"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
loadRelativeToScript
(
'
callgraph
.
js
'
)
;
loadRelativeToScript
(
'
dumpCFG
.
js
'
)
;
function
checkExternalFunction
(
entry
)
{
var
whitelist
=
[
"
__builtin_clz
"
"
__builtin_expect
"
"
isprint
"
"
ceilf
"
"
floorf
"
/
^
rusturl
/
"
memcmp
"
"
strcmp
"
"
fmod
"
"
floor
"
"
ceil
"
"
atof
"
/
memchr
/
"
strlen
"
/
Servo_DeclarationBlock_GetCssText
/
/
nsIFrame
:
:
AppendOwnedAnonBoxes
/
/
^
__atomic_fetch_
/
/
^
__atomic_load_
/
/
^
__atomic_thread_fence
/
]
;
if
(
entry
.
matches
(
whitelist
)
)
return
;
const
simpleWrites
=
[
"
memcpy
"
"
memset
"
"
memmove
"
]
;
if
(
entry
.
isSafeArgument
(
1
)
&
&
simpleWrites
.
includes
(
entry
.
name
)
)
return
;
dumpError
(
entry
null
"
External
function
"
)
;
}
function
hasThreadsafeReferenceCounts
(
entry
regexp
)
{
var
whitelist
=
[
"
nsIRunnable
"
"
nsIAtom
"
"
nsIPermissionManager
"
"
nsIURI
"
]
;
var
match
=
regexp
.
exec
(
entry
.
name
)
;
return
match
&
&
nameMatchesArray
(
match
[
1
]
whitelist
)
;
}
function
checkOverridableVirtualCall
(
entry
location
callee
)
{
if
(
callee
!
=
"
nsISupports
.
AddRef
"
&
&
callee
!
=
"
nsISupports
.
Release
"
)
return
;
if
(
hasThreadsafeReferenceCounts
(
entry
/
:
:
~
?
nsCOMPtr
\
(
.
*
?
\
[
with
T
=
(
.
*
?
)
\
]
/
)
)
return
;
if
(
hasThreadsafeReferenceCounts
(
entry
/
RefPtrTraits
.
*
?
:
:
Release
.
*
?
\
[
with
U
=
(
.
*
?
)
\
]
/
)
)
return
;
if
(
hasThreadsafeReferenceCounts
(
entry
/
nsCOMPtr
<
T
>
:
:
assign_assuming_AddRef
.
*
?
\
[
with
T
=
(
.
*
?
)
\
]
/
)
)
return
;
if
(
hasThreadsafeReferenceCounts
(
entry
/
nsCOMPtr
<
T
>
:
:
assign_with_AddRef
.
*
?
\
[
with
T
=
(
.
*
?
)
\
]
/
)
)
return
;
var
whitelist
=
[
"
Gecko_AddRefAtom
"
"
Gecko_ReleaseAtom
"
/
nsPrincipal
:
:
Get
/
/
CounterStylePtr
:
:
Reset
/
]
;
if
(
entry
.
matches
(
whitelist
)
)
return
;
dumpError
(
entry
location
"
AddRef
/
Release
on
nsISupports
"
)
;
}
function
checkIndirectCall
(
entry
location
callee
)
{
var
name
=
entry
.
name
;
if
(
/
PLDHashTable
/
.
test
(
name
)
&
&
(
/
matchEntry
/
.
test
(
callee
)
|
|
/
hashKey
/
.
test
(
callee
)
)
)
return
;
if
(
/
PL_HashTable
/
.
test
(
name
)
&
&
/
keyCompare
/
.
test
(
callee
)
)
return
;
dumpError
(
entry
location
"
Indirect
call
"
+
callee
)
;
}
function
checkVariableAssignment
(
entry
location
variable
)
{
var
name
=
entry
.
name
;
dumpError
(
entry
location
"
Variable
assignment
"
+
variable
)
;
}
function
treatAsSafeArgument
(
entry
varName
csuName
)
{
var
whitelist
=
[
[
null
null
/
StyleChildrenIterator
/
]
[
null
null
/
ExplicitChildIterator
/
]
[
null
null
/
nsReadingIterator
/
]
[
/
^
Gecko_
/
null
"
nsStyleImageLayers
"
]
[
/
^
Gecko_
/
null
/
FontFamilyList
/
]
[
"
Gecko_SetNodeFlags
"
"
aNode
"
null
]
[
"
Gecko_UnsetNodeFlags
"
"
aNode
"
null
]
[
"
Gecko_CopyFontFamilyFrom
"
"
dst
"
null
]
[
"
Gecko_SetCounterStyleToName
"
"
aPtr
"
null
]
[
"
Gecko_SetCounterStyleToSymbols
"
"
aPtr
"
null
]
[
"
Gecko_SetCounterStyleToString
"
"
aPtr
"
null
]
[
"
Gecko_CopyCounterStyle
"
"
aDst
"
null
]
[
"
Gecko_SetMozBinding
"
"
aDisplay
"
null
]
[
/
ClassOrClassList
/
/
aClass
/
null
]
[
"
Gecko_GetAtomAsUTF16
"
"
aLength
"
null
]
[
"
Gecko_CopyMozBindingFrom
"
"
aDest
"
null
]
[
"
Gecko_SetNullImageValue
"
"
aImage
"
null
]
[
"
Gecko_SetGradientImageValue
"
"
aImage
"
null
]
[
"
Gecko_SetImageOrientation
"
"
aVisibility
"
null
]
[
"
Gecko_SetImageOrientationAsFromImage
"
"
aVisibility
"
null
]
[
"
Gecko_CopyImageOrientationFrom
"
"
aDst
"
null
]
[
"
Gecko_SetImageElement
"
"
aImage
"
null
]
[
"
Gecko_SetLayerImageImageValue
"
"
aImage
"
null
]
[
"
Gecko_CopyImageValueFrom
"
"
aImage
"
null
]
[
"
Gecko_SetCursorArrayLength
"
"
aStyleUI
"
null
]
[
"
Gecko_CopyCursorArrayFrom
"
"
aDest
"
null
]
[
"
Gecko_SetCursorImageValue
"
"
aCursor
"
null
]
[
"
Gecko_SetListStyleImageImageValue
"
"
aList
"
null
]
[
"
Gecko_SetListStyleImageNone
"
"
aList
"
null
]
[
"
Gecko_CopyListStyleImageFrom
"
"
aList
"
null
]
[
"
Gecko_ClearStyleContents
"
"
aContent
"
null
]
[
"
Gecko_CopyStyleContentsFrom
"
"
aContent
"
null
]
[
"
Gecko_CopyStyleGridTemplateValues
"
"
aGridTemplate
"
null
]
[
"
Gecko_ResetStyleCoord
"
null
null
]
[
"
Gecko_CopyClipPathValueFrom
"
"
aDst
"
null
]
[
"
Gecko_DestroyClipPath
"
"
aClip
"
null
]
[
"
Gecko_ResetFilters
"
"
effects
"
null
]
[
"
Gecko_CopyFiltersFrom
"
"
aDest
"
null
]
[
/
Gecko_CSSValue_Set
/
"
aCSSValue
"
null
]
[
"
Gecko_CSSValue_Drop
"
"
aCSSValue
"
null
]
[
"
Gecko_CSSFontFaceRule_GetCssText
"
"
aResult
"
null
]
[
"
Gecko_EnsureTArrayCapacity
"
"
aArray
"
null
]
[
"
Gecko_ClearPODTArray
"
"
aArray
"
null
]
[
"
Gecko_SetStyleGridTemplate
"
"
aGridTemplate
"
null
]
[
"
Gecko_ResizeTArrayForStrings
"
"
aArray
"
null
]
[
"
Gecko_ClearAndResizeStyleContents
"
"
aContent
"
null
]
[
/
Gecko_ClearAndResizeCounter
/
"
aContent
"
null
]
[
/
Gecko_CopyCounter
.
*
?
From
/
"
aContent
"
null
]
[
/
Gecko_SetContentDataImageValue
/
"
aList
"
null
]
[
/
Gecko_SetContentData
/
"
aContent
"
null
]
[
"
Gecko_SetCounterFunction
"
"
aContent
"
null
]
[
/
Gecko_EnsureStyle
.
*
?
ArrayLength
/
"
aArray
"
null
]
[
"
Gecko_GetOrCreateKeyframeAtStart
"
"
aKeyframes
"
null
]
[
"
Gecko_GetOrCreateInitialKeyframe
"
"
aKeyframes
"
null
]
[
"
Gecko_GetOrCreateFinalKeyframe
"
"
aKeyframes
"
null
]
[
"
Gecko_AppendPropertyValuePair
"
"
aProperties
"
null
]
[
"
Gecko_SetStyleCoordCalcValue
"
null
null
]
[
"
Gecko_StyleClipPath_SetURLValue
"
"
aClip
"
null
]
[
"
Gecko_nsStyleFilter_SetURLValue
"
"
aEffects
"
null
]
[
"
Gecko_nsStyleSVGPaint_CopyFrom
"
"
aDest
"
null
]
[
"
Gecko_nsStyleSVGPaint_SetURLValue
"
"
aPaint
"
null
]
[
"
Gecko_nsStyleSVGPaint_Reset
"
"
aPaint
"
null
]
[
"
Gecko_nsStyleSVG_SetDashArrayLength
"
"
aSvg
"
null
]
[
"
Gecko_nsStyleSVG_CopyDashArray
"
"
aDst
"
null
]
[
"
Gecko_nsStyleFont_SetLang
"
"
aFont
"
null
]
[
"
Gecko_nsStyleFont_CopyLangFrom
"
"
aFont
"
null
]
[
"
Gecko_MatchStringArgPseudo
"
"
aSetSlowSelectorFlag
"
null
]
[
"
Gecko_ClearWillChange
"
"
aDisplay
"
null
]
[
"
Gecko_AppendWillChange
"
"
aDisplay
"
null
]
[
"
Gecko_CopyWillChangeFrom
"
"
aDest
"
null
]
[
"
Gecko_InitializeImageCropRect
"
"
aImage
"
null
]
[
"
Gecko_CopyShapeSourceFrom
"
"
aDst
"
null
]
[
"
Gecko_DestroyShapeSource
"
"
aShape
"
null
]
[
"
Gecko_StyleShapeSource_SetURLValue
"
"
aShape
"
null
]
[
"
Gecko_nsFont_InitSystem
"
"
aDest
"
null
]
[
"
Gecko_nsFont_SetFontFeatureValuesLookup
"
"
aFont
"
null
]
[
"
Gecko_nsFont_ResetFontFeatureValuesLookup
"
"
aFont
"
null
]
[
"
Gecko_nsStyleFont_FixupNoneGeneric
"
"
aFont
"
null
]
[
"
Gecko_StyleTransition_SetUnsupportedProperty
"
"
aTransition
"
null
]
[
"
Gecko_AddPropertyToSet
"
"
aPropertySet
"
null
]
[
"
Gecko_CalcStyleDifference
"
"
aAnyStyleChanged
"
null
]
[
"
Gecko_nsStyleSVG_CopyContextProperties
"
"
aDst
"
null
]
[
"
Gecko_nsStyleFont_PrefillDefaultForGeneric
"
"
aFont
"
null
]
[
"
Gecko_nsStyleSVG_SetContextPropertiesLength
"
"
aSvg
"
null
]
[
"
Gecko_ClearAlternateValues
"
"
aFont
"
null
]
[
"
Gecko_AppendAlternateValues
"
"
aFont
"
null
]
[
"
Gecko_CopyAlternateValuesFrom
"
"
aDest
"
null
]
[
"
Gecko_CounterStyle_GetName
"
"
aResult
"
null
]
[
"
Gecko_CounterStyle_GetSingleString
"
"
aResult
"
null
]
[
"
Gecko_EnsureMozBorderColors
"
"
aBorder
"
null
]
[
"
Gecko_ClearMozBorderColors
"
"
aBorder
"
null
]
[
"
Gecko_AppendMozBorderColors
"
"
aBorder
"
null
]
[
"
Gecko_CopyMozBorderColors
"
"
aDest
"
null
]
]
;
for
(
var
[
entryMatch
varMatch
csuMatch
]
of
whitelist
)
{
assert
(
entryMatch
|
|
varMatch
|
|
csuMatch
)
;
if
(
entryMatch
&
&
!
nameMatches
(
entry
.
name
entryMatch
)
)
continue
;
if
(
varMatch
&
&
!
nameMatches
(
varName
varMatch
)
)
continue
;
if
(
csuMatch
&
&
(
!
csuName
|
|
!
nameMatches
(
csuName
csuMatch
)
)
)
continue
;
return
true
;
}
return
false
;
}
function
isSafeAssignment
(
entry
edge
variable
)
{
if
(
edge
.
Kind
!
=
'
Assign
'
)
return
false
;
var
[
mangled
unmangled
]
=
splitFunction
(
entry
.
name
)
;
if
(
unmangled
.
includes
(
"
mozilla
:
:
LangGroupFontPrefs
:
:
Initialize
"
)
&
&
variable
=
=
'
font
'
)
{
const
[
lhs
rhs
]
=
edge
.
Exp
;
const
{
Kind
Exp
:
[
{
Kind
:
indexKind
Exp
:
[
collection
index
]
}
]
}
=
rhs
;
if
(
Kind
=
=
'
Drf
'
&
&
indexKind
=
=
'
Index
'
&
&
collection
.
Kind
=
=
'
Var
'
&
&
collection
.
Variable
.
Name
[
0
]
=
=
'
fontTypes
'
)
{
return
entry
.
isSafeArgument
(
0
)
;
}
}
return
false
;
}
function
checkFieldWrite
(
entry
location
fields
)
{
var
name
=
entry
.
name
;
for
(
var
field
of
fields
)
{
if
(
/
already_AddRefed
.
*
?
.
mRawPtr
/
.
test
(
field
)
)
return
;
if
(
/
nsCOMPtr
<
.
*
?
>
.
mRawPtr
/
.
test
(
field
)
)
return
;
}
var
str
=
"
"
;
for
(
var
field
of
fields
)
str
+
=
"
"
+
field
;
dumpError
(
entry
location
"
Field
write
"
+
str
)
;
}
function
checkDereferenceWrite
(
entry
location
variable
)
{
var
name
=
entry
.
name
;
if
(
/
Maybe
.
*
?
:
:
emplace
/
.
test
(
name
)
&
&
entry
.
isSafeArgument
(
0
)
)
return
;
if
(
/
UniquePtr
.
*
?
:
:
reset
/
.
test
(
name
)
&
&
entry
.
isSafeArgument
(
0
)
)
return
;
if
(
hasThreadsafeReferenceCounts
(
entry
/
nsCOMPtr
<
T
>
:
:
swap
\
(
.
*
?
\
[
with
T
=
(
.
*
?
)
\
]
/
)
)
return
;
dumpError
(
entry
location
"
Dereference
write
"
+
(
variable
?
variable
:
"
<
unknown
>
"
)
)
;
}
function
ignoreCallEdge
(
entry
callee
)
{
var
name
=
entry
.
name
;
if
(
/
nsPropertyTable
:
:
GetPropertyInternal
/
.
test
(
callee
)
&
&
/
nsPropertyTable
:
:
GetProperty
/
.
test
(
name
)
)
{
return
true
;
}
if
(
/
nsIDocument
:
:
GetExtraPropertyTable
/
.
test
(
callee
)
&
&
/
nsIDocument
:
:
PropertyTable
/
.
test
(
name
)
&
&
entry
.
isSafeArgument
(
1
)
)
{
return
true
;
}
if
(
/
nsStyleList
:
:
SetCounterStyle
/
.
test
(
callee
)
)
return
true
;
if
(
/
CachedBorderImageData
:
:
PurgeCachedImages
/
.
test
(
callee
)
&
&
/
nsStyleImage
:
:
/
.
test
(
name
)
&
&
entry
.
isSafeArgument
(
0
)
)
{
return
true
;
}
if
(
/
nsCSSValue
:
:
Array
:
:
AddRef
/
.
test
(
callee
)
&
&
/
nsStyleContentData
:
:
SetCounters
/
.
test
(
name
)
&
&
entry
.
isSafeArgument
(
2
)
)
{
return
true
;
}
if
(
/
nsIFrame
:
:
AppendOwnedAnonBoxes
/
.
test
(
callee
)
&
&
/
AllChildrenIterator
:
:
AppendNativeAnonymousChildren
/
.
test
(
name
)
)
{
return
true
;
}
if
(
/
:
:
SetName
/
.
test
(
callee
)
&
&
/
:
:
UnlabeledDispatch
/
.
test
(
name
)
)
{
return
true
;
}
if
(
name
=
=
"
Gecko_nsFont_InitSystem
"
|
|
name
=
=
"
Gecko_GetFontMetrics
"
|
|
name
=
=
"
Gecko_nsStyleFont_FixupMinFontSize
"
|
|
/
ThreadSafeGetDefaultFontHelper
/
.
test
(
name
)
)
{
return
true
;
}
return
false
;
}
function
ignoreContents
(
entry
)
{
var
whitelist
=
[
"
abort
"
/
MOZ_ReportAssertionFailure
/
/
MOZ_ReportCrash
/
/
MOZ_CrashPrintf
/
/
AnnotateMozCrashReason
/
/
InvalidArrayIndex_CRASH
/
/
NS_ABORT_OOM
/
"
NS_DebugBreak
"
/
mozalloc_handle_oom
/
/
^
NS_Log
/
/
log_print
/
/
LazyLogModule
:
:
operator
/
/
SprintfLiteral
/
"
PR_smprintf
"
"
PR_smprintf_free
"
/
NS_DispatchToMainThread
/
/
NS_ReleaseOnMainThreadSystemGroup
/
/
NS_NewRunnableFunction
/
/
NS_Atomize
/
/
nsCSSValue
:
:
BufferFromString
/
/
NS_strdup
/
/
Assert_NoQueryNeeded
/
/
imgRequestProxy
:
:
GetProgressTracker
/
/
Smprintf
/
"
malloc
"
"
free
"
"
realloc
"
"
jemalloc_thread_local_arena
"
/
profiler_register_thread
/
/
profiler_unregister_thread
/
/
EmptyString
\
(
\
)
/
/
nsCSSProps
:
:
LookupPropertyValue
/
/
nsCSSProps
:
:
ValueToKeyword
/
/
nsCSSKeywords
:
:
GetStringValue
/
"
Gecko_GetOrCreateKeyframeAtStart
"
"
Gecko_GetOrCreateInitialKeyframe
"
"
Gecko_GetOrCreateFinalKeyframe
"
"
Gecko_NewStyleQuoteValues
"
"
Gecko_NewCSSValueSharedList
"
"
Gecko_NewNoneTransform
"
"
Gecko_NewGridTemplateAreasValue
"
/
nsCSSValue
:
:
SetCalcValue
/
/
CSSValueSerializeCalcOps
:
:
Append
/
"
Gecko_CSSValue_SetFunction
"
"
Gecko_CSSValue_SetArray
"
"
Gecko_CSSValue_InitSharedList
"
"
Gecko_EnsureMozBorderColors
"
"
Gecko_ClearMozBorderColors
"
"
Gecko_AppendMozBorderColors
"
"
Gecko_CopyMozBorderColors
"
"
Gecko_SetNullImageValue
"
/
nsStyleContext
:
:
PeekStyle
/
/
UndisplayedMap
:
:
GetEntryFor
/
/
EffectCompositor
:
:
GetServoAnimationRule
/
/
LookAndFeel
:
:
GetColor
/
"
Gecko_CopyStyleContentsFrom
"
"
Gecko_CSSValue_SetPixelValue
"
"
Gecko_UnsetDirtyStyleAttr
"
/
nsCSSPropertyIDSet
:
:
AddProperty
/
]
;
if
(
entry
.
matches
(
whitelist
)
)
return
true
;
if
(
entry
.
isSafeArgument
(
0
)
)
{
var
heapWhitelist
=
[
/
nsTArray_Impl
.
*
?
:
:
AppendElement
/
/
nsTArray_Impl
.
*
?
:
:
RemoveElementsAt
/
/
nsTArray_Impl
.
*
?
:
:
ReplaceElementsAt
/
/
nsTArray_Impl
.
*
?
:
:
InsertElementsAt
/
/
nsTArray_Impl
.
*
?
:
:
SetCapacity
/
/
nsTArray_base
.
*
?
:
:
EnsureCapacity
/
/
nsTArray_base
.
*
?
:
:
ShiftData
/
/
AutoTArray
.
*
?
:
:
Init
/
/
nsTSubstring
<
T
>
:
:
SetCapacity
/
/
nsTSubstring
<
T
>
:
:
SetLength
/
/
nsTSubstring
<
T
>
:
:
Assign
/
/
nsTSubstring
<
T
>
:
:
Append
/
/
nsTSubstring
<
T
>
:
:
Replace
/
/
nsTSubstring
<
T
>
:
:
Trim
/
/
nsTSubstring
<
T
>
:
:
Truncate
/
/
nsTSubstring
<
T
>
:
:
StripTaggedASCII
/
/
nsTSubstring
<
T
>
:
:
operator
=
/
/
nsTAutoStringN
<
T
N
>
:
:
nsTAutoStringN
/
/
nsTFixedString
<
T
>
:
:
nsTFixedString
/
/
nsCOMArray_base
:
:
SetCapacity
/
/
nsCOMArray_base
:
:
Clear
/
/
nsCOMArray_base
:
:
AppendElement
/
/
mozilla
:
:
UniquePtr
/
/
nsStyleImage
:
:
DoCopy
/
]
;
if
(
entry
.
matches
(
heapWhitelist
)
)
return
true
;
}
if
(
entry
.
isSafeArgument
(
1
)
)
{
var
firstArgWhitelist
=
[
/
nsTextFormatter
:
:
snprintf
/
/
nsTextFormatter
:
:
ssprintf
/
/
_ASCIIToUpperInSitu
/
/
FillImageLayerList
/
/
FillImageLayerPositionCoordList
/
]
;
if
(
entry
.
matches
(
firstArgWhitelist
)
)
return
true
;
}
if
(
entry
.
isSafeArgument
(
2
)
)
{
var
secondArgWhitelist
=
[
/
nsStringBuffer
:
:
ToString
/
/
AppendUTF
\
d
+
toUTF
\
d
+
/
/
AppendASCIItoUTF
\
d
+
/
]
;
if
(
entry
.
matches
(
secondArgWhitelist
)
)
return
true
;
}
return
false
;
}
function
variableName
(
variable
)
{
return
(
variable
&
&
variable
.
Name
)
?
variable
.
Name
[
0
]
:
null
;
}
function
stripFields
(
exp
)
{
var
fields
=
[
]
;
while
(
true
)
{
if
(
exp
.
Kind
=
=
"
Index
"
)
{
exp
=
exp
.
Exp
[
0
]
;
continue
;
}
if
(
exp
.
Kind
=
=
"
Fld
"
)
{
var
csuName
=
exp
.
Field
.
FieldCSU
.
Type
.
Name
;
var
fieldName
=
exp
.
Field
.
Name
[
0
]
;
assert
(
csuName
&
&
fieldName
)
;
fields
.
push
(
csuName
+
"
.
"
+
fieldName
)
;
exp
=
exp
.
Exp
[
0
]
;
continue
;
}
break
;
}
return
[
exp
fields
]
;
}
function
isLocalVariable
(
variable
)
{
switch
(
variable
.
Kind
)
{
case
"
Return
"
:
case
"
Temp
"
:
case
"
Local
"
:
case
"
Arg
"
:
return
true
;
}
return
false
;
}
function
isDirectCall
(
edge
regexp
)
{
return
edge
.
Kind
=
=
"
Call
"
&
&
edge
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
&
&
regexp
.
test
(
variableName
(
edge
.
Exp
[
0
]
.
Variable
)
)
;
}
function
isZero
(
exp
)
{
return
exp
.
Kind
=
=
"
Int
"
&
&
exp
.
String
=
=
"
0
"
;
}
function
WorklistEntry
(
name
safeArguments
stack
parameterNames
)
{
this
.
name
=
name
;
this
.
safeArguments
=
safeArguments
;
this
.
stack
=
stack
;
this
.
parameterNames
=
parameterNames
;
}
WorklistEntry
.
prototype
.
readable
=
function
(
)
{
const
[
mangled
readable
]
=
splitFunction
(
this
.
name
)
;
return
readable
;
}
WorklistEntry
.
prototype
.
mangledName
=
function
(
)
{
var
str
=
this
.
name
;
for
(
var
safe
of
this
.
safeArguments
)
str
+
=
"
SAFE
"
+
safe
;
return
str
;
}
WorklistEntry
.
prototype
.
isSafeArgument
=
function
(
index
)
{
for
(
var
safe
of
this
.
safeArguments
)
{
if
(
index
=
=
safe
)
return
true
;
}
return
false
;
}
WorklistEntry
.
prototype
.
setParameterName
=
function
(
index
name
)
{
this
.
parameterNames
[
index
]
=
name
;
}
WorklistEntry
.
prototype
.
addSafeArgument
=
function
(
index
)
{
if
(
this
.
isSafeArgument
(
index
)
)
return
;
this
.
safeArguments
.
push
(
index
)
;
this
.
safeArguments
.
sort
(
)
;
}
function
safeArgumentIndex
(
variable
)
{
if
(
variable
.
Kind
=
=
"
This
"
)
return
0
;
if
(
variable
.
Kind
=
=
"
Arg
"
)
return
variable
.
Index
+
1
;
return
-
1
;
}
function
nameMatches
(
name
match
)
{
if
(
typeof
match
=
=
"
string
"
)
{
if
(
name
=
=
match
)
return
true
;
}
else
{
assert
(
match
instanceof
RegExp
)
;
if
(
match
.
test
(
name
)
)
return
true
;
}
return
false
;
}
function
nameMatchesArray
(
name
matchArray
)
{
for
(
var
match
of
matchArray
)
{
if
(
nameMatches
(
name
match
)
)
return
true
;
}
return
false
;
}
WorklistEntry
.
prototype
.
matches
=
function
(
matchArray
)
{
return
nameMatchesArray
(
this
.
name
matchArray
)
;
}
function
CallSite
(
callee
safeArguments
location
parameterNames
)
{
this
.
callee
=
callee
;
this
.
safeArguments
=
safeArguments
;
this
.
location
=
location
;
this
.
parameterNames
=
parameterNames
;
}
CallSite
.
prototype
.
safeString
=
function
(
)
{
if
(
this
.
safeArguments
.
length
)
{
var
str
=
"
"
;
for
(
var
i
=
0
;
i
<
this
.
safeArguments
.
length
;
i
+
+
)
{
var
arg
=
this
.
safeArguments
[
i
]
;
if
(
arg
in
this
.
parameterNames
)
str
+
=
"
"
+
this
.
parameterNames
[
arg
]
;
else
str
+
=
"
<
"
+
(
(
arg
=
=
0
)
?
"
this
"
:
"
arg
"
+
(
arg
-
1
)
)
+
"
>
"
;
}
return
"
#
#
#
SafeArguments
:
"
+
str
;
}
return
"
"
;
}
var
errorCount
=
0
;
var
errorLimit
=
100
;
var
errorHeader
;
var
startTime
=
new
Date
;
function
elapsedTime
(
)
{
var
seconds
=
(
new
Date
-
startTime
)
/
1000
;
return
"
[
"
+
seconds
.
toFixed
(
2
)
+
"
s
]
"
;
}
var
options
=
parse_options
(
[
{
name
:
'
-
-
strip
-
prefix
'
default
:
os
.
getenv
(
'
SOURCE
'
)
|
|
'
'
type
:
'
string
'
}
{
name
:
'
-
-
add
-
prefix
'
default
:
os
.
getenv
(
'
URLPREFIX
'
)
|
|
'
'
type
:
'
string
'
}
{
name
:
'
-
-
verbose
'
type
:
'
bool
'
}
]
)
;
function
add_trailing_slash
(
str
)
{
if
(
str
=
=
'
'
)
return
str
;
return
str
.
endsWith
(
"
/
"
)
?
str
:
str
+
"
/
"
;
}
var
removePrefix
=
add_trailing_slash
(
options
.
strip_prefix
)
;
var
addPrefix
=
add_trailing_slash
(
options
.
add_prefix
)
;
if
(
options
.
verbose
)
{
printErr
(
Removing
prefix
{
removePrefix
}
from
paths
)
;
printErr
(
Prepending
{
addPrefix
}
to
paths
)
;
}
print
(
elapsedTime
(
)
+
"
Loading
types
.
.
.
"
)
;
if
(
os
.
getenv
(
"
TYPECACHE
"
)
)
loadTypesWithCache
(
'
src_comp
.
xdb
'
os
.
getenv
(
"
TYPECACHE
"
)
)
;
else
loadTypes
(
'
src_comp
.
xdb
'
)
;
print
(
elapsedTime
(
)
+
"
Starting
analysis
.
.
.
"
)
;
var
reachable
=
{
}
;
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_body
.
xdb
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
;
var
maxStream
=
xdb
.
max_data_stream
(
)
;
var
roots
=
[
]
;
var
[
flag
arg
]
=
scriptArgs
;
if
(
flag
&
&
(
flag
=
=
'
-
f
'
|
|
flag
=
=
'
-
-
function
'
)
)
{
roots
=
[
arg
]
;
}
else
{
for
(
var
bodyIndex
=
minStream
;
bodyIndex
<
=
maxStream
;
bodyIndex
+
+
)
{
var
key
=
xdb
.
read_key
(
bodyIndex
)
;
var
name
=
key
.
readString
(
)
;
if
(
/
^
Gecko_
/
.
test
(
name
)
)
{
var
data
=
xdb
.
read_entry
(
key
)
;
if
(
/
ServoBindings
.
cpp
/
.
test
(
data
.
readString
(
)
)
)
roots
.
push
(
name
)
;
xdb
.
free_string
(
data
)
;
}
xdb
.
free_string
(
key
)
;
}
}
print
(
elapsedTime
(
)
+
"
Found
"
+
roots
.
length
+
"
roots
.
"
)
;
for
(
var
i
=
0
;
i
<
roots
.
length
;
i
+
+
)
{
var
root
=
roots
[
i
]
;
errorHeader
=
elapsedTime
(
)
+
"
#
"
+
(
i
+
1
)
+
"
Analyzing
"
+
root
+
"
.
.
.
"
;
try
{
processRoot
(
root
)
;
}
catch
(
e
)
{
if
(
e
!
=
"
Error
!
"
)
throw
e
;
}
}
print
(
{
elapsedTime
(
)
}
Completed
analysis
found
{
errorCount
}
/
{
errorLimit
}
allowed
errors
)
;
var
currentBody
;
var
assignments
;
var
reachableLoops
;
function
dumpError
(
entry
location
text
)
{
if
(
errorHeader
)
{
print
(
errorHeader
)
;
errorHeader
=
undefined
;
}
var
stack
=
entry
.
stack
;
print
(
"
Error
:
"
+
text
)
;
print
(
"
Location
:
"
+
entry
.
name
+
(
location
?
"
"
+
location
:
"
"
)
+
stack
[
0
]
.
safeString
(
)
)
;
print
(
"
Stack
Trace
:
"
)
;
assert
(
stack
[
stack
.
length
-
1
]
.
location
=
=
null
)
;
for
(
var
i
=
0
;
i
<
stack
.
length
-
1
;
i
+
+
)
print
(
stack
[
i
+
1
]
.
callee
+
"
"
+
stack
[
i
]
.
location
+
stack
[
i
+
1
]
.
safeString
(
)
)
;
print
(
"
\
n
"
)
;
if
(
+
+
errorCount
=
=
errorLimit
)
{
print
(
"
Maximum
number
of
errors
encountered
exiting
.
.
.
"
)
;
quit
(
)
;
}
throw
"
Error
!
"
;
}
function
variableAssignRhs
(
edge
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
&
&
edge
.
Exp
[
1
]
.
Kind
=
=
"
Drf
"
&
&
edge
.
Exp
[
1
]
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
)
{
var
variable
=
edge
.
Exp
[
1
]
.
Exp
[
0
]
.
Variable
;
if
(
isLocalVariable
(
variable
)
)
return
variable
;
}
return
null
;
}
function
processAssign
(
entry
location
lhs
edge
)
{
var
fields
;
[
lhs
fields
]
=
stripFields
(
lhs
)
;
switch
(
lhs
.
Kind
)
{
case
"
Var
"
:
var
name
=
variableName
(
lhs
.
Variable
)
;
if
(
isLocalVariable
(
lhs
.
Variable
)
)
{
var
rhsVariable
=
variableAssignRhs
(
edge
)
;
if
(
rhsVariable
)
{
var
rhsEdge
=
singleAssignment
(
variableName
(
rhsVariable
)
)
;
if
(
rhsEdge
)
edge
=
rhsEdge
;
}
if
(
!
(
name
in
assignments
)
)
assignments
[
name
]
=
[
]
;
assignments
[
name
]
.
push
(
edge
)
;
}
else
{
checkVariableAssignment
(
entry
location
name
)
;
}
return
;
case
"
Drf
"
:
var
variable
=
null
;
if
(
lhs
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
)
{
variable
=
lhs
.
Exp
[
0
]
.
Variable
;
if
(
isSafeVariable
(
entry
variable
)
)
return
;
}
else
if
(
lhs
.
Exp
[
0
]
.
Kind
=
=
"
Fld
"
)
{
const
{
Type
:
{
Kind
Type
:
fieldType
}
FieldCSU
:
{
Type
:
{
Kind
:
containerTypeKind
Name
:
containerTypeName
}
}
}
=
lhs
.
Exp
[
0
]
.
Field
;
const
[
containerExpr
]
=
lhs
.
Exp
[
0
]
.
Exp
;
if
(
containerTypeKind
=
=
'
CSU
'
&
&
Kind
=
=
'
Pointer
'
&
&
isEdgeSafeArgument
(
entry
containerExpr
)
&
&
isSafeMemberPointer
(
containerTypeName
fieldType
)
)
{
return
;
}
}
if
(
fields
.
length
)
checkFieldWrite
(
entry
location
fields
)
;
else
checkDereferenceWrite
(
entry
location
variableName
(
variable
)
)
;
return
;
case
"
Int
"
:
if
(
isZero
(
lhs
)
)
{
return
;
}
}
dumpError
(
entry
location
"
Unknown
assignment
"
+
JSON
.
stringify
(
lhs
)
)
;
}
function
get_location
(
rawLocation
)
{
const
filename
=
rawLocation
.
CacheString
.
replace
(
removePrefix
'
'
)
;
return
addPrefix
+
filename
+
"
#
"
+
rawLocation
.
Line
;
}
function
process
(
entry
body
addCallee
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
return
;
if
(
"
DefineVariable
"
in
body
)
{
for
(
var
defvar
of
body
.
DefineVariable
)
{
var
index
=
safeArgumentIndex
(
defvar
.
Variable
)
;
if
(
index
>
=
0
)
{
var
varName
=
index
?
variableName
(
defvar
.
Variable
)
:
"
this
"
;
assert
(
varName
)
;
entry
.
setParameterName
(
index
varName
)
;
var
csuName
=
null
;
var
type
=
defvar
.
Type
;
if
(
type
.
Kind
=
=
"
Pointer
"
&
&
type
.
Type
.
Kind
=
=
"
CSU
"
)
csuName
=
type
.
Type
.
Name
;
if
(
treatAsSafeArgument
(
entry
varName
csuName
)
)
entry
.
addSafeArgument
(
index
)
;
}
}
}
var
nonMainThreadPoints
=
[
]
;
nonMainThreadPoints
[
body
.
Index
[
0
]
]
=
true
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
!
(
edge
.
Index
[
0
]
in
nonMainThreadPoints
)
)
continue
;
var
location
=
get_location
(
body
.
PPoint
[
edge
.
Index
[
0
]
-
1
]
.
Location
)
;
var
callees
=
getCallees
(
edge
)
;
for
(
var
callee
of
callees
)
{
switch
(
callee
.
kind
)
{
case
"
direct
"
:
var
safeArguments
=
getEdgeSafeArguments
(
entry
edge
callee
.
name
)
;
addCallee
(
new
CallSite
(
callee
.
name
safeArguments
location
{
}
)
)
;
break
;
case
"
resolved
-
field
"
:
break
;
case
"
field
"
:
var
field
=
callee
.
csu
+
"
.
"
+
callee
.
field
;
if
(
callee
.
isVirtual
)
checkOverridableVirtualCall
(
entry
location
field
)
;
else
checkIndirectCall
(
entry
location
field
)
;
break
;
case
"
indirect
"
:
checkIndirectCall
(
entry
location
callee
.
variable
)
;
break
;
default
:
dumpError
(
entry
location
"
Unknown
call
"
+
callee
.
kind
)
;
break
;
}
}
var
fallthrough
=
true
;
if
(
edge
.
Kind
=
=
"
Assign
"
)
{
assert
(
edge
.
Exp
.
length
=
=
2
)
;
processAssign
(
entry
location
edge
.
Exp
[
0
]
edge
)
;
}
else
if
(
edge
.
Kind
=
=
"
Call
"
)
{
assert
(
edge
.
Exp
.
length
<
=
2
)
;
if
(
edge
.
Exp
.
length
=
=
2
)
processAssign
(
entry
location
edge
.
Exp
[
1
]
edge
)
;
if
(
isDirectCall
(
edge
/
MOZ_ReportAssertionFailure
/
)
)
fallthrough
=
false
;
}
else
if
(
edge
.
Kind
=
=
"
Loop
"
)
{
reachableLoops
[
edge
.
BlockId
.
Loop
]
=
true
;
}
else
if
(
edge
.
Kind
=
=
"
Assume
"
)
{
if
(
testFailsOffMainThread
(
edge
.
Exp
[
0
]
edge
.
PEdgeAssumeNonZero
)
)
fallthrough
=
false
;
}
if
(
fallthrough
)
nonMainThreadPoints
[
edge
.
Index
[
1
]
]
=
true
;
}
}
function
maybeProcessMissingFunction
(
entry
addCallee
)
{
var
name
=
entry
.
name
;
if
(
name
.
indexOf
(
"
:
:
~
"
)
>
0
&
&
name
.
indexOf
(
"
(
)
"
)
>
0
)
{
var
callee
=
name
.
replace
(
"
(
)
"
"
(
int32
)
"
)
;
addCallee
(
new
CallSite
(
name
entry
.
safeArguments
entry
.
stack
[
0
]
.
location
entry
.
parameterNames
)
)
;
return
true
;
}
if
(
entry
.
mangledName
(
)
.
includes
(
"
C1E
"
)
|
|
entry
.
mangledName
(
)
.
includes
(
"
C1I
"
)
)
{
var
callee
=
name
.
replace
(
"
C1E
"
"
C4E
"
)
.
replace
(
"
C1I
"
"
C4I
"
)
;
addCallee
(
new
CallSite
(
name
entry
.
safeArguments
entry
.
stack
[
0
]
.
location
entry
.
parameterNames
)
)
;
return
true
;
}
if
(
/
mozilla
:
:
dom
:
:
Element
/
.
test
(
name
)
)
{
var
callee
=
name
.
replace
(
"
mozilla
:
:
dom
:
:
Element
"
"
nsIDocument
:
:
Element
"
)
;
addCallee
(
new
CallSite
(
name
entry
.
safeArguments
entry
.
stack
[
0
]
.
location
entry
.
parameterNames
)
)
;
return
true
;
}
if
(
/
\
nsTextFrame
*
/
.
test
(
name
)
)
{
var
callee
=
name
.
replace
(
"
nsTextFrame
"
"
nsIFrame
"
)
;
addCallee
(
new
CallSite
(
name
entry
.
safeArguments
entry
.
stack
[
0
]
.
location
entry
.
parameterNames
)
)
;
return
true
;
}
return
false
;
}
function
processRoot
(
name
)
{
var
safeArguments
=
[
]
;
var
parameterNames
=
{
}
;
var
worklist
=
[
new
WorklistEntry
(
name
safeArguments
[
new
CallSite
(
name
safeArguments
null
parameterNames
)
]
parameterNames
)
]
;
while
(
worklist
.
length
>
0
)
{
var
entry
=
worklist
.
pop
(
)
;
if
(
entry
.
mangledName
(
)
in
reachable
)
continue
;
reachable
[
entry
.
mangledName
(
)
]
=
true
;
if
(
ignoreContents
(
entry
)
)
continue
;
var
data
=
xdb
.
read_entry
(
entry
.
name
)
;
var
dataString
=
data
.
readString
(
)
;
var
callees
=
[
]
;
if
(
dataString
.
length
)
{
assignments
=
{
}
;
reachableLoops
=
{
}
;
var
bodies
=
JSON
.
parse
(
dataString
)
.
reverse
(
)
;
for
(
var
body
of
bodies
)
{
if
(
!
body
.
BlockId
.
Loop
|
|
body
.
BlockId
.
Loop
in
reachableLoops
)
{
currentBody
=
body
;
process
(
entry
body
Array
.
prototype
.
push
.
bind
(
callees
)
)
;
}
}
}
else
{
if
(
!
maybeProcessMissingFunction
(
entry
Array
.
prototype
.
push
.
bind
(
callees
)
)
)
checkExternalFunction
(
entry
)
;
}
xdb
.
free_string
(
data
)
;
for
(
var
callee
of
callees
)
{
if
(
!
ignoreCallEdge
(
entry
callee
.
callee
)
)
{
var
nstack
=
[
callee
.
.
.
entry
.
stack
]
;
worklist
.
push
(
new
WorklistEntry
(
callee
.
callee
callee
.
safeArguments
nstack
callee
.
parameterNames
)
)
;
}
}
}
}
function
isEdgeSafeArgument
(
entry
exp
)
{
var
fields
;
[
exp
fields
]
=
stripFields
(
exp
)
;
if
(
exp
.
Kind
=
=
"
Var
"
&
&
isLocalVariable
(
exp
.
Variable
)
)
return
true
;
if
(
exp
.
Kind
=
=
"
Drf
"
&
&
exp
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
)
{
var
variable
=
exp
.
Exp
[
0
]
.
Variable
;
return
isSafeVariable
(
entry
variable
)
;
}
if
(
isZero
(
exp
)
)
return
true
;
return
false
;
}
function
getEdgeSafeArguments
(
entry
edge
callee
)
{
assert
(
edge
.
Kind
=
=
"
Call
"
)
;
var
res
=
[
]
;
if
(
"
PEdgeCallInstance
"
in
edge
)
{
if
(
isEdgeSafeArgument
(
entry
edge
.
PEdgeCallInstance
.
Exp
)
)
res
.
push
(
0
)
;
}
if
(
"
PEdgeCallArguments
"
in
edge
)
{
var
args
=
edge
.
PEdgeCallArguments
.
Exp
;
for
(
var
i
=
0
;
i
<
args
.
length
;
i
+
+
)
{
if
(
isEdgeSafeArgument
(
entry
args
[
i
]
)
)
res
.
push
(
i
+
1
)
;
}
}
return
res
;
}
function
singleAssignment
(
name
)
{
if
(
name
in
assignments
)
{
var
edges
=
assignments
[
name
]
;
if
(
edges
.
length
=
=
1
)
return
edges
[
0
]
;
}
return
null
;
}
function
expressionValueEdge
(
exp
)
{
if
(
exp
.
Kind
=
=
"
Var
"
&
&
exp
.
Variable
.
Kind
=
=
"
Temp
"
)
return
singleAssignment
(
variableName
(
exp
.
Variable
)
)
;
return
null
;
}
function
isSafeVariable
(
entry
variable
)
{
var
index
=
safeArgumentIndex
(
variable
)
;
if
(
index
>
=
0
)
return
entry
.
isSafeArgument
(
index
)
;
if
(
variable
.
Kind
!
=
"
Temp
"
&
&
variable
.
Kind
!
=
"
Local
"
)
return
false
;
var
name
=
variableName
(
variable
)
;
if
(
!
entry
.
safeLocals
)
entry
.
safeLocals
=
new
Map
;
if
(
entry
.
safeLocals
.
has
(
name
)
)
return
entry
.
safeLocals
.
get
(
name
)
;
const
safe
=
isSafeLocalVariable
(
entry
name
)
;
entry
.
safeLocals
.
set
(
name
safe
)
;
return
safe
;
}
function
isSafeLocalVariable
(
entry
name
)
{
var
edge
=
singleAssignment
(
name
)
;
if
(
edge
)
{
if
(
isDirectCall
(
edge
/
DebugOnly
.
*
?
:
:
operator
/
)
)
return
true
;
if
(
isDirectCall
(
edge
/
operator
new
/
)
|
|
isDirectCall
(
edge
/
nsCSSValue
:
:
Array
:
:
Create
/
)
)
{
return
true
;
}
if
(
"
PEdgeCallInstance
"
in
edge
)
{
if
(
(
isDirectCall
(
edge
/
operator
\
[
\
]
/
)
|
|
isDirectCall
(
edge
/
nsTArray
.
*
?
:
:
InsertElementAt
\
b
/
)
|
|
isDirectCall
(
edge
/
nsStyleContent
:
:
ContentAt
/
)
)
&
&
isEdgeSafeArgument
(
entry
edge
.
PEdgeCallInstance
.
Exp
)
)
{
return
true
;
}
if
(
isDirectCall
(
edge
/
operator
/
)
)
{
var
otherEdge
=
expressionValueEdge
(
edge
.
PEdgeCallInstance
.
Exp
)
;
if
(
otherEdge
&
&
isDirectCall
(
otherEdge
/
getter_
(
?
:
AddRefs
|
Copies
)
/
)
&
&
isEdgeSafeArgument
(
entry
otherEdge
.
PEdgeCallArguments
.
Exp
[
0
]
)
)
{
return
true
;
}
}
if
(
isDirectCall
(
edge
/
RefPtr
<
.
*
?
>
:
:
operator
(
-
>
|
\
*
)
\
(
\
)
/
)
&
&
isEdgeSafeArgument
(
entry
edge
.
PEdgeCallInstance
.
Exp
)
)
{
return
true
;
}
if
(
isDirectCall
(
edge
/
operator
new
/
)
&
&
edge
.
PEdgeCallInstance
.
Exp
.
length
=
=
2
&
&
isEdgeSafeArgument
(
entry
edge
.
PEdgeCallInstance
.
Exp
[
1
]
)
)
{
return
true
;
}
if
(
isDirectCall
(
edge
/
AsAString
/
)
&
&
isEdgeSafeArgument
(
entry
edge
.
PEdgeCallInstance
.
Exp
)
)
{
return
true
;
}
}
if
(
isSafeAssignment
(
entry
edge
name
)
)
return
true
;
var
rhsVariable
=
variableAssignRhs
(
edge
)
;
if
(
rhsVariable
)
return
isSafeVariable
(
entry
rhsVariable
)
;
}
var
type
=
null
;
for
(
var
defvar
of
currentBody
.
DefineVariable
)
{
if
(
variableName
(
defvar
.
Variable
)
=
=
name
)
{
type
=
defvar
.
Type
;
break
;
}
}
if
(
!
type
|
|
type
.
Kind
!
=
"
CSU
"
)
return
false
;
if
(
name
in
assignments
)
return
false
;
return
true
;
}
function
isSafeMemberPointer
(
containerType
memberType
)
{
if
(
memberType
.
Kind
!
=
'
Pointer
'
)
return
false
;
const
{
Type
:
{
Kind
:
pointeeKind
Name
:
pointeeTypeName
}
}
=
memberType
;
if
(
containerType
=
=
'
nsStyleBorder
'
&
&
pointeeKind
=
=
'
CSU
'
&
&
pointeeTypeName
=
=
'
nsBorderColors
'
)
{
return
true
;
}
return
false
;
}
function
testFailsOffMainThread
(
exp
value
)
{
switch
(
exp
.
Kind
)
{
case
"
Drf
"
:
var
edge
=
expressionValueEdge
(
exp
.
Exp
[
0
]
)
;
if
(
edge
)
{
if
(
isDirectCall
(
edge
/
NS_IsMainThread
/
)
&
&
value
)
return
true
;
if
(
isDirectCall
(
edge
/
IsInServoTraversal
/
)
&
&
!
value
)
return
true
;
if
(
isDirectCall
(
edge
/
__builtin_expect
/
)
)
return
testFailsOffMainThread
(
edge
.
PEdgeCallArguments
.
Exp
[
0
]
value
)
;
if
(
edge
.
Kind
=
=
"
Assign
"
)
return
testFailsOffMainThread
(
edge
.
Exp
[
1
]
value
)
;
}
break
;
case
"
Unop
"
:
if
(
exp
.
OpCode
=
=
"
LogicalNot
"
)
return
testFailsOffMainThread
(
exp
.
Exp
[
0
]
!
value
)
;
break
;
case
"
Binop
"
:
if
(
exp
.
OpCode
=
=
"
NotEqual
"
|
|
exp
.
OpCode
=
=
"
Equal
"
)
{
var
cmpExp
=
isZero
(
exp
.
Exp
[
0
]
)
?
exp
.
Exp
[
1
]
:
(
isZero
(
exp
.
Exp
[
1
]
)
?
exp
.
Exp
[
0
]
:
null
)
;
if
(
cmpExp
)
return
testFailsOffMainThread
(
cmpExp
exp
.
OpCode
=
=
"
NotEqual
"
?
value
:
!
value
)
;
}
break
;
case
"
Int
"
:
if
(
exp
.
String
=
=
"
0
"
&
&
value
)
return
true
;
if
(
exp
.
String
=
=
"
1
"
&
&
!
value
)
return
true
;
break
;
}
return
false
;
}
