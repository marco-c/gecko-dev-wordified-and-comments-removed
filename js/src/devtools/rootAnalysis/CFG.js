"
use
strict
"
;
function
findAllPoints
(
bodies
blockId
limits
)
{
var
points
=
[
]
;
var
body
;
for
(
var
xbody
of
bodies
)
{
if
(
sameBlockId
(
xbody
.
BlockId
blockId
)
)
{
assert
(
!
body
)
;
body
=
xbody
;
}
}
assert
(
body
)
;
if
(
!
(
"
PEdge
"
in
body
)
)
return
;
for
(
var
edge
of
body
.
PEdge
)
{
points
.
push
(
[
body
edge
.
Index
[
0
]
limits
]
)
;
if
(
edge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
edge
.
BlockId
limits
)
)
;
}
return
points
;
}
function
isMatchingDestructor
(
constructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
if
(
variable
.
Name
[
1
]
.
charAt
(
0
)
!
=
'
~
'
)
return
false
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
return
false
;
var
constructExp
=
constructor
.
PEdgeCallInstance
.
Exp
;
assert
(
constructExp
.
Kind
=
=
"
Var
"
)
;
var
destructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
allRAIIGuardedCallPoints
(
typeInfo
bodies
body
isConstructor
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
return
[
]
;
var
points
=
[
]
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
continue
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
continue
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
const
limits
=
isConstructor
(
typeInfo
edge
.
Type
variable
.
Name
)
;
if
(
!
limits
)
continue
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
continue
;
if
(
edge
.
PEdgeCallInstance
.
Exp
.
Kind
!
=
"
Var
"
)
continue
;
points
.
push
(
.
.
.
pointsInRAIIScope
(
bodies
body
edge
limits
)
)
;
}
return
points
;
}
function
isMatchingConstructor
(
destructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
if
(
variable
.
Kind
!
=
"
Func
"
)
return
false
;
var
name
=
readable
(
variable
.
Name
[
0
]
)
;
var
destructorName
=
readable
(
destructor
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
)
;
var
match
=
destructorName
.
match
(
/
^
(
.
*
?
:
:
)
~
(
\
w
+
)
\
(
/
)
;
if
(
!
match
)
{
printErr
(
"
Unhandled
destructor
syntax
:
"
+
destructorName
)
;
return
false
;
}
var
constructorSubstring
=
match
[
1
]
+
match
[
2
]
;
if
(
name
.
indexOf
(
constructorSubstring
)
=
=
-
1
)
return
false
;
var
destructExp
=
destructor
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
var
constructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
constructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
findMatchingConstructor
(
destructorEdge
body
warnIfNotFound
=
true
)
{
var
worklist
=
[
destructorEdge
]
;
var
predecessors
=
getPredecessors
(
body
)
;
while
(
worklist
.
length
>
0
)
{
var
edge
=
worklist
.
pop
(
)
;
if
(
isMatchingConstructor
(
destructorEdge
edge
)
)
return
edge
;
if
(
edge
.
Index
[
0
]
in
predecessors
)
{
for
(
var
e
of
predecessors
[
edge
.
Index
[
0
]
]
)
worklist
.
push
(
e
)
;
}
}
if
(
warnIfNotFound
)
printErr
(
"
Could
not
find
matching
constructor
!
"
)
;
return
undefined
;
}
function
pointsInRAIIScope
(
bodies
body
constructorEdge
limits
)
{
var
seen
=
{
}
;
var
worklist
=
[
constructorEdge
.
Index
[
1
]
]
;
var
points
=
[
]
;
while
(
worklist
.
length
)
{
var
point
=
worklist
.
pop
(
)
;
if
(
point
in
seen
)
continue
;
seen
[
point
]
=
true
;
points
.
push
(
[
body
point
limits
]
)
;
var
successors
=
getSuccessors
(
body
)
;
if
(
!
(
point
in
successors
)
)
continue
;
for
(
var
nedge
of
successors
[
point
]
)
{
if
(
isMatchingDestructor
(
constructorEdge
nedge
)
)
continue
;
if
(
nedge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
nedge
.
BlockId
limits
)
)
;
worklist
.
push
(
nedge
.
Index
[
1
]
)
;
}
}
return
points
;
}
function
getFieldCallInstanceCSU
(
edge
field
)
{
if
(
"
FieldInstanceFunction
"
in
field
)
{
const
instanceExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
instanceExp
.
Kind
=
=
'
Drf
'
)
{
return
edge
.
Type
.
TypeFunctionCSU
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Fld
'
)
{
return
instanceExp
.
Field
.
FieldCSU
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Index
'
)
{
return
instanceExp
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Var
'
)
{
return
field
.
FieldCSU
.
Type
.
Name
;
}
else
{
printErr
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
edge
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
printErr
(
JSON
.
stringify
(
edge
null
4
)
)
;
printErr
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
field
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
printErr
(
JSON
.
stringify
(
field
null
4
)
)
;
assert
(
false
unrecognized
FieldInstanceFunction
Kind
{
instanceExp
.
Kind
}
)
;
}
}
else
{
return
field
.
FieldCSU
.
Type
.
Name
;
}
}
function
isSyntheticVirtualDestructor
(
funcName
)
{
return
funcName
.
endsWith
(
"
"
)
;
}
function
typedField
(
field
)
{
if
(
"
FieldInstanceFunction
"
in
field
)
{
const
{
Type
Name
:
[
name
]
}
=
field
;
if
(
isSyntheticVirtualDestructor
(
name
)
)
{
return
name
;
}
var
nargs
=
0
;
if
(
Type
.
Kind
=
=
"
Function
"
&
&
"
TypeFunctionArguments
"
in
Type
)
nargs
=
Type
.
TypeFunctionArguments
.
Type
.
length
;
return
name
+
"
:
"
+
nargs
;
}
else
{
return
field
.
Name
[
0
]
;
}
}
function
fieldKey
(
csuName
field
)
{
return
csuName
+
"
.
"
+
typedField
(
field
)
;
}
