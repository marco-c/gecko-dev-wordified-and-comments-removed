"
use
strict
"
;
function
findAllPoints
(
bodies
blockId
limits
)
{
var
points
=
[
]
;
var
body
;
for
(
var
xbody
of
bodies
)
{
if
(
sameBlockId
(
xbody
.
BlockId
blockId
)
)
{
assert
(
!
body
)
;
body
=
xbody
;
}
}
assert
(
body
)
;
if
(
!
(
"
PEdge
"
in
body
)
)
return
;
for
(
var
edge
of
body
.
PEdge
)
{
points
.
push
(
[
body
edge
.
Index
[
0
]
limits
]
)
;
if
(
edge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
edge
.
BlockId
limits
)
)
;
}
return
points
;
}
function
isMatchingDestructor
(
constructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
if
(
variable
.
Name
[
1
]
.
charAt
(
0
)
!
=
'
~
'
)
return
false
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
return
false
;
var
constructExp
=
constructor
.
PEdgeCallInstance
.
Exp
;
assert
(
constructExp
.
Kind
=
=
"
Var
"
)
;
var
destructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
allRAIIGuardedCallPoints
(
typeInfo
bodies
body
isConstructor
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
return
[
]
;
var
points
=
[
]
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
continue
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
continue
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
const
limits
=
isConstructor
(
typeInfo
edge
.
Type
variable
.
Name
)
;
if
(
!
limits
)
continue
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
continue
;
if
(
edge
.
PEdgeCallInstance
.
Exp
.
Kind
!
=
"
Var
"
)
continue
;
points
.
push
(
.
.
.
pointsInRAIIScope
(
bodies
body
edge
limits
)
)
;
}
return
points
;
}
function
isMatchingConstructor
(
destructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
if
(
variable
.
Kind
!
=
"
Func
"
)
return
false
;
var
name
=
readable
(
variable
.
Name
[
0
]
)
;
var
destructorName
=
readable
(
destructor
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
)
;
var
match
=
destructorName
.
match
(
/
^
(
.
*
?
:
:
)
~
(
\
w
+
)
\
(
/
)
;
if
(
!
match
)
{
printErr
(
"
Unhandled
destructor
syntax
:
"
+
destructorName
)
;
return
false
;
}
var
constructorSubstring
=
match
[
1
]
+
match
[
2
]
;
if
(
name
.
indexOf
(
constructorSubstring
)
=
=
-
1
)
return
false
;
var
destructExp
=
destructor
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
var
constructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
constructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
findMatchingConstructor
(
destructorEdge
body
warnIfNotFound
=
true
)
{
var
worklist
=
[
destructorEdge
]
;
var
predecessors
=
getPredecessors
(
body
)
;
while
(
worklist
.
length
>
0
)
{
var
edge
=
worklist
.
pop
(
)
;
if
(
isMatchingConstructor
(
destructorEdge
edge
)
)
return
edge
;
if
(
edge
.
Index
[
0
]
in
predecessors
)
{
for
(
var
e
of
predecessors
[
edge
.
Index
[
0
]
]
)
worklist
.
push
(
e
)
;
}
}
if
(
warnIfNotFound
)
printErr
(
"
Could
not
find
matching
constructor
!
"
)
;
return
undefined
;
}
function
pointsInRAIIScope
(
bodies
body
constructorEdge
limits
)
{
var
seen
=
{
}
;
var
worklist
=
[
constructorEdge
.
Index
[
1
]
]
;
var
points
=
[
]
;
while
(
worklist
.
length
)
{
var
point
=
worklist
.
pop
(
)
;
if
(
point
in
seen
)
continue
;
seen
[
point
]
=
true
;
points
.
push
(
[
body
point
limits
]
)
;
var
successors
=
getSuccessors
(
body
)
;
if
(
!
(
point
in
successors
)
)
continue
;
for
(
var
nedge
of
successors
[
point
]
)
{
if
(
isMatchingDestructor
(
constructorEdge
nedge
)
)
continue
;
if
(
nedge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
nedge
.
BlockId
limits
)
)
;
worklist
.
push
(
nedge
.
Index
[
1
]
)
;
}
}
return
points
;
}
