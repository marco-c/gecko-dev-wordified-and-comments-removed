"
use
strict
"
;
var
TRACING
=
false
;
var
PTR_POINTER
=
0
;
var
PTR_REFERENCE
=
1
;
var
PTR_RVALUE_REF
=
2
;
function
findAllPoints
(
bodies
blockId
bits
)
{
var
points
=
[
]
;
var
body
;
for
(
var
xbody
of
bodies
)
{
if
(
sameBlockId
(
xbody
.
BlockId
blockId
)
)
{
assert
(
!
body
)
;
body
=
xbody
;
}
}
assert
(
body
)
;
if
(
!
(
"
PEdge
"
in
body
)
)
return
;
for
(
var
edge
of
body
.
PEdge
)
{
points
.
push
(
[
body
edge
.
Index
[
0
]
bits
]
)
;
if
(
edge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
edge
.
BlockId
bits
)
)
;
}
return
points
;
}
var
Visitor
=
class
{
constructor
(
bodies
)
{
this
.
visited_bodies
=
new
Map
(
)
;
for
(
const
body
of
bodies
)
{
this
.
visited_bodies
.
set
(
body
new
Map
(
)
)
;
}
}
visit
(
body
ppoint
info
)
{
const
visited
=
this
.
visited_bodies
.
get
(
body
)
;
const
existing
=
visited
.
get
(
ppoint
)
;
const
action
=
this
.
next_action
(
existing
info
)
;
const
merged
=
this
.
merge_info
(
existing
info
)
;
visited
.
set
(
ppoint
merged
)
;
return
[
action
merged
]
;
}
next_action
(
prev
current
)
{
return
prev
?
"
prune
"
:
"
continue
"
;
}
merge_info
(
prev
current
)
{
return
true
;
}
extend_path
(
edge
body
ppoint
successor_path
)
{
return
true
;
}
}
;
function
findMatchingBlock
(
bodies
blockId
)
{
for
(
const
body
of
bodies
)
{
if
(
sameBlockId
(
body
.
BlockId
blockId
)
)
{
return
body
;
}
}
assert
(
false
)
;
}
function
BFS_upwards
(
start_body
start_ppoint
bodies
visitor
initial_successor_info
=
{
}
result_if_reached_root
=
null
)
{
const
work
=
[
[
start_body
start_ppoint
null
initial_successor_info
]
]
;
if
(
TRACING
)
{
printErr
(
BFS
start
at
{
blockIdentifier
(
start_body
)
}
:
{
start_ppoint
}
)
;
}
let
reached_root
=
false
;
while
(
work
.
length
>
0
)
{
const
[
body
ppoint
edgeToAdd
successor_path
]
=
work
.
shift
(
)
;
if
(
TRACING
)
{
printErr
(
prepending
edge
from
{
ppoint
}
to
state
'
{
successor_path
}
'
)
;
}
let
path
=
visitor
.
extend_path
(
edgeToAdd
body
ppoint
successor_path
)
;
const
[
action
merged_path
]
=
visitor
.
visit
(
body
ppoint
path
)
;
if
(
action
=
=
=
"
done
"
)
{
return
merged_path
;
}
if
(
action
=
=
=
"
prune
"
)
{
continue
;
}
assert
(
action
=
=
"
continue
"
)
;
path
=
merged_path
;
const
predecessors
=
getPredecessors
(
body
)
;
for
(
const
edge
of
(
predecessors
[
ppoint
]
|
|
[
]
)
)
{
if
(
edge
.
Kind
=
=
"
Loop
"
)
{
const
loopBody
=
findMatchingBlock
(
bodies
edge
.
BlockId
)
;
const
loopEnd
=
loopBody
.
Index
[
1
]
;
work
.
push
(
[
loopBody
loopEnd
null
path
]
)
;
}
else
{
work
.
push
(
[
body
edge
.
Index
[
0
]
edge
path
]
)
;
}
}
if
(
ppoint
=
=
body
.
Index
[
0
]
&
&
body
.
BlockId
.
Kind
=
=
"
Loop
"
)
{
for
(
const
parent
of
(
body
.
BlockPPoint
|
|
[
]
)
)
{
const
parentBody
=
findMatchingBlock
(
bodies
parent
.
BlockId
)
;
work
.
push
(
[
parentBody
parent
.
Index
null
path
]
)
;
}
work
.
push
(
[
body
body
.
Index
[
1
]
null
path
]
)
;
}
if
(
body
=
=
=
start_body
&
&
ppoint
=
=
body
.
Index
[
0
]
)
{
reached_root
=
true
;
}
}
return
reached_root
?
result_if_reached_root
:
null
;
}
function
isMatchingDestructor
(
constructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
if
(
variable
.
Name
[
1
]
.
charAt
(
0
)
!
=
'
~
'
)
return
false
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
return
false
;
var
constructExp
=
constructor
.
PEdgeCallInstance
.
Exp
;
assert
(
constructExp
.
Kind
=
=
"
Var
"
)
;
var
destructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
allRAIIGuardedCallPoints
(
typeInfo
bodies
body
isConstructor
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
return
[
]
;
var
points
=
[
]
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
continue
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
continue
;
var
variable
=
callee
.
Variable
;
assert
(
variable
.
Kind
=
=
"
Func
"
)
;
const
bits
=
isConstructor
(
typeInfo
edge
.
Type
variable
.
Name
)
;
if
(
!
bits
)
continue
;
if
(
!
(
"
PEdgeCallInstance
"
in
edge
)
)
continue
;
if
(
edge
.
PEdgeCallInstance
.
Exp
.
Kind
!
=
"
Var
"
)
continue
;
points
.
push
(
.
.
.
pointsInRAIIScope
(
bodies
body
edge
bits
)
)
;
}
return
points
;
}
function
isMatchingConstructor
(
destructor
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
var
variable
=
callee
.
Variable
;
if
(
variable
.
Kind
!
=
"
Func
"
)
return
false
;
var
name
=
readable
(
variable
.
Name
[
0
]
)
;
var
destructorName
=
readable
(
destructor
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
)
;
var
match
=
destructorName
.
match
(
/
^
(
.
*
?
:
:
)
~
(
\
w
+
)
\
(
/
)
;
if
(
!
match
)
{
printErr
(
"
Unhandled
destructor
syntax
:
"
+
destructorName
)
;
return
false
;
}
var
constructorSubstring
=
match
[
1
]
+
match
[
2
]
;
if
(
name
.
indexOf
(
constructorSubstring
)
=
=
-
1
)
return
false
;
var
destructExp
=
destructor
.
PEdgeCallInstance
.
Exp
;
if
(
destructExp
.
Kind
!
=
"
Var
"
)
return
false
;
var
constructExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
constructExp
.
Kind
!
=
"
Var
"
)
return
false
;
return
sameVariable
(
constructExp
.
Variable
destructExp
.
Variable
)
;
}
function
findMatchingConstructor
(
destructorEdge
body
warnIfNotFound
=
true
)
{
var
worklist
=
[
destructorEdge
]
;
var
predecessors
=
getPredecessors
(
body
)
;
while
(
worklist
.
length
>
0
)
{
var
edge
=
worklist
.
pop
(
)
;
if
(
isMatchingConstructor
(
destructorEdge
edge
)
)
return
edge
;
if
(
edge
.
Index
[
0
]
in
predecessors
)
{
for
(
var
e
of
predecessors
[
edge
.
Index
[
0
]
]
)
worklist
.
push
(
e
)
;
}
}
if
(
warnIfNotFound
)
printErr
(
"
Could
not
find
matching
constructor
!
"
)
;
return
undefined
;
}
function
pointsInRAIIScope
(
bodies
body
constructorEdge
bits
)
{
var
seen
=
{
}
;
var
worklist
=
[
constructorEdge
.
Index
[
1
]
]
;
var
points
=
[
]
;
while
(
worklist
.
length
)
{
var
point
=
worklist
.
pop
(
)
;
if
(
point
in
seen
)
continue
;
seen
[
point
]
=
true
;
points
.
push
(
[
body
point
bits
]
)
;
var
successors
=
getSuccessors
(
body
)
;
if
(
!
(
point
in
successors
)
)
continue
;
for
(
var
nedge
of
successors
[
point
]
)
{
if
(
isMatchingDestructor
(
constructorEdge
nedge
)
)
continue
;
if
(
nedge
.
Kind
=
=
"
Loop
"
)
points
.
push
(
.
.
.
findAllPoints
(
bodies
nedge
.
BlockId
bits
)
)
;
worklist
.
push
(
nedge
.
Index
[
1
]
)
;
}
}
return
points
;
}
function
isImmobileValue
(
exp
)
{
if
(
exp
.
Kind
=
=
"
Int
"
&
&
exp
.
String
=
=
"
0
"
)
{
return
true
;
}
return
false
;
}
function
isReferenceDecl
(
decl
)
{
return
decl
.
Type
.
Kind
=
=
"
Pointer
"
&
&
decl
.
Type
.
Reference
!
=
PTR_POINTER
&
&
decl
.
Variable
.
Kind
!
=
"
Temp
"
;
}
function
expressionIsVariableAddress
(
exp
variable
)
{
while
(
exp
.
Kind
=
=
"
Fld
"
)
exp
=
exp
.
Exp
[
0
]
;
return
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
;
}
function
edgeTakesVariableAddress
(
edge
variable
body
)
{
if
(
ignoreEdgeUse
(
edge
variable
body
)
)
return
false
;
if
(
ignoreEdgeAddressTaken
(
edge
)
)
return
false
;
switch
(
edge
.
Kind
)
{
case
"
Assign
"
:
return
expressionIsVariableAddress
(
edge
.
Exp
[
1
]
variable
)
;
case
"
Call
"
:
if
(
"
PEdgeCallArguments
"
in
edge
)
{
for
(
var
exp
of
edge
.
PEdgeCallArguments
.
Exp
)
{
if
(
expressionIsVariableAddress
(
exp
variable
)
)
return
true
;
}
}
return
false
;
default
:
return
false
;
}
}
function
getFieldCallInstanceCSU
(
edge
field
)
{
if
(
"
FieldInstanceFunction
"
in
field
)
{
const
instanceExp
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
instanceExp
.
Kind
=
=
'
Drf
'
)
{
return
edge
.
Type
.
TypeFunctionCSU
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Fld
'
)
{
return
instanceExp
.
Field
.
FieldCSU
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Index
'
)
{
return
instanceExp
.
Type
.
Name
;
}
else
if
(
instanceExp
.
Kind
=
=
'
Var
'
)
{
return
field
.
FieldCSU
.
Type
.
Name
;
}
else
{
printErr
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
edge
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
printErr
(
JSON
.
stringify
(
edge
null
4
)
)
;
printErr
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
field
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
printErr
(
JSON
.
stringify
(
field
null
4
)
)
;
assert
(
false
unrecognized
FieldInstanceFunction
Kind
{
instanceExp
.
Kind
}
)
;
}
}
else
{
return
field
.
FieldCSU
.
Type
.
Name
;
}
}
function
expressionUsesVariable
(
exp
variable
)
{
if
(
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
)
return
true
;
if
(
!
(
"
Exp
"
in
exp
)
)
return
false
;
for
(
var
childExp
of
exp
.
Exp
)
{
if
(
expressionUsesVariable
(
childExp
variable
)
)
return
true
;
}
return
false
;
}
function
expressionUsesVariableContents
(
exp
variable
)
{
if
(
!
(
"
Exp
"
in
exp
)
)
return
false
;
for
(
var
childExp
of
exp
.
Exp
)
{
if
(
childExp
.
Kind
=
=
'
Drf
'
)
{
if
(
expressionUsesVariable
(
childExp
variable
)
)
return
true
;
}
else
if
(
expressionUsesVariableContents
(
childExp
variable
)
)
{
return
true
;
}
}
return
false
;
}
function
isReturningImmobileValue
(
edge
variable
)
{
if
(
variable
.
Kind
=
=
"
Return
"
)
{
if
(
edge
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
edge
.
Exp
[
0
]
.
Variable
variable
)
)
{
if
(
isImmobileValue
(
edge
.
Exp
[
1
]
)
)
return
true
;
}
}
return
false
;
}
function
edgeUsesVariable
(
edge
variable
body
liveToEnd
=
false
)
{
if
(
ignoreEdgeUse
(
edge
variable
body
)
)
return
0
;
if
(
variable
.
Kind
=
=
"
Return
"
)
{
liveToEnd
=
true
;
}
if
(
liveToEnd
&
&
body
.
Index
[
1
]
=
=
edge
.
Index
[
1
]
&
&
body
.
BlockId
.
Kind
=
=
"
Function
"
)
{
return
edge
.
Index
[
1
]
;
}
var
src
=
edge
.
Index
[
0
]
;
switch
(
edge
.
Kind
)
{
case
"
Assign
"
:
{
if
(
isReturningImmobileValue
(
edge
variable
)
)
return
0
;
const
[
lhs
rhs
]
=
edge
.
Exp
;
if
(
expressionUsesVariable
(
rhs
variable
)
)
return
src
;
if
(
expressionUsesVariable
(
lhs
variable
)
&
&
!
expressionIsVariable
(
lhs
variable
)
)
return
src
;
return
0
;
}
case
"
Assume
"
:
return
expressionUsesVariableContents
(
edge
.
Exp
[
0
]
variable
)
?
src
:
0
;
case
"
Call
"
:
{
const
callee
=
edge
.
Exp
[
0
]
;
if
(
expressionUsesVariable
(
callee
variable
)
)
return
src
;
if
(
"
PEdgeCallInstance
"
in
edge
)
{
if
(
expressionUsesVariable
(
edge
.
PEdgeCallInstance
.
Exp
variable
)
)
{
if
(
edgeStartsValueLiveRange
(
edge
variable
)
)
{
}
else
{
return
src
;
}
}
}
if
(
"
PEdgeCallArguments
"
in
edge
)
{
for
(
var
exp
of
edge
.
PEdgeCallArguments
.
Exp
)
{
if
(
expressionUsesVariable
(
exp
variable
)
)
return
src
;
}
}
if
(
edge
.
Exp
.
length
=
=
1
)
return
0
;
const
lhs
=
edge
.
Exp
[
1
]
;
if
(
expressionUsesVariable
(
lhs
variable
)
&
&
!
expressionIsVariable
(
lhs
variable
)
)
return
src
;
return
0
;
}
case
"
Loop
"
:
return
0
;
case
"
Assembly
"
:
return
0
;
default
:
assert
(
false
)
;
}
}
function
maybeDereference
(
exp
decl
)
{
if
(
exp
.
Kind
=
=
"
Drf
"
&
&
exp
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
)
{
if
(
isReferenceDecl
(
decl
)
)
{
return
exp
.
Exp
[
0
]
;
}
}
return
exp
;
}
function
expressionIsVariable
(
exp
variable
)
{
return
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
;
}
function
expressionIsDeclaredVariable
(
exp
decl
)
{
exp
=
maybeDereference
(
exp
decl
)
;
return
expressionIsVariable
(
exp
decl
.
Variable
)
;
}
function
expressionIsMethodOnVariableDecl
(
exp
decl
)
{
while
(
exp
.
Kind
=
=
"
Fld
"
&
&
exp
.
Field
.
Name
[
0
]
.
startsWith
(
"
field
:
"
)
)
exp
=
exp
.
Exp
[
0
]
;
return
expressionIsDeclaredVariable
(
exp
decl
)
;
}
function
edgeStartsValueLiveRange
(
edge
variable
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
)
{
const
[
lhs
rhs
]
=
edge
.
Exp
;
return
(
expressionIsVariable
(
lhs
variable
)
&
&
!
isReturningImmobileValue
(
edge
variable
)
)
;
}
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
if
(
1
in
edge
.
Exp
)
{
var
lhs
=
edge
.
Exp
[
1
]
;
if
(
expressionIsVariable
(
lhs
variable
)
)
return
true
;
}
if
(
"
PEdgeCallInstance
"
in
edge
)
{
var
instance
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
instance
.
Kind
=
=
"
Drf
"
)
instance
=
instance
.
Exp
[
0
]
;
if
(
!
expressionIsVariable
(
instance
variable
)
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
assert
(
callee
.
Variable
.
Kind
=
=
"
Func
"
)
;
var
calleeName
=
readable
(
callee
.
Variable
.
Name
[
0
]
)
;
var
openParen
=
calleeName
.
indexOf
(
'
(
'
)
;
if
(
openParen
<
0
)
return
false
;
calleeName
=
calleeName
.
substring
(
0
openParen
)
;
var
lastColon
=
calleeName
.
lastIndexOf
(
'
:
:
'
)
;
if
(
lastColon
<
0
)
return
false
;
var
constructorName
=
calleeName
.
substr
(
lastColon
+
2
)
;
calleeName
=
calleeName
.
substr
(
0
lastColon
)
;
var
lastTemplateOpen
=
calleeName
.
lastIndexOf
(
'
<
'
)
;
if
(
lastTemplateOpen
>
=
0
)
calleeName
=
calleeName
.
substr
(
0
lastTemplateOpen
)
;
if
(
calleeName
.
endsWith
(
constructorName
)
)
return
true
;
}
return
false
;
}
function
parseTypeName
(
typeName
)
{
const
m
=
typeName
.
match
(
/
^
(
(
(
?
:
\
w
|
:
:
)
+
:
:
)
?
(
\
w
+
)
)
\
b
(
\
<
)
?
/
)
;
if
(
!
m
)
{
return
undefined
;
}
const
[
type
raw_namespace
classname
is_specialized
]
=
m
;
const
namespace
=
raw_namespace
=
=
=
null
?
"
"
:
raw_namespace
;
return
{
type
namespace
classname
is_specialized
}
}
function
edgeEndsValueLiveRange
(
edge
variable
body
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
)
{
const
[
lhs
rhs
]
=
edge
.
Exp
;
return
expressionIsVariable
(
lhs
variable
)
&
&
isImmobileValue
(
rhs
)
;
}
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Exp
[
0
]
.
Kind
=
=
'
Var
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Kind
=
=
'
Func
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
1
]
=
=
'
MarkVariableAsGCSafe
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
.
includes
(
"
JS
:
:
detail
:
:
MarkVariableAsGCSafe
"
)
&
&
expressionIsVariable
(
edge
.
PEdgeCallArguments
.
Exp
[
0
]
variable
)
)
{
return
true
;
}
const
decl
=
lookupVariable
(
body
variable
)
;
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Exp
[
0
]
.
Kind
=
=
'
Var
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Kind
=
=
'
Func
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
1
]
=
=
'
move
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
.
includes
(
'
std
:
:
move
(
'
)
&
&
expressionIsDeclaredVariable
(
edge
.
PEdgeCallArguments
.
Exp
[
0
]
decl
)
&
&
edge
.
Exp
[
1
]
.
Kind
=
=
'
Var
'
&
&
edge
.
Exp
[
1
]
.
Variable
.
Kind
=
=
'
Temp
'
)
{
const
lhs
=
edge
.
Exp
[
1
]
.
Variable
;
if
(
basicBlockEatsVariable
(
lhs
body
edge
.
Index
[
1
]
)
)
return
true
;
}
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Type
.
TypeFunctionCSU
&
&
edge
.
PEdgeCallInstance
&
&
expressionIsMethodOnVariableDecl
(
edge
.
PEdgeCallInstance
.
Exp
decl
)
)
{
const
typeName
=
edge
.
Type
.
TypeFunctionCSU
.
Type
.
Name
;
const
parsed
=
parseTypeName
(
typeName
)
;
if
(
parsed
)
{
const
{
type
namespace
classname
is_specialized
}
=
parsed
;
const
template
=
is_specialized
?
'
<
T
>
'
:
'
'
;
const
ctorName
=
{
namespace
}
{
classname
}
{
template
}
:
:
{
classname
}
(
)
;
if
(
callee
.
Kind
=
=
'
Var
'
&
&
typesWithSafeConstructors
.
has
(
type
)
&
&
callee
.
Variable
.
Name
[
0
]
.
includes
(
ctorName
)
)
{
return
true
;
}
if
(
callee
.
Kind
=
=
'
Var
'
&
&
type
in
resetterMethods
&
&
resetterMethods
[
type
]
.
has
(
callee
.
Variable
.
Name
[
1
]
)
)
{
return
true
;
}
}
}
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Type
.
TypeFunctionArgument
&
&
edge
.
PEdgeCallArguments
)
{
for
(
const
i
in
edge
.
Type
.
TypeFunctionArgument
)
{
const
param
=
edge
.
Type
.
TypeFunctionArgument
[
i
]
;
if
(
param
.
Type
.
Kind
!
=
'
CSU
'
)
continue
;
if
(
!
param
.
Type
.
Name
.
startsWith
(
"
mozilla
:
:
UniquePtr
<
"
)
)
continue
;
const
arg
=
edge
.
PEdgeCallArguments
.
Exp
[
i
]
;
if
(
expressionIsVariable
(
arg
variable
)
)
{
return
true
;
}
}
}
return
false
;
}
function
lookupVariable
(
body
variable
)
{
for
(
const
decl
of
(
body
.
DefineVariable
|
|
[
]
)
)
{
if
(
sameVariable
(
decl
.
Variable
variable
)
)
{
return
decl
;
}
}
return
undefined
;
}
function
edgeMovesVariable
(
edge
variable
body
)
{
if
(
edge
.
Kind
!
=
'
Call
'
)
return
false
;
const
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
'
Var
'
&
&
callee
.
Variable
.
Kind
=
=
'
Func
'
)
{
const
{
Variable
:
{
Name
:
[
fullname
shortname
]
}
}
=
callee
;
if
(
!
edge
|
|
!
edge
.
PEdgeCallArguments
|
|
!
edge
.
PEdgeCallArguments
.
Exp
)
{
return
false
;
}
for
(
const
arg
of
edge
.
PEdgeCallArguments
.
Exp
)
{
if
(
arg
.
Kind
!
=
'
Drf
'
)
continue
;
const
val
=
arg
.
Exp
[
0
]
;
if
(
val
.
Kind
=
=
'
Var
'
&
&
sameVariable
(
val
.
Variable
variable
)
)
{
const
type
=
lookupVariable
(
body
variable
)
.
Type
;
if
(
type
.
Kind
=
=
"
Pointer
"
&
&
type
.
Reference
=
=
PTR_RVALUE_REF
)
{
return
true
;
}
}
}
}
return
false
;
}
function
basicBlockEatsVariable
(
variable
body
startpoint
)
{
const
successors
=
getSuccessors
(
body
)
;
let
point
=
startpoint
;
while
(
point
in
successors
)
{
const
edges
=
successors
[
point
]
;
if
(
edges
.
length
!
=
1
)
{
return
false
;
}
const
edge
=
edges
[
0
]
;
if
(
edgeMovesVariable
(
edge
variable
body
)
)
{
return
true
;
}
if
(
edgeStartsValueLiveRange
(
edge
variable
)
)
{
return
false
;
}
point
=
edge
.
Index
[
1
]
;
}
return
false
;
}
var
PROP_REFCNT
=
1
<
<
0
;
function
getCalleeProperties
(
calleeName
)
{
let
props
=
0
;
if
(
isRefcountedDtor
(
calleeName
)
)
{
props
=
props
|
PROP_REFCNT
;
}
return
props
;
}
function
getCallEdgeProperties
(
body
edge
calleeName
functionBodies
)
{
let
attrs
=
0
;
if
(
edge
.
Kind
!
=
=
"
Call
"
)
{
return
{
attrs
}
;
}
const
props
=
getCalleeProperties
(
calleeName
)
;
if
(
props
&
PROP_REFCNT
)
{
const
blockId
=
blockIdentifier
(
body
)
;
if
(
blockId
.
includes
(
"
std
:
:
swap
"
)
|
|
blockId
.
includes
(
"
mozilla
:
:
Swap
"
)
)
{
attrs
|
=
ATTR_REPLACED
;
}
}
if
(
(
props
&
PROP_REFCNT
)
=
=
0
)
{
return
{
attrs
}
;
}
let
callee
=
edge
.
Exp
[
0
]
;
while
(
callee
.
Kind
=
=
=
"
Drf
"
)
{
callee
=
callee
.
Exp
[
0
]
;
}
const
instance
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
instance
.
Kind
!
=
=
"
Var
"
)
{
return
{
attrs
}
;
}
const
variable
=
instance
.
Variable
;
const
visitor
=
new
class
DominatorVisitor
extends
Visitor
{
next_action
(
seen
current
)
{
return
seen
?
"
prune
"
:
current
;
}
merge_info
(
seen
current
)
{
return
current
;
}
extend_path
(
edge
body
ppoint
successor_path
)
{
if
(
!
edge
)
{
return
"
continue
"
;
}
if
(
!
edgeUsesVariable
(
edge
variable
body
)
)
{
return
"
continue
"
;
}
if
(
edgeEndsValueLiveRange
(
edge
variable
body
)
)
{
return
"
prune
"
;
}
return
"
done
"
;
}
}
(
functionBodies
)
;
const
edgeIsNonReleasingDtor
=
!
BFS_upwards
(
body
edge
.
Index
[
0
]
functionBodies
visitor
"
start
"
true
)
;
if
(
edgeIsNonReleasingDtor
)
{
attrs
|
=
ATTR_GC_SUPPRESSED
|
ATTR_NONRELEASING
;
}
return
{
attrs
}
;
}
function
isSyntheticVirtualDestructor
(
funcName
)
{
return
funcName
.
endsWith
(
"
"
)
;
}
function
typedField
(
field
)
{
if
(
"
FieldInstanceFunction
"
in
field
)
{
const
{
Type
Name
:
[
name
]
}
=
field
;
if
(
isSyntheticVirtualDestructor
(
name
)
)
{
return
name
;
}
var
nargs
=
0
;
if
(
Type
.
Kind
=
=
"
Function
"
&
&
"
TypeFunctionArguments
"
in
Type
)
nargs
=
Type
.
TypeFunctionArguments
.
Type
.
length
;
return
name
+
"
:
"
+
nargs
;
}
else
{
return
field
.
Name
[
0
]
;
}
}
function
fieldKey
(
csuName
field
)
{
return
csuName
+
"
.
"
+
typedField
(
field
)
;
}
