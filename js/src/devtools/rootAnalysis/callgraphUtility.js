var
subclasses
=
new
Map
(
)
;
var
superclasses
=
new
Map
(
)
;
var
classFunctions
=
new
Map
(
)
;
function
addEntry
(
map
name
entry
)
{
if
(
!
map
.
has
(
name
)
)
map
.
set
(
name
new
Set
(
)
)
;
map
.
get
(
name
)
.
add
(
entry
)
;
}
function
fieldKey
(
csuName
field
)
{
var
nargs
=
0
;
if
(
field
.
Type
.
Kind
=
=
"
Function
"
&
&
"
TypeFunctionArguments
"
in
field
.
Type
)
nargs
=
field
.
Type
.
TypeFunctionArguments
.
length
;
return
csuName
+
"
:
"
+
field
.
Name
[
0
]
+
"
:
"
+
nargs
;
}
function
processCSU
(
csuName
csu
)
{
if
(
!
(
"
FunctionField
"
in
csu
)
)
return
;
for
(
var
field
of
csu
.
FunctionField
)
{
if
(
1
in
field
.
Field
)
{
var
superclass
=
field
.
Field
[
1
]
.
Type
.
Name
;
var
subclass
=
field
.
Field
[
1
]
.
FieldCSU
.
Type
.
Name
;
assert
(
subclass
=
=
csuName
)
;
addEntry
(
subclasses
superclass
subclass
)
;
addEntry
(
superclasses
subclass
superclass
)
;
}
if
(
"
Variable
"
in
field
)
{
var
name
=
field
.
Variable
.
Name
[
0
]
;
addEntry
(
classFunctions
fieldKey
(
csuName
field
.
Field
[
0
]
)
name
)
;
}
}
}
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_comp
.
xdb
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
;
var
maxStream
=
xdb
.
max_data_stream
(
)
;
for
(
var
csuIndex
=
minStream
;
csuIndex
<
=
maxStream
;
csuIndex
+
+
)
{
var
csu
=
xdb
.
read_key
(
csuIndex
)
;
var
data
=
xdb
.
read_entry
(
csu
)
;
var
json
=
JSON
.
parse
(
data
.
readString
(
)
)
;
processCSU
(
csu
.
readString
(
)
json
[
0
]
)
;
xdb
.
free_string
(
csu
)
;
xdb
.
free_string
(
data
)
;
}
function
nearestAncestorMethods
(
csu
field
)
{
var
key
=
fieldKey
(
csu
field
)
;
print
(
"
Scanning
for
nearest
ancestor
of
"
+
key
)
;
if
(
classFunctions
.
has
(
key
)
)
return
new
Set
(
classFunctions
.
get
(
key
)
)
;
var
functions
=
new
Set
(
)
;
if
(
superclasses
.
has
(
csu
)
)
{
for
(
var
parent
of
superclasses
.
get
(
csu
)
)
functions
.
update
(
nearestAncestorMethods
(
parent
field
)
)
;
}
return
functions
;
}
function
findVirtualFunctions
(
initialCSU
field
)
{
var
fieldName
=
field
.
Name
[
0
]
;
var
worklist
=
[
initialCSU
]
;
var
functions
=
new
Set
(
)
;
while
(
worklist
.
length
)
{
var
csu
=
worklist
.
pop
(
)
;
if
(
isSuppressedVirtualMethod
(
csu
fieldName
)
)
return
[
new
Set
(
)
true
]
;
if
(
isOverridableField
(
initialCSU
csu
fieldName
)
)
{
functions
.
add
(
null
)
;
}
if
(
superclasses
.
has
(
csu
)
)
worklist
.
push
(
.
.
.
superclasses
.
get
(
csu
)
)
;
}
functions
.
update
(
nearestAncestorMethods
(
initialCSU
field
)
)
;
var
worklist
=
[
initialCSU
]
;
while
(
worklist
.
length
)
{
var
csu
=
worklist
.
pop
(
)
;
var
key
=
fieldKey
(
csu
field
)
;
if
(
classFunctions
.
has
(
key
)
)
functions
.
update
(
classFunctions
.
get
(
key
)
)
;
if
(
subclasses
.
has
(
csu
)
)
worklist
.
push
(
.
.
.
subclasses
.
get
(
csu
)
)
;
}
assert
(
functions
.
size
>
0
"
failed
to
find
virtual
function
for
"
+
fieldName
)
;
return
[
functions
false
]
;
}
function
getCallees
(
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
[
]
;
var
callee
=
edge
.
Exp
[
0
]
;
var
callees
=
[
]
;
if
(
callee
.
Kind
=
=
"
Var
"
)
{
assert
(
callee
.
Variable
.
Kind
=
=
"
Func
"
)
;
callees
.
push
(
{
'
kind
'
:
'
direct
'
'
name
'
:
callee
.
Variable
.
Name
[
0
]
}
)
;
}
else
{
assert
(
callee
.
Kind
=
=
"
Drf
"
)
;
if
(
callee
.
Exp
[
0
]
.
Kind
=
=
"
Fld
"
)
{
var
field
=
callee
.
Exp
[
0
]
.
Field
;
var
fieldName
=
field
.
Name
[
0
]
;
var
csuName
=
field
.
FieldCSU
.
Type
.
Name
;
var
functions
;
if
(
"
FieldInstanceFunction
"
in
field
)
{
let
suppressed
;
[
functions
suppressed
]
=
findVirtualFunctions
(
csuName
field
suppressed
)
;
if
(
suppressed
)
{
callees
.
push
(
{
'
kind
'
:
"
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
suppressed
'
:
true
'
isVirtual
'
:
true
}
)
;
}
}
else
{
functions
=
new
Set
(
[
null
]
)
;
}
var
targets
=
[
]
;
var
fullyResolved
=
true
;
for
(
var
name
of
functions
)
{
if
(
name
=
=
=
null
)
{
callees
.
push
(
{
'
kind
'
:
"
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
isVirtual
'
:
"
FieldInstanceFunction
"
in
field
}
)
;
fullyResolved
=
false
;
}
else
{
callees
.
push
(
{
'
kind
'
:
"
direct
"
'
name
'
:
name
}
)
;
targets
.
push
(
{
'
kind
'
:
"
direct
"
'
name
'
:
name
}
)
;
}
}
if
(
fullyResolved
)
callees
.
push
(
{
'
kind
'
:
"
resolved
-
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
callees
'
:
targets
}
)
;
}
else
if
(
callee
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
)
{
callees
.
push
(
{
'
kind
'
:
"
indirect
"
'
variable
'
:
callee
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
}
)
;
}
else
{
callees
.
push
(
{
'
kind
'
:
"
unknown
"
}
)
;
}
}
return
callees
;
}
