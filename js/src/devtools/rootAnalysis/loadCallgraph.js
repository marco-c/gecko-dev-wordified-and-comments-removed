"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
var
readableNames
=
{
}
;
var
calleesOf
=
{
}
;
var
callersOf
;
var
gcFunctions
=
{
}
;
var
limitedFunctions
=
{
}
;
var
gcEdges
=
{
}
;
var
functionNames
=
[
"
"
]
;
var
mangledToId
=
{
}
;
function
addGCFunction
(
caller
reason
functionLimits
)
{
if
(
functionLimits
[
caller
]
&
LIMIT_CANNOT_GC
)
return
false
;
if
(
ignoreGCFunction
(
functionNames
[
caller
]
)
)
return
false
;
if
(
!
(
caller
in
gcFunctions
)
)
{
gcFunctions
[
caller
]
=
reason
;
return
true
;
}
return
false
;
}
function
merge_repeated_calls
(
calleesOf
)
{
const
callersOf
=
Object
.
create
(
null
)
;
for
(
const
[
caller_prop
callee_limits
]
of
Object
.
entries
(
calleesOf
)
)
{
const
caller
=
caller_prop
|
0
;
const
ordered_callees
=
[
]
;
const
callee2limit
=
new
Map
(
)
;
for
(
const
{
callee
limits
}
of
callee_limits
)
{
const
prev_limits
=
callee2limit
.
get
(
callee
)
;
if
(
prev_limits
=
=
=
undefined
)
{
callee2limit
.
set
(
callee
limits
)
;
ordered_callees
.
push
(
callee
)
;
}
else
{
callee2limit
.
set
(
callee
prev_limits
&
limits
)
;
}
}
callee_limits
.
length
=
0
;
for
(
const
callee
of
ordered_callees
)
{
const
limits
=
callee2limit
.
get
(
callee
)
;
callee_limits
.
push
(
{
callee
limits
}
)
;
if
(
!
(
callee
in
callersOf
)
)
callersOf
[
callee
]
=
[
]
;
callersOf
[
callee
]
.
push
(
{
caller
limits
}
)
;
}
}
return
callersOf
;
}
function
loadCallgraph
(
file
)
{
const
fieldCallLimits
=
{
}
;
const
fieldCallCSU
=
new
Map
(
)
;
var
functionLimits
=
{
}
;
let
numGCCalls
=
0
;
for
(
let
line
of
readFileLines_gen
(
file
)
)
{
line
=
line
.
replace
(
/
\
n
/
"
"
)
;
let
match
;
if
(
match
=
line
.
charAt
(
0
)
=
=
"
#
"
&
&
/
^
\
#
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
mangled
]
=
match
;
assert
(
functionNames
.
length
=
=
id
)
;
functionNames
.
push
(
mangled
)
;
mangledToId
[
mangled
]
=
id
;
continue
;
}
if
(
match
=
line
.
charAt
(
0
)
=
=
"
=
"
&
&
/
^
=
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
readable
]
=
match
;
const
mangled
=
functionNames
[
id
]
;
if
(
mangled
in
readableNames
)
readableNames
[
mangled
]
.
push
(
readable
)
;
else
readableNames
[
mangled
]
=
[
readable
]
;
continue
;
}
let
limits
=
0
;
if
(
line
.
indexOf
(
"
/
"
)
!
=
-
1
)
{
match
=
/
^
(
.
.
)
\
/
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
;
line
=
match
[
1
]
+
match
[
3
]
;
limits
=
match
[
2
]
|
0
;
}
const
tag
=
line
.
charAt
(
0
)
;
if
(
match
=
tag
=
=
'
I
'
&
&
/
^
I
(
\
d
+
)
VARIABLE
(
[
^
\
]
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
name
=
match
[
2
]
;
if
(
!
indirectCallCannotGC
(
functionNames
[
caller
]
name
)
&
&
!
(
limits
&
LIMIT_CANNOT_GC
)
)
{
addGCFunction
(
caller
"
IndirectCall
:
"
+
name
functionLimits
)
;
}
}
else
if
(
match
=
tag
=
=
'
F
'
&
&
/
^
F
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
fullfield
=
match
[
2
]
|
0
;
const
csu
=
match
[
3
]
;
const
fullfield_str
=
csu
+
"
.
"
+
match
[
4
]
;
assert
(
functionNames
[
fullfield
]
=
=
fullfield_str
)
;
if
(
limits
)
fieldCallLimits
[
fullfield
]
=
limits
;
addToKeyedList
(
calleesOf
caller
{
callee
:
fullfield
limits
}
)
;
fieldCallCSU
.
set
(
fullfield
csu
)
;
}
else
if
(
match
=
tag
=
=
'
V
'
&
&
/
^
V
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
}
else
if
(
match
=
tag
=
=
'
D
'
&
&
/
^
D
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
callee
=
match
[
2
]
|
0
;
addToKeyedList
(
calleesOf
caller
{
callee
:
callee
limits
:
limits
}
)
;
}
else
if
(
match
=
tag
=
=
'
R
'
&
&
/
^
R
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
assert
(
false
"
R
tag
is
no
longer
used
"
)
;
}
else
if
(
match
=
tag
=
=
'
T
'
&
&
/
^
T
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
id
=
match
[
1
]
|
0
;
let
tag
=
match
[
2
]
;
if
(
tag
=
=
'
GC
Call
'
)
{
addGCFunction
(
id
"
GC
"
functionLimits
)
;
numGCCalls
+
+
;
}
}
else
{
assert
(
false
"
Invalid
format
in
callgraph
line
:
"
+
line
)
;
}
}
callersOf
=
merge_repeated_calls
(
calleesOf
)
;
for
(
var
func
of
extraGCFunctions
(
)
)
{
addGCFunction
(
mangledToId
[
func
]
"
annotation
"
functionLimits
)
;
}
const
unknown
=
mangledToId
[
'
(
unknown
-
definition
)
'
]
;
if
(
unknown
)
{
addGCFunction
(
unknown
"
internal
"
functionLimits
)
;
}
for
(
var
[
name
limits
]
of
Object
.
entries
(
fieldCallLimits
)
)
{
if
(
limits
)
functionLimits
[
name
]
=
limits
;
}
var
roots
=
gather_simple_roots
(
functionLimits
callersOf
)
;
propagate_limits
(
roots
functionLimits
calleesOf
)
;
const
recursive_roots
=
gather_recursive_roots
(
functionLimits
calleesOf
callersOf
)
;
propagate_limits
(
recursive_roots
functionLimits
calleesOf
)
;
for
(
var
name
in
gcFunctions
)
{
if
(
functionLimits
[
name
]
&
LIMIT_CANNOT_GC
)
delete
gcFunctions
[
name
]
;
}
assert
(
numGCCalls
>
0
"
No
GC
functions
found
!
"
)
;
var
worklist
=
[
]
;
for
(
const
name
in
gcFunctions
)
worklist
.
push
(
name
)
;
for
(
const
[
name
csuName
]
of
fieldCallCSU
)
{
const
fullFieldName
=
functionNames
[
name
]
;
if
(
!
fieldCallCannotGC
(
csuName
fullFieldName
)
)
{
gcFunctions
[
name
]
=
'
arbitrary
function
pointer
'
+
fullFieldName
;
worklist
.
push
(
name
)
;
}
}
while
(
worklist
.
length
)
{
name
=
worklist
.
shift
(
)
;
assert
(
name
in
gcFunctions
"
gcFunctions
does
not
contain
"
+
name
)
;
if
(
!
(
name
in
callersOf
)
)
continue
;
for
(
const
{
caller
limits
}
of
callersOf
[
name
]
)
{
if
(
!
(
limits
&
LIMIT_CANNOT_GC
)
)
{
if
(
addGCFunction
(
caller
name
functionLimits
)
)
worklist
.
push
(
caller
)
;
}
}
}
for
(
const
[
id
limits
]
of
Object
.
entries
(
functionLimits
)
)
limitedFunctions
[
functionNames
[
id
]
]
=
{
limits
}
;
for
(
const
[
id
limits
label
]
of
recursive_roots
)
{
const
name
=
functionNames
[
id
]
;
const
s
=
limitedFunctions
[
name
]
|
|
(
limitedFunctions
[
name
]
=
{
}
)
;
s
.
recursive_root
=
true
;
}
remap_ids_to_mangled_names
(
)
;
}
function
gather_simple_roots
(
functionLimits
callersOf
)
{
const
roots
=
[
]
;
for
(
let
callee
in
callersOf
)
functionLimits
[
callee
]
=
LIMIT_UNVISITED
;
for
(
let
caller
in
calleesOf
)
{
if
(
!
(
caller
in
callersOf
)
)
{
functionLimits
[
caller
]
=
LIMIT_UNVISITED
;
roots
.
push
(
[
caller
LIMIT_NONE
'
root
'
]
)
;
}
}
return
roots
;
}
function
propagate_limits
(
roots
functionLimits
calleesOf
)
{
const
worklist
=
Array
.
from
(
roots
)
;
let
top
=
worklist
.
length
;
while
(
top
>
0
)
{
const
[
caller
edge_limits
callercaller
]
=
worklist
[
-
-
top
]
;
const
prev_limits
=
functionLimits
[
caller
]
;
if
(
prev_limits
&
~
edge_limits
)
{
const
new_limits
=
prev_limits
&
edge_limits
;
if
(
new_limits
)
functionLimits
[
caller
]
=
new_limits
;
else
delete
functionLimits
[
caller
]
;
for
(
const
{
callee
limits
}
of
(
calleesOf
[
caller
]
|
|
[
]
)
)
worklist
[
top
+
+
]
=
[
callee
limits
|
edge_limits
caller
]
;
}
}
}
function
gather_recursive_roots
(
functionLimits
calleesOf
callersOf
)
{
const
roots
=
[
]
;
const
seen
=
new
Set
(
)
;
for
(
let
func
in
functionLimits
)
{
func
=
func
|
0
;
if
(
functionLimits
[
func
]
!
=
LIMIT_UNVISITED
)
continue
;
assert
(
callersOf
[
func
]
.
length
>
0
)
;
if
(
seen
.
has
(
func
)
)
continue
;
const
work
=
[
func
]
;
while
(
work
.
length
>
0
)
{
const
f
=
work
.
pop
(
)
;
for
(
const
callee
of
(
calleesOf
[
f
]
|
|
[
]
)
.
map
(
o
=
>
o
.
callee
)
)
{
if
(
!
seen
.
has
(
callee
)
&
&
callee
!
=
func
&
&
functionLimits
[
callee
]
=
=
LIMIT_UNVISITED
)
{
work
.
push
(
callee
)
;
seen
.
add
(
callee
)
;
}
}
}
assert
(
!
seen
.
has
(
func
)
)
;
seen
.
add
(
func
)
;
if
(
callersOf
[
func
]
.
findIndex
(
o
=
>
!
seen
.
has
(
o
.
caller
)
)
=
=
-
1
)
{
roots
.
push
(
[
func
LIMIT_NONE
'
recursive
-
root
'
]
)
;
}
}
return
roots
;
}
function
remap_ids_to_mangled_names
(
)
{
var
tmp
=
gcFunctions
;
gcFunctions
=
{
}
;
for
(
const
[
caller
reason
]
of
Object
.
entries
(
tmp
)
)
gcFunctions
[
functionNames
[
caller
]
]
=
functionNames
[
reason
]
|
|
reason
;
}
