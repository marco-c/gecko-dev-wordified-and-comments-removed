"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
callgraph
.
js
'
)
;
var
readableNames
=
{
}
;
var
calleesOf
=
{
}
;
var
callersOf
;
var
gcFunctions
=
{
}
;
var
limitedFunctions
=
{
}
;
var
gcEdges
=
{
}
;
var
functionNames
=
[
"
"
]
;
var
mangledToId
=
{
}
;
function
addGCFunction
(
caller
reason
functionAttrs
)
{
if
(
functionAttrs
[
caller
]
&
&
functionAttrs
[
caller
]
[
1
]
&
ATTR_GC_SUPPRESSED
)
return
false
;
if
(
ignoreGCFunction
(
functionNames
[
caller
]
)
)
return
false
;
if
(
!
(
caller
in
gcFunctions
)
)
{
gcFunctions
[
caller
]
=
reason
;
return
true
;
}
return
false
;
}
function
merge_repeated_calls
(
calleesOf
)
{
const
callersOf
=
Object
.
create
(
null
)
;
for
(
const
[
caller_prop
callee_attrs
]
of
Object
.
entries
(
calleesOf
)
)
{
const
caller
=
caller_prop
|
0
;
const
ordered_callees
=
[
]
;
const
callee2any
=
new
Map
(
)
;
const
callee2all
=
new
Map
(
)
;
for
(
const
{
callee
any
all
}
of
callee_attrs
)
{
const
prev_any
=
callee2any
.
get
(
callee
)
;
if
(
prev_any
=
=
=
undefined
)
{
assert
(
!
callee2all
.
has
(
callee
)
)
;
callee2any
.
set
(
callee
any
)
;
callee2all
.
set
(
callee
all
)
;
ordered_callees
.
push
(
callee
)
;
}
else
{
const
prev_all
=
callee2all
.
get
(
callee
)
;
callee2any
.
set
(
callee
prev_any
|
any
)
;
callee2all
.
set
(
callee
prev_all
&
all
)
;
}
}
callee_attrs
.
length
=
0
;
for
(
const
callee
of
ordered_callees
)
{
const
any
=
callee2any
.
get
(
callee
)
;
const
all
=
callee2all
.
get
(
callee
)
;
callee_attrs
.
push
(
{
callee
any
all
}
)
;
if
(
!
(
callee
in
callersOf
)
)
callersOf
[
callee
]
=
[
]
;
callersOf
[
callee
]
.
push
(
{
caller
any
all
}
)
;
}
}
return
callersOf
;
}
function
loadCallgraph
(
file
)
{
const
fieldCallAttrs
=
{
}
;
const
fieldCallCSU
=
new
Map
(
)
;
var
functionAttrs
=
{
}
;
let
numGCCalls
=
0
;
for
(
let
line
of
readFileLines_gen
(
file
)
)
{
line
=
line
.
replace
(
/
\
n
/
"
"
)
;
let
match
;
if
(
match
=
line
.
charAt
(
0
)
=
=
"
#
"
&
&
/
^
\
#
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
mangled
]
=
match
;
assert
(
functionNames
.
length
=
=
id
)
;
functionNames
.
push
(
mangled
)
;
mangledToId
[
mangled
]
=
id
;
continue
;
}
if
(
match
=
line
.
charAt
(
0
)
=
=
"
=
"
&
&
/
^
=
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
readable
]
=
match
;
const
mangled
=
functionNames
[
id
]
;
if
(
mangled
in
readableNames
)
readableNames
[
mangled
]
.
push
(
readable
)
;
else
readableNames
[
mangled
]
=
[
readable
]
;
continue
;
}
let
attrs
=
0
;
if
(
line
.
indexOf
(
"
/
"
)
!
=
-
1
)
{
match
=
/
^
(
.
.
)
\
/
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
;
line
=
match
[
1
]
+
match
[
3
]
;
attrs
=
match
[
2
]
|
0
;
}
const
tag
=
line
.
charAt
(
0
)
;
if
(
match
=
tag
=
=
'
I
'
&
&
/
^
I
(
\
d
+
)
VARIABLE
(
[
^
\
]
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
name
=
match
[
2
]
;
if
(
!
indirectCallCannotGC
(
functionNames
[
caller
]
name
)
&
&
!
(
attrs
&
ATTR_GC_SUPPRESSED
)
)
{
addGCFunction
(
caller
"
IndirectCall
:
"
+
name
functionAttrs
)
;
}
}
else
if
(
match
=
tag
=
=
'
F
'
&
&
/
^
F
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
fullfield
=
match
[
2
]
|
0
;
const
csu
=
match
[
3
]
;
const
fullfield_str
=
csu
+
"
.
"
+
match
[
4
]
;
assert
(
functionNames
[
fullfield
]
=
=
fullfield_str
)
;
if
(
attrs
)
fieldCallAttrs
[
fullfield
]
=
attrs
;
addToKeyedList
(
calleesOf
caller
{
callee
:
fullfield
any
:
attrs
all
:
attrs
}
)
;
fieldCallCSU
.
set
(
fullfield
csu
)
;
}
else
if
(
match
=
tag
=
=
'
V
'
&
&
/
^
V
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
}
else
if
(
match
=
tag
=
=
'
D
'
&
&
/
^
D
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
callee
=
match
[
2
]
|
0
;
addToKeyedList
(
calleesOf
caller
{
callee
any
:
attrs
all
:
attrs
}
)
;
}
else
if
(
match
=
tag
=
=
'
R
'
&
&
/
^
R
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
assert
(
false
"
R
tag
is
no
longer
used
"
)
;
}
else
if
(
match
=
tag
=
=
'
T
'
&
&
/
^
T
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
id
=
match
[
1
]
|
0
;
let
tag
=
match
[
2
]
;
if
(
tag
=
=
'
GC
Call
'
)
{
addGCFunction
(
id
"
GC
"
functionAttrs
)
;
numGCCalls
+
+
;
}
}
else
{
assert
(
false
"
Invalid
format
in
callgraph
line
:
"
+
line
)
;
}
}
callersOf
=
merge_repeated_calls
(
calleesOf
)
;
assert
(
ID
.
jscode
=
=
mangledToId
[
"
(
js
-
code
)
"
]
)
;
assert
(
ID
.
anyfunc
=
=
mangledToId
[
"
(
any
-
function
)
"
]
)
;
assert
(
ID
.
nogcfunc
=
=
mangledToId
[
"
(
nogc
-
function
)
"
]
)
;
assert
(
ID
.
gc
=
=
mangledToId
[
"
(
GC
)
"
]
)
;
addToKeyedList
(
calleesOf
mangledToId
[
"
(
any
-
function
)
"
]
{
callee
:
ID
.
gc
any
:
0
all
:
0
}
)
;
for
(
var
[
name
attrs
]
of
Object
.
entries
(
fieldCallAttrs
)
)
functionAttrs
[
name
]
=
[
attrs
attrs
]
;
functionAttrs
[
ID
.
gc
]
=
[
0
0
]
;
addGCFunction
(
ID
.
gc
"
annotation
"
functionAttrs
)
;
for
(
var
func
of
extraGCFunctions
(
)
)
{
addGCFunction
(
mangledToId
[
func
]
"
annotation
"
functionAttrs
)
;
}
const
unknown
=
mangledToId
[
'
(
unknown
-
definition
)
'
]
;
if
(
unknown
)
{
addGCFunction
(
unknown
"
internal
"
functionAttrs
)
;
}
for
(
var
[
name
attrs
]
of
Object
.
entries
(
fieldCallAttrs
)
)
functionAttrs
[
name
]
=
[
attrs
attrs
]
;
const
simple_roots
=
gather_simple_roots
(
functionAttrs
callersOf
)
;
propagate_attrs
(
simple_roots
functionAttrs
calleesOf
)
;
const
recursive_roots
=
gather_recursive_roots
(
functionAttrs
calleesOf
callersOf
)
;
propagate_attrs
(
recursive_roots
functionAttrs
calleesOf
)
;
for
(
const
[
f
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
{
if
(
any
=
=
0
&
&
all
=
=
0
)
delete
functionAttrs
[
f
]
;
if
(
all
&
ATTR_GC_SUPPRESSED
)
delete
gcFunctions
[
name
]
;
}
assert
(
numGCCalls
>
0
"
No
GC
functions
found
!
"
)
;
const
worklist
=
Object
.
keys
(
gcFunctions
)
;
for
(
const
[
name
csuName
]
of
fieldCallCSU
)
{
const
fullFieldName
=
functionNames
[
name
]
;
if
(
!
fieldCallCannotGC
(
csuName
fullFieldName
)
)
{
gcFunctions
[
name
]
=
'
arbitrary
function
pointer
'
+
fullFieldName
;
worklist
.
push
(
name
)
;
}
}
while
(
worklist
.
length
)
{
name
=
worklist
.
shift
(
)
;
assert
(
name
in
gcFunctions
"
gcFunctions
does
not
contain
"
+
name
)
;
if
(
!
(
name
in
callersOf
)
)
continue
;
for
(
const
{
caller
any
all
}
of
callersOf
[
name
]
)
{
if
(
!
(
all
&
ATTR_GC_SUPPRESSED
)
)
{
if
(
addGCFunction
(
caller
name
functionAttrs
)
)
worklist
.
push
(
caller
)
;
}
}
}
for
(
const
[
id
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
limitedFunctions
[
functionNames
[
id
]
]
=
{
attributes
:
all
}
;
for
(
const
[
id
limits
label
]
of
recursive_roots
)
{
const
name
=
functionNames
[
id
]
;
const
s
=
limitedFunctions
[
name
]
|
|
(
limitedFunctions
[
name
]
=
{
}
)
;
s
.
recursive_root
=
true
;
}
remap_ids_to_mangled_names
(
)
;
}
function
gather_simple_roots
(
functionAttrs
callersOf
)
{
const
roots
=
[
]
;
for
(
let
callee
in
callersOf
)
functionAttrs
[
callee
]
=
[
ATTRS_NONE
ATTRS_UNVISITED
]
;
for
(
let
caller
in
calleesOf
)
{
functionAttrs
[
caller
]
=
[
ATTRS_NONE
ATTRS_UNVISITED
]
;
if
(
!
(
caller
in
callersOf
)
)
roots
.
push
(
[
caller
ATTRS_NONE
'
root
'
]
)
;
}
return
roots
;
}
function
propagate_attrs
(
roots
functionAttrs
calleesOf
)
{
const
worklist
=
Array
.
from
(
roots
)
;
let
top
=
worklist
.
length
;
while
(
top
>
0
)
{
const
[
caller
edge_attrs
callercaller
]
=
worklist
[
-
-
top
]
;
assert
(
caller
in
functionAttrs
)
;
const
[
prev_any
prev_all
]
=
functionAttrs
[
caller
]
;
assert
(
prev_any
!
=
=
undefined
)
;
assert
(
prev_all
!
=
=
undefined
)
;
const
[
new_any
new_all
]
=
[
prev_any
|
edge_attrs
prev_all
&
edge_attrs
]
;
if
(
prev_any
!
=
new_any
|
|
prev_all
!
=
new_all
)
{
functionAttrs
[
caller
]
=
[
new_any
new_all
]
;
for
(
const
{
callee
any
all
}
of
(
calleesOf
[
caller
]
|
|
[
]
)
)
worklist
[
top
+
+
]
=
[
callee
all
|
edge_attrs
caller
]
;
}
}
}
function
gather_recursive_roots
(
functionAttrs
calleesOf
callersOf
)
{
const
roots
=
[
]
;
const
seen
=
new
Set
(
)
;
for
(
let
[
func
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
{
func
=
func
|
0
;
if
(
all
!
=
ATTRS_UNVISITED
)
continue
;
assert
(
callersOf
[
func
]
.
length
>
0
)
;
if
(
seen
.
has
(
func
)
)
continue
;
const
work
=
[
func
]
;
while
(
work
.
length
>
0
)
{
const
f
=
work
.
pop
(
)
;
for
(
const
callee
of
(
calleesOf
[
f
]
|
|
[
]
)
.
map
(
o
=
>
o
.
callee
)
)
{
if
(
!
seen
.
has
(
callee
)
&
&
callee
!
=
func
&
&
functionAttrs
[
callee
]
[
1
]
=
=
ATTRS_UNVISITED
)
{
work
.
push
(
callee
)
;
seen
.
add
(
callee
)
;
}
}
}
assert
(
!
seen
.
has
(
func
)
)
;
seen
.
add
(
func
)
;
if
(
callersOf
[
func
]
.
findIndex
(
o
=
>
!
seen
.
has
(
o
.
caller
)
)
=
=
-
1
)
{
roots
.
push
(
[
func
ATTRS_NONE
'
recursive
-
root
'
]
)
;
}
}
return
roots
;
}
function
remap_ids_to_mangled_names
(
)
{
var
tmp
=
gcFunctions
;
gcFunctions
=
{
}
;
for
(
const
[
caller
reason
]
of
Object
.
entries
(
tmp
)
)
gcFunctions
[
functionNames
[
caller
]
]
=
functionNames
[
reason
]
|
|
reason
;
}
