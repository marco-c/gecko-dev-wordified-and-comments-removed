"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
callgraph
.
js
'
)
;
var
gcEdges
=
{
}
;
function
addGCFunction
(
caller
reason
gcFunctions
functionAttrs
functions
)
{
if
(
functionAttrs
[
caller
]
&
&
functionAttrs
[
caller
]
[
1
]
&
ATTR_GC_SUPPRESSED
)
return
false
;
if
(
ignoreGCFunction
(
functions
.
name
[
caller
]
functions
.
readableName
)
)
return
false
;
if
(
!
(
caller
in
gcFunctions
)
)
{
gcFunctions
[
caller
]
=
reason
;
return
true
;
}
return
false
;
}
function
generate_callgraph
(
rawCallees
)
{
const
callersOf
=
new
Map
(
)
;
const
calleesOf
=
new
Map
(
)
;
for
(
const
[
caller
callee_attrs
]
of
rawCallees
)
{
const
ordered_callees
=
[
]
;
const
callee2any
=
new
Map
(
)
;
const
callee2all
=
new
Map
(
)
;
for
(
const
{
callee
any
all
}
of
callee_attrs
)
{
const
prev_any
=
callee2any
.
get
(
callee
)
;
if
(
prev_any
=
=
=
undefined
)
{
assert
(
!
callee2all
.
has
(
callee
)
)
;
callee2any
.
set
(
callee
any
)
;
callee2all
.
set
(
callee
all
)
;
ordered_callees
.
push
(
callee
)
;
}
else
{
const
prev_all
=
callee2all
.
get
(
callee
)
;
callee2any
.
set
(
callee
prev_any
|
any
)
;
callee2all
.
set
(
callee
prev_all
&
all
)
;
}
}
callee_attrs
.
length
=
0
;
for
(
const
callee
of
ordered_callees
)
{
const
any
=
callee2any
.
get
(
callee
)
;
const
all
=
callee2all
.
get
(
callee
)
;
if
(
!
calleesOf
.
has
(
caller
)
)
calleesOf
.
set
(
caller
new
Map
(
)
)
;
calleesOf
.
get
(
caller
)
.
set
(
callee
{
any
all
}
)
;
if
(
!
callersOf
.
has
(
callee
)
)
callersOf
.
set
(
callee
new
Map
(
)
)
;
callersOf
.
get
(
callee
)
.
set
(
caller
{
any
all
}
)
;
}
}
return
{
callersOf
calleesOf
}
;
}
function
loadRawCallgraphFile
(
file
)
{
const
functions
=
{
name
:
[
"
"
]
readableName
:
{
}
mangledToId
:
{
}
}
;
const
fieldCallAttrs
=
{
}
;
const
fieldCallCSU
=
new
Map
(
)
;
var
functionAttrs
=
{
}
;
const
gcCalls
=
[
]
;
const
indirectCalls
=
[
]
;
const
rawCallees
=
new
Map
(
)
;
for
(
let
line
of
readFileLines_gen
(
file
)
)
{
line
=
line
.
replace
(
/
\
n
/
"
"
)
;
let
match
;
if
(
match
=
line
.
charAt
(
0
)
=
=
"
#
"
&
&
/
^
\
#
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
mangled
]
=
match
;
assert
(
functions
.
name
.
length
=
=
id
)
;
functions
.
name
.
push
(
mangled
)
;
functions
.
mangledToId
[
mangled
]
=
id
|
0
;
continue
;
}
if
(
match
=
line
.
charAt
(
0
)
=
=
"
=
"
&
&
/
^
=
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
readable
]
=
match
;
const
mangled
=
functions
.
name
[
id
]
;
if
(
mangled
in
functions
.
readableName
)
functions
.
readableName
[
mangled
]
.
push
(
readable
)
;
else
functions
.
readableName
[
mangled
]
=
[
readable
]
;
continue
;
}
let
attrs
=
0
;
if
(
line
.
indexOf
(
"
/
"
)
!
=
-
1
)
{
match
=
/
^
(
.
.
)
\
/
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
;
line
=
match
[
1
]
+
match
[
3
]
;
attrs
=
match
[
2
]
|
0
;
}
const
tag
=
line
.
charAt
(
0
)
;
if
(
match
=
tag
=
=
'
I
'
&
&
/
^
I
(
\
d
+
)
VARIABLE
(
[
^
\
]
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
name
=
match
[
2
]
;
if
(
indirectCallCannotGC
(
functions
.
name
[
caller
]
name
)
)
attrs
|
=
ATTR_GC_SUPPRESSED
;
indirectCalls
.
push
(
[
caller
"
IndirectCall
:
"
+
name
attrs
]
)
;
}
else
if
(
match
=
tag
=
=
'
F
'
&
&
/
^
F
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
fullfield
=
match
[
2
]
|
0
;
const
csu
=
match
[
3
]
;
const
fullfield_str
=
csu
+
"
.
"
+
match
[
4
]
;
assert
(
functions
.
name
[
fullfield
]
=
=
fullfield_str
)
;
if
(
attrs
)
fieldCallAttrs
[
fullfield
]
=
attrs
;
addToMappedList
(
rawCallees
caller
{
callee
:
fullfield
any
:
attrs
all
:
attrs
}
)
;
fieldCallCSU
.
set
(
fullfield
csu
)
;
if
(
fieldCallCannotGC
(
csu
fullfield_str
)
)
addToMappedList
(
rawCallees
fullfield
{
callee
:
ID
.
nogcfunc
any
:
0
all
:
0
}
)
;
else
addToMappedList
(
rawCallees
fullfield
{
callee
:
ID
.
anyfunc
any
:
0
all
:
0
}
)
;
}
else
if
(
match
=
tag
=
=
'
V
'
&
&
/
^
V
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
}
else
if
(
match
=
tag
=
=
'
D
'
&
&
/
^
D
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
callee
=
match
[
2
]
|
0
;
addToMappedList
(
rawCallees
caller
{
callee
any
:
attrs
all
:
attrs
}
)
;
}
else
if
(
match
=
tag
=
=
'
R
'
&
&
/
^
R
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
assert
(
false
"
R
tag
is
no
longer
used
"
)
;
}
else
if
(
match
=
tag
=
=
'
T
'
&
&
/
^
T
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
id
=
match
[
1
]
|
0
;
let
tag
=
match
[
2
]
;
if
(
tag
=
=
'
GC
Call
'
)
gcCalls
.
push
(
id
)
;
}
else
{
assert
(
false
"
Invalid
format
in
callgraph
line
:
"
+
line
)
;
}
}
printErr
(
"
Loaded
"
+
file
)
;
return
{
fieldCallAttrs
fieldCallCSU
gcCalls
indirectCalls
rawCallees
functions
}
;
}
function
mergeRawCallgraphs
(
filenames
)
{
let
d
;
for
(
const
filename
of
filenames
)
{
const
raw
=
loadRawCallgraphFile
(
filename
)
;
if
(
!
d
)
{
d
=
raw
;
continue
;
}
const
{
fieldCallAttrs
fieldCallCSU
gcCalls
indirectCalls
rawCallees
functions
}
=
raw
;
const
remap
=
new
Array
(
functions
.
name
.
length
)
;
for
(
let
i
=
1
;
i
<
functions
.
name
.
length
;
i
+
+
)
{
const
mangled
=
functions
.
name
[
i
]
;
const
old_id
=
d
.
functions
.
mangledToId
[
mangled
]
if
(
old_id
)
{
remap
[
i
]
=
old_id
;
}
else
{
const
newid
=
d
.
functions
.
name
.
length
;
d
.
functions
.
mangledToId
[
mangled
]
=
newid
;
d
.
functions
.
name
.
push
(
mangled
)
;
remap
[
i
]
=
newid
;
assert
(
!
(
mangled
in
d
.
functions
.
readableName
)
mangled
+
"
readable
name
is
already
found
"
)
;
const
readables
=
functions
.
readableName
[
mangled
]
;
if
(
readables
!
=
=
undefined
)
d
.
functions
.
readableName
[
mangled
]
=
readables
;
}
}
for
(
const
[
fullfield
attrs
]
of
Object
.
entries
(
fieldCallAttrs
)
)
d
.
fieldCallAttrs
[
remap
[
fullfield
]
]
=
attrs
;
for
(
const
[
fullfield
csu
]
of
fieldCallCSU
.
entries
(
)
)
d
.
fieldCallCSU
.
set
(
remap
[
fullfield
]
csu
)
;
for
(
const
call
of
gcCalls
)
d
.
gcCalls
.
push
(
remap
[
call
]
)
;
for
(
const
[
caller
name
attrs
]
of
indirectCalls
)
d
.
indirectCalls
.
push
(
[
remap
[
caller
]
name
attrs
]
)
;
for
(
const
[
caller
callees
]
of
rawCallees
)
{
for
(
const
{
callee
any
all
}
of
callees
)
{
addToMappedList
(
d
.
rawCallees
remap
[
caller
]
|
0
{
callee
:
remap
[
callee
]
any
all
}
)
;
}
}
}
return
d
;
}
function
loadCallgraph
(
files
)
{
const
{
fieldCallAttrs
fieldCallCSU
gcCalls
indirectCalls
rawCallees
functions
}
=
mergeRawCallgraphs
(
files
)
;
assert
(
ID
.
jscode
=
=
functions
.
mangledToId
[
"
(
js
-
code
)
"
]
)
;
assert
(
ID
.
anyfunc
=
=
functions
.
mangledToId
[
"
(
any
-
function
)
"
]
)
;
assert
(
ID
.
nogcfunc
=
=
functions
.
mangledToId
[
"
(
nogc
-
function
)
"
]
)
;
assert
(
ID
.
gc
=
=
functions
.
mangledToId
[
"
(
GC
)
"
]
)
;
addToMappedList
(
rawCallees
functions
.
mangledToId
[
"
(
any
-
function
)
"
]
{
callee
:
ID
.
gc
any
:
0
all
:
0
}
)
;
const
functionAttrs
=
{
}
;
for
(
var
[
name
attrs
]
of
Object
.
entries
(
fieldCallAttrs
)
)
functionAttrs
[
name
]
=
[
attrs
attrs
]
;
const
gcFunctions
=
{
[
ID
.
gc
]
:
'
internal
'
}
;
for
(
var
func
of
extraGCFunctions
(
functions
.
readableName
)
)
{
addGCFunction
(
functions
.
mangledToId
[
func
]
"
annotation
"
gcFunctions
functionAttrs
functions
)
;
}
for
(
const
func
of
gcCalls
)
addToMappedList
(
rawCallees
func
{
callee
:
ID
.
gc
any
:
0
all
:
0
}
)
;
for
(
const
[
caller
indirect
attrs
]
of
indirectCalls
)
{
const
id
=
functions
.
name
.
length
;
functions
.
name
.
push
(
indirect
)
;
functions
.
mangledToId
[
indirect
]
=
id
;
addToMappedList
(
rawCallees
caller
{
callee
:
id
any
:
attrs
all
:
attrs
}
)
;
addToMappedList
(
rawCallees
id
{
callee
:
ID
.
anyfunc
any
:
0
all
:
0
}
)
;
}
const
{
callersOf
calleesOf
}
=
generate_callgraph
(
rawCallees
)
;
for
(
var
[
name
attrs
]
of
Object
.
entries
(
fieldCallAttrs
)
)
functionAttrs
[
name
]
=
[
attrs
attrs
]
;
const
simple_roots
=
gather_simple_roots
(
functionAttrs
calleesOf
callersOf
)
;
propagate_attrs
(
simple_roots
functionAttrs
calleesOf
)
;
const
recursive_roots
=
gather_recursive_roots
(
functionAttrs
calleesOf
callersOf
functions
)
;
propagate_attrs
(
recursive_roots
functionAttrs
calleesOf
)
;
for
(
const
[
f
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
{
if
(
any
=
=
0
&
&
all
=
=
0
)
delete
functionAttrs
[
f
]
;
if
(
all
&
ATTR_GC_SUPPRESSED
)
delete
gcFunctions
[
name
]
;
}
assert
(
gcCalls
.
length
>
0
"
No
GC
functions
found
!
"
)
;
const
worklist
=
[
ID
.
gc
]
;
for
(
const
[
name
csuName
]
of
fieldCallCSU
)
{
const
fullFieldName
=
functions
.
name
[
name
]
;
if
(
!
fieldCallCannotGC
(
csuName
fullFieldName
)
)
{
gcFunctions
[
name
]
=
'
arbitrary
function
pointer
'
+
fullFieldName
;
worklist
.
push
(
name
)
;
}
}
while
(
worklist
.
length
)
{
name
=
worklist
.
shift
(
)
;
assert
(
name
in
gcFunctions
"
gcFunctions
does
not
contain
"
+
name
)
;
if
(
!
callersOf
.
has
(
name
)
)
continue
;
for
(
const
[
caller
{
any
all
}
]
of
callersOf
.
get
(
name
)
)
{
if
(
!
(
all
&
ATTR_GC_SUPPRESSED
)
)
{
if
(
addGCFunction
(
caller
name
gcFunctions
functionAttrs
functions
)
)
worklist
.
push
(
caller
)
;
}
}
}
var
limitedFunctions
=
{
}
;
for
(
const
[
id
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
limitedFunctions
[
functions
.
name
[
id
]
]
=
{
attributes
:
all
}
;
for
(
const
[
id
limits
label
]
of
recursive_roots
)
{
const
name
=
functions
.
name
[
id
]
;
const
s
=
limitedFunctions
[
name
]
|
|
(
limitedFunctions
[
name
]
=
{
}
)
;
s
.
recursive_root
=
true
;
}
const
namedGCFunctions
=
{
}
;
for
(
const
[
caller
reason
]
of
Object
.
entries
(
gcFunctions
)
)
{
namedGCFunctions
[
functions
.
name
[
caller
]
]
=
functions
.
name
[
reason
]
|
|
reason
;
}
return
{
gcFunctions
:
namedGCFunctions
functions
calleesOf
callersOf
limitedFunctions
}
;
}
function
saveCallgraph
(
functions
calleesOf
)
{
let
id
=
-
1
;
for
(
const
name
of
functions
.
name
)
{
id
+
=
1
;
if
(
id
=
=
0
)
continue
;
print
(
#
{
id
}
{
name
}
)
;
for
(
const
readable
of
(
functions
.
readableName
[
name
]
|
|
[
]
)
)
{
if
(
readable
!
=
name
)
print
(
=
{
id
}
{
readable
}
)
;
}
}
const
attrstring
=
range
=
>
range
.
any
|
|
range
.
all
?
{
range
.
all
}
:
{
range
.
any
}
:
'
'
;
for
(
const
[
caller
callees
]
of
calleesOf
)
{
for
(
const
[
callee
attrs
]
of
callees
)
{
print
(
D
{
attrstring
(
attrs
)
}
{
caller
}
{
callee
}
)
;
}
}
}
function
gather_simple_roots
(
functionAttrs
calleesOf
callersOf
)
{
const
roots
=
[
]
;
for
(
const
callee
of
callersOf
.
keys
(
)
)
functionAttrs
[
callee
]
=
[
ATTRS_NONE
ATTRS_UNVISITED
]
;
for
(
const
caller
of
calleesOf
.
keys
(
)
)
{
functionAttrs
[
caller
]
=
[
ATTRS_NONE
ATTRS_UNVISITED
]
;
if
(
!
callersOf
.
has
(
caller
)
)
roots
.
push
(
[
caller
ATTRS_NONE
'
root
'
]
)
;
}
return
roots
;
}
function
propagate_attrs
(
roots
functionAttrs
calleesOf
)
{
const
worklist
=
Array
.
from
(
roots
)
;
let
top
=
worklist
.
length
;
while
(
top
>
0
)
{
const
[
caller
edge_attrs
callercaller
]
=
worklist
[
-
-
top
]
;
assert
(
caller
in
functionAttrs
)
;
const
[
prev_any
prev_all
]
=
functionAttrs
[
caller
]
;
assert
(
prev_any
!
=
=
undefined
)
;
assert
(
prev_all
!
=
=
undefined
)
;
const
[
new_any
new_all
]
=
[
prev_any
|
edge_attrs
prev_all
&
edge_attrs
]
;
if
(
prev_any
!
=
new_any
|
|
prev_all
!
=
new_all
)
{
functionAttrs
[
caller
]
=
[
new_any
new_all
]
;
for
(
const
[
callee
{
any
all
}
]
of
(
calleesOf
.
get
(
caller
)
|
|
new
Map
)
)
worklist
[
top
+
+
]
=
[
callee
all
|
edge_attrs
caller
]
;
}
}
}
function
gather_recursive_roots
(
functionAttrs
calleesOf
callersOf
functions
)
{
const
roots
=
[
]
;
const
seen
=
new
Set
(
)
;
for
(
let
[
func
[
any
all
]
]
of
Object
.
entries
(
functionAttrs
)
)
{
func
=
func
|
0
;
if
(
all
!
=
ATTRS_UNVISITED
)
continue
;
assert
(
callersOf
.
has
(
func
)
)
;
assert
(
callersOf
.
get
(
func
)
.
size
>
0
)
;
if
(
seen
.
has
(
func
)
)
continue
;
const
work
=
[
func
]
;
while
(
work
.
length
>
0
)
{
const
f
=
work
.
pop
(
)
;
if
(
!
calleesOf
.
has
(
f
)
)
continue
;
for
(
const
callee
of
calleesOf
.
get
(
f
)
.
keys
(
)
)
{
if
(
!
seen
.
has
(
callee
)
&
&
callee
!
=
func
&
&
functionAttrs
[
callee
]
[
1
]
=
=
ATTRS_UNVISITED
)
{
work
.
push
(
callee
)
;
seen
.
add
(
callee
)
;
}
}
}
assert
(
!
seen
.
has
(
func
)
)
;
seen
.
add
(
func
)
;
if
(
[
.
.
.
callersOf
.
get
(
func
)
.
keys
(
)
]
.
findIndex
(
f
=
>
!
seen
.
has
(
f
)
)
=
=
-
1
)
{
roots
.
push
(
[
func
ATTRS_NONE
'
recursive
-
root
'
]
)
;
}
}
return
roots
;
tmp
=
calleesOf
;
calleesOf
=
{
}
;
for
(
const
[
callerId
callees
]
of
Object
.
entries
(
calleesOf
)
)
{
const
caller
=
functionNames
[
callerId
]
;
for
(
const
{
calleeId
limits
}
of
callees
)
calleesOf
[
caller
]
[
functionNames
[
calleeId
]
]
=
limits
;
}
tmp
=
callersOf
;
callersOf
=
{
}
;
for
(
const
[
calleeId
callers
]
of
Object
.
entries
(
callersOf
)
)
{
const
callee
=
functionNames
[
calleeId
]
;
callersOf
[
callee
]
=
{
}
;
for
(
const
{
callerId
limits
}
of
callers
)
callersOf
[
callee
]
[
functionNames
[
caller
]
]
=
limits
;
}
}
