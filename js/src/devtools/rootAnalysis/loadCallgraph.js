"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
var
readableNames
=
{
}
;
var
calleesOf
=
{
}
;
var
callersOf
;
var
gcFunctions
=
{
}
;
var
limitedFunctions
=
{
}
;
var
gcEdges
=
{
}
;
var
functionNames
=
[
"
"
]
;
var
mangledToId
=
{
}
;
function
addGCFunction
(
caller
reason
functionLimits
)
{
if
(
functionLimits
[
caller
]
&
LIMIT_CANNOT_GC
)
return
false
;
if
(
ignoreGCFunction
(
functionNames
[
caller
]
)
)
return
false
;
if
(
!
(
caller
in
gcFunctions
)
)
{
gcFunctions
[
caller
]
=
reason
;
return
true
;
}
return
false
;
}
function
merge_repeated_calls
(
calleesOf
)
{
const
callersOf
=
Object
.
create
(
null
)
;
for
(
const
[
caller
callee_limits
]
of
Object
.
entries
(
calleesOf
)
)
{
const
ordered_callees
=
[
]
;
const
callee2limit
=
new
Map
(
)
;
for
(
const
{
callee
limits
}
of
callee_limits
)
{
const
prev_limits
=
callee2limit
.
get
(
callee
)
;
if
(
prev_limits
=
=
=
undefined
)
{
callee2limit
.
set
(
callee
limits
)
;
ordered_callees
.
push
(
callee
)
;
}
else
{
callee2limit
.
set
(
callee
prev_limits
&
limits
)
;
}
}
callee_limits
.
length
=
0
;
for
(
const
callee
of
ordered_callees
)
{
const
limits
=
callee2limit
.
get
(
callee
)
;
callee_limits
.
push
(
{
callee
limits
}
)
;
if
(
!
(
callee
in
callersOf
)
)
callersOf
[
callee
]
=
[
]
;
callersOf
[
callee
]
.
push
(
{
caller
limits
}
)
;
}
}
return
callersOf
;
}
function
loadCallgraph
(
file
)
{
const
fieldCallLimits
=
{
}
;
const
fieldCallCSU
=
new
Map
(
)
;
const
resolvedFieldCalls
=
new
Set
(
)
;
var
functionLimits
=
{
}
;
let
numGCCalls
=
0
;
for
(
let
line
of
readFileLines_gen
(
file
)
)
{
line
=
line
.
replace
(
/
\
n
/
"
"
)
;
let
match
;
if
(
match
=
line
.
charAt
(
0
)
=
=
"
#
"
&
&
/
^
\
#
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
mangled
]
=
match
;
assert
(
functionNames
.
length
=
=
id
)
;
functionNames
.
push
(
mangled
)
;
mangledToId
[
mangled
]
=
id
;
continue
;
}
if
(
match
=
line
.
charAt
(
0
)
=
=
"
=
"
&
&
/
^
=
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
[
_
id
readable
]
=
match
;
const
mangled
=
functionNames
[
id
]
;
if
(
mangled
in
readableNames
)
readableNames
[
mangled
]
.
push
(
readable
)
;
else
readableNames
[
mangled
]
=
[
readable
]
;
continue
;
}
let
limits
=
0
;
if
(
line
.
indexOf
(
"
/
"
)
!
=
-
1
)
{
match
=
/
^
(
.
.
)
\
/
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
;
line
=
match
[
1
]
+
match
[
3
]
;
limits
=
match
[
2
]
|
0
;
}
const
tag
=
line
.
charAt
(
0
)
;
if
(
match
=
tag
=
=
'
I
'
&
&
/
^
I
(
\
d
+
)
VARIABLE
(
[
^
\
]
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
name
=
match
[
2
]
;
if
(
!
indirectCallCannotGC
(
functionNames
[
caller
]
name
)
&
&
!
(
limits
&
LIMIT_CANNOT_GC
)
)
{
addGCFunction
(
caller
"
IndirectCall
:
"
+
name
functionLimits
)
;
}
}
else
if
(
match
=
(
tag
=
=
'
F
'
|
|
tag
=
=
'
V
'
)
&
&
/
^
[
FV
]
(
\
d
+
)
(
\
d
+
)
CLASS
(
.
*
?
)
FIELD
(
.
*
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
fullfield
=
match
[
2
]
|
0
;
const
csu
=
match
[
3
]
;
const
fullfield_str
=
csu
+
"
.
"
+
match
[
4
]
;
assert
(
functionNames
[
fullfield
]
=
=
fullfield_str
)
;
if
(
limits
)
fieldCallLimits
[
fullfield
]
=
limits
;
addToKeyedList
(
calleesOf
caller
{
callee
:
fullfield
limits
}
)
;
fieldCallCSU
.
set
(
fullfield
csu
)
;
}
else
if
(
match
=
tag
=
=
'
D
'
&
&
/
^
D
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
const
caller
=
match
[
1
]
|
0
;
const
callee
=
match
[
2
]
|
0
;
addToKeyedList
(
calleesOf
caller
{
callee
:
callee
limits
:
limits
}
)
;
}
else
if
(
match
=
tag
=
=
'
R
'
&
&
/
^
R
(
\
d
+
)
(
\
d
+
)
/
.
exec
(
line
)
)
{
const
callerField
=
match
[
1
]
|
0
;
const
callee
=
match
[
2
]
|
0
;
addToKeyedList
(
calleesOf
callerField
{
callee
:
callee
limits
:
0
}
)
;
resolvedFieldCalls
.
add
(
callerField
)
;
}
else
if
(
match
=
tag
=
=
'
T
'
&
&
/
^
T
(
\
d
+
)
(
.
*
)
/
.
exec
(
line
)
)
{
const
id
=
match
[
1
]
|
0
;
let
tag
=
match
[
2
]
;
if
(
tag
=
=
'
GC
Call
'
)
{
addGCFunction
(
id
"
GC
"
functionLimits
)
;
numGCCalls
+
+
;
}
}
else
{
assert
(
false
"
Invalid
format
in
callgraph
line
:
"
+
line
)
;
}
}
callersOf
=
merge_repeated_calls
(
calleesOf
)
;
for
(
var
func
of
extraGCFunctions
(
)
)
{
addGCFunction
(
mangledToId
[
func
]
"
annotation
"
functionLimits
)
;
}
for
(
var
[
name
limits
]
of
Object
.
entries
(
fieldCallLimits
)
)
{
if
(
limits
)
functionLimits
[
name
]
=
limits
;
}
var
roots
=
gather_simple_roots
(
functionLimits
callersOf
)
;
propagate_limits
(
roots
functionLimits
calleesOf
)
;
roots
=
gather_recursive_roots
(
roots
functionLimits
callersOf
)
;
propagate_limits
(
roots
functionLimits
calleesOf
)
;
for
(
var
name
in
gcFunctions
)
{
if
(
functionLimits
[
name
]
&
LIMIT_CANNOT_GC
)
delete
gcFunctions
[
name
]
;
}
assert
(
numGCCalls
>
0
"
No
GC
functions
found
!
"
)
;
var
worklist
=
[
]
;
for
(
const
name
in
gcFunctions
)
worklist
.
push
(
name
)
;
for
(
const
[
name
csuName
]
of
fieldCallCSU
)
{
if
(
resolvedFieldCalls
.
has
(
name
)
)
continue
;
const
fullFieldName
=
functionNames
[
name
]
;
if
(
!
fieldCallCannotGC
(
csuName
fullFieldName
)
)
{
gcFunctions
[
name
]
=
'
unresolved
'
+
fullFieldName
;
worklist
.
push
(
name
)
;
}
}
while
(
worklist
.
length
)
{
name
=
worklist
.
shift
(
)
;
assert
(
name
in
gcFunctions
"
gcFunctions
does
not
contain
"
+
name
)
;
if
(
!
(
name
in
callersOf
)
)
continue
;
for
(
const
{
caller
limits
}
of
callersOf
[
name
]
)
{
if
(
!
(
limits
&
LIMIT_CANNOT_GC
)
)
{
if
(
addGCFunction
(
caller
name
functionLimits
)
)
worklist
.
push
(
caller
)
;
}
}
}
for
(
const
[
id
limits
]
of
Object
.
entries
(
functionLimits
)
)
limitedFunctions
[
functionNames
[
id
]
]
=
limits
;
remap_ids_to_mangled_names
(
)
;
}
function
gather_simple_roots
(
functionLimits
callersOf
)
{
const
roots
=
[
]
;
for
(
let
callee
in
callersOf
)
functionLimits
[
callee
]
=
LIMIT_UNVISITED
;
for
(
let
caller
in
calleesOf
)
{
if
(
!
(
caller
in
callersOf
)
)
{
functionLimits
[
caller
]
=
LIMIT_UNVISITED
;
roots
.
push
(
[
caller
LIMIT_NONE
'
root
'
]
)
;
}
}
return
roots
;
}
function
propagate_limits
(
worklist
functionLimits
calleesOf
)
{
let
top
=
worklist
.
length
;
while
(
top
>
0
)
{
const
[
caller
edge_limits
callercaller
]
=
worklist
[
-
-
top
]
;
const
prev_limits
=
functionLimits
[
caller
]
;
if
(
prev_limits
&
~
edge_limits
)
{
const
new_limits
=
prev_limits
&
edge_limits
;
if
(
new_limits
)
functionLimits
[
caller
]
=
new_limits
;
else
delete
functionLimits
[
caller
]
;
for
(
const
{
callee
limits
}
of
(
calleesOf
[
caller
]
|
|
[
]
)
)
worklist
[
top
+
+
]
=
[
callee
limits
|
edge_limits
caller
]
;
}
}
}
function
gather_recursive_roots
(
functionLimits
callersOf
)
{
const
roots
=
[
]
;
const
seen
=
new
Map
(
)
;
for
(
var
func
in
functionLimits
)
{
if
(
functionLimits
[
func
]
!
=
LIMIT_UNVISITED
)
continue
;
assert
(
callersOf
[
func
]
.
length
>
0
)
;
const
work
=
[
func
]
;
while
(
work
.
length
>
0
)
{
const
f
=
work
.
pop
(
)
;
if
(
seen
.
has
(
f
)
)
{
if
(
seen
.
get
(
f
)
=
=
func
)
{
roots
.
push
(
[
f
LIMIT_NONE
'
root
'
]
)
;
print
(
recursive
root
?
{
f
}
=
{
functionNames
[
f
]
}
)
;
}
else
{
seen
.
set
(
f
func
)
;
}
}
else
{
print
(
retained
by
recursive
root
?
{
f
}
=
{
functionNames
[
f
]
}
)
;
work
.
push
(
.
.
.
callersOf
[
f
]
)
;
seen
.
set
(
f
func
)
;
}
}
}
return
roots
;
}
function
remap_ids_to_mangled_names
(
)
{
var
tmp
=
gcFunctions
;
gcFunctions
=
{
}
;
for
(
const
[
caller
reason
]
of
Object
.
entries
(
tmp
)
)
gcFunctions
[
functionNames
[
caller
]
]
=
functionNames
[
reason
]
|
|
reason
;
tmp
=
calleesOf
;
calleesOf
=
{
}
;
for
(
const
[
callerId
callees
]
of
Object
.
entries
(
calleesOf
)
)
{
const
caller
=
functionNames
[
callerId
]
;
for
(
const
{
calleeId
limits
}
of
callees
)
calleesOf
[
caller
]
[
functionNames
[
calleeId
]
]
=
limits
;
}
tmp
=
callersOf
;
callersOf
=
{
}
;
for
(
const
[
calleeId
callers
]
of
Object
.
entries
(
callersOf
)
)
{
const
callee
=
functionNames
[
calleeId
]
;
callersOf
[
callee
]
=
{
}
;
for
(
const
{
callerId
limits
}
of
callers
)
callersOf
[
callee
]
[
functionNames
[
caller
]
]
=
limits
;
}
}
