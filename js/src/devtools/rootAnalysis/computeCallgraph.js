"
use
strict
"
;
loadRelativeToScript
(
'
callgraph
.
js
'
)
;
var
theFunctionNameToFind
;
if
(
scriptArgs
[
0
]
=
=
'
-
-
function
'
|
|
scriptArgs
[
0
]
=
=
'
-
f
'
)
{
theFunctionNameToFind
=
scriptArgs
[
1
]
;
scriptArgs
=
scriptArgs
.
slice
(
2
)
;
}
var
typeInfo_filename
=
scriptArgs
[
0
]
|
|
"
typeInfo
.
txt
"
;
var
callgraphOut_filename
=
scriptArgs
[
1
]
|
|
"
callgraph
.
txt
"
;
var
origOut
=
os
.
file
.
redirect
(
callgraphOut_filename
)
;
var
memoized
=
new
Map
(
)
;
var
JSNativeCaller
=
Object
.
create
(
null
)
;
var
JSNatives
=
[
]
;
var
unmangled2id
=
new
Set
(
)
;
function
getId
(
name
)
{
let
id
=
memoized
.
get
(
name
)
;
if
(
id
!
=
=
undefined
)
return
id
;
id
=
memoized
.
size
+
1
;
memoized
.
set
(
name
id
)
;
print
(
#
{
id
}
{
name
}
)
;
return
id
;
}
function
functionId
(
name
)
{
const
[
mangled
unmangled
]
=
splitFunction
(
name
)
;
const
id
=
getId
(
mangled
)
;
if
(
unmangled2id
.
has
(
unmangled
)
)
return
id
;
print
(
=
{
id
}
{
unmangled
}
)
;
unmangled2id
.
add
(
unmangled
)
;
return
id
;
}
var
lastline
;
function
printOnce
(
line
)
{
if
(
line
!
=
lastline
)
{
print
(
line
)
;
lastline
=
line
;
}
}
function
getAllAttributes
(
body
)
{
var
all_annotations
=
{
}
;
for
(
var
v
of
(
body
.
DefineVariable
|
|
[
]
)
)
{
if
(
v
.
Variable
.
Kind
!
=
'
Func
'
)
continue
;
var
name
=
v
.
Variable
.
Name
[
0
]
;
var
annotations
=
all_annotations
[
name
]
=
[
]
;
for
(
var
ann
of
(
v
.
Type
.
Annotation
|
|
[
]
)
)
{
annotations
.
push
(
ann
.
Name
)
;
}
}
return
all_annotations
;
}
function
getAnnotations
(
functionName
body
)
{
var
tags
=
new
Set
(
)
;
var
attributes
=
getAllAttributes
(
body
)
;
if
(
functionName
in
attributes
)
{
for
(
var
[
annName
annValue
]
of
attributes
[
functionName
]
)
{
if
(
annName
=
=
'
annotate
'
)
tags
.
add
(
annValue
)
;
}
}
return
tags
;
}
function
processBody
(
functionName
body
)
{
if
(
!
(
'
PEdge
'
in
body
)
)
return
;
for
(
var
tag
of
getAnnotations
(
functionName
body
)
.
values
(
)
)
{
print
(
"
T
"
+
functionId
(
functionName
)
+
"
"
+
tag
)
;
if
(
tag
=
=
"
Calls
JSNatives
"
)
JSNativeCaller
[
functionName
]
=
true
;
}
var
seen
=
new
Map
(
)
;
lastline
=
null
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
continue
;
var
edgeLimited
=
body
.
limits
[
edge
.
Index
[
0
]
]
|
0
;
for
(
var
callee
of
getCallees
(
edge
)
)
{
const
limits
=
edgeLimited
|
callee
.
limits
;
let
prologue
=
limits
?
/
{
limits
}
:
"
"
;
prologue
+
=
functionId
(
functionName
)
+
"
"
;
if
(
callee
.
kind
=
=
'
direct
'
)
{
const
prev_limits
=
seen
.
has
(
callee
.
name
)
?
seen
.
get
(
callee
.
name
)
:
LIMIT_UNVISITED
;
if
(
prev_limits
&
~
limits
)
{
seen
.
set
(
callee
.
name
prev_limits
&
limits
)
;
printOnce
(
"
D
"
+
prologue
+
functionId
(
callee
.
name
)
)
;
}
}
else
if
(
callee
.
kind
=
=
'
field
'
)
{
var
{
csu
field
isVirtual
}
=
callee
;
const
tag
=
isVirtual
?
'
V
'
:
'
F
'
;
const
fullfield
=
{
csu
}
.
{
field
}
;
printOnce
(
{
tag
}
{
prologue
}
{
getId
(
fullfield
)
}
CLASS
{
csu
}
FIELD
{
field
}
)
;
}
else
if
(
callee
.
kind
=
=
'
resolved
-
field
'
)
{
var
{
csu
field
callees
}
=
callee
;
var
fullFieldName
=
csu
+
"
.
"
+
field
;
if
(
!
virtualResolutionsSeen
.
has
(
fullFieldName
)
)
{
virtualResolutionsSeen
.
add
(
fullFieldName
)
;
for
(
var
target
of
callees
)
printOnce
(
"
R
"
+
getId
(
fullFieldName
)
+
"
"
+
functionId
(
target
.
name
)
)
;
}
}
else
if
(
callee
.
kind
=
=
'
indirect
'
)
{
printOnce
(
"
I
"
+
prologue
+
"
VARIABLE
"
+
callee
.
variable
)
;
}
else
if
(
callee
.
kind
=
=
'
unknown
'
)
{
printOnce
(
"
I
"
+
prologue
+
"
VARIABLE
UNKNOWN
"
)
;
}
else
{
printErr
(
"
invalid
"
+
callee
.
kind
+
"
callee
"
)
;
debugger
;
}
}
}
}
var
typeInfo
=
loadTypeInfo
(
typeInfo_filename
)
;
loadTypes
(
"
src_comp
.
xdb
"
)
;
for
(
const
[
fieldkey
methods
]
of
virtualDefinitions
)
{
const
caller
=
getId
(
fieldkey
)
;
for
(
const
name
of
methods
)
{
const
callee
=
functionId
(
name
)
;
printOnce
(
D
{
caller
}
{
callee
}
)
;
}
}
function
ancestorClassesAndSelf
(
C
)
{
const
ancestors
=
[
C
]
;
for
(
const
base
of
(
superclasses
.
get
(
C
)
|
|
[
]
)
)
ancestors
.
push
(
.
.
.
ancestorClassesAndSelf
(
base
)
)
;
return
ancestors
;
}
function
isOverridable
(
C
field
)
{
for
(
const
A
of
ancestorClassesAndSelf
(
C
)
)
{
if
(
isOverridableField
(
C
A
field
)
)
return
true
;
}
return
false
;
}
for
(
const
[
csu
methods
]
of
virtualDeclarations
)
{
for
(
const
{
field
}
of
methods
)
{
const
caller
=
getId
(
fieldKey
(
csu
field
)
)
;
if
(
isOverridable
(
csu
field
.
Name
[
0
]
)
)
printOnce
(
D
{
caller
}
{
functionId
(
"
(
unknown
-
definition
)
"
)
}
)
;
if
(
!
subclasses
.
has
(
csu
)
)
continue
;
for
(
const
sub
of
subclasses
.
get
(
csu
)
)
{
printOnce
(
D
{
caller
}
{
getId
(
fieldKey
(
sub
field
)
)
}
)
;
}
}
}
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_body
.
xdb
"
)
;
printErr
(
"
Finished
loading
data
structures
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
;
var
maxStream
=
xdb
.
max_data_stream
(
)
;
if
(
theFunctionNameToFind
)
{
var
index
=
xdb
.
lookup_key
(
theFunctionNameToFind
)
;
if
(
!
index
)
{
printErr
(
"
Function
not
found
"
)
;
quit
(
1
)
;
}
minStream
=
maxStream
=
index
;
}
function
process
(
functionName
functionBodies
)
{
for
(
var
body
of
functionBodies
)
body
.
limits
=
[
]
;
for
(
var
body
of
functionBodies
)
{
for
(
var
[
pbody
id
limits
]
of
allRAIIGuardedCallPoints
(
typeInfo
functionBodies
body
isLimitConstructor
)
)
{
pbody
.
limits
[
id
]
=
limits
;
}
}
for
(
var
body
of
functionBodies
)
processBody
(
functionName
body
)
;
var
markerPos
=
functionName
.
indexOf
(
internalMarker
)
;
if
(
markerPos
>
0
)
{
var
inChargeXTor
=
functionName
.
replace
(
internalMarker
"
"
)
;
printOnce
(
"
D
"
+
functionId
(
inChargeXTor
)
+
"
"
+
functionId
(
functionName
)
)
;
}
const
[
mangled
unmangled
]
=
splitFunction
(
functionName
)
;
if
(
functionName
.
indexOf
(
"
C4
"
)
!
=
-
1
)
{
for
(
let
[
synthetic
variant
desc
]
of
[
[
'
C4E
'
'
C1E
'
'
complete_ctor
'
]
[
'
C4E
'
'
C2E
'
'
base_ctor
'
]
[
'
C4E
'
'
C3E
'
'
complete_alloc_ctor
'
]
[
'
C4I
'
'
C1I
'
'
complete_ctor
'
]
[
'
C4I
'
'
C2I
'
'
base_ctor
'
]
[
'
C4I
'
'
C3I
'
'
complete_alloc_ctor
'
]
]
)
{
if
(
mangled
.
indexOf
(
synthetic
)
=
=
-
1
)
continue
;
let
variant_mangled
=
mangled
.
replace
(
synthetic
variant
)
;
let
variant_full
=
{
variant_mangled
}
{
unmangled
}
[
[
{
desc
}
]
]
;
printOnce
(
"
D
"
+
functionId
(
variant_full
)
+
"
"
+
functionId
(
functionName
)
)
;
}
}
if
(
functionName
.
indexOf
(
"
D4Ev
"
)
!
=
-
1
&
&
functionName
.
indexOf
(
"
:
:
~
"
)
!
=
-
1
)
{
const
not_in_charge_dtor
=
functionName
.
replace
(
"
(
int32
)
"
"
(
)
"
)
;
const
D0
=
not_in_charge_dtor
.
replace
(
"
D4Ev
"
"
D0Ev
"
)
+
"
[
[
deleting_dtor
]
]
"
;
const
D1
=
not_in_charge_dtor
.
replace
(
"
D4Ev
"
"
D1Ev
"
)
+
"
[
[
complete_dtor
]
]
"
;
const
D2
=
not_in_charge_dtor
.
replace
(
"
D4Ev
"
"
D2Ev
"
)
+
"
[
[
base_dtor
]
]
"
;
printOnce
(
"
D
"
+
functionId
(
D0
)
+
"
"
+
functionId
(
D1
)
)
;
printOnce
(
"
D
"
+
functionId
(
D1
)
+
"
"
+
functionId
(
D2
)
)
;
printOnce
(
"
D
"
+
functionId
(
D2
)
+
"
"
+
functionId
(
functionName
)
)
;
}
if
(
isJSNative
(
mangled
)
)
JSNatives
.
push
(
functionName
)
;
}
function
postprocess_callgraph
(
)
{
for
(
const
caller
of
Object
.
keys
(
JSNativeCaller
)
)
{
const
caller_id
=
functionId
(
caller
)
;
for
(
const
callee
of
JSNatives
)
printOnce
(
D
{
caller_id
}
{
functionId
(
callee
)
}
)
;
}
}
for
(
var
nameIndex
=
minStream
;
nameIndex
<
=
maxStream
;
nameIndex
+
+
)
{
var
name
=
xdb
.
read_key
(
nameIndex
)
;
var
data
=
xdb
.
read_entry
(
name
)
;
process
(
name
.
readString
(
)
JSON
.
parse
(
data
.
readString
(
)
)
)
;
xdb
.
free_string
(
name
)
;
xdb
.
free_string
(
data
)
;
}
postprocess_callgraph
(
)
;
os
.
file
.
close
(
os
.
file
.
redirect
(
origOut
)
)
;
