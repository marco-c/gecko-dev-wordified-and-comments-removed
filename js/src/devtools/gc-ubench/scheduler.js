var
Scheduler
=
class
{
constructor
(
perfMonitor
)
{
this
.
_perfMonitor
=
perfMonitor
;
}
start
(
loadMgr
timestamp
)
{
return
loadMgr
.
start
(
timestamp
)
;
}
tick
(
loadMgr
timestamp
)
{
}
wait_for_next_frame
(
t0
tick_start
tick_end
)
{
}
}
;
var
VsyncScheduler
=
class
extends
Scheduler
{
tick
(
loadMgr
timestamp
)
{
this
.
_perfMonitor
.
before_mutator
(
timestamp
)
;
gHost
.
start_turn
(
)
;
const
events
=
loadMgr
.
tick
(
timestamp
)
;
gHost
.
end_turn
(
)
;
this
.
_perfMonitor
.
after_mutator
(
timestamp
)
;
return
events
;
}
wait_for_next_frame
(
t0
tick_start
tick_end
)
{
const
elapsed
=
(
tick_end
-
t0
)
/
1000
;
const
period
=
1
/
FPS
;
const
used
=
elapsed
%
period
;
const
delay
=
period
-
used
;
gHost
.
suspend
(
delay
)
;
this
.
_perfMonitor
.
after_suspend
(
delay
)
;
}
}
;
var
OptimizeForFrameRate
=
class
extends
Scheduler
{
tick
(
loadMgr
timestamp
)
{
this
.
_perfMonitor
.
before_mutator
(
timestamp
)
;
gHost
.
start_turn
(
)
;
const
events
=
loadMgr
.
tick
(
timestamp
)
;
gHost
.
end_turn
(
)
;
this
.
_perfMonitor
.
after_mutator
(
timestamp
)
;
return
events
;
}
wait_for_next_frame
(
t0
tick_start
tick_end
)
{
const
next_frame_ms
=
round_up
(
tick_start
1000
/
FPS
)
;
if
(
tick_end
<
next_frame_ms
)
{
const
delay
=
(
next_frame_ms
-
tick_end
)
/
1000
;
gHost
.
suspend
(
delay
)
;
this
.
_perfMonitor
.
after_suspend
(
delay
)
;
}
}
}
;
