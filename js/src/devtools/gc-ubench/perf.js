function
round_up
(
val
interval
)
{
return
val
+
(
interval
-
(
val
%
interval
)
)
;
}
var
FrameTimer
=
class
{
constructor
(
)
{
this
.
start
=
undefined
;
this
.
prev
=
undefined
;
this
.
stopped
=
0
;
}
is_stopped
(
)
{
return
this
.
stopped
!
=
0
;
}
start_recording
(
now
=
gHost
.
now
(
)
)
{
this
.
start
=
this
.
prev
=
now
;
}
on_frame_finished
(
now
=
gHost
.
now
(
)
)
{
const
delay
=
now
-
this
.
prev
;
this
.
prev
=
now
;
return
delay
;
}
pause
(
now
=
gHost
.
now
(
)
)
{
this
.
stopped
=
now
;
this
.
prev
=
now
-
this
.
prev
;
}
resume
(
now
=
gHost
.
now
(
)
)
{
this
.
prev
=
now
-
this
.
prev
;
const
stop_duration
=
now
-
this
.
stopped
;
this
.
start
+
=
stop_duration
;
this
.
stopped
=
0
;
}
}
;
var
sampleTime
=
16
.
666667
;
var
sampleIndex
=
0
;
var
FrameHistory
=
class
{
constructor
(
numSamples
)
{
this
.
_frameTimer
=
new
FrameTimer
(
)
;
this
.
_numSamples
=
numSamples
;
this
.
delays
=
new
Array
(
numSamples
)
;
this
.
gcBytes
=
new
Array
(
numSamples
)
;
this
.
mallocBytes
=
new
Array
(
numSamples
)
;
this
.
gcs
=
new
Array
(
numSamples
)
;
this
.
minorGCs
=
new
Array
(
numSamples
)
;
this
.
majorGCs
=
new
Array
(
numSamples
)
;
this
.
slices
=
new
Array
(
numSamples
)
;
sampleIndex
=
0
;
this
.
reset
(
)
;
}
start
(
now
=
gHost
.
now
(
)
)
{
this
.
_frameTimer
.
start_recording
(
now
)
;
}
reset
(
)
{
this
.
delays
.
fill
(
0
)
;
this
.
gcBytes
.
fill
(
0
)
;
this
.
mallocBytes
.
fill
(
0
)
;
this
.
gcs
.
fill
(
this
.
gcs
[
sampleIndex
]
)
;
this
.
minorGCs
.
fill
(
this
.
minorGCs
[
sampleIndex
]
)
;
this
.
majorGCs
.
fill
(
this
.
majorGCs
[
sampleIndex
]
)
;
this
.
slices
.
fill
(
this
.
slices
[
sampleIndex
]
)
;
sampleIndex
=
0
;
}
get
numSamples
(
)
{
return
this
.
_numSamples
;
}
findMax
(
collection
)
{
var
maxIndex
=
0
;
for
(
let
i
=
0
;
i
<
this
.
_numSamples
;
i
+
+
)
{
if
(
collection
[
i
]
>
=
collection
[
maxIndex
]
)
{
maxIndex
=
i
;
}
}
return
maxIndex
;
}
findMaxDelay
(
)
{
return
this
.
findMax
(
this
.
delays
)
;
}
on_frame
(
now
=
gHost
.
now
(
)
)
{
const
delay
=
this
.
_frameTimer
.
on_frame_finished
(
now
)
;
var
t
=
now
-
this
.
_frameTimer
.
start
;
var
newIndex
=
Math
.
round
(
t
/
sampleTime
)
;
while
(
sampleIndex
<
newIndex
)
{
sampleIndex
+
+
;
var
idx
=
sampleIndex
%
this
.
_numSamples
;
this
.
delays
[
idx
]
=
delay
;
if
(
gHost
.
features
.
haveMemorySizes
)
{
this
.
gcBytes
[
idx
]
=
gHost
.
gcBytes
;
this
.
mallocBytes
[
idx
]
=
gHost
.
mallocBytes
;
}
if
(
gHost
.
features
.
haveGCCounts
)
{
this
.
minorGCs
[
idx
]
=
gHost
.
minorGCCount
;
this
.
majorGCs
[
idx
]
=
gHost
.
majorGCCount
;
this
.
slices
[
idx
]
=
gHost
.
GCSliceCount
;
}
}
return
delay
;
}
pause
(
)
{
this
.
_frameTimer
.
pause
(
)
;
}
resume
(
)
{
this
.
_frameTimer
.
resume
(
)
;
}
is_stopped
(
)
{
return
this
.
_frameTimer
.
is_stopped
(
)
;
}
}
;
var
PerfTracker
=
class
{
constructor
(
)
{
this
.
_currentLoadStart
=
undefined
;
this
.
_frameCount
=
undefined
;
this
.
_mutating_ms
=
undefined
;
this
.
_suspend_sec
=
undefined
;
this
.
_minorGCs
=
undefined
;
this
.
_majorGCs
=
undefined
;
this
.
results
=
[
]
;
}
on_load_start
(
load
now
=
gHost
.
now
(
)
)
{
this
.
_currentLoadStart
=
now
;
this
.
_frameCount
=
0
;
this
.
_mutating_ms
=
0
;
this
.
_suspend_sec
=
0
;
this
.
_majorGCs
=
gHost
.
majorGCCount
;
this
.
_minorGCs
=
gHost
.
minorGCCount
;
}
on_load_end
(
load
now
=
gHost
.
now
(
)
)
{
const
elapsed_time
=
(
now
-
this
.
_currentLoadStart
)
/
1000
;
const
full_time
=
round_up
(
elapsed_time
1
/
60
)
;
const
frame_60fps_limit
=
Math
.
round
(
full_time
*
60
)
;
const
dropped_60fps_frames
=
frame_60fps_limit
-
this
.
_frameCount
;
const
dropped_60fps_fraction
=
dropped_60fps_frames
/
frame_60fps_limit
;
const
mutating_and_gc_fraction
=
this
.
_mutating_ms
/
(
full_time
*
1000
)
;
this
.
results
.
push
(
{
load
elapsed_time
mutating
:
this
.
_mutating_ms
/
1000
mutating_and_gc_fraction
suspended
:
this
.
_suspend_sec
full_time
frames
:
this
.
_frameCount
dropped_60fps_frames
dropped_60fps_fraction
majorGCs
:
gHost
.
majorGCCount
-
this
.
_majorGCs
minorGCs
:
gHost
.
minorGCCount
-
this
.
_minorGCs
}
)
;
this
.
_currentLoadStart
=
undefined
;
this
.
_frameCount
=
0
;
}
after_suspend
(
wait_sec
)
{
this
.
_suspend_sec
+
=
wait_sec
;
}
before_mutator
(
now
=
gHost
.
now
(
)
)
{
this
.
_frameCount
+
+
;
}
after_mutator
(
start_time
end_time
=
gHost
.
now
(
)
)
{
}
handle_tick_events
(
events
loadMgr
tick_start
tick_end
)
{
let
load_running
=
true
;
if
(
events
&
loadMgr
.
LOAD_ENDED
)
{
this
.
on_load_end
(
loadMgr
.
lastActive
tick_start
)
;
load_running
=
false
;
}
if
(
events
&
loadMgr
.
LOAD_STARTED
)
{
this
.
on_load_start
(
loadMgr
.
active
tick_start
)
;
load_running
=
true
;
}
if
(
load_running
)
{
this
.
_mutating_ms
+
=
tick_end
-
tick_start
;
}
}
}
;
