var
features
=
{
trackingSizes
:
"
mozMemory
"
in
performance
showingGCs
:
"
mozMemory
"
in
performance
}
;
class
FrameTimer
{
constructor
(
)
{
this
.
start
=
undefined
;
this
.
prev
=
undefined
;
this
.
stopped
=
0
;
}
is_stopped
(
)
{
return
this
.
stopped
!
=
0
;
}
start_recording
(
now
=
performance
.
now
(
)
)
{
this
.
start
=
this
.
prev
=
now
;
}
on_frame_finished
(
now
=
performance
.
now
(
)
)
{
const
delay
=
now
-
this
.
prev
;
this
.
prev
=
now
;
return
delay
;
}
pause
(
now
=
performance
.
now
(
)
)
{
this
.
stopped
=
now
;
this
.
prev
=
now
-
this
.
prev
;
}
resume
(
now
=
performance
.
now
(
)
)
{
this
.
prev
=
now
-
this
.
prev
;
const
stop_duration
=
now
-
this
.
stopped
;
this
.
start
+
=
stop_duration
;
this
.
stopped
=
0
;
}
}
var
sampleTime
=
16
.
666667
;
var
sampleIndex
=
0
;
class
FrameHistory
{
constructor
(
numSamples
)
{
this
.
_frameTimer
=
new
FrameTimer
(
)
;
this
.
_numSamples
=
numSamples
;
this
.
delays
=
new
Array
(
numSamples
)
;
this
.
gcBytes
=
new
Array
(
numSamples
)
;
this
.
mallocBytes
=
new
Array
(
numSamples
)
;
this
.
gcs
=
new
Array
(
numSamples
)
;
this
.
minorGCs
=
new
Array
(
numSamples
)
;
this
.
majorGCs
=
new
Array
(
numSamples
)
;
this
.
slices
=
new
Array
(
numSamples
)
;
sampleIndex
=
0
;
this
.
reset
(
)
;
}
start
(
now
=
performance
.
now
(
)
)
{
this
.
_frameTimer
.
start_recording
(
now
)
;
}
reset
(
)
{
this
.
delays
.
fill
(
0
)
;
this
.
gcBytes
.
fill
(
0
)
;
this
.
mallocBytes
.
fill
(
0
)
;
this
.
gcs
.
fill
(
this
.
gcs
[
sampleIndex
]
)
;
this
.
minorGCs
.
fill
(
this
.
minorGCs
[
sampleIndex
]
)
;
this
.
majorGCs
.
fill
(
this
.
majorGCs
[
sampleIndex
]
)
;
this
.
slices
.
fill
(
this
.
slices
[
sampleIndex
]
)
;
sampleIndex
=
0
;
}
get
numSamples
(
)
{
return
this
.
_numSamples
;
}
findMax
(
collection
)
{
var
maxIndex
=
0
;
for
(
let
i
=
0
;
i
<
this
.
_numSamples
;
i
+
+
)
{
if
(
collection
[
i
]
>
=
collection
[
maxIndex
]
)
{
maxIndex
=
i
;
}
}
return
maxIndex
;
}
findMaxDelay
(
)
{
return
this
.
findMax
(
this
.
delays
)
;
}
on_frame
(
now
=
performance
.
now
(
)
)
{
const
delay
=
this
.
_frameTimer
.
on_frame_finished
(
now
)
;
var
t
=
now
-
this
.
_frameTimer
.
start
;
var
newIndex
=
Math
.
round
(
t
/
sampleTime
)
;
while
(
sampleIndex
<
newIndex
)
{
sampleIndex
+
+
;
var
idx
=
sampleIndex
%
this
.
_numSamples
;
this
.
delays
[
idx
]
=
delay
;
if
(
features
.
trackingSizes
)
{
this
.
gcBytes
[
idx
]
=
performance
.
mozMemory
.
gc
.
gcBytes
;
this
.
mallocBytes
[
idx
]
=
performance
.
mozMemory
.
gc
.
zone
.
mallocBytes
;
}
if
(
features
.
showingGCs
)
{
this
.
gcs
[
idx
]
=
performance
.
mozMemory
.
gc
.
gcNumber
;
this
.
minorGCs
[
idx
]
=
performance
.
mozMemory
.
gc
.
minorGCCount
;
this
.
majorGCs
[
idx
]
=
performance
.
mozMemory
.
gc
.
majorGCCount
;
this
.
slices
[
idx
]
=
performance
.
mozMemory
.
gc
.
sliceCount
|
|
performance
.
mozMemory
.
gc
.
gcNumber
;
}
}
return
delay
;
}
pause
(
)
{
this
.
_frameTimer
.
pause
(
)
;
}
resume
(
)
{
this
.
_frameTimer
.
resume
(
)
;
}
is_stopped
(
)
{
return
this
.
_frameTimer
.
is_stopped
(
)
;
}
}
