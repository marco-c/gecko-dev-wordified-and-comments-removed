#
ifndef
jsutil_h
#
define
jsutil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
limits
.
h
>
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Poison
.
h
"
#
if
defined
(
DEBUG
)
|
|
defined
(
NIGHTLY_BUILD
)
#
define
JS_CRASH_DIAGNOSTICS
1
#
endif
#
if
defined
(
JS_DEBUG
)
#
define
JS_DIAGNOSTICS_ASSERT
(
expr
)
MOZ_ASSERT
(
expr
)
#
elif
defined
(
JS_CRASH_DIAGNOSTICS
)
#
define
JS_DIAGNOSTICS_ASSERT
(
expr
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
!
(
expr
)
)
)
MOZ_CRASH
(
)
;
\
}
while
(
0
)
#
else
#
define
JS_DIAGNOSTICS_ASSERT
(
expr
)
(
(
void
)
0
)
#
endif
static
MOZ_ALWAYS_INLINE
void
*
js_memcpy
(
void
*
dst_
const
void
*
src_
size_t
len
)
{
char
*
dst
=
(
char
*
)
dst_
;
const
char
*
src
=
(
const
char
*
)
src_
;
MOZ_ASSERT_IF
(
dst
>
=
src
(
size_t
)
(
dst
-
src
)
>
=
len
)
;
MOZ_ASSERT_IF
(
src
>
=
dst
(
size_t
)
(
src
-
dst
)
>
=
len
)
;
return
memcpy
(
dst
src
len
)
;
}
namespace
js
{
inline
bool
IsInitialized
(
)
{
using
namespace
JS
:
:
detail
;
return
libraryInitState
=
=
InitState
:
:
Initializing
|
|
libraryInitState
=
=
InitState
:
:
Running
;
}
template
<
class
T
>
static
constexpr
inline
T
Min
(
T
t1
T
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
class
T
>
static
constexpr
inline
T
Max
(
T
t1
T
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
template
<
typename
T
typename
U
>
static
constexpr
U
ComputeByteAlignment
(
T
bytes
U
alignment
)
{
static_assert
(
mozilla
:
:
IsUnsigned
<
U
>
:
:
value
"
alignment
amount
must
be
unsigned
"
)
;
return
(
alignment
-
(
bytes
%
alignment
)
)
%
alignment
;
}
template
<
typename
T
typename
U
>
static
constexpr
T
AlignBytes
(
T
bytes
U
alignment
)
{
static_assert
(
mozilla
:
:
IsUnsigned
<
U
>
:
:
value
"
alignment
amount
must
be
unsigned
"
)
;
return
bytes
+
ComputeByteAlignment
(
bytes
alignment
)
;
}
static
const
size_t
BitArrayElementBits
=
sizeof
(
size_t
)
*
CHAR_BIT
;
static
inline
unsigned
NumWordsForBitArrayOfLength
(
size_t
length
)
{
return
(
length
+
(
BitArrayElementBits
-
1
)
)
/
BitArrayElementBits
;
}
static
inline
unsigned
BitArrayIndexToWordIndex
(
size_t
length
size_t
bitIndex
)
{
unsigned
wordIndex
=
bitIndex
/
BitArrayElementBits
;
MOZ_ASSERT
(
wordIndex
<
length
)
;
return
wordIndex
;
}
static
inline
size_t
BitArrayIndexToWordMask
(
size_t
i
)
{
return
size_t
(
1
)
<
<
(
i
%
BitArrayElementBits
)
;
}
static
inline
bool
IsBitArrayElementSet
(
const
size_t
*
array
size_t
length
size_t
i
)
{
return
array
[
BitArrayIndexToWordIndex
(
length
i
)
]
&
BitArrayIndexToWordMask
(
i
)
;
}
static
inline
bool
IsAnyBitArrayElementSet
(
const
size_t
*
array
size_t
length
)
{
unsigned
numWords
=
NumWordsForBitArrayOfLength
(
length
)
;
for
(
unsigned
i
=
0
;
i
<
numWords
;
+
+
i
)
{
if
(
array
[
i
]
)
{
return
true
;
}
}
return
false
;
}
static
inline
void
SetBitArrayElement
(
size_t
*
array
size_t
length
size_t
i
)
{
array
[
BitArrayIndexToWordIndex
(
length
i
)
]
|
=
BitArrayIndexToWordMask
(
i
)
;
}
static
inline
void
ClearBitArrayElement
(
size_t
*
array
size_t
length
size_t
i
)
{
array
[
BitArrayIndexToWordIndex
(
length
i
)
]
&
=
~
BitArrayIndexToWordMask
(
i
)
;
}
static
inline
void
ClearAllBitArrayElements
(
size_t
*
array
size_t
length
)
{
for
(
unsigned
i
=
0
;
i
<
length
;
+
+
i
)
{
array
[
i
]
=
0
;
}
}
template
<
typename
T
>
static
void
DefaultInitializeElements
(
void
*
arrayPtr
size_t
length
)
{
uintptr_t
elem
=
reinterpret_cast
<
uintptr_t
>
(
arrayPtr
)
;
MOZ_ASSERT
(
elem
%
alignof
(
T
)
=
=
0
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
new
(
reinterpret_cast
<
void
*
>
(
elem
)
)
T
;
elem
+
=
sizeof
(
T
)
;
}
}
}
#
endif
