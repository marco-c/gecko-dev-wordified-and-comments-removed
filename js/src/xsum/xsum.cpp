#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
math
.
h
>
#
include
"
xsum
.
h
"
#
define
USE_SIMD
1
/
*
Use
SIMD
intrinsics
(
SSE2
/
AVX
)
if
available
?
*
/
#
define
USE_MEMSET_SMALL
\
1
/
*
Use
memset
rather
than
a
loop
(
for
small
mem
)
?
\
*
/
#
define
USE_MEMSET_LARGE
\
1
/
*
Use
memset
rather
than
a
loop
(
for
large
mem
)
?
\
*
/
#
define
USE_USED_LARGE
1
/
*
Use
the
used
flags
in
a
large
accumulator
?
*
/
#
define
OPT_SMALL
0
/
*
Class
of
manual
optimization
for
operations
on
*
/
#
define
OPT_CARRY
1
/
*
Use
manually
optimized
carry
propagation
?
*
/
#
define
OPT_LARGE_SUM
1
/
*
Should
manually
optimized
routines
be
used
for
*
/
#
define
OPT_LARGE_SQNORM
1
/
*
operations
using
the
large
accumulator
?
*
/
#
define
OPT_LARGE_DOT
1
#
define
OPT_SIMPLE_SUM
1
/
*
Should
manually
optimized
routines
be
used
for
*
/
#
define
OPT_SIMPLE_SQNORM
1
/
*
operations
done
with
simple
FP
arithmetic
?
*
/
#
define
OPT_SIMPLE_DOT
1
#
define
OPT_KAHAN_SUM
0
/
*
Use
manually
optimized
routine
for
Kahan
sum
?
*
/
#
define
INLINE_SMALL
1
/
*
Inline
more
of
the
small
accumulator
routines
?
*
/
#
define
INLINE_LARGE
1
/
*
Inline
more
of
the
large
accumulator
routines
?
*
/
#
if
USE_SIMD
&
&
__SSE2__
#
include
<
immintrin
.
h
>
#
endif
#
define
COPY64
(
dst
src
)
memcpy
(
&
(
dst
)
&
(
src
)
sizeof
(
double
)
)
#
ifdef
PBINARY
#
include
"
pbinary
.
h
"
#
else
#
define
pbinary_int64
(
x
y
)
0
#
define
pbinary_double
(
x
)
0
#
endif
int
xsum_debug
=
0
;
#
ifndef
DEBUG
#
define
xsum_debug
0
#
endif
#
if
__GNUC__
#
define
INLINE
inline
__attribute__
(
(
always_inline
)
)
#
define
NOINLINE
__attribute__
(
(
noinline
)
)
#
else
#
define
INLINE
inline
#
define
NOINLINE
#
endif
static
NOINLINE
void
xsum_small_add_inf_nan
(
xsum_small_accumulator
*
sacc
xsum_int
ivalue
)
{
xsum_int
mantissa
;
double
fltv
;
mantissa
=
ivalue
&
XSUM_MANTISSA_MASK
;
if
(
mantissa
=
=
0
)
{
if
(
sacc
-
>
Inf
=
=
0
)
{
sacc
-
>
Inf
=
ivalue
;
}
else
if
(
sacc
-
>
Inf
!
=
ivalue
)
{
COPY64
(
fltv
ivalue
)
;
fltv
=
fltv
-
fltv
;
COPY64
(
sacc
-
>
Inf
fltv
)
;
}
}
else
{
if
(
(
sacc
-
>
NaN
&
XSUM_MANTISSA_MASK
)
<
=
mantissa
)
{
sacc
-
>
NaN
=
ivalue
&
~
XSUM_SIGN_MASK
;
}
}
}
static
NOINLINE
int
xsum_carry_propagate
(
xsum_small_accumulator
*
sacc
)
{
int
i
u
uix
;
if
(
xsum_debug
)
printf
(
"
\
nCARRY
PROPAGATING
IN
SMALL
ACCUMULATOR
\
n
"
)
;
#
if
OPT_CARRY
{
u
=
XSUM_SCHUNKS
-
1
;
switch
(
XSUM_SCHUNKS
&
0x3
)
{
case
3
:
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
case
2
:
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
case
1
:
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
case
0
:
;
}
do
{
#
if
USE_SIMD
&
&
__AVX__
{
__m256i
ch
;
ch
=
_mm256_loadu_si256
(
(
__m256i
*
)
(
sacc
-
>
chunk
+
u
-
3
)
)
;
if
(
!
_mm256_testz_si256
(
ch
ch
)
)
{
goto
found
;
}
u
-
=
4
;
if
(
u
<
0
)
{
break
;
}
ch
=
_mm256_loadu_si256
(
(
__m256i
*
)
(
sacc
-
>
chunk
+
u
-
3
)
)
;
if
(
!
_mm256_testz_si256
(
ch
ch
)
)
{
goto
found
;
}
u
-
=
4
;
}
#
else
{
if
(
sacc
-
>
chunk
[
u
]
|
sacc
-
>
chunk
[
u
-
1
]
|
sacc
-
>
chunk
[
u
-
2
]
|
sacc
-
>
chunk
[
u
-
3
]
)
{
goto
found
;
}
u
-
=
4
;
}
#
endif
}
while
(
u
>
=
0
)
;
if
(
xsum_debug
)
printf
(
"
number
is
zero
(
1
)
\
n
"
)
;
uix
=
0
;
goto
done
;
found
:
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
if
(
sacc
-
>
chunk
[
u
]
!
=
0
)
{
goto
found2
;
}
u
-
=
1
;
found2
:
;
}
#
else
{
for
(
u
=
XSUM_SCHUNKS
-
1
;
sacc
-
>
chunk
[
u
]
=
=
0
;
u
-
-
)
{
if
(
u
=
=
0
)
{
if
(
xsum_debug
)
printf
(
"
number
is
zero
(
1
)
\
n
"
)
;
uix
=
0
;
goto
done
;
}
}
}
#
endif
if
(
xsum_debug
)
printf
(
"
u
:
%
d
sacc
-
>
chunk
[
u
]
:
%
ld
"
u
sacc
-
>
chunk
[
u
]
)
;
i
=
0
;
#
if
OPT_CARRY
{
int
e
=
u
-
3
;
do
{
#
if
USE_SIMD
&
&
__AVX__
{
__m256i
ch
;
ch
=
_mm256_loadu_si256
(
(
__m256i
*
)
(
sacc
-
>
chunk
+
i
)
)
;
if
(
!
_mm256_testz_si256
(
ch
ch
)
)
{
break
;
}
i
+
=
4
;
if
(
i
>
=
e
)
{
break
;
}
ch
=
_mm256_loadu_si256
(
(
__m256i
*
)
(
sacc
-
>
chunk
+
i
)
)
;
if
(
!
_mm256_testz_si256
(
ch
ch
)
)
{
break
;
}
}
#
else
{
if
(
sacc
-
>
chunk
[
i
]
|
sacc
-
>
chunk
[
i
+
1
]
|
sacc
-
>
chunk
[
i
+
2
]
|
sacc
-
>
chunk
[
i
+
3
]
)
{
break
;
}
}
#
endif
i
+
=
4
;
}
while
(
i
<
=
e
)
;
}
#
endif
uix
=
-
1
;
do
{
xsum_schunk
c
;
xsum_schunk
clow
;
xsum_schunk
chigh
;
#
if
OPT_CARRY
{
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
if
(
i
>
u
)
{
break
;
}
for
(
;
;
)
{
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
}
}
#
else
{
do
{
c
=
sacc
-
>
chunk
[
i
]
;
if
(
c
!
=
0
)
{
goto
nonzero
;
}
i
+
=
1
;
}
while
(
i
<
=
u
)
;
break
;
}
#
endif
nonzero
:
chigh
=
c
>
>
XSUM_LOW_MANTISSA_BITS
;
if
(
chigh
=
=
0
)
{
uix
=
i
;
i
+
=
1
;
continue
;
}
if
(
u
=
=
i
)
{
if
(
chigh
=
=
-
1
)
{
uix
=
i
;
break
;
}
u
=
i
+
1
;
}
clow
=
c
&
XSUM_LOW_MANTISSA_MASK
;
if
(
clow
!
=
0
)
{
uix
=
i
;
}
sacc
-
>
chunk
[
i
]
=
clow
;
if
(
i
+
1
>
=
XSUM_SCHUNKS
)
{
xsum_small_add_inf_nan
(
sacc
(
(
xsum_int
)
XSUM_EXP_MASK
<
<
XSUM_MANTISSA_BITS
)
|
XSUM_MANTISSA_MASK
)
;
u
=
i
;
}
else
{
sacc
-
>
chunk
[
i
+
1
]
+
=
chigh
;
}
i
+
=
1
;
}
while
(
i
<
=
u
)
;
if
(
xsum_debug
)
printf
(
"
uix
:
%
d
new
u
:
%
d
\
n
"
uix
u
)
;
if
(
uix
<
0
)
{
if
(
xsum_debug
)
printf
(
"
number
is
zero
(
2
)
\
n
"
)
;
uix
=
0
;
goto
done
;
}
while
(
sacc
-
>
chunk
[
uix
]
=
=
-
1
&
&
uix
>
0
)
{
sacc
-
>
chunk
[
uix
-
1
]
+
=
(
(
xsum_schunk
)
-
1
)
*
(
(
(
xsum_schunk
)
1
)
<
<
XSUM_LOW_MANTISSA_BITS
)
;
sacc
-
>
chunk
[
uix
]
=
0
;
uix
-
=
1
;
}
done
:
sacc
-
>
adds_until_propagate
=
XSUM_SMALL_CARRY_TERMS
-
1
;
return
uix
;
}
void
xsum_small_init
(
xsum_small_accumulator
*
sacc
)
{
sacc
-
>
adds_until_propagate
=
XSUM_SMALL_CARRY_TERMS
;
sacc
-
>
Inf
=
sacc
-
>
NaN
=
0
;
#
if
USE_MEMSET_SMALL
{
memset
(
sacc
-
>
chunk
0
XSUM_SCHUNKS
*
sizeof
(
xsum_schunk
)
)
;
}
#
elif
USE_SIMD
&
&
__AVX__
&
&
XSUM_SCHUNKS
=
=
67
{
xsum_schunk
*
ch
=
sacc
-
>
chunk
;
__m256i
z
=
_mm256_setzero_si256
(
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
0
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
4
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
8
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
12
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
16
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
20
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
24
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
28
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
32
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
36
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
40
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
44
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
48
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
52
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
56
)
z
)
;
_mm256_storeu_si256
(
(
__m256i
*
)
(
ch
+
60
)
z
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
ch
+
64
)
_mm256_castsi256_si128
(
z
)
)
;
_mm_storeu_si64
(
ch
+
66
_mm256_castsi256_si128
(
z
)
)
;
}
#
else
{
xsum_schunk
*
p
;
int
n
;
p
=
sacc
-
>
chunk
;
n
=
XSUM_SCHUNKS
;
do
{
*
p
+
+
=
0
;
n
-
=
1
;
}
while
(
n
>
0
)
;
}
#
endif
}
static
INLINE
void
xsum_add1_no_carry
(
xsum_small_accumulator
*
sacc
xsum_flt
value
)
{
xsum_int
ivalue
;
xsum_int
mantissa
;
xsum_expint
exp
low_exp
high_exp
;
xsum_schunk
*
chunk_ptr
;
if
(
xsum_debug
)
{
printf
(
"
ADD1
%
+
.
17le
\
n
"
(
double
)
value
)
;
pbinary_double
(
(
double
)
value
)
;
printf
(
"
\
n
"
)
;
}
COPY64
(
ivalue
value
)
;
exp
=
(
ivalue
>
>
XSUM_MANTISSA_BITS
)
&
XSUM_EXP_MASK
;
mantissa
=
ivalue
&
XSUM_MANTISSA_MASK
;
high_exp
=
exp
>
>
XSUM_LOW_EXP_BITS
;
low_exp
=
exp
&
XSUM_LOW_EXP_MASK
;
if
(
xsum_debug
)
{
printf
(
"
high
exp
:
"
)
;
pbinary_int64
(
high_exp
XSUM_HIGH_EXP_BITS
)
;
printf
(
"
low
exp
:
"
)
;
pbinary_int64
(
low_exp
XSUM_LOW_EXP_BITS
)
;
printf
(
"
\
n
"
)
;
}
if
(
exp
=
=
0
)
{
if
(
mantissa
=
=
0
)
{
return
;
}
exp
=
low_exp
=
1
;
}
else
if
(
exp
=
=
XSUM_EXP_MASK
)
{
xsum_small_add_inf_nan
(
sacc
ivalue
)
;
return
;
}
else
{
mantissa
|
=
(
xsum_int
)
1
<
<
XSUM_MANTISSA_BITS
;
}
if
(
xsum_debug
)
{
printf
(
"
mantissa
:
"
)
;
pbinary_int64
(
mantissa
XSUM_MANTISSA_BITS
+
1
)
;
printf
(
"
\
n
"
)
;
}
chunk_ptr
=
sacc
-
>
chunk
+
high_exp
;
xsum_int
split_mantissa
[
2
]
;
split_mantissa
[
0
]
=
(
(
xsum_uint
)
mantissa
<
<
low_exp
)
&
XSUM_LOW_MANTISSA_MASK
;
split_mantissa
[
1
]
=
mantissa
>
>
(
XSUM_LOW_MANTISSA_BITS
-
low_exp
)
;
#
if
OPT_SMALL
=
=
1
{
xsum_int
ivalue_sign
=
ivalue
<
0
?
-
1
:
1
;
chunk_ptr
[
0
]
+
=
ivalue_sign
*
split_mantissa
[
0
]
;
chunk_ptr
[
1
]
+
=
ivalue_sign
*
split_mantissa
[
1
]
;
}
#
elif
OPT_SMALL
=
=
2
{
xsum_int
ivalue_neg
=
ivalue
>
>
(
XSUM_SCHUNK_BITS
-
1
)
;
chunk_ptr
[
0
]
+
=
(
split_mantissa
[
0
]
^
ivalue_neg
)
+
(
ivalue_neg
&
1
)
;
chunk_ptr
[
1
]
+
=
(
split_mantissa
[
1
]
^
ivalue_neg
)
+
(
ivalue_neg
&
1
)
;
}
#
elif
OPT_SMALL
=
=
3
&
&
USE_SIMD
&
&
__SSE2__
{
xsum_int
ivalue_neg
=
ivalue
>
>
(
XSUM_SCHUNK_BITS
-
1
)
;
_mm_storeu_si128
(
(
__m128i
*
)
chunk_ptr
_mm_add_epi64
(
_mm_loadu_si128
(
(
__m128i
*
)
chunk_ptr
)
_mm_add_epi64
(
_mm_set1_epi64
(
(
__m64
)
(
ivalue_neg
&
1
)
)
_mm_xor_si128
(
_mm_set1_epi64
(
(
__m64
)
ivalue_neg
)
_mm_loadu_si128
(
(
__m128i
*
)
split_mantissa
)
)
)
)
)
;
}
#
else
{
if
(
ivalue
<
0
)
{
chunk_ptr
[
0
]
-
=
split_mantissa
[
0
]
;
chunk_ptr
[
1
]
-
=
split_mantissa
[
1
]
;
}
else
{
chunk_ptr
[
0
]
+
=
split_mantissa
[
0
]
;
chunk_ptr
[
1
]
+
=
split_mantissa
[
1
]
;
}
}
#
endif
if
(
xsum_debug
)
{
if
(
ivalue
<
0
)
{
printf
(
"
-
high
man
:
"
)
;
pbinary_int64
(
-
split_mantissa
[
1
]
XSUM_MANTISSA_BITS
)
;
printf
(
"
\
n
-
low
man
:
"
)
;
pbinary_int64
(
-
split_mantissa
[
0
]
XSUM_LOW_MANTISSA_BITS
)
;
printf
(
"
\
n
"
)
;
}
else
{
printf
(
"
high
man
:
"
)
;
pbinary_int64
(
split_mantissa
[
1
]
XSUM_MANTISSA_BITS
)
;
printf
(
"
\
n
low
man
:
"
)
;
pbinary_int64
(
split_mantissa
[
0
]
XSUM_LOW_MANTISSA_BITS
)
;
printf
(
"
\
n
"
)
;
}
}
}
void
xsum_small_add1
(
xsum_small_accumulator
*
sacc
xsum_flt
value
)
{
if
(
sacc
-
>
adds_until_propagate
=
=
0
)
{
(
void
)
xsum_carry_propagate
(
sacc
)
;
}
xsum_add1_no_carry
(
sacc
value
)
;
sacc
-
>
adds_until_propagate
-
=
1
;
}
xsum_flt
xsum_small_round
(
xsum_small_accumulator
*
sacc
)
{
xsum_int
ivalue
;
xsum_schunk
lower
;
int
i
j
e
more
;
xsum_int
intv
;
double
fltv
;
if
(
xsum_debug
)
printf
(
"
\
nROUNDING
SMALL
ACCUMULATOR
\
n
"
)
;
if
(
sacc
-
>
NaN
!
=
0
)
{
COPY64
(
fltv
sacc
-
>
NaN
)
;
return
fltv
;
}
if
(
sacc
-
>
Inf
!
=
0
)
{
COPY64
(
fltv
sacc
-
>
Inf
)
;
return
fltv
;
}
i
=
xsum_carry_propagate
(
sacc
)
;
if
(
xsum_debug
)
xsum_small_display
(
sacc
)
;
ivalue
=
sacc
-
>
chunk
[
i
]
;
if
(
i
<
=
1
)
{
if
(
ivalue
=
=
0
)
{
return
0
.
0
;
}
if
(
i
=
=
0
)
{
intv
=
ivalue
>
=
0
?
ivalue
:
-
ivalue
;
intv
>
>
=
1
;
if
(
ivalue
<
0
)
{
intv
|
=
XSUM_SIGN_MASK
;
}
if
(
xsum_debug
)
{
printf
(
"
denormalized
with
i
=
=
0
:
intv
%
016llx
\
n
"
(
long
long
)
intv
)
;
}
COPY64
(
fltv
intv
)
;
return
fltv
;
}
else
{
intv
=
ivalue
*
(
(
xsum_int
)
1
<
<
(
XSUM_LOW_MANTISSA_BITS
-
1
)
)
+
(
sacc
-
>
chunk
[
0
]
>
>
1
)
;
if
(
intv
<
0
)
{
if
(
intv
>
-
(
(
xsum_int
)
1
<
<
XSUM_MANTISSA_BITS
)
)
{
intv
=
(
-
intv
)
|
XSUM_SIGN_MASK
;
if
(
xsum_debug
)
{
printf
(
"
denormalized
with
i
=
=
1
:
intv
%
016llx
\
n
"
(
long
long
)
intv
)
;
}
COPY64
(
fltv
intv
)
;
return
fltv
;
}
}
else
{
if
(
(
xsum_uint
)
intv
<
(
xsum_uint
)
1
<
<
XSUM_MANTISSA_BITS
)
{
if
(
xsum_debug
)
{
printf
(
"
denormalized
with
i
=
=
1
:
intv
%
016llx
\
n
"
(
long
long
)
intv
)
;
}
COPY64
(
fltv
intv
)
;
return
fltv
;
}
}
}
}
fltv
=
(
xsum_flt
)
ivalue
;
COPY64
(
intv
fltv
)
;
e
=
(
intv
>
>
XSUM_MANTISSA_BITS
)
&
XSUM_EXP_MASK
;
more
=
2
+
XSUM_MANTISSA_BITS
+
XSUM_EXP_BIAS
-
e
;
if
(
xsum_debug
)
{
printf
(
"
e
:
%
d
more
:
%
d
ivalue
:
%
016llx
\
n
"
e
more
(
long
long
)
ivalue
)
;
}
ivalue
*
=
(
xsum_int
)
1
<
<
more
;
if
(
xsum_debug
)
{
printf
(
"
after
ivalue
<
<
=
more
ivalue
:
%
016llx
\
n
"
(
long
long
)
ivalue
)
;
}
j
=
i
-
1
;
lower
=
sacc
-
>
chunk
[
j
]
;
if
(
more
>
=
XSUM_LOW_MANTISSA_BITS
)
{
more
-
=
XSUM_LOW_MANTISSA_BITS
;
ivalue
+
=
lower
<
<
more
;
if
(
xsum_debug
)
{
printf
(
"
after
ivalue
+
=
lower
<
<
more
ivalue
:
%
016llx
\
n
"
(
long
long
)
ivalue
)
;
}
j
-
=
1
;
lower
=
j
<
0
?
0
:
sacc
-
>
chunk
[
j
]
;
}
ivalue
+
=
lower
>
>
(
XSUM_LOW_MANTISSA_BITS
-
more
)
;
lower
&
=
(
(
xsum_schunk
)
1
<
<
(
XSUM_LOW_MANTISSA_BITS
-
more
)
)
-
1
;
if
(
xsum_debug
)
{
printf
(
"
after
final
add
to
ivalue
ivalue
:
%
016llx
\
n
"
(
long
long
)
ivalue
)
;
printf
(
"
j
:
%
d
e
:
%
d
|
ivalue
|
:
%
016llx
lower
:
%
016llx
(
a
)
\
n
"
j
e
(
long
long
)
(
ivalue
<
0
?
-
ivalue
:
ivalue
)
(
long
long
)
lower
)
;
printf
(
"
mask
of
low
55
bits
:
007fffffffffffff
mask
:
%
016llx
\
n
"
(
long
long
)
(
(
xsum_schunk
)
1
<
<
(
XSUM_LOW_MANTISSA_BITS
-
more
)
)
-
1
)
;
}
if
(
ivalue
>
=
0
)
{
intv
=
0
;
if
(
(
ivalue
&
2
)
=
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
+
no
adjustment
since
remainder
adds
<
1
/
2
\
n
"
)
;
}
goto
done_rounding
;
}
if
(
(
ivalue
&
1
)
!
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
+
round
away
from
0
since
remainder
adds
>
1
/
2
\
n
"
)
;
}
goto
round_away_from_zero
;
}
if
(
(
ivalue
&
4
)
!
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
+
odd
round
away
from
0
since
remainder
adds
>
=
1
/
2
\
n
"
)
;
}
goto
round_away_from_zero
;
}
if
(
lower
=
=
0
)
{
while
(
j
>
0
)
{
j
-
=
1
;
if
(
sacc
-
>
chunk
[
j
]
!
=
0
)
{
lower
=
1
;
break
;
}
}
}
if
(
lower
!
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
+
even
round
away
from
0
since
remainder
adds
>
1
/
2
\
n
"
)
;
}
goto
round_away_from_zero
;
}
else
{
if
(
xsum_debug
)
{
printf
(
"
+
even
no
adjustment
since
reaminder
adds
exactly
1
/
2
\
n
"
)
;
}
goto
done_rounding
;
}
}
else
{
if
(
(
(
-
ivalue
)
&
(
(
xsum_int
)
1
<
<
(
XSUM_MANTISSA_BITS
+
2
)
)
)
=
=
0
)
{
int
pos
=
(
xsum_schunk
)
1
<
<
(
XSUM_LOW_MANTISSA_BITS
-
1
-
more
)
;
ivalue
*
=
2
;
if
(
lower
&
pos
)
{
ivalue
+
=
1
;
lower
&
=
~
pos
;
}
e
-
=
1
;
if
(
xsum_debug
)
{
printf
(
"
j
:
%
d
e
:
%
d
|
ivalue
|
:
%
016llx
lower
:
%
016llx
(
b
)
\
n
"
j
e
(
long
long
)
(
ivalue
<
0
?
-
ivalue
:
ivalue
)
(
long
long
)
lower
)
;
}
}
intv
=
XSUM_SIGN_MASK
;
ivalue
=
-
ivalue
;
if
(
(
ivalue
&
3
)
=
=
3
)
{
if
(
xsum_debug
)
{
printf
(
"
-
round
away
from
0
since
remainder
adds
>
1
/
2
\
n
"
)
;
}
goto
round_away_from_zero
;
}
if
(
(
ivalue
&
3
)
<
=
1
)
{
if
(
xsum_debug
)
{
printf
(
"
-
no
adjustment
since
remainder
adds
<
=
1
/
4
or
subtracts
<
1
/
4
\
n
"
)
;
}
goto
done_rounding
;
}
if
(
(
ivalue
&
4
)
=
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
-
even
no
adjustment
since
remainder
adds
<
=
1
/
2
\
n
"
)
;
}
goto
done_rounding
;
}
if
(
lower
=
=
0
)
{
while
(
j
>
0
)
{
j
-
=
1
;
if
(
sacc
-
>
chunk
[
j
]
!
=
0
)
{
lower
=
1
;
break
;
}
}
}
if
(
lower
!
=
0
)
{
if
(
xsum_debug
)
{
printf
(
"
-
odd
no
adjustment
since
remainder
adds
<
1
/
2
\
n
"
)
;
}
goto
done_rounding
;
}
else
{
if
(
xsum_debug
)
{
printf
(
"
-
odd
round
away
from
0
since
remainder
adds
exactly
1
/
2
\
n
"
)
;
}
goto
round_away_from_zero
;
}
}
round_away_from_zero
:
ivalue
+
=
4
;
if
(
ivalue
&
(
(
xsum_int
)
1
<
<
(
XSUM_MANTISSA_BITS
+
3
)
)
)
{
ivalue
>
>
=
1
;
e
+
=
1
;
}
done_rounding
:
;
ivalue
>
>
=
2
;
e
+
=
(
i
<
<
XSUM_LOW_EXP_BITS
)
-
XSUM_EXP_BIAS
-
XSUM_MANTISSA_BITS
;
if
(
e
>
=
XSUM_EXP_MASK
)
{
intv
|
=
(
xsum_int
)
XSUM_EXP_MASK
<
<
XSUM_MANTISSA_BITS
;
COPY64
(
fltv
intv
)
;
if
(
xsum_debug
)
{
printf
(
"
Final
rounded
result
:
%
.
17le
(
overflowed
)
\
n
"
fltv
)
;
pbinary_double
(
fltv
)
;
printf
(
"
\
n
"
)
;
}
return
fltv
;
}
intv
+
=
(
xsum_int
)
e
<
<
XSUM_MANTISSA_BITS
;
intv
+
=
ivalue
&
XSUM_MANTISSA_MASK
;
COPY64
(
fltv
intv
)
;
if
(
xsum_debug
)
{
printf
(
"
Final
rounded
result
:
%
.
17le
\
n
"
fltv
)
;
pbinary_double
(
fltv
)
;
printf
(
"
\
n
"
)
;
if
(
(
ivalue
>
>
XSUM_MANTISSA_BITS
)
!
=
1
)
abort
(
)
;
}
return
fltv
;
}
void
xsum_small_display
(
xsum_small_accumulator
*
sacc
)
{
int
i
dots
;
printf
(
"
Small
accumulator
:
"
)
;
if
(
sacc
-
>
Inf
)
{
printf
(
"
%
cInf
"
sacc
-
>
Inf
>
0
?
'
+
'
:
'
-
'
)
;
if
(
(
sacc
-
>
Inf
&
(
(
xsum_uint
)
XSUM_EXP_MASK
<
<
XSUM_MANTISSA_BITS
)
)
!
=
(
(
xsum_uint
)
XSUM_EXP_MASK
<
<
XSUM_MANTISSA_BITS
)
)
{
printf
(
"
BUT
WRONG
CONTENTS
:
%
llx
"
(
long
long
)
sacc
-
>
Inf
)
;
}
}
if
(
sacc
-
>
NaN
)
{
printf
(
"
NaN
(
%
llx
)
"
(
long
long
)
sacc
-
>
NaN
)
;
}
printf
(
"
\
n
"
)
;
dots
=
0
;
for
(
i
=
XSUM_SCHUNKS
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
sacc
-
>
chunk
[
i
]
=
=
0
)
{
if
(
!
dots
)
printf
(
"
.
.
.
\
n
"
)
;
dots
=
1
;
}
else
{
printf
(
"
%
5d
%
5d
"
i
(
int
)
(
(
i
<
<
XSUM_LOW_EXP_BITS
)
-
XSUM_EXP_BIAS
-
XSUM_MANTISSA_BITS
)
)
;
pbinary_int64
(
(
int64_t
)
sacc
-
>
chunk
[
i
]
>
>
32
XSUM_SCHUNK_BITS
-
32
)
;
printf
(
"
"
)
;
pbinary_int64
(
(
int64_t
)
sacc
-
>
chunk
[
i
]
&
0xffffffff
32
)
;
printf
(
"
\
n
"
)
;
dots
=
0
;
}
}
printf
(
"
\
n
"
)
;
}
