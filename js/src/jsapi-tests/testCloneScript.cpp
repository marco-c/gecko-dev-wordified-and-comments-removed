#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
BEGIN_TEST
(
test_cloneScript
)
{
JS
:
:
RootedObject
A
(
cx
createGlobal
(
)
)
;
JS
:
:
RootedObject
B
(
cx
createGlobal
(
)
)
;
CHECK
(
A
)
;
CHECK
(
B
)
;
static
const
char
source
[
]
=
"
var
i
=
0
;
\
n
"
"
var
sum
=
0
;
\
n
"
"
while
(
i
<
10
)
{
\
n
"
"
sum
+
=
i
;
\
n
"
"
+
+
i
;
\
n
"
"
}
\
n
"
"
(
sum
)
;
\
n
"
;
JS
:
:
RootedObject
obj
(
cx
)
;
{
JSAutoRealm
a
(
cx
A
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setFileAndLine
(
__FILE__
1
)
;
JS
:
:
RootedFunction
fun
(
cx
)
;
JS
:
:
AutoObjectVector
emptyScopeChain
(
cx
)
;
CHECK
(
JS
:
:
CompileFunctionUtf8
(
cx
emptyScopeChain
options
"
f
"
0
nullptr
source
strlen
(
source
)
&
fun
)
)
;
CHECK
(
obj
=
JS_GetFunctionObject
(
fun
)
)
;
}
{
JSAutoRealm
b
(
cx
B
)
;
CHECK
(
JS
:
:
CloneFunctionObject
(
cx
obj
)
)
;
}
return
true
;
}
END_TEST
(
test_cloneScript
)
struct
Principals
final
:
public
JSPrincipals
{
public
:
Principals
(
)
{
refcount
=
0
;
}
bool
write
(
JSContext
*
cx
JSStructuredCloneWriter
*
writer
)
override
{
MOZ_ASSERT
(
false
"
not
imlemented
"
)
;
return
false
;
}
}
;
class
AutoDropPrincipals
{
JSContext
*
cx
;
JSPrincipals
*
principals
;
public
:
AutoDropPrincipals
(
JSContext
*
cx
JSPrincipals
*
principals
)
:
cx
(
cx
)
principals
(
principals
)
{
JS_HoldPrincipals
(
principals
)
;
}
~
AutoDropPrincipals
(
)
{
JS_DropPrincipals
(
cx
principals
)
;
}
}
;
static
void
DestroyPrincipals
(
JSPrincipals
*
principals
)
{
auto
p
=
static_cast
<
Principals
*
>
(
principals
)
;
delete
p
;
}
BEGIN_TEST
(
test_cloneScriptWithPrincipals
)
{
JS_InitDestroyPrincipalsCallback
(
cx
DestroyPrincipals
)
;
JSPrincipals
*
principalsA
=
new
Principals
(
)
;
AutoDropPrincipals
dropA
(
cx
principalsA
)
;
JSPrincipals
*
principalsB
=
new
Principals
(
)
;
AutoDropPrincipals
dropB
(
cx
principalsB
)
;
JS
:
:
RootedObject
A
(
cx
createGlobal
(
principalsA
)
)
;
JS
:
:
RootedObject
B
(
cx
createGlobal
(
principalsB
)
)
;
CHECK
(
A
)
;
CHECK
(
B
)
;
const
char
*
argnames
[
]
=
{
"
arg
"
}
;
static
const
char
source
[
]
=
"
return
function
(
)
{
return
arg
;
}
"
;
JS
:
:
RootedObject
obj
(
cx
)
;
{
JSAutoRealm
a
(
cx
A
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setFileAndLine
(
__FILE__
1
)
;
JS
:
:
RootedFunction
fun
(
cx
)
;
JS
:
:
AutoObjectVector
emptyScopeChain
(
cx
)
;
CHECK
(
JS
:
:
CompileFunctionUtf8
(
cx
emptyScopeChain
options
"
f
"
mozilla
:
:
ArrayLength
(
argnames
)
argnames
source
strlen
(
source
)
&
fun
)
)
;
CHECK
(
fun
)
;
JSScript
*
script
;
CHECK
(
script
=
JS_GetFunctionScript
(
cx
fun
)
)
;
CHECK
(
JS_GetScriptPrincipals
(
script
)
=
=
principalsA
)
;
CHECK
(
obj
=
JS_GetFunctionObject
(
fun
)
)
;
}
{
JSAutoRealm
b
(
cx
B
)
;
JS
:
:
RootedObject
cloned
(
cx
)
;
CHECK
(
cloned
=
JS
:
:
CloneFunctionObject
(
cx
obj
)
)
;
JS
:
:
RootedFunction
fun
(
cx
)
;
JS
:
:
RootedValue
clonedValue
(
cx
JS
:
:
ObjectValue
(
*
cloned
)
)
;
CHECK
(
fun
=
JS_ValueToFunction
(
cx
clonedValue
)
)
;
JSScript
*
script
;
CHECK
(
script
=
JS_GetFunctionScript
(
cx
fun
)
)
;
CHECK
(
JS_GetScriptPrincipals
(
script
)
=
=
principalsB
)
;
JS
:
:
RootedValue
v
(
cx
)
;
JS
:
:
RootedValue
arg
(
cx
JS
:
:
Int32Value
(
1
)
)
;
CHECK
(
JS_CallFunctionValue
(
cx
B
clonedValue
JS
:
:
HandleValueArray
(
arg
)
&
v
)
)
;
CHECK
(
v
.
isObject
(
)
)
;
JSObject
*
funobj
=
&
v
.
toObject
(
)
;
CHECK
(
JS_ObjectIsFunction
(
cx
funobj
)
)
;
CHECK
(
fun
=
JS_ValueToFunction
(
cx
v
)
)
;
CHECK
(
script
=
JS_GetFunctionScript
(
cx
fun
)
)
;
CHECK
(
JS_GetScriptPrincipals
(
script
)
=
=
principalsB
)
;
}
return
true
;
}
END_TEST
(
test_cloneScriptWithPrincipals
)
