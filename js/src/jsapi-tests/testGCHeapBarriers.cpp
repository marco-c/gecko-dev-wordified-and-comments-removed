#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
namespace
js
;
static
js
:
:
gc
:
:
CellColor
GetColor
(
JSObject
*
obj
)
{
return
obj
-
>
color
(
)
;
}
static
js
:
:
gc
:
:
CellColor
GetColor
(
const
JS
:
:
ArrayBufferOrView
&
view
)
{
return
view
.
asObjectUnbarriered
(
)
-
>
color
(
)
;
}
static
MOZ_MAYBE_UNUSED
bool
IsInsideNursery
(
gc
:
:
Cell
*
cell
)
{
return
!
cell
-
>
isTenured
(
)
;
}
static
MOZ_MAYBE_UNUSED
bool
IsInsideNursery
(
const
JS
:
:
ArrayBufferOrView
&
view
)
{
return
IsInsideNursery
(
view
.
asObjectUnbarriered
(
)
)
;
}
template
<
typename
W
typename
T
>
struct
TestStruct
{
W
wrapper
;
void
trace
(
JSTracer
*
trc
)
{
TraceNullableEdge
(
trc
&
wrapper
"
TestStruct
:
:
wrapper
"
)
;
}
TestStruct
(
)
{
}
explicit
TestStruct
(
T
init
)
:
wrapper
(
init
)
{
}
}
;
template
<
typename
T
>
static
T
CreateNurseryGCThing
(
JSContext
*
cx
)
=
delete
;
template
<
>
JSObject
*
CreateNurseryGCThing
(
JSContext
*
cx
)
{
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
JS_DefineProperty
(
cx
obj
"
x
"
42
0
)
;
MOZ_ASSERT
(
IsInsideNursery
(
obj
)
)
;
return
obj
;
}
template
<
>
JSFunction
*
CreateNurseryGCThing
(
JSContext
*
cx
)
{
return
static_cast
<
JSFunction
*
>
(
CreateNurseryGCThing
<
JSObject
*
>
(
cx
)
)
;
}
template
<
>
JS
:
:
Uint8Array
CreateNurseryGCThing
(
JSContext
*
cx
)
{
JS
:
:
Rooted
<
JS
:
:
Uint8Array
>
arr
(
cx
JS
:
:
Uint8Array
:
:
create
(
cx
100
)
)
;
JS
:
:
RootedObject
obj
(
cx
arr
.
asObject
(
)
)
;
JS_DefineProperty
(
cx
obj
"
x
"
42
0
)
;
MOZ_ASSERT
(
IsInsideNursery
(
obj
)
)
;
return
arr
;
}
template
<
typename
T
>
static
T
CreateTenuredGCThing
(
JSContext
*
cx
)
=
delete
;
template
<
>
JSObject
*
CreateTenuredGCThing
(
JSContext
*
cx
)
{
JSObject
*
obj
=
JS
:
:
NewArrayBuffer
(
cx
20
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
-
>
hasFinalize
(
)
&
&
!
(
obj
-
>
getClass
(
)
-
>
flags
&
JSCLASS_SKIP_NURSERY_FINALIZE
)
)
;
return
obj
;
}
template
<
>
JS
:
:
ArrayBuffer
CreateTenuredGCThing
(
JSContext
*
cx
)
{
return
JS
:
:
ArrayBuffer
:
:
fromObject
(
CreateTenuredGCThing
<
JSObject
*
>
(
cx
)
)
;
}
template
<
>
JS
:
:
Uint8Array
CreateTenuredGCThing
(
JSContext
*
cx
)
{
gc
:
:
AutoSuppressNurseryCellAlloc
suppress
(
cx
)
;
return
JS
:
:
Uint8Array
:
:
create
(
cx
100
)
;
}
template
<
typename
T
>
void
*
CreateHiddenTenuredGCThing
(
JSContext
*
cx
)
{
return
CreateTenuredGCThing
<
T
>
(
cx
)
;
}
template
<
>
void
*
CreateHiddenTenuredGCThing
<
JS
:
:
ArrayBuffer
>
(
JSContext
*
cx
)
{
return
CreateTenuredGCThing
<
JS
:
:
ArrayBuffer
>
(
cx
)
.
asObjectUnbarriered
(
)
;
}
template
<
>
void
*
CreateHiddenTenuredGCThing
<
JS
:
:
Uint8Array
>
(
JSContext
*
cx
)
{
return
CreateTenuredGCThing
<
JS
:
:
Uint8Array
>
(
cx
)
.
asObjectUnbarriered
(
)
;
}
static
uintptr_t
UnbarrieredCastToInt
(
gc
:
:
Cell
*
cell
)
{
return
reinterpret_cast
<
uintptr_t
>
(
cell
)
;
}
static
uintptr_t
UnbarrieredCastToInt
(
const
JS
:
:
ArrayBufferOrView
&
view
)
{
return
UnbarrieredCastToInt
(
view
.
asObjectUnbarriered
(
)
)
;
}
template
<
typename
T
>
T
RecoverHiddenGCThing
(
void
*
ptr
)
{
return
reinterpret_cast
<
T
>
(
ptr
)
;
}
template
<
>
JS
:
:
ArrayBuffer
RecoverHiddenGCThing
(
void
*
ptr
)
{
return
JS
:
:
ArrayBuffer
:
:
fromObject
(
RecoverHiddenGCThing
<
JSObject
*
>
(
ptr
)
)
;
}
template
<
>
JS
:
:
Uint8Array
RecoverHiddenGCThing
(
void
*
ptr
)
{
return
JS
:
:
Uint8Array
:
:
fromObject
(
RecoverHiddenGCThing
<
JSObject
*
>
(
ptr
)
)
;
}
static
void
MakeGray
(
JSObject
*
obj
)
{
gc
:
:
TenuredCell
*
cell
=
&
obj
-
>
asTenured
(
)
;
cell
-
>
unmark
(
)
;
cell
-
>
markIfUnmarked
(
gc
:
:
MarkColor
:
:
Gray
)
;
MOZ_ASSERT
(
obj
-
>
isMarkedGray
(
)
)
;
}
static
void
MakeGray
(
const
JS
:
:
ArrayBufferOrView
&
view
)
{
MakeGray
(
view
.
asObjectUnbarriered
(
)
)
;
}
BEGIN_TEST
(
testGCHeapPostBarriers
)
{
AutoLeaveZeal
nozeal
(
cx
)
;
JS_GC
(
cx
)
;
JS
:
:
RootedObject
obj
(
cx
CreateNurseryGCThing
<
JSObject
*
>
(
cx
)
)
;
CHECK
(
IsInsideNursery
(
obj
.
get
(
)
)
)
;
JS_GC
(
cx
)
;
CHECK
(
!
IsInsideNursery
(
obj
.
get
(
)
)
)
;
JS
:
:
RootedObject
tenuredObject
(
cx
obj
)
;
CHECK
(
TestHeapPostBarriersForType
<
JSObject
*
>
(
)
)
;
CHECK
(
TestHeapPostBarriersForType
<
JSFunction
*
>
(
)
)
;
CHECK
(
TestHeapPostBarriersForType
<
JS
:
:
Uint8Array
>
(
)
)
;
return
true
;
}
bool
CanAccessObject
(
JSObject
*
obj
)
{
JS
:
:
RootedObject
rootedObj
(
cx
obj
)
;
JS
:
:
RootedValue
value
(
cx
)
;
CHECK
(
JS_GetProperty
(
cx
rootedObj
"
x
"
&
value
)
)
;
CHECK
(
value
.
isInt32
(
)
)
;
CHECK
(
value
.
toInt32
(
)
=
=
42
)
;
return
true
;
}
bool
CanAccessObject
(
const
JS
:
:
ArrayBufferOrView
&
view
)
{
return
CanAccessObject
(
view
.
asObject
(
)
)
;
}
template
<
typename
T
>
bool
TestHeapPostBarriersForType
(
)
{
CHECK
(
(
TestHeapPostBarriersForWrapper
<
js
:
:
GCPtr
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
JS
:
:
Heap
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
js
:
:
HeapPtr
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
js
:
:
WeakHeapPtr
T
>
(
)
)
)
;
return
true
;
}
template
<
template
<
typename
>
class
W
typename
T
>
bool
TestHeapPostBarriersForMovableWrapper
(
)
{
CHECK
(
(
TestHeapPostBarriersForWrapper
<
W
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierMoveConstruction
<
W
<
T
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierMoveAssignment
<
W
<
T
>
T
>
(
)
)
)
;
return
true
;
}
template
<
template
<
typename
>
class
W
typename
T
>
bool
TestHeapPostBarriersForWrapper
(
)
{
CHECK
(
(
TestHeapPostBarrierConstruction
<
W
<
T
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierConstruction
<
const
W
<
T
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierUpdate
<
W
<
T
>
T
>
(
)
)
)
;
if
constexpr
(
!
std
:
:
is_same_v
<
W
<
T
>
GCPtr
<
T
>
>
)
{
CHECK
(
(
TestHeapPostBarrierInitFailure
<
W
<
T
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierInitFailure
<
const
W
<
T
>
T
>
(
)
)
)
;
}
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierConstruction
(
)
{
T
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
)
;
CHECK
(
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
UnbarrieredCastToInt
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
*
testStruct
=
js_new
<
TestStruct
<
W
T
>
>
(
initialObj
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
wrapper
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
IsInsideNursery
(
wrapper
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper
.
get
(
)
)
)
;
mozilla
:
:
Maybe
<
gc
:
:
AutoSetThreadIsFinalizing
>
threadIsFinalizing
;
if
constexpr
(
std
:
:
is_same_v
<
std
:
:
remove_const_t
<
W
>
GCPtr
<
T
>
>
)
{
threadIsFinalizing
.
emplace
(
)
;
}
js_delete
(
testStruct
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierUpdate
(
)
{
T
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
)
;
CHECK
(
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
UnbarrieredCastToInt
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
*
testStruct
=
js_new
<
TestStruct
<
W
T
>
>
(
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
!
wrapper
.
get
(
)
)
;
wrapper
=
initialObj
;
CHECK
(
wrapper
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
IsInsideNursery
(
wrapper
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper
.
get
(
)
)
)
;
gc
:
:
AutoSetThreadIsFinalizing
threadIsFinalizing
;
js_delete
(
testStruct
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierInitFailure
(
)
{
T
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
)
;
CHECK
(
IsInsideNursery
(
initialObj
)
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
testStruct
=
cx
-
>
make_unique
<
TestStruct
<
W
T
>
>
(
initialObj
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
wrapper
=
=
initialObj
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierMoveConstruction
(
)
{
T
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
)
;
CHECK
(
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
UnbarrieredCastToInt
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
W
wrapper1
(
initialObj
)
;
CHECK
(
wrapper1
=
=
initialObj
)
;
W
wrapper2
(
std
:
:
move
(
wrapper1
)
)
;
CHECK
(
wrapper2
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper1
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper2
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
IsInsideNursery
(
wrapper2
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper2
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierMoveAssignment
(
)
{
T
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
)
;
CHECK
(
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
UnbarrieredCastToInt
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
W
wrapper1
(
initialObj
)
;
CHECK
(
wrapper1
=
=
initialObj
)
;
W
wrapper2
;
wrapper2
=
std
:
:
move
(
wrapper1
)
;
CHECK
(
wrapper2
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper1
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
UnbarrieredCastToInt
(
wrapper2
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
IsInsideNursery
(
wrapper2
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper2
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
END_TEST
(
testGCHeapPostBarriers
)
BEGIN_TEST
(
testGCHeapReadBarriers
)
{
AutoLeaveZeal
nozeal
(
cx
)
;
CHECK
(
(
TestWrapperType
<
JS
:
:
Heap
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
JS
:
:
TenuredHeap
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
WeakHeapPtr
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
JS
:
:
Heap
<
JS
:
:
ArrayBuffer
>
JS
:
:
ArrayBuffer
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
JS
:
:
Heap
<
JS
:
:
Uint8Array
>
JS
:
:
Uint8Array
>
(
)
)
)
;
CHECK
(
(
TestConstructorBarrier
<
JS
:
:
Heap
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestConstructorBarrier
<
JS
:
:
Heap
<
JS
:
:
ArrayBuffer
>
JS
:
:
ArrayBuffer
>
(
)
)
)
;
CHECK
(
(
TestConstructorBarrier
<
JS
:
:
Heap
<
JS
:
:
Uint8Array
>
JS
:
:
Uint8Array
>
(
)
)
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestWrapperType
(
)
{
CHECK
(
(
TestReadBarrierUnmarksGray
<
WrapperT
ObjectT
>
(
)
)
)
;
CHECK
(
(
TestReadBarrierMarksBlack
<
WrapperT
ObjectT
>
(
true
)
)
)
;
CHECK
(
(
TestReadBarrierMarksBlack
<
WrapperT
ObjectT
>
(
false
)
)
)
;
Rooted
<
ObjectT
>
obj1
(
cx
CreateTenuredGCThing
<
ObjectT
>
(
cx
)
)
;
Rooted
<
ObjectT
>
obj2
(
cx
CreateTenuredGCThing
<
ObjectT
>
(
cx
)
)
;
MakeGray
(
obj1
)
;
MakeGray
(
obj2
)
;
WrapperT
wrapper1
(
obj1
)
;
WrapperT
wrapper2
(
obj2
)
;
const
ObjectT
constobj1
=
obj1
;
const
ObjectT
constobj2
=
obj2
;
CHECK
(
(
TestUnbarrieredOperations
<
WrapperT
ObjectT
>
(
obj1
obj2
wrapper1
wrapper2
)
)
)
;
CHECK
(
(
TestUnbarrieredOperations
<
WrapperT
ObjectT
>
(
constobj1
constobj2
wrapper1
wrapper2
)
)
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
void
Access
(
const
WrapperT
&
wrapper
)
{
if
constexpr
(
std
:
:
is_base_of_v
<
JS
:
:
ArrayBufferOrView
ObjectT
>
)
{
(
void
)
wrapper
.
asObject
(
)
;
}
else
{
(
void
)
*
wrapper
;
}
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestReadBarrierUnmarksGray
(
)
{
Rooted
<
ObjectT
>
obj
(
cx
CreateTenuredGCThing
<
ObjectT
>
(
cx
)
)
;
WrapperT
wrapper
(
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
Access
<
WrapperT
ObjectT
>
(
wrapper
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
MakeGray
(
obj
)
;
Access
<
WrapperT
ObjectT
>
(
wrapper
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
template
<
typename
F
>
bool
CallDuringIncrementalGC
(
uint32_t
mode
F
&
&
f
)
{
#
ifndef
JS_GC_ZEAL
fprintf
(
stderr
"
This
test
requires
building
with
-
-
enable
-
gczeal
\
n
"
)
;
#
else
AutoGCParameter
incremental
(
cx
JSGC_INCREMENTAL_GC_ENABLED
true
)
;
const
int64_t
BudgetMS
=
10000
;
JS_SetGCZeal
(
cx
mode
0
)
;
JS
:
:
PrepareZoneForGC
(
cx
js
:
:
GetContextZone
(
cx
)
)
;
js
:
:
SliceBudget
budget
{
TimeBudget
(
BudgetMS
)
}
;
JS
:
:
StartIncrementalGC
(
cx
JS
:
:
GCOptions
(
)
JS
:
:
GCReason
:
:
DEBUG_GC
budget
)
;
CHECK
(
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
;
CHECK
(
f
(
)
)
;
JS
:
:
FinishIncrementalGC
(
cx
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
#
endif
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestReadBarrierMarksBlack
(
bool
fromWhite
)
{
AutoLeaveZeal
noZeal
(
cx
)
;
void
*
ptr
=
CreateHiddenTenuredGCThing
<
ObjectT
>
(
cx
)
;
CHECK
(
ptr
)
;
CallDuringIncrementalGC
(
9
[
&
]
(
)
-
>
bool
{
CHECK
(
JS
:
:
IsIncrementalBarrierNeeded
(
cx
)
)
;
auto
obj
=
RecoverHiddenGCThing
<
ObjectT
>
(
ptr
)
;
WrapperT
wrapper
(
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
if
(
!
fromWhite
)
{
MakeGray
(
obj
)
;
}
Access
<
WrapperT
ObjectT
>
(
wrapper
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestConstructorBarrier
(
)
{
AutoLeaveZeal
noZeal
(
cx
)
;
void
*
ptr
=
CreateHiddenTenuredGCThing
<
ObjectT
>
(
cx
)
;
CHECK
(
ptr
)
;
CallDuringIncrementalGC
(
9
[
&
]
(
)
-
>
bool
{
CHECK
(
JS
:
:
IsIncrementalBarrierNeeded
(
cx
)
)
;
auto
obj
=
RecoverHiddenGCThing
<
ObjectT
>
(
ptr
)
;
WrapperT
wrapper
(
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
WrapperT
copiedWrapper
(
wrapper
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
)
;
ptr
=
CreateHiddenTenuredGCThing
<
ObjectT
>
(
cx
)
;
CHECK
(
ptr
)
;
CallDuringIncrementalGC
(
9
[
&
]
(
)
-
>
bool
{
CHECK
(
JS
:
:
IsIncrementalBarrierNeeded
(
cx
)
)
;
auto
obj
=
RecoverHiddenGCThing
<
ObjectT
>
(
ptr
)
;
WrapperT
wrapper
(
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
WrapperT
movedWrapper
(
std
:
:
move
(
wrapper
)
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestUnbarrieredOperations
(
ObjectT
obj
ObjectT
obj2
WrapperT
&
wrapper
WrapperT
&
wrapper2
)
{
(
void
)
bool
(
wrapper
)
;
(
void
)
bool
(
wrapper2
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
int
x
=
0
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
obj
=
=
obj2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
obj
=
=
wrapper2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
wrapper
=
=
obj2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
wrapper
=
=
wrapper2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
x
=
=
0
)
;
x
+
=
obj
!
=
obj2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
obj
!
=
wrapper2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
wrapper
!
=
obj2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
x
+
=
wrapper
!
=
wrapper2
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
x
=
=
4
)
;
return
true
;
}
END_TEST
(
testGCHeapReadBarriers
)
using
ObjectVector
=
Vector
<
JSObject
*
0
SystemAllocPolicy
>
;
BEGIN_TEST
(
testGCHeapPreBarriers
)
{
AutoLeaveZeal
nozeal
(
cx
)
;
AutoGCParameter
param1
(
cx
JSGC_INCREMENTAL_GC_ENABLED
true
)
;
size_t
objectCount
=
100
;
ObjectVector
testObjects
;
for
(
size_t
i
=
0
;
i
<
objectCount
;
i
+
+
)
{
JSObject
*
obj
=
CreateTenuredGCThing
<
JSObject
*
>
(
cx
)
;
CHECK
(
obj
)
;
CHECK
(
testObjects
.
append
(
obj
)
)
;
}
JS
:
:
PrepareForFullGC
(
cx
)
;
SliceBudget
budget
(
WorkBudget
(
1
)
)
;
gc
:
:
GCRuntime
*
gc
=
&
cx
-
>
runtime
(
)
-
>
gc
;
gc
-
>
startDebugGC
(
JS
:
:
GCOptions
:
:
Normal
budget
)
;
while
(
gc
-
>
state
(
)
!
=
gc
:
:
State
:
:
Mark
)
{
gc
-
>
debugGCSlice
(
budget
)
;
}
MOZ_ASSERT
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
;
TestWrapper
<
HeapPtr
<
JSObject
*
>
>
(
testObjects
)
;
TestWrapper
<
PreBarriered
<
JSObject
*
>
>
(
testObjects
)
;
TestGCPtr
(
testObjects
)
;
gc
:
:
FinishGC
(
cx
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestWrapper
(
ObjectVector
&
testObjects
)
{
CHECK
(
TestCopyConstruction
<
Wrapper
>
(
testObjects
.
popCopy
(
)
)
)
;
CHECK
(
TestMoveConstruction
<
Wrapper
>
(
testObjects
.
popCopy
(
)
)
)
;
CHECK
(
TestAssignment
<
Wrapper
>
(
testObjects
.
popCopy
(
)
testObjects
.
popCopy
(
)
)
)
;
CHECK
(
TestMoveAssignment
<
Wrapper
>
(
testObjects
.
popCopy
(
)
testObjects
.
popCopy
(
)
)
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestCopyConstruction
(
JSObject
*
obj
)
{
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
Wrapper
wrapper1
(
obj
)
;
Wrapper
wrapper2
(
wrapper1
)
;
CHECK
(
wrapper1
=
=
obj
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
}
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestMoveConstruction
(
JSObject
*
obj
)
{
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
Wrapper
wrapper1
(
obj
)
;
MakeGray
(
obj
)
;
Wrapper
wrapper2
(
std
:
:
move
(
wrapper1
)
)
;
CHECK
(
!
wrapper1
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
}
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestAssignment
(
JSObject
*
obj1
JSObject
*
obj2
)
{
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
Wrapper
wrapper1
(
obj1
)
;
Wrapper
wrapper2
(
obj2
)
;
wrapper2
=
wrapper1
;
CHECK
(
wrapper1
=
=
obj1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
}
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestMoveAssignment
(
JSObject
*
obj1
JSObject
*
obj2
)
{
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
Wrapper
wrapper1
(
obj1
)
;
Wrapper
wrapper2
(
obj2
)
;
MakeGray
(
obj1
)
;
wrapper2
=
std
:
:
move
(
wrapper1
)
;
CHECK
(
!
wrapper1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
Gray
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
}
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
return
true
;
}
bool
TestGCPtr
(
ObjectVector
&
testObjects
)
{
CHECK
(
TestGCPtrCopyConstruction
(
testObjects
.
popCopy
(
)
)
)
;
CHECK
(
TestGCPtrAssignment
(
testObjects
.
popCopy
(
)
testObjects
.
popCopy
(
)
)
)
;
return
true
;
}
bool
TestGCPtrCopyConstruction
(
JSObject
*
obj
)
{
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
gc
:
:
AutoSetThreadIsFinalizing
threadIsFinalizing
;
GCPtrObject
wrapper1
(
obj
)
;
GCPtrObject
wrapper2
(
wrapper1
)
;
CHECK
(
wrapper1
=
=
obj
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
}
CHECK
(
GetColor
(
obj
)
=
=
gc
:
:
CellColor
:
:
White
)
;
return
true
;
}
bool
TestGCPtrAssignment
(
JSObject
*
obj1
JSObject
*
obj2
)
{
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
White
)
;
{
gc
:
:
AutoSetThreadIsFinalizing
threadIsFinalizing
;
GCPtrObject
wrapper1
(
obj1
)
;
GCPtrObject
wrapper2
(
obj2
)
;
wrapper2
=
wrapper1
;
CHECK
(
wrapper1
=
=
obj1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
CHECK
(
GetColor
(
obj2
)
=
=
gc
:
:
CellColor
:
:
Black
)
;
}
CHECK
(
GetColor
(
obj1
)
=
=
gc
:
:
CellColor
:
:
White
)
;
return
true
;
}
END_TEST
(
testGCHeapPreBarriers
)
