#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
namespace
js
;
template
<
typename
W
typename
T
>
struct
TestStruct
{
W
wrapper
;
void
trace
(
JSTracer
*
trc
)
{
TraceNullableEdge
(
trc
&
wrapper
"
TestStruct
:
:
wrapper
"
)
;
}
TestStruct
(
)
{
}
explicit
TestStruct
(
T
init
)
:
wrapper
(
init
)
{
}
}
;
namespace
JS
{
template
<
typename
T
>
struct
DeletePolicy
<
TestStruct
<
js
:
:
GCPtr
<
T
>
T
>
>
:
public
js
:
:
GCManagedDeletePolicy
<
TestStruct
<
js
:
:
GCPtr
<
T
>
T
>
>
{
}
;
template
<
typename
T
>
struct
DeletePolicy
<
TestStruct
<
const
js
:
:
GCPtr
<
T
>
T
>
>
:
public
js
:
:
GCManagedDeletePolicy
<
TestStruct
<
const
js
:
:
GCPtr
<
T
>
T
>
>
{
}
;
}
template
<
typename
T
>
static
T
*
CreateNurseryGCThing
(
JSContext
*
cx
)
{
MOZ_CRASH
(
)
;
return
nullptr
;
}
template
<
>
JSObject
*
CreateNurseryGCThing
(
JSContext
*
cx
)
{
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
JS_DefineProperty
(
cx
obj
"
x
"
42
0
)
;
MOZ_ASSERT
(
IsInsideNursery
(
obj
)
)
;
return
obj
;
}
template
<
>
JSFunction
*
CreateNurseryGCThing
(
JSContext
*
cx
)
{
return
static_cast
<
JSFunction
*
>
(
CreateNurseryGCThing
<
JSObject
>
(
cx
)
)
;
}
template
<
typename
T
>
static
T
*
CreateTenuredGCThing
(
JSContext
*
cx
)
{
MOZ_CRASH
(
)
;
return
nullptr
;
}
template
<
>
JSObject
*
CreateTenuredGCThing
(
JSContext
*
cx
)
{
JSObject
*
obj
=
JS
:
:
NewArrayBuffer
(
cx
20
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
-
>
hasFinalize
(
)
&
&
!
(
obj
-
>
getClass
(
)
-
>
flags
&
JSCLASS_SKIP_NURSERY_FINALIZE
)
)
;
return
obj
;
}
static
void
MakeWhite
(
JSObject
*
obj
)
{
gc
:
:
TenuredCell
*
cell
=
&
obj
-
>
asTenured
(
)
;
cell
-
>
unmark
(
)
;
MOZ_ASSERT
(
!
obj
-
>
isMarkedAny
(
)
)
;
}
static
void
MakeGray
(
JSObject
*
obj
)
{
gc
:
:
TenuredCell
*
cell
=
&
obj
-
>
asTenured
(
)
;
cell
-
>
unmark
(
)
;
cell
-
>
markIfUnmarked
(
gc
:
:
MarkColor
:
:
Gray
)
;
MOZ_ASSERT
(
obj
-
>
isMarkedGray
(
)
)
;
}
BEGIN_TEST
(
testGCHeapPostBarriers
)
{
#
ifdef
JS_GC_ZEAL
AutoLeaveZeal
nozeal
(
cx
)
;
#
endif
JS_GC
(
cx
)
;
JS
:
:
RootedObject
obj
(
cx
CreateNurseryGCThing
<
JSObject
>
(
cx
)
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
obj
.
get
(
)
)
)
;
JS_GC
(
cx
)
;
CHECK
(
!
js
:
:
gc
:
:
IsInsideNursery
(
obj
.
get
(
)
)
)
;
JS
:
:
RootedObject
tenuredObject
(
cx
obj
)
;
CHECK
(
TestHeapPostBarriersForType
<
JSObject
>
(
)
)
;
CHECK
(
TestHeapPostBarriersForType
<
JSFunction
>
(
)
)
;
return
true
;
}
bool
CanAccessObject
(
JSObject
*
obj
)
{
JS
:
:
RootedObject
rootedObj
(
cx
obj
)
;
JS
:
:
RootedValue
value
(
cx
)
;
CHECK
(
JS_GetProperty
(
cx
rootedObj
"
x
"
&
value
)
)
;
CHECK
(
value
.
isInt32
(
)
)
;
CHECK
(
value
.
toInt32
(
)
=
=
42
)
;
return
true
;
}
template
<
typename
T
>
bool
TestHeapPostBarriersForType
(
)
{
CHECK
(
(
TestHeapPostBarriersForWrapper
<
js
:
:
GCPtr
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
JS
:
:
Heap
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
js
:
:
HeapPtr
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarriersForMovableWrapper
<
js
:
:
WeakHeapPtr
T
>
(
)
)
)
;
return
true
;
}
template
<
template
<
typename
>
class
W
typename
T
>
bool
TestHeapPostBarriersForMovableWrapper
(
)
{
CHECK
(
(
TestHeapPostBarriersForWrapper
<
W
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierMoveConstruction
<
W
<
T
*
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierMoveAssignment
<
W
<
T
*
>
T
>
(
)
)
)
;
return
true
;
}
template
<
template
<
typename
>
class
W
typename
T
>
bool
TestHeapPostBarriersForWrapper
(
)
{
CHECK
(
(
TestHeapPostBarrierConstruction
<
W
<
T
*
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierConstruction
<
const
W
<
T
*
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierUpdate
<
W
<
T
*
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierInitFailure
<
W
<
T
*
>
T
>
(
)
)
)
;
CHECK
(
(
TestHeapPostBarrierInitFailure
<
const
W
<
T
*
>
T
>
(
)
)
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierConstruction
(
)
{
T
*
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
!
=
nullptr
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
uintptr_t
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
testStruct
=
cx
-
>
make_unique
<
TestStruct
<
W
T
*
>
>
(
initialObj
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
wrapper
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
uintptr_t
(
wrapper
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
js
:
:
gc
:
:
IsInsideNursery
(
wrapper
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierUpdate
(
)
{
T
*
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
!
=
nullptr
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
uintptr_t
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
testStruct
=
cx
-
>
make_unique
<
TestStruct
<
W
T
*
>
>
(
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
wrapper
.
get
(
)
=
=
nullptr
)
;
wrapper
=
initialObj
;
CHECK
(
wrapper
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
uintptr_t
(
wrapper
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
js
:
:
gc
:
:
IsInsideNursery
(
wrapper
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierInitFailure
(
)
{
T
*
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
!
=
nullptr
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
initialObj
)
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
auto
testStruct
=
cx
-
>
make_unique
<
TestStruct
<
W
T
*
>
>
(
initialObj
)
;
CHECK
(
testStruct
)
;
auto
&
wrapper
=
testStruct
-
>
wrapper
;
CHECK
(
wrapper
=
=
initialObj
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierMoveConstruction
(
)
{
T
*
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
!
=
nullptr
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
uintptr_t
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
W
wrapper1
(
initialObj
)
;
CHECK
(
wrapper1
=
=
initialObj
)
;
W
wrapper2
(
std
:
:
move
(
wrapper1
)
)
;
CHECK
(
wrapper2
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
uintptr_t
(
wrapper1
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
uintptr_t
(
wrapper2
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
js
:
:
gc
:
:
IsInsideNursery
(
wrapper2
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper2
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
template
<
typename
W
typename
T
>
bool
TestHeapPostBarrierMoveAssignment
(
)
{
T
*
initialObj
=
CreateNurseryGCThing
<
T
>
(
cx
)
;
CHECK
(
initialObj
!
=
nullptr
)
;
CHECK
(
js
:
:
gc
:
:
IsInsideNursery
(
initialObj
)
)
;
uintptr_t
initialObjAsInt
=
uintptr_t
(
initialObj
)
;
{
JS
:
:
AutoSuppressGCAnalysis
noAnalysis
(
cx
)
;
W
wrapper1
(
initialObj
)
;
CHECK
(
wrapper1
=
=
initialObj
)
;
W
wrapper2
;
wrapper2
=
std
:
:
move
(
wrapper1
)
;
CHECK
(
wrapper2
=
=
initialObj
)
;
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
CHECK
(
uintptr_t
(
wrapper1
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
uintptr_t
(
wrapper2
.
get
(
)
)
!
=
initialObjAsInt
)
;
CHECK
(
!
js
:
:
gc
:
:
IsInsideNursery
(
wrapper2
.
get
(
)
)
)
;
CHECK
(
CanAccessObject
(
wrapper2
.
get
(
)
)
)
;
}
cx
-
>
minorGC
(
JS
:
:
GCReason
:
:
API
)
;
return
true
;
}
END_TEST
(
testGCHeapPostBarriers
)
BEGIN_TEST
(
testGCHeapReadBarriers
)
{
#
ifdef
JS_GC_ZEAL
AutoLeaveZeal
nozeal
(
cx
)
;
#
endif
CHECK
(
(
TestWrapperType
<
JS
:
:
Heap
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
JS
:
:
TenuredHeap
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
CHECK
(
(
TestWrapperType
<
WeakHeapPtr
<
JSObject
*
>
JSObject
*
>
(
)
)
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestWrapperType
(
)
{
{
Rooted
<
ObjectT
>
obj0
(
cx
CreateTenuredGCThing
<
JSObject
>
(
cx
)
)
;
WrapperT
wrapper0
(
obj0
)
;
MakeGray
(
obj0
)
;
mozilla
:
:
Unused
<
<
*
wrapper0
;
CHECK
(
obj0
-
>
isMarkedBlack
(
)
)
;
}
Rooted
<
ObjectT
>
obj1
(
cx
CreateTenuredGCThing
<
JSObject
>
(
cx
)
)
;
Rooted
<
ObjectT
>
obj2
(
cx
CreateTenuredGCThing
<
JSObject
>
(
cx
)
)
;
MakeGray
(
obj1
)
;
MakeGray
(
obj2
)
;
WrapperT
wrapper1
(
obj1
)
;
WrapperT
wrapper2
(
obj2
)
;
const
ObjectT
constobj1
=
obj1
;
const
ObjectT
constobj2
=
obj2
;
CHECK
(
(
TestUnbarrieredOperations
<
WrapperT
ObjectT
>
(
obj1
obj2
wrapper1
wrapper2
)
)
)
;
CHECK
(
(
TestUnbarrieredOperations
<
WrapperT
ObjectT
>
(
constobj1
constobj2
wrapper1
wrapper2
)
)
)
;
return
true
;
}
template
<
typename
WrapperT
typename
ObjectT
>
bool
TestUnbarrieredOperations
(
ObjectT
obj
ObjectT
obj2
WrapperT
&
wrapper
WrapperT
&
wrapper2
)
{
mozilla
:
:
Unused
<
<
bool
(
wrapper
)
;
mozilla
:
:
Unused
<
<
bool
(
wrapper2
)
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
int
x
=
0
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
obj
=
=
obj2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
obj
=
=
wrapper2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
wrapper
=
=
obj2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
wrapper
=
=
wrapper2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
CHECK
(
x
=
=
0
)
;
x
+
=
obj
!
=
obj2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
obj
!
=
wrapper2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
wrapper
!
=
obj2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
x
+
=
wrapper
!
=
wrapper2
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedGray
(
)
)
;
CHECK
(
x
=
=
4
)
;
return
true
;
}
END_TEST
(
testGCHeapReadBarriers
)
BEGIN_TEST
(
testGCHeapPreBarriers
)
{
#
ifdef
JS_GC_ZEAL
AutoLeaveZeal
nozeal
(
cx
)
;
#
endif
uint32_t
oldMode
=
JS_GetGCParameter
(
cx
JSGC_MODE
)
;
JS_SetGCParameter
(
cx
JSGC_MODE
JSGC_MODE_ZONE_INCREMENTAL
)
;
RootedObject
obj1
(
cx
CreateTenuredGCThing
<
JSObject
>
(
cx
)
)
;
RootedObject
obj2
(
cx
CreateTenuredGCThing
<
JSObject
>
(
cx
)
)
;
CHECK
(
obj1
)
;
CHECK
(
obj2
)
;
JS
:
:
PrepareForFullGC
(
cx
)
;
SliceBudget
budget
(
WorkBudget
(
1
)
)
;
gc
:
:
GCRuntime
*
gc
=
&
cx
-
>
runtime
(
)
-
>
gc
;
gc
-
>
startDebugGC
(
GC_NORMAL
budget
)
;
MOZ_ASSERT
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
;
TestWrapper
<
HeapPtr
<
JSObject
*
>
>
(
obj1
obj2
)
;
TestWrapper
<
PreBarriered
<
JSObject
*
>
>
(
obj1
obj2
)
;
TestGCPtr
(
obj1
obj2
)
;
gc
:
:
FinishGC
(
cx
JS
:
:
GCReason
:
:
API
)
;
JS_SetGCParameter
(
cx
JSGC_MODE
oldMode
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestWrapper
(
HandleObject
obj1
HandleObject
obj2
)
{
CHECK
(
TestCopyConstruction
<
Wrapper
>
(
obj1
)
)
;
CHECK
(
TestMoveConstruction
<
Wrapper
>
(
obj1
)
)
;
CHECK
(
TestAssignment
<
Wrapper
>
(
obj1
obj2
)
)
;
CHECK
(
TestMoveAssignment
<
Wrapper
>
(
obj1
obj2
)
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestCopyConstruction
(
HandleObject
obj
)
{
MakeWhite
(
obj
)
;
{
Wrapper
wrapper1
(
obj
)
;
Wrapper
wrapper2
(
wrapper1
)
;
CHECK
(
wrapper1
=
=
obj
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
!
obj
-
>
isMarkedAny
(
)
)
;
}
MOZ_ASSERT
(
obj
-
>
isMarkedBlack
(
)
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestMoveConstruction
(
HandleObject
obj
)
{
MakeWhite
(
obj
)
;
{
Wrapper
wrapper1
(
obj
)
;
MakeGray
(
obj
)
;
Wrapper
wrapper2
(
std
:
:
move
(
wrapper1
)
)
;
CHECK
(
!
wrapper1
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
obj
-
>
isMarkedGray
(
)
)
;
}
CHECK
(
obj
-
>
isMarkedBlack
(
)
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestAssignment
(
HandleObject
obj1
HandleObject
obj2
)
{
MakeWhite
(
obj1
)
;
MakeWhite
(
obj2
)
;
{
Wrapper
wrapper1
(
obj1
)
;
Wrapper
wrapper2
(
obj2
)
;
wrapper2
=
wrapper1
;
CHECK
(
wrapper1
=
=
obj1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
!
obj1
-
>
isMarkedAny
(
)
)
;
CHECK
(
obj2
-
>
isMarkedBlack
(
)
)
;
}
CHECK
(
obj1
-
>
isMarkedBlack
(
)
)
;
return
true
;
}
template
<
typename
Wrapper
>
bool
TestMoveAssignment
(
HandleObject
obj1
HandleObject
obj2
)
{
MakeWhite
(
obj1
)
;
MakeWhite
(
obj2
)
;
{
Wrapper
wrapper1
(
obj1
)
;
Wrapper
wrapper2
(
obj2
)
;
MakeGray
(
obj1
)
;
wrapper2
=
std
:
:
move
(
wrapper1
)
;
CHECK
(
!
wrapper1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
obj1
-
>
isMarkedGray
(
)
)
;
CHECK
(
obj2
-
>
isMarkedBlack
(
)
)
;
}
CHECK
(
obj1
-
>
isMarkedBlack
(
)
)
;
return
true
;
}
bool
TestGCPtr
(
HandleObject
obj1
HandleObject
obj2
)
{
CHECK
(
TestGCPtrCopyConstruction
(
obj1
)
)
;
CHECK
(
TestGCPtrAssignment
(
obj1
obj2
)
)
;
return
true
;
}
bool
TestGCPtrCopyConstruction
(
HandleObject
obj
)
{
MakeWhite
(
obj
)
;
{
gc
:
:
AutoSetThreadIsSweeping
threadIsSweeping
;
GCPtrObject
wrapper1
(
obj
)
;
GCPtrObject
wrapper2
(
wrapper1
)
;
CHECK
(
wrapper1
=
=
obj
)
;
CHECK
(
wrapper2
=
=
obj
)
;
CHECK
(
!
obj
-
>
isMarkedAny
(
)
)
;
}
CHECK
(
!
obj
-
>
isMarkedAny
(
)
)
;
return
true
;
}
bool
TestGCPtrAssignment
(
HandleObject
obj1
HandleObject
obj2
)
{
MakeWhite
(
obj1
)
;
MakeWhite
(
obj2
)
;
{
gc
:
:
AutoSetThreadIsSweeping
threadIsSweeping
;
GCPtrObject
wrapper1
(
obj1
)
;
GCPtrObject
wrapper2
(
obj2
)
;
wrapper2
=
wrapper1
;
CHECK
(
wrapper1
=
=
obj1
)
;
CHECK
(
wrapper2
=
=
obj1
)
;
CHECK
(
!
obj1
-
>
isMarkedAny
(
)
)
;
CHECK
(
obj2
-
>
isMarkedBlack
(
)
)
;
}
CHECK
(
!
obj1
-
>
isMarkedAny
(
)
)
;
return
true
;
}
END_TEST
(
testGCHeapPreBarriers
)
