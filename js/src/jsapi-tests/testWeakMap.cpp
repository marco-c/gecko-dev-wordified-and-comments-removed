#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
GlobalObject
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
WeakMap
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
vm
/
Realm
.
h
"
using
namespace
js
;
static
bool
checkSize
(
JSContext
*
cx
JS
:
:
HandleObject
map
uint32_t
expected
)
{
JS
:
:
RootedObject
keys
(
cx
)
;
if
(
!
JS_NondeterministicGetWeakMapKeys
(
cx
map
&
keys
)
)
{
return
false
;
}
uint32_t
length
;
if
(
!
JS
:
:
GetArrayLength
(
cx
keys
&
length
)
)
{
return
false
;
}
return
length
=
=
expected
;
}
JSObject
*
keyDelegate
=
nullptr
;
BEGIN_TEST
(
testWeakMap_basicOperations
)
{
JS
:
:
RootedObject
map
(
cx
JS
:
:
NewWeakMapObject
(
cx
)
)
;
CHECK
(
IsWeakMapObject
(
map
)
)
;
JS
:
:
RootedValue
key
(
cx
JS
:
:
ObjectOrNullValue
(
newKey
(
)
)
)
;
CHECK
(
!
key
.
isNull
(
)
)
;
CHECK
(
!
JS
:
:
IsWeakMapObject
(
&
key
.
toObject
(
)
)
)
;
JS
:
:
RootedValue
r
(
cx
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
.
isUndefined
(
)
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
JS
:
:
RootedValue
val
(
cx
JS
:
:
Int32Value
(
1
)
)
;
CHECK
(
SetWeakMapEntry
(
cx
map
key
val
)
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
=
=
val
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
JS_GC
(
cx
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
=
=
val
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
key
.
setUndefined
(
)
;
JS_GC
(
cx
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
return
true
;
}
JSObject
*
newKey
(
)
{
return
JS_NewPlainObject
(
cx
)
;
}
END_TEST
(
testWeakMap_basicOperations
)
BEGIN_TEST
(
testWeakMap_setWeakMapEntry_invalid_key
)
{
JS
:
:
RootedObject
map
(
cx
JS
:
:
NewWeakMapObject
(
cx
)
)
;
CHECK
(
IsWeakMapObject
(
map
)
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
JS
:
:
RootedString
test
(
cx
JS_NewStringCopyZ
(
cx
"
test
"
)
)
;
JS
:
:
RootedSymbol
sym
(
cx
JS
:
:
GetSymbolFor
(
cx
test
)
)
;
JS
:
:
RootedValue
key
(
cx
JS
:
:
SymbolValue
(
sym
)
)
;
CHECK
(
!
key
.
isUndefined
(
)
)
;
JS
:
:
RootedValue
val
(
cx
JS
:
:
Int32Value
(
1
)
)
;
CHECK
(
!
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
SetWeakMapEntry
(
cx
map
key
val
)
=
=
false
)
;
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
)
;
CHECK
(
JS_GetPendingException
(
cx
&
exn
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
&
exn
.
toObject
(
)
)
;
JSErrorReport
*
err
=
JS_ErrorFromException
(
cx
obj
)
;
CHECK
(
err
-
>
exnType
=
=
JSEXN_TYPEERR
)
;
JS_ClearPendingException
(
cx
)
;
JS
:
:
RootedValue
r
(
cx
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
=
=
JS
:
:
UndefinedValue
(
)
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
return
true
;
}
END_TEST
(
testWeakMap_setWeakMapEntry_invalid_key
)
#
ifdef
NIGHTLY_BUILD
BEGIN_TEST
(
testWeakMap_basicOperations_symbols_as_keys
)
{
JS
:
:
RootedObject
map
(
cx
JS
:
:
NewWeakMapObject
(
cx
)
)
;
CHECK
(
IsWeakMapObject
(
map
)
)
;
JS
:
:
RootedString
test
(
cx
JS_NewStringCopyZ
(
cx
"
test
"
)
)
;
JS
:
:
RootedSymbol
sym
(
cx
JS
:
:
NewSymbol
(
cx
test
)
)
;
CHECK
(
sym
)
;
JS
:
:
RootedValue
key
(
cx
JS
:
:
SymbolValue
(
sym
)
)
;
JS
:
:
RootedValue
r
(
cx
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
.
isUndefined
(
)
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
JS
:
:
RootedValue
val
(
cx
JS
:
:
Int32Value
(
1
)
)
;
CHECK
(
SetWeakMapEntry
(
cx
map
key
val
)
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
=
=
val
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
JS_GC
(
cx
)
;
CHECK
(
GetWeakMapEntry
(
cx
map
key
&
r
)
)
;
CHECK
(
r
=
=
val
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
sym
=
nullptr
;
key
.
setUndefined
(
)
;
JS_GC
(
cx
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
return
true
;
}
END_TEST
(
testWeakMap_basicOperations_symbols_as_keys
)
#
endif
BEGIN_TEST
(
testWeakMap_keyDelegates
)
{
AutoLeaveZeal
nozeal
(
cx
)
;
AutoGCParameter
param
(
cx
JSGC_INCREMENTAL_GC_ENABLED
true
)
;
JS_GC
(
cx
)
;
JS
:
:
RootedObject
map
(
cx
JS
:
:
NewWeakMapObject
(
cx
)
)
;
CHECK
(
map
)
;
JS
:
:
RootedObject
delegate
(
cx
newDelegate
(
)
)
;
JS
:
:
RootedObject
key
(
cx
delegate
)
;
if
(
!
JS_WrapObject
(
cx
&
key
)
)
{
return
false
;
}
CHECK
(
key
)
;
CHECK
(
delegate
)
;
keyDelegate
=
delegate
;
JS
:
:
RootedObject
delegateRoot
(
cx
)
;
{
JSAutoRealm
ar
(
cx
delegate
)
;
delegateRoot
=
JS_NewPlainObject
(
cx
)
;
CHECK
(
delegateRoot
)
;
JS
:
:
RootedValue
delegateValue
(
cx
JS
:
:
ObjectValue
(
*
delegate
)
)
;
CHECK
(
JS_DefineProperty
(
cx
delegateRoot
"
delegate
"
delegateValue
0
)
)
;
}
delegate
=
nullptr
;
CHECK
(
newCCW
(
map
delegateRoot
)
)
;
performIncrementalGC
(
)
;
#
ifdef
DEBUG
CHECK
(
map
-
>
zone
(
)
-
>
lastSweepGroupIndex
(
)
<
delegateRoot
-
>
zone
(
)
-
>
lastSweepGroupIndex
(
)
)
;
#
endif
JS
:
:
RootedValue
keyVal
(
cx
JS
:
:
ObjectValue
(
*
key
)
)
;
JS
:
:
RootedValue
val
(
cx
JS
:
:
Int32Value
(
1
)
)
;
CHECK
(
SetWeakMapEntry
(
cx
map
keyVal
val
)
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
key
=
nullptr
;
keyVal
.
setUndefined
(
)
;
CHECK
(
newCCW
(
map
delegateRoot
)
)
;
performIncrementalGC
(
)
;
CHECK
(
checkSize
(
cx
map
1
)
)
;
#
ifdef
DEBUG
CHECK
(
map
-
>
zone
(
)
-
>
lastSweepGroupIndex
(
)
=
=
delegateRoot
-
>
zone
(
)
-
>
lastSweepGroupIndex
(
)
)
;
#
endif
delegateRoot
=
nullptr
;
keyDelegate
=
nullptr
;
JS_GC
(
cx
)
;
CHECK
(
checkSize
(
cx
map
0
)
)
;
return
true
;
}
static
size_t
DelegateObjectMoved
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
!
keyDelegate
)
{
return
0
;
}
MOZ_RELEASE_ASSERT
(
keyDelegate
=
=
old
)
;
keyDelegate
=
obj
;
return
0
;
}
JSObject
*
newKey
(
)
{
static
const
JSClass
keyClass
=
{
"
keyWithDelegate
"
JSCLASS_HAS_RESERVED_SLOTS
(
1
)
JS_NULL_CLASS_OPS
JS_NULL_CLASS_SPEC
JS_NULL_CLASS_EXT
JS_NULL_OBJECT_OPS
}
;
JS
:
:
RootedObject
key
(
cx
JS_NewObject
(
cx
&
keyClass
)
)
;
if
(
!
key
)
{
return
nullptr
;
}
return
key
;
}
JSObject
*
newCCW
(
JS
:
:
HandleObject
sourceZone
JS
:
:
HandleObject
destZone
)
{
JS
:
:
RootedObject
object
(
cx
)
;
{
JSAutoRealm
ar
(
cx
destZone
)
;
object
=
JS_NewPlainObject
(
cx
)
;
if
(
!
object
)
{
return
nullptr
;
}
}
{
JSAutoRealm
ar
(
cx
sourceZone
)
;
if
(
!
JS_WrapObject
(
cx
&
object
)
)
{
return
nullptr
;
}
}
cx
-
>
runtime
(
)
-
>
gc
.
evictNursery
(
)
;
return
object
;
}
JSObject
*
newDelegate
(
)
{
static
const
JSClassOps
delegateClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
JS_GlobalObjectTraceHook
}
;
static
const
js
:
:
ClassExtension
delegateClassExtension
=
{
DelegateObjectMoved
}
;
static
const
JSClass
delegateClass
=
{
"
delegate
"
JSCLASS_GLOBAL_FLAGS
|
JSCLASS_HAS_RESERVED_SLOTS
(
1
)
&
delegateClassOps
JS_NULL_CLASS_SPEC
&
delegateClassExtension
JS_NULL_OBJECT_OPS
}
;
JS
:
:
RealmOptions
options
;
JS
:
:
RootedObject
global
(
cx
JS_NewGlobalObject
(
cx
&
delegateClass
nullptr
JS
:
:
FireOnNewGlobalHook
options
)
)
;
if
(
!
global
)
{
return
nullptr
;
}
JS_SetReservedSlot
(
global
0
JS
:
:
Int32Value
(
42
)
)
;
return
global
;
}
void
performIncrementalGC
(
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
js
:
:
SliceBudget
budget
(
js
:
:
WorkBudget
(
1000
)
)
;
rt
-
>
gc
.
startDebugGC
(
JS
:
:
GCOptions
:
:
Normal
budget
)
;
while
(
rt
-
>
gc
.
state
(
)
=
=
gc
:
:
State
:
:
Prepare
)
{
rt
-
>
gc
.
debugGCSlice
(
budget
)
;
}
if
(
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
{
rt
-
>
gc
.
finishGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
}
END_TEST
(
testWeakMap_keyDelegates
)
