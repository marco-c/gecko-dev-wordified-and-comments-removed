#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
const
int
NUM_THREADS
=
256
;
const
int
NUM_ITERATIONS
=
256
;
const
int
NUM_STRINGS
=
4
;
const
char16_t
*
const
STRINGS
[
NUM_STRINGS
]
=
{
u
"
uno
"
u
"
dos
"
u
"
tres
"
u
"
quattro
"
}
;
struct
CacheAndIndex
{
js
:
:
SharedImmutableStringsCache
*
cache
;
int
index
;
CacheAndIndex
(
js
:
:
SharedImmutableStringsCache
*
cache
int
index
)
:
cache
(
cache
)
index
(
index
)
{
}
}
;
static
void
getString
(
CacheAndIndex
*
cacheAndIndex
)
{
for
(
int
i
=
0
;
i
<
NUM_ITERATIONS
;
i
+
+
)
{
auto
str
=
STRINGS
[
cacheAndIndex
-
>
index
%
NUM_STRINGS
]
;
auto
dupe
=
js
:
:
DuplicateString
(
str
)
;
MOZ_RELEASE_ASSERT
(
dupe
)
;
auto
deduped
=
cacheAndIndex
-
>
cache
-
>
getOrCreate
(
mozilla
:
:
Move
(
dupe
)
js_strlen
(
str
)
)
;
MOZ_RELEASE_ASSERT
(
deduped
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
js_strcmp
(
str
deduped
-
>
chars
(
)
)
=
=
0
)
;
{
auto
cloned
=
deduped
-
>
clone
(
)
;
MOZ_RELEASE_ASSERT
(
deduped
-
>
chars
(
)
=
=
cloned
.
chars
(
)
)
;
}
}
js_delete
(
cacheAndIndex
)
;
}
BEGIN_TEST
(
testSharedImmutableStringsCache
)
{
auto
maybeCache
=
js
:
:
SharedImmutableStringsCache
:
:
Create
(
)
;
CHECK
(
maybeCache
.
isSome
(
)
)
;
auto
&
cache
=
*
maybeCache
;
js
:
:
Vector
<
js
:
:
Thread
>
threads
(
cx
)
;
CHECK
(
threads
.
reserve
(
NUM_THREADS
)
)
;
for
(
auto
i
:
mozilla
:
:
MakeRange
(
NUM_THREADS
)
)
{
auto
cacheAndIndex
=
js_new
<
CacheAndIndex
>
(
&
cache
i
)
;
CHECK
(
cacheAndIndex
)
;
threads
.
infallibleEmplaceBack
(
)
;
CHECK
(
threads
.
back
(
)
.
init
(
getString
cacheAndIndex
)
)
;
}
for
(
auto
&
thread
:
threads
)
thread
.
join
(
)
;
return
true
;
}
END_TEST
(
testSharedImmutableStringsCache
)
