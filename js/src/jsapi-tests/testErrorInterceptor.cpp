#
include
<
iterator
>
#
include
"
js
/
ErrorInterceptor
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
util
/
StringBuilder
.
h
"
namespace
{
MOZ_RUNINIT
static
JS
:
:
PersistentRootedString
gLatestMessage
;
struct
SimpleInterceptor
:
JSErrorInterceptor
{
virtual
void
interceptError
(
JSContext
*
cx
JS
:
:
HandleValue
val
)
override
{
js
:
:
JSStringBuilder
buffer
(
cx
)
;
if
(
!
ValueToStringBuilder
(
cx
val
buffer
)
)
{
MOZ_CRASH
(
"
Could
not
convert
to
string
buffer
"
)
;
}
gLatestMessage
=
buffer
.
finishString
(
)
;
if
(
!
gLatestMessage
)
{
MOZ_CRASH
(
"
Could
not
convert
to
string
"
)
;
}
}
}
;
bool
equalStrings
(
JSContext
*
cx
JSString
*
a
JSString
*
b
)
{
int32_t
result
=
0
;
if
(
!
JS_CompareStrings
(
cx
a
b
&
result
)
)
{
MOZ_CRASH
(
"
Could
not
compare
strings
"
)
;
}
return
result
=
=
0
;
}
}
BEGIN_TEST
(
testErrorInterceptor
)
{
const
char
*
SAMPLES
[
]
=
{
"
throw
new
Error
(
'
I
am
an
Error
'
)
\
0
"
"
throw
new
TypeError
(
'
I
am
a
TypeError
'
)
\
0
"
"
throw
new
ReferenceError
(
'
I
am
a
ReferenceError
'
)
\
0
"
"
throw
new
SyntaxError
(
'
I
am
a
SyntaxError
'
)
\
0
"
"
throw
5
\
0
"
"
foo
[
0
]
\
0
"
"
b
[
\
0
"
}
;
const
char
*
TO_STRING
[
]
=
{
"
Error
:
I
am
an
Error
\
0
"
"
TypeError
:
I
am
a
TypeError
\
0
"
"
ReferenceError
:
I
am
a
ReferenceError
\
0
"
"
SyntaxError
:
I
am
a
SyntaxError
\
0
"
"
5
\
0
"
"
ReferenceError
:
foo
is
not
defined
\
0
"
"
SyntaxError
:
expected
expression
got
end
of
script
\
0
"
}
;
static_assert
(
std
:
:
size
(
SAMPLES
)
=
=
std
:
:
size
(
TO_STRING
)
)
;
JSErrorInterceptor
*
original
=
JS_GetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
)
;
gLatestMessage
.
init
(
cx
)
;
JS_SetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
nullptr
)
;
CHECK
(
gLatestMessage
=
=
nullptr
)
;
for
(
auto
sample
:
SAMPLES
)
{
if
(
execDontReport
(
sample
__FILE__
__LINE__
)
)
{
MOZ_CRASH
(
"
This
sample
should
have
failed
"
)
;
}
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
gLatestMessage
=
=
nullptr
)
;
JS_ClearPendingException
(
cx
)
;
}
SimpleInterceptor
simpleInterceptor
;
JS_SetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
&
simpleInterceptor
)
;
CHECK_EQUAL
(
JS_GetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
)
&
simpleInterceptor
)
;
EXEC
(
"
function
bar
(
)
{
}
"
)
;
CHECK
(
gLatestMessage
=
=
nullptr
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
SAMPLES
)
;
+
+
i
)
{
if
(
execDontReport
(
SAMPLES
[
i
]
__FILE__
__LINE__
)
)
{
MOZ_CRASH
(
"
This
sample
should
have
failed
"
)
;
}
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
gLatestMessage
!
=
nullptr
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
&
gLatestMessage
-
>
asLinear
(
)
TO_STRING
[
i
]
)
)
;
JS
:
:
RootedValue
exn
(
cx
)
;
CHECK
(
JS_GetPendingException
(
cx
&
exn
)
)
;
JS_ClearPendingException
(
cx
)
;
js
:
:
JSStringBuilder
buffer
(
cx
)
;
CHECK
(
ValueToStringBuilder
(
cx
exn
buffer
)
)
;
JS
:
:
Rooted
<
JSLinearString
*
>
linear
(
cx
buffer
.
finishString
(
)
)
;
CHECK
(
equalStrings
(
cx
linear
gLatestMessage
)
)
;
gLatestMessage
=
nullptr
;
}
JS_SetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
nullptr
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
SAMPLES
)
;
+
+
i
)
{
if
(
execDontReport
(
SAMPLES
[
i
]
__FILE__
__LINE__
)
)
{
MOZ_CRASH
(
"
This
sample
should
have
failed
"
)
;
}
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
gLatestMessage
=
=
nullptr
)
;
JS
:
:
RootedValue
exn
(
cx
)
;
CHECK
(
JS_GetPendingException
(
cx
&
exn
)
)
;
JS_ClearPendingException
(
cx
)
;
js
:
:
JSStringBuilder
buffer
(
cx
)
;
CHECK
(
ValueToStringBuilder
(
cx
exn
buffer
)
)
;
JS
:
:
Rooted
<
JSLinearString
*
>
linear
(
cx
buffer
.
finishString
(
)
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
linear
TO_STRING
[
i
]
)
)
;
gLatestMessage
=
nullptr
;
}
JS_SetErrorInterceptorCallback
(
cx
-
>
runtime
(
)
original
)
;
gLatestMessage
=
nullptr
;
JS_ClearPendingException
(
cx
)
;
return
true
;
}
END_TEST
(
testErrorInterceptor
)
