#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
builtin
/
TestingFunctions
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
BEGIN_TEST
(
testSavedStacks_withNoStack
)
{
JSCompartment
*
compartment
=
js
:
:
GetContextCompartment
(
cx
)
;
compartment
-
>
setAllocationMetadataBuilder
(
&
js
:
:
SavedStacks
:
:
metadataBuilder
)
;
JS
:
:
RootedObject
obj
(
cx
js
:
:
NewDenseEmptyArray
(
cx
)
)
;
compartment
-
>
setAllocationMetadataBuilder
(
nullptr
)
;
return
true
;
}
END_TEST
(
testSavedStacks_withNoStack
)
BEGIN_TEST
(
testSavedStacks_ApiDefaultValues
)
{
js
:
:
RootedSavedFrame
savedFrame
(
cx
nullptr
)
;
JS
:
:
RootedString
str
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameSource
(
cx
savedFrame
&
str
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
str
.
get
(
)
=
=
cx
-
>
runtime
(
)
-
>
emptyString
)
;
uint32_t
line
=
123
;
result
=
JS
:
:
GetSavedFrameLine
(
cx
savedFrame
&
line
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
line
=
=
0
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
savedFrame
&
column
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
column
=
=
0
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
savedFrame
&
str
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
str
.
get
(
)
=
=
nullptr
)
;
JS
:
:
RootedObject
parent
(
cx
)
;
result
=
JS
:
:
GetSavedFrameParent
(
cx
savedFrame
&
parent
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
parent
.
get
(
)
=
=
nullptr
)
;
CHECK
(
JS
:
:
BuildStackString
(
cx
savedFrame
&
str
)
)
;
CHECK
(
str
.
get
(
)
=
=
cx
-
>
runtime
(
)
-
>
emptyString
)
;
return
true
;
}
END_TEST
(
testSavedStacks_ApiDefaultValues
)
BEGIN_TEST
(
testSavedStacks_RangeBasedForLoops
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
return
(
function
two
(
)
{
\
n
"
"
return
(
function
three
(
)
{
\
n
"
"
return
saveStack
(
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isObject
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
CHECK
(
obj
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrame
(
cx
&
obj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
js
:
:
SavedFrame
*
f
=
savedFrame
.
get
(
)
;
for
(
auto
&
frame
:
*
savedFrame
.
get
(
)
)
{
CHECK
(
&
frame
=
=
f
)
;
f
=
f
-
>
getParent
(
)
;
}
CHECK
(
f
=
=
nullptr
)
;
const
js
:
:
SavedFrame
*
cf
=
savedFrame
.
get
(
)
;
for
(
const
auto
&
frame
:
*
savedFrame
.
get
(
)
)
{
CHECK
(
&
frame
=
=
cf
)
;
cf
=
cf
-
>
getParent
(
)
;
}
CHECK
(
cf
=
=
nullptr
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
rf
(
cx
savedFrame
)
;
for
(
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
frame
:
js
:
:
SavedFrame
:
:
RootedRange
(
cx
rf
)
)
{
JS_GC
(
cx
-
>
runtime
(
)
)
;
CHECK
(
frame
=
=
rf
)
;
rf
=
rf
-
>
getParent
(
)
;
}
CHECK
(
rf
=
=
nullptr
)
;
return
true
;
}
END_TEST
(
testSavedStacks_RangeBasedForLoops
)
BEGIN_TEST
(
testSavedStacks_selfHostedFrames
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
try
{
\
n
"
"
[
1
]
.
map
(
function
two
(
)
{
\
n
"
"
throw
saveStack
(
)
;
\
n
"
"
}
)
;
\
n
"
"
}
catch
(
stack
)
{
\
n
"
"
return
stack
;
\
n
"
"
}
\
n
"
"
}
(
)
)
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isObject
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
CHECK
(
obj
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrame
(
cx
&
obj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
selfHostedFrame
(
cx
savedFrame
-
>
getParent
(
)
)
;
CHECK
(
selfHostedFrame
-
>
isSelfHosted
(
)
)
;
JS
:
:
RootedString
str
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameSource
(
cx
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
JSLinearString
*
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
lin
"
filename
.
js
"
)
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Include
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
lin
"
self
-
hosted
"
)
)
;
uint32_t
line
=
123
;
result
=
JS
:
:
GetSavedFrameLine
(
cx
selfHostedFrame
&
line
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
line
3U
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
selfHostedFrame
&
column
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
column
5U
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
lin
"
one
"
)
)
;
JS
:
:
RootedObject
parent
(
cx
)
;
result
=
JS
:
:
GetSavedFrameParent
(
cx
savedFrame
&
parent
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
parent
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
lin
"
filename
.
js
"
)
)
;
return
true
;
}
END_TEST
(
testSavedStacks_selfHostedFrames
)
BEGIN_TEST
(
test_JS_GetPendingExceptionStack
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
const
char
*
sourceText
=
"
(
function
one
(
)
{
\
n
"
"
(
function
two
(
)
{
\
n
"
"
(
function
three
(
)
{
\
n
"
"
throw
5
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
\
n
"
;
JS
:
:
RootedValue
val
(
cx
)
;
JS
:
:
CompileOptions
opts
(
cx
)
;
opts
.
setFileAndLine
(
"
filename
.
js
"
1U
)
;
JS
:
:
ContextOptionsRef
(
cx
)
.
setDontReportUncaught
(
true
)
;
JSContext
*
context
=
cx
;
auto
resetReportUncaught
=
mozilla
:
:
MakeScopeExit
(
[
=
]
(
)
{
JS
:
:
ContextOptionsRef
(
context
)
.
setDontReportUncaught
(
false
)
;
}
)
;
bool
ok
=
JS
:
:
Evaluate
(
cx
opts
sourceText
strlen
(
sourceText
)
&
val
)
;
CHECK
(
!
ok
)
;
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
val
.
isUndefined
(
)
)
;
JS
:
:
RootedObject
stack
(
cx
)
;
CHECK
(
JS
:
:
GetPendingExceptionStack
(
cx
&
stack
)
)
;
CHECK
(
stack
)
;
CHECK
(
stack
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrameStack
(
cx
&
stack
-
>
as
<
SavedFrame
>
(
)
)
;
JS_GetPendingException
(
cx
&
val
)
;
CHECK
(
val
.
isInt32
(
)
)
;
CHECK
(
val
.
toInt32
(
)
=
=
5
)
;
struct
{
uint32_t
line
;
uint32_t
column
;
const
char
*
source
;
const
char
*
functionDisplayName
;
}
expected
[
]
=
{
{
4
7
"
filename
.
js
"
"
three
"
}
{
3
15
"
filename
.
js
"
"
two
"
}
{
2
13
"
filename
.
js
"
"
one
"
}
{
1
11
"
filename
.
js
"
nullptr
}
}
;
size_t
i
=
0
;
for
(
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
frame
:
js
:
:
SavedFrame
:
:
RootedRange
(
cx
savedFrameStack
)
)
{
CHECK
(
i
<
4
)
;
uint32_t
line
=
123
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameLine
(
cx
frame
&
line
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
line
expected
[
i
]
.
line
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
frame
&
column
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
column
expected
[
i
]
.
column
)
;
JS
:
:
RootedString
str
(
cx
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
frame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
linear
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
linear
expected
[
i
]
.
source
)
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
frame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
if
(
auto
expectedName
=
expected
[
i
]
.
functionDisplayName
)
{
CHECK
(
str
)
;
linear
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
linear
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
linear
expectedName
)
)
;
}
else
{
CHECK
(
!
str
)
;
}
i
+
+
;
}
return
true
;
}
END_TEST
(
test_JS_GetPendingExceptionStack
)
