#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
builtin
/
TestingFunctions
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
SavedFrameAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
BEGIN_TEST
(
testSavedStacks_withNoStack
)
{
JS
:
:
Realm
*
realm
=
cx
-
>
realm
(
)
;
realm
-
>
setAllocationMetadataBuilder
(
&
js
:
:
SavedStacks
:
:
metadataBuilder
)
;
JS
:
:
RootedObject
obj
(
cx
js
:
:
NewDenseEmptyArray
(
cx
)
)
;
realm
-
>
setAllocationMetadataBuilder
(
nullptr
)
;
return
true
;
}
END_TEST
(
testSavedStacks_withNoStack
)
BEGIN_TEST
(
testSavedStacks_ApiDefaultValues
)
{
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrame
(
cx
nullptr
)
;
JSPrincipals
*
principals
=
cx
-
>
realm
(
)
-
>
principals
(
)
;
JS
:
:
RootedString
str
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameSource
(
cx
principals
savedFrame
&
str
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
str
.
get
(
)
=
=
cx
-
>
runtime
(
)
-
>
emptyString
)
;
uint32_t
line
=
123
;
result
=
JS
:
:
GetSavedFrameLine
(
cx
principals
savedFrame
&
line
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
line
=
=
0
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
principals
savedFrame
&
column
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
column
=
=
0
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
principals
savedFrame
&
str
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
str
.
get
(
)
=
=
nullptr
)
;
JS
:
:
RootedObject
parent
(
cx
)
;
result
=
JS
:
:
GetSavedFrameParent
(
cx
principals
savedFrame
&
parent
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
AccessDenied
)
;
CHECK
(
parent
.
get
(
)
=
=
nullptr
)
;
CHECK
(
JS
:
:
BuildStackString
(
cx
principals
savedFrame
&
str
)
)
;
CHECK
(
str
.
get
(
)
=
=
cx
-
>
runtime
(
)
-
>
emptyString
)
;
return
true
;
}
END_TEST
(
testSavedStacks_ApiDefaultValues
)
BEGIN_TEST
(
testSavedStacks_RangeBasedForLoops
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
return
(
function
two
(
)
{
\
n
"
"
return
(
function
three
(
)
{
\
n
"
"
return
saveStack
(
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isObject
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
CHECK
(
obj
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrame
(
cx
&
obj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
rf
(
cx
savedFrame
)
;
for
(
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
frame
:
js
:
:
SavedFrame
:
:
RootedRange
(
cx
rf
)
)
{
JS_GC
(
cx
)
;
CHECK
(
frame
=
=
rf
)
;
rf
=
rf
-
>
getParent
(
)
;
}
CHECK
(
rf
=
=
nullptr
)
;
static
const
char
SpiderMonkeyStack
[
]
=
"
three
filename
.
js
:
4
:
14
\
n
"
"
two
filename
.
js
:
5
:
6
\
n
"
"
one
filename
.
js
:
6
:
4
\
n
"
"
filename
.
js
:
7
:
2
\
n
"
;
static
const
char
V8Stack
[
]
=
"
at
three
(
filename
.
js
:
4
:
14
)
\
n
"
"
at
two
(
filename
.
js
:
5
:
6
)
\
n
"
"
at
one
(
filename
.
js
:
6
:
4
)
\
n
"
"
at
filename
.
js
:
7
:
2
"
;
struct
{
js
:
:
StackFormat
format
;
const
char
*
expected
;
}
expectations
[
]
=
{
{
js
:
:
StackFormat
:
:
Default
SpiderMonkeyStack
}
{
js
:
:
StackFormat
:
:
SpiderMonkey
SpiderMonkeyStack
}
{
js
:
:
StackFormat
:
:
V8
V8Stack
}
}
;
auto
CheckStacks
=
[
&
]
(
)
{
for
(
auto
&
expectation
:
expectations
)
{
JS
:
:
RootedString
str
(
cx
)
;
JSPrincipals
*
principals
=
cx
-
>
realm
(
)
-
>
principals
(
)
;
CHECK
(
JS
:
:
BuildStackString
(
cx
principals
savedFrame
&
str
0
expectation
.
format
)
)
;
JSLinearString
*
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
lin
expectation
.
expected
)
)
;
}
return
true
;
}
;
CHECK
(
CheckStacks
(
)
)
;
js
:
:
SetStackFormat
(
cx
js
:
:
StackFormat
:
:
V8
)
;
expectations
[
0
]
.
expected
=
V8Stack
;
CHECK
(
CheckStacks
(
)
)
;
return
true
;
}
END_TEST
(
testSavedStacks_RangeBasedForLoops
)
BEGIN_TEST
(
testSavedStacks_ErrorStackSpiderMonkey
)
{
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
return
(
function
two
(
)
{
\
n
"
"
return
(
function
three
(
)
{
\
n
"
"
return
new
Error
(
'
foo
'
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
.
stack
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isString
(
)
)
;
JS
:
:
RootedString
stack
(
cx
val
.
toString
(
)
)
;
static
const
char
SpiderMonkeyStack
[
]
=
"
three
filename
.
js
:
4
:
14
\
n
"
"
two
filename
.
js
:
5
:
6
\
n
"
"
one
filename
.
js
:
6
:
4
\
n
"
"
filename
.
js
:
7
:
2
\
n
"
;
JSLinearString
*
lin
=
stack
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
SpiderMonkeyStack
)
)
;
return
true
;
}
END_TEST
(
testSavedStacks_ErrorStackSpiderMonkey
)
BEGIN_TEST
(
testSavedStacks_ErrorStackV8
)
{
js
:
:
SetStackFormat
(
cx
js
:
:
StackFormat
:
:
V8
)
;
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
return
(
function
two
(
)
{
\
n
"
"
return
(
function
three
(
)
{
\
n
"
"
return
new
Error
(
'
foo
'
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
.
stack
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isString
(
)
)
;
JS
:
:
RootedString
stack
(
cx
val
.
toString
(
)
)
;
static
const
char
V8Stack
[
]
=
"
Error
:
foo
\
n
"
"
at
three
(
filename
.
js
:
4
:
14
)
\
n
"
"
at
two
(
filename
.
js
:
5
:
6
)
\
n
"
"
at
one
(
filename
.
js
:
6
:
4
)
\
n
"
"
at
filename
.
js
:
7
:
2
"
;
JSLinearString
*
lin
=
stack
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
V8Stack
)
)
;
return
true
;
}
END_TEST
(
testSavedStacks_ErrorStackV8
)
BEGIN_TEST
(
testSavedStacks_selfHostedFrames
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
JS
:
:
RootedValue
val
(
cx
)
;
CHECK
(
evaluate
(
"
(
function
one
(
)
{
\
n
"
"
try
{
\
n
"
"
[
1
]
.
map
(
function
two
(
)
{
\
n
"
"
throw
saveStack
(
)
;
\
n
"
"
}
)
;
\
n
"
"
}
catch
(
stack
)
{
\
n
"
"
return
stack
;
\
n
"
"
}
\
n
"
"
}
(
)
)
\
n
"
"
filename
.
js
"
1
&
val
)
)
;
CHECK
(
val
.
isObject
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
CHECK
(
obj
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrame
(
cx
&
obj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
selfHostedFrame
(
cx
savedFrame
-
>
getParent
(
)
)
;
CHECK
(
selfHostedFrame
-
>
isSelfHosted
(
cx
)
)
;
JSPrincipals
*
principals
=
cx
-
>
realm
(
)
-
>
principals
(
)
;
JS
:
:
RootedString
str
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameSource
(
cx
principals
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
JSLinearString
*
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
"
filename
.
js
"
)
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
principals
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Include
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
"
self
-
hosted
"
)
)
;
uint32_t
line
=
123
;
result
=
JS
:
:
GetSavedFrameLine
(
cx
principals
selfHostedFrame
&
line
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
line
3U
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
principals
selfHostedFrame
&
column
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
column
9U
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
principals
selfHostedFrame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
"
one
"
)
)
;
JS
:
:
RootedObject
parent
(
cx
)
;
result
=
JS
:
:
GetSavedFrameParent
(
cx
principals
savedFrame
&
parent
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
principals
parent
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
lin
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
lin
)
;
CHECK
(
js
:
:
StringEqualsLiteral
(
lin
"
filename
.
js
"
)
)
;
return
true
;
}
END_TEST
(
testSavedStacks_selfHostedFrames
)
BEGIN_TEST
(
test_GetPendingExceptionStack
)
{
CHECK
(
js
:
:
DefineTestingFunctions
(
cx
global
false
false
)
)
;
JSPrincipals
*
principals
=
cx
-
>
realm
(
)
-
>
principals
(
)
;
static
const
char
sourceText
[
]
=
"
(
function
one
(
)
{
\
n
"
"
(
function
two
(
)
{
\
n
"
"
(
function
three
(
)
{
\
n
"
"
throw
5
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
;
\
n
"
"
}
(
)
)
\
n
"
;
JS
:
:
CompileOptions
opts
(
cx
)
;
opts
.
setFileAndLine
(
"
filename
.
js
"
1U
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
CHECK
(
srcBuf
.
init
(
cx
sourceText
js_strlen
(
sourceText
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
;
JS
:
:
RootedValue
val
(
cx
)
;
bool
ok
=
JS
:
:
Evaluate
(
cx
opts
srcBuf
&
val
)
;
CHECK
(
!
ok
)
;
CHECK
(
JS_IsExceptionPending
(
cx
)
)
;
CHECK
(
val
.
isUndefined
(
)
)
;
JS
:
:
ExceptionStack
exnStack
(
cx
)
;
CHECK
(
JS
:
:
GetPendingExceptionStack
(
cx
&
exnStack
)
)
;
CHECK
(
exnStack
.
stack
(
)
)
;
CHECK
(
exnStack
.
stack
(
)
-
>
is
<
js
:
:
SavedFrame
>
(
)
)
;
JS
:
:
Rooted
<
js
:
:
SavedFrame
*
>
savedFrameStack
(
cx
&
exnStack
.
stack
(
)
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
CHECK
(
exnStack
.
exception
(
)
.
isInt32
(
)
)
;
CHECK
(
exnStack
.
exception
(
)
.
toInt32
(
)
=
=
5
)
;
struct
{
uint32_t
line
;
uint32_t
column
;
const
char
*
source
;
const
char
*
functionDisplayName
;
}
expected
[
]
=
{
{
4
7
"
filename
.
js
"
"
three
"
}
{
5
6
"
filename
.
js
"
"
two
"
}
{
6
4
"
filename
.
js
"
"
one
"
}
{
7
2
"
filename
.
js
"
nullptr
}
}
;
size_t
i
=
0
;
for
(
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
frame
:
js
:
:
SavedFrame
:
:
RootedRange
(
cx
savedFrameStack
)
)
{
CHECK
(
i
<
4
)
;
uint32_t
line
=
123
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameLine
(
cx
principals
frame
&
line
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
line
expected
[
i
]
.
line
)
;
uint32_t
column
=
123
;
result
=
JS
:
:
GetSavedFrameColumn
(
cx
principals
frame
&
column
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
CHECK_EQUAL
(
column
expected
[
i
]
.
column
)
;
JS
:
:
RootedString
str
(
cx
)
;
result
=
JS
:
:
GetSavedFrameSource
(
cx
principals
frame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
linear
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
linear
expected
[
i
]
.
source
)
)
;
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
principals
frame
&
str
JS
:
:
SavedFrameSelfHosted
:
:
Exclude
)
;
CHECK
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
;
if
(
auto
expectedName
=
expected
[
i
]
.
functionDisplayName
)
{
CHECK
(
str
)
;
linear
=
str
-
>
ensureLinear
(
cx
)
;
CHECK
(
linear
)
;
CHECK
(
js
:
:
StringEqualsAscii
(
linear
expectedName
)
)
;
}
else
{
CHECK
(
!
str
)
;
}
i
+
+
;
}
return
true
;
}
END_TEST
(
test_GetPendingExceptionStack
)
