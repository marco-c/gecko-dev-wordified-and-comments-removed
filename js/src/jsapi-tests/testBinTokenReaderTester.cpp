#
include
<
string
.
h
>
#
include
<
sys
/
stat
.
h
>
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
elif
defined
(
XP_UNIX
)
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
BinTokenReaderTester
.
h
"
#
include
"
frontend
/
ErrorReporter
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
using
mozilla
:
:
Maybe
;
using
Tokenizer
=
js
:
:
frontend
:
:
BinTokenReaderTester
;
using
Chars
=
js
:
:
frontend
:
:
BinTokenReaderTester
:
:
Chars
;
#
if
defined
(
XP_UNIX
)
#
include
<
sys
/
param
.
h
>
static
int
gJsDirectory
(
0
)
;
void
enterJsDirectory
(
)
{
MOZ_ASSERT
(
gJsDirectory
=
=
0
)
;
gJsDirectory
=
open
(
"
.
"
O_RDONLY
)
;
MOZ_ASSERT
(
gJsDirectory
!
=
0
"
Could
not
open
directory
'
.
'
"
)
;
const
char
*
destination
=
getenv
(
"
CPP_UNIT_TESTS_DIR_JS_SRC
"
)
;
if
(
destination
)
{
if
(
chdir
(
destination
)
=
=
-
1
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
chdir
to
%
s
"
destination
)
;
}
}
}
void
exitJsDirectory
(
)
{
MOZ_ASSERT
(
gJsDirectory
)
;
if
(
fchdir
(
gJsDirectory
)
=
=
-
1
)
{
MOZ_CRASH
(
"
Could
not
return
to
original
directory
"
)
;
}
if
(
close
(
gJsDirectory
)
!
=
0
)
{
MOZ_CRASH
(
"
Could
not
close
js
directory
"
)
;
}
gJsDirectory
=
0
;
}
#
else
char
gJsDirectory
[
MAX_PATH
]
=
{
0
}
;
void
enterJsDirectory
(
)
{
MOZ_ASSERT
(
strlen
(
gJsDirectory
)
=
=
0
)
;
auto
result
=
GetCurrentDirectory
(
MAX_PATH
gJsDirectory
)
;
if
(
result
<
=
0
)
{
MOZ_CRASH
(
"
Could
not
get
current
directory
"
)
;
}
if
(
result
>
MAX_PATH
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
get
current
directory
:
needed
%
ld
bytes
got
%
ld
\
n
"
result
MAX_PATH
)
;
}
char
destination
[
MAX_PATH
]
;
result
=
GetEnvironmentVariable
(
"
CPP_UNIT_TESTS_DIR_JS_SRC
"
destination
MAX_PATH
)
;
if
(
result
=
=
0
)
{
if
(
GetLastError
(
)
=
=
ERROR_ENVVAR_NOT_FOUND
)
{
return
;
}
else
{
MOZ_CRASH
(
"
Could
not
get
CPP_UNIT_TESTS_DIR_JS_SRC
"
)
;
}
}
if
(
result
>
MAX_PATH
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
get
CPP_UNIT_TESTS_DIR_JS_SRC
:
needed
%
ld
bytes
got
%
ld
\
n
"
result
MAX_PATH
)
;
}
if
(
SetCurrentDirectory
(
destination
)
=
=
0
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
chdir
to
%
s
"
destination
)
;
}
}
void
exitJsDirectory
(
)
{
MOZ_ASSERT
(
strlen
(
gJsDirectory
)
>
0
)
;
if
(
SetCurrentDirectory
(
gJsDirectory
)
=
=
0
)
{
MOZ_CRASH
(
"
Could
not
return
to
original
directory
"
)
;
}
gJsDirectory
[
0
]
=
0
;
}
#
endif
class
DummyErrorReporter
:
public
js
:
:
frontend
:
:
ErrorReporter
{
const
JS
:
:
CompileOptions
options_
;
public
:
explicit
DummyErrorReporter
(
JSContext
*
cx
)
:
options_
(
cx
)
{
}
virtual
const
JS
:
:
ReadOnlyCompileOptions
&
options
(
)
const
override
{
return
options_
;
}
virtual
void
lineAndColumnAt
(
size_t
offset
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
0
;
*
column
=
0
;
}
virtual
void
currentLineAndColumn
(
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
0
;
*
column
=
0
;
}
virtual
bool
isOnThisLine
(
size_t
offset
uint32_t
lineNum
bool
*
onThisLine
)
const
override
{
*
onThisLine
=
true
;
return
true
;
}
virtual
uint32_t
lineAt
(
size_t
offset
)
const
override
{
return
0
;
}
virtual
uint32_t
columnAt
(
size_t
offset
)
const
override
{
return
0
;
}
virtual
bool
hasTokenizationStarted
(
)
const
override
{
return
true
;
}
virtual
void
reportErrorNoOffsetVA
(
unsigned
errorNumber
va_list
args
)
override
{
MOZ_CRASH
(
"
shouldn
'
t
be
used
in
test
"
)
;
}
virtual
const
char
*
getFilename
(
)
const
override
{
return
"
dummy
filename
"
;
}
virtual
void
errorAtVA
(
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
override
{
MOZ_CRASH
(
"
shouldn
'
t
be
used
in
test
"
)
;
}
virtual
bool
reportExtraWarningErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
override
{
MOZ_CRASH
(
"
shouldn
'
t
be
used
in
test
"
)
;
return
false
;
}
}
;
void
readFull
(
const
char
*
path
js
:
:
Vector
<
uint8_t
>
&
buf
)
{
enterJsDirectory
(
)
;
buf
.
shrinkTo
(
0
)
;
FILE
*
in
=
fopen
(
path
"
rb
"
)
;
if
(
!
in
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
open
%
s
:
%
s
"
path
strerror
(
errno
)
)
;
}
struct
stat
info
;
if
(
stat
(
path
&
info
)
<
0
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Could
not
get
stat
on
%
s
"
path
)
;
}
if
(
!
buf
.
growBy
(
info
.
st_size
)
)
{
MOZ_CRASH
(
"
OOM
"
)
;
}
int
result
=
fread
(
buf
.
begin
(
)
1
info
.
st_size
in
)
;
if
(
fclose
(
in
)
!
=
0
)
{
MOZ_CRASH
(
"
Could
not
close
input
file
"
)
;
}
if
(
result
!
=
info
.
st_size
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Read
error
while
reading
%
s
:
expected
%
llu
bytes
got
%
llu
"
path
(
unsigned
long
long
)
info
.
st_size
(
unsigned
long
long
)
result
)
;
}
exitJsDirectory
(
)
;
}
BEGIN_TEST
(
testBinTokenReaderTesterSimpleString
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
simple
-
string
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
Chars
found
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found
"
simple
string
"
)
)
;
return
true
;
}
END_TEST
(
testBinTokenReaderTesterSimpleString
)
BEGIN_TEST
(
testBinTokenReaderTesterStringWithEscapes
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
string
-
with
-
escapes
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
Chars
found
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found
"
string
with
escapes
\
0
\
1
\
0
"
)
)
;
return
true
;
}
END_TEST
(
testBinTokenReaderTesterStringWithEscapes
)
BEGIN_TEST
(
testBinTokenReaderTesterEmptyUntaggedTuple
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
empty
-
untagged
-
tuple
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
Tokenizer
:
:
AutoTuple
guard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterUntaggedTuple
(
guard
)
.
isOk
(
)
)
;
CHECK
(
guard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterEmptyUntaggedTuple
)
BEGIN_TEST
(
testBinTokenReaderTesterTwoStringsInTuple
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
trivial
-
untagged
-
tuple
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
Tokenizer
:
:
AutoTuple
guard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterUntaggedTuple
(
guard
)
.
isOk
(
)
)
;
Chars
found_0
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_0
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_0
"
foo
"
)
)
;
Chars
found_1
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_1
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_1
"
bar
"
)
)
;
CHECK
(
guard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterTwoStringsInTuple
)
BEGIN_TEST
(
testBinTokenReaderTesterSimpleTaggedTuple
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
simple
-
tagged
-
tuple
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
js
:
:
frontend
:
:
BinKind
tag
;
Tokenizer
:
:
BinFields
fields
(
cx
)
;
Tokenizer
:
:
AutoTaggedTuple
guard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterTaggedTuple
(
tag
fields
guard
)
.
isOk
(
)
)
;
CHECK
(
tag
=
=
js
:
:
frontend
:
:
BinKind
:
:
BindingIdentifier
)
;
Chars
found_id
(
cx
)
;
const
double
EXPECTED_value
=
3
.
1415
;
CHECK
(
fields
[
0
]
=
=
js
:
:
frontend
:
:
BinField
:
:
Label
)
;
CHECK
(
fields
[
1
]
=
=
js
:
:
frontend
:
:
BinField
:
:
Value
)
;
CHECK
(
tokenizer
.
readChars
(
found_id
)
.
isOk
(
)
)
;
double
found_value
=
tokenizer
.
readDouble
(
)
.
unwrap
(
)
;
CHECK
(
EXPECTED_value
=
=
found_value
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_id
"
foo
"
)
)
;
CHECK
(
guard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterSimpleTaggedTuple
)
BEGIN_TEST
(
testBinTokenReaderTesterEmptyList
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
empty
-
list
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
uint32_t
length
;
Tokenizer
:
:
AutoList
guard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterList
(
length
guard
)
.
isOk
(
)
)
;
CHECK
(
length
=
=
0
)
;
CHECK
(
guard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterEmptyList
)
BEGIN_TEST
(
testBinTokenReaderTesterSimpleList
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
trivial
-
list
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
uint32_t
length
;
Tokenizer
:
:
AutoList
guard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterList
(
length
guard
)
.
isOk
(
)
)
;
CHECK
(
length
=
=
2
)
;
Chars
found_0
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_0
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_0
"
foo
"
)
)
;
Chars
found_1
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_1
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_1
"
bar
"
)
)
;
CHECK
(
guard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterSimpleList
)
BEGIN_TEST
(
testBinTokenReaderTesterNestedList
)
{
js
:
:
Vector
<
uint8_t
>
contents
(
cx
)
;
readFull
(
"
jsapi
-
tests
/
binast
/
tokenizer
/
tester
/
test
-
nested
-
lists
.
binjs
"
contents
)
;
DummyErrorReporter
reporter
(
cx
)
;
Tokenizer
tokenizer
(
cx
&
reporter
contents
)
;
{
uint32_t
outerLength
;
Tokenizer
:
:
AutoList
outerGuard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterList
(
outerLength
outerGuard
)
.
isOk
(
)
)
;
CHECK_EQUAL
(
outerLength
(
uint32_t
)
1
)
;
{
uint32_t
innerLength
;
Tokenizer
:
:
AutoList
innerGuard
(
tokenizer
)
;
CHECK
(
tokenizer
.
enterList
(
innerLength
innerGuard
)
.
isOk
(
)
)
;
CHECK_EQUAL
(
innerLength
(
uint32_t
)
2
)
;
Chars
found_0
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_0
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_0
"
foo
"
)
)
;
Chars
found_1
(
cx
)
;
CHECK
(
tokenizer
.
readChars
(
found_1
)
.
isOk
(
)
)
;
CHECK
(
Tokenizer
:
:
equals
(
found_1
"
bar
"
)
)
;
CHECK
(
innerGuard
.
done
(
)
.
isOk
(
)
)
;
}
CHECK
(
outerGuard
.
done
(
)
.
isOk
(
)
)
;
}
return
true
;
}
END_TEST
(
testBinTokenReaderTesterNestedList
)
