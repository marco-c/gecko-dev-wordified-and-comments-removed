#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
vm
/
Compression
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Utf8Unit
;
struct
JSContext
;
class
JSString
;
template
<
typename
Unit
>
using
Source
=
js
:
:
UniquePtr
<
Unit
[
]
JS
:
:
FreePolicy
>
;
constexpr
size_t
ChunkSize
=
js
:
:
Compressor
:
:
CHUNK_SIZE
;
constexpr
size_t
MinimumCompressibleLength
=
js
:
:
ScriptSource
:
:
MinimumCompressibleLength
;
constexpr
char
FillerWhitespace
=
'
\
n
'
;
template
<
typename
Unit
>
static
Source
<
Unit
>
MakeSourceAllWhitespace
(
JSContext
*
cx
size_t
len
)
{
static_assert
(
ChunkSize
%
sizeof
(
Unit
)
=
=
0
"
chunk
size
presumed
to
be
a
multiple
of
char
size
"
)
;
Source
<
Unit
>
source
(
reinterpret_cast
<
Unit
*
>
(
JS_malloc
(
cx
len
*
sizeof
(
Unit
)
)
)
)
;
if
(
source
)
{
std
:
:
uninitialized_fill_n
(
source
.
get
(
)
len
FillerWhitespace
)
;
}
return
source
;
}
static
bool
Evaluate
(
JSContext
*
cx
const
JS
:
:
CompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
sourceText
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
dummy
(
cx
)
;
return
JS
:
:
Evaluate
(
cx
options
sourceText
&
dummy
)
;
}
static
bool
Evaluate
(
JSContext
*
cx
const
JS
:
:
CompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
sourceText
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
dummy
(
cx
)
;
return
JS
:
:
EvaluateDontInflate
(
cx
options
sourceText
&
dummy
)
;
}
template
<
typename
Unit
>
static
JSFunction
*
EvaluateChars
(
JSContext
*
cx
Source
<
Unit
>
chars
size_t
len
char
functionName
const
char
*
func
)
{
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setFileAndLine
(
func
1
)
;
JS
:
:
SourceText
<
Unit
>
sourceText
;
if
(
!
sourceText
.
init
(
cx
std
:
:
move
(
chars
)
len
)
)
{
return
nullptr
;
}
if
(
!
Evaluate
(
cx
options
sourceText
)
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
cx
)
;
const
char16_t
name
[
]
=
{
char16_t
(
functionName
)
}
;
JS
:
:
SourceText
<
char16_t
>
srcbuf
;
if
(
!
srcbuf
.
init
(
cx
name
ArrayLength
(
name
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
{
return
nullptr
;
}
if
(
!
JS
:
:
Evaluate
(
cx
options
srcbuf
&
rval
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
rval
.
isObject
(
)
)
;
return
JS_ValueToFunction
(
cx
rval
)
;
}
static
void
CompressSourceSync
(
JS
:
:
Handle
<
JSFunction
*
>
fun
JSContext
*
cx
)
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
cx
JSFunction
:
:
getOrCreateScript
(
cx
fun
)
)
;
MOZ_RELEASE_ASSERT
(
script
)
;
MOZ_RELEASE_ASSERT
(
script
-
>
scriptSource
(
)
-
>
hasSourceText
(
)
)
;
MOZ_RELEASE_ASSERT
(
js
:
:
SynchronouslyCompressSource
(
cx
script
)
)
;
MOZ_RELEASE_ASSERT
(
script
-
>
scriptSource
(
)
-
>
hasCompressedSource
(
)
)
;
}
static
constexpr
char
FunctionStart
[
]
=
"
function
(
)
{
"
;
constexpr
size_t
FunctionStartLength
=
ArrayLength
(
FunctionStart
)
-
1
;
constexpr
size_t
FunctionNameOffset
=
9
;
static_assert
(
FunctionStart
[
FunctionNameOffset
]
=
=
'
'
"
offset
must
correctly
point
at
the
function
name
location
"
)
;
static
constexpr
char
FunctionEnd
[
]
=
"
return
42
;
}
"
;
constexpr
size_t
FunctionEndLength
=
ArrayLength
(
FunctionEnd
)
-
1
;
template
<
typename
Unit
>
static
void
WriteFunctionOfSizeAtOffset
(
Source
<
Unit
>
&
source
size_t
usableSourceLen
char
functionName
size_t
functionLength
size_t
offset
)
{
MOZ_RELEASE_ASSERT
(
functionLength
>
=
MinimumCompressibleLength
"
function
must
be
a
certain
size
to
be
compressed
"
)
;
MOZ_RELEASE_ASSERT
(
offset
<
=
usableSourceLen
"
offset
must
not
exceed
usable
source
"
)
;
MOZ_RELEASE_ASSERT
(
functionLength
<
=
usableSourceLen
"
function
must
fit
in
usable
source
"
)
;
MOZ_RELEASE_ASSERT
(
offset
<
=
usableSourceLen
-
functionLength
"
function
must
not
extend
past
usable
source
"
)
;
auto
TransformToUnit
=
[
]
(
char
c
)
{
return
Unit
(
c
)
;
}
;
std
:
:
transform
(
FunctionStart
FunctionStart
+
FunctionStartLength
&
source
[
offset
]
TransformToUnit
)
;
source
[
offset
+
FunctionNameOffset
]
=
Unit
(
functionName
)
;
std
:
:
transform
(
FunctionEnd
FunctionEnd
+
FunctionEndLength
&
source
[
offset
+
functionLength
-
FunctionEndLength
]
TransformToUnit
)
;
}
static
JSString
*
DecompressSource
(
JSContext
*
cx
JS
:
:
Handle
<
JSFunction
*
>
fun
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
fval
(
cx
JS
:
:
ObjectValue
(
*
JS_GetFunctionObject
(
fun
)
)
)
;
return
JS
:
:
ToString
(
cx
fval
)
;
}
static
bool
IsExpectedFunctionString
(
JS
:
:
Handle
<
JSString
*
>
str
char
functionName
JSContext
*
cx
)
{
JSLinearString
*
lstr
=
JS_EnsureLinearString
(
cx
str
)
;
MOZ_RELEASE_ASSERT
(
lstr
)
;
size_t
len
=
JS_GetStringLength
(
str
)
;
if
(
len
<
FunctionStartLength
|
|
len
<
FunctionEndLength
)
{
return
false
;
}
JS
:
:
AutoAssertNoGC
nogc
(
cx
)
;
auto
CheckContents
=
[
functionName
len
]
(
const
auto
*
chars
)
{
return
std
:
:
equal
(
chars
chars
+
FunctionNameOffset
FunctionStart
)
&
&
chars
[
FunctionNameOffset
]
=
=
functionName
&
&
std
:
:
equal
(
chars
+
FunctionNameOffset
+
1
chars
+
FunctionStartLength
FunctionStart
+
FunctionNameOffset
+
1
)
&
&
std
:
:
all_of
(
chars
+
FunctionStartLength
chars
+
len
-
FunctionEndLength
[
]
(
auto
c
)
{
return
c
=
=
FillerWhitespace
;
}
)
&
&
std
:
:
equal
(
chars
+
len
-
FunctionEndLength
chars
+
len
FunctionEnd
)
;
}
;
bool
hasExpectedContents
;
if
(
JS_StringHasLatin1Chars
(
str
)
)
{
const
JS
:
:
Latin1Char
*
chars
=
JS_GetLatin1LinearStringChars
(
nogc
lstr
)
;
hasExpectedContents
=
CheckContents
(
chars
)
;
}
else
{
const
char16_t
*
chars
=
JS_GetTwoByteLinearStringChars
(
nogc
lstr
)
;
hasExpectedContents
=
CheckContents
(
chars
)
;
}
return
hasExpectedContents
;
}
BEGIN_TEST
(
testScriptSourceCompression_inOneChunk
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
MinimumCompressibleLength
+
55
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
char
FunctionName
=
'
a
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
MinimumCompressibleLength
len
-
MinimumCompressibleLength
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_inOneChunk
)
BEGIN_TEST
(
testScriptSourceCompression_endsAtBoundaryInOneChunk
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
ChunkSize
/
sizeof
(
Unit
)
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
char
FunctionName
=
'
c
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
MinimumCompressibleLength
len
-
MinimumCompressibleLength
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_endsAtBoundaryInOneChunk
)
BEGIN_TEST
(
testScriptSourceCompression_isExactChunk
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
ChunkSize
/
sizeof
(
Unit
)
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
char
FunctionName
=
'
e
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
len
0
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_isExactChunk
)
BEGIN_TEST
(
testScriptSourceCompression_crossesChunkBoundary
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
ChunkSize
/
sizeof
(
Unit
)
+
293
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
size_t
FunctionSize
=
177
+
ChunkSize
/
sizeof
(
Unit
)
;
constexpr
char
FunctionName
=
'
g
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
FunctionSize
37
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_crossesChunkBoundary
)
BEGIN_TEST
(
testScriptSourceCompression_crossesChunkBoundary_endsAtBoundary
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
(
2
*
ChunkSize
)
/
sizeof
(
Unit
)
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
size_t
FunctionSize
=
1
+
ChunkSize
/
sizeof
(
Unit
)
;
constexpr
char
FunctionName
=
'
i
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
FunctionSize
len
-
FunctionSize
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_crossesChunkBoundary_endsAtBoundary
)
BEGIN_TEST
(
testScriptSourceCompression_containsWholeChunk
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
(
2
*
ChunkSize
)
/
sizeof
(
Unit
)
+
17
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
size_t
FunctionSize
=
2
+
ChunkSize
/
sizeof
(
Unit
)
;
constexpr
char
FunctionName
=
'
k
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
FunctionSize
ChunkSize
/
sizeof
(
Unit
)
-
1
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_containsWholeChunk
)
BEGIN_TEST
(
testScriptSourceCompression_containsWholeChunk_endsAtBoundary
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
(
3
*
ChunkSize
)
/
sizeof
(
Unit
)
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
size_t
FunctionSize
=
1
+
(
2
*
ChunkSize
)
/
sizeof
(
Unit
)
;
constexpr
char
FunctionName
=
'
m
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
FunctionSize
ChunkSize
/
sizeof
(
Unit
)
-
1
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_containsWholeChunk_endsAtBoundary
)
BEGIN_TEST
(
testScriptSourceCompression_spansMultipleMiddleChunks
)
{
CHECK
(
run
<
char16_t
>
(
)
)
;
CHECK
(
run
<
Utf8Unit
>
(
)
)
;
return
true
;
}
template
<
typename
Unit
>
bool
run
(
)
{
constexpr
size_t
len
=
(
4
*
ChunkSize
)
/
sizeof
(
Unit
)
;
auto
source
=
MakeSourceAllWhitespace
<
Unit
>
(
cx
len
)
;
CHECK
(
source
)
;
constexpr
size_t
FunctionSize
=
2
+
(
2
*
ChunkSize
)
/
sizeof
(
Unit
)
;
constexpr
char
FunctionName
=
'
o
'
+
sizeof
(
Unit
)
;
WriteFunctionOfSizeAtOffset
(
source
len
FunctionName
FunctionSize
ChunkSize
/
sizeof
(
Unit
)
-
1
)
;
JS
:
:
Rooted
<
JSFunction
*
>
fun
(
cx
)
;
fun
=
EvaluateChars
(
cx
std
:
:
move
(
source
)
len
FunctionName
__FUNCTION__
)
;
CHECK
(
fun
)
;
CompressSourceSync
(
fun
cx
)
;
JS
:
:
Rooted
<
JSString
*
>
str
(
cx
DecompressSource
(
cx
fun
)
)
;
CHECK
(
str
)
;
CHECK
(
IsExpectedFunctionString
(
str
FunctionName
cx
)
)
;
return
true
;
}
END_TEST
(
testScriptSourceCompression_spansMultipleMiddleChunks
)
