#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
<
iterator
>
#
include
"
jit
/
ABIFunctions
.
h
"
#
include
"
jit
/
IonAnalysis
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
jit
/
ValueNumbering
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
jsapi
-
tests
/
testsJit
.
h
"
#
include
"
jit
/
ABIFunctionList
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
VMFunctionList
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
#
define
ABIFUN_TO_ALLFUN
(
Fun
)
(
#
Fun
decltype
(
&
:
:
Fun
)
)
#
define
ABIFUN_AND_SIG_TO_ALLFUN
(
Fun
Sig
)
(
#
Fun
"
as
"
#
Sig
Sig
)
#
define
ABISIG_TO_ALLFUN
(
Sig
)
(
"
(
none
)
as
"
#
Sig
Sig
)
#
define
VMFUN_TO_ALLFUN
(
Name
Fun
Pop
.
.
.
)
(
#
Fun
decltype
(
&
:
:
Fun
)
)
#
define
APPLY
(
A
B
)
A
B
#
define
ALL_FUNCTIONS
(
PREFIX
)
\
ABIFUNCTION_LIST
(
PREFIX
#
#
_ABIFUN_TO_ALLFUN
)
\
ABIFUNCTION_AND_TYPE_LIST
(
PREFIX
#
#
_ABIFUN_AND_SIG_TO_ALLFUN
)
\
ABIFUNCTIONSIG_LIST
(
PREFIX
#
#
_ABISIG_TO_ALLFUN
)
\
VMFUNCTION_LIST
(
PREFIX
#
#
_VMFUN_TO_ALLFUN
)
template
<
typename
T
>
constexpr
size_t
ActualSizeOf
(
)
{
struct
Wrapper
{
T
_unused
;
}
;
return
sizeof
(
Wrapper
)
;
}
template
<
typename
T
>
constexpr
size_t
ActualAlignOf
(
)
{
struct
Wrapper
{
T
_unused
;
}
;
return
alignof
(
Wrapper
)
;
}
template
<
typename
T
>
using
IntTypeOf_t
=
typename
mozilla
:
:
UnsignedStdintTypeForSize
<
ActualSizeOf
<
T
>
(
)
>
:
:
Type
;
template
<
typename
Before
typename
After
>
struct
Concat
;
template
<
typename
Int
Int
.
.
.
Before
Int
.
.
.
After
>
struct
Concat
<
std
:
:
integer_sequence
<
Int
Before
.
.
.
>
std
:
:
integer_sequence
<
Int
After
.
.
.
>
>
{
using
type
=
std
:
:
integer_sequence
<
Int
Before
.
.
.
After
.
.
.
>
;
}
;
template
<
typename
Before
typename
After
>
using
Concat_t
=
typename
Concat
<
Before
After
>
:
:
type
;
static_assert
(
std
:
:
is_same_v
<
Concat_t
<
std
:
:
integer_sequence
<
uint8_t
1
2
>
std
:
:
integer_sequence
<
uint8_t
3
4
>
>
std
:
:
integer_sequence
<
uint8_t
1
2
3
4
>
>
)
;
template
<
size_t
N
uint8_t
Value
>
constexpr
auto
CstSeq
(
)
{
if
constexpr
(
N
=
=
0
)
{
return
std
:
:
integer_sequence
<
uint8_t
>
{
}
;
}
else
{
return
Concat_t
<
std
:
:
integer_sequence
<
uint8_t
Value
>
decltype
(
CstSeq
<
N
-
1
Value
>
(
)
)
>
{
}
;
}
}
template
<
size_t
N
uint8_t
Value
>
using
CstSeq_t
=
decltype
(
CstSeq
<
N
Value
>
(
)
)
;
static_assert
(
std
:
:
is_same_v
<
CstSeq_t
<
4
2
>
std
:
:
integer_sequence
<
uint8_t
2
2
2
2
>
>
)
;
constexpr
size_t
PadBytes
(
size_t
size
size_t
align
)
{
return
(
align
-
(
size
%
align
)
)
%
align
;
}
constexpr
size_t
AtLeastSize
(
)
{
return
sizeof
(
uintptr_t
)
;
}
template
<
typename
Type
>
constexpr
size_t
BackPadBytes
(
)
{
return
std
:
:
max
(
AtLeastSize
(
)
ActualSizeOf
<
Type
>
(
)
)
-
ActualSizeOf
<
Type
>
(
)
;
}
template
<
typename
Type
>
constexpr
size_t
PadSize
(
size_t
size
)
{
return
PadBytes
(
size
ActualAlignOf
<
Type
>
(
)
)
+
ActualSizeOf
<
Type
>
(
)
+
BackPadBytes
<
Type
>
(
)
;
}
template
<
size_t
Align
size_t
CurrSize
>
using
PadSeq_t
=
decltype
(
CstSeq
<
PadBytes
(
CurrSize
Align
)
0
>
(
)
)
;
static_assert
(
std
:
:
is_same_v
<
PadSeq_t
<
4
0
>
std
:
:
integer_sequence
<
uint8_t
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
PadSeq_t
<
4
3
>
std
:
:
integer_sequence
<
uint8_t
0
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
PadSeq_t
<
4
2
>
std
:
:
integer_sequence
<
uint8_t
0
0
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
PadSeq_t
<
4
1
>
std
:
:
integer_sequence
<
uint8_t
0
0
0
>
>
)
;
template
<
size_t
N
uint64_t
Value
uint8_t
.
.
.
Rest
>
constexpr
auto
FillLESeq
(
)
{
if
constexpr
(
N
=
=
0
)
{
return
std
:
:
integer_sequence
<
uint8_t
Rest
.
.
.
>
{
}
;
}
else
{
return
FillLESeq
<
N
-
1
(
Value
>
>
8
)
Rest
.
.
.
uint8_t
(
Value
&
0xff
)
>
(
)
;
}
}
template
<
size_t
N
uint64_t
Value
>
using
FillSeq_t
=
decltype
(
FillLESeq
<
N
Value
>
(
)
)
;
static_assert
(
std
:
:
is_same_v
<
FillSeq_t
<
4
2
>
std
:
:
integer_sequence
<
uint8_t
2
0
0
0
>
>
)
;
template
<
typename
.
.
.
Args
>
using
ArgsIndexes_t
=
std
:
:
make_integer_sequence
<
uint64_t
uint64_t
(
sizeof
.
.
.
(
Args
)
)
>
;
static_assert
(
std
:
:
is_same_v
<
ArgsIndexes_t
<
uint8_t
uint64_t
>
std
:
:
integer_sequence
<
uint64_t
0
1
>
>
)
;
template
<
size_t
Bit
typename
IntSeq
>
struct
ExtractBit
;
template
<
size_t
Bit
uint64_t
.
.
.
Values
>
struct
ExtractBit
<
Bit
std
:
:
integer_sequence
<
uint64_t
Values
.
.
.
>
>
{
using
type
=
std
:
:
integer_sequence
<
uint64_t
(
Values
>
>
Bit
)
&
1
.
.
.
>
;
}
;
template
<
size_t
Bit
typename
.
.
.
Args
>
using
ArgsBitOfIndexes_t
=
typename
ExtractBit
<
Bit
ArgsIndexes_t
<
Args
.
.
.
>
>
:
:
type
;
static_assert
(
std
:
:
is_same_v
<
ArgsBitOfIndexes_t
<
0
int
int
int
int
>
std
:
:
integer_sequence
<
uint64_t
0
1
0
1
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
ArgsBitOfIndexes_t
<
1
int
int
int
int
>
std
:
:
integer_sequence
<
uint64_t
0
0
1
1
>
>
)
;
template
<
uint64_t
Size
typename
.
.
.
Args
>
struct
ArgsOffsets
;
template
<
uint64_t
Size
>
struct
ArgsOffsets
<
Size
>
{
using
type
=
std
:
:
integer_sequence
<
uint64_t
>
;
}
;
template
<
uint64_t
Size
typename
Arg
typename
.
.
.
Args
>
struct
ArgsOffsets
<
Size
Arg
Args
.
.
.
>
{
using
type
=
Concat_t
<
std
:
:
integer_sequence
<
uint64_t
Size
+
PadBytes
(
Size
ActualAlignOf
<
Arg
>
(
)
)
>
typename
ArgsOffsets
<
Size
+
PadSize
<
Arg
>
(
Size
)
Args
.
.
.
>
:
:
type
>
;
}
;
template
<
uint64_t
Size
typename
.
.
.
Args
>
using
ArgsOffsets_t
=
typename
ArgsOffsets
<
Size
Args
.
.
.
>
:
:
type
;
static_assert
(
ActualAlignOf
<
uint64_t
>
(
)
!
=
8
|
|
std
:
:
is_same_v
<
ArgsOffsets_t
<
0
uint8_t
uint64_t
bool
>
std
:
:
integer_sequence
<
uint64_t
0
8
16
>
>
)
;
static_assert
(
ActualAlignOf
<
uint64_t
>
(
)
!
=
4
|
|
std
:
:
is_same_v
<
ArgsOffsets_t
<
0
uint8_t
uint64_t
bool
>
std
:
:
integer_sequence
<
uint64_t
0
4
12
>
>
)
;
template
<
typename
.
.
.
Args
>
using
ArgsSizes_t
=
std
:
:
integer_sequence
<
uint64_t
ActualSizeOf
<
Args
>
(
)
.
.
.
>
;
template
<
typename
Type
>
constexpr
uint64_t
FillBits
(
)
{
constexpr
uint64_t
topBit
=
uint64_t
(
1
)
<
<
(
(
8
*
ActualSizeOf
<
Type
>
(
)
)
-
1
)
;
if
constexpr
(
std
:
:
is_same_v
<
Type
bool
>
)
{
return
uint64_t
(
1
)
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
Type
double
>
|
|
std
:
:
is_same_v
<
Type
float
>
)
{
constexpr
uint64_t
lowExpBit
=
uint64_t
(
1
)
<
<
mozilla
:
:
FloatingPoint
<
Type
>
:
:
kExponentShift
;
return
uint64_t
(
(
topBit
-
1
)
+
topBit
-
lowExpBit
)
;
}
else
{
return
uint64_t
(
(
topBit
-
1
)
+
topBit
)
;
}
}
template
<
typename
.
.
.
Args
>
using
ArgsFillBits_t
=
std
:
:
integer_sequence
<
uint64_t
FillBits
<
Args
>
(
)
.
.
.
>
;
template
<
typename
Type
>
constexpr
ABIType
TypeToABIType
(
)
{
if
constexpr
(
std
:
:
is_same_v
<
Type
float
>
)
{
return
ABIType
:
:
Float32
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
Type
double
>
)
{
return
ABIType
:
:
Float64
;
}
else
{
return
ABIType
:
:
General
;
}
}
template
<
ABIType
.
.
.
Val
>
class
ABITypeSequence
{
}
;
template
<
typename
.
.
.
Args
>
using
ArgsABITypes_t
=
ABITypeSequence
<
TypeToABIType
<
Args
>
(
)
.
.
.
>
;
template
<
typename
Buffer
typename
Values
typename
.
.
.
Args
>
struct
ArgsBuffer
;
template
<
uint8_t
.
.
.
Buffer
typename
Arg
typename
.
.
.
Args
uint64_t
Val
uint64_t
.
.
.
Values
>
struct
ArgsBuffer
<
std
:
:
integer_sequence
<
uint8_t
Buffer
.
.
.
>
std
:
:
integer_sequence
<
uint64_t
Val
Values
.
.
.
>
Arg
Args
.
.
.
>
{
using
type
=
typename
ArgsBuffer
<
Concat_t
<
std
:
:
integer_sequence
<
uint8_t
Buffer
.
.
.
>
Concat_t
<
PadSeq_t
<
ActualAlignOf
<
Arg
>
(
)
sizeof
.
.
.
(
Buffer
)
>
Concat_t
<
FillSeq_t
<
ActualSizeOf
<
Arg
>
(
)
Val
>
CstSeq_t
<
BackPadBytes
<
Arg
>
(
)
0x55
>
>
>
>
std
:
:
integer_sequence
<
uint64_t
Values
.
.
.
>
Args
.
.
.
>
:
:
type
;
}
;
template
<
typename
Buffer
>
struct
ArgsBuffer
<
Buffer
std
:
:
integer_sequence
<
uint64_t
>
>
{
using
type
=
Buffer
;
}
;
template
<
typename
Values
typename
.
.
.
Args
>
using
ArgsBuffer_t
=
typename
ArgsBuffer
<
std
:
:
integer_sequence
<
uint8_t
>
Values
Args
.
.
.
>
:
:
type
;
#
ifdef
JS_64BIT
static_assert
(
sizeof
(
uintptr_t
)
=
=
8
)
;
static_assert
(
std
:
:
is_same_v
<
ArgsBuffer_t
<
std
:
:
integer_sequence
<
uint64_t
42
51
>
uint64_t
bool
>
std
:
:
integer_sequence
<
uint8_t
42
0
0
0
0
0
0
0
51
0x55
0x55
0x55
0x55
0x55
0x55
0x55
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
ArgsBuffer_t
<
std
:
:
integer_sequence
<
uint64_t
0xffffffff
0xffffffff
>
uint8_t
uint16_t
>
std
:
:
integer_sequence
<
uint8_t
0xff
0x55
0x55
0x55
0x55
0x55
0x55
0x55
0xff
0xff
0x55
0x55
0x55
0x55
0x55
0x55
>
>
)
;
#
else
static_assert
(
sizeof
(
uintptr_t
)
=
=
4
)
;
static_assert
(
std
:
:
is_same_v
<
ArgsBuffer_t
<
std
:
:
integer_sequence
<
uint64_t
42
51
>
uint64_t
bool
>
std
:
:
integer_sequence
<
uint8_t
42
0
0
0
0
0
0
0
51
0x55
0x55
0x55
>
>
)
;
static_assert
(
std
:
:
is_same_v
<
ArgsBuffer_t
<
std
:
:
integer_sequence
<
uint64_t
0xffffffff
0xffffffff
>
uint8_t
uint16_t
>
std
:
:
integer_sequence
<
uint8_t
0xff
0x55
0x55
0x55
0xff
0xff
0x55
0x55
>
>
)
;
#
endif
template
<
typename
.
.
.
Args
>
constexpr
bool
AnyBool_v
=
(
std
:
:
is_same_v
<
Args
bool
>
|
|
.
.
.
)
;
template
<
typename
Seq
>
struct
InstanceSeq
;
template
<
typename
Int
Int
.
.
.
Values
>
struct
InstanceSeq
<
std
:
:
integer_sequence
<
Int
Values
.
.
.
>
>
{
static
constexpr
Int
table
[
sizeof
.
.
.
(
Values
)
]
=
{
Values
.
.
.
}
;
static
constexpr
size_t
size
=
sizeof
.
.
.
(
Values
)
;
}
;
template
<
typename
.
.
.
Args
>
using
TestArgsPositions
=
InstanceSeq
<
ArgsBuffer_t
<
ArgsIndexes_t
<
Args
.
.
.
>
Args
.
.
.
>
>
;
template
<
size_t
Bit
typename
.
.
.
Args
>
using
TestArgsBitOfPositions
=
InstanceSeq
<
ArgsBuffer_t
<
ArgsBitOfIndexes_t
<
Bit
Args
.
.
.
>
Args
.
.
.
>
>
;
template
<
typename
.
.
.
Args
>
using
TestArgsSizes
=
InstanceSeq
<
ArgsBuffer_t
<
ArgsSizes_t
<
Args
.
.
.
>
Args
.
.
.
>
>
;
template
<
typename
.
.
.
Args
>
using
TestArgsFillBits
=
InstanceSeq
<
ArgsBuffer_t
<
ArgsFillBits_t
<
Args
.
.
.
>
Args
.
.
.
>
>
;
template
<
typename
Type
>
IntTypeOf_t
<
Type
>
ConvertToInt
(
Type
v
)
{
auto
address
=
reinterpret_cast
<
const
void
*
>
(
&
v
)
;
static_assert
(
ActualSizeOf
<
Type
>
(
)
=
=
ActualSizeOf
<
IntTypeOf_t
<
Type
>
>
(
)
)
;
if
constexpr
(
std
:
:
is_reference_v
<
Type
>
)
{
return
reinterpret_cast
<
const
IntTypeOf_t
<
Type
>
>
(
address
)
;
}
else
{
return
*
reinterpret_cast
<
const
IntTypeOf_t
<
Type
>
*
>
(
address
)
;
}
}
#
if
defined
(
__clang__
)
&
&
defined
(
__has_attribute
)
&
&
\
__has_attribute
(
no_sanitize
)
#
define
NO_ARGS_CHECKS
__attribute__
(
(
no_sanitize
(
"
enum
"
)
)
)
#
else
#
define
NO_ARGS_CHECKS
#
endif
template
<
typename
.
.
.
Args
typename
Int
Int
.
.
.
Val
>
NO_ARGS_CHECKS
bool
CheckArgsEqual
(
JSAPIRuntimeTest
*
instance
int
lineno
std
:
:
integer_sequence
<
Int
Val
.
.
.
>
Args
.
.
.
args
)
{
return
(
instance
-
>
checkEqual
(
ConvertToInt
<
Args
>
(
args
)
IntTypeOf_t
<
Args
>
(
Val
)
"
ConvertToInt
<
Args
>
(
args
)
"
"
IntTypeOf_t
<
Args
>
(
Val
)
"
__FILE__
lineno
)
&
&
.
.
.
)
;
}
template
<
uint64_t
.
.
.
Off
ABIType
.
.
.
Type
>
static
void
passABIArgs
(
MacroAssembler
&
masm
Register
base
std
:
:
integer_sequence
<
uint64_t
Off
.
.
.
>
ABITypeSequence
<
Type
.
.
.
>
)
{
(
masm
.
passABIArg
(
MoveOperand
(
base
size_t
(
Off
)
)
Type
)
.
.
.
)
;
}
template
<
typename
Type
>
struct
DefineCheckArgs
;
template
<
typename
Res
typename
.
.
.
Args
>
struct
DefineCheckArgs
<
Res
(
*
)
(
Args
.
.
.
)
>
{
void
set_instance
(
JSAPIRuntimeTest
*
instance
bool
*
reportTo
)
{
MOZ_ASSERT
(
(
!
instance_
)
!
=
(
!
instance
)
)
;
instance_
=
instance
;
MOZ_ASSERT
(
(
!
reportTo_
)
!
=
(
!
reportTo
)
)
;
reportTo_
=
reportTo
;
}
static
void
report
(
bool
value
)
{
*
reportTo_
=
*
reportTo_
&
&
value
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsPositions
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Indexes
=
std
:
:
index_sequence_for
<
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Indexes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsBitOfPositions0
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Indexes
=
ArgsBitOfIndexes_t
<
0
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Indexes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsBitOfPositions1
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Indexes
=
ArgsBitOfIndexes_t
<
1
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Indexes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsBitOfPositions2
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Indexes
=
ArgsBitOfIndexes_t
<
2
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Indexes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsBitOfPositions3
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Indexes
=
ArgsBitOfIndexes_t
<
3
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Indexes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsSizes
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
Sizes
=
ArgsSizes_t
<
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
Sizes
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
static
NO_ARGS_CHECKS
Res
CheckArgsFillBits
(
Args
.
.
.
args
)
{
AutoUnsafeCallWithABI
unsafe
;
using
FillBits
=
ArgsFillBits_t
<
Args
.
.
.
>
;
report
(
CheckArgsEqual
<
Args
.
.
.
>
(
instance_
__LINE__
FillBits
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
return
Res
(
)
;
}
using
FunType
=
Res
(
*
)
(
Args
.
.
.
)
;
struct
Test
{
const
uint8_t
*
buffer
;
const
size_t
size
;
const
FunType
fun
;
}
;
void
generateCalls
(
MacroAssembler
&
masm
Register
base
Register
setup
)
{
using
ArgsPositions
=
TestArgsPositions
<
Args
.
.
.
>
;
using
ArgsBitOfPositions0
=
TestArgsBitOfPositions
<
0
Args
.
.
.
>
;
using
ArgsBitOfPositions1
=
TestArgsBitOfPositions
<
1
Args
.
.
.
>
;
using
ArgsBitOfPositions2
=
TestArgsBitOfPositions
<
2
Args
.
.
.
>
;
using
ArgsBitOfPositions3
=
TestArgsBitOfPositions
<
3
Args
.
.
.
>
;
using
ArgsSizes
=
TestArgsSizes
<
Args
.
.
.
>
;
using
ArgsFillBits
=
TestArgsFillBits
<
Args
.
.
.
>
;
static
const
Test
testsWithoutBoolArgs
[
3
]
=
{
{
ArgsPositions
:
:
table
ArgsPositions
:
:
size
CheckArgsPositions
}
{
ArgsSizes
:
:
table
ArgsSizes
:
:
size
CheckArgsSizes
}
{
ArgsFillBits
:
:
table
ArgsFillBits
:
:
size
CheckArgsFillBits
}
}
;
static
const
Test
testsWithBoolArgs
[
6
]
=
{
{
ArgsBitOfPositions0
:
:
table
ArgsBitOfPositions0
:
:
size
CheckArgsBitOfPositions0
}
{
ArgsBitOfPositions1
:
:
table
ArgsBitOfPositions1
:
:
size
CheckArgsBitOfPositions1
}
{
ArgsBitOfPositions2
:
:
table
ArgsBitOfPositions2
:
:
size
CheckArgsBitOfPositions2
}
{
ArgsBitOfPositions3
:
:
table
ArgsBitOfPositions3
:
:
size
CheckArgsBitOfPositions3
}
{
ArgsSizes
:
:
table
ArgsSizes
:
:
size
CheckArgsSizes
}
{
ArgsFillBits
:
:
table
ArgsFillBits
:
:
size
CheckArgsFillBits
}
}
;
const
Test
*
tests
=
testsWithoutBoolArgs
;
size_t
numTests
=
std
:
:
size
(
testsWithoutBoolArgs
)
;
if
(
AnyBool_v
<
Args
.
.
.
>
)
{
tests
=
testsWithBoolArgs
;
numTests
=
std
:
:
size
(
testsWithBoolArgs
)
;
}
for
(
size_t
i
=
0
;
i
<
numTests
;
i
+
+
)
{
const
Test
&
test
=
tests
[
i
]
;
masm
.
movePtr
(
ImmPtr
(
test
.
buffer
)
base
)
;
masm
.
setupUnalignedABICall
(
setup
)
;
using
Offsets
=
ArgsOffsets_t
<
0
Args
.
.
.
>
;
using
ABITypes
=
ArgsABITypes_t
<
Args
.
.
.
>
;
passABIArgs
(
masm
base
Offsets
(
)
ABITypes
(
)
)
;
masm
.
callWithABI
(
DynFn
{
JS_FUNC_TO_DATA_PTR
(
void
*
test
.
fun
)
}
TypeToABIType
<
Res
>
(
)
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
private
:
static
JSAPIRuntimeTest
*
instance_
;
static
bool
*
reportTo_
;
}
;
template
<
typename
Res
typename
.
.
.
Args
>
JSAPIRuntimeTest
*
DefineCheckArgs
<
Res
(
*
)
(
Args
.
.
.
)
>
:
:
instance_
=
nullptr
;
template
<
typename
Res
typename
.
.
.
Args
>
bool
*
DefineCheckArgs
<
Res
(
*
)
(
Args
.
.
.
)
>
:
:
reportTo_
=
nullptr
;
template
<
typename
Sig
>
class
JitABICall
final
:
public
JSAPIRuntimeTest
public
DefineCheckArgs
<
Sig
>
{
public
:
explicit
JitABICall
(
const
char
*
name
)
:
name_
(
name
)
{
reuseGlobal
=
true
;
}
virtual
const
char
*
name
(
)
override
{
return
name_
;
}
virtual
bool
run
(
JS
:
:
HandleObject
)
override
{
bool
result
=
true
;
this
-
>
set_instance
(
this
&
result
)
;
TempAllocator
temp
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
JitContext
jcx
(
cx
)
;
StackMacroAssembler
masm
(
cx
temp
)
;
AutoCreatedBy
acb
(
masm
__func__
)
;
PrepareJit
(
masm
)
;
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
#
if
defined
(
JS_CODEGEN_X86
)
Register
base
=
regs
.
takeAny
(
)
;
#
elif
defined
(
JS_CODEGEN_X64
)
Register
base
=
r10
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
Register
base
=
r5
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
Register
base
=
r8
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_MIPS32
)
Register
base
=
t1
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_MIPS64
)
Register
base
=
t1
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_LOONG64
)
Register
base
=
t0
;
regs
.
take
(
base
)
;
#
elif
defined
(
JS_CODEGEN_RISCV64
)
Register
base
=
t0
;
regs
.
take
(
base
)
;
#
else
#
error
"
Unknown
architecture
!
"
#
endif
Register
setup
=
regs
.
takeAny
(
)
;
this
-
>
generateCalls
(
masm
base
setup
)
;
if
(
!
ExecuteJit
(
cx
masm
)
)
{
return
false
;
}
this
-
>
set_instance
(
nullptr
nullptr
)
;
return
result
;
}
;
private
:
const
char
*
name_
;
}
;
#
if
MOZ_IS_GCC
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wignored
-
attributes
"
#
endif
#
define
TEST_INSTANCE
(
Name
Sig
)
\
static
JitABICall
<
Sig
>
MOZ_CONCAT
(
MOZ_CONCAT
(
cls_jitabicall
__COUNTER__
)
\
_instance
)
(
"
JIT
ABI
for
"
Name
)
;
#
define
TEST_INSTANCE_ABIFUN_TO_ALLFUN
(
.
.
.
)
\
APPLY
(
TEST_INSTANCE
ABIFUN_TO_ALLFUN
(
__VA_ARGS__
)
)
#
define
TEST_INSTANCE_ABIFUN_AND_SIG_TO_ALLFUN
(
.
.
.
)
\
APPLY
(
TEST_INSTANCE
ABIFUN_AND_SIG_TO_ALLFUN
(
__VA_ARGS__
)
)
#
define
TEST_INSTANCE_ABISIG_TO_ALLFUN
(
.
.
.
)
\
APPLY
(
TEST_INSTANCE
ABISIG_TO_ALLFUN
(
__VA_ARGS__
)
)
#
define
TEST_INSTANCE_VMFUN_TO_ALLFUN
(
.
.
.
)
\
APPLY
(
TEST_INSTANCE
VMFUN_TO_ALLFUN
(
__VA_ARGS__
)
)
ALL_FUNCTIONS
(
TEST_INSTANCE
)
#
if
MOZ_IS_GCC
#
pragma
GCC
diagnostic
pop
#
endif
