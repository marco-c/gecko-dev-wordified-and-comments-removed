#
include
"
jsapi
-
tests
/
tests
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
stdio
.
h
>
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
GlobalObject
.
h
"
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
JSAPITest
*
JSAPITest
:
:
list
;
bool
JSAPITest
:
:
init
(
JSContext
*
maybeReusableContext
)
{
if
(
maybeReusableContext
&
&
reuseGlobal
)
{
cx
=
maybeReusableContext
;
global
.
init
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
return
init
(
)
;
}
MaybeFreeContext
(
maybeReusableContext
)
;
cx
=
createContext
(
)
;
if
(
!
cx
)
{
return
false
;
}
js
:
:
UseInternalJobQueues
(
cx
)
;
if
(
!
JS
:
:
InitSelfHostedCode
(
cx
)
)
{
return
false
;
}
global
.
init
(
cx
)
;
createGlobal
(
)
;
if
(
!
global
)
{
return
false
;
}
JS
:
:
EnterRealm
(
cx
global
)
;
return
init
(
)
;
}
JSContext
*
JSAPITest
:
:
maybeForgetContext
(
)
{
if
(
!
reuseGlobal
)
{
return
nullptr
;
}
JSContext
*
reusableCx
=
cx
;
global
.
reset
(
)
;
cx
=
nullptr
;
return
reusableCx
;
}
void
JSAPITest
:
:
MaybeFreeContext
(
JSContext
*
maybeCx
)
{
if
(
maybeCx
)
{
JS
:
:
LeaveRealm
(
maybeCx
nullptr
)
;
JS_DestroyContext
(
maybeCx
)
;
}
}
void
JSAPITest
:
:
uninit
(
)
{
global
.
reset
(
)
;
MaybeFreeContext
(
cx
)
;
cx
=
nullptr
;
msgs
.
clear
(
)
;
}
bool
JSAPITest
:
:
exec
(
const
char
*
utf8
const
char
*
filename
int
lineno
)
{
JS
:
:
CompileOptions
opts
(
cx
)
;
opts
.
setFileAndLine
(
filename
lineno
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
JS
:
:
RootedValue
v
(
cx
)
;
return
(
srcBuf
.
init
(
cx
utf8
strlen
(
utf8
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
&
&
JS
:
:
Evaluate
(
cx
opts
srcBuf
&
v
)
)
|
|
fail
(
JSAPITestString
(
utf8
)
filename
lineno
)
;
}
bool
JSAPITest
:
:
execDontReport
(
const
char
*
utf8
const
char
*
filename
int
lineno
)
{
JS
:
:
CompileOptions
opts
(
cx
)
;
opts
.
setFileAndLine
(
filename
lineno
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
JS
:
:
RootedValue
v
(
cx
)
;
return
srcBuf
.
init
(
cx
utf8
strlen
(
utf8
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
&
&
JS
:
:
Evaluate
(
cx
opts
srcBuf
&
v
)
;
}
bool
JSAPITest
:
:
evaluate
(
const
char
*
utf8
const
char
*
filename
int
lineno
JS
:
:
MutableHandleValue
vp
)
{
JS
:
:
CompileOptions
opts
(
cx
)
;
opts
.
setFileAndLine
(
filename
lineno
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
return
(
srcBuf
.
init
(
cx
utf8
strlen
(
utf8
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
&
&
JS
:
:
Evaluate
(
cx
opts
srcBuf
vp
)
)
|
|
fail
(
JSAPITestString
(
utf8
)
filename
lineno
)
;
}
bool
JSAPITest
:
:
definePrint
(
)
{
return
JS_DefineFunction
(
cx
global
"
print
"
(
JSNative
)
print
0
0
)
;
}
JSObject
*
JSAPITest
:
:
createGlobal
(
JSPrincipals
*
principals
)
{
JS
:
:
RootedObject
newGlobal
(
cx
)
;
JS
:
:
RealmOptions
options
;
options
.
creationOptions
(
)
.
setWeakRefsEnabled
(
JS
:
:
WeakRefSpecifier
:
:
EnabledWithCleanupSome
)
.
setSharedMemoryAndAtomicsEnabled
(
true
)
;
newGlobal
=
JS_NewGlobalObject
(
cx
getGlobalClass
(
)
principals
JS
:
:
FireOnNewGlobalHook
options
)
;
if
(
!
newGlobal
)
{
return
nullptr
;
}
global
=
newGlobal
;
return
newGlobal
;
}
struct
CommandOptions
{
bool
list
=
false
;
bool
help
=
false
;
const
char
*
filter
=
nullptr
;
}
;
void
parseArgs
(
int
argc
char
*
argv
[
]
CommandOptions
&
options
)
{
for
(
int
i
=
1
;
i
<
argc
;
i
+
+
)
{
if
(
strcmp
(
argv
[
i
]
"
-
h
"
)
=
=
0
|
|
strcmp
(
argv
[
i
]
"
-
-
help
"
)
=
=
0
)
{
options
.
help
=
true
;
continue
;
}
if
(
strcmp
(
argv
[
i
]
"
-
-
list
"
)
=
=
0
)
{
options
.
list
=
true
;
continue
;
}
if
(
!
options
.
filter
)
{
options
.
filter
=
argv
[
i
]
;
continue
;
}
printf
(
"
error
:
Unrecognized
option
:
%
s
\
n
"
argv
[
i
]
)
;
options
.
help
=
true
;
}
}
int
main
(
int
argc
char
*
argv
[
]
)
{
int
total
=
0
;
int
failures
=
0
;
CommandOptions
options
;
parseArgs
(
argc
argv
options
)
;
if
(
options
.
help
)
{
printf
(
"
Usage
:
jsapi
-
tests
[
OPTIONS
]
[
FILTER
]
\
n
"
)
;
printf
(
"
\
n
"
)
;
printf
(
"
Options
:
\
n
"
)
;
printf
(
"
-
h
-
-
help
Display
this
message
\
n
"
)
;
printf
(
"
-
-
list
List
all
tests
\
n
"
)
;
return
0
;
}
if
(
!
JS_Init
(
)
)
{
printf
(
"
TEST
-
UNEXPECTED
-
FAIL
|
jsapi
-
tests
|
JS_Init
(
)
failed
.
\
n
"
)
;
return
1
;
}
if
(
options
.
list
)
{
for
(
JSAPITest
*
test
=
JSAPITest
:
:
list
;
test
;
test
=
test
-
>
next
)
{
printf
(
"
%
s
\
n
"
test
-
>
name
(
)
)
;
}
return
0
;
}
JSContext
*
maybeReusedContext
=
nullptr
;
for
(
JSAPITest
*
test
=
JSAPITest
:
:
list
;
test
;
test
=
test
-
>
next
)
{
const
char
*
name
=
test
-
>
name
(
)
;
if
(
options
.
filter
&
&
strstr
(
name
options
.
filter
)
=
=
nullptr
)
{
continue
;
}
total
+
=
1
;
printf
(
"
%
s
\
n
"
name
)
;
fflush
(
stdout
)
;
if
(
!
test
-
>
init
(
maybeReusedContext
)
)
{
printf
(
"
TEST
-
UNEXPECTED
-
FAIL
|
%
s
|
Failed
to
initialize
.
\
n
"
name
)
;
failures
+
+
;
test
-
>
uninit
(
)
;
continue
;
}
if
(
test
-
>
run
(
test
-
>
global
)
)
{
printf
(
"
TEST
-
PASS
|
%
s
|
ok
\
n
"
name
)
;
}
else
{
JSAPITestString
messages
=
test
-
>
messages
(
)
;
printf
(
"
%
s
|
%
s
|
%
.
*
s
\
n
"
(
test
-
>
knownFail
?
"
TEST
-
KNOWN
-
FAIL
"
:
"
TEST
-
UNEXPECTED
-
FAIL
"
)
name
(
int
)
messages
.
length
(
)
messages
.
begin
(
)
)
;
if
(
!
test
-
>
knownFail
)
{
failures
+
+
;
}
}
maybeReusedContext
=
test
-
>
maybeForgetContext
(
)
;
test
-
>
uninit
(
)
;
}
JSAPITest
:
:
MaybeFreeContext
(
maybeReusedContext
)
;
MOZ_RELEASE_ASSERT
(
!
JSRuntime
:
:
hasLiveRuntimes
(
)
)
;
JS_ShutDown
(
)
;
if
(
failures
)
{
printf
(
"
\
n
%
d
unexpected
failure
%
s
.
\
n
"
failures
(
failures
=
=
1
?
"
"
:
"
s
"
)
)
;
return
1
;
}
printf
(
"
\
nPassed
:
ran
%
d
tests
.
\
n
"
total
)
;
return
0
;
}
