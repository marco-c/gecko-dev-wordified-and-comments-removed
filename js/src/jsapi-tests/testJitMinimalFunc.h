#
ifndef
jsapi_tests_jitTestGVN_h
#
define
jsapi_tests_jitTestGVN_h
#
include
"
jit
/
DominatorTree
.
h
"
#
include
"
jit
/
IonAnalysis
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
jit
/
RangeAnalysis
.
h
"
#
include
"
jit
/
ValueNumbering
.
h
"
namespace
js
{
namespace
jit
{
struct
MinimalAlloc
{
LifoAlloc
lifo
;
TempAllocator
alloc
;
MinimalAlloc
(
)
:
lifo
(
128
*
1024
js
:
:
MallocArena
)
alloc
(
&
lifo
)
{
if
(
!
alloc
.
ensureBallast
(
)
)
{
MOZ_CRASH
(
"
[
OOM
]
Not
enough
RAM
for
the
test
.
"
)
;
}
}
}
;
struct
MinimalFunc
:
MinimalAlloc
{
JitCompileOptions
options
;
CompileInfo
info
;
MIRGraph
graph
;
MIRGenerator
mir
;
uint32_t
numParams
;
MinimalFunc
(
)
:
options
(
)
info
(
0
)
graph
(
&
alloc
)
mir
(
static_cast
<
CompileRealm
*
>
(
nullptr
)
options
&
alloc
&
graph
&
info
static_cast
<
const
OptimizationInfo
*
>
(
nullptr
)
)
numParams
(
0
)
{
}
MBasicBlock
*
createEntryBlock
(
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
info
nullptr
MBasicBlock
:
:
NORMAL
)
;
graph
.
addBlock
(
block
)
;
return
block
;
}
MBasicBlock
*
createOsrEntryBlock
(
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
info
nullptr
MBasicBlock
:
:
NORMAL
)
;
graph
.
addBlock
(
block
)
;
graph
.
setOsrBlock
(
block
)
;
return
block
;
}
MBasicBlock
*
createBlock
(
MBasicBlock
*
pred
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
info
pred
MBasicBlock
:
:
NORMAL
)
;
graph
.
addBlock
(
block
)
;
return
block
;
}
MParameter
*
createParameter
(
)
{
MParameter
*
p
=
MParameter
:
:
New
(
alloc
numParams
+
+
)
;
return
p
;
}
bool
runGVN
(
)
{
if
(
!
SplitCriticalEdges
(
graph
)
)
{
return
false
;
}
RenumberBlocks
(
graph
)
;
if
(
!
BuildDominatorTree
(
graph
)
)
{
return
false
;
}
if
(
!
BuildPhiReverseMapping
(
graph
)
)
{
return
false
;
}
ValueNumberer
gvn
(
&
mir
graph
)
;
if
(
!
gvn
.
run
(
ValueNumberer
:
:
DontUpdateAliasAnalysis
)
)
{
return
false
;
}
return
true
;
}
bool
runRangeAnalysis
(
)
{
if
(
!
SplitCriticalEdges
(
graph
)
)
{
return
false
;
}
RenumberBlocks
(
graph
)
;
if
(
!
BuildDominatorTree
(
graph
)
)
{
return
false
;
}
if
(
!
BuildPhiReverseMapping
(
graph
)
)
{
return
false
;
}
RangeAnalysis
rangeAnalysis
(
&
mir
graph
)
;
if
(
!
rangeAnalysis
.
addBetaNodes
(
)
)
{
return
false
;
}
if
(
!
rangeAnalysis
.
analyze
(
)
)
{
return
false
;
}
if
(
!
rangeAnalysis
.
addRangeAssertions
(
)
)
{
return
false
;
}
if
(
!
rangeAnalysis
.
removeBetaNodes
(
)
)
{
return
false
;
}
return
true
;
}
}
;
}
}
#
endif
