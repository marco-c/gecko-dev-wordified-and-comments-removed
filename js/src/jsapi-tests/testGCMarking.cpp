#
include
"
jsapi
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
class
CCWTestTracer
:
public
JS
:
:
CallbackTracer
{
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
{
numberOfThingsTraced
+
+
;
printf
(
"
*
thingp
=
%
p
\
n
"
thing
.
asCell
(
)
)
;
printf
(
"
*
expectedThingp
=
%
p
\
n
"
*
expectedThingp
)
;
printf
(
"
kind
=
%
d
\
n
"
static_cast
<
int
>
(
thing
.
kind
(
)
)
)
;
printf
(
"
expectedKind
=
%
d
\
n
"
static_cast
<
int
>
(
expectedKind
)
)
;
if
(
thing
.
asCell
(
)
!
=
*
expectedThingp
|
|
thing
.
kind
(
)
!
=
expectedKind
)
okay
=
false
;
}
public
:
bool
okay
;
size_t
numberOfThingsTraced
;
void
*
*
expectedThingp
;
JS
:
:
TraceKind
expectedKind
;
CCWTestTracer
(
JSContext
*
cx
void
*
*
expectedThingp
JS
:
:
TraceKind
expectedKind
)
:
JS
:
:
CallbackTracer
(
JS_GetRuntime
(
cx
)
)
okay
(
true
)
numberOfThingsTraced
(
0
)
expectedThingp
(
expectedThingp
)
expectedKind
(
expectedKind
)
{
}
}
;
BEGIN_TEST
(
testTracingIncomingCCWs
)
{
JS
:
:
RootedObject
global1
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
CHECK
(
global1
)
;
JS
:
:
CompartmentOptions
options
;
JS
:
:
RootedObject
global2
(
cx
JS_NewGlobalObject
(
cx
getGlobalClass
(
)
nullptr
JS
:
:
FireOnNewGlobalHook
options
)
)
;
CHECK
(
global2
)
;
CHECK
(
global1
-
>
compartment
(
)
!
=
global2
-
>
compartment
(
)
)
;
JS
:
:
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
CHECK
(
obj
-
>
compartment
(
)
=
=
global1
-
>
compartment
(
)
)
;
JSAutoCompartment
ac
(
cx
global2
)
;
JS
:
:
RootedObject
wrapper
(
cx
obj
)
;
CHECK
(
JS_WrapObject
(
cx
&
wrapper
)
)
;
JS
:
:
RootedValue
v
(
cx
JS
:
:
ObjectValue
(
*
wrapper
)
)
;
CHECK
(
JS_SetProperty
(
cx
global2
"
ccw
"
v
)
)
;
JS
:
:
CompartmentSet
compartments
;
CHECK
(
compartments
.
init
(
)
)
;
CHECK
(
compartments
.
put
(
global1
-
>
compartment
(
)
)
)
;
void
*
thing
=
obj
.
get
(
)
;
CCWTestTracer
trc
(
cx
&
thing
JS
:
:
TraceKind
:
:
Object
)
;
JS
:
:
TraceIncomingCCWs
(
&
trc
compartments
)
;
CHECK
(
trc
.
numberOfThingsTraced
=
=
1
)
;
CHECK
(
trc
.
okay
)
;
return
true
;
}
END_TEST
(
testTracingIncomingCCWs
)
BEGIN_TEST
(
testIncrementalRoots
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
#
ifdef
JS_GC_ZEAL
JS_SetGCZeal
(
rt
0
100
)
;
#
endif
JS
:
:
RootedObject
obj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
obj
)
return
false
;
JS
:
:
RootedObject
root
(
cx
obj
)
;
JS
:
:
RootedObject
leaf
(
cx
)
;
JS
:
:
RootedObject
leafOwner
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
3000
;
i
+
+
)
{
JS
:
:
RootedObject
subobj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
subobj
)
return
false
;
if
(
!
JS_DefineProperty
(
cx
obj
"
obj
"
subobj
0
)
)
return
false
;
leafOwner
=
obj
;
obj
=
subobj
;
leaf
=
subobj
;
}
{
JS
:
:
RootedObject
leaf2
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
leaf2
)
return
false
;
if
(
!
JS_DefineProperty
(
cx
leafOwner
"
leaf2
"
leaf2
0
)
)
return
false
;
}
JS
:
:
AutoObjectVector
vec
(
cx
)
;
if
(
!
vec
.
append
(
root
)
)
return
false
;
cx
-
>
minorGC
(
JS
:
:
gcreason
:
:
API
)
;
obj
=
root
=
nullptr
;
JSObject
*
unrootedLeaf
=
leaf
;
JS
:
:
Value
unrootedLeafValue
=
JS
:
:
ObjectValue
(
*
leaf
)
;
JSObject
*
unrootedLeafOwner
=
leafOwner
;
JS
:
:
HandleObject
leafHandle
=
JS
:
:
HandleObject
:
:
fromMarkedLocation
(
&
unrootedLeaf
)
;
JS
:
:
HandleValue
leafValueHandle
=
JS
:
:
HandleValue
:
:
fromMarkedLocation
(
&
unrootedLeafValue
)
;
JS
:
:
HandleObject
leafOwnerHandle
=
JS
:
:
HandleObject
:
:
fromMarkedLocation
(
&
unrootedLeafOwner
)
;
leaf
=
leafOwner
=
nullptr
;
js
:
:
SliceBudget
budget
(
js
:
:
WorkBudget
(
1000
)
)
;
JS_SetGCParameter
(
rt
JSGC_MODE
JSGC_MODE_INCREMENTAL
)
;
rt
-
>
gc
.
startDebugGC
(
GC_NORMAL
budget
)
;
MOZ_ASSERT
(
JS
:
:
IsIncrementalGCInProgress
(
rt
)
)
;
MOZ_ASSERT
(
vec
[
0
]
-
>
asTenured
(
)
.
isMarked
(
)
)
;
MOZ_ASSERT
(
!
leafHandle
-
>
asTenured
(
)
.
isMarked
(
)
)
;
MOZ_ASSERT
(
!
leafOwnerHandle
-
>
asTenured
(
)
.
isMarked
(
)
)
;
#
ifdef
DEBUG
auto
currentGCNumber
=
rt
-
>
gc
.
gcNumber
(
)
;
#
endif
if
(
!
JS_SetProperty
(
cx
leafOwnerHandle
"
obj
"
JS
:
:
UndefinedHandleValue
)
)
return
false
;
MOZ_ASSERT
(
rt
-
>
gc
.
gcNumber
(
)
=
=
currentGCNumber
)
;
if
(
!
JS_SetProperty
(
cx
vec
[
0
]
"
newobj
"
leafValueHandle
)
)
return
false
;
MOZ_ASSERT
(
rt
-
>
gc
.
gcNumber
(
)
=
=
currentGCNumber
)
;
MOZ_ASSERT
(
leafHandle
-
>
asTenured
(
)
.
isMarked
(
)
)
;
{
JS
:
:
RootedValue
leaf2
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
leafOwnerHandle
"
leaf2
"
&
leaf2
)
)
return
false
;
MOZ_ASSERT
(
rt
-
>
gc
.
gcNumber
(
)
=
=
currentGCNumber
)
;
MOZ_ASSERT
(
!
leaf2
.
toObject
(
)
.
asTenured
(
)
.
isMarked
(
)
)
;
if
(
!
JS_SetProperty
(
cx
vec
[
0
]
"
leafcopy
"
leaf2
)
)
return
false
;
MOZ_ASSERT
(
rt
-
>
gc
.
gcNumber
(
)
=
=
currentGCNumber
)
;
MOZ_ASSERT
(
!
leaf2
.
toObject
(
)
.
asTenured
(
)
.
isMarked
(
)
)
;
}
auto
unlimited
=
js
:
:
SliceBudget
:
:
unlimited
(
)
;
rt
-
>
gc
.
debugGCSlice
(
unlimited
)
;
if
(
!
JS_SetProperty
(
cx
leafHandle
"
toes
"
JS
:
:
UndefinedHandleValue
)
)
return
false
;
return
true
;
}
END_TEST
(
testIncrementalRoots
)
