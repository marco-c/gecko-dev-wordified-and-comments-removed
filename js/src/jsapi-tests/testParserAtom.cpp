#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
BEGIN_TEST
(
testParserAtom_empty
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
using
js
:
:
frontend
:
:
ParserAtomVector
;
using
js
:
:
frontend
:
:
TaggedParserAtomIndex
;
js
:
:
LifoAlloc
alloc
(
512
)
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
alloc
)
;
const
char
ascii
[
]
=
{
}
;
const
JS
:
:
Latin1Char
latin1
[
]
=
{
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
}
;
const
char16_t
char16
[
]
=
{
}
;
const
uint8_t
bytes
[
]
=
{
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
auto
refIndex
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
empty
(
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
0
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
0
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
0
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
0
)
=
=
refIndex
)
;
return
true
;
}
END_TEST
(
testParserAtom_empty
)
BEGIN_TEST
(
testParserAtom_tiny1
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
using
js
:
:
frontend
:
:
ParserAtomVector
;
js
:
:
LifoAlloc
alloc
(
512
)
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
alloc
)
;
char16_t
a
=
'
a
'
;
const
char
ascii
[
]
=
{
'
a
'
}
;
JS
:
:
Latin1Char
latin1
[
]
=
{
'
a
'
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
mozilla
:
:
Utf8Unit
(
'
a
'
)
}
;
char16_t
char16
[
]
=
{
'
a
'
}
;
const
uint8_t
bytes
[
]
=
{
'
a
'
0
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
auto
ref
=
cx
-
>
runtime
(
)
-
>
commonParserNames
-
>
lookupTiny
(
&
a
1
)
;
CHECK
(
ref
)
;
auto
refIndex
=
cx
-
>
runtime
(
)
-
>
commonParserNames
-
>
lookupTinyIndex
(
&
a
1
)
;
CHECK
(
refIndex
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
1
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
1
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
1
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
1
)
=
=
refIndex
)
;
char16_t
ae
=
0x00E6
;
CHECK
(
cx
-
>
runtime
(
)
-
>
commonParserNames
-
>
lookupTiny
(
&
ae
1
)
=
=
nullptr
)
;
return
true
;
}
END_TEST
(
testParserAtom_tiny1
)
BEGIN_TEST
(
testParserAtom_tiny2
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
using
js
:
:
frontend
:
:
ParserAtomVector
;
js
:
:
LifoAlloc
alloc
(
512
)
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
alloc
)
;
const
char
ascii
[
]
=
{
'
a
'
'
0
'
}
;
JS
:
:
Latin1Char
latin1
[
]
=
{
'
a
'
'
0
'
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
mozilla
:
:
Utf8Unit
(
'
a
'
)
mozilla
:
:
Utf8Unit
(
'
0
'
)
}
;
char16_t
char16
[
]
=
{
'
a
'
'
0
'
}
;
const
uint8_t
bytes
[
]
=
{
'
a
'
0
'
0
'
0
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
auto
refIndex
=
cx
-
>
runtime
(
)
-
>
commonParserNames
-
>
lookupTinyIndex
(
ascii
2
)
;
CHECK
(
refIndex
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
2
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
2
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
2
)
=
=
refIndex
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
2
)
=
=
refIndex
)
;
char16_t
ae0
[
]
=
{
0x00E6
'
0
'
}
;
CHECK
(
cx
-
>
runtime
(
)
-
>
commonParserNames
-
>
lookupTiny
(
ae0
2
)
=
=
nullptr
)
;
return
true
;
}
END_TEST
(
testParserAtom_tiny2
)
