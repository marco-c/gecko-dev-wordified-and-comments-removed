#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
BEGIN_TEST
(
testParserAtom_empty
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
)
;
const
char
ascii
[
]
=
{
}
;
const
JS
:
:
Latin1Char
latin1
[
]
=
{
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
}
;
const
char16_t
char16
[
]
=
{
}
;
const
uint8_t
bytes
[
]
=
{
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
const
ParserAtom
*
ref
=
cx
-
>
parserNames
(
)
.
empty
;
CHECK
(
ref
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
0
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
0
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
0
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
0
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16LE
(
cx
leTwoByte
0
)
.
unwrap
(
)
=
=
ref
)
;
const
ParserAtom
*
concat
[
]
=
{
cx
-
>
parserNames
(
)
.
empty
cx
-
>
parserNames
(
)
.
empty
}
;
mozilla
:
:
Range
<
const
ParserAtom
*
>
concatRange
(
concat
2
)
;
CHECK
(
atomTable
.
concatAtoms
(
cx
concatRange
)
.
unwrap
(
)
=
=
ref
)
;
return
true
;
}
END_TEST
(
testParserAtom_empty
)
BEGIN_TEST
(
testParserAtom_tiny1
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
)
;
char16_t
a
=
'
a
'
;
const
char
ascii
[
]
=
{
'
a
'
}
;
JS
:
:
Latin1Char
latin1
[
]
=
{
'
a
'
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
mozilla
:
:
Utf8Unit
(
'
a
'
)
}
;
char16_t
char16
[
]
=
{
'
a
'
}
;
const
uint8_t
bytes
[
]
=
{
'
a
'
0
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
const
ParserAtom
*
ref
=
cx
-
>
parserNames
(
)
.
lookupTiny
(
&
a
1
)
;
CHECK
(
ref
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
1
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
1
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
1
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
1
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16LE
(
cx
leTwoByte
1
)
.
unwrap
(
)
=
=
ref
)
;
const
ParserAtom
*
concat
[
]
=
{
ref
cx
-
>
parserNames
(
)
.
empty
}
;
mozilla
:
:
Range
<
const
ParserAtom
*
>
concatRange
(
concat
2
)
;
CHECK
(
atomTable
.
concatAtoms
(
cx
concatRange
)
.
unwrap
(
)
=
=
ref
)
;
char16_t
ae
=
0x00E6
;
CHECK
(
cx
-
>
parserNames
(
)
.
lookupTiny
(
&
ae
1
)
=
=
nullptr
)
;
return
true
;
}
END_TEST
(
testParserAtom_tiny1
)
BEGIN_TEST
(
testParserAtom_tiny2
)
{
using
js
:
:
frontend
:
:
ParserAtom
;
using
js
:
:
frontend
:
:
ParserAtomsTable
;
ParserAtomsTable
atomTable
(
cx
-
>
runtime
(
)
)
;
const
char
ascii
[
]
=
{
'
a
'
'
0
'
}
;
JS
:
:
Latin1Char
latin1
[
]
=
{
'
a
'
'
0
'
}
;
const
mozilla
:
:
Utf8Unit
utf8
[
]
=
{
mozilla
:
:
Utf8Unit
(
'
a
'
)
mozilla
:
:
Utf8Unit
(
'
0
'
)
}
;
char16_t
char16
[
]
=
{
'
a
'
'
0
'
}
;
const
uint8_t
bytes
[
]
=
{
'
a
'
0
'
0
'
0
}
;
const
js
:
:
LittleEndianChars
leTwoByte
(
bytes
)
;
const
ParserAtom
*
ref
=
cx
-
>
parserNames
(
)
.
lookupTiny
(
ascii
2
)
;
CHECK
(
ref
)
;
CHECK
(
atomTable
.
internAscii
(
cx
ascii
2
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internLatin1
(
cx
latin1
2
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internUtf8
(
cx
utf8
2
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16
(
cx
char16
2
)
.
unwrap
(
)
=
=
ref
)
;
CHECK
(
atomTable
.
internChar16LE
(
cx
leTwoByte
2
)
.
unwrap
(
)
=
=
ref
)
;
const
ParserAtom
*
concat
[
]
=
{
cx
-
>
parserNames
(
)
.
lookupTiny
(
ascii
+
0
1
)
cx
-
>
parserNames
(
)
.
lookupTiny
(
ascii
+
1
1
)
}
;
mozilla
:
:
Range
<
const
ParserAtom
*
>
concatRange
(
concat
2
)
;
CHECK
(
atomTable
.
concatAtoms
(
cx
concatRange
)
.
unwrap
(
)
=
=
ref
)
;
char16_t
ae0
[
]
=
{
0x00E6
'
0
'
}
;
CHECK
(
cx
-
>
parserNames
(
)
.
lookupTiny
(
ae0
2
)
=
=
nullptr
)
;
return
true
;
}
END_TEST
(
testParserAtom_tiny2
)
