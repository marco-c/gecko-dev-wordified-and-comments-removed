#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
clocale
>
#
include
<
cstring
>
#
include
<
cwchar
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
string_view
>
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
jsapi
-
tests
/
tests
.
h
"
static
bool
EqualsIgnoreCase
(
const
char
*
xs
const
char
*
ys
)
{
while
(
*
xs
&
&
*
ys
)
{
char
x
=
*
xs
+
+
;
char
y
=
*
ys
+
+
;
if
(
mozilla
:
:
IsAsciiAlpha
(
x
)
&
&
mozilla
:
:
IsAsciiAlpha
(
y
)
)
{
x
|
=
0x20
;
y
|
=
0x20
;
}
if
(
x
!
=
y
)
{
return
false
;
}
}
return
!
*
xs
&
&
!
*
ys
;
}
class
ToUTF8Locale
{
const
char
*
previousLocale_
=
nullptr
;
bool
supported_
=
false
;
public
:
ToUTF8Locale
(
)
{
previousLocale_
=
std
:
:
setlocale
(
LC_ALL
nullptr
)
;
const
char
*
defaultLocale
=
std
:
:
setlocale
(
LC_ALL
"
"
)
;
if
(
!
defaultLocale
)
{
return
;
}
const
char
*
newLocale
=
std
:
:
setlocale
(
LC_ALL
"
en_US
.
UTF
-
8
"
)
;
if
(
!
newLocale
)
{
return
;
}
const
char
*
defaultCodepage
=
std
:
:
strchr
(
defaultLocale
'
.
'
)
;
const
char
*
newCodepage
=
std
:
:
strchr
(
newLocale
'
.
'
)
;
if
(
!
defaultCodepage
|
|
!
newCodepage
)
{
return
;
}
defaultCodepage
+
+
;
newCodepage
+
+
;
supported_
=
EqualsIgnoreCase
(
defaultCodepage
"
UTF
-
8
"
)
&
&
EqualsIgnoreCase
(
newCodepage
"
UTF
-
8
"
)
;
}
bool
supported
(
)
const
{
return
supported_
;
}
~
ToUTF8Locale
(
)
{
if
(
previousLocale_
)
{
std
:
:
setlocale
(
LC_ALL
previousLocale_
)
;
}
}
}
;
BEGIN_TEST
(
testCharacterEncoding_narrow_to_utf8
)
{
for
(
std
:
:
string_view
string
:
{
"
"
"
a
"
"
abc
"
"
abc
\
0def
"
}
)
{
auto
utf8
=
JS
:
:
EncodeNarrowToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
strlen
(
utf8
.
get
(
)
)
string
.
length
(
)
)
;
CHECK
(
utf8
.
get
(
)
=
=
string
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_narrow_to_utf8
)
BEGIN_TEST
(
testCharacterEncoding_wide_to_utf8
)
{
for
(
std
:
:
wstring_view
string
:
{
L
"
"
L
"
a
"
L
"
abc
"
L
"
abc
\
0def
"
}
)
{
auto
utf8
=
JS
:
:
EncodeWideToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
strlen
(
utf8
.
get
(
)
)
string
.
length
(
)
)
;
CHECK
(
std
:
:
equal
(
string
.
begin
(
)
string
.
end
(
)
utf8
.
get
(
)
[
]
(
wchar_t
x
char
y
)
{
return
char32_t
(
x
)
=
=
char32_t
(
y
)
;
}
)
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_wide_to_utf8
)
BEGIN_TEST
(
testCharacterEncoding_wide_to_utf8_non_ascii
)
{
ToUTF8Locale
utf8locale
;
if
(
!
utf8locale
.
supported
(
)
)
{
return
true
;
}
{
std
:
:
wstring_view
string
=
L
"
"
;
auto
utf8
=
JS
:
:
EncodeWideToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
strlen
(
utf8
.
get
(
)
)
2U
)
;
CHECK_EQUAL
(
utf8
[
0
]
char
(
0xC3
)
)
;
CHECK_EQUAL
(
utf8
[
1
]
char
(
0xA4
)
)
;
}
{
std
:
:
wstring_view
string
=
L
"
"
;
auto
utf8
=
JS
:
:
EncodeWideToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
strlen
(
utf8
.
get
(
)
)
4U
)
;
CHECK_EQUAL
(
utf8
[
0
]
char
(
0xF0
)
)
;
CHECK_EQUAL
(
utf8
[
1
]
char
(
0x9F
)
)
;
CHECK_EQUAL
(
utf8
[
2
]
char
(
0x92
)
)
;
CHECK_EQUAL
(
utf8
[
3
]
char
(
0xA9
)
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_wide_to_utf8_non_ascii
)
BEGIN_TEST
(
testCharacterEncoding_utf8_to_narrow
)
{
for
(
std
:
:
string_view
string
:
{
"
"
"
a
"
"
abc
"
"
abc
\
0def
"
}
)
{
auto
narrow
=
JS
:
:
EncodeUtf8ToNarrow
(
cx
string
.
data
(
)
)
;
CHECK
(
narrow
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
strlen
(
narrow
.
get
(
)
)
string
.
length
(
)
)
;
CHECK
(
narrow
.
get
(
)
=
=
string
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_utf8_to_narrow
)
BEGIN_TEST
(
testCharacterEncoding_utf8_to_wide
)
{
for
(
std
:
:
string_view
string
:
{
"
"
"
a
"
"
abc
"
"
abc
\
0def
"
}
)
{
auto
wide
=
JS
:
:
EncodeUtf8ToWide
(
cx
string
.
data
(
)
)
;
CHECK
(
wide
!
=
nullptr
)
;
CHECK_EQUAL
(
std
:
:
wcslen
(
wide
.
get
(
)
)
string
.
length
(
)
)
;
CHECK
(
std
:
:
equal
(
string
.
begin
(
)
string
.
end
(
)
wide
.
get
(
)
[
]
(
char
x
wchar_t
y
)
{
return
char32_t
(
x
)
=
=
char32_t
(
y
)
;
}
)
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_utf8_to_wide
)
BEGIN_TEST
(
testCharacterEncoding_narrow_roundtrip
)
{
ToUTF8Locale
utf8locale
;
if
(
!
utf8locale
.
supported
(
)
)
{
return
true
;
}
for
(
std
:
:
string_view
string
:
{
"
"
"
a
"
"
abc
"
"
"
"
"
}
)
{
auto
utf8
=
JS
:
:
EncodeNarrowToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
auto
narrow
=
JS
:
:
EncodeUtf8ToNarrow
(
cx
utf8
.
get
(
)
)
;
CHECK
(
narrow
!
=
nullptr
)
;
CHECK
(
narrow
.
get
(
)
=
=
string
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_narrow_roundtrip
)
BEGIN_TEST
(
testCharacterEncoding_wide_roundtrip
)
{
ToUTF8Locale
utf8locale
;
if
(
!
utf8locale
.
supported
(
)
)
{
return
true
;
}
for
(
std
:
:
wstring_view
string
:
{
L
"
"
L
"
a
"
L
"
abc
"
L
"
"
L
"
"
}
)
{
auto
utf8
=
JS
:
:
EncodeWideToUtf8
(
cx
string
.
data
(
)
)
;
CHECK
(
utf8
!
=
nullptr
)
;
auto
wide
=
JS
:
:
EncodeUtf8ToWide
(
cx
utf8
.
get
(
)
)
;
CHECK
(
wide
!
=
nullptr
)
;
CHECK
(
wide
.
get
(
)
=
=
string
)
;
}
return
true
;
}
END_TEST
(
testCharacterEncoding_wide_roundtrip
)
