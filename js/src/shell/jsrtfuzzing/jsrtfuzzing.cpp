#
include
"
shell
/
jsrtfuzzing
/
jsrtfuzzing
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
FuzzerDefs
.
h
"
#
include
"
FuzzingInterface
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
Equality
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
namespace
js
;
namespace
js
{
namespace
shell
{
static
JSContext
*
gCx
=
nullptr
;
static
std
:
:
string
gFuzzModuleName
;
static
void
CrashOnPendingException
(
)
{
if
(
JS_IsExceptionPending
(
gCx
)
)
{
RootedValue
exn
(
gCx
)
;
(
void
)
JS_GetPendingException
(
gCx
&
exn
)
;
RootedObject
stack
(
gCx
GetPendingExceptionStack
(
gCx
)
)
;
JS_ClearPendingException
(
gCx
)
;
js
:
:
ErrorReport
report
(
gCx
)
;
if
(
!
report
.
init
(
gCx
exn
js
:
:
ErrorReport
:
:
WithSideEffects
)
)
{
fprintf
(
stderr
"
out
of
memory
initializing
ErrorReport
\
n
"
)
;
fflush
(
stderr
)
;
}
else
{
PrintError
(
gCx
stderr
report
.
toStringResult
(
)
report
.
report
(
)
reportWarnings
)
;
if
(
!
PrintStackTrace
(
gCx
stack
)
)
{
fputs
(
"
(
Unable
to
print
stack
trace
)
\
n
"
stderr
)
;
}
}
MOZ_CRASH
(
"
Unhandled
exception
from
JS
runtime
!
"
)
;
}
}
int
FuzzJSRuntimeStart
(
JSContext
*
cx
int
*
argc
char
*
*
*
argv
)
{
gCx
=
cx
;
gFuzzModuleName
=
getenv
(
"
FUZZER
"
)
;
int
ret
=
FuzzJSRuntimeInit
(
argc
argv
)
;
if
(
ret
)
{
fprintf
(
stderr
"
Fuzzing
Interface
:
Error
:
Initialize
callback
failed
\
n
"
)
;
return
ret
;
}
#
ifdef
LIBFUZZER
fuzzer
:
:
FuzzerDriver
(
&
sArgc
&
sArgv
FuzzJSRuntimeFuzz
)
;
#
elif
__AFL_COMPILER
MOZ_CRASH
(
"
AFL
is
unsupported
for
JS
runtime
fuzzing
integration
"
)
;
#
endif
return
0
;
}
int
FuzzJSRuntimeInit
(
int
*
argc
char
*
*
*
argv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
gCx
)
;
JS
:
:
CompileOptions
opts
(
gCx
)
;
JS
:
:
EvaluateUtf8Path
(
gCx
opts
gFuzzModuleName
.
c_str
(
)
&
v
)
;
CrashOnPendingException
(
)
;
return
0
;
}
int
FuzzJSRuntimeFuzz
(
const
uint8_t
*
buf
size_t
size
)
{
if
(
!
size
)
{
return
0
;
}
JS
:
:
Rooted
<
JSObject
*
>
arr
(
gCx
JS_NewUint8ClampedArray
(
gCx
size
)
)
;
if
(
!
arr
)
{
MOZ_CRASH
(
"
OOM
"
)
;
}
do
{
JS
:
:
AutoCheckCannotGC
nogc
;
bool
isShared
;
uint8_t
*
data
=
JS_GetUint8ClampedArrayData
(
arr
&
isShared
nogc
)
;
MOZ_RELEASE_ASSERT
(
!
isShared
)
;
memcpy
(
data
buf
size
)
;
}
while
(
false
)
;
JS
:
:
RootedValue
arrVal
(
gCx
JS
:
:
ObjectValue
(
*
arr
)
)
;
if
(
!
JS_SetProperty
(
gCx
gCx
-
>
global
(
)
"
fuzzBuf
"
arrVal
)
)
{
MOZ_CRASH
(
"
JS_SetProperty
failed
"
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
gCx
)
;
JS
:
:
CompileOptions
opts
(
gCx
)
;
static
const
char
data
[
]
=
"
JSFuzzIterate
(
)
;
"
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
if
(
!
srcBuf
.
init
(
gCx
data
mozilla
:
:
ArrayLength
(
data
)
-
1
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
{
return
0
;
}
JS
:
:
Evaluate
(
gCx
opts
.
setFileAndLine
(
__FILE__
__LINE__
)
srcBuf
&
v
)
;
CrashOnPendingException
(
)
;
return
0
;
}
}
}
