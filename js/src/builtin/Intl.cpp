#
include
"
builtin
/
Intl
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
builtin
/
intl
/
ICUStubs
.
h
"
#
include
"
builtin
/
intl
/
ScopedICUObject
.
h
"
#
include
"
builtin
/
IntlTimeZoneData
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
vm
/
DateTime
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
String
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
vm
/
Unicode
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
IsFinite
;
using
mozilla
:
:
IsNaN
;
using
mozilla
:
:
IsNegativeZero
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
Range
;
using
mozilla
:
:
RangedPtr
;
using
JS
:
:
ClippedTime
;
using
JS
:
:
TimeClip
;
using
js
:
:
intl
:
:
CallICU
;
using
js
:
:
intl
:
:
DateTimeFormatOptions
;
using
js
:
:
intl
:
:
GetAvailableLocales
;
using
js
:
:
intl
:
:
IcuLocale
;
using
js
:
:
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
;
using
js
:
:
intl
:
:
StringsAreEqual
;
const
ClassOps
CollatorObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
CollatorObject
:
:
finalize
}
;
const
Class
CollatorObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
CollatorObject
:
:
SLOT_COUNT
)
|
JSCLASS_FOREGROUND_FINALIZE
&
CollatorObject
:
:
classOps_
}
;
#
if
JS_HAS_TOSOURCE
static
bool
collator_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Collator
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
collator_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_Collator_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
collator_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_Collator_resolvedOptions
"
0
0
)
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
collator_toSource
0
0
)
#
endif
JS_FS_END
}
;
static
const
JSPropertySpec
collator_properties
[
]
=
{
JS_SELF_HOSTED_GET
(
"
compare
"
"
Intl_Collator_compare_get
"
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Object
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
bool
Collator
(
JSContext
*
cx
const
CallArgs
&
args
)
{
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreateCollatorPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
Rooted
<
CollatorObject
*
>
collator
(
cx
NewObjectWithGivenProto
<
CollatorObject
>
(
cx
proto
)
)
;
if
(
!
collator
)
return
false
;
collator
-
>
setReservedSlot
(
CollatorObject
:
:
INTERNALS_SLOT
NullValue
(
)
)
;
collator
-
>
setReservedSlot
(
CollatorObject
:
:
UCOLLATOR_SLOT
PrivateValue
(
nullptr
)
)
;
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
if
(
!
intl
:
:
InitializeObject
(
cx
collator
cx
-
>
names
(
)
.
InitializeCollator
locales
options
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
collator
)
;
return
true
;
}
static
bool
Collator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
Collator
(
cx
args
)
;
}
bool
js
:
:
intl_Collator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
args
.
isConstructing
(
)
)
;
return
Collator
(
cx
args
)
;
}
void
CollatorObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
const
Value
&
slot
=
obj
-
>
as
<
CollatorObject
>
(
)
.
getReservedSlot
(
CollatorObject
:
:
UCOLLATOR_SLOT
)
;
if
(
UCollator
*
coll
=
static_cast
<
UCollator
*
>
(
slot
.
toPrivate
(
)
)
)
ucol_close
(
coll
)
;
}
static
JSObject
*
CreateCollatorPrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
)
{
RootedFunction
ctor
(
cx
GlobalObject
:
:
createConstructor
(
cx
&
Collator
cx
-
>
names
(
)
.
Collator
0
)
)
;
if
(
!
ctor
)
return
nullptr
;
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
ctor
collator_static_methods
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
proto
collator_methods
)
)
return
nullptr
;
if
(
!
JS_DefineProperties
(
cx
proto
collator_properties
)
)
return
nullptr
;
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
Collator
ctorValue
0
)
)
return
nullptr
;
return
proto
;
}
bool
js
:
:
intl_Collator_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
RootedValue
result
(
cx
)
;
if
(
!
GetAvailableLocales
(
cx
ucol_countAvailable
ucol_getAvailable
&
result
)
)
return
false
;
args
.
rval
(
)
.
set
(
result
)
;
return
true
;
}
bool
js
:
:
intl_availableCollations
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
values
=
ucol_getKeywordValuesForLocale
(
"
co
"
locale
.
ptr
(
)
false
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UEnumeration
uenum_close
>
toClose
(
values
)
;
uint32_t
count
=
uenum_count
(
values
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
RootedObject
collations
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
collations
)
return
false
;
uint32_t
index
=
0
;
if
(
!
DefineDataElement
(
cx
collations
index
+
+
NullHandleValue
)
)
return
false
;
RootedValue
element
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
const
char
*
collation
=
uenum_next
(
values
nullptr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
StringsAreEqual
(
collation
"
standard
"
)
|
|
StringsAreEqual
(
collation
"
search
"
)
)
continue
;
JSString
*
jscollation
=
JS_NewStringCopyZ
(
cx
uloc_toUnicodeLocaleType
(
"
co
"
collation
)
)
;
if
(
!
jscollation
)
return
false
;
element
=
StringValue
(
jscollation
)
;
if
(
!
DefineDataElement
(
cx
collations
index
+
+
element
)
)
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
collations
)
;
return
true
;
}
static
UCollator
*
NewUCollator
(
JSContext
*
cx
Handle
<
CollatorObject
*
>
collator
)
{
RootedValue
value
(
cx
)
;
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
collator
)
)
;
if
(
!
internals
)
return
nullptr
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
nullptr
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
nullptr
;
UColAttributeValue
uStrength
=
UCOL_DEFAULT
;
UColAttributeValue
uCaseLevel
=
UCOL_OFF
;
UColAttributeValue
uAlternate
=
UCOL_DEFAULT
;
UColAttributeValue
uNumeric
=
UCOL_OFF
;
UColAttributeValue
uNormalization
=
UCOL_ON
;
UColAttributeValue
uCaseFirst
=
UCOL_DEFAULT
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
usage
&
value
)
)
return
nullptr
;
{
JSLinearString
*
usage
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
usage
)
return
nullptr
;
if
(
StringEqualsAscii
(
usage
"
search
"
)
)
{
const
char
*
oldLocale
=
locale
.
ptr
(
)
;
const
char
*
p
;
size_t
index
;
size_t
localeLen
=
strlen
(
oldLocale
)
;
if
(
(
p
=
strstr
(
oldLocale
"
-
x
-
"
)
)
)
index
=
p
-
oldLocale
;
else
index
=
localeLen
;
const
char
*
insert
;
if
(
(
p
=
strstr
(
oldLocale
"
-
u
-
"
)
)
&
&
static_cast
<
size_t
>
(
p
-
oldLocale
)
<
index
)
{
index
=
p
-
oldLocale
+
2
;
insert
=
"
-
co
-
search
"
;
}
else
{
insert
=
"
-
u
-
co
-
search
"
;
}
size_t
insertLen
=
strlen
(
insert
)
;
char
*
newLocale
=
cx
-
>
pod_malloc
<
char
>
(
localeLen
+
insertLen
+
1
)
;
if
(
!
newLocale
)
return
nullptr
;
memcpy
(
newLocale
oldLocale
index
)
;
memcpy
(
newLocale
+
index
insert
insertLen
)
;
memcpy
(
newLocale
+
index
+
insertLen
oldLocale
+
index
localeLen
-
index
+
1
)
;
locale
.
clear
(
)
;
locale
.
initBytes
(
JS
:
:
UniqueChars
(
newLocale
)
)
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
usage
"
sort
"
)
)
;
}
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
sensitivity
&
value
)
)
return
nullptr
;
{
JSLinearString
*
sensitivity
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
sensitivity
)
return
nullptr
;
if
(
StringEqualsAscii
(
sensitivity
"
base
"
)
)
{
uStrength
=
UCOL_PRIMARY
;
}
else
if
(
StringEqualsAscii
(
sensitivity
"
accent
"
)
)
{
uStrength
=
UCOL_SECONDARY
;
}
else
if
(
StringEqualsAscii
(
sensitivity
"
case
"
)
)
{
uStrength
=
UCOL_PRIMARY
;
uCaseLevel
=
UCOL_ON
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
sensitivity
"
variant
"
)
)
;
uStrength
=
UCOL_TERTIARY
;
}
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
ignorePunctuation
&
value
)
)
return
nullptr
;
if
(
value
.
toBoolean
(
)
)
uAlternate
=
UCOL_SHIFTED
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
numeric
&
value
)
)
return
nullptr
;
if
(
!
value
.
isUndefined
(
)
&
&
value
.
toBoolean
(
)
)
uNumeric
=
UCOL_ON
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
caseFirst
&
value
)
)
return
nullptr
;
if
(
!
value
.
isUndefined
(
)
)
{
JSLinearString
*
caseFirst
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
caseFirst
)
return
nullptr
;
if
(
StringEqualsAscii
(
caseFirst
"
upper
"
)
)
{
uCaseFirst
=
UCOL_UPPER_FIRST
;
}
else
if
(
StringEqualsAscii
(
caseFirst
"
lower
"
)
)
{
uCaseFirst
=
UCOL_LOWER_FIRST
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
caseFirst
"
false
"
)
)
;
uCaseFirst
=
UCOL_OFF
;
}
}
UErrorCode
status
=
U_ZERO_ERROR
;
UCollator
*
coll
=
ucol_open
(
IcuLocale
(
locale
.
ptr
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ucol_setAttribute
(
coll
UCOL_STRENGTH
uStrength
&
status
)
;
ucol_setAttribute
(
coll
UCOL_CASE_LEVEL
uCaseLevel
&
status
)
;
ucol_setAttribute
(
coll
UCOL_ALTERNATE_HANDLING
uAlternate
&
status
)
;
ucol_setAttribute
(
coll
UCOL_NUMERIC_COLLATION
uNumeric
&
status
)
;
ucol_setAttribute
(
coll
UCOL_NORMALIZATION_MODE
uNormalization
&
status
)
;
ucol_setAttribute
(
coll
UCOL_CASE_FIRST
uCaseFirst
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
ucol_close
(
coll
)
;
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
return
coll
;
}
static
bool
intl_CompareStrings
(
JSContext
*
cx
UCollator
*
coll
HandleString
str1
HandleString
str2
MutableHandleValue
result
)
{
MOZ_ASSERT
(
str1
)
;
MOZ_ASSERT
(
str2
)
;
if
(
str1
=
=
str2
)
{
result
.
setInt32
(
0
)
;
return
true
;
}
AutoStableStringChars
stableChars1
(
cx
)
;
if
(
!
stableChars1
.
initTwoByte
(
cx
str1
)
)
return
false
;
AutoStableStringChars
stableChars2
(
cx
)
;
if
(
!
stableChars2
.
initTwoByte
(
cx
str2
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
chars1
=
stableChars1
.
twoByteRange
(
)
;
mozilla
:
:
Range
<
const
char16_t
>
chars2
=
stableChars2
.
twoByteRange
(
)
;
UCollationResult
uresult
=
ucol_strcoll
(
coll
chars1
.
begin
(
)
.
get
(
)
chars1
.
length
(
)
chars2
.
begin
(
)
.
get
(
)
chars2
.
length
(
)
)
;
int32_t
res
;
switch
(
uresult
)
{
case
UCOL_LESS
:
res
=
-
1
;
break
;
case
UCOL_EQUAL
:
res
=
0
;
break
;
case
UCOL_GREATER
:
res
=
1
;
break
;
default
:
MOZ_CRASH
(
"
ucol_strcoll
returned
bad
UCollationResult
"
)
;
}
result
.
setInt32
(
res
)
;
return
true
;
}
bool
js
:
:
intl_CompareStrings
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isString
(
)
)
;
Rooted
<
CollatorObject
*
>
collator
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
CollatorObject
>
(
)
)
;
void
*
priv
=
collator
-
>
getReservedSlot
(
CollatorObject
:
:
UCOLLATOR_SLOT
)
.
toPrivate
(
)
;
UCollator
*
coll
=
static_cast
<
UCollator
*
>
(
priv
)
;
if
(
!
coll
)
{
coll
=
NewUCollator
(
cx
collator
)
;
if
(
!
coll
)
return
false
;
collator
-
>
setReservedSlot
(
CollatorObject
:
:
UCOLLATOR_SLOT
PrivateValue
(
coll
)
)
;
}
RootedString
str1
(
cx
args
[
1
]
.
toString
(
)
)
;
RootedString
str2
(
cx
args
[
2
]
.
toString
(
)
)
;
return
intl_CompareStrings
(
cx
coll
str1
str2
args
.
rval
(
)
)
;
}
js
:
:
SharedIntlData
:
:
LocaleHasher
:
:
Lookup
:
:
Lookup
(
JSLinearString
*
locale
)
:
js
:
:
SharedIntlData
:
:
LinearStringLookup
(
locale
)
{
if
(
isLatin1
)
hash
=
mozilla
:
:
HashString
(
latin1Chars
length
)
;
else
hash
=
mozilla
:
:
HashString
(
twoByteChars
length
)
;
}
bool
js
:
:
SharedIntlData
:
:
LocaleHasher
:
:
match
(
Locale
key
const
Lookup
&
lookup
)
{
if
(
key
-
>
length
(
)
!
=
lookup
.
length
)
return
false
;
if
(
key
-
>
hasLatin1Chars
(
)
)
{
const
Latin1Char
*
keyChars
=
key
-
>
latin1Chars
(
lookup
.
nogc
)
;
if
(
lookup
.
isLatin1
)
return
EqualChars
(
keyChars
lookup
.
latin1Chars
lookup
.
length
)
;
return
EqualChars
(
keyChars
lookup
.
twoByteChars
lookup
.
length
)
;
}
const
char16_t
*
keyChars
=
key
-
>
twoByteChars
(
lookup
.
nogc
)
;
if
(
lookup
.
isLatin1
)
return
EqualChars
(
lookup
.
latin1Chars
keyChars
lookup
.
length
)
;
return
EqualChars
(
keyChars
lookup
.
twoByteChars
lookup
.
length
)
;
}
bool
js
:
:
SharedIntlData
:
:
ensureUpperCaseFirstLocales
(
JSContext
*
cx
)
{
if
(
upperCaseFirstInitialized
)
return
true
;
if
(
upperCaseFirstLocales
.
initialized
(
)
)
upperCaseFirstLocales
.
finish
(
)
;
if
(
!
upperCaseFirstLocales
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
available
=
ucol_openAvailableLocales
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UEnumeration
uenum_close
>
toClose
(
available
)
;
RootedAtom
locale
(
cx
)
;
while
(
true
)
{
int32_t
size
;
const
char
*
rawLocale
=
uenum_next
(
available
&
size
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
rawLocale
=
=
nullptr
)
break
;
UCollator
*
collator
=
ucol_open
(
rawLocale
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UCollator
ucol_close
>
toCloseCollator
(
collator
)
;
UColAttributeValue
caseFirst
=
ucol_getAttribute
(
collator
UCOL_CASE_FIRST
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
caseFirst
!
=
UCOL_UPPER_FIRST
)
continue
;
MOZ_ASSERT
(
size
>
=
0
)
;
locale
=
Atomize
(
cx
rawLocale
size_t
(
size
)
)
;
if
(
!
locale
)
return
false
;
LocaleHasher
:
:
Lookup
lookup
(
locale
)
;
LocaleSet
:
:
AddPtr
p
=
upperCaseFirstLocales
.
lookupForAdd
(
lookup
)
;
if
(
!
p
&
&
!
upperCaseFirstLocales
.
add
(
p
locale
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
MOZ_ASSERT
(
!
upperCaseFirstInitialized
"
ensureUpperCaseFirstLocales
is
neither
reentrant
nor
thread
-
safe
"
)
;
upperCaseFirstInitialized
=
true
;
return
true
;
}
bool
js
:
:
SharedIntlData
:
:
isUpperCaseFirst
(
JSContext
*
cx
HandleString
locale
bool
*
isUpperFirst
)
{
if
(
!
ensureUpperCaseFirstLocales
(
cx
)
)
return
false
;
RootedLinearString
localeLinear
(
cx
locale
-
>
ensureLinear
(
cx
)
)
;
if
(
!
localeLinear
)
return
false
;
LocaleHasher
:
:
Lookup
lookup
(
localeLinear
)
;
*
isUpperFirst
=
upperCaseFirstLocales
.
has
(
lookup
)
;
return
true
;
}
bool
js
:
:
intl_isUpperCaseFirst
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
RootedString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
bool
isUpperFirst
;
if
(
!
sharedIntlData
.
isUpperCaseFirst
(
cx
locale
&
isUpperFirst
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
isUpperFirst
)
;
return
true
;
}
const
ClassOps
NumberFormatObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
NumberFormatObject
:
:
finalize
}
;
const
Class
NumberFormatObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
NumberFormatObject
:
:
SLOT_COUNT
)
|
JSCLASS_FOREGROUND_FINALIZE
&
NumberFormatObject
:
:
classOps_
}
;
#
if
JS_HAS_TOSOURCE
static
bool
numberFormat_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
NumberFormat
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
numberFormat_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_NumberFormat_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
numberFormat_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_NumberFormat_resolvedOptions
"
0
0
)
JS_SELF_HOSTED_FN
(
"
formatToParts
"
"
Intl_NumberFormat_formatToParts
"
1
0
)
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
numberFormat_toSource
0
0
)
#
endif
JS_FS_END
}
;
static
const
JSPropertySpec
numberFormat_properties
[
]
=
{
JS_SELF_HOSTED_GET
(
"
format
"
"
Intl_NumberFormat_format_get
"
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Object
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
bool
NumberFormat
(
JSContext
*
cx
const
CallArgs
&
args
bool
construct
)
{
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreateNumberFormatPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
Rooted
<
NumberFormatObject
*
>
numberFormat
(
cx
)
;
numberFormat
=
NewObjectWithGivenProto
<
NumberFormatObject
>
(
cx
proto
)
;
if
(
!
numberFormat
)
return
false
;
numberFormat
-
>
setReservedSlot
(
NumberFormatObject
:
:
INTERNALS_SLOT
NullValue
(
)
)
;
numberFormat
-
>
setReservedSlot
(
NumberFormatObject
:
:
UNUMBER_FORMAT_SLOT
PrivateValue
(
nullptr
)
)
;
RootedValue
thisValue
(
cx
construct
?
ObjectValue
(
*
numberFormat
)
:
args
.
thisv
(
)
)
;
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
return
intl
:
:
LegacyInitializeObject
(
cx
numberFormat
cx
-
>
names
(
)
.
InitializeNumberFormat
thisValue
locales
options
DateTimeFormatOptions
:
:
Standard
args
.
rval
(
)
)
;
}
static
bool
NumberFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
NumberFormat
(
cx
args
args
.
isConstructing
(
)
)
;
}
bool
js
:
:
intl_NumberFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
args
.
isConstructing
(
)
)
;
return
NumberFormat
(
cx
args
true
)
;
}
void
NumberFormatObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
const
Value
&
slot
=
obj
-
>
as
<
NumberFormatObject
>
(
)
.
getReservedSlot
(
NumberFormatObject
:
:
UNUMBER_FORMAT_SLOT
)
;
if
(
UNumberFormat
*
nf
=
static_cast
<
UNumberFormat
*
>
(
slot
.
toPrivate
(
)
)
)
unum_close
(
nf
)
;
}
static
JSObject
*
CreateNumberFormatPrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
MutableHandleObject
constructor
)
{
RootedFunction
ctor
(
cx
)
;
ctor
=
GlobalObject
:
:
createConstructor
(
cx
&
NumberFormat
cx
-
>
names
(
)
.
NumberFormat
0
)
;
if
(
!
ctor
)
return
nullptr
;
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
ctor
numberFormat_static_methods
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
proto
numberFormat_methods
)
)
return
nullptr
;
if
(
!
JS_DefineProperties
(
cx
proto
numberFormat_properties
)
)
return
nullptr
;
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
NumberFormat
ctorValue
0
)
)
return
nullptr
;
constructor
.
set
(
ctor
)
;
return
proto
;
}
bool
js
:
:
intl_NumberFormat_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
RootedValue
result
(
cx
)
;
if
(
!
GetAvailableLocales
(
cx
unum_countAvailable
unum_getAvailable
&
result
)
)
return
false
;
args
.
rval
(
)
.
set
(
result
)
;
return
true
;
}
bool
js
:
:
intl_numberingSystem
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UNumberingSystem
*
numbers
=
unumsys_open
(
IcuLocale
(
locale
.
ptr
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UNumberingSystem
unumsys_close
>
toClose
(
numbers
)
;
const
char
*
name
=
unumsys_getName
(
numbers
)
;
JSString
*
jsname
=
JS_NewStringCopyZ
(
cx
name
)
;
if
(
!
jsname
)
return
false
;
args
.
rval
(
)
.
setString
(
jsname
)
;
return
true
;
}
static
UNumberFormat
*
NewUNumberFormatForPluralRules
(
JSContext
*
cx
Handle
<
PluralRulesObject
*
>
pluralRules
)
{
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
pluralRules
)
)
;
if
(
!
internals
)
return
nullptr
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
nullptr
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
nullptr
;
uint32_t
uMinimumIntegerDigits
=
1
;
uint32_t
uMinimumFractionDigits
=
0
;
uint32_t
uMaximumFractionDigits
=
3
;
int32_t
uMinimumSignificantDigits
=
-
1
;
int32_t
uMaximumSignificantDigits
=
-
1
;
bool
hasP
;
if
(
!
HasProperty
(
cx
internals
cx
-
>
names
(
)
.
minimumSignificantDigits
&
hasP
)
)
return
nullptr
;
if
(
hasP
)
{
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumSignificantDigits
&
value
)
)
return
nullptr
;
uMinimumSignificantDigits
=
value
.
toInt32
(
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
maximumSignificantDigits
&
value
)
)
return
nullptr
;
uMaximumSignificantDigits
=
value
.
toInt32
(
)
;
}
else
{
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumIntegerDigits
&
value
)
)
return
nullptr
;
uMinimumIntegerDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumFractionDigits
&
value
)
)
return
nullptr
;
uMinimumFractionDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
maximumFractionDigits
&
value
)
)
return
nullptr
;
uMaximumFractionDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UNumberFormat
*
nf
=
unum_open
(
UNUM_DECIMAL
nullptr
0
IcuLocale
(
locale
.
ptr
(
)
)
nullptr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ScopedICUObject
<
UNumberFormat
unum_close
>
toClose
(
nf
)
;
if
(
uMinimumSignificantDigits
!
=
-
1
)
{
unum_setAttribute
(
nf
UNUM_SIGNIFICANT_DIGITS_USED
true
)
;
unum_setAttribute
(
nf
UNUM_MIN_SIGNIFICANT_DIGITS
uMinimumSignificantDigits
)
;
unum_setAttribute
(
nf
UNUM_MAX_SIGNIFICANT_DIGITS
uMaximumSignificantDigits
)
;
}
else
{
unum_setAttribute
(
nf
UNUM_MIN_INTEGER_DIGITS
uMinimumIntegerDigits
)
;
unum_setAttribute
(
nf
UNUM_MIN_FRACTION_DIGITS
uMinimumFractionDigits
)
;
unum_setAttribute
(
nf
UNUM_MAX_FRACTION_DIGITS
uMaximumFractionDigits
)
;
}
return
toClose
.
forget
(
)
;
}
static
UNumberFormat
*
NewUNumberFormat
(
JSContext
*
cx
Handle
<
NumberFormatObject
*
>
numberFormat
)
{
RootedValue
value
(
cx
)
;
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
numberFormat
)
)
;
if
(
!
internals
)
return
nullptr
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
nullptr
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
nullptr
;
UNumberFormatStyle
uStyle
=
UNUM_DECIMAL
;
const
UChar
*
uCurrency
=
nullptr
;
uint32_t
uMinimumIntegerDigits
=
1
;
uint32_t
uMinimumFractionDigits
=
0
;
uint32_t
uMaximumFractionDigits
=
3
;
int32_t
uMinimumSignificantDigits
=
-
1
;
int32_t
uMaximumSignificantDigits
=
-
1
;
bool
uUseGrouping
=
true
;
RootedString
currency
(
cx
)
;
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
style
&
value
)
)
return
nullptr
;
{
JSLinearString
*
style
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
style
)
return
nullptr
;
if
(
StringEqualsAscii
(
style
"
currency
"
)
)
{
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
currency
&
value
)
)
return
nullptr
;
currency
=
value
.
toString
(
)
;
MOZ_ASSERT
(
currency
-
>
length
(
)
=
=
3
"
IsWellFormedCurrencyCode
permits
only
length
-
3
strings
"
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
currency
)
)
return
nullptr
;
uCurrency
=
stableChars
.
twoByteRange
(
)
.
begin
(
)
.
get
(
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
currencyDisplay
&
value
)
)
return
nullptr
;
JSLinearString
*
currencyDisplay
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
currencyDisplay
)
return
nullptr
;
if
(
StringEqualsAscii
(
currencyDisplay
"
code
"
)
)
{
uStyle
=
UNUM_CURRENCY_ISO
;
}
else
if
(
StringEqualsAscii
(
currencyDisplay
"
symbol
"
)
)
{
uStyle
=
UNUM_CURRENCY
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
currencyDisplay
"
name
"
)
)
;
uStyle
=
UNUM_CURRENCY_PLURAL
;
}
}
else
if
(
StringEqualsAscii
(
style
"
percent
"
)
)
{
uStyle
=
UNUM_PERCENT
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
style
"
decimal
"
)
)
;
uStyle
=
UNUM_DECIMAL
;
}
}
bool
hasP
;
if
(
!
HasProperty
(
cx
internals
cx
-
>
names
(
)
.
minimumSignificantDigits
&
hasP
)
)
return
nullptr
;
if
(
hasP
)
{
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumSignificantDigits
&
value
)
)
return
nullptr
;
uMinimumSignificantDigits
=
value
.
toInt32
(
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
maximumSignificantDigits
&
value
)
)
return
nullptr
;
uMaximumSignificantDigits
=
value
.
toInt32
(
)
;
}
else
{
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumIntegerDigits
&
value
)
)
return
nullptr
;
uMinimumIntegerDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
minimumFractionDigits
&
value
)
)
return
nullptr
;
uMinimumFractionDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
maximumFractionDigits
&
value
)
)
return
nullptr
;
uMaximumFractionDigits
=
AssertedCast
<
uint32_t
>
(
value
.
toInt32
(
)
)
;
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
useGrouping
&
value
)
)
return
nullptr
;
uUseGrouping
=
value
.
toBoolean
(
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UNumberFormat
*
nf
=
unum_open
(
uStyle
nullptr
0
IcuLocale
(
locale
.
ptr
(
)
)
nullptr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ScopedICUObject
<
UNumberFormat
unum_close
>
toClose
(
nf
)
;
if
(
uCurrency
)
{
unum_setTextAttribute
(
nf
UNUM_CURRENCY_CODE
uCurrency
3
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
}
if
(
uMinimumSignificantDigits
!
=
-
1
)
{
unum_setAttribute
(
nf
UNUM_SIGNIFICANT_DIGITS_USED
true
)
;
unum_setAttribute
(
nf
UNUM_MIN_SIGNIFICANT_DIGITS
uMinimumSignificantDigits
)
;
unum_setAttribute
(
nf
UNUM_MAX_SIGNIFICANT_DIGITS
uMaximumSignificantDigits
)
;
}
else
{
unum_setAttribute
(
nf
UNUM_MIN_INTEGER_DIGITS
uMinimumIntegerDigits
)
;
unum_setAttribute
(
nf
UNUM_MIN_FRACTION_DIGITS
uMinimumFractionDigits
)
;
unum_setAttribute
(
nf
UNUM_MAX_FRACTION_DIGITS
uMaximumFractionDigits
)
;
}
unum_setAttribute
(
nf
UNUM_GROUPING_USED
uUseGrouping
)
;
unum_setAttribute
(
nf
UNUM_ROUNDING_MODE
UNUM_ROUND_HALFUP
)
;
return
toClose
.
forget
(
)
;
}
static
JSString
*
PartitionNumberPattern
(
JSContext
*
cx
UNumberFormat
*
nf
double
*
x
UFieldPositionIterator
*
fpositer
)
{
if
(
IsNegativeZero
(
*
x
)
)
*
x
=
0
.
0
;
return
CallICU
(
cx
[
nf
x
fpositer
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
unum_formatDoubleForFields
(
nf
*
x
chars
size
fpositer
status
)
;
}
)
;
}
static
bool
intl_FormatNumber
(
JSContext
*
cx
UNumberFormat
*
nf
double
x
MutableHandleValue
result
)
{
JSString
*
str
=
PartitionNumberPattern
(
cx
nf
&
x
nullptr
)
;
if
(
!
str
)
return
false
;
result
.
setString
(
str
)
;
return
true
;
}
using
FieldType
=
ImmutablePropertyNamePtr
JSAtomState
:
:
*
;
static
FieldType
GetFieldTypeForNumberField
(
UNumberFormatFields
fieldName
double
d
)
{
switch
(
fieldName
)
{
case
UNUM_INTEGER_FIELD
:
if
(
IsNaN
(
d
)
)
return
&
JSAtomState
:
:
nan
;
if
(
!
IsFinite
(
d
)
)
return
&
JSAtomState
:
:
infinity
;
return
&
JSAtomState
:
:
integer
;
case
UNUM_GROUPING_SEPARATOR_FIELD
:
return
&
JSAtomState
:
:
group
;
case
UNUM_DECIMAL_SEPARATOR_FIELD
:
return
&
JSAtomState
:
:
decimal
;
case
UNUM_FRACTION_FIELD
:
return
&
JSAtomState
:
:
fraction
;
case
UNUM_SIGN_FIELD
:
{
MOZ_ASSERT
(
!
IsNegativeZero
(
d
)
"
-
0
should
have
been
excluded
by
PartitionNumberPattern
"
)
;
return
d
<
0
?
&
JSAtomState
:
:
minusSign
:
&
JSAtomState
:
:
plusSign
;
}
case
UNUM_PERCENT_FIELD
:
return
&
JSAtomState
:
:
percentSign
;
case
UNUM_CURRENCY_FIELD
:
return
&
JSAtomState
:
:
currency
;
case
UNUM_PERMILL_FIELD
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
permill
field
found
even
though
"
"
we
don
'
t
use
any
user
-
defined
patterns
that
"
"
would
require
a
permill
field
"
)
;
break
;
case
UNUM_EXPONENT_SYMBOL_FIELD
:
case
UNUM_EXPONENT_SIGN_FIELD
:
case
UNUM_EXPONENT_FIELD
:
MOZ_ASSERT_UNREACHABLE
(
"
exponent
field
unexpectedly
found
in
"
"
formatted
number
even
though
UNUM_SCIENTIFIC
"
"
and
scientific
notation
were
never
requested
"
)
;
break
;
#
ifndef
U_HIDE_DEPRECATED_API
case
UNUM_FIELD_COUNT
:
MOZ_ASSERT_UNREACHABLE
(
"
format
field
sentinel
value
returned
by
"
"
iterator
!
"
)
;
break
;
#
endif
}
MOZ_ASSERT_UNREACHABLE
(
"
unenumerated
undocumented
format
field
returned
"
"
by
iterator
"
)
;
return
nullptr
;
}
static
bool
intl_FormatNumberToParts
(
JSContext
*
cx
UNumberFormat
*
nf
double
x
MutableHandleValue
result
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UFieldPositionIterator
*
fpositer
=
ufieldpositer_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
MOZ_ASSERT
(
fpositer
)
;
ScopedICUObject
<
UFieldPositionIterator
ufieldpositer_close
>
toClose
(
fpositer
)
;
RootedString
overallResult
(
cx
PartitionNumberPattern
(
cx
nf
&
x
fpositer
)
)
;
if
(
!
overallResult
)
return
false
;
RootedArrayObject
partsArray
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
partsArray
)
return
false
;
struct
Field
{
uint32_t
begin
;
uint32_t
end
;
FieldType
type
;
Field
(
)
=
default
;
Field
(
uint32_t
begin
uint32_t
end
FieldType
type
)
:
begin
(
begin
)
end
(
end
)
type
(
type
)
{
}
}
;
using
FieldsVector
=
Vector
<
Field
16
>
;
FieldsVector
fields
(
cx
)
;
int32_t
fieldInt
beginIndexInt
endIndexInt
;
while
(
(
fieldInt
=
ufieldpositer_next
(
fpositer
&
beginIndexInt
&
endIndexInt
)
)
>
=
0
)
{
MOZ_ASSERT
(
beginIndexInt
>
=
0
)
;
MOZ_ASSERT
(
endIndexInt
>
=
0
)
;
MOZ_ASSERT
(
beginIndexInt
<
endIndexInt
"
erm
aren
'
t
fields
always
non
-
empty
?
"
)
;
FieldType
type
=
GetFieldTypeForNumberField
(
UNumberFormatFields
(
fieldInt
)
x
)
;
if
(
!
fields
.
emplaceBack
(
uint32_t
(
beginIndexInt
)
uint32_t
(
endIndexInt
)
type
)
)
return
false
;
}
size_t
fieldsLen
=
fields
.
length
(
)
;
if
(
!
fields
.
resizeUninitialized
(
fieldsLen
*
2
)
)
return
false
;
MOZ_ALWAYS_TRUE
(
MergeSort
(
fields
.
begin
(
)
fieldsLen
fields
.
begin
(
)
+
fieldsLen
[
]
(
const
Field
&
left
const
Field
&
right
bool
*
lessOrEqual
)
{
*
lessOrEqual
=
left
.
begin
<
right
.
begin
|
|
(
left
.
begin
=
=
right
.
begin
&
&
left
.
end
>
right
.
end
)
;
return
true
;
}
)
)
;
if
(
!
fields
.
resize
(
fieldsLen
)
)
return
false
;
struct
Part
{
uint32_t
end
;
FieldType
type
;
}
;
class
PartGenerator
{
const
FieldsVector
&
fields
;
size_t
index
;
uint32_t
lastEnd
;
const
uint32_t
limit
;
Vector
<
size_t
4
>
enclosingFields
;
void
popEnclosingFieldsEndingAt
(
uint32_t
end
)
{
MOZ_ASSERT_IF
(
enclosingFields
.
length
(
)
>
0
fields
[
enclosingFields
.
back
(
)
]
.
end
>
=
end
)
;
while
(
enclosingFields
.
length
(
)
>
0
&
&
fields
[
enclosingFields
.
back
(
)
]
.
end
=
=
end
)
enclosingFields
.
popBack
(
)
;
}
bool
nextPartInternal
(
Part
*
part
)
{
size_t
len
=
fields
.
length
(
)
;
MOZ_ASSERT
(
index
<
=
len
)
;
if
(
index
=
=
len
)
{
if
(
enclosingFields
.
length
(
)
>
0
)
{
const
auto
&
enclosing
=
fields
[
enclosingFields
.
popCopy
(
)
]
;
part
-
>
end
=
enclosing
.
end
;
part
-
>
type
=
enclosing
.
type
;
popEnclosingFieldsEndingAt
(
part
-
>
end
)
;
}
else
{
part
-
>
end
=
limit
;
part
-
>
type
=
&
JSAtomState
:
:
literal
;
}
return
true
;
}
const
Field
*
current
=
&
fields
[
index
]
;
MOZ_ASSERT
(
lastEnd
<
=
current
-
>
begin
)
;
MOZ_ASSERT
(
current
-
>
begin
<
current
-
>
end
)
;
if
(
lastEnd
<
current
-
>
begin
)
{
if
(
enclosingFields
.
length
(
)
>
0
)
{
const
auto
&
enclosing
=
fields
[
enclosingFields
.
back
(
)
]
;
part
-
>
end
=
std
:
:
min
(
enclosing
.
end
current
-
>
begin
)
;
part
-
>
type
=
enclosing
.
type
;
popEnclosingFieldsEndingAt
(
part
-
>
end
)
;
}
else
{
part
-
>
end
=
current
-
>
begin
;
part
-
>
type
=
&
JSAtomState
:
:
literal
;
}
return
true
;
}
const
Field
*
next
;
do
{
current
=
&
fields
[
index
]
;
if
(
+
+
index
=
=
len
)
{
part
-
>
end
=
current
-
>
end
;
part
-
>
type
=
current
-
>
type
;
return
true
;
}
next
=
&
fields
[
index
]
;
MOZ_ASSERT
(
current
-
>
begin
<
=
next
-
>
begin
)
;
MOZ_ASSERT
(
current
-
>
begin
<
next
-
>
end
)
;
if
(
current
-
>
end
>
next
-
>
begin
)
{
if
(
!
enclosingFields
.
append
(
index
-
1
)
)
return
false
;
}
}
while
(
current
-
>
begin
=
=
next
-
>
begin
)
;
part
-
>
type
=
current
-
>
type
;
if
(
current
-
>
end
<
=
next
-
>
begin
)
{
part
-
>
end
=
current
-
>
end
;
popEnclosingFieldsEndingAt
(
part
-
>
end
)
;
}
else
{
part
-
>
end
=
next
-
>
begin
;
}
return
true
;
}
public
:
PartGenerator
(
JSContext
*
cx
const
FieldsVector
&
vec
uint32_t
limit
)
:
fields
(
vec
)
index
(
0
)
lastEnd
(
0
)
limit
(
limit
)
enclosingFields
(
cx
)
{
}
bool
nextPart
(
bool
*
hasPart
Part
*
part
)
{
if
(
lastEnd
=
=
limit
)
{
MOZ_ASSERT
(
enclosingFields
.
length
(
)
=
=
0
)
;
*
hasPart
=
false
;
return
true
;
}
if
(
!
nextPartInternal
(
part
)
)
return
false
;
*
hasPart
=
true
;
lastEnd
=
part
-
>
end
;
return
true
;
}
}
;
size_t
lastEndIndex
=
0
;
uint32_t
partIndex
=
0
;
RootedObject
singlePart
(
cx
)
;
RootedValue
propVal
(
cx
)
;
PartGenerator
gen
(
cx
fields
overallResult
-
>
length
(
)
)
;
do
{
bool
hasPart
;
Part
part
;
if
(
!
gen
.
nextPart
(
&
hasPart
&
part
)
)
return
false
;
if
(
!
hasPart
)
break
;
FieldType
type
=
part
.
type
;
size_t
endIndex
=
part
.
end
;
MOZ_ASSERT
(
lastEndIndex
<
endIndex
)
;
singlePart
=
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
;
if
(
!
singlePart
)
return
false
;
propVal
.
setString
(
cx
-
>
names
(
)
.
*
type
)
;
if
(
!
DefineDataProperty
(
cx
singlePart
cx
-
>
names
(
)
.
type
propVal
)
)
return
false
;
JSLinearString
*
partSubstr
=
NewDependentString
(
cx
overallResult
lastEndIndex
endIndex
-
lastEndIndex
)
;
if
(
!
partSubstr
)
return
false
;
propVal
.
setString
(
partSubstr
)
;
if
(
!
DefineDataProperty
(
cx
singlePart
cx
-
>
names
(
)
.
value
propVal
)
)
return
false
;
propVal
.
setObject
(
*
singlePart
)
;
if
(
!
DefineDataElement
(
cx
partsArray
partIndex
propVal
)
)
return
false
;
lastEndIndex
=
endIndex
;
partIndex
+
+
;
}
while
(
true
)
;
MOZ_ASSERT
(
lastEndIndex
=
=
overallResult
-
>
length
(
)
"
result
array
must
partition
the
entire
string
"
)
;
result
.
setObject
(
*
partsArray
)
;
return
true
;
}
bool
js
:
:
intl_FormatNumber
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isNumber
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isBoolean
(
)
)
;
Rooted
<
NumberFormatObject
*
>
numberFormat
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
NumberFormatObject
>
(
)
)
;
void
*
priv
=
numberFormat
-
>
getReservedSlot
(
NumberFormatObject
:
:
UNUMBER_FORMAT_SLOT
)
.
toPrivate
(
)
;
UNumberFormat
*
nf
=
static_cast
<
UNumberFormat
*
>
(
priv
)
;
if
(
!
nf
)
{
nf
=
NewUNumberFormat
(
cx
numberFormat
)
;
if
(
!
nf
)
return
false
;
numberFormat
-
>
setReservedSlot
(
NumberFormatObject
:
:
UNUMBER_FORMAT_SLOT
PrivateValue
(
nf
)
)
;
}
if
(
args
[
2
]
.
toBoolean
(
)
)
{
return
intl_FormatNumberToParts
(
cx
nf
args
[
1
]
.
toNumber
(
)
args
.
rval
(
)
)
;
}
return
intl_FormatNumber
(
cx
nf
args
[
1
]
.
toNumber
(
)
args
.
rval
(
)
)
;
}
const
ClassOps
DateTimeFormatObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
DateTimeFormatObject
:
:
finalize
}
;
const
Class
DateTimeFormatObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
DateTimeFormatObject
:
:
SLOT_COUNT
)
|
JSCLASS_FOREGROUND_FINALIZE
&
DateTimeFormatObject
:
:
classOps_
}
;
#
if
JS_HAS_TOSOURCE
static
bool
dateTimeFormat_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
DateTimeFormat
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
dateTimeFormat_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_DateTimeFormat_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
dateTimeFormat_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_DateTimeFormat_resolvedOptions
"
0
0
)
JS_SELF_HOSTED_FN
(
"
formatToParts
"
"
Intl_DateTimeFormat_formatToParts
"
1
0
)
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
dateTimeFormat_toSource
0
0
)
#
endif
JS_FS_END
}
;
static
const
JSPropertySpec
dateTimeFormat_properties
[
]
=
{
JS_SELF_HOSTED_GET
(
"
format
"
"
Intl_DateTimeFormat_format_get
"
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Object
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
bool
DateTimeFormat
(
JSContext
*
cx
const
CallArgs
&
args
bool
construct
DateTimeFormatOptions
dtfOptions
)
{
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreateDateTimeFormatPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
Rooted
<
DateTimeFormatObject
*
>
dateTimeFormat
(
cx
)
;
dateTimeFormat
=
NewObjectWithGivenProto
<
DateTimeFormatObject
>
(
cx
proto
)
;
if
(
!
dateTimeFormat
)
return
false
;
dateTimeFormat
-
>
setReservedSlot
(
DateTimeFormatObject
:
:
INTERNALS_SLOT
NullValue
(
)
)
;
dateTimeFormat
-
>
setReservedSlot
(
DateTimeFormatObject
:
:
UDATE_FORMAT_SLOT
PrivateValue
(
nullptr
)
)
;
RootedValue
thisValue
(
cx
construct
?
ObjectValue
(
*
dateTimeFormat
)
:
args
.
thisv
(
)
)
;
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
return
intl
:
:
LegacyInitializeObject
(
cx
dateTimeFormat
cx
-
>
names
(
)
.
InitializeDateTimeFormat
thisValue
locales
options
dtfOptions
args
.
rval
(
)
)
;
}
static
bool
DateTimeFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
DateTimeFormat
(
cx
args
args
.
isConstructing
(
)
DateTimeFormatOptions
:
:
Standard
)
;
}
static
bool
MozDateTimeFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
mozIntl
.
DateTimeFormat
"
)
)
return
false
;
return
DateTimeFormat
(
cx
args
true
DateTimeFormatOptions
:
:
EnableMozExtensions
)
;
}
bool
js
:
:
intl_DateTimeFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
args
.
isConstructing
(
)
)
;
return
DateTimeFormat
(
cx
args
true
DateTimeFormatOptions
:
:
Standard
)
;
}
void
DateTimeFormatObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
const
Value
&
slot
=
obj
-
>
as
<
DateTimeFormatObject
>
(
)
.
getReservedSlot
(
DateTimeFormatObject
:
:
UDATE_FORMAT_SLOT
)
;
if
(
UDateFormat
*
df
=
static_cast
<
UDateFormat
*
>
(
slot
.
toPrivate
(
)
)
)
udat_close
(
df
)
;
}
static
JSObject
*
CreateDateTimeFormatPrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
MutableHandleObject
constructor
DateTimeFormatOptions
dtfOptions
)
{
RootedFunction
ctor
(
cx
)
;
ctor
=
dtfOptions
=
=
DateTimeFormatOptions
:
:
EnableMozExtensions
?
GlobalObject
:
:
createConstructor
(
cx
MozDateTimeFormat
cx
-
>
names
(
)
.
DateTimeFormat
0
)
:
GlobalObject
:
:
createConstructor
(
cx
DateTimeFormat
cx
-
>
names
(
)
.
DateTimeFormat
0
)
;
if
(
!
ctor
)
return
nullptr
;
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
ctor
dateTimeFormat_static_methods
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
proto
dateTimeFormat_methods
)
)
return
nullptr
;
if
(
!
JS_DefineProperties
(
cx
proto
dateTimeFormat_properties
)
)
return
nullptr
;
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
DateTimeFormat
ctorValue
0
)
)
return
nullptr
;
constructor
.
set
(
ctor
)
;
return
proto
;
}
bool
js
:
:
AddMozDateTimeFormatConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
intl
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
mozDateTimeFormat
(
cx
)
;
JSObject
*
mozDateTimeFormatProto
=
CreateDateTimeFormatPrototype
(
cx
intl
global
&
mozDateTimeFormat
DateTimeFormatOptions
:
:
EnableMozExtensions
)
;
return
mozDateTimeFormatProto
!
=
nullptr
;
}
bool
js
:
:
intl_DateTimeFormat_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
RootedValue
result
(
cx
)
;
if
(
!
GetAvailableLocales
(
cx
udat_countAvailable
udat_getAvailable
&
result
)
)
return
false
;
args
.
rval
(
)
.
set
(
result
)
;
return
true
;
}
static
bool
DefaultCalendar
(
JSContext
*
cx
const
JSAutoByteString
&
locale
MutableHandleValue
rval
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UCalendar
*
cal
=
ucal_open
(
nullptr
0
locale
.
ptr
(
)
UCAL_DEFAULT
&
status
)
;
ScopedICUObject
<
UCalendar
ucal_close
>
closeCalendar
(
cal
)
;
const
char
*
calendar
=
ucal_getType
(
cal
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
JSString
*
str
=
JS_NewStringCopyZ
(
cx
uloc_toUnicodeLocaleType
(
"
ca
"
calendar
)
)
;
if
(
!
str
)
return
false
;
rval
.
setString
(
str
)
;
return
true
;
}
struct
CalendarAlias
{
const
char
*
const
calendar
;
const
char
*
const
alias
;
}
;
const
CalendarAlias
calendarAliases
[
]
=
{
{
"
islamic
-
civil
"
"
islamicc
"
}
{
"
ethioaa
"
"
ethiopic
-
amete
-
alem
"
}
}
;
bool
js
:
:
intl_availableCalendars
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
RootedObject
calendars
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
calendars
)
return
false
;
uint32_t
index
=
0
;
RootedValue
element
(
cx
)
;
if
(
!
DefaultCalendar
(
cx
locale
&
element
)
)
return
false
;
if
(
!
DefineDataElement
(
cx
calendars
index
+
+
element
)
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
values
=
ucal_getKeywordValuesForLocale
(
"
ca
"
locale
.
ptr
(
)
false
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UEnumeration
uenum_close
>
toClose
(
values
)
;
uint32_t
count
=
uenum_count
(
values
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
for
(
;
count
>
0
;
count
-
-
)
{
const
char
*
calendar
=
uenum_next
(
values
nullptr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
calendar
=
uloc_toUnicodeLocaleType
(
"
ca
"
calendar
)
;
JSString
*
jscalendar
=
JS_NewStringCopyZ
(
cx
calendar
)
;
if
(
!
jscalendar
)
return
false
;
element
=
StringValue
(
jscalendar
)
;
if
(
!
DefineDataElement
(
cx
calendars
index
+
+
element
)
)
return
false
;
for
(
const
auto
&
calendarAlias
:
calendarAliases
)
{
if
(
StringsAreEqual
(
calendar
calendarAlias
.
calendar
)
)
{
JSString
*
jscalendar
=
JS_NewStringCopyZ
(
cx
calendarAlias
.
alias
)
;
if
(
!
jscalendar
)
return
false
;
element
=
StringValue
(
jscalendar
)
;
if
(
!
DefineDataElement
(
cx
calendars
index
+
+
element
)
)
return
false
;
}
}
}
args
.
rval
(
)
.
setObject
(
*
calendars
)
;
return
true
;
}
bool
js
:
:
intl_defaultCalendar
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
return
DefaultCalendar
(
cx
locale
args
.
rval
(
)
)
;
}
template
<
typename
Char
>
static
constexpr
Char
ToUpperASCII
(
Char
c
)
{
return
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
?
(
c
&
~
0x20
)
:
c
;
}
static_assert
(
ToUpperASCII
(
'
a
'
)
=
=
'
A
'
"
verifying
'
a
'
uppercases
correctly
"
)
;
static_assert
(
ToUpperASCII
(
'
m
'
)
=
=
'
M
'
"
verifying
'
m
'
uppercases
correctly
"
)
;
static_assert
(
ToUpperASCII
(
'
z
'
)
=
=
'
Z
'
"
verifying
'
z
'
uppercases
correctly
"
)
;
static_assert
(
ToUpperASCII
(
u
'
a
'
)
=
=
u
'
A
'
"
verifying
u
'
a
'
uppercases
correctly
"
)
;
static_assert
(
ToUpperASCII
(
u
'
k
'
)
=
=
u
'
K
'
"
verifying
u
'
k
'
uppercases
correctly
"
)
;
static_assert
(
ToUpperASCII
(
u
'
z
'
)
=
=
u
'
Z
'
"
verifying
u
'
z
'
uppercases
correctly
"
)
;
template
<
typename
Char1
typename
Char2
>
static
bool
EqualCharsIgnoreCaseASCII
(
const
Char1
*
s1
const
Char2
*
s2
size_t
len
)
{
for
(
const
Char1
*
s1end
=
s1
+
len
;
s1
<
s1end
;
s1
+
+
s2
+
+
)
{
if
(
ToUpperASCII
(
*
s1
)
!
=
ToUpperASCII
(
*
s2
)
)
return
false
;
}
return
true
;
}
template
<
typename
Char
>
static
js
:
:
HashNumber
HashStringIgnoreCaseASCII
(
const
Char
*
s
size_t
length
)
{
uint32_t
hash
=
0
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
hash
=
mozilla
:
:
AddToHash
(
hash
ToUpperASCII
(
s
[
i
]
)
)
;
return
hash
;
}
js
:
:
SharedIntlData
:
:
TimeZoneHasher
:
:
Lookup
:
:
Lookup
(
JSLinearString
*
timeZone
)
:
js
:
:
SharedIntlData
:
:
LinearStringLookup
(
timeZone
)
{
if
(
isLatin1
)
hash
=
HashStringIgnoreCaseASCII
(
latin1Chars
length
)
;
else
hash
=
HashStringIgnoreCaseASCII
(
twoByteChars
length
)
;
}
bool
js
:
:
SharedIntlData
:
:
TimeZoneHasher
:
:
match
(
TimeZoneName
key
const
Lookup
&
lookup
)
{
if
(
key
-
>
length
(
)
!
=
lookup
.
length
)
return
false
;
if
(
key
-
>
hasLatin1Chars
(
)
)
{
const
Latin1Char
*
keyChars
=
key
-
>
latin1Chars
(
lookup
.
nogc
)
;
if
(
lookup
.
isLatin1
)
return
EqualCharsIgnoreCaseASCII
(
keyChars
lookup
.
latin1Chars
lookup
.
length
)
;
return
EqualCharsIgnoreCaseASCII
(
keyChars
lookup
.
twoByteChars
lookup
.
length
)
;
}
const
char16_t
*
keyChars
=
key
-
>
twoByteChars
(
lookup
.
nogc
)
;
if
(
lookup
.
isLatin1
)
return
EqualCharsIgnoreCaseASCII
(
lookup
.
latin1Chars
keyChars
lookup
.
length
)
;
return
EqualCharsIgnoreCaseASCII
(
keyChars
lookup
.
twoByteChars
lookup
.
length
)
;
}
static
bool
IsLegacyICUTimeZone
(
const
char
*
timeZone
)
{
for
(
const
auto
&
legacyTimeZone
:
js
:
:
timezone
:
:
legacyICUTimeZones
)
{
if
(
StringsAreEqual
(
timeZone
legacyTimeZone
)
)
return
true
;
}
return
false
;
}
bool
js
:
:
SharedIntlData
:
:
ensureTimeZones
(
JSContext
*
cx
)
{
if
(
timeZoneDataInitialized
)
return
true
;
if
(
availableTimeZones
.
initialized
(
)
)
availableTimeZones
.
finish
(
)
;
if
(
!
availableTimeZones
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
values
=
ucal_openTimeZones
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UEnumeration
uenum_close
>
toClose
(
values
)
;
RootedAtom
timeZone
(
cx
)
;
while
(
true
)
{
int32_t
size
;
const
char
*
rawTimeZone
=
uenum_next
(
values
&
size
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
rawTimeZone
=
=
nullptr
)
break
;
if
(
IsLegacyICUTimeZone
(
rawTimeZone
)
)
continue
;
MOZ_ASSERT
(
size
>
=
0
)
;
timeZone
=
Atomize
(
cx
rawTimeZone
size_t
(
size
)
)
;
if
(
!
timeZone
)
return
false
;
TimeZoneHasher
:
:
Lookup
lookup
(
timeZone
)
;
TimeZoneSet
:
:
AddPtr
p
=
availableTimeZones
.
lookupForAdd
(
lookup
)
;
if
(
!
p
&
&
!
availableTimeZones
.
add
(
p
timeZone
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
ianaZonesTreatedAsLinksByICU
.
initialized
(
)
)
ianaZonesTreatedAsLinksByICU
.
finish
(
)
;
if
(
!
ianaZonesTreatedAsLinksByICU
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
const
char
*
rawTimeZone
:
timezone
:
:
ianaZonesTreatedAsLinksByICU
)
{
MOZ_ASSERT
(
rawTimeZone
!
=
nullptr
)
;
timeZone
=
Atomize
(
cx
rawTimeZone
strlen
(
rawTimeZone
)
)
;
if
(
!
timeZone
)
return
false
;
TimeZoneHasher
:
:
Lookup
lookup
(
timeZone
)
;
TimeZoneSet
:
:
AddPtr
p
=
ianaZonesTreatedAsLinksByICU
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
"
Duplicate
entry
in
timezone
:
:
ianaZonesTreatedAsLinksByICU
"
)
;
if
(
!
ianaZonesTreatedAsLinksByICU
.
add
(
p
timeZone
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
ianaLinksCanonicalizedDifferentlyByICU
.
initialized
(
)
)
ianaLinksCanonicalizedDifferentlyByICU
.
finish
(
)
;
if
(
!
ianaLinksCanonicalizedDifferentlyByICU
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
RootedAtom
linkName
(
cx
)
;
RootedAtom
&
target
=
timeZone
;
for
(
const
auto
&
linkAndTarget
:
timezone
:
:
ianaLinksCanonicalizedDifferentlyByICU
)
{
const
char
*
rawLinkName
=
linkAndTarget
.
link
;
const
char
*
rawTarget
=
linkAndTarget
.
target
;
MOZ_ASSERT
(
rawLinkName
!
=
nullptr
)
;
linkName
=
Atomize
(
cx
rawLinkName
strlen
(
rawLinkName
)
)
;
if
(
!
linkName
)
return
false
;
MOZ_ASSERT
(
rawTarget
!
=
nullptr
)
;
target
=
Atomize
(
cx
rawTarget
strlen
(
rawTarget
)
)
;
if
(
!
target
)
return
false
;
TimeZoneHasher
:
:
Lookup
lookup
(
linkName
)
;
TimeZoneMap
:
:
AddPtr
p
=
ianaLinksCanonicalizedDifferentlyByICU
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
"
Duplicate
entry
in
timezone
:
:
ianaLinksCanonicalizedDifferentlyByICU
"
)
;
if
(
!
ianaLinksCanonicalizedDifferentlyByICU
.
add
(
p
linkName
target
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
MOZ_ASSERT
(
!
timeZoneDataInitialized
"
ensureTimeZones
is
neither
reentrant
nor
thread
-
safe
"
)
;
timeZoneDataInitialized
=
true
;
return
true
;
}
bool
js
:
:
SharedIntlData
:
:
validateTimeZoneName
(
JSContext
*
cx
HandleString
timeZone
MutableHandleAtom
result
)
{
if
(
!
ensureTimeZones
(
cx
)
)
return
false
;
RootedLinearString
timeZoneLinear
(
cx
timeZone
-
>
ensureLinear
(
cx
)
)
;
if
(
!
timeZoneLinear
)
return
false
;
TimeZoneHasher
:
:
Lookup
lookup
(
timeZoneLinear
)
;
if
(
TimeZoneSet
:
:
Ptr
p
=
availableTimeZones
.
lookup
(
lookup
)
)
result
.
set
(
*
p
)
;
return
true
;
}
bool
js
:
:
SharedIntlData
:
:
tryCanonicalizeTimeZoneConsistentWithIANA
(
JSContext
*
cx
HandleString
timeZone
MutableHandleAtom
result
)
{
if
(
!
ensureTimeZones
(
cx
)
)
return
false
;
RootedLinearString
timeZoneLinear
(
cx
timeZone
-
>
ensureLinear
(
cx
)
)
;
if
(
!
timeZoneLinear
)
return
false
;
TimeZoneHasher
:
:
Lookup
lookup
(
timeZoneLinear
)
;
MOZ_ASSERT
(
availableTimeZones
.
has
(
lookup
)
"
Invalid
time
zone
name
"
)
;
if
(
TimeZoneMap
:
:
Ptr
p
=
ianaLinksCanonicalizedDifferentlyByICU
.
lookup
(
lookup
)
)
{
TimeZoneName
targetTimeZone
=
p
-
>
value
(
)
;
TimeZoneHasher
:
:
Lookup
targetLookup
(
targetTimeZone
)
;
if
(
availableTimeZones
.
has
(
targetLookup
)
)
result
.
set
(
targetTimeZone
)
;
}
else
if
(
TimeZoneSet
:
:
Ptr
p
=
ianaZonesTreatedAsLinksByICU
.
lookup
(
lookup
)
)
{
result
.
set
(
*
p
)
;
}
return
true
;
}
void
js
:
:
SharedIntlData
:
:
destroyInstance
(
)
{
availableTimeZones
.
finish
(
)
;
ianaZonesTreatedAsLinksByICU
.
finish
(
)
;
ianaLinksCanonicalizedDifferentlyByICU
.
finish
(
)
;
upperCaseFirstLocales
.
finish
(
)
;
}
void
js
:
:
SharedIntlData
:
:
trace
(
JSTracer
*
trc
)
{
if
(
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
{
availableTimeZones
.
trace
(
trc
)
;
ianaZonesTreatedAsLinksByICU
.
trace
(
trc
)
;
ianaLinksCanonicalizedDifferentlyByICU
.
trace
(
trc
)
;
upperCaseFirstLocales
.
trace
(
trc
)
;
}
}
size_t
js
:
:
SharedIntlData
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
availableTimeZones
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
ianaZonesTreatedAsLinksByICU
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
ianaLinksCanonicalizedDifferentlyByICU
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
upperCaseFirstLocales
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
js
:
:
intl_IsValidTimeZoneName
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
RootedString
timeZone
(
cx
args
[
0
]
.
toString
(
)
)
;
RootedAtom
validatedTimeZone
(
cx
)
;
if
(
!
sharedIntlData
.
validateTimeZoneName
(
cx
timeZone
&
validatedTimeZone
)
)
return
false
;
if
(
validatedTimeZone
)
{
cx
-
>
markAtom
(
validatedTimeZone
)
;
args
.
rval
(
)
.
setString
(
validatedTimeZone
)
;
}
else
{
args
.
rval
(
)
.
setNull
(
)
;
}
return
true
;
}
bool
js
:
:
intl_canonicalizeTimeZone
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
RootedString
timeZone
(
cx
args
[
0
]
.
toString
(
)
)
;
RootedAtom
ianaTimeZone
(
cx
)
;
if
(
!
sharedIntlData
.
tryCanonicalizeTimeZoneConsistentWithIANA
(
cx
timeZone
&
ianaTimeZone
)
)
return
false
;
if
(
ianaTimeZone
)
{
cx
-
>
markAtom
(
ianaTimeZone
)
;
args
.
rval
(
)
.
setString
(
ianaTimeZone
)
;
return
true
;
}
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
timeZone
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
tzchars
=
stableChars
.
twoByteRange
(
)
;
JSString
*
str
=
CallICU
(
cx
[
&
tzchars
]
(
UChar
*
chars
uint32_t
size
UErrorCode
*
status
)
{
return
ucal_getCanonicalTimeZoneID
(
tzchars
.
begin
(
)
.
get
(
)
tzchars
.
length
(
)
chars
size
nullptr
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_defaultTimeZone
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
js
:
:
ResyncICUDefaultTimeZone
(
)
;
JSString
*
str
=
CallICU
(
cx
ucal_getDefaultTimeZone
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_defaultTimeZoneOffset
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
const
UChar
*
uTimeZone
=
nullptr
;
int32_t
uTimeZoneLength
=
0
;
const
char
*
rootLocale
=
"
"
;
UCalendar
*
cal
=
ucal_open
(
uTimeZone
uTimeZoneLength
rootLocale
UCAL_DEFAULT
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UCalendar
ucal_close
>
toClose
(
cal
)
;
int32_t
offset
=
ucal_get
(
cal
UCAL_ZONE_OFFSET
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
args
.
rval
(
)
.
setInt32
(
offset
)
;
return
true
;
}
bool
js
:
:
intl_isDefaultTimeZone
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
|
|
args
[
0
]
.
isUndefined
(
)
)
;
if
(
args
[
0
]
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
js
:
:
ResyncICUDefaultTimeZone
(
)
;
Vector
<
char16_t
INITIAL_CHAR_BUFFER_SIZE
>
chars
(
cx
)
;
int32_t
size
=
CallICU
(
cx
ucal_getDefaultTimeZone
chars
)
;
if
(
size
<
0
)
return
false
;
JSLinearString
*
str
=
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
str
)
return
false
;
bool
equals
;
if
(
str
-
>
length
(
)
=
=
size_t
(
size
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
equals
=
str
-
>
hasLatin1Chars
(
)
?
EqualChars
(
str
-
>
latin1Chars
(
nogc
)
chars
.
begin
(
)
str
-
>
length
(
)
)
:
EqualChars
(
str
-
>
twoByteChars
(
nogc
)
chars
.
begin
(
)
str
-
>
length
(
)
)
;
}
else
{
equals
=
false
;
}
args
.
rval
(
)
.
setBoolean
(
equals
)
;
return
true
;
}
bool
js
:
:
intl_patternForSkeleton
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
AutoStableStringChars
skeleton
(
cx
)
;
if
(
!
skeleton
.
initTwoByte
(
cx
args
[
1
]
.
toString
(
)
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
skelChars
=
skeleton
.
twoByteRange
(
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UDateTimePatternGenerator
*
gen
=
udatpg_open
(
IcuLocale
(
locale
.
ptr
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UDateTimePatternGenerator
udatpg_close
>
toClose
(
gen
)
;
JSString
*
str
=
CallICU
(
cx
[
gen
&
skelChars
]
(
UChar
*
chars
uint32_t
size
UErrorCode
*
status
)
{
return
udatpg_getBestPattern
(
gen
skelChars
.
begin
(
)
.
get
(
)
skelChars
.
length
(
)
chars
size
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_patternForStyle
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
4
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
UDateFormatStyle
dateStyle
=
UDAT_NONE
;
UDateFormatStyle
timeStyle
=
UDAT_NONE
;
if
(
args
[
1
]
.
isString
(
)
)
{
JSLinearString
*
dateStyleStr
=
args
[
1
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
dateStyleStr
)
return
false
;
if
(
StringEqualsAscii
(
dateStyleStr
"
full
"
)
)
dateStyle
=
UDAT_FULL
;
else
if
(
StringEqualsAscii
(
dateStyleStr
"
long
"
)
)
dateStyle
=
UDAT_LONG
;
else
if
(
StringEqualsAscii
(
dateStyleStr
"
medium
"
)
)
dateStyle
=
UDAT_MEDIUM
;
else
if
(
StringEqualsAscii
(
dateStyleStr
"
short
"
)
)
dateStyle
=
UDAT_SHORT
;
else
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
dateStyle
"
)
;
}
if
(
args
[
2
]
.
isString
(
)
)
{
JSLinearString
*
timeStyleStr
=
args
[
2
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
timeStyleStr
)
return
false
;
if
(
StringEqualsAscii
(
timeStyleStr
"
full
"
)
)
timeStyle
=
UDAT_FULL
;
else
if
(
StringEqualsAscii
(
timeStyleStr
"
long
"
)
)
timeStyle
=
UDAT_LONG
;
else
if
(
StringEqualsAscii
(
timeStyleStr
"
medium
"
)
)
timeStyle
=
UDAT_MEDIUM
;
else
if
(
StringEqualsAscii
(
timeStyleStr
"
short
"
)
)
timeStyle
=
UDAT_SHORT
;
else
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
timeStyle
"
)
;
}
AutoStableStringChars
timeZone
(
cx
)
;
if
(
!
timeZone
.
initTwoByte
(
cx
args
[
3
]
.
toString
(
)
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
timeZoneChars
=
timeZone
.
twoByteRange
(
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UDateFormat
*
df
=
udat_open
(
timeStyle
dateStyle
IcuLocale
(
locale
.
ptr
(
)
)
timeZoneChars
.
begin
(
)
.
get
(
)
timeZoneChars
.
length
(
)
nullptr
-
1
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UDateFormat
udat_close
>
toClose
(
df
)
;
JSString
*
str
=
CallICU
(
cx
[
df
]
(
UChar
*
chars
uint32_t
size
UErrorCode
*
status
)
{
return
udat_toPattern
(
df
false
chars
size
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
UDateFormat
*
NewUDateFormat
(
JSContext
*
cx
Handle
<
DateTimeFormatObject
*
>
dateTimeFormat
)
{
RootedValue
value
(
cx
)
;
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
dateTimeFormat
)
)
;
if
(
!
internals
)
return
nullptr
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
nullptr
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
nullptr
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
timeZone
&
value
)
)
return
nullptr
;
AutoStableStringChars
timeZone
(
cx
)
;
if
(
!
timeZone
.
initTwoByte
(
cx
value
.
toString
(
)
)
)
return
nullptr
;
mozilla
:
:
Range
<
const
char16_t
>
timeZoneChars
=
timeZone
.
twoByteRange
(
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
pattern
&
value
)
)
return
nullptr
;
AutoStableStringChars
pattern
(
cx
)
;
if
(
!
pattern
.
initTwoByte
(
cx
value
.
toString
(
)
)
)
return
nullptr
;
mozilla
:
:
Range
<
const
char16_t
>
patternChars
=
pattern
.
twoByteRange
(
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UDateFormat
*
df
=
udat_open
(
UDAT_PATTERN
UDAT_PATTERN
IcuLocale
(
locale
.
ptr
(
)
)
timeZoneChars
.
begin
(
)
.
get
(
)
timeZoneChars
.
length
(
)
patternChars
.
begin
(
)
.
get
(
)
patternChars
.
length
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
UCalendar
*
cal
=
const_cast
<
UCalendar
*
>
(
udat_getCalendar
(
df
)
)
;
ucal_setGregorianChange
(
cal
StartOfTime
&
status
)
;
return
df
;
}
static
bool
intl_FormatDateTime
(
JSContext
*
cx
UDateFormat
*
df
ClippedTime
x
MutableHandleValue
result
)
{
MOZ_ASSERT
(
x
.
isValid
(
)
)
;
JSString
*
str
=
CallICU
(
cx
[
df
x
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
udat_format
(
df
x
.
toDouble
(
)
chars
size
nullptr
status
)
;
}
)
;
if
(
!
str
)
return
false
;
result
.
setString
(
str
)
;
return
true
;
}
static
FieldType
GetFieldTypeForFormatField
(
UDateFormatField
fieldName
)
{
switch
(
fieldName
)
{
case
UDAT_ERA_FIELD
:
return
&
JSAtomState
:
:
era
;
case
UDAT_YEAR_FIELD
:
case
UDAT_YEAR_WOY_FIELD
:
case
UDAT_EXTENDED_YEAR_FIELD
:
case
UDAT_YEAR_NAME_FIELD
:
return
&
JSAtomState
:
:
year
;
case
UDAT_MONTH_FIELD
:
case
UDAT_STANDALONE_MONTH_FIELD
:
return
&
JSAtomState
:
:
month
;
case
UDAT_DATE_FIELD
:
case
UDAT_JULIAN_DAY_FIELD
:
return
&
JSAtomState
:
:
day
;
case
UDAT_HOUR_OF_DAY1_FIELD
:
case
UDAT_HOUR_OF_DAY0_FIELD
:
case
UDAT_HOUR1_FIELD
:
case
UDAT_HOUR0_FIELD
:
return
&
JSAtomState
:
:
hour
;
case
UDAT_MINUTE_FIELD
:
return
&
JSAtomState
:
:
minute
;
case
UDAT_SECOND_FIELD
:
return
&
JSAtomState
:
:
second
;
case
UDAT_DAY_OF_WEEK_FIELD
:
case
UDAT_STANDALONE_DAY_FIELD
:
case
UDAT_DOW_LOCAL_FIELD
:
case
UDAT_DAY_OF_WEEK_IN_MONTH_FIELD
:
return
&
JSAtomState
:
:
weekday
;
case
UDAT_AM_PM_FIELD
:
return
&
JSAtomState
:
:
dayPeriod
;
case
UDAT_TIMEZONE_FIELD
:
return
&
JSAtomState
:
:
timeZoneName
;
case
UDAT_FRACTIONAL_SECOND_FIELD
:
case
UDAT_DAY_OF_YEAR_FIELD
:
case
UDAT_WEEK_OF_YEAR_FIELD
:
case
UDAT_WEEK_OF_MONTH_FIELD
:
case
UDAT_MILLISECONDS_IN_DAY_FIELD
:
case
UDAT_TIMEZONE_RFC_FIELD
:
case
UDAT_TIMEZONE_GENERIC_FIELD
:
case
UDAT_QUARTER_FIELD
:
case
UDAT_STANDALONE_QUARTER_FIELD
:
case
UDAT_TIMEZONE_SPECIAL_FIELD
:
case
UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD
:
case
UDAT_TIMEZONE_ISO_FIELD
:
case
UDAT_TIMEZONE_ISO_LOCAL_FIELD
:
#
ifndef
U_HIDE_INTERNAL_API
case
UDAT_RELATED_YEAR_FIELD
:
#
endif
case
UDAT_AM_PM_MIDNIGHT_NOON_FIELD
:
case
UDAT_FLEXIBLE_DAY_PERIOD_FIELD
:
#
ifndef
U_HIDE_INTERNAL_API
case
UDAT_TIME_SEPARATOR_FIELD
:
#
endif
return
nullptr
;
#
ifndef
U_HIDE_DEPRECATED_API
case
UDAT_FIELD_COUNT
:
MOZ_ASSERT_UNREACHABLE
(
"
format
field
sentinel
value
returned
by
"
"
iterator
!
"
)
;
#
endif
}
MOZ_ASSERT_UNREACHABLE
(
"
unenumerated
undocumented
format
field
returned
"
"
by
iterator
"
)
;
return
nullptr
;
}
static
bool
intl_FormatToPartsDateTime
(
JSContext
*
cx
UDateFormat
*
df
ClippedTime
x
MutableHandleValue
result
)
{
MOZ_ASSERT
(
x
.
isValid
(
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UFieldPositionIterator
*
fpositer
=
ufieldpositer_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UFieldPositionIterator
ufieldpositer_close
>
toClose
(
fpositer
)
;
RootedString
overallResult
(
cx
)
;
overallResult
=
CallICU
(
cx
[
df
x
fpositer
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
udat_formatForFields
(
df
x
.
toDouble
(
)
chars
size
fpositer
status
)
;
}
)
;
if
(
!
overallResult
)
return
false
;
RootedArrayObject
partsArray
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
partsArray
)
return
false
;
if
(
overallResult
-
>
length
(
)
=
=
0
)
{
result
.
setObject
(
*
partsArray
)
;
return
true
;
}
size_t
lastEndIndex
=
0
;
uint32_t
partIndex
=
0
;
RootedObject
singlePart
(
cx
)
;
RootedValue
partType
(
cx
)
;
RootedValue
val
(
cx
)
;
auto
AppendPart
=
[
&
]
(
FieldType
type
size_t
beginIndex
size_t
endIndex
)
{
singlePart
=
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
;
if
(
!
singlePart
)
return
false
;
partType
=
StringValue
(
cx
-
>
names
(
)
.
*
type
)
;
if
(
!
DefineDataProperty
(
cx
singlePart
cx
-
>
names
(
)
.
type
partType
)
)
return
false
;
JSLinearString
*
partSubstr
=
NewDependentString
(
cx
overallResult
beginIndex
endIndex
-
beginIndex
)
;
if
(
!
partSubstr
)
return
false
;
val
=
StringValue
(
partSubstr
)
;
if
(
!
DefineDataProperty
(
cx
singlePart
cx
-
>
names
(
)
.
value
val
)
)
return
false
;
val
=
ObjectValue
(
*
singlePart
)
;
if
(
!
DefineDataElement
(
cx
partsArray
partIndex
val
)
)
return
false
;
lastEndIndex
=
endIndex
;
partIndex
+
+
;
return
true
;
}
;
int32_t
fieldInt
beginIndexInt
endIndexInt
;
while
(
(
fieldInt
=
ufieldpositer_next
(
fpositer
&
beginIndexInt
&
endIndexInt
)
)
>
=
0
)
{
MOZ_ASSERT
(
beginIndexInt
>
=
0
)
;
MOZ_ASSERT
(
endIndexInt
>
=
0
)
;
MOZ_ASSERT
(
beginIndexInt
<
=
endIndexInt
"
field
iterator
returning
invalid
range
"
)
;
size_t
beginIndex
(
beginIndexInt
)
;
size_t
endIndex
(
endIndexInt
)
;
MOZ_ASSERT
(
lastEndIndex
<
=
beginIndex
"
field
iteration
didn
'
t
return
fields
in
order
start
to
"
"
finish
as
expected
"
)
;
if
(
FieldType
type
=
GetFieldTypeForFormatField
(
static_cast
<
UDateFormatField
>
(
fieldInt
)
)
)
{
if
(
lastEndIndex
<
beginIndex
)
{
if
(
!
AppendPart
(
&
JSAtomState
:
:
literal
lastEndIndex
beginIndex
)
)
return
false
;
}
if
(
!
AppendPart
(
type
beginIndex
endIndex
)
)
return
false
;
}
}
if
(
lastEndIndex
<
overallResult
-
>
length
(
)
)
{
if
(
!
AppendPart
(
&
JSAtomState
:
:
literal
lastEndIndex
overallResult
-
>
length
(
)
)
)
return
false
;
}
result
.
setObject
(
*
partsArray
)
;
return
true
;
}
bool
js
:
:
intl_FormatDateTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isNumber
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isBoolean
(
)
)
;
Rooted
<
DateTimeFormatObject
*
>
dateTimeFormat
(
cx
)
;
dateTimeFormat
=
&
args
[
0
]
.
toObject
(
)
.
as
<
DateTimeFormatObject
>
(
)
;
ClippedTime
x
=
TimeClip
(
args
[
1
]
.
toNumber
(
)
)
;
if
(
!
x
.
isValid
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DATE_NOT_FINITE
)
;
return
false
;
}
void
*
priv
=
dateTimeFormat
-
>
getReservedSlot
(
DateTimeFormatObject
:
:
UDATE_FORMAT_SLOT
)
.
toPrivate
(
)
;
UDateFormat
*
df
=
static_cast
<
UDateFormat
*
>
(
priv
)
;
if
(
!
df
)
{
df
=
NewUDateFormat
(
cx
dateTimeFormat
)
;
if
(
!
df
)
return
false
;
dateTimeFormat
-
>
setReservedSlot
(
DateTimeFormatObject
:
:
UDATE_FORMAT_SLOT
PrivateValue
(
df
)
)
;
}
return
args
[
2
]
.
toBoolean
(
)
?
intl_FormatToPartsDateTime
(
cx
df
x
args
.
rval
(
)
)
:
intl_FormatDateTime
(
cx
df
x
args
.
rval
(
)
)
;
}
const
ClassOps
PluralRulesObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
PluralRulesObject
:
:
finalize
}
;
const
Class
PluralRulesObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
PluralRulesObject
:
:
SLOT_COUNT
)
|
JSCLASS_FOREGROUND_FINALIZE
&
PluralRulesObject
:
:
classOps_
}
;
#
if
JS_HAS_TOSOURCE
static
bool
pluralRules_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
PluralRules
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
pluralRules_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_PluralRules_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
pluralRules_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_PluralRules_resolvedOptions
"
0
0
)
JS_SELF_HOSTED_FN
(
"
select
"
"
Intl_PluralRules_select
"
1
0
)
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
pluralRules_toSource
0
0
)
#
endif
JS_FS_END
}
;
static
bool
PluralRules
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Intl
.
PluralRules
"
)
)
return
false
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreatePluralRulesPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
Rooted
<
PluralRulesObject
*
>
pluralRules
(
cx
)
;
pluralRules
=
NewObjectWithGivenProto
<
PluralRulesObject
>
(
cx
proto
)
;
if
(
!
pluralRules
)
return
false
;
pluralRules
-
>
setReservedSlot
(
PluralRulesObject
:
:
INTERNALS_SLOT
NullValue
(
)
)
;
pluralRules
-
>
setReservedSlot
(
PluralRulesObject
:
:
UPLURAL_RULES_SLOT
PrivateValue
(
nullptr
)
)
;
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
if
(
!
intl
:
:
InitializeObject
(
cx
pluralRules
cx
-
>
names
(
)
.
InitializePluralRules
locales
options
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
pluralRules
)
;
return
true
;
}
void
PluralRulesObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
const
Value
&
slot
=
obj
-
>
as
<
PluralRulesObject
>
(
)
.
getReservedSlot
(
PluralRulesObject
:
:
UPLURAL_RULES_SLOT
)
;
if
(
UPluralRules
*
pr
=
static_cast
<
UPluralRules
*
>
(
slot
.
toPrivate
(
)
)
)
uplrules_close
(
pr
)
;
}
static
JSObject
*
CreatePluralRulesPrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
)
{
RootedFunction
ctor
(
cx
)
;
ctor
=
global
-
>
createConstructor
(
cx
&
PluralRules
cx
-
>
names
(
)
.
PluralRules
0
)
;
if
(
!
ctor
)
return
nullptr
;
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
ctor
pluralRules_static_methods
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
proto
pluralRules_methods
)
)
return
nullptr
;
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
PluralRules
ctorValue
0
)
)
return
nullptr
;
return
proto
;
}
bool
js
:
:
intl_PluralRules_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
RootedValue
result
(
cx
)
;
if
(
!
GetAvailableLocales
(
cx
uloc_countAvailable
uloc_getAvailable
&
result
)
)
return
false
;
args
.
rval
(
)
.
set
(
result
)
;
return
true
;
}
bool
js
:
:
intl_SelectPluralRule
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
Rooted
<
PluralRulesObject
*
>
pluralRules
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
PluralRulesObject
>
(
)
)
;
double
x
=
args
[
1
]
.
toNumber
(
)
;
UNumberFormat
*
nf
=
NewUNumberFormatForPluralRules
(
cx
pluralRules
)
;
if
(
!
nf
)
return
false
;
ScopedICUObject
<
UNumberFormat
unum_close
>
closeNumberFormat
(
nf
)
;
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
pluralRules
)
)
;
if
(
!
internals
)
return
false
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
false
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
type
&
value
)
)
return
false
;
UPluralType
category
;
{
JSLinearString
*
type
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
type
)
return
false
;
if
(
StringEqualsAscii
(
type
"
cardinal
"
)
)
{
category
=
UPLURAL_TYPE_CARDINAL
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
type
"
ordinal
"
)
)
;
category
=
UPLURAL_TYPE_ORDINAL
;
}
}
UErrorCode
status
=
U_ZERO_ERROR
;
UPluralRules
*
pr
=
uplrules_openForType
(
IcuLocale
(
locale
.
ptr
(
)
)
category
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UPluralRules
uplrules_close
>
closePluralRules
(
pr
)
;
JSString
*
str
=
CallICU
(
cx
[
pr
x
nf
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
uplrules_selectWithFormat
(
pr
x
nf
chars
size
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_GetPluralCategories
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
JSLinearString
*
type
=
args
[
1
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
type
)
return
false
;
UPluralType
category
;
if
(
StringEqualsAscii
(
type
"
cardinal
"
)
)
{
category
=
UPLURAL_TYPE_CARDINAL
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
type
"
ordinal
"
)
)
;
category
=
UPLURAL_TYPE_ORDINAL
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UPluralRules
*
pr
=
uplrules_openForType
(
IcuLocale
(
locale
.
ptr
(
)
)
category
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UPluralRules
uplrules_close
>
closePluralRules
(
pr
)
;
UEnumeration
*
ue
=
uplrules_getKeywords
(
pr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UEnumeration
uenum_close
>
closeEnum
(
ue
)
;
RootedObject
res
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
res
)
return
false
;
RootedValue
element
(
cx
)
;
uint32_t
i
=
0
;
do
{
int32_t
catSize
;
const
char
*
cat
=
uenum_next
(
ue
&
catSize
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
!
cat
)
break
;
MOZ_ASSERT
(
catSize
>
=
0
)
;
JSString
*
str
=
NewStringCopyN
<
CanGC
>
(
cx
cat
catSize
)
;
if
(
!
str
)
return
false
;
element
.
setString
(
str
)
;
if
(
!
DefineDataElement
(
cx
res
i
+
+
element
)
)
return
false
;
}
while
(
true
)
;
args
.
rval
(
)
.
setObject
(
*
res
)
;
return
true
;
}
const
ClassOps
RelativeTimeFormatObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
RelativeTimeFormatObject
:
:
finalize
}
;
const
Class
RelativeTimeFormatObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
RelativeTimeFormatObject
:
:
SLOT_COUNT
)
|
JSCLASS_FOREGROUND_FINALIZE
&
RelativeTimeFormatObject
:
:
classOps_
}
;
#
if
JS_HAS_TOSOURCE
static
bool
relativeTimeFormat_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
RelativeTimeFormat
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
relativeTimeFormat_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_RelativeTimeFormat_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
relativeTimeFormat_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_RelativeTimeFormat_resolvedOptions
"
0
0
)
JS_SELF_HOSTED_FN
(
"
format
"
"
Intl_RelativeTimeFormat_format
"
2
0
)
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
relativeTimeFormat_toSource
0
0
)
#
endif
JS_FS_END
}
;
static
bool
RelativeTimeFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Intl
.
RelativeTimeFormat
"
)
)
return
false
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreateRelativeTimeFormatPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
Rooted
<
RelativeTimeFormatObject
*
>
relativeTimeFormat
(
cx
)
;
relativeTimeFormat
=
NewObjectWithGivenProto
<
RelativeTimeFormatObject
>
(
cx
proto
)
;
if
(
!
relativeTimeFormat
)
return
false
;
relativeTimeFormat
-
>
setReservedSlot
(
RelativeTimeFormatObject
:
:
INTERNALS_SLOT
NullValue
(
)
)
;
relativeTimeFormat
-
>
setReservedSlot
(
RelativeTimeFormatObject
:
:
URELATIVE_TIME_FORMAT_SLOT
PrivateValue
(
nullptr
)
)
;
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
if
(
!
intl
:
:
InitializeObject
(
cx
relativeTimeFormat
cx
-
>
names
(
)
.
InitializeRelativeTimeFormat
locales
options
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
relativeTimeFormat
)
;
return
true
;
}
void
RelativeTimeFormatObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
const
Value
&
slot
=
obj
-
>
as
<
RelativeTimeFormatObject
>
(
)
.
getReservedSlot
(
RelativeTimeFormatObject
:
:
URELATIVE_TIME_FORMAT_SLOT
)
;
if
(
URelativeDateTimeFormatter
*
rtf
=
static_cast
<
URelativeDateTimeFormatter
*
>
(
slot
.
toPrivate
(
)
)
)
ureldatefmt_close
(
rtf
)
;
}
static
JSObject
*
CreateRelativeTimeFormatPrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
)
{
RootedFunction
ctor
(
cx
)
;
ctor
=
global
-
>
createConstructor
(
cx
&
RelativeTimeFormat
cx
-
>
names
(
)
.
RelativeTimeFormat
0
)
;
if
(
!
ctor
)
return
nullptr
;
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
ctor
relativeTimeFormat_static_methods
)
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
proto
relativeTimeFormat_methods
)
)
return
nullptr
;
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
RelativeTimeFormat
ctorValue
0
)
)
return
nullptr
;
return
proto
;
}
bool
js
:
:
GlobalObject
:
:
addRelativeTimeFormatConstructor
(
JSContext
*
cx
HandleObject
intl
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
{
const
HeapSlot
&
slot
=
global
-
>
getReservedSlotRef
(
RELATIVE_TIME_FORMAT_PROTO
)
;
if
(
!
slot
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
slot
.
isObject
(
)
)
;
JS_ReportErrorASCII
(
cx
"
the
RelativeTimeFormat
constructor
can
'
t
be
added
"
"
multiple
times
in
the
same
global
"
)
;
return
false
;
}
}
JSObject
*
relativeTimeFormatProto
=
CreateRelativeTimeFormatPrototype
(
cx
intl
global
)
;
if
(
!
relativeTimeFormatProto
)
return
false
;
global
-
>
setReservedSlot
(
RELATIVE_TIME_FORMAT_PROTO
ObjectValue
(
*
relativeTimeFormatProto
)
)
;
return
true
;
}
bool
js
:
:
AddRelativeTimeFormatConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
intl
)
{
return
GlobalObject
:
:
addRelativeTimeFormatConstructor
(
cx
intl
)
;
}
bool
js
:
:
intl_RelativeTimeFormat_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
RootedValue
result
(
cx
)
;
if
(
!
GetAvailableLocales
(
cx
uloc_countAvailable
uloc_getAvailable
&
result
)
)
return
false
;
args
.
rval
(
)
.
set
(
result
)
;
return
true
;
}
enum
class
RelativeTimeType
{
Numeric
Text
}
;
bool
js
:
:
intl_FormatRelativeTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
RootedObject
relativeTimeFormat
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
double
t
=
args
[
1
]
.
toNumber
(
)
;
RootedObject
internals
(
cx
intl
:
:
GetInternalsObject
(
cx
relativeTimeFormat
)
)
;
if
(
!
internals
)
return
false
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
return
false
;
JSAutoByteString
locale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
style
&
value
)
)
return
false
;
UDateRelativeDateTimeFormatterStyle
relDateTimeStyle
;
{
JSLinearString
*
style
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
style
)
return
false
;
if
(
StringEqualsAscii
(
style
"
short
"
)
)
{
relDateTimeStyle
=
UDAT_STYLE_SHORT
;
}
else
if
(
StringEqualsAscii
(
style
"
narrow
"
)
)
{
relDateTimeStyle
=
UDAT_STYLE_NARROW
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
style
"
long
"
)
)
;
relDateTimeStyle
=
UDAT_STYLE_LONG
;
}
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
type
&
value
)
)
return
false
;
RelativeTimeType
relDateTimeType
;
{
JSLinearString
*
type
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
type
)
return
false
;
if
(
StringEqualsAscii
(
type
"
text
"
)
)
{
relDateTimeType
=
RelativeTimeType
:
:
Text
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
type
"
numeric
"
)
)
;
relDateTimeType
=
RelativeTimeType
:
:
Numeric
;
}
}
URelativeDateTimeUnit
relDateTimeUnit
;
{
JSLinearString
*
unit
=
args
[
2
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
unit
)
return
false
;
if
(
StringEqualsAscii
(
unit
"
second
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_SECOND
;
}
else
if
(
StringEqualsAscii
(
unit
"
minute
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_MINUTE
;
}
else
if
(
StringEqualsAscii
(
unit
"
hour
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_HOUR
;
}
else
if
(
StringEqualsAscii
(
unit
"
day
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_DAY
;
}
else
if
(
StringEqualsAscii
(
unit
"
week
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_WEEK
;
}
else
if
(
StringEqualsAscii
(
unit
"
month
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_MONTH
;
}
else
if
(
StringEqualsAscii
(
unit
"
quarter
"
)
)
{
relDateTimeUnit
=
UDAT_REL_UNIT_QUARTER
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
unit
"
year
"
)
)
;
relDateTimeUnit
=
UDAT_REL_UNIT_YEAR
;
}
}
if
(
IsNegativeZero
(
t
)
)
t
=
+
0
.
0
;
UErrorCode
status
=
U_ZERO_ERROR
;
URelativeDateTimeFormatter
*
rtf
=
ureldatefmt_open
(
IcuLocale
(
locale
.
ptr
(
)
)
nullptr
relDateTimeStyle
UDISPCTX_CAPITALIZATION_FOR_STANDALONE
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
URelativeDateTimeFormatter
ureldatefmt_close
>
closeRelativeTimeFormat
(
rtf
)
;
JSString
*
str
=
CallICU
(
cx
[
rtf
t
relDateTimeUnit
relDateTimeType
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
auto
fmt
=
relDateTimeType
=
=
RelativeTimeType
:
:
Text
?
ureldatefmt_format
:
ureldatefmt_formatNumeric
;
return
fmt
(
rtf
t
relDateTimeUnit
chars
size
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
const
char
*
CaseMappingLocale
(
JSContext
*
cx
JSString
*
str
)
{
JSLinearString
*
locale
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
locale
)
return
nullptr
;
MOZ_ASSERT
(
locale
-
>
length
(
)
>
=
2
"
locale
is
a
valid
language
tag
"
)
;
static
const
char
languagesWithSpecialCasing
[
]
[
3
]
=
{
"
lt
"
"
tr
"
"
az
"
}
;
if
(
locale
-
>
length
(
)
=
=
2
|
|
locale
-
>
latin1OrTwoByteChar
(
2
)
=
=
'
-
'
)
{
for
(
const
auto
&
language
:
languagesWithSpecialCasing
)
{
if
(
locale
-
>
latin1OrTwoByteChar
(
0
)
=
=
language
[
0
]
&
&
locale
-
>
latin1OrTwoByteChar
(
1
)
=
=
language
[
1
]
)
{
return
language
;
}
}
}
return
"
"
;
}
bool
js
:
:
intl_toLocaleLowerCase
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
RootedString
string
(
cx
args
[
0
]
.
toString
(
)
)
;
const
char
*
locale
=
CaseMappingLocale
(
cx
args
[
1
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
if
(
StringsAreEqual
(
locale
"
"
)
)
{
JSString
*
str
=
js
:
:
StringToLowerCase
(
cx
string
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
AutoStableStringChars
inputChars
(
cx
)
;
if
(
!
inputChars
.
initTwoByte
(
cx
string
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
input
=
inputChars
.
twoByteRange
(
)
;
static_assert
(
JSString
:
:
MAX_LENGTH
<
INT32_MAX
/
3
"
Case
conversion
doesn
'
t
overflow
int32_t
indices
"
)
;
JSString
*
str
=
CallICU
(
cx
[
&
input
locale
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
u_strToLower
(
chars
size
input
.
begin
(
)
.
get
(
)
input
.
length
(
)
locale
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_toLocaleUpperCase
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
RootedString
string
(
cx
args
[
0
]
.
toString
(
)
)
;
const
char
*
locale
=
CaseMappingLocale
(
cx
args
[
1
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
if
(
StringsAreEqual
(
locale
"
"
)
)
{
JSString
*
str
=
js
:
:
StringToUpperCase
(
cx
string
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
AutoStableStringChars
inputChars
(
cx
)
;
if
(
!
inputChars
.
initTwoByte
(
cx
string
)
)
return
false
;
mozilla
:
:
Range
<
const
char16_t
>
input
=
inputChars
.
twoByteRange
(
)
;
static_assert
(
JSString
:
:
MAX_LENGTH
<
INT32_MAX
/
3
"
Case
conversion
doesn
'
t
overflow
int32_t
indices
"
)
;
JSString
*
str
=
CallICU
(
cx
[
&
input
locale
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
u_strToUpper
(
chars
size
input
.
begin
(
)
.
get
(
)
input
.
length
(
)
locale
status
)
;
}
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
intl_GetCalendarInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
const
UChar
*
uTimeZone
=
nullptr
;
int32_t
uTimeZoneLength
=
0
;
UCalendar
*
cal
=
ucal_open
(
uTimeZone
uTimeZoneLength
locale
.
ptr
(
)
UCAL_DEFAULT
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UCalendar
ucal_close
>
toClose
(
cal
)
;
RootedObject
info
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
)
;
if
(
!
info
)
return
false
;
RootedValue
v
(
cx
)
;
int32_t
firstDayOfWeek
=
ucal_getAttribute
(
cal
UCAL_FIRST_DAY_OF_WEEK
)
;
v
.
setInt32
(
firstDayOfWeek
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
firstDayOfWeek
v
)
)
return
false
;
int32_t
minDays
=
ucal_getAttribute
(
cal
UCAL_MINIMAL_DAYS_IN_FIRST_WEEK
)
;
v
.
setInt32
(
minDays
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
minDays
v
)
)
return
false
;
UCalendarWeekdayType
prevDayType
=
ucal_getDayOfWeekType
(
cal
UCAL_SATURDAY
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
RootedValue
weekendStart
(
cx
)
weekendEnd
(
cx
)
;
for
(
int
i
=
UCAL_SUNDAY
;
i
<
=
UCAL_SATURDAY
;
i
+
+
)
{
UCalendarDaysOfWeek
dayOfWeek
=
static_cast
<
UCalendarDaysOfWeek
>
(
i
)
;
UCalendarWeekdayType
type
=
ucal_getDayOfWeekType
(
cal
dayOfWeek
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
prevDayType
!
=
type
)
{
switch
(
type
)
{
case
UCAL_WEEKDAY
:
weekendEnd
.
setInt32
(
i
=
=
1
?
7
:
i
-
1
)
;
break
;
case
UCAL_WEEKEND
:
weekendStart
.
setInt32
(
i
)
;
break
;
case
UCAL_WEEKEND_ONSET
:
case
UCAL_WEEKEND_CEASE
:
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
default
:
break
;
}
}
prevDayType
=
type
;
}
MOZ_ASSERT
(
weekendStart
.
isInt32
(
)
)
;
MOZ_ASSERT
(
weekendEnd
.
isInt32
(
)
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
weekendStart
weekendStart
)
)
return
false
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
weekendEnd
weekendEnd
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
info
)
;
return
true
;
}
static
void
ReportBadKey
(
JSContext
*
cx
const
Range
<
const
JS
:
:
Latin1Char
>
&
range
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_KEY
range
.
begin
(
)
.
get
(
)
)
;
}
static
void
ReportBadKey
(
JSContext
*
cx
const
Range
<
const
char16_t
>
&
range
)
{
JS_ReportErrorNumberUC
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_KEY
range
.
begin
(
)
.
get
(
)
)
;
}
template
<
typename
ConstChar
>
static
bool
MatchPart
(
RangedPtr
<
ConstChar
>
iter
const
RangedPtr
<
ConstChar
>
end
const
char
*
part
size_t
partlen
)
{
for
(
size_t
i
=
0
;
i
<
partlen
;
iter
+
+
i
+
+
)
{
if
(
iter
=
=
end
|
|
*
iter
!
=
part
[
i
]
)
return
false
;
}
return
true
;
}
template
<
typename
ConstChar
size_t
N
>
inline
bool
MatchPart
(
RangedPtr
<
ConstChar
>
*
iter
const
RangedPtr
<
ConstChar
>
end
const
char
(
&
part
)
[
N
]
)
{
if
(
!
MatchPart
(
*
iter
end
part
N
-
1
)
)
return
false
;
*
iter
+
=
N
-
1
;
return
true
;
}
enum
class
DisplayNameStyle
{
Narrow
Short
Long
}
;
template
<
typename
ConstChar
>
static
JSString
*
ComputeSingleDisplayName
(
JSContext
*
cx
UDateFormat
*
fmt
UDateTimePatternGenerator
*
dtpg
DisplayNameStyle
style
const
Range
<
ConstChar
>
&
pattern
)
{
RangedPtr
<
ConstChar
>
iter
=
pattern
.
begin
(
)
;
const
RangedPtr
<
ConstChar
>
end
=
pattern
.
end
(
)
;
auto
MatchSlash
=
[
cx
pattern
&
iter
end
]
(
)
{
if
(
MOZ_LIKELY
(
iter
!
=
end
&
&
*
iter
=
=
'
/
'
)
)
{
iter
+
+
;
return
true
;
}
ReportBadKey
(
cx
pattern
)
;
return
false
;
}
;
if
(
!
MatchPart
(
&
iter
end
"
dates
"
)
)
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
if
(
!
MatchSlash
(
)
)
return
nullptr
;
if
(
MatchPart
(
&
iter
end
"
fields
"
)
)
{
if
(
!
MatchSlash
(
)
)
return
nullptr
;
UDateTimePatternField
fieldType
;
if
(
MatchPart
(
&
iter
end
"
year
"
)
)
{
fieldType
=
UDATPG_YEAR_FIELD
;
}
else
if
(
MatchPart
(
&
iter
end
"
month
"
)
)
{
fieldType
=
UDATPG_MONTH_FIELD
;
}
else
if
(
MatchPart
(
&
iter
end
"
week
"
)
)
{
fieldType
=
UDATPG_WEEK_OF_YEAR_FIELD
;
}
else
if
(
MatchPart
(
&
iter
end
"
day
"
)
)
{
fieldType
=
UDATPG_DAY_FIELD
;
}
else
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
if
(
iter
!
=
end
)
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
int32_t
resultSize
;
const
UChar
*
value
=
udatpg_getAppendItemName
(
dtpg
fieldType
&
resultSize
)
;
MOZ_ASSERT
(
resultSize
>
=
0
)
;
return
NewStringCopyN
<
CanGC
>
(
cx
value
size_t
(
resultSize
)
)
;
}
if
(
MatchPart
(
&
iter
end
"
gregorian
"
)
)
{
if
(
!
MatchSlash
(
)
)
return
nullptr
;
UDateFormatSymbolType
symbolType
;
int32_t
index
;
if
(
MatchPart
(
&
iter
end
"
months
"
)
)
{
if
(
!
MatchSlash
(
)
)
return
nullptr
;
switch
(
style
)
{
case
DisplayNameStyle
:
:
Narrow
:
symbolType
=
UDAT_STANDALONE_NARROW_MONTHS
;
break
;
case
DisplayNameStyle
:
:
Short
:
symbolType
=
UDAT_STANDALONE_SHORT_MONTHS
;
break
;
case
DisplayNameStyle
:
:
Long
:
symbolType
=
UDAT_STANDALONE_MONTHS
;
break
;
}
if
(
MatchPart
(
&
iter
end
"
january
"
)
)
{
index
=
UCAL_JANUARY
;
}
else
if
(
MatchPart
(
&
iter
end
"
february
"
)
)
{
index
=
UCAL_FEBRUARY
;
}
else
if
(
MatchPart
(
&
iter
end
"
march
"
)
)
{
index
=
UCAL_MARCH
;
}
else
if
(
MatchPart
(
&
iter
end
"
april
"
)
)
{
index
=
UCAL_APRIL
;
}
else
if
(
MatchPart
(
&
iter
end
"
may
"
)
)
{
index
=
UCAL_MAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
june
"
)
)
{
index
=
UCAL_JUNE
;
}
else
if
(
MatchPart
(
&
iter
end
"
july
"
)
)
{
index
=
UCAL_JULY
;
}
else
if
(
MatchPart
(
&
iter
end
"
august
"
)
)
{
index
=
UCAL_AUGUST
;
}
else
if
(
MatchPart
(
&
iter
end
"
september
"
)
)
{
index
=
UCAL_SEPTEMBER
;
}
else
if
(
MatchPart
(
&
iter
end
"
october
"
)
)
{
index
=
UCAL_OCTOBER
;
}
else
if
(
MatchPart
(
&
iter
end
"
november
"
)
)
{
index
=
UCAL_NOVEMBER
;
}
else
if
(
MatchPart
(
&
iter
end
"
december
"
)
)
{
index
=
UCAL_DECEMBER
;
}
else
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
}
else
if
(
MatchPart
(
&
iter
end
"
weekdays
"
)
)
{
if
(
!
MatchSlash
(
)
)
return
nullptr
;
switch
(
style
)
{
case
DisplayNameStyle
:
:
Narrow
:
symbolType
=
UDAT_STANDALONE_NARROW_WEEKDAYS
;
break
;
case
DisplayNameStyle
:
:
Short
:
symbolType
=
UDAT_STANDALONE_SHORT_WEEKDAYS
;
break
;
case
DisplayNameStyle
:
:
Long
:
symbolType
=
UDAT_STANDALONE_WEEKDAYS
;
break
;
}
if
(
MatchPart
(
&
iter
end
"
monday
"
)
)
{
index
=
UCAL_MONDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
tuesday
"
)
)
{
index
=
UCAL_TUESDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
wednesday
"
)
)
{
index
=
UCAL_WEDNESDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
thursday
"
)
)
{
index
=
UCAL_THURSDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
friday
"
)
)
{
index
=
UCAL_FRIDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
saturday
"
)
)
{
index
=
UCAL_SATURDAY
;
}
else
if
(
MatchPart
(
&
iter
end
"
sunday
"
)
)
{
index
=
UCAL_SUNDAY
;
}
else
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
}
else
if
(
MatchPart
(
&
iter
end
"
dayperiods
"
)
)
{
if
(
!
MatchSlash
(
)
)
return
nullptr
;
symbolType
=
UDAT_AM_PMS
;
if
(
MatchPart
(
&
iter
end
"
am
"
)
)
{
index
=
UCAL_AM
;
}
else
if
(
MatchPart
(
&
iter
end
"
pm
"
)
)
{
index
=
UCAL_PM
;
}
else
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
}
else
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
if
(
iter
!
=
end
)
{
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
return
CallICU
(
cx
[
fmt
symbolType
index
]
(
UChar
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
udat_getSymbols
(
fmt
symbolType
index
chars
size
status
)
;
}
)
;
}
ReportBadKey
(
cx
pattern
)
;
return
nullptr
;
}
bool
js
:
:
intl_ComputeDisplayNames
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
RootedString
str
(
cx
args
[
0
]
.
toString
(
)
)
;
JSAutoByteString
locale
;
if
(
!
locale
.
encodeUtf8
(
cx
str
)
)
return
false
;
DisplayNameStyle
dnStyle
;
{
JSLinearString
*
style
=
args
[
1
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
style
)
return
false
;
if
(
StringEqualsAscii
(
style
"
narrow
"
)
)
{
dnStyle
=
DisplayNameStyle
:
:
Narrow
;
}
else
if
(
StringEqualsAscii
(
style
"
short
"
)
)
{
dnStyle
=
DisplayNameStyle
:
:
Short
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
style
"
long
"
)
)
;
dnStyle
=
DisplayNameStyle
:
:
Long
;
}
}
RootedArrayObject
keys
(
cx
&
args
[
2
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
)
;
if
(
!
keys
)
return
false
;
RootedArrayObject
result
(
cx
NewDenseUnallocatedArray
(
cx
keys
-
>
length
(
)
)
)
;
if
(
!
result
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UDateFormat
*
fmt
=
udat_open
(
UDAT_DEFAULT
UDAT_DEFAULT
IcuLocale
(
locale
.
ptr
(
)
)
nullptr
0
nullptr
0
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UDateFormat
udat_close
>
datToClose
(
fmt
)
;
UDateTimePatternGenerator
*
dtpg
=
udatpg_open
(
IcuLocale
(
locale
.
ptr
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UDateTimePatternGenerator
udatpg_close
>
datPgToClose
(
dtpg
)
;
RootedString
keyValStr
(
cx
)
;
RootedValue
v
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
keys
-
>
length
(
)
;
i
+
+
)
{
if
(
!
GetElement
(
cx
keys
keys
i
&
v
)
)
return
false
;
keyValStr
=
v
.
toString
(
)
;
AutoStableStringChars
stablePatternChars
(
cx
)
;
if
(
!
stablePatternChars
.
init
(
cx
keyValStr
)
)
return
false
;
JSString
*
displayName
=
stablePatternChars
.
isLatin1
(
)
?
ComputeSingleDisplayName
(
cx
fmt
dtpg
dnStyle
stablePatternChars
.
latin1Range
(
)
)
:
ComputeSingleDisplayName
(
cx
fmt
dtpg
dnStyle
stablePatternChars
.
twoByteRange
(
)
)
;
if
(
!
displayName
)
return
false
;
v
.
setString
(
displayName
)
;
if
(
!
DefineDataElement
(
cx
result
i
v
)
)
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
bool
js
:
:
intl_GetLocaleInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
JSAutoByteString
locale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
return
false
;
RootedObject
info
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
)
;
if
(
!
info
)
return
false
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
locale
args
[
0
]
)
)
return
false
;
bool
rtl
=
uloc_isRightToLeft
(
IcuLocale
(
locale
.
ptr
(
)
)
)
;
RootedValue
dir
(
cx
StringValue
(
rtl
?
cx
-
>
names
(
)
.
rtl
:
cx
-
>
names
(
)
.
ltr
)
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
direction
dir
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
info
)
;
return
true
;
}
const
Class
js
:
:
IntlClass
=
{
js_Object_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Intl
)
}
;
#
if
JS_HAS_TOSOURCE
static
bool
intl_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Intl
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
intl_static_methods
[
]
=
{
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
intl_toSource
0
0
)
#
endif
JS_SELF_HOSTED_FN
(
"
getCanonicalLocales
"
"
Intl_getCanonicalLocales
"
1
0
)
JS_FS_END
}
;
bool
GlobalObject
:
:
initIntlObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
proto
)
return
false
;
RootedObject
intl
(
cx
NewObjectWithGivenProto
(
cx
&
IntlClass
proto
SingletonObject
)
)
;
if
(
!
intl
)
return
false
;
if
(
!
JS_DefineFunctions
(
cx
intl
intl_static_methods
)
)
return
false
;
RootedObject
collatorProto
(
cx
CreateCollatorPrototype
(
cx
intl
global
)
)
;
if
(
!
collatorProto
)
return
false
;
RootedObject
dateTimeFormatProto
(
cx
)
dateTimeFormat
(
cx
)
;
dateTimeFormatProto
=
CreateDateTimeFormatPrototype
(
cx
intl
global
&
dateTimeFormat
DateTimeFormatOptions
:
:
Standard
)
;
if
(
!
dateTimeFormatProto
)
return
false
;
RootedObject
numberFormatProto
(
cx
)
numberFormat
(
cx
)
;
numberFormatProto
=
CreateNumberFormatPrototype
(
cx
intl
global
&
numberFormat
)
;
if
(
!
numberFormatProto
)
return
false
;
RootedObject
pluralRulesProto
(
cx
CreatePluralRulesPrototype
(
cx
intl
global
)
)
;
if
(
!
pluralRulesProto
)
return
false
;
RootedValue
intlValue
(
cx
ObjectValue
(
*
intl
)
)
;
if
(
!
DefineDataProperty
(
cx
global
cx
-
>
names
(
)
.
Intl
intlValue
JSPROP_RESOLVING
)
)
return
false
;
global
-
>
setReservedSlot
(
COLLATOR_PROTO
ObjectValue
(
*
collatorProto
)
)
;
global
-
>
setReservedSlot
(
DATE_TIME_FORMAT
ObjectValue
(
*
dateTimeFormat
)
)
;
global
-
>
setReservedSlot
(
DATE_TIME_FORMAT_PROTO
ObjectValue
(
*
dateTimeFormatProto
)
)
;
global
-
>
setReservedSlot
(
NUMBER_FORMAT
ObjectValue
(
*
numberFormat
)
)
;
global
-
>
setReservedSlot
(
NUMBER_FORMAT_PROTO
ObjectValue
(
*
numberFormatProto
)
)
;
global
-
>
setReservedSlot
(
PLURAL_RULES_PROTO
ObjectValue
(
*
pluralRulesProto
)
)
;
global
-
>
setConstructor
(
JSProto_Intl
ObjectValue
(
*
intl
)
)
;
return
true
;
}
JSObject
*
js
:
:
InitIntlClass
(
JSContext
*
cx
HandleObject
obj
)
{
Handle
<
GlobalObject
*
>
global
=
obj
.
as
<
GlobalObject
>
(
)
;
if
(
!
GlobalObject
:
:
initIntlObject
(
cx
global
)
)
return
nullptr
;
return
&
global
-
>
getConstructor
(
JSProto_Intl
)
.
toObject
(
)
;
}
