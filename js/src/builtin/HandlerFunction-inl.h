#
ifndef
builtin_HandlerFunction_inl_h
#
define
builtin_HandlerFunction_inl_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stddef
.
h
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ObjectGroup
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
namespace
js
{
constexpr
size_t
HandlerFunctionSlot_Target
=
0
;
constexpr
size_t
HandlerFunctionSlot_Extra
=
1
;
static_assert
(
HandlerFunctionSlot_Extra
<
FunctionExtended
:
:
NUM_EXTENDED_SLOTS
"
handler
function
slots
shouldn
'
t
exceed
available
extended
"
"
slots
"
)
;
[
[
nodiscard
]
]
inline
JSFunction
*
NewHandler
(
JSContext
*
cx
Native
handler
JS
:
:
Handle
<
JSObject
*
>
target
)
{
cx
-
>
check
(
target
)
;
JS
:
:
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
JS
:
:
Rooted
<
JSFunction
*
>
handlerFun
(
cx
NewNativeFunction
(
cx
handler
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
handlerFun
)
{
return
nullptr
;
}
handlerFun
-
>
setExtendedSlot
(
HandlerFunctionSlot_Target
JS
:
:
ObjectValue
(
*
target
)
)
;
return
handlerFun
;
}
[
[
nodiscard
]
]
inline
JSFunction
*
NewHandlerWithExtra
(
JSContext
*
cx
Native
handler
JS
:
:
Handle
<
JSObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
extra
)
{
cx
-
>
check
(
extra
)
;
JSFunction
*
handlerFun
=
NewHandler
(
cx
handler
target
)
;
if
(
handlerFun
)
{
handlerFun
-
>
setExtendedSlot
(
HandlerFunctionSlot_Extra
JS
:
:
ObjectValue
(
*
extra
)
)
;
}
return
handlerFun
;
}
[
[
nodiscard
]
]
inline
JSFunction
*
NewHandlerWithExtraValue
(
JSContext
*
cx
Native
handler
JS
:
:
Handle
<
JSObject
*
>
target
JS
:
:
Handle
<
JS
:
:
Value
>
extra
)
{
cx
-
>
check
(
extra
)
;
JSFunction
*
handlerFun
=
NewHandler
(
cx
handler
target
)
;
if
(
handlerFun
)
{
handlerFun
-
>
setExtendedSlot
(
HandlerFunctionSlot_Extra
extra
)
;
}
return
handlerFun
;
}
template
<
class
T
>
[
[
nodiscard
]
]
inline
T
*
TargetFromHandler
(
const
JS
:
:
CallArgs
&
args
)
{
JSFunction
&
func
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
return
&
func
.
getExtendedSlot
(
HandlerFunctionSlot_Target
)
.
toObject
(
)
.
as
<
T
>
(
)
;
}
[
[
nodiscard
]
]
inline
JS
:
:
Value
ExtraValueFromHandler
(
const
JS
:
:
CallArgs
&
args
)
{
JSFunction
&
func
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
return
func
.
getExtendedSlot
(
HandlerFunctionSlot_Extra
)
;
}
template
<
class
T
>
[
[
nodiscard
]
]
inline
T
*
ExtraFromHandler
(
const
JS
:
:
CallArgs
&
args
)
{
return
&
ExtraValueFromHandler
(
args
)
.
toObject
(
)
.
as
<
T
>
(
)
;
}
}
#
endif
