#
ifndef
builtin_streams_WritableStream_h
#
define
builtin_streams_WritableStream_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
class
PromiseObject
;
class
WritableStreamDefaultController
;
class
WritableStreamDefaultWriter
;
class
WritableStream
:
public
NativeObject
{
public
:
enum
Slots
{
Slot_Controller
Slot_Writer
Slot_State
Slot_StoredError
Slot_WriteRequests
Slot_CloseRequest
Slot_PendingAbortRequestPromise
Slot_PendingAbortRequestReason
SlotCount
}
;
private
:
enum
State
:
uint32_t
{
Writable
=
0x0000
'
0000
Closed
=
0x0000
'
0001
Erroring
=
0x0000
'
0002
Errored
=
0x0000
'
0003
StateBits
=
0x0000
'
0003
StateMask
=
0x0000
'
00ff
Backpressure
=
0x0000
'
0100
HaveInFlightWriteRequest
=
0x0000
'
0200
HaveInFlightCloseRequest
=
0x0000
'
0400
PendingAbortRequestWasAlreadyErroring
=
0x0000
'
0800
FlagBits
=
Backpressure
|
HaveInFlightWriteRequest
|
HaveInFlightCloseRequest
|
PendingAbortRequestWasAlreadyErroring
FlagMask
=
0x0000
'
ff00
SettableBits
=
uint32_t
(
StateBits
|
FlagBits
)
}
;
bool
stateIsInitialized
(
)
const
{
return
getFixedSlot
(
Slot_State
)
.
isInt32
(
)
;
}
State
state
(
)
const
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
uint32_t
v
=
getFixedSlot
(
Slot_State
)
.
toInt32
(
)
;
MOZ_ASSERT
(
(
v
&
~
SettableBits
)
=
=
0
)
;
return
static_cast
<
State
>
(
v
&
StateMask
)
;
}
State
flags
(
)
const
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
uint32_t
v
=
getFixedSlot
(
Slot_State
)
.
toInt32
(
)
;
MOZ_ASSERT
(
(
v
&
~
SettableBits
)
=
=
0
)
;
return
static_cast
<
State
>
(
v
&
FlagMask
)
;
}
void
initWritableState
(
)
{
MOZ_ASSERT
(
!
stateIsInitialized
(
)
)
;
setFixedSlot
(
Slot_State
JS
:
:
Int32Value
(
Writable
)
)
;
MOZ_ASSERT
(
writable
(
)
)
;
MOZ_ASSERT
(
!
backpressure
(
)
)
;
}
void
setState
(
State
newState
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
(
newState
&
~
StateBits
)
=
=
0
)
;
MOZ_ASSERT
(
newState
<
=
Errored
)
;
#
ifdef
DEBUG
{
auto
current
=
state
(
)
;
if
(
current
=
=
Writable
)
{
MOZ_ASSERT
(
newState
=
=
Closed
|
|
newState
=
=
Erroring
)
;
}
else
if
(
current
=
=
Erroring
)
{
MOZ_ASSERT
(
newState
=
=
Errored
)
;
}
else
if
(
current
=
=
Closed
|
|
current
=
=
Errored
)
{
MOZ_ASSERT_UNREACHABLE
(
"
closed
/
errored
stream
shouldn
'
t
undergo
state
transitions
"
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
smashed
state
bits
?
"
)
;
}
}
#
endif
uint32_t
newValue
=
static_cast
<
uint32_t
>
(
newState
)
|
(
getFixedSlot
(
Slot_State
)
.
toInt32
(
)
&
FlagMask
)
;
setFixedSlot
(
Slot_State
JS
:
:
Int32Value
(
mozilla
:
:
AssertedCast
<
int32_t
>
(
newValue
)
)
)
;
}
void
setFlag
(
State
flag
bool
set
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
mozilla
:
:
IsPowerOfTwo
(
uint32_t
(
flag
)
)
)
;
MOZ_ASSERT
(
(
flag
&
FlagBits
)
!
=
0
)
;
uint32_t
v
=
getFixedSlot
(
Slot_State
)
.
toInt32
(
)
;
MOZ_ASSERT
(
(
v
&
~
SettableBits
)
=
=
0
)
;
uint32_t
newValue
=
set
?
(
v
|
flag
)
:
(
v
&
~
flag
)
;
setFixedSlot
(
Slot_State
JS
:
:
Int32Value
(
mozilla
:
:
AssertedCast
<
int32_t
>
(
newValue
)
)
)
;
}
public
:
bool
writable
(
)
const
{
return
state
(
)
=
=
Writable
;
}
bool
closed
(
)
const
{
return
state
(
)
=
=
Closed
;
}
void
setClosed
(
)
{
setState
(
Closed
)
;
}
bool
erroring
(
)
const
{
return
state
(
)
=
=
Erroring
;
}
void
setErroring
(
)
{
setState
(
Erroring
)
;
}
bool
errored
(
)
const
{
return
state
(
)
=
=
Errored
;
}
void
setErrored
(
)
{
setState
(
Errored
)
;
}
bool
backpressure
(
)
const
{
return
flags
(
)
&
Backpressure
;
}
void
setBackpressure
(
bool
pressure
)
{
setFlag
(
Backpressure
pressure
)
;
}
bool
haveInFlightWriteRequest
(
)
const
{
return
flags
(
)
&
HaveInFlightWriteRequest
;
}
void
setHaveInFlightWriteRequest
(
)
{
MOZ_ASSERT
(
!
haveInFlightWriteRequest
(
)
)
;
MOZ_ASSERT
(
writeRequests
(
)
-
>
length
(
)
>
0
)
;
setFlag
(
HaveInFlightWriteRequest
true
)
;
}
bool
haveInFlightCloseRequest
(
)
const
{
return
flags
(
)
&
HaveInFlightCloseRequest
;
}
bool
hasController
(
)
const
{
return
!
getFixedSlot
(
Slot_Controller
)
.
isUndefined
(
)
;
}
inline
WritableStreamDefaultController
*
controller
(
)
const
;
inline
void
setController
(
WritableStreamDefaultController
*
controller
)
;
void
clearController
(
)
{
setFixedSlot
(
Slot_Controller
JS
:
:
UndefinedValue
(
)
)
;
}
bool
hasWriter
(
)
const
{
return
!
getFixedSlot
(
Slot_Writer
)
.
isUndefined
(
)
;
}
bool
isLocked
(
)
const
{
return
hasWriter
(
)
;
}
void
setWriter
(
JSObject
*
writer
)
{
MOZ_ASSERT
(
!
hasWriter
(
)
)
;
setFixedSlot
(
Slot_Writer
JS
:
:
ObjectValue
(
*
writer
)
)
;
}
void
clearWriter
(
)
{
setFixedSlot
(
Slot_Writer
JS
:
:
UndefinedValue
(
)
)
;
}
JS
:
:
Value
storedError
(
)
const
{
return
getFixedSlot
(
Slot_StoredError
)
;
}
void
setStoredError
(
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
{
setFixedSlot
(
Slot_StoredError
value
)
;
}
void
clearStoredError
(
)
{
setFixedSlot
(
Slot_StoredError
JS
:
:
UndefinedValue
(
)
)
;
}
JS
:
:
Value
inFlightWriteRequest
(
)
const
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
if
(
haveInFlightWriteRequest
(
)
)
{
MOZ_ASSERT
(
writeRequests
(
)
-
>
length
(
)
>
0
)
;
return
writeRequests
(
)
-
>
get
(
0
)
;
}
return
JS
:
:
UndefinedValue
(
)
;
}
void
clearInFlightWriteRequest
(
JSContext
*
cx
)
;
JS
:
:
Value
closeRequest
(
)
const
{
JS
:
:
Value
v
=
getFixedSlot
(
Slot_CloseRequest
)
;
if
(
v
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
return
JS
:
:
UndefinedValue
(
)
;
}
if
(
!
haveInFlightCloseRequest
(
)
)
{
return
v
;
}
return
JS
:
:
UndefinedValue
(
)
;
}
void
setCloseRequest
(
JSObject
*
closeRequest
)
{
MOZ_ASSERT
(
!
haveCloseRequestOrInFlightCloseRequest
(
)
)
;
setFixedSlot
(
Slot_CloseRequest
JS
:
:
ObjectValue
(
*
closeRequest
)
)
;
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
}
void
clearCloseRequest
(
)
{
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
MOZ_ASSERT
(
!
getFixedSlot
(
Slot_CloseRequest
)
.
isUndefined
(
)
)
;
setFixedSlot
(
Slot_CloseRequest
JS
:
:
UndefinedValue
(
)
)
;
}
JS
:
:
Value
inFlightCloseRequest
(
)
const
{
JS
:
:
Value
v
=
getFixedSlot
(
Slot_CloseRequest
)
;
if
(
v
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
return
JS
:
:
UndefinedValue
(
)
;
}
if
(
haveInFlightCloseRequest
(
)
)
{
return
v
;
}
return
JS
:
:
UndefinedValue
(
)
;
}
bool
haveCloseRequestOrInFlightCloseRequest
(
)
const
{
if
(
getFixedSlot
(
Slot_CloseRequest
)
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
return
false
;
}
return
true
;
}
void
convertCloseRequestToInFlightCloseRequest
(
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
!
haveInFlightCloseRequest
(
)
)
;
setFlag
(
HaveInFlightCloseRequest
true
)
;
MOZ_ASSERT
(
haveInFlightCloseRequest
(
)
)
;
}
void
clearInFlightCloseRequest
(
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
haveInFlightCloseRequest
(
)
)
;
MOZ_ASSERT
(
!
getFixedSlot
(
Slot_CloseRequest
)
.
isUndefined
(
)
)
;
setFlag
(
HaveInFlightCloseRequest
false
)
;
setFixedSlot
(
Slot_CloseRequest
JS
:
:
UndefinedValue
(
)
)
;
}
ListObject
*
writeRequests
(
)
const
{
MOZ_ASSERT
(
!
getFixedSlot
(
Slot_WriteRequests
)
.
isUndefined
(
)
"
shouldn
'
t
be
accessing
[
[
writeRequests
]
]
on
a
newborn
and
"
"
uninitialized
stream
or
on
a
stream
that
'
s
errored
and
no
"
"
longer
has
any
write
requests
"
)
;
return
&
getFixedSlot
(
Slot_WriteRequests
)
.
toObject
(
)
.
as
<
ListObject
>
(
)
;
}
void
clearWriteRequests
(
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
!
haveInFlightWriteRequest
(
)
"
must
clear
the
in
-
flight
request
flag
before
clearing
"
"
requests
"
)
;
setFixedSlot
(
Slot_WriteRequests
JS
:
:
UndefinedValue
(
)
)
;
}
bool
hasPendingAbortRequest
(
)
const
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
return
!
getFixedSlot
(
Slot_PendingAbortRequestPromise
)
.
isUndefined
(
)
;
}
JSObject
*
pendingAbortRequestPromise
(
)
const
{
MOZ_ASSERT
(
hasPendingAbortRequest
(
)
)
;
return
&
getFixedSlot
(
Slot_PendingAbortRequestPromise
)
.
toObject
(
)
;
}
JS
:
:
Value
pendingAbortRequestReason
(
)
const
{
MOZ_ASSERT
(
hasPendingAbortRequest
(
)
)
;
return
getFixedSlot
(
Slot_PendingAbortRequestReason
)
;
}
bool
pendingAbortRequestWasAlreadyErroring
(
)
const
{
MOZ_ASSERT
(
hasPendingAbortRequest
(
)
)
;
return
flags
(
)
&
PendingAbortRequestWasAlreadyErroring
;
}
void
setPendingAbortRequest
(
JSObject
*
promise
const
JS
:
:
Value
&
reason
bool
wasAlreadyErroring
)
{
MOZ_ASSERT
(
!
hasPendingAbortRequest
(
)
)
;
MOZ_ASSERT
(
!
(
flags
(
)
&
PendingAbortRequestWasAlreadyErroring
)
)
;
setFixedSlot
(
Slot_PendingAbortRequestPromise
JS
:
:
ObjectValue
(
*
promise
)
)
;
setFixedSlot
(
Slot_PendingAbortRequestReason
reason
)
;
setFlag
(
PendingAbortRequestWasAlreadyErroring
wasAlreadyErroring
)
;
}
void
clearPendingAbortRequest
(
)
{
MOZ_ASSERT
(
stateIsInitialized
(
)
)
;
MOZ_ASSERT
(
hasPendingAbortRequest
(
)
)
;
setFixedSlot
(
Slot_PendingAbortRequestPromise
JS
:
:
UndefinedValue
(
)
)
;
setFixedSlot
(
Slot_PendingAbortRequestReason
JS
:
:
UndefinedValue
(
)
)
;
}
static
MOZ_MUST_USE
WritableStream
*
create
(
JSContext
*
cx
void
*
nsISupportsObject_alreadyAddreffed
=
nullptr
JS
:
:
Handle
<
JSObject
*
>
proto
=
nullptr
)
;
static
bool
constructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
static
const
ClassSpec
classSpec_
;
static
const
JSClass
class_
;
static
const
ClassSpec
protoClassSpec_
;
static
const
JSClass
protoClass_
;
}
;
}
#
endif
