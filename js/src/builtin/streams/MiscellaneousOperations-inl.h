#
ifndef
builtin_streams_MiscellaneousOperations_inl_h
#
define
builtin_streams_MiscellaneousOperations_inl_h
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
namespace
js
{
template
<
class
.
.
.
Args
>
inline
MOZ_MUST_USE
JSObject
*
PromiseCall
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
F
JS
:
:
Handle
<
JS
:
:
Value
>
V
Args
&
&
.
.
.
args
)
{
cx
-
>
check
(
F
)
;
cx
-
>
check
(
V
)
;
cx
-
>
check
(
args
.
.
.
)
;
MOZ_ASSERT
(
IsCallable
(
F
)
)
;
MOZ_ASSERT
(
!
V
.
isUndefined
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
cx
)
;
if
(
!
Call
(
cx
F
V
args
.
.
.
&
rval
)
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
return
PromiseObject
:
:
unforgeableResolve
(
cx
rval
)
;
}
inline
MOZ_MUST_USE
bool
ResolveUnwrappedPromiseWithValue
(
JSContext
*
cx
JSObject
*
unwrappedPromise
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
{
cx
-
>
check
(
value
)
;
JS
:
:
Rooted
<
JSObject
*
>
promise
(
cx
unwrappedPromise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
{
return
false
;
}
return
JS
:
:
ResolvePromise
(
cx
promise
value
)
;
}
inline
MOZ_MUST_USE
bool
ResolveUnwrappedPromiseWithUndefined
(
JSContext
*
cx
JSObject
*
unwrappedPromise
)
{
return
ResolveUnwrappedPromiseWithValue
(
cx
unwrappedPromise
JS
:
:
UndefinedHandleValue
)
;
}
inline
MOZ_MUST_USE
bool
RejectUnwrappedPromiseWithError
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JSObject
*
>
unwrappedPromise
JS
:
:
Handle
<
JS
:
:
Value
>
error
)
{
cx
-
>
check
(
error
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
unwrappedPromise
)
)
{
return
false
;
}
return
JS
:
:
RejectPromise
(
cx
unwrappedPromise
error
)
;
}
inline
MOZ_MUST_USE
bool
RejectUnwrappedPromiseWithError
(
JSContext
*
cx
JSObject
*
unwrappedPromise
JS
:
:
Handle
<
JS
:
:
Value
>
error
)
{
JS
:
:
Rooted
<
JSObject
*
>
promise
(
cx
unwrappedPromise
)
;
return
RejectUnwrappedPromiseWithError
(
cx
&
promise
error
)
;
}
inline
void
SetSettledPromiseIsHandled
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
unwrappedPromise
)
{
MOZ_ASSERT
(
unwrappedPromise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
unwrappedPromise
-
>
setHandled
(
)
;
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
unwrappedPromise
)
;
}
}
#
endif
