#
ifndef
builtin_streams_PipeToState_h
#
define
builtin_streams_PipeToState_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
class
JS_PUBLIC_API
JSObject
;
namespace
js
{
class
ReadableStream
;
class
WritableStream
;
class
PipeToState
:
public
NativeObject
{
public
:
enum
Slots
{
Slot_Flags
=
0
Slot_Promise
Slot_Reader
Slot_Writer
Slot_LastWriteRequest
SlotCount
}
;
private
:
enum
Flags
:
uint32_t
{
Flag_ShuttingDown
=
0b0001
Flag_PreventClose
=
0b0010
Flag_PreventAbort
=
0b0100
Flag_PreventCancel
=
0b1000
Flag_PendingRead
=
0b1
'
0000
#
ifdef
DEBUG
Flag_PendingReadWouldBeRejected
=
0b10
'
0000
#
endif
}
;
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
JS
:
:
Int32Value
(
flags
)
)
;
}
public
:
static
const
JSClass
class_
;
PromiseObject
*
promise
(
)
const
{
return
&
getFixedSlot
(
Slot_Promise
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
ReadableStreamDefaultReader
*
reader
(
)
const
{
return
&
getFixedSlot
(
Slot_Reader
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultReader
>
(
)
;
}
WritableStreamDefaultWriter
*
writer
(
)
const
{
return
&
getFixedSlot
(
Slot_Writer
)
.
toObject
(
)
.
as
<
WritableStreamDefaultWriter
>
(
)
;
}
PromiseObject
*
lastWriteRequest
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
Slot_LastWriteRequest
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
&
slot
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
void
updateLastWriteRequest
(
PromiseObject
*
writeRequest
)
{
MOZ_ASSERT
(
writeRequest
!
=
nullptr
)
;
setFixedSlot
(
Slot_LastWriteRequest
JS
:
:
ObjectValue
(
*
writeRequest
)
)
;
}
bool
shuttingDown
(
)
const
{
return
flags
(
)
&
Flag_ShuttingDown
;
}
void
setShuttingDown
(
)
{
MOZ_ASSERT
(
!
shuttingDown
(
)
)
;
setFlags
(
flags
(
)
|
Flag_ShuttingDown
)
;
}
bool
preventClose
(
)
const
{
return
flags
(
)
&
Flag_PreventClose
;
}
bool
preventAbort
(
)
const
{
return
flags
(
)
&
Flag_PreventAbort
;
}
bool
preventCancel
(
)
const
{
return
flags
(
)
&
Flag_PreventCancel
;
}
bool
hasPendingRead
(
)
const
{
return
flags
(
)
&
Flag_PendingRead
;
}
void
setPendingRead
(
)
{
MOZ_ASSERT
(
!
hasPendingRead
(
)
)
;
setFlags
(
flags
(
)
|
Flag_PendingRead
)
;
}
void
clearPendingRead
(
)
{
MOZ_ASSERT
(
hasPendingRead
(
)
)
;
setFlags
(
flags
(
)
&
~
Flag_PendingRead
)
;
}
#
ifdef
DEBUG
bool
pendingReadWouldBeRejected
(
)
const
{
return
flags
(
)
&
Flag_PendingReadWouldBeRejected
;
}
void
setPendingReadWouldBeRejected
(
)
{
MOZ_ASSERT
(
!
pendingReadWouldBeRejected
(
)
)
;
setFlags
(
flags
(
)
|
Flag_PendingReadWouldBeRejected
)
;
}
#
endif
void
initFlags
(
bool
preventClose
bool
preventAbort
bool
preventCancel
)
{
MOZ_ASSERT
(
getFixedSlot
(
Slot_Flags
)
.
isUndefined
(
)
)
;
uint32_t
flagBits
=
(
preventClose
?
Flag_PreventClose
:
0
)
|
(
preventAbort
?
Flag_PreventAbort
:
0
)
|
(
preventCancel
?
Flag_PreventCancel
:
0
)
;
setFlags
(
flagBits
)
;
}
static
PipeToState
*
create
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
ReadableStream
*
>
unwrappedSource
JS
:
:
Handle
<
WritableStream
*
>
unwrappedDest
bool
preventClose
bool
preventAbort
bool
preventCancel
JS
:
:
Handle
<
JSObject
*
>
signal
)
;
}
;
}
#
endif
