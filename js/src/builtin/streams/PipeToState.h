#
ifndef
builtin_streams_PipeToState_h
#
define
builtin_streams_PipeToState_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
WrappingOperations
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
class
JS_PUBLIC_API
JSObject
;
namespace
js
{
class
ReadableStream
;
class
WritableStream
;
class
PipeToState
:
public
NativeObject
{
public
:
enum
Slots
{
Slot_Flags
=
0
Slot_Promise
Slot_Reader
Slot_Writer
Slot_LastWriteRequest
SlotCount
}
;
enum
class
ShutdownAction
{
AbortAlgorithm
AbortDestStream
CancelSource
CloseWriterWithErrorPropagation
}
;
private
:
enum
Flags
:
uint32_t
{
Flag_ShutdownActionBits
=
0b0000
'
0011
Flag_ShuttingDown
=
0b0000
'
0100
Flag_PendingRead
=
0b0000
'
1000
#
ifdef
DEBUG
Flag_PendingReadWouldBeRejected
=
0b0001
'
0000
#
endif
Flag_PreventClose
=
0b0010
'
0000
Flag_PreventAbort
=
0b0100
'
0000
Flag_PreventCancel
=
0b1000
'
0000
}
;
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
JS
:
:
Int32Value
(
mozilla
:
:
WrapToSigned
(
flags
)
)
)
;
}
static
constexpr
ShutdownAction
UninitializedAction
=
ShutdownAction
:
:
AbortAlgorithm
;
static_assert
(
Flag_ShutdownActionBits
&
1
"
shutdown
action
bits
must
be
low
-
order
bits
so
that
we
can
"
"
cast
ShutdownAction
values
directly
to
bits
to
store
"
)
;
static
constexpr
uint32_t
MaxAction
=
static_cast
<
uint32_t
>
(
ShutdownAction
:
:
CloseWriterWithErrorPropagation
)
;
static_assert
(
MaxAction
<
=
Flag_ShutdownActionBits
"
max
action
shouldn
'
t
overflow
available
bits
to
store
it
"
)
;
public
:
static
const
JSClass
class_
;
PromiseObject
*
promise
(
)
const
{
return
&
getFixedSlot
(
Slot_Promise
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
ReadableStreamDefaultReader
*
reader
(
)
const
{
return
&
getFixedSlot
(
Slot_Reader
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultReader
>
(
)
;
}
WritableStreamDefaultWriter
*
writer
(
)
const
{
return
&
getFixedSlot
(
Slot_Writer
)
.
toObject
(
)
.
as
<
WritableStreamDefaultWriter
>
(
)
;
}
PromiseObject
*
lastWriteRequest
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
Slot_LastWriteRequest
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
&
slot
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
void
updateLastWriteRequest
(
PromiseObject
*
writeRequest
)
{
MOZ_ASSERT
(
writeRequest
!
=
nullptr
)
;
setFixedSlot
(
Slot_LastWriteRequest
JS
:
:
ObjectValue
(
*
writeRequest
)
)
;
}
bool
shuttingDown
(
)
const
{
return
flags
(
)
&
Flag_ShuttingDown
;
}
void
setShuttingDown
(
)
{
MOZ_ASSERT
(
!
shuttingDown
(
)
)
;
setFlags
(
flags
(
)
|
Flag_ShuttingDown
)
;
}
ShutdownAction
shutdownAction
(
)
const
{
MOZ_ASSERT
(
shuttingDown
(
)
"
must
be
shutting
down
to
have
a
shutdown
action
"
)
;
uint32_t
bits
=
flags
(
)
&
Flag_ShutdownActionBits
;
static_assert
(
Flag_ShutdownActionBits
&
1
"
shutdown
action
bits
are
assumed
to
be
low
-
order
bits
that
"
"
don
'
t
have
to
be
shifted
down
to
ShutdownAction
'
s
range
"
)
;
MOZ_ASSERT
(
bits
<
=
MaxAction
"
bits
must
encode
a
valid
action
"
)
;
return
static_cast
<
ShutdownAction
>
(
bits
)
;
}
void
setShutdownAction
(
ShutdownAction
action
)
{
MOZ_ASSERT
(
shuttingDown
(
)
"
must
be
protected
by
the
|
shuttingDown
|
boolean
to
save
the
"
"
shutdown
action
"
)
;
MOZ_ASSERT
(
shutdownAction
(
)
=
=
UninitializedAction
"
should
only
set
shutdown
action
once
"
)
;
setFlags
(
flags
(
)
|
static_cast
<
uint32_t
>
(
action
)
)
;
}
bool
preventClose
(
)
const
{
return
flags
(
)
&
Flag_PreventClose
;
}
bool
preventAbort
(
)
const
{
return
flags
(
)
&
Flag_PreventAbort
;
}
bool
preventCancel
(
)
const
{
return
flags
(
)
&
Flag_PreventCancel
;
}
bool
hasPendingRead
(
)
const
{
return
flags
(
)
&
Flag_PendingRead
;
}
void
setPendingRead
(
)
{
MOZ_ASSERT
(
!
hasPendingRead
(
)
)
;
setFlags
(
flags
(
)
|
Flag_PendingRead
)
;
}
void
clearPendingRead
(
)
{
MOZ_ASSERT
(
hasPendingRead
(
)
)
;
setFlags
(
flags
(
)
&
~
Flag_PendingRead
)
;
}
#
ifdef
DEBUG
bool
pendingReadWouldBeRejected
(
)
const
{
return
flags
(
)
&
Flag_PendingReadWouldBeRejected
;
}
void
setPendingReadWouldBeRejected
(
)
{
MOZ_ASSERT
(
!
pendingReadWouldBeRejected
(
)
)
;
setFlags
(
flags
(
)
|
Flag_PendingReadWouldBeRejected
)
;
}
#
endif
void
initFlags
(
bool
preventClose
bool
preventAbort
bool
preventCancel
)
{
MOZ_ASSERT
(
getFixedSlot
(
Slot_Flags
)
.
isUndefined
(
)
)
;
uint32_t
flagBits
=
(
preventClose
?
Flag_PreventClose
:
0
)
|
(
preventAbort
?
Flag_PreventAbort
:
0
)
|
(
preventCancel
?
Flag_PreventCancel
:
0
)
;
setFlags
(
flagBits
)
;
}
static
PipeToState
*
create
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
ReadableStream
*
>
unwrappedSource
JS
:
:
Handle
<
WritableStream
*
>
unwrappedDest
bool
preventClose
bool
preventAbort
bool
preventCancel
JS
:
:
Handle
<
JSObject
*
>
signal
)
;
}
;
}
#
endif
