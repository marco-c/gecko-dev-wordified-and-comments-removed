#
ifndef
builtin_streams_TeeState_h
#
define
builtin_streams_TeeState_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
TeeState
:
public
NativeObject
{
public
:
enum
Slots
{
Slot_Flags
=
0
Slot_Reason1
Slot_Reason2
Slot_CancelPromise
Slot_Stream
Slot_Branch1
Slot_Branch2
SlotCount
}
;
private
:
enum
Flags
{
Flag_Reading
=
1
<
<
0
Flag_Canceled1
=
1
<
<
1
Flag_Canceled2
=
1
<
<
2
}
;
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
JS
:
:
Int32Value
(
flags
)
)
;
}
public
:
static
const
JSClass
class_
;
static
constexpr
bool
cloneForBranch2
(
)
{
return
false
;
}
bool
reading
(
)
const
{
return
flags
(
)
&
Flag_Reading
;
}
void
setReading
(
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Reading
)
)
;
setFlags
(
flags
(
)
|
Flag_Reading
)
;
}
void
unsetReading
(
)
{
MOZ_ASSERT
(
flags
(
)
&
Flag_Reading
)
;
setFlags
(
flags
(
)
&
~
Flag_Reading
)
;
}
bool
canceled1
(
)
const
{
return
flags
(
)
&
Flag_Canceled1
;
}
void
setCanceled1
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled1
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled1
)
;
setFixedSlot
(
Slot_Reason1
reason
)
;
}
bool
canceled2
(
)
const
{
return
flags
(
)
&
Flag_Canceled2
;
}
void
setCanceled2
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled2
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled2
)
;
setFixedSlot
(
Slot_Reason2
reason
)
;
}
JS
:
:
Value
reason1
(
)
const
{
MOZ_ASSERT
(
canceled1
(
)
)
;
return
getFixedSlot
(
Slot_Reason1
)
;
}
JS
:
:
Value
reason2
(
)
const
{
MOZ_ASSERT
(
canceled2
(
)
)
;
return
getFixedSlot
(
Slot_Reason2
)
;
}
PromiseObject
*
cancelPromise
(
)
{
return
&
getFixedSlot
(
Slot_CancelPromise
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
ReadableStreamDefaultController
*
branch1
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch1
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
controller
-
>
isTeeBranch1
(
)
)
;
return
controller
;
}
void
setBranch1
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
controller
-
>
isTeeBranch1
(
)
)
;
setFixedSlot
(
Slot_Branch1
JS
:
:
ObjectValue
(
*
controller
)
)
;
}
ReadableStreamDefaultController
*
branch2
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch2
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
controller
-
>
isTeeBranch2
(
)
)
;
return
controller
;
}
void
setBranch2
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
controller
-
>
isTeeBranch2
(
)
)
;
setFixedSlot
(
Slot_Branch2
JS
:
:
ObjectValue
(
*
controller
)
)
;
}
static
TeeState
*
create
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
;
}
;
}
#
endif
