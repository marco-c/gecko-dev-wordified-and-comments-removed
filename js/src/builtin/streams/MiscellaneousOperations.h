#
ifndef
builtin_streams_MiscellaneousOperations_h
#
define
builtin_streams_MiscellaneousOperations_h
#
include
"
jstypes
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
class
PropertyName
;
[
[
nodiscard
]
]
extern
PromiseObject
*
PromiseRejectedWithPendingError
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
inline
bool
ReturnPromiseRejectedWithPendingError
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
PromiseObject
*
promise
=
PromiseRejectedWithPendingError
(
cx
)
;
if
(
!
promise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
promise
)
;
return
true
;
}
[
[
nodiscard
]
]
extern
bool
CreateAlgorithmFromUnderlyingMethod
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
underlyingObject
const
char
*
methodNameForErrorMessage
JS
:
:
Handle
<
PropertyName
*
>
methodName
JS
:
:
MutableHandle
<
JS
:
:
Value
>
method
)
;
[
[
nodiscard
]
]
extern
bool
InvokeOrNoop
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
O
JS
:
:
Handle
<
PropertyName
*
>
P
JS
:
:
Handle
<
JS
:
:
Value
>
arg
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
;
[
[
nodiscard
]
]
extern
bool
ValidateAndNormalizeHighWaterMark
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
highWaterMarkVal
double
*
highWaterMark
)
;
[
[
nodiscard
]
]
extern
bool
MakeSizeAlgorithmFromSizeFunction
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
size
)
;
template
<
class
T
>
inline
bool
IsMaybeWrapped
(
const
JS
:
:
Handle
<
JS
:
:
Value
>
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
canUnwrapAs
<
T
>
(
)
;
}
}
#
endif
