#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
Stream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
js
:
:
ReadableStreamController
;
using
js
:
:
UnwrapStreamFromReader
;
using
JS
:
:
Handle
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamReaderGenericCancel
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
unwrappedReader
Handle
<
Value
>
reason
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromReader
(
cx
unwrappedReader
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
return
js
:
:
ReadableStreamCancel
(
cx
unwrappedStream
reason
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderGenericInitialize
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
Handle
<
ReadableStream
*
>
unwrappedStream
ForAuthorCodeBool
forAuthorCode
)
{
cx
-
>
check
(
reader
)
;
{
Rooted
<
JSObject
*
>
readerCompartmentStream
(
cx
unwrappedStream
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readerCompartmentStream
)
)
{
return
false
;
}
reader
-
>
setStream
(
readerCompartmentStream
)
;
}
Rooted
<
JSObject
*
>
promise
(
cx
)
;
if
(
unwrappedStream
-
>
readable
(
)
)
{
promise
=
PromiseObject
:
:
createSkippingExecutor
(
cx
)
;
}
else
if
(
unwrappedStream
-
>
closed
(
)
)
{
promise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
MOZ_ASSERT
(
unwrappedStream
-
>
errored
(
)
)
;
Rooted
<
Value
>
storedError
(
cx
unwrappedStream
-
>
storedError
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
promise
=
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
if
(
!
promise
)
{
return
false
;
}
promise
-
>
as
<
PromiseObject
>
(
)
.
setHandled
(
)
;
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
promise
)
;
}
if
(
!
promise
)
{
return
false
;
}
reader
-
>
setClosedPromise
(
promise
)
;
reader
-
>
setForAuthorCode
(
forAuthorCode
)
;
if
(
!
StoreNewListInFixedSlot
(
cx
reader
ReadableStreamReader
:
:
Slot_Requests
)
)
{
return
false
;
}
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
Rooted
<
JSObject
*
>
streamCompartmentReader
(
cx
reader
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
streamCompartmentReader
)
)
{
return
false
;
}
unwrappedStream
-
>
setReader
(
streamCompartmentReader
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
unwrappedReader
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromReader
(
cx
unwrappedReader
)
)
;
if
(
!
unwrappedStream
)
{
return
false
;
}
#
ifdef
DEBUG
ReadableStreamReader
*
unwrappedReader2
=
UnwrapReaderFromStreamNoThrow
(
unwrappedStream
)
;
MOZ_ASSERT_IF
(
unwrappedReader2
unwrappedReader2
=
=
unwrappedReader
)
;
#
endif
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_RELEASED
)
;
Rooted
<
Value
>
exn
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
exn
)
)
{
return
false
;
}
Rooted
<
PromiseObject
*
>
unwrappedClosedPromise
(
cx
)
;
if
(
unwrappedStream
-
>
readable
(
)
)
{
unwrappedClosedPromise
=
UnwrapInternalSlot
<
PromiseObject
>
(
cx
unwrappedReader
ReadableStreamReader
:
:
Slot_ClosedPromise
)
;
if
(
!
unwrappedClosedPromise
)
{
return
false
;
}
AutoRealm
ar
(
cx
unwrappedClosedPromise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
exn
)
)
{
return
false
;
}
if
(
!
PromiseObject
:
:
reject
(
cx
unwrappedClosedPromise
exn
)
)
{
return
false
;
}
}
else
{
Rooted
<
JSObject
*
>
closedPromise
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
exn
)
)
;
if
(
!
closedPromise
)
{
return
false
;
}
unwrappedClosedPromise
=
&
closedPromise
-
>
as
<
PromiseObject
>
(
)
;
AutoRealm
ar
(
cx
unwrappedReader
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
unwrappedReader
-
>
setClosedPromise
(
closedPromise
)
;
}
unwrappedClosedPromise
-
>
setHandled
(
)
;
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
unwrappedClosedPromise
)
;
unwrappedStream
-
>
clearReader
(
)
;
unwrappedReader
-
>
clearStream
(
)
;
return
true
;
}
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamDefaultReaderRead
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultReader
*
>
unwrappedReader
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromReader
(
cx
unwrappedReader
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
unwrappedStream
-
>
setDisturbed
(
)
;
if
(
unwrappedStream
-
>
closed
(
)
)
{
RootedObject
iterResult
(
cx
ReadableStreamCreateReadResult
(
cx
UndefinedHandleValue
true
unwrappedReader
-
>
forAuthorCode
(
)
)
)
;
if
(
!
iterResult
)
{
return
nullptr
;
}
Rooted
<
Value
>
iterResultVal
(
cx
JS
:
:
ObjectValue
(
*
iterResult
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
iterResultVal
)
;
}
if
(
unwrappedStream
-
>
errored
(
)
)
{
Rooted
<
Value
>
storedError
(
cx
unwrappedStream
-
>
storedError
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
return
ReadableStreamControllerPullSteps
(
cx
unwrappedController
)
;
}
