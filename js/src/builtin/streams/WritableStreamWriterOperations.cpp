#
include
"
builtin
/
streams
/
WritableStreamWriterOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultController
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultControllerOperations
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamOperations
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Handle
;
using
JS
:
:
Int32Value
;
using
JS
:
:
MutableHandle
;
using
JS
:
:
NullValue
;
using
JS
:
:
NumberValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
using
js
:
:
AutoRealm
;
using
js
:
:
PromiseObject
;
using
js
:
:
UnwrapAndDowncastObject
;
using
js
:
:
WritableStreamDefaultWriter
;
JSObject
*
js
:
:
WritableStreamDefaultWriterAbort
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
Handle
<
Value
>
reason
)
{
cx
-
>
check
(
reason
)
;
MOZ_ASSERT
(
unwrappedWriter
-
>
hasStream
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
return
WritableStreamAbort
(
cx
unwrappedStream
reason
)
;
}
JSObject
*
js
:
:
WritableStreamDefaultWriterClose
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
)
{
MOZ_ASSERT
(
unwrappedWriter
-
>
hasStream
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
)
;
if
(
!
unwrappedStream
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
unwrappedStream
-
>
closed
(
)
|
|
unwrappedStream
-
>
errored
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_CLOSED_OR_ERRORED
)
;
return
PromiseRejectedWithPendingError
(
cx
)
;
}
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
^
unwrappedStream
-
>
erroring
(
)
)
;
MOZ_ASSERT
(
!
WritableStreamCloseQueuedOrInFlight
(
unwrappedStream
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
Rooted
<
JSObject
*
>
closeRequest
(
cx
promise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closeRequest
)
)
{
return
nullptr
;
}
unwrappedStream
-
>
setCloseRequest
(
closeRequest
)
;
}
if
(
unwrappedStream
-
>
backpressure
(
)
&
&
unwrappedStream
-
>
writable
(
)
)
{
if
(
!
ResolveUnwrappedPromiseWithUndefined
(
cx
unwrappedWriter
-
>
readyPromise
(
)
)
)
{
return
nullptr
;
}
}
Rooted
<
WritableStreamDefaultController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
if
(
!
WritableStreamDefaultControllerClose
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
promise
;
}
using
GetField
=
JSObject
*
(
WritableStreamDefaultWriter
:
:
*
)
(
)
const
;
using
SetField
=
void
(
WritableStreamDefaultWriter
:
:
*
)
(
JSObject
*
)
;
static
bool
EnsurePromiseRejected
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
GetField
getField
SetField
setField
Handle
<
Value
>
error
)
{
cx
-
>
check
(
error
)
;
Rooted
<
PromiseObject
*
>
unwrappedPromise
(
cx
UnwrapAndDowncastObject
<
PromiseObject
>
(
cx
(
unwrappedWriter
-
>
*
getField
)
(
)
)
)
;
if
(
!
unwrappedPromise
)
{
return
false
;
}
if
(
unwrappedPromise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
{
if
(
!
RejectUnwrappedPromiseWithError
(
cx
unwrappedPromise
error
)
)
{
return
false
;
}
}
else
{
Rooted
<
JSObject
*
>
rejectedWithError
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
error
)
)
;
if
(
!
rejectedWithError
)
{
return
false
;
}
{
AutoRealm
ar
(
cx
unwrappedWriter
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
rejectedWithError
)
)
{
return
false
;
}
(
unwrappedWriter
-
>
*
setField
)
(
rejectedWithError
)
;
}
unwrappedPromise
=
&
rejectedWithError
-
>
as
<
PromiseObject
>
(
)
;
}
unwrappedPromise
-
>
setHandled
(
)
;
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
unwrappedPromise
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
WritableStreamDefaultWriterEnsureClosedPromiseRejected
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
Handle
<
Value
>
error
)
{
return
EnsurePromiseRejected
(
cx
unwrappedWriter
&
WritableStreamDefaultWriter
:
:
closedPromise
&
WritableStreamDefaultWriter
:
:
setClosedPromise
error
)
;
}
MOZ_MUST_USE
bool
js
:
:
WritableStreamDefaultWriterEnsureReadyPromiseRejected
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
Handle
<
Value
>
error
)
{
return
EnsurePromiseRejected
(
cx
unwrappedWriter
&
WritableStreamDefaultWriter
:
:
readyPromise
&
WritableStreamDefaultWriter
:
:
setReadyPromise
error
)
;
}
bool
js
:
:
WritableStreamDefaultWriterGetDesiredSize
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
MutableHandle
<
Value
>
size
)
{
const
WritableStream
*
unwrappedStream
=
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
;
if
(
!
unwrappedStream
)
{
return
false
;
}
if
(
unwrappedStream
-
>
errored
(
)
|
|
unwrappedStream
-
>
erroring
(
)
)
{
size
.
setNull
(
)
;
}
else
if
(
unwrappedStream
-
>
closed
(
)
)
{
size
.
setInt32
(
0
)
;
}
else
{
size
.
setNumber
(
WritableStreamDefaultControllerGetDesiredSize
(
unwrappedStream
-
>
controller
(
)
)
)
;
}
return
true
;
}
bool
js
:
:
WritableStreamDefaultWriterRelease
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
)
{
MOZ_ASSERT
(
unwrappedWriter
-
>
hasStream
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
)
;
if
(
!
unwrappedStream
)
{
return
false
;
}
#
ifdef
DEBUG
{
WritableStreamDefaultWriter
*
unwrappedStreamWriter
=
UnwrapWriterFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedStreamWriter
)
{
return
false
;
}
MOZ_ASSERT
(
unwrappedStreamWriter
=
=
unwrappedWriter
)
;
}
#
endif
Rooted
<
Value
>
releasedError
(
cx
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_CANT_RELEASE_ALREADY_CLOSED
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
releasedError
)
)
{
return
false
;
}
if
(
!
WritableStreamDefaultWriterEnsureReadyPromiseRejected
(
cx
unwrappedWriter
releasedError
)
)
{
return
false
;
}
if
(
!
WritableStreamDefaultWriterEnsureClosedPromiseRejected
(
cx
unwrappedWriter
releasedError
)
)
{
return
false
;
}
unwrappedStream
-
>
clearWriter
(
)
;
unwrappedWriter
-
>
clearStream
(
)
;
return
true
;
}
JSObject
*
js
:
:
WritableStreamDefaultWriterWrite
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
Handle
<
Value
>
chunk
)
{
cx
-
>
check
(
chunk
)
;
MOZ_ASSERT
(
unwrappedWriter
-
>
hasStream
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
Rooted
<
WritableStreamDefaultController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
Rooted
<
Value
>
chunkSize
(
cx
)
;
if
(
!
WritableStreamDefaultControllerGetChunkSize
(
cx
unwrappedController
chunk
&
chunkSize
)
)
{
return
nullptr
;
}
cx
-
>
check
(
chunkSize
)
;
if
(
!
unwrappedWriter
-
>
hasStream
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_RELEASED_DURING_WRITE
)
;
return
PromiseRejectedWithPendingError
(
cx
)
;
}
auto
RejectWithStoredError
=
[
]
(
JSContext
*
cx
Handle
<
WritableStream
*
>
unwrappedStream
)
-
>
JSObject
*
{
Rooted
<
Value
>
storedError
(
cx
unwrappedStream
-
>
storedError
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
;
if
(
unwrappedStream
-
>
errored
(
)
)
{
return
RejectWithStoredError
(
cx
unwrappedStream
)
;
}
if
(
WritableStreamCloseQueuedOrInFlight
(
unwrappedStream
)
|
|
unwrappedStream
-
>
closed
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED
)
;
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
unwrappedStream
-
>
erroring
(
)
)
{
return
RejectWithStoredError
(
cx
unwrappedStream
)
;
}
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
WritableStreamAddWriteRequest
(
cx
unwrappedStream
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
WritableStreamDefaultControllerWrite
(
cx
unwrappedController
chunk
chunkSize
)
)
{
return
nullptr
;
}
return
promise
;
}
