#
include
"
builtin
/
streams
/
WritableStreamWriterOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultController
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultControllerOperations
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamOperations
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Handle
;
using
JS
:
:
Int32Value
;
using
JS
:
:
MutableHandle
;
using
JS
:
:
NullValue
;
using
JS
:
:
NumberValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
using
js
:
:
PromiseObject
;
JSObject
*
js
:
:
WritableStreamDefaultWriterClose
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
)
{
MOZ_ASSERT
(
unwrappedWriter
-
>
hasStream
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
)
;
if
(
!
unwrappedStream
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
unwrappedStream
-
>
closed
(
)
|
|
unwrappedStream
-
>
errored
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_CLOSED_OR_ERRORED
)
;
return
PromiseRejectedWithPendingError
(
cx
)
;
}
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
^
unwrappedStream
-
>
erroring
(
)
)
;
MOZ_ASSERT
(
!
WritableStreamCloseQueuedOrInFlight
(
unwrappedStream
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
Rooted
<
JSObject
*
>
closeRequest
(
cx
promise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closeRequest
)
)
{
return
nullptr
;
}
unwrappedStream
-
>
setCloseRequest
(
closeRequest
)
;
}
if
(
unwrappedStream
-
>
backpressure
(
)
&
&
unwrappedStream
-
>
writable
(
)
)
{
Rooted
<
JSObject
*
>
readyPromise
(
cx
unwrappedWriter
-
>
readyPromise
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readyPromise
)
)
{
return
nullptr
;
}
if
(
!
ResolvePromise
(
cx
readyPromise
UndefinedHandleValue
)
)
{
return
nullptr
;
}
}
Rooted
<
WritableStreamDefaultController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
if
(
!
WritableStreamDefaultControllerClose
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
promise
;
}
bool
js
:
:
WritableStreamDefaultWriterGetDesiredSize
(
JSContext
*
cx
Handle
<
WritableStreamDefaultWriter
*
>
unwrappedWriter
MutableHandle
<
Value
>
size
)
{
const
WritableStream
*
unwrappedStream
=
UnwrapStreamFromWriter
(
cx
unwrappedWriter
)
;
if
(
!
unwrappedStream
)
{
return
false
;
}
if
(
unwrappedStream
-
>
errored
(
)
|
|
unwrappedStream
-
>
erroring
(
)
)
{
size
.
setNull
(
)
;
}
else
if
(
unwrappedStream
-
>
closed
(
)
)
{
size
.
setInt32
(
0
)
;
}
else
{
size
.
setNumber
(
WritableStreamDefaultControllerGetDesiredSize
(
unwrappedStream
-
>
controller
(
)
)
)
;
}
return
true
;
}
