#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
streams
/
StreamController
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Handle
;
using
JS
:
:
MutableHandle
;
using
JS
:
:
NumberValue
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
ToNumber
;
using
JS
:
:
Value
;
class
QueueEntry
:
public
js
:
:
NativeObject
{
private
:
enum
Slots
{
Slot_Value
=
0
Slot_Size
SlotCount
}
;
public
:
static
const
JSClass
class_
;
Value
value
(
)
{
return
getFixedSlot
(
Slot_Value
)
;
}
double
size
(
)
{
return
getFixedSlot
(
Slot_Size
)
.
toNumber
(
)
;
}
static
QueueEntry
*
create
(
JSContext
*
cx
Handle
<
Value
>
value
double
size
)
{
Rooted
<
QueueEntry
*
>
entry
(
cx
js
:
:
NewBuiltinClassInstance
<
QueueEntry
>
(
cx
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
entry
-
>
setFixedSlot
(
Slot_Value
value
)
;
entry
-
>
setFixedSlot
(
Slot_Size
NumberValue
(
size
)
)
;
return
entry
;
}
}
;
const
JSClass
QueueEntry
:
:
class_
=
{
"
QueueEntry
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
MOZ_MUST_USE
bool
js
:
:
DequeueValue
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
MutableHandle
<
Value
>
chunk
)
{
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedContainer
-
>
queue
(
)
)
;
MOZ_ASSERT
(
unwrappedQueue
-
>
length
(
)
>
0
)
;
Rooted
<
QueueEntry
*
>
unwrappedPair
(
cx
&
unwrappedQueue
-
>
popFirstAs
<
QueueEntry
>
(
cx
)
)
;
MOZ_ASSERT
(
unwrappedPair
)
;
double
totalSize
=
unwrappedContainer
-
>
queueTotalSize
(
)
;
totalSize
-
=
unwrappedPair
-
>
size
(
)
;
if
(
totalSize
<
0
)
{
totalSize
=
0
;
}
unwrappedContainer
-
>
setQueueTotalSize
(
totalSize
)
;
Rooted
<
Value
>
val
(
cx
unwrappedPair
-
>
value
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
val
)
)
{
return
false
;
}
chunk
.
set
(
val
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
EnqueueValueWithSize
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
Handle
<
Value
>
value
Handle
<
Value
>
sizeVal
)
{
cx
-
>
check
(
value
sizeVal
)
;
double
size
;
if
(
!
ToNumber
(
cx
sizeVal
&
size
)
)
{
return
false
;
}
if
(
size
<
0
|
|
mozilla
:
:
IsNaN
(
size
)
|
|
mozilla
:
:
IsInfinite
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE
"
size
"
)
;
return
false
;
}
{
AutoRealm
ar
(
cx
unwrappedContainer
)
;
Rooted
<
ListObject
*
>
queue
(
cx
unwrappedContainer
-
>
queue
(
)
)
;
Rooted
<
Value
>
wrappedVal
(
cx
value
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedVal
)
)
{
return
false
;
}
QueueEntry
*
entry
=
QueueEntry
:
:
create
(
cx
wrappedVal
size
)
;
if
(
!
entry
)
{
return
false
;
}
Rooted
<
Value
>
val
(
cx
ObjectValue
(
*
entry
)
)
;
if
(
!
queue
-
>
append
(
cx
val
)
)
{
return
false
;
}
}
unwrappedContainer
-
>
setQueueTotalSize
(
unwrappedContainer
-
>
queueTotalSize
(
)
+
size
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ResetQueue
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
)
{
if
(
!
StoreNewListInFixedSlot
(
cx
unwrappedContainer
StreamController
:
:
Slot_Queue
)
)
{
return
false
;
}
unwrappedContainer
-
>
setQueueTotalSize
(
0
)
;
return
true
;
}
