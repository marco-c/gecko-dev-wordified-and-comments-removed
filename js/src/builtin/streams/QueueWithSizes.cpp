#
include
"
builtin
/
streams
/
QueueWithSizes
-
inl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
builtin
/
streams
/
StreamController
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Handle
;
using
JS
:
:
MutableHandle
;
using
JS
:
:
NumberValue
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
ToNumber
;
using
JS
:
:
Value
;
[
[
nodiscard
]
]
bool
js
:
:
DequeueValue
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
MutableHandle
<
Value
>
chunk
)
{
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedContainer
-
>
queue
(
)
)
;
double
chunkSize
=
detail
:
:
QueueFirstSize
(
unwrappedQueue
)
;
chunk
.
set
(
detail
:
:
QueueFirstValue
(
unwrappedQueue
)
)
;
detail
:
:
QueueRemoveFirstValueAndSize
(
unwrappedQueue
cx
)
;
double
totalSize
=
unwrappedContainer
-
>
queueTotalSize
(
)
;
totalSize
-
=
chunkSize
;
if
(
totalSize
<
0
)
{
totalSize
=
0
;
}
unwrappedContainer
-
>
setQueueTotalSize
(
totalSize
)
;
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
chunk
)
;
}
void
js
:
:
DequeueValue
(
StreamController
*
unwrappedContainer
JSContext
*
cx
)
{
ListObject
*
unwrappedQueue
=
unwrappedContainer
-
>
queue
(
)
;
double
chunkSize
=
detail
:
:
QueueFirstSize
(
unwrappedQueue
)
;
detail
:
:
QueueRemoveFirstValueAndSize
(
unwrappedQueue
cx
)
;
double
totalSize
=
unwrappedContainer
-
>
queueTotalSize
(
)
;
totalSize
-
=
chunkSize
;
if
(
totalSize
<
0
)
{
totalSize
=
0
;
}
unwrappedContainer
-
>
setQueueTotalSize
(
totalSize
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
EnqueueValueWithSize
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
Handle
<
Value
>
value
Handle
<
Value
>
sizeVal
)
{
cx
-
>
check
(
value
sizeVal
)
;
double
size
;
if
(
!
ToNumber
(
cx
sizeVal
&
size
)
)
{
return
false
;
}
if
(
size
<
0
|
|
mozilla
:
:
IsNaN
(
size
)
|
|
mozilla
:
:
IsInfinite
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE
"
size
"
)
;
return
false
;
}
{
AutoRealm
ar
(
cx
unwrappedContainer
)
;
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedContainer
-
>
queue
(
)
)
;
Rooted
<
Value
>
wrappedVal
(
cx
value
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedVal
)
)
{
return
false
;
}
if
(
!
detail
:
:
QueueAppendValueAndSize
(
cx
unwrappedQueue
wrappedVal
size
)
)
{
return
false
;
}
}
unwrappedContainer
-
>
setQueueTotalSize
(
unwrappedContainer
-
>
queueTotalSize
(
)
+
size
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
ResetQueue
(
JSContext
*
cx
Handle
<
StreamController
*
>
unwrappedContainer
)
{
if
(
!
StoreNewListInFixedSlot
(
cx
unwrappedContainer
StreamController
:
:
Slot_Queue
)
)
{
return
false
;
}
unwrappedContainer
-
>
setQueueTotalSize
(
0
)
;
return
true
;
}
