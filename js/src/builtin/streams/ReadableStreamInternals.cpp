#
include
"
builtin
/
streams
/
ReadableStreamInternals
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
builtin
/
Promise
-
inl
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
PlainObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
BooleanValue
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
ResolvePromise
;
using
JS
:
:
Rooted
;
using
JS
:
:
UndefinedHandleValue
;
using
JS
:
:
Value
;
using
js
:
:
PlainObject
;
using
js
:
:
ReadableStream
;
[
[
nodiscard
]
]
js
:
:
PromiseObject
*
js
:
:
ReadableStreamAddReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
{
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
MOZ_ASSERT
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
|
|
unwrappedStream
-
>
closed
(
)
)
;
MOZ_ASSERT_IF
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
unwrappedStream
-
>
readable
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
AppendToListInFixedSlot
(
cx
unwrappedReader
ReadableStreamReader
:
:
Slot_Requests
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
static
bool
ReturnUndefined
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
ReadableStreamCancel
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
Handle
<
Value
>
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
unwrappedStream
-
>
setDisturbed
(
)
;
if
(
unwrappedStream
-
>
closed
(
)
)
{
return
PromiseResolvedWithUndefined
(
cx
)
;
}
if
(
unwrappedStream
-
>
errored
(
)
)
{
Rooted
<
Value
>
storedError
(
cx
unwrappedStream
-
>
storedError
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
)
{
return
nullptr
;
}
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
Rooted
<
JSObject
*
>
sourceCancelPromise
(
cx
ReadableStreamControllerCancelSteps
(
cx
unwrappedController
reason
)
)
;
if
(
!
sourceCancelPromise
)
{
return
nullptr
;
}
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
Rooted
<
JSFunction
*
>
returnUndefined
(
cx
NewNativeFunction
(
cx
ReturnUndefined
0
funName
gc
:
:
AllocKind
:
:
FUNCTION
GenericObject
)
)
;
if
(
!
returnUndefined
)
{
return
nullptr
;
}
return
JS
:
:
CallOriginalPromiseThen
(
cx
sourceCancelPromise
returnUndefined
nullptr
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
{
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedStream
-
>
setClosed
(
)
;
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
if
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
{
ForAuthorCodeBool
forAuthorCode
=
unwrappedReader
-
>
forAuthorCode
(
)
;
Rooted
<
ListObject
*
>
unwrappedReadRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
uint32_t
len
=
unwrappedReadRequests
-
>
length
(
)
;
Rooted
<
JSObject
*
>
readRequest
(
cx
)
;
Rooted
<
JSObject
*
>
resultObj
(
cx
)
;
Rooted
<
Value
>
resultVal
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
readRequest
=
&
unwrappedReadRequests
-
>
getAs
<
JSObject
>
(
i
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readRequest
)
)
{
return
false
;
}
resultObj
=
js
:
:
ReadableStreamCreateReadResult
(
cx
UndefinedHandleValue
true
forAuthorCode
)
;
if
(
!
resultObj
)
{
return
false
;
}
resultVal
=
ObjectValue
(
*
resultObj
)
;
if
(
!
ResolvePromise
(
cx
readRequest
resultVal
)
)
{
return
false
;
}
}
unwrappedReader
-
>
clearRequests
(
)
;
}
if
(
!
ResolveUnwrappedPromiseWithUndefined
(
cx
unwrappedReader
-
>
closedPromise
(
)
)
)
{
return
false
;
}
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedStream
-
>
controller
(
)
-
>
externalSource
(
)
;
source
-
>
onClosed
(
cx
unwrappedStream
)
;
}
return
true
;
}
[
[
nodiscard
]
]
PlainObject
*
js
:
:
ReadableStreamCreateReadResult
(
JSContext
*
cx
Handle
<
Value
>
value
bool
done
ForAuthorCodeBool
forAuthorCode
)
{
Rooted
<
PlainObject
*
>
templateObject
(
cx
forAuthorCode
=
=
ForAuthorCodeBool
:
:
Yes
?
GlobalObject
:
:
getOrCreateIterResultTemplateObject
(
cx
cx
-
>
global
(
)
)
:
GlobalObject
:
:
getOrCreateIterResultWithoutPrototypeTemplateObject
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
PlainObject
*
obj
=
PlainObject
:
:
createWithTemplate
(
cx
templateObject
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
setSlot
(
GlobalObject
:
:
IterResultObjectValueSlot
value
)
;
obj
-
>
setSlot
(
GlobalObject
:
:
IterResultObjectDoneSlot
BooleanValue
(
done
)
)
;
return
obj
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableStreamErrorInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
Handle
<
Value
>
e
)
{
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedStream
-
>
setErrored
(
)
;
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
Rooted
<
Value
>
wrappedError
(
cx
e
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedError
)
)
{
return
false
;
}
unwrappedStream
-
>
setStoredError
(
wrappedError
)
;
}
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
{
Rooted
<
ListObject
*
>
unwrappedReadRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
Rooted
<
JSObject
*
>
readRequest
(
cx
)
;
uint32_t
len
=
unwrappedReadRequests
-
>
length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
readRequest
=
&
unwrappedReadRequests
-
>
get
(
i
)
.
toObject
(
)
;
if
(
!
RejectUnwrappedPromiseWithError
(
cx
&
readRequest
e
)
)
{
return
false
;
}
}
}
if
(
!
StoreNewListInFixedSlot
(
cx
unwrappedReader
ReadableStreamReader
:
:
Slot_Requests
)
)
{
return
false
;
}
if
(
!
RejectUnwrappedPromiseWithError
(
cx
unwrappedReader
-
>
closedPromise
(
)
e
)
)
{
return
false
;
}
Rooted
<
JSObject
*
>
closedPromise
(
cx
unwrappedReader
-
>
closedPromise
(
)
)
;
js
:
:
SetSettledPromiseIsHandled
(
cx
closedPromise
.
as
<
PromiseObject
>
(
)
)
;
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedStream
-
>
controller
(
)
-
>
externalSource
(
)
;
Rooted
<
Value
>
error
(
cx
e
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
error
)
)
{
return
false
;
}
source
-
>
onErrored
(
cx
unwrappedStream
error
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableStreamFulfillReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
Handle
<
Value
>
chunk
bool
done
)
{
cx
-
>
check
(
chunk
)
;
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
Rooted
<
ListObject
*
>
unwrappedReadIntoRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
Rooted
<
JSObject
*
>
readIntoRequest
(
cx
&
unwrappedReadIntoRequests
-
>
popFirstAs
<
JSObject
>
(
cx
)
)
;
MOZ_ASSERT
(
readIntoRequest
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readIntoRequest
)
)
{
return
false
;
}
PlainObject
*
iterResult
=
ReadableStreamCreateReadResult
(
cx
chunk
done
unwrappedReader
-
>
forAuthorCode
(
)
)
;
if
(
!
iterResult
)
{
return
false
;
}
Rooted
<
Value
>
val
(
cx
ObjectValue
(
*
iterResult
)
)
;
return
ResolvePromise
(
cx
readIntoRequest
val
)
;
}
uint32_t
js
:
:
ReadableStreamGetNumReadRequests
(
ReadableStream
*
stream
)
{
if
(
!
stream
-
>
hasReader
(
)
)
{
return
0
;
}
JS
:
:
AutoSuppressGCAnalysis
nogc
;
ReadableStreamReader
*
reader
=
UnwrapReaderFromStreamNoThrow
(
stream
)
;
if
(
!
reader
)
{
return
0
;
}
return
reader
-
>
requests
(
)
-
>
length
(
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableStreamHasDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
bool
*
result
)
{
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
*
result
=
false
;
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
*
result
=
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
;
return
true
;
}
