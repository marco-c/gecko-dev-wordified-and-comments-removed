#
include
"
builtin
/
streams
/
PipeToState
-
inl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamOperations
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamWriterOperations
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
builtin
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
Int32Value
;
using
JS
:
:
MagicValue
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
UndefinedHandleValue
;
using
JS
:
:
Value
;
using
js
:
:
ExtraValueFromHandler
;
using
js
:
:
GetErrorMessage
;
using
js
:
:
NewHandler
;
using
js
:
:
NewHandlerWithExtraValue
;
using
js
:
:
PipeToState
;
using
js
:
:
PromiseObject
;
using
js
:
:
ReadableStream
;
using
js
:
:
ReadableStreamDefaultReader
;
using
js
:
:
ReadableStreamReaderGenericRelease
;
using
js
:
:
TargetFromHandler
;
using
js
:
:
UnwrapReaderFromStream
;
using
js
:
:
UnwrapStreamFromWriter
;
using
js
:
:
UnwrapWriterFromStream
;
using
js
:
:
WritableStream
;
using
js
:
:
WritableStreamDefaultWriter
;
using
js
:
:
WritableStreamDefaultWriterRelease
;
using
js
:
:
WritableStreamDefaultWriterWrite
;
static
ReadableStream
*
GetUnwrappedSource
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
state
-
>
reader
(
)
)
;
cx
-
>
check
(
reader
)
;
return
UnwrapStreamFromReader
(
cx
reader
)
;
}
static
WritableStream
*
GetUnwrappedDest
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
return
UnwrapStreamFromWriter
(
cx
writer
)
;
}
static
bool
WritableAndNotClosing
(
const
WritableStream
*
unwrappedDest
)
{
return
unwrappedDest
-
>
writable
(
)
&
&
WritableStreamCloseQueuedOrInFlight
(
unwrappedDest
)
;
}
static
MOZ_MUST_USE
bool
Finalize
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
Maybe
<
Value
>
>
error
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
error
)
;
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
if
(
!
WritableStreamDefaultWriterRelease
(
cx
writer
)
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
state
-
>
reader
(
)
)
;
cx
-
>
check
(
reader
)
;
if
(
!
ReadableStreamReaderGenericRelease
(
cx
reader
)
)
{
return
false
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
state
-
>
promise
(
)
)
;
cx
-
>
check
(
promise
)
;
if
(
error
.
isSome
(
)
)
{
Rooted
<
Value
>
errorVal
(
cx
*
error
.
get
(
)
)
;
return
PromiseObject
:
:
reject
(
cx
promise
errorVal
)
;
}
return
PromiseObject
:
:
resolve
(
cx
promise
UndefinedHandleValue
)
;
}
static
MOZ_MUST_USE
bool
Finalize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
optionalError
(
cx
Nothing
(
)
)
;
if
(
Value
maybeError
=
ExtraValueFromHandler
(
args
)
;
!
maybeError
.
isMagic
(
JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR
)
)
{
optionalError
=
Some
(
maybeError
)
;
}
cx
-
>
check
(
optionalError
)
;
if
(
!
Finalize
(
cx
state
optionalError
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ActAndFinalize
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
Maybe
<
Value
>
>
error
)
{
Rooted
<
JSObject
*
>
p
(
cx
)
;
switch
(
state
-
>
shutdownAction
(
)
)
{
case
PipeToState
:
:
ShutdownAction
:
:
AbortAlgorithm
:
{
MOZ_ASSERT
(
error
.
get
(
)
.
isSome
(
)
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
any
required
actions
during
abortAlgorithm
"
)
;
return
false
;
}
case
PipeToState
:
:
ShutdownAction
:
:
AbortDestStream
:
{
MOZ_ASSERT
(
error
.
get
(
)
.
isSome
(
)
)
;
Rooted
<
WritableStream
*
>
unwrappedDest
(
cx
GetUnwrappedDest
(
cx
state
)
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
Rooted
<
Value
>
sourceStoredError
(
cx
*
error
.
get
(
)
)
;
cx
-
>
check
(
sourceStoredError
)
;
p
=
WritableStreamAbort
(
cx
unwrappedDest
sourceStoredError
)
;
break
;
}
case
PipeToState
:
:
ShutdownAction
:
:
CancelSource
:
{
MOZ_ASSERT
(
error
.
get
(
)
.
isSome
(
)
)
;
Rooted
<
ReadableStream
*
>
unwrappedSource
(
cx
GetUnwrappedSource
(
cx
state
)
)
;
if
(
!
unwrappedSource
)
{
return
false
;
}
Rooted
<
Value
>
reason
(
cx
*
error
.
get
(
)
)
;
cx
-
>
check
(
reason
)
;
p
=
ReadableStreamCancel
(
cx
unwrappedSource
reason
)
;
break
;
}
case
PipeToState
:
:
ShutdownAction
:
:
CloseWriterWithErrorPropagation
:
{
MOZ_ASSERT
(
error
.
get
(
)
.
isNothing
(
)
)
;
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
p
=
WritableStreamDefaultWriterCloseWithErrorPropagation
(
cx
writer
)
;
break
;
}
}
if
(
!
p
)
{
return
false
;
}
Rooted
<
JSFunction
*
>
onFulfilled
(
cx
)
;
{
Rooted
<
Value
>
optionalError
(
cx
error
.
isSome
(
)
?
*
error
.
get
(
)
:
MagicValue
(
JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR
)
)
;
onFulfilled
=
NewHandlerWithExtraValue
(
cx
Finalize
state
optionalError
)
;
if
(
!
onFulfilled
)
{
return
false
;
}
}
auto
OnRejected
=
[
]
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
newError
(
cx
Some
(
args
[
0
]
)
)
;
cx
-
>
check
(
newError
)
;
if
(
!
Finalize
(
cx
state
newError
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
;
Rooted
<
JSFunction
*
>
onRejected
(
cx
NewHandler
(
cx
OnRejected
state
)
)
;
if
(
!
onRejected
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
p
onFulfilled
onRejected
)
;
}
static
MOZ_MUST_USE
bool
ActAndFinalize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
optionalError
(
cx
Nothing
(
)
)
;
if
(
Value
maybeError
=
ExtraValueFromHandler
(
args
)
;
!
maybeError
.
isMagic
(
JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR
)
)
{
optionalError
=
Some
(
maybeError
)
;
}
cx
-
>
check
(
optionalError
)
;
if
(
!
ActAndFinalize
(
cx
state
optionalError
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ShutdownWithAction
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
PipeToState
:
:
ShutdownAction
action
Handle
<
Maybe
<
Value
>
>
originalError
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
originalError
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
state
-
>
setShuttingDown
(
)
;
state
-
>
setShutdownAction
(
action
)
;
WritableStream
*
unwrappedDest
=
GetUnwrappedDest
(
cx
state
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
WritableAndNotClosing
(
unwrappedDest
)
)
{
if
(
PromiseObject
*
p
=
state
-
>
lastWriteRequest
(
)
)
{
Rooted
<
PromiseObject
*
>
lastWriteRequest
(
cx
p
)
;
Rooted
<
Value
>
extra
(
cx
originalError
.
isSome
(
)
?
*
originalError
.
get
(
)
:
MagicValue
(
JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR
)
)
;
Rooted
<
JSFunction
*
>
actAndfinalize
(
cx
NewHandlerWithExtraValue
(
cx
ActAndFinalize
state
extra
)
)
;
if
(
!
actAndfinalize
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
lastWriteRequest
actAndfinalize
actAndfinalize
)
;
}
}
return
ActAndFinalize
(
cx
state
originalError
)
;
}
static
MOZ_MUST_USE
bool
Shutdown
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
Maybe
<
Value
>
>
error
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
error
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
state
-
>
setShuttingDown
(
)
;
WritableStream
*
unwrappedDest
=
GetUnwrappedDest
(
cx
state
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
WritableAndNotClosing
(
unwrappedDest
)
)
{
if
(
PromiseObject
*
p
=
state
-
>
lastWriteRequest
(
)
)
{
Rooted
<
PromiseObject
*
>
lastWriteRequest
(
cx
p
)
;
Rooted
<
Value
>
extra
(
cx
error
.
isSome
(
)
?
*
error
.
get
(
)
:
MagicValue
(
JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR
)
)
;
Rooted
<
JSFunction
*
>
finalize
(
cx
NewHandlerWithExtraValue
(
cx
Finalize
state
extra
)
)
;
if
(
!
finalize
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
lastWriteRequest
finalize
finalize
)
;
}
}
return
Finalize
(
cx
state
error
)
;
}
static
MOZ_MUST_USE
bool
OnSourceErrored
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
storedError
(
cx
Some
(
unwrappedSource
-
>
storedError
(
)
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
if
(
state
-
>
preventAbort
(
)
)
{
if
(
!
Shutdown
(
cx
state
storedError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
PipeToState
:
:
ShutdownAction
:
:
AbortDestStream
storedError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestErrored
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
WritableStream
*
>
unwrappedDest
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
storedError
(
cx
Some
(
unwrappedDest
-
>
storedError
(
)
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
if
(
state
-
>
preventCancel
(
)
)
{
if
(
!
Shutdown
(
cx
state
storedError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
PipeToState
:
:
ShutdownAction
:
:
CancelSource
storedError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceClosed
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
noError
(
cx
Nothing
(
)
)
;
if
(
state
-
>
preventClose
(
)
)
{
if
(
!
Shutdown
(
cx
state
noError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
PipeToState
:
:
ShutdownAction
:
:
CloseWriterWithErrorPropagation
noError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestClosed
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
destClosed
(
cx
Nothing
(
)
)
;
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED
)
;
Rooted
<
Value
>
v
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
v
)
)
{
return
false
;
}
destClosed
=
Some
(
v
.
get
(
)
)
;
}
if
(
state
-
>
preventCancel
(
)
)
{
if
(
!
Shutdown
(
cx
state
destClosed
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
PipeToState
:
:
ShutdownAction
:
:
CancelSource
destClosed
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
SourceOrDestErroredOrClosed
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
bool
*
erroredOrClosed
)
{
cx
-
>
check
(
state
)
;
*
erroredOrClosed
=
true
;
if
(
unwrappedSource
-
>
errored
(
)
)
{
return
OnSourceErrored
(
cx
state
unwrappedSource
)
;
}
if
(
unwrappedDest
-
>
errored
(
)
)
{
return
OnDestErrored
(
cx
state
unwrappedDest
)
;
}
if
(
unwrappedSource
-
>
closed
(
)
)
{
return
OnSourceClosed
(
cx
state
)
;
}
if
(
WritableStreamCloseQueuedOrInFlight
(
unwrappedDest
)
|
|
unwrappedDest
-
>
closed
(
)
)
{
return
OnDestClosed
(
cx
state
)
;
}
*
erroredOrClosed
=
false
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceClosed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
if
(
!
OnSourceClosed
(
cx
state
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceErrored
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
ReadableStream
*
>
unwrappedSource
(
cx
GetUnwrappedSource
(
cx
state
)
)
;
if
(
!
unwrappedSource
)
{
return
false
;
}
if
(
!
OnSourceErrored
(
cx
state
unwrappedSource
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestClosed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
if
(
!
OnDestClosed
(
cx
state
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestErrored
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
WritableStream
*
>
unwrappedDest
(
cx
GetUnwrappedDest
(
cx
state
)
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
!
OnDestErrored
(
cx
state
unwrappedDest
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
template
<
class
StreamAccessor
class
Stream
>
static
inline
JSObject
*
GetClosedPromise
(
JSContext
*
cx
Handle
<
Stream
*
>
unwrappedStream
StreamAccessor
*
(
&
unwrapAccessorFromStream
)
(
JSContext
*
Handle
<
Stream
*
>
)
)
{
StreamAccessor
*
unwrappedAccessor
=
unwrapAccessorFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedAccessor
)
{
return
nullptr
;
}
return
unwrappedAccessor
-
>
closedPromise
(
)
;
}
static
MOZ_MUST_USE
bool
ReadFromSource
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
;
static
bool
ReadFulfilled
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
JSObject
*
>
result
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
result
)
;
state
-
>
clearPendingRead
(
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
{
bool
done
;
{
Rooted
<
Value
>
doneVal
(
cx
)
;
if
(
!
GetProperty
(
cx
result
result
cx
-
>
names
(
)
.
done
&
doneVal
)
)
{
return
false
;
}
done
=
doneVal
.
toBoolean
(
)
;
}
if
(
done
)
{
return
OnSourceClosed
(
cx
state
)
;
}
}
{
Rooted
<
Value
>
chunk
(
cx
)
;
if
(
!
GetProperty
(
cx
result
result
cx
-
>
names
(
)
.
value
&
chunk
)
)
{
return
false
;
}
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
PromiseObject
*
writeRequest
=
WritableStreamDefaultWriterWrite
(
cx
writer
chunk
)
;
if
(
!
writeRequest
)
{
return
false
;
}
state
-
>
updateLastWriteRequest
(
writeRequest
)
;
}
return
ReadFromSource
(
cx
state
)
;
}
static
bool
ReadFulfilled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
JSObject
*
>
result
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
cx
-
>
check
(
result
)
;
if
(
!
ReadFulfilled
(
cx
state
result
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadFromSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
MOZ_MUST_USE
bool
ReadFromSource
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
MOZ_ASSERT
(
!
state
-
>
hasPendingRead
(
)
"
should
only
have
one
read
in
flight
at
a
time
because
multiple
"
"
reads
could
cause
the
latter
read
to
ignore
backpressure
"
"
signals
"
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
Rooted
<
Value
>
desiredSize
(
cx
)
;
if
(
!
WritableStreamDefaultWriterGetDesiredSize
(
cx
writer
&
desiredSize
)
)
{
return
false
;
}
if
(
desiredSize
.
isNull
(
)
)
{
#
ifdef
DEBUG
{
WritableStream
*
unwrappedDest
=
GetUnwrappedDest
(
cx
state
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
MOZ_ASSERT
(
unwrappedDest
-
>
erroring
(
)
|
|
unwrappedDest
-
>
errored
(
)
)
;
}
#
endif
return
true
;
}
MOZ_ASSERT
(
desiredSize
.
isNumber
(
)
)
;
if
(
desiredSize
.
toNumber
(
)
<
=
0
)
{
Rooted
<
JSObject
*
>
readyPromise
(
cx
writer
-
>
readyPromise
(
)
)
;
cx
-
>
check
(
readyPromise
)
;
Rooted
<
JSFunction
*
>
readFromSource
(
cx
NewHandler
(
cx
ReadFromSource
state
)
)
;
if
(
!
readFromSource
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactionsIgnoringUnhandledRejection
(
cx
readyPromise
readFromSource
nullptr
)
;
}
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
state
-
>
reader
(
)
)
;
cx
-
>
check
(
reader
)
;
Rooted
<
PromiseObject
*
>
readRequest
(
cx
js
:
:
ReadableStreamDefaultReaderRead
(
cx
reader
)
)
;
if
(
!
readRequest
)
{
return
false
;
}
Rooted
<
JSFunction
*
>
readFulfilled
(
cx
NewHandler
(
cx
ReadFulfilled
state
)
)
;
if
(
!
readFulfilled
)
{
return
false
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
state
-
>
pendingReadWouldBeRejected
(
)
)
;
auto
ReadRejected
=
[
]
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
state
-
>
setPendingReadWouldBeRejected
(
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
;
Rooted
<
JSFunction
*
>
readRejected
(
cx
NewHandler
(
cx
ReadRejected
state
)
)
;
if
(
!
readRejected
)
{
return
false
;
}
#
else
auto
readRejected
=
nullptr
;
#
endif
if
(
!
JS
:
:
AddPromiseReactionsIgnoringUnhandledRejection
(
cx
readRequest
readFulfilled
readRejected
)
)
{
return
false
;
}
state
-
>
setPendingRead
(
)
;
return
true
;
}
static
bool
ReadFromSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
if
(
!
ReadFromSource
(
cx
state
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
StartPiping
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
)
{
cx
-
>
check
(
state
)
;
MOZ_ASSERT
(
!
state
-
>
shuttingDown
(
)
"
can
'
t
be
shutting
down
when
starting
"
)
;
bool
erroredOrClosed
;
if
(
!
SourceOrDestErroredOrClosed
(
cx
state
unwrappedSource
unwrappedDest
&
erroredOrClosed
)
)
{
return
false
;
}
if
(
erroredOrClosed
)
{
return
true
;
}
{
Rooted
<
JSObject
*
>
unwrappedClosedPromise
(
cx
)
;
Rooted
<
JSObject
*
>
onClosed
(
cx
)
;
Rooted
<
JSObject
*
>
onErrored
(
cx
)
;
auto
ReactWhenClosedOrErrored
=
[
&
unwrappedClosedPromise
&
onClosed
&
onErrored
&
state
]
(
JSContext
*
cx
JSNative
onClosedFunc
JSNative
onErroredFunc
)
{
onClosed
=
NewHandler
(
cx
onClosedFunc
state
)
;
if
(
!
onClosed
)
{
return
false
;
}
onErrored
=
NewHandler
(
cx
onErroredFunc
state
)
;
if
(
!
onErrored
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
unwrappedClosedPromise
onClosed
onErrored
)
;
}
;
unwrappedClosedPromise
=
GetClosedPromise
(
cx
unwrappedSource
UnwrapReaderFromStream
)
;
if
(
!
unwrappedClosedPromise
)
{
return
false
;
}
if
(
!
ReactWhenClosedOrErrored
(
cx
OnSourceClosed
OnSourceErrored
)
)
{
return
false
;
}
unwrappedClosedPromise
=
GetClosedPromise
(
cx
unwrappedDest
UnwrapWriterFromStream
)
;
if
(
!
unwrappedClosedPromise
)
{
return
false
;
}
if
(
!
ReactWhenClosedOrErrored
(
cx
OnDestClosed
OnDestErrored
)
)
{
return
false
;
}
}
return
ReadFromSource
(
cx
state
)
;
}
static
MOZ_MUST_USE
bool
PerformAbortAlgorithm
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
abortAlgorithm
steps
"
)
;
return
false
;
}
PipeToState
*
PipeToState
:
:
create
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
bool
preventClose
bool
preventAbort
bool
preventCancel
Handle
<
JSObject
*
>
signal
)
{
cx
-
>
check
(
promise
)
;
cx
-
>
check
(
signal
)
;
Rooted
<
PipeToState
*
>
state
(
cx
NewTenuredBuiltinClassInstance
<
PipeToState
>
(
cx
)
)
;
if
(
!
state
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Signal
)
.
isUndefined
(
)
)
;
if
(
signal
)
{
state
-
>
initFixedSlot
(
Slot_Signal
ObjectValue
(
*
signal
)
)
;
}
MOZ_ASSERT
(
!
unwrappedSource
-
>
locked
(
)
)
;
MOZ_ASSERT
(
!
unwrappedDest
-
>
isLocked
(
)
)
;
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Promise
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Promise
ObjectValue
(
*
promise
)
)
;
{
ReadableStreamDefaultReader
*
reader
=
CreateReadableStreamDefaultReader
(
cx
unwrappedSource
ForAuthorCodeBool
:
:
No
)
;
if
(
!
reader
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Reader
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Reader
ObjectValue
(
*
reader
)
)
;
}
{
WritableStreamDefaultWriter
*
writer
=
CreateWritableStreamDefaultWriter
(
cx
unwrappedDest
)
;
if
(
!
writer
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Writer
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Writer
ObjectValue
(
*
writer
)
)
;
}
unwrappedSource
-
>
setDisturbed
(
)
;
state
-
>
initFlags
(
preventClose
preventAbort
preventCancel
)
;
MOZ_ASSERT
(
state
-
>
preventClose
(
)
=
=
preventClose
)
;
MOZ_ASSERT
(
state
-
>
preventAbort
(
)
=
=
preventAbort
)
;
MOZ_ASSERT
(
state
-
>
preventCancel
(
)
=
=
preventCancel
)
;
MOZ_ASSERT
(
!
state
-
>
shuttingDown
(
)
"
should
be
set
to
false
by
initFlags
"
)
;
if
(
signal
)
{
bool
aborted
;
{
JSObject
*
unwrappedSignal
=
UnwrapSignalFromPipeToState
(
cx
state
)
;
if
(
!
unwrappedSignal
)
{
return
nullptr
;
}
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
MOZ_ASSERT
(
unwrappedSignal
-
>
hasClass
(
rt
-
>
maybeAbortSignalClass
(
)
)
)
;
AutoRealm
ar
(
cx
unwrappedSignal
)
;
aborted
=
rt
-
>
abortSignalIsAborted
(
unwrappedSignal
)
;
}
if
(
aborted
)
{
if
(
!
PerformAbortAlgorithm
(
cx
state
)
)
{
return
nullptr
;
}
return
state
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
adding
abortAlgorithm
to
signal
"
)
;
return
nullptr
;
}
if
(
!
StartPiping
(
cx
state
unwrappedSource
unwrappedDest
)
)
{
return
nullptr
;
}
return
state
;
}
const
JSClass
PipeToState
:
:
class_
=
{
"
PipeToState
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
