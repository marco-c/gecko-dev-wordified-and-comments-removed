#
include
"
builtin
/
streams
/
PipeToState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamOperations
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
builtin
/
streams
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
-
inl
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultWriter
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
Int32Value
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
using
js
:
:
GetErrorMessage
;
using
js
:
:
NewHandler
;
using
js
:
:
PipeToState
;
using
js
:
:
ReadableStream
;
using
js
:
:
ReadableStreamDefaultReader
;
using
js
:
:
TargetFromHandler
;
using
js
:
:
UnwrapReaderFromStream
;
using
js
:
:
UnwrapStreamFromWriter
;
using
js
:
:
UnwrapWriterFromStream
;
using
js
:
:
WritableStream
;
using
js
:
:
WritableStreamDefaultWriter
;
using
Action
=
bool
(
*
)
(
JSContext
*
Handle
<
PipeToState
*
>
state
)
;
static
MOZ_MUST_USE
bool
DummyAction
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeTo
dummy
action
"
)
;
return
false
;
}
static
ReadableStream
*
GetUnwrappedSource
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
state
-
>
reader
(
)
)
;
cx
-
>
check
(
reader
)
;
return
UnwrapStreamFromReader
(
cx
reader
)
;
}
static
WritableStream
*
GetUnwrappedDest
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
WritableStreamDefaultWriter
*
>
writer
(
cx
state
-
>
writer
(
)
)
;
cx
-
>
check
(
writer
)
;
return
UnwrapStreamFromWriter
(
cx
writer
)
;
}
static
bool
WritableAndNotClosing
(
const
WritableStream
*
unwrappedDest
)
{
return
unwrappedDest
-
>
writable
(
)
&
&
WritableStreamCloseQueuedOrInFlight
(
unwrappedDest
)
;
}
static
MOZ_MUST_USE
bool
ShutdownWithAction
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Action
action
Handle
<
Maybe
<
Value
>
>
originalError
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
originalError
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
state
-
>
setShuttingDown
(
)
;
WritableStream
*
unwrappedDest
=
GetUnwrappedDest
(
cx
state
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
WritableAndNotClosing
(
unwrappedDest
)
)
{
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeTo
shutdown
with
action
"
)
;
return
false
;
}
static
MOZ_MUST_USE
bool
Shutdown
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
Maybe
<
Value
>
>
error
)
{
cx
-
>
check
(
state
)
;
cx
-
>
check
(
error
)
;
if
(
state
-
>
shuttingDown
(
)
)
{
return
true
;
}
state
-
>
setShuttingDown
(
)
;
WritableStream
*
unwrappedDest
=
GetUnwrappedDest
(
cx
state
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
WritableAndNotClosing
(
unwrappedDest
)
)
{
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeTo
shutdown
"
)
;
return
false
;
}
static
MOZ_MUST_USE
bool
OnSourceErrored
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
storedError
(
cx
Some
(
unwrappedSource
-
>
storedError
(
)
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
if
(
state
-
>
preventAbort
(
)
)
{
if
(
!
Shutdown
(
cx
state
storedError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
DummyAction
storedError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestErrored
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
WritableStream
*
>
unwrappedDest
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
storedError
(
cx
Some
(
unwrappedDest
-
>
storedError
(
)
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
if
(
state
-
>
preventCancel
(
)
)
{
if
(
!
Shutdown
(
cx
state
storedError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
DummyAction
storedError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceClosed
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
noError
(
cx
Nothing
(
)
)
;
if
(
state
-
>
preventClose
(
)
)
{
if
(
!
Shutdown
(
cx
state
noError
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
DummyAction
noError
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestClosed
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
)
{
cx
-
>
check
(
state
)
;
Rooted
<
Maybe
<
Value
>
>
destClosed
(
cx
Nothing
(
)
)
;
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED
)
;
Rooted
<
Value
>
v
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
v
)
)
{
return
false
;
}
destClosed
=
Some
(
v
.
get
(
)
)
;
}
if
(
state
-
>
preventCancel
(
)
)
{
if
(
!
Shutdown
(
cx
state
destClosed
)
)
{
return
false
;
}
}
else
{
if
(
!
ShutdownWithAction
(
cx
state
DummyAction
destClosed
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
CanPipeStreams
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
bool
*
shouldStart
)
{
cx
-
>
check
(
state
)
;
*
shouldStart
=
false
;
if
(
unwrappedSource
-
>
errored
(
)
)
{
return
OnSourceErrored
(
cx
state
unwrappedSource
)
;
}
if
(
unwrappedDest
-
>
errored
(
)
)
{
return
OnDestErrored
(
cx
state
unwrappedDest
)
;
}
if
(
unwrappedSource
-
>
closed
(
)
)
{
return
OnSourceClosed
(
cx
state
)
;
}
if
(
WritableStreamCloseQueuedOrInFlight
(
unwrappedDest
)
|
|
unwrappedDest
-
>
closed
(
)
)
{
return
OnDestClosed
(
cx
state
)
;
}
*
shouldStart
=
true
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceClosed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
if
(
!
OnSourceClosed
(
cx
state
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnSourceErrored
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
ReadableStream
*
>
unwrappedSource
(
cx
GetUnwrappedSource
(
cx
state
)
)
;
if
(
!
unwrappedSource
)
{
return
false
;
}
if
(
!
OnSourceErrored
(
cx
state
unwrappedSource
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestClosed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
if
(
!
OnDestClosed
(
cx
state
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
OnDestErrored
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
PipeToState
*
>
state
(
cx
TargetFromHandler
<
PipeToState
>
(
args
)
)
;
cx
-
>
check
(
state
)
;
Rooted
<
WritableStream
*
>
unwrappedDest
(
cx
GetUnwrappedDest
(
cx
state
)
)
;
if
(
!
unwrappedDest
)
{
return
false
;
}
if
(
!
OnDestErrored
(
cx
state
unwrappedDest
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
template
<
class
StreamAccessor
class
Stream
>
static
inline
JSObject
*
GetClosedPromise
(
JSContext
*
cx
Handle
<
Stream
*
>
unwrappedStream
StreamAccessor
*
(
&
unwrapAccessorFromStream
)
(
JSContext
*
Handle
<
Stream
*
>
)
)
{
StreamAccessor
*
unwrappedAccessor
=
unwrapAccessorFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedAccessor
)
{
return
nullptr
;
}
return
unwrappedAccessor
-
>
closedPromise
(
)
;
}
static
MOZ_MUST_USE
bool
StartPiping
(
JSContext
*
cx
Handle
<
PipeToState
*
>
state
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
)
{
cx
-
>
check
(
state
)
;
bool
shouldStart
;
if
(
!
CanPipeStreams
(
cx
state
unwrappedSource
unwrappedDest
&
shouldStart
)
)
{
return
false
;
}
if
(
!
shouldStart
)
{
return
true
;
}
{
Rooted
<
JSObject
*
>
unwrappedClosedPromise
(
cx
)
;
Rooted
<
JSObject
*
>
onClosed
(
cx
)
;
Rooted
<
JSObject
*
>
onErrored
(
cx
)
;
auto
ReactWhenClosedOrErrored
=
[
&
unwrappedClosedPromise
&
onClosed
&
onErrored
&
state
]
(
JSContext
*
cx
JSNative
onClosedFunc
JSNative
onErroredFunc
)
{
onClosed
=
NewHandler
(
cx
onClosedFunc
state
)
;
if
(
!
onClosed
)
{
return
false
;
}
onErrored
=
NewHandler
(
cx
onErroredFunc
state
)
;
if
(
!
onErrored
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
unwrappedClosedPromise
onClosed
onErrored
)
;
}
;
unwrappedClosedPromise
=
GetClosedPromise
(
cx
unwrappedSource
UnwrapReaderFromStream
)
;
if
(
!
unwrappedClosedPromise
)
{
return
false
;
}
if
(
!
ReactWhenClosedOrErrored
(
cx
OnSourceClosed
OnSourceErrored
)
)
{
return
false
;
}
unwrappedClosedPromise
=
GetClosedPromise
(
cx
unwrappedDest
UnwrapWriterFromStream
)
;
if
(
!
unwrappedClosedPromise
)
{
return
false
;
}
if
(
!
ReactWhenClosedOrErrored
(
cx
OnDestClosed
OnDestErrored
)
)
{
return
false
;
}
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeTo
"
)
;
return
false
;
}
PipeToState
*
PipeToState
:
:
create
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
bool
preventClose
bool
preventAbort
bool
preventCancel
Handle
<
JSObject
*
>
signal
)
{
cx
-
>
check
(
promise
)
;
#
ifdef
DEBUG
if
(
signal
)
{
}
#
endif
MOZ_ASSERT
(
!
unwrappedSource
-
>
locked
(
)
)
;
MOZ_ASSERT
(
!
unwrappedDest
-
>
isLocked
(
)
)
;
Rooted
<
PipeToState
*
>
state
(
cx
NewBuiltinClassInstance
<
PipeToState
>
(
cx
)
)
;
if
(
!
state
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Promise
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Promise
ObjectValue
(
*
promise
)
)
;
{
ReadableStreamDefaultReader
*
reader
=
CreateReadableStreamDefaultReader
(
cx
unwrappedSource
ForAuthorCodeBool
:
:
No
)
;
if
(
!
reader
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Reader
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Reader
ObjectValue
(
*
reader
)
)
;
}
{
WritableStreamDefaultWriter
*
writer
=
CreateWritableStreamDefaultWriter
(
cx
unwrappedDest
)
;
if
(
!
writer
)
{
return
nullptr
;
}
MOZ_ASSERT
(
state
-
>
getFixedSlot
(
Slot_Writer
)
.
isUndefined
(
)
)
;
state
-
>
initFixedSlot
(
Slot_Writer
ObjectValue
(
*
writer
)
)
;
}
unwrappedSource
-
>
setDisturbed
(
)
;
state
-
>
initFlags
(
preventClose
preventAbort
preventCancel
)
;
MOZ_ASSERT
(
state
-
>
preventClose
(
)
=
=
preventClose
)
;
MOZ_ASSERT
(
state
-
>
preventAbort
(
)
=
=
preventAbort
)
;
MOZ_ASSERT
(
state
-
>
preventCancel
(
)
=
=
preventCancel
)
;
MOZ_ASSERT
(
!
state
-
>
shuttingDown
(
)
"
should
be
set
to
false
by
initFlags
"
)
;
if
(
!
StartPiping
(
cx
state
unwrappedSource
unwrappedDest
)
)
{
return
nullptr
;
}
return
state
;
}
const
JSClass
PipeToState
:
:
class_
=
{
"
PipeToState
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
