#
include
"
builtin
/
streams
/
WritableStreamDefaultControllerOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamDefaultController
.
h
"
#
include
"
builtin
/
streams
/
WritableStreamOperations
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
builtin
/
streams
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
Int32Value
;
using
JS
:
:
MagicValue
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
UndefinedHandleValue
;
using
JS
:
:
Value
;
using
js
:
:
ListObject
;
using
js
:
:
WritableStream
;
using
js
:
:
WritableStreamDefaultController
;
using
js
:
:
WritableStreamFinishErroring
;
JSObject
*
js
:
:
WritableStreamControllerAbortSteps
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
Handle
<
Value
>
reason
)
{
cx
-
>
check
(
reason
)
;
Rooted
<
Value
>
unwrappedAbortMethod
(
cx
unwrappedController
-
>
abortMethod
(
)
)
;
Rooted
<
JSObject
*
>
result
(
cx
)
;
if
(
unwrappedAbortMethod
.
isUndefined
(
)
)
{
result
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
if
(
!
result
)
{
return
nullptr
;
}
}
else
{
{
AutoRealm
ar
(
cx
unwrappedController
)
;
cx
-
>
check
(
unwrappedAbortMethod
)
;
Rooted
<
Value
>
underlyingSink
(
cx
unwrappedController
-
>
underlyingSink
(
)
)
;
cx
-
>
check
(
underlyingSink
)
;
Rooted
<
Value
>
wrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
result
=
PromiseCall
(
cx
unwrappedAbortMethod
underlyingSink
wrappedReason
)
;
if
(
!
result
)
{
return
nullptr
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
result
)
)
{
return
nullptr
;
}
}
WritableStreamDefaultControllerClearAlgorithms
(
unwrappedController
)
;
return
result
;
}
bool
js
:
:
WritableStreamControllerErrorSteps
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
)
{
return
ResetQueue
(
cx
unwrappedController
)
;
}
static
MOZ_MUST_USE
bool
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
)
;
bool
js
:
:
WritableStreamControllerStartHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
WritableStreamDefaultController
*
>
unwrappedController
(
cx
TargetFromHandler
<
WritableStreamDefaultController
>
(
args
)
)
;
#
ifdef
DEBUG
const
auto
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
^
unwrappedStream
-
>
erroring
(
)
)
;
#
endif
unwrappedController
-
>
setStarted
(
)
;
if
(
!
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
cx
unwrappedController
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
js
:
:
WritableStreamControllerStartFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
WritableStreamDefaultController
*
>
unwrappedController
(
cx
TargetFromHandler
<
WritableStreamDefaultController
>
(
args
)
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
^
unwrappedStream
-
>
erroring
(
)
)
;
unwrappedController
-
>
setStarted
(
)
;
if
(
!
WritableStreamDealWithRejection
(
cx
unwrappedStream
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpWritableStreamDefaultController
(
JSContext
*
cx
Handle
<
WritableStream
*
>
stream
SinkAlgorithms
sinkAlgorithms
Handle
<
Value
>
underlyingSink
Handle
<
Value
>
writeMethod
Handle
<
Value
>
closeMethod
Handle
<
Value
>
abortMethod
double
highWaterMark
Handle
<
Value
>
size
)
{
cx
-
>
check
(
stream
)
;
cx
-
>
check
(
underlyingSink
)
;
cx
-
>
check
(
writeMethod
)
;
MOZ_ASSERT
(
writeMethod
.
isUndefined
(
)
|
|
IsCallable
(
writeMethod
)
)
;
cx
-
>
check
(
closeMethod
)
;
MOZ_ASSERT
(
closeMethod
.
isUndefined
(
)
|
|
IsCallable
(
closeMethod
)
)
;
cx
-
>
check
(
abortMethod
)
;
MOZ_ASSERT
(
abortMethod
.
isUndefined
(
)
|
|
IsCallable
(
abortMethod
)
)
;
MOZ_ASSERT
(
highWaterMark
>
=
0
)
;
cx
-
>
check
(
size
)
;
MOZ_ASSERT
(
size
.
isUndefined
(
)
|
|
IsCallable
(
size
)
)
;
Rooted
<
WritableStreamDefaultController
*
>
controller
(
cx
NewBuiltinClassInstance
<
WritableStreamDefaultController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
false
;
}
MOZ_ASSERT
(
!
stream
-
>
hasController
(
)
)
;
controller
-
>
setStream
(
stream
)
;
stream
-
>
setController
(
controller
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
false
;
}
controller
-
>
setFlags
(
0
)
;
MOZ_ASSERT
(
!
controller
-
>
started
(
)
)
;
controller
-
>
setStrategySize
(
size
)
;
controller
-
>
setStrategyHWM
(
highWaterMark
)
;
controller
-
>
setWriteMethod
(
writeMethod
)
;
controller
-
>
setCloseMethod
(
closeMethod
)
;
controller
-
>
setAbortMethod
(
abortMethod
)
;
bool
backpressure
=
WritableStreamDefaultControllerGetBackpressure
(
controller
)
;
if
(
!
WritableStreamUpdateBackpressure
(
cx
stream
backpressure
)
)
{
return
false
;
}
Rooted
<
Value
>
startResult
(
cx
)
;
if
(
sinkAlgorithms
=
=
SinkAlgorithms
:
:
Script
)
{
Rooted
<
Value
>
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingSink
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
false
;
}
}
Rooted
<
JSObject
*
>
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onStartFulfilled
(
cx
NewHandler
(
cx
WritableStreamControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onStartRejected
(
cx
NewHandler
(
cx
WritableStreamControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpWritableStreamDefaultControllerFromUnderlyingSink
(
JSContext
*
cx
Handle
<
WritableStream
*
>
stream
Handle
<
Value
>
underlyingSink
double
highWaterMark
Handle
<
Value
>
sizeAlgorithm
)
{
cx
-
>
check
(
stream
)
;
cx
-
>
check
(
underlyingSink
)
;
cx
-
>
check
(
sizeAlgorithm
)
;
MOZ_ASSERT
(
!
underlyingSink
.
isUndefined
(
)
)
;
SinkAlgorithms
sinkAlgorithms
=
SinkAlgorithms
:
:
Script
;
Rooted
<
Value
>
writeMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSink
"
WritableStream
sink
.
write
method
"
cx
-
>
names
(
)
.
write
&
writeMethod
)
)
{
return
false
;
}
Rooted
<
Value
>
closeMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSink
"
WritableStream
sink
.
close
method
"
cx
-
>
names
(
)
.
close
&
closeMethod
)
)
{
return
false
;
}
Rooted
<
Value
>
abortMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSink
"
WritableStream
sink
.
abort
method
"
cx
-
>
names
(
)
.
abort
&
abortMethod
)
)
{
return
false
;
}
return
SetUpWritableStreamDefaultController
(
cx
stream
sinkAlgorithms
underlyingSink
writeMethod
closeMethod
abortMethod
highWaterMark
sizeAlgorithm
)
;
}
void
js
:
:
WritableStreamDefaultControllerClearAlgorithms
(
WritableStreamDefaultController
*
unwrappedController
)
{
unwrappedController
-
>
clearWriteMethod
(
)
;
unwrappedController
-
>
clearCloseMethod
(
)
;
unwrappedController
-
>
clearAbortMethod
(
)
;
unwrappedController
-
>
clearStrategySize
(
)
;
}
bool
js
:
:
WritableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
)
{
{
Rooted
<
Value
>
v
(
cx
MagicValue
(
JS_WRITABLESTREAM_CLOSE_RECORD
)
)
;
Rooted
<
Value
>
size
(
cx
Int32Value
(
0
)
)
;
if
(
!
EnqueueValueWithSize
(
cx
unwrappedController
v
size
)
)
{
return
false
;
}
}
return
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
cx
unwrappedController
)
;
}
bool
js
:
:
WritableStreamDefaultControllerGetChunkSize
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
Handle
<
Value
>
chunk
MutableHandle
<
Value
>
returnValue
)
{
cx
-
>
check
(
chunk
)
;
Rooted
<
Value
>
unwrappedStrategySize
(
cx
unwrappedController
-
>
strategySize
(
)
)
;
if
(
unwrappedStrategySize
.
isUndefined
(
)
)
{
returnValue
.
setInt32
(
1
)
;
return
true
;
}
MOZ_ASSERT
(
IsCallable
(
unwrappedStrategySize
)
)
;
{
bool
success
;
{
AutoRealm
ar
(
cx
unwrappedController
)
;
cx
-
>
check
(
unwrappedStrategySize
)
;
Rooted
<
Value
>
wrappedChunk
(
cx
chunk
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedChunk
)
)
{
return
false
;
}
success
=
Call
(
cx
unwrappedStrategySize
UndefinedHandleValue
wrappedChunk
returnValue
)
;
}
if
(
success
)
{
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
returnValue
)
;
}
}
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
cx
-
>
getPendingException
(
returnValue
)
)
{
return
false
;
}
cx
-
>
check
(
returnValue
)
;
cx
-
>
clearPendingException
(
)
;
if
(
!
WritableStreamDefaultControllerErrorIfNeeded
(
cx
unwrappedController
returnValue
)
)
{
return
false
;
}
returnValue
.
setInt32
(
1
)
;
return
true
;
}
double
js
:
:
WritableStreamDefaultControllerGetDesiredSize
(
const
WritableStreamDefaultController
*
controller
)
{
return
controller
-
>
strategyHWM
(
)
-
controller
-
>
queueTotalSize
(
)
;
}
MOZ_MUST_USE
bool
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
)
{
if
(
!
unwrappedController
-
>
started
(
)
)
{
return
true
;
}
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
if
(
!
unwrappedStream
-
>
inFlightWriteRequest
(
)
.
isUndefined
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
!
unwrappedStream
-
>
closed
(
)
)
;
MOZ_ASSERT
(
!
unwrappedStream
-
>
errored
(
)
)
;
if
(
unwrappedStream
-
>
erroring
(
)
)
{
return
WritableStreamFinishErroring
(
cx
unwrappedStream
)
;
}
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedController
-
>
queue
(
)
)
;
MOZ_ASSERT
(
(
unwrappedQueue
-
>
length
(
)
%
2
)
=
=
0
)
;
if
(
unwrappedQueue
-
>
isEmpty
(
)
)
{
return
true
;
}
JS_ReportErrorASCII
(
cx
"
nope
"
)
;
return
false
;
}
bool
js
:
:
WritableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
Handle
<
Value
>
error
)
{
cx
-
>
check
(
error
)
;
if
(
unwrappedController
-
>
stream
(
)
-
>
writable
(
)
)
{
if
(
!
WritableStreamDefaultControllerError
(
cx
unwrappedController
error
)
)
{
return
false
;
}
}
return
true
;
}
bool
js
:
:
WritableStreamDefaultControllerGetBackpressure
(
const
WritableStreamDefaultController
*
unwrappedController
)
{
return
WritableStreamDefaultControllerGetDesiredSize
(
unwrappedController
)
<
=
0
.
0
;
}
bool
js
:
:
WritableStreamDefaultControllerError
(
JSContext
*
cx
Handle
<
WritableStreamDefaultController
*
>
unwrappedController
Handle
<
Value
>
error
)
{
cx
-
>
check
(
error
)
;
Rooted
<
WritableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
writable
(
)
)
;
WritableStreamDefaultControllerClearAlgorithms
(
unwrappedController
)
;
return
WritableStreamStartErroring
(
cx
unwrappedStream
error
)
;
}
