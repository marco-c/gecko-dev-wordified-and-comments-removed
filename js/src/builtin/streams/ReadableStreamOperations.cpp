#
include
"
builtin
/
streams
/
ReadableStreamOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
streams
/
PipeToState
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamDefaultControllerOperations
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamInternals
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
TeeState
.
h
"
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
builtin
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
js
:
:
IsCallable
;
using
js
:
:
NewHandler
;
using
js
:
:
NewObjectWithClassProto
;
using
js
:
:
PromiseObject
;
using
js
:
:
ReadableStream
;
using
js
:
:
ReadableStreamDefaultController
;
using
js
:
:
ReadableStreamDefaultControllerEnqueue
;
using
js
:
:
ReadableStreamDefaultReader
;
using
js
:
:
ReadableStreamReader
;
using
js
:
:
SourceAlgorithms
;
using
js
:
:
TargetFromHandler
;
using
js
:
:
TeeState
;
using
js
:
:
UnwrapCalleeSlot
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
MutableHandle
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
UndefinedHandleValue
;
using
JS
:
:
Value
;
[
[
nodiscard
]
]
static
ReadableStream
*
CreateReadableStream
(
JSContext
*
cx
SourceAlgorithms
sourceAlgorithms
Handle
<
Value
>
underlyingSource
Handle
<
Value
>
pullMethod
=
UndefinedHandleValue
Handle
<
Value
>
cancelMethod
=
UndefinedHandleValue
double
highWaterMark
=
1
Handle
<
Value
>
sizeAlgorithm
=
UndefinedHandleValue
Handle
<
JSObject
*
>
proto
=
nullptr
)
{
cx
-
>
check
(
underlyingSource
sizeAlgorithm
proto
)
;
MOZ_ASSERT
(
sizeAlgorithm
.
isUndefined
(
)
|
|
IsCallable
(
sizeAlgorithm
)
)
;
MOZ_ASSERT
(
highWaterMark
>
=
0
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
ReadableStream
:
:
create
(
cx
nullptr
proto
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
if
(
!
SetUpReadableStreamDefaultController
(
cx
stream
sourceAlgorithms
underlyingSource
pullMethod
cancelMethod
highWaterMark
sizeAlgorithm
)
)
{
return
nullptr
;
}
return
stream
;
}
[
[
nodiscard
]
]
ReadableStream
*
ReadableStream
:
:
create
(
JSContext
*
cx
void
*
nsISupportsObject_alreadyAddreffed
Handle
<
JSObject
*
>
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
NewObjectWithClassProto
<
ReadableStream
>
(
cx
proto
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
static_assert
(
Slot_ISupports
=
=
0
"
Must
use
right
slot
for
JSCLASS_SLOT0_IS_NSISUPPORTS
"
)
;
JS
:
:
SetObjectISupports
(
stream
nsISupportsObject_alreadyAddreffed
)
;
stream
-
>
initStateBits
(
Readable
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
MOZ_ASSERT
(
!
stream
-
>
hasReader
(
)
)
;
MOZ_ASSERT
(
stream
-
>
storedError
(
)
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
!
stream
-
>
disturbed
(
)
)
;
return
stream
;
}
bool
ReadableStream
:
:
locked
(
)
const
{
if
(
hasController
(
)
&
&
controller
(
)
-
>
sourceLocked
(
)
)
{
return
true
;
}
return
hasReader
(
)
;
}
static
bool
TeeReaderReadHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
unwrappedTeeState
(
cx
UnwrapCalleeSlot
<
TeeState
>
(
cx
args
0
)
)
;
if
(
!
unwrappedTeeState
)
{
return
false
;
}
Handle
<
Value
>
resultVal
=
args
.
get
(
0
)
;
unwrappedTeeState
-
>
unsetReading
(
)
;
Rooted
<
JSObject
*
>
result
(
cx
&
resultVal
.
toObject
(
)
)
;
bool
done
;
{
Rooted
<
Value
>
doneVal
(
cx
)
;
if
(
!
GetProperty
(
cx
result
result
cx
-
>
names
(
)
.
done
&
doneVal
)
)
{
return
false
;
}
done
=
doneVal
.
toBoolean
(
)
;
}
if
(
done
)
{
if
(
!
unwrappedTeeState
-
>
canceled1
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedBranch1
(
cx
unwrappedTeeState
-
>
branch1
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
unwrappedBranch1
)
)
{
return
false
;
}
}
if
(
!
unwrappedTeeState
-
>
canceled2
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedBranch2
(
cx
unwrappedTeeState
-
>
branch2
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
unwrappedBranch2
)
)
{
return
false
;
}
}
if
(
!
unwrappedTeeState
-
>
canceled1
(
)
|
|
!
unwrappedTeeState
-
>
canceled2
(
)
)
{
Rooted
<
PromiseObject
*
>
unwrappedCancelPromise
(
cx
unwrappedTeeState
-
>
cancelPromise
(
)
)
;
MOZ_ASSERT
(
unwrappedCancelPromise
!
=
nullptr
)
;
if
(
!
ResolveUnwrappedPromiseWithUndefined
(
cx
unwrappedCancelPromise
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
result
result
cx
-
>
names
(
)
.
value
&
value
)
)
{
return
false
;
}
auto
&
value1
=
value
;
MOZ_ASSERT
(
!
unwrappedTeeState
-
>
cloneForBranch2
(
)
"
support
for
cloneForBranch2
=
true
is
not
yet
implemented
"
)
;
auto
&
value2
=
value
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
)
;
if
(
!
unwrappedTeeState
-
>
canceled1
(
)
)
{
unwrappedController
=
unwrappedTeeState
-
>
branch1
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
unwrappedController
value1
)
)
{
return
false
;
}
}
if
(
!
unwrappedTeeState
-
>
canceled2
(
)
)
{
unwrappedController
=
unwrappedTeeState
-
>
branch2
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
unwrappedController
value2
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
[
[
nodiscard
]
]
PromiseObject
*
js
:
:
ReadableStreamTee_Pull
(
JSContext
*
cx
JS
:
:
Handle
<
TeeState
*
>
unwrappedTeeState
)
{
if
(
!
unwrappedTeeState
-
>
reading
(
)
)
{
unwrappedTeeState
-
>
setReading
(
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
unwrappedReader
(
cx
)
;
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
UnwrapInternalSlot
<
ReadableStream
>
(
cx
unwrappedTeeState
TeeState
:
:
Slot_Stream
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
ReadableStreamReader
*
unwrappedReaderObj
=
UnwrapReaderFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedReaderObj
)
{
return
nullptr
;
}
unwrappedReader
=
&
unwrappedReaderObj
-
>
as
<
ReadableStreamDefaultReader
>
(
)
;
}
Rooted
<
PromiseObject
*
>
readerReadResultPromise
(
cx
js
:
:
ReadableStreamDefaultReaderRead
(
cx
unwrappedReader
)
)
;
if
(
!
readerReadResultPromise
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
teeState
(
cx
unwrappedTeeState
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
teeState
)
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
onFulfilled
(
cx
NewHandler
(
cx
TeeReaderReadHandler
teeState
)
)
;
if
(
!
onFulfilled
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactionsIgnoringUnhandledRejection
(
cx
readerReadResultPromise
onFulfilled
nullptr
)
)
{
return
nullptr
;
}
}
return
PromiseResolvedWithUndefined
(
cx
)
;
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
ReadableStreamTee_Cancel
(
JSContext
*
cx
JS
:
:
Handle
<
TeeState
*
>
unwrappedTeeState
JS
:
:
Handle
<
ReadableStreamDefaultController
*
>
unwrappedBranch
JS
:
:
Handle
<
Value
>
reason
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
UnwrapInternalSlot
<
ReadableStream
>
(
cx
unwrappedTeeState
TeeState
:
:
Slot_Stream
)
)
;
if
(
!
unwrappedStream
)
{
return
nullptr
;
}
bool
bothBranchesCanceled
=
false
;
{
AutoRealm
ar
(
cx
unwrappedTeeState
)
;
Rooted
<
Value
>
unwrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
unwrappedReason
)
)
{
return
nullptr
;
}
if
(
unwrappedBranch
-
>
isTeeBranch1
(
)
)
{
unwrappedTeeState
-
>
setCanceled1
(
unwrappedReason
)
;
bothBranchesCanceled
=
unwrappedTeeState
-
>
canceled2
(
)
;
}
else
{
MOZ_ASSERT
(
unwrappedBranch
-
>
isTeeBranch2
(
)
)
;
unwrappedTeeState
-
>
setCanceled2
(
unwrappedReason
)
;
bothBranchesCanceled
=
unwrappedTeeState
-
>
canceled1
(
)
;
}
}
Rooted
<
PromiseObject
*
>
unwrappedCancelPromise
(
cx
unwrappedTeeState
-
>
cancelPromise
(
)
)
;
MOZ_ASSERT
(
unwrappedCancelPromise
!
=
nullptr
)
;
if
(
bothBranchesCanceled
)
{
Rooted
<
Value
>
compositeReason
(
cx
)
;
{
Rooted
<
Value
>
reason1
(
cx
unwrappedTeeState
-
>
reason1
(
)
)
;
Rooted
<
Value
>
reason2
(
cx
unwrappedTeeState
-
>
reason2
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason1
)
|
|
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason2
)
)
{
return
nullptr
;
}
ArrayObject
*
reasonArray
=
NewDenseFullyAllocatedArray
(
cx
2
)
;
if
(
!
reasonArray
)
{
return
nullptr
;
}
reasonArray
-
>
setDenseInitializedLength
(
2
)
;
reasonArray
-
>
initDenseElement
(
0
reason1
)
;
reasonArray
-
>
initDenseElement
(
1
reason2
)
;
compositeReason
=
ObjectValue
(
*
reasonArray
)
;
}
Rooted
<
JSObject
*
>
cancelResult
(
cx
js
:
:
ReadableStreamCancel
(
cx
unwrappedStream
compositeReason
)
)
;
if
(
!
cancelResult
)
{
AutoRealm
ar
(
cx
unwrappedCancelPromise
)
;
if
(
!
RejectPromiseWithPendingError
(
cx
unwrappedCancelPromise
)
)
{
return
nullptr
;
}
}
else
{
Rooted
<
Value
>
cancelResultVal
(
cx
ObjectValue
(
*
cancelResult
)
)
;
if
(
!
ResolveUnwrappedPromiseWithValue
(
cx
unwrappedCancelPromise
cancelResultVal
)
)
{
return
nullptr
;
}
}
}
Rooted
<
JSObject
*
>
cancelPromise
(
cx
unwrappedCancelPromise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
cancelPromise
)
)
{
return
nullptr
;
}
return
cancelPromise
;
}
static
bool
TeeReaderErroredHandler
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
teeState
(
cx
TargetFromHandler
<
TeeState
>
(
args
)
)
;
Handle
<
Value
>
reason
=
args
.
get
(
0
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedBranchController
(
cx
)
;
unwrappedBranchController
=
teeState
-
>
branch1
(
)
;
if
(
!
ReadableStreamControllerError
(
cx
unwrappedBranchController
reason
)
)
{
return
false
;
}
unwrappedBranchController
=
teeState
-
>
branch2
(
)
;
if
(
!
ReadableStreamControllerError
(
cx
unwrappedBranchController
reason
)
)
{
return
false
;
}
if
(
!
teeState
-
>
canceled1
(
)
|
|
!
teeState
-
>
canceled2
(
)
)
{
Rooted
<
PromiseObject
*
>
unwrappedCancelPromise
(
cx
teeState
-
>
cancelPromise
(
)
)
;
MOZ_ASSERT
(
unwrappedCancelPromise
!
=
nullptr
)
;
if
(
!
ResolveUnwrappedPromiseWithUndefined
(
cx
unwrappedCancelPromise
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableStreamTee
(
JSContext
*
cx
JS
:
:
Handle
<
ReadableStream
*
>
unwrappedStream
bool
cloneForBranch2
JS
:
:
MutableHandle
<
ReadableStream
*
>
branch1Stream
JS
:
:
MutableHandle
<
ReadableStream
*
>
branch2Stream
)
{
MOZ_ASSERT
(
!
cloneForBranch2
"
support
for
cloneForBranch2
=
true
is
not
yet
implemented
"
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
CreateReadableStreamDefaultReader
(
cx
unwrappedStream
ForAuthorCodeBool
:
:
No
)
)
;
if
(
!
reader
)
{
return
false
;
}
Rooted
<
TeeState
*
>
teeState
(
cx
TeeState
:
:
create
(
cx
unwrappedStream
)
)
;
if
(
!
teeState
)
{
return
false
;
}
MOZ_ASSERT
(
!
teeState
-
>
reading
(
)
)
;
MOZ_ASSERT
(
!
teeState
-
>
canceled1
(
)
)
;
MOZ_ASSERT
(
!
teeState
-
>
canceled2
(
)
)
;
Rooted
<
Value
>
underlyingSource
(
cx
ObjectValue
(
*
teeState
)
)
;
branch1Stream
.
set
(
CreateReadableStream
(
cx
SourceAlgorithms
:
:
Tee
underlyingSource
)
)
;
if
(
!
branch1Stream
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
)
;
branch1
=
&
branch1Stream
-
>
controller
(
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
branch1
-
>
setTeeBranch1
(
)
;
teeState
-
>
setBranch1
(
branch1
)
;
branch2Stream
.
set
(
CreateReadableStream
(
cx
SourceAlgorithms
:
:
Tee
underlyingSource
)
)
;
if
(
!
branch2Stream
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
)
;
branch2
=
&
branch2Stream
-
>
controller
(
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
branch2
-
>
setTeeBranch2
(
)
;
teeState
-
>
setBranch2
(
branch2
)
;
Rooted
<
JSObject
*
>
closedPromise
(
cx
reader
-
>
closedPromise
(
)
)
;
Rooted
<
JSObject
*
>
onRejected
(
cx
NewHandler
(
cx
TeeReaderErroredHandler
teeState
)
)
;
if
(
!
onRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
closedPromise
nullptr
onRejected
)
)
{
return
false
;
}
return
true
;
}
PromiseObject
*
js
:
:
ReadableStreamPipeTo
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedSource
Handle
<
WritableStream
*
>
unwrappedDest
bool
preventClose
bool
preventAbort
bool
preventCancel
Handle
<
JSObject
*
>
signal
)
{
cx
-
>
check
(
signal
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
Rooted
<
PipeToState
*
>
pipeToState
(
cx
PipeToState
:
:
create
(
cx
promise
unwrappedSource
unwrappedDest
preventClose
preventAbort
preventCancel
signal
)
)
;
if
(
!
pipeToState
)
{
if
(
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
return
promise
;
}
