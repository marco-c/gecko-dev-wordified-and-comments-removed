#
ifndef
builtin_streams_QueueWithSizes_inl_h
#
define
builtin_streams_QueueWithSizes_inl_h
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
namespace
detail
{
inline
JS
:
:
Value
QueueFirstValue
(
ListObject
*
unwrappedQueue
)
{
MOZ_ASSERT
(
!
unwrappedQueue
-
>
isEmpty
(
)
"
can
'
t
examine
first
value
in
an
empty
queue
-
with
-
sizes
"
)
;
MOZ_ASSERT
(
(
unwrappedQueue
-
>
length
(
)
%
2
)
=
=
0
"
queue
-
with
-
sizes
must
consist
of
(
value
size
)
element
pairs
and
"
"
so
must
have
even
length
"
)
;
return
unwrappedQueue
-
>
get
(
0
)
;
}
inline
double
QueueFirstSize
(
ListObject
*
unwrappedQueue
)
{
MOZ_ASSERT
(
!
unwrappedQueue
-
>
isEmpty
(
)
"
can
'
t
examine
first
value
in
an
empty
queue
-
with
-
sizes
"
)
;
MOZ_ASSERT
(
(
unwrappedQueue
-
>
length
(
)
%
2
)
=
=
0
"
queue
-
with
-
sizes
must
consist
of
(
value
size
)
element
pairs
and
"
"
so
must
have
even
length
"
)
;
return
unwrappedQueue
-
>
get
(
1
)
.
toDouble
(
)
;
}
inline
void
QueueRemoveFirstValueAndSize
(
ListObject
*
unwrappedQueue
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
unwrappedQueue
-
>
isEmpty
(
)
"
can
'
t
remove
first
value
from
an
empty
queue
-
with
-
sizes
"
)
;
MOZ_ASSERT
(
(
unwrappedQueue
-
>
length
(
)
%
2
)
=
=
0
"
queue
-
with
-
sizes
must
consist
of
(
value
size
)
element
pairs
and
"
"
so
must
have
even
length
"
)
;
unwrappedQueue
-
>
popFirstPair
(
cx
)
;
}
[
[
nodiscard
]
]
inline
bool
QueueAppendValueAndSize
(
JSContext
*
cx
JS
:
:
Handle
<
ListObject
*
>
unwrappedQueue
JS
:
:
Handle
<
JS
:
:
Value
>
value
double
size
)
{
return
unwrappedQueue
-
>
appendValueAndSize
(
cx
value
size
)
;
}
}
inline
JS
:
:
Value
PeekQueueValue
(
ListObject
*
queue
)
{
return
detail
:
:
QueueFirstValue
(
queue
)
;
}
}
#
endif
