#
include
"
builtin
/
streams
/
ReadableStreamDefaultControllerOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
Stream
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamInternals
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamOperations
.
h
"
#
include
"
builtin
/
streams
/
TeeState
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
builtin
/
streams
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
js
:
:
ReadableByteStreamController
;
using
js
:
:
ReadableStream
;
using
js
:
:
ReadableStreamController
;
using
js
:
:
ReadableStreamControllerCallPullIfNeeded
;
using
js
:
:
ReadableStreamControllerError
;
using
js
:
:
ReadableStreamGetNumReadRequests
;
using
js
:
:
UnwrapCalleeSlot
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
Rooted
;
using
JS
:
:
UndefinedHandleValue
;
using
JS
:
:
Value
;
static
bool
ControllerPullHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
UnwrapCalleeSlot
<
ReadableStreamController
>
(
cx
args
0
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
bool
pullAgain
=
unwrappedController
-
>
pullAgain
(
)
;
unwrappedController
-
>
clearPullFlags
(
)
;
if
(
pullAgain
)
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ControllerPullFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Handle
<
Value
>
e
=
args
.
get
(
0
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
UnwrapCalleeSlot
<
ReadableStreamController
>
(
cx
args
0
)
)
;
if
(
!
controller
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
unwrappedController
)
;
MOZ_MUST_USE
bool
js
:
:
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
bool
shouldPull
=
ReadableStreamControllerShouldCallPull
(
unwrappedController
)
;
if
(
!
shouldPull
)
{
return
true
;
}
if
(
unwrappedController
-
>
pulling
(
)
)
{
unwrappedController
-
>
setPullAgain
(
)
;
return
true
;
}
MOZ_ASSERT
(
!
unwrappedController
-
>
pullAgain
(
)
)
;
unwrappedController
-
>
setPulling
(
)
;
Rooted
<
JSObject
*
>
wrappedController
(
cx
unwrappedController
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedController
)
)
{
return
false
;
}
Rooted
<
JSObject
*
>
pullPromise
(
cx
)
;
Rooted
<
Value
>
unwrappedUnderlyingSource
(
cx
unwrappedController
-
>
underlyingSource
(
)
)
;
if
(
IsMaybeWrapped
<
TeeState
>
(
unwrappedUnderlyingSource
)
)
{
MOZ_ASSERT
(
unwrappedUnderlyingSource
.
toObject
(
)
.
is
<
TeeState
>
(
)
"
tee
streams
and
controllers
are
always
same
-
compartment
with
"
"
the
TeeState
object
"
)
;
Rooted
<
TeeState
*
>
unwrappedTeeState
(
cx
&
unwrappedUnderlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
pullPromise
=
ReadableStreamTee_Pull
(
cx
unwrappedTeeState
)
;
}
else
if
(
unwrappedController
-
>
hasExternalSource
(
)
)
{
{
AutoRealm
ar
(
cx
unwrappedController
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
unwrappedController
-
>
stream
(
)
)
;
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
;
source
-
>
requestData
(
cx
stream
desiredSize
)
;
}
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
Rooted
<
Value
>
unwrappedPullMethod
(
cx
unwrappedController
-
>
pullMethod
(
)
)
;
if
(
unwrappedPullMethod
.
isUndefined
(
)
)
{
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
{
AutoRealm
ar
(
cx
unwrappedController
)
;
cx
-
>
check
(
unwrappedPullMethod
)
;
cx
-
>
check
(
unwrappedUnderlyingSource
)
;
Rooted
<
Value
>
controller
(
cx
ObjectValue
(
*
unwrappedController
)
)
;
cx
-
>
check
(
controller
)
;
pullPromise
=
PromiseCall
(
cx
unwrappedPullMethod
unwrappedUnderlyingSource
controller
)
;
if
(
!
pullPromise
)
{
return
false
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
pullPromise
)
)
{
return
false
;
}
}
}
if
(
!
pullPromise
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onPullFulfilled
(
cx
NewHandler
(
cx
ControllerPullHandler
wrappedController
)
)
;
if
(
!
onPullFulfilled
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onPullRejected
(
cx
NewHandler
(
cx
ControllerPullFailedHandler
wrappedController
)
)
;
if
(
!
onPullRejected
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
pullPromise
onPullFulfilled
onPullRejected
)
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
unwrappedController
)
{
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
return
false
;
}
if
(
unwrappedController
-
>
closeRequested
(
)
)
{
return
false
;
}
if
(
!
unwrappedController
-
>
started
(
)
)
{
return
false
;
}
if
(
unwrappedStream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
>
0
)
{
return
true
;
}
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
;
return
desiredSize
>
0
;
}
void
js
:
:
ReadableStreamControllerClearAlgorithms
(
Handle
<
ReadableStreamController
*
>
controller
)
{
controller
-
>
setPullMethod
(
UndefinedHandleValue
)
;
controller
-
>
setCancelMethod
(
UndefinedHandleValue
)
;
ReadableStreamController
:
:
clearUnderlyingSource
(
controller
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
controller
-
>
as
<
ReadableStreamDefaultController
>
(
)
.
setStrategySize
(
UndefinedHandleValue
)
;
}
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedController
-
>
setCloseRequested
(
)
;
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedController
-
>
queue
(
)
)
;
if
(
unwrappedQueue
-
>
length
(
)
=
=
0
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
Handle
<
Value
>
chunk
)
{
AssertSameCompartment
(
cx
chunk
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedStream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
>
0
)
{
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
unwrappedStream
chunk
false
)
)
{
return
false
;
}
}
else
{
Rooted
<
Value
>
chunkSize
(
cx
Int32Value
(
1
)
)
;
bool
success
=
true
;
Rooted
<
Value
>
strategySize
(
cx
unwrappedController
-
>
strategySize
(
)
)
;
if
(
!
strategySize
.
isUndefined
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
strategySize
)
)
{
return
false
;
}
success
=
Call
(
cx
strategySize
UndefinedHandleValue
chunk
&
chunkSize
)
;
}
if
(
success
)
{
success
=
EnqueueValueWithSize
(
cx
unwrappedController
chunk
chunkSize
)
;
}
if
(
!
success
)
{
Rooted
<
Value
>
exn
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearExceptionAndStack
(
cx
&
exn
&
stack
)
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
exn
)
)
{
return
false
;
}
cx
-
>
setPendingException
(
exn
stack
)
;
return
false
;
}
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamControllerError
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
Handle
<
Value
>
e
)
{
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
AssertSameCompartment
(
cx
e
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
return
true
;
}
if
(
unwrappedController
-
>
is
<
ReadableByteStreamController
>
(
)
)
{
Rooted
<
ReadableByteStreamController
*
>
unwrappedByteStreamController
(
cx
&
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
unwrappedByteStreamController
)
)
{
return
false
;
}
}
if
(
!
ResetQueue
(
cx
unwrappedController
)
)
{
return
false
;
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamErrorInternal
(
cx
unwrappedStream
e
)
;
}
MOZ_MUST_USE
double
js
:
:
ReadableStreamControllerGetDesiredSizeUnchecked
(
ReadableStreamController
*
controller
)
{
#
if
DEBUG
ReadableStream
*
stream
=
controller
-
>
stream
(
)
;
MOZ_ASSERT
(
!
(
stream
-
>
errored
(
)
|
|
stream
-
>
closed
(
)
)
)
;
#
endif
return
controller
-
>
strategyHWM
(
)
-
controller
-
>
queueTotalSize
(
)
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
SourceAlgorithms
sourceAlgorithms
Handle
<
Value
>
underlyingSource
Handle
<
Value
>
pullMethod
Handle
<
Value
>
cancelMethod
double
highWaterMark
Handle
<
Value
>
size
)
{
cx
-
>
check
(
stream
underlyingSource
size
)
;
MOZ_ASSERT
(
pullMethod
.
isUndefined
(
)
|
|
IsCallable
(
pullMethod
)
)
;
MOZ_ASSERT
(
cancelMethod
.
isUndefined
(
)
|
|
IsCallable
(
cancelMethod
)
)
;
MOZ_ASSERT_IF
(
sourceAlgorithms
!
=
SourceAlgorithms
:
:
Script
pullMethod
.
isUndefined
(
)
)
;
MOZ_ASSERT_IF
(
sourceAlgorithms
!
=
SourceAlgorithms
:
:
Script
cancelMethod
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
highWaterMark
>
=
0
)
;
MOZ_ASSERT
(
size
.
isUndefined
(
)
|
|
IsCallable
(
size
)
)
;
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableStreamDefaultController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
false
;
}
MOZ_ASSERT
(
!
stream
-
>
hasController
(
)
)
;
controller
-
>
setStream
(
stream
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
false
;
}
controller
-
>
setFlags
(
0
)
;
controller
-
>
setStrategySize
(
size
)
;
controller
-
>
setStrategyHWM
(
highWaterMark
)
;
controller
-
>
setUnderlyingSource
(
underlyingSource
)
;
controller
-
>
setPullMethod
(
pullMethod
)
;
controller
-
>
setCancelMethod
(
cancelMethod
)
;
stream
-
>
setController
(
controller
)
;
Rooted
<
Value
>
startResult
(
cx
)
;
if
(
sourceAlgorithms
=
=
SourceAlgorithms
:
:
Script
)
{
Rooted
<
Value
>
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
false
;
}
}
Rooted
<
JSObject
*
>
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onStartFulfilled
(
cx
NewHandler
(
cx
ReadableStreamControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
false
;
}
Rooted
<
JSObject
*
>
onStartRejected
(
cx
NewHandler
(
cx
ReadableStreamControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpReadableStreamDefaultControllerFromUnderlyingSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
Handle
<
Value
>
underlyingSource
double
highWaterMark
Handle
<
Value
>
sizeAlgorithm
)
{
MOZ_ASSERT
(
!
underlyingSource
.
isUndefined
(
)
)
;
SourceAlgorithms
sourceAlgorithms
=
SourceAlgorithms
:
:
Script
;
Rooted
<
Value
>
pullMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSource
"
ReadableStream
source
.
pull
method
"
cx
-
>
names
(
)
.
pull
&
pullMethod
)
)
{
return
false
;
}
Rooted
<
Value
>
cancelMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSource
"
ReadableStream
source
.
cancel
method
"
cx
-
>
names
(
)
.
cancel
&
cancelMethod
)
)
{
return
false
;
}
return
SetUpReadableStreamDefaultController
(
cx
stream
sourceAlgorithms
underlyingSource
pullMethod
cancelMethod
highWaterMark
sizeAlgorithm
)
;
}
