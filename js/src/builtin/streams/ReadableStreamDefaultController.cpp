#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
streams
/
ClassSpecMacro
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
PullIntoDescriptor
.
h
"
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamDefaultControllerOperations
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamInternals
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamOperations
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
StreamController
.
h
"
#
include
"
builtin
/
streams
/
TeeState
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
builtin
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
js
:
:
ClassSpec
;
using
js
:
:
PromiseObject
;
using
js
:
:
ReadableStream
;
using
js
:
:
ReadableStreamController
;
using
js
:
:
ReadableStreamControllerCallPullIfNeeded
;
using
js
:
:
ReadableStreamControllerClearAlgorithms
;
using
js
:
:
ReadableStreamControllerError
;
using
js
:
:
ReadableStreamControllerGetDesiredSizeUnchecked
;
using
js
:
:
ReadableStreamDefaultController
;
using
js
:
:
ReadableStreamDefaultControllerClose
;
using
js
:
:
ReadableStreamDefaultControllerEnqueue
;
using
js
:
:
TargetFromHandler
;
using
js
:
:
UnwrapAndTypeCheckThis
;
using
JS
:
:
CallArgs
;
using
JS
:
:
CallArgsFromVp
;
using
JS
:
:
Handle
;
using
JS
:
:
ObjectValue
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
bool
js
:
:
ReadableStreamControllerStartHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
TargetFromHandler
<
ReadableStreamController
>
(
args
)
)
;
controller
-
>
setStarted
(
)
;
MOZ_ASSERT
(
!
controller
-
>
pulling
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
pullAgain
(
)
)
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
js
:
:
ReadableStreamControllerStartFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
TargetFromHandler
<
ReadableStreamController
>
(
args
)
)
;
if
(
!
ReadableStreamControllerError
(
cx
controller
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
ReadableStreamDefaultController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BOGUS_CONSTRUCTOR
"
ReadableStreamDefaultController
"
)
;
return
false
;
}
static
bool
ReadableStreamDefaultController_desiredSize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
get
desiredSize
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
unwrappedStream
-
>
errored
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
if
(
unwrappedStream
-
>
closed
(
)
)
{
args
.
rval
(
)
.
setInt32
(
0
)
;
return
true
;
}
args
.
rval
(
)
.
setNumber
(
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
CheckReadableStreamControllerCanCloseOrEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
const
char
*
action
)
{
if
(
unwrappedController
-
>
closeRequested
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
action
)
;
return
false
;
}
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
action
)
;
return
false
;
}
return
true
;
}
static
bool
ReadableStreamDefaultController_close
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
close
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
CheckReadableStreamControllerCanCloseOrEnqueue
(
cx
unwrappedController
"
close
"
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerClose
(
cx
unwrappedController
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_enqueue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
enqueue
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
CheckReadableStreamControllerCanCloseOrEnqueue
(
cx
unwrappedController
"
enqueue
"
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
unwrappedController
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_error
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
enqueue
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
const
JSPropertySpec
ReadableStreamDefaultController_properties
[
]
=
{
JS_PSG
(
"
desiredSize
"
ReadableStreamDefaultController_desiredSize
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamDefaultController_methods
[
]
=
{
JS_FN
(
"
close
"
ReadableStreamDefaultController_close
0
0
)
JS_FN
(
"
enqueue
"
ReadableStreamDefaultController_enqueue
1
0
)
JS_FN
(
"
error
"
ReadableStreamDefaultController_error
1
0
)
JS_FS_END
}
;
JS_STREAMS_CLASS_SPEC
(
ReadableStreamDefaultController
0
SlotCount
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
Handle
<
Value
>
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
if
(
!
unwrappedController
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ListObject
*
>
unwrappedPendingPullIntos
(
cx
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
.
pendingPullIntos
(
)
)
;
if
(
unwrappedPendingPullIntos
-
>
length
(
)
!
=
0
)
{
PullIntoDescriptor
*
unwrappedDescriptor
=
UnwrapAndDowncastObject
<
PullIntoDescriptor
>
(
cx
&
unwrappedPendingPullIntos
-
>
get
(
0
)
.
toObject
(
)
)
;
if
(
!
unwrappedDescriptor
)
{
return
nullptr
;
}
unwrappedDescriptor
-
>
setBytesFilled
(
0
)
;
}
}
Rooted
<
Value
>
unwrappedUnderlyingSource
(
cx
unwrappedController
-
>
underlyingSource
(
)
)
;
if
(
!
ResetQueue
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
result
(
cx
)
;
if
(
IsMaybeWrapped
<
TeeState
>
(
unwrappedUnderlyingSource
)
)
{
MOZ_ASSERT
(
unwrappedUnderlyingSource
.
toObject
(
)
.
is
<
TeeState
>
(
)
"
tee
streams
and
controllers
are
always
same
-
compartment
with
"
"
the
TeeState
object
"
)
;
Rooted
<
TeeState
*
>
unwrappedTeeState
(
cx
&
unwrappedUnderlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedDefaultController
(
cx
&
unwrappedController
-
>
as
<
ReadableStreamDefaultController
>
(
)
)
;
result
=
ReadableStreamTee_Cancel
(
cx
unwrappedTeeState
unwrappedDefaultController
reason
)
;
}
else
if
(
unwrappedController
-
>
hasExternalSource
(
)
)
{
Rooted
<
Value
>
rval
(
cx
)
;
{
AutoRealm
ar
(
cx
unwrappedController
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
unwrappedController
-
>
stream
(
)
)
;
Rooted
<
Value
>
wrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
cx
-
>
check
(
stream
wrappedReason
)
;
rval
=
source
-
>
cancel
(
cx
stream
wrappedReason
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
rval
)
)
{
result
=
nullptr
;
}
else
{
result
=
PromiseObject
:
:
unforgeableResolve
(
cx
rval
)
;
}
}
else
{
Rooted
<
Value
>
unwrappedCancelMethod
(
cx
unwrappedController
-
>
cancelMethod
(
)
)
;
if
(
unwrappedCancelMethod
.
isUndefined
(
)
)
{
result
=
PromiseResolvedWithUndefined
(
cx
)
;
}
else
{
{
AutoRealm
ar
(
cx
unwrappedController
)
;
cx
-
>
check
(
unwrappedCancelMethod
)
;
cx
-
>
check
(
unwrappedUnderlyingSource
)
;
Rooted
<
Value
>
wrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
result
=
PromiseCall
(
cx
unwrappedCancelMethod
unwrappedUnderlyingSource
wrappedReason
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
result
)
)
{
result
=
nullptr
;
}
}
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
result
;
}
PromiseObject
*
js
:
:
ReadableStreamDefaultControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
)
;
Rooted
<
Value
>
val
(
cx
unwrappedController
-
>
getFixedSlot
(
StreamController
:
:
Slot_Queue
)
)
;
if
(
val
.
isObject
(
)
)
{
unwrappedQueue
=
&
val
.
toObject
(
)
.
as
<
ListObject
>
(
)
;
}
if
(
unwrappedQueue
&
&
unwrappedQueue
-
>
length
(
)
!
=
0
)
{
Rooted
<
Value
>
chunk
(
cx
)
;
if
(
!
DequeueValue
(
cx
unwrappedController
&
chunk
)
)
{
return
nullptr
;
}
if
(
unwrappedController
-
>
closeRequested
(
)
&
&
unwrappedQueue
-
>
length
(
)
=
=
0
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
if
(
!
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
}
cx
-
>
check
(
chunk
)
;
ReadableStreamReader
*
unwrappedReader
=
UnwrapReaderFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
PlainObject
*
readResultObj
=
ReadableStreamCreateReadResult
(
cx
chunk
false
unwrappedReader
-
>
forAuthorCode
(
)
)
;
if
(
!
readResultObj
)
{
return
nullptr
;
}
Rooted
<
Value
>
readResult
(
cx
ObjectValue
(
*
readResultObj
)
)
;
return
PromiseObject
:
:
unforgeableResolveWithNonPromise
(
cx
readResult
)
;
}
Rooted
<
PromiseObject
*
>
pendingPromise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
unwrappedStream
)
)
;
if
(
!
pendingPromise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
pendingPromise
;
}
