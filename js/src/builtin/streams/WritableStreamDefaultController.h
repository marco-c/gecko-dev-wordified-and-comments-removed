#
ifndef
builtin_streams_WritableStreamDefaultController_h
#
define
builtin_streams_WritableStreamDefaultController_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
streams
/
StreamController
.
h
"
#
include
"
builtin
/
streams
/
WritableStream
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
WritableStreamDefaultController
:
public
StreamController
{
public
:
enum
Slots
{
Slot_Stream
=
StreamController
:
:
SlotCount
Slot_UnderlyingSink
Slot_StrategyHWM
Slot_StrategySize
Slot_WriteMethod
Slot_CloseMethod
Slot_AbortMethod
Slot_Flags
SlotCount
}
;
enum
ControllerFlags
{
Flag_Started
=
0b0001
Flag_ExternalSink
=
0b0010
}
;
WritableStream
*
stream
(
)
const
{
return
&
getFixedSlot
(
Slot_Stream
)
.
toObject
(
)
.
as
<
WritableStream
>
(
)
;
}
void
setStream
(
WritableStream
*
stream
)
{
setFixedSlot
(
Slot_Stream
JS
:
:
ObjectValue
(
*
stream
)
)
;
}
JS
:
:
Value
underlyingSink
(
)
const
{
return
getFixedSlot
(
Slot_UnderlyingSink
)
;
}
void
setUnderlyingSink
(
const
JS
:
:
Value
&
underlyingSink
)
{
setFixedSlot
(
Slot_UnderlyingSink
underlyingSink
)
;
}
JS
:
:
WritableStreamUnderlyingSink
*
externalSink
(
)
const
{
static_assert
(
alignof
(
JS
:
:
WritableStreamUnderlyingSink
)
>
=
2
"
external
underling
sinks
are
stored
as
PrivateValues
so
"
"
they
must
have
even
addresses
"
)
;
MOZ_ASSERT
(
hasExternalSink
(
)
)
;
return
static_cast
<
JS
:
:
WritableStreamUnderlyingSink
*
>
(
underlyingSink
(
)
.
toPrivate
(
)
)
;
}
void
setExternalSink
(
JS
:
:
WritableStreamUnderlyingSink
*
underlyingSink
)
{
setUnderlyingSink
(
JS
:
:
PrivateValue
(
underlyingSink
)
)
;
addFlags
(
Flag_ExternalSink
)
;
}
static
void
clearUnderlyingSink
(
JS
:
:
Handle
<
WritableStreamDefaultController
*
>
controller
bool
finalizeSink
=
true
)
{
if
(
controller
-
>
hasExternalSink
(
)
)
{
if
(
finalizeSink
)
{
controller
-
>
externalSink
(
)
-
>
finalize
(
)
;
}
controller
-
>
setFlags
(
controller
-
>
flags
(
)
&
~
Flag_ExternalSink
)
;
}
controller
-
>
setUnderlyingSink
(
JS
:
:
UndefinedHandleValue
)
;
}
JS
:
:
Value
writeMethod
(
)
const
{
return
getFixedSlot
(
Slot_WriteMethod
)
;
}
void
setWriteMethod
(
const
JS
:
:
Value
&
writeMethod
)
{
setFixedSlot
(
Slot_WriteMethod
writeMethod
)
;
}
void
clearWriteMethod
(
)
{
setWriteMethod
(
JS
:
:
UndefinedValue
(
)
)
;
}
JS
:
:
Value
closeMethod
(
)
const
{
return
getFixedSlot
(
Slot_CloseMethod
)
;
}
void
setCloseMethod
(
const
JS
:
:
Value
&
closeMethod
)
{
setFixedSlot
(
Slot_CloseMethod
closeMethod
)
;
}
void
clearCloseMethod
(
)
{
setCloseMethod
(
JS
:
:
UndefinedValue
(
)
)
;
}
JS
:
:
Value
abortMethod
(
)
const
{
return
getFixedSlot
(
Slot_AbortMethod
)
;
}
void
setAbortMethod
(
const
JS
:
:
Value
&
abortMethod
)
{
setFixedSlot
(
Slot_AbortMethod
abortMethod
)
;
}
void
clearAbortMethod
(
)
{
setAbortMethod
(
JS
:
:
UndefinedValue
(
)
)
;
}
double
strategyHWM
(
)
const
{
return
getFixedSlot
(
Slot_StrategyHWM
)
.
toDouble
(
)
;
}
void
setStrategyHWM
(
double
highWaterMark
)
{
setFixedSlot
(
Slot_StrategyHWM
DoubleValue
(
highWaterMark
)
)
;
}
void
setStrategySize
(
const
JS
:
:
Value
&
size
)
{
}
void
clearStrategySize
(
)
{
setStrategySize
(
JS
:
:
UndefinedValue
(
)
)
;
}
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
Int32Value
(
flags
)
)
;
}
void
addFlags
(
uint32_t
flags
)
{
setFlags
(
this
-
>
flags
(
)
|
flags
)
;
}
void
removeFlags
(
uint32_t
flags
)
{
setFlags
(
this
-
>
flags
(
)
&
~
flags
)
;
}
bool
started
(
)
const
{
return
flags
(
)
&
Flag_Started
;
}
void
setStarted
(
)
{
addFlags
(
Flag_Started
)
;
}
bool
hasExternalSink
(
)
const
{
return
flags
(
)
&
Flag_ExternalSink
;
}
static
bool
constructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
static
const
ClassSpec
classSpec_
;
static
const
JSClass
class_
;
static
const
ClassSpec
protoClassSpec_
;
static
const
JSClass
protoClass_
;
}
;
inline
WritableStreamDefaultController
*
WritableStream
:
:
controller
(
)
const
{
return
&
getFixedSlot
(
Slot_Controller
)
.
toObject
(
)
.
as
<
WritableStreamDefaultController
>
(
)
;
}
inline
void
WritableStream
:
:
setController
(
WritableStreamDefaultController
*
controller
)
{
setFixedSlot
(
Slot_Controller
JS
:
:
ObjectValue
(
*
controller
)
)
;
}
}
#
endif
