#
include
"
builtin
/
Stream
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
streams
/
ClassSpecMacro
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
PullIntoDescriptor
.
h
"
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamOperations
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
builtin
/
streams
/
TeeState
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
builtin
/
streams
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
JS
:
:
ReadableStreamMode
ReadableStream
:
:
mode
(
)
const
{
ReadableStreamController
*
controller
=
this
-
>
controller
(
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
return
JS
:
:
ReadableStreamMode
:
:
Default
;
}
return
controller
-
>
as
<
ReadableByteStreamController
>
(
)
.
hasExternalSource
(
)
?
JS
:
:
ReadableStreamMode
:
:
ExternalSource
:
JS
:
:
ReadableStreamMode
:
:
Byte
;
}
#
if
0
class
ByteStreamChunk
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Buffer
=
0
Slot_ByteOffset
Slot_ByteLength
SlotCount
}
;
public
:
static
const
JSClass
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_Buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
uint32_t
byteOffset
(
)
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
void
SetByteOffset
(
uint32_t
offset
)
{
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
offset
)
)
;
}
uint32_t
byteLength
(
)
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
void
SetByteLength
(
uint32_t
length
)
{
setFixedSlot
(
Slot_ByteLength
Int32Value
(
length
)
)
;
}
static
ByteStreamChunk
*
create
(
JSContext
*
cx
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
{
Rooted
<
ByteStreamChunk
*
>
chunk
(
cx
NewBuiltinClassInstance
<
ByteStreamChunk
>
(
cx
)
)
;
if
(
!
chunk
)
{
return
nullptr
;
}
chunk
-
>
setFixedSlot
(
Slot_Buffer
ObjectValue
(
*
buffer
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
return
chunk
;
}
}
;
const
JSClass
ByteStreamChunk
:
:
class_
=
{
"
ByteStreamChunk
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
#
endif
static
MOZ_MUST_USE
JSObject
*
ReadableStreamAddReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
{
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
MOZ_ASSERT
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
|
|
unwrappedStream
-
>
closed
(
)
)
;
MOZ_ASSERT_IF
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
unwrappedStream
-
>
readable
(
)
)
;
RootedObject
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
AppendToListInFixedSlot
(
cx
unwrappedReader
ReadableStreamReader
:
:
Slot_Requests
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
HandleValue
reason
)
;
static
bool
ReturnUndefined
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
;
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamCancel
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
HandleValue
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
unwrappedStream
-
>
setDisturbed
(
)
;
if
(
unwrappedStream
-
>
closed
(
)
)
{
return
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
if
(
unwrappedStream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
unwrappedStream
-
>
storedError
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
)
{
return
nullptr
;
}
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
unwrappedStream
-
>
controller
(
)
)
;
RootedObject
sourceCancelPromise
(
cx
ReadableStreamControllerCancelSteps
(
cx
unwrappedController
reason
)
)
;
if
(
!
sourceCancelPromise
)
{
return
nullptr
;
}
HandlePropertyName
funName
=
cx
-
>
names
(
)
.
empty
;
RootedFunction
returnUndefined
(
cx
NewNativeFunction
(
cx
ReturnUndefined
0
funName
gc
:
:
AllocKind
:
:
FUNCTION
GenericObject
)
)
;
if
(
!
returnUndefined
)
{
return
nullptr
;
}
return
JS
:
:
CallOriginalPromiseThen
(
cx
sourceCancelPromise
returnUndefined
nullptr
)
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
)
{
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedStream
-
>
setClosed
(
)
;
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
if
(
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
{
ForAuthorCodeBool
forAuthorCode
=
unwrappedReader
-
>
forAuthorCode
(
)
;
Rooted
<
ListObject
*
>
unwrappedReadRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
uint32_t
len
=
unwrappedReadRequests
-
>
length
(
)
;
RootedObject
readRequest
(
cx
)
;
RootedObject
resultObj
(
cx
)
;
RootedValue
resultVal
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
readRequest
=
&
unwrappedReadRequests
-
>
getAs
<
JSObject
>
(
i
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readRequest
)
)
{
return
false
;
}
resultObj
=
js
:
:
ReadableStreamCreateReadResult
(
cx
UndefinedHandleValue
true
forAuthorCode
)
;
if
(
!
resultObj
)
{
return
false
;
}
resultVal
=
ObjectValue
(
*
resultObj
)
;
if
(
!
ResolvePromise
(
cx
readRequest
resultVal
)
)
{
return
false
;
}
}
unwrappedReader
-
>
clearRequests
(
)
;
}
RootedObject
closedPromise
(
cx
unwrappedReader
-
>
closedPromise
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
if
(
!
ResolvePromise
(
cx
closedPromise
UndefinedHandleValue
)
)
{
return
false
;
}
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedStream
-
>
controller
(
)
-
>
externalSource
(
)
;
source
-
>
onClosed
(
cx
unwrappedStream
)
;
}
return
true
;
}
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamCreateReadResult
(
JSContext
*
cx
HandleValue
value
bool
done
ForAuthorCodeBool
forAuthorCode
)
{
RootedObject
templateObject
(
cx
forAuthorCode
=
=
ForAuthorCodeBool
:
:
Yes
?
cx
-
>
realm
(
)
-
>
getOrCreateIterResultTemplateObject
(
cx
)
:
cx
-
>
realm
(
)
-
>
getOrCreateIterResultWithoutPrototypeTemplateObject
(
cx
)
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
NativeObject
*
obj
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
obj
NativeObject
:
:
createWithTemplate
(
cx
templateObject
)
)
;
obj
-
>
setSlot
(
Realm
:
:
IterResultObjectValueSlot
value
)
;
obj
-
>
setSlot
(
Realm
:
:
IterResultObjectDoneSlot
done
?
TrueHandleValue
:
FalseHandleValue
)
;
return
obj
;
}
MOZ_MUST_USE
bool
ReadableStreamErrorInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
HandleValue
e
)
{
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedStream
-
>
setErrored
(
)
;
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
RootedValue
wrappedError
(
cx
e
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedError
)
)
{
return
false
;
}
unwrappedStream
-
>
setStoredError
(
wrappedError
)
;
}
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
Rooted
<
ListObject
*
>
unwrappedReadRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
RootedObject
readRequest
(
cx
)
;
RootedValue
val
(
cx
)
;
uint32_t
len
=
unwrappedReadRequests
-
>
length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
val
=
unwrappedReadRequests
-
>
get
(
i
)
;
readRequest
=
&
val
.
toObject
(
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readRequest
)
)
{
return
false
;
}
if
(
!
RejectPromise
(
cx
readRequest
e
)
)
{
return
false
;
}
}
if
(
!
StoreNewListInFixedSlot
(
cx
unwrappedReader
ReadableStreamReader
:
:
Slot_Requests
)
)
{
return
false
;
}
RootedObject
closedPromise
(
cx
unwrappedReader
-
>
closedPromise
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
if
(
!
RejectPromise
(
cx
closedPromise
e
)
)
{
return
false
;
}
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedStream
-
>
controller
(
)
-
>
externalSource
(
)
;
RootedValue
error
(
cx
e
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
error
)
)
{
return
false
;
}
source
-
>
onErrored
(
cx
unwrappedStream
error
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamFulfillReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
HandleValue
chunk
bool
done
)
{
cx
-
>
check
(
chunk
)
;
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
Rooted
<
ListObject
*
>
unwrappedReadIntoRequests
(
cx
unwrappedReader
-
>
requests
(
)
)
;
RootedObject
readIntoRequest
(
cx
&
unwrappedReadIntoRequests
-
>
popFirstAs
<
JSObject
>
(
cx
)
)
;
MOZ_ASSERT
(
readIntoRequest
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readIntoRequest
)
)
{
return
false
;
}
RootedObject
iterResult
(
cx
ReadableStreamCreateReadResult
(
cx
chunk
done
unwrappedReader
-
>
forAuthorCode
(
)
)
)
;
if
(
!
iterResult
)
{
return
false
;
}
RootedValue
val
(
cx
ObjectValue
(
*
iterResult
)
)
;
return
ResolvePromise
(
cx
readIntoRequest
val
)
;
}
uint32_t
js
:
:
ReadableStreamGetNumReadRequests
(
ReadableStream
*
stream
)
{
if
(
!
stream
-
>
hasReader
(
)
)
{
return
0
;
}
JS
:
:
AutoSuppressGCAnalysis
nogc
;
ReadableStreamReader
*
reader
=
UnwrapReaderFromStreamNoThrow
(
stream
)
;
if
(
!
reader
)
{
return
0
;
}
return
reader
-
>
requests
(
)
-
>
length
(
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamHasDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
unwrappedStream
bool
*
result
)
{
if
(
!
unwrappedStream
-
>
hasReader
(
)
)
{
*
result
=
false
;
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
unwrappedReader
(
cx
UnwrapReaderFromStream
(
cx
unwrappedStream
)
)
;
if
(
!
unwrappedReader
)
{
return
false
;
}
*
result
=
unwrappedReader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
;
return
true
;
}
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
;
static
bool
ControllerStartHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
TargetFromHandler
<
ReadableStreamController
>
(
args
)
)
;
controller
-
>
setStarted
(
)
;
MOZ_ASSERT
(
!
controller
-
>
pulling
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
pullAgain
(
)
)
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ControllerStartFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
TargetFromHandler
<
ReadableStreamController
>
(
args
)
)
;
if
(
!
ReadableStreamControllerError
(
cx
controller
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
ReadableStreamDefaultController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BOGUS_CONSTRUCTOR
"
ReadableStreamDefaultController
"
)
;
return
false
;
}
static
bool
ReadableStreamDefaultController_desiredSize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
get
desiredSize
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
unwrappedStream
-
>
errored
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
if
(
unwrappedStream
-
>
closed
(
)
)
{
args
.
rval
(
)
.
setInt32
(
0
)
;
return
true
;
}
args
.
rval
(
)
.
setNumber
(
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
)
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
CheckReadableStreamControllerCanCloseOrEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
const
char
*
action
)
{
if
(
unwrappedController
-
>
closeRequested
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
action
)
;
return
false
;
}
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
action
)
;
return
false
;
}
return
true
;
}
static
bool
ReadableStreamDefaultController_close
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
close
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
CheckReadableStreamControllerCanCloseOrEnqueue
(
cx
unwrappedController
"
close
"
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerClose
(
cx
unwrappedController
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_enqueue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
enqueue
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
CheckReadableStreamControllerCanCloseOrEnqueue
(
cx
unwrappedController
"
enqueue
"
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
unwrappedController
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_error
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedController
(
cx
UnwrapAndTypeCheckThis
<
ReadableStreamDefaultController
>
(
cx
args
"
enqueue
"
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
const
JSPropertySpec
ReadableStreamDefaultController_properties
[
]
=
{
JS_PSG
(
"
desiredSize
"
ReadableStreamDefaultController_desiredSize
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamDefaultController_methods
[
]
=
{
JS_FN
(
"
close
"
ReadableStreamDefaultController_close
0
0
)
JS_FN
(
"
enqueue
"
ReadableStreamDefaultController_enqueue
1
0
)
JS_FN
(
"
error
"
ReadableStreamDefaultController_error
1
0
)
JS_FS_END
}
;
JS_STREAMS_CLASS_SPEC
(
ReadableStreamDefaultController
0
SlotCount
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
static
void
ReadableStreamControllerClearAlgorithms
(
Handle
<
ReadableStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
HandleValue
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
if
(
!
unwrappedController
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ListObject
*
>
unwrappedPendingPullIntos
(
cx
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
.
pendingPullIntos
(
)
)
;
if
(
unwrappedPendingPullIntos
-
>
length
(
)
!
=
0
)
{
PullIntoDescriptor
*
unwrappedDescriptor
=
UnwrapAndDowncastObject
<
PullIntoDescriptor
>
(
cx
&
unwrappedPendingPullIntos
-
>
get
(
0
)
.
toObject
(
)
)
;
if
(
!
unwrappedDescriptor
)
{
return
nullptr
;
}
unwrappedDescriptor
-
>
setBytesFilled
(
0
)
;
}
}
RootedValue
unwrappedUnderlyingSource
(
cx
)
;
unwrappedUnderlyingSource
=
unwrappedController
-
>
underlyingSource
(
)
;
if
(
!
ResetQueue
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
RootedObject
result
(
cx
)
;
if
(
IsMaybeWrapped
<
TeeState
>
(
unwrappedUnderlyingSource
)
)
{
MOZ_ASSERT
(
unwrappedUnderlyingSource
.
toObject
(
)
.
is
<
TeeState
>
(
)
"
tee
streams
and
controllers
are
always
same
-
compartment
with
"
"
the
TeeState
object
"
)
;
Rooted
<
TeeState
*
>
unwrappedTeeState
(
cx
&
unwrappedUnderlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedDefaultController
(
cx
&
unwrappedController
-
>
as
<
ReadableStreamDefaultController
>
(
)
)
;
result
=
ReadableStreamTee_Cancel
(
cx
unwrappedTeeState
unwrappedDefaultController
reason
)
;
}
else
if
(
unwrappedController
-
>
hasExternalSource
(
)
)
{
RootedValue
rval
(
cx
)
;
{
AutoRealm
ar
(
cx
unwrappedController
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
unwrappedController
-
>
stream
(
)
)
;
RootedValue
wrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
cx
-
>
check
(
stream
wrappedReason
)
;
rval
=
source
-
>
cancel
(
cx
stream
wrappedReason
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
rval
)
)
{
result
=
nullptr
;
}
else
{
result
=
PromiseObject
:
:
unforgeableResolve
(
cx
rval
)
;
}
}
else
{
RootedValue
unwrappedCancelMethod
(
cx
unwrappedController
-
>
cancelMethod
(
)
)
;
if
(
unwrappedCancelMethod
.
isUndefined
(
)
)
{
result
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
{
AutoRealm
ar
(
cx
&
unwrappedCancelMethod
.
toObject
(
)
)
;
RootedValue
underlyingSource
(
cx
unwrappedUnderlyingSource
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
underlyingSource
)
)
{
return
nullptr
;
}
RootedValue
wrappedReason
(
cx
reason
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
result
=
PromiseCall
(
cx
unwrappedCancelMethod
underlyingSource
wrappedReason
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
result
)
)
{
result
=
nullptr
;
}
}
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
result
;
}
static
JSObject
*
ReadableStreamDefaultControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
)
;
RootedValue
val
(
cx
unwrappedController
-
>
getFixedSlot
(
StreamController
:
:
Slot_Queue
)
)
;
if
(
val
.
isObject
(
)
)
{
unwrappedQueue
=
&
val
.
toObject
(
)
.
as
<
ListObject
>
(
)
;
}
if
(
unwrappedQueue
&
&
unwrappedQueue
-
>
length
(
)
!
=
0
)
{
RootedValue
chunk
(
cx
)
;
if
(
!
DequeueValue
(
cx
unwrappedController
&
chunk
)
)
{
return
nullptr
;
}
if
(
unwrappedController
-
>
closeRequested
(
)
&
&
unwrappedQueue
-
>
length
(
)
=
=
0
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
if
(
!
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
}
cx
-
>
check
(
chunk
)
;
ReadableStreamReader
*
unwrappedReader
=
UnwrapReaderFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
RootedObject
readResultObj
(
cx
ReadableStreamCreateReadResult
(
cx
chunk
false
unwrappedReader
-
>
forAuthorCode
(
)
)
)
;
if
(
!
readResultObj
)
{
return
nullptr
;
}
RootedValue
readResult
(
cx
ObjectValue
(
*
readResultObj
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
readResult
)
;
}
RootedObject
pendingPromise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
unwrappedStream
)
)
;
if
(
!
pendingPromise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
pendingPromise
;
}
static
bool
ControllerPullHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
unwrappedController
(
cx
UnwrapCalleeSlot
<
ReadableStreamController
>
(
cx
args
0
)
)
;
if
(
!
unwrappedController
)
{
return
false
;
}
bool
pullAgain
=
unwrappedController
-
>
pullAgain
(
)
;
unwrappedController
-
>
clearPullFlags
(
)
;
if
(
pullAgain
)
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ControllerPullFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
e
=
args
.
get
(
0
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
UnwrapCalleeSlot
<
ReadableStreamController
>
(
cx
args
0
)
)
;
if
(
!
controller
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
unwrappedController
)
;
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
bool
shouldPull
=
ReadableStreamControllerShouldCallPull
(
unwrappedController
)
;
if
(
!
shouldPull
)
{
return
true
;
}
if
(
unwrappedController
-
>
pulling
(
)
)
{
unwrappedController
-
>
setPullAgain
(
)
;
return
true
;
}
MOZ_ASSERT
(
!
unwrappedController
-
>
pullAgain
(
)
)
;
unwrappedController
-
>
setPulling
(
)
;
RootedObject
wrappedController
(
cx
unwrappedController
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedController
)
)
{
return
false
;
}
RootedObject
pullPromise
(
cx
)
;
RootedValue
unwrappedUnderlyingSource
(
cx
unwrappedController
-
>
underlyingSource
(
)
)
;
if
(
IsMaybeWrapped
<
TeeState
>
(
unwrappedUnderlyingSource
)
)
{
MOZ_ASSERT
(
unwrappedUnderlyingSource
.
toObject
(
)
.
is
<
TeeState
>
(
)
"
tee
streams
and
controllers
are
always
same
-
compartment
with
"
"
the
TeeState
object
"
)
;
Rooted
<
TeeState
*
>
unwrappedTeeState
(
cx
&
unwrappedUnderlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
pullPromise
=
ReadableStreamTee_Pull
(
cx
unwrappedTeeState
)
;
}
else
if
(
unwrappedController
-
>
hasExternalSource
(
)
)
{
{
AutoRealm
ar
(
cx
unwrappedController
)
;
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
unwrappedController
-
>
stream
(
)
)
;
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
;
source
-
>
requestData
(
cx
stream
desiredSize
)
;
}
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
RootedValue
unwrappedPullMethod
(
cx
unwrappedController
-
>
pullMethod
(
)
)
;
if
(
unwrappedPullMethod
.
isUndefined
(
)
)
{
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
{
AutoRealm
ar
(
cx
&
unwrappedPullMethod
.
toObject
(
)
)
;
RootedValue
underlyingSource
(
cx
unwrappedUnderlyingSource
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
underlyingSource
)
)
{
return
false
;
}
RootedValue
controller
(
cx
ObjectValue
(
*
unwrappedController
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
controller
)
)
{
return
false
;
}
pullPromise
=
PromiseCall
(
cx
unwrappedPullMethod
underlyingSource
controller
)
;
if
(
!
pullPromise
)
{
return
false
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
pullPromise
)
)
{
return
false
;
}
}
}
if
(
!
pullPromise
)
{
return
false
;
}
RootedObject
onPullFulfilled
(
cx
NewHandler
(
cx
ControllerPullHandler
wrappedController
)
)
;
if
(
!
onPullFulfilled
)
{
return
false
;
}
RootedObject
onPullRejected
(
cx
NewHandler
(
cx
ControllerPullFailedHandler
wrappedController
)
)
;
if
(
!
onPullRejected
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
pullPromise
onPullFulfilled
onPullRejected
)
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
unwrappedController
)
{
ReadableStream
*
unwrappedStream
=
unwrappedController
-
>
stream
(
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
return
false
;
}
if
(
unwrappedController
-
>
closeRequested
(
)
)
{
return
false
;
}
if
(
!
unwrappedController
-
>
started
(
)
)
{
return
false
;
}
if
(
unwrappedStream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
>
0
)
{
return
true
;
}
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
unwrappedController
)
;
return
desiredSize
>
0
;
}
static
void
ReadableStreamControllerClearAlgorithms
(
Handle
<
ReadableStreamController
*
>
controller
)
{
controller
-
>
setPullMethod
(
UndefinedHandleValue
)
;
controller
-
>
setCancelMethod
(
UndefinedHandleValue
)
;
ReadableStreamController
:
:
clearUnderlyingSource
(
controller
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
controller
-
>
as
<
ReadableStreamDefaultController
>
(
)
.
setStrategySize
(
UndefinedHandleValue
)
;
}
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
unwrappedController
-
>
setCloseRequested
(
)
;
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedController
-
>
queue
(
)
)
;
if
(
unwrappedQueue
-
>
length
(
)
=
=
0
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
unwrappedController
HandleValue
chunk
)
{
AssertSameCompartment
(
cx
chunk
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedStream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
>
0
)
{
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
unwrappedStream
chunk
false
)
)
{
return
false
;
}
}
else
{
RootedValue
chunkSize
(
cx
NumberValue
(
1
)
)
;
bool
success
=
true
;
RootedValue
strategySize
(
cx
unwrappedController
-
>
strategySize
(
)
)
;
if
(
!
strategySize
.
isUndefined
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
strategySize
)
)
{
return
false
;
}
success
=
Call
(
cx
strategySize
UndefinedHandleValue
chunk
&
chunkSize
)
;
}
if
(
success
)
{
success
=
EnqueueValueWithSize
(
cx
unwrappedController
chunk
chunkSize
)
;
}
if
(
!
success
)
{
RootedValue
exn
(
cx
)
;
RootedSavedFrame
stack
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearExceptionAndStack
(
cx
&
exn
&
stack
)
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
exn
)
)
{
return
false
;
}
cx
-
>
setPendingException
(
exn
stack
)
;
return
false
;
}
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
;
MOZ_MUST_USE
bool
js
:
:
ReadableStreamControllerError
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
HandleValue
e
)
{
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
AssertSameCompartment
(
cx
e
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
if
(
!
unwrappedStream
-
>
readable
(
)
)
{
return
true
;
}
if
(
unwrappedController
-
>
is
<
ReadableByteStreamController
>
(
)
)
{
Rooted
<
ReadableByteStreamController
*
>
unwrappedByteStreamController
(
cx
&
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
unwrappedByteStreamController
)
)
{
return
false
;
}
}
if
(
!
ResetQueue
(
cx
unwrappedController
)
)
{
return
false
;
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamErrorInternal
(
cx
unwrappedStream
e
)
;
}
MOZ_MUST_USE
double
js
:
:
ReadableStreamControllerGetDesiredSizeUnchecked
(
ReadableStreamController
*
controller
)
{
#
if
DEBUG
ReadableStream
*
stream
=
controller
-
>
stream
(
)
;
MOZ_ASSERT
(
!
(
stream
-
>
errored
(
)
|
|
stream
-
>
closed
(
)
)
)
;
#
endif
return
controller
-
>
strategyHWM
(
)
-
controller
-
>
queueTotalSize
(
)
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
SourceAlgorithms
sourceAlgorithms
HandleValue
underlyingSource
HandleValue
pullMethod
HandleValue
cancelMethod
double
highWaterMark
HandleValue
size
)
{
cx
-
>
check
(
stream
underlyingSource
size
)
;
MOZ_ASSERT
(
pullMethod
.
isUndefined
(
)
|
|
IsCallable
(
pullMethod
)
)
;
MOZ_ASSERT
(
cancelMethod
.
isUndefined
(
)
|
|
IsCallable
(
cancelMethod
)
)
;
MOZ_ASSERT_IF
(
sourceAlgorithms
!
=
SourceAlgorithms
:
:
Script
pullMethod
.
isUndefined
(
)
)
;
MOZ_ASSERT_IF
(
sourceAlgorithms
!
=
SourceAlgorithms
:
:
Script
cancelMethod
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
highWaterMark
>
=
0
)
;
MOZ_ASSERT
(
size
.
isUndefined
(
)
|
|
IsCallable
(
size
)
)
;
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableStreamDefaultController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
false
;
}
MOZ_ASSERT
(
!
stream
-
>
hasController
(
)
)
;
controller
-
>
setStream
(
stream
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
false
;
}
controller
-
>
setFlags
(
0
)
;
controller
-
>
setStrategySize
(
size
)
;
controller
-
>
setStrategyHWM
(
highWaterMark
)
;
controller
-
>
setUnderlyingSource
(
underlyingSource
)
;
controller
-
>
setPullMethod
(
pullMethod
)
;
controller
-
>
setCancelMethod
(
cancelMethod
)
;
stream
-
>
setController
(
controller
)
;
RootedValue
startResult
(
cx
)
;
if
(
sourceAlgorithms
=
=
SourceAlgorithms
:
:
Script
)
{
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
false
;
}
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
false
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
false
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
SetUpReadableStreamDefaultControllerFromUnderlyingSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingSource
double
highWaterMark
HandleValue
sizeAlgorithm
)
{
MOZ_ASSERT
(
!
underlyingSource
.
isUndefined
(
)
)
;
SourceAlgorithms
sourceAlgorithms
=
SourceAlgorithms
:
:
Script
;
RootedValue
pullMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSource
"
ReadableStream
source
.
pull
method
"
cx
-
>
names
(
)
.
pull
&
pullMethod
)
)
{
return
false
;
}
RootedValue
cancelMethod
(
cx
)
;
if
(
!
CreateAlgorithmFromUnderlyingMethod
(
cx
underlyingSource
"
ReadableStream
source
.
cancel
method
"
cx
-
>
names
(
)
.
cancel
&
cancelMethod
)
)
{
return
false
;
}
return
SetUpReadableStreamDefaultController
(
cx
stream
sourceAlgorithms
underlyingSource
pullMethod
cancelMethod
highWaterMark
sizeAlgorithm
)
;
}
#
if
0
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingByteSource
HandleValue
highWaterMarkVal
)
{
cx
-
>
check
(
stream
underlyingByteSource
highWaterMarkVal
)
;
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
nullptr
;
}
controller
-
>
setStream
(
stream
)
;
controller
-
>
setUnderlyingSource
(
underlyingByteSource
)
;
controller
-
>
setFlags
(
0
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
controller
)
)
{
return
nullptr
;
}
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
controller
-
>
flags
(
)
=
=
0
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
&
highWaterMark
)
)
{
return
nullptr
;
}
controller
-
>
setStrategyHWM
(
highWaterMark
)
;
RootedValue
autoAllocateChunkSize
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
autoAllocateChunkSize
&
autoAllocateChunkSize
)
)
{
return
nullptr
;
}
if
(
!
autoAllocateChunkSize
.
isUndefined
(
)
)
{
if
(
!
IsInteger
(
autoAllocateChunkSize
)
|
|
autoAllocateChunkSize
.
toNumber
(
)
<
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE
)
;
return
nullptr
;
}
}
controller
-
>
setAutoAllocateChunkSize
(
autoAllocateChunkSize
)
;
if
(
!
StoreNewListInFixedSlot
(
cx
controller
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
)
{
return
nullptr
;
}
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
nullptr
;
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
nullptr
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
nullptr
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
nullptr
;
}
return
controller
;
}
#
endif
bool
ReadableByteStreamController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BOGUS_CONSTRUCTOR
"
ReadableByteStreamController
"
)
;
return
false
;
}
class
MOZ_RAII
AutoClearUnderlyingSource
{
Rooted
<
ReadableStreamController
*
>
controller_
;
public
:
AutoClearUnderlyingSource
(
JSContext
*
cx
ReadableStreamController
*
controller
)
:
controller_
(
cx
controller
)
{
}
~
AutoClearUnderlyingSource
(
)
{
if
(
controller_
)
{
ReadableStreamController
:
:
clearUnderlyingSource
(
controller_
false
)
;
}
}
void
reset
(
)
{
controller_
=
nullptr
;
}
}
;
MOZ_MUST_USE
bool
js
:
:
SetUpExternalReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
JS
:
:
ReadableStreamUnderlyingSource
*
source
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
false
;
}
AutoClearUnderlyingSource
autoClear
(
cx
controller
)
;
MOZ_ASSERT
(
!
stream
-
>
hasController
(
)
)
;
controller
-
>
setStream
(
stream
)
;
controller
-
>
setFlags
(
0
)
;
MOZ_ASSERT
(
!
controller
-
>
pullAgain
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
pulling
(
)
)
;
controller
-
>
setQueueTotalSize
(
0
)
;
MOZ_ASSERT
(
!
controller
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
started
(
)
)
;
controller
-
>
setStrategyHWM
(
0
)
;
controller
-
>
setExternalSource
(
source
)
;
MOZ_ASSERT
(
controller
-
>
autoAllocateChunkSize
(
)
.
isUndefined
(
)
)
;
if
(
!
StoreNewListInFixedSlot
(
cx
controller
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
)
{
return
false
;
}
stream
-
>
setController
(
controller
)
;
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
)
;
if
(
!
startPromise
)
{
return
false
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
false
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
false
;
}
autoClear
.
reset
(
)
;
return
true
;
}
static
const
JSPropertySpec
ReadableByteStreamController_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableByteStreamController_methods
[
]
=
{
JS_FS_END
}
;
static
void
ReadableByteStreamControllerFinalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
ReadableByteStreamController
&
controller
=
obj
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
controller
.
getFixedSlot
(
ReadableStreamController
:
:
Slot_Flags
)
.
isUndefined
(
)
)
{
return
;
}
if
(
!
controller
.
hasExternalSource
(
)
)
{
return
;
}
controller
.
externalSource
(
)
-
>
finalize
(
)
;
}
static
const
JSClassOps
ReadableByteStreamControllerClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ReadableByteStreamControllerFinalize
nullptr
nullptr
nullptr
nullptr
}
;
JS_STREAMS_CLASS_SPEC
(
ReadableByteStreamController
0
SlotCount
ClassSpec
:
:
DontDefineConstructor
JSCLASS_BACKGROUND_FINALIZE
&
ReadableByteStreamControllerClassOps
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
#
ifdef
DEBUG
bool
result
;
if
(
!
ReadableStreamHasDefaultReader
(
cx
unwrappedStream
&
result
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
result
)
;
#
endif
RootedValue
val
(
cx
)
;
double
queueTotalSize
=
unwrappedController
-
>
queueTotalSize
(
)
;
if
(
queueTotalSize
>
0
)
{
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
=
=
0
)
;
RootedObject
view
(
cx
)
;
MOZ_RELEASE_ASSERT
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
#
if
0
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
#
endif
{
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
view
=
JS_NewUint8Array
(
cx
queueTotalSize
)
;
if
(
!
view
)
{
return
nullptr
;
}
size_t
bytesWritten
;
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
void
*
buffer
=
JS_GetArrayBufferViewData
(
view
&
dummy
noGC
)
;
source
-
>
writeIntoReadRequestBuffer
(
cx
unwrappedStream
buffer
queueTotalSize
&
bytesWritten
)
;
}
queueTotalSize
=
queueTotalSize
-
bytesWritten
;
}
#
if
0
else
{
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedController
-
>
queue
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
unwrappedEntry
(
cx
UnwrapAndDowncastObject
<
ByteStreamChunk
>
(
cx
&
unwrappedQueue
-
>
popFirstAs
<
JSObject
>
(
cx
)
)
)
;
if
(
!
unwrappedEntry
)
{
return
nullptr
;
}
queueTotalSize
=
queueTotalSize
-
unwrappedEntry
-
>
byteLength
(
)
;
RootedObject
buffer
(
cx
unwrappedEntry
-
>
buffer
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
buffer
)
)
{
return
nullptr
;
}
uint32_t
byteOffset
=
unwrappedEntry
-
>
byteOffset
(
)
;
view
=
JS_NewUint8ArrayWithBuffer
(
cx
buffer
byteOffset
unwrappedEntry
-
>
byteLength
(
)
)
;
if
(
!
view
)
{
return
nullptr
;
}
}
#
endif
unwrappedController
-
>
setQueueTotalSize
(
queueTotalSize
)
;
if
(
!
ReadableByteStreamControllerHandleQueueDrain
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
val
.
setObject
(
*
view
)
;
ReadableStreamReader
*
unwrappedReader
=
UnwrapReaderFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
RootedObject
readResult
(
cx
ReadableStreamCreateReadResult
(
cx
val
false
unwrappedReader
-
>
forAuthorCode
(
)
)
)
;
if
(
!
readResult
)
{
return
nullptr
;
}
val
.
setObject
(
*
readResult
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
val
)
;
}
val
=
unwrappedController
-
>
autoAllocateChunkSize
(
)
;
if
(
!
val
.
isUndefined
(
)
)
{
double
autoAllocateChunkSize
=
val
.
toNumber
(
)
;
JSObject
*
bufferObj
=
JS
:
:
NewArrayBuffer
(
cx
autoAllocateChunkSize
)
;
if
(
!
bufferObj
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
RootedArrayBufferObject
buffer
(
cx
&
bufferObj
-
>
as
<
ArrayBufferObject
>
(
)
)
;
RootedObject
pullIntoDescriptor
(
cx
PullIntoDescriptor
:
:
create
(
cx
buffer
0
autoAllocateChunkSize
0
1
nullptr
ReaderType
:
:
Default
)
)
;
if
(
!
pullIntoDescriptor
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
!
AppendToListInFixedSlot
(
cx
unwrappedController
ReadableByteStreamController
:
:
Slot_PendingPullIntos
pullIntoDescriptor
)
)
{
return
nullptr
;
}
}
RootedObject
promise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
unwrappedStream
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
promise
;
}
MOZ_MUST_USE
JSObject
*
js
:
:
ReadableStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
if
(
unwrappedController
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedDefaultController
(
cx
&
unwrappedController
-
>
as
<
ReadableStreamDefaultController
>
(
)
)
;
return
ReadableStreamDefaultControllerPullSteps
(
cx
unwrappedDefaultController
)
;
}
Rooted
<
ReadableByteStreamController
*
>
unwrappedByteController
(
cx
&
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
)
;
return
ReadableByteStreamControllerPullSteps
(
cx
unwrappedByteController
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
if
(
!
ReadableByteStreamControllerInvalidateBYOBRequest
(
cx
unwrappedController
)
)
{
return
false
;
}
return
StoreNewListInFixedSlot
(
cx
unwrappedController
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableByteStreamControllerClose
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedController
-
>
queueTotalSize
(
)
>
0
)
{
unwrappedController
-
>
setCloseRequested
(
)
;
return
true
;
}
Rooted
<
ListObject
*
>
unwrappedPendingPullIntos
(
cx
unwrappedController
-
>
pendingPullIntos
(
)
)
;
if
(
unwrappedPendingPullIntos
-
>
length
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
unwrappedFirstPendingPullInto
(
cx
UnwrapAndDowncastObject
<
PullIntoDescriptor
>
(
cx
&
unwrappedPendingPullIntos
-
>
get
(
0
)
.
toObject
(
)
)
)
;
if
(
!
unwrappedFirstPendingPullInto
)
{
return
false
;
}
if
(
unwrappedFirstPendingPullInto
-
>
bytesFilled
(
)
>
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL
)
;
RootedValue
e
(
cx
)
;
RootedSavedFrame
stack
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearExceptionAndStack
(
cx
&
e
&
stack
)
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
e
)
)
{
return
false
;
}
cx
-
>
setPendingException
(
e
stack
)
;
return
false
;
}
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
MOZ_ASSERT
(
unwrappedController
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedController
-
>
queueTotalSize
(
)
=
=
0
&
&
unwrappedController
-
>
closeRequested
(
)
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
;
}
enum
BYOBRequestSlots
{
BYOBRequestSlot_Controller
BYOBRequestSlot_View
BYOBRequestSlotCount
}
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
RootedValue
unwrappedBYOBRequestVal
(
cx
unwrappedController
-
>
byobRequest
(
)
)
;
if
(
unwrappedBYOBRequestVal
.
isUndefined
(
)
)
{
return
true
;
}
RootedNativeObject
unwrappedBYOBRequest
(
cx
UnwrapAndDowncastValue
<
NativeObject
>
(
cx
unwrappedBYOBRequestVal
)
)
;
if
(
!
unwrappedBYOBRequest
)
{
return
false
;
}
unwrappedBYOBRequest
-
>
setFixedSlot
(
BYOBRequestSlot_Controller
UndefinedValue
(
)
)
;
unwrappedBYOBRequest
-
>
setFixedSlot
(
BYOBRequestSlot_View
UndefinedValue
(
)
)
;
unwrappedController
-
>
clearBYOBRequest
(
)
;
return
true
;
}
