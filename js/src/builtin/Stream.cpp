#
include
"
builtin
/
Stream
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
streams
/
ClassSpecMacro
.
h
"
#
include
"
builtin
/
streams
/
MiscellaneousOperations
.
h
"
#
include
"
builtin
/
streams
/
PullIntoDescriptor
.
h
"
#
include
"
builtin
/
streams
/
QueueWithSizes
.
h
"
#
include
"
builtin
/
streams
/
ReadableStream
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamController
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamDefaultControllerOperations
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamInternals
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
builtin
/
HandlerFunction
-
inl
.
h
"
#
include
"
builtin
/
streams
/
ReadableStreamReader
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
#
if
0
class
ByteStreamChunk
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Buffer
=
0
Slot_ByteOffset
Slot_ByteLength
SlotCount
}
;
public
:
static
const
JSClass
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_Buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
uint32_t
byteOffset
(
)
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
void
SetByteOffset
(
uint32_t
offset
)
{
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
offset
)
)
;
}
uint32_t
byteLength
(
)
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
void
SetByteLength
(
uint32_t
length
)
{
setFixedSlot
(
Slot_ByteLength
Int32Value
(
length
)
)
;
}
static
ByteStreamChunk
*
create
(
JSContext
*
cx
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
{
Rooted
<
ByteStreamChunk
*
>
chunk
(
cx
NewBuiltinClassInstance
<
ByteStreamChunk
>
(
cx
)
)
;
if
(
!
chunk
)
{
return
nullptr
;
}
chunk
-
>
setFixedSlot
(
Slot_Buffer
ObjectValue
(
*
buffer
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
return
chunk
;
}
}
;
const
JSClass
ByteStreamChunk
:
:
class_
=
{
"
ByteStreamChunk
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
#
endif
#
if
0
[
[
nodiscard
]
]
static
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingByteSource
HandleValue
highWaterMarkVal
)
{
cx
-
>
check
(
stream
underlyingByteSource
highWaterMarkVal
)
;
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
nullptr
;
}
controller
-
>
setStream
(
stream
)
;
controller
-
>
setUnderlyingSource
(
underlyingByteSource
)
;
controller
-
>
setFlags
(
0
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
controller
)
)
{
return
nullptr
;
}
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
controller
-
>
flags
(
)
=
=
0
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
&
highWaterMark
)
)
{
return
nullptr
;
}
controller
-
>
setStrategyHWM
(
highWaterMark
)
;
RootedValue
autoAllocateChunkSize
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
autoAllocateChunkSize
&
autoAllocateChunkSize
)
)
{
return
nullptr
;
}
if
(
!
autoAllocateChunkSize
.
isUndefined
(
)
)
{
if
(
!
IsInteger
(
autoAllocateChunkSize
)
|
|
autoAllocateChunkSize
.
toNumber
(
)
<
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE
)
;
return
nullptr
;
}
}
controller
-
>
setAutoAllocateChunkSize
(
autoAllocateChunkSize
)
;
if
(
!
StoreNewListInFixedSlot
(
cx
controller
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
)
{
return
nullptr
;
}
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
nullptr
;
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
nullptr
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ReadableStreamControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
nullptr
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
nullptr
;
}
return
controller
;
}
#
endif
bool
ReadableByteStreamController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BOGUS_CONSTRUCTOR
"
ReadableByteStreamController
"
)
;
return
false
;
}
class
MOZ_RAII
AutoClearUnderlyingSource
{
Rooted
<
ReadableStreamController
*
>
controller_
;
public
:
AutoClearUnderlyingSource
(
JSContext
*
cx
ReadableStreamController
*
controller
)
:
controller_
(
cx
controller
)
{
}
~
AutoClearUnderlyingSource
(
)
{
if
(
controller_
)
{
ReadableStreamController
:
:
clearUnderlyingSource
(
controller_
false
)
;
}
}
void
reset
(
)
{
controller_
=
nullptr
;
}
}
;
[
[
nodiscard
]
]
bool
js
:
:
SetUpExternalReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
JS
:
:
ReadableStreamUnderlyingSource
*
source
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
)
;
if
(
!
controller
)
{
return
false
;
}
AutoClearUnderlyingSource
autoClear
(
cx
controller
)
;
MOZ_ASSERT
(
!
stream
-
>
hasController
(
)
)
;
controller
-
>
setStream
(
stream
)
;
controller
-
>
setFlags
(
0
)
;
MOZ_ASSERT
(
!
controller
-
>
pullAgain
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
pulling
(
)
)
;
controller
-
>
setQueueTotalSize
(
0
)
;
MOZ_ASSERT
(
!
controller
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
!
controller
-
>
started
(
)
)
;
controller
-
>
setStrategyHWM
(
0
)
;
controller
-
>
setExternalSource
(
source
)
;
MOZ_ASSERT
(
controller
-
>
autoAllocateChunkSize
(
)
.
isUndefined
(
)
)
;
if
(
!
StoreNewListInFixedSlot
(
cx
controller
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
)
{
return
false
;
}
stream
-
>
setController
(
controller
)
;
Rooted
<
PromiseObject
*
>
startPromise
(
cx
PromiseResolvedWithUndefined
(
cx
)
)
;
if
(
!
startPromise
)
{
return
false
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ReadableStreamControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
false
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ReadableStreamControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
false
;
}
autoClear
.
reset
(
)
;
return
true
;
}
static
const
JSPropertySpec
ReadableByteStreamController_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableByteStreamController_methods
[
]
=
{
JS_FS_END
}
;
static
void
ReadableByteStreamControllerFinalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
ReadableByteStreamController
&
controller
=
obj
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
controller
.
getFixedSlot
(
ReadableStreamController
:
:
Slot_Flags
)
.
isUndefined
(
)
)
{
return
;
}
if
(
!
controller
.
hasExternalSource
(
)
)
{
return
;
}
controller
.
externalSource
(
)
-
>
finalize
(
)
;
}
static
const
JSClassOps
ReadableByteStreamControllerClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ReadableByteStreamControllerFinalize
nullptr
nullptr
nullptr
}
;
JS_STREAMS_CLASS_SPEC
(
ReadableByteStreamController
0
SlotCount
ClassSpec
:
:
DontDefineConstructor
JSCLASS_BACKGROUND_FINALIZE
&
ReadableByteStreamControllerClassOps
)
;
[
[
nodiscard
]
]
static
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
;
[
[
nodiscard
]
]
static
PromiseObject
*
ReadableByteStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
#
ifdef
DEBUG
bool
result
;
if
(
!
ReadableStreamHasDefaultReader
(
cx
unwrappedStream
&
result
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
result
)
;
#
endif
RootedValue
val
(
cx
)
;
double
queueTotalSize
=
unwrappedController
-
>
queueTotalSize
(
)
;
if
(
queueTotalSize
>
0
)
{
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
unwrappedStream
)
=
=
0
)
;
RootedObject
view
(
cx
)
;
MOZ_RELEASE_ASSERT
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
#
if
0
if
(
unwrappedStream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
#
endif
{
JS
:
:
ReadableStreamUnderlyingSource
*
source
=
unwrappedController
-
>
externalSource
(
)
;
view
=
JS_NewUint8Array
(
cx
queueTotalSize
)
;
if
(
!
view
)
{
return
nullptr
;
}
size_t
bytesWritten
;
{
AutoRealm
ar
(
cx
unwrappedStream
)
;
source
-
>
writeIntoReadRequestBuffer
(
cx
unwrappedStream
view
queueTotalSize
&
bytesWritten
)
;
}
queueTotalSize
=
queueTotalSize
-
bytesWritten
;
}
#
if
0
else
{
Rooted
<
ListObject
*
>
unwrappedQueue
(
cx
unwrappedController
-
>
queue
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
unwrappedEntry
(
cx
UnwrapAndDowncastObject
<
ByteStreamChunk
>
(
cx
&
unwrappedQueue
-
>
popFirstAs
<
JSObject
>
(
cx
)
)
)
;
if
(
!
unwrappedEntry
)
{
return
nullptr
;
}
queueTotalSize
=
queueTotalSize
-
unwrappedEntry
-
>
byteLength
(
)
;
RootedObject
buffer
(
cx
unwrappedEntry
-
>
buffer
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
buffer
)
)
{
return
nullptr
;
}
uint32_t
byteOffset
=
unwrappedEntry
-
>
byteOffset
(
)
;
view
=
JS_NewUint8ArrayWithBuffer
(
cx
buffer
byteOffset
unwrappedEntry
-
>
byteLength
(
)
)
;
if
(
!
view
)
{
return
nullptr
;
}
}
#
endif
unwrappedController
-
>
setQueueTotalSize
(
queueTotalSize
)
;
if
(
!
ReadableByteStreamControllerHandleQueueDrain
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
val
.
setObject
(
*
view
)
;
ReadableStreamReader
*
unwrappedReader
=
UnwrapReaderFromStream
(
cx
unwrappedStream
)
;
if
(
!
unwrappedReader
)
{
return
nullptr
;
}
Rooted
<
PlainObject
*
>
readResult
(
cx
ReadableStreamCreateReadResult
(
cx
val
false
unwrappedReader
-
>
forAuthorCode
(
)
)
)
;
if
(
!
readResult
)
{
return
nullptr
;
}
val
.
setObject
(
*
readResult
)
;
return
PromiseObject
:
:
unforgeableResolveWithNonPromise
(
cx
val
)
;
}
val
=
unwrappedController
-
>
autoAllocateChunkSize
(
)
;
if
(
!
val
.
isUndefined
(
)
)
{
double
autoAllocateChunkSize
=
val
.
toNumber
(
)
;
JSObject
*
bufferObj
=
JS
:
:
NewArrayBuffer
(
cx
autoAllocateChunkSize
)
;
if
(
!
bufferObj
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
RootedArrayBufferObject
buffer
(
cx
&
bufferObj
-
>
as
<
ArrayBufferObject
>
(
)
)
;
RootedObject
pullIntoDescriptor
(
cx
PullIntoDescriptor
:
:
create
(
cx
buffer
0
autoAllocateChunkSize
0
1
nullptr
ReaderType
:
:
Default
)
)
;
if
(
!
pullIntoDescriptor
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
!
AppendToListInFixedSlot
(
cx
unwrappedController
ReadableByteStreamController
:
:
Slot_PendingPullIntos
pullIntoDescriptor
)
)
{
return
nullptr
;
}
}
Rooted
<
PromiseObject
*
>
promise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
unwrappedStream
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
)
{
return
nullptr
;
}
return
promise
;
}
[
[
nodiscard
]
]
PromiseObject
*
js
:
:
ReadableStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
if
(
unwrappedController
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
unwrappedDefaultController
(
cx
&
unwrappedController
-
>
as
<
ReadableStreamDefaultController
>
(
)
)
;
return
ReadableStreamDefaultControllerPullSteps
(
cx
unwrappedDefaultController
)
;
}
Rooted
<
ReadableByteStreamController
*
>
unwrappedByteController
(
cx
&
unwrappedController
-
>
as
<
ReadableByteStreamController
>
(
)
)
;
return
ReadableByteStreamControllerPullSteps
(
cx
unwrappedByteController
)
;
}
[
[
nodiscard
]
]
static
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
;
[
[
nodiscard
]
]
bool
js
:
:
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
if
(
!
ReadableByteStreamControllerInvalidateBYOBRequest
(
cx
unwrappedController
)
)
{
return
false
;
}
return
StoreNewListInFixedSlot
(
cx
unwrappedController
ReadableByteStreamController
:
:
Slot_PendingPullIntos
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
ReadableByteStreamControllerClose
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
!
unwrappedController
-
>
closeRequested
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedController
-
>
queueTotalSize
(
)
>
0
)
{
unwrappedController
-
>
setCloseRequested
(
)
;
return
true
;
}
Rooted
<
ListObject
*
>
unwrappedPendingPullIntos
(
cx
unwrappedController
-
>
pendingPullIntos
(
)
)
;
if
(
unwrappedPendingPullIntos
-
>
length
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
unwrappedFirstPendingPullInto
(
cx
UnwrapAndDowncastObject
<
PullIntoDescriptor
>
(
cx
&
unwrappedPendingPullIntos
-
>
get
(
0
)
.
toObject
(
)
)
)
;
if
(
!
unwrappedFirstPendingPullInto
)
{
return
false
;
}
if
(
unwrappedFirstPendingPullInto
-
>
bytesFilled
(
)
>
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL
)
;
RootedValue
e
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearExceptionAndStack
(
cx
&
e
&
stack
)
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
unwrappedController
e
)
)
{
return
false
;
}
cx
-
>
setPendingException
(
e
stack
)
;
return
false
;
}
}
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
[
[
nodiscard
]
]
static
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
unwrappedController
)
{
MOZ_ASSERT
(
unwrappedController
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
unwrappedStream
(
cx
unwrappedController
-
>
stream
(
)
)
;
MOZ_ASSERT
(
unwrappedStream
-
>
readable
(
)
)
;
if
(
unwrappedController
-
>
queueTotalSize
(
)
=
=
0
&
&
unwrappedController
-
>
closeRequested
(
)
)
{
ReadableStreamControllerClearAlgorithms
(
unwrappedController
)
;
return
ReadableStreamCloseInternal
(
cx
unwrappedStream
)
;
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
unwrappedController
)
;
}
enum
BYOBRequestSlots
{
BYOBRequestSlot_Controller
BYOBRequestSlot_View
BYOBRequestSlotCount
}
;
[
[
nodiscard
]
]
static
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
unwrappedController
)
{
RootedValue
unwrappedBYOBRequestVal
(
cx
unwrappedController
-
>
byobRequest
(
)
)
;
if
(
unwrappedBYOBRequestVal
.
isUndefined
(
)
)
{
return
true
;
}
RootedNativeObject
unwrappedBYOBRequest
(
cx
UnwrapAndDowncastValue
<
NativeObject
>
(
cx
unwrappedBYOBRequestVal
)
)
;
if
(
!
unwrappedBYOBRequest
)
{
return
false
;
}
unwrappedBYOBRequest
-
>
setFixedSlot
(
BYOBRequestSlot_Controller
UndefinedValue
(
)
)
;
unwrappedBYOBRequest
-
>
setFixedSlot
(
BYOBRequestSlot_View
UndefinedValue
(
)
)
;
unwrappedController
-
>
clearBYOBRequest
(
)
;
return
true
;
}
