#
include
"
builtin
/
Stream
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
enum
StreamSlots
{
StreamSlot_Controller
StreamSlot_Reader
StreamSlot_State
StreamSlot_StoredError
StreamSlotCount
}
;
enum
ReaderSlots
{
ReaderSlot_Stream
ReaderSlot_Requests
ReaderSlot_ClosedPromise
ReaderSlotCount
}
;
enum
ReaderType
{
ReaderType_Default
ReaderType_BYOB
}
;
enum
QueueContainerSlots
{
QueueContainerSlot_Queue
QueueContainerSlot_TotalSize
QueueContainerSlotCount
}
;
enum
ControllerSlots
{
ControllerSlot_Stream
=
QueueContainerSlotCount
ControllerSlot_UnderlyingSource
ControllerSlot_StrategyHWM
ControllerSlot_Flags
ControllerSlotCount
}
;
enum
DefaultControllerSlots
{
DefaultControllerSlot_StrategySize
=
ControllerSlotCount
DefaultControllerSlotCount
}
;
enum
ByteControllerSlots
{
ByteControllerSlot_BYOBRequest
=
ControllerSlotCount
ByteControllerSlot_PendingPullIntos
ByteControllerSlot_AutoAllocateSize
ByteControllerSlotCount
}
;
enum
ControllerFlags
{
ControllerFlag_Started
=
1
<
<
0
ControllerFlag_Pulling
=
1
<
<
1
ControllerFlag_PullAgain
=
1
<
<
2
ControllerFlag_CloseRequested
=
1
<
<
3
ControllerFlag_TeeBranch
=
1
<
<
4
ControllerFlag_TeeBranch1
=
1
<
<
5
ControllerFlag_TeeBranch2
=
1
<
<
6
ControllerFlag_ExternalSource
=
1
<
<
7
ControllerFlag_SourceLocked
=
1
<
<
8
}
;
constexpr
uint8_t
ControllerEmbeddingFlagsOffset
=
24
;
enum
BYOBRequestSlots
{
BYOBRequestSlot_Controller
BYOBRequestSlot_View
BYOBRequestSlotCount
}
;
template
<
class
T
>
bool
Is
(
const
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
T
>
(
)
;
}
template
<
class
T
>
bool
IsMaybeWrapped
(
const
HandleValue
v
)
{
if
(
!
v
.
isObject
(
)
)
{
return
false
;
}
JSObject
*
obj
=
&
v
.
toObject
(
)
;
if
(
obj
-
>
is
<
T
>
(
)
)
{
return
true
;
}
obj
=
CheckedUnwrap
(
obj
)
;
if
(
!
obj
)
{
return
false
;
}
return
obj
-
>
is
<
T
>
(
)
;
}
static
inline
uint32_t
ControllerFlags
(
const
ReadableStreamController
*
controller
)
{
return
controller
-
>
getFixedSlot
(
ControllerSlot_Flags
)
.
toInt32
(
)
;
}
static
inline
void
AddControllerFlags
(
ReadableStreamController
*
controller
uint32_t
flags
)
{
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlags
(
controller
)
|
flags
)
)
;
}
static
inline
void
RemoveControllerFlags
(
ReadableStreamController
*
controller
uint32_t
flags
)
{
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlags
(
controller
)
&
~
flags
)
)
;
}
static
inline
uint32_t
StreamState
(
const
ReadableStream
*
stream
)
{
return
stream
-
>
getFixedSlot
(
StreamSlot_State
)
.
toInt32
(
)
;
}
static
inline
void
SetStreamState
(
ReadableStream
*
stream
uint32_t
state
)
{
MOZ_ASSERT_IF
(
stream
-
>
disturbed
(
)
state
&
ReadableStream
:
:
Disturbed
)
;
MOZ_ASSERT_IF
(
stream
-
>
closed
(
)
|
|
stream
-
>
errored
(
)
!
(
state
&
ReadableStream
:
:
Readable
)
)
;
stream
-
>
setFixedSlot
(
StreamSlot_State
Int32Value
(
state
)
)
;
}
bool
ReadableStream
:
:
readable
(
)
const
{
return
StreamState
(
this
)
&
Readable
;
}
bool
ReadableStream
:
:
closed
(
)
const
{
return
StreamState
(
this
)
&
Closed
;
}
bool
ReadableStream
:
:
errored
(
)
const
{
return
StreamState
(
this
)
&
Errored
;
}
bool
ReadableStream
:
:
disturbed
(
)
const
{
return
StreamState
(
this
)
&
Disturbed
;
}
inline
static
bool
ReaderHasStream
(
const
ReadableStreamReader
*
reader
)
{
return
!
reader
-
>
getFixedSlot
(
ReaderSlot_Stream
)
.
isUndefined
(
)
;
}
bool
js
:
:
ReadableStreamReaderIsClosed
(
const
JSObject
*
reader
)
{
return
!
ReaderHasStream
(
&
reader
-
>
as
<
ReadableStreamReader
>
(
)
)
;
}
inline
static
MOZ_MUST_USE
ReadableStream
*
StreamFromController
(
const
ReadableStreamController
*
controller
)
{
return
&
controller
-
>
getFixedSlot
(
ControllerSlot_Stream
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
;
}
inline
static
MOZ_MUST_USE
ReadableStreamController
*
ControllerFromStream
(
const
ReadableStream
*
stream
)
{
return
&
stream
-
>
getFixedSlot
(
StreamSlot_Controller
)
.
toObject
(
)
.
as
<
ReadableStreamController
>
(
)
;
}
inline
static
bool
HasController
(
const
ReadableStream
*
stream
)
{
return
!
stream
-
>
getFixedSlot
(
StreamSlot_Controller
)
.
isUndefined
(
)
;
}
JS
:
:
ReadableStreamMode
ReadableStream
:
:
mode
(
)
const
{
ReadableStreamController
*
controller
=
ControllerFromStream
(
this
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
return
JS
:
:
ReadableStreamMode
:
:
Default
;
}
return
controller
-
>
as
<
ReadableByteStreamController
>
(
)
.
hasExternalSource
(
)
?
JS
:
:
ReadableStreamMode
:
:
ExternalSource
:
JS
:
:
ReadableStreamMode
:
:
Byte
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
ReadableStreamController
>
(
)
const
{
return
is
<
ReadableStreamDefaultController
>
(
)
|
|
is
<
ReadableByteStreamController
>
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
ReadableStreamReader
>
(
)
const
{
return
is
<
ReadableStreamDefaultReader
>
(
)
;
}
template
<
class
T
>
static
T
*
ToUnwrapped
(
JSContext
*
cx
JSObject
*
obj
)
{
if
(
IsWrapper
(
obj
)
)
{
obj
=
CheckedUnwrap
(
obj
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
return
&
obj
-
>
as
<
T
>
(
)
;
}
template
<
class
T
>
static
T
*
ToUnwrapped
(
JSContext
*
cx
JSObject
*
obj
const
char
*
description
)
{
if
(
IsWrapper
(
obj
)
)
{
obj
=
CheckedUnwrap
(
obj
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
if
(
!
obj
-
>
is
<
T
>
(
)
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_EXPECTED_TYPE
description
T
:
:
class_
-
>
name
InformalValueTypeName
(
ObjectValue
(
*
obj
)
)
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
T
>
(
)
;
}
template
<
class
T
>
static
T
*
ToUnwrapped
(
JSContext
*
cx
JSObject
*
obj
const
char
*
className
const
char
*
methodName
)
{
if
(
IsWrapper
(
obj
)
)
{
obj
=
CheckedUnwrap
(
obj
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
if
(
!
obj
-
>
is
<
T
>
(
)
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
className
methodName
InformalValueTypeName
(
ObjectValue
(
*
obj
)
)
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
T
>
(
)
;
}
template
<
class
T
>
static
T
*
ToUnwrapped
(
JSContext
*
cx
HandleValue
val
const
char
*
className
=
"
"
const
char
*
methodName
=
"
"
)
{
if
(
!
val
.
isObject
(
)
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
className
methodName
InformalValueTypeName
(
val
)
)
;
return
nullptr
;
}
return
ToUnwrapped
<
T
>
(
cx
&
val
.
toObject
(
)
className
methodName
)
;
}
static
MOZ_MUST_USE
ReadableStream
*
StreamFromReader
(
JSContext
*
maybeCx
const
ReadableStreamReader
*
reader
)
{
MOZ_ASSERT
(
ReaderHasStream
(
reader
)
)
;
JSObject
*
streamObj
=
&
reader
-
>
getFixedSlot
(
ReaderSlot_Stream
)
.
toObject
(
)
;
if
(
IsProxy
(
streamObj
)
)
{
if
(
JS_IsDeadWrapper
(
streamObj
)
)
{
if
(
maybeCx
)
{
JS_ReportErrorNumberASCII
(
maybeCx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
}
return
nullptr
;
}
streamObj
=
UncheckedUnwrap
(
streamObj
)
;
}
return
&
streamObj
-
>
as
<
ReadableStream
>
(
)
;
}
static
MOZ_MUST_USE
ReadableStreamReader
*
ReaderFromStream
(
JSContext
*
maybeCx
const
ReadableStream
*
stream
)
{
JSObject
*
readerObj
=
&
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
toObject
(
)
;
if
(
IsProxy
(
readerObj
)
)
{
if
(
JS_IsDeadWrapper
(
readerObj
)
)
{
if
(
maybeCx
)
{
JS_ReportErrorNumberASCII
(
maybeCx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
}
return
nullptr
;
}
readerObj
=
UncheckedUnwrap
(
readerObj
)
;
}
return
&
readerObj
-
>
as
<
ReadableStreamReader
>
(
)
;
}
inline
static
bool
HasReader
(
const
ReadableStream
*
stream
)
{
return
!
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
isUndefined
(
)
;
}
inline
static
MOZ_MUST_USE
JSFunction
*
NewHandler
(
JSContext
*
cx
Native
handler
HandleObject
target
)
{
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
handlerFun
(
cx
NewNativeFunction
(
cx
handler
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
handlerFun
)
{
return
nullptr
;
}
handlerFun
-
>
setExtendedSlot
(
0
ObjectValue
(
*
target
)
)
;
return
handlerFun
;
}
template
<
class
T
>
inline
static
MOZ_MUST_USE
T
*
TargetFromHandler
(
JSObject
&
handler
)
{
return
&
handler
.
as
<
JSFunction
>
(
)
.
getExtendedSlot
(
0
)
.
toObject
(
)
.
as
<
T
>
(
)
;
}
inline
static
MOZ_MUST_USE
bool
ResetQueue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
)
;
inline
static
MOZ_MUST_USE
bool
InvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
MutableHandleValue
rval
)
;
static
MOZ_MUST_USE
JSObject
*
PromiseInvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
)
;
static
MOZ_MUST_USE
JSObject
*
PromiseRejectedWithPendingError
(
JSContext
*
cx
)
{
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
exn
)
;
}
static
void
ReportArgTypeError
(
JSContext
*
cx
const
char
*
funName
const
char
*
expectedType
HandleValue
arg
)
{
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
arg
nullptr
)
;
if
(
!
bytes
)
{
return
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_EXPECTED_TYPE
funName
expectedType
bytes
.
get
(
)
)
;
}
static
MOZ_MUST_USE
bool
ReturnPromiseRejectedWithPendingError
(
JSContext
*
cx
const
CallArgs
&
args
)
{
JSObject
*
promise
=
PromiseRejectedWithPendingError
(
cx
)
;
if
(
!
promise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
promise
)
;
return
true
;
}
inline
static
MOZ_MUST_USE
NativeObject
*
SetNewList
(
JSContext
*
cx
HandleNativeObject
container
uint32_t
slot
)
{
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
container
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ar
.
emplace
(
cx
container
)
;
}
NativeObject
*
list
=
NewList
(
cx
)
;
if
(
!
list
)
{
return
nullptr
;
}
container
-
>
setFixedSlot
(
slot
ObjectValue
(
*
list
)
)
;
return
list
;
}
class
ByteStreamChunk
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Buffer
=
0
Slot_ByteOffset
Slot_ByteLength
SlotCount
}
;
public
:
static
const
Class
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_Buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
uint32_t
byteOffset
(
)
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
void
SetByteOffset
(
uint32_t
offset
)
{
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
offset
)
)
;
}
uint32_t
byteLength
(
)
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
void
SetByteLength
(
uint32_t
length
)
{
setFixedSlot
(
Slot_ByteLength
Int32Value
(
length
)
)
;
}
static
ByteStreamChunk
*
create
(
JSContext
*
cx
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
{
Rooted
<
ByteStreamChunk
*
>
chunk
(
cx
NewBuiltinClassInstance
<
ByteStreamChunk
>
(
cx
)
)
;
if
(
!
chunk
)
{
return
nullptr
;
}
chunk
-
>
setFixedSlot
(
Slot_Buffer
ObjectValue
(
*
buffer
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
return
chunk
;
}
}
;
const
Class
ByteStreamChunk
:
:
class_
=
{
"
ByteStreamChunk
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
PullIntoDescriptor
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_buffer
Slot_ByteOffset
Slot_ByteLength
Slot_BytesFilled
Slot_ElementSize
Slot_Ctor
Slot_ReaderType
SlotCount
}
;
public
:
static
const
Class
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
void
setBuffer
(
ArrayBufferObject
*
buffer
)
{
setFixedSlot
(
Slot_buffer
ObjectValue
(
*
buffer
)
)
;
}
JSObject
*
ctor
(
)
{
return
getFixedSlot
(
Slot_Ctor
)
.
toObjectOrNull
(
)
;
}
uint32_t
byteOffset
(
)
const
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
uint32_t
byteLength
(
)
const
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
uint32_t
bytesFilled
(
)
const
{
return
getFixedSlot
(
Slot_BytesFilled
)
.
toInt32
(
)
;
}
void
setBytesFilled
(
int32_t
bytes
)
{
setFixedSlot
(
Slot_BytesFilled
Int32Value
(
bytes
)
)
;
}
uint32_t
elementSize
(
)
const
{
return
getFixedSlot
(
Slot_ElementSize
)
.
toInt32
(
)
;
}
uint32_t
readerType
(
)
const
{
return
getFixedSlot
(
Slot_ReaderType
)
.
toInt32
(
)
;
}
static
PullIntoDescriptor
*
create
(
JSContext
*
cx
HandleArrayBufferObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
uint32_t
bytesFilled
uint32_t
elementSize
HandleObject
ctor
uint32_t
readerType
)
{
Rooted
<
PullIntoDescriptor
*
>
descriptor
(
cx
NewBuiltinClassInstance
<
PullIntoDescriptor
>
(
cx
)
)
;
if
(
!
descriptor
)
{
return
nullptr
;
}
descriptor
-
>
setFixedSlot
(
Slot_buffer
ObjectValue
(
*
buffer
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_Ctor
ObjectOrNullValue
(
ctor
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_BytesFilled
Int32Value
(
bytesFilled
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ElementSize
Int32Value
(
elementSize
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ReaderType
Int32Value
(
readerType
)
)
;
return
descriptor
;
}
}
;
const
Class
PullIntoDescriptor
:
:
class_
=
{
"
PullIntoDescriptor
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
QueueEntry
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Value
=
0
Slot_Size
SlotCount
}
;
public
:
static
const
Class
class_
;
Value
value
(
)
{
return
getFixedSlot
(
Slot_Value
)
;
}
double
size
(
)
{
return
getFixedSlot
(
Slot_Size
)
.
toNumber
(
)
;
}
static
QueueEntry
*
create
(
JSContext
*
cx
HandleValue
value
double
size
)
{
Rooted
<
QueueEntry
*
>
entry
(
cx
NewBuiltinClassInstance
<
QueueEntry
>
(
cx
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
entry
-
>
setFixedSlot
(
Slot_Value
value
)
;
entry
-
>
setFixedSlot
(
Slot_Size
NumberValue
(
size
)
)
;
return
entry
;
}
}
;
const
Class
QueueEntry
:
:
class_
=
{
"
QueueEntry
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
TeeState
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Flags
=
0
Slot_Reason1
Slot_Reason2
Slot_Promise
Slot_Stream
Slot_Branch1
Slot_Branch2
SlotCount
}
;
enum
Flags
{
Flag_ClosedOrErrored
=
1
<
<
0
Flag_Canceled1
=
1
<
<
1
Flag_Canceled2
=
1
<
<
2
Flag_CloneForBranch2
=
1
<
<
3
}
;
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
Int32Value
(
flags
)
)
;
}
public
:
static
const
Class
class_
;
bool
cloneForBranch2
(
)
const
{
return
flags
(
)
&
Flag_CloneForBranch2
;
}
bool
closedOrErrored
(
)
const
{
return
flags
(
)
&
Flag_ClosedOrErrored
;
}
void
setClosedOrErrored
(
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_ClosedOrErrored
)
)
;
setFlags
(
flags
(
)
|
Flag_ClosedOrErrored
)
;
}
bool
canceled1
(
)
const
{
return
flags
(
)
&
Flag_Canceled1
;
}
void
setCanceled1
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled1
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled1
)
;
setFixedSlot
(
Slot_Reason1
reason
)
;
}
bool
canceled2
(
)
const
{
return
flags
(
)
&
Flag_Canceled2
;
}
void
setCanceled2
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled2
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled2
)
;
setFixedSlot
(
Slot_Reason2
reason
)
;
}
Value
reason1
(
)
const
{
MOZ_ASSERT
(
canceled1
(
)
)
;
return
getFixedSlot
(
Slot_Reason1
)
;
}
Value
reason2
(
)
const
{
MOZ_ASSERT
(
canceled2
(
)
)
;
return
getFixedSlot
(
Slot_Reason2
)
;
}
PromiseObject
*
promise
(
)
{
return
&
getFixedSlot
(
Slot_Promise
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
static
MOZ_MUST_USE
ReadableStream
*
stream
(
JSContext
*
cx
TeeState
*
teeState
)
{
RootedValue
streamVal
(
cx
teeState
-
>
getFixedSlot
(
Slot_Stream
)
)
;
return
ToUnwrapped
<
ReadableStream
>
(
cx
streamVal
)
;
}
ReadableStreamDefaultController
*
branch1
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch1
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch1
)
;
return
controller
;
}
void
setBranch1
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch1
)
;
setFixedSlot
(
Slot_Branch1
ObjectValue
(
*
controller
)
)
;
}
ReadableStreamDefaultController
*
branch2
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch2
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch2
)
;
return
controller
;
}
void
setBranch2
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch2
)
;
setFixedSlot
(
Slot_Branch2
ObjectValue
(
*
controller
)
)
;
}
static
TeeState
*
create
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
TeeState
*
>
state
(
cx
NewBuiltinClassInstance
<
TeeState
>
(
cx
)
)
;
if
(
!
state
)
{
return
nullptr
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
state
-
>
setFixedSlot
(
Slot_Flags
Int32Value
(
0
)
)
;
state
-
>
setFixedSlot
(
Slot_Promise
ObjectValue
(
*
promise
)
)
;
RootedObject
wrappedStream
(
cx
stream
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedStream
)
)
{
return
nullptr
;
}
state
-
>
setFixedSlot
(
Slot_Stream
ObjectValue
(
*
wrappedStream
)
)
;
return
state
;
}
}
;
const
Class
TeeState
:
:
class_
=
{
"
TeeState
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
#
define
CLASS_SPEC
(
cls
nCtorArgs
nSlots
specFlags
classFlags
classOps
)
\
const
ClassSpec
cls
:
:
classSpec_
=
{
\
GenericCreateConstructor
<
cls
:
:
constructor
nCtorArgs
gc
:
:
AllocKind
:
:
FUNCTION
>
\
GenericCreatePrototype
<
cls
>
\
nullptr
\
nullptr
\
cls
#
#
_methods
\
cls
#
#
_properties
\
nullptr
\
specFlags
\
}
;
\
\
const
Class
cls
:
:
class_
=
{
\
#
cls
\
JSCLASS_HAS_RESERVED_SLOTS
(
nSlots
)
|
\
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
cls
)
|
\
classFlags
\
classOps
\
&
cls
:
:
classSpec_
\
}
;
\
\
const
Class
cls
:
:
protoClass_
=
{
\
"
object
"
\
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
cls
)
\
JS_NULL_CLASS_OPS
\
&
cls
:
:
classSpec_
\
}
;
ReadableStream
*
ReadableStream
:
:
createStream
(
JSContext
*
cx
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
NewObjectWithClassProto
<
ReadableStream
>
(
cx
proto
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
stream
-
>
setFixedSlot
(
StreamSlot_State
Int32Value
(
Readable
)
)
;
return
stream
;
}
static
MOZ_MUST_USE
ReadableStreamDefaultController
*
CreateReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMarkVal
)
;
ReadableStream
*
ReadableStream
:
:
createDefaultStream
(
JSContext
*
cx
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMark
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
createStream
(
cx
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
RootedObject
controller
(
cx
CreateReadableStreamDefaultController
(
cx
stream
underlyingSource
size
highWaterMark
)
)
;
if
(
!
controller
)
{
return
nullptr
;
}
stream
-
>
setFixedSlot
(
StreamSlot_Controller
ObjectValue
(
*
controller
)
)
;
return
stream
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
underlyingSource
)
;
ReadableStream
*
ReadableStream
:
:
createExternalSourceStream
(
JSContext
*
cx
void
*
underlyingSource
uint8_t
flags
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
createStream
(
cx
proto
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
Rooted
<
ReadableStreamController
*
>
controller
(
cx
)
;
controller
=
CreateReadableByteStreamController
(
cx
stream
underlyingSource
)
;
if
(
!
controller
)
{
return
nullptr
;
}
stream
-
>
setFixedSlot
(
StreamSlot_Controller
ObjectValue
(
*
controller
)
)
;
AddControllerFlags
(
controller
flags
<
<
ControllerEmbeddingFlagsOffset
)
;
return
stream
;
}
bool
ReadableStream
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
underlyingSource
(
cx
args
.
get
(
0
)
)
;
RootedValue
options
(
cx
args
.
get
(
1
)
)
;
if
(
underlyingSource
.
isUndefined
(
)
)
{
RootedObject
sourceObj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
)
;
if
(
!
sourceObj
)
{
return
false
;
}
underlyingSource
=
ObjectValue
(
*
sourceObj
)
;
}
RootedValue
size
(
cx
)
;
RootedValue
highWaterMark
(
cx
)
;
if
(
!
options
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
options
cx
-
>
names
(
)
.
size
&
size
)
)
{
return
false
;
}
if
(
!
GetProperty
(
cx
options
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
{
return
false
;
}
}
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStream
"
)
)
{
return
false
;
}
RootedValue
typeVal
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingSource
cx
-
>
names
(
)
.
type
&
typeVal
)
)
{
return
false
;
}
RootedString
type
(
cx
ToString
<
CanGC
>
(
cx
typeVal
)
)
;
if
(
!
type
)
{
return
false
;
}
int32_t
notByteStream
;
if
(
!
CompareStrings
(
cx
type
cx
-
>
names
(
)
.
bytes
&
notByteStream
)
)
{
return
false
;
}
if
(
highWaterMark
.
isUndefined
(
)
)
{
highWaterMark
=
Int32Value
(
notByteStream
?
1
:
0
)
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
if
(
!
notByteStream
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_BYTES_TYPE_NOT_IMPLEMENTED
)
;
return
false
;
}
else
if
(
typeVal
.
isUndefined
(
)
)
{
stream
=
createDefaultStream
(
cx
underlyingSource
size
highWaterMark
)
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_UNDERLYINGSOURCE_TYPE_WRONG
)
;
return
false
;
}
if
(
!
stream
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
stream
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStream_locked_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
stream
=
&
UncheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
-
>
as
<
ReadableStream
>
(
)
;
args
.
rval
(
)
.
setBoolean
(
stream
-
>
locked
(
)
)
;
return
true
;
}
static
bool
ReadableStream_locked
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsMaybeWrapped
<
ReadableStream
>
ReadableStream_locked_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStream_cancel
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
stream
=
ToUnwrapped
<
ReadableStream
>
(
cx
args
.
thisv
(
)
"
ReadableStream
"
"
cancel
"
)
;
if
(
!
stream
)
{
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED_METHOD
"
cancel
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
RootedObject
cancelPromise
(
cx
ReadableStream
:
:
cancel
(
cx
stream
args
.
get
(
0
)
)
)
;
if
(
!
cancelPromise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
cancelPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
ReadableStreamDefaultReader
*
CreateReadableStreamDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
;
static
bool
ReadableStream_getReader
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
stream
=
ToUnwrapped
<
ReadableStream
>
(
cx
args
.
thisv
(
)
"
ReadableStream
"
"
getReader
"
)
;
if
(
!
stream
)
{
return
false
;
}
RootedObject
reader
(
cx
)
;
RootedValue
modeVal
(
cx
)
;
HandleValue
optionsVal
=
args
.
get
(
0
)
;
if
(
!
optionsVal
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
optionsVal
cx
-
>
names
(
)
.
mode
&
modeVal
)
)
{
return
false
;
}
}
if
(
modeVal
.
isUndefined
(
)
)
{
reader
=
CreateReadableStreamDefaultReader
(
cx
stream
)
;
}
else
{
RootedString
mode
(
cx
ToString
<
CanGC
>
(
cx
modeVal
)
)
;
if
(
!
mode
)
{
return
false
;
}
int32_t
notByob
;
if
(
!
CompareStrings
(
cx
mode
cx
-
>
names
(
)
.
byob
&
notByob
)
)
{
return
false
;
}
if
(
notByob
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_INVALID_READER_MODE
)
;
return
false
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_BYTES_TYPE_NOT_IMPLEMENTED
)
;
}
if
(
!
reader
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
reader
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamTee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1
MutableHandle
<
ReadableStream
*
>
branch2
)
;
static
bool
ReadableStream_tee
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
stream
=
ToUnwrapped
<
ReadableStream
>
(
cx
args
.
thisv
(
)
"
ReadableStream
"
"
tee
"
)
;
if
(
!
stream
)
{
return
false
;
}
Rooted
<
ReadableStream
*
>
branch1
(
cx
)
;
Rooted
<
ReadableStream
*
>
branch2
(
cx
)
;
if
(
!
ReadableStreamTee
(
cx
stream
false
&
branch1
&
branch2
)
)
{
return
false
;
}
RootedNativeObject
branches
(
cx
NewDenseFullyAllocatedArray
(
cx
2
)
)
;
if
(
!
branches
)
{
return
false
;
}
branches
-
>
setDenseInitializedLength
(
2
)
;
branches
-
>
initDenseElement
(
0
ObjectValue
(
*
branch1
)
)
;
branches
-
>
initDenseElement
(
1
ObjectValue
(
*
branch2
)
)
;
args
.
rval
(
)
.
setObject
(
*
branches
)
;
return
true
;
}
static
const
JSFunctionSpec
ReadableStream_methods
[
]
=
{
JS_FN
(
"
cancel
"
ReadableStream_cancel
1
0
)
JS_FN
(
"
getReader
"
ReadableStream_getReader
0
0
)
JS_FN
(
"
tee
"
ReadableStream_tee
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
ReadableStream_properties
[
]
=
{
JS_PSG
(
"
locked
"
ReadableStream_locked
0
)
JS_PS_END
}
;
CLASS_SPEC
(
ReadableStream
0
StreamSlotCount
0
0
JS_NULL_CLASS_OPS
)
;
bool
ReadableStream
:
:
locked
(
)
const
{
if
(
HasController
(
this
)
&
&
(
ControllerFlags
(
ControllerFromStream
(
this
)
)
&
ControllerFlag_SourceLocked
)
)
{
return
true
;
}
return
HasReader
(
this
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
chunk
)
;
static
bool
TeeReaderReadHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
teeState
(
cx
TargetFromHandler
<
TeeState
>
(
args
.
callee
(
)
)
)
;
HandleValue
resultVal
=
args
.
get
(
0
)
;
RootedObject
result
(
cx
&
resultVal
.
toObject
(
)
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
result
NameToId
(
cx
-
>
names
(
)
.
value
)
value
.
address
(
)
)
)
{
return
false
;
}
RootedValue
doneVal
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
result
NameToId
(
cx
-
>
names
(
)
.
done
)
doneVal
.
address
(
)
)
)
{
return
false
;
}
bool
done
=
doneVal
.
toBoolean
(
)
;
if
(
done
&
&
!
teeState
-
>
closedOrErrored
(
)
)
{
if
(
!
teeState
-
>
canceled1
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
teeState
-
>
branch1
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
branch1
)
)
{
return
false
;
}
}
if
(
!
teeState
-
>
canceled2
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
teeState
-
>
branch2
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
branch2
)
)
{
return
false
;
}
}
teeState
-
>
setClosedOrErrored
(
)
;
}
if
(
teeState
-
>
closedOrErrored
(
)
)
{
return
true
;
}
RootedValue
value1
(
cx
value
)
;
RootedValue
value2
(
cx
value
)
;
MOZ_ASSERT
(
!
teeState
-
>
cloneForBranch2
(
)
"
tee
(
cloneForBranch2
=
true
)
should
not
be
exposed
"
)
;
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
if
(
!
teeState
-
>
canceled1
(
)
)
{
controller
=
teeState
-
>
branch1
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
value1
)
)
{
return
false
;
}
}
if
(
!
teeState
-
>
canceled2
(
)
)
{
controller
=
teeState
-
>
branch2
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
value2
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamTee_Pull
(
JSContext
*
cx
Handle
<
TeeState
*
>
teeState
Handle
<
ReadableStream
*
>
branchStream
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
TeeState
:
:
stream
(
cx
teeState
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
RootedObject
readerObj
(
cx
ReaderFromStream
(
cx
stream
)
)
;
if
(
!
readerObj
)
{
return
nullptr
;
}
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
&
readerObj
-
>
as
<
ReadableStreamDefaultReader
>
(
)
)
;
RootedObject
readPromise
(
cx
ReadableStreamDefaultReader
:
:
read
(
cx
reader
)
)
;
if
(
!
readPromise
)
{
return
nullptr
;
}
RootedObject
onFulfilled
(
cx
NewHandler
(
cx
TeeReaderReadHandler
teeState
)
)
;
if
(
!
onFulfilled
)
{
return
nullptr
;
}
return
JS
:
:
CallOriginalPromiseThen
(
cx
readPromise
onFulfilled
nullptr
)
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamTee_Cancel
(
JSContext
*
cx
Handle
<
TeeState
*
>
teeState
Handle
<
ReadableStreamDefaultController
*
>
branch
HandleValue
reason_
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
TeeState
:
:
stream
(
cx
teeState
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
bool
bothBranchesCanceled
=
false
;
{
RootedValue
reason
(
cx
reason_
)
;
if
(
reason
.
isGCThing
(
)
&
&
reason
.
toGCThing
(
)
-
>
maybeCompartment
(
)
!
=
teeState
-
>
compartment
(
)
)
{
AutoRealm
ar
(
cx
teeState
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason
)
)
{
return
nullptr
;
}
}
if
(
ControllerFlags
(
branch
)
&
ControllerFlag_TeeBranch1
)
{
teeState
-
>
setCanceled1
(
reason
)
;
bothBranchesCanceled
=
teeState
-
>
canceled2
(
)
;
}
else
{
MOZ_ASSERT
(
ControllerFlags
(
branch
)
&
ControllerFlag_TeeBranch2
)
;
teeState
-
>
setCanceled2
(
reason
)
;
bothBranchesCanceled
=
teeState
-
>
canceled1
(
)
;
}
}
if
(
bothBranchesCanceled
)
{
RootedNativeObject
compositeReason
(
cx
NewDenseFullyAllocatedArray
(
cx
2
)
)
;
if
(
!
compositeReason
)
{
return
nullptr
;
}
compositeReason
-
>
setDenseInitializedLength
(
2
)
;
RootedValue
reason1
(
cx
teeState
-
>
reason1
(
)
)
;
RootedValue
reason2
(
cx
teeState
-
>
reason2
(
)
)
;
if
(
teeState
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason1
)
|
|
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason2
)
)
{
return
nullptr
;
}
}
compositeReason
-
>
initDenseElement
(
0
reason1
)
;
compositeReason
-
>
initDenseElement
(
1
reason2
)
;
RootedValue
compositeReasonVal
(
cx
ObjectValue
(
*
compositeReason
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
teeState
-
>
promise
(
)
)
;
RootedObject
cancelResult
(
cx
ReadableStream
:
:
cancel
(
cx
stream
compositeReasonVal
)
)
;
{
AutoRealm
ar
(
cx
promise
)
;
if
(
!
cancelResult
)
{
if
(
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
}
else
{
RootedValue
resultVal
(
cx
ObjectValue
(
*
cancelResult
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
resultVal
)
)
{
return
nullptr
;
}
if
(
!
PromiseObject
:
:
resolve
(
cx
promise
resultVal
)
)
{
return
nullptr
;
}
}
}
}
RootedObject
promise
(
cx
teeState
-
>
promise
(
)
)
;
if
(
promise
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
{
return
nullptr
;
}
}
return
promise
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
e
)
;
static
bool
TeeReaderClosedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
teeState
(
cx
TargetFromHandler
<
TeeState
>
(
args
.
callee
(
)
)
)
;
HandleValue
reason
=
args
.
get
(
0
)
;
if
(
!
teeState
-
>
closedOrErrored
(
)
)
{
teeState
-
>
setClosedOrErrored
(
)
;
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
teeState
-
>
branch1
(
)
)
;
if
(
!
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
branch1
reason
)
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
teeState
-
>
branch2
(
)
)
;
if
(
!
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
branch2
reason
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamTee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1Stream
MutableHandle
<
ReadableStream
*
>
branch2Stream
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
CreateReadableStreamDefaultReader
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
false
;
}
Rooted
<
TeeState
*
>
teeState
(
cx
TeeState
:
:
create
(
cx
stream
)
)
;
if
(
!
teeState
)
{
return
false
;
}
RootedValue
hwmValue
(
cx
NumberValue
(
1
)
)
;
RootedValue
underlyingSource
(
cx
ObjectValue
(
*
teeState
)
)
;
branch1Stream
.
set
(
ReadableStream
:
:
createDefaultStream
(
cx
underlyingSource
UndefinedHandleValue
hwmValue
)
)
;
if
(
!
branch1Stream
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
)
;
branch1
=
&
ControllerFromStream
(
branch1Stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
AddControllerFlags
(
branch1
ControllerFlag_TeeBranch
|
ControllerFlag_TeeBranch1
)
;
teeState
-
>
setBranch1
(
branch1
)
;
branch2Stream
.
set
(
ReadableStream
:
:
createDefaultStream
(
cx
underlyingSource
UndefinedHandleValue
hwmValue
)
)
;
if
(
!
branch2Stream
)
{
return
false
;
}
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
)
;
branch2
=
&
ControllerFromStream
(
branch2Stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
AddControllerFlags
(
branch2
ControllerFlag_TeeBranch
|
ControllerFlag_TeeBranch2
)
;
teeState
-
>
setBranch2
(
branch2
)
;
RootedObject
closedPromise
(
cx
&
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
.
toObject
(
)
)
;
RootedObject
onRejected
(
cx
NewHandler
(
cx
TeeReaderClosedHandler
teeState
)
)
;
if
(
!
onRejected
)
{
return
false
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
closedPromise
nullptr
onRejected
)
)
{
return
false
;
}
return
true
;
}
inline
static
MOZ_MUST_USE
bool
AppendToListAtSlot
(
JSContext
*
cx
HandleNativeObject
container
uint32_t
slot
HandleObject
obj
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamAddReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
ReaderFromStream
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
nullptr
;
}
MOZ_ASSERT_IF
(
reader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
stream
-
>
readable
(
)
)
;
RootedObject
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
AppendToListAtSlot
(
cx
reader
ReaderSlot_Requests
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
HandleValue
reason
)
;
static
bool
ReturnUndefined
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
;
MOZ_MUST_USE
JSObject
*
ReadableStream
:
:
cancel
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
uint32_t
state
=
StreamState
(
stream
)
|
ReadableStream
:
:
Disturbed
;
SetStreamState
(
stream
state
)
;
if
(
stream
-
>
closed
(
)
)
{
return
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
if
(
stream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
ReadableStreamCloseInternal
(
cx
stream
)
)
{
return
nullptr
;
}
Rooted
<
ReadableStreamController
*
>
controller
(
cx
ControllerFromStream
(
stream
)
)
;
RootedObject
sourceCancelPromise
(
cx
)
;
sourceCancelPromise
=
ReadableStreamControllerCancelSteps
(
cx
controller
reason
)
;
if
(
!
sourceCancelPromise
)
{
return
nullptr
;
}
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
returnUndefined
(
cx
NewNativeFunction
(
cx
ReturnUndefined
0
funName
)
)
;
if
(
!
returnUndefined
)
{
return
nullptr
;
}
return
JS
:
:
CallOriginalPromiseThen
(
cx
sourceCancelPromise
returnUndefined
nullptr
)
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
uint32_t
state
=
StreamState
(
stream
)
;
SetStreamState
(
stream
(
state
&
ReadableStream
:
:
Disturbed
)
|
ReadableStream
:
:
Closed
)
;
if
(
!
HasReader
(
stream
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
ReaderFromStream
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
false
;
}
bool
needsWrapping
=
reader
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
;
if
(
reader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
{
RootedValue
val
(
cx
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
)
;
if
(
!
val
.
isUndefined
(
)
)
{
RootedNativeObject
readRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
RootedObject
readRequest
(
cx
)
;
RootedObject
resultObj
(
cx
)
;
RootedValue
resultVal
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
readRequest
=
&
readRequests
-
>
getDenseElement
(
i
)
.
toObject
(
)
;
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readRequest
)
)
{
return
false
;
}
resultObj
=
CreateIterResultObject
(
cx
UndefinedHandleValue
true
)
;
if
(
!
resultObj
)
{
return
false
;
}
resultVal
=
ObjectValue
(
*
resultObj
)
;
if
(
!
ResolvePromise
(
cx
readRequest
resultVal
)
)
{
return
false
;
}
}
reader
-
>
setFixedSlot
(
ReaderSlot_Requests
UndefinedValue
(
)
)
;
}
}
RootedObject
closedPromise
(
cx
&
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
.
toObject
(
)
)
;
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
if
(
!
ResolvePromise
(
cx
closedPromise
UndefinedHandleValue
)
)
{
return
false
;
}
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
&
&
cx
-
>
runtime
(
)
-
>
readableStreamClosedCallback
)
{
AutoRealm
ar
(
cx
stream
)
;
ReadableStreamController
*
controller
=
ControllerFromStream
(
stream
)
;
void
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
cx
-
>
runtime
(
)
-
>
readableStreamClosedCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
ReadableStreamErrorInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
e
)
{
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
uint32_t
state
=
StreamState
(
stream
)
;
SetStreamState
(
stream
(
state
&
ReadableStream
:
:
Disturbed
)
|
ReadableStream
:
:
Errored
)
;
stream
-
>
setFixedSlot
(
StreamSlot_StoredError
e
)
;
if
(
!
HasReader
(
stream
)
)
{
return
true
;
}
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
ReaderFromStream
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
false
;
}
RootedValue
val
(
cx
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
)
;
RootedNativeObject
readRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedObject
readRequest
(
cx
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
val
=
readRequests
-
>
getDenseElement
(
i
)
;
readRequest
=
&
val
.
toObject
(
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readRequest
)
)
{
return
false
;
}
if
(
!
RejectPromise
(
cx
readRequest
e
)
)
{
return
false
;
}
}
if
(
!
SetNewList
(
cx
reader
ReaderSlot_Requests
)
)
{
return
false
;
}
RootedObject
closedPromise
(
cx
&
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
.
toObject
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
if
(
!
RejectPromise
(
cx
closedPromise
e
)
)
{
return
false
;
}
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
&
&
cx
-
>
runtime
(
)
-
>
readableStreamErroredCallback
)
{
AutoRealm
ar
(
cx
stream
)
;
ReadableStreamController
*
controller
=
ControllerFromStream
(
stream
)
;
void
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
RootedValue
error
(
cx
e
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
error
)
)
{
return
false
;
}
cx
-
>
runtime
(
)
-
>
readableStreamErroredCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
error
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamFulfillReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
chunk
bool
done
)
{
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
ReaderFromStream
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
false
;
}
RootedValue
val
(
cx
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
)
;
RootedNativeObject
readIntoRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedObject
readIntoRequest
(
cx
ShiftFromList
<
JSObject
>
(
cx
readIntoRequests
)
)
;
MOZ_ASSERT
(
readIntoRequest
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
readIntoRequest
)
)
{
return
false
;
}
RootedValue
wrappedChunk
(
cx
chunk
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedChunk
)
)
{
return
false
;
}
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
wrappedChunk
done
)
)
;
if
(
!
iterResult
)
{
return
false
;
}
val
=
ObjectValue
(
*
iterResult
)
;
return
ResolvePromise
(
cx
readIntoRequest
val
)
;
}
static
uint32_t
ReadableStreamGetNumReadRequests
(
ReadableStream
*
stream
)
{
if
(
!
HasReader
(
stream
)
)
{
return
0
;
}
JS
:
:
AutoSuppressGCAnalysis
nogc
;
ReadableStreamReader
*
reader
=
ReaderFromStream
(
nullptr
stream
)
;
if
(
!
reader
)
{
return
0
;
}
Value
readRequests
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
return
readRequests
.
toObject
(
)
.
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
;
}
enum
class
ReaderMode
{
None
Default
}
;
#
if
DEBUG
static
MOZ_MUST_USE
bool
ReadableStreamHasDefaultReader
(
JSContext
*
cx
ReadableStream
*
stream
bool
*
result
)
{
if
(
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
isUndefined
(
)
)
{
*
result
=
false
;
return
true
;
}
JSObject
*
readerObj
=
ReaderFromStream
(
cx
stream
)
;
if
(
!
readerObj
)
{
return
false
;
}
*
result
=
readerObj
-
>
is
<
ReadableStreamDefaultReader
>
(
)
;
return
true
;
}
#
endif
static
MOZ_MUST_USE
bool
ReadableStreamGetReaderMode
(
JSContext
*
cx
ReadableStream
*
stream
ReaderMode
*
mode
)
{
if
(
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
isUndefined
(
)
)
{
*
mode
=
ReaderMode
:
:
None
;
return
true
;
}
JSObject
*
readerObj
=
ReaderFromStream
(
cx
stream
)
;
if
(
!
readerObj
)
{
return
false
;
}
*
mode
=
ReaderMode
:
:
Default
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
Handle
<
ReadableStream
*
>
stream
)
;
static
MOZ_MUST_USE
ReadableStreamDefaultReader
*
CreateReadableStreamDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
NewBuiltinClassInstance
<
ReadableStreamDefaultReader
>
(
cx
)
;
if
(
!
reader
)
{
return
nullptr
;
}
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED
)
;
return
nullptr
;
}
if
(
!
ReadableStreamReaderGenericInitialize
(
cx
reader
stream
)
)
{
return
nullptr
;
}
if
(
!
SetNewList
(
cx
reader
ReaderSlot_Requests
)
)
{
return
nullptr
;
}
return
reader
;
}
bool
ReadableStreamDefaultReader
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamDefaultReader
"
)
)
{
return
false
;
}
if
(
!
IsMaybeWrapped
<
ReadableStream
>
(
args
.
get
(
0
)
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultReader
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
CheckedUnwrap
(
&
args
.
get
(
0
)
.
toObject
(
)
)
-
>
as
<
ReadableStream
>
(
)
)
;
RootedObject
reader
(
cx
CreateReadableStreamDefaultReader
(
cx
stream
)
)
;
if
(
!
reader
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
reader
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_closed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
reader
=
ToUnwrapped
<
ReadableStreamDefaultReader
>
(
cx
args
.
thisv
(
)
"
ReadableStreamDefaultReader
"
"
get
closed
"
)
;
if
(
!
reader
)
{
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
RootedValue
closedPromise
(
cx
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
closedPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamReaderGenericCancel
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
HandleValue
reason
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_cancel
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
ToUnwrapped
<
ReadableStreamDefaultReader
>
(
cx
args
.
thisv
(
)
"
ReadableStreamDefaultReader
"
"
cancel
"
)
;
if
(
!
reader
)
{
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
cancel
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
cancelPromise
=
ReadableStreamReaderGenericCancel
(
cx
reader
args
.
get
(
0
)
)
;
if
(
!
cancelPromise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
cancelPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_read
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
ToUnwrapped
<
ReadableStreamDefaultReader
>
(
cx
args
.
thisv
(
)
"
ReadableStreamDefaultReader
"
"
read
"
)
;
if
(
!
reader
)
{
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
read
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
readPromise
=
ReadableStreamDefaultReader
:
:
read
(
cx
reader
)
;
if
(
!
readPromise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
readPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
)
;
static
bool
ReadableStreamDefaultReader_releaseLock_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
&
UncheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
-
>
as
<
ReadableStreamDefaultReader
>
(
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Value
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
if
(
!
val
.
isUndefined
(
)
)
{
NativeObject
*
readRequests
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
if
(
len
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_EMPTY
"
releaseLock
"
)
;
return
false
;
}
}
return
ReadableStreamReaderGenericRelease
(
cx
reader
)
;
}
static
bool
ReadableStreamDefaultReader_releaseLock
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsMaybeWrapped
<
ReadableStreamDefaultReader
>
ReadableStreamDefaultReader_releaseLock_impl
>
(
cx
args
)
;
}
static
const
JSFunctionSpec
ReadableStreamDefaultReader_methods
[
]
=
{
JS_FN
(
"
cancel
"
ReadableStreamDefaultReader_cancel
1
0
)
JS_FN
(
"
read
"
ReadableStreamDefaultReader_read
0
0
)
JS_FN
(
"
releaseLock
"
ReadableStreamDefaultReader_releaseLock
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
ReadableStreamDefaultReader_properties
[
]
=
{
JS_PSG
(
"
closed
"
ReadableStreamDefaultReader_closed
0
)
JS_PS_END
}
;
const
Class
ReadableStreamReader
:
:
class_
=
{
"
ReadableStreamReader
"
}
;
CLASS_SPEC
(
ReadableStreamDefaultReader
1
ReaderSlotCount
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamReaderGenericCancel
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
HandleValue
reason
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
cx
reader
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
return
ReadableStream
:
:
cancel
(
cx
stream
reason
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
Handle
<
ReadableStream
*
>
stream
)
{
if
(
!
IsObjectInContextCompartment
(
stream
cx
)
)
{
RootedObject
wrappedStream
(
cx
stream
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedStream
)
)
{
return
false
;
}
reader
-
>
setFixedSlot
(
ReaderSlot_Stream
ObjectValue
(
*
wrappedStream
)
)
;
AutoRealm
ar
(
cx
stream
)
;
RootedObject
wrappedReader
(
cx
reader
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReader
)
)
{
return
false
;
}
stream
-
>
setFixedSlot
(
StreamSlot_Reader
ObjectValue
(
*
wrappedReader
)
)
;
}
else
{
reader
-
>
setFixedSlot
(
ReaderSlot_Stream
ObjectValue
(
*
stream
)
)
;
stream
-
>
setFixedSlot
(
StreamSlot_Reader
ObjectValue
(
*
reader
)
)
;
}
RootedObject
promise
(
cx
)
;
if
(
stream
-
>
readable
(
)
)
{
promise
=
PromiseObject
:
:
createSkippingExecutor
(
cx
)
;
}
else
if
(
stream
-
>
closed
(
)
)
{
promise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
MOZ_ASSERT
(
stream
-
>
errored
(
)
)
;
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
false
;
}
promise
=
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
promise
)
{
return
false
;
}
reader
-
>
setFixedSlot
(
ReaderSlot_ClosedPromise
ObjectValue
(
*
promise
)
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
Handle
<
ReadableStreamReader
*
>
reader
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
cx
reader
)
)
;
if
(
!
stream
)
{
return
false
;
}
MOZ_ASSERT
(
ReaderFromStream
(
cx
stream
)
=
=
reader
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_RELEASED
)
;
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
{
return
false
;
}
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
stream
-
>
readable
(
)
)
{
Value
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
;
Rooted
<
PromiseObject
*
>
closedPromise
(
cx
&
val
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
if
(
closedPromise
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ar
.
emplace
(
cx
closedPromise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
exn
)
)
{
return
false
;
}
}
if
(
!
PromiseObject
:
:
reject
(
cx
closedPromise
exn
)
)
{
return
false
;
}
}
else
{
RootedObject
closedPromise
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
exn
)
)
;
if
(
!
closedPromise
)
{
return
false
;
}
if
(
reader
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ar
.
emplace
(
cx
reader
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
closedPromise
)
)
{
return
false
;
}
}
reader
-
>
setFixedSlot
(
ReaderSlot_ClosedPromise
ObjectValue
(
*
closedPromise
)
)
;
}
stream
-
>
setFixedSlot
(
StreamSlot_Reader
UndefinedValue
(
)
)
;
reader
-
>
setFixedSlot
(
ReaderSlot_Stream
UndefinedValue
(
)
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
;
MOZ_MUST_USE
JSObject
*
ReadableStreamDefaultReader
:
:
read
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultReader
*
>
reader
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
cx
reader
)
)
;
if
(
!
stream
)
{
return
nullptr
;
}
SetStreamState
(
stream
StreamState
(
stream
)
|
ReadableStream
:
:
Disturbed
)
;
if
(
stream
-
>
closed
(
)
)
{
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
UndefinedHandleValue
true
)
)
;
if
(
!
iterResult
)
{
return
nullptr
;
}
RootedValue
iterResultVal
(
cx
ObjectValue
(
*
iterResult
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
iterResultVal
)
;
}
if
(
stream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
storedError
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
ControllerFromStream
(
stream
)
)
;
return
ReadableStreamControllerPullSteps
(
cx
controller
)
;
}
static
bool
ControllerStartHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
)
;
controller
=
TargetFromHandler
<
ReadableStreamController
>
(
args
.
callee
(
)
)
;
AddControllerFlags
(
controller
ControllerFlag_Started
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
(
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
)
)
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamControllerError
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
HandleValue
e
)
;
static
bool
ControllerStartFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
ReadableStreamController
*
>
controllerObj
(
cx
)
;
controllerObj
=
TargetFromHandler
<
ReadableStreamController
>
(
args
.
callee
(
)
)
;
if
(
controllerObj
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
controller
args
.
get
(
0
)
)
;
}
if
(
StreamFromController
(
controllerObj
)
-
>
readable
(
)
)
{
return
ReadableStreamControllerError
(
cx
controllerObj
args
.
get
(
0
)
)
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeHighWaterMark
(
JSContext
*
cx
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
;
static
MOZ_MUST_USE
bool
ValidateAndNormalizeQueuingStrategy
(
JSContext
*
cx
HandleValue
size
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
;
static
MOZ_MUST_USE
ReadableStreamDefaultController
*
CreateReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMarkVal
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableStreamDefaultController
>
(
cx
)
;
if
(
!
controller
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
underlyingSource
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
0
)
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeQueuingStrategy
(
cx
size
highWaterMarkVal
&
highWaterMark
)
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
DefaultControllerSlot_StrategySize
size
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
NumberValue
(
highWaterMark
)
)
;
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
nullptr
;
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
nullptr
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
nullptr
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
nullptr
;
}
return
controller
;
}
bool
ReadableStreamDefaultController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamDefaultController
"
)
)
{
return
false
;
}
HandleValue
streamVal
=
args
.
get
(
0
)
;
if
(
!
Is
<
ReadableStream
>
(
streamVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultController
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
streamVal
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
if
(
HasController
(
stream
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_CONTROLLER_SET
)
;
return
false
;
}
RootedObject
controller
(
cx
CreateReadableStreamDefaultController
(
cx
stream
args
.
get
(
1
)
args
.
get
(
2
)
args
.
get
(
3
)
)
)
;
if
(
!
controller
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
controller
)
;
return
true
;
}
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
ReadableStreamController
*
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamController_desiredSize_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamController
>
(
)
;
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
stream
-
>
errored
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
if
(
stream
-
>
closed
(
)
)
{
args
.
rval
(
)
.
setInt32
(
0
)
;
return
true
;
}
args
.
rval
(
)
.
setNumber
(
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_desiredSize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultController
>
ReadableStreamController_desiredSize_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
VerifyControllerStateForClosing
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
close
"
)
;
return
false
;
}
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
close
"
)
;
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_close_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
UncheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
!
VerifyControllerStateForClosing
(
cx
controller
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerClose
(
cx
controller
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_close
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsMaybeWrapped
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_close_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_enqueue_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
UncheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
enqueue
"
)
;
return
false
;
}
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
enqueue
"
)
;
return
false
;
}
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_enqueue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsMaybeWrapped
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_enqueue_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_error_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
UncheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
error
"
)
;
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
args
.
get
(
0
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_error
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsMaybeWrapped
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_error_impl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
ReadableStreamDefaultController_properties
[
]
=
{
JS_PSG
(
"
desiredSize
"
ReadableStreamDefaultController_desiredSize
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamDefaultController_methods
[
]
=
{
JS_FN
(
"
close
"
ReadableStreamDefaultController_close
0
0
)
JS_FN
(
"
enqueue
"
ReadableStreamDefaultController_enqueue
1
0
)
JS_FN
(
"
error
"
ReadableStreamDefaultController_error
1
0
)
JS_FS_END
}
;
const
Class
ReadableStreamController
:
:
class_
=
{
"
ReadableStreamController
"
}
;
CLASS_SPEC
(
ReadableStreamDefaultController
4
7
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
HandleValue
reason
)
{
AssertSameCompartment
(
cx
reason
)
;
if
(
!
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Value
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
PullIntoDescriptor
*
descriptor
;
descriptor
=
ToUnwrapped
<
PullIntoDescriptor
>
(
cx
PeekList
<
JSObject
>
(
pendingPullIntos
)
)
;
if
(
!
descriptor
)
{
return
nullptr
;
}
descriptor
-
>
setBytesFilled
(
0
)
;
}
}
RootedValue
underlyingSource
(
cx
)
;
underlyingSource
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
nullptr
;
}
if
(
IsMaybeWrapped
<
TeeState
>
(
underlyingSource
)
)
{
Rooted
<
TeeState
*
>
teeState
(
cx
)
;
teeState
=
&
UncheckedUnwrap
(
&
underlyingSource
.
toObject
(
)
)
-
>
as
<
TeeState
>
(
)
;
Rooted
<
ReadableStreamDefaultController
*
>
defaultController
(
cx
)
;
defaultController
=
&
controller
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamTee_Cancel
(
cx
teeState
defaultController
reason
)
;
}
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_ExternalSource
)
{
bool
needsWrapping
=
controller
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
;
RootedValue
rval
(
cx
)
;
{
RootedValue
wrappedReason
(
cx
reason
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
needsWrapping
)
{
ar
.
emplace
(
cx
controller
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedReason
)
)
{
return
nullptr
;
}
}
void
*
source
=
underlyingSource
.
toPrivate
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
rval
=
cx
-
>
runtime
(
)
-
>
readableStreamCancelCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
wrappedReason
)
;
}
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
rval
)
)
{
return
nullptr
;
}
return
PromiseObject
:
:
unforgeableResolve
(
cx
rval
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
underlyingSource
)
)
{
return
nullptr
;
}
return
PromiseInvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
cancel
reason
)
;
}
inline
static
MOZ_MUST_USE
bool
DequeueValue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
MutableHandleValue
chunk
)
;
static
JSObject
*
ReadableStreamDefaultControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
RootedNativeObject
queue
(
cx
)
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
if
(
val
.
isObject
(
)
)
{
queue
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
}
if
(
queue
&
&
queue
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
RootedValue
chunk
(
cx
)
;
if
(
!
DequeueValue
(
cx
controller
&
chunk
)
)
{
return
nullptr
;
}
bool
closeRequested
=
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
;
if
(
closeRequested
&
&
queue
-
>
getDenseInitializedLength
(
)
=
=
0
)
{
if
(
!
ReadableStreamCloseInternal
(
cx
stream
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
nullptr
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
chunk
)
)
{
return
nullptr
;
}
RootedObject
iterResultObj
(
cx
CreateIterResultObject
(
cx
chunk
false
)
)
;
if
(
!
iterResultObj
)
{
return
nullptr
;
}
RootedValue
iterResult
(
cx
ObjectValue
(
*
iterResultObj
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
iterResult
)
;
}
RootedObject
pendingPromise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
stream
)
)
;
if
(
!
pendingPromise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
nullptr
;
}
return
pendingPromise
;
}
static
bool
ControllerPullHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
controllerVal
(
cx
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
.
getExtendedSlot
(
0
)
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
)
;
controller
=
ToUnwrapped
<
ReadableStreamController
>
(
cx
controllerVal
)
;
if
(
!
controller
)
{
return
false
;
}
uint32_t
flags
=
ControllerFlags
(
controller
)
;
RemoveControllerFlags
(
controller
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
;
if
(
flags
&
ControllerFlag_PullAgain
)
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ControllerPullFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
e
=
args
.
get
(
0
)
;
RootedValue
controllerVal
(
cx
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
.
getExtendedSlot
(
0
)
)
;
Rooted
<
ReadableStreamController
*
>
controller
(
cx
)
;
controller
=
ToUnwrapped
<
ReadableStreamController
>
(
cx
controllerVal
)
;
if
(
!
controller
)
{
return
false
;
}
if
(
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
controller
)
;
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
ReadableStreamController
*
controller
)
;
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
bool
shouldPull
=
ReadableStreamControllerShouldCallPull
(
controller
)
;
if
(
!
shouldPull
)
{
return
true
;
}
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_Pulling
)
{
AddControllerFlags
(
controller
ControllerFlag_PullAgain
)
;
return
true
;
}
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_PullAgain
)
)
;
AddControllerFlags
(
controller
ControllerFlag_Pulling
)
;
RootedObject
wrappedController
(
cx
controller
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedController
)
)
{
return
false
;
}
RootedValue
controllerVal
(
cx
ObjectValue
(
*
wrappedController
)
)
;
RootedValue
underlyingSource
(
cx
)
;
underlyingSource
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
RootedObject
pullPromise
(
cx
)
;
if
(
IsMaybeWrapped
<
TeeState
>
(
underlyingSource
)
)
{
Rooted
<
TeeState
*
>
teeState
(
cx
)
;
teeState
=
&
UncheckedUnwrap
(
&
underlyingSource
.
toObject
(
)
)
-
>
as
<
TeeState
>
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
pullPromise
=
ReadableStreamTee_Pull
(
cx
teeState
stream
)
;
}
else
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_ExternalSource
)
{
void
*
source
=
underlyingSource
.
toPrivate
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
cx
-
>
runtime
(
)
-
>
readableStreamDataRequestCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
desiredSize
)
;
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
pullPromise
=
PromiseInvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
pull
controllerVal
)
;
}
if
(
!
pullPromise
)
{
return
false
;
}
RootedObject
onPullFulfilled
(
cx
NewHandler
(
cx
ControllerPullHandler
wrappedController
)
)
;
if
(
!
onPullFulfilled
)
{
return
false
;
}
RootedObject
onPullRejected
(
cx
NewHandler
(
cx
ControllerPullFailedHandler
wrappedController
)
)
;
if
(
!
onPullRejected
)
{
return
false
;
}
return
JS
:
:
AddPromiseReactions
(
cx
pullPromise
onPullFulfilled
onPullRejected
)
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
ReadableStreamController
*
controller
)
{
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
{
return
false
;
}
uint32_t
flags
=
ControllerFlags
(
controller
)
;
if
(
flags
&
ControllerFlag_CloseRequested
)
{
return
false
;
}
if
(
!
(
flags
&
ControllerFlag_Started
)
)
{
return
false
;
}
if
(
stream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
return
true
;
}
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
return
desiredSize
>
0
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
AddControllerFlags
(
controller
ControllerFlag_CloseRequested
)
;
RootedNativeObject
queue
(
cx
)
;
queue
=
&
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
if
(
queue
-
>
getDenseInitializedLength
(
)
=
=
0
)
{
return
ReadableStreamCloseInternal
(
cx
stream
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
EnqueueValueWithSize
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
HandleValue
value
HandleValue
sizeVal
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
chunk
)
{
AssertSameCompartment
(
cx
chunk
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
if
(
stream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
chunk
false
)
)
{
return
false
;
}
}
else
{
RootedValue
chunkSize
(
cx
NumberValue
(
1
)
)
;
bool
success
=
true
;
RootedValue
strategySize
(
cx
)
;
strategySize
=
controller
-
>
getFixedSlot
(
DefaultControllerSlot_StrategySize
)
;
if
(
!
strategySize
.
isUndefined
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
strategySize
)
)
{
return
false
;
}
success
=
Call
(
cx
strategySize
UndefinedHandleValue
chunk
&
chunkSize
)
;
}
if
(
success
)
{
success
=
EnqueueValueWithSize
(
cx
controller
chunk
chunkSize
)
;
}
if
(
!
success
)
{
RootedValue
exn
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
exn
)
)
{
return
false
;
}
if
(
!
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
controller
exn
)
)
{
return
false
;
}
return
false
;
}
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamControllerError
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
HandleValue
e
)
{
AssertSameCompartment
(
cx
e
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
if
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
{
Rooted
<
ReadableByteStreamController
*
>
byteStreamController
(
cx
)
;
byteStreamController
=
&
controller
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
byteStreamController
)
)
{
return
false
;
}
}
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
false
;
}
return
ReadableStreamErrorInternal
(
cx
stream
e
)
;
}
inline
static
double
QueueSize
(
const
NativeObject
*
container
)
;
inline
static
void
SetQueueSize
(
NativeObject
*
container
double
size
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
e
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
if
(
stream
-
>
readable
(
)
)
{
return
ReadableStreamControllerError
(
cx
controller
e
)
;
}
return
true
;
}
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
ReadableStreamController
*
controller
)
{
#
if
DEBUG
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
MOZ_ASSERT
(
!
(
stream
-
>
errored
(
)
|
|
stream
-
>
closed
(
)
)
)
;
#
endif
double
strategyHWM
=
controller
-
>
getFixedSlot
(
ControllerSlot_StrategyHWM
)
.
toNumber
(
)
;
double
queueSize
=
QueueSize
(
controller
)
;
return
strategyHWM
-
queueSize
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingByteSource
HandleValue
highWaterMarkVal
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
;
if
(
!
controller
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
underlyingByteSource
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
0
)
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
controller
)
)
{
return
nullptr
;
}
if
(
!
ResetQueue
(
cx
controller
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
ControllerFlags
(
controller
)
=
=
0
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
&
highWaterMark
)
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
NumberValue
(
highWaterMark
)
)
;
RootedValue
autoAllocateChunkSize
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
autoAllocateChunkSize
&
autoAllocateChunkSize
)
)
{
return
nullptr
;
}
if
(
!
autoAllocateChunkSize
.
isUndefined
(
)
)
{
if
(
!
IsInteger
(
autoAllocateChunkSize
)
|
|
autoAllocateChunkSize
.
toNumber
(
)
<
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE
)
;
return
nullptr
;
}
}
controller
-
>
setFixedSlot
(
ByteControllerSlot_AutoAllocateSize
autoAllocateChunkSize
)
;
if
(
!
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
)
{
return
nullptr
;
}
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
{
return
nullptr
;
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
{
return
nullptr
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
nullptr
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
nullptr
;
}
return
controller
;
}
bool
ReadableByteStreamController
:
:
hasExternalSource
(
)
{
return
ControllerFlags
(
this
)
&
ControllerFlag_ExternalSource
;
}
bool
ReadableByteStreamController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableByteStreamController
"
)
)
{
return
false
;
}
HandleValue
streamVal
=
args
.
get
(
0
)
;
if
(
!
Is
<
ReadableStream
>
(
streamVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultController
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
streamVal
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
if
(
HasController
(
stream
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_CONTROLLER_SET
)
;
return
false
;
}
RootedObject
controller
(
cx
CreateReadableByteStreamController
(
cx
stream
args
.
get
(
1
)
args
.
get
(
2
)
)
)
;
if
(
!
controller
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
controller
)
;
return
true
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
underlyingSource
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
;
if
(
!
controller
)
{
return
nullptr
;
}
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
PrivateValue
(
underlyingSource
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlag_ExternalSource
)
)
;
SetQueueSize
(
controller
0
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
Int32Value
(
0
)
)
;
if
(
!
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
)
{
return
nullptr
;
}
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
)
;
if
(
!
startPromise
)
{
return
nullptr
;
}
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
{
return
nullptr
;
}
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
{
return
nullptr
;
}
return
controller
;
}
static
const
JSPropertySpec
ReadableByteStreamController_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableByteStreamController_methods
[
]
=
{
JS_FS_END
}
;
static
void
ReadableByteStreamControllerFinalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
ReadableByteStreamController
&
controller
=
obj
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
controller
.
getFixedSlot
(
ControllerSlot_Flags
)
.
isUndefined
(
)
)
{
return
;
}
uint32_t
flags
=
ControllerFlags
(
&
controller
)
;
if
(
!
(
flags
&
ControllerFlag_ExternalSource
)
)
{
return
;
}
uint8_t
embeddingFlags
=
flags
>
>
ControllerEmbeddingFlagsOffset
;
void
*
underlyingSource
=
controller
.
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
obj
-
>
runtimeFromAnyThread
(
)
-
>
readableStreamFinalizeCallback
(
underlyingSource
embeddingFlags
)
;
}
static
const
ClassOps
ReadableByteStreamControllerClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ReadableByteStreamControllerFinalize
nullptr
nullptr
nullptr
nullptr
}
;
CLASS_SPEC
(
ReadableByteStreamController
3
9
ClassSpec
:
:
DontDefineConstructor
JSCLASS_BACKGROUND_FINALIZE
&
ReadableByteStreamControllerClassOps
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
#
ifdef
DEBUG
bool
result
;
if
(
!
ReadableStreamHasDefaultReader
(
cx
stream
&
result
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
result
)
;
#
endif
RootedValue
val
(
cx
)
;
double
queueTotalSize
=
QueueSize
(
controller
)
;
if
(
queueTotalSize
>
0
)
{
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
;
RootedObject
view
(
cx
)
;
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
val
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
void
*
underlyingSource
=
val
.
toPrivate
(
)
;
view
=
JS_NewUint8Array
(
cx
queueTotalSize
)
;
if
(
!
view
)
{
return
nullptr
;
}
size_t
bytesWritten
;
{
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
void
*
buffer
=
JS_GetArrayBufferViewData
(
view
&
dummy
noGC
)
;
auto
cb
=
cx
-
>
runtime
(
)
-
>
readableStreamWriteIntoReadRequestCallback
;
MOZ_ASSERT
(
cb
)
;
cb
(
cx
stream
underlyingSource
stream
-
>
embeddingFlags
(
)
buffer
queueTotalSize
&
bytesWritten
)
;
}
queueTotalSize
=
queueTotalSize
-
bytesWritten
;
}
else
{
val
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
entry
(
cx
)
;
entry
=
ToUnwrapped
<
ByteStreamChunk
>
(
cx
ShiftFromList
<
JSObject
>
(
cx
queue
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
queueTotalSize
=
queueTotalSize
-
entry
-
>
byteLength
(
)
;
RootedObject
buffer
(
cx
entry
-
>
buffer
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
buffer
)
)
{
return
nullptr
;
}
uint32_t
byteOffset
=
entry
-
>
byteOffset
(
)
;
view
=
JS_NewUint8ArrayWithBuffer
(
cx
buffer
byteOffset
entry
-
>
byteLength
(
)
)
;
if
(
!
view
)
{
return
nullptr
;
}
}
SetQueueSize
(
controller
queueTotalSize
)
;
if
(
!
ReadableByteStreamControllerHandleQueueDrain
(
cx
controller
)
)
{
return
nullptr
;
}
val
.
setObject
(
*
view
)
;
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
val
false
)
)
;
if
(
!
iterResult
)
{
return
nullptr
;
}
val
.
setObject
(
*
iterResult
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
val
)
;
}
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_AutoAllocateSize
)
;
if
(
!
val
.
isUndefined
(
)
)
{
double
autoAllocateChunkSize
=
val
.
toNumber
(
)
;
RootedObject
bufferObj
(
cx
JS_NewArrayBuffer
(
cx
autoAllocateChunkSize
)
)
;
if
(
!
bufferObj
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
RootedArrayBufferObject
buffer
(
cx
&
bufferObj
-
>
as
<
ArrayBufferObject
>
(
)
)
;
RootedObject
pullIntoDescriptor
(
cx
)
;
pullIntoDescriptor
=
PullIntoDescriptor
:
:
create
(
cx
buffer
0
autoAllocateChunkSize
0
1
nullptr
ReaderType_Default
)
;
if
(
!
pullIntoDescriptor
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
if
(
!
AppendToListAtSlot
(
cx
controller
ByteControllerSlot_PendingPullIntos
pullIntoDescriptor
)
)
{
return
nullptr
;
}
}
RootedObject
promise
(
cx
ReadableStreamAddReadOrReadIntoRequest
(
cx
stream
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
{
return
nullptr
;
}
return
promise
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerPullSteps
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
return
ReadableStreamDefaultControllerPullSteps
(
cx
controller
)
;
}
return
ReadableByteStreamControllerPullSteps
(
cx
controller
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
if
(
!
ReadableByteStreamControllerInvalidateBYOBRequest
(
cx
controller
)
)
{
return
false
;
}
return
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClose
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
double
queueTotalSize
=
QueueSize
(
controller
)
;
if
(
queueTotalSize
>
0
)
{
AddControllerFlags
(
controller
ControllerFlag_CloseRequested
)
;
return
true
;
}
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
firstPendingPullInto
(
cx
)
;
firstPendingPullInto
=
ToUnwrapped
<
PullIntoDescriptor
>
(
cx
PeekList
<
JSObject
>
(
pendingPullIntos
)
)
;
if
(
!
firstPendingPullInto
)
{
return
false
;
}
if
(
firstPendingPullInto
-
>
bytesFilled
(
)
>
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL
)
;
RootedValue
e
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
e
)
)
{
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
{
return
false
;
}
return
false
;
}
}
return
ReadableStreamCloseInternal
(
cx
stream
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
double
totalSize
=
QueueSize
(
controller
)
;
bool
closeRequested
=
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
;
if
(
totalSize
=
=
0
&
&
closeRequested
)
{
return
ReadableStreamCloseInternal
(
cx
stream
)
;
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerInvalidateBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
RootedValue
byobRequestVal
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_BYOBRequest
)
)
;
if
(
byobRequestVal
.
isUndefined
(
)
)
{
return
true
;
}
RootedNativeObject
byobRequest
(
cx
ToUnwrapped
<
NativeObject
>
(
cx
byobRequestVal
)
)
;
if
(
!
byobRequest
)
{
return
false
;
}
byobRequest
-
>
setFixedSlot
(
BYOBRequestSlot_Controller
UndefinedValue
(
)
)
;
byobRequest
-
>
setFixedSlot
(
BYOBRequestSlot_View
UndefinedValue
(
)
)
;
controller
-
>
setFixedSlot
(
ByteControllerSlot_BYOBRequest
UndefinedValue
(
)
)
;
return
true
;
}
bool
js
:
:
ByteLengthQueuingStrategy
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
strategy
(
cx
NewBuiltinClassInstance
<
ByteLengthQueuingStrategy
>
(
cx
)
)
;
if
(
!
strategy
)
{
return
false
;
}
RootedObject
argObj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
argObj
)
{
return
false
;
}
RootedValue
highWaterMark
(
cx
)
;
if
(
!
GetProperty
(
cx
argObj
argObj
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
{
return
false
;
}
if
(
!
SetProperty
(
cx
strategy
cx
-
>
names
(
)
.
highWaterMark
highWaterMark
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
strategy
)
;
return
true
;
}
bool
ByteLengthQueuingStrategy_size
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
GetProperty
(
cx
args
.
get
(
0
)
cx
-
>
names
(
)
.
byteLength
args
.
rval
(
)
)
;
}
static
const
JSPropertySpec
ByteLengthQueuingStrategy_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
ByteLengthQueuingStrategy_methods
[
]
=
{
JS_FN
(
"
size
"
ByteLengthQueuingStrategy_size
1
0
)
JS_FS_END
}
;
CLASS_SPEC
(
ByteLengthQueuingStrategy
1
0
0
0
JS_NULL_CLASS_OPS
)
;
bool
js
:
:
CountQueuingStrategy
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
CountQueuingStrategy
*
>
strategy
(
cx
NewBuiltinClassInstance
<
CountQueuingStrategy
>
(
cx
)
)
;
if
(
!
strategy
)
{
return
false
;
}
RootedObject
argObj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
argObj
)
{
return
false
;
}
RootedValue
highWaterMark
(
cx
)
;
if
(
!
GetProperty
(
cx
argObj
argObj
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
{
return
false
;
}
if
(
!
SetProperty
(
cx
strategy
cx
-
>
names
(
)
.
highWaterMark
highWaterMark
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
strategy
)
;
return
true
;
}
bool
CountQueuingStrategy_size
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setInt32
(
1
)
;
return
true
;
}
static
const
JSPropertySpec
CountQueuingStrategy_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
CountQueuingStrategy_methods
[
]
=
{
JS_FN
(
"
size
"
CountQueuingStrategy_size
0
0
)
JS_FS_END
}
;
CLASS_SPEC
(
CountQueuingStrategy
1
0
0
0
JS_NULL_CLASS_OPS
)
;
#
undef
CLASS_SPEC
inline
static
MOZ_MUST_USE
bool
DequeueValue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
MutableHandleValue
chunk
)
{
RootedValue
val
(
cx
container
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
queue
-
>
getDenseInitializedLength
(
)
>
0
)
;
Rooted
<
QueueEntry
*
>
pair
(
cx
ShiftFromList
<
QueueEntry
>
(
cx
queue
)
)
;
MOZ_ASSERT
(
pair
)
;
double
totalSize
=
QueueSize
(
container
)
;
totalSize
-
=
pair
-
>
size
(
)
;
if
(
totalSize
<
0
)
{
totalSize
=
0
;
}
SetQueueSize
(
container
totalSize
)
;
val
=
pair
-
>
value
(
)
;
if
(
container
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
val
)
)
{
return
false
;
}
chunk
.
set
(
val
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
EnqueueValueWithSize
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
HandleValue
value
HandleValue
sizeVal
)
{
double
size
;
if
(
!
ToNumber
(
cx
sizeVal
&
size
)
)
{
return
false
;
}
if
(
size
<
0
|
|
mozilla
:
:
IsNaN
(
size
)
|
|
mozilla
:
:
IsInfinite
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE
"
size
"
)
;
return
false
;
}
RootedValue
val
(
cx
container
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedValue
wrappedVal
(
cx
value
)
;
{
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
container
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ar
.
emplace
(
cx
container
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedVal
)
)
{
return
false
;
}
}
QueueEntry
*
entry
=
QueueEntry
:
:
create
(
cx
wrappedVal
size
)
;
if
(
!
entry
)
{
return
false
;
}
val
=
ObjectValue
(
*
entry
)
;
if
(
!
AppendToList
(
cx
queue
val
)
)
{
return
false
;
}
}
SetQueueSize
(
container
QueueSize
(
container
)
+
size
)
;
return
true
;
}
inline
static
MOZ_MUST_USE
bool
ResetQueue
(
JSContext
*
cx
Handle
<
ReadableStreamController
*
>
container
)
{
if
(
!
SetNewList
(
cx
container
QueueContainerSlot_Queue
)
)
{
return
false
;
}
SetQueueSize
(
container
0
)
;
return
true
;
}
inline
static
double
QueueSize
(
const
NativeObject
*
container
)
{
return
container
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
}
inline
static
void
SetQueueSize
(
NativeObject
*
container
double
size
)
{
container
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
size
)
)
;
}
inline
static
MOZ_MUST_USE
bool
AppendToListAtSlot
(
JSContext
*
cx
HandleNativeObject
container
uint32_t
slot
HandleObject
obj
)
{
RootedValue
val
(
cx
container
-
>
getFixedSlot
(
slot
)
)
;
RootedNativeObject
list
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
ObjectValue
(
*
obj
)
;
AutoRealm
ar
(
cx
list
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
val
)
)
{
return
false
;
}
return
AppendToList
(
cx
list
val
)
;
}
inline
static
MOZ_MUST_USE
bool
InvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
MutableHandleValue
rval
)
{
RootedValue
method
(
cx
)
;
if
(
!
GetProperty
(
cx
O
P
&
method
)
)
{
return
false
;
}
if
(
method
.
isUndefined
(
)
)
{
return
true
;
}
return
Call
(
cx
method
O
arg
rval
)
;
}
static
MOZ_MUST_USE
JSObject
*
PromiseInvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
)
{
MOZ_ASSERT
(
!
O
.
isUndefined
(
)
)
;
RootedValue
returnValue
(
cx
)
;
if
(
!
InvokeOrNoop
(
cx
O
P
arg
&
returnValue
)
)
{
return
PromiseRejectedWithPendingError
(
cx
)
;
}
return
PromiseObject
:
:
unforgeableResolve
(
cx
returnValue
)
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeHighWaterMark
(
JSContext
*
cx
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
{
if
(
!
ToNumber
(
cx
highWaterMarkVal
highWaterMark
)
)
{
return
false
;
}
if
(
mozilla
:
:
IsNaN
(
*
highWaterMark
)
|
|
*
highWaterMark
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_STREAM_INVALID_HIGHWATERMARK
)
;
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeQueuingStrategy
(
JSContext
*
cx
HandleValue
size
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
{
if
(
!
size
.
isUndefined
(
)
&
&
!
IsCallable
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_FUNCTION
"
ReadableStream
argument
options
.
size
"
)
;
return
false
;
}
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
highWaterMark
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderCancel
(
JSContext
*
cx
HandleObject
readerObj
HandleValue
reason
)
{
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
&
readerObj
-
>
as
<
ReadableStreamReader
>
(
)
)
;
ReadableStream
*
stream
=
StreamFromReader
(
cx
reader
)
;
if
(
!
stream
)
{
return
false
;
}
return
ReadableStreamReaderGenericCancel
(
cx
reader
reason
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderReleaseLock
(
JSContext
*
cx
HandleObject
readerObj
)
{
Rooted
<
ReadableStreamReader
*
>
reader
(
cx
&
readerObj
-
>
as
<
ReadableStreamReader
>
(
)
)
;
ReadableStream
*
stream
=
StreamFromReader
(
cx
reader
)
;
if
(
!
stream
)
{
return
false
;
}
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
;
return
ReadableStreamReaderGenericRelease
(
cx
reader
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
enqueue
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
chunk
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
return
ReadableStreamDefaultControllerEnqueue
(
cx
controller
chunk
)
;
}
void
ReadableStream
:
:
desiredSize
(
bool
*
hasSize
double
*
size
)
const
{
if
(
errored
(
)
)
{
*
hasSize
=
false
;
return
;
}
*
hasSize
=
true
;
if
(
closed
(
)
)
{
*
size
=
0
;
return
;
}
ReadableStreamController
*
controller
=
ControllerFromStream
(
this
)
;
*
size
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
}
bool
ReadableStream
:
:
getExternalSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
*
source
)
{
MOZ_ASSERT
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED
)
;
return
false
;
}
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
ReadableStreamGetExternalUnderlyingSource
"
)
;
return
false
;
}
auto
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
AddControllerFlags
(
controller
ControllerFlag_SourceLocked
)
;
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
return
true
;
}
void
ReadableStream
:
:
releaseExternalSource
(
)
{
MOZ_ASSERT
(
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
MOZ_ASSERT
(
locked
(
)
)
;
auto
controller
=
ControllerFromStream
(
this
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_SourceLocked
)
;
RemoveControllerFlags
(
controller
ControllerFlag_SourceLocked
)
;
}
uint8_t
ReadableStream
:
:
embeddingFlags
(
)
const
{
uint8_t
flags
=
ControllerFlags
(
ControllerFromStream
(
this
)
)
>
>
ControllerEmbeddingFlagsOffset
;
MOZ_ASSERT_IF
(
flags
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
return
flags
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
updateDataAvailableFromSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
uint32_t
availableData
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
enqueue
"
)
;
return
false
;
}
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
enqueue
"
)
;
return
false
;
}
RemoveControllerFlags
(
controller
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
;
#
if
DEBUG
uint32_t
oldAvailableData
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toInt32
(
)
;
#
endif
SetQueueSize
(
controller
availableData
)
;
if
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
{
return
true
;
}
ReaderMode
readerMode
;
if
(
!
ReadableStreamGetReaderMode
(
cx
stream
&
readerMode
)
)
{
return
false
;
}
if
(
readerMode
=
=
ReaderMode
:
:
Default
)
{
MOZ_ASSERT
(
oldAvailableData
=
=
0
)
;
JSObject
*
viewObj
=
JS_NewUint8Array
(
cx
availableData
)
;
Rooted
<
ArrayBufferViewObject
*
>
transferredView
(
cx
&
viewObj
-
>
as
<
ArrayBufferViewObject
>
(
)
)
;
if
(
!
transferredView
)
{
return
false
;
}
Value
val
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
void
*
underlyingSource
=
val
.
toPrivate
(
)
;
size_t
bytesWritten
;
{
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
void
*
buffer
=
JS_GetArrayBufferViewData
(
transferredView
&
dummy
noGC
)
;
auto
cb
=
cx
-
>
runtime
(
)
-
>
readableStreamWriteIntoReadRequestCallback
;
MOZ_ASSERT
(
cb
)
;
cb
(
cx
stream
underlyingSource
stream
-
>
embeddingFlags
(
)
buffer
availableData
&
bytesWritten
)
;
}
RootedValue
chunk
(
cx
ObjectValue
(
*
transferredView
)
)
;
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
chunk
false
)
)
{
return
false
;
}
SetQueueSize
(
controller
availableData
-
bytesWritten
)
;
}
else
{
MOZ_ASSERT
(
!
stream
-
>
locked
(
)
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
close
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
ReadableStreamController
*
>
controllerObj
(
cx
ControllerFromStream
(
stream
)
)
;
if
(
!
VerifyControllerStateForClosing
(
cx
controllerObj
)
)
{
return
false
;
}
if
(
controllerObj
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamDefaultControllerClose
(
cx
controller
)
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableByteStreamController
>
(
)
;
return
ReadableByteStreamControllerClose
(
cx
controller
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
error
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
reason
)
{
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
error
"
)
;
return
false
;
}
Rooted
<
ReadableStreamController
*
>
controller
(
cx
ControllerFromStream
(
stream
)
)
;
return
ReadableStreamControllerError
(
cx
controller
reason
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
tee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1Stream
MutableHandle
<
ReadableStream
*
>
branch2Stream
)
{
return
ReadableStreamTee
(
cx
stream
false
branch1Stream
branch2Stream
)
;
}
MOZ_MUST_USE
ReadableStreamReader
*
ReadableStream
:
:
getReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
JS
:
:
ReadableStreamReaderMode
mode
)
{
return
CreateReadableStreamDefaultReader
(
cx
stream
)
;
}
JS_FRIEND_API
(
JSObject
*
)
js
:
:
UnwrapReadableStream
(
JSObject
*
obj
)
{
if
(
JSObject
*
unwrapped
=
CheckedUnwrap
(
obj
)
)
{
return
unwrapped
-
>
is
<
ReadableStream
>
(
)
?
unwrapped
:
nullptr
;
}
return
nullptr
;
}
