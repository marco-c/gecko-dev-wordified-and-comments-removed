#
include
"
builtin
/
Stream
.
h
"
#
include
"
js
/
Stream
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
enum
StreamSlots
{
StreamSlot_Controller
StreamSlot_Reader
StreamSlot_State
StreamSlot_StoredError
StreamSlotCount
}
;
enum
ReaderSlots
{
ReaderSlot_Stream
ReaderSlot_Requests
ReaderSlot_ClosedPromise
ReaderSlotCount
}
;
enum
ReaderType
{
ReaderType_Default
ReaderType_BYOB
}
;
enum
QueueContainerSlots
{
QueueContainerSlot_Queue
QueueContainerSlot_TotalSize
QueueContainerSlotCount
}
;
enum
ControllerSlots
{
ControllerSlot_Stream
=
QueueContainerSlotCount
ControllerSlot_UnderlyingSource
ControllerSlot_StrategyHWM
ControllerSlot_Flags
ControllerSlotCount
}
;
enum
DefaultControllerSlots
{
DefaultControllerSlot_StrategySize
=
ControllerSlotCount
DefaultControllerSlotCount
}
;
enum
ByteControllerSlots
{
ByteControllerSlot_BYOBRequest
=
ControllerSlotCount
ByteControllerSlot_PendingPullIntos
ByteControllerSlot_AutoAllocateSize
ByteControllerSlotCount
}
;
enum
ControllerFlags
{
ControllerFlag_Started
=
1
<
<
0
ControllerFlag_Pulling
=
1
<
<
1
ControllerFlag_PullAgain
=
1
<
<
2
ControllerFlag_CloseRequested
=
1
<
<
3
ControllerFlag_TeeBranch
=
1
<
<
4
ControllerFlag_TeeBranch1
=
1
<
<
5
ControllerFlag_TeeBranch2
=
1
<
<
6
ControllerFlag_ExternalSource
=
1
<
<
7
ControllerFlag_SourceLocked
=
1
<
<
8
}
;
constexpr
uint8_t
ControllerEmbeddingFlagsOffset
=
24
;
enum
BYOBRequestSlots
{
BYOBRequestSlot_Controller
BYOBRequestSlot_View
BYOBRequestSlotCount
}
;
template
<
class
T
>
MOZ_ALWAYS_INLINE
bool
Is
(
const
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
T
>
(
)
;
}
#
ifdef
DEBUG
static
bool
IsReadableStreamController
(
const
JSObject
*
controller
)
{
return
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
|
|
controller
-
>
is
<
ReadableByteStreamController
>
(
)
;
}
#
endif
static
inline
uint32_t
ControllerFlags
(
const
NativeObject
*
controller
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
return
controller
-
>
getFixedSlot
(
ControllerSlot_Flags
)
.
toInt32
(
)
;
}
static
inline
void
AddControllerFlags
(
NativeObject
*
controller
uint32_t
flags
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlags
(
controller
)
|
flags
)
)
;
}
static
inline
void
RemoveControllerFlags
(
NativeObject
*
controller
uint32_t
flags
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlags
(
controller
)
&
~
flags
)
)
;
}
static
inline
uint32_t
StreamState
(
const
ReadableStream
*
stream
)
{
return
stream
-
>
getFixedSlot
(
StreamSlot_State
)
.
toInt32
(
)
;
}
static
inline
void
SetStreamState
(
ReadableStream
*
stream
uint32_t
state
)
{
MOZ_ASSERT_IF
(
stream
-
>
disturbed
(
)
state
&
ReadableStream
:
:
Disturbed
)
;
MOZ_ASSERT_IF
(
stream
-
>
closed
(
)
|
|
stream
-
>
errored
(
)
!
(
state
&
ReadableStream
:
:
Readable
)
)
;
stream
-
>
setFixedSlot
(
StreamSlot_State
Int32Value
(
state
)
)
;
}
bool
ReadableStream
:
:
readable
(
)
const
{
return
StreamState
(
this
)
&
Readable
;
}
bool
ReadableStream
:
:
closed
(
)
const
{
return
StreamState
(
this
)
&
Closed
;
}
bool
ReadableStream
:
:
errored
(
)
const
{
return
StreamState
(
this
)
&
Errored
;
}
bool
ReadableStream
:
:
disturbed
(
)
const
{
return
StreamState
(
this
)
&
Disturbed
;
}
inline
static
bool
ReaderHasStream
(
const
NativeObject
*
reader
)
{
MOZ_ASSERT
(
JS
:
:
IsReadableStreamReader
(
reader
)
)
;
return
!
reader
-
>
getFixedSlot
(
ReaderSlot_Stream
)
.
isUndefined
(
)
;
}
bool
js
:
:
ReadableStreamReaderIsClosed
(
const
JSObject
*
reader
)
{
return
!
ReaderHasStream
(
&
reader
-
>
as
<
NativeObject
>
(
)
)
;
}
inline
static
MOZ_MUST_USE
ReadableStream
*
StreamFromController
(
const
NativeObject
*
controller
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
return
&
controller
-
>
getFixedSlot
(
ControllerSlot_Stream
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
;
}
inline
static
MOZ_MUST_USE
NativeObject
*
ControllerFromStream
(
const
ReadableStream
*
stream
)
{
Value
controllerVal
=
stream
-
>
getFixedSlot
(
StreamSlot_Controller
)
;
MOZ_ASSERT
(
IsReadableStreamController
(
&
controllerVal
.
toObject
(
)
)
)
;
return
&
controllerVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
}
inline
static
bool
HasController
(
const
ReadableStream
*
stream
)
{
return
!
stream
-
>
getFixedSlot
(
StreamSlot_Controller
)
.
isUndefined
(
)
;
}
JS
:
:
ReadableStreamMode
ReadableStream
:
:
mode
(
)
const
{
NativeObject
*
controller
=
ControllerFromStream
(
this
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
return
JS
:
:
ReadableStreamMode
:
:
Default
;
return
controller
-
>
as
<
ReadableByteStreamController
>
(
)
.
hasExternalSource
(
)
?
JS
:
:
ReadableStreamMode
:
:
ExternalSource
:
JS
:
:
ReadableStreamMode
:
:
Byte
;
}
inline
static
MOZ_MUST_USE
ReadableStream
*
StreamFromReader
(
const
NativeObject
*
reader
)
{
MOZ_ASSERT
(
ReaderHasStream
(
reader
)
)
;
return
&
reader
-
>
getFixedSlot
(
ReaderSlot_Stream
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
;
}
inline
static
MOZ_MUST_USE
NativeObject
*
ReaderFromStream
(
const
NativeObject
*
stream
)
{
Value
readerVal
=
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
;
MOZ_ASSERT
(
JS
:
:
IsReadableStreamReader
(
&
readerVal
.
toObject
(
)
)
)
;
return
&
readerVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
}
inline
static
bool
HasReader
(
const
ReadableStream
*
stream
)
{
return
!
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
isUndefined
(
)
;
}
inline
static
MOZ_MUST_USE
JSFunction
*
NewHandler
(
JSContext
*
cx
Native
handler
HandleObject
target
)
{
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
handlerFun
(
cx
NewNativeFunction
(
cx
handler
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
handlerFun
)
return
nullptr
;
handlerFun
-
>
setExtendedSlot
(
0
ObjectValue
(
*
target
)
)
;
return
handlerFun
;
}
template
<
class
T
>
inline
static
MOZ_MUST_USE
T
*
TargetFromHandler
(
JSObject
&
handler
)
{
return
&
handler
.
as
<
JSFunction
>
(
)
.
getExtendedSlot
(
0
)
.
toObject
(
)
.
as
<
T
>
(
)
;
}
inline
static
MOZ_MUST_USE
bool
ResetQueue
(
JSContext
*
cx
HandleNativeObject
container
)
;
inline
static
MOZ_MUST_USE
bool
InvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
MutableHandleValue
rval
)
;
static
MOZ_MUST_USE
JSObject
*
PromiseInvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
)
;
static
MOZ_MUST_USE
JSObject
*
PromiseRejectedWithPendingError
(
JSContext
*
cx
)
{
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
return
nullptr
;
return
PromiseObject
:
:
unforgeableReject
(
cx
exn
)
;
}
static
void
ReportArgTypeError
(
JSContext
*
cx
const
char
*
funName
const
char
*
expectedType
HandleValue
arg
)
{
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
arg
nullptr
)
;
if
(
!
bytes
)
return
;
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_EXPECTED_TYPE
funName
expectedType
bytes
.
get
(
)
)
;
}
static
MOZ_MUST_USE
bool
RejectWithPendingError
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
return
false
;
return
PromiseObject
:
:
reject
(
cx
promise
exn
)
;
}
static
MOZ_MUST_USE
bool
ReturnPromiseRejectedWithPendingError
(
JSContext
*
cx
const
CallArgs
&
args
)
{
JSObject
*
promise
=
PromiseRejectedWithPendingError
(
cx
)
;
if
(
!
promise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
promise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
RejectNonGenericMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
char
*
className
const
char
*
methodName
)
{
ReportValueError
(
cx
JSMSG_INCOMPATIBLE_PROTO
JSDVG_SEARCH_STACK
args
.
thisv
(
)
nullptr
className
methodName
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
inline
static
MOZ_MUST_USE
NativeObject
*
SetNewList
(
JSContext
*
cx
HandleNativeObject
container
uint32_t
slot
)
{
NativeObject
*
list
=
NewList
(
cx
)
;
if
(
!
list
)
return
nullptr
;
container
-
>
setFixedSlot
(
slot
ObjectValue
(
*
list
)
)
;
return
list
;
}
class
ByteStreamChunk
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Buffer
=
0
Slot_ByteOffset
Slot_ByteLength
SlotCount
}
;
public
:
static
const
Class
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_Buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
uint32_t
byteOffset
(
)
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
void
SetByteOffset
(
uint32_t
offset
)
{
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
offset
)
)
;
}
uint32_t
byteLength
(
)
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
void
SetByteLength
(
uint32_t
length
)
{
setFixedSlot
(
Slot_ByteLength
Int32Value
(
length
)
)
;
}
static
ByteStreamChunk
*
create
(
JSContext
*
cx
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
{
Rooted
<
ByteStreamChunk
*
>
chunk
(
cx
NewBuiltinClassInstance
<
ByteStreamChunk
>
(
cx
)
)
;
if
(
!
chunk
)
return
nullptr
;
chunk
-
>
setFixedSlot
(
Slot_Buffer
ObjectValue
(
*
buffer
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
chunk
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
return
chunk
;
}
}
;
const
Class
ByteStreamChunk
:
:
class_
=
{
"
ByteStreamChunk
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
PullIntoDescriptor
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_buffer
Slot_ByteOffset
Slot_ByteLength
Slot_BytesFilled
Slot_ElementSize
Slot_Ctor
Slot_ReaderType
SlotCount
}
;
public
:
static
const
Class
class_
;
ArrayBufferObject
*
buffer
(
)
{
return
&
getFixedSlot
(
Slot_buffer
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
}
void
setBuffer
(
ArrayBufferObject
*
buffer
)
{
setFixedSlot
(
Slot_buffer
ObjectValue
(
*
buffer
)
)
;
}
JSObject
*
ctor
(
)
{
return
getFixedSlot
(
Slot_Ctor
)
.
toObjectOrNull
(
)
;
}
uint32_t
byteOffset
(
)
const
{
return
getFixedSlot
(
Slot_ByteOffset
)
.
toInt32
(
)
;
}
uint32_t
byteLength
(
)
const
{
return
getFixedSlot
(
Slot_ByteLength
)
.
toInt32
(
)
;
}
uint32_t
bytesFilled
(
)
const
{
return
getFixedSlot
(
Slot_BytesFilled
)
.
toInt32
(
)
;
}
void
setBytesFilled
(
int32_t
bytes
)
{
setFixedSlot
(
Slot_BytesFilled
Int32Value
(
bytes
)
)
;
}
uint32_t
elementSize
(
)
const
{
return
getFixedSlot
(
Slot_ElementSize
)
.
toInt32
(
)
;
}
uint32_t
readerType
(
)
const
{
return
getFixedSlot
(
Slot_ReaderType
)
.
toInt32
(
)
;
}
static
PullIntoDescriptor
*
create
(
JSContext
*
cx
HandleArrayBufferObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
uint32_t
bytesFilled
uint32_t
elementSize
HandleObject
ctor
uint32_t
readerType
)
{
Rooted
<
PullIntoDescriptor
*
>
descriptor
(
cx
NewBuiltinClassInstance
<
PullIntoDescriptor
>
(
cx
)
)
;
if
(
!
descriptor
)
return
nullptr
;
descriptor
-
>
setFixedSlot
(
Slot_buffer
ObjectValue
(
*
buffer
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_Ctor
ObjectOrNullValue
(
ctor
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ByteOffset
Int32Value
(
byteOffset
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ByteLength
Int32Value
(
byteLength
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_BytesFilled
Int32Value
(
bytesFilled
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ElementSize
Int32Value
(
elementSize
)
)
;
descriptor
-
>
setFixedSlot
(
Slot_ReaderType
Int32Value
(
readerType
)
)
;
return
descriptor
;
}
}
;
const
Class
PullIntoDescriptor
:
:
class_
=
{
"
PullIntoDescriptor
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
QueueEntry
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Value
=
0
Slot_Size
SlotCount
}
;
public
:
static
const
Class
class_
;
Value
value
(
)
{
return
getFixedSlot
(
Slot_Value
)
;
}
double
size
(
)
{
return
getFixedSlot
(
Slot_Size
)
.
toNumber
(
)
;
}
static
QueueEntry
*
create
(
JSContext
*
cx
HandleValue
value
double
size
)
{
Rooted
<
QueueEntry
*
>
entry
(
cx
NewBuiltinClassInstance
<
QueueEntry
>
(
cx
)
)
;
if
(
!
entry
)
return
nullptr
;
entry
-
>
setFixedSlot
(
Slot_Value
value
)
;
entry
-
>
setFixedSlot
(
Slot_Size
NumberValue
(
size
)
)
;
return
entry
;
}
}
;
const
Class
QueueEntry
:
:
class_
=
{
"
QueueEntry
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
class
TeeState
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_Flags
=
0
Slot_Reason1
Slot_Reason2
Slot_Promise
Slot_Stream
Slot_Branch1
Slot_Branch2
SlotCount
}
;
enum
Flags
{
Flag_ClosedOrErrored
=
1
<
<
0
Flag_Canceled1
=
1
<
<
1
Flag_Canceled2
=
1
<
<
2
Flag_CloneForBranch2
=
1
<
<
3
}
;
uint32_t
flags
(
)
const
{
return
getFixedSlot
(
Slot_Flags
)
.
toInt32
(
)
;
}
void
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
Slot_Flags
Int32Value
(
flags
)
)
;
}
public
:
static
const
Class
class_
;
bool
cloneForBranch2
(
)
const
{
return
flags
(
)
&
Flag_CloneForBranch2
;
}
bool
closedOrErrored
(
)
const
{
return
flags
(
)
&
Flag_ClosedOrErrored
;
}
void
setClosedOrErrored
(
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_ClosedOrErrored
)
)
;
setFlags
(
flags
(
)
|
Flag_ClosedOrErrored
)
;
}
bool
canceled1
(
)
const
{
return
flags
(
)
&
Flag_Canceled1
;
}
void
setCanceled1
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled1
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled1
)
;
setFixedSlot
(
Slot_Reason1
reason
)
;
}
bool
canceled2
(
)
const
{
return
flags
(
)
&
Flag_Canceled2
;
}
void
setCanceled2
(
HandleValue
reason
)
{
MOZ_ASSERT
(
!
(
flags
(
)
&
Flag_Canceled2
)
)
;
setFlags
(
flags
(
)
|
Flag_Canceled2
)
;
setFixedSlot
(
Slot_Reason2
reason
)
;
}
Value
reason1
(
)
const
{
MOZ_ASSERT
(
canceled1
(
)
)
;
return
getFixedSlot
(
Slot_Reason1
)
;
}
Value
reason2
(
)
const
{
MOZ_ASSERT
(
canceled2
(
)
)
;
return
getFixedSlot
(
Slot_Reason2
)
;
}
PromiseObject
*
promise
(
)
{
return
&
getFixedSlot
(
Slot_Promise
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
ReadableStream
*
stream
(
)
{
return
&
getFixedSlot
(
Slot_Stream
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
;
}
ReadableStreamDefaultReader
*
reader
(
)
{
return
&
ReaderFromStream
(
stream
(
)
)
-
>
as
<
ReadableStreamDefaultReader
>
(
)
;
}
ReadableStreamDefaultController
*
branch1
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch1
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch1
)
;
return
controller
;
}
void
setBranch1
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch1
)
;
setFixedSlot
(
Slot_Branch1
ObjectValue
(
*
controller
)
)
;
}
ReadableStreamDefaultController
*
branch2
(
)
{
ReadableStreamDefaultController
*
controller
=
&
getFixedSlot
(
Slot_Branch2
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch2
)
;
return
controller
;
}
void
setBranch2
(
ReadableStreamDefaultController
*
controller
)
{
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_TeeBranch2
)
;
setFixedSlot
(
Slot_Branch2
ObjectValue
(
*
controller
)
)
;
}
static
TeeState
*
create
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
TeeState
*
>
state
(
cx
NewBuiltinClassInstance
<
TeeState
>
(
cx
)
)
;
if
(
!
state
)
return
nullptr
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
state
-
>
setFixedSlot
(
Slot_Flags
Int32Value
(
0
)
)
;
state
-
>
setFixedSlot
(
Slot_Promise
ObjectValue
(
*
promise
)
)
;
state
-
>
setFixedSlot
(
Slot_Stream
ObjectValue
(
*
stream
)
)
;
return
state
;
}
}
;
const
Class
TeeState
:
:
class_
=
{
"
TeeState
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
#
define
CLASS_SPEC
(
cls
nCtorArgs
nSlots
specFlags
classFlags
classOps
)
\
const
ClassSpec
cls
:
:
classSpec_
=
{
\
GenericCreateConstructor
<
cls
:
:
constructor
nCtorArgs
gc
:
:
AllocKind
:
:
FUNCTION
>
\
GenericCreatePrototype
\
nullptr
\
nullptr
\
cls
#
#
_methods
\
cls
#
#
_properties
\
nullptr
\
specFlags
\
}
;
\
\
const
Class
cls
:
:
class_
=
{
\
#
cls
\
JSCLASS_HAS_RESERVED_SLOTS
(
nSlots
)
|
\
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
cls
)
|
\
classFlags
\
classOps
\
&
cls
:
:
classSpec_
\
}
;
\
\
const
Class
cls
:
:
protoClass_
=
{
\
"
object
"
\
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
cls
)
\
JS_NULL_CLASS_OPS
\
&
cls
:
:
classSpec_
\
}
;
ReadableStream
*
ReadableStream
:
:
createStream
(
JSContext
*
cx
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
NewObjectWithClassProto
<
ReadableStream
>
(
cx
proto
)
)
;
if
(
!
stream
)
return
nullptr
;
stream
-
>
setFixedSlot
(
StreamSlot_State
Int32Value
(
Readable
)
)
;
return
stream
;
}
static
MOZ_MUST_USE
ReadableStreamDefaultController
*
CreateReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMarkVal
)
;
ReadableStream
*
ReadableStream
:
:
createDefaultStream
(
JSContext
*
cx
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMark
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
createStream
(
cx
)
)
;
if
(
!
stream
)
return
nullptr
;
RootedObject
controller
(
cx
CreateReadableStreamDefaultController
(
cx
stream
underlyingSource
size
highWaterMark
)
)
;
if
(
!
controller
)
return
nullptr
;
stream
-
>
setFixedSlot
(
StreamSlot_Controller
ObjectValue
(
*
controller
)
)
;
return
stream
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingByteSource
HandleValue
highWaterMarkVal
)
;
ReadableStream
*
ReadableStream
:
:
createByteStream
(
JSContext
*
cx
HandleValue
underlyingSource
HandleValue
highWaterMark
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
createStream
(
cx
proto
)
)
;
if
(
!
stream
)
return
nullptr
;
RootedObject
controller
(
cx
CreateReadableByteStreamController
(
cx
stream
underlyingSource
highWaterMark
)
)
;
if
(
!
controller
)
return
nullptr
;
stream
-
>
setFixedSlot
(
StreamSlot_Controller
ObjectValue
(
*
controller
)
)
;
return
stream
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
underlyingSource
)
;
ReadableStream
*
ReadableStream
:
:
createExternalSourceStream
(
JSContext
*
cx
void
*
underlyingSource
uint8_t
flags
HandleObject
proto
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
createStream
(
cx
proto
)
)
;
if
(
!
stream
)
return
nullptr
;
RootedNativeObject
controller
(
cx
CreateReadableByteStreamController
(
cx
stream
underlyingSource
)
)
;
if
(
!
controller
)
return
nullptr
;
stream
-
>
setFixedSlot
(
StreamSlot_Controller
ObjectValue
(
*
controller
)
)
;
AddControllerFlags
(
controller
flags
<
<
ControllerEmbeddingFlagsOffset
)
;
return
stream
;
}
bool
ReadableStream
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
val
(
cx
args
.
get
(
0
)
)
;
RootedValue
underlyingSource
(
cx
args
.
get
(
0
)
)
;
RootedValue
options
(
cx
args
.
get
(
1
)
)
;
if
(
underlyingSource
.
isUndefined
(
)
)
{
RootedObject
sourceObj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
)
)
;
if
(
!
sourceObj
)
return
false
;
underlyingSource
=
ObjectValue
(
*
sourceObj
)
;
}
RootedValue
size
(
cx
)
;
RootedValue
highWaterMark
(
cx
)
;
if
(
!
options
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
options
cx
-
>
names
(
)
.
size
&
size
)
)
return
false
;
if
(
!
GetProperty
(
cx
options
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
return
false
;
}
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStream
"
)
)
return
false
;
RootedValue
typeVal
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingSource
cx
-
>
names
(
)
.
type
&
typeVal
)
)
return
false
;
RootedString
type
(
cx
ToString
<
CanGC
>
(
cx
typeVal
)
)
;
if
(
!
type
)
return
false
;
int32_t
notByteStream
;
if
(
!
CompareStrings
(
cx
type
cx
-
>
names
(
)
.
bytes
&
notByteStream
)
)
return
false
;
if
(
highWaterMark
.
isUndefined
(
)
)
highWaterMark
=
Int32Value
(
notByteStream
?
1
:
0
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
)
;
if
(
!
notByteStream
)
{
stream
=
createByteStream
(
cx
underlyingSource
highWaterMark
)
;
}
else
if
(
typeVal
.
isUndefined
(
)
)
{
stream
=
createDefaultStream
(
cx
underlyingSource
size
highWaterMark
)
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_UNDERLYINGSOURCE_TYPE_WRONG
)
;
return
false
;
}
if
(
!
stream
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
stream
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStream_locked_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
stream
-
>
locked
(
)
)
;
return
true
;
}
static
bool
ReadableStream_locked
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStream
>
ReadableStream_locked_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStream_cancel
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStream
>
(
args
.
thisv
(
)
)
)
{
ReportValueError
(
cx
JSMSG_INCOMPATIBLE_PROTO
JSDVG_SEARCH_STACK
args
.
thisv
(
)
nullptr
"
cancel
"
"
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_NOT_LOCKED
"
cancel
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
RootedObject
cancelPromise
(
cx
ReadableStream
:
:
cancel
(
cx
stream
args
.
get
(
0
)
)
)
;
if
(
!
cancelPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
cancelPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
ReadableStreamDefaultReader
*
CreateReadableStreamDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
;
static
MOZ_MUST_USE
ReadableStreamBYOBReader
*
CreateReadableStreamBYOBReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
;
static
MOZ_MUST_USE
bool
ReadableStream_getReader_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
RootedObject
reader
(
cx
)
;
RootedValue
modeVal
(
cx
)
;
HandleValue
optionsVal
=
args
.
get
(
0
)
;
if
(
!
optionsVal
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
optionsVal
cx
-
>
names
(
)
.
mode
&
modeVal
)
)
return
false
;
}
if
(
modeVal
.
isUndefined
(
)
)
{
reader
=
CreateReadableStreamDefaultReader
(
cx
stream
)
;
}
else
{
RootedString
mode
(
cx
ToString
<
CanGC
>
(
cx
modeVal
)
)
;
if
(
!
mode
)
return
false
;
int32_t
notByob
;
if
(
!
CompareStrings
(
cx
mode
cx
-
>
names
(
)
.
byob
&
notByob
)
)
return
false
;
if
(
notByob
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_INVALID_READER_MODE
)
;
return
false
;
}
reader
=
CreateReadableStreamBYOBReader
(
cx
stream
)
;
}
if
(
!
reader
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
reader
)
;
return
true
;
}
static
bool
ReadableStream_getReader
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStream
>
ReadableStream_getReader_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStream_pipeThrough
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeThrough
"
)
;
return
false
;
}
static
MOZ_MUST_USE
bool
ReadableStream_pipeTo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED
"
pipeTo
"
)
;
return
false
;
}
static
MOZ_MUST_USE
bool
ReadableStreamTee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1
MutableHandle
<
ReadableStream
*
>
branch2
)
;
static
MOZ_MUST_USE
bool
ReadableStream_tee_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
Rooted
<
ReadableStream
*
>
branch1
(
cx
)
;
Rooted
<
ReadableStream
*
>
branch2
(
cx
)
;
if
(
!
ReadableStreamTee
(
cx
stream
false
&
branch1
&
branch2
)
)
return
false
;
RootedNativeObject
branches
(
cx
NewDenseFullyAllocatedArray
(
cx
2
)
)
;
if
(
!
branches
)
return
false
;
branches
-
>
setDenseInitializedLength
(
2
)
;
branches
-
>
initDenseElement
(
0
ObjectValue
(
*
branch1
)
)
;
branches
-
>
initDenseElement
(
1
ObjectValue
(
*
branch2
)
)
;
args
.
rval
(
)
.
setObject
(
*
branches
)
;
return
true
;
}
static
bool
ReadableStream_tee
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStream
>
ReadableStream_tee_impl
>
(
cx
args
)
;
}
static
const
JSFunctionSpec
ReadableStream_methods
[
]
=
{
JS_FN
(
"
cancel
"
ReadableStream_cancel
1
0
)
JS_FN
(
"
getReader
"
ReadableStream_getReader
0
0
)
JS_FN
(
"
pipeThrough
"
ReadableStream_pipeThrough
2
0
)
JS_FN
(
"
pipeTo
"
ReadableStream_pipeTo
1
0
)
JS_FN
(
"
tee
"
ReadableStream_tee
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
ReadableStream_properties
[
]
=
{
JS_PSG
(
"
locked
"
ReadableStream_locked
0
)
JS_PS_END
}
;
CLASS_SPEC
(
ReadableStream
0
StreamSlotCount
0
0
JS_NULL_CLASS_OPS
)
;
bool
ReadableStream
:
:
locked
(
)
const
{
if
(
HasController
(
this
)
&
&
(
ControllerFlags
(
ControllerFromStream
(
this
)
)
&
ControllerFlag_SourceLocked
)
)
{
return
true
;
}
return
HasReader
(
this
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
chunk
)
;
static
bool
TeeReaderReadHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
teeState
(
cx
TargetFromHandler
<
TeeState
>
(
args
.
callee
(
)
)
)
;
HandleValue
resultVal
=
args
.
get
(
0
)
;
RootedObject
result
(
cx
&
resultVal
.
toObject
(
)
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
result
NameToId
(
cx
-
>
names
(
)
.
value
)
value
.
address
(
)
)
)
return
false
;
RootedValue
doneVal
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
result
NameToId
(
cx
-
>
names
(
)
.
done
)
doneVal
.
address
(
)
)
)
return
false
;
bool
done
=
doneVal
.
toBoolean
(
)
;
if
(
done
&
&
!
teeState
-
>
closedOrErrored
(
)
)
{
if
(
!
teeState
-
>
canceled1
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
teeState
-
>
branch1
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
branch1
)
)
return
false
;
}
if
(
!
teeState
-
>
canceled2
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
teeState
-
>
branch2
(
)
)
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
branch2
)
)
return
false
;
}
teeState
-
>
setClosedOrErrored
(
)
;
}
if
(
teeState
-
>
closedOrErrored
(
)
)
return
true
;
RootedValue
value1
(
cx
value
)
;
RootedValue
value2
(
cx
value
)
;
MOZ_ASSERT
(
!
teeState
-
>
cloneForBranch2
(
)
"
tee
(
cloneForBranch2
=
true
)
should
not
be
exposed
"
)
;
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
if
(
!
teeState
-
>
canceled1
(
)
)
{
controller
=
teeState
-
>
branch1
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
value1
)
)
return
false
;
}
if
(
!
teeState
-
>
canceled2
(
)
)
{
controller
=
teeState
-
>
branch2
(
)
;
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
value2
)
)
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamTee_Pull
(
JSContext
*
cx
Handle
<
TeeState
*
>
teeState
Handle
<
ReadableStream
*
>
branchStream
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
teeState
-
>
reader
(
)
)
;
RootedObject
readPromise
(
cx
ReadableStreamDefaultReader
:
:
read
(
cx
reader
)
)
;
if
(
!
readPromise
)
return
nullptr
;
RootedObject
onFulfilled
(
cx
NewHandler
(
cx
TeeReaderReadHandler
teeState
)
)
;
if
(
!
onFulfilled
)
return
nullptr
;
return
JS
:
:
CallOriginalPromiseThen
(
cx
readPromise
onFulfilled
nullptr
)
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamTee_Cancel
(
JSContext
*
cx
Handle
<
TeeState
*
>
teeState
Handle
<
ReadableStreamDefaultController
*
>
branch
HandleValue
reason
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
teeState
-
>
stream
(
)
)
;
bool
bothBranchesCanceled
=
false
;
if
(
ControllerFlags
(
branch
)
&
ControllerFlag_TeeBranch1
)
{
teeState
-
>
setCanceled1
(
reason
)
;
bothBranchesCanceled
=
teeState
-
>
canceled2
(
)
;
}
else
{
MOZ_ASSERT
(
ControllerFlags
(
branch
)
&
ControllerFlag_TeeBranch2
)
;
teeState
-
>
setCanceled2
(
reason
)
;
bothBranchesCanceled
=
teeState
-
>
canceled1
(
)
;
}
if
(
bothBranchesCanceled
)
{
RootedNativeObject
compositeReason
(
cx
NewDenseFullyAllocatedArray
(
cx
2
)
)
;
if
(
!
compositeReason
)
return
nullptr
;
compositeReason
-
>
setDenseInitializedLength
(
2
)
;
compositeReason
-
>
initDenseElement
(
0
teeState
-
>
reason1
(
)
)
;
compositeReason
-
>
initDenseElement
(
1
teeState
-
>
reason2
(
)
)
;
RootedValue
compositeReasonVal
(
cx
ObjectValue
(
*
compositeReason
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
teeState
-
>
promise
(
)
)
;
RootedObject
cancelResult
(
cx
ReadableStream
:
:
cancel
(
cx
stream
compositeReasonVal
)
)
;
if
(
!
cancelResult
)
{
if
(
!
RejectWithPendingError
(
cx
promise
)
)
return
nullptr
;
}
else
{
RootedValue
resultVal
(
cx
ObjectValue
(
*
cancelResult
)
)
;
if
(
!
PromiseObject
:
:
resolve
(
cx
promise
resultVal
)
)
return
nullptr
;
}
}
return
teeState
-
>
promise
(
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamControllerError
(
JSContext
*
cx
HandleNativeObject
controller
HandleValue
e
)
;
static
bool
TeeReaderClosedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
TeeState
*
>
teeState
(
cx
TargetFromHandler
<
TeeState
>
(
args
.
callee
(
)
)
)
;
HandleValue
reason
=
args
.
get
(
0
)
;
if
(
!
teeState
-
>
closedOrErrored
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
teeState
-
>
branch1
(
)
)
;
if
(
!
ReadableStreamControllerError
(
cx
branch1
reason
)
)
return
false
;
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
teeState
-
>
branch2
(
)
)
;
if
(
!
ReadableStreamControllerError
(
cx
branch2
reason
)
)
return
false
;
teeState
-
>
setClosedOrErrored
(
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamTee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1Stream
MutableHandle
<
ReadableStream
*
>
branch2Stream
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
CreateReadableStreamDefaultReader
(
cx
stream
)
)
;
if
(
!
reader
)
return
false
;
Rooted
<
TeeState
*
>
teeState
(
cx
TeeState
:
:
create
(
cx
stream
)
)
;
if
(
!
teeState
)
return
false
;
RootedValue
hwmValue
(
cx
NumberValue
(
1
)
)
;
RootedValue
underlyingSource
(
cx
ObjectValue
(
*
teeState
)
)
;
branch1Stream
.
set
(
ReadableStream
:
:
createDefaultStream
(
cx
underlyingSource
UndefinedHandleValue
hwmValue
)
)
;
if
(
!
branch1Stream
)
return
false
;
Rooted
<
ReadableStreamDefaultController
*
>
branch1
(
cx
)
;
branch1
=
&
ControllerFromStream
(
branch1Stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
AddControllerFlags
(
branch1
ControllerFlag_TeeBranch
|
ControllerFlag_TeeBranch1
)
;
teeState
-
>
setBranch1
(
branch1
)
;
branch2Stream
.
set
(
ReadableStream
:
:
createDefaultStream
(
cx
underlyingSource
UndefinedHandleValue
hwmValue
)
)
;
if
(
!
branch2Stream
)
return
false
;
Rooted
<
ReadableStreamDefaultController
*
>
branch2
(
cx
)
;
branch2
=
&
ControllerFromStream
(
branch2Stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
AddControllerFlags
(
branch2
ControllerFlag_TeeBranch
|
ControllerFlag_TeeBranch2
)
;
teeState
-
>
setBranch2
(
branch2
)
;
RootedObject
closedPromise
(
cx
&
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
.
toObject
(
)
)
;
RootedObject
onRejected
(
cx
NewHandler
(
cx
TeeReaderClosedHandler
teeState
)
)
;
if
(
!
onRejected
)
return
false
;
if
(
!
JS
:
:
AddPromiseReactions
(
cx
closedPromise
nullptr
onRejected
)
)
return
false
;
return
true
;
}
static
MOZ_MUST_USE
PromiseObject
*
ReadableStreamAddReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
RootedValue
val
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
)
;
RootedNativeObject
reader
(
cx
&
val
.
toObject
(
)
.
as
<
ReadableStreamBYOBReader
>
(
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
|
|
stream
-
>
closed
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
RootedNativeObject
readIntoRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
ObjectValue
(
*
promise
)
;
if
(
!
AppendToList
(
cx
readIntoRequests
val
)
)
return
nullptr
;
return
promise
;
}
static
MOZ_MUST_USE
PromiseObject
*
ReadableStreamAddReadRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
MOZ_ASSERT
(
stream
-
>
is
<
ReadableStream
>
(
)
)
;
RootedNativeObject
reader
(
cx
ReaderFromStream
(
stream
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
createSkippingExecutor
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
RootedValue
val
(
cx
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
)
;
RootedNativeObject
readRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
ObjectValue
(
*
promise
)
;
if
(
!
AppendToList
(
cx
readRequests
val
)
)
return
nullptr
;
return
promise
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
HandleNativeObject
controller
HandleValue
reason
)
;
static
bool
ReturnUndefined
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
;
MOZ_MUST_USE
JSObject
*
ReadableStream
:
:
cancel
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
reason
)
{
uint32_t
state
=
StreamState
(
stream
)
|
ReadableStream
:
:
Disturbed
;
SetStreamState
(
stream
state
)
;
if
(
stream
-
>
closed
(
)
)
return
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
if
(
stream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
ReadableStreamCloseInternal
(
cx
stream
)
)
return
nullptr
;
RootedNativeObject
controller
(
cx
ControllerFromStream
(
stream
)
)
;
RootedObject
sourceCancelPromise
(
cx
)
;
sourceCancelPromise
=
ReadableStreamControllerCancelSteps
(
cx
controller
reason
)
;
if
(
!
sourceCancelPromise
)
return
nullptr
;
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
returnUndefined
(
cx
NewNativeFunction
(
cx
ReturnUndefined
0
funName
)
)
;
if
(
!
returnUndefined
)
return
nullptr
;
return
JS
:
:
CallOriginalPromiseThen
(
cx
sourceCancelPromise
returnUndefined
nullptr
)
;
}
MOZ_MUST_USE
bool
ReadableStreamCloseInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
uint32_t
state
=
StreamState
(
stream
)
;
SetStreamState
(
stream
(
state
&
ReadableStream
:
:
Disturbed
)
|
ReadableStream
:
:
Closed
)
;
RootedValue
val
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
)
;
if
(
val
.
isUndefined
(
)
)
return
true
;
RootedNativeObject
reader
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
reader
-
>
is
<
ReadableStreamDefaultReader
>
(
)
)
{
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
if
(
!
val
.
isUndefined
(
)
)
{
RootedNativeObject
readRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
RootedObject
readRequest
(
cx
)
;
RootedObject
resultObj
(
cx
)
;
RootedValue
resultVal
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
readRequest
=
&
readRequests
-
>
getDenseElement
(
i
)
.
toObject
(
)
;
resultObj
=
CreateIterResultObject
(
cx
UndefinedHandleValue
true
)
;
if
(
!
resultObj
)
return
false
;
resultVal
=
ObjectValue
(
*
resultObj
)
;
if
(
!
ResolvePromise
(
cx
readRequest
resultVal
)
)
return
false
;
}
reader
-
>
setFixedSlot
(
ReaderSlot_Requests
UndefinedValue
(
)
)
;
}
}
RootedObject
closedPromise
(
cx
&
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
.
toObject
(
)
)
;
if
(
!
ResolvePromise
(
cx
closedPromise
UndefinedHandleValue
)
)
return
false
;
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
&
&
cx
-
>
runtime
(
)
-
>
readableStreamClosedCallback
)
{
NativeObject
*
controller
=
ControllerFromStream
(
stream
)
;
void
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
cx
-
>
runtime
(
)
-
>
readableStreamClosedCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
ReadableStreamErrorInternal
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
e
)
{
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
uint32_t
state
=
StreamState
(
stream
)
;
SetStreamState
(
stream
(
state
&
ReadableStream
:
:
Disturbed
)
|
ReadableStream
:
:
Errored
)
;
stream
-
>
setFixedSlot
(
StreamSlot_StoredError
e
)
;
RootedValue
val
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
)
;
if
(
val
.
isUndefined
(
)
)
return
true
;
RootedNativeObject
reader
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
RootedNativeObject
readRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
PromiseObject
*
>
readRequest
(
cx
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
val
=
readRequests
-
>
getDenseElement
(
i
)
;
readRequest
=
&
val
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
if
(
!
PromiseObject
:
:
reject
(
cx
readRequest
e
)
)
return
false
;
}
if
(
!
SetNewList
(
cx
reader
ReaderSlot_Requests
)
)
return
false
;
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
;
Rooted
<
PromiseObject
*
>
closedPromise
(
cx
&
val
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
if
(
!
PromiseObject
:
:
reject
(
cx
closedPromise
e
)
)
return
false
;
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
&
&
cx
-
>
runtime
(
)
-
>
readableStreamErroredCallback
)
{
NativeObject
*
controller
=
ControllerFromStream
(
stream
)
;
void
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
cx
-
>
runtime
(
)
-
>
readableStreamErroredCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
e
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamFulfillReadOrReadIntoRequest
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
chunk
bool
done
)
{
RootedValue
val
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
)
;
RootedNativeObject
reader
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
RootedNativeObject
readIntoRequests
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
PromiseObject
*
>
readIntoRequest
(
cx
)
;
readIntoRequest
=
ShiftFromList
<
PromiseObject
>
(
cx
readIntoRequests
)
;
MOZ_ASSERT
(
readIntoRequest
)
;
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
chunk
done
)
)
;
if
(
!
iterResult
)
return
false
;
val
=
ObjectValue
(
*
iterResult
)
;
return
PromiseObject
:
:
resolve
(
cx
readIntoRequest
val
)
;
}
static
uint32_t
ReadableStreamGetNumReadRequests
(
ReadableStream
*
stream
)
{
if
(
!
HasReader
(
stream
)
)
return
0
;
NativeObject
*
reader
=
ReaderFromStream
(
stream
)
;
Value
readRequests
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
return
readRequests
.
toObject
(
)
.
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamHasBYOBReader
(
ReadableStream
*
stream
)
{
Value
reader
=
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
;
return
reader
.
isObject
(
)
&
&
reader
.
toObject
(
)
.
is
<
ReadableStreamBYOBReader
>
(
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamHasDefaultReader
(
ReadableStream
*
stream
)
{
Value
reader
=
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
;
return
reader
.
isObject
(
)
&
&
reader
.
toObject
(
)
.
is
<
ReadableStreamDefaultReader
>
(
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
cx
HandleNativeObject
reader
Handle
<
ReadableStream
*
>
stream
)
;
static
MOZ_MUST_USE
ReadableStreamDefaultReader
*
CreateReadableStreamDefaultReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
NewBuiltinClassInstance
<
ReadableStreamDefaultReader
>
(
cx
)
;
if
(
!
reader
)
return
nullptr
;
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED
)
;
return
nullptr
;
}
if
(
!
ReadableStreamReaderGenericInitialize
(
cx
reader
stream
)
)
return
nullptr
;
if
(
!
SetNewList
(
cx
reader
ReaderSlot_Requests
)
)
return
nullptr
;
return
reader
;
}
bool
ReadableStreamDefaultReader
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamDefaultReader
"
)
)
return
false
;
if
(
!
Is
<
ReadableStream
>
(
args
.
get
(
0
)
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultReader
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
RootedObject
reader
(
cx
CreateReadableStreamDefaultReader
(
cx
stream
)
)
;
if
(
!
reader
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
reader
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_closed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStreamDefaultReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamDefaultReader
"
"
get
closed
"
)
;
NativeObject
*
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
args
.
rval
(
)
.
set
(
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamReaderGenericCancel
(
JSContext
*
cx
HandleNativeObject
reader
HandleValue
reason
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_cancel
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStreamDefaultReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamDefaultReader
"
"
cancel
"
)
;
RootedNativeObject
reader
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
cancel
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
cancelPromise
=
ReadableStreamReaderGenericCancel
(
cx
reader
args
.
get
(
0
)
)
;
if
(
!
cancelPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
cancelPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_read
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStreamDefaultReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamDefaultReader
"
"
read
"
)
;
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultReader
>
(
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
read
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
readPromise
=
ReadableStreamDefaultReader
:
:
read
(
cx
reader
)
;
if
(
!
readPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
readPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
HandleNativeObject
reader
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultReader_releaseLock_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultReader
*
>
reader
(
cx
)
;
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultReader
>
(
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Value
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
if
(
!
val
.
isUndefined
(
)
)
{
NativeObject
*
readRequests
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
if
(
len
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_EMPTY
"
releaseLock
"
)
;
return
false
;
}
}
return
ReadableStreamReaderGenericRelease
(
cx
reader
)
;
}
static
bool
ReadableStreamDefaultReader_releaseLock
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultReader
>
ReadableStreamDefaultReader_releaseLock_impl
>
(
cx
args
)
;
}
static
const
JSFunctionSpec
ReadableStreamDefaultReader_methods
[
]
=
{
JS_FN
(
"
cancel
"
ReadableStreamDefaultReader_cancel
1
0
)
JS_FN
(
"
read
"
ReadableStreamDefaultReader_read
0
0
)
JS_FN
(
"
releaseLock
"
ReadableStreamDefaultReader_releaseLock
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
ReadableStreamDefaultReader_properties
[
]
=
{
JS_PSG
(
"
closed
"
ReadableStreamDefaultReader_closed
0
)
JS_PS_END
}
;
CLASS_SPEC
(
ReadableStreamDefaultReader
1
ReaderSlotCount
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
static
MOZ_MUST_USE
ReadableStreamBYOBReader
*
CreateReadableStreamBYOBReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
if
(
!
ControllerFromStream
(
stream
)
-
>
is
<
ReadableByteStreamController
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER
"
ReadableStream
.
getReader
(
'
byob
'
)
"
)
;
return
nullptr
;
}
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED
)
;
return
nullptr
;
}
Rooted
<
ReadableStreamBYOBReader
*
>
reader
(
cx
)
;
reader
=
NewBuiltinClassInstance
<
ReadableStreamBYOBReader
>
(
cx
)
;
if
(
!
reader
)
return
nullptr
;
if
(
!
ReadableStreamReaderGenericInitialize
(
cx
reader
stream
)
)
return
nullptr
;
if
(
!
SetNewList
(
cx
reader
ReaderSlot_Requests
)
)
return
nullptr
;
return
reader
;
}
bool
ReadableStreamBYOBReader
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamBYOBReader
"
)
)
return
false
;
if
(
!
Is
<
ReadableStream
>
(
args
.
get
(
0
)
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamBYOBReader
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
RootedObject
reader
(
cx
CreateReadableStreamBYOBReader
(
cx
stream
)
)
;
if
(
!
reader
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
reader
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamBYOBReader_closed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStreamBYOBReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamBYOBReader
"
"
get
closed
"
)
;
NativeObject
*
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
args
.
rval
(
)
.
set
(
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamBYOBReader_cancel
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
Is
<
ReadableStreamBYOBReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamBYOBReader
"
"
cancel
"
)
;
RootedNativeObject
reader
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
cancel
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
cancelPromise
=
ReadableStreamReaderGenericCancel
(
cx
reader
args
.
get
(
0
)
)
;
if
(
!
cancelPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
cancelPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamBYOBReader_read
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
viewVal
=
args
.
get
(
0
)
;
if
(
!
Is
<
ReadableStreamBYOBReader
>
(
args
.
thisv
(
)
)
)
return
RejectNonGenericMethod
(
cx
args
"
ReadableStreamBYOBReader
"
"
read
"
)
;
Rooted
<
ReadableStreamBYOBReader
*
>
reader
(
cx
)
;
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamBYOBReader
>
(
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_OWNED
"
read
"
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
if
(
!
Is
<
ArrayBufferViewObject
>
(
viewVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamBYOBReader
.
read
"
"
Typed
Array
"
viewVal
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
Rooted
<
ArrayBufferViewObject
*
>
view
(
cx
&
viewVal
.
toObject
(
)
.
as
<
ArrayBufferViewObject
>
(
)
)
;
if
(
JS_GetArrayBufferViewByteLength
(
view
)
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW
)
;
return
ReturnPromiseRejectedWithPendingError
(
cx
args
)
;
}
JSObject
*
readPromise
=
ReadableStreamBYOBReader
:
:
read
(
cx
reader
view
)
;
if
(
!
readPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
readPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
HandleNativeObject
reader
)
;
static
MOZ_MUST_USE
bool
ReadableStreamBYOBReader_releaseLock_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamBYOBReader
*
>
reader
(
cx
)
;
reader
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamBYOBReader
>
(
)
;
if
(
!
ReaderHasStream
(
reader
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Value
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_Requests
)
;
if
(
!
val
.
isUndefined
(
)
)
{
NativeObject
*
readRequests
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
uint32_t
len
=
readRequests
-
>
getDenseInitializedLength
(
)
;
if
(
len
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_NOT_EMPTY
"
releaseLock
"
)
;
return
false
;
}
}
return
ReadableStreamReaderGenericRelease
(
cx
reader
)
;
}
static
bool
ReadableStreamBYOBReader_releaseLock
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamBYOBReader
>
ReadableStreamBYOBReader_releaseLock_impl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
ReadableStreamBYOBReader_properties
[
]
=
{
JS_PSG
(
"
closed
"
ReadableStreamBYOBReader_closed
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamBYOBReader_methods
[
]
=
{
JS_FN
(
"
cancel
"
ReadableStreamBYOBReader_cancel
1
0
)
JS_FN
(
"
read
"
ReadableStreamBYOBReader_read
1
0
)
JS_FN
(
"
releaseLock
"
ReadableStreamBYOBReader_releaseLock
0
0
)
JS_FS_END
}
;
CLASS_SPEC
(
ReadableStreamBYOBReader
1
3
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
HandleNativeObject
controller
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamReaderGenericCancel
(
JSContext
*
cx
HandleNativeObject
reader
HandleValue
reason
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
reader
)
)
;
return
&
ReadableStreamCancel
(
cx
stream
reason
)
-
>
as
<
PromiseObject
>
(
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
cx
HandleNativeObject
reader
Handle
<
ReadableStream
*
>
stream
)
{
reader
-
>
setFixedSlot
(
ReaderSlot_Stream
ObjectValue
(
*
stream
)
)
;
stream
-
>
setFixedSlot
(
StreamSlot_Reader
ObjectValue
(
*
reader
)
)
;
RootedObject
promise
(
cx
)
;
if
(
stream
-
>
readable
(
)
)
{
promise
=
PromiseObject
:
:
createSkippingExecutor
(
cx
)
;
}
else
if
(
stream
-
>
closed
(
)
)
{
promise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
MOZ_ASSERT
(
stream
-
>
errored
(
)
)
;
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
promise
=
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
if
(
!
promise
)
return
false
;
reader
-
>
setFixedSlot
(
ReaderSlot_ClosedPromise
ObjectValue
(
*
promise
)
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamReaderGenericRelease
(
JSContext
*
cx
HandleNativeObject
reader
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
reader
)
)
;
MOZ_ASSERT
(
&
stream
-
>
getFixedSlot
(
StreamSlot_Reader
)
.
toObject
(
)
=
=
reader
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMREADER_RELEASED
)
;
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
return
false
;
if
(
stream
-
>
readable
(
)
)
{
Value
val
=
reader
-
>
getFixedSlot
(
ReaderSlot_ClosedPromise
)
;
Rooted
<
PromiseObject
*
>
closedPromise
(
cx
&
val
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
if
(
!
PromiseObject
:
:
reject
(
cx
closedPromise
exn
)
)
return
false
;
}
else
{
RootedObject
closedPromise
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
exn
)
)
;
if
(
!
closedPromise
)
return
false
;
reader
-
>
setFixedSlot
(
ReaderSlot_ClosedPromise
ObjectValue
(
*
closedPromise
)
)
;
}
stream
-
>
setFixedSlot
(
StreamSlot_Reader
UndefinedValue
(
)
)
;
reader
-
>
setFixedSlot
(
ReaderSlot_Stream
UndefinedValue
(
)
)
;
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerPullInto
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
Handle
<
ArrayBufferViewObject
*
>
view
)
;
MOZ_MUST_USE
JSObject
*
ReadableStreamBYOBReader
:
:
read
(
JSContext
*
cx
Handle
<
ReadableStreamBYOBReader
*
>
reader
Handle
<
ArrayBufferViewObject
*
>
view
)
{
MOZ_ASSERT
(
reader
-
>
is
<
ReadableStreamBYOBReader
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
reader
)
)
;
SetStreamState
(
stream
StreamState
(
stream
)
|
ReadableStream
:
:
Disturbed
)
;
if
(
stream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
return
ReadableByteStreamControllerPullInto
(
cx
controller
view
)
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerPullSteps
(
JSContext
*
cx
HandleNativeObject
controller
)
;
MOZ_MUST_USE
JSObject
*
ReadableStreamDefaultReader
:
:
read
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultReader
*
>
reader
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromReader
(
reader
)
)
;
SetStreamState
(
stream
StreamState
(
stream
)
|
ReadableStream
:
:
Disturbed
)
;
if
(
stream
-
>
closed
(
)
)
{
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
UndefinedHandleValue
true
)
)
;
if
(
!
iterResult
)
return
nullptr
;
RootedValue
iterResultVal
(
cx
ObjectValue
(
*
iterResult
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
iterResultVal
)
;
}
if
(
stream
-
>
errored
(
)
)
{
RootedValue
storedError
(
cx
stream
-
>
getFixedSlot
(
StreamSlot_StoredError
)
)
;
return
PromiseObject
:
:
unforgeableReject
(
cx
storedError
)
;
}
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
RootedNativeObject
controller
(
cx
ControllerFromStream
(
stream
)
)
;
return
ReadableStreamControllerPullSteps
(
cx
controller
)
;
}
static
bool
ControllerStartHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedNativeObject
controller
(
cx
TargetFromHandler
<
NativeObject
>
(
args
.
callee
(
)
)
)
;
AddControllerFlags
(
controller
ControllerFlag_Started
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
(
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
)
)
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
e
)
;
static
MOZ_MUST_USE
bool
ReadableStreamControllerError
(
JSContext
*
cx
HandleNativeObject
controller
HandleValue
e
)
;
static
bool
ControllerStartFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedNativeObject
controllerObj
(
cx
TargetFromHandler
<
NativeObject
>
(
args
.
callee
(
)
)
)
;
if
(
controllerObj
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
controller
args
.
get
(
0
)
)
;
}
if
(
StreamFromController
(
controllerObj
)
-
>
readable
(
)
)
return
ReadableStreamControllerError
(
cx
controllerObj
args
.
get
(
0
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeHighWaterMark
(
JSContext
*
cx
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
;
static
MOZ_MUST_USE
bool
ValidateAndNormalizeQueuingStrategy
(
JSContext
*
cx
HandleValue
size
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
;
static
MOZ_MUST_USE
ReadableStreamDefaultController
*
CreateReadableStreamDefaultController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingSource
HandleValue
size
HandleValue
highWaterMarkVal
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableStreamDefaultController
>
(
cx
)
;
if
(
!
controller
)
return
nullptr
;
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
underlyingSource
)
;
if
(
!
ResetQueue
(
cx
controller
)
)
return
nullptr
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
0
)
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeQueuingStrategy
(
cx
size
highWaterMarkVal
&
highWaterMark
)
)
return
nullptr
;
controller
-
>
setFixedSlot
(
DefaultControllerSlot_StrategySize
size
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
NumberValue
(
highWaterMark
)
)
;
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
return
nullptr
;
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
return
nullptr
;
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
return
nullptr
;
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
return
nullptr
;
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
return
nullptr
;
return
controller
;
}
bool
ReadableStreamDefaultController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamDefaultController
"
)
)
return
false
;
HandleValue
streamVal
=
args
.
get
(
0
)
;
if
(
!
Is
<
ReadableStream
>
(
streamVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultController
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
streamVal
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
if
(
HasController
(
stream
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_CONTROLLER_SET
)
;
return
false
;
}
RootedObject
controller
(
cx
CreateReadableStreamDefaultController
(
cx
stream
args
.
get
(
1
)
args
.
get
(
2
)
args
.
get
(
3
)
)
)
;
if
(
!
controller
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
controller
)
;
return
true
;
}
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
NativeObject
*
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamController_desiredSize_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
RootedNativeObject
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
stream
-
>
errored
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
if
(
stream
-
>
closed
(
)
)
{
args
.
rval
(
)
.
setInt32
(
0
)
;
return
true
;
}
args
.
rval
(
)
.
setNumber
(
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_desiredSize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultController
>
ReadableStreamController_desiredSize_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
VerifyControllerStateForClosing
(
JSContext
*
cx
HandleNativeObject
controller
)
{
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
close
"
)
;
return
false
;
}
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
close
"
)
;
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_close_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
!
VerifyControllerStateForClosing
(
cx
controller
)
)
return
false
;
if
(
!
ReadableStreamDefaultControllerClose
(
cx
controller
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_close
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_close_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
chunk
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_enqueue_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
close
"
)
;
return
false
;
}
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
close
"
)
;
return
false
;
}
if
(
!
ReadableStreamDefaultControllerEnqueue
(
cx
controller
args
.
get
(
0
)
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_enqueue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_enqueue_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultController_error_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamDefaultController
>
(
)
;
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
error
"
)
;
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
args
.
get
(
0
)
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamDefaultController_error
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamDefaultController
>
ReadableStreamDefaultController_error_impl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
ReadableStreamDefaultController_properties
[
]
=
{
JS_PSG
(
"
desiredSize
"
ReadableStreamDefaultController_desiredSize
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamDefaultController_methods
[
]
=
{
JS_FN
(
"
close
"
ReadableStreamDefaultController_close
0
0
)
JS_FN
(
"
enqueue
"
ReadableStreamDefaultController_enqueue
1
0
)
JS_FN
(
"
error
"
ReadableStreamDefaultController_error
1
0
)
JS_FS_END
}
;
CLASS_SPEC
(
ReadableStreamDefaultController
4
7
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerCancelSteps
(
JSContext
*
cx
HandleNativeObject
controller
HandleValue
reason
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
if
(
!
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Value
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
firstDescriptor
(
cx
)
;
firstDescriptor
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
firstDescriptor
-
>
setBytesFilled
(
0
)
;
}
}
if
(
!
ResetQueue
(
cx
controller
)
)
return
nullptr
;
RootedValue
underlyingSource
(
cx
)
;
underlyingSource
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
if
(
Is
<
TeeState
>
(
underlyingSource
)
)
{
Rooted
<
TeeState
*
>
teeState
(
cx
&
underlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
Rooted
<
ReadableStreamDefaultController
*
>
defaultController
(
cx
)
;
defaultController
=
&
controller
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamTee_Cancel
(
cx
teeState
defaultController
reason
)
;
}
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_ExternalSource
)
{
void
*
source
=
underlyingSource
.
toPrivate
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
RootedValue
rval
(
cx
)
;
rval
=
cx
-
>
runtime
(
)
-
>
readableStreamCancelCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
reason
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
rval
)
;
}
return
PromiseInvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
cancel
reason
)
;
}
inline
static
MOZ_MUST_USE
bool
DequeueValue
(
JSContext
*
cx
HandleNativeObject
container
MutableHandleValue
chunk
)
;
static
JSObject
*
ReadableStreamDefaultControllerPullSteps
(
JSContext
*
cx
HandleNativeObject
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
RootedNativeObject
queue
(
cx
)
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
if
(
val
.
isObject
(
)
)
queue
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
if
(
queue
&
&
queue
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
RootedValue
chunk
(
cx
)
;
if
(
!
DequeueValue
(
cx
controller
&
chunk
)
)
return
nullptr
;
bool
closeRequested
=
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
;
if
(
closeRequested
&
&
queue
-
>
getDenseInitializedLength
(
)
=
=
0
)
{
if
(
!
ReadableStreamCloseInternal
(
cx
stream
)
)
return
nullptr
;
}
else
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
nullptr
;
}
RootedObject
iterResultObj
(
cx
CreateIterResultObject
(
cx
chunk
false
)
)
;
if
(
!
iterResultObj
)
return
nullptr
;
RootedValue
iterResult
(
cx
ObjectValue
(
*
iterResultObj
)
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
iterResult
)
;
}
Rooted
<
PromiseObject
*
>
pendingPromise
(
cx
ReadableStreamAddReadRequest
(
cx
stream
)
)
;
if
(
!
pendingPromise
)
return
nullptr
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
nullptr
;
return
pendingPromise
;
}
static
bool
ControllerPullHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedNativeObject
controller
(
cx
TargetFromHandler
<
NativeObject
>
(
args
.
callee
(
)
)
)
;
uint32_t
flags
=
ControllerFlags
(
controller
)
;
RemoveControllerFlags
(
controller
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
;
if
(
flags
&
ControllerFlag_PullAgain
)
{
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ControllerPullFailedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedNativeObject
controller
(
cx
TargetFromHandler
<
NativeObject
>
(
args
.
callee
(
)
)
)
;
HandleValue
e
=
args
.
get
(
0
)
;
if
(
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
NativeObject
*
controller
)
;
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
NativeObject
*
controller
)
;
inline
static
MOZ_MUST_USE
bool
ReadableStreamControllerCallPullIfNeeded
(
JSContext
*
cx
HandleNativeObject
controller
)
{
bool
shouldPull
=
ReadableStreamControllerShouldCallPull
(
controller
)
;
if
(
!
shouldPull
)
return
true
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_Pulling
)
{
AddControllerFlags
(
controller
ControllerFlag_PullAgain
)
;
return
true
;
}
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_PullAgain
)
)
;
AddControllerFlags
(
controller
ControllerFlag_Pulling
)
;
RootedObject
pullPromise
(
cx
)
;
RootedValue
underlyingSource
(
cx
)
;
underlyingSource
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
Is
<
TeeState
>
(
underlyingSource
)
)
{
Rooted
<
TeeState
*
>
teeState
(
cx
&
underlyingSource
.
toObject
(
)
.
as
<
TeeState
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
pullPromise
=
ReadableStreamTee_Pull
(
cx
teeState
stream
)
;
}
else
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_ExternalSource
)
{
void
*
source
=
underlyingSource
.
toPrivate
(
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
cx
-
>
runtime
(
)
-
>
readableStreamDataRequestCallback
(
cx
stream
source
stream
-
>
embeddingFlags
(
)
desiredSize
)
;
pullPromise
=
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
;
}
else
{
pullPromise
=
PromiseInvokeOrNoop
(
cx
underlyingSource
cx
-
>
names
(
)
.
pull
controllerVal
)
;
}
if
(
!
pullPromise
)
return
false
;
RootedObject
onPullFulfilled
(
cx
NewHandler
(
cx
ControllerPullHandler
controller
)
)
;
if
(
!
onPullFulfilled
)
return
false
;
RootedObject
onPullRejected
(
cx
NewHandler
(
cx
ControllerPullFailedHandler
controller
)
)
;
if
(
!
onPullRejected
)
return
false
;
return
JS
:
:
AddPromiseReactions
(
cx
pullPromise
onPullFulfilled
onPullRejected
)
;
}
static
bool
ReadableStreamControllerShouldCallPull
(
NativeObject
*
controller
)
{
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
if
(
!
stream
-
>
readable
(
)
)
return
false
;
uint32_t
flags
=
ControllerFlags
(
controller
)
;
if
(
flags
&
ControllerFlag_CloseRequested
)
return
false
;
if
(
!
(
flags
&
ControllerFlag_Started
)
)
return
false
;
if
(
stream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
return
true
;
double
desiredSize
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
return
desiredSize
>
0
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerClose
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
AddControllerFlags
(
controller
ControllerFlag_CloseRequested
)
;
RootedNativeObject
queue
(
cx
)
;
queue
=
&
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
if
(
queue
-
>
getDenseInitializedLength
(
)
=
=
0
)
return
ReadableStreamCloseInternal
(
cx
stream
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
EnqueueValueWithSize
(
JSContext
*
cx
HandleNativeObject
container
HandleValue
value
HandleValue
sizeVal
)
;
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
chunk
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
if
(
stream
-
>
locked
(
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
chunk
false
)
)
return
false
;
}
else
{
RootedValue
chunkSize
(
cx
NumberValue
(
1
)
)
;
bool
success
=
true
;
RootedValue
strategySize
(
cx
)
;
strategySize
=
controller
-
>
getFixedSlot
(
DefaultControllerSlot_StrategySize
)
;
if
(
!
strategySize
.
isUndefined
(
)
)
{
success
=
Call
(
cx
strategySize
UndefinedHandleValue
chunk
&
chunkSize
)
;
}
if
(
success
)
success
=
EnqueueValueWithSize
(
cx
controller
chunk
chunkSize
)
;
if
(
!
success
)
{
RootedValue
exn
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
exn
)
)
return
false
;
if
(
!
ReadableStreamDefaultControllerErrorIfNeeded
(
cx
controller
exn
)
)
return
false
;
return
false
;
}
}
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
false
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
HandleNativeObject
controller
)
;
static
MOZ_MUST_USE
bool
ReadableStreamControllerError
(
JSContext
*
cx
HandleNativeObject
controller
HandleValue
e
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
if
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
{
Rooted
<
ReadableByteStreamController
*
>
byteStreamController
(
cx
)
;
byteStreamController
=
&
controller
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
byteStreamController
)
)
return
false
;
}
if
(
!
ResetQueue
(
cx
controller
)
)
return
false
;
return
ReadableStreamErrorInternal
(
cx
stream
e
)
;
}
static
MOZ_MUST_USE
bool
ReadableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
cx
Handle
<
ReadableStreamDefaultController
*
>
controller
HandleValue
e
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
if
(
stream
-
>
readable
(
)
)
return
ReadableStreamControllerError
(
cx
controller
e
)
;
return
true
;
}
static
MOZ_MUST_USE
double
ReadableStreamControllerGetDesiredSizeUnchecked
(
NativeObject
*
controller
)
{
#
if
DEBUG
ReadableStream
*
stream
=
StreamFromController
(
controller
)
;
MOZ_ASSERT
(
!
(
stream
-
>
errored
(
)
|
|
stream
-
>
closed
(
)
)
)
;
#
endif
double
strategyHWM
=
controller
-
>
getFixedSlot
(
ControllerSlot_StrategyHWM
)
.
toNumber
(
)
;
double
queueSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
return
strategyHWM
-
queueSize
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
underlyingByteSource
HandleValue
highWaterMarkVal
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
;
if
(
!
controller
)
return
nullptr
;
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
underlyingByteSource
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
0
)
)
;
if
(
!
ReadableByteStreamControllerClearPendingPullIntos
(
cx
controller
)
)
return
nullptr
;
if
(
!
ResetQueue
(
cx
controller
)
)
return
nullptr
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
=
=
0
)
;
double
highWaterMark
;
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
&
highWaterMark
)
)
return
nullptr
;
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
NumberValue
(
highWaterMark
)
)
;
RootedValue
autoAllocateChunkSize
(
cx
)
;
if
(
!
GetProperty
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
autoAllocateChunkSize
&
autoAllocateChunkSize
)
)
{
return
nullptr
;
}
if
(
!
autoAllocateChunkSize
.
isUndefined
(
)
)
{
if
(
!
IsInteger
(
autoAllocateChunkSize
)
|
|
autoAllocateChunkSize
.
toNumber
(
)
<
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE
)
;
return
nullptr
;
}
}
controller
-
>
setFixedSlot
(
ByteControllerSlot_AutoAllocateSize
autoAllocateChunkSize
)
;
if
(
!
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
)
return
nullptr
;
RootedValue
startResult
(
cx
)
;
RootedValue
controllerVal
(
cx
ObjectValue
(
*
controller
)
)
;
if
(
!
InvokeOrNoop
(
cx
underlyingByteSource
cx
-
>
names
(
)
.
start
controllerVal
&
startResult
)
)
return
nullptr
;
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
startResult
)
)
;
if
(
!
startPromise
)
return
nullptr
;
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
return
nullptr
;
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
return
nullptr
;
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
return
nullptr
;
return
controller
;
}
bool
ReadableByteStreamController
:
:
hasExternalSource
(
)
{
return
ControllerFlags
(
this
)
&
ControllerFlag_ExternalSource
;
}
bool
ReadableByteStreamController
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableByteStreamController
"
)
)
return
false
;
HandleValue
streamVal
=
args
.
get
(
0
)
;
if
(
!
Is
<
ReadableStream
>
(
streamVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamDefaultController
"
"
ReadableStream
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableStream
*
>
stream
(
cx
&
streamVal
.
toObject
(
)
.
as
<
ReadableStream
>
(
)
)
;
if
(
HasController
(
stream
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_CONTROLLER_SET
)
;
return
false
;
}
RootedObject
controller
(
cx
CreateReadableByteStreamController
(
cx
stream
args
.
get
(
1
)
args
.
get
(
2
)
)
)
;
if
(
!
controller
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
controller
)
;
return
true
;
}
static
MOZ_MUST_USE
ReadableByteStreamController
*
CreateReadableByteStreamController
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
underlyingSource
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
NewBuiltinClassInstance
<
ReadableByteStreamController
>
(
cx
)
;
if
(
!
controller
)
return
nullptr
;
controller
-
>
setFixedSlot
(
ControllerSlot_Stream
ObjectValue
(
*
stream
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_UnderlyingSource
PrivateValue
(
underlyingSource
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_Flags
Int32Value
(
ControllerFlag_ExternalSource
)
)
;
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
Int32Value
(
0
)
)
;
controller
-
>
setFixedSlot
(
ControllerSlot_StrategyHWM
Int32Value
(
0
)
)
;
if
(
!
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
)
return
nullptr
;
RootedObject
startPromise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
UndefinedHandleValue
)
)
;
if
(
!
startPromise
)
return
nullptr
;
RootedObject
onStartFulfilled
(
cx
NewHandler
(
cx
ControllerStartHandler
controller
)
)
;
if
(
!
onStartFulfilled
)
return
nullptr
;
RootedObject
onStartRejected
(
cx
NewHandler
(
cx
ControllerStartFailedHandler
controller
)
)
;
if
(
!
onStartRejected
)
return
nullptr
;
if
(
!
JS
:
:
AddPromiseReactions
(
cx
startPromise
onStartFulfilled
onStartRejected
)
)
return
nullptr
;
return
controller
;
}
static
MOZ_MUST_USE
ReadableStreamBYOBRequest
*
CreateReadableStreamBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
view
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamController_byobRequest_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
Value
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_BYOBRequest
)
;
RootedValue
byobRequest
(
cx
val
)
;
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
byobRequest
.
isUndefined
(
)
&
&
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
firstDescriptor
(
cx
)
;
firstDescriptor
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
RootedArrayBufferObject
buffer
(
cx
firstDescriptor
-
>
buffer
(
)
)
;
uint32_t
bytesFilled
=
firstDescriptor
-
>
bytesFilled
(
)
;
RootedObject
view
(
cx
JS_NewUint8ArrayWithBuffer
(
cx
buffer
firstDescriptor
-
>
byteOffset
(
)
+
bytesFilled
firstDescriptor
-
>
byteLength
(
)
-
bytesFilled
)
)
;
if
(
!
view
)
return
false
;
RootedObject
request
(
cx
CreateReadableStreamBYOBRequest
(
cx
controller
view
)
)
;
if
(
!
request
)
return
false
;
byobRequest
=
ObjectValue
(
*
request
)
;
controller
-
>
setFixedSlot
(
ByteControllerSlot_BYOBRequest
byobRequest
)
;
}
args
.
rval
(
)
.
set
(
byobRequest
)
;
return
true
;
}
static
bool
ReadableByteStreamController_byobRequest
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableByteStreamController
>
ReadableByteStreamController_byobRequest_impl
>
(
cx
args
)
;
}
static
bool
ReadableByteStreamController_desiredSize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableByteStreamController
>
ReadableStreamController_desiredSize_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClose
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamController_close_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
if
(
!
VerifyControllerStateForClosing
(
cx
controller
)
)
return
false
;
if
(
!
ReadableByteStreamControllerClose
(
cx
controller
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableByteStreamController_close
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableByteStreamController
>
ReadableByteStreamController_close_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
chunk
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamController_enqueue_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
HandleValue
chunkVal
=
args
.
get
(
0
)
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
enqueue
"
)
;
return
false
;
}
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
enqueue
"
)
;
return
false
;
}
if
(
!
chunkVal
.
isObject
(
)
|
|
!
JS_IsArrayBufferViewObject
(
&
chunkVal
.
toObject
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK
"
ReadableByteStreamController
#
enqueue
"
)
;
return
false
;
}
RootedObject
chunk
(
cx
&
chunkVal
.
toObject
(
)
)
;
if
(
!
ReadableByteStreamControllerEnqueue
(
cx
controller
chunk
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableByteStreamController_enqueue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableByteStreamController
>
ReadableByteStreamController_enqueue_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamController_error_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
HandleValue
e
=
args
.
get
(
0
)
;
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
error
"
)
;
return
false
;
}
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableByteStreamController_error
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableByteStreamController
>
ReadableByteStreamController_error_impl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
ReadableByteStreamController_properties
[
]
=
{
JS_PSG
(
"
byobRequest
"
ReadableByteStreamController_byobRequest
0
)
JS_PSG
(
"
desiredSize
"
ReadableByteStreamController_desiredSize
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableByteStreamController_methods
[
]
=
{
JS_FN
(
"
close
"
ReadableByteStreamController_close
0
0
)
JS_FN
(
"
enqueue
"
ReadableByteStreamController_enqueue
1
0
)
JS_FN
(
"
error
"
ReadableByteStreamController_error
1
0
)
JS_FS_END
}
;
static
void
ReadableByteStreamControllerFinalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
ReadableByteStreamController
&
controller
=
obj
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
controller
.
getFixedSlot
(
ControllerSlot_Flags
)
.
isUndefined
(
)
)
return
;
uint32_t
flags
=
ControllerFlags
(
&
controller
)
;
if
(
!
(
flags
&
ControllerFlag_ExternalSource
)
)
return
;
uint8_t
embeddingFlags
=
flags
>
>
ControllerEmbeddingFlagsOffset
;
void
*
underlyingSource
=
controller
.
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
obj
-
>
runtimeFromAnyThread
(
)
-
>
readableStreamFinalizeCallback
(
underlyingSource
embeddingFlags
)
;
}
static
const
ClassOps
ReadableByteStreamControllerClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ReadableByteStreamControllerFinalize
nullptr
nullptr
nullptr
nullptr
}
;
CLASS_SPEC
(
ReadableByteStreamController
3
9
ClassSpec
:
:
DontDefineConstructor
JSCLASS_BACKGROUND_FINALIZE
&
ReadableByteStreamControllerClassOps
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
HandleNativeObject
controller
)
;
static
JSObject
*
ReadableByteStreamControllerPullSteps
(
JSContext
*
cx
HandleNativeObject
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
ReadableStreamHasDefaultReader
(
stream
)
)
;
RootedValue
val
(
cx
)
;
double
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
if
(
queueTotalSize
>
0
)
{
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
;
RootedObject
view
(
cx
)
;
if
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
{
val
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
void
*
underlyingSource
=
val
.
toPrivate
(
)
;
view
=
JS_NewUint8Array
(
cx
queueTotalSize
)
;
if
(
!
view
)
return
nullptr
;
size_t
bytesWritten
;
{
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
void
*
buffer
=
JS_GetArrayBufferViewData
(
view
&
dummy
noGC
)
;
auto
cb
=
cx
-
>
runtime
(
)
-
>
readableStreamWriteIntoReadRequestCallback
;
MOZ_ASSERT
(
cb
)
;
cb
(
cx
stream
underlyingSource
stream
-
>
embeddingFlags
(
)
buffer
queueTotalSize
&
bytesWritten
)
;
}
queueTotalSize
=
queueTotalSize
-
bytesWritten
;
}
else
{
val
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
entry
(
cx
ShiftFromList
<
ByteStreamChunk
>
(
cx
queue
)
)
;
MOZ_ASSERT
(
entry
)
;
queueTotalSize
=
queueTotalSize
-
entry
-
>
byteLength
(
)
;
RootedObject
buffer
(
cx
entry
-
>
buffer
(
)
)
;
uint32_t
byteOffset
=
entry
-
>
byteOffset
(
)
;
view
=
JS_NewUint8ArrayWithBuffer
(
cx
buffer
byteOffset
entry
-
>
byteLength
(
)
)
;
if
(
!
view
)
return
nullptr
;
}
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
Int32Value
(
queueTotalSize
)
)
;
if
(
!
ReadableByteStreamControllerHandleQueueDrain
(
cx
controller
)
)
return
nullptr
;
val
.
setObject
(
*
view
)
;
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
val
false
)
)
;
if
(
!
iterResult
)
return
nullptr
;
val
.
setObject
(
*
iterResult
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
val
)
;
}
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_AutoAllocateSize
)
;
if
(
!
val
.
isUndefined
(
)
)
{
double
autoAllocateChunkSize
=
val
.
toNumber
(
)
;
RootedObject
bufferObj
(
cx
JS_NewArrayBuffer
(
cx
autoAllocateChunkSize
)
)
;
if
(
!
bufferObj
)
return
PromiseRejectedWithPendingError
(
cx
)
;
RootedArrayBufferObject
buffer
(
cx
&
bufferObj
-
>
as
<
ArrayBufferObject
>
(
)
)
;
RootedObject
pullIntoDescriptor
(
cx
)
;
pullIntoDescriptor
=
PullIntoDescriptor
:
:
create
(
cx
buffer
0
autoAllocateChunkSize
0
1
nullptr
ReaderType_Default
)
;
if
(
!
pullIntoDescriptor
)
return
PromiseRejectedWithPendingError
(
cx
)
;
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
val
=
ObjectValue
(
*
pullIntoDescriptor
)
;
if
(
!
AppendToList
(
cx
pendingPullIntos
val
)
)
return
nullptr
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
ReadableStreamAddReadRequest
(
cx
stream
)
)
;
if
(
!
promise
)
return
nullptr
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
nullptr
;
return
promise
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableStreamControllerPullSteps
(
JSContext
*
cx
HandleNativeObject
controller
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
controller
)
)
;
if
(
controller
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
return
ReadableStreamDefaultControllerPullSteps
(
cx
controller
)
;
return
ReadableByteStreamControllerPullSteps
(
cx
controller
)
;
}
static
MOZ_MUST_USE
ReadableStreamBYOBRequest
*
CreateReadableStreamBYOBRequest
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
view
)
{
MOZ_ASSERT
(
controller
)
;
MOZ_ASSERT
(
JS_IsArrayBufferViewObject
(
view
)
)
;
Rooted
<
ReadableStreamBYOBRequest
*
>
request
(
cx
)
;
request
=
NewBuiltinClassInstance
<
ReadableStreamBYOBRequest
>
(
cx
)
;
if
(
!
request
)
return
nullptr
;
request
-
>
setFixedSlot
(
BYOBRequestSlot_Controller
ObjectValue
(
*
controller
)
)
;
request
-
>
setFixedSlot
(
BYOBRequestSlot_View
ObjectValue
(
*
view
)
)
;
return
request
;
}
bool
ReadableStreamBYOBRequest
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
controllerVal
=
args
.
get
(
0
)
;
HandleValue
viewVal
=
args
.
get
(
1
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ReadableStreamBYOBRequest
"
)
)
return
false
;
if
(
!
Is
<
ReadableByteStreamController
>
(
controllerVal
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamBYOBRequest
"
"
ReadableByteStreamController
"
args
.
get
(
0
)
)
;
return
false
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
controllerVal
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
if
(
!
viewVal
.
isObject
(
)
|
|
!
JS_IsArrayBufferViewObject
(
&
viewVal
.
toObject
(
)
)
)
{
ReportArgTypeError
(
cx
"
ReadableStreamBYOBRequest
"
"
ArrayBuffer
view
"
args
.
get
(
1
)
)
;
return
false
;
}
Rooted
<
ArrayBufferViewObject
*
>
view
(
cx
&
viewVal
.
toObject
(
)
.
as
<
ArrayBufferViewObject
>
(
)
)
;
RootedObject
request
(
cx
CreateReadableStreamBYOBRequest
(
cx
controller
view
)
)
;
if
(
!
request
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
request
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableStreamBYOBRequest_view_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
NativeObject
*
request
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
args
.
rval
(
)
.
set
(
request
-
>
getFixedSlot
(
BYOBRequestSlot_View
)
)
;
return
true
;
}
static
bool
ReadableStreamBYOBRequest_view
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamBYOBRequest
>
ReadableStreamBYOBRequest_view_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespond
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleValue
bytesWrittenVal
)
;
static
MOZ_MUST_USE
bool
ReadableStreamBYOBRequest_respond_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamBYOBRequest
*
>
request
(
cx
)
;
request
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamBYOBRequest
>
(
)
;
HandleValue
bytesWritten
=
args
.
get
(
0
)
;
RootedValue
controllerVal
(
cx
request
-
>
getFixedSlot
(
BYOBRequestSlot_Controller
)
)
;
if
(
controllerVal
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER
"
respond
"
)
;
return
false
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
controllerVal
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
if
(
!
ReadableByteStreamControllerRespond
(
cx
controller
bytesWritten
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamBYOBRequest_respond
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamBYOBRequest
>
ReadableStreamBYOBRequest_respond_impl
>
(
cx
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondWithNewView
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
view
)
;
static
MOZ_MUST_USE
bool
ReadableStreamBYOBRequest_respondWithNewView_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
ReadableStreamBYOBRequest
*
>
request
(
cx
)
;
request
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ReadableStreamBYOBRequest
>
(
)
;
HandleValue
viewVal
=
args
.
get
(
0
)
;
RootedValue
controllerVal
(
cx
request
-
>
getFixedSlot
(
BYOBRequestSlot_Controller
)
)
;
if
(
controllerVal
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER
"
respondWithNewView
"
)
;
return
false
;
}
if
(
!
viewVal
.
isObject
(
)
|
|
!
JS_IsArrayBufferViewObject
(
&
viewVal
.
toObject
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK
"
ReadableStreamBYOBRequest
#
respondWithNewView
"
)
;
return
false
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
controllerVal
.
toObject
(
)
.
as
<
ReadableByteStreamController
>
(
)
;
RootedObject
view
(
cx
&
viewVal
.
toObject
(
)
)
;
if
(
!
ReadableByteStreamControllerRespondWithNewView
(
cx
controller
view
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ReadableStreamBYOBRequest_respondWithNewView
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
Is
<
ReadableStreamBYOBRequest
>
ReadableStreamBYOBRequest_respondWithNewView_impl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
ReadableStreamBYOBRequest_properties
[
]
=
{
JS_PSG
(
"
view
"
ReadableStreamBYOBRequest_view
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
ReadableStreamBYOBRequest_methods
[
]
=
{
JS_FN
(
"
respond
"
ReadableStreamBYOBRequest_respond
1
0
)
JS_FN
(
"
respondWithNewView
"
ReadableStreamBYOBRequest_respondWithNewView
1
0
)
JS_FS_END
}
;
CLASS_SPEC
(
ReadableStreamBYOBRequest
3
2
ClassSpec
:
:
DontDefineConstructor
0
JS_NULL_CLASS_OPS
)
;
static
void
ReadableByteStreamControllerInvalidateBYOBRequest
(
NativeObject
*
controller
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClearPendingPullIntos
(
JSContext
*
cx
HandleNativeObject
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
ReadableByteStreamControllerInvalidateBYOBRequest
(
controller
)
;
return
SetNewList
(
cx
controller
ByteControllerSlot_PendingPullIntos
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerClose
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
double
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
if
(
queueTotalSize
>
0
)
{
AddControllerFlags
(
controller
ControllerFlag_CloseRequested
)
;
return
true
;
}
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
Rooted
<
PullIntoDescriptor
*
>
firstPendingPullInto
(
cx
)
;
firstPendingPullInto
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
if
(
firstPendingPullInto
-
>
bytesFilled
(
)
>
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL
)
;
RootedValue
e
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
e
)
)
return
false
;
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
return
false
;
return
false
;
}
}
return
ReadableStreamCloseInternal
(
cx
stream
)
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerConvertPullIntoDescriptor
(
JSContext
*
cx
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerCommitPullIntoDescriptor
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
)
{
MOZ_ASSERT
(
!
stream
-
>
errored
(
)
)
;
bool
done
=
false
;
if
(
stream
-
>
closed
(
)
)
{
MOZ_ASSERT
(
pullIntoDescriptor
-
>
bytesFilled
(
)
=
=
0
)
;
done
=
true
;
}
RootedObject
filledView
(
cx
)
;
filledView
=
ReadableByteStreamControllerConvertPullIntoDescriptor
(
cx
pullIntoDescriptor
)
;
if
(
!
filledView
)
return
false
;
uint32_t
readerType
=
pullIntoDescriptor
-
>
readerType
(
)
;
RootedValue
filledViewVal
(
cx
ObjectValue
(
*
filledView
)
)
;
if
(
readerType
=
=
ReaderType_Default
)
{
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
filledViewVal
done
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
readerType
=
=
ReaderType_BYOB
)
;
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
filledViewVal
done
)
)
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerConvertPullIntoDescriptor
(
JSContext
*
cx
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
)
{
uint32_t
bytesFilled
=
pullIntoDescriptor
-
>
bytesFilled
(
)
;
uint32_t
elementSize
=
pullIntoDescriptor
-
>
elementSize
(
)
;
MOZ_ASSERT
(
bytesFilled
<
=
pullIntoDescriptor
-
>
byteLength
(
)
)
;
MOZ_ASSERT
(
bytesFilled
%
elementSize
=
=
0
)
;
RootedObject
ctor
(
cx
pullIntoDescriptor
-
>
ctor
(
)
)
;
if
(
!
ctor
)
{
ctor
=
GlobalObject
:
:
getOrCreateConstructor
(
cx
JSProto_Uint8Array
)
;
if
(
!
ctor
)
return
nullptr
;
}
RootedObject
buffer
(
cx
pullIntoDescriptor
-
>
buffer
(
)
)
;
uint32_t
byteOffset
=
pullIntoDescriptor
-
>
byteOffset
(
)
;
FixedConstructArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
buffer
)
;
args
[
1
]
.
setInt32
(
byteOffset
)
;
args
[
2
]
.
setInt32
(
bytesFilled
/
elementSize
)
;
return
JS_New
(
cx
ctor
args
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerEnqueueChunkToQueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
;
static
MOZ_MUST_USE
ArrayBufferObject
*
TransferArrayBuffer
(
JSContext
*
cx
HandleObject
buffer
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerEnqueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
chunk
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
uint32_t
byteOffset
;
uint32_t
byteLength
;
if
(
chunk
-
>
is
<
ArrayBufferObject
>
(
)
)
{
buffer
=
&
chunk
-
>
as
<
ArrayBufferObject
>
(
)
;
byteOffset
=
0
;
byteLength
=
buffer
-
>
byteLength
(
)
;
}
else
{
bool
dummy
;
JSObject
*
bufferObj
=
JS_GetArrayBufferViewBuffer
(
cx
chunk
&
dummy
)
;
if
(
!
bufferObj
)
return
false
;
buffer
=
&
bufferObj
-
>
as
<
ArrayBufferObject
>
(
)
;
byteOffset
=
JS_GetArrayBufferViewByteOffset
(
chunk
)
;
byteLength
=
JS_GetArrayBufferViewByteLength
(
chunk
)
;
}
RootedArrayBufferObject
transferredBuffer
(
cx
TransferArrayBuffer
(
cx
buffer
)
)
;
if
(
!
transferredBuffer
)
return
false
;
if
(
ReadableStreamHasDefaultReader
(
stream
)
)
{
if
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
{
if
(
!
ReadableByteStreamControllerEnqueueChunkToQueue
(
cx
controller
transferredBuffer
byteOffset
byteLength
)
)
{
return
false
;
}
}
else
{
#
if
DEBUG
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
queue
-
>
getDenseInitializedLength
(
)
=
=
0
)
;
#
endif
RootedObject
transferredView
(
cx
JS_NewUint8ArrayWithBuffer
(
cx
transferredBuffer
byteOffset
byteLength
)
)
;
if
(
!
transferredView
)
return
false
;
RootedValue
chunk
(
cx
ObjectValue
(
*
transferredView
)
)
;
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
chunk
false
)
)
return
false
;
}
}
else
if
(
ReadableStreamHasBYOBReader
(
stream
)
)
{
if
(
!
ReadableByteStreamControllerEnqueueChunkToQueue
(
cx
controller
transferredBuffer
byteOffset
byteLength
)
)
{
return
false
;
}
if
(
!
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
(
cx
controller
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
!
stream
-
>
locked
(
)
)
;
if
(
!
ReadableByteStreamControllerEnqueueChunkToQueue
(
cx
controller
transferredBuffer
byteOffset
byteLength
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerEnqueueChunkToQueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
buffer
uint32_t
byteOffset
uint32_t
byteLength
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
"
must
operate
on
ReadableByteStreamController
"
)
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
chunk
(
cx
)
;
chunk
=
ByteStreamChunk
:
:
create
(
cx
buffer
byteOffset
byteLength
)
;
if
(
!
chunk
)
return
false
;
RootedValue
chunkVal
(
cx
ObjectValue
(
*
chunk
)
)
;
if
(
!
AppendToList
(
cx
queue
chunkVal
)
)
return
false
;
double
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
queueTotalSize
+
byteLength
)
)
;
return
true
;
}
static
void
ReadableByteStreamControllerFillHeadPullIntoDescriptor
(
ReadableByteStreamController
*
controller
uint32_t
size
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
)
{
#
if
DEBUG
Value
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
NativeObject
*
pendingPullIntos
=
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
=
=
0
|
|
&
pendingPullIntos
-
>
getDenseElement
(
0
)
.
toObject
(
)
=
=
pullIntoDescriptor
)
;
#
endif
ReadableByteStreamControllerInvalidateBYOBRequest
(
controller
)
;
pullIntoDescriptor
-
>
setBytesFilled
(
pullIntoDescriptor
-
>
bytesFilled
(
)
+
size
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerFillPullIntoDescriptorFromQueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
bool
*
ready
)
{
*
ready
=
false
;
uint32_t
elementSize
=
pullIntoDescriptor
-
>
elementSize
(
)
;
uint32_t
bytesFilled
=
pullIntoDescriptor
-
>
bytesFilled
(
)
;
uint32_t
currentAlignedBytes
=
bytesFilled
-
(
bytesFilled
%
elementSize
)
;
uint32_t
byteLength
=
pullIntoDescriptor
-
>
byteLength
(
)
;
Value
sizeVal
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
;
uint32_t
queueTotalSize
=
JS
:
:
ToUint32
(
sizeVal
.
toNumber
(
)
)
;
uint32_t
maxBytesToCopy
=
std
:
:
min
(
queueTotalSize
byteLength
-
bytesFilled
)
;
uint32_t
maxBytesFilled
=
bytesFilled
+
maxBytesToCopy
;
uint32_t
maxAlignedBytes
=
maxBytesFilled
-
(
maxBytesFilled
%
elementSize
)
;
uint32_t
totalBytesToCopyRemaining
=
maxBytesToCopy
;
if
(
maxAlignedBytes
>
currentAlignedBytes
)
{
totalBytesToCopyRemaining
=
maxAlignedBytes
-
bytesFilled
;
*
ready
=
true
;
}
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_ExternalSource
)
{
if
(
!
ready
)
return
true
;
Value
val
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
void
*
underlyingSource
=
val
.
toPrivate
(
)
;
RootedArrayBufferObject
targetBuffer
(
cx
pullIntoDescriptor
-
>
buffer
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
size_t
bytesWritten
;
{
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
uint8_t
*
buffer
=
JS_GetArrayBufferData
(
targetBuffer
&
dummy
noGC
)
;
buffer
+
=
bytesFilled
;
auto
cb
=
cx
-
>
runtime
(
)
-
>
readableStreamWriteIntoReadRequestCallback
;
MOZ_ASSERT
(
cb
)
;
cb
(
cx
stream
underlyingSource
stream
-
>
embeddingFlags
(
)
buffer
totalBytesToCopyRemaining
&
bytesWritten
)
;
pullIntoDescriptor
-
>
setBytesFilled
(
bytesFilled
+
bytesWritten
)
;
}
queueTotalSize
-
=
bytesWritten
;
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
Int32Value
(
queueTotalSize
)
)
;
return
true
;
}
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
ByteStreamChunk
*
>
headOfQueue
(
cx
)
;
while
(
totalBytesToCopyRemaining
>
0
)
{
MOZ_ASSERT
(
queue
-
>
getDenseInitializedLength
(
)
!
=
0
)
;
headOfQueue
=
PeekList
<
ByteStreamChunk
>
(
queue
)
;
uint32_t
byteLength
=
headOfQueue
-
>
byteLength
(
)
;
uint32_t
bytesToCopy
=
std
:
:
min
(
totalBytesToCopyRemaining
byteLength
)
;
uint32_t
destStart
=
pullIntoDescriptor
-
>
byteOffset
(
)
+
bytesFilled
;
RootedArrayBufferObject
sourceBuffer
(
cx
headOfQueue
-
>
buffer
(
)
)
;
uint32_t
sourceOffset
=
headOfQueue
-
>
byteOffset
(
)
;
RootedArrayBufferObject
targetBuffer
(
cx
pullIntoDescriptor
-
>
buffer
(
)
)
;
ArrayBufferObject
:
:
copyData
(
targetBuffer
destStart
sourceBuffer
sourceOffset
bytesToCopy
)
;
if
(
byteLength
=
=
bytesToCopy
)
{
headOfQueue
=
ShiftFromList
<
ByteStreamChunk
>
(
cx
queue
)
;
MOZ_ASSERT
(
headOfQueue
)
;
}
else
{
headOfQueue
-
>
SetByteOffset
(
sourceOffset
+
bytesToCopy
)
;
headOfQueue
-
>
SetByteLength
(
byteLength
-
bytesToCopy
)
;
}
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
queueTotalSize
-
=
bytesToCopy
;
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
queueTotalSize
)
)
;
ReadableByteStreamControllerFillHeadPullIntoDescriptor
(
controller
bytesToCopy
pullIntoDescriptor
)
;
bytesFilled
+
=
bytesToCopy
;
MOZ_ASSERT
(
bytesFilled
=
=
pullIntoDescriptor
-
>
bytesFilled
(
)
)
;
totalBytesToCopyRemaining
-
=
bytesToCopy
;
}
if
(
!
*
ready
)
{
MOZ_ASSERT
(
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
=
=
0
)
;
MOZ_ASSERT
(
bytesFilled
>
0
"
should
have
filled
some
bytes
"
)
;
MOZ_ASSERT
(
bytesFilled
<
elementSize
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
cx
HandleNativeObject
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
double
totalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
bool
closeRequested
=
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
;
if
(
totalSize
=
=
0
&
&
closeRequested
)
{
return
ReadableStreamCloseInternal
(
cx
stream
)
;
}
return
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
;
}
static
void
ReadableByteStreamControllerInvalidateBYOBRequest
(
NativeObject
*
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Value
byobRequestVal
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_BYOBRequest
)
;
if
(
byobRequestVal
.
isUndefined
(
)
)
return
;
NativeObject
*
byobRequest
=
&
byobRequestVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
byobRequest
-
>
setFixedSlot
(
BYOBRequestSlot_Controller
UndefinedValue
(
)
)
;
byobRequest
-
>
setFixedSlot
(
BYOBRequestSlot_View
UndefinedValue
(
)
)
;
controller
-
>
setFixedSlot
(
ByteControllerSlot_BYOBRequest
UndefinedValue
(
)
)
;
}
static
MOZ_MUST_USE
PullIntoDescriptor
*
ReadableByteStreamControllerShiftPendingPullInto
(
JSContext
*
cx
HandleNativeObject
controller
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
)
{
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
PullIntoDescriptor
*
>
pullIntoDescriptor
(
cx
)
;
while
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
double
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
if
(
queueTotalSize
=
=
0
)
return
true
;
pullIntoDescriptor
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
bool
ready
;
if
(
!
ReadableByteStreamControllerFillPullIntoDescriptorFromQueue
(
cx
controller
pullIntoDescriptor
&
ready
)
)
{
return
false
;
}
if
(
ready
)
{
if
(
!
ReadableByteStreamControllerShiftPendingPullInto
(
cx
controller
)
)
return
false
;
if
(
!
ReadableByteStreamControllerCommitPullIntoDescriptor
(
cx
stream
pullIntoDescriptor
)
)
{
return
false
;
}
}
}
return
true
;
}
static
MOZ_MUST_USE
JSObject
*
ReadableByteStreamControllerPullInto
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
Handle
<
ArrayBufferViewObject
*
>
view
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
uint32_t
elementSize
=
1
;
RootedObject
ctor
(
cx
)
;
if
(
view
-
>
is
<
TypedArrayObject
>
(
)
)
{
JSProtoKey
protoKey
=
StandardProtoKeyOrNull
(
view
)
;
MOZ_ASSERT
(
protoKey
)
;
ctor
=
GlobalObject
:
:
getOrCreateConstructor
(
cx
protoKey
)
;
if
(
!
ctor
)
return
nullptr
;
elementSize
=
1
<
<
TypedArrayShift
(
view
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
)
;
}
else
{
ctor
=
GlobalObject
:
:
getOrCreateConstructor
(
cx
JSProto_DataView
)
;
if
(
!
ctor
)
return
nullptr
;
}
bool
dummy
;
RootedArrayBufferObject
buffer
(
cx
&
JS_GetArrayBufferViewBuffer
(
cx
view
&
dummy
)
-
>
as
<
ArrayBufferObject
>
(
)
)
;
if
(
!
buffer
)
return
nullptr
;
uint32_t
byteOffset
=
JS_GetArrayBufferViewByteOffset
(
view
)
;
uint32_t
byteLength
=
JS_GetArrayBufferViewByteLength
(
view
)
;
Rooted
<
PullIntoDescriptor
*
>
pullIntoDescriptor
(
cx
)
;
pullIntoDescriptor
=
PullIntoDescriptor
:
:
create
(
cx
buffer
byteOffset
byteLength
0
elementSize
ctor
ReaderType_BYOB
)
;
if
(
!
pullIntoDescriptor
)
return
nullptr
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
{
RootedArrayBufferObject
transferredBuffer
(
cx
TransferArrayBuffer
(
cx
buffer
)
)
;
if
(
!
transferredBuffer
)
return
nullptr
;
pullIntoDescriptor
-
>
setBuffer
(
transferredBuffer
)
;
val
=
ObjectValue
(
*
pullIntoDescriptor
)
;
if
(
!
AppendToList
(
cx
pendingPullIntos
val
)
)
return
nullptr
;
return
ReadableStreamAddReadIntoRequest
(
cx
stream
)
;
}
if
(
stream
-
>
closed
(
)
)
{
FixedConstructArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
buffer
)
;
args
[
1
]
.
setInt32
(
byteOffset
)
;
args
[
2
]
.
setInt32
(
0
)
;
RootedObject
emptyView
(
cx
JS_New
(
cx
ctor
args
)
)
;
if
(
!
emptyView
)
return
nullptr
;
RootedValue
val
(
cx
ObjectValue
(
*
emptyView
)
)
;
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
val
true
)
)
;
if
(
!
iterResult
)
return
nullptr
;
val
=
ObjectValue
(
*
iterResult
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
val
)
;
}
double
queueTotalSize
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
if
(
queueTotalSize
>
0
)
{
bool
ready
;
if
(
!
ReadableByteStreamControllerFillPullIntoDescriptorFromQueue
(
cx
controller
pullIntoDescriptor
&
ready
)
)
{
return
nullptr
;
}
if
(
ready
)
{
RootedObject
filledView
(
cx
)
;
filledView
=
ReadableByteStreamControllerConvertPullIntoDescriptor
(
cx
pullIntoDescriptor
)
;
if
(
!
filledView
)
return
nullptr
;
if
(
!
ReadableByteStreamControllerHandleQueueDrain
(
cx
controller
)
)
return
nullptr
;
val
=
ObjectValue
(
*
filledView
)
;
RootedObject
iterResult
(
cx
CreateIterResultObject
(
cx
val
false
)
)
;
if
(
!
iterResult
)
return
nullptr
;
val
=
ObjectValue
(
*
iterResult
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
val
)
;
}
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
read
"
)
;
RootedValue
e
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
e
)
)
return
nullptr
;
if
(
!
ReadableStreamControllerError
(
cx
controller
e
)
)
return
nullptr
;
return
PromiseObject
:
:
unforgeableReject
(
cx
e
)
;
}
}
RootedArrayBufferObject
transferredBuffer
(
cx
TransferArrayBuffer
(
cx
buffer
)
)
;
if
(
!
transferredBuffer
)
return
nullptr
;
pullIntoDescriptor
-
>
setBuffer
(
transferredBuffer
)
;
val
=
ObjectValue
(
*
pullIntoDescriptor
)
;
if
(
!
AppendToList
(
cx
pendingPullIntos
val
)
)
return
nullptr
;
Rooted
<
PromiseObject
*
>
promise
(
cx
ReadableStreamAddReadIntoRequest
(
cx
stream
)
)
;
if
(
!
promise
)
return
nullptr
;
if
(
!
ReadableStreamControllerCallPullIfNeeded
(
cx
controller
)
)
return
nullptr
;
return
promise
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondInternal
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
double
bytesWritten
)
;
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespond
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleValue
bytesWrittenVal
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
double
bytesWritten
;
if
(
!
ToNumber
(
cx
bytesWrittenVal
&
bytesWritten
)
)
return
false
;
if
(
bytesWritten
<
0
|
|
mozilla
:
:
IsNaN
(
bytesWritten
)
|
|
mozilla
:
:
IsInfinite
(
bytesWritten
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE
"
bytesWritten
"
)
;
return
false
;
}
#
if
DEBUG
Value
val
=
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
;
#
endif
return
ReadableByteStreamControllerRespondInternal
(
cx
controller
bytesWritten
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondInClosedState
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
Handle
<
PullIntoDescriptor
*
>
firstDescriptor
)
{
RootedArrayBufferObject
buffer
(
cx
firstDescriptor
-
>
buffer
(
)
)
;
RootedArrayBufferObject
transferredBuffer
(
cx
TransferArrayBuffer
(
cx
buffer
)
)
;
if
(
!
transferredBuffer
)
return
false
;
firstDescriptor
-
>
setBuffer
(
transferredBuffer
)
;
MOZ_ASSERT
(
firstDescriptor
-
>
bytesFilled
(
)
=
=
0
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
if
(
ReadableStreamHasBYOBReader
(
stream
)
)
{
Rooted
<
PullIntoDescriptor
*
>
descriptor
(
cx
)
;
while
(
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
descriptor
=
ReadableByteStreamControllerShiftPendingPullInto
(
cx
controller
)
;
if
(
!
descriptor
)
return
false
;
if
(
!
ReadableByteStreamControllerCommitPullIntoDescriptor
(
cx
stream
descriptor
)
)
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondInReadableState
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
uint32_t
bytesWritten
Handle
<
PullIntoDescriptor
*
>
pullIntoDescriptor
)
{
uint32_t
bytesFilled
=
pullIntoDescriptor
-
>
bytesFilled
(
)
;
uint32_t
byteLength
=
pullIntoDescriptor
-
>
byteLength
(
)
;
if
(
bytesFilled
+
bytesWritten
>
byteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_BYTESWRITTEN
)
;
return
false
;
}
ReadableByteStreamControllerFillHeadPullIntoDescriptor
(
controller
bytesWritten
pullIntoDescriptor
)
;
bytesFilled
+
=
bytesWritten
;
uint32_t
elementSize
=
pullIntoDescriptor
-
>
elementSize
(
)
;
if
(
bytesFilled
<
elementSize
)
return
true
;
if
(
!
ReadableByteStreamControllerShiftPendingPullInto
(
cx
controller
)
)
return
false
;
uint32_t
remainderSize
=
bytesFilled
%
elementSize
;
RootedArrayBufferObject
buffer
(
cx
pullIntoDescriptor
-
>
buffer
(
)
)
;
if
(
remainderSize
>
0
)
{
uint32_t
end
=
pullIntoDescriptor
-
>
byteOffset
(
)
+
bytesFilled
;
RootedObject
remainderObj
(
cx
JS_NewArrayBuffer
(
cx
remainderSize
)
)
;
if
(
!
remainderObj
)
return
false
;
RootedArrayBufferObject
remainder
(
cx
&
remainderObj
-
>
as
<
ArrayBufferObject
>
(
)
)
;
ArrayBufferObject
:
:
copyData
(
remainder
0
buffer
end
-
remainderSize
remainderSize
)
;
if
(
!
ReadableByteStreamControllerEnqueueChunkToQueue
(
cx
controller
remainder
0
remainderSize
)
)
{
return
false
;
}
}
RootedArrayBufferObject
transferredBuffer
(
cx
TransferArrayBuffer
(
cx
buffer
)
)
;
if
(
!
transferredBuffer
)
return
false
;
pullIntoDescriptor
-
>
setBuffer
(
transferredBuffer
)
;
pullIntoDescriptor
-
>
setBytesFilled
(
bytesFilled
-
remainderSize
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
if
(
!
ReadableByteStreamControllerCommitPullIntoDescriptor
(
cx
stream
pullIntoDescriptor
)
)
return
false
;
return
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
(
cx
controller
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondInternal
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
double
bytesWritten
)
{
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
PullIntoDescriptor
*
>
firstDescriptor
(
cx
)
;
firstDescriptor
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
Rooted
<
ReadableStream
*
>
stream
(
cx
StreamFromController
(
controller
)
)
;
if
(
stream
-
>
closed
(
)
)
{
if
(
bytesWritten
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_CLOSED
)
;
return
false
;
}
return
ReadableByteStreamControllerRespondInClosedState
(
cx
controller
firstDescriptor
)
;
}
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
return
ReadableByteStreamControllerRespondInReadableState
(
cx
controller
bytesWritten
firstDescriptor
)
;
}
static
MOZ_MUST_USE
bool
ReadableByteStreamControllerRespondWithNewView
(
JSContext
*
cx
Handle
<
ReadableByteStreamController
*
>
controller
HandleObject
view
)
{
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
pendingPullIntos
-
>
getDenseInitializedLength
(
)
!
=
0
)
;
Rooted
<
PullIntoDescriptor
*
>
firstDescriptor
(
cx
)
;
firstDescriptor
=
PeekList
<
PullIntoDescriptor
>
(
pendingPullIntos
)
;
uint32_t
byteOffset
=
uint32_t
(
JS_GetArrayBufferViewByteOffset
(
view
)
)
;
if
(
firstDescriptor
-
>
byteOffset
(
)
+
firstDescriptor
-
>
bytesFilled
(
)
!
=
byteOffset
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_OFFSET
)
;
return
false
;
}
uint32_t
byteLength
=
JS_GetArrayBufferViewByteLength
(
view
)
;
if
(
firstDescriptor
-
>
byteLength
(
)
!
=
byteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_SIZE
)
;
return
false
;
}
bool
dummy
;
RootedArrayBufferObject
buffer
(
cx
&
AsArrayBuffer
(
JS_GetArrayBufferViewBuffer
(
cx
view
&
dummy
)
)
)
;
if
(
!
buffer
)
return
false
;
firstDescriptor
-
>
setBuffer
(
buffer
)
;
return
ReadableByteStreamControllerRespondInternal
(
cx
controller
byteLength
)
;
}
static
MOZ_MUST_USE
PullIntoDescriptor
*
ReadableByteStreamControllerShiftPendingPullInto
(
JSContext
*
cx
HandleNativeObject
controller
)
{
MOZ_ASSERT
(
controller
-
>
is
<
ReadableByteStreamController
>
(
)
)
;
RootedValue
val
(
cx
controller
-
>
getFixedSlot
(
ByteControllerSlot_PendingPullIntos
)
)
;
RootedNativeObject
pendingPullIntos
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
Rooted
<
PullIntoDescriptor
*
>
descriptor
(
cx
)
;
descriptor
=
ShiftFromList
<
PullIntoDescriptor
>
(
cx
pendingPullIntos
)
;
MOZ_ASSERT
(
descriptor
)
;
ReadableByteStreamControllerInvalidateBYOBRequest
(
controller
)
;
return
descriptor
;
}
bool
js
:
:
ByteLengthQueuingStrategy
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
strategy
(
cx
NewBuiltinClassInstance
<
ByteLengthQueuingStrategy
>
(
cx
)
)
;
if
(
!
strategy
)
return
false
;
RootedObject
argObj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
argObj
)
return
false
;
RootedValue
highWaterMark
(
cx
)
;
if
(
!
GetProperty
(
cx
argObj
argObj
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
return
false
;
if
(
!
SetProperty
(
cx
strategy
cx
-
>
names
(
)
.
highWaterMark
highWaterMark
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
strategy
)
;
return
true
;
}
bool
ByteLengthQueuingStrategy_size
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
GetProperty
(
cx
args
.
get
(
0
)
cx
-
>
names
(
)
.
byteLength
args
.
rval
(
)
)
;
}
static
const
JSPropertySpec
ByteLengthQueuingStrategy_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
ByteLengthQueuingStrategy_methods
[
]
=
{
JS_FN
(
"
size
"
ByteLengthQueuingStrategy_size
1
0
)
JS_FS_END
}
;
CLASS_SPEC
(
ByteLengthQueuingStrategy
1
0
0
0
JS_NULL_CLASS_OPS
)
;
bool
js
:
:
CountQueuingStrategy
:
:
constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
CountQueuingStrategy
*
>
strategy
(
cx
NewBuiltinClassInstance
<
CountQueuingStrategy
>
(
cx
)
)
;
if
(
!
strategy
)
return
false
;
RootedObject
argObj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
argObj
)
return
false
;
RootedValue
highWaterMark
(
cx
)
;
if
(
!
GetProperty
(
cx
argObj
argObj
cx
-
>
names
(
)
.
highWaterMark
&
highWaterMark
)
)
return
false
;
if
(
!
SetProperty
(
cx
strategy
cx
-
>
names
(
)
.
highWaterMark
highWaterMark
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
strategy
)
;
return
true
;
}
bool
CountQueuingStrategy_size
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setInt32
(
1
)
;
return
true
;
}
static
const
JSPropertySpec
CountQueuingStrategy_properties
[
]
=
{
JS_PS_END
}
;
static
const
JSFunctionSpec
CountQueuingStrategy_methods
[
]
=
{
JS_FN
(
"
size
"
CountQueuingStrategy_size
0
0
)
JS_FS_END
}
;
CLASS_SPEC
(
CountQueuingStrategy
1
0
0
0
JS_NULL_CLASS_OPS
)
;
#
undef
CLASS_SPEC
inline
static
MOZ_MUST_USE
bool
DequeueValue
(
JSContext
*
cx
HandleNativeObject
container
MutableHandleValue
chunk
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
container
)
)
;
RootedValue
val
(
cx
container
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
queue
-
>
getDenseInitializedLength
(
)
>
0
)
;
Rooted
<
QueueEntry
*
>
pair
(
cx
ShiftFromList
<
QueueEntry
>
(
cx
queue
)
)
;
MOZ_ASSERT
(
pair
)
;
double
totalSize
=
container
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
totalSize
-
=
pair
-
>
size
(
)
;
if
(
totalSize
<
0
)
totalSize
=
0
;
container
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
totalSize
)
)
;
chunk
.
set
(
pair
-
>
value
(
)
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
EnqueueValueWithSize
(
JSContext
*
cx
HandleNativeObject
container
HandleValue
value
HandleValue
sizeVal
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
container
)
)
;
double
size
;
if
(
!
ToNumber
(
cx
sizeVal
&
size
)
)
return
false
;
if
(
size
<
0
|
|
mozilla
:
:
IsNaN
(
size
)
|
|
mozilla
:
:
IsInfinite
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE
"
size
"
)
;
return
false
;
}
RootedValue
val
(
cx
container
-
>
getFixedSlot
(
QueueContainerSlot_Queue
)
)
;
RootedNativeObject
queue
(
cx
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
QueueEntry
*
entry
=
QueueEntry
:
:
create
(
cx
value
size
)
;
if
(
!
entry
)
return
false
;
val
=
ObjectValue
(
*
entry
)
;
if
(
!
AppendToList
(
cx
queue
val
)
)
return
false
;
double
totalSize
=
container
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toNumber
(
)
;
container
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
totalSize
+
size
)
)
;
return
true
;
}
inline
static
MOZ_MUST_USE
bool
ResetQueue
(
JSContext
*
cx
HandleNativeObject
container
)
{
MOZ_ASSERT
(
IsReadableStreamController
(
container
)
)
;
if
(
!
SetNewList
(
cx
container
QueueContainerSlot_Queue
)
)
return
false
;
container
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
NumberValue
(
0
)
)
;
return
true
;
}
inline
static
MOZ_MUST_USE
bool
InvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
MutableHandleValue
rval
)
{
RootedValue
method
(
cx
)
;
if
(
!
GetProperty
(
cx
O
P
&
method
)
)
return
false
;
if
(
method
.
isUndefined
(
)
)
return
true
;
return
Call
(
cx
method
O
arg
rval
)
;
}
static
MOZ_MUST_USE
JSObject
*
PromiseInvokeOrNoop
(
JSContext
*
cx
HandleValue
O
HandlePropertyName
P
HandleValue
arg
)
{
MOZ_ASSERT
(
!
O
.
isUndefined
(
)
)
;
RootedValue
returnValue
(
cx
)
;
if
(
!
InvokeOrNoop
(
cx
O
P
arg
&
returnValue
)
)
return
PromiseRejectedWithPendingError
(
cx
)
;
return
PromiseObject
:
:
unforgeableResolve
(
cx
returnValue
)
;
}
static
MOZ_MUST_USE
ArrayBufferObject
*
TransferArrayBuffer
(
JSContext
*
cx
HandleObject
buffer
)
{
MOZ_ASSERT
(
buffer
-
>
is
<
ArrayBufferObject
>
(
)
)
;
MOZ_ASSERT
(
!
JS_IsDetachedArrayBufferObject
(
buffer
)
)
;
uint32_t
size
=
buffer
-
>
as
<
ArrayBufferObject
>
(
)
.
byteLength
(
)
;
void
*
contents
=
JS_StealArrayBufferContents
(
cx
buffer
)
;
if
(
!
contents
)
return
nullptr
;
MOZ_ASSERT
(
JS_IsDetachedArrayBufferObject
(
buffer
)
)
;
RootedObject
transferredBuffer
(
cx
JS_NewArrayBufferWithContents
(
cx
size
contents
)
)
;
if
(
!
transferredBuffer
)
return
nullptr
;
return
&
transferredBuffer
-
>
as
<
ArrayBufferObject
>
(
)
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeHighWaterMark
(
JSContext
*
cx
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
{
if
(
!
ToNumber
(
cx
highWaterMarkVal
highWaterMark
)
)
return
false
;
if
(
mozilla
:
:
IsNaN
(
*
highWaterMark
)
|
|
*
highWaterMark
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_STREAM_INVALID_HIGHWATERMARK
)
;
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
ValidateAndNormalizeQueuingStrategy
(
JSContext
*
cx
HandleValue
size
HandleValue
highWaterMarkVal
double
*
highWaterMark
)
{
if
(
!
size
.
isUndefined
(
)
&
&
!
IsCallable
(
size
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_FUNCTION
"
ReadableStream
argument
options
.
size
"
)
;
return
false
;
}
if
(
!
ValidateAndNormalizeHighWaterMark
(
cx
highWaterMarkVal
highWaterMark
)
)
return
false
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderCancel
(
JSContext
*
cx
HandleObject
readerObj
HandleValue
reason
)
{
MOZ_ASSERT
(
IsReadableStreamReader
(
readerObj
)
)
;
RootedNativeObject
reader
(
cx
&
readerObj
-
>
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
StreamFromReader
(
reader
)
)
;
return
ReadableStreamReaderGenericCancel
(
cx
reader
reason
)
;
}
MOZ_MUST_USE
bool
js
:
:
ReadableStreamReaderReleaseLock
(
JSContext
*
cx
HandleObject
readerObj
)
{
MOZ_ASSERT
(
IsReadableStreamReader
(
readerObj
)
)
;
RootedNativeObject
reader
(
cx
&
readerObj
-
>
as
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
StreamFromReader
(
reader
)
)
=
=
0
)
;
return
ReadableStreamReaderGenericRelease
(
cx
reader
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
enqueue
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
chunk
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
return
ReadableStreamDefaultControllerEnqueue
(
cx
controller
chunk
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
enqueueBuffer
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
Handle
<
ArrayBufferObject
*
>
chunk
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
MOZ_ASSERT
(
!
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
)
;
MOZ_ASSERT
(
stream
-
>
readable
(
)
)
;
return
ReadableByteStreamControllerEnqueue
(
cx
controller
chunk
)
;
}
void
ReadableStream
:
:
desiredSize
(
bool
*
hasSize
double
*
size
)
const
{
if
(
errored
(
)
)
{
*
hasSize
=
false
;
return
;
}
*
hasSize
=
true
;
if
(
closed
(
)
)
{
*
size
=
0
;
return
;
}
NativeObject
*
controller
=
ControllerFromStream
(
this
)
;
*
size
=
ReadableStreamControllerGetDesiredSizeUnchecked
(
controller
)
;
}
bool
ReadableStream
:
:
getExternalSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
void
*
*
source
)
{
MOZ_ASSERT
(
stream
-
>
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
if
(
stream
-
>
locked
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAM_LOCKED
)
;
return
false
;
}
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
ReadableStreamGetExternalUnderlyingSource
"
)
;
return
false
;
}
auto
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
AddControllerFlags
(
controller
ControllerFlag_SourceLocked
)
;
*
source
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
.
toPrivate
(
)
;
return
true
;
}
void
ReadableStream
:
:
releaseExternalSource
(
)
{
MOZ_ASSERT
(
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
MOZ_ASSERT
(
locked
(
)
)
;
auto
controller
=
ControllerFromStream
(
this
)
;
MOZ_ASSERT
(
ControllerFlags
(
controller
)
&
ControllerFlag_SourceLocked
)
;
RemoveControllerFlags
(
controller
ControllerFlag_SourceLocked
)
;
}
uint8_t
ReadableStream
:
:
embeddingFlags
(
)
const
{
uint8_t
flags
=
ControllerFlags
(
ControllerFromStream
(
this
)
)
>
>
ControllerEmbeddingFlagsOffset
;
MOZ_ASSERT_IF
(
flags
mode
(
)
=
=
JS
:
:
ReadableStreamMode
:
:
ExternalSource
)
;
return
flags
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
updateDataAvailableFromSource
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
uint32_t
availableData
)
{
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
ControllerFromStream
(
stream
)
-
>
as
<
ReadableByteStreamController
>
(
)
;
if
(
ControllerFlags
(
controller
)
&
ControllerFlag_CloseRequested
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_CLOSED
"
enqueue
"
)
;
return
false
;
}
if
(
!
StreamFromController
(
controller
)
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
enqueue
"
)
;
return
false
;
}
RemoveControllerFlags
(
controller
ControllerFlag_Pulling
|
ControllerFlag_PullAgain
)
;
#
if
DEBUG
uint32_t
oldAvailableData
=
controller
-
>
getFixedSlot
(
QueueContainerSlot_TotalSize
)
.
toInt32
(
)
;
#
endif
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
Int32Value
(
availableData
)
)
;
if
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
return
true
;
if
(
ReadableStreamHasDefaultReader
(
stream
)
)
{
MOZ_ASSERT
(
oldAvailableData
=
=
0
)
;
JSObject
*
viewObj
=
JS_NewUint8Array
(
cx
availableData
)
;
Rooted
<
ArrayBufferViewObject
*
>
transferredView
(
cx
&
viewObj
-
>
as
<
ArrayBufferViewObject
>
(
)
)
;
if
(
!
transferredView
)
return
false
;
Value
val
=
controller
-
>
getFixedSlot
(
ControllerSlot_UnderlyingSource
)
;
void
*
underlyingSource
=
val
.
toPrivate
(
)
;
size_t
bytesWritten
;
{
JS
:
:
AutoSuppressGCAnalysis
suppressGC
(
cx
)
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
dummy
;
void
*
buffer
=
JS_GetArrayBufferViewData
(
transferredView
&
dummy
noGC
)
;
auto
cb
=
cx
-
>
runtime
(
)
-
>
readableStreamWriteIntoReadRequestCallback
;
MOZ_ASSERT
(
cb
)
;
cb
(
cx
stream
underlyingSource
stream
-
>
embeddingFlags
(
)
buffer
availableData
&
bytesWritten
)
;
}
RootedValue
chunk
(
cx
ObjectValue
(
*
transferredView
)
)
;
if
(
!
ReadableStreamFulfillReadOrReadIntoRequest
(
cx
stream
chunk
false
)
)
return
false
;
controller
-
>
setFixedSlot
(
QueueContainerSlot_TotalSize
Int32Value
(
availableData
-
bytesWritten
)
)
;
}
else
if
(
ReadableStreamHasBYOBReader
(
stream
)
)
{
if
(
!
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
(
cx
controller
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
!
stream
-
>
locked
(
)
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
close
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
)
{
RootedNativeObject
controllerObj
(
cx
ControllerFromStream
(
stream
)
)
;
if
(
!
VerifyControllerStateForClosing
(
cx
controllerObj
)
)
return
false
;
if
(
controllerObj
-
>
is
<
ReadableStreamDefaultController
>
(
)
)
{
Rooted
<
ReadableStreamDefaultController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableStreamDefaultController
>
(
)
;
return
ReadableStreamDefaultControllerClose
(
cx
controller
)
;
}
Rooted
<
ReadableByteStreamController
*
>
controller
(
cx
)
;
controller
=
&
controllerObj
-
>
as
<
ReadableByteStreamController
>
(
)
;
return
ReadableByteStreamControllerClose
(
cx
controller
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
error
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
HandleValue
reason
)
{
if
(
!
stream
-
>
readable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE
"
error
"
)
;
return
false
;
}
RootedNativeObject
controller
(
cx
ControllerFromStream
(
stream
)
)
;
return
ReadableStreamControllerError
(
cx
controller
reason
)
;
}
MOZ_MUST_USE
bool
ReadableStream
:
:
tee
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
bool
cloneForBranch2
MutableHandle
<
ReadableStream
*
>
branch1Stream
MutableHandle
<
ReadableStream
*
>
branch2Stream
)
{
return
ReadableStreamTee
(
cx
stream
false
branch1Stream
branch2Stream
)
;
}
MOZ_MUST_USE
NativeObject
*
ReadableStream
:
:
getReader
(
JSContext
*
cx
Handle
<
ReadableStream
*
>
stream
JS
:
:
ReadableStreamReaderMode
mode
)
{
if
(
mode
=
=
JS
:
:
ReadableStreamReaderMode
:
:
Default
)
return
CreateReadableStreamDefaultReader
(
cx
stream
)
;
return
CreateReadableStreamBYOBReader
(
cx
stream
)
;
}
JS_FRIEND_API
(
JSObject
*
)
js
:
:
UnwrapReadableStream
(
JSObject
*
obj
)
{
if
(
JSObject
*
unwrapped
=
CheckedUnwrap
(
obj
)
)
return
unwrapped
-
>
is
<
ReadableStream
>
(
)
?
unwrapped
:
nullptr
;
return
nullptr
;
}
