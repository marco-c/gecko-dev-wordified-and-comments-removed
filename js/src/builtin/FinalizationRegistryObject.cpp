#
include
"
builtin
/
FinalizationRegistryObject
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
const
JSClass
FinalizationRecordObject
:
:
class_
=
{
"
FinalizationRecord
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
&
classOps_
JS_NULL_CLASS_SPEC
}
;
const
JSClassOps
FinalizationRecordObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
FinalizationRecordObject
:
:
trace
}
;
FinalizationRecordObject
*
FinalizationRecordObject
:
:
create
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleValue
heldValue
)
{
MOZ_ASSERT
(
registry
)
;
auto
record
=
NewObjectWithGivenProto
<
FinalizationRecordObject
>
(
cx
nullptr
)
;
if
(
!
record
)
{
return
nullptr
;
}
MOZ_ASSERT
(
registry
-
>
compartment
(
)
=
=
record
-
>
compartment
(
)
)
;
record
-
>
initReservedSlot
(
WeakRegistrySlot
PrivateValue
(
registry
)
)
;
record
-
>
initReservedSlot
(
HeldValueSlot
heldValue
)
;
return
record
;
}
FinalizationRegistryObject
*
FinalizationRecordObject
:
:
registryDuringGC
(
gc
:
:
GCRuntime
*
gc
)
const
{
FinalizationRegistryObject
*
registry
=
registryUnbarriered
(
)
;
if
(
registry
-
>
zone
(
)
-
>
isGCMarking
(
)
)
{
FinalizationRegistryObject
*
tmp
=
registry
;
TraceManuallyBarrieredEdge
(
&
gc
-
>
marker
&
tmp
"
FinalizationRegistry
read
barrier
"
)
;
MOZ_ASSERT
(
tmp
=
=
registry
)
;
}
else
if
(
registry
-
>
isMarkedGray
(
)
)
{
gc
:
:
UnmarkGrayGCThingUnchecked
(
gc
-
>
rt
JS
:
:
GCCellPtr
(
registry
)
)
;
}
return
registry
;
}
FinalizationRegistryObject
*
FinalizationRecordObject
:
:
registryUnbarriered
(
)
const
{
Value
value
=
getReservedSlot
(
WeakRegistrySlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
FinalizationRegistryObject
*
>
(
value
.
toPrivate
(
)
)
;
}
Value
FinalizationRecordObject
:
:
heldValue
(
)
const
{
return
getReservedSlot
(
HeldValueSlot
)
;
}
bool
FinalizationRecordObject
:
:
isActive
(
)
const
{
MOZ_ASSERT_IF
(
!
registryUnbarriered
(
)
heldValue
(
)
.
isUndefined
(
)
)
;
return
registryUnbarriered
(
)
;
}
void
FinalizationRecordObject
:
:
clear
(
)
{
MOZ_ASSERT
(
registryUnbarriered
(
)
)
;
setReservedSlot
(
WeakRegistrySlot
UndefinedValue
(
)
)
;
setReservedSlot
(
HeldValueSlot
UndefinedValue
(
)
)
;
}
bool
FinalizationRecordObject
:
:
sweep
(
)
{
FinalizationRegistryObject
*
obj
=
registryUnbarriered
(
)
;
MOZ_ASSERT
(
obj
)
;
if
(
IsAboutToBeFinalizedUnbarriered
(
&
obj
)
)
{
clear
(
)
;
return
false
;
}
return
true
;
}
void
FinalizationRecordObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
if
(
!
trc
-
>
traceWeakEdges
(
)
)
{
return
;
}
auto
record
=
&
obj
-
>
as
<
FinalizationRecordObject
>
(
)
;
FinalizationRegistryObject
*
registry
=
record
-
>
registryUnbarriered
(
)
;
if
(
!
registry
)
{
return
;
}
TraceManuallyBarrieredEdge
(
trc
&
registry
"
FinalizationRecordObject
weak
registry
"
)
;
if
(
registry
!
=
record
-
>
registryUnbarriered
(
)
)
{
record
-
>
setReservedSlot
(
WeakRegistrySlot
PrivateValue
(
registry
)
)
;
}
}
const
JSClass
FinalizationRegistrationsObject
:
:
class_
=
{
"
FinalizationRegistrations
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_BACKGROUND_FINALIZE
&
classOps_
JS_NULL_CLASS_SPEC
}
;
const
JSClassOps
FinalizationRegistrationsObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
FinalizationRegistrationsObject
:
:
finalize
nullptr
nullptr
nullptr
nullptr
}
;
FinalizationRegistrationsObject
*
FinalizationRegistrationsObject
:
:
create
(
JSContext
*
cx
)
{
auto
records
=
cx
-
>
make_unique
<
FinalizationRecordVector
>
(
cx
-
>
zone
(
)
)
;
if
(
!
records
)
{
return
nullptr
;
}
auto
object
=
NewObjectWithGivenProto
<
FinalizationRegistrationsObject
>
(
cx
nullptr
)
;
if
(
!
object
)
{
return
nullptr
;
}
InitReservedSlot
(
object
RecordsSlot
records
.
release
(
)
MemoryUse
:
:
FinalizationRecordVector
)
;
return
object
;
}
void
FinalizationRegistrationsObject
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
auto
rv
=
&
obj
-
>
as
<
FinalizationRegistrationsObject
>
(
)
;
fop
-
>
delete_
(
obj
rv
-
>
records
(
)
MemoryUse
:
:
FinalizationRecordVector
)
;
}
inline
WeakFinalizationRecordVector
*
FinalizationRegistrationsObject
:
:
records
(
)
{
return
static_cast
<
WeakFinalizationRecordVector
*
>
(
privatePtr
(
)
)
;
}
inline
const
WeakFinalizationRecordVector
*
FinalizationRegistrationsObject
:
:
records
(
)
const
{
return
static_cast
<
const
WeakFinalizationRecordVector
*
>
(
privatePtr
(
)
)
;
}
inline
void
*
FinalizationRegistrationsObject
:
:
privatePtr
(
)
const
{
Value
value
=
getReservedSlot
(
RecordsSlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
void
*
ptr
=
value
.
toPrivate
(
)
;
MOZ_ASSERT
(
ptr
)
;
return
ptr
;
}
inline
bool
FinalizationRegistrationsObject
:
:
isEmpty
(
)
const
{
MOZ_ASSERT
(
records
(
)
)
;
return
records
(
)
-
>
empty
(
)
;
}
inline
bool
FinalizationRegistrationsObject
:
:
append
(
HandleFinalizationRecordObject
record
)
{
MOZ_ASSERT
(
records
(
)
)
;
return
records
(
)
-
>
append
(
record
)
;
}
inline
void
FinalizationRegistrationsObject
:
:
remove
(
HandleFinalizationRecordObject
record
)
{
MOZ_ASSERT
(
records
(
)
)
;
records
(
)
-
>
eraseIfEqual
(
record
)
;
}
inline
void
FinalizationRegistrationsObject
:
:
sweep
(
)
{
MOZ_ASSERT
(
records
(
)
)
;
return
records
(
)
-
>
sweep
(
)
;
}
const
JSClass
FinalizationRegistryObject
:
:
class_
=
{
"
FinalizationRegistry
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_FinalizationRegistry
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_FOREGROUND_FINALIZE
&
classOps_
&
classSpec_
}
;
const
JSClass
FinalizationRegistryObject
:
:
protoClass_
=
{
"
FinalizationRegistryPrototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_FinalizationRegistry
)
JS_NULL_CLASS_OPS
&
classSpec_
}
;
const
JSClassOps
FinalizationRegistryObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
FinalizationRegistryObject
:
:
finalize
nullptr
nullptr
nullptr
FinalizationRegistryObject
:
:
trace
}
;
const
ClassSpec
FinalizationRegistryObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
construct
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
FinalizationRegistryObject
>
nullptr
nullptr
methods_
properties_
}
;
const
JSFunctionSpec
FinalizationRegistryObject
:
:
methods_
[
]
=
{
JS_FN
(
js_register_str
register_
2
0
)
JS_FN
(
js_unregister_str
unregister
1
0
)
JS_FN
(
js_cleanupSome_str
cleanupSome
0
0
)
JS_FS_END
}
;
const
JSPropertySpec
FinalizationRegistryObject
:
:
properties_
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
FinalizationRegistry
"
JSPROP_READONLY
)
JS_PS_END
}
;
bool
FinalizationRegistryObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
FinalizationRegistry
"
)
)
{
return
false
;
}
RootedObject
cleanupCallback
(
cx
ValueToCallable
(
cx
args
.
get
(
0
)
1
NO_CONSTRUCT
)
)
;
if
(
!
cleanupCallback
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_FinalizationRegistry
&
proto
)
)
{
return
false
;
}
Rooted
<
UniquePtr
<
ObjectWeakMap
>
>
registrations
(
cx
cx
-
>
make_unique
<
ObjectWeakMap
>
(
cx
)
)
;
if
(
!
registrations
)
{
return
false
;
}
Rooted
<
UniquePtr
<
FinalizationRecordSet
>
>
activeRecords
(
cx
cx
-
>
make_unique
<
FinalizationRecordSet
>
(
cx
-
>
zone
(
)
)
)
;
if
(
!
activeRecords
)
{
return
false
;
}
Rooted
<
UniquePtr
<
FinalizationRecordVector
>
>
recordsToBeCleanedUp
(
cx
cx
-
>
make_unique
<
FinalizationRecordVector
>
(
cx
-
>
zone
(
)
)
)
;
if
(
!
recordsToBeCleanedUp
)
{
return
false
;
}
FinalizationRegistryObject
*
registry
=
NewObjectWithClassProto
<
FinalizationRegistryObject
>
(
cx
proto
)
;
if
(
!
registry
)
{
return
false
;
}
registry
-
>
initReservedSlot
(
CleanupCallbackSlot
ObjectValue
(
*
cleanupCallback
)
)
;
InitReservedSlot
(
registry
RegistrationsSlot
registrations
.
release
(
)
MemoryUse
:
:
FinalizationRegistryRegistrations
)
;
InitReservedSlot
(
registry
ActiveRecords
activeRecords
.
release
(
)
MemoryUse
:
:
FinalizationRegistryRecordSet
)
;
InitReservedSlot
(
registry
RecordsToBeCleanedUpSlot
recordsToBeCleanedUp
.
release
(
)
MemoryUse
:
:
FinalizationRegistryRecordVector
)
;
registry
-
>
initReservedSlot
(
IsQueuedForCleanupSlot
BooleanValue
(
false
)
)
;
registry
-
>
initReservedSlot
(
IsCleanupJobActiveSlot
BooleanValue
(
false
)
)
;
if
(
!
cx
-
>
runtime
(
)
-
>
gc
.
addFinalizationRegistry
(
cx
registry
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
registry
)
;
return
true
;
}
void
FinalizationRegistryObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
auto
registry
=
&
obj
-
>
as
<
FinalizationRegistryObject
>
(
)
;
if
(
ObjectWeakMap
*
registrations
=
registry
-
>
registrations
(
)
)
{
registrations
-
>
trace
(
trc
)
;
}
if
(
FinalizationRecordVector
*
records
=
registry
-
>
recordsToBeCleanedUp
(
)
)
{
records
-
>
trace
(
trc
)
;
}
}
void
FinalizationRegistryObject
:
:
sweep
(
)
{
MOZ_ASSERT
(
activeRecords
(
)
)
;
activeRecords
(
)
-
>
sweep
(
)
;
MOZ_ASSERT
(
registrations
(
)
)
;
for
(
ObjectValueWeakMap
:
:
Enum
e
(
registrations
(
)
-
>
valueMap
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
registrations
=
&
e
.
front
(
)
.
value
(
)
.
toObject
(
)
.
as
<
FinalizationRegistrationsObject
>
(
)
;
registrations
-
>
sweep
(
)
;
if
(
registrations
-
>
isEmpty
(
)
)
{
e
.
removeFront
(
)
;
}
}
}
void
FinalizationRegistryObject
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
auto
registry
=
&
obj
-
>
as
<
FinalizationRegistryObject
>
(
)
;
MOZ_ASSERT
(
registry
-
>
getClass
(
)
-
>
flags
&
JSCLASS_FOREGROUND_FINALIZE
)
;
FinalizationRecordSet
*
allRecords
=
registry
-
>
activeRecords
(
)
;
for
(
auto
r
=
allRecords
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
auto
record
=
&
r
.
front
(
)
-
>
as
<
FinalizationRecordObject
>
(
)
;
MOZ_ASSERT
(
!
(
record
-
>
getClass
(
)
-
>
flags
&
JSCLASS_FOREGROUND_FINALIZE
)
)
;
MOZ_ASSERT
(
record
-
>
zone
(
)
=
=
registry
-
>
zone
(
)
)
;
if
(
record
-
>
isActive
(
)
)
{
record
-
>
clear
(
)
;
}
}
fop
-
>
delete_
(
obj
registry
-
>
registrations
(
)
MemoryUse
:
:
FinalizationRegistryRegistrations
)
;
fop
-
>
delete_
(
obj
registry
-
>
activeRecords
(
)
MemoryUse
:
:
FinalizationRegistryRecordSet
)
;
fop
-
>
delete_
(
obj
registry
-
>
recordsToBeCleanedUp
(
)
MemoryUse
:
:
FinalizationRegistryRecordVector
)
;
}
inline
JSObject
*
FinalizationRegistryObject
:
:
cleanupCallback
(
)
const
{
Value
value
=
getReservedSlot
(
CleanupCallbackSlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
&
value
.
toObject
(
)
;
}
ObjectWeakMap
*
FinalizationRegistryObject
:
:
registrations
(
)
const
{
Value
value
=
getReservedSlot
(
RegistrationsSlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
ObjectWeakMap
*
>
(
value
.
toPrivate
(
)
)
;
}
FinalizationRecordSet
*
FinalizationRegistryObject
:
:
activeRecords
(
)
const
{
Value
value
=
getReservedSlot
(
ActiveRecords
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
FinalizationRecordSet
*
>
(
value
.
toPrivate
(
)
)
;
}
FinalizationRecordVector
*
FinalizationRegistryObject
:
:
recordsToBeCleanedUp
(
)
const
{
Value
value
=
getReservedSlot
(
RecordsToBeCleanedUpSlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
FinalizationRecordVector
*
>
(
value
.
toPrivate
(
)
)
;
}
bool
FinalizationRegistryObject
:
:
isQueuedForCleanup
(
)
const
{
return
getReservedSlot
(
IsQueuedForCleanupSlot
)
.
toBoolean
(
)
;
}
bool
FinalizationRegistryObject
:
:
isCleanupJobActive
(
)
const
{
return
getReservedSlot
(
IsCleanupJobActiveSlot
)
.
toBoolean
(
)
;
}
void
FinalizationRegistryObject
:
:
queueRecordToBeCleanedUp
(
FinalizationRecordObject
*
record
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
recordsToBeCleanedUp
(
)
-
>
append
(
record
)
)
{
oomUnsafe
.
crash
(
"
FinalizationRegistryObject
:
:
queueRecordsToBeCleanedUp
"
)
;
}
}
void
FinalizationRegistryObject
:
:
setQueuedForCleanup
(
bool
value
)
{
MOZ_ASSERT
(
value
!
=
isQueuedForCleanup
(
)
)
;
setReservedSlot
(
IsQueuedForCleanupSlot
BooleanValue
(
value
)
)
;
}
void
FinalizationRegistryObject
:
:
setCleanupJobActive
(
bool
value
)
{
MOZ_ASSERT
(
value
!
=
isCleanupJobActive
(
)
)
;
setReservedSlot
(
IsCleanupJobActiveSlot
BooleanValue
(
value
)
)
;
}
bool
FinalizationRegistryObject
:
:
register_
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
|
|
!
args
.
thisv
(
)
.
toObject
(
)
.
is
<
FinalizationRegistryObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_A_FINALIZATION_REGISTRY
"
Receiver
of
FinalizationRegistry
.
register
call
"
)
;
return
false
;
}
RootedFinalizationRegistryObject
registry
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
FinalizationRegistryObject
>
(
)
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED
"
target
argument
to
FinalizationRegistry
.
register
"
)
;
return
false
;
}
RootedObject
target
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
if
(
args
.
get
(
1
)
.
isObject
(
)
&
&
&
args
.
get
(
1
)
.
toObject
(
)
=
=
target
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_HELD_VALUE
)
;
return
false
;
}
HandleValue
heldValue
=
args
.
get
(
1
)
;
if
(
!
args
.
get
(
2
)
.
isUndefined
(
)
&
&
!
args
.
get
(
2
)
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_UNREGISTER_TOKEN
"
FinalizationRegistry
.
register
"
)
;
return
false
;
}
RootedObject
unregisterToken
(
cx
)
;
if
(
!
args
.
get
(
2
)
.
isUndefined
(
)
)
{
unregisterToken
=
&
args
[
2
]
.
toObject
(
)
;
}
Rooted
<
FinalizationRecordObject
*
>
record
(
cx
FinalizationRecordObject
:
:
create
(
cx
registry
heldValue
)
)
;
if
(
!
record
)
{
return
false
;
}
if
(
!
registry
-
>
activeRecords
(
)
-
>
put
(
record
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
auto
recordsGuard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
registry
-
>
activeRecords
(
)
-
>
remove
(
record
)
;
}
)
;
if
(
unregisterToken
&
&
!
addRegistration
(
cx
registry
unregisterToken
record
)
)
{
return
false
;
}
auto
registrationsGuard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
if
(
unregisterToken
)
{
removeRegistrationOnError
(
registry
unregisterToken
record
)
;
}
}
)
;
RootedObject
unwrappedTarget
(
cx
)
;
unwrappedTarget
=
CheckedUnwrapDynamic
(
target
cx
)
;
if
(
!
unwrappedTarget
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
RootedObject
wrappedRecord
(
cx
record
)
;
AutoRealm
ar
(
cx
unwrappedTarget
)
;
if
(
!
JS_WrapObject
(
cx
&
wrappedRecord
)
)
{
return
false
;
}
if
(
JS_IsDeadWrapper
(
wrappedRecord
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
gc
:
:
GCRuntime
*
gc
=
&
cx
-
>
runtime
(
)
-
>
gc
;
if
(
!
gc
-
>
registerWithFinalizationRegistry
(
cx
unwrappedTarget
wrappedRecord
)
)
{
return
false
;
}
recordsGuard
.
release
(
)
;
registrationsGuard
.
release
(
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
FinalizationRegistryObject
:
:
addRegistration
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleObject
unregisterToken
HandleFinalizationRecordObject
record
)
{
MOZ_ASSERT
(
unregisterToken
)
;
MOZ_ASSERT
(
registry
-
>
registrations
(
)
)
;
auto
&
map
=
*
registry
-
>
registrations
(
)
;
Rooted
<
FinalizationRegistrationsObject
*
>
recordsObject
(
cx
)
;
JSObject
*
obj
=
map
.
lookup
(
unregisterToken
)
;
if
(
obj
)
{
recordsObject
=
&
obj
-
>
as
<
FinalizationRegistrationsObject
>
(
)
;
}
else
{
recordsObject
=
FinalizationRegistrationsObject
:
:
create
(
cx
)
;
if
(
!
recordsObject
|
|
!
map
.
add
(
cx
unregisterToken
recordsObject
)
)
{
return
false
;
}
}
if
(
!
recordsObject
-
>
append
(
record
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
FinalizationRegistryObject
:
:
removeRegistrationOnError
(
HandleFinalizationRegistryObject
registry
HandleObject
unregisterToken
HandleFinalizationRecordObject
record
)
{
MOZ_ASSERT
(
unregisterToken
)
;
MOZ_ASSERT
(
registry
-
>
registrations
(
)
)
;
JS
:
:
AutoAssertNoGC
nogc
;
auto
&
map
=
*
registry
-
>
registrations
(
)
;
JSObject
*
obj
=
map
.
lookup
(
unregisterToken
)
;
MOZ_ASSERT
(
obj
)
;
auto
records
=
&
obj
-
>
as
<
FinalizationRegistrationsObject
>
(
)
;
records
-
>
remove
(
record
)
;
if
(
records
-
>
empty
(
)
)
{
map
.
remove
(
unregisterToken
)
;
}
}
bool
FinalizationRegistryObject
:
:
unregister
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
|
|
!
args
.
thisv
(
)
.
toObject
(
)
.
is
<
FinalizationRegistryObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_A_FINALIZATION_REGISTRY
"
Receiver
of
FinalizationRegistry
.
unregister
call
"
)
;
return
false
;
}
RootedFinalizationRegistryObject
registry
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
FinalizationRegistryObject
>
(
)
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_UNREGISTER_TOKEN
"
FinalizationRegistry
.
unregister
"
)
;
return
false
;
}
RootedObject
unregisterToken
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
bool
removed
=
false
;
FinalizationRecordSet
*
activeRecords
=
registry
-
>
activeRecords
(
)
;
RootedObject
obj
(
cx
registry
-
>
registrations
(
)
-
>
lookup
(
unregisterToken
)
)
;
if
(
obj
)
{
auto
*
records
=
obj
-
>
as
<
FinalizationRegistrationsObject
>
(
)
.
records
(
)
;
MOZ_ASSERT
(
records
)
;
MOZ_ASSERT
(
!
records
-
>
empty
(
)
)
;
for
(
FinalizationRecordObject
*
record
:
*
records
)
{
if
(
record
-
>
isActive
(
)
)
{
activeRecords
-
>
remove
(
record
)
;
record
-
>
clear
(
)
;
removed
=
true
;
}
MOZ_ASSERT
(
!
activeRecords
-
>
has
(
record
)
)
;
}
registry
-
>
registrations
(
)
-
>
remove
(
unregisterToken
)
;
}
args
.
rval
(
)
.
setBoolean
(
removed
)
;
return
true
;
}
bool
FinalizationRegistryObject
:
:
cleanupSome
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
|
|
!
args
.
thisv
(
)
.
toObject
(
)
.
is
<
FinalizationRegistryObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_A_FINALIZATION_REGISTRY
"
Receiver
of
FinalizationRegistry
.
cleanupSome
call
"
)
;
return
false
;
}
RootedFinalizationRegistryObject
registry
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
FinalizationRegistryObject
>
(
)
)
;
if
(
registry
-
>
isCleanupJobActive
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_CLEANUP_STATE
)
;
return
false
;
}
RootedObject
cleanupCallback
(
cx
)
;
if
(
!
args
.
get
(
0
)
.
isUndefined
(
)
)
{
cleanupCallback
=
ValueToCallable
(
cx
args
.
get
(
0
)
-
1
NO_CONSTRUCT
)
;
if
(
!
cleanupCallback
)
{
return
false
;
}
}
if
(
!
cleanupQueuedRecords
(
cx
registry
cleanupCallback
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
FinalizationRegistryObject
:
:
hasRegisteredRecordsToBeCleanedUp
(
HandleFinalizationRegistryObject
registry
)
{
FinalizationRecordVector
*
records
=
registry
-
>
recordsToBeCleanedUp
(
)
;
size_t
initialLength
=
records
-
>
length
(
)
;
if
(
initialLength
=
=
0
)
{
return
false
;
}
for
(
FinalizationRecordObject
*
record
:
*
records
)
{
if
(
record
-
>
isActive
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
FinalizationRegistryObject
:
:
cleanupQueuedRecords
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleObject
callbackArg
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
registry
-
>
compartment
(
)
)
;
if
(
!
hasRegisteredRecordsToBeCleanedUp
(
registry
)
)
{
return
true
;
}
Rooted
<
FinalizationIteratorObject
*
>
iterator
(
cx
FinalizationIteratorObject
:
:
create
(
cx
registry
)
)
;
if
(
!
iterator
)
{
return
false
;
}
RootedValue
callback
(
cx
)
;
if
(
callbackArg
)
{
callback
.
setObject
(
*
callbackArg
)
;
}
else
{
JSObject
*
cleanupCallback
=
registry
-
>
cleanupCallback
(
)
;
MOZ_ASSERT
(
cleanupCallback
)
;
callback
.
setObject
(
*
cleanupCallback
)
;
}
registry
-
>
setCleanupJobActive
(
true
)
;
FinalizationRecordVector
*
records
=
registry
-
>
recordsToBeCleanedUp
(
)
;
#
ifdef
DEBUG
size_t
initialLength
=
records
-
>
length
(
)
;
#
endif
RootedValue
iteratorVal
(
cx
ObjectValue
(
*
iterator
)
)
;
RootedValue
rval
(
cx
)
;
bool
ok
=
Call
(
cx
callback
UndefinedHandleValue
iteratorVal
&
rval
)
;
size_t
index
=
iterator
-
>
index
(
)
;
MOZ_ASSERT
(
index
<
=
records
-
>
length
(
)
)
;
MOZ_ASSERT
(
initialLength
<
=
records
-
>
length
(
)
)
;
if
(
index
>
0
)
{
records
-
>
erase
(
records
-
>
begin
(
)
records
-
>
begin
(
)
+
index
)
;
}
registry
-
>
setCleanupJobActive
(
false
)
;
iterator
-
>
clearFinalizationRegistry
(
)
;
return
ok
;
}
const
JSClass
FinalizationIteratorObject
:
:
class_
=
{
"
FinalizationRegistryCleanupIterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
JS_NULL_CLASS_OPS
JS_NULL_CLASS_SPEC
}
;
const
JSFunctionSpec
FinalizationIteratorObject
:
:
methods_
[
]
=
{
JS_FN
(
js_next_str
next
0
0
)
JS_FS_END
}
;
const
JSPropertySpec
FinalizationIteratorObject
:
:
properties_
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
FinalizationRegistry
Cleanup
Iterator
"
JSPROP_READONLY
)
JS_PS_END
}
;
bool
GlobalObject
:
:
initFinalizationIteratorProto
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
Rooted
<
JSObject
*
>
base
(
cx
GlobalObject
:
:
getOrCreateIteratorPrototype
(
cx
global
)
)
;
if
(
!
base
)
{
return
false
;
}
RootedPlainObject
proto
(
cx
NewObjectWithGivenProto
<
PlainObject
>
(
cx
base
)
)
;
if
(
!
proto
)
{
return
false
;
}
if
(
!
JS_DefineFunctions
(
cx
proto
FinalizationIteratorObject
:
:
methods_
)
|
|
!
JS_DefineProperties
(
cx
proto
FinalizationIteratorObject
:
:
properties_
)
)
{
return
false
;
}
global
-
>
setReservedSlot
(
FINALIZATION_ITERATOR_PROTO
ObjectValue
(
*
proto
)
)
;
return
true
;
}
FinalizationIteratorObject
*
FinalizationIteratorObject
:
:
create
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
)
{
MOZ_ASSERT
(
registry
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateFinalizationIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
FinalizationIteratorObject
*
iterator
=
NewObjectWithGivenProto
<
FinalizationIteratorObject
>
(
cx
proto
)
;
if
(
!
iterator
)
{
return
nullptr
;
}
iterator
-
>
initReservedSlot
(
FinalizationRegistrySlot
ObjectValue
(
*
registry
)
)
;
iterator
-
>
initReservedSlot
(
IndexSlot
Int32Value
(
0
)
)
;
return
iterator
;
}
FinalizationRegistryObject
*
FinalizationIteratorObject
:
:
finalizationRegistry
(
)
const
{
Value
value
=
getReservedSlot
(
FinalizationRegistrySlot
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
&
value
.
toObject
(
)
.
as
<
FinalizationRegistryObject
>
(
)
;
}
size_t
FinalizationIteratorObject
:
:
index
(
)
const
{
int32_t
i
=
getReservedSlot
(
IndexSlot
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
size_t
(
i
)
;
}
void
FinalizationIteratorObject
:
:
setIndex
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
=
INT32_MAX
)
;
setReservedSlot
(
IndexSlot
Int32Value
(
int32_t
(
i
)
)
)
;
}
void
FinalizationIteratorObject
:
:
clearFinalizationRegistry
(
)
{
MOZ_ASSERT
(
finalizationRegistry
(
)
)
;
setReservedSlot
(
FinalizationRegistrySlot
UndefinedValue
(
)
)
;
}
bool
FinalizationIteratorObject
:
:
next
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
|
|
!
args
.
thisv
(
)
.
toObject
(
)
.
is
<
FinalizationIteratorObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_A_FINALIZATION_ITERATOR
"
Receiver
of
FinalizationRegistryCleanupIterator
.
next
call
"
)
;
return
false
;
}
RootedFinalizationIteratorObject
iterator
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
FinalizationIteratorObject
>
(
)
)
;
RootedFinalizationRegistryObject
registry
(
cx
iterator
-
>
finalizationRegistry
(
)
)
;
if
(
!
registry
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_STALE_FINALIZATION_REGISTRY_ITERATOR
)
;
return
false
;
}
FinalizationRecordVector
*
records
=
registry
-
>
recordsToBeCleanedUp
(
)
;
size_t
index
=
iterator
-
>
index
(
)
;
MOZ_ASSERT
(
index
<
=
records
-
>
length
(
)
)
;
while
(
index
<
records
-
>
length
(
)
&
&
index
<
INT32_MAX
&
&
!
(
*
records
)
[
index
]
-
>
isActive
(
)
)
{
index
+
+
;
iterator
-
>
setIndex
(
index
)
;
}
if
(
index
<
records
-
>
length
(
)
&
&
index
<
INT32_MAX
)
{
RootedFinalizationRecordObject
record
(
cx
(
*
records
)
[
index
]
)
;
RootedValue
heldValue
(
cx
record
-
>
heldValue
(
)
)
;
PlainObject
*
result
=
CreateIterResultObject
(
cx
heldValue
false
)
;
if
(
!
result
)
{
return
false
;
}
registry
-
>
activeRecords
(
)
-
>
remove
(
record
)
;
record
-
>
clear
(
)
;
iterator
-
>
setIndex
(
index
+
1
)
;
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
PlainObject
*
result
=
CreateIterResultObject
(
cx
UndefinedHandleValue
true
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
