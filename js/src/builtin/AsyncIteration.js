function
AsyncIteratorIdentity
(
)
{
return
this
;
}
function
AsyncGeneratorNext
(
val
)
{
assert
(
IsAsyncGeneratorObject
(
this
)
"
ThisArgument
must
be
a
generator
object
for
async
generators
"
)
;
return
resumeGenerator
(
this
val
"
next
"
)
;
}
function
AsyncGeneratorThrow
(
val
)
{
assert
(
IsAsyncGeneratorObject
(
this
)
"
ThisArgument
must
be
a
generator
object
for
async
generators
"
)
;
return
resumeGenerator
(
this
val
"
throw
"
)
;
}
function
AsyncGeneratorReturn
(
val
)
{
assert
(
IsAsyncGeneratorObject
(
this
)
"
ThisArgument
must
be
a
generator
object
for
async
generators
"
)
;
return
resumeGenerator
(
this
val
"
return
"
)
;
}
function
GetAsyncIteratorDirectWrapper
(
obj
)
{
if
(
!
IsObject
(
obj
)
)
{
ThrowTypeError
(
JSMSG_OBJECT_REQUIRED
obj
)
;
}
const
nextMethod
=
obj
.
next
;
if
(
!
IsCallable
(
nextMethod
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
nextMethod
)
;
}
return
{
[
std_asyncIterator
]
:
function
AsyncIteratorMethod
(
)
{
return
this
;
}
next
(
value
)
{
return
callContentFunction
(
nextMethod
obj
value
)
;
}
async
return
(
value
)
{
const
returnMethod
=
obj
.
return
;
if
(
returnMethod
!
=
=
undefined
&
&
returnMethod
!
=
=
null
)
{
return
callContentFunction
(
returnMethod
obj
value
)
;
}
return
{
done
:
true
value
}
;
}
}
;
}
async
function
AsyncIteratorReduce
(
reducer
)
{
const
iterated
=
GetAsyncIteratorDirectWrapper
(
this
)
;
if
(
!
IsCallable
(
reducer
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
reducer
)
)
;
}
let
accumulator
;
if
(
arguments
.
length
=
=
=
1
)
{
const
next
=
await
callContentFunction
(
iterated
.
next
iterated
)
;
if
(
!
IsObject
(
next
)
)
{
ThrowTypeError
(
JSMSG_OBJECT_REQUIRED
DecompileArg
(
0
next
)
)
;
}
if
(
next
.
done
)
{
ThrowTypeError
(
JSMSG_EMPTY_ITERATOR_REDUCE
)
;
}
accumulator
=
next
.
value
;
}
else
{
accumulator
=
arguments
[
1
]
;
}
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
accumulator
=
await
callContentFunction
(
reducer
undefined
accumulator
value
)
;
}
return
accumulator
;
}
async
function
AsyncIteratorToArray
(
)
{
const
iterated
=
{
[
std_asyncIterator
]
:
(
)
=
>
this
}
;
const
items
=
[
]
;
let
index
=
0
;
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
_DefineDataProperty
(
items
index
+
+
value
)
;
}
return
items
;
}
async
function
AsyncIteratorForEach
(
fn
)
{
const
iterated
=
GetAsyncIteratorDirectWrapper
(
this
)
;
if
(
!
IsCallable
(
fn
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
fn
)
)
;
}
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
await
callContentFunction
(
fn
undefined
value
)
;
}
}
async
function
AsyncIteratorSome
(
fn
)
{
const
iterated
=
GetAsyncIteratorDirectWrapper
(
this
)
;
if
(
!
IsCallable
(
fn
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
fn
)
)
;
}
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
if
(
await
callContentFunction
(
fn
undefined
value
)
)
{
return
true
;
}
}
return
false
;
}
async
function
AsyncIteratorEvery
(
fn
)
{
const
iterated
=
GetAsyncIteratorDirectWrapper
(
this
)
;
if
(
!
IsCallable
(
fn
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
fn
)
)
;
}
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
if
(
!
await
callContentFunction
(
fn
undefined
value
)
)
{
return
false
;
}
}
return
true
;
}
async
function
AsyncIteratorFind
(
fn
)
{
const
iterated
=
GetAsyncIteratorDirectWrapper
(
this
)
;
if
(
!
IsCallable
(
fn
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
fn
)
)
;
}
for
await
(
const
value
of
allowContentIter
(
iterated
)
)
{
if
(
await
callContentFunction
(
fn
undefined
value
)
)
{
return
value
;
}
}
}
