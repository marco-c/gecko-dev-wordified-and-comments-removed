#
ifndef
builtin_Promise_h
#
define
builtin_Promise_h
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
enum
PromiseSlots
{
PromiseSlot_Flags
=
0
PromiseSlot_ReactionsOrResult
PromiseSlot_RejectFunction
PromiseSlot_AllocationSite
PromiseSlot_ResolutionSite
PromiseSlot_AllocationTime
PromiseSlot_ResolutionTime
PromiseSlot_Id
PromiseSlots
}
;
#
define
PROMISE_FLAG_RESOLVED
0x1
#
define
PROMISE_FLAG_FULFILLED
0x2
#
define
PROMISE_FLAG_HANDLED
0x4
#
define
PROMISE_FLAG_REPORTED
0x8
#
define
PROMISE_FLAG_DEFAULT_RESOLVE_FUNCTION
0x10
#
define
PROMISE_FLAG_DEFAULT_REJECT_FUNCTION
0x20
class
AutoSetNewObjectMetadata
;
class
PromiseObject
:
public
NativeObject
{
public
:
static
const
unsigned
RESERVED_SLOTS
=
PromiseSlots
;
static
const
Class
class_
;
static
const
Class
protoClass_
;
static
PromiseObject
*
create
(
JSContext
*
cx
HandleObject
executor
HandleObject
proto
=
nullptr
)
;
static
JSObject
*
unforgeableResolve
(
JSContext
*
cx
HandleValue
value
)
;
static
JSObject
*
unforgeableReject
(
JSContext
*
cx
HandleValue
value
)
;
JS
:
:
PromiseState
state
(
)
{
int32_t
flags
=
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
if
(
!
(
flags
&
PROMISE_FLAG_RESOLVED
)
)
{
MOZ_ASSERT
(
!
(
flags
&
PROMISE_FLAG_FULFILLED
)
)
;
return
JS
:
:
PromiseState
:
:
Pending
;
}
if
(
flags
&
PROMISE_FLAG_FULFILLED
)
return
JS
:
:
PromiseState
:
:
Fulfilled
;
return
JS
:
:
PromiseState
:
:
Rejected
;
}
Value
value
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
Value
reason
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
MOZ_MUST_USE
bool
resolve
(
JSContext
*
cx
HandleValue
resolutionValue
)
;
MOZ_MUST_USE
bool
reject
(
JSContext
*
cx
HandleValue
rejectionValue
)
;
void
onSettled
(
JSContext
*
cx
)
;
double
allocationTime
(
)
{
return
getFixedSlot
(
PromiseSlot_AllocationTime
)
.
toNumber
(
)
;
}
double
resolutionTime
(
)
{
return
getFixedSlot
(
PromiseSlot_ResolutionTime
)
.
toNumber
(
)
;
}
JSObject
*
allocationSite
(
)
{
return
getFixedSlot
(
PromiseSlot_AllocationSite
)
.
toObjectOrNull
(
)
;
}
JSObject
*
resolutionSite
(
)
{
return
getFixedSlot
(
PromiseSlot_ResolutionSite
)
.
toObjectOrNull
(
)
;
}
double
lifetime
(
)
;
double
timeToResolution
(
)
{
MOZ_ASSERT
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
resolutionTime
(
)
-
allocationTime
(
)
;
}
MOZ_MUST_USE
bool
dependentPromises
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
values
)
;
uint64_t
getID
(
)
;
bool
isUnhandled
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
!
(
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
&
PROMISE_FLAG_HANDLED
)
;
}
void
markAsReported
(
)
{
MOZ_ASSERT
(
isUnhandled
(
)
)
;
int32_t
flags
=
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
|
PROMISE_FLAG_REPORTED
)
)
;
}
}
;
MOZ_MUST_USE
bool
EnqueuePromiseReactions
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleObject
dependentPromise
HandleValue
onFulfilled
HandleValue
onRejected
)
;
MOZ_MUST_USE
JSObject
*
GetWaitForAllPromise
(
JSContext
*
cx
const
JS
:
:
AutoObjectVector
&
promises
)
;
MOZ_MUST_USE
JSObject
*
OriginalPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled
HandleValue
onRejected
)
;
class
PromiseTask
:
public
JS
:
:
AsyncTask
{
JSRuntime
*
runtime_
;
PersistentRooted
<
PromiseObject
*
>
promise_
;
void
finish
(
JSContext
*
cx
)
override
final
;
void
cancel
(
JSContext
*
cx
)
override
final
;
protected
:
virtual
bool
finishPromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
=
0
;
public
:
PromiseTask
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
;
~
PromiseTask
(
)
;
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
virtual
void
execute
(
)
=
0
;
}
;
}
#
endif
