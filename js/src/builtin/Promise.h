#
ifndef
builtin_Promise_h
#
define
builtin_Promise_h
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
AutoSetNewObjectMetadata
;
class
PromiseObject
:
public
NativeObject
{
public
:
static
const
unsigned
RESERVED_SLOTS
=
8
;
static
const
Class
class_
;
static
const
Class
protoClass_
;
static
PromiseObject
*
create
(
JSContext
*
cx
HandleObject
executor
HandleObject
proto
=
nullptr
)
;
JS
:
:
PromiseState
state
(
)
{
int32_t
flags
=
getFixedSlot
(
PROMISE_FLAGS_SLOT
)
.
toInt32
(
)
;
if
(
!
(
flags
&
PROMISE_FLAG_RESOLVED
)
)
{
MOZ_ASSERT
(
!
(
flags
&
PROMISE_FLAG_FULFILLED
)
)
;
return
JS
:
:
PromiseState
:
:
Pending
;
}
if
(
flags
&
PROMISE_FLAG_FULFILLED
)
return
JS
:
:
PromiseState
:
:
Fulfilled
;
return
JS
:
:
PromiseState
:
:
Rejected
;
}
Value
value
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
;
return
getFixedSlot
(
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
}
Value
reason
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
getFixedSlot
(
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
}
MOZ_MUST_USE
bool
resolve
(
JSContext
*
cx
HandleValue
resolutionValue
)
;
MOZ_MUST_USE
bool
reject
(
JSContext
*
cx
HandleValue
rejectionValue
)
;
void
onSettled
(
JSContext
*
cx
)
;
double
allocationTime
(
)
{
return
getFixedSlot
(
PROMISE_ALLOCATION_TIME_SLOT
)
.
toNumber
(
)
;
}
double
resolutionTime
(
)
{
return
getFixedSlot
(
PROMISE_RESOLUTION_TIME_SLOT
)
.
toNumber
(
)
;
}
JSObject
*
allocationSite
(
)
{
return
getFixedSlot
(
PROMISE_ALLOCATION_SITE_SLOT
)
.
toObjectOrNull
(
)
;
}
JSObject
*
resolutionSite
(
)
{
return
getFixedSlot
(
PROMISE_RESOLUTION_SITE_SLOT
)
.
toObjectOrNull
(
)
;
}
double
lifetime
(
)
;
double
timeToResolution
(
)
{
MOZ_ASSERT
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
resolutionTime
(
)
-
allocationTime
(
)
;
}
MOZ_MUST_USE
bool
dependentPromises
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
values
)
;
uint64_t
getID
(
)
;
bool
isUnhandled
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
!
(
getFixedSlot
(
PROMISE_FLAGS_SLOT
)
.
toInt32
(
)
&
PROMISE_FLAG_HANDLED
)
;
}
void
markAsReported
(
)
{
MOZ_ASSERT
(
isUnhandled
(
)
)
;
int32_t
flags
=
getFixedSlot
(
PROMISE_FLAGS_SLOT
)
.
toInt32
(
)
;
setFixedSlot
(
PROMISE_FLAGS_SLOT
Int32Value
(
flags
|
PROMISE_FLAG_REPORTED
)
)
;
}
}
;
bool
EnqueuePromiseReactionJob
(
JSContext
*
cx
HandleValue
handler
HandleValue
handlerArg
HandleObject
resolve
HandleObject
reject
HandleObject
promise
HandleObject
objectFromIncumbentGlobal
)
;
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve
HandleValue
thenable
HandleValue
then
)
;
class
PromiseTask
:
public
JS
:
:
AsyncTask
{
JSRuntime
*
runtime_
;
PersistentRooted
<
PromiseObject
*
>
promise_
;
void
finish
(
JSContext
*
cx
)
override
final
;
void
cancel
(
JSContext
*
cx
)
override
final
;
protected
:
virtual
bool
finishPromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
=
0
;
public
:
PromiseTask
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
;
~
PromiseTask
(
)
;
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
virtual
void
execute
(
)
=
0
;
}
;
}
#
endif
