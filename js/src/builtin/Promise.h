#
ifndef
builtin_Promise_h
#
define
builtin_Promise_h
#
include
"
js
/
Promise
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSObject
;
namespace
js
{
class
AsyncFunctionGeneratorObject
;
class
AsyncGeneratorObject
;
class
PromiseObject
;
enum
class
CompletionKind
;
extern
bool
Promise_then
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
extern
bool
Promise_static_species
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
extern
bool
Promise_static_resolve
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
JSObject
*
GetWaitForAllPromise
(
JSContext
*
cx
JS
:
:
HandleObjectVector
promises
)
;
[
[
nodiscard
]
]
PromiseObject
*
OriginalPromiseThen
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
promiseObj
JS
:
:
Handle
<
JSObject
*
>
onFulfilled
JS
:
:
Handle
<
JSObject
*
>
onRejected
)
;
enum
class
UnhandledRejectionBehavior
{
Ignore
Report
}
;
[
[
nodiscard
]
]
extern
bool
ReactToUnwrappedPromise
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
unwrappedPromise
JS
:
:
Handle
<
JSObject
*
>
onFulfilled_
JS
:
:
Handle
<
JSObject
*
>
onRejected_
UnhandledRejectionBehavior
behavior
)
;
[
[
nodiscard
]
]
JSObject
*
PromiseResolve
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
constructor
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
[
[
nodiscard
]
]
bool
RejectPromiseWithPendingError
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
)
;
[
[
nodiscard
]
]
PromiseObject
*
CreatePromiseObjectForAsync
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
IsPromiseForAsyncFunctionOrGenerator
(
JSObject
*
promise
)
;
[
[
nodiscard
]
]
bool
AsyncFunctionReturned
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
resultPromise
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
[
[
nodiscard
]
]
bool
AsyncFunctionThrown
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
resultPromise
JS
:
:
Handle
<
JS
:
:
Value
>
reason
)
;
[
[
nodiscard
]
]
JSObject
*
AsyncFunctionAwait
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncFunctionGeneratorObject
*
>
genObj
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
[
[
nodiscard
]
]
bool
CanSkipAwait
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
val
bool
*
canSkip
)
;
[
[
nodiscard
]
]
bool
ExtractAwaitValue
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
val
JS
:
:
MutableHandle
<
JS
:
:
Value
>
resolved
)
;
[
[
nodiscard
]
]
bool
AsyncGeneratorAwait
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
[
[
nodiscard
]
]
bool
AsyncGeneratorResolve
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
JS
:
:
Handle
<
JS
:
:
Value
>
value
bool
done
)
;
[
[
nodiscard
]
]
bool
AsyncGeneratorReject
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
JS
:
:
Handle
<
JS
:
:
Value
>
exception
)
;
[
[
nodiscard
]
]
bool
AsyncGeneratorEnqueue
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
asyncGenVal
CompletionKind
completionKind
JS
:
:
Handle
<
JS
:
:
Value
>
completionValue
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
bool
AsyncFromSyncIteratorMethod
(
JSContext
*
cx
JS
:
:
CallArgs
&
args
CompletionKind
completionKind
)
;
struct
PromiseReactionRecordBuilder
{
[
[
nodiscard
]
]
virtual
bool
then
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
resolve
JS
:
:
Handle
<
JSObject
*
>
reject
JS
:
:
Handle
<
JSObject
*
>
result
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
direct
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
unwrappedPromise
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
asyncFunction
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncFunctionGeneratorObject
*
>
unwrappedGenerator
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
asyncGenerator
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncGeneratorObject
*
>
unwrappedGenerator
)
=
0
;
}
;
}
#
endif
