#
include
"
builtin
/
RegExp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
irregexp
/
RegExpParser
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
vm
/
RegExpStatics
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
vm
/
Unicode
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
unicode
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
bool
js
:
:
CreateRegExpMatchResult
(
JSContext
*
cx
HandleString
input
const
MatchPairs
&
matches
MutableHandleValue
rval
)
{
MOZ_ASSERT
(
input
)
;
JSObject
*
templateObject
=
cx
-
>
compartment
(
)
-
>
regExps
.
getOrCreateMatchResultTemplateObject
(
cx
)
;
if
(
!
templateObject
)
return
false
;
size_t
numPairs
=
matches
.
length
(
)
;
MOZ_ASSERT
(
numPairs
>
0
)
;
RootedArrayObject
arr
(
cx
NewDenseFullyAllocatedArrayWithTemplate
(
cx
numPairs
templateObject
)
)
;
if
(
!
arr
)
return
false
;
for
(
size_t
i
=
0
;
i
<
numPairs
;
i
+
+
)
{
const
MatchPair
&
pair
=
matches
[
i
]
;
if
(
pair
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
i
!
=
0
)
;
arr
-
>
setDenseInitializedLength
(
i
+
1
)
;
arr
-
>
initDenseElement
(
i
UndefinedValue
(
)
)
;
}
else
{
JSLinearString
*
str
=
NewDependentString
(
cx
input
pair
.
start
pair
.
length
(
)
)
;
if
(
!
str
)
return
false
;
arr
-
>
setDenseInitializedLength
(
i
+
1
)
;
arr
-
>
initDenseElement
(
i
StringValue
(
str
)
)
;
}
}
arr
-
>
setSlot
(
0
Int32Value
(
matches
[
0
]
.
start
)
)
;
arr
-
>
setSlot
(
1
StringValue
(
input
)
)
;
#
ifdef
DEBUG
RootedValue
test
(
cx
)
;
RootedId
id
(
cx
NameToId
(
cx
-
>
names
(
)
.
index
)
)
;
if
(
!
NativeGetProperty
(
cx
arr
id
&
test
)
)
return
false
;
MOZ_ASSERT
(
test
=
=
arr
-
>
getSlot
(
0
)
)
;
id
=
NameToId
(
cx
-
>
names
(
)
.
input
)
;
if
(
!
NativeGetProperty
(
cx
arr
id
&
test
)
)
return
false
;
MOZ_ASSERT
(
test
=
=
arr
-
>
getSlot
(
1
)
)
;
#
endif
rval
.
setObject
(
*
arr
)
;
return
true
;
}
static
RegExpRunStatus
ExecuteRegExpImpl
(
JSContext
*
cx
RegExpStatics
*
res
RegExpShared
&
re
HandleLinearString
input
size_t
searchIndex
bool
sticky
MatchPairs
*
matches
size_t
*
endIndex
)
{
RegExpRunStatus
status
=
re
.
execute
(
cx
input
searchIndex
sticky
matches
endIndex
)
;
if
(
status
=
=
RegExpRunStatus_Success
&
&
res
)
{
if
(
matches
)
{
if
(
!
res
-
>
updateFromMatchPairs
(
cx
input
*
matches
)
)
return
RegExpRunStatus_Error
;
}
else
{
res
-
>
updateLazily
(
cx
input
&
re
searchIndex
sticky
)
;
}
}
return
status
;
}
bool
js
:
:
ExecuteRegExpLegacy
(
JSContext
*
cx
RegExpStatics
*
res
RegExpObject
&
reobj
HandleLinearString
input
size_t
*
lastIndex
bool
test
MutableHandleValue
rval
)
{
RegExpGuard
shared
(
cx
)
;
if
(
!
reobj
.
getShared
(
cx
&
shared
)
)
return
false
;
ScopedMatchPairs
matches
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
RegExpRunStatus
status
=
ExecuteRegExpImpl
(
cx
res
*
shared
input
*
lastIndex
reobj
.
sticky
(
)
&
matches
nullptr
)
;
if
(
status
=
=
RegExpRunStatus_Error
)
return
false
;
if
(
status
=
=
RegExpRunStatus_Success_NotFound
)
{
rval
.
setNull
(
)
;
return
true
;
}
*
lastIndex
=
matches
[
0
]
.
limit
;
if
(
test
)
{
rval
.
setBoolean
(
true
)
;
return
true
;
}
return
CreateRegExpMatchResult
(
cx
input
matches
rval
)
;
}
static
bool
RegExpInitialize
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
obj
HandleValue
patternValue
HandleValue
flagsValue
RegExpStaticsUse
staticsUse
)
{
RootedAtom
pattern
(
cx
)
;
if
(
patternValue
.
isUndefined
(
)
)
{
pattern
=
cx
-
>
runtime
(
)
-
>
emptyString
;
}
else
{
pattern
=
ToAtom
<
CanGC
>
(
cx
patternValue
)
;
if
(
!
pattern
)
return
false
;
}
RegExpFlag
flags
=
RegExpFlag
(
0
)
;
if
(
!
flagsValue
.
isUndefined
(
)
)
{
RootedString
flagStr
(
cx
ToString
<
CanGC
>
(
cx
flagsValue
)
)
;
if
(
!
flagStr
)
return
false
;
if
(
!
ParseRegExpFlags
(
cx
flagStr
&
flags
)
)
return
false
;
}
CompileOptions
options
(
cx
)
;
frontend
:
:
TokenStream
dummyTokenStream
(
cx
options
nullptr
0
nullptr
)
;
if
(
!
irregexp
:
:
ParsePatternSyntax
(
dummyTokenStream
cx
-
>
tempLifoAlloc
(
)
pattern
flags
&
UnicodeFlag
)
)
{
return
false
;
}
if
(
staticsUse
=
=
UseRegExpStatics
)
{
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
if
(
!
res
)
return
false
;
flags
=
RegExpFlag
(
flags
|
res
-
>
getFlags
(
)
)
;
}
if
(
!
RegExpObject
:
:
initFromAtom
(
cx
obj
pattern
flags
)
)
return
false
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
IsRegExpObject
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
RegExpObject
>
(
)
;
}
bool
js
:
:
IsRegExp
(
JSContext
*
cx
HandleValue
value
bool
*
result
)
{
if
(
!
value
.
isObject
(
)
)
{
*
result
=
false
;
return
true
;
}
RootedObject
obj
(
cx
&
value
.
toObject
(
)
)
;
RootedValue
isRegExp
(
cx
)
;
RootedId
matchId
(
cx
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
match
)
)
;
if
(
!
GetProperty
(
cx
obj
obj
matchId
&
isRegExp
)
)
return
false
;
if
(
!
isRegExp
.
isUndefined
(
)
)
{
*
result
=
ToBoolean
(
isRegExp
)
;
return
true
;
}
ESClassValue
cls
;
if
(
!
GetClassOfValue
(
cx
value
&
cls
)
)
return
false
;
*
result
=
cls
=
=
ESClass_RegExp
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
regexp_compile_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
regexp
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
RootedValue
patternValue
(
cx
args
.
get
(
0
)
)
;
ESClassValue
cls
;
if
(
!
GetClassOfValue
(
cx
patternValue
&
cls
)
)
return
false
;
if
(
cls
=
=
ESClass_RegExp
)
{
if
(
args
.
hasDefined
(
1
)
)
{
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_NEWREGEXP_FLAGGED
)
;
return
false
;
}
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
RootedAtom
sourceAtom
(
cx
)
;
RegExpFlag
flags
;
{
RegExpGuard
g
(
cx
)
;
if
(
!
RegExpToShared
(
cx
patternObj
&
g
)
)
return
false
;
sourceAtom
=
g
-
>
getSource
(
)
;
flags
=
g
-
>
getFlags
(
)
;
}
if
(
!
RegExpObject
:
:
initFromAtom
(
cx
regexp
sourceAtom
flags
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
RootedValue
P
(
cx
patternValue
)
;
RootedValue
F
(
cx
args
.
get
(
1
)
)
;
if
(
!
RegExpInitialize
(
cx
regexp
P
F
UseRegExpStatics
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
static
bool
regexp_compile
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_compile_impl
>
(
cx
args
)
;
}
bool
js
:
:
regexp_construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
patternIsRegExp
;
if
(
!
IsRegExp
(
cx
args
.
get
(
0
)
&
patternIsRegExp
)
)
return
false
;
if
(
!
args
.
isConstructing
(
)
)
{
if
(
patternIsRegExp
&
&
!
args
.
hasDefined
(
1
)
)
{
RootedObject
patternObj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedValue
patternConstructor
(
cx
)
;
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
constructor
&
patternConstructor
)
)
return
false
;
if
(
patternConstructor
.
isObject
(
)
&
&
patternConstructor
.
toObject
(
)
=
=
args
.
callee
(
)
)
{
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
}
}
}
RootedValue
patternValue
(
cx
args
.
get
(
0
)
)
;
ESClassValue
cls
;
if
(
!
GetClassOfValue
(
cx
patternValue
&
cls
)
)
return
false
;
if
(
cls
=
=
ESClass_RegExp
)
{
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
RootedAtom
sourceAtom
(
cx
)
;
RegExpFlag
flags
;
{
RegExpGuard
g
(
cx
)
;
if
(
!
RegExpToShared
(
cx
patternObj
&
g
)
)
return
false
;
sourceAtom
=
g
-
>
getSource
(
)
;
if
(
!
args
.
hasDefined
(
1
)
)
{
flags
=
g
-
>
getFlags
(
)
;
}
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromCallableConstructor
(
cx
args
&
proto
)
)
return
false
;
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
proto
)
)
;
if
(
!
regexp
)
return
false
;
if
(
args
.
hasDefined
(
1
)
)
{
flags
=
RegExpFlag
(
0
)
;
RootedString
flagStr
(
cx
ToString
<
CanGC
>
(
cx
args
[
1
]
)
)
;
if
(
!
flagStr
)
return
false
;
if
(
!
ParseRegExpFlags
(
cx
flagStr
&
flags
)
)
return
false
;
}
if
(
!
RegExpObject
:
:
initFromAtom
(
cx
regexp
sourceAtom
flags
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
RootedValue
P
(
cx
)
;
RootedValue
F
(
cx
)
;
if
(
patternIsRegExp
)
{
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
source
&
P
)
)
return
false
;
F
=
args
.
get
(
1
)
;
if
(
F
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
flags
&
F
)
)
return
false
;
}
}
else
{
P
=
patternValue
;
F
=
args
.
get
(
1
)
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromCallableConstructor
(
cx
args
&
proto
)
)
return
false
;
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
proto
)
)
;
if
(
!
regexp
)
return
false
;
if
(
!
RegExpInitialize
(
cx
regexp
P
F
UseRegExpStatics
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
bool
js
:
:
regexp_construct_no_statics
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
|
|
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
MOZ_ASSERT_IF
(
args
.
length
(
)
=
=
2
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
!
args
.
isConstructing
(
)
)
;
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
)
)
;
if
(
!
regexp
)
return
false
;
if
(
!
RegExpInitialize
(
cx
regexp
args
[
0
]
args
.
get
(
1
)
DontUseRegExpStatics
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
regexp_global_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
reObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
reObj
-
>
global
(
)
)
;
return
true
;
}
static
bool
regexp_global
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_global_impl
>
(
cx
args
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_ignoreCase_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
reObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
reObj
-
>
ignoreCase
(
)
)
;
return
true
;
}
static
bool
regexp_ignoreCase
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_ignoreCase_impl
>
(
cx
args
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_multiline_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
reObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
reObj
-
>
multiline
(
)
)
;
return
true
;
}
static
bool
regexp_multiline
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_multiline_impl
>
(
cx
args
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_source_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
reObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
RootedAtom
src
(
cx
reObj
-
>
getSource
(
)
)
;
if
(
!
src
)
return
false
;
RootedString
str
(
cx
EscapeRegExpPattern
(
cx
src
)
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
regexp_source
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_source_impl
>
(
cx
args
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_sticky_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
reObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
reObj
-
>
sticky
(
)
)
;
return
true
;
}
static
bool
regexp_sticky
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_sticky_impl
>
(
cx
args
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_unicode_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
args
.
rval
(
)
.
setBoolean
(
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
.
unicode
(
)
)
;
return
true
;
}
static
bool
regexp_unicode
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_unicode_impl
>
(
cx
args
)
;
}
const
JSPropertySpec
js
:
:
regexp_properties
[
]
=
{
JS_SELF_HOSTED_GET
(
"
flags
"
"
RegExpFlagsGetter
"
0
)
JS_PSG
(
"
global
"
regexp_global
0
)
JS_PSG
(
"
ignoreCase
"
regexp_ignoreCase
0
)
JS_PSG
(
"
multiline
"
regexp_multiline
0
)
JS_PSG
(
"
source
"
regexp_source
0
)
JS_PSG
(
"
sticky
"
regexp_sticky
0
)
JS_PSG
(
"
unicode
"
regexp_unicode
0
)
JS_PS_END
}
;
const
JSFunctionSpec
js
:
:
regexp_methods
[
]
=
{
#
if
JS_HAS_TOSOURCE
JS_SELF_HOSTED_FN
(
js_toSource_str
"
RegExpToString
"
0
0
)
#
endif
JS_SELF_HOSTED_FN
(
js_toString_str
"
RegExpToString
"
0
0
)
JS_FN
(
"
compile
"
regexp_compile
2
0
)
JS_SELF_HOSTED_FN
(
"
exec
"
"
RegExp_prototype_Exec
"
1
0
)
JS_SELF_HOSTED_FN
(
"
test
"
"
RegExpTest
"
1
0
)
JS_FS_END
}
;
#
define
STATIC_PAREN_GETTER_CODE
(
parenNum
)
\
if
(
!
res
-
>
createParen
(
cx
parenNum
args
.
rval
(
)
)
)
\
return
false
;
\
if
(
args
.
rval
(
)
.
isUndefined
(
)
)
\
args
.
rval
(
)
.
setString
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
\
return
true
#
define
DEFINE_STATIC_GETTER
(
name
code
)
\
static
bool
\
name
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
\
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
\
if
(
!
res
)
\
return
false
;
\
code
;
\
}
DEFINE_STATIC_GETTER
(
static_input_getter
return
res
-
>
createPendingInput
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_lastMatch_getter
return
res
-
>
createLastMatch
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_lastParen_getter
return
res
-
>
createLastParen
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_leftContext_getter
return
res
-
>
createLeftContext
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_rightContext_getter
return
res
-
>
createRightContext
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_paren1_getter
STATIC_PAREN_GETTER_CODE
(
1
)
)
DEFINE_STATIC_GETTER
(
static_paren2_getter
STATIC_PAREN_GETTER_CODE
(
2
)
)
DEFINE_STATIC_GETTER
(
static_paren3_getter
STATIC_PAREN_GETTER_CODE
(
3
)
)
DEFINE_STATIC_GETTER
(
static_paren4_getter
STATIC_PAREN_GETTER_CODE
(
4
)
)
DEFINE_STATIC_GETTER
(
static_paren5_getter
STATIC_PAREN_GETTER_CODE
(
5
)
)
DEFINE_STATIC_GETTER
(
static_paren6_getter
STATIC_PAREN_GETTER_CODE
(
6
)
)
DEFINE_STATIC_GETTER
(
static_paren7_getter
STATIC_PAREN_GETTER_CODE
(
7
)
)
DEFINE_STATIC_GETTER
(
static_paren8_getter
STATIC_PAREN_GETTER_CODE
(
8
)
)
DEFINE_STATIC_GETTER
(
static_paren9_getter
STATIC_PAREN_GETTER_CODE
(
9
)
)
#
define
DEFINE_STATIC_SETTER
(
name
code
)
\
static
bool
\
name
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
\
{
\
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
\
if
(
!
res
)
\
return
false
;
\
code
;
\
return
true
;
\
}
static
bool
static_input_setter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
if
(
!
res
)
return
false
;
RootedString
str
(
cx
ToString
<
CanGC
>
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
str
)
return
false
;
res
-
>
setPendingInput
(
str
)
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
WarnOnceAboutRegExpMultiline
(
JSContext
*
cx
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
warnedAboutRegExpMultiline
)
{
if
(
!
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_WARNING
GetErrorMessage
nullptr
JSMSG_DEPRECATED_REGEXP_MULTILINE
)
)
{
return
false
;
}
cx
-
>
compartment
(
)
-
>
warnedAboutRegExpMultiline
=
true
;
}
return
true
;
}
static
bool
static_multiline_getter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
if
(
!
res
)
return
false
;
if
(
!
WarnOnceAboutRegExpMultiline
(
cx
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
res
-
>
multiline
(
)
)
;
return
true
;
}
static
bool
static_multiline_setter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RegExpStatics
*
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
if
(
!
res
)
return
false
;
if
(
!
WarnOnceAboutRegExpMultiline
(
cx
)
)
return
false
;
bool
b
=
ToBoolean
(
args
.
get
(
0
)
)
;
res
-
>
setMultiline
(
cx
b
)
;
args
.
rval
(
)
.
setBoolean
(
b
)
;
return
true
;
}
const
JSPropertySpec
js
:
:
regexp_static_props
[
]
=
{
JS_PSGS
(
"
input
"
static_input_getter
static_input_setter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSGS
(
"
multiline
"
static_multiline_getter
static_multiline_setter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
lastMatch
"
static_lastMatch_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
lastParen
"
static_lastParen_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
leftContext
"
static_leftContext_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
rightContext
"
static_rightContext_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
1
"
static_paren1_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
2
"
static_paren2_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
3
"
static_paren3_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
4
"
static_paren4_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
5
"
static_paren5_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
6
"
static_paren6_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
7
"
static_paren7_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
8
"
static_paren8_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
9
"
static_paren9_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSGS
(
"
_
"
static_input_getter
static_input_setter
JSPROP_PERMANENT
)
JS_PSGS
(
"
*
"
static_multiline_getter
static_multiline_setter
JSPROP_PERMANENT
)
JS_PSG
(
"
&
"
static_lastMatch_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
+
"
static_lastParen_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
"
static_leftContext_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
'
"
static_rightContext_getter
JSPROP_PERMANENT
)
JS_PS_END
}
;
JSObject
*
js
:
:
CreateRegExpPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
MOZ_ASSERT
(
key
=
=
JSProto_RegExp
)
;
Rooted
<
RegExpObject
*
>
proto
(
cx
cx
-
>
global
(
)
-
>
createBlankPrototype
<
RegExpObject
>
(
cx
)
)
;
if
(
!
proto
)
return
nullptr
;
proto
-
>
NativeObject
:
:
setPrivate
(
nullptr
)
;
RootedAtom
source
(
cx
cx
-
>
names
(
)
.
empty
)
;
if
(
!
RegExpObject
:
:
initFromAtom
(
cx
proto
source
RegExpFlag
(
0
)
)
)
return
nullptr
;
return
proto
;
}
template
<
typename
CharT
>
static
bool
IsTrailSurrogateWithLeadSurrogateImpl
(
JSContext
*
cx
HandleLinearString
input
size_t
index
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
index
>
0
&
&
index
<
input
-
>
length
(
)
)
;
const
CharT
*
inputChars
=
input
-
>
chars
<
CharT
>
(
nogc
)
;
return
unicode
:
:
IsTrailSurrogate
(
inputChars
[
index
]
)
&
&
unicode
:
:
IsLeadSurrogate
(
inputChars
[
index
-
1
]
)
;
}
static
bool
IsTrailSurrogateWithLeadSurrogate
(
JSContext
*
cx
HandleLinearString
input
int32_t
index
)
{
if
(
index
<
=
0
|
|
size_t
(
index
)
>
=
input
-
>
length
(
)
)
return
false
;
return
input
-
>
hasLatin1Chars
(
)
?
IsTrailSurrogateWithLeadSurrogateImpl
<
Latin1Char
>
(
cx
input
index
)
:
IsTrailSurrogateWithLeadSurrogateImpl
<
char16_t
>
(
cx
input
index
)
;
}
static
RegExpRunStatus
ExecuteRegExp
(
JSContext
*
cx
HandleObject
regexp
HandleString
string
int32_t
lastIndex
bool
sticky
MatchPairs
*
matches
size_t
*
endIndex
RegExpStaticsUpdate
staticsUpdate
)
{
Rooted
<
RegExpObject
*
>
reobj
(
cx
&
regexp
-
>
as
<
RegExpObject
>
(
)
)
;
RegExpGuard
re
(
cx
)
;
if
(
!
reobj
-
>
getShared
(
cx
&
re
)
)
return
RegExpRunStatus_Error
;
RegExpStatics
*
res
;
if
(
staticsUpdate
=
=
UpdateRegExpStatics
)
{
res
=
cx
-
>
global
(
)
-
>
getRegExpStatics
(
cx
)
;
if
(
!
res
)
return
RegExpRunStatus_Error
;
}
else
{
res
=
nullptr
;
}
RootedLinearString
input
(
cx
string
-
>
ensureLinear
(
cx
)
)
;
if
(
!
input
)
return
RegExpRunStatus_Error
;
MOZ_ASSERT
(
lastIndex
>
=
0
&
&
size_t
(
lastIndex
)
<
=
input
-
>
length
(
)
)
;
if
(
reobj
-
>
unicode
(
)
)
{
if
(
IsTrailSurrogateWithLeadSurrogate
(
cx
input
lastIndex
)
)
lastIndex
-
-
;
}
RegExpRunStatus
status
=
ExecuteRegExpImpl
(
cx
res
*
re
input
lastIndex
sticky
matches
endIndex
)
;
if
(
status
=
=
RegExpRunStatus_Error
)
return
RegExpRunStatus_Error
;
return
status
;
}
static
bool
RegExpMatcherImpl
(
JSContext
*
cx
HandleObject
regexp
HandleString
string
int32_t
lastIndex
bool
sticky
RegExpStaticsUpdate
staticsUpdate
MutableHandleValue
rval
)
{
ScopedMatchPairs
matches
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
string
lastIndex
sticky
&
matches
nullptr
staticsUpdate
)
;
if
(
status
=
=
RegExpRunStatus_Error
)
return
false
;
if
(
status
=
=
RegExpRunStatus_Success_NotFound
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
CreateRegExpMatchResult
(
cx
string
matches
rval
)
;
}
bool
js
:
:
RegExpMatcher
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
4
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isNumber
(
)
)
;
MOZ_ASSERT
(
args
[
3
]
.
isBoolean
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
RootedValue
lastIndexVal
(
cx
args
[
2
]
)
;
bool
sticky
=
ToBoolean
(
args
[
3
]
)
;
int32_t
lastIndex
=
0
;
if
(
!
ToInt32
(
cx
lastIndexVal
&
lastIndex
)
)
return
false
;
return
RegExpMatcherImpl
(
cx
regexp
string
lastIndex
sticky
UpdateRegExpStatics
args
.
rval
(
)
)
;
}
bool
js
:
:
RegExpMatcherRaw
(
JSContext
*
cx
HandleObject
regexp
HandleString
input
uint32_t
lastIndex
bool
sticky
MatchPairs
*
maybeMatches
MutableHandleValue
output
)
{
MOZ_ASSERT
(
lastIndex
<
=
INT32_MAX
)
;
if
(
maybeMatches
&
&
maybeMatches
-
>
pairsRaw
(
)
[
0
]
>
=
0
)
return
CreateRegExpMatchResult
(
cx
input
*
maybeMatches
output
)
;
return
RegExpMatcherImpl
(
cx
regexp
input
lastIndex
sticky
UpdateRegExpStatics
output
)
;
}
bool
js
:
:
regexp_exec_no_statics
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
return
RegExpMatcherImpl
(
cx
regexp
string
0
false
DontUpdateRegExpStatics
args
.
rval
(
)
)
;
}
bool
js
:
:
RegExpTester
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
4
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isNumber
(
)
)
;
MOZ_ASSERT
(
args
[
3
]
.
isBoolean
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
RootedValue
lastIndexVal
(
cx
args
[
2
]
)
;
bool
sticky
=
ToBoolean
(
args
[
3
]
)
;
int32_t
lastIndex
=
0
;
if
(
!
ToInt32
(
cx
lastIndexVal
&
lastIndex
)
)
return
false
;
size_t
endIndex
=
0
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
string
lastIndex
sticky
nullptr
&
endIndex
UpdateRegExpStatics
)
;
if
(
status
=
=
RegExpRunStatus_Error
)
return
false
;
if
(
status
=
=
RegExpRunStatus_Success
)
{
MOZ_ASSERT
(
endIndex
<
=
INT32_MAX
)
;
args
.
rval
(
)
.
setInt32
(
int32_t
(
endIndex
)
)
;
}
else
{
args
.
rval
(
)
.
setInt32
(
-
1
)
;
}
return
true
;
}
bool
js
:
:
RegExpTesterRaw
(
JSContext
*
cx
HandleObject
regexp
HandleString
input
uint32_t
lastIndex
bool
sticky
int32_t
*
endIndex
)
{
MOZ_ASSERT
(
lastIndex
<
=
INT32_MAX
)
;
size_t
endIndexTmp
=
0
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
input
lastIndex
sticky
nullptr
&
endIndexTmp
UpdateRegExpStatics
)
;
if
(
status
=
=
RegExpRunStatus_Success
)
{
MOZ_ASSERT
(
endIndexTmp
<
=
INT32_MAX
)
;
*
endIndex
=
int32_t
(
endIndexTmp
)
;
return
true
;
}
if
(
status
=
=
RegExpRunStatus_Success_NotFound
)
{
*
endIndex
=
-
1
;
return
true
;
}
return
false
;
}
bool
js
:
:
regexp_test_no_statics
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
size_t
ignored
=
0
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
string
0
false
nullptr
&
ignored
DontUpdateRegExpStatics
)
;
args
.
rval
(
)
.
setBoolean
(
status
=
=
RegExpRunStatus_Success
)
;
return
status
!
=
RegExpRunStatus_Error
;
}
