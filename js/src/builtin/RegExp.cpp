#
include
"
builtin
/
RegExp
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
irregexp
/
RegExpAPI
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
util
/
StringBuilder
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
RegExpStatics
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
#
include
"
vm
/
PlainObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
IsAsciiDigit
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
RegExpFlag
;
using
JS
:
:
RegExpFlags
;
static
PlainObject
*
CreateGroupsObject
(
JSContext
*
cx
Handle
<
PlainObject
*
>
groupsTemplate
)
{
if
(
groupsTemplate
-
>
inDictionaryMode
(
)
)
{
return
NewPlainObjectWithProto
(
cx
nullptr
)
;
}
if
(
cx
-
>
realm
(
)
!
=
groupsTemplate
-
>
realm
(
)
)
{
return
PlainObject
:
:
createWithTemplateFromDifferentRealm
(
cx
groupsTemplate
)
;
}
return
PlainObject
:
:
createWithTemplate
(
cx
groupsTemplate
)
;
}
static
inline
void
getValueAndIndex
(
HandleRegExpShared
re
uint32_t
i
Handle
<
ArrayObject
*
>
arr
MutableHandleValue
val
uint32_t
&
valueIndex
)
{
if
(
re
-
>
numNamedCaptures
(
)
=
=
re
-
>
numDistinctNamedCaptures
(
)
)
{
valueIndex
=
re
-
>
getNamedCaptureIndex
(
i
)
;
val
.
set
(
arr
-
>
getDenseElement
(
valueIndex
)
)
;
}
else
{
mozilla
:
:
Span
<
uint32_t
>
indicesSlice
=
re
-
>
getNamedCaptureIndices
(
i
)
;
MOZ_ASSERT
(
!
indicesSlice
.
IsEmpty
(
)
)
;
valueIndex
=
indicesSlice
[
0
]
;
for
(
uint32_t
index
:
indicesSlice
)
{
val
.
set
(
arr
-
>
getDenseElement
(
index
)
)
;
if
(
!
val
.
isUndefined
(
)
)
{
valueIndex
=
index
;
break
;
}
}
}
}
bool
js
:
:
CreateRegExpMatchResult
(
JSContext
*
cx
HandleRegExpShared
re
HandleString
input
const
MatchPairs
&
matches
MutableHandleValue
rval
)
{
MOZ_ASSERT
(
re
)
;
MOZ_ASSERT
(
input
)
;
bool
hasIndices
=
re
-
>
hasIndices
(
)
;
RegExpRealm
:
:
ResultShapeKind
kind
=
hasIndices
?
RegExpRealm
:
:
ResultShapeKind
:
:
WithIndices
:
RegExpRealm
:
:
ResultShapeKind
:
:
Normal
;
Rooted
<
SharedShape
*
>
shape
(
cx
cx
-
>
global
(
)
-
>
regExpRealm
(
)
.
getOrCreateMatchResultShape
(
cx
kind
)
)
;
if
(
!
shape
)
{
return
false
;
}
size_t
numPairs
=
matches
.
length
(
)
;
MOZ_ASSERT
(
numPairs
>
0
)
;
Rooted
<
ArrayObject
*
>
arr
(
cx
NewDenseFullyAllocatedArrayWithShape
(
cx
numPairs
shape
)
)
;
if
(
!
arr
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
numPairs
;
i
+
+
)
{
const
MatchPair
&
pair
=
matches
[
i
]
;
if
(
pair
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
i
!
=
0
)
;
arr
-
>
setDenseInitializedLength
(
i
+
1
)
;
arr
-
>
initDenseElement
(
i
UndefinedValue
(
)
)
;
}
else
{
JSLinearString
*
str
=
NewDependentString
(
cx
input
pair
.
start
pair
.
length
(
)
)
;
if
(
!
str
)
{
return
false
;
}
arr
-
>
setDenseInitializedLength
(
i
+
1
)
;
arr
-
>
initDenseElement
(
i
StringValue
(
str
)
)
;
}
}
Rooted
<
ArrayObject
*
>
indices
(
cx
)
;
Rooted
<
PlainObject
*
>
indicesGroups
(
cx
)
;
if
(
hasIndices
)
{
Rooted
<
SharedShape
*
>
indicesShape
(
cx
cx
-
>
global
(
)
-
>
regExpRealm
(
)
.
getOrCreateMatchResultShape
(
cx
RegExpRealm
:
:
ResultShapeKind
:
:
Indices
)
)
;
if
(
!
indicesShape
)
{
return
false
;
}
indices
=
NewDenseFullyAllocatedArrayWithShape
(
cx
numPairs
indicesShape
)
;
if
(
!
indices
)
{
return
false
;
}
if
(
re
-
>
numNamedCaptures
(
)
>
0
)
{
Rooted
<
PlainObject
*
>
groupsTemplate
(
cx
re
-
>
getGroupsTemplate
(
)
)
;
indicesGroups
=
CreateGroupsObject
(
cx
groupsTemplate
)
;
if
(
!
indicesGroups
)
{
return
false
;
}
indices
-
>
initSlot
(
RegExpRealm
:
:
IndicesGroupsSlot
ObjectValue
(
*
indicesGroups
)
)
;
}
for
(
size_t
i
=
0
;
i
<
numPairs
;
i
+
+
)
{
const
MatchPair
&
pair
=
matches
[
i
]
;
if
(
pair
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
i
!
=
0
)
;
indices
-
>
setDenseInitializedLength
(
i
+
1
)
;
indices
-
>
initDenseElement
(
i
UndefinedValue
(
)
)
;
}
else
{
ArrayObject
*
indexPair
=
NewDenseFullyAllocatedArray
(
cx
2
)
;
if
(
!
indexPair
)
{
return
false
;
}
indexPair
-
>
setDenseInitializedLength
(
2
)
;
indexPair
-
>
initDenseElement
(
0
Int32Value
(
pair
.
start
)
)
;
indexPair
-
>
initDenseElement
(
1
Int32Value
(
pair
.
limit
)
)
;
indices
-
>
setDenseInitializedLength
(
i
+
1
)
;
indices
-
>
initDenseElement
(
i
ObjectValue
(
*
indexPair
)
)
;
}
}
}
Rooted
<
PlainObject
*
>
groups
(
cx
)
;
bool
groupsInDictionaryMode
=
false
;
if
(
re
-
>
numNamedCaptures
(
)
>
0
)
{
Rooted
<
PlainObject
*
>
groupsTemplate
(
cx
re
-
>
getGroupsTemplate
(
)
)
;
groupsInDictionaryMode
=
groupsTemplate
-
>
inDictionaryMode
(
)
;
groups
=
CreateGroupsObject
(
cx
groupsTemplate
)
;
if
(
!
groups
)
{
return
false
;
}
}
if
(
groupsInDictionaryMode
)
{
RootedIdVector
keys
(
cx
)
;
Rooted
<
PlainObject
*
>
groupsTemplate
(
cx
re
-
>
getGroupsTemplate
(
)
)
;
if
(
!
GetPropertyKeys
(
cx
groupsTemplate
0
&
keys
)
)
{
return
false
;
}
MOZ_ASSERT
(
keys
.
length
(
)
=
=
re
-
>
numDistinctNamedCaptures
(
)
)
;
RootedId
key
(
cx
)
;
RootedValue
val
(
cx
)
;
uint32_t
valueIndex
;
for
(
uint32_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
key
=
keys
[
i
]
;
getValueAndIndex
(
re
i
arr
&
val
valueIndex
)
;
if
(
!
NativeDefineDataProperty
(
cx
groups
key
val
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
hasIndices
)
{
val
=
indices
-
>
getDenseElement
(
valueIndex
)
;
if
(
!
NativeDefineDataProperty
(
cx
indicesGroups
key
val
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
}
}
else
{
RootedValue
val
(
cx
)
;
uint32_t
valueIndex
;
for
(
uint32_t
i
=
0
;
i
<
re
-
>
numDistinctNamedCaptures
(
)
;
i
+
+
)
{
getValueAndIndex
(
re
i
arr
&
val
valueIndex
)
;
groups
-
>
initSlot
(
i
val
)
;
if
(
hasIndices
)
{
indicesGroups
-
>
initSlot
(
i
indices
-
>
getDenseElement
(
valueIndex
)
)
;
}
}
}
arr
-
>
initSlot
(
RegExpRealm
:
:
MatchResultObjectIndexSlot
Int32Value
(
matches
[
0
]
.
start
)
)
;
arr
-
>
initSlot
(
RegExpRealm
:
:
MatchResultObjectInputSlot
StringValue
(
input
)
)
;
if
(
groups
)
{
arr
-
>
initSlot
(
RegExpRealm
:
:
MatchResultObjectGroupsSlot
ObjectValue
(
*
groups
)
)
;
}
if
(
re
-
>
hasIndices
(
)
)
{
arr
-
>
initSlot
(
RegExpRealm
:
:
MatchResultObjectIndicesSlot
ObjectValue
(
*
indices
)
)
;
}
#
ifdef
DEBUG
RootedValue
test
(
cx
)
;
RootedId
id
(
cx
NameToId
(
cx
-
>
names
(
)
.
index
)
)
;
if
(
!
NativeGetProperty
(
cx
arr
id
&
test
)
)
{
return
false
;
}
MOZ_ASSERT
(
test
=
=
arr
-
>
getSlot
(
RegExpRealm
:
:
MatchResultObjectIndexSlot
)
)
;
id
=
NameToId
(
cx
-
>
names
(
)
.
input
)
;
if
(
!
NativeGetProperty
(
cx
arr
id
&
test
)
)
{
return
false
;
}
MOZ_ASSERT
(
test
=
=
arr
-
>
getSlot
(
RegExpRealm
:
:
MatchResultObjectInputSlot
)
)
;
#
endif
rval
.
setObject
(
*
arr
)
;
return
true
;
}
static
int32_t
CreateRegExpSearchResult
(
JSContext
*
cx
const
MatchPairs
&
matches
)
{
MOZ_ASSERT
(
matches
[
0
]
.
start
>
=
0
)
;
MOZ_ASSERT
(
matches
[
0
]
.
limit
>
=
0
)
;
MOZ_ASSERT
(
cx
-
>
regExpSearcherLastLimit
=
=
RegExpSearcherLastLimitSentinel
)
;
#
ifdef
DEBUG
static_assert
(
JSString
:
:
MAX_LENGTH
<
RegExpSearcherLastLimitSentinel
)
;
MOZ_ASSERT
(
uint32_t
(
matches
[
0
]
.
limit
)
<
RegExpSearcherLastLimitSentinel
)
;
#
endif
cx
-
>
regExpSearcherLastLimit
=
matches
[
0
]
.
limit
;
return
matches
[
0
]
.
start
;
}
static
RegExpRunStatus
ExecuteRegExpImpl
(
JSContext
*
cx
RegExpStatics
*
res
MutableHandleRegExpShared
re
Handle
<
JSLinearString
*
>
input
size_t
searchIndex
VectorMatchPairs
*
matches
)
{
RegExpRunStatus
status
=
RegExpShared
:
:
execute
(
cx
re
input
searchIndex
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Success
&
&
res
)
{
if
(
!
res
-
>
updateFromMatchPairs
(
cx
input
*
matches
)
)
{
return
RegExpRunStatus
:
:
Error
;
}
}
return
status
;
}
bool
js
:
:
ExecuteRegExpLegacy
(
JSContext
*
cx
RegExpStatics
*
res
Handle
<
RegExpObject
*
>
reobj
Handle
<
JSLinearString
*
>
input
size_t
*
lastIndex
bool
test
MutableHandleValue
rval
)
{
cx
-
>
check
(
reobj
input
)
;
RootedRegExpShared
shared
(
cx
RegExpObject
:
:
getShared
(
cx
reobj
)
)
;
if
(
!
shared
)
{
return
false
;
}
VectorMatchPairs
matches
;
RegExpRunStatus
status
=
ExecuteRegExpImpl
(
cx
res
&
shared
input
*
lastIndex
&
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
false
;
}
if
(
status
=
=
RegExpRunStatus
:
:
Success_NotFound
)
{
rval
.
setNull
(
)
;
return
true
;
}
*
lastIndex
=
matches
[
0
]
.
limit
;
if
(
test
)
{
rval
.
setBoolean
(
true
)
;
return
true
;
}
return
CreateRegExpMatchResult
(
cx
shared
input
matches
rval
)
;
}
static
bool
CheckPatternSyntaxSlow
(
JSContext
*
cx
Handle
<
JSAtom
*
>
pattern
RegExpFlags
flags
)
{
LifoAllocScope
allocScope
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
AutoReportFrontendContext
fc
(
cx
)
;
CompileOptions
options
(
cx
)
;
frontend
:
:
DummyTokenStream
dummyTokenStream
(
&
fc
options
)
;
return
irregexp
:
:
CheckPatternSyntax
(
cx
cx
-
>
stackLimitForCurrentPrincipal
(
)
dummyTokenStream
pattern
flags
)
;
}
static
RegExpShared
*
CheckPatternSyntax
(
JSContext
*
cx
Handle
<
JSAtom
*
>
pattern
RegExpFlags
flags
)
{
RootedRegExpShared
shared
(
cx
cx
-
>
zone
(
)
-
>
regExps
(
)
.
maybeGet
(
pattern
flags
)
)
;
if
(
shared
)
{
#
ifdef
DEBUG
if
(
!
CheckPatternSyntaxSlow
(
cx
pattern
flags
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
|
|
cx
-
>
isThrowingOverRecursed
(
)
)
;
return
nullptr
;
}
#
endif
return
shared
;
}
if
(
!
CheckPatternSyntaxSlow
(
cx
pattern
flags
)
)
{
return
nullptr
;
}
return
cx
-
>
zone
(
)
-
>
regExps
(
)
.
get
(
cx
pattern
flags
)
;
}
static
bool
RegExpInitializeIgnoringLastIndex
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
obj
HandleValue
patternValue
HandleValue
flagsValue
)
{
Rooted
<
JSAtom
*
>
pattern
(
cx
)
;
if
(
patternValue
.
isUndefined
(
)
)
{
pattern
=
cx
-
>
names
(
)
.
empty_
;
}
else
{
pattern
=
ToAtom
<
CanGC
>
(
cx
patternValue
)
;
if
(
!
pattern
)
{
return
false
;
}
}
RegExpFlags
flags
=
RegExpFlag
:
:
NoFlags
;
if
(
!
flagsValue
.
isUndefined
(
)
)
{
RootedString
flagStr
(
cx
ToString
<
CanGC
>
(
cx
flagsValue
)
)
;
if
(
!
flagStr
)
{
return
false
;
}
if
(
!
ParseRegExpFlags
(
cx
flagStr
&
flags
)
)
{
return
false
;
}
}
RegExpShared
*
shared
=
CheckPatternSyntax
(
cx
pattern
flags
)
;
if
(
!
shared
)
{
return
false
;
}
obj
-
>
initIgnoringLastIndex
(
pattern
flags
)
;
obj
-
>
setShared
(
shared
)
;
return
true
;
}
bool
js
:
:
RegExpCreate
(
JSContext
*
cx
HandleValue
patternValue
HandleValue
flagsValue
MutableHandleValue
rval
)
{
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
GenericObject
)
)
;
if
(
!
regexp
)
{
return
false
;
}
if
(
!
RegExpInitializeIgnoringLastIndex
(
cx
regexp
patternValue
flagsValue
)
)
{
return
false
;
}
regexp
-
>
zeroLastIndex
(
cx
)
;
rval
.
setObject
(
*
regexp
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
IsRegExpObject
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
RegExpObject
>
(
)
;
}
bool
js
:
:
IsRegExp
(
JSContext
*
cx
HandleValue
value
bool
*
result
)
{
if
(
!
value
.
isObject
(
)
)
{
*
result
=
false
;
return
true
;
}
RootedObject
obj
(
cx
&
value
.
toObject
(
)
)
;
RootedValue
isRegExp
(
cx
)
;
RootedId
matchId
(
cx
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
match
)
)
;
if
(
!
GetProperty
(
cx
obj
obj
matchId
&
isRegExp
)
)
{
return
false
;
}
if
(
!
isRegExp
.
isUndefined
(
)
)
{
*
result
=
ToBoolean
(
isRegExp
)
;
return
true
;
}
ESClass
cls
;
if
(
!
GetClassOfValue
(
cx
value
&
cls
)
)
{
return
false
;
}
*
result
=
cls
=
=
ESClass
:
:
RegExp
;
return
true
;
}
template
<
bool
CalledFromJit
=
false
>
static
bool
SetLastIndex
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
int32_t
lastIndex
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
if
(
CalledFromJit
|
|
MOZ_LIKELY
(
RegExpObject
:
:
isInitialShape
(
regexp
)
)
|
|
regexp
-
>
lookupPure
(
cx
-
>
names
(
)
.
lastIndex
)
-
>
writable
(
)
)
{
regexp
-
>
setLastIndex
(
cx
lastIndex
)
;
return
true
;
}
Rooted
<
Value
>
val
(
cx
Int32Value
(
lastIndex
)
)
;
return
SetProperty
(
cx
regexp
cx
-
>
names
(
)
.
lastIndex
val
)
;
}
MOZ_ALWAYS_INLINE
bool
regexp_compile_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsRegExpObject
(
args
.
thisv
(
)
)
)
;
Rooted
<
RegExpObject
*
>
regexp
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
RegExpObject
>
(
)
)
;
RootedValue
patternValue
(
cx
args
.
get
(
0
)
)
;
ESClass
cls
;
if
(
!
GetClassOfValue
(
cx
patternValue
&
cls
)
)
{
return
false
;
}
if
(
cls
=
=
ESClass
:
:
RegExp
)
{
if
(
args
.
hasDefined
(
1
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NEWREGEXP_FLAGGED
)
;
return
false
;
}
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
Rooted
<
JSAtom
*
>
sourceAtom
(
cx
)
;
RegExpFlags
flags
=
RegExpFlag
:
:
NoFlags
;
{
RegExpShared
*
shared
=
RegExpToShared
(
cx
patternObj
)
;
if
(
!
shared
)
{
return
false
;
}
sourceAtom
=
shared
-
>
getSource
(
)
;
flags
=
shared
-
>
getFlags
(
)
;
}
regexp
-
>
initIgnoringLastIndex
(
sourceAtom
flags
)
;
}
else
{
RootedValue
P
(
cx
patternValue
)
;
RootedValue
F
(
cx
args
.
get
(
1
)
)
;
if
(
!
RegExpInitializeIgnoringLastIndex
(
cx
regexp
P
F
)
)
{
return
false
;
}
}
if
(
!
SetLastIndex
(
cx
regexp
0
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
static
bool
regexp_compile
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsRegExpObject
regexp_compile_impl
>
(
cx
args
)
;
}
bool
js
:
:
regexp_construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSConstructorProfilerEntry
pseudoFrame
(
cx
"
RegExp
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
patternIsRegExp
;
if
(
!
IsRegExp
(
cx
args
.
get
(
0
)
&
patternIsRegExp
)
)
{
return
false
;
}
if
(
!
args
.
isConstructing
(
)
)
{
if
(
patternIsRegExp
&
&
!
args
.
hasDefined
(
1
)
)
{
RootedObject
patternObj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedValue
patternConstructor
(
cx
)
;
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
constructor
&
patternConstructor
)
)
{
return
false
;
}
if
(
patternConstructor
.
isObject
(
)
&
&
patternConstructor
.
toObject
(
)
=
=
args
.
callee
(
)
)
{
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
}
}
}
RootedValue
patternValue
(
cx
args
.
get
(
0
)
)
;
ESClass
cls
;
if
(
!
GetClassOfValue
(
cx
patternValue
&
cls
)
)
{
return
false
;
}
if
(
cls
=
=
ESClass
:
:
RegExp
)
{
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
Rooted
<
JSAtom
*
>
sourceAtom
(
cx
)
;
RegExpFlags
flags
;
RootedRegExpShared
shared
(
cx
)
;
{
shared
=
RegExpToShared
(
cx
patternObj
)
;
if
(
!
shared
)
{
return
false
;
}
sourceAtom
=
shared
-
>
getSource
(
)
;
flags
=
shared
-
>
getFlags
(
)
;
if
(
cx
-
>
zone
(
)
!
=
shared
-
>
zone
(
)
)
{
shared
=
nullptr
;
}
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_RegExp
&
proto
)
)
{
return
false
;
}
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
GenericObject
proto
)
)
;
if
(
!
regexp
)
{
return
false
;
}
if
(
args
.
hasDefined
(
1
)
)
{
RegExpFlags
flagsArg
=
RegExpFlag
:
:
NoFlags
;
RootedString
flagStr
(
cx
ToString
<
CanGC
>
(
cx
args
[
1
]
)
)
;
if
(
!
flagStr
)
{
return
false
;
}
if
(
!
ParseRegExpFlags
(
cx
flagStr
&
flagsArg
)
)
{
return
false
;
}
if
(
flags
!
=
flagsArg
)
{
shared
=
nullptr
;
}
if
(
!
flags
.
unicode
(
)
&
&
flagsArg
.
unicode
(
)
)
{
shared
=
CheckPatternSyntax
(
cx
sourceAtom
flagsArg
)
;
if
(
!
shared
)
{
return
false
;
}
}
flags
=
flagsArg
;
}
regexp
-
>
initAndZeroLastIndex
(
sourceAtom
flags
cx
)
;
if
(
shared
)
{
regexp
-
>
setShared
(
shared
)
;
}
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
RootedValue
P
(
cx
)
;
RootedValue
F
(
cx
)
;
if
(
patternIsRegExp
)
{
RootedObject
patternObj
(
cx
&
patternValue
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
source
&
P
)
)
{
return
false
;
}
F
=
args
.
get
(
1
)
;
if
(
F
.
isUndefined
(
)
)
{
if
(
!
GetProperty
(
cx
patternObj
patternObj
cx
-
>
names
(
)
.
flags
&
F
)
)
{
return
false
;
}
}
}
else
{
P
=
patternValue
;
F
=
args
.
get
(
1
)
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_RegExp
&
proto
)
)
{
return
false
;
}
Rooted
<
RegExpObject
*
>
regexp
(
cx
RegExpAlloc
(
cx
GenericObject
proto
)
)
;
if
(
!
regexp
)
{
return
false
;
}
if
(
!
RegExpInitializeIgnoringLastIndex
(
cx
regexp
P
F
)
)
{
return
false
;
}
regexp
-
>
zeroLastIndex
(
cx
)
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
bool
js
:
:
regexp_construct_raw_flags
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
args
.
isConstructing
(
)
)
;
Rooted
<
JSAtom
*
>
sourceAtom
(
cx
AtomizeString
(
cx
args
[
0
]
.
toString
(
)
)
)
;
if
(
!
sourceAtom
)
{
return
false
;
}
RegExpFlags
flags
=
AssertedCast
<
uint8_t
>
(
int32_t
(
args
[
1
]
.
toNumber
(
)
)
)
;
RegExpObject
*
regexp
=
RegExpAlloc
(
cx
GenericObject
)
;
if
(
!
regexp
)
{
return
false
;
}
regexp
-
>
initAndZeroLastIndex
(
sourceAtom
flags
cx
)
;
args
.
rval
(
)
.
setObject
(
*
regexp
)
;
return
true
;
}
template
<
typename
Fn
>
static
bool
RegExpGetter
(
JSContext
*
cx
CallArgs
&
args
const
char
*
methodName
Fn
&
&
fn
HandleValue
fallbackValue
=
UndefinedHandleValue
)
{
JSObject
*
obj
=
nullptr
;
if
(
args
.
thisv
(
)
.
isObject
(
)
)
{
obj
=
&
args
.
thisv
(
)
.
toObject
(
)
;
if
(
IsWrapper
(
obj
)
)
{
obj
=
CheckedUnwrapStatic
(
obj
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
}
}
if
(
obj
)
{
if
(
obj
-
>
is
<
RegExpObject
>
(
)
)
{
return
fn
(
&
obj
-
>
as
<
RegExpObject
>
(
)
)
;
}
if
(
obj
=
=
cx
-
>
global
(
)
-
>
maybeGetRegExpPrototype
(
)
)
{
args
.
rval
(
)
.
set
(
fallbackValue
)
;
return
true
;
}
}
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_REGEXP_GETTER
methodName
InformalValueTypeName
(
args
.
thisv
(
)
)
)
;
return
false
;
}
bool
js
:
:
regexp_hasIndices
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
hasIndices
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
hasIndices
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_global
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
global
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
global
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_ignoreCase
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
ignoreCase
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
ignoreCase
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_multiline
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
multiline
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
multiline
(
)
)
;
return
true
;
}
)
;
}
static
bool
regexp_source
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
fallback
(
cx
StringValue
(
cx
-
>
names
(
)
.
emptyRegExp_
)
)
;
return
RegExpGetter
(
cx
args
"
source
"
[
cx
args
]
(
RegExpObject
*
unwrapped
)
{
Rooted
<
JSAtom
*
>
src
(
cx
unwrapped
-
>
getSource
(
)
)
;
MOZ_ASSERT
(
src
)
;
if
(
cx
-
>
zone
(
)
!
=
unwrapped
-
>
zone
(
)
)
{
cx
-
>
markAtom
(
src
)
;
}
JSString
*
escaped
=
EscapeRegExpPattern
(
cx
src
)
;
if
(
!
escaped
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
escaped
)
;
return
true
;
}
fallback
)
;
}
bool
js
:
:
regexp_dotAll
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
dotAll
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
dotAll
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_sticky
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
sticky
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
sticky
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_unicode
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
unicode
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
unicode
(
)
)
;
return
true
;
}
)
;
}
bool
js
:
:
regexp_unicodeSets
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
RegExpGetter
(
cx
args
"
unicodeSets
"
[
args
]
(
RegExpObject
*
unwrapped
)
{
args
.
rval
(
)
.
setBoolean
(
unwrapped
-
>
unicodeSets
(
)
)
;
return
true
;
}
)
;
}
const
JSPropertySpec
js
:
:
regexp_properties
[
]
=
{
JS_SELF_HOSTED_GET
(
"
flags
"
"
RegExpFlagsGetter
"
0
)
JS_PSG
(
"
hasIndices
"
regexp_hasIndices
0
)
JS_PSG
(
"
global
"
regexp_global
0
)
JS_PSG
(
"
ignoreCase
"
regexp_ignoreCase
0
)
JS_PSG
(
"
multiline
"
regexp_multiline
0
)
JS_PSG
(
"
dotAll
"
regexp_dotAll
0
)
JS_PSG
(
"
source
"
regexp_source
0
)
JS_PSG
(
"
sticky
"
regexp_sticky
0
)
JS_PSG
(
"
unicode
"
regexp_unicode
0
)
JS_PSG
(
"
unicodeSets
"
regexp_unicodeSets
0
)
JS_PS_END
}
;
const
JSFunctionSpec
js
:
:
regexp_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
toSource
"
"
RegExpToString
"
0
0
)
JS_SELF_HOSTED_FN
(
"
toString
"
"
RegExpToString
"
0
0
)
JS_FN
(
"
compile
"
regexp_compile
2
0
)
JS_SELF_HOSTED_FN
(
"
exec
"
"
RegExp_prototype_Exec
"
1
0
)
JS_SELF_HOSTED_FN
(
"
test
"
"
RegExpTest
"
1
0
)
JS_SELF_HOSTED_SYM_FN
(
match
"
RegExpMatch
"
1
0
)
JS_SELF_HOSTED_SYM_FN
(
matchAll
"
RegExpMatchAll
"
1
0
)
JS_SELF_HOSTED_SYM_FN
(
replace
"
RegExpReplace
"
2
0
)
JS_SELF_HOSTED_SYM_FN
(
search
"
RegExpSearch
"
1
0
)
JS_SELF_HOSTED_SYM_FN
(
split
"
RegExpSplit
"
2
0
)
JS_FS_END
}
;
static
constexpr
JS
:
:
Latin1Char
SHOULD_HEX_ESCAPE
=
JSString
:
:
MAX_LATIN1_CHAR
;
static
constexpr
auto
AsciiRegExpEscapeMap
(
)
{
std
:
:
array
<
JS
:
:
Latin1Char
128
>
result
=
{
}
;
result
[
'
^
'
]
=
'
^
'
;
result
[
'
'
]
=
'
'
;
result
[
'
\
\
'
]
=
'
\
\
'
;
result
[
'
.
'
]
=
'
.
'
;
result
[
'
*
'
]
=
'
*
'
;
result
[
'
+
'
]
=
'
+
'
;
result
[
'
?
'
]
=
'
?
'
;
result
[
'
(
'
]
=
'
(
'
;
result
[
'
)
'
]
=
'
)
'
;
result
[
'
[
'
]
=
'
[
'
;
result
[
'
]
'
]
=
'
]
'
;
result
[
'
{
'
]
=
'
{
'
;
result
[
'
}
'
]
=
'
}
'
;
result
[
'
|
'
]
=
'
|
'
;
result
[
'
/
'
]
=
'
/
'
;
result
[
'
\
t
'
]
=
'
t
'
;
result
[
'
\
n
'
]
=
'
n
'
;
result
[
'
\
v
'
]
=
'
v
'
;
result
[
'
\
f
'
]
=
'
f
'
;
result
[
'
\
r
'
]
=
'
r
'
;
result
[
'
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
-
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
=
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
<
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
>
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
#
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
&
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
!
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
%
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
:
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
;
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
~
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
\
'
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
"
'
]
=
SHOULD_HEX_ESCAPE
;
result
[
'
'
]
=
SHOULD_HEX_ESCAPE
;
return
result
;
}
template
<
typename
CharT
>
[
[
nodiscard
]
]
static
bool
EncodeForRegExpEscape
(
mozilla
:
:
Span
<
const
CharT
>
chars
JSStringBuilder
&
sb
)
{
MOZ_ASSERT
(
sb
.
empty
(
)
)
;
const
size_t
length
=
chars
.
size
(
)
;
if
(
length
=
=
0
)
{
return
true
;
}
static
constexpr
auto
asciiEscapeMap
=
AsciiRegExpEscapeMap
(
)
;
static
constexpr
size_t
EscapeAddLength
=
2
-
1
;
static
constexpr
size_t
HexEscapeAddLength
=
4
-
1
;
static
constexpr
size_t
UnicodeEscapeAddLength
=
6
-
1
;
size_t
outLength
=
length
;
size_t
scanStart
=
0
;
if
(
mozilla
:
:
IsAsciiAlphanumeric
(
chars
[
0
]
)
)
{
outLength
+
=
HexEscapeAddLength
;
scanStart
=
1
;
}
for
(
size_t
i
=
scanStart
;
i
<
length
;
i
+
+
)
{
CharT
ch
=
chars
[
i
]
;
JS
:
:
Latin1Char
escape
=
0
;
if
(
mozilla
:
:
IsAscii
(
ch
)
)
{
escape
=
asciiEscapeMap
[
ch
]
;
}
else
{
if
(
unicode
:
:
IsLeadSurrogate
(
ch
)
&
&
i
+
1
<
length
&
&
unicode
:
:
IsTrailSurrogate
(
chars
[
i
+
1
]
)
)
{
i
+
=
1
;
continue
;
}
if
(
unicode
:
:
IsSpace
(
ch
)
|
|
unicode
:
:
IsSurrogate
(
ch
)
)
{
escape
=
SHOULD_HEX_ESCAPE
;
}
}
if
(
!
escape
)
{
continue
;
}
if
(
mozilla
:
:
IsAscii
(
escape
)
)
{
outLength
+
=
EscapeAddLength
;
}
else
if
(
ch
<
=
JSString
:
:
MAX_LATIN1_CHAR
)
{
outLength
+
=
HexEscapeAddLength
;
}
else
{
outLength
+
=
UnicodeEscapeAddLength
;
}
}
if
(
outLength
=
=
length
)
{
return
true
;
}
MOZ_ASSERT
(
outLength
>
length
)
;
if
constexpr
(
std
:
:
is_same_v
<
CharT
char16_t
>
)
{
if
(
!
sb
.
ensureTwoByteChars
(
)
)
{
return
false
;
}
}
if
(
!
sb
.
reserve
(
outLength
)
)
{
return
false
;
}
static
constexpr
char
HexDigits
[
]
=
"
0123456789abcdef
"
;
static_assert
(
std
:
:
char_traits
<
char
>
:
:
length
(
HexDigits
)
=
=
16
)
;
auto
appendEscape
=
[
&
]
(
JS
:
:
Latin1Char
ch
)
{
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
ch
)
)
;
sb
.
infallibleAppend
(
'
\
\
'
)
;
sb
.
infallibleAppend
(
ch
)
;
}
;
auto
appendHexEscape
=
[
&
]
(
CharT
ch
)
{
MOZ_ASSERT
(
ch
<
=
JSString
:
:
MAX_LATIN1_CHAR
)
;
sb
.
infallibleAppend
(
'
\
\
'
)
;
sb
.
infallibleAppend
(
'
x
'
)
;
sb
.
infallibleAppend
(
HexDigits
[
(
ch
>
>
4
)
&
0xf
]
)
;
sb
.
infallibleAppend
(
HexDigits
[
ch
&
0xf
]
)
;
}
;
auto
appendUnicodeEscape
=
[
&
]
(
char16_t
ch
)
{
MOZ_ASSERT
(
ch
>
JSString
:
:
MAX_LATIN1_CHAR
)
;
sb
.
infallibleAppend
(
'
\
\
'
)
;
sb
.
infallibleAppend
(
'
u
'
)
;
sb
.
infallibleAppend
(
HexDigits
[
(
ch
>
>
12
)
&
0xf
]
)
;
sb
.
infallibleAppend
(
HexDigits
[
(
ch
>
>
8
)
&
0xf
]
)
;
sb
.
infallibleAppend
(
HexDigits
[
(
ch
>
>
4
)
&
0xf
]
)
;
sb
.
infallibleAppend
(
HexDigits
[
ch
&
0xf
]
)
;
}
;
size_t
startUnescaped
=
0
;
auto
appendUnescaped
=
[
&
]
(
size_t
end
)
{
MOZ_ASSERT
(
startUnescaped
<
=
end
&
&
end
<
=
length
)
;
if
(
startUnescaped
<
end
)
{
auto
unescaped
=
chars
.
FromTo
(
startUnescaped
end
)
;
sb
.
infallibleAppend
(
unescaped
.
data
(
)
unescaped
.
size
(
)
)
;
}
startUnescaped
=
end
+
1
;
}
;
size_t
start
=
0
;
if
(
mozilla
:
:
IsAsciiAlphanumeric
(
chars
[
0
]
)
)
{
appendHexEscape
(
chars
[
0
]
)
;
start
=
1
;
startUnescaped
=
1
;
}
for
(
size_t
i
=
start
;
i
<
length
;
i
+
+
)
{
CharT
ch
=
chars
[
i
]
;
JS
:
:
Latin1Char
escape
=
0
;
if
(
mozilla
:
:
IsAscii
(
ch
)
)
{
escape
=
asciiEscapeMap
[
ch
]
;
}
else
{
if
(
unicode
:
:
IsLeadSurrogate
(
ch
)
&
&
i
+
1
<
length
&
&
unicode
:
:
IsTrailSurrogate
(
chars
[
i
+
1
]
)
)
{
i
+
=
1
;
continue
;
}
if
(
unicode
:
:
IsSpace
(
ch
)
|
|
unicode
:
:
IsSurrogate
(
ch
)
)
{
escape
=
SHOULD_HEX_ESCAPE
;
}
}
if
(
!
escape
)
{
continue
;
}
appendUnescaped
(
i
)
;
if
(
mozilla
:
:
IsAscii
(
escape
)
)
{
appendEscape
(
escape
)
;
}
else
if
(
ch
<
=
JSString
:
:
MAX_LATIN1_CHAR
)
{
appendHexEscape
(
ch
)
;
}
else
{
appendUnicodeEscape
(
ch
)
;
}
}
if
(
startUnescaped
)
{
appendUnescaped
(
length
)
;
}
MOZ_ASSERT
(
sb
.
length
(
)
=
=
outLength
"
all
characters
were
written
"
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
EncodeForRegExpEscape
(
JSLinearString
*
string
JSStringBuilder
&
sb
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
string
-
>
hasLatin1Chars
(
)
)
{
auto
chars
=
mozilla
:
:
Span
(
string
-
>
latin1Range
(
nogc
)
)
;
return
EncodeForRegExpEscape
(
chars
sb
)
;
}
auto
chars
=
mozilla
:
:
Span
(
string
-
>
twoByteRange
(
nogc
)
)
;
return
EncodeForRegExpEscape
(
chars
sb
)
;
}
static
bool
regexp_escape
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
get
(
0
)
.
isString
(
)
)
{
return
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_SEARCH_STACK
args
.
get
(
0
)
nullptr
"
not
a
string
"
)
;
}
Rooted
<
JSLinearString
*
>
string
(
cx
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
string
)
{
return
false
;
}
JSStringBuilder
sb
(
cx
)
;
if
(
!
EncodeForRegExpEscape
(
string
sb
)
)
{
return
false
;
}
if
(
sb
.
empty
(
)
)
{
args
.
rval
(
)
.
setString
(
string
)
;
return
true
;
}
auto
*
result
=
sb
.
finishString
(
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
result
)
;
return
true
;
}
#
define
STATIC_PAREN_GETTER_CODE
(
parenNum
)
\
if
(
!
res
-
>
createParen
(
cx
parenNum
args
.
rval
(
)
)
)
return
false
;
\
if
(
args
.
rval
(
)
.
isUndefined
(
)
)
\
args
.
rval
(
)
.
setString
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
\
return
true
#
define
DEFINE_STATIC_GETTER
(
name
code
)
\
static
bool
name
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
RegExpStatics
*
res
=
GlobalObject
:
:
getRegExpStatics
(
cx
cx
-
>
global
(
)
)
;
\
if
(
!
res
)
return
false
;
\
code
;
\
}
DEFINE_STATIC_GETTER
(
static_input_getter
return
res
-
>
createPendingInput
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_lastMatch_getter
return
res
-
>
createLastMatch
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_lastParen_getter
return
res
-
>
createLastParen
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_leftContext_getter
return
res
-
>
createLeftContext
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_rightContext_getter
return
res
-
>
createRightContext
(
cx
args
.
rval
(
)
)
)
DEFINE_STATIC_GETTER
(
static_paren1_getter
STATIC_PAREN_GETTER_CODE
(
1
)
)
DEFINE_STATIC_GETTER
(
static_paren2_getter
STATIC_PAREN_GETTER_CODE
(
2
)
)
DEFINE_STATIC_GETTER
(
static_paren3_getter
STATIC_PAREN_GETTER_CODE
(
3
)
)
DEFINE_STATIC_GETTER
(
static_paren4_getter
STATIC_PAREN_GETTER_CODE
(
4
)
)
DEFINE_STATIC_GETTER
(
static_paren5_getter
STATIC_PAREN_GETTER_CODE
(
5
)
)
DEFINE_STATIC_GETTER
(
static_paren6_getter
STATIC_PAREN_GETTER_CODE
(
6
)
)
DEFINE_STATIC_GETTER
(
static_paren7_getter
STATIC_PAREN_GETTER_CODE
(
7
)
)
DEFINE_STATIC_GETTER
(
static_paren8_getter
STATIC_PAREN_GETTER_CODE
(
8
)
)
DEFINE_STATIC_GETTER
(
static_paren9_getter
STATIC_PAREN_GETTER_CODE
(
9
)
)
#
define
DEFINE_STATIC_SETTER
(
name
code
)
\
static
bool
name
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
RegExpStatics
*
res
=
GlobalObject
:
:
getRegExpStatics
(
cx
cx
-
>
global
(
)
)
;
\
if
(
!
res
)
return
false
;
\
code
;
\
return
true
;
\
}
static
bool
static_input_setter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RegExpStatics
*
res
=
GlobalObject
:
:
getRegExpStatics
(
cx
cx
-
>
global
(
)
)
;
if
(
!
res
)
{
return
false
;
}
RootedString
str
(
cx
ToString
<
CanGC
>
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
str
)
{
return
false
;
}
res
-
>
setPendingInput
(
str
)
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
const
JSPropertySpec
js
:
:
regexp_static_props
[
]
=
{
JS_PSGS
(
"
input
"
static_input_getter
static_input_setter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
lastMatch
"
static_lastMatch_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
lastParen
"
static_lastParen_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
leftContext
"
static_leftContext_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
rightContext
"
static_rightContext_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
1
"
static_paren1_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
2
"
static_paren2_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
3
"
static_paren3_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
4
"
static_paren4_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
5
"
static_paren5_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
6
"
static_paren6_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
7
"
static_paren7_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
8
"
static_paren8_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSG
(
"
9
"
static_paren9_getter
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
)
JS_PSGS
(
"
_
"
static_input_getter
static_input_setter
JSPROP_PERMANENT
)
JS_PSG
(
"
&
"
static_lastMatch_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
+
"
static_lastParen_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
"
static_leftContext_getter
JSPROP_PERMANENT
)
JS_PSG
(
"
'
"
static_rightContext_getter
JSPROP_PERMANENT
)
JS_SELF_HOSTED_SYM_GET
(
species
"
RegExpSpecies
"
0
)
JS_PS_END
}
;
const
JSFunctionSpec
js
:
:
regexp_static_methods
[
]
=
{
JS_FN
(
"
escape
"
regexp_escape
1
0
)
JS_FS_END
}
;
static
RegExpRunStatus
ExecuteRegExp
(
JSContext
*
cx
HandleObject
regexp
HandleString
string
int32_t
lastIndex
VectorMatchPairs
*
matches
)
{
Handle
<
RegExpObject
*
>
reobj
=
regexp
.
as
<
RegExpObject
>
(
)
;
RootedRegExpShared
re
(
cx
RegExpObject
:
:
getShared
(
cx
reobj
)
)
;
if
(
!
re
)
{
return
RegExpRunStatus
:
:
Error
;
}
RegExpStatics
*
res
=
GlobalObject
:
:
getRegExpStatics
(
cx
cx
-
>
global
(
)
)
;
if
(
!
res
)
{
return
RegExpRunStatus
:
:
Error
;
}
Rooted
<
JSLinearString
*
>
input
(
cx
string
-
>
ensureLinear
(
cx
)
)
;
if
(
!
input
)
{
return
RegExpRunStatus
:
:
Error
;
}
MOZ_ASSERT
(
lastIndex
>
=
0
&
&
size_t
(
lastIndex
)
<
=
input
-
>
length
(
)
)
;
RegExpRunStatus
status
=
ExecuteRegExpImpl
(
cx
res
&
re
input
lastIndex
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
RegExpRunStatus
:
:
Error
;
}
return
status
;
}
static
bool
RegExpMatcherImpl
(
JSContext
*
cx
HandleObject
regexp
HandleString
string
int32_t
lastIndex
MutableHandleValue
rval
)
{
VectorMatchPairs
matches
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
string
lastIndex
&
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
false
;
}
if
(
status
=
=
RegExpRunStatus
:
:
Success_NotFound
)
{
rval
.
setNull
(
)
;
return
true
;
}
RootedRegExpShared
shared
(
cx
regexp
-
>
as
<
RegExpObject
>
(
)
.
getShared
(
)
)
;
return
CreateRegExpMatchResult
(
cx
shared
string
matches
rval
)
;
}
bool
js
:
:
RegExpMatcher
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isNumber
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
int32_t
lastIndex
;
MOZ_ALWAYS_TRUE
(
ToInt32
(
cx
args
[
2
]
&
lastIndex
)
)
;
return
RegExpMatcherImpl
(
cx
regexp
string
lastIndex
args
.
rval
(
)
)
;
}
bool
js
:
:
RegExpMatcherRaw
(
JSContext
*
cx
HandleObject
regexp
HandleString
input
int32_t
lastIndex
MatchPairs
*
maybeMatches
MutableHandleValue
output
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
&
&
size_t
(
lastIndex
)
<
=
input
-
>
length
(
)
)
;
if
(
maybeMatches
&
&
maybeMatches
-
>
pairsRaw
(
)
[
0
]
>
MatchPair
:
:
NoMatch
)
{
RootedRegExpShared
shared
(
cx
regexp
-
>
as
<
RegExpObject
>
(
)
.
getShared
(
)
)
;
return
CreateRegExpMatchResult
(
cx
shared
input
*
maybeMatches
output
)
;
}
return
RegExpMatcherImpl
(
cx
regexp
input
lastIndex
output
)
;
}
static
bool
RegExpSearcherImpl
(
JSContext
*
cx
HandleObject
regexp
HandleString
string
int32_t
lastIndex
int32_t
*
result
)
{
VectorMatchPairs
matches
;
#
ifdef
DEBUG
cx
-
>
regExpSearcherLastLimit
=
RegExpSearcherLastLimitSentinel
;
#
endif
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
string
lastIndex
&
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
false
;
}
if
(
status
=
=
RegExpRunStatus
:
:
Success_NotFound
)
{
*
result
=
-
1
;
return
true
;
}
*
result
=
CreateRegExpSearchResult
(
cx
matches
)
;
return
true
;
}
bool
js
:
:
RegExpSearcher
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
IsRegExpObject
(
args
[
0
]
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isString
(
)
)
;
MOZ_ASSERT
(
args
[
2
]
.
isNumber
(
)
)
;
RootedObject
regexp
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedString
string
(
cx
args
[
1
]
.
toString
(
)
)
;
int32_t
lastIndex
;
MOZ_ALWAYS_TRUE
(
ToInt32
(
cx
args
[
2
]
&
lastIndex
)
)
;
int32_t
result
=
0
;
if
(
!
RegExpSearcherImpl
(
cx
regexp
string
lastIndex
&
result
)
)
{
return
false
;
}
args
.
rval
(
)
.
setInt32
(
result
)
;
return
true
;
}
bool
js
:
:
RegExpSearcherRaw
(
JSContext
*
cx
HandleObject
regexp
HandleString
input
int32_t
lastIndex
MatchPairs
*
maybeMatches
int32_t
*
result
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
if
(
maybeMatches
&
&
maybeMatches
-
>
pairsRaw
(
)
[
0
]
>
MatchPair
:
:
NoMatch
)
{
*
result
=
CreateRegExpSearchResult
(
cx
*
maybeMatches
)
;
return
true
;
}
return
RegExpSearcherImpl
(
cx
regexp
input
lastIndex
result
)
;
}
bool
js
:
:
RegExpSearcherLastLimit
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
MOZ_ASSERT
(
cx
-
>
regExpSearcherLastLimit
!
=
RegExpSearcherLastLimitSentinel
)
;
MOZ_ASSERT
(
cx
-
>
regExpSearcherLastLimit
<
=
args
[
0
]
.
toString
(
)
-
>
length
(
)
)
;
args
.
rval
(
)
.
setInt32
(
cx
-
>
regExpSearcherLastLimit
)
;
#
ifdef
DEBUG
cx
-
>
regExpSearcherLastLimit
=
RegExpSearcherLastLimitSentinel
;
#
endif
return
true
;
}
template
<
bool
CalledFromJit
>
static
bool
RegExpBuiltinExecMatchRaw
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
HandleString
input
int32_t
lastIndex
MatchPairs
*
maybeMatches
MutableHandleValue
output
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
MOZ_ASSERT
(
size_t
(
lastIndex
)
<
=
input
-
>
length
(
)
)
;
MOZ_ASSERT_IF
(
!
CalledFromJit
!
maybeMatches
)
;
int32_t
lastIndexNew
=
0
;
if
(
CalledFromJit
&
&
maybeMatches
&
&
maybeMatches
-
>
pairsRaw
(
)
[
0
]
>
MatchPair
:
:
NoMatch
)
{
RootedRegExpShared
shared
(
cx
regexp
-
>
as
<
RegExpObject
>
(
)
.
getShared
(
)
)
;
if
(
!
CreateRegExpMatchResult
(
cx
shared
input
*
maybeMatches
output
)
)
{
return
false
;
}
lastIndexNew
=
(
*
maybeMatches
)
[
0
]
.
limit
;
}
else
{
VectorMatchPairs
matches
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
input
lastIndex
&
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
false
;
}
if
(
status
=
=
RegExpRunStatus
:
:
Success_NotFound
)
{
output
.
setNull
(
)
;
lastIndexNew
=
0
;
}
else
{
RootedRegExpShared
shared
(
cx
regexp
-
>
as
<
RegExpObject
>
(
)
.
getShared
(
)
)
;
if
(
!
CreateRegExpMatchResult
(
cx
shared
input
matches
output
)
)
{
return
false
;
}
lastIndexNew
=
matches
[
0
]
.
limit
;
}
}
RegExpFlags
flags
=
regexp
-
>
getFlags
(
)
;
if
(
!
flags
.
global
(
)
&
&
!
flags
.
sticky
(
)
)
{
return
true
;
}
return
SetLastIndex
<
CalledFromJit
>
(
cx
regexp
lastIndexNew
)
;
}
bool
js
:
:
RegExpBuiltinExecMatchFromJit
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
HandleString
input
MatchPairs
*
maybeMatches
MutableHandleValue
output
)
{
int32_t
lastIndex
=
0
;
if
(
regexp
-
>
isGlobalOrSticky
(
)
)
{
lastIndex
=
regexp
-
>
getLastIndex
(
)
.
toInt32
(
)
;
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
if
(
size_t
(
lastIndex
)
>
input
-
>
length
(
)
)
{
output
.
setNull
(
)
;
return
SetLastIndex
<
true
>
(
cx
regexp
0
)
;
}
}
return
RegExpBuiltinExecMatchRaw
<
true
>
(
cx
regexp
input
lastIndex
maybeMatches
output
)
;
}
template
<
bool
CalledFromJit
>
static
bool
RegExpBuiltinExecTestRaw
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
HandleString
input
int32_t
lastIndex
bool
*
result
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
MOZ_ASSERT
(
size_t
(
lastIndex
)
<
=
input
-
>
length
(
)
)
;
VectorMatchPairs
matches
;
RegExpRunStatus
status
=
ExecuteRegExp
(
cx
regexp
input
lastIndex
&
matches
)
;
if
(
status
=
=
RegExpRunStatus
:
:
Error
)
{
return
false
;
}
*
result
=
(
status
=
=
RegExpRunStatus
:
:
Success
)
;
RegExpFlags
flags
=
regexp
-
>
getFlags
(
)
;
if
(
!
flags
.
global
(
)
&
&
!
flags
.
sticky
(
)
)
{
return
true
;
}
int32_t
lastIndexNew
=
*
result
?
matches
[
0
]
.
limit
:
0
;
return
SetLastIndex
<
CalledFromJit
>
(
cx
regexp
lastIndexNew
)
;
}
bool
js
:
:
RegExpBuiltinExecTestFromJit
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
HandleString
input
bool
*
result
)
{
int32_t
lastIndex
=
0
;
if
(
regexp
-
>
isGlobalOrSticky
(
)
)
{
lastIndex
=
regexp
-
>
getLastIndex
(
)
.
toInt32
(
)
;
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
if
(
size_t
(
lastIndex
)
>
input
-
>
length
(
)
)
{
*
result
=
false
;
return
SetLastIndex
<
true
>
(
cx
regexp
0
)
;
}
}
return
RegExpBuiltinExecTestRaw
<
true
>
(
cx
regexp
input
lastIndex
result
)
;
}
using
CapturesVector
=
GCVector
<
Value
4
>
;
struct
JSSubString
{
JSLinearString
*
base
=
nullptr
;
size_t
offset
=
0
;
size_t
length
=
0
;
JSSubString
(
)
=
default
;
void
initEmpty
(
JSLinearString
*
base
)
{
this
-
>
base
=
base
;
offset
=
length
=
0
;
}
void
init
(
JSLinearString
*
base
size_t
offset
size_t
length
)
{
this
-
>
base
=
base
;
this
-
>
offset
=
offset
;
this
-
>
length
=
length
;
}
}
;
static
void
GetParen
(
JSLinearString
*
matched
const
JS
:
:
Value
&
capture
JSSubString
*
out
)
{
if
(
capture
.
isUndefined
(
)
)
{
out
-
>
initEmpty
(
matched
)
;
return
;
}
JSLinearString
&
captureLinear
=
capture
.
toString
(
)
-
>
asLinear
(
)
;
out
-
>
init
(
&
captureLinear
0
captureLinear
.
length
(
)
)
;
}
template
<
typename
CharT
>
static
bool
InterpretDollar
(
JSLinearString
*
matched
JSLinearString
*
string
size_t
position
size_t
tailPos
Handle
<
CapturesVector
>
captures
Handle
<
CapturesVector
>
namedCaptures
JSLinearString
*
replacement
const
CharT
*
replacementBegin
const
CharT
*
currentDollar
const
CharT
*
replacementEnd
JSSubString
*
out
size_t
*
skip
uint32_t
*
currentNamedCapture
)
{
MOZ_ASSERT
(
*
currentDollar
=
=
'
'
)
;
if
(
currentDollar
+
1
>
=
replacementEnd
)
{
return
false
;
}
char16_t
c
=
currentDollar
[
1
]
;
if
(
IsAsciiDigit
(
c
)
)
{
unsigned
num
=
AsciiDigitToNumber
(
c
)
;
if
(
num
>
captures
.
length
(
)
)
{
return
false
;
}
const
CharT
*
currentChar
=
currentDollar
+
2
;
if
(
currentChar
<
replacementEnd
)
{
c
=
*
currentChar
;
if
(
IsAsciiDigit
(
c
)
)
{
unsigned
tmpNum
=
10
*
num
+
AsciiDigitToNumber
(
c
)
;
if
(
tmpNum
<
=
captures
.
length
(
)
)
{
currentChar
+
+
;
num
=
tmpNum
;
}
}
}
if
(
num
=
=
0
)
{
return
false
;
}
*
skip
=
currentChar
-
currentDollar
;
MOZ_ASSERT
(
num
<
=
captures
.
length
(
)
)
;
GetParen
(
matched
captures
[
num
-
1
]
out
)
;
return
true
;
}
if
(
c
=
=
'
<
'
)
{
if
(
namedCaptures
.
length
(
)
=
=
0
)
{
return
false
;
}
const
CharT
*
nameStart
=
currentDollar
+
2
;
const
CharT
*
nameEnd
=
js_strchr_limit
(
nameStart
'
>
'
replacementEnd
)
;
if
(
!
nameEnd
)
{
return
false
;
}
size_t
nameLength
=
nameEnd
-
nameStart
;
*
skip
=
nameLength
+
3
;
GetParen
(
matched
namedCaptures
[
*
currentNamedCapture
]
out
)
;
*
currentNamedCapture
+
=
1
;
return
true
;
}
switch
(
c
)
{
default
:
return
false
;
case
'
'
:
out
-
>
init
(
replacement
currentDollar
-
replacementBegin
1
)
;
break
;
case
'
&
'
:
out
-
>
init
(
matched
0
matched
-
>
length
(
)
)
;
break
;
case
'
'
:
out
-
>
init
(
string
0
position
)
;
break
;
case
'
\
'
'
:
if
(
tailPos
>
=
string
-
>
length
(
)
)
{
out
-
>
initEmpty
(
matched
)
;
}
else
{
out
-
>
init
(
string
tailPos
string
-
>
length
(
)
-
tailPos
)
;
}
break
;
}
*
skip
=
2
;
return
true
;
}
template
<
typename
CharT
>
static
bool
FindReplaceLengthString
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
matched
Handle
<
JSLinearString
*
>
string
size_t
position
size_t
tailPos
Handle
<
CapturesVector
>
captures
Handle
<
CapturesVector
>
namedCaptures
Handle
<
JSLinearString
*
>
replacement
size_t
firstDollarIndex
size_t
*
sizep
)
{
CheckedInt
<
uint32_t
>
replen
=
replacement
-
>
length
(
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
firstDollarIndex
<
replacement
-
>
length
(
)
)
;
const
CharT
*
replacementBegin
=
replacement
-
>
chars
<
CharT
>
(
nogc
)
;
const
CharT
*
currentDollar
=
replacementBegin
+
firstDollarIndex
;
const
CharT
*
replacementEnd
=
replacementBegin
+
replacement
-
>
length
(
)
;
uint32_t
currentNamedCapture
=
0
;
do
{
JSSubString
sub
;
size_t
skip
;
if
(
InterpretDollar
(
matched
string
position
tailPos
captures
namedCaptures
replacement
replacementBegin
currentDollar
replacementEnd
&
sub
&
skip
&
currentNamedCapture
)
)
{
if
(
sub
.
length
>
skip
)
{
replen
+
=
sub
.
length
-
skip
;
}
else
{
replen
-
=
skip
-
sub
.
length
;
}
currentDollar
+
=
skip
;
}
else
{
currentDollar
+
+
;
}
currentDollar
=
js_strchr_limit
(
currentDollar
'
'
replacementEnd
)
;
}
while
(
currentDollar
)
;
if
(
!
replen
.
isValid
(
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
*
sizep
=
replen
.
value
(
)
;
return
true
;
}
static
bool
FindReplaceLength
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
matched
Handle
<
JSLinearString
*
>
string
size_t
position
size_t
tailPos
Handle
<
CapturesVector
>
captures
Handle
<
CapturesVector
>
namedCaptures
Handle
<
JSLinearString
*
>
replacement
size_t
firstDollarIndex
size_t
*
sizep
)
{
return
replacement
-
>
hasLatin1Chars
(
)
?
FindReplaceLengthString
<
Latin1Char
>
(
cx
matched
string
position
tailPos
captures
namedCaptures
replacement
firstDollarIndex
sizep
)
:
FindReplaceLengthString
<
char16_t
>
(
cx
matched
string
position
tailPos
captures
namedCaptures
replacement
firstDollarIndex
sizep
)
;
}
template
<
typename
CharT
>
static
void
DoReplace
(
Handle
<
JSLinearString
*
>
matched
Handle
<
JSLinearString
*
>
string
size_t
position
size_t
tailPos
Handle
<
CapturesVector
>
captures
Handle
<
CapturesVector
>
namedCaptures
Handle
<
JSLinearString
*
>
replacement
size_t
firstDollarIndex
StringBuilder
&
sb
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
const
CharT
*
replacementBegin
=
replacement
-
>
chars
<
CharT
>
(
nogc
)
;
const
CharT
*
currentChar
=
replacementBegin
;
MOZ_ASSERT
(
firstDollarIndex
<
replacement
-
>
length
(
)
)
;
const
CharT
*
currentDollar
=
replacementBegin
+
firstDollarIndex
;
const
CharT
*
replacementEnd
=
replacementBegin
+
replacement
-
>
length
(
)
;
uint32_t
currentNamedCapture
=
0
;
do
{
size_t
len
=
currentDollar
-
currentChar
;
sb
.
infallibleAppend
(
currentChar
len
)
;
currentChar
=
currentDollar
;
JSSubString
sub
;
size_t
skip
;
if
(
InterpretDollar
(
matched
string
position
tailPos
captures
namedCaptures
replacement
replacementBegin
currentDollar
replacementEnd
&
sub
&
skip
&
currentNamedCapture
)
)
{
sb
.
infallibleAppendSubstring
(
sub
.
base
sub
.
offset
sub
.
length
)
;
currentChar
+
=
skip
;
currentDollar
+
=
skip
;
}
else
{
currentDollar
+
+
;
}
currentDollar
=
js_strchr_limit
(
currentDollar
'
'
replacementEnd
)
;
}
while
(
currentDollar
)
;
sb
.
infallibleAppend
(
currentChar
replacement
-
>
length
(
)
-
(
currentChar
-
replacementBegin
)
)
;
}
template
<
typename
CharT
>
static
bool
CollectNames
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
replacement
size_t
firstDollarIndex
MutableHandle
<
GCVector
<
jsid
>
>
names
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
firstDollarIndex
<
replacement
-
>
length
(
)
)
;
const
CharT
*
replacementBegin
=
replacement
-
>
chars
<
CharT
>
(
nogc
)
;
const
CharT
*
currentDollar
=
replacementBegin
+
firstDollarIndex
;
const
CharT
*
replacementEnd
=
replacementBegin
+
replacement
-
>
length
(
)
;
while
(
currentDollar
&
&
currentDollar
+
1
<
replacementEnd
)
{
if
(
currentDollar
[
1
]
=
=
'
<
'
)
{
const
CharT
*
nameStart
=
currentDollar
+
2
;
const
CharT
*
nameEnd
=
js_strchr_limit
(
nameStart
'
>
'
replacementEnd
)
;
if
(
!
nameEnd
)
{
return
true
;
}
size_t
nameLength
=
nameEnd
-
nameStart
;
JSAtom
*
atom
=
AtomizeChars
(
cx
nameStart
nameLength
)
;
if
(
!
atom
|
|
!
names
.
append
(
AtomToId
(
atom
)
)
)
{
return
false
;
}
currentDollar
=
nameEnd
+
1
;
}
else
{
currentDollar
+
=
2
;
}
currentDollar
=
js_strchr_limit
(
currentDollar
'
'
replacementEnd
)
;
}
return
true
;
}
static
bool
InitNamedCaptures
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
replacement
HandleObject
groups
size_t
firstDollarIndex
MutableHandle
<
CapturesVector
>
namedCaptures
)
{
Rooted
<
GCVector
<
jsid
>
>
names
(
cx
cx
)
;
if
(
replacement
-
>
hasLatin1Chars
(
)
)
{
if
(
!
CollectNames
<
Latin1Char
>
(
cx
replacement
firstDollarIndex
&
names
)
)
{
return
false
;
}
}
else
{
if
(
!
CollectNames
<
char16_t
>
(
cx
replacement
firstDollarIndex
&
names
)
)
{
return
false
;
}
}
RootedId
id
(
cx
)
;
RootedValue
capture
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
names
.
length
(
)
;
i
+
+
)
{
id
=
names
[
i
]
;
if
(
!
GetProperty
(
cx
groups
groups
id
&
capture
)
)
{
return
false
;
}
if
(
capture
.
isUndefined
(
)
)
{
if
(
!
namedCaptures
.
append
(
capture
)
)
{
return
false
;
}
}
else
{
JSString
*
str
=
ToString
<
CanGC
>
(
cx
capture
)
;
if
(
!
str
)
{
return
false
;
}
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
if
(
!
namedCaptures
.
append
(
StringValue
(
linear
)
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
NeedTwoBytes
(
Handle
<
JSLinearString
*
>
string
Handle
<
JSLinearString
*
>
replacement
Handle
<
JSLinearString
*
>
matched
Handle
<
CapturesVector
>
captures
Handle
<
CapturesVector
>
namedCaptures
)
{
if
(
string
-
>
hasTwoByteChars
(
)
)
{
return
true
;
}
if
(
replacement
-
>
hasTwoByteChars
(
)
)
{
return
true
;
}
if
(
matched
-
>
hasTwoByteChars
(
)
)
{
return
true
;
}
for
(
const
Value
&
capture
:
captures
)
{
if
(
capture
.
isUndefined
(
)
)
{
continue
;
}
if
(
capture
.
toString
(
)
-
>
hasTwoByteChars
(
)
)
{
return
true
;
}
}
for
(
const
Value
&
capture
:
namedCaptures
)
{
if
(
capture
.
isUndefined
(
)
)
{
continue
;
}
if
(
capture
.
toString
(
)
-
>
hasTwoByteChars
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
js
:
:
RegExpBuiltinExec
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
Handle
<
JSString
*
>
string
bool
forTest
MutableHandle
<
Value
>
rval
)
{
uint64_t
lastIndex
;
if
(
MOZ_LIKELY
(
regexp
-
>
getLastIndex
(
)
.
isInt32
(
)
)
)
{
lastIndex
=
std
:
:
max
(
regexp
-
>
getLastIndex
(
)
.
toInt32
(
)
0
)
;
}
else
{
Rooted
<
Value
>
lastIndexVal
(
cx
regexp
-
>
getLastIndex
(
)
)
;
if
(
!
ToLength
(
cx
lastIndexVal
&
lastIndex
)
)
{
return
false
;
}
}
bool
globalOrSticky
=
regexp
-
>
isGlobalOrSticky
(
)
;
if
(
!
globalOrSticky
)
{
lastIndex
=
0
;
}
else
{
if
(
lastIndex
>
string
-
>
length
(
)
)
{
if
(
!
SetLastIndex
(
cx
regexp
0
)
)
{
return
false
;
}
rval
.
set
(
forTest
?
BooleanValue
(
false
)
:
NullValue
(
)
)
;
return
true
;
}
}
MOZ_ASSERT
(
lastIndex
<
=
string
-
>
length
(
)
)
;
static_assert
(
JSString
:
:
MAX_LENGTH
<
=
INT32_MAX
"
lastIndex
fits
in
int32_t
"
)
;
if
(
forTest
)
{
bool
result
;
if
(
!
RegExpBuiltinExecTestRaw
<
false
>
(
cx
regexp
string
int32_t
(
lastIndex
)
&
result
)
)
{
return
false
;
}
rval
.
setBoolean
(
result
)
;
return
true
;
}
return
RegExpBuiltinExecMatchRaw
<
false
>
(
cx
regexp
string
int32_t
(
lastIndex
)
nullptr
rval
)
;
}
bool
js
:
:
IsOptimizableRegExpObject
(
JSObject
*
obj
JSContext
*
cx
)
{
bool
optimizable
=
obj
-
>
shape
(
)
=
=
cx
-
>
global
(
)
-
>
maybeRegExpShapeWithDefaultProto
(
)
&
&
cx
-
>
realm
(
)
-
>
realmFuses
.
optimizeRegExpPrototypeFuse
.
intact
(
)
;
MOZ_ASSERT_IF
(
optimizable
obj
-
>
is
<
RegExpObject
>
(
)
&
&
obj
-
>
as
<
RegExpObject
>
(
)
.
realm
(
)
=
=
cx
-
>
realm
(
)
)
;
return
optimizable
;
}
bool
js
:
:
RegExpExec
(
JSContext
*
cx
Handle
<
JSObject
*
>
regexp
Handle
<
JSString
*
>
string
bool
forTest
MutableHandle
<
Value
>
rval
)
{
if
(
MOZ_LIKELY
(
IsOptimizableRegExpObject
(
regexp
cx
)
)
)
{
return
RegExpBuiltinExec
(
cx
regexp
.
as
<
RegExpObject
>
(
)
string
forTest
rval
)
;
}
Rooted
<
Value
>
exec
(
cx
)
;
Rooted
<
PropertyKey
>
execKey
(
cx
NameToId
(
cx
-
>
names
(
)
.
exec
)
)
;
if
(
!
GetProperty
(
cx
regexp
regexp
execKey
&
exec
)
)
{
return
false
;
}
PropertyName
*
execName
=
cx
-
>
names
(
)
.
RegExp_prototype_Exec
;
if
(
IsSelfHostedFunctionWithName
(
exec
execName
)
|
|
!
IsCallable
(
exec
)
)
{
if
(
MOZ_LIKELY
(
regexp
-
>
is
<
RegExpObject
>
(
)
)
)
{
return
RegExpBuiltinExec
(
cx
regexp
.
as
<
RegExpObject
>
(
)
string
forTest
rval
)
;
}
if
(
!
regexp
-
>
canUnwrapAs
<
RegExpObject
>
(
)
)
{
Rooted
<
Value
>
thisv
(
cx
ObjectValue
(
*
regexp
)
)
;
return
ReportIncompatibleSelfHostedMethod
(
cx
thisv
)
;
}
Rooted
<
RegExpObject
*
>
unwrapped
(
cx
&
regexp
-
>
unwrapAs
<
RegExpObject
>
(
)
)
;
{
AutoRealm
ar
(
cx
unwrapped
)
;
Rooted
<
JSString
*
>
wrappedString
(
cx
string
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedString
)
)
{
return
false
;
}
if
(
!
RegExpBuiltinExec
(
cx
unwrapped
wrappedString
forTest
rval
)
)
{
return
false
;
}
}
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
rval
)
;
}
Rooted
<
Value
>
thisv
(
cx
ObjectValue
(
*
regexp
)
)
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
setString
(
string
)
;
if
(
!
js
:
:
Call
(
cx
exec
thisv
args
rval
CallReason
:
:
CallContent
)
)
{
return
false
;
}
if
(
!
rval
.
isObjectOrNull
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_EXEC_NOT_OBJORNULL
)
;
return
false
;
}
if
(
forTest
)
{
rval
.
setBoolean
(
rval
.
isObject
(
)
)
;
}
return
true
;
}
bool
js
:
:
RegExpHasCaptureGroups
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
obj
Handle
<
JSString
*
>
input
bool
*
result
)
{
if
(
!
obj
-
>
hasShared
(
)
|
|
obj
-
>
getShared
(
)
-
>
kind
(
)
=
=
RegExpShared
:
:
Kind
:
:
Unparsed
)
{
Rooted
<
RegExpShared
*
>
shared
(
cx
RegExpObject
:
:
getShared
(
cx
obj
)
)
;
if
(
!
shared
)
{
return
false
;
}
Rooted
<
JSLinearString
*
>
inputLinear
(
cx
input
-
>
ensureLinear
(
cx
)
)
;
if
(
!
inputLinear
)
{
return
false
;
}
if
(
!
RegExpShared
:
:
compileIfNecessary
(
cx
&
shared
inputLinear
RegExpShared
:
:
CodeKind
:
:
Any
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
obj
-
>
getShared
(
)
-
>
pairCount
(
)
>
=
1
)
;
*
result
=
obj
-
>
getShared
(
)
-
>
pairCount
(
)
>
1
;
return
true
;
}
bool
js
:
:
RegExpGetSubstitution
(
JSContext
*
cx
Handle
<
ArrayObject
*
>
matchResult
Handle
<
JSLinearString
*
>
string
size_t
position
Handle
<
JSLinearString
*
>
replacement
size_t
firstDollarIndex
HandleValue
groups
MutableHandleValue
rval
)
{
MOZ_ASSERT
(
firstDollarIndex
<
replacement
-
>
length
(
)
)
;
uint32_t
matchResultLength
=
matchResult
-
>
length
(
)
;
MOZ_ASSERT
(
matchResultLength
>
0
)
;
MOZ_ASSERT
(
matchResultLength
=
=
matchResult
-
>
getDenseInitializedLength
(
)
)
;
const
Value
&
matchedValue
=
matchResult
-
>
getDenseElement
(
0
)
;
Rooted
<
JSLinearString
*
>
matched
(
cx
matchedValue
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
matched
)
{
return
false
;
}
size_t
matchLength
=
matched
-
>
length
(
)
;
MOZ_ASSERT
(
position
<
=
string
-
>
length
(
)
)
;
uint32_t
nCaptures
=
matchResultLength
-
1
;
Rooted
<
CapturesVector
>
captures
(
cx
CapturesVector
(
cx
)
)
;
if
(
!
captures
.
reserve
(
nCaptures
)
)
{
return
false
;
}
for
(
uint32_t
i
=
1
;
i
<
=
nCaptures
;
i
+
+
)
{
const
Value
&
capture
=
matchResult
-
>
getDenseElement
(
i
)
;
if
(
capture
.
isUndefined
(
)
)
{
captures
.
infallibleAppend
(
capture
)
;
continue
;
}
JSLinearString
*
captureLinear
=
capture
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
captureLinear
)
{
return
false
;
}
captures
.
infallibleAppend
(
StringValue
(
captureLinear
)
)
;
}
Rooted
<
CapturesVector
>
namedCaptures
(
cx
cx
)
;
if
(
groups
.
isObject
(
)
)
{
RootedObject
groupsObj
(
cx
&
groups
.
toObject
(
)
)
;
if
(
!
InitNamedCaptures
(
cx
replacement
groupsObj
firstDollarIndex
&
namedCaptures
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
groups
.
isUndefined
(
)
)
;
}
CheckedInt
<
uint32_t
>
checkedTailPos
(
0
)
;
checkedTailPos
+
=
position
;
checkedTailPos
+
=
matchLength
;
if
(
!
checkedTailPos
.
isValid
(
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
uint32_t
tailPos
=
checkedTailPos
.
value
(
)
;
size_t
reserveLength
;
if
(
!
FindReplaceLength
(
cx
matched
string
position
tailPos
captures
namedCaptures
replacement
firstDollarIndex
&
reserveLength
)
)
{
return
false
;
}
JSStringBuilder
result
(
cx
)
;
if
(
NeedTwoBytes
(
string
replacement
matched
captures
namedCaptures
)
)
{
if
(
!
result
.
ensureTwoByteChars
(
)
)
{
return
false
;
}
}
if
(
!
result
.
reserve
(
reserveLength
)
)
{
return
false
;
}
if
(
replacement
-
>
hasLatin1Chars
(
)
)
{
DoReplace
<
Latin1Char
>
(
matched
string
position
tailPos
captures
namedCaptures
replacement
firstDollarIndex
result
)
;
}
else
{
DoReplace
<
char16_t
>
(
matched
string
position
tailPos
captures
namedCaptures
replacement
firstDollarIndex
result
)
;
}
JSString
*
resultString
=
result
.
finishString
(
)
;
if
(
!
resultString
)
{
return
false
;
}
rval
.
setString
(
resultString
)
;
return
true
;
}
bool
js
:
:
GetFirstDollarIndex
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
JSString
*
str
=
args
[
0
]
.
toString
(
)
;
MOZ_ASSERT
(
str
-
>
length
(
)
!
=
0
)
;
int32_t
index
=
-
1
;
if
(
!
GetFirstDollarIndexRaw
(
cx
str
&
index
)
)
{
return
false
;
}
args
.
rval
(
)
.
setInt32
(
index
)
;
return
true
;
}
template
<
typename
TextChar
>
static
MOZ_ALWAYS_INLINE
int
GetFirstDollarIndexImpl
(
const
TextChar
*
text
uint32_t
textLen
)
{
const
TextChar
*
end
=
text
+
textLen
;
for
(
const
TextChar
*
c
=
text
;
c
!
=
end
;
+
+
c
)
{
if
(
*
c
=
=
'
'
)
{
return
c
-
text
;
}
}
return
-
1
;
}
template
<
typename
StringT
>
int32_t
js
:
:
GetFirstDollarIndexRawFlat
(
const
StringT
*
text
)
{
uint32_t
len
=
text
-
>
length
(
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
text
-
>
hasLatin1Chars
(
)
)
{
return
GetFirstDollarIndexImpl
(
text
-
>
latin1Chars
(
nogc
)
len
)
;
}
return
GetFirstDollarIndexImpl
(
text
-
>
twoByteChars
(
nogc
)
len
)
;
}
template
int32_t
js
:
:
GetFirstDollarIndexRawFlat
<
JSLinearString
>
(
const
JSLinearString
*
text
)
;
template
int32_t
js
:
:
GetFirstDollarIndexRawFlat
<
JSOffThreadAtom
>
(
const
JSOffThreadAtom
*
text
)
;
bool
js
:
:
GetFirstDollarIndexRaw
(
JSContext
*
cx
JSString
*
str
int32_t
*
index
)
{
JSLinearString
*
text
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
text
)
{
return
false
;
}
*
index
=
GetFirstDollarIndexRawFlat
(
text
)
;
return
true
;
}
bool
js
:
:
IsRegExpPrototypeOptimizable
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
bool
optimizable
=
cx
-
>
realm
(
)
-
>
realmFuses
.
optimizeRegExpPrototypeFuse
.
intact
(
)
;
args
.
rval
(
)
.
setBoolean
(
optimizable
)
;
return
true
;
}
bool
js
:
:
IsOptimizableRegExpObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
JSObject
*
obj
=
&
args
[
0
]
.
toObject
(
)
;
bool
optimizable
=
IsOptimizableRegExpObject
(
obj
cx
)
;
args
.
rval
(
)
.
setBoolean
(
optimizable
)
;
return
true
;
}
bool
js
:
:
intrinsic_GetElemBaseForLambda
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
JSObject
&
lambda
=
args
[
0
]
.
toObject
(
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
if
(
!
lambda
.
is
<
JSFunction
>
(
)
)
{
return
true
;
}
RootedFunction
fun
(
cx
&
lambda
.
as
<
JSFunction
>
(
)
)
;
if
(
!
fun
-
>
isInterpreted
(
)
|
|
fun
-
>
isClassConstructor
(
)
)
{
return
true
;
}
JSScript
*
script
=
JSFunction
:
:
getOrCreateScript
(
cx
fun
)
;
if
(
!
script
)
{
return
false
;
}
jsbytecode
*
pc
=
script
-
>
code
(
)
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
GetAliasedVar
|
|
fun
-
>
needsSomeEnvironmentObject
(
)
)
{
return
true
;
}
EnvironmentCoordinate
ec
(
pc
)
;
EnvironmentObject
*
env
=
&
fun
-
>
environment
(
)
-
>
as
<
EnvironmentObject
>
(
)
;
for
(
unsigned
i
=
0
;
i
<
ec
.
hops
(
)
;
+
+
i
)
{
env
=
&
env
-
>
enclosingEnvironment
(
)
.
as
<
EnvironmentObject
>
(
)
;
}
Value
b
=
env
-
>
aliasedBinding
(
ec
)
;
pc
+
=
JSOpLength_GetAliasedVar
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
GetArg
|
|
GET_ARGNO
(
pc
)
!
=
0
)
{
return
true
;
}
pc
+
=
JSOpLength_GetArg
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
GetElem
)
{
return
true
;
}
pc
+
=
JSOpLength_GetElem
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
Return
)
{
return
true
;
}
if
(
!
b
.
isObject
(
)
)
{
return
true
;
}
JSObject
&
bobj
=
b
.
toObject
(
)
;
const
JSClass
*
clasp
=
bobj
.
getClass
(
)
;
if
(
!
clasp
-
>
isNativeObject
(
)
|
|
clasp
-
>
getOpsLookupProperty
(
)
|
|
clasp
-
>
getOpsGetProperty
(
)
)
{
return
true
;
}
args
.
rval
(
)
.
setObject
(
bobj
)
;
return
true
;
}
bool
js
:
:
intrinsic_GetStringDataProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
JSObject
*
obj
=
&
args
[
0
]
.
toObject
(
)
;
if
(
!
obj
-
>
is
<
NativeObject
>
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
JS
:
:
AutoCheckCannotGC
nogc
;
JSAtom
*
atom
=
AtomizeString
(
cx
args
[
1
]
.
toString
(
)
)
;
if
(
!
atom
)
{
return
false
;
}
Value
v
;
if
(
GetPropertyPure
(
cx
obj
AtomToId
(
atom
)
&
v
)
&
&
v
.
isString
(
)
)
{
args
.
rval
(
)
.
set
(
v
)
;
}
else
{
args
.
rval
(
)
.
setUndefined
(
)
;
}
return
true
;
}
