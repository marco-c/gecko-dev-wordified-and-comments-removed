function
CountingSort
(
array
len
signed
)
{
var
buffer
=
new
List
(
)
;
var
min
=
0
;
if
(
signed
)
{
min
=
-
128
;
}
for
(
var
i
=
0
;
i
<
256
;
i
+
+
)
{
buffer
[
i
]
=
0
;
}
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
val
=
array
[
i
]
;
buffer
[
val
-
min
]
+
+
}
var
val
=
0
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
while
(
true
)
{
if
(
buffer
[
val
]
>
0
)
{
array
[
i
]
=
val
+
min
;
buffer
[
val
]
-
-
;
break
;
}
else
{
val
+
+
;
}
}
}
return
array
;
}
function
ByteAtCol
(
x
pos
)
{
return
(
x
>
>
(
pos
*
8
)
)
&
0xFF
;
}
function
SortByColumn
(
array
len
aux
col
)
{
const
R
=
256
;
let
counts
=
new
List
(
)
;
for
(
let
r
=
0
;
r
<
R
+
1
;
r
+
+
)
{
counts
[
r
]
=
0
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
val
=
array
[
i
]
;
let
b
=
ByteAtCol
(
val
col
)
;
counts
[
b
+
1
]
+
+
;
}
for
(
let
r
=
0
;
r
<
R
;
r
+
+
)
{
counts
[
r
+
1
]
+
=
counts
[
r
]
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
val
=
array
[
i
]
;
let
b
=
ByteAtCol
(
val
col
)
;
aux
[
counts
[
b
]
+
+
]
=
val
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
array
[
i
]
=
aux
[
i
]
;
}
}
function
RadixSort
(
array
len
nbytes
signed
floating
comparefn
)
{
if
(
len
<
128
)
{
QuickSort
(
array
len
comparefn
)
;
return
array
;
}
let
aux
=
new
List
(
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
aux
[
i
]
=
0
;
}
let
view
=
array
;
let
signMask
=
1
<
<
nbytes
*
8
-
1
;
if
(
floating
)
{
view
=
new
Int32Array
(
array
.
buffer
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
view
[
i
]
&
signMask
)
{
view
[
i
]
^
=
0xFFFFFFFF
;
}
else
{
view
[
i
]
^
=
signMask
}
}
}
else
if
(
signed
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
view
[
i
]
^
=
signMask
}
}
for
(
let
col
=
0
;
col
<
nbytes
;
col
+
+
)
{
SortByColumn
(
view
len
aux
col
)
;
}
if
(
floating
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
view
[
i
]
&
signMask
)
{
view
[
i
]
^
=
signMask
;
}
else
{
view
[
i
]
^
=
0xFFFFFFFF
;
}
}
}
else
if
(
signed
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
view
[
i
]
^
=
signMask
}
}
return
array
;
}
function
InsertionSort
(
array
from
to
comparefn
)
{
let
item
swap
i
j
;
for
(
i
=
from
+
1
;
i
<
=
to
;
i
+
+
)
{
item
=
array
[
i
]
;
for
(
j
=
i
-
1
;
j
>
=
from
;
j
-
-
)
{
swap
=
array
[
j
]
;
if
(
comparefn
(
swap
item
)
<
=
0
)
break
;
array
[
j
+
1
]
=
swap
;
}
array
[
j
+
1
]
=
item
;
}
}
function
SwapArrayElements
(
array
i
j
)
{
var
swap
=
array
[
i
]
;
array
[
i
]
=
array
[
j
]
;
array
[
j
]
=
swap
;
}
function
Merge
(
source
start
mid
end
destination
comparefn
)
{
var
i
j
k
;
i
=
start
;
j
=
mid
;
k
=
start
;
while
(
i
<
mid
&
&
j
<
end
)
{
if
(
comparefn
(
source
[
j
]
source
[
i
]
)
<
0
)
{
destination
[
k
]
=
source
[
j
]
;
j
+
+
;
}
else
{
destination
[
k
]
=
source
[
i
]
;
i
+
+
;
}
k
+
+
;
}
while
(
i
<
mid
)
{
destination
[
k
]
=
source
[
i
]
;
i
+
+
;
k
+
+
;
}
while
(
j
<
end
)
{
destination
[
k
]
=
source
[
j
]
;
j
+
+
;
k
+
+
;
}
}
function
MoveHoles
(
sparse
sparseLen
dense
denseLen
)
{
for
(
var
i
=
0
;
i
<
denseLen
;
i
+
+
)
_DefineDataProperty
(
sparse
i
dense
[
i
]
)
;
for
(
var
j
=
denseLen
;
j
<
sparseLen
;
j
+
+
)
delete
sparse
[
j
]
;
}
function
MergeSort
(
array
len
comparefn
)
{
var
denseList
=
new
List
(
)
;
var
denseLen
=
0
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
i
in
array
)
denseList
[
denseLen
+
+
]
=
array
[
i
]
;
}
if
(
denseLen
<
1
)
return
array
;
if
(
len
<
24
)
{
InsertionSort
(
denseList
0
denseLen
-
1
comparefn
)
;
MoveHoles
(
array
len
denseList
denseLen
)
;
return
array
;
}
var
source
=
denseList
;
var
destination
=
new
List
(
)
;
var
mid
end
endOne
endTwo
;
for
(
var
windowSize
=
1
;
windowSize
<
denseLen
;
windowSize
=
2
*
windowSize
)
{
for
(
var
start
=
0
;
start
<
denseLen
;
start
+
=
2
*
windowSize
)
{
assert
(
windowSize
<
denseLen
"
The
window
size
is
larger
than
the
array
denseLength
!
"
)
;
mid
=
start
+
windowSize
;
mid
=
mid
<
denseLen
?
mid
:
denseLen
;
end
=
start
+
2
*
windowSize
;
end
=
end
<
denseLen
?
end
:
denseLen
;
Merge
(
source
start
mid
end
destination
comparefn
)
;
}
var
tmp
=
source
;
source
=
destination
;
destination
=
tmp
;
}
MoveHoles
(
array
len
source
denseLen
)
;
return
array
;
}
function
Partition
(
array
from
to
comparefn
)
{
assert
(
to
-
from
>
=
3
"
Partition
will
not
work
with
less
than
three
elements
"
)
;
var
medianIndex
=
(
from
+
to
)
>
>
1
;
var
i
=
from
+
1
;
var
j
=
to
;
SwapArrayElements
(
array
medianIndex
i
)
;
if
(
comparefn
(
array
[
from
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
from
to
)
;
if
(
comparefn
(
array
[
i
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
i
to
)
;
if
(
comparefn
(
array
[
from
]
array
[
i
]
)
>
0
)
SwapArrayElements
(
array
from
i
)
;
var
pivotIndex
=
i
;
for
(
;
;
)
{
do
i
+
+
;
while
(
comparefn
(
array
[
i
]
array
[
pivotIndex
]
)
<
0
)
;
do
j
-
-
;
while
(
comparefn
(
array
[
j
]
array
[
pivotIndex
]
)
>
0
)
;
if
(
i
>
j
)
break
;
SwapArrayElements
(
array
i
j
)
;
}
SwapArrayElements
(
array
pivotIndex
j
)
;
return
j
;
}
function
QuickSort
(
array
len
comparefn
)
{
var
stack
=
new
List
(
)
;
var
top
=
0
;
var
start
=
0
;
var
end
=
len
-
1
;
var
pivotIndex
i
j
leftLen
rightLen
;
for
(
;
;
)
{
if
(
end
-
start
<
=
23
)
{
InsertionSort
(
array
start
end
comparefn
)
;
if
(
top
<
1
)
break
;
end
=
stack
[
-
-
top
]
;
start
=
stack
[
-
-
top
]
;
}
else
{
pivotIndex
=
Partition
(
array
start
end
comparefn
)
;
leftLen
=
(
pivotIndex
-
1
)
-
start
;
rightLen
=
end
-
(
pivotIndex
+
1
)
;
if
(
rightLen
>
leftLen
)
{
stack
[
top
+
+
]
=
start
;
stack
[
top
+
+
]
=
pivotIndex
-
1
;
start
=
pivotIndex
+
1
;
}
else
{
stack
[
top
+
+
]
=
pivotIndex
+
1
;
stack
[
top
+
+
]
=
end
;
end
=
pivotIndex
-
1
;
}
}
}
return
array
;
}
