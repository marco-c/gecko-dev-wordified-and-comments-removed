function
CountingSort
(
array
len
signed
comparefn
)
{
assert
(
IsPossiblyWrappedTypedArray
(
array
)
"
CountingSort
works
only
with
typed
arrays
.
"
)
;
if
(
len
<
128
)
{
QuickSort
(
array
len
comparefn
)
;
return
array
;
}
var
min
=
0
;
if
(
signed
)
{
min
=
-
128
;
}
var
buffer
=
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
val
=
array
[
i
]
;
buffer
[
val
-
min
]
+
+
;
}
var
val
=
-
1
;
for
(
var
i
=
0
;
i
<
len
;
)
{
var
j
;
do
{
j
=
buffer
[
+
+
val
]
;
}
while
(
j
=
=
=
0
)
;
for
(
;
j
>
0
;
j
-
-
)
array
[
i
+
+
]
=
val
+
min
;
}
return
array
;
}
function
ByteAtCol
(
x
pos
)
{
return
(
x
>
>
(
pos
*
8
)
)
&
0xFF
;
}
function
SortByColumn
(
array
len
aux
col
counts
)
{
const
R
=
256
;
assert
(
counts
.
length
=
=
=
R
+
1
"
counts
has
|
R
|
+
1
entries
"
)
;
for
(
let
r
=
0
;
r
<
R
+
1
;
r
+
+
)
{
counts
[
r
]
=
0
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
val
=
array
[
i
]
;
let
b
=
ByteAtCol
(
val
col
)
;
counts
[
b
+
1
]
+
+
;
}
for
(
let
r
=
0
;
r
<
R
;
r
+
+
)
{
counts
[
r
+
1
]
+
=
counts
[
r
]
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
val
=
array
[
i
]
;
let
b
=
ByteAtCol
(
val
col
)
;
aux
[
counts
[
b
]
+
+
]
=
val
;
}
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
array
[
i
]
=
aux
[
i
]
;
}
}
function
RadixSort
(
array
len
buffer
nbytes
signed
floating
comparefn
)
{
assert
(
IsPossiblyWrappedTypedArray
(
array
)
"
RadixSort
works
only
with
typed
arrays
.
"
)
;
if
(
len
<
512
)
{
QuickSort
(
array
len
comparefn
)
;
return
array
;
}
let
aux
=
[
]
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
DefineDataProperty
(
aux
i
0
)
;
let
view
=
array
;
let
signMask
=
1
<
<
nbytes
*
8
-
1
;
if
(
floating
)
{
if
(
buffer
=
=
=
null
)
{
buffer
=
callFunction
(
std_TypedArray_buffer
array
)
;
assert
(
buffer
!
=
=
null
"
Attached
data
buffer
should
be
reified
"
)
;
}
let
offset
=
IsTypedArray
(
array
)
?
TypedArrayByteOffset
(
array
)
:
callFunction
(
CallTypedArrayMethodIfWrapped
array
"
TypedArrayByteOffsetMethod
"
)
;
let
Int32Array
=
GetBuiltinConstructor
(
"
Int32Array
"
)
;
view
=
new
Int32Array
(
buffer
offset
len
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
view
[
i
]
&
signMask
)
{
if
(
(
view
[
i
]
&
0x7F800000
)
!
=
=
0x7F800000
|
|
(
view
[
i
]
&
0x007FFFFF
)
=
=
=
0
)
{
view
[
i
]
^
=
0xFFFFFFFF
;
}
}
else
{
view
[
i
]
^
=
signMask
;
}
}
}
else
if
(
signed
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
view
[
i
]
^
=
signMask
;
}
}
let
counts
=
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
;
for
(
let
col
=
0
;
col
<
nbytes
;
col
+
+
)
{
SortByColumn
(
view
len
aux
col
counts
)
;
}
if
(
floating
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
view
[
i
]
&
signMask
)
{
view
[
i
]
^
=
signMask
;
}
else
{
view
[
i
]
^
=
0xFFFFFFFF
;
}
}
}
else
if
(
signed
)
{
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
view
[
i
]
^
=
signMask
;
}
}
return
array
;
}
function
InsertionSort
(
array
from
to
comparefn
)
{
let
item
swap
i
j
;
for
(
i
=
from
+
1
;
i
<
=
to
;
i
+
+
)
{
item
=
array
[
i
]
;
for
(
j
=
i
-
1
;
j
>
=
from
;
j
-
-
)
{
swap
=
array
[
j
]
;
if
(
comparefn
(
swap
item
)
<
=
0
)
break
;
array
[
j
+
1
]
=
swap
;
}
array
[
j
+
1
]
=
item
;
}
}
function
SwapArrayElements
(
array
i
j
)
{
var
swap
=
array
[
i
]
;
array
[
i
]
=
array
[
j
]
;
array
[
j
]
=
swap
;
}
function
Merge
(
list
out
start
mid
end
comparefn
)
{
if
(
mid
>
=
end
|
|
comparefn
(
list
[
mid
]
list
[
mid
+
1
]
)
<
=
0
)
{
for
(
var
i
=
start
;
i
<
=
end
;
i
+
+
)
{
DefineDataProperty
(
out
i
list
[
i
]
)
;
}
return
;
}
var
i
=
start
;
var
j
=
mid
+
1
;
var
k
=
start
;
while
(
i
<
=
mid
&
&
j
<
=
end
)
{
var
lvalue
=
list
[
i
]
;
var
rvalue
=
list
[
j
]
;
if
(
comparefn
(
lvalue
rvalue
)
<
=
0
)
{
DefineDataProperty
(
out
k
+
+
lvalue
)
;
i
+
+
;
}
else
{
DefineDataProperty
(
out
k
+
+
rvalue
)
;
j
+
+
;
}
}
while
(
i
<
=
mid
)
{
DefineDataProperty
(
out
k
+
+
list
[
i
+
+
]
)
;
}
while
(
j
<
=
end
)
{
DefineDataProperty
(
out
k
+
+
list
[
j
+
+
]
)
;
}
}
function
MoveHoles
(
sparse
sparseLen
dense
denseLen
)
{
for
(
var
i
=
0
;
i
<
denseLen
;
i
+
+
)
sparse
[
i
]
=
dense
[
i
]
;
for
(
var
j
=
denseLen
;
j
<
sparseLen
;
j
+
+
)
delete
sparse
[
j
]
;
}
function
MergeSort
(
array
len
comparefn
)
{
var
denseList
=
[
]
;
var
denseLen
=
0
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
i
in
array
)
DefineDataProperty
(
denseList
denseLen
+
+
array
[
i
]
)
;
}
if
(
denseLen
<
1
)
return
array
;
if
(
denseLen
<
24
)
{
InsertionSort
(
denseList
0
denseLen
-
1
comparefn
)
;
MoveHoles
(
array
len
denseList
denseLen
)
;
return
array
;
}
var
lBuffer
=
denseList
;
var
rBuffer
=
[
]
;
var
windowSize
=
4
;
for
(
var
start
=
0
;
start
<
denseLen
-
1
;
start
+
=
windowSize
)
{
var
end
=
std_Math_min
(
start
+
windowSize
-
1
denseLen
-
1
)
;
InsertionSort
(
lBuffer
start
end
comparefn
)
;
}
for
(
;
windowSize
<
denseLen
;
windowSize
=
2
*
windowSize
)
{
for
(
var
start
=
0
;
start
<
denseLen
;
start
+
=
2
*
windowSize
)
{
var
mid
=
start
+
windowSize
-
1
;
var
end
=
std_Math_min
(
start
+
2
*
windowSize
-
1
denseLen
-
1
)
;
Merge
(
lBuffer
rBuffer
start
mid
end
comparefn
)
;
}
var
swap
=
lBuffer
;
lBuffer
=
rBuffer
;
rBuffer
=
swap
;
}
MoveHoles
(
array
len
lBuffer
denseLen
)
;
return
array
;
}
function
MergeTypedArray
(
list
out
start
mid
end
comparefn
)
{
if
(
mid
>
=
end
|
|
comparefn
(
list
[
mid
]
list
[
mid
+
1
]
)
<
=
0
)
{
for
(
var
i
=
start
;
i
<
=
end
;
i
+
+
)
{
out
[
i
]
=
list
[
i
]
;
}
return
;
}
var
i
=
start
;
var
j
=
mid
+
1
;
var
k
=
start
;
while
(
i
<
=
mid
&
&
j
<
=
end
)
{
var
lvalue
=
list
[
i
]
;
var
rvalue
=
list
[
j
]
;
if
(
comparefn
(
lvalue
rvalue
)
<
=
0
)
{
out
[
k
+
+
]
=
lvalue
;
i
+
+
;
}
else
{
out
[
k
+
+
]
=
rvalue
;
j
+
+
;
}
}
while
(
i
<
=
mid
)
{
out
[
k
+
+
]
=
list
[
i
+
+
]
;
}
while
(
j
<
=
end
)
{
out
[
k
+
+
]
=
list
[
j
+
+
]
;
}
}
function
MergeSortTypedArray
(
array
len
comparefn
)
{
assert
(
IsPossiblyWrappedTypedArray
(
array
)
"
MergeSortTypedArray
works
only
with
typed
arrays
.
"
)
;
if
(
len
<
8
)
{
InsertionSort
(
array
0
len
-
1
comparefn
)
;
return
array
;
}
var
C
=
ConstructorForTypedArray
(
array
)
;
var
lBuffer
=
array
;
var
rBuffer
=
new
C
(
len
)
;
var
windowSize
=
4
;
for
(
var
start
=
0
;
start
<
len
-
1
;
start
+
=
windowSize
)
{
var
end
=
std_Math_min
(
start
+
windowSize
-
1
len
-
1
)
;
InsertionSort
(
lBuffer
start
end
comparefn
)
;
}
for
(
;
windowSize
<
len
;
windowSize
=
2
*
windowSize
)
{
for
(
var
start
=
0
;
start
<
len
;
start
+
=
2
*
windowSize
)
{
var
mid
=
start
+
windowSize
-
1
;
var
end
=
std_Math_min
(
start
+
2
*
windowSize
-
1
len
-
1
)
;
MergeTypedArray
(
lBuffer
rBuffer
start
mid
end
comparefn
)
;
}
var
swap
=
lBuffer
;
lBuffer
=
rBuffer
;
rBuffer
=
swap
;
}
if
(
lBuffer
!
=
=
array
)
{
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
array
[
i
]
=
lBuffer
[
i
]
;
}
}
return
array
;
}
function
Partition
(
array
from
to
comparefn
)
{
assert
(
to
-
from
>
=
3
"
Partition
will
not
work
with
less
than
three
elements
"
)
;
var
medianIndex
=
from
+
(
(
to
-
from
)
>
>
1
)
;
var
i
=
from
+
1
;
var
j
=
to
;
SwapArrayElements
(
array
medianIndex
i
)
;
if
(
comparefn
(
array
[
from
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
from
to
)
;
if
(
comparefn
(
array
[
i
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
i
to
)
;
if
(
comparefn
(
array
[
from
]
array
[
i
]
)
>
0
)
SwapArrayElements
(
array
from
i
)
;
var
pivotIndex
=
i
;
for
(
;
;
)
{
do
i
+
+
;
while
(
comparefn
(
array
[
i
]
array
[
pivotIndex
]
)
<
0
)
;
do
j
-
-
;
while
(
comparefn
(
array
[
j
]
array
[
pivotIndex
]
)
>
0
)
;
if
(
i
>
j
)
break
;
SwapArrayElements
(
array
i
j
)
;
}
SwapArrayElements
(
array
pivotIndex
j
)
;
return
j
;
}
function
QuickSort
(
array
len
comparefn
)
{
assert
(
0
<
=
len
&
&
len
<
=
0x7FFFFFFF
"
length
is
a
positive
int32
value
"
)
;
var
stack
=
new_List
(
)
;
var
top
=
0
;
var
start
=
0
;
var
end
=
len
-
1
;
var
pivotIndex
leftLen
rightLen
;
for
(
;
;
)
{
if
(
end
-
start
<
=
23
)
{
InsertionSort
(
array
start
end
comparefn
)
;
if
(
top
<
1
)
break
;
end
=
stack
[
-
-
top
]
;
start
=
stack
[
-
-
top
]
;
}
else
{
pivotIndex
=
Partition
(
array
start
end
comparefn
)
;
leftLen
=
(
pivotIndex
-
1
)
-
start
;
rightLen
=
end
-
(
pivotIndex
+
1
)
;
if
(
rightLen
>
leftLen
)
{
stack
[
top
+
+
]
=
start
;
stack
[
top
+
+
]
=
pivotIndex
-
1
;
start
=
pivotIndex
+
1
;
}
else
{
stack
[
top
+
+
]
=
pivotIndex
+
1
;
stack
[
top
+
+
]
=
end
;
end
=
pivotIndex
-
1
;
}
}
}
return
array
;
}
