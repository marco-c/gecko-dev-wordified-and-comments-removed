function
CountingSort
(
array
len
signed
)
{
var
buffer
=
new
List
(
)
;
var
min
=
0
;
if
(
signed
)
{
min
=
-
128
;
}
for
(
var
i
=
0
;
i
<
256
;
i
+
+
)
{
buffer
[
i
]
=
0
;
}
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
val
=
array
[
i
]
;
buffer
[
val
-
min
]
+
+
}
var
val
=
0
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
while
(
true
)
{
if
(
buffer
[
val
]
>
0
)
{
array
[
i
]
=
val
+
min
;
buffer
[
val
]
-
-
;
break
;
}
else
{
val
+
+
;
}
}
}
return
array
;
}
function
InsertionSort
(
array
from
to
comparefn
)
{
var
item
swap
;
for
(
var
i
=
from
+
1
;
i
<
=
to
;
i
+
+
)
{
item
=
array
[
i
]
;
for
(
var
j
=
i
-
1
;
j
>
=
from
;
j
-
-
)
{
swap
=
array
[
j
]
;
if
(
comparefn
(
swap
item
)
<
=
0
)
break
;
array
[
j
+
1
]
=
swap
;
}
array
[
j
+
1
]
=
item
;
}
}
function
SwapArrayElements
(
array
i
j
)
{
var
swap
=
array
[
i
]
;
array
[
i
]
=
array
[
j
]
;
array
[
j
]
=
swap
;
}
function
Merge
(
list
start
mid
end
lBuffer
rBuffer
comparefn
)
{
var
i
j
k
;
var
sizeLeft
=
mid
-
start
+
1
;
var
sizeRight
=
end
-
mid
;
for
(
i
=
0
;
i
<
sizeLeft
;
i
+
+
)
lBuffer
[
i
]
=
list
[
start
+
i
]
;
for
(
j
=
0
;
j
<
sizeRight
;
j
+
+
)
rBuffer
[
j
]
=
list
[
mid
+
1
+
j
]
;
i
=
0
;
j
=
0
;
k
=
start
;
while
(
i
<
sizeLeft
&
&
j
<
sizeRight
)
{
if
(
comparefn
(
lBuffer
[
i
]
rBuffer
[
j
]
)
<
=
0
)
{
list
[
k
]
=
lBuffer
[
i
]
;
i
+
+
;
}
else
{
list
[
k
]
=
rBuffer
[
j
]
;
j
+
+
;
}
k
+
+
;
}
while
(
i
<
sizeLeft
)
{
list
[
k
]
=
lBuffer
[
i
]
;
i
+
+
;
k
+
+
;
}
while
(
j
<
sizeRight
)
{
list
[
k
]
=
rBuffer
[
j
]
;
j
+
+
;
k
+
+
;
}
}
function
MoveHoles
(
sparse
sparseLen
dense
denseLen
)
{
for
(
var
i
=
0
;
i
<
denseLen
;
i
+
+
)
_DefineDataProperty
(
sparse
i
dense
[
i
]
)
;
for
(
var
j
=
denseLen
;
j
<
sparseLen
;
j
+
+
)
delete
sparse
[
j
]
;
}
function
MergeSort
(
array
len
comparefn
)
{
var
denseList
=
new
List
(
)
;
var
denseLen
=
0
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
i
in
array
)
denseList
[
denseLen
+
+
]
=
array
[
i
]
;
}
if
(
denseLen
<
1
)
return
array
;
if
(
len
<
24
)
{
InsertionSort
(
denseList
0
denseLen
-
1
comparefn
)
;
MoveHoles
(
array
len
denseList
denseLen
)
;
return
array
;
}
var
lBuffer
=
new
List
(
)
;
var
rBuffer
=
new
List
(
)
;
var
mid
end
endOne
endTwo
;
for
(
var
windowSize
=
1
;
windowSize
<
denseLen
;
windowSize
=
2
*
windowSize
)
{
for
(
var
start
=
0
;
start
<
denseLen
-
1
;
start
+
=
2
*
windowSize
)
{
assert
(
windowSize
<
denseLen
"
The
window
size
is
larger
than
the
array
denseLength
!
"
)
;
mid
=
start
+
windowSize
-
1
;
end
=
start
+
2
*
windowSize
-
1
;
end
=
end
<
denseLen
-
1
?
end
:
denseLen
-
1
;
if
(
mid
>
end
)
continue
;
Merge
(
denseList
start
mid
end
lBuffer
rBuffer
comparefn
)
;
}
}
MoveHoles
(
array
len
denseList
denseLen
)
;
return
array
;
}
function
Partition
(
array
from
to
comparefn
)
{
assert
(
to
-
from
>
=
3
"
Partition
will
not
work
with
less
than
three
elements
"
)
;
var
medianIndex
=
(
from
+
to
)
>
>
1
;
var
i
=
from
+
1
;
var
j
=
to
;
SwapArrayElements
(
array
medianIndex
i
)
;
if
(
comparefn
(
array
[
from
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
from
to
)
;
if
(
comparefn
(
array
[
i
]
array
[
to
]
)
>
0
)
SwapArrayElements
(
array
i
to
)
;
if
(
comparefn
(
array
[
from
]
array
[
i
]
)
>
0
)
SwapArrayElements
(
array
from
i
)
;
var
pivotIndex
=
i
;
for
(
;
;
)
{
do
i
+
+
;
while
(
comparefn
(
array
[
i
]
array
[
pivotIndex
]
)
<
0
)
;
do
j
-
-
;
while
(
comparefn
(
array
[
j
]
array
[
pivotIndex
]
)
>
0
)
;
if
(
i
>
j
)
break
;
SwapArrayElements
(
array
i
j
)
;
}
SwapArrayElements
(
array
pivotIndex
j
)
;
return
j
;
}
function
QuickSort
(
array
len
comparefn
)
{
var
stack
=
new
List
(
)
;
var
top
=
0
;
var
start
=
0
;
var
end
=
len
-
1
;
var
pivotIndex
i
j
leftLen
rightLen
;
for
(
;
;
)
{
if
(
end
-
start
<
=
23
)
{
InsertionSort
(
array
start
end
comparefn
)
;
if
(
top
<
1
)
break
;
end
=
stack
[
-
-
top
]
;
start
=
stack
[
-
-
top
]
;
}
else
{
pivotIndex
=
Partition
(
array
start
end
comparefn
)
;
leftLen
=
(
pivotIndex
-
1
)
-
start
;
rightLen
=
end
-
(
pivotIndex
+
1
)
;
if
(
rightLen
>
leftLen
)
{
stack
[
top
+
+
]
=
start
;
stack
[
top
+
+
]
=
pivotIndex
-
1
;
start
=
pivotIndex
+
1
;
}
else
{
stack
[
top
+
+
]
=
pivotIndex
+
1
;
stack
[
top
+
+
]
=
end
;
end
=
pivotIndex
-
1
;
}
}
}
return
array
;
}
