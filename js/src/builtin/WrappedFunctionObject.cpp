#
include
"
builtin
/
WrappedFunctionObject
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
friend
/
DumpFunctions
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
JS
;
bool
js
:
:
GetWrappedValue
(
JSContext
*
cx
Realm
*
callerRealm
HandleValue
value
MutableHandleValue
res
)
{
if
(
!
value
.
isObject
(
)
)
{
res
.
set
(
value
)
;
return
true
;
}
RootedObject
objectVal
(
cx
&
value
.
toObject
(
)
)
;
if
(
!
IsCallable
(
objectVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_INVALID_RETURN
)
;
return
false
;
}
return
WrappedFunctionCreate
(
cx
callerRealm
objectVal
res
)
;
}
static
bool
WrappedFunction_Call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
callee
(
cx
&
args
.
callee
(
)
)
;
MOZ_ASSERT
(
callee
-
>
is
<
WrappedFunctionObject
>
(
)
)
;
Handle
<
WrappedFunctionObject
*
>
F
=
callee
.
as
<
WrappedFunctionObject
>
(
)
;
RootedObject
target
(
cx
F
-
>
getTargetFunction
(
)
)
;
MOZ_ASSERT
(
IsCallable
(
ObjectValue
(
*
target
)
)
)
;
Rooted
<
Realm
*
>
targetRealm
(
cx
GetFunctionRealm
(
cx
target
)
)
;
if
(
!
targetRealm
)
{
return
false
;
}
Rooted
<
Realm
*
>
callerRealm
(
cx
GetFunctionRealm
(
cx
F
)
)
;
if
(
!
callerRealm
)
{
return
false
;
}
RootedValue
result
(
cx
)
;
{
RootedObject
global
(
cx
JS
:
:
GetRealmGlobalOrNull
(
callerRealm
)
)
;
MOZ_RELEASE_ASSERT
(
global
"
global
is
null
;
executing
in
a
realm
that
'
s
being
GC
'
d
?
"
)
;
AutoRealm
ar
(
cx
global
)
;
RootedValueVector
wrappedArgs
(
cx
)
;
RootedValue
element
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
args
.
length
(
)
;
i
+
+
)
{
element
=
args
.
get
(
i
)
;
if
(
!
GetWrappedValue
(
cx
targetRealm
element
&
element
)
)
{
return
false
;
}
if
(
!
wrappedArgs
.
append
(
element
)
)
{
return
false
;
}
}
RootedValue
wrappedThisArgument
(
cx
)
;
if
(
!
GetWrappedValue
(
cx
targetRealm
args
.
thisv
(
)
&
wrappedThisArgument
)
)
{
return
false
;
}
if
(
!
JS
:
:
Call
(
cx
wrappedThisArgument
target
wrappedArgs
&
result
)
)
{
JS_ClearPendingException
(
cx
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE
)
;
return
false
;
}
if
(
!
GetWrappedValue
(
cx
callerRealm
result
args
.
rval
(
)
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
CopyNameAndLength
(
JSContext
*
cx
HandleObject
F
HandleObject
Target
char
*
prefix
=
nullptr
unsigned
argCount
=
0
)
{
double
L
=
0
;
RootedId
length
(
cx
NameToId
(
cx
-
>
names
(
)
.
length
)
)
;
RootedId
name
(
cx
NameToId
(
cx
-
>
names
(
)
.
name
)
)
;
if
(
Target
-
>
is
<
JSFunction
>
(
)
&
&
!
Target
-
>
as
<
JSFunction
>
(
)
.
hasResolvedLength
(
)
)
{
RootedValue
targetLen
(
cx
)
;
if
(
!
JSFunction
:
:
getUnresolvedLength
(
cx
Target
.
as
<
JSFunction
>
(
)
&
targetLen
)
)
{
return
false
;
}
L
=
std
:
:
max
(
0
.
0
targetLen
.
toNumber
(
)
-
argCount
)
;
}
else
{
bool
targetHasLength
;
if
(
!
HasOwnProperty
(
cx
Target
length
&
targetHasLength
)
)
{
return
false
;
}
if
(
targetHasLength
)
{
RootedValue
targetLen
(
cx
)
;
if
(
!
GetProperty
(
cx
Target
Target
length
&
targetLen
)
)
{
return
false
;
}
if
(
targetLen
.
isNumber
(
)
)
{
L
=
std
:
:
max
(
0
.
0
JS
:
:
ToInteger
(
targetLen
.
toNumber
(
)
)
-
argCount
)
;
}
}
}
RootedValue
rootedL
(
cx
DoubleValue
(
L
)
)
;
if
(
!
JS_DefinePropertyById
(
cx
F
length
rootedL
JSPROP_READONLY
)
)
{
return
false
;
}
RootedValue
targetName
(
cx
)
;
if
(
!
GetProperty
(
cx
Target
Target
cx
-
>
names
(
)
.
name
&
targetName
)
)
{
return
false
;
}
if
(
!
targetName
.
isString
(
)
)
{
targetName
=
StringValue
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
}
RootedString
targetString
(
cx
targetName
.
toString
(
)
)
;
RootedId
targetNameId
(
cx
)
;
if
(
!
JS_StringToId
(
cx
targetString
&
targetNameId
)
)
{
return
false
;
}
Rooted
<
JSAtom
*
>
funName
(
cx
IdToFunctionName
(
cx
targetNameId
)
)
;
if
(
!
funName
)
{
return
false
;
}
RootedValue
rootedFunName
(
cx
StringValue
(
funName
)
)
;
return
JS_DefinePropertyById
(
cx
F
name
rootedFunName
JSPROP_READONLY
)
;
}
static
const
JSClassOps
classOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
WrappedFunction_Call
nullptr
nullptr
}
;
const
JSClass
WrappedFunctionObject
:
:
class_
=
{
"
WrappedFunctionObject
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Function
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
WrappedFunctionObject
:
:
SlotCount
)
&
classOps
}
;
JSObject
*
GetRealmFunctionPrototype
(
JSContext
*
cx
Realm
*
realm
)
{
CHECK_THREAD
(
cx
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
realm
-
>
maybeGlobal
(
)
)
;
MOZ_RELEASE_ASSERT
(
global
)
;
return
GlobalObject
:
:
getOrCreateFunctionPrototype
(
cx
global
)
;
}
bool
js
:
:
WrappedFunctionCreate
(
JSContext
*
cx
Realm
*
callerRealm
HandleObject
target
MutableHandleValue
res
)
{
RootedObject
global
(
cx
JS
:
:
GetRealmGlobalOrNull
(
callerRealm
)
)
;
MOZ_RELEASE_ASSERT
(
global
"
global
is
null
;
executing
in
a
realm
that
'
s
being
GC
'
d
?
"
)
;
AutoRealm
ar
(
cx
global
)
;
MOZ_ASSERT
(
target
)
;
RootedObject
maybeWrappedTarget
(
cx
target
)
;
if
(
!
JS_WrapObject
(
cx
&
maybeWrappedTarget
)
)
{
return
false
;
}
RootedObject
functionPrototype
(
cx
GetRealmFunctionPrototype
(
cx
callerRealm
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
functionPrototype
-
>
compartment
(
)
)
;
Rooted
<
WrappedFunctionObject
*
>
wrapped
(
cx
NewObjectWithGivenProto
<
WrappedFunctionObject
>
(
cx
functionPrototype
)
)
;
if
(
!
wrapped
)
{
return
false
;
}
wrapped
-
>
setTargetFunction
(
*
maybeWrappedTarget
)
;
MOZ_ASSERT
(
wrapped
-
>
realm
(
)
=
=
callerRealm
)
;
if
(
!
CopyNameAndLength
(
cx
wrapped
maybeWrappedTarget
)
)
{
JS_ClearPendingException
(
cx
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_WRAP_FAILURE
)
;
return
false
;
}
res
.
set
(
ObjectValue
(
*
wrapped
)
)
;
return
true
;
}
