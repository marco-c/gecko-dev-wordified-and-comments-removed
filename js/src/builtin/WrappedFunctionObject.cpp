#
include
"
builtin
/
WrappedFunctionObject
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
ShadowRealm
.
h
"
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
namespace
JS
;
bool
js
:
:
GetWrappedValue
(
JSContext
*
cx
Realm
*
callerRealm
Handle
<
Value
>
value
MutableHandle
<
Value
>
res
)
{
if
(
!
value
.
isObject
(
)
)
{
res
.
set
(
value
)
;
return
true
;
}
Rooted
<
JSObject
*
>
objectVal
(
cx
&
value
.
toObject
(
)
)
;
if
(
!
IsCallable
(
objectVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_INVALID_RETURN
)
;
return
false
;
}
return
WrappedFunctionCreate
(
cx
callerRealm
objectVal
res
)
;
}
static
bool
WrappedFunction_Call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
JSObject
*
>
callee
(
cx
&
args
.
callee
(
)
)
;
MOZ_ASSERT
(
callee
-
>
is
<
WrappedFunctionObject
>
(
)
)
;
Handle
<
WrappedFunctionObject
*
>
fun
=
callee
.
as
<
WrappedFunctionObject
>
(
)
;
Rooted
<
JSObject
*
>
target
(
cx
fun
-
>
getTargetFunction
(
)
)
;
MOZ_ASSERT
(
IsCallable
(
ObjectValue
(
*
target
)
)
)
;
Rooted
<
Realm
*
>
targetRealm
(
cx
GetFunctionRealm
(
cx
target
)
)
;
if
(
!
targetRealm
)
{
return
false
;
}
Rooted
<
Realm
*
>
callerRealm
(
cx
GetFunctionRealm
(
cx
fun
)
)
;
if
(
!
callerRealm
)
{
return
false
;
}
Rooted
<
Value
>
result
(
cx
)
;
{
Rooted
<
JSObject
*
>
global
(
cx
callerRealm
-
>
maybeGlobal
(
)
)
;
MOZ_RELEASE_ASSERT
(
global
"
global
is
null
;
executing
in
a
realm
that
'
s
being
GC
'
d
?
"
)
;
AutoRealm
ar
(
cx
global
)
;
InvokeArgs
wrappedArgs
(
cx
)
;
if
(
!
wrappedArgs
.
init
(
cx
args
.
length
(
)
)
)
{
return
false
;
}
Rooted
<
Value
>
element
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
args
.
length
(
)
;
i
+
+
)
{
element
=
args
.
get
(
i
)
;
if
(
!
GetWrappedValue
(
cx
targetRealm
element
&
element
)
)
{
return
false
;
}
wrappedArgs
[
i
]
.
set
(
element
)
;
}
Rooted
<
Value
>
wrappedThisArgument
(
cx
)
;
if
(
!
GetWrappedValue
(
cx
targetRealm
args
.
thisv
(
)
&
wrappedThisArgument
)
)
{
return
false
;
}
Rooted
<
Value
>
targetValue
(
cx
ObjectValue
(
*
target
)
)
;
if
(
!
js
:
:
Call
(
cx
targetValue
wrappedThisArgument
wrappedArgs
&
result
)
)
{
ReportPotentiallyDetailedMessage
(
cx
JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE_DETAIL
JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE
)
;
return
false
;
}
if
(
!
GetWrappedValue
(
cx
callerRealm
result
args
.
rval
(
)
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
CopyNameAndLength
(
JSContext
*
cx
HandleObject
fun
HandleObject
target
)
{
constexpr
int32_t
argCount
=
0
;
double
length
=
0
;
if
(
target
-
>
is
<
JSFunction
>
(
)
&
&
!
target
-
>
as
<
JSFunction
>
(
)
.
hasResolvedLength
(
)
)
{
Rooted
<
Value
>
targetLen
(
cx
)
;
if
(
!
JSFunction
:
:
getUnresolvedLength
(
cx
target
.
as
<
JSFunction
>
(
)
&
targetLen
)
)
{
return
false
;
}
length
=
std
:
:
max
(
0
.
0
targetLen
.
toNumber
(
)
-
argCount
)
;
}
else
{
Rooted
<
jsid
>
lengthId
(
cx
NameToId
(
cx
-
>
names
(
)
.
length
)
)
;
bool
targetHasLength
;
if
(
!
HasOwnProperty
(
cx
target
lengthId
&
targetHasLength
)
)
{
return
false
;
}
if
(
targetHasLength
)
{
Rooted
<
Value
>
targetLen
(
cx
)
;
if
(
!
GetProperty
(
cx
target
target
lengthId
&
targetLen
)
)
{
return
false
;
}
if
(
targetLen
.
isNumber
(
)
)
{
length
=
std
:
:
max
(
0
.
0
JS
:
:
ToInteger
(
targetLen
.
toNumber
(
)
)
-
argCount
)
;
}
}
}
Rooted
<
Value
>
rootedLength
(
cx
NumberValue
(
length
)
)
;
if
(
!
DefineDataProperty
(
cx
fun
cx
-
>
names
(
)
.
length
rootedLength
JSPROP_READONLY
)
)
{
return
false
;
}
Rooted
<
Value
>
targetName
(
cx
)
;
if
(
target
-
>
is
<
JSFunction
>
(
)
&
&
!
target
-
>
as
<
JSFunction
>
(
)
.
hasResolvedName
(
)
)
{
if
(
!
JSFunction
:
:
getUnresolvedName
(
cx
target
.
as
<
JSFunction
>
(
)
&
targetName
)
)
{
return
false
;
}
}
else
{
if
(
!
GetProperty
(
cx
target
target
cx
-
>
names
(
)
.
name
&
targetName
)
)
{
return
false
;
}
}
if
(
!
targetName
.
isString
(
)
)
{
targetName
=
StringValue
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
}
return
DefineDataProperty
(
cx
fun
cx
-
>
names
(
)
.
name
targetName
JSPROP_READONLY
)
;
}
static
JSString
*
ToStringOp
(
JSContext
*
cx
JS
:
:
HandleObject
obj
bool
isToSource
)
{
Rooted
<
Value
>
nameVal
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
name
&
nameVal
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
nameVal
.
isString
(
)
)
;
Rooted
<
JSString
*
>
nameStr
(
cx
nameVal
.
toString
(
)
)
;
JSStringBuilder
out
(
cx
)
;
if
(
!
out
.
append
(
"
function
"
)
)
{
return
nullptr
;
}
if
(
!
out
.
append
(
nameStr
)
)
{
return
nullptr
;
}
if
(
!
out
.
append
(
"
(
)
{
\
n
[
native
code
]
\
n
}
"
)
)
{
return
nullptr
;
}
return
out
.
finishString
(
)
;
}
static
const
JSClassOps
classOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
WrappedFunction_Call
nullptr
nullptr
}
;
static
const
ObjectOps
objOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ToStringOp
}
;
const
JSClass
WrappedFunctionObject
:
:
class_
=
{
"
WrappedFunctionObject
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Function
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
WrappedFunctionObject
:
:
SlotCount
)
&
classOps
JS_NULL_CLASS_SPEC
JS_NULL_CLASS_EXT
&
objOps
}
;
JSObject
*
GetRealmFunctionPrototype
(
JSContext
*
cx
Realm
*
realm
)
{
CHECK_THREAD
(
cx
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
realm
-
>
maybeGlobal
(
)
)
;
MOZ_RELEASE_ASSERT
(
global
)
;
return
GlobalObject
:
:
getOrCreateFunctionPrototype
(
cx
global
)
;
}
bool
js
:
:
WrappedFunctionCreate
(
JSContext
*
cx
Realm
*
callerRealm
HandleObject
target
MutableHandle
<
Value
>
res
)
{
Rooted
<
JSObject
*
>
global
(
cx
callerRealm
-
>
maybeGlobal
(
)
)
;
MOZ_RELEASE_ASSERT
(
global
"
global
is
null
;
executing
in
a
realm
that
'
s
being
GC
'
d
?
"
)
;
AutoRealm
ar
(
cx
global
)
;
MOZ_ASSERT
(
target
)
;
Rooted
<
JSObject
*
>
maybeWrappedTarget
(
cx
target
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
maybeWrappedTarget
)
)
{
return
false
;
}
Rooted
<
JSObject
*
>
functionPrototype
(
cx
GetRealmFunctionPrototype
(
cx
callerRealm
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
functionPrototype
-
>
compartment
(
)
)
;
Rooted
<
WrappedFunctionObject
*
>
wrapped
(
cx
NewObjectWithGivenProto
<
WrappedFunctionObject
>
(
cx
functionPrototype
)
)
;
if
(
!
wrapped
)
{
return
false
;
}
wrapped
-
>
setTargetFunction
(
*
maybeWrappedTarget
)
;
MOZ_ASSERT
(
wrapped
-
>
realm
(
)
=
=
callerRealm
)
;
if
(
!
CopyNameAndLength
(
cx
wrapped
maybeWrappedTarget
)
)
{
cx
-
>
clearPendingException
(
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_WRAP_FAILURE
)
;
return
false
;
}
res
.
set
(
ObjectValue
(
*
wrapped
)
)
;
return
true
;
}
