#
ifndef
builtin_WeakMapObject_h
#
define
builtin_WeakMapObject_h
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
WeakCollectionObject
:
public
NativeObject
{
public
:
enum
{
DataSlot
SlotCount
}
;
ValueValueWeakMap
*
getMap
(
)
{
return
maybePtrFromReservedSlot
<
ValueValueWeakMap
>
(
DataSlot
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
[
[
nodiscard
]
]
static
bool
nondeterministicGetKeys
(
JSContext
*
cx
Handle
<
WeakCollectionObject
*
>
obj
MutableHandleObject
ret
)
;
protected
:
static
const
JSClassOps
classOps_
;
}
;
class
WeakMapObject
:
public
WeakCollectionObject
{
public
:
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
[
[
nodiscard
]
]
static
bool
has
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
bool
get
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
bool
set
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
private
:
static
const
ClassSpec
classSpec_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
[
[
nodiscard
]
]
static
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
bool
tryOptimizeCtorWithIterable
(
JSContext
*
cx
Handle
<
WeakMapObject
*
>
obj
Handle
<
Value
>
iterableVal
bool
*
optimized
)
;
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
is
(
HandleValue
v
)
;
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
has_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
get_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
delete_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
[
[
nodiscard
]
]
static
bool
delete_
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
set_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
}
;
}
#
endif
