#
include
"
builtin
/
DisposableStackObject
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
DisposableStackObjectBase
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
UsingHint
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
DisposableStackObject
*
DisposableStackObject
:
:
create
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proto
JS
:
:
Handle
<
JS
:
:
Value
>
initialDisposeCapability
)
{
DisposableStackObject
*
obj
=
NewObjectWithClassProto
<
DisposableStackObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
initialDisposeCapability
.
isUndefined
(
)
|
|
initialDisposeCapability
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
initialDisposeCapability
.
isObject
(
)
initialDisposeCapability
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
)
;
obj
-
>
initReservedSlot
(
DisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
initialDisposeCapability
)
;
obj
-
>
initReservedSlot
(
DisposableStackObject
:
:
STATE_SLOT
JS
:
:
Int32Value
(
int32_t
(
DisposableStackObject
:
:
DisposableState
:
:
Pending
)
)
)
;
return
obj
;
}
bool
DisposableStackObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
DisposableStack
"
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_DisposableStack
&
proto
)
)
{
return
false
;
}
DisposableStackObject
*
obj
=
DisposableStackObject
:
:
create
(
cx
proto
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
DisposableStackObject
:
:
is
(
JS
:
:
Handle
<
JS
:
:
Value
>
val
)
{
return
val
.
isObject
(
)
&
&
val
.
toObject
(
)
.
is
<
DisposableStackObject
>
(
)
;
}
bool
DisposableStackObject
:
:
use_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
args
.
get
(
0
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
val
UsingHint
:
:
Sync
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
val
)
;
return
true
;
}
bool
DisposableStackObject
:
:
use
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
use_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
defer_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDispose
=
args
.
get
(
0
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDispose
)
)
{
return
false
;
}
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Sync
onDispose
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
DisposableStackObject
:
:
defer
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
defer_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
move_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
existingDisposeCapability
(
cx
disposableStack
-
>
getReservedSlot
(
DisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
)
)
;
DisposableStackObject
*
newDisposableStack
=
DisposableStackObject
:
:
create
(
cx
nullptr
existingDisposeCapability
)
;
if
(
!
newDisposableStack
)
{
return
false
;
}
disposableStack
-
>
clearDisposableResourceStack
(
)
;
disposableStack
-
>
setState
(
DisposableState
:
:
Disposed
)
;
args
.
rval
(
)
.
setObject
(
*
newDisposableStack
)
;
return
true
;
}
bool
DisposableStackObject
:
:
move
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
move_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
adopt_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDispose
=
args
.
get
(
1
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDispose
)
)
{
return
false
;
}
JS
:
:
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty_
;
JS
:
:
Rooted
<
JSFunction
*
>
F
(
cx
NewNativeFunction
(
cx
AdoptClosure
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
F
)
{
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
value
=
args
.
get
(
0
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_ValueSlot
value
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_OnDisposeSlot
onDispose
)
;
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
FVal
(
cx
ObjectValue
(
*
F
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Sync
FVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
value
)
;
return
true
;
}
bool
DisposableStackObject
:
:
adopt
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
adopt_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
disposed_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
;
return
true
;
}
bool
DisposableStackObject
:
:
disposed
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
disposed_impl
>
(
cx
args
)
;
}
const
JSPropertySpec
DisposableStackObject
:
:
properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
DisposableStack
"
JSPROP_READONLY
)
JS_PSG
(
"
disposed
"
disposed
0
)
JS_PS_END
}
;
const
JSFunctionSpec
DisposableStackObject
:
:
methods
[
]
=
{
JS_FN
(
"
use
"
DisposableStackObject
:
:
use
1
0
)
JS_SELF_HOSTED_FN
(
"
dispose
"
"
DisposableStackDispose
"
0
0
)
JS_FN
(
"
defer
"
DisposableStackObject
:
:
defer
1
0
)
JS_FN
(
"
move
"
DisposableStackObject
:
:
move
0
0
)
JS_FN
(
"
adopt
"
DisposableStackObject
:
:
adopt
2
0
)
JS_SELF_HOSTED_SYM_FN
(
dispose
"
DisposableStackDispose
"
0
0
)
JS_FS_END
}
;
const
ClassSpec
DisposableStackObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
DisposableStackObject
:
:
construct
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
DisposableStackObject
>
nullptr
nullptr
DisposableStackObject
:
:
methods
DisposableStackObject
:
:
properties
nullptr
}
;
const
JSClass
DisposableStackObject
:
:
class_
=
{
"
DisposableStack
"
JSCLASS_HAS_RESERVED_SLOTS
(
DisposableStackObject
:
:
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_DisposableStack
)
JS_NULL_CLASS_OPS
&
DisposableStackObject
:
:
classSpec_
}
;
const
JSClass
DisposableStackObject
:
:
protoClass_
=
{
"
DisposableStack
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_DisposableStack
)
JS_NULL_CLASS_OPS
&
DisposableStackObject
:
:
classSpec_
}
;
