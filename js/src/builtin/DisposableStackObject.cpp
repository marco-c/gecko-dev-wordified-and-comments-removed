#
include
"
builtin
/
DisposableStackObject
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
List
.
h
"
#
include
"
vm
/
UsingHint
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
DisposableStackObject
*
DisposableStackObject
:
:
create
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proto
JS
:
:
Handle
<
JS
:
:
Value
>
initialDisposeCapability
)
{
DisposableStackObject
*
obj
=
NewObjectWithClassProto
<
DisposableStackObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
initialDisposeCapability
.
isUndefined
(
)
|
|
initialDisposeCapability
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
initialDisposeCapability
.
isObject
(
)
initialDisposeCapability
.
toObject
(
)
.
is
<
ListObject
>
(
)
)
;
obj
-
>
initReservedSlot
(
DisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
initialDisposeCapability
)
;
obj
-
>
initReservedSlot
(
DisposableStackObject
:
:
STATE_SLOT
JS
:
:
Int32Value
(
int32_t
(
DisposableStackObject
:
:
DisposableState
:
:
Pending
)
)
)
;
return
obj
;
}
bool
DisposableStackObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
DisposableStack
"
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_DisposableStack
&
proto
)
)
{
return
false
;
}
DisposableStackObject
*
obj
=
DisposableStackObject
:
:
create
(
cx
proto
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
DisposableStackObject
:
:
is
(
JS
:
:
Handle
<
JS
:
:
Value
>
val
)
{
return
val
.
isObject
(
)
&
&
val
.
toObject
(
)
.
is
<
DisposableStackObject
>
(
)
;
}
ListObject
*
DisposableStackObject
:
:
getOrCreateDisposeCapability
(
JSContext
*
cx
)
{
ListObject
*
disposablesList
=
nullptr
;
if
(
isDisposableResourceStackEmpty
(
)
)
{
disposablesList
=
ListObject
:
:
create
(
cx
)
;
if
(
!
disposablesList
)
{
return
nullptr
;
}
setReservedSlot
(
DISPOSABLE_RESOURCE_STACK_SLOT
ObjectValue
(
*
disposablesList
)
)
;
}
else
{
disposablesList
=
nonEmptyDisposableResourceStack
(
)
;
}
return
disposablesList
;
}
inline
bool
DisposableStackObject
:
:
isDisposableResourceStackEmpty
(
)
const
{
return
getReservedSlot
(
DISPOSABLE_RESOURCE_STACK_SLOT
)
.
isUndefined
(
)
;
}
inline
void
DisposableStackObject
:
:
clearDisposableResourceStack
(
)
{
setReservedSlot
(
DISPOSABLE_RESOURCE_STACK_SLOT
JS
:
:
UndefinedValue
(
)
)
;
}
inline
ListObject
*
DisposableStackObject
:
:
nonEmptyDisposableResourceStack
(
)
const
{
MOZ_ASSERT
(
!
isDisposableResourceStackEmpty
(
)
)
;
return
&
getReservedSlot
(
DISPOSABLE_RESOURCE_STACK_SLOT
)
.
toObject
(
)
.
as
<
ListObject
>
(
)
;
}
inline
DisposableStackObject
:
:
DisposableState
DisposableStackObject
:
:
state
(
)
const
{
return
DisposableState
(
uint8_t
(
getReservedSlot
(
STATE_SLOT
)
.
toInt32
(
)
)
)
;
}
inline
void
DisposableStackObject
:
:
setState
(
DisposableState
state
)
{
setReservedSlot
(
STATE_SLOT
JS
:
:
Int32Value
(
int32_t
(
state
)
)
)
;
}
bool
DisposableStackObject
:
:
use_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
ListObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
args
.
get
(
0
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
val
UsingHint
:
:
Sync
JS
:
:
NothingHandleValue
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
val
)
;
return
true
;
}
bool
DisposableStackObject
:
:
use
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
use_impl
>
(
cx
args
)
;
}
template
<
typename
ClearFn
>
MOZ_ALWAYS_INLINE
bool
DisposeResources
(
JSContext
*
cx
JS
:
:
Handle
<
ListObject
*
>
disposeCapability
ClearFn
clear
)
{
uint32_t
index
=
disposeCapability
-
>
length
(
)
;
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
bool
hadError
=
false
;
JS
:
:
Rooted
<
JS
:
:
Value
>
latestException
(
cx
)
;
while
(
index
)
{
-
-
index
;
JS
:
:
Value
val
=
disposeCapability
-
>
get
(
index
)
;
MOZ_ASSERT
(
val
.
isObject
(
)
)
;
JS
:
:
Rooted
<
DisposableRecordObject
*
>
resource
(
cx
&
val
.
toObject
(
)
.
as
<
DisposableRecordObject
>
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
resource
-
>
getObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
method
(
cx
resource
-
>
getMethod
(
)
)
;
if
(
method
.
isUndefined
(
)
)
{
continue
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
cx
)
;
if
(
!
Call
(
cx
method
value
&
rval
)
)
{
if
(
hadError
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
result
)
)
{
return
false
;
}
cx
-
>
clearPendingException
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
suppressed
(
cx
latestException
)
;
ErrorObject
*
errorObj
=
CreateSuppressedError
(
cx
result
suppressed
)
;
if
(
!
errorObj
)
{
return
false
;
}
latestException
.
set
(
ObjectValue
(
*
errorObj
)
)
;
}
else
{
hadError
=
true
;
if
(
cx
-
>
isExceptionPending
(
)
)
{
if
(
!
cx
-
>
getPendingException
(
&
latestException
)
)
{
return
false
;
}
cx
-
>
clearPendingException
(
)
;
}
}
}
}
clear
(
)
;
if
(
hadError
)
{
cx
-
>
setPendingException
(
latestException
ShouldCaptureStack
:
:
Maybe
)
;
return
false
;
}
return
true
;
}
bool
DisposableStackObject
:
:
disposeResources
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
state
(
)
=
=
DisposableState
:
:
Pending
)
;
setState
(
DisposableState
:
:
Disposed
)
;
if
(
isDisposableResourceStackEmpty
(
)
)
{
return
true
;
}
JS
:
:
Rooted
<
ListObject
*
>
disposeCapability
(
cx
nonEmptyDisposableResourceStack
(
)
)
;
auto
clearFn
=
[
&
]
(
)
{
clearDisposableResourceStack
(
)
;
}
;
return
DisposeResources
(
cx
disposeCapability
clearFn
)
;
}
bool
DisposableStackObject
:
:
dispose_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
if
(
!
disposableStack
-
>
disposeResources
(
cx
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
DisposableStackObject
:
:
dispose
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
dispose_impl
>
(
cx
args
)
;
}
static
bool
ThrowIfOnDisposeNotCallable
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
onDispose
)
{
if
(
IsCallable
(
onDispose
)
)
{
return
true
;
}
JS
:
:
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
onDispose
nullptr
)
;
if
(
!
bytes
)
{
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_FUNCTION
bytes
.
get
(
)
)
;
return
false
;
}
bool
DisposableStackObject
:
:
defer_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDispose
=
args
.
get
(
0
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDispose
)
)
{
return
false
;
}
JS
:
:
Rooted
<
ListObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
onDisposeVal
(
cx
mozilla
:
:
Some
(
onDispose
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Sync
onDisposeVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
DisposableStackObject
:
:
defer
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
defer_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
move_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_DisposableStack
&
proto
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
existingDisposeCapability
(
cx
disposableStack
-
>
getReservedSlot
(
DisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
)
)
;
DisposableStackObject
*
newDisposableStack
=
DisposableStackObject
:
:
create
(
cx
proto
existingDisposeCapability
)
;
if
(
!
newDisposableStack
)
{
return
false
;
}
disposableStack
-
>
clearDisposableResourceStack
(
)
;
disposableStack
-
>
setState
(
DisposableState
:
:
Disposed
)
;
args
.
rval
(
)
.
setObject
(
*
newDisposableStack
)
;
return
true
;
}
bool
DisposableStackObject
:
:
move
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
move_impl
>
(
cx
args
)
;
}
enum
AdoptClosureSlots
{
AdoptClosureSlot_ValueSlot
=
0
AdoptClosureSlot_OnDisposeSlot
}
;
static
bool
AdoptClosure
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JS
:
:
Rooted
<
JSFunction
*
>
callee
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
callee
-
>
getExtendedSlot
(
AdoptClosureSlot_ValueSlot
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
onDispose
(
cx
callee
-
>
getExtendedSlot
(
AdoptClosureSlot_OnDisposeSlot
)
)
;
return
Call
(
cx
onDispose
JS
:
:
UndefinedHandleValue
value
args
.
rval
(
)
)
;
}
bool
DisposableStackObject
:
:
adopt_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
if
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDispose
=
args
.
get
(
1
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDispose
)
)
{
return
false
;
}
JS
:
:
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty_
;
JS
:
:
Rooted
<
JSFunction
*
>
F
(
cx
NewNativeFunction
(
cx
AdoptClosure
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
F
)
{
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
value
=
args
.
get
(
0
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_ValueSlot
value
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_OnDisposeSlot
onDispose
)
;
JS
:
:
Rooted
<
ListObject
*
>
disposeCapability
(
cx
disposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
FVal
(
cx
mozilla
:
:
Some
(
ObjectValue
(
*
F
)
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Sync
FVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
value
)
;
return
true
;
}
bool
DisposableStackObject
:
:
adopt
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
adopt_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
disposed_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
DisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DisposableStackObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
;
return
true
;
}
bool
DisposableStackObject
:
:
disposed
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
disposed_impl
>
(
cx
args
)
;
}
bool
DisposableStackObject
:
:
finishInit
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
ctor
JS
:
:
Handle
<
JSObject
*
>
proto
)
{
JS
:
:
Handle
<
NativeObject
*
>
nativeProto
=
proto
.
as
<
NativeObject
>
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
disposeFn
(
cx
)
;
JS
:
:
Rooted
<
JS
:
:
PropertyKey
>
disposeId
(
cx
NameToId
(
cx
-
>
names
(
)
.
dispose
)
)
;
if
(
!
NativeGetProperty
(
cx
nativeProto
disposeId
&
disposeFn
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
PropertyKey
>
disposeSym
(
cx
JS
:
:
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
dispose
)
)
;
return
NativeDefineDataProperty
(
cx
nativeProto
disposeSym
disposeFn
0
)
;
}
const
JSPropertySpec
DisposableStackObject
:
:
properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
DisposableStack
"
JSPROP_READONLY
)
JS_PSG
(
"
disposed
"
disposed
0
)
JS_PS_END
}
;
const
JSFunctionSpec
DisposableStackObject
:
:
methods
[
]
=
{
JS_FN
(
"
use
"
DisposableStackObject
:
:
use
1
0
)
JS_FN
(
"
dispose
"
DisposableStackObject
:
:
dispose
0
0
)
JS_FN
(
"
defer
"
DisposableStackObject
:
:
defer
1
0
)
JS_FN
(
"
move
"
DisposableStackObject
:
:
move
0
0
)
JS_FN
(
"
adopt
"
DisposableStackObject
:
:
adopt
2
0
)
JS_SYM_FN
(
dispose
DisposableStackObject
:
:
dispose
0
0
)
JS_FS_END
}
;
const
ClassSpec
DisposableStackObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
DisposableStackObject
:
:
construct
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
DisposableStackObject
>
nullptr
nullptr
DisposableStackObject
:
:
methods
DisposableStackObject
:
:
properties
DisposableStackObject
:
:
finishInit
}
;
const
JSClass
DisposableStackObject
:
:
class_
=
{
"
DisposableStack
"
JSCLASS_HAS_RESERVED_SLOTS
(
DisposableStackObject
:
:
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_DisposableStack
)
JS_NULL_CLASS_OPS
&
DisposableStackObject
:
:
classSpec_
}
;
const
JSClass
DisposableStackObject
:
:
protoClass_
=
{
"
DisposableStack
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_DisposableStack
)
JS_NULL_CLASS_OPS
&
DisposableStackObject
:
:
classSpec_
}
;
