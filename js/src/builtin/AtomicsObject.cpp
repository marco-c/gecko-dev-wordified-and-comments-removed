#
include
"
builtin
/
AtomicsObject
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
asmjs
/
WasmInstance
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
jsobjinlines
.
h
"
using
namespace
js
;
const
Class
AtomicsObject
:
:
class_
=
{
"
Atomics
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Atomics
)
}
;
static
bool
ReportBadArrayType
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_BAD_ARRAY
)
;
return
false
;
}
static
bool
ReportOutOfRange
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
static
bool
ReportCannotWait
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
false
;
}
static
bool
GetSharedTypedArray
(
JSContext
*
cx
HandleValue
v
MutableHandle
<
TypedArrayObject
*
>
viewp
)
{
if
(
!
v
.
isObject
(
)
)
return
ReportBadArrayType
(
cx
)
;
if
(
!
v
.
toObject
(
)
.
is
<
TypedArrayObject
>
(
)
)
return
ReportBadArrayType
(
cx
)
;
viewp
.
set
(
&
v
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
if
(
!
viewp
-
>
isSharedMemory
(
)
)
return
ReportBadArrayType
(
cx
)
;
return
true
;
}
static
bool
GetTypedArrayIndex
(
JSContext
*
cx
HandleValue
v
Handle
<
TypedArrayObject
*
>
view
uint32_t
*
offset
)
{
uint64_t
index
;
if
(
!
js
:
:
ToIntegerIndex
(
cx
v
&
index
)
)
return
false
;
if
(
index
>
=
view
-
>
length
(
)
)
return
ReportOutOfRange
(
cx
)
;
*
offset
=
uint32_t
(
index
)
;
return
true
;
}
static
int32_t
CompareExchange
(
Scalar
:
:
Type
viewType
int32_t
oldCandidate
int32_t
newCandidate
SharedMem
<
void
*
>
viewData
uint32_t
offset
bool
*
badArrayType
=
nullptr
)
{
switch
(
viewType
)
{
case
Scalar
:
:
Int8
:
{
int8_t
oldval
=
(
int8_t
)
oldCandidate
;
int8_t
newval
=
(
int8_t
)
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
int8_t
*
>
(
)
+
offset
oldval
newval
)
;
return
oldval
;
}
case
Scalar
:
:
Uint8
:
{
uint8_t
oldval
=
(
uint8_t
)
oldCandidate
;
uint8_t
newval
=
(
uint8_t
)
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
oldval
newval
)
;
return
oldval
;
}
case
Scalar
:
:
Int16
:
{
int16_t
oldval
=
(
int16_t
)
oldCandidate
;
int16_t
newval
=
(
int16_t
)
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
int16_t
*
>
(
)
+
offset
oldval
newval
)
;
return
oldval
;
}
case
Scalar
:
:
Uint16
:
{
uint16_t
oldval
=
(
uint16_t
)
oldCandidate
;
uint16_t
newval
=
(
uint16_t
)
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
uint16_t
*
>
(
)
+
offset
oldval
newval
)
;
return
oldval
;
}
case
Scalar
:
:
Int32
:
{
int32_t
oldval
=
oldCandidate
;
int32_t
newval
=
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
int32_t
*
>
(
)
+
offset
oldval
newval
)
;
return
oldval
;
}
case
Scalar
:
:
Uint32
:
{
uint32_t
oldval
=
(
uint32_t
)
oldCandidate
;
uint32_t
newval
=
(
uint32_t
)
newCandidate
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
viewData
.
cast
<
uint32_t
*
>
(
)
+
offset
oldval
newval
)
;
return
(
int32_t
)
oldval
;
}
default
:
if
(
badArrayType
)
*
badArrayType
=
true
;
return
0
;
}
}
bool
js
:
:
atomics_compareExchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
oldv
=
args
.
get
(
2
)
;
HandleValue
newv
=
args
.
get
(
3
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
int32_t
oldCandidate
;
if
(
!
ToInt32
(
cx
oldv
&
oldCandidate
)
)
return
false
;
int32_t
newCandidate
;
if
(
!
ToInt32
(
cx
newv
&
newCandidate
)
)
return
false
;
bool
badType
=
false
;
int32_t
result
=
CompareExchange
(
view
-
>
type
(
)
oldCandidate
newCandidate
view
-
>
viewDataShared
(
)
offset
&
badType
)
;
if
(
badType
)
return
ReportBadArrayType
(
cx
)
;
if
(
view
-
>
type
(
)
=
=
Scalar
:
:
Uint32
)
r
.
setNumber
(
(
double
)
(
uint32_t
)
result
)
;
else
r
.
setInt32
(
result
)
;
return
true
;
}
bool
js
:
:
atomics_load
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
SharedMem
<
void
*
>
viewData
=
view
-
>
viewDataShared
(
)
;
switch
(
view
-
>
type
(
)
)
{
case
Scalar
:
:
Uint8
:
{
uint8_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
)
;
r
.
setInt32
(
v
)
;
return
true
;
}
case
Scalar
:
:
Int8
:
{
int8_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
)
;
r
.
setInt32
(
v
)
;
return
true
;
}
case
Scalar
:
:
Int16
:
{
int16_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
int16_t
*
>
(
)
+
offset
)
;
r
.
setInt32
(
v
)
;
return
true
;
}
case
Scalar
:
:
Uint16
:
{
uint16_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
uint16_t
*
>
(
)
+
offset
)
;
r
.
setInt32
(
v
)
;
return
true
;
}
case
Scalar
:
:
Int32
:
{
int32_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
int32_t
*
>
(
)
+
offset
)
;
r
.
setInt32
(
v
)
;
return
true
;
}
case
Scalar
:
:
Uint32
:
{
uint32_t
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
viewData
.
cast
<
uint32_t
*
>
(
)
+
offset
)
;
r
.
setNumber
(
v
)
;
return
true
;
}
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
enum
XchgStoreOp
{
DoExchange
DoStore
}
;
template
<
XchgStoreOp
op
>
static
int32_t
ExchangeOrStore
(
Scalar
:
:
Type
viewType
int32_t
numberValue
SharedMem
<
void
*
>
viewData
uint32_t
offset
bool
*
badArrayType
=
nullptr
)
{
#
define
INT_OP
(
ptr
value
)
\
JS_BEGIN_MACRO
\
if
(
op
=
=
DoStore
)
\
jit
:
:
AtomicOperations
:
:
storeSeqCst
(
ptr
value
)
;
\
else
\
value
=
jit
:
:
AtomicOperations
:
:
exchangeSeqCst
(
ptr
value
)
;
\
JS_END_MACRO
switch
(
viewType
)
{
case
Scalar
:
:
Int8
:
{
int8_t
value
=
(
int8_t
)
numberValue
;
INT_OP
(
viewData
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
return
value
;
}
case
Scalar
:
:
Uint8
:
{
uint8_t
value
=
(
uint8_t
)
numberValue
;
INT_OP
(
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
return
value
;
}
case
Scalar
:
:
Int16
:
{
int16_t
value
=
(
int16_t
)
numberValue
;
INT_OP
(
viewData
.
cast
<
int16_t
*
>
(
)
+
offset
value
)
;
return
value
;
}
case
Scalar
:
:
Uint16
:
{
uint16_t
value
=
(
uint16_t
)
numberValue
;
INT_OP
(
viewData
.
cast
<
uint16_t
*
>
(
)
+
offset
value
)
;
return
value
;
}
case
Scalar
:
:
Int32
:
{
int32_t
value
=
numberValue
;
INT_OP
(
viewData
.
cast
<
int32_t
*
>
(
)
+
offset
value
)
;
return
value
;
}
case
Scalar
:
:
Uint32
:
{
uint32_t
value
=
(
uint32_t
)
numberValue
;
INT_OP
(
viewData
.
cast
<
uint32_t
*
>
(
)
+
offset
value
)
;
return
(
int32_t
)
value
;
}
default
:
if
(
badArrayType
)
*
badArrayType
=
true
;
return
0
;
}
#
undef
INT_OP
}
template
<
XchgStoreOp
op
>
static
bool
ExchangeOrStore
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
valv
=
args
.
get
(
2
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
int32_t
numberValue
;
if
(
!
ToInt32
(
cx
valv
&
numberValue
)
)
return
false
;
bool
badType
=
false
;
int32_t
result
=
ExchangeOrStore
<
op
>
(
view
-
>
type
(
)
numberValue
view
-
>
viewDataShared
(
)
offset
&
badType
)
;
if
(
badType
)
return
ReportBadArrayType
(
cx
)
;
if
(
view
-
>
type
(
)
=
=
Scalar
:
:
Uint32
)
r
.
setNumber
(
(
double
)
(
uint32_t
)
result
)
;
else
r
.
setInt32
(
result
)
;
return
true
;
}
bool
js
:
:
atomics_store
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
ExchangeOrStore
<
DoStore
>
(
cx
argc
vp
)
;
}
bool
js
:
:
atomics_exchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
ExchangeOrStore
<
DoExchange
>
(
cx
argc
vp
)
;
}
template
<
typename
T
>
static
bool
AtomicsBinop
(
JSContext
*
cx
HandleValue
objv
HandleValue
idxv
HandleValue
valv
MutableHandleValue
r
)
{
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
int32_t
numberValue
;
if
(
!
ToInt32
(
cx
valv
&
numberValue
)
)
return
false
;
SharedMem
<
void
*
>
viewData
=
view
-
>
viewDataShared
(
)
;
switch
(
view
-
>
type
(
)
)
{
case
Scalar
:
:
Int8
:
{
int8_t
v
=
(
int8_t
)
numberValue
;
r
.
setInt32
(
T
:
:
operate
(
viewData
.
cast
<
int8_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
case
Scalar
:
:
Uint8
:
{
uint8_t
v
=
(
uint8_t
)
numberValue
;
r
.
setInt32
(
T
:
:
operate
(
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
case
Scalar
:
:
Int16
:
{
int16_t
v
=
(
int16_t
)
numberValue
;
r
.
setInt32
(
T
:
:
operate
(
viewData
.
cast
<
int16_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
case
Scalar
:
:
Uint16
:
{
uint16_t
v
=
(
uint16_t
)
numberValue
;
r
.
setInt32
(
T
:
:
operate
(
viewData
.
cast
<
uint16_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
case
Scalar
:
:
Int32
:
{
int32_t
v
=
numberValue
;
r
.
setInt32
(
T
:
:
operate
(
viewData
.
cast
<
int32_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
case
Scalar
:
:
Uint32
:
{
uint32_t
v
=
(
uint32_t
)
numberValue
;
r
.
setNumber
(
(
double
)
T
:
:
operate
(
viewData
.
cast
<
uint32_t
*
>
(
)
+
offset
v
)
)
;
return
true
;
}
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
#
define
INTEGRAL_TYPES_FOR_EACH
(
NAME
)
\
static
int8_t
operate
(
SharedMem
<
int8_t
*
>
addr
int8_t
v
)
{
return
NAME
(
addr
v
)
;
}
\
static
uint8_t
operate
(
SharedMem
<
uint8_t
*
>
addr
uint8_t
v
)
{
return
NAME
(
addr
v
)
;
}
\
static
int16_t
operate
(
SharedMem
<
int16_t
*
>
addr
int16_t
v
)
{
return
NAME
(
addr
v
)
;
}
\
static
uint16_t
operate
(
SharedMem
<
uint16_t
*
>
addr
uint16_t
v
)
{
return
NAME
(
addr
v
)
;
}
\
static
int32_t
operate
(
SharedMem
<
int32_t
*
>
addr
int32_t
v
)
{
return
NAME
(
addr
v
)
;
}
\
static
uint32_t
operate
(
SharedMem
<
uint32_t
*
>
addr
uint32_t
v
)
{
return
NAME
(
addr
v
)
;
}
class
PerformAdd
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchAddSeqCst
)
static
int32_t
perform
(
int32_t
x
int32_t
y
)
{
return
x
+
y
;
}
}
;
bool
js
:
:
atomics_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformAdd
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformSub
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchSubSeqCst
)
static
int32_t
perform
(
int32_t
x
int32_t
y
)
{
return
x
-
y
;
}
}
;
bool
js
:
:
atomics_sub
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformSub
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformAnd
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchAndSeqCst
)
static
int32_t
perform
(
int32_t
x
int32_t
y
)
{
return
x
&
y
;
}
}
;
bool
js
:
:
atomics_and
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformAnd
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformOr
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchOrSeqCst
)
static
int32_t
perform
(
int32_t
x
int32_t
y
)
{
return
x
|
y
;
}
}
;
bool
js
:
:
atomics_or
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformOr
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformXor
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchXorSeqCst
)
static
int32_t
perform
(
int32_t
x
int32_t
y
)
{
return
x
^
y
;
}
}
;
bool
js
:
:
atomics_xor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformXor
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
bool
js
:
:
atomics_isLockFree
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
v
=
args
.
get
(
0
)
;
int32_t
size
;
if
(
v
.
isInt32
(
)
)
{
size
=
v
.
toInt32
(
)
;
}
else
{
double
dsize
;
if
(
!
ToInteger
(
cx
v
&
dsize
)
)
return
false
;
if
(
!
mozilla
:
:
NumberIsInt32
(
dsize
&
size
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
}
args
.
rval
(
)
.
setBoolean
(
jit
:
:
AtomicOperations
:
:
isLockfree
(
size
)
)
;
return
true
;
}
int32_t
js
:
:
atomics_add_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
PerformAdd
:
:
operate
(
heap
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Uint8
:
return
PerformAdd
:
:
operate
(
heap
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Int16
:
return
PerformAdd
:
:
operate
(
heap
.
cast
<
int16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
case
Scalar
:
:
Uint16
:
return
PerformAdd
:
:
operate
(
heap
.
cast
<
uint16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_sub_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
PerformSub
:
:
operate
(
heap
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Uint8
:
return
PerformSub
:
:
operate
(
heap
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Int16
:
return
PerformSub
:
:
operate
(
heap
.
cast
<
int16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
case
Scalar
:
:
Uint16
:
return
PerformSub
:
:
operate
(
heap
.
cast
<
uint16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_and_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
PerformAnd
:
:
operate
(
heap
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Uint8
:
return
PerformAnd
:
:
operate
(
heap
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Int16
:
return
PerformAnd
:
:
operate
(
heap
.
cast
<
int16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
case
Scalar
:
:
Uint16
:
return
PerformAnd
:
:
operate
(
heap
.
cast
<
uint16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_or_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
PerformOr
:
:
operate
(
heap
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Uint8
:
return
PerformOr
:
:
operate
(
heap
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Int16
:
return
PerformOr
:
:
operate
(
heap
.
cast
<
int16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
case
Scalar
:
:
Uint16
:
return
PerformOr
:
:
operate
(
heap
.
cast
<
uint16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_xor_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
PerformXor
:
:
operate
(
heap
.
cast
<
int8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Uint8
:
return
PerformXor
:
:
operate
(
heap
.
cast
<
uint8_t
*
>
(
)
+
offset
value
)
;
case
Scalar
:
:
Int16
:
return
PerformXor
:
:
operate
(
heap
.
cast
<
int16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
case
Scalar
:
:
Uint16
:
return
PerformXor
:
:
operate
(
heap
.
cast
<
uint16_t
*
>
(
)
+
(
offset
>
>
1
)
value
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_xchg_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
value
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
ExchangeOrStore
<
DoExchange
>
(
Scalar
:
:
Int8
value
heap
offset
)
;
case
Scalar
:
:
Uint8
:
return
ExchangeOrStore
<
DoExchange
>
(
Scalar
:
:
Uint8
value
heap
offset
)
;
case
Scalar
:
:
Int16
:
return
ExchangeOrStore
<
DoExchange
>
(
Scalar
:
:
Int16
value
heap
offset
>
>
1
)
;
case
Scalar
:
:
Uint16
:
return
ExchangeOrStore
<
DoExchange
>
(
Scalar
:
:
Uint16
value
heap
offset
>
>
1
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
int32_t
js
:
:
atomics_cmpxchg_asm_callout
(
wasm
:
:
Instance
*
instance
int32_t
vt
int32_t
offset
int32_t
oldval
int32_t
newval
)
{
SharedMem
<
void
*
>
heap
=
instance
-
>
memoryBase
(
)
.
cast
<
void
*
>
(
)
;
size_t
heapLength
=
instance
-
>
memoryLength
(
)
;
if
(
size_t
(
offset
)
>
=
heapLength
)
return
0
;
switch
(
Scalar
:
:
Type
(
vt
)
)
{
case
Scalar
:
:
Int8
:
return
CompareExchange
(
Scalar
:
:
Int8
oldval
newval
heap
offset
)
;
case
Scalar
:
:
Uint8
:
return
CompareExchange
(
Scalar
:
:
Uint8
oldval
newval
heap
offset
)
;
case
Scalar
:
:
Int16
:
return
CompareExchange
(
Scalar
:
:
Int16
oldval
newval
heap
offset
>
>
1
)
;
case
Scalar
:
:
Uint16
:
return
CompareExchange
(
Scalar
:
:
Uint16
oldval
newval
heap
offset
>
>
1
)
;
default
:
MOZ_CRASH
(
"
Invalid
size
"
)
;
}
}
namespace
js
{
class
FutexWaiter
{
public
:
FutexWaiter
(
uint32_t
offset
JSRuntime
*
rt
)
:
offset
(
offset
)
rt
(
rt
)
lower_pri
(
nullptr
)
back
(
nullptr
)
{
}
uint32_t
offset
;
JSRuntime
*
rt
;
FutexWaiter
*
lower_pri
;
FutexWaiter
*
back
;
}
;
class
AutoLockFutexAPI
{
mozilla
:
:
Maybe
<
js
:
:
UniqueLock
<
js
:
:
Mutex
>
>
unique_
;
public
:
AutoLockFutexAPI
(
)
{
js
:
:
Mutex
*
lock
=
FutexRuntime
:
:
lock_
;
unique_
.
emplace
(
*
lock
)
;
}
~
AutoLockFutexAPI
(
)
{
unique_
.
reset
(
)
;
}
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
unique
(
)
{
return
*
unique_
;
}
}
;
class
AutoUnlockFutexAPI
{
public
:
AutoUnlockFutexAPI
(
)
{
FutexRuntime
:
:
unlock
(
)
;
}
~
AutoUnlockFutexAPI
(
)
{
FutexRuntime
:
:
lock
(
)
;
}
}
;
}
bool
js
:
:
atomics_wait
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
valv
=
args
.
get
(
2
)
;
HandleValue
timeoutv
=
args
.
get
(
3
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
if
(
view
-
>
type
(
)
!
=
Scalar
:
:
Int32
)
return
ReportBadArrayType
(
cx
)
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
int32_t
value
;
if
(
!
ToInt32
(
cx
valv
&
value
)
)
return
false
;
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
timeout
;
if
(
!
timeoutv
.
isUndefined
(
)
)
{
double
timeout_ms
;
if
(
!
ToNumber
(
cx
timeoutv
&
timeout_ms
)
)
return
false
;
if
(
!
mozilla
:
:
IsNaN
(
timeout_ms
)
)
{
if
(
timeout_ms
<
0
)
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
0
.
0
)
)
;
else
if
(
!
mozilla
:
:
IsInfinite
(
timeout_ms
)
)
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
timeout_ms
)
)
;
}
}
if
(
!
rt
-
>
fx
.
canWait
(
)
)
return
ReportCannotWait
(
cx
)
;
AutoLockFutexAPI
lock
;
SharedMem
<
int32_t
*
>
(
addr
)
=
view
-
>
viewDataShared
(
)
.
cast
<
int32_t
*
>
(
)
+
offset
;
if
(
jit
:
:
AtomicOperations
:
:
loadSafeWhenRacy
(
addr
)
!
=
value
)
{
r
.
setString
(
cx
-
>
names
(
)
.
futexNotEqual
)
;
return
true
;
}
Rooted
<
SharedArrayBufferObject
*
>
sab
(
cx
view
-
>
bufferShared
(
)
)
;
SharedArrayRawBuffer
*
sarb
=
sab
-
>
rawBufferObject
(
)
;
FutexWaiter
w
(
offset
rt
)
;
if
(
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
)
{
w
.
lower_pri
=
waiters
;
w
.
back
=
waiters
-
>
back
;
waiters
-
>
back
-
>
lower_pri
=
&
w
;
waiters
-
>
back
=
&
w
;
}
else
{
w
.
lower_pri
=
w
.
back
=
&
w
;
sarb
-
>
setWaiters
(
&
w
)
;
}
FutexRuntime
:
:
WaitResult
result
=
FutexRuntime
:
:
FutexOK
;
bool
retval
=
rt
-
>
fx
.
wait
(
cx
lock
.
unique
(
)
timeout
&
result
)
;
if
(
retval
)
{
switch
(
result
)
{
case
FutexRuntime
:
:
FutexOK
:
r
.
setString
(
cx
-
>
names
(
)
.
futexOK
)
;
break
;
case
FutexRuntime
:
:
FutexTimedOut
:
r
.
setString
(
cx
-
>
names
(
)
.
futexTimedOut
)
;
break
;
}
}
if
(
w
.
lower_pri
=
=
&
w
)
{
sarb
-
>
setWaiters
(
nullptr
)
;
}
else
{
w
.
lower_pri
-
>
back
=
w
.
back
;
w
.
back
-
>
lower_pri
=
w
.
lower_pri
;
if
(
sarb
-
>
waiters
(
)
=
=
&
w
)
sarb
-
>
setWaiters
(
w
.
lower_pri
)
;
}
return
retval
;
}
bool
js
:
:
atomics_wake
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
countv
=
args
.
get
(
2
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
&
view
)
)
return
false
;
if
(
view
-
>
type
(
)
!
=
Scalar
:
:
Int32
)
return
ReportBadArrayType
(
cx
)
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
return
false
;
double
count
;
if
(
countv
.
isUndefined
(
)
)
{
count
=
mozilla
:
:
PositiveInfinity
<
double
>
(
)
;
}
else
{
if
(
!
ToInteger
(
cx
countv
&
count
)
)
return
false
;
if
(
count
<
0
.
0
)
count
=
0
.
0
;
}
AutoLockFutexAPI
lock
;
Rooted
<
SharedArrayBufferObject
*
>
sab
(
cx
view
-
>
bufferShared
(
)
)
;
SharedArrayRawBuffer
*
sarb
=
sab
-
>
rawBufferObject
(
)
;
int32_t
woken
=
0
;
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
;
if
(
waiters
&
&
count
>
0
)
{
FutexWaiter
*
iter
=
waiters
;
do
{
FutexWaiter
*
c
=
iter
;
iter
=
iter
-
>
lower_pri
;
if
(
c
-
>
offset
!
=
offset
|
|
!
c
-
>
rt
-
>
fx
.
isWaiting
(
)
)
continue
;
c
-
>
rt
-
>
fx
.
wake
(
FutexRuntime
:
:
WakeExplicit
)
;
+
+
woken
;
-
-
count
;
}
while
(
count
>
0
&
&
iter
!
=
waiters
)
;
}
r
.
setInt32
(
woken
)
;
return
true
;
}
bool
js
:
:
FutexRuntime
:
:
initialize
(
)
{
MOZ_ASSERT
(
!
lock_
)
;
lock_
=
js_new
<
js
:
:
Mutex
>
(
)
;
return
lock_
!
=
nullptr
;
}
void
js
:
:
FutexRuntime
:
:
destroy
(
)
{
if
(
lock_
)
{
js
:
:
Mutex
*
lock
=
lock_
;
js_delete
(
lock
)
;
lock_
=
nullptr
;
}
}
void
js
:
:
FutexRuntime
:
:
lock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
lock
(
)
;
}
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
>
FutexRuntime
:
:
lock_
;
void
js
:
:
FutexRuntime
:
:
unlock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
unlock
(
)
;
}
js
:
:
FutexRuntime
:
:
FutexRuntime
(
)
:
cond_
(
nullptr
)
state_
(
Idle
)
canWait_
(
false
)
{
}
bool
js
:
:
FutexRuntime
:
:
initInstance
(
)
{
MOZ_ASSERT
(
lock_
)
;
cond_
=
js_new
<
js
:
:
ConditionVariable
>
(
)
;
return
cond_
!
=
nullptr
;
}
void
js
:
:
FutexRuntime
:
:
destroyInstance
(
)
{
if
(
cond_
)
js_delete
(
cond_
)
;
}
bool
js
:
:
FutexRuntime
:
:
isWaiting
(
)
{
return
state_
=
=
Waiting
|
|
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
;
}
bool
js
:
:
FutexRuntime
:
:
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
WaitResult
*
result
)
{
MOZ_ASSERT
(
&
cx
-
>
runtime
(
)
-
>
fx
=
=
this
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
fx
.
canWait
(
)
)
;
MOZ_ASSERT
(
state_
=
=
Idle
|
|
state_
=
=
WaitingInterrupted
)
;
if
(
state_
=
=
WaitingInterrupted
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
false
;
}
const
bool
isTimed
=
timeout
.
isSome
(
)
;
auto
finalEnd
=
timeout
.
map
(
[
]
(
mozilla
:
:
TimeDuration
&
timeout
)
{
return
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
timeout
;
}
)
;
auto
maxSlice
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
4000
.
0
)
;
bool
retval
=
true
;
for
(
;
;
)
{
auto
sliceEnd
=
finalEnd
.
map
(
[
&
]
(
mozilla
:
:
TimeStamp
&
finalEnd
)
{
auto
sliceEnd
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
maxSlice
;
if
(
finalEnd
<
sliceEnd
)
sliceEnd
=
finalEnd
;
return
sliceEnd
;
}
)
;
state_
=
Waiting
;
if
(
isTimed
)
{
mozilla
:
:
Unused
<
<
cond_
-
>
wait_until
(
locked
*
sliceEnd
)
;
}
else
{
cond_
-
>
wait
(
locked
)
;
}
switch
(
state_
)
{
case
FutexRuntime
:
:
Waiting
:
if
(
isTimed
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
if
(
now
>
=
*
finalEnd
)
{
*
result
=
FutexTimedOut
;
goto
finished
;
}
}
break
;
case
FutexRuntime
:
:
Woken
:
*
result
=
FutexOK
;
goto
finished
;
case
FutexRuntime
:
:
WaitingNotifiedForInterrupt
:
state_
=
WaitingInterrupted
;
{
AutoUnlockFutexAPI
unlock
;
retval
=
cx
-
>
runtime
(
)
-
>
handleInterrupt
(
cx
)
;
}
if
(
!
retval
)
goto
finished
;
if
(
state_
=
=
Woken
)
{
*
result
=
FutexOK
;
goto
finished
;
}
break
;
default
:
MOZ_CRASH
(
"
Bad
FutexState
in
wait
(
)
"
)
;
}
}
finished
:
state_
=
Idle
;
return
retval
;
}
void
js
:
:
FutexRuntime
:
:
wake
(
WakeReason
reason
)
{
MOZ_ASSERT
(
isWaiting
(
)
)
;
if
(
(
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
)
&
&
reason
=
=
WakeExplicit
)
{
state_
=
Woken
;
return
;
}
switch
(
reason
)
{
case
WakeExplicit
:
state_
=
Woken
;
break
;
case
WakeForJSInterrupt
:
if
(
state_
=
=
WaitingNotifiedForInterrupt
)
return
;
state_
=
WaitingNotifiedForInterrupt
;
break
;
default
:
MOZ_CRASH
(
"
bad
WakeReason
in
FutexRuntime
:
:
wake
(
)
"
)
;
}
cond_
-
>
notify_all
(
)
;
}
const
JSFunctionSpec
AtomicsMethods
[
]
=
{
JS_INLINABLE_FN
(
"
compareExchange
"
atomics_compareExchange
4
0
AtomicsCompareExchange
)
JS_INLINABLE_FN
(
"
load
"
atomics_load
2
0
AtomicsLoad
)
JS_INLINABLE_FN
(
"
store
"
atomics_store
3
0
AtomicsStore
)
JS_INLINABLE_FN
(
"
exchange
"
atomics_exchange
3
0
AtomicsExchange
)
JS_INLINABLE_FN
(
"
add
"
atomics_add
3
0
AtomicsAdd
)
JS_INLINABLE_FN
(
"
sub
"
atomics_sub
3
0
AtomicsSub
)
JS_INLINABLE_FN
(
"
and
"
atomics_and
3
0
AtomicsAnd
)
JS_INLINABLE_FN
(
"
or
"
atomics_or
3
0
AtomicsOr
)
JS_INLINABLE_FN
(
"
xor
"
atomics_xor
3
0
AtomicsXor
)
JS_INLINABLE_FN
(
"
isLockFree
"
atomics_isLockFree
1
0
AtomicsIsLockFree
)
JS_FN
(
"
wait
"
atomics_wait
4
0
)
JS_FN
(
"
wake
"
atomics_wake
3
0
)
JS_FS_END
}
;
JSObject
*
AtomicsObject
:
:
initClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
RootedObject
objProto
(
cx
global
-
>
getOrCreateObjectPrototype
(
cx
)
)
;
if
(
!
objProto
)
return
nullptr
;
RootedObject
Atomics
(
cx
NewObjectWithGivenProto
(
cx
&
AtomicsObject
:
:
class_
objProto
SingletonObject
)
)
;
if
(
!
Atomics
)
return
nullptr
;
if
(
!
JS_DefineFunctions
(
cx
Atomics
AtomicsMethods
)
)
return
nullptr
;
RootedValue
AtomicsValue
(
cx
ObjectValue
(
*
Atomics
)
)
;
if
(
!
DefineProperty
(
cx
global
cx
-
>
names
(
)
.
Atomics
AtomicsValue
nullptr
nullptr
JSPROP_RESOLVING
)
)
{
return
nullptr
;
}
global
-
>
setConstructor
(
JSProto_Atomics
AtomicsValue
)
;
return
Atomics
;
}
JSObject
*
js
:
:
InitAtomicsClass
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
obj
-
>
is
<
GlobalObject
>
(
)
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
&
obj
-
>
as
<
GlobalObject
>
(
)
)
;
return
AtomicsObject
:
:
initClass
(
cx
global
)
;
}
#
undef
CXX11_ATOMICS
#
undef
GNU_ATOMICS
