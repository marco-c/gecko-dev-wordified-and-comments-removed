#
include
"
builtin
/
AtomicsObject
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
static
bool
ReportBadArrayType
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_BAD_ARRAY
)
;
return
false
;
}
static
bool
ReportOutOfRange
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
static
bool
GetSharedTypedArray
(
JSContext
*
cx
HandleValue
v
bool
waitable
MutableHandle
<
TypedArrayObject
*
>
viewp
)
{
if
(
!
v
.
isObject
(
)
)
{
return
ReportBadArrayType
(
cx
)
;
}
if
(
!
v
.
toObject
(
)
.
is
<
TypedArrayObject
>
(
)
)
{
return
ReportBadArrayType
(
cx
)
;
}
viewp
.
set
(
&
v
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
if
(
!
viewp
-
>
isSharedMemory
(
)
)
{
return
ReportBadArrayType
(
cx
)
;
}
if
(
waitable
)
{
switch
(
viewp
-
>
type
(
)
)
{
case
Scalar
:
:
Int32
:
case
Scalar
:
:
BigInt64
:
break
;
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
else
{
switch
(
viewp
-
>
type
(
)
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
break
;
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
return
true
;
}
static
bool
GetTypedArrayIndex
(
JSContext
*
cx
HandleValue
v
Handle
<
TypedArrayObject
*
>
view
uint32_t
*
offset
)
{
uint64_t
index
;
if
(
!
ToIndex
(
cx
v
&
index
)
)
{
return
false
;
}
if
(
index
>
=
view
-
>
length
(
)
)
{
return
ReportOutOfRange
(
cx
)
;
}
*
offset
=
uint32_t
(
index
)
;
return
true
;
}
template
<
typename
T
>
struct
ArrayOps
{
static
JS
:
:
Result
<
T
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
int32_t
n
;
if
(
!
ToInt32
(
cx
v
&
n
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
(
T
)
n
;
}
static
JS
:
:
Result
<
T
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
double
d
;
if
(
!
ToInteger
(
cx
v
&
d
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setNumber
(
d
)
;
return
(
T
)
JS
:
:
ToInt32
(
d
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
T
v
MutableHandleValue
result
)
{
result
.
setInt32
(
v
)
;
return
Ok
(
)
;
}
}
;
template
<
>
JS
:
:
Result
<
>
ArrayOps
<
uint32_t
>
:
:
storeResult
(
JSContext
*
cx
uint32_t
v
MutableHandleValue
result
)
{
result
.
setNumber
(
v
)
;
return
Ok
(
)
;
}
template
<
>
struct
ArrayOps
<
int64_t
>
{
static
JS
:
:
Result
<
int64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
BigInt
:
:
toInt64
(
bi
)
;
}
static
JS
:
:
Result
<
int64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
BigInt
:
:
toInt64
(
bi
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
int64_t
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
BigInt
:
:
createFromInt64
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
Ok
(
)
;
}
}
;
template
<
>
struct
ArrayOps
<
uint64_t
>
{
static
JS
:
:
Result
<
uint64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
BigInt
:
:
toUint64
(
bi
)
;
}
static
JS
:
:
Result
<
uint64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
BigInt
:
:
toUint64
(
bi
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
uint64_t
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
BigInt
:
:
createFromUint64
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
Ok
(
)
;
}
}
;
template
<
template
<
typename
>
class
F
typename
.
.
.
Args
>
bool
perform
(
JSContext
*
cx
HandleValue
objv
HandleValue
idxv
Args
.
.
.
args
)
{
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
false
&
view
)
)
{
return
false
;
}
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
{
return
false
;
}
SharedMem
<
void
*
>
viewData
=
view
-
>
dataPointerShared
(
)
;
switch
(
view
-
>
type
(
)
)
{
case
Scalar
:
:
Int8
:
return
F
<
int8_t
>
:
:
run
(
cx
viewData
.
cast
<
int8_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Uint8
:
return
F
<
uint8_t
>
:
:
run
(
cx
viewData
.
cast
<
uint8_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Int16
:
return
F
<
int16_t
>
:
:
run
(
cx
viewData
.
cast
<
int16_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Uint16
:
return
F
<
uint16_t
>
:
:
run
(
cx
viewData
.
cast
<
uint16_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Int32
:
return
F
<
int32_t
>
:
:
run
(
cx
viewData
.
cast
<
int32_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Uint32
:
return
F
<
uint32_t
>
:
:
run
(
cx
viewData
.
cast
<
uint32_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
BigInt64
:
return
F
<
int64_t
>
:
:
run
(
cx
viewData
.
cast
<
int64_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
BigUint64
:
return
F
<
uint64_t
>
:
:
run
(
cx
viewData
.
cast
<
uint64_t
*
>
(
)
+
offset
args
.
.
.
)
;
case
Scalar
:
:
Float32
:
case
Scalar
:
:
Float64
:
case
Scalar
:
:
Uint8Clamped
:
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
break
;
}
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
template
<
typename
T
>
struct
DoCompareExchange
{
static
bool
run
(
JSContext
*
cx
SharedMem
<
T
*
>
addr
HandleValue
oldv
HandleValue
newv
MutableHandleValue
result
)
{
using
Ops
=
ArrayOps
<
T
>
;
T
oldval
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
oldval
Ops
:
:
convertValue
(
cx
oldv
)
)
;
T
newval
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
newval
Ops
:
:
convertValue
(
cx
newv
)
)
;
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
addr
oldval
newval
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
Ops
:
:
storeResult
(
cx
oldval
result
)
)
;
return
true
;
}
}
;
bool
js
:
:
atomics_compareExchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
perform
<
DoCompareExchange
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
get
(
3
)
args
.
rval
(
)
)
;
}
template
<
typename
T
>
struct
DoLoad
{
static
bool
run
(
JSContext
*
cx
SharedMem
<
T
*
>
addr
MutableHandleValue
result
)
{
using
Ops
=
ArrayOps
<
T
>
;
T
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
addr
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
Ops
:
:
storeResult
(
cx
v
result
)
)
;
return
true
;
}
}
;
bool
js
:
:
atomics_load
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
perform
<
DoLoad
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
rval
(
)
)
;
}
template
<
typename
T
>
struct
DoExchange
{
static
bool
run
(
JSContext
*
cx
SharedMem
<
T
*
>
addr
HandleValue
valv
MutableHandleValue
result
)
{
using
Ops
=
ArrayOps
<
T
>
;
T
value
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
value
Ops
:
:
convertValue
(
cx
valv
)
)
;
value
=
jit
:
:
AtomicOperations
:
:
exchangeSeqCst
(
addr
value
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
Ops
:
:
storeResult
(
cx
value
result
)
)
;
return
true
;
}
}
;
template
<
typename
T
>
struct
DoStore
{
static
bool
run
(
JSContext
*
cx
SharedMem
<
T
*
>
addr
HandleValue
valv
MutableHandleValue
result
)
{
using
Ops
=
ArrayOps
<
T
>
;
T
value
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
value
Ops
:
:
convertValue
(
cx
valv
result
)
)
;
jit
:
:
AtomicOperations
:
:
storeSeqCst
(
addr
value
)
;
return
true
;
}
}
;
bool
js
:
:
atomics_store
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
perform
<
DoStore
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
bool
js
:
:
atomics_exchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
perform
<
DoExchange
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
template
<
typename
Operate
>
struct
DoBinopWithOperation
{
template
<
typename
T
>
struct
DoBinop
{
static
bool
run
(
JSContext
*
cx
SharedMem
<
T
*
>
addr
HandleValue
valv
MutableHandleValue
result
)
{
using
Ops
=
ArrayOps
<
T
>
;
T
v
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
v
Ops
:
:
convertValue
(
cx
valv
)
)
;
v
=
Operate
:
:
operate
(
addr
v
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
Ops
:
:
storeResult
(
cx
v
result
)
)
;
return
true
;
}
}
;
}
;
template
<
typename
Operate
>
static
bool
AtomicsBinop
(
JSContext
*
cx
HandleValue
objv
HandleValue
idxv
HandleValue
valv
MutableHandleValue
r
)
{
return
perform
<
DoBinopWithOperation
<
Operate
>
:
:
template
DoBinop
>
(
cx
objv
idxv
valv
r
)
;
}
#
define
INTEGRAL_TYPES_FOR_EACH
(
NAME
)
\
static
int8_t
operate
(
SharedMem
<
int8_t
*
>
addr
int8_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
uint8_t
operate
(
SharedMem
<
uint8_t
*
>
addr
uint8_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
int16_t
operate
(
SharedMem
<
int16_t
*
>
addr
int16_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
uint16_t
operate
(
SharedMem
<
uint16_t
*
>
addr
uint16_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
int32_t
operate
(
SharedMem
<
int32_t
*
>
addr
int32_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
uint32_t
operate
(
SharedMem
<
uint32_t
*
>
addr
uint32_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
int64_t
operate
(
SharedMem
<
int64_t
*
>
addr
int64_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
\
static
uint64_t
operate
(
SharedMem
<
uint64_t
*
>
addr
uint64_t
v
)
{
\
return
NAME
(
addr
v
)
;
\
}
class
PerformAdd
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchAddSeqCst
)
}
;
bool
js
:
:
atomics_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformAdd
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformSub
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchSubSeqCst
)
}
;
bool
js
:
:
atomics_sub
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformSub
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformAnd
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchAndSeqCst
)
}
;
bool
js
:
:
atomics_and
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformAnd
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformOr
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchOrSeqCst
)
}
;
bool
js
:
:
atomics_or
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformOr
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
class
PerformXor
{
public
:
INTEGRAL_TYPES_FOR_EACH
(
jit
:
:
AtomicOperations
:
:
fetchXorSeqCst
)
}
;
bool
js
:
:
atomics_xor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicsBinop
<
PerformXor
>
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
args
.
get
(
2
)
args
.
rval
(
)
)
;
}
bool
js
:
:
atomics_isLockFree
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
v
=
args
.
get
(
0
)
;
int32_t
size
;
if
(
v
.
isInt32
(
)
)
{
size
=
v
.
toInt32
(
)
;
}
else
{
double
dsize
;
if
(
!
ToInteger
(
cx
v
&
dsize
)
)
{
return
false
;
}
if
(
!
mozilla
:
:
NumberIsInt32
(
dsize
&
size
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
}
args
.
rval
(
)
.
setBoolean
(
jit
:
:
AtomicOperations
:
:
isLockfreeJS
(
size
)
)
;
return
true
;
}
namespace
js
{
class
FutexWaiter
{
public
:
FutexWaiter
(
uint32_t
offset
JSContext
*
cx
)
:
offset
(
offset
)
cx
(
cx
)
lower_pri
(
nullptr
)
back
(
nullptr
)
{
}
uint32_t
offset
;
JSContext
*
cx
;
FutexWaiter
*
lower_pri
;
FutexWaiter
*
back
;
}
;
class
AutoLockFutexAPI
{
mozilla
:
:
Maybe
<
js
:
:
UniqueLock
<
js
:
:
Mutex
>
>
unique_
;
public
:
AutoLockFutexAPI
(
)
{
js
:
:
Mutex
*
lock
=
FutexThread
:
:
lock_
;
unique_
.
emplace
(
*
lock
)
;
}
~
AutoLockFutexAPI
(
)
{
unique_
.
reset
(
)
;
}
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
unique
(
)
{
return
*
unique_
;
}
}
;
}
template
<
typename
T
>
static
FutexThread
:
:
WaitResult
AtomicsWait
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
T
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
MOZ_ASSERT
(
sarb
"
wait
is
only
applicable
to
shared
memory
"
)
;
if
(
!
cx
-
>
fx
.
canWait
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
FutexThread
:
:
WaitResult
:
:
Error
;
}
SharedMem
<
T
*
>
addr
=
sarb
-
>
dataPointerShared
(
)
.
cast
<
T
*
>
(
)
+
(
byteOffset
/
sizeof
(
T
)
)
;
AutoLockFutexAPI
lock
;
if
(
jit
:
:
AtomicOperations
:
:
loadSafeWhenRacy
(
addr
)
!
=
value
)
{
return
FutexThread
:
:
WaitResult
:
:
NotEqual
;
}
FutexWaiter
w
(
byteOffset
cx
)
;
if
(
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
)
{
w
.
lower_pri
=
waiters
;
w
.
back
=
waiters
-
>
back
;
waiters
-
>
back
-
>
lower_pri
=
&
w
;
waiters
-
>
back
=
&
w
;
}
else
{
w
.
lower_pri
=
w
.
back
=
&
w
;
sarb
-
>
setWaiters
(
&
w
)
;
}
FutexThread
:
:
WaitResult
retval
=
cx
-
>
fx
.
wait
(
cx
lock
.
unique
(
)
timeout
)
;
if
(
w
.
lower_pri
=
=
&
w
)
{
sarb
-
>
setWaiters
(
nullptr
)
;
}
else
{
w
.
lower_pri
-
>
back
=
w
.
back
;
w
.
back
-
>
lower_pri
=
w
.
lower_pri
;
if
(
sarb
-
>
waiters
(
)
=
=
&
w
)
{
sarb
-
>
setWaiters
(
w
.
lower_pri
)
;
}
}
return
retval
;
}
FutexThread
:
:
WaitResult
js
:
:
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int32_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
return
AtomicsWait
(
cx
sarb
byteOffset
value
timeout
)
;
}
FutexThread
:
:
WaitResult
js
:
:
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int64_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
return
AtomicsWait
(
cx
sarb
byteOffset
value
timeout
)
;
}
template
<
typename
T
>
static
bool
DoAtomicsWait
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
view
uint32_t
offset
T
value
HandleValue
timeoutv
MutableHandleValue
r
)
{
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
timeout
;
if
(
!
timeoutv
.
isUndefined
(
)
)
{
double
timeout_ms
;
if
(
!
ToNumber
(
cx
timeoutv
&
timeout_ms
)
)
{
return
false
;
}
if
(
!
mozilla
:
:
IsNaN
(
timeout_ms
)
)
{
if
(
timeout_ms
<
0
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
0
.
0
)
)
;
}
else
if
(
!
mozilla
:
:
IsInfinite
(
timeout_ms
)
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
timeout_ms
)
)
;
}
}
}
Rooted
<
SharedArrayBufferObject
*
>
sab
(
cx
view
-
>
bufferShared
(
)
)
;
uint32_t
byteOffset
=
offset
*
sizeof
(
T
)
+
(
view
-
>
dataPointerShared
(
)
.
cast
<
uint8_t
*
>
(
)
.
unwrap
(
)
-
sab
-
>
dataPointerShared
(
)
.
unwrap
(
)
)
;
switch
(
atomics_wait_impl
(
cx
sab
-
>
rawBufferObject
(
)
byteOffset
value
timeout
)
)
{
case
FutexThread
:
:
WaitResult
:
:
NotEqual
:
r
.
setString
(
cx
-
>
names
(
)
.
futexNotEqual
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
OK
:
r
.
setString
(
cx
-
>
names
(
)
.
futexOK
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
TimedOut
:
r
.
setString
(
cx
-
>
names
(
)
.
futexTimedOut
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
Error
:
return
false
;
default
:
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
}
bool
js
:
:
atomics_wait
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
valv
=
args
.
get
(
2
)
;
HandleValue
timeoutv
=
args
.
get
(
3
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
true
&
view
)
)
{
return
false
;
}
MOZ_ASSERT
(
view
-
>
type
(
)
=
=
Scalar
:
:
Int32
|
|
view
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
{
return
false
;
}
if
(
view
-
>
type
(
)
=
=
Scalar
:
:
Int32
)
{
int32_t
value
;
if
(
!
ToInt32
(
cx
valv
&
value
)
)
{
return
false
;
}
return
DoAtomicsWait
(
cx
view
offset
value
timeoutv
r
)
;
}
MOZ_ASSERT
(
view
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
RootedBigInt
valbi
(
cx
ToBigInt
(
cx
valv
)
)
;
if
(
!
valbi
)
{
return
false
;
}
return
DoAtomicsWait
(
cx
view
offset
BigInt
:
:
toInt64
(
valbi
)
timeoutv
r
)
;
}
int64_t
js
:
:
atomics_notify_impl
(
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int64_t
count
)
{
MOZ_ASSERT
(
sarb
"
notify
is
only
applicable
to
shared
memory
"
)
;
AutoLockFutexAPI
lock
;
int64_t
woken
=
0
;
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
;
if
(
waiters
&
&
count
)
{
FutexWaiter
*
iter
=
waiters
;
do
{
FutexWaiter
*
c
=
iter
;
iter
=
iter
-
>
lower_pri
;
if
(
c
-
>
offset
!
=
byteOffset
|
|
!
c
-
>
cx
-
>
fx
.
isWaiting
(
)
)
{
continue
;
}
c
-
>
cx
-
>
fx
.
notify
(
FutexThread
:
:
NotifyExplicit
)
;
MOZ_RELEASE_ASSERT
(
woken
<
INT64_MAX
)
;
+
+
woken
;
if
(
count
>
0
)
{
-
-
count
;
}
}
while
(
count
&
&
iter
!
=
waiters
)
;
}
return
woken
;
}
bool
js
:
:
atomics_notify
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
idxv
=
args
.
get
(
1
)
;
HandleValue
countv
=
args
.
get
(
2
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
view
(
cx
nullptr
)
;
if
(
!
GetSharedTypedArray
(
cx
objv
true
&
view
)
)
{
return
false
;
}
MOZ_ASSERT
(
view
-
>
type
(
)
=
=
Scalar
:
:
Int32
|
|
view
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
uint32_t
elementSize
=
view
-
>
type
(
)
=
=
Scalar
:
:
Int32
?
sizeof
(
int32_t
)
:
sizeof
(
int64_t
)
;
uint32_t
offset
;
if
(
!
GetTypedArrayIndex
(
cx
idxv
view
&
offset
)
)
{
return
false
;
}
int64_t
count
;
if
(
countv
.
isUndefined
(
)
)
{
count
=
-
1
;
}
else
{
double
dcount
;
if
(
!
ToInteger
(
cx
countv
&
dcount
)
)
{
return
false
;
}
if
(
dcount
<
0
.
0
)
{
dcount
=
0
.
0
;
}
count
=
dcount
<
double
(
1ULL
<
<
63
)
?
int64_t
(
dcount
)
:
-
1
;
}
Rooted
<
SharedArrayBufferObject
*
>
sab
(
cx
view
-
>
bufferShared
(
)
)
;
uint32_t
byteOffset
=
offset
*
elementSize
+
(
view
-
>
dataPointerShared
(
)
.
cast
<
uint8_t
*
>
(
)
.
unwrap
(
)
-
sab
-
>
dataPointerShared
(
)
.
unwrap
(
)
)
;
r
.
setNumber
(
double
(
atomics_notify_impl
(
sab
-
>
rawBufferObject
(
)
byteOffset
count
)
)
)
;
return
true
;
}
bool
js
:
:
FutexThread
:
:
initialize
(
)
{
MOZ_ASSERT
(
!
lock_
)
;
lock_
=
js_new
<
js
:
:
Mutex
>
(
mutexid
:
:
FutexThread
)
;
return
lock_
!
=
nullptr
;
}
void
js
:
:
FutexThread
:
:
destroy
(
)
{
if
(
lock_
)
{
js
:
:
Mutex
*
lock
=
lock_
;
js_delete
(
lock
)
;
lock_
=
nullptr
;
}
}
void
js
:
:
FutexThread
:
:
lock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
lock
(
)
;
}
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
mozilla
:
:
SequentiallyConsistent
>
FutexThread
:
:
lock_
;
void
js
:
:
FutexThread
:
:
unlock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
unlock
(
)
;
}
js
:
:
FutexThread
:
:
FutexThread
(
)
:
cond_
(
nullptr
)
state_
(
Idle
)
canWait_
(
false
)
{
}
bool
js
:
:
FutexThread
:
:
initInstance
(
)
{
MOZ_ASSERT
(
lock_
)
;
cond_
=
js_new
<
js
:
:
ConditionVariable
>
(
)
;
return
cond_
!
=
nullptr
;
}
void
js
:
:
FutexThread
:
:
destroyInstance
(
)
{
if
(
cond_
)
{
js_delete
(
cond_
)
;
}
}
bool
js
:
:
FutexThread
:
:
isWaiting
(
)
{
return
state_
=
=
Waiting
|
|
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
;
}
FutexThread
:
:
WaitResult
js
:
:
FutexThread
:
:
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
MOZ_ASSERT
(
&
cx
-
>
fx
=
=
this
)
;
MOZ_ASSERT
(
cx
-
>
fx
.
canWait
(
)
)
;
MOZ_ASSERT
(
state_
=
=
Idle
|
|
state_
=
=
WaitingInterrupted
)
;
if
(
state_
=
=
WaitingInterrupted
)
{
UnlockGuard
<
Mutex
>
unlock
(
locked
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
WaitResult
:
:
Error
;
}
auto
onFinish
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
state_
=
Idle
;
}
)
;
const
bool
isTimed
=
timeout
.
isSome
(
)
;
auto
finalEnd
=
timeout
.
map
(
[
]
(
const
mozilla
:
:
TimeDuration
&
timeout
)
{
return
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
timeout
;
}
)
;
auto
maxSlice
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
4000
.
0
)
;
for
(
;
;
)
{
auto
sliceEnd
=
finalEnd
.
map
(
[
&
]
(
mozilla
:
:
TimeStamp
&
finalEnd
)
{
auto
sliceEnd
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
maxSlice
;
if
(
finalEnd
<
sliceEnd
)
{
sliceEnd
=
finalEnd
;
}
return
sliceEnd
;
}
)
;
state_
=
Waiting
;
if
(
isTimed
)
{
mozilla
:
:
Unused
<
<
cond_
-
>
wait_until
(
locked
*
sliceEnd
)
;
}
else
{
cond_
-
>
wait
(
locked
)
;
}
switch
(
state_
)
{
case
FutexThread
:
:
Waiting
:
if
(
isTimed
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
if
(
now
>
=
*
finalEnd
)
{
return
WaitResult
:
:
TimedOut
;
}
}
break
;
case
FutexThread
:
:
Woken
:
return
WaitResult
:
:
OK
;
case
FutexThread
:
:
WaitingNotifiedForInterrupt
:
state_
=
WaitingInterrupted
;
{
UnlockGuard
<
Mutex
>
unlock
(
locked
)
;
if
(
!
cx
-
>
handleInterrupt
(
)
)
{
return
WaitResult
:
:
Error
;
}
}
if
(
state_
=
=
Woken
)
{
return
WaitResult
:
:
OK
;
}
break
;
default
:
MOZ_CRASH
(
"
Bad
FutexState
in
wait
(
)
"
)
;
}
}
}
void
js
:
:
FutexThread
:
:
notify
(
NotifyReason
reason
)
{
MOZ_ASSERT
(
isWaiting
(
)
)
;
if
(
(
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
)
&
&
reason
=
=
NotifyExplicit
)
{
state_
=
Woken
;
return
;
}
switch
(
reason
)
{
case
NotifyExplicit
:
state_
=
Woken
;
break
;
case
NotifyForJSInterrupt
:
if
(
state_
=
=
WaitingNotifiedForInterrupt
)
{
return
;
}
state_
=
WaitingNotifiedForInterrupt
;
break
;
default
:
MOZ_CRASH
(
"
bad
NotifyReason
in
FutexThread
:
:
notify
(
)
"
)
;
}
cond_
-
>
notify_all
(
)
;
}
const
JSFunctionSpec
AtomicsMethods
[
]
=
{
JS_INLINABLE_FN
(
"
compareExchange
"
atomics_compareExchange
4
0
AtomicsCompareExchange
)
JS_INLINABLE_FN
(
"
load
"
atomics_load
2
0
AtomicsLoad
)
JS_INLINABLE_FN
(
"
store
"
atomics_store
3
0
AtomicsStore
)
JS_INLINABLE_FN
(
"
exchange
"
atomics_exchange
3
0
AtomicsExchange
)
JS_INLINABLE_FN
(
"
add
"
atomics_add
3
0
AtomicsAdd
)
JS_INLINABLE_FN
(
"
sub
"
atomics_sub
3
0
AtomicsSub
)
JS_INLINABLE_FN
(
"
and
"
atomics_and
3
0
AtomicsAnd
)
JS_INLINABLE_FN
(
"
or
"
atomics_or
3
0
AtomicsOr
)
JS_INLINABLE_FN
(
"
xor
"
atomics_xor
3
0
AtomicsXor
)
JS_INLINABLE_FN
(
"
isLockFree
"
atomics_isLockFree
1
0
AtomicsIsLockFree
)
JS_FN
(
"
wait
"
atomics_wait
4
0
)
JS_FN
(
"
notify
"
atomics_notify
3
0
)
JS_FN
(
"
wake
"
atomics_notify
3
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
AtomicsProperties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Atomics
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
JSObject
*
CreateAtomicsObject
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
(
cx
&
AtomicsObject
:
:
class_
proto
SingletonObject
)
;
}
static
const
ClassSpec
AtomicsClassSpec
=
{
CreateAtomicsObject
nullptr
AtomicsMethods
AtomicsProperties
}
;
const
JSClass
AtomicsObject
:
:
class_
=
{
"
Atomics
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Atomics
)
JS_NULL_CLASS_OPS
&
AtomicsClassSpec
}
;
#
undef
CXX11_ATOMICS
#
undef
GNU_ATOMICS
