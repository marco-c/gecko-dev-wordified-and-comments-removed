#
include
"
builtin
/
AtomicsObject
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
WaitCallbacks
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
static
bool
ReportBadArrayType
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_BAD_ARRAY
)
;
return
false
;
}
static
bool
ReportDetachedArrayBuffer
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
static
bool
ReportOutOfRange
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
static
bool
ValidateIntegerTypedArray
(
JSContext
*
cx
HandleValue
typedArray
bool
waitable
MutableHandle
<
TypedArrayObject
*
>
unwrappedTypedArray
)
{
auto
*
unwrapped
=
UnwrapAndTypeCheckValue
<
TypedArrayObject
>
(
cx
typedArray
[
cx
]
(
)
{
ReportBadArrayType
(
cx
)
;
}
)
;
if
(
!
unwrapped
)
{
return
false
;
}
if
(
unwrapped
-
>
hasDetachedBuffer
(
)
)
{
return
ReportDetachedArrayBuffer
(
cx
)
;
}
if
(
waitable
)
{
switch
(
unwrapped
-
>
type
(
)
)
{
case
Scalar
:
:
Int32
:
case
Scalar
:
:
BigInt64
:
break
;
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
else
{
switch
(
unwrapped
-
>
type
(
)
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
break
;
default
:
return
ReportBadArrayType
(
cx
)
;
}
}
unwrappedTypedArray
.
set
(
unwrapped
)
;
return
true
;
}
static
bool
ValidateAtomicAccess
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
typedArray
HandleValue
requestIndex
size_t
*
index
)
{
MOZ_ASSERT
(
!
typedArray
-
>
hasDetachedBuffer
(
)
)
;
size_t
length
=
typedArray
-
>
length
(
)
;
uint64_t
accessIndex
;
if
(
!
ToIndex
(
cx
requestIndex
&
accessIndex
)
)
{
return
false
;
}
if
(
accessIndex
>
=
length
)
{
return
ReportOutOfRange
(
cx
)
;
}
*
index
=
size_t
(
accessIndex
)
;
return
true
;
}
template
<
typename
T
>
struct
ArrayOps
{
using
Type
=
T
;
static
JS
:
:
Result
<
T
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
int32_t
n
;
if
(
!
ToInt32
(
cx
v
&
n
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
static_cast
<
T
>
(
n
)
;
}
static
JS
:
:
Result
<
T
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
double
d
;
if
(
!
ToInteger
(
cx
v
&
d
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setNumber
(
d
)
;
return
static_cast
<
T
>
(
JS
:
:
ToInt32
(
d
)
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
T
v
MutableHandleValue
result
)
{
result
.
setInt32
(
v
)
;
return
Ok
(
)
;
}
}
;
template
<
>
JS
:
:
Result
<
>
ArrayOps
<
uint32_t
>
:
:
storeResult
(
JSContext
*
cx
uint32_t
v
MutableHandleValue
result
)
{
result
.
setDouble
(
v
)
;
return
Ok
(
)
;
}
template
<
>
struct
ArrayOps
<
int64_t
>
{
using
Type
=
int64_t
;
static
JS
:
:
Result
<
int64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
BigInt
:
:
toInt64
(
bi
)
;
}
static
JS
:
:
Result
<
int64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
BigInt
:
:
toInt64
(
bi
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
int64_t
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
BigInt
:
:
createFromInt64
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
Ok
(
)
;
}
}
;
template
<
>
struct
ArrayOps
<
uint64_t
>
{
using
Type
=
uint64_t
;
static
JS
:
:
Result
<
uint64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
BigInt
:
:
toUint64
(
bi
)
;
}
static
JS
:
:
Result
<
uint64_t
>
convertValue
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
ToBigInt
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
BigInt
:
:
toUint64
(
bi
)
;
}
static
JS
:
:
Result
<
>
storeResult
(
JSContext
*
cx
uint64_t
v
MutableHandleValue
result
)
{
BigInt
*
bi
=
BigInt
:
:
createFromUint64
(
cx
v
)
;
if
(
!
bi
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
result
.
setBigInt
(
bi
)
;
return
Ok
(
)
;
}
}
;
template
<
typename
Op
>
bool
AtomicAccess
(
JSContext
*
cx
HandleValue
obj
HandleValue
index
Op
op
)
{
Rooted
<
TypedArrayObject
*
>
unwrappedTypedArray
(
cx
)
;
if
(
!
ValidateIntegerTypedArray
(
cx
obj
false
&
unwrappedTypedArray
)
)
{
return
false
;
}
size_t
intIndex
;
if
(
!
ValidateAtomicAccess
(
cx
unwrappedTypedArray
index
&
intIndex
)
)
{
return
false
;
}
switch
(
unwrappedTypedArray
-
>
type
(
)
)
{
case
Scalar
:
:
Int8
:
return
op
(
ArrayOps
<
int8_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Uint8
:
return
op
(
ArrayOps
<
uint8_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Int16
:
return
op
(
ArrayOps
<
int16_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Uint16
:
return
op
(
ArrayOps
<
uint16_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Int32
:
return
op
(
ArrayOps
<
int32_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Uint32
:
return
op
(
ArrayOps
<
uint32_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
BigInt64
:
return
op
(
ArrayOps
<
int64_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
BigUint64
:
return
op
(
ArrayOps
<
uint64_t
>
{
}
unwrappedTypedArray
intIndex
)
;
case
Scalar
:
:
Float32
:
case
Scalar
:
:
Float64
:
case
Scalar
:
:
Uint8Clamped
:
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
template
<
typename
T
>
static
SharedMem
<
T
*
>
TypedArrayData
(
JSContext
*
cx
TypedArrayObject
*
typedArray
size_t
index
)
{
if
(
typedArray
-
>
hasDetachedBuffer
(
)
)
{
ReportDetachedArrayBuffer
(
cx
)
;
return
{
}
;
}
SharedMem
<
void
*
>
typedArrayData
=
typedArray
-
>
dataPointerEither
(
)
;
return
typedArrayData
.
cast
<
T
*
>
(
)
+
index
;
}
static
bool
atomics_compareExchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
typedArray
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
return
AtomicAccess
(
cx
typedArray
index
[
cx
&
args
]
(
auto
ops
Handle
<
TypedArrayObject
*
>
unwrappedTypedArray
size_t
index
)
{
using
T
=
typename
decltype
(
ops
)
:
:
Type
;
HandleValue
expectedValue
=
args
.
get
(
2
)
;
HandleValue
replacementValue
=
args
.
get
(
3
)
;
T
oldval
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
oldval
ops
.
convertValue
(
cx
expectedValue
)
)
;
T
newval
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
newval
ops
.
convertValue
(
cx
replacementValue
)
)
;
SharedMem
<
T
*
>
addr
=
TypedArrayData
<
T
>
(
cx
unwrappedTypedArray
index
)
;
if
(
!
addr
)
{
return
false
;
}
oldval
=
jit
:
:
AtomicOperations
:
:
compareExchangeSeqCst
(
addr
oldval
newval
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
ops
.
storeResult
(
cx
oldval
args
.
rval
(
)
)
)
;
return
true
;
}
)
;
}
static
bool
atomics_load
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
typedArray
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
return
AtomicAccess
(
cx
typedArray
index
[
cx
&
args
]
(
auto
ops
Handle
<
TypedArrayObject
*
>
unwrappedTypedArray
size_t
index
)
{
using
T
=
typename
decltype
(
ops
)
:
:
Type
;
SharedMem
<
T
*
>
addr
=
TypedArrayData
<
T
>
(
cx
unwrappedTypedArray
index
)
;
if
(
!
addr
)
{
return
false
;
}
T
v
=
jit
:
:
AtomicOperations
:
:
loadSeqCst
(
addr
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
ops
.
storeResult
(
cx
v
args
.
rval
(
)
)
)
;
return
true
;
}
)
;
}
static
bool
atomics_store
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
typedArray
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
return
AtomicAccess
(
cx
typedArray
index
[
cx
&
args
]
(
auto
ops
Handle
<
TypedArrayObject
*
>
unwrappedTypedArray
size_t
index
)
{
using
T
=
typename
decltype
(
ops
)
:
:
Type
;
HandleValue
value
=
args
.
get
(
2
)
;
T
v
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
v
ops
.
convertValue
(
cx
value
args
.
rval
(
)
)
)
;
SharedMem
<
T
*
>
addr
=
TypedArrayData
<
T
>
(
cx
unwrappedTypedArray
index
)
;
if
(
!
addr
)
{
return
false
;
}
jit
:
:
AtomicOperations
:
:
storeSeqCst
(
addr
v
)
;
return
true
;
}
)
;
}
template
<
typename
AtomicOp
>
static
bool
AtomicReadModifyWrite
(
JSContext
*
cx
const
CallArgs
&
args
AtomicOp
op
)
{
HandleValue
typedArray
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
return
AtomicAccess
(
cx
typedArray
index
[
cx
&
args
op
]
(
auto
ops
Handle
<
TypedArrayObject
*
>
unwrappedTypedArray
size_t
index
)
{
using
T
=
typename
decltype
(
ops
)
:
:
Type
;
HandleValue
value
=
args
.
get
(
2
)
;
T
v
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
v
ops
.
convertValue
(
cx
value
)
)
;
SharedMem
<
T
*
>
addr
=
TypedArrayData
<
T
>
(
cx
unwrappedTypedArray
index
)
;
if
(
!
addr
)
{
return
false
;
}
v
=
op
(
addr
v
)
;
JS_TRY_OR_RETURN_FALSE
(
cx
ops
.
storeResult
(
cx
v
args
.
rval
(
)
)
)
;
return
true
;
}
)
;
}
static
bool
atomics_exchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
exchangeSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
fetchAddSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_sub
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
fetchSubSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_and
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
fetchAndSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_or
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
fetchOrSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_xor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
AtomicReadModifyWrite
(
cx
args
[
]
(
auto
addr
auto
val
)
{
return
jit
:
:
AtomicOperations
:
:
fetchXorSeqCst
(
addr
val
)
;
}
)
;
}
static
bool
atomics_isLockFree
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
v
=
args
.
get
(
0
)
;
int32_t
size
;
if
(
v
.
isInt32
(
)
)
{
size
=
v
.
toInt32
(
)
;
}
else
{
double
dsize
;
if
(
!
ToInteger
(
cx
v
&
dsize
)
)
{
return
false
;
}
if
(
!
mozilla
:
:
NumberEqualsInt32
(
dsize
&
size
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
}
args
.
rval
(
)
.
setBoolean
(
jit
:
:
AtomicOperations
:
:
isLockfreeJS
(
size
)
)
;
return
true
;
}
namespace
js
{
class
FutexWaiter
{
public
:
FutexWaiter
(
size_t
offset
JSContext
*
cx
)
:
offset
(
offset
)
cx
(
cx
)
lower_pri
(
nullptr
)
back
(
nullptr
)
{
}
size_t
offset
;
JSContext
*
cx
;
FutexWaiter
*
lower_pri
;
FutexWaiter
*
back
;
}
;
class
AutoLockFutexAPI
{
mozilla
:
:
Maybe
<
js
:
:
UniqueLock
<
js
:
:
Mutex
>
>
unique_
;
public
:
AutoLockFutexAPI
(
)
{
js
:
:
Mutex
*
lock
=
FutexThread
:
:
lock_
;
unique_
.
emplace
(
*
lock
)
;
}
~
AutoLockFutexAPI
(
)
{
unique_
.
reset
(
)
;
}
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
unique
(
)
{
return
*
unique_
;
}
}
;
}
template
<
typename
T
>
static
FutexThread
:
:
WaitResult
AtomicsWait
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
T
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
MOZ_ASSERT
(
sarb
"
wait
is
only
applicable
to
shared
memory
"
)
;
if
(
!
cx
-
>
fx
.
canWait
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
FutexThread
:
:
WaitResult
:
:
Error
;
}
SharedMem
<
T
*
>
addr
=
sarb
-
>
dataPointerShared
(
)
.
cast
<
T
*
>
(
)
+
(
byteOffset
/
sizeof
(
T
)
)
;
AutoLockFutexAPI
lock
;
if
(
jit
:
:
AtomicOperations
:
:
loadSafeWhenRacy
(
addr
)
!
=
value
)
{
return
FutexThread
:
:
WaitResult
:
:
NotEqual
;
}
FutexWaiter
w
(
byteOffset
cx
)
;
if
(
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
)
{
w
.
lower_pri
=
waiters
;
w
.
back
=
waiters
-
>
back
;
waiters
-
>
back
-
>
lower_pri
=
&
w
;
waiters
-
>
back
=
&
w
;
}
else
{
w
.
lower_pri
=
w
.
back
=
&
w
;
sarb
-
>
setWaiters
(
&
w
)
;
}
FutexThread
:
:
WaitResult
retval
=
cx
-
>
fx
.
wait
(
cx
lock
.
unique
(
)
timeout
)
;
if
(
w
.
lower_pri
=
=
&
w
)
{
sarb
-
>
setWaiters
(
nullptr
)
;
}
else
{
w
.
lower_pri
-
>
back
=
w
.
back
;
w
.
back
-
>
lower_pri
=
w
.
lower_pri
;
if
(
sarb
-
>
waiters
(
)
=
=
&
w
)
{
sarb
-
>
setWaiters
(
w
.
lower_pri
)
;
}
}
return
retval
;
}
FutexThread
:
:
WaitResult
js
:
:
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int32_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
return
AtomicsWait
(
cx
sarb
byteOffset
value
timeout
)
;
}
FutexThread
:
:
WaitResult
js
:
:
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int64_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
return
AtomicsWait
(
cx
sarb
byteOffset
value
timeout
)
;
}
template
<
typename
T
>
static
bool
DoAtomicsWait
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
unwrappedTypedArray
size_t
index
T
value
HandleValue
timeoutv
MutableHandleValue
r
)
{
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
timeout
;
if
(
!
timeoutv
.
isUndefined
(
)
)
{
double
timeout_ms
;
if
(
!
ToNumber
(
cx
timeoutv
&
timeout_ms
)
)
{
return
false
;
}
if
(
!
mozilla
:
:
IsNaN
(
timeout_ms
)
)
{
if
(
timeout_ms
<
0
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
0
.
0
)
)
;
}
else
if
(
!
mozilla
:
:
IsInfinite
(
timeout_ms
)
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
timeout_ms
)
)
;
}
}
}
Rooted
<
SharedArrayBufferObject
*
>
unwrappedSab
(
cx
unwrappedTypedArray
-
>
bufferShared
(
)
)
;
size_t
offset
=
unwrappedTypedArray
-
>
byteOffset
(
)
;
size_t
indexedPosition
=
index
*
sizeof
(
T
)
+
offset
;
switch
(
atomics_wait_impl
(
cx
unwrappedSab
-
>
rawBufferObject
(
)
indexedPosition
value
timeout
)
)
{
case
FutexThread
:
:
WaitResult
:
:
NotEqual
:
r
.
setString
(
cx
-
>
names
(
)
.
futexNotEqual
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
OK
:
r
.
setString
(
cx
-
>
names
(
)
.
futexOK
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
TimedOut
:
r
.
setString
(
cx
-
>
names
(
)
.
futexTimedOut
)
;
return
true
;
case
FutexThread
:
:
WaitResult
:
:
Error
:
return
false
;
default
:
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
}
static
bool
atomics_wait
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
HandleValue
valv
=
args
.
get
(
2
)
;
HandleValue
timeoutv
=
args
.
get
(
3
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
unwrappedTypedArray
(
cx
)
;
if
(
!
ValidateIntegerTypedArray
(
cx
objv
true
&
unwrappedTypedArray
)
)
{
return
false
;
}
MOZ_ASSERT
(
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
Int32
|
|
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
if
(
!
unwrappedTypedArray
-
>
isSharedMemory
(
)
)
{
return
ReportBadArrayType
(
cx
)
;
}
size_t
intIndex
;
if
(
!
ValidateAtomicAccess
(
cx
unwrappedTypedArray
index
&
intIndex
)
)
{
return
false
;
}
if
(
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
Int32
)
{
int32_t
value
;
if
(
!
ToInt32
(
cx
valv
&
value
)
)
{
return
false
;
}
return
DoAtomicsWait
(
cx
unwrappedTypedArray
intIndex
value
timeoutv
r
)
;
}
MOZ_ASSERT
(
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
RootedBigInt
value
(
cx
ToBigInt
(
cx
valv
)
)
;
if
(
!
value
)
{
return
false
;
}
return
DoAtomicsWait
(
cx
unwrappedTypedArray
intIndex
BigInt
:
:
toInt64
(
value
)
timeoutv
r
)
;
}
int64_t
js
:
:
atomics_notify_impl
(
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int64_t
count
)
{
MOZ_ASSERT
(
sarb
"
notify
is
only
applicable
to
shared
memory
"
)
;
AutoLockFutexAPI
lock
;
int64_t
woken
=
0
;
FutexWaiter
*
waiters
=
sarb
-
>
waiters
(
)
;
if
(
waiters
&
&
count
)
{
FutexWaiter
*
iter
=
waiters
;
do
{
FutexWaiter
*
c
=
iter
;
iter
=
iter
-
>
lower_pri
;
if
(
c
-
>
offset
!
=
byteOffset
|
|
!
c
-
>
cx
-
>
fx
.
isWaiting
(
)
)
{
continue
;
}
c
-
>
cx
-
>
fx
.
notify
(
FutexThread
:
:
NotifyExplicit
)
;
MOZ_RELEASE_ASSERT
(
woken
<
INT64_MAX
)
;
+
+
woken
;
if
(
count
>
0
)
{
-
-
count
;
}
}
while
(
count
&
&
iter
!
=
waiters
)
;
}
return
woken
;
}
static
bool
atomics_notify
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
objv
=
args
.
get
(
0
)
;
HandleValue
index
=
args
.
get
(
1
)
;
HandleValue
countv
=
args
.
get
(
2
)
;
MutableHandleValue
r
=
args
.
rval
(
)
;
Rooted
<
TypedArrayObject
*
>
unwrappedTypedArray
(
cx
)
;
if
(
!
ValidateIntegerTypedArray
(
cx
objv
true
&
unwrappedTypedArray
)
)
{
return
false
;
}
MOZ_ASSERT
(
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
Int32
|
|
unwrappedTypedArray
-
>
type
(
)
=
=
Scalar
:
:
BigInt64
)
;
size_t
intIndex
;
if
(
!
ValidateAtomicAccess
(
cx
unwrappedTypedArray
index
&
intIndex
)
)
{
return
false
;
}
int64_t
count
;
if
(
countv
.
isUndefined
(
)
)
{
count
=
-
1
;
}
else
{
double
dcount
;
if
(
!
ToInteger
(
cx
countv
&
dcount
)
)
{
return
false
;
}
if
(
dcount
<
0
.
0
)
{
dcount
=
0
.
0
;
}
count
=
dcount
<
double
(
1ULL
<
<
63
)
?
int64_t
(
dcount
)
:
-
1
;
}
if
(
!
unwrappedTypedArray
-
>
isSharedMemory
(
)
)
{
r
.
setInt32
(
0
)
;
return
true
;
}
Rooted
<
SharedArrayBufferObject
*
>
unwrappedSab
(
cx
unwrappedTypedArray
-
>
bufferShared
(
)
)
;
size_t
offset
=
unwrappedTypedArray
-
>
byteOffset
(
)
;
size_t
elementSize
=
Scalar
:
:
byteSize
(
unwrappedTypedArray
-
>
type
(
)
)
;
size_t
indexedPosition
=
intIndex
*
elementSize
+
offset
;
r
.
setNumber
(
double
(
atomics_notify_impl
(
unwrappedSab
-
>
rawBufferObject
(
)
indexedPosition
count
)
)
)
;
return
true
;
}
bool
js
:
:
FutexThread
:
:
initialize
(
)
{
MOZ_ASSERT
(
!
lock_
)
;
lock_
=
js_new
<
js
:
:
Mutex
>
(
mutexid
:
:
FutexThread
)
;
return
lock_
!
=
nullptr
;
}
void
js
:
:
FutexThread
:
:
destroy
(
)
{
if
(
lock_
)
{
js
:
:
Mutex
*
lock
=
lock_
;
js_delete
(
lock
)
;
lock_
=
nullptr
;
}
}
void
js
:
:
FutexThread
:
:
lock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
lock
(
)
;
}
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
mozilla
:
:
SequentiallyConsistent
>
FutexThread
:
:
lock_
;
void
js
:
:
FutexThread
:
:
unlock
(
)
{
js
:
:
Mutex
*
lock
=
lock_
;
lock
-
>
unlock
(
)
;
}
js
:
:
FutexThread
:
:
FutexThread
(
)
:
cond_
(
nullptr
)
state_
(
Idle
)
canWait_
(
false
)
{
}
bool
js
:
:
FutexThread
:
:
initInstance
(
)
{
MOZ_ASSERT
(
lock_
)
;
cond_
=
js_new
<
js
:
:
ConditionVariable
>
(
)
;
return
cond_
!
=
nullptr
;
}
void
js
:
:
FutexThread
:
:
destroyInstance
(
)
{
if
(
cond_
)
{
js_delete
(
cond_
)
;
}
}
bool
js
:
:
FutexThread
:
:
isWaiting
(
)
{
return
state_
=
=
Waiting
|
|
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
;
}
FutexThread
:
:
WaitResult
js
:
:
FutexThread
:
:
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
{
MOZ_ASSERT
(
&
cx
-
>
fx
=
=
this
)
;
MOZ_ASSERT
(
cx
-
>
fx
.
canWait
(
)
)
;
MOZ_ASSERT
(
state_
=
=
Idle
|
|
state_
=
=
WaitingInterrupted
)
;
if
(
state_
=
=
WaitingInterrupted
)
{
UnlockGuard
<
Mutex
>
unlock
(
locked
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ATOMICS_WAIT_NOT_ALLOWED
)
;
return
WaitResult
:
:
Error
;
}
auto
onFinish
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
state_
=
Idle
;
}
)
;
const
bool
isTimed
=
timeout
.
isSome
(
)
;
auto
finalEnd
=
timeout
.
map
(
[
]
(
const
mozilla
:
:
TimeDuration
&
timeout
)
{
return
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
timeout
;
}
)
;
auto
maxSlice
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
4000
.
0
)
;
for
(
;
;
)
{
auto
sliceEnd
=
finalEnd
.
map
(
[
&
]
(
mozilla
:
:
TimeStamp
&
finalEnd
)
{
auto
sliceEnd
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
maxSlice
;
if
(
finalEnd
<
sliceEnd
)
{
sliceEnd
=
finalEnd
;
}
return
sliceEnd
;
}
)
;
state_
=
Waiting
;
MOZ_ASSERT
(
(
cx
-
>
runtime
(
)
-
>
beforeWaitCallback
=
=
nullptr
)
=
=
(
cx
-
>
runtime
(
)
-
>
afterWaitCallback
=
=
nullptr
)
)
;
mozilla
:
:
DebugOnly
<
bool
>
callbacksPresent
=
cx
-
>
runtime
(
)
-
>
beforeWaitCallback
!
=
nullptr
;
void
*
cookie
=
nullptr
;
uint8_t
clientMemory
[
JS
:
:
WAIT_CALLBACK_CLIENT_MAXMEM
]
;
if
(
cx
-
>
runtime
(
)
-
>
beforeWaitCallback
)
{
cookie
=
(
*
cx
-
>
runtime
(
)
-
>
beforeWaitCallback
)
(
clientMemory
)
;
}
if
(
isTimed
)
{
(
void
)
cond_
-
>
wait_until
(
locked
*
sliceEnd
)
;
}
else
{
cond_
-
>
wait
(
locked
)
;
}
MOZ_ASSERT
(
(
cx
-
>
runtime
(
)
-
>
afterWaitCallback
!
=
nullptr
)
=
=
callbacksPresent
)
;
if
(
cx
-
>
runtime
(
)
-
>
afterWaitCallback
)
{
(
*
cx
-
>
runtime
(
)
-
>
afterWaitCallback
)
(
cookie
)
;
}
switch
(
state_
)
{
case
FutexThread
:
:
Waiting
:
if
(
isTimed
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
if
(
now
>
=
*
finalEnd
)
{
return
WaitResult
:
:
TimedOut
;
}
}
break
;
case
FutexThread
:
:
Woken
:
return
WaitResult
:
:
OK
;
case
FutexThread
:
:
WaitingNotifiedForInterrupt
:
state_
=
WaitingInterrupted
;
{
UnlockGuard
<
Mutex
>
unlock
(
locked
)
;
if
(
!
cx
-
>
handleInterrupt
(
)
)
{
return
WaitResult
:
:
Error
;
}
}
if
(
state_
=
=
Woken
)
{
return
WaitResult
:
:
OK
;
}
break
;
default
:
MOZ_CRASH
(
"
Bad
FutexState
in
wait
(
)
"
)
;
}
}
}
void
js
:
:
FutexThread
:
:
notify
(
NotifyReason
reason
)
{
MOZ_ASSERT
(
isWaiting
(
)
)
;
if
(
(
state_
=
=
WaitingInterrupted
|
|
state_
=
=
WaitingNotifiedForInterrupt
)
&
&
reason
=
=
NotifyExplicit
)
{
state_
=
Woken
;
return
;
}
switch
(
reason
)
{
case
NotifyExplicit
:
state_
=
Woken
;
break
;
case
NotifyForJSInterrupt
:
if
(
state_
=
=
WaitingNotifiedForInterrupt
)
{
return
;
}
state_
=
WaitingNotifiedForInterrupt
;
break
;
default
:
MOZ_CRASH
(
"
bad
NotifyReason
in
FutexThread
:
:
notify
(
)
"
)
;
}
cond_
-
>
notify_all
(
)
;
}
const
JSFunctionSpec
AtomicsMethods
[
]
=
{
JS_INLINABLE_FN
(
"
compareExchange
"
atomics_compareExchange
4
0
AtomicsCompareExchange
)
JS_INLINABLE_FN
(
"
load
"
atomics_load
2
0
AtomicsLoad
)
JS_INLINABLE_FN
(
"
store
"
atomics_store
3
0
AtomicsStore
)
JS_INLINABLE_FN
(
"
exchange
"
atomics_exchange
3
0
AtomicsExchange
)
JS_INLINABLE_FN
(
"
add
"
atomics_add
3
0
AtomicsAdd
)
JS_INLINABLE_FN
(
"
sub
"
atomics_sub
3
0
AtomicsSub
)
JS_INLINABLE_FN
(
"
and
"
atomics_and
3
0
AtomicsAnd
)
JS_INLINABLE_FN
(
"
or
"
atomics_or
3
0
AtomicsOr
)
JS_INLINABLE_FN
(
"
xor
"
atomics_xor
3
0
AtomicsXor
)
JS_INLINABLE_FN
(
"
isLockFree
"
atomics_isLockFree
1
0
AtomicsIsLockFree
)
JS_FN
(
"
wait
"
atomics_wait
4
0
)
JS_FN
(
"
notify
"
atomics_notify
3
0
)
JS_FN
(
"
wake
"
atomics_notify
3
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
AtomicsProperties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Atomics
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
JSObject
*
CreateAtomicsObject
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewTenuredObjectWithGivenProto
(
cx
&
AtomicsObject
:
:
class_
proto
)
;
}
static
const
ClassSpec
AtomicsClassSpec
=
{
CreateAtomicsObject
nullptr
AtomicsMethods
AtomicsProperties
}
;
const
JSClass
AtomicsObject
:
:
class_
=
{
"
Atomics
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Atomics
)
JS_NULL_CLASS_OPS
&
AtomicsClassSpec
}
;
