#
include
"
builtin
/
WeakRefObject
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
namespace
js
{
bool
WeakRefObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
WeakRef
"
)
)
{
return
false
;
}
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
{
ReportNotObject
(
cx
args
.
get
(
0
)
)
;
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_WeakRef
&
proto
)
)
{
return
false
;
}
Rooted
<
WeakRefObject
*
>
weakRef
(
cx
NewObjectWithClassProto
<
WeakRefObject
>
(
cx
proto
)
)
;
if
(
!
weakRef
)
{
return
false
;
}
RootedObject
target
(
cx
)
;
target
=
CheckedUnwrapDynamic
(
&
args
[
0
]
.
toObject
(
)
cx
)
;
if
(
!
target
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
!
preserveDOMWrapper
(
cx
target
)
)
{
return
false
;
}
RootedObject
wrappedWeakRef
(
cx
weakRef
)
;
AutoRealm
ar
(
cx
target
)
;
if
(
!
JS_WrapObject
(
cx
&
wrappedWeakRef
)
)
{
return
false
;
}
if
(
JS_IsDeadWrapper
(
wrappedWeakRef
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
if
(
!
target
-
>
zone
(
)
-
>
keepDuringJob
(
target
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
;
gc
:
:
GCRuntime
*
gc
=
&
cx
-
>
runtime
(
)
-
>
gc
;
if
(
!
gc
-
>
registerWeakRef
(
target
wrappedWeakRef
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
;
weakRef
-
>
setReservedSlotGCThingAsPrivate
(
TargetSlot
target
)
;
args
.
rval
(
)
.
setObject
(
*
weakRef
)
;
return
true
;
}
bool
WeakRefObject
:
:
preserveDOMWrapper
(
JSContext
*
cx
HandleObject
obj
)
{
if
(
!
MaybePreserveDOMWrapper
(
cx
obj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_WEAKREF_TARGET
)
;
return
false
;
}
return
true
;
}
void
WeakRefObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
WeakRefObject
*
weakRef
=
&
obj
-
>
as
<
WeakRefObject
>
(
)
;
if
(
trc
-
>
traceWeakEdges
(
)
)
{
JSObject
*
target
=
weakRef
-
>
target
(
)
;
if
(
target
)
{
TraceManuallyBarrieredEdge
(
trc
&
target
"
WeakRefObject
:
:
target
"
)
;
weakRef
-
>
setTargetUnbarriered
(
target
)
;
}
}
}
void
WeakRefObject
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
as
<
WeakRefObject
>
(
)
.
target
(
)
)
;
}
const
JSClassOps
WeakRefObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
finalize
nullptr
nullptr
nullptr
trace
}
;
const
ClassSpec
WeakRefObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
WeakRefObject
:
:
construct
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
WeakRefObject
>
nullptr
nullptr
WeakRefObject
:
:
methods
WeakRefObject
:
:
properties
}
;
const
JSClass
WeakRefObject
:
:
class_
=
{
"
WeakRef
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_WeakRef
)
|
JSCLASS_FOREGROUND_FINALIZE
&
classOps_
&
classSpec_
}
;
const
JSClass
WeakRefObject
:
:
protoClass_
=
{
"
WeakRef
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_WeakRef
)
JS_NULL_CLASS_OPS
&
classSpec_
}
;
const
JSPropertySpec
WeakRefObject
:
:
properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
WeakRef
"
JSPROP_READONLY
)
JS_PS_END
}
;
const
JSFunctionSpec
WeakRefObject
:
:
methods
[
]
=
{
JS_FN
(
"
deref
"
deref
0
0
)
JS_FS_END
}
;
bool
WeakRefObject
:
:
deref
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
|
|
!
args
.
thisv
(
)
.
toObject
(
)
.
is
<
WeakRefObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_A_WEAK_REF
"
Receiver
of
WeakRef
.
deref
call
"
)
;
return
false
;
}
Rooted
<
WeakRefObject
*
>
weakRef
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
WeakRefObject
>
(
)
)
;
readBarrier
(
cx
weakRef
)
;
if
(
!
weakRef
-
>
target
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
target
(
cx
weakRef
-
>
target
(
)
)
;
if
(
!
target
-
>
zone
(
)
-
>
keepDuringJob
(
target
)
)
{
return
false
;
}
RootedObject
wrappedTarget
(
cx
target
)
;
if
(
!
JS_WrapObject
(
cx
&
wrappedTarget
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
wrappedTarget
)
;
return
true
;
}
void
WeakRefObject
:
:
setTargetUnbarriered
(
JSObject
*
target
)
{
setReservedSlotGCThingAsPrivateUnbarriered
(
TargetSlot
target
)
;
}
void
WeakRefObject
:
:
clearTarget
(
)
{
clearReservedSlotGCThingAsPrivate
(
TargetSlot
)
;
}
void
WeakRefObject
:
:
readBarrier
(
JSContext
*
cx
Handle
<
WeakRefObject
*
>
self
)
{
RootedObject
obj
(
cx
self
-
>
target
(
)
)
;
if
(
!
obj
)
{
return
;
}
if
(
obj
-
>
getClass
(
)
-
>
isDOMClass
(
)
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
hasReleasedWrapperCallback
)
;
bool
wasReleased
=
cx
-
>
runtime
(
)
-
>
hasReleasedWrapperCallback
(
obj
)
;
if
(
wasReleased
)
{
self
-
>
clearTarget
(
)
;
return
;
}
}
gc
:
:
ReadBarrier
(
obj
.
get
(
)
)
;
}
namespace
gc
{
bool
GCRuntime
:
:
registerWeakRef
(
HandleObject
target
HandleObject
weakRef
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
MOZ_ASSERT
(
UncheckedUnwrap
(
weakRef
)
-
>
is
<
WeakRefObject
>
(
)
)
;
MOZ_ASSERT
(
target
-
>
compartment
(
)
=
=
weakRef
-
>
compartment
(
)
)
;
auto
&
map
=
target
-
>
zone
(
)
-
>
weakRefMap
(
)
;
auto
ptr
=
map
.
lookupForAdd
(
target
)
;
if
(
!
ptr
&
&
!
map
.
add
(
ptr
target
WeakRefHeapPtrVector
(
target
-
>
zone
(
)
)
)
)
{
return
false
;
}
auto
&
refs
=
ptr
-
>
value
(
)
;
return
refs
.
emplaceBack
(
weakRef
)
;
}
bool
GCRuntime
:
:
unregisterWeakRefWrapper
(
JSObject
*
wrapper
)
{
WeakRefObject
*
weakRef
=
&
UncheckedUnwrapWithoutExpose
(
wrapper
)
-
>
as
<
WeakRefObject
>
(
)
;
JSObject
*
target
=
weakRef
-
>
target
(
)
;
MOZ_ASSERT
(
target
)
;
bool
removed
=
false
;
auto
&
map
=
target
-
>
zone
(
)
-
>
weakRefMap
(
)
;
if
(
auto
ptr
=
map
.
lookup
(
target
)
)
{
ptr
-
>
value
(
)
.
eraseIf
(
[
wrapper
&
removed
]
(
JSObject
*
obj
)
{
bool
remove
=
obj
=
=
wrapper
;
if
(
remove
)
{
removed
=
true
;
}
return
remove
;
}
)
;
}
return
removed
;
}
void
GCRuntime
:
:
traceKeptObjects
(
JSTracer
*
trc
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
traceKeptObjects
(
trc
)
;
}
}
}
static
WeakRefObject
*
UnwrapWeakRef
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
JS_IsDeadWrapper
(
obj
)
)
;
obj
=
UncheckedUnwrapWithoutExpose
(
obj
)
;
return
&
obj
-
>
as
<
WeakRefObject
>
(
)
;
}
void
WeakRefMap
:
:
traceWeak
(
JSTracer
*
trc
gc
:
:
StoreBuffer
*
sbToLock
)
{
mozilla
:
:
Maybe
<
Enum
>
e
;
for
(
e
.
emplace
(
*
this
)
;
!
e
-
>
empty
(
)
;
e
-
>
popFront
(
)
)
{
auto
result
=
TraceWeakEdge
(
trc
&
e
-
>
front
(
)
.
mutableKey
(
)
"
WeakRef
target
"
)
;
if
(
result
.
isDead
(
)
)
{
for
(
JSObject
*
obj
:
e
-
>
front
(
)
.
value
(
)
)
{
UnwrapWeakRef
(
obj
)
-
>
clearTarget
(
)
;
}
e
-
>
removeFront
(
)
;
}
else
{
e
-
>
front
(
)
.
value
(
)
.
traceWeak
(
trc
result
.
finalTarget
(
)
)
;
}
}
gc
:
:
AutoLockStoreBuffer
lock
(
sbToLock
)
;
e
.
reset
(
)
;
}
void
WeakRefHeapPtrVector
:
:
traceWeak
(
JSTracer
*
trc
JSObject
*
target
)
{
mutableEraseIf
(
[
&
]
(
HeapPtrObject
&
obj
)
-
>
bool
{
auto
result
=
TraceWeakEdge
(
trc
&
obj
"
WeakRef
"
)
;
if
(
result
.
isDead
(
)
)
{
UnwrapWeakRef
(
result
.
initialTarget
(
)
)
-
>
clearTarget
(
)
;
}
else
{
UnwrapWeakRef
(
result
.
finalTarget
(
)
)
-
>
setTargetUnbarriered
(
target
)
;
}
return
result
.
isDead
(
)
;
}
)
;
}
}
