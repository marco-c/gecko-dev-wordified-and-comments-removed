var
PromiseReactionRecordProto
=
{
__proto__
:
null
}
;
function
PromiseReactionRecord
(
promise
resolve
reject
fulfillHandler
rejectHandler
incumbentGlobal
)
{
this
.
promise
=
promise
;
this
.
resolve
=
resolve
;
this
.
reject
=
reject
;
this
.
fulfillHandler
=
fulfillHandler
;
this
.
rejectHandler
=
rejectHandler
;
this
.
incumbentGlobal
=
incumbentGlobal
;
}
MakeConstructible
(
PromiseReactionRecord
PromiseReactionRecordProto
)
;
var
PromiseCapabilityRecordProto
=
{
__proto__
:
null
}
;
function
NewPromiseCapability
(
C
)
{
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
0
)
;
let
resolve
;
let
reject
;
function
GetCapabilitiesExecutor
(
resolve_
reject_
)
{
if
(
resolve
!
=
=
undefined
|
|
reject
!
=
=
undefined
)
ThrowTypeError
(
JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY
)
;
resolve
=
resolve_
;
reject
=
reject_
;
}
let
promise
=
new
C
(
GetCapabilitiesExecutor
)
;
if
(
!
IsCallable
(
resolve
)
)
ThrowTypeError
(
JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE
)
;
if
(
!
IsCallable
(
reject
)
)
ThrowTypeError
(
JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE
)
;
return
{
__proto__
:
PromiseCapabilityRecordProto
promise
resolve
reject
}
;
}
function
EnqueuePromiseReactionJob
(
reaction
jobType
argument
)
{
assert
(
jobType
=
=
=
PROMISE_JOB_TYPE_FULFILL
|
|
jobType
=
=
=
PROMISE_JOB_TYPE_REJECT
"
Invalid
job
type
"
)
;
_EnqueuePromiseReactionJob
(
reaction
[
jobType
]
argument
reaction
.
resolve
reaction
.
reject
reaction
.
promise
reaction
.
incumbentGlobal
|
|
null
)
;
}
function
Promise_static_all
(
iterable
)
{
let
C
=
this
;
if
(
!
IsObject
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
all
call
"
)
;
let
promiseCapability
=
NewPromiseCapability
(
C
)
;
let
iterator
;
try
{
iterator
=
GetIterator
(
iterable
)
;
}
catch
(
e
)
{
callContentFunction
(
promiseCapability
.
reject
undefined
e
)
;
return
promiseCapability
.
promise
;
}
let
iteratorRecord
=
{
__proto__
:
null
iterator
done
:
false
}
;
try
{
return
PerformPromiseAll
(
iteratorRecord
C
promiseCapability
)
;
}
catch
(
e
)
{
callContentFunction
(
promiseCapability
.
reject
undefined
e
)
;
return
promiseCapability
.
promise
;
}
}
function
PerformPromiseAll
(
iteratorRecord
constructor
resultCapability
)
{
assert
(
IsConstructor
(
constructor
)
"
PerformPromiseAll
called
with
non
-
constructor
"
)
;
assert
(
IsPromiseCapability
(
resultCapability
)
"
Invalid
promise
capability
record
"
)
;
let
values
=
IsPromise
(
resultCapability
.
promise
)
|
|
!
IsWrappedPromise
(
resultCapability
.
promise
)
?
[
]
:
NewArrayInCompartment
(
constructor
)
;
let
valuesCount
=
0
;
let
remainingElementsCount
=
{
value
:
1
}
;
let
index
=
0
;
let
iterator
=
iteratorRecord
.
iterator
;
let
next
;
let
nextValue
;
let
allPromise
=
resultCapability
.
promise
;
while
(
true
)
{
try
{
next
=
callContentFunction
(
iterator
.
next
iterator
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_NEXT_RETURNED_PRIMITIVE
)
;
}
catch
(
e
)
{
iteratorRecord
.
done
=
true
;
throw
(
e
)
;
}
if
(
next
.
done
)
{
iteratorRecord
.
done
=
true
;
remainingElementsCount
.
value
-
-
;
assert
(
remainingElementsCount
.
value
>
=
0
"
remainingElementsCount
mustn
'
t
be
negative
.
"
)
;
if
(
remainingElementsCount
.
value
=
=
=
0
)
callContentFunction
(
resultCapability
.
resolve
undefined
values
)
;
return
allPromise
;
}
try
{
nextValue
=
next
.
value
;
}
catch
(
e
)
{
iteratorRecord
.
done
=
true
;
throw
e
;
}
_DefineDataProperty
(
values
valuesCount
+
+
undefined
)
;
let
nextPromise
=
callContentFunction
(
constructor
.
resolve
constructor
nextValue
)
;
let
resolveElement
=
CreatePromiseAllResolveElementFunction
(
index
values
resultCapability
remainingElementsCount
)
;
remainingElementsCount
.
value
+
+
;
BlockOnPromise
(
nextPromise
allPromise
resolveElement
resultCapability
.
reject
)
;
index
+
+
;
}
}
function
GetWaitForAllPromise
(
promises
)
{
let
resultCapability
=
NewPromiseCapability
(
GetBuiltinConstructor
(
'
Promise
'
)
)
;
let
allPromise
=
resultCapability
.
promise
;
let
values
=
[
]
;
let
valuesCount
=
0
;
let
remainingElementsCount
=
{
value
:
0
}
;
for
(
let
i
=
0
;
i
<
promises
.
length
;
i
+
+
)
{
assert
(
callFunction
(
std_Object_hasOwnProperty
promises
i
)
"
GetWaitForAllPromise
must
be
called
with
a
dense
array
of
promises
"
)
;
let
nextPromise
=
promises
[
i
]
;
assert
(
IsPromise
(
nextPromise
)
|
|
IsWrappedPromise
(
nextPromise
)
"
promises
list
must
only
contain
possibly
wrapped
promises
"
)
;
_DefineDataProperty
(
values
valuesCount
+
+
undefined
)
;
let
resolveElement
=
CreatePromiseAllResolveElementFunction
(
i
values
resultCapability
remainingElementsCount
)
;
remainingElementsCount
.
value
+
+
;
EnqueuePromiseReactions
(
nextPromise
allPromise
resolveElement
resultCapability
.
reject
)
;
}
if
(
remainingElementsCount
.
value
=
=
=
0
)
callFunction
(
resultCapability
.
resolve
undefined
values
)
;
return
allPromise
;
}
function
CreatePromiseAllResolveElementFunction
(
index
values
promiseCapability
remainingElementsCount
)
{
var
alreadyCalled
=
false
;
return
function
PromiseAllResolveElementFunction
(
x
)
{
if
(
alreadyCalled
)
return
undefined
;
alreadyCalled
=
true
;
values
[
index
]
=
x
;
remainingElementsCount
.
value
-
-
;
assert
(
remainingElementsCount
.
value
>
=
0
"
remainingElementsCount
mustn
'
t
be
negative
.
"
)
;
if
(
remainingElementsCount
.
value
=
=
=
0
)
{
return
callContentFunction
(
promiseCapability
.
resolve
undefined
values
)
;
}
}
;
}
function
Promise_static_race
(
iterable
)
{
let
C
=
this
;
if
(
!
IsObject
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
race
call
"
)
;
let
promiseCapability
=
NewPromiseCapability
(
C
)
;
let
iterator
;
try
{
iterator
=
GetIterator
(
iterable
)
;
}
catch
(
e
)
{
callContentFunction
(
promiseCapability
.
reject
undefined
e
)
;
return
promiseCapability
.
promise
;
}
let
iteratorRecord
=
{
__proto__
:
null
iterator
done
:
false
}
;
try
{
return
PerformPromiseRace
(
iteratorRecord
promiseCapability
C
)
;
}
catch
(
e
)
{
callContentFunction
(
promiseCapability
.
reject
undefined
e
)
;
return
promiseCapability
.
promise
;
}
}
function
PerformPromiseRace
(
iteratorRecord
resultCapability
C
)
{
assert
(
IsConstructor
(
C
)
"
PerformPromiseRace
called
with
non
-
constructor
"
)
;
assert
(
IsPromiseCapability
(
resultCapability
)
"
Invalid
promise
capability
record
"
)
;
let
iterator
=
iteratorRecord
.
iterator
;
let
racePromise
=
resultCapability
.
promise
;
let
next
;
let
nextValue
;
while
(
true
)
{
try
{
next
=
callContentFunction
(
iterator
.
next
iterator
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_NEXT_RETURNED_PRIMITIVE
)
;
}
catch
(
e
)
{
iteratorRecord
.
done
=
true
;
throw
(
e
)
;
}
if
(
next
.
done
)
{
iteratorRecord
.
done
=
true
;
return
racePromise
;
}
try
{
nextValue
=
next
.
value
;
}
catch
(
e
)
{
iteratorRecord
.
done
=
true
;
throw
e
;
}
let
nextPromise
=
callContentFunction
(
C
.
resolve
C
nextValue
)
;
BlockOnPromise
(
nextPromise
racePromise
resultCapability
.
resolve
resultCapability
.
reject
)
;
}
assert
(
false
"
Shouldn
'
t
reach
the
end
of
PerformPromiseRace
"
)
;
}
function
BlockOnPromise
(
promise
blockedPromise
onResolve
onReject
)
{
let
then
=
promise
.
then
;
let
addToDependent
=
true
;
if
(
then
=
=
=
Promise_then
&
&
IsObject
(
promise
)
&
&
IsPromise
(
promise
)
)
{
let
PromiseCtor
=
GetBuiltinConstructor
(
'
Promise
'
)
;
let
C
=
SpeciesConstructor
(
promise
PromiseCtor
)
;
let
resultCapability
;
if
(
C
=
=
=
PromiseCtor
)
{
resultCapability
=
{
__proto__
:
PromiseCapabilityRecordProto
promise
:
blockedPromise
reject
:
NullFunction
resolve
:
NullFunction
}
;
addToDependent
=
false
;
}
else
{
resultCapability
=
NewPromiseCapability
(
C
)
;
}
PerformPromiseThen
(
promise
onResolve
onReject
resultCapability
)
;
}
else
{
callContentFunction
(
then
promise
onResolve
onReject
)
;
}
if
(
!
addToDependent
)
return
;
if
(
IsPromise
(
promise
)
)
return
callFunction
(
AddDependentPromise
promise
blockedPromise
)
;
if
(
IsWrappedPromise
(
promise
)
)
callFunction
(
CallPromiseMethodIfWrapped
promise
blockedPromise
"
AddDependentPromise
"
)
;
}
function
AddDependentPromise
(
dependentPromise
)
{
assert
(
IsPromise
(
this
)
"
AddDependentPromise
expects
an
unwrapped
Promise
as
the
receiver
"
)
;
if
(
GetPromiseState
(
this
)
!
=
=
PROMISE_STATE_PENDING
)
return
;
let
reaction
=
new
PromiseReactionRecord
(
dependentPromise
NullFunction
NullFunction
NullFunction
NullFunction
null
)
;
let
reactions
=
UnsafeGetReservedSlot
(
this
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
if
(
!
reactions
)
UnsafeSetReservedSlot
(
dependentPromise
PROMISE_REACTIONS_OR_RESULT_SLOT
[
reaction
]
)
;
else
_DefineDataProperty
(
reactions
reactions
.
length
reaction
)
;
}
function
Promise_static_get_species
(
)
{
return
this
;
}
_SetCanonicalName
(
Promise_static_get_species
"
get
[
Symbol
.
species
]
"
)
;
function
Promise_catch
(
onRejected
)
{
return
callContentFunction
(
this
.
then
this
undefined
onRejected
)
;
}
function
Promise_then
(
onFulfilled
onRejected
)
{
let
promise
=
this
;
if
(
!
IsObject
(
promise
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
prototype
.
then
call
"
)
;
let
isPromise
=
IsPromise
(
promise
)
;
let
isWrappedPromise
=
isPromise
?
false
:
IsWrappedPromise
(
promise
)
;
if
(
!
(
isPromise
|
|
isWrappedPromise
)
)
ThrowTypeError
(
JSMSG_INCOMPATIBLE_PROTO
"
Promise
"
"
then
"
"
value
"
)
;
let
C
=
SpeciesConstructor
(
promise
GetBuiltinConstructor
(
'
Promise
'
)
)
;
let
resultCapability
=
NewPromiseCapability
(
C
)
;
if
(
isWrappedPromise
)
{
let
handlerForwarders
=
GetPromiseHandlerForwarders
(
onFulfilled
onRejected
)
;
return
callFunction
(
CallPromiseMethodIfWrapped
promise
handlerForwarders
[
0
]
handlerForwarders
[
1
]
resultCapability
.
promise
resultCapability
.
resolve
resultCapability
.
reject
"
UnwrappedPerformPromiseThen
"
)
;
}
return
PerformPromiseThen
(
promise
onFulfilled
onRejected
resultCapability
)
;
}
function
EnqueuePromiseReactions
(
promise
dependentPromise
onFulfilled
onRejected
)
{
let
isWrappedPromise
=
false
;
if
(
!
IsPromise
(
promise
)
)
{
assert
(
IsWrappedPromise
(
promise
)
"
EnqueuePromiseReactions
must
be
provided
with
a
possibly
wrapped
promise
"
)
;
isWrappedPromise
=
true
;
}
assert
(
dependentPromise
=
=
=
null
|
|
IsPromise
(
dependentPromise
)
"
EnqueuePromiseReactions
'
s
dependentPromise
argument
must
be
a
Promise
or
null
"
)
;
if
(
isWrappedPromise
)
{
let
handlerForwarders
=
GetPromiseHandlerForwarders
(
onFulfilled
onRejected
)
;
return
callFunction
(
CallPromiseMethodIfWrapped
promise
handlerForwarders
[
0
]
handlerForwarders
[
1
]
dependentPromise
NullFunction
NullFunction
"
UnwrappedPerformPromiseThen
"
)
;
}
let
capability
=
{
__proto__
:
PromiseCapabilityRecordProto
promise
:
dependentPromise
resolve
:
NullFunction
reject
:
NullFunction
}
;
return
PerformPromiseThen
(
promise
onFulfilled
onRejected
capability
)
;
}
function
GetPromiseHandlerForwarders
(
fulfilledHandler
rejectedHandler
)
{
return
[
IsCallable
(
fulfilledHandler
)
?
function
onFulfilled
(
argument
)
{
return
callContentFunction
(
fulfilledHandler
this
argument
)
;
}
:
fulfilledHandler
IsCallable
(
rejectedHandler
)
?
function
onRejected
(
argument
)
{
return
callContentFunction
(
rejectedHandler
this
argument
)
;
}
:
rejectedHandler
]
;
}
function
UnwrappedPerformPromiseThen
(
fulfilledHandler
rejectedHandler
promise
resolve
reject
)
{
let
resultCapability
=
{
__proto__
:
PromiseCapabilityRecordProto
promise
resolve
(
resolution
)
{
if
(
IsFunctionObject
(
resolve
)
)
return
resolve
(
resolution
)
;
return
UnsafeCallWrappedFunction
(
resolve
undefined
resolution
)
;
}
reject
(
reason
)
{
if
(
IsFunctionObject
(
reject
)
)
return
reject
(
reason
)
;
return
UnsafeCallWrappedFunction
(
reject
undefined
reason
)
;
}
}
;
function
onFulfilled
(
argument
)
{
return
UnsafeCallWrappedFunction
(
fulfilledHandler
undefined
argument
)
;
}
function
onRejected
(
argument
)
{
return
UnsafeCallWrappedFunction
(
rejectedHandler
undefined
argument
)
;
}
return
PerformPromiseThen
(
this
IsCallable
(
fulfilledHandler
)
?
onFulfilled
:
fulfilledHandler
IsCallable
(
rejectedHandler
)
?
onRejected
:
rejectedHandler
resultCapability
)
;
}
function
PerformPromiseThen
(
promise
onFulfilled
onRejected
resultCapability
)
{
assert
(
IsPromise
(
promise
)
"
Can
'
t
call
PerformPromiseThen
on
non
-
Promise
objects
"
)
;
assert
(
IsPromiseCapability
(
resultCapability
)
"
Invalid
promise
capability
record
"
)
;
if
(
!
IsCallable
(
onFulfilled
)
)
onFulfilled
=
PROMISE_HANDLER_IDENTITY
;
if
(
!
IsCallable
(
onRejected
)
)
onRejected
=
PROMISE_HANDLER_THROWER
;
let
incumbentGlobal
=
_GetObjectFromIncumbentGlobal
(
)
;
let
reaction
=
new
PromiseReactionRecord
(
resultCapability
.
promise
resultCapability
.
resolve
resultCapability
.
reject
onFulfilled
onRejected
incumbentGlobal
)
;
let
state
=
GetPromiseState
(
promise
)
;
let
flags
=
UnsafeGetInt32FromReservedSlot
(
promise
PROMISE_FLAGS_SLOT
)
;
if
(
state
=
=
=
PROMISE_STATE_PENDING
)
{
let
reactions
=
UnsafeGetReservedSlot
(
promise
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
if
(
!
reactions
)
UnsafeSetReservedSlot
(
promise
PROMISE_REACTIONS_OR_RESULT_SLOT
[
reaction
]
)
;
else
_DefineDataProperty
(
reactions
reactions
.
length
reaction
)
;
}
else
if
(
state
=
=
=
PROMISE_STATE_FULFILLED
)
{
let
value
=
UnsafeGetReservedSlot
(
promise
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
EnqueuePromiseReactionJob
(
reaction
PROMISE_JOB_TYPE_FULFILL
value
)
;
}
else
{
assert
(
state
=
=
=
PROMISE_STATE_REJECTED
"
Invalid
Promise
state
"
+
state
)
;
let
reason
=
UnsafeGetReservedSlot
(
promise
PROMISE_REACTIONS_OR_RESULT_SLOT
)
;
if
(
!
(
flags
&
PROMISE_FLAG_HANDLED
)
)
HostPromiseRejectionTracker
(
promise
PROMISE_REJECTION_TRACKER_OPERATION_HANDLE
)
;
EnqueuePromiseReactionJob
(
reaction
PROMISE_JOB_TYPE_REJECT
reason
)
;
}
UnsafeSetReservedSlot
(
promise
PROMISE_FLAGS_SLOT
flags
|
PROMISE_FLAG_HANDLED
)
;
return
resultCapability
.
promise
;
}
function
IsPromiseReaction
(
record
)
{
return
std_Reflect_getPrototypeOf
(
record
)
=
=
=
PromiseReactionRecordProto
;
}
function
IsPromiseCapability
(
capability
)
{
return
std_Reflect_getPrototypeOf
(
capability
)
=
=
=
PromiseCapabilityRecordProto
;
}
function
GetPromiseState
(
promise
)
{
let
flags
=
UnsafeGetInt32FromReservedSlot
(
promise
PROMISE_FLAGS_SLOT
)
;
if
(
!
(
flags
&
PROMISE_FLAG_RESOLVED
)
)
{
assert
(
!
(
flags
&
PROMISE_STATE_FULFILLED
)
"
Fulfilled
promises
are
resolved
too
"
)
;
return
PROMISE_STATE_PENDING
;
}
if
(
flags
&
PROMISE_FLAG_FULFILLED
)
return
PROMISE_STATE_FULFILLED
;
return
PROMISE_STATE_REJECTED
;
}
