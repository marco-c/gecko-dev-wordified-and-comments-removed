#
include
"
builtin
/
Promise
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsiter
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
vm
/
AsyncFunction
.
h
"
#
include
"
vm
/
AsyncIteration
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
Debugger
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
double
MillisecondsSinceStartup
(
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
return
(
now
-
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
}
enum
PromiseHandler
{
PromiseHandlerIdentity
=
0
PromiseHandlerThrower
PromiseHandlerAsyncFunctionAwaitedFulfilled
PromiseHandlerAsyncFunctionAwaitedRejected
PromiseHandlerAsyncGeneratorAwaitedFulfilled
PromiseHandlerAsyncGeneratorAwaitedRejected
PromiseHandlerAsyncGeneratorResumeNextReturnFulfilled
PromiseHandlerAsyncGeneratorResumeNextReturnRejected
PromiseHandlerAsyncGeneratorYieldReturnAwaitedFulfilled
PromiseHandlerAsyncGeneratorYieldReturnAwaitedRejected
PromiseHandlerAsyncFromSyncIteratorValueUnwrapDone
PromiseHandlerAsyncFromSyncIteratorValueUnwrapNotDone
}
;
enum
ResolutionMode
{
ResolveMode
RejectMode
}
;
enum
ResolveFunctionSlots
{
ResolveFunctionSlot_Promise
=
0
ResolveFunctionSlot_RejectFunction
}
;
enum
RejectFunctionSlots
{
RejectFunctionSlot_Promise
=
0
RejectFunctionSlot_ResolveFunction
}
;
enum
PromiseAllResolveElementFunctionSlots
{
PromiseAllResolveElementFunctionSlot_Data
=
0
PromiseAllResolveElementFunctionSlot_ElementIndex
}
;
enum
ReactionJobSlots
{
ReactionJobSlot_ReactionRecord
=
0
}
;
enum
ThenableJobSlots
{
ThenableJobSlot_Handler
=
0
ThenableJobSlot_JobData
}
;
enum
ThenableJobDataIndices
{
ThenableJobDataIndex_Promise
=
0
ThenableJobDataIndex_Thenable
ThenableJobDataLength
}
;
enum
PromiseAllDataHolderSlots
{
PromiseAllDataHolderSlot_Promise
=
0
PromiseAllDataHolderSlot_RemainingElements
PromiseAllDataHolderSlot_ValuesArray
PromiseAllDataHolderSlot_ResolveFunction
PromiseAllDataHolderSlots
}
;
class
PromiseAllDataHolder
:
public
NativeObject
{
public
:
static
const
Class
class_
;
JSObject
*
promiseObj
(
)
{
return
&
getFixedSlot
(
PromiseAllDataHolderSlot_Promise
)
.
toObject
(
)
;
}
JSObject
*
resolveObj
(
)
{
return
&
getFixedSlot
(
PromiseAllDataHolderSlot_ResolveFunction
)
.
toObject
(
)
;
}
Value
valuesArray
(
)
{
return
getFixedSlot
(
PromiseAllDataHolderSlot_ValuesArray
)
;
}
int32_t
remainingCount
(
)
{
return
getFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
)
.
toInt32
(
)
;
}
int32_t
increaseRemainingCount
(
)
{
int32_t
remainingCount
=
getFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
)
.
toInt32
(
)
;
remainingCount
+
+
;
setFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
Int32Value
(
remainingCount
)
)
;
return
remainingCount
;
}
int32_t
decreaseRemainingCount
(
)
{
int32_t
remainingCount
=
getFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
)
.
toInt32
(
)
;
remainingCount
-
-
;
setFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
Int32Value
(
remainingCount
)
)
;
return
remainingCount
;
}
}
;
const
Class
PromiseAllDataHolder
:
:
class_
=
{
"
PromiseAllDataHolder
"
JSCLASS_HAS_RESERVED_SLOTS
(
PromiseAllDataHolderSlots
)
}
;
static
PromiseAllDataHolder
*
NewPromiseAllDataHolder
(
JSContext
*
cx
HandleObject
resultPromise
HandleValue
valuesArray
HandleObject
resolve
)
{
Rooted
<
PromiseAllDataHolder
*
>
dataHolder
(
cx
NewObjectWithClassProto
<
PromiseAllDataHolder
>
(
cx
)
)
;
if
(
!
dataHolder
)
return
nullptr
;
assertSameCompartment
(
cx
resultPromise
)
;
assertSameCompartment
(
cx
valuesArray
)
;
assertSameCompartment
(
cx
resolve
)
;
dataHolder
-
>
setFixedSlot
(
PromiseAllDataHolderSlot_Promise
ObjectValue
(
*
resultPromise
)
)
;
dataHolder
-
>
setFixedSlot
(
PromiseAllDataHolderSlot_RemainingElements
Int32Value
(
1
)
)
;
dataHolder
-
>
setFixedSlot
(
PromiseAllDataHolderSlot_ValuesArray
valuesArray
)
;
dataHolder
-
>
setFixedSlot
(
PromiseAllDataHolderSlot_ResolveFunction
ObjectValue
(
*
resolve
)
)
;
return
dataHolder
;
}
namespace
{
mozilla
:
:
Atomic
<
uint64_t
>
gIDGenerator
(
0
)
;
}
static
MOZ_ALWAYS_INLINE
bool
ShouldCaptureDebugInfo
(
JSContext
*
cx
)
{
return
cx
-
>
options
(
)
.
asyncStack
(
)
|
|
cx
-
>
compartment
(
)
-
>
isDebuggee
(
)
;
}
class
PromiseDebugInfo
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_AllocationSite
Slot_ResolutionSite
Slot_AllocationTime
Slot_ResolutionTime
Slot_Id
SlotCount
}
;
public
:
static
const
Class
class_
;
static
PromiseDebugInfo
*
create
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
Rooted
<
PromiseDebugInfo
*
>
debugInfo
(
cx
NewObjectWithClassProto
<
PromiseDebugInfo
>
(
cx
)
)
;
if
(
!
debugInfo
)
return
nullptr
;
RootedObject
stack
(
cx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
return
nullptr
;
debugInfo
-
>
setFixedSlot
(
Slot_AllocationSite
ObjectOrNullValue
(
stack
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
NullValue
(
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_AllocationTime
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
NumberValue
(
0
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_DebugInfo
ObjectValue
(
*
debugInfo
)
)
;
return
debugInfo
;
}
static
PromiseDebugInfo
*
FromPromise
(
PromiseObject
*
promise
)
{
Value
val
=
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
;
if
(
val
.
isObject
(
)
)
return
&
val
.
toObject
(
)
.
as
<
PromiseDebugInfo
>
(
)
;
return
nullptr
;
}
static
uint64_t
id
(
PromiseObject
*
promise
)
{
Value
idVal
(
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
)
;
if
(
idVal
.
isUndefined
(
)
)
{
idVal
.
setDouble
(
+
+
gIDGenerator
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_DebugInfo
idVal
)
;
}
else
if
(
idVal
.
isObject
(
)
)
{
PromiseDebugInfo
*
debugInfo
=
FromPromise
(
promise
)
;
idVal
=
debugInfo
-
>
getFixedSlot
(
Slot_Id
)
;
if
(
idVal
.
isUndefined
(
)
)
{
idVal
.
setDouble
(
+
+
gIDGenerator
)
;
debugInfo
-
>
setFixedSlot
(
Slot_Id
idVal
)
;
}
}
return
uint64_t
(
idVal
.
toNumber
(
)
)
;
}
double
allocationTime
(
)
{
return
getFixedSlot
(
Slot_AllocationTime
)
.
toNumber
(
)
;
}
double
resolutionTime
(
)
{
return
getFixedSlot
(
Slot_ResolutionTime
)
.
toNumber
(
)
;
}
JSObject
*
allocationSite
(
)
{
return
getFixedSlot
(
Slot_AllocationSite
)
.
toObjectOrNull
(
)
;
}
JSObject
*
resolutionSite
(
)
{
return
getFixedSlot
(
Slot_ResolutionSite
)
.
toObjectOrNull
(
)
;
}
static
void
setResolutionInfo
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
if
(
!
ShouldCaptureDebugInfo
(
cx
)
)
return
;
Rooted
<
PromiseDebugInfo
*
>
debugInfo
(
cx
FromPromise
(
promise
)
)
;
if
(
!
debugInfo
)
{
RootedValue
idVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
)
;
debugInfo
=
create
(
cx
promise
)
;
if
(
!
debugInfo
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
debugInfo
-
>
getFixedSlot
(
Slot_AllocationSite
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_AllocationSite
NullValue
(
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
debugInfo
-
>
getFixedSlot
(
Slot_AllocationTime
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_Id
idVal
)
;
return
;
}
RootedObject
stack
(
cx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
ObjectOrNullValue
(
stack
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
}
}
;
const
Class
PromiseDebugInfo
:
:
class_
=
{
"
PromiseDebugInfo
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
double
PromiseObject
:
:
allocationTime
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
return
debugInfo
-
>
allocationTime
(
)
;
return
0
;
}
double
PromiseObject
:
:
resolutionTime
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
return
debugInfo
-
>
resolutionTime
(
)
;
return
0
;
}
JSObject
*
PromiseObject
:
:
allocationSite
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
return
debugInfo
-
>
allocationSite
(
)
;
return
nullptr
;
}
JSObject
*
PromiseObject
:
:
resolutionSite
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
return
debugInfo
-
>
resolutionSite
(
)
;
return
nullptr
;
}
static
bool
MaybeGetAndClearException
(
JSContext
*
cx
MutableHandleValue
rval
)
{
if
(
!
cx
-
>
isExceptionPending
(
)
)
return
false
;
return
GetAndClearException
(
cx
rval
)
;
}
static
MOZ_MUST_USE
bool
RunResolutionFunction
(
JSContext
*
cx
HandleObject
resolutionFun
HandleValue
result
ResolutionMode
mode
HandleObject
promiseObj
)
;
static
bool
AbruptRejectPromise
(
JSContext
*
cx
CallArgs
&
args
HandleObject
promiseObj
HandleObject
reject
)
{
RootedValue
reason
(
cx
)
;
if
(
!
MaybeGetAndClearException
(
cx
&
reason
)
)
return
false
;
if
(
!
RunResolutionFunction
(
cx
reject
reason
RejectMode
promiseObj
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
promiseObj
)
;
return
true
;
}
enum
ReactionRecordSlots
{
ReactionRecordSlot_Promise
=
0
ReactionRecordSlot_OnFulfilled
ReactionRecordSlot_OnRejected
ReactionRecordSlot_Resolve
ReactionRecordSlot_Reject
ReactionRecordSlot_IncumbentGlobalObject
ReactionRecordSlot_Flags
ReactionRecordSlot_HandlerArg
ReactionRecordSlot_Generator
ReactionRecordSlots
}
;
#
define
REACTION_FLAG_RESOLVED
0x1
#
define
REACTION_FLAG_FULFILLED
0x2
#
define
REACTION_FLAG_IGNORE_DEFAULT_RESOLUTION
0x4
#
define
REACTION_FLAG_ASYNC_FUNCTION
0x8
#
define
REACTION_FLAG_ASYNC_GENERATOR
0x10
class
PromiseReactionRecord
:
public
NativeObject
{
public
:
static
const
Class
class_
;
JSObject
*
promise
(
)
{
return
getFixedSlot
(
ReactionRecordSlot_Promise
)
.
toObjectOrNull
(
)
;
}
int32_t
flags
(
)
{
return
getFixedSlot
(
ReactionRecordSlot_Flags
)
.
toInt32
(
)
;
}
JS
:
:
PromiseState
targetState
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
if
(
!
(
flags
&
REACTION_FLAG_RESOLVED
)
)
return
JS
:
:
PromiseState
:
:
Pending
;
return
flags
&
REACTION_FLAG_FULFILLED
?
JS
:
:
PromiseState
:
:
Fulfilled
:
JS
:
:
PromiseState
:
:
Rejected
;
}
void
setTargetState
(
JS
:
:
PromiseState
state
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
MOZ_ASSERT
(
!
(
flags
&
REACTION_FLAG_RESOLVED
)
)
;
MOZ_ASSERT
(
state
!
=
JS
:
:
PromiseState
:
:
Pending
"
Can
'
t
revert
a
reaction
to
pending
.
"
)
;
flags
|
=
REACTION_FLAG_RESOLVED
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
flags
|
=
REACTION_FLAG_FULFILLED
;
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
flags
)
)
;
}
void
setIsAsyncFunction
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
flags
|
=
REACTION_FLAG_ASYNC_FUNCTION
;
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
flags
)
)
;
}
bool
isAsyncFunction
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_ASYNC_FUNCTION
;
}
void
setIsAsyncGenerator
(
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
flags
|
=
REACTION_FLAG_ASYNC_GENERATOR
;
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
flags
)
)
;
setFixedSlot
(
ReactionRecordSlot_Generator
ObjectValue
(
*
asyncGenObj
)
)
;
}
bool
isAsyncGenerator
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_ASYNC_GENERATOR
;
}
AsyncGeneratorObject
*
asyncGenerator
(
)
{
MOZ_ASSERT
(
isAsyncGenerator
(
)
)
;
return
&
getFixedSlot
(
ReactionRecordSlot_Generator
)
.
toObject
(
)
.
as
<
AsyncGeneratorObject
>
(
)
;
}
Value
handler
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
uint32_t
slot
=
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
?
ReactionRecordSlot_OnFulfilled
:
ReactionRecordSlot_OnRejected
;
return
getFixedSlot
(
slot
)
;
}
Value
handlerArg
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
getFixedSlot
(
ReactionRecordSlot_HandlerArg
)
;
}
void
setHandlerArg
(
Value
&
arg
)
{
MOZ_ASSERT
(
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
setFixedSlot
(
ReactionRecordSlot_HandlerArg
arg
)
;
}
JSObject
*
incumbentGlobalObject
(
)
{
return
getFixedSlot
(
ReactionRecordSlot_IncumbentGlobalObject
)
.
toObjectOrNull
(
)
;
}
}
;
const
Class
PromiseReactionRecord
:
:
class_
=
{
"
PromiseReactionRecord
"
JSCLASS_HAS_RESERVED_SLOTS
(
ReactionRecordSlots
)
}
;
static
void
AddPromiseFlags
(
PromiseObject
&
promise
int32_t
flag
)
{
int32_t
flags
=
promise
.
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
promise
.
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
|
flag
)
)
;
}
static
bool
PromiseHasAnyFlag
(
PromiseObject
&
promise
int32_t
flag
)
{
return
promise
.
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
&
flag
;
}
static
bool
ResolvePromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
RejectPromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
MOZ_MUST_USE
bool
CreateResolvingFunctions
(
JSContext
*
cx
HandleObject
promise
MutableHandleObject
resolveFn
MutableHandleObject
rejectFn
)
{
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
resolve
(
cx
NewNativeFunction
(
cx
ResolvePromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
resolve
)
return
false
;
RootedFunction
reject
(
cx
NewNativeFunction
(
cx
RejectPromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
reject
)
return
false
;
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_Promise
ObjectValue
(
*
promise
)
)
;
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_RejectFunction
ObjectValue
(
*
reject
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_Promise
ObjectValue
(
*
promise
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_ResolveFunction
ObjectValue
(
*
resolve
)
)
;
resolveFn
.
set
(
resolve
)
;
rejectFn
.
set
(
reject
)
;
return
true
;
}
static
void
ClearResolutionFunctionSlots
(
JSFunction
*
resolutionFun
)
;
static
MOZ_MUST_USE
bool
RejectMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
reason
)
;
static
bool
RejectPromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
reject
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
reasonVal
(
cx
args
.
get
(
0
)
)
;
RootedValue
promiseVal
(
cx
reject
-
>
getExtendedSlot
(
RejectFunctionSlot_Promise
)
)
;
if
(
promiseVal
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
ClearResolutionFunctionSlots
(
reject
)
;
RootedObject
promise
(
cx
&
promiseVal
.
toObject
(
)
)
;
if
(
promise
-
>
is
<
PromiseObject
>
(
)
&
&
promise
-
>
as
<
PromiseObject
>
(
)
.
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
if
(
!
RejectMaybeWrappedPromise
(
cx
promise
reasonVal
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
FulfillMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
value_
)
;
static
MOZ_MUST_USE
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve
HandleValue
thenable
HandleValue
thenVal
)
;
static
MOZ_MUST_USE
bool
ResolvePromiseInternal
(
JSContext
*
cx
HandleObject
promise
HandleValue
resolutionVal
)
{
if
(
!
resolutionVal
.
isObject
(
)
)
return
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
RootedObject
resolution
(
cx
&
resolutionVal
.
toObject
(
)
)
;
if
(
resolution
=
=
promise
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF
)
;
RootedValue
selfResolutionError
(
cx
)
;
if
(
!
MaybeGetAndClearException
(
cx
&
selfResolutionError
)
)
return
false
;
return
RejectMaybeWrappedPromise
(
cx
promise
selfResolutionError
)
;
}
RootedValue
thenVal
(
cx
)
;
bool
status
=
GetProperty
(
cx
resolution
resolution
cx
-
>
names
(
)
.
then
&
thenVal
)
;
if
(
!
status
)
{
RootedValue
error
(
cx
)
;
if
(
!
MaybeGetAndClearException
(
cx
&
error
)
)
return
false
;
return
RejectMaybeWrappedPromise
(
cx
promise
error
)
;
}
if
(
!
IsCallable
(
thenVal
)
)
return
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
RootedValue
promiseVal
(
cx
ObjectValue
(
*
promise
)
)
;
if
(
!
EnqueuePromiseResolveThenableJob
(
cx
promiseVal
resolutionVal
thenVal
)
)
return
false
;
return
true
;
}
static
bool
ResolvePromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
resolve
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
resolutionVal
(
cx
args
.
get
(
0
)
)
;
if
(
!
resolve
-
>
getExtendedSlot
(
ResolveFunctionSlot_RejectFunction
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
promise
(
cx
&
resolve
-
>
getExtendedSlot
(
ResolveFunctionSlot_Promise
)
.
toObject
(
)
)
;
ClearResolutionFunctionSlots
(
resolve
)
;
if
(
promise
-
>
is
<
PromiseObject
>
(
)
&
&
promise
-
>
as
<
PromiseObject
>
(
)
.
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
if
(
!
ResolvePromiseInternal
(
cx
promise
resolutionVal
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
PromiseReactionJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
static
bool
EnqueuePromiseReactionJob
(
JSContext
*
cx
HandleObject
reactionObj
HandleValue
handlerArg_
JS
:
:
PromiseState
targetState
)
{
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
)
;
RootedValue
handlerArg
(
cx
handlerArg_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsProxy
(
reactionObj
)
)
{
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
reaction
=
&
reactionObj
-
>
as
<
PromiseReactionRecord
>
(
)
;
}
else
{
if
(
JS_IsDeadWrapper
(
UncheckedUnwrap
(
reactionObj
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
reaction
=
&
UncheckedUnwrap
(
reactionObj
)
-
>
as
<
PromiseReactionRecord
>
(
)
;
MOZ_RELEASE_ASSERT
(
reaction
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
ac
.
emplace
(
cx
reaction
)
;
if
(
!
reaction
-
>
compartment
(
)
-
>
wrap
(
cx
&
handlerArg
)
)
return
false
;
}
MOZ_ASSERT
(
reaction
-
>
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
assertSameCompartment
(
cx
handlerArg
)
;
reaction
-
>
setHandlerArg
(
handlerArg
.
get
(
)
)
;
RootedValue
reactionVal
(
cx
ObjectValue
(
*
reaction
)
)
;
reaction
-
>
setTargetState
(
targetState
)
;
RootedValue
handler
(
cx
reaction
-
>
handler
(
)
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac2
;
if
(
handler
.
isObject
(
)
)
{
RootedObject
handlerObj
(
cx
&
handler
.
toObject
(
)
)
;
handlerObj
=
UncheckedUnwrap
(
handlerObj
)
;
MOZ_ASSERT
(
handlerObj
)
;
ac2
.
emplace
(
cx
handlerObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reactionVal
)
)
return
false
;
}
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseReactionJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
job
)
return
false
;
job
-
>
setExtendedSlot
(
ReactionJobSlot_ReactionRecord
reactionVal
)
;
RootedObject
promise
(
cx
reaction
-
>
promise
(
)
)
;
if
(
promise
&
&
promise
-
>
is
<
PromiseObject
>
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
return
false
;
}
RootedObject
global
(
cx
)
;
RootedObject
objectFromIncumbentGlobal
(
cx
reaction
-
>
incumbentGlobalObject
(
)
)
;
if
(
objectFromIncumbentGlobal
)
{
objectFromIncumbentGlobal
=
CheckedUnwrap
(
objectFromIncumbentGlobal
)
;
MOZ_ASSERT
(
objectFromIncumbentGlobal
)
;
global
=
&
objectFromIncumbentGlobal
-
>
global
(
)
;
}
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
global
)
;
}
static
MOZ_MUST_USE
bool
TriggerPromiseReactions
(
JSContext
*
cx
HandleValue
reactionsVal
JS
:
:
PromiseState
state
HandleValue
valueOrReason
)
;
static
MOZ_MUST_USE
bool
ResolvePromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
valueOrReason
JS
:
:
PromiseState
state
)
{
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
|
|
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
reactionsVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
valueOrReason
)
;
int32_t
flags
=
promise
-
>
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
flags
|
=
PROMISE_FLAG_RESOLVED
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
flags
|
=
PROMISE_FLAG_FULFILLED
;
promise
-
>
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
UndefinedValue
(
)
)
;
PromiseObject
:
:
onSettled
(
cx
promise
)
;
if
(
reactionsVal
.
isObject
(
)
)
return
TriggerPromiseReactions
(
cx
reactionsVal
state
valueOrReason
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
FulfillMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
value_
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
value
(
cx
value_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsProxy
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
if
(
JS_IsDeadWrapper
(
UncheckedUnwrap
(
promiseObj
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
promise
=
&
UncheckedUnwrap
(
promiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
ac
.
emplace
(
cx
promise
)
;
if
(
!
promise
-
>
compartment
(
)
-
>
wrap
(
cx
&
value
)
)
return
false
;
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
ResolvePromise
(
cx
promise
value
JS
:
:
PromiseState
:
:
Fulfilled
)
;
}
static
bool
GetCapabilitiesExecutor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
PromiseConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
MOZ_MUST_USE
PromiseObject
*
CreatePromiseObjectInternal
(
JSContext
*
cx
HandleObject
proto
=
nullptr
bool
protoIsWrapped
=
false
bool
informDebugger
=
true
)
;
enum
GetCapabilitiesExecutorSlots
{
GetCapabilitiesExecutorSlots_Resolve
GetCapabilitiesExecutorSlots_Reject
}
;
static
MOZ_MUST_USE
PromiseObject
*
CreatePromiseObjectWithoutResolutionFunctions
(
JSContext
*
cx
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectInternal
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
AddPromiseFlags
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVE_FUNCTION
|
PROMISE_FLAG_DEFAULT_REJECT_FUNCTION
)
;
return
promise
;
}
static
MOZ_MUST_USE
PromiseObject
*
CreatePromiseWithDefaultResolutionFunctions
(
JSContext
*
cx
MutableHandleObject
resolve
MutableHandleObject
reject
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectInternal
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
if
(
!
CreateResolvingFunctions
(
cx
promise
resolve
reject
)
)
return
nullptr
;
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
reject
)
)
;
return
promise
;
}
static
MOZ_MUST_USE
bool
NewPromiseCapability
(
JSContext
*
cx
HandleObject
C
MutableHandleObject
promise
MutableHandleObject
resolve
MutableHandleObject
reject
bool
canOmitResolutionFunctions
)
{
RootedValue
cVal
(
cx
ObjectValue
(
*
C
)
)
;
if
(
!
IsConstructor
(
C
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_SEARCH_STACK
cVal
nullptr
)
;
return
false
;
}
if
(
IsNativeFunction
(
cVal
PromiseConstructor
)
)
{
if
(
canOmitResolutionFunctions
)
promise
.
set
(
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
else
promise
.
set
(
CreatePromiseWithDefaultResolutionFunctions
(
cx
resolve
reject
)
)
;
if
(
!
promise
)
return
false
;
return
true
;
}
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
executor
(
cx
NewNativeFunction
(
cx
GetCapabilitiesExecutor
2
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
executor
)
return
false
;
FixedConstructArgs
<
1
>
cargs
(
cx
)
;
cargs
[
0
]
.
setObject
(
*
executor
)
;
if
(
!
Construct
(
cx
cVal
cargs
cVal
promise
)
)
return
false
;
RootedValue
resolveVal
(
cx
executor
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
)
)
;
if
(
!
IsCallable
(
resolveVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE
)
;
return
false
;
}
RootedValue
rejectVal
(
cx
executor
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
)
)
;
if
(
!
IsCallable
(
rejectVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE
)
;
return
false
;
}
resolve
.
set
(
&
resolveVal
.
toObject
(
)
)
;
reject
.
set
(
&
rejectVal
.
toObject
(
)
)
;
return
true
;
}
static
bool
GetCapabilitiesExecutor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
F
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
F
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
)
.
isUndefined
(
)
|
|
!
F
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
)
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY
)
;
return
false
;
}
F
-
>
setExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
args
.
get
(
0
)
)
;
F
-
>
setExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
args
.
get
(
1
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
RejectMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
reason_
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
reason
(
cx
reason_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsProxy
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
if
(
JS_IsDeadWrapper
(
UncheckedUnwrap
(
promiseObj
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
promise
=
&
UncheckedUnwrap
(
promiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
ac
.
emplace
(
cx
promise
)
;
if
(
!
promise
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason
)
)
return
false
;
if
(
reason
.
isObject
(
)
&
&
!
CheckedUnwrap
(
&
reason
.
toObject
(
)
)
)
{
RootedObject
realReason
(
cx
UncheckedUnwrap
(
&
reason
.
toObject
(
)
)
)
;
RootedValue
realReasonVal
(
cx
ObjectValue
(
*
realReason
)
)
;
RootedObject
realGlobal
(
cx
&
realReason
-
>
global
(
)
)
;
ReportErrorToGlobal
(
cx
realGlobal
realReasonVal
)
;
if
(
!
GetInternalError
(
cx
JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON
&
reason
)
)
return
false
;
}
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
ResolvePromise
(
cx
promise
reason
JS
:
:
PromiseState
:
:
Rejected
)
;
}
static
MOZ_MUST_USE
bool
TriggerPromiseReactions
(
JSContext
*
cx
HandleValue
reactionsVal
JS
:
:
PromiseState
state
HandleValue
valueOrReason
)
{
RootedObject
reactions
(
cx
&
reactionsVal
.
toObject
(
)
)
;
RootedObject
reaction
(
cx
)
;
if
(
reactions
-
>
is
<
PromiseReactionRecord
>
(
)
|
|
IsWrapper
(
reactions
)
|
|
JS_IsDeadWrapper
(
reactions
)
)
{
return
EnqueuePromiseReactionJob
(
cx
reactions
valueOrReason
state
)
;
}
RootedNativeObject
reactionsList
(
cx
&
reactions
-
>
as
<
NativeObject
>
(
)
)
;
size_t
reactionsCount
=
reactionsList
-
>
getDenseInitializedLength
(
)
;
MOZ_ASSERT
(
reactionsCount
>
1
"
Reactions
list
should
be
created
lazily
"
)
;
RootedValue
reactionVal
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
reactionsCount
;
i
+
+
)
{
reactionVal
=
reactionsList
-
>
getDenseElement
(
i
)
;
MOZ_RELEASE_ASSERT
(
reactionVal
.
isObject
(
)
)
;
reaction
=
&
reactionVal
.
toObject
(
)
;
if
(
!
EnqueuePromiseReactionJob
(
cx
reaction
valueOrReason
state
)
)
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
AsyncFunctionPromiseReactionJob
(
JSContext
*
cx
Handle
<
PromiseReactionRecord
*
>
reaction
MutableHandleValue
rval
)
{
MOZ_ASSERT
(
reaction
-
>
isAsyncFunction
(
)
)
;
RootedValue
handlerVal
(
cx
reaction
-
>
handler
(
)
)
;
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
Rooted
<
PromiseObject
*
>
resultPromise
(
cx
&
reaction
-
>
promise
(
)
-
>
as
<
PromiseObject
>
(
)
)
;
RootedValue
generatorVal
(
cx
resultPromise
-
>
getFixedSlot
(
PromiseSlot_AwaitGenerator
)
)
;
int32_t
handlerNum
=
int32_t
(
handlerVal
.
toNumber
(
)
)
;
if
(
handlerNum
=
=
PromiseHandlerAsyncFunctionAwaitedFulfilled
)
{
if
(
!
AsyncFunctionAwaitedFulfilled
(
cx
resultPromise
generatorVal
argument
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
handlerNum
=
=
PromiseHandlerAsyncFunctionAwaitedRejected
)
;
if
(
!
AsyncFunctionAwaitedRejected
(
cx
resultPromise
generatorVal
argument
)
)
return
false
;
}
rval
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
AsyncGeneratorPromiseReactionJob
(
JSContext
*
cx
Handle
<
PromiseReactionRecord
*
>
reaction
MutableHandleValue
rval
)
{
MOZ_ASSERT
(
reaction
-
>
isAsyncGenerator
(
)
)
;
RootedValue
handlerVal
(
cx
reaction
-
>
handler
(
)
)
;
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
Rooted
<
AsyncGeneratorObject
*
>
asyncGenObj
(
cx
reaction
-
>
asyncGenerator
(
)
)
;
int32_t
handlerNum
=
int32_t
(
handlerVal
.
toNumber
(
)
)
;
if
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorAwaitedFulfilled
)
{
if
(
!
AsyncGeneratorAwaitedFulfilled
(
cx
asyncGenObj
argument
)
)
return
false
;
}
else
if
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorAwaitedRejected
)
{
if
(
!
AsyncGeneratorAwaitedRejected
(
cx
asyncGenObj
argument
)
)
return
false
;
}
else
if
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorResumeNextReturnFulfilled
)
{
asyncGenObj
-
>
setCompleted
(
)
;
if
(
!
AsyncGeneratorResolve
(
cx
asyncGenObj
argument
true
)
)
return
false
;
}
else
if
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorResumeNextReturnRejected
)
{
asyncGenObj
-
>
setCompleted
(
)
;
if
(
!
AsyncGeneratorReject
(
cx
asyncGenObj
argument
)
)
return
false
;
}
else
if
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorYieldReturnAwaitedFulfilled
)
{
asyncGenObj
-
>
setExecuting
(
)
;
if
(
!
AsyncGeneratorYieldReturnAwaitedFulfilled
(
cx
asyncGenObj
argument
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
handlerNum
=
=
PromiseHandlerAsyncGeneratorYieldReturnAwaitedRejected
)
;
asyncGenObj
-
>
setExecuting
(
)
;
if
(
!
AsyncGeneratorYieldReturnAwaitedRejected
(
cx
asyncGenObj
argument
)
)
return
false
;
}
rval
.
setUndefined
(
)
;
return
true
;
}
static
bool
PromiseReactionJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedObject
reactionObj
(
cx
&
job
-
>
getExtendedSlot
(
ReactionJobSlot_ReactionRecord
)
.
toObject
(
)
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsProxy
(
reactionObj
)
)
{
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
}
else
{
reactionObj
=
UncheckedUnwrap
(
reactionObj
)
;
if
(
JS_IsDeadWrapper
(
reactionObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
ac
.
emplace
(
cx
reactionObj
)
;
}
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
&
reactionObj
-
>
as
<
PromiseReactionRecord
>
(
)
)
;
if
(
reaction
-
>
isAsyncFunction
(
)
)
return
AsyncFunctionPromiseReactionJob
(
cx
reaction
args
.
rval
(
)
)
;
if
(
reaction
-
>
isAsyncGenerator
(
)
)
return
AsyncGeneratorPromiseReactionJob
(
cx
reaction
args
.
rval
(
)
)
;
RootedValue
handlerVal
(
cx
reaction
-
>
handler
(
)
)
;
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
RootedValue
handlerResult
(
cx
)
;
ResolutionMode
resolutionMode
=
ResolveMode
;
if
(
handlerVal
.
isNumber
(
)
)
{
int32_t
handlerNum
=
int32_t
(
handlerVal
.
toNumber
(
)
)
;
if
(
handlerNum
=
=
PromiseHandlerIdentity
)
{
handlerResult
=
argument
;
}
else
if
(
handlerNum
=
=
PromiseHandlerThrower
)
{
resolutionMode
=
RejectMode
;
handlerResult
=
argument
;
}
else
{
MOZ_ASSERT
(
handlerNum
=
=
PromiseHandlerAsyncFromSyncIteratorValueUnwrapDone
|
|
handlerNum
=
=
PromiseHandlerAsyncFromSyncIteratorValueUnwrapNotDone
)
;
bool
done
=
handlerNum
=
=
PromiseHandlerAsyncFromSyncIteratorValueUnwrapDone
;
RootedObject
resultObj
(
cx
CreateIterResultObject
(
cx
argument
done
)
)
;
if
(
!
resultObj
)
return
false
;
handlerResult
=
ObjectValue
(
*
resultObj
)
;
}
}
else
{
FixedInvokeArgs
<
1
>
args2
(
cx
)
;
args2
[
0
]
.
set
(
argument
)
;
if
(
!
Call
(
cx
handlerVal
UndefinedHandleValue
args2
&
handlerResult
)
)
{
resolutionMode
=
RejectMode
;
if
(
!
MaybeGetAndClearException
(
cx
&
handlerResult
)
)
return
false
;
}
}
size_t
hookSlot
=
resolutionMode
=
=
RejectMode
?
ReactionRecordSlot_Reject
:
ReactionRecordSlot_Resolve
;
RootedObject
callee
(
cx
reaction
-
>
getFixedSlot
(
hookSlot
)
.
toObjectOrNull
(
)
)
;
RootedObject
promiseObj
(
cx
reaction
-
>
promise
(
)
)
;
if
(
!
RunResolutionFunction
(
cx
callee
handlerResult
resolutionMode
promiseObj
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
PromiseResolveThenableJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
then
(
cx
job
-
>
getExtendedSlot
(
ThenableJobSlot_Handler
)
)
;
MOZ_ASSERT
(
!
IsWrapper
(
&
then
.
toObject
(
)
)
)
;
RootedNativeObject
jobArgs
(
cx
&
job
-
>
getExtendedSlot
(
ThenableJobSlot_JobData
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedObject
promise
(
cx
&
jobArgs
-
>
getDenseElement
(
ThenableJobDataIndex_Promise
)
.
toObject
(
)
)
;
RootedValue
thenable
(
cx
jobArgs
-
>
getDenseElement
(
ThenableJobDataIndex_Thenable
)
)
;
RootedObject
resolveFn
(
cx
)
;
RootedObject
rejectFn
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promise
&
resolveFn
&
rejectFn
)
)
return
false
;
FixedInvokeArgs
<
2
>
args2
(
cx
)
;
args2
[
0
]
.
setObject
(
*
resolveFn
)
;
args2
[
1
]
.
setObject
(
*
rejectFn
)
;
RootedValue
rval
(
cx
)
;
if
(
Call
(
cx
then
thenable
args2
&
rval
)
)
return
true
;
if
(
!
MaybeGetAndClearException
(
cx
&
rval
)
)
return
false
;
FixedInvokeArgs
<
1
>
rejectArgs
(
cx
)
;
rejectArgs
[
0
]
.
set
(
rval
)
;
RootedValue
rejectVal
(
cx
ObjectValue
(
*
rejectFn
)
)
;
return
Call
(
cx
rejectVal
UndefinedHandleValue
rejectArgs
&
rval
)
;
}
static
MOZ_MUST_USE
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve_
HandleValue
thenable_
HandleValue
thenVal
)
{
RootedValue
promiseToResolve
(
cx
promiseToResolve_
)
;
RootedValue
thenable
(
cx
thenable_
)
;
RootedObject
then
(
cx
CheckedUnwrap
(
&
thenVal
.
toObject
(
)
)
)
;
AutoCompartment
ac
(
cx
then
)
;
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseResolveThenableJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
job
)
return
false
;
job
-
>
setExtendedSlot
(
ThenableJobSlot_Handler
ObjectValue
(
*
then
)
)
;
RootedArrayObject
data
(
cx
NewDenseFullyAllocatedArray
(
cx
ThenableJobDataLength
)
)
;
if
(
!
data
|
|
data
-
>
ensureDenseElements
(
cx
0
ThenableJobDataLength
)
!
=
DenseElementResult
:
:
Success
)
{
return
false
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseToResolve
)
)
return
false
;
data
-
>
setDenseElement
(
ThenableJobDataIndex_Promise
promiseToResolve
)
;
RootedObject
promise
(
cx
&
promiseToResolve
.
toObject
(
)
)
;
MOZ_ASSERT
(
thenable
.
isObject
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
thenable
)
)
return
false
;
data
-
>
setDenseElement
(
ThenableJobDataIndex_Thenable
thenable
)
;
job
-
>
setExtendedSlot
(
ThenableJobSlot_JobData
ObjectValue
(
*
data
)
)
;
RootedObject
incumbentGlobal
(
cx
cx
-
>
runtime
(
)
-
>
getIncumbentGlobal
(
cx
)
)
;
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
incumbentGlobal
)
;
}
static
MOZ_MUST_USE
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled
HandleValue
onRejected
HandleObject
dependentPromise
HandleObject
resolve
HandleObject
reject
HandleObject
incumbentGlobal
)
;
static
MOZ_MUST_USE
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
;
static
MOZ_MUST_USE
bool
BlockOnPromise
(
JSContext
*
cx
HandleValue
promise
HandleObject
blockedPromise
HandleValue
onFulfilled
HandleValue
onRejected
)
;
static
JSFunction
*
GetResolveFunctionFromReject
(
JSFunction
*
reject
)
{
MOZ_ASSERT
(
reject
-
>
maybeNative
(
)
=
=
RejectPromiseFunction
)
;
Value
resolveFunVal
=
reject
-
>
getExtendedSlot
(
RejectFunctionSlot_ResolveFunction
)
;
MOZ_ASSERT
(
IsNativeFunction
(
resolveFunVal
ResolvePromiseFunction
)
)
;
return
&
resolveFunVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
static
JSFunction
*
GetRejectFunctionFromResolve
(
JSFunction
*
resolve
)
{
MOZ_ASSERT
(
resolve
-
>
maybeNative
(
)
=
=
ResolvePromiseFunction
)
;
Value
rejectFunVal
=
resolve
-
>
getExtendedSlot
(
ResolveFunctionSlot_RejectFunction
)
;
MOZ_ASSERT
(
IsNativeFunction
(
rejectFunVal
RejectPromiseFunction
)
)
;
return
&
rejectFunVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
static
JSFunction
*
GetResolveFunctionFromPromise
(
PromiseObject
*
promise
)
{
Value
rejectFunVal
=
promise
-
>
getFixedSlot
(
PromiseSlot_RejectFunction
)
;
if
(
rejectFunVal
.
isUndefined
(
)
)
return
nullptr
;
JSObject
*
rejectFunObj
=
&
rejectFunVal
.
toObject
(
)
;
if
(
IsWrapper
(
rejectFunObj
)
)
rejectFunObj
=
UncheckedUnwrap
(
rejectFunObj
)
;
if
(
!
rejectFunObj
-
>
is
<
JSFunction
>
(
)
)
return
nullptr
;
JSFunction
*
rejectFun
=
&
rejectFunObj
-
>
as
<
JSFunction
>
(
)
;
if
(
rejectFun
-
>
maybeNative
(
)
!
=
&
RejectPromiseFunction
)
return
nullptr
;
return
GetResolveFunctionFromReject
(
rejectFun
)
;
}
static
void
ClearResolutionFunctionSlots
(
JSFunction
*
resolutionFun
)
{
JSFunction
*
resolve
;
JSFunction
*
reject
;
if
(
resolutionFun
-
>
maybeNative
(
)
=
=
ResolvePromiseFunction
)
{
resolve
=
resolutionFun
;
reject
=
GetRejectFunctionFromResolve
(
resolutionFun
)
;
}
else
{
resolve
=
GetResolveFunctionFromReject
(
resolutionFun
)
;
reject
=
resolutionFun
;
}
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_Promise
UndefinedValue
(
)
)
;
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_RejectFunction
UndefinedValue
(
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_Promise
UndefinedValue
(
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_ResolveFunction
UndefinedValue
(
)
)
;
}
static
MOZ_MUST_USE
PromiseObject
*
CreatePromiseObjectInternal
(
JSContext
*
cx
HandleObject
proto
bool
protoIsWrapped
bool
informDebugger
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
protoIsWrapped
)
ac
.
emplace
(
cx
proto
)
;
promise
=
NewObjectWithClassProto
<
PromiseObject
>
(
cx
proto
)
;
if
(
!
promise
)
return
nullptr
;
promise
-
>
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
0
)
)
;
if
(
ShouldCaptureDebugInfo
(
cx
)
)
{
PromiseDebugInfo
*
debugInfo
=
PromiseDebugInfo
:
:
create
(
cx
promise
)
;
if
(
!
debugInfo
)
return
nullptr
;
}
if
(
informDebugger
)
Debugger
:
:
onNewPromise
(
cx
promise
)
;
return
promise
;
}
static
bool
PromiseConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Promise
"
)
)
return
false
;
RootedValue
executorVal
(
cx
args
.
get
(
0
)
)
;
if
(
!
IsCallable
(
executorVal
)
)
return
ReportIsNotFunction
(
cx
executorVal
)
;
RootedObject
executor
(
cx
&
executorVal
.
toObject
(
)
)
;
RootedObject
newTarget
(
cx
&
args
.
newTarget
(
)
.
toObject
(
)
)
;
bool
needsWrapping
=
false
;
RootedObject
proto
(
cx
)
;
if
(
IsWrapper
(
newTarget
)
)
{
JSObject
*
unwrappedNewTarget
=
CheckedUnwrap
(
newTarget
)
;
MOZ_ASSERT
(
unwrappedNewTarget
)
;
MOZ_ASSERT
(
unwrappedNewTarget
!
=
newTarget
)
;
newTarget
=
unwrappedNewTarget
;
{
AutoCompartment
ac
(
cx
newTarget
)
;
RootedObject
promiseCtor
(
cx
)
;
if
(
!
GetBuiltinConstructor
(
cx
JSProto_Promise
&
promiseCtor
)
)
return
false
;
if
(
newTarget
=
=
promiseCtor
)
{
needsWrapping
=
true
;
if
(
!
GetBuiltinPrototype
(
cx
JSProto_Promise
&
proto
)
)
return
false
;
}
}
}
if
(
needsWrapping
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
proto
)
)
return
false
;
}
else
{
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
create
(
cx
executor
proto
needsWrapping
)
)
;
if
(
!
promise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
promise
)
;
if
(
needsWrapping
)
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
args
.
rval
(
)
)
;
return
true
;
}
PromiseObject
*
PromiseObject
:
:
create
(
JSContext
*
cx
HandleObject
executor
HandleObject
proto
bool
needsWrapping
)
{
MOZ_ASSERT
(
executor
-
>
isCallable
(
)
)
;
RootedObject
usedProto
(
cx
proto
)
;
if
(
needsWrapping
)
{
MOZ_ASSERT
(
proto
)
;
usedProto
=
CheckedUnwrap
(
proto
)
;
if
(
!
usedProto
)
return
nullptr
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectInternal
(
cx
usedProto
needsWrapping
false
)
)
;
if
(
!
promise
)
return
nullptr
;
RootedObject
promiseObj
(
cx
promise
)
;
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseObj
)
)
return
nullptr
;
RootedObject
resolveFn
(
cx
)
;
RootedObject
rejectFn
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promiseObj
&
resolveFn
&
rejectFn
)
)
return
nullptr
;
if
(
needsWrapping
)
{
AutoCompartment
ac
(
cx
promise
)
;
RootedObject
wrappedRejectFn
(
cx
rejectFn
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedRejectFn
)
)
return
nullptr
;
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
wrappedRejectFn
)
)
;
}
else
{
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
rejectFn
)
)
;
}
bool
success
;
{
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
resolveFn
)
;
args
[
1
]
.
setObject
(
*
rejectFn
)
;
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
executor
)
)
;
success
=
Call
(
cx
calleeOrRval
UndefinedHandleValue
args
&
calleeOrRval
)
;
}
if
(
!
success
)
{
RootedValue
exceptionVal
(
cx
)
;
if
(
!
MaybeGetAndClearException
(
cx
&
exceptionVal
)
)
return
nullptr
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
exceptionVal
)
;
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
rejectFn
)
)
;
if
(
!
Call
(
cx
calleeOrRval
UndefinedHandleValue
args
&
calleeOrRval
)
)
return
nullptr
;
}
Debugger
:
:
onNewPromise
(
cx
promise
)
;
return
promise
;
}
PromiseObject
*
PromiseObject
:
:
createSkippingExecutor
(
JSContext
*
cx
)
{
return
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
}
static
MOZ_MUST_USE
bool
PerformPromiseAll
(
JSContext
*
cx
JS
:
:
ForOfIterator
&
iterator
HandleObject
C
HandleObject
promiseObj
HandleObject
resolve
HandleObject
reject
bool
*
done
)
;
static
bool
Promise_static_all
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
iterable
(
cx
args
.
get
(
0
)
)
;
RootedValue
CVal
(
cx
args
.
thisv
(
)
)
;
if
(
!
CVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
all
call
"
)
;
return
false
;
}
RootedObject
C
(
cx
&
CVal
.
toObject
(
)
)
;
RootedObject
resultPromise
(
cx
)
;
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
resultPromise
&
resolve
&
reject
false
)
)
return
false
;
JS
:
:
ForOfIterator
iter
(
cx
)
;
if
(
!
iter
.
init
(
iterable
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
if
(
!
iter
.
valueIsIterable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
"
Argument
of
Promise
.
all
"
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
}
bool
done
;
bool
result
=
PerformPromiseAll
(
cx
iter
C
resultPromise
resolve
reject
&
done
)
;
if
(
!
result
)
{
if
(
!
done
)
iter
.
closeThrow
(
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
PerformPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled_
HandleValue
onRejected_
HandleObject
resultPromise
HandleObject
resolve
HandleObject
reject
)
;
static
bool
PromiseAllResolveElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
JSObject
*
js
:
:
GetWaitForAllPromise
(
JSContext
*
cx
const
JS
:
:
AutoObjectVector
&
promises
)
{
#
ifdef
DEBUG
for
(
size_t
i
=
0
len
=
promises
.
length
(
)
;
i
<
len
;
i
+
+
)
{
JSObject
*
obj
=
promises
[
i
]
;
assertSameCompartment
(
cx
obj
)
;
MOZ_ASSERT
(
UncheckedUnwrap
(
obj
)
-
>
is
<
PromiseObject
>
(
)
)
;
}
#
endif
RootedObject
C
(
cx
GlobalObject
:
:
getOrCreatePromiseConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
C
)
return
nullptr
;
RootedObject
resultPromise
(
cx
)
;
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
resultPromise
&
resolve
&
reject
false
)
)
return
nullptr
;
{
uint32_t
promiseCount
=
promises
.
length
(
)
;
RootedNativeObject
valuesArray
(
cx
NewDenseFullyAllocatedArray
(
cx
promiseCount
)
)
;
if
(
!
valuesArray
)
return
nullptr
;
if
(
valuesArray
-
>
ensureDenseElements
(
cx
0
promiseCount
)
!
=
DenseElementResult
:
:
Success
)
return
nullptr
;
RootedValue
valuesArrayVal
(
cx
ObjectValue
(
*
valuesArray
)
)
;
Rooted
<
PromiseAllDataHolder
*
>
dataHolder
(
cx
NewPromiseAllDataHolder
(
cx
resultPromise
valuesArrayVal
resolve
)
)
;
if
(
!
dataHolder
)
return
nullptr
;
RootedValue
dataHolderVal
(
cx
ObjectValue
(
*
dataHolder
)
)
;
for
(
uint32_t
index
=
0
;
index
<
promiseCount
;
index
+
+
)
{
valuesArray
-
>
setDenseElement
(
index
UndefinedHandleValue
)
;
RootedObject
nextPromiseObj
(
cx
promises
[
index
]
)
;
RootedFunction
resolveFunc
(
cx
NewNativeFunction
(
cx
PromiseAllResolveElementFunction
1
nullptr
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
resolveFunc
)
return
nullptr
;
resolveFunc
-
>
setExtendedSlot
(
PromiseAllResolveElementFunctionSlot_Data
dataHolderVal
)
;
resolveFunc
-
>
setExtendedSlot
(
PromiseAllResolveElementFunctionSlot_ElementIndex
Int32Value
(
index
)
)
;
dataHolder
-
>
increaseRemainingCount
(
)
;
RootedValue
resolveFunVal
(
cx
ObjectValue
(
*
resolveFunc
)
)
;
RootedValue
rejectFunVal
(
cx
ObjectValue
(
*
reject
)
)
;
Rooted
<
PromiseObject
*
>
nextPromise
(
cx
)
;
nextPromise
=
&
UncheckedUnwrap
(
nextPromiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
if
(
!
PerformPromiseThen
(
cx
nextPromise
resolveFunVal
rejectFunVal
resultPromise
nullptr
nullptr
)
)
{
return
nullptr
;
}
}
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
RootedValue
valuesArrayVal
(
cx
ObjectValue
(
*
valuesArray
)
)
;
if
(
!
ResolvePromiseInternal
(
cx
resultPromise
valuesArrayVal
)
)
return
nullptr
;
}
}
return
resultPromise
;
}
static
MOZ_MUST_USE
bool
RunResolutionFunction
(
JSContext
*
cx
HandleObject
resolutionFun
HandleValue
result
ResolutionMode
mode
HandleObject
promiseObj
)
{
assertSameCompartment
(
cx
resolutionFun
)
;
assertSameCompartment
(
cx
result
)
;
assertSameCompartment
(
cx
promiseObj
)
;
if
(
resolutionFun
)
{
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
resolutionFun
)
)
;
FixedInvokeArgs
<
1
>
resolveArgs
(
cx
)
;
resolveArgs
[
0
]
.
set
(
result
)
;
return
Call
(
cx
calleeOrRval
UndefinedHandleValue
resolveArgs
&
calleeOrRval
)
;
}
if
(
!
promiseObj
)
return
true
;
Rooted
<
PromiseObject
*
>
promise
(
cx
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
)
;
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
return
true
;
if
(
mode
=
=
ResolveMode
)
{
if
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVE_FUNCTION
)
)
return
true
;
return
ResolvePromiseInternal
(
cx
promise
result
)
;
}
if
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_REJECT_FUNCTION
)
)
return
true
;
return
RejectMaybeWrappedPromise
(
cx
promiseObj
result
)
;
}
static
MOZ_MUST_USE
bool
PerformPromiseAll
(
JSContext
*
cx
JS
:
:
ForOfIterator
&
iterator
HandleObject
C
HandleObject
promiseObj
HandleObject
resolve
HandleObject
reject
bool
*
done
)
{
*
done
=
false
;
RootedObject
unwrappedPromiseObj
(
cx
)
;
if
(
IsWrapper
(
promiseObj
)
)
{
unwrappedPromiseObj
=
CheckedUnwrap
(
promiseObj
)
;
MOZ_ASSERT
(
unwrappedPromiseObj
)
;
}
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
RootedValue
CVal
(
cx
ObjectValue
(
*
C
)
)
;
RootedObject
valuesArray
(
cx
)
;
if
(
unwrappedPromiseObj
)
{
JSAutoCompartment
ac
(
cx
unwrappedPromiseObj
)
;
valuesArray
=
NewDenseFullyAllocatedArray
(
cx
0
)
;
}
else
{
valuesArray
=
NewDenseFullyAllocatedArray
(
cx
0
)
;
}
if
(
!
valuesArray
)
return
false
;
RootedValue
valuesArrayVal
(
cx
ObjectValue
(
*
valuesArray
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
valuesArrayVal
)
)
return
false
;
Rooted
<
PromiseAllDataHolder
*
>
dataHolder
(
cx
NewPromiseAllDataHolder
(
cx
promiseObj
valuesArrayVal
resolve
)
)
;
if
(
!
dataHolder
)
return
false
;
RootedValue
dataHolderVal
(
cx
ObjectValue
(
*
dataHolder
)
)
;
uint32_t
index
=
0
;
RootedValue
nextValue
(
cx
)
;
RootedId
indexId
(
cx
)
;
RootedValue
rejectFunVal
(
cx
ObjectValue
(
*
reject
)
)
;
while
(
true
)
{
if
(
!
iterator
.
next
(
&
nextValue
done
)
)
{
*
done
=
true
;
return
false
;
}
if
(
*
done
)
{
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
return
RunResolutionFunction
(
cx
resolve
valuesArrayVal
ResolveMode
promiseObj
)
;
}
return
true
;
}
{
JSAutoCompartment
ac
(
cx
valuesArray
)
;
indexId
=
INT_TO_JSID
(
index
)
;
if
(
!
DefineDataProperty
(
cx
valuesArray
indexId
UndefinedHandleValue
)
)
return
false
;
}
RootedValue
nextPromise
(
cx
)
;
RootedValue
staticResolve
(
cx
)
;
if
(
!
GetProperty
(
cx
C
CVal
cx
-
>
names
(
)
.
resolve
&
staticResolve
)
)
return
false
;
FixedInvokeArgs
<
1
>
resolveArgs
(
cx
)
;
resolveArgs
[
0
]
.
set
(
nextValue
)
;
if
(
!
Call
(
cx
staticResolve
CVal
resolveArgs
&
nextPromise
)
)
return
false
;
RootedFunction
resolveFunc
(
cx
NewNativeFunction
(
cx
PromiseAllResolveElementFunction
1
nullptr
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
resolveFunc
)
return
false
;
resolveFunc
-
>
setExtendedSlot
(
PromiseAllResolveElementFunctionSlot_Data
dataHolderVal
)
;
resolveFunc
-
>
setExtendedSlot
(
PromiseAllResolveElementFunctionSlot_ElementIndex
Int32Value
(
index
)
)
;
dataHolder
-
>
increaseRemainingCount
(
)
;
RootedValue
resolveFunVal
(
cx
ObjectValue
(
*
resolveFunc
)
)
;
if
(
!
BlockOnPromise
(
cx
nextPromise
promiseObj
resolveFunVal
rejectFunVal
)
)
return
false
;
index
+
+
;
MOZ_ASSERT
(
index
>
0
)
;
}
}
static
bool
PromiseAllResolveElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
resolve
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
xVal
(
cx
args
.
get
(
0
)
)
;
RootedValue
dataVal
(
cx
resolve
-
>
getExtendedSlot
(
PromiseAllResolveElementFunctionSlot_Data
)
)
;
if
(
dataVal
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PromiseAllDataHolder
*
>
data
(
cx
&
dataVal
.
toObject
(
)
.
as
<
PromiseAllDataHolder
>
(
)
)
;
resolve
-
>
setExtendedSlot
(
PromiseAllResolveElementFunctionSlot_Data
UndefinedValue
(
)
)
;
int32_t
index
=
resolve
-
>
getExtendedSlot
(
PromiseAllResolveElementFunctionSlot_ElementIndex
)
.
toInt32
(
)
;
RootedValue
valuesVal
(
cx
data
-
>
valuesArray
(
)
)
;
RootedObject
valuesObj
(
cx
&
valuesVal
.
toObject
(
)
)
;
bool
valuesListIsWrapped
=
false
;
if
(
IsWrapper
(
valuesObj
)
)
{
valuesListIsWrapped
=
true
;
valuesObj
=
UncheckedUnwrap
(
valuesObj
)
;
}
RootedNativeObject
values
(
cx
&
valuesObj
-
>
as
<
NativeObject
>
(
)
)
;
if
(
valuesListIsWrapped
)
{
AutoCompartment
ac
(
cx
values
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
xVal
)
)
return
false
;
}
values
-
>
setDenseElement
(
index
xVal
)
;
uint32_t
remainingCount
=
data
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
RootedObject
resolveAllFun
(
cx
data
-
>
resolveObj
(
)
)
;
RootedObject
promiseObj
(
cx
data
-
>
promiseObj
(
)
)
;
if
(
!
RunResolutionFunction
(
cx
resolveAllFun
valuesVal
ResolveMode
promiseObj
)
)
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
PerformPromiseRace
(
JSContext
*
cx
JS
:
:
ForOfIterator
&
iterator
HandleObject
C
HandleObject
promiseObj
HandleObject
resolve
HandleObject
reject
bool
*
done
)
;
static
bool
Promise_static_race
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
iterable
(
cx
args
.
get
(
0
)
)
;
RootedValue
CVal
(
cx
args
.
thisv
(
)
)
;
if
(
!
CVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
race
call
"
)
;
return
false
;
}
RootedObject
C
(
cx
&
CVal
.
toObject
(
)
)
;
RootedObject
resultPromise
(
cx
)
;
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
resultPromise
&
resolve
&
reject
false
)
)
return
false
;
JS
:
:
ForOfIterator
iter
(
cx
)
;
if
(
!
iter
.
init
(
iterable
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
if
(
!
iter
.
valueIsIterable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
"
Argument
of
Promise
.
race
"
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
}
bool
done
;
bool
result
=
PerformPromiseRace
(
cx
iter
C
resultPromise
resolve
reject
&
done
)
;
if
(
!
result
)
{
if
(
!
done
)
iter
.
closeThrow
(
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
reject
)
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
PerformPromiseRace
(
JSContext
*
cx
JS
:
:
ForOfIterator
&
iterator
HandleObject
C
HandleObject
promiseObj
HandleObject
resolve
HandleObject
reject
bool
*
done
)
{
*
done
=
false
;
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
RootedValue
CVal
(
cx
ObjectValue
(
*
C
)
)
;
RootedValue
nextValue
(
cx
)
;
RootedValue
resolveFunVal
(
cx
ObjectValue
(
*
resolve
)
)
;
RootedValue
rejectFunVal
(
cx
ObjectValue
(
*
reject
)
)
;
while
(
true
)
{
if
(
!
iterator
.
next
(
&
nextValue
done
)
)
{
*
done
=
true
;
return
false
;
}
if
(
*
done
)
{
return
true
;
}
RootedValue
nextPromise
(
cx
)
;
RootedValue
staticResolve
(
cx
)
;
if
(
!
GetProperty
(
cx
C
CVal
cx
-
>
names
(
)
.
resolve
&
staticResolve
)
)
return
false
;
FixedInvokeArgs
<
1
>
resolveArgs
(
cx
)
;
resolveArgs
[
0
]
.
set
(
nextValue
)
;
if
(
!
Call
(
cx
staticResolve
CVal
resolveArgs
&
nextPromise
)
)
return
false
;
if
(
!
BlockOnPromise
(
cx
nextPromise
promiseObj
resolveFunVal
rejectFunVal
)
)
return
false
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
reach
the
end
of
PerformPromiseRace
"
)
;
}
static
MOZ_MUST_USE
JSObject
*
CommonStaticResolveRejectImpl
(
JSContext
*
cx
HandleValue
thisVal
HandleValue
argVal
ResolutionMode
mode
)
{
if
(
!
thisVal
.
isObject
(
)
)
{
const
char
*
msg
=
mode
=
=
ResolveMode
?
"
Receiver
of
Promise
.
resolve
call
"
:
"
Receiver
of
Promise
.
reject
call
"
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_NONNULL_OBJECT
msg
)
;
return
nullptr
;
}
RootedObject
C
(
cx
&
thisVal
.
toObject
(
)
)
;
if
(
mode
=
=
ResolveMode
&
&
argVal
.
isObject
(
)
)
{
RootedObject
xObj
(
cx
&
argVal
.
toObject
(
)
)
;
bool
isPromise
=
false
;
if
(
xObj
-
>
is
<
PromiseObject
>
(
)
)
{
isPromise
=
true
;
}
else
if
(
IsWrapper
(
xObj
)
)
{
RootedObject
unwrappedObject
(
cx
CheckedUnwrap
(
xObj
)
)
;
if
(
unwrappedObject
&
&
unwrappedObject
-
>
is
<
PromiseObject
>
(
)
)
isPromise
=
true
;
}
if
(
isPromise
)
{
RootedValue
ctorVal
(
cx
)
;
if
(
!
GetProperty
(
cx
xObj
xObj
cx
-
>
names
(
)
.
constructor
&
ctorVal
)
)
return
nullptr
;
if
(
ctorVal
=
=
thisVal
)
return
xObj
;
}
}
RootedObject
promise
(
cx
)
;
RootedObject
resolveFun
(
cx
)
;
RootedObject
rejectFun
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
promise
&
resolveFun
&
rejectFun
true
)
)
return
nullptr
;
if
(
!
RunResolutionFunction
(
cx
mode
=
=
ResolveMode
?
resolveFun
:
rejectFun
argVal
mode
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
bool
js
:
:
Promise_reject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
thisVal
(
cx
args
.
thisv
(
)
)
;
RootedValue
argVal
(
cx
args
.
get
(
0
)
)
;
JSObject
*
result
=
CommonStaticResolveRejectImpl
(
cx
thisVal
argVal
RejectMode
)
;
if
(
!
result
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
JSObject
*
PromiseObject
:
:
unforgeableReject
(
JSContext
*
cx
HandleValue
value
)
{
RootedObject
promiseCtor
(
cx
JS
:
:
GetPromiseConstructor
(
cx
)
)
;
if
(
!
promiseCtor
)
return
nullptr
;
RootedValue
cVal
(
cx
ObjectValue
(
*
promiseCtor
)
)
;
return
CommonStaticResolveRejectImpl
(
cx
cVal
value
RejectMode
)
;
}
bool
js
:
:
Promise_static_resolve
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
thisVal
(
cx
args
.
thisv
(
)
)
;
RootedValue
argVal
(
cx
args
.
get
(
0
)
)
;
JSObject
*
result
=
CommonStaticResolveRejectImpl
(
cx
thisVal
argVal
ResolveMode
)
;
if
(
!
result
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
JSObject
*
PromiseObject
:
:
unforgeableResolve
(
JSContext
*
cx
HandleValue
value
)
{
RootedObject
promiseCtor
(
cx
JS
:
:
GetPromiseConstructor
(
cx
)
)
;
if
(
!
promiseCtor
)
return
nullptr
;
RootedValue
cVal
(
cx
ObjectValue
(
*
promiseCtor
)
)
;
return
CommonStaticResolveRejectImpl
(
cx
cVal
value
ResolveMode
)
;
}
static
bool
Promise_static_species
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
args
.
thisv
(
)
)
;
return
true
;
}
static
PromiseReactionRecord
*
NewReactionRecord
(
JSContext
*
cx
HandleObject
resultPromise
HandleValue
onFulfilled
HandleValue
onRejected
HandleObject
resolve
HandleObject
reject
HandleObject
incumbentGlobalObject
)
{
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewObjectWithClassProto
<
PromiseReactionRecord
>
(
cx
)
)
;
if
(
!
reaction
)
return
nullptr
;
assertSameCompartment
(
cx
resultPromise
)
;
assertSameCompartment
(
cx
onFulfilled
)
;
assertSameCompartment
(
cx
onRejected
)
;
assertSameCompartment
(
cx
resolve
)
;
assertSameCompartment
(
cx
reject
)
;
assertSameCompartment
(
cx
incumbentGlobalObject
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Promise
ObjectOrNullValue
(
resultPromise
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
0
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_OnFulfilled
onFulfilled
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_OnRejected
onRejected
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Resolve
ObjectOrNullValue
(
resolve
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Reject
ObjectOrNullValue
(
reject
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_IncumbentGlobalObject
ObjectOrNullValue
(
incumbentGlobalObject
)
)
;
return
reaction
;
}
static
bool
IsPromiseSpecies
(
JSContext
*
cx
JSFunction
*
species
)
{
return
species
-
>
maybeNative
(
)
=
=
Promise_static_species
;
}
MOZ_MUST_USE
bool
js
:
:
OriginalPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled
HandleValue
onRejected
MutableHandleObject
dependent
bool
createDependent
)
{
RootedObject
promiseObj
(
cx
promise
)
;
if
(
promise
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseObj
)
)
return
false
;
}
RootedObject
resultPromise
(
cx
)
;
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
if
(
createDependent
)
{
RootedObject
C
(
cx
SpeciesConstructor
(
cx
promiseObj
JSProto_Promise
IsPromiseSpecies
)
)
;
if
(
!
C
)
return
false
;
if
(
!
NewPromiseCapability
(
cx
C
&
resultPromise
&
resolve
&
reject
true
)
)
return
false
;
}
if
(
!
PerformPromiseThen
(
cx
promise
onFulfilled
onRejected
resultPromise
resolve
reject
)
)
return
false
;
dependent
.
set
(
resultPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
PerformPromiseThenWithReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
;
MOZ_MUST_USE
PromiseObject
*
js
:
:
CreatePromiseObjectForAsync
(
JSContext
*
cx
HandleValue
generatorVal
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
promise
)
return
nullptr
;
AddPromiseFlags
(
*
promise
PROMISE_FLAG_ASYNC
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_AwaitGenerator
generatorVal
)
;
return
promise
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncFunctionThrown
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
resultPromise
)
{
RootedValue
exc
(
cx
)
;
if
(
!
MaybeGetAndClearException
(
cx
&
exc
)
)
return
false
;
if
(
!
RejectMaybeWrappedPromise
(
cx
resultPromise
exc
)
)
return
false
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncFunctionReturned
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
resultPromise
HandleValue
value
)
{
if
(
!
ResolvePromiseInternal
(
cx
resultPromise
value
)
)
return
false
;
return
true
;
}
template
<
typename
T
>
static
MOZ_MUST_USE
bool
InternalAwait
(
JSContext
*
cx
HandleValue
value
HandleObject
resultPromise
HandleValue
onFulfilled
HandleValue
onRejected
T
extraStep
)
{
MOZ_ASSERT
(
onFulfilled
.
isNumber
(
)
|
|
onFulfilled
.
isObject
(
)
)
;
MOZ_ASSERT
(
onRejected
.
isNumber
(
)
|
|
onRejected
.
isObject
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
promise
)
return
false
;
if
(
!
ResolvePromiseInternal
(
cx
promise
value
)
)
return
false
;
RootedObject
incumbentGlobal
(
cx
)
;
if
(
!
GetObjectFromIncumbentGlobal
(
cx
&
incumbentGlobal
)
)
return
false
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultPromise
onFulfilled
onRejected
nullptr
nullptr
incumbentGlobal
)
)
;
if
(
!
reaction
)
return
false
;
extraStep
(
reaction
)
;
return
PerformPromiseThenWithReaction
(
cx
promise
reaction
)
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncFunctionAwait
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
resultPromise
HandleValue
value
)
{
RootedValue
onFulfilled
(
cx
Int32Value
(
PromiseHandlerAsyncFunctionAwaitedFulfilled
)
)
;
RootedValue
onRejected
(
cx
Int32Value
(
PromiseHandlerAsyncFunctionAwaitedRejected
)
)
;
auto
extra
=
[
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncFunction
(
)
;
}
;
return
InternalAwait
(
cx
value
resultPromise
onFulfilled
onRejected
extra
)
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncGeneratorAwait
(
JSContext
*
cx
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
HandleValue
value
)
{
RootedValue
onFulfilled
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorAwaitedFulfilled
)
)
;
RootedValue
onRejected
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorAwaitedRejected
)
)
;
auto
extra
=
[
&
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncGenerator
(
asyncGenObj
)
;
}
;
return
InternalAwait
(
cx
value
nullptr
onFulfilled
onRejected
extra
)
;
}
bool
js
:
:
AsyncFromSyncIteratorMethod
(
JSContext
*
cx
CallArgs
&
args
CompletionKind
completionKind
)
{
RootedValue
thisVal
(
cx
args
.
thisv
(
)
)
;
RootedObject
resultPromise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
resultPromise
)
return
false
;
if
(
!
thisVal
.
isObject
(
)
|
|
!
thisVal
.
toObject
(
)
.
is
<
AsyncFromSyncIteratorObject
>
(
)
)
{
RootedValue
badGeneratorError
(
cx
)
;
if
(
!
GetTypeError
(
cx
JSMSG_NOT_AN_ASYNC_ITERATOR
&
badGeneratorError
)
)
return
false
;
if
(
!
RejectMaybeWrappedPromise
(
cx
resultPromise
badGeneratorError
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
Rooted
<
AsyncFromSyncIteratorObject
*
>
asyncIter
(
cx
&
thisVal
.
toObject
(
)
.
as
<
AsyncFromSyncIteratorObject
>
(
)
)
;
RootedObject
iter
(
cx
asyncIter
-
>
iterator
(
)
)
;
RootedValue
resultVal
(
cx
)
;
RootedValue
func
(
cx
)
;
if
(
completionKind
=
=
CompletionKind
:
:
Normal
)
{
if
(
!
GetProperty
(
cx
iter
iter
cx
-
>
names
(
)
.
next
&
func
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
else
if
(
completionKind
=
=
CompletionKind
:
:
Return
)
{
if
(
!
GetProperty
(
cx
iter
iter
cx
-
>
names
(
)
.
return_
&
func
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
if
(
func
.
isNullOrUndefined
(
)
)
{
RootedObject
resultObj
(
cx
CreateIterResultObject
(
cx
args
.
get
(
0
)
true
)
)
;
if
(
!
resultObj
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
RootedValue
resultVal
(
cx
ObjectValue
(
*
resultObj
)
)
;
if
(
!
ResolvePromiseInternal
(
cx
resultPromise
resultVal
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
completionKind
=
=
CompletionKind
:
:
Throw
)
;
if
(
!
GetProperty
(
cx
iter
iter
cx
-
>
names
(
)
.
throw_
&
func
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
if
(
func
.
isNullOrUndefined
(
)
)
{
if
(
!
RejectMaybeWrappedPromise
(
cx
resultPromise
args
.
get
(
0
)
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
}
RootedValue
iterVal
(
cx
ObjectValue
(
*
iter
)
)
;
FixedInvokeArgs
<
1
>
args2
(
cx
)
;
args2
[
0
]
.
set
(
args
.
get
(
0
)
)
;
if
(
!
js
:
:
Call
(
cx
func
iterVal
args2
&
resultVal
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
if
(
!
resultVal
.
isObject
(
)
)
{
CheckIsObjectKind
kind
;
switch
(
completionKind
)
{
case
CompletionKind
:
:
Normal
:
kind
=
CheckIsObjectKind
:
:
IteratorNext
;
break
;
case
CompletionKind
:
:
Throw
:
kind
=
CheckIsObjectKind
:
:
IteratorThrow
;
break
;
case
CompletionKind
:
:
Return
:
kind
=
CheckIsObjectKind
:
:
IteratorReturn
;
break
;
}
MOZ_ALWAYS_FALSE
(
ThrowCheckIsObject
(
cx
kind
)
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
RootedObject
resultObj
(
cx
&
resultVal
.
toObject
(
)
)
;
RootedValue
doneVal
(
cx
)
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
done
&
doneVal
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
bool
done
=
ToBoolean
(
doneVal
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
value
&
value
)
)
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
RootedValue
onFulfilled
(
cx
Int32Value
(
done
?
PromiseHandlerAsyncFromSyncIteratorValueUnwrapDone
:
PromiseHandlerAsyncFromSyncIteratorValueUnwrapNotDone
)
)
;
RootedValue
onRejected
(
cx
Int32Value
(
PromiseHandlerThrower
)
)
;
auto
extra
=
[
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
}
;
if
(
!
InternalAwait
(
cx
value
resultPromise
onFulfilled
onRejected
extra
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
AsyncGeneratorResumeNext
(
JSContext
*
cx
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
)
;
MOZ_MUST_USE
bool
js
:
:
AsyncGeneratorResolve
(
JSContext
*
cx
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
HandleValue
value
bool
done
)
{
MOZ_ASSERT
(
!
asyncGenObj
-
>
isQueueEmpty
(
)
)
;
Rooted
<
AsyncGeneratorRequest
*
>
request
(
cx
AsyncGeneratorObject
:
:
dequeueRequest
(
cx
asyncGenObj
)
)
;
if
(
!
request
)
return
false
;
RootedObject
resultPromise
(
cx
request
-
>
promise
(
)
)
;
RootedObject
resultObj
(
cx
CreateIterResultObject
(
cx
value
done
)
)
;
if
(
!
resultObj
)
return
false
;
RootedValue
resultValue
(
cx
ObjectValue
(
*
resultObj
)
)
;
if
(
!
ResolvePromiseInternal
(
cx
resultPromise
resultValue
)
)
return
false
;
if
(
!
AsyncGeneratorResumeNext
(
cx
asyncGenObj
)
)
return
false
;
return
true
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncGeneratorReject
(
JSContext
*
cx
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
HandleValue
exception
)
{
MOZ_ASSERT
(
!
asyncGenObj
-
>
isQueueEmpty
(
)
)
;
Rooted
<
AsyncGeneratorRequest
*
>
request
(
cx
AsyncGeneratorObject
:
:
dequeueRequest
(
cx
asyncGenObj
)
)
;
if
(
!
request
)
return
false
;
RootedObject
resultPromise
(
cx
request
-
>
promise
(
)
)
;
if
(
!
RejectMaybeWrappedPromise
(
cx
resultPromise
exception
)
)
return
false
;
if
(
!
AsyncGeneratorResumeNext
(
cx
asyncGenObj
)
)
return
false
;
return
true
;
}
static
MOZ_MUST_USE
bool
AsyncGeneratorResumeNext
(
JSContext
*
cx
Handle
<
AsyncGeneratorObject
*
>
asyncGenObj
)
{
MOZ_ASSERT
(
!
asyncGenObj
-
>
isExecuting
(
)
)
;
if
(
asyncGenObj
-
>
isAwaitingYieldReturn
(
)
|
|
asyncGenObj
-
>
isAwaitingReturn
(
)
)
return
true
;
if
(
asyncGenObj
-
>
isQueueEmpty
(
)
)
return
true
;
Rooted
<
AsyncGeneratorRequest
*
>
request
(
cx
AsyncGeneratorObject
:
:
peekRequest
(
cx
asyncGenObj
)
)
;
if
(
!
request
)
return
false
;
CompletionKind
completionKind
=
request
-
>
completionKind
(
)
;
if
(
completionKind
!
=
CompletionKind
:
:
Normal
)
{
if
(
asyncGenObj
-
>
isSuspendedStart
(
)
)
asyncGenObj
-
>
setCompleted
(
)
;
if
(
asyncGenObj
-
>
isCompleted
(
)
)
{
RootedValue
value
(
cx
request
-
>
completionValue
(
)
)
;
if
(
completionKind
=
=
CompletionKind
:
:
Return
)
{
asyncGenObj
-
>
setAwaitingReturn
(
)
;
RootedValue
onFulfilled
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorResumeNextReturnFulfilled
)
)
;
RootedValue
onRejected
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorResumeNextReturnRejected
)
)
;
auto
extra
=
[
&
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncGenerator
(
asyncGenObj
)
;
}
;
return
InternalAwait
(
cx
value
nullptr
onFulfilled
onRejected
extra
)
;
}
MOZ_ASSERT
(
completionKind
=
=
CompletionKind
:
:
Throw
)
;
return
AsyncGeneratorReject
(
cx
asyncGenObj
value
)
;
}
}
else
if
(
asyncGenObj
-
>
isCompleted
(
)
)
{
return
AsyncGeneratorResolve
(
cx
asyncGenObj
UndefinedHandleValue
true
)
;
}
MOZ_ASSERT
(
asyncGenObj
-
>
isSuspendedStart
(
)
|
|
asyncGenObj
-
>
isSuspendedYield
(
)
)
;
asyncGenObj
-
>
setExecuting
(
)
;
RootedValue
argument
(
cx
request
-
>
completionValue
(
)
)
;
if
(
completionKind
=
=
CompletionKind
:
:
Return
)
{
asyncGenObj
-
>
setAwaitingYieldReturn
(
)
;
RootedValue
onFulfilled
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorYieldReturnAwaitedFulfilled
)
)
;
RootedValue
onRejected
(
cx
Int32Value
(
PromiseHandlerAsyncGeneratorYieldReturnAwaitedRejected
)
)
;
auto
extra
=
[
&
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncGenerator
(
asyncGenObj
)
;
}
;
return
InternalAwait
(
cx
argument
nullptr
onFulfilled
onRejected
extra
)
;
}
return
AsyncGeneratorResume
(
cx
asyncGenObj
completionKind
argument
)
;
}
MOZ_MUST_USE
bool
js
:
:
AsyncGeneratorEnqueue
(
JSContext
*
cx
HandleValue
asyncGenVal
CompletionKind
completionKind
HandleValue
completionValue
MutableHandleValue
result
)
{
RootedObject
resultPromise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
resultPromise
)
return
false
;
if
(
!
asyncGenVal
.
isObject
(
)
|
|
!
asyncGenVal
.
toObject
(
)
.
is
<
AsyncGeneratorObject
>
(
)
)
{
RootedValue
badGeneratorError
(
cx
)
;
if
(
!
GetTypeError
(
cx
JSMSG_NOT_AN_ASYNC_GENERATOR
&
badGeneratorError
)
)
return
false
;
if
(
!
RejectMaybeWrappedPromise
(
cx
resultPromise
badGeneratorError
)
)
return
false
;
result
.
setObject
(
*
resultPromise
)
;
return
true
;
}
Rooted
<
AsyncGeneratorObject
*
>
asyncGenObj
(
cx
&
asyncGenVal
.
toObject
(
)
.
as
<
AsyncGeneratorObject
>
(
)
)
;
Rooted
<
AsyncGeneratorRequest
*
>
request
(
cx
AsyncGeneratorRequest
:
:
create
(
cx
completionKind
completionValue
resultPromise
)
)
;
if
(
!
request
)
return
false
;
if
(
!
AsyncGeneratorObject
:
:
enqueueRequest
(
cx
asyncGenObj
request
)
)
return
false
;
if
(
!
asyncGenObj
-
>
isExecuting
(
)
)
{
if
(
!
AsyncGeneratorResumeNext
(
cx
asyncGenObj
)
)
return
false
;
}
result
.
setObject
(
*
resultPromise
)
;
return
true
;
}
bool
js
:
:
Promise_then
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
promiseVal
(
cx
args
.
thisv
(
)
)
;
RootedValue
onFulfilled
(
cx
args
.
get
(
0
)
)
;
RootedValue
onRejected
(
cx
args
.
get
(
1
)
)
;
if
(
!
promiseVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_NONNULL_OBJECT
"
Receiver
of
Promise
.
prototype
.
then
call
"
)
;
return
false
;
}
RootedObject
promiseObj
(
cx
&
promiseVal
.
toObject
(
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
bool
isPromise
=
promiseObj
-
>
is
<
PromiseObject
>
(
)
;
if
(
isPromise
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
RootedObject
unwrappedPromiseObj
(
cx
CheckedUnwrap
(
promiseObj
)
)
;
if
(
!
unwrappedPromiseObj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
!
unwrappedPromiseObj
-
>
is
<
PromiseObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
"
Promise
"
"
then
"
"
value
"
)
;
return
false
;
}
promise
=
&
unwrappedPromiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
RootedObject
resultPromise
(
cx
)
;
if
(
!
OriginalPromiseThen
(
cx
promise
onFulfilled
onRejected
&
resultPromise
true
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
PerformPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled_
HandleValue
onRejected_
HandleObject
resultPromise
HandleObject
resolve
HandleObject
reject
)
{
RootedValue
onFulfilled
(
cx
onFulfilled_
)
;
if
(
!
IsCallable
(
onFulfilled
)
)
onFulfilled
=
Int32Value
(
PromiseHandlerIdentity
)
;
RootedValue
onRejected
(
cx
onRejected_
)
;
if
(
!
IsCallable
(
onRejected
)
)
onRejected
=
Int32Value
(
PromiseHandlerThrower
)
;
RootedObject
incumbentGlobal
(
cx
)
;
if
(
!
GetObjectFromIncumbentGlobal
(
cx
&
incumbentGlobal
)
)
return
false
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultPromise
onFulfilled
onRejected
resolve
reject
incumbentGlobal
)
)
;
if
(
!
reaction
)
return
false
;
return
PerformPromiseThenWithReaction
(
cx
promise
reaction
)
;
}
static
MOZ_MUST_USE
bool
PerformPromiseThenWithReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
JS
:
:
PromiseState
state
=
promise
-
>
state
(
)
;
int32_t
flags
=
promise
-
>
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Pending
)
{
if
(
!
AddPromiseReaction
(
cx
promise
reaction
)
)
return
false
;
}
else
{
MOZ_ASSERT_IF
(
state
!
=
JS
:
:
PromiseState
:
:
Fulfilled
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
valueOrReason
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
valueOrReason
)
)
return
false
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Rejected
&
&
!
(
flags
&
PROMISE_FLAG_HANDLED
)
)
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
promise
)
;
if
(
!
EnqueuePromiseReactionJob
(
cx
reaction
valueOrReason
state
)
)
return
false
;
}
promise
-
>
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
|
PROMISE_FLAG_HANDLED
)
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
BlockOnPromise
(
JSContext
*
cx
HandleValue
promiseVal
HandleObject
blockedPromise_
HandleValue
onFulfilled
HandleValue
onRejected
)
{
RootedObject
promiseObj
(
cx
ToObject
(
cx
promiseVal
)
)
;
if
(
!
promiseObj
)
return
false
;
RootedValue
thenVal
(
cx
)
;
if
(
!
GetProperty
(
cx
promiseObj
promiseVal
cx
-
>
names
(
)
.
then
&
thenVal
)
)
return
false
;
if
(
promiseObj
-
>
is
<
PromiseObject
>
(
)
&
&
IsNativeFunction
(
thenVal
Promise_then
)
)
{
RootedObject
PromiseCtor
(
cx
)
;
if
(
!
GetBuiltinConstructor
(
cx
JSProto_Promise
&
PromiseCtor
)
)
return
false
;
RootedObject
C
(
cx
SpeciesConstructor
(
cx
promiseObj
JSProto_Promise
IsPromiseSpecies
)
)
;
if
(
!
C
)
return
false
;
RootedObject
resultPromise
(
cx
blockedPromise_
)
;
RootedObject
resolveFun
(
cx
)
;
RootedObject
rejectFun
(
cx
)
;
bool
addToDependent
=
true
;
if
(
C
=
=
PromiseCtor
)
{
addToDependent
=
false
;
}
else
{
if
(
!
NewPromiseCapability
(
cx
C
&
resultPromise
&
resolveFun
&
rejectFun
true
)
)
return
false
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
)
;
if
(
!
PerformPromiseThen
(
cx
promise
onFulfilled
onRejected
resultPromise
resolveFun
rejectFun
)
)
{
return
false
;
}
if
(
!
addToDependent
)
return
true
;
}
else
{
RootedValue
rval
(
cx
)
;
if
(
!
Call
(
cx
thenVal
promiseVal
onFulfilled
onRejected
&
rval
)
)
return
false
;
}
if
(
!
promiseVal
.
isObject
(
)
)
return
true
;
RootedObject
unwrappedPromiseObj
(
cx
promiseObj
)
;
RootedObject
blockedPromise
(
cx
blockedPromise_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
IsProxy
(
promiseObj
)
)
{
unwrappedPromiseObj
=
CheckedUnwrap
(
promiseObj
)
;
if
(
!
unwrappedPromiseObj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
JS_IsDeadWrapper
(
unwrappedPromiseObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
ac
.
emplace
(
cx
unwrappedPromiseObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
blockedPromise
)
)
return
false
;
}
if
(
!
unwrappedPromiseObj
-
>
is
<
PromiseObject
>
(
)
)
return
true
;
Rooted
<
PromiseObject
*
>
promise
(
cx
&
unwrappedPromiseObj
-
>
as
<
PromiseObject
>
(
)
)
;
return
AddPromiseReaction
(
cx
promise
UndefinedHandleValue
UndefinedHandleValue
blockedPromise
nullptr
nullptr
nullptr
)
;
}
static
MOZ_MUST_USE
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
MOZ_RELEASE_ASSERT
(
reaction
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
RootedValue
reactionVal
(
cx
ObjectValue
(
*
reaction
)
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
promise
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ac
.
emplace
(
cx
promise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reactionVal
)
)
return
false
;
}
RootedValue
reactionsVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
)
;
RootedNativeObject
reactions
(
cx
)
;
if
(
reactionsVal
.
isUndefined
(
)
)
{
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
reactionVal
)
;
return
true
;
}
RootedObject
reactionsObj
(
cx
&
reactionsVal
.
toObject
(
)
)
;
if
(
IsProxy
(
reactionsObj
)
)
{
reactionsObj
=
UncheckedUnwrap
(
reactionsObj
)
;
if
(
JS_IsDeadWrapper
(
reactionsObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
reactionsObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
}
if
(
reactionsObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
{
reactions
=
NewDenseFullyAllocatedArray
(
cx
2
)
;
if
(
!
reactions
)
return
false
;
if
(
reactions
-
>
ensureDenseElements
(
cx
0
2
)
!
=
DenseElementResult
:
:
Success
)
return
false
;
reactions
-
>
setDenseElement
(
0
reactionsVal
)
;
reactions
-
>
setDenseElement
(
1
reactionVal
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
ObjectValue
(
*
reactions
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
reactionsObj
-
>
is
<
NativeObject
>
(
)
)
;
reactions
=
&
reactionsObj
-
>
as
<
NativeObject
>
(
)
;
uint32_t
len
=
reactions
-
>
getDenseInitializedLength
(
)
;
if
(
reactions
-
>
ensureDenseElements
(
cx
0
len
+
1
)
!
=
DenseElementResult
:
:
Success
)
return
false
;
reactions
-
>
setDenseElement
(
len
reactionVal
)
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled
HandleValue
onRejected
HandleObject
dependentPromise
HandleObject
resolve
HandleObject
reject
HandleObject
incumbentGlobal
)
{
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
return
true
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
dependentPromise
onFulfilled
onRejected
resolve
reject
incumbentGlobal
)
)
;
if
(
!
reaction
)
return
false
;
return
AddPromiseReaction
(
cx
promise
reaction
)
;
}
uint64_t
PromiseObject
:
:
getID
(
)
{
return
PromiseDebugInfo
:
:
id
(
this
)
;
}
double
PromiseObject
:
:
lifetime
(
)
{
return
MillisecondsSinceStartup
(
)
-
allocationTime
(
)
;
}
bool
PromiseObject
:
:
dependentPromises
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
values
)
{
if
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
return
true
;
RootedValue
reactionsVal
(
cx
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
)
;
if
(
reactionsVal
.
isNullOrUndefined
(
)
)
return
true
;
RootedNativeObject
reactions
(
cx
&
reactionsVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
reactions
-
>
is
<
PromiseReactionRecord
>
(
)
)
{
RootedObject
promiseObj
(
cx
reactions
-
>
as
<
PromiseReactionRecord
>
(
)
.
promise
(
)
)
;
if
(
!
promiseObj
)
return
true
;
if
(
!
values
.
growBy
(
1
)
)
return
false
;
values
[
0
]
.
setObject
(
*
promiseObj
)
;
return
true
;
}
uint32_t
len
=
reactions
-
>
getDenseInitializedLength
(
)
;
MOZ_ASSERT
(
len
>
=
2
)
;
size_t
valuesIndex
=
0
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
reaction
=
&
reactions
-
>
getDenseElement
(
i
)
.
toObject
(
)
.
as
<
PromiseReactionRecord
>
(
)
;
RootedObject
promiseObj
(
cx
reaction
-
>
promise
(
)
)
;
if
(
!
promiseObj
)
continue
;
if
(
!
values
.
growBy
(
1
)
)
return
false
;
values
[
valuesIndex
+
+
]
.
setObject
(
*
promiseObj
)
;
}
return
true
;
}
bool
PromiseObject
:
:
resolve
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
resolutionValue
)
{
MOZ_ASSERT
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_ASYNC
)
)
;
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
return
true
;
if
(
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVE_FUNCTION
)
)
return
ResolvePromiseInternal
(
cx
promise
resolutionValue
)
;
RootedObject
resolveFun
(
cx
GetResolveFunctionFromPromise
(
promise
)
)
;
RootedValue
funVal
(
cx
ObjectValue
(
*
resolveFun
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
funVal
)
)
return
false
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
resolutionValue
)
;
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
args
&
dummy
)
;
}
bool
PromiseObject
:
:
reject
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
rejectionValue
)
{
MOZ_ASSERT
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_ASYNC
)
)
;
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
return
true
;
if
(
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_REJECT_FUNCTION
)
)
return
ResolvePromise
(
cx
promise
rejectionValue
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
funVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_RejectFunction
)
)
;
MOZ_ASSERT
(
IsCallable
(
funVal
)
)
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
rejectionValue
)
;
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
args
&
dummy
)
;
}
void
PromiseObject
:
:
onSettled
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
PromiseDebugInfo
:
:
setResolutionInfo
(
cx
promise
)
;
if
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
&
&
promise
-
>
isUnhandled
(
)
)
cx
-
>
runtime
(
)
-
>
addUnhandledRejectedPromise
(
cx
promise
)
;
Debugger
:
:
onPromiseSettled
(
cx
promise
)
;
}
OffThreadPromiseTask
:
:
OffThreadPromiseTask
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
:
runtime_
(
cx
-
>
runtime
(
)
)
promise_
(
cx
promise
)
registered_
(
false
)
{
MOZ_ASSERT
(
runtime_
=
=
promise_
-
>
zone
(
)
-
>
runtimeFromActiveCooperatingThread
(
)
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
offThreadPromiseState
.
ref
(
)
.
initialized
(
)
)
;
}
OffThreadPromiseTask
:
:
~
OffThreadPromiseTask
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
if
(
registered_
)
{
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
state
.
live_
.
remove
(
this
)
;
}
}
bool
OffThreadPromiseTask
:
:
init
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
=
=
runtime_
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
if
(
!
state
.
live_
.
putNew
(
this
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
registered_
=
true
;
return
true
;
}
void
OffThreadPromiseTask
:
:
run
(
JSContext
*
cx
MaybeShuttingDown
maybeShuttingDown
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
=
=
runtime_
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
MOZ_ASSERT
(
registered_
)
;
MOZ_ASSERT
(
runtime_
-
>
offThreadPromiseState
.
ref
(
)
.
initialized
(
)
)
;
if
(
maybeShuttingDown
=
=
JS
:
:
Dispatchable
:
:
NotShuttingDown
)
{
AutoCompartment
ac
(
cx
promise_
)
;
if
(
!
resolve
(
cx
promise_
)
)
cx
-
>
clearPendingException
(
)
;
}
js_delete
(
this
)
;
}
void
OffThreadPromiseTask
:
:
dispatchResolveAndDestroy
(
)
{
MOZ_ASSERT
(
registered_
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
MOZ_ASSERT
(
(
LockGuard
<
Mutex
>
(
state
.
mutex_
)
state
.
live_
.
has
(
this
)
)
)
;
if
(
state
.
dispatchToEventLoopCallback_
(
state
.
dispatchToEventLoopClosure_
this
)
)
return
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
state
.
numCanceled_
+
+
;
if
(
state
.
numCanceled_
=
=
state
.
live_
.
count
(
)
)
state
.
allCanceled_
.
notify_one
(
)
;
}
OffThreadPromiseRuntimeState
:
:
OffThreadPromiseRuntimeState
(
)
:
dispatchToEventLoopCallback_
(
nullptr
)
dispatchToEventLoopClosure_
(
nullptr
)
mutex_
(
mutexid
:
:
OffThreadPromiseState
)
numCanceled_
(
0
)
internalDispatchQueueClosed_
(
false
)
{
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
live_
.
init
(
)
)
noOOM
.
crash
(
"
OffThreadPromiseRuntimeState
"
)
;
}
OffThreadPromiseRuntimeState
:
:
~
OffThreadPromiseRuntimeState
(
)
{
MOZ_ASSERT
(
live_
.
empty
(
)
)
;
MOZ_ASSERT
(
numCanceled_
=
=
0
)
;
MOZ_ASSERT
(
internalDispatchQueue_
.
empty
(
)
)
;
MOZ_ASSERT
(
!
initialized
(
)
)
;
}
void
OffThreadPromiseRuntimeState
:
:
init
(
JS
:
:
DispatchToEventLoopCallback
callback
void
*
closure
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
dispatchToEventLoopCallback_
=
callback
;
dispatchToEventLoopClosure_
=
closure
;
MOZ_ASSERT
(
initialized
(
)
)
;
}
bool
OffThreadPromiseRuntimeState
:
:
internalDispatchToEventLoop
(
void
*
closure
JS
:
:
Dispatchable
*
d
)
{
OffThreadPromiseRuntimeState
&
state
=
*
reinterpret_cast
<
OffThreadPromiseRuntimeState
*
>
(
closure
)
;
MOZ_ASSERT
(
state
.
usingInternalDispatchQueue
(
)
)
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
if
(
state
.
internalDispatchQueueClosed_
)
return
false
;
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
state
.
internalDispatchQueue_
.
append
(
d
)
)
noOOM
.
crash
(
"
internalDispatchToEventLoop
"
)
;
state
.
internalDispatchQueueAppended_
.
notify_one
(
)
;
return
true
;
}
bool
OffThreadPromiseRuntimeState
:
:
usingInternalDispatchQueue
(
)
const
{
return
dispatchToEventLoopCallback_
=
=
internalDispatchToEventLoop
;
}
void
OffThreadPromiseRuntimeState
:
:
initInternalDispatchQueue
(
)
{
init
(
internalDispatchToEventLoop
this
)
;
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
}
bool
OffThreadPromiseRuntimeState
:
:
initialized
(
)
const
{
return
!
!
dispatchToEventLoopCallback_
;
}
void
OffThreadPromiseRuntimeState
:
:
internalDrain
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
MOZ_ASSERT
(
!
internalDispatchQueueClosed_
)
;
while
(
true
)
{
DispatchableVector
dispatchQueue
;
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
MOZ_ASSERT_IF
(
!
internalDispatchQueue_
.
empty
(
)
!
live_
.
empty
(
)
)
;
if
(
live_
.
empty
(
)
)
return
;
while
(
internalDispatchQueue_
.
empty
(
)
)
internalDispatchQueueAppended_
.
wait
(
lock
)
;
Swap
(
dispatchQueue
internalDispatchQueue_
)
;
MOZ_ASSERT
(
internalDispatchQueue_
.
empty
(
)
)
;
}
for
(
JS
:
:
Dispatchable
*
d
:
dispatchQueue
)
d
-
>
run
(
cx
JS
:
:
Dispatchable
:
:
NotShuttingDown
)
;
}
}
bool
OffThreadPromiseRuntimeState
:
:
internalHasPending
(
)
{
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
MOZ_ASSERT
(
!
internalDispatchQueueClosed_
)
;
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
MOZ_ASSERT_IF
(
!
internalDispatchQueue_
.
empty
(
)
!
live_
.
empty
(
)
)
;
return
!
live_
.
empty
(
)
;
}
void
OffThreadPromiseRuntimeState
:
:
shutdown
(
JSContext
*
cx
)
{
if
(
!
initialized
(
)
)
return
;
if
(
usingInternalDispatchQueue
(
)
)
{
DispatchableVector
dispatchQueue
;
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
Swap
(
dispatchQueue
internalDispatchQueue_
)
;
MOZ_ASSERT
(
internalDispatchQueue_
.
empty
(
)
)
;
internalDispatchQueueClosed_
=
true
;
}
for
(
JS
:
:
Dispatchable
*
d
:
dispatchQueue
)
d
-
>
run
(
cx
JS
:
:
Dispatchable
:
:
ShuttingDown
)
;
}
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
while
(
live_
.
count
(
)
!
=
numCanceled_
)
{
MOZ_ASSERT
(
numCanceled_
<
live_
.
count
(
)
)
;
allCanceled_
.
wait
(
lock
)
;
}
}
for
(
OffThreadPromiseTaskSet
:
:
Range
r
=
live_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
OffThreadPromiseTask
*
task
=
r
.
front
(
)
;
MOZ_ASSERT
(
task
-
>
registered_
)
;
task
-
>
registered_
=
false
;
js_delete
(
task
)
;
}
live_
.
clear
(
)
;
numCanceled_
=
0
;
dispatchToEventLoopCallback_
=
nullptr
;
MOZ_ASSERT
(
!
initialized
(
)
)
;
}
static
JSObject
*
CreatePromisePrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
GlobalObject
:
:
createBlankPrototype
(
cx
cx
-
>
global
(
)
&
PromiseObject
:
:
protoClass_
)
;
}
static
const
JSFunctionSpec
promise_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
catch
"
"
Promise_catch
"
1
0
)
JS_FN
(
"
then
"
Promise_then
2
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
promise_properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Promise
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
JSFunctionSpec
promise_static_methods
[
]
=
{
JS_FN
(
"
all
"
Promise_static_all
1
0
)
JS_FN
(
"
race
"
Promise_static_race
1
0
)
JS_FN
(
"
reject
"
Promise_reject
1
0
)
JS_FN
(
"
resolve
"
Promise_static_resolve
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
promise_static_properties
[
]
=
{
JS_SYM_GET
(
species
Promise_static_species
0
)
JS_PS_END
}
;
static
const
ClassSpec
PromiseObjectClassSpec
=
{
GenericCreateConstructor
<
PromiseConstructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
CreatePromisePrototype
promise_static_methods
promise_static_properties
promise_methods
promise_properties
}
;
const
Class
PromiseObject
:
:
class_
=
{
"
Promise
"
JSCLASS_HAS_RESERVED_SLOTS
(
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
|
JSCLASS_HAS_XRAYED_CONSTRUCTOR
JS_NULL_CLASS_OPS
&
PromiseObjectClassSpec
}
;
const
Class
PromiseObject
:
:
protoClass_
=
{
"
PromiseProto
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
JS_NULL_CLASS_OPS
&
PromiseObjectClassSpec
}
;
