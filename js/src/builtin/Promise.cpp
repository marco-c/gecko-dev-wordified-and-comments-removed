#
include
"
builtin
/
Promise
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
experimental
/
JitInfo
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
AsyncFunction
.
h
"
#
include
"
vm
/
AsyncIteration
.
h
"
#
include
"
vm
/
CompletionKind
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
GeneratorObject
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
PromiseLookup
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Warnings
.
h
"
#
include
"
debugger
/
DebugAPI
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
ErrorObject
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
double
MillisecondsSinceStartup
(
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
return
(
now
-
mozilla
:
:
TimeStamp
:
:
FirstTimeStamp
(
)
)
.
ToMilliseconds
(
)
;
}
enum
ResolutionMode
{
ResolveMode
RejectMode
}
;
enum
ResolveFunctionSlots
{
ResolveFunctionSlot_Promise
=
0
ResolveFunctionSlot_RejectFunction
}
;
enum
RejectFunctionSlots
{
RejectFunctionSlot_Promise
=
0
RejectFunctionSlot_ResolveFunction
}
;
enum
PromiseCombinatorElementFunctionSlots
{
PromiseCombinatorElementFunctionSlot_Data
=
0
PromiseCombinatorElementFunctionSlot_ElementIndex
}
;
enum
ReactionJobSlots
{
ReactionJobSlot_ReactionRecord
=
0
}
;
enum
ThenableJobSlots
{
ThenableJobSlot_Handler
=
0
ThenableJobSlot_JobData
}
;
enum
ThenableJobDataIndices
{
ThenableJobDataIndex_Promise
=
0
ThenableJobDataIndex_Thenable
ThenableJobDataLength
}
;
enum
BuiltinThenableJobSlots
{
BuiltinThenableJobSlot_Promise
=
0
BuiltinThenableJobSlot_Thenable
}
;
struct
PromiseCapability
{
JSObject
*
promise
=
nullptr
;
JSObject
*
resolve
=
nullptr
;
JSObject
*
reject
=
nullptr
;
PromiseCapability
(
)
=
default
;
void
trace
(
JSTracer
*
trc
)
;
}
;
void
PromiseCapability
:
:
trace
(
JSTracer
*
trc
)
{
if
(
promise
)
{
TraceRoot
(
trc
&
promise
"
PromiseCapability
:
:
promise
"
)
;
}
if
(
resolve
)
{
TraceRoot
(
trc
&
resolve
"
PromiseCapability
:
:
resolve
"
)
;
}
if
(
reject
)
{
TraceRoot
(
trc
&
reject
"
PromiseCapability
:
:
reject
"
)
;
}
}
namespace
js
{
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
PromiseCapability
Wrapper
>
{
const
PromiseCapability
&
capability
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
HandleObject
promise
(
)
const
{
return
HandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
promise
)
;
}
HandleObject
resolve
(
)
const
{
return
HandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
resolve
)
;
}
HandleObject
reject
(
)
const
{
return
HandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
reject
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
PromiseCapability
Wrapper
>
:
public
WrappedPtrOperations
<
PromiseCapability
Wrapper
>
{
PromiseCapability
&
capability
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
MutableHandleObject
promise
(
)
{
return
MutableHandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
promise
)
;
}
MutableHandleObject
resolve
(
)
{
return
MutableHandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
resolve
)
;
}
MutableHandleObject
reject
(
)
{
return
MutableHandleObject
:
:
fromMarkedLocation
(
&
capability
(
)
.
reject
)
;
}
}
;
}
struct
PromiseCombinatorElements
;
class
PromiseCombinatorDataHolder
:
public
NativeObject
{
enum
{
Slot_Promise
=
0
Slot_RemainingElements
Slot_ValuesArray
Slot_ResolveOrRejectFunction
SlotsCount
}
;
public
:
static
const
JSClass
class_
;
JSObject
*
promiseObj
(
)
{
return
&
getFixedSlot
(
Slot_Promise
)
.
toObject
(
)
;
}
JSObject
*
resolveOrRejectObj
(
)
{
return
&
getFixedSlot
(
Slot_ResolveOrRejectFunction
)
.
toObject
(
)
;
}
Value
valuesArray
(
)
{
return
getFixedSlot
(
Slot_ValuesArray
)
;
}
int32_t
remainingCount
(
)
{
return
getFixedSlot
(
Slot_RemainingElements
)
.
toInt32
(
)
;
}
int32_t
increaseRemainingCount
(
)
{
int32_t
remainingCount
=
getFixedSlot
(
Slot_RemainingElements
)
.
toInt32
(
)
;
remainingCount
+
+
;
setFixedSlot
(
Slot_RemainingElements
Int32Value
(
remainingCount
)
)
;
return
remainingCount
;
}
int32_t
decreaseRemainingCount
(
)
{
int32_t
remainingCount
=
getFixedSlot
(
Slot_RemainingElements
)
.
toInt32
(
)
;
remainingCount
-
-
;
MOZ_ASSERT
(
remainingCount
>
=
0
"
unpaired
calls
to
decreaseRemainingCount
"
)
;
setFixedSlot
(
Slot_RemainingElements
Int32Value
(
remainingCount
)
)
;
return
remainingCount
;
}
static
PromiseCombinatorDataHolder
*
New
(
JSContext
*
cx
HandleObject
resultPromise
Handle
<
PromiseCombinatorElements
>
elements
HandleObject
resolveOrReject
)
;
}
;
const
JSClass
PromiseCombinatorDataHolder
:
:
class_
=
{
"
PromiseCombinatorDataHolder
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotsCount
)
}
;
struct
MOZ_STACK_CLASS
PromiseCombinatorElements
final
{
Value
value
;
ArrayObject
*
unwrappedArray
=
nullptr
;
bool
setElementNeedsWrapping
=
false
;
PromiseCombinatorElements
(
)
=
default
;
void
trace
(
JSTracer
*
trc
)
;
}
;
void
PromiseCombinatorElements
:
:
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
value
"
PromiseCombinatorElements
:
:
value
"
)
;
if
(
unwrappedArray
)
{
TraceRoot
(
trc
&
unwrappedArray
"
PromiseCombinatorElements
:
:
unwrappedArray
"
)
;
}
}
namespace
js
{
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
PromiseCombinatorElements
Wrapper
>
{
const
PromiseCombinatorElements
&
elements
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
HandleValue
value
(
)
const
{
return
HandleValue
:
:
fromMarkedLocation
(
&
elements
(
)
.
value
)
;
}
Handle
<
ArrayObject
*
>
unwrappedArray
(
)
const
{
return
Handle
<
ArrayObject
*
>
:
:
fromMarkedLocation
(
&
elements
(
)
.
unwrappedArray
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
PromiseCombinatorElements
Wrapper
>
:
public
WrappedPtrOperations
<
PromiseCombinatorElements
Wrapper
>
{
PromiseCombinatorElements
&
elements
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
MutableHandleValue
value
(
)
{
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
elements
(
)
.
value
)
;
}
MutableHandle
<
ArrayObject
*
>
unwrappedArray
(
)
{
return
MutableHandle
<
ArrayObject
*
>
:
:
fromMarkedLocation
(
&
elements
(
)
.
unwrappedArray
)
;
}
void
initialize
(
ArrayObject
*
arrayObj
)
{
unwrappedArray
(
)
.
set
(
arrayObj
)
;
value
(
)
.
setObject
(
*
arrayObj
)
;
}
void
initialize
(
PromiseCombinatorDataHolder
*
data
ArrayObject
*
arrayObj
bool
needsWrapping
)
{
unwrappedArray
(
)
.
set
(
arrayObj
)
;
value
(
)
.
set
(
data
-
>
valuesArray
(
)
)
;
elements
(
)
.
setElementNeedsWrapping
=
needsWrapping
;
}
[
[
nodiscard
]
]
bool
pushUndefined
(
JSContext
*
cx
)
{
AutoRealm
ar
(
cx
unwrappedArray
(
)
)
;
Handle
<
ArrayObject
*
>
arrayObj
=
unwrappedArray
(
)
;
return
js
:
:
NewbornArrayPush
(
cx
arrayObj
UndefinedValue
(
)
)
;
}
[
[
nodiscard
]
]
bool
setElement
(
JSContext
*
cx
uint32_t
index
HandleValue
val
)
{
MOZ_ASSERT
(
unwrappedArray
(
)
-
>
getDenseElement
(
index
)
.
isUndefined
(
)
)
;
if
(
elements
(
)
.
setElementNeedsWrapping
)
{
AutoRealm
ar
(
cx
unwrappedArray
(
)
)
;
RootedValue
rootedVal
(
cx
val
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
rootedVal
)
)
{
return
false
;
}
unwrappedArray
(
)
-
>
setDenseElement
(
index
rootedVal
)
;
}
else
{
unwrappedArray
(
)
-
>
setDenseElement
(
index
val
)
;
}
return
true
;
}
}
;
}
PromiseCombinatorDataHolder
*
PromiseCombinatorDataHolder
:
:
New
(
JSContext
*
cx
HandleObject
resultPromise
Handle
<
PromiseCombinatorElements
>
elements
HandleObject
resolveOrReject
)
{
auto
*
dataHolder
=
NewBuiltinClassInstance
<
PromiseCombinatorDataHolder
>
(
cx
)
;
if
(
!
dataHolder
)
{
return
nullptr
;
}
cx
-
>
check
(
resultPromise
)
;
cx
-
>
check
(
elements
.
value
(
)
)
;
cx
-
>
check
(
resolveOrReject
)
;
dataHolder
-
>
setFixedSlot
(
Slot_Promise
ObjectValue
(
*
resultPromise
)
)
;
dataHolder
-
>
setFixedSlot
(
Slot_RemainingElements
Int32Value
(
1
)
)
;
dataHolder
-
>
setFixedSlot
(
Slot_ValuesArray
elements
.
value
(
)
)
;
dataHolder
-
>
setFixedSlot
(
Slot_ResolveOrRejectFunction
ObjectValue
(
*
resolveOrReject
)
)
;
return
dataHolder
;
}
namespace
{
mozilla
:
:
Atomic
<
uint64_t
>
gIDGenerator
(
0
)
;
}
class
PromiseDebugInfo
:
public
NativeObject
{
private
:
enum
Slots
{
Slot_AllocationSite
Slot_ResolutionSite
Slot_AllocationTime
Slot_ResolutionTime
Slot_Id
SlotCount
}
;
public
:
static
const
JSClass
class_
;
static
PromiseDebugInfo
*
create
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
Rooted
<
PromiseDebugInfo
*
>
debugInfo
(
cx
NewBuiltinClassInstance
<
PromiseDebugInfo
>
(
cx
)
)
;
if
(
!
debugInfo
)
{
return
nullptr
;
}
RootedObject
stack
(
cx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
{
return
nullptr
;
}
debugInfo
-
>
setFixedSlot
(
Slot_AllocationSite
ObjectOrNullValue
(
stack
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
NullValue
(
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_AllocationTime
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
NumberValue
(
0
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_DebugInfo
ObjectValue
(
*
debugInfo
)
)
;
return
debugInfo
;
}
static
PromiseDebugInfo
*
FromPromise
(
PromiseObject
*
promise
)
{
Value
val
=
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
;
if
(
val
.
isObject
(
)
)
{
return
&
val
.
toObject
(
)
.
as
<
PromiseDebugInfo
>
(
)
;
}
return
nullptr
;
}
static
uint64_t
id
(
PromiseObject
*
promise
)
{
Value
idVal
(
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
)
;
if
(
idVal
.
isUndefined
(
)
)
{
idVal
.
setDouble
(
+
+
gIDGenerator
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_DebugInfo
idVal
)
;
}
else
if
(
idVal
.
isObject
(
)
)
{
PromiseDebugInfo
*
debugInfo
=
FromPromise
(
promise
)
;
idVal
=
debugInfo
-
>
getFixedSlot
(
Slot_Id
)
;
if
(
idVal
.
isUndefined
(
)
)
{
idVal
.
setDouble
(
+
+
gIDGenerator
)
;
debugInfo
-
>
setFixedSlot
(
Slot_Id
idVal
)
;
}
}
return
uint64_t
(
idVal
.
toNumber
(
)
)
;
}
double
allocationTime
(
)
{
return
getFixedSlot
(
Slot_AllocationTime
)
.
toNumber
(
)
;
}
double
resolutionTime
(
)
{
return
getFixedSlot
(
Slot_ResolutionTime
)
.
toNumber
(
)
;
}
JSObject
*
allocationSite
(
)
{
return
getFixedSlot
(
Slot_AllocationSite
)
.
toObjectOrNull
(
)
;
}
JSObject
*
resolutionSite
(
)
{
return
getFixedSlot
(
Slot_ResolutionSite
)
.
toObjectOrNull
(
)
;
}
static
void
setResolutionInfo
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
{
MOZ_ASSERT_IF
(
unwrappedRejectionStack
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
if
(
!
JS
:
:
IsAsyncStackCaptureEnabledForRealm
(
cx
)
)
{
return
;
}
Rooted
<
PromiseDebugInfo
*
>
debugInfo
(
cx
FromPromise
(
promise
)
)
;
if
(
!
debugInfo
)
{
RootedValue
idVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_DebugInfo
)
)
;
debugInfo
=
create
(
cx
promise
)
;
if
(
!
debugInfo
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
debugInfo
-
>
getFixedSlot
(
Slot_AllocationSite
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_AllocationSite
NullValue
(
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
debugInfo
-
>
getFixedSlot
(
Slot_AllocationTime
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_Id
idVal
)
;
return
;
}
RootedObject
stack
(
cx
unwrappedRejectionStack
)
;
if
(
stack
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
stack
)
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
}
else
{
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
}
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionSite
ObjectOrNullValue
(
stack
)
)
;
debugInfo
-
>
setFixedSlot
(
Slot_ResolutionTime
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
}
}
;
const
JSClass
PromiseDebugInfo
:
:
class_
=
{
"
PromiseDebugInfo
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
double
PromiseObject
:
:
allocationTime
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
{
return
debugInfo
-
>
allocationTime
(
)
;
}
return
0
;
}
double
PromiseObject
:
:
resolutionTime
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
{
return
debugInfo
-
>
resolutionTime
(
)
;
}
return
0
;
}
JSObject
*
PromiseObject
:
:
allocationSite
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
{
return
debugInfo
-
>
allocationSite
(
)
;
}
return
nullptr
;
}
JSObject
*
PromiseObject
:
:
resolutionSite
(
)
{
auto
debugInfo
=
PromiseDebugInfo
:
:
FromPromise
(
this
)
;
if
(
debugInfo
)
{
return
debugInfo
-
>
resolutionSite
(
)
;
}
return
nullptr
;
}
static
bool
MaybeGetAndClearExceptionAndStack
(
JSContext
*
cx
MutableHandleValue
rval
MutableHandle
<
SavedFrame
*
>
stack
)
{
if
(
!
cx
-
>
isExceptionPending
(
)
)
{
return
false
;
}
return
GetAndClearExceptionAndStack
(
cx
rval
stack
)
;
}
[
[
nodiscard
]
]
static
bool
CallPromiseRejectFunction
(
JSContext
*
cx
HandleObject
rejectFun
HandleValue
reason
HandleObject
promiseObj
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
UnhandledRejectionBehavior
behavior
)
;
static
bool
AbruptRejectPromise
(
JSContext
*
cx
CallArgs
&
args
HandleObject
promiseObj
HandleObject
reject
)
{
RootedValue
reason
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
reason
&
stack
)
)
{
return
false
;
}
if
(
!
CallPromiseRejectFunction
(
cx
reject
reason
promiseObj
stack
UnhandledRejectionBehavior
:
:
Report
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
promiseObj
)
;
return
true
;
}
static
bool
AbruptRejectPromise
(
JSContext
*
cx
CallArgs
&
args
Handle
<
PromiseCapability
>
capability
)
{
return
AbruptRejectPromise
(
cx
args
capability
.
promise
(
)
capability
.
reject
(
)
)
;
}
enum
ReactionRecordSlots
{
ReactionRecordSlot_Promise
=
0
ReactionRecordSlot_OnFulfilled
ReactionRecordSlot_OnRejectedArg
=
ReactionRecordSlot_OnFulfilled
ReactionRecordSlot_OnRejected
ReactionRecordSlot_OnFulfilledArg
=
ReactionRecordSlot_OnRejected
ReactionRecordSlot_Resolve
ReactionRecordSlot_Reject
ReactionRecordSlot_IncumbentGlobalObject
ReactionRecordSlot_Flags
ReactionRecordSlot_GeneratorOrPromiseToResolve
ReactionRecordSlots
}
;
class
PromiseReactionRecord
:
public
NativeObject
{
static
constexpr
uint32_t
REACTION_FLAG_RESOLVED
=
0x1
;
static
constexpr
uint32_t
REACTION_FLAG_FULFILLED
=
0x2
;
static
constexpr
uint32_t
REACTION_FLAG_DEFAULT_RESOLVING_HANDLER
=
0x4
;
static
constexpr
uint32_t
REACTION_FLAG_ASYNC_FUNCTION
=
0x8
;
static
constexpr
uint32_t
REACTION_FLAG_ASYNC_GENERATOR
=
0x10
;
static
constexpr
uint32_t
REACTION_FLAG_DEBUGGER_DUMMY
=
0x20
;
static
constexpr
uint32_t
REACTION_FLAG_IGNORE_UNHANDLED_REJECTION
=
0x40
;
void
setFlagOnInitialState
(
uint32_t
flag
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
MOZ_ASSERT
(
flags
=
=
0
"
Can
'
t
modify
with
non
-
default
flags
"
)
;
flags
|
=
flag
;
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
flags
)
)
;
}
uint32_t
handlerSlot
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
?
ReactionRecordSlot_OnFulfilled
:
ReactionRecordSlot_OnRejected
;
}
uint32_t
handlerArgSlot
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
?
ReactionRecordSlot_OnFulfilledArg
:
ReactionRecordSlot_OnRejectedArg
;
}
public
:
static
const
JSClass
class_
;
JSObject
*
promise
(
)
{
return
getFixedSlot
(
ReactionRecordSlot_Promise
)
.
toObjectOrNull
(
)
;
}
int32_t
flags
(
)
const
{
return
getFixedSlot
(
ReactionRecordSlot_Flags
)
.
toInt32
(
)
;
}
JS
:
:
PromiseState
targetState
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
if
(
!
(
flags
&
REACTION_FLAG_RESOLVED
)
)
{
return
JS
:
:
PromiseState
:
:
Pending
;
}
return
flags
&
REACTION_FLAG_FULFILLED
?
JS
:
:
PromiseState
:
:
Fulfilled
:
JS
:
:
PromiseState
:
:
Rejected
;
}
void
setTargetStateAndHandlerArg
(
JS
:
:
PromiseState
state
const
Value
&
arg
)
{
MOZ_ASSERT
(
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
state
!
=
JS
:
:
PromiseState
:
:
Pending
"
Can
'
t
revert
a
reaction
to
pending
.
"
)
;
int32_t
flags
=
this
-
>
flags
(
)
;
flags
|
=
REACTION_FLAG_RESOLVED
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
{
flags
|
=
REACTION_FLAG_FULFILLED
;
}
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
flags
)
)
;
setFixedSlot
(
handlerArgSlot
(
)
arg
)
;
}
void
setShouldIgnoreUnhandledRejection
(
)
{
setFlagOnInitialState
(
REACTION_FLAG_IGNORE_UNHANDLED_REJECTION
)
;
}
UnhandledRejectionBehavior
unhandledRejectionBehavior
(
)
const
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
(
flags
&
REACTION_FLAG_IGNORE_UNHANDLED_REJECTION
)
?
UnhandledRejectionBehavior
:
:
Ignore
:
UnhandledRejectionBehavior
:
:
Report
;
}
void
setIsDefaultResolvingHandler
(
PromiseObject
*
promiseToResolve
)
{
setFlagOnInitialState
(
REACTION_FLAG_DEFAULT_RESOLVING_HANDLER
)
;
setFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
ObjectValue
(
*
promiseToResolve
)
)
;
}
bool
isDefaultResolvingHandler
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_DEFAULT_RESOLVING_HANDLER
;
}
PromiseObject
*
defaultResolvingPromise
(
)
{
MOZ_ASSERT
(
isDefaultResolvingHandler
(
)
)
;
const
Value
&
promiseToResolve
=
getFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
)
;
return
&
promiseToResolve
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
void
setIsAsyncFunction
(
AsyncFunctionGeneratorObject
*
genObj
)
{
setFlagOnInitialState
(
REACTION_FLAG_ASYNC_FUNCTION
)
;
setFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
ObjectValue
(
*
genObj
)
)
;
}
bool
isAsyncFunction
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_ASYNC_FUNCTION
;
}
AsyncFunctionGeneratorObject
*
asyncFunctionGenerator
(
)
{
MOZ_ASSERT
(
isAsyncFunction
(
)
)
;
const
Value
&
generator
=
getFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
)
;
return
&
generator
.
toObject
(
)
.
as
<
AsyncFunctionGeneratorObject
>
(
)
;
}
void
setIsAsyncGenerator
(
AsyncGeneratorObject
*
generator
)
{
setFlagOnInitialState
(
REACTION_FLAG_ASYNC_GENERATOR
)
;
setFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
ObjectValue
(
*
generator
)
)
;
}
bool
isAsyncGenerator
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_ASYNC_GENERATOR
;
}
AsyncGeneratorObject
*
asyncGenerator
(
)
{
MOZ_ASSERT
(
isAsyncGenerator
(
)
)
;
const
Value
&
generator
=
getFixedSlot
(
ReactionRecordSlot_GeneratorOrPromiseToResolve
)
;
return
&
generator
.
toObject
(
)
.
as
<
AsyncGeneratorObject
>
(
)
;
}
void
setIsDebuggerDummy
(
)
{
setFlagOnInitialState
(
REACTION_FLAG_DEBUGGER_DUMMY
)
;
}
bool
isDebuggerDummy
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
return
flags
&
REACTION_FLAG_DEBUGGER_DUMMY
;
}
Value
handler
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
getFixedSlot
(
handlerSlot
(
)
)
;
}
Value
handlerArg
(
)
{
MOZ_ASSERT
(
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
getFixedSlot
(
handlerArgSlot
(
)
)
;
}
JSObject
*
getAndClearIncumbentGlobalObject
(
)
{
JSObject
*
obj
=
getFixedSlot
(
ReactionRecordSlot_IncumbentGlobalObject
)
.
toObjectOrNull
(
)
;
setFixedSlot
(
ReactionRecordSlot_IncumbentGlobalObject
UndefinedValue
(
)
)
;
return
obj
;
}
}
;
const
JSClass
PromiseReactionRecord
:
:
class_
=
{
"
PromiseReactionRecord
"
JSCLASS_HAS_RESERVED_SLOTS
(
ReactionRecordSlots
)
}
;
static
void
AddPromiseFlags
(
PromiseObject
&
promise
int32_t
flag
)
{
int32_t
flags
=
promise
.
flags
(
)
;
promise
.
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
|
flag
)
)
;
}
static
void
RemovePromiseFlags
(
PromiseObject
&
promise
int32_t
flag
)
{
int32_t
flags
=
promise
.
flags
(
)
;
promise
.
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
&
~
flag
)
)
;
}
static
bool
PromiseHasAnyFlag
(
PromiseObject
&
promise
int32_t
flag
)
{
return
promise
.
flags
(
)
&
flag
;
}
static
bool
ResolvePromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
RejectPromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
JSFunction
*
GetResolveFunctionFromReject
(
JSFunction
*
reject
)
;
static
JSFunction
*
GetRejectFunctionFromResolve
(
JSFunction
*
resolve
)
;
#
ifdef
DEBUG
static
bool
IsAlreadyResolvedMaybeWrappedResolveFunction
(
JSObject
*
resolveFunObj
)
{
if
(
IsWrapper
(
resolveFunObj
)
)
{
resolveFunObj
=
UncheckedUnwrap
(
resolveFunObj
)
;
}
JSFunction
*
resolveFun
=
&
resolveFunObj
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
resolveFun
-
>
maybeNative
(
)
=
=
ResolvePromiseFunction
)
;
bool
alreadyResolved
=
resolveFun
-
>
getExtendedSlot
(
ResolveFunctionSlot_Promise
)
.
isUndefined
(
)
;
if
(
alreadyResolved
)
{
MOZ_ASSERT
(
resolveFun
-
>
getExtendedSlot
(
ResolveFunctionSlot_RejectFunction
)
.
isUndefined
(
)
)
;
}
else
{
JSFunction
*
rejectFun
=
GetRejectFunctionFromResolve
(
resolveFun
)
;
MOZ_ASSERT
(
!
rejectFun
-
>
getExtendedSlot
(
RejectFunctionSlot_Promise
)
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
!
rejectFun
-
>
getExtendedSlot
(
RejectFunctionSlot_ResolveFunction
)
.
isUndefined
(
)
)
;
}
return
alreadyResolved
;
}
static
bool
IsAlreadyResolvedMaybeWrappedRejectFunction
(
JSObject
*
rejectFunObj
)
{
if
(
IsWrapper
(
rejectFunObj
)
)
{
rejectFunObj
=
UncheckedUnwrap
(
rejectFunObj
)
;
}
JSFunction
*
rejectFun
=
&
rejectFunObj
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
rejectFun
-
>
maybeNative
(
)
=
=
RejectPromiseFunction
)
;
bool
alreadyResolved
=
rejectFun
-
>
getExtendedSlot
(
RejectFunctionSlot_Promise
)
.
isUndefined
(
)
;
if
(
alreadyResolved
)
{
MOZ_ASSERT
(
rejectFun
-
>
getExtendedSlot
(
RejectFunctionSlot_ResolveFunction
)
.
isUndefined
(
)
)
;
}
else
{
JSFunction
*
resolveFun
=
GetResolveFunctionFromReject
(
rejectFun
)
;
MOZ_ASSERT
(
!
resolveFun
-
>
getExtendedSlot
(
ResolveFunctionSlot_Promise
)
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
!
resolveFun
-
>
getExtendedSlot
(
ResolveFunctionSlot_RejectFunction
)
.
isUndefined
(
)
)
;
}
return
alreadyResolved
;
}
#
endif
static
void
SetAlreadyResolvedResolutionFunction
(
JSFunction
*
resolutionFun
)
{
JSFunction
*
resolve
;
JSFunction
*
reject
;
if
(
resolutionFun
-
>
maybeNative
(
)
=
=
ResolvePromiseFunction
)
{
resolve
=
resolutionFun
;
reject
=
GetRejectFunctionFromResolve
(
resolutionFun
)
;
}
else
{
resolve
=
GetResolveFunctionFromReject
(
resolutionFun
)
;
reject
=
resolutionFun
;
}
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_Promise
UndefinedValue
(
)
)
;
resolve
-
>
setExtendedSlot
(
ResolveFunctionSlot_RejectFunction
UndefinedValue
(
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_Promise
UndefinedValue
(
)
)
;
reject
-
>
setExtendedSlot
(
RejectFunctionSlot_ResolveFunction
UndefinedValue
(
)
)
;
MOZ_ASSERT
(
IsAlreadyResolvedMaybeWrappedResolveFunction
(
resolve
)
)
;
MOZ_ASSERT
(
IsAlreadyResolvedMaybeWrappedRejectFunction
(
reject
)
)
;
}
static
bool
IsPromiseWithDefaultResolvingFunction
(
PromiseObject
*
promise
)
{
return
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS
)
;
}
static
bool
IsAlreadyResolvedPromiseWithDefaultResolvingFunction
(
PromiseObject
*
promise
)
{
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
if
(
promise
-
>
as
<
PromiseObject
>
(
)
.
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
MOZ_ASSERT
(
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS_ALREADY_RESOLVED
)
)
;
return
true
;
}
return
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS_ALREADY_RESOLVED
)
;
}
static
void
SetAlreadyResolvedPromiseWithDefaultResolvingFunction
(
PromiseObject
*
promise
)
{
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_Flags
JS
:
:
Int32Value
(
promise
-
>
flags
(
)
|
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS_ALREADY_RESOLVED
)
)
;
}
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
bool
CreateResolvingFunctions
(
JSContext
*
cx
HandleObject
promise
MutableHandleObject
resolveFn
MutableHandleObject
rejectFn
)
{
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
resolveFn
.
set
(
NewNativeFunction
(
cx
ResolvePromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
resolveFn
)
{
return
false
;
}
rejectFn
.
set
(
NewNativeFunction
(
cx
RejectPromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
rejectFn
)
{
return
false
;
}
JSFunction
*
resolveFun
=
&
resolveFn
-
>
as
<
JSFunction
>
(
)
;
JSFunction
*
rejectFun
=
&
rejectFn
-
>
as
<
JSFunction
>
(
)
;
resolveFun
-
>
initExtendedSlot
(
ResolveFunctionSlot_Promise
ObjectValue
(
*
promise
)
)
;
resolveFun
-
>
initExtendedSlot
(
ResolveFunctionSlot_RejectFunction
ObjectValue
(
*
rejectFun
)
)
;
rejectFun
-
>
initExtendedSlot
(
RejectFunctionSlot_Promise
ObjectValue
(
*
promise
)
)
;
rejectFun
-
>
initExtendedSlot
(
RejectFunctionSlot_ResolveFunction
ObjectValue
(
*
resolveFun
)
)
;
MOZ_ASSERT
(
!
IsAlreadyResolvedMaybeWrappedResolveFunction
(
resolveFun
)
)
;
MOZ_ASSERT
(
!
IsAlreadyResolvedMaybeWrappedRejectFunction
(
rejectFun
)
)
;
return
true
;
}
static
bool
IsSettledMaybeWrappedPromise
(
JSObject
*
promise
)
{
if
(
IsProxy
(
promise
)
)
{
promise
=
UncheckedUnwrap
(
promise
)
;
if
(
JS_IsDeadWrapper
(
promise
)
)
{
return
false
;
}
}
return
promise
-
>
as
<
PromiseObject
>
(
)
.
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
;
}
[
[
nodiscard
]
]
static
bool
RejectMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
reason
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
;
static
bool
RejectPromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
*
reject
=
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
HandleValue
reasonVal
=
args
.
get
(
0
)
;
const
Value
&
promiseVal
=
reject
-
>
getExtendedSlot
(
RejectFunctionSlot_Promise
)
;
bool
alreadyResolved
=
promiseVal
.
isUndefined
(
)
;
MOZ_ASSERT
(
IsAlreadyResolvedMaybeWrappedRejectFunction
(
reject
)
=
=
alreadyResolved
)
;
if
(
alreadyResolved
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
promise
(
cx
&
promiseVal
.
toObject
(
)
)
;
SetAlreadyResolvedResolutionFunction
(
reject
)
;
if
(
IsSettledMaybeWrappedPromise
(
promise
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
if
(
!
RejectMaybeWrappedPromise
(
cx
promise
reasonVal
nullptr
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
FulfillMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
value_
)
;
[
[
nodiscard
]
]
static
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve
HandleValue
thenable
HandleValue
thenVal
)
;
[
[
nodiscard
]
]
static
bool
EnqueuePromiseResolveThenableBuiltinJob
(
JSContext
*
cx
HandleObject
promiseToResolve
HandleObject
thenable
)
;
static
bool
Promise_then_impl
(
JSContext
*
cx
HandleValue
promiseVal
HandleValue
onFulfilled
HandleValue
onRejected
MutableHandleValue
rval
bool
rvalExplicitlyUsed
)
;
[
[
nodiscard
]
]
bool
js
:
:
ResolvePromiseInternal
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
promise
JS
:
:
Handle
<
JS
:
:
Value
>
resolutionVal
)
{
cx
-
>
check
(
promise
resolutionVal
)
;
MOZ_ASSERT
(
!
IsSettledMaybeWrappedPromise
(
promise
)
)
;
if
(
!
resolutionVal
.
isObject
(
)
)
{
return
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
}
RootedObject
resolution
(
cx
&
resolutionVal
.
toObject
(
)
)
;
if
(
resolution
=
=
promise
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF
)
;
RootedValue
selfResolutionError
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
selfResolutionError
&
stack
)
)
{
return
false
;
}
return
RejectMaybeWrappedPromise
(
cx
promise
selfResolutionError
stack
)
;
}
RootedValue
thenVal
(
cx
)
;
bool
status
=
GetProperty
(
cx
resolution
resolution
cx
-
>
names
(
)
.
then
&
thenVal
)
;
RootedValue
error
(
cx
)
;
Rooted
<
SavedFrame
*
>
errorStack
(
cx
)
;
if
(
!
status
)
{
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
error
&
errorStack
)
)
{
return
false
;
}
}
if
(
IsSettledMaybeWrappedPromise
(
promise
)
)
{
return
true
;
}
if
(
!
status
)
{
return
RejectMaybeWrappedPromise
(
cx
promise
error
errorStack
)
;
}
if
(
!
IsCallable
(
thenVal
)
)
{
return
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
}
bool
isBuiltinThen
=
false
;
if
(
resolution
-
>
is
<
PromiseObject
>
(
)
&
&
promise
-
>
is
<
PromiseObject
>
(
)
&
&
IsNativeFunction
(
thenVal
Promise_then
)
&
&
thenVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
.
realm
(
)
=
=
cx
-
>
realm
(
)
)
{
isBuiltinThen
=
true
;
}
if
(
!
isBuiltinThen
)
{
RootedValue
promiseVal
(
cx
ObjectValue
(
*
promise
)
)
;
if
(
!
EnqueuePromiseResolveThenableJob
(
cx
promiseVal
resolutionVal
thenVal
)
)
{
return
false
;
}
}
else
{
if
(
!
EnqueuePromiseResolveThenableBuiltinJob
(
cx
promise
resolution
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ResolvePromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
*
resolve
=
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
HandleValue
resolutionVal
=
args
.
get
(
0
)
;
const
Value
&
promiseVal
=
resolve
-
>
getExtendedSlot
(
ResolveFunctionSlot_Promise
)
;
bool
alreadyResolved
=
promiseVal
.
isUndefined
(
)
;
MOZ_ASSERT
(
IsAlreadyResolvedMaybeWrappedResolveFunction
(
resolve
)
=
=
alreadyResolved
)
;
if
(
alreadyResolved
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
promise
(
cx
&
promiseVal
.
toObject
(
)
)
;
SetAlreadyResolvedResolutionFunction
(
resolve
)
;
if
(
IsSettledMaybeWrappedPromise
(
promise
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
if
(
!
ResolvePromiseInternal
(
cx
promise
resolutionVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
PromiseReactionJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
bool
EnqueuePromiseReactionJob
(
JSContext
*
cx
HandleObject
reactionObj
HandleValue
handlerArg_
JS
:
:
PromiseState
targetState
)
{
MOZ_ASSERT
(
targetState
=
=
JS
:
:
PromiseState
:
:
Fulfilled
|
|
targetState
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
)
;
RootedValue
handlerArg
(
cx
handlerArg_
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
!
IsProxy
(
reactionObj
)
)
{
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
reaction
=
&
reactionObj
-
>
as
<
PromiseReactionRecord
>
(
)
;
if
(
cx
-
>
realm
(
)
!
=
reaction
-
>
realm
(
)
)
{
ar
.
emplace
(
cx
reaction
)
;
}
}
else
{
JSObject
*
unwrappedReactionObj
=
UncheckedUnwrap
(
reactionObj
)
;
if
(
JS_IsDeadWrapper
(
unwrappedReactionObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
reaction
=
&
unwrappedReactionObj
-
>
as
<
PromiseReactionRecord
>
(
)
;
MOZ_RELEASE_ASSERT
(
reaction
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
ar
.
emplace
(
cx
reaction
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
handlerArg
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
reaction
-
>
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
cx
-
>
check
(
handlerArg
)
;
reaction
-
>
setTargetStateAndHandlerArg
(
targetState
handlerArg
)
;
RootedValue
reactionVal
(
cx
ObjectValue
(
*
reaction
)
)
;
RootedValue
handler
(
cx
reaction
-
>
handler
(
)
)
;
mozilla
:
:
Maybe
<
AutoFunctionOrCurrentRealm
>
ar2
;
if
(
handler
.
isObject
(
)
)
{
RootedObject
handlerObj
(
cx
&
handler
.
toObject
(
)
)
;
ar2
.
emplace
(
cx
handlerObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reactionVal
)
)
{
return
false
;
}
}
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseReactionJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
job
)
{
return
false
;
}
job
-
>
setExtendedSlot
(
ReactionJobSlot_ReactionRecord
reactionVal
)
;
RootedObject
promise
(
cx
reaction
-
>
promise
(
)
)
;
if
(
promise
)
{
if
(
promise
-
>
is
<
PromiseObject
>
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
{
return
false
;
}
}
else
if
(
IsWrapper
(
promise
)
)
{
JSObject
*
unwrappedPromise
=
UncheckedUnwrap
(
promise
)
;
if
(
unwrappedPromise
-
>
is
<
PromiseObject
>
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
{
return
false
;
}
}
else
{
promise
=
nullptr
;
}
}
else
{
promise
=
nullptr
;
}
}
Rooted
<
GlobalObject
*
>
global
(
cx
)
;
if
(
JSObject
*
objectFromIncumbentGlobal
=
reaction
-
>
getAndClearIncumbentGlobalObject
(
)
)
{
objectFromIncumbentGlobal
=
CheckedUnwrapStatic
(
objectFromIncumbentGlobal
)
;
MOZ_ASSERT
(
objectFromIncumbentGlobal
)
;
global
=
&
objectFromIncumbentGlobal
-
>
nonCCWGlobal
(
)
;
}
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
global
)
;
}
[
[
nodiscard
]
]
static
bool
TriggerPromiseReactions
(
JSContext
*
cx
HandleValue
reactionsVal
JS
:
:
PromiseState
state
HandleValue
valueOrReason
)
;
[
[
nodiscard
]
]
static
bool
ResolvePromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
valueOrReason
JS
:
:
PromiseState
state
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
=
nullptr
)
{
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
|
|
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
MOZ_ASSERT_IF
(
unwrappedRejectionStack
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
reactionsVal
(
cx
promise
-
>
reactions
(
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
valueOrReason
)
;
int32_t
flags
=
promise
-
>
flags
(
)
;
flags
|
=
PROMISE_FLAG_RESOLVED
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
{
flags
|
=
PROMISE_FLAG_FULFILLED
;
}
promise
-
>
setFixedSlot
(
PromiseSlot_Flags
Int32Value
(
flags
)
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
UndefinedValue
(
)
)
;
PromiseObject
:
:
onSettled
(
cx
promise
unwrappedRejectionStack
)
;
return
TriggerPromiseReactions
(
cx
reactionsVal
state
valueOrReason
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
RejectPromiseInternal
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
JS
:
:
Value
>
reason
JS
:
:
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
{
return
ResolvePromise
(
cx
promise
reason
JS
:
:
PromiseState
:
:
Rejected
unwrappedRejectionStack
)
;
}
[
[
nodiscard
]
]
static
bool
FulfillMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
value_
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
value
(
cx
value_
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
!
IsProxy
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
JSObject
*
unwrappedPromiseObj
=
UncheckedUnwrap
(
promiseObj
)
;
if
(
JS_IsDeadWrapper
(
unwrappedPromiseObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
promise
=
&
unwrappedPromiseObj
-
>
as
<
PromiseObject
>
(
)
;
ar
.
emplace
(
cx
promise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
value
)
)
{
return
false
;
}
}
return
ResolvePromise
(
cx
promise
value
JS
:
:
PromiseState
:
:
Fulfilled
)
;
}
static
bool
GetCapabilitiesExecutor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
PromiseConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
static
PromiseObject
*
CreatePromiseObjectInternal
(
JSContext
*
cx
HandleObject
proto
=
nullptr
bool
protoIsWrapped
=
false
bool
informDebugger
=
true
)
;
enum
GetCapabilitiesExecutorSlots
{
GetCapabilitiesExecutorSlots_Resolve
GetCapabilitiesExecutorSlots_Reject
}
;
[
[
nodiscard
]
]
static
PromiseObject
*
CreatePromiseObjectWithoutResolutionFunctions
(
JSContext
*
cx
)
{
PromiseObject
*
promise
=
CreatePromiseObjectInternal
(
cx
)
;
if
(
!
promise
)
{
return
nullptr
;
}
AddPromiseFlags
(
*
promise
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS
)
;
return
promise
;
}
[
[
nodiscard
]
]
static
PromiseObject
*
CreatePromiseWithDefaultResolutionFunctions
(
JSContext
*
cx
MutableHandleObject
resolve
MutableHandleObject
reject
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectInternal
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
if
(
!
CreateResolvingFunctions
(
cx
promise
resolve
reject
)
)
{
return
nullptr
;
}
promise
-
>
setFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
reject
)
)
;
return
promise
;
}
[
[
nodiscard
]
]
static
bool
NewPromiseCapability
(
JSContext
*
cx
HandleObject
C
MutableHandle
<
PromiseCapability
>
capability
bool
canOmitResolutionFunctions
)
{
RootedValue
cVal
(
cx
ObjectValue
(
*
C
)
)
;
if
(
!
IsConstructor
(
C
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_SEARCH_STACK
cVal
nullptr
)
;
return
false
;
}
if
(
IsNativeFunction
(
cVal
PromiseConstructor
)
&
&
cVal
.
toObject
(
)
.
nonCCWRealm
(
)
=
=
cx
-
>
realm
(
)
)
{
PromiseObject
*
promise
;
if
(
canOmitResolutionFunctions
)
{
promise
=
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
}
else
{
promise
=
CreatePromiseWithDefaultResolutionFunctions
(
cx
capability
.
resolve
(
)
capability
.
reject
(
)
)
;
}
if
(
!
promise
)
{
return
false
;
}
capability
.
promise
(
)
.
set
(
promise
)
;
return
true
;
}
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
RootedFunction
executor
(
cx
NewNativeFunction
(
cx
GetCapabilitiesExecutor
2
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
executor
)
{
return
false
;
}
FixedConstructArgs
<
1
>
cargs
(
cx
)
;
cargs
[
0
]
.
setObject
(
*
executor
)
;
if
(
!
Construct
(
cx
cVal
cargs
cVal
capability
.
promise
(
)
)
)
{
return
false
;
}
const
Value
&
resolveVal
=
executor
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
)
;
if
(
!
IsCallable
(
resolveVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE
)
;
return
false
;
}
const
Value
&
rejectVal
=
executor
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
)
;
if
(
!
IsCallable
(
rejectVal
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE
)
;
return
false
;
}
capability
.
resolve
(
)
.
set
(
&
resolveVal
.
toObject
(
)
)
;
capability
.
reject
(
)
.
set
(
&
rejectVal
.
toObject
(
)
)
;
return
true
;
}
static
bool
GetCapabilitiesExecutor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
*
F
=
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
F
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
)
.
isUndefined
(
)
|
|
!
F
-
>
getExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
)
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY
)
;
return
false
;
}
F
-
>
setExtendedSlot
(
GetCapabilitiesExecutorSlots_Resolve
args
.
get
(
0
)
)
;
F
-
>
setExtendedSlot
(
GetCapabilitiesExecutorSlots_Reject
args
.
get
(
1
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
RejectMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
reason_
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
reason
(
cx
reason_
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
!
IsProxy
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
JSObject
*
unwrappedPromiseObj
=
UncheckedUnwrap
(
promiseObj
)
;
if
(
JS_IsDeadWrapper
(
unwrappedPromiseObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
promise
=
&
unwrappedPromiseObj
-
>
as
<
PromiseObject
>
(
)
;
ar
.
emplace
(
cx
promise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason
)
)
{
return
false
;
}
if
(
reason
.
isObject
(
)
&
&
!
CheckedUnwrapStatic
(
&
reason
.
toObject
(
)
)
)
{
JSObject
*
realReason
=
UncheckedUnwrap
(
&
reason
.
toObject
(
)
)
;
RootedValue
realReasonVal
(
cx
ObjectValue
(
*
realReason
)
)
;
Rooted
<
GlobalObject
*
>
realGlobal
(
cx
&
realReason
-
>
nonCCWGlobal
(
)
)
;
ReportErrorToGlobal
(
cx
realGlobal
realReasonVal
)
;
if
(
!
GetInternalError
(
cx
JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON
&
reason
)
)
{
return
false
;
}
}
}
return
ResolvePromise
(
cx
promise
reason
JS
:
:
PromiseState
:
:
Rejected
unwrappedRejectionStack
)
;
}
template
<
typename
F
>
static
bool
ForEachReaction
(
JSContext
*
cx
HandleValue
reactionsVal
F
f
)
{
if
(
reactionsVal
.
isUndefined
(
)
)
{
return
true
;
}
RootedObject
reactions
(
cx
&
reactionsVal
.
toObject
(
)
)
;
RootedObject
reaction
(
cx
)
;
if
(
reactions
-
>
is
<
PromiseReactionRecord
>
(
)
|
|
IsWrapper
(
reactions
)
|
|
JS_IsDeadWrapper
(
reactions
)
)
{
return
f
(
&
reactions
)
;
}
Handle
<
NativeObject
*
>
reactionsList
=
reactions
.
as
<
NativeObject
>
(
)
;
uint32_t
reactionsCount
=
reactionsList
-
>
getDenseInitializedLength
(
)
;
MOZ_ASSERT
(
reactionsCount
>
1
"
Reactions
list
should
be
created
lazily
"
)
;
for
(
uint32_t
i
=
0
;
i
<
reactionsCount
;
i
+
+
)
{
const
Value
&
reactionVal
=
reactionsList
-
>
getDenseElement
(
i
)
;
MOZ_RELEASE_ASSERT
(
reactionVal
.
isObject
(
)
)
;
reaction
=
&
reactionVal
.
toObject
(
)
;
if
(
!
f
(
&
reaction
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
TriggerPromiseReactions
(
JSContext
*
cx
HandleValue
reactionsVal
JS
:
:
PromiseState
state
HandleValue
valueOrReason
)
{
MOZ_ASSERT
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
|
|
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
ForEachReaction
(
cx
reactionsVal
[
&
]
(
MutableHandleObject
reaction
)
{
return
EnqueuePromiseReactionJob
(
cx
reaction
valueOrReason
state
)
;
}
)
;
}
[
[
nodiscard
]
]
static
bool
CallPromiseResolveFunction
(
JSContext
*
cx
HandleObject
resolveFun
HandleValue
value
HandleObject
promiseObj
)
;
[
[
nodiscard
]
]
static
bool
DefaultResolvingPromiseReactionJob
(
JSContext
*
cx
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
MOZ_ASSERT
(
reaction
-
>
targetState
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
Rooted
<
PromiseObject
*
>
promiseToResolve
(
cx
reaction
-
>
defaultResolvingPromise
(
)
)
;
ResolutionMode
resolutionMode
=
ResolveMode
;
RootedValue
handlerResult
(
cx
UndefinedValue
(
)
)
;
Rooted
<
SavedFrame
*
>
unwrappedRejectionStack
(
cx
)
;
if
(
promiseToResolve
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
{
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
bool
ok
;
if
(
reaction
-
>
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
{
ok
=
ResolvePromiseInternal
(
cx
promiseToResolve
argument
)
;
}
else
{
ok
=
RejectPromiseInternal
(
cx
promiseToResolve
argument
)
;
}
if
(
!
ok
)
{
resolutionMode
=
RejectMode
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
handlerResult
&
unwrappedRejectionStack
)
)
{
return
false
;
}
}
}
RootedObject
promiseObj
(
cx
reaction
-
>
promise
(
)
)
;
RootedObject
callee
(
cx
)
;
if
(
resolutionMode
=
=
ResolveMode
)
{
callee
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_Resolve
)
.
toObjectOrNull
(
)
;
return
CallPromiseResolveFunction
(
cx
callee
handlerResult
promiseObj
)
;
}
callee
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_Reject
)
.
toObjectOrNull
(
)
;
return
CallPromiseRejectFunction
(
cx
callee
handlerResult
promiseObj
unwrappedRejectionStack
reaction
-
>
unhandledRejectionBehavior
(
)
)
;
}
[
[
nodiscard
]
]
static
bool
AsyncFunctionPromiseReactionJob
(
JSContext
*
cx
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
MOZ_ASSERT
(
reaction
-
>
isAsyncFunction
(
)
)
;
auto
handler
=
static_cast
<
PromiseHandler
>
(
reaction
-
>
handler
(
)
.
toInt32
(
)
)
;
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
Rooted
<
AsyncFunctionGeneratorObject
*
>
generator
(
cx
reaction
-
>
asyncFunctionGenerator
(
)
)
;
if
(
handler
=
=
PromiseHandler
:
:
AsyncFunctionAwaitedFulfilled
)
{
return
AsyncFunctionAwaitedFulfilled
(
cx
generator
argument
)
;
}
MOZ_ASSERT
(
handler
=
=
PromiseHandler
:
:
AsyncFunctionAwaitedRejected
)
;
return
AsyncFunctionAwaitedRejected
(
cx
generator
argument
)
;
}
static
bool
PromiseReactionJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
RootedObject
reactionObj
(
cx
&
job
-
>
getExtendedSlot
(
ReactionJobSlot_ReactionRecord
)
.
toObject
(
)
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
!
IsProxy
(
reactionObj
)
)
{
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
}
else
{
reactionObj
=
UncheckedUnwrap
(
reactionObj
)
;
if
(
JS_IsDeadWrapper
(
reactionObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
reactionObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
ar
.
emplace
(
cx
reactionObj
)
;
}
Handle
<
PromiseReactionRecord
*
>
reaction
=
reactionObj
.
as
<
PromiseReactionRecord
>
(
)
;
if
(
reaction
-
>
isDefaultResolvingHandler
(
)
)
{
return
DefaultResolvingPromiseReactionJob
(
cx
reaction
)
;
}
if
(
reaction
-
>
isAsyncFunction
(
)
)
{
return
AsyncFunctionPromiseReactionJob
(
cx
reaction
)
;
}
if
(
reaction
-
>
isAsyncGenerator
(
)
)
{
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
Rooted
<
AsyncGeneratorObject
*
>
generator
(
cx
reaction
-
>
asyncGenerator
(
)
)
;
auto
handler
=
static_cast
<
PromiseHandler
>
(
reaction
-
>
handler
(
)
.
toInt32
(
)
)
;
return
AsyncGeneratorPromiseReactionJob
(
cx
handler
generator
argument
)
;
}
if
(
reaction
-
>
isDebuggerDummy
(
)
)
{
return
true
;
}
RootedValue
handlerVal
(
cx
reaction
-
>
handler
(
)
)
;
RootedValue
argument
(
cx
reaction
-
>
handlerArg
(
)
)
;
RootedValue
handlerResult
(
cx
)
;
ResolutionMode
resolutionMode
=
ResolveMode
;
Rooted
<
SavedFrame
*
>
unwrappedRejectionStack
(
cx
)
;
if
(
handlerVal
.
isInt32
(
)
)
{
auto
handlerNum
=
static_cast
<
PromiseHandler
>
(
handlerVal
.
toInt32
(
)
)
;
if
(
handlerNum
=
=
PromiseHandler
:
:
Identity
)
{
handlerResult
=
argument
;
}
else
if
(
handlerNum
=
=
PromiseHandler
:
:
Thrower
)
{
resolutionMode
=
RejectMode
;
handlerResult
=
argument
;
}
else
{
MOZ_ASSERT
(
handlerNum
=
=
PromiseHandler
:
:
AsyncFromSyncIteratorValueUnwrapDone
|
|
handlerNum
=
=
PromiseHandler
:
:
AsyncFromSyncIteratorValueUnwrapNotDone
)
;
bool
done
=
handlerNum
=
=
PromiseHandler
:
:
AsyncFromSyncIteratorValueUnwrapDone
;
PlainObject
*
resultObj
=
CreateIterResultObject
(
cx
argument
done
)
;
if
(
!
resultObj
)
{
return
false
;
}
handlerResult
=
ObjectValue
(
*
resultObj
)
;
}
}
else
{
MOZ_ASSERT
(
handlerVal
.
isObject
(
)
)
;
MOZ_ASSERT
(
IsCallable
(
handlerVal
)
)
;
if
(
!
Call
(
cx
handlerVal
UndefinedHandleValue
argument
&
handlerResult
)
)
{
resolutionMode
=
RejectMode
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
handlerResult
&
unwrappedRejectionStack
)
)
{
return
false
;
}
}
}
RootedObject
promiseObj
(
cx
reaction
-
>
promise
(
)
)
;
RootedObject
callee
(
cx
)
;
if
(
resolutionMode
=
=
ResolveMode
)
{
callee
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_Resolve
)
.
toObjectOrNull
(
)
;
return
CallPromiseResolveFunction
(
cx
callee
handlerResult
promiseObj
)
;
}
callee
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_Reject
)
.
toObjectOrNull
(
)
;
return
CallPromiseRejectFunction
(
cx
callee
handlerResult
promiseObj
unwrappedRejectionStack
reaction
-
>
unhandledRejectionBehavior
(
)
)
;
}
static
bool
PromiseResolveThenableJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
then
(
cx
job
-
>
getExtendedSlot
(
ThenableJobSlot_Handler
)
)
;
MOZ_ASSERT
(
then
.
isObject
(
)
)
;
Rooted
<
NativeObject
*
>
jobArgs
(
cx
&
job
-
>
getExtendedSlot
(
ThenableJobSlot_JobData
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedObject
promise
(
cx
&
jobArgs
-
>
getDenseElement
(
ThenableJobDataIndex_Promise
)
.
toObject
(
)
)
;
RootedValue
thenable
(
cx
jobArgs
-
>
getDenseElement
(
ThenableJobDataIndex_Thenable
)
)
;
RootedObject
resolveFn
(
cx
)
;
RootedObject
rejectFn
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promise
&
resolveFn
&
rejectFn
)
)
{
return
false
;
}
FixedInvokeArgs
<
2
>
args2
(
cx
)
;
args2
[
0
]
.
setObject
(
*
resolveFn
)
;
args2
[
1
]
.
setObject
(
*
rejectFn
)
;
RootedValue
rval
(
cx
)
;
if
(
Call
(
cx
then
thenable
args2
&
rval
)
)
{
return
true
;
}
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
rval
&
stack
)
)
{
return
false
;
}
RootedValue
rejectVal
(
cx
ObjectValue
(
*
rejectFn
)
)
;
return
Call
(
cx
rejectVal
UndefinedHandleValue
rval
&
rval
)
;
}
[
[
nodiscard
]
]
static
bool
OriginalPromiseThenWithoutSettleHandlers
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseObject
*
>
promiseToResolve
)
;
static
bool
PromiseResolveBuiltinThenableJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedObject
promise
(
cx
&
job
-
>
getExtendedSlot
(
BuiltinThenableJobSlot_Promise
)
.
toObject
(
)
)
;
RootedObject
thenable
(
cx
&
job
-
>
getExtendedSlot
(
BuiltinThenableJobSlot_Thenable
)
.
toObject
(
)
)
;
cx
-
>
check
(
promise
thenable
)
;
MOZ_ASSERT
(
promise
-
>
is
<
PromiseObject
>
(
)
)
;
MOZ_ASSERT
(
thenable
-
>
is
<
PromiseObject
>
(
)
)
;
if
(
OriginalPromiseThenWithoutSettleHandlers
(
cx
thenable
.
as
<
PromiseObject
>
(
)
promise
.
as
<
PromiseObject
>
(
)
)
)
{
return
true
;
}
RootedValue
exception
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
exception
&
stack
)
)
{
return
false
;
}
if
(
promise
-
>
as
<
PromiseObject
>
(
)
.
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
return
RejectPromiseInternal
(
cx
promise
.
as
<
PromiseObject
>
(
)
exception
stack
)
;
}
[
[
nodiscard
]
]
static
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve_
HandleValue
thenable_
HandleValue
thenVal
)
{
RootedValue
promiseToResolve
(
cx
promiseToResolve_
)
;
RootedValue
thenable
(
cx
thenable_
)
;
RootedObject
then
(
cx
&
thenVal
.
toObject
(
)
)
;
AutoFunctionOrCurrentRealm
ar
(
cx
then
)
;
if
(
then
-
>
maybeCCWRealm
(
)
!
=
cx
-
>
realm
(
)
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
then
)
)
{
return
false
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseToResolve
)
)
{
return
false
;
}
MOZ_ASSERT
(
thenable
.
isObject
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
thenable
)
)
{
return
false
;
}
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseResolveThenableJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
job
)
{
return
false
;
}
job
-
>
setExtendedSlot
(
ThenableJobSlot_Handler
ObjectValue
(
*
then
)
)
;
Rooted
<
ArrayObject
*
>
data
(
cx
NewDenseFullyAllocatedArray
(
cx
ThenableJobDataLength
)
)
;
if
(
!
data
)
{
return
false
;
}
data
-
>
setDenseInitializedLength
(
ThenableJobDataLength
)
;
data
-
>
initDenseElement
(
ThenableJobDataIndex_Promise
promiseToResolve
)
;
data
-
>
initDenseElement
(
ThenableJobDataIndex_Thenable
thenable
)
;
job
-
>
setExtendedSlot
(
ThenableJobSlot_JobData
ObjectValue
(
*
data
)
)
;
RootedObject
promise
(
cx
&
promiseToResolve
.
toObject
(
)
)
;
Rooted
<
GlobalObject
*
>
incumbentGlobal
(
cx
cx
-
>
runtime
(
)
-
>
getIncumbentGlobal
(
cx
)
)
;
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
incumbentGlobal
)
;
}
[
[
nodiscard
]
]
static
bool
EnqueuePromiseResolveThenableBuiltinJob
(
JSContext
*
cx
HandleObject
promiseToResolve
HandleObject
thenable
)
{
cx
-
>
check
(
promiseToResolve
thenable
)
;
MOZ_ASSERT
(
promiseToResolve
-
>
is
<
PromiseObject
>
(
)
)
;
MOZ_ASSERT
(
thenable
-
>
is
<
PromiseObject
>
(
)
)
;
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseResolveBuiltinThenableJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
job
)
{
return
false
;
}
job
-
>
setExtendedSlot
(
BuiltinThenableJobSlot_Promise
ObjectValue
(
*
promiseToResolve
)
)
;
job
-
>
setExtendedSlot
(
BuiltinThenableJobSlot_Thenable
ObjectValue
(
*
thenable
)
)
;
Rooted
<
GlobalObject
*
>
incumbentGlobal
(
cx
cx
-
>
runtime
(
)
-
>
getIncumbentGlobal
(
cx
)
)
;
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promiseToResolve
incumbentGlobal
)
;
}
[
[
nodiscard
]
]
static
bool
AddDummyPromiseReactionForDebugger
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleObject
dependentPromise
)
;
[
[
nodiscard
]
]
static
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
;
static
JSFunction
*
GetResolveFunctionFromReject
(
JSFunction
*
reject
)
{
MOZ_ASSERT
(
reject
-
>
maybeNative
(
)
=
=
RejectPromiseFunction
)
;
Value
resolveFunVal
=
reject
-
>
getExtendedSlot
(
RejectFunctionSlot_ResolveFunction
)
;
MOZ_ASSERT
(
IsNativeFunction
(
resolveFunVal
ResolvePromiseFunction
)
)
;
return
&
resolveFunVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
static
JSFunction
*
GetRejectFunctionFromResolve
(
JSFunction
*
resolve
)
{
MOZ_ASSERT
(
resolve
-
>
maybeNative
(
)
=
=
ResolvePromiseFunction
)
;
Value
rejectFunVal
=
resolve
-
>
getExtendedSlot
(
ResolveFunctionSlot_RejectFunction
)
;
MOZ_ASSERT
(
IsNativeFunction
(
rejectFunVal
RejectPromiseFunction
)
)
;
return
&
rejectFunVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
static
JSFunction
*
GetResolveFunctionFromPromise
(
PromiseObject
*
promise
)
{
Value
rejectFunVal
=
promise
-
>
getFixedSlot
(
PromiseSlot_RejectFunction
)
;
if
(
rejectFunVal
.
isUndefined
(
)
)
{
return
nullptr
;
}
JSObject
*
rejectFunObj
=
&
rejectFunVal
.
toObject
(
)
;
if
(
IsWrapper
(
rejectFunObj
)
)
{
rejectFunObj
=
UncheckedUnwrap
(
rejectFunObj
)
;
}
if
(
!
rejectFunObj
-
>
is
<
JSFunction
>
(
)
)
{
return
nullptr
;
}
JSFunction
*
rejectFun
=
&
rejectFunObj
-
>
as
<
JSFunction
>
(
)
;
if
(
rejectFun
-
>
maybeNative
(
)
!
=
&
RejectPromiseFunction
)
{
return
nullptr
;
}
if
(
rejectFun
-
>
getExtendedSlot
(
RejectFunctionSlot_ResolveFunction
)
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
GetResolveFunctionFromReject
(
rejectFun
)
;
}
[
[
nodiscard
]
]
static
MOZ_ALWAYS_INLINE
PromiseObject
*
CreatePromiseObjectInternal
(
JSContext
*
cx
HandleObject
proto
bool
protoIsWrapped
bool
informDebugger
)
{
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
protoIsWrapped
)
{
ar
.
emplace
(
cx
proto
)
;
}
PromiseObject
*
promise
=
NewObjectWithClassProto
<
PromiseObject
>
(
cx
proto
)
;
if
(
!
promise
)
{
return
nullptr
;
}
promise
-
>
initFixedSlot
(
PromiseSlot_Flags
Int32Value
(
0
)
)
;
if
(
MOZ_LIKELY
(
!
JS
:
:
IsAsyncStackCaptureEnabledForRealm
(
cx
)
)
)
{
return
promise
;
}
Rooted
<
PromiseObject
*
>
promiseRoot
(
cx
promise
)
;
PromiseDebugInfo
*
debugInfo
=
PromiseDebugInfo
:
:
create
(
cx
promiseRoot
)
;
if
(
!
debugInfo
)
{
return
nullptr
;
}
if
(
informDebugger
)
{
DebugAPI
:
:
onNewPromise
(
cx
promiseRoot
)
;
}
return
promiseRoot
;
}
static
bool
PromiseConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Promise
"
)
)
{
return
false
;
}
HandleValue
executorVal
=
args
.
get
(
0
)
;
if
(
!
IsCallable
(
executorVal
)
)
{
return
ReportIsNotFunction
(
cx
executorVal
)
;
}
RootedObject
executor
(
cx
&
executorVal
.
toObject
(
)
)
;
RootedObject
newTarget
(
cx
&
args
.
newTarget
(
)
.
toObject
(
)
)
;
bool
needsWrapping
=
false
;
RootedObject
proto
(
cx
)
;
if
(
IsWrapper
(
newTarget
)
)
{
JSObject
*
unwrappedNewTarget
=
CheckedUnwrapStatic
(
newTarget
)
;
MOZ_ASSERT
(
unwrappedNewTarget
)
;
MOZ_ASSERT
(
unwrappedNewTarget
!
=
newTarget
)
;
newTarget
=
unwrappedNewTarget
;
{
AutoRealm
ar
(
cx
newTarget
)
;
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
JSObject
*
promiseCtor
=
GlobalObject
:
:
getOrCreatePromiseConstructor
(
cx
global
)
;
if
(
!
promiseCtor
)
{
return
false
;
}
if
(
newTarget
=
=
promiseCtor
)
{
needsWrapping
=
true
;
proto
=
GlobalObject
:
:
getOrCreatePromisePrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
false
;
}
}
}
}
if
(
needsWrapping
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
proto
)
)
{
return
false
;
}
}
else
{
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Promise
&
proto
)
)
{
return
false
;
}
}
PromiseObject
*
promise
=
PromiseObject
:
:
create
(
cx
executor
proto
needsWrapping
)
;
if
(
!
promise
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
promise
)
;
if
(
needsWrapping
)
{
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
args
.
rval
(
)
)
;
}
return
true
;
}
PromiseObject
*
PromiseObject
:
:
create
(
JSContext
*
cx
HandleObject
executor
HandleObject
proto
bool
needsWrapping
)
{
MOZ_ASSERT
(
executor
-
>
isCallable
(
)
)
;
RootedObject
usedProto
(
cx
proto
)
;
if
(
needsWrapping
)
{
MOZ_ASSERT
(
proto
)
;
usedProto
=
CheckedUnwrapStatic
(
proto
)
;
if
(
!
usedProto
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectInternal
(
cx
usedProto
needsWrapping
false
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
RootedObject
promiseObj
(
cx
promise
)
;
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseObj
)
)
{
return
nullptr
;
}
RootedObject
resolveFn
(
cx
)
;
RootedObject
rejectFn
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promiseObj
&
resolveFn
&
rejectFn
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
promise
-
>
getFixedSlot
(
PromiseSlot_RejectFunction
)
.
isUndefined
(
)
"
Slot
must
be
undefined
so
initFixedSlot
can
be
used
"
)
;
if
(
needsWrapping
)
{
AutoRealm
ar
(
cx
promise
)
;
RootedObject
wrappedRejectFn
(
cx
rejectFn
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedRejectFn
)
)
{
return
nullptr
;
}
promise
-
>
initFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
wrappedRejectFn
)
)
;
}
else
{
promise
-
>
initFixedSlot
(
PromiseSlot_RejectFunction
ObjectValue
(
*
rejectFn
)
)
;
}
bool
success
;
{
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
resolveFn
)
;
args
[
1
]
.
setObject
(
*
rejectFn
)
;
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
executor
)
)
;
success
=
Call
(
cx
calleeOrRval
UndefinedHandleValue
args
&
calleeOrRval
)
;
}
if
(
!
success
)
{
RootedValue
exceptionVal
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
exceptionVal
&
stack
)
)
{
return
nullptr
;
}
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
rejectFn
)
)
;
if
(
!
Call
(
cx
calleeOrRval
UndefinedHandleValue
exceptionVal
&
calleeOrRval
)
)
{
return
nullptr
;
}
}
DebugAPI
:
:
onNewPromise
(
cx
promise
)
;
return
promise
;
}
PromiseObject
*
PromiseObject
:
:
createSkippingExecutor
(
JSContext
*
cx
)
{
return
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
}
class
MOZ_STACK_CLASS
PromiseForOfIterator
:
public
JS
:
:
ForOfIterator
{
public
:
using
JS
:
:
ForOfIterator
:
:
ForOfIterator
;
bool
isOptimizedDenseArrayIteration
(
)
{
MOZ_ASSERT
(
valueIsIterable
(
)
)
;
return
index
!
=
NOT_ARRAY
&
&
IsPackedArray
(
iterator
)
;
}
}
;
[
[
nodiscard
]
]
static
bool
PerformPromiseAll
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
;
[
[
nodiscard
]
]
static
bool
PerformPromiseAllSettled
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
;
[
[
nodiscard
]
]
static
bool
PerformPromiseAny
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
;
[
[
nodiscard
]
]
static
bool
PerformPromiseRace
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
;
enum
class
CombinatorKind
{
All
AllSettled
Any
Race
}
;
[
[
nodiscard
]
]
static
bool
CommonPromiseCombinator
(
JSContext
*
cx
CallArgs
&
args
CombinatorKind
kind
)
{
HandleValue
iterable
=
args
.
get
(
0
)
;
HandleValue
CVal
=
args
.
thisv
(
)
;
if
(
!
CVal
.
isObject
(
)
)
{
const
char
*
message
;
switch
(
kind
)
{
case
CombinatorKind
:
:
All
:
message
=
"
Receiver
of
Promise
.
all
call
"
;
break
;
case
CombinatorKind
:
:
AllSettled
:
message
=
"
Receiver
of
Promise
.
allSettled
call
"
;
break
;
case
CombinatorKind
:
:
Any
:
message
=
"
Receiver
of
Promise
.
any
call
"
;
break
;
case
CombinatorKind
:
:
Race
:
message
=
"
Receiver
of
Promise
.
race
call
"
;
break
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED
message
)
;
return
false
;
}
RootedObject
C
(
cx
&
CVal
.
toObject
(
)
)
;
Rooted
<
PromiseCapability
>
promiseCapability
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
promiseCapability
false
)
)
{
return
false
;
}
RootedValue
promiseResolve
(
cx
UndefinedValue
(
)
)
;
{
JSObject
*
promiseCtor
=
GlobalObject
:
:
getOrCreatePromiseConstructor
(
cx
cx
-
>
global
(
)
)
;
if
(
!
promiseCtor
)
{
return
false
;
}
PromiseLookup
&
promiseLookup
=
cx
-
>
realm
(
)
-
>
promiseLookup
;
if
(
C
!
=
promiseCtor
|
|
!
promiseLookup
.
isDefaultPromiseState
(
cx
)
)
{
if
(
!
GetProperty
(
cx
C
C
cx
-
>
names
(
)
.
resolve
&
promiseResolve
)
)
{
return
AbruptRejectPromise
(
cx
args
promiseCapability
)
;
}
if
(
!
IsCallable
(
promiseResolve
)
)
{
ReportIsNotFunction
(
cx
promiseResolve
)
;
return
AbruptRejectPromise
(
cx
args
promiseCapability
)
;
}
}
}
PromiseForOfIterator
iter
(
cx
)
;
if
(
!
iter
.
init
(
iterable
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
return
AbruptRejectPromise
(
cx
args
promiseCapability
)
;
}
if
(
!
iter
.
valueIsIterable
(
)
)
{
const
char
*
message
;
switch
(
kind
)
{
case
CombinatorKind
:
:
All
:
message
=
"
Argument
of
Promise
.
all
"
;
break
;
case
CombinatorKind
:
:
AllSettled
:
message
=
"
Argument
of
Promise
.
allSettled
"
;
break
;
case
CombinatorKind
:
:
Any
:
message
=
"
Argument
of
Promise
.
any
"
;
break
;
case
CombinatorKind
:
:
Race
:
message
=
"
Argument
of
Promise
.
race
"
;
break
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
message
)
;
return
AbruptRejectPromise
(
cx
args
promiseCapability
)
;
}
bool
done
result
;
switch
(
kind
)
{
case
CombinatorKind
:
:
All
:
result
=
PerformPromiseAll
(
cx
iter
C
promiseCapability
promiseResolve
&
done
)
;
break
;
case
CombinatorKind
:
:
AllSettled
:
result
=
PerformPromiseAllSettled
(
cx
iter
C
promiseCapability
promiseResolve
&
done
)
;
break
;
case
CombinatorKind
:
:
Any
:
result
=
PerformPromiseAny
(
cx
iter
C
promiseCapability
promiseResolve
&
done
)
;
break
;
case
CombinatorKind
:
:
Race
:
result
=
PerformPromiseRace
(
cx
iter
C
promiseCapability
promiseResolve
&
done
)
;
break
;
}
if
(
!
result
)
{
if
(
!
done
)
{
iter
.
closeThrow
(
)
;
}
return
AbruptRejectPromise
(
cx
args
promiseCapability
)
;
}
args
.
rval
(
)
.
setObject
(
*
promiseCapability
.
promise
(
)
)
;
return
true
;
}
static
bool
Promise_static_all
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CommonPromiseCombinator
(
cx
args
CombinatorKind
:
:
All
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled_
HandleValue
onRejected_
Handle
<
PromiseCapability
>
resultCapability
)
;
[
[
nodiscard
]
]
static
bool
PerformPromiseThenWithoutSettleHandlers
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseObject
*
>
promiseToResolve
Handle
<
PromiseCapability
>
resultCapability
)
;
static
JSFunction
*
NewPromiseCombinatorElementFunction
(
JSContext
*
cx
Native
native
Handle
<
PromiseCombinatorDataHolder
*
>
dataHolder
uint32_t
index
)
;
static
bool
PromiseAllResolveElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
[
[
nodiscard
]
]
JSObject
*
js
:
:
GetWaitForAllPromise
(
JSContext
*
cx
JS
:
:
HandleObjectVector
promises
)
{
#
ifdef
DEBUG
for
(
size_t
i
=
0
len
=
promises
.
length
(
)
;
i
<
len
;
i
+
+
)
{
JSObject
*
obj
=
promises
[
i
]
;
cx
-
>
check
(
obj
)
;
MOZ_ASSERT
(
UncheckedUnwrap
(
obj
)
-
>
is
<
PromiseObject
>
(
)
)
;
}
#
endif
RootedObject
C
(
cx
GlobalObject
:
:
getOrCreatePromiseConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
C
)
{
return
nullptr
;
}
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
resultCapability
false
)
)
{
return
nullptr
;
}
{
uint32_t
promiseCount
=
promises
.
length
(
)
;
Rooted
<
PromiseCombinatorElements
>
values
(
cx
)
;
{
auto
*
valuesArray
=
NewDenseFullyAllocatedArray
(
cx
promiseCount
)
;
if
(
!
valuesArray
)
{
return
nullptr
;
}
valuesArray
-
>
ensureDenseInitializedLength
(
0
promiseCount
)
;
values
.
initialize
(
valuesArray
)
;
}
Rooted
<
PromiseCombinatorDataHolder
*
>
dataHolder
(
cx
)
;
dataHolder
=
PromiseCombinatorDataHolder
:
:
New
(
cx
resultCapability
.
promise
(
)
values
resultCapability
.
resolve
(
)
)
;
if
(
!
dataHolder
)
{
return
nullptr
;
}
Rooted
<
PromiseCapability
>
resultCapabilityWithoutResolving
(
cx
)
;
resultCapabilityWithoutResolving
.
promise
(
)
.
set
(
resultCapability
.
promise
(
)
)
;
for
(
uint32_t
index
=
0
;
index
<
promiseCount
;
index
+
+
)
{
values
.
unwrappedArray
(
)
-
>
setDenseElement
(
index
UndefinedHandleValue
)
;
RootedObject
nextPromiseObj
(
cx
promises
[
index
]
)
;
JSFunction
*
resolveFunc
=
NewPromiseCombinatorElementFunction
(
cx
PromiseAllResolveElementFunction
dataHolder
index
)
;
if
(
!
resolveFunc
)
{
return
nullptr
;
}
dataHolder
-
>
increaseRemainingCount
(
)
;
RootedValue
resolveFunVal
(
cx
ObjectValue
(
*
resolveFunc
)
)
;
RootedValue
rejectFunVal
(
cx
ObjectValue
(
*
resultCapability
.
reject
(
)
)
)
;
Rooted
<
PromiseObject
*
>
nextPromise
(
cx
)
;
nextPromise
=
&
UncheckedUnwrap
(
nextPromiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
if
(
!
PerformPromiseThen
(
cx
nextPromise
resolveFunVal
rejectFunVal
resultCapabilityWithoutResolving
)
)
{
return
nullptr
;
}
}
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
if
(
!
ResolvePromiseInternal
(
cx
resultCapability
.
promise
(
)
values
.
value
(
)
)
)
{
return
nullptr
;
}
}
}
return
resultCapability
.
promise
(
)
;
}
static
bool
CallDefaultPromiseResolveFunction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
resolutionValue
)
;
static
bool
CallDefaultPromiseRejectFunction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
rejectionValue
JS
:
:
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
=
nullptr
)
;
[
[
nodiscard
]
]
static
bool
CallPromiseResolveFunction
(
JSContext
*
cx
HandleObject
resolveFun
HandleValue
value
HandleObject
promiseObj
)
{
cx
-
>
check
(
resolveFun
)
;
cx
-
>
check
(
value
)
;
cx
-
>
check
(
promiseObj
)
;
if
(
resolveFun
)
{
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
resolveFun
)
)
;
return
Call
(
cx
calleeOrRval
UndefinedHandleValue
value
&
calleeOrRval
)
;
}
if
(
!
promiseObj
)
{
return
true
;
}
Handle
<
PromiseObject
*
>
promise
=
promiseObj
.
as
<
PromiseObject
>
(
)
;
if
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
CallDefaultPromiseResolveFunction
(
cx
promise
value
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
CallPromiseRejectFunction
(
JSContext
*
cx
HandleObject
rejectFun
HandleValue
reason
HandleObject
promiseObj
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
UnhandledRejectionBehavior
behavior
)
{
cx
-
>
check
(
rejectFun
)
;
cx
-
>
check
(
reason
)
;
cx
-
>
check
(
promiseObj
)
;
if
(
rejectFun
)
{
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
rejectFun
)
)
;
return
Call
(
cx
calleeOrRval
UndefinedHandleValue
reason
&
calleeOrRval
)
;
}
if
(
!
promiseObj
)
{
if
(
behavior
=
=
UnhandledRejectionBehavior
:
:
Ignore
)
{
return
true
;
}
Rooted
<
PromiseObject
*
>
temporaryPromise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
temporaryPromise
)
{
cx
-
>
clearPendingException
(
)
;
return
true
;
}
return
RejectPromiseInternal
(
cx
temporaryPromise
reason
unwrappedRejectionStack
)
;
}
Handle
<
PromiseObject
*
>
promise
=
promiseObj
.
as
<
PromiseObject
>
(
)
;
if
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
CallDefaultPromiseRejectFunction
(
cx
promise
reason
unwrappedRejectionStack
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
JSObject
*
CommonStaticResolveRejectImpl
(
JSContext
*
cx
HandleValue
thisVal
HandleValue
argVal
ResolutionMode
mode
)
;
static
bool
IsPromiseSpecies
(
JSContext
*
cx
JSFunction
*
species
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
static
bool
CommonPerformPromiseCombinator
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
HandleObject
resultPromise
HandleValue
promiseResolve
bool
*
done
bool
resolveReturnsUndefined
T
getResolveAndReject
)
{
RootedObject
promiseCtor
(
cx
GlobalObject
:
:
getOrCreatePromiseConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
promiseCtor
)
{
return
false
;
}
bool
iterationMayHaveSideEffects
=
!
iterator
.
isOptimizedDenseArrayIteration
(
)
;
PromiseLookup
&
promiseLookup
=
cx
-
>
realm
(
)
-
>
promiseLookup
;
bool
isDefaultPromiseState
=
C
=
=
promiseCtor
&
&
promiseLookup
.
isDefaultPromiseState
(
cx
)
;
bool
validatePromiseState
=
iterationMayHaveSideEffects
;
RootedValue
CVal
(
cx
ObjectValue
(
*
C
)
)
;
RootedValue
resolveFunVal
(
cx
)
;
RootedValue
rejectFunVal
(
cx
)
;
RootedValue
nextValueOrNextPromise
(
cx
)
;
RootedObject
nextPromiseObj
(
cx
)
;
RootedValue
thenVal
(
cx
)
;
RootedObject
thenSpeciesOrBlockedPromise
(
cx
)
;
Rooted
<
PromiseCapability
>
thenCapability
(
cx
)
;
while
(
true
)
{
RootedValue
&
nextValue
=
nextValueOrNextPromise
;
if
(
!
iterator
.
next
(
&
nextValue
done
)
)
{
*
done
=
true
;
return
false
;
}
if
(
*
done
)
{
return
true
;
}
bool
getThen
=
true
;
if
(
isDefaultPromiseState
&
&
validatePromiseState
)
{
isDefaultPromiseState
=
promiseLookup
.
isDefaultPromiseState
(
cx
)
;
}
RootedValue
&
nextPromise
=
nextValueOrNextPromise
;
if
(
isDefaultPromiseState
)
{
PromiseObject
*
nextValuePromise
=
nullptr
;
if
(
nextValue
.
isObject
(
)
&
&
nextValue
.
toObject
(
)
.
is
<
PromiseObject
>
(
)
)
{
nextValuePromise
=
&
nextValue
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
if
(
nextValuePromise
&
&
promiseLookup
.
isDefaultInstanceWhenPromiseStateIsSane
(
cx
nextValuePromise
)
)
{
validatePromiseState
=
iterationMayHaveSideEffects
;
MOZ_ASSERT
(
&
nextPromise
.
toObject
(
)
=
=
nextValuePromise
)
;
getThen
=
false
;
}
else
{
validatePromiseState
=
true
;
JSObject
*
res
=
CommonStaticResolveRejectImpl
(
cx
CVal
nextValue
ResolveMode
)
;
if
(
!
res
)
{
return
false
;
}
nextPromise
.
setObject
(
*
res
)
;
}
}
else
if
(
promiseResolve
.
isUndefined
(
)
)
{
JSObject
*
res
=
CommonStaticResolveRejectImpl
(
cx
CVal
nextValue
ResolveMode
)
;
if
(
!
res
)
{
return
false
;
}
nextPromise
.
setObject
(
*
res
)
;
}
else
{
if
(
!
Call
(
cx
promiseResolve
CVal
nextValue
&
nextPromise
)
)
{
return
false
;
}
}
if
(
!
getResolveAndReject
(
&
resolveFunVal
&
rejectFunVal
)
)
{
return
false
;
}
nextPromiseObj
=
ToObject
(
cx
nextPromise
)
;
if
(
!
nextPromiseObj
)
{
return
false
;
}
bool
isBuiltinThen
;
if
(
getThen
)
{
if
(
!
GetProperty
(
cx
nextPromiseObj
nextPromise
cx
-
>
names
(
)
.
then
&
thenVal
)
)
{
return
false
;
}
isBuiltinThen
=
nextPromiseObj
-
>
is
<
PromiseObject
>
(
)
&
&
IsNativeFunction
(
thenVal
Promise_then
)
;
}
else
{
isBuiltinThen
=
true
;
}
bool
addToDependent
=
true
;
if
(
isBuiltinThen
)
{
MOZ_ASSERT
(
nextPromise
.
isObject
(
)
)
;
MOZ_ASSERT
(
&
nextPromise
.
toObject
(
)
=
=
nextPromiseObj
)
;
RootedObject
&
thenSpecies
=
thenSpeciesOrBlockedPromise
;
if
(
getThen
)
{
thenSpecies
=
SpeciesConstructor
(
cx
nextPromiseObj
JSProto_Promise
IsPromiseSpecies
)
;
if
(
!
thenSpecies
)
{
return
false
;
}
}
else
{
thenSpecies
=
promiseCtor
;
}
thenCapability
.
resolve
(
)
.
set
(
nullptr
)
;
thenCapability
.
reject
(
)
.
set
(
nullptr
)
;
if
(
thenSpecies
=
=
promiseCtor
&
&
resolveReturnsUndefined
&
&
resultPromise
-
>
is
<
PromiseObject
>
(
)
&
&
!
IsPromiseWithDefaultResolvingFunction
(
&
resultPromise
-
>
as
<
PromiseObject
>
(
)
)
)
{
thenCapability
.
promise
(
)
.
set
(
resultPromise
)
;
addToDependent
=
false
;
}
else
{
if
(
!
NewPromiseCapability
(
cx
thenSpecies
&
thenCapability
true
)
)
{
return
false
;
}
}
Handle
<
PromiseObject
*
>
promise
=
nextPromiseObj
.
as
<
PromiseObject
>
(
)
;
if
(
!
PerformPromiseThen
(
cx
promise
resolveFunVal
rejectFunVal
thenCapability
)
)
{
return
false
;
}
}
else
{
RootedValue
&
ignored
=
thenVal
;
if
(
!
Call
(
cx
thenVal
nextPromise
resolveFunVal
rejectFunVal
&
ignored
)
)
{
return
false
;
}
if
(
!
nextPromise
.
isObject
(
)
)
{
addToDependent
=
false
;
}
}
if
(
addToDependent
)
{
RootedObject
&
blockedPromise
=
thenSpeciesOrBlockedPromise
;
blockedPromise
=
resultPromise
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
IsProxy
(
nextPromiseObj
)
)
{
nextPromiseObj
=
CheckedUnwrapStatic
(
nextPromiseObj
)
;
if
(
!
nextPromiseObj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
JS_IsDeadWrapper
(
nextPromiseObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
ar
.
emplace
(
cx
nextPromiseObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
blockedPromise
)
)
{
return
false
;
}
}
if
(
nextPromiseObj
-
>
is
<
PromiseObject
>
(
)
&
&
resultPromise
-
>
is
<
PromiseObject
>
(
)
)
{
Handle
<
PromiseObject
*
>
promise
=
nextPromiseObj
.
as
<
PromiseObject
>
(
)
;
if
(
!
AddDummyPromiseReactionForDebugger
(
cx
promise
blockedPromise
)
)
{
return
false
;
}
}
}
}
}
[
[
nodiscard
]
]
static
bool
NewPromiseCombinatorElements
(
JSContext
*
cx
Handle
<
PromiseCapability
>
resultCapability
MutableHandle
<
PromiseCombinatorElements
>
elements
)
{
if
(
IsWrapper
(
resultCapability
.
promise
(
)
)
)
{
JSObject
*
unwrappedPromiseObj
=
CheckedUnwrapStatic
(
resultCapability
.
promise
(
)
)
;
MOZ_ASSERT
(
unwrappedPromiseObj
)
;
{
AutoRealm
ar
(
cx
unwrappedPromiseObj
)
;
auto
*
array
=
NewDenseEmptyArray
(
cx
)
;
if
(
!
array
)
{
return
false
;
}
elements
.
initialize
(
array
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
elements
.
value
(
)
)
)
{
return
false
;
}
}
else
{
auto
*
array
=
NewDenseEmptyArray
(
cx
)
;
if
(
!
array
)
{
return
false
;
}
elements
.
initialize
(
array
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
GetPromiseCombinatorElements
(
JSContext
*
cx
Handle
<
PromiseCombinatorDataHolder
*
>
data
MutableHandle
<
PromiseCombinatorElements
>
elements
)
{
bool
needsWrapping
=
false
;
JSObject
*
valuesObj
=
&
data
-
>
valuesArray
(
)
.
toObject
(
)
;
if
(
IsProxy
(
valuesObj
)
)
{
valuesObj
=
UncheckedUnwrap
(
valuesObj
)
;
if
(
JS_IsDeadWrapper
(
valuesObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
needsWrapping
=
true
;
}
elements
.
initialize
(
data
&
valuesObj
-
>
as
<
ArrayObject
>
(
)
needsWrapping
)
;
return
true
;
}
static
JSFunction
*
NewPromiseCombinatorElementFunction
(
JSContext
*
cx
Native
native
Handle
<
PromiseCombinatorDataHolder
*
>
dataHolder
uint32_t
index
)
{
JSFunction
*
fn
=
NewNativeFunction
(
cx
native
1
nullptr
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
;
if
(
!
fn
)
{
return
nullptr
;
}
fn
-
>
setExtendedSlot
(
PromiseCombinatorElementFunctionSlot_Data
ObjectValue
(
*
dataHolder
)
)
;
fn
-
>
setExtendedSlot
(
PromiseCombinatorElementFunctionSlot_ElementIndex
Int32Value
(
index
)
)
;
return
fn
;
}
static
bool
PromiseCombinatorElementFunctionAlreadyCalled
(
const
CallArgs
&
args
MutableHandle
<
PromiseCombinatorDataHolder
*
>
data
uint32_t
*
index
)
{
JSFunction
*
fn
=
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
const
Value
&
dataVal
=
fn
-
>
getExtendedSlot
(
PromiseCombinatorElementFunctionSlot_Data
)
;
if
(
dataVal
.
isUndefined
(
)
)
{
return
true
;
}
data
.
set
(
&
dataVal
.
toObject
(
)
.
as
<
PromiseCombinatorDataHolder
>
(
)
)
;
fn
-
>
setExtendedSlot
(
PromiseCombinatorElementFunctionSlot_Data
UndefinedValue
(
)
)
;
int32_t
idx
=
fn
-
>
getExtendedSlot
(
PromiseCombinatorElementFunctionSlot_ElementIndex
)
.
toInt32
(
)
;
MOZ_ASSERT
(
idx
>
=
0
)
;
*
index
=
uint32_t
(
idx
)
;
return
false
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseAll
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
{
*
done
=
false
;
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
Rooted
<
PromiseCombinatorElements
>
values
(
cx
)
;
if
(
!
NewPromiseCombinatorElements
(
cx
resultCapability
&
values
)
)
{
return
false
;
}
Rooted
<
PromiseCombinatorDataHolder
*
>
dataHolder
(
cx
)
;
dataHolder
=
PromiseCombinatorDataHolder
:
:
New
(
cx
resultCapability
.
promise
(
)
values
resultCapability
.
resolve
(
)
)
;
if
(
!
dataHolder
)
{
return
false
;
}
uint32_t
index
=
0
;
auto
getResolveAndReject
=
[
cx
&
resultCapability
&
values
&
dataHolder
&
index
]
(
MutableHandleValue
resolveFunVal
MutableHandleValue
rejectFunVal
)
{
if
(
!
values
.
pushUndefined
(
cx
)
)
{
return
false
;
}
JSFunction
*
resolveFunc
=
NewPromiseCombinatorElementFunction
(
cx
PromiseAllResolveElementFunction
dataHolder
index
)
;
if
(
!
resolveFunc
)
{
return
false
;
}
dataHolder
-
>
increaseRemainingCount
(
)
;
index
+
+
;
MOZ_ASSERT
(
index
>
0
)
;
resolveFunVal
.
setObject
(
*
resolveFunc
)
;
rejectFunVal
.
setObject
(
*
resultCapability
.
reject
(
)
)
;
return
true
;
}
;
if
(
!
CommonPerformPromiseCombinator
(
cx
iterator
C
resultCapability
.
promise
(
)
promiseResolve
done
true
getResolveAndReject
)
)
{
return
false
;
}
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
return
CallPromiseResolveFunction
(
cx
resultCapability
.
resolve
(
)
values
.
value
(
)
resultCapability
.
promise
(
)
)
;
}
return
true
;
}
static
bool
PromiseAllResolveElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
xVal
=
args
.
get
(
0
)
;
Rooted
<
PromiseCombinatorDataHolder
*
>
data
(
cx
)
;
uint32_t
index
;
if
(
PromiseCombinatorElementFunctionAlreadyCalled
(
args
&
data
&
index
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PromiseCombinatorElements
>
values
(
cx
)
;
if
(
!
GetPromiseCombinatorElements
(
cx
data
&
values
)
)
{
return
false
;
}
if
(
!
values
.
setElement
(
cx
index
xVal
)
)
{
return
false
;
}
uint32_t
remainingCount
=
data
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
RootedObject
resolveAllFun
(
cx
data
-
>
resolveOrRejectObj
(
)
)
;
RootedObject
promiseObj
(
cx
data
-
>
promiseObj
(
)
)
;
if
(
!
CallPromiseResolveFunction
(
cx
resolveAllFun
values
.
value
(
)
promiseObj
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
Promise_static_race
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CommonPromiseCombinator
(
cx
args
CombinatorKind
:
:
Race
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseRace
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
{
*
done
=
false
;
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
bool
isDefaultResolveFn
=
IsNativeFunction
(
resultCapability
.
resolve
(
)
ResolvePromiseFunction
)
;
auto
getResolveAndReject
=
[
&
resultCapability
]
(
MutableHandleValue
resolveFunVal
MutableHandleValue
rejectFunVal
)
{
resolveFunVal
.
setObject
(
*
resultCapability
.
resolve
(
)
)
;
rejectFunVal
.
setObject
(
*
resultCapability
.
reject
(
)
)
;
return
true
;
}
;
return
CommonPerformPromiseCombinator
(
cx
iterator
C
resultCapability
.
promise
(
)
promiseResolve
done
isDefaultResolveFn
getResolveAndReject
)
;
}
enum
class
PromiseAllSettledElementFunctionKind
{
Resolve
Reject
}
;
template
<
PromiseAllSettledElementFunctionKind
Kind
>
static
bool
PromiseAllSettledElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Promise_static_allSettled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CommonPromiseCombinator
(
cx
args
CombinatorKind
:
:
AllSettled
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseAllSettled
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
{
*
done
=
false
;
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
Rooted
<
PromiseCombinatorElements
>
values
(
cx
)
;
if
(
!
NewPromiseCombinatorElements
(
cx
resultCapability
&
values
)
)
{
return
false
;
}
Rooted
<
PromiseCombinatorDataHolder
*
>
dataHolder
(
cx
)
;
dataHolder
=
PromiseCombinatorDataHolder
:
:
New
(
cx
resultCapability
.
promise
(
)
values
resultCapability
.
resolve
(
)
)
;
if
(
!
dataHolder
)
{
return
false
;
}
uint32_t
index
=
0
;
auto
getResolveAndReject
=
[
cx
&
values
&
dataHolder
&
index
]
(
MutableHandleValue
resolveFunVal
MutableHandleValue
rejectFunVal
)
{
if
(
!
values
.
pushUndefined
(
cx
)
)
{
return
false
;
}
auto
PromiseAllSettledResolveElementFunction
=
PromiseAllSettledElementFunction
<
PromiseAllSettledElementFunctionKind
:
:
Resolve
>
;
auto
PromiseAllSettledRejectElementFunction
=
PromiseAllSettledElementFunction
<
PromiseAllSettledElementFunctionKind
:
:
Reject
>
;
JSFunction
*
resolveFunc
=
NewPromiseCombinatorElementFunction
(
cx
PromiseAllSettledResolveElementFunction
dataHolder
index
)
;
if
(
!
resolveFunc
)
{
return
false
;
}
resolveFunVal
.
setObject
(
*
resolveFunc
)
;
JSFunction
*
rejectFunc
=
NewPromiseCombinatorElementFunction
(
cx
PromiseAllSettledRejectElementFunction
dataHolder
index
)
;
if
(
!
rejectFunc
)
{
return
false
;
}
rejectFunVal
.
setObject
(
*
rejectFunc
)
;
dataHolder
-
>
increaseRemainingCount
(
)
;
index
+
+
;
MOZ_ASSERT
(
index
>
0
)
;
return
true
;
}
;
if
(
!
CommonPerformPromiseCombinator
(
cx
iterator
C
resultCapability
.
promise
(
)
promiseResolve
done
true
getResolveAndReject
)
)
{
return
false
;
}
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
return
CallPromiseResolveFunction
(
cx
resultCapability
.
resolve
(
)
values
.
value
(
)
resultCapability
.
promise
(
)
)
;
}
return
true
;
}
template
<
PromiseAllSettledElementFunctionKind
Kind
>
static
bool
PromiseAllSettledElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
valueOrReason
=
args
.
get
(
0
)
;
Rooted
<
PromiseCombinatorDataHolder
*
>
data
(
cx
)
;
uint32_t
index
;
if
(
PromiseCombinatorElementFunctionAlreadyCalled
(
args
&
data
&
index
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PromiseCombinatorElements
>
values
(
cx
)
;
if
(
!
GetPromiseCombinatorElements
(
cx
data
&
values
)
)
{
return
false
;
}
if
(
!
values
.
unwrappedArray
(
)
-
>
getDenseElement
(
index
)
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PlainObject
*
>
obj
(
cx
NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
false
;
}
RootedId
id
(
cx
NameToId
(
cx
-
>
names
(
)
.
status
)
)
;
RootedValue
statusValue
(
cx
)
;
if
(
Kind
=
=
PromiseAllSettledElementFunctionKind
:
:
Resolve
)
{
statusValue
.
setString
(
cx
-
>
names
(
)
.
fulfilled
)
;
}
else
{
statusValue
.
setString
(
cx
-
>
names
(
)
.
rejected
)
;
}
if
(
!
NativeDefineDataProperty
(
cx
obj
id
statusValue
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
Kind
=
=
PromiseAllSettledElementFunctionKind
:
:
Resolve
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
value
)
;
}
else
{
id
=
NameToId
(
cx
-
>
names
(
)
.
reason
)
;
}
if
(
!
NativeDefineDataProperty
(
cx
obj
id
valueOrReason
JSPROP_ENUMERATE
)
)
{
return
false
;
}
RootedValue
objVal
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
!
values
.
setElement
(
cx
index
objVal
)
)
{
return
false
;
}
uint32_t
remainingCount
=
data
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
RootedObject
resolveAllFun
(
cx
data
-
>
resolveOrRejectObj
(
)
)
;
RootedObject
promiseObj
(
cx
data
-
>
promiseObj
(
)
)
;
if
(
!
CallPromiseResolveFunction
(
cx
resolveAllFun
values
.
value
(
)
promiseObj
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
Promise_static_any
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CommonPromiseCombinator
(
cx
args
CombinatorKind
:
:
Any
)
;
}
static
bool
PromiseAnyRejectElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
void
ThrowAggregateError
(
JSContext
*
cx
Handle
<
PromiseCombinatorElements
>
errors
HandleObject
promise
)
;
[
[
nodiscard
]
]
static
bool
PerformPromiseAny
(
JSContext
*
cx
PromiseForOfIterator
&
iterator
HandleObject
C
Handle
<
PromiseCapability
>
resultCapability
HandleValue
promiseResolve
bool
*
done
)
{
*
done
=
false
;
MOZ_ASSERT
(
C
-
>
isConstructor
(
)
)
;
Rooted
<
PromiseCombinatorElements
>
errors
(
cx
)
;
if
(
!
NewPromiseCombinatorElements
(
cx
resultCapability
&
errors
)
)
{
return
false
;
}
Rooted
<
PromiseCombinatorDataHolder
*
>
dataHolder
(
cx
)
;
dataHolder
=
PromiseCombinatorDataHolder
:
:
New
(
cx
resultCapability
.
promise
(
)
errors
resultCapability
.
reject
(
)
)
;
if
(
!
dataHolder
)
{
return
false
;
}
uint32_t
index
=
0
;
auto
getResolveAndReject
=
[
cx
&
resultCapability
&
errors
&
dataHolder
&
index
]
(
MutableHandleValue
resolveFunVal
MutableHandleValue
rejectFunVal
)
{
if
(
!
errors
.
pushUndefined
(
cx
)
)
{
return
false
;
}
JSFunction
*
rejectFunc
=
NewPromiseCombinatorElementFunction
(
cx
PromiseAnyRejectElementFunction
dataHolder
index
)
;
if
(
!
rejectFunc
)
{
return
false
;
}
dataHolder
-
>
increaseRemainingCount
(
)
;
index
+
+
;
MOZ_ASSERT
(
index
>
0
)
;
resolveFunVal
.
setObject
(
*
resultCapability
.
resolve
(
)
)
;
rejectFunVal
.
setObject
(
*
rejectFunc
)
;
return
true
;
}
;
bool
isDefaultResolveFn
=
IsNativeFunction
(
resultCapability
.
resolve
(
)
ResolvePromiseFunction
)
;
if
(
!
CommonPerformPromiseCombinator
(
cx
iterator
C
resultCapability
.
promise
(
)
promiseResolve
done
isDefaultResolveFn
getResolveAndReject
)
)
{
return
false
;
}
int32_t
remainingCount
=
dataHolder
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
ThrowAggregateError
(
cx
errors
resultCapability
.
promise
(
)
)
;
return
false
;
}
return
true
;
}
static
bool
PromiseAnyRejectElementFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
xVal
=
args
.
get
(
0
)
;
Rooted
<
PromiseCombinatorDataHolder
*
>
data
(
cx
)
;
uint32_t
index
;
if
(
PromiseCombinatorElementFunctionAlreadyCalled
(
args
&
data
&
index
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PromiseCombinatorElements
>
errors
(
cx
)
;
if
(
!
GetPromiseCombinatorElements
(
cx
data
&
errors
)
)
{
return
false
;
}
if
(
!
errors
.
setElement
(
cx
index
xVal
)
)
{
return
false
;
}
uint32_t
remainingCount
=
data
-
>
decreaseRemainingCount
(
)
;
if
(
remainingCount
=
=
0
)
{
RootedObject
rejectFun
(
cx
data
-
>
resolveOrRejectObj
(
)
)
;
RootedObject
promiseObj
(
cx
data
-
>
promiseObj
(
)
)
;
ThrowAggregateError
(
cx
errors
promiseObj
)
;
RootedValue
reason
(
cx
)
;
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
!
MaybeGetAndClearExceptionAndStack
(
cx
&
reason
&
stack
)
)
{
return
false
;
}
if
(
!
CallPromiseRejectFunction
(
cx
rejectFun
reason
promiseObj
stack
UnhandledRejectionBehavior
:
:
Report
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
void
ThrowAggregateError
(
JSContext
*
cx
Handle
<
PromiseCombinatorElements
>
errors
HandleObject
promise
)
{
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
AutoRealm
ar
(
cx
errors
.
unwrappedArray
(
)
)
;
RootedObject
allocationSite
(
cx
)
;
mozilla
:
:
Maybe
<
JS
:
:
AutoSetAsyncStackForNewCalls
>
asyncStack
;
if
(
promise
-
>
is
<
PromiseObject
>
(
)
)
{
allocationSite
=
promise
-
>
as
<
PromiseObject
>
(
)
.
allocationSite
(
)
;
if
(
allocationSite
)
{
asyncStack
.
emplace
(
cx
allocationSite
"
Promise
.
any
"
JS
:
:
AutoSetAsyncStackForNewCalls
:
:
AsyncCallKind
:
:
IMPLICIT
)
;
}
}
RootedValue
error
(
cx
)
;
if
(
!
GetAggregateError
(
cx
JSMSG_PROMISE_ANY_REJECTION
&
error
)
)
{
return
;
}
Rooted
<
SavedFrame
*
>
stack
(
cx
)
;
if
(
error
.
isObject
(
)
&
&
error
.
toObject
(
)
.
is
<
ErrorObject
>
(
)
)
{
Rooted
<
ErrorObject
*
>
errorObj
(
cx
&
error
.
toObject
(
)
.
as
<
ErrorObject
>
(
)
)
;
if
(
errorObj
-
>
type
(
)
=
=
JSEXN_AGGREGATEERR
)
{
RootedValue
errorsVal
(
cx
JS
:
:
ObjectValue
(
*
errors
.
unwrappedArray
(
)
)
)
;
if
(
!
NativeDefineDataProperty
(
cx
errorObj
cx
-
>
names
(
)
.
errors
errorsVal
0
)
)
{
return
;
}
if
(
JSObject
*
errorStack
=
errorObj
-
>
stack
(
)
)
{
stack
=
&
errorStack
-
>
as
<
SavedFrame
>
(
)
;
}
}
}
cx
-
>
setPendingException
(
error
stack
)
;
}
[
[
nodiscard
]
]
static
JSObject
*
CommonStaticResolveRejectImpl
(
JSContext
*
cx
HandleValue
thisVal
HandleValue
argVal
ResolutionMode
mode
)
{
if
(
!
thisVal
.
isObject
(
)
)
{
const
char
*
msg
=
mode
=
=
ResolveMode
?
"
Receiver
of
Promise
.
resolve
call
"
:
"
Receiver
of
Promise
.
reject
call
"
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED
msg
)
;
return
nullptr
;
}
RootedObject
C
(
cx
&
thisVal
.
toObject
(
)
)
;
if
(
mode
=
=
ResolveMode
&
&
argVal
.
isObject
(
)
)
{
RootedObject
xObj
(
cx
&
argVal
.
toObject
(
)
)
;
bool
isPromise
=
false
;
if
(
xObj
-
>
is
<
PromiseObject
>
(
)
)
{
isPromise
=
true
;
}
else
if
(
IsWrapper
(
xObj
)
)
{
if
(
xObj
-
>
canUnwrapAs
<
PromiseObject
>
(
)
)
{
isPromise
=
true
;
}
}
if
(
isPromise
)
{
RootedValue
ctorVal
(
cx
)
;
if
(
!
GetProperty
(
cx
xObj
xObj
cx
-
>
names
(
)
.
constructor
&
ctorVal
)
)
{
return
nullptr
;
}
if
(
ctorVal
=
=
thisVal
)
{
return
xObj
;
}
}
}
Rooted
<
PromiseCapability
>
capability
(
cx
)
;
if
(
!
NewPromiseCapability
(
cx
C
&
capability
true
)
)
{
return
nullptr
;
}
HandleObject
promise
=
capability
.
promise
(
)
;
if
(
mode
=
=
ResolveMode
)
{
if
(
!
CallPromiseResolveFunction
(
cx
capability
.
resolve
(
)
argVal
promise
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
CallPromiseRejectFunction
(
cx
capability
.
reject
(
)
argVal
promise
nullptr
UnhandledRejectionBehavior
:
:
Report
)
)
{
return
nullptr
;
}
}
return
promise
;
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
PromiseResolve
(
JSContext
*
cx
HandleObject
constructor
HandleValue
value
)
{
RootedValue
C
(
cx
ObjectValue
(
*
constructor
)
)
;
return
CommonStaticResolveRejectImpl
(
cx
C
value
ResolveMode
)
;
}
static
bool
Promise_reject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
thisVal
=
args
.
thisv
(
)
;
HandleValue
argVal
=
args
.
get
(
0
)
;
JSObject
*
result
=
CommonStaticResolveRejectImpl
(
cx
thisVal
argVal
RejectMode
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
PromiseObject
*
PromiseObject
:
:
unforgeableReject
(
JSContext
*
cx
HandleValue
value
)
{
cx
-
>
check
(
value
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
if
(
!
RejectPromiseInternal
(
cx
promise
value
)
)
{
return
nullptr
;
}
return
promise
;
}
bool
js
:
:
Promise_static_resolve
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
thisVal
=
args
.
thisv
(
)
;
HandleValue
argVal
=
args
.
get
(
0
)
;
JSObject
*
result
=
CommonStaticResolveRejectImpl
(
cx
thisVal
argVal
ResolveMode
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
JSObject
*
PromiseObject
:
:
unforgeableResolve
(
JSContext
*
cx
HandleValue
value
)
{
JSObject
*
promiseCtor
=
JS
:
:
GetPromiseConstructor
(
cx
)
;
if
(
!
promiseCtor
)
{
return
nullptr
;
}
RootedValue
cVal
(
cx
ObjectValue
(
*
promiseCtor
)
)
;
return
CommonStaticResolveRejectImpl
(
cx
cVal
value
ResolveMode
)
;
}
PromiseObject
*
PromiseObject
:
:
unforgeableResolveWithNonPromise
(
JSContext
*
cx
HandleValue
value
)
{
cx
-
>
check
(
value
)
;
#
ifdef
DEBUG
auto
IsPromise
=
[
]
(
HandleValue
value
)
{
if
(
!
value
.
isObject
(
)
)
{
return
false
;
}
JSObject
*
obj
=
&
value
.
toObject
(
)
;
if
(
obj
-
>
is
<
PromiseObject
>
(
)
)
{
return
true
;
}
if
(
!
IsWrapper
(
obj
)
)
{
return
false
;
}
return
obj
-
>
canUnwrapAs
<
PromiseObject
>
(
)
;
}
;
MOZ_ASSERT
(
!
IsPromise
(
value
)
"
must
use
unforgeableResolve
with
this
value
"
)
;
#
endif
Rooted
<
PromiseObject
*
>
promise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
promise
)
{
return
nullptr
;
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
if
(
!
ResolvePromiseInternal
(
cx
promise
value
)
)
{
return
nullptr
;
}
return
promise
;
}
bool
js
:
:
Promise_static_species
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
args
.
thisv
(
)
)
;
return
true
;
}
enum
class
IncumbentGlobalObject
{
No
Yes
}
;
static
PromiseReactionRecord
*
NewReactionRecord
(
JSContext
*
cx
Handle
<
PromiseCapability
>
resultCapability
HandleValue
onFulfilled
HandleValue
onRejected
IncumbentGlobalObject
incumbentGlobalObjectOption
)
{
#
ifdef
DEBUG
if
(
resultCapability
.
promise
(
)
)
{
if
(
incumbentGlobalObjectOption
=
=
IncumbentGlobalObject
:
:
Yes
)
{
if
(
resultCapability
.
promise
(
)
-
>
is
<
PromiseObject
>
(
)
)
{
MOZ_ASSERT_IF
(
resultCapability
.
resolve
(
)
IsCallable
(
resultCapability
.
resolve
(
)
)
)
;
MOZ_ASSERT_IF
(
resultCapability
.
reject
(
)
IsCallable
(
resultCapability
.
reject
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
resultCapability
.
resolve
(
)
)
;
MOZ_ASSERT
(
IsCallable
(
resultCapability
.
resolve
(
)
)
)
;
MOZ_ASSERT
(
resultCapability
.
reject
(
)
)
;
MOZ_ASSERT
(
IsCallable
(
resultCapability
.
reject
(
)
)
)
;
}
}
else
{
JSObject
*
unwrappedPromise
=
UncheckedUnwrap
(
resultCapability
.
promise
(
)
)
;
MOZ_ASSERT
(
unwrappedPromise
-
>
is
<
PromiseObject
>
(
)
)
;
MOZ_ASSERT
(
!
resultCapability
.
resolve
(
)
)
;
MOZ_ASSERT
(
!
resultCapability
.
reject
(
)
)
;
}
}
else
{
MOZ_ASSERT
(
!
resultCapability
.
resolve
(
)
)
;
MOZ_ASSERT
(
!
resultCapability
.
reject
(
)
)
;
MOZ_ASSERT
(
incumbentGlobalObjectOption
=
=
IncumbentGlobalObject
:
:
Yes
)
;
}
#
endif
MOZ_ASSERT
(
onFulfilled
.
isInt32
(
)
|
|
onFulfilled
.
isObjectOrNull
(
)
)
;
MOZ_ASSERT_IF
(
onFulfilled
.
isObject
(
)
IsCallable
(
onFulfilled
)
)
;
MOZ_ASSERT_IF
(
onFulfilled
.
isInt32
(
)
0
<
=
onFulfilled
.
toInt32
(
)
&
&
onFulfilled
.
toInt32
(
)
<
int32_t
(
PromiseHandler
:
:
Limit
)
)
;
MOZ_ASSERT
(
onRejected
.
isInt32
(
)
|
|
onRejected
.
isObjectOrNull
(
)
)
;
MOZ_ASSERT_IF
(
onRejected
.
isObject
(
)
IsCallable
(
onRejected
)
)
;
MOZ_ASSERT_IF
(
onRejected
.
isInt32
(
)
0
<
=
onRejected
.
toInt32
(
)
&
&
onRejected
.
toInt32
(
)
<
int32_t
(
PromiseHandler
:
:
Limit
)
)
;
MOZ_ASSERT
(
onFulfilled
.
isNull
(
)
=
=
onRejected
.
isNull
(
)
)
;
RootedObject
incumbentGlobalObject
(
cx
)
;
if
(
incumbentGlobalObjectOption
=
=
IncumbentGlobalObject
:
:
Yes
)
{
if
(
!
GetObjectFromIncumbentGlobal
(
cx
&
incumbentGlobalObject
)
)
{
return
nullptr
;
}
}
PromiseReactionRecord
*
reaction
=
NewBuiltinClassInstance
<
PromiseReactionRecord
>
(
cx
)
;
if
(
!
reaction
)
{
return
nullptr
;
}
cx
-
>
check
(
resultCapability
.
promise
(
)
)
;
cx
-
>
check
(
onFulfilled
)
;
cx
-
>
check
(
onRejected
)
;
cx
-
>
check
(
resultCapability
.
resolve
(
)
)
;
cx
-
>
check
(
resultCapability
.
reject
(
)
)
;
cx
-
>
check
(
incumbentGlobalObject
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Promise
ObjectOrNullValue
(
resultCapability
.
promise
(
)
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Flags
Int32Value
(
0
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_OnFulfilled
onFulfilled
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_OnRejected
onRejected
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Resolve
ObjectOrNullValue
(
resultCapability
.
resolve
(
)
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_Reject
ObjectOrNullValue
(
resultCapability
.
reject
(
)
)
)
;
reaction
-
>
setFixedSlot
(
ReactionRecordSlot_IncumbentGlobalObject
ObjectOrNullValue
(
incumbentGlobalObject
)
)
;
return
reaction
;
}
static
bool
IsPromiseSpecies
(
JSContext
*
cx
JSFunction
*
species
)
{
return
species
-
>
maybeNative
(
)
=
=
Promise_static_species
;
}
enum
class
CreateDependentPromise
{
Always
SkipIfCtorUnobservable
}
;
static
bool
PromiseThenNewPromiseCapability
(
JSContext
*
cx
HandleObject
promiseObj
CreateDependentPromise
createDependent
MutableHandle
<
PromiseCapability
>
resultCapability
)
{
RootedObject
C
(
cx
SpeciesConstructor
(
cx
promiseObj
JSProto_Promise
IsPromiseSpecies
)
)
;
if
(
!
C
)
{
return
false
;
}
if
(
createDependent
!
=
CreateDependentPromise
:
:
Always
&
&
IsNativeFunction
(
C
PromiseConstructor
)
)
{
return
true
;
}
if
(
!
NewPromiseCapability
(
cx
C
resultCapability
true
)
)
{
return
false
;
}
RootedObject
unwrappedPromise
(
cx
promiseObj
)
;
if
(
IsWrapper
(
promiseObj
)
)
{
unwrappedPromise
=
UncheckedUnwrap
(
promiseObj
)
;
}
RootedObject
unwrappedNewPromise
(
cx
resultCapability
.
promise
(
)
)
;
if
(
IsWrapper
(
resultCapability
.
promise
(
)
)
)
{
unwrappedNewPromise
=
UncheckedUnwrap
(
resultCapability
.
promise
(
)
)
;
}
if
(
unwrappedPromise
-
>
is
<
PromiseObject
>
(
)
&
&
unwrappedNewPromise
-
>
is
<
PromiseObject
>
(
)
)
{
unwrappedNewPromise
-
>
as
<
PromiseObject
>
(
)
.
copyUserInteractionFlagsFrom
(
*
unwrappedPromise
.
as
<
PromiseObject
>
(
)
)
;
}
return
true
;
}
[
[
nodiscard
]
]
PromiseObject
*
js
:
:
OriginalPromiseThen
(
JSContext
*
cx
HandleObject
promiseObj
HandleObject
onFulfilled
HandleObject
onRejected
)
{
cx
-
>
check
(
promiseObj
)
;
cx
-
>
check
(
onFulfilled
)
;
cx
-
>
check
(
onRejected
)
;
RootedValue
promiseVal
(
cx
ObjectValue
(
*
promiseObj
)
)
;
Rooted
<
PromiseObject
*
>
unwrappedPromise
(
cx
UnwrapAndTypeCheckValue
<
PromiseObject
>
(
cx
promiseVal
[
cx
promiseObj
]
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
"
Promise
"
"
then
"
promiseObj
-
>
getClass
(
)
-
>
name
)
;
}
)
)
;
if
(
!
unwrappedPromise
)
{
return
nullptr
;
}
Rooted
<
PromiseObject
*
>
newPromise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
newPromise
)
{
return
nullptr
;
}
newPromise
-
>
copyUserInteractionFlagsFrom
(
*
unwrappedPromise
)
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
resultCapability
.
promise
(
)
.
set
(
newPromise
)
;
{
RootedValue
onFulfilledVal
(
cx
ObjectOrNullValue
(
onFulfilled
)
)
;
RootedValue
onRejectedVal
(
cx
ObjectOrNullValue
(
onRejected
)
)
;
if
(
!
PerformPromiseThen
(
cx
unwrappedPromise
onFulfilledVal
onRejectedVal
resultCapability
)
)
{
return
nullptr
;
}
}
return
newPromise
;
}
[
[
nodiscard
]
]
static
bool
OriginalPromiseThenWithoutSettleHandlers
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseObject
*
>
promiseToResolve
)
{
cx
-
>
check
(
promise
)
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
if
(
!
PromiseThenNewPromiseCapability
(
cx
promise
CreateDependentPromise
:
:
SkipIfCtorUnobservable
&
resultCapability
)
)
{
return
false
;
}
return
PerformPromiseThenWithoutSettleHandlers
(
cx
promise
promiseToResolve
resultCapability
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseThenWithReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseReactionRecord
*
>
reaction
)
;
[
[
nodiscard
]
]
bool
js
:
:
ReactToUnwrappedPromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
unwrappedPromise
HandleObject
onFulfilled_
HandleObject
onRejected_
UnhandledRejectionBehavior
behavior
)
{
cx
-
>
check
(
onFulfilled_
)
;
cx
-
>
check
(
onRejected_
)
;
MOZ_ASSERT_IF
(
onFulfilled_
IsCallable
(
onFulfilled_
)
)
;
MOZ_ASSERT_IF
(
onRejected_
IsCallable
(
onRejected_
)
)
;
RootedValue
onFulfilled
(
cx
onFulfilled_
?
ObjectValue
(
*
onFulfilled_
)
:
Int32Value
(
int32_t
(
PromiseHandler
:
:
Identity
)
)
)
;
RootedValue
onRejected
(
cx
onRejected_
?
ObjectValue
(
*
onRejected_
)
:
Int32Value
(
int32_t
(
PromiseHandler
:
:
Thrower
)
)
)
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
MOZ_ASSERT
(
!
resultCapability
.
promise
(
)
)
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultCapability
onFulfilled
onRejected
IncumbentGlobalObject
:
:
Yes
)
)
;
if
(
!
reaction
)
{
return
false
;
}
if
(
behavior
=
=
UnhandledRejectionBehavior
:
:
Ignore
)
{
reaction
-
>
setShouldIgnoreUnhandledRejection
(
)
;
}
return
PerformPromiseThenWithReaction
(
cx
unwrappedPromise
reaction
)
;
}
static
bool
CanCallOriginalPromiseThenBuiltin
(
JSContext
*
cx
HandleValue
promise
)
{
return
promise
.
isObject
(
)
&
&
promise
.
toObject
(
)
.
is
<
PromiseObject
>
(
)
&
&
cx
-
>
realm
(
)
-
>
promiseLookup
.
isDefaultInstance
(
cx
&
promise
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
bool
IsPromiseThenOrCatchRetValImplicitlyUsed
(
JSContext
*
cx
PromiseObject
*
promise
)
{
if
(
promise
-
>
requiresUserInteractionHandling
(
)
)
{
return
true
;
}
if
(
!
cx
-
>
options
(
)
.
asyncStack
(
)
)
{
return
false
;
}
if
(
cx
-
>
realm
(
)
-
>
isDebuggee
(
)
)
{
return
true
;
}
if
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
return
true
;
}
if
(
JS
:
:
IsProfileTimelineRecordingEnabled
(
)
)
{
return
true
;
}
return
false
;
}
static
bool
OriginalPromiseThenBuiltin
(
JSContext
*
cx
HandleValue
promiseVal
HandleValue
onFulfilled
HandleValue
onRejected
MutableHandleValue
rval
bool
rvalExplicitlyUsed
)
{
cx
-
>
check
(
promiseVal
onFulfilled
onRejected
)
;
MOZ_ASSERT
(
CanCallOriginalPromiseThenBuiltin
(
cx
promiseVal
)
)
;
Rooted
<
PromiseObject
*
>
promise
(
cx
&
promiseVal
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
bool
rvalUsed
=
rvalExplicitlyUsed
|
|
IsPromiseThenOrCatchRetValImplicitlyUsed
(
cx
promise
)
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
if
(
rvalUsed
)
{
PromiseObject
*
resultPromise
=
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
if
(
!
resultPromise
)
{
return
false
;
}
resultPromise
-
>
copyUserInteractionFlagsFrom
(
promiseVal
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
)
;
resultCapability
.
promise
(
)
.
set
(
resultPromise
)
;
}
if
(
!
PerformPromiseThen
(
cx
promise
onFulfilled
onRejected
resultCapability
)
)
{
return
false
;
}
if
(
rvalUsed
)
{
rval
.
setObject
(
*
resultCapability
.
promise
(
)
)
;
}
else
{
rval
.
setUndefined
(
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
RejectPromiseWithPendingError
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
{
cx
-
>
check
(
promise
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
)
{
(
void
)
PromiseObject
:
:
reject
(
cx
promise
UndefinedHandleValue
)
;
return
false
;
}
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
{
return
false
;
}
return
PromiseObject
:
:
reject
(
cx
promise
exn
)
;
}
[
[
nodiscard
]
]
PromiseObject
*
js
:
:
CreatePromiseObjectForAsync
(
JSContext
*
cx
)
{
PromiseObject
*
promise
=
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
if
(
!
promise
)
{
return
nullptr
;
}
AddPromiseFlags
(
*
promise
PROMISE_FLAG_ASYNC
)
;
return
promise
;
}
bool
js
:
:
IsPromiseForAsyncFunctionOrGenerator
(
JSObject
*
promise
)
{
return
promise
-
>
is
<
PromiseObject
>
(
)
&
&
PromiseHasAnyFlag
(
promise
-
>
as
<
PromiseObject
>
(
)
PROMISE_FLAG_ASYNC
)
;
}
[
[
nodiscard
]
]
PromiseObject
*
js
:
:
CreatePromiseObjectForAsyncGenerator
(
JSContext
*
cx
)
{
PromiseObject
*
promise
=
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
;
if
(
!
promise
)
{
return
nullptr
;
}
AddPromiseFlags
(
*
promise
PROMISE_FLAG_ASYNC
)
;
return
promise
;
}
[
[
nodiscard
]
]
bool
js
:
:
AsyncFunctionThrown
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
resultPromise
HandleValue
reason
)
{
if
(
resultPromise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
if
(
!
WarnNumberASCII
(
cx
JSMSG_UNHANDLABLE_PROMISE_REJECTION_WARNING
)
)
{
if
(
cx
-
>
isExceptionPending
(
)
)
{
cx
-
>
clearPendingException
(
)
;
}
}
return
true
;
}
return
RejectPromiseInternal
(
cx
resultPromise
reason
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
AsyncFunctionReturned
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
resultPromise
HandleValue
value
)
{
return
ResolvePromiseInternal
(
cx
resultPromise
value
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
static
bool
InternalAwait
(
JSContext
*
cx
HandleValue
value
HandleObject
resultPromise
PromiseHandler
onFulfilled
PromiseHandler
onRejected
T
extraStep
)
{
RootedObject
promise
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
value
)
)
;
if
(
!
promise
)
{
return
false
;
}
Rooted
<
PromiseObject
*
>
unwrappedPromise
(
cx
UnwrapAndDowncastObject
<
PromiseObject
>
(
cx
promise
)
)
;
if
(
!
unwrappedPromise
)
{
return
false
;
}
RootedValue
onFulfilledValue
(
cx
Int32Value
(
int32_t
(
onFulfilled
)
)
)
;
RootedValue
onRejectedValue
(
cx
Int32Value
(
int32_t
(
onRejected
)
)
)
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
resultCapability
.
promise
(
)
.
set
(
resultPromise
)
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultCapability
onFulfilledValue
onRejectedValue
IncumbentGlobalObject
:
:
Yes
)
)
;
if
(
!
reaction
)
{
return
false
;
}
extraStep
(
reaction
)
;
return
PerformPromiseThenWithReaction
(
cx
unwrappedPromise
reaction
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
InternalAsyncGeneratorAwait
(
JSContext
*
cx
JS
:
:
Handle
<
AsyncGeneratorObject
*
>
generator
JS
:
:
Handle
<
JS
:
:
Value
>
value
PromiseHandler
onFulfilled
PromiseHandler
onRejected
)
{
auto
extra
=
[
&
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncGenerator
(
generator
)
;
}
;
return
InternalAwait
(
cx
value
nullptr
onFulfilled
onRejected
extra
)
;
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
AsyncFunctionAwait
(
JSContext
*
cx
Handle
<
AsyncFunctionGeneratorObject
*
>
genObj
HandleValue
value
)
{
auto
extra
=
[
&
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
reaction
-
>
setIsAsyncFunction
(
genObj
)
;
}
;
if
(
!
InternalAwait
(
cx
value
nullptr
PromiseHandler
:
:
AsyncFunctionAwaitedFulfilled
PromiseHandler
:
:
AsyncFunctionAwaitedRejected
extra
)
)
{
return
nullptr
;
}
return
genObj
-
>
promise
(
)
;
}
bool
js
:
:
AsyncFromSyncIteratorMethod
(
JSContext
*
cx
CallArgs
&
args
CompletionKind
completionKind
)
{
HandleValue
thisVal
=
args
.
thisv
(
)
;
Rooted
<
PromiseObject
*
>
resultPromise
(
cx
CreatePromiseObjectWithoutResolutionFunctions
(
cx
)
)
;
if
(
!
resultPromise
)
{
return
false
;
}
if
(
!
thisVal
.
isObject
(
)
|
|
!
thisVal
.
toObject
(
)
.
is
<
AsyncFromSyncIteratorObject
>
(
)
)
{
RootedValue
badGeneratorError
(
cx
)
;
if
(
!
GetTypeError
(
cx
JSMSG_NOT_AN_ASYNC_ITERATOR
&
badGeneratorError
)
)
{
return
false
;
}
if
(
!
RejectPromiseInternal
(
cx
resultPromise
badGeneratorError
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
Rooted
<
AsyncFromSyncIteratorObject
*
>
asyncIter
(
cx
&
thisVal
.
toObject
(
)
.
as
<
AsyncFromSyncIteratorObject
>
(
)
)
;
RootedObject
iter
(
cx
asyncIter
-
>
iterator
(
)
)
;
RootedValue
func
(
cx
)
;
if
(
completionKind
=
=
CompletionKind
:
:
Normal
)
{
func
.
set
(
asyncIter
-
>
nextMethod
(
)
)
;
}
else
if
(
completionKind
=
=
CompletionKind
:
:
Return
)
{
if
(
!
GetProperty
(
cx
iter
iter
cx
-
>
names
(
)
.
return_
&
func
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
if
(
func
.
isNullOrUndefined
(
)
)
{
PlainObject
*
resultObj
=
CreateIterResultObject
(
cx
args
.
get
(
0
)
true
)
;
if
(
!
resultObj
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
RootedValue
resultVal
(
cx
ObjectValue
(
*
resultObj
)
)
;
if
(
!
ResolvePromiseInternal
(
cx
resultPromise
resultVal
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
completionKind
=
=
CompletionKind
:
:
Throw
)
;
if
(
!
GetProperty
(
cx
iter
iter
cx
-
>
names
(
)
.
throw_
&
func
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
if
(
func
.
isNullOrUndefined
(
)
)
{
if
(
!
RejectPromiseInternal
(
cx
resultPromise
args
.
get
(
0
)
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
}
RootedValue
iterVal
(
cx
ObjectValue
(
*
iter
)
)
;
RootedValue
resultVal
(
cx
)
;
bool
ok
;
if
(
args
.
length
(
)
=
=
0
)
{
ok
=
Call
(
cx
func
iterVal
&
resultVal
)
;
}
else
{
ok
=
Call
(
cx
func
iterVal
args
[
0
]
&
resultVal
)
;
}
if
(
!
ok
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
if
(
!
resultVal
.
isObject
(
)
)
{
CheckIsObjectKind
kind
;
switch
(
completionKind
)
{
case
CompletionKind
:
:
Normal
:
kind
=
CheckIsObjectKind
:
:
IteratorNext
;
break
;
case
CompletionKind
:
:
Throw
:
kind
=
CheckIsObjectKind
:
:
IteratorThrow
;
break
;
case
CompletionKind
:
:
Return
:
kind
=
CheckIsObjectKind
:
:
IteratorReturn
;
break
;
}
MOZ_ALWAYS_FALSE
(
ThrowCheckIsObject
(
cx
kind
)
)
;
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
RootedObject
resultObj
(
cx
&
resultVal
.
toObject
(
)
)
;
RootedValue
doneVal
(
cx
)
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
done
&
doneVal
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
bool
done
=
ToBoolean
(
doneVal
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
value
&
value
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
PromiseHandler
onFulfilled
=
done
?
PromiseHandler
:
:
AsyncFromSyncIteratorValueUnwrapDone
:
PromiseHandler
:
:
AsyncFromSyncIteratorValueUnwrapNotDone
;
PromiseHandler
onRejected
=
PromiseHandler
:
:
Thrower
;
auto
extra
=
[
]
(
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
}
;
if
(
!
InternalAwait
(
cx
value
resultPromise
onFulfilled
onRejected
extra
)
)
{
return
AbruptRejectPromise
(
cx
args
resultPromise
nullptr
)
;
}
args
.
rval
(
)
.
setObject
(
*
resultPromise
)
;
return
true
;
}
static
bool
Promise_catch_impl
(
JSContext
*
cx
unsigned
argc
Value
*
vp
bool
rvalExplicitlyUsed
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
thisVal
=
args
.
thisv
(
)
;
HandleValue
onFulfilled
=
UndefinedHandleValue
;
HandleValue
onRejected
=
args
.
get
(
0
)
;
if
(
CanCallOriginalPromiseThenBuiltin
(
cx
thisVal
)
)
{
return
OriginalPromiseThenBuiltin
(
cx
thisVal
onFulfilled
onRejected
args
.
rval
(
)
rvalExplicitlyUsed
)
;
}
RootedValue
thenVal
(
cx
)
;
if
(
!
GetProperty
(
cx
thisVal
cx
-
>
names
(
)
.
then
&
thenVal
)
)
{
return
false
;
}
if
(
IsNativeFunction
(
thenVal
&
Promise_then
)
&
&
thenVal
.
toObject
(
)
.
nonCCWRealm
(
)
=
=
cx
-
>
realm
(
)
)
{
return
Promise_then_impl
(
cx
thisVal
onFulfilled
onRejected
args
.
rval
(
)
rvalExplicitlyUsed
)
;
}
return
Call
(
cx
thenVal
thisVal
UndefinedHandleValue
onRejected
args
.
rval
(
)
)
;
}
static
bool
Promise_catch_noRetVal
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
Promise_catch_impl
(
cx
argc
vp
false
)
;
}
static
bool
Promise_catch
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
Promise_catch_impl
(
cx
argc
vp
true
)
;
}
static
bool
Promise_then_impl
(
JSContext
*
cx
HandleValue
promiseVal
HandleValue
onFulfilled
HandleValue
onRejected
MutableHandleValue
rval
bool
rvalExplicitlyUsed
)
{
if
(
!
promiseVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED
"
Receiver
of
Promise
.
prototype
.
then
call
"
)
;
return
false
;
}
if
(
CanCallOriginalPromiseThenBuiltin
(
cx
promiseVal
)
)
{
return
OriginalPromiseThenBuiltin
(
cx
promiseVal
onFulfilled
onRejected
rval
rvalExplicitlyUsed
)
;
}
RootedObject
promiseObj
(
cx
&
promiseVal
.
toObject
(
)
)
;
Rooted
<
PromiseObject
*
>
unwrappedPromise
(
cx
UnwrapAndTypeCheckValue
<
PromiseObject
>
(
cx
promiseVal
[
cx
&
promiseVal
]
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
"
Promise
"
"
then
"
InformalValueTypeName
(
promiseVal
)
)
;
}
)
)
;
if
(
!
unwrappedPromise
)
{
return
false
;
}
bool
rvalUsed
=
rvalExplicitlyUsed
|
|
IsPromiseThenOrCatchRetValImplicitlyUsed
(
cx
unwrappedPromise
)
;
CreateDependentPromise
createDependent
=
rvalUsed
?
CreateDependentPromise
:
:
Always
:
CreateDependentPromise
:
:
SkipIfCtorUnobservable
;
Rooted
<
PromiseCapability
>
resultCapability
(
cx
)
;
if
(
!
PromiseThenNewPromiseCapability
(
cx
promiseObj
createDependent
&
resultCapability
)
)
{
return
false
;
}
if
(
!
PerformPromiseThen
(
cx
unwrappedPromise
onFulfilled
onRejected
resultCapability
)
)
{
return
false
;
}
if
(
rvalUsed
)
{
rval
.
setObject
(
*
resultCapability
.
promise
(
)
)
;
}
else
{
rval
.
setUndefined
(
)
;
}
return
true
;
}
bool
Promise_then_noRetVal
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
Promise_then_impl
(
cx
args
.
thisv
(
)
args
.
get
(
0
)
args
.
get
(
1
)
args
.
rval
(
)
false
)
;
}
bool
js
:
:
Promise_then
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
Promise_then_impl
(
cx
args
.
thisv
(
)
args
.
get
(
0
)
args
.
get
(
1
)
args
.
rval
(
)
true
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseThen
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
onFulfilled_
HandleValue
onRejected_
Handle
<
PromiseCapability
>
resultCapability
)
{
RootedValue
onFulfilled
(
cx
onFulfilled_
)
;
if
(
!
IsCallable
(
onFulfilled
)
)
{
onFulfilled
=
Int32Value
(
int32_t
(
PromiseHandler
:
:
Identity
)
)
;
}
RootedValue
onRejected
(
cx
onRejected_
)
;
if
(
!
IsCallable
(
onRejected
)
)
{
onRejected
=
Int32Value
(
int32_t
(
PromiseHandler
:
:
Thrower
)
)
;
}
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultCapability
onFulfilled
onRejected
IncumbentGlobalObject
:
:
Yes
)
)
;
if
(
!
reaction
)
{
return
false
;
}
return
PerformPromiseThenWithReaction
(
cx
promise
reaction
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseThenWithoutSettleHandlers
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
PromiseObject
*
>
promiseToResolve
Handle
<
PromiseCapability
>
resultCapability
)
{
HandleValue
onFulfilled
=
NullHandleValue
;
HandleValue
onRejected
=
NullHandleValue
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
resultCapability
onFulfilled
onRejected
IncumbentGlobalObject
:
:
Yes
)
)
;
if
(
!
reaction
)
{
return
false
;
}
reaction
-
>
setIsDefaultResolvingHandler
(
promiseToResolve
)
;
return
PerformPromiseThenWithReaction
(
cx
promise
reaction
)
;
}
[
[
nodiscard
]
]
static
bool
PerformPromiseThenWithReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
unwrappedPromise
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
JS
:
:
PromiseState
state
=
unwrappedPromise
-
>
state
(
)
;
int32_t
flags
=
unwrappedPromise
-
>
flags
(
)
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Pending
)
{
if
(
!
AddPromiseReaction
(
cx
unwrappedPromise
reaction
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT_IF
(
state
!
=
JS
:
:
PromiseState
:
:
Fulfilled
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
valueOrReason
(
cx
unwrappedPromise
-
>
valueOrReason
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
valueOrReason
)
)
{
return
false
;
}
if
(
state
=
=
JS
:
:
PromiseState
:
:
Rejected
&
&
!
(
flags
&
PROMISE_FLAG_HANDLED
)
)
{
cx
-
>
runtime
(
)
-
>
removeUnhandledRejectedPromise
(
cx
unwrappedPromise
)
;
}
if
(
!
EnqueuePromiseReactionJob
(
cx
reaction
valueOrReason
state
)
)
{
return
false
;
}
}
unwrappedPromise
-
>
setHandled
(
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
AddPromiseReaction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
unwrappedPromise
Handle
<
PromiseReactionRecord
*
>
reaction
)
{
MOZ_RELEASE_ASSERT
(
reaction
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
RootedValue
reactionVal
(
cx
ObjectValue
(
*
reaction
)
)
;
mozilla
:
:
Maybe
<
AutoRealm
>
ar
;
if
(
unwrappedPromise
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
ar
.
emplace
(
cx
unwrappedPromise
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
reactionVal
)
)
{
return
false
;
}
}
Handle
<
PromiseObject
*
>
promise
=
unwrappedPromise
;
RootedValue
reactionsVal
(
cx
promise
-
>
reactions
(
)
)
;
if
(
reactionsVal
.
isUndefined
(
)
)
{
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
reactionVal
)
;
return
true
;
}
RootedObject
reactionsObj
(
cx
&
reactionsVal
.
toObject
(
)
)
;
if
(
IsProxy
(
reactionsObj
)
)
{
reactionsObj
=
UncheckedUnwrap
(
reactionsObj
)
;
if
(
JS_IsDeadWrapper
(
reactionsObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
reactionsObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
}
if
(
reactionsObj
-
>
is
<
PromiseReactionRecord
>
(
)
)
{
ArrayObject
*
reactions
=
NewDenseFullyAllocatedArray
(
cx
2
)
;
if
(
!
reactions
)
{
return
false
;
}
reactions
-
>
setDenseInitializedLength
(
2
)
;
reactions
-
>
initDenseElement
(
0
reactionsVal
)
;
reactions
-
>
initDenseElement
(
1
reactionVal
)
;
promise
-
>
setFixedSlot
(
PromiseSlot_ReactionsOrResult
ObjectValue
(
*
reactions
)
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
reactionsObj
-
>
is
<
NativeObject
>
(
)
)
;
Handle
<
NativeObject
*
>
reactions
=
reactionsObj
.
as
<
NativeObject
>
(
)
;
uint32_t
len
=
reactions
-
>
getDenseInitializedLength
(
)
;
DenseElementResult
result
=
reactions
-
>
ensureDenseElements
(
cx
len
1
)
;
if
(
result
!
=
DenseElementResult
:
:
Success
)
{
MOZ_ASSERT
(
result
=
=
DenseElementResult
:
:
Failure
)
;
return
false
;
}
reactions
-
>
setDenseElement
(
len
reactionVal
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
AddDummyPromiseReactionForDebugger
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleObject
dependentPromise
)
{
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
MOZ_ASSERT
(
UncheckedUnwrap
(
dependentPromise
)
-
>
is
<
PromiseObject
>
(
)
)
;
Rooted
<
PromiseCapability
>
capability
(
cx
)
;
capability
.
promise
(
)
.
set
(
dependentPromise
)
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
NewReactionRecord
(
cx
capability
NullHandleValue
NullHandleValue
IncumbentGlobalObject
:
:
No
)
)
;
if
(
!
reaction
)
{
return
false
;
}
reaction
-
>
setIsDebuggerDummy
(
)
;
return
AddPromiseReaction
(
cx
promise
reaction
)
;
}
uint64_t
PromiseObject
:
:
getID
(
)
{
return
PromiseDebugInfo
:
:
id
(
this
)
;
}
double
PromiseObject
:
:
lifetime
(
)
{
return
MillisecondsSinceStartup
(
)
-
allocationTime
(
)
;
}
bool
PromiseObject
:
:
dependentPromises
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
values
)
{
if
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
uint32_t
valuesIndex
=
0
;
RootedValue
reactionsVal
(
cx
reactions
(
)
)
;
return
ForEachReaction
(
cx
reactionsVal
[
&
]
(
MutableHandleObject
obj
)
{
if
(
IsProxy
(
obj
)
)
{
obj
.
set
(
UncheckedUnwrap
(
obj
)
)
;
}
if
(
JS_IsDeadWrapper
(
obj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
obj
-
>
is
<
PromiseReactionRecord
>
(
)
)
;
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
&
obj
-
>
as
<
PromiseReactionRecord
>
(
)
)
;
RootedObject
promiseObj
(
cx
reaction
-
>
promise
(
)
)
;
if
(
promiseObj
)
{
if
(
!
values
.
growBy
(
1
)
)
{
return
false
;
}
values
[
valuesIndex
+
+
]
.
setObject
(
*
promiseObj
)
;
}
return
true
;
}
)
;
}
bool
PromiseObject
:
:
forEachReactionRecord
(
JSContext
*
cx
PromiseReactionRecordBuilder
&
builder
)
{
if
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
RootedValue
reactionsVal
(
cx
reactions
(
)
)
;
if
(
reactionsVal
.
isNullOrUndefined
(
)
)
{
return
true
;
}
return
ForEachReaction
(
cx
reactionsVal
[
&
]
(
MutableHandleObject
obj
)
{
if
(
IsProxy
(
obj
)
)
{
obj
.
set
(
UncheckedUnwrap
(
obj
)
)
;
}
if
(
JS_IsDeadWrapper
(
obj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
Rooted
<
PromiseReactionRecord
*
>
reaction
(
cx
&
obj
-
>
as
<
PromiseReactionRecord
>
(
)
)
;
MOZ_ASSERT
(
reaction
-
>
targetState
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
if
(
reaction
-
>
isAsyncFunction
(
)
)
{
Rooted
<
AsyncFunctionGeneratorObject
*
>
generator
(
cx
reaction
-
>
asyncFunctionGenerator
(
)
)
;
if
(
!
builder
.
asyncFunction
(
cx
generator
)
)
{
return
false
;
}
}
else
if
(
reaction
-
>
isAsyncGenerator
(
)
)
{
Rooted
<
AsyncGeneratorObject
*
>
generator
(
cx
reaction
-
>
asyncGenerator
(
)
)
;
if
(
!
builder
.
asyncGenerator
(
cx
generator
)
)
{
return
false
;
}
}
else
if
(
reaction
-
>
isDefaultResolvingHandler
(
)
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
reaction
-
>
defaultResolvingPromise
(
)
)
;
if
(
!
builder
.
direct
(
cx
promise
)
)
{
return
false
;
}
}
else
{
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
RootedObject
result
(
cx
reaction
-
>
promise
(
)
)
;
Value
v
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_OnFulfilled
)
;
if
(
v
.
isObject
(
)
)
{
resolve
=
&
v
.
toObject
(
)
;
}
v
=
reaction
-
>
getFixedSlot
(
ReactionRecordSlot_OnRejected
)
;
if
(
v
.
isObject
(
)
)
{
reject
=
&
v
.
toObject
(
)
;
}
if
(
!
builder
.
then
(
cx
resolve
reject
result
)
)
{
return
false
;
}
}
return
true
;
}
)
;
}
static
bool
CallDefaultPromiseResolveFunction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
resolutionValue
)
{
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
if
(
IsAlreadyResolvedPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
true
;
}
SetAlreadyResolvedPromiseWithDefaultResolvingFunction
(
promise
)
;
return
ResolvePromiseInternal
(
cx
promise
resolutionValue
)
;
}
bool
PromiseObject
:
:
resolve
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
resolutionValue
)
{
MOZ_ASSERT
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_ASYNC
)
)
;
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
if
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
CallDefaultPromiseResolveFunction
(
cx
promise
resolutionValue
)
;
}
JSFunction
*
resolveFun
=
GetResolveFunctionFromPromise
(
promise
)
;
if
(
!
resolveFun
)
{
return
true
;
}
RootedValue
funVal
(
cx
ObjectValue
(
*
resolveFun
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
funVal
)
)
{
return
false
;
}
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
resolutionValue
&
dummy
)
;
}
static
bool
CallDefaultPromiseRejectFunction
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
rejectionValue
JS
:
:
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
{
MOZ_ASSERT
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
;
if
(
IsAlreadyResolvedPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
true
;
}
SetAlreadyResolvedPromiseWithDefaultResolvingFunction
(
promise
)
;
return
RejectPromiseInternal
(
cx
promise
rejectionValue
unwrappedRejectionStack
)
;
}
bool
PromiseObject
:
:
reject
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
rejectionValue
)
{
MOZ_ASSERT
(
!
PromiseHasAnyFlag
(
*
promise
PROMISE_FLAG_ASYNC
)
)
;
if
(
promise
-
>
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
{
return
true
;
}
if
(
IsPromiseWithDefaultResolvingFunction
(
promise
)
)
{
return
CallDefaultPromiseRejectFunction
(
cx
promise
rejectionValue
)
;
}
RootedValue
funVal
(
cx
promise
-
>
getFixedSlot
(
PromiseSlot_RejectFunction
)
)
;
MOZ_ASSERT
(
IsCallable
(
funVal
)
)
;
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
rejectionValue
&
dummy
)
;
}
void
PromiseObject
:
:
onSettled
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
Handle
<
SavedFrame
*
>
unwrappedRejectionStack
)
{
PromiseDebugInfo
:
:
setResolutionInfo
(
cx
promise
unwrappedRejectionStack
)
;
if
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
&
&
promise
-
>
isUnhandled
(
)
)
{
cx
-
>
runtime
(
)
-
>
addUnhandledRejectedPromise
(
cx
promise
)
;
}
DebugAPI
:
:
onPromiseSettled
(
cx
promise
)
;
}
void
PromiseObject
:
:
setRequiresUserInteractionHandling
(
bool
state
)
{
if
(
state
)
{
AddPromiseFlags
(
*
this
PROMISE_FLAG_REQUIRES_USER_INTERACTION_HANDLING
)
;
}
else
{
RemovePromiseFlags
(
*
this
PROMISE_FLAG_REQUIRES_USER_INTERACTION_HANDLING
)
;
}
}
void
PromiseObject
:
:
setHadUserInteractionUponCreation
(
bool
state
)
{
if
(
state
)
{
AddPromiseFlags
(
*
this
PROMISE_FLAG_HAD_USER_INTERACTION_UPON_CREATION
)
;
}
else
{
RemovePromiseFlags
(
*
this
PROMISE_FLAG_HAD_USER_INTERACTION_UPON_CREATION
)
;
}
}
void
PromiseObject
:
:
copyUserInteractionFlagsFrom
(
PromiseObject
&
rhs
)
{
setRequiresUserInteractionHandling
(
rhs
.
requiresUserInteractionHandling
(
)
)
;
setHadUserInteractionUponCreation
(
rhs
.
hadUserInteractionUponCreation
(
)
)
;
}
[
[
nodiscard
]
]
static
bool
IsTopMostAsyncFunctionCall
(
JSContext
*
cx
)
{
FrameIter
iter
(
cx
)
;
if
(
iter
.
done
(
)
)
{
return
false
;
}
if
(
!
iter
.
isFunctionFrame
(
)
&
&
iter
.
isModuleFrame
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
iter
.
calleeTemplate
(
)
-
>
isAsync
(
)
)
;
#
ifdef
DEBUG
bool
isGenerator
=
iter
.
calleeTemplate
(
)
-
>
isGenerator
(
)
;
#
endif
+
+
iter
;
if
(
iter
.
done
(
)
)
{
return
false
;
}
if
(
!
iter
.
isFunctionFrame
(
)
)
{
MOZ_ASSERT
(
!
isGenerator
)
;
return
false
;
}
JSFunction
*
fun
=
iter
.
calleeTemplate
(
)
;
if
(
IsSelfHostedFunctionWithName
(
fun
cx
-
>
names
(
)
.
InterpretGeneratorResume
)
)
{
+
+
iter
;
if
(
iter
.
done
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
iter
.
isFunctionFrame
(
)
)
;
fun
=
iter
.
calleeTemplate
(
)
;
}
if
(
!
IsSelfHostedFunctionWithName
(
fun
cx
-
>
names
(
)
.
AsyncFunctionNext
)
&
&
!
IsSelfHostedFunctionWithName
(
fun
cx
-
>
names
(
)
.
AsyncGeneratorNext
)
)
{
return
false
;
}
+
+
iter
;
if
(
iter
.
done
(
)
)
{
return
true
;
}
return
false
;
}
[
[
nodiscard
]
]
bool
js
:
:
CanSkipAwait
(
JSContext
*
cx
HandleValue
val
bool
*
canSkip
)
{
if
(
!
cx
-
>
canSkipEnqueuingJobs
)
{
*
canSkip
=
false
;
return
true
;
}
if
(
!
IsTopMostAsyncFunctionCall
(
cx
)
)
{
*
canSkip
=
false
;
return
true
;
}
if
(
!
val
.
isObject
(
)
)
{
*
canSkip
=
true
;
return
true
;
}
JSObject
*
obj
=
&
val
.
toObject
(
)
;
if
(
!
obj
-
>
is
<
PromiseObject
>
(
)
)
{
*
canSkip
=
false
;
return
true
;
}
PromiseObject
*
promise
=
&
obj
-
>
as
<
PromiseObject
>
(
)
;
if
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
{
*
canSkip
=
false
;
return
true
;
}
PromiseLookup
&
promiseLookup
=
cx
-
>
realm
(
)
-
>
promiseLookup
;
if
(
!
promiseLookup
.
isDefaultInstance
(
cx
promise
)
)
{
*
canSkip
=
false
;
return
true
;
}
if
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
{
*
canSkip
=
false
;
return
true
;
}
*
canSkip
=
true
;
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
ExtractAwaitValue
(
JSContext
*
cx
HandleValue
val
MutableHandleValue
resolved
)
{
#
ifdef
DEBUG
bool
canSkip
;
if
(
!
CanSkipAwait
(
cx
val
&
canSkip
)
)
{
return
false
;
}
MOZ_ASSERT
(
canSkip
=
=
true
)
;
#
endif
if
(
!
val
.
isObject
(
)
)
{
resolved
.
set
(
val
)
;
return
true
;
}
JSObject
*
obj
=
&
val
.
toObject
(
)
;
PromiseObject
*
promise
=
&
obj
-
>
as
<
PromiseObject
>
(
)
;
resolved
.
set
(
promise
-
>
value
(
)
)
;
return
true
;
}
JS
:
:
AutoDebuggerJobQueueInterruption
:
:
AutoDebuggerJobQueueInterruption
(
)
:
cx
(
nullptr
)
{
}
JS
:
:
AutoDebuggerJobQueueInterruption
:
:
~
AutoDebuggerJobQueueInterruption
(
)
{
MOZ_ASSERT_IF
(
initialized
(
)
cx
-
>
jobQueue
-
>
empty
(
)
)
;
}
bool
JS
:
:
AutoDebuggerJobQueueInterruption
:
:
init
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
jobQueue
)
;
this
-
>
cx
=
cx
;
saved
=
cx
-
>
jobQueue
-
>
saveJobQueue
(
cx
)
;
return
!
!
saved
;
}
void
JS
:
:
AutoDebuggerJobQueueInterruption
:
:
runJobs
(
)
{
JS
:
:
AutoSaveExceptionState
ases
(
cx
)
;
cx
-
>
jobQueue
-
>
runJobs
(
cx
)
;
}
const
JSJitInfo
promise_then_info
=
{
{
(
JSJitGetterOp
)
Promise_then_noRetVal
}
{
0
}
{
0
}
JSJitInfo
:
:
IgnoresReturnValueNative
JSJitInfo
:
:
AliasEverything
JSVAL_TYPE_UNDEFINED
}
;
const
JSJitInfo
promise_catch_info
=
{
{
(
JSJitGetterOp
)
Promise_catch_noRetVal
}
{
0
}
{
0
}
JSJitInfo
:
:
IgnoresReturnValueNative
JSJitInfo
:
:
AliasEverything
JSVAL_TYPE_UNDEFINED
}
;
static
const
JSFunctionSpec
promise_methods
[
]
=
{
JS_FNINFO
(
"
then
"
js
:
:
Promise_then
&
promise_then_info
2
0
)
JS_FNINFO
(
"
catch
"
Promise_catch
&
promise_catch_info
1
0
)
JS_SELF_HOSTED_FN
(
"
finally
"
"
Promise_finally
"
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
promise_properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Promise
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
JSFunctionSpec
promise_static_methods
[
]
=
{
JS_FN
(
"
all
"
Promise_static_all
1
0
)
JS_FN
(
"
allSettled
"
Promise_static_allSettled
1
0
)
JS_FN
(
"
any
"
Promise_static_any
1
0
)
JS_FN
(
"
race
"
Promise_static_race
1
0
)
JS_FN
(
"
reject
"
Promise_reject
1
0
)
JS_FN
(
"
resolve
"
js
:
:
Promise_static_resolve
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
promise_static_properties
[
]
=
{
JS_SYM_GET
(
species
js
:
:
Promise_static_species
0
)
JS_PS_END
}
;
static
const
ClassSpec
PromiseObjectClassSpec
=
{
GenericCreateConstructor
<
PromiseConstructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
PromiseObject
>
promise_static_methods
promise_static_properties
promise_methods
promise_properties
}
;
const
JSClass
PromiseObject
:
:
class_
=
{
"
Promise
"
JSCLASS_HAS_RESERVED_SLOTS
(
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
|
JSCLASS_HAS_XRAYED_CONSTRUCTOR
JS_NULL_CLASS_OPS
&
PromiseObjectClassSpec
}
;
const
JSClass
PromiseObject
:
:
protoClass_
=
{
"
Promise
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
JS_NULL_CLASS_OPS
&
PromiseObjectClassSpec
}
;
