#
include
"
builtin
/
Promise
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
const
JSFunctionSpec
promise_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
catch
"
"
Promise_catch
"
1
0
)
JS_SELF_HOSTED_FN
(
"
then
"
"
Promise_then
"
2
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
promise_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
all
"
"
Promise_static_all
"
1
0
)
JS_SELF_HOSTED_FN
(
"
race
"
"
Promise_static_race
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reject
"
"
Promise_static_reject
"
1
0
)
JS_SELF_HOSTED_FN
(
"
resolve
"
"
Promise_static_resolve
"
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
promise_static_properties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
Promise_static_get_species
"
0
)
JS_PS_END
}
;
static
double
MillisecondsSinceStartup
(
)
{
auto
now
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
bool
ignored
;
return
(
now
-
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignored
)
)
.
ToMilliseconds
(
)
;
}
enum
ResolutionFunctionSlots
{
ResolutionFunctionSlot_Promise
=
0
ResolutionFunctionSlot_OtherFunction
}
;
static
MOZ_MUST_USE
bool
TriggerPromiseReactions
(
JSContext
*
cx
HandleValue
reactionsVal
JS
:
:
PromiseState
state
HandleValue
valueOrReason
)
{
RootedObject
reactions
(
cx
&
reactionsVal
.
toObject
(
)
)
;
AutoIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
reactions
JSITER_OWNONLY
&
keys
)
)
return
false
;
MOZ_ASSERT
(
keys
.
length
(
)
>
0
"
Reactions
list
should
be
created
lazily
"
)
;
RootedPropertyName
handlerName
(
cx
)
;
handlerName
=
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
?
cx
-
>
names
(
)
.
fulfillHandler
:
cx
-
>
names
(
)
.
rejectHandler
;
RootedValue
val
(
cx
)
;
RootedObject
reaction
(
cx
)
;
RootedValue
handler
(
cx
)
;
RootedObject
promise
(
cx
)
;
RootedObject
resolve
(
cx
)
;
RootedObject
reject
(
cx
)
;
RootedObject
objectFromIncumbentGlobal
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
if
(
!
GetProperty
(
cx
reactions
reactions
keys
[
i
]
&
val
)
)
return
false
;
reaction
=
&
val
.
toObject
(
)
;
if
(
!
GetProperty
(
cx
reaction
reaction
cx
-
>
names
(
)
.
promise
&
val
)
)
return
false
;
promise
=
val
.
toObjectOrNull
(
)
;
if
(
!
GetProperty
(
cx
reaction
reaction
handlerName
&
handler
)
)
return
false
;
#
ifdef
DEBUG
if
(
handler
.
isNumber
(
)
)
{
MOZ_ASSERT
(
handler
.
toNumber
(
)
=
=
PROMISE_HANDLER_IDENTITY
|
|
handler
.
toNumber
(
)
=
=
PROMISE_HANDLER_THROWER
)
;
}
else
{
MOZ_ASSERT
(
handler
.
toObject
(
)
.
isCallable
(
)
)
;
}
#
endif
if
(
!
GetProperty
(
cx
reaction
reaction
cx
-
>
names
(
)
.
resolve
&
val
)
)
return
false
;
resolve
=
&
val
.
toObject
(
)
;
MOZ_ASSERT
(
IsCallable
(
resolve
)
)
;
if
(
!
GetProperty
(
cx
reaction
reaction
cx
-
>
names
(
)
.
reject
&
val
)
)
return
false
;
reject
=
&
val
.
toObject
(
)
;
MOZ_ASSERT
(
IsCallable
(
reject
)
)
;
if
(
!
GetProperty
(
cx
reaction
reaction
cx
-
>
names
(
)
.
incumbentGlobal
&
val
)
)
return
false
;
objectFromIncumbentGlobal
=
val
.
toObjectOrNull
(
)
;
if
(
!
EnqueuePromiseReactionJob
(
cx
handler
valueOrReason
resolve
reject
promise
objectFromIncumbentGlobal
)
)
{
return
false
;
}
}
return
true
;
}
static
MOZ_MUST_USE
bool
ResolvePromise
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
HandleValue
valueOrReason
JS
:
:
PromiseState
state
)
{
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
MOZ_ASSERT
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
|
|
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
RootedValue
reactionsVal
(
cx
promise
-
>
getFixedSlot
(
PROMISE_REACTIONS_SLOT
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_RESULT_SLOT
valueOrReason
)
;
promise
-
>
setFixedSlot
(
PROMISE_REACTIONS_SLOT
UndefinedValue
(
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_STATE_SLOT
Int32Value
(
int32_t
(
state
)
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_RESOLVE_FUNCTION_SLOT
UndefinedValue
(
)
)
;
promise
-
>
onSettled
(
cx
)
;
if
(
reactionsVal
.
isObject
(
)
)
return
TriggerPromiseReactions
(
cx
reactionsVal
state
valueOrReason
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
FulfillMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
value_
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
value
(
cx
value_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsWrapper
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
promise
=
&
UncheckedUnwrap
(
promiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
ac
.
emplace
(
cx
promise
)
;
if
(
!
promise
-
>
compartment
(
)
-
>
wrap
(
cx
&
value
)
)
return
false
;
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
ResolvePromise
(
cx
promise
value
JS
:
:
PromiseState
:
:
Fulfilled
)
;
}
static
MOZ_MUST_USE
bool
RejectMaybeWrappedPromise
(
JSContext
*
cx
HandleObject
promiseObj
HandleValue
reason_
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
RootedValue
reason
(
cx
reason_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
!
IsWrapper
(
promiseObj
)
)
{
promise
=
&
promiseObj
-
>
as
<
PromiseObject
>
(
)
;
}
else
{
promise
=
&
UncheckedUnwrap
(
promiseObj
)
-
>
as
<
PromiseObject
>
(
)
;
ac
.
emplace
(
cx
promise
)
;
if
(
!
promise
-
>
compartment
(
)
-
>
wrap
(
cx
&
reason
)
)
return
false
;
if
(
reason
.
isObject
(
)
&
&
!
CheckedUnwrap
(
&
reason
.
toObject
(
)
)
)
{
FixedInvokeArgs
<
1
>
getErrorArgs
(
cx
)
;
getErrorArgs
[
0
]
.
set
(
Int32Value
(
JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON
)
)
;
if
(
!
CallSelfHostedFunction
(
cx
"
GetInternalError
"
reason
getErrorArgs
&
reason
)
)
return
false
;
}
}
MOZ_ASSERT
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
ResolvePromise
(
cx
promise
reason
JS
:
:
PromiseState
:
:
Rejected
)
;
}
static
void
ClearResolutionFunctionSlots
(
JSFunction
*
resolutionFun
)
{
JSFunction
*
otherFun
=
&
resolutionFun
-
>
getExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
resolutionFun
-
>
setExtendedSlot
(
ResolutionFunctionSlot_Promise
UndefinedValue
(
)
)
;
otherFun
-
>
setExtendedSlot
(
ResolutionFunctionSlot_Promise
UndefinedValue
(
)
)
;
resolutionFun
-
>
setExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
UndefinedValue
(
)
)
;
otherFun
-
>
setExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
UndefinedValue
(
)
)
;
}
static
bool
RejectPromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
reject
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
reasonVal
(
cx
args
.
get
(
0
)
)
;
RootedValue
promiseVal
(
cx
reject
-
>
getExtendedSlot
(
ResolutionFunctionSlot_Promise
)
)
;
if
(
promiseVal
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
promise
(
cx
&
promiseVal
.
toObject
(
)
)
;
ClearResolutionFunctionSlots
(
reject
)
;
bool
result
=
RejectMaybeWrappedPromise
(
cx
promise
reasonVal
)
;
if
(
result
)
args
.
rval
(
)
.
setUndefined
(
)
;
return
result
;
}
static
bool
ResolvePromiseFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
resolve
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
resolutionVal
(
cx
args
.
get
(
0
)
)
;
RootedValue
promiseVal
(
cx
resolve
-
>
getExtendedSlot
(
ResolutionFunctionSlot_Promise
)
)
;
if
(
promiseVal
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
RootedObject
promise
(
cx
&
promiseVal
.
toObject
(
)
)
;
ClearResolutionFunctionSlots
(
resolve
)
;
if
(
resolutionVal
=
=
promiseVal
)
{
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF
)
;
RootedValue
selfResolutionError
(
cx
)
;
bool
status
=
GetAndClearException
(
cx
&
selfResolutionError
)
;
MOZ_ASSERT
(
status
)
;
status
=
RejectMaybeWrappedPromise
(
cx
promise
selfResolutionError
)
;
if
(
status
)
args
.
rval
(
)
.
setUndefined
(
)
;
return
status
;
}
if
(
!
resolutionVal
.
isObject
(
)
)
{
bool
status
=
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
if
(
status
)
args
.
rval
(
)
.
setUndefined
(
)
;
return
status
;
}
RootedObject
resolution
(
cx
&
resolutionVal
.
toObject
(
)
)
;
RootedValue
thenVal
(
cx
)
;
bool
status
=
GetProperty
(
cx
resolution
resolution
cx
-
>
names
(
)
.
then
&
thenVal
)
;
if
(
!
status
)
{
RootedValue
error
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
error
)
)
return
false
;
return
RejectMaybeWrappedPromise
(
cx
promise
error
)
;
}
if
(
!
IsCallable
(
thenVal
)
)
{
bool
status
=
FulfillMaybeWrappedPromise
(
cx
promise
resolutionVal
)
;
if
(
status
)
args
.
rval
(
)
.
setUndefined
(
)
;
return
status
;
}
if
(
!
EnqueuePromiseResolveThenableJob
(
cx
promiseVal
resolutionVal
thenVal
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
CreateResolvingFunctions
(
JSContext
*
cx
HandleValue
promise
MutableHandleValue
resolveVal
MutableHandleValue
rejectVal
)
{
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
resolve
(
cx
NewNativeFunction
(
cx
ResolvePromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
if
(
!
resolve
)
return
false
;
RootedFunction
reject
(
cx
NewNativeFunction
(
cx
RejectPromiseFunction
1
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
if
(
!
reject
)
return
false
;
resolve
-
>
setFlags
(
resolve
-
>
flags
(
)
|
JSFunction
:
:
SELF_HOSTED
)
;
reject
-
>
setFlags
(
reject
-
>
flags
(
)
|
JSFunction
:
:
SELF_HOSTED
)
;
resolve
-
>
setExtendedSlot
(
ResolutionFunctionSlot_Promise
promise
)
;
resolve
-
>
setExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
ObjectValue
(
*
reject
)
)
;
reject
-
>
setExtendedSlot
(
ResolutionFunctionSlot_Promise
promise
)
;
reject
-
>
setExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
ObjectValue
(
*
resolve
)
)
;
resolveVal
.
setObject
(
*
resolve
)
;
rejectVal
.
setObject
(
*
reject
)
;
return
true
;
}
PromiseObject
*
PromiseObject
:
:
create
(
JSContext
*
cx
HandleObject
executor
HandleObject
proto
)
{
MOZ_ASSERT
(
executor
-
>
isCallable
(
)
)
;
RootedObject
usedProto
(
cx
proto
)
;
bool
wrappedProto
=
false
;
if
(
proto
&
&
IsWrapper
(
proto
)
)
{
wrappedProto
=
true
;
usedProto
=
CheckedUnwrap
(
proto
)
;
if
(
!
usedProto
)
return
nullptr
;
}
Rooted
<
PromiseObject
*
>
promise
(
cx
)
;
{
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
wrappedProto
)
ac
.
emplace
(
cx
usedProto
)
;
promise
=
NewObjectWithClassProto
<
PromiseObject
>
(
cx
usedProto
)
;
if
(
!
promise
)
return
nullptr
;
promise
-
>
setFixedSlot
(
PROMISE_STATE_SLOT
Int32Value
(
PROMISE_STATE_PENDING
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_IS_HANDLED_SLOT
Int32Value
(
PROMISE_IS_HANDLED_STATE_UNHANDLED
)
)
;
RootedObject
stack
(
cx
)
;
if
(
cx
-
>
options
(
)
.
asyncStack
(
)
|
|
cx
-
>
compartment
(
)
-
>
isDebuggee
(
)
)
{
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
return
nullptr
;
}
promise
-
>
setFixedSlot
(
PROMISE_ALLOCATION_SITE_SLOT
ObjectOrNullValue
(
stack
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_ALLOCATION_TIME_SLOT
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
}
RootedValue
promiseVal
(
cx
ObjectValue
(
*
promise
)
)
;
if
(
wrappedProto
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseVal
)
)
return
nullptr
;
RootedValue
resolveVal
(
cx
)
;
RootedValue
rejectVal
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promiseVal
&
resolveVal
&
rejectVal
)
)
return
nullptr
;
if
(
wrappedProto
)
{
AutoCompartment
ac
(
cx
promise
)
;
RootedValue
wrappedResolveVal
(
cx
resolveVal
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedResolveVal
)
)
return
nullptr
;
promise
-
>
setFixedSlot
(
PROMISE_RESOLVE_FUNCTION_SLOT
wrappedResolveVal
)
;
}
else
{
promise
-
>
setFixedSlot
(
PROMISE_RESOLVE_FUNCTION_SLOT
resolveVal
)
;
}
bool
success
;
{
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
set
(
resolveVal
)
;
args
[
1
]
.
set
(
rejectVal
)
;
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
executor
)
)
;
success
=
Call
(
cx
calleeOrRval
UndefinedHandleValue
args
&
calleeOrRval
)
;
}
if
(
!
success
)
{
RootedValue
exceptionVal
(
cx
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
exceptionVal
)
)
return
nullptr
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
exceptionVal
)
;
if
(
!
Call
(
cx
rejectVal
UndefinedHandleValue
args
&
rejectVal
)
)
return
nullptr
;
}
JS
:
:
dbg
:
:
onNewPromise
(
cx
promise
)
;
return
promise
;
}
namespace
{
mozilla
:
:
Atomic
<
uint64_t
>
gIDGenerator
(
0
)
;
}
double
PromiseObject
:
:
lifetime
(
)
{
return
MillisecondsSinceStartup
(
)
-
allocationTime
(
)
;
}
uint64_t
PromiseObject
:
:
getID
(
)
{
Value
idVal
(
getReservedSlot
(
PROMISE_ID_SLOT
)
)
;
if
(
idVal
.
isUndefined
(
)
)
{
idVal
.
setDouble
(
+
+
gIDGenerator
)
;
setReservedSlot
(
PROMISE_ID_SLOT
idVal
)
;
}
return
uint64_t
(
idVal
.
toNumber
(
)
)
;
}
bool
PromiseObject
:
:
dependentPromises
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
values
)
{
RootedValue
reactionsVal
(
cx
getReservedSlot
(
PROMISE_REACTIONS_SLOT
)
)
;
if
(
reactionsVal
.
isNullOrUndefined
(
)
)
return
true
;
RootedObject
reactions
(
cx
&
reactionsVal
.
toObject
(
)
)
;
AutoIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
reactions
JSITER_OWNONLY
&
keys
)
)
return
false
;
if
(
keys
.
length
(
)
=
=
0
)
return
true
;
if
(
!
values
.
growBy
(
keys
.
length
(
)
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
MutableHandleValue
val
=
values
[
i
]
;
if
(
!
GetProperty
(
cx
reactions
reactions
keys
[
i
]
val
)
)
return
false
;
RootedObject
reaction
(
cx
&
val
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
reaction
reaction
cx
-
>
names
(
)
.
promise
val
)
)
return
false
;
}
return
true
;
}
namespace
js
{
bool
PromiseConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Promise
"
)
)
return
false
;
RootedValue
executorVal
(
cx
args
.
get
(
0
)
)
;
if
(
!
IsCallable
(
executorVal
)
)
return
ReportIsNotFunction
(
cx
executorVal
)
;
RootedObject
executor
(
cx
&
executorVal
.
toObject
(
)
)
;
RootedObject
newTarget
(
cx
&
args
.
newTarget
(
)
.
toObject
(
)
)
;
RootedObject
originalNewTarget
(
cx
newTarget
)
;
bool
needsWrapping
=
false
;
if
(
IsWrapper
(
newTarget
)
)
{
newTarget
=
CheckedUnwrap
(
newTarget
)
;
MOZ_ASSERT
(
newTarget
)
;
MOZ_ASSERT
(
newTarget
!
=
originalNewTarget
)
;
{
AutoCompartment
ac
(
cx
newTarget
)
;
RootedObject
promiseCtor
(
cx
)
;
if
(
!
GetBuiltinConstructor
(
cx
JSProto_Promise
&
promiseCtor
)
)
return
false
;
if
(
newTarget
=
=
promiseCtor
)
needsWrapping
=
true
;
}
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromConstructor
(
cx
newTarget
&
proto
)
)
return
false
;
if
(
needsWrapping
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
proto
)
)
return
false
;
Rooted
<
PromiseObject
*
>
promise
(
cx
PromiseObject
:
:
create
(
cx
executor
proto
)
)
;
if
(
!
promise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
promise
)
;
if
(
needsWrapping
)
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
args
.
rval
(
)
)
;
return
true
;
}
bool
PromiseObject
:
:
resolve
(
JSContext
*
cx
HandleValue
resolutionValue
)
{
if
(
this
-
>
getFixedSlot
(
PROMISE_STATE_SLOT
)
.
toInt32
(
)
!
=
unsigned
(
JS
:
:
PromiseState
:
:
Pending
)
)
return
true
;
RootedValue
funVal
(
cx
this
-
>
getReservedSlot
(
PROMISE_RESOLVE_FUNCTION_SLOT
)
)
;
MOZ_ASSERT
(
funVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
resolutionValue
)
;
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
args
&
dummy
)
;
}
bool
PromiseObject
:
:
reject
(
JSContext
*
cx
HandleValue
rejectionValue
)
{
if
(
this
-
>
getFixedSlot
(
PROMISE_STATE_SLOT
)
.
toInt32
(
)
!
=
unsigned
(
JS
:
:
PromiseState
:
:
Pending
)
)
return
true
;
RootedValue
resolveVal
(
cx
this
-
>
getReservedSlot
(
PROMISE_RESOLVE_FUNCTION_SLOT
)
)
;
RootedFunction
resolve
(
cx
&
resolveVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
funVal
(
cx
resolve
-
>
getExtendedSlot
(
ResolutionFunctionSlot_OtherFunction
)
)
;
MOZ_ASSERT
(
funVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
rejectionValue
)
;
RootedValue
dummy
(
cx
)
;
return
Call
(
cx
funVal
UndefinedHandleValue
args
&
dummy
)
;
}
void
PromiseObject
:
:
onSettled
(
JSContext
*
cx
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
this
)
;
RootedObject
stack
(
cx
)
;
if
(
cx
-
>
options
(
)
.
asyncStack
(
)
|
|
cx
-
>
compartment
(
)
-
>
isDebuggee
(
)
)
{
if
(
!
JS
:
:
CaptureCurrentStack
(
cx
&
stack
JS
:
:
StackCapture
(
JS
:
:
AllFrames
(
)
)
)
)
{
cx
-
>
clearPendingException
(
)
;
return
;
}
}
promise
-
>
setFixedSlot
(
PROMISE_RESOLUTION_SITE_SLOT
ObjectOrNullValue
(
stack
)
)
;
promise
-
>
setFixedSlot
(
PROMISE_RESOLUTION_TIME_SLOT
DoubleValue
(
MillisecondsSinceStartup
(
)
)
)
;
if
(
promise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
&
&
promise
-
>
getFixedSlot
(
PROMISE_IS_HANDLED_SLOT
)
.
toInt32
(
)
!
=
PROMISE_IS_HANDLED_STATE_HANDLED
)
{
cx
-
>
runtime
(
)
-
>
addUnhandledRejectedPromise
(
cx
promise
)
;
}
JS
:
:
dbg
:
:
onPromiseSettled
(
cx
promise
)
;
}
enum
ReactionJobSlots
{
ReactionJobSlot_Handler
=
0
ReactionJobSlot_JobData
}
;
enum
ReactionJobDataSlots
{
ReactionJobDataSlot_HandlerArg
=
0
ReactionJobDataSlot_ResolveHook
ReactionJobDataSlot_RejectHook
ReactionJobDataSlotsCount
}
;
static
bool
PromiseReactionJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
handlerVal
(
cx
job
-
>
getExtendedSlot
(
ReactionJobSlot_Handler
)
)
;
RootedObject
jobDataObj
(
cx
&
job
-
>
getExtendedSlot
(
ReactionJobSlot_JobData
)
.
toObject
(
)
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
IsWrapper
(
jobDataObj
)
)
{
jobDataObj
=
UncheckedUnwrap
(
jobDataObj
)
;
ac
.
emplace
(
cx
jobDataObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
handlerVal
)
)
return
false
;
}
RootedNativeObject
jobData
(
cx
&
jobDataObj
-
>
as
<
NativeObject
>
(
)
)
;
RootedValue
argument
(
cx
jobData
-
>
getDenseElement
(
ReactionJobDataSlot_HandlerArg
)
)
;
RootedValue
handlerResult
(
cx
)
;
bool
shouldReject
=
false
;
if
(
handlerVal
.
isNumber
(
)
)
{
int32_t
handlerNum
=
int32_t
(
handlerVal
.
toNumber
(
)
)
;
if
(
handlerNum
=
=
PROMISE_HANDLER_IDENTITY
)
{
handlerResult
=
argument
;
}
else
{
MOZ_ASSERT
(
handlerNum
=
=
PROMISE_HANDLER_THROWER
)
;
shouldReject
=
true
;
handlerResult
=
argument
;
}
}
else
{
FixedInvokeArgs
<
1
>
args2
(
cx
)
;
args2
[
0
]
.
set
(
argument
)
;
if
(
!
Call
(
cx
handlerVal
UndefinedHandleValue
args2
&
handlerResult
)
)
{
shouldReject
=
true
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
GetAndClearException
(
cx
&
handlerResult
)
)
return
false
;
}
}
size_t
hookSlot
=
shouldReject
?
ReactionJobDataSlot_RejectHook
:
ReactionJobDataSlot_ResolveHook
;
RootedObject
callee
(
cx
&
jobData
-
>
getDenseElement
(
hookSlot
)
.
toObject
(
)
)
;
FixedInvokeArgs
<
1
>
args2
(
cx
)
;
args2
[
0
]
.
set
(
handlerResult
)
;
RootedValue
calleeOrRval
(
cx
ObjectValue
(
*
callee
)
)
;
bool
result
=
Call
(
cx
calleeOrRval
UndefinedHandleValue
args2
&
calleeOrRval
)
;
args
.
rval
(
)
.
set
(
calleeOrRval
)
;
return
result
;
}
bool
EnqueuePromiseReactionJob
(
JSContext
*
cx
HandleValue
handler_
HandleValue
handlerArg
HandleObject
resolve
HandleObject
reject
HandleObject
promise_
HandleObject
objectFromIncumbentGlobal_
)
{
RootedArrayObject
data
(
cx
NewDenseFullyAllocatedArray
(
cx
ReactionJobDataSlotsCount
)
)
;
if
(
!
data
|
|
data
-
>
ensureDenseElements
(
cx
0
ReactionJobDataSlotsCount
)
!
=
DenseElementResult
:
:
Success
)
{
return
false
;
}
data
-
>
setDenseElement
(
ReactionJobDataSlot_HandlerArg
handlerArg
)
;
data
-
>
setDenseElement
(
ReactionJobDataSlot_ResolveHook
ObjectValue
(
*
resolve
)
)
;
data
-
>
setDenseElement
(
ReactionJobDataSlot_RejectHook
ObjectValue
(
*
reject
)
)
;
RootedValue
dataVal
(
cx
ObjectValue
(
*
data
)
)
;
RootedValue
handler
(
cx
handler_
)
;
mozilla
:
:
Maybe
<
AutoCompartment
>
ac
;
if
(
handler
.
isObject
(
)
)
{
RootedObject
handlerObj
(
cx
&
handler
.
toObject
(
)
)
;
handlerObj
=
UncheckedUnwrap
(
handlerObj
)
;
MOZ_ASSERT
(
handlerObj
)
;
ac
.
emplace
(
cx
handlerObj
)
;
handler
=
ObjectValue
(
*
handlerObj
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
dataVal
)
)
return
false
;
}
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseReactionJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
if
(
!
job
)
return
false
;
job
-
>
setExtendedSlot
(
ReactionJobSlot_Handler
handler
)
;
job
-
>
setExtendedSlot
(
ReactionJobSlot_JobData
dataVal
)
;
RootedObject
promise
(
cx
)
;
if
(
promise_
&
&
promise_
-
>
is
<
PromiseObject
>
(
)
)
{
promise
=
promise_
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promise
)
)
return
false
;
}
RootedObject
global
(
cx
)
;
RootedObject
objectFromIncumbentGlobal
(
cx
objectFromIncumbentGlobal_
)
;
if
(
objectFromIncumbentGlobal
)
{
objectFromIncumbentGlobal
=
CheckedUnwrap
(
objectFromIncumbentGlobal
)
;
MOZ_ASSERT
(
objectFromIncumbentGlobal
)
;
global
=
&
objectFromIncumbentGlobal
-
>
global
(
)
;
}
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
global
)
;
}
enum
ThenableJobSlots
{
ThenableJobSlot_Handler
=
0
ThenableJobSlot_JobData
}
;
enum
ThenableJobDataSlots
{
ThenableJobDataSlot_Promise
=
0
ThenableJobDataSlot_Thenable
ThenableJobDataSlotsCount
}
;
static
bool
PromiseResolveThenableJob
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
job
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
then
(
cx
job
-
>
getExtendedSlot
(
ThenableJobSlot_Handler
)
)
;
MOZ_ASSERT
(
!
IsWrapper
(
&
then
.
toObject
(
)
)
)
;
RootedNativeObject
jobArgs
(
cx
&
job
-
>
getExtendedSlot
(
ThenableJobSlot_JobData
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
RootedValue
promise
(
cx
jobArgs
-
>
getDenseElement
(
ThenableJobDataSlot_Promise
)
)
;
RootedValue
thenable
(
cx
jobArgs
-
>
getDenseElement
(
ThenableJobDataSlot_Thenable
)
)
;
RootedValue
resolveVal
(
cx
)
;
RootedValue
rejectVal
(
cx
)
;
if
(
!
CreateResolvingFunctions
(
cx
promise
&
resolveVal
&
rejectVal
)
)
return
false
;
FixedInvokeArgs
<
2
>
args2
(
cx
)
;
args2
[
0
]
.
set
(
resolveVal
)
;
args2
[
1
]
.
set
(
rejectVal
)
;
RootedValue
rval
(
cx
)
;
if
(
Call
(
cx
then
thenable
args2
&
rval
)
)
return
true
;
if
(
!
GetAndClearException
(
cx
&
rval
)
)
return
false
;
FixedInvokeArgs
<
1
>
rejectArgs
(
cx
)
;
rejectArgs
[
0
]
.
set
(
rval
)
;
return
Call
(
cx
rejectVal
UndefinedHandleValue
rejectArgs
&
rval
)
;
}
bool
EnqueuePromiseResolveThenableJob
(
JSContext
*
cx
HandleValue
promiseToResolve_
HandleValue
thenable_
HandleValue
thenVal
)
{
RootedValue
promiseToResolve
(
cx
promiseToResolve_
)
;
RootedValue
thenable
(
cx
thenable_
)
;
RootedObject
then
(
cx
CheckedUnwrap
(
&
thenVal
.
toObject
(
)
)
)
;
AutoCompartment
ac
(
cx
then
)
;
RootedAtom
funName
(
cx
cx
-
>
names
(
)
.
empty
)
;
RootedFunction
job
(
cx
NewNativeFunction
(
cx
PromiseResolveThenableJob
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
if
(
!
job
)
return
false
;
job
-
>
setExtendedSlot
(
ThenableJobSlot_Handler
ObjectValue
(
*
then
)
)
;
RootedArrayObject
data
(
cx
NewDenseFullyAllocatedArray
(
cx
ThenableJobDataSlotsCount
)
)
;
if
(
!
data
|
|
data
-
>
ensureDenseElements
(
cx
0
ThenableJobDataSlotsCount
)
!
=
DenseElementResult
:
:
Success
)
{
return
false
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
promiseToResolve
)
)
return
false
;
data
-
>
setDenseElement
(
ThenableJobDataSlot_Promise
promiseToResolve
)
;
RootedObject
promise
(
cx
&
promiseToResolve
.
toObject
(
)
)
;
MOZ_ASSERT
(
thenable
.
isObject
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
thenable
)
)
return
false
;
data
-
>
setDenseElement
(
ThenableJobDataSlot_Thenable
thenable
)
;
job
-
>
setExtendedSlot
(
ThenableJobSlot_JobData
ObjectValue
(
*
data
)
)
;
RootedObject
incumbentGlobal
(
cx
cx
-
>
runtime
(
)
-
>
getIncumbentGlobal
(
cx
)
)
;
return
cx
-
>
runtime
(
)
-
>
enqueuePromiseJob
(
cx
job
promise
incumbentGlobal
)
;
}
PromiseTask
:
:
PromiseTask
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
:
runtime_
(
cx
)
promise_
(
cx
promise
)
{
}
PromiseTask
:
:
~
PromiseTask
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessZone
(
promise_
-
>
zone
(
)
)
)
;
}
void
PromiseTask
:
:
finish
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
=
=
runtime_
)
;
{
AutoCompartment
ac
(
cx
promise_
)
;
if
(
!
finishPromise
(
cx
promise_
)
)
cx
-
>
clearPendingException
(
)
;
}
js_delete
(
this
)
;
}
void
PromiseTask
:
:
cancel
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
=
=
runtime_
)
;
js_delete
(
this
)
;
}
}
static
JSObject
*
CreatePromisePrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
cx
-
>
global
(
)
-
>
createBlankPrototype
(
cx
&
PromiseObject
:
:
protoClass_
)
;
}
static
const
ClassSpec
PromiseObjectClassSpec
=
{
GenericCreateConstructor
<
PromiseConstructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
CreatePromisePrototype
promise_static_methods
promise_static_properties
promise_methods
}
;
const
Class
PromiseObject
:
:
class_
=
{
"
Promise
"
JSCLASS_HAS_RESERVED_SLOTS
(
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
|
JSCLASS_HAS_XRAYED_CONSTRUCTOR
JS_NULL_CLASS_OPS
&
PromiseObjectClassSpec
}
;
static
const
ClassSpec
PromiseObjectProtoClassSpec
=
{
DELEGATED_CLASSSPEC
(
PromiseObject
:
:
class_
.
spec
)
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ClassSpec
:
:
IsDelegated
}
;
const
Class
PromiseObject
:
:
protoClass_
=
{
"
PromiseProto
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Promise
)
JS_NULL_CLASS_OPS
&
PromiseObjectProtoClassSpec
}
;
