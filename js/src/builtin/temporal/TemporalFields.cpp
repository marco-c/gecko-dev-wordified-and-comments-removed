#
include
"
builtin
/
temporal
/
TemporalFields
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cstring
>
#
include
<
iterator
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Crash
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
ComparisonOperators
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
JSAtomUtils
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
void
TemporalFields
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
monthCode
"
TemporalFields
:
:
monthCode
"
)
;
TraceNullableRoot
(
trc
&
offset
"
TemporalFields
:
:
offset
"
)
;
TraceNullableRoot
(
trc
&
era
"
TemporalFields
:
:
era
"
)
;
TraceRoot
(
trc
&
timeZone
"
TemporalFields
:
:
timeZone
"
)
;
}
template
<
typename
T
const
auto
&
sorted
>
class
SortedEnumSet
{
mozilla
:
:
EnumSet
<
T
>
fields_
;
public
:
explicit
SortedEnumSet
(
mozilla
:
:
EnumSet
<
T
>
fields
)
:
fields_
(
fields
)
{
}
class
Iterator
{
mozilla
:
:
EnumSet
<
T
>
fields_
;
size_t
index_
;
void
findNext
(
)
{
while
(
index_
<
sorted
.
size
(
)
&
&
!
fields_
.
contains
(
sorted
[
index_
]
)
)
{
index_
+
+
;
}
}
void
findPrevious
(
)
{
while
(
index_
>
0
&
&
!
fields_
.
contains
(
sorted
[
index_
]
)
)
{
index_
-
-
;
}
}
public
:
using
difference_type
=
ptrdiff_t
;
using
value_type
=
TemporalField
;
using
pointer
=
TemporalField
*
;
using
reference
=
TemporalField
&
;
using
iterator_category
=
std
:
:
bidirectional_iterator_tag
;
Iterator
(
mozilla
:
:
EnumSet
<
T
>
fields
size_t
index
)
:
fields_
(
fields
)
index_
(
index
)
{
findNext
(
)
;
}
bool
operator
=
=
(
const
Iterator
&
other
)
const
{
MOZ_ASSERT
(
fields_
=
=
other
.
fields_
)
;
return
index_
=
=
other
.
index_
;
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
auto
operator
*
(
)
const
{
MOZ_ASSERT
(
index_
<
sorted
.
size
(
)
)
;
MOZ_ASSERT
(
fields_
.
contains
(
sorted
[
index_
]
)
)
;
return
sorted
[
index_
]
;
}
auto
&
operator
+
+
(
)
{
MOZ_ASSERT
(
index_
<
sorted
.
size
(
)
)
;
index_
+
+
;
findNext
(
)
;
return
*
this
;
}
auto
operator
+
+
(
int
)
{
auto
result
=
*
this
;
+
+
(
*
this
)
;
return
result
;
}
auto
&
operator
-
-
(
)
{
MOZ_ASSERT
(
index_
>
0
)
;
index_
-
-
;
findPrevious
(
)
;
return
*
this
;
}
auto
operator
-
-
(
int
)
{
auto
result
=
*
this
;
-
-
(
*
this
)
;
return
result
;
}
}
;
Iterator
begin
(
)
const
{
return
Iterator
{
fields_
0
}
;
}
;
Iterator
end
(
)
const
{
return
Iterator
{
fields_
sorted
.
size
(
)
}
;
}
}
;
PropertyName
*
js
:
:
temporal
:
:
ToPropertyName
(
JSContext
*
cx
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
return
cx
-
>
names
(
)
.
year
;
case
TemporalField
:
:
Month
:
return
cx
-
>
names
(
)
.
month
;
case
TemporalField
:
:
MonthCode
:
return
cx
-
>
names
(
)
.
monthCode
;
case
TemporalField
:
:
Day
:
return
cx
-
>
names
(
)
.
day
;
case
TemporalField
:
:
Hour
:
return
cx
-
>
names
(
)
.
hour
;
case
TemporalField
:
:
Minute
:
return
cx
-
>
names
(
)
.
minute
;
case
TemporalField
:
:
Second
:
return
cx
-
>
names
(
)
.
second
;
case
TemporalField
:
:
Millisecond
:
return
cx
-
>
names
(
)
.
millisecond
;
case
TemporalField
:
:
Microsecond
:
return
cx
-
>
names
(
)
.
microsecond
;
case
TemporalField
:
:
Nanosecond
:
return
cx
-
>
names
(
)
.
nanosecond
;
case
TemporalField
:
:
Offset
:
return
cx
-
>
names
(
)
.
offset
;
case
TemporalField
:
:
Era
:
return
cx
-
>
names
(
)
.
era
;
case
TemporalField
:
:
EraYear
:
return
cx
-
>
names
(
)
.
eraYear
;
case
TemporalField
:
:
TimeZone
:
return
cx
-
>
names
(
)
.
timeZone
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
constexpr
const
char
*
ToCString
(
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
return
"
year
"
;
case
TemporalField
:
:
Month
:
return
"
month
"
;
case
TemporalField
:
:
MonthCode
:
return
"
monthCode
"
;
case
TemporalField
:
:
Day
:
return
"
day
"
;
case
TemporalField
:
:
Hour
:
return
"
hour
"
;
case
TemporalField
:
:
Minute
:
return
"
minute
"
;
case
TemporalField
:
:
Second
:
return
"
second
"
;
case
TemporalField
:
:
Millisecond
:
return
"
millisecond
"
;
case
TemporalField
:
:
Microsecond
:
return
"
microsecond
"
;
case
TemporalField
:
:
Nanosecond
:
return
"
nanosecond
"
;
case
TemporalField
:
:
Offset
:
return
"
offset
"
;
case
TemporalField
:
:
Era
:
return
"
era
"
;
case
TemporalField
:
:
EraYear
:
return
"
eraYear
"
;
case
TemporalField
:
:
TimeZone
:
return
"
timeZone
"
;
}
JS_CONSTEXPR_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
template
<
typename
T
size_t
N
>
static
constexpr
bool
IsSorted
(
const
std
:
:
array
<
T
N
>
&
arr
)
{
for
(
size_t
i
=
1
;
i
<
arr
.
size
(
)
;
i
+
+
)
{
auto
a
=
std
:
:
string_view
{
ToCString
(
arr
[
i
-
1
]
)
}
;
auto
b
=
std
:
:
string_view
{
ToCString
(
arr
[
i
]
)
}
;
if
(
a
.
compare
(
b
)
>
=
0
)
{
return
false
;
}
}
return
true
;
}
static
constexpr
auto
sortedTemporalFields
=
std
:
:
array
{
TemporalField
:
:
Day
TemporalField
:
:
Era
TemporalField
:
:
EraYear
TemporalField
:
:
Hour
TemporalField
:
:
Microsecond
TemporalField
:
:
Millisecond
TemporalField
:
:
Minute
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Nanosecond
TemporalField
:
:
Offset
TemporalField
:
:
Second
TemporalField
:
:
TimeZone
TemporalField
:
:
Year
}
;
static_assert
(
IsSorted
(
sortedTemporalFields
)
)
;
using
SortedTemporalFields
=
SortedEnumSet
<
TemporalField
sortedTemporalFields
>
;
mozilla
:
:
Maybe
<
TemporalField
>
js
:
:
temporal
:
:
ToTemporalField
(
JSContext
*
cx
PropertyKey
property
)
{
static
constexpr
TemporalField
fieldNames
[
]
=
{
TemporalField
:
:
Year
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Day
TemporalField
:
:
Hour
TemporalField
:
:
Minute
TemporalField
:
:
Second
TemporalField
:
:
Millisecond
TemporalField
:
:
Microsecond
TemporalField
:
:
Nanosecond
TemporalField
:
:
Offset
TemporalField
:
:
Era
TemporalField
:
:
EraYear
TemporalField
:
:
TimeZone
}
;
for
(
const
auto
&
fieldName
:
fieldNames
)
{
auto
*
name
=
ToPropertyName
(
cx
fieldName
)
;
if
(
property
.
isAtom
(
name
)
)
{
return
mozilla
:
:
Some
(
fieldName
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
JSString
*
ToPrimitiveAndRequireString
(
JSContext
*
cx
Handle
<
Value
>
value
)
{
Rooted
<
Value
>
primitive
(
cx
value
)
;
if
(
!
ToPrimitive
(
cx
JSTYPE_STRING
&
primitive
)
)
{
return
nullptr
;
}
if
(
!
primitive
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
primitive
nullptr
"
not
a
string
"
)
;
return
nullptr
;
}
return
primitive
.
toString
(
)
;
}
static
Value
TemporalFieldDefaultValue
(
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
case
TemporalField
:
:
Month
:
case
TemporalField
:
:
MonthCode
:
case
TemporalField
:
:
Day
:
case
TemporalField
:
:
Offset
:
case
TemporalField
:
:
Era
:
case
TemporalField
:
:
EraYear
:
case
TemporalField
:
:
TimeZone
:
return
UndefinedValue
(
)
;
case
TemporalField
:
:
Hour
:
case
TemporalField
:
:
Minute
:
case
TemporalField
:
:
Second
:
case
TemporalField
:
:
Millisecond
:
case
TemporalField
:
:
Microsecond
:
case
TemporalField
:
:
Nanosecond
:
return
Int32Value
(
0
)
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
bool
TemporalFieldConvertValue
(
JSContext
*
cx
TemporalField
field
MutableHandle
<
Value
>
value
)
{
const
auto
*
name
=
ToCString
(
field
)
;
switch
(
field
)
{
case
TemporalField
:
:
Year
:
case
TemporalField
:
:
Hour
:
case
TemporalField
:
:
Minute
:
case
TemporalField
:
:
Second
:
case
TemporalField
:
:
Millisecond
:
case
TemporalField
:
:
Microsecond
:
case
TemporalField
:
:
Nanosecond
:
{
double
num
;
if
(
!
ToIntegerWithTruncation
(
cx
value
name
&
num
)
)
{
return
false
;
}
value
.
setNumber
(
num
)
;
return
true
;
}
case
TemporalField
:
:
EraYear
:
{
[
[
fallthrough
]
]
;
}
case
TemporalField
:
:
Month
:
case
TemporalField
:
:
Day
:
{
double
num
;
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
name
&
num
)
)
{
return
false
;
}
value
.
setNumber
(
num
)
;
return
true
;
}
case
TemporalField
:
:
MonthCode
:
case
TemporalField
:
:
Offset
:
case
TemporalField
:
:
Era
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
value
.
setString
(
str
)
;
return
true
;
}
case
TemporalField
:
:
TimeZone
:
return
true
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
void
AssignFromFallback
(
TemporalField
fieldName
MutableHandle
<
TemporalFields
>
result
)
{
const
TemporalFields
FallbackValues
{
}
;
switch
(
fieldName
)
{
case
TemporalField
:
:
Year
:
result
.
year
(
)
=
FallbackValues
.
year
;
break
;
case
TemporalField
:
:
Month
:
result
.
month
(
)
=
FallbackValues
.
month
;
break
;
case
TemporalField
:
:
MonthCode
:
result
.
monthCode
(
)
.
set
(
FallbackValues
.
monthCode
)
;
break
;
case
TemporalField
:
:
Day
:
result
.
day
(
)
=
FallbackValues
.
day
;
break
;
case
TemporalField
:
:
Hour
:
result
.
hour
(
)
=
FallbackValues
.
hour
;
break
;
case
TemporalField
:
:
Minute
:
result
.
minute
(
)
=
FallbackValues
.
minute
;
break
;
case
TemporalField
:
:
Second
:
result
.
second
(
)
=
FallbackValues
.
second
;
break
;
case
TemporalField
:
:
Millisecond
:
result
.
millisecond
(
)
=
FallbackValues
.
millisecond
;
break
;
case
TemporalField
:
:
Microsecond
:
result
.
microsecond
(
)
=
FallbackValues
.
microsecond
;
break
;
case
TemporalField
:
:
Nanosecond
:
result
.
nanosecond
(
)
=
FallbackValues
.
nanosecond
;
break
;
case
TemporalField
:
:
Offset
:
result
.
offset
(
)
.
set
(
FallbackValues
.
offset
)
;
break
;
case
TemporalField
:
:
Era
:
result
.
era
(
)
.
set
(
FallbackValues
.
era
)
;
break
;
case
TemporalField
:
:
EraYear
:
result
.
eraYear
(
)
=
FallbackValues
.
eraYear
;
break
;
case
TemporalField
:
:
TimeZone
:
result
.
timeZone
(
)
.
set
(
FallbackValues
.
timeZone
)
;
break
;
}
}
bool
js
:
:
temporal
:
:
PrepareTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
TemporalField
>
fieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
requiredFields
MutableHandle
<
TemporalFields
>
result
)
{
Rooted
<
Value
>
value
(
cx
)
;
for
(
auto
fieldName
:
SortedTemporalFields
{
fieldNames
}
)
{
auto
*
property
=
ToPropertyName
(
cx
fieldName
)
;
const
auto
*
cstr
=
ToCString
(
fieldName
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
false
;
}
if
(
!
value
.
isUndefined
(
)
)
{
switch
(
fieldName
)
{
case
TemporalField
:
:
Year
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
year
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Month
:
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
cstr
&
result
.
month
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
MonthCode
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
monthCode
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
Day
:
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
cstr
&
result
.
day
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Hour
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
hour
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Minute
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
minute
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Second
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
second
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Millisecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
millisecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Microsecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
microsecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Nanosecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
nanosecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Offset
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
offset
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
Era
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
era
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
EraYear
:
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
cstr
&
result
.
eraYear
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
TimeZone
:
result
.
timeZone
(
)
.
set
(
value
)
;
break
;
}
}
else
{
if
(
requiredFields
.
contains
(
fieldName
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
cstr
)
;
return
false
;
}
AssignFromFallback
(
fieldName
result
)
;
}
}
return
true
;
}
PlainObject
*
js
:
:
temporal
:
:
PrepareTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
TemporalField
>
fieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
requiredFields
)
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
Rooted
<
Value
>
value
(
cx
)
;
Rooted
<
PropertyKey
>
property
(
cx
)
;
for
(
auto
fieldName
:
SortedTemporalFields
{
fieldNames
}
)
{
property
=
NameToId
(
ToPropertyName
(
cx
fieldName
)
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
nullptr
;
}
if
(
!
value
.
isUndefined
(
)
)
{
if
(
!
TemporalFieldConvertValue
(
cx
fieldName
&
value
)
)
{
return
nullptr
;
}
}
else
{
if
(
requiredFields
.
contains
(
fieldName
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
ToCString
(
fieldName
)
)
;
return
nullptr
;
}
value
=
TemporalFieldDefaultValue
(
fieldName
)
;
}
if
(
!
DefineDataProperty
(
cx
result
property
value
)
)
{
return
nullptr
;
}
}
return
result
;
}
PlainObject
*
js
:
:
temporal
:
:
PreparePartialTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
TemporalField
>
fieldNames
)
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
bool
any
=
false
;
Rooted
<
Value
>
value
(
cx
)
;
Rooted
<
PropertyKey
>
property
(
cx
)
;
for
(
auto
fieldName
:
SortedTemporalFields
{
fieldNames
}
)
{
property
=
NameToId
(
ToPropertyName
(
cx
fieldName
)
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
nullptr
;
}
if
(
!
value
.
isUndefined
(
)
)
{
any
=
true
;
if
(
!
TemporalFieldConvertValue
(
cx
fieldName
&
value
)
)
{
return
nullptr
;
}
if
(
!
DefineDataProperty
(
cx
result
property
value
)
)
{
return
nullptr
;
}
}
else
{
}
}
if
(
!
any
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_TEMPORAL_FIELDS
)
;
return
nullptr
;
}
return
result
;
}
static
auto
AsTemporalFieldSet
(
mozilla
:
:
EnumSet
<
CalendarField
>
values
)
{
using
T
=
std
:
:
underlying_type_t
<
TemporalField
>
;
static_assert
(
std
:
:
is_same_v
<
T
std
:
:
underlying_type_t
<
CalendarField
>
>
)
;
static_assert
(
static_cast
<
T
>
(
TemporalField
:
:
Year
)
=
=
static_cast
<
T
>
(
CalendarField
:
:
Year
)
)
;
static_assert
(
static_cast
<
T
>
(
TemporalField
:
:
Month
)
=
=
static_cast
<
T
>
(
CalendarField
:
:
Month
)
)
;
static_assert
(
static_cast
<
T
>
(
TemporalField
:
:
MonthCode
)
=
=
static_cast
<
T
>
(
CalendarField
:
:
MonthCode
)
)
;
static_assert
(
static_cast
<
T
>
(
TemporalField
:
:
Day
)
=
=
static_cast
<
T
>
(
CalendarField
:
:
Day
)
)
;
auto
result
=
mozilla
:
:
EnumSet
<
TemporalField
>
{
}
;
result
.
deserialize
(
values
.
serialize
(
)
)
;
return
result
;
}
static
bool
PrepareCalendarFieldsAndFieldNames
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
CalendarField
>
calendarFieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
nonCalendarFieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
requiredFieldNames
MutableHandle
<
PlainObject
*
>
resultFields
mozilla
:
:
EnumSet
<
TemporalField
>
*
resultFieldNames
)
{
auto
calendarId
=
calendar
.
identifier
(
)
;
auto
fieldNames
=
AsTemporalFieldSet
(
calendarFieldNames
)
;
if
(
calendarId
!
=
CalendarId
:
:
ISO8601
)
{
fieldNames
+
=
CalendarFieldDescriptors
(
calendar
calendarFieldNames
)
;
}
fieldNames
+
=
nonCalendarFieldNames
;
auto
*
flds
=
PrepareTemporalFields
(
cx
fields
fieldNames
requiredFieldNames
)
;
if
(
!
flds
)
{
return
false
;
}
resultFields
.
set
(
flds
)
;
*
resultFieldNames
=
fieldNames
;
return
true
;
}
bool
js
:
:
temporal
:
:
PrepareCalendarFieldsAndFieldNames
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
CalendarField
>
calendarFieldNames
MutableHandle
<
PlainObject
*
>
resultFields
mozilla
:
:
EnumSet
<
TemporalField
>
*
resultFieldNames
)
{
return
:
:
PrepareCalendarFieldsAndFieldNames
(
cx
calendar
fields
calendarFieldNames
{
}
{
}
resultFields
resultFieldNames
)
;
}
#
ifdef
DEBUG
static
constexpr
auto
NonCalendarFieldNames
=
mozilla
:
:
EnumSet
<
TemporalField
>
{
TemporalField
:
:
Hour
TemporalField
:
:
Minute
TemporalField
:
:
Second
TemporalField
:
:
Millisecond
TemporalField
:
:
Microsecond
TemporalField
:
:
Nanosecond
TemporalField
:
:
Offset
TemporalField
:
:
TimeZone
}
;
#
endif
PlainObject
*
js
:
:
temporal
:
:
PrepareCalendarFields
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
fields
mozilla
:
:
EnumSet
<
CalendarField
>
calendarFieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
nonCalendarFieldNames
mozilla
:
:
EnumSet
<
TemporalField
>
requiredFieldNames
)
{
MOZ_ASSERT
(
NonCalendarFieldNames
.
contains
(
nonCalendarFieldNames
)
)
;
MOZ_ASSERT
(
(
AsTemporalFieldSet
(
calendarFieldNames
)
+
nonCalendarFieldNames
)
.
contains
(
requiredFieldNames
)
)
;
Rooted
<
PlainObject
*
>
resultFields
(
cx
)
;
mozilla
:
:
EnumSet
<
TemporalField
>
resultFieldNames
{
}
;
if
(
!
:
:
PrepareCalendarFieldsAndFieldNames
(
cx
calendar
fields
calendarFieldNames
nonCalendarFieldNames
requiredFieldNames
&
resultFields
&
resultFieldNames
)
)
{
return
nullptr
;
}
return
resultFields
;
}
