#
include
"
builtin
/
temporal
/
TemporalFields
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
iterator
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
ComparisonOperators
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
JSAtomUtils
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
void
TemporalFields
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
monthCode
"
TemporalFields
:
:
monthCode
"
)
;
TraceNullableRoot
(
trc
&
offset
"
TemporalFields
:
:
offset
"
)
;
TraceNullableRoot
(
trc
&
era
"
TemporalFields
:
:
era
"
)
;
TraceRoot
(
trc
&
timeZone
"
TemporalFields
:
:
timeZone
"
)
;
}
static
PropertyName
*
ToPropertyName
(
JSContext
*
cx
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
return
cx
-
>
names
(
)
.
year
;
case
TemporalField
:
:
Month
:
return
cx
-
>
names
(
)
.
month
;
case
TemporalField
:
:
MonthCode
:
return
cx
-
>
names
(
)
.
monthCode
;
case
TemporalField
:
:
Day
:
return
cx
-
>
names
(
)
.
day
;
case
TemporalField
:
:
Hour
:
return
cx
-
>
names
(
)
.
hour
;
case
TemporalField
:
:
Minute
:
return
cx
-
>
names
(
)
.
minute
;
case
TemporalField
:
:
Second
:
return
cx
-
>
names
(
)
.
second
;
case
TemporalField
:
:
Millisecond
:
return
cx
-
>
names
(
)
.
millisecond
;
case
TemporalField
:
:
Microsecond
:
return
cx
-
>
names
(
)
.
microsecond
;
case
TemporalField
:
:
Nanosecond
:
return
cx
-
>
names
(
)
.
nanosecond
;
case
TemporalField
:
:
Offset
:
return
cx
-
>
names
(
)
.
offset
;
case
TemporalField
:
:
Era
:
return
cx
-
>
names
(
)
.
era
;
case
TemporalField
:
:
EraYear
:
return
cx
-
>
names
(
)
.
eraYear
;
case
TemporalField
:
:
TimeZone
:
return
cx
-
>
names
(
)
.
timeZone
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
const
char
*
ToCString
(
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
return
"
year
"
;
case
TemporalField
:
:
Month
:
return
"
month
"
;
case
TemporalField
:
:
MonthCode
:
return
"
monthCode
"
;
case
TemporalField
:
:
Day
:
return
"
day
"
;
case
TemporalField
:
:
Hour
:
return
"
hour
"
;
case
TemporalField
:
:
Minute
:
return
"
minute
"
;
case
TemporalField
:
:
Second
:
return
"
second
"
;
case
TemporalField
:
:
Millisecond
:
return
"
millisecond
"
;
case
TemporalField
:
:
Microsecond
:
return
"
microsecond
"
;
case
TemporalField
:
:
Nanosecond
:
return
"
nanosecond
"
;
case
TemporalField
:
:
Offset
:
return
"
offset
"
;
case
TemporalField
:
:
Era
:
return
"
era
"
;
case
TemporalField
:
:
EraYear
:
return
"
eraYear
"
;
case
TemporalField
:
:
TimeZone
:
return
"
timeZone
"
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
JS
:
:
UniqueChars
QuoteString
(
JSContext
*
cx
const
char
*
str
)
{
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
{
return
nullptr
;
}
mozilla
:
:
Range
range
(
reinterpret_cast
<
const
Latin1Char
*
>
(
str
)
std
:
:
strlen
(
str
)
)
;
if
(
!
QuoteString
<
QuoteTarget
:
:
String
>
(
&
sprinter
range
)
)
{
return
nullptr
;
}
return
sprinter
.
release
(
)
;
}
static
JS
:
:
UniqueChars
QuoteString
(
JSContext
*
cx
PropertyKey
key
)
{
if
(
key
.
isString
(
)
)
{
return
QuoteString
(
cx
key
.
toString
(
)
)
;
}
if
(
key
.
isInt
(
)
)
{
Int32ToCStringBuf
buf
;
size_t
length
;
const
char
*
str
=
Int32ToCString
(
&
buf
key
.
toInt
(
)
&
length
)
;
return
DuplicateString
(
cx
str
length
)
;
}
MOZ_ASSERT
(
key
.
isSymbol
(
)
)
;
return
QuoteString
(
cx
key
.
toSymbol
(
)
-
>
description
(
)
)
;
}
static
mozilla
:
:
Maybe
<
TemporalField
>
ToTemporalField
(
JSContext
*
cx
PropertyKey
property
)
{
static
constexpr
TemporalField
fieldNames
[
]
=
{
TemporalField
:
:
Year
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Day
TemporalField
:
:
Hour
TemporalField
:
:
Minute
TemporalField
:
:
Second
TemporalField
:
:
Millisecond
TemporalField
:
:
Microsecond
TemporalField
:
:
Nanosecond
TemporalField
:
:
Offset
TemporalField
:
:
Era
TemporalField
:
:
EraYear
TemporalField
:
:
TimeZone
}
;
for
(
const
auto
&
fieldName
:
fieldNames
)
{
auto
*
name
=
ToPropertyName
(
cx
fieldName
)
;
if
(
property
.
isAtom
(
name
)
)
{
return
mozilla
:
:
Some
(
fieldName
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
JSString
*
ToPrimitiveAndRequireString
(
JSContext
*
cx
Handle
<
Value
>
value
)
{
Rooted
<
Value
>
primitive
(
cx
value
)
;
if
(
!
ToPrimitive
(
cx
JSTYPE_STRING
&
primitive
)
)
{
return
nullptr
;
}
if
(
!
primitive
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
primitive
nullptr
"
not
a
string
"
)
;
return
nullptr
;
}
return
primitive
.
toString
(
)
;
}
static
Value
TemporalFieldDefaultValue
(
TemporalField
field
)
{
switch
(
field
)
{
case
TemporalField
:
:
Year
:
case
TemporalField
:
:
Month
:
case
TemporalField
:
:
MonthCode
:
case
TemporalField
:
:
Day
:
case
TemporalField
:
:
Offset
:
case
TemporalField
:
:
Era
:
case
TemporalField
:
:
EraYear
:
case
TemporalField
:
:
TimeZone
:
return
UndefinedValue
(
)
;
case
TemporalField
:
:
Hour
:
case
TemporalField
:
:
Minute
:
case
TemporalField
:
:
Second
:
case
TemporalField
:
:
Millisecond
:
case
TemporalField
:
:
Microsecond
:
case
TemporalField
:
:
Nanosecond
:
return
Int32Value
(
0
)
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
bool
TemporalFieldConvertValue
(
JSContext
*
cx
TemporalField
field
MutableHandle
<
Value
>
value
)
{
auto
*
name
=
ToCString
(
field
)
;
switch
(
field
)
{
case
TemporalField
:
:
Year
:
case
TemporalField
:
:
Hour
:
case
TemporalField
:
:
Minute
:
case
TemporalField
:
:
Second
:
case
TemporalField
:
:
Millisecond
:
case
TemporalField
:
:
Microsecond
:
case
TemporalField
:
:
Nanosecond
:
case
TemporalField
:
:
EraYear
:
{
double
num
;
if
(
!
ToIntegerWithTruncation
(
cx
value
name
&
num
)
)
{
return
false
;
}
value
.
setNumber
(
num
)
;
return
true
;
}
case
TemporalField
:
:
Month
:
case
TemporalField
:
:
Day
:
{
double
num
;
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
name
&
num
)
)
{
return
false
;
}
value
.
setNumber
(
num
)
;
return
true
;
}
case
TemporalField
:
:
MonthCode
:
case
TemporalField
:
:
Offset
:
case
TemporalField
:
:
Era
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
value
.
setString
(
str
)
;
return
true
;
}
case
TemporalField
:
:
TimeZone
:
return
true
;
}
MOZ_CRASH
(
"
invalid
temporal
field
name
"
)
;
}
static
int32_t
ComparePropertyKey
(
PropertyKey
x
PropertyKey
y
)
{
MOZ_ASSERT
(
x
.
isAtom
(
)
|
|
x
.
isInt
(
)
)
;
MOZ_ASSERT
(
y
.
isAtom
(
)
|
|
y
.
isInt
(
)
)
;
if
(
MOZ_LIKELY
(
x
.
isAtom
(
)
&
&
y
.
isAtom
(
)
)
)
{
return
CompareStrings
(
x
.
toAtom
(
)
y
.
toAtom
(
)
)
;
}
if
(
x
.
isInt
(
)
&
&
y
.
isInt
(
)
)
{
return
x
.
toInt
(
)
-
y
.
toInt
(
)
;
}
uint32_t
index
=
uint32_t
(
x
.
isInt
(
)
?
x
.
toInt
(
)
:
y
.
toInt
(
)
)
;
JSAtom
*
str
=
x
.
isAtom
(
)
?
x
.
toAtom
(
)
:
y
.
toAtom
(
)
;
char16_t
buf
[
UINT32_CHAR_BUFFER_LENGTH
]
;
mozilla
:
:
RangedPtr
<
char16_t
>
end
(
std
:
:
end
(
buf
)
buf
std
:
:
end
(
buf
)
)
;
mozilla
:
:
RangedPtr
<
char16_t
>
start
=
BackfillIndexInCharBuffer
(
index
end
)
;
int32_t
result
=
CompareChars
(
start
.
get
(
)
end
-
start
str
)
;
return
x
.
isInt
(
)
?
result
:
-
result
;
}
#
ifdef
DEBUG
static
bool
IsSorted
(
std
:
:
initializer_list
<
TemporalField
>
fieldNames
)
{
return
std
:
:
is_sorted
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
[
]
(
auto
x
auto
y
)
{
auto
*
a
=
ToCString
(
x
)
;
auto
*
b
=
ToCString
(
y
)
;
return
std
:
:
strcmp
(
a
b
)
<
0
;
}
)
;
}
static
bool
IsSorted
(
const
JS
:
:
StackGCVector
<
PropertyKey
>
&
fieldNames
)
{
return
std
:
:
is_sorted
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
[
]
(
auto
x
auto
y
)
{
return
ComparePropertyKey
(
x
y
)
<
0
;
}
)
;
}
#
endif
bool
js
:
:
temporal
:
:
PrepareTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
std
:
:
initializer_list
<
TemporalField
>
fieldNames
std
:
:
initializer_list
<
TemporalField
>
requiredFields
MutableHandle
<
TemporalFields
>
result
)
{
MOZ_ASSERT
(
IsSorted
(
fieldNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
)
=
=
fieldNames
.
end
(
)
)
;
MOZ_ASSERT
(
IsSorted
(
requiredFields
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
requiredFields
.
begin
(
)
requiredFields
.
end
(
)
)
=
=
requiredFields
.
end
(
)
)
;
Rooted
<
Value
>
value
(
cx
)
;
for
(
auto
fieldName
:
fieldNames
)
{
auto
*
property
=
ToPropertyName
(
cx
fieldName
)
;
auto
*
cstr
=
ToCString
(
fieldName
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
false
;
}
if
(
!
value
.
isUndefined
(
)
)
{
switch
(
fieldName
)
{
case
TemporalField
:
:
Year
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
year
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Month
:
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
cstr
&
result
.
month
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
MonthCode
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
monthCode
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
Day
:
if
(
!
ToPositiveIntegerWithTruncation
(
cx
value
cstr
&
result
.
day
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Hour
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
hour
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Minute
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
minute
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Second
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
second
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Millisecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
millisecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Microsecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
microsecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Nanosecond
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
nanosecond
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
Offset
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
offset
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
Era
:
{
JSString
*
str
=
ToPrimitiveAndRequireString
(
cx
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
era
(
)
.
set
(
str
)
;
break
;
}
case
TemporalField
:
:
EraYear
:
if
(
!
ToIntegerWithTruncation
(
cx
value
cstr
&
result
.
eraYear
(
)
)
)
{
return
false
;
}
break
;
case
TemporalField
:
:
TimeZone
:
result
.
timeZone
(
)
.
set
(
value
)
;
break
;
}
}
else
{
if
(
std
:
:
find
(
requiredFields
.
begin
(
)
requiredFields
.
end
(
)
fieldName
)
!
=
requiredFields
.
end
(
)
)
{
if
(
auto
chars
=
QuoteString
(
cx
cstr
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
const
TemporalFields
FallbackValues
{
}
;
switch
(
fieldName
)
{
case
TemporalField
:
:
Year
:
result
.
year
(
)
=
FallbackValues
.
year
;
break
;
case
TemporalField
:
:
Month
:
result
.
month
(
)
=
FallbackValues
.
month
;
break
;
case
TemporalField
:
:
MonthCode
:
result
.
monthCode
(
)
.
set
(
FallbackValues
.
monthCode
)
;
break
;
case
TemporalField
:
:
Day
:
result
.
day
(
)
=
FallbackValues
.
day
;
break
;
case
TemporalField
:
:
Hour
:
result
.
hour
(
)
=
FallbackValues
.
hour
;
break
;
case
TemporalField
:
:
Minute
:
result
.
minute
(
)
=
FallbackValues
.
minute
;
break
;
case
TemporalField
:
:
Second
:
result
.
second
(
)
=
FallbackValues
.
second
;
break
;
case
TemporalField
:
:
Millisecond
:
result
.
millisecond
(
)
=
FallbackValues
.
millisecond
;
break
;
case
TemporalField
:
:
Microsecond
:
result
.
microsecond
(
)
=
FallbackValues
.
microsecond
;
break
;
case
TemporalField
:
:
Nanosecond
:
result
.
nanosecond
(
)
=
FallbackValues
.
nanosecond
;
break
;
case
TemporalField
:
:
Offset
:
result
.
offset
(
)
.
set
(
FallbackValues
.
offset
)
;
break
;
case
TemporalField
:
:
Era
:
result
.
era
(
)
.
set
(
FallbackValues
.
era
)
;
break
;
case
TemporalField
:
:
EraYear
:
result
.
eraYear
(
)
=
FallbackValues
.
eraYear
;
break
;
case
TemporalField
:
:
TimeZone
:
result
.
timeZone
(
)
.
set
(
FallbackValues
.
timeZone
)
;
break
;
}
}
}
return
true
;
}
PlainObject
*
js
:
:
temporal
:
:
PrepareTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
Handle
<
JS
:
:
StackGCVector
<
PropertyKey
>
>
fieldNames
)
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsSorted
(
fieldNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
)
=
=
fieldNames
.
end
(
)
)
;
Rooted
<
Value
>
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
fieldNames
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
property
=
fieldNames
[
i
]
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
constructor
)
)
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
proto_
)
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
nullptr
;
}
if
(
auto
fieldName
=
ToTemporalField
(
cx
property
)
)
{
if
(
!
value
.
isUndefined
(
)
)
{
if
(
!
TemporalFieldConvertValue
(
cx
*
fieldName
&
value
)
)
{
return
nullptr
;
}
}
else
{
value
=
TemporalFieldDefaultValue
(
*
fieldName
)
;
}
}
if
(
!
DefineDataProperty
(
cx
result
property
value
)
)
{
return
nullptr
;
}
}
return
result
;
}
PlainObject
*
js
:
:
temporal
:
:
PrepareTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
Handle
<
JS
:
:
StackGCVector
<
PropertyKey
>
>
fieldNames
std
:
:
initializer_list
<
TemporalField
>
requiredFields
)
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsSorted
(
fieldNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
)
=
=
fieldNames
.
end
(
)
)
;
MOZ_ASSERT
(
IsSorted
(
requiredFields
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
requiredFields
.
begin
(
)
requiredFields
.
end
(
)
)
=
=
requiredFields
.
end
(
)
)
;
Rooted
<
Value
>
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
fieldNames
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
property
=
fieldNames
[
i
]
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
constructor
)
)
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
proto_
)
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
nullptr
;
}
if
(
auto
fieldName
=
ToTemporalField
(
cx
property
)
)
{
if
(
!
value
.
isUndefined
(
)
)
{
if
(
!
TemporalFieldConvertValue
(
cx
*
fieldName
&
value
)
)
{
return
nullptr
;
}
}
else
{
if
(
std
:
:
find
(
requiredFields
.
begin
(
)
requiredFields
.
end
(
)
*
fieldName
)
!
=
requiredFields
.
end
(
)
)
{
if
(
auto
chars
=
QuoteString
(
cx
property
.
toString
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
chars
.
get
(
)
)
;
}
return
nullptr
;
}
value
=
TemporalFieldDefaultValue
(
*
fieldName
)
;
}
}
if
(
!
DefineDataProperty
(
cx
result
property
value
)
)
{
return
nullptr
;
}
}
return
result
;
}
PlainObject
*
js
:
:
temporal
:
:
PreparePartialTemporalFields
(
JSContext
*
cx
Handle
<
JSObject
*
>
fields
Handle
<
JS
:
:
StackGCVector
<
PropertyKey
>
>
fieldNames
)
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
bool
any
=
false
;
MOZ_ASSERT
(
IsSorted
(
fieldNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
)
=
=
fieldNames
.
end
(
)
)
;
Rooted
<
Value
>
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
fieldNames
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
property
=
fieldNames
[
i
]
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
constructor
)
)
;
MOZ_ASSERT
(
property
!
=
NameToId
(
cx
-
>
names
(
)
.
proto_
)
)
;
if
(
!
GetProperty
(
cx
fields
fields
property
&
value
)
)
{
return
nullptr
;
}
if
(
!
value
.
isUndefined
(
)
)
{
any
=
true
;
if
(
auto
fieldName
=
ToTemporalField
(
cx
property
)
)
{
if
(
!
TemporalFieldConvertValue
(
cx
*
fieldName
&
value
)
)
{
return
nullptr
;
}
}
if
(
!
DefineDataProperty
(
cx
result
property
value
)
)
{
return
nullptr
;
}
}
else
{
}
}
if
(
!
any
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_TEMPORAL_FIELDS
)
;
return
nullptr
;
}
return
result
;
}
bool
js
:
:
temporal
:
:
ConcatTemporalFieldNames
(
const
JS
:
:
StackGCVector
<
PropertyKey
>
&
receiverFieldNames
const
JS
:
:
StackGCVector
<
PropertyKey
>
&
inputFieldNames
JS
:
:
StackGCVector
<
PropertyKey
>
&
concatenatedFieldNames
)
{
MOZ_ASSERT
(
IsSorted
(
receiverFieldNames
)
)
;
MOZ_ASSERT
(
IsSorted
(
inputFieldNames
)
)
;
MOZ_ASSERT
(
concatenatedFieldNames
.
empty
(
)
)
;
auto
appendUnique
=
[
&
]
(
auto
key
)
{
if
(
concatenatedFieldNames
.
empty
(
)
|
|
concatenatedFieldNames
.
back
(
)
!
=
key
)
{
return
concatenatedFieldNames
.
append
(
key
)
;
}
return
true
;
}
;
size_t
i
=
0
;
size_t
j
=
0
;
while
(
i
<
receiverFieldNames
.
length
(
)
&
&
j
<
inputFieldNames
.
length
(
)
)
{
auto
x
=
receiverFieldNames
[
i
]
;
auto
y
=
inputFieldNames
[
j
]
;
PropertyKey
z
;
if
(
ComparePropertyKey
(
x
y
)
<
=
0
)
{
z
=
x
;
i
+
+
;
}
else
{
z
=
y
;
j
+
+
;
}
if
(
!
appendUnique
(
z
)
)
{
return
false
;
}
}
while
(
i
<
receiverFieldNames
.
length
(
)
)
{
if
(
!
appendUnique
(
receiverFieldNames
[
i
+
+
]
)
)
{
return
false
;
}
}
while
(
j
<
inputFieldNames
.
length
(
)
)
{
if
(
!
appendUnique
(
inputFieldNames
[
j
+
+
]
)
)
{
return
false
;
}
}
return
true
;
}
static
auto
*
LowerBound
(
PropertyKey
*
begin
PropertyKey
*
end
PropertyKey
key
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
return
std
:
:
lower_bound
(
begin
end
key
[
]
(
auto
x
auto
y
)
{
return
ComparePropertyKey
(
x
y
)
<
0
;
}
)
;
}
[
[
nodiscard
]
]
static
bool
AppendSorted
(
JSContext
*
cx
JS
:
:
StackGCVector
<
PropertyKey
>
&
fieldNames
PropertyKey
additionalName
)
{
auto
*
p
=
LowerBound
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
additionalName
)
;
if
(
p
!
=
fieldNames
.
end
(
)
&
&
*
p
=
=
additionalName
)
{
if
(
auto
chars
=
QuoteString
(
cx
additionalName
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DUPLICATE_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
size_t
index
=
std
:
:
distance
(
fieldNames
.
begin
(
)
p
)
;
if
(
!
fieldNames
.
growBy
(
1
)
)
{
return
false
;
}
std
:
:
copy_backward
(
fieldNames
.
begin
(
)
+
index
fieldNames
.
end
(
)
-
1
fieldNames
.
end
(
)
)
;
fieldNames
[
index
]
=
additionalName
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
AppendSorted
(
JSContext
*
cx
JS
:
:
StackGCVector
<
PropertyKey
>
&
fieldNames
PropertyKey
additionalNameOne
PropertyKey
additionalNameTwo
)
{
MOZ_ASSERT
(
ComparePropertyKey
(
additionalNameOne
additionalNameTwo
)
<
0
)
;
auto
*
p
=
LowerBound
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
additionalNameOne
)
;
auto
*
q
=
LowerBound
(
p
fieldNames
.
end
(
)
additionalNameTwo
)
;
if
(
p
!
=
fieldNames
.
end
(
)
&
&
*
p
=
=
additionalNameOne
)
{
if
(
auto
chars
=
QuoteString
(
cx
additionalNameOne
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DUPLICATE_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
if
(
q
!
=
fieldNames
.
end
(
)
&
&
*
q
=
=
additionalNameTwo
)
{
if
(
auto
chars
=
QuoteString
(
cx
additionalNameTwo
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DUPLICATE_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
size_t
indexOne
=
std
:
:
distance
(
fieldNames
.
begin
(
)
p
)
;
size_t
indexTwo
=
std
:
:
distance
(
fieldNames
.
begin
(
)
q
)
;
if
(
!
fieldNames
.
growBy
(
2
)
)
{
return
false
;
}
std
:
:
copy_backward
(
fieldNames
.
begin
(
)
+
indexTwo
fieldNames
.
end
(
)
-
2
fieldNames
.
end
(
)
)
;
std
:
:
copy_backward
(
fieldNames
.
begin
(
)
+
indexOne
fieldNames
.
begin
(
)
+
indexTwo
fieldNames
.
begin
(
)
+
indexTwo
+
1
)
;
fieldNames
[
indexOne
]
=
additionalNameOne
;
fieldNames
[
indexTwo
+
1
]
=
additionalNameTwo
;
return
true
;
}
bool
js
:
:
temporal
:
:
AppendSorted
(
JSContext
*
cx
JS
:
:
StackGCVector
<
PropertyKey
>
&
fieldNames
std
:
:
initializer_list
<
TemporalField
>
additionalNames
)
{
MOZ_ASSERT
(
IsSorted
(
fieldNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
fieldNames
.
begin
(
)
fieldNames
.
end
(
)
)
=
=
fieldNames
.
end
(
)
)
;
MOZ_ASSERT
(
additionalNames
.
size
(
)
>
0
)
;
MOZ_ASSERT
(
IsSorted
(
additionalNames
)
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
additionalNames
.
begin
(
)
additionalNames
.
end
(
)
)
=
=
additionalNames
.
end
(
)
)
;
if
(
additionalNames
.
size
(
)
=
=
1
)
{
auto
*
it
=
additionalNames
.
begin
(
)
;
auto
name
=
NameToId
(
ToPropertyName
(
cx
*
it
)
)
;
return
:
:
AppendSorted
(
cx
fieldNames
name
)
;
}
if
(
additionalNames
.
size
(
)
=
=
2
)
{
auto
*
it
=
additionalNames
.
begin
(
)
;
auto
one
=
NameToId
(
ToPropertyName
(
cx
*
it
)
)
;
auto
two
=
NameToId
(
ToPropertyName
(
cx
*
std
:
:
next
(
it
)
)
)
;
return
:
:
AppendSorted
(
cx
fieldNames
one
two
)
;
}
if
(
!
fieldNames
.
growBy
(
additionalNames
.
size
(
)
)
)
{
return
false
;
}
auto
*
left
=
std
:
:
prev
(
fieldNames
.
end
(
)
additionalNames
.
size
(
)
)
;
auto
*
right
=
additionalNames
.
end
(
)
;
auto
*
out
=
fieldNames
.
end
(
)
;
while
(
left
!
=
fieldNames
.
begin
(
)
&
&
right
!
=
additionalNames
.
begin
(
)
)
{
MOZ_ASSERT
(
out
!
=
fieldNames
.
begin
(
)
)
;
auto
x
=
*
std
:
:
prev
(
left
)
;
auto
y
=
NameToId
(
ToPropertyName
(
cx
*
std
:
:
prev
(
right
)
)
)
;
int32_t
r
=
ComparePropertyKey
(
x
y
)
;
if
(
r
=
=
0
)
{
if
(
auto
chars
=
QuoteString
(
cx
x
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DUPLICATE_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
PropertyKey
z
;
if
(
r
>
0
)
{
z
=
x
;
left
-
-
;
}
else
{
z
=
y
;
right
-
-
;
}
*
-
-
out
=
z
;
}
if
(
left
=
=
out
)
{
MOZ_ASSERT
(
right
=
=
additionalNames
.
begin
(
)
)
;
return
true
;
}
while
(
left
!
=
fieldNames
.
begin
(
)
)
{
MOZ_ASSERT
(
out
!
=
fieldNames
.
begin
(
)
)
;
*
-
-
out
=
*
-
-
left
;
}
while
(
right
!
=
additionalNames
.
begin
(
)
)
{
MOZ_ASSERT
(
out
!
=
fieldNames
.
begin
(
)
)
;
*
-
-
out
=
NameToId
(
ToPropertyName
(
cx
*
-
-
right
)
)
;
}
MOZ_ASSERT
(
out
=
=
fieldNames
.
begin
(
)
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
SortTemporalFieldNames
(
JSContext
*
cx
JS
:
:
StackGCVector
<
PropertyKey
>
&
fieldNames
)
{
JS
:
:
StackGCVector
<
PropertyKey
>
scratch
(
cx
)
;
if
(
!
scratch
.
resize
(
fieldNames
.
length
(
)
)
)
{
return
false
;
}
auto
comparator
=
[
]
(
const
auto
&
x
const
auto
&
y
bool
*
lessOrEqual
)
{
*
lessOrEqual
=
ComparePropertyKey
(
x
y
)
<
=
0
;
return
true
;
}
;
MOZ_ALWAYS_TRUE
(
MergeSort
(
fieldNames
.
begin
(
)
fieldNames
.
length
(
)
scratch
.
begin
(
)
comparator
)
)
;
for
(
size_t
i
=
0
;
i
<
fieldNames
.
length
(
)
;
i
+
+
)
{
auto
property
=
fieldNames
[
i
]
;
if
(
property
=
=
NameToId
(
cx
-
>
names
(
)
.
constructor
)
|
|
property
=
=
NameToId
(
cx
-
>
names
(
)
.
proto_
)
)
{
if
(
auto
chars
=
QuoteString
(
cx
property
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
if
(
i
>
0
&
&
property
=
=
fieldNames
[
i
-
1
]
)
{
if
(
auto
chars
=
QuoteString
(
cx
property
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DUPLICATE_PROPERTY
chars
.
get
(
)
)
;
}
return
false
;
}
}
return
true
;
}
