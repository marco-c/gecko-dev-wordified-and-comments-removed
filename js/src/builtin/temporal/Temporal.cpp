#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
utility
>
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainDateTime
.
h
"
#
include
"
builtin
/
temporal
/
PlainMonthDay
.
h
"
#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
builtin
/
temporal
/
PlainYearMonth
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
String
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
static
bool
GetStringOption
(
JSContext
*
cx
Handle
<
JSObject
*
>
options
Handle
<
PropertyName
*
>
property
MutableHandle
<
JSString
*
>
string
)
{
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
property
&
value
)
)
{
return
false
;
}
if
(
value
.
isUndefined
(
)
)
{
return
true
;
}
string
.
set
(
JS
:
:
ToString
(
cx
value
)
)
;
if
(
!
string
)
{
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ToCalendarNameOption
(
JSContext
*
cx
Handle
<
JSObject
*
>
options
CalendarOption
*
result
)
{
Rooted
<
JSString
*
>
calendarName
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
calendarName
&
calendarName
)
)
{
return
false
;
}
if
(
!
calendarName
)
{
return
true
;
}
JSLinearString
*
linear
=
calendarName
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
if
(
StringEqualsLiteral
(
linear
"
auto
"
)
)
{
*
result
=
CalendarOption
:
:
Auto
;
}
else
if
(
StringEqualsLiteral
(
linear
"
always
"
)
)
{
*
result
=
CalendarOption
:
:
Always
;
}
else
if
(
StringEqualsLiteral
(
linear
"
never
"
)
)
{
*
result
=
CalendarOption
:
:
Never
;
}
else
if
(
StringEqualsLiteral
(
linear
"
critical
"
)
)
{
*
result
=
CalendarOption
:
:
Critical
;
}
else
{
if
(
auto
chars
=
QuoteString
(
cx
linear
'
"
'
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
calendarName
"
chars
.
get
(
)
)
;
}
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ToTemporalOverflow
(
JSContext
*
cx
Handle
<
JSObject
*
>
options
TemporalOverflow
*
result
)
{
Rooted
<
JSString
*
>
overflow
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
overflow
&
overflow
)
)
{
return
false
;
}
if
(
!
overflow
)
{
return
true
;
}
JSLinearString
*
linear
=
overflow
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
if
(
StringEqualsLiteral
(
linear
"
constrain
"
)
)
{
*
result
=
TemporalOverflow
:
:
Constrain
;
}
else
if
(
StringEqualsLiteral
(
linear
"
reject
"
)
)
{
*
result
=
TemporalOverflow
:
:
Reject
;
}
else
{
if
(
auto
chars
=
QuoteString
(
cx
linear
'
"
'
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
overflow
"
chars
.
get
(
)
)
;
}
return
false
;
}
return
true
;
}
template
<
typename
T
typename
.
.
.
Ts
>
static
JSObject
*
MaybeUnwrapIf
(
JSObject
*
object
)
{
if
(
auto
*
unwrapped
=
object
-
>
maybeUnwrapIf
<
T
>
(
)
)
{
return
unwrapped
;
}
if
constexpr
(
sizeof
.
.
.
(
Ts
)
>
0
)
{
return
MaybeUnwrapIf
<
Ts
.
.
.
>
(
object
)
;
}
return
nullptr
;
}
bool
js
:
:
temporal
:
:
RejectObjectWithCalendarOrTimeZone
(
JSContext
*
cx
Handle
<
JSObject
*
>
object
)
{
if
(
auto
*
unwrapped
=
MaybeUnwrapIf
<
PlainDateObject
PlainDateTimeObject
PlainMonthDayObject
PlainTimeObject
PlainYearMonthObject
ZonedDateTimeObject
>
(
object
)
)
{
Rooted
<
Value
>
value
(
cx
ObjectValue
(
*
object
)
)
;
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
value
nullptr
unwrapped
-
>
getClass
(
)
-
>
name
)
;
return
false
;
}
Rooted
<
Value
>
property
(
cx
)
;
if
(
!
GetProperty
(
cx
object
object
cx
-
>
names
(
)
.
calendar
&
property
)
)
{
return
false
;
}
if
(
!
property
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_UNEXPECTED_PROPERTY
"
calendar
"
)
;
return
false
;
}
if
(
!
GetProperty
(
cx
object
object
cx
-
>
names
(
)
.
timeZone
&
property
)
)
{
return
false
;
}
if
(
!
property
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_UNEXPECTED_PROPERTY
"
timeZone
"
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ToPositiveIntegerWithTruncation
(
JSContext
*
cx
Handle
<
Value
>
value
const
char
*
name
double
*
result
)
{
double
number
;
if
(
!
ToIntegerWithTruncation
(
cx
value
name
&
number
)
)
{
return
false
;
}
if
(
number
<
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_NUMBER
name
)
;
return
false
;
}
*
result
=
number
;
return
true
;
}
bool
js
:
:
temporal
:
:
ToIntegerWithTruncation
(
JSContext
*
cx
Handle
<
Value
>
value
const
char
*
name
double
*
result
)
{
double
number
;
if
(
!
JS
:
:
ToNumber
(
cx
value
&
number
)
)
{
return
false
;
}
if
(
!
std
:
:
isfinite
(
number
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_INTEGER
name
)
;
return
false
;
}
*
result
=
std
:
:
trunc
(
number
)
+
(
+
0
.
0
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
GetMethod
(
JSContext
*
cx
Handle
<
JSObject
*
>
object
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
!
GetProperty
(
cx
object
object
name
result
)
)
{
return
false
;
}
if
(
result
.
isNullOrUndefined
(
)
)
{
return
true
;
}
if
(
!
IsCallable
(
result
)
)
{
if
(
auto
chars
=
StringToNewUTF8CharsZ
(
cx
*
name
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_PROPERTY_NOT_CALLABLE
chars
.
get
(
)
)
;
}
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
GetMethodForCall
(
JSContext
*
cx
Handle
<
JSObject
*
>
object
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
!
GetProperty
(
cx
object
object
name
result
)
)
{
return
false
;
}
if
(
!
IsCallable
(
result
)
)
{
if
(
auto
chars
=
StringToNewUTF8CharsZ
(
cx
*
name
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_PROPERTY_NOT_CALLABLE
chars
.
get
(
)
)
;
}
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
CopyDataProperties
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
{
if
(
source
-
>
is
<
NativeObject
>
(
)
)
{
bool
optimized
=
false
;
if
(
!
CopyDataPropertiesNative
(
cx
target
source
.
as
<
NativeObject
>
(
)
nullptr
&
optimized
)
)
{
return
false
;
}
if
(
optimized
)
{
return
true
;
}
}
JS
:
:
RootedVector
<
PropertyKey
>
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
source
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
&
keys
)
)
{
return
false
;
}
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
Rooted
<
Value
>
propValue
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
key
=
keys
[
i
]
;
if
(
!
GetOwnPropertyDescriptor
(
cx
source
key
&
desc
)
)
{
return
false
;
}
if
(
desc
.
isNothing
(
)
|
|
!
desc
-
>
enumerable
(
)
)
{
continue
;
}
if
(
!
GetProperty
(
cx
source
source
key
&
propValue
)
)
{
return
false
;
}
if
(
!
DefineDataProperty
(
cx
target
key
propValue
)
)
{
return
false
;
}
}
return
true
;
}
bool
js
:
:
temporal
:
:
CopyDataPropertiesIgnoreUndefined
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
{
JS
:
:
RootedVector
<
PropertyKey
>
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
source
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
&
keys
)
)
{
return
false
;
}
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
Rooted
<
Value
>
propValue
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
key
=
keys
[
i
]
;
if
(
!
GetOwnPropertyDescriptor
(
cx
source
key
&
desc
)
)
{
return
false
;
}
if
(
desc
.
isNothing
(
)
|
|
!
desc
-
>
enumerable
(
)
)
{
continue
;
}
if
(
!
GetProperty
(
cx
source
source
key
&
propValue
)
)
{
return
false
;
}
if
(
propValue
.
isUndefined
(
)
)
{
continue
;
}
if
(
!
DefineDataProperty
(
cx
target
key
propValue
)
)
{
return
false
;
}
}
return
true
;
}
static
JSObject
*
CreateTemporalObject
(
JSContext
*
cx
JSProtoKey
key
)
{
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getObjectPrototype
(
)
)
;
return
NewTenuredObjectWithGivenProto
<
TemporalObject
>
(
cx
proto
)
;
}
static
bool
TemporalClassFinish
(
JSContext
*
cx
Handle
<
JSObject
*
>
temporal
Handle
<
JSObject
*
>
proto
)
{
Rooted
<
PropertyKey
>
ctorId
(
cx
)
;
Rooted
<
Value
>
ctorValue
(
cx
)
;
auto
defineProperty
=
[
&
]
(
JSProtoKey
protoKey
Handle
<
PropertyName
*
>
name
)
{
JSObject
*
ctor
=
GlobalObject
:
:
getOrCreateConstructor
(
cx
protoKey
)
;
if
(
!
ctor
)
{
return
false
;
}
ctorId
=
NameToId
(
name
)
;
ctorValue
.
setObject
(
*
ctor
)
;
return
DefineDataProperty
(
cx
temporal
ctorId
ctorValue
0
)
;
}
;
for
(
const
auto
&
protoKey
:
{
JSProto_Calendar
JSProto_Duration
JSProto_Instant
JSProto_PlainDate
JSProto_PlainDateTime
JSProto_PlainMonthDay
JSProto_PlainTime
JSProto_PlainYearMonth
JSProto_TimeZone
JSProto_ZonedDateTime
}
)
{
if
(
!
defineProperty
(
protoKey
ClassName
(
protoKey
cx
)
)
)
{
return
false
;
}
}
if
(
!
defineProperty
(
JSProto_TemporalNow
cx
-
>
names
(
)
.
Now
)
)
{
return
false
;
}
return
true
;
}
const
JSClass
TemporalObject
:
:
class_
=
{
"
Temporal
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Temporal
)
JS_NULL_CLASS_OPS
&
TemporalObject
:
:
classSpec_
}
;
static
const
JSPropertySpec
Temporal_properties
[
]
=
{
JS_PS_END
}
;
const
ClassSpec
TemporalObject
:
:
classSpec_
=
{
CreateTemporalObject
nullptr
nullptr
Temporal_properties
nullptr
nullptr
TemporalClassFinish
}
;
