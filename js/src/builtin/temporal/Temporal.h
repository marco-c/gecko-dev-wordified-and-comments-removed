#
ifndef
builtin_temporal_Temporal_h
#
define
builtin_temporal_Temporal_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
struct
ClassSpec
;
class
PlainObject
;
class
PropertyName
;
class
JSStringBuilder
;
}
namespace
js
:
:
temporal
{
class
TemporalObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
private
:
static
const
ClassSpec
classSpec_
;
}
;
struct
Instant
;
struct
PlainTime
;
class
Increment
final
{
uint32_t
value_
;
public
:
constexpr
explicit
Increment
(
uint32_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
1
<
=
value
&
&
value
<
=
1
'
000
'
000
'
000
)
;
}
static
constexpr
auto
min
(
)
{
return
Increment
{
1
}
;
}
static
constexpr
auto
max
(
)
{
return
Increment
{
1
'
000
'
000
'
000
}
;
}
uint32_t
value
(
)
const
{
return
value_
;
}
bool
operator
=
=
(
const
Increment
&
other
)
const
{
return
value_
=
=
other
.
value_
;
}
bool
operator
<
(
const
Increment
&
other
)
const
{
return
value_
<
other
.
value_
;
}
bool
operator
!
=
(
const
Increment
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
operator
>
(
const
Increment
&
other
)
const
{
return
other
<
*
this
;
}
bool
operator
<
=
(
const
Increment
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
bool
operator
>
=
(
const
Increment
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
}
;
bool
ToTemporalRoundingIncrement
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
Increment
*
increment
)
;
bool
ValidateTemporalRoundingIncrement
(
JSContext
*
cx
Increment
increment
int64_t
dividend
bool
inclusive
)
;
inline
bool
ValidateTemporalRoundingIncrement
(
JSContext
*
cx
Increment
increment
Increment
dividend
bool
inclusive
)
{
return
ValidateTemporalRoundingIncrement
(
cx
increment
dividend
.
value
(
)
inclusive
)
;
}
constexpr
Increment
MaximumTemporalDurationRoundingIncrement
(
TemporalUnit
unit
)
{
MOZ_ASSERT
(
unit
>
TemporalUnit
:
:
Day
)
;
if
(
unit
=
=
TemporalUnit
:
:
Hour
)
{
return
Increment
{
24
}
;
}
if
(
unit
<
=
TemporalUnit
:
:
Second
)
{
return
Increment
{
60
}
;
}
return
Increment
{
1000
}
;
}
PropertyName
*
TemporalUnitToString
(
JSContext
*
cx
TemporalUnit
unit
)
;
enum
class
TemporalUnitGroup
{
Date
Time
DateTime
DayTime
}
;
enum
class
TemporalUnitKey
{
SmallestUnit
LargestUnit
Unit
}
;
bool
GetTemporalUnit
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalUnitKey
key
TemporalUnitGroup
unitGroup
TemporalUnit
*
unit
)
;
bool
GetTemporalUnit
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
value
TemporalUnitKey
key
TemporalUnitGroup
unitGroup
TemporalUnit
*
unit
)
;
bool
ToTemporalRoundingMode
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalRoundingMode
*
mode
)
;
enum
class
CalendarOption
{
Auto
Always
Never
Critical
}
;
bool
ToCalendarNameOption
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
CalendarOption
*
result
)
;
class
Precision
final
{
int8_t
value_
;
enum
class
Tag
{
}
;
constexpr
Precision
(
int8_t
value
Tag
)
:
value_
(
value
)
{
}
public
:
constexpr
explicit
Precision
(
uint8_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
value
<
10
)
;
}
uint8_t
value
(
)
const
{
MOZ_ASSERT
(
value_
>
=
0
"
auto
and
minute
precision
don
'
t
have
a
value
"
)
;
return
uint8_t
(
value_
)
;
}
bool
isAuto
(
)
const
{
return
value_
=
=
-
1
;
}
bool
isMinute
(
)
const
{
return
value_
=
=
-
2
;
}
static
constexpr
Precision
Auto
(
)
{
return
{
-
1
Tag
{
}
}
;
}
static
constexpr
Precision
Minute
(
)
{
return
{
-
2
Tag
{
}
}
;
}
}
;
bool
ToFractionalSecondDigits
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
Precision
*
precision
)
;
struct
SecondsStringPrecision
final
{
Precision
precision
=
Precision
{
0
}
;
TemporalUnit
unit
=
TemporalUnit
:
:
Auto
;
Increment
increment
=
Increment
{
1
}
;
}
;
SecondsStringPrecision
ToSecondsStringPrecision
(
TemporalUnit
smallestUnit
Precision
fractionalDigitCount
)
;
void
FormatSecondsStringPart
(
JSStringBuilder
&
result
const
PlainTime
&
time
Precision
precision
)
;
enum
class
TemporalOverflow
{
Constrain
Reject
}
;
bool
ToTemporalOverflow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalOverflow
*
result
)
;
bool
RejectObjectWithCalendarOrTimeZone
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
)
;
bool
ToPositiveIntegerWithTruncation
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
const
char
*
name
double
*
result
)
;
bool
ToIntegerWithTruncation
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
const
char
*
name
double
*
result
)
;
bool
GetMethod
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
JS
:
:
Handle
<
PropertyName
*
>
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
bool
GetMethodForCall
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
JS
:
:
Handle
<
PropertyName
*
>
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
bool
CopyDataProperties
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
;
bool
CopyDataPropertiesIgnoreUndefined
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
;
}
#
endif
