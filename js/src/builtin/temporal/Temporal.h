#
ifndef
builtin_temporal_Temporal_h
#
define
builtin_temporal_Temporal_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
struct
ClassSpec
;
class
PlainObject
;
class
PropertyName
;
class
JSStringBuilder
;
}
namespace
js
:
:
temporal
{
class
TemporalObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
private
:
static
const
ClassSpec
classSpec_
;
}
;
struct
Instant
;
struct
PlainTime
;
class
Increment
final
{
uint32_t
value_
;
public
:
constexpr
explicit
Increment
(
uint32_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
1
<
=
value
&
&
value
<
=
1
'
000
'
000
'
000
)
;
}
static
constexpr
auto
min
(
)
{
return
Increment
{
1
}
;
}
static
constexpr
auto
max
(
)
{
return
Increment
{
1
'
000
'
000
'
000
}
;
}
uint32_t
value
(
)
const
{
return
value_
;
}
bool
operator
=
=
(
const
Increment
&
other
)
const
{
return
value_
=
=
other
.
value_
;
}
bool
operator
<
(
const
Increment
&
other
)
const
{
return
value_
<
other
.
value_
;
}
bool
operator
!
=
(
const
Increment
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
operator
>
(
const
Increment
&
other
)
const
{
return
other
<
*
this
;
}
bool
operator
<
=
(
const
Increment
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
bool
operator
>
=
(
const
Increment
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
}
;
bool
ToTemporalRoundingIncrement
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
Increment
*
increment
)
;
bool
ValidateTemporalRoundingIncrement
(
JSContext
*
cx
Increment
increment
int64_t
dividend
bool
inclusive
)
;
inline
bool
ValidateTemporalRoundingIncrement
(
JSContext
*
cx
Increment
increment
Increment
dividend
bool
inclusive
)
{
return
ValidateTemporalRoundingIncrement
(
cx
increment
dividend
.
value
(
)
inclusive
)
;
}
constexpr
Increment
MaximumTemporalDurationRoundingIncrement
(
TemporalUnit
unit
)
{
MOZ_ASSERT
(
unit
>
TemporalUnit
:
:
Day
)
;
if
(
unit
=
=
TemporalUnit
:
:
Hour
)
{
return
Increment
{
24
}
;
}
if
(
unit
<
=
TemporalUnit
:
:
Second
)
{
return
Increment
{
60
}
;
}
return
Increment
{
1000
}
;
}
PropertyName
*
TemporalUnitToString
(
JSContext
*
cx
TemporalUnit
unit
)
;
enum
class
TemporalUnitGroup
{
Date
Time
DateTime
DayTime
}
;
enum
class
TemporalUnitKey
{
SmallestUnit
LargestUnit
Unit
}
;
bool
GetTemporalUnit
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalUnitKey
key
TemporalUnitGroup
unitGroup
TemporalUnit
*
unit
)
;
bool
GetTemporalUnit
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
value
TemporalUnitKey
key
TemporalUnitGroup
unitGroup
TemporalUnit
*
unit
)
;
bool
ToTemporalRoundingMode
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalRoundingMode
*
mode
)
;
bool
RoundNumberToIncrement
(
JSContext
*
cx
const
Instant
&
x
int64_t
increment
TemporalRoundingMode
roundingMode
Instant
*
result
)
;
bool
RoundNumberToIncrement
(
JSContext
*
cx
int64_t
numerator
TemporalUnit
unit
Increment
increment
TemporalRoundingMode
roundingMode
double
*
result
)
;
bool
RoundNumberToIncrement
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
BigInt
*
>
numerator
TemporalUnit
unit
Increment
increment
TemporalRoundingMode
roundingMode
double
*
result
)
;
bool
RoundNumberToIncrement
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
BigInt
*
>
numerator
JS
:
:
Handle
<
JS
:
:
BigInt
*
>
denominator
Increment
increment
TemporalRoundingMode
roundingMode
double
*
result
)
;
enum
class
CalendarOption
{
Auto
Always
Never
Critical
}
;
bool
ToCalendarNameOption
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
CalendarOption
*
result
)
;
class
Precision
final
{
int8_t
value_
;
enum
class
Tag
{
}
;
constexpr
Precision
(
int8_t
value
Tag
)
:
value_
(
value
)
{
}
public
:
constexpr
explicit
Precision
(
uint8_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
value
<
10
)
;
}
uint8_t
value
(
)
const
{
MOZ_ASSERT
(
value_
>
=
0
"
auto
and
minute
precision
don
'
t
have
a
value
"
)
;
return
uint8_t
(
value_
)
;
}
bool
isAuto
(
)
const
{
return
value_
=
=
-
1
;
}
bool
isMinute
(
)
const
{
return
value_
=
=
-
2
;
}
static
constexpr
Precision
Auto
(
)
{
return
{
-
1
Tag
{
}
}
;
}
static
constexpr
Precision
Minute
(
)
{
return
{
-
2
Tag
{
}
}
;
}
}
;
bool
ToFractionalSecondDigits
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
Precision
*
precision
)
;
struct
SecondsStringPrecision
final
{
Precision
precision
=
Precision
{
0
}
;
TemporalUnit
unit
=
TemporalUnit
:
:
Auto
;
Increment
increment
=
Increment
{
1
}
;
}
;
SecondsStringPrecision
ToSecondsStringPrecision
(
TemporalUnit
smallestUnit
Precision
fractionalDigitCount
)
;
void
FormatSecondsStringPart
(
JSStringBuilder
&
result
const
PlainTime
&
time
Precision
precision
)
;
enum
class
TemporalOverflow
{
Constrain
Reject
}
;
bool
ToTemporalOverflow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalOverflow
*
result
)
;
enum
class
TemporalDisambiguation
{
Compatible
Earlier
Later
Reject
}
;
bool
ToTemporalDisambiguation
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalDisambiguation
*
disambiguation
)
;
enum
class
TemporalOffset
{
Prefer
Use
Ignore
Reject
}
;
bool
ToTemporalOffset
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TemporalOffset
*
offset
)
;
enum
class
TimeZoneNameOption
{
Auto
Never
Critical
}
;
bool
ToTimeZoneNameOption
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
TimeZoneNameOption
*
result
)
;
enum
class
ShowOffsetOption
{
Auto
Never
}
;
bool
ToShowOffsetOption
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
options
ShowOffsetOption
*
result
)
;
bool
RejectObjectWithCalendarOrTimeZone
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
)
;
bool
ToPositiveIntegerWithTruncation
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
const
char
*
name
double
*
result
)
;
bool
ToIntegerWithTruncation
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
const
char
*
name
double
*
result
)
;
bool
GetMethod
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
JS
:
:
Handle
<
PropertyName
*
>
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
bool
GetMethodForCall
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
object
JS
:
:
Handle
<
PropertyName
*
>
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
bool
CopyDataProperties
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
;
bool
CopyDataPropertiesIgnoreUndefined
(
JSContext
*
cx
JS
:
:
Handle
<
PlainObject
*
>
target
JS
:
:
Handle
<
JSObject
*
>
source
)
;
enum
class
TemporalDifference
{
Since
Until
}
;
inline
const
char
*
ToName
(
TemporalDifference
difference
)
{
return
difference
=
=
TemporalDifference
:
:
Since
?
"
since
"
:
"
until
"
;
}
struct
DifferenceSettings
final
{
TemporalUnit
smallestUnit
=
TemporalUnit
:
:
Auto
;
TemporalUnit
largestUnit
=
TemporalUnit
:
:
Auto
;
TemporalRoundingMode
roundingMode
=
TemporalRoundingMode
:
:
Trunc
;
Increment
roundingIncrement
=
Increment
{
1
}
;
}
;
bool
GetDifferenceSettings
(
JSContext
*
cx
TemporalDifference
operation
JS
:
:
Handle
<
JSObject
*
>
options
TemporalUnitGroup
unitGroup
TemporalUnit
smallestAllowedUnit
TemporalUnit
fallbackSmallestUnit
TemporalUnit
smallestLargestDefaultUnit
DifferenceSettings
*
result
)
;
inline
bool
GetDifferenceSettings
(
JSContext
*
cx
TemporalDifference
operation
JS
:
:
Handle
<
JSObject
*
>
options
TemporalUnitGroup
unitGroup
TemporalUnit
fallbackSmallestUnit
TemporalUnit
smallestLargestDefaultUnit
DifferenceSettings
*
result
)
{
return
GetDifferenceSettings
(
cx
operation
options
unitGroup
TemporalUnit
:
:
Nanosecond
fallbackSmallestUnit
smallestLargestDefaultUnit
result
)
;
}
}
#
endif
