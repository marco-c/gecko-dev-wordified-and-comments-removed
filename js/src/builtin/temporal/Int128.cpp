#
include
"
builtin
/
temporal
/
Int128
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
stdint
.
h
>
using
namespace
js
;
using
namespace
js
:
:
temporal
;
double
Uint128
:
:
toDouble
(
const
Uint128
&
x
bool
negative
)
{
using
Double
=
mozilla
:
:
FloatingPoint
<
double
>
;
constexpr
uint8_t
ExponentShift
=
Double
:
:
kExponentShift
;
constexpr
uint8_t
SignificandWidth
=
Double
:
:
kSignificandWidth
;
constexpr
unsigned
ExponentBias
=
Double
:
:
kExponentBias
;
constexpr
uint8_t
SignShift
=
Double
:
:
kExponentWidth
+
SignificandWidth
;
constexpr
uint64_t
MaxIntegralPrecisionDouble
=
uint64_t
(
1
)
<
<
(
SignificandWidth
+
1
)
;
constexpr
uint8_t
BitsNeededForShiftedMantissa
=
SignificandWidth
+
1
;
uint64_t
shiftedMantissa
=
0
;
uint64_t
exponent
=
0
;
uint64_t
bitsBeneathExtraBitInDigitContainingExtraBit
=
0
;
if
(
x
.
high
=
=
0
)
{
uint64_t
msd
=
x
.
low
;
if
(
msd
<
=
MaxIntegralPrecisionDouble
)
{
return
negative
?
-
double
(
msd
)
:
+
double
(
msd
)
;
}
const
uint8_t
msdLeadingZeroes
=
mozilla
:
:
CountLeadingZeroes64
(
msd
)
;
MOZ_ASSERT
(
0
<
=
msdLeadingZeroes
&
&
msdLeadingZeroes
<
=
10
"
leading
zeroes
is
at
most
10
when
the
fast
path
isn
'
t
taken
"
)
;
exponent
=
64
-
msdLeadingZeroes
-
1
;
const
uint8_t
msdIgnoredBits
=
msdLeadingZeroes
+
1
;
MOZ_ASSERT
(
1
<
=
msdIgnoredBits
&
&
msdIgnoredBits
<
=
11
)
;
const
uint8_t
msdIncludedBits
=
64
-
msdIgnoredBits
;
MOZ_ASSERT
(
53
<
=
msdIncludedBits
&
&
msdIncludedBits
<
=
63
)
;
MOZ_ASSERT
(
msdIncludedBits
>
=
BitsNeededForShiftedMantissa
)
;
shiftedMantissa
=
msd
<
<
(
64
-
msdIncludedBits
)
;
const
uint8_t
countOfBitsInDigitBelowExtraBit
=
64
-
BitsNeededForShiftedMantissa
-
msdIgnoredBits
;
bitsBeneathExtraBitInDigitContainingExtraBit
=
msd
&
(
(
uint64_t
(
1
)
<
<
countOfBitsInDigitBelowExtraBit
)
-
1
)
;
}
else
{
uint64_t
msd
=
x
.
high
;
uint64_t
second
=
x
.
low
;
uint8_t
msdLeadingZeroes
=
mozilla
:
:
CountLeadingZeroes64
(
msd
)
;
exponent
=
2
*
64
-
msdLeadingZeroes
-
1
;
const
uint8_t
msdIgnoredBits
=
msdLeadingZeroes
+
1
;
const
uint8_t
msdIncludedBits
=
64
-
msdIgnoredBits
;
shiftedMantissa
=
msdIncludedBits
=
=
0
?
0
:
msd
<
<
(
64
-
msdIncludedBits
)
;
if
(
msdIncludedBits
>
=
BitsNeededForShiftedMantissa
)
{
const
uint8_t
countOfBitsInDigitBelowExtraBit
=
64
-
BitsNeededForShiftedMantissa
-
msdIgnoredBits
;
bitsBeneathExtraBitInDigitContainingExtraBit
=
msd
&
(
(
uint64_t
(
1
)
<
<
countOfBitsInDigitBelowExtraBit
)
-
1
)
;
if
(
bitsBeneathExtraBitInDigitContainingExtraBit
=
=
0
)
{
bitsBeneathExtraBitInDigitContainingExtraBit
=
second
;
}
}
else
{
shiftedMantissa
|
=
second
>
>
msdIncludedBits
;
const
uint8_t
countOfBitsInSecondDigitBelowExtraBit
=
(
msdIncludedBits
+
64
)
-
BitsNeededForShiftedMantissa
;
bitsBeneathExtraBitInDigitContainingExtraBit
=
second
<
<
(
64
-
countOfBitsInSecondDigitBelowExtraBit
)
;
}
}
constexpr
uint64_t
LeastSignificantBit
=
uint64_t
(
1
)
<
<
(
64
-
SignificandWidth
)
;
constexpr
uint64_t
ExtraBit
=
LeastSignificantBit
>
>
1
;
if
(
(
shiftedMantissa
&
ExtraBit
)
!
=
0
)
{
bool
shouldRoundUp
;
if
(
shiftedMantissa
&
LeastSignificantBit
)
{
shouldRoundUp
=
true
;
}
else
{
shouldRoundUp
=
bitsBeneathExtraBitInDigitContainingExtraBit
!
=
0
;
}
if
(
shouldRoundUp
)
{
uint64_t
before
=
shiftedMantissa
;
shiftedMantissa
+
=
ExtraBit
;
if
(
shiftedMantissa
<
before
)
{
exponent
+
+
;
}
}
}
uint64_t
significandBits
=
shiftedMantissa
>
>
(
64
-
SignificandWidth
)
;
uint64_t
signBit
=
uint64_t
(
negative
?
1
:
0
)
<
<
SignShift
;
uint64_t
exponentBits
=
(
exponent
+
ExponentBias
)
<
<
ExponentShift
;
return
mozilla
:
:
BitwiseCast
<
double
>
(
signBit
|
exponentBits
|
significandBits
)
;
}
