#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
intl
/
ICU4XGeckoDataProvider
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cmath
>
#
include
<
cstring
>
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
diplomat_runtime
.
h
"
#
include
"
ICU4XAnyCalendarKind
.
h
"
#
include
"
ICU4XCalendar
.
h
"
#
include
"
ICU4XDate
.
h
"
#
include
"
ICU4XIsoDate
.
h
"
#
include
"
ICU4XIsoWeekday
.
h
"
#
include
"
ICU4XWeekCalculator
.
h
"
#
include
"
ICU4XWeekOf
.
h
"
#
include
"
ICU4XWeekRelativeUnit
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
temporal
/
Crash
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
builtin
/
temporal
/
Era
.
h
"
#
include
"
builtin
/
temporal
/
MonthCode
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainDateTime
.
h
"
#
include
"
builtin
/
temporal
/
PlainMonthDay
.
h
"
#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
builtin
/
temporal
/
PlainYearMonth
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
builtin
/
temporal
/
TemporalFields
.
h
"
#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
Wrapped
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
CallNonGenericMethod
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
PropertyInfo
.
h
"
#
include
"
vm
/
PropertyKey
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSAtomUtils
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
static
inline
bool
IsCalendar
(
Handle
<
Value
>
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
CalendarObject
>
(
)
;
}
void
js
:
:
temporal
:
:
CalendarValue
:
:
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
value_
"
CalendarValue
:
:
value
"
)
;
}
void
js
:
:
temporal
:
:
CalendarRecord
:
:
trace
(
JSTracer
*
trc
)
{
receiver_
.
trace
(
trc
)
;
TraceNullableRoot
(
trc
&
dateAdd_
"
CalendarRecord
:
:
dateAdd
"
)
;
TraceNullableRoot
(
trc
&
dateFromFields_
"
CalendarRecord
:
:
dateFromFields
"
)
;
TraceNullableRoot
(
trc
&
dateUntil_
"
CalendarRecord
:
:
dateUntil
"
)
;
TraceNullableRoot
(
trc
&
day_
"
CalendarRecord
:
:
day
"
)
;
TraceNullableRoot
(
trc
&
fields_
"
CalendarRecord
:
:
fields
"
)
;
TraceNullableRoot
(
trc
&
mergeFields_
"
CalendarRecord
:
:
mergeFields
"
)
;
TraceNullableRoot
(
trc
&
monthDayFromFields_
"
CalendarRecord
:
:
monthDayFromFields
"
)
;
TraceNullableRoot
(
trc
&
yearMonthFromFields_
"
CalendarRecord
:
:
yearMonthFromFields
"
)
;
}
bool
js
:
:
temporal
:
:
WrapCalendarValue
(
JSContext
*
cx
MutableHandle
<
JS
:
:
Value
>
calendar
)
{
MOZ_ASSERT
(
calendar
.
isInt32
(
)
|
|
calendar
.
isObject
(
)
)
;
return
cx
-
>
compartment
(
)
-
>
wrap
(
cx
calendar
)
;
}
static
bool
IterableToListOfStrings
(
JSContext
*
cx
Handle
<
Value
>
items
MutableHandle
<
CalendarFieldNames
>
list
)
{
JS
:
:
ForOfIterator
iterator
(
cx
)
;
if
(
!
iterator
.
init
(
items
)
)
{
return
false
;
}
Rooted
<
Value
>
nextValue
(
cx
)
;
Rooted
<
PropertyKey
>
value
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iterator
.
next
(
&
nextValue
&
done
)
)
{
return
false
;
}
if
(
done
)
{
return
true
;
}
if
(
nextValue
.
isString
(
)
)
{
if
(
!
PrimitiveValueToId
<
CanGC
>
(
cx
nextValue
&
value
)
)
{
return
false
;
}
if
(
!
list
.
append
(
value
)
)
{
return
false
;
}
continue
;
}
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
nextValue
nullptr
"
not
a
string
"
)
;
iterator
.
closeThrow
(
)
;
return
false
;
}
}
static
constexpr
bool
IsISOLeapYear
(
int32_t
year
)
{
return
(
year
%
4
=
=
0
)
&
&
(
(
year
%
100
!
=
0
)
|
|
(
year
%
400
=
=
0
)
)
;
}
static
bool
IsISOLeapYear
(
double
year
)
{
MOZ_ASSERT
(
IsInteger
(
year
)
)
;
return
std
:
:
fmod
(
year
4
)
=
=
0
&
&
(
std
:
:
fmod
(
year
100
)
!
=
0
|
|
std
:
:
fmod
(
year
400
)
=
=
0
)
;
}
int32_t
js
:
:
temporal
:
:
ISODaysInYear
(
int32_t
year
)
{
return
IsISOLeapYear
(
year
)
?
366
:
365
;
}
static
constexpr
int32_t
ISODaysInMonth
(
int32_t
year
int32_t
month
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
constexpr
uint8_t
daysInMonth
[
2
]
[
13
]
=
{
{
0
31
28
31
30
31
30
31
31
30
31
30
31
}
{
0
31
29
31
30
31
30
31
31
30
31
30
31
}
}
;
return
daysInMonth
[
IsISOLeapYear
(
year
)
]
[
month
]
;
}
int32_t
js
:
:
temporal
:
:
ISODaysInMonth
(
int32_t
year
int32_t
month
)
{
return
:
:
ISODaysInMonth
(
year
month
)
;
}
int32_t
js
:
:
temporal
:
:
ISODaysInMonth
(
double
year
int32_t
month
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
static
constexpr
uint8_t
daysInMonth
[
2
]
[
13
]
=
{
{
0
31
28
31
30
31
30
31
31
30
31
30
31
}
{
0
31
29
31
30
31
30
31
31
30
31
30
31
}
}
;
return
daysInMonth
[
IsISOLeapYear
(
year
)
]
[
month
]
;
}
static
int32_t
WeekDay
(
int32_t
day
)
{
int32_t
result
=
(
day
+
4
)
%
7
;
if
(
result
<
0
)
{
result
+
=
7
;
}
return
result
;
}
static
int32_t
ToISODayOfWeek
(
const
PlainDate
&
date
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
date
)
)
;
int32_t
day
=
MakeDay
(
date
)
;
int32_t
weekday
=
WeekDay
(
day
)
;
return
weekday
!
=
0
?
weekday
:
7
;
}
static
constexpr
auto
FirstDayOfMonth
(
int32_t
year
)
{
std
:
:
array
<
int32_t
13
>
days
=
{
}
;
for
(
int32_t
month
=
1
;
month
<
=
12
;
+
+
month
)
{
days
[
month
]
=
days
[
month
-
1
]
+
:
:
ISODaysInMonth
(
year
month
)
;
}
return
days
;
}
static
int32_t
ToISODayOfYear
(
int32_t
year
int32_t
month
int32_t
day
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
constexpr
decltype
(
FirstDayOfMonth
(
0
)
)
firstDayOfMonth
[
2
]
=
{
FirstDayOfMonth
(
1
)
FirstDayOfMonth
(
0
)
}
;
return
firstDayOfMonth
[
IsISOLeapYear
(
year
)
]
[
month
-
1
]
+
day
;
}
int32_t
js
:
:
temporal
:
:
ToISODayOfYear
(
const
PlainDate
&
date
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
date
)
)
;
const
auto
&
[
year
month
day
]
=
date
;
return
:
:
ToISODayOfYear
(
year
month
day
)
;
}
static
int32_t
FloorDiv
(
int32_t
dividend
int32_t
divisor
)
{
MOZ_ASSERT
(
divisor
>
0
)
;
int32_t
quotient
=
dividend
/
divisor
;
int32_t
remainder
=
dividend
%
divisor
;
if
(
remainder
<
0
)
{
quotient
-
=
1
;
}
return
quotient
;
}
static
int32_t
DayFromYear
(
int32_t
year
)
{
return
365
*
(
year
-
1970
)
+
FloorDiv
(
year
-
1969
4
)
-
FloorDiv
(
year
-
1901
100
)
+
FloorDiv
(
year
-
1601
400
)
;
}
static
int64_t
MakeTime
(
const
PlainTime
&
time
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
int64_t
h
=
time
.
hour
;
int64_t
m
=
time
.
minute
;
int64_t
s
=
time
.
second
;
int64_t
milli
=
time
.
millisecond
;
return
h
*
ToMilliseconds
(
TemporalUnit
:
:
Hour
)
+
m
*
ToMilliseconds
(
TemporalUnit
:
:
Minute
)
+
s
*
ToMilliseconds
(
TemporalUnit
:
:
Second
)
+
milli
;
}
int32_t
js
:
:
temporal
:
:
MakeDay
(
const
PlainDate
&
date
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
date
)
)
;
return
DayFromYear
(
date
.
year
)
+
ToISODayOfYear
(
date
)
-
1
;
}
int64_t
js
:
:
temporal
:
:
MakeDate
(
const
PlainDateTime
&
dateTime
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
dateTime
)
)
;
int64_t
tv
=
MakeDay
(
dateTime
.
date
)
*
ToMilliseconds
(
TemporalUnit
:
:
Day
)
+
MakeTime
(
dateTime
.
time
)
;
return
tv
;
}
static
int32_t
MakeDay
(
int32_t
year
int32_t
month
int32_t
day
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
return
DayFromYear
(
year
)
+
:
:
ToISODayOfYear
(
year
month
day
)
-
1
;
}
int64_t
js
:
:
temporal
:
:
MakeDate
(
int32_t
year
int32_t
month
int32_t
day
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
int64_t
tv
=
:
:
MakeDay
(
year
month
day
)
*
ToMilliseconds
(
TemporalUnit
:
:
Day
)
;
return
tv
;
}
struct
YearWeek
final
{
int32_t
year
=
0
;
int32_t
week
=
0
;
}
;
static
YearWeek
ToISOWeekOfYear
(
const
PlainDate
&
date
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
date
)
)
;
const
auto
&
[
year
month
day
]
=
date
;
int32_t
doy
=
ToISODayOfYear
(
date
)
;
int32_t
dow
=
ToISODayOfWeek
(
date
)
;
int32_t
woy
=
(
10
+
doy
-
dow
)
/
7
;
MOZ_ASSERT
(
0
<
=
woy
&
&
woy
<
=
53
)
;
auto
isLongYear
=
[
]
(
int32_t
year
)
{
int32_t
startOfYear
=
ToISODayOfWeek
(
{
year
1
1
}
)
;
return
startOfYear
=
=
4
|
|
(
startOfYear
=
=
3
&
&
IsISOLeapYear
(
year
)
)
;
}
;
if
(
woy
=
=
0
)
{
return
{
year
-
1
52
+
int32_t
(
isLongYear
(
year
-
1
)
)
}
;
}
if
(
woy
=
=
53
&
&
!
isLongYear
(
year
)
)
{
return
{
year
+
1
1
}
;
}
return
{
year
woy
}
;
}
static
JSString
*
ISOMonthCode
(
JSContext
*
cx
int32_t
month
)
{
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
12
)
;
char
monthCode
[
3
]
=
{
'
M
'
char
(
'
0
'
+
(
month
/
10
)
)
char
(
'
0
'
+
(
month
%
10
)
)
}
;
return
NewStringCopyN
<
CanGC
>
(
cx
monthCode
std
:
:
size
(
monthCode
)
)
;
}
template
<
typename
CharT
>
static
auto
ToMonthCode
(
std
:
:
basic_string_view
<
CharT
>
view
)
{
MOZ_ASSERT
(
view
.
length
(
)
>
=
std
:
:
string_view
{
MonthCode
{
1
}
}
.
length
(
)
)
;
MOZ_ASSERT
(
view
.
length
(
)
<
=
std
:
:
string_view
{
MonthCode
:
:
maxLeapMonth
(
)
}
.
length
(
)
)
;
bool
isLeapMonth
=
view
.
length
(
)
=
=
4
;
if
(
view
[
0
]
!
=
'
M
'
|
|
(
isLeapMonth
&
&
view
[
3
]
!
=
'
L
'
)
)
{
return
MonthCode
{
}
;
}
if
(
!
mozilla
:
:
IsAsciiDigit
(
view
[
1
]
)
|
|
!
mozilla
:
:
IsAsciiDigit
(
view
[
2
]
)
)
{
return
MonthCode
{
}
;
}
int32_t
ordinal
=
AsciiDigitToNumber
(
view
[
1
]
)
*
10
+
AsciiDigitToNumber
(
view
[
2
]
)
;
constexpr
int32_t
minMonth
=
MonthCode
{
1
}
.
ordinal
(
)
;
constexpr
int32_t
maxNonLeapMonth
=
MonthCode
:
:
maxNonLeapMonth
(
)
.
ordinal
(
)
;
constexpr
int32_t
maxLeapMonth
=
MonthCode
:
:
maxLeapMonth
(
)
.
ordinal
(
)
;
const
int32_t
maxMonth
=
isLeapMonth
?
maxLeapMonth
:
maxNonLeapMonth
;
if
(
ordinal
<
minMonth
|
|
ordinal
>
maxMonth
)
{
return
MonthCode
{
}
;
}
return
MonthCode
{
ordinal
isLeapMonth
}
;
}
static
MonthCode
ToMonthCode
(
const
JSLinearString
*
linear
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
linear
-
>
hasLatin1Chars
(
)
)
{
auto
*
chars
=
reinterpret_cast
<
const
char
*
>
(
linear
-
>
latin1Chars
(
nogc
)
)
;
return
ToMonthCode
(
std
:
:
string_view
{
chars
linear
-
>
length
(
)
}
)
;
}
auto
*
chars
=
linear
-
>
twoByteChars
(
nogc
)
;
return
ToMonthCode
(
std
:
:
u16string_view
{
chars
linear
-
>
length
(
)
}
)
;
}
static
bool
ParseMonthCode
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
JSString
*
>
monthCode
MonthCode
*
result
)
{
auto
reportInvalidMonthCode
=
[
&
]
(
)
{
if
(
auto
code
=
QuoteString
(
cx
monthCode
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_MONTHCODE
code
.
get
(
)
)
;
}
return
false
;
}
;
constexpr
size_t
MinLength
=
std
:
:
string_view
{
MonthCode
{
1
}
}
.
length
(
)
;
constexpr
size_t
MaxLength
=
std
:
:
string_view
{
MonthCode
:
:
maxLeapMonth
(
)
}
.
length
(
)
;
static_assert
(
MaxLength
>
std
:
:
string_view
{
MonthCode
:
:
maxNonLeapMonth
(
)
}
.
length
(
)
"
string
representation
of
max
-
leap
month
is
larger
"
)
;
if
(
monthCode
-
>
length
(
)
<
MinLength
|
|
monthCode
-
>
length
(
)
>
MaxLength
)
{
return
reportInvalidMonthCode
(
)
;
}
auto
*
linear
=
monthCode
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
auto
code
=
ToMonthCode
(
linear
)
;
if
(
code
=
=
MonthCode
{
}
)
{
return
reportInvalidMonthCode
(
)
;
}
const
auto
&
monthCodes
=
CalendarMonthCodes
(
calendarId
)
;
if
(
!
monthCodes
.
contains
(
code
)
)
{
return
reportInvalidMonthCode
(
)
;
}
*
result
=
code
;
return
true
;
}
template
<
typename
T
typename
.
.
.
Ts
>
static
bool
ToPlainDate
(
JSObject
*
temporalDateLike
PlainDate
*
result
)
{
if
(
auto
*
obj
=
temporalDateLike
-
>
maybeUnwrapIf
<
T
>
(
)
)
{
*
result
=
ToPlainDate
(
obj
)
;
return
true
;
}
if
constexpr
(
sizeof
.
.
.
(
Ts
)
>
0
)
{
return
ToPlainDate
<
Ts
.
.
.
>
(
temporalDateLike
result
)
;
}
return
false
;
}
template
<
typename
.
.
.
Ts
>
static
bool
ToPlainDate
(
JSContext
*
cx
Handle
<
Value
>
temporalDateLike
PlainDate
*
result
)
{
if
(
temporalDateLike
.
isObject
(
)
)
{
if
(
ToPlainDate
<
Ts
.
.
.
>
(
&
temporalDateLike
.
toObject
(
)
result
)
)
{
return
true
;
}
}
return
ToTemporalDate
(
cx
temporalDateLike
result
)
;
}
#
ifdef
DEBUG
static
bool
StringIsAsciiLowerCase
(
mozilla
:
:
Span
<
const
char
>
str
)
{
return
std
:
:
all_of
(
str
.
begin
(
)
str
.
end
(
)
[
]
(
char
ch
)
{
return
mozilla
:
:
IsAscii
(
ch
)
&
&
!
mozilla
:
:
IsAsciiUppercaseAlpha
(
ch
)
;
}
)
;
}
#
endif
static
std
:
:
string_view
CalendarIdToBcp47
(
CalendarId
id
)
{
switch
(
id
)
{
case
CalendarId
:
:
ISO8601
:
return
"
iso8601
"
;
case
CalendarId
:
:
Buddhist
:
return
"
buddhist
"
;
case
CalendarId
:
:
Chinese
:
return
"
chinese
"
;
case
CalendarId
:
:
Coptic
:
return
"
coptic
"
;
case
CalendarId
:
:
Dangi
:
return
"
dangi
"
;
case
CalendarId
:
:
Ethiopian
:
return
"
ethiopic
"
;
case
CalendarId
:
:
EthiopianAmeteAlem
:
return
"
ethioaa
"
;
case
CalendarId
:
:
Gregorian
:
return
"
gregory
"
;
case
CalendarId
:
:
Hebrew
:
return
"
hebrew
"
;
case
CalendarId
:
:
Indian
:
return
"
indian
"
;
case
CalendarId
:
:
Islamic
:
return
"
islamic
"
;
case
CalendarId
:
:
IslamicCivil
:
return
"
islamic
-
civil
"
;
case
CalendarId
:
:
IslamicRGSA
:
return
"
islamic
-
rgsa
"
;
case
CalendarId
:
:
IslamicTabular
:
return
"
islamic
-
tbla
"
;
case
CalendarId
:
:
IslamicUmmAlQura
:
return
"
islamic
-
umalqura
"
;
case
CalendarId
:
:
Japanese
:
return
"
japanese
"
;
case
CalendarId
:
:
Persian
:
return
"
persian
"
;
case
CalendarId
:
:
ROC
:
return
"
roc
"
;
}
MOZ_CRASH
(
"
invalid
calendar
id
"
)
;
}
class
MOZ_STACK_CLASS
AsciiLowerCaseChars
final
{
static
constexpr
size_t
InlineCapacity
=
24
;
Vector
<
char
InlineCapacity
>
chars_
;
public
:
explicit
AsciiLowerCaseChars
(
JSContext
*
cx
)
:
chars_
(
cx
)
{
}
operator
mozilla
:
:
Span
<
const
char
>
(
)
const
{
return
mozilla
:
:
Span
<
const
char
>
{
chars_
}
;
}
[
[
nodiscard
]
]
bool
init
(
JSLinearString
*
str
)
{
MOZ_ASSERT
(
StringIsAscii
(
str
)
)
;
if
(
!
chars_
.
resize
(
str
-
>
length
(
)
)
)
{
return
false
;
}
CopyChars
(
reinterpret_cast
<
JS
:
:
Latin1Char
*
>
(
chars_
.
begin
(
)
)
*
str
)
;
mozilla
:
:
intl
:
:
AsciiToLowerCase
(
chars_
.
begin
(
)
chars_
.
length
(
)
chars_
.
begin
(
)
)
;
return
true
;
}
}
;
static
mozilla
:
:
Maybe
<
CalendarId
>
IsBuiltinCalendar
(
mozilla
:
:
Span
<
const
char
>
id
)
{
MOZ_ASSERT
(
StringIsAsciiLowerCase
(
id
)
)
;
MOZ_ASSERT
(
id
.
size
(
)
>
0
)
;
if
(
mozilla
:
:
intl
:
:
LocaleParser
:
:
CanParseUnicodeExtensionType
(
id
)
.
isErr
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
static
constexpr
auto
key
=
mozilla
:
:
MakeStringSpan
(
"
ca
"
)
;
if
(
const
char
*
replacement
=
mozilla
:
:
intl
:
:
Locale
:
:
ReplaceUnicodeExtensionType
(
key
id
)
)
{
id
=
mozilla
:
:
MakeStringSpan
(
replacement
)
;
}
static
constexpr
auto
&
calendars
=
AvailableCalendars
(
)
;
for
(
auto
identifier
:
calendars
)
{
if
(
id
=
=
mozilla
:
:
Span
{
CalendarIdToBcp47
(
identifier
)
}
)
{
return
mozilla
:
:
Some
(
identifier
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
bool
ToBuiltinCalendar
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
id
CalendarId
*
result
)
{
if
(
!
StringIsAscii
(
id
)
|
|
id
-
>
empty
(
)
)
{
if
(
auto
chars
=
QuoteString
(
cx
id
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_ID
chars
.
get
(
)
)
;
}
return
false
;
}
AsciiLowerCaseChars
lowerCaseChars
(
cx
)
;
if
(
!
lowerCaseChars
.
init
(
id
)
)
{
return
false
;
}
if
(
auto
builtin
=
IsBuiltinCalendar
(
lowerCaseChars
)
)
{
*
result
=
*
builtin
;
return
true
;
}
if
(
auto
chars
=
QuoteString
(
cx
id
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_ID
chars
.
get
(
)
)
;
}
return
false
;
}
bool
js
:
:
temporal
:
:
ToBuiltinCalendar
(
JSContext
*
cx
Handle
<
JSString
*
>
id
MutableHandle
<
CalendarValue
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
id
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
CalendarId
identifier
;
if
(
!
:
:
ToBuiltinCalendar
(
cx
linear
&
identifier
)
)
{
return
false
;
}
result
.
set
(
CalendarValue
(
identifier
)
)
;
return
true
;
}
static
CalendarObject
*
CreateTemporalCalendar
(
JSContext
*
cx
const
CallArgs
&
args
CalendarId
identifier
)
{
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Calendar
&
proto
)
)
{
return
nullptr
;
}
auto
*
obj
=
NewObjectWithClassProto
<
CalendarObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
setFixedSlot
(
CalendarObject
:
:
IDENTIFIER_SLOT
Int32Value
(
static_cast
<
int32_t
>
(
identifier
)
)
)
;
return
obj
;
}
static
CalendarObject
*
CreateTemporalCalendar
(
JSContext
*
cx
CalendarId
identifier
)
{
auto
*
obj
=
NewBuiltinClassInstance
<
CalendarObject
>
(
cx
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
setFixedSlot
(
CalendarObject
:
:
IDENTIFIER_SLOT
Int32Value
(
static_cast
<
int32_t
>
(
identifier
)
)
)
;
return
obj
;
}
template
<
typename
T
typename
.
.
.
Ts
>
static
bool
ToTemporalCalendar
(
JSContext
*
cx
Handle
<
JSObject
*
>
object
MutableHandle
<
CalendarValue
>
result
)
{
if
(
auto
*
unwrapped
=
object
-
>
maybeUnwrapIf
<
T
>
(
)
)
{
result
.
set
(
unwrapped
-
>
calendar
(
)
)
;
return
result
.
wrap
(
cx
)
;
}
if
constexpr
(
sizeof
.
.
.
(
Ts
)
>
0
)
{
return
ToTemporalCalendar
<
Ts
.
.
.
>
(
cx
object
result
)
;
}
result
.
set
(
CalendarValue
(
)
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
ToTemporalCalendar
(
JSContext
*
cx
Handle
<
Value
>
temporalCalendarLike
MutableHandle
<
CalendarValue
>
result
)
{
if
(
temporalCalendarLike
.
isObject
(
)
)
{
Rooted
<
JSObject
*
>
obj
(
cx
&
temporalCalendarLike
.
toObject
(
)
)
;
Rooted
<
CalendarValue
>
calendar
(
cx
)
;
if
(
!
:
:
ToTemporalCalendar
<
PlainDateObject
PlainDateTimeObject
PlainMonthDayObject
PlainYearMonthObject
ZonedDateTimeObject
>
(
cx
obj
&
calendar
)
)
{
return
false
;
}
if
(
calendar
)
{
result
.
set
(
calendar
)
;
return
true
;
}
}
if
(
!
temporalCalendarLike
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
temporalCalendarLike
nullptr
"
not
a
string
"
)
;
return
false
;
}
Rooted
<
JSString
*
>
str
(
cx
temporalCalendarLike
.
toString
(
)
)
;
Rooted
<
JSLinearString
*
>
id
(
cx
ParseTemporalCalendarString
(
cx
str
)
)
;
if
(
!
id
)
{
return
false
;
}
CalendarId
identifier
;
if
(
!
:
:
ToBuiltinCalendar
(
cx
id
&
identifier
)
)
{
return
false
;
}
result
.
set
(
CalendarValue
(
identifier
)
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
ToTemporalCalendarWithISODefault
(
JSContext
*
cx
Handle
<
Value
>
temporalCalendarLike
MutableHandle
<
CalendarValue
>
result
)
{
if
(
temporalCalendarLike
.
isUndefined
(
)
)
{
result
.
set
(
CalendarValue
(
CalendarId
:
:
ISO8601
)
)
;
return
true
;
}
return
ToTemporalCalendar
(
cx
temporalCalendarLike
result
)
;
}
bool
js
:
:
temporal
:
:
GetTemporalCalendarWithISODefault
(
JSContext
*
cx
Handle
<
JSObject
*
>
item
MutableHandle
<
CalendarValue
>
result
)
{
Rooted
<
CalendarValue
>
calendar
(
cx
)
;
if
(
!
:
:
ToTemporalCalendar
<
PlainDateObject
PlainDateTimeObject
PlainMonthDayObject
PlainYearMonthObject
ZonedDateTimeObject
>
(
cx
item
&
calendar
)
)
{
return
false
;
}
if
(
calendar
)
{
result
.
set
(
calendar
)
;
return
true
;
}
Rooted
<
Value
>
calendarValue
(
cx
)
;
if
(
!
GetProperty
(
cx
item
item
cx
-
>
names
(
)
.
calendar
&
calendarValue
)
)
{
return
false
;
}
return
ToTemporalCalendarWithISODefault
(
cx
calendarValue
result
)
;
}
static
JSLinearString
*
ToTemporalCalendarIdentifier
(
JSContext
*
cx
CalendarId
id
)
{
return
NewStringCopy
<
CanGC
>
(
cx
CalendarIdToBcp47
(
id
)
)
;
}
JSLinearString
*
js
:
:
temporal
:
:
ToTemporalCalendarIdentifier
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
)
{
if
(
calendar
.
isString
(
)
)
{
return
ToTemporalCalendarIdentifier
(
cx
calendar
.
toString
(
)
)
;
}
Rooted
<
JSObject
*
>
calendarObj
(
cx
calendar
.
toObject
(
)
)
;
Rooted
<
Value
>
identifier
(
cx
)
;
if
(
!
GetProperty
(
cx
calendarObj
calendarObj
cx
-
>
names
(
)
.
id
&
identifier
)
)
{
return
nullptr
;
}
if
(
!
identifier
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
identifier
nullptr
"
not
a
string
"
)
;
return
nullptr
;
}
return
identifier
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
}
JSObject
*
js
:
:
temporal
:
:
ToTemporalCalendarObject
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
)
{
if
(
calendar
.
isObject
(
)
)
{
return
calendar
.
toObject
(
)
;
}
return
CreateTemporalCalendar
(
cx
calendar
.
toString
(
)
)
;
}
bool
js
:
:
temporal
:
:
ToTemporalCalendar
(
JSContext
*
cx
const
CalendarValue
&
calendar
MutableHandle
<
Value
>
result
)
{
if
(
calendar
.
isObject
(
)
)
{
result
.
setObject
(
*
calendar
.
toObject
(
)
)
;
return
true
;
}
auto
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
.
toString
(
)
)
;
if
(
!
str
)
{
return
false
;
}
result
.
setString
(
str
)
;
return
true
;
}
static
bool
Calendar_dateAdd
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_dateFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_dateUntil
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_day
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_fields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_mergeFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_monthDayFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
Calendar_yearMonthFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarMethodsRecordLookup
(
JSContext
*
cx
MutableHandle
<
CalendarRecord
>
calendar
CalendarMethod
methodName
)
{
Rooted
<
JSObject
*
>
object
(
cx
calendar
.
receiver
(
)
.
toObject
(
)
)
;
auto
lookup
=
[
&
]
(
Handle
<
PropertyName
*
>
name
JSNative
native
MutableHandle
<
JSObject
*
>
result
)
{
auto
*
method
=
GetMethod
(
cx
object
name
)
;
if
(
!
method
)
{
return
false
;
}
if
(
!
object
-
>
is
<
CalendarObject
>
(
)
|
|
!
IsNativeFunction
(
method
native
)
)
{
result
.
set
(
method
)
;
}
return
true
;
}
;
switch
(
methodName
)
{
case
CalendarMethod
:
:
DateAdd
:
return
lookup
(
cx
-
>
names
(
)
.
dateAdd
Calendar_dateAdd
calendar
.
dateAdd
(
)
)
;
case
CalendarMethod
:
:
DateFromFields
:
return
lookup
(
cx
-
>
names
(
)
.
dateFromFields
Calendar_dateFromFields
calendar
.
dateFromFields
(
)
)
;
case
CalendarMethod
:
:
DateUntil
:
return
lookup
(
cx
-
>
names
(
)
.
dateUntil
Calendar_dateUntil
calendar
.
dateUntil
(
)
)
;
case
CalendarMethod
:
:
Day
:
return
lookup
(
cx
-
>
names
(
)
.
day
Calendar_day
calendar
.
day
(
)
)
;
case
CalendarMethod
:
:
Fields
:
return
lookup
(
cx
-
>
names
(
)
.
fields
Calendar_fields
calendar
.
fields
(
)
)
;
case
CalendarMethod
:
:
MergeFields
:
return
lookup
(
cx
-
>
names
(
)
.
mergeFields
Calendar_mergeFields
calendar
.
mergeFields
(
)
)
;
case
CalendarMethod
:
:
MonthDayFromFields
:
return
lookup
(
cx
-
>
names
(
)
.
monthDayFromFields
Calendar_monthDayFromFields
calendar
.
monthDayFromFields
(
)
)
;
case
CalendarMethod
:
:
YearMonthFromFields
:
return
lookup
(
cx
-
>
names
(
)
.
yearMonthFromFields
Calendar_yearMonthFromFields
calendar
.
yearMonthFromFields
(
)
)
;
}
MOZ_CRASH
(
"
invalid
calendar
method
"
)
;
}
bool
js
:
:
temporal
:
:
CreateCalendarMethodsRecord
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
mozilla
:
:
EnumSet
<
CalendarMethod
>
methods
MutableHandle
<
CalendarRecord
>
result
)
{
MOZ_ASSERT
(
!
methods
.
isEmpty
(
)
)
;
result
.
set
(
CalendarRecord
{
calendar
}
)
;
#
ifdef
DEBUG
result
.
get
(
)
.
lookedUp
(
)
+
=
methods
;
#
endif
if
(
calendar
.
isString
(
)
)
{
return
true
;
}
for
(
auto
method
:
methods
)
{
if
(
!
CalendarMethodsRecordLookup
(
cx
result
method
)
)
{
return
false
;
}
}
return
true
;
}
static
CalendarId
BuiltinCalendarId
(
const
CalendarValue
&
calendar
)
{
if
(
calendar
.
isString
(
)
)
{
return
calendar
.
toString
(
)
;
}
return
calendar
.
toObject
(
)
-
>
as
<
CalendarObject
>
(
)
.
identifier
(
)
;
}
static
auto
ToAnyCalendarKind
(
CalendarId
id
)
{
switch
(
id
)
{
case
CalendarId
:
:
ISO8601
:
return
capi
:
:
ICU4XAnyCalendarKind_Iso
;
case
CalendarId
:
:
Buddhist
:
return
capi
:
:
ICU4XAnyCalendarKind_Buddhist
;
case
CalendarId
:
:
Chinese
:
return
capi
:
:
ICU4XAnyCalendarKind_Chinese
;
case
CalendarId
:
:
Coptic
:
return
capi
:
:
ICU4XAnyCalendarKind_Coptic
;
case
CalendarId
:
:
Dangi
:
return
capi
:
:
ICU4XAnyCalendarKind_Dangi
;
case
CalendarId
:
:
Ethiopian
:
return
capi
:
:
ICU4XAnyCalendarKind_Ethiopian
;
case
CalendarId
:
:
EthiopianAmeteAlem
:
return
capi
:
:
ICU4XAnyCalendarKind_EthiopianAmeteAlem
;
case
CalendarId
:
:
Gregorian
:
return
capi
:
:
ICU4XAnyCalendarKind_Gregorian
;
case
CalendarId
:
:
Hebrew
:
return
capi
:
:
ICU4XAnyCalendarKind_Hebrew
;
case
CalendarId
:
:
Indian
:
return
capi
:
:
ICU4XAnyCalendarKind_Indian
;
case
CalendarId
:
:
IslamicCivil
:
return
capi
:
:
ICU4XAnyCalendarKind_IslamicCivil
;
case
CalendarId
:
:
Islamic
:
return
capi
:
:
ICU4XAnyCalendarKind_IslamicObservational
;
case
CalendarId
:
:
IslamicRGSA
:
return
capi
:
:
ICU4XAnyCalendarKind_IslamicObservational
;
case
CalendarId
:
:
IslamicTabular
:
return
capi
:
:
ICU4XAnyCalendarKind_IslamicTabular
;
case
CalendarId
:
:
IslamicUmmAlQura
:
return
capi
:
:
ICU4XAnyCalendarKind_IslamicUmmAlQura
;
case
CalendarId
:
:
Japanese
:
return
capi
:
:
ICU4XAnyCalendarKind_Japanese
;
case
CalendarId
:
:
Persian
:
return
capi
:
:
ICU4XAnyCalendarKind_Persian
;
case
CalendarId
:
:
ROC
:
return
capi
:
:
ICU4XAnyCalendarKind_Roc
;
}
MOZ_CRASH
(
"
invalid
calendar
id
"
)
;
}
class
ICU4XCalendarDeleter
{
public
:
void
operator
(
)
(
capi
:
:
ICU4XCalendar
*
ptr
)
{
capi
:
:
ICU4XCalendar_destroy
(
ptr
)
;
}
}
;
using
UniqueICU4XCalendar
=
mozilla
:
:
UniquePtr
<
capi
:
:
ICU4XCalendar
ICU4XCalendarDeleter
>
;
static
UniqueICU4XCalendar
CreateICU4XCalendar
(
JSContext
*
cx
CalendarId
id
)
{
auto
result
=
capi
:
:
ICU4XCalendar_create_for_kind
(
mozilla
:
:
intl
:
:
GetDataProvider
(
)
ToAnyCalendarKind
(
id
)
)
;
if
(
!
result
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
nullptr
;
}
return
UniqueICU4XCalendar
{
result
.
ok
}
;
}
class
ICU4XDateDeleter
{
public
:
void
operator
(
)
(
capi
:
:
ICU4XDate
*
ptr
)
{
capi
:
:
ICU4XDate_destroy
(
ptr
)
;
}
}
;
using
UniqueICU4XDate
=
mozilla
:
:
UniquePtr
<
capi
:
:
ICU4XDate
ICU4XDateDeleter
>
;
static
UniqueICU4XDate
CreateICU4XDate
(
JSContext
*
cx
const
PlainDate
&
date
const
capi
:
:
ICU4XCalendar
*
calendar
)
{
auto
result
=
capi
:
:
ICU4XDate_create_from_iso_in_calendar
(
date
.
year
date
.
month
date
.
day
calendar
)
;
if
(
!
result
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
nullptr
;
}
return
UniqueICU4XDate
{
result
.
ok
}
;
}
class
ICU4XIsoDateDeleter
{
public
:
void
operator
(
)
(
capi
:
:
ICU4XIsoDate
*
ptr
)
{
capi
:
:
ICU4XIsoDate_destroy
(
ptr
)
;
}
}
;
using
UniqueICU4XIsoDate
=
mozilla
:
:
UniquePtr
<
capi
:
:
ICU4XIsoDate
ICU4XIsoDateDeleter
>
;
class
ICU4XWeekCalculatorDeleter
{
public
:
void
operator
(
)
(
capi
:
:
ICU4XWeekCalculator
*
ptr
)
{
capi
:
:
ICU4XWeekCalculator_destroy
(
ptr
)
;
}
}
;
using
UniqueICU4XWeekCalculator
=
mozilla
:
:
UniquePtr
<
capi
:
:
ICU4XWeekCalculator
ICU4XWeekCalculatorDeleter
>
;
static
UniqueICU4XWeekCalculator
CreateICU4WeekCalculator
(
JSContext
*
cx
CalendarId
calendar
)
{
MOZ_ASSERT
(
calendar
=
=
CalendarId
:
:
Gregorian
)
;
auto
firstWeekday
=
capi
:
:
ICU4XIsoWeekday_Monday
;
uint8_t
minWeekDays
=
1
;
auto
*
result
=
capi
:
:
ICU4XWeekCalculator_create_from_first_day_of_week_and_min_week_days
(
firstWeekday
minWeekDays
)
;
return
UniqueICU4XWeekCalculator
{
result
}
;
}
static
constexpr
size_t
EraNameMaxLength
(
)
{
size_t
length
=
0
;
for
(
auto
calendar
:
AvailableCalendars
(
)
)
{
for
(
auto
era
:
CalendarEras
(
calendar
)
)
{
for
(
auto
name
:
CalendarEraNames
(
calendar
era
)
)
{
length
=
std
:
:
max
(
length
name
.
length
(
)
)
;
}
}
}
return
length
;
}
static
mozilla
:
:
Maybe
<
EraCode
>
EraForString
(
CalendarId
calendar
JSLinearString
*
string
)
{
MOZ_ASSERT
(
CalendarEraRelevant
(
calendar
)
)
;
constexpr
size_t
MaxLength
=
24
;
static_assert
(
MaxLength
>
=
EraNameMaxLength
(
)
"
Storage
size
is
at
least
as
large
as
the
largest
known
era
"
)
;
if
(
string
-
>
length
(
)
>
MaxLength
|
|
!
StringIsAscii
(
string
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
char
chars
[
MaxLength
]
=
{
}
;
CopyChars
(
reinterpret_cast
<
JS
:
:
Latin1Char
*
>
(
chars
)
*
string
)
;
auto
stringView
=
std
:
:
string_view
{
chars
string
-
>
length
(
)
}
;
for
(
auto
era
:
CalendarEras
(
calendar
)
)
{
for
(
auto
name
:
CalendarEraNames
(
calendar
era
)
)
{
if
(
name
=
=
stringView
)
{
return
mozilla
:
:
Some
(
era
)
;
}
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
constexpr
std
:
:
string_view
IcuEraName
(
CalendarId
calendar
EraCode
era
)
{
switch
(
calendar
)
{
case
CalendarId
:
:
ISO8601
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
default
"
;
}
case
CalendarId
:
:
Buddhist
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
be
"
;
}
case
CalendarId
:
:
Chinese
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
chinese
"
;
}
case
CalendarId
:
:
Coptic
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
|
|
era
=
=
EraCode
:
:
Inverse
)
;
return
era
=
=
EraCode
:
:
Standard
?
"
ad
"
:
"
bd
"
;
}
case
CalendarId
:
:
Dangi
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
dangi
"
;
}
case
CalendarId
:
:
Ethiopian
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
|
|
era
=
=
EraCode
:
:
Inverse
)
;
return
era
=
=
EraCode
:
:
Standard
?
"
incar
"
:
"
pre
-
incar
"
;
}
case
CalendarId
:
:
EthiopianAmeteAlem
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
mundi
"
;
}
case
CalendarId
:
:
Gregorian
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
|
|
era
=
=
EraCode
:
:
Inverse
)
;
return
era
=
=
EraCode
:
:
Standard
?
"
ce
"
:
"
bce
"
;
}
case
CalendarId
:
:
Hebrew
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
am
"
;
}
case
CalendarId
:
:
Indian
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
saka
"
;
}
case
CalendarId
:
:
Islamic
:
case
CalendarId
:
:
IslamicCivil
:
case
CalendarId
:
:
IslamicRGSA
:
case
CalendarId
:
:
IslamicTabular
:
case
CalendarId
:
:
IslamicUmmAlQura
:
case
CalendarId
:
:
Persian
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
return
"
ah
"
;
}
case
CalendarId
:
:
Japanese
:
{
switch
(
era
)
{
case
EraCode
:
:
Standard
:
return
"
ce
"
;
case
EraCode
:
:
Inverse
:
return
"
bce
"
;
case
EraCode
:
:
Meiji
:
return
"
meiji
"
;
case
EraCode
:
:
Taisho
:
return
"
taisho
"
;
case
EraCode
:
:
Showa
:
return
"
showa
"
;
case
EraCode
:
:
Heisei
:
return
"
heisei
"
;
case
EraCode
:
:
Reiwa
:
return
"
reiwa
"
;
}
break
;
}
case
CalendarId
:
:
ROC
:
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
|
|
era
=
=
EraCode
:
:
Inverse
)
;
return
era
=
=
EraCode
:
:
Standard
?
"
roc
"
:
"
roc
-
inverse
"
;
}
}
JS_CONSTEXPR_CRASH
(
"
invalid
era
"
)
;
}
enum
class
CalendarError
{
Generic
Overflow
Underflow
OutOfRange
UnknownEra
UnknownMonthCode
}
;
static
mozilla
:
:
Result
<
UniqueICU4XDate
CalendarError
>
CreateDateFromCodes
(
CalendarId
calendarId
const
capi
:
:
ICU4XCalendar
*
calendar
EraYear
eraYear
MonthCode
monthCode
int32_t
day
)
{
MOZ_ASSERT
(
calendarId
!
=
CalendarId
:
:
ISO8601
)
;
MOZ_ASSERT
(
capi
:
:
ICU4XCalendar_kind
(
calendar
)
=
=
ToAnyCalendarKind
(
calendarId
)
)
;
MOZ_ASSERT
(
mozilla
:
:
EnumSet
<
EraCode
>
(
CalendarEras
(
calendarId
)
)
.
contains
(
eraYear
.
era
)
)
;
MOZ_ASSERT_IF
(
CalendarEraRelevant
(
calendarId
)
eraYear
.
year
>
0
)
;
MOZ_ASSERT
(
CalendarMonthCodes
(
calendarId
)
.
contains
(
monthCode
)
)
;
MOZ_ASSERT
(
day
>
0
)
;
MOZ_ASSERT
(
day
<
=
CalendarDaysInMonth
(
calendarId
)
.
second
)
;
auto
era
=
IcuEraName
(
calendarId
eraYear
.
era
)
;
auto
monthCodeView
=
std
:
:
string_view
{
monthCode
}
;
auto
date
=
capi
:
:
ICU4XDate_create_from_codes_in_calendar
(
era
.
data
(
)
era
.
length
(
)
eraYear
.
year
monthCodeView
.
data
(
)
monthCodeView
.
length
(
)
day
calendar
)
;
if
(
date
.
is_ok
)
{
return
UniqueICU4XDate
{
date
.
ok
}
;
}
switch
(
date
.
err
)
{
case
capi
:
:
ICU4XError_CalendarOverflowError
:
return
mozilla
:
:
Err
(
CalendarError
:
:
Overflow
)
;
case
capi
:
:
ICU4XError_CalendarUnderflowError
:
return
mozilla
:
:
Err
(
CalendarError
:
:
Underflow
)
;
case
capi
:
:
ICU4XError_CalendarOutOfRangeError
:
return
mozilla
:
:
Err
(
CalendarError
:
:
OutOfRange
)
;
case
capi
:
:
ICU4XError_CalendarUnknownEraError
:
return
mozilla
:
:
Err
(
CalendarError
:
:
UnknownEra
)
;
case
capi
:
:
ICU4XError_CalendarUnknownMonthCodeError
:
return
mozilla
:
:
Err
(
CalendarError
:
:
UnknownMonthCode
)
;
default
:
return
mozilla
:
:
Err
(
CalendarError
:
:
Generic
)
;
}
}
static
mozilla
:
:
Result
<
UniqueICU4XDate
CalendarError
>
CreateDateFromCodesConstrainToJapaneseEra
(
JSContext
*
cx
CalendarId
calendarId
const
capi
:
:
ICU4XCalendar
*
calendar
EraYear
eraYear
MonthCode
monthCode
int32_t
day
)
{
MOZ_ASSERT
(
calendarId
=
=
CalendarId
:
:
Japanese
)
;
MOZ_ASSERT
(
capi
:
:
ICU4XCalendar_kind
(
calendar
)
=
=
ToAnyCalendarKind
(
calendarId
)
)
;
MOZ_ASSERT
(
!
CalendarEraStartsAtYearBoundary
(
calendarId
eraYear
.
era
)
)
;
MOZ_ASSERT
(
!
monthCode
.
isLeapMonth
(
)
)
;
MOZ_ASSERT
(
1
<
=
monthCode
.
ordinal
(
)
&
&
monthCode
.
ordinal
(
)
<
=
12
)
;
MOZ_ASSERT
(
1
<
=
day
&
&
day
<
=
31
)
;
const
auto
&
[
era
year
]
=
eraYear
;
int32_t
month
=
monthCode
.
ordinal
(
)
;
const
int32_t
startMonth
=
month
;
if
(
year
=
=
1
)
{
MOZ_ASSERT
(
capi
:
:
ICU4XCalendar_kind
(
calendar
)
!
=
capi
:
:
ICU4XAnyCalendarKind_JapaneseExtended
)
;
auto
firstEraYear
=
EraYear
{
era
1
}
;
for
(
;
month
<
=
12
;
month
+
+
)
{
auto
firstDayOfMonth
=
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
MonthCode
{
month
}
1
)
;
if
(
firstDayOfMonth
.
isOk
(
)
)
{
if
(
month
=
=
startMonth
)
{
int32_t
lastDayOfMonth
=
capi
:
:
ICU4XDate_days_in_month
(
firstDayOfMonth
.
inspect
(
)
.
get
(
)
)
;
return
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
MonthCode
{
month
}
std
:
:
min
(
day
lastDayOfMonth
)
)
;
}
break
;
}
if
(
firstDayOfMonth
.
inspectErr
(
)
!
=
CalendarError
:
:
OutOfRange
)
{
return
firstDayOfMonth
.
propagateErr
(
)
;
}
}
MOZ_ASSERT
(
startMonth
<
month
)
;
auto
monthCode
=
MonthCode
{
month
-
1
}
;
if
(
startMonth
<
month
-
1
)
{
for
(
int32_t
firstDayOfEra
=
2
;
firstDayOfEra
<
=
31
;
firstDayOfEra
+
+
)
{
auto
date
=
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
monthCode
firstDayOfEra
)
;
if
(
date
.
isOk
(
)
)
{
return
date
.
unwrap
(
)
;
}
if
(
date
.
inspectErr
(
)
=
=
CalendarError
:
:
OutOfRange
)
{
continue
;
}
if
(
date
.
inspectErr
(
)
=
=
CalendarError
:
:
Overflow
)
{
break
;
}
return
date
.
propagateErr
(
)
;
}
return
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
MonthCode
{
month
}
1
)
;
}
auto
date
=
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
monthCode
day
)
;
if
(
date
.
isOk
(
)
)
{
return
date
.
unwrap
(
)
;
}
auto
errorCode
=
date
.
inspectErr
(
)
;
int32_t
direction
;
if
(
errorCode
=
=
CalendarError
:
:
Overflow
)
{
direction
=
-
1
;
}
else
if
(
errorCode
=
=
CalendarError
:
:
OutOfRange
)
{
direction
=
1
;
}
else
{
return
date
.
propagateErr
(
)
;
}
while
(
(
direction
<
0
&
&
day
>
28
)
|
|
(
direction
>
0
&
&
day
<
31
)
)
{
day
+
=
direction
;
auto
date
=
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
monthCode
day
)
;
if
(
date
.
isOk
(
)
)
{
return
date
.
unwrap
(
)
;
}
if
(
date
.
inspectErr
(
)
=
=
errorCode
)
{
continue
;
}
return
date
.
propagateErr
(
)
;
}
return
CreateDateFromCodes
(
calendarId
calendar
firstEraYear
MonthCode
{
month
}
1
)
;
}
auto
firstDayOfYear
=
CreateDateFromCodes
(
calendarId
calendar
EraYear
{
era
year
}
MonthCode
{
1
}
1
)
;
int32_t
lastYearInEra
;
if
(
firstDayOfYear
.
isOk
(
)
)
{
lastYearInEra
=
year
;
}
else
if
(
firstDayOfYear
.
inspectErr
(
)
=
=
CalendarError
:
:
OutOfRange
)
{
int32_t
minYear
=
1
;
int32_t
maxYear
=
year
;
while
(
minYear
!
=
maxYear
)
{
int32_t
candidateYear
=
minYear
+
(
maxYear
-
minYear
)
/
2
;
auto
firstDayOfYear
=
CreateDateFromCodes
(
calendarId
calendar
EraYear
{
era
candidateYear
}
MonthCode
{
1
}
1
)
;
if
(
firstDayOfYear
.
isOk
(
)
)
{
minYear
=
candidateYear
+
1
;
}
else
if
(
firstDayOfYear
.
inspectErr
(
)
=
=
CalendarError
:
:
OutOfRange
)
{
maxYear
=
candidateYear
;
}
else
{
return
firstDayOfYear
.
propagateErr
(
)
;
}
}
MOZ_ASSERT
(
1
<
minYear
&
&
minYear
<
=
year
)
;
lastYearInEra
=
minYear
-
1
;
month
=
12
;
day
=
31
;
}
else
{
return
firstDayOfYear
.
propagateErr
(
)
;
}
auto
lastEraYear
=
EraYear
{
era
lastYearInEra
}
;
for
(
;
month
>
0
;
month
-
-
)
{
auto
monthCode
=
MonthCode
{
month
}
;
auto
firstDayOfMonth
=
CreateDateFromCodes
(
calendarId
calendar
lastEraYear
monthCode
1
)
;
if
(
firstDayOfMonth
.
isErr
(
)
)
{
if
(
firstDayOfMonth
.
inspectErr
(
)
=
=
CalendarError
:
:
OutOfRange
)
{
continue
;
}
return
firstDayOfMonth
.
propagateErr
(
)
;
}
auto
intermediateDate
=
firstDayOfMonth
.
unwrap
(
)
;
int32_t
lastDayOfMonth
=
capi
:
:
ICU4XDate_days_in_month
(
intermediateDate
.
get
(
)
)
;
if
(
lastYearInEra
=
=
year
&
&
month
=
=
startMonth
)
{
day
=
std
:
:
min
(
day
lastDayOfMonth
)
;
}
else
{
MOZ_ASSERT_IF
(
lastYearInEra
=
=
year
month
<
startMonth
)
;
day
=
lastDayOfMonth
;
}
for
(
int32_t
nextDay
=
2
;
nextDay
<
=
day
;
nextDay
+
+
)
{
auto
nextDayOfMonth
=
CreateDateFromCodes
(
calendarId
calendar
lastEraYear
monthCode
nextDay
)
;
if
(
nextDayOfMonth
.
isErr
(
)
)
{
if
(
nextDayOfMonth
.
inspectErr
(
)
=
=
CalendarError
:
:
OutOfRange
)
{
break
;
}
return
nextDayOfMonth
.
propagateErr
(
)
;
}
intermediateDate
=
nextDayOfMonth
.
unwrap
(
)
;
}
return
intermediateDate
;
}
MOZ_CRASH
(
"
error
constraining
to
end
of
era
"
)
;
}
static
void
ReportCalendarFieldOverflow
(
JSContext
*
cx
const
char
*
name
double
num
)
{
ToCStringBuf
numCbuf
;
const
char
*
numStr
=
NumberToCString
(
&
numCbuf
num
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_OVERFLOW_FIELD
name
numStr
)
;
}
static
UniqueICU4XDate
CreateDateFromCodes
(
JSContext
*
cx
CalendarId
calendarId
const
capi
:
:
ICU4XCalendar
*
calendar
EraYear
eraYear
MonthCode
monthCode
int32_t
day
TemporalOverflow
overflow
)
{
MOZ_ASSERT
(
CalendarMonthCodes
(
calendarId
)
.
contains
(
monthCode
)
)
;
MOZ_ASSERT
(
day
>
0
)
;
MOZ_ASSERT
(
day
<
=
CalendarDaysInMonth
(
calendarId
)
.
second
)
;
int32_t
daysInMonth
=
CalendarDaysInMonth
(
calendarId
monthCode
)
.
second
;
if
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
{
day
=
std
:
:
min
(
day
daysInMonth
)
;
}
else
{
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
;
if
(
day
>
daysInMonth
)
{
ReportCalendarFieldOverflow
(
cx
"
day
"
day
)
;
return
nullptr
;
}
}
auto
result
=
CreateDateFromCodes
(
calendarId
calendar
eraYear
monthCode
day
)
;
if
(
result
.
isOk
(
)
)
{
return
result
.
unwrap
(
)
;
}
switch
(
result
.
inspectErr
(
)
)
{
case
CalendarError
:
:
UnknownMonthCode
:
{
MOZ_ASSERT
(
CalendarHasLeapMonths
(
calendarId
)
)
;
MOZ_ASSERT
(
monthCode
.
isLeapMonth
(
)
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
char
code
[
5
]
=
{
}
;
auto
monthCodeView
=
std
:
:
string_view
{
monthCode
}
;
monthCodeView
.
copy
(
code
monthCodeView
.
length
(
)
)
;
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_MONTHCODE
code
)
;
return
nullptr
;
}
int32_t
nonLeapMonth
=
std
:
:
min
(
monthCode
.
ordinal
(
)
+
1
12
)
;
auto
nonLeapMonthCode
=
MonthCode
{
nonLeapMonth
}
;
return
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
nonLeapMonthCode
day
overflow
)
;
}
case
CalendarError
:
:
Overflow
:
{
MOZ_ASSERT
(
day
>
CalendarDaysInMonth
(
calendarId
monthCode
)
.
first
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
day
"
day
)
;
return
nullptr
;
}
auto
firstDayOfMonth
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
monthCode
1
overflow
)
;
if
(
!
firstDayOfMonth
)
{
return
nullptr
;
}
int32_t
daysInMonth
=
capi
:
:
ICU4XDate_days_in_month
(
firstDayOfMonth
.
get
(
)
)
;
MOZ_ASSERT
(
day
>
daysInMonth
)
;
return
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
monthCode
daysInMonth
overflow
)
;
}
case
CalendarError
:
:
OutOfRange
:
{
MOZ_ASSERT
(
calendarId
=
=
CalendarId
:
:
Japanese
)
;
MOZ_ASSERT
(
!
CalendarEraStartsAtYearBoundary
(
calendarId
eraYear
.
era
)
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
eraYear
"
eraYear
.
year
)
;
return
nullptr
;
}
auto
result
=
CreateDateFromCodesConstrainToJapaneseEra
(
cx
calendarId
calendar
eraYear
monthCode
day
)
;
if
(
result
.
isOk
(
)
)
{
return
result
.
unwrap
(
)
;
}
break
;
}
case
CalendarError
:
:
Underflow
:
case
CalendarError
:
:
UnknownEra
:
MOZ_ASSERT
(
false
"
unexpected
calendar
error
"
)
;
break
;
case
CalendarError
:
:
Generic
:
break
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
nullptr
;
}
static
UniqueICU4XDate
CreateDateFrom
(
JSContext
*
cx
CalendarId
calendarId
const
capi
:
:
ICU4XCalendar
*
calendar
EraYear
eraYear
int32_t
month
int32_t
day
TemporalOverflow
overflow
)
{
MOZ_ASSERT
(
calendarId
!
=
CalendarId
:
:
ISO8601
)
;
MOZ_ASSERT
(
month
>
0
)
;
MOZ_ASSERT
(
day
>
0
)
;
MOZ_ASSERT
(
month
<
=
CalendarMonthsPerYear
(
calendarId
)
)
;
MOZ_ASSERT
(
day
<
=
CalendarDaysInMonth
(
calendarId
)
.
second
)
;
switch
(
calendarId
)
{
case
CalendarId
:
:
ISO8601
:
case
CalendarId
:
:
Buddhist
:
case
CalendarId
:
:
Coptic
:
case
CalendarId
:
:
Ethiopian
:
case
CalendarId
:
:
EthiopianAmeteAlem
:
case
CalendarId
:
:
Gregorian
:
case
CalendarId
:
:
Indian
:
case
CalendarId
:
:
Islamic
:
case
CalendarId
:
:
IslamicCivil
:
case
CalendarId
:
:
IslamicRGSA
:
case
CalendarId
:
:
IslamicTabular
:
case
CalendarId
:
:
IslamicUmmAlQura
:
case
CalendarId
:
:
Japanese
:
case
CalendarId
:
:
Persian
:
case
CalendarId
:
:
ROC
:
{
MOZ_ASSERT
(
!
CalendarHasLeapMonths
(
calendarId
)
)
;
auto
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
MonthCode
{
month
}
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
MOZ_ASSERT_IF
(
CalendarEraStartsAtYearBoundary
(
calendarId
)
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
=
=
uint32_t
(
month
)
)
;
return
date
;
}
case
CalendarId
:
:
Dangi
:
case
CalendarId
:
:
Chinese
:
{
static_assert
(
CalendarHasLeapMonths
(
CalendarId
:
:
Chinese
)
)
;
static_assert
(
CalendarMonthsPerYear
(
CalendarId
:
:
Chinese
)
=
=
13
)
;
static_assert
(
CalendarHasLeapMonths
(
CalendarId
:
:
Dangi
)
)
;
static_assert
(
CalendarMonthsPerYear
(
CalendarId
:
:
Dangi
)
=
=
13
)
;
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
13
)
;
auto
monthCode
=
MonthCode
{
std
:
:
min
(
month
12
)
}
;
auto
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
monthCode
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
int32_t
ordinal
=
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
;
if
(
ordinal
=
=
month
)
{
return
date
;
}
if
(
ordinal
>
month
)
{
MOZ_ASSERT
(
1
<
month
&
&
month
<
=
12
)
;
MOZ_ASSERT
(
capi
:
:
ICU4XDate_months_in_year
(
date
.
get
(
)
)
=
=
13
)
;
MOZ_ASSERT
(
(
ordinal
-
month
)
=
=
1
)
;
if
(
month
>
2
)
{
auto
previousMonthCode
=
MonthCode
{
month
-
1
}
;
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
previousMonthCode
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
int32_t
ordinal
=
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
;
if
(
ordinal
=
=
month
)
{
return
date
;
}
}
}
else
{
MOZ_ASSERT
(
month
=
=
13
)
;
MOZ_ASSERT
(
ordinal
=
=
12
)
;
if
(
capi
:
:
ICU4XDate_months_in_year
(
date
.
get
(
)
)
!
=
13
)
{
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
month
"
month
)
;
return
nullptr
;
}
return
date
;
}
}
auto
leapMonthCode
=
MonthCode
{
month
-
1
true
}
;
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
leapMonthCode
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
MOZ_ASSERT
(
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
=
=
uint32_t
(
month
)
"
unexpected
ordinal
month
"
)
;
return
date
;
}
case
CalendarId
:
:
Hebrew
:
{
static_assert
(
CalendarHasLeapMonths
(
CalendarId
:
:
Hebrew
)
)
;
static_assert
(
CalendarMonthsPerYear
(
CalendarId
:
:
Hebrew
)
=
=
13
)
;
MOZ_ASSERT
(
1
<
=
month
&
&
month
<
=
13
)
;
auto
monthCode
=
MonthCode
{
std
:
:
min
(
month
12
)
}
;
auto
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
monthCode
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
int32_t
ordinal
=
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
;
if
(
ordinal
=
=
month
)
{
return
date
;
}
if
(
ordinal
>
month
)
{
MOZ_ASSERT
(
1
<
month
&
&
month
<
=
12
)
;
MOZ_ASSERT
(
capi
:
:
ICU4XDate_months_in_year
(
date
.
get
(
)
)
=
=
13
)
;
MOZ_ASSERT
(
(
ordinal
-
month
)
=
=
1
)
;
}
else
{
MOZ_ASSERT
(
month
=
=
13
)
;
MOZ_ASSERT
(
ordinal
=
=
12
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
month
"
month
)
;
return
nullptr
;
}
return
date
;
}
bool
isLeapMonth
=
month
=
=
6
;
auto
previousMonthCode
=
MonthCode
{
month
-
1
isLeapMonth
}
;
date
=
CreateDateFromCodes
(
cx
calendarId
calendar
eraYear
previousMonthCode
day
overflow
)
;
if
(
!
date
)
{
return
nullptr
;
}
MOZ_ASSERT
(
capi
:
:
ICU4XDate_ordinal_month
(
date
.
get
(
)
)
=
=
uint32_t
(
month
)
"
unexpected
ordinal
month
"
)
;
return
date
;
}
}
MOZ_CRASH
(
"
invalid
calendar
id
"
)
;
}
static
constexpr
size_t
ICUEraNameMaxLength
(
)
{
size_t
length
=
0
;
for
(
auto
calendar
:
AvailableCalendars
(
)
)
{
for
(
auto
era
:
CalendarEras
(
calendar
)
)
{
auto
name
=
IcuEraName
(
calendar
era
)
;
length
=
std
:
:
max
(
length
name
.
length
(
)
)
;
}
}
return
length
;
}
static
bool
CalendarDateEra
(
JSContext
*
cx
CalendarId
calendar
const
capi
:
:
ICU4XDate
*
date
EraCode
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
constexpr
size_t
MaxLength
=
15
;
static_assert
(
MaxLength
>
=
ICUEraNameMaxLength
(
)
"
Storage
size
is
at
least
as
large
as
the
largest
known
era
"
)
;
char
buf
[
MaxLength
+
1
]
=
{
}
;
auto
writable
=
capi
:
:
diplomat_simple_writeable
(
buf
std
:
:
size
(
buf
)
)
;
if
(
!
capi
:
:
ICU4XDate_era
(
date
&
writable
)
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
MOZ_ASSERT
(
writable
.
buf
=
=
buf
"
unexpected
buffer
relocation
"
)
;
auto
dateEra
=
std
:
:
string_view
{
writable
.
buf
writable
.
len
}
;
for
(
auto
era
:
CalendarEras
(
calendar
)
)
{
if
(
IcuEraName
(
calendar
era
)
=
=
dateEra
)
{
*
result
=
era
;
return
true
;
}
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
static
bool
CalendarDateYear
(
JSContext
*
cx
CalendarId
calendar
const
capi
:
:
ICU4XDate
*
date
int32_t
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
if
(
!
CalendarEraRelevant
(
calendar
)
)
{
int32_t
year
=
capi
:
:
ICU4XDate_year_in_era
(
date
)
;
*
result
=
year
;
return
true
;
}
if
(
calendar
!
=
CalendarId
:
:
Japanese
)
{
MOZ_ASSERT
(
CalendarEras
(
calendar
)
.
size
(
)
=
=
2
)
;
int32_t
year
=
capi
:
:
ICU4XDate_year_in_era
(
date
)
;
MOZ_ASSERT
(
year
>
0
"
era
years
are
strictly
positive
in
ICU4X
"
)
;
EraCode
era
;
if
(
!
CalendarDateEra
(
cx
calendar
date
&
era
)
)
{
return
false
;
}
if
(
era
=
=
EraCode
:
:
Inverse
)
{
year
=
-
(
year
-
1
)
;
}
else
{
MOZ_ASSERT
(
era
=
=
EraCode
:
:
Standard
)
;
}
*
result
=
year
;
return
true
;
}
UniqueICU4XIsoDate
isoDate
{
capi
:
:
ICU4XDate_to_iso
(
date
)
}
;
int32_t
isoYear
=
capi
:
:
ICU4XIsoDate_year
(
isoDate
.
get
(
)
)
;
*
result
=
isoYear
;
return
true
;
}
static
bool
CalendarDateMonthCode
(
JSContext
*
cx
CalendarId
calendar
const
capi
:
:
ICU4XDate
*
date
MonthCode
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
constexpr
size_t
MaxLength
=
std
:
:
string_view
{
MonthCode
:
:
maxLeapMonth
(
)
}
.
length
(
)
;
static_assert
(
MaxLength
>
std
:
:
string_view
{
MonthCode
:
:
maxNonLeapMonth
(
)
}
.
length
(
)
"
string
representation
of
max
-
leap
month
is
larger
"
)
;
char
buf
[
MaxLength
+
1
]
=
{
}
;
auto
writable
=
capi
:
:
diplomat_simple_writeable
(
buf
std
:
:
size
(
buf
)
)
;
if
(
!
capi
:
:
ICU4XDate_month_code
(
date
&
writable
)
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
MOZ_ASSERT
(
writable
.
buf
=
=
buf
"
unexpected
buffer
relocation
"
)
;
auto
view
=
std
:
:
string_view
{
writable
.
buf
writable
.
len
}
;
auto
monthCode
=
ToMonthCode
(
view
)
;
MOZ_ASSERT
(
monthCode
!
=
MonthCode
{
}
"
invalid
month
code
returned
"
)
;
static
constexpr
auto
IrregularAdarII
=
MonthCode
{
6
true
}
;
static
constexpr
auto
RegularAdarII
=
MonthCode
{
6
}
;
if
(
calendar
=
=
CalendarId
:
:
Hebrew
&
&
monthCode
=
=
IrregularAdarII
)
{
monthCode
=
RegularAdarII
;
}
MOZ_ASSERT
(
CalendarMonthCodes
(
calendar
)
.
contains
(
monthCode
)
)
;
*
result
=
monthCode
;
return
true
;
}
static
bool
CalendarDateEra
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
if
(
!
CalendarEraRelevant
(
calendar
)
)
{
result
.
setUndefined
(
)
;
return
true
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
EraCode
era
;
if
(
!
CalendarDateEra
(
cx
calendar
dt
.
get
(
)
&
era
)
)
{
return
false
;
}
auto
*
str
=
NewStringCopy
<
CanGC
>
(
cx
CalendarEraName
(
calendar
era
)
)
;
if
(
!
str
)
{
return
false
;
}
result
.
setString
(
str
)
;
return
true
;
}
static
bool
CalendarDateEraYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
if
(
!
CalendarEraRelevant
(
calendar
)
)
{
result
.
setUndefined
(
)
;
return
true
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
year
=
capi
:
:
ICU4XDate_year_in_era
(
dt
.
get
(
)
)
;
result
.
setInt32
(
year
)
;
return
true
;
}
static
bool
CalendarDateYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
year
;
if
(
!
CalendarDateYear
(
cx
calendar
dt
.
get
(
)
&
year
)
)
{
return
false
;
}
result
.
setInt32
(
year
)
;
return
true
;
}
static
bool
CalendarDateMonth
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
month
=
capi
:
:
ICU4XDate_ordinal_month
(
dt
.
get
(
)
)
;
result
.
setInt32
(
month
)
;
return
true
;
}
static
bool
CalendarDateMonthCode
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
MonthCode
monthCode
;
if
(
!
CalendarDateMonthCode
(
cx
calendar
dt
.
get
(
)
&
monthCode
)
)
{
return
false
;
}
auto
*
str
=
NewStringCopy
<
CanGC
>
(
cx
std
:
:
string_view
{
monthCode
}
)
;
if
(
!
str
)
{
return
false
;
}
result
.
setString
(
str
)
;
return
true
;
}
static
bool
CalendarDateDay
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
day
=
capi
:
:
ICU4XDate_day_of_month
(
dt
.
get
(
)
)
;
result
.
setInt32
(
day
)
;
return
true
;
}
static
bool
CalendarDateDayOfWeek
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
static_assert
(
capi
:
:
ICU4XIsoWeekday_Monday
=
=
1
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Tuesday
=
=
2
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Wednesday
=
=
3
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Thursday
=
=
4
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Friday
=
=
5
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Saturday
=
=
6
)
;
static_assert
(
capi
:
:
ICU4XIsoWeekday_Sunday
=
=
7
)
;
capi
:
:
ICU4XIsoWeekday
day
=
capi
:
:
ICU4XDate_day_of_week
(
dt
.
get
(
)
)
;
result
.
setInt32
(
static_cast
<
int32_t
>
(
day
)
)
;
return
true
;
}
static
bool
CalendarDateDayOfYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
year
;
if
(
!
CalendarDateYear
(
cx
calendar
dt
.
get
(
)
&
year
)
)
{
return
false
;
}
auto
eraYear
=
CalendarEraYear
(
calendar
year
)
;
int32_t
dayOfYear
=
capi
:
:
ICU4XDate_day_of_month
(
dt
.
get
(
)
)
;
int32_t
month
=
capi
:
:
ICU4XDate_ordinal_month
(
dt
.
get
(
)
)
;
while
(
month
>
1
)
{
auto
previousMonth
=
CreateDateFrom
(
cx
calendar
cal
.
get
(
)
eraYear
-
-
month
1
TemporalOverflow
:
:
Reject
)
;
if
(
!
previousMonth
)
{
return
false
;
}
dayOfYear
+
=
capi
:
:
ICU4XDate_days_in_month
(
previousMonth
.
get
(
)
)
;
}
MOZ_ASSERT
(
dayOfYear
<
=
capi
:
:
ICU4XDate_days_in_year
(
dt
.
get
(
)
)
)
;
result
.
setInt32
(
dayOfYear
)
;
return
true
;
}
static
bool
CalendarDateWeekOfYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
if
(
calendar
!
=
CalendarId
:
:
Gregorian
)
{
result
.
setUndefined
(
)
;
return
true
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
auto
weekCal
=
CreateICU4WeekCalculator
(
cx
calendar
)
;
if
(
!
weekCal
)
{
return
false
;
}
auto
week
=
capi
:
:
ICU4XDate_week_of_year
(
dt
.
get
(
)
weekCal
.
get
(
)
)
;
if
(
!
week
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
result
.
setInt32
(
week
.
ok
.
week
)
;
return
true
;
}
static
bool
CalendarDateYearOfWeek
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
if
(
calendar
!
=
CalendarId
:
:
Gregorian
)
{
result
.
setUndefined
(
)
;
return
true
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
auto
weekCal
=
CreateICU4WeekCalculator
(
cx
calendar
)
;
if
(
!
weekCal
)
{
return
false
;
}
auto
week
=
capi
:
:
ICU4XDate_week_of_year
(
dt
.
get
(
)
weekCal
.
get
(
)
)
;
if
(
!
week
.
is_ok
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
int32_t
relative
=
0
;
switch
(
week
.
ok
.
unit
)
{
case
capi
:
:
ICU4XWeekRelativeUnit_Previous
:
relative
=
-
1
;
break
;
case
capi
:
:
ICU4XWeekRelativeUnit_Current
:
relative
=
0
;
break
;
case
capi
:
:
ICU4XWeekRelativeUnit_Next
:
relative
=
1
;
break
;
}
int32_t
calendarYear
;
if
(
!
CalendarDateYear
(
cx
calendar
dt
.
get
(
)
&
calendarYear
)
)
{
return
false
;
}
result
.
setInt32
(
calendarYear
+
relative
)
;
return
true
;
}
static
bool
CalendarDateDaysInWeek
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
result
.
setInt32
(
7
)
;
return
true
;
}
static
bool
CalendarDateDaysInMonth
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
days
=
capi
:
:
ICU4XDate_days_in_month
(
dt
.
get
(
)
)
;
result
.
setInt32
(
days
)
;
return
true
;
}
static
bool
CalendarDateDaysInYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
days
=
capi
:
:
ICU4XDate_days_in_year
(
dt
.
get
(
)
)
;
result
.
setInt32
(
days
)
;
return
true
;
}
static
bool
CalendarDateMonthsInYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
int32_t
months
=
capi
:
:
ICU4XDate_months_in_year
(
dt
.
get
(
)
)
;
result
.
setInt32
(
months
)
;
return
true
;
}
static
bool
CalendarDateInLeapYear
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
dt
=
CreateICU4XDate
(
cx
date
cal
.
get
(
)
)
;
if
(
!
dt
)
{
return
false
;
}
bool
inLeapYear
=
false
;
switch
(
calendar
)
{
case
CalendarId
:
:
ISO8601
:
case
CalendarId
:
:
Buddhist
:
case
CalendarId
:
:
Gregorian
:
case
CalendarId
:
:
Japanese
:
case
CalendarId
:
:
Coptic
:
case
CalendarId
:
:
Ethiopian
:
case
CalendarId
:
:
EthiopianAmeteAlem
:
case
CalendarId
:
:
Indian
:
case
CalendarId
:
:
Persian
:
case
CalendarId
:
:
ROC
:
{
MOZ_ASSERT
(
!
CalendarHasLeapMonths
(
calendar
)
)
;
int32_t
days
=
capi
:
:
ICU4XDate_days_in_year
(
dt
.
get
(
)
)
;
MOZ_ASSERT
(
days
=
=
365
|
|
days
=
=
366
)
;
inLeapYear
=
days
=
=
366
;
break
;
}
case
CalendarId
:
:
Islamic
:
case
CalendarId
:
:
IslamicCivil
:
case
CalendarId
:
:
IslamicRGSA
:
case
CalendarId
:
:
IslamicTabular
:
case
CalendarId
:
:
IslamicUmmAlQura
:
{
MOZ_ASSERT
(
!
CalendarHasLeapMonths
(
calendar
)
)
;
int32_t
days
=
capi
:
:
ICU4XDate_days_in_year
(
dt
.
get
(
)
)
;
MOZ_ASSERT
(
days
=
=
353
|
|
days
=
=
354
|
|
days
=
=
355
)
;
inLeapYear
=
days
=
=
355
;
break
;
}
case
CalendarId
:
:
Chinese
:
case
CalendarId
:
:
Dangi
:
case
CalendarId
:
:
Hebrew
:
{
MOZ_ASSERT
(
CalendarHasLeapMonths
(
calendar
)
)
;
int32_t
months
=
capi
:
:
ICU4XDate_months_in_year
(
dt
.
get
(
)
)
;
MOZ_ASSERT
(
months
=
=
12
|
|
months
=
=
13
)
;
inLeapYear
=
months
=
=
13
;
break
;
}
}
result
.
setBoolean
(
inLeapYear
)
;
return
true
;
}
static
bool
CalendarDateAddition
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
date
const
DateDuration
&
duration
TemporalOverflow
overflow
PlainDate
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
return
AddISODate
(
cx
date
duration
overflow
result
)
;
}
static
bool
CalendarDateDifference
(
JSContext
*
cx
CalendarId
calendar
const
PlainDate
&
one
const
PlainDate
&
two
TemporalUnit
largestUnit
DateDuration
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
*
result
=
DifferenceISODate
(
one
two
largestUnit
)
;
return
true
;
}
struct
EraYears
{
mozilla
:
:
Maybe
<
EraYear
>
fromEpoch
;
mozilla
:
:
Maybe
<
EraYear
>
fromEra
;
}
;
static
bool
CalendarFieldYear
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
EraYears
*
result
)
{
auto
era
=
fields
.
era
(
)
;
double
eraYear
=
fields
.
eraYear
(
)
;
MOZ_ASSERT
(
IsInteger
(
eraYear
)
|
|
std
:
:
isnan
(
eraYear
)
)
;
double
year
=
fields
.
year
(
)
;
MOZ_ASSERT
(
IsInteger
(
year
)
|
|
std
:
:
isnan
(
year
)
)
;
bool
hasRelevantEra
=
era
&
&
CalendarEraRelevant
(
calendar
)
;
mozilla
:
:
Maybe
<
EraYear
>
fromEpoch
;
if
(
!
std
:
:
isnan
(
year
)
)
{
int32_t
intYear
;
if
(
!
mozilla
:
:
NumberEqualsInt32
(
year
&
intYear
)
)
{
ReportCalendarFieldOverflow
(
cx
"
year
"
year
)
;
return
false
;
}
fromEpoch
=
mozilla
:
:
Some
(
CalendarEraYear
(
calendar
intYear
)
)
;
}
else
{
MOZ_ASSERT
(
hasRelevantEra
)
;
}
mozilla
:
:
Maybe
<
EraYear
>
fromEra
;
if
(
hasRelevantEra
)
{
MOZ_ASSERT
(
!
std
:
:
isnan
(
eraYear
)
)
;
auto
*
linearEra
=
era
-
>
ensureLinear
(
cx
)
;
if
(
!
linearEra
)
{
return
false
;
}
auto
eraCode
=
EraForString
(
calendar
linearEra
)
;
if
(
!
eraCode
)
{
if
(
auto
code
=
QuoteString
(
cx
era
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_ERA
code
.
get
(
)
)
;
}
return
false
;
}
int32_t
intEraYear
;
if
(
!
mozilla
:
:
NumberEqualsInt32
(
eraYear
&
intEraYear
)
)
{
ReportCalendarFieldOverflow
(
cx
"
eraYear
"
eraYear
)
;
return
false
;
}
fromEra
=
mozilla
:
:
Some
(
EraYear
{
*
eraCode
intEraYear
}
)
;
}
*
result
=
{
fromEpoch
fromEra
}
;
return
true
;
}
struct
Month
{
MonthCode
code
;
int32_t
ordinal
=
0
;
}
;
static
bool
CalendarFieldMonth
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
Month
*
result
)
{
double
month
=
fields
.
month
(
)
;
MOZ_ASSERT
(
(
IsInteger
(
month
)
&
&
month
>
0
)
|
|
std
:
:
isnan
(
month
)
)
;
auto
monthCode
=
fields
.
monthCode
(
)
;
int32_t
intMonth
=
0
;
if
(
!
std
:
:
isnan
(
month
)
)
{
if
(
!
mozilla
:
:
NumberEqualsInt32
(
month
&
intMonth
)
)
{
intMonth
=
0
;
}
const
int32_t
monthsPerYear
=
CalendarMonthsPerYear
(
calendar
)
;
if
(
intMonth
<
1
|
|
intMonth
>
monthsPerYear
)
{
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
month
"
month
)
;
return
false
;
}
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
;
intMonth
=
monthsPerYear
;
}
MOZ_ASSERT
(
intMonth
>
0
)
;
}
MonthCode
fromMonthCode
;
if
(
monthCode
)
{
if
(
!
ParseMonthCode
(
cx
calendar
monthCode
&
fromMonthCode
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
intMonth
>
0
)
;
}
*
result
=
{
fromMonthCode
intMonth
}
;
return
true
;
}
static
bool
CalendarFieldDay
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
int32_t
*
result
)
{
double
day
=
fields
.
day
(
)
;
MOZ_ASSERT
(
IsInteger
(
day
)
&
&
day
>
0
)
;
int32_t
intDay
;
if
(
!
mozilla
:
:
NumberEqualsInt32
(
day
&
intDay
)
)
{
intDay
=
0
;
}
int32_t
daysPerMonth
=
CalendarDaysInMonth
(
calendar
)
.
second
;
if
(
intDay
<
1
|
|
intDay
>
daysPerMonth
)
{
if
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
{
ReportCalendarFieldOverflow
(
cx
"
day
"
day
)
;
return
false
;
}
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
;
intDay
=
daysPerMonth
;
}
*
result
=
intDay
;
return
true
;
}
static
bool
CalendarFieldEraYearMatchesYear
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
const
capi
:
:
ICU4XDate
*
date
)
{
double
year
=
fields
.
year
(
)
;
MOZ_ASSERT
(
!
std
:
:
isnan
(
year
)
)
;
int32_t
intYear
;
MOZ_ALWAYS_TRUE
(
mozilla
:
:
NumberEqualsInt32
(
year
&
intYear
)
)
;
int32_t
yearFromEraYear
;
if
(
!
CalendarDateYear
(
cx
calendar
date
&
yearFromEraYear
)
)
{
return
false
;
}
if
(
intYear
!
=
yearFromEraYear
)
{
ToCStringBuf
yearCbuf
;
const
char
*
yearStr
=
NumberToCString
(
&
yearCbuf
intYear
)
;
ToCStringBuf
fromEraCbuf
;
const
char
*
fromEraStr
=
NumberToCString
(
&
fromEraCbuf
yearFromEraYear
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_YEAR
yearStr
fromEraStr
)
;
return
false
;
}
return
true
;
}
static
bool
CalendarFieldMonthCodeMatchesMonth
(
JSContext
*
cx
Handle
<
TemporalFields
>
fields
const
capi
:
:
ICU4XDate
*
date
int32_t
month
)
{
int32_t
ordinal
=
capi
:
:
ICU4XDate_ordinal_month
(
date
)
;
if
(
month
!
=
ordinal
)
{
ToCStringBuf
cbuf
;
const
char
*
monthStr
=
NumberToCString
(
&
cbuf
fields
.
month
(
)
)
;
if
(
auto
code
=
QuoteString
(
cx
fields
.
monthCode
(
)
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_MONTHCODE
code
.
get
(
)
monthStr
)
;
}
return
false
;
}
return
true
;
}
static
PlainDate
ToPlainDate
(
const
capi
:
:
ICU4XDate
*
date
)
{
UniqueICU4XIsoDate
isoDate
{
capi
:
:
ICU4XDate_to_iso
(
date
)
}
;
int32_t
isoYear
=
capi
:
:
ICU4XIsoDate_year
(
isoDate
.
get
(
)
)
;
int32_t
isoMonth
=
capi
:
:
ICU4XIsoDate_month
(
isoDate
.
get
(
)
)
;
MOZ_ASSERT
(
1
<
=
isoMonth
&
&
isoMonth
<
=
12
)
;
int32_t
isoDay
=
capi
:
:
ICU4XIsoDate_day_of_month
(
isoDate
.
get
(
)
)
;
MOZ_ASSERT
(
1
<
=
isoDay
&
&
isoDay
<
=
:
:
ISODaysInMonth
(
isoYear
isoMonth
)
)
;
return
{
isoYear
isoMonth
isoDay
}
;
}
static
bool
CalendarDateToISO
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
PlainDate
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
EraYears
eraYears
;
if
(
!
CalendarFieldYear
(
cx
calendar
fields
&
eraYears
)
)
{
return
false
;
}
Month
month
;
if
(
!
CalendarFieldMonth
(
cx
calendar
fields
overflow
&
month
)
)
{
return
false
;
}
int32_t
day
;
if
(
!
CalendarFieldDay
(
cx
calendar
fields
overflow
&
day
)
)
{
return
false
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
eraYear
=
eraYears
.
fromEra
?
*
eraYears
.
fromEra
:
*
eraYears
.
fromEpoch
;
UniqueICU4XDate
date
;
if
(
month
.
code
!
=
MonthCode
{
}
)
{
date
=
CreateDateFromCodes
(
cx
calendar
cal
.
get
(
)
eraYear
month
.
code
day
overflow
)
;
}
else
{
date
=
CreateDateFrom
(
cx
calendar
cal
.
get
(
)
eraYear
month
.
ordinal
day
overflow
)
;
}
if
(
!
date
)
{
return
false
;
}
if
(
eraYears
.
fromEpoch
&
&
eraYears
.
fromEra
)
{
if
(
!
CalendarFieldEraYearMatchesYear
(
cx
calendar
fields
date
.
get
(
)
)
)
{
return
false
;
}
}
if
(
month
.
code
!
=
MonthCode
{
}
&
&
month
.
ordinal
>
0
)
{
if
(
!
CalendarFieldMonthCodeMatchesMonth
(
cx
fields
date
.
get
(
)
month
.
ordinal
)
)
{
return
false
;
}
}
*
result
=
ToPlainDate
(
date
.
get
(
)
)
;
return
true
;
}
static
bool
CalendarMonthDayToISOReferenceDate
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
PlainDate
*
result
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
EraYears
eraYears
;
if
(
!
fields
.
monthCode
(
)
)
{
if
(
!
CalendarFieldYear
(
cx
calendar
fields
&
eraYears
)
)
{
return
false
;
}
}
Month
month
;
if
(
!
CalendarFieldMonth
(
cx
calendar
fields
overflow
&
month
)
)
{
return
false
;
}
MOZ_ASSERT
(
(
month
.
code
=
=
MonthCode
{
}
)
=
=
!
fields
.
monthCode
(
)
)
;
int32_t
day
;
if
(
!
CalendarFieldDay
(
cx
calendar
fields
overflow
&
day
)
)
{
return
false
;
}
auto
cal
=
CreateICU4XCalendar
(
cx
calendar
)
;
if
(
!
cal
)
{
return
false
;
}
auto
monthCode
=
month
.
code
;
if
(
monthCode
=
=
MonthCode
{
}
)
{
MOZ_ASSERT
(
month
.
ordinal
>
0
)
;
auto
eraYear
=
eraYears
.
fromEra
?
*
eraYears
.
fromEra
:
*
eraYears
.
fromEpoch
;
auto
date
=
CreateDateFrom
(
cx
calendar
cal
.
get
(
)
eraYear
month
.
ordinal
day
overflow
)
;
if
(
!
date
)
{
return
false
;
}
if
(
eraYears
.
fromEpoch
&
&
eraYears
.
fromEra
)
{
if
(
!
CalendarFieldEraYearMatchesYear
(
cx
calendar
fields
date
.
get
(
)
)
)
{
return
false
;
}
}
if
(
!
CalendarDateMonthCode
(
cx
calendar
date
.
get
(
)
&
monthCode
)
)
{
return
false
;
}
}
constexpr
auto
isoReferenceDate
=
PlainDate
{
1972
12
31
}
;
auto
fromIsoDate
=
CreateICU4XDate
(
cx
isoReferenceDate
cal
.
get
(
)
)
;
if
(
!
fromIsoDate
)
{
return
false
;
}
int32_t
calendarYear
;
if
(
!
CalendarDateYear
(
cx
calendar
fromIsoDate
.
get
(
)
&
calendarYear
)
)
{
return
false
;
}
int32_t
daysInMonth
=
CalendarDaysInMonth
(
calendar
monthCode
)
.
second
;
if
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
{
day
=
std
:
:
min
(
day
daysInMonth
)
;
}
else
{
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
;
if
(
day
>
daysInMonth
)
{
ReportCalendarFieldOverflow
(
cx
"
day
"
day
)
;
return
false
;
}
}
constexpr
size_t
maxIterations
=
10
'
000
;
UniqueICU4XDate
date
;
for
(
size_t
i
=
0
;
i
<
maxIterations
;
i
+
+
)
{
if
(
!
CheckForInterrupt
(
cx
)
)
{
return
false
;
}
auto
candidateYear
=
CalendarEraYear
(
calendar
calendarYear
)
;
auto
result
=
CreateDateFromCodes
(
calendar
cal
.
get
(
)
candidateYear
monthCode
day
)
;
if
(
result
.
isOk
(
)
)
{
auto
plainDate
=
ToPlainDate
(
result
.
inspect
(
)
.
get
(
)
)
;
if
(
plainDate
.
year
>
isoReferenceDate
.
year
)
{
calendarYear
-
=
1
;
continue
;
}
date
=
result
.
unwrap
(
)
;
break
;
}
switch
(
result
.
inspectErr
(
)
)
{
case
CalendarError
:
:
UnknownMonthCode
:
{
MOZ_ASSERT
(
CalendarHasLeapMonths
(
calendar
)
)
;
MOZ_ASSERT
(
monthCode
.
isLeapMonth
(
)
)
;
calendarYear
-
=
1
;
continue
;
}
case
CalendarError
:
:
Overflow
:
{
MOZ_ASSERT
(
day
>
CalendarDaysInMonth
(
calendar
monthCode
)
.
first
)
;
calendarYear
-
=
1
;
continue
;
}
case
CalendarError
:
:
OutOfRange
:
case
CalendarError
:
:
Underflow
:
case
CalendarError
:
:
UnknownEra
:
MOZ_ASSERT
(
false
"
unexpected
calendar
error
"
)
;
break
;
case
CalendarError
:
:
Generic
:
break
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR
)
;
return
false
;
}
if
(
!
date
)
{
ReportCalendarFieldOverflow
(
cx
"
day
"
day
)
;
return
false
;
}
if
(
month
.
code
!
=
MonthCode
{
}
&
&
month
.
ordinal
>
0
)
{
if
(
!
CalendarFieldMonthCodeMatchesMonth
(
cx
fields
date
.
get
(
)
month
.
ordinal
)
)
{
return
false
;
}
}
*
result
=
ToPlainDate
(
date
.
get
(
)
)
;
return
true
;
}
enum
class
FieldType
{
Date
YearMonth
MonthDay
}
;
static
FieldDescriptors
CalendarFieldDescriptors
(
CalendarId
calendar
FieldType
type
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
mozilla
:
:
EnumSet
<
TemporalField
>
relevant
;
mozilla
:
:
EnumSet
<
TemporalField
>
required
;
switch
(
type
)
{
case
FieldType
:
:
Date
:
{
relevant
=
{
TemporalField
:
:
Day
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
required
=
{
TemporalField
:
:
Day
}
;
if
(
CalendarEraRelevant
(
calendar
)
)
{
relevant
+
=
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
}
;
}
else
{
required
+
=
TemporalField
:
:
Year
;
}
break
;
}
case
FieldType
:
:
YearMonth
:
{
relevant
=
{
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
required
=
{
}
;
if
(
CalendarEraRelevant
(
calendar
)
)
{
relevant
+
=
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
}
;
}
else
{
required
+
=
TemporalField
:
:
Year
;
}
break
;
}
case
FieldType
:
:
MonthDay
:
{
relevant
=
{
TemporalField
:
:
Day
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
required
=
{
TemporalField
:
:
Day
}
;
if
(
CalendarEraRelevant
(
calendar
)
)
{
relevant
+
=
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
}
;
}
break
;
}
}
return
{
relevant
required
}
;
}
static
FieldDescriptors
CalendarFieldDescriptors
(
CalendarId
calendar
mozilla
:
:
EnumSet
<
CalendarField
>
type
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
mozilla
:
:
EnumSet
<
TemporalField
>
relevant
;
mozilla
:
:
EnumSet
<
TemporalField
>
required
;
if
(
type
.
contains
(
CalendarField
:
:
Year
)
&
&
CalendarEraRelevant
(
calendar
)
)
{
relevant
+
=
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
}
;
}
return
{
relevant
required
}
;
}
static
auto
CalendarFieldKeysToIgnore
(
CalendarId
calendar
mozilla
:
:
EnumSet
<
TemporalField
>
keys
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
static
constexpr
auto
eraOrEraYear
=
mozilla
:
:
EnumSet
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
}
;
static
constexpr
auto
eraOrAnyYear
=
mozilla
:
:
EnumSet
{
TemporalField
:
:
Era
TemporalField
:
:
EraYear
TemporalField
:
:
Year
}
;
static
constexpr
auto
monthOrMonthCode
=
mozilla
:
:
EnumSet
{
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
}
;
static
constexpr
auto
dayOrAnyMonth
=
mozilla
:
:
EnumSet
{
TemporalField
:
:
Day
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
}
;
auto
result
=
keys
;
if
(
!
(
keys
&
monthOrMonthCode
)
.
isEmpty
(
)
)
{
result
+
=
monthOrMonthCode
;
}
if
(
CalendarEraRelevant
(
calendar
)
&
&
!
(
keys
&
eraOrAnyYear
)
.
isEmpty
(
)
)
{
result
+
=
eraOrAnyYear
;
}
if
(
!
CalendarEraStartsAtYearBoundary
(
calendar
)
&
&
!
(
keys
&
dayOrAnyMonth
)
.
isEmpty
(
)
)
{
result
+
=
eraOrEraYear
;
}
return
result
;
}
static
bool
CalendarResolveFields
(
JSContext
*
cx
CalendarId
calendar
Handle
<
TemporalFields
>
fields
FieldType
type
)
{
MOZ_ASSERT
(
calendar
!
=
CalendarId
:
:
ISO8601
)
;
double
day
=
fields
.
day
(
)
;
MOZ_ASSERT
(
(
IsInteger
(
day
)
&
&
day
>
0
)
|
|
std
:
:
isnan
(
day
)
)
;
double
month
=
fields
.
month
(
)
;
MOZ_ASSERT
(
(
IsInteger
(
month
)
&
&
month
>
0
)
|
|
std
:
:
isnan
(
month
)
)
;
auto
monthCode
=
fields
.
monthCode
(
)
;
auto
era
=
fields
.
era
(
)
;
double
eraYear
=
fields
.
eraYear
(
)
;
MOZ_ASSERT
(
IsInteger
(
eraYear
)
|
|
std
:
:
isnan
(
eraYear
)
)
;
double
year
=
fields
.
year
(
)
;
MOZ_ASSERT
(
IsInteger
(
year
)
|
|
std
:
:
isnan
(
year
)
)
;
bool
requireDay
=
type
=
=
FieldType
:
:
Date
|
|
type
=
=
FieldType
:
:
MonthDay
;
bool
requireYear
=
type
=
=
FieldType
:
:
Date
|
|
type
=
=
FieldType
:
:
YearMonth
|
|
!
monthCode
;
const
char
*
missingField
=
nullptr
;
if
(
!
monthCode
&
&
std
:
:
isnan
(
month
)
)
{
missingField
=
"
monthCode
"
;
}
else
if
(
requireDay
&
&
std
:
:
isnan
(
day
)
)
{
missingField
=
"
day
"
;
}
else
if
(
!
CalendarEraRelevant
(
calendar
)
)
{
if
(
requireYear
&
&
std
:
:
isnan
(
year
)
)
{
missingField
=
"
year
"
;
}
}
else
{
if
(
(
era
&
&
std
:
:
isnan
(
eraYear
)
)
|
|
(
!
era
&
&
!
std
:
:
isnan
(
eraYear
)
)
)
{
missingField
=
era
?
"
eraYear
"
:
"
era
"
;
}
else
if
(
requireYear
&
&
std
:
:
isnan
(
year
)
&
&
std
:
:
isnan
(
eraYear
)
)
{
missingField
=
"
eraYear
"
;
}
}
if
(
missingField
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_MISSING_FIELD
missingField
)
;
return
false
;
}
return
true
;
}
static
bool
ToCalendarField
(
JSContext
*
cx
JSLinearString
*
linear
CalendarField
*
result
)
{
if
(
StringEqualsLiteral
(
linear
"
year
"
)
)
{
*
result
=
CalendarField
:
:
Year
;
return
true
;
}
if
(
StringEqualsLiteral
(
linear
"
month
"
)
)
{
*
result
=
CalendarField
:
:
Month
;
return
true
;
}
if
(
StringEqualsLiteral
(
linear
"
monthCode
"
)
)
{
*
result
=
CalendarField
:
:
MonthCode
;
return
true
;
}
if
(
StringEqualsLiteral
(
linear
"
day
"
)
)
{
*
result
=
CalendarField
:
:
Day
;
return
true
;
}
if
(
auto
chars
=
QuoteString
(
cx
linear
'
"
'
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INVALID_FIELD
chars
.
get
(
)
)
;
}
return
false
;
}
static
constexpr
auto
sortedCalendarFields
=
std
:
:
array
{
CalendarField
:
:
Day
CalendarField
:
:
Month
CalendarField
:
:
MonthCode
CalendarField
:
:
Year
}
;
using
SortedCalendarFields
=
SortedEnumSet
<
CalendarField
sortedCalendarFields
>
;
static
TemporalField
ToTemporalField
(
CalendarField
field
)
{
switch
(
field
)
{
case
CalendarField
:
:
Year
:
return
TemporalField
:
:
Year
;
case
CalendarField
:
:
Month
:
return
TemporalField
:
:
Month
;
case
CalendarField
:
:
MonthCode
:
return
TemporalField
:
:
MonthCode
;
case
CalendarField
:
:
Day
:
return
TemporalField
:
:
Day
;
}
MOZ_CRASH
(
"
invalid
calendar
field
name
"
)
;
}
static
bool
BuiltinCalendarFields
(
JSContext
*
cx
CalendarId
calendarId
mozilla
:
:
EnumSet
<
CalendarField
>
fieldNames
CalendarFieldNames
&
result
)
{
MOZ_ASSERT
(
result
.
empty
(
)
)
;
mozilla
:
:
EnumSet
<
TemporalField
>
temporalFields
{
}
;
for
(
auto
fieldName
:
fieldNames
)
{
temporalFields
+
=
ToTemporalField
(
fieldName
)
;
}
if
(
calendarId
!
=
CalendarId
:
:
ISO8601
)
{
auto
extraFieldDescriptors
=
CalendarFieldDescriptors
(
calendarId
fieldNames
)
;
temporalFields
+
=
extraFieldDescriptors
.
relevant
;
temporalFields
+
=
extraFieldDescriptors
.
required
;
}
if
(
!
result
.
reserve
(
temporalFields
.
size
(
)
)
)
{
return
false
;
}
for
(
auto
field
:
SortedTemporalFields
{
temporalFields
}
)
{
auto
*
name
=
ToPropertyName
(
cx
field
)
;
result
.
infallibleAppend
(
NameToId
(
name
)
)
;
}
return
true
;
}
static
bool
BuiltinCalendarFields
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
Value
>
fields
MutableHandle
<
Value
>
result
)
{
JS
:
:
ForOfIterator
iterator
(
cx
)
;
if
(
!
iterator
.
init
(
fields
)
)
{
return
false
;
}
JS
:
:
RootedVector
<
Value
>
fieldNames
(
cx
)
;
mozilla
:
:
EnumSet
<
CalendarField
>
seen
;
Rooted
<
Value
>
nextValue
(
cx
)
;
Rooted
<
JSLinearString
*
>
linear
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iterator
.
next
(
&
nextValue
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
nextValue
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
nextValue
nullptr
"
not
a
string
"
)
;
iterator
.
closeThrow
(
)
;
return
false
;
}
linear
=
nextValue
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
CalendarField
field
;
if
(
!
ToCalendarField
(
cx
linear
&
field
)
)
{
iterator
.
closeThrow
(
)
;
return
false
;
}
if
(
seen
.
contains
(
field
)
)
{
if
(
auto
chars
=
QuoteString
(
cx
linear
'
"
'
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_DUPLICATE_FIELD
chars
.
get
(
)
)
;
}
iterator
.
closeThrow
(
)
;
return
false
;
}
if
(
!
fieldNames
.
append
(
nextValue
)
)
{
return
false
;
}
seen
+
=
field
;
}
if
(
calendarId
!
=
CalendarId
:
:
ISO8601
)
{
auto
extraFieldDescriptors
=
CalendarFieldDescriptors
(
calendarId
seen
)
;
mozilla
:
:
EnumSet
<
TemporalField
>
temporalFields
{
}
;
temporalFields
+
=
extraFieldDescriptors
.
relevant
;
temporalFields
+
=
extraFieldDescriptors
.
required
;
for
(
auto
fieldName
:
seen
)
{
temporalFields
-
=
ToTemporalField
(
fieldName
)
;
}
if
(
!
fieldNames
.
reserve
(
fieldNames
.
length
(
)
+
temporalFields
.
size
(
)
)
)
{
return
false
;
}
for
(
auto
field
:
SortedTemporalFields
{
temporalFields
}
)
{
auto
*
name
=
ToPropertyName
(
cx
field
)
;
fieldNames
.
infallibleAppend
(
StringValue
(
name
)
)
;
}
}
auto
*
array
=
NewDenseCopiedArray
(
cx
fieldNames
.
length
(
)
fieldNames
.
begin
(
)
)
;
if
(
!
array
)
{
return
false
;
}
result
.
setObject
(
*
array
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
CalendarFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
mozilla
:
:
EnumSet
<
CalendarField
>
fieldNames
MutableHandle
<
CalendarFieldNames
>
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
Fields
)
)
;
auto
fields
=
calendar
.
fields
(
)
;
if
(
!
fields
)
{
bool
arrayIterationSane
;
if
(
calendar
.
receiver
(
)
.
isString
(
)
)
{
arrayIterationSane
=
true
;
}
else
{
if
(
!
IsArrayIterationSane
(
cx
&
arrayIterationSane
)
)
{
return
false
;
}
}
if
(
arrayIterationSane
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarFields
(
cx
calendarId
fieldNames
result
.
get
(
)
)
;
}
}
auto
*
array
=
NewDenseFullyAllocatedArray
(
cx
fieldNames
.
size
(
)
)
;
if
(
!
array
)
{
return
false
;
}
array
-
>
setDenseInitializedLength
(
fieldNames
.
size
(
)
)
;
size_t
index
=
0
;
for
(
auto
calendarField
:
SortedCalendarFields
{
fieldNames
}
)
{
auto
*
name
=
ToPropertyName
(
cx
:
:
ToTemporalField
(
calendarField
)
)
;
array
-
>
initDenseElement
(
index
+
+
StringValue
(
name
)
)
;
}
MOZ_ASSERT
(
index
=
=
fieldNames
.
size
(
)
)
;
Rooted
<
Value
>
fieldsArray
(
cx
ObjectValue
(
*
array
)
)
;
Rooted
<
Value
>
calendarFieldNames
(
cx
)
;
if
(
fields
)
{
Rooted
<
Value
>
fieldsFn
(
cx
ObjectValue
(
*
fields
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
if
(
!
Call
(
cx
fieldsFn
thisv
fieldsArray
&
calendarFieldNames
)
)
{
return
false
;
}
}
else
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
if
(
!
BuiltinCalendarFields
(
cx
calendarId
fieldsArray
&
calendarFieldNames
)
)
{
return
false
;
}
}
if
(
!
IterableToListOfStrings
(
cx
calendarFieldNames
result
)
)
{
return
false
;
}
return
SortTemporalFieldNames
(
cx
result
.
get
(
)
)
;
}
static
bool
RequireIntegralNumber
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
MOZ_LIKELY
(
value
.
isInt32
(
)
)
)
{
result
.
set
(
value
)
;
return
true
;
}
if
(
value
.
isDouble
(
)
)
{
double
d
=
value
.
toDouble
(
)
;
if
(
js
:
:
IsInteger
(
d
)
)
{
result
.
setNumber
(
d
)
;
return
true
;
}
if
(
auto
str
=
QuoteString
(
cx
name
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_INTEGER
str
.
get
(
)
)
;
}
return
false
;
}
if
(
auto
str
=
QuoteString
(
cx
name
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_UNEXPECTED_TYPE
str
.
get
(
)
"
not
a
number
"
)
;
}
return
false
;
}
static
bool
RequireIntegralPositiveNumber
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
!
RequireIntegralNumber
(
cx
value
name
result
)
)
{
return
false
;
}
if
(
result
.
toNumber
(
)
<
=
0
)
{
if
(
auto
str
=
QuoteString
(
cx
name
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_NUMBER
str
.
get
(
)
)
;
}
return
false
;
}
return
true
;
}
static
bool
RequireIntegralNumberOrUndefined
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
value
.
isUndefined
(
)
)
{
result
.
setUndefined
(
)
;
return
true
;
}
return
RequireIntegralNumber
(
cx
value
name
result
)
;
}
static
bool
RequireIntegralPositiveNumberOrUndefined
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
value
.
isUndefined
(
)
)
{
result
.
setUndefined
(
)
;
return
true
;
}
return
RequireIntegralPositiveNumber
(
cx
value
name
result
)
;
}
static
bool
RequireString
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
MOZ_LIKELY
(
value
.
isString
(
)
)
)
{
result
.
set
(
value
)
;
return
true
;
}
if
(
auto
str
=
QuoteString
(
cx
name
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_UNEXPECTED_TYPE
str
.
get
(
)
"
not
a
string
"
)
;
}
return
false
;
}
static
bool
RequireStringOrUndefined
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
value
.
isUndefined
(
)
)
{
result
.
setUndefined
(
)
;
return
true
;
}
return
RequireString
(
cx
value
name
result
)
;
}
static
bool
RequireBoolean
(
JSContext
*
cx
Handle
<
Value
>
value
Handle
<
PropertyName
*
>
name
MutableHandle
<
Value
>
result
)
{
if
(
MOZ_LIKELY
(
value
.
isBoolean
(
)
)
)
{
result
.
set
(
value
)
;
return
true
;
}
if
(
auto
str
=
QuoteString
(
cx
name
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_UNEXPECTED_TYPE
str
.
get
(
)
"
not
a
boolean
"
)
;
}
return
false
;
}
using
BuiltinCalendarMethod
=
bool
(
*
)
(
JSContext
*
cx
CalendarId
const
PlainDate
&
MutableHandle
<
Value
>
)
;
using
CalendarConversion
=
bool
(
*
)
(
JSContext
*
Handle
<
Value
>
Handle
<
PropertyName
*
>
MutableHandle
<
Value
>
)
;
template
<
BuiltinCalendarMethod
builtin
CalendarConversion
conversion
>
static
bool
CallCalendarMethod
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
JSNative
native
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendar
.
isString
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
)
;
return
builtin
(
cx
calendarId
date
result
)
;
}
Rooted
<
JSObject
*
>
calendarObj
(
cx
calendar
.
toObject
(
)
)
;
JSObject
*
fn
=
GetMethod
(
cx
calendarObj
name
)
;
if
(
!
fn
)
{
return
false
;
}
if
(
calendarObj
-
>
is
<
CalendarObject
>
(
)
&
&
IsNativeFunction
(
fn
native
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
)
;
return
builtin
(
cx
calendarId
date
result
)
;
}
Rooted
<
JS
:
:
Value
>
fnVal
(
cx
ObjectValue
(
*
fn
)
)
;
Rooted
<
JS
:
:
Value
>
dateLikeValue
(
cx
ObjectValue
(
*
dateLike
)
)
;
if
(
!
Call
(
cx
fnVal
calendarObj
dateLikeValue
result
)
)
{
return
false
;
}
return
conversion
(
cx
result
name
result
)
;
}
static
bool
BuiltinCalendarEra
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setUndefined
(
)
;
return
true
;
}
return
CalendarDateEra
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_era
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarEra
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarEra
RequireStringOrUndefined
>
(
cx
cx
-
>
names
(
)
.
era
Calendar_era
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEra
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEra
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEra
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEra
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEra
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEra
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEra
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarEra
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarEraYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setUndefined
(
)
;
return
true
;
}
return
CalendarDateEraYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_eraYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarEraYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarEraYear
RequireIntegralNumberOrUndefined
>
(
cx
cx
-
>
names
(
)
.
eraYear
Calendar_eraYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEraYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEraYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEraYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEraYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEraYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarEraYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEraYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarEraYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
date
.
year
)
;
return
true
;
}
return
CalendarDateYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_year
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarYear
RequireIntegralNumber
>
(
cx
cx
-
>
names
(
)
.
year
Calendar_year
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarMonth
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
date
.
month
)
;
return
true
;
}
return
CalendarDateMonth
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_month
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarMonth
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
month
Calendar_month
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarMonth
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarMonthCode
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
JSString
*
str
=
ISOMonthCode
(
cx
date
.
month
)
;
if
(
!
str
)
{
return
false
;
}
result
.
setString
(
str
)
;
return
true
;
}
return
CalendarDateMonthCode
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_monthCode
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarMonthCode
RequireString
>
(
cx
cx
-
>
names
(
)
.
monthCode
Calendar_monthCode
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonthCode
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonthCode
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainMonthDayObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonthCode
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarMonthCode
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthCode
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarMonthCode
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDay
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
date
.
day
)
;
return
true
;
}
return
CalendarDateDay
(
cx
calendarId
date
result
)
;
}
static
bool
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
Day
)
)
;
auto
day
=
calendar
.
day
(
)
;
if
(
!
day
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDay
(
cx
calendarId
date
result
)
;
}
Rooted
<
Value
>
fn
(
cx
ObjectValue
(
*
day
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
JS
:
:
Value
>
dateLikeValue
(
cx
ObjectValue
(
*
dateLike
)
)
;
if
(
!
Call
(
cx
fn
thisv
dateLikeValue
result
)
)
{
return
false
;
}
return
RequireIntegralPositiveNumber
(
cx
result
cx
-
>
names
(
)
.
day
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
Rooted
<
CalendarRecord
>
calendarRec
(
cx
)
;
if
(
!
CreateCalendarMethodsRecord
(
cx
calendar
{
CalendarMethod
:
:
Day
}
&
calendarRec
)
)
{
return
false
;
}
return
CalendarDay
(
cx
calendarRec
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
Rooted
<
CalendarRecord
>
calendarRec
(
cx
)
;
if
(
!
CreateCalendarMethodsRecord
(
cx
calendar
{
CalendarMethod
:
:
Day
}
&
calendarRec
)
)
{
return
false
;
}
return
CalendarDay
(
cx
calendarRec
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainMonthDayObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
Rooted
<
CalendarRecord
>
calendarRec
(
cx
)
;
if
(
!
CreateCalendarMethodsRecord
(
cx
calendar
{
CalendarMethod
:
:
Day
}
&
calendarRec
)
)
{
return
false
;
}
return
CalendarDay
(
cx
calendarRec
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateObject
*
>
dateLike
(
cx
CreateTemporalDate
(
cx
date
calendar
.
receiver
(
)
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDay
(
cx
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDay
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
.
receiver
(
)
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDay
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDayOfWeek
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
ToISODayOfWeek
(
date
)
)
;
return
true
;
}
return
CalendarDateDayOfWeek
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_dayOfWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarDayOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarDayOfWeek
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
dayOfWeek
Calendar_dayOfWeek
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDayOfWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDayOfWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDayOfWeek
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDayOfYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
ToISODayOfYear
(
date
)
)
;
return
true
;
}
return
CalendarDateDayOfYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_dayOfYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarDayOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarDayOfYear
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
dayOfYear
Calendar_dayOfYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDayOfYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDayOfYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDayOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDayOfYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarWeekOfYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
ToISOWeekOfYear
(
date
)
.
week
)
;
return
true
;
}
return
CalendarDateWeekOfYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_weekOfYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarWeekOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarWeekOfYear
RequireIntegralPositiveNumberOrUndefined
>
(
cx
cx
-
>
names
(
)
.
weekOfYear
Calendar_weekOfYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarWeekOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarWeekOfYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarWeekOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarWeekOfYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarWeekOfYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarWeekOfYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarYearOfWeek
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
ToISOWeekOfYear
(
date
)
.
year
)
;
return
true
;
}
return
CalendarDateYearOfWeek
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_yearOfWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarYearOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarYearOfWeek
RequireIntegralNumberOrUndefined
>
(
cx
cx
-
>
names
(
)
.
yearOfWeek
Calendar_yearOfWeek
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYearOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarYearOfWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYearOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarYearOfWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarYearOfWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarYearOfWeek
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDaysInWeek
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
7
)
;
return
true
;
}
return
CalendarDateDaysInWeek
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_daysInWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarDaysInWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarDaysInWeek
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
daysInWeek
Calendar_daysInWeek
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInWeek
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInWeek
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDaysInWeek
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDaysInMonth
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
:
:
ISODaysInMonth
(
date
.
year
date
.
month
)
)
;
return
true
;
}
return
CalendarDateDaysInMonth
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_daysInMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarDaysInMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarDaysInMonth
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
daysInMonth
Calendar_daysInMonth
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInMonth
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInMonth
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDaysInMonth
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarDaysInYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
ISODaysInYear
(
date
.
year
)
)
;
return
true
;
}
return
CalendarDateDaysInYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_daysInYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarDaysInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarDaysInYear
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
daysInYear
Calendar_daysInYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
CalendarDaysInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDaysInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarDaysInYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarMonthsInYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setInt32
(
12
)
;
return
true
;
}
return
CalendarDateMonthsInYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_monthsInYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarMonthsInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarMonthsInYear
RequireIntegralPositiveNumber
>
(
cx
cx
-
>
names
(
)
.
monthsInYear
Calendar_monthsInYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthsInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarMonthsInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthsInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarMonthsInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthsInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarMonthsInYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarMonthsInYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarMonthsInYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
BuiltinCalendarInLeapYear
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
result
.
setBoolean
(
IsISOLeapYear
(
date
.
year
)
)
;
return
true
;
}
return
CalendarDateInLeapYear
(
cx
calendarId
date
result
)
;
}
static
bool
Calendar_inLeapYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
CalendarInLeapYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
JSObject
*
>
dateLike
const
PlainDate
&
date
MutableHandle
<
Value
>
result
)
{
return
CallCalendarMethod
<
BuiltinCalendarInLeapYear
RequireBoolean
>
(
cx
cx
-
>
names
(
)
.
inLeapYear
Calendar_inLeapYear
calendar
dateLike
date
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarInLeapYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarInLeapYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarInLeapYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainDateTimeObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarInLeapYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarInLeapYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
Handle
<
PlainYearMonthObject
*
>
dateLike
MutableHandle
<
Value
>
result
)
{
return
:
:
CalendarInLeapYear
(
cx
calendar
dateLike
ToPlainDate
(
dateLike
)
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarInLeapYear
(
JSContext
*
cx
Handle
<
CalendarValue
>
calendar
const
PlainDateTime
&
dateTime
MutableHandle
<
Value
>
result
)
{
Rooted
<
PlainDateTimeObject
*
>
dateLike
(
cx
CreateTemporalDateTime
(
cx
dateTime
calendar
)
)
;
if
(
!
dateLike
)
{
return
false
;
}
return
:
:
CalendarInLeapYear
(
cx
calendar
dateLike
dateTime
.
date
result
)
;
}
static
bool
ISOResolveMonth
(
JSContext
*
cx
MutableHandle
<
TemporalFields
>
fields
)
{
double
month
=
fields
.
month
(
)
;
MOZ_ASSERT
(
(
IsInteger
(
month
)
&
&
month
>
0
)
|
|
std
:
:
isnan
(
month
)
)
;
Handle
<
JSString
*
>
monthCode
=
fields
.
monthCode
(
)
;
if
(
!
monthCode
)
{
if
(
std
:
:
isnan
(
month
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_MISSING_FIELD
"
monthCode
"
)
;
return
false
;
}
return
true
;
}
MonthCode
parsedMonthCode
;
if
(
!
ParseMonthCode
(
cx
CalendarId
:
:
ISO8601
monthCode
&
parsedMonthCode
)
)
{
return
false
;
}
int32_t
ordinal
=
parsedMonthCode
.
ordinal
(
)
;
if
(
!
std
:
:
isnan
(
month
)
&
&
month
!
=
ordinal
)
{
ToCStringBuf
cbuf
;
const
char
*
monthStr
=
NumberToCString
(
&
cbuf
month
)
;
if
(
auto
code
=
QuoteString
(
cx
monthCode
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_MONTHCODE
code
.
get
(
)
monthStr
)
;
}
return
false
;
}
fields
.
month
(
)
=
ordinal
;
return
true
;
}
static
bool
ISODateFromFields
(
JSContext
*
cx
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
PlainDate
*
result
)
{
double
year
=
fields
.
year
(
)
;
double
month
=
fields
.
month
(
)
;
double
day
=
fields
.
day
(
)
;
MOZ_ASSERT
(
!
std
:
:
isnan
(
year
)
&
&
!
std
:
:
isnan
(
month
)
&
&
!
std
:
:
isnan
(
day
)
)
;
RegulatedISODate
regulated
;
if
(
!
RegulateISODate
(
cx
year
month
day
overflow
&
regulated
)
)
{
return
false
;
}
int32_t
intYear
;
if
(
!
mozilla
:
:
NumberEqualsInt32
(
regulated
.
year
&
intYear
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PLAIN_DATE_INVALID
)
;
return
false
;
}
*
result
=
{
intYear
regulated
.
month
regulated
.
day
}
;
return
true
;
}
static
PlainDateObject
*
BuiltinCalendarDateFromFields
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
JSObject
*
>
fields
Handle
<
JSObject
*
>
maybeOptions
)
{
auto
relevantFieldNames
=
{
TemporalField
:
:
Day
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
Rooted
<
TemporalFields
>
dateFields
(
cx
)
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
TemporalField
:
:
Day
TemporalField
:
:
Year
}
&
dateFields
)
)
{
return
nullptr
;
}
}
else
{
auto
calendarRelevantFieldDescriptors
=
CalendarFieldDescriptors
(
calendarId
FieldType
:
:
Date
)
;
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
}
calendarRelevantFieldDescriptors
&
dateFields
)
)
{
return
nullptr
;
}
}
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
maybeOptions
)
{
if
(
!
GetTemporalOverflowOption
(
cx
maybeOptions
&
overflow
)
)
{
return
nullptr
;
}
}
PlainDate
result
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
ISOResolveMonth
(
cx
&
dateFields
)
)
{
return
nullptr
;
}
if
(
!
ISODateFromFields
(
cx
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
CalendarResolveFields
(
cx
calendarId
dateFields
FieldType
:
:
Date
)
)
{
return
nullptr
;
}
if
(
!
CalendarDateToISO
(
cx
calendarId
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
Rooted
<
CalendarValue
>
calendar
(
cx
CalendarValue
(
calendarId
)
)
;
return
CreateTemporalDate
(
cx
result
calendar
)
;
}
static
Wrapped
<
PlainDateObject
*
>
CalendarDateFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
JSObject
*
>
fields
Handle
<
PlainObject
*
>
maybeOptions
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateFromFields
)
)
;
auto
dateFromFields
=
calendar
.
dateFromFields
(
)
;
if
(
!
dateFromFields
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDateFromFields
(
cx
calendarId
fields
maybeOptions
)
;
}
Rooted
<
Value
>
dateFromFieldsFn
(
cx
ObjectValue
(
*
dateFromFields
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
rval
(
cx
)
;
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
fields
)
;
if
(
maybeOptions
)
{
args
[
1
]
.
setObject
(
*
maybeOptions
)
;
}
else
{
args
[
1
]
.
setUndefined
(
)
;
}
if
(
!
Call
(
cx
dateFromFieldsFn
thisv
args
&
rval
)
)
{
return
nullptr
;
}
if
(
!
rval
.
isObject
(
)
|
|
!
rval
.
toObject
(
)
.
canUnwrapAs
<
PlainDateObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
rval
nullptr
"
not
a
PlainDate
object
"
)
;
return
nullptr
;
}
return
&
rval
.
toObject
(
)
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
)
{
return
:
:
CalendarDateFromFields
(
cx
calendar
fields
nullptr
)
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
Handle
<
PlainObject
*
>
options
)
{
return
:
:
CalendarDateFromFields
(
cx
calendar
fields
options
)
;
}
struct
RegulatedISOYearMonth
final
{
double
year
=
0
;
int32_t
month
=
0
;
}
;
static
bool
RegulateISOYearMonth
(
JSContext
*
cx
double
year
double
month
TemporalOverflow
overflow
RegulatedISOYearMonth
*
result
)
{
MOZ_ASSERT
(
IsInteger
(
year
)
)
;
MOZ_ASSERT
(
IsInteger
(
month
)
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
{
month
=
std
:
:
clamp
(
month
1
.
0
12
.
0
)
;
*
result
=
{
year
int32_t
(
month
)
}
;
return
true
;
}
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
;
if
(
month
<
1
|
|
month
>
12
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PLAIN_YEAR_MONTH_INVALID
)
;
return
false
;
}
*
result
=
{
year
int32_t
(
month
)
}
;
return
true
;
}
static
bool
ISOYearMonthFromFields
(
JSContext
*
cx
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
PlainDate
*
result
)
{
double
year
=
fields
.
year
(
)
;
double
month
=
fields
.
month
(
)
;
MOZ_ASSERT
(
!
std
:
:
isnan
(
year
)
&
&
!
std
:
:
isnan
(
month
)
)
;
RegulatedISOYearMonth
regulated
;
if
(
!
RegulateISOYearMonth
(
cx
year
month
overflow
&
regulated
)
)
{
return
false
;
}
int32_t
intYear
;
if
(
!
mozilla
:
:
NumberEqualsInt32
(
regulated
.
year
&
intYear
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PLAIN_YEAR_MONTH_INVALID
)
;
return
false
;
}
*
result
=
{
intYear
regulated
.
month
1
}
;
return
true
;
}
static
PlainYearMonthObject
*
BuiltinCalendarYearMonthFromFields
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
JSObject
*
>
fields
Handle
<
JSObject
*
>
maybeOptions
)
{
auto
relevantFieldNames
=
{
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
Rooted
<
TemporalFields
>
dateFields
(
cx
)
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
TemporalField
:
:
Year
}
&
dateFields
)
)
{
return
nullptr
;
}
}
else
{
auto
calendarRelevantFieldDescriptors
=
CalendarFieldDescriptors
(
calendarId
FieldType
:
:
YearMonth
)
;
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
}
calendarRelevantFieldDescriptors
&
dateFields
)
)
{
return
nullptr
;
}
int32_t
firstDayIndex
=
1
;
dateFields
.
day
(
)
=
firstDayIndex
;
}
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
maybeOptions
)
{
if
(
!
GetTemporalOverflowOption
(
cx
maybeOptions
&
overflow
)
)
{
return
nullptr
;
}
}
PlainDate
result
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
ISOResolveMonth
(
cx
&
dateFields
)
)
{
return
nullptr
;
}
if
(
!
ISOYearMonthFromFields
(
cx
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
CalendarResolveFields
(
cx
calendarId
dateFields
FieldType
:
:
YearMonth
)
)
{
return
nullptr
;
}
if
(
!
CalendarDateToISO
(
cx
calendarId
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
Rooted
<
CalendarValue
>
calendar
(
cx
CalendarValue
(
calendarId
)
)
;
return
CreateTemporalYearMonth
(
cx
result
calendar
)
;
}
static
Wrapped
<
PlainYearMonthObject
*
>
CalendarYearMonthFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
JSObject
*
>
fields
Handle
<
PlainObject
*
>
maybeOptions
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
YearMonthFromFields
)
)
;
auto
yearMonthFromFields
=
calendar
.
yearMonthFromFields
(
)
;
if
(
!
yearMonthFromFields
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarYearMonthFromFields
(
cx
calendarId
fields
maybeOptions
)
;
}
Rooted
<
Value
>
yearMonthFromFieldsFn
(
cx
ObjectValue
(
*
yearMonthFromFields
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
rval
(
cx
)
;
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
fields
)
;
if
(
maybeOptions
)
{
args
[
1
]
.
setObject
(
*
maybeOptions
)
;
}
else
{
args
[
1
]
.
setUndefined
(
)
;
}
if
(
!
Call
(
cx
yearMonthFromFieldsFn
thisv
args
&
rval
)
)
{
return
nullptr
;
}
if
(
!
rval
.
isObject
(
)
|
|
!
rval
.
toObject
(
)
.
canUnwrapAs
<
PlainYearMonthObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
rval
nullptr
"
not
a
PlainYearMonth
object
"
)
;
return
nullptr
;
}
return
&
rval
.
toObject
(
)
;
}
Wrapped
<
PlainYearMonthObject
*
>
js
:
:
temporal
:
:
CalendarYearMonthFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
)
{
return
:
:
CalendarYearMonthFromFields
(
cx
calendar
fields
nullptr
)
;
}
Wrapped
<
PlainYearMonthObject
*
>
js
:
:
temporal
:
:
CalendarYearMonthFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainYearMonthObject
*
>
fields
)
{
return
:
:
CalendarYearMonthFromFields
(
cx
calendar
fields
nullptr
)
;
}
Wrapped
<
PlainYearMonthObject
*
>
js
:
:
temporal
:
:
CalendarYearMonthFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
Handle
<
PlainObject
*
>
options
)
{
return
:
:
CalendarYearMonthFromFields
(
cx
calendar
fields
options
)
;
}
static
bool
ISOMonthDayFromFields
(
JSContext
*
cx
Handle
<
TemporalFields
>
fields
TemporalOverflow
overflow
PlainDate
*
result
)
{
double
month
=
fields
.
month
(
)
;
double
day
=
fields
.
day
(
)
;
MOZ_ASSERT
(
!
std
:
:
isnan
(
month
)
)
;
MOZ_ASSERT
(
!
std
:
:
isnan
(
day
)
)
;
double
year
=
fields
.
year
(
)
;
int32_t
referenceISOYear
=
1972
;
double
y
=
std
:
:
isnan
(
year
)
?
referenceISOYear
:
year
;
RegulatedISODate
regulated
;
if
(
!
RegulateISODate
(
cx
y
month
day
overflow
&
regulated
)
)
{
return
false
;
}
*
result
=
{
referenceISOYear
regulated
.
month
regulated
.
day
}
;
return
true
;
}
static
PlainMonthDayObject
*
BuiltinCalendarMonthDayFromFields
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
JSObject
*
>
fields
Handle
<
JSObject
*
>
maybeOptions
)
{
auto
relevantFieldNames
=
{
TemporalField
:
:
Day
TemporalField
:
:
Month
TemporalField
:
:
MonthCode
TemporalField
:
:
Year
}
;
Rooted
<
TemporalFields
>
dateFields
(
cx
)
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
TemporalField
:
:
Day
}
&
dateFields
)
)
{
return
nullptr
;
}
}
else
{
auto
calendarRelevantFieldDescriptors
=
CalendarFieldDescriptors
(
calendarId
FieldType
:
:
MonthDay
)
;
if
(
!
PrepareTemporalFields
(
cx
fields
relevantFieldNames
{
}
calendarRelevantFieldDescriptors
&
dateFields
)
)
{
return
nullptr
;
}
}
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
maybeOptions
)
{
if
(
!
GetTemporalOverflowOption
(
cx
maybeOptions
&
overflow
)
)
{
return
nullptr
;
}
}
PlainDate
result
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
if
(
!
ISOResolveMonth
(
cx
&
dateFields
)
)
{
return
nullptr
;
}
if
(
!
ISOMonthDayFromFields
(
cx
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
CalendarResolveFields
(
cx
calendarId
dateFields
FieldType
:
:
MonthDay
)
)
{
return
nullptr
;
}
if
(
!
CalendarMonthDayToISOReferenceDate
(
cx
calendarId
dateFields
overflow
&
result
)
)
{
return
nullptr
;
}
}
Rooted
<
CalendarValue
>
calendar
(
cx
CalendarValue
(
calendarId
)
)
;
return
CreateTemporalMonthDay
(
cx
result
calendar
)
;
}
static
Wrapped
<
PlainMonthDayObject
*
>
CalendarMonthDayFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
JSObject
*
>
fields
Handle
<
PlainObject
*
>
maybeOptions
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
MonthDayFromFields
)
)
;
auto
monthDayFromFields
=
calendar
.
monthDayFromFields
(
)
;
if
(
!
monthDayFromFields
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarMonthDayFromFields
(
cx
calendarId
fields
maybeOptions
)
;
}
Rooted
<
Value
>
monthDayFromFieldsFn
(
cx
ObjectValue
(
*
monthDayFromFields
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
rval
(
cx
)
;
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
fields
)
;
if
(
maybeOptions
)
{
args
[
1
]
.
setObject
(
*
maybeOptions
)
;
}
else
{
args
[
1
]
.
setUndefined
(
)
;
}
if
(
!
Call
(
cx
monthDayFromFieldsFn
thisv
args
&
rval
)
)
{
return
nullptr
;
}
if
(
!
rval
.
isObject
(
)
|
|
!
rval
.
toObject
(
)
.
canUnwrapAs
<
PlainMonthDayObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
rval
nullptr
"
not
a
PlainMonthDay
object
"
)
;
return
nullptr
;
}
return
&
rval
.
toObject
(
)
;
}
Wrapped
<
PlainMonthDayObject
*
>
js
:
:
temporal
:
:
CalendarMonthDayFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
)
{
return
:
:
CalendarMonthDayFromFields
(
cx
calendar
fields
nullptr
)
;
}
Wrapped
<
PlainMonthDayObject
*
>
js
:
:
temporal
:
:
CalendarMonthDayFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainMonthDayObject
*
>
fields
)
{
return
:
:
CalendarMonthDayFromFields
(
cx
calendar
fields
nullptr
)
;
}
Wrapped
<
PlainMonthDayObject
*
>
js
:
:
temporal
:
:
CalendarMonthDayFromFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
Handle
<
PlainObject
*
>
options
)
{
return
:
:
CalendarMonthDayFromFields
(
cx
calendar
fields
options
)
;
}
using
PropertyHashSet
=
JS
:
:
GCHashSet
<
JS
:
:
PropertyKey
>
;
using
PropertyVector
=
JS
:
:
StackGCVector
<
JS
:
:
PropertyKey
>
;
static
bool
SetFromList
(
JSContext
*
cx
const
PropertyVector
&
keys
PropertyHashSet
&
keysSet
)
{
MOZ_ASSERT
(
keysSet
.
empty
(
)
"
expected
an
empty
output
hashset
"
)
;
if
(
!
keysSet
.
reserve
(
keys
.
length
(
)
)
)
{
return
false
;
}
for
(
const
auto
&
key
:
keys
)
{
if
(
!
keysSet
.
putNew
(
key
)
)
{
return
false
;
}
}
return
true
;
}
static
auto
ISOFieldKeysToIgnore
(
mozilla
:
:
EnumSet
<
TemporalField
>
keys
)
{
auto
ignoredKeys
=
keys
;
if
(
keys
.
contains
(
TemporalField
:
:
Month
)
)
{
ignoredKeys
+
=
TemporalField
:
:
MonthCode
;
}
else
if
(
keys
.
contains
(
TemporalField
:
:
MonthCode
)
)
{
ignoredKeys
+
=
TemporalField
:
:
Month
;
}
return
ignoredKeys
;
}
#
ifdef
DEBUG
static
bool
IsPlainDataObject
(
PlainObject
*
obj
)
{
if
(
obj
-
>
staticPrototype
(
)
!
=
nullptr
)
{
return
false
;
}
for
(
ShapePropertyIter
<
NoGC
>
iter
(
obj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
if
(
iter
-
>
flags
(
)
!
=
PropertyFlags
:
:
defaultDataPropFlags
)
{
return
false
;
}
}
return
true
;
}
#
endif
static
PlainObject
*
BuiltinCalendarMergeFields
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
PlainObject
*
>
fields
Handle
<
PlainObject
*
>
additionalFields
)
{
MOZ_ASSERT
(
IsPlainDataObject
(
fields
)
)
;
MOZ_ASSERT
(
IsPlainDataObject
(
additionalFields
)
)
;
JS
:
:
RootedVector
<
PropertyKey
>
additionalKeys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
additionalFields
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
additionalKeys
)
)
{
return
nullptr
;
}
mozilla
:
:
EnumSet
<
TemporalField
>
additionalFieldKeys
;
for
(
const
auto
&
additionalKey
:
additionalKeys
)
{
auto
field
=
ToTemporalField
(
cx
additionalKey
)
;
if
(
field
)
{
additionalFieldKeys
+
=
*
field
;
}
}
mozilla
:
:
EnumSet
<
TemporalField
>
toIgnore
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
toIgnore
=
ISOFieldKeysToIgnore
(
additionalFieldKeys
)
;
}
else
{
toIgnore
=
CalendarFieldKeysToIgnore
(
calendarId
additionalFieldKeys
)
;
}
MOZ_ASSERT
(
toIgnore
.
contains
(
additionalFieldKeys
)
)
;
Rooted
<
PropertyHashSet
>
overriddenKeys
(
cx
PropertyHashSet
(
cx
)
)
;
if
(
!
SetFromList
(
cx
additionalKeys
.
get
(
)
overriddenKeys
.
get
(
)
)
)
{
return
nullptr
;
}
auto
additionalFieldsToIgnore
=
toIgnore
-
additionalFieldKeys
;
for
(
auto
field
:
additionalFieldsToIgnore
)
{
auto
*
fieldName
=
ToPropertyName
(
cx
field
)
;
if
(
!
overriddenKeys
.
put
(
NameToId
(
fieldName
)
)
)
{
return
nullptr
;
}
}
Rooted
<
PlainObject
*
>
merged
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
merged
)
{
return
nullptr
;
}
JS
:
:
RootedVector
<
PropertyKey
>
fieldsKeys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
fields
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
fieldsKeys
)
)
{
return
nullptr
;
}
Rooted
<
Value
>
propValue
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
fieldsKeys
.
length
(
)
;
i
+
+
)
{
Handle
<
PropertyKey
>
key
=
fieldsKeys
[
i
]
;
if
(
overriddenKeys
.
has
(
key
)
)
{
if
(
!
GetProperty
(
cx
additionalFields
additionalFields
key
&
propValue
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
GetProperty
(
cx
fields
fields
key
&
propValue
)
)
{
return
nullptr
;
}
}
if
(
!
propValue
.
isUndefined
(
)
)
{
if
(
!
DefineDataProperty
(
cx
merged
key
propValue
)
)
{
return
nullptr
;
}
}
}
if
(
!
CopyDataProperties
(
cx
merged
additionalFields
)
)
{
return
nullptr
;
}
return
merged
;
}
JSObject
*
js
:
:
temporal
:
:
CalendarMergeFields
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
PlainObject
*
>
fields
Handle
<
PlainObject
*
>
additionalFields
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
MergeFields
)
)
;
auto
mergeFields
=
calendar
.
mergeFields
(
)
;
if
(
!
mergeFields
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarMergeFields
(
cx
calendarId
fields
additionalFields
)
;
}
Rooted
<
Value
>
mergeFieldsFn
(
cx
ObjectValue
(
*
mergeFields
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
result
(
cx
)
;
FixedInvokeArgs
<
2
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
fields
)
;
args
[
1
]
.
setObject
(
*
additionalFields
)
;
if
(
!
Call
(
cx
mergeFieldsFn
thisv
args
&
result
)
)
{
return
nullptr
;
}
return
RequireObject
(
cx
result
)
;
}
static
bool
BuiltinCalendarAdd
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
const
NormalizedDuration
&
duration
Handle
<
JSObject
*
>
options
PlainDate
*
result
)
{
MOZ_ASSERT
(
IsValidISODate
(
date
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
options
)
{
if
(
!
GetTemporalOverflowOption
(
cx
options
&
overflow
)
)
{
return
false
;
}
}
const
auto
&
timeDuration
=
duration
.
time
;
auto
balanceResult
=
BalanceTimeDuration
(
timeDuration
TemporalUnit
:
:
Day
)
;
auto
addDuration
=
DateDuration
{
duration
.
date
.
years
duration
.
date
.
months
duration
.
date
.
weeks
duration
.
date
.
days
+
balanceResult
.
days
}
;
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
return
AddISODate
(
cx
date
addDuration
overflow
result
)
;
}
return
CalendarDateAddition
(
cx
calendarId
date
addDuration
overflow
result
)
;
}
static
bool
BuiltinCalendarAdd
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
PlainDate
*
result
)
{
auto
normalized
=
CreateNormalizedDurationRecord
(
duration
{
}
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
normalized
options
result
)
;
}
static
PlainDateObject
*
BuiltinCalendarAdd
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
)
{
PlainDate
result
;
if
(
!
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
&
result
)
)
{
return
nullptr
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
CalendarValue
(
calendarId
)
)
;
return
CreateTemporalDate
(
cx
result
calendar
)
;
}
static
PlainDateObject
*
BuiltinCalendarAdd
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
date
const
Duration
&
duration
Handle
<
JSObject
*
>
options
)
{
auto
normalized
=
CreateNormalizedDurationRecord
(
duration
)
;
PlainDate
result
;
if
(
!
BuiltinCalendarAdd
(
cx
calendarId
date
normalized
options
&
result
)
)
{
return
nullptr
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
CalendarValue
(
calendarId
)
)
;
return
CreateTemporalDate
(
cx
result
calendar
)
;
}
static
Wrapped
<
PlainDateObject
*
>
CalendarDateAddSlow
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
Handle
<
Wrapped
<
DurationObject
*
>
>
duration
Handle
<
JSObject
*
>
options
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
MOZ_ASSERT
(
calendar
.
receiver
(
)
.
isObject
(
)
)
;
MOZ_ASSERT
(
calendar
.
dateAdd
(
)
)
;
Rooted
<
JS
:
:
Value
>
dateAdd
(
cx
ObjectValue
(
*
calendar
.
dateAdd
(
)
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
rval
(
cx
)
;
FixedInvokeArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
date
)
;
args
[
1
]
.
setObject
(
*
duration
)
;
if
(
options
)
{
args
[
2
]
.
setObject
(
*
options
)
;
}
else
{
args
[
2
]
.
setUndefined
(
)
;
}
if
(
!
Call
(
cx
dateAdd
thisv
args
&
rval
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
CalendarMethodsRecordIsBuiltin
(
calendar
)
)
;
if
(
!
rval
.
isObject
(
)
|
|
!
rval
.
toObject
(
)
.
canUnwrapAs
<
PlainDateObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
rval
nullptr
"
not
a
PlainDate
object
"
)
;
return
nullptr
;
}
return
&
rval
.
toObject
(
)
;
}
static
Wrapped
<
PlainDateObject
*
>
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
Duration
&
duration
Handle
<
JSObject
*
>
options
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
if
(
!
calendar
.
dateAdd
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
auto
*
unwrappedDate
=
date
.
unwrap
(
cx
)
;
if
(
!
unwrappedDate
)
{
return
nullptr
;
}
auto
date
=
ToPlainDate
(
unwrappedDate
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
)
;
}
Rooted
<
DurationObject
*
>
durationObj
(
cx
CreateTemporalDuration
(
cx
duration
)
)
;
if
(
!
durationObj
)
{
return
nullptr
;
}
return
CalendarDateAddSlow
(
cx
calendar
date
durationObj
options
)
;
}
static
Wrapped
<
PlainDateObject
*
>
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
if
(
!
calendar
.
dateAdd
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
auto
*
unwrappedDate
=
date
.
unwrap
(
cx
)
;
if
(
!
unwrappedDate
)
{
return
nullptr
;
}
auto
date
=
ToPlainDate
(
unwrappedDate
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
)
;
}
Rooted
<
DurationObject
*
>
durationObj
(
cx
CreateTemporalDuration
(
cx
duration
.
toDuration
(
)
)
)
;
if
(
!
durationObj
)
{
return
nullptr
;
}
return
CalendarDateAddSlow
(
cx
calendar
date
durationObj
options
)
;
}
static
Wrapped
<
PlainDateObject
*
>
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
Handle
<
Wrapped
<
DurationObject
*
>
>
duration
Handle
<
JSObject
*
>
options
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
if
(
!
calendar
.
dateAdd
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
auto
*
unwrappedDate
=
date
.
unwrap
(
cx
)
;
if
(
!
unwrappedDate
)
{
return
nullptr
;
}
auto
date
=
ToPlainDate
(
unwrappedDate
)
;
auto
*
unwrappedDuration
=
duration
.
unwrap
(
cx
)
;
if
(
!
unwrappedDuration
)
{
return
nullptr
;
}
auto
duration
=
ToDuration
(
unwrappedDuration
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
)
;
}
return
CalendarDateAddSlow
(
cx
calendar
date
duration
options
)
;
}
static
bool
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
PlainDate
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
if
(
!
calendar
.
dateAdd
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
auto
*
unwrappedDate
=
date
.
unwrap
(
cx
)
;
if
(
!
unwrappedDate
)
{
return
false
;
}
auto
date
=
ToPlainDate
(
unwrappedDate
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
result
)
;
}
Rooted
<
DurationObject
*
>
durationObj
(
cx
CreateTemporalDuration
(
cx
duration
.
toDuration
(
)
)
)
;
if
(
!
durationObj
)
{
return
false
;
}
auto
obj
=
CalendarDateAddSlow
(
cx
calendar
date
durationObj
options
)
;
if
(
!
obj
)
{
return
false
;
}
*
result
=
ToPlainDate
(
&
obj
.
unwrap
(
)
)
;
return
true
;
}
static
bool
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
PlainDate
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
if
(
!
calendar
.
dateAdd
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
result
)
;
}
Rooted
<
PlainDateObject
*
>
dateObj
(
cx
CreateTemporalDate
(
cx
date
calendar
.
receiver
(
)
)
)
;
if
(
!
dateObj
)
{
return
false
;
}
Rooted
<
DurationObject
*
>
durationObj
(
cx
CreateTemporalDuration
(
cx
duration
.
toDuration
(
)
)
)
;
if
(
!
durationObj
)
{
return
false
;
}
auto
obj
=
CalendarDateAddSlow
(
cx
calendar
dateObj
durationObj
options
)
;
if
(
!
obj
)
{
return
false
;
}
*
result
=
ToPlainDate
(
&
obj
.
unwrap
(
)
)
;
return
true
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
Duration
&
duration
Handle
<
JSObject
*
>
options
)
{
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
)
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
DateDuration
&
duration
)
{
Handle
<
JSObject
*
>
options
=
nullptr
;
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
)
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
Handle
<
Wrapped
<
DurationObject
*
>
>
duration
)
{
Handle
<
JSObject
*
>
options
=
nullptr
;
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
)
;
}
Wrapped
<
PlainDateObject
*
>
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
Handle
<
Wrapped
<
DurationObject
*
>
>
duration
Handle
<
JSObject
*
>
options
)
{
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
date
const
DateDuration
&
duration
PlainDate
*
result
)
{
Handle
<
JSObject
*
>
options
=
nullptr
;
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
date
const
DateDuration
&
duration
Handle
<
JSObject
*
>
options
PlainDate
*
result
)
{
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateAdd
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
date
const
DateDuration
&
duration
PlainDate
*
result
)
{
Handle
<
JSObject
*
>
options
=
nullptr
;
return
:
:
CalendarDateAdd
(
cx
calendar
date
duration
options
result
)
;
}
static
bool
BuiltinCalendarDateUntil
(
JSContext
*
cx
CalendarId
calendarId
const
PlainDate
&
one
const
PlainDate
&
two
TemporalUnit
largestUnit
DateDuration
*
result
)
{
if
(
calendarId
=
=
CalendarId
:
:
ISO8601
)
{
*
result
=
DifferenceISODate
(
one
two
largestUnit
)
;
return
true
;
}
return
CalendarDateDifference
(
cx
calendarId
one
two
largestUnit
result
)
;
}
static
bool
BuiltinCalendarDateUntil
(
JSContext
*
cx
CalendarId
calendarId
Handle
<
Wrapped
<
PlainDateObject
*
>
>
one
Handle
<
Wrapped
<
PlainDateObject
*
>
>
two
TemporalUnit
largestUnit
DateDuration
*
result
)
{
MOZ_ASSERT
(
largestUnit
<
=
TemporalUnit
:
:
Day
)
;
auto
*
unwrappedOne
=
one
.
unwrap
(
cx
)
;
if
(
!
unwrappedOne
)
{
return
false
;
}
auto
dateOne
=
ToPlainDate
(
unwrappedOne
)
;
auto
*
unwrappedTwo
=
two
.
unwrap
(
cx
)
;
if
(
!
unwrappedTwo
)
{
return
false
;
}
auto
dateTwo
=
ToPlainDate
(
unwrappedTwo
)
;
return
BuiltinCalendarDateUntil
(
cx
calendarId
dateOne
dateTwo
largestUnit
result
)
;
}
static
bool
CalendarDateUntilSlow
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
one
Handle
<
Wrapped
<
PlainDateObject
*
>
>
two
TemporalUnit
largestUnit
Handle
<
JSObject
*
>
maybeOptions
DateDuration
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
MOZ_ASSERT
(
calendar
.
receiver
(
)
.
isObject
(
)
)
;
MOZ_ASSERT
(
calendar
.
dateUntil
(
)
)
;
Rooted
<
JSObject
*
>
options
(
cx
maybeOptions
)
;
if
(
!
options
)
{
options
=
NewPlainObjectWithProto
(
cx
nullptr
)
;
if
(
!
options
)
{
return
false
;
}
}
Rooted
<
Value
>
value
(
cx
StringValue
(
TemporalUnitToString
(
cx
largestUnit
)
)
)
;
if
(
!
DefineDataProperty
(
cx
options
cx
-
>
names
(
)
.
largestUnit
value
)
)
{
return
false
;
}
Rooted
<
JS
:
:
Value
>
dateUntil
(
cx
ObjectValue
(
*
calendar
.
dateUntil
(
)
)
)
;
auto
thisv
=
calendar
.
receiver
(
)
.
toObjectValue
(
)
;
Rooted
<
Value
>
rval
(
cx
)
;
FixedInvokeArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
one
)
;
args
[
1
]
.
setObject
(
*
two
)
;
args
[
2
]
.
setObject
(
*
options
)
;
if
(
!
Call
(
cx
dateUntil
thisv
args
&
rval
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
CalendarMethodsRecordIsBuiltin
(
calendar
)
)
;
if
(
!
rval
.
isObject
(
)
|
|
!
rval
.
toObject
(
)
.
canUnwrapAs
<
DurationObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
rval
nullptr
"
not
a
Duration
object
"
)
;
return
false
;
}
auto
duration
=
ToDuration
(
&
rval
.
toObject
(
)
.
unwrapAs
<
DurationObject
>
(
)
)
;
*
result
=
duration
.
toDateDuration
(
)
;
return
true
;
}
static
bool
CalendarDateUntilSlow
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
one
const
PlainDate
&
two
TemporalUnit
largestUnit
Handle
<
JSObject
*
>
maybeOptions
DateDuration
*
result
)
{
Rooted
<
PlainDateObject
*
>
date1
(
cx
CreateTemporalDate
(
cx
one
calendar
.
receiver
(
)
)
)
;
if
(
!
date1
)
{
return
false
;
}
Rooted
<
PlainDateObject
*
>
date2
(
cx
CreateTemporalDate
(
cx
two
calendar
.
receiver
(
)
)
)
;
if
(
!
date2
)
{
return
false
;
}
return
CalendarDateUntilSlow
(
cx
calendar
date1
date2
largestUnit
maybeOptions
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateUntil
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
one
const
PlainDate
&
two
TemporalUnit
largestUnit
DateDuration
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
MOZ_ASSERT
(
largestUnit
<
=
TemporalUnit
:
:
Day
)
;
if
(
!
calendar
.
dateUntil
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDateUntil
(
cx
calendarId
one
two
largestUnit
result
)
;
}
return
CalendarDateUntilSlow
(
cx
calendar
one
two
largestUnit
nullptr
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateUntil
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
const
PlainDate
&
one
const
PlainDate
&
two
TemporalUnit
largestUnit
Handle
<
PlainObject
*
>
options
DateDuration
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
options
-
>
isExtensible
(
)
)
;
auto
largestUnitProp
=
options
-
>
lookupPure
(
cx
-
>
names
(
)
.
largestUnit
)
;
MOZ_ASSERT_IF
(
largestUnitProp
largestUnitProp
-
>
configurable
(
)
)
;
#
endif
if
(
!
calendar
.
dateUntil
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDateUntil
(
cx
calendarId
one
two
largestUnit
result
)
;
}
return
CalendarDateUntilSlow
(
cx
calendar
one
two
largestUnit
options
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateUntil
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
one
Handle
<
Wrapped
<
PlainDateObject
*
>
>
two
TemporalUnit
largestUnit
DateDuration
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
MOZ_ASSERT
(
largestUnit
<
=
TemporalUnit
:
:
Day
)
;
if
(
!
calendar
.
dateUntil
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDateUntil
(
cx
calendarId
one
two
largestUnit
result
)
;
}
return
CalendarDateUntilSlow
(
cx
calendar
one
two
largestUnit
nullptr
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarDateUntil
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
one
Handle
<
Wrapped
<
PlainDateObject
*
>
>
two
TemporalUnit
largestUnit
Handle
<
PlainObject
*
>
options
DateDuration
*
result
)
{
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
options
-
>
isExtensible
(
)
)
;
auto
largestUnitProp
=
options
-
>
lookupPure
(
cx
-
>
names
(
)
.
largestUnit
)
;
MOZ_ASSERT_IF
(
largestUnitProp
largestUnitProp
-
>
configurable
(
)
)
;
#
endif
if
(
!
calendar
.
dateUntil
(
)
)
{
auto
calendarId
=
BuiltinCalendarId
(
calendar
.
receiver
(
)
)
;
return
BuiltinCalendarDateUntil
(
cx
calendarId
one
two
largestUnit
result
)
;
}
return
CalendarDateUntilSlow
(
cx
calendar
one
two
largestUnit
options
result
)
;
}
bool
js
:
:
temporal
:
:
CalendarEquals
(
JSContext
*
cx
Handle
<
CalendarValue
>
one
Handle
<
CalendarValue
>
two
bool
*
equals
)
{
if
(
one
.
isObject
(
)
&
&
two
.
isObject
(
)
&
&
one
.
toObject
(
)
=
=
two
.
toObject
(
)
)
{
*
equals
=
true
;
return
true
;
}
Rooted
<
JSLinearString
*
>
calendarOne
(
cx
ToTemporalCalendarIdentifier
(
cx
one
)
)
;
if
(
!
calendarOne
)
{
return
false
;
}
JSLinearString
*
calendarTwo
=
ToTemporalCalendarIdentifier
(
cx
two
)
;
if
(
!
calendarTwo
)
{
return
false
;
}
*
equals
=
EqualStrings
(
calendarOne
calendarTwo
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
CalendarEqualsOrThrow
(
JSContext
*
cx
Handle
<
CalendarValue
>
one
Handle
<
CalendarValue
>
two
)
{
if
(
one
.
isObject
(
)
&
&
two
.
isObject
(
)
&
&
one
.
toObject
(
)
=
=
two
.
toObject
(
)
)
{
return
true
;
}
Rooted
<
JSLinearString
*
>
calendarOne
(
cx
ToTemporalCalendarIdentifier
(
cx
one
)
)
;
if
(
!
calendarOne
)
{
return
false
;
}
JSLinearString
*
calendarTwo
=
ToTemporalCalendarIdentifier
(
cx
two
)
;
if
(
!
calendarTwo
)
{
return
false
;
}
if
(
EqualStrings
(
calendarOne
calendarTwo
)
)
{
return
true
;
}
if
(
auto
charsOne
=
QuoteString
(
cx
calendarOne
)
)
{
if
(
auto
charsTwo
=
QuoteString
(
cx
calendarTwo
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE
charsOne
.
get
(
)
charsTwo
.
get
(
)
)
;
}
}
return
false
;
}
static
bool
CalendarConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Temporal
.
Calendar
"
)
)
{
return
false
;
}
if
(
!
args
.
requireAtLeast
(
cx
"
Temporal
.
Calendar
"
1
)
)
{
return
false
;
}
if
(
!
args
[
0
]
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_SEARCH_STACK
args
[
0
]
nullptr
"
not
a
string
"
)
;
return
false
;
}
Rooted
<
JSLinearString
*
>
id
(
cx
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
id
)
{
return
false
;
}
CalendarId
identifier
;
if
(
!
:
:
ToBuiltinCalendar
(
cx
id
&
identifier
)
)
{
return
false
;
}
auto
*
calendar
=
CreateTemporalCalendar
(
cx
args
identifier
)
;
if
(
!
calendar
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
calendar
)
;
return
true
;
}
static
bool
Calendar_from
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
CalendarValue
>
calendar
(
cx
)
;
if
(
!
ToTemporalCalendar
(
cx
args
.
get
(
0
)
&
calendar
)
)
{
return
false
;
}
auto
*
obj
=
ToTemporalCalendarObject
(
cx
calendar
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_id
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
-
>
identifier
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Calendar_id
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_id
>
(
cx
args
)
;
}
static
bool
Calendar_dateFromFields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
Rooted
<
JSObject
*
>
fields
(
cx
RequireObjectArg
(
cx
"
fields
"
"
dateFromFields
"
args
.
get
(
0
)
)
)
;
if
(
!
fields
)
{
return
false
;
}
Rooted
<
JSObject
*
>
options
(
cx
)
;
if
(
args
.
hasDefined
(
1
)
)
{
options
=
RequireObjectArg
(
cx
"
options
"
"
dateFromFields
"
args
[
1
]
)
;
if
(
!
options
)
{
return
false
;
}
}
auto
*
obj
=
BuiltinCalendarDateFromFields
(
cx
calendarId
fields
options
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_dateFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_dateFromFields
>
(
cx
args
)
;
}
static
bool
Calendar_yearMonthFromFields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
Rooted
<
JSObject
*
>
fields
(
cx
RequireObjectArg
(
cx
"
fields
"
"
yearMonthFromFields
"
args
.
get
(
0
)
)
)
;
if
(
!
fields
)
{
return
false
;
}
Rooted
<
JSObject
*
>
options
(
cx
)
;
if
(
args
.
hasDefined
(
1
)
)
{
options
=
RequireObjectArg
(
cx
"
options
"
"
yearMonthFromFields
"
args
[
1
]
)
;
if
(
!
options
)
{
return
false
;
}
}
auto
*
obj
=
BuiltinCalendarYearMonthFromFields
(
cx
calendarId
fields
options
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_yearMonthFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_yearMonthFromFields
>
(
cx
args
)
;
}
static
bool
Calendar_monthDayFromFields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
Rooted
<
JSObject
*
>
fields
(
cx
RequireObjectArg
(
cx
"
fields
"
"
monthDayFromFields
"
args
.
get
(
0
)
)
)
;
if
(
!
fields
)
{
return
false
;
}
Rooted
<
JSObject
*
>
options
(
cx
)
;
if
(
args
.
hasDefined
(
1
)
)
{
options
=
RequireObjectArg
(
cx
"
options
"
"
monthDayFromFields
"
args
[
1
]
)
;
if
(
!
options
)
{
return
false
;
}
}
auto
*
obj
=
BuiltinCalendarMonthDayFromFields
(
cx
calendarId
fields
options
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_monthDayFromFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_monthDayFromFields
>
(
cx
args
)
;
}
static
bool
Calendar_dateAdd
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
Duration
duration
;
if
(
!
ToTemporalDuration
(
cx
args
.
get
(
1
)
&
duration
)
)
{
return
false
;
}
Rooted
<
JSObject
*
>
options
(
cx
)
;
if
(
args
.
hasDefined
(
2
)
)
{
options
=
RequireObjectArg
(
cx
"
options
"
"
dateAdd
"
args
[
2
]
)
;
if
(
!
options
)
{
return
false
;
}
}
auto
*
obj
=
BuiltinCalendarAdd
(
cx
calendarId
date
duration
options
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_dateAdd
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_dateAdd
>
(
cx
args
)
;
}
static
bool
Calendar_dateUntil
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
one
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
one
)
)
{
return
false
;
}
PlainDate
two
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
1
)
&
two
)
)
{
return
false
;
}
auto
largestUnit
=
TemporalUnit
:
:
Day
;
if
(
args
.
hasDefined
(
2
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
"
dateUntil
"
args
[
2
]
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
GetTemporalUnitValuedOption
(
cx
options
TemporalUnitKey
:
:
LargestUnit
TemporalUnitGroup
:
:
Date
&
largestUnit
)
)
{
return
false
;
}
}
DateDuration
duration
;
if
(
!
BuiltinCalendarDateUntil
(
cx
calendarId
one
two
largestUnit
&
duration
)
)
{
return
false
;
}
auto
*
obj
=
CreateTemporalDuration
(
cx
duration
.
toDuration
(
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Calendar_dateUntil
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_dateUntil
>
(
cx
args
)
;
}
static
bool
Calendar_era
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarEra
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_era
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_era
>
(
cx
args
)
;
}
static
bool
Calendar_eraYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarEraYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_eraYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_eraYear
>
(
cx
args
)
;
}
static
bool
Calendar_year
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_year
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_year
>
(
cx
args
)
;
}
static
bool
Calendar_month
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
Handle
<
Value
>
temporalDateLike
=
args
.
get
(
0
)
;
if
(
temporalDateLike
.
isObject
(
)
&
&
temporalDateLike
.
toObject
(
)
.
canUnwrapAs
<
PlainMonthDayObject
>
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_SEARCH_STACK
temporalDateLike
nullptr
"
a
PlainMonthDay
object
"
)
;
return
false
;
}
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
temporalDateLike
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarMonth
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_month
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_month
>
(
cx
args
)
;
}
static
bool
Calendar_monthCode
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainMonthDayObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarMonthCode
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_monthCode
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_monthCode
>
(
cx
args
)
;
}
static
bool
Calendar_day
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainMonthDayObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDay
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_day
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_day
>
(
cx
args
)
;
}
static
bool
Calendar_dayOfWeek
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDayOfWeek
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_dayOfWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_dayOfWeek
>
(
cx
args
)
;
}
static
bool
Calendar_dayOfYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDayOfYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_dayOfYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_dayOfYear
>
(
cx
args
)
;
}
static
bool
Calendar_weekOfYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarWeekOfYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_weekOfYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_weekOfYear
>
(
cx
args
)
;
}
static
bool
Calendar_yearOfWeek
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarYearOfWeek
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_yearOfWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_yearOfWeek
>
(
cx
args
)
;
}
static
bool
Calendar_daysInWeek
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDaysInWeek
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_daysInWeek
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_daysInWeek
>
(
cx
args
)
;
}
static
bool
Calendar_daysInMonth
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDaysInMonth
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_daysInMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_daysInMonth
>
(
cx
args
)
;
}
static
bool
Calendar_daysInYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarDaysInYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_daysInYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_daysInYear
>
(
cx
args
)
;
}
static
bool
Calendar_monthsInYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarMonthsInYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_monthsInYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_monthsInYear
>
(
cx
args
)
;
}
static
bool
Calendar_inLeapYear
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
PlainDate
date
;
if
(
!
ToPlainDate
<
PlainDateObject
PlainDateTimeObject
PlainYearMonthObject
>
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
return
BuiltinCalendarInLeapYear
(
cx
calendarId
date
args
.
rval
(
)
)
;
}
static
bool
Calendar_inLeapYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_inLeapYear
>
(
cx
args
)
;
}
static
bool
Calendar_fields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
return
BuiltinCalendarFields
(
cx
calendarId
args
.
get
(
0
)
args
.
rval
(
)
)
;
}
static
bool
Calendar_fields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_fields
>
(
cx
args
)
;
}
static
bool
Calendar_mergeFields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
calendarId
=
calendar
-
>
identifier
(
)
;
Rooted
<
JSObject
*
>
fields
(
cx
JS
:
:
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
fields
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
fieldsCopy
(
cx
SnapshotOwnPropertiesIgnoreUndefined
(
cx
fields
)
)
;
if
(
!
fieldsCopy
)
{
return
false
;
}
Rooted
<
JSObject
*
>
additionalFields
(
cx
JS
:
:
ToObject
(
cx
args
.
get
(
1
)
)
)
;
if
(
!
additionalFields
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
additionalFieldsCopy
(
cx
SnapshotOwnPropertiesIgnoreUndefined
(
cx
additionalFields
)
)
;
if
(
!
additionalFieldsCopy
)
{
return
false
;
}
auto
*
merged
=
BuiltinCalendarMergeFields
(
cx
calendarId
fieldsCopy
additionalFieldsCopy
)
;
if
(
!
merged
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
merged
)
;
return
true
;
}
static
bool
Calendar_mergeFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_mergeFields
>
(
cx
args
)
;
}
static
bool
Calendar_toString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
-
>
identifier
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Calendar_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_toString
>
(
cx
args
)
;
}
static
bool
Calendar_toJSON
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
calendar
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
CalendarObject
>
(
)
;
auto
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
-
>
identifier
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Calendar_toJSON
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsCalendar
Calendar_toJSON
>
(
cx
args
)
;
}
const
JSClass
CalendarObject
:
:
class_
=
{
"
Temporal
.
Calendar
"
JSCLASS_HAS_RESERVED_SLOTS
(
CalendarObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Calendar
)
JS_NULL_CLASS_OPS
&
CalendarObject
:
:
classSpec_
}
;
const
JSClass
&
CalendarObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
const
JSFunctionSpec
Calendar_methods
[
]
=
{
JS_FN
(
"
from
"
Calendar_from
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
Calendar_prototype_methods
[
]
=
{
JS_FN
(
"
dateFromFields
"
Calendar_dateFromFields
1
0
)
JS_FN
(
"
yearMonthFromFields
"
Calendar_yearMonthFromFields
1
0
)
JS_FN
(
"
monthDayFromFields
"
Calendar_monthDayFromFields
1
0
)
JS_FN
(
"
dateAdd
"
Calendar_dateAdd
2
0
)
JS_FN
(
"
dateUntil
"
Calendar_dateUntil
2
0
)
JS_FN
(
"
era
"
Calendar_era
1
0
)
JS_FN
(
"
eraYear
"
Calendar_eraYear
1
0
)
JS_FN
(
"
year
"
Calendar_year
1
0
)
JS_FN
(
"
month
"
Calendar_month
1
0
)
JS_FN
(
"
monthCode
"
Calendar_monthCode
1
0
)
JS_FN
(
"
day
"
Calendar_day
1
0
)
JS_FN
(
"
dayOfWeek
"
Calendar_dayOfWeek
1
0
)
JS_FN
(
"
dayOfYear
"
Calendar_dayOfYear
1
0
)
JS_FN
(
"
weekOfYear
"
Calendar_weekOfYear
1
0
)
JS_FN
(
"
yearOfWeek
"
Calendar_yearOfWeek
1
0
)
JS_FN
(
"
daysInWeek
"
Calendar_daysInWeek
1
0
)
JS_FN
(
"
daysInMonth
"
Calendar_daysInMonth
1
0
)
JS_FN
(
"
daysInYear
"
Calendar_daysInYear
1
0
)
JS_FN
(
"
monthsInYear
"
Calendar_monthsInYear
1
0
)
JS_FN
(
"
inLeapYear
"
Calendar_inLeapYear
1
0
)
JS_FN
(
"
fields
"
Calendar_fields
1
0
)
JS_FN
(
"
mergeFields
"
Calendar_mergeFields
2
0
)
JS_FN
(
"
toString
"
Calendar_toString
0
0
)
JS_FN
(
"
toJSON
"
Calendar_toJSON
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
Calendar_prototype_properties
[
]
=
{
JS_PSG
(
"
id
"
Calendar_id
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Temporal
.
Calendar
"
JSPROP_READONLY
)
JS_PS_END
}
;
const
ClassSpec
CalendarObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
CalendarConstructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
CalendarObject
>
Calendar_methods
nullptr
Calendar_prototype_methods
Calendar_prototype_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
