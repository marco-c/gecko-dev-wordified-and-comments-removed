#
ifndef
builtin_temporal_Int96_h
#
define
builtin_temporal_Int96_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
array
>
#
include
<
climits
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
namespace
js
:
:
temporal
{
class
Int96
final
{
public
:
using
Digit
=
uint32_t
;
using
TwoDigit
=
uint64_t
;
using
Digits
=
std
:
:
array
<
Digit
3
>
;
private
:
Digits
digits
=
{
}
;
bool
negative
=
false
;
public
:
constexpr
Int96
(
)
=
default
;
constexpr
explicit
Int96
(
int64_t
value
)
:
negative
(
value
<
0
)
{
uint64_t
abs
=
mozilla
:
:
Abs
(
value
)
;
digits
[
1
]
=
uint32_t
(
abs
>
>
32
)
;
digits
[
0
]
=
uint32_t
(
abs
)
;
}
constexpr
Int96
(
Digits
digits
bool
negative
)
:
digits
(
digits
)
negative
(
negative
)
{
MOZ_ASSERT_IF
(
(
digits
[
0
]
|
digits
[
1
]
|
digits
[
2
]
)
=
=
0
!
negative
)
;
}
constexpr
bool
operator
=
=
(
const
Int96
&
other
)
const
{
return
digits
[
0
]
=
=
other
.
digits
[
0
]
&
&
digits
[
1
]
=
=
other
.
digits
[
1
]
&
&
digits
[
2
]
=
=
other
.
digits
[
2
]
&
&
negative
=
=
other
.
negative
;
}
constexpr
bool
operator
<
(
const
Int96
&
other
)
const
{
if
(
negative
!
=
other
.
negative
)
{
return
negative
;
}
for
(
size_t
i
=
digits
.
size
(
)
;
i
!
=
0
;
-
-
i
)
{
Digit
x
=
digits
[
i
-
1
]
;
Digit
y
=
other
.
digits
[
i
-
1
]
;
if
(
x
!
=
y
)
{
return
negative
?
x
>
y
:
x
<
y
;
}
}
return
false
;
}
constexpr
bool
operator
!
=
(
const
Int96
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
constexpr
bool
operator
>
(
const
Int96
&
other
)
const
{
return
other
<
*
this
;
}
constexpr
bool
operator
<
=
(
const
Int96
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
constexpr
bool
operator
>
=
(
const
Int96
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
constexpr
Int96
&
operator
*
=
(
Digit
multiplier
)
{
Digit
carry
=
0
;
for
(
auto
&
digit
:
digits
)
{
TwoDigit
d
=
digit
;
d
*
=
multiplier
;
d
+
=
carry
;
digit
=
Digit
(
d
)
;
carry
=
Digit
(
d
>
>
32
)
;
}
MOZ_ASSERT
(
carry
=
=
0
"
unsupported
overflow
"
)
;
return
*
this
;
}
constexpr
Int96
operator
*
(
Digit
multiplier
)
const
{
auto
result
=
*
this
;
result
*
=
multiplier
;
return
result
;
}
constexpr
std
:
:
pair
<
int64_t
int32_t
>
operator
/
(
Digit
divisor
)
const
{
MOZ_ASSERT
(
digits
[
2
]
<
divisor
"
unsupported
divisor
"
)
;
Digit
quotient
[
2
]
=
{
}
;
Digit
remainder
=
digits
[
2
]
;
for
(
int32_t
i
=
1
;
i
>
=
0
;
i
-
-
)
{
TwoDigit
n
=
(
TwoDigit
(
remainder
)
<
<
32
)
|
digits
[
i
]
;
quotient
[
i
]
=
n
/
divisor
;
remainder
=
n
%
divisor
;
}
int64_t
result
=
int64_t
(
(
TwoDigit
(
quotient
[
1
]
)
<
<
32
)
|
quotient
[
0
]
)
;
if
(
negative
)
{
result
*
=
-
1
;
if
(
remainder
!
=
0
)
{
result
-
=
1
;
remainder
=
divisor
-
remainder
;
}
}
return
{
result
int32_t
(
remainder
)
}
;
}
constexpr
Int96
abs
(
)
const
{
return
{
digits
false
}
;
}
static
mozilla
:
:
Maybe
<
Int96
>
fromInteger
(
double
value
)
;
}
;
}
#
endif
