#
ifndef
builtin_temporal_Wrapped_h
#
define
builtin_temporal_Wrapped_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
type_traits
>
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
:
:
temporal
{
template
<
class
T
>
class
MOZ_STACK_CLASS
Wrapped
final
{
static_assert
(
std
:
:
is_pointer_v
<
T
>
)
;
static_assert
(
std
:
:
is_convertible_v
<
T
NativeObject
*
>
)
;
using
U
=
std
:
:
remove_pointer_t
<
T
>
;
JSObject
*
ptr_
=
nullptr
;
public
:
Wrapped
(
)
=
default
;
MOZ_IMPLICIT
Wrapped
(
decltype
(
nullptr
)
)
:
ptr_
(
nullptr
)
{
}
MOZ_IMPLICIT
Wrapped
(
T
ptr
)
:
ptr_
(
ptr
)
{
}
MOZ_IMPLICIT
Wrapped
(
JSObject
*
ptr
)
:
ptr_
(
ptr
)
{
MOZ_ASSERT_IF
(
ptr_
ptr_
-
>
canUnwrapAs
<
U
>
(
)
)
;
}
template
<
typename
S
>
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
Rooted
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
:
Wrapped
(
root
.
get
(
)
)
{
}
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
Rooted
<
JSObject
*
>
&
root
)
:
Wrapped
(
root
.
get
(
)
)
{
}
template
<
typename
S
>
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
Handle
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
:
Wrapped
(
root
.
get
(
)
)
{
}
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
Handle
<
JSObject
*
>
&
root
)
:
Wrapped
(
root
.
get
(
)
)
{
}
template
<
typename
S
>
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
MutableHandle
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
:
Wrapped
(
root
.
get
(
)
)
{
}
MOZ_IMPLICIT
Wrapped
(
const
JS
:
:
MutableHandle
<
JSObject
*
>
&
root
)
:
Wrapped
(
root
.
get
(
)
)
{
}
Wrapped
&
operator
=
(
decltype
(
nullptr
)
)
{
ptr_
=
nullptr
;
return
*
this
;
}
Wrapped
&
operator
=
(
T
ptr
)
{
ptr_
=
ptr
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
!
!
ptr_
;
}
JSObject
*
operator
-
>
(
)
const
{
return
ptr_
;
}
JSObject
&
operator
*
(
)
const
{
return
*
ptr_
;
}
JSObject
*
get
(
)
const
{
return
ptr_
;
}
operator
JSObject
*
(
)
const
{
return
get
(
)
;
}
auto
address
(
)
const
{
return
&
ptr_
;
}
U
&
unwrap
(
)
const
{
MOZ_ASSERT
(
ptr_
)
;
return
ptr_
-
>
unwrapAs
<
U
>
(
)
;
}
U
*
unwrapOrNull
(
)
const
{
return
ptr_
?
&
ptr_
-
>
unwrapAs
<
U
>
(
)
:
nullptr
;
}
void
trace
(
JSTracer
*
trc
)
{
if
(
ptr_
)
{
TraceRoot
(
trc
&
ptr_
"
Wrapped
:
:
ptr_
"
)
;
}
}
}
;
void
ReportDeadWrapperOrAccessDenied
(
JSContext
*
cx
JSObject
*
obj
)
;
}
namespace
js
{
template
<
typename
T
typename
Container
>
class
WrappedPtrOperations
<
temporal
:
:
Wrapped
<
T
>
Container
>
{
using
U
=
std
:
:
remove_pointer_t
<
T
>
;
const
auto
&
wrapped
(
)
const
{
return
static_cast
<
const
Container
*
>
(
this
)
-
>
get
(
)
;
}
public
:
explicit
operator
bool
(
)
const
{
return
!
!
wrapped
(
)
;
}
JSObject
*
operator
-
>
(
)
const
{
return
wrapped
(
)
.
get
(
)
;
}
JSObject
&
operator
*
(
)
const
{
return
*
wrapped
(
)
.
get
(
)
;
}
JS
:
:
Handle
<
JSObject
*
>
object
(
)
const
{
return
JS
:
:
Handle
<
JSObject
*
>
:
:
fromMarkedLocation
(
wrapped
(
)
.
address
(
)
)
;
}
operator
JS
:
:
Handle
<
JSObject
*
>
(
)
const
{
return
object
(
)
;
}
[
[
nodiscard
]
]
U
*
unwrap
(
JSContext
*
cx
)
const
{
JSObject
*
obj
=
wrapped
(
)
.
get
(
)
;
if
(
auto
*
unwrapped
=
obj
-
>
maybeUnwrapIf
<
U
>
(
)
)
{
return
unwrapped
;
}
temporal
:
:
ReportDeadWrapperOrAccessDenied
(
cx
obj
)
;
return
nullptr
;
}
}
;
}
#
endif
