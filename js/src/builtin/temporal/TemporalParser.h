#
ifndef
builtin_temporal_TemporalParser_h
#
define
builtin_temporal_TemporalParser_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
cstdlib
>
#
include
<
stdint
.
h
>
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JSLinearString
;
class
JS_PUBLIC_API
JSTracer
;
namespace
js
:
:
temporal
{
struct
Duration
;
struct
PlainDate
;
struct
PlainDateTime
;
struct
PlainTime
;
struct
MOZ_STACK_CLASS
ParsedTimeZone
final
{
JSLinearString
*
name
=
nullptr
;
int32_t
offset
=
INT32_MIN
;
void
trace
(
JSTracer
*
trc
)
;
static
ParsedTimeZone
fromName
(
JSLinearString
*
name
)
{
MOZ_ASSERT
(
name
)
;
return
{
name
0
}
;
}
static
ParsedTimeZone
fromOffset
(
int32_t
offset
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offset
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
)
;
return
{
nullptr
offset
}
;
}
explicit
operator
bool
(
)
const
{
return
name
!
=
nullptr
|
|
offset
!
=
INT32_MIN
;
}
}
;
bool
ParseTemporalInstantString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDateTime
*
result
int64_t
*
offset
)
;
bool
ParseTemporalTimeZoneString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
JS
:
:
MutableHandle
<
ParsedTimeZone
>
result
)
;
bool
ParseTimeZoneIdentifier
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
JS
:
:
MutableHandle
<
ParsedTimeZone
>
result
)
;
bool
ParseTimeZoneOffsetString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
int32_t
*
result
)
;
bool
ParseDateTimeUTCOffset
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
int64_t
*
result
)
;
bool
ParseTemporalDurationString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
Duration
*
result
)
;
JSLinearString
*
ParseTemporalCalendarString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
)
;
bool
ParseTemporalTimeString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainTime
*
result
)
;
bool
ParseTemporalDateString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDate
*
result
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
bool
ParseTemporalMonthDayString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDate
*
result
bool
*
hasYear
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
bool
ParseTemporalYearMonthString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDate
*
result
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
bool
ParseTemporalDateTimeString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDateTime
*
result
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
bool
ParseTemporalZonedDateTimeString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDateTime
*
dateTime
bool
*
isUTC
bool
*
hasOffset
int64_t
*
timeZoneOffset
JS
:
:
MutableHandle
<
ParsedTimeZone
>
timeZoneAnnotation
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
bool
ParseTemporalRelativeToString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
PlainDateTime
*
dateTime
bool
*
isUTC
bool
*
hasOffset
int64_t
*
timeZoneOffset
JS
:
:
MutableHandle
<
ParsedTimeZone
>
timeZoneAnnotation
JS
:
:
MutableHandle
<
JSString
*
>
calendar
)
;
}
namespace
js
{
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
temporal
:
:
ParsedTimeZone
Wrapper
>
{
const
auto
&
object
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
JS
:
:
Handle
<
JSLinearString
*
>
name
(
)
const
{
return
JS
:
:
Handle
<
JSLinearString
*
>
:
:
fromMarkedLocation
(
&
object
(
)
.
name
)
;
}
int32_t
offset
(
)
const
{
return
object
(
)
.
offset
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
object
(
)
)
;
}
}
;
}
#
endif
