#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string_view
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
struct
StringName
final
{
size_t
start
=
0
;
size_t
length
=
0
;
bool
present
(
)
const
{
return
length
>
0
;
}
}
;
static
JSLinearString
*
ToString
(
JSContext
*
cx
JSString
*
string
const
StringName
&
name
)
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
NewDependentString
(
cx
string
name
.
start
name
.
length
)
;
}
using
CalendarName
=
StringName
;
using
AnnotationKey
=
StringName
;
using
AnnotationValue
=
StringName
;
using
TimeZoneName
=
StringName
;
struct
Annotation
final
{
AnnotationKey
key
;
AnnotationValue
value
;
bool
critical
=
false
;
}
;
struct
TimeSpec
final
{
PlainTime
time
;
}
;
struct
TimeZoneOffset
final
{
int32_t
sign
=
0
;
int32_t
hour
=
0
;
int32_t
minute
=
0
;
int32_t
second
=
0
;
int32_t
fractionalPart
=
0
;
}
;
struct
TimeZoneAnnotation
final
{
TimeZoneOffset
offset
;
TimeZoneName
name
;
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasName
(
)
const
{
return
name
.
present
(
)
;
}
}
;
struct
TimeZoneString
final
{
TimeZoneOffset
offset
;
TimeZoneName
name
;
TimeZoneAnnotation
annotation
;
bool
utc
=
false
;
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasName
(
)
const
{
return
name
.
present
(
)
;
}
bool
hasAnnotation
(
)
const
{
return
annotation
.
hasName
(
)
|
|
annotation
.
hasOffset
(
)
;
}
bool
isUTC
(
)
const
{
return
utc
;
}
}
;
struct
ZonedDateTimeString
final
{
PlainDate
date
;
PlainTime
time
;
TimeZoneString
timeZone
;
CalendarName
calendar
;
}
;
static
constexpr
int32_t
AbsentYear
=
INT32_MAX
;
static
bool
ParseISODateTime
(
JSContext
*
cx
const
ZonedDateTimeString
&
parsed
PlainDateTime
*
result
)
{
PlainDateTime
dateTime
=
{
parsed
.
date
parsed
.
time
}
;
if
(
dateTime
.
date
.
year
=
=
AbsentYear
)
{
dateTime
.
date
.
year
=
0
;
}
if
(
dateTime
.
date
.
month
=
=
0
)
{
dateTime
.
date
.
month
=
1
;
}
if
(
dateTime
.
date
.
day
=
=
0
)
{
dateTime
.
date
.
day
=
1
;
}
if
(
dateTime
.
time
.
second
=
=
60
)
{
dateTime
.
time
.
second
=
59
;
}
MOZ_ASSERT
(
std
:
:
abs
(
dateTime
.
date
.
year
)
<
=
999
'
999
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
month
&
&
dateTime
.
date
.
month
<
=
12
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
day
&
&
dateTime
.
date
.
day
<
=
31
)
;
if
(
!
ThrowIfInvalidISODate
(
cx
dateTime
.
date
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidTime
(
dateTime
.
time
)
)
;
*
result
=
dateTime
;
return
true
;
}
class
ParserError
final
{
JSErrNum
error_
=
JSMSG_NOT_AN_ERROR
;
public
:
constexpr
MOZ_IMPLICIT
ParserError
(
JSErrNum
error
)
:
error_
(
error
)
{
}
constexpr
JSErrNum
error
(
)
const
{
return
error_
;
}
constexpr
operator
JSErrNum
(
)
const
{
return
error
(
)
;
}
}
;
namespace
mozilla
:
:
detail
{
static_assert
(
static_cast
<
JSErrNum
>
(
0
)
=
=
JSMSG_NOT_AN_ERROR
)
;
template
<
>
struct
UnusedZero
<
:
:
ParserError
>
{
private
:
using
Error
=
:
:
ParserError
;
using
ErrorKind
=
JSErrNum
;
public
:
using
StorageType
=
std
:
:
underlying_type_t
<
ErrorKind
>
;
static
constexpr
bool
value
=
true
;
static
constexpr
StorageType
nullValue
=
0
;
static
constexpr
Error
Inspect
(
const
StorageType
&
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
Error
Unwrap
(
StorageType
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
StorageType
Store
(
Error
aValue
)
{
return
static_cast
<
StorageType
>
(
aValue
.
error
(
)
)
;
}
}
;
}
static_assert
(
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
:
:
Strategy
!
=
mozilla
:
:
detail
:
:
PackingStrategy
:
:
Variant
)
;
template
<
typename
CharT
>
class
StringReader
final
{
mozilla
:
:
Span
<
const
CharT
>
string_
;
size_t
index_
=
0
;
public
:
explicit
StringReader
(
mozilla
:
:
Span
<
const
CharT
>
string
)
:
string_
(
string
)
{
}
mozilla
:
:
Span
<
const
CharT
>
string
(
)
const
{
return
string_
;
}
mozilla
:
:
Span
<
const
CharT
>
substring
(
const
StringName
&
name
)
const
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
string_
.
Subspan
(
name
.
start
name
.
length
)
;
}
size_t
index
(
)
const
{
return
index_
;
}
size_t
length
(
)
const
{
return
string_
.
size
(
)
;
}
bool
atEnd
(
)
const
{
return
index
(
)
=
=
length
(
)
;
}
void
reset
(
size_t
index
=
0
)
{
MOZ_ASSERT
(
index
<
=
length
(
)
)
;
index_
=
index
;
}
bool
hasMore
(
size_t
amount
)
const
{
return
index
(
)
+
amount
<
=
length
(
)
;
}
void
advance
(
size_t
amount
)
{
MOZ_ASSERT
(
hasMore
(
amount
)
)
;
index_
+
=
amount
;
}
CharT
current
(
)
const
{
return
string
(
)
[
index
(
)
]
;
}
CharT
next
(
)
const
{
return
string
(
)
[
index
(
)
+
1
]
;
}
CharT
at
(
size_t
index
)
const
{
return
string
(
)
[
index
]
;
}
}
;
template
<
typename
CharT
>
class
TemporalParser
final
{
StringReader
<
CharT
>
reader_
;
bool
hasCharacter
(
CharT
ch
)
const
{
return
reader_
.
hasMore
(
1
)
&
&
reader_
.
current
(
)
=
=
ch
;
}
bool
character
(
CharT
ch
)
{
if
(
!
hasCharacter
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
bool
hasTwoAsciiAlpha
(
)
{
if
(
!
reader_
.
hasMore
(
2
)
)
{
return
false
;
}
size_t
index
=
reader_
.
index
(
)
;
return
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
)
)
&
&
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
+
1
)
)
;
}
bool
aValChar
(
)
{
if
(
!
reader_
.
hasMore
(
1
)
)
{
return
false
;
}
CharT
ch
=
reader_
.
current
(
)
;
if
(
!
mozilla
:
:
IsAsciiAlphanumeric
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
bool
annotationValueComponent
(
)
;
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
annotationValue
(
)
;
public
:
explicit
TemporalParser
(
mozilla
:
:
Span
<
const
CharT
>
str
)
:
reader_
(
str
)
{
}
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalCalendarString
(
)
;
}
;
template
<
typename
CharT
>
bool
TemporalParser
<
CharT
>
:
:
annotationValueComponent
(
)
{
bool
hasOne
=
false
;
while
(
aValChar
(
)
)
{
hasOne
=
true
;
}
return
hasOne
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
TemporalParser
<
CharT
>
:
:
annotationValue
(
)
{
size_t
start
=
reader_
.
index
(
)
;
do
{
if
(
!
annotationValueComponent
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_VALUE
)
;
}
}
while
(
character
(
'
-
'
)
)
;
return
AnnotationValue
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalCalendarString
(
)
{
if
(
hasTwoAsciiAlpha
(
)
)
{
auto
cal
=
annotationValue
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
ZonedDateTimeString
result
=
{
}
;
result
.
calendar
=
cal
.
unwrap
(
)
;
return
result
;
}
MOZ_CRASH
(
"
NYI
"
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalCalendarString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalCalendarString
(
)
;
}
static
auto
ParseTemporalCalendarString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalCalendarString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalCalendarString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
JSLinearString
*
js
:
:
temporal
:
:
ParseTemporalCalendarString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
nullptr
;
}
auto
parseResult
=
:
:
ParseTemporalCalendarString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
nullptr
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
PlainDateTime
unused
;
if
(
!
ParseISODateTime
(
cx
parsed
&
unused
)
)
{
return
nullptr
;
}
if
(
!
parsed
.
calendar
.
present
(
)
)
{
return
cx
-
>
names
(
)
.
iso8601
;
}
return
ToString
(
cx
linear
parsed
.
calendar
)
;
}
