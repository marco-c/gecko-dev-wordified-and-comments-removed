#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
<
string_view
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
struct
StringName
final
{
size_t
start
=
0
;
size_t
length
=
0
;
bool
present
(
)
const
{
return
length
>
0
;
}
}
;
static
JSLinearString
*
ToString
(
JSContext
*
cx
JSString
*
string
const
StringName
&
name
)
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
NewDependentString
(
cx
string
name
.
start
name
.
length
)
;
}
template
<
typename
CharT
>
bool
EqualCharIgnoreCaseAscii
(
CharT
c1
char
c2
)
{
if
constexpr
(
sizeof
(
CharT
)
>
sizeof
(
char
)
)
{
if
(
!
mozilla
:
:
IsAscii
(
c1
)
)
{
return
false
;
}
}
static
constexpr
auto
toLower
=
0x20
;
static_assert
(
'
a
'
-
'
A
'
=
=
toLower
)
;
char
c
=
c1
;
if
(
mozilla
:
:
IsAsciiUppercaseAlpha
(
c1
)
)
{
c
=
char
(
c
+
toLower
)
;
}
char
d
=
c2
;
if
(
mozilla
:
:
IsAsciiUppercaseAlpha
(
c2
)
)
{
d
=
char
(
d
+
toLower
)
;
}
return
c
=
=
d
;
}
using
CalendarName
=
StringName
;
using
AnnotationKey
=
StringName
;
using
AnnotationValue
=
StringName
;
using
TimeZoneName
=
StringName
;
struct
Annotation
final
{
AnnotationKey
key
;
AnnotationValue
value
;
bool
critical
=
false
;
}
;
struct
TimeSpec
final
{
PlainTime
time
;
}
;
struct
TimeZoneUTCOffset
final
{
int32_t
sign
=
0
;
int32_t
hour
=
0
;
int32_t
minute
=
0
;
}
;
struct
DateTimeUTCOffset
final
{
int32_t
sign
=
0
;
int32_t
hour
=
0
;
int32_t
minute
=
0
;
int32_t
second
=
0
;
int32_t
fractionalPart
=
0
;
bool
subMinutePrecision
=
false
;
TimeZoneUTCOffset
toTimeZoneUTCOffset
(
)
const
{
MOZ_ASSERT
(
!
subMinutePrecision
"
unexpected
sub
-
minute
precision
"
)
;
return
{
sign
hour
minute
}
;
}
}
;
static
int64_t
ParseDateTimeUTCOffset
(
const
DateTimeUTCOffset
&
offset
)
{
constexpr
int64_t
nanoPerSec
=
1
'
000
'
000
'
000
;
MOZ_ASSERT
(
offset
.
sign
=
=
-
1
|
|
offset
.
sign
=
=
+
1
)
;
MOZ_ASSERT
(
0
<
=
offset
.
hour
&
&
offset
.
hour
<
24
)
;
MOZ_ASSERT
(
0
<
=
offset
.
minute
&
&
offset
.
minute
<
60
)
;
MOZ_ASSERT
(
0
<
=
offset
.
second
&
&
offset
.
second
<
60
)
;
MOZ_ASSERT
(
0
<
=
offset
.
fractionalPart
&
&
offset
.
fractionalPart
<
nanoPerSec
)
;
int64_t
seconds
=
(
offset
.
hour
*
60
+
offset
.
minute
)
*
60
+
offset
.
second
;
int64_t
nanos
=
(
seconds
*
nanoPerSec
)
+
offset
.
fractionalPart
;
int64_t
result
=
offset
.
sign
*
nanos
;
MOZ_ASSERT
(
std
:
:
abs
(
result
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
"
time
zone
offset
is
less
than
24
:
00
hours
"
)
;
return
result
;
}
static
int32_t
ParseTimeZoneOffset
(
const
TimeZoneUTCOffset
&
offset
)
{
MOZ_ASSERT
(
offset
.
sign
=
=
-
1
|
|
offset
.
sign
=
=
+
1
)
;
MOZ_ASSERT
(
0
<
=
offset
.
hour
&
&
offset
.
hour
<
24
)
;
MOZ_ASSERT
(
0
<
=
offset
.
minute
&
&
offset
.
minute
<
60
)
;
int32_t
result
=
offset
.
sign
*
(
offset
.
hour
*
60
+
offset
.
minute
)
;
MOZ_ASSERT
(
std
:
:
abs
(
result
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
"
time
zone
offset
is
less
than
24
:
00
hours
"
)
;
return
result
;
}
struct
TimeZoneAnnotation
final
{
TimeZoneUTCOffset
offset
;
TimeZoneName
name
;
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasName
(
)
const
{
return
name
.
present
(
)
;
}
}
;
struct
TimeZoneString
final
{
DateTimeUTCOffset
offset
;
TimeZoneAnnotation
annotation
;
bool
utc
=
false
;
static
auto
from
(
DateTimeUTCOffset
offset
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
offset
=
offset
;
return
timeZone
;
}
static
auto
from
(
TimeZoneUTCOffset
offset
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
annotation
.
offset
=
offset
;
return
timeZone
;
}
static
auto
from
(
TimeZoneName
name
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
annotation
.
name
=
name
;
return
timeZone
;
}
static
auto
UTC
(
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
utc
=
true
;
return
timeZone
;
}
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasAnnotation
(
)
const
{
return
annotation
.
hasName
(
)
|
|
annotation
.
hasOffset
(
)
;
}
bool
isUTC
(
)
const
{
return
utc
;
}
}
;
struct
ZonedDateTimeString
final
{
PlainDate
date
;
PlainTime
time
;
TimeZoneString
timeZone
;
CalendarName
calendar
;
}
;
template
<
typename
CharT
>
static
bool
IsISO8601Calendar
(
mozilla
:
:
Span
<
const
CharT
>
calendar
)
{
static
constexpr
std
:
:
string_view
iso8601
=
"
iso8601
"
;
if
(
calendar
.
size
(
)
!
=
iso8601
.
length
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
iso8601
.
length
(
)
;
i
+
+
)
{
if
(
!
EqualCharIgnoreCaseAscii
(
calendar
[
i
]
iso8601
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
static
constexpr
int32_t
AbsentYear
=
INT32_MAX
;
static
bool
ParseISODateTime
(
JSContext
*
cx
const
ZonedDateTimeString
&
parsed
PlainDateTime
*
result
)
{
PlainDateTime
dateTime
=
{
parsed
.
date
parsed
.
time
}
;
if
(
dateTime
.
date
.
year
=
=
AbsentYear
)
{
dateTime
.
date
.
year
=
0
;
}
if
(
dateTime
.
date
.
month
=
=
0
)
{
dateTime
.
date
.
month
=
1
;
}
if
(
dateTime
.
date
.
day
=
=
0
)
{
dateTime
.
date
.
day
=
1
;
}
if
(
dateTime
.
time
.
second
=
=
60
)
{
dateTime
.
time
.
second
=
59
;
}
MOZ_ASSERT
(
std
:
:
abs
(
dateTime
.
date
.
year
)
<
=
999
'
999
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
month
&
&
dateTime
.
date
.
month
<
=
12
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
day
&
&
dateTime
.
date
.
day
<
=
31
)
;
if
(
!
ThrowIfInvalidISODate
(
cx
dateTime
.
date
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidTime
(
dateTime
.
time
)
)
;
*
result
=
dateTime
;
return
true
;
}
static
bool
ParseTimeZoneAnnotation
(
JSContext
*
cx
const
TimeZoneAnnotation
&
annotation
JSLinearString
*
linear
MutableHandle
<
ParsedTimeZone
>
result
)
{
MOZ_ASSERT
(
annotation
.
hasOffset
(
)
|
|
annotation
.
hasName
(
)
)
;
if
(
annotation
.
hasOffset
(
)
)
{
int32_t
offset
=
ParseTimeZoneOffset
(
annotation
.
offset
)
;
result
.
set
(
ParsedTimeZone
:
:
fromOffset
(
offset
)
)
;
return
true
;
}
auto
*
str
=
ToString
(
cx
linear
annotation
.
name
)
;
if
(
!
str
)
{
return
false
;
}
result
.
set
(
ParsedTimeZone
:
:
fromName
(
str
)
)
;
return
true
;
}
struct
TemporalDurationString
final
{
double
years
=
0
;
double
months
=
0
;
double
weeks
=
0
;
double
days
=
0
;
double
hours
=
0
;
double
minutes
=
0
;
double
seconds
=
0
;
int32_t
hoursFraction
=
0
;
int32_t
minutesFraction
=
0
;
int32_t
secondsFraction
=
0
;
int32_t
sign
=
0
;
}
;
class
ParserError
final
{
JSErrNum
error_
=
JSMSG_NOT_AN_ERROR
;
public
:
constexpr
MOZ_IMPLICIT
ParserError
(
JSErrNum
error
)
:
error_
(
error
)
{
}
constexpr
JSErrNum
error
(
)
const
{
return
error_
;
}
constexpr
operator
JSErrNum
(
)
const
{
return
error
(
)
;
}
}
;
namespace
mozilla
:
:
detail
{
static_assert
(
static_cast
<
JSErrNum
>
(
0
)
=
=
JSMSG_NOT_AN_ERROR
)
;
template
<
>
struct
UnusedZero
<
:
:
ParserError
>
{
private
:
using
Error
=
:
:
ParserError
;
using
ErrorKind
=
JSErrNum
;
public
:
using
StorageType
=
std
:
:
underlying_type_t
<
ErrorKind
>
;
static
constexpr
bool
value
=
true
;
static
constexpr
StorageType
nullValue
=
0
;
static
constexpr
Error
Inspect
(
const
StorageType
&
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
Error
Unwrap
(
StorageType
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
StorageType
Store
(
Error
aValue
)
{
return
static_cast
<
StorageType
>
(
aValue
.
error
(
)
)
;
}
}
;
}
static_assert
(
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
:
:
Strategy
!
=
mozilla
:
:
detail
:
:
PackingStrategy
:
:
Variant
)
;
template
<
typename
CharT
>
class
StringReader
final
{
mozilla
:
:
Span
<
const
CharT
>
string_
;
size_t
index_
=
0
;
public
:
explicit
StringReader
(
mozilla
:
:
Span
<
const
CharT
>
string
)
:
string_
(
string
)
{
}
mozilla
:
:
Span
<
const
CharT
>
string
(
)
const
{
return
string_
;
}
mozilla
:
:
Span
<
const
CharT
>
substring
(
const
StringName
&
name
)
const
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
string_
.
Subspan
(
name
.
start
name
.
length
)
;
}
size_t
index
(
)
const
{
return
index_
;
}
size_t
length
(
)
const
{
return
string_
.
size
(
)
;
}
bool
atEnd
(
)
const
{
return
index
(
)
=
=
length
(
)
;
}
void
reset
(
size_t
index
=
0
)
{
MOZ_ASSERT
(
index
<
=
length
(
)
)
;
index_
=
index
;
}
bool
hasMore
(
size_t
amount
)
const
{
return
index
(
)
+
amount
<
=
length
(
)
;
}
void
advance
(
size_t
amount
)
{
MOZ_ASSERT
(
hasMore
(
amount
)
)
;
index_
+
=
amount
;
}
CharT
current
(
)
const
{
return
string
(
)
[
index
(
)
]
;
}
CharT
next
(
)
const
{
return
string
(
)
[
index
(
)
+
1
]
;
}
CharT
at
(
size_t
index
)
const
{
return
string
(
)
[
index
]
;
}
}
;
template
<
typename
CharT
>
class
TemporalParser
final
{
StringReader
<
CharT
>
reader_
;
mozilla
:
:
Maybe
<
double
>
digits
(
JSContext
*
cx
)
;
mozilla
:
:
Maybe
<
int32_t
>
digits
(
size_t
length
)
{
MOZ_ASSERT
(
length
>
0
"
can
'
t
read
zero
digits
"
)
;
MOZ_ASSERT
(
length
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
digits10
"
can
'
t
read
more
than
digits10
digits
without
overflow
"
)
;
if
(
!
reader_
.
hasMore
(
length
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int32_t
num
=
0
;
size_t
index
=
reader_
.
index
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
auto
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiDigit
(
ch
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
num
=
num
*
10
+
AsciiDigitToNumber
(
ch
)
;
}
reader_
.
advance
(
length
)
;
return
mozilla
:
:
Some
(
num
)
;
}
mozilla
:
:
Maybe
<
int32_t
>
fraction
(
)
{
if
(
!
reader_
.
hasMore
(
2
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
if
(
!
hasDecimalSeparator
(
)
|
|
!
mozilla
:
:
IsAsciiDigit
(
reader_
.
next
(
)
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ALWAYS_TRUE
(
decimalSeparator
(
)
)
;
constexpr
size_t
maxFractions
=
9
;
int32_t
num
=
0
;
size_t
index
=
reader_
.
index
(
)
;
size_t
i
=
0
;
for
(
;
i
<
std
:
:
min
(
reader_
.
length
(
)
-
index
maxFractions
)
;
i
+
+
)
{
CharT
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiDigit
(
ch
)
)
{
break
;
}
num
=
num
*
10
+
AsciiDigitToNumber
(
ch
)
;
}
reader_
.
advance
(
i
)
;
for
(
;
i
<
maxFractions
;
i
+
+
)
{
num
*
=
10
;
}
return
mozilla
:
:
Some
(
num
)
;
}
bool
hasCharacter
(
CharT
ch
)
const
{
return
reader_
.
hasMore
(
1
)
&
&
reader_
.
current
(
)
=
=
ch
;
}
bool
character
(
CharT
ch
)
{
if
(
!
hasCharacter
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
template
<
size_t
N
>
bool
string
(
const
char
(
&
str
)
[
N
]
)
{
static_assert
(
N
>
2
"
use
character
(
)
for
one
element
strings
"
)
;
if
(
!
reader_
.
hasMore
(
N
-
1
)
)
{
return
false
;
}
size_t
index
=
reader_
.
index
(
)
;
for
(
size_t
i
=
0
;
i
<
N
-
1
;
i
+
+
)
{
if
(
reader_
.
at
(
index
+
i
)
!
=
str
[
i
]
)
{
return
false
;
}
}
reader_
.
advance
(
N
-
1
)
;
return
true
;
}
bool
hasTwoAsciiAlpha
(
)
{
if
(
!
reader_
.
hasMore
(
2
)
)
{
return
false
;
}
size_t
index
=
reader_
.
index
(
)
;
return
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
)
)
&
&
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
+
1
)
)
;
}
bool
hasOneOf
(
std
:
:
initializer_list
<
char16_t
>
chars
)
const
{
if
(
!
reader_
.
hasMore
(
1
)
)
{
return
false
;
}
auto
ch
=
reader_
.
current
(
)
;
return
std
:
:
find
(
chars
.
begin
(
)
chars
.
end
(
)
ch
)
!
=
chars
.
end
(
)
;
}
bool
oneOf
(
std
:
:
initializer_list
<
char16_t
>
chars
)
{
if
(
!
hasOneOf
(
chars
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
template
<
typename
Predicate
>
bool
matches
(
Predicate
&
&
predicate
)
{
if
(
!
reader_
.
hasMore
(
1
)
)
{
return
false
;
}
CharT
ch
=
reader_
.
current
(
)
;
if
(
!
predicate
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
bool
hasSign
(
)
const
{
return
hasOneOf
(
{
'
+
'
'
-
'
0x2212
}
)
;
}
int32_t
sign
(
)
{
MOZ_ASSERT
(
hasSign
(
)
)
;
int32_t
plus
=
hasCharacter
(
'
+
'
)
;
reader_
.
advance
(
1
)
;
return
plus
?
1
:
-
1
;
}
bool
hasDecimalSeparator
(
)
const
{
return
hasOneOf
(
{
'
.
'
'
'
}
)
;
}
bool
decimalSeparator
(
)
{
return
oneOf
(
{
'
.
'
'
'
}
)
;
}
bool
daysDesignator
(
)
{
return
oneOf
(
{
'
D
'
'
d
'
}
)
;
}
bool
hoursDesignator
(
)
{
return
oneOf
(
{
'
H
'
'
h
'
}
)
;
}
bool
minutesDesignator
(
)
{
return
oneOf
(
{
'
M
'
'
m
'
}
)
;
}
bool
monthsDesignator
(
)
{
return
oneOf
(
{
'
M
'
'
m
'
}
)
;
}
bool
durationDesignator
(
)
{
return
oneOf
(
{
'
P
'
'
p
'
}
)
;
}
bool
secondsDesignator
(
)
{
return
oneOf
(
{
'
S
'
'
s
'
}
)
;
}
bool
dateTimeSeparator
(
)
{
return
oneOf
(
{
'
'
'
T
'
'
t
'
}
)
;
}
bool
hasTimeDesignator
(
)
const
{
return
hasOneOf
(
{
'
T
'
'
t
'
}
)
;
}
bool
timeDesignator
(
)
{
return
oneOf
(
{
'
T
'
'
t
'
}
)
;
}
bool
weeksDesignator
(
)
{
return
oneOf
(
{
'
W
'
'
w
'
}
)
;
}
bool
yearsDesignator
(
)
{
return
oneOf
(
{
'
Y
'
'
y
'
}
)
;
}
bool
utcDesignator
(
)
{
return
oneOf
(
{
'
Z
'
'
z
'
}
)
;
}
bool
tzLeadingChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiAlpha
(
ch
)
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
tzChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiAlphanumeric
(
ch
)
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
_
'
|
|
ch
=
=
'
-
'
|
|
ch
=
=
'
+
'
;
}
)
;
}
bool
annotationCriticalFlag
(
)
{
return
character
(
'
!
'
)
;
}
bool
aKeyLeadingChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
ch
)
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
aKeyChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
ch
)
|
|
mozilla
:
:
IsAsciiDigit
(
ch
)
|
|
ch
=
=
'
-
'
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
annotationValueComponent
(
)
{
size_t
index
=
reader_
.
index
(
)
;
size_t
i
=
0
;
for
(
;
index
+
i
<
reader_
.
length
(
)
;
i
+
+
)
{
auto
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiAlphanumeric
(
ch
)
)
{
break
;
}
}
if
(
i
=
=
0
)
{
return
false
;
}
reader_
.
advance
(
i
)
;
return
true
;
}
template
<
typename
T
>
static
constexpr
bool
inBounds
(
const
T
&
x
const
T
&
min
const
T
&
max
)
{
return
min
<
=
x
&
&
x
<
=
max
;
}
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
dateTime
(
)
;
mozilla
:
:
Result
<
PlainDate
ParserError
>
date
(
)
;
mozilla
:
:
Result
<
PlainDate
ParserError
>
dateSpecYearMonth
(
)
;
mozilla
:
:
Result
<
PlainDate
ParserError
>
dateSpecMonthDay
(
)
;
mozilla
:
:
Result
<
PlainDate
ParserError
>
validMonthDay
(
)
;
mozilla
:
:
Result
<
PlainTime
ParserError
>
timeSpec
(
)
;
bool
hasAnnotationStart
(
)
const
{
return
hasCharacter
(
'
[
'
)
;
}
bool
hasTimeZoneAnnotationStart
(
)
const
{
if
(
!
hasCharacter
(
'
[
'
)
)
{
return
false
;
}
for
(
size_t
i
=
reader_
.
index
(
)
+
1
;
i
<
reader_
.
length
(
)
;
i
+
+
)
{
CharT
ch
=
reader_
.
at
(
i
)
;
if
(
ch
=
=
'
=
'
)
{
return
false
;
}
if
(
ch
=
=
'
]
'
)
{
break
;
}
}
return
true
;
}
bool
hasDateTimeUTCOffsetStart
(
)
{
return
hasOneOf
(
{
'
Z
'
'
z
'
'
+
'
'
-
'
0x2212
}
)
;
}
mozilla
:
:
Result
<
TimeZoneString
ParserError
>
dateTimeUTCOffset
(
)
;
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
utcOffsetSubMinutePrecision
(
)
;
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
timeZoneUTCOffsetName
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
timeZoneIdentifier
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
timeZoneAnnotation
(
)
;
mozilla
:
:
Result
<
TimeZoneName
ParserError
>
timeZoneIANAName
(
)
;
mozilla
:
:
Result
<
AnnotationKey
ParserError
>
annotationKey
(
)
;
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
annotationValue
(
)
;
mozilla
:
:
Result
<
Annotation
ParserError
>
annotation
(
)
;
mozilla
:
:
Result
<
CalendarName
ParserError
>
annotations
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedTime
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedDateTime
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedDateTimeTimeRequired
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedYearMonth
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedMonthDay
(
)
;
public
:
explicit
TemporalParser
(
mozilla
:
:
Span
<
const
CharT
>
str
)
:
reader_
(
str
)
{
}
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalInstantString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalTimeZoneString
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
parseTimeZoneIdentifier
(
)
;
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
parseTimeZoneOffsetString
(
)
;
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
parseDateTimeUTCOffset
(
)
;
mozilla
:
:
Result
<
TemporalDurationString
ParserError
>
parseTemporalDurationString
(
JSContext
*
cx
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalCalendarString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalTimeString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalMonthDayString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalYearMonthString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalDateTimeString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalZonedDateTimeString
(
)
;
}
;
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
dateTime
(
)
{
ZonedDateTimeString
result
=
{
}
;
auto
dt
=
date
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
result
.
date
=
dt
.
unwrap
(
)
;
if
(
dateTimeSeparator
(
)
)
{
auto
time
=
timeSpec
(
)
;
if
(
time
.
isErr
(
)
)
{
return
time
.
propagateErr
(
)
;
}
result
.
time
=
time
.
unwrap
(
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
auto
tz
=
dateTimeUTCOffset
(
)
;
if
(
tz
.
isErr
(
)
)
{
return
tz
.
propagateErr
(
)
;
}
result
.
timeZone
=
tz
.
unwrap
(
)
;
}
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
PlainDate
ParserError
>
TemporalParser
<
CharT
>
:
:
date
(
)
{
PlainDate
result
=
{
}
;
if
(
auto
year
=
digits
(
4
)
)
{
result
.
year
=
year
.
value
(
)
;
}
else
if
(
hasSign
(
)
)
{
int32_t
yearSign
=
sign
(
)
;
if
(
auto
year
=
digits
(
6
)
)
{
result
.
year
=
yearSign
*
year
.
value
(
)
;
if
(
yearSign
<
0
&
&
result
.
year
=
=
0
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_NEGATIVE_ZERO_YEAR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_EXTENDED_YEAR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_YEAR
)
;
}
character
(
'
-
'
)
;
if
(
auto
month
=
digits
(
2
)
)
{
result
.
month
=
month
.
value
(
)
;
if
(
!
inBounds
(
result
.
month
1
12
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MONTH
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MONTH
)
;
}
character
(
'
-
'
)
;
if
(
auto
day
=
digits
(
2
)
)
{
result
.
day
=
day
.
value
(
)
;
if
(
!
inBounds
(
result
.
day
1
31
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DAY
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
PlainTime
ParserError
>
TemporalParser
<
CharT
>
:
:
timeSpec
(
)
{
PlainTime
result
=
{
}
;
if
(
auto
hour
=
digits
(
2
)
)
{
result
.
hour
=
hour
.
value
(
)
;
if
(
!
inBounds
(
result
.
hour
0
23
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_HOUR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_HOUR
)
;
}
bool
needsMinutes
=
character
(
'
:
'
)
;
if
(
auto
minute
=
digits
(
2
)
)
{
result
.
minute
=
minute
.
value
(
)
;
if
(
!
inBounds
(
result
.
minute
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MINUTE
)
;
}
bool
needsSeconds
=
needsMinutes
&
&
character
(
'
:
'
)
;
if
(
auto
second
=
digits
(
2
)
)
{
result
.
second
=
second
.
value
(
)
;
if
(
!
inBounds
(
result
.
second
0
60
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_LEAPSECOND
)
;
}
if
(
auto
f
=
fraction
(
)
)
{
int32_t
fractionalPart
=
f
.
value
(
)
;
result
.
millisecond
=
fractionalPart
/
1
'
000
'
000
;
result
.
microsecond
=
(
fractionalPart
%
1
'
000
'
000
)
/
1
'
000
;
result
.
nanosecond
=
fractionalPart
%
1
'
000
;
}
}
else
if
(
needsSeconds
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_SECOND
)
;
}
}
else
if
(
needsMinutes
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MINUTE
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneString
ParserError
>
TemporalParser
<
CharT
>
:
:
dateTimeUTCOffset
(
)
{
if
(
utcDesignator
(
)
)
{
return
TimeZoneString
:
:
UTC
(
)
;
}
if
(
hasSign
(
)
)
{
auto
offset
=
utcOffsetSubMinutePrecision
(
)
;
if
(
offset
.
isErr
(
)
)
{
return
offset
.
propagateErr
(
)
;
}
return
TimeZoneString
:
:
from
(
offset
.
unwrap
(
)
)
;
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneUTCOffsetName
(
)
{
TimeZoneUTCOffset
result
=
{
}
;
if
(
!
hasSign
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN
)
;
}
result
.
sign
=
sign
(
)
;
if
(
auto
hour
=
digits
(
2
)
)
{
result
.
hour
=
hour
.
value
(
)
;
if
(
!
inBounds
(
result
.
hour
0
23
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_HOUR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_HOUR
)
;
}
bool
needsMinutes
=
character
(
'
:
'
)
;
if
(
auto
minute
=
digits
(
2
)
)
{
result
.
minute
=
minute
.
value
(
)
;
if
(
!
inBounds
(
result
.
minute
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MINUTE
)
;
}
if
(
hasCharacter
(
'
:
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE
)
;
}
}
else
if
(
needsMinutes
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MINUTE
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
utcOffsetSubMinutePrecision
(
)
{
DateTimeUTCOffset
result
=
{
}
;
if
(
!
hasSign
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN
)
;
}
result
.
sign
=
sign
(
)
;
if
(
auto
hour
=
digits
(
2
)
)
{
result
.
hour
=
hour
.
value
(
)
;
if
(
!
inBounds
(
result
.
hour
0
23
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_HOUR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_HOUR
)
;
}
bool
needsMinutes
=
character
(
'
:
'
)
;
if
(
auto
minute
=
digits
(
2
)
)
{
result
.
minute
=
minute
.
value
(
)
;
if
(
!
inBounds
(
result
.
minute
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MINUTE
)
;
}
bool
needsSeconds
=
needsMinutes
&
&
character
(
'
:
'
)
;
if
(
auto
second
=
digits
(
2
)
)
{
result
.
second
=
second
.
value
(
)
;
if
(
!
inBounds
(
result
.
second
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_SECOND
)
;
}
if
(
auto
fractionalPart
=
fraction
(
)
)
{
result
.
fractionalPart
=
fractionalPart
.
value
(
)
;
}
result
.
subMinutePrecision
=
true
;
}
else
if
(
needsSeconds
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_SECOND
)
;
}
}
else
if
(
needsMinutes
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MINUTE
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneIdentifier
(
)
{
TimeZoneAnnotation
result
=
{
}
;
if
(
hasSign
(
)
)
{
auto
offset
=
timeZoneUTCOffsetName
(
)
;
if
(
offset
.
isErr
(
)
)
{
return
offset
.
propagateErr
(
)
;
}
result
.
offset
=
offset
.
unwrap
(
)
;
}
else
{
auto
name
=
timeZoneIANAName
(
)
;
if
(
name
.
isErr
(
)
)
{
return
name
.
propagateErr
(
)
;
}
result
.
name
=
name
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneAnnotation
(
)
{
if
(
!
character
(
'
[
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_TIMEZONE
)
;
}
annotationCriticalFlag
(
)
;
auto
result
=
timeZoneIdentifier
(
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
if
(
!
character
(
'
]
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_TIMEZONE
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneName
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneIANAName
(
)
{
size_t
start
=
reader_
.
index
(
)
;
do
{
if
(
!
tzLeadingChar
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_NAME
)
;
}
while
(
tzChar
(
)
)
{
}
}
while
(
character
(
'
/
'
)
)
;
return
TimeZoneName
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Maybe
<
double
>
TemporalParser
<
CharT
>
:
:
digits
(
JSContext
*
cx
)
{
auto
span
=
reader_
.
string
(
)
.
Subspan
(
reader_
.
index
(
)
)
;
const
CharT
*
endp
=
nullptr
;
double
num
;
MOZ_ALWAYS_TRUE
(
GetPrefixInteger
(
span
.
data
(
)
span
.
data
(
)
+
span
.
size
(
)
10
IntegerSeparatorHandling
:
:
None
&
endp
&
num
)
)
;
size_t
len
=
endp
-
span
.
data
(
)
;
if
(
len
=
=
0
)
{
return
mozilla
:
:
Nothing
(
)
;
}
reader_
.
advance
(
len
)
;
return
mozilla
:
:
Some
(
num
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalInstantString
(
)
{
ZonedDateTimeString
result
=
{
}
;
auto
dt
=
date
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
result
.
date
=
dt
.
unwrap
(
)
;
if
(
!
dateTimeSeparator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR
)
;
}
auto
time
=
timeSpec
(
)
;
if
(
time
.
isErr
(
)
)
{
return
time
.
propagateErr
(
)
;
}
result
.
time
=
time
.
unwrap
(
)
;
auto
tz
=
dateTimeUTCOffset
(
)
;
if
(
tz
.
isErr
(
)
)
{
return
tz
.
propagateErr
(
)
;
}
result
.
timeZone
=
tz
.
unwrap
(
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
if
(
auto
cal
=
annotations
(
)
;
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
result
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalInstantString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalInstantString
(
)
;
}
static
auto
ParseTemporalInstantString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalInstantString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalInstantString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalInstantString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDateTime
*
result
int64_t
*
offset
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalInstantString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
!
ParseISODateTime
(
cx
parsed
result
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
*
offset
=
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
;
}
else
{
MOZ_ASSERT
(
parsed
.
timeZone
.
isUTC
(
)
)
;
*
offset
=
0
;
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalTimeZoneString
(
)
{
if
(
hasSign
(
)
)
{
if
(
auto
offset
=
timeZoneUTCOffsetName
(
)
;
offset
.
isOk
(
)
&
&
reader_
.
atEnd
(
)
)
{
ZonedDateTimeString
result
=
{
}
;
result
.
timeZone
=
TimeZoneString
:
:
from
(
offset
.
unwrap
(
)
)
;
return
result
;
}
}
else
{
if
(
auto
name
=
timeZoneIANAName
(
)
;
name
.
isOk
(
)
&
&
reader_
.
atEnd
(
)
)
{
ZonedDateTimeString
result
=
{
}
;
result
.
timeZone
=
TimeZoneString
:
:
from
(
name
.
unwrap
(
)
)
;
return
result
;
}
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalDateTimeString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalInstantString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalTimeString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalMonthDayString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalYearMonthString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
else
{
return
dt
.
propagateErr
(
)
;
}
}
template
<
typename
CharT
>
static
auto
ParseTemporalTimeZoneString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalTimeZoneString
(
)
;
}
static
auto
ParseTemporalTimeZoneString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalTimeZoneString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalTimeZoneString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalTimeZoneString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
MutableHandle
<
ParsedTimeZone
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalTimeZoneString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
const
auto
&
timeZone
=
parsed
.
timeZone
;
PlainDateTime
unused
;
if
(
!
ParseISODateTime
(
cx
parsed
&
unused
)
)
{
return
false
;
}
if
(
timeZone
.
hasAnnotation
(
)
)
{
if
(
!
ParseTimeZoneAnnotation
(
cx
timeZone
.
annotation
linear
result
)
)
{
return
false
;
}
}
else
if
(
timeZone
.
isUTC
(
)
)
{
result
.
set
(
ParsedTimeZone
:
:
fromName
(
cx
-
>
names
(
)
.
UTC
)
)
;
}
else
if
(
timeZone
.
hasOffset
(
)
)
{
if
(
timeZone
.
offset
.
subMinutePrecision
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE
)
;
return
false
;
}
int32_t
offset
=
ParseTimeZoneOffset
(
timeZone
.
offset
.
toTimeZoneUTCOffset
(
)
)
;
result
.
set
(
ParsedTimeZone
:
:
fromOffset
(
offset
)
)
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE
)
;
return
false
;
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTimeZoneIdentifier
(
)
{
auto
result
=
timeZoneIdentifier
(
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
result
;
}
template
<
typename
CharT
>
static
auto
ParseTimeZoneIdentifier
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTimeZoneIdentifier
(
)
;
}
static
auto
ParseTimeZoneIdentifier
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTimeZoneIdentifier
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTimeZoneIdentifier
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTimeZoneIdentifier
(
JSContext
*
cx
Handle
<
JSString
*
>
str
MutableHandle
<
ParsedTimeZone
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTimeZoneIdentifier
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
auto
timeZone
=
parseResult
.
unwrap
(
)
;
return
ParseTimeZoneAnnotation
(
cx
timeZone
linear
result
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTimeZoneOffsetString
(
)
{
auto
offset
=
timeZoneUTCOffsetName
(
)
;
if
(
offset
.
isErr
(
)
)
{
return
offset
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
offset
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTimeZoneOffsetString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTimeZoneOffsetString
(
)
;
}
static
auto
ParseTimeZoneOffsetString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTimeZoneOffsetString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTimeZoneOffsetString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTimeZoneOffsetString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
int32_t
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTimeZoneOffsetString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
*
result
=
ParseTimeZoneOffset
(
parseResult
.
unwrap
(
)
)
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
parseDateTimeUTCOffset
(
)
{
auto
offset
=
utcOffsetSubMinutePrecision
(
)
;
if
(
offset
.
isErr
(
)
)
{
return
offset
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
offset
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseDateTimeUTCOffset
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseDateTimeUTCOffset
(
)
;
}
static
auto
ParseDateTimeUTCOffset
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseDateTimeUTCOffset
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseDateTimeUTCOffset
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseDateTimeUTCOffset
(
JSContext
*
cx
Handle
<
JSString
*
>
str
int64_t
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseDateTimeUTCOffset
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
*
result
=
ParseDateTimeUTCOffset
(
parseResult
.
unwrap
(
)
)
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TemporalDurationString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalDurationString
(
JSContext
*
cx
)
{
TemporalDurationString
result
=
{
}
;
if
(
hasSign
(
)
)
{
result
.
sign
=
sign
(
)
;
}
if
(
!
durationDesignator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DESIGNATOR
)
;
}
do
{
double
num
;
if
(
hasTimeDesignator
(
)
)
{
break
;
}
if
(
auto
d
=
digits
(
cx
)
;
!
d
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
else
{
num
=
*
d
;
}
if
(
yearsDesignator
(
)
)
{
result
.
years
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
if
(
auto
d
=
digits
(
cx
)
;
!
d
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
else
{
num
=
*
d
;
}
}
if
(
monthsDesignator
(
)
)
{
result
.
months
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
if
(
auto
d
=
digits
(
cx
)
;
!
d
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
else
{
num
=
*
d
;
}
}
if
(
weeksDesignator
(
)
)
{
result
.
weeks
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
if
(
auto
d
=
digits
(
cx
)
;
!
d
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
else
{
num
=
*
d
;
}
}
if
(
daysDesignator
(
)
)
{
result
.
days
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
while
(
false
)
;
if
(
!
timeDesignator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIME_DESIGNATOR
)
;
}
double
num
;
mozilla
:
:
Maybe
<
int32_t
>
frac
;
auto
digitsAndFraction
=
[
&
]
(
)
{
auto
d
=
digits
(
cx
)
;
if
(
!
d
)
{
return
false
;
}
num
=
*
d
;
frac
=
fraction
(
)
;
return
true
;
}
;
if
(
!
digitsAndFraction
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
bool
hasHoursFraction
=
false
;
if
(
hoursDesignator
(
)
)
{
hasHoursFraction
=
bool
(
frac
)
;
result
.
hours
=
num
;
result
.
hoursFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
!
digitsAndFraction
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
}
bool
hasMinutesFraction
=
false
;
if
(
minutesDesignator
(
)
)
{
if
(
hasHoursFraction
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DURATION_MINUTES
)
;
}
hasMinutesFraction
=
bool
(
frac
)
;
result
.
minutes
=
num
;
result
.
minutesFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
!
digitsAndFraction
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
}
if
(
secondsDesignator
(
)
)
{
if
(
hasHoursFraction
|
|
hasMinutesFraction
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DURATION_SECONDS
)
;
}
result
.
seconds
=
num
;
result
.
secondsFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalDurationString
(
JSContext
*
cx
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalDurationString
(
cx
)
;
}
static
auto
ParseTemporalDurationString
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalDurationString
<
Latin1Char
>
(
cx
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalDurationString
<
char16_t
>
(
cx
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalDurationString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
Duration
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalDurationString
(
cx
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
TemporalDurationString
parsed
=
parseResult
.
unwrap
(
)
;
double
years
=
parsed
.
years
;
double
months
=
parsed
.
months
;
double
weeks
=
parsed
.
weeks
;
double
days
=
parsed
.
days
;
double
hours
=
parsed
.
hours
;
double
minutes
seconds
milliseconds
microseconds
nanoseconds
;
if
(
parsed
.
hoursFraction
)
{
MOZ_ASSERT
(
parsed
.
hoursFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
hoursFraction
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
parsed
.
minutes
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
minutesFraction
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
seconds
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
=
=
0
)
;
int64_t
h
=
int64_t
(
parsed
.
hoursFraction
)
*
60
;
minutes
=
double
(
h
/
1
'
000
'
000
'
000
)
;
int64_t
min
=
(
h
%
1
'
000
'
000
'
000
)
*
60
;
seconds
=
double
(
min
/
1
'
000
'
000
'
000
)
;
milliseconds
=
double
(
(
min
%
1
'
000
'
000
'
000
)
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
min
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
min
%
1
'
000
)
;
}
else
if
(
parsed
.
minutesFraction
)
{
MOZ_ASSERT
(
parsed
.
minutesFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
minutesFraction
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
parsed
.
seconds
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
=
=
0
)
;
minutes
=
parsed
.
minutes
;
int64_t
min
=
int64_t
(
parsed
.
minutesFraction
)
*
60
;
seconds
=
double
(
min
/
1
'
000
'
000
'
000
)
;
milliseconds
=
double
(
(
min
%
1
'
000
'
000
'
000
)
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
min
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
min
%
1
'
000
)
;
}
else
if
(
parsed
.
secondsFraction
)
{
MOZ_ASSERT
(
parsed
.
secondsFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
<
1
'
000
'
000
'
000
)
;
minutes
=
parsed
.
minutes
;
seconds
=
parsed
.
seconds
;
milliseconds
=
double
(
parsed
.
secondsFraction
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
parsed
.
secondsFraction
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
parsed
.
secondsFraction
%
1
'
000
)
;
}
else
{
minutes
=
parsed
.
minutes
;
seconds
=
parsed
.
seconds
;
milliseconds
=
0
;
microseconds
=
0
;
nanoseconds
=
0
;
}
int32_t
factor
=
parsed
.
sign
?
parsed
.
sign
:
1
;
MOZ_ASSERT
(
factor
=
=
-
1
|
|
factor
=
=
1
)
;
*
result
=
{
(
years
*
factor
)
+
(
+
0
.
0
)
(
months
*
factor
)
+
(
+
0
.
0
)
(
weeks
*
factor
)
+
(
+
0
.
0
)
(
days
*
factor
)
+
(
+
0
.
0
)
(
hours
*
factor
)
+
(
+
0
.
0
)
(
minutes
*
factor
)
+
(
+
0
.
0
)
(
seconds
*
factor
)
+
(
+
0
.
0
)
(
milliseconds
*
factor
)
+
(
+
0
.
0
)
(
microseconds
*
factor
)
+
(
+
0
.
0
)
(
nanoseconds
*
factor
)
+
(
+
0
.
0
)
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
*
result
)
)
{
return
false
;
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
AnnotationKey
ParserError
>
TemporalParser
<
CharT
>
:
:
annotationKey
(
)
{
size_t
start
=
reader_
.
index
(
)
;
if
(
!
aKeyLeadingChar
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_KEY
)
;
}
while
(
aKeyChar
(
)
)
{
}
return
AnnotationKey
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
TemporalParser
<
CharT
>
:
:
annotationValue
(
)
{
size_t
start
=
reader_
.
index
(
)
;
do
{
if
(
!
annotationValueComponent
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_VALUE
)
;
}
}
while
(
character
(
'
-
'
)
)
;
return
AnnotationValue
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
Annotation
ParserError
>
TemporalParser
<
CharT
>
:
:
annotation
(
)
{
if
(
!
character
(
'
[
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_ANNOTATION
)
;
}
bool
critical
=
annotationCriticalFlag
(
)
;
auto
key
=
annotationKey
(
)
;
if
(
key
.
isErr
(
)
)
{
return
key
.
propagateErr
(
)
;
}
if
(
!
character
(
'
=
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_ASSIGNMENT_IN_ANNOTATION
)
;
}
auto
value
=
annotationValue
(
)
;
if
(
value
.
isErr
(
)
)
{
return
value
.
propagateErr
(
)
;
}
if
(
!
character
(
'
]
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_ANNOTATION
)
;
}
return
Annotation
{
key
.
unwrap
(
)
value
.
unwrap
(
)
critical
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
CalendarName
ParserError
>
TemporalParser
<
CharT
>
:
:
annotations
(
)
{
MOZ_ASSERT
(
hasAnnotationStart
(
)
)
;
CalendarName
calendar
;
bool
calendarWasCritical
=
false
;
while
(
hasAnnotationStart
(
)
)
{
auto
anno
=
annotation
(
)
;
if
(
anno
.
isErr
(
)
)
{
return
anno
.
propagateErr
(
)
;
}
auto
[
key
value
critical
]
=
anno
.
unwrap
(
)
;
static
constexpr
std
:
:
string_view
ca
=
"
u
-
ca
"
;
auto
keySpan
=
reader_
.
substring
(
key
)
;
if
(
keySpan
.
size
(
)
=
=
ca
.
length
(
)
&
&
std
:
:
equal
(
ca
.
begin
(
)
ca
.
end
(
)
keySpan
.
data
(
)
)
)
{
if
(
!
calendar
.
present
(
)
)
{
calendar
=
value
;
calendarWasCritical
=
critical
;
}
else
if
(
critical
|
|
calendarWasCritical
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION
)
;
}
}
else
if
(
critical
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION
)
;
}
}
return
calendar
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedTime
(
)
{
if
(
timeDesignator
(
)
)
{
ZonedDateTimeString
result
=
{
}
;
auto
time
=
timeSpec
(
)
;
if
(
time
.
isErr
(
)
)
{
return
time
.
propagateErr
(
)
;
}
result
.
time
=
time
.
unwrap
(
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
auto
tz
=
dateTimeUTCOffset
(
)
;
if
(
tz
.
isErr
(
)
)
{
return
tz
.
propagateErr
(
)
;
}
result
.
timeZone
=
tz
.
unwrap
(
)
;
}
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
size_t
start
=
reader_
.
index
(
)
;
ZonedDateTimeString
result
=
{
}
;
auto
time
=
timeSpec
(
)
;
if
(
time
.
isErr
(
)
)
{
return
time
.
propagateErr
(
)
;
}
result
.
time
=
time
.
unwrap
(
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
auto
tz
=
dateTimeUTCOffset
(
)
;
if
(
tz
.
isErr
(
)
)
{
return
tz
.
propagateErr
(
)
;
}
result
.
timeZone
=
tz
.
unwrap
(
)
;
}
size_t
end
=
reader_
.
index
(
)
;
reader_
.
reset
(
start
)
;
if
(
validMonthDay
(
)
.
isOk
(
)
)
{
if
(
reader_
.
index
(
)
=
=
end
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_MONTH_DAY
)
;
}
}
reader_
.
reset
(
start
)
;
if
(
dateSpecYearMonth
(
)
.
isOk
(
)
)
{
if
(
reader_
.
index
(
)
=
=
end
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_YEAR_MONTH
)
;
}
}
reader_
.
reset
(
end
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedDateTime
(
)
{
auto
dt
=
dateTime
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
auto
result
=
dt
.
unwrap
(
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedDateTimeTimeRequired
(
)
{
ZonedDateTimeString
result
=
{
}
;
auto
dt
=
date
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
result
.
date
=
dt
.
unwrap
(
)
;
if
(
!
dateTimeSeparator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR
)
;
}
auto
time
=
timeSpec
(
)
;
if
(
time
.
isErr
(
)
)
{
return
time
.
propagateErr
(
)
;
}
result
.
time
=
time
.
unwrap
(
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
auto
tz
=
dateTimeUTCOffset
(
)
;
if
(
tz
.
isErr
(
)
)
{
return
tz
.
propagateErr
(
)
;
}
result
.
timeZone
=
tz
.
unwrap
(
)
;
}
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedYearMonth
(
)
{
ZonedDateTimeString
result
=
{
}
;
auto
yearMonth
=
dateSpecYearMonth
(
)
;
if
(
yearMonth
.
isErr
(
)
)
{
return
yearMonth
.
propagateErr
(
)
;
}
result
.
date
=
yearMonth
.
unwrap
(
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedMonthDay
(
)
{
ZonedDateTimeString
result
=
{
}
;
auto
monthDay
=
dateSpecMonthDay
(
)
;
if
(
monthDay
.
isErr
(
)
)
{
return
monthDay
.
propagateErr
(
)
;
}
result
.
date
=
monthDay
.
unwrap
(
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
}
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
PlainDate
ParserError
>
TemporalParser
<
CharT
>
:
:
dateSpecYearMonth
(
)
{
PlainDate
result
=
{
}
;
if
(
auto
year
=
digits
(
4
)
)
{
result
.
year
=
year
.
value
(
)
;
}
else
if
(
hasSign
(
)
)
{
int32_t
yearSign
=
sign
(
)
;
if
(
auto
year
=
digits
(
6
)
)
{
result
.
year
=
yearSign
*
year
.
value
(
)
;
if
(
yearSign
<
0
&
&
result
.
year
=
=
0
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_NEGATIVE_ZERO_YEAR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_EXTENDED_YEAR
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_YEAR
)
;
}
character
(
'
-
'
)
;
if
(
auto
month
=
digits
(
2
)
)
{
result
.
month
=
month
.
value
(
)
;
if
(
!
inBounds
(
result
.
month
1
12
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MONTH
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MONTH
)
;
}
result
.
day
=
1
;
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
PlainDate
ParserError
>
TemporalParser
<
CharT
>
:
:
dateSpecMonthDay
(
)
{
PlainDate
result
=
{
}
;
string
(
"
-
-
"
)
;
result
.
year
=
AbsentYear
;
if
(
auto
month
=
digits
(
2
)
)
{
result
.
month
=
month
.
value
(
)
;
if
(
!
inBounds
(
result
.
month
1
12
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MONTH
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MONTH
)
;
}
character
(
'
-
'
)
;
if
(
auto
day
=
digits
(
2
)
)
{
result
.
day
=
day
.
value
(
)
;
if
(
!
inBounds
(
result
.
day
1
31
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DAY
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
PlainDate
ParserError
>
TemporalParser
<
CharT
>
:
:
validMonthDay
(
)
{
PlainDate
result
=
{
}
;
if
(
auto
month
=
digits
(
2
)
)
{
result
.
month
=
month
.
value
(
)
;
if
(
!
inBounds
(
result
.
month
1
12
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MONTH
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MONTH
)
;
}
character
(
'
-
'
)
;
if
(
auto
day
=
digits
(
2
)
)
{
result
.
day
=
day
.
value
(
)
;
if
(
!
inBounds
(
result
.
day
1
31
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
}
else
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DAY
)
;
}
if
(
result
.
month
=
=
2
&
&
result
.
day
>
29
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
if
(
result
.
day
>
30
)
{
MOZ_ASSERT
(
result
.
day
=
=
31
)
;
static
constexpr
int32_t
monthsWithThirtyOneDays
[
]
=
{
1
3
5
7
8
10
12
}
;
if
(
std
:
:
find
(
std
:
:
begin
(
monthsWithThirtyOneDays
)
std
:
:
end
(
monthsWithThirtyOneDays
)
result
.
month
)
=
=
std
:
:
end
(
monthsWithThirtyOneDays
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalCalendarString
(
)
{
if
(
hasTwoAsciiAlpha
(
)
)
{
auto
cal
=
annotationValue
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
ZonedDateTimeString
result
=
{
}
;
result
.
calendar
=
cal
.
unwrap
(
)
;
return
result
;
}
if
(
auto
dt
=
parseTemporalDateTimeString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalInstantString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalTimeString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalMonthDayString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
if
(
auto
dt
=
parseTemporalYearMonthString
(
)
;
dt
.
isOk
(
)
)
{
return
dt
.
unwrap
(
)
;
}
else
{
return
dt
.
propagateErr
(
)
;
}
}
template
<
typename
CharT
>
static
auto
ParseTemporalCalendarString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalCalendarString
(
)
;
}
static
auto
ParseTemporalCalendarString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalCalendarString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalCalendarString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
JSLinearString
*
js
:
:
temporal
:
:
ParseTemporalCalendarString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
nullptr
;
}
auto
parseResult
=
:
:
ParseTemporalCalendarString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
nullptr
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
PlainDateTime
unused
;
if
(
!
ParseISODateTime
(
cx
parsed
&
unused
)
)
{
return
nullptr
;
}
if
(
!
parsed
.
calendar
.
present
(
)
)
{
return
cx
-
>
names
(
)
.
iso8601
;
}
return
ToString
(
cx
linear
parsed
.
calendar
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalTimeString
(
)
{
if
(
auto
time
=
annotatedTime
(
)
;
time
.
isOk
(
)
&
&
reader_
.
atEnd
(
)
)
{
return
time
.
unwrap
(
)
;
}
reader_
.
reset
(
)
;
auto
dt
=
annotatedDateTimeTimeRequired
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
dt
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalTimeString
(
)
;
}
static
auto
ParseTemporalTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainTime
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR
)
;
return
false
;
}
PlainDateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
time
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalMonthDayString
(
)
{
if
(
auto
monthDay
=
annotatedMonthDay
(
)
;
monthDay
.
isOk
(
)
&
&
reader_
.
atEnd
(
)
)
{
auto
result
=
monthDay
.
unwrap
(
)
;
if
(
result
.
calendar
.
present
(
)
&
&
!
IsISO8601Calendar
(
reader_
.
substring
(
result
.
calendar
)
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MONTH_DAY_CALENDAR_NOT_ISO8601
)
;
}
return
result
;
}
reader_
.
reset
(
)
;
auto
dt
=
annotatedDateTime
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
dt
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalMonthDayString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalMonthDayString
(
)
;
}
static
auto
ParseTemporalMonthDayString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalMonthDayString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalMonthDayString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalMonthDayString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDate
*
result
bool
*
hasYear
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalMonthDayString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR
)
;
return
false
;
}
PlainDateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
date
;
*
hasYear
=
parsed
.
date
.
year
!
=
AbsentYear
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalYearMonthString
(
)
{
if
(
auto
yearMonth
=
annotatedYearMonth
(
)
;
yearMonth
.
isOk
(
)
&
&
reader_
.
atEnd
(
)
)
{
auto
result
=
yearMonth
.
unwrap
(
)
;
if
(
result
.
calendar
.
present
(
)
&
&
!
IsISO8601Calendar
(
reader_
.
substring
(
result
.
calendar
)
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_YEAR_MONTH_CALENDAR_NOT_ISO8601
)
;
}
return
result
;
}
reader_
.
reset
(
)
;
auto
dt
=
annotatedDateTime
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
dt
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalYearMonthString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalYearMonthString
(
)
;
}
static
auto
ParseTemporalYearMonthString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalYearMonthString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalYearMonthString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalYearMonthString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDate
*
result
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalYearMonthString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR
)
;
return
false
;
}
PlainDateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
date
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalDateTimeString
(
)
{
auto
dateTime
=
annotatedDateTime
(
)
;
if
(
dateTime
.
isErr
(
)
)
{
return
dateTime
.
propagateErr
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
dateTime
.
unwrap
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalDateTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalDateTimeString
(
)
;
}
static
auto
ParseTemporalDateTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalDateTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalDateTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalDateTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDateTime
*
result
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalDateTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR
)
;
return
false
;
}
if
(
!
ParseISODateTime
(
cx
parsed
result
)
)
{
return
false
;
}
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
bool
js
:
:
temporal
:
:
ParseTemporalDateString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDate
*
result
MutableHandle
<
JSString
*
>
calendar
)
{
PlainDateTime
dateTime
;
if
(
!
ParseTemporalDateTimeString
(
cx
str
&
dateTime
calendar
)
)
{
return
false
;
}
*
result
=
dateTime
.
date
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalZonedDateTimeString
(
)
{
auto
dt
=
dateTime
(
)
;
if
(
dt
.
isErr
(
)
)
{
return
dt
.
propagateErr
(
)
;
}
auto
result
=
dt
.
unwrap
(
)
;
auto
annotation
=
timeZoneAnnotation
(
)
;
if
(
annotation
.
isErr
(
)
)
{
return
annotation
.
propagateErr
(
)
;
}
result
.
timeZone
.
annotation
=
annotation
.
unwrap
(
)
;
if
(
hasAnnotationStart
(
)
)
{
auto
cal
=
annotations
(
)
;
if
(
cal
.
isErr
(
)
)
{
return
cal
.
propagateErr
(
)
;
}
result
.
calendar
=
cal
.
unwrap
(
)
;
}
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT
)
;
}
return
result
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalZonedDateTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalZonedDateTimeString
(
)
;
}
static
auto
ParseTemporalZonedDateTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalZonedDateTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalZonedDateTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalZonedDateTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDateTime
*
dateTime
bool
*
isUTC
bool
*
hasOffset
int64_t
*
timeZoneOffset
MutableHandle
<
ParsedTimeZone
>
timeZoneName
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalZonedDateTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
!
ParseISODateTime
(
cx
parsed
dateTime
)
)
{
return
false
;
}
{
MOZ_ASSERT
(
parsed
.
timeZone
.
hasAnnotation
(
)
)
;
const
auto
&
annotation
=
parsed
.
timeZone
.
annotation
;
if
(
!
ParseTimeZoneAnnotation
(
cx
annotation
linear
timeZoneName
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
*
isUTC
=
true
;
*
hasOffset
=
false
;
*
timeZoneOffset
=
0
;
}
else
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
*
isUTC
=
false
;
*
hasOffset
=
true
;
*
timeZoneOffset
=
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
;
}
else
{
*
isUTC
=
false
;
*
hasOffset
=
false
;
*
timeZoneOffset
=
0
;
}
}
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalRelativeToString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalDateTimeString
(
)
;
}
static
auto
ParseTemporalRelativeToString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalRelativeToString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalRelativeToString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalRelativeToString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
PlainDateTime
*
dateTime
bool
*
isUTC
bool
*
hasOffset
int64_t
*
timeZoneOffset
MutableHandle
<
ParsedTimeZone
>
timeZoneName
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalRelativeToString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
&
&
!
parsed
.
timeZone
.
hasAnnotation
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR_WITHOUT_NAME
)
;
return
false
;
}
if
(
!
ParseISODateTime
(
cx
parsed
dateTime
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
hasAnnotation
(
)
)
{
const
auto
&
annotation
=
parsed
.
timeZone
.
annotation
;
if
(
!
ParseTimeZoneAnnotation
(
cx
annotation
linear
timeZoneName
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
*
isUTC
=
true
;
*
hasOffset
=
false
;
*
timeZoneOffset
=
0
;
}
else
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
*
isUTC
=
false
;
*
hasOffset
=
true
;
*
timeZoneOffset
=
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
;
}
else
{
*
isUTC
=
false
;
*
hasOffset
=
false
;
*
timeZoneOffset
=
0
;
}
}
else
{
*
isUTC
=
false
;
*
hasOffset
=
false
;
*
timeZoneOffset
=
0
;
timeZoneName
.
set
(
ParsedTimeZone
{
}
)
;
}
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
void
js
:
:
temporal
:
:
ParsedTimeZone
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
name
"
ParsedTimeZone
:
:
name
"
)
;
}
