#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
<
algorithm
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
<
string_view
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
struct
StringName
final
{
size_t
start
=
0
;
size_t
length
=
0
;
bool
present
(
)
const
{
return
length
>
0
;
}
}
;
static
JSLinearString
*
ToString
(
JSContext
*
cx
JSString
*
string
const
StringName
&
name
)
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
NewDependentString
(
cx
string
name
.
start
name
.
length
)
;
}
template
<
typename
CharT
>
bool
EqualCharIgnoreCaseAscii
(
CharT
c1
char
c2
)
{
if
constexpr
(
sizeof
(
CharT
)
>
sizeof
(
char
)
)
{
if
(
!
mozilla
:
:
IsAscii
(
c1
)
)
{
return
false
;
}
}
static
constexpr
auto
toLower
=
0x20
;
static_assert
(
'
a
'
-
'
A
'
=
=
toLower
)
;
char
c
=
c1
;
if
(
mozilla
:
:
IsAsciiUppercaseAlpha
(
c1
)
)
{
c
=
char
(
c
+
toLower
)
;
}
char
d
=
c2
;
if
(
mozilla
:
:
IsAsciiUppercaseAlpha
(
c2
)
)
{
d
=
char
(
d
+
toLower
)
;
}
return
c
=
=
d
;
}
using
CalendarName
=
StringName
;
using
AnnotationKey
=
StringName
;
using
AnnotationValue
=
StringName
;
using
TimeZoneName
=
StringName
;
struct
Annotation
final
{
AnnotationKey
key
;
AnnotationValue
value
;
bool
critical
=
false
;
}
;
struct
TimeSpec
final
{
Time
time
;
}
;
struct
TimeZoneUTCOffset
final
{
int32_t
sign
=
0
;
int32_t
hour
=
0
;
int32_t
minute
=
0
;
}
;
struct
DateTimeUTCOffset
final
{
int32_t
sign
=
0
;
int32_t
hour
=
0
;
int32_t
minute
=
0
;
int32_t
second
=
0
;
int32_t
fractionalPart
=
0
;
bool
subMinutePrecision
=
false
;
TimeZoneUTCOffset
toTimeZoneUTCOffset
(
)
const
{
MOZ_ASSERT
(
!
subMinutePrecision
"
unexpected
sub
-
minute
precision
"
)
;
return
{
sign
hour
minute
}
;
}
}
;
static
auto
ParseDateTimeUTCOffset
(
const
DateTimeUTCOffset
&
offset
)
{
constexpr
int64_t
nanoPerSec
=
1
'
000
'
000
'
000
;
MOZ_ASSERT
(
offset
.
sign
=
=
-
1
|
|
offset
.
sign
=
=
+
1
)
;
MOZ_ASSERT
(
0
<
=
offset
.
hour
&
&
offset
.
hour
<
24
)
;
MOZ_ASSERT
(
0
<
=
offset
.
minute
&
&
offset
.
minute
<
60
)
;
MOZ_ASSERT
(
0
<
=
offset
.
second
&
&
offset
.
second
<
60
)
;
MOZ_ASSERT
(
0
<
=
offset
.
fractionalPart
&
&
offset
.
fractionalPart
<
nanoPerSec
)
;
int64_t
seconds
=
(
offset
.
hour
*
60
+
offset
.
minute
)
*
60
+
offset
.
second
;
int64_t
nanos
=
(
seconds
*
nanoPerSec
)
+
offset
.
fractionalPart
;
int64_t
result
=
offset
.
sign
*
nanos
;
MOZ_ASSERT
(
std
:
:
abs
(
result
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
"
time
zone
offset
is
less
than
24
:
00
hours
"
)
;
return
OffsetTimeZone
{
result
offset
.
subMinutePrecision
}
;
}
static
int32_t
ParseTimeZoneOffset
(
const
TimeZoneUTCOffset
&
offset
)
{
MOZ_ASSERT
(
offset
.
sign
=
=
-
1
|
|
offset
.
sign
=
=
+
1
)
;
MOZ_ASSERT
(
0
<
=
offset
.
hour
&
&
offset
.
hour
<
24
)
;
MOZ_ASSERT
(
0
<
=
offset
.
minute
&
&
offset
.
minute
<
60
)
;
int32_t
result
=
offset
.
sign
*
(
offset
.
hour
*
60
+
offset
.
minute
)
;
MOZ_ASSERT
(
std
:
:
abs
(
result
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
"
time
zone
offset
is
less
than
24
:
00
hours
"
)
;
return
result
;
}
struct
TimeZoneAnnotation
final
{
TimeZoneUTCOffset
offset
;
TimeZoneName
name
;
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasName
(
)
const
{
return
name
.
present
(
)
;
}
}
;
struct
TimeZoneString
final
{
DateTimeUTCOffset
offset
;
TimeZoneAnnotation
annotation
;
bool
utc
=
false
;
static
auto
from
(
DateTimeUTCOffset
offset
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
offset
=
offset
;
return
timeZone
;
}
static
auto
from
(
TimeZoneUTCOffset
offset
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
annotation
.
offset
=
offset
;
return
timeZone
;
}
static
auto
from
(
TimeZoneName
name
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
annotation
.
name
=
name
;
return
timeZone
;
}
static
auto
UTC
(
)
{
TimeZoneString
timeZone
{
}
;
timeZone
.
utc
=
true
;
return
timeZone
;
}
bool
hasOffset
(
)
const
{
return
offset
.
sign
!
=
0
;
}
bool
hasAnnotation
(
)
const
{
return
annotation
.
hasName
(
)
|
|
annotation
.
hasOffset
(
)
;
}
bool
isUTC
(
)
const
{
return
utc
;
}
}
;
struct
ZonedDateTimeString
final
{
ISODate
date
;
Time
time
;
TimeZoneString
timeZone
;
CalendarName
calendar
;
bool
startOfDay
;
}
;
template
<
typename
CharT
>
static
bool
IsISO8601Calendar
(
mozilla
:
:
Span
<
const
CharT
>
calendar
)
{
static
constexpr
std
:
:
string_view
iso8601
=
"
iso8601
"
;
if
(
calendar
.
size
(
)
!
=
iso8601
.
length
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
iso8601
.
length
(
)
;
i
+
+
)
{
if
(
!
EqualCharIgnoreCaseAscii
(
calendar
[
i
]
iso8601
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
static
constexpr
int32_t
AbsentYear
=
INT32_MAX
;
static
bool
ParseISODateTime
(
JSContext
*
cx
const
ZonedDateTimeString
&
parsed
ISODateTime
*
result
)
{
ISODateTime
dateTime
=
{
parsed
.
date
parsed
.
time
}
;
if
(
dateTime
.
date
.
year
=
=
AbsentYear
)
{
dateTime
.
date
.
year
=
0
;
}
if
(
dateTime
.
date
.
month
=
=
0
)
{
dateTime
.
date
.
month
=
1
;
}
if
(
dateTime
.
date
.
day
=
=
0
)
{
dateTime
.
date
.
day
=
1
;
}
if
(
dateTime
.
time
.
second
=
=
60
)
{
dateTime
.
time
.
second
=
59
;
}
MOZ_ASSERT
(
std
:
:
abs
(
dateTime
.
date
.
year
)
<
=
999
'
999
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
month
&
&
dateTime
.
date
.
month
<
=
12
)
;
MOZ_ASSERT
(
1
<
=
dateTime
.
date
.
day
&
&
dateTime
.
date
.
day
<
=
31
)
;
if
(
!
ThrowIfInvalidISODate
(
cx
dateTime
.
date
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidISODate
(
dateTime
.
date
)
)
;
MOZ_ASSERT
(
IsValidTime
(
dateTime
.
time
)
)
;
*
result
=
dateTime
;
return
true
;
}
static
bool
ParseTimeZoneAnnotation
(
JSContext
*
cx
const
TimeZoneAnnotation
&
annotation
JSLinearString
*
linear
MutableHandle
<
ParsedTimeZone
>
result
)
{
MOZ_ASSERT
(
annotation
.
hasOffset
(
)
|
|
annotation
.
hasName
(
)
)
;
if
(
annotation
.
hasOffset
(
)
)
{
int32_t
offset
=
ParseTimeZoneOffset
(
annotation
.
offset
)
;
result
.
set
(
ParsedTimeZone
:
:
fromOffset
(
offset
)
)
;
return
true
;
}
auto
*
str
=
ToString
(
cx
linear
annotation
.
name
)
;
if
(
!
str
)
{
return
false
;
}
result
.
set
(
ParsedTimeZone
:
:
fromName
(
str
)
)
;
return
true
;
}
struct
TemporalDurationString
final
{
double
years
=
0
;
double
months
=
0
;
double
weeks
=
0
;
double
days
=
0
;
double
hours
=
0
;
double
minutes
=
0
;
double
seconds
=
0
;
int32_t
hoursFraction
=
0
;
int32_t
minutesFraction
=
0
;
int32_t
secondsFraction
=
0
;
int32_t
sign
=
0
;
}
;
class
ParserError
final
{
JSErrNum
error_
=
JSMSG_NOT_AN_ERROR
;
public
:
constexpr
ParserError
(
)
=
default
;
constexpr
MOZ_IMPLICIT
ParserError
(
JSErrNum
error
)
:
error_
(
error
)
{
}
constexpr
JSErrNum
error
(
)
const
{
return
error_
;
}
constexpr
operator
JSErrNum
(
)
const
{
return
error
(
)
;
}
}
;
namespace
mozilla
:
:
detail
{
static_assert
(
static_cast
<
JSErrNum
>
(
0
)
=
=
JSMSG_NOT_AN_ERROR
)
;
template
<
>
struct
UnusedZero
<
:
:
ParserError
>
{
private
:
using
Error
=
:
:
ParserError
;
using
ErrorKind
=
JSErrNum
;
public
:
using
StorageType
=
std
:
:
underlying_type_t
<
ErrorKind
>
;
static
constexpr
bool
value
=
true
;
static
constexpr
StorageType
nullValue
=
0
;
static
constexpr
Error
Inspect
(
const
StorageType
&
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
Error
Unwrap
(
StorageType
aValue
)
{
return
Error
(
static_cast
<
ErrorKind
>
(
aValue
)
)
;
}
static
constexpr
StorageType
Store
(
Error
aValue
)
{
return
static_cast
<
StorageType
>
(
aValue
.
error
(
)
)
;
}
}
;
}
static_assert
(
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
:
:
Strategy
!
=
mozilla
:
:
detail
:
:
PackingStrategy
:
:
Variant
)
;
class
LikelyError
final
{
size_t
index_
=
0
;
ParserError
error_
{
}
;
public
:
template
<
typename
V
>
void
update
(
const
mozilla
:
:
Result
<
V
ParserError
>
&
result
size_t
index
)
{
MOZ_ASSERT
(
result
.
isErr
(
)
)
;
if
(
index
>
=
index_
)
{
index_
=
index
;
error_
=
result
.
inspectErr
(
)
;
}
}
size_t
index
(
)
const
{
return
index_
;
}
auto
propagate
(
)
const
{
return
mozilla
:
:
Err
(
error_
)
;
}
}
;
template
<
typename
CharT
>
class
StringReader
final
{
mozilla
:
:
Span
<
const
CharT
>
string_
;
size_t
index_
=
0
;
public
:
explicit
StringReader
(
mozilla
:
:
Span
<
const
CharT
>
string
)
:
string_
(
string
)
{
}
mozilla
:
:
Span
<
const
CharT
>
string
(
)
const
{
return
string_
;
}
mozilla
:
:
Span
<
const
CharT
>
substring
(
const
StringName
&
name
)
const
{
MOZ_ASSERT
(
name
.
present
(
)
)
;
return
string_
.
Subspan
(
name
.
start
name
.
length
)
;
}
size_t
index
(
)
const
{
return
index_
;
}
size_t
length
(
)
const
{
return
string_
.
size
(
)
;
}
bool
atEnd
(
)
const
{
return
index
(
)
=
=
length
(
)
;
}
void
reset
(
size_t
index
=
0
)
{
MOZ_ASSERT
(
index
<
=
length
(
)
)
;
index_
=
index
;
}
bool
hasMore
(
size_t
amount
)
const
{
return
index
(
)
+
amount
<
=
length
(
)
;
}
void
advance
(
size_t
amount
)
{
MOZ_ASSERT
(
hasMore
(
amount
)
)
;
index_
+
=
amount
;
}
CharT
current
(
)
const
{
return
string
(
)
[
index
(
)
]
;
}
CharT
next
(
)
const
{
return
string
(
)
[
index
(
)
+
1
]
;
}
CharT
at
(
size_t
index
)
const
{
return
string
(
)
[
index
]
;
}
}
;
template
<
typename
CharT
>
class
TemporalParser
final
{
StringReader
<
CharT
>
reader_
;
mozilla
:
:
Maybe
<
double
>
digits
(
JSContext
*
cx
)
;
mozilla
:
:
Maybe
<
int32_t
>
digits
(
size_t
length
)
{
MOZ_ASSERT
(
length
>
0
"
can
'
t
read
zero
digits
"
)
;
MOZ_ASSERT
(
length
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
digits10
"
can
'
t
read
more
than
digits10
digits
without
overflow
"
)
;
if
(
!
reader_
.
hasMore
(
length
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int32_t
num
=
0
;
size_t
index
=
reader_
.
index
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
auto
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiDigit
(
ch
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
num
=
num
*
10
+
AsciiDigitToNumber
(
ch
)
;
}
reader_
.
advance
(
length
)
;
return
mozilla
:
:
Some
(
num
)
;
}
mozilla
:
:
Maybe
<
int32_t
>
fraction
(
)
{
if
(
!
reader_
.
hasMore
(
2
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
if
(
!
hasDecimalSeparator
(
)
|
|
!
mozilla
:
:
IsAsciiDigit
(
reader_
.
next
(
)
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ALWAYS_TRUE
(
decimalSeparator
(
)
)
;
constexpr
size_t
maxFractions
=
9
;
int32_t
num
=
0
;
size_t
index
=
reader_
.
index
(
)
;
size_t
i
=
0
;
for
(
;
i
<
std
:
:
min
(
reader_
.
length
(
)
-
index
maxFractions
)
;
i
+
+
)
{
CharT
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiDigit
(
ch
)
)
{
break
;
}
num
=
num
*
10
+
AsciiDigitToNumber
(
ch
)
;
}
reader_
.
advance
(
i
)
;
for
(
;
i
<
maxFractions
;
i
+
+
)
{
num
*
=
10
;
}
return
mozilla
:
:
Some
(
num
)
;
}
bool
hasCharacter
(
CharT
ch
)
const
{
return
reader_
.
hasMore
(
1
)
&
&
reader_
.
current
(
)
=
=
ch
;
}
bool
character
(
CharT
ch
)
{
if
(
!
hasCharacter
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
template
<
size_t
N
>
bool
string
(
const
char
(
&
str
)
[
N
]
)
{
static_assert
(
N
>
2
"
use
character
(
)
for
one
element
strings
"
)
;
if
(
!
reader_
.
hasMore
(
N
-
1
)
)
{
return
false
;
}
size_t
index
=
reader_
.
index
(
)
;
for
(
size_t
i
=
0
;
i
<
N
-
1
;
i
+
+
)
{
if
(
reader_
.
at
(
index
+
i
)
!
=
str
[
i
]
)
{
return
false
;
}
}
reader_
.
advance
(
N
-
1
)
;
return
true
;
}
bool
hasTwoAsciiAlpha
(
)
{
if
(
!
reader_
.
hasMore
(
2
)
)
{
return
false
;
}
size_t
index
=
reader_
.
index
(
)
;
return
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
)
)
&
&
mozilla
:
:
IsAsciiAlpha
(
reader_
.
at
(
index
+
1
)
)
;
}
bool
hasOneOf
(
std
:
:
initializer_list
<
char
>
chars
)
const
{
if
(
!
reader_
.
hasMore
(
1
)
)
{
return
false
;
}
auto
ch
=
reader_
.
current
(
)
;
return
std
:
:
find
(
chars
.
begin
(
)
chars
.
end
(
)
ch
)
!
=
chars
.
end
(
)
;
}
bool
oneOf
(
std
:
:
initializer_list
<
char
>
chars
)
{
if
(
!
hasOneOf
(
chars
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
template
<
typename
Predicate
>
bool
matches
(
Predicate
&
&
predicate
)
{
if
(
!
reader_
.
hasMore
(
1
)
)
{
return
false
;
}
CharT
ch
=
reader_
.
current
(
)
;
if
(
!
predicate
(
ch
)
)
{
return
false
;
}
reader_
.
advance
(
1
)
;
return
true
;
}
bool
hasSign
(
)
const
{
return
hasOneOf
(
{
'
+
'
'
-
'
}
)
;
}
int32_t
sign
(
)
{
MOZ_ASSERT
(
hasSign
(
)
)
;
int32_t
plus
=
hasCharacter
(
'
+
'
)
;
reader_
.
advance
(
1
)
;
return
plus
?
1
:
-
1
;
}
bool
dateSeparator
(
)
{
return
character
(
'
-
'
)
;
}
bool
hasTimeSeparator
(
)
const
{
return
hasCharacter
(
'
:
'
)
;
}
bool
timeSeparator
(
)
{
return
character
(
'
:
'
)
;
}
bool
hasDecimalSeparator
(
)
const
{
return
hasOneOf
(
{
'
.
'
'
'
}
)
;
}
bool
decimalSeparator
(
)
{
return
oneOf
(
{
'
.
'
'
'
}
)
;
}
bool
daysDesignator
(
)
{
return
oneOf
(
{
'
D
'
'
d
'
}
)
;
}
bool
hoursDesignator
(
)
{
return
oneOf
(
{
'
H
'
'
h
'
}
)
;
}
bool
minutesDesignator
(
)
{
return
oneOf
(
{
'
M
'
'
m
'
}
)
;
}
bool
monthsDesignator
(
)
{
return
oneOf
(
{
'
M
'
'
m
'
}
)
;
}
bool
durationDesignator
(
)
{
return
oneOf
(
{
'
P
'
'
p
'
}
)
;
}
bool
secondsDesignator
(
)
{
return
oneOf
(
{
'
S
'
'
s
'
}
)
;
}
bool
dateTimeSeparator
(
)
{
return
oneOf
(
{
'
'
'
T
'
'
t
'
}
)
;
}
bool
hasTimeDesignator
(
)
const
{
return
hasOneOf
(
{
'
T
'
'
t
'
}
)
;
}
bool
timeDesignator
(
)
{
return
oneOf
(
{
'
T
'
'
t
'
}
)
;
}
bool
weeksDesignator
(
)
{
return
oneOf
(
{
'
W
'
'
w
'
}
)
;
}
bool
yearsDesignator
(
)
{
return
oneOf
(
{
'
Y
'
'
y
'
}
)
;
}
bool
utcDesignator
(
)
{
return
oneOf
(
{
'
Z
'
'
z
'
}
)
;
}
bool
tzLeadingChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiAlpha
(
ch
)
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
tzChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiAlphanumeric
(
ch
)
|
|
ch
=
=
'
.
'
|
|
ch
=
=
'
_
'
|
|
ch
=
=
'
-
'
|
|
ch
=
=
'
+
'
;
}
)
;
}
bool
annotationCriticalFlag
(
)
{
return
character
(
'
!
'
)
;
}
bool
aKeyLeadingChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
ch
)
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
aKeyChar
(
)
{
return
matches
(
[
]
(
auto
ch
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
ch
)
|
|
mozilla
:
:
IsAsciiDigit
(
ch
)
|
|
ch
=
=
'
-
'
|
|
ch
=
=
'
_
'
;
}
)
;
}
bool
annotationValueComponent
(
)
{
size_t
index
=
reader_
.
index
(
)
;
size_t
i
=
0
;
for
(
;
index
+
i
<
reader_
.
length
(
)
;
i
+
+
)
{
auto
ch
=
reader_
.
at
(
index
+
i
)
;
if
(
!
mozilla
:
:
IsAsciiAlphanumeric
(
ch
)
)
{
break
;
}
}
if
(
i
=
=
0
)
{
return
false
;
}
reader_
.
advance
(
i
)
;
return
true
;
}
template
<
typename
T
>
static
constexpr
bool
inBounds
(
const
T
&
x
const
T
&
min
const
T
&
max
)
{
return
min
<
=
x
&
&
x
<
=
max
;
}
static
auto
err
(
JSErrNum
error
)
{
return
mozilla
:
:
Err
(
ParserError
{
error
}
)
;
}
mozilla
:
:
Result
<
int32_t
ParserError
>
dateYear
(
)
;
mozilla
:
:
Result
<
int32_t
ParserError
>
dateMonth
(
)
;
mozilla
:
:
Result
<
int32_t
ParserError
>
dateDay
(
)
;
mozilla
:
:
Result
<
int32_t
ParserError
>
hour
(
)
;
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
minute
(
bool
required
)
;
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
second
(
bool
required
)
;
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
timeSecond
(
bool
required
)
;
mozilla
:
:
Result
<
ISODate
ParserError
>
date
(
)
;
mozilla
:
:
Result
<
Time
ParserError
>
time
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
dateTime
(
bool
allowZ
)
;
mozilla
:
:
Result
<
ISODate
ParserError
>
dateSpecYearMonth
(
)
;
mozilla
:
:
Result
<
ISODate
ParserError
>
dateSpecMonthDay
(
)
;
bool
hasAnnotationStart
(
)
const
{
return
hasCharacter
(
'
[
'
)
;
}
bool
hasTimeZoneAnnotationStart
(
)
const
{
if
(
!
hasCharacter
(
'
[
'
)
)
{
return
false
;
}
for
(
size_t
i
=
reader_
.
index
(
)
+
1
;
i
<
reader_
.
length
(
)
;
i
+
+
)
{
CharT
ch
=
reader_
.
at
(
i
)
;
if
(
ch
=
=
'
=
'
)
{
return
false
;
}
if
(
ch
=
=
'
]
'
)
{
break
;
}
}
return
true
;
}
bool
hasDateTimeUTCOffsetStart
(
)
{
return
hasOneOf
(
{
'
Z
'
'
z
'
'
+
'
'
-
'
}
)
;
}
mozilla
:
:
Result
<
TimeZoneString
ParserError
>
dateTimeUTCOffset
(
bool
allowZ
)
;
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
utcOffsetSubMinutePrecision
(
)
;
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
timeZoneUTCOffsetName
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
timeZoneIdentifier
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
timeZoneAnnotation
(
)
;
mozilla
:
:
Result
<
TimeZoneName
ParserError
>
timeZoneIANAName
(
)
;
mozilla
:
:
Result
<
AnnotationKey
ParserError
>
annotationKey
(
)
;
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
annotationValue
(
)
;
mozilla
:
:
Result
<
Annotation
ParserError
>
annotation
(
)
;
mozilla
:
:
Result
<
CalendarName
ParserError
>
annotations
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedTime
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedDateTime
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedDateTimeTimeRequired
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedYearMonth
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
annotatedMonthDay
(
)
;
mozilla
:
:
Result
<
double
ParserError
>
durationDigits
(
JSContext
*
cx
)
;
template
<
typename
T
>
mozilla
:
:
Result
<
T
ParserError
>
parse
(
mozilla
:
:
Result
<
T
ParserError
>
&
&
result
)
const
;
template
<
typename
T
>
mozilla
:
:
Result
<
T
ParserError
>
complete
(
const
T
&
value
)
const
;
mozilla
:
:
Result
<
mozilla
:
:
Ok
ParserError
>
nonempty
(
)
const
;
public
:
explicit
TemporalParser
(
mozilla
:
:
Span
<
const
CharT
>
str
)
:
reader_
(
str
)
{
}
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalInstantString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalTimeZoneString
(
)
;
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
parseTimeZoneIdentifier
(
)
;
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
parseDateTimeUTCOffset
(
)
;
mozilla
:
:
Result
<
TemporalDurationString
ParserError
>
parseTemporalDurationString
(
JSContext
*
cx
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalCalendarString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalTimeString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalMonthDayString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalYearMonthString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalDateTimeString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalZonedDateTimeString
(
)
;
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
parseTemporalRelativeToString
(
)
;
}
;
template
<
typename
CharT
>
template
<
typename
T
>
mozilla
:
:
Result
<
T
ParserError
>
TemporalParser
<
CharT
>
:
:
parse
(
mozilla
:
:
Result
<
T
ParserError
>
&
&
result
)
const
{
if
(
result
.
isOk
(
)
&
&
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_UNEXPECTED_CHARACTERS_AT_END
)
;
}
return
std
:
:
move
(
result
)
;
}
template
<
typename
CharT
>
template
<
typename
T
>
mozilla
:
:
Result
<
T
ParserError
>
TemporalParser
<
CharT
>
:
:
complete
(
const
T
&
result
)
const
{
if
(
!
reader_
.
atEnd
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_UNEXPECTED_CHARACTERS_AT_END
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
mozilla
:
:
Ok
ParserError
>
TemporalParser
<
CharT
>
:
:
nonempty
(
)
const
{
if
(
reader_
.
length
(
)
=
=
0
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_EMPTY_STRING
)
;
}
return
mozilla
:
:
Ok
{
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
int32_t
ParserError
>
TemporalParser
<
CharT
>
:
:
dateYear
(
)
{
if
(
auto
year
=
digits
(
4
)
)
{
return
year
.
value
(
)
;
}
if
(
hasSign
(
)
)
{
int32_t
yearSign
=
sign
(
)
;
if
(
auto
year
=
digits
(
6
)
)
{
int32_t
result
=
yearSign
*
year
.
value
(
)
;
if
(
yearSign
<
0
&
&
result
=
=
0
)
{
return
err
(
JSMSG_TEMPORAL_PARSER_NEGATIVE_ZERO_YEAR
)
;
}
return
result
;
}
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_EXTENDED_YEAR
)
;
}
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_YEAR
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
int32_t
ParserError
>
TemporalParser
<
CharT
>
:
:
dateMonth
(
)
{
if
(
auto
month
=
digits
(
2
)
)
{
int32_t
result
=
month
.
value
(
)
;
if
(
!
inBounds
(
result
1
12
)
)
{
return
err
(
JSMSG_TEMPORAL_PARSER_INVALID_MONTH
)
;
}
return
result
;
}
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_MONTH
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
int32_t
ParserError
>
TemporalParser
<
CharT
>
:
:
dateDay
(
)
{
if
(
auto
day
=
digits
(
2
)
)
{
int32_t
result
=
day
.
value
(
)
;
if
(
!
inBounds
(
result
1
31
)
)
{
return
err
(
JSMSG_TEMPORAL_PARSER_INVALID_DAY
)
;
}
return
result
;
}
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_DAY
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
int32_t
ParserError
>
TemporalParser
<
CharT
>
:
:
hour
(
)
{
if
(
auto
hour
=
digits
(
2
)
)
{
int32_t
result
=
hour
.
value
(
)
;
if
(
!
inBounds
(
result
0
23
)
)
{
return
err
(
JSMSG_TEMPORAL_PARSER_INVALID_HOUR
)
;
}
return
result
;
}
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_HOUR
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
TemporalParser
<
CharT
>
:
:
minute
(
bool
required
)
{
if
(
auto
minute
=
digits
(
2
)
)
{
if
(
!
inBounds
(
minute
.
value
(
)
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_MINUTE
)
;
}
return
minute
;
}
if
(
!
required
)
{
return
mozilla
:
:
Maybe
<
int32_t
>
{
mozilla
:
:
Nothing
{
}
}
;
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_MINUTE
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
TemporalParser
<
CharT
>
:
:
second
(
bool
required
)
{
if
(
auto
minute
=
digits
(
2
)
)
{
if
(
!
inBounds
(
minute
.
value
(
)
0
59
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_SECOND
)
;
}
return
minute
;
}
if
(
!
required
)
{
return
mozilla
:
:
Maybe
<
int32_t
>
{
mozilla
:
:
Nothing
{
}
}
;
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_SECOND
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
mozilla
:
:
Maybe
<
int32_t
>
ParserError
>
TemporalParser
<
CharT
>
:
:
timeSecond
(
bool
required
)
{
if
(
auto
minute
=
digits
(
2
)
)
{
if
(
!
inBounds
(
minute
.
value
(
)
0
60
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_LEAPSECOND
)
;
}
return
minute
;
}
if
(
!
required
)
{
return
mozilla
:
:
Maybe
<
int32_t
>
{
mozilla
:
:
Nothing
{
}
}
;
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_SECOND
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ISODate
ParserError
>
TemporalParser
<
CharT
>
:
:
date
(
)
{
ISODate
result
{
}
;
result
.
year
=
MOZ_TRY
(
dateYear
(
)
)
;
bool
hasMonthSeparator
=
dateSeparator
(
)
;
result
.
month
=
MOZ_TRY
(
dateMonth
(
)
)
;
bool
hasDaySeparator
=
dateSeparator
(
)
;
if
(
hasMonthSeparator
!
=
hasDaySeparator
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INCONSISTENT_DATE_SEPARATOR
)
;
}
result
.
day
=
MOZ_TRY
(
dateDay
(
)
)
;
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
Time
ParserError
>
TemporalParser
<
CharT
>
:
:
time
(
)
{
Time
result
{
}
;
result
.
hour
=
MOZ_TRY
(
hour
(
)
)
;
bool
hasMinuteSeparator
=
timeSeparator
(
)
;
mozilla
:
:
Maybe
<
int32_t
>
minutes
=
MOZ_TRY
(
minute
(
hasMinuteSeparator
)
)
;
if
(
minutes
)
{
result
.
minute
=
minutes
.
value
(
)
;
bool
hasSecondSeparator
=
timeSeparator
(
)
;
mozilla
:
:
Maybe
<
int32_t
>
seconds
=
MOZ_TRY
(
timeSecond
(
hasSecondSeparator
)
)
;
if
(
seconds
)
{
result
.
second
=
seconds
.
value
(
)
;
if
(
hasMinuteSeparator
!
=
hasSecondSeparator
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INCONSISTENT_TIME_SEPARATOR
)
;
}
if
(
auto
f
=
fraction
(
)
)
{
int32_t
fractionalPart
=
f
.
value
(
)
;
result
.
millisecond
=
fractionalPart
/
1
'
000
'
000
;
result
.
microsecond
=
(
fractionalPart
%
1
'
000
'
000
)
/
1
'
000
;
result
.
nanosecond
=
fractionalPart
%
1
'
000
;
}
}
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
dateTime
(
bool
allowZ
)
{
ZonedDateTimeString
result
{
}
;
result
.
date
=
MOZ_TRY
(
date
(
)
)
;
if
(
dateTimeSeparator
(
)
)
{
result
.
time
=
MOZ_TRY
(
time
(
)
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
result
.
timeZone
=
MOZ_TRY
(
dateTimeUTCOffset
(
allowZ
)
)
;
}
}
else
{
result
.
startOfDay
=
true
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneString
ParserError
>
TemporalParser
<
CharT
>
:
:
dateTimeUTCOffset
(
bool
allowZ
)
{
if
(
utcDesignator
(
)
)
{
if
(
!
allowZ
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR
)
;
}
return
TimeZoneString
:
:
UTC
(
)
;
}
if
(
hasSign
(
)
)
{
DateTimeUTCOffset
offset
=
MOZ_TRY
(
utcOffsetSubMinutePrecision
(
)
)
;
return
TimeZoneString
:
:
from
(
offset
)
;
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneUTCOffsetName
(
)
{
TimeZoneUTCOffset
result
{
}
;
if
(
!
hasSign
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN
)
;
}
result
.
sign
=
sign
(
)
;
result
.
hour
=
MOZ_TRY
(
hour
(
)
)
;
bool
hasMinuteSeparator
=
timeSeparator
(
)
;
mozilla
:
:
Maybe
<
int32_t
>
minutes
=
MOZ_TRY
(
minute
(
hasMinuteSeparator
)
)
;
if
(
minutes
)
{
result
.
minute
=
minutes
.
value
(
)
;
if
(
hasTimeSeparator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE
)
;
}
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
utcOffsetSubMinutePrecision
(
)
{
DateTimeUTCOffset
result
{
}
;
if
(
!
hasSign
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN
)
;
}
result
.
sign
=
sign
(
)
;
result
.
hour
=
MOZ_TRY
(
hour
(
)
)
;
bool
hasMinuteSeparator
=
timeSeparator
(
)
;
mozilla
:
:
Maybe
<
int32_t
>
minutes
=
MOZ_TRY
(
minute
(
hasMinuteSeparator
)
)
;
if
(
minutes
)
{
result
.
minute
=
minutes
.
value
(
)
;
bool
hasSecondSeparator
=
timeSeparator
(
)
;
mozilla
:
:
Maybe
<
int32_t
>
seconds
=
MOZ_TRY
(
second
(
hasSecondSeparator
)
)
;
if
(
seconds
)
{
result
.
second
=
seconds
.
value
(
)
;
if
(
hasMinuteSeparator
!
=
hasSecondSeparator
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INCONSISTENT_TIME_SEPARATOR
)
;
}
if
(
auto
fractionalPart
=
fraction
(
)
)
{
result
.
fractionalPart
=
fractionalPart
.
value
(
)
;
}
result
.
subMinutePrecision
=
true
;
}
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneIdentifier
(
)
{
TimeZoneAnnotation
result
{
}
;
if
(
hasSign
(
)
)
{
result
.
offset
=
MOZ_TRY
(
timeZoneUTCOffsetName
(
)
)
;
}
else
{
result
.
name
=
MOZ_TRY
(
timeZoneIANAName
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneAnnotation
(
)
{
if
(
!
character
(
'
[
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_TIMEZONE
)
;
}
annotationCriticalFlag
(
)
;
auto
result
=
timeZoneIdentifier
(
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
if
(
!
character
(
'
]
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_TIMEZONE
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneName
ParserError
>
TemporalParser
<
CharT
>
:
:
timeZoneIANAName
(
)
{
size_t
start
=
reader_
.
index
(
)
;
do
{
if
(
!
tzLeadingChar
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_NAME
)
;
}
while
(
tzChar
(
)
)
{
}
}
while
(
character
(
'
/
'
)
)
;
return
TimeZoneName
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Maybe
<
double
>
TemporalParser
<
CharT
>
:
:
digits
(
JSContext
*
cx
)
{
auto
span
=
reader_
.
string
(
)
.
Subspan
(
reader_
.
index
(
)
)
;
const
CharT
*
endp
=
nullptr
;
double
num
;
MOZ_ALWAYS_TRUE
(
GetPrefixInteger
(
span
.
data
(
)
span
.
data
(
)
+
span
.
size
(
)
10
IntegerSeparatorHandling
:
:
None
&
endp
&
num
)
)
;
size_t
len
=
endp
-
span
.
data
(
)
;
if
(
len
=
=
0
)
{
return
mozilla
:
:
Nothing
(
)
;
}
reader_
.
advance
(
len
)
;
return
mozilla
:
:
Some
(
num
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalInstantString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
ZonedDateTimeString
result
{
}
;
result
.
date
=
MOZ_TRY
(
date
(
)
)
;
if
(
!
dateTimeSeparator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR
)
;
}
result
.
time
=
MOZ_TRY
(
time
(
)
)
;
result
.
timeZone
=
MOZ_TRY
(
dateTimeUTCOffset
(
true
)
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
MOZ_TRY
(
annotations
(
)
)
;
}
return
complete
(
result
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalInstantString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalInstantString
(
)
;
}
static
auto
ParseTemporalInstantString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalInstantString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalInstantString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalInstantString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
ISODateTime
*
result
int64_t
*
offset
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalInstantString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
instant
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
!
ParseISODateTime
(
cx
parsed
result
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
*
offset
=
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
.
offset
;
}
else
{
MOZ_ASSERT
(
parsed
.
timeZone
.
isUTC
(
)
)
;
*
offset
=
0
;
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalTimeZoneString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
if
(
auto
tz
=
parse
(
timeZoneIdentifier
(
)
)
;
tz
.
isOk
(
)
)
{
auto
timeZone
=
tz
.
unwrap
(
)
;
ZonedDateTimeString
result
{
}
;
if
(
timeZone
.
hasOffset
(
)
)
{
result
.
timeZone
=
TimeZoneString
:
:
from
(
timeZone
.
offset
)
;
}
else
{
MOZ_ASSERT
(
timeZone
.
hasName
(
)
)
;
result
.
timeZone
=
TimeZoneString
:
:
from
(
timeZone
.
name
)
;
}
return
result
;
}
LikelyError
likelyError
{
}
;
reader_
.
reset
(
)
;
auto
dateTime
=
parseTemporalDateTimeString
(
)
;
if
(
dateTime
.
isOk
(
)
)
{
return
dateTime
;
}
likelyError
.
update
(
dateTime
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
instant
=
parseTemporalInstantString
(
)
;
if
(
instant
.
isOk
(
)
)
{
return
instant
;
}
likelyError
.
update
(
instant
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
time
=
parseTemporalTimeString
(
)
;
if
(
time
.
isOk
(
)
)
{
return
time
;
}
likelyError
.
update
(
time
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
monthDay
=
parseTemporalMonthDayString
(
)
;
if
(
monthDay
.
isOk
(
)
)
{
return
monthDay
;
}
likelyError
.
update
(
monthDay
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
yearMonth
=
parseTemporalYearMonthString
(
)
;
if
(
yearMonth
.
isOk
(
)
)
{
return
yearMonth
;
}
likelyError
.
update
(
yearMonth
reader_
.
index
(
)
)
;
return
likelyError
.
propagate
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalTimeZoneString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalTimeZoneString
(
)
;
}
static
auto
ParseTemporalTimeZoneString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalTimeZoneString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalTimeZoneString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalTimeZoneString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
MutableHandle
<
ParsedTimeZone
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalTimeZoneString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
time
zone
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
const
auto
&
timeZone
=
parsed
.
timeZone
;
ISODateTime
unused
;
if
(
!
ParseISODateTime
(
cx
parsed
&
unused
)
)
{
return
false
;
}
if
(
timeZone
.
hasAnnotation
(
)
)
{
if
(
!
ParseTimeZoneAnnotation
(
cx
timeZone
.
annotation
linear
result
)
)
{
return
false
;
}
}
else
if
(
timeZone
.
isUTC
(
)
)
{
result
.
set
(
ParsedTimeZone
:
:
fromName
(
cx
-
>
names
(
)
.
UTC
)
)
;
}
else
if
(
timeZone
.
hasOffset
(
)
)
{
if
(
timeZone
.
offset
.
subMinutePrecision
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE
"
time
zone
"
)
;
return
false
;
}
int32_t
offset
=
ParseTimeZoneOffset
(
timeZone
.
offset
.
toTimeZoneUTCOffset
(
)
)
;
result
.
set
(
ParsedTimeZone
:
:
fromOffset
(
offset
)
)
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE
"
time
zone
"
)
;
return
false
;
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TimeZoneAnnotation
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTimeZoneIdentifier
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
return
parse
(
timeZoneIdentifier
(
)
)
;
}
template
<
typename
CharT
>
static
auto
ParseTimeZoneIdentifier
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTimeZoneIdentifier
(
)
;
}
static
auto
ParseTimeZoneIdentifier
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTimeZoneIdentifier
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTimeZoneIdentifier
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTimeZoneIdentifier
(
JSContext
*
cx
Handle
<
JSString
*
>
str
MutableHandle
<
ParsedTimeZone
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTimeZoneIdentifier
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
time
zone
identifier
"
)
;
return
false
;
}
auto
timeZone
=
parseResult
.
unwrap
(
)
;
return
ParseTimeZoneAnnotation
(
cx
timeZone
linear
result
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
DateTimeUTCOffset
ParserError
>
TemporalParser
<
CharT
>
:
:
parseDateTimeUTCOffset
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
return
parse
(
utcOffsetSubMinutePrecision
(
)
)
;
}
template
<
typename
CharT
>
static
auto
ParseDateTimeUTCOffset
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseDateTimeUTCOffset
(
)
;
}
static
auto
ParseDateTimeUTCOffset
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseDateTimeUTCOffset
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseDateTimeUTCOffset
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseDateTimeUTCOffset
(
JSContext
*
cx
Handle
<
JSString
*
>
str
int64_t
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseDateTimeUTCOffset
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
UTC
offset
"
)
;
return
false
;
}
*
result
=
ParseDateTimeUTCOffset
(
parseResult
.
unwrap
(
)
)
.
offset
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
double
ParserError
>
TemporalParser
<
CharT
>
:
:
durationDigits
(
JSContext
*
cx
)
{
auto
d
=
digits
(
cx
)
;
if
(
!
d
)
{
return
err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS
)
;
}
return
*
d
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
TemporalDurationString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalDurationString
(
JSContext
*
cx
)
{
MOZ_TRY
(
nonempty
(
)
)
;
TemporalDurationString
result
{
}
;
if
(
hasSign
(
)
)
{
result
.
sign
=
sign
(
)
;
}
if
(
!
durationDesignator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DESIGNATOR
)
;
}
do
{
if
(
hasTimeDesignator
(
)
)
{
break
;
}
double
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
if
(
yearsDesignator
(
)
)
{
result
.
years
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
}
if
(
monthsDesignator
(
)
)
{
result
.
months
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
}
if
(
weeksDesignator
(
)
)
{
result
.
weeks
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
}
if
(
daysDesignator
(
)
)
{
result
.
days
=
num
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
if
(
hasTimeDesignator
(
)
)
{
break
;
}
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_UNIT_DESIGNATOR
)
;
}
while
(
false
)
;
if
(
!
timeDesignator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_TIME_DESIGNATOR
)
;
}
double
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
auto
frac
=
fraction
(
)
;
bool
hasHoursFraction
=
false
;
if
(
hoursDesignator
(
)
)
{
hasHoursFraction
=
bool
(
frac
)
;
result
.
hours
=
num
;
result
.
hoursFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
frac
=
fraction
(
)
;
}
bool
hasMinutesFraction
=
false
;
if
(
minutesDesignator
(
)
)
{
if
(
hasHoursFraction
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DURATION_MINUTES
)
;
}
hasMinutesFraction
=
bool
(
frac
)
;
result
.
minutes
=
num
;
result
.
minutesFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
num
=
MOZ_TRY
(
durationDigits
(
cx
)
)
;
frac
=
fraction
(
)
;
}
if
(
secondsDesignator
(
)
)
{
if
(
hasHoursFraction
|
|
hasMinutesFraction
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_DURATION_SECONDS
)
;
}
result
.
seconds
=
num
;
result
.
secondsFraction
=
frac
.
valueOr
(
0
)
;
if
(
reader_
.
atEnd
(
)
)
{
return
result
;
}
}
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DURATION_UNIT_DESIGNATOR
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalDurationString
(
JSContext
*
cx
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalDurationString
(
cx
)
;
}
static
auto
ParseTemporalDurationString
(
JSContext
*
cx
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalDurationString
<
Latin1Char
>
(
cx
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalDurationString
<
char16_t
>
(
cx
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalDurationString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
Duration
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalDurationString
(
cx
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
duration
"
)
;
return
false
;
}
TemporalDurationString
parsed
=
parseResult
.
unwrap
(
)
;
double
years
=
parsed
.
years
;
double
months
=
parsed
.
months
;
double
weeks
=
parsed
.
weeks
;
double
days
=
parsed
.
days
;
double
hours
=
parsed
.
hours
;
double
minutes
seconds
milliseconds
microseconds
nanoseconds
;
if
(
parsed
.
hoursFraction
)
{
MOZ_ASSERT
(
parsed
.
hoursFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
hoursFraction
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
parsed
.
minutes
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
minutesFraction
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
seconds
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
=
=
0
)
;
int64_t
h
=
int64_t
(
parsed
.
hoursFraction
)
*
60
;
minutes
=
double
(
h
/
1
'
000
'
000
'
000
)
;
int64_t
min
=
(
h
%
1
'
000
'
000
'
000
)
*
60
;
seconds
=
double
(
min
/
1
'
000
'
000
'
000
)
;
milliseconds
=
double
(
(
min
%
1
'
000
'
000
'
000
)
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
min
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
min
%
1
'
000
)
;
}
else
if
(
parsed
.
minutesFraction
)
{
MOZ_ASSERT
(
parsed
.
minutesFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
minutesFraction
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
parsed
.
seconds
=
=
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
=
=
0
)
;
minutes
=
parsed
.
minutes
;
int64_t
min
=
int64_t
(
parsed
.
minutesFraction
)
*
60
;
seconds
=
double
(
min
/
1
'
000
'
000
'
000
)
;
milliseconds
=
double
(
(
min
%
1
'
000
'
000
'
000
)
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
min
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
min
%
1
'
000
)
;
}
else
if
(
parsed
.
secondsFraction
)
{
MOZ_ASSERT
(
parsed
.
secondsFraction
>
0
)
;
MOZ_ASSERT
(
parsed
.
secondsFraction
<
1
'
000
'
000
'
000
)
;
minutes
=
parsed
.
minutes
;
seconds
=
parsed
.
seconds
;
milliseconds
=
double
(
parsed
.
secondsFraction
/
1
'
000
'
000
)
;
microseconds
=
double
(
(
parsed
.
secondsFraction
%
1
'
000
'
000
)
/
1
'
000
)
;
nanoseconds
=
double
(
parsed
.
secondsFraction
%
1
'
000
)
;
}
else
{
minutes
=
parsed
.
minutes
;
seconds
=
parsed
.
seconds
;
milliseconds
=
0
;
microseconds
=
0
;
nanoseconds
=
0
;
}
int32_t
factor
=
parsed
.
sign
?
parsed
.
sign
:
1
;
MOZ_ASSERT
(
factor
=
=
-
1
|
|
factor
=
=
1
)
;
*
result
=
{
(
years
*
factor
)
+
(
+
0
.
0
)
(
months
*
factor
)
+
(
+
0
.
0
)
(
weeks
*
factor
)
+
(
+
0
.
0
)
(
days
*
factor
)
+
(
+
0
.
0
)
(
hours
*
factor
)
+
(
+
0
.
0
)
(
minutes
*
factor
)
+
(
+
0
.
0
)
(
seconds
*
factor
)
+
(
+
0
.
0
)
(
milliseconds
*
factor
)
+
(
+
0
.
0
)
(
microseconds
*
factor
)
+
(
+
0
.
0
)
(
nanoseconds
*
factor
)
+
(
+
0
.
0
)
}
;
return
ThrowIfInvalidDuration
(
cx
*
result
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
AnnotationKey
ParserError
>
TemporalParser
<
CharT
>
:
:
annotationKey
(
)
{
size_t
start
=
reader_
.
index
(
)
;
if
(
!
aKeyLeadingChar
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_KEY
)
;
}
while
(
aKeyChar
(
)
)
{
}
return
AnnotationKey
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
AnnotationValue
ParserError
>
TemporalParser
<
CharT
>
:
:
annotationValue
(
)
{
size_t
start
=
reader_
.
index
(
)
;
do
{
if
(
!
annotationValueComponent
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_VALUE
)
;
}
}
while
(
character
(
'
-
'
)
)
;
return
AnnotationValue
{
start
reader_
.
index
(
)
-
start
}
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
Annotation
ParserError
>
TemporalParser
<
CharT
>
:
:
annotation
(
)
{
if
(
!
character
(
'
[
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_ANNOTATION
)
;
}
Annotation
result
{
}
;
result
.
critical
=
annotationCriticalFlag
(
)
;
result
.
key
=
MOZ_TRY
(
annotationKey
(
)
)
;
if
(
!
character
(
'
=
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_ASSIGNMENT_IN_ANNOTATION
)
;
}
result
.
value
=
MOZ_TRY
(
annotationValue
(
)
)
;
if
(
!
character
(
'
]
'
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_ANNOTATION
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
CalendarName
ParserError
>
TemporalParser
<
CharT
>
:
:
annotations
(
)
{
MOZ_ASSERT
(
hasAnnotationStart
(
)
)
;
CalendarName
calendar
;
bool
calendarWasCritical
=
false
;
while
(
hasAnnotationStart
(
)
)
{
Annotation
anno
=
MOZ_TRY
(
annotation
(
)
)
;
auto
[
key
value
critical
]
=
anno
;
static
constexpr
std
:
:
string_view
ca
=
"
u
-
ca
"
;
auto
keySpan
=
reader_
.
substring
(
key
)
;
if
(
keySpan
.
size
(
)
=
=
ca
.
length
(
)
&
&
std
:
:
equal
(
ca
.
begin
(
)
ca
.
end
(
)
keySpan
.
data
(
)
)
)
{
if
(
!
calendar
.
present
(
)
)
{
calendar
=
value
;
calendarWasCritical
=
critical
;
}
else
if
(
critical
|
|
calendarWasCritical
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION
)
;
}
}
else
if
(
critical
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION
)
;
}
}
return
calendar
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedTime
(
)
{
ZonedDateTimeString
result
{
}
;
size_t
start
=
reader_
.
index
(
)
;
bool
hasTimeDesignator
=
timeDesignator
(
)
;
result
.
time
=
MOZ_TRY
(
time
(
)
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
result
.
timeZone
=
MOZ_TRY
(
dateTimeUTCOffset
(
false
)
)
;
}
if
(
!
hasTimeDesignator
)
{
size_t
end
=
reader_
.
index
(
)
;
auto
isValidMonthDay
=
[
]
(
const
ISODate
&
date
)
{
MOZ_ASSERT
(
date
.
year
=
=
AbsentYear
)
;
MOZ_ASSERT
(
1
<
=
date
.
month
&
&
date
.
month
<
=
12
)
;
MOZ_ASSERT
(
1
<
=
date
.
day
&
&
date
.
day
<
=
31
)
;
constexpr
int32_t
leapYear
=
0
;
return
date
.
day
<
=
ISODaysInMonth
(
leapYear
date
.
month
)
;
}
;
reader_
.
reset
(
start
)
;
if
(
auto
monthDay
=
dateSpecMonthDay
(
)
;
monthDay
.
isOk
(
)
)
{
if
(
reader_
.
index
(
)
=
=
end
&
&
isValidMonthDay
(
monthDay
.
unwrap
(
)
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_MONTH_DAY
)
;
}
}
reader_
.
reset
(
start
)
;
if
(
dateSpecYearMonth
(
)
.
isOk
(
)
)
{
if
(
reader_
.
index
(
)
=
=
end
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_YEAR_MONTH
)
;
}
}
reader_
.
reset
(
end
)
;
}
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedDateTime
(
)
{
ZonedDateTimeString
result
=
MOZ_TRY
(
dateTime
(
false
)
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedDateTimeTimeRequired
(
)
{
ZonedDateTimeString
result
{
}
;
result
.
date
=
MOZ_TRY
(
date
(
)
)
;
if
(
!
dateTimeSeparator
(
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR
)
;
}
result
.
time
=
MOZ_TRY
(
time
(
)
)
;
if
(
hasDateTimeUTCOffsetStart
(
)
)
{
result
.
timeZone
=
MOZ_TRY
(
dateTimeUTCOffset
(
false
)
)
;
}
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedYearMonth
(
)
{
ZonedDateTimeString
result
{
}
;
result
.
date
=
MOZ_TRY
(
dateSpecYearMonth
(
)
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
annotatedMonthDay
(
)
{
ZonedDateTimeString
result
{
}
;
result
.
date
=
MOZ_TRY
(
dateSpecMonthDay
(
)
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ISODate
ParserError
>
TemporalParser
<
CharT
>
:
:
dateSpecYearMonth
(
)
{
ISODate
result
{
}
;
result
.
year
=
MOZ_TRY
(
dateYear
(
)
)
;
dateSeparator
(
)
;
result
.
month
=
MOZ_TRY
(
dateMonth
(
)
)
;
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ISODate
ParserError
>
TemporalParser
<
CharT
>
:
:
dateSpecMonthDay
(
)
{
ISODate
result
{
}
;
string
(
"
-
-
"
)
;
result
.
year
=
AbsentYear
;
result
.
month
=
MOZ_TRY
(
dateMonth
(
)
)
;
dateSeparator
(
)
;
result
.
day
=
MOZ_TRY
(
dateDay
(
)
)
;
return
result
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalCalendarString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
if
(
hasTwoAsciiAlpha
(
)
)
{
ZonedDateTimeString
result
{
}
;
result
.
calendar
=
MOZ_TRY
(
parse
(
annotationValue
(
)
)
)
;
return
result
;
}
LikelyError
likelyError
{
}
;
auto
dateTime
=
parseTemporalDateTimeString
(
)
;
if
(
dateTime
.
isOk
(
)
)
{
return
dateTime
;
}
likelyError
.
update
(
dateTime
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
instant
=
parseTemporalInstantString
(
)
;
if
(
instant
.
isOk
(
)
)
{
return
instant
;
}
likelyError
.
update
(
instant
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
time
=
parseTemporalTimeString
(
)
;
if
(
time
.
isOk
(
)
)
{
return
time
;
}
likelyError
.
update
(
time
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
monthDay
=
parseTemporalMonthDayString
(
)
;
if
(
monthDay
.
isOk
(
)
)
{
return
monthDay
;
}
likelyError
.
update
(
monthDay
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
yearMonth
=
parseTemporalYearMonthString
(
)
;
if
(
yearMonth
.
isOk
(
)
)
{
return
yearMonth
;
}
likelyError
.
update
(
yearMonth
reader_
.
index
(
)
)
;
return
likelyError
.
propagate
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalCalendarString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalCalendarString
(
)
;
}
static
auto
ParseTemporalCalendarString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalCalendarString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalCalendarString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
JSLinearString
*
js
:
:
temporal
:
:
ParseTemporalCalendarString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
nullptr
;
}
auto
parseResult
=
:
:
ParseTemporalCalendarString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
calendar
"
)
;
return
nullptr
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
ISODateTime
unused
;
if
(
!
ParseISODateTime
(
cx
parsed
&
unused
)
)
{
return
nullptr
;
}
if
(
!
parsed
.
calendar
.
present
(
)
)
{
return
cx
-
>
names
(
)
.
iso8601
;
}
return
ToString
(
cx
linear
parsed
.
calendar
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalTimeString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
LikelyError
likelyError
{
}
;
auto
time
=
parse
(
annotatedTime
(
)
)
;
if
(
time
.
isOk
(
)
)
{
return
time
;
}
likelyError
.
update
(
time
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
dateTime
=
parse
(
annotatedDateTimeTimeRequired
(
)
)
;
if
(
dateTime
.
isOk
(
)
)
{
return
dateTime
;
}
likelyError
.
update
(
time
reader_
.
index
(
)
)
;
reader_
.
reset
(
likelyError
.
index
(
)
)
;
return
likelyError
.
propagate
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalTimeString
(
)
;
}
static
auto
ParseTemporalTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
Time
*
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
time
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
ISODateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
time
;
MOZ_ASSERT
(
!
parsed
.
startOfDay
)
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalMonthDayString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
LikelyError
likelyError
{
}
;
auto
monthDay
=
parse
(
annotatedMonthDay
(
)
)
;
if
(
monthDay
.
isOk
(
)
)
{
auto
result
=
monthDay
.
unwrap
(
)
;
if
(
result
.
calendar
.
present
(
)
&
&
!
IsISO8601Calendar
(
reader_
.
substring
(
result
.
calendar
)
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_MONTH_DAY_CALENDAR_NOT_ISO8601
)
;
}
return
result
;
}
likelyError
.
update
(
monthDay
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
dateTime
=
parse
(
annotatedDateTime
(
)
)
;
if
(
dateTime
.
isOk
(
)
)
{
return
dateTime
;
}
likelyError
.
update
(
dateTime
reader_
.
index
(
)
)
;
reader_
.
reset
(
likelyError
.
index
(
)
)
;
return
likelyError
.
propagate
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalMonthDayString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalMonthDayString
(
)
;
}
static
auto
ParseTemporalMonthDayString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalMonthDayString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalMonthDayString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalMonthDayString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
ISODate
*
result
bool
*
hasYear
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalMonthDayString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
month
-
day
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
ISODateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
date
;
*
hasYear
=
parsed
.
date
.
year
!
=
AbsentYear
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalYearMonthString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
LikelyError
likelyError
{
}
;
auto
yearMonth
=
parse
(
annotatedYearMonth
(
)
)
;
if
(
yearMonth
.
isOk
(
)
)
{
auto
result
=
yearMonth
.
unwrap
(
)
;
if
(
result
.
calendar
.
present
(
)
&
&
!
IsISO8601Calendar
(
reader_
.
substring
(
result
.
calendar
)
)
)
{
return
mozilla
:
:
Err
(
JSMSG_TEMPORAL_PARSER_YEAR_MONTH_CALENDAR_NOT_ISO8601
)
;
}
return
result
;
}
likelyError
.
update
(
yearMonth
reader_
.
index
(
)
)
;
reader_
.
reset
(
)
;
auto
dateTime
=
parse
(
annotatedDateTime
(
)
)
;
if
(
dateTime
.
isOk
(
)
)
{
return
dateTime
;
}
likelyError
.
update
(
dateTime
reader_
.
index
(
)
)
;
reader_
.
reset
(
likelyError
.
index
(
)
)
;
return
likelyError
.
propagate
(
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalYearMonthString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalYearMonthString
(
)
;
}
static
auto
ParseTemporalYearMonthString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalYearMonthString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalYearMonthString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalYearMonthString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
ISODate
*
result
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalYearMonthString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
year
-
month
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
ISODateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
date
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalDateTimeString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
return
parse
(
annotatedDateTime
(
)
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalDateTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalDateTimeString
(
)
;
}
static
auto
ParseTemporalDateTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalDateTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalDateTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalDateTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
ISODateTime
*
result
MutableHandle
<
JSString
*
>
calendar
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalDateTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
date
-
time
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
!
ParseISODateTime
(
cx
parsed
result
)
)
{
return
false
;
}
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
.
set
(
ToString
(
cx
linear
parsed
.
calendar
)
)
;
if
(
!
calendar
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalZonedDateTimeString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
ZonedDateTimeString
result
{
}
;
result
=
MOZ_TRY
(
dateTime
(
true
)
)
;
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
complete
(
result
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalZonedDateTimeString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalZonedDateTimeString
(
)
;
}
static
auto
ParseTemporalZonedDateTimeString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalZonedDateTimeString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalZonedDateTimeString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalZonedDateTimeString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
JS
:
:
MutableHandle
<
ParsedZonedDateTime
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalZonedDateTimeString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
zoned
date
-
time
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
Rooted
<
JSLinearString
*
>
calendar
(
cx
)
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
=
ToString
(
cx
linear
parsed
.
calendar
)
;
if
(
!
calendar
)
{
return
false
;
}
}
ISODateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
bool
isStartOfDay
=
parsed
.
startOfDay
;
Rooted
<
ParsedTimeZone
>
timeZoneAnnotation
(
cx
)
;
mozilla
:
:
MaybeOneOf
<
UTCTimeZone
OffsetTimeZone
>
timeZone
;
{
MOZ_ASSERT
(
parsed
.
timeZone
.
hasAnnotation
(
)
)
;
const
auto
&
annotation
=
parsed
.
timeZone
.
annotation
;
if
(
!
ParseTimeZoneAnnotation
(
cx
annotation
linear
&
timeZoneAnnotation
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
timeZone
.
construct
<
UTCTimeZone
>
(
)
;
}
else
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
timeZone
.
construct
<
OffsetTimeZone
>
(
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
)
;
}
}
result
.
set
(
ParsedZonedDateTime
{
dateTime
calendar
timeZoneAnnotation
.
get
(
)
std
:
:
move
(
timeZone
)
isStartOfDay
}
)
;
return
true
;
}
template
<
typename
CharT
>
mozilla
:
:
Result
<
ZonedDateTimeString
ParserError
>
TemporalParser
<
CharT
>
:
:
parseTemporalRelativeToString
(
)
{
MOZ_TRY
(
nonempty
(
)
)
;
ZonedDateTimeString
result
{
}
;
result
=
MOZ_TRY
(
dateTime
(
true
)
)
;
if
(
hasTimeZoneAnnotationStart
(
)
)
{
result
.
timeZone
.
annotation
=
MOZ_TRY
(
timeZoneAnnotation
(
)
)
;
}
if
(
hasAnnotationStart
(
)
)
{
result
.
calendar
=
MOZ_TRY
(
annotations
(
)
)
;
}
return
complete
(
result
)
;
}
template
<
typename
CharT
>
static
auto
ParseTemporalRelativeToString
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
TemporalParser
<
CharT
>
parser
(
str
)
;
return
parser
.
parseTemporalRelativeToString
(
)
;
}
static
auto
ParseTemporalRelativeToString
(
Handle
<
JSLinearString
*
>
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
ParseTemporalRelativeToString
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
;
}
return
ParseTemporalRelativeToString
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
bool
js
:
:
temporal
:
:
ParseTemporalRelativeToString
(
JSContext
*
cx
Handle
<
JSString
*
>
str
MutableHandle
<
ParsedZonedDateTime
>
result
)
{
Rooted
<
JSLinearString
*
>
linear
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
auto
parseResult
=
:
:
ParseTemporalRelativeToString
(
linear
)
;
if
(
parseResult
.
isErr
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
parseResult
.
unwrapErr
(
)
"
relative
date
-
time
"
)
;
return
false
;
}
ZonedDateTimeString
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
timeZone
.
isUTC
(
)
&
&
!
parsed
.
timeZone
.
hasAnnotation
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR_WITHOUT_NAME
"
relative
date
-
time
"
)
;
return
false
;
}
ISODateTime
dateTime
;
if
(
!
ParseISODateTime
(
cx
parsed
&
dateTime
)
)
{
return
false
;
}
bool
isStartOfDay
=
parsed
.
startOfDay
;
Rooted
<
ParsedTimeZone
>
timeZoneAnnotation
(
cx
)
;
mozilla
:
:
MaybeOneOf
<
UTCTimeZone
OffsetTimeZone
>
timeZone
;
if
(
parsed
.
timeZone
.
hasAnnotation
(
)
)
{
const
auto
&
annotation
=
parsed
.
timeZone
.
annotation
;
if
(
!
ParseTimeZoneAnnotation
(
cx
annotation
linear
&
timeZoneAnnotation
)
)
{
return
false
;
}
if
(
parsed
.
timeZone
.
isUTC
(
)
)
{
timeZone
.
construct
<
UTCTimeZone
>
(
)
;
}
else
if
(
parsed
.
timeZone
.
hasOffset
(
)
)
{
timeZone
.
construct
<
OffsetTimeZone
>
(
ParseDateTimeUTCOffset
(
parsed
.
timeZone
.
offset
)
)
;
}
}
else
{
timeZoneAnnotation
.
set
(
ParsedTimeZone
{
}
)
;
}
JSLinearString
*
calendar
=
nullptr
;
if
(
parsed
.
calendar
.
present
(
)
)
{
calendar
=
ToString
(
cx
linear
parsed
.
calendar
)
;
if
(
!
calendar
)
{
return
false
;
}
}
result
.
set
(
ParsedZonedDateTime
{
dateTime
calendar
timeZoneAnnotation
.
get
(
)
std
:
:
move
(
timeZone
)
isStartOfDay
}
)
;
return
true
;
}
void
js
:
:
temporal
:
:
ParsedTimeZone
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
name
"
ParsedTimeZone
:
:
name
"
)
;
}
void
js
:
:
temporal
:
:
ParsedZonedDateTime
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
calendar
"
ParsedZonedDateTime
:
:
calendar
"
)
;
timeZoneAnnotation
.
trace
(
trc
)
;
}
