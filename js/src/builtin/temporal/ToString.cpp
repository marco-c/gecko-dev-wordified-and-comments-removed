#
include
"
builtin
/
temporal
/
ToString
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
cstdlib
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainMonthDay
.
h
"
#
include
"
builtin
/
temporal
/
PlainYearMonth
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
enum
class
TemporalStringFormat
{
None
Date
Time
DateTime
YearMonth
MonthDay
ZonedDateTime
Instant
}
;
class
TemporalStringBuilder
{
JSStringBuilder
sb_
;
TemporalStringFormat
kind_
=
TemporalStringFormat
:
:
None
;
#
ifdef
DEBUG
bool
reserved_
=
false
;
#
endif
static
constexpr
size_t
reserveAmount
(
TemporalStringFormat
format
)
{
constexpr
size_t
datePart
=
1
+
6
+
1
+
2
+
1
+
2
;
constexpr
size_t
timePart
=
2
+
1
+
2
+
1
+
2
+
1
+
9
;
constexpr
size_t
dateTimePart
=
datePart
+
1
+
timePart
;
constexpr
size_t
timeZoneOffsetPart
=
1
+
2
+
1
+
2
;
switch
(
format
)
{
case
TemporalStringFormat
:
:
Date
:
case
TemporalStringFormat
:
:
YearMonth
:
case
TemporalStringFormat
:
:
MonthDay
:
return
datePart
;
case
TemporalStringFormat
:
:
Time
:
return
timePart
;
case
TemporalStringFormat
:
:
DateTime
:
return
dateTimePart
;
case
TemporalStringFormat
:
:
ZonedDateTime
:
return
dateTimePart
+
timeZoneOffsetPart
;
case
TemporalStringFormat
:
:
Instant
:
return
dateTimePart
+
timeZoneOffsetPart
;
case
TemporalStringFormat
:
:
None
:
break
;
}
MOZ_CRASH
(
"
invalid
reserve
amount
"
)
;
}
public
:
TemporalStringBuilder
(
JSContext
*
cx
TemporalStringFormat
kind
)
:
sb_
(
cx
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
!
=
TemporalStringFormat
:
:
None
)
;
}
bool
reserve
(
)
{
MOZ_ASSERT
(
!
reserved_
)
;
if
(
!
sb_
.
reserve
(
reserveAmount
(
kind_
)
)
)
{
return
false
;
}
#
ifdef
DEBUG
reserved_
=
true
;
#
endif
return
true
;
}
void
append
(
char
value
)
{
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
value
)
;
}
void
appendTwoDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
99
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
10
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendFourDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
9999
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
1000
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
1000
)
/
100
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100
)
/
10
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendSixDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
999999
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
100000
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100000
)
/
10000
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10000
)
/
1000
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
1000
)
/
100
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100
)
/
10
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendYear
(
int32_t
year
)
{
if
(
0
<
=
year
&
&
year
<
=
9999
)
{
appendFourDigit
(
year
)
;
}
else
{
append
(
year
<
0
?
'
-
'
:
'
+
'
)
;
appendSixDigit
(
std
:
:
abs
(
year
)
)
;
}
}
auto
*
finishString
(
)
{
return
sb_
.
finishString
(
)
;
}
auto
&
builder
(
)
{
return
sb_
;
}
}
;
static
void
FormatFractionalSeconds
(
TemporalStringBuilder
&
result
int32_t
subSecondNanoseconds
Precision
precision
)
{
MOZ_ASSERT
(
0
<
=
subSecondNanoseconds
&
&
subSecondNanoseconds
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
precision
!
=
Precision
:
:
Minute
(
)
)
;
if
(
precision
=
=
Precision
:
:
Auto
(
)
)
{
if
(
subSecondNanoseconds
=
=
0
)
{
return
;
}
result
.
append
(
'
.
'
)
;
uint32_t
k
=
100
'
000
'
000
;
do
{
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
;
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
while
(
subSecondNanoseconds
)
;
}
else
{
uint8_t
p
=
precision
.
value
(
)
;
if
(
p
=
=
0
)
{
return
;
}
result
.
append
(
'
.
'
)
;
uint32_t
k
=
100
'
000
'
000
;
for
(
uint8_t
i
=
0
;
i
<
p
;
i
+
+
)
{
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
;
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
}
}
static
void
FormatTimeString
(
TemporalStringBuilder
&
result
const
PlainTime
&
time
Precision
precision
)
{
result
.
appendTwoDigit
(
time
.
hour
)
;
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
time
.
minute
)
;
if
(
precision
!
=
Precision
:
:
Minute
(
)
)
{
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
time
.
second
)
;
int32_t
subSecondNanoseconds
=
time
.
millisecond
*
1
'
000
'
000
+
time
.
microsecond
*
1
'
000
+
time
.
nanosecond
;
FormatFractionalSeconds
(
result
subSecondNanoseconds
precision
)
;
}
}
static
void
FormatDateString
(
TemporalStringBuilder
&
result
const
PlainDate
&
date
)
{
result
.
appendYear
(
date
.
year
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
month
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
day
)
;
}
static
void
FormatDateTimeString
(
TemporalStringBuilder
&
result
const
PlainDateTime
&
dateTime
Precision
precision
)
{
FormatDateString
(
result
dateTime
.
date
)
;
result
.
append
(
'
T
'
)
;
FormatTimeString
(
result
dateTime
.
time
precision
)
;
}
static
void
FormatOffsetTimeZoneIdentifier
(
TemporalStringBuilder
&
result
int32_t
offsetMinutes
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetMinutes
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
"
time
zone
offset
mustn
'
t
exceed
24
-
hours
"
)
;
char
sign
=
offsetMinutes
>
=
0
?
'
+
'
:
'
-
'
;
int32_t
absoluteMinutes
=
std
:
:
abs
(
offsetMinutes
)
;
int32_t
hours
=
absoluteMinutes
/
60
;
int32_t
minutes
=
absoluteMinutes
%
60
;
result
.
append
(
sign
)
;
result
.
appendTwoDigit
(
hours
)
;
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
minutes
)
;
}
static
int32_t
RoundNanosecondsToMinutes
(
int64_t
offsetNanoseconds
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
constexpr
int64_t
increment
=
ToNanoseconds
(
TemporalUnit
:
:
Minute
)
;
int64_t
quotient
=
offsetNanoseconds
/
increment
;
int64_t
remainder
=
offsetNanoseconds
%
increment
;
if
(
std
:
:
abs
(
remainder
*
2
)
>
=
increment
)
{
quotient
+
=
(
offsetNanoseconds
>
0
?
1
:
-
1
)
;
}
return
quotient
;
}
static
void
FormatDateTimeUTCOffsetRounded
(
TemporalStringBuilder
&
result
int64_t
offsetNanoseconds
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
int32_t
offsetMinutes
=
RoundNanosecondsToMinutes
(
offsetNanoseconds
)
;
FormatOffsetTimeZoneIdentifier
(
result
offsetMinutes
)
;
}
static
bool
FormatCalendarAnnotation
(
TemporalStringBuilder
&
result
JSLinearString
*
id
CalendarOption
showCalendar
)
{
switch
(
showCalendar
)
{
case
CalendarOption
:
:
Never
:
return
true
;
case
CalendarOption
:
:
Auto
:
{
if
(
StringEqualsLiteral
(
id
"
iso8601
"
)
)
{
return
true
;
}
[
[
fallthrough
]
]
;
}
case
CalendarOption
:
:
Always
:
{
auto
&
sb
=
result
.
builder
(
)
;
return
sb
.
append
(
"
[
u
-
ca
=
"
)
&
&
sb
.
append
(
id
)
&
&
sb
.
append
(
'
]
'
)
;
}
case
CalendarOption
:
:
Critical
:
{
auto
&
sb
=
result
.
builder
(
)
;
return
sb
.
append
(
"
[
!
u
-
ca
=
"
)
&
&
sb
.
append
(
id
)
&
&
sb
.
append
(
'
]
'
)
;
}
}
MOZ_CRASH
(
"
bad
calendar
option
"
)
;
}
static
bool
MaybeFormatCalendarAnnotation
(
JSContext
*
cx
TemporalStringBuilder
&
result
Handle
<
CalendarValue
>
calendar
CalendarOption
showCalendar
)
{
if
(
showCalendar
=
=
CalendarOption
:
:
Never
)
{
return
true
;
}
JSString
*
calendarIdentifier
=
ToTemporalCalendarIdentifier
(
cx
calendar
)
;
if
(
!
calendarIdentifier
)
{
return
false
;
}
JSLinearString
*
linearCalendarId
=
calendarIdentifier
-
>
ensureLinear
(
cx
)
;
if
(
!
linearCalendarId
)
{
return
false
;
}
return
FormatCalendarAnnotation
(
result
linearCalendarId
showCalendar
)
;
}
static
bool
FormatTimeZoneAnnotation
(
TemporalStringBuilder
&
result
JSLinearString
*
id
TimeZoneNameOption
showTimeZone
)
{
switch
(
showTimeZone
)
{
case
TimeZoneNameOption
:
:
Never
:
return
true
;
case
TimeZoneNameOption
:
:
Auto
:
{
auto
&
sb
=
result
.
builder
(
)
;
return
sb
.
append
(
"
[
"
)
&
&
sb
.
append
(
id
)
&
&
sb
.
append
(
'
]
'
)
;
}
case
TimeZoneNameOption
:
:
Critical
:
{
auto
&
sb
=
result
.
builder
(
)
;
return
sb
.
append
(
"
[
!
"
)
&
&
sb
.
append
(
id
)
&
&
sb
.
append
(
'
]
'
)
;
}
}
MOZ_CRASH
(
"
bad
time
zone
option
"
)
;
}
static
bool
MaybeFormatTimeZoneAnnotation
(
JSContext
*
cx
TemporalStringBuilder
&
result
Handle
<
TimeZoneValue
>
timeZone
TimeZoneNameOption
showTimeZone
)
{
if
(
showTimeZone
=
=
TimeZoneNameOption
:
:
Never
)
{
return
true
;
}
JSString
*
timeZoneIdentifier
=
ToTemporalTimeZoneIdentifier
(
cx
timeZone
)
;
if
(
!
timeZoneIdentifier
)
{
return
false
;
}
JSLinearString
*
linearTimeZoneId
=
timeZoneIdentifier
-
>
ensureLinear
(
cx
)
;
if
(
!
linearTimeZoneId
)
{
return
false
;
}
return
FormatTimeZoneAnnotation
(
result
linearTimeZoneId
showTimeZone
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalInstantToString
(
JSContext
*
cx
Handle
<
InstantObject
*
>
instant
Handle
<
TimeZoneValue
>
timeZone
Precision
precision
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Instant
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
Rooted
<
TimeZoneValue
>
outputTimeZone
(
cx
timeZone
)
;
if
(
!
timeZone
)
{
auto
*
utcTimeZone
=
CreateTemporalTimeZoneUTC
(
cx
)
;
if
(
!
utcTimeZone
)
{
return
nullptr
;
}
outputTimeZone
.
set
(
TimeZoneValue
(
utcTimeZone
)
)
;
}
PlainDateTime
dateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
outputTimeZone
instant
&
dateTime
)
)
{
return
nullptr
;
}
FormatDateTimeString
(
result
dateTime
precision
)
;
Rooted
<
JSString
*
>
timeZoneString
(
cx
)
;
if
(
!
timeZone
)
{
result
.
append
(
'
Z
'
)
;
}
else
{
int64_t
offsetNs
;
if
(
!
GetOffsetNanosecondsFor
(
cx
timeZone
instant
&
offsetNs
)
)
{
return
nullptr
;
}
FormatDateTimeUTCOffsetRounded
(
result
offsetNs
)
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalDateToString
(
JSContext
*
cx
Handle
<
PlainDateObject
*
>
temporalDate
CalendarOption
showCalendar
)
{
auto
date
=
ToPlainDate
(
temporalDate
)
;
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Date
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatDateString
(
result
date
)
;
Rooted
<
CalendarValue
>
calendar
(
cx
temporalDate
-
>
calendar
(
)
)
;
if
(
!
MaybeFormatCalendarAnnotation
(
cx
result
calendar
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalDateTimeToString
(
JSContext
*
cx
const
PlainDateTime
&
dateTime
Handle
<
CalendarValue
>
calendar
Precision
precision
CalendarOption
showCalendar
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
DateTime
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatDateTimeString
(
result
dateTime
precision
)
;
if
(
!
MaybeFormatCalendarAnnotation
(
cx
result
calendar
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalTimeToString
(
JSContext
*
cx
const
PlainTime
&
time
Precision
precision
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Time
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatTimeString
(
result
time
precision
)
;
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalMonthDayToString
(
JSContext
*
cx
Handle
<
PlainMonthDayObject
*
>
monthDay
CalendarOption
showCalendar
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
MonthDay
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
monthDay
-
>
calendar
(
)
)
;
JSString
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
)
;
if
(
!
str
)
{
return
nullptr
;
}
Rooted
<
JSLinearString
*
>
calendarIdentifier
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
calendarIdentifier
)
{
return
nullptr
;
}
auto
date
=
ToPlainDate
(
monthDay
)
;
if
(
showCalendar
=
=
CalendarOption
:
:
Always
|
|
showCalendar
=
=
CalendarOption
:
:
Critical
|
|
!
StringEqualsLiteral
(
calendarIdentifier
"
iso8601
"
)
)
{
FormatDateString
(
result
date
)
;
}
else
{
result
.
appendTwoDigit
(
date
.
month
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
day
)
;
}
if
(
!
FormatCalendarAnnotation
(
result
calendarIdentifier
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalYearMonthToString
(
JSContext
*
cx
Handle
<
PlainYearMonthObject
*
>
yearMonth
CalendarOption
showCalendar
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
YearMonth
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
yearMonth
-
>
calendar
(
)
)
;
JSString
*
str
=
ToTemporalCalendarIdentifier
(
cx
calendar
)
;
if
(
!
str
)
{
return
nullptr
;
}
Rooted
<
JSLinearString
*
>
calendarIdentifier
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
calendarIdentifier
)
{
return
nullptr
;
}
auto
date
=
ToPlainDate
(
yearMonth
)
;
if
(
showCalendar
=
=
CalendarOption
:
:
Always
|
|
showCalendar
=
=
CalendarOption
:
:
Critical
|
|
!
StringEqualsLiteral
(
calendarIdentifier
"
iso8601
"
)
)
{
FormatDateString
(
result
date
)
;
}
else
{
result
.
appendYear
(
date
.
year
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
month
)
;
}
if
(
!
FormatCalendarAnnotation
(
result
calendarIdentifier
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalZonedDateTimeToString
(
JSContext
*
cx
Handle
<
ZonedDateTimeObject
*
>
zonedDateTime
Precision
precision
CalendarOption
showCalendar
TimeZoneNameOption
showTimeZone
ShowOffsetOption
showOffset
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
ZonedDateTime
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
Instant
ns
;
if
(
!
RoundTemporalInstant
(
cx
ToInstant
(
zonedDateTime
)
increment
unit
roundingMode
&
ns
)
)
{
return
nullptr
;
}
Rooted
<
TimeZoneValue
>
timeZone
(
cx
zonedDateTime
-
>
timeZone
(
)
)
;
Rooted
<
InstantObject
*
>
instant
(
cx
CreateTemporalInstant
(
cx
ns
)
)
;
if
(
!
instant
)
{
return
nullptr
;
}
PlainDateTime
temporalDateTime
;
if
(
!
js
:
:
temporal
:
:
GetPlainDateTimeFor
(
cx
timeZone
instant
&
temporalDateTime
)
)
{
return
nullptr
;
}
FormatDateTimeString
(
result
temporalDateTime
precision
)
;
if
(
showOffset
!
=
ShowOffsetOption
:
:
Never
)
{
int64_t
offsetNs
;
if
(
!
GetOffsetNanosecondsFor
(
cx
timeZone
instant
&
offsetNs
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
std
:
:
abs
(
offsetNs
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
FormatDateTimeUTCOffsetRounded
(
result
offsetNs
)
;
}
if
(
!
MaybeFormatTimeZoneAnnotation
(
cx
result
timeZone
showTimeZone
)
)
{
return
nullptr
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
zonedDateTime
-
>
calendar
(
)
)
;
if
(
!
MaybeFormatCalendarAnnotation
(
cx
result
calendar
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
