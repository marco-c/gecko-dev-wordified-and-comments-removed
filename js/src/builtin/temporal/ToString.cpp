#
include
"
builtin
/
temporal
/
ToString
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
cstdlib
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
builtin
/
temporal
/
Crash
.
h
"
#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainMonthDay
.
h
"
#
include
"
builtin
/
temporal
/
PlainYearMonth
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
util
/
StringBuilder
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
enum
class
TemporalStringFormat
{
None
Date
Time
DateTime
YearMonth
MonthDay
ZonedDateTime
Instant
}
;
enum
class
Critical
:
bool
{
No
Yes
}
;
class
TemporalStringBuilder
{
JSStringBuilder
sb_
;
TemporalStringFormat
kind_
=
TemporalStringFormat
:
:
None
;
#
ifdef
DEBUG
bool
reserved_
=
false
;
#
endif
static
constexpr
size_t
reserveAmount
(
TemporalStringFormat
format
)
{
constexpr
size_t
datePart
=
1
+
6
+
1
+
2
+
1
+
2
;
constexpr
size_t
timePart
=
2
+
1
+
2
+
1
+
2
+
1
+
9
;
constexpr
size_t
dateTimePart
=
datePart
+
1
+
timePart
;
constexpr
size_t
timeZoneOffsetPart
=
1
+
2
+
1
+
2
;
switch
(
format
)
{
case
TemporalStringFormat
:
:
Date
:
case
TemporalStringFormat
:
:
YearMonth
:
case
TemporalStringFormat
:
:
MonthDay
:
return
datePart
;
case
TemporalStringFormat
:
:
Time
:
return
timePart
;
case
TemporalStringFormat
:
:
DateTime
:
return
dateTimePart
;
case
TemporalStringFormat
:
:
ZonedDateTime
:
return
dateTimePart
+
timeZoneOffsetPart
;
case
TemporalStringFormat
:
:
Instant
:
return
dateTimePart
+
timeZoneOffsetPart
;
case
TemporalStringFormat
:
:
None
:
break
;
}
JS_CONSTEXPR_CRASH
(
"
invalid
reserve
amount
"
)
;
}
public
:
TemporalStringBuilder
(
JSContext
*
cx
TemporalStringFormat
kind
)
:
sb_
(
cx
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
!
=
TemporalStringFormat
:
:
None
)
;
}
bool
reserve
(
)
{
MOZ_ASSERT
(
!
reserved_
)
;
if
(
!
sb_
.
reserve
(
reserveAmount
(
kind_
)
)
)
{
return
false
;
}
#
ifdef
DEBUG
reserved_
=
true
;
#
endif
return
true
;
}
void
append
(
char
value
)
{
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
value
)
;
}
void
appendTwoDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
99
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
10
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendFourDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
9999
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
1000
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
1000
)
/
100
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100
)
/
10
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendSixDigit
(
int32_t
value
)
{
MOZ_ASSERT
(
0
<
=
value
&
&
value
<
=
999999
)
;
MOZ_ASSERT
(
reserved_
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
/
100000
)
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100000
)
/
10000
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10000
)
/
1000
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
1000
)
/
100
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
100
)
/
10
)
)
;
sb_
.
infallibleAppend
(
char
(
'
0
'
+
(
value
%
10
)
)
)
;
}
void
appendYear
(
int32_t
year
)
{
if
(
0
<
=
year
&
&
year
<
=
9999
)
{
appendFourDigit
(
year
)
;
}
else
{
append
(
year
<
0
?
'
-
'
:
'
+
'
)
;
appendSixDigit
(
std
:
:
abs
(
year
)
)
;
}
}
bool
appendCalendarAnnnotation
(
std
:
:
string_view
id
Critical
critical
)
{
std
:
:
string_view
start
=
bool
(
critical
)
?
"
[
!
u
-
ca
=
"
:
"
[
u
-
ca
=
"
;
return
sb_
.
append
(
start
.
data
(
)
start
.
length
(
)
)
&
&
sb_
.
append
(
id
.
data
(
)
id
.
length
(
)
)
&
&
sb_
.
append
(
'
]
'
)
;
}
bool
appendTimeZoneAnnnotation
(
const
JSLinearString
*
id
Critical
critical
)
{
std
:
:
string_view
start
=
bool
(
critical
)
?
"
[
!
"
:
"
[
"
;
return
sb_
.
append
(
start
.
data
(
)
start
.
length
(
)
)
&
&
sb_
.
append
(
id
)
&
&
sb_
.
append
(
'
]
'
)
;
}
auto
*
finishString
(
)
{
return
sb_
.
finishString
(
)
;
}
}
;
static
void
FormatFractionalSeconds
(
TemporalStringBuilder
&
result
int32_t
subSecondNanoseconds
Precision
precision
)
{
MOZ_ASSERT
(
0
<
=
subSecondNanoseconds
&
&
subSecondNanoseconds
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
precision
!
=
Precision
:
:
Minute
(
)
)
;
if
(
precision
=
=
Precision
:
:
Auto
(
)
)
{
if
(
subSecondNanoseconds
=
=
0
)
{
return
;
}
result
.
append
(
'
.
'
)
;
int32_t
k
=
100
'
000
'
000
;
do
{
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
;
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
while
(
subSecondNanoseconds
)
;
}
else
{
uint8_t
p
=
precision
.
value
(
)
;
if
(
p
=
=
0
)
{
return
;
}
result
.
append
(
'
.
'
)
;
int32_t
k
=
100
'
000
'
000
;
for
(
uint8_t
i
=
0
;
i
<
p
;
i
+
+
)
{
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
;
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
}
}
static
void
FormatTimeString
(
TemporalStringBuilder
&
result
const
PlainTime
&
time
Precision
precision
)
{
result
.
appendTwoDigit
(
time
.
hour
)
;
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
time
.
minute
)
;
if
(
precision
!
=
Precision
:
:
Minute
(
)
)
{
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
time
.
second
)
;
int32_t
subSecondNanoseconds
=
time
.
millisecond
*
1
'
000
'
000
+
time
.
microsecond
*
1
'
000
+
time
.
nanosecond
;
FormatFractionalSeconds
(
result
subSecondNanoseconds
precision
)
;
}
}
static
void
FormatDateString
(
TemporalStringBuilder
&
result
const
PlainDate
&
date
)
{
result
.
appendYear
(
date
.
year
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
month
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
day
)
;
}
static
void
FormatDateTimeString
(
TemporalStringBuilder
&
result
const
PlainDateTime
&
dateTime
Precision
precision
)
{
FormatDateString
(
result
dateTime
.
date
)
;
result
.
append
(
'
T
'
)
;
FormatTimeString
(
result
dateTime
.
time
precision
)
;
}
static
void
FormatOffsetTimeZoneIdentifier
(
TemporalStringBuilder
&
result
int32_t
offsetMinutes
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetMinutes
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
"
time
zone
offset
mustn
'
t
exceed
24
-
hours
"
)
;
char
sign
=
offsetMinutes
>
=
0
?
'
+
'
:
'
-
'
;
int32_t
absoluteMinutes
=
std
:
:
abs
(
offsetMinutes
)
;
int32_t
hours
=
absoluteMinutes
/
60
;
int32_t
minutes
=
absoluteMinutes
%
60
;
result
.
append
(
sign
)
;
result
.
appendTwoDigit
(
hours
)
;
result
.
append
(
'
:
'
)
;
result
.
appendTwoDigit
(
minutes
)
;
}
static
int32_t
RoundNanosecondsToMinutes
(
int64_t
offsetNanoseconds
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
constexpr
int64_t
increment
=
ToNanoseconds
(
TemporalUnit
:
:
Minute
)
;
int64_t
quotient
=
offsetNanoseconds
/
increment
;
int64_t
remainder
=
offsetNanoseconds
%
increment
;
if
(
std
:
:
abs
(
remainder
*
2
)
>
=
increment
)
{
quotient
+
=
(
offsetNanoseconds
>
0
?
1
:
-
1
)
;
}
return
int32_t
(
quotient
)
;
}
static
void
FormatDateTimeUTCOffsetRounded
(
TemporalStringBuilder
&
result
int64_t
offsetNanoseconds
)
{
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
int32_t
offsetMinutes
=
RoundNanosecondsToMinutes
(
offsetNanoseconds
)
;
FormatOffsetTimeZoneIdentifier
(
result
offsetMinutes
)
;
}
static
bool
FormatCalendarAnnotation
(
TemporalStringBuilder
&
result
const
CalendarValue
&
calendar
ShowCalendar
showCalendar
)
{
switch
(
showCalendar
)
{
case
ShowCalendar
:
:
Never
:
return
true
;
case
ShowCalendar
:
:
Auto
:
{
if
(
calendar
.
identifier
(
)
=
=
CalendarId
:
:
ISO8601
)
{
return
true
;
}
[
[
fallthrough
]
]
;
}
case
ShowCalendar
:
:
Always
:
{
auto
id
=
ToTemporalCalendarIdentifier
(
calendar
)
;
return
result
.
appendCalendarAnnnotation
(
id
Critical
:
:
No
)
;
}
case
ShowCalendar
:
:
Critical
:
{
auto
id
=
ToTemporalCalendarIdentifier
(
calendar
)
;
return
result
.
appendCalendarAnnnotation
(
id
Critical
:
:
Yes
)
;
}
}
MOZ_CRASH
(
"
bad
calendar
option
"
)
;
}
static
bool
FormatTimeZoneAnnotation
(
TemporalStringBuilder
&
result
const
TimeZoneValue
&
timeZone
ShowTimeZoneName
showTimeZone
)
{
switch
(
showTimeZone
)
{
case
ShowTimeZoneName
:
:
Never
:
return
true
;
case
ShowTimeZoneName
:
:
Auto
:
return
result
.
appendTimeZoneAnnnotation
(
timeZone
.
identifier
(
)
Critical
:
:
No
)
;
case
ShowTimeZoneName
:
:
Critical
:
return
result
.
appendTimeZoneAnnnotation
(
timeZone
.
identifier
(
)
Critical
:
:
Yes
)
;
}
MOZ_CRASH
(
"
bad
time
zone
option
"
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalInstantToString
(
JSContext
*
cx
const
Instant
&
instant
Handle
<
TimeZoneValue
>
timeZone
Precision
precision
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Instant
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
int64_t
offsetNanoseconds
=
0
;
if
(
timeZone
)
{
if
(
!
GetOffsetNanosecondsFor
(
cx
timeZone
instant
&
offsetNanoseconds
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
}
auto
dateTime
=
GetISODateTimeFor
(
instant
offsetNanoseconds
)
;
FormatDateTimeString
(
result
dateTime
precision
)
;
Rooted
<
JSString
*
>
timeZoneString
(
cx
)
;
if
(
!
timeZone
)
{
result
.
append
(
'
Z
'
)
;
}
else
{
FormatDateTimeUTCOffsetRounded
(
result
offsetNanoseconds
)
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalDateToString
(
JSContext
*
cx
Handle
<
PlainDateObject
*
>
temporalDate
ShowCalendar
showCalendar
)
{
auto
date
=
temporalDate
-
>
date
(
)
;
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Date
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatDateString
(
result
date
)
;
if
(
!
FormatCalendarAnnotation
(
result
temporalDate
-
>
calendar
(
)
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalDateTimeToString
(
JSContext
*
cx
const
PlainDateTime
&
dateTime
Handle
<
CalendarValue
>
calendar
Precision
precision
ShowCalendar
showCalendar
)
{
MOZ_ASSERT
(
IsValidISODateTime
(
dateTime
)
)
;
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
DateTime
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatDateTimeString
(
result
dateTime
precision
)
;
if
(
!
FormatCalendarAnnotation
(
result
calendar
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TimeRecordToString
(
JSContext
*
cx
const
PlainTime
&
time
Precision
precision
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
Time
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
FormatTimeString
(
result
time
precision
)
;
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalMonthDayToString
(
JSContext
*
cx
Handle
<
PlainMonthDayObject
*
>
monthDay
ShowCalendar
showCalendar
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
MonthDay
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
auto
date
=
monthDay
-
>
date
(
)
;
if
(
showCalendar
=
=
ShowCalendar
:
:
Always
|
|
showCalendar
=
=
ShowCalendar
:
:
Critical
|
|
monthDay
-
>
calendar
(
)
.
identifier
(
)
!
=
CalendarId
:
:
ISO8601
)
{
FormatDateString
(
result
date
)
;
}
else
{
result
.
appendTwoDigit
(
date
.
month
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
day
)
;
}
if
(
!
FormatCalendarAnnotation
(
result
monthDay
-
>
calendar
(
)
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalYearMonthToString
(
JSContext
*
cx
Handle
<
PlainYearMonthObject
*
>
yearMonth
ShowCalendar
showCalendar
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
YearMonth
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
auto
date
=
yearMonth
-
>
date
(
)
;
if
(
showCalendar
=
=
ShowCalendar
:
:
Always
|
|
showCalendar
=
=
ShowCalendar
:
:
Critical
|
|
yearMonth
-
>
calendar
(
)
.
identifier
(
)
!
=
CalendarId
:
:
ISO8601
)
{
FormatDateString
(
result
date
)
;
}
else
{
result
.
appendYear
(
date
.
year
)
;
result
.
append
(
'
-
'
)
;
result
.
appendTwoDigit
(
date
.
month
)
;
}
if
(
!
FormatCalendarAnnotation
(
result
yearMonth
-
>
calendar
(
)
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
JSString
*
js
:
:
temporal
:
:
TemporalZonedDateTimeToString
(
JSContext
*
cx
Handle
<
ZonedDateTime
>
zonedDateTime
Precision
precision
ShowCalendar
showCalendar
ShowTimeZoneName
showTimeZone
ShowOffset
showOffset
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
)
{
TemporalStringBuilder
result
(
cx
TemporalStringFormat
:
:
ZonedDateTime
)
;
if
(
!
result
.
reserve
(
)
)
{
return
nullptr
;
}
auto
ns
=
RoundTemporalInstant
(
zonedDateTime
.
instant
(
)
increment
unit
roundingMode
)
;
auto
timeZone
=
zonedDateTime
.
timeZone
(
)
;
int64_t
offsetNanoseconds
;
if
(
!
GetOffsetNanosecondsFor
(
cx
timeZone
ns
&
offsetNanoseconds
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
std
:
:
abs
(
offsetNanoseconds
)
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
auto
temporalDateTime
=
GetISODateTimeFor
(
ns
offsetNanoseconds
)
;
FormatDateTimeString
(
result
temporalDateTime
precision
)
;
if
(
showOffset
!
=
ShowOffset
:
:
Never
)
{
FormatDateTimeUTCOffsetRounded
(
result
offsetNanoseconds
)
;
}
if
(
!
FormatTimeZoneAnnotation
(
result
timeZone
showTimeZone
)
)
{
return
nullptr
;
}
if
(
!
FormatCalendarAnnotation
(
result
zonedDateTime
.
calendar
(
)
showCalendar
)
)
{
return
nullptr
;
}
return
result
.
finishString
(
)
;
}
