#
include
"
builtin
/
temporal
/
PlainTime
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainDateTime
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
builtin
/
temporal
/
ToString
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
ds
/
IdValuePair
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
CallNonGenericMethod
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
static
inline
bool
IsPlainTime
(
Handle
<
Value
>
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
PlainTimeObject
>
(
)
;
}
#
ifdef
DEBUG
template
<
typename
T
>
static
bool
IsValidTime
(
T
hour
T
minute
T
second
T
millisecond
T
microsecond
T
nanosecond
)
{
static_assert
(
std
:
:
is_same_v
<
T
int32_t
>
|
|
std
:
:
is_same_v
<
T
double
>
)
;
MOZ_ASSERT
(
IsInteger
(
hour
)
)
;
MOZ_ASSERT
(
IsInteger
(
minute
)
)
;
MOZ_ASSERT
(
IsInteger
(
second
)
)
;
MOZ_ASSERT
(
IsInteger
(
millisecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
microsecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanosecond
)
)
;
if
(
hour
<
0
|
|
hour
>
23
)
{
return
false
;
}
if
(
minute
<
0
|
|
minute
>
59
)
{
return
false
;
}
if
(
second
<
0
|
|
second
>
59
)
{
return
false
;
}
if
(
millisecond
<
0
|
|
millisecond
>
999
)
{
return
false
;
}
if
(
microsecond
<
0
|
|
microsecond
>
999
)
{
return
false
;
}
if
(
nanosecond
<
0
|
|
nanosecond
>
999
)
{
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
IsValidTime
(
const
PlainTime
&
time
)
{
auto
&
[
hour
minute
second
millisecond
microsecond
nanosecond
]
=
time
;
return
:
:
IsValidTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
}
bool
js
:
:
temporal
:
:
IsValidTime
(
double
hour
double
minute
double
second
double
millisecond
double
microsecond
double
nanosecond
)
{
return
:
:
IsValidTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
}
#
endif
static
void
ReportInvalidTimeValue
(
JSContext
*
cx
const
char
*
name
int32_t
min
int32_t
max
double
num
)
{
Int32ToCStringBuf
minCbuf
;
const
char
*
minStr
=
Int32ToCString
(
&
minCbuf
min
)
;
Int32ToCStringBuf
maxCbuf
;
const
char
*
maxStr
=
Int32ToCString
(
&
maxCbuf
max
)
;
ToCStringBuf
numCbuf
;
const
char
*
numStr
=
NumberToCString
(
&
numCbuf
num
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PLAIN_TIME_INVALID_VALUE
name
minStr
maxStr
numStr
)
;
}
template
<
typename
T
>
static
inline
bool
ThrowIfInvalidTimeValue
(
JSContext
*
cx
const
char
*
name
int32_t
min
int32_t
max
T
num
)
{
if
(
min
<
=
num
&
&
num
<
=
max
)
{
return
true
;
}
ReportInvalidTimeValue
(
cx
name
min
max
num
)
;
return
false
;
}
template
<
typename
T
>
static
bool
ThrowIfInvalidTime
(
JSContext
*
cx
T
hour
T
minute
T
second
T
millisecond
T
microsecond
T
nanosecond
)
{
static_assert
(
std
:
:
is_same_v
<
T
int32_t
>
|
|
std
:
:
is_same_v
<
T
double
>
)
;
MOZ_ASSERT
(
IsInteger
(
hour
)
)
;
MOZ_ASSERT
(
IsInteger
(
minute
)
)
;
MOZ_ASSERT
(
IsInteger
(
second
)
)
;
MOZ_ASSERT
(
IsInteger
(
millisecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
microsecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanosecond
)
)
;
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
hour
"
0
23
hour
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
minute
"
0
59
minute
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
second
"
0
59
second
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
millisecond
"
0
999
millisecond
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
microsecond
"
0
999
microsecond
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidTimeValue
(
cx
"
nanosecond
"
0
999
nanosecond
)
)
{
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ThrowIfInvalidTime
(
JSContext
*
cx
const
PlainTime
&
time
)
{
auto
&
[
hour
minute
second
millisecond
microsecond
nanosecond
]
=
time
;
return
:
:
ThrowIfInvalidTime
(
cx
hour
minute
second
millisecond
microsecond
nanosecond
)
;
}
bool
js
:
:
temporal
:
:
ThrowIfInvalidTime
(
JSContext
*
cx
double
hour
double
minute
double
second
double
millisecond
double
microsecond
double
nanosecond
)
{
return
:
:
ThrowIfInvalidTime
(
cx
hour
minute
second
millisecond
microsecond
nanosecond
)
;
}
static
PlainTime
ConstrainTime
(
double
hour
double
minute
double
second
double
millisecond
double
microsecond
double
nanosecond
)
{
MOZ_ASSERT
(
IsInteger
(
hour
)
)
;
MOZ_ASSERT
(
IsInteger
(
minute
)
)
;
MOZ_ASSERT
(
IsInteger
(
second
)
)
;
MOZ_ASSERT
(
IsInteger
(
millisecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
microsecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanosecond
)
)
;
return
{
int32_t
(
std
:
:
clamp
(
hour
0
.
0
23
.
0
)
)
int32_t
(
std
:
:
clamp
(
minute
0
.
0
59
.
0
)
)
int32_t
(
std
:
:
clamp
(
second
0
.
0
59
.
0
)
)
int32_t
(
std
:
:
clamp
(
millisecond
0
.
0
999
.
0
)
)
int32_t
(
std
:
:
clamp
(
microsecond
0
.
0
999
.
0
)
)
int32_t
(
std
:
:
clamp
(
nanosecond
0
.
0
999
.
0
)
)
}
;
}
bool
js
:
:
temporal
:
:
RegulateTime
(
JSContext
*
cx
const
TimeRecord
&
time
TemporalOverflow
overflow
PlainTime
*
result
)
{
auto
&
[
hour
minute
second
millisecond
microsecond
nanosecond
]
=
time
;
MOZ_ASSERT
(
IsInteger
(
hour
)
)
;
MOZ_ASSERT
(
IsInteger
(
minute
)
)
;
MOZ_ASSERT
(
IsInteger
(
second
)
)
;
MOZ_ASSERT
(
IsInteger
(
millisecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
microsecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanosecond
)
)
;
if
(
overflow
=
=
TemporalOverflow
:
:
Constrain
)
{
*
result
=
ConstrainTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
return
true
;
}
MOZ_ASSERT
(
overflow
=
=
TemporalOverflow
:
:
Reject
)
;
if
(
!
ThrowIfInvalidTime
(
cx
hour
minute
second
millisecond
microsecond
nanosecond
)
)
{
return
false
;
}
*
result
=
{
int32_t
(
hour
)
int32_t
(
minute
)
int32_t
(
second
)
int32_t
(
millisecond
)
int32_t
(
microsecond
)
int32_t
(
nanosecond
)
}
;
return
true
;
}
static
PlainTimeObject
*
CreateTemporalTime
(
JSContext
*
cx
const
CallArgs
&
args
double
hour
double
minute
double
second
double
millisecond
double
microsecond
double
nanosecond
)
{
MOZ_ASSERT
(
IsInteger
(
hour
)
)
;
MOZ_ASSERT
(
IsInteger
(
minute
)
)
;
MOZ_ASSERT
(
IsInteger
(
second
)
)
;
MOZ_ASSERT
(
IsInteger
(
millisecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
microsecond
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanosecond
)
)
;
if
(
!
ThrowIfInvalidTime
(
cx
hour
minute
second
millisecond
microsecond
nanosecond
)
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_PlainTime
&
proto
)
)
{
return
nullptr
;
}
auto
*
object
=
NewObjectWithClassProto
<
PlainTimeObject
>
(
cx
proto
)
;
if
(
!
object
)
{
return
nullptr
;
}
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_HOUR_SLOT
Int32Value
(
hour
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MINUTE_SLOT
Int32Value
(
minute
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_SECOND_SLOT
Int32Value
(
second
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MILLISECOND_SLOT
Int32Value
(
millisecond
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MICROSECOND_SLOT
Int32Value
(
microsecond
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_NANOSECOND_SLOT
Int32Value
(
nanosecond
)
)
;
return
object
;
}
PlainTimeObject
*
js
:
:
temporal
:
:
CreateTemporalTime
(
JSContext
*
cx
const
PlainTime
&
time
)
{
auto
&
[
hour
minute
second
millisecond
microsecond
nanosecond
]
=
time
;
if
(
!
ThrowIfInvalidTime
(
cx
time
)
)
{
return
nullptr
;
}
auto
*
object
=
NewBuiltinClassInstance
<
PlainTimeObject
>
(
cx
)
;
if
(
!
object
)
{
return
nullptr
;
}
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_HOUR_SLOT
Int32Value
(
hour
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MINUTE_SLOT
Int32Value
(
minute
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_SECOND_SLOT
Int32Value
(
second
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MILLISECOND_SLOT
Int32Value
(
millisecond
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_MICROSECOND_SLOT
Int32Value
(
microsecond
)
)
;
object
-
>
setFixedSlot
(
PlainTimeObject
:
:
ISO_NANOSECOND_SLOT
Int32Value
(
nanosecond
)
)
;
return
object
;
}
static
TimeDuration
CreateTimeDurationRecord
(
double
days
int32_t
hours
int32_t
minutes
int32_t
seconds
int32_t
milliseconds
int32_t
microseconds
int32_t
nanoseconds
)
{
MOZ_ASSERT
(
IsValidDuration
(
{
0
0
0
days
double
(
hours
)
double
(
minutes
)
double
(
seconds
)
double
(
microseconds
)
double
(
nanoseconds
)
}
)
)
;
return
{
days
double
(
hours
)
double
(
minutes
)
double
(
seconds
)
double
(
milliseconds
)
double
(
microseconds
)
double
(
nanoseconds
)
}
;
}
static
int32_t
DurationSign
(
int32_t
hours
int32_t
minutes
int32_t
seconds
int32_t
milliseconds
int32_t
microseconds
int32_t
nanoseconds
)
{
if
(
hours
)
{
return
hours
>
0
?
1
:
-
1
;
}
if
(
minutes
)
{
return
minutes
>
0
?
1
:
-
1
;
}
if
(
seconds
)
{
return
seconds
>
0
?
1
:
-
1
;
}
if
(
milliseconds
)
{
return
milliseconds
>
0
?
1
:
-
1
;
}
if
(
microseconds
)
{
return
microseconds
>
0
?
1
:
-
1
;
}
if
(
nanoseconds
)
{
return
nanoseconds
>
0
?
1
:
-
1
;
}
return
0
;
}
template
<
typename
IntT
>
static
BalancedTime
BalanceTime
(
IntT
hour
IntT
minute
IntT
second
IntT
millisecond
IntT
microsecond
IntT
nanosecond
)
{
auto
divmod
=
[
]
(
IntT
dividend
int32_t
divisor
int32_t
*
remainder
)
{
MOZ_ASSERT
(
divisor
>
0
)
;
IntT
quotient
=
dividend
/
divisor
;
*
remainder
=
dividend
%
divisor
;
if
(
*
remainder
<
0
)
{
*
remainder
+
=
divisor
;
quotient
-
=
1
;
}
return
quotient
;
}
;
PlainTime
time
=
{
}
;
microsecond
+
=
divmod
(
nanosecond
1000
&
time
.
nanosecond
)
;
millisecond
+
=
divmod
(
microsecond
1000
&
time
.
microsecond
)
;
second
+
=
divmod
(
millisecond
1000
&
time
.
millisecond
)
;
minute
+
=
divmod
(
second
60
&
time
.
second
)
;
hour
+
=
divmod
(
minute
60
&
time
.
minute
)
;
int32_t
days
=
divmod
(
hour
24
&
time
.
hour
)
;
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
return
{
days
time
}
;
}
static
BalancedTime
BalanceTime
(
int32_t
hour
int32_t
minute
int32_t
second
int32_t
millisecond
int32_t
microsecond
int32_t
nanosecond
)
{
MOZ_ASSERT
(
-
24
<
hour
&
&
hour
<
2
*
24
)
;
MOZ_ASSERT
(
-
60
<
minute
&
&
minute
<
2
*
60
)
;
MOZ_ASSERT
(
-
60
<
second
&
&
second
<
2
*
60
)
;
MOZ_ASSERT
(
-
1000
<
millisecond
&
&
millisecond
<
2
*
1000
)
;
MOZ_ASSERT
(
-
1000
<
microsecond
&
&
microsecond
<
2
*
1000
)
;
MOZ_ASSERT
(
-
1000
<
nanosecond
&
&
nanosecond
<
2
*
1000
)
;
return
BalanceTime
<
int32_t
>
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
}
BalancedTime
js
:
:
temporal
:
:
BalanceTime
(
const
PlainTime
&
time
int64_t
nanoseconds
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
nanoseconds
)
<
=
2
*
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
return
:
:
BalanceTime
<
int64_t
>
(
time
.
hour
time
.
minute
time
.
second
time
.
millisecond
time
.
microsecond
time
.
nanosecond
+
nanoseconds
)
;
}
TimeDuration
js
:
:
temporal
:
:
DifferenceTime
(
const
PlainTime
&
time1
const
PlainTime
&
time2
)
{
MOZ_ASSERT
(
IsValidTime
(
time1
)
)
;
MOZ_ASSERT
(
IsValidTime
(
time2
)
)
;
int32_t
hours
=
time2
.
hour
-
time1
.
hour
;
int32_t
minutes
=
time2
.
minute
-
time1
.
minute
;
int32_t
seconds
=
time2
.
second
-
time1
.
second
;
int32_t
milliseconds
=
time2
.
millisecond
-
time1
.
millisecond
;
int32_t
microseconds
=
time2
.
microsecond
-
time1
.
microsecond
;
int32_t
nanoseconds
=
time2
.
nanosecond
-
time1
.
nanosecond
;
int32_t
sign
=
:
:
DurationSign
(
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
)
;
auto
balanced
=
:
:
BalanceTime
(
hours
*
sign
minutes
*
sign
seconds
*
sign
milliseconds
*
sign
microseconds
*
sign
nanoseconds
*
sign
)
;
MOZ_ASSERT
(
balanced
.
days
=
=
0
)
;
return
CreateTimeDurationRecord
(
0
balanced
.
time
.
hour
*
sign
balanced
.
time
.
minute
*
sign
balanced
.
time
.
second
*
sign
balanced
.
time
.
millisecond
*
sign
balanced
.
time
.
microsecond
*
sign
balanced
.
time
.
nanosecond
*
sign
)
;
}
static
bool
ToTemporalTime
(
JSContext
*
cx
Handle
<
Value
>
item
TemporalOverflow
overflow
PlainTime
*
result
)
{
if
(
item
.
isObject
(
)
)
{
Rooted
<
JSObject
*
>
itemObj
(
cx
&
item
.
toObject
(
)
)
;
if
(
auto
*
time
=
itemObj
-
>
maybeUnwrapIf
<
PlainTimeObject
>
(
)
)
{
*
result
=
ToPlainTime
(
time
)
;
return
true
;
}
if
(
auto
*
zonedDateTime
=
itemObj
-
>
maybeUnwrapIf
<
ZonedDateTimeObject
>
(
)
)
{
auto
epochInstant
=
ToInstant
(
zonedDateTime
)
;
Rooted
<
TimeZoneValue
>
timeZone
(
cx
zonedDateTime
-
>
timeZone
(
)
)
;
if
(
!
timeZone
.
wrap
(
cx
)
)
{
return
false
;
}
PlainDateTime
dateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
epochInstant
&
dateTime
)
)
{
return
false
;
}
*
result
=
dateTime
.
time
;
return
true
;
}
if
(
auto
*
dateTime
=
itemObj
-
>
maybeUnwrapIf
<
PlainDateTimeObject
>
(
)
)
{
*
result
=
ToPlainTime
(
dateTime
)
;
return
true
;
}
TimeRecord
timeResult
;
if
(
!
ToTemporalTimeRecord
(
cx
itemObj
&
timeResult
)
)
{
return
false
;
}
if
(
!
RegulateTime
(
cx
timeResult
overflow
result
)
)
{
return
false
;
}
}
else
{
if
(
!
item
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
item
nullptr
"
not
a
string
"
)
;
return
false
;
}
Rooted
<
JSString
*
>
string
(
cx
item
.
toString
(
)
)
;
if
(
!
ParseTemporalTimeString
(
cx
string
result
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidTime
(
*
result
)
)
;
}
return
true
;
}
static
PlainTimeObject
*
ToTemporalTime
(
JSContext
*
cx
Handle
<
Value
>
item
TemporalOverflow
overflow
)
{
PlainTime
time
;
if
(
!
ToTemporalTime
(
cx
item
overflow
&
time
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
return
CreateTemporalTime
(
cx
time
)
;
}
bool
js
:
:
temporal
:
:
ToTemporalTime
(
JSContext
*
cx
Handle
<
Value
>
item
PlainTime
*
result
)
{
return
ToTemporalTime
(
cx
item
TemporalOverflow
:
:
Constrain
result
)
;
}
static
int64_t
TotalDurationNanoseconds
(
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
hours
)
<
=
24
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
minutes
)
<
=
60
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
seconds
)
<
=
60
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
milliseconds
)
<
=
1000
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
microseconds
)
<
=
1000
)
;
MOZ_ASSERT
(
std
:
:
abs
(
duration
.
nanoseconds
)
<
=
1000
)
;
auto
minutes
=
int64_t
(
duration
.
minutes
)
+
int64_t
(
duration
.
hours
)
*
60
;
auto
seconds
=
int64_t
(
duration
.
seconds
)
+
minutes
*
60
;
auto
milliseconds
=
int64_t
(
duration
.
milliseconds
)
+
seconds
*
1000
;
auto
microseconds
=
int64_t
(
duration
.
microseconds
)
+
milliseconds
*
1000
;
return
int64_t
(
duration
.
nanoseconds
)
+
microseconds
*
1000
;
}
static
Duration
BalanceTimeDuration
(
const
Duration
&
duration
TemporalUnit
largestUnit
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
MOZ_ASSERT
(
largestUnit
>
TemporalUnit
:
:
Day
)
;
MOZ_ASSERT
(
duration
.
years
=
=
0
)
;
MOZ_ASSERT
(
duration
.
months
=
=
0
)
;
MOZ_ASSERT
(
duration
.
weeks
=
=
0
)
;
MOZ_ASSERT
(
duration
.
days
=
=
0
)
;
int64_t
nanoseconds
=
TotalDurationNanoseconds
(
duration
)
;
MOZ_ASSERT
(
std
:
:
abs
(
nanoseconds
)
<
=
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
int64_t
hours
=
0
;
int64_t
minutes
=
0
;
int64_t
seconds
=
0
;
int64_t
milliseconds
=
0
;
int64_t
microseconds
=
0
;
int32_t
sign
=
nanoseconds
<
0
?
-
1
:
+
1
;
nanoseconds
=
std
:
:
abs
(
nanoseconds
)
;
switch
(
largestUnit
)
{
case
TemporalUnit
:
:
Auto
:
case
TemporalUnit
:
:
Year
:
case
TemporalUnit
:
:
Month
:
case
TemporalUnit
:
:
Week
:
case
TemporalUnit
:
:
Day
:
MOZ_CRASH
(
"
Unexpected
temporal
unit
"
)
;
case
TemporalUnit
:
:
Hour
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
seconds
=
milliseconds
/
1000
;
milliseconds
=
milliseconds
%
1000
;
minutes
=
seconds
/
60
;
seconds
=
seconds
%
60
;
hours
=
minutes
/
60
;
minutes
=
minutes
%
60
;
break
;
}
case
TemporalUnit
:
:
Minute
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
seconds
=
milliseconds
/
1000
;
milliseconds
=
milliseconds
%
1000
;
minutes
=
seconds
/
60
;
seconds
=
seconds
%
60
;
break
;
}
case
TemporalUnit
:
:
Second
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
seconds
=
milliseconds
/
1000
;
milliseconds
=
milliseconds
%
1000
;
break
;
}
case
TemporalUnit
:
:
Millisecond
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
break
;
}
case
TemporalUnit
:
:
Microsecond
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
break
;
}
case
TemporalUnit
:
:
Nanosecond
:
{
break
;
}
}
return
{
0
0
0
0
double
(
hours
*
sign
)
double
(
minutes
*
sign
)
double
(
seconds
*
sign
)
double
(
milliseconds
*
sign
)
double
(
microseconds
*
sign
)
double
(
nanoseconds
*
sign
)
}
;
}
int32_t
js
:
:
temporal
:
:
CompareTemporalTime
(
const
PlainTime
&
one
const
PlainTime
&
two
)
{
if
(
int32_t
diff
=
one
.
hour
-
two
.
hour
)
{
return
diff
<
0
?
-
1
:
1
;
}
if
(
int32_t
diff
=
one
.
minute
-
two
.
minute
)
{
return
diff
<
0
?
-
1
:
1
;
}
if
(
int32_t
diff
=
one
.
second
-
two
.
second
)
{
return
diff
<
0
?
-
1
:
1
;
}
if
(
int32_t
diff
=
one
.
millisecond
-
two
.
millisecond
)
{
return
diff
<
0
?
-
1
:
1
;
}
if
(
int32_t
diff
=
one
.
microsecond
-
two
.
microsecond
)
{
return
diff
<
0
?
-
1
:
1
;
}
if
(
int32_t
diff
=
one
.
nanosecond
-
two
.
nanosecond
)
{
return
diff
<
0
?
-
1
:
1
;
}
return
0
;
}
static
bool
ToTemporalTimeRecord
(
JSContext
*
cx
Handle
<
JSObject
*
>
temporalTimeLike
TimeRecord
*
result
)
{
bool
any
=
false
;
Rooted
<
Value
>
value
(
cx
)
;
auto
getTimeProperty
=
[
&
]
(
Handle
<
PropertyName
*
>
property
const
char
*
name
double
*
num
)
{
if
(
!
GetProperty
(
cx
temporalTimeLike
temporalTimeLike
property
&
value
)
)
{
return
false
;
}
if
(
!
value
.
isUndefined
(
)
)
{
any
=
true
;
if
(
!
ToIntegerWithTruncation
(
cx
value
name
num
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
hour
"
hour
"
&
result
-
>
hour
)
)
{
return
false
;
}
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
microsecond
"
microsecond
"
&
result
-
>
microsecond
)
)
{
return
false
;
}
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
millisecond
"
millisecond
"
&
result
-
>
millisecond
)
)
{
return
false
;
}
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
minute
"
minute
"
&
result
-
>
minute
)
)
{
return
false
;
}
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
nanosecond
"
nanosecond
"
&
result
-
>
nanosecond
)
)
{
return
false
;
}
if
(
!
getTimeProperty
(
cx
-
>
names
(
)
.
second
"
second
"
&
result
-
>
second
)
)
{
return
false
;
}
if
(
!
any
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_PLAIN_TIME_MISSING_UNIT
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ToTemporalTimeRecord
(
JSContext
*
cx
Handle
<
JSObject
*
>
temporalTimeLike
TimeRecord
*
result
)
{
*
result
=
{
}
;
return
:
:
ToTemporalTimeRecord
(
cx
temporalTimeLike
result
)
;
}
static
int64_t
RoundNumberToIncrement
(
int64_t
x
TemporalUnit
unit
Increment
increment
TemporalRoundingMode
roundingMode
)
{
MOZ_ASSERT
(
x
>
=
0
)
;
MOZ_ASSERT
(
x
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
MOZ_ASSERT
(
unit
>
=
TemporalUnit
:
:
Day
)
;
MOZ_ASSERT_IF
(
unit
=
=
TemporalUnit
:
:
Day
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT_IF
(
unit
>
TemporalUnit
:
:
Day
increment
<
=
MaximumTemporalDurationRoundingIncrement
(
unit
)
)
;
int64_t
divisor
=
ToNanoseconds
(
unit
)
*
increment
.
value
(
)
;
MOZ_ASSERT
(
divisor
>
0
)
;
MOZ_ASSERT
(
divisor
<
=
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
if
(
divisor
=
=
1
)
{
MOZ_ASSERT
(
increment
=
=
Increment
{
1
}
)
;
return
x
;
}
int64_t
rounded
=
Divide
(
x
divisor
roundingMode
)
;
mozilla
:
:
CheckedInt64
result
=
rounded
;
result
*
=
increment
.
value
(
)
;
MOZ_ASSERT
(
result
.
isValid
(
)
"
can
'
t
overflow
when
inputs
are
all
in
range
"
)
;
return
result
.
value
(
)
;
}
static
int64_t
RoundNumberToIncrement
(
int64_t
x
int64_t
divisor
Increment
increment
TemporalRoundingMode
roundingMode
)
{
MOZ_ASSERT
(
x
>
=
0
)
;
MOZ_ASSERT
(
x
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
MOZ_ASSERT
(
divisor
>
0
)
;
MOZ_ASSERT
(
increment
=
=
Increment
{
1
}
"
Rounding
increment
for
'
day
'
is
1
"
)
;
return
Divide
(
x
divisor
roundingMode
)
;
}
static
int64_t
TimeToNanos
(
const
PlainTime
&
time
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
int64_t
hour
=
time
.
hour
;
int64_t
minute
=
time
.
minute
;
int64_t
second
=
time
.
second
;
int64_t
millisecond
=
time
.
millisecond
;
int64_t
microsecond
=
time
.
microsecond
;
int64_t
nanosecond
=
time
.
nanosecond
;
int64_t
millis
=
(
(
hour
*
60
+
minute
)
*
60
+
second
)
*
1000
+
millisecond
;
return
(
millis
*
1000
+
microsecond
)
*
1000
+
nanosecond
;
}
RoundedTime
js
:
:
temporal
:
:
RoundTime
(
const
PlainTime
&
time
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
unit
>
=
TemporalUnit
:
:
Day
)
;
MOZ_ASSERT_IF
(
unit
>
TemporalUnit
:
:
Day
increment
<
=
MaximumTemporalDurationRoundingIncrement
(
unit
)
)
;
MOZ_ASSERT_IF
(
unit
=
=
TemporalUnit
:
:
Day
increment
=
=
Increment
{
1
}
)
;
int32_t
days
=
0
;
auto
[
hour
minute
second
millisecond
microsecond
nanosecond
]
=
time
;
PlainTime
quantity
;
int32_t
*
result
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Day
:
quantity
=
time
;
result
=
&
days
;
break
;
case
TemporalUnit
:
:
Hour
:
quantity
=
time
;
result
=
&
hour
;
minute
=
0
;
second
=
0
;
millisecond
=
0
;
microsecond
=
0
;
nanosecond
=
0
;
break
;
case
TemporalUnit
:
:
Minute
:
quantity
=
{
0
minute
second
millisecond
microsecond
nanosecond
}
;
result
=
&
minute
;
second
=
0
;
millisecond
=
0
;
microsecond
=
0
;
nanosecond
=
0
;
break
;
case
TemporalUnit
:
:
Second
:
quantity
=
{
0
0
second
millisecond
microsecond
nanosecond
}
;
result
=
&
second
;
millisecond
=
0
;
microsecond
=
0
;
nanosecond
=
0
;
break
;
case
TemporalUnit
:
:
Millisecond
:
quantity
=
{
0
0
0
millisecond
microsecond
nanosecond
}
;
result
=
&
millisecond
;
microsecond
=
0
;
nanosecond
=
0
;
break
;
case
TemporalUnit
:
:
Microsecond
:
quantity
=
{
0
0
0
0
microsecond
nanosecond
}
;
result
=
&
microsecond
;
nanosecond
=
0
;
break
;
case
TemporalUnit
:
:
Nanosecond
:
quantity
=
{
0
0
0
0
0
nanosecond
}
;
result
=
&
nanosecond
;
break
;
case
TemporalUnit
:
:
Auto
:
case
TemporalUnit
:
:
Year
:
case
TemporalUnit
:
:
Month
:
case
TemporalUnit
:
:
Week
:
MOZ_CRASH
(
"
unexpected
temporal
unit
"
)
;
}
int64_t
r
=
:
:
RoundNumberToIncrement
(
TimeToNanos
(
quantity
)
unit
increment
roundingMode
)
;
MOZ_ASSERT
(
r
=
=
int64_t
(
int32_t
(
r
)
)
"
no
overflow
possible
due
to
limited
range
of
arguments
"
)
;
*
result
=
r
;
if
(
unit
=
=
TemporalUnit
:
:
Day
)
{
return
{
int64_t
(
days
)
{
0
0
0
0
0
0
}
}
;
}
auto
balanced
=
:
:
BalanceTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
return
{
int64_t
(
balanced
.
days
)
balanced
.
time
}
;
}
RoundedTime
js
:
:
temporal
:
:
RoundTime
(
const
PlainTime
&
time
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
const
InstantSpan
&
dayLengthNs
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
IsValidInstantSpan
(
dayLengthNs
)
)
;
MOZ_ASSERT
(
dayLengthNs
>
(
InstantSpan
{
}
)
)
;
if
(
unit
!
=
TemporalUnit
:
:
Day
)
{
return
RoundTime
(
time
increment
unit
roundingMode
)
;
}
int64_t
quantity
=
TimeToNanos
(
time
)
;
MOZ_ASSERT
(
quantity
<
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
int64_t
divisor
;
if
(
auto
checkedDiv
=
dayLengthNs
.
toNanoseconds
(
)
;
checkedDiv
.
isValid
(
)
)
{
divisor
=
checkedDiv
.
value
(
)
;
}
else
{
divisor
=
ToNanoseconds
(
TemporalUnit
:
:
Day
)
;
}
MOZ_ASSERT
(
divisor
>
0
)
;
int64_t
result
=
:
:
RoundNumberToIncrement
(
quantity
divisor
increment
roundingMode
)
;
return
{
result
{
0
0
0
0
0
0
}
}
;
}
static
PlainTime
AddTime
(
const
PlainTime
&
time
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
static_assert
(
1
*
UnitsPerDay
(
TemporalUnit
:
:
Nanosecond
)
>
INT32_MAX
"
total
combined
nanoseconds
per
day
"
)
;
static_assert
(
2
*
UnitsPerDay
(
TemporalUnit
:
:
Microsecond
)
>
INT32_MAX
"
total
combined
microseconds
per
day
"
)
;
static_assert
(
3
*
UnitsPerDay
(
TemporalUnit
:
:
Millisecond
)
<
=
INT32_MAX
"
total
combined
milliseconds
per
day
"
)
;
static_assert
(
4
*
UnitsPerDay
(
TemporalUnit
:
:
Second
)
<
=
INT32_MAX
"
total
combined
seconds
per
day
"
)
;
static_assert
(
5
*
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
<
=
INT32_MAX
"
total
combined
minutes
per
day
"
)
;
static_assert
(
6
*
UnitsPerDay
(
TemporalUnit
:
:
Hour
)
<
=
INT32_MAX
"
total
combined
hours
per
day
"
)
;
int64_t
nanoseconds
=
int64_t
(
std
:
:
fmod
(
duration
.
nanoseconds
UnitsPerDay
(
TemporalUnit
:
:
Nanosecond
)
)
)
;
int64_t
microseconds
=
int64_t
(
std
:
:
fmod
(
duration
.
microseconds
UnitsPerDay
(
TemporalUnit
:
:
Microsecond
)
)
)
;
int32_t
milliseconds
=
int32_t
(
std
:
:
fmod
(
duration
.
milliseconds
UnitsPerDay
(
TemporalUnit
:
:
Millisecond
)
)
)
;
int32_t
seconds
=
int32_t
(
std
:
:
fmod
(
duration
.
seconds
UnitsPerDay
(
TemporalUnit
:
:
Second
)
)
)
;
int32_t
minutes
=
int32_t
(
std
:
:
fmod
(
duration
.
minutes
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
)
)
;
int32_t
hours
=
int32_t
(
std
:
:
fmod
(
duration
.
hours
UnitsPerDay
(
TemporalUnit
:
:
Hour
)
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
nanoseconds
)
<
UnitsPerDay
(
TemporalUnit
:
:
Nanosecond
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
microseconds
)
<
UnitsPerDay
(
TemporalUnit
:
:
Microsecond
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
UnitsPerDay
(
TemporalUnit
:
:
Millisecond
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
seconds
)
<
UnitsPerDay
(
TemporalUnit
:
:
Second
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
minutes
)
<
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
)
;
MOZ_ASSERT
(
std
:
:
abs
(
hours
)
<
UnitsPerDay
(
TemporalUnit
:
:
Hour
)
)
;
microseconds
+
=
nanoseconds
/
1000
;
nanoseconds
%
=
1000
;
MOZ_ASSERT
(
microseconds
<
2
*
UnitsPerDay
(
TemporalUnit
:
:
Microsecond
)
)
;
milliseconds
+
=
microseconds
/
1000
;
microseconds
%
=
1000
;
MOZ_ASSERT
(
milliseconds
<
3
*
UnitsPerDay
(
TemporalUnit
:
:
Millisecond
)
)
;
seconds
+
=
milliseconds
/
1000
;
milliseconds
%
=
1000
;
MOZ_ASSERT
(
seconds
<
4
*
UnitsPerDay
(
TemporalUnit
:
:
Second
)
)
;
minutes
+
=
seconds
/
60
;
seconds
%
=
60
;
MOZ_ASSERT
(
minutes
<
5
*
UnitsPerDay
(
TemporalUnit
:
:
Minute
)
)
;
hours
+
=
minutes
/
60
;
minutes
%
=
60
;
MOZ_ASSERT
(
hours
<
6
*
UnitsPerDay
(
TemporalUnit
:
:
Hour
)
)
;
hours
%
=
24
;
MOZ_ASSERT
(
std
:
:
abs
(
hours
)
<
=
23
)
;
MOZ_ASSERT
(
std
:
:
abs
(
minutes
)
<
=
59
)
;
MOZ_ASSERT
(
std
:
:
abs
(
seconds
)
<
=
59
)
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
MOZ_ASSERT
(
std
:
:
abs
(
microseconds
)
<
=
999
)
;
MOZ_ASSERT
(
std
:
:
abs
(
nanoseconds
)
<
=
999
)
;
int32_t
hour
=
time
.
hour
+
hours
;
int32_t
minute
=
time
.
minute
+
minutes
;
int32_t
second
=
time
.
second
+
seconds
;
int32_t
millisecond
=
time
.
millisecond
+
milliseconds
;
int32_t
microsecond
=
time
.
microsecond
+
int32_t
(
microseconds
)
;
int32_t
nanosecond
=
time
.
nanosecond
+
int32_t
(
nanoseconds
)
;
auto
balanced
=
:
:
BalanceTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
return
balanced
.
time
;
}
static
BigInt
*
FloorDiv
(
JSContext
*
cx
Handle
<
BigInt
*
>
dividend
int32_t
divisor
)
{
MOZ_ASSERT
(
divisor
>
0
)
;
Rooted
<
BigInt
*
>
div
(
cx
BigInt
:
:
createFromInt64
(
cx
divisor
)
)
;
if
(
!
div
)
{
return
nullptr
;
}
Rooted
<
BigInt
*
>
quotient
(
cx
)
;
Rooted
<
BigInt
*
>
remainder
(
cx
)
;
if
(
!
BigInt
:
:
divmod
(
cx
dividend
div
&
quotient
&
remainder
)
)
{
return
nullptr
;
}
if
(
remainder
-
>
isNegative
(
)
)
{
return
BigInt
:
:
dec
(
cx
quotient
)
;
}
return
quotient
;
}
static
bool
AddTimeDaysSlow
(
JSContext
*
cx
const
PlainTime
&
time
const
Duration
&
duration
double
*
result
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
Rooted
<
BigInt
*
>
days
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
days
)
)
;
if
(
!
days
)
{
return
false
;
}
Rooted
<
BigInt
*
>
hours
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
hours
)
)
;
if
(
!
hours
)
{
return
false
;
}
Rooted
<
BigInt
*
>
minutes
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
minutes
)
)
;
if
(
!
minutes
)
{
return
false
;
}
Rooted
<
BigInt
*
>
seconds
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
seconds
)
)
;
if
(
!
seconds
)
{
return
false
;
}
Rooted
<
BigInt
*
>
milliseconds
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
milliseconds
)
)
;
if
(
!
milliseconds
)
{
return
false
;
}
Rooted
<
BigInt
*
>
microseconds
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
microseconds
)
)
;
if
(
!
microseconds
)
{
return
false
;
}
Rooted
<
BigInt
*
>
nanoseconds
(
cx
BigInt
:
:
createFromDouble
(
cx
duration
.
nanoseconds
)
)
;
if
(
!
nanoseconds
)
{
return
false
;
}
auto
addWithInt32
=
[
cx
]
(
Handle
<
BigInt
*
>
left
int32_t
right
)
-
>
BigInt
*
{
Rooted
<
BigInt
*
>
rightBigInt
(
cx
BigInt
:
:
createFromInt64
(
cx
right
)
)
;
if
(
!
rightBigInt
)
{
return
nullptr
;
}
return
BigInt
:
:
add
(
cx
left
rightBigInt
)
;
}
;
Rooted
<
BigInt
*
>
hour
(
cx
addWithInt32
(
hours
time
.
hour
)
)
;
if
(
!
hour
)
{
return
false
;
}
Rooted
<
BigInt
*
>
minute
(
cx
addWithInt32
(
minutes
time
.
minute
)
)
;
if
(
!
minute
)
{
return
false
;
}
Rooted
<
BigInt
*
>
second
(
cx
addWithInt32
(
seconds
time
.
second
)
)
;
if
(
!
second
)
{
return
false
;
}
Rooted
<
BigInt
*
>
millisecond
(
cx
addWithInt32
(
milliseconds
time
.
millisecond
)
)
;
if
(
!
millisecond
)
{
return
false
;
}
Rooted
<
BigInt
*
>
microsecond
(
cx
addWithInt32
(
microseconds
time
.
microsecond
)
)
;
if
(
!
microsecond
)
{
return
false
;
}
Rooted
<
BigInt
*
>
nanosecond
(
cx
addWithInt32
(
nanoseconds
time
.
nanosecond
)
)
;
if
(
!
nanosecond
)
{
return
false
;
}
auto
addFloorDiv
=
[
cx
]
(
Handle
<
BigInt
*
>
left
Handle
<
BigInt
*
>
right
int32_t
divisor
)
-
>
BigInt
*
{
Rooted
<
BigInt
*
>
quotient
(
cx
FloorDiv
(
cx
right
divisor
)
)
;
if
(
!
quotient
)
{
return
nullptr
;
}
return
BigInt
:
:
add
(
cx
left
quotient
)
;
}
;
microsecond
=
addFloorDiv
(
microsecond
nanosecond
1000
)
;
if
(
!
microsecond
)
{
return
false
;
}
millisecond
=
addFloorDiv
(
millisecond
microsecond
1000
)
;
if
(
!
millisecond
)
{
return
false
;
}
second
=
addFloorDiv
(
second
millisecond
1000
)
;
if
(
!
second
)
{
return
false
;
}
minute
=
addFloorDiv
(
minute
second
60
)
;
if
(
!
minute
)
{
return
false
;
}
hour
=
addFloorDiv
(
hour
minute
60
)
;
if
(
!
hour
)
{
return
false
;
}
days
=
addFloorDiv
(
days
hour
24
)
;
if
(
!
days
)
{
return
false
;
}
double
daysNumber
=
BigInt
:
:
numberValue
(
days
)
;
if
(
!
ThrowIfInvalidDuration
(
cx
{
0
0
0
daysNumber
}
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
daysNumber
)
)
;
*
result
=
daysNumber
;
return
true
;
}
static
mozilla
:
:
Maybe
<
int64_t
>
AddTimeDays
(
const
PlainTime
&
time
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
int64_t
days
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
days
&
days
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
hours
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
hours
&
hours
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
minutes
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
minutes
&
minutes
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
seconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
seconds
&
seconds
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
milliseconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
milliseconds
&
milliseconds
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
microseconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
microseconds
&
microseconds
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int64_t
nanoseconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
nanoseconds
&
nanoseconds
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
hour
=
mozilla
:
:
CheckedInt64
(
time
.
hour
)
+
hours
;
if
(
!
hour
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
minute
=
mozilla
:
:
CheckedInt64
(
time
.
minute
)
+
minutes
;
if
(
!
minute
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
second
=
mozilla
:
:
CheckedInt64
(
time
.
second
)
+
seconds
;
if
(
!
second
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
millisecond
=
mozilla
:
:
CheckedInt64
(
time
.
millisecond
)
+
milliseconds
;
if
(
!
millisecond
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
microsecond
=
mozilla
:
:
CheckedInt64
(
time
.
microsecond
)
+
microseconds
;
if
(
!
microsecond
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
nanosecond
=
mozilla
:
:
CheckedInt64
(
time
.
nanosecond
)
+
nanoseconds
;
if
(
!
nanosecond
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
microsecond
+
=
FloorDiv
(
nanosecond
.
value
(
)
1000
)
;
if
(
!
microsecond
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
millisecond
+
=
FloorDiv
(
microsecond
.
value
(
)
1000
)
;
if
(
!
millisecond
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
second
+
=
FloorDiv
(
millisecond
.
value
(
)
1000
)
;
if
(
!
second
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
minute
+
=
FloorDiv
(
second
.
value
(
)
60
)
;
if
(
!
minute
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
hour
+
=
FloorDiv
(
minute
.
value
(
)
60
)
;
if
(
!
hour
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
result
=
mozilla
:
:
CheckedInt64
(
days
)
+
FloorDiv
(
hour
.
value
(
)
24
)
;
if
(
!
result
.
isValid
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
return
mozilla
:
:
Some
(
result
.
value
(
)
)
;
}
static
bool
AddTimeDays
(
JSContext
*
cx
const
PlainTime
&
time
const
Duration
&
duration
double
*
result
)
{
if
(
auto
days
=
AddTimeDays
(
time
duration
)
)
{
*
result
=
*
days
;
return
true
;
}
return
AddTimeDaysSlow
(
cx
time
duration
result
)
;
}
bool
js
:
:
temporal
:
:
AddTime
(
JSContext
*
cx
const
PlainTime
&
time
const
Duration
&
duration
PlainTime
*
result
double
*
daysResult
)
{
MOZ_ASSERT
(
IsValidTime
(
time
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
auto
balanced
=
:
:
AddTime
(
time
duration
)
;
double
days
;
if
(
!
AddTimeDays
(
cx
time
duration
&
days
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
days
)
)
;
*
result
=
balanced
;
*
daysResult
=
days
;
return
true
;
}
static
bool
DifferenceTemporalPlainTime
(
JSContext
*
cx
TemporalDifference
operation
const
CallArgs
&
args
)
{
auto
temporalTime
=
ToPlainTime
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
)
;
PlainTime
other
;
if
(
!
ToTemporalTime
(
cx
args
.
get
(
0
)
&
other
)
)
{
return
false
;
}
DifferenceSettings
settings
;
if
(
args
.
hasDefined
(
1
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
ToName
(
operation
)
args
[
1
]
)
)
;
if
(
!
options
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
resolvedOptions
(
cx
SnapshotOwnProperties
(
cx
options
)
)
;
if
(
!
resolvedOptions
)
{
return
false
;
}
if
(
!
GetDifferenceSettings
(
cx
operation
resolvedOptions
TemporalUnitGroup
:
:
Time
TemporalUnit
:
:
Nanosecond
TemporalUnit
:
:
Hour
&
settings
)
)
{
return
false
;
}
}
else
{
settings
=
{
TemporalUnit
:
:
Nanosecond
TemporalUnit
:
:
Hour
TemporalRoundingMode
:
:
Trunc
Increment
{
1
}
}
;
}
auto
diff
=
DifferenceTime
(
temporalTime
other
)
;
MOZ_ASSERT
(
diff
.
days
=
=
0
)
;
auto
roundedDuration
=
diff
.
toDuration
(
)
;
if
(
settings
.
smallestUnit
!
=
TemporalUnit
:
:
Nanosecond
|
|
settings
.
roundingIncrement
!
=
Increment
{
1
}
)
{
if
(
!
RoundDuration
(
cx
roundedDuration
.
time
(
)
settings
.
roundingIncrement
settings
.
smallestUnit
settings
.
roundingMode
&
roundedDuration
)
)
{
return
false
;
}
}
auto
balancedDuration
=
BalanceTimeDuration
(
roundedDuration
settings
.
largestUnit
)
;
if
(
operation
=
=
TemporalDifference
:
:
Since
)
{
balancedDuration
=
balancedDuration
.
negate
(
)
;
}
auto
*
result
=
CreateTemporalDuration
(
cx
balancedDuration
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
enum
class
PlainTimeDuration
{
Add
Subtract
}
;
static
bool
AddDurationToOrSubtractDurationFromPlainTime
(
JSContext
*
cx
PlainTimeDuration
operation
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
Duration
duration
;
if
(
!
ToTemporalDurationRecord
(
cx
args
.
get
(
0
)
&
duration
)
)
{
return
false
;
}
if
(
operation
=
=
PlainTimeDuration
:
:
Subtract
)
{
duration
=
duration
.
negate
(
)
;
}
auto
result
=
AddTime
(
time
duration
)
;
MOZ_ASSERT
(
IsValidTime
(
result
)
)
;
auto
*
obj
=
CreateTemporalTime
(
cx
result
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
PlainTimeConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Temporal
.
PlainTime
"
)
)
{
return
false
;
}
double
hour
=
0
;
if
(
args
.
hasDefined
(
0
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
0
]
"
hour
"
&
hour
)
)
{
return
false
;
}
}
double
minute
=
0
;
if
(
args
.
hasDefined
(
1
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
1
]
"
minute
"
&
minute
)
)
{
return
false
;
}
}
double
second
=
0
;
if
(
args
.
hasDefined
(
2
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
2
]
"
second
"
&
second
)
)
{
return
false
;
}
}
double
millisecond
=
0
;
if
(
args
.
hasDefined
(
3
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
3
]
"
millisecond
"
&
millisecond
)
)
{
return
false
;
}
}
double
microsecond
=
0
;
if
(
args
.
hasDefined
(
4
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
4
]
"
microsecond
"
&
microsecond
)
)
{
return
false
;
}
}
double
nanosecond
=
0
;
if
(
args
.
hasDefined
(
5
)
)
{
if
(
!
ToIntegerWithTruncation
(
cx
args
[
5
]
"
nanosecond
"
&
nanosecond
)
)
{
return
false
;
}
}
auto
*
temporalTime
=
CreateTemporalTime
(
cx
args
hour
minute
second
millisecond
microsecond
nanosecond
)
;
if
(
!
temporalTime
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
temporalTime
)
;
return
true
;
}
static
bool
PlainTime_from
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
args
.
hasDefined
(
1
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
"
from
"
args
[
1
]
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
ToTemporalOverflow
(
cx
options
&
overflow
)
)
{
return
false
;
}
}
auto
result
=
ToTemporalTime
(
cx
args
.
get
(
0
)
overflow
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
PlainTime_compare
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
PlainTime
one
;
if
(
!
ToTemporalTime
(
cx
args
.
get
(
0
)
&
one
)
)
{
return
false
;
}
PlainTime
two
;
if
(
!
ToTemporalTime
(
cx
args
.
get
(
1
)
&
two
)
)
{
return
false
;
}
args
.
rval
(
)
.
setInt32
(
CompareTemporalTime
(
one
two
)
)
;
return
true
;
}
static
bool
PlainTime_hour
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoHour
(
)
)
;
return
true
;
}
static
bool
PlainTime_hour
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_hour
>
(
cx
args
)
;
}
static
bool
PlainTime_minute
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoMinute
(
)
)
;
return
true
;
}
static
bool
PlainTime_minute
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_minute
>
(
cx
args
)
;
}
static
bool
PlainTime_second
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoSecond
(
)
)
;
return
true
;
}
static
bool
PlainTime_second
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_second
>
(
cx
args
)
;
}
static
bool
PlainTime_millisecond
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoMillisecond
(
)
)
;
return
true
;
}
static
bool
PlainTime_millisecond
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_millisecond
>
(
cx
args
)
;
}
static
bool
PlainTime_microsecond
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoMicrosecond
(
)
)
;
return
true
;
}
static
bool
PlainTime_microsecond
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_microsecond
>
(
cx
args
)
;
}
static
bool
PlainTime_nanosecond
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
args
.
rval
(
)
.
setInt32
(
temporalTime
-
>
isoNanosecond
(
)
)
;
return
true
;
}
static
bool
PlainTime_nanosecond
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_nanosecond
>
(
cx
args
)
;
}
static
bool
PlainTime_add
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
AddDurationToOrSubtractDurationFromPlainTime
(
cx
PlainTimeDuration
:
:
Add
args
)
;
}
static
bool
PlainTime_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_add
>
(
cx
args
)
;
}
static
bool
PlainTime_subtract
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
AddDurationToOrSubtractDurationFromPlainTime
(
cx
PlainTimeDuration
:
:
Subtract
args
)
;
}
static
bool
PlainTime_subtract
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_subtract
>
(
cx
args
)
;
}
static
bool
PlainTime_with
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
Rooted
<
JSObject
*
>
temporalTimeLike
(
cx
RequireObjectArg
(
cx
"
temporalTimeLike
"
"
with
"
args
.
get
(
0
)
)
)
;
if
(
!
temporalTimeLike
)
{
return
false
;
}
if
(
!
RejectTemporalLikeObject
(
cx
temporalTimeLike
)
)
{
return
false
;
}
auto
overflow
=
TemporalOverflow
:
:
Constrain
;
if
(
args
.
hasDefined
(
1
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
"
with
"
args
[
1
]
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
ToTemporalOverflow
(
cx
options
&
overflow
)
)
{
return
false
;
}
}
TimeRecord
partialTime
=
{
double
(
time
.
hour
)
double
(
time
.
minute
)
double
(
time
.
second
)
double
(
time
.
millisecond
)
double
(
time
.
microsecond
)
double
(
time
.
nanosecond
)
}
;
if
(
!
:
:
ToTemporalTimeRecord
(
cx
temporalTimeLike
&
partialTime
)
)
{
return
false
;
}
PlainTime
result
;
if
(
!
RegulateTime
(
cx
partialTime
overflow
&
result
)
)
{
return
false
;
}
auto
*
obj
=
CreateTemporalTime
(
cx
result
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
PlainTime_with
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_with
>
(
cx
args
)
;
}
static
bool
PlainTime_until
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
DifferenceTemporalPlainTime
(
cx
TemporalDifference
:
:
Until
args
)
;
}
static
bool
PlainTime_until
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_until
>
(
cx
args
)
;
}
static
bool
PlainTime_since
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
DifferenceTemporalPlainTime
(
cx
TemporalDifference
:
:
Since
args
)
;
}
static
bool
PlainTime_since
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_since
>
(
cx
args
)
;
}
static
bool
PlainTime_round
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
auto
smallestUnit
=
TemporalUnit
:
:
Auto
;
auto
roundingMode
=
TemporalRoundingMode
:
:
HalfExpand
;
auto
roundingIncrement
=
Increment
{
1
}
;
if
(
args
.
get
(
0
)
.
isString
(
)
)
{
Rooted
<
JSString
*
>
paramString
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
GetTemporalUnit
(
cx
paramString
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
Time
&
smallestUnit
)
)
{
return
false
;
}
}
else
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
roundTo
"
"
round
"
args
.
get
(
0
)
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
ToTemporalRoundingIncrement
(
cx
options
&
roundingIncrement
)
)
{
return
false
;
}
if
(
!
ToTemporalRoundingMode
(
cx
options
&
roundingMode
)
)
{
return
false
;
}
if
(
!
GetTemporalUnit
(
cx
options
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
Time
&
smallestUnit
)
)
{
return
false
;
}
if
(
smallestUnit
=
=
TemporalUnit
:
:
Auto
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_OPTION
"
smallestUnit
"
)
;
return
false
;
}
auto
maximum
=
MaximumTemporalDurationRoundingIncrement
(
smallestUnit
)
;
if
(
!
ValidateTemporalRoundingIncrement
(
cx
roundingIncrement
maximum
false
)
)
{
return
false
;
}
}
auto
result
=
RoundTime
(
time
roundingIncrement
smallestUnit
roundingMode
)
;
auto
*
obj
=
CreateTemporalTime
(
cx
result
.
time
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
PlainTime_round
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_round
>
(
cx
args
)
;
}
static
bool
PlainTime_equals
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
temporalTime
=
ToPlainTime
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
)
;
PlainTime
other
;
if
(
!
ToTemporalTime
(
cx
args
.
get
(
0
)
&
other
)
)
{
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
temporalTime
=
=
other
)
;
return
true
;
}
static
bool
PlainTime_equals
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_equals
>
(
cx
args
)
;
}
static
bool
PlainTime_toPlainDateTime
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
Rooted
<
PlainDateWithCalendar
>
plainDate
(
cx
)
;
if
(
!
ToTemporalDate
(
cx
args
.
get
(
0
)
&
plainDate
)
)
{
return
false
;
}
auto
date
=
plainDate
.
date
(
)
;
auto
calendar
=
plainDate
.
calendar
(
)
;
auto
*
result
=
CreateTemporalDateTime
(
cx
{
date
time
}
calendar
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
PlainTime_toPlainDateTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_toPlainDateTime
>
(
cx
args
)
;
}
static
bool
PlainTime_toZonedDateTime
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
Rooted
<
JSObject
*
>
itemObj
(
cx
RequireObjectArg
(
cx
"
item
"
"
toZonedDateTime
"
args
.
get
(
0
)
)
)
;
if
(
!
itemObj
)
{
return
false
;
}
Rooted
<
Value
>
temporalDateLike
(
cx
)
;
if
(
!
GetProperty
(
cx
itemObj
args
[
0
]
cx
-
>
names
(
)
.
plainDate
&
temporalDateLike
)
)
{
return
false
;
}
if
(
temporalDateLike
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
"
plainDate
"
)
;
return
false
;
}
Rooted
<
PlainDateWithCalendar
>
plainDate
(
cx
)
;
if
(
!
ToTemporalDate
(
cx
temporalDateLike
&
plainDate
)
)
{
return
false
;
}
auto
date
=
plainDate
.
date
(
)
;
auto
calendar
=
plainDate
.
calendar
(
)
;
Rooted
<
Value
>
temporalTimeZoneLike
(
cx
)
;
if
(
!
GetProperty
(
cx
itemObj
itemObj
cx
-
>
names
(
)
.
timeZone
&
temporalTimeZoneLike
)
)
{
return
false
;
}
if
(
temporalTimeZoneLike
.
isUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_PROPERTY
"
timeZone
"
)
;
return
false
;
}
Rooted
<
TimeZoneValue
>
timeZone
(
cx
)
;
if
(
!
ToTemporalTimeZone
(
cx
temporalTimeZoneLike
&
timeZone
)
)
{
return
false
;
}
Rooted
<
PlainDateTimeWithCalendar
>
temporalDateTime
(
cx
)
;
if
(
!
CreateTemporalDateTime
(
cx
{
date
time
}
calendar
&
temporalDateTime
)
)
{
return
false
;
}
Instant
instant
;
if
(
!
GetInstantFor
(
cx
timeZone
temporalDateTime
TemporalDisambiguation
:
:
Compatible
&
instant
)
)
{
return
false
;
}
auto
*
result
=
CreateTemporalZonedDateTime
(
cx
instant
timeZone
calendar
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
PlainTime_toZonedDateTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_toZonedDateTime
>
(
cx
args
)
;
}
static
bool
PlainTime_getISOFields
(
JSContext
*
cx
const
CallArgs
&
args
)
{
Rooted
<
PlainTimeObject
*
>
temporalTime
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
Rooted
<
IdValueVector
>
fields
(
cx
IdValueVector
(
cx
)
)
;
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoHour
)
Int32Value
(
time
.
hour
)
)
)
{
return
false
;
}
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoMicrosecond
)
Int32Value
(
time
.
microsecond
)
)
)
{
return
false
;
}
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoMillisecond
)
Int32Value
(
time
.
millisecond
)
)
)
{
return
false
;
}
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoMinute
)
Int32Value
(
time
.
minute
)
)
)
{
return
false
;
}
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoNanosecond
)
Int32Value
(
time
.
nanosecond
)
)
)
{
return
false
;
}
if
(
!
fields
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
isoSecond
)
Int32Value
(
time
.
second
)
)
)
{
return
false
;
}
auto
*
obj
=
NewPlainObjectWithUniqueNames
(
cx
fields
.
begin
(
)
fields
.
length
(
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
PlainTime_getISOFields
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_getISOFields
>
(
cx
args
)
;
}
static
bool
PlainTime_toString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
SecondsStringPrecision
precision
=
{
Precision
:
:
Auto
(
)
TemporalUnit
:
:
Nanosecond
Increment
{
1
}
}
;
auto
roundingMode
=
TemporalRoundingMode
:
:
Trunc
;
if
(
args
.
hasDefined
(
0
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
"
toString
"
args
[
0
]
)
)
;
if
(
!
options
)
{
return
false
;
}
auto
digits
=
Precision
:
:
Auto
(
)
;
if
(
!
ToFractionalSecondDigits
(
cx
options
&
digits
)
)
{
return
false
;
}
if
(
!
ToTemporalRoundingMode
(
cx
options
&
roundingMode
)
)
{
return
false
;
}
auto
smallestUnit
=
TemporalUnit
:
:
Auto
;
if
(
!
GetTemporalUnit
(
cx
options
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
Time
&
smallestUnit
)
)
{
return
false
;
}
if
(
smallestUnit
=
=
TemporalUnit
:
:
Hour
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_UNIT_OPTION
"
hour
"
"
smallestUnit
"
)
;
return
false
;
}
precision
=
ToSecondsStringPrecision
(
smallestUnit
digits
)
;
}
auto
roundedTime
=
RoundTime
(
time
precision
.
increment
precision
.
unit
roundingMode
)
;
JSString
*
str
=
TemporalTimeToString
(
cx
roundedTime
.
time
precision
.
precision
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
PlainTime_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_toString
>
(
cx
args
)
;
}
static
bool
PlainTime_toLocaleString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
JSString
*
str
=
TemporalTimeToString
(
cx
time
Precision
:
:
Auto
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
PlainTime_toLocaleString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_toLocaleString
>
(
cx
args
)
;
}
static
bool
PlainTime_toJSON
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
temporalTime
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
PlainTimeObject
>
(
)
;
auto
time
=
ToPlainTime
(
temporalTime
)
;
JSString
*
str
=
TemporalTimeToString
(
cx
time
Precision
:
:
Auto
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
PlainTime_toJSON
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsPlainTime
PlainTime_toJSON
>
(
cx
args
)
;
}
static
bool
PlainTime_valueOf
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_CONVERT_TO
"
PlainTime
"
"
primitive
type
"
)
;
return
false
;
}
const
JSClass
PlainTimeObject
:
:
class_
=
{
"
Temporal
.
PlainTime
"
JSCLASS_HAS_RESERVED_SLOTS
(
PlainTimeObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_PlainTime
)
JS_NULL_CLASS_OPS
&
PlainTimeObject
:
:
classSpec_
}
;
const
JSClass
&
PlainTimeObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
const
JSFunctionSpec
PlainTime_methods
[
]
=
{
JS_FN
(
"
from
"
PlainTime_from
1
0
)
JS_FN
(
"
compare
"
PlainTime_compare
2
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
PlainTime_prototype_methods
[
]
=
{
JS_FN
(
"
add
"
PlainTime_add
1
0
)
JS_FN
(
"
subtract
"
PlainTime_subtract
1
0
)
JS_FN
(
"
with
"
PlainTime_with
1
0
)
JS_FN
(
"
until
"
PlainTime_until
1
0
)
JS_FN
(
"
since
"
PlainTime_since
1
0
)
JS_FN
(
"
round
"
PlainTime_round
1
0
)
JS_FN
(
"
equals
"
PlainTime_equals
1
0
)
JS_FN
(
"
toPlainDateTime
"
PlainTime_toPlainDateTime
1
0
)
JS_FN
(
"
toZonedDateTime
"
PlainTime_toZonedDateTime
1
0
)
JS_FN
(
"
getISOFields
"
PlainTime_getISOFields
0
0
)
JS_FN
(
"
toString
"
PlainTime_toString
0
0
)
JS_FN
(
"
toLocaleString
"
PlainTime_toLocaleString
0
0
)
JS_FN
(
"
toJSON
"
PlainTime_toJSON
0
0
)
JS_FN
(
"
valueOf
"
PlainTime_valueOf
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
PlainTime_prototype_properties
[
]
=
{
JS_PSG
(
"
hour
"
PlainTime_hour
0
)
JS_PSG
(
"
minute
"
PlainTime_minute
0
)
JS_PSG
(
"
second
"
PlainTime_second
0
)
JS_PSG
(
"
millisecond
"
PlainTime_millisecond
0
)
JS_PSG
(
"
microsecond
"
PlainTime_microsecond
0
)
JS_PSG
(
"
nanosecond
"
PlainTime_nanosecond
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Temporal
.
PlainTime
"
JSPROP_READONLY
)
JS_PS_END
}
;
const
ClassSpec
PlainTimeObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
PlainTimeConstructor
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
PlainTimeObject
>
PlainTime_methods
nullptr
PlainTime_prototype_methods
PlainTime_prototype_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
