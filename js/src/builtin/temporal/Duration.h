#
ifndef
builtin_temporal_Duration_h
#
define
builtin_temporal_Duration_h
#
include
<
stdint
.
h
>
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
Wrapped
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
struct
ClassSpec
;
}
namespace
js
:
:
temporal
{
class
DurationObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
constexpr
uint32_t
YEARS_SLOT
=
0
;
static
constexpr
uint32_t
MONTHS_SLOT
=
1
;
static
constexpr
uint32_t
WEEKS_SLOT
=
2
;
static
constexpr
uint32_t
DAYS_SLOT
=
3
;
static
constexpr
uint32_t
HOURS_SLOT
=
4
;
static
constexpr
uint32_t
MINUTES_SLOT
=
5
;
static
constexpr
uint32_t
SECONDS_SLOT
=
6
;
static
constexpr
uint32_t
MILLISECONDS_SLOT
=
7
;
static
constexpr
uint32_t
MICROSECONDS_SLOT
=
8
;
static
constexpr
uint32_t
NANOSECONDS_SLOT
=
9
;
static
constexpr
uint32_t
SLOT_COUNT
=
10
;
double
years
(
)
const
{
return
getFixedSlot
(
YEARS_SLOT
)
.
toNumber
(
)
;
}
double
months
(
)
const
{
return
getFixedSlot
(
MONTHS_SLOT
)
.
toNumber
(
)
;
}
double
weeks
(
)
const
{
return
getFixedSlot
(
WEEKS_SLOT
)
.
toNumber
(
)
;
}
double
days
(
)
const
{
return
getFixedSlot
(
DAYS_SLOT
)
.
toNumber
(
)
;
}
double
hours
(
)
const
{
return
getFixedSlot
(
HOURS_SLOT
)
.
toNumber
(
)
;
}
double
minutes
(
)
const
{
return
getFixedSlot
(
MINUTES_SLOT
)
.
toNumber
(
)
;
}
double
seconds
(
)
const
{
return
getFixedSlot
(
SECONDS_SLOT
)
.
toNumber
(
)
;
}
double
milliseconds
(
)
const
{
return
getFixedSlot
(
MILLISECONDS_SLOT
)
.
toNumber
(
)
;
}
double
microseconds
(
)
const
{
return
getFixedSlot
(
MICROSECONDS_SLOT
)
.
toNumber
(
)
;
}
double
nanoseconds
(
)
const
{
return
getFixedSlot
(
NANOSECONDS_SLOT
)
.
toNumber
(
)
;
}
private
:
static
const
ClassSpec
classSpec_
;
}
;
inline
Duration
ToDuration
(
const
DurationObject
*
duration
)
{
return
{
duration
-
>
years
(
)
duration
-
>
months
(
)
duration
-
>
weeks
(
)
duration
-
>
days
(
)
duration
-
>
hours
(
)
duration
-
>
minutes
(
)
duration
-
>
seconds
(
)
duration
-
>
milliseconds
(
)
duration
-
>
microseconds
(
)
duration
-
>
nanoseconds
(
)
}
;
}
class
Increment
;
class
CalendarRecord
;
class
PlainDateObject
;
class
TimeZoneRecord
;
class
ZonedDateTime
;
class
ZonedDateTimeObject
;
enum
class
TemporalRoundingMode
;
enum
class
TemporalUnit
;
int32_t
DurationSign
(
const
Duration
&
duration
)
;
int32_t
DurationSign
(
const
DateDuration
&
duration
)
;
int32_t
DurationSign
(
const
NormalizedDuration
&
duration
)
;
bool
IsValidDuration
(
const
Duration
&
duration
)
;
#
ifdef
DEBUG
bool
IsValidDuration
(
const
DateDuration
&
duration
)
;
bool
IsValidDuration
(
const
NormalizedDuration
&
duration
)
;
#
endif
bool
ThrowIfInvalidDuration
(
JSContext
*
cx
const
Duration
&
duration
)
;
bool
ThrowIfInvalidDuration
(
JSContext
*
cx
const
DateDuration
&
duration
)
;
inline
bool
IsValidNormalizedTimeDuration
(
const
NormalizedTimeDuration
&
duration
)
{
MOZ_ASSERT
(
0
<
=
duration
.
nanoseconds
&
&
duration
.
nanoseconds
<
=
999
'
999
'
999
)
;
return
NormalizedTimeDuration
:
:
min
(
)
<
=
duration
&
&
duration
<
=
NormalizedTimeDuration
:
:
max
(
)
;
}
NormalizedTimeDuration
NormalizeTimeDuration
(
int32_t
hours
int32_t
minutes
int32_t
seconds
int32_t
milliseconds
int32_t
microseconds
int32_t
nanoseconds
)
;
NormalizedTimeDuration
NormalizeTimeDuration
(
const
Duration
&
duration
)
;
inline
int32_t
CompareNormalizedTimeDuration
(
const
NormalizedTimeDuration
&
one
const
NormalizedTimeDuration
&
two
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
one
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
two
)
)
;
if
(
one
>
two
)
{
return
1
;
}
if
(
one
<
two
)
{
return
-
1
;
}
return
0
;
}
inline
int32_t
NormalizedTimeDurationSign
(
const
NormalizedTimeDuration
&
d
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
d
)
)
;
return
CompareNormalizedTimeDuration
(
d
NormalizedTimeDuration
{
}
)
;
}
bool
Add24HourDaysToNormalizedTimeDuration
(
JSContext
*
cx
const
NormalizedTimeDuration
&
d
int64_t
days
NormalizedTimeDuration
*
result
)
;
inline
NormalizedDuration
CreateNormalizedDurationRecord
(
const
DateDuration
&
date
const
NormalizedTimeDuration
&
time
)
{
MOZ_ASSERT
(
IsValidDuration
(
date
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
time
)
)
;
#
ifdef
DEBUG
int64_t
dateValues
=
date
.
years
|
date
.
months
|
date
.
weeks
|
date
.
days
;
int32_t
dateSign
=
dateValues
?
dateValues
<
0
?
-
1
:
1
:
0
;
int32_t
timeSign
=
NormalizedTimeDurationSign
(
time
)
;
MOZ_ASSERT
(
(
dateSign
*
timeSign
)
>
=
0
)
;
#
endif
return
{
date
time
}
;
}
inline
NormalizedDuration
CreateNormalizedDurationRecord
(
const
Duration
&
duration
)
{
return
CreateNormalizedDurationRecord
(
duration
.
toDateDuration
(
)
NormalizeTimeDuration
(
duration
)
)
;
}
bool
CombineDateAndNormalizedTimeDuration
(
JSContext
*
cx
const
DateDuration
&
date
const
NormalizedTimeDuration
&
time
NormalizedDuration
*
result
)
;
inline
bool
CreateNormalizedDurationRecord
(
JSContext
*
cx
const
DateDuration
&
date
const
NormalizedTimeDuration
&
time
NormalizedDuration
*
result
)
{
return
CombineDateAndNormalizedTimeDuration
(
cx
date
time
result
)
;
}
NormalizedTimeDuration
NormalizedTimeDurationFromEpochNanosecondsDifference
(
const
Instant
&
one
const
Instant
&
two
)
;
DurationObject
*
CreateTemporalDuration
(
JSContext
*
cx
const
Duration
&
duration
)
;
Wrapped
<
DurationObject
*
>
ToTemporalDuration
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
item
)
;
bool
ToTemporalDuration
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
item
Duration
*
result
)
;
bool
ToTemporalDurationRecord
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
temporalDurationLike
Duration
*
result
)
;
TimeDuration
BalanceTimeDuration
(
const
NormalizedTimeDuration
&
duration
TemporalUnit
largestUnit
)
;
bool
BalanceTimeDuration
(
JSContext
*
cx
const
NormalizedTimeDuration
&
duration
TemporalUnit
largestUnit
TimeDuration
*
result
)
;
NormalizedTimeDuration
RoundTimeDuration
(
const
NormalizedTimeDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
)
;
struct
RoundedRelativeDuration
{
Duration
duration
;
double
total
=
0
;
}
;
bool
RoundRelativeDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
const
Instant
&
destEpochNs
const
PlainDateTime
&
dateTime
JS
:
:
Handle
<
CalendarRecord
>
calendar
JS
:
:
Handle
<
TimeZoneRecord
>
timeZone
TemporalUnit
largestUnit
Increment
increment
TemporalUnit
smallestUnit
TemporalRoundingMode
roundingMode
RoundedRelativeDuration
*
result
)
;
double
DivideNormalizedTimeDuration
(
const
NormalizedTimeDuration
&
duration
TemporalUnit
unit
)
;
int32_t
DaysUntil
(
const
PlainDate
&
earlier
const
PlainDate
&
later
)
;
}
#
endif
