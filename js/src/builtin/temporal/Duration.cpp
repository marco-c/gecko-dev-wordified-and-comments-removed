#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
initializer_list
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
include
"
builtin
/
temporal
/
Int128
.
h
"
#
include
"
builtin
/
temporal
/
Int96
.
h
"
#
include
"
builtin
/
temporal
/
PlainDate
.
h
"
#
include
"
builtin
/
temporal
/
PlainDateTime
.
h
"
#
include
"
builtin
/
temporal
/
Temporal
.
h
"
#
include
"
builtin
/
temporal
/
TemporalFields
.
h
"
#
include
"
builtin
/
temporal
/
TemporalParser
.
h
"
#
include
"
builtin
/
temporal
/
TemporalRoundingMode
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
builtin
/
temporal
/
Wrapped
.
h
"
#
include
"
builtin
/
temporal
/
ZonedDateTime
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
CallNonGenericMethod
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
static
inline
bool
IsDuration
(
Handle
<
Value
>
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
DurationObject
>
(
)
;
}
#
ifdef
DEBUG
static
bool
IsIntegerOrInfinity
(
double
d
)
{
return
IsInteger
(
d
)
|
|
std
:
:
isinf
(
d
)
;
}
static
bool
IsIntegerOrInfinityDuration
(
const
Duration
&
duration
)
{
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
return
IsIntegerOrInfinity
(
years
)
&
&
IsIntegerOrInfinity
(
months
)
&
&
IsIntegerOrInfinity
(
weeks
)
&
&
IsIntegerOrInfinity
(
days
)
&
&
IsIntegerOrInfinity
(
hours
)
&
&
IsIntegerOrInfinity
(
minutes
)
&
&
IsIntegerOrInfinity
(
seconds
)
&
&
IsIntegerOrInfinity
(
milliseconds
)
&
&
IsIntegerOrInfinity
(
microseconds
)
&
&
IsIntegerOrInfinity
(
nanoseconds
)
;
}
static
bool
IsIntegerDuration
(
const
Duration
&
duration
)
{
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
return
IsInteger
(
years
)
&
&
IsInteger
(
months
)
&
&
IsInteger
(
weeks
)
&
&
IsInteger
(
days
)
&
&
IsInteger
(
hours
)
&
&
IsInteger
(
minutes
)
&
&
IsInteger
(
seconds
)
&
&
IsInteger
(
milliseconds
)
&
&
IsInteger
(
microseconds
)
&
&
IsInteger
(
nanoseconds
)
;
}
#
endif
int32_t
js
:
:
temporal
:
:
DurationSign
(
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsIntegerOrInfinityDuration
(
duration
)
)
;
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
for
(
auto
v
:
{
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
)
{
if
(
v
<
0
)
{
return
-
1
;
}
if
(
v
>
0
)
{
return
1
;
}
}
return
0
;
}
static
NormalizedTimeDuration
NormalizeNanoseconds
(
const
Int96
&
nanoseconds
)
{
auto
[
seconds
nanos
]
=
nanoseconds
/
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
return
{
seconds
nanos
}
;
}
static
mozilla
:
:
Maybe
<
NormalizedTimeDuration
>
NormalizeNanoseconds
(
double
nanoseconds
)
{
MOZ_ASSERT
(
IsInteger
(
nanoseconds
)
)
;
if
(
auto
int96
=
Int96
:
:
fromInteger
(
nanoseconds
)
)
{
constexpr
auto
limit
=
Int96
{
uint64_t
(
1
)
<
<
53
}
*
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
if
(
int96
-
>
abs
(
)
<
limit
)
{
return
mozilla
:
:
Some
(
NormalizeNanoseconds
(
*
int96
)
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
NormalizedTimeDuration
NormalizeMicroseconds
(
const
Int96
&
microseconds
)
{
auto
[
seconds
micros
]
=
microseconds
/
ToMicroseconds
(
TemporalUnit
:
:
Second
)
;
int32_t
nanos
=
micros
*
ToNanoseconds
(
TemporalUnit
:
:
Microsecond
)
;
return
{
seconds
nanos
}
;
}
static
mozilla
:
:
Maybe
<
NormalizedTimeDuration
>
NormalizeMicroseconds
(
double
microseconds
)
{
MOZ_ASSERT
(
IsInteger
(
microseconds
)
)
;
if
(
auto
int96
=
Int96
:
:
fromInteger
(
microseconds
)
)
{
constexpr
auto
limit
=
Int96
{
uint64_t
(
1
)
<
<
53
}
*
ToMicroseconds
(
TemporalUnit
:
:
Second
)
;
if
(
int96
-
>
abs
(
)
<
limit
)
{
return
mozilla
:
:
Some
(
NormalizeMicroseconds
(
*
int96
)
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
static
mozilla
:
:
Maybe
<
NormalizedTimeDuration
>
NormalizeSeconds
(
const
Duration
&
duration
)
{
do
{
auto
nanoseconds
=
NormalizeNanoseconds
(
duration
.
nanoseconds
)
;
if
(
!
nanoseconds
)
{
break
;
}
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
*
nanoseconds
)
)
;
auto
microseconds
=
NormalizeMicroseconds
(
duration
.
microseconds
)
;
if
(
!
microseconds
)
{
break
;
}
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
*
microseconds
)
)
;
int64_t
milliseconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
milliseconds
&
milliseconds
)
)
{
break
;
}
int64_t
seconds
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
seconds
&
seconds
)
)
{
break
;
}
int64_t
minutes
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
minutes
&
minutes
)
)
{
break
;
}
int64_t
hours
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
hours
&
hours
)
)
{
break
;
}
int64_t
days
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
duration
.
days
&
days
)
)
{
break
;
}
mozilla
:
:
CheckedInt64
millis
=
days
;
millis
*
=
24
;
millis
+
=
hours
;
millis
*
=
60
;
millis
+
=
minutes
;
millis
*
=
60
;
millis
+
=
seconds
;
millis
*
=
1000
;
millis
+
=
milliseconds
;
if
(
!
millis
.
isValid
(
)
)
{
break
;
}
auto
milli
=
NormalizedTimeDuration
:
:
fromMilliseconds
(
millis
.
value
(
)
)
;
if
(
!
IsValidNormalizedTimeDuration
(
milli
)
)
{
break
;
}
auto
result
=
milli
+
*
microseconds
+
*
nanoseconds
;
if
(
!
IsValidNormalizedTimeDuration
(
result
)
)
{
break
;
}
return
mozilla
:
:
Some
(
result
)
;
}
while
(
false
)
;
return
mozilla
:
:
Nothing
(
)
;
}
static
mozilla
:
:
Maybe
<
NormalizedTimeDuration
>
NormalizeDays
(
double
days
)
{
MOZ_ASSERT
(
IsInteger
(
days
)
)
;
do
{
int64_t
intDays
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
days
&
intDays
)
)
{
break
;
}
auto
millis
=
mozilla
:
:
CheckedInt64
(
intDays
)
*
ToMilliseconds
(
TemporalUnit
:
:
Day
)
;
if
(
!
millis
.
isValid
(
)
)
{
break
;
}
auto
result
=
NormalizedTimeDuration
:
:
fromMilliseconds
(
millis
.
value
(
)
)
;
if
(
!
IsValidNormalizedTimeDuration
(
result
)
)
{
break
;
}
return
mozilla
:
:
Some
(
result
)
;
}
while
(
false
)
;
return
mozilla
:
:
Nothing
(
)
;
}
static
NormalizedTimeDuration
NormalizeTimeDuration
(
double
hours
double
minutes
double
seconds
double
milliseconds
double
microseconds
double
nanoseconds
)
{
MOZ_ASSERT
(
IsInteger
(
hours
)
)
;
MOZ_ASSERT
(
IsInteger
(
minutes
)
)
;
MOZ_ASSERT
(
IsInteger
(
seconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
milliseconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
microseconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanoseconds
)
)
;
mozilla
:
:
CheckedInt64
millis
=
int64_t
(
hours
)
;
millis
*
=
60
;
millis
+
=
int64_t
(
minutes
)
;
millis
*
=
60
;
millis
+
=
int64_t
(
seconds
)
;
millis
*
=
1000
;
millis
+
=
int64_t
(
milliseconds
)
;
MOZ_ASSERT
(
millis
.
isValid
(
)
)
;
auto
normalized
=
NormalizedTimeDuration
:
:
fromMilliseconds
(
millis
.
value
(
)
)
;
auto
micros
=
Int96
:
:
fromInteger
(
microseconds
)
;
MOZ_ASSERT
(
micros
)
;
normalized
+
=
NormalizeMicroseconds
(
*
micros
)
;
auto
nanos
=
Int96
:
:
fromInteger
(
nanoseconds
)
;
MOZ_ASSERT
(
nanos
)
;
normalized
+
=
NormalizeNanoseconds
(
*
nanos
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
normalized
)
)
;
return
normalized
;
}
NormalizedTimeDuration
js
:
:
temporal
:
:
NormalizeTimeDuration
(
int32_t
hours
int32_t
minutes
int32_t
seconds
int32_t
milliseconds
int32_t
microseconds
int32_t
nanoseconds
)
{
mozilla
:
:
CheckedInt64
millis
=
int64_t
(
hours
)
;
millis
*
=
60
;
millis
+
=
int64_t
(
minutes
)
;
millis
*
=
60
;
millis
+
=
int64_t
(
seconds
)
;
millis
*
=
1000
;
millis
+
=
int64_t
(
milliseconds
)
;
MOZ_ASSERT
(
millis
.
isValid
(
)
)
;
auto
normalized
=
NormalizedTimeDuration
:
:
fromMilliseconds
(
millis
.
value
(
)
)
;
normalized
+
=
NormalizeMicroseconds
(
Int96
{
microseconds
}
)
;
normalized
+
=
NormalizeNanoseconds
(
Int96
{
nanoseconds
}
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
normalized
)
)
;
return
normalized
;
}
NormalizedTimeDuration
js
:
:
temporal
:
:
NormalizeTimeDuration
(
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
return
:
:
NormalizeTimeDuration
(
duration
.
hours
duration
.
minutes
duration
.
seconds
duration
.
milliseconds
duration
.
microseconds
duration
.
nanoseconds
)
;
}
static
bool
AddNormalizedTimeDuration
(
JSContext
*
cx
const
NormalizedTimeDuration
&
one
const
NormalizedTimeDuration
&
two
NormalizedTimeDuration
*
result
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
one
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
two
)
)
;
auto
sum
=
one
+
two
;
if
(
!
IsValidNormalizedTimeDuration
(
sum
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
*
result
=
sum
;
return
true
;
}
static
bool
SubtractNormalizedTimeDuration
(
JSContext
*
cx
const
NormalizedTimeDuration
&
one
const
NormalizedTimeDuration
&
two
NormalizedTimeDuration
*
result
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
one
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
two
)
)
;
auto
sum
=
one
-
two
;
if
(
!
IsValidNormalizedTimeDuration
(
sum
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
*
result
=
sum
;
return
true
;
}
bool
js
:
:
temporal
:
:
Add24HourDaysToNormalizedTimeDuration
(
JSContext
*
cx
const
NormalizedTimeDuration
&
d
double
days
NormalizedTimeDuration
*
result
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
d
)
)
;
MOZ_ASSERT
(
IsInteger
(
days
)
)
;
auto
normalizedDays
=
NormalizeDays
(
days
)
;
if
(
!
normalizedDays
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
auto
sum
=
d
+
*
normalizedDays
;
if
(
!
IsValidNormalizedTimeDuration
(
sum
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
*
result
=
sum
;
return
true
;
}
bool
js
:
:
temporal
:
:
CombineDateAndNormalizedTimeDuration
(
JSContext
*
cx
const
DateDuration
&
date
const
NormalizedTimeDuration
&
time
NormalizedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
date
.
toDuration
(
)
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
time
)
)
;
int32_t
dateSign
=
:
:
DurationSign
(
date
.
toDuration
(
)
)
;
int32_t
timeSign
=
NormalizedTimeDurationSign
(
time
)
;
if
(
(
dateSign
*
timeSign
)
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_COMBINE_INVALID_SIGN
)
;
return
false
;
}
*
result
=
{
date
time
}
;
return
true
;
}
NormalizedTimeDuration
js
:
:
temporal
:
:
NormalizedTimeDurationFromEpochNanosecondsDifference
(
const
Instant
&
one
const
Instant
&
two
)
{
MOZ_ASSERT
(
IsValidEpochInstant
(
one
)
)
;
MOZ_ASSERT
(
IsValidEpochInstant
(
two
)
)
;
auto
result
=
one
-
two
;
MOZ_ASSERT
(
IsValidInstantSpan
(
result
)
)
;
return
{
result
.
seconds
result
.
nanoseconds
}
;
}
bool
js
:
:
temporal
:
:
IsValidDuration
(
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsIntegerOrInfinityDuration
(
duration
)
)
;
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
int32_t
sign
=
DurationSign
(
duration
)
;
for
(
auto
v
:
{
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
)
{
if
(
!
std
:
:
isfinite
(
v
)
)
{
return
false
;
}
if
(
v
<
0
&
&
sign
>
0
)
{
return
false
;
}
if
(
v
>
0
&
&
sign
<
0
)
{
return
false
;
}
}
if
(
!
NormalizeSeconds
(
duration
)
)
{
return
false
;
}
return
true
;
}
#
ifdef
DEBUG
bool
js
:
:
temporal
:
:
IsValidDuration
(
const
NormalizedDuration
&
duration
)
{
auto
date
=
duration
.
date
.
toDuration
(
)
;
return
IsValidDuration
(
date
)
&
&
IsValidNormalizedTimeDuration
(
duration
.
time
)
&
&
(
DurationSign
(
date
)
*
NormalizedTimeDurationSign
(
duration
.
time
)
>
=
0
)
;
}
#
endif
bool
js
:
:
temporal
:
:
ThrowIfInvalidDuration
(
JSContext
*
cx
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsIntegerOrInfinityDuration
(
duration
)
)
;
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
int32_t
sign
=
DurationSign
(
duration
)
;
auto
report
=
[
&
]
(
double
v
const
char
*
name
unsigned
errorNumber
)
{
ToCStringBuf
cbuf
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
v
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
errorNumber
name
numStr
)
;
}
;
auto
throwIfInvalid
=
[
&
]
(
double
v
const
char
*
name
)
{
if
(
!
std
:
:
isfinite
(
v
)
)
{
report
(
v
name
JSMSG_TEMPORAL_DURATION_INVALID_NON_FINITE
)
;
return
false
;
}
if
(
(
v
<
0
&
&
sign
>
0
)
|
|
(
v
>
0
&
&
sign
<
0
)
)
{
report
(
v
name
JSMSG_TEMPORAL_DURATION_INVALID_SIGN
)
;
return
false
;
}
return
true
;
}
;
if
(
!
throwIfInvalid
(
years
"
years
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
months
"
months
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
weeks
"
weeks
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
days
"
days
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
hours
"
hours
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
minutes
"
minutes
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
seconds
"
seconds
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
milliseconds
"
milliseconds
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
microseconds
"
microseconds
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
nanoseconds
"
nanoseconds
"
)
)
{
return
false
;
}
if
(
!
NormalizeSeconds
(
duration
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
return
true
;
}
static
bool
ThrowIfInvalidDuration
(
JSContext
*
cx
const
DateDuration
&
duration
)
{
MOZ_ASSERT
(
IsIntegerOrInfinityDuration
(
duration
.
toDuration
(
)
)
)
;
auto
&
[
years
months
weeks
days
]
=
duration
;
int32_t
sign
=
DurationSign
(
duration
.
toDuration
(
)
)
;
auto
report
=
[
&
]
(
double
v
const
char
*
name
unsigned
errorNumber
)
{
ToCStringBuf
cbuf
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
v
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
errorNumber
name
numStr
)
;
}
;
auto
throwIfInvalid
=
[
&
]
(
double
v
const
char
*
name
)
{
if
(
!
std
:
:
isfinite
(
v
)
)
{
report
(
v
name
JSMSG_TEMPORAL_DURATION_INVALID_NON_FINITE
)
;
return
false
;
}
if
(
(
v
<
0
&
&
sign
>
0
)
|
|
(
v
>
0
&
&
sign
<
0
)
)
{
report
(
v
name
JSMSG_TEMPORAL_DURATION_INVALID_SIGN
)
;
return
false
;
}
return
true
;
}
;
if
(
!
throwIfInvalid
(
years
"
years
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
months
"
months
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
weeks
"
weeks
"
)
)
{
return
false
;
}
if
(
!
throwIfInvalid
(
days
"
days
"
)
)
{
return
false
;
}
if
(
std
:
:
abs
(
days
)
>
(
(
int64_t
(
1
)
<
<
53
)
/
86400
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME
)
;
return
false
;
}
MOZ_ASSERT
(
IsValidDuration
(
duration
.
toDuration
(
)
)
)
;
return
true
;
}
static
TemporalUnit
DefaultTemporalLargestUnit
(
const
Duration
&
duration
)
{
MOZ_ASSERT
(
IsIntegerDuration
(
duration
)
)
;
if
(
duration
.
years
!
=
0
)
{
return
TemporalUnit
:
:
Year
;
}
if
(
duration
.
months
!
=
0
)
{
return
TemporalUnit
:
:
Month
;
}
if
(
duration
.
weeks
!
=
0
)
{
return
TemporalUnit
:
:
Week
;
}
if
(
duration
.
days
!
=
0
)
{
return
TemporalUnit
:
:
Day
;
}
if
(
duration
.
hours
!
=
0
)
{
return
TemporalUnit
:
:
Hour
;
}
if
(
duration
.
minutes
!
=
0
)
{
return
TemporalUnit
:
:
Minute
;
}
if
(
duration
.
seconds
!
=
0
)
{
return
TemporalUnit
:
:
Second
;
}
if
(
duration
.
milliseconds
!
=
0
)
{
return
TemporalUnit
:
:
Millisecond
;
}
if
(
duration
.
microseconds
!
=
0
)
{
return
TemporalUnit
:
:
Microsecond
;
}
return
TemporalUnit
:
:
Nanosecond
;
}
static
DurationObject
*
CreateTemporalDuration
(
JSContext
*
cx
const
CallArgs
&
args
const
Duration
&
duration
)
{
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
if
(
!
ThrowIfInvalidDuration
(
cx
duration
)
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Duration
&
proto
)
)
{
return
nullptr
;
}
auto
*
object
=
NewObjectWithClassProto
<
DurationObject
>
(
cx
proto
)
;
if
(
!
object
)
{
return
nullptr
;
}
object
-
>
setFixedSlot
(
DurationObject
:
:
YEARS_SLOT
NumberValue
(
years
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MONTHS_SLOT
NumberValue
(
months
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
WEEKS_SLOT
NumberValue
(
weeks
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
DAYS_SLOT
NumberValue
(
days
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
HOURS_SLOT
NumberValue
(
hours
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MINUTES_SLOT
NumberValue
(
minutes
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
SECONDS_SLOT
NumberValue
(
seconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MILLISECONDS_SLOT
NumberValue
(
milliseconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MICROSECONDS_SLOT
NumberValue
(
microseconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
NANOSECONDS_SLOT
NumberValue
(
nanoseconds
+
(
+
0
.
0
)
)
)
;
return
object
;
}
DurationObject
*
js
:
:
temporal
:
:
CreateTemporalDuration
(
JSContext
*
cx
const
Duration
&
duration
)
{
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
duration
;
MOZ_ASSERT
(
IsInteger
(
years
)
)
;
MOZ_ASSERT
(
IsInteger
(
months
)
)
;
MOZ_ASSERT
(
IsInteger
(
weeks
)
)
;
MOZ_ASSERT
(
IsInteger
(
days
)
)
;
MOZ_ASSERT
(
IsInteger
(
hours
)
)
;
MOZ_ASSERT
(
IsInteger
(
minutes
)
)
;
MOZ_ASSERT
(
IsInteger
(
seconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
milliseconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
microseconds
)
)
;
MOZ_ASSERT
(
IsInteger
(
nanoseconds
)
)
;
if
(
!
ThrowIfInvalidDuration
(
cx
duration
)
)
{
return
nullptr
;
}
auto
*
object
=
NewBuiltinClassInstance
<
DurationObject
>
(
cx
)
;
if
(
!
object
)
{
return
nullptr
;
}
object
-
>
setFixedSlot
(
DurationObject
:
:
YEARS_SLOT
NumberValue
(
years
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MONTHS_SLOT
NumberValue
(
months
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
WEEKS_SLOT
NumberValue
(
weeks
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
DAYS_SLOT
NumberValue
(
days
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
HOURS_SLOT
NumberValue
(
hours
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MINUTES_SLOT
NumberValue
(
minutes
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
SECONDS_SLOT
NumberValue
(
seconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MILLISECONDS_SLOT
NumberValue
(
milliseconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
MICROSECONDS_SLOT
NumberValue
(
microseconds
+
(
+
0
.
0
)
)
)
;
object
-
>
setFixedSlot
(
DurationObject
:
:
NANOSECONDS_SLOT
NumberValue
(
nanoseconds
+
(
+
0
.
0
)
)
)
;
return
object
;
}
static
bool
ToIntegerIfIntegral
(
JSContext
*
cx
const
char
*
name
Handle
<
Value
>
argument
double
*
num
)
{
double
d
;
if
(
!
JS
:
:
ToNumber
(
cx
argument
&
d
)
)
{
return
false
;
}
if
(
!
js
:
:
IsInteger
(
d
)
)
{
ToCStringBuf
cbuf
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
d
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_NOT_INTEGER
numStr
name
)
;
return
false
;
}
*
num
=
d
;
return
true
;
}
static
bool
ToIntegerIfIntegral
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
Handle
<
Value
>
argument
double
*
result
)
{
double
d
;
if
(
!
JS
:
:
ToNumber
(
cx
argument
&
d
)
)
{
return
false
;
}
if
(
!
js
:
:
IsInteger
(
d
)
)
{
if
(
auto
nameStr
=
js
:
:
QuoteString
(
cx
name
)
)
{
ToCStringBuf
cbuf
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
d
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_NOT_INTEGER
numStr
nameStr
.
get
(
)
)
;
}
return
false
;
}
*
result
=
d
;
return
true
;
}
static
bool
ToTemporalPartialDurationRecord
(
JSContext
*
cx
Handle
<
JSObject
*
>
temporalDurationLike
Duration
*
result
)
{
Rooted
<
Value
>
value
(
cx
)
;
bool
any
=
false
;
auto
getDurationProperty
=
[
&
]
(
Handle
<
PropertyName
*
>
name
double
*
num
)
{
if
(
!
GetProperty
(
cx
temporalDurationLike
temporalDurationLike
name
&
value
)
)
{
return
false
;
}
if
(
!
value
.
isUndefined
(
)
)
{
any
=
true
;
if
(
!
ToIntegerIfIntegral
(
cx
name
value
num
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
days
&
result
-
>
days
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
hours
&
result
-
>
hours
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
microseconds
&
result
-
>
microseconds
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
milliseconds
&
result
-
>
milliseconds
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
minutes
&
result
-
>
minutes
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
months
&
result
-
>
months
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
nanoseconds
&
result
-
>
nanoseconds
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
seconds
&
result
-
>
seconds
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
weeks
&
result
-
>
weeks
)
)
{
return
false
;
}
if
(
!
getDurationProperty
(
cx
-
>
names
(
)
.
years
&
result
-
>
years
)
)
{
return
false
;
}
if
(
!
any
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_MISSING_UNIT
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
temporal
:
:
ToTemporalDurationRecord
(
JSContext
*
cx
Handle
<
Value
>
temporalDurationLike
Duration
*
result
)
{
if
(
!
temporalDurationLike
.
isObject
(
)
)
{
if
(
!
temporalDurationLike
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
temporalDurationLike
nullptr
"
not
a
string
"
)
;
return
false
;
}
Rooted
<
JSString
*
>
string
(
cx
temporalDurationLike
.
toString
(
)
)
;
return
ParseTemporalDurationString
(
cx
string
result
)
;
}
Rooted
<
JSObject
*
>
durationLike
(
cx
&
temporalDurationLike
.
toObject
(
)
)
;
if
(
auto
*
duration
=
durationLike
-
>
maybeUnwrapIf
<
DurationObject
>
(
)
)
{
*
result
=
ToDuration
(
duration
)
;
return
true
;
}
Duration
duration
=
{
}
;
if
(
!
ToTemporalPartialDurationRecord
(
cx
durationLike
&
duration
)
)
{
return
false
;
}
if
(
!
ThrowIfInvalidDuration
(
cx
duration
)
)
{
return
false
;
}
*
result
=
duration
;
return
true
;
}
Wrapped
<
DurationObject
*
>
js
:
:
temporal
:
:
ToTemporalDuration
(
JSContext
*
cx
Handle
<
Value
>
item
)
{
if
(
item
.
isObject
(
)
)
{
JSObject
*
itemObj
=
&
item
.
toObject
(
)
;
if
(
itemObj
-
>
canUnwrapAs
<
DurationObject
>
(
)
)
{
return
itemObj
;
}
}
Duration
result
;
if
(
!
ToTemporalDurationRecord
(
cx
item
&
result
)
)
{
return
nullptr
;
}
return
CreateTemporalDuration
(
cx
result
)
;
}
bool
js
:
:
temporal
:
:
ToTemporalDuration
(
JSContext
*
cx
Handle
<
Value
>
item
Duration
*
result
)
{
auto
obj
=
ToTemporalDuration
(
cx
item
)
;
if
(
!
obj
)
{
return
false
;
}
*
result
=
ToDuration
(
&
obj
.
unwrap
(
)
)
;
return
true
;
}
int32_t
js
:
:
temporal
:
:
DaysUntil
(
const
PlainDate
&
earlier
const
PlainDate
&
later
)
{
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
earlier
)
)
;
MOZ_ASSERT
(
ISODateTimeWithinLimits
(
later
)
)
;
int32_t
epochDaysEarlier
=
MakeDay
(
earlier
)
;
MOZ_ASSERT
(
std
:
:
abs
(
epochDaysEarlier
)
<
=
100
'
000
'
000
)
;
int32_t
epochDaysLater
=
MakeDay
(
later
)
;
MOZ_ASSERT
(
std
:
:
abs
(
epochDaysLater
)
<
=
100
'
000
'
000
)
;
return
epochDaysLater
-
epochDaysEarlier
;
}
static
bool
MoveRelativeDate
(
JSContext
*
cx
Handle
<
CalendarRecord
>
calendar
Handle
<
Wrapped
<
PlainDateObject
*
>
>
relativeTo
const
Duration
&
duration
MutableHandle
<
Wrapped
<
PlainDateObject
*
>
>
relativeToResult
int32_t
*
daysResult
)
{
auto
*
unwrappedRelativeTo
=
relativeTo
.
unwrap
(
cx
)
;
if
(
!
unwrappedRelativeTo
)
{
return
false
;
}
auto
relativeToDate
=
ToPlainDate
(
unwrappedRelativeTo
)
;
auto
newDate
=
AddDate
(
cx
calendar
relativeTo
duration
)
;
if
(
!
newDate
)
{
return
false
;
}
auto
later
=
ToPlainDate
(
&
newDate
.
unwrap
(
)
)
;
relativeToResult
.
set
(
newDate
)
;
*
daysResult
=
DaysUntil
(
relativeToDate
later
)
;
MOZ_ASSERT
(
std
:
:
abs
(
*
daysResult
)
<
=
200
'
000
'
000
)
;
return
true
;
}
static
bool
MoveRelativeZonedDateTime
(
JSContext
*
cx
Handle
<
ZonedDateTime
>
zonedDateTime
Handle
<
CalendarRecord
>
calendar
Handle
<
TimeZoneRecord
>
timeZone
const
DateDuration
&
duration
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
MutableHandle
<
ZonedDateTime
>
result
)
{
MOZ_ASSERT
(
TimeZoneMethodsRecordHasLookedUp
(
timeZone
TimeZoneMethod
:
:
GetOffsetNanosecondsFor
)
)
;
MOZ_ASSERT
(
TimeZoneMethodsRecordHasLookedUp
(
timeZone
TimeZoneMethod
:
:
GetPossibleInstantsFor
)
)
;
Instant
intermediateNs
;
if
(
precalculatedPlainDateTime
)
{
if
(
!
AddZonedDateTime
(
cx
zonedDateTime
.
instant
(
)
timeZone
calendar
duration
*
precalculatedPlainDateTime
&
intermediateNs
)
)
{
return
false
;
}
}
else
{
if
(
!
AddZonedDateTime
(
cx
zonedDateTime
.
instant
(
)
timeZone
calendar
duration
&
intermediateNs
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
IsValidEpochInstant
(
intermediateNs
)
)
;
result
.
set
(
ZonedDateTime
{
intermediateNs
zonedDateTime
.
timeZone
(
)
zonedDateTime
.
calendar
(
)
}
)
;
return
true
;
}
static
NormalizedTimeAndDays
NormalizedTimeDurationToDays
(
const
NormalizedTimeDuration
&
duration
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
)
)
;
auto
[
seconds
nanoseconds
]
=
duration
;
if
(
seconds
<
0
&
&
nanoseconds
>
0
)
{
seconds
+
=
1
;
nanoseconds
-
=
1
'
000
'
000
'
000
;
}
int64_t
days
=
seconds
/
ToSeconds
(
TemporalUnit
:
:
Day
)
;
seconds
=
seconds
%
ToSeconds
(
TemporalUnit
:
:
Day
)
;
auto
time
=
NormalizedTimeDuration
:
:
fromSeconds
(
seconds
)
+
NormalizedTimeDuration
:
:
fromNanoseconds
(
nanoseconds
)
;
constexpr
auto
dayLength
=
NormalizedTimeDuration
:
:
fromNanoseconds
(
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
MOZ_ASSERT
(
time
.
abs
(
)
<
dayLength
)
;
return
{
days
time
dayLength
}
;
}
static
TimeDuration
CreateTimeDurationRecord
(
int64_t
days
int64_t
hours
int64_t
minutes
int64_t
seconds
int64_t
milliseconds
int64_t
microseconds
int64_t
nanoseconds
)
{
MOZ_ASSERT
(
IsValidDuration
(
{
0
0
0
double
(
days
)
double
(
hours
)
double
(
minutes
)
double
(
seconds
)
double
(
milliseconds
)
double
(
microseconds
)
double
(
nanoseconds
)
}
)
)
;
return
{
double
(
days
)
double
(
hours
)
double
(
minutes
)
double
(
seconds
)
double
(
milliseconds
)
double
(
microseconds
)
double
(
nanoseconds
)
}
;
}
static
TimeDuration
CreateTimeDurationRecord
(
double
days
double
hours
double
minutes
double
seconds
double
milliseconds
double
microseconds
double
nanoseconds
)
{
MOZ_ASSERT
(
IsValidDuration
(
{
0
0
0
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
)
)
;
return
{
days
+
(
+
0
.
0
)
hours
+
(
+
0
.
0
)
minutes
+
(
+
0
.
0
)
seconds
+
(
+
0
.
0
)
milliseconds
+
(
+
0
.
0
)
microseconds
+
(
+
0
.
0
)
nanoseconds
+
(
+
0
.
0
)
}
;
}
TimeDuration
js
:
:
temporal
:
:
BalanceTimeDuration
(
const
NormalizedTimeDuration
&
duration
TemporalUnit
largestUnit
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
)
)
;
auto
[
seconds
nanoseconds
]
=
duration
;
if
(
seconds
<
0
&
&
nanoseconds
>
0
)
{
seconds
+
=
1
;
nanoseconds
-
=
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
}
int64_t
days
=
0
;
int64_t
hours
=
0
;
int64_t
minutes
=
0
;
int64_t
milliseconds
=
0
;
int64_t
microseconds
=
0
;
switch
(
largestUnit
)
{
case
TemporalUnit
:
:
Year
:
case
TemporalUnit
:
:
Month
:
case
TemporalUnit
:
:
Week
:
case
TemporalUnit
:
:
Day
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
minutes
=
seconds
/
60
;
seconds
=
seconds
%
60
;
hours
=
minutes
/
60
;
minutes
=
minutes
%
60
;
days
=
hours
/
24
;
hours
=
hours
%
24
;
break
;
}
case
TemporalUnit
:
:
Hour
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
minutes
=
seconds
/
60
;
seconds
=
seconds
%
60
;
hours
=
minutes
/
60
;
minutes
=
minutes
%
60
;
break
;
}
case
TemporalUnit
:
:
Minute
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
minutes
=
seconds
/
60
;
seconds
=
seconds
%
60
;
break
;
}
case
TemporalUnit
:
:
Second
:
{
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
break
;
}
case
TemporalUnit
:
:
Millisecond
:
{
static_assert
(
(
NormalizedTimeDuration
:
:
max
(
)
.
seconds
+
1
)
*
ToMilliseconds
(
TemporalUnit
:
:
Second
)
<
=
INT64_MAX
"
total
number
duration
milliseconds
fits
into
int64
"
)
;
int64_t
millis
=
seconds
*
ToMilliseconds
(
TemporalUnit
:
:
Second
)
;
seconds
=
0
;
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
milliseconds
=
microseconds
/
1000
;
microseconds
=
microseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
milliseconds
)
<
=
999
)
;
milliseconds
+
=
millis
;
break
;
}
case
TemporalUnit
:
:
Microsecond
:
{
int64_t
microseconds
=
nanoseconds
/
1000
;
nanoseconds
=
nanoseconds
%
1000
;
MOZ_ASSERT
(
std
:
:
abs
(
microseconds
)
<
=
999
'
999
)
;
double
micros
=
std
:
:
fma
(
double
(
seconds
)
ToMicroseconds
(
TemporalUnit
:
:
Second
)
double
(
microseconds
)
)
;
return
CreateTimeDurationRecord
(
0
0
0
0
0
micros
double
(
nanoseconds
)
)
;
}
case
TemporalUnit
:
:
Nanosecond
:
{
MOZ_ASSERT
(
std
:
:
abs
(
nanoseconds
)
<
=
999
'
999
'
999
)
;
double
nanos
=
std
:
:
fma
(
double
(
seconds
)
ToNanoseconds
(
TemporalUnit
:
:
Second
)
double
(
nanoseconds
)
)
;
return
CreateTimeDurationRecord
(
0
0
0
0
0
0
nanos
)
;
}
case
TemporalUnit
:
:
Auto
:
MOZ_CRASH
(
"
Unexpected
temporal
unit
"
)
;
}
return
CreateTimeDurationRecord
(
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
)
;
}
static
bool
BalanceTimeDurationRelative
(
JSContext
*
cx
const
NormalizedDuration
&
duration
TemporalUnit
largestUnit
Handle
<
ZonedDateTime
>
relativeTo
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
TimeDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
const
auto
&
startNs
=
relativeTo
.
instant
(
)
;
const
auto
&
startInstant
=
startNs
;
auto
intermediateNs
=
startNs
;
PlainDateTime
startDateTime
;
if
(
duration
.
date
.
days
!
=
0
)
{
if
(
!
precalculatedPlainDateTime
)
{
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
startInstant
&
startDateTime
)
)
{
return
false
;
}
precalculatedPlainDateTime
=
mozilla
:
:
SomeRef
<
const
PlainDateTime
>
(
startDateTime
)
;
}
Rooted
<
CalendarValue
>
isoCalendar
(
cx
CalendarValue
(
cx
-
>
names
(
)
.
iso8601
)
)
;
if
(
!
AddDaysToZonedDateTime
(
cx
startInstant
*
precalculatedPlainDateTime
timeZone
isoCalendar
duration
.
date
.
days
&
intermediateNs
)
)
{
return
false
;
}
}
Instant
endNs
;
if
(
!
AddInstant
(
cx
intermediateNs
duration
.
time
&
endNs
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
endNs
)
)
;
auto
normalized
=
NormalizedTimeDurationFromEpochNanosecondsDifference
(
endNs
startInstant
)
;
if
(
normalized
=
=
NormalizedTimeDuration
{
}
)
{
*
result
=
{
}
;
return
true
;
}
int64_t
days
=
0
;
if
(
TemporalUnit
:
:
Year
<
=
largestUnit
&
&
largestUnit
<
=
TemporalUnit
:
:
Day
)
{
if
(
!
precalculatedPlainDateTime
)
{
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
startInstant
&
startDateTime
)
)
{
return
false
;
}
precalculatedPlainDateTime
=
mozilla
:
:
SomeRef
<
const
PlainDateTime
>
(
startDateTime
)
;
}
NormalizedTimeAndDays
timeAndDays
;
if
(
!
NormalizedTimeDurationToDays
(
cx
normalized
relativeTo
timeZone
*
precalculatedPlainDateTime
&
timeAndDays
)
)
{
return
false
;
}
days
=
timeAndDays
.
days
;
normalized
=
timeAndDays
.
time
;
MOZ_ASSERT_IF
(
days
>
0
normalized
>
=
NormalizedTimeDuration
{
}
)
;
MOZ_ASSERT_IF
(
days
<
0
normalized
<
=
NormalizedTimeDuration
{
}
)
;
largestUnit
=
TemporalUnit
:
:
Hour
;
}
auto
balanceResult
=
BalanceTimeDuration
(
normalized
largestUnit
)
;
*
result
=
{
double
(
days
)
balanceResult
.
hours
balanceResult
.
minutes
balanceResult
.
seconds
balanceResult
.
milliseconds
balanceResult
.
microseconds
balanceResult
.
nanoseconds
}
;
MOZ_ASSERT
(
IsValidDuration
(
result
-
>
toDuration
(
)
)
)
;
return
true
;
}
static
DateDuration
CreateDateDurationRecord
(
double
years
double
months
double
weeks
double
days
)
{
MOZ_ASSERT
(
IsValidDuration
(
Duration
{
years
months
weeks
days
}
)
)
;
return
{
years
months
weeks
days
}
;
}
static
bool
CreateDateDurationRecord
(
JSContext
*
cx
double
years
double
months
double
weeks
double
days
DateDuration
*
result
)
{
auto
duration
=
DateDuration
{
years
months
weeks
days
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
duration
)
)
{
return
false
;
}
*
result
=
duration
;
return
true
;
}
static
bool
UnbalanceDateDurationRelativeHasEffect
(
const
DateDuration
&
duration
TemporalUnit
largestUnit
)
{
MOZ_ASSERT
(
largestUnit
!
=
TemporalUnit
:
:
Auto
)
;
return
(
largestUnit
>
TemporalUnit
:
:
Year
&
&
duration
.
years
!
=
0
)
|
|
(
largestUnit
>
TemporalUnit
:
:
Month
&
&
duration
.
months
!
=
0
)
|
|
(
largestUnit
>
TemporalUnit
:
:
Week
&
&
duration
.
weeks
!
=
0
)
;
}
static
bool
UnbalanceDateDurationRelative
(
JSContext
*
cx
const
DateDuration
&
duration
TemporalUnit
largestUnit
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
DateDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
.
toDuration
(
)
)
)
;
auto
[
years
months
weeks
days
]
=
duration
;
if
(
!
UnbalanceDateDurationRelativeHasEffect
(
duration
largestUnit
)
)
{
*
result
=
duration
;
return
true
;
}
if
(
largestUnit
=
=
TemporalUnit
:
:
Month
)
{
MOZ_ASSERT
(
years
!
=
0
)
;
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
auto
yearsDuration
=
Duration
{
years
}
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
later
(
cx
CalendarDateAdd
(
cx
calendar
plainRelativeTo
yearsDuration
)
)
;
if
(
!
later
)
{
return
false
;
}
Duration
untilResult
;
if
(
!
CalendarDateUntil
(
cx
calendar
plainRelativeTo
later
TemporalUnit
:
:
Month
&
untilResult
)
)
{
return
false
;
}
double
yearsInMonths
=
untilResult
.
months
;
return
CreateDateDurationRecord
(
cx
0
months
+
yearsInMonths
weeks
days
result
)
;
}
if
(
largestUnit
=
=
TemporalUnit
:
:
Week
)
{
MOZ_ASSERT
(
years
!
=
0
|
|
months
!
=
0
)
;
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
auto
yearsMonthsDuration
=
Duration
{
years
months
}
;
auto
later
=
CalendarDateAdd
(
cx
calendar
plainRelativeTo
yearsMonthsDuration
)
;
if
(
!
later
)
{
return
false
;
}
auto
laterDate
=
ToPlainDate
(
&
later
.
unwrap
(
)
)
;
auto
*
unwrappedRelativeTo
=
plainRelativeTo
.
unwrap
(
cx
)
;
if
(
!
unwrappedRelativeTo
)
{
return
false
;
}
auto
relativeToDate
=
ToPlainDate
(
unwrappedRelativeTo
)
;
int32_t
yearsMonthsInDays
=
DaysUntil
(
relativeToDate
laterDate
)
;
return
CreateDateDurationRecord
(
cx
0
0
weeks
days
+
yearsMonthsInDays
result
)
;
}
MOZ_ASSERT
(
years
!
=
0
|
|
months
!
=
0
|
|
weeks
!
=
0
)
;
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
auto
yearsMonthsWeeksDuration
=
Duration
{
years
months
weeks
}
;
auto
later
=
CalendarDateAdd
(
cx
calendar
plainRelativeTo
yearsMonthsWeeksDuration
)
;
if
(
!
later
)
{
return
false
;
}
auto
laterDate
=
ToPlainDate
(
&
later
.
unwrap
(
)
)
;
auto
*
unwrappedRelativeTo
=
plainRelativeTo
.
unwrap
(
cx
)
;
if
(
!
unwrappedRelativeTo
)
{
return
false
;
}
auto
relativeToDate
=
ToPlainDate
(
unwrappedRelativeTo
)
;
int32_t
yearsMonthsWeeksInDay
=
DaysUntil
(
relativeToDate
laterDate
)
;
return
CreateDateDurationRecord
(
cx
0
0
0
days
+
yearsMonthsWeeksInDay
result
)
;
}
static
bool
UnbalanceDateDurationRelative
(
JSContext
*
cx
const
DateDuration
&
duration
TemporalUnit
largestUnit
DateDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
.
toDuration
(
)
)
)
;
if
(
!
UnbalanceDateDurationRelativeHasEffect
(
duration
largestUnit
)
)
{
*
result
=
duration
;
return
true
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_UNCOMPARABLE
"
calendar
"
)
;
return
false
;
}
static
bool
BalanceDateDurationRelative
(
JSContext
*
cx
const
DateDuration
&
duration
TemporalUnit
largestUnit
TemporalUnit
smallestUnit
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
DateDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
.
toDuration
(
)
)
)
;
MOZ_ASSERT
(
largestUnit
<
=
smallestUnit
)
;
auto
[
years
months
weeks
days
]
=
duration
;
if
(
largestUnit
>
TemporalUnit
:
:
Week
|
|
(
years
=
=
0
&
&
months
=
=
0
&
&
weeks
=
=
0
&
&
days
=
=
0
)
)
{
*
result
=
duration
;
return
true
;
}
if
(
!
plainRelativeTo
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_UNCOMPARABLE
"
relativeTo
"
)
;
return
false
;
}
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
MOZ_ASSERT
(
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
auto
untilAddedDate
=
[
&
]
(
const
Duration
&
duration
Duration
*
untilResult
)
{
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
later
(
cx
AddDate
(
cx
calendar
plainRelativeTo
duration
)
)
;
if
(
!
later
)
{
return
false
;
}
return
CalendarDateUntil
(
cx
calendar
plainRelativeTo
later
largestUnit
untilResult
)
;
}
;
if
(
largestUnit
=
=
TemporalUnit
:
:
Year
)
{
if
(
smallestUnit
=
=
TemporalUnit
:
:
Week
)
{
MOZ_ASSERT
(
days
=
=
0
)
;
auto
yearsMonthsDuration
=
Duration
{
years
months
}
;
Duration
untilResult
;
if
(
!
untilAddedDate
(
yearsMonthsDuration
&
untilResult
)
)
{
return
false
;
}
*
result
=
CreateDateDurationRecord
(
untilResult
.
years
untilResult
.
months
weeks
0
)
;
return
true
;
}
auto
yearsMonthsWeeksDaysDuration
=
Duration
{
years
months
weeks
days
}
;
Duration
untilResult
;
if
(
!
untilAddedDate
(
yearsMonthsWeeksDaysDuration
&
untilResult
)
)
{
return
false
;
}
*
result
=
CreateDateDurationRecord
(
untilResult
.
years
untilResult
.
months
untilResult
.
weeks
untilResult
.
days
)
;
return
true
;
}
if
(
largestUnit
=
=
TemporalUnit
:
:
Month
)
{
MOZ_ASSERT
(
years
=
=
0
)
;
if
(
smallestUnit
=
=
TemporalUnit
:
:
Week
)
{
MOZ_ASSERT
(
days
=
=
0
)
;
*
result
=
CreateDateDurationRecord
(
0
months
weeks
0
)
;
return
true
;
}
auto
monthsWeeksDaysDuration
=
Duration
{
0
months
weeks
days
}
;
Duration
untilResult
;
if
(
!
untilAddedDate
(
monthsWeeksDaysDuration
&
untilResult
)
)
{
return
false
;
}
*
result
=
CreateDateDurationRecord
(
0
untilResult
.
months
untilResult
.
weeks
untilResult
.
days
)
;
return
true
;
}
MOZ_ASSERT
(
largestUnit
=
=
TemporalUnit
:
:
Week
)
;
MOZ_ASSERT
(
years
=
=
0
)
;
MOZ_ASSERT
(
months
=
=
0
)
;
auto
weeksDaysDuration
=
Duration
{
0
0
weeks
days
}
;
Duration
untilResult
;
if
(
!
untilAddedDate
(
weeksDaysDuration
&
untilResult
)
)
{
return
false
;
}
*
result
=
CreateDateDurationRecord
(
0
0
untilResult
.
weeks
untilResult
.
days
)
;
return
true
;
}
bool
js
:
:
temporal
:
:
BalanceDateDurationRelative
(
JSContext
*
cx
const
DateDuration
&
duration
TemporalUnit
largestUnit
TemporalUnit
smallestUnit
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
DateDuration
*
result
)
{
MOZ_ASSERT
(
plainRelativeTo
)
;
MOZ_ASSERT
(
calendar
.
receiver
(
)
)
;
return
:
:
BalanceDateDurationRelative
(
cx
duration
largestUnit
smallestUnit
plainRelativeTo
calendar
result
)
;
}
static
bool
AddDuration
(
JSContext
*
cx
const
Duration
&
one
const
Duration
&
two
Duration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
one
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
two
)
)
;
auto
largestUnit1
=
DefaultTemporalLargestUnit
(
one
)
;
auto
largestUnit2
=
DefaultTemporalLargestUnit
(
two
)
;
auto
largestUnit
=
std
:
:
min
(
largestUnit1
largestUnit2
)
;
if
(
largestUnit
<
=
TemporalUnit
:
:
Week
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_UNCOMPARABLE
"
relativeTo
"
)
;
return
false
;
}
auto
normalized1
=
NormalizeTimeDuration
(
one
)
;
auto
normalized2
=
NormalizeTimeDuration
(
two
)
;
NormalizedTimeDuration
normalized
;
if
(
!
AddNormalizedTimeDuration
(
cx
normalized1
normalized2
&
normalized
)
)
{
return
false
;
}
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
normalized
one
.
days
+
two
.
days
&
normalized
)
)
{
return
false
;
}
auto
balanced
=
temporal
:
:
BalanceTimeDuration
(
normalized
largestUnit
)
;
*
result
=
balanced
.
toDuration
(
)
;
return
true
;
}
static
bool
AddDuration
(
JSContext
*
cx
const
Duration
&
one
const
Duration
&
two
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
Duration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
one
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
two
)
)
;
auto
largestUnit1
=
DefaultTemporalLargestUnit
(
one
)
;
auto
largestUnit2
=
DefaultTemporalLargestUnit
(
two
)
;
auto
largestUnit
=
std
:
:
min
(
largestUnit1
largestUnit2
)
;
auto
dateDuration1
=
Duration
{
one
.
years
one
.
months
one
.
weeks
one
.
days
}
;
auto
dateDuration2
=
Duration
{
two
.
years
two
.
months
two
.
weeks
two
.
days
}
;
[
[
maybe_unused
]
]
bool
calendarUnitsPresent
=
true
;
if
(
dateDuration1
.
years
=
=
0
&
&
dateDuration1
.
months
=
=
0
&
&
dateDuration1
.
weeks
=
=
0
&
&
dateDuration2
.
years
=
=
0
&
&
dateDuration2
.
months
=
=
0
&
&
dateDuration2
.
weeks
=
=
0
)
{
calendarUnitsPresent
=
false
;
}
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
intermediate
(
cx
AddDate
(
cx
calendar
plainRelativeTo
dateDuration1
)
)
;
if
(
!
intermediate
)
{
return
false
;
}
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
end
(
cx
AddDate
(
cx
calendar
intermediate
dateDuration2
)
)
;
if
(
!
end
)
{
return
false
;
}
auto
dateLargestUnit
=
std
:
:
min
(
TemporalUnit
:
:
Day
largestUnit
)
;
Duration
dateDifference
;
if
(
!
DifferenceDate
(
cx
calendar
plainRelativeTo
end
dateLargestUnit
&
dateDifference
)
)
{
return
false
;
}
auto
normalized1
=
NormalizeTimeDuration
(
one
)
;
auto
normalized2
=
NormalizeTimeDuration
(
two
)
;
NormalizedTimeDuration
normalized1WithDays
;
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
normalized1
dateDifference
.
days
&
normalized1WithDays
)
)
{
return
false
;
}
NormalizedTimeDuration
normalized
;
if
(
!
AddNormalizedTimeDuration
(
cx
normalized1WithDays
normalized2
&
normalized
)
)
{
return
false
;
}
auto
balanced
=
temporal
:
:
BalanceTimeDuration
(
normalized
largestUnit
)
;
*
result
=
{
dateDifference
.
years
dateDifference
.
months
dateDifference
.
weeks
balanced
.
days
balanced
.
hours
balanced
.
minutes
balanced
.
seconds
balanced
.
milliseconds
balanced
.
microseconds
balanced
.
nanoseconds
}
;
MOZ_ASSERT
(
IsValidDuration
(
*
result
)
)
;
return
true
;
}
static
bool
AddDuration
(
JSContext
*
cx
const
Duration
&
one
const
Duration
&
two
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
Duration
*
result
)
{
auto
largestUnit1
=
DefaultTemporalLargestUnit
(
one
)
;
auto
largestUnit2
=
DefaultTemporalLargestUnit
(
two
)
;
auto
largestUnit
=
std
:
:
min
(
largestUnit1
largestUnit2
)
;
bool
startDateTimeNeeded
=
largestUnit
<
=
TemporalUnit
:
:
Day
;
if
(
!
startDateTimeNeeded
)
{
auto
normalized1
=
NormalizeTimeDuration
(
one
)
;
auto
normalized2
=
NormalizeTimeDuration
(
two
)
;
Instant
intermediateNs
;
if
(
!
AddInstant
(
cx
zonedRelativeTo
.
instant
(
)
normalized1
&
intermediateNs
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
intermediateNs
)
)
;
Instant
endNs
;
if
(
!
AddInstant
(
cx
intermediateNs
normalized2
&
endNs
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
endNs
)
)
;
auto
normalized
=
NormalizedTimeDurationFromEpochNanosecondsDifference
(
endNs
zonedRelativeTo
.
instant
(
)
)
;
auto
balanced
=
BalanceTimeDuration
(
normalized
largestUnit
)
;
*
result
=
balanced
.
toDuration
(
)
;
return
true
;
}
PlainDateTime
startDateTime
;
if
(
!
precalculatedPlainDateTime
)
{
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
zonedRelativeTo
.
instant
(
)
&
startDateTime
)
)
{
return
false
;
}
}
else
{
startDateTime
=
*
precalculatedPlainDateTime
;
}
auto
normalized1
=
CreateNormalizedDurationRecord
(
one
)
;
auto
normalized2
=
CreateNormalizedDurationRecord
(
two
)
;
Instant
intermediateNs
;
if
(
!
AddZonedDateTime
(
cx
zonedRelativeTo
.
instant
(
)
timeZone
calendar
normalized1
startDateTime
&
intermediateNs
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
intermediateNs
)
)
;
Instant
endNs
;
if
(
!
AddZonedDateTime
(
cx
intermediateNs
timeZone
calendar
normalized2
&
endNs
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
endNs
)
)
;
NormalizedDuration
difference
;
if
(
!
DifferenceZonedDateTime
(
cx
zonedRelativeTo
.
instant
(
)
endNs
timeZone
calendar
largestUnit
startDateTime
&
difference
)
)
{
return
false
;
}
auto
balanced
=
BalanceTimeDuration
(
difference
.
time
TemporalUnit
:
:
Hour
)
;
*
result
=
{
difference
.
date
.
years
difference
.
date
.
months
difference
.
date
.
weeks
difference
.
date
.
days
balanced
.
hours
balanced
.
minutes
balanced
.
seconds
balanced
.
milliseconds
balanced
.
microseconds
balanced
.
nanoseconds
}
;
MOZ_ASSERT
(
IsValidDuration
(
*
result
)
)
;
return
true
;
}
static
bool
AddDuration
(
JSContext
*
cx
const
Duration
&
one
const
Duration
&
two
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
TimeZoneRecord
>
timeZone
Duration
*
result
)
{
return
AddDuration
(
cx
one
two
zonedRelativeTo
calendar
timeZone
mozilla
:
:
Nothing
(
)
result
)
;
}
static
bool
AdjustRoundedDurationDays
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
NormalizedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
if
(
(
TemporalUnit
:
:
Year
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Day
)
|
|
(
unit
=
=
TemporalUnit
:
:
Nanosecond
&
&
increment
=
=
Increment
{
1
}
)
)
{
*
result
=
duration
;
return
true
;
}
MOZ_ASSERT
(
increment
<
MaximumTemporalDurationRoundingIncrement
(
unit
)
)
;
MOZ_ASSERT
(
precalculatedPlainDateTime
)
;
int32_t
direction
=
NormalizedTimeDurationSign
(
duration
.
time
)
;
Instant
dayStart
;
if
(
!
AddZonedDateTime
(
cx
zonedRelativeTo
.
instant
(
)
timeZone
calendar
duration
.
date
*
precalculatedPlainDateTime
&
dayStart
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
dayStart
)
)
;
PlainDateTime
dayStartDateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
dayStart
&
dayStartDateTime
)
)
{
return
false
;
}
Instant
dayEnd
;
if
(
!
AddDaysToZonedDateTime
(
cx
dayStart
dayStartDateTime
timeZone
zonedRelativeTo
.
calendar
(
)
direction
&
dayEnd
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
dayEnd
)
)
;
auto
dayLengthNs
=
NormalizedTimeDurationFromEpochNanosecondsDifference
(
dayEnd
dayStart
)
;
MOZ_ASSERT
(
IsValidInstantSpan
(
{
dayLengthNs
.
seconds
dayLengthNs
.
nanoseconds
}
)
)
;
NormalizedTimeDuration
oneDayLess
;
if
(
!
SubtractNormalizedTimeDuration
(
cx
duration
.
time
dayLengthNs
&
oneDayLess
)
)
{
return
false
;
}
int32_t
oneDayLessSign
=
NormalizedTimeDurationSign
(
oneDayLess
)
;
if
(
(
direction
>
0
&
&
oneDayLessSign
<
0
)
|
|
(
direction
<
0
&
&
oneDayLessSign
>
0
)
)
{
*
result
=
duration
;
return
true
;
}
Duration
adjustedDateDuration
;
if
(
!
AddDuration
(
cx
duration
.
date
.
toDuration
(
)
{
0
0
0
double
(
direction
)
}
zonedRelativeTo
calendar
timeZone
precalculatedPlainDateTime
&
adjustedDateDuration
)
)
{
return
false
;
}
auto
roundedTime
=
RoundDuration
(
oneDayLess
increment
unit
roundingMode
)
;
return
CombineDateAndNormalizedTimeDuration
(
cx
adjustedDateDuration
.
toDateDuration
(
)
roundedTime
result
)
;
}
bool
js
:
:
temporal
:
:
AdjustRoundedDurationDays
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
TimeZoneRecord
>
timeZone
const
PlainDateTime
&
precalculatedPlainDateTime
NormalizedDuration
*
result
)
{
return
:
:
AdjustRoundedDurationDays
(
cx
duration
increment
unit
roundingMode
zonedRelativeTo
calendar
timeZone
mozilla
:
:
SomeRef
(
precalculatedPlainDateTime
)
result
)
;
}
static
bool
BigIntToStringBuilder
(
JSContext
*
cx
Handle
<
BigInt
*
>
num
JSStringBuilder
&
sb
)
{
MOZ_ASSERT
(
!
num
-
>
isNegative
(
)
)
;
JSLinearString
*
str
=
BigInt
:
:
toString
<
CanGC
>
(
cx
num
10
)
;
if
(
!
str
)
{
return
false
;
}
return
sb
.
append
(
str
)
;
}
static
bool
NumberToStringBuilder
(
JSContext
*
cx
int64_t
num
JSStringBuilder
&
sb
)
{
MOZ_ASSERT
(
num
>
=
0
)
;
MOZ_ASSERT
(
num
<
int64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
;
ToCStringBuf
cbuf
;
size_t
length
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
num
&
length
)
;
return
sb
.
append
(
numStr
length
)
;
}
static
bool
NumberToStringBuilder
(
JSContext
*
cx
double
num
JSStringBuilder
&
sb
)
{
MOZ_ASSERT
(
IsInteger
(
num
)
)
;
MOZ_ASSERT
(
num
>
=
0
)
;
if
(
num
<
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
{
ToCStringBuf
cbuf
;
size_t
length
;
const
char
*
numStr
=
NumberToCString
(
&
cbuf
num
&
length
)
;
return
sb
.
append
(
numStr
length
)
;
}
Rooted
<
BigInt
*
>
bi
(
cx
BigInt
:
:
createFromDouble
(
cx
num
)
)
;
if
(
!
bi
)
{
return
false
;
}
return
BigIntToStringBuilder
(
cx
bi
sb
)
;
}
static
Duration
AbsoluteDuration
(
const
Duration
&
duration
)
{
return
{
std
:
:
abs
(
duration
.
years
)
std
:
:
abs
(
duration
.
months
)
std
:
:
abs
(
duration
.
weeks
)
std
:
:
abs
(
duration
.
days
)
std
:
:
abs
(
duration
.
hours
)
std
:
:
abs
(
duration
.
minutes
)
std
:
:
abs
(
duration
.
seconds
)
std
:
:
abs
(
duration
.
milliseconds
)
std
:
:
abs
(
duration
.
microseconds
)
std
:
:
abs
(
duration
.
nanoseconds
)
}
;
}
[
[
nodiscard
]
]
static
bool
FormatFractionalSeconds
(
JSStringBuilder
&
result
int32_t
subSecondNanoseconds
Precision
precision
)
{
MOZ_ASSERT
(
0
<
=
subSecondNanoseconds
&
&
subSecondNanoseconds
<
1
'
000
'
000
'
000
)
;
MOZ_ASSERT
(
precision
!
=
Precision
:
:
Minute
(
)
)
;
if
(
precision
=
=
Precision
:
:
Auto
(
)
)
{
if
(
subSecondNanoseconds
=
=
0
)
{
return
true
;
}
if
(
!
result
.
append
(
'
.
'
)
)
{
return
false
;
}
uint32_t
k
=
100
'
000
'
000
;
do
{
if
(
!
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
)
{
return
false
;
}
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
while
(
subSecondNanoseconds
)
;
}
else
{
uint8_t
p
=
precision
.
value
(
)
;
if
(
p
=
=
0
)
{
return
true
;
}
if
(
!
result
.
append
(
'
.
'
)
)
{
return
false
;
}
uint32_t
k
=
100
'
000
'
000
;
for
(
uint8_t
i
=
0
;
i
<
precision
.
value
(
)
;
i
+
+
)
{
if
(
!
result
.
append
(
char
(
'
0
'
+
(
subSecondNanoseconds
/
k
)
)
)
)
{
return
false
;
}
subSecondNanoseconds
%
=
k
;
k
/
=
10
;
}
}
return
true
;
}
static
JSString
*
TemporalDurationToString
(
JSContext
*
cx
const
Duration
&
duration
Precision
precision
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
MOZ_ASSERT
(
precision
!
=
Precision
:
:
Minute
(
)
)
;
const
auto
&
[
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
]
=
AbsoluteDuration
(
duration
)
;
if
(
years
=
=
0
&
&
months
=
=
0
&
&
weeks
=
=
0
&
&
days
=
=
0
&
&
hours
=
=
0
&
&
minutes
=
=
0
&
&
seconds
=
=
0
&
&
milliseconds
=
=
0
&
&
microseconds
=
=
0
&
&
nanoseconds
=
=
0
&
&
(
precision
=
=
Precision
:
:
Auto
(
)
|
|
precision
.
value
(
)
=
=
0
)
)
{
return
NewStringCopyZ
<
CanGC
>
(
cx
"
PT0S
"
)
;
}
auto
secondsDuration
=
NormalizeTimeDuration
(
0
.
0
0
.
0
seconds
milliseconds
microseconds
nanoseconds
)
;
int32_t
sign
=
DurationSign
(
duration
)
;
JSStringBuilder
result
(
cx
)
;
if
(
sign
<
0
)
{
if
(
!
result
.
append
(
'
-
'
)
)
{
return
nullptr
;
}
}
if
(
!
result
.
append
(
'
P
'
)
)
{
return
nullptr
;
}
if
(
years
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
years
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
Y
'
)
)
{
return
nullptr
;
}
}
if
(
months
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
months
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
M
'
)
)
{
return
nullptr
;
}
}
if
(
weeks
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
weeks
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
W
'
)
)
{
return
nullptr
;
}
}
if
(
days
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
days
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
D
'
)
)
{
return
nullptr
;
}
}
bool
zeroMinutesAndHigher
=
years
=
=
0
&
&
months
=
=
0
&
&
weeks
=
=
0
&
&
days
=
=
0
&
&
hours
=
=
0
&
&
minutes
=
=
0
;
bool
hasSecondsPart
=
(
secondsDuration
!
=
NormalizedTimeDuration
{
}
)
|
|
zeroMinutesAndHigher
|
|
precision
!
=
Precision
:
:
Auto
(
)
;
if
(
hours
!
=
0
|
|
minutes
!
=
0
|
|
hasSecondsPart
)
{
if
(
!
result
.
append
(
'
T
'
)
)
{
return
nullptr
;
}
if
(
hours
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
hours
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
H
'
)
)
{
return
nullptr
;
}
}
if
(
minutes
!
=
0
)
{
if
(
!
NumberToStringBuilder
(
cx
minutes
result
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
M
'
)
)
{
return
nullptr
;
}
}
if
(
hasSecondsPart
)
{
if
(
!
NumberToStringBuilder
(
cx
secondsDuration
.
seconds
result
)
)
{
return
nullptr
;
}
if
(
!
FormatFractionalSeconds
(
result
secondsDuration
.
nanoseconds
precision
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
'
S
'
)
)
{
return
nullptr
;
}
}
}
return
result
.
finishString
(
)
;
}
static
bool
ToRelativeTemporalObject
(
JSContext
*
cx
Handle
<
JSObject
*
>
options
MutableHandle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
MutableHandle
<
ZonedDateTime
>
zonedRelativeTo
MutableHandle
<
TimeZoneRecord
>
timeZoneRecord
)
{
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
cx
-
>
names
(
)
.
relativeTo
&
value
)
)
{
return
false
;
}
if
(
value
.
isUndefined
(
)
)
{
plainRelativeTo
.
set
(
nullptr
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
}
)
;
timeZoneRecord
.
set
(
TimeZoneRecord
{
}
)
;
return
true
;
}
auto
offsetBehaviour
=
OffsetBehaviour
:
:
Option
;
auto
matchBehaviour
=
MatchBehaviour
:
:
MatchExactly
;
PlainDateTime
dateTime
;
Rooted
<
CalendarValue
>
calendar
(
cx
)
;
Rooted
<
TimeZoneValue
>
timeZone
(
cx
)
;
int64_t
offsetNs
;
if
(
value
.
isObject
(
)
)
{
Rooted
<
JSObject
*
>
obj
(
cx
&
value
.
toObject
(
)
)
;
if
(
auto
*
zonedDateTime
=
obj
-
>
maybeUnwrapIf
<
ZonedDateTimeObject
>
(
)
)
{
auto
instant
=
ToInstant
(
zonedDateTime
)
;
Rooted
<
TimeZoneValue
>
timeZone
(
cx
zonedDateTime
-
>
timeZone
(
)
)
;
Rooted
<
CalendarValue
>
calendar
(
cx
zonedDateTime
-
>
calendar
(
)
)
;
if
(
!
timeZone
.
wrap
(
cx
)
)
{
return
false
;
}
if
(
!
calendar
.
wrap
(
cx
)
)
{
return
false
;
}
Rooted
<
TimeZoneRecord
>
timeZoneRec
(
cx
)
;
if
(
!
CreateTimeZoneMethodsRecord
(
cx
timeZone
{
TimeZoneMethod
:
:
GetOffsetNanosecondsFor
TimeZoneMethod
:
:
GetPossibleInstantsFor
}
&
timeZoneRec
)
)
{
return
false
;
}
plainRelativeTo
.
set
(
nullptr
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
instant
timeZone
calendar
}
)
;
timeZoneRecord
.
set
(
timeZoneRec
)
;
return
true
;
}
if
(
obj
-
>
canUnwrapAs
<
PlainDateObject
>
(
)
)
{
plainRelativeTo
.
set
(
obj
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
}
)
;
timeZoneRecord
.
set
(
TimeZoneRecord
{
}
)
;
return
true
;
}
if
(
auto
*
dateTime
=
obj
-
>
maybeUnwrapIf
<
PlainDateTimeObject
>
(
)
)
{
auto
plainDateTime
=
ToPlainDate
(
dateTime
)
;
Rooted
<
CalendarValue
>
calendar
(
cx
dateTime
-
>
calendar
(
)
)
;
if
(
!
calendar
.
wrap
(
cx
)
)
{
return
false
;
}
auto
*
plainDate
=
CreateTemporalDate
(
cx
plainDateTime
calendar
)
;
if
(
!
plainDate
)
{
return
false
;
}
plainRelativeTo
.
set
(
plainDate
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
}
)
;
timeZoneRecord
.
set
(
TimeZoneRecord
{
}
)
;
return
true
;
}
if
(
!
GetTemporalCalendarWithISODefault
(
cx
obj
&
calendar
)
)
{
return
false
;
}
Rooted
<
CalendarRecord
>
calendarRec
(
cx
)
;
if
(
!
CreateCalendarMethodsRecord
(
cx
calendar
{
CalendarMethod
:
:
DateFromFields
CalendarMethod
:
:
Fields
}
&
calendarRec
)
)
{
return
false
;
}
JS
:
:
RootedVector
<
PropertyKey
>
fieldNames
(
cx
)
;
if
(
!
CalendarFields
(
cx
calendarRec
{
CalendarField
:
:
Day
CalendarField
:
:
Month
CalendarField
:
:
MonthCode
CalendarField
:
:
Year
}
&
fieldNames
)
)
{
return
false
;
}
if
(
!
AppendSorted
(
cx
fieldNames
.
get
(
)
{
TemporalField
:
:
Hour
TemporalField
:
:
Microsecond
TemporalField
:
:
Millisecond
TemporalField
:
:
Minute
TemporalField
:
:
Nanosecond
TemporalField
:
:
Offset
TemporalField
:
:
Second
TemporalField
:
:
TimeZone
}
)
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
fields
(
cx
PrepareTemporalFields
(
cx
obj
fieldNames
)
)
;
if
(
!
fields
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
dateOptions
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
dateOptions
)
{
return
false
;
}
Rooted
<
Value
>
overflow
(
cx
StringValue
(
cx
-
>
names
(
)
.
constrain
)
)
;
if
(
!
DefineDataProperty
(
cx
dateOptions
cx
-
>
names
(
)
.
overflow
overflow
)
)
{
return
false
;
}
if
(
!
InterpretTemporalDateTimeFields
(
cx
calendarRec
fields
dateOptions
&
dateTime
)
)
{
return
false
;
}
Rooted
<
Value
>
offset
(
cx
)
;
if
(
!
GetProperty
(
cx
fields
fields
cx
-
>
names
(
)
.
offset
&
offset
)
)
{
return
false
;
}
Rooted
<
Value
>
timeZoneValue
(
cx
)
;
if
(
!
GetProperty
(
cx
fields
fields
cx
-
>
names
(
)
.
timeZone
&
timeZoneValue
)
)
{
return
false
;
}
if
(
!
timeZoneValue
.
isUndefined
(
)
)
{
if
(
!
ToTemporalTimeZone
(
cx
timeZoneValue
&
timeZone
)
)
{
return
false
;
}
}
if
(
offset
.
isUndefined
(
)
)
{
offsetBehaviour
=
OffsetBehaviour
:
:
Wall
;
}
if
(
timeZone
)
{
if
(
offsetBehaviour
=
=
OffsetBehaviour
:
:
Option
)
{
MOZ_ASSERT
(
!
offset
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
offset
.
isString
(
)
)
;
Rooted
<
JSString
*
>
offsetString
(
cx
offset
.
toString
(
)
)
;
if
(
!
offsetString
)
{
return
false
;
}
if
(
!
ParseDateTimeUTCOffset
(
cx
offsetString
&
offsetNs
)
)
{
return
false
;
}
}
else
{
offsetNs
=
0
;
}
}
}
else
{
if
(
!
value
.
isString
(
)
)
{
ReportValueError
(
cx
JSMSG_UNEXPECTED_TYPE
JSDVG_IGNORE_STACK
value
nullptr
"
not
a
string
"
)
;
return
false
;
}
Rooted
<
JSString
*
>
string
(
cx
value
.
toString
(
)
)
;
bool
isUTC
;
bool
hasOffset
;
int64_t
timeZoneOffset
;
Rooted
<
ParsedTimeZone
>
timeZoneName
(
cx
)
;
Rooted
<
JSString
*
>
calendarString
(
cx
)
;
if
(
!
ParseTemporalRelativeToString
(
cx
string
&
dateTime
&
isUTC
&
hasOffset
&
timeZoneOffset
&
timeZoneName
&
calendarString
)
)
{
return
false
;
}
if
(
timeZoneName
)
{
if
(
!
ToTemporalTimeZone
(
cx
timeZoneName
&
timeZone
)
)
{
return
false
;
}
if
(
isUTC
)
{
offsetBehaviour
=
OffsetBehaviour
:
:
Exact
;
}
else
if
(
!
hasOffset
)
{
offsetBehaviour
=
OffsetBehaviour
:
:
Wall
;
}
matchBehaviour
=
MatchBehaviour
:
:
MatchMinutes
;
}
else
{
MOZ_ASSERT
(
!
timeZone
)
;
}
if
(
calendarString
)
{
if
(
!
ToBuiltinCalendar
(
cx
calendarString
&
calendar
)
)
{
return
false
;
}
}
else
{
calendar
.
set
(
CalendarValue
(
cx
-
>
names
(
)
.
iso8601
)
)
;
}
if
(
timeZone
)
{
if
(
offsetBehaviour
=
=
OffsetBehaviour
:
:
Option
)
{
MOZ_ASSERT
(
hasOffset
)
;
offsetNs
=
timeZoneOffset
;
}
else
{
offsetNs
=
0
;
}
}
}
if
(
!
timeZone
)
{
auto
*
plainDate
=
CreateTemporalDate
(
cx
dateTime
.
date
calendar
)
;
if
(
!
plainDate
)
{
return
false
;
}
plainRelativeTo
.
set
(
plainDate
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
}
)
;
timeZoneRecord
.
set
(
TimeZoneRecord
{
}
)
;
return
true
;
}
Rooted
<
TimeZoneRecord
>
timeZoneRec
(
cx
)
;
if
(
!
CreateTimeZoneMethodsRecord
(
cx
timeZone
{
TimeZoneMethod
:
:
GetOffsetNanosecondsFor
TimeZoneMethod
:
:
GetPossibleInstantsFor
}
&
timeZoneRec
)
)
{
return
false
;
}
Instant
epochNanoseconds
;
if
(
!
InterpretISODateTimeOffset
(
cx
dateTime
offsetBehaviour
offsetNs
timeZoneRec
TemporalDisambiguation
:
:
Compatible
TemporalOffset
:
:
Reject
matchBehaviour
&
epochNanoseconds
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsValidEpochInstant
(
epochNanoseconds
)
)
;
plainRelativeTo
.
set
(
nullptr
)
;
zonedRelativeTo
.
set
(
ZonedDateTime
{
epochNanoseconds
timeZone
calendar
}
)
;
timeZoneRecord
.
set
(
timeZoneRec
)
;
return
true
;
}
static
bool
CreateCalendarMethodsRecordFromRelativeTo
(
JSContext
*
cx
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
ZonedDateTime
>
zonedRelativeTo
mozilla
:
:
EnumSet
<
CalendarMethod
>
methods
MutableHandle
<
CalendarRecord
>
result
)
{
if
(
zonedRelativeTo
)
{
return
CreateCalendarMethodsRecord
(
cx
zonedRelativeTo
.
calendar
(
)
methods
result
)
;
}
if
(
plainRelativeTo
)
{
auto
*
unwrapped
=
plainRelativeTo
.
unwrap
(
cx
)
;
if
(
!
unwrapped
)
{
return
false
;
}
Rooted
<
CalendarValue
>
calendar
(
cx
unwrapped
-
>
calendar
(
)
)
;
if
(
!
calendar
.
wrap
(
cx
)
)
{
return
false
;
}
return
CreateCalendarMethodsRecord
(
cx
calendar
methods
result
)
;
}
return
true
;
}
static
constexpr
bool
IsSafeInteger
(
int64_t
x
)
{
constexpr
int64_t
MaxSafeInteger
=
int64_t
(
1
)
<
<
53
;
constexpr
int64_t
MinSafeInteger
=
-
MaxSafeInteger
;
return
MinSafeInteger
<
x
&
&
x
<
MaxSafeInteger
;
}
static
constexpr
bool
IsSafeInteger
(
const
Int128
&
x
)
{
constexpr
Int128
MaxSafeInteger
=
Int128
{
int64_t
(
1
)
<
<
53
}
;
constexpr
Int128
MinSafeInteger
=
-
MaxSafeInteger
;
return
MinSafeInteger
<
x
&
&
x
<
MaxSafeInteger
;
}
static
void
TruncateNumber
(
int64_t
numerator
int64_t
denominator
double
*
quotient
double
*
total
)
{
int64_t
q
=
numerator
/
denominator
;
int64_t
r
=
numerator
%
denominator
;
if
(
:
:
IsSafeInteger
(
numerator
)
&
&
:
:
IsSafeInteger
(
denominator
)
)
{
*
quotient
=
double
(
q
)
;
*
total
=
double
(
numerator
)
/
double
(
denominator
)
;
}
else
{
*
quotient
=
double
(
q
)
;
*
total
=
double
(
q
)
+
double
(
r
)
/
double
(
denominator
)
;
}
}
static
bool
TruncateNumber
(
JSContext
*
cx
Handle
<
BigInt
*
>
numerator
Handle
<
BigInt
*
>
denominator
double
*
quotient
double
*
total
)
{
MOZ_ASSERT
(
!
denominator
-
>
isNegative
(
)
)
;
MOZ_ASSERT
(
!
denominator
-
>
isZero
(
)
)
;
if
(
numerator
-
>
isZero
(
)
)
{
*
quotient
=
0
;
*
total
=
0
;
return
true
;
}
int64_t
num
denom
;
if
(
BigInt
:
:
isInt64
(
numerator
&
num
)
&
&
BigInt
:
:
isInt64
(
denominator
&
denom
)
)
{
TruncateNumber
(
num
denom
quotient
total
)
;
return
true
;
}
Rooted
<
BigInt
*
>
quot
(
cx
)
;
Rooted
<
BigInt
*
>
rem
(
cx
)
;
if
(
!
BigInt
:
:
divmod
(
cx
numerator
denominator
&
quot
&
rem
)
)
{
return
false
;
}
double
q
=
BigInt
:
:
numberValue
(
quot
)
;
*
quotient
=
q
;
*
total
=
q
+
BigInt
:
:
numberValue
(
rem
)
/
BigInt
:
:
numberValue
(
denominator
)
;
return
true
;
}
struct
RoundedDuration
final
{
NormalizedDuration
duration
;
double
total
=
0
;
}
;
enum
class
ComputeRemainder
:
bool
{
No
Yes
}
;
static
NormalizedTimeDuration
RoundNormalizedTimeDurationToIncrement
(
const
NormalizedTimeDuration
&
duration
const
TemporalUnit
unit
Increment
increment
TemporalRoundingMode
roundingMode
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
)
)
;
MOZ_ASSERT
(
unit
>
TemporalUnit
:
:
Day
)
;
MOZ_ASSERT
(
increment
<
=
MaximumTemporalDurationRoundingIncrement
(
unit
)
)
;
int64_t
divisor
=
ToNanoseconds
(
unit
)
*
increment
.
value
(
)
;
MOZ_ASSERT
(
divisor
>
0
)
;
MOZ_ASSERT
(
divisor
<
=
ToNanoseconds
(
TemporalUnit
:
:
Day
)
)
;
auto
totalNanoseconds
=
duration
.
toTotalNanoseconds
(
)
;
auto
rounded
=
RoundNumberToIncrement
(
totalNanoseconds
Int128
{
divisor
}
roundingMode
)
;
return
NormalizedTimeDuration
:
:
fromNanoseconds
(
rounded
)
;
}
static
double
TotalNormalizedTimeDuration
(
const
NormalizedTimeDuration
&
duration
const
TemporalUnit
unit
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
)
)
;
MOZ_ASSERT
(
unit
>
TemporalUnit
:
:
Day
)
;
auto
numerator
=
duration
.
toTotalNanoseconds
(
)
;
auto
denominator
=
ToNanoseconds
(
unit
)
;
MOZ_ASSERT
(
:
:
IsSafeInteger
(
denominator
)
)
;
if
(
:
:
IsSafeInteger
(
numerator
)
)
{
return
double
(
numerator
)
/
double
(
denominator
)
;
}
auto
[
q
r
]
=
numerator
.
divrem
(
Int128
{
denominator
}
)
;
return
double
(
q
)
+
double
(
r
)
/
double
(
denominator
)
;
}
NormalizedTimeDuration
js
:
:
temporal
:
:
RoundDuration
(
const
NormalizedTimeDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
)
{
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
)
)
;
MOZ_ASSERT
(
unit
>
TemporalUnit
:
:
Day
)
;
auto
rounded
=
RoundNormalizedTimeDurationToIncrement
(
duration
unit
increment
roundingMode
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
rounded
)
)
;
return
rounded
;
}
static
bool
TruncateDays
(
JSContext
*
cx
const
NormalizedTimeAndDays
&
timeAndDays
double
days
int32_t
daysToAdd
double
*
result
)
{
do
{
int64_t
intDays
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
days
&
intDays
)
)
{
break
;
}
auto
totalDays
=
mozilla
:
:
CheckedInt64
(
intDays
)
;
totalDays
+
=
timeAndDays
.
days
;
totalDays
+
=
daysToAdd
;
if
(
!
totalDays
.
isValid
(
)
)
{
break
;
}
int64_t
truncatedDays
=
totalDays
.
value
(
)
;
if
(
timeAndDays
.
time
>
NormalizedTimeDuration
{
}
)
{
if
(
truncatedDays
<
0
)
{
truncatedDays
+
=
1
;
}
}
else
if
(
timeAndDays
.
time
<
NormalizedTimeDuration
{
}
)
{
if
(
truncatedDays
>
0
)
{
truncatedDays
-
=
1
;
}
}
*
result
=
double
(
truncatedDays
)
;
return
true
;
}
while
(
false
)
;
Rooted
<
BigInt
*
>
biDays
(
cx
BigInt
:
:
createFromDouble
(
cx
days
)
)
;
if
(
!
biDays
)
{
return
false
;
}
Rooted
<
BigInt
*
>
biNanoDays
(
cx
BigInt
:
:
createFromInt64
(
cx
timeAndDays
.
days
)
)
;
if
(
!
biNanoDays
)
{
return
false
;
}
Rooted
<
BigInt
*
>
biDaysToAdd
(
cx
BigInt
:
:
createFromInt64
(
cx
daysToAdd
)
)
;
if
(
!
biDaysToAdd
)
{
return
false
;
}
Rooted
<
BigInt
*
>
truncatedDays
(
cx
BigInt
:
:
add
(
cx
biDays
biNanoDays
)
)
;
if
(
!
truncatedDays
)
{
return
false
;
}
truncatedDays
=
BigInt
:
:
add
(
cx
truncatedDays
biDaysToAdd
)
;
if
(
!
truncatedDays
)
{
return
false
;
}
if
(
timeAndDays
.
time
>
NormalizedTimeDuration
{
}
)
{
if
(
truncatedDays
-
>
isNegative
(
)
)
{
truncatedDays
=
BigInt
:
:
inc
(
cx
truncatedDays
)
;
if
(
!
truncatedDays
)
{
return
false
;
}
}
}
else
if
(
timeAndDays
.
time
<
NormalizedTimeDuration
{
}
)
{
if
(
!
truncatedDays
-
>
isNegative
(
)
&
&
!
truncatedDays
-
>
isZero
(
)
)
{
truncatedDays
=
BigInt
:
:
dec
(
cx
truncatedDays
)
;
if
(
!
truncatedDays
)
{
return
false
;
}
}
}
*
result
=
BigInt
:
:
numberValue
(
truncatedDays
)
;
return
true
;
}
static
bool
DaysIsNegative
(
double
days
const
NormalizedTimeAndDays
&
timeAndDays
int32_t
daysToAdd
)
{
static
constexpr
int32_t
epochDays
=
200
'
000
'
000
;
MOZ_ASSERT
(
std
:
:
abs
(
daysToAdd
)
<
=
epochDays
*
2
)
;
int64_t
timeDays
=
timeAndDays
.
days
;
MOZ_ASSERT
(
(
days
<
=
0
&
&
timeDays
<
=
0
)
|
|
(
days
>
=
0
&
&
timeDays
>
=
0
)
|
|
std
:
:
abs
(
days
)
<
=
epochDays
)
;
double
daysApproximation
=
days
+
timeDays
;
if
(
std
:
:
abs
(
daysApproximation
)
<
=
epochDays
*
2
)
{
int32_t
intDays
=
int32_t
(
daysApproximation
)
+
daysToAdd
;
return
intDays
<
0
|
|
(
intDays
=
=
0
&
&
timeAndDays
.
time
<
NormalizedTimeDuration
{
}
)
;
}
return
daysApproximation
<
0
;
}
struct
RoundedNumber
{
double
rounded
;
double
total
;
}
;
static
bool
RoundNumberToIncrementSlow
(
JSContext
*
cx
double
durationAmount
double
amountPassed
double
durationDays
int32_t
daysToAdd
const
NormalizedTimeAndDays
&
timeAndDays
int32_t
oneUnitDays
Increment
increment
TemporalRoundingMode
roundingMode
ComputeRemainder
computeRemainder
RoundedNumber
*
result
)
{
MOZ_ASSERT
(
timeAndDays
.
dayLength
>
NormalizedTimeDuration
{
}
)
;
MOZ_ASSERT
(
timeAndDays
.
time
.
abs
(
)
<
timeAndDays
.
dayLength
)
;
MOZ_ASSERT
(
oneUnitDays
!
=
0
)
;
Rooted
<
BigInt
*
>
biAmount
(
cx
BigInt
:
:
createFromDouble
(
cx
durationAmount
)
)
;
if
(
!
biAmount
)
{
return
false
;
}
Rooted
<
BigInt
*
>
biAmountPassed
(
cx
BigInt
:
:
createFromDouble
(
cx
amountPassed
)
)
;
if
(
!
biAmountPassed
)
{
return
false
;
}
biAmount
=
BigInt
:
:
add
(
cx
biAmount
biAmountPassed
)
;
if
(
!
biAmount
)
{
return
false
;
}
Rooted
<
BigInt
*
>
days
(
cx
BigInt
:
:
createFromDouble
(
cx
durationDays
)
)
;
if
(
!
days
)
{
return
false
;
}
Rooted
<
BigInt
*
>
nanoDays
(
cx
BigInt
:
:
createFromInt64
(
cx
timeAndDays
.
days
)
)
;
if
(
!
nanoDays
)
{
return
false
;
}
Rooted
<
BigInt
*
>
biDaysToAdd
(
cx
BigInt
:
:
createFromInt64
(
cx
daysToAdd
)
)
;
if
(
!
biDaysToAdd
)
{
return
false
;
}
days
=
BigInt
:
:
add
(
cx
days
nanoDays
)
;
if
(
!
days
)
{
return
false
;
}
days
=
BigInt
:
:
add
(
cx
days
biDaysToAdd
)
;
if
(
!
days
)
{
return
false
;
}
Rooted
<
BigInt
*
>
nanoseconds
(
cx
ToNanoseconds
(
cx
timeAndDays
.
time
)
)
;
if
(
!
nanoseconds
)
{
return
false
;
}
Rooted
<
BigInt
*
>
dayLength
(
cx
ToNanoseconds
(
cx
timeAndDays
.
dayLength
)
)
;
if
(
!
dayLength
)
{
return
false
;
}
Rooted
<
BigInt
*
>
denominator
(
cx
BigInt
:
:
createFromInt64
(
cx
std
:
:
abs
(
oneUnitDays
)
)
)
;
if
(
!
denominator
)
{
return
false
;
}
denominator
=
BigInt
:
:
mul
(
cx
denominator
dayLength
)
;
if
(
!
denominator
)
{
return
false
;
}
Rooted
<
BigInt
*
>
totalNanoseconds
(
cx
BigInt
:
:
mul
(
cx
days
dayLength
)
)
;
if
(
!
totalNanoseconds
)
{
return
false
;
}
totalNanoseconds
=
BigInt
:
:
add
(
cx
totalNanoseconds
nanoseconds
)
;
if
(
!
totalNanoseconds
)
{
return
false
;
}
Rooted
<
BigInt
*
>
amountNanos
(
cx
BigInt
:
:
mul
(
cx
biAmount
denominator
)
)
;
if
(
!
amountNanos
)
{
return
false
;
}
totalNanoseconds
=
BigInt
:
:
add
(
cx
totalNanoseconds
amountNanos
)
;
if
(
!
totalNanoseconds
)
{
return
false
;
}
double
rounded
;
double
total
=
0
;
if
(
computeRemainder
=
=
ComputeRemainder
:
:
No
)
{
if
(
!
temporal
:
:
RoundNumberToIncrement
(
cx
totalNanoseconds
denominator
increment
roundingMode
&
rounded
)
)
{
return
false
;
}
}
else
{
if
(
!
:
:
TruncateNumber
(
cx
totalNanoseconds
denominator
&
rounded
&
total
)
)
{
return
false
;
}
}
*
result
=
{
rounded
total
}
;
return
true
;
}
static
bool
RoundNumberToIncrement
(
JSContext
*
cx
double
durationAmount
double
amountPassed
double
durationDays
int32_t
daysToAdd
const
NormalizedTimeAndDays
&
timeAndDays
int32_t
oneUnitDays
Increment
increment
TemporalRoundingMode
roundingMode
ComputeRemainder
computeRemainder
RoundedNumber
*
result
)
{
MOZ_ASSERT
(
timeAndDays
.
dayLength
>
NormalizedTimeDuration
{
}
)
;
MOZ_ASSERT
(
timeAndDays
.
time
.
abs
(
)
<
timeAndDays
.
dayLength
)
;
MOZ_ASSERT
(
oneUnitDays
!
=
0
)
;
MOZ_ASSERT
(
std
:
:
abs
(
oneUnitDays
)
<
=
200
'
000
'
000
)
;
do
{
auto
nanoseconds
=
timeAndDays
.
time
.
toNanoseconds
(
)
;
if
(
!
nanoseconds
.
isValid
(
)
)
{
break
;
}
auto
dayLength
=
timeAndDays
.
dayLength
.
toNanoseconds
(
)
;
if
(
!
dayLength
.
isValid
(
)
)
{
break
;
}
auto
denominator
=
dayLength
*
std
:
:
abs
(
oneUnitDays
)
;
if
(
!
denominator
.
isValid
(
)
)
{
break
;
}
int64_t
intDays
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
durationDays
&
intDays
)
)
{
break
;
}
auto
totalDays
=
mozilla
:
:
CheckedInt64
(
intDays
)
;
totalDays
+
=
timeAndDays
.
days
;
totalDays
+
=
daysToAdd
;
if
(
!
totalDays
.
isValid
(
)
)
{
break
;
}
auto
totalNanoseconds
=
dayLength
*
totalDays
;
if
(
!
totalNanoseconds
.
isValid
(
)
)
{
break
;
}
totalNanoseconds
+
=
nanoseconds
;
if
(
!
totalNanoseconds
.
isValid
(
)
)
{
break
;
}
int64_t
intAmount
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
durationAmount
&
intAmount
)
)
{
break
;
}
int64_t
intAmountPassed
;
if
(
!
mozilla
:
:
NumberEqualsInt64
(
amountPassed
&
intAmountPassed
)
)
{
break
;
}
auto
totalAmount
=
mozilla
:
:
CheckedInt64
(
intAmount
)
+
intAmountPassed
;
if
(
!
totalAmount
.
isValid
(
)
)
{
break
;
}
auto
amountNanos
=
denominator
*
totalAmount
;
if
(
!
amountNanos
.
isValid
(
)
)
{
break
;
}
totalNanoseconds
+
=
amountNanos
;
if
(
!
totalNanoseconds
.
isValid
(
)
)
{
break
;
}
double
rounded
;
double
total
=
0
;
if
(
computeRemainder
=
=
ComputeRemainder
:
:
No
)
{
if
(
!
temporal
:
:
RoundNumberToIncrement
(
cx
totalNanoseconds
.
value
(
)
denominator
.
value
(
)
increment
roundingMode
&
rounded
)
)
{
return
false
;
}
}
else
{
TruncateNumber
(
totalNanoseconds
.
value
(
)
denominator
.
value
(
)
&
rounded
&
total
)
;
}
*
result
=
{
rounded
total
}
;
return
true
;
}
while
(
false
)
;
return
RoundNumberToIncrementSlow
(
cx
durationAmount
amountPassed
durationDays
daysToAdd
timeAndDays
oneUnitDays
increment
roundingMode
computeRemainder
result
)
;
}
static
bool
RoundNumberToIncrement
(
JSContext
*
cx
double
durationDays
const
NormalizedTimeAndDays
&
timeAndDays
Increment
increment
TemporalRoundingMode
roundingMode
ComputeRemainder
computeRemainder
RoundedNumber
*
result
)
{
constexpr
double
daysAmount
=
0
;
constexpr
double
daysPassed
=
0
;
constexpr
int32_t
oneDayDays
=
1
;
constexpr
int32_t
daysToAdd
=
0
;
return
RoundNumberToIncrement
(
cx
daysAmount
daysPassed
durationDays
daysToAdd
timeAndDays
oneDayDays
increment
roundingMode
computeRemainder
result
)
;
}
static
bool
RoundDurationYear
(
JSContext
*
cx
const
NormalizedDuration
&
duration
const
NormalizedTimeAndDays
&
timeAndDays
Increment
increment
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
dateRelativeTo
Handle
<
CalendarRecord
>
calendar
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
static
constexpr
int32_t
epochDays
=
200
'
000
'
000
;
auto
[
years
months
weeks
days
]
=
duration
.
date
;
Duration
yearsDuration
=
{
years
}
;
auto
yearsLater
=
AddDate
(
cx
calendar
dateRelativeTo
yearsDuration
)
;
if
(
!
yearsLater
)
{
return
false
;
}
auto
yearsLaterDate
=
ToPlainDate
(
&
yearsLater
.
unwrap
(
)
)
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
newRelativeTo
(
cx
yearsLater
)
;
Duration
yearsMonthsWeeks
=
{
years
months
weeks
}
;
PlainDate
yearsMonthsWeeksLater
;
if
(
!
AddDate
(
cx
calendar
dateRelativeTo
yearsMonthsWeeks
&
yearsMonthsWeeksLater
)
)
{
return
false
;
}
int32_t
monthsWeeksInDays
=
DaysUntil
(
yearsLaterDate
yearsMonthsWeeksLater
)
;
MOZ_ASSERT
(
std
:
:
abs
(
monthsWeeksInDays
)
<
=
epochDays
)
;
double
truncatedDays
;
if
(
!
TruncateDays
(
cx
timeAndDays
days
monthsWeeksInDays
&
truncatedDays
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
truncatedDays
)
)
;
PlainDate
isoResult
;
if
(
!
AddISODate
(
cx
yearsLaterDate
{
0
0
0
truncatedDays
}
TemporalOverflow
:
:
Constrain
&
isoResult
)
)
{
return
false
;
}
Rooted
<
PlainDateObject
*
>
wholeDaysLater
(
cx
CreateTemporalDate
(
cx
isoResult
calendar
.
receiver
(
)
)
)
;
if
(
!
wholeDaysLater
)
{
return
false
;
}
Duration
timePassed
;
if
(
!
DifferenceDate
(
cx
calendar
newRelativeTo
wholeDaysLater
TemporalUnit
:
:
Year
&
timePassed
)
)
{
return
false
;
}
double
yearsPassed
=
timePassed
.
years
;
Duration
yearsPassedDuration
=
{
yearsPassed
}
;
int32_t
daysPassed
;
if
(
!
MoveRelativeDate
(
cx
calendar
newRelativeTo
yearsPassedDuration
&
newRelativeTo
&
daysPassed
)
)
{
return
false
;
}
MOZ_ASSERT
(
std
:
:
abs
(
daysPassed
)
<
=
epochDays
)
;
int32_t
daysToAdd
=
monthsWeeksInDays
-
daysPassed
;
MOZ_ASSERT
(
std
:
:
abs
(
daysToAdd
)
<
=
epochDays
*
2
)
;
double
sign
=
DaysIsNegative
(
days
timeAndDays
daysToAdd
)
?
-
1
:
1
;
Duration
oneYear
=
{
sign
}
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
moveResultIgnored
(
cx
)
;
int32_t
oneYearDays
;
if
(
!
MoveRelativeDate
(
cx
calendar
newRelativeTo
oneYear
&
moveResultIgnored
&
oneYearDays
)
)
{
return
false
;
}
if
(
oneYearDays
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_NUMBER
"
days
"
)
;
return
false
;
}
RoundedNumber
rounded
;
if
(
!
RoundNumberToIncrement
(
cx
years
yearsPassed
days
daysToAdd
timeAndDays
oneYearDays
increment
roundingMode
computeRemainder
&
rounded
)
)
{
return
false
;
}
auto
[
numYears
total
]
=
rounded
;
double
numMonths
=
0
;
double
numWeeks
=
0
;
constexpr
auto
time
=
NormalizedTimeDuration
{
}
;
auto
resultDuration
=
DateDuration
{
numYears
numMonths
numWeeks
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
resultDuration
)
)
{
return
false
;
}
*
result
=
{
{
resultDuration
time
}
total
}
;
return
true
;
}
static
bool
RoundDurationMonth
(
JSContext
*
cx
const
NormalizedDuration
&
duration
const
NormalizedTimeAndDays
&
timeAndDays
Increment
increment
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
dateRelativeTo
Handle
<
CalendarRecord
>
calendar
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
static
constexpr
int32_t
epochDays
=
200
'
000
'
000
;
auto
[
years
months
weeks
days
]
=
duration
.
date
;
Duration
yearsMonths
=
{
years
months
}
;
auto
yearsMonthsLater
=
AddDate
(
cx
calendar
dateRelativeTo
yearsMonths
)
;
if
(
!
yearsMonthsLater
)
{
return
false
;
}
auto
yearsMonthsLaterDate
=
ToPlainDate
(
&
yearsMonthsLater
.
unwrap
(
)
)
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
newRelativeTo
(
cx
yearsMonthsLater
)
;
Duration
yearsMonthsWeeks
=
{
years
months
weeks
}
;
PlainDate
yearsMonthsWeeksLater
;
if
(
!
AddDate
(
cx
calendar
dateRelativeTo
yearsMonthsWeeks
&
yearsMonthsWeeksLater
)
)
{
return
false
;
}
int32_t
weeksInDays
=
DaysUntil
(
yearsMonthsLaterDate
yearsMonthsWeeksLater
)
;
MOZ_ASSERT
(
std
:
:
abs
(
weeksInDays
)
<
=
epochDays
)
;
double
truncatedDays
;
if
(
!
TruncateDays
(
cx
timeAndDays
days
weeksInDays
&
truncatedDays
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
truncatedDays
)
)
;
PlainDate
isoResult
;
if
(
!
AddISODate
(
cx
yearsMonthsLaterDate
{
0
0
0
truncatedDays
}
TemporalOverflow
:
:
Constrain
&
isoResult
)
)
{
return
false
;
}
Rooted
<
PlainDateObject
*
>
wholeDaysLater
(
cx
CreateTemporalDate
(
cx
isoResult
calendar
.
receiver
(
)
)
)
;
if
(
!
wholeDaysLater
)
{
return
false
;
}
Duration
timePassed
;
if
(
!
DifferenceDate
(
cx
calendar
newRelativeTo
wholeDaysLater
TemporalUnit
:
:
Month
&
timePassed
)
)
{
return
false
;
}
double
monthsPassed
=
timePassed
.
months
;
Duration
monthsPassedDuration
=
{
0
monthsPassed
}
;
int32_t
daysPassed
;
if
(
!
MoveRelativeDate
(
cx
calendar
newRelativeTo
monthsPassedDuration
&
newRelativeTo
&
daysPassed
)
)
{
return
false
;
}
MOZ_ASSERT
(
std
:
:
abs
(
daysPassed
)
<
=
epochDays
)
;
int32_t
daysToAdd
=
weeksInDays
-
daysPassed
;
MOZ_ASSERT
(
std
:
:
abs
(
daysToAdd
)
<
=
epochDays
*
2
)
;
double
sign
=
DaysIsNegative
(
days
timeAndDays
daysToAdd
)
?
-
1
:
1
;
Duration
oneMonth
=
{
0
sign
}
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
moveResultIgnored
(
cx
)
;
int32_t
oneMonthDays
;
if
(
!
MoveRelativeDate
(
cx
calendar
newRelativeTo
oneMonth
&
moveResultIgnored
&
oneMonthDays
)
)
{
return
false
;
}
if
(
oneMonthDays
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_NUMBER
"
days
"
)
;
return
false
;
}
RoundedNumber
rounded
;
if
(
!
RoundNumberToIncrement
(
cx
months
monthsPassed
days
daysToAdd
timeAndDays
oneMonthDays
increment
roundingMode
computeRemainder
&
rounded
)
)
{
return
false
;
}
auto
[
numMonths
total
]
=
rounded
;
double
numWeeks
=
0
;
constexpr
auto
time
=
NormalizedTimeDuration
{
}
;
auto
resultDuration
=
DateDuration
{
years
numMonths
numWeeks
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
resultDuration
)
)
{
return
false
;
}
*
result
=
{
{
resultDuration
time
}
total
}
;
return
true
;
}
static
bool
RoundDurationWeek
(
JSContext
*
cx
const
NormalizedDuration
&
duration
const
NormalizedTimeAndDays
&
timeAndDays
Increment
increment
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
dateRelativeTo
Handle
<
CalendarRecord
>
calendar
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
static
constexpr
int32_t
epochDays
=
200
'
000
'
000
;
auto
[
years
months
weeks
days
]
=
duration
.
date
;
auto
*
unwrappedRelativeTo
=
dateRelativeTo
.
unwrap
(
cx
)
;
if
(
!
unwrappedRelativeTo
)
{
return
false
;
}
auto
relativeToDate
=
ToPlainDate
(
unwrappedRelativeTo
)
;
double
truncatedDays
;
if
(
!
TruncateDays
(
cx
timeAndDays
days
0
&
truncatedDays
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
truncatedDays
)
)
;
PlainDate
isoResult
;
if
(
!
AddISODate
(
cx
relativeToDate
{
0
0
0
truncatedDays
}
TemporalOverflow
:
:
Constrain
&
isoResult
)
)
{
return
false
;
}
Rooted
<
PlainDateObject
*
>
wholeDaysLater
(
cx
CreateTemporalDate
(
cx
isoResult
calendar
.
receiver
(
)
)
)
;
if
(
!
wholeDaysLater
)
{
return
false
;
}
Duration
timePassed
;
if
(
!
DifferenceDate
(
cx
calendar
dateRelativeTo
wholeDaysLater
TemporalUnit
:
:
Week
&
timePassed
)
)
{
return
false
;
}
double
weeksPassed
=
timePassed
.
weeks
;
Duration
weeksPassedDuration
=
{
0
0
weeksPassed
}
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
newRelativeTo
(
cx
)
;
int32_t
daysPassed
;
if
(
!
MoveRelativeDate
(
cx
calendar
dateRelativeTo
weeksPassedDuration
&
newRelativeTo
&
daysPassed
)
)
{
return
false
;
}
MOZ_ASSERT
(
std
:
:
abs
(
daysPassed
)
<
=
epochDays
)
;
int32_t
daysToAdd
=
-
daysPassed
;
MOZ_ASSERT
(
std
:
:
abs
(
daysToAdd
)
<
=
epochDays
)
;
double
sign
=
DaysIsNegative
(
days
timeAndDays
daysToAdd
)
?
-
1
:
1
;
Duration
oneWeek
=
{
0
0
sign
}
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
moveResultIgnored
(
cx
)
;
int32_t
oneWeekDays
;
if
(
!
MoveRelativeDate
(
cx
calendar
newRelativeTo
oneWeek
&
moveResultIgnored
&
oneWeekDays
)
)
{
return
false
;
}
if
(
oneWeekDays
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_NUMBER
"
days
"
)
;
return
false
;
}
RoundedNumber
rounded
;
if
(
!
RoundNumberToIncrement
(
cx
weeks
weeksPassed
days
daysToAdd
timeAndDays
oneWeekDays
increment
roundingMode
computeRemainder
&
rounded
)
)
{
return
false
;
}
auto
[
numWeeks
total
]
=
rounded
;
constexpr
auto
time
=
NormalizedTimeDuration
{
}
;
auto
resultDuration
=
DateDuration
{
years
months
numWeeks
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
resultDuration
)
)
{
return
false
;
}
*
result
=
{
{
resultDuration
time
}
total
}
;
return
true
;
}
static
bool
RoundDurationDay
(
JSContext
*
cx
const
NormalizedDuration
&
duration
const
NormalizedTimeAndDays
&
timeAndDays
Increment
increment
TemporalRoundingMode
roundingMode
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
auto
[
years
months
weeks
days
]
=
duration
.
date
;
RoundedNumber
rounded
;
if
(
!
RoundNumberToIncrement
(
cx
days
timeAndDays
increment
roundingMode
computeRemainder
&
rounded
)
)
{
return
false
;
}
auto
[
numDays
total
]
=
rounded
;
constexpr
auto
time
=
NormalizedTimeDuration
{
}
;
auto
resultDuration
=
DateDuration
{
years
months
weeks
numDays
}
;
if
(
!
ThrowIfInvalidDuration
(
cx
resultDuration
)
)
{
return
false
;
}
*
result
=
{
{
resultDuration
time
}
total
}
;
return
true
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
MOZ_ASSERT_IF
(
computeRemainder
=
=
ComputeRemainder
:
:
Yes
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT_IF
(
computeRemainder
=
=
ComputeRemainder
:
:
Yes
roundingMode
=
=
TemporalRoundingMode
:
:
Trunc
)
;
if
(
unit
<
=
TemporalUnit
:
:
Week
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_UNCOMPARABLE
"
relativeTo
"
)
;
return
false
;
}
if
(
unit
=
=
TemporalUnit
:
:
Day
)
{
auto
timeAndDays
=
NormalizedTimeDurationToDays
(
duration
.
time
)
;
return
RoundDurationDay
(
cx
duration
timeAndDays
increment
roundingMode
computeRemainder
result
)
;
}
MOZ_ASSERT
(
TemporalUnit
:
:
Hour
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Nanosecond
)
;
auto
time
=
duration
.
time
;
double
total
=
0
;
if
(
computeRemainder
=
=
ComputeRemainder
:
:
No
)
{
time
=
RoundNormalizedTimeDurationToIncrement
(
time
unit
increment
roundingMode
)
;
}
else
{
MOZ_ASSERT
(
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT
(
roundingMode
=
=
TemporalRoundingMode
:
:
Trunc
)
;
total
=
TotalNormalizedTimeDuration
(
duration
.
time
unit
)
;
}
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
time
)
)
;
MOZ_ASSERT
(
IsValidDuration
(
duration
.
date
.
toDuration
(
)
)
)
;
*
result
=
{
{
duration
.
date
time
}
total
}
;
return
true
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
ComputeRemainder
computeRemainder
RoundedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
Duration
{
duration
.
date
.
years
duration
.
date
.
months
duration
.
date
.
weeks
}
)
)
;
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
duration
.
time
)
)
;
MOZ_ASSERT
(
plainRelativeTo
|
|
zonedRelativeTo
"
Use
RoundDuration
without
relativeTo
when
plainRelativeTo
and
"
"
zonedRelativeTo
are
both
undefined
"
)
;
MOZ_ASSERT_IF
(
computeRemainder
=
=
ComputeRemainder
:
:
Yes
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT_IF
(
computeRemainder
=
=
ComputeRemainder
:
:
Yes
roundingMode
=
=
TemporalRoundingMode
:
:
Trunc
)
;
MOZ_ASSERT_IF
(
unit
<
=
TemporalUnit
:
:
Week
plainRelativeTo
)
;
MOZ_ASSERT_IF
(
unit
<
=
TemporalUnit
:
:
Week
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateAdd
)
)
;
MOZ_ASSERT_IF
(
unit
<
=
TemporalUnit
:
:
Week
CalendarMethodsRecordHasLookedUp
(
calendar
CalendarMethod
:
:
DateUntil
)
)
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
case
TemporalUnit
:
:
Month
:
case
TemporalUnit
:
:
Week
:
break
;
case
TemporalUnit
:
:
Day
:
if
(
zonedRelativeTo
)
{
break
;
}
[
[
fallthrough
]
]
;
case
TemporalUnit
:
:
Hour
:
case
TemporalUnit
:
:
Minute
:
case
TemporalUnit
:
:
Second
:
case
TemporalUnit
:
:
Millisecond
:
case
TemporalUnit
:
:
Microsecond
:
case
TemporalUnit
:
:
Nanosecond
:
return
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
computeRemainder
result
)
;
case
TemporalUnit
:
:
Auto
:
MOZ_CRASH
(
"
Unexpected
temporal
unit
"
)
;
}
MOZ_ASSERT
(
TemporalUnit
:
:
Year
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Day
)
;
NormalizedTimeAndDays
timeAndDays
;
if
(
zonedRelativeTo
)
{
Rooted
<
ZonedDateTime
>
intermediate
(
cx
)
;
if
(
!
MoveRelativeZonedDateTime
(
cx
zonedRelativeTo
calendar
timeZone
duration
.
date
precalculatedPlainDateTime
&
intermediate
)
)
{
return
false
;
}
if
(
!
NormalizedTimeDurationToDays
(
cx
duration
.
time
intermediate
timeZone
&
timeAndDays
)
)
{
return
false
;
}
}
else
{
timeAndDays
=
:
:
NormalizedTimeDurationToDays
(
duration
.
time
)
;
}
MOZ_ASSERT
(
timeAndDays
.
time
.
abs
(
)
<
timeAndDays
.
dayLength
)
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
RoundDurationYear
(
cx
duration
timeAndDays
increment
roundingMode
plainRelativeTo
calendar
computeRemainder
result
)
;
case
TemporalUnit
:
:
Month
:
return
RoundDurationMonth
(
cx
duration
timeAndDays
increment
roundingMode
plainRelativeTo
calendar
computeRemainder
result
)
;
case
TemporalUnit
:
:
Week
:
return
RoundDurationWeek
(
cx
duration
timeAndDays
increment
roundingMode
plainRelativeTo
calendar
computeRemainder
result
)
;
case
TemporalUnit
:
:
Day
:
return
RoundDurationDay
(
cx
duration
timeAndDays
increment
roundingMode
computeRemainder
result
)
;
case
TemporalUnit
:
:
Auto
:
case
TemporalUnit
:
:
Hour
:
case
TemporalUnit
:
:
Minute
:
case
TemporalUnit
:
:
Second
:
case
TemporalUnit
:
:
Millisecond
:
case
TemporalUnit
:
:
Microsecond
:
case
TemporalUnit
:
:
Nanosecond
:
break
;
}
MOZ_CRASH
(
"
Unexpected
temporal
unit
"
)
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
double
*
result
)
{
MOZ_ASSERT
(
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT
(
roundingMode
=
=
TemporalRoundingMode
:
:
Trunc
)
;
RoundedDuration
rounded
;
if
(
!
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
plainRelativeTo
calendar
zonedRelativeTo
timeZone
precalculatedPlainDateTime
ComputeRemainder
:
:
Yes
&
rounded
)
)
{
return
false
;
}
*
result
=
rounded
.
total
;
return
true
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
TimeZoneRecord
>
timeZone
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
NormalizedDuration
*
result
)
{
RoundedDuration
rounded
;
if
(
!
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
plainRelativeTo
calendar
zonedRelativeTo
timeZone
precalculatedPlainDateTime
ComputeRemainder
:
:
No
&
rounded
)
)
{
return
false
;
}
*
result
=
rounded
.
duration
;
return
true
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
double
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
MOZ_ASSERT
(
increment
=
=
Increment
{
1
}
)
;
MOZ_ASSERT
(
roundingMode
=
=
TemporalRoundingMode
:
:
Trunc
)
;
RoundedDuration
rounded
;
if
(
!
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
ComputeRemainder
:
:
Yes
&
rounded
)
)
{
return
false
;
}
*
result
=
rounded
.
total
;
return
true
;
}
static
bool
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
NormalizedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
RoundedDuration
rounded
;
if
(
!
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
ComputeRemainder
:
:
No
&
rounded
)
)
{
return
false
;
}
*
result
=
rounded
.
duration
;
return
true
;
}
bool
js
:
:
temporal
:
:
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
NormalizedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
Rooted
<
ZonedDateTime
>
zonedRelativeTo
(
cx
ZonedDateTime
{
}
)
;
Rooted
<
TimeZoneRecord
>
timeZone
(
cx
TimeZoneRecord
{
}
)
;
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
{
}
;
return
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
plainRelativeTo
calendar
zonedRelativeTo
timeZone
precalculatedPlainDateTime
result
)
;
}
bool
js
:
:
temporal
:
:
RoundDuration
(
JSContext
*
cx
const
NormalizedDuration
&
duration
Increment
increment
TemporalUnit
unit
TemporalRoundingMode
roundingMode
Handle
<
PlainDateObject
*
>
plainRelativeTo
Handle
<
CalendarRecord
>
calendar
Handle
<
ZonedDateTime
>
zonedRelativeTo
Handle
<
TimeZoneRecord
>
timeZone
const
PlainDateTime
&
precalculatedPlainDateTime
NormalizedDuration
*
result
)
{
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
return
:
:
RoundDuration
(
cx
duration
increment
unit
roundingMode
plainRelativeTo
calendar
zonedRelativeTo
timeZone
mozilla
:
:
SomeRef
(
precalculatedPlainDateTime
)
result
)
;
}
enum
class
DurationOperation
{
Add
Subtract
}
;
static
bool
AddDurationToOrSubtractDurationFromDuration
(
JSContext
*
cx
DurationOperation
operation
const
CallArgs
&
args
)
{
auto
*
durationObj
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
auto
duration
=
ToDuration
(
durationObj
)
;
Duration
other
;
if
(
!
ToTemporalDurationRecord
(
cx
args
.
get
(
0
)
&
other
)
)
{
return
false
;
}
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
(
cx
)
;
Rooted
<
ZonedDateTime
>
zonedRelativeTo
(
cx
)
;
Rooted
<
TimeZoneRecord
>
timeZone
(
cx
)
;
if
(
args
.
hasDefined
(
1
)
)
{
const
char
*
name
=
operation
=
=
DurationOperation
:
:
Add
?
"
add
"
:
"
subtract
"
;
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
name
args
[
1
]
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
ToRelativeTemporalObject
(
cx
options
&
plainRelativeTo
&
zonedRelativeTo
&
timeZone
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
plainRelativeTo
|
|
!
zonedRelativeTo
)
;
MOZ_ASSERT_IF
(
zonedRelativeTo
timeZone
.
receiver
(
)
)
;
}
Rooted
<
CalendarRecord
>
calendar
(
cx
)
;
if
(
!
CreateCalendarMethodsRecordFromRelativeTo
(
cx
plainRelativeTo
zonedRelativeTo
{
CalendarMethod
:
:
DateAdd
CalendarMethod
:
:
DateUntil
}
&
calendar
)
)
{
return
false
;
}
if
(
operation
=
=
DurationOperation
:
:
Subtract
)
{
other
=
other
.
negate
(
)
;
}
Duration
result
;
if
(
plainRelativeTo
)
{
if
(
!
AddDuration
(
cx
duration
other
plainRelativeTo
calendar
&
result
)
)
{
return
false
;
}
}
else
if
(
zonedRelativeTo
)
{
if
(
!
AddDuration
(
cx
duration
other
zonedRelativeTo
calendar
timeZone
&
result
)
)
{
return
false
;
}
}
else
{
if
(
!
AddDuration
(
cx
duration
other
&
result
)
)
{
return
false
;
}
}
auto
*
obj
=
CreateTemporalDuration
(
cx
result
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
DurationConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Temporal
.
Duration
"
)
)
{
return
false
;
}
double
years
=
0
;
if
(
args
.
hasDefined
(
0
)
&
&
!
ToIntegerIfIntegral
(
cx
"
years
"
args
[
0
]
&
years
)
)
{
return
false
;
}
double
months
=
0
;
if
(
args
.
hasDefined
(
1
)
&
&
!
ToIntegerIfIntegral
(
cx
"
months
"
args
[
1
]
&
months
)
)
{
return
false
;
}
double
weeks
=
0
;
if
(
args
.
hasDefined
(
2
)
&
&
!
ToIntegerIfIntegral
(
cx
"
weeks
"
args
[
2
]
&
weeks
)
)
{
return
false
;
}
double
days
=
0
;
if
(
args
.
hasDefined
(
3
)
&
&
!
ToIntegerIfIntegral
(
cx
"
days
"
args
[
3
]
&
days
)
)
{
return
false
;
}
double
hours
=
0
;
if
(
args
.
hasDefined
(
4
)
&
&
!
ToIntegerIfIntegral
(
cx
"
hours
"
args
[
4
]
&
hours
)
)
{
return
false
;
}
double
minutes
=
0
;
if
(
args
.
hasDefined
(
5
)
&
&
!
ToIntegerIfIntegral
(
cx
"
minutes
"
args
[
5
]
&
minutes
)
)
{
return
false
;
}
double
seconds
=
0
;
if
(
args
.
hasDefined
(
6
)
&
&
!
ToIntegerIfIntegral
(
cx
"
seconds
"
args
[
6
]
&
seconds
)
)
{
return
false
;
}
double
milliseconds
=
0
;
if
(
args
.
hasDefined
(
7
)
&
&
!
ToIntegerIfIntegral
(
cx
"
milliseconds
"
args
[
7
]
&
milliseconds
)
)
{
return
false
;
}
double
microseconds
=
0
;
if
(
args
.
hasDefined
(
8
)
&
&
!
ToIntegerIfIntegral
(
cx
"
microseconds
"
args
[
8
]
&
microseconds
)
)
{
return
false
;
}
double
nanoseconds
=
0
;
if
(
args
.
hasDefined
(
9
)
&
&
!
ToIntegerIfIntegral
(
cx
"
nanoseconds
"
args
[
9
]
&
nanoseconds
)
)
{
return
false
;
}
auto
*
duration
=
CreateTemporalDuration
(
cx
args
{
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
)
;
if
(
!
duration
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
duration
)
;
return
true
;
}
static
bool
Duration_from
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Handle
<
Value
>
item
=
args
.
get
(
0
)
;
if
(
item
.
isObject
(
)
)
{
if
(
auto
*
duration
=
item
.
toObject
(
)
.
maybeUnwrapIf
<
DurationObject
>
(
)
)
{
auto
*
result
=
CreateTemporalDuration
(
cx
ToDuration
(
duration
)
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
}
auto
result
=
ToTemporalDuration
(
cx
item
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Duration_compare
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Duration
one
;
if
(
!
ToTemporalDuration
(
cx
args
.
get
(
0
)
&
one
)
)
{
return
false
;
}
Duration
two
;
if
(
!
ToTemporalDuration
(
cx
args
.
get
(
1
)
&
two
)
)
{
return
false
;
}
Rooted
<
JSObject
*
>
options
(
cx
)
;
if
(
args
.
hasDefined
(
2
)
)
{
options
=
RequireObjectArg
(
cx
"
options
"
"
compare
"
args
[
2
]
)
;
if
(
!
options
)
{
return
false
;
}
}
if
(
one
=
=
two
)
{
args
.
rval
(
)
.
setInt32
(
0
)
;
return
true
;
}
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
(
cx
)
;
Rooted
<
ZonedDateTime
>
zonedRelativeTo
(
cx
)
;
Rooted
<
TimeZoneRecord
>
timeZone
(
cx
)
;
if
(
options
)
{
if
(
!
ToRelativeTemporalObject
(
cx
options
&
plainRelativeTo
&
zonedRelativeTo
&
timeZone
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
plainRelativeTo
|
|
!
zonedRelativeTo
)
;
MOZ_ASSERT_IF
(
zonedRelativeTo
timeZone
.
receiver
(
)
)
;
}
auto
hasCalendarUnit
=
[
]
(
const
auto
&
d
)
{
return
d
.
years
!
=
0
|
|
d
.
months
!
=
0
|
|
d
.
weeks
!
=
0
;
}
;
bool
calendarUnitsPresent
=
hasCalendarUnit
(
one
)
|
|
hasCalendarUnit
(
two
)
;
Rooted
<
CalendarRecord
>
calendar
(
cx
)
;
if
(
!
CreateCalendarMethodsRecordFromRelativeTo
(
cx
plainRelativeTo
zonedRelativeTo
{
CalendarMethod
:
:
DateAdd
}
&
calendar
)
)
{
return
false
;
}
if
(
zonedRelativeTo
&
&
(
calendarUnitsPresent
|
|
one
.
days
!
=
0
|
|
two
.
days
!
=
0
)
)
{
const
auto
&
instant
=
zonedRelativeTo
.
instant
(
)
;
PlainDateTime
dateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
instant
&
dateTime
)
)
{
return
false
;
}
auto
normalized1
=
CreateNormalizedDurationRecord
(
one
)
;
auto
normalized2
=
CreateNormalizedDurationRecord
(
two
)
;
Instant
after1
;
if
(
!
AddZonedDateTime
(
cx
instant
timeZone
calendar
normalized1
dateTime
&
after1
)
)
{
return
false
;
}
Instant
after2
;
if
(
!
AddZonedDateTime
(
cx
instant
timeZone
calendar
normalized2
dateTime
&
after2
)
)
{
return
false
;
}
args
.
rval
(
)
.
setInt32
(
after1
<
after2
?
-
1
:
after1
>
after2
?
1
:
0
)
;
return
true
;
}
double
days1
days2
;
if
(
calendarUnitsPresent
)
{
DateDuration
unbalanceResult1
;
if
(
plainRelativeTo
)
{
if
(
!
UnbalanceDateDurationRelative
(
cx
one
.
toDateDuration
(
)
TemporalUnit
:
:
Day
plainRelativeTo
calendar
&
unbalanceResult1
)
)
{
return
false
;
}
}
else
{
if
(
!
UnbalanceDateDurationRelative
(
cx
one
.
toDateDuration
(
)
TemporalUnit
:
:
Day
&
unbalanceResult1
)
)
{
return
false
;
}
MOZ_ASSERT
(
one
.
toDateDuration
(
)
=
=
unbalanceResult1
)
;
}
DateDuration
unbalanceResult2
;
if
(
plainRelativeTo
)
{
if
(
!
UnbalanceDateDurationRelative
(
cx
two
.
toDateDuration
(
)
TemporalUnit
:
:
Day
plainRelativeTo
calendar
&
unbalanceResult2
)
)
{
return
false
;
}
}
else
{
if
(
!
UnbalanceDateDurationRelative
(
cx
two
.
toDateDuration
(
)
TemporalUnit
:
:
Day
&
unbalanceResult2
)
)
{
return
false
;
}
MOZ_ASSERT
(
two
.
toDateDuration
(
)
=
=
unbalanceResult2
)
;
}
days1
=
unbalanceResult1
.
days
;
days2
=
unbalanceResult2
.
days
;
}
else
{
days1
=
one
.
days
;
days2
=
two
.
days
;
}
auto
normalized1
=
NormalizeTimeDuration
(
one
)
;
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
normalized1
days1
&
normalized1
)
)
{
return
false
;
}
auto
normalized2
=
NormalizeTimeDuration
(
two
)
;
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
normalized2
days2
&
normalized2
)
)
{
return
false
;
}
args
.
rval
(
)
.
setInt32
(
CompareNormalizedTimeDuration
(
normalized1
normalized2
)
)
;
return
true
;
}
static
bool
Duration_years
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
years
(
)
)
;
return
true
;
}
static
bool
Duration_years
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_years
>
(
cx
args
)
;
}
static
bool
Duration_months
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
months
(
)
)
;
return
true
;
}
static
bool
Duration_months
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_months
>
(
cx
args
)
;
}
static
bool
Duration_weeks
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
weeks
(
)
)
;
return
true
;
}
static
bool
Duration_weeks
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_weeks
>
(
cx
args
)
;
}
static
bool
Duration_days
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
days
(
)
)
;
return
true
;
}
static
bool
Duration_days
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_days
>
(
cx
args
)
;
}
static
bool
Duration_hours
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
hours
(
)
)
;
return
true
;
}
static
bool
Duration_hours
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_hours
>
(
cx
args
)
;
}
static
bool
Duration_minutes
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
minutes
(
)
)
;
return
true
;
}
static
bool
Duration_minutes
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_minutes
>
(
cx
args
)
;
}
static
bool
Duration_seconds
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
seconds
(
)
)
;
return
true
;
}
static
bool
Duration_seconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_seconds
>
(
cx
args
)
;
}
static
bool
Duration_milliseconds
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
milliseconds
(
)
)
;
return
true
;
}
static
bool
Duration_milliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_milliseconds
>
(
cx
args
)
;
}
static
bool
Duration_microseconds
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
microseconds
(
)
)
;
return
true
;
}
static
bool
Duration_microseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_microseconds
>
(
cx
args
)
;
}
static
bool
Duration_nanoseconds
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
duration
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
duration
-
>
nanoseconds
(
)
)
;
return
true
;
}
static
bool
Duration_nanoseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_nanoseconds
>
(
cx
args
)
;
}
static
bool
Duration_sign
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
args
.
rval
(
)
.
setInt32
(
DurationSign
(
duration
)
)
;
return
true
;
}
static
bool
Duration_sign
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_sign
>
(
cx
args
)
;
}
static
bool
Duration_blank
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
duration
=
=
Duration
{
}
)
;
return
true
;
}
static
bool
Duration_blank
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_blank
>
(
cx
args
)
;
}
static
bool
Duration_with
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
Rooted
<
JSObject
*
>
temporalDurationLike
(
cx
RequireObjectArg
(
cx
"
temporalDurationLike
"
"
with
"
args
.
get
(
0
)
)
)
;
if
(
!
temporalDurationLike
)
{
return
false
;
}
if
(
!
ToTemporalPartialDurationRecord
(
cx
temporalDurationLike
&
duration
)
)
{
return
false
;
}
auto
*
result
=
CreateTemporalDuration
(
cx
duration
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Duration_with
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_with
>
(
cx
args
)
;
}
static
bool
Duration_negated
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
auto
*
result
=
CreateTemporalDuration
(
cx
duration
.
negate
(
)
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Duration_negated
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_negated
>
(
cx
args
)
;
}
static
bool
Duration_abs
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
auto
*
result
=
CreateTemporalDuration
(
cx
AbsoluteDuration
(
duration
)
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Duration_abs
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_abs
>
(
cx
args
)
;
}
static
bool
Duration_add
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
AddDurationToOrSubtractDurationFromDuration
(
cx
DurationOperation
:
:
Add
args
)
;
}
static
bool
Duration_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_add
>
(
cx
args
)
;
}
static
bool
Duration_subtract
(
JSContext
*
cx
const
CallArgs
&
args
)
{
return
AddDurationToOrSubtractDurationFromDuration
(
cx
DurationOperation
:
:
Subtract
args
)
;
}
static
bool
Duration_subtract
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_subtract
>
(
cx
args
)
;
}
static
bool
Duration_round
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
auto
existingLargestUnit
=
DefaultTemporalLargestUnit
(
duration
)
;
auto
smallestUnit
=
TemporalUnit
:
:
Auto
;
TemporalUnit
largestUnit
;
auto
roundingMode
=
TemporalRoundingMode
:
:
HalfExpand
;
auto
roundingIncrement
=
Increment
{
1
}
;
Rooted
<
JSObject
*
>
relativeTo
(
cx
)
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
(
cx
)
;
Rooted
<
ZonedDateTime
>
zonedRelativeTo
(
cx
)
;
Rooted
<
TimeZoneRecord
>
timeZone
(
cx
)
;
if
(
args
.
get
(
0
)
.
isString
(
)
)
{
Rooted
<
JSString
*
>
paramString
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
GetTemporalUnit
(
cx
paramString
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
DateTime
&
smallestUnit
)
)
{
return
false
;
}
auto
defaultLargestUnit
=
std
:
:
min
(
existingLargestUnit
smallestUnit
)
;
largestUnit
=
defaultLargestUnit
;
}
else
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
roundTo
"
"
round
"
args
.
get
(
0
)
)
)
;
if
(
!
options
)
{
return
false
;
}
bool
smallestUnitPresent
=
true
;
bool
largestUnitPresent
=
true
;
Rooted
<
Value
>
largestUnitValue
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
cx
-
>
names
(
)
.
largestUnit
&
largestUnitValue
)
)
{
return
false
;
}
if
(
!
largestUnitValue
.
isUndefined
(
)
)
{
Rooted
<
JSString
*
>
largestUnitStr
(
cx
JS
:
:
ToString
(
cx
largestUnitValue
)
)
;
if
(
!
largestUnitStr
)
{
return
false
;
}
largestUnit
=
TemporalUnit
:
:
Auto
;
if
(
!
GetTemporalUnit
(
cx
largestUnitStr
TemporalUnitKey
:
:
LargestUnit
TemporalUnitGroup
:
:
DateTime
&
largestUnit
)
)
{
return
false
;
}
}
if
(
!
ToRelativeTemporalObject
(
cx
options
&
plainRelativeTo
&
zonedRelativeTo
&
timeZone
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
plainRelativeTo
|
|
!
zonedRelativeTo
)
;
MOZ_ASSERT_IF
(
zonedRelativeTo
timeZone
.
receiver
(
)
)
;
if
(
!
ToTemporalRoundingIncrement
(
cx
options
&
roundingIncrement
)
)
{
return
false
;
}
if
(
!
ToTemporalRoundingMode
(
cx
options
&
roundingMode
)
)
{
return
false
;
}
if
(
!
GetTemporalUnit
(
cx
options
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
DateTime
&
smallestUnit
)
)
{
return
false
;
}
if
(
smallestUnit
=
=
TemporalUnit
:
:
Auto
)
{
smallestUnitPresent
=
false
;
smallestUnit
=
TemporalUnit
:
:
Nanosecond
;
}
auto
defaultLargestUnit
=
std
:
:
min
(
existingLargestUnit
smallestUnit
)
;
if
(
largestUnitValue
.
isUndefined
(
)
)
{
largestUnitPresent
=
false
;
largestUnit
=
defaultLargestUnit
;
}
else
if
(
largestUnit
=
=
TemporalUnit
:
:
Auto
)
{
largestUnit
=
defaultLargestUnit
;
}
if
(
!
smallestUnitPresent
&
&
!
largestUnitPresent
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_DURATION_MISSING_UNIT_SPECIFIER
)
;
return
false
;
}
if
(
largestUnit
>
smallestUnit
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_UNIT_RANGE
)
;
return
false
;
}
if
(
smallestUnit
>
TemporalUnit
:
:
Day
)
{
auto
maximum
=
MaximumTemporalDurationRoundingIncrement
(
smallestUnit
)
;
if
(
!
ValidateTemporalRoundingIncrement
(
cx
roundingIncrement
maximum
false
)
)
{
return
false
;
}
}
}
bool
hoursToDaysConversionMayOccur
=
false
;
if
(
duration
.
days
!
=
0
&
&
zonedRelativeTo
)
{
hoursToDaysConversionMayOccur
=
true
;
}
else
if
(
std
:
:
abs
(
duration
.
hours
)
>
=
24
)
{
hoursToDaysConversionMayOccur
=
true
;
}
bool
roundingGranularityIsNoop
=
smallestUnit
=
=
TemporalUnit
:
:
Nanosecond
&
&
roundingIncrement
=
=
Increment
{
1
}
;
bool
calendarUnitsPresent
=
duration
.
years
!
=
0
|
|
duration
.
months
!
=
0
|
|
duration
.
weeks
!
=
0
;
if
(
roundingGranularityIsNoop
&
&
largestUnit
=
=
existingLargestUnit
&
&
!
calendarUnitsPresent
&
&
!
hoursToDaysConversionMayOccur
&
&
std
:
:
abs
(
duration
.
minutes
)
<
60
&
&
std
:
:
abs
(
duration
.
seconds
)
<
60
&
&
std
:
:
abs
(
duration
.
milliseconds
)
<
1000
&
&
std
:
:
abs
(
duration
.
microseconds
)
<
1000
&
&
std
:
:
abs
(
duration
.
nanoseconds
)
<
1000
)
{
auto
*
obj
=
CreateTemporalDuration
(
cx
duration
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
{
}
;
bool
plainDateTimeOrRelativeToWillBeUsed
=
!
roundingGranularityIsNoop
|
|
largestUnit
<
=
TemporalUnit
:
:
Day
|
|
calendarUnitsPresent
|
|
duration
.
days
!
=
0
;
PlainDateTime
relativeToDateTime
;
if
(
zonedRelativeTo
&
&
plainDateTimeOrRelativeToWillBeUsed
)
{
const
auto
&
instant
=
zonedRelativeTo
.
instant
(
)
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
instant
&
relativeToDateTime
)
)
{
return
false
;
}
precalculatedPlainDateTime
=
mozilla
:
:
SomeRef
<
const
PlainDateTime
>
(
relativeToDateTime
)
;
plainRelativeTo
=
CreateTemporalDate
(
cx
relativeToDateTime
.
date
zonedRelativeTo
.
calendar
(
)
)
;
if
(
!
plainRelativeTo
)
{
return
false
;
}
}
Rooted
<
CalendarRecord
>
calendar
(
cx
)
;
if
(
!
CreateCalendarMethodsRecordFromRelativeTo
(
cx
plainRelativeTo
zonedRelativeTo
{
CalendarMethod
:
:
DateAdd
CalendarMethod
:
:
DateUntil
}
&
calendar
)
)
{
return
false
;
}
DateDuration
unbalanceResult
;
if
(
plainRelativeTo
)
{
if
(
!
UnbalanceDateDurationRelative
(
cx
duration
.
toDateDuration
(
)
largestUnit
plainRelativeTo
calendar
&
unbalanceResult
)
)
{
return
false
;
}
}
else
{
if
(
!
UnbalanceDateDurationRelative
(
cx
duration
.
toDateDuration
(
)
largestUnit
&
unbalanceResult
)
)
{
return
false
;
}
MOZ_ASSERT
(
duration
.
toDateDuration
(
)
=
=
unbalanceResult
)
;
}
auto
roundInput
=
NormalizedDuration
{
unbalanceResult
NormalizeTimeDuration
(
duration
)
}
;
NormalizedDuration
roundResult
;
if
(
plainRelativeTo
|
|
zonedRelativeTo
)
{
if
(
!
:
:
RoundDuration
(
cx
roundInput
roundingIncrement
smallestUnit
roundingMode
plainRelativeTo
calendar
zonedRelativeTo
timeZone
precalculatedPlainDateTime
&
roundResult
)
)
{
return
false
;
}
}
else
{
if
(
!
:
:
RoundDuration
(
cx
roundInput
roundingIncrement
smallestUnit
roundingMode
&
roundResult
)
)
{
return
false
;
}
}
TimeDuration
balanceResult
;
if
(
zonedRelativeTo
)
{
NormalizedDuration
adjustResult
;
if
(
!
AdjustRoundedDurationDays
(
cx
roundResult
roundingIncrement
smallestUnit
roundingMode
zonedRelativeTo
calendar
timeZone
precalculatedPlainDateTime
&
adjustResult
)
)
{
return
false
;
}
roundResult
=
adjustResult
;
if
(
!
BalanceTimeDurationRelative
(
cx
roundResult
largestUnit
zonedRelativeTo
timeZone
precalculatedPlainDateTime
&
balanceResult
)
)
{
return
false
;
}
}
else
{
NormalizedTimeDuration
withDays
;
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
roundResult
.
time
roundResult
.
date
.
days
&
withDays
)
)
{
return
false
;
}
balanceResult
=
temporal
:
:
BalanceTimeDuration
(
withDays
largestUnit
)
;
}
DateDuration
balanceInput
=
{
roundResult
.
date
.
years
roundResult
.
date
.
months
roundResult
.
date
.
weeks
balanceResult
.
days
}
;
DateDuration
dateResult
;
if
(
!
:
:
BalanceDateDurationRelative
(
cx
balanceInput
largestUnit
smallestUnit
plainRelativeTo
calendar
&
dateResult
)
)
{
return
false
;
}
auto
result
=
Duration
{
dateResult
.
years
dateResult
.
months
dateResult
.
weeks
dateResult
.
days
balanceResult
.
hours
balanceResult
.
minutes
balanceResult
.
seconds
balanceResult
.
milliseconds
balanceResult
.
microseconds
balanceResult
.
nanoseconds
}
;
MOZ_ASSERT
(
IsValidDuration
(
result
)
)
;
auto
*
obj
=
CreateTemporalDuration
(
cx
result
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
Duration_round
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_round
>
(
cx
args
)
;
}
static
bool
Duration_total
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
durationObj
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
;
auto
duration
=
ToDuration
(
durationObj
)
;
Rooted
<
JSObject
*
>
relativeTo
(
cx
)
;
Rooted
<
Wrapped
<
PlainDateObject
*
>
>
plainRelativeTo
(
cx
)
;
Rooted
<
ZonedDateTime
>
zonedRelativeTo
(
cx
)
;
Rooted
<
TimeZoneRecord
>
timeZone
(
cx
)
;
auto
unit
=
TemporalUnit
:
:
Auto
;
if
(
args
.
get
(
0
)
.
isString
(
)
)
{
MOZ_ASSERT
(
!
plainRelativeTo
&
&
!
zonedRelativeTo
)
;
Rooted
<
JSString
*
>
paramString
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
GetTemporalUnit
(
cx
paramString
TemporalUnitKey
:
:
Unit
TemporalUnitGroup
:
:
DateTime
&
unit
)
)
{
return
false
;
}
}
else
{
Rooted
<
JSObject
*
>
totalOf
(
cx
RequireObjectArg
(
cx
"
totalOf
"
"
total
"
args
.
get
(
0
)
)
)
;
if
(
!
totalOf
)
{
return
false
;
}
if
(
!
ToRelativeTemporalObject
(
cx
totalOf
&
plainRelativeTo
&
zonedRelativeTo
&
timeZone
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
plainRelativeTo
|
|
!
zonedRelativeTo
)
;
MOZ_ASSERT_IF
(
zonedRelativeTo
timeZone
.
receiver
(
)
)
;
if
(
!
GetTemporalUnit
(
cx
totalOf
TemporalUnitKey
:
:
Unit
TemporalUnitGroup
:
:
DateTime
&
unit
)
)
{
return
false
;
}
if
(
unit
=
=
TemporalUnit
:
:
Auto
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_MISSING_OPTION
"
unit
"
)
;
return
false
;
}
}
mozilla
:
:
Maybe
<
const
PlainDateTime
&
>
precalculatedPlainDateTime
{
}
;
bool
plainDateTimeOrRelativeToWillBeUsed
=
unit
<
=
TemporalUnit
:
:
Day
|
|
duration
.
toDateDuration
(
)
!
=
DateDuration
{
}
;
PlainDateTime
relativeToDateTime
;
if
(
zonedRelativeTo
&
&
plainDateTimeOrRelativeToWillBeUsed
)
{
const
auto
&
instant
=
zonedRelativeTo
.
instant
(
)
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
instant
&
relativeToDateTime
)
)
{
return
false
;
}
precalculatedPlainDateTime
=
mozilla
:
:
SomeRef
<
const
PlainDateTime
>
(
relativeToDateTime
)
;
plainRelativeTo
=
CreateTemporalDate
(
cx
relativeToDateTime
.
date
zonedRelativeTo
.
calendar
(
)
)
;
if
(
!
plainRelativeTo
)
{
return
false
;
}
}
Rooted
<
CalendarRecord
>
calendar
(
cx
)
;
if
(
!
CreateCalendarMethodsRecordFromRelativeTo
(
cx
plainRelativeTo
zonedRelativeTo
{
CalendarMethod
:
:
DateAdd
CalendarMethod
:
:
DateUntil
}
&
calendar
)
)
{
return
false
;
}
DateDuration
unbalanceResult
;
if
(
plainRelativeTo
)
{
if
(
!
UnbalanceDateDurationRelative
(
cx
duration
.
toDateDuration
(
)
unit
plainRelativeTo
calendar
&
unbalanceResult
)
)
{
return
false
;
}
}
else
{
if
(
!
UnbalanceDateDurationRelative
(
cx
duration
.
toDateDuration
(
)
unit
&
unbalanceResult
)
)
{
return
false
;
}
MOZ_ASSERT
(
duration
.
toDateDuration
(
)
=
=
unbalanceResult
)
;
}
double
unbalancedDays
=
unbalanceResult
.
days
;
int64_t
days
;
NormalizedTimeDuration
balanceResult
;
if
(
zonedRelativeTo
)
{
Rooted
<
ZonedDateTime
>
intermediate
(
cx
)
;
if
(
!
MoveRelativeZonedDateTime
(
cx
zonedRelativeTo
calendar
timeZone
{
unbalanceResult
.
years
unbalanceResult
.
months
unbalanceResult
.
weeks
0
}
precalculatedPlainDateTime
&
intermediate
)
)
{
return
false
;
}
auto
timeDuration
=
NormalizeTimeDuration
(
duration
)
;
const
auto
&
startNs
=
intermediate
.
instant
(
)
;
const
auto
&
startInstant
=
startNs
;
mozilla
:
:
Maybe
<
PlainDateTime
>
startDateTime
{
}
;
Instant
intermediateNs
;
if
(
unbalancedDays
!
=
0
)
{
PlainDateTime
dateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
startInstant
&
dateTime
)
)
{
return
false
;
}
startDateTime
=
mozilla
:
:
Some
(
dateTime
)
;
Rooted
<
CalendarValue
>
isoCalendar
(
cx
CalendarValue
(
cx
-
>
names
(
)
.
iso8601
)
)
;
Instant
addResult
;
if
(
!
AddDaysToZonedDateTime
(
cx
startInstant
dateTime
timeZone
isoCalendar
unbalancedDays
&
addResult
)
)
{
return
false
;
}
intermediateNs
=
addResult
;
}
else
{
intermediateNs
=
startNs
;
}
Instant
endNs
;
if
(
!
AddInstant
(
cx
intermediateNs
timeDuration
&
endNs
)
)
{
return
false
;
}
auto
difference
=
NormalizedTimeDurationFromEpochNanosecondsDifference
(
endNs
startNs
)
;
if
(
TemporalUnit
:
:
Year
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Day
&
&
difference
!
=
NormalizedTimeDuration
{
}
)
{
if
(
!
startDateTime
)
{
PlainDateTime
dateTime
;
if
(
!
GetPlainDateTimeFor
(
cx
timeZone
startInstant
&
dateTime
)
)
{
return
false
;
}
startDateTime
=
mozilla
:
:
Some
(
dateTime
)
;
}
NormalizedTimeAndDays
timeAndDays
;
if
(
!
NormalizedTimeDurationToDays
(
cx
difference
intermediate
timeZone
*
startDateTime
&
timeAndDays
)
)
{
return
false
;
}
balanceResult
=
timeAndDays
.
time
;
days
=
timeAndDays
.
days
;
}
else
{
balanceResult
=
difference
;
days
=
0
;
}
}
else
{
auto
timeDuration
=
NormalizeTimeDuration
(
duration
)
;
if
(
!
Add24HourDaysToNormalizedTimeDuration
(
cx
timeDuration
unbalancedDays
&
balanceResult
)
)
{
return
false
;
}
days
=
0
;
}
MOZ_ASSERT
(
IsValidNormalizedTimeDuration
(
balanceResult
)
)
;
auto
roundInput
=
NormalizedDuration
{
{
unbalanceResult
.
years
unbalanceResult
.
months
unbalanceResult
.
weeks
double
(
days
)
}
balanceResult
}
;
double
total
;
if
(
plainRelativeTo
|
|
zonedRelativeTo
)
{
if
(
!
:
:
RoundDuration
(
cx
roundInput
Increment
{
1
}
unit
TemporalRoundingMode
:
:
Trunc
plainRelativeTo
calendar
zonedRelativeTo
timeZone
precalculatedPlainDateTime
&
total
)
)
{
return
false
;
}
}
else
{
if
(
!
:
:
RoundDuration
(
cx
roundInput
Increment
{
1
}
unit
TemporalRoundingMode
:
:
Trunc
&
total
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setNumber
(
total
)
;
return
true
;
}
static
bool
Duration_total
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_total
>
(
cx
args
)
;
}
static
bool
Duration_toString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
SecondsStringPrecision
precision
=
{
Precision
:
:
Auto
(
)
TemporalUnit
:
:
Nanosecond
Increment
{
1
}
}
;
auto
roundingMode
=
TemporalRoundingMode
:
:
Trunc
;
if
(
args
.
hasDefined
(
0
)
)
{
Rooted
<
JSObject
*
>
options
(
cx
RequireObjectArg
(
cx
"
options
"
"
toString
"
args
[
0
]
)
)
;
if
(
!
options
)
{
return
false
;
}
auto
digits
=
Precision
:
:
Auto
(
)
;
if
(
!
ToFractionalSecondDigits
(
cx
options
&
digits
)
)
{
return
false
;
}
if
(
!
ToTemporalRoundingMode
(
cx
options
&
roundingMode
)
)
{
return
false
;
}
auto
smallestUnit
=
TemporalUnit
:
:
Auto
;
if
(
!
GetTemporalUnit
(
cx
options
TemporalUnitKey
:
:
SmallestUnit
TemporalUnitGroup
:
:
Time
&
smallestUnit
)
)
{
return
false
;
}
if
(
smallestUnit
=
=
TemporalUnit
:
:
Hour
|
|
smallestUnit
=
=
TemporalUnit
:
:
Minute
)
{
const
char
*
smallestUnitStr
=
smallestUnit
=
=
TemporalUnit
:
:
Hour
?
"
hour
"
:
"
minute
"
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TEMPORAL_INVALID_UNIT_OPTION
smallestUnitStr
"
smallestUnit
"
)
;
return
false
;
}
precision
=
ToSecondsStringPrecision
(
smallestUnit
digits
)
;
}
Duration
result
;
if
(
precision
.
unit
!
=
TemporalUnit
:
:
Nanosecond
|
|
precision
.
increment
!
=
Increment
{
1
}
)
{
auto
timeDuration
=
NormalizeTimeDuration
(
duration
)
;
auto
largestUnit
=
DefaultTemporalLargestUnit
(
duration
)
;
auto
rounded
=
RoundDuration
(
timeDuration
precision
.
increment
precision
.
unit
roundingMode
)
;
auto
balanced
=
BalanceTimeDuration
(
rounded
std
:
:
min
(
largestUnit
TemporalUnit
:
:
Second
)
)
;
result
=
{
duration
.
years
duration
.
months
duration
.
weeks
duration
.
days
+
balanced
.
days
balanced
.
hours
balanced
.
minutes
balanced
.
seconds
balanced
.
milliseconds
balanced
.
microseconds
balanced
.
nanoseconds
}
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
}
else
{
result
=
duration
;
}
JSString
*
str
=
TemporalDurationToString
(
cx
result
precision
.
precision
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Duration_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_toString
>
(
cx
args
)
;
}
static
bool
Duration_toJSON
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
JSString
*
str
=
TemporalDurationToString
(
cx
duration
Precision
:
:
Auto
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Duration_toJSON
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_toJSON
>
(
cx
args
)
;
}
static
bool
Duration_toLocaleString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
duration
=
ToDuration
(
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationObject
>
(
)
)
;
JSString
*
str
=
TemporalDurationToString
(
cx
duration
Precision
:
:
Auto
(
)
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Duration_toLocaleString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDuration
Duration_toLocaleString
>
(
cx
args
)
;
}
static
bool
Duration_valueOf
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_CONVERT_TO
"
Duration
"
"
primitive
type
"
)
;
return
false
;
}
const
JSClass
DurationObject
:
:
class_
=
{
"
Temporal
.
Duration
"
JSCLASS_HAS_RESERVED_SLOTS
(
DurationObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Duration
)
JS_NULL_CLASS_OPS
&
DurationObject
:
:
classSpec_
}
;
const
JSClass
&
DurationObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
const
JSFunctionSpec
Duration_methods
[
]
=
{
JS_FN
(
"
from
"
Duration_from
1
0
)
JS_FN
(
"
compare
"
Duration_compare
2
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
Duration_prototype_methods
[
]
=
{
JS_FN
(
"
with
"
Duration_with
1
0
)
JS_FN
(
"
negated
"
Duration_negated
0
0
)
JS_FN
(
"
abs
"
Duration_abs
0
0
)
JS_FN
(
"
add
"
Duration_add
1
0
)
JS_FN
(
"
subtract
"
Duration_subtract
1
0
)
JS_FN
(
"
round
"
Duration_round
1
0
)
JS_FN
(
"
total
"
Duration_total
1
0
)
JS_FN
(
"
toString
"
Duration_toString
0
0
)
JS_FN
(
"
toJSON
"
Duration_toJSON
0
0
)
JS_FN
(
"
toLocaleString
"
Duration_toLocaleString
0
0
)
JS_FN
(
"
valueOf
"
Duration_valueOf
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
Duration_prototype_properties
[
]
=
{
JS_PSG
(
"
years
"
Duration_years
0
)
JS_PSG
(
"
months
"
Duration_months
0
)
JS_PSG
(
"
weeks
"
Duration_weeks
0
)
JS_PSG
(
"
days
"
Duration_days
0
)
JS_PSG
(
"
hours
"
Duration_hours
0
)
JS_PSG
(
"
minutes
"
Duration_minutes
0
)
JS_PSG
(
"
seconds
"
Duration_seconds
0
)
JS_PSG
(
"
milliseconds
"
Duration_milliseconds
0
)
JS_PSG
(
"
microseconds
"
Duration_microseconds
0
)
JS_PSG
(
"
nanoseconds
"
Duration_nanoseconds
0
)
JS_PSG
(
"
sign
"
Duration_sign
0
)
JS_PSG
(
"
blank
"
Duration_blank
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Temporal
.
Duration
"
JSPROP_READONLY
)
JS_PS_END
}
;
const
ClassSpec
DurationObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
DurationConstructor
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
DurationObject
>
Duration_methods
nullptr
Duration_prototype_methods
Duration_prototype_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
