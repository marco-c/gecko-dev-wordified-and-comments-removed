#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cstdlib
>
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
jsnum
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
temporal
/
TemporalTypes
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
using
namespace
js
;
using
namespace
js
:
:
temporal
;
template
<
const
auto
&
digits
>
static
bool
AbsoluteValueIsLessOrEqual
(
const
BigInt
*
bigInt
)
{
size_t
length
=
bigInt
-
>
digitLength
(
)
;
if
(
length
<
std
:
:
size
(
digits
)
)
{
return
true
;
}
if
(
length
>
std
:
:
size
(
digits
)
)
{
return
false
;
}
size_t
index
=
std
:
:
size
(
digits
)
;
for
(
auto
digit
:
digits
)
{
auto
d
=
bigInt
-
>
digit
(
-
-
index
)
;
if
(
d
<
digit
)
{
return
true
;
}
if
(
d
>
digit
)
{
return
false
;
}
}
return
true
;
}
static
constexpr
auto
NanosecondsMaxInstant
(
)
{
static_assert
(
BigInt
:
:
DigitBits
=
=
64
|
|
BigInt
:
:
DigitBits
=
=
32
)
;
if
constexpr
(
BigInt
:
:
DigitBits
=
=
64
)
{
return
std
:
:
array
{
BigInt
:
:
Digit
(
0x1d4
)
BigInt
:
:
Digit
(
0x6016
'
2f51
'
6f00
'
0000
)
}
;
}
else
{
return
std
:
:
array
{
BigInt
:
:
Digit
(
0x1d4
)
BigInt
:
:
Digit
(
0x6016
'
2f51
)
BigInt
:
:
Digit
(
0x6f00
'
0000
)
}
;
}
}
static
constexpr
int64_t
SecondsMaxInstant
=
8
'
640
'
000
'
000
'
000
;
bool
js
:
:
temporal
:
:
IsValidEpochNanoseconds
(
const
BigInt
*
epochNanoseconds
)
{
static
constexpr
auto
epochLimit
=
NanosecondsMaxInstant
(
)
;
return
AbsoluteValueIsLessOrEqual
<
epochLimit
>
(
epochNanoseconds
)
;
}
bool
js
:
:
temporal
:
:
IsValidEpochInstant
(
const
Instant
&
instant
)
{
MOZ_ASSERT
(
0
<
=
instant
.
nanoseconds
&
&
instant
.
nanoseconds
<
=
999
'
999
'
999
)
;
if
(
instant
.
seconds
<
SecondsMaxInstant
)
{
return
instant
.
seconds
>
=
-
SecondsMaxInstant
;
}
return
instant
.
seconds
=
=
SecondsMaxInstant
&
&
instant
.
nanoseconds
=
=
0
;
}
static
constexpr
auto
NanosecondsMaxInstantDifference
(
)
{
static_assert
(
BigInt
:
:
DigitBits
=
=
64
|
|
BigInt
:
:
DigitBits
=
=
32
)
;
if
constexpr
(
BigInt
:
:
DigitBits
=
=
64
)
{
return
std
:
:
array
{
BigInt
:
:
Digit
(
0x3a8
)
BigInt
:
:
Digit
(
0xc02c
'
5ea2
'
de00
'
0000
)
}
;
}
else
{
return
std
:
:
array
{
BigInt
:
:
Digit
(
0x3a8
)
BigInt
:
:
Digit
(
0xc02c
'
5ea2
)
BigInt
:
:
Digit
(
0xde00
'
0000
)
}
;
}
}
bool
js
:
:
temporal
:
:
IsValidInstantDifference
(
const
BigInt
*
ns
)
{
static
constexpr
auto
differenceLimit
=
NanosecondsMaxInstantDifference
(
)
;
return
AbsoluteValueIsLessOrEqual
<
differenceLimit
>
(
ns
)
;
}
bool
js
:
:
temporal
:
:
IsValidInstantDifference
(
const
Instant
&
instant
)
{
MOZ_ASSERT
(
0
<
=
instant
.
nanoseconds
&
&
instant
.
nanoseconds
<
=
999
'
999
'
999
)
;
constexpr
int64_t
differenceLimit
=
SecondsMaxInstant
*
2
;
if
(
instant
.
seconds
<
differenceLimit
)
{
return
instant
.
seconds
>
=
-
differenceLimit
;
}
return
instant
.
seconds
=
=
differenceLimit
&
&
instant
.
nanoseconds
=
=
0
;
}
static
std
:
:
array
<
uint32_t
3
>
BigIntDigits
(
const
BigInt
*
ns
)
{
static_assert
(
BigInt
:
:
DigitBits
=
=
64
|
|
BigInt
:
:
DigitBits
=
=
32
)
;
auto
digits
=
ns
-
>
digits
(
)
;
if
constexpr
(
BigInt
:
:
DigitBits
=
=
64
)
{
BigInt
:
:
Digit
x
=
0
y
=
0
;
switch
(
digits
.
size
(
)
)
{
case
2
:
y
=
digits
[
1
]
;
[
[
fallthrough
]
]
;
case
1
:
x
=
digits
[
0
]
;
[
[
fallthrough
]
]
;
case
0
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
digit
length
"
)
;
}
return
{
uint32_t
(
x
)
uint32_t
(
x
>
>
32
)
uint32_t
(
y
)
}
;
}
else
{
BigInt
:
:
Digit
x
=
0
y
=
0
z
=
0
;
switch
(
digits
.
size
(
)
)
{
case
3
:
z
=
digits
[
2
]
;
[
[
fallthrough
]
]
;
case
2
:
y
=
digits
[
1
]
;
[
[
fallthrough
]
]
;
case
1
:
x
=
digits
[
0
]
;
[
[
fallthrough
]
]
;
case
0
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
digit
length
"
)
;
}
return
{
uint32_t
(
x
)
uint32_t
(
y
)
uint32_t
(
z
)
}
;
}
}
static
Instant
ToInstant
(
std
:
:
array
<
uint32_t
3
>
digits
bool
isNegative
)
{
constexpr
uint32_t
divisor
=
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
MOZ_ASSERT
(
digits
[
2
]
<
divisor
)
;
uint32_t
quotient
[
2
]
=
{
}
;
uint32_t
remainder
=
digits
[
2
]
;
for
(
int32_t
i
=
1
;
i
>
=
0
;
i
-
-
)
{
uint64_t
n
=
(
uint64_t
(
remainder
)
<
<
32
)
|
digits
[
i
]
;
quotient
[
i
]
=
n
/
divisor
;
remainder
=
n
%
divisor
;
}
int64_t
seconds
=
(
uint64_t
(
quotient
[
1
]
)
<
<
32
)
|
quotient
[
0
]
;
if
(
isNegative
)
{
seconds
*
=
-
1
;
if
(
remainder
!
=
0
)
{
seconds
-
=
1
;
remainder
=
divisor
-
remainder
;
}
}
return
{
seconds
int32_t
(
remainder
)
}
;
}
Instant
js
:
:
temporal
:
:
ToInstant
(
const
BigInt
*
epochNanoseconds
)
{
MOZ_ASSERT
(
IsValidEpochNanoseconds
(
epochNanoseconds
)
)
;
auto
digits
=
BigIntDigits
(
epochNanoseconds
)
;
return
:
:
ToInstant
(
digits
epochNanoseconds
-
>
isNegative
(
)
)
;
}
Instant
js
:
:
temporal
:
:
ToInstantDifference
(
const
BigInt
*
epochNanoseconds
)
{
MOZ_ASSERT
(
IsValidInstantDifference
(
epochNanoseconds
)
)
;
auto
digits
=
BigIntDigits
(
epochNanoseconds
)
;
return
:
:
ToInstant
(
digits
epochNanoseconds
-
>
isNegative
(
)
)
;
}
static
BigInt
*
CreateBigInt
(
JSContext
*
cx
const
std
:
:
array
<
uint32_t
3
>
&
digits
bool
negative
)
{
static_assert
(
BigInt
:
:
DigitBits
=
=
64
|
|
BigInt
:
:
DigitBits
=
=
32
)
;
if
constexpr
(
BigInt
:
:
DigitBits
=
=
64
)
{
uint64_t
x
=
(
uint64_t
(
digits
[
1
]
)
<
<
32
)
|
digits
[
0
]
;
uint64_t
y
=
digits
[
2
]
;
size_t
length
=
y
?
2
:
x
?
1
:
0
;
auto
*
result
=
BigInt
:
:
createUninitialized
(
cx
length
negative
)
;
if
(
!
result
)
{
return
nullptr
;
}
if
(
y
)
{
result
-
>
setDigit
(
1
y
)
;
}
if
(
x
)
{
result
-
>
setDigit
(
0
x
)
;
}
return
result
;
}
else
{
size_t
length
=
digits
[
2
]
?
3
:
digits
[
1
]
?
2
:
digits
[
0
]
?
1
:
0
;
auto
*
result
=
BigInt
:
:
createUninitialized
(
cx
length
negative
)
;
if
(
!
result
)
{
return
nullptr
;
}
while
(
length
-
-
)
{
result
-
>
setDigit
(
length
digits
[
length
]
)
;
}
return
result
;
}
}
static
BigInt
*
ToEpochBigInt
(
JSContext
*
cx
const
Instant
&
instant
)
{
MOZ_ASSERT
(
IsValidInstantDifference
(
instant
)
)
;
auto
digitMul
=
[
]
(
uint32_t
a
uint32_t
b
uint32_t
*
high
)
{
uint64_t
result
=
static_cast
<
uint64_t
>
(
a
)
*
static_cast
<
uint64_t
>
(
b
)
;
*
high
=
result
>
>
32
;
return
static_cast
<
uint32_t
>
(
result
)
;
}
;
auto
digitAdd
=
[
]
(
uint32_t
a
uint32_t
b
uint32_t
*
carry
)
{
uint32_t
result
=
a
+
b
;
*
carry
+
=
static_cast
<
uint32_t
>
(
result
<
a
)
;
return
result
;
}
;
constexpr
uint32_t
secToNanos
=
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
uint64_t
seconds
=
std
:
:
abs
(
instant
.
seconds
)
;
uint32_t
nanoseconds
=
instant
.
nanoseconds
;
if
(
instant
.
seconds
<
0
&
&
nanoseconds
!
=
0
)
{
nanoseconds
=
secToNanos
-
nanoseconds
;
seconds
-
=
1
;
}
std
:
:
array
<
uint32_t
2
>
multiplicand
=
{
uint32_t
(
seconds
)
uint32_t
(
seconds
>
>
32
)
}
;
std
:
:
array
<
uint32_t
3
>
accumulator
=
{
nanoseconds
0
0
}
;
uint32_t
carry
=
0
;
{
uint32_t
high
=
0
;
uint32_t
low
=
digitMul
(
secToNanos
multiplicand
[
0
]
&
high
)
;
uint32_t
newCarry
=
0
;
accumulator
[
0
]
=
digitAdd
(
accumulator
[
0
]
low
&
newCarry
)
;
accumulator
[
1
]
=
digitAdd
(
high
newCarry
&
carry
)
;
}
{
uint32_t
high
=
0
;
uint32_t
low
=
digitMul
(
secToNanos
multiplicand
[
1
]
&
high
)
;
uint32_t
newCarry
=
0
;
accumulator
[
1
]
=
digitAdd
(
accumulator
[
1
]
low
&
carry
)
;
accumulator
[
2
]
=
digitAdd
(
high
carry
&
newCarry
)
;
MOZ_ASSERT
(
newCarry
=
=
0
)
;
}
return
CreateBigInt
(
cx
accumulator
instant
.
seconds
<
0
)
;
}
BigInt
*
js
:
:
temporal
:
:
ToEpochNanoseconds
(
JSContext
*
cx
const
Instant
&
instant
)
{
MOZ_ASSERT
(
IsValidEpochInstant
(
instant
)
)
;
return
:
:
ToEpochBigInt
(
cx
instant
)
;
}
BigInt
*
js
:
:
temporal
:
:
ToEpochDifferenceNanoseconds
(
JSContext
*
cx
const
Instant
&
instant
)
{
MOZ_ASSERT
(
IsValidInstantDifference
(
instant
)
)
;
return
:
:
ToEpochBigInt
(
cx
instant
)
;
}
static
bool
InstantConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
MOZ_CRASH
(
"
NYI
"
)
;
}
const
JSClass
InstantObject
:
:
class_
=
{
"
Temporal
.
Instant
"
JSCLASS_HAS_RESERVED_SLOTS
(
InstantObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Instant
)
JS_NULL_CLASS_OPS
&
InstantObject
:
:
classSpec_
}
;
const
JSClass
&
InstantObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
const
JSFunctionSpec
Instant_methods
[
]
=
{
JS_FS_END
}
;
static
const
JSFunctionSpec
Instant_prototype_methods
[
]
=
{
JS_FS_END
}
;
static
const
JSPropertySpec
Instant_prototype_properties
[
]
=
{
JS_PS_END
}
;
const
ClassSpec
InstantObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
InstantConstructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
InstantObject
>
Instant_methods
nullptr
Instant_prototype_methods
Instant_prototype_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
