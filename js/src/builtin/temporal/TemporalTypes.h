#
ifndef
builtin_temporal_TemporalTypes_h
#
define
builtin_temporal_TemporalTypes_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
<
cmath
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
builtin
/
temporal
/
Int128
.
h
"
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
namespace
js
:
:
temporal
{
#
if
defined
__has_builtin
#
if
__has_builtin
(
__builtin_assume
)
#
define
JS_ASSUME
(
x
)
__builtin_assume
(
x
)
#
elif
__has_builtin
(
__builtin_unreachable
)
#
define
JS_ASSUME
(
x
)
\
if
(
!
(
x
)
)
__builtin_unreachable
(
)
#
else
#
endif
#
endif
#
ifndef
JS_ASSUME
#
define
JS_ASSUME
(
x
)
\
do
{
\
}
while
(
false
)
#
endif
template
<
typename
Derived
>
struct
SecondsAndNanoseconds
{
int64_t
seconds
=
0
;
int32_t
nanoseconds
=
0
;
constexpr
bool
operator
=
=
(
const
SecondsAndNanoseconds
&
other
)
const
{
return
seconds
=
=
other
.
seconds
&
&
nanoseconds
=
=
other
.
nanoseconds
;
}
constexpr
bool
operator
<
(
const
SecondsAndNanoseconds
&
other
)
const
{
JS_ASSUME
(
nanoseconds
>
=
0
)
;
JS_ASSUME
(
other
.
nanoseconds
>
=
0
)
;
return
(
seconds
<
other
.
seconds
)
|
|
(
seconds
=
=
other
.
seconds
&
&
nanoseconds
<
other
.
nanoseconds
)
;
}
constexpr
bool
operator
!
=
(
const
SecondsAndNanoseconds
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
constexpr
bool
operator
>
(
const
SecondsAndNanoseconds
&
other
)
const
{
return
other
<
*
this
;
}
constexpr
bool
operator
<
=
(
const
SecondsAndNanoseconds
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
constexpr
bool
operator
>
=
(
const
SecondsAndNanoseconds
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
protected
:
template
<
typename
T
typename
U
class
R
=
Derived
>
static
constexpr
R
add
(
const
SecondsAndNanoseconds
<
T
>
&
self
const
SecondsAndNanoseconds
<
U
>
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
self
.
seconds
;
secs
+
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
self
.
nanoseconds
;
nanos
+
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
>
=
1
'
000
'
000
'
000
)
{
secs
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
return
{
secs
.
value
(
)
nanos
.
value
(
)
}
;
}
template
<
class
T
class
U
class
R
=
Derived
>
static
constexpr
R
subtract
(
const
SecondsAndNanoseconds
<
T
>
&
self
const
SecondsAndNanoseconds
<
U
>
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
self
.
seconds
;
secs
-
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
self
.
nanoseconds
;
nanos
-
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
<
0
)
{
secs
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
return
{
secs
.
value
(
)
nanos
.
value
(
)
}
;
}
static
constexpr
Derived
negate
(
const
Derived
&
self
)
{
return
subtract
(
Derived
{
}
self
)
;
}
public
:
constexpr
std
:
:
pair
<
int64_t
int32_t
>
denormalize
(
)
const
{
int64_t
sec
=
seconds
;
int32_t
nanos
=
nanoseconds
;
if
(
sec
<
0
&
&
nanos
>
0
)
{
sec
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
return
{
sec
nanos
}
;
}
constexpr
Derived
abs
(
)
const
{
auto
[
sec
nanos
]
=
denormalize
(
)
;
return
{
std
:
:
abs
(
sec
)
std
:
:
abs
(
nanos
)
}
;
}
constexpr
int64_t
toSeconds
(
)
const
{
auto
[
sec
nanos
]
=
denormalize
(
)
;
return
sec
;
}
constexpr
int64_t
toMilliseconds
(
)
const
{
auto
[
sec
nanos
]
=
denormalize
(
)
;
return
(
sec
*
1
'
000
)
+
(
nanos
/
1
'
000
'
000
)
;
}
constexpr
int64_t
toMicroseconds
(
)
const
{
auto
[
sec
nanos
]
=
denormalize
(
)
;
return
(
sec
*
1
'
000
'
000
)
+
(
nanos
/
1
'
000
)
;
}
constexpr
Int128
toNanoseconds
(
)
const
{
return
Int128
{
seconds
}
*
Int128
{
ToNanoseconds
(
TemporalUnit
:
:
Second
)
}
+
Int128
{
nanoseconds
}
;
}
template
<
class
Other
>
constexpr
Other
to
(
)
const
{
static_assert
(
std
:
:
is_base_of_v
<
SecondsAndNanoseconds
<
Other
>
Other
>
)
;
return
Other
{
seconds
nanoseconds
}
;
}
static
constexpr
Derived
fromMinutes
(
int64_t
minutes
)
{
return
{
minutes
*
60
0
}
;
}
static
constexpr
Derived
fromSeconds
(
int64_t
seconds
)
{
return
{
seconds
0
}
;
}
static
constexpr
Derived
fromMilliseconds
(
int64_t
milliseconds
)
{
int64_t
seconds
=
milliseconds
/
1
'
000
;
int32_t
millis
=
int32_t
(
milliseconds
%
1
'
000
)
;
if
(
millis
<
0
)
{
seconds
-
=
1
;
millis
+
=
1
'
000
;
}
return
{
seconds
millis
*
1
'
000
'
000
}
;
}
static
constexpr
Derived
fromMicroseconds
(
int64_t
microseconds
)
{
int64_t
seconds
=
microseconds
/
1
'
000
'
000
;
int32_t
micros
=
int32_t
(
microseconds
%
1
'
000
'
000
)
;
if
(
micros
<
0
)
{
seconds
-
=
1
;
micros
+
=
1
'
000
'
000
;
}
return
{
seconds
micros
*
1
'
000
}
;
}
static
constexpr
Derived
fromNanoseconds
(
int64_t
nanoseconds
)
{
int64_t
seconds
=
nanoseconds
/
1
'
000
'
000
'
000
;
int32_t
nanos
=
int32_t
(
nanoseconds
%
1
'
000
'
000
'
000
)
;
if
(
nanos
<
0
)
{
seconds
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
return
{
seconds
nanos
}
;
}
static
Derived
fromNanoseconds
(
const
Int128
&
nanoseconds
)
{
auto
div
=
nanoseconds
.
divrem
(
Int128
{
1
'
000
'
000
'
000
}
)
;
int64_t
seconds
=
int64_t
(
div
.
first
)
;
int32_t
nanos
=
int32_t
(
div
.
second
)
;
if
(
nanos
<
0
)
{
seconds
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
return
{
seconds
nanos
}
;
}
}
;
#
undef
JS_ASSUME
struct
InstantSpan
final
:
SecondsAndNanoseconds
<
InstantSpan
>
{
constexpr
InstantSpan
&
operator
+
=
(
const
InstantSpan
&
other
)
{
*
this
=
add
(
*
this
other
)
;
return
*
this
;
}
constexpr
InstantSpan
&
operator
-
=
(
const
InstantSpan
&
other
)
{
*
this
=
subtract
(
*
this
other
)
;
return
*
this
;
}
constexpr
InstantSpan
operator
+
(
const
InstantSpan
&
other
)
const
{
return
add
(
*
this
other
)
;
}
constexpr
InstantSpan
operator
-
(
const
InstantSpan
&
other
)
const
{
return
subtract
(
*
this
other
)
;
}
constexpr
InstantSpan
operator
-
(
)
const
{
return
negate
(
*
this
)
;
}
static
constexpr
InstantSpan
max
(
)
{
constexpr
int64_t
seconds
=
2
*
8
'
640
'
000
'
000
'
000
;
constexpr
int64_t
nanos
=
0
;
return
{
seconds
nanos
}
;
}
static
constexpr
InstantSpan
min
(
)
{
return
-
max
(
)
;
}
}
;
struct
Instant
final
:
SecondsAndNanoseconds
<
Instant
>
{
constexpr
Instant
&
operator
+
=
(
const
InstantSpan
&
other
)
{
*
this
=
add
(
*
this
other
)
;
return
*
this
;
}
constexpr
Instant
&
operator
-
=
(
const
InstantSpan
&
other
)
{
*
this
=
subtract
(
*
this
other
)
;
return
*
this
;
}
constexpr
Instant
operator
+
(
const
InstantSpan
&
other
)
const
{
return
add
(
*
this
other
)
;
}
constexpr
Instant
operator
-
(
const
InstantSpan
&
other
)
const
{
return
subtract
(
*
this
other
)
;
}
constexpr
InstantSpan
operator
-
(
const
Instant
&
other
)
const
{
return
subtract
<
Instant
Instant
InstantSpan
>
(
*
this
other
)
;
}
constexpr
Instant
operator
-
(
)
const
{
return
negate
(
*
this
)
;
}
constexpr
int64_t
floorToMicroseconds
(
)
const
{
return
(
seconds
*
1
'
000
'
000
)
+
(
nanoseconds
/
1
'
000
)
;
}
constexpr
int64_t
floorToMilliseconds
(
)
const
{
return
(
seconds
*
1
'
000
)
+
(
nanoseconds
/
1
'
000
'
000
)
;
}
constexpr
int64_t
ceilToMilliseconds
(
)
const
{
return
floorToMilliseconds
(
)
+
int64_t
(
nanoseconds
%
1
'
000
'
000
!
=
0
)
;
}
static
constexpr
Instant
max
(
)
{
constexpr
int64_t
seconds
=
8
'
640
'
000
'
000
'
000
;
constexpr
int64_t
nanos
=
0
;
return
{
seconds
nanos
}
;
}
static
constexpr
Instant
min
(
)
{
return
-
max
(
)
;
}
}
;
constexpr
inline
int32_t
MinEpochDay
=
-
100
'
000
'
001
;
constexpr
inline
int32_t
MaxEpochDay
=
100
'
000
'
000
;
static_assert
(
MinEpochDay
=
=
Instant
:
:
min
(
)
.
seconds
/
ToSeconds
(
TemporalUnit
:
:
Day
)
-
1
)
;
static_assert
(
MaxEpochDay
=
=
Instant
:
:
max
(
)
.
seconds
/
ToSeconds
(
TemporalUnit
:
:
Day
)
)
;
constexpr
inline
int32_t
MaxEpochDaysDuration
=
MaxEpochDay
-
MinEpochDay
;
struct
PlainDate
final
{
int32_t
year
=
0
;
int32_t
month
=
0
;
int32_t
day
=
0
;
bool
operator
=
=
(
const
PlainDate
&
other
)
const
{
return
year
=
=
other
.
year
&
&
month
=
=
other
.
month
&
&
day
=
=
other
.
day
;
}
bool
operator
!
=
(
const
PlainDate
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
struct
PlainTime
final
{
int32_t
hour
=
0
;
int32_t
minute
=
0
;
int32_t
second
=
0
;
int32_t
millisecond
=
0
;
int32_t
microsecond
=
0
;
int32_t
nanosecond
=
0
;
bool
operator
=
=
(
const
PlainTime
&
other
)
const
{
return
hour
=
=
other
.
hour
&
&
minute
=
=
other
.
minute
&
&
second
=
=
other
.
second
&
&
millisecond
=
=
other
.
millisecond
&
&
microsecond
=
=
other
.
microsecond
&
&
nanosecond
=
=
other
.
nanosecond
;
}
bool
operator
!
=
(
const
PlainTime
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
struct
PlainDateTime
final
{
PlainDate
date
;
PlainTime
time
;
bool
operator
=
=
(
const
PlainDateTime
&
other
)
const
{
return
date
=
=
other
.
date
&
&
time
=
=
other
.
time
;
}
bool
operator
!
=
(
const
PlainDateTime
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
struct
DateDuration
;
struct
TimeDuration
;
struct
Duration
final
{
double
years
=
0
;
double
months
=
0
;
double
weeks
=
0
;
double
days
=
0
;
double
hours
=
0
;
double
minutes
=
0
;
double
seconds
=
0
;
double
milliseconds
=
0
;
double
microseconds
=
0
;
double
nanoseconds
=
0
;
constexpr
bool
operator
=
=
(
const
Duration
&
other
)
const
{
return
years
=
=
other
.
years
&
&
months
=
=
other
.
months
&
&
weeks
=
=
other
.
weeks
&
&
days
=
=
other
.
days
&
&
hours
=
=
other
.
hours
&
&
minutes
=
=
other
.
minutes
&
&
seconds
=
=
other
.
seconds
&
&
milliseconds
=
=
other
.
milliseconds
&
&
microseconds
=
=
other
.
microseconds
&
&
nanoseconds
=
=
other
.
nanoseconds
;
}
constexpr
bool
operator
!
=
(
const
Duration
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
constexpr
Duration
negate
(
)
const
{
return
{
-
years
+
(
+
0
.
0
)
-
months
+
(
+
0
.
0
)
-
weeks
+
(
+
0
.
0
)
-
days
+
(
+
0
.
0
)
-
hours
+
(
+
0
.
0
)
-
minutes
+
(
+
0
.
0
)
-
seconds
+
(
+
0
.
0
)
-
milliseconds
+
(
+
0
.
0
)
-
microseconds
+
(
+
0
.
0
)
-
nanoseconds
+
(
+
0
.
0
)
}
;
}
inline
DateDuration
toDateDuration
(
)
const
;
}
;
struct
DateDuration
final
{
int64_t
years
=
0
;
int64_t
months
=
0
;
int64_t
weeks
=
0
;
int64_t
days
=
0
;
constexpr
bool
operator
=
=
(
const
DateDuration
&
other
)
const
{
return
years
=
=
other
.
years
&
&
months
=
=
other
.
months
&
&
weeks
=
=
other
.
weeks
&
&
days
=
=
other
.
days
;
}
constexpr
bool
operator
!
=
(
const
DateDuration
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
constexpr
Duration
toDuration
(
)
const
{
return
{
double
(
years
)
double
(
months
)
double
(
weeks
)
double
(
days
)
}
;
}
}
;
inline
DateDuration
Duration
:
:
toDateDuration
(
)
const
{
return
{
int64_t
(
years
)
int64_t
(
months
)
int64_t
(
weeks
)
int64_t
(
days
)
}
;
}
struct
TimeDuration
final
{
int64_t
days
=
0
;
int64_t
hours
=
0
;
int64_t
minutes
=
0
;
int64_t
seconds
=
0
;
int64_t
milliseconds
=
0
;
double
microseconds
=
0
;
double
nanoseconds
=
0
;
constexpr
Duration
toDuration
(
)
const
{
return
{
0
0
0
double
(
days
)
double
(
hours
)
double
(
minutes
)
double
(
seconds
)
double
(
milliseconds
)
microseconds
nanoseconds
}
;
}
}
;
struct
NormalizedTimeDuration
final
:
SecondsAndNanoseconds
<
NormalizedTimeDuration
>
{
constexpr
NormalizedTimeDuration
&
operator
+
=
(
const
NormalizedTimeDuration
&
other
)
{
*
this
=
add
(
*
this
other
)
;
return
*
this
;
}
constexpr
NormalizedTimeDuration
&
operator
-
=
(
const
NormalizedTimeDuration
&
other
)
{
*
this
=
subtract
(
*
this
other
)
;
return
*
this
;
}
constexpr
NormalizedTimeDuration
operator
+
(
const
NormalizedTimeDuration
&
other
)
const
{
return
add
(
*
this
other
)
;
}
constexpr
NormalizedTimeDuration
operator
-
(
const
NormalizedTimeDuration
&
other
)
const
{
return
subtract
(
*
this
other
)
;
}
constexpr
NormalizedTimeDuration
operator
-
(
)
const
{
return
negate
(
*
this
)
;
}
static
constexpr
NormalizedTimeDuration
max
(
)
{
constexpr
int64_t
seconds
=
0x1f
'
ffff
'
ffff
'
ffff
;
constexpr
int64_t
nanos
=
999
'
999
'
999
;
return
{
seconds
nanos
}
;
}
static
constexpr
NormalizedTimeDuration
min
(
)
{
return
-
max
(
)
;
}
}
;
struct
NormalizedDuration
final
{
DateDuration
date
;
NormalizedTimeDuration
time
;
constexpr
bool
operator
=
=
(
const
NormalizedDuration
&
other
)
const
{
return
date
=
=
other
.
date
&
&
time
=
=
other
.
time
;
}
constexpr
bool
operator
!
=
(
const
NormalizedDuration
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
}
#
endif
