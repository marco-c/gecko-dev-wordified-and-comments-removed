#
ifndef
builtin_temporal_TemporalTypes_h
#
define
builtin_temporal_TemporalTypes_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
<
stdint
.
h
>
#
include
"
builtin
/
temporal
/
TemporalUnit
.
h
"
namespace
js
:
:
temporal
{
#
if
defined
__has_builtin
#
if
__has_builtin
(
__builtin_assume
)
#
define
JS_ASSUME
(
x
)
__builtin_assume
(
x
)
#
elif
__has_builtin
(
__builtin_unreachable
)
#
define
JS_ASSUME
(
x
)
\
if
(
!
(
x
)
)
__builtin_unreachable
(
)
#
else
#
endif
#
endif
#
ifndef
JS_ASSUME
#
define
JS_ASSUME
(
x
)
\
do
{
\
}
while
(
false
)
#
endif
struct
InstantSpan
;
struct
Instant
final
{
int64_t
seconds
=
0
;
int32_t
nanoseconds
=
0
;
bool
operator
=
=
(
const
Instant
&
other
)
const
{
return
seconds
=
=
other
.
seconds
&
&
nanoseconds
=
=
other
.
nanoseconds
;
}
bool
operator
<
(
const
Instant
&
other
)
const
{
JS_ASSUME
(
nanoseconds
>
=
0
)
;
JS_ASSUME
(
other
.
nanoseconds
>
=
0
)
;
return
(
seconds
<
other
.
seconds
)
|
|
(
seconds
=
=
other
.
seconds
&
&
nanoseconds
<
other
.
nanoseconds
)
;
}
bool
operator
!
=
(
const
Instant
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
operator
>
(
const
Instant
&
other
)
const
{
return
other
<
*
this
;
}
bool
operator
<
=
(
const
Instant
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
bool
operator
>
=
(
const
Instant
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
inline
Instant
&
operator
+
=
(
const
InstantSpan
&
other
)
;
inline
Instant
&
operator
-
=
(
const
InstantSpan
&
other
)
;
inline
Instant
operator
+
(
const
InstantSpan
&
other
)
const
;
inline
Instant
operator
-
(
const
InstantSpan
&
other
)
const
;
inline
InstantSpan
operator
-
(
const
Instant
&
other
)
const
;
int64_t
toSeconds
(
)
const
{
int64_t
sec
=
seconds
;
int64_t
nanos
=
nanoseconds
;
if
(
sec
<
0
&
&
nanos
>
0
)
{
sec
+
=
1
;
}
return
sec
;
}
int64_t
toMilliseconds
(
)
const
{
int64_t
sec
=
seconds
;
int64_t
nanos
=
nanoseconds
;
if
(
sec
<
0
&
&
nanos
>
0
)
{
sec
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
return
(
sec
*
1
'
000
)
+
(
nanos
/
1
'
000
'
000
)
;
}
int64_t
toMicroseconds
(
)
const
{
int64_t
sec
=
seconds
;
int64_t
nanos
=
nanoseconds
;
if
(
sec
<
0
&
&
nanos
>
0
)
{
sec
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
return
(
sec
*
1
'
000
'
000
)
+
(
nanos
/
1
'
000
)
;
}
mozilla
:
:
CheckedInt64
toNanoseconds
(
)
const
{
mozilla
:
:
CheckedInt64
nanos
=
seconds
;
nanos
*
=
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
nanos
+
=
nanoseconds
;
return
nanos
;
}
int64_t
floorToMicroseconds
(
)
const
{
return
(
seconds
*
1
'
000
'
000
)
+
(
nanoseconds
/
1
'
000
)
;
}
int64_t
floorToMilliseconds
(
)
const
{
return
(
seconds
*
1
'
000
)
+
(
nanoseconds
/
1
'
000
'
000
)
;
}
int64_t
ceilToMilliseconds
(
)
const
{
return
floorToMilliseconds
(
)
+
int64_t
(
nanoseconds
%
1
'
000
'
000
!
=
0
)
;
}
static
constexpr
Instant
fromSeconds
(
int64_t
seconds
)
{
return
{
seconds
0
}
;
}
static
constexpr
Instant
fromMilliseconds
(
int64_t
milliseconds
)
{
int64_t
seconds
=
milliseconds
/
1
'
000
;
int32_t
millis
=
milliseconds
%
1
'
000
;
if
(
millis
<
0
)
{
seconds
-
=
1
;
millis
+
=
1
'
000
;
}
return
{
seconds
millis
*
1
'
000
'
000
}
;
}
static
constexpr
Instant
fromMicroseconds
(
int64_t
microseconds
)
{
int64_t
seconds
=
microseconds
/
1
'
000
'
000
;
int32_t
micros
=
microseconds
%
1
'
000
'
000
;
if
(
micros
<
0
)
{
seconds
-
=
1
;
micros
+
=
1
'
000
'
000
;
}
return
{
seconds
micros
*
1
'
000
}
;
}
static
constexpr
Instant
fromNanoseconds
(
int64_t
nanoseconds
)
{
int64_t
seconds
=
nanoseconds
/
1
'
000
'
000
'
000
;
int32_t
nanos
=
nanoseconds
%
1
'
000
'
000
'
000
;
if
(
nanos
<
0
)
{
seconds
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
return
{
seconds
nanos
}
;
}
}
;
struct
InstantSpan
final
{
int64_t
seconds
=
0
;
int32_t
nanoseconds
=
0
;
bool
operator
=
=
(
const
InstantSpan
&
other
)
const
{
return
seconds
=
=
other
.
seconds
&
&
nanoseconds
=
=
other
.
nanoseconds
;
}
bool
operator
<
(
const
InstantSpan
&
other
)
const
{
JS_ASSUME
(
nanoseconds
>
=
0
)
;
JS_ASSUME
(
other
.
nanoseconds
>
=
0
)
;
return
(
seconds
<
other
.
seconds
)
|
|
(
seconds
=
=
other
.
seconds
&
&
nanoseconds
<
other
.
nanoseconds
)
;
}
bool
operator
!
=
(
const
InstantSpan
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
operator
>
(
const
InstantSpan
&
other
)
const
{
return
other
<
*
this
;
}
bool
operator
<
=
(
const
InstantSpan
&
other
)
const
{
return
!
(
other
<
*
this
)
;
}
bool
operator
>
=
(
const
InstantSpan
&
other
)
const
{
return
!
(
*
this
<
other
)
;
}
InstantSpan
&
operator
+
=
(
const
InstantSpan
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
seconds
;
secs
+
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
nanoseconds
;
nanos
+
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
>
=
1
'
000
'
000
'
000
)
{
secs
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
seconds
=
secs
.
value
(
)
;
nanoseconds
=
nanos
.
value
(
)
;
return
*
this
;
}
InstantSpan
&
operator
-
=
(
const
InstantSpan
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
seconds
;
secs
-
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
nanoseconds
;
nanos
-
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
<
0
)
{
secs
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
seconds
=
secs
.
value
(
)
;
nanoseconds
=
nanos
.
value
(
)
;
return
*
this
;
}
InstantSpan
operator
+
(
const
InstantSpan
&
other
)
const
{
auto
result
=
*
this
;
result
+
=
other
;
return
result
;
}
InstantSpan
operator
-
(
const
InstantSpan
&
other
)
const
{
auto
result
=
*
this
;
result
-
=
other
;
return
result
;
}
InstantSpan
abs
(
)
const
{
int64_t
sec
=
seconds
;
int32_t
nanos
=
nanoseconds
;
if
(
sec
<
0
)
{
if
(
nanos
>
0
)
{
sec
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
sec
=
-
sec
;
nanos
=
-
nanos
;
}
return
{
sec
nanos
}
;
}
mozilla
:
:
CheckedInt64
toNanoseconds
(
)
const
{
mozilla
:
:
CheckedInt64
nanos
=
seconds
;
nanos
*
=
ToNanoseconds
(
TemporalUnit
:
:
Second
)
;
nanos
+
=
nanoseconds
;
return
nanos
;
}
static
constexpr
InstantSpan
fromMinutes
(
int64_t
minutes
)
{
return
{
minutes
*
60
0
}
;
}
static
constexpr
InstantSpan
fromMilliseconds
(
int64_t
milliseconds
)
{
int64_t
seconds
=
milliseconds
/
1
'
000
;
int32_t
millis
=
milliseconds
%
1
'
000
;
if
(
millis
<
0
)
{
seconds
-
=
1
;
millis
+
=
1
'
000
;
}
return
{
seconds
millis
*
1
'
000
'
000
}
;
}
static
constexpr
InstantSpan
fromNanoseconds
(
int64_t
nanoseconds
)
{
int64_t
seconds
=
nanoseconds
/
1
'
000
'
000
'
000
;
int32_t
nanos
=
nanoseconds
%
1
'
000
'
000
'
000
;
if
(
nanos
<
0
)
{
seconds
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
return
{
seconds
nanos
}
;
}
}
;
Instant
&
Instant
:
:
operator
+
=
(
const
InstantSpan
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
seconds
;
secs
+
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
nanoseconds
;
nanos
+
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
>
=
1
'
000
'
000
'
000
)
{
secs
+
=
1
;
nanos
-
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
seconds
=
secs
.
value
(
)
;
nanoseconds
=
nanos
.
value
(
)
;
return
*
this
;
}
Instant
&
Instant
:
:
operator
-
=
(
const
InstantSpan
&
other
)
{
mozilla
:
:
CheckedInt64
secs
=
seconds
;
secs
-
=
other
.
seconds
;
mozilla
:
:
CheckedInt32
nanos
=
nanoseconds
;
nanos
-
=
other
.
nanoseconds
;
if
(
nanos
.
value
(
)
<
0
)
{
secs
-
=
1
;
nanos
+
=
1
'
000
'
000
'
000
;
}
MOZ_ASSERT
(
0
<
=
nanos
.
value
(
)
&
&
nanos
.
value
(
)
<
1
'
000
'
000
'
000
)
;
seconds
=
secs
.
value
(
)
;
nanoseconds
=
nanos
.
value
(
)
;
return
*
this
;
}
Instant
Instant
:
:
operator
+
(
const
InstantSpan
&
other
)
const
{
auto
result
=
*
this
;
result
+
=
other
;
return
result
;
}
Instant
Instant
:
:
operator
-
(
const
InstantSpan
&
other
)
const
{
auto
result
=
*
this
;
result
-
=
other
;
return
result
;
}
InstantSpan
Instant
:
:
operator
-
(
const
Instant
&
other
)
const
{
InstantSpan
result
{
seconds
nanoseconds
}
;
result
-
=
InstantSpan
{
other
.
seconds
other
.
nanoseconds
}
;
return
result
;
}
#
undef
JS_ASSUME
struct
PlainDate
final
{
int32_t
year
=
0
;
int32_t
month
=
0
;
int32_t
day
=
0
;
}
;
struct
PlainTime
final
{
int32_t
hour
=
0
;
int32_t
minute
=
0
;
int32_t
second
=
0
;
int32_t
millisecond
=
0
;
int32_t
microsecond
=
0
;
int32_t
nanosecond
=
0
;
}
;
struct
PlainDateTime
final
{
PlainDate
date
;
PlainTime
time
;
}
;
struct
Duration
final
{
double
years
=
0
;
double
months
=
0
;
double
weeks
=
0
;
double
days
=
0
;
double
hours
=
0
;
double
minutes
=
0
;
double
seconds
=
0
;
double
milliseconds
=
0
;
double
microseconds
=
0
;
double
nanoseconds
=
0
;
bool
operator
=
=
(
const
Duration
&
other
)
const
{
return
years
=
=
other
.
years
&
&
months
=
=
other
.
months
&
&
weeks
=
=
other
.
weeks
&
&
days
=
=
other
.
days
&
&
hours
=
=
other
.
hours
&
&
minutes
=
=
other
.
minutes
&
&
seconds
=
=
other
.
seconds
&
&
milliseconds
=
=
other
.
milliseconds
&
&
microseconds
=
=
other
.
microseconds
&
&
nanoseconds
=
=
other
.
nanoseconds
;
}
bool
operator
!
=
(
const
Duration
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
Duration
date
(
)
const
{
return
{
years
months
weeks
days
}
;
}
Duration
time
(
)
const
{
return
{
0
0
0
0
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
;
}
Duration
negate
(
)
const
{
return
{
-
years
+
(
+
0
.
0
)
-
months
+
(
+
0
.
0
)
-
weeks
+
(
+
0
.
0
)
-
days
+
(
+
0
.
0
)
-
hours
+
(
+
0
.
0
)
-
minutes
+
(
+
0
.
0
)
-
seconds
+
(
+
0
.
0
)
-
milliseconds
+
(
+
0
.
0
)
-
microseconds
+
(
+
0
.
0
)
-
nanoseconds
+
(
+
0
.
0
)
}
;
}
}
;
struct
DateDuration
final
{
double
years
=
0
;
double
months
=
0
;
double
weeks
=
0
;
double
days
=
0
;
Duration
toDuration
(
)
{
return
{
years
months
weeks
days
}
;
}
}
;
struct
TimeDuration
final
{
double
days
=
0
;
double
hours
=
0
;
double
minutes
=
0
;
double
seconds
=
0
;
double
milliseconds
=
0
;
double
microseconds
=
0
;
double
nanoseconds
=
0
;
Duration
toDuration
(
)
{
return
{
0
0
0
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
}
;
}
}
;
}
#
endif
