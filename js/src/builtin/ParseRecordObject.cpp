#
include
"
builtin
/
ParseRecordObject
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
Object
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
const
JSClass
ParseRecordObject
:
:
class_
=
{
"
ParseRecordObject
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
}
;
ParseRecordObject
*
ParseRecordObject
:
:
create
(
JSContext
*
cx
const
Value
&
val
)
{
Rooted
<
JSONParseNode
*
>
parseNode
(
cx
)
;
return
ParseRecordObject
:
:
create
(
cx
parseNode
val
)
;
}
ParseRecordObject
*
ParseRecordObject
:
:
create
(
JSContext
*
cx
Handle
<
JSONParseNode
*
>
parseNode
const
Value
&
val
)
{
Rooted
<
ParseRecordObject
*
>
obj
(
cx
NewObjectWithGivenProto
<
ParseRecordObject
>
(
cx
nullptr
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
if
(
parseNode
)
{
obj
-
>
initSlot
(
ParseNodeSlot
StringValue
(
parseNode
)
)
;
}
obj
-
>
initSlot
(
ValueSlot
val
)
;
return
obj
;
}
JS
:
:
PropertyKey
ParseRecordObject
:
:
getKey
(
JSContext
*
cx
)
const
{
Rooted
<
Value
>
slot
(
cx
getSlot
(
KeySlot
)
)
;
Rooted
<
JS
:
:
PropertyKey
>
key
(
cx
)
;
MOZ_ALWAYS_TRUE
(
JS_ValueToId
(
cx
slot
&
key
)
)
;
return
key
;
}
;
bool
ParseRecordObject
:
:
setKey
(
JSContext
*
cx
const
JS
:
:
PropertyKey
&
key
)
{
Rooted
<
Value
>
val
(
cx
)
;
if
(
!
JS_IdToValue
(
cx
key
&
val
)
)
{
return
false
;
}
setSlot
(
KeySlot
val
)
;
return
true
;
}
void
ParseRecordObject
:
:
setEntries
(
JSContext
*
cx
Handle
<
EntryMap
*
>
entries
)
{
setSlot
(
EntriesSlot
ObjectValue
(
*
entries
)
)
;
}
void
ParseRecordObject
:
:
getEntries
(
JSContext
*
cx
MutableHandle
<
EntryMap
*
>
entries
)
{
const
Value
&
entryVal
=
getSlot
(
EntriesSlot
)
;
if
(
entryVal
.
isObject
(
)
)
{
entries
.
set
(
&
entryVal
.
toObject
(
)
)
;
}
}
