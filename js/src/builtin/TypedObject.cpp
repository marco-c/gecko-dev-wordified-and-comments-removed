#
include
"
builtin
/
TypedObject
-
inl
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
<
algorithm
>
#
include
"
gc
/
Marking
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
#
include
"
vm
/
JSAtom
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
IsPowerOfTwo
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PointerRangeSize
;
using
namespace
js
;
const
JSClass
js
:
:
TypedObjectModuleObject
:
:
class_
=
{
"
TypedObject
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_TypedObject
)
JS_NULL_CLASS_OPS
&
classSpec_
}
;
static
const
JSFunctionSpec
TypedObjectMethods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
objectType
"
"
TypeOfTypedObject
"
1
0
)
JS_FS_END
}
;
static
void
ReportCannotConvertTo
(
JSContext
*
cx
HandleValue
fromValue
const
char
*
toType
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_CONVERT_TO
InformalValueTypeName
(
fromValue
)
toType
)
;
}
template
<
typename
T
>
BigInt
*
CreateBigInt
(
JSContext
*
cx
T
i
)
;
template
<
>
BigInt
*
CreateBigInt
<
int64_t
>
(
JSContext
*
cx
int64_t
i
)
{
return
BigInt
:
:
createFromInt64
(
cx
i
)
;
}
template
<
>
BigInt
*
CreateBigInt
<
uint64_t
>
(
JSContext
*
cx
uint64_t
u
)
{
return
BigInt
:
:
createFromUint64
(
cx
u
)
;
}
template
<
typename
T
>
T
ConvertBigInt
(
BigInt
*
bi
)
;
template
<
>
int64_t
ConvertBigInt
<
int64_t
>
(
BigInt
*
bi
)
{
return
BigInt
:
:
toInt64
(
bi
)
;
}
template
<
>
uint64_t
ConvertBigInt
<
uint64_t
>
(
BigInt
*
bi
)
{
return
BigInt
:
:
toUint64
(
bi
)
;
}
template
<
class
T
>
static
inline
T
*
ToObjectIf
(
HandleValue
value
)
{
if
(
!
value
.
isObject
(
)
)
{
return
nullptr
;
}
if
(
!
value
.
toObject
(
)
.
is
<
T
>
(
)
)
{
return
nullptr
;
}
return
&
value
.
toObject
(
)
.
as
<
T
>
(
)
;
}
static
inline
CheckedInt32
RoundUpToAlignment
(
CheckedInt32
address
uint32_t
align
)
{
MOZ_ASSERT
(
IsPowerOfTwo
(
align
)
)
;
return
(
(
address
+
(
align
-
1
)
)
/
align
)
*
align
;
}
static
bool
ConvertAndCopyTo
(
JSContext
*
cx
HandleTypeDescr
typeObj
HandleTypedObject
typedObj
int32_t
offset
HandleAtom
name
HandleValue
val
)
{
FixedInvokeArgs
<
5
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
typeObj
)
;
args
[
1
]
.
setObject
(
*
typedObj
)
;
args
[
2
]
.
setInt32
(
offset
)
;
if
(
name
)
{
args
[
3
]
.
setString
(
name
)
;
}
else
{
args
[
3
]
.
setNull
(
)
;
}
args
[
4
]
.
set
(
val
)
;
RootedValue
dummy
(
cx
)
;
return
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
ConvertAndCopyTo
dummy
args
&
dummy
)
;
}
static
bool
ConvertAndCopyTo
(
JSContext
*
cx
HandleTypedObject
typedObj
HandleValue
val
)
{
Rooted
<
TypeDescr
*
>
type
(
cx
&
typedObj
-
>
typeDescr
(
)
)
;
return
ConvertAndCopyTo
(
cx
type
typedObj
0
nullptr
val
)
;
}
static
bool
Reify
(
JSContext
*
cx
HandleTypeDescr
type
HandleTypedObject
typedObj
size_t
offset
MutableHandleValue
to
)
{
FixedInvokeArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
setObject
(
*
type
)
;
args
[
1
]
.
setObject
(
*
typedObj
)
;
args
[
2
]
.
setInt32
(
offset
)
;
return
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
Reify
UndefinedHandleValue
args
to
)
;
}
static
JSObject
*
GetPrototype
(
JSContext
*
cx
HandleObject
obj
)
{
RootedValue
prototypeVal
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
prototype
&
prototypeVal
)
)
{
return
nullptr
;
}
if
(
!
prototypeVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_PROTOTYPE
)
;
return
nullptr
;
}
return
&
prototypeVal
.
toObject
(
)
;
}
const
JSClass
js
:
:
TypedProto
:
:
class_
=
{
"
TypedProto
"
JSCLASS_HAS_RESERVED_SLOTS
(
JS_TYPROTO_SLOTS
)
}
;
static
const
JSClassOps
ScalarTypeDescrClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypeDescr
:
:
finalize
ScalarTypeDescr
:
:
call
nullptr
nullptr
nullptr
}
;
const
JSClass
js
:
:
ScalarTypeDescr
:
:
class_
=
{
"
Scalar
"
JSCLASS_HAS_RESERVED_SLOTS
(
JS_DESCR_SLOTS
)
|
JSCLASS_BACKGROUND_FINALIZE
&
ScalarTypeDescrClassOps
}
;
const
JSFunctionSpec
js
:
:
ScalarTypeDescr
:
:
typeObjectMethods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
toSource
"
"
DescrToSource
"
0
0
)
JS_SELF_HOSTED_FN
(
"
array
"
"
ArrayShorthand
"
1
0
)
JS_SELF_HOSTED_FN
(
"
equivalent
"
"
TypeDescrEquivalent
"
1
0
)
JS_FS_END
}
;
uint32_t
ScalarTypeDescr
:
:
size
(
Type
t
)
{
return
AssertedCast
<
uint32_t
>
(
Scalar
:
:
byteSize
(
t
)
)
;
}
uint32_t
ScalarTypeDescr
:
:
alignment
(
Type
t
)
{
return
AssertedCast
<
uint32_t
>
(
Scalar
:
:
byteSize
(
t
)
)
;
}
const
char
*
ScalarTypeDescr
:
:
typeName
(
Type
type
)
{
switch
(
type
)
{
#
define
NUMERIC_TYPE_TO_STRING
(
constant_
type_
name_
)
\
case
constant_
:
\
return
#
name_
;
JS_FOR_EACH_SCALAR_TYPE_REPR
(
NUMERIC_TYPE_TO_STRING
)
#
undef
NUMERIC_TYPE_TO_STRING
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
case
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
Invalid
type
"
)
;
}
bool
ScalarTypeDescr
:
:
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
requireAtLeast
(
cx
args
.
callee
(
)
.
getClass
(
)
-
>
name
1
)
)
{
return
false
;
}
Rooted
<
ScalarTypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
ScalarTypeDescr
>
(
)
)
;
ScalarTypeDescr
:
:
Type
type
=
descr
-
>
type
(
)
;
switch
(
type
)
{
#
define
NUMBER_CALL
(
constant_
type_
name_
)
\
case
constant_
:
{
\
double
number
;
\
if
(
!
ToNumber
(
cx
args
[
0
]
&
number
)
)
{
\
return
false
;
\
}
\
if
(
type
=
=
Scalar
:
:
Uint8Clamped
)
{
\
number
=
ClampDoubleToUint8
(
number
)
;
\
}
\
type_
converted
=
ConvertScalar
<
type_
>
(
number
)
;
\
args
.
rval
(
)
.
setNumber
(
(
double
)
converted
)
;
\
return
true
;
\
}
JS_FOR_EACH_SCALAR_NUMBER_TYPE_REPR
(
NUMBER_CALL
)
#
undef
NUMBER_CALL
#
define
BIGINT_CALL
(
constant_
type_
name_
)
\
case
constant_
:
{
\
BigInt
*
bi
=
ToBigInt
(
cx
args
[
0
]
)
;
\
if
(
!
bi
)
{
\
return
false
;
\
}
\
type_
converted
=
ConvertBigInt
<
type_
>
(
bi
)
;
\
BigInt
*
ret
=
CreateBigInt
<
type_
>
(
cx
converted
)
;
\
if
(
!
ret
)
{
\
return
false
;
\
}
\
args
.
rval
(
)
.
setBigInt
(
ret
)
;
\
return
true
;
\
}
JS_FOR_EACH_SCALAR_BIGINT_TYPE_REPR
(
BIGINT_CALL
)
#
undef
BIGINT_CALL
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
case
Scalar
:
:
MaxTypedArrayViewType
:
MOZ_CRASH
(
)
;
}
return
true
;
}
TypeDescr
*
GlobalObject
:
:
getOrCreateScalarTypeDescr
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
Scalar
:
:
Type
scalarType
)
{
int32_t
slot
=
0
;
switch
(
scalarType
)
{
case
Scalar
:
:
Int32
:
slot
=
TypedObjectModuleObject
:
:
Int32Desc
;
break
;
case
Scalar
:
:
Int64
:
slot
=
TypedObjectModuleObject
:
:
Int64Desc
;
break
;
case
Scalar
:
:
Float32
:
slot
=
TypedObjectModuleObject
:
:
Float32Desc
;
break
;
case
Scalar
:
:
Float64
:
slot
=
TypedObjectModuleObject
:
:
Float64Desc
;
break
;
default
:
MOZ_CRASH
(
"
NYI
"
)
;
}
Rooted
<
TypedObjectModuleObject
*
>
module
(
cx
&
GlobalObject
:
:
getOrCreateTypedObjectModule
(
cx
global
)
-
>
as
<
TypedObjectModuleObject
>
(
)
)
;
if
(
!
module
)
{
return
nullptr
;
}
return
&
module
-
>
getReservedSlot
(
slot
)
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
;
}
TypeDescr
*
GlobalObject
:
:
getOrCreateReferenceTypeDescr
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
ReferenceType
type
)
{
int32_t
slot
=
0
;
switch
(
type
)
{
case
ReferenceType
:
:
TYPE_OBJECT
:
slot
=
TypedObjectModuleObject
:
:
ObjectDesc
;
break
;
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
slot
=
TypedObjectModuleObject
:
:
WasmAnyRefDesc
;
break
;
default
:
MOZ_CRASH
(
"
NYI
"
)
;
}
Rooted
<
TypedObjectModuleObject
*
>
module
(
cx
&
GlobalObject
:
:
getOrCreateTypedObjectModule
(
cx
global
)
-
>
as
<
TypedObjectModuleObject
>
(
)
)
;
if
(
!
module
)
{
return
nullptr
;
}
return
&
module
-
>
getReservedSlot
(
slot
)
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
;
}
static
const
JSClassOps
ReferenceTypeDescrClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypeDescr
:
:
finalize
ReferenceTypeDescr
:
:
call
nullptr
nullptr
nullptr
}
;
const
JSClass
js
:
:
ReferenceTypeDescr
:
:
class_
=
{
"
Reference
"
JSCLASS_HAS_RESERVED_SLOTS
(
JS_DESCR_SLOTS
)
|
JSCLASS_BACKGROUND_FINALIZE
&
ReferenceTypeDescrClassOps
}
;
const
JSFunctionSpec
js
:
:
ReferenceTypeDescr
:
:
typeObjectMethods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
toSource
"
"
DescrToSource
"
0
0
)
{
JSFunctionSpec
:
:
Name
(
"
array
"
)
{
nullptr
nullptr
}
1
0
"
ArrayShorthand
"
}
{
JSFunctionSpec
:
:
Name
(
"
equivalent
"
)
{
nullptr
nullptr
}
1
0
"
TypeDescrEquivalent
"
}
JS_FS_END
}
;
static
const
uint32_t
ReferenceSizes
[
]
=
{
#
define
REFERENCE_SIZE
(
_kind
_type
_name
)
sizeof
(
_type
)
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
REFERENCE_SIZE
)
0
#
undef
REFERENCE_SIZE
}
;
uint32_t
ReferenceTypeDescr
:
:
size
(
Type
t
)
{
return
ReferenceSizes
[
uint32_t
(
t
)
]
;
}
uint32_t
ReferenceTypeDescr
:
:
alignment
(
Type
t
)
{
return
ReferenceSizes
[
uint32_t
(
t
)
]
;
}
const
char
*
ReferenceTypeDescr
:
:
typeName
(
Type
type
)
{
switch
(
type
)
{
#
define
NUMERIC_TYPE_TO_STRING
(
constant_
type_
name_
)
\
case
constant_
:
\
return
#
name_
;
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
NUMERIC_TYPE_TO_STRING
)
#
undef
NUMERIC_TYPE_TO_STRING
}
MOZ_CRASH
(
"
Invalid
type
"
)
;
}
bool
js
:
:
ReferenceTypeDescr
:
:
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
callee
(
)
.
is
<
ReferenceTypeDescr
>
(
)
)
;
Rooted
<
ReferenceTypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
ReferenceTypeDescr
>
(
)
)
;
if
(
!
args
.
requireAtLeast
(
cx
descr
-
>
typeName
(
)
1
)
)
{
return
false
;
}
switch
(
descr
-
>
type
(
)
)
{
case
ReferenceType
:
:
TYPE_ANY
:
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
case
ReferenceType
:
:
TYPE_OBJECT
:
{
RootedObject
obj
(
cx
ToObject
(
cx
args
[
0
]
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
case
ReferenceType
:
:
TYPE_STRING
:
{
RootedString
obj
(
cx
ToString
<
CanGC
>
(
cx
args
[
0
]
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
&
*
obj
)
;
return
true
;
}
}
MOZ_CRASH
(
"
Unhandled
Reference
type
"
)
;
}
static
TypedProto
*
CreatePrototypeObjectForComplexTypeInstance
(
JSContext
*
cx
HandleObject
ctorPrototype
)
{
RootedObject
ctorPrototypePrototype
(
cx
GetPrototype
(
cx
ctorPrototype
)
)
;
if
(
!
ctorPrototypePrototype
)
{
return
nullptr
;
}
return
NewSingletonObjectWithGivenProto
<
TypedProto
>
(
cx
ctorPrototypePrototype
)
;
}
static
const
JSClassOps
ArrayTypeDescrClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypeDescr
:
:
finalize
nullptr
nullptr
TypedObject
:
:
construct
nullptr
}
;
const
JSClass
ArrayTypeDescr
:
:
class_
=
{
"
ArrayType
"
JSCLASS_HAS_RESERVED_SLOTS
(
JS_DESCR_SLOTS
)
|
JSCLASS_BACKGROUND_FINALIZE
&
ArrayTypeDescrClassOps
}
;
const
JSPropertySpec
ArrayMetaTypeDescr
:
:
typeObjectProperties
[
]
=
{
JS_PS_END
}
;
const
JSFunctionSpec
ArrayMetaTypeDescr
:
:
typeObjectMethods
[
]
=
{
{
JSFunctionSpec
:
:
Name
(
"
array
"
)
{
nullptr
nullptr
}
1
0
"
ArrayShorthand
"
}
JS_SELF_HOSTED_FN
(
"
toSource
"
"
DescrToSource
"
0
0
)
{
JSFunctionSpec
:
:
Name
(
"
equivalent
"
)
{
nullptr
nullptr
}
1
0
"
TypeDescrEquivalent
"
}
JS_SELF_HOSTED_FN
(
"
build
"
"
TypedObjectArrayTypeBuild
"
3
0
)
JS_SELF_HOSTED_FN
(
"
from
"
"
TypedObjectArrayTypeFrom
"
3
0
)
JS_FS_END
}
;
const
JSPropertySpec
ArrayMetaTypeDescr
:
:
typedObjectProperties
[
]
=
{
JS_PS_END
}
;
const
JSFunctionSpec
ArrayMetaTypeDescr
:
:
typedObjectMethods
[
]
=
{
{
JSFunctionSpec
:
:
Name
(
"
forEach
"
)
{
nullptr
nullptr
}
1
0
"
ArrayForEach
"
}
{
JSFunctionSpec
:
:
Name
(
"
redimension
"
)
{
nullptr
nullptr
}
1
0
"
TypedObjectArrayRedimension
"
}
JS_SELF_HOSTED_FN
(
"
map
"
"
TypedObjectArrayMap
"
2
0
)
JS_SELF_HOSTED_FN
(
"
reduce
"
"
TypedObjectArrayReduce
"
2
0
)
JS_SELF_HOSTED_FN
(
"
filter
"
"
TypedObjectArrayFilter
"
1
0
)
JS_FS_END
}
;
bool
js
:
:
CreateUserSizeAndAlignmentProperties
(
JSContext
*
cx
HandleTypeDescr
descr
)
{
if
(
descr
-
>
transparent
(
)
)
{
RootedValue
typeByteLength
(
cx
Int32Value
(
AssertedCast
<
int32_t
>
(
descr
-
>
size
(
)
)
)
)
;
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
byteLength
typeByteLength
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
RootedValue
typeByteAlignment
(
cx
Int32Value
(
descr
-
>
alignment
(
)
)
)
;
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
byteAlignment
typeByteAlignment
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
}
else
{
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
byteLength
UndefinedHandleValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
byteAlignment
UndefinedHandleValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
CreateTraceList
(
JSContext
*
cx
HandleTypeDescr
descr
)
;
ArrayTypeDescr
*
ArrayMetaTypeDescr
:
:
create
(
JSContext
*
cx
HandleObject
arrayTypePrototype
HandleTypeDescr
elementType
HandleAtom
stringRepr
int32_t
size
int32_t
length
)
{
MOZ_ASSERT
(
arrayTypePrototype
)
;
Rooted
<
ArrayTypeDescr
*
>
obj
(
cx
)
;
obj
=
NewSingletonObjectWithGivenProto
<
ArrayTypeDescr
>
(
cx
arrayTypePrototype
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_KIND
Int32Value
(
ArrayTypeDescr
:
:
Kind
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRING_REPR
StringValue
(
stringRepr
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_ALIGNMENT
Int32Value
(
elementType
-
>
alignment
(
)
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_SIZE
Int32Value
(
size
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_OPAQUE
BooleanValue
(
elementType
-
>
opaque
(
)
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_ARRAY_ELEM_TYPE
ObjectValue
(
*
elementType
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_ARRAY_LENGTH
Int32Value
(
length
)
)
;
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_FLAGS
Int32Value
(
JS_DESCR_FLAG_ALLOW_CONSTRUCT
)
)
;
RootedValue
elementTypeVal
(
cx
ObjectValue
(
*
elementType
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
cx
-
>
names
(
)
.
elementType
elementTypeVal
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
RootedValue
lengthValue
(
cx
NumberValue
(
length
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
cx
-
>
names
(
)
.
length
lengthValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
if
(
!
CreateUserSizeAndAlignmentProperties
(
cx
obj
)
)
{
return
nullptr
;
}
Rooted
<
TypedProto
*
>
prototypeObj
(
cx
)
;
if
(
elementType
-
>
getReservedSlot
(
JS_DESCR_SLOT_ARRAYPROTO
)
.
isObject
(
)
)
{
prototypeObj
=
&
elementType
-
>
getReservedSlot
(
JS_DESCR_SLOT_ARRAYPROTO
)
.
toObject
(
)
.
as
<
TypedProto
>
(
)
;
}
else
{
prototypeObj
=
CreatePrototypeObjectForComplexTypeInstance
(
cx
arrayTypePrototype
)
;
if
(
!
prototypeObj
)
{
return
nullptr
;
}
elementType
-
>
setReservedSlot
(
JS_DESCR_SLOT_ARRAYPROTO
ObjectValue
(
*
prototypeObj
)
)
;
}
obj
-
>
initReservedSlot
(
JS_DESCR_SLOT_TYPROTO
ObjectValue
(
*
prototypeObj
)
)
;
if
(
!
LinkConstructorAndPrototype
(
cx
obj
prototypeObj
)
)
{
return
nullptr
;
}
if
(
!
CreateTraceList
(
cx
obj
)
)
{
return
nullptr
;
}
if
(
!
cx
-
>
zone
(
)
-
>
addTypeDescrObject
(
cx
obj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
obj
;
}
bool
ArrayMetaTypeDescr
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ArrayType
"
)
)
{
return
false
;
}
RootedObject
arrayTypeGlobal
(
cx
&
args
.
callee
(
)
)
;
if
(
!
args
.
requireAtLeast
(
cx
"
ArrayType
"
2
)
)
{
return
false
;
}
if
(
!
args
[
0
]
.
isObject
(
)
|
|
!
args
[
0
]
.
toObject
(
)
.
is
<
TypeDescr
>
(
)
)
{
ReportCannotConvertTo
(
cx
args
[
0
]
"
ArrayType
element
specifier
"
)
;
return
false
;
}
if
(
!
args
[
1
]
.
isInt32
(
)
|
|
args
[
1
]
.
toInt32
(
)
<
0
)
{
ReportCannotConvertTo
(
cx
args
[
1
]
"
ArrayType
length
specifier
"
)
;
return
false
;
}
Rooted
<
TypeDescr
*
>
elementType
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
)
;
int32_t
length
=
args
[
1
]
.
toInt32
(
)
;
CheckedInt32
size
=
CheckedInt32
(
elementType
-
>
size
(
)
)
*
length
;
if
(
!
size
.
isValid
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_TOO_BIG
)
;
return
false
;
}
StringBuffer
contents
(
cx
)
;
if
(
!
contents
.
append
(
"
new
ArrayType
(
"
)
)
{
return
false
;
}
if
(
!
contents
.
append
(
&
elementType
-
>
stringRepr
(
)
)
)
{
return
false
;
}
if
(
!
contents
.
append
(
"
"
)
)
{
return
false
;
}
if
(
!
NumberValueToStringBuffer
(
cx
NumberValue
(
length
)
contents
)
)
{
return
false
;
}
if
(
!
contents
.
append
(
"
)
"
)
)
{
return
false
;
}
RootedAtom
stringRepr
(
cx
contents
.
finishAtom
(
)
)
;
if
(
!
stringRepr
)
{
return
false
;
}
RootedObject
arrayTypePrototype
(
cx
GetPrototype
(
cx
arrayTypeGlobal
)
)
;
if
(
!
arrayTypePrototype
)
{
return
false
;
}
Rooted
<
ArrayTypeDescr
*
>
obj
(
cx
)
;
obj
=
create
(
cx
arrayTypePrototype
elementType
stringRepr
size
.
value
(
)
length
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
const
JSClassOps
StructTypeDescrClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypeDescr
:
:
finalize
StructTypeDescr
:
:
call
nullptr
TypedObject
:
:
construct
nullptr
}
;
const
JSClass
StructTypeDescr
:
:
class_
=
{
"
StructType
"
JSCLASS_HAS_RESERVED_SLOTS
(
JS_DESCR_SLOTS
)
|
JSCLASS_BACKGROUND_FINALIZE
&
StructTypeDescrClassOps
}
;
const
JSPropertySpec
StructMetaTypeDescr
:
:
typeObjectProperties
[
]
=
{
JS_PS_END
}
;
const
JSFunctionSpec
StructMetaTypeDescr
:
:
typeObjectMethods
[
]
=
{
{
JSFunctionSpec
:
:
Name
(
"
array
"
)
{
nullptr
nullptr
}
1
0
"
ArrayShorthand
"
}
JS_SELF_HOSTED_FN
(
"
toSource
"
"
DescrToSource
"
0
0
)
{
JSFunctionSpec
:
:
Name
(
"
equivalent
"
)
{
nullptr
nullptr
}
1
0
"
TypeDescrEquivalent
"
}
JS_FS_END
}
;
const
JSPropertySpec
StructMetaTypeDescr
:
:
typedObjectProperties
[
]
=
{
JS_PS_END
}
;
const
JSFunctionSpec
StructMetaTypeDescr
:
:
typedObjectMethods
[
]
=
{
JS_FS_END
}
;
CheckedInt32
StructMetaTypeDescr
:
:
Layout
:
:
addField
(
int32_t
fieldAlignment
int32_t
fieldSize
)
{
structAlignment
=
std
:
:
max
(
structAlignment
fieldAlignment
)
;
CheckedInt32
offset
=
RoundUpToAlignment
(
sizeSoFar
fieldAlignment
)
;
if
(
!
offset
.
isValid
(
)
)
{
return
offset
;
}
sizeSoFar
=
offset
+
fieldSize
;
if
(
!
sizeSoFar
.
isValid
(
)
)
{
return
sizeSoFar
;
}
return
offset
;
}
CheckedInt32
StructMetaTypeDescr
:
:
Layout
:
:
addScalar
(
Scalar
:
:
Type
type
)
{
return
addField
(
ScalarTypeDescr
:
:
alignment
(
type
)
ScalarTypeDescr
:
:
size
(
type
)
)
;
}
CheckedInt32
StructMetaTypeDescr
:
:
Layout
:
:
addReference
(
ReferenceType
type
)
{
return
addField
(
ReferenceTypeDescr
:
:
alignment
(
type
)
ReferenceTypeDescr
:
:
size
(
type
)
)
;
}
CheckedInt32
StructMetaTypeDescr
:
:
Layout
:
:
close
(
int32_t
*
alignment
)
{
if
(
alignment
)
{
*
alignment
=
structAlignment
;
}
return
RoundUpToAlignment
(
sizeSoFar
structAlignment
)
;
}
JSObject
*
StructMetaTypeDescr
:
:
create
(
JSContext
*
cx
HandleObject
metaTypeDescr
HandleObject
fields
)
{
RootedIdVector
ids
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
fields
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
ids
)
)
{
return
nullptr
;
}
RootedValueVector
fieldTypeObjs
(
cx
)
;
bool
opaque
=
false
;
Vector
<
StructFieldProps
>
fieldProps
(
cx
)
;
RootedValue
fieldTypeVal
(
cx
)
;
RootedId
id
(
cx
)
;
Rooted
<
TypeDescr
*
>
fieldType
(
cx
)
;
for
(
unsigned
int
i
=
0
;
i
<
ids
.
length
(
)
;
i
+
+
)
{
id
=
ids
[
i
]
;
uint32_t
unused
;
if
(
!
JSID_IS_ATOM
(
id
)
|
|
JSID_TO_ATOM
(
id
)
-
>
isIndex
(
&
unused
)
)
{
RootedValue
idValue
(
cx
IdToValue
(
id
)
)
;
ReportCannotConvertTo
(
cx
idValue
"
StructType
field
name
"
)
;
return
nullptr
;
}
if
(
!
GetProperty
(
cx
fields
fields
id
&
fieldTypeVal
)
)
{
return
nullptr
;
}
fieldType
=
ToObjectIf
<
TypeDescr
>
(
fieldTypeVal
)
;
if
(
!
fieldType
)
{
ReportCannotConvertTo
(
cx
fieldTypeVal
"
StructType
field
specifier
"
)
;
return
nullptr
;
}
if
(
!
fieldTypeObjs
.
append
(
ObjectValue
(
*
fieldType
)
)
)
{
return
nullptr
;
}
StructFieldProps
props
;
props
.
isMutable
=
true
;
if
(
!
fieldProps
.
append
(
props
)
)
{
return
nullptr
;
}
if
(
fieldType
-
>
opaque
(
)
)
{
opaque
=
true
;
}
}
RootedObject
structTypePrototype
(
cx
GetPrototype
(
cx
metaTypeDescr
)
)
;
if
(
!
structTypePrototype
)
{
return
nullptr
;
}
return
createFromArrays
(
cx
structTypePrototype
opaque
true
ids
fieldTypeObjs
fieldProps
)
;
}
StructTypeDescr
*
StructMetaTypeDescr
:
:
createFromArrays
(
JSContext
*
cx
HandleObject
structTypePrototype
bool
opaque
bool
allowConstruct
HandleIdVector
ids
JS
:
:
HandleValueVector
fieldTypeObjs
Vector
<
StructFieldProps
>
&
fieldProps
)
{
StringBuffer
stringBuffer
(
cx
)
;
RootedValueVector
fieldNames
(
cx
)
;
RootedValueVector
fieldOffsets
(
cx
)
;
RootedValueVector
fieldMuts
(
cx
)
;
RootedObject
userFieldOffsets
(
cx
)
;
RootedObject
userFieldTypes
(
cx
)
;
Layout
layout
;
userFieldOffsets
=
NewTenuredBuiltinClassInstance
<
PlainObject
>
(
cx
)
;
if
(
!
userFieldOffsets
)
{
return
nullptr
;
}
userFieldTypes
=
NewTenuredBuiltinClassInstance
<
PlainObject
>
(
cx
)
;
if
(
!
userFieldTypes
)
{
return
nullptr
;
}
if
(
!
stringBuffer
.
append
(
"
new
StructType
(
{
"
)
)
{
return
nullptr
;
}
RootedId
id
(
cx
)
;
Rooted
<
TypeDescr
*
>
fieldType
(
cx
)
;
for
(
unsigned
int
i
=
0
;
i
<
ids
.
length
(
)
;
i
+
+
)
{
id
=
ids
[
i
]
;
RootedValue
fieldName
(
cx
IdToValue
(
id
)
)
;
if
(
!
fieldNames
.
append
(
fieldName
)
)
{
return
nullptr
;
}
fieldType
=
ToObjectIf
<
TypeDescr
>
(
fieldTypeObjs
[
i
]
)
;
if
(
!
DefineDataProperty
(
cx
userFieldTypes
id
fieldTypeObjs
[
i
]
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
if
(
i
>
0
&
&
!
stringBuffer
.
append
(
"
"
)
)
{
return
nullptr
;
}
if
(
!
stringBuffer
.
append
(
JSID_TO_ATOM
(
id
)
)
)
{
return
nullptr
;
}
if
(
!
stringBuffer
.
append
(
"
:
"
)
)
{
return
nullptr
;
}
if
(
!
stringBuffer
.
append
(
&
fieldType
-
>
stringRepr
(
)
)
)
{
return
nullptr
;
}
CheckedInt32
offset
;
if
(
fieldProps
[
i
]
.
alignAsInt64
)
{
offset
=
layout
.
addField
(
ScalarTypeDescr
:
:
alignment
(
Scalar
:
:
Int64
)
fieldType
-
>
size
(
)
)
;
}
else
if
(
fieldProps
[
i
]
.
alignAsV128
)
{
offset
=
layout
.
addField
(
ScalarTypeDescr
:
:
alignment
(
Scalar
:
:
Simd128
)
fieldType
-
>
size
(
)
)
;
}
else
{
offset
=
layout
.
addField
(
fieldType
-
>
alignment
(
)
fieldType
-
>
size
(
)
)
;
}
if
(
!
offset
.
isValid
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_TOO_BIG
)
;
return
nullptr
;
}
MOZ_ASSERT
(
offset
.
value
(
)
>
=
0
)
;
if
(
!
fieldOffsets
.
append
(
Int32Value
(
offset
.
value
(
)
)
)
)
{
return
nullptr
;
}
if
(
!
fieldMuts
.
append
(
BooleanValue
(
fieldProps
[
i
]
.
isMutable
)
)
)
{
return
nullptr
;
}
RootedValue
offsetValue
(
cx
Int32Value
(
offset
.
value
(
)
)
)
;
if
(
!
DefineDataProperty
(
cx
userFieldOffsets
id
offsetValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
}
if
(
!
stringBuffer
.
append
(
"
}
)
"
)
)
{
return
nullptr
;
}
RootedAtom
stringRepr
(
cx
stringBuffer
.
finishAtom
(
)
)
;
if
(
!
stringRepr
)
{
return
nullptr
;
}
int32_t
alignment
;
CheckedInt32
totalSize
=
layout
.
close
(
&
alignment
)
;
if
(
!
totalSize
.
isValid
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_TOO_BIG
)
;
return
nullptr
;
}
Rooted
<
StructTypeDescr
*
>
descr
(
cx
)
;
descr
=
NewSingletonObjectWithGivenProto
<
StructTypeDescr
>
(
cx
structTypePrototype
)
;
if
(
!
descr
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_KIND
Int32Value
(
type
:
:
Struct
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRING_REPR
StringValue
(
stringRepr
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_ALIGNMENT
Int32Value
(
AssertedCast
<
int32_t
>
(
alignment
)
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_SIZE
Int32Value
(
totalSize
.
value
(
)
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_OPAQUE
BooleanValue
(
opaque
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_FLAGS
Int32Value
(
allowConstruct
?
JS_DESCR_FLAG_ALLOW_CONSTRUCT
:
0
)
)
;
{
RootedObject
fieldNamesVec
(
cx
)
;
fieldNamesVec
=
NewDenseCopiedArray
(
cx
fieldNames
.
length
(
)
fieldNames
.
begin
(
)
nullptr
TenuredObject
)
;
if
(
!
fieldNamesVec
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRUCT_FIELD_NAMES
ObjectValue
(
*
fieldNamesVec
)
)
;
}
RootedObject
fieldTypeVec
(
cx
)
;
fieldTypeVec
=
NewDenseCopiedArray
(
cx
fieldTypeObjs
.
length
(
)
fieldTypeObjs
.
begin
(
)
nullptr
TenuredObject
)
;
if
(
!
fieldTypeVec
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRUCT_FIELD_TYPES
ObjectValue
(
*
fieldTypeVec
)
)
;
{
RootedObject
fieldOffsetsVec
(
cx
)
;
fieldOffsetsVec
=
NewDenseCopiedArray
(
cx
fieldOffsets
.
length
(
)
fieldOffsets
.
begin
(
)
nullptr
TenuredObject
)
;
if
(
!
fieldOffsetsVec
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRUCT_FIELD_OFFSETS
ObjectValue
(
*
fieldOffsetsVec
)
)
;
}
{
RootedObject
fieldMutsVec
(
cx
)
;
fieldMutsVec
=
NewDenseCopiedArray
(
cx
fieldMuts
.
length
(
)
fieldMuts
.
begin
(
)
nullptr
TenuredObject
)
;
if
(
!
fieldMutsVec
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRUCT_FIELD_MUTS
ObjectValue
(
*
fieldMutsVec
)
)
;
}
if
(
!
FreezeObject
(
cx
userFieldOffsets
)
)
{
return
nullptr
;
}
if
(
!
FreezeObject
(
cx
userFieldTypes
)
)
{
return
nullptr
;
}
RootedValue
userFieldOffsetsValue
(
cx
ObjectValue
(
*
userFieldOffsets
)
)
;
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
fieldOffsets
userFieldOffsetsValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
RootedValue
userFieldTypesValue
(
cx
ObjectValue
(
*
userFieldTypes
)
)
;
if
(
!
DefineDataProperty
(
cx
descr
cx
-
>
names
(
)
.
fieldTypes
userFieldTypesValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
if
(
!
CreateUserSizeAndAlignmentProperties
(
cx
descr
)
)
{
return
nullptr
;
}
Rooted
<
TypedProto
*
>
prototypeObj
(
cx
)
;
prototypeObj
=
CreatePrototypeObjectForComplexTypeInstance
(
cx
structTypePrototype
)
;
if
(
!
prototypeObj
)
{
return
nullptr
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_TYPROTO
ObjectValue
(
*
prototypeObj
)
)
;
if
(
!
LinkConstructorAndPrototype
(
cx
descr
prototypeObj
)
)
{
return
nullptr
;
}
if
(
!
CreateTraceList
(
cx
descr
)
)
{
return
nullptr
;
}
if
(
!
cx
-
>
zone
(
)
-
>
addTypeDescrObject
(
cx
descr
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
descr
;
}
bool
StructMetaTypeDescr
:
:
construct
(
JSContext
*
cx
unsigned
int
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
StructType
"
)
)
{
return
false
;
}
if
(
args
.
length
(
)
>
=
1
&
&
args
[
0
]
.
isObject
(
)
)
{
RootedObject
metaTypeDescr
(
cx
&
args
.
callee
(
)
)
;
RootedObject
fields
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedObject
obj
(
cx
create
(
cx
metaTypeDescr
fields
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_STRUCTTYPE_BAD_ARGS
)
;
return
false
;
}
size_t
StructTypeDescr
:
:
fieldCount
(
)
const
{
return
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_NAMES
)
.
getDenseInitializedLength
(
)
;
}
bool
StructTypeDescr
:
:
fieldIndex
(
jsid
id
size_t
*
out
)
const
{
ArrayObject
&
fieldNames
=
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_NAMES
)
;
size_t
l
=
fieldNames
.
getDenseInitializedLength
(
)
;
for
(
size_t
i
=
0
;
i
<
l
;
i
+
+
)
{
JSAtom
&
a
=
fieldNames
.
getDenseElement
(
i
)
.
toString
(
)
-
>
asAtom
(
)
;
if
(
JSID_IS_ATOM
(
id
&
a
)
)
{
*
out
=
i
;
return
true
;
}
}
return
false
;
}
JSAtom
&
StructTypeDescr
:
:
fieldName
(
size_t
index
)
const
{
return
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_NAMES
)
.
getDenseElement
(
index
)
.
toString
(
)
-
>
asAtom
(
)
;
}
size_t
StructTypeDescr
:
:
fieldOffset
(
size_t
index
)
const
{
ArrayObject
&
fieldOffsets
=
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_OFFSETS
)
;
MOZ_ASSERT
(
index
<
fieldOffsets
.
getDenseInitializedLength
(
)
)
;
return
AssertedCast
<
size_t
>
(
fieldOffsets
.
getDenseElement
(
index
)
.
toInt32
(
)
)
;
}
bool
StructTypeDescr
:
:
fieldIsMutable
(
size_t
index
)
const
{
ArrayObject
&
fieldMuts
=
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_MUTS
)
;
MOZ_ASSERT
(
index
<
fieldMuts
.
getDenseInitializedLength
(
)
)
;
return
fieldMuts
.
getDenseElement
(
index
)
.
toBoolean
(
)
;
}
TypeDescr
&
StructTypeDescr
:
:
fieldDescr
(
size_t
index
)
const
{
ArrayObject
&
fieldDescrs
=
fieldInfoObject
(
JS_DESCR_SLOT_STRUCT_FIELD_TYPES
)
;
MOZ_ASSERT
(
index
<
fieldDescrs
.
getDenseInitializedLength
(
)
)
;
return
fieldDescrs
.
getDenseElement
(
index
)
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
;
}
bool
StructTypeDescr
:
:
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_STRUCTTYPE_NOT_CALLABLE
)
;
return
false
;
}
template
<
typename
T
>
static
bool
DefineSimpleTypeDescr
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleObject
module
typename
T
:
:
Type
type
HandlePropertyName
className
)
{
RootedObject
objProto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
objProto
)
{
return
false
;
}
RootedObject
funcProto
(
cx
GlobalObject
:
:
getOrCreateFunctionPrototype
(
cx
global
)
)
;
if
(
!
funcProto
)
{
return
false
;
}
Rooted
<
T
*
>
descr
(
cx
NewSingletonObjectWithGivenProto
<
T
>
(
cx
funcProto
)
)
;
if
(
!
descr
)
{
return
false
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_KIND
Int32Value
(
T
:
:
Kind
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_STRING_REPR
StringValue
(
className
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_ALIGNMENT
Int32Value
(
T
:
:
alignment
(
type
)
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_SIZE
Int32Value
(
AssertedCast
<
int32_t
>
(
T
:
:
size
(
type
)
)
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_OPAQUE
BooleanValue
(
T
:
:
Opaque
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_TYPE
Int32Value
(
int32_t
(
type
)
)
)
;
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_FLAGS
Int32Value
(
0
)
)
;
if
(
!
CreateUserSizeAndAlignmentProperties
(
cx
descr
)
)
{
return
false
;
}
if
(
!
JS_DefineFunctions
(
cx
descr
T
:
:
typeObjectMethods
)
)
{
return
false
;
}
Rooted
<
TypedProto
*
>
proto
(
cx
)
;
proto
=
NewTenuredObjectWithGivenProto
<
TypedProto
>
(
cx
objProto
)
;
if
(
!
proto
)
{
return
false
;
}
descr
-
>
initReservedSlot
(
JS_DESCR_SLOT_TYPROTO
ObjectValue
(
*
proto
)
)
;
RootedValue
descrValue
(
cx
ObjectValue
(
*
descr
)
)
;
if
(
!
DefineDataProperty
(
cx
module
className
descrValue
0
)
)
{
return
false
;
}
if
(
!
CreateTraceList
(
cx
descr
)
)
{
return
false
;
}
if
(
!
cx
-
>
zone
(
)
-
>
addTypeDescrObject
(
cx
descr
)
)
{
return
false
;
}
return
true
;
}
template
<
typename
T
>
static
JSObject
*
DefineMetaTypeDescr
(
JSContext
*
cx
const
char
*
name
Handle
<
GlobalObject
*
>
global
Handle
<
TypedObjectModuleObject
*
>
module
TypedObjectModuleObject
:
:
Slot
protoSlot
)
{
RootedAtom
className
(
cx
Atomize
(
cx
name
strlen
(
name
)
)
)
;
if
(
!
className
)
{
return
nullptr
;
}
RootedObject
funcProto
(
cx
GlobalObject
:
:
getOrCreateFunctionPrototype
(
cx
global
)
)
;
if
(
!
funcProto
)
{
return
nullptr
;
}
RootedObject
proto
(
cx
NewSingletonObjectWithGivenProto
<
PlainObject
>
(
cx
funcProto
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
RootedObject
objProto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
objProto
)
{
return
nullptr
;
}
RootedObject
protoProto
(
cx
)
;
protoProto
=
NewSingletonObjectWithGivenProto
<
PlainObject
>
(
cx
objProto
)
;
if
(
!
protoProto
)
{
return
nullptr
;
}
RootedValue
protoProtoValue
(
cx
ObjectValue
(
*
protoProto
)
)
;
if
(
!
DefineDataProperty
(
cx
proto
cx
-
>
names
(
)
.
prototype
protoProtoValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
const
int
constructorLength
=
2
;
RootedFunction
ctor
(
cx
)
;
ctor
=
GlobalObject
:
:
createConstructor
(
cx
T
:
:
construct
className
constructorLength
)
;
if
(
!
ctor
|
|
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
|
|
!
DefinePropertiesAndFunctions
(
cx
proto
T
:
:
typeObjectProperties
T
:
:
typeObjectMethods
)
|
|
!
DefinePropertiesAndFunctions
(
cx
protoProto
T
:
:
typedObjectProperties
T
:
:
typedObjectMethods
)
)
{
return
nullptr
;
}
module
-
>
initReservedSlot
(
protoSlot
ObjectValue
(
*
proto
)
)
;
return
ctor
;
}
static
JSObject
*
CreateTypedObjectModuleObject
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
objProto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
objProto
)
{
return
nullptr
;
}
return
NewSingletonObjectWithGivenProto
<
TypedObjectModuleObject
>
(
cx
objProto
)
;
}
static
bool
TypedObjectModuleObjectClassFinish
(
JSContext
*
cx
HandleObject
ctor
HandleObject
proto
)
{
Handle
<
TypedObjectModuleObject
*
>
module
=
ctor
.
as
<
TypedObjectModuleObject
>
(
)
;
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
#
define
BINARYDATA_SCALAR_DEFINE
(
constant_
type_
name_
)
\
if
(
!
DefineSimpleTypeDescr
<
ScalarTypeDescr
>
(
cx
global
module
constant_
\
cx
-
>
names
(
)
.
name_
)
)
\
return
false
;
JS_FOR_EACH_SCALAR_TYPE_REPR
(
BINARYDATA_SCALAR_DEFINE
)
#
undef
BINARYDATA_SCALAR_DEFINE
#
define
BINARYDATA_REFERENCE_DEFINE
(
constant_
type_
name_
)
\
if
(
!
DefineSimpleTypeDescr
<
ReferenceTypeDescr
>
(
\
cx
global
module
constant_
cx
-
>
names
(
)
.
name_
)
)
\
return
false
;
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
BINARYDATA_REFERENCE_DEFINE
)
#
undef
BINARYDATA_REFERENCE_DEFINE
RootedValue
typeDescr
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
module
"
int32
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
Int32Desc
typeDescr
)
;
if
(
!
JS_GetProperty
(
cx
module
"
int64
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
Int64Desc
typeDescr
)
;
if
(
!
JS_GetProperty
(
cx
module
"
float32
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
Float32Desc
typeDescr
)
;
if
(
!
JS_GetProperty
(
cx
module
"
float64
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
Float64Desc
typeDescr
)
;
if
(
!
JS_GetProperty
(
cx
module
"
Object
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
ObjectDesc
typeDescr
)
;
if
(
!
JS_GetProperty
(
cx
module
"
WasmAnyRef
"
&
typeDescr
)
)
{
return
false
;
}
module
-
>
initReservedSlot
(
TypedObjectModuleObject
:
:
WasmAnyRefDesc
typeDescr
)
;
RootedObject
arrayType
(
cx
)
;
arrayType
=
DefineMetaTypeDescr
<
ArrayMetaTypeDescr
>
(
cx
"
ArrayType
"
global
module
TypedObjectModuleObject
:
:
ArrayTypePrototype
)
;
if
(
!
arrayType
)
{
return
false
;
}
RootedValue
arrayTypeValue
(
cx
ObjectValue
(
*
arrayType
)
)
;
if
(
!
DefineDataProperty
(
cx
module
cx
-
>
names
(
)
.
ArrayType
arrayTypeValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
RootedObject
structType
(
cx
)
;
structType
=
DefineMetaTypeDescr
<
StructMetaTypeDescr
>
(
cx
"
StructType
"
global
module
TypedObjectModuleObject
:
:
StructTypePrototype
)
;
if
(
!
structType
)
{
return
false
;
}
RootedValue
structTypeValue
(
cx
ObjectValue
(
*
structType
)
)
;
if
(
!
DefineDataProperty
(
cx
module
cx
-
>
names
(
)
.
StructType
structTypeValue
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
false
;
}
return
true
;
}
const
ClassSpec
TypedObjectModuleObject
:
:
classSpec_
=
{
CreateTypedObjectModuleObject
nullptr
TypedObjectMethods
nullptr
nullptr
nullptr
TypedObjectModuleObjectClassFinish
}
;
uint32_t
TypedObject
:
:
offset
(
)
const
{
if
(
is
<
InlineTypedObject
>
(
)
)
{
return
0
;
}
return
PointerRangeSize
(
typedMemBase
(
)
typedMem
(
)
)
;
}
uint32_t
TypedObject
:
:
length
(
)
const
{
return
typeDescr
(
)
.
as
<
ArrayTypeDescr
>
(
)
.
length
(
)
;
}
uint8_t
*
TypedObject
:
:
typedMem
(
)
const
{
if
(
is
<
InlineTypedObject
>
(
)
)
{
return
as
<
InlineTypedObject
>
(
)
.
inlineTypedMem
(
)
;
}
return
as
<
OutlineTypedObject
>
(
)
.
outOfLineTypedMem
(
)
;
}
uint8_t
*
TypedObject
:
:
typedMemBase
(
)
const
{
MOZ_ASSERT
(
is
<
OutlineTypedObject
>
(
)
)
;
JSObject
&
owner
=
as
<
OutlineTypedObject
>
(
)
.
owner
(
)
;
if
(
owner
.
is
<
ArrayBufferObject
>
(
)
)
{
return
owner
.
as
<
ArrayBufferObject
>
(
)
.
dataPointer
(
)
;
}
return
owner
.
as
<
InlineTypedObject
>
(
)
.
inlineTypedMem
(
)
;
}
OutlineTypedObject
*
OutlineTypedObject
:
:
createUnattached
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
{
const
JSClass
*
clasp
=
descr
-
>
opaque
(
)
?
&
OutlineOpaqueTypedObject
:
:
class_
:
&
OutlineTransparentTypedObject
:
:
class_
;
return
createUnattachedWithClass
(
cx
clasp
descr
heap
)
;
}
void
OutlineTypedObject
:
:
setOwnerAndData
(
JSObject
*
owner
uint8_t
*
data
)
{
owner_
=
owner
;
data_
=
data
;
if
(
owner
)
{
if
(
!
IsInsideNursery
(
this
)
&
&
IsInsideNursery
(
owner
)
)
{
owner
-
>
storeBuffer
(
)
-
>
putWholeCell
(
this
)
;
}
else
if
(
IsInsideNursery
(
this
)
&
&
!
IsInsideNursery
(
owner
)
)
{
storeBuffer
(
)
-
>
putWholeCell
(
owner
)
;
}
}
}
OutlineTypedObject
*
OutlineTypedObject
:
:
createUnattachedWithClass
(
JSContext
*
cx
const
JSClass
*
clasp
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
{
MOZ_ASSERT
(
clasp
=
=
&
OutlineTransparentTypedObject
:
:
class_
|
|
clasp
=
=
&
OutlineOpaqueTypedObject
:
:
class_
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
RootedObjectGroup
group
(
cx
ObjectGroup
:
:
defaultNewGroup
(
cx
clasp
TaggedProto
(
&
descr
-
>
typedProto
(
)
)
descr
)
)
;
if
(
!
group
)
{
return
nullptr
;
}
NewObjectKind
newKind
=
(
heap
=
=
gc
:
:
TenuredHeap
)
?
TenuredObject
:
GenericObject
;
OutlineTypedObject
*
obj
=
NewObjectWithGroup
<
OutlineTypedObject
>
(
cx
group
gc
:
:
AllocKind
:
:
OBJECT0
newKind
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
setOwnerAndData
(
nullptr
nullptr
)
;
return
obj
;
}
void
OutlineTypedObject
:
:
attach
(
ArrayBufferObject
&
buffer
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
=
buffer
.
byteLength
(
)
)
;
MOZ_ASSERT
(
size
(
)
<
=
buffer
.
byteLength
(
)
-
offset
)
;
MOZ_ASSERT
(
buffer
.
hasTypedObjectViews
(
)
)
;
MOZ_ASSERT
(
!
buffer
.
isDetached
(
)
)
;
setOwnerAndData
(
&
buffer
buffer
.
dataPointer
(
)
+
offset
)
;
}
void
OutlineTypedObject
:
:
attach
(
JSContext
*
cx
TypedObject
&
typedObj
uint32_t
offset
)
{
JSObject
*
owner
=
&
typedObj
;
if
(
typedObj
.
is
<
OutlineTypedObject
>
(
)
)
{
owner
=
&
typedObj
.
as
<
OutlineTypedObject
>
(
)
.
owner
(
)
;
MOZ_ASSERT
(
typedObj
.
offset
(
)
<
=
UINT32_MAX
-
offset
)
;
offset
+
=
typedObj
.
offset
(
)
;
}
if
(
owner
-
>
is
<
ArrayBufferObject
>
(
)
)
{
attach
(
owner
-
>
as
<
ArrayBufferObject
>
(
)
offset
)
;
}
else
{
MOZ_ASSERT
(
owner
-
>
is
<
InlineTypedObject
>
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
setOwnerAndData
(
owner
owner
-
>
as
<
InlineTypedObject
>
(
)
.
inlineTypedMem
(
nogc
)
+
offset
)
;
}
}
OutlineTypedObject
*
OutlineTypedObject
:
:
createZeroed
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
{
Rooted
<
OutlineTypedObject
*
>
obj
(
cx
OutlineTypedObject
:
:
createUnattached
(
cx
descr
heap
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
size_t
totalSize
=
descr
-
>
size
(
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
buffer
=
ArrayBufferObject
:
:
createForTypedObject
(
cx
totalSize
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
descr
-
>
initInstance
(
cx
-
>
runtime
(
)
buffer
-
>
dataPointer
(
)
)
;
obj
-
>
attach
(
*
buffer
0
)
;
return
obj
;
}
OutlineTypedObject
*
OutlineTypedObject
:
:
createDerived
(
JSContext
*
cx
HandleTypeDescr
type
HandleTypedObject
typedObj
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
=
typedObj
-
>
size
(
)
)
;
MOZ_ASSERT
(
offset
+
type
-
>
size
(
)
<
=
typedObj
-
>
size
(
)
)
;
const
JSClass
*
clasp
=
typedObj
-
>
opaque
(
)
?
&
OutlineOpaqueTypedObject
:
:
class_
:
&
OutlineTransparentTypedObject
:
:
class_
;
Rooted
<
OutlineTypedObject
*
>
obj
(
cx
)
;
obj
=
createUnattachedWithClass
(
cx
clasp
type
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
attach
(
cx
*
typedObj
offset
)
;
return
obj
;
}
OutlineTypedObject
*
OutlineTypedObject
:
:
createOpaque
(
JSContext
*
cx
HandleTypeDescr
descr
HandleTypedObject
target
uint32_t
offset
)
{
Rooted
<
OutlineTypedObject
*
>
obj
(
cx
)
;
obj
=
createUnattachedWithClass
(
cx
&
OutlineOpaqueTypedObject
:
:
class_
descr
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
attach
(
cx
*
target
offset
)
;
return
obj
;
}
TypedObject
*
TypedObject
:
:
createZeroed
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
{
if
(
InlineTypedObject
:
:
canAccommodateType
(
descr
)
)
{
AutoSetNewObjectMetadata
metadata
(
cx
)
;
InlineTypedObject
*
obj
=
InlineTypedObject
:
:
create
(
cx
descr
heap
)
;
if
(
!
obj
)
{
return
nullptr
;
}
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
descr
-
>
initInstance
(
cx
-
>
runtime
(
)
obj
-
>
inlineTypedMem
(
nogc
)
)
;
return
obj
;
}
return
OutlineTypedObject
:
:
createZeroed
(
cx
descr
heap
)
;
}
void
OutlineTypedObject
:
:
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
{
OutlineTypedObject
&
typedObj
=
object
-
>
as
<
OutlineTypedObject
>
(
)
;
TraceEdge
(
trc
typedObj
.
shapePtr
(
)
"
OutlineTypedObject_shape
"
)
;
if
(
!
typedObj
.
owner_
)
{
MOZ_ASSERT
(
!
typedObj
.
data_
)
;
return
;
}
MOZ_ASSERT
(
typedObj
.
data_
)
;
TypeDescr
&
descr
=
typedObj
.
typeDescr
(
)
;
JSObject
*
oldOwner
=
typedObj
.
owner_
;
TraceManuallyBarrieredEdge
(
trc
&
typedObj
.
owner_
"
typed
object
owner
"
)
;
JSObject
*
owner
=
typedObj
.
owner_
;
uint8_t
*
oldData
=
typedObj
.
outOfLineTypedMem
(
)
;
uint8_t
*
newData
=
oldData
;
if
(
owner
!
=
oldOwner
&
&
(
IsInlineTypedObjectClass
(
gc
:
:
MaybeForwardedObjectClass
(
owner
)
)
|
|
gc
:
:
MaybeForwardedObjectAs
<
ArrayBufferObject
>
(
owner
)
.
hasInlineData
(
)
)
)
{
newData
+
=
reinterpret_cast
<
uint8_t
*
>
(
owner
)
-
reinterpret_cast
<
uint8_t
*
>
(
oldOwner
)
;
typedObj
.
setData
(
newData
)
;
if
(
trc
-
>
isTenuringTracer
(
)
)
{
Nursery
&
nursery
=
trc
-
>
runtime
(
)
-
>
gc
.
nursery
(
)
;
nursery
.
maybeSetForwardingPointer
(
trc
oldData
newData
false
)
;
}
}
if
(
!
descr
.
opaque
(
)
)
{
return
;
}
descr
.
traceInstance
(
trc
newData
)
;
}
bool
TypeDescr
:
:
hasProperty
(
const
JSAtomState
&
names
jsid
id
)
{
switch
(
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
return
false
;
case
type
:
:
Array
:
{
uint32_t
index
;
return
IdIsIndex
(
id
&
index
)
|
|
JSID_IS_ATOM
(
id
names
.
length
)
;
}
case
type
:
:
Struct
:
{
size_t
index
;
return
as
<
StructTypeDescr
>
(
)
.
fieldIndex
(
id
&
index
)
;
}
}
MOZ_CRASH
(
"
Unexpected
kind
"
)
;
}
bool
TypedObject
:
:
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
MutableHandle
<
PropertyResult
>
propp
)
{
if
(
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
hasProperty
(
cx
-
>
names
(
)
id
)
)
{
propp
.
setNonNativeProperty
(
)
;
objp
.
set
(
obj
)
;
return
true
;
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
objp
.
set
(
nullptr
)
;
propp
.
setNotFound
(
)
;
return
true
;
}
return
LookupProperty
(
cx
proto
id
objp
propp
)
;
}
bool
TypedObject
:
:
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
{
RootedAtom
typeReprAtom
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
stringRepr
(
)
)
;
UniqueChars
typeReprStr
=
StringToNewUTF8CharsZ
(
cx
*
typeReprAtom
)
;
if
(
!
typeReprStr
)
{
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_NOT_EXTENSIBLE
typeReprStr
.
get
(
)
)
;
return
false
;
}
bool
TypedObject
:
:
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
{
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
switch
(
typedObj
-
>
typeDescr
(
)
.
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
break
;
case
type
:
:
Array
:
{
if
(
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
{
*
foundp
=
true
;
return
true
;
}
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
*
foundp
=
(
index
<
uint32_t
(
typedObj
-
>
length
(
)
)
)
;
return
true
;
}
break
;
}
case
type
:
:
Struct
:
size_t
index
;
if
(
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
.
fieldIndex
(
id
&
index
)
)
{
*
foundp
=
true
;
return
true
;
}
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
*
foundp
=
false
;
return
true
;
}
return
HasProperty
(
cx
proto
id
foundp
)
;
}
bool
TypedObject
:
:
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
{
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
return
obj_getElement
(
cx
obj
receiver
index
vp
)
;
}
switch
(
typedObj
-
>
typeDescr
(
)
.
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
break
;
case
type
:
:
Array
:
if
(
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
{
vp
.
setInt32
(
typedObj
-
>
length
(
)
)
;
return
true
;
}
break
;
case
type
:
:
Struct
:
{
Rooted
<
StructTypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
)
;
size_t
fieldIndex
;
if
(
!
descr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
{
break
;
}
size_t
offset
=
descr
-
>
fieldOffset
(
fieldIndex
)
;
Rooted
<
TypeDescr
*
>
fieldType
(
cx
&
descr
-
>
fieldDescr
(
fieldIndex
)
)
;
return
Reify
(
cx
fieldType
typedObj
offset
vp
)
;
}
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
return
GetProperty
(
cx
proto
receiver
id
vp
)
;
}
bool
TypedObject
:
:
obj_getElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
uint32_t
index
MutableHandleValue
vp
)
{
MOZ_ASSERT
(
obj
-
>
is
<
TypedObject
>
(
)
)
;
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
)
;
switch
(
descr
-
>
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
case
type
:
:
Struct
:
break
;
case
type
:
:
Array
:
return
obj_getArrayElement
(
cx
typedObj
descr
index
vp
)
;
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
return
GetElement
(
cx
proto
receiver
index
vp
)
;
}
bool
TypedObject
:
:
obj_getArrayElement
(
JSContext
*
cx
Handle
<
TypedObject
*
>
typedObj
Handle
<
TypeDescr
*
>
typeDescr
uint32_t
index
MutableHandleValue
vp
)
{
if
(
index
>
=
(
size_t
)
typedObj
-
>
length
(
)
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
TypeDescr
*
>
elementType
(
cx
&
typeDescr
-
>
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
)
;
size_t
offset
=
elementType
-
>
size
(
)
*
index
;
return
Reify
(
cx
elementType
typedObj
offset
vp
)
;
}
bool
TypedObject
:
:
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
switch
(
typedObj
-
>
typeDescr
(
)
.
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
break
;
case
type
:
:
Array
:
{
if
(
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
{
if
(
receiver
.
isObject
(
)
&
&
obj
=
=
&
receiver
.
toObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_REDEFINE_ARRAY_LENGTH
)
;
return
false
;
}
return
result
.
failReadOnly
(
)
;
}
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
if
(
!
receiver
.
isObject
(
)
|
|
obj
!
=
&
receiver
.
toObject
(
)
)
{
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
if
(
index
>
=
uint32_t
(
typedObj
-
>
length
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_BINARYARRAY_BAD_INDEX
)
;
return
false
;
}
Rooted
<
TypeDescr
*
>
elementType
(
cx
)
;
elementType
=
&
typedObj
-
>
typeDescr
(
)
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
;
size_t
offset
=
elementType
-
>
size
(
)
*
index
;
if
(
!
ConvertAndCopyTo
(
cx
elementType
typedObj
offset
nullptr
v
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
break
;
}
case
type
:
:
Struct
:
{
Rooted
<
StructTypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
)
;
size_t
fieldIndex
;
if
(
!
descr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
{
break
;
}
if
(
!
descr
-
>
fieldIsMutable
(
fieldIndex
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_SETTING_IMMUTABLE
)
;
return
false
;
}
if
(
!
receiver
.
isObject
(
)
|
|
obj
!
=
&
receiver
.
toObject
(
)
)
{
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
size_t
offset
=
descr
-
>
fieldOffset
(
fieldIndex
)
;
Rooted
<
TypeDescr
*
>
fieldType
(
cx
&
descr
-
>
fieldDescr
(
fieldIndex
)
)
;
RootedAtom
fieldName
(
cx
&
descr
-
>
fieldName
(
fieldIndex
)
)
;
if
(
!
ConvertAndCopyTo
(
cx
fieldType
typedObj
offset
fieldName
v
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
}
return
SetPropertyOnProto
(
cx
obj
id
v
receiver
result
)
;
}
bool
TypedObject
:
:
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
{
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
)
;
switch
(
descr
-
>
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
break
;
case
type
:
:
Array
:
{
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
if
(
!
obj_getArrayElement
(
cx
typedObj
descr
index
desc
.
value
(
)
)
)
{
return
false
;
}
desc
.
setAttributes
(
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
)
;
desc
.
object
(
)
.
set
(
obj
)
;
return
true
;
}
if
(
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
{
desc
.
value
(
)
.
setInt32
(
typedObj
-
>
length
(
)
)
;
desc
.
setAttributes
(
JSPROP_READONLY
|
JSPROP_PERMANENT
)
;
desc
.
object
(
)
.
set
(
obj
)
;
return
true
;
}
break
;
}
case
type
:
:
Struct
:
{
Rooted
<
StructTypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
)
;
size_t
fieldIndex
;
if
(
!
descr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
{
break
;
}
size_t
offset
=
descr
-
>
fieldOffset
(
fieldIndex
)
;
Rooted
<
TypeDescr
*
>
fieldType
(
cx
&
descr
-
>
fieldDescr
(
fieldIndex
)
)
;
if
(
!
Reify
(
cx
fieldType
typedObj
offset
desc
.
value
(
)
)
)
{
return
false
;
}
desc
.
setAttributes
(
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
)
;
desc
.
object
(
)
.
set
(
obj
)
;
return
true
;
}
}
desc
.
object
(
)
.
set
(
nullptr
)
;
return
true
;
}
static
bool
IsOwnId
(
JSContext
*
cx
HandleObject
obj
HandleId
id
)
{
uint32_t
index
;
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
switch
(
typedObj
-
>
typeDescr
(
)
.
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
return
false
;
case
type
:
:
Array
:
return
IdIsIndex
(
id
&
index
)
|
|
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
;
case
type
:
:
Struct
:
size_t
index
;
if
(
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
.
fieldIndex
(
id
&
index
)
)
{
return
true
;
}
}
return
false
;
}
bool
TypedObject
:
:
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
{
if
(
IsOwnId
(
cx
obj
id
)
)
{
return
Throw
(
cx
id
JSMSG_CANT_DELETE
)
;
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
return
result
.
succeed
(
)
;
}
return
DeleteProperty
(
cx
proto
id
result
)
;
}
bool
TypedObject
:
:
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
{
MOZ_ASSERT
(
obj
-
>
is
<
TypedObject
>
(
)
)
;
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
obj
-
>
as
<
TypedObject
>
(
)
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
typedObj
-
>
typeDescr
(
)
)
;
RootedId
id
(
cx
)
;
switch
(
descr
-
>
kind
(
)
)
{
case
type
:
:
Scalar
:
case
type
:
:
Reference
:
{
break
;
}
case
type
:
:
Array
:
{
if
(
!
properties
.
reserve
(
typedObj
-
>
length
(
)
)
)
{
return
false
;
}
for
(
uint32_t
index
=
0
;
index
<
typedObj
-
>
length
(
)
;
index
+
+
)
{
id
=
INT_TO_JSID
(
index
)
;
properties
.
infallibleAppend
(
id
)
;
}
break
;
}
case
type
:
:
Struct
:
{
size_t
fieldCount
=
descr
-
>
as
<
StructTypeDescr
>
(
)
.
fieldCount
(
)
;
if
(
!
properties
.
reserve
(
fieldCount
)
)
{
return
false
;
}
for
(
size_t
index
=
0
;
index
<
fieldCount
;
index
+
+
)
{
id
=
AtomToId
(
&
descr
-
>
as
<
StructTypeDescr
>
(
)
.
fieldName
(
index
)
)
;
properties
.
infallibleAppend
(
id
)
;
}
break
;
}
}
return
true
;
}
InlineTypedObject
*
InlineTypedObject
:
:
create
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
{
gc
:
:
AllocKind
allocKind
=
allocKindForTypeDescriptor
(
descr
)
;
const
JSClass
*
clasp
=
descr
-
>
opaque
(
)
?
&
InlineOpaqueTypedObject
:
:
class_
:
&
InlineTransparentTypedObject
:
:
class_
;
RootedObjectGroup
group
(
cx
ObjectGroup
:
:
defaultNewGroup
(
cx
clasp
TaggedProto
(
&
descr
-
>
typedProto
(
)
)
descr
)
)
;
if
(
!
group
)
{
return
nullptr
;
}
NewObjectKind
newKind
=
(
heap
=
=
gc
:
:
TenuredHeap
)
?
TenuredObject
:
GenericObject
;
return
NewObjectWithGroup
<
InlineTypedObject
>
(
cx
group
allocKind
newKind
)
;
}
InlineTypedObject
*
InlineTypedObject
:
:
createCopy
(
JSContext
*
cx
Handle
<
InlineTypedObject
*
>
templateObject
gc
:
:
InitialHeap
heap
)
{
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
templateObject
-
>
typeDescr
(
)
)
;
InlineTypedObject
*
res
=
create
(
cx
descr
heap
)
;
if
(
!
res
)
{
return
nullptr
;
}
memcpy
(
res
-
>
inlineTypedMem
(
)
templateObject
-
>
inlineTypedMem
(
)
templateObject
-
>
size
(
)
)
;
return
res
;
}
void
InlineTypedObject
:
:
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
{
InlineTypedObject
&
typedObj
=
object
-
>
as
<
InlineTypedObject
>
(
)
;
TraceEdge
(
trc
typedObj
.
shapePtr
(
)
"
InlineTypedObject_shape
"
)
;
if
(
typedObj
.
is
<
InlineTransparentTypedObject
>
(
)
)
{
return
;
}
typedObj
.
typeDescr
(
)
.
traceInstance
(
trc
typedObj
.
inlineTypedMem
(
)
)
;
}
size_t
InlineTypedObject
:
:
obj_moved
(
JSObject
*
dst
JSObject
*
src
)
{
if
(
!
IsInsideNursery
(
src
)
)
{
return
0
;
}
TypeDescr
&
descr
=
dst
-
>
as
<
InlineTypedObject
>
(
)
.
typeDescr
(
)
;
if
(
descr
.
kind
(
)
=
=
type
:
:
Array
)
{
uint8_t
*
oldData
=
reinterpret_cast
<
uint8_t
*
>
(
src
)
+
offsetOfDataStart
(
)
;
uint8_t
*
newData
=
dst
-
>
as
<
InlineTypedObject
>
(
)
.
inlineTypedMem
(
)
;
auto
&
nursery
=
dst
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
bool
direct
=
descr
.
size
(
)
>
=
sizeof
(
uintptr_t
)
;
nursery
.
setForwardingPointerWhileTenuring
(
oldData
newData
direct
)
;
}
return
0
;
}
const
ObjectOps
TypedObject
:
:
objectOps_
=
{
TypedObject
:
:
obj_lookupProperty
TypedObject
:
:
obj_defineProperty
TypedObject
:
:
obj_hasProperty
TypedObject
:
:
obj_getProperty
TypedObject
:
:
obj_setProperty
TypedObject
:
:
obj_getOwnPropertyDescriptor
TypedObject
:
:
obj_deleteProperty
nullptr
nullptr
}
;
#
define
DEFINE_TYPEDOBJ_CLASS
(
Name
Trace
Moved
)
\
static
const
JSClassOps
Name
#
#
ClassOps
=
{
\
nullptr
/
*
addProperty
*
/
\
nullptr
/
*
delProperty
*
/
\
nullptr
/
*
enumerate
*
/
\
TypedObject
:
:
obj_newEnumerate
\
nullptr
/
*
resolve
*
/
\
nullptr
/
*
mayResolve
*
/
\
nullptr
/
*
finalize
*
/
\
nullptr
/
*
call
*
/
\
nullptr
/
*
hasInstance
*
/
\
nullptr
/
*
construct
*
/
\
Trace
\
}
;
\
static
const
ClassExtension
Name
#
#
ClassExt
=
{
\
Moved
/
*
objectMovedOp
*
/
\
}
;
\
const
JSClass
Name
:
:
class_
=
{
\
#
Name
JSClass
:
:
NON_NATIVE
|
JSCLASS_DELAY_METADATA_BUILDER
\
&
Name
#
#
ClassOps
JS_NULL_CLASS_SPEC
\
&
Name
#
#
ClassExt
&
TypedObject
:
:
objectOps_
}
DEFINE_TYPEDOBJ_CLASS
(
OutlineTransparentTypedObject
OutlineTypedObject
:
:
obj_trace
nullptr
)
;
DEFINE_TYPEDOBJ_CLASS
(
OutlineOpaqueTypedObject
OutlineTypedObject
:
:
obj_trace
nullptr
)
;
DEFINE_TYPEDOBJ_CLASS
(
InlineTransparentTypedObject
InlineTypedObject
:
:
obj_trace
InlineTypedObject
:
:
obj_moved
)
;
DEFINE_TYPEDOBJ_CLASS
(
InlineOpaqueTypedObject
InlineTypedObject
:
:
obj_trace
InlineTypedObject
:
:
obj_moved
)
;
bool
TypedObject
:
:
construct
(
JSContext
*
cx
unsigned
int
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
callee
(
)
.
is
<
TypeDescr
>
(
)
)
;
Rooted
<
TypeDescr
*
>
callee
(
cx
&
args
.
callee
(
)
.
as
<
TypeDescr
>
(
)
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
callee
-
>
realm
(
)
)
;
if
(
callee
-
>
is
<
ComplexTypeDescr
>
(
)
&
&
!
callee
-
>
as
<
ComplexTypeDescr
>
(
)
.
allowConstruct
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_NOT_CONSTRUCTIBLE
)
;
return
false
;
}
if
(
args
.
length
(
)
=
=
0
)
{
Rooted
<
TypedObject
*
>
obj
(
cx
createZeroed
(
cx
callee
)
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
if
(
args
[
0
]
.
isObject
(
)
)
{
Rooted
<
TypedObject
*
>
obj
(
cx
createZeroed
(
cx
callee
)
)
;
if
(
!
obj
)
{
return
false
;
}
if
(
!
ConvertAndCopyTo
(
cx
obj
args
[
0
]
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPEDOBJECT_BAD_ARGS
)
;
return
false
;
}
JS
:
:
Result
<
TypedObject
*
JS
:
:
OOM
&
>
TypedObject
:
:
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
js
:
:
HandleObjectGroup
group
)
{
debugCheckNewObject
(
group
shape
kind
heap
)
;
const
JSClass
*
clasp
=
group
-
>
clasp
(
)
;
MOZ_ASSERT
(
:
:
IsTypedObjectClass
(
clasp
)
)
;
JSObject
*
obj
=
js
:
:
AllocateObject
(
cx
kind
0
heap
clasp
)
;
if
(
!
obj
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
TypedObject
*
tobj
=
static_cast
<
TypedObject
*
>
(
obj
)
;
tobj
-
>
initGroup
(
group
)
;
tobj
-
>
initShape
(
shape
)
;
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
cx
tobj
)
;
js
:
:
gc
:
:
gcprobes
:
:
CreateObject
(
tobj
)
;
return
tobj
;
}
bool
js
:
:
NewOpaqueTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypeDescr
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
args
[
2
]
.
isInt32
(
)
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
)
;
Rooted
<
TypedObject
*
>
target
(
cx
&
args
[
1
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
)
;
uint32_t
offset
=
AssertedCast
<
uint32_t
>
(
args
[
2
]
.
toInt32
(
)
)
;
auto
*
obj
=
OutlineTypedObject
:
:
createOpaque
(
cx
descr
target
offset
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
js
:
:
NewDerivedTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypeDescr
>
(
)
)
;
MOZ_ASSERT
(
args
[
1
]
.
isObject
(
)
&
&
args
[
1
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
MOZ_RELEASE_ASSERT
(
args
[
2
]
.
isInt32
(
)
)
;
Rooted
<
TypeDescr
*
>
descr
(
cx
&
args
[
0
]
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
)
;
Rooted
<
TypedObject
*
>
typedObj
(
cx
&
args
[
1
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
)
;
uint32_t
offset
=
AssertedCast
<
uint32_t
>
(
args
[
2
]
.
toInt32
(
)
)
;
Rooted
<
TypedObject
*
>
obj
(
cx
)
;
obj
=
OutlineTypedObject
:
:
createDerived
(
cx
descr
typedObj
offset
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
js
:
:
ObjectIsTypeDescr
(
JSContext
*
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
args
[
0
]
.
toObject
(
)
.
is
<
TypeDescr
>
(
)
)
;
return
true
;
}
bool
js
:
:
ObjectIsTypedObject
(
JSContext
*
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
return
true
;
}
bool
js
:
:
TypeDescrIsSimpleType
(
JSContext
*
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
[
0
]
.
toObject
(
)
.
is
<
js
:
:
TypeDescr
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
args
[
0
]
.
toObject
(
)
.
is
<
js
:
:
SimpleTypeDescr
>
(
)
)
;
return
true
;
}
bool
js
:
:
TypeDescrIsArrayType
(
JSContext
*
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
[
0
]
.
toObject
(
)
.
is
<
js
:
:
TypeDescr
>
(
)
)
;
JSObject
&
obj
=
args
[
0
]
.
toObject
(
)
;
args
.
rval
(
)
.
setBoolean
(
obj
.
is
<
js
:
:
ArrayTypeDescr
>
(
)
)
;
return
true
;
}
bool
js
:
:
TypedObjectTypeDescr
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
args
.
rval
(
)
.
setObject
(
typedObj
.
typeDescr
(
)
)
;
return
true
;
}
bool
js
:
:
ClampToUint8
(
JSContext
*
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isNumber
(
)
)
;
args
.
rval
(
)
.
setNumber
(
ClampDoubleToUint8
(
args
[
0
]
.
toNumber
(
)
)
)
;
return
true
;
}
bool
js
:
:
GetTypedObjectModule
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
cx
-
>
global
(
)
)
;
MOZ_ASSERT
(
global
)
;
args
.
rval
(
)
.
setObject
(
global
-
>
getTypedObjectModule
(
)
)
;
return
true
;
}
#
define
JS_STORE_NUMBER_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
StoreScalar
#
#
T
:
:
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
MOZ_ASSERT
(
args
[
2
]
.
isNumber
(
)
)
;
\
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
T
*
target
=
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
double
d
=
args
[
2
]
.
toNumber
(
)
;
\
*
target
=
ConvertScalar
<
T
>
(
d
)
;
\
args
.
rval
(
)
.
setUndefined
(
)
;
\
return
true
;
\
}
#
define
JS_STORE_BIGINT_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
StoreScalar
#
#
T
:
:
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
BigInt
*
bi
=
ToBigInt
(
cx
args
[
2
]
)
;
\
if
(
!
bi
)
{
\
return
false
;
\
}
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
T
*
target
=
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
*
target
=
ConvertBigInt
<
T
>
(
bi
)
;
\
args
.
rval
(
)
.
setUndefined
(
)
;
\
return
true
;
\
}
#
define
JS_STORE_REFERENCE_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
StoreReference
#
#
_name
:
:
Func
(
JSContext
*
cx
unsigned
argc
\
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
4
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
MOZ_ASSERT
(
args
[
2
]
.
isString
(
)
|
|
args
[
2
]
.
isNull
(
)
)
;
\
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
\
jsid
id
=
args
[
2
]
.
isString
(
)
\
?
IdToTypeId
(
AtomToId
(
&
args
[
2
]
.
toString
(
)
-
>
asAtom
(
)
)
)
\
:
JSID_VOID
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
T
*
target
=
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
if
(
!
store
(
cx
target
args
[
3
]
&
typedObj
id
)
)
return
false
;
\
args
.
rval
(
)
.
setUndefined
(
)
;
\
return
true
;
\
}
#
define
JS_LOAD_NUMBER_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
LoadScalar
#
#
T
:
:
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
T
*
target
=
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
args
.
rval
(
)
.
setNumber
(
JS
:
:
CanonicalizeNaN
(
(
double
)
*
target
)
)
;
\
return
true
;
\
}
#
define
JS_LOAD_BIGINT_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
LoadScalar
#
#
T
:
:
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
T
value
;
\
{
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
value
=
*
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
}
\
BigInt
*
bi
=
CreateBigInt
<
T
>
(
cx
value
)
;
\
if
(
!
bi
)
{
\
return
false
;
\
}
\
args
.
rval
(
)
.
setBigInt
(
bi
)
;
\
return
true
;
\
}
#
define
JS_LOAD_REFERENCE_CLASS_IMPL
(
_constant
T
_name
)
\
bool
js
:
:
LoadReference
#
#
_name
:
:
Func
(
JSContext
*
cx
unsigned
argc
\
Value
*
vp
)
{
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
\
MOZ_ASSERT
(
args
[
0
]
.
isObject
(
)
&
&
args
[
0
]
.
toObject
(
)
.
is
<
TypedObject
>
(
)
)
;
\
MOZ_RELEASE_ASSERT
(
args
[
1
]
.
isInt32
(
)
)
;
\
\
TypedObject
&
typedObj
=
args
[
0
]
.
toObject
(
)
.
as
<
TypedObject
>
(
)
;
\
int32_t
offset
=
args
[
1
]
.
toInt32
(
)
;
\
\
/
*
Should
be
guaranteed
by
the
typed
objects
API
:
*
/
\
MOZ_ASSERT
(
offset
%
MOZ_ALIGNOF
(
T
)
=
=
0
)
;
\
\
JS
:
:
AutoCheckCannotGC
nogc
(
cx
)
;
\
T
*
target
=
reinterpret_cast
<
T
*
>
(
typedObj
.
typedMem
(
offset
nogc
)
)
;
\
load
(
target
args
.
rval
(
)
)
;
\
return
true
;
\
}
bool
StoreReferenceAny
:
:
store
(
JSContext
*
cx
GCPtrValue
*
heap
const
Value
&
v
TypedObject
*
obj
jsid
id
)
{
if
(
!
v
.
isUndefined
(
)
)
{
if
(
!
cx
-
>
isHelperThreadContext
(
)
)
{
AddTypePropertyId
(
cx
obj
id
v
)
;
}
else
if
(
!
HasTypePropertyId
(
obj
id
v
)
)
{
return
false
;
}
}
*
heap
=
v
;
return
true
;
}
bool
StoreReferenceObject
:
:
store
(
JSContext
*
cx
GCPtrObject
*
heap
const
Value
&
v
TypedObject
*
obj
jsid
id
)
{
MOZ_ASSERT
(
v
.
isObjectOrNull
(
)
)
;
if
(
v
.
isObject
(
)
)
{
if
(
!
cx
-
>
isHelperThreadContext
(
)
)
{
AddTypePropertyId
(
cx
obj
id
v
)
;
}
else
if
(
!
HasTypePropertyId
(
obj
id
v
)
)
{
return
false
;
}
}
*
heap
=
v
.
toObjectOrNull
(
)
;
return
true
;
}
bool
StoreReferenceWasmAnyRef
:
:
store
(
JSContext
*
cx
GCPtrObject
*
heap
const
Value
&
v
TypedObject
*
obj
jsid
id
)
{
MOZ_ASSERT
(
v
.
isObjectOrNull
(
)
)
;
*
heap
=
v
.
toObjectOrNull
(
)
;
return
true
;
}
bool
StoreReferencestring
:
:
store
(
JSContext
*
cx
GCPtrString
*
heap
const
Value
&
v
TypedObject
*
obj
jsid
id
)
{
MOZ_ASSERT
(
v
.
isString
(
)
)
;
*
heap
=
v
.
toString
(
)
;
return
true
;
}
void
LoadReferenceAny
:
:
load
(
GCPtrValue
*
heap
MutableHandleValue
v
)
{
v
.
set
(
*
heap
)
;
}
void
LoadReferenceObject
:
:
load
(
GCPtrObject
*
heap
MutableHandleValue
v
)
{
if
(
*
heap
)
{
v
.
setObject
(
*
*
heap
)
;
}
else
{
v
.
setNull
(
)
;
}
}
void
LoadReferenceWasmAnyRef
:
:
load
(
GCPtrObject
*
heap
MutableHandleValue
v
)
{
if
(
*
heap
)
{
v
.
setObject
(
*
*
heap
)
;
}
else
{
v
.
setNull
(
)
;
}
}
void
LoadReferencestring
:
:
load
(
GCPtrString
*
heap
MutableHandleValue
v
)
{
v
.
setString
(
*
heap
)
;
}
JS_FOR_EACH_UNIQUE_SCALAR_NUMBER_TYPE_REPR_CTYPE
(
JS_STORE_NUMBER_CLASS_IMPL
)
JS_FOR_EACH_UNIQUE_SCALAR_NUMBER_TYPE_REPR_CTYPE
(
JS_LOAD_NUMBER_CLASS_IMPL
)
JS_FOR_EACH_SCALAR_BIGINT_TYPE_REPR
(
JS_STORE_BIGINT_CLASS_IMPL
)
JS_FOR_EACH_SCALAR_BIGINT_TYPE_REPR
(
JS_LOAD_BIGINT_CLASS_IMPL
)
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
JS_STORE_REFERENCE_CLASS_IMPL
)
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
JS_LOAD_REFERENCE_CLASS_IMPL
)
template
<
typename
V
>
static
void
VisitReferences
(
TypeDescr
&
descr
uint8_t
*
base
V
&
visitor
size_t
offset
)
{
if
(
descr
.
transparent
(
)
)
{
return
;
}
switch
(
descr
.
kind
(
)
)
{
case
type
:
:
Scalar
:
return
;
case
type
:
:
Reference
:
visitor
.
visitReference
(
descr
.
as
<
ReferenceTypeDescr
>
(
)
base
offset
)
;
return
;
case
type
:
:
Array
:
{
ArrayTypeDescr
&
arrayDescr
=
descr
.
as
<
ArrayTypeDescr
>
(
)
;
TypeDescr
&
elementDescr
=
arrayDescr
.
elementType
(
)
;
for
(
uint32_t
i
=
0
;
i
<
arrayDescr
.
length
(
)
;
i
+
+
)
{
VisitReferences
(
elementDescr
base
visitor
offset
)
;
offset
+
=
elementDescr
.
size
(
)
;
}
return
;
}
case
type
:
:
Struct
:
{
StructTypeDescr
&
structDescr
=
descr
.
as
<
StructTypeDescr
>
(
)
;
for
(
size_t
i
=
0
;
i
<
structDescr
.
fieldCount
(
)
;
i
+
+
)
{
TypeDescr
&
descr
=
structDescr
.
fieldDescr
(
i
)
;
VisitReferences
(
descr
base
visitor
offset
+
structDescr
.
fieldOffset
(
i
)
)
;
}
return
;
}
}
MOZ_CRASH
(
"
Invalid
type
repr
kind
"
)
;
}
namespace
{
class
MemoryInitVisitor
{
const
JSRuntime
*
rt_
;
public
:
explicit
MemoryInitVisitor
(
const
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
void
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
;
}
;
}
void
MemoryInitVisitor
:
:
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
{
switch
(
descr
.
type
(
)
)
{
case
ReferenceType
:
:
TYPE_ANY
:
{
js
:
:
GCPtrValue
*
heapValue
=
reinterpret_cast
<
js
:
:
GCPtrValue
*
>
(
base
+
offset
)
;
heapValue
-
>
init
(
UndefinedValue
(
)
)
;
return
;
}
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
case
ReferenceType
:
:
TYPE_OBJECT
:
{
js
:
:
GCPtrObject
*
objectPtr
=
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
base
+
offset
)
;
objectPtr
-
>
init
(
nullptr
)
;
return
;
}
case
ReferenceType
:
:
TYPE_STRING
:
{
js
:
:
GCPtrString
*
stringPtr
=
reinterpret_cast
<
js
:
:
GCPtrString
*
>
(
base
+
offset
)
;
stringPtr
-
>
init
(
rt_
-
>
emptyString
)
;
return
;
}
}
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
void
TypeDescr
:
:
initInstance
(
const
JSRuntime
*
rt
uint8_t
*
mem
)
{
MemoryInitVisitor
visitor
(
rt
)
;
memset
(
mem
0
size
(
)
)
;
if
(
opaque
(
)
)
{
VisitReferences
(
*
this
mem
visitor
0
)
;
}
}
namespace
{
class
MemoryTracingVisitor
{
JSTracer
*
trace_
;
public
:
explicit
MemoryTracingVisitor
(
JSTracer
*
trace
)
:
trace_
(
trace
)
{
}
void
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
;
}
;
}
void
MemoryTracingVisitor
:
:
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
{
switch
(
descr
.
type
(
)
)
{
case
ReferenceType
:
:
TYPE_ANY
:
{
GCPtrValue
*
heapValue
=
reinterpret_cast
<
js
:
:
GCPtrValue
*
>
(
base
+
offset
)
;
TraceEdge
(
trace_
heapValue
"
reference
-
val
"
)
;
return
;
}
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
case
ReferenceType
:
:
TYPE_OBJECT
:
{
GCPtrObject
*
objectPtr
=
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
base
+
offset
)
;
TraceNullableEdge
(
trace_
objectPtr
"
reference
-
obj
"
)
;
return
;
}
case
ReferenceType
:
:
TYPE_STRING
:
{
GCPtrString
*
stringPtr
=
reinterpret_cast
<
js
:
:
GCPtrString
*
>
(
base
+
offset
)
;
TraceNullableEdge
(
trace_
stringPtr
"
reference
-
str
"
)
;
return
;
}
}
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
void
TypeDescr
:
:
traceInstance
(
JSTracer
*
trace
uint8_t
*
mem
)
{
MemoryTracingVisitor
visitor
(
trace
)
;
VisitReferences
(
*
this
mem
visitor
0
)
;
}
namespace
{
struct
TraceListVisitor
{
using
OffsetVector
=
Vector
<
uint32_t
0
SystemAllocPolicy
>
;
OffsetVector
stringOffsets
;
OffsetVector
objectOffsets
;
OffsetVector
valueOffsets
;
void
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
;
bool
fillList
(
Vector
<
uint32_t
>
&
entries
)
;
}
;
}
void
TraceListVisitor
:
:
visitReference
(
ReferenceTypeDescr
&
descr
uint8_t
*
base
size_t
offset
)
{
MOZ_ASSERT
(
!
base
)
;
OffsetVector
*
offsets
;
switch
(
descr
.
type
(
)
)
{
case
ReferenceType
:
:
TYPE_ANY
:
offsets
=
&
valueOffsets
;
break
;
case
ReferenceType
:
:
TYPE_OBJECT
:
offsets
=
&
objectOffsets
;
break
;
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
offsets
=
&
objectOffsets
;
break
;
case
ReferenceType
:
:
TYPE_STRING
:
offsets
=
&
stringOffsets
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
AutoEnterOOMUnsafeRegion
oomUnsafe
;
MOZ_ASSERT
(
offset
<
=
UINT32_MAX
)
;
if
(
!
offsets
-
>
append
(
offset
)
)
{
oomUnsafe
.
crash
(
"
TraceListVisitor
:
:
visitReference
"
)
;
}
}
bool
TraceListVisitor
:
:
fillList
(
Vector
<
uint32_t
>
&
entries
)
{
return
entries
.
append
(
stringOffsets
.
length
(
)
)
&
&
entries
.
append
(
objectOffsets
.
length
(
)
)
&
&
entries
.
append
(
valueOffsets
.
length
(
)
)
&
&
entries
.
appendAll
(
stringOffsets
)
&
&
entries
.
appendAll
(
objectOffsets
)
&
&
entries
.
appendAll
(
valueOffsets
)
;
}
static
bool
CreateTraceList
(
JSContext
*
cx
HandleTypeDescr
descr
)
{
if
(
!
InlineTypedObject
:
:
canAccommodateType
(
descr
)
|
|
descr
-
>
transparent
(
)
)
{
return
true
;
}
TraceListVisitor
visitor
;
VisitReferences
(
*
descr
nullptr
visitor
0
)
;
Vector
<
uint32_t
>
entries
(
cx
)
;
if
(
!
visitor
.
fillList
(
entries
)
)
{
return
false
;
}
MOZ_ASSERT
(
entries
.
length
(
)
>
=
3
)
;
if
(
entries
.
length
(
)
=
=
3
)
{
MOZ_ASSERT
(
entries
[
0
]
=
=
0
&
&
entries
[
1
]
=
=
0
&
&
entries
[
2
]
=
=
0
)
;
return
true
;
}
uint32_t
*
list
=
cx
-
>
pod_malloc
<
uint32_t
>
(
entries
.
length
(
)
)
;
if
(
!
list
)
{
return
false
;
}
PodCopy
(
list
entries
.
begin
(
)
entries
.
length
(
)
)
;
size_t
size
=
entries
.
length
(
)
*
sizeof
(
uint32_t
)
;
InitReservedSlot
(
descr
JS_DESCR_SLOT_TRACE_LIST
list
size
MemoryUse
:
:
TypeDescrTraceList
)
;
return
true
;
}
void
TypeDescr
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
TypeDescr
&
descr
=
obj
-
>
as
<
TypeDescr
>
(
)
;
if
(
descr
.
hasTraceList
(
)
)
{
auto
list
=
const_cast
<
uint32_t
*
>
(
descr
.
traceList
(
)
)
;
size_t
size
=
(
3
+
list
[
0
]
+
list
[
1
]
+
list
[
2
]
)
*
sizeof
(
uint32_t
)
;
fop
-
>
free_
(
obj
list
size
MemoryUse
:
:
TypeDescrTraceList
)
;
}
}
