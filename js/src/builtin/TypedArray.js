function
ViewedArrayBufferIfReified
(
tarray
)
{
assert
(
IsTypedArray
(
tarray
)
"
non
-
typed
array
asked
for
its
buffer
"
)
;
var
buf
=
UnsafeGetReservedSlot
(
tarray
JS_TYPEDARRAYLAYOUT_BUFFER_SLOT
)
;
assert
(
buf
=
=
=
null
|
|
(
IsObject
(
buf
)
&
&
(
GuardToArrayBuffer
(
buf
)
!
=
=
null
|
|
GuardToSharedArrayBuffer
(
buf
)
!
=
=
null
)
)
"
unexpected
value
in
buffer
slot
"
)
;
return
buf
;
}
function
IsDetachedBuffer
(
buffer
)
{
if
(
buffer
=
=
=
null
)
return
false
;
assert
(
GuardToArrayBuffer
(
buffer
)
!
=
=
null
|
|
GuardToSharedArrayBuffer
(
buffer
)
!
=
=
null
"
non
-
ArrayBuffer
passed
to
IsDetachedBuffer
"
)
;
if
(
(
buffer
=
GuardToArrayBuffer
(
buffer
)
)
=
=
=
null
)
return
false
;
var
flags
=
UnsafeGetInt32FromReservedSlot
(
buffer
JS_ARRAYBUFFER_FLAGS_SLOT
)
;
return
(
flags
&
JS_ARRAYBUFFER_DETACHED_FLAG
)
!
=
=
0
;
}
function
TypedArrayLengthMethod
(
)
{
return
TypedArrayLength
(
this
)
;
}
function
TypedArrayByteOffsetMethod
(
)
{
return
TypedArrayByteOffset
(
this
)
;
}
function
GetAttachedArrayBuffer
(
tarray
)
{
var
buffer
=
ViewedArrayBufferIfReified
(
tarray
)
;
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
buffer
;
}
function
GetAttachedArrayBufferMethod
(
)
{
return
GetAttachedArrayBuffer
(
this
)
;
}
function
IsTypedArrayEnsuringArrayBuffer
(
arg
)
{
if
(
IsObject
(
arg
)
&
&
IsTypedArray
(
arg
)
)
{
GetAttachedArrayBuffer
(
arg
)
;
return
true
;
}
callFunction
(
CallTypedArrayMethodIfWrapped
arg
"
GetAttachedArrayBufferMethod
"
)
;
return
false
;
}
function
TypedArraySpeciesConstructor
(
obj
)
{
assert
(
IsObject
(
obj
)
"
not
passed
an
object
"
)
;
var
ctor
=
obj
.
constructor
;
if
(
ctor
=
=
=
undefined
)
return
_ConstructorForTypedArray
(
obj
)
;
if
(
!
IsObject
(
ctor
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
"
object
'
s
'
constructor
'
property
"
)
;
var
s
=
ctor
[
std_species
]
;
if
(
s
=
=
=
undefined
|
|
s
=
=
=
null
)
return
_ConstructorForTypedArray
(
obj
)
;
if
(
IsConstructor
(
s
)
)
return
s
;
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
"
species
property
of
object
'
s
constructor
"
)
;
}
function
ValidateTypedArray
(
obj
)
{
if
(
IsObject
(
obj
)
)
{
if
(
IsTypedArray
(
obj
)
)
{
GetAttachedArrayBuffer
(
obj
)
;
return
true
;
}
if
(
IsPossiblyWrappedTypedArray
(
obj
)
)
{
if
(
PossiblyWrappedTypedArrayHasDetachedBuffer
(
obj
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
}
ThrowTypeError
(
JSMSG_NON_TYPED_ARRAY_RETURNED
)
;
}
function
TypedArrayCreateWithLength
(
constructor
length
)
{
var
newTypedArray
=
new
constructor
(
length
)
;
var
isTypedArray
=
ValidateTypedArray
(
newTypedArray
)
;
var
len
;
if
(
isTypedArray
)
{
len
=
TypedArrayLength
(
newTypedArray
)
;
}
else
{
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
newTypedArray
"
TypedArrayLengthMethod
"
)
;
}
if
(
len
<
length
)
ThrowTypeError
(
JSMSG_SHORT_TYPED_ARRAY_RETURNED
length
len
)
;
return
newTypedArray
;
}
function
TypedArrayCreateWithBuffer
(
constructor
buffer
byteOffset
length
)
{
var
newTypedArray
=
new
constructor
(
buffer
byteOffset
length
)
;
ValidateTypedArray
(
newTypedArray
)
;
return
newTypedArray
;
}
function
TypedArraySpeciesCreateWithLength
(
exemplar
length
)
{
var
C
=
TypedArraySpeciesConstructor
(
exemplar
)
;
return
TypedArrayCreateWithLength
(
C
length
)
;
}
function
TypedArraySpeciesCreateWithBuffer
(
exemplar
buffer
byteOffset
length
)
{
var
C
=
TypedArraySpeciesConstructor
(
exemplar
)
;
return
TypedArrayCreateWithBuffer
(
C
buffer
byteOffset
length
)
;
}
function
TypedArrayCopyWithin
(
target
start
end
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
target
start
end
"
TypedArrayCopyWithin
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
obj
=
this
;
var
len
=
TypedArrayLength
(
obj
)
;
assert
(
0
<
=
len
&
&
len
<
=
0x7FFFFFFF
"
assumed
by
some
of
the
math
below
see
also
the
other
assertions
"
)
;
var
relativeTarget
=
ToInteger
(
target
)
;
var
to
=
relativeTarget
<
0
?
std_Math_max
(
len
+
relativeTarget
0
)
:
std_Math_min
(
relativeTarget
len
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
from
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
count
=
std_Math_min
(
final
-
from
len
-
to
)
;
assert
(
0
<
=
to
&
&
to
<
=
0x7FFFFFFF
"
typed
array
|
to
|
index
assumed
int32_t
"
)
;
assert
(
0
<
=
from
&
&
from
<
=
0x7FFFFFFF
"
typed
array
|
from
|
index
assumed
int32_t
"
)
;
assert
(
-
0x7FFFFFFF
-
1
<
=
count
&
&
count
<
=
0x7FFFFFFF
"
typed
array
element
count
assumed
int32_t
"
)
;
if
(
count
>
0
)
MoveTypedArrayElements
(
obj
to
|
0
from
|
0
count
|
0
)
;
return
obj
;
}
function
TypedArrayEntries
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY_AND_VALUE
)
;
}
function
TypedArrayEvery
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
every
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
T
kValue
k
O
)
;
if
(
!
testResult
)
return
false
;
}
return
true
;
}
function
TypedArrayFill
(
value
start
=
0
end
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
value
start
end
"
TypedArrayFill
"
)
;
}
var
O
=
this
;
var
buffer
=
GetAttachedArrayBuffer
(
this
)
;
var
len
=
TypedArrayLength
(
O
)
;
var
kind
=
GetTypedArrayKind
(
O
)
;
if
(
kind
=
=
=
TYPEDARRAY_KIND_BIGINT64
|
|
kind
=
=
=
TYPEDARRAY_KIND_BIGUINT64
)
{
value
=
ToBigInt
(
value
)
;
}
else
{
value
=
ToNumber
(
value
)
;
}
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
if
(
buffer
=
=
=
null
)
{
buffer
=
ViewedArrayBufferIfReified
(
O
)
;
}
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
for
(
;
k
<
final
;
k
+
+
)
{
O
[
k
]
=
value
;
}
return
O
;
}
function
TypedArrayFilter
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
filter
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
var
kept
=
new
List
(
)
;
var
captured
=
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
selected
=
ToBoolean
(
callContentFunction
(
callbackfn
T
kValue
k
O
)
)
;
if
(
selected
)
{
kept
[
captured
+
+
]
=
kValue
;
}
}
var
A
=
TypedArraySpeciesCreateWithLength
(
O
captured
)
;
for
(
var
n
=
0
;
n
<
captured
;
n
+
+
)
{
A
[
n
]
=
kept
[
n
]
;
}
return
A
;
}
function
TypedArrayFind
(
predicate
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
find
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
if
(
callContentFunction
(
predicate
T
kValue
k
O
)
)
return
kValue
;
}
return
undefined
;
}
function
TypedArrayFindIndex
(
predicate
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
findIndex
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
if
(
callContentFunction
(
predicate
T
O
[
k
]
k
O
)
)
return
k
;
}
return
-
1
;
}
function
TypedArrayForEach
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
TypedArray
.
prototype
.
forEach
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
callContentFunction
(
callbackfn
T
O
[
k
]
k
O
)
;
}
return
undefined
;
}
function
TypedArrayIndexOf
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
ToInteger
(
fromIndex
)
+
0
;
if
(
n
>
=
len
)
return
-
1
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
for
(
;
k
<
len
;
k
+
+
)
{
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayJoin
(
separator
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
separator
"
TypedArrayJoin
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
sep
=
separator
=
=
=
undefined
?
"
"
:
ToString
(
separator
)
;
if
(
len
=
=
=
0
)
return
"
"
;
var
element0
=
O
[
0
]
;
var
R
=
ToString
(
element0
)
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
S
=
R
+
sep
;
var
element
=
O
[
k
]
;
var
next
=
ToString
(
element
)
;
R
=
S
+
next
;
}
return
R
;
}
function
TypedArrayKeys
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY
)
;
}
function
TypedArrayLastIndexOf
(
searchElement
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
if
(
arguments
.
length
>
1
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
arguments
[
1
]
"
TypedArrayLastIndexOf
"
)
;
}
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
"
TypedArrayLastIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
arguments
.
length
>
1
?
ToInteger
(
arguments
[
1
]
)
+
0
:
len
-
1
;
var
k
=
n
>
=
0
?
std_Math_min
(
n
len
-
1
)
:
len
+
n
;
for
(
;
k
>
=
0
;
k
-
-
)
{
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayMap
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
map
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
mappedValue
=
callContentFunction
(
callbackfn
T
O
[
k
]
k
O
)
;
A
[
k
]
=
mappedValue
;
}
return
A
;
}
function
TypedArrayReduce
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduce
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
0
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
+
+
]
;
for
(
;
k
<
len
;
k
+
+
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReduceRight
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduceRight
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
len
-
1
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
-
-
]
;
for
(
;
k
>
=
0
;
k
-
-
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReverse
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayReverse
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
middle
=
std_Math_floor
(
len
/
2
)
;
for
(
var
lower
=
0
;
lower
!
=
=
middle
;
lower
+
+
)
{
var
upper
=
len
-
lower
-
1
;
var
lowerValue
=
O
[
lower
]
;
var
upperValue
=
O
[
upper
]
;
O
[
lower
]
=
upperValue
;
O
[
upper
]
=
lowerValue
;
}
return
O
;
}
function
SetFromNonTypedArray
(
target
array
targetOffset
targetLength
targetBuffer
)
{
assert
(
!
IsPossiblyWrappedTypedArray
(
array
)
"
typed
arrays
must
be
passed
to
SetFromTypedArray
"
)
;
var
src
=
ToObject
(
array
)
;
var
srcLength
=
ToLength
(
src
.
length
)
;
var
limitOffset
=
targetOffset
+
srcLength
;
if
(
limitOffset
>
targetLength
)
ThrowRangeError
(
JSMSG_BAD_INDEX
)
;
var
k
=
0
;
var
isShared
=
targetBuffer
!
=
=
null
&
&
(
targetBuffer
=
GuardToSharedArrayBuffer
(
targetBuffer
)
)
!
=
=
null
;
while
(
targetOffset
<
limitOffset
)
{
var
kNumber
=
ToNumber
(
src
[
k
]
)
;
if
(
!
isShared
)
{
if
(
targetBuffer
=
=
=
null
)
{
targetBuffer
=
ViewedArrayBufferIfReified
(
target
)
;
}
if
(
IsDetachedBuffer
(
targetBuffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
target
[
targetOffset
]
=
kNumber
;
k
+
+
;
targetOffset
+
+
;
}
return
undefined
;
}
function
SetFromTypedArray
(
target
typedArray
targetOffset
targetLength
)
{
assert
(
IsPossiblyWrappedTypedArray
(
typedArray
)
"
only
typed
arrays
may
be
passed
to
this
method
"
)
;
var
res
=
SetFromTypedArrayApproach
(
target
typedArray
targetOffset
targetLength
|
0
)
;
assert
(
res
=
=
=
JS_SETTYPEDARRAY_SAME_TYPE
|
|
res
=
=
=
JS_SETTYPEDARRAY_OVERLAPPING
|
|
res
=
=
=
JS_SETTYPEDARRAY_DISJOINT
"
intrinsic
didn
'
t
return
one
of
its
enumerated
return
values
"
)
;
if
(
res
=
=
JS_SETTYPEDARRAY_SAME_TYPE
)
return
undefined
;
if
(
res
=
=
=
JS_SETTYPEDARRAY_DISJOINT
)
{
SetDisjointTypedElements
(
target
targetOffset
|
0
typedArray
)
;
return
undefined
;
}
SetOverlappingTypedElements
(
target
targetOffset
|
0
typedArray
)
;
return
undefined
;
}
function
TypedArraySet
(
overloaded
offset
=
0
)
{
var
target
=
this
;
if
(
!
IsObject
(
target
)
|
|
!
IsTypedArray
(
target
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
target
overloaded
offset
"
TypedArraySet
"
)
;
}
var
targetOffset
=
ToInteger
(
offset
)
;
if
(
targetOffset
<
0
)
ThrowRangeError
(
JSMSG_TYPED_ARRAY_NEGATIVE_ARG
"
2
"
)
;
var
targetBuffer
=
GetAttachedArrayBuffer
(
target
)
;
var
targetLength
=
TypedArrayLength
(
target
)
;
if
(
IsObject
(
overloaded
)
&
&
IsPossiblyWrappedTypedArray
(
overloaded
)
)
return
SetFromTypedArray
(
target
overloaded
targetOffset
targetLength
)
;
return
SetFromNonTypedArray
(
target
overloaded
targetOffset
targetLength
targetBuffer
)
;
}
function
TypedArraySlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsTypedArray
(
O
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
O
start
end
"
TypedArraySlice
"
)
;
}
var
buffer
=
GetAttachedArrayBuffer
(
O
)
;
var
len
=
TypedArrayLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
count
=
std_Math_max
(
final
-
k
0
)
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
count
)
;
if
(
count
>
0
)
{
if
(
buffer
=
=
=
null
)
{
buffer
=
ViewedArrayBufferIfReified
(
O
)
;
}
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
var
sliced
=
TypedArrayBitwiseSlice
(
O
A
k
|
0
count
|
0
)
;
if
(
!
sliced
)
{
var
n
=
0
;
while
(
k
<
final
)
{
A
[
n
+
+
]
=
O
[
k
+
+
]
;
}
}
}
return
A
;
}
function
TypedArraySome
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
some
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
T
kValue
k
O
)
;
if
(
testResult
)
return
true
;
}
return
false
;
}
function
TypedArrayCompare
(
x
y
)
{
assert
(
(
typeof
x
=
=
=
"
number
"
&
&
typeof
y
=
=
=
"
number
"
)
|
|
(
typeof
x
=
=
=
"
bigint
"
&
&
typeof
y
=
=
=
"
bigint
"
)
"
x
and
y
are
not
numbers
of
the
same
type
.
"
)
;
if
(
x
<
y
)
return
-
1
;
if
(
x
>
y
)
return
1
;
if
(
x
=
=
=
0
&
&
y
=
=
=
0
)
return
(
(
1
/
x
)
>
0
?
1
:
0
)
-
(
(
1
/
y
)
>
0
?
1
:
0
)
;
if
(
Number_isNaN
(
x
)
)
return
Number_isNaN
(
y
)
?
0
:
1
;
return
Number_isNaN
(
y
)
?
-
1
:
0
;
}
function
TypedArrayCompareInt
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
number
"
&
&
typeof
y
=
=
=
"
number
"
"
x
and
y
are
not
numbers
.
"
)
;
assert
(
(
x
=
=
=
(
x
|
0
)
|
|
x
=
=
=
(
x
>
>
>
0
)
)
&
&
(
y
=
=
=
(
y
|
0
)
|
|
y
=
=
=
(
y
>
>
>
0
)
)
"
x
and
y
are
not
int32
/
uint32
numbers
.
"
)
;
var
diff
=
x
-
y
;
if
(
diff
)
return
diff
;
return
0
;
}
function
TypedArrayCompareBigInt
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
bigint
"
&
&
typeof
y
=
=
=
"
bigint
"
"
x
and
y
are
not
BigInts
.
"
)
;
if
(
x
<
y
)
return
-
1
;
if
(
x
>
y
)
return
1
;
return
0
;
}
function
TypedArraySort
(
comparefn
)
{
if
(
comparefn
!
=
=
undefined
)
{
if
(
!
IsCallable
(
comparefn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
comparefn
)
)
;
}
var
obj
=
this
;
var
isTypedArray
=
IsObject
(
obj
)
&
&
IsTypedArray
(
obj
)
;
var
buffer
;
if
(
isTypedArray
)
{
buffer
=
GetAttachedArrayBuffer
(
obj
)
;
}
else
{
buffer
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
GetAttachedArrayBufferMethod
"
)
;
}
var
len
;
if
(
isTypedArray
)
{
len
=
TypedArrayLength
(
obj
)
;
}
else
{
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
TypedArrayLengthMethod
"
)
;
}
if
(
len
<
=
1
)
return
obj
;
if
(
comparefn
=
=
=
undefined
)
{
var
kind
=
GetTypedArrayKind
(
obj
)
;
switch
(
kind
)
{
case
TYPEDARRAY_KIND_UINT8
:
case
TYPEDARRAY_KIND_UINT8CLAMPED
:
return
CountingSort
(
obj
len
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT8
:
return
CountingSort
(
obj
len
true
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_UINT16
:
return
RadixSort
(
obj
len
buffer
2
false
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT16
:
return
RadixSort
(
obj
len
buffer
2
true
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_UINT32
:
return
RadixSort
(
obj
len
buffer
4
false
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT32
:
return
RadixSort
(
obj
len
buffer
4
true
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_BIGINT64
:
case
TYPEDARRAY_KIND_BIGUINT64
:
return
QuickSort
(
obj
len
TypedArrayCompareBigInt
)
;
case
TYPEDARRAY_KIND_FLOAT32
:
return
RadixSort
(
obj
len
buffer
4
true
true
TypedArrayCompare
)
;
case
TYPEDARRAY_KIND_FLOAT64
:
default
:
assert
(
kind
=
=
=
TYPEDARRAY_KIND_FLOAT64
"
unexpected
typed
array
kind
"
)
;
return
QuickSort
(
obj
len
TypedArrayCompare
)
;
}
}
var
wrappedCompareFn
=
function
(
x
y
)
{
var
v
=
+
comparefn
(
x
y
)
;
var
length
;
if
(
isTypedArray
)
{
length
=
TypedArrayLength
(
obj
)
;
}
else
{
length
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
TypedArrayLengthMethod
"
)
;
}
if
(
length
=
=
=
0
)
{
assert
(
PossiblyWrappedTypedArrayHasDetachedBuffer
(
obj
)
"
Length
can
only
change
from
non
-
zero
to
zero
when
the
buffer
was
detached
"
)
;
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
if
(
v
!
=
=
v
)
return
0
;
return
v
;
}
;
return
MergeSortTypedArray
(
obj
len
wrappedCompareFn
)
;
}
function
TypedArrayToLocaleString
(
locales
=
undefined
options
=
undefined
)
{
var
array
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
array
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
array
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
array
"
TypedArrayLengthMethod
"
)
;
if
(
len
=
=
=
0
)
return
"
"
;
var
firstElement
=
array
[
0
]
;
#
if
EXPOSE_INTL_API
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
locales
options
)
)
;
#
else
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
)
)
;
#
endif
var
separator
=
"
"
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
S
=
R
+
separator
;
var
nextElement
=
array
[
k
]
;
#
if
EXPOSE_INTL_API
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
locales
options
)
)
;
#
else
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
)
)
;
#
endif
R
=
S
+
R
;
}
return
R
;
}
function
TypedArraySubarray
(
begin
end
)
{
var
obj
=
this
;
if
(
!
IsObject
(
obj
)
|
|
!
IsTypedArray
(
obj
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
begin
end
"
TypedArraySubarray
"
)
;
}
var
buffer
=
ViewedArrayBufferIfReified
(
obj
)
;
if
(
buffer
=
=
=
null
)
{
buffer
=
TypedArrayBuffer
(
obj
)
;
}
var
srcLength
=
TypedArrayLength
(
obj
)
;
var
srcByteOffset
=
TypedArrayByteOffset
(
obj
)
;
var
relativeBegin
=
ToInteger
(
begin
)
;
var
beginIndex
=
relativeBegin
<
0
?
std_Math_max
(
srcLength
+
relativeBegin
0
)
:
std_Math_min
(
relativeBegin
srcLength
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
srcLength
:
ToInteger
(
end
)
;
var
endIndex
=
relativeEnd
<
0
?
std_Math_max
(
srcLength
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
srcLength
)
;
var
newLength
=
std_Math_max
(
endIndex
-
beginIndex
0
)
;
var
elementShift
=
TypedArrayElementShift
(
obj
)
;
var
beginByteOffset
=
srcByteOffset
+
(
beginIndex
<
<
elementShift
)
;
return
TypedArraySpeciesCreateWithBuffer
(
obj
buffer
beginByteOffset
newLength
)
;
}
function
TypedArrayValues
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_VALUE
)
;
}
_SetCanonicalName
(
TypedArrayValues
"
values
"
)
;
function
TypedArrayIncludes
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIncludes
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
false
;
var
n
=
ToInteger
(
fromIndex
)
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
while
(
k
<
len
)
{
if
(
SameValueZero
(
searchElement
O
[
k
]
)
)
return
true
;
k
+
+
;
}
return
false
;
}
function
TypedArrayStaticFrom
(
source
mapfn
=
undefined
thisArg
=
undefined
)
{
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
typeof
C
)
;
var
mapping
;
if
(
mapfn
!
=
=
undefined
)
{
if
(
!
IsCallable
(
mapfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
1
mapfn
)
)
;
mapping
=
true
;
}
else
{
mapping
=
false
;
}
var
T
=
thisArg
;
var
usingIterator
=
source
[
std_iterator
]
;
if
(
usingIterator
!
=
=
undefined
&
&
usingIterator
!
=
=
null
)
{
if
(
!
IsCallable
(
usingIterator
)
)
ThrowTypeError
(
JSMSG_NOT_ITERABLE
DecompileArg
(
0
source
)
)
;
if
(
!
mapping
&
&
IsTypedArrayConstructor
(
C
)
&
&
IsObject
(
source
)
)
{
if
(
usingIterator
=
=
=
TypedArrayValues
&
&
IsTypedArray
(
source
)
&
&
ArrayIteratorPrototypeOptimizable
(
)
)
{
GetAttachedArrayBuffer
(
source
)
;
var
len
=
TypedArrayLength
(
source
)
;
var
targetObj
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
targetObj
[
k
]
=
source
[
k
]
;
}
return
targetObj
;
}
if
(
usingIterator
=
=
=
ArrayValues
&
&
IsPackedArray
(
source
)
&
&
ArrayIteratorPrototypeOptimizable
(
)
)
{
var
targetObj
=
new
C
(
source
.
length
)
;
TypedArrayInitFromPackedArray
(
targetObj
source
)
;
return
targetObj
;
}
}
var
values
=
IterableToList
(
source
usingIterator
)
;
var
len
=
values
.
length
;
var
targetObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
values
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
var
arrayLike
=
ToObject
(
source
)
;
var
len
=
ToLength
(
arrayLike
.
length
)
;
var
targetObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
arrayLike
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
function
TypedArrayStaticOf
(
)
{
var
len
=
arguments
.
length
;
var
items
=
arguments
;
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
typeof
C
)
;
var
newObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
newObj
[
k
]
=
items
[
k
]
;
return
newObj
;
}
function
TypedArraySpecies
(
)
{
return
this
;
}
_SetCanonicalName
(
TypedArraySpecies
"
get
[
Symbol
.
species
]
"
)
;
function
IterableToList
(
items
method
)
{
assert
(
IsCallable
(
method
)
"
method
argument
is
a
function
"
)
;
var
iterator
=
callContentFunction
(
method
items
)
;
if
(
!
IsObject
(
iterator
)
)
ThrowTypeError
(
JSMSG_GET_ITER_RETURNED_PRIMITIVE
)
;
var
nextMethod
=
iterator
.
next
;
var
values
=
[
]
;
var
i
=
0
;
while
(
true
)
{
var
next
=
callContentFunction
(
nextMethod
iterator
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_ITER_METHOD_RETURNED_PRIMITIVE
"
next
"
)
;
if
(
next
.
done
)
break
;
_DefineDataProperty
(
values
i
+
+
next
.
value
)
;
}
return
values
;
}
function
ArrayBufferSlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
(
O
=
GuardToArrayBuffer
(
O
)
)
=
=
=
null
)
{
return
callFunction
(
CallArrayBufferMethodIfWrapped
this
start
end
"
ArrayBufferSlice
"
)
;
}
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
var
len
=
ArrayBufferByteLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
first
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
newLen
=
std_Math_max
(
final
-
first
0
)
;
var
ctor
=
SpeciesConstructor
(
O
GetBuiltinConstructor
(
"
ArrayBuffer
"
)
)
;
var
new_
=
new
ctor
(
newLen
)
;
var
isWrapped
=
false
;
var
newBuffer
;
if
(
(
newBuffer
=
GuardToArrayBuffer
(
new_
)
)
!
=
=
null
)
{
if
(
IsDetachedBuffer
(
new_
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
else
{
newBuffer
=
new_
;
if
(
!
IsWrappedArrayBuffer
(
newBuffer
)
)
ThrowTypeError
(
JSMSG_NON_ARRAY_BUFFER_RETURNED
)
;
isWrapped
=
true
;
if
(
callFunction
(
CallArrayBufferMethodIfWrapped
newBuffer
"
IsDetachedBufferThis
"
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
if
(
newBuffer
=
=
=
O
)
ThrowTypeError
(
JSMSG_SAME_ARRAY_BUFFER_RETURNED
)
;
var
actualLen
=
PossiblyWrappedArrayBufferByteLength
(
newBuffer
)
;
if
(
actualLen
<
newLen
)
ThrowTypeError
(
JSMSG_SHORT_ARRAY_BUFFER_RETURNED
newLen
actualLen
)
;
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
ArrayBufferCopyData
(
newBuffer
0
O
first
|
0
newLen
|
0
isWrapped
)
;
return
new_
;
}
function
IsDetachedBufferThis
(
)
{
return
IsDetachedBuffer
(
this
)
;
}
function
ArrayBufferSpecies
(
)
{
return
this
;
}
_SetCanonicalName
(
ArrayBufferSpecies
"
get
[
Symbol
.
species
]
"
)
;
function
SharedArrayBufferSpecies
(
)
{
return
this
;
}
_SetCanonicalName
(
SharedArrayBufferSpecies
"
get
[
Symbol
.
species
]
"
)
;
function
SharedArrayBufferSlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
(
O
=
GuardToSharedArrayBuffer
(
O
)
)
=
=
=
null
)
{
return
callFunction
(
CallSharedArrayBufferMethodIfWrapped
this
start
end
"
SharedArrayBufferSlice
"
)
;
}
var
len
=
SharedArrayBufferByteLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
first
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
newLen
=
std_Math_max
(
final
-
first
0
)
;
var
ctor
=
SpeciesConstructor
(
O
GetBuiltinConstructor
(
"
SharedArrayBuffer
"
)
)
;
var
new_
=
new
ctor
(
newLen
)
;
var
isWrapped
=
false
;
var
newObj
;
if
(
(
newObj
=
GuardToSharedArrayBuffer
(
new_
)
)
=
=
=
null
)
{
if
(
!
IsWrappedSharedArrayBuffer
(
new_
)
)
ThrowTypeError
(
JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED
)
;
isWrapped
=
true
;
newObj
=
new_
;
}
if
(
newObj
=
=
=
O
)
ThrowTypeError
(
JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED
)
;
if
(
SharedArrayBuffersMemorySame
(
newObj
O
)
)
ThrowTypeError
(
JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED
)
;
var
actualLen
=
PossiblyWrappedSharedArrayBufferByteLength
(
newObj
)
;
if
(
actualLen
<
newLen
)
ThrowTypeError
(
JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED
newLen
actualLen
)
;
SharedArrayBufferCopyData
(
newObj
0
O
first
|
0
newLen
|
0
isWrapped
)
;
return
new_
;
}
