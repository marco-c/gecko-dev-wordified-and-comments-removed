#
include
"
TypedArrayConstants
.
h
"
function
ViewedArrayBufferIfReified
(
tarray
)
{
assert
(
IsTypedArray
(
tarray
)
"
non
-
typed
array
asked
for
its
buffer
"
)
;
var
buf
=
UnsafeGetReservedSlot
(
tarray
JS_TYPEDARRAYLAYOUT_BUFFER_SLOT
)
;
assert
(
buf
=
=
=
null
|
|
(
IsObject
(
buf
)
&
&
(
GuardToArrayBuffer
(
buf
)
!
=
=
null
|
|
GuardToSharedArrayBuffer
(
buf
)
!
=
=
null
)
)
"
unexpected
value
in
buffer
slot
"
)
;
return
buf
;
}
function
IsDetachedBuffer
(
buffer
)
{
if
(
buffer
=
=
=
null
)
return
false
;
assert
(
GuardToArrayBuffer
(
buffer
)
!
=
=
null
|
|
GuardToSharedArrayBuffer
(
buffer
)
!
=
=
null
"
non
-
ArrayBuffer
passed
to
IsDetachedBuffer
"
)
;
if
(
(
buffer
=
GuardToArrayBuffer
(
buffer
)
)
=
=
=
null
)
return
false
;
var
flags
=
UnsafeGetInt32FromReservedSlot
(
buffer
JS_ARRAYBUFFER_FLAGS_SLOT
)
;
return
(
flags
&
JS_ARRAYBUFFER_DETACHED_FLAG
)
!
=
=
0
;
}
function
TypedArrayLengthMethod
(
)
{
return
TypedArrayLength
(
this
)
;
}
function
TypedArrayByteOffsetMethod
(
)
{
return
TypedArrayByteOffset
(
this
)
;
}
function
GetAttachedArrayBuffer
(
tarray
)
{
var
buffer
=
ViewedArrayBufferIfReified
(
tarray
)
;
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
buffer
;
}
function
GetAttachedArrayBufferMethod
(
)
{
return
GetAttachedArrayBuffer
(
this
)
;
}
function
IsTypedArrayEnsuringArrayBuffer
(
arg
)
{
if
(
IsObject
(
arg
)
&
&
IsTypedArray
(
arg
)
)
{
GetAttachedArrayBuffer
(
arg
)
;
return
true
;
}
callFunction
(
CallTypedArrayMethodIfWrapped
arg
"
GetAttachedArrayBufferMethod
"
)
;
return
false
;
}
function
TypedArraySpeciesConstructor
(
obj
)
{
assert
(
IsObject
(
obj
)
"
not
passed
an
object
"
)
;
var
ctor
=
obj
.
constructor
;
if
(
ctor
=
=
=
undefined
)
return
ConstructorForTypedArray
(
obj
)
;
if
(
!
IsObject
(
ctor
)
)
ThrowTypeError
(
JSMSG_OBJECT_REQUIRED
"
object
'
s
'
constructor
'
property
"
)
;
var
s
=
ctor
[
GetBuiltinSymbol
(
"
species
"
)
]
;
if
(
s
=
=
=
undefined
|
|
s
=
=
=
null
)
return
ConstructorForTypedArray
(
obj
)
;
if
(
IsConstructor
(
s
)
)
return
s
;
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
"
species
property
of
object
'
s
constructor
"
)
;
}
function
ValidateTypedArray
(
obj
)
{
if
(
IsObject
(
obj
)
)
{
if
(
IsTypedArray
(
obj
)
)
{
GetAttachedArrayBuffer
(
obj
)
;
return
true
;
}
if
(
IsPossiblyWrappedTypedArray
(
obj
)
)
{
if
(
PossiblyWrappedTypedArrayHasDetachedBuffer
(
obj
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
}
ThrowTypeError
(
JSMSG_NON_TYPED_ARRAY_RETURNED
)
;
}
function
TypedArrayCreateWithLength
(
constructor
length
)
{
var
newTypedArray
=
new
constructor
(
length
)
;
var
isTypedArray
=
ValidateTypedArray
(
newTypedArray
)
;
var
len
;
if
(
isTypedArray
)
{
len
=
TypedArrayLength
(
newTypedArray
)
;
}
else
{
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
newTypedArray
"
TypedArrayLengthMethod
"
)
;
}
if
(
len
<
length
)
ThrowTypeError
(
JSMSG_SHORT_TYPED_ARRAY_RETURNED
length
len
)
;
return
newTypedArray
;
}
function
TypedArrayCreateWithBuffer
(
constructor
buffer
byteOffset
length
)
{
var
newTypedArray
=
new
constructor
(
buffer
byteOffset
length
)
;
ValidateTypedArray
(
newTypedArray
)
;
return
newTypedArray
;
}
function
TypedArraySpeciesCreateWithLength
(
exemplar
length
)
{
var
C
=
TypedArraySpeciesConstructor
(
exemplar
)
;
return
TypedArrayCreateWithLength
(
C
length
)
;
}
function
TypedArraySpeciesCreateWithBuffer
(
exemplar
buffer
byteOffset
length
)
{
var
C
=
TypedArraySpeciesConstructor
(
exemplar
)
;
return
TypedArrayCreateWithBuffer
(
C
buffer
byteOffset
length
)
;
}
function
TypedArrayEntries
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY_AND_VALUE
)
;
}
function
TypedArrayEvery
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
every
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
thisArg
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
thisArg
kValue
k
O
)
;
if
(
!
testResult
)
return
false
;
}
return
true
;
}
function
TypedArrayFill
(
value
start
=
0
end
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
value
start
end
"
TypedArrayFill
"
)
;
}
var
O
=
this
;
var
buffer
=
GetAttachedArrayBuffer
(
this
)
;
var
len
=
TypedArrayLength
(
O
)
;
var
kind
=
GetTypedArrayKind
(
O
)
;
if
(
kind
=
=
=
TYPEDARRAY_KIND_BIGINT64
|
|
kind
=
=
=
TYPEDARRAY_KIND_BIGUINT64
)
{
value
=
ToBigInt
(
value
)
;
}
else
{
value
=
ToNumber
(
value
)
;
}
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
if
(
buffer
=
=
=
null
)
{
buffer
=
ViewedArrayBufferIfReified
(
O
)
;
}
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
for
(
;
k
<
final
;
k
+
+
)
{
O
[
k
]
=
value
;
}
return
O
;
}
function
TypedArrayFilter
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
filter
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
var
kept
=
new_List
(
)
;
var
captured
=
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
selected
=
ToBoolean
(
callContentFunction
(
callbackfn
T
kValue
k
O
)
)
;
if
(
selected
)
{
kept
[
captured
+
+
]
=
kValue
;
}
}
var
A
=
TypedArraySpeciesCreateWithLength
(
O
captured
)
;
for
(
var
n
=
0
;
n
<
captured
;
n
+
+
)
{
A
[
n
]
=
kept
[
n
]
;
}
return
A
;
}
function
TypedArrayFind
(
predicate
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
find
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
thisArg
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
if
(
callContentFunction
(
predicate
thisArg
kValue
k
O
)
)
return
kValue
;
}
return
undefined
;
}
function
TypedArrayFindIndex
(
predicate
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
findIndex
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
thisArg
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
if
(
callContentFunction
(
predicate
thisArg
O
[
k
]
k
O
)
)
return
k
;
}
return
-
1
;
}
function
TypedArrayForEach
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
TypedArray
.
prototype
.
forEach
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
thisArg
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
callContentFunction
(
callbackfn
thisArg
O
[
k
]
k
O
)
;
}
return
undefined
;
}
function
TypedArrayIndexOf
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
ToInteger
(
fromIndex
)
;
assert
(
fromIndex
!
=
=
undefined
|
|
n
=
=
=
0
"
ToInteger
(
undefined
)
is
zero
"
)
;
len
=
TypedArrayLength
(
O
)
;
assert
(
len
=
=
=
0
|
|
!
IsDetachedBuffer
(
ViewedArrayBufferIfReified
(
O
)
)
"
TypedArrays
with
detached
buffers
have
a
length
of
zero
"
)
;
if
(
n
>
=
len
)
return
-
1
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
for
(
;
k
<
len
;
k
+
+
)
{
assert
(
k
in
O
"
unexpected
missing
element
"
)
;
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayJoin
(
separator
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
separator
"
TypedArrayJoin
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
sep
=
separator
=
=
=
undefined
?
"
"
:
ToString
(
separator
)
;
if
(
len
=
=
=
0
)
return
"
"
;
if
(
TypedArrayLength
(
O
)
=
=
=
0
)
{
assert
(
IsDetachedBuffer
(
ViewedArrayBufferIfReified
(
O
)
)
"
TypedArrays
with
detached
buffers
have
a
length
of
zero
"
)
;
return
callFunction
(
String_repeat
"
"
len
-
1
)
;
}
assert
(
!
IsDetachedBuffer
(
ViewedArrayBufferIfReified
(
O
)
)
"
TypedArrays
with
detached
buffers
have
a
length
of
zero
"
)
;
var
element0
=
O
[
0
]
;
assert
(
element0
!
=
=
undefined
"
unexpected
undefined
element
"
)
;
var
R
=
ToString
(
element0
)
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
element
=
O
[
k
]
;
assert
(
element
!
=
=
undefined
"
unexpected
undefined
element
"
)
;
R
+
=
sep
+
ToString
(
element
)
;
}
return
R
;
}
function
TypedArrayKeys
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY
)
;
}
function
TypedArrayLastIndexOf
(
searchElement
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
if
(
arguments
.
length
>
1
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
arguments
[
1
]
"
TypedArrayLastIndexOf
"
)
;
}
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
"
TypedArrayLastIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
arguments
.
length
>
1
?
ToInteger
(
arguments
[
1
]
)
:
len
-
1
;
len
=
TypedArrayLength
(
O
)
;
assert
(
len
=
=
=
0
|
|
!
IsDetachedBuffer
(
ViewedArrayBufferIfReified
(
O
)
)
"
TypedArrays
with
detached
buffers
have
a
length
of
zero
"
)
;
var
k
=
n
>
=
0
?
std_Math_min
(
n
len
-
1
)
:
len
+
n
;
for
(
;
k
>
=
0
;
k
-
-
)
{
assert
(
k
in
O
"
unexpected
missing
element
"
)
;
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayMap
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
map
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
mappedValue
=
callContentFunction
(
callbackfn
T
O
[
k
]
k
O
)
;
A
[
k
]
=
mappedValue
;
}
return
A
;
}
function
TypedArrayReduce
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduce
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
0
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
+
+
]
;
for
(
;
k
<
len
;
k
+
+
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReduceRight
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduceRight
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
len
-
1
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
-
-
]
;
for
(
;
k
>
=
0
;
k
-
-
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReverse
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayReverse
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
middle
=
std_Math_floor
(
len
/
2
)
;
for
(
var
lower
=
0
;
lower
!
=
=
middle
;
lower
+
+
)
{
var
upper
=
len
-
lower
-
1
;
var
lowerValue
=
O
[
lower
]
;
var
upperValue
=
O
[
upper
]
;
O
[
lower
]
=
upperValue
;
O
[
upper
]
=
lowerValue
;
}
return
O
;
}
function
TypedArraySlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsTypedArray
(
O
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
O
start
end
"
TypedArraySlice
"
)
;
}
var
buffer
=
GetAttachedArrayBuffer
(
O
)
;
var
len
=
TypedArrayLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
count
=
std_Math_max
(
final
-
k
0
)
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
count
)
;
if
(
count
>
0
)
{
if
(
buffer
=
=
=
null
)
{
buffer
=
ViewedArrayBufferIfReified
(
O
)
;
}
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
var
sliced
=
TypedArrayBitwiseSlice
(
O
A
k
count
)
;
if
(
!
sliced
)
{
var
n
=
0
;
while
(
k
<
final
)
{
A
[
n
+
+
]
=
O
[
k
+
+
]
;
}
}
}
return
A
;
}
function
TypedArraySome
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
"
TypedArrayLengthMethod
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
some
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
thisArg
=
arguments
.
length
>
1
?
arguments
[
1
]
:
void
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
thisArg
kValue
k
O
)
;
if
(
testResult
)
return
true
;
}
return
false
;
}
function
TypedArrayCompare
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
number
"
&
&
typeof
y
=
=
=
"
number
"
"
x
and
y
are
not
numbers
.
"
)
;
if
(
x
<
y
)
return
-
1
;
if
(
x
>
y
)
return
1
;
if
(
x
=
=
=
0
&
&
y
=
=
=
0
)
return
(
(
1
/
x
)
>
0
?
1
:
0
)
-
(
(
1
/
y
)
>
0
?
1
:
0
)
;
if
(
Number_isNaN
(
x
)
)
return
Number_isNaN
(
y
)
?
0
:
1
;
return
Number_isNaN
(
y
)
?
-
1
:
0
;
}
function
TypedArrayCompareInt
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
number
"
&
&
typeof
y
=
=
=
"
number
"
"
x
and
y
are
not
numbers
.
"
)
;
assert
(
(
x
=
=
=
(
x
|
0
)
|
|
x
=
=
=
(
x
>
>
>
0
)
)
&
&
(
y
=
=
=
(
y
|
0
)
|
|
y
=
=
=
(
y
>
>
>
0
)
)
"
x
and
y
are
not
int32
/
uint32
numbers
.
"
)
;
var
diff
=
x
-
y
;
if
(
diff
)
return
diff
;
return
0
;
}
function
TypedArrayCompareBigInt
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
bigint
"
&
&
typeof
y
=
=
=
"
bigint
"
"
x
and
y
are
not
BigInts
.
"
)
;
if
(
x
<
y
)
return
-
1
;
if
(
x
>
y
)
return
1
;
return
0
;
}
function
TypedArraySort
(
comparefn
)
{
if
(
comparefn
!
=
=
undefined
)
{
if
(
!
IsCallable
(
comparefn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
comparefn
)
)
;
}
var
obj
=
this
;
var
isTypedArray
=
IsObject
(
obj
)
&
&
IsTypedArray
(
obj
)
;
var
buffer
;
if
(
isTypedArray
)
{
buffer
=
GetAttachedArrayBuffer
(
obj
)
;
}
else
{
buffer
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
GetAttachedArrayBufferMethod
"
)
;
}
var
len
;
if
(
isTypedArray
)
{
len
=
TypedArrayLength
(
obj
)
;
}
else
{
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
TypedArrayLengthMethod
"
)
;
}
if
(
len
<
=
1
)
return
obj
;
if
(
comparefn
=
=
=
undefined
)
{
var
kind
=
GetTypedArrayKind
(
obj
)
;
switch
(
kind
)
{
case
TYPEDARRAY_KIND_UINT8
:
case
TYPEDARRAY_KIND_UINT8CLAMPED
:
return
CountingSort
(
obj
len
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT8
:
return
CountingSort
(
obj
len
true
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_UINT16
:
return
RadixSort
(
obj
len
buffer
2
false
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT16
:
return
RadixSort
(
obj
len
buffer
2
true
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_UINT32
:
return
RadixSort
(
obj
len
buffer
4
false
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_INT32
:
return
RadixSort
(
obj
len
buffer
4
true
false
TypedArrayCompareInt
)
;
case
TYPEDARRAY_KIND_BIGINT64
:
case
TYPEDARRAY_KIND_BIGUINT64
:
return
QuickSort
(
obj
len
TypedArrayCompareBigInt
)
;
case
TYPEDARRAY_KIND_FLOAT32
:
return
RadixSort
(
obj
len
buffer
4
true
true
TypedArrayCompare
)
;
case
TYPEDARRAY_KIND_FLOAT64
:
default
:
assert
(
kind
=
=
=
TYPEDARRAY_KIND_FLOAT64
"
unexpected
typed
array
kind
"
)
;
return
QuickSort
(
obj
len
TypedArrayCompare
)
;
}
}
var
wrappedCompareFn
=
function
(
x
y
)
{
var
v
=
+
comparefn
(
x
y
)
;
var
length
;
if
(
isTypedArray
)
{
length
=
TypedArrayLength
(
obj
)
;
}
else
{
length
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
"
TypedArrayLengthMethod
"
)
;
}
if
(
length
=
=
=
0
)
{
assert
(
PossiblyWrappedTypedArrayHasDetachedBuffer
(
obj
)
"
Length
can
only
change
from
non
-
zero
to
zero
when
the
buffer
was
detached
"
)
;
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
if
(
v
!
=
=
v
)
return
0
;
return
v
;
}
;
return
MergeSortTypedArray
(
obj
len
wrappedCompareFn
)
;
}
function
TypedArrayToLocaleString
(
locales
=
undefined
options
=
undefined
)
{
var
array
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
array
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
array
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
array
"
TypedArrayLengthMethod
"
)
;
if
(
len
=
=
=
0
)
return
"
"
;
var
firstElement
=
array
[
0
]
;
#
if
JS_HAS_INTL_API
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
locales
options
)
)
;
#
else
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
)
)
;
#
endif
var
separator
=
"
"
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
S
=
R
+
separator
;
var
nextElement
=
array
[
k
]
;
#
if
JS_HAS_INTL_API
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
locales
options
)
)
;
#
else
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
)
)
;
#
endif
R
=
S
+
R
;
}
return
R
;
}
function
TypedArraySubarray
(
begin
end
)
{
var
obj
=
this
;
if
(
!
IsObject
(
obj
)
|
|
!
IsTypedArray
(
obj
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
begin
end
"
TypedArraySubarray
"
)
;
}
var
buffer
=
ViewedArrayBufferIfReified
(
obj
)
;
if
(
buffer
=
=
=
null
)
{
buffer
=
TypedArrayBuffer
(
obj
)
;
}
var
srcLength
=
TypedArrayLength
(
obj
)
;
var
srcByteOffset
=
TypedArrayByteOffset
(
obj
)
;
var
relativeBegin
=
ToInteger
(
begin
)
;
var
beginIndex
=
relativeBegin
<
0
?
std_Math_max
(
srcLength
+
relativeBegin
0
)
:
std_Math_min
(
relativeBegin
srcLength
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
srcLength
:
ToInteger
(
end
)
;
var
endIndex
=
relativeEnd
<
0
?
std_Math_max
(
srcLength
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
srcLength
)
;
var
newLength
=
std_Math_max
(
endIndex
-
beginIndex
0
)
;
var
elementSize
=
TypedArrayElementSize
(
obj
)
;
var
beginByteOffset
=
srcByteOffset
+
(
beginIndex
*
elementSize
)
;
return
TypedArraySpeciesCreateWithBuffer
(
obj
buffer
beginByteOffset
newLength
)
;
}
function
TypedArrayAt
(
index
)
{
var
obj
=
this
;
if
(
!
IsObject
(
obj
)
|
|
!
IsTypedArray
(
obj
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
obj
index
"
TypedArrayAt
"
)
;
}
GetAttachedArrayBuffer
(
obj
)
;
var
len
=
TypedArrayLength
(
obj
)
;
var
relativeIndex
=
ToInteger
(
index
)
;
var
k
;
if
(
relativeIndex
>
=
0
)
{
k
=
relativeIndex
;
}
else
{
k
=
len
+
relativeIndex
;
}
if
(
k
<
0
|
|
k
>
=
len
)
{
return
undefined
;
}
return
obj
[
k
]
;
}
function
TypedArrayValues
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_VALUE
)
;
}
SetCanonicalName
(
TypedArrayValues
"
values
"
)
;
function
TypedArrayIncludes
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIncludes
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
false
;
var
n
=
ToInteger
(
fromIndex
)
;
assert
(
fromIndex
!
=
=
undefined
|
|
n
=
=
=
0
"
ToInteger
(
undefined
)
is
zero
"
)
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
while
(
k
<
len
)
{
if
(
SameValueZero
(
searchElement
O
[
k
]
)
)
return
true
;
k
+
+
;
}
return
false
;
}
function
TypedArrayStaticFrom
(
source
mapfn
=
undefined
thisArg
=
undefined
)
{
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
typeof
C
)
;
var
mapping
;
if
(
mapfn
!
=
=
undefined
)
{
if
(
!
IsCallable
(
mapfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
1
mapfn
)
)
;
mapping
=
true
;
}
else
{
mapping
=
false
;
}
var
T
=
thisArg
;
var
usingIterator
=
source
[
GetBuiltinSymbol
(
"
iterator
"
)
]
;
if
(
usingIterator
!
=
=
undefined
&
&
usingIterator
!
=
=
null
)
{
if
(
!
IsCallable
(
usingIterator
)
)
ThrowTypeError
(
JSMSG_NOT_ITERABLE
DecompileArg
(
0
source
)
)
;
if
(
!
mapping
&
&
IsTypedArrayConstructor
(
C
)
&
&
IsObject
(
source
)
)
{
if
(
usingIterator
=
=
=
TypedArrayValues
&
&
IsTypedArray
(
source
)
&
&
ArrayIteratorPrototypeOptimizable
(
)
)
{
GetAttachedArrayBuffer
(
source
)
;
var
len
=
TypedArrayLength
(
source
)
;
var
targetObj
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
targetObj
[
k
]
=
source
[
k
]
;
}
return
targetObj
;
}
if
(
usingIterator
=
=
=
ArrayValues
&
&
IsPackedArray
(
source
)
&
&
ArrayIteratorPrototypeOptimizable
(
)
)
{
var
targetObj
=
new
C
(
source
.
length
)
;
TypedArrayInitFromPackedArray
(
targetObj
source
)
;
return
targetObj
;
}
}
var
values
=
IterableToList
(
source
usingIterator
)
;
var
len
=
values
.
length
;
var
targetObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
values
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
var
arrayLike
=
ToObject
(
source
)
;
var
len
=
ToLength
(
arrayLike
.
length
)
;
var
targetObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
arrayLike
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
function
TypedArrayStaticOf
(
)
{
var
len
=
arguments
.
length
;
var
items
=
arguments
;
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
typeof
C
)
;
var
newObj
=
TypedArrayCreateWithLength
(
C
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
newObj
[
k
]
=
items
[
k
]
;
return
newObj
;
}
function
TypedArraySpecies
(
)
{
return
this
;
}
SetCanonicalName
(
TypedArraySpecies
"
get
[
Symbol
.
species
]
"
)
;
function
IterableToList
(
items
method
)
{
assert
(
IsCallable
(
method
)
"
method
argument
is
a
function
"
)
;
var
iterator
=
callContentFunction
(
method
items
)
;
if
(
!
IsObject
(
iterator
)
)
ThrowTypeError
(
JSMSG_GET_ITER_RETURNED_PRIMITIVE
)
;
var
nextMethod
=
iterator
.
next
;
var
values
=
[
]
;
var
i
=
0
;
while
(
true
)
{
var
next
=
callContentFunction
(
nextMethod
iterator
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_ITER_METHOD_RETURNED_PRIMITIVE
"
next
"
)
;
if
(
next
.
done
)
break
;
DefineDataProperty
(
values
i
+
+
next
.
value
)
;
}
return
values
;
}
function
ArrayBufferSlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
(
O
=
GuardToArrayBuffer
(
O
)
)
=
=
=
null
)
{
return
callFunction
(
CallArrayBufferMethodIfWrapped
this
start
end
"
ArrayBufferSlice
"
)
;
}
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
var
len
=
ArrayBufferByteLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
first
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
newLen
=
std_Math_max
(
final
-
first
0
)
;
var
ctor
=
SpeciesConstructor
(
O
GetBuiltinConstructor
(
"
ArrayBuffer
"
)
)
;
var
new_
=
new
ctor
(
newLen
)
;
var
isWrapped
=
false
;
var
newBuffer
;
if
(
(
newBuffer
=
GuardToArrayBuffer
(
new_
)
)
!
=
=
null
)
{
if
(
IsDetachedBuffer
(
newBuffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
else
{
newBuffer
=
new_
;
if
(
!
IsWrappedArrayBuffer
(
newBuffer
)
)
ThrowTypeError
(
JSMSG_NON_ARRAY_BUFFER_RETURNED
)
;
isWrapped
=
true
;
if
(
callFunction
(
CallArrayBufferMethodIfWrapped
newBuffer
"
IsDetachedBufferThis
"
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
if
(
newBuffer
=
=
=
O
)
ThrowTypeError
(
JSMSG_SAME_ARRAY_BUFFER_RETURNED
)
;
var
actualLen
=
PossiblyWrappedArrayBufferByteLength
(
newBuffer
)
;
if
(
actualLen
<
newLen
)
ThrowTypeError
(
JSMSG_SHORT_ARRAY_BUFFER_RETURNED
newLen
actualLen
)
;
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
ArrayBufferCopyData
(
newBuffer
0
O
first
newLen
isWrapped
)
;
return
newBuffer
;
}
function
IsDetachedBufferThis
(
)
{
return
IsDetachedBuffer
(
this
)
;
}
function
ArrayBufferSpecies
(
)
{
return
this
;
}
SetCanonicalName
(
ArrayBufferSpecies
"
get
[
Symbol
.
species
]
"
)
;
function
SharedArrayBufferSpecies
(
)
{
return
this
;
}
SetCanonicalName
(
SharedArrayBufferSpecies
"
get
[
Symbol
.
species
]
"
)
;
function
SharedArrayBufferSlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
(
O
=
GuardToSharedArrayBuffer
(
O
)
)
=
=
=
null
)
{
return
callFunction
(
CallSharedArrayBufferMethodIfWrapped
this
start
end
"
SharedArrayBufferSlice
"
)
;
}
var
len
=
SharedArrayBufferByteLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
first
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
newLen
=
std_Math_max
(
final
-
first
0
)
;
var
ctor
=
SpeciesConstructor
(
O
GetBuiltinConstructor
(
"
SharedArrayBuffer
"
)
)
;
var
new_
=
new
ctor
(
newLen
)
;
var
isWrapped
=
false
;
var
newObj
;
if
(
(
newObj
=
GuardToSharedArrayBuffer
(
new_
)
)
=
=
=
null
)
{
if
(
!
IsWrappedSharedArrayBuffer
(
new_
)
)
ThrowTypeError
(
JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED
)
;
isWrapped
=
true
;
newObj
=
new_
;
}
if
(
newObj
=
=
=
O
|
|
SharedArrayBuffersMemorySame
(
newObj
O
)
)
ThrowTypeError
(
JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED
)
;
var
actualLen
=
PossiblyWrappedSharedArrayBufferByteLength
(
newObj
)
;
if
(
actualLen
<
newLen
)
ThrowTypeError
(
JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED
newLen
actualLen
)
;
SharedArrayBufferCopyData
(
newObj
0
O
first
newLen
isWrapped
)
;
return
newObj
;
}
#
ifdef
ENABLE_CHANGE_ARRAY_BY_COPY
function
TypedArrayWithReversed
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayWithReversed
"
)
;
}
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
from
=
len
-
k
-
1
;
var
fromValue
=
O
[
from
]
;
DefineDataProperty
(
A
k
fromValue
)
;
}
return
A
;
}
function
isValidIntegerIndex
(
a
index
)
{
return
(
!
IsDetachedBuffer
(
ViewedArrayBufferIfReified
(
a
)
)
&
&
Number_isInteger
(
index
)
&
&
!
SameValue
(
index
-
0
)
&
&
index
>
=
0
&
&
index
<
TypedArrayLength
(
a
)
)
;
}
function
TypedArrayWithAt
(
index
value
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayWithAt
"
index
value
)
;
}
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
!
Number_isInteger
(
index
)
)
{
ThrowRangeError
(
JSMSG_BAD_INDEX
)
;
}
var
actualIndex
=
index
<
0
?
(
len
+
index
)
:
index
;
if
(
!
isValidIntegerIndex
(
O
actualIndex
)
)
{
ThrowRangeError
(
JSMSG_BAD_INDEX
)
;
}
var
A
=
TypedArraySpeciesCreateWithLength
(
O
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
fromValue
=
k
=
=
actualIndex
?
value
:
O
[
k
]
;
DefineDataProperty
(
A
k
fromValue
)
;
}
return
A
;
}
function
TypedArrayWithSorted
(
comparefn
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayWithSorted
"
comparefn
)
;
}
if
(
comparefn
!
=
=
undefined
)
{
if
(
!
IsCallable
(
comparefn
)
)
{
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
comparefn
)
)
;
}
}
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
A
[
k
]
=
O
[
k
]
;
}
return
callFunction
(
CallTypedArrayMethodIfWrapped
A
comparefn
"
TypedArraySort
"
)
;
}
function
TypedArrayWithSpliced
(
start
deleteCount
.
.
.
items
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayWithSpliced
"
start
deleteCount
items
)
;
}
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
actualStart
;
if
(
!
Global_isFinite
(
relativeStart
)
&
&
relativeStart
<
0
)
{
actualStart
=
0
;
}
else
if
(
relativeStart
<
0
)
{
actualStart
=
std_Math_max
(
len
+
relativeStart
0
)
;
}
else
{
actualStart
=
std_Math_min
(
relativeStart
len
)
;
}
var
insertCount
;
var
actualDeleteCount
;
if
(
start
=
=
=
undefined
)
{
insertCount
=
0
;
actualDeleteCount
=
0
;
}
else
if
(
deleteCount
=
=
=
undefined
)
{
insertCount
=
0
;
actualDeleteCount
=
len
-
actualStart
;
}
else
{
insertCount
=
items
=
=
=
undefined
?
0
:
items
.
length
;
var
dc
=
ToInteger
(
deleteCount
)
;
actualDeleteCount
=
std_Math_min
(
len
-
actualStart
std_Math_max
(
0
dc
)
)
;
}
var
newLen
=
len
+
insertCount
-
actualDeleteCount
;
var
A
=
TypedArraySpeciesCreateWithLength
(
O
newLen
)
;
for
(
var
k
=
0
;
k
<
actualStart
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
DefineDataProperty
(
A
k
kValue
)
;
}
var
k
=
actualStart
;
for
(
var
i
=
0
;
i
<
insertCount
;
i
+
+
)
{
DefineDataProperty
(
A
k
+
+
items
[
i
]
)
;
}
while
(
k
<
newLen
)
{
var
from
=
k
+
actualDeleteCount
-
insertCount
;
var
fromValue
=
O
[
from
]
;
DefineDataProperty
(
A
k
+
+
fromValue
)
;
}
return
A
;
}
#
endif
