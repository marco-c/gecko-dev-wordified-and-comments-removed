#
include
"
TypedObjectConstants
.
h
"
function
ViewedArrayBufferIfReified
(
tarray
)
{
assert
(
IsTypedArray
(
tarray
)
"
non
-
typed
array
asked
for
its
buffer
"
)
;
var
buf
=
UnsafeGetReservedSlot
(
tarray
JS_TYPEDARRAYLAYOUT_BUFFER_SLOT
)
;
assert
(
buf
=
=
=
null
|
|
(
IsObject
(
buf
)
&
&
(
IsArrayBuffer
(
buf
)
|
|
IsSharedArrayBuffer
(
buf
)
)
)
"
unexpected
value
in
buffer
slot
"
)
;
return
buf
;
}
function
IsDetachedBuffer
(
buffer
)
{
if
(
buffer
=
=
=
null
)
return
false
;
assert
(
IsArrayBuffer
(
buffer
)
|
|
IsSharedArrayBuffer
(
buffer
)
"
non
-
ArrayBuffer
passed
to
IsDetachedBuffer
"
)
;
if
(
IsSharedArrayBuffer
(
buffer
)
)
return
false
;
var
flags
=
UnsafeGetInt32FromReservedSlot
(
buffer
JS_ARRAYBUFFER_FLAGS_SLOT
)
;
return
(
flags
&
JS_ARRAYBUFFER_DETACHED_FLAG
)
!
=
=
0
;
}
function
GetAttachedArrayBuffer
(
tarray
)
{
var
buffer
=
ViewedArrayBufferIfReified
(
tarray
)
;
if
(
IsDetachedBuffer
(
buffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
buffer
;
}
function
IsTypedArrayEnsuringArrayBuffer
(
arg
)
{
if
(
IsObject
(
arg
)
&
&
IsTypedArray
(
arg
)
)
{
GetAttachedArrayBuffer
(
arg
)
;
return
true
;
}
callFunction
(
CallTypedArrayMethodIfWrapped
arg
arg
"
GetAttachedArrayBuffer
"
)
;
return
false
;
}
function
TypedArrayCopyWithin
(
target
start
end
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
target
start
end
"
TypedArrayCopyWithin
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
obj
=
this
;
var
len
=
TypedArrayLength
(
obj
)
;
assert
(
0
<
=
len
&
&
len
<
=
0x7FFFFFFF
"
assumed
by
some
of
the
math
below
see
also
the
other
assertions
"
)
;
var
relativeTarget
=
ToInteger
(
target
)
;
var
to
=
relativeTarget
<
0
?
std_Math_max
(
len
+
relativeTarget
0
)
:
std_Math_min
(
relativeTarget
len
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
from
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
count
=
std_Math_min
(
final
-
from
len
-
to
)
;
assert
(
0
<
=
to
&
&
to
<
=
0x7FFFFFFF
"
typed
array
|
to
|
index
assumed
int32_t
"
)
;
assert
(
0
<
=
from
&
&
from
<
=
0x7FFFFFFF
"
typed
array
|
from
|
index
assumed
int32_t
"
)
;
assert
(
-
0x7FFFFFFF
-
1
<
=
count
&
&
count
<
=
0x7FFFFFFF
"
typed
array
element
count
assumed
int32_t
"
)
;
if
(
count
>
0
)
MoveTypedArrayElements
(
obj
to
|
0
from
|
0
count
|
0
)
;
return
obj
;
}
function
TypedArrayEntries
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY_AND_VALUE
)
;
}
function
TypedArrayEvery
(
callbackfn
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
every
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
thisArg
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
T
kValue
k
O
)
;
if
(
!
testResult
)
return
false
;
}
return
true
;
}
function
TypedArrayFill
(
value
start
=
0
end
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
value
start
end
"
TypedArrayFill
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
for
(
;
k
<
final
;
k
+
+
)
{
O
[
k
]
=
value
;
}
return
O
;
}
function
TypedArrayFilter
(
callbackfn
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
filter
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
thisArg
;
var
defaultConstructor
=
_ConstructorForTypedArray
(
O
)
;
var
C
=
SpeciesConstructor
(
O
defaultConstructor
)
;
var
kept
=
new
List
(
)
;
var
captured
=
0
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
selected
=
ToBoolean
(
callContentFunction
(
callbackfn
T
kValue
k
O
)
)
;
if
(
selected
)
{
callFunction
(
std_Array_push
kept
kValue
)
;
captured
+
+
;
}
}
var
A
=
new
C
(
captured
)
;
for
(
var
n
=
0
;
n
<
captured
;
n
+
+
)
{
A
[
n
]
=
kept
[
n
]
;
}
return
A
;
}
function
TypedArrayFind
(
predicate
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
find
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
T
=
thisArg
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
if
(
callContentFunction
(
predicate
T
kValue
k
O
)
)
return
kValue
;
}
return
undefined
;
}
function
TypedArrayFindIndex
(
predicate
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
findIndex
"
)
;
if
(
!
IsCallable
(
predicate
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
predicate
)
)
;
var
T
=
thisArg
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
if
(
callContentFunction
(
predicate
T
O
[
k
]
k
O
)
)
return
k
;
}
return
-
1
;
}
function
TypedArrayForEach
(
callbackfn
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
'
TypedArray
.
prototype
.
forEach
'
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
thisArg
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
callContentFunction
(
callbackfn
T
O
[
k
]
k
O
)
;
}
return
undefined
;
}
function
TypedArrayIndexOf
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
ToInteger
(
fromIndex
)
+
0
;
if
(
n
>
=
len
)
return
-
1
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
for
(
;
k
<
len
;
k
+
+
)
{
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayJoin
(
separator
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
separator
"
TypedArrayJoin
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
sep
=
separator
=
=
=
undefined
?
"
"
:
ToString
(
separator
)
;
if
(
len
=
=
=
0
)
return
"
"
;
var
element0
=
O
[
0
]
;
var
R
=
ToString
(
element0
)
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
S
=
R
+
sep
;
var
element
=
O
[
k
]
;
var
next
=
ToString
(
element
)
;
R
=
S
+
next
;
}
return
R
;
}
function
TypedArrayKeys
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_KEY
)
;
}
function
TypedArrayLastIndexOf
(
searchElement
fromIndex
=
undefined
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayLastIndexOf
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
-
1
;
var
n
=
fromIndex
=
=
=
undefined
?
len
-
1
:
ToInteger
(
fromIndex
)
+
0
;
var
k
=
n
>
=
0
?
std_Math_min
(
n
len
-
1
)
:
len
+
n
;
for
(
;
k
>
=
0
;
k
-
-
)
{
if
(
O
[
k
]
=
=
=
searchElement
)
return
k
;
}
return
-
1
;
}
function
TypedArrayMap
(
callbackfn
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
'
%
TypedArray
%
.
prototype
.
map
'
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
thisArg
;
var
defaultConstructor
=
_ConstructorForTypedArray
(
O
)
;
var
C
=
SpeciesConstructor
(
O
defaultConstructor
)
;
var
A
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
mappedValue
=
callContentFunction
(
callbackfn
T
O
[
k
]
k
O
)
;
A
[
k
]
=
mappedValue
;
}
return
A
;
}
function
TypedArrayReduce
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduce
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
0
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
+
+
]
;
for
(
;
k
<
len
;
k
+
+
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReduceRight
(
callbackfn
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
reduceRight
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
ThrowTypeError
(
JSMSG_EMPTY_ARRAY_REDUCE
)
;
var
k
=
len
-
1
;
var
accumulator
=
arguments
.
length
>
1
?
arguments
[
1
]
:
O
[
k
-
-
]
;
for
(
;
k
>
=
0
;
k
-
-
)
{
accumulator
=
callContentFunction
(
callbackfn
undefined
accumulator
O
[
k
]
k
O
)
;
}
return
accumulator
;
}
function
TypedArrayReverse
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
"
TypedArrayReverse
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
var
middle
=
std_Math_floor
(
len
/
2
)
;
for
(
var
lower
=
0
;
lower
!
=
=
middle
;
lower
+
+
)
{
var
upper
=
len
-
lower
-
1
;
var
lowerValue
=
O
[
lower
]
;
var
upperValue
=
O
[
upper
]
;
O
[
lower
]
=
upperValue
;
O
[
upper
]
=
lowerValue
;
}
return
O
;
}
function
SetFromNonTypedArray
(
target
array
targetOffset
targetLength
targetBuffer
)
{
assert
(
!
IsPossiblyWrappedTypedArray
(
array
)
"
typed
arrays
must
be
passed
to
SetFromTypedArray
"
)
;
var
src
=
ToObject
(
array
)
;
var
srcLength
=
ToLength
(
src
.
length
)
;
var
limitOffset
=
targetOffset
+
srcLength
;
if
(
limitOffset
>
targetLength
)
ThrowRangeError
(
JSMSG_BAD_INDEX
)
;
var
k
=
0
;
var
isShared
=
targetBuffer
!
=
=
null
&
&
IsSharedArrayBuffer
(
targetBuffer
)
;
while
(
targetOffset
<
limitOffset
)
{
var
kNumber
=
ToNumber
(
src
[
k
]
)
;
if
(
!
isShared
)
{
if
(
targetBuffer
=
=
=
null
)
{
targetBuffer
=
ViewedArrayBufferIfReified
(
target
)
;
}
if
(
IsDetachedBuffer
(
targetBuffer
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
target
[
targetOffset
]
=
kNumber
;
k
+
+
;
targetOffset
+
+
;
}
return
undefined
;
}
function
SetFromTypedArray
(
target
typedArray
targetOffset
targetLength
)
{
assert
(
IsPossiblyWrappedTypedArray
(
typedArray
)
"
only
typed
arrays
may
be
passed
to
this
method
"
)
;
var
res
=
SetFromTypedArrayApproach
(
target
typedArray
targetOffset
targetLength
|
0
)
;
assert
(
res
=
=
=
JS_SETTYPEDARRAY_SAME_TYPE
|
|
res
=
=
=
JS_SETTYPEDARRAY_OVERLAPPING
|
|
res
=
=
=
JS_SETTYPEDARRAY_DISJOINT
"
intrinsic
didn
'
t
return
one
of
its
enumerated
return
values
"
)
;
if
(
res
=
=
JS_SETTYPEDARRAY_SAME_TYPE
)
return
undefined
;
if
(
res
=
=
=
JS_SETTYPEDARRAY_DISJOINT
)
{
SetDisjointTypedElements
(
target
targetOffset
|
0
typedArray
)
;
return
undefined
;
}
SetOverlappingTypedElements
(
target
targetOffset
|
0
typedArray
)
;
return
undefined
;
}
function
TypedArraySet
(
overloaded
offset
=
0
)
{
var
target
=
this
;
if
(
!
IsObject
(
target
)
|
|
!
IsTypedArray
(
target
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
target
overloaded
offset
"
TypedArraySet
"
)
;
}
var
targetOffset
=
ToInteger
(
offset
)
;
if
(
targetOffset
<
0
)
ThrowRangeError
(
JSMSG_TYPED_ARRAY_NEGATIVE_ARG
"
2
"
)
;
var
targetBuffer
=
GetAttachedArrayBuffer
(
target
)
;
var
targetLength
=
TypedArrayLength
(
target
)
;
if
(
IsPossiblyWrappedTypedArray
(
overloaded
)
)
return
SetFromTypedArray
(
target
overloaded
targetOffset
targetLength
)
;
return
SetFromNonTypedArray
(
target
overloaded
targetOffset
targetLength
targetBuffer
)
;
}
function
TypedArraySlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsTypedArray
(
O
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
O
start
end
"
TypedArraySlice
"
)
;
}
GetAttachedArrayBuffer
(
O
)
;
var
len
=
TypedArrayLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
k
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
count
=
std_Math_max
(
final
-
k
0
)
;
var
defaultConstructor
=
_ConstructorForTypedArray
(
O
)
;
var
C
=
SpeciesConstructor
(
O
defaultConstructor
)
;
var
A
=
new
C
(
count
)
;
var
n
=
0
;
while
(
k
<
final
)
{
A
[
n
]
=
O
[
k
]
;
k
+
+
;
n
+
+
;
}
return
A
;
}
function
TypedArraySome
(
callbackfn
thisArg
=
undefined
)
{
var
O
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
O
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
O
O
"
TypedArrayLength
"
)
;
if
(
arguments
.
length
=
=
=
0
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
"
%
TypedArray
%
.
prototype
.
some
"
)
;
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
T
=
thisArg
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
O
[
k
]
;
var
testResult
=
callContentFunction
(
callbackfn
T
kValue
k
O
)
;
if
(
testResult
)
return
true
;
}
return
false
;
}
function
TypedArrayCompare
(
x
y
)
{
assert
(
typeof
x
=
=
=
"
number
"
&
&
typeof
y
=
=
=
"
number
"
"
x
and
y
are
not
numbers
.
"
)
;
var
diff
=
x
-
y
;
if
(
diff
)
return
diff
;
if
(
x
=
=
=
0
&
&
y
=
=
=
0
)
return
(
1
/
x
>
0
?
1
:
0
)
-
(
1
/
y
>
0
?
1
:
0
)
;
if
(
Number_isNaN
(
x
)
&
&
Number_isNaN
(
y
)
)
return
0
;
if
(
Number_isNaN
(
x
)
|
|
Number_isNaN
(
y
)
)
return
Number_isNaN
(
x
)
?
1
:
-
1
;
}
function
TypedArraySort
(
comparefn
)
{
var
obj
=
this
;
var
isTypedArray
=
IsObject
(
obj
)
&
&
IsTypedArray
(
obj
)
;
var
buffer
;
if
(
isTypedArray
)
{
buffer
=
GetAttachedArrayBuffer
(
obj
)
;
}
else
{
buffer
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
obj
"
GetAttachedArrayBuffer
"
)
;
}
var
len
;
if
(
isTypedArray
)
{
len
=
TypedArrayLength
(
obj
)
;
}
else
{
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
obj
obj
"
TypedArrayLength
"
)
;
}
if
(
comparefn
=
=
=
undefined
)
{
comparefn
=
TypedArrayCompare
;
if
(
IsUint8TypedArray
(
obj
)
)
{
return
CountingSort
(
obj
len
false
)
;
}
else
if
(
IsInt8TypedArray
(
obj
)
)
{
return
CountingSort
(
obj
len
true
)
;
}
else
if
(
IsUint16TypedArray
(
obj
)
)
{
return
RadixSort
(
obj
len
buffer
2
false
false
comparefn
)
;
}
else
if
(
IsInt16TypedArray
(
obj
)
)
{
return
RadixSort
(
obj
len
buffer
2
true
false
comparefn
)
;
}
else
if
(
IsUint32TypedArray
(
obj
)
)
{
return
RadixSort
(
obj
len
buffer
4
false
false
comparefn
)
;
}
else
if
(
IsInt32TypedArray
(
obj
)
)
{
return
RadixSort
(
obj
len
buffer
4
true
false
comparefn
)
;
}
else
if
(
IsFloat32TypedArray
(
obj
)
)
{
return
RadixSort
(
obj
len
buffer
4
true
true
comparefn
)
;
}
}
var
wrappedCompareFn
=
comparefn
;
comparefn
=
function
(
x
y
)
{
var
v
=
wrappedCompareFn
(
x
y
)
;
var
bufferDetached
;
if
(
isTypedArray
)
{
bufferDetached
=
IsDetachedBuffer
(
buffer
)
;
}
else
{
bufferDetached
=
callFunction
(
CallTypedArrayMethodIfWrapped
this
buffer
"
IsDetachedBuffer
"
)
;
}
if
(
bufferDetached
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
v
;
}
return
QuickSort
(
obj
len
comparefn
)
;
}
function
TypedArrayToLocaleString
(
locales
=
undefined
options
=
undefined
)
{
var
array
=
this
;
var
isTypedArray
=
IsTypedArrayEnsuringArrayBuffer
(
array
)
;
var
len
;
if
(
isTypedArray
)
len
=
TypedArrayLength
(
array
)
;
else
len
=
callFunction
(
CallTypedArrayMethodIfWrapped
array
array
"
TypedArrayLength
"
)
;
if
(
len
=
=
=
0
)
return
"
"
;
var
firstElement
=
array
[
0
]
;
#
if
EXPOSE_INTL_API
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
locales
options
)
)
;
#
else
var
R
=
ToString
(
callContentFunction
(
firstElement
.
toLocaleString
firstElement
)
)
;
#
endif
var
separator
=
"
"
;
for
(
var
k
=
1
;
k
<
len
;
k
+
+
)
{
var
S
=
R
+
separator
;
var
nextElement
=
array
[
k
]
;
#
if
EXPOSE_INTL_API
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
locales
options
)
)
;
#
else
R
=
ToString
(
callContentFunction
(
nextElement
.
toLocaleString
nextElement
)
)
;
#
endif
R
=
S
+
R
;
}
return
R
;
}
function
TypedArraySubarray
(
begin
end
)
{
var
obj
=
this
;
if
(
!
IsObject
(
obj
)
|
|
!
IsTypedArray
(
obj
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
begin
end
"
TypedArraySubarray
"
)
;
}
var
buffer
=
TypedArrayBuffer
(
obj
)
;
var
srcLength
=
TypedArrayLength
(
obj
)
;
var
relativeBegin
=
ToInteger
(
begin
)
;
var
beginIndex
=
relativeBegin
<
0
?
std_Math_max
(
srcLength
+
relativeBegin
0
)
:
std_Math_min
(
relativeBegin
srcLength
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
srcLength
:
ToInteger
(
end
)
;
var
endIndex
=
relativeEnd
<
0
?
std_Math_max
(
srcLength
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
srcLength
)
;
var
newLength
=
std_Math_max
(
endIndex
-
beginIndex
0
)
;
var
elementShift
=
TypedArrayElementShift
(
obj
)
;
var
srcByteOffset
=
TypedArrayByteOffset
(
obj
)
;
var
beginByteOffset
=
srcByteOffset
+
(
beginIndex
<
<
elementShift
)
;
var
defaultConstructor
=
_ConstructorForTypedArray
(
obj
)
;
var
constructor
=
SpeciesConstructor
(
obj
defaultConstructor
)
;
return
new
constructor
(
buffer
beginByteOffset
newLength
)
;
}
function
TypedArrayValues
(
)
{
var
O
=
this
;
IsTypedArrayEnsuringArrayBuffer
(
O
)
;
return
CreateArrayIterator
(
O
ITEM_KIND_VALUE
)
;
}
_SetCanonicalName
(
TypedArrayValues
"
values
"
)
;
function
TypedArrayIncludes
(
searchElement
fromIndex
=
0
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsTypedArray
(
this
)
)
{
return
callFunction
(
CallTypedArrayMethodIfWrapped
this
searchElement
fromIndex
"
TypedArrayIncludes
"
)
;
}
GetAttachedArrayBuffer
(
this
)
;
var
O
=
this
;
var
len
=
TypedArrayLength
(
O
)
;
if
(
len
=
=
=
0
)
return
false
;
var
n
=
ToInteger
(
fromIndex
)
;
var
k
;
if
(
n
>
=
0
)
{
k
=
n
;
}
else
{
k
=
len
+
n
;
if
(
k
<
0
)
k
=
0
;
}
while
(
k
<
len
)
{
if
(
SameValueZero
(
searchElement
O
[
k
]
)
)
return
true
;
k
+
+
;
}
return
false
;
}
function
TypedArrayStaticFrom
(
source
mapfn
=
undefined
thisArg
=
undefined
)
{
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
DecompileArg
(
1
C
)
)
;
var
f
=
mapfn
;
if
(
f
!
=
=
undefined
&
&
!
IsCallable
(
f
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
1
f
)
)
;
return
TypedArrayFrom
(
C
undefined
source
f
thisArg
)
;
}
function
TypedArrayFrom
(
constructor
target
items
mapfn
thisArg
)
{
var
C
=
constructor
;
assert
(
C
=
=
=
undefined
|
|
target
=
=
=
undefined
"
Neither
of
'
constructor
'
and
'
target
'
is
undefined
"
)
;
assert
(
IsConstructor
(
C
)
|
|
C
=
=
=
undefined
"
'
constructor
'
is
neither
an
constructor
nor
undefined
"
)
;
assert
(
target
=
=
=
undefined
|
|
IsTypedArray
(
target
)
"
'
target
'
is
neither
a
typed
array
nor
undefined
"
)
;
assert
(
IsCallable
(
mapfn
)
|
|
mapfn
=
=
=
undefined
"
'
target
'
is
neither
a
function
nor
undefined
"
)
;
var
mapping
=
mapfn
!
=
=
undefined
;
var
T
=
thisArg
;
var
usingIterator
=
GetMethod
(
items
std_iterator
)
;
if
(
usingIterator
!
=
=
undefined
)
{
var
iterator
=
GetIterator
(
items
usingIterator
)
;
var
values
=
new
List
(
)
;
while
(
true
)
{
var
next
=
callContentFunction
(
iterator
.
next
iterator
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_NEXT_RETURNED_PRIMITIVE
)
;
if
(
next
.
done
)
break
;
callFunction
(
std_Array_push
values
next
.
value
)
;
}
var
len
=
values
.
length
;
var
targetObj
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
values
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
var
arrayLike
=
ToObject
(
items
)
;
var
len
=
ToLength
(
arrayLike
.
length
)
;
var
targetObj
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
{
var
kValue
=
arrayLike
[
k
]
;
var
mappedValue
=
mapping
?
callContentFunction
(
mapfn
T
kValue
k
)
:
kValue
;
targetObj
[
k
]
=
mappedValue
;
}
return
targetObj
;
}
function
TypedArrayStaticOf
(
)
{
var
len
=
arguments
.
length
;
var
items
=
arguments
;
var
C
=
this
;
if
(
!
IsConstructor
(
C
)
)
ThrowTypeError
(
JSMSG_NOT_CONSTRUCTOR
typeof
C
)
;
var
newObj
=
new
C
(
len
)
;
for
(
var
k
=
0
;
k
<
len
;
k
+
+
)
newObj
[
k
]
=
items
[
k
]
return
newObj
;
}
function
TypedArraySpecies
(
)
{
return
this
;
}
function
TypedArrayToStringTag
(
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsTypedArray
(
O
)
)
return
undefined
;
return
_NameForTypedArray
(
O
)
;
}
_SetCanonicalName
(
TypedArrayToStringTag
"
get
[
Symbol
.
toStringTag
]
"
)
;
function
ArrayBufferSlice
(
start
end
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsArrayBuffer
(
O
)
)
{
return
callFunction
(
CallArrayBufferMethodIfWrapped
O
start
end
"
ArrayBufferSlice
"
)
;
}
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
var
len
=
ArrayBufferByteLength
(
O
)
;
var
relativeStart
=
ToInteger
(
start
)
;
var
first
=
relativeStart
<
0
?
std_Math_max
(
len
+
relativeStart
0
)
:
std_Math_min
(
relativeStart
len
)
;
var
relativeEnd
=
end
=
=
=
undefined
?
len
:
ToInteger
(
end
)
;
var
final
=
relativeEnd
<
0
?
std_Math_max
(
len
+
relativeEnd
0
)
:
std_Math_min
(
relativeEnd
len
)
;
var
newLen
=
std_Math_max
(
final
-
first
0
)
;
var
ctor
=
SpeciesConstructor
(
O
GetBuiltinConstructor
(
"
ArrayBuffer
"
)
)
;
var
new_
=
new
ctor
(
newLen
)
;
var
isWrapped
=
false
;
if
(
IsArrayBuffer
(
new_
)
)
{
if
(
IsDetachedBuffer
(
new_
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
else
{
if
(
!
IsWrappedArrayBuffer
(
new_
)
)
ThrowTypeError
(
JSMSG_NON_ARRAY_BUFFER_RETURNED
)
;
isWrapped
=
true
;
if
(
callFunction
(
CallArrayBufferMethodIfWrapped
new_
"
IsDetachedBufferThis
"
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
if
(
new_
=
=
=
O
)
ThrowTypeError
(
JSMSG_SAME_ARRAY_BUFFER_RETURNED
)
;
var
actualLen
=
PossiblyWrappedArrayBufferByteLength
(
new_
)
;
if
(
actualLen
<
newLen
)
ThrowTypeError
(
JSMSG_SHORT_ARRAY_BUFFER_RETURNED
newLen
actualLen
)
;
if
(
IsDetachedBuffer
(
O
)
)
ThrowTypeError
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
ArrayBufferCopyData
(
new_
O
first
|
0
newLen
|
0
isWrapped
)
;
return
new_
;
}
function
IsDetachedBufferThis
(
)
{
return
IsDetachedBuffer
(
this
)
;
}
function
ArrayBufferStaticSlice
(
buf
start
end
)
{
if
(
arguments
.
length
<
1
)
ThrowTypeError
(
JSMSG_MISSING_FUN_ARG
0
'
ArrayBuffer
.
slice
'
)
;
return
callFunction
(
ArrayBufferSlice
buf
start
end
)
;
}
function
ArrayBufferSpecies
(
)
{
return
this
;
}
