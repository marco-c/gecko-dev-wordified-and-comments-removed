function
StringProtoHasNoMatch
(
)
{
var
ObjectProto
=
GetBuiltinPrototype
(
"
Object
"
)
;
var
StringProto
=
GetBuiltinPrototype
(
"
String
"
)
;
if
(
!
ObjectHasPrototype
(
StringProto
ObjectProto
)
)
{
return
false
;
}
return
!
(
GetBuiltinSymbol
(
"
match
"
)
in
StringProto
)
;
}
function
IsStringMatchOptimizable
(
)
{
var
RegExpProto
=
GetBuiltinPrototype
(
"
RegExp
"
)
;
return
(
RegExpPrototypeOptimizable
(
RegExpProto
)
&
&
RegExpProto
.
exec
=
=
=
RegExp_prototype_Exec
&
&
RegExpProto
[
GetBuiltinSymbol
(
"
match
"
)
]
=
=
=
RegExpMatch
)
;
}
function
ThrowIncompatibleMethod
(
name
thisv
)
{
ThrowTypeError
(
JSMSG_INCOMPATIBLE_PROTO
"
String
"
name
ToString
(
thisv
)
)
;
}
function
String_match
(
regexp
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
match
"
this
)
;
}
var
isPatternString
=
(
typeof
regexp
=
=
=
"
string
"
)
;
if
(
!
(
isPatternString
&
&
StringProtoHasNoMatch
(
)
)
&
&
regexp
!
=
=
undefined
&
&
regexp
!
=
=
null
)
{
var
matcher
=
GetMethod
(
regexp
GetBuiltinSymbol
(
"
match
"
)
)
;
if
(
matcher
!
=
=
undefined
)
{
return
callContentFunction
(
matcher
regexp
this
)
;
}
}
var
S
=
ToString
(
this
)
;
if
(
isPatternString
&
&
IsStringMatchOptimizable
(
)
)
{
var
flatResult
=
FlatStringMatch
(
S
regexp
)
;
if
(
flatResult
!
=
=
undefined
)
{
return
flatResult
;
}
}
var
rx
=
RegExpCreate
(
regexp
)
;
if
(
IsStringMatchOptimizable
(
)
)
{
return
RegExpMatcher
(
rx
S
0
)
;
}
return
callContentFunction
(
GetMethod
(
rx
GetBuiltinSymbol
(
"
match
"
)
)
rx
S
)
;
}
function
String_matchAll
(
regexp
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
matchAll
"
this
)
;
}
if
(
regexp
!
=
=
undefined
&
&
regexp
!
=
=
null
)
{
if
(
IsRegExp
(
regexp
)
)
{
var
flags
=
regexp
.
flags
;
if
(
flags
=
=
=
undefined
|
|
flags
=
=
=
null
)
{
ThrowTypeError
(
JSMSG_FLAGS_UNDEFINED_OR_NULL
)
;
}
if
(
!
callFunction
(
std_String_includes
ToString
(
flags
)
"
g
"
)
)
{
ThrowTypeError
(
JSMSG_REQUIRES_GLOBAL_REGEXP
"
matchAll
"
)
;
}
}
var
matcher
=
GetMethod
(
regexp
GetBuiltinSymbol
(
"
matchAll
"
)
)
;
if
(
matcher
!
=
=
undefined
)
{
return
callContentFunction
(
matcher
regexp
this
)
;
}
}
var
string
=
ToString
(
this
)
;
var
rx
=
RegExpCreate
(
regexp
"
g
"
)
;
return
callContentFunction
(
GetMethod
(
rx
GetBuiltinSymbol
(
"
matchAll
"
)
)
rx
string
)
;
}
function
String_pad
(
maxLength
fillString
padEnd
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
padEnd
?
"
padEnd
"
:
"
padStart
"
this
)
;
}
let
str
=
ToString
(
this
)
;
let
intMaxLength
=
ToLength
(
maxLength
)
;
let
strLen
=
str
.
length
;
if
(
intMaxLength
<
=
strLen
)
{
return
str
;
}
assert
(
fillString
!
=
=
undefined
"
never
called
when
fillString
is
undefined
"
)
;
let
filler
=
ToString
(
fillString
)
;
if
(
filler
=
=
=
"
"
)
{
return
str
;
}
if
(
intMaxLength
>
MAX_STRING_LENGTH
)
{
ThrowRangeError
(
JSMSG_RESULTING_STRING_TOO_LARGE
)
;
}
let
fillLen
=
intMaxLength
-
strLen
;
let
truncatedStringFiller
=
callFunction
(
String_repeat
filler
(
fillLen
/
filler
.
length
)
|
0
)
;
truncatedStringFiller
+
=
Substring
(
filler
0
fillLen
%
filler
.
length
)
;
if
(
padEnd
=
=
=
true
)
{
return
str
+
truncatedStringFiller
;
}
return
truncatedStringFiller
+
str
;
}
function
String_pad_start
(
maxLength
fillString
=
"
"
)
{
return
callFunction
(
String_pad
this
maxLength
fillString
false
)
;
}
function
String_pad_end
(
maxLength
fillString
=
"
"
)
{
return
callFunction
(
String_pad
this
maxLength
fillString
true
)
;
}
function
StringProtoHasNoReplace
(
)
{
var
ObjectProto
=
GetBuiltinPrototype
(
"
Object
"
)
;
var
StringProto
=
GetBuiltinPrototype
(
"
String
"
)
;
if
(
!
ObjectHasPrototype
(
StringProto
ObjectProto
)
)
{
return
false
;
}
return
!
(
GetBuiltinSymbol
(
"
replace
"
)
in
StringProto
)
;
}
function
Substring
(
str
from
length
)
{
assert
(
typeof
str
=
=
=
"
string
"
"
|
str
|
should
be
a
string
"
)
;
assert
(
from
|
0
=
=
=
from
"
coercing
|
from
|
into
int32
should
not
change
the
value
"
)
;
assert
(
length
|
0
=
=
=
length
"
coercing
|
length
|
into
int32
should
not
change
the
value
"
)
;
return
SubstringKernel
(
str
from
|
0
length
|
0
)
;
}
function
String_replace
(
searchValue
replaceValue
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
replace
"
this
)
;
}
if
(
!
(
typeof
searchValue
=
=
=
"
string
"
&
&
StringProtoHasNoReplace
(
)
)
&
&
searchValue
!
=
=
undefined
&
&
searchValue
!
=
=
null
)
{
var
replacer
=
GetMethod
(
searchValue
GetBuiltinSymbol
(
"
replace
"
)
)
;
if
(
replacer
!
=
=
undefined
)
{
return
callContentFunction
(
replacer
searchValue
this
replaceValue
)
;
}
}
var
string
=
ToString
(
this
)
;
var
searchString
=
ToString
(
searchValue
)
;
if
(
typeof
replaceValue
=
=
=
"
string
"
)
{
return
StringReplaceString
(
string
searchString
replaceValue
)
;
}
if
(
!
IsCallable
(
replaceValue
)
)
{
return
StringReplaceString
(
string
searchString
ToString
(
replaceValue
)
)
;
}
var
pos
=
callFunction
(
std_String_indexOf
string
searchString
)
;
if
(
pos
=
=
=
-
1
)
{
return
string
;
}
var
replStr
=
ToString
(
callContentFunction
(
replaceValue
undefined
searchString
pos
string
)
)
;
var
tailPos
=
pos
+
searchString
.
length
;
var
newString
;
if
(
pos
=
=
=
0
)
{
newString
=
"
"
;
}
else
{
newString
=
Substring
(
string
0
pos
)
;
}
newString
+
=
replStr
;
var
stringLength
=
string
.
length
;
if
(
tailPos
<
stringLength
)
{
newString
+
=
Substring
(
string
tailPos
stringLength
-
tailPos
)
;
}
return
newString
;
}
function
String_replaceAll
(
searchValue
replaceValue
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
replaceAll
"
this
)
;
}
if
(
searchValue
!
=
=
undefined
&
&
searchValue
!
=
=
null
)
{
if
(
IsRegExp
(
searchValue
)
)
{
var
flags
=
searchValue
.
flags
;
if
(
flags
=
=
=
undefined
|
|
flags
=
=
=
null
)
{
ThrowTypeError
(
JSMSG_FLAGS_UNDEFINED_OR_NULL
)
;
}
if
(
!
callFunction
(
std_String_includes
ToString
(
flags
)
"
g
"
)
)
{
ThrowTypeError
(
JSMSG_REQUIRES_GLOBAL_REGEXP
"
replaceAll
"
)
;
}
}
var
replacer
=
GetMethod
(
searchValue
GetBuiltinSymbol
(
"
replace
"
)
)
;
if
(
replacer
!
=
=
undefined
)
{
return
callContentFunction
(
replacer
searchValue
this
replaceValue
)
;
}
}
var
string
=
ToString
(
this
)
;
var
searchString
=
ToString
(
searchValue
)
;
if
(
!
IsCallable
(
replaceValue
)
)
{
return
StringReplaceAllString
(
string
searchString
ToString
(
replaceValue
)
)
;
}
var
searchLength
=
searchString
.
length
;
var
advanceBy
=
std_Math_max
(
1
searchLength
)
;
var
endOfLastMatch
=
0
;
var
result
=
"
"
;
var
position
=
0
;
while
(
true
)
{
var
nextPosition
=
callFunction
(
std_String_indexOf
string
searchString
position
)
;
if
(
nextPosition
<
position
)
{
break
;
}
position
=
nextPosition
;
var
replacement
=
ToString
(
callContentFunction
(
replaceValue
undefined
searchString
position
string
)
)
;
var
stringSlice
=
Substring
(
string
endOfLastMatch
position
-
endOfLastMatch
)
;
result
+
=
stringSlice
+
replacement
;
endOfLastMatch
=
position
+
searchLength
;
position
+
=
advanceBy
;
}
if
(
endOfLastMatch
<
string
.
length
)
{
result
+
=
Substring
(
string
endOfLastMatch
string
.
length
-
endOfLastMatch
)
;
}
return
result
;
}
function
StringProtoHasNoSearch
(
)
{
var
ObjectProto
=
GetBuiltinPrototype
(
"
Object
"
)
;
var
StringProto
=
GetBuiltinPrototype
(
"
String
"
)
;
if
(
!
ObjectHasPrototype
(
StringProto
ObjectProto
)
)
{
return
false
;
}
return
!
(
GetBuiltinSymbol
(
"
search
"
)
in
StringProto
)
;
}
function
IsStringSearchOptimizable
(
)
{
var
RegExpProto
=
GetBuiltinPrototype
(
"
RegExp
"
)
;
return
(
RegExpPrototypeOptimizable
(
RegExpProto
)
&
&
RegExpProto
.
exec
=
=
=
RegExp_prototype_Exec
&
&
RegExpProto
[
GetBuiltinSymbol
(
"
search
"
)
]
=
=
=
RegExpSearch
)
;
}
function
String_search
(
regexp
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
search
"
this
)
;
}
var
isPatternString
=
(
typeof
regexp
=
=
=
"
string
"
)
;
if
(
!
(
isPatternString
&
&
StringProtoHasNoSearch
(
)
)
&
&
regexp
!
=
=
undefined
&
&
regexp
!
=
=
null
)
{
var
searcher
=
GetMethod
(
regexp
GetBuiltinSymbol
(
"
search
"
)
)
;
if
(
searcher
!
=
=
undefined
)
{
return
callContentFunction
(
searcher
regexp
this
)
;
}
}
var
string
=
ToString
(
this
)
;
if
(
isPatternString
&
&
IsStringSearchOptimizable
(
)
)
{
var
flatResult
=
FlatStringSearch
(
string
regexp
)
;
if
(
flatResult
!
=
=
-
2
)
{
return
flatResult
;
}
}
var
rx
=
RegExpCreate
(
regexp
)
;
return
callContentFunction
(
GetMethod
(
rx
GetBuiltinSymbol
(
"
search
"
)
)
rx
string
)
;
}
function
StringProtoHasNoSplit
(
)
{
var
ObjectProto
=
GetBuiltinPrototype
(
"
Object
"
)
;
var
StringProto
=
GetBuiltinPrototype
(
"
String
"
)
;
if
(
!
ObjectHasPrototype
(
StringProto
ObjectProto
)
)
{
return
false
;
}
return
!
(
GetBuiltinSymbol
(
"
split
"
)
in
StringProto
)
;
}
function
String_split
(
separator
limit
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
split
"
this
)
;
}
if
(
typeof
this
=
=
=
"
string
"
)
{
if
(
StringProtoHasNoSplit
(
)
)
{
if
(
typeof
separator
=
=
=
"
string
"
)
{
if
(
limit
=
=
=
undefined
)
{
return
StringSplitString
(
this
separator
)
;
}
}
}
}
if
(
!
(
typeof
separator
=
=
"
string
"
&
&
StringProtoHasNoSplit
(
)
)
&
&
separator
!
=
=
undefined
&
&
separator
!
=
=
null
)
{
var
splitter
=
GetMethod
(
separator
GetBuiltinSymbol
(
"
split
"
)
)
;
if
(
splitter
!
=
=
undefined
)
{
return
callContentFunction
(
splitter
separator
this
limit
)
;
}
}
var
S
=
ToString
(
this
)
;
var
R
;
if
(
limit
!
=
=
undefined
)
{
var
lim
=
limit
>
>
>
0
;
R
=
ToString
(
separator
)
;
if
(
lim
=
=
=
0
)
{
return
[
]
;
}
if
(
separator
=
=
=
undefined
)
{
return
[
S
]
;
}
return
StringSplitStringLimit
(
S
R
lim
)
;
}
R
=
ToString
(
separator
)
;
if
(
separator
=
=
=
undefined
)
{
return
[
S
]
;
}
return
StringSplitString
(
S
R
)
;
}
function
String_substring
(
start
end
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
substring
"
this
)
;
}
var
str
=
ToString
(
this
)
;
var
len
=
str
.
length
;
var
intStart
=
ToInteger
(
start
)
;
var
intEnd
=
(
end
=
=
=
undefined
)
?
len
:
ToInteger
(
end
)
;
var
finalStart
=
std_Math_min
(
std_Math_max
(
intStart
0
)
len
)
;
var
finalEnd
=
std_Math_min
(
std_Math_max
(
intEnd
0
)
len
)
;
var
from
to
;
if
(
finalStart
<
finalEnd
)
{
from
=
finalStart
;
to
=
finalEnd
;
}
else
{
from
=
finalEnd
;
to
=
finalStart
;
}
return
SubstringKernel
(
str
from
|
0
(
to
-
from
)
|
0
)
;
}
SetIsInlinableLargeFunction
(
String_substring
)
;
function
String_substr
(
start
length
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
substr
"
this
)
;
}
var
str
=
ToString
(
this
)
;
var
intStart
=
ToInteger
(
start
)
;
var
size
=
str
.
length
;
var
end
=
(
length
=
=
=
undefined
)
?
size
:
ToInteger
(
length
)
;
if
(
intStart
<
0
)
{
intStart
=
std_Math_max
(
intStart
+
size
0
)
;
}
var
resultLength
=
std_Math_min
(
std_Math_max
(
end
0
)
size
-
intStart
)
;
if
(
resultLength
<
=
0
)
{
return
"
"
;
}
return
SubstringKernel
(
str
intStart
|
0
resultLength
|
0
)
;
}
SetIsInlinableLargeFunction
(
String_substr
)
;
function
String_concat
(
arg1
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
concat
"
this
)
;
}
var
str
=
ToString
(
this
)
;
if
(
arguments
.
length
=
=
=
0
)
{
return
str
;
}
if
(
arguments
.
length
=
=
=
1
)
{
return
str
+
ToString
(
arguments
[
0
]
)
;
}
if
(
arguments
.
length
=
=
=
2
)
{
return
str
+
ToString
(
arguments
[
0
]
)
+
ToString
(
arguments
[
1
]
)
;
}
var
result
=
str
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
nextString
=
ToString
(
arguments
[
i
]
)
;
result
+
=
nextString
;
}
return
result
;
}
function
String_slice
(
start
end
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
slice
"
this
)
;
}
var
str
=
ToString
(
this
)
;
var
len
=
str
.
length
;
var
intStart
=
ToInteger
(
start
)
;
var
intEnd
=
(
end
=
=
=
undefined
)
?
len
:
ToInteger
(
end
)
;
var
from
=
(
intStart
<
0
)
?
std_Math_max
(
len
+
intStart
0
)
:
std_Math_min
(
intStart
len
)
;
var
to
=
(
intEnd
<
0
)
?
std_Math_max
(
len
+
intEnd
0
)
:
std_Math_min
(
intEnd
len
)
;
var
span
=
std_Math_max
(
to
-
from
0
)
;
return
SubstringKernel
(
str
from
|
0
span
|
0
)
;
}
SetIsInlinableLargeFunction
(
String_slice
)
;
function
String_codePointAt
(
pos
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
codePointAt
"
this
)
;
}
var
S
=
ToString
(
this
)
;
var
position
=
ToInteger
(
pos
)
;
var
size
=
S
.
length
;
if
(
position
<
0
|
|
position
>
=
size
)
{
return
undefined
;
}
var
first
=
callFunction
(
std_String_charCodeAt
S
position
)
;
if
(
first
<
0xD800
|
|
first
>
0xDBFF
|
|
position
+
1
=
=
=
size
)
{
return
first
;
}
var
second
=
callFunction
(
std_String_charCodeAt
S
position
+
1
)
;
if
(
second
<
0xDC00
|
|
second
>
0xDFFF
)
{
return
first
;
}
return
(
first
-
0xD800
)
*
0x400
+
(
second
-
0xDC00
)
+
0x10000
;
}
function
String_repeat
(
count
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
repeat
"
this
)
;
}
var
S
=
ToString
(
this
)
;
var
n
=
ToInteger
(
count
)
;
if
(
n
<
0
)
{
ThrowRangeError
(
JSMSG_NEGATIVE_REPETITION_COUNT
)
;
}
if
(
!
(
n
*
S
.
length
<
=
MAX_STRING_LENGTH
)
)
{
ThrowRangeError
(
JSMSG_RESULTING_STRING_TOO_LARGE
)
;
}
assert
(
TO_INT32
(
MAX_STRING_LENGTH
+
1
)
=
=
MAX_STRING_LENGTH
+
1
"
MAX_STRING_LENGTH
+
1
must
fit
in
int32
"
)
;
assert
(
(
(
MAX_STRING_LENGTH
+
1
)
&
(
MAX_STRING_LENGTH
+
2
)
)
=
=
=
0
"
MAX_STRING_LENGTH
+
1
can
be
used
as
a
bitmask
"
)
;
n
=
n
&
(
MAX_STRING_LENGTH
+
1
)
;
var
T
=
"
"
;
for
(
;
;
)
{
if
(
n
&
1
)
{
T
+
=
S
;
}
n
>
>
=
1
;
if
(
n
)
{
S
+
=
S
;
}
else
{
break
;
}
}
return
T
;
}
function
String_iterator
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowTypeError
(
JSMSG_INCOMPATIBLE_PROTO2
"
String
"
"
Symbol
.
iterator
"
ToString
(
this
)
)
;
}
var
S
=
ToString
(
this
)
;
var
iterator
=
NewStringIterator
(
)
;
UnsafeSetReservedSlot
(
iterator
ITERATOR_SLOT_TARGET
S
)
;
UnsafeSetReservedSlot
(
iterator
ITERATOR_SLOT_NEXT_INDEX
0
)
;
return
iterator
;
}
function
StringIteratorNext
(
)
{
var
obj
=
this
;
if
(
!
IsObject
(
obj
)
|
|
(
obj
=
GuardToStringIterator
(
obj
)
)
=
=
=
null
)
{
return
callFunction
(
CallStringIteratorMethodIfWrapped
this
"
StringIteratorNext
"
)
;
}
var
S
=
UnsafeGetStringFromReservedSlot
(
obj
ITERATOR_SLOT_TARGET
)
;
var
index
=
UnsafeGetInt32FromReservedSlot
(
obj
ITERATOR_SLOT_NEXT_INDEX
)
;
var
size
=
S
.
length
;
var
result
=
{
value
:
undefined
done
:
false
}
;
if
(
index
>
=
size
)
{
result
.
done
=
true
;
return
result
;
}
var
charCount
=
1
;
var
first
=
callFunction
(
std_String_charCodeAt
S
index
)
;
if
(
first
>
=
0xD800
&
&
first
<
=
0xDBFF
&
&
index
+
1
<
size
)
{
var
second
=
callFunction
(
std_String_charCodeAt
S
index
+
1
)
;
if
(
second
>
=
0xDC00
&
&
second
<
=
0xDFFF
)
{
first
=
(
first
-
0xD800
)
*
0x400
+
(
second
-
0xDC00
)
+
0x10000
;
charCount
=
2
;
}
}
UnsafeSetReservedSlot
(
obj
ITERATOR_SLOT_NEXT_INDEX
index
+
charCount
)
;
result
.
value
=
callFunction
(
std_String_fromCodePoint
null
first
&
0x1fffff
)
;
return
result
;
}
#
if
JS_HAS_INTL_API
var
collatorCache
=
new_Record
(
)
;
function
String_localeCompare
(
that
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
localeCompare
"
this
)
;
}
var
S
=
ToString
(
this
)
;
var
That
=
ToString
(
that
)
;
var
locales
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
options
=
arguments
.
length
>
2
?
arguments
[
2
]
:
undefined
;
var
collator
;
if
(
locales
=
=
=
undefined
&
&
options
=
=
=
undefined
)
{
if
(
!
intl_IsRuntimeDefaultLocale
(
collatorCache
.
runtimeDefaultLocale
)
)
{
collatorCache
.
collator
=
intl_Collator
(
locales
options
)
;
collatorCache
.
runtimeDefaultLocale
=
intl_RuntimeDefaultLocale
(
)
;
}
collator
=
collatorCache
.
collator
;
}
else
{
collator
=
intl_Collator
(
locales
options
)
;
}
return
intl_CompareStrings
(
collator
S
That
)
;
}
function
String_toLocaleLowerCase
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
toLocaleLowerCase
"
this
)
;
}
var
string
=
ToString
(
this
)
;
var
locales
=
arguments
.
length
>
0
?
arguments
[
0
]
:
undefined
;
var
requestedLocale
;
if
(
locales
=
=
=
undefined
)
{
requestedLocale
=
undefined
;
}
else
if
(
typeof
locales
=
=
=
"
string
"
)
{
requestedLocale
=
intl_ValidateAndCanonicalizeLanguageTag
(
locales
false
)
;
}
else
{
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
requestedLocale
=
requestedLocales
.
length
>
0
?
requestedLocales
[
0
]
:
undefined
;
}
if
(
string
.
length
=
=
=
0
)
{
return
"
"
;
}
if
(
requestedLocale
=
=
=
undefined
)
{
requestedLocale
=
DefaultLocale
(
)
;
}
return
intl_toLocaleLowerCase
(
string
requestedLocale
)
;
}
function
String_toLocaleUpperCase
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
toLocaleUpperCase
"
this
)
;
}
var
string
=
ToString
(
this
)
;
var
locales
=
arguments
.
length
>
0
?
arguments
[
0
]
:
undefined
;
var
requestedLocale
;
if
(
locales
=
=
=
undefined
)
{
requestedLocale
=
undefined
;
}
else
if
(
typeof
locales
=
=
=
"
string
"
)
{
requestedLocale
=
intl_ValidateAndCanonicalizeLanguageTag
(
locales
false
)
;
}
else
{
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
requestedLocale
=
requestedLocales
.
length
>
0
?
requestedLocales
[
0
]
:
undefined
;
}
if
(
string
.
length
=
=
=
0
)
{
return
"
"
;
}
if
(
requestedLocale
=
=
=
undefined
)
{
requestedLocale
=
DefaultLocale
(
)
;
}
return
intl_toLocaleUpperCase
(
string
requestedLocale
)
;
}
#
endif
/
/
JS_HAS_INTL_API
function
String_static_raw
(
callSite
)
{
var
cooked
=
ToObject
(
callSite
)
;
var
raw
=
ToObject
(
cooked
.
raw
)
;
var
literalSegments
=
ToLength
(
raw
.
length
)
;
if
(
literalSegments
=
=
=
0
)
{
return
"
"
;
}
if
(
literalSegments
=
=
=
1
)
{
return
ToString
(
raw
[
0
]
)
;
}
var
resultString
=
ToString
(
raw
[
0
]
)
;
for
(
var
nextIndex
=
1
;
nextIndex
<
literalSegments
;
nextIndex
+
+
)
{
if
(
nextIndex
<
arguments
.
length
)
{
resultString
+
=
ToString
(
arguments
[
nextIndex
]
)
;
}
resultString
+
=
ToString
(
raw
[
nextIndex
]
)
;
}
return
resultString
;
}
function
String_at
(
index
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
at
"
this
)
;
}
var
string
=
ToString
(
this
)
;
var
len
=
string
.
length
;
var
relativeIndex
=
ToInteger
(
index
)
;
var
k
;
if
(
relativeIndex
>
=
0
)
{
k
=
relativeIndex
;
}
else
{
k
=
len
+
relativeIndex
;
}
if
(
k
<
0
|
|
k
>
=
len
)
{
return
undefined
;
}
return
string
[
k
]
;
}
function
String_big
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
big
"
this
)
;
}
return
"
<
big
>
"
+
ToString
(
this
)
+
"
<
/
big
>
"
;
}
function
String_blink
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
blink
"
this
)
;
}
return
"
<
blink
>
"
+
ToString
(
this
)
+
"
<
/
blink
>
"
;
}
function
String_bold
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
bold
"
this
)
;
}
return
"
<
b
>
"
+
ToString
(
this
)
+
"
<
/
b
>
"
;
}
function
String_fixed
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
fixed
"
this
)
;
}
return
"
<
tt
>
"
+
ToString
(
this
)
+
"
<
/
tt
>
"
;
}
function
String_italics
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
italics
"
this
)
;
}
return
"
<
i
>
"
+
ToString
(
this
)
+
"
<
/
i
>
"
;
}
function
String_small
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
small
"
this
)
;
}
return
"
<
small
>
"
+
ToString
(
this
)
+
"
<
/
small
>
"
;
}
function
String_strike
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
strike
"
this
)
;
}
return
"
<
strike
>
"
+
ToString
(
this
)
+
"
<
/
strike
>
"
;
}
function
String_sub
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
sub
"
this
)
;
}
return
"
<
sub
>
"
+
ToString
(
this
)
+
"
<
/
sub
>
"
;
}
function
String_sup
(
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
sup
"
this
)
;
}
return
"
<
sup
>
"
+
ToString
(
this
)
+
"
<
/
sup
>
"
;
}
function
EscapeAttributeValue
(
v
)
{
var
inputStr
=
ToString
(
v
)
;
return
StringReplaceAllString
(
inputStr
'
"
'
"
&
quot
;
"
)
;
}
function
String_anchor
(
name
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
anchor
"
this
)
;
}
var
S
=
ToString
(
this
)
;
return
'
<
a
name
=
"
'
+
EscapeAttributeValue
(
name
)
+
'
"
>
'
+
S
+
"
<
/
a
>
"
;
}
function
String_fontcolor
(
color
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
fontcolor
"
this
)
;
}
var
S
=
ToString
(
this
)
;
return
'
<
font
color
=
"
'
+
EscapeAttributeValue
(
color
)
+
'
"
>
'
+
S
+
"
<
/
font
>
"
;
}
function
String_fontsize
(
size
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
fontsize
"
this
)
;
}
var
S
=
ToString
(
this
)
;
return
'
<
font
size
=
"
'
+
EscapeAttributeValue
(
size
)
+
'
"
>
'
+
S
+
"
<
/
font
>
"
;
}
function
String_link
(
url
)
{
if
(
this
=
=
=
undefined
|
|
this
=
=
=
null
)
{
ThrowIncompatibleMethod
(
"
link
"
this
)
;
}
var
S
=
ToString
(
this
)
;
return
'
<
a
href
=
"
'
+
EscapeAttributeValue
(
url
)
+
'
"
>
'
+
S
+
"
<
/
a
>
"
;
}
