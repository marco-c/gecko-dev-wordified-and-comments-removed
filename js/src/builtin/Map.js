function
MapConstructorInit
(
iterable
)
{
var
map
=
this
;
var
adder
=
map
.
set
;
if
(
!
IsCallable
(
adder
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
typeof
adder
)
;
var
iterFn
=
iterable
[
std_iterator
]
;
if
(
!
IsCallable
(
iterFn
)
)
ThrowTypeError
(
JSMSG_NOT_ITERABLE
DecompileArg
(
0
iterable
)
)
;
var
iter
=
callContentFunction
(
iterFn
iterable
)
;
if
(
!
IsObject
(
iter
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
typeof
iter
)
;
while
(
true
)
{
var
next
=
callContentFunction
(
iter
.
next
iter
)
;
if
(
!
IsObject
(
next
)
)
ThrowTypeError
(
JSMSG_NOT_NONNULL_OBJECT
typeof
next
)
;
if
(
next
.
done
)
return
;
var
nextItem
=
next
.
value
;
if
(
!
IsObject
(
nextItem
)
)
ThrowTypeError
(
JSMSG_INVALID_MAP_ITERABLE
"
Map
"
)
;
callContentFunction
(
adder
map
nextItem
[
0
]
nextItem
[
1
]
)
;
}
}
function
MapForEach
(
callbackfn
thisArg
=
undefined
)
{
var
M
=
this
;
if
(
!
IsObject
(
M
)
)
ThrowTypeError
(
JSMSG_INCOMPATIBLE_PROTO
"
Map
"
"
forEach
"
typeof
M
)
;
try
{
callFunction
(
std_Map_has
M
)
;
}
catch
(
e
)
{
ThrowTypeError
(
JSMSG_INCOMPATIBLE_PROTO
"
Map
"
"
forEach
"
typeof
M
)
;
}
if
(
!
IsCallable
(
callbackfn
)
)
ThrowTypeError
(
JSMSG_NOT_FUNCTION
DecompileArg
(
0
callbackfn
)
)
;
var
entries
=
callFunction
(
std_Map_iterator
M
)
;
while
(
true
)
{
var
result
=
callFunction
(
MapIteratorNext
entries
)
;
if
(
result
.
done
)
break
;
var
entry
=
result
.
value
;
callContentFunction
(
callbackfn
thisArg
entry
[
1
]
entry
[
0
]
M
)
;
}
}
var
iteratorTemp
=
{
mapIterationResultPair
:
null
}
;
function
MapIteratorNext
(
)
{
var
O
=
this
;
if
(
!
IsObject
(
O
)
|
|
!
IsMapIterator
(
O
)
)
return
callFunction
(
CallMapIteratorMethodIfWrapped
O
"
MapIteratorNext
"
)
;
var
mapIterationResultPair
=
iteratorTemp
.
mapIterationResultPair
;
if
(
!
mapIterationResultPair
)
{
mapIterationResultPair
=
iteratorTemp
.
mapIterationResultPair
=
_CreateMapIterationResultPair
(
)
;
}
var
retVal
=
{
value
:
undefined
done
:
true
}
;
var
done
=
_GetNextMapEntryForIterator
(
O
mapIterationResultPair
)
;
if
(
!
done
)
{
var
itemKind
=
UnsafeGetInt32FromReservedSlot
(
this
ITERATOR_SLOT_ITEM_KIND
)
;
var
result
;
if
(
itemKind
=
=
=
ITEM_KIND_KEY
)
{
result
=
mapIterationResultPair
[
0
]
;
}
else
if
(
itemKind
=
=
=
ITEM_KIND_VALUE
)
{
result
=
mapIterationResultPair
[
1
]
;
}
else
{
assert
(
itemKind
=
=
=
ITEM_KIND_KEY_AND_VALUE
itemKind
)
;
result
=
[
mapIterationResultPair
[
0
]
mapIterationResultPair
[
1
]
]
;
}
mapIterationResultPair
[
0
]
=
null
;
mapIterationResultPair
[
1
]
=
null
;
retVal
.
value
=
result
;
retVal
.
done
=
false
;
}
return
retVal
;
}
function
MapSpecies
(
)
{
return
this
;
}
_SetCanonicalName
(
MapSpecies
"
get
[
Symbol
.
species
]
"
)
;
