#
ifndef
builtin_TypedObject_h
#
define
builtin_TypedObject_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
builtin
/
TypedObjectConstants
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ShapedObject
.
h
"
namespace
js
{
class
GlobalObject
;
template
<
typename
T
>
static
T
ConvertScalar
(
double
d
)
{
if
(
TypeIsFloatingPoint
<
T
>
(
)
)
{
return
T
(
d
)
;
}
if
(
TypeIsUnsigned
<
T
>
(
)
)
{
uint32_t
n
=
JS
:
:
ToUint32
(
d
)
;
return
T
(
n
)
;
}
int32_t
n
=
JS
:
:
ToInt32
(
d
)
;
return
T
(
n
)
;
}
namespace
type
{
enum
Kind
{
Scalar
=
JS_TYPEREPR_SCALAR_KIND
Reference
=
JS_TYPEREPR_REFERENCE_KIND
Struct
=
JS_TYPEREPR_STRUCT_KIND
Array
=
JS_TYPEREPR_ARRAY_KIND
}
;
}
class
SimpleTypeDescr
;
class
ComplexTypeDescr
;
class
StructTypeDescr
;
class
TypedProto
;
class
TypedProto
:
public
NativeObject
{
public
:
static
const
Class
class_
;
}
;
class
TypeDescr
:
public
NativeObject
{
public
:
TypedProto
&
typedProto
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_TYPROTO
)
.
toObject
(
)
.
as
<
TypedProto
>
(
)
;
}
JSAtom
&
stringRepr
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_STRING_REPR
)
.
toString
(
)
-
>
asAtom
(
)
;
}
type
:
:
Kind
kind
(
)
const
{
return
(
type
:
:
Kind
)
getReservedSlot
(
JS_DESCR_SLOT_KIND
)
.
toInt32
(
)
;
}
bool
opaque
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_OPAQUE
)
.
toBoolean
(
)
;
}
bool
transparent
(
)
const
{
return
!
opaque
(
)
;
}
uint32_t
alignment
(
)
const
{
int32_t
i
=
getReservedSlot
(
JS_DESCR_SLOT_ALIGNMENT
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
uint32_t
size
(
)
const
{
int32_t
i
=
getReservedSlot
(
JS_DESCR_SLOT_SIZE
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
MOZ_MUST_USE
bool
hasProperty
(
const
JSAtomState
&
names
jsid
id
)
;
MOZ_MUST_USE
bool
hasTraceList
(
)
const
{
return
!
getFixedSlot
(
JS_DESCR_SLOT_TRACE_LIST
)
.
isUndefined
(
)
;
}
const
int32_t
*
traceList
(
)
const
{
MOZ_ASSERT
(
hasTraceList
(
)
)
;
return
reinterpret_cast
<
int32_t
*
>
(
getFixedSlot
(
JS_DESCR_SLOT_TRACE_LIST
)
.
toPrivate
(
)
)
;
}
void
initInstances
(
const
JSRuntime
*
rt
uint8_t
*
mem
size_t
length
)
;
void
traceInstances
(
JSTracer
*
trace
uint8_t
*
mem
size_t
length
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
}
;
typedef
Handle
<
TypeDescr
*
>
HandleTypeDescr
;
class
SimpleTypeDescr
:
public
TypeDescr
{
}
;
class
ScalarTypeDescr
:
public
SimpleTypeDescr
{
public
:
typedef
Scalar
:
:
Type
Type
;
static
const
type
:
:
Kind
Kind
=
type
:
:
Scalar
;
static
const
bool
Opaque
=
false
;
static
uint32_t
size
(
Type
t
)
;
static
uint32_t
alignment
(
Type
t
)
;
static
const
char
*
typeName
(
Type
type
)
;
static
const
Class
class_
;
static
const
JSFunctionSpec
typeObjectMethods
[
]
;
Type
type
(
)
const
{
static_assert
(
Scalar
:
:
Int8
=
=
JS_SCALARTYPEREPR_INT8
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Uint8
=
=
JS_SCALARTYPEREPR_UINT8
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Int16
=
=
JS_SCALARTYPEREPR_INT16
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Uint16
=
=
JS_SCALARTYPEREPR_UINT16
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Int32
=
=
JS_SCALARTYPEREPR_INT32
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Uint32
=
=
JS_SCALARTYPEREPR_UINT32
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Float32
=
=
JS_SCALARTYPEREPR_FLOAT32
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Float64
=
=
JS_SCALARTYPEREPR_FLOAT64
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
static_assert
(
Scalar
:
:
Uint8Clamped
=
=
JS_SCALARTYPEREPR_UINT8_CLAMPED
"
TypedObjectConstants
.
h
must
be
consistent
with
Scalar
:
:
Type
"
)
;
return
Type
(
getReservedSlot
(
JS_DESCR_SLOT_TYPE
)
.
toInt32
(
)
)
;
}
static
MOZ_MUST_USE
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
#
define
JS_FOR_EACH_UNIQUE_SCALAR_TYPE_REPR_CTYPE
(
macro_
)
\
macro_
(
Scalar
:
:
Int8
int8_t
int8
)
\
macro_
(
Scalar
:
:
Uint8
uint8_t
uint8
)
\
macro_
(
Scalar
:
:
Int16
int16_t
int16
)
\
macro_
(
Scalar
:
:
Uint16
uint16_t
uint16
)
\
macro_
(
Scalar
:
:
Int32
int32_t
int32
)
\
macro_
(
Scalar
:
:
Uint32
uint32_t
uint32
)
\
macro_
(
Scalar
:
:
Float32
float
float32
)
\
macro_
(
Scalar
:
:
Float64
double
float64
)
#
define
JS_FOR_EACH_SCALAR_TYPE_REPR
(
macro_
)
\
JS_FOR_EACH_UNIQUE_SCALAR_TYPE_REPR_CTYPE
(
macro_
)
\
macro_
(
Scalar
:
:
Uint8Clamped
uint8_t
uint8Clamped
)
enum
class
ReferenceType
{
TYPE_ANY
=
JS_REFERENCETYPEREPR_ANY
TYPE_OBJECT
=
JS_REFERENCETYPEREPR_OBJECT
TYPE_STRING
=
JS_REFERENCETYPEREPR_STRING
}
;
class
ReferenceTypeDescr
:
public
SimpleTypeDescr
{
public
:
typedef
ReferenceType
Type
;
static
const
char
*
typeName
(
Type
type
)
;
static
const
int32_t
TYPE_MAX
=
int32_t
(
ReferenceType
:
:
TYPE_STRING
)
+
1
;
static
const
type
:
:
Kind
Kind
=
type
:
:
Reference
;
static
const
bool
Opaque
=
true
;
static
const
Class
class_
;
static
uint32_t
size
(
Type
t
)
;
static
uint32_t
alignment
(
Type
t
)
;
static
const
JSFunctionSpec
typeObjectMethods
[
]
;
ReferenceType
type
(
)
const
{
return
(
ReferenceType
)
getReservedSlot
(
JS_DESCR_SLOT_TYPE
)
.
toInt32
(
)
;
}
const
char
*
typeName
(
)
const
{
return
typeName
(
type
(
)
)
;
}
static
MOZ_MUST_USE
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
#
define
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
macro_
)
\
macro_
(
ReferenceType
:
:
TYPE_ANY
GCPtrValue
Any
)
\
macro_
(
ReferenceType
:
:
TYPE_OBJECT
GCPtrObject
Object
)
\
macro_
(
ReferenceType
:
:
TYPE_STRING
GCPtrString
string
)
class
ComplexTypeDescr
:
public
TypeDescr
{
public
:
TypedProto
&
instancePrototype
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_TYPROTO
)
.
toObject
(
)
.
as
<
TypedProto
>
(
)
;
}
bool
allowConstruct
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_FLAGS
)
.
toInt32
(
)
&
JS_DESCR_FLAG_ALLOW_CONSTRUCT
;
}
}
;
bool
IsTypedObjectClass
(
const
Class
*
clasp
)
;
bool
IsTypedObjectArray
(
JSObject
&
obj
)
;
MOZ_MUST_USE
bool
CreateUserSizeAndAlignmentProperties
(
JSContext
*
cx
HandleTypeDescr
obj
)
;
class
ArrayTypeDescr
;
class
ArrayMetaTypeDescr
:
public
NativeObject
{
private
:
static
ArrayTypeDescr
*
create
(
JSContext
*
cx
HandleObject
arrayTypePrototype
HandleTypeDescr
elementType
HandleAtom
stringRepr
int32_t
size
int32_t
length
)
;
public
:
static
const
JSPropertySpec
typeObjectProperties
[
]
;
static
const
JSFunctionSpec
typeObjectMethods
[
]
;
static
const
JSPropertySpec
typedObjectProperties
[
]
;
static
const
JSFunctionSpec
typedObjectMethods
[
]
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
class
ArrayTypeDescr
:
public
ComplexTypeDescr
{
public
:
static
const
Class
class_
;
static
const
type
:
:
Kind
Kind
=
type
:
:
Array
;
TypeDescr
&
elementType
(
)
const
{
return
getReservedSlot
(
JS_DESCR_SLOT_ARRAY_ELEM_TYPE
)
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
;
}
uint32_t
length
(
)
const
{
int32_t
i
=
getReservedSlot
(
JS_DESCR_SLOT_ARRAY_LENGTH
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
static
int32_t
offsetOfLength
(
)
{
return
getFixedSlotOffset
(
JS_DESCR_SLOT_ARRAY_LENGTH
)
;
}
}
;
struct
StructFieldProps
{
StructFieldProps
(
)
:
isMutable
(
0
)
alignAsInt64
(
0
)
{
}
uint32_t
isMutable
:
1
;
uint32_t
alignAsInt64
:
1
;
}
;
class
StructMetaTypeDescr
:
public
NativeObject
{
private
:
static
JSObject
*
create
(
JSContext
*
cx
HandleObject
structTypeGlobal
HandleObject
fields
)
;
public
:
static
StructTypeDescr
*
createFromArrays
(
JSContext
*
cx
HandleObject
structTypePrototype
bool
opaque
bool
allowConstruct
AutoIdVector
&
ids
AutoValueVector
&
fieldTypeObjs
Vector
<
StructFieldProps
>
&
fieldProps
)
;
static
const
JSPropertySpec
typeObjectProperties
[
]
;
static
const
JSFunctionSpec
typeObjectMethods
[
]
;
static
const
JSPropertySpec
typedObjectProperties
[
]
;
static
const
JSFunctionSpec
typedObjectMethods
[
]
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
class
Layout
{
friend
class
StructMetaTypeDescr
;
mozilla
:
:
CheckedInt32
sizeSoFar
=
0
;
int32_t
structAlignment
=
1
;
mozilla
:
:
CheckedInt32
addField
(
int32_t
fieldAlignment
int32_t
fieldSize
)
;
public
:
mozilla
:
:
CheckedInt32
addScalar
(
Scalar
:
:
Type
type
)
;
mozilla
:
:
CheckedInt32
addReference
(
ReferenceType
type
)
;
mozilla
:
:
CheckedInt32
close
(
int32_t
*
alignment
=
nullptr
)
;
}
;
}
;
class
StructTypeDescr
:
public
ComplexTypeDescr
{
public
:
static
const
Class
class_
;
size_t
fieldCount
(
)
const
;
MOZ_MUST_USE
bool
fieldIndex
(
jsid
id
size_t
*
out
)
const
;
JSAtom
&
fieldName
(
size_t
index
)
const
;
TypeDescr
&
fieldDescr
(
size_t
index
)
const
;
size_t
fieldOffset
(
size_t
index
)
const
;
bool
fieldIsMutable
(
size_t
index
)
const
;
static
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
private
:
ArrayObject
&
fieldInfoObject
(
size_t
slot
)
const
{
return
getReservedSlot
(
slot
)
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
}
}
;
typedef
Handle
<
StructTypeDescr
*
>
HandleStructTypeDescr
;
class
TypedObjectModuleObject
:
public
NativeObject
{
public
:
enum
Slot
{
ArrayTypePrototype
StructTypePrototype
Int32Desc
Int64Desc
Float32Desc
Float64Desc
ObjectDesc
SlotCount
}
;
static
const
Class
class_
;
}
;
class
TypedObject
:
public
ShapedObject
{
static
const
bool
IsTypedObjectClass
=
true
;
static
MOZ_MUST_USE
bool
obj_getArrayElement
(
JSContext
*
cx
Handle
<
TypedObject
*
>
typedObj
Handle
<
TypeDescr
*
>
typeDescr
uint32_t
index
MutableHandleValue
vp
)
;
protected
:
static
const
ObjectOps
objectOps_
;
static
MOZ_MUST_USE
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
MutableHandle
<
PropertyResult
>
propp
)
;
static
MOZ_MUST_USE
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
static
MOZ_MUST_USE
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
static
MOZ_MUST_USE
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
static
MOZ_MUST_USE
bool
obj_getElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
uint32_t
index
MutableHandleValue
vp
)
;
static
MOZ_MUST_USE
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
static
MOZ_MUST_USE
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
;
static
MOZ_MUST_USE
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
uint8_t
*
typedMem
(
)
const
;
uint8_t
*
typedMemBase
(
)
const
;
public
:
static
MOZ_MUST_USE
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
AutoIdVector
&
properties
bool
enumerableOnly
)
;
TypedProto
&
typedProto
(
)
const
{
return
staticPrototype
(
)
-
>
as
<
TypedProto
>
(
)
;
}
TypeDescr
&
typeDescr
(
)
const
{
return
group
(
)
-
>
typeDescr
(
)
;
}
static
JS
:
:
Result
<
TypedObject
*
JS
:
:
OOM
&
>
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
js
:
:
HandleObjectGroup
group
)
;
uint32_t
offset
(
)
const
;
uint32_t
length
(
)
const
;
uint8_t
*
typedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
typedMem
(
)
;
}
bool
isAttached
(
)
const
;
uint32_t
size
(
)
const
{
return
typeDescr
(
)
.
size
(
)
;
}
uint8_t
*
typedMem
(
size_t
offset
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
offset
<
=
(
size_t
)
size
(
)
)
;
return
typedMem
(
nogc
)
+
offset
;
}
inline
MOZ_MUST_USE
bool
opaque
(
)
const
;
static
TypedObject
*
createZeroed
(
JSContext
*
cx
HandleTypeDescr
typeObj
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
MOZ_MUST_USE
bool
GetBuffer
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
MOZ_MUST_USE
bool
GetByteOffset
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
Shape
*
*
addressOfShapeFromGC
(
)
{
return
shapeRef
(
)
.
unsafeUnbarrieredForTracing
(
)
;
}
}
;
typedef
Handle
<
TypedObject
*
>
HandleTypedObject
;
class
OutlineTypedObject
:
public
TypedObject
{
JSObject
*
owner_
;
uint8_t
*
data_
;
void
setOwnerAndData
(
JSObject
*
owner
uint8_t
*
data
)
;
public
:
static
size_t
offsetOfData
(
)
{
return
offsetof
(
OutlineTypedObject
data_
)
;
}
static
size_t
offsetOfOwner
(
)
{
return
offsetof
(
OutlineTypedObject
owner_
)
;
}
JSObject
&
owner
(
)
const
{
MOZ_ASSERT
(
owner_
)
;
return
*
owner_
;
}
JSObject
*
maybeOwner
(
)
const
{
return
owner_
;
}
uint8_t
*
outOfLineTypedMem
(
)
const
{
return
data_
;
}
void
setData
(
uint8_t
*
data
)
{
data_
=
data
;
}
void
resetOffset
(
size_t
offset
)
{
MOZ_ASSERT
(
offset
<
=
(
size_t
)
size
(
)
)
;
setData
(
typedMemBase
(
)
+
offset
)
;
}
static
OutlineTypedObject
*
createUnattachedWithClass
(
JSContext
*
cx
const
Class
*
clasp
HandleTypeDescr
type
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
OutlineTypedObject
*
createUnattached
(
JSContext
*
cx
HandleTypeDescr
type
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
OutlineTypedObject
*
createDerived
(
JSContext
*
cx
HandleTypeDescr
type
Handle
<
TypedObject
*
>
typedContents
uint32_t
offset
)
;
void
attach
(
JSContext
*
cx
ArrayBufferObject
&
buffer
uint32_t
offset
)
;
void
attach
(
JSContext
*
cx
TypedObject
&
typedObj
uint32_t
offset
)
;
void
notifyBufferDetached
(
void
*
newData
)
;
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
}
;
class
OutlineTransparentTypedObject
:
public
OutlineTypedObject
{
public
:
static
const
Class
class_
;
ArrayBufferObject
*
getOrCreateBuffer
(
JSContext
*
cx
)
;
}
;
class
OutlineOpaqueTypedObject
:
public
OutlineTypedObject
{
public
:
static
const
Class
class_
;
}
;
class
InlineTypedObject
:
public
TypedObject
{
friend
class
TypedObject
;
uint8_t
data_
[
1
]
;
static
const
size_t
MaximumSize
=
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
TypedObject
)
;
protected
:
uint8_t
*
inlineTypedMem
(
)
const
{
return
(
uint8_t
*
)
&
data_
;
}
public
:
static
inline
gc
:
:
AllocKind
allocKindForTypeDescriptor
(
TypeDescr
*
descr
)
;
static
bool
canAccommodateSize
(
size_t
size
)
{
return
size
<
=
MaximumSize
;
}
static
bool
canAccommodateType
(
TypeDescr
*
type
)
{
return
type
-
>
size
(
)
<
=
MaximumSize
;
}
uint8_t
*
inlineTypedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
inlineTypedMem
(
)
;
}
uint8_t
*
inlineTypedMemForGC
(
)
const
{
return
inlineTypedMem
(
)
;
}
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
dst
JSObject
*
src
)
;
static
size_t
offsetOfDataStart
(
)
{
return
offsetof
(
InlineTypedObject
data_
)
;
}
static
InlineTypedObject
*
create
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
InlineTypedObject
*
createCopy
(
JSContext
*
cx
Handle
<
InlineTypedObject
*
>
templateObject
gc
:
:
InitialHeap
heap
)
;
}
;
class
InlineTransparentTypedObject
:
public
InlineTypedObject
{
public
:
static
const
Class
class_
;
ArrayBufferObject
*
getOrCreateBuffer
(
JSContext
*
cx
)
;
uint8_t
*
inlineTypedMem
(
)
const
{
return
InlineTypedObject
:
:
inlineTypedMem
(
)
;
}
}
;
class
InlineOpaqueTypedObject
:
public
InlineTypedObject
{
public
:
static
const
Class
class_
;
}
;
MOZ_MUST_USE
bool
NewOpaqueTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
NewDerivedTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
AttachTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
SetTypedObjectOffset
(
JSContext
*
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
ObjectIsTypeDescr
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
ObjectIsTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
ObjectIsOpaqueTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
ObjectIsTransparentTypedObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
TypeDescrIsSimpleType
(
JSContext
*
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
TypeDescrIsArrayType
(
JSContext
*
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
TypedObjectIsAttached
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
TypedObjectTypeDescr
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
ClampToUint8
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
GetTypedObjectModule
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
#
define
JS_STORE_SCALAR_CLASS_DEFN
(
_constant
T
_name
)
\
class
StoreScalar
#
#
T
{
\
public
:
\
static
MOZ_MUST_USE
bool
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
\
static
const
JSJitInfo
JitInfo
;
\
}
;
#
define
JS_STORE_REFERENCE_CLASS_DEFN
(
_constant
T
_name
)
\
class
StoreReference
#
#
_name
{
\
private
:
\
static
MOZ_MUST_USE
bool
store
(
JSContext
*
cx
T
*
heap
const
Value
&
v
\
TypedObject
*
obj
jsid
id
)
;
\
\
public
:
\
static
MOZ_MUST_USE
bool
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
\
static
const
JSJitInfo
JitInfo
;
\
}
;
#
define
JS_LOAD_SCALAR_CLASS_DEFN
(
_constant
T
_name
)
\
class
LoadScalar
#
#
T
{
\
public
:
\
static
MOZ_MUST_USE
bool
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
\
static
const
JSJitInfo
JitInfo
;
\
}
;
#
define
JS_LOAD_REFERENCE_CLASS_DEFN
(
_constant
T
_name
)
\
class
LoadReference
#
#
_name
{
\
private
:
\
static
void
load
(
T
*
heap
MutableHandleValue
v
)
;
\
\
public
:
\
static
MOZ_MUST_USE
bool
Func
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
\
static
const
JSJitInfo
JitInfo
;
\
}
;
JS_FOR_EACH_UNIQUE_SCALAR_TYPE_REPR_CTYPE
(
JS_STORE_SCALAR_CLASS_DEFN
)
JS_FOR_EACH_UNIQUE_SCALAR_TYPE_REPR_CTYPE
(
JS_LOAD_SCALAR_CLASS_DEFN
)
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
JS_STORE_REFERENCE_CLASS_DEFN
)
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
JS_LOAD_REFERENCE_CLASS_DEFN
)
inline
bool
IsTypedObjectClass
(
const
Class
*
class_
)
{
return
class_
=
=
&
OutlineTransparentTypedObject
:
:
class_
|
|
class_
=
=
&
InlineTransparentTypedObject
:
:
class_
|
|
class_
=
=
&
OutlineOpaqueTypedObject
:
:
class_
|
|
class_
=
=
&
InlineOpaqueTypedObject
:
:
class_
;
}
inline
bool
IsOpaqueTypedObjectClass
(
const
Class
*
class_
)
{
return
class_
=
=
&
OutlineOpaqueTypedObject
:
:
class_
|
|
class_
=
=
&
InlineOpaqueTypedObject
:
:
class_
;
}
inline
bool
IsOutlineTypedObjectClass
(
const
Class
*
class_
)
{
return
class_
=
=
&
OutlineOpaqueTypedObject
:
:
class_
|
|
class_
=
=
&
OutlineTransparentTypedObject
:
:
class_
;
}
inline
bool
IsInlineTypedObjectClass
(
const
Class
*
class_
)
{
return
class_
=
=
&
InlineOpaqueTypedObject
:
:
class_
|
|
class_
=
=
&
InlineTransparentTypedObject
:
:
class_
;
}
inline
const
Class
*
GetOutlineTypedObjectClass
(
bool
opaque
)
{
return
opaque
?
&
OutlineOpaqueTypedObject
:
:
class_
:
&
OutlineTransparentTypedObject
:
:
class_
;
}
inline
bool
IsSimpleTypeDescrClass
(
const
Class
*
clasp
)
{
return
clasp
=
=
&
ScalarTypeDescr
:
:
class_
|
|
clasp
=
=
&
ReferenceTypeDescr
:
:
class_
;
}
inline
bool
IsComplexTypeDescrClass
(
const
Class
*
clasp
)
{
return
clasp
=
=
&
StructTypeDescr
:
:
class_
|
|
clasp
=
=
&
ArrayTypeDescr
:
:
class_
;
}
inline
bool
IsTypeDescrClass
(
const
Class
*
clasp
)
{
return
IsSimpleTypeDescrClass
(
clasp
)
|
|
IsComplexTypeDescrClass
(
clasp
)
;
}
inline
bool
TypedObject
:
:
opaque
(
)
const
{
return
IsOpaqueTypedObjectClass
(
getClass
(
)
)
;
}
JSObject
*
InitTypedObjectModuleObject
(
JSContext
*
cx
JS
:
:
Handle
<
GlobalObject
*
>
global
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
SimpleTypeDescr
>
(
)
const
{
return
IsSimpleTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
ComplexTypeDescr
>
(
)
const
{
return
IsComplexTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
TypeDescr
>
(
)
const
{
return
IsTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
TypedObject
>
(
)
const
{
return
IsTypedObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
OutlineTypedObject
>
(
)
const
{
return
getClass
(
)
=
=
&
js
:
:
OutlineTransparentTypedObject
:
:
class_
|
|
getClass
(
)
=
=
&
js
:
:
OutlineOpaqueTypedObject
:
:
class_
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
InlineTypedObject
>
(
)
const
{
return
getClass
(
)
=
=
&
js
:
:
InlineTransparentTypedObject
:
:
class_
|
|
getClass
(
)
=
=
&
js
:
:
InlineOpaqueTypedObject
:
:
class_
;
}
#
endif
