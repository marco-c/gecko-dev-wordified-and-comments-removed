function
CallModuleResolveHook
(
module
specifier
expectedMinimumStatus
)
{
let
requestedModule
=
HostResolveImportedModule
(
module
specifier
)
;
if
(
requestedModule
.
status
<
expectedMinimumStatus
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
return
requestedModule
;
}
function
ModuleGetExportedNames
(
exportStarSet
=
[
]
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportStarSet
"
ModuleGetExportedNames
"
)
;
}
let
module
=
this
;
if
(
callFunction
(
ArrayIncludes
exportStarSet
module
)
)
return
[
]
;
_DefineDataProperty
(
exportStarSet
exportStarSet
.
length
module
)
;
let
exportedNames
=
[
]
;
let
namesCount
=
0
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
_DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
_DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
requestedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNINSTANTIATED
)
;
let
starNames
=
callFunction
(
requestedModule
.
getExportedNames
requestedModule
exportStarSet
)
;
for
(
let
j
=
0
;
j
<
starNames
.
length
;
j
+
+
)
{
let
n
=
starNames
[
j
]
;
if
(
n
!
=
=
"
default
"
&
&
!
callFunction
(
ArrayIncludes
exportedNames
n
)
)
_DefineDataProperty
(
exportedNames
namesCount
+
+
n
)
;
}
}
return
exportedNames
;
}
function
ModuleSetStatus
(
module
newStatus
)
{
assert
(
newStatus
>
=
MODULE_STATUS_UNINSTANTIATED
&
&
newStatus
<
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
new
module
status
in
ModuleSetStatus
"
)
;
assert
(
(
module
.
status
<
=
MODULE_STATUS_INSTANTIATED
&
&
newStatus
=
=
=
MODULE_STATUS_UNINSTANTIATED
)
|
|
newStatus
>
module
.
status
"
New
module
status
inconsistent
with
current
status
"
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_STATUS_SLOT
newStatus
)
;
}
function
ModuleResolveExport
(
exportName
resolveSet
=
[
]
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportName
resolveSet
"
ModuleResolveExport
"
)
;
}
let
module
=
this
;
for
(
let
i
=
0
;
i
<
resolveSet
.
length
;
i
+
+
)
{
let
r
=
resolveSet
[
i
]
;
if
(
r
.
module
=
=
=
module
&
&
r
.
exportName
=
=
=
exportName
)
{
return
null
;
}
}
_DefineDataProperty
(
resolveSet
resolveSet
.
length
{
module
exportName
}
)
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
return
{
module
bindingName
:
e
.
localName
}
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
{
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNINSTANTIATED
)
;
return
callFunction
(
importedModule
.
resolveExport
importedModule
e
.
importName
resolveSet
)
;
}
}
if
(
exportName
=
=
=
"
default
"
)
{
return
null
;
}
let
starResolution
=
null
;
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNINSTANTIATED
)
;
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
exportName
resolveSet
)
;
if
(
resolution
=
=
=
"
ambiguous
"
)
return
resolution
;
if
(
resolution
!
=
=
null
)
{
if
(
starResolution
=
=
=
null
)
{
starResolution
=
resolution
;
}
else
{
if
(
resolution
.
module
!
=
=
starResolution
.
module
|
|
resolution
.
bindingName
!
=
=
starResolution
.
bindingName
)
{
return
"
ambiguous
"
;
}
}
}
}
return
starResolution
;
}
function
IsResolvedBinding
(
resolution
)
{
assert
(
resolution
=
=
=
"
ambiguous
"
|
|
typeof
resolution
=
=
=
"
object
"
"
Bad
module
resolution
result
"
)
;
return
typeof
resolution
=
=
=
"
object
"
&
&
resolution
!
=
=
null
;
}
function
GetModuleNamespace
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
GetModuleNamespace
called
with
non
-
module
"
)
;
assert
(
module
.
status
!
=
=
MODULE_STATUS_UNINSTANTIATED
"
Bad
module
state
in
GetModuleNamespace
"
)
;
let
namespace
=
module
.
namespace
;
if
(
typeof
namespace
=
=
=
"
undefined
"
)
{
let
exportedNames
=
callFunction
(
module
.
getExportedNames
module
)
;
let
unambiguousNames
=
[
]
;
for
(
let
i
=
0
;
i
<
exportedNames
.
length
;
i
+
+
)
{
let
name
=
exportedNames
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
name
)
;
if
(
IsResolvedBinding
(
resolution
)
)
_DefineDataProperty
(
unambiguousNames
unambiguousNames
.
length
name
)
;
}
namespace
=
ModuleNamespaceCreate
(
module
unambiguousNames
)
;
}
return
namespace
;
}
function
ModuleNamespaceCreate
(
module
exports
)
{
callFunction
(
ArraySort
exports
)
;
let
ns
=
NewModuleNamespace
(
module
exports
)
;
for
(
let
i
=
0
;
i
<
exports
.
length
;
i
+
+
)
{
let
name
=
exports
[
i
]
;
let
binding
=
callFunction
(
module
.
resolveExport
module
name
)
;
assert
(
IsResolvedBinding
(
binding
)
"
Failed
to
resolve
binding
"
)
;
AddModuleNamespaceBinding
(
ns
name
binding
.
module
binding
.
bindingName
)
;
}
return
ns
;
}
function
GetModuleEnvironment
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEnvironment
"
)
;
assert
(
module
.
status
>
=
MODULE_STATUS_INSTANTIATING
"
Attempt
to
access
module
environement
before
instantation
"
)
;
let
env
=
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_ENVIRONMENT_SLOT
)
;
assert
(
IsObject
(
env
)
&
&
IsModuleEnvironment
(
env
)
"
Module
environment
slot
contains
unexpected
value
"
)
;
return
env
;
}
function
CountArrayValues
(
array
value
)
{
let
count
=
0
;
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
count
+
+
;
}
return
count
;
}
function
ArrayContains
(
array
value
)
{
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
return
true
;
}
return
false
;
}
function
HandleModuleInstantiationFailure
(
module
)
{
ModuleSetStatus
(
module
MODULE_STATUS_UNINSTANTIATED
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
undefined
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
undefined
)
;
}
function
ModuleInstantiate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleInstantiate
"
)
;
let
module
=
this
;
if
(
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
let
stack
=
[
]
;
try
{
InnerModuleInstantiation
(
module
stack
0
)
;
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
if
(
m
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
)
{
HandleModuleInstantiationFailure
(
m
)
;
}
}
if
(
stack
.
length
=
=
=
0
&
&
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
)
{
HandleModuleInstantiationFailure
(
module
)
;
}
assert
(
module
.
status
!
=
=
MODULE_STATUS_INSTANTIATING
"
Expected
uninstantiated
status
after
failed
instantiation
"
)
;
throw
error
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
successful
instantiation
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
instantiation
"
)
;
return
undefined
;
}
function
InnerModuleInstantiation
(
module
stack
index
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
|
|
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
index
;
}
if
(
module
.
status
!
=
=
MODULE_STATUS_UNINSTANTIATED
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
ModuleSetStatus
(
module
MODULE_STATUS_INSTANTIATING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
index
+
+
;
_DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleSpecifier
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_UNINSTANTIATED
)
;
index
=
InnerModuleInstantiation
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_INSTANTIATED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
required
module
status
after
InnerModuleInstantiation
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
instantiated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
}
ModuleDeclarationEnvironmentSetup
(
module
)
;
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_INSTANTIATED
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
function
ModuleDeclarationEnvironmentSetup
(
module
)
{
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
e
.
exportName
)
;
if
(
!
IsResolvedBinding
(
resolution
)
)
{
ThrowResolutionError
(
module
resolution
"
indirectExport
"
e
.
exportName
e
.
lineNumber
e
.
columnNumber
)
;
}
}
let
env
=
GetModuleEnvironment
(
module
)
;
let
importEntries
=
module
.
importEntries
;
for
(
let
i
=
0
;
i
<
importEntries
.
length
;
i
+
+
)
{
let
imp
=
importEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
imp
.
moduleRequest
MODULE_STATUS_INSTANTIATING
)
;
if
(
imp
.
importName
=
=
=
"
*
"
)
{
let
namespace
=
GetModuleNamespace
(
importedModule
)
;
CreateNamespaceBinding
(
env
imp
.
localName
namespace
)
;
}
else
{
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
imp
.
importName
)
;
if
(
!
IsResolvedBinding
(
resolution
)
)
{
ThrowResolutionError
(
module
resolution
"
import
"
imp
.
importName
imp
.
lineNumber
imp
.
columnNumber
)
;
}
CreateImportBinding
(
env
imp
.
localName
resolution
.
module
resolution
.
bindingName
)
;
}
}
InstantiateModuleFunctionDeclarations
(
module
)
;
}
function
ThrowResolutionError
(
module
resolution
kind
name
line
column
)
{
assert
(
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATING
"
Unexpected
module
status
in
ThrowResolutionError
"
)
;
assert
(
kind
=
=
=
"
import
"
|
|
kind
=
=
=
"
indirectExport
"
"
Unexpected
kind
in
ThrowResolutionError
"
)
;
assert
(
line
>
0
"
Line
number
should
be
present
for
all
imports
and
indirect
exports
"
)
;
let
ambiguous
=
resolution
=
=
=
"
ambiguous
"
;
let
errorNumber
;
if
(
kind
=
=
=
"
import
"
)
errorNumber
=
ambiguous
?
JSMSG_AMBIGUOUS_IMPORT
:
JSMSG_MISSING_IMPORT
;
else
errorNumber
=
ambiguous
?
JSMSG_AMBIGUOUS_INDIRECT_EXPORT
:
JSMSG_MISSING_INDIRECT_EXPORT
;
let
message
=
GetErrorMessage
(
errorNumber
)
+
"
:
"
+
name
;
let
error
=
CreateModuleSyntaxError
(
module
line
column
message
)
;
throw
error
;
}
function
GetModuleEvaluationError
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEvaluationError
"
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
in
GetModuleEvaluationError
"
)
;
return
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
)
;
}
function
RecordModuleEvaluationError
(
module
error
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
RecordModuleEvaluationError
"
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
;
}
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATED_ERROR
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
error
)
;
}
function
ModuleEvaluate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleEvaluate
"
)
;
let
module
=
this
;
if
(
module
.
status
!
=
=
MODULE_STATUS_INSTANTIATED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
let
stack
=
[
]
;
try
{
InnerModuleEvaluation
(
module
stack
0
)
;
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
assert
(
m
.
status
=
=
=
MODULE_STATUS_EVALUATING
"
Bad
module
status
after
failed
evaluation
"
)
;
RecordModuleEvaluationError
(
m
error
)
;
}
if
(
stack
.
length
=
=
=
0
)
RecordModuleEvaluationError
(
module
error
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
failed
evaluation
"
)
;
throw
error
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
successful
evaluation
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
evaluation
"
)
;
return
undefined
;
}
function
InnerModuleEvaluation
(
module
stack
index
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
throw
GetModuleEvaluationError
(
module
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
)
return
index
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
return
index
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_INSTANTIATED
"
Bad
module
status
in
InnerModuleEvaluation
"
)
;
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
index
+
+
;
_DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleSpecifier
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_INSTANTIATED
)
;
index
=
InnerModuleEvaluation
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
InnerModuleEvaluation
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
evaluated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
}
ExecuteModule
(
module
)
;
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_EVALUATED
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
