function
CallModuleResolveHook
(
module
specifier
expectedMinimumState
)
{
let
requestedModule
=
HostResolveImportedModule
(
module
specifier
)
;
if
(
requestedModule
.
state
<
expectedMinimumState
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATE
)
;
return
requestedModule
;
}
function
ModuleGetExportedNames
(
exportStarSet
=
[
]
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportStarSet
"
ModuleGetExportedNames
"
)
;
}
let
module
=
this
;
if
(
callFunction
(
ArrayIncludes
exportStarSet
module
)
)
return
[
]
;
_DefineDataProperty
(
exportStarSet
exportStarSet
.
length
module
)
;
let
exportedNames
=
[
]
;
let
namesCount
=
0
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
_DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
_DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
requestedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATE_INSTANTIATED
)
;
let
starNames
=
callFunction
(
requestedModule
.
getExportedNames
requestedModule
exportStarSet
)
;
for
(
let
j
=
0
;
j
<
starNames
.
length
;
j
+
+
)
{
let
n
=
starNames
[
j
]
;
if
(
n
!
=
=
"
default
"
&
&
!
callFunction
(
ArrayIncludes
exportedNames
n
)
)
_DefineDataProperty
(
exportedNames
namesCount
+
+
n
)
;
}
}
return
exportedNames
;
}
function
ModuleResolveExport
(
exportName
resolveSet
=
[
]
exportStarSet
=
[
]
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportName
resolveSet
exportStarSet
"
ModuleResolveExport
"
)
;
}
let
module
=
this
;
for
(
let
i
=
0
;
i
<
resolveSet
.
length
;
i
+
+
)
{
let
r
=
resolveSet
[
i
]
;
if
(
r
.
module
=
=
=
module
&
&
r
.
exportName
=
=
=
exportName
)
return
null
;
}
_DefineDataProperty
(
resolveSet
resolveSet
.
length
{
module
:
module
exportName
:
exportName
}
)
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
return
{
module
:
module
bindingName
:
e
.
localName
}
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
{
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATE_INSTANTIATED
)
;
let
indirectResolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
e
.
importName
resolveSet
exportStarSet
)
;
if
(
indirectResolution
!
=
=
null
)
return
indirectResolution
;
}
}
if
(
exportName
=
=
=
"
default
"
)
{
ThrowSyntaxError
(
JSMSG_BAD_DEFAULT_EXPORT
)
;
}
if
(
callFunction
(
ArrayIncludes
exportStarSet
module
)
)
return
null
;
_DefineDataProperty
(
exportStarSet
exportStarSet
.
length
module
)
;
let
starResolution
=
null
;
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATE_INSTANTIATED
)
;
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
exportName
resolveSet
exportStarSet
)
;
if
(
resolution
=
=
=
"
ambiguous
"
)
return
resolution
;
if
(
resolution
!
=
=
null
)
{
if
(
starResolution
=
=
=
null
)
{
starResolution
=
resolution
;
}
else
{
if
(
resolution
.
module
!
=
=
starResolution
.
module
|
|
resolution
.
exportName
!
=
=
starResolution
.
exportName
)
{
return
"
ambiguous
"
;
}
}
}
}
return
starResolution
;
}
function
GetModuleNamespace
(
module
)
{
let
namespace
=
module
.
namespace
;
if
(
typeof
namespace
=
=
=
"
undefined
"
)
{
let
exportedNames
=
callFunction
(
module
.
getExportedNames
module
)
;
let
unambiguousNames
=
[
]
;
for
(
let
i
=
0
;
i
<
exportedNames
.
length
;
i
+
+
)
{
let
name
=
exportedNames
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
name
)
;
if
(
resolution
=
=
=
null
)
ThrowSyntaxError
(
JSMSG_MISSING_NAMESPACE_EXPORT
)
;
if
(
resolution
!
=
=
"
ambiguous
"
)
_DefineDataProperty
(
unambiguousNames
unambiguousNames
.
length
name
)
;
}
namespace
=
ModuleNamespaceCreate
(
module
unambiguousNames
)
;
}
return
namespace
;
}
function
ModuleNamespaceCreate
(
module
exports
)
{
callFunction
(
std_Array_sort
exports
)
;
let
ns
=
NewModuleNamespace
(
module
exports
)
;
for
(
let
i
=
0
;
i
<
exports
.
length
;
i
+
+
)
{
let
name
=
exports
[
i
]
;
let
binding
=
callFunction
(
module
.
resolveExport
module
name
)
;
assert
(
binding
!
=
=
null
&
&
binding
!
=
=
"
ambiguous
"
"
Failed
to
resolve
binding
"
)
;
AddModuleNamespaceBinding
(
ns
name
binding
.
module
binding
.
bindingName
)
;
}
return
ns
;
}
function
GetModuleEnvironment
(
module
)
{
assert
(
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEnvironment
"
)
;
if
(
module
.
state
=
=
MODULE_STATE_FAILED
)
ThrowInternalError
(
JSMSG_MODULE_INSTANTIATE_FAILED
)
;
let
env
=
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_ENVIRONMENT_SLOT
)
;
assert
(
env
=
=
=
undefined
|
|
IsModuleEnvironment
(
env
)
"
Module
environment
slot
contains
unexpected
value
"
)
;
return
env
;
}
function
RecordInstantationFailure
(
module
)
{
assert
(
IsModule
(
module
)
"
Non
-
module
passed
to
RecordInstantationFailure
"
)
;
SetModuleState
(
module
MODULE_STATE_FAILED
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_ENVIRONMENT_SLOT
undefined
)
;
}
function
ModuleDeclarationInstantiation
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleDeclarationInstantiation
"
)
;
let
module
=
this
;
if
(
GetModuleEnvironment
(
module
)
!
=
=
undefined
)
return
undefined
;
CreateModuleEnvironment
(
module
)
;
let
env
=
GetModuleEnvironment
(
module
)
;
SetModuleState
(
this
MODULE_STATE_INSTANTIATED
)
;
try
{
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATE_PARSED
)
;
callFunction
(
requiredModule
.
declarationInstantiation
requiredModule
)
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
e
.
exportName
)
;
if
(
resolution
=
=
=
null
)
ThrowSyntaxError
(
JSMSG_MISSING_INDIRECT_EXPORT
e
.
exportName
)
;
if
(
resolution
=
=
=
"
ambiguous
"
)
ThrowSyntaxError
(
JSMSG_AMBIGUOUS_INDIRECT_EXPORT
e
.
exportName
)
;
}
let
importEntries
=
module
.
importEntries
;
for
(
let
i
=
0
;
i
<
importEntries
.
length
;
i
+
+
)
{
let
imp
=
importEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
imp
.
moduleRequest
MODULE_STATE_INSTANTIATED
)
;
if
(
imp
.
importName
=
=
=
"
*
"
)
{
let
namespace
=
GetModuleNamespace
(
importedModule
)
;
CreateNamespaceBinding
(
env
imp
.
localName
namespace
)
;
}
else
{
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
imp
.
importName
)
;
if
(
resolution
=
=
=
null
)
ThrowSyntaxError
(
JSMSG_MISSING_IMPORT
imp
.
importName
)
;
if
(
resolution
=
=
=
"
ambiguous
"
)
ThrowSyntaxError
(
JSMSG_AMBIGUOUS_IMPORT
imp
.
importName
)
;
CreateImportBinding
(
env
imp
.
localName
resolution
.
module
resolution
.
bindingName
)
;
}
}
InstantiateModuleFunctionDeclarations
(
module
)
;
}
catch
(
e
)
{
RecordInstantationFailure
(
module
)
;
throw
e
;
}
}
_SetCanonicalName
(
ModuleDeclarationInstantiation
"
ModuleDeclarationInstantiation
"
)
;
function
ModuleEvaluation
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleEvaluation
"
)
;
let
module
=
this
;
if
(
module
.
state
<
MODULE_STATE_INSTANTIATED
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATE
)
;
if
(
module
.
state
=
=
MODULE_STATE_EVALUATED
)
return
undefined
;
SetModuleState
(
this
MODULE_STATE_EVALUATED
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATE_INSTANTIATED
)
;
callFunction
(
requiredModule
.
evaluation
requiredModule
)
;
}
return
EvaluateModule
(
module
)
;
}
_SetCanonicalName
(
ModuleEvaluation
"
ModuleEvaluation
"
)
;
