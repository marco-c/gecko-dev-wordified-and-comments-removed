function
CallModuleResolveHook
(
module
moduleRequest
expectedMinimumStatus
)
{
let
requestedModule
=
HostResolveImportedModule
(
module
moduleRequest
)
;
if
(
requestedModule
.
status
<
expectedMinimumStatus
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
return
requestedModule
;
}
function
ModuleSetStatus
(
module
newStatus
)
{
assert
(
newStatus
>
=
MODULE_STATUS_UNLINKED
&
&
newStatus
<
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
new
module
status
in
ModuleSetStatus
"
)
;
assert
(
(
module
.
status
<
=
MODULE_STATUS_LINKED
&
&
newStatus
=
=
=
MODULE_STATUS_UNLINKED
)
|
|
newStatus
>
module
.
status
"
New
module
status
inconsistent
with
current
status
"
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_STATUS_SLOT
newStatus
)
;
}
function
CountArrayValues
(
array
value
)
{
let
count
=
0
;
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
count
+
+
;
}
return
count
;
}
function
ArrayContains
(
array
value
)
{
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
return
true
;
}
return
false
;
}
function
HandleModuleInstantiationFailure
(
module
)
{
ModuleSetStatus
(
module
MODULE_STATUS_UNLINKED
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
undefined
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
undefined
)
;
}
function
ModuleInstantiate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleInstantiate
"
)
;
let
module
=
this
;
if
(
module
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
let
stack
=
new_List
(
)
;
try
{
InnerModuleLinking
(
module
stack
0
)
;
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
if
(
m
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
HandleModuleInstantiationFailure
(
m
)
;
}
}
if
(
stack
.
length
=
=
=
0
&
&
module
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
HandleModuleInstantiationFailure
(
module
)
;
}
assert
(
module
.
status
!
=
=
MODULE_STATUS_LINKING
"
Expected
unlinked
status
after
failed
linking
"
)
;
throw
error
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
successful
linking
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
linking
"
)
;
return
undefined
;
}
function
InnerModuleLinking
(
module
stack
index
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
module
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
index
;
}
if
(
module
.
status
!
=
=
MODULE_STATUS_UNLINKED
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
ModuleSetStatus
(
module
MODULE_STATUS_LINKING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
index
+
+
;
DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleRequest
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_UNLINKED
)
;
index
=
InnerModuleLinking
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
required
module
status
after
InnerModuleLinking
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
instantiated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
}
InitializeEnvironment
(
module
)
;
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_LINKED
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
function
GetModuleEvaluationError
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEvaluationError
"
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
in
GetModuleEvaluationError
"
)
;
return
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
)
;
}
function
RecordModuleEvaluationError
(
module
error
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
RecordModuleEvaluationError
"
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
;
}
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATED_ERROR
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
error
)
;
}
function
ModuleEvaluate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleEvaluate
"
)
;
let
module
=
this
;
if
(
module
.
status
!
=
=
MODULE_STATUS_LINKED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
)
{
module
=
GetCycleRoot
(
module
)
;
}
if
(
module
.
topLevelCapability
)
{
return
module
.
topLevelCapability
;
}
const
capability
=
CreateTopLevelCapability
(
module
)
;
let
stack
=
new_List
(
)
;
try
{
InnerModuleEvaluation
(
module
stack
0
)
;
if
(
!
IsAsyncEvaluating
(
module
)
)
{
ModuleTopLevelCapabilityResolve
(
module
)
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
successful
evaluation
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
evaluation
"
)
;
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
assert
(
m
.
status
=
=
=
MODULE_STATUS_EVALUATING
"
Bad
module
status
after
failed
evaluation
"
)
;
RecordModuleEvaluationError
(
m
error
)
;
}
if
(
stack
.
length
=
=
=
0
)
RecordModuleEvaluationError
(
module
error
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
failed
evaluation
"
)
;
ModuleTopLevelCapabilityReject
(
module
error
)
;
}
return
capability
;
}
function
InnerModuleEvaluation
(
module
stack
index
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
throw
GetModuleEvaluationError
(
module
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
)
return
index
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
return
index
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_LINKED
"
Bad
module
status
in
InnerModuleEvaluation
"
)
;
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
0
)
;
index
+
+
;
DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleRequest
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_LINKED
)
;
index
=
InnerModuleEvaluation
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
InnerModuleEvaluation
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
evaluated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
else
{
requiredModule
=
GetCycleRoot
(
requiredModule
)
;
assert
(
requiredModule
.
status
>
=
MODULE_STATUS_EVALUATED
Bad
module
status
in
InnerModuleEvaluation
:
{
requiredModule
.
status
}
)
;
if
(
requiredModule
.
status
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
throw
GetModuleEvaluationError
(
requiredModule
)
;
}
}
if
(
IsAsyncEvaluating
(
requiredModule
)
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
module
.
pendingAsyncDependencies
+
1
)
;
AppendAsyncParentModule
(
requiredModule
module
)
;
}
}
if
(
module
.
pendingAsyncDependencies
>
0
|
|
module
.
async
)
{
InitAsyncEvaluating
(
module
)
;
if
(
module
.
pendingAsyncDependencies
=
=
=
0
)
{
ExecuteAsyncModule
(
module
)
;
}
}
else
{
ExecuteModule
(
module
)
;
}
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
cycleRoot
=
module
;
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_EVALUATED
)
;
SetCycleRoot
(
requiredModule
cycleRoot
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
function
GatherAsyncParentCompletions
(
module
execList
=
new_List
(
)
)
{
assert
(
module
.
status
=
=
MODULE_STATUS_EVALUATED
"
bad
status
for
async
module
"
)
;
let
i
=
0
;
while
(
module
.
asyncParentModules
[
i
]
)
{
const
m
=
module
.
asyncParentModules
[
i
]
;
if
(
GetCycleRoot
(
m
)
.
status
!
=
MODULE_STATUS_EVALUATED_ERROR
&
&
!
callFunction
(
std_Array_includes
execList
m
)
)
{
assert
(
!
m
.
evaluationError
"
should
not
have
evaluation
error
"
)
;
assert
(
m
.
pendingAsyncDependencies
>
0
"
should
have
at
least
one
dependency
"
)
;
UnsafeSetReservedSlot
(
m
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
m
.
pendingAsyncDependencies
-
1
)
;
if
(
m
.
pendingAsyncDependencies
=
=
=
0
)
{
callFunction
(
std_Array_push
execList
m
)
;
if
(
!
m
.
async
)
{
execList
=
GatherAsyncParentCompletions
(
m
execList
)
;
}
}
}
i
+
+
;
}
callFunction
(
ArraySort
execList
(
a
b
)
=
>
a
.
asyncEvaluatingPostOrder
-
b
.
asyncEvaluatingPostOrder
)
;
return
execList
}
function
ExecuteAsyncModule
(
module
)
{
assert
(
module
.
status
=
=
MODULE_STATUS_EVALUATING
|
|
module
.
status
=
=
MODULE_STATUS_EVALUATED
"
bad
status
for
async
module
"
)
;
ExecuteModule
(
module
)
;
}
