function
CallModuleResolveHook
(
module
moduleRequest
expectedMinimumStatus
)
{
let
requestedModule
=
HostResolveImportedModule
(
module
moduleRequest
)
;
if
(
requestedModule
.
status
<
expectedMinimumStatus
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
return
requestedModule
;
}
function
ModuleGetExportedNames
(
exportStarSet
=
[
]
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportStarSet
"
ModuleGetExportedNames
"
)
;
}
let
module
=
this
;
if
(
callFunction
(
ArrayIncludes
exportStarSet
module
)
)
return
[
]
;
DefineDataProperty
(
exportStarSet
exportStarSet
.
length
module
)
;
let
exportedNames
=
[
]
;
let
namesCount
=
0
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
DefineDataProperty
(
exportedNames
namesCount
+
+
e
.
exportName
)
;
}
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
requestedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNLINKED
)
;
let
starNames
=
callFunction
(
requestedModule
.
getExportedNames
requestedModule
exportStarSet
)
;
for
(
let
j
=
0
;
j
<
starNames
.
length
;
j
+
+
)
{
let
n
=
starNames
[
j
]
;
if
(
n
!
=
=
"
default
"
&
&
!
callFunction
(
ArrayIncludes
exportedNames
n
)
)
DefineDataProperty
(
exportedNames
namesCount
+
+
n
)
;
}
}
return
exportedNames
;
}
function
ModuleSetStatus
(
module
newStatus
)
{
assert
(
newStatus
>
=
MODULE_STATUS_UNLINKED
&
&
newStatus
<
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
new
module
status
in
ModuleSetStatus
"
)
;
assert
(
(
module
.
status
<
=
MODULE_STATUS_LINKED
&
&
newStatus
=
=
=
MODULE_STATUS_UNLINKED
)
|
|
newStatus
>
module
.
status
"
New
module
status
inconsistent
with
current
status
"
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_STATUS_SLOT
newStatus
)
;
}
function
ModuleResolveExport
(
exportName
resolveSet
=
[
]
)
{
assert
(
typeof
exportName
=
=
=
"
string
"
"
ModuleResolveExport
"
)
;
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
{
return
callFunction
(
CallModuleMethodIfWrapped
this
exportName
resolveSet
"
ModuleResolveExport
"
)
;
}
let
module
=
this
;
for
(
let
i
=
0
;
i
<
resolveSet
.
length
;
i
+
+
)
{
let
r
=
resolveSet
[
i
]
;
if
(
r
.
module
=
=
=
module
&
&
r
.
exportName
=
=
=
exportName
)
{
return
null
;
}
}
DefineDataProperty
(
resolveSet
resolveSet
.
length
{
module
exportName
}
)
;
let
localExportEntries
=
module
.
localExportEntries
;
for
(
let
i
=
0
;
i
<
localExportEntries
.
length
;
i
+
+
)
{
let
e
=
localExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
return
{
module
bindingName
:
e
.
localName
}
;
}
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
if
(
exportName
=
=
=
e
.
exportName
)
{
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNLINKED
)
;
if
(
e
.
importName
=
=
=
null
)
{
return
{
module
:
importedModule
bindingName
:
"
*
namespace
*
"
}
;
}
return
callFunction
(
importedModule
.
resolveExport
importedModule
e
.
importName
resolveSet
)
;
}
}
if
(
exportName
=
=
=
"
default
"
)
{
return
null
;
}
let
starResolution
=
null
;
let
starExportEntries
=
module
.
starExportEntries
;
for
(
let
i
=
0
;
i
<
starExportEntries
.
length
;
i
+
+
)
{
let
e
=
starExportEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
e
.
moduleRequest
MODULE_STATUS_UNLINKED
)
;
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
exportName
resolveSet
)
;
if
(
resolution
=
=
=
"
ambiguous
"
)
return
resolution
;
if
(
resolution
!
=
=
null
)
{
if
(
starResolution
=
=
=
null
)
{
starResolution
=
resolution
;
}
else
{
if
(
resolution
.
module
!
=
=
starResolution
.
module
|
|
resolution
.
bindingName
!
=
=
starResolution
.
bindingName
)
{
return
"
ambiguous
"
;
}
}
}
}
return
starResolution
;
}
function
IsResolvedBinding
(
resolution
)
{
assert
(
resolution
=
=
=
"
ambiguous
"
|
|
typeof
resolution
=
=
=
"
object
"
"
Bad
module
resolution
result
"
)
;
return
typeof
resolution
=
=
=
"
object
"
&
&
resolution
!
=
=
null
;
}
function
GetModuleNamespace
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
GetModuleNamespace
called
with
non
-
module
"
)
;
assert
(
module
.
status
!
=
=
MODULE_STATUS_UNLINKED
"
Bad
module
state
in
GetModuleNamespace
"
)
;
let
namespace
=
module
.
namespace
;
if
(
typeof
namespace
=
=
=
"
undefined
"
)
{
let
exportedNames
=
callFunction
(
module
.
getExportedNames
module
)
;
let
unambiguousNames
=
[
]
;
for
(
let
i
=
0
;
i
<
exportedNames
.
length
;
i
+
+
)
{
let
name
=
exportedNames
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
name
)
;
if
(
IsResolvedBinding
(
resolution
)
)
DefineDataProperty
(
unambiguousNames
unambiguousNames
.
length
name
)
;
}
namespace
=
ModuleNamespaceCreate
(
module
unambiguousNames
)
;
}
return
namespace
;
}
function
ModuleNamespaceCreate
(
module
exports
)
{
callFunction
(
ArraySort
exports
)
;
let
ns
=
NewModuleNamespace
(
module
exports
)
;
for
(
let
i
=
0
;
i
<
exports
.
length
;
i
+
+
)
{
let
name
=
exports
[
i
]
;
let
binding
=
callFunction
(
module
.
resolveExport
module
name
)
;
assert
(
IsResolvedBinding
(
binding
)
"
Failed
to
resolve
binding
"
)
;
if
(
binding
.
bindingName
=
=
=
"
*
namespace
*
"
)
{
let
namespace
=
GetModuleNamespace
(
binding
.
module
)
;
EnsureModuleEnvironmentNamespace
(
binding
.
module
namespace
)
;
AddModuleNamespaceBinding
(
ns
name
binding
.
module
binding
.
bindingName
)
;
}
else
{
AddModuleNamespaceBinding
(
ns
name
binding
.
module
binding
.
bindingName
)
;
}
}
return
ns
;
}
function
GetModuleEnvironment
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEnvironment
"
)
;
assert
(
module
.
status
>
=
MODULE_STATUS_LINKING
"
Attempt
to
access
module
environement
before
linking
"
)
;
let
env
=
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_ENVIRONMENT_SLOT
)
;
assert
(
IsObject
(
env
)
&
&
IsModuleEnvironment
(
env
)
"
Module
environment
slot
contains
unexpected
value
"
)
;
return
env
;
}
function
CountArrayValues
(
array
value
)
{
let
count
=
0
;
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
count
+
+
;
}
return
count
;
}
function
ArrayContains
(
array
value
)
{
for
(
let
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
=
=
=
value
)
return
true
;
}
return
false
;
}
function
HandleModuleInstantiationFailure
(
module
)
{
ModuleSetStatus
(
module
MODULE_STATUS_UNLINKED
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
undefined
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
undefined
)
;
}
function
ModuleInstantiate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleInstantiate
"
)
;
let
module
=
this
;
if
(
module
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
let
stack
=
[
]
;
try
{
InnerModuleLinking
(
module
stack
0
)
;
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
if
(
m
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
HandleModuleInstantiationFailure
(
m
)
;
}
}
if
(
stack
.
length
=
=
=
0
&
&
module
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
HandleModuleInstantiationFailure
(
module
)
;
}
assert
(
module
.
status
!
=
=
MODULE_STATUS_LINKING
"
Expected
unlinked
status
after
failed
linking
"
)
;
throw
error
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
successful
linking
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
linking
"
)
;
return
undefined
;
}
function
InnerModuleLinking
(
module
stack
index
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
module
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
index
;
}
if
(
module
.
status
!
=
=
MODULE_STATUS_UNLINKED
)
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
ModuleSetStatus
(
module
MODULE_STATUS_LINKING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
index
+
+
;
DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleRequest
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_UNLINKED
)
;
index
=
InnerModuleLinking
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
required
module
status
after
InnerModuleLinking
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
instantiated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_LINKING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
}
callFunction
(
InitializeEnvironment
module
)
;
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_LINKED
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
function
InitializeEnvironment
(
)
{
let
module
=
this
;
let
indirectExportEntries
=
module
.
indirectExportEntries
;
for
(
let
i
=
0
;
i
<
indirectExportEntries
.
length
;
i
+
+
)
{
let
e
=
indirectExportEntries
[
i
]
;
let
resolution
=
callFunction
(
module
.
resolveExport
module
e
.
exportName
)
;
if
(
!
IsResolvedBinding
(
resolution
)
)
{
ThrowResolutionError
(
module
resolution
"
indirectExport
"
e
.
exportName
e
.
lineNumber
e
.
columnNumber
)
;
}
}
let
env
=
GetModuleEnvironment
(
module
)
;
let
importEntries
=
module
.
importEntries
;
for
(
let
i
=
0
;
i
<
importEntries
.
length
;
i
+
+
)
{
let
imp
=
importEntries
[
i
]
;
let
importedModule
=
CallModuleResolveHook
(
module
imp
.
moduleRequest
MODULE_STATUS_LINKING
)
;
if
(
imp
.
importName
=
=
=
null
)
{
let
namespace
=
GetModuleNamespace
(
importedModule
)
;
CreateNamespaceBinding
(
env
imp
.
localName
namespace
)
;
}
else
{
let
resolution
=
callFunction
(
importedModule
.
resolveExport
importedModule
imp
.
importName
)
;
if
(
!
IsResolvedBinding
(
resolution
)
)
{
ThrowResolutionError
(
module
resolution
"
import
"
imp
.
importName
imp
.
lineNumber
imp
.
columnNumber
)
;
}
if
(
resolution
.
bindingName
=
=
=
"
*
namespace
*
"
)
{
let
namespace
=
GetModuleNamespace
(
resolution
.
module
)
;
EnsureModuleEnvironmentNamespace
(
resolution
.
module
namespace
)
;
CreateImportBinding
(
env
imp
.
localName
resolution
.
module
resolution
.
bindingName
)
;
}
else
{
CreateImportBinding
(
env
imp
.
localName
resolution
.
module
resolution
.
bindingName
)
;
}
}
}
InstantiateModuleFunctionDeclarations
(
module
)
;
}
function
ThrowResolutionError
(
module
resolution
kind
name
line
column
)
{
assert
(
module
.
status
=
=
=
MODULE_STATUS_LINKING
"
Unexpected
module
status
in
ThrowResolutionError
"
)
;
assert
(
kind
=
=
=
"
import
"
|
|
kind
=
=
=
"
indirectExport
"
"
Unexpected
kind
in
ThrowResolutionError
"
)
;
assert
(
line
>
0
"
Line
number
should
be
present
for
all
imports
and
indirect
exports
"
)
;
let
ambiguous
=
resolution
=
=
=
"
ambiguous
"
;
let
errorNumber
;
if
(
kind
=
=
=
"
import
"
)
errorNumber
=
ambiguous
?
JSMSG_AMBIGUOUS_IMPORT
:
JSMSG_MISSING_IMPORT
;
else
errorNumber
=
ambiguous
?
JSMSG_AMBIGUOUS_INDIRECT_EXPORT
:
JSMSG_MISSING_INDIRECT_EXPORT
;
let
message
=
GetErrorMessage
(
errorNumber
)
+
"
:
"
+
name
;
let
error
=
CreateModuleSyntaxError
(
module
line
column
message
)
;
throw
error
;
}
function
GetModuleEvaluationError
(
module
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
GetModuleEvaluationError
"
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
in
GetModuleEvaluationError
"
)
;
return
UnsafeGetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
)
;
}
function
RecordModuleEvaluationError
(
module
error
)
{
assert
(
IsObject
(
module
)
&
&
IsModule
(
module
)
"
Non
-
module
passed
to
RecordModuleEvaluationError
"
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
return
;
}
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATED_ERROR
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_EVALUATION_ERROR_SLOT
error
)
;
}
function
ModuleEvaluate
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsModule
(
this
)
)
return
callFunction
(
CallModuleMethodIfWrapped
this
"
ModuleEvaluate
"
)
;
const
isTopLevelAwaitEnabled
=
IsTopLevelAwaitEnabled
(
)
;
let
module
=
this
;
if
(
module
.
status
!
=
=
MODULE_STATUS_LINKED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED
&
&
module
.
status
!
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
ThrowInternalError
(
JSMSG_BAD_MODULE_STATUS
)
;
}
let
capability
=
undefined
;
if
(
isTopLevelAwaitEnabled
)
{
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
)
{
module
=
GetCycleRoot
(
module
)
;
}
if
(
module
.
topLevelCapability
)
{
return
module
.
topLevelCapability
;
}
capability
=
CreateTopLevelCapability
(
module
)
;
}
let
stack
=
[
]
;
try
{
InnerModuleEvaluation
(
module
stack
0
)
;
if
(
isTopLevelAwaitEnabled
)
{
if
(
!
IsAsyncEvaluating
(
module
)
)
{
ModuleTopLevelCapabilityResolve
(
module
)
;
}
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
successful
evaluation
"
)
;
assert
(
stack
.
length
=
=
=
0
"
Stack
should
be
empty
after
successful
evaluation
"
)
;
}
}
catch
(
error
)
{
for
(
let
i
=
0
;
i
<
stack
.
length
;
i
+
+
)
{
let
m
=
stack
[
i
]
;
assert
(
m
.
status
=
=
=
MODULE_STATUS_EVALUATING
"
Bad
module
status
after
failed
evaluation
"
)
;
RecordModuleEvaluationError
(
m
error
)
;
}
if
(
stack
.
length
=
=
=
0
)
RecordModuleEvaluationError
(
module
error
)
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
"
Bad
module
status
after
failed
evaluation
"
)
;
if
(
isTopLevelAwaitEnabled
)
{
ModuleTopLevelCapabilityReject
(
module
error
)
;
}
else
{
throw
error
;
}
}
return
capability
;
}
function
InnerModuleEvaluation
(
module
stack
index
)
{
const
isTopLevelAwaitEnabled
=
IsTopLevelAwaitEnabled
(
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED_ERROR
)
throw
GetModuleEvaluationError
(
module
)
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATED
)
return
index
;
if
(
module
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
return
index
;
assert
(
module
.
status
=
=
=
MODULE_STATUS_LINKED
"
Bad
module
status
in
InnerModuleEvaluation
"
)
;
ModuleSetStatus
(
module
MODULE_STATUS_EVALUATING
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_INDEX_SLOT
index
)
;
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
index
)
;
if
(
isTopLevelAwaitEnabled
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
0
)
;
}
index
+
+
;
DefineDataProperty
(
stack
stack
.
length
module
)
;
let
requestedModules
=
module
.
requestedModules
;
for
(
let
i
=
0
;
i
<
requestedModules
.
length
;
i
+
+
)
{
let
required
=
requestedModules
[
i
]
.
moduleRequest
;
let
requiredModule
=
CallModuleResolveHook
(
module
required
MODULE_STATUS_LINKED
)
;
index
=
InnerModuleEvaluation
(
requiredModule
stack
index
)
;
assert
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
|
|
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATED
"
Bad
module
status
after
InnerModuleEvaluation
"
)
;
assert
(
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
=
=
=
ArrayContains
(
stack
requiredModule
)
"
Required
module
should
be
in
the
stack
iff
it
is
currently
being
evaluated
"
)
;
assert
(
typeof
requiredModule
.
dfsIndex
=
=
=
"
number
"
"
Bad
dfsIndex
"
)
;
assert
(
typeof
requiredModule
.
dfsAncestorIndex
=
=
=
"
number
"
"
Bad
dfsAncestorIndex
"
)
;
if
(
requiredModule
.
status
=
=
=
MODULE_STATUS_EVALUATING
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_DFS_ANCESTOR_INDEX_SLOT
std_Math_min
(
module
.
dfsAncestorIndex
requiredModule
.
dfsAncestorIndex
)
)
;
}
else
{
if
(
isTopLevelAwaitEnabled
)
{
requiredModule
=
GetCycleRoot
(
requiredModule
)
;
assert
(
requiredModule
.
status
>
=
MODULE_STATUS_EVALUATED
Bad
module
status
in
InnerModuleEvaluation
:
{
requiredModule
.
status
}
)
;
if
(
requiredModule
.
status
=
=
MODULE_STATUS_EVALUATED_ERROR
)
{
throw
GetModuleEvaluationError
(
requiredModule
)
;
}
}
}
if
(
isTopLevelAwaitEnabled
)
{
if
(
IsAsyncEvaluating
(
requiredModule
)
)
{
UnsafeSetReservedSlot
(
module
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
module
.
pendingAsyncDependencies
+
1
)
;
AppendAsyncParentModule
(
requiredModule
module
)
;
}
}
}
if
(
isTopLevelAwaitEnabled
)
{
if
(
module
.
pendingAsyncDependencies
>
0
|
|
module
.
async
)
{
InitAsyncEvaluating
(
module
)
;
if
(
module
.
pendingAsyncDependencies
=
=
=
0
)
{
ExecuteAsyncModule
(
module
)
;
}
}
else
{
ExecuteModule
(
module
)
;
}
}
else
{
ExecuteModule
(
module
)
;
}
assert
(
CountArrayValues
(
stack
module
)
=
=
=
1
"
Current
module
should
appear
exactly
once
in
the
stack
"
)
;
assert
(
module
.
dfsAncestorIndex
<
=
module
.
dfsIndex
"
Bad
DFS
ancestor
index
"
)
;
if
(
module
.
dfsAncestorIndex
=
=
=
module
.
dfsIndex
)
{
let
cycleRoot
=
module
;
let
requiredModule
;
do
{
requiredModule
=
callFunction
(
std_Array_pop
stack
)
;
ModuleSetStatus
(
requiredModule
MODULE_STATUS_EVALUATED
)
;
SetCycleRoot
(
requiredModule
cycleRoot
)
;
}
while
(
requiredModule
!
=
=
module
)
;
}
return
index
;
}
function
GatherAsyncParentCompletions
(
module
execList
=
[
]
)
{
assert
(
module
.
status
=
=
MODULE_STATUS_EVALUATED
"
bad
status
for
async
module
"
)
;
let
i
=
0
;
while
(
module
.
asyncParentModules
[
i
]
)
{
const
m
=
module
.
asyncParentModules
[
i
]
;
if
(
GetCycleRoot
(
m
)
.
status
!
=
MODULE_STATUS_EVALUATED_ERROR
&
&
!
callFunction
(
ArrayIncludes
execList
m
)
)
{
assert
(
!
m
.
evaluationError
"
should
not
have
evaluation
error
"
)
;
assert
(
m
.
pendingAsyncDependencies
>
0
"
should
have
at
least
one
dependency
"
)
;
UnsafeSetReservedSlot
(
m
MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT
m
.
pendingAsyncDependencies
-
1
)
;
if
(
m
.
pendingAsyncDependencies
=
=
=
0
)
{
callFunction
(
std_Array_push
execList
m
)
;
if
(
!
m
.
async
)
{
execList
=
GatherAsyncParentCompletions
(
m
execList
)
;
}
}
}
i
+
+
;
}
callFunction
(
ArraySort
execList
(
a
b
)
=
>
a
.
asyncEvaluatingPostOrder
-
b
.
asyncEvaluatingPostOrder
)
;
return
execList
}
function
ExecuteAsyncModule
(
module
)
{
assert
(
module
.
status
=
=
MODULE_STATUS_EVALUATING
|
|
module
.
status
=
=
MODULE_STATUS_EVALUATED
"
bad
status
for
async
module
"
)
;
ExecuteModule
(
module
)
;
}
