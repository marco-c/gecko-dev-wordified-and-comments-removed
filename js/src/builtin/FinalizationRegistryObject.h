#
ifndef
builtin_FinalizationRegistryObject_h
#
define
builtin_FinalizationRegistryObject_h
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
FinalizationRegistryObject
;
class
FinalizationRecordObject
;
class
FinalizationQueueObject
;
class
ObjectWeakMap
;
using
HandleFinalizationRegistryObject
=
Handle
<
FinalizationRegistryObject
*
>
;
using
HandleFinalizationRecordObject
=
Handle
<
FinalizationRecordObject
*
>
;
using
HandleFinalizationQueueObject
=
Handle
<
FinalizationQueueObject
*
>
;
using
RootedFinalizationRegistryObject
=
Rooted
<
FinalizationRegistryObject
*
>
;
using
RootedFinalizationRecordObject
=
Rooted
<
FinalizationRecordObject
*
>
;
using
RootedFinalizationQueueObject
=
Rooted
<
FinalizationQueueObject
*
>
;
class
FinalizationRecordObject
:
public
NativeObject
{
enum
{
WeakRegistrySlot
=
0
HeldValueSlot
SlotCount
}
;
public
:
static
const
JSClass
class_
;
static
FinalizationRecordObject
*
create
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleValue
heldValue
)
;
FinalizationRegistryObject
*
registryDuringGC
(
gc
:
:
GCRuntime
*
gc
)
const
;
FinalizationRegistryObject
*
registryUnbarriered
(
)
const
;
Value
heldValue
(
)
const
;
bool
isActive
(
)
const
;
void
clear
(
)
;
bool
sweep
(
)
;
private
:
static
const
JSClassOps
classOps_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
}
;
using
WeakFinalizationRecordVector
=
GCVector
<
WeakHeapPtr
<
FinalizationRecordObject
*
>
1
js
:
:
ZoneAllocPolicy
>
;
class
FinalizationRegistrationsObject
:
public
NativeObject
{
enum
{
RecordsSlot
=
0
SlotCount
}
;
public
:
static
const
JSClass
class_
;
static
FinalizationRegistrationsObject
*
create
(
JSContext
*
cx
)
;
WeakFinalizationRecordVector
*
records
(
)
;
const
WeakFinalizationRecordVector
*
records
(
)
const
;
bool
isEmpty
(
)
const
;
bool
append
(
HandleFinalizationRecordObject
record
)
;
void
remove
(
HandleFinalizationRecordObject
record
)
;
void
sweep
(
)
;
private
:
static
const
JSClassOps
classOps_
;
void
*
privatePtr
(
)
const
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
}
;
using
FinalizationRecordVector
=
GCVector
<
HeapPtr
<
FinalizationRecordObject
*
>
1
js
:
:
ZoneAllocPolicy
>
;
using
FinalizationRecordSet
=
GCHashSet
<
HeapPtrObject
MovableCellHasher
<
HeapPtrObject
>
ZoneAllocPolicy
>
;
class
FinalizationRegistryObject
:
public
NativeObject
{
enum
{
QueueSlot
=
0
RegistrationsSlot
ActiveRecords
SlotCount
}
;
public
:
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
FinalizationQueueObject
*
queue
(
)
const
;
ObjectWeakMap
*
registrations
(
)
const
;
FinalizationRecordSet
*
activeRecords
(
)
const
;
void
sweep
(
)
;
static
bool
unregisterRecord
(
FinalizationRecordObject
*
record
)
;
static
bool
cleanupQueuedRecords
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleObject
callback
=
nullptr
)
;
private
:
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
const
JSFunctionSpec
methods_
[
]
;
static
const
JSPropertySpec
properties_
[
]
;
static
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
register_
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
unregister
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
cleanupSome
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
addRegistration
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleObject
unregisterToken
HandleFinalizationRecordObject
record
)
;
static
void
removeRegistrationOnError
(
HandleFinalizationRegistryObject
registry
HandleObject
unregisterToken
HandleFinalizationRecordObject
record
)
;
static
bool
preserveDOMWrapper
(
JSContext
*
cx
HandleObject
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
}
;
class
FinalizationQueueObject
:
public
NativeObject
{
enum
{
RegistrySlot
=
0
CleanupCallbackSlot
IncumbentObjectSlot
RecordsToBeCleanedUpSlot
IsQueuedForCleanupSlot
DoCleanupFunctionSlot
SlotCount
}
;
enum
DoCleanupFunctionSlots
{
DoCleanupFunction_QueueSlot
=
0
}
;
public
:
static
const
JSClass
class_
;
FinalizationRegistryObject
*
registry
(
)
const
;
JSObject
*
cleanupCallback
(
)
const
;
JSObject
*
incumbentObject
(
)
const
;
FinalizationRecordVector
*
recordsToBeCleanedUp
(
)
const
;
bool
isQueuedForCleanup
(
)
const
;
JSFunction
*
doCleanupFunction
(
)
const
;
void
queueRecordToBeCleanedUp
(
FinalizationRecordObject
*
record
)
;
void
setQueuedForCleanup
(
bool
value
)
;
static
FinalizationQueueObject
*
create
(
JSContext
*
cx
HandleFinalizationRegistryObject
registry
HandleObject
cleanupCallback
)
;
static
bool
cleanupQueuedRecords
(
JSContext
*
cx
HandleFinalizationQueueObject
registry
HandleObject
callback
=
nullptr
)
;
private
:
static
const
JSClassOps
classOps_
;
static
bool
doCleanup
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
}
;
}
#
endif
