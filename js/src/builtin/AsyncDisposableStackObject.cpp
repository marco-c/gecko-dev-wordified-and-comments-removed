#
include
"
builtin
/
AsyncDisposableStackObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
UsingHint
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
AsyncDisposableStackObject
*
AsyncDisposableStackObject
:
:
create
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proto
JS
:
:
Handle
<
JS
:
:
Value
>
initialDisposeCapability
)
{
AsyncDisposableStackObject
*
obj
=
NewObjectWithClassProto
<
AsyncDisposableStackObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
initialDisposeCapability
.
isUndefined
(
)
|
|
initialDisposeCapability
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
initialDisposeCapability
.
isObject
(
)
initialDisposeCapability
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
)
;
obj
-
>
initReservedSlot
(
AsyncDisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
initialDisposeCapability
)
;
obj
-
>
initReservedSlot
(
AsyncDisposableStackObject
:
:
STATE_SLOT
JS
:
:
Int32Value
(
int32_t
(
AsyncDisposableStackObject
:
:
DisposableState
:
:
Pending
)
)
)
;
return
obj
;
}
bool
AsyncDisposableStackObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
AsyncDisposableStack
"
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_AsyncDisposableStack
&
proto
)
)
{
return
false
;
}
AsyncDisposableStackObject
*
obj
=
AsyncDisposableStackObject
:
:
create
(
cx
proto
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
is
(
JS
:
:
Handle
<
JS
:
:
Value
>
val
)
{
return
val
.
isObject
(
)
&
&
val
.
toObject
(
)
.
is
<
AsyncDisposableStackObject
>
(
)
;
}
bool
AsyncDisposableStackObject
:
:
use_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
AsyncDisposableStackObject
*
>
asyncDisposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
AsyncDisposableStackObject
>
(
)
)
;
if
(
asyncDisposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
asyncDisposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
args
.
get
(
0
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
val
UsingHint
:
:
Async
JS
:
:
NothingHandleValue
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
val
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
use
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
use_impl
>
(
cx
args
)
;
}
bool
AsyncDisposableStackObject
:
:
disposed_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
AsyncDisposableStackObject
*
>
disposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
AsyncDisposableStackObject
>
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
disposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
disposed
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
disposed_impl
>
(
cx
args
)
;
}
bool
AsyncDisposableStackObject
:
:
move_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
AsyncDisposableStackObject
*
>
asyncDisposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
AsyncDisposableStackObject
>
(
)
)
;
if
(
asyncDisposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
existingDisposeCapability
(
cx
asyncDisposableStack
-
>
getReservedSlot
(
AsyncDisposableStackObject
:
:
DISPOSABLE_RESOURCE_STACK_SLOT
)
)
;
AsyncDisposableStackObject
*
newAsyncDisposableStack
=
AsyncDisposableStackObject
:
:
create
(
cx
nullptr
existingDisposeCapability
)
;
if
(
!
newAsyncDisposableStack
)
{
return
false
;
}
asyncDisposableStack
-
>
clearDisposableResourceStack
(
)
;
asyncDisposableStack
-
>
setState
(
DisposableState
:
:
Disposed
)
;
args
.
rval
(
)
.
setObject
(
*
newAsyncDisposableStack
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
move
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
move_impl
>
(
cx
args
)
;
}
bool
AsyncDisposableStackObject
:
:
defer_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
AsyncDisposableStackObject
*
>
asyncDisposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
AsyncDisposableStackObject
>
(
)
)
;
if
(
asyncDisposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDisposeAsync
=
args
.
get
(
0
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDisposeAsync
)
)
{
return
false
;
}
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
asyncDisposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
onDisposeAsyncVal
(
cx
mozilla
:
:
Some
(
onDisposeAsync
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Async
onDisposeAsyncVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
defer
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
defer_impl
>
(
cx
args
)
;
}
bool
AsyncDisposableStackObject
:
:
adopt_impl
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
AsyncDisposableStackObject
*
>
asyncDisposableStack
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
AsyncDisposableStackObject
>
(
)
)
;
if
(
asyncDisposableStack
-
>
state
(
)
=
=
DisposableState
:
:
Disposed
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DISPOSABLE_STACK_DISPOSED
)
;
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
onDisposeAsync
=
args
.
get
(
1
)
;
if
(
!
ThrowIfOnDisposeNotCallable
(
cx
onDisposeAsync
)
)
{
return
false
;
}
JS
:
:
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty_
;
JS
:
:
Rooted
<
JSFunction
*
>
F
(
cx
NewNativeFunction
(
cx
AdoptClosure
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
F
)
{
return
false
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
value
=
args
.
get
(
0
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_ValueSlot
value
)
;
F
-
>
initExtendedSlot
(
AdoptClosureSlot_OnDisposeSlot
onDisposeAsync
)
;
JS
:
:
Rooted
<
ArrayObject
*
>
disposeCapability
(
cx
asyncDisposableStack
-
>
getOrCreateDisposeCapability
(
cx
)
)
;
if
(
!
disposeCapability
)
{
return
false
;
}
JS
:
:
Rooted
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
FVal
(
cx
mozilla
:
:
Some
(
ObjectValue
(
*
F
)
)
)
;
if
(
!
AddDisposableResource
(
cx
disposeCapability
JS
:
:
UndefinedHandleValue
UsingHint
:
:
Async
FVal
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
value
)
;
return
true
;
}
bool
AsyncDisposableStackObject
:
:
adopt
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
JS
:
:
CallNonGenericMethod
<
is
adopt_impl
>
(
cx
args
)
;
}
const
JSPropertySpec
AsyncDisposableStackObject
:
:
properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
AsyncDisposableStack
"
JSPROP_READONLY
)
JS_PSG
(
"
disposed
"
disposed
0
)
JS_PS_END
}
;
const
JSFunctionSpec
AsyncDisposableStackObject
:
:
methods
[
]
=
{
JS_FN
(
"
adopt
"
AsyncDisposableStackObject
:
:
adopt
2
0
)
JS_FN
(
"
defer
"
AsyncDisposableStackObject
:
:
defer
1
0
)
JS_SELF_HOSTED_FN
(
"
disposeAsync
"
"
AsyncDisposableStackDisposeAsync
"
0
0
)
JS_FN
(
"
move
"
AsyncDisposableStackObject
:
:
move
0
0
)
JS_FN
(
"
use
"
AsyncDisposableStackObject
:
:
use
1
0
)
JS_SELF_HOSTED_SYM_FN
(
asyncDispose
"
AsyncDisposableStackDisposeAsync
"
0
0
)
JS_FS_END
}
;
const
ClassSpec
AsyncDisposableStackObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
AsyncDisposableStackObject
:
:
construct
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
AsyncDisposableStackObject
>
nullptr
nullptr
AsyncDisposableStackObject
:
:
methods
AsyncDisposableStackObject
:
:
properties
nullptr
}
;
const
JSClass
AsyncDisposableStackObject
:
:
class_
=
{
"
AsyncDisposableStack
"
JSCLASS_HAS_RESERVED_SLOTS
(
AsyncDisposableStackObject
:
:
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_AsyncDisposableStack
)
JS_NULL_CLASS_OPS
&
AsyncDisposableStackObject
:
:
classSpec_
}
;
const
JSClass
AsyncDisposableStackObject
:
:
protoClass_
=
{
"
AsyncDisposableStack
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_AsyncDisposableStack
)
JS_NULL_CLASS_OPS
&
AsyncDisposableStackObject
:
:
classSpec_
}
;
