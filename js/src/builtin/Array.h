#
ifndef
builtin_Array_h
#
define
builtin_Array_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
vm
/
JSObject
.
h
"
namespace
js
{
namespace
jit
{
class
TrampolineNativeFrameLayout
;
}
class
ArrayObject
;
MOZ_ALWAYS_INLINE
bool
IdIsIndex
(
jsid
id
uint32_t
*
indexp
)
{
if
(
id
.
isInt
(
)
)
{
int32_t
i
=
id
.
toInt
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
*
indexp
=
uint32_t
(
i
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
!
id
.
isAtom
(
)
)
)
{
return
false
;
}
JSAtom
*
atom
=
id
.
toAtom
(
)
;
return
atom
-
>
isIndex
(
indexp
)
;
}
extern
ArrayObject
*
NewDenseEmptyArray
(
JSContext
*
cx
)
;
extern
ArrayObject
*
NewTenuredDenseEmptyArray
(
JSContext
*
cx
)
;
extern
ArrayObject
*
NewDenseUnallocatedArray
(
JSContext
*
cx
uint32_t
length
NewObjectKind
newKind
=
GenericObject
)
;
extern
ArrayObject
*
NewDenseFullyAllocatedArray
(
JSContext
*
cx
uint32_t
length
NewObjectKind
newKind
=
GenericObject
gc
:
:
AllocSite
*
site
=
nullptr
)
;
extern
ArrayObject
*
NewDensePartlyAllocatedArray
(
JSContext
*
cx
uint32_t
length
NewObjectKind
newKind
=
GenericObject
)
;
extern
ArrayObject
*
NewDensePartlyAllocatedArrayWithProto
(
JSContext
*
cx
uint32_t
length
HandleObject
proto
)
;
extern
ArrayObject
*
NewDenseCopiedArray
(
JSContext
*
cx
uint32_t
length
const
Value
*
values
NewObjectKind
newKind
=
GenericObject
)
;
extern
ArrayObject
*
NewDenseCopiedArray
(
JSContext
*
cx
uint32_t
length
JSLinearString
*
*
values
NewObjectKind
newKind
=
GenericObject
)
;
extern
ArrayObject
*
NewDenseCopiedArrayWithProto
(
JSContext
*
cx
uint32_t
length
const
Value
*
values
HandleObject
proto
)
;
extern
ArrayObject
*
NewDenseFullyAllocatedArrayWithShape
(
JSContext
*
cx
uint32_t
length
Handle
<
SharedShape
*
>
shape
)
;
extern
ArrayObject
*
NewArrayWithShape
(
JSContext
*
cx
uint32_t
length
Handle
<
Shape
*
>
shape
)
;
extern
bool
ToLength
(
JSContext
*
cx
HandleValue
v
uint64_t
*
out
)
;
extern
bool
GetLengthProperty
(
JSContext
*
cx
HandleObject
obj
uint64_t
*
lengthp
)
;
extern
bool
SetLengthProperty
(
JSContext
*
cx
HandleObject
obj
uint32_t
length
)
;
extern
bool
GetElements
(
JSContext
*
cx
HandleObject
aobj
uint32_t
length
js
:
:
Value
*
vp
)
;
extern
bool
array_includes
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
bool
array_indexOf
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
bool
array_lastIndexOf
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
bool
array_pop
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
bool
array_join
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
bool
array_sort
(
JSContext
*
cx
unsigned
argc
js
:
:
Value
*
vp
)
;
extern
void
ArrayShiftMoveElements
(
ArrayObject
*
arr
)
;
extern
JSObject
*
ArraySliceDense
(
JSContext
*
cx
HandleObject
obj
int32_t
begin
int32_t
end
HandleObject
result
)
;
extern
JSObject
*
ArgumentsSliceDense
(
JSContext
*
cx
HandleObject
obj
int32_t
begin
int32_t
end
HandleObject
result
)
;
extern
ArrayObject
*
NewArrayWithNullProto
(
JSContext
*
cx
)
;
extern
bool
NewbornArrayPush
(
JSContext
*
cx
HandleObject
obj
const
Value
&
v
)
;
extern
ArrayObject
*
ArrayConstructorOneArg
(
JSContext
*
cx
Handle
<
ArrayObject
*
>
templateObject
int32_t
lengthInt
)
;
#
ifdef
DEBUG
extern
bool
ArrayInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
#
endif
extern
bool
ArrayConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
array_construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
JSString
*
ArrayToSource
(
JSContext
*
cx
HandleObject
obj
)
;
extern
bool
IsCrossRealmArrayConstructor
(
JSContext
*
cx
JSObject
*
obj
bool
*
result
)
;
extern
bool
ObjectMayHaveExtraIndexedOwnProperties
(
JSObject
*
obj
)
;
extern
bool
ObjectMayHaveExtraIndexedProperties
(
JSObject
*
obj
)
;
extern
bool
PrototypeMayHaveIndexedProperties
(
NativeObject
*
obj
)
;
extern
bool
IsArrayFromJit
(
JSContext
*
cx
HandleObject
obj
bool
*
isArray
)
;
extern
bool
ArrayLengthGetter
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleValue
vp
)
;
extern
bool
ArrayLengthSetter
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
ObjectOpResult
&
result
)
;
enum
class
ArraySortResult
:
uint32_t
{
Failure
Done
CallJS
CallJSSameRealmNoRectifier
}
;
class
ArraySortData
{
public
:
enum
class
ComparatorKind
:
uint8_t
{
Unoptimized
JS
JSSameRealmNoRectifier
}
;
static
constexpr
size_t
ComparatorActualArgs
=
2
;
static
constexpr
size_t
InsertionSortLimit
=
24
;
using
ValueVector
=
GCVector
<
Value
8
SystemAllocPolicy
>
;
private
:
uintptr_t
descriptor_
;
JSObject
*
comparator_
=
nullptr
;
Value
thisv
;
Value
callArgs
[
ComparatorActualArgs
]
;
ValueVector
vec
;
Value
item
;
JSContext
*
cx_
;
JSObject
*
obj_
=
nullptr
;
Value
*
list
;
Value
*
out
;
uint32_t
length
;
uint32_t
denseLen
;
uint32_t
windowSize
;
uint32_t
start
;
uint32_t
mid
;
uint32_t
end
;
uint32_t
i
j
k
;
enum
class
State
:
uint8_t
{
Initial
InsertionSortCall1
InsertionSortCall2
MergeSortCall1
MergeSortCall2
}
;
State
state
=
State
:
:
Initial
;
ComparatorKind
comparatorKind_
;
#
if
!
defined
(
JS_64BIT
)
&
&
!
defined
(
DEBUG
)
protected
:
size_t
padding
;
#
endif
public
:
explicit
ArraySortData
(
JSContext
*
cx
)
;
void
MOZ_ALWAYS_INLINE
init
(
JSObject
*
obj
JSObject
*
comparator
ValueVector
&
&
vec
uint32_t
length
uint32_t
denseLen
)
;
JSContext
*
cx
(
)
const
{
return
cx_
;
}
JSObject
*
comparator
(
)
const
{
MOZ_ASSERT
(
comparator_
)
;
return
comparator_
;
}
Value
returnValue
(
)
const
{
return
callArgs
[
0
]
;
}
void
setReturnValue
(
JSObject
*
obj
)
{
callArgs
[
0
]
.
setObject
(
*
obj
)
;
}
Value
comparatorArg
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
ComparatorActualArgs
)
;
return
callArgs
[
index
]
;
}
Value
comparatorThisValue
(
)
const
{
return
thisv
;
}
Value
comparatorReturnValue
(
)
const
{
return
callArgs
[
0
]
;
}
void
setComparatorArgs
(
const
Value
&
x
const
Value
&
y
)
{
callArgs
[
0
]
=
x
;
callArgs
[
1
]
=
y
;
}
void
setComparatorReturnValue
(
const
Value
&
v
)
{
callArgs
[
0
]
=
v
;
}
ComparatorKind
comparatorKind
(
)
const
{
return
comparatorKind_
;
}
void
initDescriptor
(
uintptr_t
descriptor
)
{
descriptor_
=
descriptor
;
}
static
ArraySortResult
sortWithComparator
(
ArraySortData
*
d
)
;
void
freeMallocData
(
)
;
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
int32_t
offsetOfDescriptor
(
)
{
return
offsetof
(
ArraySortData
descriptor_
)
;
}
static
constexpr
int32_t
offsetOfComparator
(
)
{
return
offsetof
(
ArraySortData
comparator_
)
;
}
static
constexpr
int32_t
offsetOfComparatorReturnValue
(
)
{
return
offsetof
(
ArraySortData
callArgs
[
0
]
)
;
}
static
constexpr
int32_t
offsetOfComparatorThis
(
)
{
return
offsetof
(
ArraySortData
thisv
)
;
}
static
constexpr
int32_t
offsetOfComparatorArgs
(
)
{
return
offsetof
(
ArraySortData
callArgs
)
;
}
}
;
extern
ArraySortResult
ArraySortFromJit
(
JSContext
*
cx
jit
:
:
TrampolineNativeFrameLayout
*
frame
)
;
class
MOZ_NON_TEMPORARY_CLASS
ArraySpeciesLookup
final
{
MOZ_INIT_OUTSIDE_CTOR
NativeObject
*
arrayProto_
;
MOZ_INIT_OUTSIDE_CTOR
NativeObject
*
arrayConstructor_
;
MOZ_INIT_OUTSIDE_CTOR
Shape
*
arrayConstructorShape_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
arraySpeciesGetterSlot_
;
MOZ_INIT_OUTSIDE_CTOR
JSFunction
*
canonicalSpeciesFunc_
;
MOZ_INIT_OUTSIDE_CTOR
Shape
*
arrayProtoShape_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
arrayProtoConstructorSlot_
;
enum
class
State
:
uint8_t
{
Uninitialized
Initialized
Disabled
}
;
State
state_
=
State
:
:
Uninitialized
;
void
initialize
(
JSContext
*
cx
)
;
void
reset
(
)
;
bool
isArrayStateStillSane
(
)
;
public
:
ArraySpeciesLookup
(
)
{
reset
(
)
;
}
bool
tryOptimizeArray
(
JSContext
*
cx
ArrayObject
*
array
)
;
void
purge
(
)
{
if
(
state_
=
=
State
:
:
Initialized
)
{
reset
(
)
;
}
}
}
;
}
#
endif
