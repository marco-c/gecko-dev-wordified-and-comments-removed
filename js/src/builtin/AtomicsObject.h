#
ifndef
builtin_AtomicsObject_h
#
define
builtin_AtomicsObject_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
namespace
js
{
class
AtomicsObject
:
public
JSObject
{
public
:
static
const
Class
class_
;
static
JSObject
*
initClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
MOZ_MUST_USE
bool
toString
(
JSContext
*
cx
unsigned
int
argc
Value
*
vp
)
;
}
;
MOZ_MUST_USE
bool
atomics_compareExchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_exchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_load
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_store
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_sub
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_and
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_or
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_xor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_isLockFree
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_wait
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_wake
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
namespace
wasm
{
class
Instance
;
}
int32_t
atomics_add_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
int32_t
atomics_sub_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
int32_t
atomics_and_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
int32_t
atomics_or_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
int32_t
atomics_xor_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
int32_t
atomics_cmpxchg_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
oldval
int32_t
newval
)
;
int32_t
atomics_xchg_asm_callout
(
wasm
:
:
Instance
*
i
int32_t
vt
int32_t
offset
int32_t
value
)
;
class
FutexRuntime
{
friend
class
AutoLockFutexAPI
;
public
:
static
MOZ_MUST_USE
bool
initialize
(
)
;
static
void
destroy
(
)
;
static
void
lock
(
)
;
static
void
unlock
(
)
;
FutexRuntime
(
)
;
MOZ_MUST_USE
bool
initInstance
(
)
;
void
destroyInstance
(
)
;
enum
WakeReason
{
WakeExplicit
WakeForJSInterrupt
}
;
enum
WaitResult
{
FutexOK
FutexTimedOut
}
;
MOZ_MUST_USE
bool
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
WaitResult
*
result
)
;
void
wake
(
WakeReason
reason
)
;
bool
isWaiting
(
)
;
bool
canWait
(
)
{
return
canWait_
;
}
void
setCanWait
(
bool
flag
)
{
canWait_
=
flag
;
}
private
:
enum
FutexState
{
Idle
Waiting
WaitingNotifiedForInterrupt
WaitingInterrupted
Woken
}
;
js
:
:
ConditionVariable
*
cond_
;
FutexState
state_
;
static
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
>
lock_
;
bool
canWait_
;
}
;
JSObject
*
InitAtomicsClass
(
JSContext
*
cx
HandleObject
obj
)
;
}
#
endif
