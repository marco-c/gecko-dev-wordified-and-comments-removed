#
ifndef
builtin_AtomicsObject_h
#
define
builtin_AtomicsObject_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
GlobalObject
;
class
SharedArrayRawBuffer
;
class
AtomicsObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
static
JSObject
*
initClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
MOZ_MUST_USE
bool
toString
(
JSContext
*
cx
unsigned
int
argc
Value
*
vp
)
;
}
;
MOZ_MUST_USE
bool
atomics_compareExchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_exchange
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_load
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_store
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_add
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_sub
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_and
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_or
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_xor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_isLockFree
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_wait
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
MOZ_MUST_USE
bool
atomics_wake
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
class
FutexThread
{
friend
class
AutoLockFutexAPI
;
public
:
static
MOZ_MUST_USE
bool
initialize
(
)
;
static
void
destroy
(
)
;
static
void
lock
(
)
;
static
void
unlock
(
)
;
FutexThread
(
)
;
MOZ_MUST_USE
bool
initInstance
(
)
;
void
destroyInstance
(
)
;
enum
WakeReason
{
WakeExplicit
WakeForJSInterrupt
}
;
enum
class
WaitResult
{
Error
NotEqual
OK
TimedOut
}
;
MOZ_MUST_USE
WaitResult
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
void
wake
(
WakeReason
reason
)
;
bool
isWaiting
(
)
;
bool
canWait
(
)
{
return
canWait_
;
}
void
setCanWait
(
bool
flag
)
{
canWait_
=
flag
;
}
private
:
enum
FutexState
{
Idle
Waiting
WaitingNotifiedForInterrupt
WaitingInterrupted
Woken
}
;
js
:
:
ConditionVariable
*
cond_
;
FutexState
state_
;
static
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
>
lock_
;
ThreadData
<
bool
>
canWait_
;
}
;
JSObject
*
InitAtomicsClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
MOZ_MUST_USE
FutexThread
:
:
WaitResult
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int32_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
MOZ_MUST_USE
FutexThread
:
:
WaitResult
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int64_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
MOZ_MUST_USE
int64_t
atomics_wake_impl
(
SharedArrayRawBuffer
*
sarb
uint32_t
byteOffset
int64_t
count
)
;
}
#
endif
