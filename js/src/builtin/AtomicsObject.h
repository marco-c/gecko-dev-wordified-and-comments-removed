#
ifndef
builtin_AtomicsObject_h
#
define
builtin_AtomicsObject_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
SharedArrayRawBuffer
;
class
AtomicsObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
class
FutexThread
{
friend
class
AutoLockFutexAPI
;
public
:
[
[
nodiscard
]
]
static
bool
initialize
(
)
;
static
void
destroy
(
)
;
static
void
lock
(
)
;
static
void
unlock
(
)
;
FutexThread
(
)
;
[
[
nodiscard
]
]
bool
initInstance
(
)
;
void
destroyInstance
(
)
;
enum
NotifyReason
{
NotifyExplicit
NotifyForJSInterrupt
}
;
enum
class
WaitResult
{
Error
NotEqual
OK
TimedOut
}
;
[
[
nodiscard
]
]
WaitResult
wait
(
JSContext
*
cx
js
:
:
UniqueLock
<
js
:
:
Mutex
>
&
locked
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
void
notify
(
NotifyReason
reason
)
;
bool
isWaiting
(
)
;
bool
canWait
(
)
{
return
canWait_
;
}
void
setCanWait
(
bool
flag
)
{
canWait_
=
flag
;
}
private
:
enum
FutexState
{
Idle
Waiting
WaitingNotifiedForInterrupt
WaitingInterrupted
Woken
}
;
js
:
:
ConditionVariable
*
cond_
;
FutexState
state_
;
static
mozilla
:
:
Atomic
<
js
:
:
Mutex
*
mozilla
:
:
SequentiallyConsistent
>
lock_
;
ThreadData
<
bool
>
canWait_
;
}
;
[
[
nodiscard
]
]
FutexThread
:
:
WaitResult
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int32_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
[
[
nodiscard
]
]
FutexThread
:
:
WaitResult
atomics_wait_impl
(
JSContext
*
cx
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int64_t
value
const
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
&
timeout
)
;
[
[
nodiscard
]
]
int64_t
atomics_notify_impl
(
SharedArrayRawBuffer
*
sarb
size_t
byteOffset
int64_t
count
)
;
}
#
endif
