#
include
"
builtin
/
Eval
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
friend
/
JSMEnvironment
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
FrameIter
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSONParser
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
AddToHash
;
using
JS
:
:
AutoCheckCannotGC
;
using
JS
:
:
AutoStableStringChars
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
SourceText
;
static
void
AssertInnerizedEnvironmentChain
(
JSContext
*
cx
JSObject
&
env
)
{
#
ifdef
DEBUG
RootedObject
obj
(
cx
)
;
for
(
obj
=
&
env
;
obj
;
obj
=
obj
-
>
enclosingEnvironment
(
)
)
{
MOZ_ASSERT
(
!
IsWindowProxy
(
obj
)
)
;
}
#
endif
}
static
bool
IsEvalCacheCandidate
(
JSScript
*
script
)
{
if
(
!
script
-
>
isDirectEvalInFunction
(
)
)
{
return
false
;
}
for
(
JS
:
:
GCCellPtr
gcThing
:
script
-
>
gcthings
(
)
)
{
if
(
gcThing
.
is
<
JSObject
>
(
)
)
{
return
false
;
}
}
return
true
;
}
HashNumber
EvalCacheHashPolicy
:
:
hash
(
const
EvalCacheLookup
&
l
)
{
HashNumber
hash
=
HashStringChars
(
l
.
str
)
;
return
AddToHash
(
hash
l
.
callerScript
l
.
pc
)
;
}
bool
EvalCacheHashPolicy
:
:
match
(
const
EvalCacheEntry
&
cacheEntry
const
EvalCacheLookup
&
l
)
{
MOZ_ASSERT
(
IsEvalCacheCandidate
(
cacheEntry
.
script
)
)
;
return
EqualStrings
(
cacheEntry
.
str
l
.
str
)
&
&
cacheEntry
.
callerScript
=
=
l
.
callerScript
&
&
cacheEntry
.
pc
=
=
l
.
pc
;
}
void
EvalCacheLookup
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
str
"
EvalCacheLookup
:
:
str
"
)
;
TraceNullableRoot
(
trc
&
callerScript
"
EvalCacheLookup
:
:
callerScript
"
)
;
}
class
EvalScriptGuard
{
JSContext
*
cx_
;
Rooted
<
JSScript
*
>
script_
;
Rooted
<
EvalCacheLookup
>
lookup_
;
mozilla
:
:
Maybe
<
DependentAddPtr
<
EvalCache
>
>
p_
;
Rooted
<
JSLinearString
*
>
lookupStr_
;
public
:
explicit
EvalScriptGuard
(
JSContext
*
cx
)
:
cx_
(
cx
)
script_
(
cx
)
lookup_
(
cx
)
lookupStr_
(
cx
)
{
}
~
EvalScriptGuard
(
)
{
if
(
script_
&
&
!
cx_
-
>
isExceptionPending
(
)
)
{
script_
-
>
cacheForEval
(
)
;
EvalCacheLookup
&
lookup
=
lookup_
.
get
(
)
;
EvalCacheEntry
cacheEntry
=
{
lookupStr_
script_
lookup
.
callerScript
lookup
.
pc
}
;
lookup
.
str
=
lookupStr_
;
if
(
lookup
.
str
&
&
IsEvalCacheCandidate
(
script_
)
)
{
if
(
!
p_
-
>
add
(
cx_
cx_
-
>
caches
(
)
.
evalCache
lookup
cacheEntry
)
)
{
cx_
-
>
recoverFromOutOfMemory
(
)
;
}
}
}
}
void
lookupInEvalCache
(
JSLinearString
*
str
JSScript
*
callerScript
jsbytecode
*
pc
)
{
lookupStr_
=
str
;
EvalCacheLookup
&
lookup
=
lookup_
.
get
(
)
;
lookup
.
str
=
str
;
lookup
.
callerScript
=
callerScript
;
lookup
.
pc
=
pc
;
p_
.
emplace
(
cx_
cx_
-
>
caches
(
)
.
evalCache
lookup
)
;
if
(
*
p_
)
{
script_
=
(
*
p_
)
-
>
script
;
p_
-
>
remove
(
cx_
cx_
-
>
caches
(
)
.
evalCache
lookup
)
;
}
}
void
setNewScript
(
JSScript
*
script
)
{
MOZ_ASSERT
(
!
script_
&
&
script
)
;
script_
=
script
;
}
bool
foundScript
(
)
{
return
!
!
script_
;
}
HandleScript
script
(
)
{
MOZ_ASSERT
(
script_
)
;
return
script_
;
}
}
;
enum
class
EvalJSONResult
{
Failure
Success
NotJSON
}
;
template
<
typename
CharT
>
static
bool
EvalStringMightBeJSON
(
const
mozilla
:
:
Range
<
const
CharT
>
chars
)
{
size_t
length
=
chars
.
length
(
)
;
if
(
length
<
2
)
{
return
false
;
}
CharT
first
=
chars
[
0
]
last
=
chars
[
length
-
1
]
;
return
(
first
=
=
'
[
'
&
&
last
=
=
'
]
'
)
|
|
(
first
=
=
'
(
'
&
&
last
=
=
'
)
'
)
;
}
template
<
typename
CharT
>
static
EvalJSONResult
ParseEvalStringAsJSON
(
JSContext
*
cx
const
mozilla
:
:
Range
<
const
CharT
>
chars
MutableHandleValue
rval
)
{
size_t
len
=
chars
.
length
(
)
;
MOZ_ASSERT
(
(
chars
[
0
]
=
=
'
(
'
&
&
chars
[
len
-
1
]
=
=
'
)
'
)
|
|
(
chars
[
0
]
=
=
'
[
'
&
&
chars
[
len
-
1
]
=
=
'
]
'
)
)
;
auto
jsonChars
=
(
chars
[
0
]
=
=
'
[
'
)
?
chars
:
mozilla
:
:
Range
<
const
CharT
>
(
chars
.
begin
(
)
.
get
(
)
+
1U
len
-
2
)
;
Rooted
<
JSONParser
<
CharT
>
>
parser
(
cx
cx
jsonChars
JSONParser
<
CharT
>
:
:
ParseType
:
:
AttemptForEval
)
;
if
(
!
parser
.
parse
(
rval
)
)
{
return
EvalJSONResult
:
:
Failure
;
}
return
rval
.
isUndefined
(
)
?
EvalJSONResult
:
:
NotJSON
:
EvalJSONResult
:
:
Success
;
}
static
EvalJSONResult
TryEvalJSON
(
JSContext
*
cx
JSLinearString
*
str
MutableHandleValue
rval
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
AutoCheckCannotGC
nogc
;
if
(
!
EvalStringMightBeJSON
(
str
-
>
latin1Range
(
nogc
)
)
)
{
return
EvalJSONResult
:
:
NotJSON
;
}
}
else
{
AutoCheckCannotGC
nogc
;
if
(
!
EvalStringMightBeJSON
(
str
-
>
twoByteRange
(
nogc
)
)
)
{
return
EvalJSONResult
:
:
NotJSON
;
}
}
AutoStableStringChars
linearChars
(
cx
)
;
if
(
!
linearChars
.
init
(
cx
str
)
)
{
return
EvalJSONResult
:
:
Failure
;
}
return
linearChars
.
isLatin1
(
)
?
ParseEvalStringAsJSON
(
cx
linearChars
.
latin1Range
(
)
rval
)
:
ParseEvalStringAsJSON
(
cx
linearChars
.
twoByteRange
(
)
rval
)
;
}
enum
EvalType
{
DIRECT_EVAL
INDIRECT_EVAL
}
;
static
bool
EvalKernel
(
JSContext
*
cx
HandleValue
v
EvalType
evalType
AbstractFramePtr
caller
HandleObject
env
jsbytecode
*
pc
MutableHandleValue
vp
)
{
MOZ_ASSERT
(
(
evalType
=
=
INDIRECT_EVAL
)
=
=
!
caller
)
;
MOZ_ASSERT
(
(
evalType
=
=
INDIRECT_EVAL
)
=
=
!
pc
)
;
MOZ_ASSERT_IF
(
evalType
=
=
INDIRECT_EVAL
env
-
>
is
<
GlobalLexicalEnvironmentObject
>
(
)
)
;
AssertInnerizedEnvironmentChain
(
cx
*
env
)
;
if
(
!
v
.
isString
(
)
)
{
vp
.
set
(
v
)
;
return
true
;
}
RootedString
str
(
cx
v
.
toString
(
)
)
;
if
(
!
cx
-
>
isRuntimeCodeGenEnabled
(
JS
:
:
RuntimeCode
:
:
JS
str
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CSP_BLOCKED_EVAL
)
;
return
false
;
}
MOZ_ASSERT_IF
(
evalType
!
=
DIRECT_EVAL
cx
-
>
global
(
)
=
=
&
env
-
>
as
<
GlobalLexicalEnvironmentObject
>
(
)
.
global
(
)
)
;
Rooted
<
JSLinearString
*
>
linearStr
(
cx
str
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linearStr
)
{
return
false
;
}
RootedScript
callerScript
(
cx
caller
?
caller
.
script
(
)
:
nullptr
)
;
EvalJSONResult
ejr
=
TryEvalJSON
(
cx
linearStr
vp
)
;
if
(
ejr
!
=
EvalJSONResult
:
:
NotJSON
)
{
return
ejr
=
=
EvalJSONResult
:
:
Success
;
}
EvalScriptGuard
esg
(
cx
)
;
if
(
evalType
=
=
DIRECT_EVAL
&
&
caller
.
isFunctionFrame
(
)
)
{
esg
.
lookupInEvalCache
(
linearStr
callerScript
pc
)
;
}
if
(
!
esg
.
foundScript
(
)
)
{
RootedScript
maybeScript
(
cx
)
;
uint32_t
lineno
;
const
char
*
filename
;
bool
mutedErrors
;
uint32_t
pcOffset
;
if
(
evalType
=
=
DIRECT_EVAL
)
{
DescribeScriptedCallerForDirectEval
(
cx
callerScript
pc
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
maybeScript
=
callerScript
;
}
else
{
DescribeScriptedCallerForCompilation
(
cx
&
maybeScript
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
}
const
char
*
introducerFilename
=
filename
;
if
(
maybeScript
&
&
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
)
{
introducerFilename
=
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
;
}
Rooted
<
Scope
*
>
enclosing
(
cx
)
;
if
(
evalType
=
=
DIRECT_EVAL
)
{
enclosing
=
callerScript
-
>
innermostScope
(
pc
)
;
}
else
{
enclosing
=
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
;
}
CompileOptions
options
(
cx
)
;
options
.
setIsRunOnce
(
true
)
.
setNoScriptRval
(
false
)
.
setMutedErrors
(
mutedErrors
)
.
setDeferDebugMetadata
(
)
;
RootedScript
introScript
(
cx
)
;
if
(
evalType
=
=
DIRECT_EVAL
&
&
IsStrictEvalPC
(
pc
)
)
{
options
.
setForceStrictMode
(
)
;
}
if
(
introducerFilename
)
{
options
.
setFileAndLine
(
filename
1
)
;
options
.
setIntroductionInfo
(
introducerFilename
"
eval
"
lineno
pcOffset
)
;
introScript
=
maybeScript
;
}
else
{
options
.
setFileAndLine
(
"
eval
"
1
)
;
options
.
setIntroductionType
(
"
eval
"
)
;
}
options
.
setNonSyntacticScope
(
enclosing
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
AutoStableStringChars
linearChars
(
cx
)
;
if
(
!
linearChars
.
initTwoByte
(
cx
linearStr
)
)
{
return
false
;
}
SourceText
<
char16_t
>
srcBuf
;
if
(
!
srcBuf
.
initMaybeBorrowed
(
cx
linearChars
)
)
{
return
false
;
}
RootedScript
script
(
cx
frontend
:
:
CompileEvalScript
(
cx
options
srcBuf
enclosing
env
)
)
;
if
(
!
script
)
{
return
false
;
}
RootedValue
undefValue
(
cx
)
;
JS
:
:
InstantiateOptions
instantiateOptions
(
options
)
;
if
(
!
JS
:
:
UpdateDebugMetadata
(
cx
script
instantiateOptions
undefValue
nullptr
introScript
maybeScript
)
)
{
return
false
;
}
esg
.
setNewScript
(
script
)
;
}
return
ExecuteKernel
(
cx
esg
.
script
(
)
env
NullFramePtr
(
)
vp
)
;
}
bool
js
:
:
IndirectEval
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
return
EvalKernel
(
cx
args
.
get
(
0
)
INDIRECT_EVAL
NullFramePtr
(
)
globalLexical
nullptr
args
.
rval
(
)
)
;
}
bool
js
:
:
DirectEval
(
JSContext
*
cx
HandleValue
v
MutableHandleValue
vp
)
{
ScriptFrameIter
iter
(
cx
)
;
AbstractFramePtr
caller
=
iter
.
abstractFramePtr
(
)
;
MOZ_ASSERT
(
JSOp
(
*
iter
.
pc
(
)
)
=
=
JSOp
:
:
Eval
|
|
JSOp
(
*
iter
.
pc
(
)
)
=
=
JSOp
:
:
StrictEval
|
|
JSOp
(
*
iter
.
pc
(
)
)
=
=
JSOp
:
:
SpreadEval
|
|
JSOp
(
*
iter
.
pc
(
)
)
=
=
JSOp
:
:
StrictSpreadEval
)
;
MOZ_ASSERT
(
caller
.
realm
(
)
=
=
caller
.
script
(
)
-
>
realm
(
)
)
;
RootedObject
envChain
(
cx
caller
.
environmentChain
(
)
)
;
return
EvalKernel
(
cx
v
DIRECT_EVAL
caller
envChain
iter
.
pc
(
)
vp
)
;
}
bool
js
:
:
IsAnyBuiltinEval
(
JSFunction
*
fun
)
{
return
fun
-
>
maybeNative
(
)
=
=
IndirectEval
;
}
static
bool
ExecuteInExtensibleLexicalEnvironment
(
JSContext
*
cx
HandleScript
scriptArg
Handle
<
ExtensibleLexicalEnvironmentObject
*
>
env
)
{
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
env
)
;
cx
-
>
check
(
scriptArg
)
;
MOZ_RELEASE_ASSERT
(
scriptArg
-
>
hasNonSyntacticScope
(
)
)
;
RootedValue
rval
(
cx
)
;
return
ExecuteKernel
(
cx
scriptArg
env
NullFramePtr
(
)
&
rval
)
;
}
JS_PUBLIC_API
bool
js
:
:
ExecuteInFrameScriptEnvironment
(
JSContext
*
cx
HandleObject
objArg
HandleScript
scriptArg
MutableHandleObject
envArg
)
{
Rooted
<
NonSyntacticVariablesObject
*
>
varEnv
(
cx
NonSyntacticVariablesObject
:
:
create
(
cx
)
)
;
if
(
!
varEnv
)
{
return
false
;
}
RootedObjectVector
envChain
(
cx
)
;
if
(
!
envChain
.
append
(
objArg
)
)
{
return
false
;
}
Rooted
<
WithEnvironmentObject
*
>
env
(
cx
js
:
:
CreateObjectsForEnvironmentChain
(
cx
envChain
varEnv
)
)
;
if
(
!
env
)
{
return
false
;
}
ObjectRealm
&
realm
=
ObjectRealm
:
:
get
(
varEnv
)
;
Rooted
<
NonSyntacticLexicalEnvironmentObject
*
>
lexicalEnv
(
cx
realm
.
getOrCreateNonSyntacticLexicalEnvironment
(
cx
env
varEnv
)
)
;
if
(
!
lexicalEnv
)
{
return
false
;
}
if
(
!
ExecuteInExtensibleLexicalEnvironment
(
cx
scriptArg
lexicalEnv
)
)
{
return
false
;
}
envArg
.
set
(
lexicalEnv
)
;
return
true
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewJSMEnvironment
(
JSContext
*
cx
)
{
Rooted
<
NonSyntacticVariablesObject
*
>
varEnv
(
cx
NonSyntacticVariablesObject
:
:
create
(
cx
)
)
;
if
(
!
varEnv
)
{
return
nullptr
;
}
ObjectRealm
&
realm
=
ObjectRealm
:
:
get
(
varEnv
)
;
MOZ_ASSERT
(
!
realm
.
getNonSyntacticLexicalEnvironment
(
varEnv
)
)
;
if
(
!
realm
.
getOrCreateNonSyntacticLexicalEnvironment
(
cx
varEnv
)
)
{
return
nullptr
;
}
return
varEnv
;
}
JS_PUBLIC_API
bool
JS
:
:
ExecuteInJSMEnvironment
(
JSContext
*
cx
HandleScript
scriptArg
HandleObject
varEnv
)
{
RootedObjectVector
emptyChain
(
cx
)
;
return
ExecuteInJSMEnvironment
(
cx
scriptArg
varEnv
emptyChain
)
;
}
JS_PUBLIC_API
bool
JS
:
:
ExecuteInJSMEnvironment
(
JSContext
*
cx
HandleScript
scriptArg
HandleObject
varEnv
HandleObjectVector
targetObj
)
{
cx
-
>
check
(
varEnv
)
;
MOZ_ASSERT
(
ObjectRealm
:
:
get
(
varEnv
)
.
getNonSyntacticLexicalEnvironment
(
varEnv
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
scriptArg
-
>
noScriptRval
(
)
)
;
Rooted
<
ExtensibleLexicalEnvironmentObject
*
>
env
(
cx
ExtensibleLexicalEnvironmentObject
:
:
forVarEnvironment
(
varEnv
)
)
;
if
(
!
targetObj
.
empty
(
)
)
{
Rooted
<
WithEnvironmentObject
*
>
envChain
(
cx
js
:
:
CreateObjectsForEnvironmentChain
(
cx
targetObj
env
)
)
;
if
(
!
envChain
)
{
return
false
;
}
if
(
!
JSObject
:
:
setQualifiedVarObj
(
cx
envChain
)
)
{
return
false
;
}
env
=
ObjectRealm
:
:
get
(
envChain
)
.
getOrCreateNonSyntacticLexicalEnvironment
(
cx
envChain
)
;
if
(
!
env
)
{
return
false
;
}
}
return
ExecuteInExtensibleLexicalEnvironment
(
cx
scriptArg
env
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
GetJSMEnvironmentOfScriptedCaller
(
JSContext
*
cx
)
{
FrameIter
iter
(
cx
)
;
if
(
iter
.
done
(
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
!
iter
.
isWasm
(
)
)
;
RootedObject
env
(
cx
iter
.
environmentChain
(
cx
)
)
;
while
(
env
&
&
!
env
-
>
is
<
NonSyntacticVariablesObject
>
(
)
)
{
env
=
env
-
>
enclosingEnvironment
(
)
;
}
return
env
;
}
JS_PUBLIC_API
bool
JS
:
:
IsJSMEnvironment
(
JSObject
*
obj
)
{
return
obj
-
>
is
<
NonSyntacticVariablesObject
>
(
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
RuntimeCaches
:
:
checkEvalCacheAfterMinorGC
(
)
{
gc
:
:
CheckTableAfterMovingGC
(
evalCache
[
]
(
const
auto
&
entry
)
{
CheckGCThingAfterMovingGC
(
entry
.
str
)
;
CheckGCThingAfterMovingGC
(
entry
.
script
)
;
CheckGCThingAfterMovingGC
(
entry
.
callerScript
)
;
return
EvalCacheLookup
(
entry
.
str
entry
.
callerScript
entry
.
pc
)
;
}
)
;
}
#
endif
