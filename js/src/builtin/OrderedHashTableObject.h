#
ifndef
builtin_OrderedHashTableObject_h
#
define
builtin_OrderedHashTableObject_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
utility
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
class
JSTracer
;
namespace
js
{
namespace
detail
{
template
<
class
T
class
Ops
>
class
OrderedHashTableImpl
;
class
OrderedHashTableObject
:
public
NativeObject
{
template
<
class
T
class
Ops
>
friend
class
OrderedHashTableImpl
;
enum
Slots
{
HashTableSlot
DataSlot
DataLengthSlot
DataCapacitySlot
LiveCountSlot
HashShiftSlot
RangesSlot
NurseryRangesSlot
HashCodeScramblerSlot
SlotCount
}
;
public
:
static
constexpr
size_t
offsetOfDataLength
(
)
{
return
getFixedSlotOffset
(
DataLengthSlot
)
;
}
static
constexpr
size_t
offsetOfData
(
)
{
return
getFixedSlotOffset
(
DataSlot
)
;
}
static
constexpr
size_t
offsetOfHashTable
(
)
{
return
getFixedSlotOffset
(
HashTableSlot
)
;
}
static
constexpr
size_t
offsetOfHashShift
(
)
{
return
getFixedSlotOffset
(
HashShiftSlot
)
;
}
static
constexpr
size_t
offsetOfLiveCount
(
)
{
return
getFixedSlotOffset
(
LiveCountSlot
)
;
}
static
constexpr
size_t
offsetOfHashCodeScrambler
(
)
{
return
getFixedSlotOffset
(
HashCodeScramblerSlot
)
;
}
}
;
template
<
class
T
class
Ops
>
class
MOZ_STACK_CLASS
OrderedHashTableImpl
{
public
:
using
Key
=
typename
Ops
:
:
KeyType
;
using
MutableKey
=
std
:
:
remove_const_t
<
Key
>
;
using
UnbarrieredKey
=
typename
RemoveBarrier
<
MutableKey
>
:
:
Type
;
using
Lookup
=
typename
Ops
:
:
Lookup
;
using
HashCodeScrambler
=
mozilla
:
:
HashCodeScrambler
;
static
constexpr
size_t
SlotCount
=
OrderedHashTableObject
:
:
SlotCount
;
struct
Data
{
T
element
;
Data
*
chain
;
Data
(
const
T
&
e
Data
*
c
)
:
element
(
e
)
chain
(
c
)
{
}
Data
(
T
&
&
e
Data
*
c
)
:
element
(
std
:
:
move
(
e
)
)
chain
(
c
)
{
}
}
;
class
Range
;
friend
class
Range
;
private
:
using
Slots
=
OrderedHashTableObject
:
:
Slots
;
OrderedHashTableObject
*
const
obj
;
Data
*
*
getHashTable
(
)
const
{
Value
v
=
obj
-
>
getReservedSlot
(
Slots
:
:
HashTableSlot
)
;
return
static_cast
<
Data
*
*
>
(
v
.
toPrivate
(
)
)
;
}
void
setHashTable
(
Data
*
*
table
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
HashTableSlot
PrivateValue
(
table
)
)
;
}
Data
*
getData
(
)
const
{
Value
v
=
obj
-
>
getReservedSlot
(
Slots
:
:
DataSlot
)
;
return
static_cast
<
Data
*
>
(
v
.
toPrivate
(
)
)
;
}
void
setData
(
Data
*
data
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
DataSlot
PrivateValue
(
data
)
)
;
}
uint32_t
getDataLength
(
)
const
{
return
obj
-
>
getReservedSlot
(
Slots
:
:
DataLengthSlot
)
.
toPrivateUint32
(
)
;
}
void
setDataLength
(
uint32_t
length
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
DataLengthSlot
PrivateUint32Value
(
length
)
)
;
}
uint32_t
getDataCapacity
(
)
const
{
return
obj
-
>
getReservedSlot
(
Slots
:
:
DataCapacitySlot
)
.
toPrivateUint32
(
)
;
}
void
setDataCapacity
(
uint32_t
capacity
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
DataCapacitySlot
PrivateUint32Value
(
capacity
)
)
;
}
uint32_t
getLiveCount
(
)
const
{
return
obj
-
>
getReservedSlot
(
Slots
:
:
LiveCountSlot
)
.
toPrivateUint32
(
)
;
}
void
setLiveCount
(
uint32_t
liveCount
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
LiveCountSlot
PrivateUint32Value
(
liveCount
)
)
;
}
uint32_t
getHashShift
(
)
const
{
return
obj
-
>
getReservedSlot
(
Slots
:
:
HashShiftSlot
)
.
toPrivateUint32
(
)
;
}
void
setHashShift
(
uint32_t
hashShift
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
HashShiftSlot
PrivateUint32Value
(
hashShift
)
)
;
}
Range
*
getRanges
(
)
const
{
Value
v
=
obj
-
>
getReservedSlot
(
Slots
:
:
RangesSlot
)
;
return
static_cast
<
Range
*
>
(
v
.
toPrivate
(
)
)
;
}
void
setRanges
(
Range
*
range
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
RangesSlot
PrivateValue
(
range
)
)
;
}
Range
*
*
getRangesPtr
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
obj
)
+
NativeObject
:
:
getFixedSlotOffset
(
Slots
:
:
RangesSlot
)
;
return
reinterpret_cast
<
Range
*
*
>
(
addr
)
;
}
Range
*
getNurseryRanges
(
)
const
{
Value
v
=
obj
-
>
getReservedSlot
(
Slots
:
:
NurseryRangesSlot
)
;
return
static_cast
<
Range
*
>
(
v
.
toPrivate
(
)
)
;
}
void
setNurseryRanges
(
Range
*
range
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
NurseryRangesSlot
PrivateValue
(
range
)
)
;
}
Range
*
*
getNurseryRangesPtr
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
obj
)
+
NativeObject
:
:
getFixedSlotOffset
(
Slots
:
:
NurseryRangesSlot
)
;
return
reinterpret_cast
<
Range
*
*
>
(
addr
)
;
}
const
HashCodeScrambler
*
getHashCodeScrambler
(
)
const
{
Value
v
=
obj
-
>
getReservedSlot
(
Slots
:
:
HashCodeScramblerSlot
)
;
return
static_cast
<
const
HashCodeScrambler
*
>
(
v
.
toPrivate
(
)
)
;
}
void
setHashCodeScrambler
(
HashCodeScrambler
*
hcs
)
{
obj
-
>
setReservedSlot
(
Slots
:
:
HashCodeScramblerSlot
PrivateValue
(
hcs
)
)
;
}
static
constexpr
uint32_t
InitialBucketsLog2
=
1
;
static
constexpr
uint32_t
InitialBuckets
=
1
<
<
InitialBucketsLog2
;
static
constexpr
uint32_t
InitialHashShift
=
js
:
:
kHashNumberBits
-
InitialBucketsLog2
;
static
constexpr
double
FillFactor
=
8
.
0
/
3
.
0
;
static
constexpr
double
MinDataFill
=
0
.
25
;
template
<
typename
F
>
void
forEachRange
(
F
&
&
f
)
{
Range
*
next
;
for
(
Range
*
r
=
getRanges
(
)
;
r
;
r
=
next
)
{
next
=
r
-
>
next
;
f
(
r
)
;
}
for
(
Range
*
r
=
getNurseryRanges
(
)
;
r
;
r
=
next
)
{
next
=
r
-
>
next
;
f
(
r
)
;
}
}
bool
isInitialized
(
)
const
{
return
!
obj
-
>
getReservedSlot
(
Slots
:
:
DataSlot
)
.
isUndefined
(
)
;
}
static
MOZ_ALWAYS_INLINE
bool
calcAllocSize
(
uint32_t
dataCapacity
uint32_t
buckets
size_t
*
numBytes
)
{
using
CheckedSize
=
mozilla
:
:
CheckedInt
<
size_t
>
;
auto
res
=
CheckedSize
(
dataCapacity
)
*
sizeof
(
Data
)
+
CheckedSize
(
sizeof
(
HashCodeScrambler
)
)
+
CheckedSize
(
buckets
)
*
sizeof
(
Data
*
)
;
if
(
MOZ_UNLIKELY
(
!
res
.
isValid
(
)
)
)
{
return
false
;
}
*
numBytes
=
res
.
value
(
)
;
return
true
;
}
using
AllocationResult
=
std
:
:
tuple
<
Data
*
Data
*
*
HashCodeScrambler
*
size_t
>
;
AllocationResult
allocateBuffer
(
JSContext
*
cx
uint32_t
dataCapacity
uint32_t
buckets
)
{
size_t
numBytes
=
0
;
if
(
MOZ_UNLIKELY
(
!
calcAllocSize
(
dataCapacity
buckets
&
numBytes
)
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
{
}
;
}
void
*
buf
=
obj
-
>
zone
(
)
-
>
pod_malloc
<
uint8_t
>
(
numBytes
)
;
if
(
!
buf
)
{
ReportOutOfMemory
(
cx
)
;
return
{
}
;
}
static_assert
(
alignof
(
Data
)
%
alignof
(
HashCodeScrambler
)
=
=
0
"
Hash
code
scrambler
must
be
aligned
properly
"
)
;
static_assert
(
alignof
(
HashCodeScrambler
)
%
alignof
(
Data
*
)
=
=
0
"
Hash
table
entries
must
be
aligned
properly
"
)
;
auto
*
data
=
static_cast
<
Data
*
>
(
buf
)
;
auto
*
hcs
=
reinterpret_cast
<
HashCodeScrambler
*
>
(
data
+
dataCapacity
)
;
auto
*
*
table
=
reinterpret_cast
<
Data
*
*
>
(
hcs
+
1
)
;
MOZ_ASSERT
(
uintptr_t
(
table
+
buckets
)
=
=
uintptr_t
(
buf
)
+
numBytes
)
;
return
{
data
table
hcs
numBytes
}
;
}
void
updateHashTableForRekey
(
Data
*
entry
HashNumber
oldHash
HashNumber
newHash
)
{
uint32_t
hashShift
=
getHashShift
(
)
;
oldHash
>
>
=
hashShift
;
newHash
>
>
=
hashShift
;
if
(
oldHash
=
=
newHash
)
{
return
;
}
Data
*
*
hashTable
=
getHashTable
(
)
;
Data
*
*
ep
=
&
hashTable
[
oldHash
]
;
while
(
*
ep
!
=
entry
)
{
ep
=
&
(
*
ep
)
-
>
chain
;
}
*
ep
=
entry
-
>
chain
;
ep
=
&
hashTable
[
newHash
]
;
while
(
*
ep
&
&
*
ep
>
entry
)
{
ep
=
&
(
*
ep
)
-
>
chain
;
}
entry
-
>
chain
=
*
ep
;
*
ep
=
entry
;
}
public
:
explicit
OrderedHashTableImpl
(
OrderedHashTableObject
*
obj
)
:
obj
(
obj
)
{
}
[
[
nodiscard
]
]
bool
init
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
isInitialized
(
)
"
init
must
be
called
at
most
once
"
)
;
constexpr
uint32_t
buckets
=
InitialBuckets
;
constexpr
uint32_t
capacity
=
uint32_t
(
buckets
*
FillFactor
)
;
auto
[
dataAlloc
tableAlloc
hcsAlloc
numBytes
]
=
allocateBuffer
(
cx
capacity
buckets
)
;
if
(
!
dataAlloc
)
{
return
false
;
}
AddCellMemory
(
obj
numBytes
MemoryUse
:
:
MapObjectData
)
;
*
hcsAlloc
=
cx
-
>
realm
(
)
-
>
randomHashCodeScrambler
(
)
;
std
:
:
uninitialized_fill_n
(
tableAlloc
buckets
nullptr
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
HashTableSlot
PrivateValue
(
tableAlloc
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
DataSlot
PrivateValue
(
dataAlloc
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
DataLengthSlot
PrivateUint32Value
(
0
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
DataCapacitySlot
PrivateUint32Value
(
capacity
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
LiveCountSlot
PrivateUint32Value
(
0
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
HashShiftSlot
PrivateUint32Value
(
InitialHashShift
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
RangesSlot
PrivateValue
(
nullptr
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
NurseryRangesSlot
PrivateValue
(
nullptr
)
)
;
obj
-
>
initReservedSlot
(
Slots
:
:
HashCodeScramblerSlot
PrivateValue
(
hcsAlloc
)
)
;
MOZ_ASSERT
(
hashBuckets
(
)
=
=
buckets
)
;
return
true
;
}
void
destroy
(
JS
:
:
GCContext
*
gcx
)
{
if
(
isInitialized
(
)
)
{
Data
*
data
=
getData
(
)
;
MOZ_ASSERT
(
data
)
;
freeData
(
gcx
data
getDataLength
(
)
getDataCapacity
(
)
hashBuckets
(
)
)
;
}
}
void
trackMallocBufferOnPromotion
(
)
{
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
)
;
size_t
numBytes
=
0
;
MOZ_ALWAYS_TRUE
(
calcAllocSize
(
getDataCapacity
(
)
hashBuckets
(
)
&
numBytes
)
)
;
AddCellMemory
(
obj
numBytes
MemoryUse
:
:
MapObjectData
)
;
}
size_t
sizeOfExcludingObject
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
if
(
isInitialized
(
)
)
{
size
+
=
mallocSizeOf
(
getData
(
)
)
;
}
return
size
;
}
uint32_t
count
(
)
const
{
return
getLiveCount
(
)
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
lookup
(
l
)
!
=
nullptr
;
}
T
*
get
(
const
Lookup
&
l
)
{
Data
*
e
=
lookup
(
l
prepareHash
(
l
)
)
;
return
e
?
&
e
-
>
element
:
nullptr
;
}
template
<
typename
ElementInput
>
[
[
nodiscard
]
]
bool
put
(
JSContext
*
cx
ElementInput
&
&
element
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
element
)
)
;
if
(
Data
*
e
=
lookup
(
Ops
:
:
getKey
(
element
)
h
)
)
{
e
-
>
element
=
std
:
:
forward
<
ElementInput
>
(
element
)
;
return
true
;
}
if
(
getDataLength
(
)
=
=
getDataCapacity
(
)
&
&
!
rehashOnFull
(
cx
)
)
{
return
false
;
}
auto
[
entry
chain
]
=
addEntry
(
h
)
;
new
(
entry
)
Data
(
std
:
:
forward
<
ElementInput
>
(
element
)
chain
)
;
return
true
;
}
bool
remove
(
JSContext
*
cx
const
Lookup
&
l
)
{
Data
*
e
=
lookup
(
l
prepareHash
(
l
)
)
;
if
(
e
=
=
nullptr
)
{
return
false
;
}
MOZ_ASSERT
(
uint32_t
(
e
-
getData
(
)
)
<
getDataCapacity
(
)
)
;
uint32_t
liveCount
=
getLiveCount
(
)
;
liveCount
-
-
;
setLiveCount
(
liveCount
)
;
Ops
:
:
makeEmpty
(
&
e
-
>
element
)
;
uint32_t
pos
=
e
-
getData
(
)
;
forEachRange
(
[
this
pos
]
(
Range
*
range
)
{
range
-
>
onRemove
(
obj
pos
)
;
}
)
;
if
(
hashBuckets
(
)
>
InitialBuckets
&
&
liveCount
<
getDataLength
(
)
*
MinDataFill
)
{
if
(
!
rehash
(
cx
getHashShift
(
)
+
1
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
}
return
true
;
}
void
clear
(
JSContext
*
cx
)
{
if
(
getDataLength
(
)
!
=
0
)
{
destroyData
(
getData
(
)
getDataLength
(
)
)
;
setDataLength
(
0
)
;
setLiveCount
(
0
)
;
size_t
buckets
=
hashBuckets
(
)
;
std
:
:
fill_n
(
getHashTable
(
)
buckets
nullptr
)
;
forEachRange
(
[
]
(
Range
*
range
)
{
range
-
>
onClear
(
)
;
}
)
;
if
(
buckets
>
InitialBuckets
)
{
if
(
!
rehash
(
cx
InitialHashShift
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
}
}
MOZ_ASSERT
(
getHashTable
(
)
)
;
MOZ_ASSERT
(
getData
(
)
)
;
MOZ_ASSERT
(
getDataLength
(
)
=
=
0
)
;
MOZ_ASSERT
(
getLiveCount
(
)
=
=
0
)
;
}
class
Range
{
friend
class
OrderedHashTableImpl
;
uint32_t
i
=
0
;
uint32_t
count
=
0
;
Range
*
*
prevp
;
Range
*
next
;
Range
(
OrderedHashTableObject
*
obj
Range
*
*
listp
)
:
prevp
(
listp
)
next
(
*
listp
)
{
*
prevp
=
this
;
if
(
next
)
{
next
-
>
prevp
=
&
next
;
}
seek
(
obj
)
;
MOZ_ASSERT
(
valid
(
)
)
;
}
public
:
Range
(
OrderedHashTableObject
*
obj
const
Range
&
other
bool
inNursery
)
:
i
(
other
.
i
)
count
(
other
.
count
)
prevp
(
inNursery
?
OrderedHashTableImpl
(
obj
)
.
getNurseryRangesPtr
(
)
:
OrderedHashTableImpl
(
obj
)
.
getRangesPtr
(
)
)
next
(
*
prevp
)
{
*
prevp
=
this
;
if
(
next
)
{
next
-
>
prevp
=
&
next
;
}
MOZ_ASSERT
(
valid
(
)
)
;
}
~
Range
(
)
{
if
(
!
prevp
)
{
return
;
}
*
prevp
=
next
;
if
(
next
)
{
next
-
>
prevp
=
prevp
;
}
}
protected
:
Range
&
operator
=
(
const
Range
&
other
)
=
delete
;
void
seek
(
OrderedHashTableObject
*
obj
)
{
Data
*
data
=
OrderedHashTableImpl
(
obj
)
.
getData
(
)
;
uint32_t
dataLength
=
OrderedHashTableImpl
(
obj
)
.
getDataLength
(
)
;
while
(
i
<
dataLength
&
&
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
i
+
+
;
}
}
void
onRemove
(
OrderedHashTableObject
*
obj
uint32_t
j
)
{
MOZ_ASSERT
(
valid
(
)
)
;
if
(
j
<
i
)
{
count
-
-
;
}
if
(
j
=
=
i
)
{
seek
(
obj
)
;
}
}
void
onCompact
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
i
=
count
;
}
void
onClear
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
i
=
count
=
0
;
}
#
ifdef
DEBUG
bool
valid
(
)
const
{
return
next
!
=
this
;
}
#
endif
public
:
bool
empty
(
OrderedHashTableObject
*
obj
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
return
i
>
=
OrderedHashTableImpl
(
obj
)
.
getDataLength
(
)
;
}
const
T
&
front
(
OrderedHashTableObject
*
obj
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
!
empty
(
obj
)
)
;
return
OrderedHashTableImpl
(
obj
)
.
getData
(
)
[
i
]
.
element
;
}
void
popFront
(
OrderedHashTableObject
*
obj
)
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
!
empty
(
obj
)
)
;
MOZ_ASSERT
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
OrderedHashTableImpl
(
obj
)
.
getData
(
)
[
i
]
.
element
)
)
)
;
count
+
+
;
i
+
+
;
seek
(
obj
)
;
}
static
size_t
offsetOfI
(
)
{
return
offsetof
(
Range
i
)
;
}
static
size_t
offsetOfCount
(
)
{
return
offsetof
(
Range
count
)
;
}
static
size_t
offsetOfPrevP
(
)
{
return
offsetof
(
Range
prevp
)
;
}
static
size_t
offsetOfNext
(
)
{
return
offsetof
(
Range
next
)
;
}
}
;
template
<
typename
F
>
[
[
nodiscard
]
]
bool
forEachEntry
(
F
&
&
f
)
const
{
const
Data
*
data
=
getData
(
)
;
uint32_t
dataLength
=
getDataLength
(
)
;
#
ifdef
DEBUG
uint32_t
liveCount
=
getLiveCount
(
)
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
dataLength
;
i
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
if
(
!
f
(
data
[
i
]
.
element
)
)
{
return
false
;
}
}
}
MOZ_ASSERT
(
getData
(
)
=
=
data
)
;
MOZ_ASSERT
(
getDataLength
(
)
=
=
dataLength
)
;
MOZ_ASSERT
(
getLiveCount
(
)
=
=
liveCount
)
;
return
true
;
}
#
ifdef
DEBUG
template
<
typename
F
>
void
forEachEntryUpTo
(
size_t
maxCount
F
&
&
f
)
const
{
MOZ_ASSERT
(
maxCount
>
0
)
;
const
Data
*
data
=
getData
(
)
;
uint32_t
dataLength
=
getDataLength
(
)
;
uint32_t
liveCount
=
getLiveCount
(
)
;
size_t
count
=
0
;
for
(
uint32_t
i
=
0
;
i
<
dataLength
;
i
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
f
(
data
[
i
]
.
element
)
;
count
+
+
;
if
(
count
=
=
maxCount
)
{
break
;
}
}
}
MOZ_ASSERT
(
getData
(
)
=
=
data
)
;
MOZ_ASSERT
(
getDataLength
(
)
=
=
dataLength
)
;
MOZ_ASSERT
(
getLiveCount
(
)
=
=
liveCount
)
;
}
#
endif
void
trace
(
JSTracer
*
trc
)
{
Data
*
data
=
getData
(
)
;
uint32_t
dataLength
=
getDataLength
(
)
;
for
(
uint32_t
i
=
0
;
i
<
dataLength
;
i
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
Ops
:
:
trace
(
trc
this
i
data
[
i
]
.
element
)
;
}
}
}
void
traceKey
(
JSTracer
*
trc
uint32_t
index
const
Key
&
key
)
{
MOZ_ASSERT
(
index
<
getDataLength
(
)
)
;
UnbarrieredKey
newKey
=
key
;
JS
:
:
GCPolicy
<
UnbarrieredKey
>
:
:
trace
(
trc
&
newKey
"
OrderedHashTableObject
key
"
)
;
if
(
newKey
!
=
key
)
{
rekey
(
&
getData
(
)
[
index
]
newKey
)
;
}
}
template
<
typename
Value
>
void
traceValue
(
JSTracer
*
trc
Value
&
value
)
{
JS
:
:
GCPolicy
<
Value
>
:
:
trace
(
trc
&
value
"
OrderedHashMapObject
value
"
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
Range
*
*
listp
=
inNursery
?
getNurseryRangesPtr
(
)
:
getRangesPtr
(
)
;
new
(
buffer
)
Range
(
obj
listp
)
;
return
static_cast
<
Range
*
>
(
buffer
)
;
}
void
destroyNurseryRanges
(
)
{
if
(
Range
*
range
=
getNurseryRanges
(
)
)
{
range
-
>
prevp
=
nullptr
;
}
setNurseryRanges
(
nullptr
)
;
}
void
updateRangesAfterMove
(
OrderedHashTableObject
*
old
)
{
if
(
Range
*
range
=
getRanges
(
)
)
{
MOZ_ASSERT
(
range
-
>
prevp
=
=
OrderedHashTableImpl
(
old
)
.
getRangesPtr
(
)
)
;
range
-
>
prevp
=
getRangesPtr
(
)
;
}
if
(
Range
*
range
=
getNurseryRanges
(
)
)
{
MOZ_ASSERT
(
range
-
>
prevp
=
=
OrderedHashTableImpl
(
old
)
.
getNurseryRangesPtr
(
)
)
;
range
-
>
prevp
=
getNurseryRangesPtr
(
)
;
}
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
getNurseryRanges
(
)
;
}
#
endif
void
rekeyOneEntry
(
const
Key
&
current
const
Key
&
newKey
const
T
&
element
)
{
if
(
current
=
=
newKey
)
{
return
;
}
HashNumber
currentHash
=
prepareHash
(
current
)
;
HashNumber
newHash
=
prepareHash
(
newKey
)
;
Data
*
entry
=
lookup
(
current
currentHash
)
;
MOZ_ASSERT
(
entry
)
;
entry
-
>
element
=
element
;
updateHashTableForRekey
(
entry
currentHash
newHash
)
;
}
static
constexpr
size_t
offsetOfDataElement
(
)
{
static_assert
(
offsetof
(
Data
element
)
=
=
0
"
RangeFront
and
RangePopFront
depend
on
offsetof
(
Data
"
"
element
)
being
0
"
)
;
return
offsetof
(
Data
element
)
;
}
static
constexpr
size_t
offsetOfDataChain
(
)
{
return
offsetof
(
Data
chain
)
;
}
static
constexpr
size_t
sizeofData
(
)
{
return
sizeof
(
Data
)
;
}
HashNumber
prepareHash
(
const
Lookup
&
l
)
const
{
const
HashCodeScrambler
&
hcs
=
*
getHashCodeScrambler
(
)
;
return
mozilla
:
:
ScrambleHashCode
(
Ops
:
:
hash
(
l
hcs
)
)
;
}
private
:
uint32_t
hashBuckets
(
)
const
{
return
1
<
<
(
js
:
:
kHashNumberBits
-
getHashShift
(
)
)
;
}
void
destroyData
(
Data
*
data
uint32_t
length
)
{
Data
*
end
=
data
+
length
;
for
(
Data
*
p
=
data
;
p
!
=
end
;
p
+
+
)
{
p
-
>
~
Data
(
)
;
}
}
void
freeData
(
JS
:
:
GCContext
*
gcx
Data
*
data
uint32_t
length
uint32_t
capacity
uint32_t
hashBuckets
)
{
MOZ_ASSERT
(
data
)
;
MOZ_ASSERT
(
capacity
>
0
)
;
destroyData
(
data
length
)
;
size_t
numBytes
;
MOZ_ALWAYS_TRUE
(
calcAllocSize
(
capacity
hashBuckets
&
numBytes
)
)
;
gcx
-
>
free_
(
obj
data
numBytes
MemoryUse
:
:
MapObjectData
)
;
}
Data
*
lookup
(
const
Lookup
&
l
HashNumber
h
)
const
{
Data
*
*
hashTable
=
getHashTable
(
)
;
uint32_t
hashShift
=
getHashShift
(
)
;
for
(
Data
*
e
=
hashTable
[
h
>
>
hashShift
]
;
e
;
e
=
e
-
>
chain
)
{
if
(
Ops
:
:
match
(
Ops
:
:
getKey
(
e
-
>
element
)
l
)
)
{
return
e
;
}
}
return
nullptr
;
}
const
Data
*
lookup
(
const
Lookup
&
l
)
const
{
return
lookup
(
l
prepareHash
(
l
)
)
;
}
std
:
:
tuple
<
Data
*
Data
*
>
addEntry
(
HashNumber
hash
)
{
uint32_t
dataLength
=
getDataLength
(
)
;
MOZ_ASSERT
(
dataLength
<
getDataCapacity
(
)
)
;
Data
*
entry
=
&
getData
(
)
[
dataLength
]
;
setDataLength
(
dataLength
+
1
)
;
setLiveCount
(
getLiveCount
(
)
+
1
)
;
Data
*
*
hashTable
=
getHashTable
(
)
;
hash
>
>
=
getHashShift
(
)
;
Data
*
chain
=
hashTable
[
hash
]
;
hashTable
[
hash
]
=
entry
;
return
std
:
:
make_tuple
(
entry
chain
)
;
}
void
compacted
(
)
{
forEachRange
(
[
]
(
Range
*
range
)
{
range
-
>
onCompact
(
)
;
}
)
;
}
void
rehashInPlace
(
)
{
Data
*
*
hashTable
=
getHashTable
(
)
;
std
:
:
fill_n
(
hashTable
hashBuckets
(
)
nullptr
)
;
Data
*
const
data
=
getData
(
)
;
uint32_t
hashShift
=
getHashShift
(
)
;
Data
*
wp
=
data
;
Data
*
end
=
data
+
getDataLength
(
)
;
for
(
Data
*
rp
=
data
;
rp
!
=
end
;
rp
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
rp
-
>
element
)
)
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
rp
-
>
element
)
)
>
>
hashShift
;
if
(
rp
!
=
wp
)
{
wp
-
>
element
=
std
:
:
move
(
rp
-
>
element
)
;
}
wp
-
>
chain
=
hashTable
[
h
]
;
hashTable
[
h
]
=
wp
;
wp
+
+
;
}
}
MOZ_ASSERT
(
wp
=
=
data
+
getLiveCount
(
)
)
;
while
(
wp
!
=
end
)
{
wp
-
>
~
Data
(
)
;
wp
+
+
;
}
setDataLength
(
getLiveCount
(
)
)
;
compacted
(
)
;
}
[
[
nodiscard
]
]
bool
rehashOnFull
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
getDataLength
(
)
=
=
getDataCapacity
(
)
)
;
uint32_t
newHashShift
=
getLiveCount
(
)
>
=
getDataCapacity
(
)
*
0
.
75
?
getHashShift
(
)
-
1
:
getHashShift
(
)
;
return
rehash
(
cx
newHashShift
)
;
}
[
[
nodiscard
]
]
bool
rehash
(
JSContext
*
cx
uint32_t
newHashShift
)
{
if
(
newHashShift
=
=
getHashShift
(
)
)
{
rehashInPlace
(
)
;
return
true
;
}
constexpr
size_t
maxCapacityLog2
=
mozilla
:
:
tl
:
:
FloorLog2
<
size_t
(
INT32_MAX
/
FillFactor
)
>
:
:
value
;
static_assert
(
maxCapacityLog2
<
kHashNumberBits
)
;
if
(
MOZ_UNLIKELY
(
newHashShift
<
(
js
:
:
kHashNumberBits
-
maxCapacityLog2
)
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
uint32_t
newHashBuckets
=
uint32_t
(
1
)
<
<
(
js
:
:
kHashNumberBits
-
newHashShift
)
;
uint32_t
newCapacity
=
uint32_t
(
newHashBuckets
*
FillFactor
)
;
auto
[
newData
newHashTable
newHcs
numBytes
]
=
allocateBuffer
(
cx
newCapacity
newHashBuckets
)
;
if
(
!
newData
)
{
return
false
;
}
*
newHcs
=
*
getHashCodeScrambler
(
)
;
std
:
:
uninitialized_fill_n
(
newHashTable
newHashBuckets
nullptr
)
;
Data
*
const
oldData
=
getData
(
)
;
const
uint32_t
oldDataLength
=
getDataLength
(
)
;
Data
*
wp
=
newData
;
Data
*
end
=
oldData
+
oldDataLength
;
for
(
Data
*
p
=
oldData
;
p
!
=
end
;
p
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
p
-
>
element
)
)
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
p
-
>
element
)
)
>
>
newHashShift
;
new
(
wp
)
Data
(
std
:
:
move
(
p
-
>
element
)
newHashTable
[
h
]
)
;
newHashTable
[
h
]
=
wp
;
wp
+
+
;
}
}
MOZ_ASSERT
(
wp
=
=
newData
+
getLiveCount
(
)
)
;
freeData
(
obj
-
>
runtimeFromMainThread
(
)
-
>
gcContext
(
)
oldData
oldDataLength
getDataCapacity
(
)
hashBuckets
(
)
)
;
AddCellMemory
(
obj
numBytes
MemoryUse
:
:
MapObjectData
)
;
setHashTable
(
newHashTable
)
;
setData
(
newData
)
;
setDataLength
(
getLiveCount
(
)
)
;
setDataCapacity
(
newCapacity
)
;
setHashShift
(
newHashShift
)
;
setHashCodeScrambler
(
newHcs
)
;
MOZ_ASSERT
(
hashBuckets
(
)
=
=
newHashBuckets
)
;
compacted
(
)
;
return
true
;
}
void
rekey
(
Data
*
entry
const
UnbarrieredKey
&
k
)
{
HashNumber
oldHash
=
prepareHash
(
Ops
:
:
getKey
(
entry
-
>
element
)
)
;
HashNumber
newHash
=
prepareHash
(
k
)
;
reinterpret_cast
<
UnbarrieredKey
&
>
(
Ops
:
:
getKeyRef
(
entry
-
>
element
)
)
=
k
;
updateHashTableForRekey
(
entry
oldHash
newHash
)
;
}
}
;
}
class
OrderedHashMapObject
:
public
detail
:
:
OrderedHashTableObject
{
}
;
template
<
class
Key
class
Value
class
OrderedHashPolicy
>
class
MOZ_STACK_CLASS
OrderedHashMapImpl
{
public
:
class
Entry
{
template
<
class
class
>
friend
class
detail
:
:
OrderedHashTableImpl
;
void
operator
=
(
const
Entry
&
rhs
)
{
const_cast
<
Key
&
>
(
key
)
=
rhs
.
key
;
value
=
rhs
.
value
;
}
void
operator
=
(
Entry
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
assignment
is
prohibited
"
)
;
const_cast
<
Key
&
>
(
key
)
=
std
:
:
move
(
rhs
.
key
)
;
value
=
std
:
:
move
(
rhs
.
value
)
;
}
public
:
Entry
(
)
=
default
;
explicit
Entry
(
const
Key
&
k
)
:
key
(
k
)
{
}
template
<
typename
V
>
Entry
(
const
Key
&
k
V
&
&
v
)
:
key
(
k
)
value
(
std
:
:
forward
<
V
>
(
v
)
)
{
}
Entry
(
Entry
&
&
rhs
)
:
key
(
std
:
:
move
(
rhs
.
key
)
)
value
(
std
:
:
move
(
rhs
.
value
)
)
{
}
const
Key
key
{
}
;
Value
value
{
}
;
static
constexpr
size_t
offsetOfKey
(
)
{
return
offsetof
(
Entry
key
)
;
}
static
constexpr
size_t
offsetOfValue
(
)
{
return
offsetof
(
Entry
value
)
;
}
}
;
private
:
struct
MapOps
;
using
Impl
=
detail
:
:
OrderedHashTableImpl
<
Entry
MapOps
>
;
struct
MapOps
:
OrderedHashPolicy
{
using
KeyType
=
Key
;
static
void
makeEmpty
(
Entry
*
e
)
{
OrderedHashPolicy
:
:
makeEmpty
(
const_cast
<
Key
*
>
(
&
e
-
>
key
)
)
;
e
-
>
value
=
Value
(
)
;
}
static
const
Key
&
getKey
(
const
Entry
&
e
)
{
return
e
.
key
;
}
static
Key
&
getKeyRef
(
Entry
&
e
)
{
return
const_cast
<
Key
&
>
(
e
.
key
)
;
}
static
void
trace
(
JSTracer
*
trc
Impl
*
table
uint32_t
index
Entry
&
entry
)
{
table
-
>
traceKey
(
trc
index
entry
.
key
)
;
table
-
>
traceValue
(
trc
entry
.
value
)
;
}
}
;
Impl
impl
;
public
:
using
Lookup
=
typename
Impl
:
:
Lookup
;
using
Range
=
typename
Impl
:
:
Range
;
static
constexpr
size_t
SlotCount
=
Impl
:
:
SlotCount
;
explicit
OrderedHashMapImpl
(
OrderedHashMapObject
*
obj
)
:
impl
(
obj
)
{
}
[
[
nodiscard
]
]
bool
init
(
JSContext
*
cx
)
{
return
impl
.
init
(
cx
)
;
}
uint32_t
count
(
)
const
{
return
impl
.
count
(
)
;
}
bool
has
(
const
Lookup
&
key
)
const
{
return
impl
.
has
(
key
)
;
}
template
<
typename
F
>
[
[
nodiscard
]
]
bool
forEachEntry
(
F
&
&
f
)
const
{
return
impl
.
forEachEntry
(
f
)
;
}
#
ifdef
DEBUG
template
<
typename
F
>
void
forEachEntryUpTo
(
size_t
maxCount
F
&
&
f
)
const
{
impl
.
forEachEntryUpTo
(
maxCount
f
)
;
}
#
endif
Entry
*
get
(
const
Lookup
&
key
)
{
return
impl
.
get
(
key
)
;
}
bool
remove
(
JSContext
*
cx
const
Lookup
&
key
)
{
return
impl
.
remove
(
cx
key
)
;
}
void
clear
(
JSContext
*
cx
)
{
impl
.
clear
(
cx
)
;
}
void
destroy
(
JS
:
:
GCContext
*
gcx
)
{
impl
.
destroy
(
gcx
)
;
}
template
<
typename
K
typename
V
>
[
[
nodiscard
]
]
bool
put
(
JSContext
*
cx
K
&
&
key
V
&
&
value
)
{
return
impl
.
put
(
cx
Entry
(
std
:
:
forward
<
K
>
(
key
)
std
:
:
forward
<
V
>
(
value
)
)
)
;
}
HashNumber
hash
(
const
Lookup
&
key
)
const
{
return
impl
.
prepareHash
(
key
)
;
}
template
<
typename
GetNewKey
>
mozilla
:
:
Maybe
<
Key
>
rekeyOneEntry
(
Lookup
&
current
GetNewKey
&
&
getNewKey
)
{
const
Entry
*
e
=
get
(
current
)
;
if
(
!
e
)
{
return
mozilla
:
:
Nothing
(
)
;
}
Key
newKey
=
getNewKey
(
current
)
;
impl
.
rekeyOneEntry
(
current
newKey
Entry
(
newKey
e
-
>
value
)
)
;
return
mozilla
:
:
Some
(
newKey
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
return
impl
.
createRange
(
buffer
inNursery
)
;
}
void
destroyNurseryRanges
(
)
{
impl
.
destroyNurseryRanges
(
)
;
}
void
updateRangesAfterMove
(
OrderedHashMapObject
*
old
)
{
impl
.
updateRangesAfterMove
(
old
)
;
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
impl
.
hasNurseryRanges
(
)
;
}
#
endif
void
trackMallocBufferOnPromotion
(
)
{
return
impl
.
trackMallocBufferOnPromotion
(
)
;
}
void
trace
(
JSTracer
*
trc
)
{
impl
.
trace
(
trc
)
;
}
static
constexpr
size_t
offsetOfEntryKey
(
)
{
return
Entry
:
:
offsetOfKey
(
)
;
}
static
constexpr
size_t
offsetOfImplDataElement
(
)
{
return
Impl
:
:
offsetOfDataElement
(
)
;
}
static
constexpr
size_t
offsetOfImplDataChain
(
)
{
return
Impl
:
:
offsetOfDataChain
(
)
;
}
static
constexpr
size_t
sizeofImplData
(
)
{
return
Impl
:
:
sizeofData
(
)
;
}
size_t
sizeOfExcludingObject
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
impl
.
sizeOfExcludingObject
(
mallocSizeOf
)
;
}
}
;
class
OrderedHashSetObject
:
public
detail
:
:
OrderedHashTableObject
{
}
;
template
<
class
T
class
OrderedHashPolicy
>
class
MOZ_STACK_CLASS
OrderedHashSetImpl
{
private
:
struct
SetOps
;
using
Impl
=
detail
:
:
OrderedHashTableImpl
<
T
SetOps
>
;
struct
SetOps
:
OrderedHashPolicy
{
using
KeyType
=
const
T
;
static
const
T
&
getKey
(
const
T
&
v
)
{
return
v
;
}
static
T
&
getKeyRef
(
T
&
e
)
{
return
e
;
}
static
void
trace
(
JSTracer
*
trc
Impl
*
table
uint32_t
index
T
&
entry
)
{
table
-
>
traceKey
(
trc
index
entry
)
;
}
}
;
Impl
impl
;
public
:
using
Lookup
=
typename
Impl
:
:
Lookup
;
using
Range
=
typename
Impl
:
:
Range
;
static
constexpr
size_t
SlotCount
=
Impl
:
:
SlotCount
;
explicit
OrderedHashSetImpl
(
OrderedHashSetObject
*
obj
)
:
impl
(
obj
)
{
}
[
[
nodiscard
]
]
bool
init
(
JSContext
*
cx
)
{
return
impl
.
init
(
cx
)
;
}
uint32_t
count
(
)
const
{
return
impl
.
count
(
)
;
}
bool
has
(
const
Lookup
&
value
)
const
{
return
impl
.
has
(
value
)
;
}
template
<
typename
F
>
[
[
nodiscard
]
]
bool
forEachEntry
(
F
&
&
f
)
const
{
return
impl
.
forEachEntry
(
f
)
;
}
#
ifdef
DEBUG
template
<
typename
F
>
void
forEachEntryUpTo
(
size_t
maxCount
F
&
&
f
)
const
{
impl
.
forEachEntryUpTo
(
maxCount
f
)
;
}
#
endif
template
<
typename
Input
>
[
[
nodiscard
]
]
bool
put
(
JSContext
*
cx
Input
&
&
value
)
{
return
impl
.
put
(
cx
std
:
:
forward
<
Input
>
(
value
)
)
;
}
bool
remove
(
JSContext
*
cx
const
Lookup
&
value
)
{
return
impl
.
remove
(
cx
value
)
;
}
void
clear
(
JSContext
*
cx
)
{
impl
.
clear
(
cx
)
;
}
void
destroy
(
JS
:
:
GCContext
*
gcx
)
{
impl
.
destroy
(
gcx
)
;
}
HashNumber
hash
(
const
Lookup
&
value
)
const
{
return
impl
.
prepareHash
(
value
)
;
}
template
<
typename
GetNewKey
>
mozilla
:
:
Maybe
<
T
>
rekeyOneEntry
(
Lookup
&
current
GetNewKey
&
&
getNewKey
)
{
if
(
!
has
(
current
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
T
newKey
=
getNewKey
(
current
)
;
impl
.
rekeyOneEntry
(
current
newKey
newKey
)
;
return
mozilla
:
:
Some
(
newKey
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
return
impl
.
createRange
(
buffer
inNursery
)
;
}
void
destroyNurseryRanges
(
)
{
impl
.
destroyNurseryRanges
(
)
;
}
void
updateRangesAfterMove
(
OrderedHashSetObject
*
old
)
{
impl
.
updateRangesAfterMove
(
old
)
;
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
impl
.
hasNurseryRanges
(
)
;
}
#
endif
void
trackMallocBufferOnPromotion
(
)
{
return
impl
.
trackMallocBufferOnPromotion
(
)
;
}
void
trace
(
JSTracer
*
trc
)
{
impl
.
trace
(
trc
)
;
}
static
constexpr
size_t
offsetOfEntryKey
(
)
{
return
0
;
}
static
constexpr
size_t
offsetOfImplDataElement
(
)
{
return
Impl
:
:
offsetOfDataElement
(
)
;
}
static
constexpr
size_t
offsetOfImplDataChain
(
)
{
return
Impl
:
:
offsetOfDataChain
(
)
;
}
static
constexpr
size_t
sizeofImplData
(
)
{
return
Impl
:
:
sizeofData
(
)
;
}
size_t
sizeOfExcludingObject
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
impl
.
sizeOfExcludingObject
(
mallocSizeOf
)
;
}
}
;
}
#
endif
