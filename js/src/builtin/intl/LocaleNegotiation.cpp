#
include
"
builtin
/
intl
/
LocaleNegotiation
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
builtin
/
intl
/
FormatBuffer
.
h
"
#
include
"
builtin
/
intl
/
SharedIntlData
.
h
"
#
include
"
builtin
/
intl
/
StringAsciiChars
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
namespace
js
:
:
intl
;
static
bool
SameOrParentLocale
(
const
JSLinearString
*
locale
const
JSLinearString
*
otherLocale
)
{
if
(
locale
-
>
length
(
)
=
=
otherLocale
-
>
length
(
)
)
{
return
EqualStrings
(
locale
otherLocale
)
;
}
if
(
locale
-
>
length
(
)
<
otherLocale
-
>
length
(
)
)
{
return
HasSubstringAt
(
otherLocale
locale
0
)
&
&
otherLocale
-
>
latin1OrTwoByteChar
(
locale
-
>
length
(
)
)
=
=
'
-
'
;
}
return
false
;
}
static
JS
:
:
Result
<
JSLinearString
*
>
BestAvailableLocale
(
JSContext
*
cx
AvailableLocaleKind
availableLocales
Handle
<
JSLinearString
*
>
locale
Handle
<
JSLinearString
*
>
defaultLocale
)
{
intl
:
:
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
auto
findLast
=
[
]
(
const
auto
*
chars
size_t
length
)
{
auto
rbegin
=
std
:
:
make_reverse_iterator
(
chars
+
length
)
;
auto
rend
=
std
:
:
make_reverse_iterator
(
chars
)
;
auto
p
=
std
:
:
find
(
rbegin
rend
'
-
'
)
;
ptrdiff_t
r
=
std
:
:
distance
(
chars
p
.
base
(
)
)
;
MOZ_ASSERT
(
r
=
=
std
:
:
distance
(
p
rend
)
)
;
return
r
-
1
;
}
;
Rooted
<
JSLinearString
*
>
candidate
(
cx
locale
)
;
while
(
true
)
{
bool
supported
=
false
;
if
(
!
sharedIntlData
.
isAvailableLocale
(
cx
availableLocales
candidate
&
supported
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
if
(
supported
)
{
return
candidate
.
get
(
)
;
}
if
(
defaultLocale
&
&
SameOrParentLocale
(
candidate
defaultLocale
)
)
{
return
candidate
.
get
(
)
;
}
ptrdiff_t
pos
;
if
(
candidate
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
pos
=
findLast
(
candidate
-
>
latin1Chars
(
nogc
)
candidate
-
>
length
(
)
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
pos
=
findLast
(
candidate
-
>
twoByteChars
(
nogc
)
candidate
-
>
length
(
)
)
;
}
if
(
pos
<
0
)
{
return
nullptr
;
}
size_t
length
=
size_t
(
pos
)
;
if
(
length
>
=
2
&
&
candidate
-
>
latin1OrTwoByteChar
(
length
-
2
)
=
=
'
-
'
)
{
length
-
=
2
;
}
candidate
=
NewDependentString
(
cx
candidate
0
length
)
;
if
(
!
candidate
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
}
}
bool
js
:
:
intl
:
:
BestAvailableLocale
(
JSContext
*
cx
AvailableLocaleKind
availableLocales
Handle
<
JSLinearString
*
>
locale
Handle
<
JSLinearString
*
>
defaultLocale
MutableHandle
<
JSLinearString
*
>
result
)
{
#
ifdef
DEBUG
{
MOZ_ASSERT
(
StringIsAscii
(
locale
)
"
language
tags
are
ASCII
-
only
"
)
;
mozilla
:
:
intl
:
:
Locale
tag
;
using
ParserError
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
ParserError
;
mozilla
:
:
Result
<
mozilla
:
:
Ok
ParserError
>
parse_result
=
Ok
(
)
;
{
intl
:
:
StringAsciiChars
chars
(
locale
)
;
if
(
!
chars
.
init
(
cx
)
)
{
return
false
;
}
parse_result
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
chars
tag
)
;
}
if
(
parse_result
.
isErr
(
)
)
{
MOZ_ASSERT
(
parse_result
.
unwrapErr
(
)
=
=
ParserError
:
:
OutOfMemory
"
locale
is
a
structurally
valid
language
tag
"
)
;
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
MOZ_ASSERT
(
!
tag
.
GetUnicodeExtension
(
)
"
locale
must
contain
no
Unicode
extensions
"
)
;
if
(
auto
result
=
tag
.
Canonicalize
(
)
;
result
.
isErr
(
)
)
{
MOZ_ASSERT
(
result
.
unwrapErr
(
)
!
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
;
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
intl
:
:
FormatBuffer
<
char
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
false
;
}
MOZ_ASSERT
(
StringEqualsAscii
(
locale
buffer
.
data
(
)
buffer
.
length
(
)
)
"
locale
is
a
canonicalized
language
tag
"
)
;
}
#
endif
JSLinearString
*
res
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
res
BestAvailableLocale
(
cx
availableLocales
locale
defaultLocale
)
)
;
if
(
res
)
{
result
.
set
(
res
)
;
}
else
{
result
.
set
(
nullptr
)
;
}
return
true
;
}
JSLinearString
*
js
:
:
intl
:
:
ComputeDefaultLocale
(
JSContext
*
cx
)
{
const
char
*
locale
=
cx
-
>
realm
(
)
-
>
getLocale
(
)
;
if
(
!
locale
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
auto
span
=
mozilla
:
:
MakeStringSpan
(
locale
)
;
mozilla
:
:
intl
:
:
Locale
tag
;
bool
canParseLocale
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
span
tag
)
.
isOk
(
)
&
&
tag
.
Canonicalize
(
)
.
isOk
(
)
;
Rooted
<
JSLinearString
*
>
candidate
(
cx
)
;
if
(
!
canParseLocale
)
{
candidate
=
NewStringCopyZ
<
CanGC
>
(
cx
intl
:
:
LastDitchLocale
(
)
)
;
if
(
!
candidate
)
{
return
nullptr
;
}
}
else
{
tag
.
ClearUnicodeExtension
(
)
;
intl
:
:
FormatBuffer
<
char
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
candidate
=
buffer
.
toAsciiString
(
cx
)
;
if
(
!
candidate
)
{
return
nullptr
;
}
for
(
const
auto
&
mapping
:
js
:
:
intl
:
:
oldStyleLanguageTagMappings
)
{
const
char
*
oldStyle
=
mapping
.
oldStyle
;
const
char
*
modernStyle
=
mapping
.
modernStyle
;
if
(
StringEqualsAscii
(
candidate
oldStyle
)
)
{
candidate
=
NewStringCopyZ
<
CanGC
>
(
cx
modernStyle
)
;
if
(
!
candidate
)
{
return
nullptr
;
}
break
;
}
}
}
Rooted
<
JSLinearString
*
>
supportedCollator
(
cx
)
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
supportedCollator
BestAvailableLocale
(
cx
AvailableLocaleKind
:
:
Collator
candidate
nullptr
)
)
;
Rooted
<
JSLinearString
*
>
supportedDateTimeFormat
(
cx
)
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
supportedDateTimeFormat
BestAvailableLocale
(
cx
AvailableLocaleKind
:
:
DateTimeFormat
candidate
nullptr
)
)
;
#
ifdef
DEBUG
for
(
auto
kind
:
{
AvailableLocaleKind
:
:
DisplayNames
AvailableLocaleKind
:
:
DurationFormat
AvailableLocaleKind
:
:
ListFormat
AvailableLocaleKind
:
:
NumberFormat
AvailableLocaleKind
:
:
PluralRules
AvailableLocaleKind
:
:
RelativeTimeFormat
AvailableLocaleKind
:
:
Segmenter
}
)
{
JSLinearString
*
supported
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
supported
BestAvailableLocale
(
cx
kind
candidate
nullptr
)
)
;
MOZ_ASSERT
(
!
!
supported
=
=
!
!
supportedDateTimeFormat
)
;
MOZ_ASSERT_IF
(
supported
EqualStrings
(
supported
supportedDateTimeFormat
)
)
;
}
#
endif
if
(
supportedCollator
&
&
supportedDateTimeFormat
)
{
if
(
SameOrParentLocale
(
supportedCollator
supportedDateTimeFormat
)
)
{
return
supportedDateTimeFormat
;
}
return
supportedCollator
;
}
return
NewStringCopyZ
<
CanGC
>
(
cx
intl
:
:
LastDitchLocale
(
)
)
;
}
