var
pluralRulesInternalProperties
=
{
localeData
:
pluralRulesLocaleData
relevantExtensionKeys
:
[
]
}
;
function
pluralRulesLocaleData
(
)
{
return
{
}
;
}
function
resolvePluralRulesInternals
(
lazyPluralRulesData
)
{
assert
(
IsObject
(
lazyPluralRulesData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
PluralRules
=
pluralRulesInternalProperties
;
var
localeData
=
PluralRules
.
localeData
;
var
r
=
ResolveLocale
(
"
PluralRules
"
lazyPluralRulesData
.
requestedLocales
lazyPluralRulesData
.
opt
PluralRules
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
type
=
lazyPluralRulesData
.
type
;
internalProps
.
minimumIntegerDigits
=
lazyPluralRulesData
.
minimumIntegerDigits
;
internalProps
.
roundingIncrement
=
lazyPluralRulesData
.
roundingIncrement
;
internalProps
.
roundingMode
=
lazyPluralRulesData
.
roundingMode
;
internalProps
.
trailingZeroDisplay
=
lazyPluralRulesData
.
trailingZeroDisplay
;
if
(
"
minimumFractionDigits
"
in
lazyPluralRulesData
)
{
assert
(
"
maximumFractionDigits
"
in
lazyPluralRulesData
"
min
/
max
frac
digits
mismatch
"
)
;
internalProps
.
minimumFractionDigits
=
lazyPluralRulesData
.
minimumFractionDigits
;
internalProps
.
maximumFractionDigits
=
lazyPluralRulesData
.
maximumFractionDigits
;
}
if
(
"
minimumSignificantDigits
"
in
lazyPluralRulesData
)
{
assert
(
"
maximumSignificantDigits
"
in
lazyPluralRulesData
"
min
/
max
sig
digits
mismatch
"
)
;
internalProps
.
minimumSignificantDigits
=
lazyPluralRulesData
.
minimumSignificantDigits
;
internalProps
.
maximumSignificantDigits
=
lazyPluralRulesData
.
maximumSignificantDigits
;
}
internalProps
.
roundingPriority
=
lazyPluralRulesData
.
roundingPriority
;
internalProps
.
pluralCategories
=
null
;
return
internalProps
;
}
function
getPluralRulesInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getPluralRulesInternals
called
with
non
-
object
"
)
;
assert
(
intl_GuardToPluralRules
(
obj
)
!
=
=
null
"
getPluralRulesInternals
called
with
non
-
PluralRules
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
PluralRules
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
{
return
internalProps
;
}
internalProps
=
resolvePluralRulesInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
InitializePluralRules
(
pluralRules
locales
options
)
{
assert
(
IsObject
(
pluralRules
)
"
InitializePluralRules
called
with
non
-
object
"
)
;
assert
(
intl_GuardToPluralRules
(
pluralRules
)
!
=
=
null
"
InitializePluralRules
called
with
non
-
PluralRules
"
)
;
var
lazyPluralRulesData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyPluralRulesData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
{
options
=
std_Object_create
(
null
)
;
}
else
{
options
=
ToObject
(
options
)
;
}
var
opt
=
NEW_RECORD
(
)
;
lazyPluralRulesData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
type
=
GetOption
(
options
"
type
"
"
string
"
[
"
cardinal
"
"
ordinal
"
]
"
cardinal
"
)
;
lazyPluralRulesData
.
type
=
type
;
SetNumberFormatDigitOptions
(
lazyPluralRulesData
options
0
3
"
standard
"
)
;
initializeIntlObject
(
pluralRules
"
PluralRules
"
lazyPluralRulesData
)
;
}
function
Intl_PluralRules_supportedLocalesOf
(
locales
)
{
var
options
=
ArgumentsLength
(
)
>
1
?
GetArgument
(
1
)
:
undefined
;
var
availableLocales
=
"
PluralRules
"
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
function
Intl_PluralRules_select
(
value
)
{
var
pluralRules
=
this
;
if
(
!
IsObject
(
pluralRules
)
|
|
(
pluralRules
=
intl_GuardToPluralRules
(
pluralRules
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallPluralRulesMethodIfWrapped
this
value
"
Intl_PluralRules_select
"
)
;
}
var
n
=
TO_NUMBER
(
value
)
;
getPluralRulesInternals
(
pluralRules
)
;
return
intl_SelectPluralRule
(
pluralRules
n
)
;
}
function
Intl_PluralRules_selectRange
(
start
end
)
{
var
pluralRules
=
this
;
if
(
!
IsObject
(
pluralRules
)
|
|
(
pluralRules
=
intl_GuardToPluralRules
(
pluralRules
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallPluralRulesMethodIfWrapped
this
start
end
"
Intl_PluralRules_selectRange
"
)
;
}
if
(
start
=
=
=
undefined
|
|
end
=
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_UNDEFINED_NUMBER
start
=
=
=
undefined
?
"
start
"
:
"
end
"
"
PluralRules
"
"
selectRange
"
)
;
}
var
x
=
TO_NUMBER
(
start
)
;
var
y
=
TO_NUMBER
(
end
)
;
return
intl_SelectPluralRuleRange
(
pluralRules
x
y
)
;
}
function
Intl_PluralRules_resolvedOptions
(
)
{
var
pluralRules
=
this
;
if
(
!
IsObject
(
pluralRules
)
|
|
(
pluralRules
=
intl_GuardToPluralRules
(
pluralRules
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallPluralRulesMethodIfWrapped
this
"
Intl_PluralRules_resolvedOptions
"
)
;
}
var
internals
=
getPluralRulesInternals
(
pluralRules
)
;
var
internalsPluralCategories
=
internals
.
pluralCategories
;
if
(
internalsPluralCategories
=
=
=
null
)
{
internalsPluralCategories
=
intl_GetPluralCategories
(
pluralRules
)
;
internals
.
pluralCategories
=
internalsPluralCategories
;
}
var
pluralCategories
=
[
]
;
for
(
var
i
=
0
;
i
<
internalsPluralCategories
.
length
;
i
+
+
)
{
DefineDataProperty
(
pluralCategories
i
internalsPluralCategories
[
i
]
)
;
}
var
result
=
{
locale
:
internals
.
locale
type
:
internals
.
type
minimumIntegerDigits
:
internals
.
minimumIntegerDigits
}
;
assert
(
hasOwn
(
"
minimumFractionDigits
"
internals
)
=
=
=
hasOwn
(
"
maximumFractionDigits
"
internals
)
"
minimumFractionDigits
is
present
iff
maximumFractionDigits
is
present
"
)
;
if
(
hasOwn
(
"
minimumFractionDigits
"
internals
)
)
{
DefineDataProperty
(
result
"
minimumFractionDigits
"
internals
.
minimumFractionDigits
)
;
DefineDataProperty
(
result
"
maximumFractionDigits
"
internals
.
maximumFractionDigits
)
;
}
assert
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
=
=
=
hasOwn
(
"
maximumSignificantDigits
"
internals
)
"
minimumSignificantDigits
is
present
iff
maximumSignificantDigits
is
present
"
)
;
if
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
)
{
DefineDataProperty
(
result
"
minimumSignificantDigits
"
internals
.
minimumSignificantDigits
)
;
DefineDataProperty
(
result
"
maximumSignificantDigits
"
internals
.
maximumSignificantDigits
)
;
}
DefineDataProperty
(
result
"
pluralCategories
"
pluralCategories
)
;
DefineDataProperty
(
result
"
roundingIncrement
"
internals
.
roundingIncrement
)
;
DefineDataProperty
(
result
"
roundingMode
"
internals
.
roundingMode
)
;
DefineDataProperty
(
result
"
roundingPriority
"
internals
.
roundingPriority
)
;
DefineDataProperty
(
result
"
trailingZeroDisplay
"
internals
.
trailingZeroDisplay
)
;
return
result
;
}
