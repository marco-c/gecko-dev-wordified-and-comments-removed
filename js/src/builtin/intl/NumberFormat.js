var
numberFormatInternalProperties
=
{
localeData
:
numberFormatLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_NumberFormat_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
nu
"
]
}
;
function
resolveNumberFormatInternals
(
lazyNumberFormatData
)
{
assert
(
IsObject
(
lazyNumberFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
NumberFormat
=
numberFormatInternalProperties
;
var
localeData
=
NumberFormat
.
localeData
;
var
r
=
ResolveLocale
(
callFunction
(
NumberFormat
.
availableLocales
NumberFormat
)
lazyNumberFormatData
.
requestedLocales
lazyNumberFormatData
.
opt
NumberFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
style
=
lazyNumberFormatData
.
style
;
internalProps
.
style
=
style
;
if
(
style
=
=
=
"
currency
"
)
{
internalProps
.
currency
=
lazyNumberFormatData
.
currency
;
internalProps
.
currencyDisplay
=
lazyNumberFormatData
.
currencyDisplay
;
}
internalProps
.
minimumIntegerDigits
=
lazyNumberFormatData
.
minimumIntegerDigits
;
internalProps
.
minimumFractionDigits
=
lazyNumberFormatData
.
minimumFractionDigits
;
internalProps
.
maximumFractionDigits
=
lazyNumberFormatData
.
maximumFractionDigits
;
if
(
"
minimumSignificantDigits
"
in
lazyNumberFormatData
)
{
assert
(
"
maximumSignificantDigits
"
in
lazyNumberFormatData
"
min
/
max
sig
digits
mismatch
"
)
;
internalProps
.
minimumSignificantDigits
=
lazyNumberFormatData
.
minimumSignificantDigits
;
internalProps
.
maximumSignificantDigits
=
lazyNumberFormatData
.
maximumSignificantDigits
;
}
internalProps
.
useGrouping
=
lazyNumberFormatData
.
useGrouping
;
return
internalProps
;
}
function
getNumberFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getNumberFormatInternals
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
obj
)
!
=
=
null
"
getNumberFormatInternals
called
with
non
-
NumberFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
NumberFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapNumberFormat
(
nf
)
{
if
(
IsObject
(
nf
)
&
&
GuardToNumberFormat
(
nf
)
=
=
=
null
&
&
!
IsWrappedNumberFormat
(
nf
)
&
&
nf
instanceof
GetNumberFormatConstructor
(
)
)
{
nf
=
nf
[
intlFallbackSymbol
(
)
]
;
}
return
nf
;
}
function
SetNumberFormatDigitOptions
(
lazyData
options
mnfdDefault
mxfdDefault
)
{
assert
(
IsObject
(
options
)
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mnfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mxfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
mnfdDefault
<
=
mxfdDefault
"
SetNumberFormatDigitOptions
"
)
;
const
mnid
=
GetNumberOption
(
options
"
minimumIntegerDigits
"
1
21
1
)
;
const
mnfd
=
GetNumberOption
(
options
"
minimumFractionDigits
"
0
20
mnfdDefault
)
;
const
mxfdActualDefault
=
std_Math_max
(
mnfd
mxfdDefault
)
;
const
mxfd
=
GetNumberOption
(
options
"
maximumFractionDigits
"
mnfd
20
mxfdActualDefault
)
;
let
mnsd
=
options
.
minimumSignificantDigits
;
let
mxsd
=
options
.
maximumSignificantDigits
;
lazyData
.
minimumIntegerDigits
=
mnid
;
lazyData
.
minimumFractionDigits
=
mnfd
;
lazyData
.
maximumFractionDigits
=
mxfd
;
if
(
mnsd
!
=
=
undefined
|
|
mxsd
!
=
=
undefined
)
{
mnsd
=
DefaultNumberOption
(
mnsd
1
21
1
)
;
mxsd
=
DefaultNumberOption
(
mxsd
mnsd
21
21
)
;
lazyData
.
minimumSignificantDigits
=
mnsd
;
lazyData
.
maximumSignificantDigits
=
mxsd
;
}
}
function
toASCIIUpperCase
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
toASCIIUpperCase
"
)
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
result
+
=
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
?
callFunction
(
std_String_fromCharCode
null
c
&
~
0x20
)
:
s
[
i
]
;
}
return
result
;
}
function
IsWellFormedCurrencyCode
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
currency
is
a
string
value
"
)
;
return
currency
.
length
=
=
=
3
&
&
IsASCIIAlphaString
(
currency
)
;
}
function
InitializeNumberFormat
(
numberFormat
thisValue
locales
options
)
{
assert
(
IsObject
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
numberFormat
)
!
=
=
null
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
lazyNumberFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyNumberFormatData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
opt
=
new
Record
(
)
;
lazyNumberFormatData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
style
=
GetOption
(
options
"
style
"
"
string
"
[
"
decimal
"
"
percent
"
"
currency
"
]
"
decimal
"
)
;
lazyNumberFormatData
.
style
=
style
;
var
c
=
GetOption
(
options
"
currency
"
"
string
"
undefined
undefined
)
;
if
(
c
!
=
=
undefined
&
&
!
IsWellFormedCurrencyCode
(
c
)
)
ThrowRangeError
(
JSMSG_INVALID_CURRENCY_CODE
c
)
;
var
cDigits
;
if
(
style
=
=
=
"
currency
"
)
{
if
(
c
=
=
=
undefined
)
ThrowTypeError
(
JSMSG_UNDEFINED_CURRENCY
)
;
c
=
toASCIIUpperCase
(
c
)
;
lazyNumberFormatData
.
currency
=
c
;
cDigits
=
CurrencyDigits
(
c
)
;
}
var
cd
=
GetOption
(
options
"
currencyDisplay
"
"
string
"
[
"
code
"
"
symbol
"
"
name
"
]
"
symbol
"
)
;
if
(
style
=
=
=
"
currency
"
)
lazyNumberFormatData
.
currencyDisplay
=
cd
;
var
mnfdDefault
mxfdDefault
;
if
(
style
=
=
=
"
currency
"
)
{
mnfdDefault
=
cDigits
;
mxfdDefault
=
cDigits
;
}
else
{
mnfdDefault
=
0
;
mxfdDefault
=
style
=
=
=
"
percent
"
?
0
:
3
;
}
SetNumberFormatDigitOptions
(
lazyNumberFormatData
options
mnfdDefault
mxfdDefault
)
;
var
g
=
GetOption
(
options
"
useGrouping
"
"
boolean
"
undefined
true
)
;
lazyNumberFormatData
.
useGrouping
=
g
;
initializeIntlObject
(
numberFormat
"
NumberFormat
"
lazyNumberFormatData
)
;
if
(
numberFormat
!
=
=
thisValue
&
&
IsObject
(
thisValue
)
&
&
thisValue
instanceof
GetNumberFormatConstructor
(
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
numberFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
numberFormat
;
}
function
CurrencyDigits
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
currency
is
a
string
value
"
)
;
assert
(
IsWellFormedCurrencyCode
(
currency
)
"
currency
is
well
-
formed
"
)
;
assert
(
currency
=
=
toASCIIUpperCase
(
currency
)
"
currency
is
all
upper
-
case
"
)
;
if
(
hasOwn
(
currency
currencyDigits
)
)
return
currencyDigits
[
currency
]
;
return
2
;
}
function
Intl_NumberFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
function
getNumberingSystems
(
locale
)
{
var
defaultNumberingSystem
=
intl_numberingSystem
(
locale
)
;
return
[
defaultNumberingSystem
"
arab
"
"
arabext
"
"
bali
"
"
beng
"
"
deva
"
"
fullwide
"
"
gujr
"
"
guru
"
"
hanidec
"
"
khmr
"
"
knda
"
"
laoo
"
"
latn
"
"
limb
"
"
mlym
"
"
mong
"
"
mymr
"
"
orya
"
"
tamldec
"
"
telu
"
"
thai
"
"
tibt
"
]
;
}
function
numberFormatLocaleData
(
)
{
return
{
nu
:
getNumberingSystems
default
:
{
nu
:
intl_numberingSystem
}
}
;
}
function
numberFormatFormatToBind
(
value
)
{
var
nf
=
this
;
assert
(
IsObject
(
nf
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
nf
)
!
=
=
null
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
x
=
ToNumeric
(
value
)
;
return
intl_FormatNumber
(
nf
x
false
)
;
}
function
Intl_NumberFormat_format_get
(
)
{
var
thisArg
=
UnwrapNumberFormat
(
this
)
;
var
nf
=
thisArg
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
thisArg
"
Intl_NumberFormat_format_get
"
)
;
}
var
internals
=
getNumberFormatInternals
(
nf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
var
F
=
callFunction
(
FunctionBind
numberFormatFormatToBind
nf
)
;
internals
.
boundFormat
=
F
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_NumberFormat_format_get
"
get
format
"
)
;
function
Intl_NumberFormat_formatToParts
(
value
)
{
var
nf
=
this
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
this
value
"
Intl_NumberFormat_formatToParts
"
)
;
}
getNumberFormatInternals
(
nf
)
;
var
x
=
ToNumeric
(
value
)
;
return
intl_FormatNumber
(
nf
x
true
)
;
}
function
Intl_NumberFormat_resolvedOptions
(
)
{
var
thisArg
=
UnwrapNumberFormat
(
this
)
;
var
nf
=
thisArg
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
thisArg
"
Intl_NumberFormat_resolvedOptions
"
)
;
}
var
internals
=
getNumberFormatInternals
(
nf
)
;
var
result
=
{
locale
:
internals
.
locale
numberingSystem
:
internals
.
numberingSystem
style
:
internals
.
style
}
;
assert
(
hasOwn
(
"
currency
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
currency
"
)
"
currency
is
present
iff
style
is
'
currency
'
"
)
;
assert
(
hasOwn
(
"
currencyDisplay
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
currency
"
)
"
currencyDisplay
is
present
iff
style
is
'
currency
'
"
)
;
if
(
hasOwn
(
"
currency
"
internals
)
)
{
_DefineDataProperty
(
result
"
currency
"
internals
.
currency
)
;
_DefineDataProperty
(
result
"
currencyDisplay
"
internals
.
currencyDisplay
)
;
}
_DefineDataProperty
(
result
"
minimumIntegerDigits
"
internals
.
minimumIntegerDigits
)
;
_DefineDataProperty
(
result
"
minimumFractionDigits
"
internals
.
minimumFractionDigits
)
;
_DefineDataProperty
(
result
"
maximumFractionDigits
"
internals
.
maximumFractionDigits
)
;
assert
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
=
=
=
hasOwn
(
"
maximumSignificantDigits
"
internals
)
"
minimumSignificantDigits
is
present
iff
maximumSignificantDigits
is
present
"
)
;
if
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
)
{
_DefineDataProperty
(
result
"
minimumSignificantDigits
"
internals
.
minimumSignificantDigits
)
;
_DefineDataProperty
(
result
"
maximumSignificantDigits
"
internals
.
maximumSignificantDigits
)
;
}
_DefineDataProperty
(
result
"
useGrouping
"
internals
.
useGrouping
)
;
return
result
;
}
