#
include
"
NumberingSystemsGenerated
.
h
"
var
numberFormatInternalProperties
=
{
localeData
:
numberFormatLocaleData
relevantExtensionKeys
:
[
"
nu
"
]
}
;
function
resolveNumberFormatInternals
(
lazyNumberFormatData
)
{
assert
(
IsObject
(
lazyNumberFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
NumberFormat
=
numberFormatInternalProperties
;
var
localeData
=
NumberFormat
.
localeData
;
var
r
=
ResolveLocale
(
"
NumberFormat
"
lazyNumberFormatData
.
requestedLocales
lazyNumberFormatData
.
opt
NumberFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
style
=
lazyNumberFormatData
.
style
;
internalProps
.
style
=
style
;
if
(
style
=
=
=
"
currency
"
)
{
internalProps
.
currency
=
lazyNumberFormatData
.
currency
;
internalProps
.
currencyDisplay
=
lazyNumberFormatData
.
currencyDisplay
;
internalProps
.
currencySign
=
lazyNumberFormatData
.
currencySign
;
}
if
(
style
=
=
=
"
unit
"
)
{
internalProps
.
unit
=
lazyNumberFormatData
.
unit
;
internalProps
.
unitDisplay
=
lazyNumberFormatData
.
unitDisplay
;
}
var
notation
=
lazyNumberFormatData
.
notation
;
internalProps
.
notation
=
notation
;
internalProps
.
minimumIntegerDigits
=
lazyNumberFormatData
.
minimumIntegerDigits
;
if
(
"
minimumFractionDigits
"
in
lazyNumberFormatData
)
{
assert
(
"
maximumFractionDigits
"
in
lazyNumberFormatData
"
min
/
max
frac
digits
mismatch
"
)
;
internalProps
.
minimumFractionDigits
=
lazyNumberFormatData
.
minimumFractionDigits
;
internalProps
.
maximumFractionDigits
=
lazyNumberFormatData
.
maximumFractionDigits
;
}
if
(
"
minimumSignificantDigits
"
in
lazyNumberFormatData
)
{
assert
(
"
maximumSignificantDigits
"
in
lazyNumberFormatData
"
min
/
max
sig
digits
mismatch
"
)
;
internalProps
.
minimumSignificantDigits
=
lazyNumberFormatData
.
minimumSignificantDigits
;
internalProps
.
maximumSignificantDigits
=
lazyNumberFormatData
.
maximumSignificantDigits
;
}
if
(
notation
=
=
=
"
compact
"
)
internalProps
.
compactDisplay
=
lazyNumberFormatData
.
compactDisplay
;
internalProps
.
useGrouping
=
lazyNumberFormatData
.
useGrouping
;
internalProps
.
signDisplay
=
lazyNumberFormatData
.
signDisplay
;
return
internalProps
;
}
function
getNumberFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getNumberFormatInternals
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
obj
)
!
=
=
null
"
getNumberFormatInternals
called
with
non
-
NumberFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
NumberFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapNumberFormat
(
nf
)
{
if
(
IsObject
(
nf
)
&
&
GuardToNumberFormat
(
nf
)
=
=
=
null
&
&
!
IsWrappedNumberFormat
(
nf
)
&
&
callFunction
(
std_Object_isPrototypeOf
GetBuiltinPrototype
(
"
NumberFormat
"
)
nf
)
)
{
nf
=
nf
[
intlFallbackSymbol
(
)
]
;
}
return
nf
;
}
function
SetNumberFormatDigitOptions
(
lazyData
options
mnfdDefault
mxfdDefault
notation
)
{
assert
(
IsObject
(
options
)
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mnfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mxfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
mnfdDefault
<
=
mxfdDefault
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
notation
=
=
=
"
string
"
"
SetNumberFormatDigitOptions
"
)
;
const
mnid
=
GetNumberOption
(
options
"
minimumIntegerDigits
"
1
21
1
)
;
let
mnfd
=
options
.
minimumFractionDigits
;
let
mxfd
=
options
.
maximumFractionDigits
;
let
mnsd
=
options
.
minimumSignificantDigits
;
let
mxsd
=
options
.
maximumSignificantDigits
;
lazyData
.
minimumIntegerDigits
=
mnid
;
if
(
mnsd
!
=
=
undefined
|
|
mxsd
!
=
=
undefined
)
{
mnsd
=
DefaultNumberOption
(
mnsd
1
21
1
)
;
mxsd
=
DefaultNumberOption
(
mxsd
mnsd
21
21
)
;
lazyData
.
minimumSignificantDigits
=
mnsd
;
lazyData
.
maximumSignificantDigits
=
mxsd
;
}
else
if
(
mnfd
!
=
=
undefined
|
|
mxfd
!
=
=
undefined
)
{
mnfd
=
DefaultNumberOption
(
mnfd
0
20
undefined
)
;
mxfd
=
DefaultNumberOption
(
mxfd
0
20
undefined
)
;
if
(
mnfd
=
=
=
undefined
)
{
assert
(
mxfd
!
=
=
undefined
"
mxfd
isn
'
t
undefined
when
mnfd
is
undefined
"
)
;
mnfd
=
std_Math_min
(
mnfdDefault
mxfd
)
;
}
else
if
(
mxfd
=
=
=
undefined
)
{
mxfd
=
std_Math_max
(
mxfdDefault
mnfd
)
;
}
else
if
(
mnfd
>
mxfd
)
{
ThrowRangeError
(
JSMSG_INVALID_DIGITS_VALUE
mxfd
)
;
}
lazyData
.
minimumFractionDigits
=
mnfd
;
lazyData
.
maximumFractionDigits
=
mxfd
;
}
else
if
(
notation
=
=
=
"
compact
"
)
{
}
else
{
lazyData
.
minimumFractionDigits
=
mnfdDefault
;
lazyData
.
maximumFractionDigits
=
mxfdDefault
;
}
}
function
toASCIIUpperCase
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
toASCIIUpperCase
"
)
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
result
+
=
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
?
callFunction
(
std_String_fromCharCode
null
c
&
~
0x20
)
:
s
[
i
]
;
}
return
result
;
}
function
IsWellFormedCurrencyCode
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
currency
is
a
string
value
"
)
;
return
currency
.
length
=
=
=
3
&
&
IsASCIIAlphaString
(
currency
)
;
}
function
IsWellFormedUnitIdentifier
(
unitIdentifier
)
{
assert
(
typeof
unitIdentifier
=
=
=
"
string
"
"
unitIdentifier
is
a
string
value
"
)
;
if
(
IsSanctionedSimpleUnitIdentifier
(
unitIdentifier
)
)
return
true
;
var
pos
=
callFunction
(
std_String_indexOf
unitIdentifier
"
-
per
-
"
)
;
if
(
pos
<
0
)
return
false
;
var
next
=
pos
+
"
-
per
-
"
.
length
;
var
numerator
=
Substring
(
unitIdentifier
0
pos
)
;
var
denominator
=
Substring
(
unitIdentifier
next
unitIdentifier
.
length
-
next
)
;
return
IsSanctionedSimpleUnitIdentifier
(
numerator
)
&
&
IsSanctionedSimpleUnitIdentifier
(
denominator
)
;
}
#
if
DEBUG
|
|
MOZ_SYSTEM_ICU
var
availableMeasurementUnits
=
{
value
:
null
}
;
#
endif
function
IsSanctionedSimpleUnitIdentifier
(
unitIdentifier
)
{
assert
(
typeof
unitIdentifier
=
=
=
"
string
"
"
unitIdentifier
is
a
string
value
"
)
;
var
isSanctioned
=
hasOwn
(
unitIdentifier
sanctionedSimpleUnitIdentifiers
)
;
#
if
DEBUG
|
|
MOZ_SYSTEM_ICU
if
(
isSanctioned
)
{
if
(
availableMeasurementUnits
.
value
=
=
=
null
)
availableMeasurementUnits
.
value
=
intl_availableMeasurementUnits
(
)
;
var
isSupported
=
hasOwn
(
unitIdentifier
availableMeasurementUnits
.
value
)
;
#
if
MOZ_SYSTEM_ICU
isSanctioned
=
isSupported
;
#
else
assert
(
isSupported
"
{
unitIdentifier
}
"
is
sanctioned
but
not
supported
.
Did
you
forget
to
update
intl
/
icu
/
data_filter
.
json
to
include
the
unit
(
and
any
implicit
compound
units
)
?
For
example
"
speed
/
kilometer
-
per
-
hour
"
is
implied
by
"
length
/
kilometer
"
and
"
duration
/
hour
"
and
must
therefore
also
be
present
.
)
;
#
endif
}
#
endif
return
isSanctioned
;
}
function
InitializeNumberFormat
(
numberFormat
thisValue
locales
options
)
{
assert
(
IsObject
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
numberFormat
)
!
=
=
null
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
lazyNumberFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyNumberFormatData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
opt
=
new
Record
(
)
;
lazyNumberFormatData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
numberingSystem
=
GetOption
(
options
"
numberingSystem
"
"
string
"
undefined
undefined
)
;
if
(
numberingSystem
!
=
=
undefined
)
{
numberingSystem
=
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
numberingSystem
"
numberingSystem
"
"
nu
"
)
;
}
opt
.
nu
=
numberingSystem
;
var
style
=
GetOption
(
options
"
style
"
"
string
"
[
"
decimal
"
"
percent
"
"
currency
"
"
unit
"
]
"
decimal
"
)
;
lazyNumberFormatData
.
style
=
style
;
var
currency
=
GetOption
(
options
"
currency
"
"
string
"
undefined
undefined
)
;
if
(
currency
!
=
=
undefined
&
&
!
IsWellFormedCurrencyCode
(
currency
)
)
ThrowRangeError
(
JSMSG_INVALID_CURRENCY_CODE
currency
)
;
var
cDigits
;
if
(
style
=
=
=
"
currency
"
)
{
if
(
currency
=
=
=
undefined
)
ThrowTypeError
(
JSMSG_UNDEFINED_CURRENCY
)
;
currency
=
toASCIIUpperCase
(
currency
)
;
lazyNumberFormatData
.
currency
=
currency
;
cDigits
=
CurrencyDigits
(
currency
)
;
}
var
currencyDisplay
=
GetOption
(
options
"
currencyDisplay
"
"
string
"
[
"
code
"
"
symbol
"
"
narrowSymbol
"
"
name
"
]
"
symbol
"
)
;
if
(
style
=
=
=
"
currency
"
)
lazyNumberFormatData
.
currencyDisplay
=
currencyDisplay
;
var
currencySign
=
GetOption
(
options
"
currencySign
"
"
string
"
[
"
standard
"
"
accounting
"
]
"
standard
"
)
;
if
(
style
=
=
=
"
currency
"
)
lazyNumberFormatData
.
currencySign
=
currencySign
;
var
unit
=
GetOption
(
options
"
unit
"
"
string
"
undefined
undefined
)
;
if
(
unit
!
=
=
undefined
&
&
!
IsWellFormedUnitIdentifier
(
unit
)
)
ThrowRangeError
(
JSMSG_INVALID_UNIT_IDENTIFIER
unit
)
;
var
unitDisplay
=
GetOption
(
options
"
unitDisplay
"
"
string
"
[
"
short
"
"
narrow
"
"
long
"
]
"
short
"
)
;
if
(
style
=
=
=
"
unit
"
)
{
if
(
unit
=
=
=
undefined
)
ThrowTypeError
(
JSMSG_UNDEFINED_UNIT
)
;
lazyNumberFormatData
.
unit
=
unit
;
lazyNumberFormatData
.
unitDisplay
=
unitDisplay
;
}
var
mnfdDefault
mxfdDefault
;
if
(
style
=
=
=
"
currency
"
)
{
mnfdDefault
=
cDigits
;
mxfdDefault
=
cDigits
;
}
else
{
mnfdDefault
=
0
;
mxfdDefault
=
style
=
=
=
"
percent
"
?
0
:
3
;
}
var
notation
=
GetOption
(
options
"
notation
"
"
string
"
[
"
standard
"
"
scientific
"
"
engineering
"
"
compact
"
]
"
standard
"
)
;
lazyNumberFormatData
.
notation
=
notation
;
SetNumberFormatDigitOptions
(
lazyNumberFormatData
options
mnfdDefault
mxfdDefault
notation
)
;
var
compactDisplay
=
GetOption
(
options
"
compactDisplay
"
"
string
"
[
"
short
"
"
long
"
]
"
short
"
)
;
if
(
notation
=
=
=
"
compact
"
)
lazyNumberFormatData
.
compactDisplay
=
compactDisplay
;
var
useGrouping
=
GetOption
(
options
"
useGrouping
"
"
boolean
"
undefined
true
)
;
lazyNumberFormatData
.
useGrouping
=
useGrouping
;
var
signDisplay
=
GetOption
(
options
"
signDisplay
"
"
string
"
[
"
auto
"
"
never
"
"
always
"
"
exceptZero
"
]
"
auto
"
)
;
lazyNumberFormatData
.
signDisplay
=
signDisplay
;
initializeIntlObject
(
numberFormat
"
NumberFormat
"
lazyNumberFormatData
)
;
if
(
numberFormat
!
=
=
thisValue
&
&
callFunction
(
std_Object_isPrototypeOf
GetBuiltinPrototype
(
"
NumberFormat
"
)
thisValue
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
numberFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
numberFormat
;
}
function
CurrencyDigits
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
currency
is
a
string
value
"
)
;
assert
(
IsWellFormedCurrencyCode
(
currency
)
"
currency
is
well
-
formed
"
)
;
assert
(
currency
=
=
toASCIIUpperCase
(
currency
)
"
currency
is
all
upper
-
case
"
)
;
if
(
hasOwn
(
currency
currencyDigits
)
)
return
currencyDigits
[
currency
]
;
return
2
;
}
function
Intl_NumberFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
"
NumberFormat
"
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
function
getNumberingSystems
(
locale
)
{
var
defaultNumberingSystem
=
intl_numberingSystem
(
locale
)
;
return
[
defaultNumberingSystem
NUMBERING_SYSTEMS_WITH_SIMPLE_DIGIT_MAPPINGS
]
;
}
function
numberFormatLocaleData
(
)
{
return
{
nu
:
getNumberingSystems
default
:
{
nu
:
intl_numberingSystem
}
}
;
}
function
createNumberFormatFormat
(
nf
)
{
return
function
(
value
)
{
assert
(
IsObject
(
nf
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
GuardToNumberFormat
(
nf
)
!
=
=
null
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
x
=
ToNumeric
(
value
)
;
return
intl_FormatNumber
(
nf
x
false
false
)
;
}
;
}
function
Intl_NumberFormat_format_get
(
)
{
var
thisArg
=
UnwrapNumberFormat
(
this
)
;
var
nf
=
thisArg
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
thisArg
"
Intl_NumberFormat_format_get
"
)
;
}
var
internals
=
getNumberFormatInternals
(
nf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
internals
.
boundFormat
=
createNumberFormatFormat
(
nf
)
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_NumberFormat_format_get
"
get
format
"
)
;
function
Intl_NumberFormat_formatToParts
(
value
)
{
var
nf
=
this
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
this
value
"
Intl_NumberFormat_formatToParts
"
)
;
}
var
x
=
ToNumeric
(
value
)
;
var
internals
=
getNumberFormatInternals
(
nf
)
;
var
unitStyle
=
internals
.
style
=
=
=
"
unit
"
;
return
intl_FormatNumber
(
nf
x
true
unitStyle
)
;
}
function
Intl_NumberFormat_resolvedOptions
(
)
{
var
thisArg
=
UnwrapNumberFormat
(
this
)
;
var
nf
=
thisArg
;
if
(
!
IsObject
(
nf
)
|
|
(
nf
=
GuardToNumberFormat
(
nf
)
)
=
=
=
null
)
{
return
callFunction
(
CallNumberFormatMethodIfWrapped
thisArg
"
Intl_NumberFormat_resolvedOptions
"
)
;
}
var
internals
=
getNumberFormatInternals
(
nf
)
;
var
result
=
{
locale
:
internals
.
locale
numberingSystem
:
internals
.
numberingSystem
style
:
internals
.
style
}
;
assert
(
hasOwn
(
"
currency
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
currency
"
)
"
currency
is
present
iff
style
is
'
currency
'
"
)
;
assert
(
hasOwn
(
"
currencyDisplay
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
currency
"
)
"
currencyDisplay
is
present
iff
style
is
'
currency
'
"
)
;
assert
(
hasOwn
(
"
currencySign
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
currency
"
)
"
currencySign
is
present
iff
style
is
'
currency
'
"
)
;
if
(
hasOwn
(
"
currency
"
internals
)
)
{
_DefineDataProperty
(
result
"
currency
"
internals
.
currency
)
;
_DefineDataProperty
(
result
"
currencyDisplay
"
internals
.
currencyDisplay
)
;
_DefineDataProperty
(
result
"
currencySign
"
internals
.
currencySign
)
;
}
assert
(
hasOwn
(
"
unit
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
unit
"
)
"
unit
is
present
iff
style
is
'
unit
'
"
)
;
assert
(
hasOwn
(
"
unitDisplay
"
internals
)
=
=
=
(
internals
.
style
=
=
=
"
unit
"
)
"
unitDisplay
is
present
iff
style
is
'
unit
'
"
)
;
if
(
hasOwn
(
"
unit
"
internals
)
)
{
_DefineDataProperty
(
result
"
unit
"
internals
.
unit
)
;
_DefineDataProperty
(
result
"
unitDisplay
"
internals
.
unitDisplay
)
;
}
_DefineDataProperty
(
result
"
minimumIntegerDigits
"
internals
.
minimumIntegerDigits
)
;
assert
(
hasOwn
(
"
minimumFractionDigits
"
internals
)
=
=
=
hasOwn
(
"
maximumFractionDigits
"
internals
)
"
minimumFractionDigits
is
present
iff
maximumFractionDigits
is
present
"
)
;
if
(
hasOwn
(
"
minimumFractionDigits
"
internals
)
)
{
_DefineDataProperty
(
result
"
minimumFractionDigits
"
internals
.
minimumFractionDigits
)
;
_DefineDataProperty
(
result
"
maximumFractionDigits
"
internals
.
maximumFractionDigits
)
;
}
assert
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
=
=
=
hasOwn
(
"
maximumSignificantDigits
"
internals
)
"
minimumSignificantDigits
is
present
iff
maximumSignificantDigits
is
present
"
)
;
if
(
hasOwn
(
"
minimumSignificantDigits
"
internals
)
)
{
_DefineDataProperty
(
result
"
minimumSignificantDigits
"
internals
.
minimumSignificantDigits
)
;
_DefineDataProperty
(
result
"
maximumSignificantDigits
"
internals
.
maximumSignificantDigits
)
;
}
_DefineDataProperty
(
result
"
useGrouping
"
internals
.
useGrouping
)
;
var
notation
=
internals
.
notation
;
_DefineDataProperty
(
result
"
notation
"
notation
)
;
if
(
notation
=
=
=
"
compact
"
)
_DefineDataProperty
(
result
"
compactDisplay
"
internals
.
compactDisplay
)
;
_DefineDataProperty
(
result
"
signDisplay
"
internals
.
signDisplay
)
;
return
result
;
}
