var
numberFormatInternalProperties
=
{
localeData
:
numberFormatLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_NumberFormat_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
nu
"
]
}
;
function
resolveNumberFormatInternals
(
lazyNumberFormatData
)
{
assert
(
IsObject
(
lazyNumberFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
requestedLocales
=
lazyNumberFormatData
.
requestedLocales
;
var
opt
=
lazyNumberFormatData
.
opt
;
var
NumberFormat
=
numberFormatInternalProperties
;
var
localeData
=
NumberFormat
.
localeData
;
var
r
=
ResolveLocale
(
callFunction
(
NumberFormat
.
availableLocales
NumberFormat
)
requestedLocales
opt
NumberFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
style
=
lazyNumberFormatData
.
style
;
internalProps
.
style
=
style
;
if
(
style
=
=
=
"
currency
"
)
{
internalProps
.
currency
=
lazyNumberFormatData
.
currency
;
internalProps
.
currencyDisplay
=
lazyNumberFormatData
.
currencyDisplay
;
}
internalProps
.
minimumIntegerDigits
=
lazyNumberFormatData
.
minimumIntegerDigits
;
internalProps
.
minimumFractionDigits
=
lazyNumberFormatData
.
minimumFractionDigits
;
internalProps
.
maximumFractionDigits
=
lazyNumberFormatData
.
maximumFractionDigits
;
if
(
"
minimumSignificantDigits
"
in
lazyNumberFormatData
)
{
assert
(
"
maximumSignificantDigits
"
in
lazyNumberFormatData
"
min
/
max
sig
digits
mismatch
"
)
;
internalProps
.
minimumSignificantDigits
=
lazyNumberFormatData
.
minimumSignificantDigits
;
internalProps
.
maximumSignificantDigits
=
lazyNumberFormatData
.
maximumSignificantDigits
;
}
internalProps
.
useGrouping
=
lazyNumberFormatData
.
useGrouping
;
internalProps
.
boundFormat
=
undefined
;
return
internalProps
;
}
function
getNumberFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getNumberFormatInternals
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
obj
)
"
getNumberFormatInternals
called
with
non
-
NumberFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
NumberFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapNumberFormat
(
nf
methodName
)
{
if
(
IsObject
(
nf
)
&
&
!
IsNumberFormat
(
nf
)
&
&
nf
instanceof
GetNumberFormatConstructor
(
)
)
nf
=
nf
[
intlFallbackSymbol
(
)
]
;
if
(
!
IsObject
(
nf
)
|
|
!
IsNumberFormat
(
nf
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
NumberFormat
"
methodName
"
NumberFormat
"
)
;
return
nf
;
}
function
SetNumberFormatDigitOptions
(
lazyData
options
mnfdDefault
mxfdDefault
)
{
assert
(
IsObject
(
options
)
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mnfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mxfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
mnfdDefault
<
=
mxfdDefault
"
SetNumberFormatDigitOptions
"
)
;
const
mnid
=
GetNumberOption
(
options
"
minimumIntegerDigits
"
1
21
1
)
;
const
mnfd
=
GetNumberOption
(
options
"
minimumFractionDigits
"
0
20
mnfdDefault
)
;
const
mxfdActualDefault
=
std_Math_max
(
mnfd
mxfdDefault
)
;
const
mxfd
=
GetNumberOption
(
options
"
maximumFractionDigits
"
mnfd
20
mxfdActualDefault
)
;
let
mnsd
=
options
.
minimumSignificantDigits
;
let
mxsd
=
options
.
maximumSignificantDigits
;
lazyData
.
minimumIntegerDigits
=
mnid
;
lazyData
.
minimumFractionDigits
=
mnfd
;
lazyData
.
maximumFractionDigits
=
mxfd
;
if
(
mnsd
!
=
=
undefined
|
|
mxsd
!
=
=
undefined
)
{
mnsd
=
DefaultNumberOption
(
mnsd
1
21
1
)
;
mxsd
=
DefaultNumberOption
(
mxsd
mnsd
21
21
)
;
lazyData
.
minimumSignificantDigits
=
mnsd
;
lazyData
.
maximumSignificantDigits
=
mxsd
;
}
}
function
toASCIIUpperCase
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
toASCIIUpperCase
"
)
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
result
+
=
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
?
callFunction
(
std_String_fromCharCode
null
c
&
~
0x20
)
:
s
[
i
]
;
}
return
result
;
}
function
getIsWellFormedCurrencyCodeRE
(
)
{
return
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
|
|
(
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
=
RegExpCreate
(
"
[
^
A
-
Z
]
"
)
)
;
}
function
IsWellFormedCurrencyCode
(
currency
)
{
var
c
=
ToString
(
currency
)
;
var
normalized
=
toASCIIUpperCase
(
c
)
;
if
(
normalized
.
length
!
=
=
3
)
return
false
;
return
!
regexp_test_no_statics
(
getIsWellFormedCurrencyCodeRE
(
)
normalized
)
;
}
function
InitializeNumberFormat
(
numberFormat
thisValue
locales
options
)
{
assert
(
IsObject
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
lazyNumberFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyNumberFormatData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
opt
=
new
Record
(
)
;
lazyNumberFormatData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
style
=
GetOption
(
options
"
style
"
"
string
"
[
"
decimal
"
"
percent
"
"
currency
"
]
"
decimal
"
)
;
lazyNumberFormatData
.
style
=
style
;
var
c
=
GetOption
(
options
"
currency
"
"
string
"
undefined
undefined
)
;
if
(
c
!
=
=
undefined
&
&
!
IsWellFormedCurrencyCode
(
c
)
)
ThrowRangeError
(
JSMSG_INVALID_CURRENCY_CODE
c
)
;
var
cDigits
;
if
(
style
=
=
=
"
currency
"
)
{
if
(
c
=
=
=
undefined
)
ThrowTypeError
(
JSMSG_UNDEFINED_CURRENCY
)
;
c
=
toASCIIUpperCase
(
c
)
;
lazyNumberFormatData
.
currency
=
c
;
cDigits
=
CurrencyDigits
(
c
)
;
}
var
cd
=
GetOption
(
options
"
currencyDisplay
"
"
string
"
[
"
code
"
"
symbol
"
"
name
"
]
"
symbol
"
)
;
if
(
style
=
=
=
"
currency
"
)
lazyNumberFormatData
.
currencyDisplay
=
cd
;
var
mnfdDefault
mxfdDefault
;
if
(
style
=
=
=
"
currency
"
)
{
mnfdDefault
=
cDigits
;
mxfdDefault
=
cDigits
;
}
else
{
mnfdDefault
=
0
;
mxfdDefault
=
style
=
=
=
"
percent
"
?
0
:
3
;
}
SetNumberFormatDigitOptions
(
lazyNumberFormatData
options
mnfdDefault
mxfdDefault
)
;
var
g
=
GetOption
(
options
"
useGrouping
"
"
boolean
"
undefined
true
)
;
lazyNumberFormatData
.
useGrouping
=
g
;
initializeIntlObject
(
numberFormat
"
NumberFormat
"
lazyNumberFormatData
)
;
if
(
numberFormat
!
=
=
thisValue
&
&
IsObject
(
thisValue
)
&
&
thisValue
instanceof
GetNumberFormatConstructor
(
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
numberFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
numberFormat
;
}
function
getCurrencyDigitsRE
(
)
{
return
internalIntlRegExps
.
currencyDigitsRE
|
|
(
internalIntlRegExps
.
currencyDigitsRE
=
RegExpCreate
(
"
^
[
A
-
Z
]
{
3
}
"
)
)
;
}
function
CurrencyDigits
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
CurrencyDigits
"
)
;
assert
(
regexp_test_no_statics
(
getCurrencyDigitsRE
(
)
currency
)
"
CurrencyDigits
"
)
;
if
(
hasOwn
(
currency
currencyDigits
)
)
return
currencyDigits
[
currency
]
;
return
2
;
}
function
Intl_NumberFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
function
getNumberingSystems
(
locale
)
{
var
defaultNumberingSystem
=
intl_numberingSystem
(
locale
)
;
return
[
defaultNumberingSystem
"
arab
"
"
arabext
"
"
bali
"
"
beng
"
"
deva
"
"
fullwide
"
"
gujr
"
"
guru
"
"
hanidec
"
"
khmr
"
"
knda
"
"
laoo
"
"
latn
"
"
limb
"
"
mlym
"
"
mong
"
"
mymr
"
"
orya
"
"
tamldec
"
"
telu
"
"
thai
"
"
tibt
"
]
;
}
function
numberFormatLocaleData
(
)
{
return
{
nu
:
getNumberingSystems
default
:
{
nu
:
intl_numberingSystem
}
}
;
}
function
numberFormatFormatToBind
(
value
)
{
var
nf
=
this
;
assert
(
IsObject
(
nf
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
nf
)
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
x
=
ToNumber
(
value
)
;
return
intl_FormatNumber
(
nf
x
false
)
;
}
function
Intl_NumberFormat_format_get
(
)
{
var
nf
=
UnwrapNumberFormat
(
this
"
format
"
)
;
var
internals
=
getNumberFormatInternals
(
nf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
var
F
=
numberFormatFormatToBind
;
var
bf
=
callFunction
(
FunctionBind
F
nf
)
;
internals
.
boundFormat
=
bf
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_NumberFormat_format_get
"
get
format
"
)
;
function
Intl_NumberFormat_formatToParts
(
value
)
{
var
nf
=
this
;
if
(
!
IsObject
(
nf
)
|
|
!
IsNumberFormat
(
nf
)
)
{
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
NumberFormat
"
"
formatToParts
"
"
NumberFormat
"
)
;
}
getNumberFormatInternals
(
nf
)
;
var
x
=
ToNumber
(
value
)
;
return
intl_FormatNumber
(
nf
x
true
)
;
}
function
Intl_NumberFormat_resolvedOptions
(
)
{
var
nf
=
UnwrapNumberFormat
(
this
"
resolvedOptions
"
)
;
var
internals
=
getNumberFormatInternals
(
nf
)
;
var
result
=
{
locale
:
internals
.
locale
numberingSystem
:
internals
.
numberingSystem
style
:
internals
.
style
minimumIntegerDigits
:
internals
.
minimumIntegerDigits
minimumFractionDigits
:
internals
.
minimumFractionDigits
maximumFractionDigits
:
internals
.
maximumFractionDigits
useGrouping
:
internals
.
useGrouping
}
;
var
optionalProperties
=
[
"
currency
"
"
currencyDisplay
"
"
minimumSignificantDigits
"
"
maximumSignificantDigits
"
]
;
for
(
var
i
=
0
;
i
<
optionalProperties
.
length
;
i
+
+
)
{
var
p
=
optionalProperties
[
i
]
;
if
(
hasOwn
(
p
internals
)
)
_DefineDataProperty
(
result
p
internals
[
p
]
)
;
}
return
result
;
}
