var
collatorKeyMappings
=
{
kn
:
{
property
:
"
numeric
"
type
:
"
boolean
"
}
kf
:
{
property
:
"
caseFirst
"
type
:
"
string
"
values
:
[
"
upper
"
"
lower
"
"
false
"
]
}
}
;
function
resolveCollatorInternals
(
lazyCollatorData
)
{
assert
(
IsObject
(
lazyCollatorData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
internalProps
.
usage
=
lazyCollatorData
.
usage
;
var
Collator
=
collatorInternalProperties
;
var
collatorIsSorting
=
lazyCollatorData
.
usage
=
=
=
"
sort
"
;
var
localeData
=
collatorIsSorting
?
Collator
.
sortLocaleData
:
Collator
.
searchLocaleData
;
var
relevantExtensionKeys
=
Collator
.
relevantExtensionKeys
;
var
r
=
ResolveLocale
(
callFunction
(
Collator
.
availableLocales
Collator
)
lazyCollatorData
.
requestedLocales
lazyCollatorData
.
opt
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
var
key
property
value
mapping
;
var
i
=
0
len
=
relevantExtensionKeys
.
length
;
while
(
i
<
len
)
{
key
=
relevantExtensionKeys
[
i
]
;
if
(
key
=
=
=
"
co
"
)
{
property
=
"
collation
"
;
value
=
r
.
co
=
=
=
null
?
"
default
"
:
r
.
co
;
}
else
{
mapping
=
collatorKeyMappings
[
key
]
;
property
=
mapping
.
property
;
value
=
r
[
key
]
;
if
(
mapping
.
type
=
=
=
"
boolean
"
)
value
=
value
=
=
=
"
true
"
;
}
internalProps
[
property
]
=
value
;
i
+
+
;
}
var
s
=
lazyCollatorData
.
rawSensitivity
;
if
(
s
=
=
=
undefined
)
{
s
=
"
variant
"
;
}
internalProps
.
sensitivity
=
s
;
internalProps
.
ignorePunctuation
=
lazyCollatorData
.
ignorePunctuation
;
internalProps
.
boundFormat
=
undefined
;
return
internalProps
;
}
function
getCollatorInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getCollatorInternals
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
obj
)
"
getCollatorInternals
called
with
non
-
Collator
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
Collator
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveCollatorInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
InitializeCollator
(
collator
locales
options
)
{
assert
(
IsObject
(
collator
)
"
InitializeCollator
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
collator
)
"
InitializeCollator
called
with
non
-
Collator
"
)
;
var
lazyCollatorData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyCollatorData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
u
=
GetOption
(
options
"
usage
"
"
string
"
[
"
sort
"
"
search
"
]
"
sort
"
)
;
lazyCollatorData
.
usage
=
u
;
var
opt
=
new
Record
(
)
;
lazyCollatorData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
numericValue
=
GetOption
(
options
"
numeric
"
"
boolean
"
undefined
undefined
)
;
if
(
numericValue
!
=
=
undefined
)
numericValue
=
numericValue
?
"
true
"
:
"
false
"
;
opt
.
kn
=
numericValue
;
var
caseFirstValue
=
GetOption
(
options
"
caseFirst
"
"
string
"
[
"
upper
"
"
lower
"
"
false
"
]
undefined
)
;
opt
.
kf
=
caseFirstValue
;
var
s
=
GetOption
(
options
"
sensitivity
"
"
string
"
[
"
base
"
"
accent
"
"
case
"
"
variant
"
]
undefined
)
;
lazyCollatorData
.
rawSensitivity
=
s
;
var
ip
=
GetOption
(
options
"
ignorePunctuation
"
"
boolean
"
undefined
false
)
;
lazyCollatorData
.
ignorePunctuation
=
ip
;
initializeIntlObject
(
collator
"
Collator
"
lazyCollatorData
)
;
}
function
Intl_Collator_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
var
collatorInternalProperties
=
{
sortLocaleData
:
collatorSortLocaleData
searchLocaleData
:
collatorSearchLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_Collator_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
co
"
"
kn
"
"
kf
"
]
}
;
function
collatorActualLocale
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
locale
should
be
string
"
)
;
var
availableLocales
=
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
;
return
BestAvailableLocaleIgnoringDefault
(
availableLocales
locale
)
;
}
function
collatorSortCaseFirst
(
locale
)
{
var
actualLocale
=
collatorActualLocale
(
locale
)
;
if
(
intl_isUpperCaseFirst
(
actualLocale
)
)
return
[
"
upper
"
"
false
"
"
lower
"
]
;
return
[
"
false
"
"
lower
"
"
upper
"
]
;
}
function
collatorSortCaseFirstDefault
(
locale
)
{
var
actualLocale
=
collatorActualLocale
(
locale
)
;
if
(
intl_isUpperCaseFirst
(
actualLocale
)
)
return
"
upper
"
;
return
"
false
"
;
}
function
collatorSortLocaleData
(
)
{
return
{
co
:
intl_availableCollations
kn
:
function
(
)
{
return
[
"
false
"
"
true
"
]
;
}
kf
:
collatorSortCaseFirst
default
:
{
co
:
function
(
)
{
return
null
;
}
kn
:
function
(
)
{
return
"
false
"
;
}
kf
:
collatorSortCaseFirstDefault
}
}
;
}
function
collatorSearchLocaleData
(
)
{
return
{
co
:
function
(
)
{
return
[
null
]
;
}
kn
:
function
(
)
{
return
[
"
false
"
"
true
"
]
;
}
kf
:
function
(
)
{
return
[
"
false
"
"
lower
"
"
upper
"
]
;
}
default
:
{
co
:
function
(
)
{
return
null
;
}
kn
:
function
(
)
{
return
"
false
"
;
}
kf
:
function
(
)
{
return
"
false
"
;
}
}
}
;
}
function
collatorCompareToBind
(
x
y
)
{
var
collator
=
this
;
assert
(
IsObject
(
collator
)
"
collatorCompareToBind
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
collator
)
"
collatorCompareToBind
called
with
non
-
Collator
"
)
;
var
X
=
ToString
(
x
)
;
var
Y
=
ToString
(
y
)
;
return
intl_CompareStrings
(
collator
X
Y
)
;
}
function
Intl_Collator_compare_get
(
)
{
var
collator
=
this
;
if
(
!
IsObject
(
collator
)
|
|
!
IsCollator
(
collator
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
Collator
"
"
compare
"
"
Collator
"
)
;
var
internals
=
getCollatorInternals
(
collator
)
;
if
(
internals
.
boundCompare
=
=
=
undefined
)
{
var
F
=
collatorCompareToBind
;
var
bc
=
callFunction
(
FunctionBind
F
collator
)
;
internals
.
boundCompare
=
bc
;
}
return
internals
.
boundCompare
;
}
_SetCanonicalName
(
Intl_Collator_compare_get
"
get
compare
"
)
;
function
Intl_Collator_resolvedOptions
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsCollator
(
this
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
Collator
"
"
resolvedOptions
"
"
Collator
"
)
;
var
internals
=
getCollatorInternals
(
this
)
;
var
result
=
{
locale
:
internals
.
locale
usage
:
internals
.
usage
sensitivity
:
internals
.
sensitivity
ignorePunctuation
:
internals
.
ignorePunctuation
}
;
var
relevantExtensionKeys
=
collatorInternalProperties
.
relevantExtensionKeys
;
for
(
var
i
=
0
;
i
<
relevantExtensionKeys
.
length
;
i
+
+
)
{
var
key
=
relevantExtensionKeys
[
i
]
;
var
property
=
(
key
=
=
=
"
co
"
)
?
"
collation
"
:
collatorKeyMappings
[
key
]
.
property
;
_DefineDataProperty
(
result
property
internals
[
property
]
)
;
}
return
result
;
}
