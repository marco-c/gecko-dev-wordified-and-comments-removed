#
ifndef
builtin_intl_DateTimeFormat_h
#
define
builtin_intl_DateTimeFormat_h
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
builtin
/
temporal
/
Calendar
.
h
"
#
include
"
builtin
/
temporal
/
TimeZone
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
mozilla
:
:
intl
{
class
DateTimeFormat
;
class
DateIntervalFormat
;
}
namespace
js
{
enum
class
DateTimeValueKind
{
Number
TemporalDate
TemporalTime
TemporalDateTime
TemporalYearMonth
TemporalMonthDay
TemporalZonedDateTime
TemporalInstant
}
;
class
DateTimeFormatObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
constexpr
uint32_t
INTERNALS_SLOT
=
0
;
static
constexpr
uint32_t
DATE_FORMAT_SLOT
=
1
;
static
constexpr
uint32_t
DATE_INTERVAL_FORMAT_SLOT
=
2
;
static
constexpr
uint32_t
DATE_TIME_VALUE_KIND_SLOT
=
3
;
static
constexpr
uint32_t
CALENDAR_SLOT
=
4
;
static
constexpr
uint32_t
TIMEZONE_SLOT
=
5
;
static
constexpr
uint32_t
SLOT_COUNT
=
6
;
static_assert
(
INTERNALS_SLOT
=
=
INTL_INTERNALS_OBJECT_SLOT
"
INTERNALS_SLOT
must
match
self
-
hosting
define
for
internals
"
"
object
slot
"
)
;
static
constexpr
size_t
UDateFormatEstimatedMemoryUse
=
72440
;
static
constexpr
size_t
UDateIntervalFormatEstimatedMemoryUse
=
175646
;
mozilla
:
:
intl
:
:
DateTimeFormat
*
getDateFormat
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
DATE_FORMAT_SLOT
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
mozilla
:
:
intl
:
:
DateTimeFormat
*
>
(
slot
.
toPrivate
(
)
)
;
}
void
setDateFormat
(
mozilla
:
:
intl
:
:
DateTimeFormat
*
dateFormat
)
{
setFixedSlot
(
DATE_FORMAT_SLOT
PrivateValue
(
dateFormat
)
)
;
}
mozilla
:
:
intl
:
:
DateIntervalFormat
*
getDateIntervalFormat
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
DATE_INTERVAL_FORMAT_SLOT
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
mozilla
:
:
intl
:
:
DateIntervalFormat
*
>
(
slot
.
toPrivate
(
)
)
;
}
void
setDateIntervalFormat
(
mozilla
:
:
intl
:
:
DateIntervalFormat
*
dateIntervalFormat
)
{
setFixedSlot
(
DATE_INTERVAL_FORMAT_SLOT
PrivateValue
(
dateIntervalFormat
)
)
;
}
DateTimeValueKind
getDateTimeValueKind
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
DATE_TIME_VALUE_KIND_SLOT
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
DateTimeValueKind
:
:
Number
;
}
return
static_cast
<
DateTimeValueKind
>
(
slot
.
toInt32
(
)
)
;
}
void
setDateTimeValueKind
(
DateTimeValueKind
kind
)
{
setFixedSlot
(
DATE_TIME_VALUE_KIND_SLOT
Int32Value
(
static_cast
<
int32_t
>
(
kind
)
)
)
;
}
temporal
:
:
CalendarValue
getCalendar
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
CALENDAR_SLOT
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
temporal
:
:
CalendarValue
(
)
;
}
return
temporal
:
:
CalendarValue
(
slot
)
;
}
void
setCalendar
(
const
temporal
:
:
CalendarValue
&
calendar
)
{
setFixedSlot
(
CALENDAR_SLOT
calendar
.
toSlotValue
(
)
)
;
}
temporal
:
:
TimeZoneValue
getTimeZone
(
)
const
{
const
auto
&
slot
=
getFixedSlot
(
TIMEZONE_SLOT
)
;
if
(
slot
.
isUndefined
(
)
)
{
return
temporal
:
:
TimeZoneValue
(
)
;
}
return
temporal
:
:
TimeZoneValue
(
slot
)
;
}
void
setTimeZone
(
const
temporal
:
:
TimeZoneValue
&
timeZone
)
{
setFixedSlot
(
TIMEZONE_SLOT
timeZone
.
toSlotValue
(
)
)
;
}
void
maybeClearCache
(
DateTimeValueKind
kind
)
;
private
:
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
}
;
[
[
nodiscard
]
]
extern
bool
intl_availableCalendars
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_defaultCalendar
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_IsValidTimeZoneName
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_canonicalizeTimeZone
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_defaultTimeZone
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_defaultTimeZoneOffset
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_isDefaultTimeZone
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_FormatDateTime
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_FormatDateTimeRange
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
intl_resolveDateTimeFormatComponents
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
[
[
nodiscard
]
]
extern
bool
TemporalObjectToLocaleString
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
JS
:
:
Handle
<
JSString
*
>
required
JS
:
:
Handle
<
JSString
*
>
defaults
JS
:
:
Handle
<
JS
:
:
Value
>
toLocaleStringTimeZone
=
JS
:
:
UndefinedHandleValue
)
;
namespace
intl
{
enum
class
DateTimeFormatKind
{
All
Date
Time
}
;
[
[
nodiscard
]
]
extern
DateTimeFormatObject
*
CreateDateTimeFormat
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
locales
JS
:
:
Handle
<
JS
:
:
Value
>
options
DateTimeFormatKind
kind
)
;
[
[
nodiscard
]
]
extern
DateTimeFormatObject
*
GetOrCreateDateTimeFormat
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
locales
JS
:
:
Handle
<
JS
:
:
Value
>
options
DateTimeFormatKind
kind
)
;
[
[
nodiscard
]
]
extern
bool
FormatDateTime
(
JSContext
*
cx
JS
:
:
Handle
<
DateTimeFormatObject
*
>
dateTimeFormat
double
millis
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
}
}
#
endif
