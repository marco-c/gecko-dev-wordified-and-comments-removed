#
include
"
builtin
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
builtin
/
Boolean
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
builtin
/
intl
/
FormatBuffer
.
h
"
#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
#
include
"
builtin
/
intl
/
StringAsciiChars
.
h
"
#
include
"
builtin
/
String
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
mozilla
:
:
intl
:
:
LanguageTagLimits
;
const
JSClass
LocaleObject
:
:
class_
=
{
"
Intl
.
Locale
"
JSCLASS_HAS_RESERVED_SLOTS
(
LocaleObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Locale
)
JS_NULL_CLASS_OPS
&
LocaleObject
:
:
classSpec_
}
;
const
JSClass
&
LocaleObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
inline
bool
IsLocale
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
LocaleObject
>
(
)
;
}
static
size_t
BaseNameLength
(
const
mozilla
:
:
intl
:
:
Locale
&
tag
)
{
size_t
baseNameLength
=
tag
.
Language
(
)
.
Length
(
)
;
if
(
tag
.
Script
(
)
.
Present
(
)
)
{
baseNameLength
+
=
1
+
tag
.
Script
(
)
.
Length
(
)
;
}
if
(
tag
.
Region
(
)
.
Present
(
)
)
{
baseNameLength
+
=
1
+
tag
.
Region
(
)
.
Length
(
)
;
}
for
(
const
auto
&
variant
:
tag
.
Variants
(
)
)
{
baseNameLength
+
=
1
+
variant
.
size
(
)
;
}
return
baseNameLength
;
}
struct
IndexAndLength
{
size_t
index
;
size_t
length
;
IndexAndLength
(
size_t
index
size_t
length
)
:
index
(
index
)
length
(
length
)
{
}
;
template
<
typename
T
>
mozilla
:
:
Span
<
const
T
>
spanOf
(
const
T
*
ptr
)
const
{
return
{
ptr
+
index
length
}
;
}
}
;
static
mozilla
:
:
Maybe
<
IndexAndLength
>
UnicodeExtensionPosition
(
const
mozilla
:
:
intl
:
:
Locale
&
tag
)
{
size_t
index
=
0
;
for
(
const
auto
&
extension
:
tag
.
Extensions
(
)
)
{
MOZ_ASSERT
(
!
mozilla
:
:
IsAsciiUppercaseAlpha
(
extension
[
0
]
)
"
extensions
are
case
normalized
to
lowercase
"
)
;
size_t
extensionLength
=
extension
.
size
(
)
;
if
(
extension
[
0
]
=
=
'
u
'
)
{
return
mozilla
:
:
Some
(
IndexAndLength
{
index
extensionLength
}
)
;
}
index
+
=
1
+
extensionLength
;
}
return
mozilla
:
:
Nothing
(
)
;
}
static
LocaleObject
*
CreateLocaleObject
(
JSContext
*
cx
HandleObject
prototype
const
mozilla
:
:
intl
:
:
Locale
&
tag
)
{
intl
:
:
FormatBuffer
<
char
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
RootedString
tagStr
(
cx
buffer
.
toAsciiString
(
cx
)
)
;
if
(
!
tagStr
)
{
return
nullptr
;
}
size_t
baseNameLength
=
BaseNameLength
(
tag
)
;
RootedString
baseName
(
cx
NewDependentString
(
cx
tagStr
0
baseNameLength
)
)
;
if
(
!
baseName
)
{
return
nullptr
;
}
RootedValue
unicodeExtension
(
cx
UndefinedValue
(
)
)
;
if
(
auto
result
=
UnicodeExtensionPosition
(
tag
)
)
{
JSString
*
str
=
NewDependentString
(
cx
tagStr
baseNameLength
+
1
+
result
-
>
index
result
-
>
length
)
;
if
(
!
str
)
{
return
nullptr
;
}
unicodeExtension
.
setString
(
str
)
;
}
auto
*
locale
=
NewObjectWithClassProto
<
LocaleObject
>
(
cx
prototype
)
;
if
(
!
locale
)
{
return
nullptr
;
}
locale
-
>
setFixedSlot
(
LocaleObject
:
:
LANGUAGE_TAG_SLOT
StringValue
(
tagStr
)
)
;
locale
-
>
setFixedSlot
(
LocaleObject
:
:
BASENAME_SLOT
StringValue
(
baseName
)
)
;
locale
-
>
setFixedSlot
(
LocaleObject
:
:
UNICODE_EXTENSION_SLOT
unicodeExtension
)
;
return
locale
;
}
static
inline
bool
IsValidUnicodeExtensionValue
(
JSContext
*
cx
JSLinearString
*
linear
bool
*
isValid
)
{
if
(
linear
-
>
length
(
)
=
=
0
)
{
*
isValid
=
false
;
return
true
;
}
if
(
!
StringIsAscii
(
linear
)
)
{
*
isValid
=
false
;
return
true
;
}
intl
:
:
StringAsciiChars
chars
(
linear
)
;
if
(
!
chars
.
init
(
cx
)
)
{
return
false
;
}
*
isValid
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
CanParseUnicodeExtensionType
(
chars
)
.
isOk
(
)
;
return
true
;
}
template
<
typename
CharT
>
class
SepKeywordIterator
{
const
CharT
*
iter_
;
const
CharT
*
const
end_
;
public
:
SepKeywordIterator
(
const
CharT
*
unicodeExtensionBegin
const
CharT
*
unicodeExtensionEnd
)
:
iter_
(
unicodeExtensionBegin
)
end_
(
unicodeExtensionEnd
)
{
}
const
CharT
*
next
(
)
{
MOZ_ASSERT
(
iter_
!
=
nullptr
"
can
'
t
call
next
(
)
once
it
'
s
returned
nullptr
"
)
;
constexpr
size_t
SepKeyLength
=
1
+
UnicodeKeyLength
;
MOZ_ASSERT
(
iter_
+
SepKeyLength
<
=
end_
"
overall
Unicode
locale
extension
or
non
-
leading
subtags
must
"
"
be
at
least
key
-
sized
"
)
;
MOZ_ASSERT
(
(
iter_
[
0
]
=
=
'
u
'
&
&
iter_
[
1
]
=
=
'
-
'
)
|
|
iter_
[
0
]
=
=
'
-
'
)
;
while
(
true
)
{
iter_
+
+
;
iter_
=
std
:
:
char_traits
<
CharT
>
:
:
find
(
iter_
mozilla
:
:
PointerRangeSize
(
iter_
end_
)
CharT
(
'
-
'
)
)
;
if
(
!
iter_
)
{
return
nullptr
;
}
MOZ_ASSERT
(
iter_
+
SepKeyLength
<
=
end_
"
non
-
leading
subtags
in
a
Unicode
locale
extension
are
all
"
"
at
least
as
long
as
a
key
"
)
;
if
(
iter_
+
SepKeyLength
=
=
end_
|
|
iter_
[
SepKeyLength
]
=
=
'
-
'
)
{
break
;
}
}
MOZ_ASSERT
(
iter_
[
0
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAsciiLowercaseAlpha
(
iter_
[
1
]
)
|
|
mozilla
:
:
IsAsciiDigit
(
iter_
[
1
]
)
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAsciiLowercaseAlpha
(
iter_
[
2
]
)
)
;
MOZ_ASSERT_IF
(
iter_
+
SepKeyLength
<
end_
iter_
[
SepKeyLength
]
=
=
'
-
'
)
;
return
iter_
;
}
}
;
static
bool
GetStringOption
(
JSContext
*
cx
HandleObject
options
Handle
<
PropertyName
*
>
name
MutableHandle
<
JSLinearString
*
>
string
)
{
RootedValue
option
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
name
&
option
)
)
{
return
false
;
}
JSLinearString
*
linear
=
nullptr
;
if
(
!
option
.
isUndefined
(
)
)
{
JSString
*
str
=
ToString
(
cx
option
)
;
if
(
!
str
)
{
return
false
;
}
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
}
string
.
set
(
linear
)
;
return
true
;
}
static
bool
GetBooleanOption
(
JSContext
*
cx
HandleObject
options
Handle
<
PropertyName
*
>
name
MutableHandle
<
JSLinearString
*
>
string
)
{
RootedValue
option
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
name
&
option
)
)
{
return
false
;
}
JSLinearString
*
linear
=
nullptr
;
if
(
!
option
.
isUndefined
(
)
)
{
linear
=
BooleanToString
(
cx
ToBoolean
(
option
)
)
;
}
string
.
set
(
linear
)
;
return
true
;
}
static
bool
ApplyOptionsToTag
(
JSContext
*
cx
mozilla
:
:
intl
:
:
Locale
&
tag
HandleObject
options
)
{
Rooted
<
JSLinearString
*
>
option
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
language
&
option
)
)
{
return
false
;
}
mozilla
:
:
intl
:
:
LanguageSubtag
language
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneLanguageTag
(
option
language
)
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
option
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
language
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
script
&
option
)
)
{
return
false
;
}
mozilla
:
:
intl
:
:
ScriptSubtag
script
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneScriptTag
(
option
script
)
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
option
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
script
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
region
&
option
)
)
{
return
false
;
}
mozilla
:
:
intl
:
:
RegionSubtag
region
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneRegionTag
(
option
region
)
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
option
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
region
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
language
.
Present
(
)
|
|
script
.
Present
(
)
|
|
region
.
Present
(
)
)
{
if
(
language
.
Present
(
)
)
{
tag
.
SetLanguage
(
language
)
;
}
if
(
script
.
Present
(
)
)
{
tag
.
SetScript
(
script
)
;
}
if
(
region
.
Present
(
)
)
{
tag
.
SetRegion
(
region
)
;
}
auto
result
=
tag
.
CanonicalizeBaseName
(
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DUPLICATE_VARIANT_SUBTAG
)
;
}
else
{
intl
:
:
ReportInternalError
(
cx
)
;
}
return
false
;
}
}
return
true
;
}
bool
js
:
:
intl
:
:
ApplyUnicodeExtensionToTag
(
JSContext
*
cx
mozilla
:
:
intl
:
:
Locale
&
tag
JS
:
:
HandleVector
<
intl
:
:
UnicodeExtensionKeyword
>
keywords
)
{
if
(
keywords
.
length
(
)
=
=
0
)
{
return
true
;
}
Vector
<
char
32
>
newExtension
(
cx
)
;
if
(
!
newExtension
.
append
(
'
u
'
)
)
{
return
false
;
}
const
char
*
unicodeExtensionEnd
=
nullptr
;
const
char
*
unicodeExtensionKeywords
=
nullptr
;
if
(
auto
unicodeExtension
=
tag
.
GetUnicodeExtension
(
)
)
{
const
char
*
unicodeExtensionBegin
=
unicodeExtension
-
>
data
(
)
;
unicodeExtensionEnd
=
unicodeExtensionBegin
+
unicodeExtension
-
>
size
(
)
;
SepKeywordIterator
<
char
>
iter
(
unicodeExtensionBegin
unicodeExtensionEnd
)
;
unicodeExtensionKeywords
=
iter
.
next
(
)
;
const
char
*
attributesEnd
=
unicodeExtensionKeywords
?
unicodeExtensionKeywords
:
unicodeExtensionEnd
;
if
(
!
newExtension
.
append
(
unicodeExtensionBegin
+
1
attributesEnd
)
)
{
return
false
;
}
}
for
(
const
auto
&
keyword
:
keywords
)
{
UnicodeExtensionKeyword
:
:
UnicodeKeySpan
key
=
keyword
.
key
(
)
;
if
(
!
newExtension
.
append
(
'
-
'
)
)
{
return
false
;
}
if
(
!
newExtension
.
append
(
key
.
data
(
)
key
.
size
(
)
)
)
{
return
false
;
}
if
(
!
newExtension
.
append
(
'
-
'
)
)
{
return
false
;
}
JS
:
:
AutoCheckCannotGC
nogc
;
JSLinearString
*
type
=
keyword
.
type
(
)
;
if
(
type
-
>
hasLatin1Chars
(
)
)
{
if
(
!
newExtension
.
append
(
type
-
>
latin1Chars
(
nogc
)
type
-
>
length
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
newExtension
.
append
(
type
-
>
twoByteChars
(
nogc
)
type
-
>
length
(
)
)
)
{
return
false
;
}
}
}
if
(
unicodeExtensionKeywords
)
{
if
(
!
newExtension
.
append
(
unicodeExtensionKeywords
unicodeExtensionEnd
)
)
{
return
false
;
}
}
if
(
auto
res
=
tag
.
SetUnicodeExtension
(
newExtension
)
;
res
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
res
.
unwrapErr
(
)
)
;
return
false
;
}
return
true
;
}
static
JS
:
:
Result
<
JSString
*
>
LanguageTagFromMaybeWrappedLocale
(
JSContext
*
cx
JSObject
*
obj
)
{
if
(
obj
-
>
is
<
LocaleObject
>
(
)
)
{
return
obj
-
>
as
<
LocaleObject
>
(
)
.
languageTag
(
)
;
}
JSObject
*
unwrapped
=
CheckedUnwrapStatic
(
obj
)
;
if
(
!
unwrapped
)
{
ReportAccessDenied
(
cx
)
;
return
cx
-
>
alreadyReportedError
(
)
;
}
if
(
!
unwrapped
-
>
is
<
LocaleObject
>
(
)
)
{
return
nullptr
;
}
RootedString
tagStr
(
cx
unwrapped
-
>
as
<
LocaleObject
>
(
)
.
languageTag
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
tagStr
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
tagStr
.
get
(
)
;
}
static
bool
Locale
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Intl
.
Locale
"
)
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Locale
&
proto
)
)
{
return
false
;
}
HandleValue
tagValue
=
args
.
get
(
0
)
;
JSString
*
tagStr
;
if
(
tagValue
.
isObject
(
)
)
{
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tagStr
LanguageTagFromMaybeWrappedLocale
(
cx
&
tagValue
.
toObject
(
)
)
)
;
if
(
!
tagStr
)
{
tagStr
=
ToString
(
cx
tagValue
)
;
if
(
!
tagStr
)
{
return
false
;
}
}
}
else
if
(
tagValue
.
isString
(
)
)
{
tagStr
=
tagValue
.
toString
(
)
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_LOCALES_ELEMENT
)
;
return
false
;
}
Rooted
<
JSLinearString
*
>
tagLinearStr
(
cx
tagStr
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagLinearStr
)
{
return
false
;
}
RootedObject
options
(
cx
)
;
if
(
args
.
hasDefined
(
1
)
)
{
options
=
ToObject
(
cx
args
[
1
]
)
;
if
(
!
options
)
{
return
false
;
}
}
mozilla
:
:
intl
:
:
Locale
tag
;
if
(
!
intl
:
:
ParseLocale
(
cx
tagLinearStr
tag
)
)
{
return
false
;
}
if
(
auto
result
=
tag
.
CanonicalizeBaseName
(
)
;
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DUPLICATE_VARIANT_SUBTAG
)
;
}
else
{
intl
:
:
ReportInternalError
(
cx
)
;
}
return
false
;
}
if
(
options
)
{
if
(
!
ApplyOptionsToTag
(
cx
tag
options
)
)
{
return
false
;
}
JS
:
:
RootedVector
<
intl
:
:
UnicodeExtensionKeyword
>
keywords
(
cx
)
;
Rooted
<
JSLinearString
*
>
calendar
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
calendar
&
calendar
)
)
{
return
false
;
}
if
(
calendar
)
{
bool
isValid
;
if
(
!
IsValidUnicodeExtensionValue
(
cx
calendar
&
isValid
)
)
{
return
false
;
}
if
(
!
isValid
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
calendar
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
calendar
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
keywords
.
emplaceBack
(
"
ca
"
calendar
)
)
{
return
false
;
}
}
Rooted
<
JSLinearString
*
>
collation
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
collation
&
collation
)
)
{
return
false
;
}
if
(
collation
)
{
bool
isValid
;
if
(
!
IsValidUnicodeExtensionValue
(
cx
collation
&
isValid
)
)
{
return
false
;
}
if
(
!
isValid
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
collation
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
collation
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
keywords
.
emplaceBack
(
"
co
"
collation
)
)
{
return
false
;
}
}
Rooted
<
JSLinearString
*
>
hourCycle
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
hourCycle
&
hourCycle
)
)
{
return
false
;
}
if
(
hourCycle
)
{
if
(
!
StringEqualsLiteral
(
hourCycle
"
h11
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h12
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h23
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h24
"
)
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
hourCycle
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
hourCycle
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
keywords
.
emplaceBack
(
"
hc
"
hourCycle
)
)
{
return
false
;
}
}
Rooted
<
JSLinearString
*
>
caseFirst
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
caseFirst
&
caseFirst
)
)
{
return
false
;
}
if
(
caseFirst
)
{
if
(
!
StringEqualsLiteral
(
caseFirst
"
upper
"
)
&
&
!
StringEqualsLiteral
(
caseFirst
"
lower
"
)
&
&
!
StringEqualsLiteral
(
caseFirst
"
false
"
)
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
caseFirst
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
caseFirst
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
keywords
.
emplaceBack
(
"
kf
"
caseFirst
)
)
{
return
false
;
}
}
Rooted
<
JSLinearString
*
>
numeric
(
cx
)
;
if
(
!
GetBooleanOption
(
cx
options
cx
-
>
names
(
)
.
numeric
&
numeric
)
)
{
return
false
;
}
if
(
numeric
)
{
if
(
!
keywords
.
emplaceBack
(
"
kn
"
numeric
)
)
{
return
false
;
}
}
Rooted
<
JSLinearString
*
>
numberingSystem
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
numberingSystem
&
numberingSystem
)
)
{
return
false
;
}
if
(
numberingSystem
)
{
bool
isValid
;
if
(
!
IsValidUnicodeExtensionValue
(
cx
numberingSystem
&
isValid
)
)
{
return
false
;
}
if
(
!
isValid
)
{
if
(
UniqueChars
str
=
QuoteString
(
cx
numberingSystem
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
numberingSystem
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
keywords
.
emplaceBack
(
"
nu
"
numberingSystem
)
)
{
return
false
;
}
}
if
(
!
ApplyUnicodeExtensionToTag
(
cx
tag
keywords
)
)
{
return
false
;
}
}
if
(
auto
result
=
tag
.
CanonicalizeExtensions
(
)
;
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DUPLICATE_VARIANT_SUBTAG
)
;
}
else
{
intl
:
:
ReportInternalError
(
cx
)
;
}
return
false
;
}
JSObject
*
obj
=
CreateLocaleObject
(
cx
proto
tag
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
using
UnicodeKey
=
const
char
(
&
)
[
UnicodeKeyLength
+
1
]
;
template
<
typename
CharT
>
static
mozilla
:
:
Maybe
<
IndexAndLength
>
FindUnicodeExtensionType
(
const
CharT
*
extension
size_t
length
UnicodeKey
key
)
{
MOZ_ASSERT
(
extension
[
0
]
=
=
'
u
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
const
CharT
*
end
=
extension
+
length
;
SepKeywordIterator
<
CharT
>
iter
(
extension
end
)
;
const
CharT
*
beginKey
;
while
(
true
)
{
beginKey
=
iter
.
next
(
)
;
if
(
!
beginKey
)
{
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ASSERT
(
beginKey
[
0
]
=
=
'
-
'
)
;
beginKey
+
+
;
if
(
std
:
:
equal
(
beginKey
beginKey
+
UnicodeKeyLength
key
)
)
{
break
;
}
}
const
CharT
*
beginType
=
beginKey
+
UnicodeKeyLength
;
const
CharT
*
endType
=
iter
.
next
(
)
;
if
(
!
endType
)
{
endType
=
end
;
}
if
(
beginType
!
=
endType
)
{
MOZ_ASSERT
(
beginType
[
0
]
=
=
'
-
'
)
;
beginType
+
+
;
}
return
mozilla
:
:
Some
(
IndexAndLength
{
size_t
(
beginType
-
extension
)
size_t
(
endType
-
beginType
)
}
)
;
}
static
inline
auto
FindUnicodeExtensionType
(
JSLinearString
*
unicodeExtension
UnicodeKey
key
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
unicodeExtension
-
>
hasLatin1Chars
(
)
?
FindUnicodeExtensionType
(
unicodeExtension
-
>
latin1Chars
(
nogc
)
unicodeExtension
-
>
length
(
)
key
)
:
FindUnicodeExtensionType
(
unicodeExtension
-
>
twoByteChars
(
nogc
)
unicodeExtension
-
>
length
(
)
key
)
;
}
static
bool
GetUnicodeExtension
(
JSContext
*
cx
LocaleObject
*
locale
UnicodeKey
key
MutableHandleValue
value
)
{
const
Value
&
unicodeExtensionValue
=
locale
-
>
unicodeExtension
(
)
;
if
(
unicodeExtensionValue
.
isUndefined
(
)
)
{
value
.
setUndefined
(
)
;
return
true
;
}
JSLinearString
*
unicodeExtension
=
unicodeExtensionValue
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
unicodeExtension
)
{
return
false
;
}
auto
result
=
FindUnicodeExtensionType
(
unicodeExtension
key
)
;
if
(
!
result
)
{
value
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
result
-
>
index
;
size_t
length
=
result
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
unicodeExtension
index
length
)
;
if
(
!
str
)
{
return
false
;
}
value
.
setString
(
str
)
;
return
true
;
}
struct
BaseNamePartsResult
{
IndexAndLength
language
;
mozilla
:
:
Maybe
<
IndexAndLength
>
script
;
mozilla
:
:
Maybe
<
IndexAndLength
>
region
;
}
;
template
<
typename
CharT
>
static
BaseNamePartsResult
BaseNameParts
(
const
CharT
*
baseName
size_t
length
)
{
size_t
languageLength
;
size_t
scriptIndex
=
0
;
size_t
regionIndex
=
0
;
size_t
regionLength
=
0
;
if
(
const
CharT
*
sep
=
std
:
:
char_traits
<
CharT
>
:
:
find
(
baseName
length
'
-
'
)
)
{
languageLength
=
sep
-
baseName
;
size_t
nextSubtag
=
languageLength
+
1
;
if
(
(
nextSubtag
+
ScriptLength
=
=
length
|
|
(
nextSubtag
+
ScriptLength
<
length
&
&
baseName
[
nextSubtag
+
ScriptLength
]
=
=
'
-
'
)
)
&
&
mozilla
:
:
IsAsciiAlpha
(
baseName
[
nextSubtag
]
)
)
{
scriptIndex
=
nextSubtag
;
nextSubtag
=
scriptIndex
+
ScriptLength
+
1
;
}
if
(
nextSubtag
<
length
)
{
for
(
size_t
rlen
:
{
AlphaRegionLength
DigitRegionLength
}
)
{
MOZ_ASSERT
(
nextSubtag
+
rlen
<
=
length
)
;
if
(
nextSubtag
+
rlen
=
=
length
|
|
baseName
[
nextSubtag
+
rlen
]
=
=
'
-
'
)
{
regionIndex
=
nextSubtag
;
regionLength
=
rlen
;
break
;
}
}
}
}
else
{
languageLength
=
length
;
}
JS
:
:
AutoSuppressGCAnalysis
nogc
;
IndexAndLength
language
{
0
languageLength
}
;
MOZ_ASSERT
(
mozilla
:
:
intl
:
:
IsStructurallyValidLanguageTag
(
language
.
spanOf
(
baseName
)
)
)
;
mozilla
:
:
Maybe
<
IndexAndLength
>
script
{
}
;
if
(
scriptIndex
)
{
script
.
emplace
(
scriptIndex
ScriptLength
)
;
MOZ_ASSERT
(
mozilla
:
:
intl
:
:
IsStructurallyValidScriptTag
(
script
-
>
spanOf
(
baseName
)
)
)
;
}
mozilla
:
:
Maybe
<
IndexAndLength
>
region
{
}
;
if
(
regionIndex
)
{
region
.
emplace
(
regionIndex
regionLength
)
;
MOZ_ASSERT
(
mozilla
:
:
intl
:
:
IsStructurallyValidRegionTag
(
region
-
>
spanOf
(
baseName
)
)
)
;
}
return
{
language
script
region
}
;
}
static
inline
auto
BaseNameParts
(
JSLinearString
*
baseName
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
baseName
-
>
hasLatin1Chars
(
)
?
BaseNameParts
(
baseName
-
>
latin1Chars
(
nogc
)
baseName
-
>
length
(
)
)
:
BaseNameParts
(
baseName
-
>
twoByteChars
(
nogc
)
baseName
-
>
length
(
)
)
;
}
static
bool
Locale_maximize
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
Rooted
<
JSLinearString
*
>
tagStr
(
cx
locale
-
>
languageTag
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagStr
)
{
return
false
;
}
mozilla
:
:
intl
:
:
Locale
tag
;
if
(
!
intl
:
:
ParseLocale
(
cx
tagStr
tag
)
)
{
return
false
;
}
if
(
auto
result
=
tag
.
AddLikelySubtags
(
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
false
;
}
auto
*
result
=
CreateLocaleObject
(
cx
nullptr
tag
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Locale_maximize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_maximize
>
(
cx
args
)
;
}
static
bool
Locale_minimize
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
Rooted
<
JSLinearString
*
>
tagStr
(
cx
locale
-
>
languageTag
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagStr
)
{
return
false
;
}
mozilla
:
:
intl
:
:
Locale
tag
;
if
(
!
intl
:
:
ParseLocale
(
cx
tagStr
tag
)
)
{
return
false
;
}
if
(
auto
result
=
tag
.
RemoveLikelySubtags
(
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
false
;
}
auto
*
result
=
CreateLocaleObject
(
cx
nullptr
tag
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Locale_minimize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_minimize
>
(
cx
args
)
;
}
static
bool
Locale_toString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
args
.
rval
(
)
.
setString
(
locale
-
>
languageTag
(
)
)
;
return
true
;
}
static
bool
Locale_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_toString
>
(
cx
args
)
;
}
static
bool
Locale_baseName
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
args
.
rval
(
)
.
setString
(
locale
-
>
baseName
(
)
)
;
return
true
;
}
static
bool
Locale_baseName
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_baseName
>
(
cx
args
)
;
}
static
bool
Locale_calendar
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
ca
"
args
.
rval
(
)
)
;
}
static
bool
Locale_calendar
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_calendar
>
(
cx
args
)
;
}
static
bool
Locale_caseFirst
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
kf
"
args
.
rval
(
)
)
;
}
static
bool
Locale_caseFirst
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_caseFirst
>
(
cx
args
)
;
}
static
bool
Locale_collation
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
co
"
args
.
rval
(
)
)
;
}
static
bool
Locale_collation
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_collation
>
(
cx
args
)
;
}
static
bool
Locale_hourCycle
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
hc
"
args
.
rval
(
)
)
;
}
static
bool
Locale_hourCycle
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_hourCycle
>
(
cx
args
)
;
}
static
bool
Locale_numeric
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetUnicodeExtension
(
cx
locale
"
kn
"
&
value
)
)
{
return
false
;
}
MOZ_ASSERT
(
value
.
isUndefined
(
)
|
|
value
.
isString
(
)
)
;
MOZ_ASSERT_IF
(
value
.
isString
(
)
!
StringEqualsLiteral
(
&
value
.
toString
(
)
-
>
asLinear
(
)
"
true
"
)
)
;
args
.
rval
(
)
.
setBoolean
(
value
.
isString
(
)
&
&
value
.
toString
(
)
-
>
empty
(
)
)
;
return
true
;
}
static
bool
Locale_numeric
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_numeric
>
(
cx
args
)
;
}
static
bool
Intl_Locale_numberingSystem
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
nu
"
args
.
rval
(
)
)
;
}
static
bool
Locale_numberingSystem
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Intl_Locale_numberingSystem
>
(
cx
args
)
;
}
static
bool
Locale_language
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
language
=
BaseNameParts
(
baseName
)
.
language
;
size_t
index
=
language
.
index
;
size_t
length
=
language
.
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_language
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_language
>
(
cx
args
)
;
}
static
bool
Locale_script
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
script
=
BaseNameParts
(
baseName
)
.
script
;
if
(
!
script
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
script
-
>
index
;
size_t
length
=
script
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_script
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_script
>
(
cx
args
)
;
}
static
bool
Locale_region
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
region
=
BaseNameParts
(
baseName
)
.
region
;
if
(
!
region
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
region
-
>
index
;
size_t
length
=
region
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_region
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_region
>
(
cx
args
)
;
}
static
bool
Locale_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Locale
)
;
return
true
;
}
static
const
JSFunctionSpec
locale_methods
[
]
=
{
JS_FN
(
"
maximize
"
Locale_maximize
0
0
)
JS_FN
(
"
minimize
"
Locale_minimize
0
0
)
JS_FN
(
js_toString_str
Locale_toString
0
0
)
JS_FN
(
js_toSource_str
Locale_toSource
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
locale_properties
[
]
=
{
JS_PSG
(
"
baseName
"
Locale_baseName
0
)
JS_PSG
(
"
calendar
"
Locale_calendar
0
)
JS_PSG
(
"
caseFirst
"
Locale_caseFirst
0
)
JS_PSG
(
"
collation
"
Locale_collation
0
)
JS_PSG
(
"
hourCycle
"
Locale_hourCycle
0
)
JS_PSG
(
"
numeric
"
Locale_numeric
0
)
JS_PSG
(
"
numberingSystem
"
Locale_numberingSystem
0
)
JS_PSG
(
"
language
"
Locale_language
0
)
JS_PSG
(
"
script
"
Locale_script
0
)
JS_PSG
(
"
region
"
Locale_region
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Intl
.
Locale
"
JSPROP_READONLY
)
JS_PS_END
}
;
const
ClassSpec
LocaleObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
Locale
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
LocaleObject
>
nullptr
nullptr
locale_methods
locale_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
bool
js
:
:
intl_ValidateAndCanonicalizeLanguageTag
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
2
)
;
HandleValue
tagValue
=
args
[
0
]
;
bool
applyToString
=
args
[
1
]
.
toBoolean
(
)
;
if
(
tagValue
.
isObject
(
)
)
{
JSString
*
tagStr
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tagStr
LanguageTagFromMaybeWrappedLocale
(
cx
&
tagValue
.
toObject
(
)
)
)
;
if
(
tagStr
)
{
args
.
rval
(
)
.
setString
(
tagStr
)
;
return
true
;
}
}
if
(
!
applyToString
&
&
!
tagValue
.
isString
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
JSString
*
tagStr
=
ToString
(
cx
tagValue
)
;
if
(
!
tagStr
)
{
return
false
;
}
Rooted
<
JSLinearString
*
>
tagLinearStr
(
cx
tagStr
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagLinearStr
)
{
return
false
;
}
JSString
*
language
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
language
intl
:
:
ParseStandaloneISO639LanguageTag
(
cx
tagLinearStr
)
)
;
if
(
language
)
{
args
.
rval
(
)
.
setString
(
language
)
;
return
true
;
}
mozilla
:
:
intl
:
:
Locale
tag
;
if
(
!
intl
:
:
ParseLocale
(
cx
tagLinearStr
tag
)
)
{
return
false
;
}
auto
result
=
tag
.
Canonicalize
(
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DUPLICATE_VARIANT_SUBTAG
)
;
}
else
{
intl
:
:
ReportInternalError
(
cx
)
;
}
return
false
;
}
intl
:
:
FormatBuffer
<
char
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
false
;
}
JSString
*
resultStr
=
buffer
.
toAsciiString
(
cx
)
;
if
(
!
resultStr
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
resultStr
)
;
return
true
;
}
bool
js
:
:
intl_TryValidateAndCanonicalizeLanguageTag
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
Rooted
<
JSLinearString
*
>
linear
(
cx
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
linear
)
{
return
false
;
}
mozilla
:
:
intl
:
:
Locale
tag
;
{
if
(
!
StringIsAscii
(
linear
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
intl
:
:
StringAsciiChars
chars
(
linear
)
;
if
(
!
chars
.
init
(
cx
)
)
{
return
false
;
}
if
(
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
chars
tag
)
.
isErr
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
}
auto
result
=
tag
.
Canonicalize
(
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
mozilla
:
:
intl
:
:
Locale
:
:
CanonicalizationError
:
:
DuplicateVariant
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DUPLICATE_VARIANT_SUBTAG
)
;
}
else
{
intl
:
:
ReportInternalError
(
cx
)
;
}
return
false
;
}
intl
:
:
FormatBuffer
<
char
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
false
;
}
JSString
*
resultStr
=
buffer
.
toAsciiString
(
cx
)
;
if
(
!
resultStr
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
resultStr
)
;
return
true
;
}
bool
js
:
:
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
HandleValue
typeArg
=
args
[
0
]
;
MOZ_ASSERT
(
typeArg
.
isString
(
)
"
type
must
be
a
string
"
)
;
HandleValue
optionArg
=
args
[
1
]
;
MOZ_ASSERT
(
optionArg
.
isString
(
)
"
option
name
must
be
a
string
"
)
;
HandleValue
keyArg
=
args
[
2
]
;
MOZ_ASSERT
(
keyArg
.
isString
(
)
"
key
must
be
a
string
"
)
;
Rooted
<
JSLinearString
*
>
unicodeType
(
cx
typeArg
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
unicodeType
)
{
return
false
;
}
bool
isValid
;
if
(
!
IsValidUnicodeExtensionValue
(
cx
unicodeType
&
isValid
)
)
{
return
false
;
}
if
(
!
isValid
)
{
UniqueChars
optionChars
=
EncodeAscii
(
cx
optionArg
.
toString
(
)
)
;
if
(
!
optionChars
)
{
return
false
;
}
UniqueChars
unicodeTypeChars
=
QuoteString
(
cx
unicodeType
'
"
'
)
;
if
(
!
unicodeTypeChars
)
{
return
false
;
}
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
optionChars
.
get
(
)
unicodeTypeChars
.
get
(
)
)
;
return
false
;
}
char
unicodeKey
[
UnicodeKeyLength
]
;
{
JSLinearString
*
str
=
keyArg
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
str
)
{
return
false
;
}
MOZ_ASSERT
(
str
-
>
length
(
)
=
=
UnicodeKeyLength
)
;
for
(
size_t
i
=
0
;
i
<
UnicodeKeyLength
;
i
+
+
)
{
char16_t
ch
=
str
-
>
latin1OrTwoByteChar
(
i
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
ch
)
)
;
unicodeKey
[
i
]
=
char
(
ch
)
;
}
}
UniqueChars
unicodeTypeChars
=
EncodeAscii
(
cx
unicodeType
)
;
if
(
!
unicodeTypeChars
)
{
return
false
;
}
size_t
unicodeTypeLength
=
unicodeType
-
>
length
(
)
;
MOZ_ASSERT
(
strlen
(
unicodeTypeChars
.
get
(
)
)
=
=
unicodeTypeLength
)
;
mozilla
:
:
intl
:
:
AsciiToLowerCase
(
unicodeTypeChars
.
get
(
)
unicodeTypeLength
unicodeTypeChars
.
get
(
)
)
;
auto
key
=
mozilla
:
:
Span
(
unicodeKey
UnicodeKeyLength
)
;
auto
type
=
mozilla
:
:
Span
(
unicodeTypeChars
.
get
(
)
unicodeTypeLength
)
;
JSString
*
result
;
if
(
const
char
*
replacement
=
mozilla
:
:
intl
:
:
Locale
:
:
ReplaceUnicodeExtensionType
(
key
type
)
)
{
result
=
NewStringCopyZ
<
CanGC
>
(
cx
replacement
)
;
}
else
{
result
=
StringToLowerCase
(
cx
unicodeType
)
;
}
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
result
)
;
return
true
;
}
