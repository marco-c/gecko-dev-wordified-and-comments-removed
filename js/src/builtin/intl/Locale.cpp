#
include
"
builtin
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
string
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
intl
:
:
LanguageTagLimits
;
using
intl
:
:
LanguageTag
;
using
intl
:
:
LanguageTagParser
;
const
JSClass
LocaleObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_RESERVED_SLOTS
(
LocaleObject
:
:
SLOT_COUNT
)
}
;
static
inline
bool
IsLocale
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
LocaleObject
>
(
)
;
}
static
size_t
BaseNameLength
(
const
LanguageTag
&
tag
)
{
size_t
baseNameLength
=
tag
.
language
(
)
.
length
(
)
;
if
(
tag
.
script
(
)
.
length
(
)
>
0
)
{
baseNameLength
+
=
1
+
tag
.
script
(
)
.
length
(
)
;
}
if
(
tag
.
region
(
)
.
length
(
)
>
0
)
{
baseNameLength
+
=
1
+
tag
.
region
(
)
.
length
(
)
;
}
for
(
const
auto
&
variant
:
tag
.
variants
(
)
)
{
baseNameLength
+
=
1
+
strlen
(
variant
.
get
(
)
)
;
}
return
baseNameLength
;
}
struct
IndexAndLength
{
size_t
index
;
size_t
length
;
IndexAndLength
(
size_t
index
size_t
length
)
:
index
(
index
)
length
(
length
)
{
}
;
template
<
typename
T
>
mozilla
:
:
Range
<
const
T
>
rangeOf
(
const
T
*
ptr
)
const
{
return
{
ptr
+
index
length
}
;
}
}
;
static
mozilla
:
:
Maybe
<
IndexAndLength
>
UnicodeExtensionPosition
(
const
LanguageTag
&
tag
)
{
size_t
index
=
0
;
for
(
const
auto
&
extension
:
tag
.
extensions
(
)
)
{
size_t
extensionLength
=
strlen
(
extension
.
get
(
)
)
;
if
(
extension
[
0
]
=
=
'
u
'
)
{
return
mozilla
:
:
Some
(
IndexAndLength
{
index
extensionLength
}
)
;
}
index
+
=
1
+
extensionLength
;
}
return
mozilla
:
:
Nothing
(
)
;
}
static
LocaleObject
*
CreateLocaleObject
(
JSContext
*
cx
HandleObject
prototype
const
LanguageTag
&
tag
)
{
RootedObject
proto
(
cx
prototype
)
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreateLocalePrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
}
JSStringBuilder
sb
(
cx
)
;
if
(
!
tag
.
appendTo
(
cx
sb
)
)
{
return
nullptr
;
}
RootedString
tagStr
(
cx
sb
.
finishString
(
)
)
;
if
(
!
tagStr
)
{
return
nullptr
;
}
size_t
baseNameLength
=
BaseNameLength
(
tag
)
;
RootedString
baseName
(
cx
NewDependentString
(
cx
tagStr
0
baseNameLength
)
)
;
if
(
!
baseName
)
{
return
nullptr
;
}
RootedValue
unicodeExtension
(
cx
UndefinedValue
(
)
)
;
if
(
auto
result
=
UnicodeExtensionPosition
(
tag
)
)
{
JSString
*
str
=
NewDependentString
(
cx
tagStr
baseNameLength
+
1
+
result
-
>
index
result
-
>
length
)
;
if
(
!
str
)
{
return
nullptr
;
}
unicodeExtension
.
setString
(
str
)
;
}
auto
*
locale
=
NewObjectWithGivenProto
<
LocaleObject
>
(
cx
proto
)
;
if
(
!
locale
)
{
return
nullptr
;
}
locale
-
>
setFixedSlot
(
LocaleObject
:
:
LANGUAGE_TAG_SLOT
StringValue
(
tagStr
)
)
;
locale
-
>
setFixedSlot
(
LocaleObject
:
:
BASENAME_SLOT
StringValue
(
baseName
)
)
;
locale
-
>
setFixedSlot
(
LocaleObject
:
:
UNICODE_EXTENSION_SLOT
unicodeExtension
)
;
return
locale
;
}
static
inline
bool
IsValidUnicodeExtensionValue
(
JSLinearString
*
linear
)
{
return
linear
-
>
length
(
)
>
0
&
&
LanguageTagParser
:
:
canParseUnicodeExtensionType
(
linear
)
;
}
template
<
typename
CharT
>
class
SepKeywordIterator
{
const
CharT
*
iter_
;
const
CharT
*
const
end_
;
public
:
SepKeywordIterator
(
const
CharT
*
unicodeExtensionBegin
const
CharT
*
unicodeExtensionEnd
)
:
iter_
(
unicodeExtensionBegin
)
end_
(
unicodeExtensionEnd
)
{
}
const
CharT
*
next
(
)
{
MOZ_ASSERT
(
iter_
!
=
nullptr
"
can
'
t
call
next
(
)
once
it
'
s
returned
nullptr
"
)
;
constexpr
size_t
SepKeyLength
=
1
+
UnicodeKeyLength
;
MOZ_ASSERT
(
iter_
+
SepKeyLength
<
=
end_
"
overall
Unicode
locale
extension
or
non
-
leading
subtags
must
"
"
be
at
least
key
-
sized
"
)
;
MOZ_ASSERT
(
(
iter_
[
0
]
=
=
'
u
'
&
&
iter_
[
1
]
=
=
'
-
'
)
|
|
iter_
[
0
]
=
=
'
-
'
)
;
while
(
true
)
{
iter_
+
+
;
iter_
=
std
:
:
char_traits
<
CharT
>
:
:
find
(
iter_
mozilla
:
:
PointerRangeSize
(
iter_
end_
)
CharT
(
'
-
'
)
)
;
if
(
!
iter_
)
{
return
nullptr
;
}
MOZ_ASSERT
(
iter_
+
SepKeyLength
<
=
end_
"
non
-
leading
subtags
in
a
Unicode
locale
extension
are
all
"
"
at
least
as
long
as
a
key
"
)
;
if
(
iter_
+
SepKeyLength
=
=
end_
|
|
iter_
[
SepKeyLength
]
=
=
'
-
'
)
{
break
;
}
}
MOZ_ASSERT
(
iter_
[
0
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAsciiLowercaseAlpha
(
iter_
[
1
]
)
|
|
mozilla
:
:
IsAsciiDigit
(
iter_
[
1
]
)
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAsciiLowercaseAlpha
(
iter_
[
2
]
)
)
;
MOZ_ASSERT_IF
(
iter_
+
SepKeyLength
<
end_
iter_
[
SepKeyLength
]
=
=
'
-
'
)
;
return
iter_
;
}
}
;
static
bool
GetStringOption
(
JSContext
*
cx
HandleObject
options
HandlePropertyName
name
MutableHandle
<
JSLinearString
*
>
string
)
{
RootedValue
option
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
name
&
option
)
)
{
return
false
;
}
JSLinearString
*
linear
=
nullptr
;
if
(
!
option
.
isUndefined
(
)
)
{
JSString
*
str
=
ToString
(
cx
option
)
;
if
(
!
str
)
{
return
false
;
}
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
}
string
.
set
(
linear
)
;
return
true
;
}
static
bool
GetBooleanOption
(
JSContext
*
cx
HandleObject
options
HandlePropertyName
name
MutableHandle
<
JSLinearString
*
>
string
)
{
RootedValue
option
(
cx
)
;
if
(
!
GetProperty
(
cx
options
options
name
&
option
)
)
{
return
false
;
}
JSLinearString
*
linear
=
nullptr
;
if
(
!
option
.
isUndefined
(
)
)
{
JSString
*
str
=
BooleanToString
(
cx
ToBoolean
(
option
)
)
;
MOZ_ALWAYS_TRUE
(
linear
=
str
-
>
ensureLinear
(
cx
)
)
;
}
string
.
set
(
linear
)
;
return
true
;
}
static
bool
ApplyOptionsToTag
(
JSContext
*
cx
LanguageTag
&
tag
HandleObject
options
)
{
RootedLinearString
option
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
language
&
option
)
)
{
return
false
;
}
intl
:
:
LanguageSubtag
language
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneLanguagTag
(
option
language
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
option
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
language
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
script
&
option
)
)
{
return
false
;
}
intl
:
:
ScriptSubtag
script
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneScriptTag
(
option
script
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
option
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
script
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
region
&
option
)
)
{
return
false
;
}
intl
:
:
RegionSubtag
region
;
if
(
option
&
&
!
intl
:
:
ParseStandaloneRegionTag
(
option
region
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
option
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
region
"
str
.
get
(
)
)
;
}
return
false
;
}
if
(
language
.
length
(
)
>
0
|
|
script
.
length
(
)
>
0
|
|
region
.
length
(
)
>
0
)
{
if
(
language
.
length
(
)
>
0
)
{
tag
.
setLanguage
(
language
)
;
}
if
(
script
.
length
(
)
>
0
)
{
tag
.
setScript
(
script
)
;
}
if
(
region
.
length
(
)
>
0
)
{
tag
.
setRegion
(
region
)
;
}
if
(
!
tag
.
canonicalizeBaseName
(
cx
)
)
{
return
true
;
}
}
return
true
;
}
static
bool
ApplyUnicodeExtensionToTag
(
JSContext
*
cx
LanguageTag
&
tag
HandleLinearString
calendar
HandleLinearString
collation
HandleLinearString
hourCycle
HandleLinearString
caseFirst
HandleLinearString
numeric
HandleLinearString
numberingSystem
)
{
if
(
!
calendar
&
&
!
collation
&
&
!
caseFirst
&
&
!
hourCycle
&
&
!
numeric
&
&
!
numberingSystem
)
{
return
true
;
}
Vector
<
char
32
>
newExtension
(
cx
)
;
if
(
!
newExtension
.
append
(
'
u
'
)
)
{
return
false
;
}
const
UniqueChars
*
existingUnicodeExtension
=
std
:
:
find_if
(
tag
.
extensions
(
)
.
begin
(
)
tag
.
extensions
(
)
.
end
(
)
[
]
(
const
auto
&
extension
)
{
return
extension
[
0
]
=
=
'
u
'
;
}
)
;
const
char
*
unicodeExtensionEnd
=
nullptr
;
const
char
*
unicodeExtensionKeywords
=
nullptr
;
if
(
existingUnicodeExtension
!
=
tag
.
extensions
(
)
.
end
(
)
)
{
const
char
*
unicodeExtension
=
existingUnicodeExtension
-
>
get
(
)
;
unicodeExtensionEnd
=
unicodeExtension
+
strlen
(
unicodeExtension
)
;
SepKeywordIterator
<
char
>
iter
(
unicodeExtension
unicodeExtensionEnd
)
;
unicodeExtensionKeywords
=
iter
.
next
(
)
;
const
char
*
attributesEnd
=
unicodeExtensionKeywords
?
unicodeExtensionKeywords
:
unicodeExtensionEnd
;
if
(
!
newExtension
.
append
(
unicodeExtension
+
1
attributesEnd
)
)
{
return
false
;
}
}
using
UnicodeKeyWithSeparator
=
const
char
(
&
)
[
UnicodeKeyLength
+
3
]
;
auto
appendKeyword
=
[
&
newExtension
]
(
UnicodeKeyWithSeparator
key
JSLinearString
*
value
)
{
if
(
!
newExtension
.
append
(
key
UnicodeKeyLength
+
2
)
)
{
return
false
;
}
JS
:
:
AutoCheckCannotGC
nogc
;
return
value
-
>
hasLatin1Chars
(
)
?
newExtension
.
append
(
value
-
>
latin1Chars
(
nogc
)
value
-
>
length
(
)
)
:
newExtension
.
append
(
value
-
>
twoByteChars
(
nogc
)
value
-
>
length
(
)
)
;
}
;
size_t
startNewKeywords
=
newExtension
.
length
(
)
;
if
(
calendar
)
{
if
(
!
appendKeyword
(
"
-
ca
-
"
calendar
)
)
{
return
false
;
}
}
if
(
collation
)
{
if
(
!
appendKeyword
(
"
-
co
-
"
collation
)
)
{
return
false
;
}
}
if
(
hourCycle
)
{
if
(
!
appendKeyword
(
"
-
hc
-
"
hourCycle
)
)
{
return
false
;
}
}
if
(
caseFirst
)
{
if
(
!
appendKeyword
(
"
-
kf
-
"
caseFirst
)
)
{
return
false
;
}
}
if
(
numeric
)
{
if
(
!
appendKeyword
(
"
-
kn
-
"
numeric
)
)
{
return
false
;
}
}
if
(
numberingSystem
)
{
if
(
!
appendKeyword
(
"
-
nu
-
"
numberingSystem
)
)
{
return
false
;
}
}
std
:
:
transform
(
newExtension
.
begin
(
)
+
startNewKeywords
newExtension
.
end
(
)
newExtension
.
begin
(
)
+
startNewKeywords
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiUppercaseAlpha
(
c
)
?
(
c
|
0x20
)
:
c
;
}
)
;
if
(
unicodeExtensionKeywords
)
{
if
(
!
newExtension
.
append
(
unicodeExtensionKeywords
unicodeExtensionEnd
)
)
{
return
false
;
}
}
if
(
!
newExtension
.
append
(
'
\
0
'
)
)
{
return
false
;
}
UniqueChars
newExtensionChars
(
newExtension
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
newExtensionChars
)
{
return
false
;
}
return
tag
.
setUnicodeExtension
(
std
:
:
move
(
newExtensionChars
)
)
;
}
static
bool
Locale
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Intl
.
Locale
"
)
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Null
&
proto
)
)
{
return
false
;
}
if
(
args
.
length
(
)
=
=
0
|
|
(
!
args
[
0
]
.
isString
(
)
&
&
!
args
[
0
]
.
isObject
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_LOCALES_ELEMENT
)
;
return
false
;
}
RootedString
tagStr
(
cx
)
;
if
(
args
[
0
]
.
isObject
(
)
)
{
JSObject
*
obj
=
&
args
[
0
]
.
toObject
(
)
;
if
(
obj
-
>
is
<
LocaleObject
>
(
)
)
{
tagStr
=
obj
-
>
as
<
LocaleObject
>
(
)
.
languageTag
(
)
;
}
else
{
JSObject
*
unwrapped
=
CheckedUnwrapStatic
(
obj
)
;
if
(
!
unwrapped
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
unwrapped
-
>
is
<
LocaleObject
>
(
)
)
{
tagStr
=
unwrapped
-
>
as
<
LocaleObject
>
(
)
.
languageTag
(
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
tagStr
)
)
{
return
false
;
}
}
else
{
tagStr
=
ToString
(
cx
args
[
0
]
)
;
if
(
!
tagStr
)
{
return
false
;
}
}
}
}
else
{
tagStr
=
args
[
0
]
.
toString
(
)
;
}
RootedLinearString
tagLinearStr
(
cx
tagStr
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagLinearStr
)
{
return
false
;
}
LanguageTag
tag
(
cx
)
;
if
(
!
LanguageTagParser
:
:
parse
(
cx
tagLinearStr
tag
)
)
{
return
false
;
}
if
(
!
tag
.
canonicalizeBaseName
(
cx
)
)
{
return
false
;
}
if
(
args
.
hasDefined
(
1
)
)
{
RootedObject
options
(
cx
ToObject
(
cx
args
[
1
]
)
)
;
if
(
!
options
)
{
return
false
;
}
if
(
!
ApplyOptionsToTag
(
cx
tag
options
)
)
{
return
false
;
}
RootedLinearString
calendar
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
calendar
&
calendar
)
)
{
return
false
;
}
if
(
calendar
)
{
if
(
!
IsValidUnicodeExtensionValue
(
calendar
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
calendar
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
calendar
"
str
.
get
(
)
)
;
}
return
false
;
}
}
RootedLinearString
collation
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
collation
&
collation
)
)
{
return
false
;
}
if
(
collation
)
{
if
(
!
IsValidUnicodeExtensionValue
(
collation
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
collation
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
collation
"
str
.
get
(
)
)
;
}
return
false
;
}
}
RootedLinearString
hourCycle
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
hourCycle
&
hourCycle
)
)
{
return
false
;
}
if
(
hourCycle
)
{
if
(
!
StringEqualsLiteral
(
hourCycle
"
h11
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h12
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h23
"
)
&
&
!
StringEqualsLiteral
(
hourCycle
"
h24
"
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
hourCycle
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
hourCycle
"
str
.
get
(
)
)
;
}
return
false
;
}
}
RootedLinearString
caseFirst
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
caseFirst
&
caseFirst
)
)
{
return
false
;
}
if
(
caseFirst
)
{
if
(
!
StringEqualsLiteral
(
caseFirst
"
upper
"
)
&
&
!
StringEqualsLiteral
(
caseFirst
"
lower
"
)
&
&
!
StringEqualsLiteral
(
caseFirst
"
false
"
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
caseFirst
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
caseFirst
"
str
.
get
(
)
)
;
}
return
false
;
}
}
RootedLinearString
numeric
(
cx
)
;
if
(
!
GetBooleanOption
(
cx
options
cx
-
>
names
(
)
.
numeric
&
numeric
)
)
{
return
false
;
}
RootedLinearString
numberingSystem
(
cx
)
;
if
(
!
GetStringOption
(
cx
options
cx
-
>
names
(
)
.
numberingSystem
&
numberingSystem
)
)
{
return
false
;
}
if
(
numberingSystem
)
{
if
(
!
IsValidUnicodeExtensionValue
(
numberingSystem
)
)
{
if
(
UniqueChars
str
=
StringToNewUTF8CharsZ
(
cx
*
numberingSystem
)
)
{
JS_ReportErrorNumberUTF8
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_OPTION_VALUE
"
numberingSystem
"
str
.
get
(
)
)
;
}
return
false
;
}
}
if
(
!
ApplyUnicodeExtensionToTag
(
cx
tag
calendar
collation
hourCycle
caseFirst
numeric
numberingSystem
)
)
{
return
false
;
}
}
if
(
!
tag
.
canonicalizeExtensions
(
cx
LanguageTag
:
:
UnicodeExtensionCanonicalForm
:
:
Yes
)
)
{
return
false
;
}
JSObject
*
obj
=
CreateLocaleObject
(
cx
proto
tag
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
using
UnicodeKey
=
const
char
(
&
)
[
UnicodeKeyLength
+
1
]
;
template
<
typename
CharT
>
static
mozilla
:
:
Maybe
<
IndexAndLength
>
FindUnicodeExtensionType
(
const
CharT
*
extension
size_t
length
UnicodeKey
key
)
{
MOZ_ASSERT
(
extension
[
0
]
=
=
'
u
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
const
CharT
*
end
=
extension
+
length
;
SepKeywordIterator
<
CharT
>
iter
(
extension
end
)
;
const
CharT
*
beginKey
;
while
(
true
)
{
beginKey
=
iter
.
next
(
)
;
if
(
!
beginKey
)
{
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ASSERT
(
beginKey
[
0
]
=
=
'
-
'
)
;
beginKey
+
+
;
if
(
std
:
:
equal
(
beginKey
beginKey
+
UnicodeKeyLength
key
)
)
{
break
;
}
}
const
CharT
*
beginType
=
beginKey
+
UnicodeKeyLength
;
const
CharT
*
endType
=
iter
.
next
(
)
;
if
(
!
endType
)
{
endType
=
end
;
}
if
(
beginType
!
=
endType
)
{
MOZ_ASSERT
(
beginType
[
0
]
=
=
'
-
'
)
;
beginType
+
+
;
}
return
mozilla
:
:
Some
(
IndexAndLength
{
size_t
(
beginType
-
extension
)
size_t
(
endType
-
beginType
)
}
)
;
}
static
inline
auto
FindUnicodeExtensionType
(
JSLinearString
*
unicodeExtension
UnicodeKey
key
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
unicodeExtension
-
>
hasLatin1Chars
(
)
?
FindUnicodeExtensionType
(
unicodeExtension
-
>
latin1Chars
(
nogc
)
unicodeExtension
-
>
length
(
)
key
)
:
FindUnicodeExtensionType
(
unicodeExtension
-
>
twoByteChars
(
nogc
)
unicodeExtension
-
>
length
(
)
key
)
;
}
static
bool
GetUnicodeExtension
(
JSContext
*
cx
LocaleObject
*
locale
UnicodeKey
key
MutableHandleValue
value
)
{
const
Value
&
unicodeExtensionValue
=
locale
-
>
unicodeExtension
(
)
;
if
(
unicodeExtensionValue
.
isUndefined
(
)
)
{
value
.
setUndefined
(
)
;
return
true
;
}
JSLinearString
*
unicodeExtension
=
unicodeExtensionValue
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
unicodeExtension
)
{
return
false
;
}
auto
result
=
FindUnicodeExtensionType
(
unicodeExtension
key
)
;
if
(
!
result
)
{
value
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
result
-
>
index
;
size_t
length
=
result
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
unicodeExtension
index
length
)
;
if
(
!
str
)
{
return
false
;
}
value
.
setString
(
str
)
;
return
true
;
}
struct
BaseNamePartsResult
{
IndexAndLength
language
;
mozilla
:
:
Maybe
<
IndexAndLength
>
script
;
mozilla
:
:
Maybe
<
IndexAndLength
>
region
;
}
;
template
<
typename
CharT
>
static
BaseNamePartsResult
BaseNameParts
(
const
CharT
*
baseName
size_t
length
)
{
size_t
languageLength
;
size_t
scriptIndex
=
0
;
size_t
regionIndex
=
0
;
size_t
regionLength
=
0
;
if
(
const
CharT
*
sep
=
std
:
:
char_traits
<
CharT
>
:
:
find
(
baseName
length
'
-
'
)
)
{
languageLength
=
sep
-
baseName
;
size_t
nextSubtag
=
languageLength
+
1
;
if
(
(
nextSubtag
+
ScriptLength
=
=
length
|
|
(
nextSubtag
+
ScriptLength
<
length
&
&
baseName
[
nextSubtag
+
ScriptLength
]
=
=
'
-
'
)
)
&
&
mozilla
:
:
IsAsciiAlpha
(
baseName
[
nextSubtag
]
)
)
{
scriptIndex
=
nextSubtag
;
nextSubtag
=
scriptIndex
+
ScriptLength
+
1
;
}
if
(
nextSubtag
<
length
)
{
for
(
size_t
rlen
:
{
AlphaRegionLength
DigitRegionLength
}
)
{
MOZ_ASSERT
(
nextSubtag
+
rlen
<
=
length
)
;
if
(
nextSubtag
+
rlen
=
=
length
|
|
baseName
[
nextSubtag
+
rlen
]
=
=
'
-
'
)
{
regionIndex
=
nextSubtag
;
regionLength
=
rlen
;
break
;
}
}
}
}
else
{
languageLength
=
length
;
}
IndexAndLength
language
{
0
languageLength
}
;
MOZ_ASSERT
(
intl
:
:
IsStructurallyValidLanguageTag
(
language
.
rangeOf
(
baseName
)
)
)
;
mozilla
:
:
Maybe
<
IndexAndLength
>
script
{
}
;
if
(
scriptIndex
)
{
script
.
emplace
(
scriptIndex
ScriptLength
)
;
MOZ_ASSERT
(
intl
:
:
IsStructurallyValidScriptTag
(
script
-
>
rangeOf
(
baseName
)
)
)
;
}
mozilla
:
:
Maybe
<
IndexAndLength
>
region
{
}
;
if
(
regionIndex
)
{
region
.
emplace
(
regionIndex
regionLength
)
;
MOZ_ASSERT
(
intl
:
:
IsStructurallyValidRegionTag
(
region
-
>
rangeOf
(
baseName
)
)
)
;
}
return
{
language
script
region
}
;
}
static
inline
auto
BaseNameParts
(
JSLinearString
*
baseName
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
baseName
-
>
hasLatin1Chars
(
)
?
BaseNameParts
(
baseName
-
>
latin1Chars
(
nogc
)
baseName
-
>
length
(
)
)
:
BaseNameParts
(
baseName
-
>
twoByteChars
(
nogc
)
baseName
-
>
length
(
)
)
;
}
static
bool
Locale_maximize
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
RootedLinearString
tagStr
(
cx
locale
-
>
languageTag
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagStr
)
{
return
false
;
}
LanguageTag
tag
(
cx
)
;
if
(
!
LanguageTagParser
:
:
parse
(
cx
tagStr
tag
)
)
{
return
false
;
}
if
(
!
tag
.
addLikelySubtags
(
cx
)
)
{
return
false
;
}
auto
*
result
=
CreateLocaleObject
(
cx
nullptr
tag
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Locale_maximize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_maximize
>
(
cx
args
)
;
}
static
bool
Locale_minimize
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
RootedLinearString
tagStr
(
cx
locale
-
>
languageTag
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
tagStr
)
{
return
false
;
}
LanguageTag
tag
(
cx
)
;
if
(
!
LanguageTagParser
:
:
parse
(
cx
tagStr
tag
)
)
{
return
false
;
}
if
(
!
tag
.
removeLikelySubtags
(
cx
)
)
{
return
false
;
}
auto
*
result
=
CreateLocaleObject
(
cx
nullptr
tag
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
static
bool
Locale_minimize
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_minimize
>
(
cx
args
)
;
}
static
bool
Locale_toString
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
args
.
rval
(
)
.
setString
(
locale
-
>
languageTag
(
)
)
;
return
true
;
}
static
bool
Locale_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_toString
>
(
cx
args
)
;
}
static
bool
Locale_baseName
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
args
.
rval
(
)
.
setString
(
locale
-
>
baseName
(
)
)
;
return
true
;
}
static
bool
Locale_baseName
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_baseName
>
(
cx
args
)
;
}
static
bool
Locale_calendar
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
ca
"
args
.
rval
(
)
)
;
}
static
bool
Locale_calendar
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_calendar
>
(
cx
args
)
;
}
static
bool
Locale_collation
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
co
"
args
.
rval
(
)
)
;
}
static
bool
Locale_collation
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_collation
>
(
cx
args
)
;
}
static
bool
Locale_hourCycle
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
hc
"
args
.
rval
(
)
)
;
}
static
bool
Locale_hourCycle
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_hourCycle
>
(
cx
args
)
;
}
static
bool
Locale_caseFirst
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
kf
"
args
.
rval
(
)
)
;
}
static
bool
Locale_caseFirst
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_caseFirst
>
(
cx
args
)
;
}
static
bool
Locale_numeric
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetUnicodeExtension
(
cx
locale
"
kn
"
&
value
)
)
{
return
false
;
}
MOZ_ASSERT
(
value
.
isUndefined
(
)
|
|
value
.
isString
(
)
)
;
args
.
rval
(
)
.
setBoolean
(
value
.
isString
(
)
&
&
value
.
toString
(
)
-
>
empty
(
)
)
;
return
true
;
}
static
bool
Locale_numeric
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_numeric
>
(
cx
args
)
;
}
static
bool
Intl_Locale_numberingSystem
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
return
GetUnicodeExtension
(
cx
locale
"
nu
"
args
.
rval
(
)
)
;
}
static
bool
Locale_numberingSystem
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Intl_Locale_numberingSystem
>
(
cx
args
)
;
}
static
bool
Locale_language
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
language
=
BaseNameParts
(
baseName
)
.
language
;
size_t
index
=
language
.
index
;
size_t
length
=
language
.
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_language
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_language
>
(
cx
args
)
;
}
static
bool
Locale_script
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
script
=
BaseNameParts
(
baseName
)
.
script
;
if
(
!
script
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
script
-
>
index
;
size_t
length
=
script
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_script
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_script
>
(
cx
args
)
;
}
static
bool
Locale_region
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsLocale
(
args
.
thisv
(
)
)
)
;
auto
*
locale
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
LocaleObject
>
(
)
;
JSLinearString
*
baseName
=
locale
-
>
baseName
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
baseName
)
{
return
false
;
}
auto
region
=
BaseNameParts
(
baseName
)
.
region
;
if
(
!
region
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
size_t
index
=
region
-
>
index
;
size_t
length
=
region
-
>
length
;
JSString
*
str
=
NewDependentString
(
cx
baseName
index
length
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
Locale_region
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsLocale
Locale_region
>
(
cx
args
)
;
}
static
bool
Locale_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Locale
)
;
return
true
;
}
static
const
JSFunctionSpec
locale_methods
[
]
=
{
JS_FN
(
"
maximize
"
Locale_maximize
0
0
)
JS_FN
(
"
minimize
"
Locale_minimize
0
0
)
JS_FN
(
js_toString_str
Locale_toString
0
0
)
JS_FN
(
js_toSource_str
Locale_toSource
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
locale_properties
[
]
=
{
JS_PSG
(
"
baseName
"
Locale_baseName
0
)
JS_PSG
(
"
calendar
"
Locale_calendar
0
)
JS_PSG
(
"
collation
"
Locale_collation
0
)
JS_PSG
(
"
hourCycle
"
Locale_hourCycle
0
)
JS_PSG
(
"
caseFirst
"
Locale_caseFirst
0
)
JS_PSG
(
"
numeric
"
Locale_numeric
0
)
JS_PSG
(
"
numberingSystem
"
Locale_numberingSystem
0
)
JS_PSG
(
"
language
"
Locale_language
0
)
JS_PSG
(
"
script
"
Locale_script
0
)
JS_PSG
(
"
region
"
Locale_region
0
)
JS_STRING_SYM_PS
(
toStringTag
"
Intl
.
Locale
"
JSPROP_READONLY
)
JS_PS_END
}
;
JSObject
*
js
:
:
CreateLocalePrototype
(
JSContext
*
cx
HandleObject
Intl
Handle
<
GlobalObject
*
>
global
)
{
RootedFunction
ctor
(
cx
GlobalObject
:
:
createConstructor
(
cx
&
Locale
cx
-
>
names
(
)
.
Locale
1
)
)
;
if
(
!
ctor
)
{
return
nullptr
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
{
return
nullptr
;
}
if
(
!
DefinePropertiesAndFunctions
(
cx
proto
locale_properties
locale_methods
)
)
{
return
nullptr
;
}
RootedValue
ctorValue
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
Intl
cx
-
>
names
(
)
.
Locale
ctorValue
0
)
)
{
return
nullptr
;
}
return
proto
;
}
bool
js
:
:
GlobalObject
:
:
addLocaleConstructor
(
JSContext
*
cx
HandleObject
intl
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
{
const
Value
&
proto
=
global
-
>
getReservedSlot
(
LOCALE_PROTO
)
;
if
(
!
proto
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
proto
.
isObject
(
)
)
;
JS_ReportErrorASCII
(
cx
"
the
Locale
constructor
can
'
t
be
added
multiple
times
in
the
"
"
same
global
"
)
;
return
false
;
}
}
JSObject
*
localeProto
=
CreateLocalePrototype
(
cx
intl
global
)
;
if
(
!
localeProto
)
{
return
false
;
}
global
-
>
setReservedSlot
(
LOCALE_PROTO
ObjectValue
(
*
localeProto
)
)
;
return
true
;
}
bool
js
:
:
AddLocaleConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
intl
)
{
return
GlobalObject
:
:
addLocaleConstructor
(
cx
intl
)
;
}
