#
include
"
builtin
/
intl
/
DecimalNumber
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
util
/
Unicode
.
h
"
#
include
"
vm
/
StringType
.
h
"
int32_t
js
:
:
intl
:
:
DecimalNumber
:
:
compareTo
(
const
DecimalNumber
&
other
)
const
{
MOZ_ASSERT
(
!
exponentTooLarge
(
)
)
;
MOZ_ASSERT
(
!
other
.
exponentTooLarge
(
)
)
;
if
(
isNegative
(
)
!
=
other
.
isNegative
(
)
)
{
return
isNegative
(
)
?
-
1
:
1
;
}
if
(
isZero
(
)
)
{
return
other
.
isZero
(
)
?
0
:
other
.
isNegative
(
)
?
1
:
-
1
;
}
if
(
other
.
isZero
(
)
)
{
return
isNegative
(
)
?
-
1
:
1
;
}
if
(
exponent
(
)
!
=
other
.
exponent
(
)
)
{
return
(
exponent
(
)
<
other
.
exponent
(
)
?
-
1
:
1
)
*
(
isNegative
(
)
?
-
1
:
1
)
;
}
class
Significand
{
const
DecimalNumber
&
decimal_
;
size_t
index_
;
public
:
explicit
Significand
(
const
DecimalNumber
&
decimal
)
:
decimal_
(
decimal
)
{
index_
=
decimal
.
significandStart_
;
}
int32_t
next
(
)
{
if
(
index_
>
=
decimal_
.
significandEnd_
)
{
return
0
;
}
char
ch
=
decimal_
.
charAt
(
index_
+
+
)
;
if
(
ch
=
=
'
.
'
)
{
if
(
index_
>
=
decimal_
.
significandEnd_
)
{
return
0
;
}
ch
=
decimal_
.
charAt
(
index_
+
+
)
;
}
MOZ_ASSERT
(
mozilla
:
:
IsAsciiDigit
(
ch
)
)
;
return
AsciiDigitToNumber
(
ch
)
;
}
}
;
Significand
s1
(
*
this
)
;
Significand
s2
(
other
)
;
for
(
int32_t
e
=
std
:
:
abs
(
exponent
(
)
)
;
e
>
=
0
;
e
-
-
)
{
int32_t
x
=
s1
.
next
(
)
;
int32_t
y
=
s2
.
next
(
)
;
if
(
int32_t
r
=
x
-
y
)
{
return
r
*
(
isNegative
(
)
?
-
1
:
1
)
;
}
}
return
0
;
}
mozilla
:
:
Maybe
<
js
:
:
intl
:
:
DecimalNumber
>
js
:
:
intl
:
:
DecimalNumber
:
:
from
(
JSLinearString
*
str
JS
:
:
AutoCheckCannotGC
&
nogc
)
{
return
str
-
>
hasLatin1Chars
(
)
?
from
<
Latin1Char
>
(
str
-
>
latin1Range
(
nogc
)
)
:
from
<
char16_t
>
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
template
<
typename
CharT
>
mozilla
:
:
Maybe
<
js
:
:
intl
:
:
DecimalNumber
>
js
:
:
intl
:
:
DecimalNumber
:
:
from
(
mozilla
:
:
Span
<
const
CharT
>
chars
)
{
DecimalNumber
number
(
chars
)
;
size_t
i
=
0
;
while
(
i
<
chars
.
size
(
)
&
&
unicode
:
:
IsSpace
(
chars
[
i
]
)
)
{
i
+
+
;
}
if
(
i
=
=
chars
.
size
(
)
)
{
number
.
zero_
=
true
;
return
mozilla
:
:
Some
(
number
)
;
}
if
(
auto
ch
=
chars
[
i
]
;
ch
=
=
'
-
'
|
|
ch
=
=
'
+
'
)
{
i
+
+
;
number
.
negative_
=
ch
=
=
'
-
'
;
if
(
i
=
=
chars
.
size
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
}
size_t
startInteger
=
i
;
size_t
endInteger
=
i
;
if
(
auto
ch
=
chars
[
i
]
;
mozilla
:
:
IsAsciiDigit
(
ch
)
)
{
while
(
i
<
chars
.
size
(
)
&
&
chars
[
i
]
=
=
'
0
'
)
{
i
+
+
;
}
startInteger
=
i
;
while
(
i
<
chars
.
size
(
)
&
&
mozilla
:
:
IsAsciiDigit
(
chars
[
i
]
)
)
{
i
+
+
;
}
endInteger
=
i
;
}
else
if
(
ch
=
=
'
.
'
)
{
if
(
i
+
1
=
=
chars
.
size
(
)
|
|
!
mozilla
:
:
IsAsciiDigit
(
chars
[
i
+
1
]
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
}
else
{
return
mozilla
:
:
Nothing
(
)
;
}
size_t
startFraction
=
i
;
size_t
endFraction
=
i
;
if
(
i
<
chars
.
size
(
)
&
&
chars
[
i
]
=
=
'
.
'
)
{
i
+
+
;
startFraction
=
i
;
while
(
i
<
chars
.
size
(
)
&
&
mozilla
:
:
IsAsciiDigit
(
chars
[
i
]
)
)
{
i
+
+
;
}
endFraction
=
i
;
while
(
startFraction
<
=
endFraction
&
&
chars
[
endFraction
-
1
]
=
=
'
0
'
)
{
endFraction
-
-
;
}
}
if
(
i
<
chars
.
size
(
)
&
&
(
chars
[
i
]
=
=
'
e
'
|
|
chars
[
i
]
=
=
'
E
'
)
)
{
i
+
+
;
if
(
i
=
=
chars
.
size
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
int32_t
exponentSign
=
1
;
if
(
auto
ch
=
chars
[
i
]
;
ch
=
=
'
-
'
|
|
ch
=
=
'
+
'
)
{
i
+
+
;
exponentSign
=
ch
=
=
'
-
'
?
-
1
:
+
1
;
if
(
i
=
=
chars
.
size
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
}
if
(
!
mozilla
:
:
IsAsciiDigit
(
chars
[
i
]
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
mozilla
:
:
CheckedInt32
exp
=
0
;
while
(
i
<
chars
.
size
(
)
&
&
mozilla
:
:
IsAsciiDigit
(
chars
[
i
]
)
)
{
exp
*
=
10
;
exp
+
=
AsciiDigitToNumber
(
chars
[
i
]
)
;
i
+
+
;
}
if
(
exp
.
isValid
(
)
)
{
number
.
exponent_
=
exp
.
value
(
)
*
exponentSign
;
}
else
{
number
.
exponentTooLarge_
=
true
;
}
}
while
(
i
<
chars
.
size
(
)
&
&
unicode
:
:
IsSpace
(
chars
[
i
]
)
)
{
i
+
+
;
}
if
(
i
!
=
chars
.
size
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
if
(
startInteger
<
endInteger
)
{
mozilla
:
:
CheckedInt32
integerExponent
=
number
.
exponent_
;
integerExponent
+
=
size_t
(
endInteger
-
startInteger
)
;
if
(
integerExponent
.
isValid
(
)
)
{
number
.
exponent_
=
integerExponent
.
value
(
)
;
}
else
{
number
.
exponent_
=
0
;
number
.
exponentTooLarge_
=
true
;
}
number
.
significandStart_
=
startInteger
;
number
.
significandEnd_
=
endFraction
;
}
else
if
(
startFraction
<
endFraction
)
{
size_t
i
=
startFraction
;
while
(
i
<
endFraction
&
&
chars
[
i
]
=
=
'
0
'
)
{
i
+
+
;
}
mozilla
:
:
CheckedInt32
fractionExponent
=
number
.
exponent_
;
fractionExponent
-
=
size_t
(
i
-
startFraction
)
;
if
(
fractionExponent
.
isValid
(
)
&
&
fractionExponent
.
value
(
)
!
=
INT32_MIN
)
{
number
.
exponent_
=
fractionExponent
.
value
(
)
;
}
else
{
number
.
exponent_
=
0
;
number
.
exponentTooLarge_
=
true
;
}
number
.
significandStart_
=
i
;
number
.
significandEnd_
=
endFraction
;
}
else
{
number
.
zero_
=
true
;
number
.
exponent_
=
0
;
number
.
exponentTooLarge_
=
false
;
}
return
mozilla
:
:
Some
(
number
)
;
}
