#
ifndef
builtin_intl_LanguageTag_h
#
define
builtin_intl_LanguageTag_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
struct
JSContext
;
class
JSLinearString
;
class
JSString
;
class
JSTracer
;
namespace
js
{
namespace
intl
{
template
<
typename
CharT
>
bool
IsStructurallyValidLanguageTag
(
mozilla
:
:
Span
<
const
CharT
>
language
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidScriptTag
(
mozilla
:
:
Span
<
const
CharT
>
script
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidRegionTag
(
mozilla
:
:
Span
<
const
CharT
>
region
)
;
#
ifdef
DEBUG
bool
IsStructurallyValidVariantTag
(
mozilla
:
:
Span
<
const
char
>
variant
)
;
bool
IsStructurallyValidUnicodeExtensionTag
(
mozilla
:
:
Span
<
const
char
>
extension
)
;
bool
IsStructurallyValidPrivateUseTag
(
mozilla
:
:
Span
<
const
char
>
privateUse
)
;
#
endif
template
<
typename
CharT
>
char
AsciiToLowerCase
(
CharT
c
)
{
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
c
)
)
;
return
mozilla
:
:
IsAsciiUppercaseAlpha
(
c
)
?
(
c
+
0x20
)
:
c
;
}
template
<
typename
CharT
>
char
AsciiToUpperCase
(
CharT
c
)
{
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
c
)
)
;
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
?
(
c
-
0x20
)
:
c
;
}
template
<
typename
CharT
>
void
AsciiToLowerCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
char
(
&
fn
)
(
CharT
)
=
AsciiToLowerCase
;
std
:
:
transform
(
chars
chars
+
length
dest
fn
)
;
}
template
<
typename
CharT
>
void
AsciiToUpperCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
char
(
&
fn
)
(
CharT
)
=
AsciiToUpperCase
;
std
:
:
transform
(
chars
chars
+
length
dest
fn
)
;
}
template
<
typename
CharT
>
void
AsciiToTitleCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
if
(
length
>
0
)
{
AsciiToUpperCase
(
chars
1
dest
)
;
AsciiToLowerCase
(
chars
+
1
length
-
1
dest
+
1
)
;
}
}
namespace
LanguageTagLimits
{
static
constexpr
size_t
LanguageLength
=
8
;
static
constexpr
size_t
ScriptLength
=
4
;
static
constexpr
size_t
RegionLength
=
3
;
static
constexpr
size_t
AlphaRegionLength
=
2
;
static
constexpr
size_t
DigitRegionLength
=
3
;
static
constexpr
size_t
UnicodeKeyLength
=
2
;
static
constexpr
size_t
TransformKeyLength
=
2
;
}
template
<
size_t
Length
>
class
LanguageTagSubtag
final
{
uint8_t
length_
=
0
;
char
chars_
[
Length
]
=
{
}
;
public
:
LanguageTagSubtag
(
)
=
default
;
LanguageTagSubtag
(
const
LanguageTagSubtag
&
)
=
delete
;
LanguageTagSubtag
&
operator
=
(
const
LanguageTagSubtag
&
)
=
delete
;
size_t
length
(
)
const
{
return
length_
;
}
bool
missing
(
)
const
{
return
length_
=
=
0
;
}
bool
present
(
)
const
{
return
length_
>
0
;
}
mozilla
:
:
Span
<
const
char
>
span
(
)
const
{
return
{
chars_
length_
}
;
}
template
<
typename
CharT
>
void
set
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
MOZ_ASSERT
(
str
.
size
(
)
<
=
Length
)
;
std
:
:
copy_n
(
str
.
data
(
)
str
.
size
(
)
chars_
)
;
length_
=
str
.
size
(
)
;
}
void
toLowerCase
(
)
{
AsciiToLowerCase
(
chars_
Length
chars_
)
;
}
void
toUpperCase
(
)
{
AsciiToUpperCase
(
chars_
Length
chars_
)
;
}
void
toTitleCase
(
)
{
AsciiToTitleCase
(
chars_
Length
chars_
)
;
}
template
<
size_t
N
>
bool
equalTo
(
const
char
(
&
str
)
[
N
]
)
const
{
static_assert
(
N
-
1
<
=
Length
"
subtag
literals
must
not
exceed
the
maximum
subtag
length
"
)
;
return
length_
=
=
N
-
1
&
&
memcmp
(
chars_
str
N
-
1
)
=
=
0
;
}
}
;
using
LanguageSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
LanguageLength
>
;
using
ScriptSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
ScriptLength
>
;
using
RegionSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
RegionLength
>
;
class
MOZ_STACK_CLASS
LanguageTag
final
{
LanguageSubtag
language_
=
{
}
;
ScriptSubtag
script_
=
{
}
;
RegionSubtag
region_
=
{
}
;
using
VariantsVector
=
Vector
<
JS
:
:
UniqueChars
2
>
;
using
ExtensionsVector
=
Vector
<
JS
:
:
UniqueChars
2
>
;
VariantsVector
variants_
;
ExtensionsVector
extensions_
;
JS
:
:
UniqueChars
privateuse_
=
nullptr
;
friend
class
LanguageTagParser
;
public
:
enum
class
UnicodeExtensionCanonicalForm
:
bool
{
No
Yes
}
;
private
:
bool
canonicalizeUnicodeExtension
(
JSContext
*
cx
JS
:
:
UniqueChars
&
unicodeExtension
UnicodeExtensionCanonicalForm
canonicalForm
)
;
bool
canonicalizeTransformExtension
(
JSContext
*
cx
JS
:
:
UniqueChars
&
transformExtension
)
;
public
:
static
bool
languageMapping
(
LanguageSubtag
&
language
)
;
static
bool
complexLanguageMapping
(
const
LanguageSubtag
&
language
)
;
private
:
static
bool
regionMapping
(
RegionSubtag
&
region
)
;
static
bool
complexRegionMapping
(
const
RegionSubtag
&
region
)
;
void
performComplexLanguageMappings
(
)
;
void
performComplexRegionMappings
(
)
;
MOZ_MUST_USE
bool
updateGrandfatheredMappings
(
JSContext
*
cx
)
;
static
const
char
*
replaceUnicodeExtensionType
(
mozilla
:
:
Span
<
const
char
>
key
mozilla
:
:
Span
<
const
char
>
type
)
;
public
:
explicit
LanguageTag
(
JSContext
*
cx
)
:
variants_
(
cx
)
extensions_
(
cx
)
{
}
LanguageTag
(
const
LanguageTag
&
)
=
delete
;
LanguageTag
&
operator
=
(
const
LanguageTag
&
)
=
delete
;
const
LanguageSubtag
&
language
(
)
const
{
return
language_
;
}
const
ScriptSubtag
&
script
(
)
const
{
return
script_
;
}
const
RegionSubtag
&
region
(
)
const
{
return
region_
;
}
const
auto
&
variants
(
)
const
{
return
variants_
;
}
const
auto
&
extensions
(
)
const
{
return
extensions_
;
}
const
char
*
privateuse
(
)
const
{
return
privateuse_
.
get
(
)
;
}
const
char
*
unicodeExtension
(
)
const
;
private
:
ptrdiff_t
unicodeExtensionIndex
(
)
const
;
public
:
template
<
size_t
N
>
void
setLanguage
(
const
char
(
&
language
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
language
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
span
)
)
;
language_
.
set
(
span
)
;
}
void
setLanguage
(
const
LanguageSubtag
&
language
)
{
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
language
.
span
(
)
)
)
;
language_
.
set
(
language
.
span
(
)
)
;
}
template
<
size_t
N
>
void
setScript
(
const
char
(
&
script
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
script
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidScriptTag
(
span
)
)
;
script_
.
set
(
span
)
;
}
void
setScript
(
const
ScriptSubtag
&
script
)
{
MOZ_ASSERT
(
script
.
missing
(
)
|
|
IsStructurallyValidScriptTag
(
script
.
span
(
)
)
)
;
script_
.
set
(
script
.
span
(
)
)
;
}
template
<
size_t
N
>
void
setRegion
(
const
char
(
&
region
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
region
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidRegionTag
(
span
)
)
;
region_
.
set
(
span
)
;
}
void
setRegion
(
const
RegionSubtag
&
region
)
{
MOZ_ASSERT
(
region
.
missing
(
)
|
|
IsStructurallyValidRegionTag
(
region
.
span
(
)
)
)
;
region_
.
set
(
region
.
span
(
)
)
;
}
void
clearVariants
(
)
{
variants_
.
clearAndFree
(
)
;
}
bool
setUnicodeExtension
(
JS
:
:
UniqueChars
extension
)
;
void
clearUnicodeExtension
(
)
;
void
setPrivateuse
(
JS
:
:
UniqueChars
privateuse
)
{
MOZ_ASSERT
(
!
privateuse
|
|
IsStructurallyValidPrivateUseTag
(
{
privateuse
.
get
(
)
strlen
(
privateuse
.
get
(
)
)
}
)
)
;
privateuse_
=
std
:
:
move
(
privateuse
)
;
}
bool
canonicalizeBaseName
(
JSContext
*
cx
)
;
bool
canonicalizeExtensions
(
JSContext
*
cx
UnicodeExtensionCanonicalForm
canonicalForm
)
;
bool
canonicalize
(
JSContext
*
cx
UnicodeExtensionCanonicalForm
canonicalForm
)
{
return
canonicalizeBaseName
(
cx
)
&
&
canonicalizeExtensions
(
cx
canonicalForm
)
;
}
JSString
*
toString
(
JSContext
*
cx
)
const
;
bool
addLikelySubtags
(
JSContext
*
cx
)
;
bool
removeLikelySubtags
(
JSContext
*
cx
)
;
}
;
class
MOZ_STACK_CLASS
LanguageTagParser
final
{
public
:
enum
class
TokenKind
:
uint8_t
{
None
=
0b000
Alpha
=
0b001
Digit
=
0b010
AlphaDigit
=
0b011
Error
=
0b100
}
;
private
:
class
Token
final
{
size_t
index_
;
size_t
length_
;
TokenKind
kind_
;
public
:
Token
(
TokenKind
kind
size_t
index
size_t
length
)
:
index_
(
index
)
length_
(
length
)
kind_
(
kind
)
{
}
TokenKind
kind
(
)
const
{
return
kind_
;
}
size_t
index
(
)
const
{
return
index_
;
}
size_t
length
(
)
const
{
return
length_
;
}
bool
isError
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Error
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TokenKind
:
:
None
;
}
bool
isAlpha
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Alpha
;
}
bool
isDigit
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Digit
;
}
bool
isAlphaDigit
(
)
const
{
return
kind_
=
=
TokenKind
:
:
AlphaDigit
;
}
}
;
using
LocaleChars
=
mozilla
:
:
Variant
<
const
JS
:
:
Latin1Char
*
const
char16_t
*
>
;
const
LocaleChars
&
locale_
;
size_t
length_
;
size_t
index_
=
0
;
LanguageTagParser
(
const
LocaleChars
&
locale
size_t
length
)
:
locale_
(
locale
)
length_
(
length
)
{
}
char16_t
charAtUnchecked
(
size_t
index
)
const
{
if
(
locale_
.
is
<
const
JS
:
:
Latin1Char
*
>
(
)
)
{
return
locale_
.
as
<
const
JS
:
:
Latin1Char
*
>
(
)
[
index
]
;
}
return
locale_
.
as
<
const
char16_t
*
>
(
)
[
index
]
;
}
char
charAt
(
size_t
index
)
const
{
char16_t
c
=
charAtUnchecked
(
index
)
;
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
c
)
)
;
return
c
;
}
template
<
size_t
N
>
void
copyChars
(
const
Token
&
tok
LanguageTagSubtag
<
N
>
&
subtag
)
const
{
size_t
index
=
tok
.
index
(
)
;
size_t
length
=
tok
.
length
(
)
;
if
(
locale_
.
is
<
const
JS
:
:
Latin1Char
*
>
(
)
)
{
using
T
=
const
JS
:
:
Latin1Char
;
subtag
.
set
(
mozilla
:
:
MakeSpan
(
locale_
.
as
<
T
*
>
(
)
+
index
length
)
)
;
}
else
{
using
T
=
const
char16_t
;
subtag
.
set
(
mozilla
:
:
MakeSpan
(
locale_
.
as
<
T
*
>
(
)
+
index
length
)
)
;
}
}
JS
:
:
UniqueChars
chars
(
JSContext
*
cx
size_t
index
size_t
length
)
const
;
JS
:
:
UniqueChars
chars
(
JSContext
*
cx
const
Token
&
tok
)
const
{
return
chars
(
cx
tok
.
index
(
)
tok
.
length
(
)
)
;
}
JS
:
:
UniqueChars
extension
(
JSContext
*
cx
const
Token
&
start
const
Token
&
end
)
const
{
MOZ_ASSERT
(
start
.
index
(
)
<
end
.
index
(
)
)
;
size_t
length
=
end
.
index
(
)
-
1
-
start
.
index
(
)
;
return
chars
(
cx
start
.
index
(
)
length
)
;
}
Token
nextToken
(
)
;
bool
isLanguage
(
const
Token
&
tok
)
const
{
return
tok
.
isAlpha
(
)
&
&
(
(
2
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
3
)
|
|
(
5
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
)
)
;
}
bool
isScript
(
const
Token
&
tok
)
const
{
return
tok
.
isAlpha
(
)
&
&
tok
.
length
(
)
=
=
4
;
}
bool
isRegion
(
const
Token
&
tok
)
const
{
return
(
tok
.
isAlpha
(
)
&
&
tok
.
length
(
)
=
=
2
)
|
|
(
tok
.
isDigit
(
)
&
&
tok
.
length
(
)
=
=
3
)
;
}
bool
isVariant
(
const
Token
&
tok
)
const
{
return
(
5
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
)
|
|
(
tok
.
length
(
)
=
=
4
&
&
mozilla
:
:
IsAsciiDigit
(
charAt
(
tok
.
index
(
)
)
)
)
;
}
char
singletonKey
(
const
Token
&
tok
)
const
{
MOZ_ASSERT
(
tok
.
length
(
)
=
=
1
)
;
return
AsciiToLowerCase
(
charAt
(
tok
.
index
(
)
)
)
;
}
bool
isExtensionStart
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
1
&
&
singletonKey
(
tok
)
!
=
'
x
'
;
}
bool
isOtherExtensionPart
(
const
Token
&
tok
)
const
{
return
2
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isUnicodeExtensionPart
(
const
Token
&
tok
)
const
{
return
isUnicodeExtensionKey
(
tok
)
|
|
isUnicodeExtensionType
(
tok
)
|
|
isUnicodeExtensionAttribute
(
tok
)
;
}
bool
isUnicodeExtensionAttribute
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isUnicodeExtensionKey
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
2
&
&
mozilla
:
:
IsAsciiAlpha
(
charAt
(
tok
.
index
(
)
+
1
)
)
;
}
bool
isUnicodeExtensionType
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isTransformExtensionKey
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
2
&
&
mozilla
:
:
IsAsciiAlpha
(
charAt
(
tok
.
index
(
)
)
)
&
&
mozilla
:
:
IsAsciiDigit
(
charAt
(
tok
.
index
(
)
+
1
)
)
;
}
bool
isTransformExtensionPart
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isPrivateUseStart
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
1
&
&
singletonKey
(
tok
)
=
=
'
x
'
;
}
bool
isPrivateUsePart
(
const
Token
&
tok
)
const
{
return
1
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
static
JS
:
:
Result
<
bool
>
internalParseBaseName
(
JSContext
*
cx
LanguageTagParser
&
ts
LanguageTag
&
tag
Token
&
tok
)
;
static
JS
:
:
Result
<
bool
>
parseBaseName
(
JSContext
*
cx
LanguageTagParser
&
ts
LanguageTag
&
tag
Token
&
tok
)
{
return
internalParseBaseName
(
cx
ts
tag
tok
)
;
}
static
JS
:
:
Result
<
JS
:
:
Ok
>
parseTlangInTransformExtension
(
JSContext
*
cx
LanguageTagParser
&
ts
LanguageTag
&
tag
Token
&
tok
)
{
MOZ_ASSERT
(
ts
.
isLanguage
(
tok
)
)
;
return
internalParseBaseName
(
cx
ts
tag
tok
)
.
map
(
[
]
(
bool
parsed
)
{
MOZ_ASSERT
(
parsed
)
;
return
JS
:
:
Ok
(
)
;
}
)
;
}
friend
class
LanguageTag
;
class
Range
final
{
size_t
begin_
;
size_t
length_
;
public
:
Range
(
size_t
begin
size_t
length
)
:
begin_
(
begin
)
length_
(
length
)
{
}
template
<
typename
T
>
T
*
begin
(
T
*
ptr
)
const
{
return
ptr
+
begin_
;
}
size_t
length
(
)
const
{
return
length_
;
}
}
;
using
TFieldVector
=
js
:
:
Vector
<
Range
8
>
;
using
AttributesVector
=
js
:
:
Vector
<
Range
8
>
;
using
KeywordsVector
=
js
:
:
Vector
<
Range
8
>
;
static
JS
:
:
Result
<
bool
>
parseTransformExtension
(
JSContext
*
cx
mozilla
:
:
Span
<
const
char
>
extension
LanguageTag
&
tag
TFieldVector
&
fields
)
;
static
JS
:
:
Result
<
bool
>
parseUnicodeExtension
(
JSContext
*
cx
mozilla
:
:
Span
<
const
char
>
extension
AttributesVector
&
attributes
KeywordsVector
&
keywords
)
;
public
:
static
bool
parse
(
JSContext
*
cx
JSLinearString
*
locale
LanguageTag
&
tag
)
;
static
JS
:
:
Result
<
bool
>
tryParse
(
JSContext
*
cx
JSLinearString
*
locale
LanguageTag
&
tag
)
;
static
bool
parseBaseName
(
JSContext
*
cx
mozilla
:
:
Span
<
const
char
>
locale
LanguageTag
&
tag
)
;
static
bool
canParseUnicodeExtension
(
mozilla
:
:
Span
<
const
char
>
extension
)
;
static
bool
canParseUnicodeExtensionType
(
JSLinearString
*
unicodeType
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
LanguageTagParser
:
:
TokenKind
)
MOZ_MUST_USE
bool
ParseStandaloneLanguageTag
(
JS
:
:
Handle
<
JSLinearString
*
>
str
LanguageSubtag
&
result
)
;
MOZ_MUST_USE
bool
ParseStandaloneScriptTag
(
JS
:
:
Handle
<
JSLinearString
*
>
str
ScriptSubtag
&
result
)
;
MOZ_MUST_USE
bool
ParseStandaloneRegionTag
(
JS
:
:
Handle
<
JSLinearString
*
>
str
RegionSubtag
&
result
)
;
JS
:
:
Result
<
JSString
*
>
ParseStandaloneISO639LanguageTag
(
JSContext
*
cx
JS
:
:
Handle
<
JSLinearString
*
>
str
)
;
class
UnicodeExtensionKeyword
final
{
char
key_
[
LanguageTagLimits
:
:
UnicodeKeyLength
]
;
JSLinearString
*
type_
;
public
:
using
UnicodeKey
=
const
char
(
&
)
[
LanguageTagLimits
:
:
UnicodeKeyLength
+
1
]
;
using
UnicodeKeySpan
=
mozilla
:
:
Span
<
const
char
LanguageTagLimits
:
:
UnicodeKeyLength
>
;
UnicodeExtensionKeyword
(
UnicodeKey
key
JSLinearString
*
type
)
:
key_
{
key
[
0
]
key
[
1
]
}
type_
(
type
)
{
}
UnicodeKeySpan
key
(
)
const
{
return
{
key_
sizeof
(
key_
)
}
;
}
JSLinearString
*
type
(
)
const
{
return
type_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
extern
MOZ_MUST_USE
bool
ApplyUnicodeExtensionToTag
(
JSContext
*
cx
LanguageTag
&
tag
JS
:
:
HandleVector
<
UnicodeExtensionKeyword
>
keywords
)
;
}
}
#
endif
