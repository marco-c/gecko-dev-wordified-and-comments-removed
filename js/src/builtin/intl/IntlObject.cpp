#
include
"
builtin
/
intl
/
IntlObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
Calendar
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cstring
>
#
include
<
iterator
>
#
include
<
string_view
>
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
intl
/
Collator
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
builtin
/
intl
/
DateTimeFormat
.
h
"
#
include
"
builtin
/
intl
/
FormatBuffer
.
h
"
#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
#
include
"
builtin
/
intl
/
MeasureUnitGenerated
.
h
"
#
include
"
builtin
/
intl
/
NumberFormat
.
h
"
#
include
"
builtin
/
intl
/
NumberingSystemsGenerated
.
h
"
#
include
"
builtin
/
intl
/
PluralRules
.
h
"
#
include
"
builtin
/
intl
/
RelativeTimeFormat
.
h
"
#
include
"
builtin
/
intl
/
ScopedICUObject
.
h
"
#
include
"
builtin
/
intl
/
SharedIntlData
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
unicode
/
ucal
.
h
"
#
include
"
unicode
/
ucol
.
h
"
#
include
"
unicode
/
ucurr
.
h
"
#
include
"
unicode
/
uenum
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
js
:
:
intl
:
:
IcuLocale
;
bool
js
:
:
intl_GetCalendarInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
UniqueChars
locale
=
intl
:
:
EncodeLocale
(
cx
args
[
0
]
.
toString
(
)
)
;
if
(
!
locale
)
{
return
false
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
const
UChar
*
uTimeZone
=
nullptr
;
int32_t
uTimeZoneLength
=
0
;
UCalendar
*
cal
=
ucal_open
(
uTimeZone
uTimeZoneLength
locale
.
get
(
)
UCAL_DEFAULT
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
ScopedICUObject
<
UCalendar
ucal_close
>
toClose
(
cal
)
;
RootedObject
info
(
cx
NewPlainObject
(
cx
)
)
;
if
(
!
info
)
{
return
false
;
}
RootedValue
v
(
cx
)
;
int32_t
firstDayOfWeek
=
ucal_getAttribute
(
cal
UCAL_FIRST_DAY_OF_WEEK
)
;
v
.
setInt32
(
firstDayOfWeek
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
firstDayOfWeek
v
)
)
{
return
false
;
}
int32_t
minDays
=
ucal_getAttribute
(
cal
UCAL_MINIMAL_DAYS_IN_FIRST_WEEK
)
;
v
.
setInt32
(
minDays
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
minDays
v
)
)
{
return
false
;
}
UCalendarWeekdayType
prevDayType
=
ucal_getDayOfWeekType
(
cal
UCAL_SATURDAY
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
RootedValue
weekendStart
(
cx
)
weekendEnd
(
cx
)
;
for
(
int
i
=
UCAL_SUNDAY
;
i
<
=
UCAL_SATURDAY
;
i
+
+
)
{
UCalendarDaysOfWeek
dayOfWeek
=
static_cast
<
UCalendarDaysOfWeek
>
(
i
)
;
UCalendarWeekdayType
type
=
ucal_getDayOfWeekType
(
cal
dayOfWeek
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
prevDayType
!
=
type
)
{
switch
(
type
)
{
case
UCAL_WEEKDAY
:
weekendEnd
.
setInt32
(
i
=
=
1
?
7
:
i
-
1
)
;
break
;
case
UCAL_WEEKEND
:
weekendStart
.
setInt32
(
i
)
;
break
;
case
UCAL_WEEKEND_ONSET
:
case
UCAL_WEEKEND_CEASE
:
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
default
:
break
;
}
}
prevDayType
=
type
;
}
MOZ_ASSERT
(
weekendStart
.
isInt32
(
)
)
;
MOZ_ASSERT
(
weekendEnd
.
isInt32
(
)
)
;
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
weekendStart
weekendStart
)
)
{
return
false
;
}
if
(
!
DefineDataProperty
(
cx
info
cx
-
>
names
(
)
.
weekendEnd
weekendEnd
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
info
)
;
return
true
;
}
static
void
ReportBadKey
(
JSContext
*
cx
JSString
*
key
)
{
if
(
UniqueChars
chars
=
QuoteString
(
cx
key
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_KEY
chars
.
get
(
)
)
;
}
}
static
bool
SameOrParentLocale
(
JSLinearString
*
locale
JSLinearString
*
otherLocale
)
{
if
(
locale
-
>
length
(
)
=
=
otherLocale
-
>
length
(
)
)
{
return
EqualStrings
(
locale
otherLocale
)
;
}
if
(
locale
-
>
length
(
)
<
otherLocale
-
>
length
(
)
)
{
return
HasSubstringAt
(
otherLocale
locale
0
)
&
&
otherLocale
-
>
latin1OrTwoByteChar
(
locale
-
>
length
(
)
)
=
=
'
-
'
;
}
return
false
;
}
using
SupportedLocaleKind
=
js
:
:
intl
:
:
SharedIntlData
:
:
SupportedLocaleKind
;
static
JS
:
:
Result
<
JSLinearString
*
>
BestAvailableLocale
(
JSContext
*
cx
SupportedLocaleKind
kind
HandleLinearString
locale
HandleLinearString
defaultLocale
)
{
intl
:
:
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
auto
findLast
=
[
]
(
const
auto
*
chars
size_t
length
)
{
auto
rbegin
=
std
:
:
make_reverse_iterator
(
chars
+
length
)
;
auto
rend
=
std
:
:
make_reverse_iterator
(
chars
)
;
auto
p
=
std
:
:
find
(
rbegin
rend
'
-
'
)
;
ptrdiff_t
r
=
std
:
:
distance
(
chars
p
.
base
(
)
)
;
MOZ_ASSERT
(
r
=
=
std
:
:
distance
(
p
rend
)
)
;
return
r
-
1
;
}
;
RootedLinearString
candidate
(
cx
locale
)
;
while
(
true
)
{
bool
supported
=
false
;
if
(
!
sharedIntlData
.
isSupportedLocale
(
cx
kind
candidate
&
supported
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
if
(
supported
)
{
return
candidate
.
get
(
)
;
}
if
(
defaultLocale
&
&
SameOrParentLocale
(
candidate
defaultLocale
)
)
{
return
candidate
.
get
(
)
;
}
ptrdiff_t
pos
;
if
(
candidate
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
pos
=
findLast
(
candidate
-
>
latin1Chars
(
nogc
)
candidate
-
>
length
(
)
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
pos
=
findLast
(
candidate
-
>
twoByteChars
(
nogc
)
candidate
-
>
length
(
)
)
;
}
if
(
pos
<
0
)
{
return
nullptr
;
}
size_t
length
=
size_t
(
pos
)
;
if
(
length
>
=
2
&
&
candidate
-
>
latin1OrTwoByteChar
(
length
-
2
)
=
=
'
-
'
)
{
length
-
=
2
;
}
candidate
=
NewDependentString
(
cx
candidate
0
length
)
;
if
(
!
candidate
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
}
}
bool
js
:
:
intl_BestAvailableLocale
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
3
)
;
SupportedLocaleKind
kind
;
{
JSLinearString
*
typeStr
=
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
typeStr
)
{
return
false
;
}
if
(
StringEqualsLiteral
(
typeStr
"
Collator
"
)
)
{
kind
=
SupportedLocaleKind
:
:
Collator
;
}
else
if
(
StringEqualsLiteral
(
typeStr
"
DateTimeFormat
"
)
)
{
kind
=
SupportedLocaleKind
:
:
DateTimeFormat
;
}
else
if
(
StringEqualsLiteral
(
typeStr
"
DisplayNames
"
)
)
{
kind
=
SupportedLocaleKind
:
:
DisplayNames
;
}
else
if
(
StringEqualsLiteral
(
typeStr
"
ListFormat
"
)
)
{
kind
=
SupportedLocaleKind
:
:
ListFormat
;
}
else
if
(
StringEqualsLiteral
(
typeStr
"
NumberFormat
"
)
)
{
kind
=
SupportedLocaleKind
:
:
NumberFormat
;
}
else
if
(
StringEqualsLiteral
(
typeStr
"
PluralRules
"
)
)
{
kind
=
SupportedLocaleKind
:
:
PluralRules
;
}
else
{
MOZ_ASSERT
(
StringEqualsLiteral
(
typeStr
"
RelativeTimeFormat
"
)
)
;
kind
=
SupportedLocaleKind
:
:
RelativeTimeFormat
;
}
}
RootedLinearString
locale
(
cx
args
[
1
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
locale
)
{
return
false
;
}
#
ifdef
DEBUG
{
intl
:
:
LanguageTag
tag
(
cx
)
;
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
intl
:
:
LanguageTagParser
:
:
tryParse
(
cx
locale
tag
)
)
;
MOZ_ASSERT
(
ok
"
locale
is
a
structurally
valid
language
tag
"
)
;
MOZ_ASSERT
(
!
tag
.
unicodeExtension
(
)
"
locale
must
contain
no
Unicode
extensions
"
)
;
if
(
!
tag
.
canonicalize
(
cx
)
)
{
return
false
;
}
JSString
*
tagStr
=
tag
.
toString
(
cx
)
;
if
(
!
tagStr
)
{
return
false
;
}
bool
canonical
;
if
(
!
EqualStrings
(
cx
locale
tagStr
&
canonical
)
)
{
return
false
;
}
MOZ_ASSERT
(
canonical
"
locale
is
a
canonicalized
language
tag
"
)
;
}
#
endif
MOZ_ASSERT
(
args
[
2
]
.
isNull
(
)
|
|
args
[
2
]
.
isString
(
)
)
;
RootedLinearString
defaultLocale
(
cx
)
;
if
(
args
[
2
]
.
isString
(
)
)
{
defaultLocale
=
args
[
2
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
defaultLocale
)
{
return
false
;
}
}
JSString
*
result
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
result
BestAvailableLocale
(
cx
kind
locale
defaultLocale
)
)
;
if
(
result
)
{
args
.
rval
(
)
.
setString
(
result
)
;
}
else
{
args
.
rval
(
)
.
setUndefined
(
)
;
}
return
true
;
}
bool
js
:
:
intl_supportedLocaleOrFallback
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
RootedLinearString
locale
(
cx
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
)
;
if
(
!
locale
)
{
return
false
;
}
intl
:
:
LanguageTag
tag
(
cx
)
;
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
intl
:
:
LanguageTagParser
:
:
tryParse
(
cx
locale
tag
)
)
;
RootedLinearString
candidate
(
cx
)
;
if
(
!
ok
)
{
candidate
=
NewStringCopyZ
<
CanGC
>
(
cx
intl
:
:
LastDitchLocale
(
)
)
;
if
(
!
candidate
)
{
return
false
;
}
}
else
{
if
(
!
tag
.
canonicalize
(
cx
)
)
{
return
false
;
}
tag
.
clearUnicodeExtension
(
)
;
JSString
*
canonical
=
tag
.
toString
(
cx
)
;
if
(
!
canonical
)
{
return
false
;
}
candidate
=
canonical
-
>
ensureLinear
(
cx
)
;
if
(
!
candidate
)
{
return
false
;
}
for
(
const
auto
&
mapping
:
js
:
:
intl
:
:
oldStyleLanguageTagMappings
)
{
const
char
*
oldStyle
=
mapping
.
oldStyle
;
const
char
*
modernStyle
=
mapping
.
modernStyle
;
if
(
StringEqualsAscii
(
candidate
oldStyle
)
)
{
candidate
=
NewStringCopyZ
<
CanGC
>
(
cx
modernStyle
)
;
if
(
!
candidate
)
{
return
false
;
}
break
;
}
}
}
RootedLinearString
supportedCollator
(
cx
)
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
supportedCollator
BestAvailableLocale
(
cx
SupportedLocaleKind
:
:
Collator
candidate
nullptr
)
)
;
RootedLinearString
supportedDateTimeFormat
(
cx
)
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
supportedDateTimeFormat
BestAvailableLocale
(
cx
SupportedLocaleKind
:
:
DateTimeFormat
candidate
nullptr
)
)
;
#
ifdef
DEBUG
for
(
auto
kind
:
{
SupportedLocaleKind
:
:
DisplayNames
SupportedLocaleKind
:
:
ListFormat
SupportedLocaleKind
:
:
NumberFormat
SupportedLocaleKind
:
:
PluralRules
SupportedLocaleKind
:
:
RelativeTimeFormat
}
)
{
JSLinearString
*
supported
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
supported
BestAvailableLocale
(
cx
kind
candidate
nullptr
)
)
;
MOZ_ASSERT
(
!
!
supported
=
=
!
!
supportedDateTimeFormat
)
;
MOZ_ASSERT_IF
(
supported
EqualStrings
(
supported
supportedDateTimeFormat
)
)
;
}
#
endif
if
(
supportedCollator
&
&
supportedDateTimeFormat
)
{
if
(
SameOrParentLocale
(
supportedCollator
supportedDateTimeFormat
)
)
{
candidate
=
supportedDateTimeFormat
;
}
else
{
candidate
=
supportedCollator
;
}
}
else
{
candidate
=
NewStringCopyZ
<
CanGC
>
(
cx
intl
:
:
LastDitchLocale
(
)
)
;
if
(
!
candidate
)
{
return
false
;
}
}
args
.
rval
(
)
.
setString
(
candidate
)
;
return
true
;
}
using
StringList
=
GCVector
<
JSLinearString
*
>
;
static
ArrayObject
*
CreateArrayFromList
(
JSContext
*
cx
MutableHandle
<
StringList
>
list
)
{
size_t
initialLength
=
list
.
length
(
)
;
if
(
!
list
.
growBy
(
initialLength
)
)
{
return
nullptr
;
}
MOZ_ALWAYS_TRUE
(
MergeSort
(
list
.
begin
(
)
initialLength
list
.
begin
(
)
+
initialLength
[
]
(
const
auto
*
a
const
auto
*
b
bool
*
lessOrEqual
)
{
*
lessOrEqual
=
CompareStrings
(
a
b
)
<
=
0
;
return
true
;
}
)
)
;
auto
*
end
=
std
:
:
unique
(
list
.
begin
(
)
list
.
begin
(
)
+
initialLength
[
]
(
const
auto
*
a
const
auto
*
b
)
{
return
EqualStrings
(
a
b
)
;
}
)
;
list
.
shrinkBy
(
std
:
:
distance
(
end
list
.
end
(
)
)
)
;
auto
*
array
=
NewDenseFullyAllocatedArray
(
cx
list
.
length
(
)
)
;
if
(
!
array
)
{
return
nullptr
;
}
array
-
>
setDenseInitializedLength
(
list
.
length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
list
.
length
(
)
;
+
+
i
)
{
array
-
>
initDenseElement
(
i
StringValue
(
list
[
i
]
)
)
;
}
return
array
;
}
template
<
size_t
N
>
static
ArrayObject
*
CreateArrayFromSortedList
(
JSContext
*
cx
const
std
:
:
array
<
const
char
*
N
>
&
list
)
{
#
ifdef
DEBUG
auto
isLargerThanOrEqual
=
[
]
(
const
auto
&
a
const
auto
&
b
)
{
return
std
:
:
strcmp
(
a
b
)
>
=
0
;
}
;
#
endif
MOZ_ASSERT
(
std
:
:
adjacent_find
(
std
:
:
begin
(
list
)
std
:
:
end
(
list
)
isLargerThanOrEqual
)
=
=
std
:
:
end
(
list
)
)
;
size_t
length
=
std
:
:
size
(
list
)
;
RootedArrayObject
array
(
cx
NewDenseFullyAllocatedArray
(
cx
length
)
)
;
if
(
!
array
)
{
return
nullptr
;
}
array
-
>
ensureDenseInitializedLength
(
0
length
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
auto
*
str
=
NewStringCopyZ
<
CanGC
>
(
cx
list
[
i
]
)
;
if
(
!
str
)
{
return
nullptr
;
}
array
-
>
initDenseElement
(
i
StringValue
(
str
)
)
;
}
return
array
;
}
template
<
const
auto
&
unsupported
class
Enumeration
>
static
bool
EnumerationIntoList
(
JSContext
*
cx
Enumeration
values
MutableHandle
<
StringList
>
list
)
{
for
(
auto
value
:
values
)
{
if
(
value
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
auto
span
=
value
.
unwrap
(
)
;
std
:
:
string_view
sv
(
span
.
data
(
)
span
.
size
(
)
)
;
if
(
std
:
:
any_of
(
std
:
:
begin
(
unsupported
)
std
:
:
end
(
unsupported
)
[
sv
]
(
const
auto
&
e
)
{
return
sv
=
=
e
;
}
)
)
{
continue
;
}
auto
*
string
=
NewStringCopy
<
CanGC
>
(
cx
span
)
;
if
(
!
string
)
{
return
false
;
}
if
(
!
list
.
append
(
string
)
)
{
return
false
;
}
}
return
true
;
}
template
<
const
auto
&
unsupported
const
auto
&
missing
>
static
bool
EnumerationIntoList
(
JSContext
*
cx
UEnumeration
*
values
MutableHandle
<
StringList
>
list
)
{
while
(
true
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
len
;
const
char
*
value
=
uenum_next
(
values
&
len
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
value
=
=
nullptr
)
{
break
;
}
if
(
std
:
:
any_of
(
std
:
:
begin
(
unsupported
)
std
:
:
end
(
unsupported
)
[
value
]
(
const
auto
&
e
)
{
return
std
:
:
strcmp
(
value
e
)
=
=
0
;
}
)
)
{
continue
;
}
auto
*
string
=
NewStringCopyN
<
CanGC
>
(
cx
value
size_t
(
len
)
)
;
if
(
!
string
)
{
return
false
;
}
if
(
!
list
.
append
(
string
)
)
{
return
false
;
}
}
for
(
const
char
*
value
:
missing
)
{
auto
*
string
=
NewStringCopyZ
<
CanGC
>
(
cx
value
)
;
if
(
!
string
)
{
return
false
;
}
if
(
!
list
.
append
(
string
)
)
{
return
false
;
}
}
return
true
;
}
template
<
const
auto
&
unsupported
>
static
bool
EnumerationIntoList
(
JSContext
*
cx
const
char
*
type
UEnumeration
*
values
MutableHandle
<
StringList
>
list
)
{
while
(
true
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
const
char
*
value
=
uenum_next
(
values
nullptr
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
value
=
=
nullptr
)
{
break
;
}
value
=
uloc_toUnicodeLocaleType
(
type
value
)
;
if
(
!
value
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
false
;
}
if
(
std
:
:
any_of
(
std
:
:
begin
(
unsupported
)
std
:
:
end
(
unsupported
)
[
value
]
(
const
auto
&
e
)
{
return
std
:
:
strcmp
(
value
e
)
=
=
0
;
}
)
)
{
continue
;
}
auto
*
string
=
NewStringCopyZ
<
CanGC
>
(
cx
value
)
;
if
(
!
string
)
{
return
false
;
}
if
(
!
list
.
append
(
string
)
)
{
return
false
;
}
}
return
true
;
}
static
void
CloseEnumeration
(
UEnumeration
*
ptr
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
uenum_close
(
ptr
)
;
}
static
constexpr
auto
UnsupportedCalendars
(
)
{
return
std
:
:
array
<
const
char
*
0
>
{
}
;
}
static
constexpr
auto
UnsupportedCalendarsArray
=
UnsupportedCalendars
(
)
;
static
ArrayObject
*
AvailableCalendars
(
JSContext
*
cx
)
{
Rooted
<
StringList
>
list
(
cx
StringList
(
cx
)
)
;
{
auto
keywords
=
mozilla
:
:
intl
:
:
Calendar
:
:
GetBcp47KeywordValuesForLocale
(
"
"
)
;
if
(
keywords
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
keywords
.
unwrapErr
(
)
)
;
return
nullptr
;
}
static
constexpr
auto
&
unsupported
=
UnsupportedCalendarsArray
;
if
(
!
EnumerationIntoList
<
unsupported
>
(
cx
keywords
.
unwrap
(
)
&
list
)
)
{
return
nullptr
;
}
}
return
CreateArrayFromList
(
cx
&
list
)
;
}
static
constexpr
auto
UnsupportedCollations
(
)
{
return
std
:
:
array
{
"
search
"
"
standard
"
}
;
}
static
constexpr
auto
UnsupportedCollationsArray
=
UnsupportedCollations
(
)
;
static
ArrayObject
*
AvailableCollations
(
JSContext
*
cx
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
values
=
ucol_getKeywordValues
(
"
collation
"
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ScopedICUObject
<
UEnumeration
CloseEnumeration
>
toClose
(
values
)
;
static
constexpr
auto
&
unsupported
=
UnsupportedCollationsArray
;
Rooted
<
StringList
>
list
(
cx
StringList
(
cx
)
)
;
if
(
!
EnumerationIntoList
<
unsupported
>
(
cx
"
co
"
values
&
list
)
)
{
return
nullptr
;
}
UEnumeration
*
rootValues
=
ucol_getKeywordValuesForLocale
(
"
collation
"
"
"
false
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ScopedICUObject
<
UEnumeration
CloseEnumeration
>
toCloseRoot
(
rootValues
)
;
if
(
!
EnumerationIntoList
<
unsupported
>
(
cx
"
co
"
rootValues
&
list
)
)
{
return
nullptr
;
}
return
CreateArrayFromList
(
cx
&
list
)
;
}
static
constexpr
auto
UnsupportedCurrencies
(
)
{
return
std
:
:
array
{
"
EQE
"
"
LSM
"
}
;
}
static
constexpr
auto
MissingCurrencies
(
)
{
return
std
:
:
array
{
"
UYW
"
"
VES
"
}
;
}
static
constexpr
auto
UnsupportedCurrenciesArray
=
UnsupportedCurrencies
(
)
;
static
constexpr
auto
MissingCurrenciesArray
=
MissingCurrencies
(
)
;
static
ArrayObject
*
AvailableCurrencies
(
JSContext
*
cx
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UEnumeration
*
values
=
ucurr_openISOCurrencies
(
UCURR_ALL
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
intl
:
:
ReportInternalError
(
cx
)
;
return
nullptr
;
}
ScopedICUObject
<
UEnumeration
CloseEnumeration
>
toClose
(
values
)
;
static
constexpr
auto
&
unsupported
=
UnsupportedCurrenciesArray
;
static
constexpr
auto
&
missing
=
MissingCurrenciesArray
;
Rooted
<
StringList
>
list
(
cx
StringList
(
cx
)
)
;
if
(
!
EnumerationIntoList
<
unsupported
missing
>
(
cx
values
&
list
)
)
{
return
nullptr
;
}
return
CreateArrayFromList
(
cx
&
list
)
;
}
static
ArrayObject
*
AvailableNumberingSystems
(
JSContext
*
cx
)
{
static
constexpr
std
:
:
array
numberingSystems
=
{
NUMBERING_SYSTEMS_WITH_SIMPLE_DIGIT_MAPPINGS
}
;
return
CreateArrayFromSortedList
(
cx
numberingSystems
)
;
}
static
ArrayObject
*
AvailableTimeZones
(
JSContext
*
cx
)
{
Rooted
<
StringList
>
timeZones
(
cx
StringList
(
cx
)
)
;
intl
:
:
SharedIntlData
&
sharedIntlData
=
cx
-
>
runtime
(
)
-
>
sharedIntlData
.
ref
(
)
;
auto
iterResult
=
sharedIntlData
.
availableTimeZonesIteration
(
cx
)
;
if
(
iterResult
.
isErr
(
)
)
{
return
nullptr
;
}
auto
iter
=
iterResult
.
unwrap
(
)
;
RootedAtom
validatedTimeZone
(
cx
)
;
RootedAtom
ianaTimeZone
(
cx
)
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
validatedTimeZone
=
iter
.
get
(
)
;
ianaTimeZone
.
set
(
nullptr
)
;
if
(
!
sharedIntlData
.
tryCanonicalizeTimeZoneConsistentWithIANA
(
cx
validatedTimeZone
&
ianaTimeZone
)
)
{
return
nullptr
;
}
JSLinearString
*
timeZone
;
if
(
ianaTimeZone
)
{
cx
-
>
markAtom
(
ianaTimeZone
)
;
timeZone
=
ianaTimeZone
;
}
else
{
JS
:
:
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
validatedTimeZone
)
)
{
return
nullptr
;
}
intl
:
:
FormatBuffer
<
char16_t
intl
:
:
INITIAL_CHAR_BUFFER_SIZE
>
canonicalTimeZone
(
cx
)
;
auto
result
=
mozilla
:
:
intl
:
:
Calendar
:
:
GetCanonicalTimeZoneID
(
stableChars
.
twoByteRange
(
)
canonicalTimeZone
)
;
if
(
result
.
isErr
(
)
)
{
intl
:
:
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
timeZone
=
canonicalTimeZone
.
toString
(
)
;
if
(
!
timeZone
)
{
return
nullptr
;
}
if
(
StringEqualsLiteral
(
timeZone
"
Etc
/
UTC
"
)
|
|
StringEqualsLiteral
(
timeZone
"
Etc
/
GMT
"
)
)
{
timeZone
=
cx
-
>
names
(
)
.
UTC
;
}
}
if
(
!
timeZones
.
append
(
timeZone
)
)
{
return
nullptr
;
}
}
return
CreateArrayFromList
(
cx
&
timeZones
)
;
}
template
<
size_t
N
>
constexpr
auto
MeasurementUnitNames
(
const
MeasureUnit
(
&
units
)
[
N
]
)
{
std
:
:
array
<
const
char
*
N
>
array
=
{
}
;
for
(
size_t
i
=
0
;
i
<
N
;
+
+
i
)
{
array
[
i
]
=
units
[
i
]
.
name
;
}
return
array
;
}
static
ArrayObject
*
AvailableUnits
(
JSContext
*
cx
)
{
static
constexpr
auto
simpleMeasureUnitNames
=
MeasurementUnitNames
(
simpleMeasureUnits
)
;
return
CreateArrayFromSortedList
(
cx
simpleMeasureUnitNames
)
;
}
bool
js
:
:
intl_SupportedValuesOf
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
args
[
0
]
.
isString
(
)
)
;
JSLinearString
*
key
=
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
key
)
{
return
false
;
}
ArrayObject
*
list
;
if
(
StringEqualsLiteral
(
key
"
calendar
"
)
)
{
list
=
AvailableCalendars
(
cx
)
;
}
else
if
(
StringEqualsLiteral
(
key
"
collation
"
)
)
{
list
=
AvailableCollations
(
cx
)
;
}
else
if
(
StringEqualsLiteral
(
key
"
currency
"
)
)
{
list
=
AvailableCurrencies
(
cx
)
;
}
else
if
(
StringEqualsLiteral
(
key
"
numberingSystem
"
)
)
{
list
=
AvailableNumberingSystems
(
cx
)
;
}
else
if
(
StringEqualsLiteral
(
key
"
timeZone
"
)
)
{
list
=
AvailableTimeZones
(
cx
)
;
}
else
if
(
StringEqualsLiteral
(
key
"
unit
"
)
)
{
list
=
AvailableUnits
(
cx
)
;
}
else
{
ReportBadKey
(
cx
key
)
;
return
false
;
}
if
(
!
list
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
list
)
;
return
true
;
}
static
bool
intl_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Intl
)
;
return
true
;
}
static
const
JSFunctionSpec
intl_static_methods
[
]
=
{
JS_FN
(
js_toSource_str
intl_toSource
0
0
)
JS_SELF_HOSTED_FN
(
"
getCanonicalLocales
"
"
Intl_getCanonicalLocales
"
1
0
)
JS_SELF_HOSTED_FN
(
"
supportedValuesOf
"
"
Intl_supportedValuesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
intl_static_properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Intl
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
JSObject
*
CreateIntlObject
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewTenuredObjectWithGivenProto
(
cx
&
IntlClass
proto
)
;
}
static
bool
IntlClassFinish
(
JSContext
*
cx
HandleObject
intl
HandleObject
proto
)
{
RootedId
ctorId
(
cx
)
;
RootedValue
ctorValue
(
cx
)
;
for
(
const
auto
&
protoKey
:
{
JSProto_Collator
JSProto_DateTimeFormat
JSProto_DisplayNames
JSProto_ListFormat
JSProto_Locale
JSProto_NumberFormat
JSProto_PluralRules
JSProto_RelativeTimeFormat
}
)
{
JSObject
*
ctor
=
GlobalObject
:
:
getOrCreateConstructor
(
cx
protoKey
)
;
if
(
!
ctor
)
{
return
false
;
}
ctorId
=
NameToId
(
ClassName
(
protoKey
cx
)
)
;
ctorValue
.
setObject
(
*
ctor
)
;
if
(
!
DefineDataProperty
(
cx
intl
ctorId
ctorValue
0
)
)
{
return
false
;
}
}
return
true
;
}
static
const
ClassSpec
IntlClassSpec
=
{
CreateIntlObject
nullptr
intl_static_methods
intl_static_properties
nullptr
nullptr
IntlClassFinish
}
;
const
JSClass
js
:
:
IntlClass
=
{
"
Intl
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Intl
)
JS_NULL_CLASS_OPS
&
IntlClassSpec
}
;
