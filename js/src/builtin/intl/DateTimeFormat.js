function
resolveDateTimeFormatInternals
(
lazyDateTimeFormatData
)
{
assert
(
IsObject
(
lazyDateTimeFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
DateTimeFormat
=
dateTimeFormatInternalProperties
;
var
localeData
=
DateTimeFormat
.
localeData
;
var
r
=
ResolveLocale
(
"
DateTimeFormat
"
lazyDateTimeFormatData
.
requestedLocales
lazyDateTimeFormatData
.
localeOpt
DateTimeFormat
.
relevantExtensionKeys
localeData
)
;
if
(
r
.
ca
=
=
=
"
islamic
"
)
{
ReportWarning
(
JSMSG_ISLAMIC_FALLBACK
)
;
r
.
ca
=
"
islamic
-
tbla
"
;
}
else
if
(
r
.
ca
=
=
=
"
islamic
-
rgsa
"
)
{
r
.
ca
=
"
islamic
-
tbla
"
;
}
internalProps
.
locale
=
r
.
locale
;
internalProps
.
calendar
=
r
.
ca
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
formatOptions
=
lazyDateTimeFormatData
.
formatOptions
;
if
(
r
.
hc
!
=
=
null
&
&
formatOptions
.
hour12
=
=
=
undefined
)
{
formatOptions
.
hourCycle
=
r
.
hc
;
}
internalProps
.
timeZone
=
lazyDateTimeFormatData
.
timeZone
;
if
(
lazyDateTimeFormatData
.
patternOption
!
=
=
undefined
)
{
internalProps
.
pattern
=
lazyDateTimeFormatData
.
patternOption
;
}
else
if
(
lazyDateTimeFormatData
.
dateStyle
!
=
=
undefined
|
|
lazyDateTimeFormatData
.
timeStyle
!
=
=
undefined
)
{
internalProps
.
hourCycle
=
formatOptions
.
hourCycle
;
internalProps
.
hour12
=
formatOptions
.
hour12
;
internalProps
.
dateStyle
=
lazyDateTimeFormatData
.
dateStyle
;
internalProps
.
timeStyle
=
lazyDateTimeFormatData
.
timeStyle
;
}
else
{
internalProps
.
required
=
lazyDateTimeFormatData
.
required
;
internalProps
.
defaults
=
lazyDateTimeFormatData
.
defaults
;
internalProps
.
hourCycle
=
formatOptions
.
hourCycle
;
internalProps
.
hour12
=
formatOptions
.
hour12
;
internalProps
.
weekday
=
formatOptions
.
weekday
;
internalProps
.
era
=
formatOptions
.
era
;
internalProps
.
year
=
formatOptions
.
year
;
internalProps
.
month
=
formatOptions
.
month
;
internalProps
.
day
=
formatOptions
.
day
;
internalProps
.
dayPeriod
=
formatOptions
.
dayPeriod
;
internalProps
.
hour
=
formatOptions
.
hour
;
internalProps
.
minute
=
formatOptions
.
minute
;
internalProps
.
second
=
formatOptions
.
second
;
internalProps
.
fractionalSecondDigits
=
formatOptions
.
fractionalSecondDigits
;
internalProps
.
timeZoneName
=
formatOptions
.
timeZoneName
;
}
return
internalProps
;
}
function
getDateTimeFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getDateTimeFormatInternals
called
with
non
-
object
"
)
;
assert
(
intl_GuardToDateTimeFormat
(
obj
)
!
=
=
null
"
getDateTimeFormatInternals
called
with
non
-
DateTimeFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
DateTimeFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
{
return
internalProps
;
}
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapDateTimeFormat
(
dtf
)
{
if
(
IsObject
(
dtf
)
&
&
intl_GuardToDateTimeFormat
(
dtf
)
=
=
=
null
&
&
!
intl_IsWrappedDateTimeFormat
(
dtf
)
&
&
callFunction
(
std_Object_isPrototypeOf
GetBuiltinPrototype
(
"
DateTimeFormat
"
)
dtf
)
)
{
dtf
=
dtf
[
intlFallbackSymbol
(
)
]
;
}
return
dtf
;
}
function
InitializeDateTimeFormat
(
dateTimeFormat
thisValue
locales
options
required
defaults
toLocaleStringTimeZone
mozExtensions
)
{
assert
(
IsObject
(
dateTimeFormat
)
"
InitializeDateTimeFormat
called
with
non
-
Object
"
)
;
assert
(
intl_GuardToDateTimeFormat
(
dateTimeFormat
)
!
=
=
null
"
InitializeDateTimeFormat
called
with
non
-
DateTimeFormat
"
)
;
assert
(
required
=
=
=
"
date
"
|
|
required
=
=
=
"
time
"
|
|
required
=
=
=
"
any
"
InitializeDateTimeFormat
called
with
invalid
required
value
:
{
required
}
)
;
assert
(
defaults
=
=
=
"
date
"
|
|
defaults
=
=
=
"
time
"
|
|
defaults
=
=
=
"
all
"
InitializeDateTimeFormat
called
with
invalid
defaults
value
:
{
defaults
}
)
;
assert
(
toLocaleStringTimeZone
=
=
=
undefined
|
|
typeof
toLocaleStringTimeZone
=
=
=
"
string
"
InitializeDateTimeFormat
called
with
invalid
toLocaleStringTimeZone
value
:
{
toLocaleStringTimeZone
}
)
;
var
lazyDateTimeFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyDateTimeFormatData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
{
options
=
std_Object_create
(
null
)
;
}
else
{
options
=
ToObject
(
options
)
;
}
var
localeOpt
=
NEW_RECORD
(
)
;
lazyDateTimeFormatData
.
localeOpt
=
localeOpt
;
var
localeMatcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
localeOpt
.
localeMatcher
=
localeMatcher
;
var
calendar
=
GetOption
(
options
"
calendar
"
"
string
"
undefined
undefined
)
;
if
(
calendar
!
=
=
undefined
)
{
calendar
=
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
calendar
"
calendar
"
"
ca
"
)
;
}
localeOpt
.
ca
=
calendar
;
var
numberingSystem
=
GetOption
(
options
"
numberingSystem
"
"
string
"
undefined
undefined
)
;
if
(
numberingSystem
!
=
=
undefined
)
{
numberingSystem
=
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
numberingSystem
"
numberingSystem
"
"
nu
"
)
;
}
localeOpt
.
nu
=
numberingSystem
;
var
hour12
=
GetOption
(
options
"
hour12
"
"
boolean
"
undefined
undefined
)
;
var
hourCycle
=
GetOption
(
options
"
hourCycle
"
"
string
"
[
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
undefined
)
;
if
(
hour12
!
=
=
undefined
)
{
hourCycle
=
null
;
}
localeOpt
.
hc
=
hourCycle
;
var
timeZone
=
options
.
timeZone
;
if
(
timeZone
=
=
=
undefined
)
{
if
(
toLocaleStringTimeZone
!
=
=
undefined
)
{
timeZone
=
toLocaleStringTimeZone
;
}
else
{
timeZone
=
intl_DefaultTimeZone
(
)
;
}
}
else
{
if
(
toLocaleStringTimeZone
!
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_INVALID_DATETIME_OPTION
"
timeZone
"
"
Temporal
.
ZonedDateTime
.
toLocaleString
"
)
;
}
timeZone
=
ToString
(
timeZone
)
;
timeZone
=
intl_ValidateAndCanonicalizeTimeZone
(
timeZone
)
;
}
lazyDateTimeFormatData
.
timeZone
=
timeZone
;
var
formatOptions
=
NEW_RECORD
(
)
;
lazyDateTimeFormatData
.
formatOptions
=
formatOptions
;
if
(
mozExtensions
)
{
var
pattern
=
GetOption
(
options
"
pattern
"
"
string
"
undefined
undefined
)
;
lazyDateTimeFormatData
.
patternOption
=
pattern
;
}
if
(
hour12
!
=
=
undefined
)
{
formatOptions
.
hour12
=
hour12
;
}
formatOptions
.
weekday
=
GetOption
(
options
"
weekday
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOptions
.
era
=
GetOption
(
options
"
era
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOptions
.
year
=
GetOption
(
options
"
year
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOptions
.
month
=
GetOption
(
options
"
month
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOptions
.
day
=
GetOption
(
options
"
day
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOptions
.
dayPeriod
=
GetOption
(
options
"
dayPeriod
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOptions
.
hour
=
GetOption
(
options
"
hour
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOptions
.
minute
=
GetOption
(
options
"
minute
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOptions
.
second
=
GetOption
(
options
"
second
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOptions
.
fractionalSecondDigits
=
GetNumberOption
(
options
"
fractionalSecondDigits
"
1
3
undefined
)
;
formatOptions
.
timeZoneName
=
GetOption
(
options
"
timeZoneName
"
"
string
"
[
"
short
"
"
long
"
"
shortOffset
"
"
longOffset
"
"
shortGeneric
"
"
longGeneric
"
]
undefined
)
;
var
formatMatcher
=
GetOption
(
options
"
formatMatcher
"
"
string
"
[
"
basic
"
"
best
fit
"
]
"
best
fit
"
)
;
void
formatMatcher
;
var
dateStyle
=
GetOption
(
options
"
dateStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
dateStyle
=
dateStyle
;
var
timeStyle
=
GetOption
(
options
"
timeStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
timeStyle
=
timeStyle
;
if
(
dateStyle
!
=
=
undefined
|
|
timeStyle
!
=
=
undefined
)
{
var
explicitFormatComponent
=
formatOptions
.
weekday
!
=
=
undefined
?
"
weekday
"
:
formatOptions
.
era
!
=
=
undefined
?
"
era
"
:
formatOptions
.
year
!
=
=
undefined
?
"
year
"
:
formatOptions
.
month
!
=
=
undefined
?
"
month
"
:
formatOptions
.
day
!
=
=
undefined
?
"
day
"
:
formatOptions
.
dayPeriod
!
=
=
undefined
?
"
dayPeriod
"
:
formatOptions
.
hour
!
=
=
undefined
?
"
hour
"
:
formatOptions
.
minute
!
=
=
undefined
?
"
minute
"
:
formatOptions
.
second
!
=
=
undefined
?
"
second
"
:
formatOptions
.
fractionalSecondDigits
!
=
=
undefined
?
"
fractionalSecondDigits
"
:
formatOptions
.
timeZoneName
!
=
=
undefined
?
"
timeZoneName
"
:
undefined
;
if
(
explicitFormatComponent
!
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_INVALID_DATETIME_OPTION
explicitFormatComponent
dateStyle
!
=
=
undefined
?
"
dateStyle
"
:
"
timeStyle
"
)
;
}
if
(
required
=
=
=
"
date
"
&
&
timeStyle
!
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_INVALID_DATETIME_STYLE
"
timeStyle
"
"
date
"
)
;
}
if
(
required
=
=
=
"
time
"
&
&
dateStyle
!
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_INVALID_DATETIME_STYLE
"
dateStyle
"
"
time
"
)
;
}
}
else
{
lazyDateTimeFormatData
.
required
=
required
;
lazyDateTimeFormatData
.
defaults
=
defaults
;
}
initializeIntlObject
(
dateTimeFormat
"
DateTimeFormat
"
lazyDateTimeFormatData
)
;
if
(
dateTimeFormat
!
=
=
thisValue
&
&
callFunction
(
std_Object_isPrototypeOf
GetBuiltinPrototype
(
"
DateTimeFormat
"
)
thisValue
)
)
{
DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
dateTimeFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
dateTimeFormat
;
}
var
dateTimeFormatInternalProperties
=
{
localeData
:
dateTimeFormatLocaleData
relevantExtensionKeys
:
[
"
ca
"
"
hc
"
"
nu
"
]
}
;
function
dateTimeFormatLocaleData
(
)
{
return
{
ca
:
intl_availableCalendars
nu
:
getNumberingSystems
hc
:
(
)
=
>
{
return
[
null
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
;
}
default
:
{
ca
:
intl_defaultCalendar
nu
:
intl_numberingSystem
hc
:
(
)
=
>
{
return
null
;
}
}
}
;
}
function
createDateTimeFormatFormat
(
dtf
)
{
return
function
(
date
)
{
assert
(
IsObject
(
dtf
)
"
dateTimeFormatFormatToBind
called
with
non
-
Object
"
)
;
assert
(
intl_GuardToDateTimeFormat
(
dtf
)
!
=
=
null
"
dateTimeFormatFormatToBind
called
with
non
-
DateTimeFormat
"
)
;
return
intl_FormatDateTime
(
dtf
date
false
)
;
}
;
}
function
Intl_DateTimeFormat_format_get
(
)
{
var
thisArg
=
UnwrapDateTimeFormat
(
this
)
;
var
dtf
=
thisArg
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
intl_GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallDateTimeFormatMethodIfWrapped
thisArg
"
Intl_DateTimeFormat_format_get
"
)
;
}
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
internals
.
boundFormat
=
createDateTimeFormatFormat
(
dtf
)
;
}
return
internals
.
boundFormat
;
}
SetCanonicalName
(
Intl_DateTimeFormat_format_get
"
get
format
"
)
;
function
Intl_DateTimeFormat_formatToParts
(
date
)
{
var
dtf
=
this
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
intl_GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallDateTimeFormatMethodIfWrapped
this
date
"
Intl_DateTimeFormat_formatToParts
"
)
;
}
getDateTimeFormatInternals
(
dtf
)
;
return
intl_FormatDateTime
(
dtf
date
true
)
;
}
function
Intl_DateTimeFormat_formatRange
(
startDate
endDate
)
{
var
dtf
=
this
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
intl_GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallDateTimeFormatMethodIfWrapped
this
startDate
endDate
"
Intl_DateTimeFormat_formatRange
"
)
;
}
if
(
startDate
=
=
=
undefined
|
|
endDate
=
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_UNDEFINED_DATE
startDate
=
=
=
undefined
?
"
start
"
:
"
end
"
"
formatRange
"
)
;
}
getDateTimeFormatInternals
(
dtf
)
;
return
intl_FormatDateTimeRange
(
dtf
startDate
endDate
false
)
;
}
function
Intl_DateTimeFormat_formatRangeToParts
(
startDate
endDate
)
{
var
dtf
=
this
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
intl_GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallDateTimeFormatMethodIfWrapped
this
startDate
endDate
"
Intl_DateTimeFormat_formatRangeToParts
"
)
;
}
if
(
startDate
=
=
=
undefined
|
|
endDate
=
=
=
undefined
)
{
ThrowTypeError
(
JSMSG_UNDEFINED_DATE
startDate
=
=
=
undefined
?
"
start
"
:
"
end
"
"
formatRangeToParts
"
)
;
}
getDateTimeFormatInternals
(
dtf
)
;
return
intl_FormatDateTimeRange
(
dtf
startDate
endDate
true
)
;
}
function
Intl_DateTimeFormat_resolvedOptions
(
)
{
var
thisArg
=
UnwrapDateTimeFormat
(
this
)
;
var
dtf
=
thisArg
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
intl_GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
intl_CallDateTimeFormatMethodIfWrapped
thisArg
"
Intl_DateTimeFormat_resolvedOptions
"
)
;
}
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
var
result
=
{
locale
:
internals
.
locale
calendar
:
internals
.
calendar
numberingSystem
:
internals
.
numberingSystem
timeZone
:
internals
.
timeZone
}
;
if
(
internals
.
pattern
!
=
=
undefined
)
{
DefineDataProperty
(
result
"
pattern
"
internals
.
pattern
)
;
}
var
hasDateStyle
=
internals
.
dateStyle
!
=
=
undefined
;
var
hasTimeStyle
=
internals
.
timeStyle
!
=
=
undefined
;
if
(
hasDateStyle
|
|
hasTimeStyle
)
{
if
(
hasTimeStyle
)
{
intl_resolveDateTimeFormatComponents
(
dtf
result
false
)
;
}
if
(
hasDateStyle
)
{
DefineDataProperty
(
result
"
dateStyle
"
internals
.
dateStyle
)
;
}
if
(
hasTimeStyle
)
{
DefineDataProperty
(
result
"
timeStyle
"
internals
.
timeStyle
)
;
}
}
else
{
intl_resolveDateTimeFormatComponents
(
dtf
result
true
)
;
}
return
result
;
}
