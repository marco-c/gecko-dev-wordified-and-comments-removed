function
resolveDateTimeFormatInternals
(
lazyDateTimeFormatData
)
{
assert
(
IsObject
(
lazyDateTimeFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
DateTimeFormat
=
dateTimeFormatInternalProperties
;
var
localeData
=
DateTimeFormat
.
localeData
;
var
r
=
ResolveLocale
(
"
DateTimeFormat
"
lazyDateTimeFormatData
.
requestedLocales
lazyDateTimeFormatData
.
localeOpt
DateTimeFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
calendar
=
r
.
ca
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
dataLocale
=
r
.
dataLocale
;
#
ifdef
NIGHTLY_BUILD
dataLocale
=
addUnicodeExtension
(
dataLocale
"
-
u
-
ca
-
"
+
r
.
ca
)
;
#
endif
internalProps
.
timeZone
=
lazyDateTimeFormatData
.
timeZone
;
var
formatOpt
=
lazyDateTimeFormatData
.
formatOpt
;
if
(
r
.
hc
!
=
=
null
&
&
formatOpt
.
hour12
=
=
=
undefined
)
formatOpt
.
hourCycle
=
r
.
hc
;
var
pattern
;
if
(
lazyDateTimeFormatData
.
mozExtensions
)
{
if
(
lazyDateTimeFormatData
.
patternOption
!
=
=
undefined
)
{
pattern
=
lazyDateTimeFormatData
.
patternOption
;
internalProps
.
patternOption
=
lazyDateTimeFormatData
.
patternOption
;
}
else
if
(
lazyDateTimeFormatData
.
dateStyle
|
|
lazyDateTimeFormatData
.
timeStyle
)
{
pattern
=
intl_patternForStyle
(
dataLocale
lazyDateTimeFormatData
.
dateStyle
lazyDateTimeFormatData
.
timeStyle
lazyDateTimeFormatData
.
timeZone
)
;
internalProps
.
dateStyle
=
lazyDateTimeFormatData
.
dateStyle
;
internalProps
.
timeStyle
=
lazyDateTimeFormatData
.
timeStyle
;
}
else
{
pattern
=
toBestICUPattern
(
dataLocale
formatOpt
)
;
}
internalProps
.
mozExtensions
=
true
;
}
else
{
pattern
=
toBestICUPattern
(
dataLocale
formatOpt
)
;
}
if
(
formatOpt
.
hourCycle
!
=
=
undefined
)
pattern
=
replaceHourRepresentation
(
pattern
formatOpt
.
hourCycle
)
;
internalProps
.
pattern
=
pattern
;
return
internalProps
;
}
function
replaceHourRepresentation
(
pattern
hourCycle
)
{
var
hour
;
switch
(
hourCycle
)
{
case
"
h11
"
:
hour
=
"
K
"
;
break
;
case
"
h12
"
:
hour
=
"
h
"
;
break
;
case
"
h23
"
:
hour
=
"
H
"
;
break
;
case
"
h24
"
:
hour
=
"
k
"
;
break
;
}
assert
(
hour
!
=
=
undefined
"
Unexpected
hourCycle
requested
:
"
+
hourCycle
)
;
var
resultPattern
=
"
"
;
var
inQuote
=
false
;
for
(
var
i
=
0
;
i
<
pattern
.
length
;
i
+
+
)
{
var
ch
=
pattern
[
i
]
;
if
(
ch
=
=
=
"
'
"
)
{
inQuote
=
!
inQuote
;
}
else
if
(
!
inQuote
&
&
(
ch
=
=
=
"
h
"
|
|
ch
=
=
=
"
H
"
|
|
ch
=
=
=
"
k
"
|
|
ch
=
=
=
"
K
"
)
)
{
ch
=
hour
;
}
resultPattern
+
=
ch
;
}
return
resultPattern
;
}
function
getDateTimeFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getDateTimeFormatInternals
called
with
non
-
object
"
)
;
assert
(
GuardToDateTimeFormat
(
obj
)
!
=
=
null
"
getDateTimeFormatInternals
called
with
non
-
DateTimeFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
DateTimeFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapDateTimeFormat
(
dtf
)
{
if
(
IsObject
(
dtf
)
&
&
GuardToDateTimeFormat
(
dtf
)
=
=
=
null
&
&
!
IsWrappedDateTimeFormat
(
dtf
)
&
&
dtf
instanceof
GetBuiltinConstructor
(
"
DateTimeFormat
"
)
)
{
dtf
=
dtf
[
intlFallbackSymbol
(
)
]
;
}
return
dtf
;
}
function
CanonicalizeTimeZoneName
(
timeZone
)
{
assert
(
typeof
timeZone
=
=
=
"
string
"
"
CanonicalizeTimeZoneName
"
)
;
assert
(
timeZone
!
=
=
"
Etc
/
Unknown
"
"
Invalid
time
zone
"
)
;
assert
(
timeZone
=
=
=
intl_IsValidTimeZoneName
(
timeZone
)
"
Time
zone
name
not
normalized
"
)
;
var
ianaTimeZone
=
intl_canonicalizeTimeZone
(
timeZone
)
;
assert
(
ianaTimeZone
!
=
=
"
Etc
/
Unknown
"
"
Invalid
canonical
time
zone
"
)
;
assert
(
ianaTimeZone
=
=
=
intl_IsValidTimeZoneName
(
ianaTimeZone
)
"
Unsupported
canonical
time
zone
"
)
;
if
(
ianaTimeZone
=
=
=
"
Etc
/
UTC
"
|
|
ianaTimeZone
=
=
=
"
Etc
/
GMT
"
)
{
ianaTimeZone
=
"
UTC
"
;
}
return
ianaTimeZone
;
}
var
timeZoneCache
=
{
icuDefaultTimeZone
:
undefined
defaultTimeZone
:
undefined
}
;
function
DefaultTimeZone
(
)
{
if
(
intl_isDefaultTimeZone
(
timeZoneCache
.
icuDefaultTimeZone
)
)
return
timeZoneCache
.
defaultTimeZone
;
var
icuDefaultTimeZone
=
intl_defaultTimeZone
(
)
;
var
timeZone
=
intl_IsValidTimeZoneName
(
icuDefaultTimeZone
)
;
if
(
timeZone
=
=
=
null
)
{
const
msPerHour
=
60
*
60
*
1000
;
var
offset
=
intl_defaultTimeZoneOffset
(
)
;
assert
(
offset
=
=
=
(
offset
|
0
)
"
milliseconds
offset
shouldn
'
t
be
able
to
exceed
int32_t
range
"
)
;
var
offsetHours
=
offset
/
msPerHour
offsetHoursFraction
=
offset
%
msPerHour
;
if
(
offsetHoursFraction
=
=
=
0
)
{
timeZone
=
"
Etc
/
GMT
"
+
(
offsetHours
<
0
?
"
+
"
:
"
-
"
)
+
std_Math_abs
(
offsetHours
)
;
timeZone
=
intl_IsValidTimeZoneName
(
timeZone
)
;
}
if
(
timeZone
=
=
=
null
)
timeZone
=
"
UTC
"
;
}
var
defaultTimeZone
=
CanonicalizeTimeZoneName
(
timeZone
)
;
timeZoneCache
.
defaultTimeZone
=
defaultTimeZone
;
timeZoneCache
.
icuDefaultTimeZone
=
icuDefaultTimeZone
;
return
defaultTimeZone
;
}
function
InitializeDateTimeFormat
(
dateTimeFormat
thisValue
locales
options
mozExtensions
)
{
assert
(
IsObject
(
dateTimeFormat
)
"
InitializeDateTimeFormat
called
with
non
-
Object
"
)
;
assert
(
GuardToDateTimeFormat
(
dateTimeFormat
)
!
=
=
null
"
InitializeDateTimeFormat
called
with
non
-
DateTimeFormat
"
)
;
var
lazyDateTimeFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyDateTimeFormatData
.
requestedLocales
=
requestedLocales
;
options
=
ToDateTimeOptions
(
options
"
any
"
"
date
"
)
;
var
localeOpt
=
new
Record
(
)
;
lazyDateTimeFormatData
.
localeOpt
=
localeOpt
;
var
localeMatcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
localeOpt
.
localeMatcher
=
localeMatcher
;
#
ifdef
NIGHTLY_BUILD
var
calendar
=
GetOption
(
options
"
calendar
"
"
string
"
undefined
undefined
)
;
if
(
calendar
!
=
=
undefined
)
{
calendar
=
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
calendar
"
calendar
"
)
;
}
localeOpt
.
ca
=
calendar
;
var
numberingSystem
=
GetOption
(
options
"
numberingSystem
"
"
string
"
undefined
undefined
)
;
if
(
numberingSystem
!
=
=
undefined
)
{
numberingSystem
=
intl_ValidateAndCanonicalizeUnicodeExtensionType
(
numberingSystem
"
numberingSystem
"
)
;
}
localeOpt
.
nu
=
numberingSystem
;
#
endif
var
hr12
=
GetOption
(
options
"
hour12
"
"
boolean
"
undefined
undefined
)
;
var
hc
=
GetOption
(
options
"
hourCycle
"
"
string
"
[
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
undefined
)
;
if
(
hr12
!
=
=
undefined
)
{
hc
=
null
;
}
localeOpt
.
hc
=
hc
;
var
tz
=
options
.
timeZone
;
if
(
tz
!
=
=
undefined
)
{
tz
=
ToString
(
tz
)
;
var
timeZone
=
intl_IsValidTimeZoneName
(
tz
)
;
if
(
timeZone
=
=
=
null
)
ThrowRangeError
(
JSMSG_INVALID_TIME_ZONE
tz
)
;
tz
=
CanonicalizeTimeZoneName
(
timeZone
)
;
}
else
{
tz
=
DefaultTimeZone
(
)
;
}
lazyDateTimeFormatData
.
timeZone
=
tz
;
var
formatOpt
=
new
Record
(
)
;
lazyDateTimeFormatData
.
formatOpt
=
formatOpt
;
lazyDateTimeFormatData
.
mozExtensions
=
mozExtensions
;
if
(
mozExtensions
)
{
let
pattern
=
GetOption
(
options
"
pattern
"
"
string
"
undefined
undefined
)
;
lazyDateTimeFormatData
.
patternOption
=
pattern
;
let
dateStyle
=
GetOption
(
options
"
dateStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
dateStyle
=
dateStyle
;
let
timeStyle
=
GetOption
(
options
"
timeStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
timeStyle
=
timeStyle
;
}
formatOpt
.
weekday
=
GetOption
(
options
"
weekday
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
era
=
GetOption
(
options
"
era
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
year
=
GetOption
(
options
"
year
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
month
=
GetOption
(
options
"
month
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
day
=
GetOption
(
options
"
day
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
hour
=
GetOption
(
options
"
hour
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
minute
=
GetOption
(
options
"
minute
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
second
=
GetOption
(
options
"
second
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
timeZoneName
=
GetOption
(
options
"
timeZoneName
"
"
string
"
[
"
short
"
"
long
"
]
undefined
)
;
#
ifdef
NIGHTLY_BUILD
formatOpt
.
fractionalSecondDigits
=
GetNumberOption
(
options
"
fractionalSecondDigits
"
0
3
0
)
;
#
endif
var
formatMatcher
=
GetOption
(
options
"
formatMatcher
"
"
string
"
[
"
basic
"
"
best
fit
"
]
"
best
fit
"
)
;
void
formatMatcher
;
if
(
hr12
!
=
=
undefined
)
formatOpt
.
hour12
=
hr12
;
initializeIntlObject
(
dateTimeFormat
"
DateTimeFormat
"
lazyDateTimeFormatData
)
;
if
(
dateTimeFormat
!
=
=
thisValue
&
&
IsObject
(
thisValue
)
&
&
thisValue
instanceof
GetBuiltinConstructor
(
"
DateTimeFormat
"
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
dateTimeFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
dateTimeFormat
;
}
function
toBestICUPattern
(
locale
options
)
{
var
skeleton
=
"
"
;
switch
(
options
.
weekday
)
{
case
"
narrow
"
:
skeleton
+
=
"
EEEEE
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
E
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
EEEE
"
;
}
switch
(
options
.
era
)
{
case
"
narrow
"
:
skeleton
+
=
"
GGGGG
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
G
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
GGGG
"
;
break
;
}
switch
(
options
.
year
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
yy
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
y
"
;
break
;
}
switch
(
options
.
month
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
MM
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
M
"
;
break
;
case
"
narrow
"
:
skeleton
+
=
"
MMMMM
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
MMM
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
MMMM
"
;
break
;
}
switch
(
options
.
day
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
dd
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
d
"
;
break
;
}
var
hourSkeletonChar
=
"
j
"
;
if
(
options
.
hour12
!
=
=
undefined
)
{
if
(
options
.
hour12
)
hourSkeletonChar
=
"
h
"
;
else
hourSkeletonChar
=
"
H
"
;
}
else
{
switch
(
options
.
hourCycle
)
{
case
"
h11
"
:
case
"
h12
"
:
hourSkeletonChar
=
"
h
"
;
break
;
case
"
h23
"
:
case
"
h24
"
:
hourSkeletonChar
=
"
H
"
;
break
;
}
}
switch
(
options
.
hour
)
{
case
"
2
-
digit
"
:
skeleton
+
=
hourSkeletonChar
+
hourSkeletonChar
;
break
;
case
"
numeric
"
:
skeleton
+
=
hourSkeletonChar
;
break
;
}
switch
(
options
.
minute
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
mm
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
m
"
;
break
;
}
switch
(
options
.
second
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
ss
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
s
"
;
break
;
}
#
ifdef
NIGHTLY_BUILD
switch
(
options
.
fractionalSecondDigits
)
{
case
1
:
skeleton
+
=
"
S
"
;
break
;
case
2
:
skeleton
+
=
"
SS
"
;
break
;
case
3
:
skeleton
+
=
"
SSS
"
;
break
;
}
#
endif
switch
(
options
.
timeZoneName
)
{
case
"
short
"
:
skeleton
+
=
"
z
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
zzzz
"
;
break
;
}
return
intl_patternForSkeleton
(
locale
skeleton
)
;
}
function
ToDateTimeOptions
(
options
required
defaults
)
{
assert
(
typeof
required
=
=
=
"
string
"
"
ToDateTimeOptions
"
)
;
assert
(
typeof
defaults
=
=
=
"
string
"
"
ToDateTimeOptions
"
)
;
if
(
options
=
=
=
undefined
)
options
=
null
;
else
options
=
ToObject
(
options
)
;
options
=
std_Object_create
(
options
)
;
var
needDefaults
=
true
;
if
(
required
=
=
=
"
date
"
|
|
required
=
=
=
"
any
"
)
{
if
(
options
.
weekday
!
=
=
undefined
)
needDefaults
=
false
;
if
(
options
.
year
!
=
=
undefined
)
needDefaults
=
false
;
if
(
options
.
month
!
=
=
undefined
)
needDefaults
=
false
;
if
(
options
.
day
!
=
=
undefined
)
needDefaults
=
false
;
}
if
(
required
=
=
=
"
time
"
|
|
required
=
=
=
"
any
"
)
{
if
(
options
.
hour
!
=
=
undefined
)
needDefaults
=
false
;
if
(
options
.
minute
!
=
=
undefined
)
needDefaults
=
false
;
if
(
options
.
second
!
=
=
undefined
)
needDefaults
=
false
;
#
ifdef
NIGHTLY_BUILD
if
(
options
.
fractionalSecondDigits
!
=
=
undefined
)
needDefaults
=
false
;
#
endif
}
if
(
needDefaults
&
&
(
defaults
=
=
=
"
date
"
|
|
defaults
=
=
=
"
all
"
)
)
{
_DefineDataProperty
(
options
"
year
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
month
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
day
"
"
numeric
"
)
;
}
if
(
needDefaults
&
&
(
defaults
=
=
=
"
time
"
|
|
defaults
=
=
=
"
all
"
)
)
{
_DefineDataProperty
(
options
"
hour
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
minute
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
second
"
"
numeric
"
)
;
}
return
options
;
}
function
Intl_DateTimeFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
"
DateTimeFormat
"
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
var
dateTimeFormatInternalProperties
=
{
localeData
:
dateTimeFormatLocaleData
relevantExtensionKeys
:
[
"
ca
"
"
hc
"
"
nu
"
]
}
;
function
dateTimeFormatLocaleData
(
)
{
return
{
ca
:
intl_availableCalendars
nu
:
getNumberingSystems
hc
:
(
)
=
>
{
return
[
null
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
;
}
default
:
{
ca
:
intl_defaultCalendar
nu
:
intl_numberingSystem
hc
:
(
)
=
>
{
return
null
;
}
}
}
;
}
function
createDateTimeFormatFormat
(
dtf
)
{
return
function
(
date
)
{
assert
(
IsObject
(
dtf
)
"
dateTimeFormatFormatToBind
called
with
non
-
Object
"
)
;
assert
(
GuardToDateTimeFormat
(
dtf
)
!
=
=
null
"
dateTimeFormatFormatToBind
called
with
non
-
DateTimeFormat
"
)
;
var
x
=
(
date
=
=
=
undefined
)
?
std_Date_now
(
)
:
ToNumber
(
date
)
;
return
intl_FormatDateTime
(
dtf
x
false
)
;
}
;
}
function
Intl_DateTimeFormat_format_get
(
)
{
var
thisArg
=
UnwrapDateTimeFormat
(
this
)
;
var
dtf
=
thisArg
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
CallDateTimeFormatMethodIfWrapped
thisArg
"
Intl_DateTimeFormat_format_get
"
)
;
}
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
internals
.
boundFormat
=
createDateTimeFormatFormat
(
dtf
)
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_DateTimeFormat_format_get
"
get
format
"
)
;
function
Intl_DateTimeFormat_formatToParts
(
date
)
{
var
dtf
=
this
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
CallDateTimeFormatMethodIfWrapped
this
date
"
Intl_DateTimeFormat_formatToParts
"
)
;
}
getDateTimeFormatInternals
(
dtf
)
;
var
x
=
(
date
=
=
=
undefined
)
?
std_Date_now
(
)
:
ToNumber
(
date
)
;
return
intl_FormatDateTime
(
dtf
x
true
)
;
}
function
Intl_DateTimeFormat_resolvedOptions
(
)
{
var
thisArg
=
UnwrapDateTimeFormat
(
this
)
;
var
dtf
=
thisArg
;
if
(
!
IsObject
(
dtf
)
|
|
(
dtf
=
GuardToDateTimeFormat
(
dtf
)
)
=
=
=
null
)
{
return
callFunction
(
CallDateTimeFormatMethodIfWrapped
thisArg
"
Intl_DateTimeFormat_resolvedOptions
"
)
;
}
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
var
result
=
{
locale
:
internals
.
locale
calendar
:
internals
.
calendar
numberingSystem
:
internals
.
numberingSystem
timeZone
:
internals
.
timeZone
}
;
if
(
internals
.
mozExtensions
)
{
if
(
internals
.
patternOption
!
=
=
undefined
)
{
_DefineDataProperty
(
result
"
pattern
"
internals
.
pattern
)
;
}
else
if
(
internals
.
dateStyle
|
|
internals
.
timeStyle
)
{
_DefineDataProperty
(
result
"
dateStyle
"
internals
.
dateStyle
)
;
_DefineDataProperty
(
result
"
timeStyle
"
internals
.
timeStyle
)
;
}
}
resolveICUPattern
(
internals
.
pattern
result
)
;
return
result
;
}
function
resolveICUPattern
(
pattern
result
)
{
assert
(
IsObject
(
result
)
"
resolveICUPattern
"
)
;
var
hourCycle
weekday
era
year
month
day
hour
minute
second
fractionalSecondDigits
timeZoneName
;
var
i
=
0
;
while
(
i
<
pattern
.
length
)
{
var
c
=
pattern
[
i
+
+
]
;
if
(
c
=
=
=
"
'
"
)
{
while
(
i
<
pattern
.
length
&
&
pattern
[
i
]
!
=
=
"
'
"
)
i
+
+
;
i
+
+
;
}
else
{
var
count
=
1
;
while
(
i
<
pattern
.
length
&
&
pattern
[
i
]
=
=
=
c
)
{
i
+
+
;
count
+
+
;
}
var
value
;
switch
(
c
)
{
case
"
G
"
:
case
"
E
"
:
case
"
c
"
:
case
"
z
"
:
case
"
v
"
:
case
"
V
"
:
if
(
count
<
=
3
)
value
=
"
short
"
;
else
if
(
count
=
=
=
4
)
value
=
"
long
"
;
else
value
=
"
narrow
"
;
break
;
case
"
y
"
:
case
"
d
"
:
case
"
h
"
:
case
"
H
"
:
case
"
m
"
:
case
"
s
"
:
case
"
k
"
:
case
"
K
"
:
if
(
count
=
=
=
2
)
value
=
"
2
-
digit
"
;
else
value
=
"
numeric
"
;
break
;
case
"
M
"
:
case
"
L
"
:
if
(
count
=
=
=
1
)
value
=
"
numeric
"
;
else
if
(
count
=
=
=
2
)
value
=
"
2
-
digit
"
;
else
if
(
count
=
=
=
3
)
value
=
"
short
"
;
else
if
(
count
=
=
=
4
)
value
=
"
long
"
;
else
value
=
"
narrow
"
;
break
;
case
"
S
"
:
value
=
count
;
break
;
default
:
}
switch
(
c
)
{
case
"
E
"
:
case
"
c
"
:
weekday
=
value
;
break
;
case
"
G
"
:
era
=
value
;
break
;
case
"
y
"
:
year
=
value
;
break
;
case
"
M
"
:
case
"
L
"
:
month
=
value
;
break
;
case
"
d
"
:
day
=
value
;
break
;
case
"
h
"
:
hourCycle
=
"
h12
"
;
hour
=
value
;
break
;
case
"
H
"
:
hourCycle
=
"
h23
"
;
hour
=
value
;
break
;
case
"
k
"
:
hourCycle
=
"
h24
"
;
hour
=
value
;
break
;
case
"
K
"
:
hourCycle
=
"
h11
"
;
hour
=
value
;
break
;
case
"
m
"
:
minute
=
value
;
break
;
case
"
s
"
:
second
=
value
;
break
;
case
"
S
"
:
fractionalSecondDigits
=
value
;
break
;
case
"
z
"
:
case
"
v
"
:
case
"
V
"
:
timeZoneName
=
value
;
break
;
}
}
}
if
(
hourCycle
)
{
_DefineDataProperty
(
result
"
hourCycle
"
hourCycle
)
;
_DefineDataProperty
(
result
"
hour12
"
hourCycle
=
=
=
"
h11
"
|
|
hourCycle
=
=
=
"
h12
"
)
;
}
if
(
weekday
)
{
_DefineDataProperty
(
result
"
weekday
"
weekday
)
;
}
if
(
era
)
{
_DefineDataProperty
(
result
"
era
"
era
)
;
}
if
(
year
)
{
_DefineDataProperty
(
result
"
year
"
year
)
;
}
if
(
month
)
{
_DefineDataProperty
(
result
"
month
"
month
)
;
}
if
(
day
)
{
_DefineDataProperty
(
result
"
day
"
day
)
;
}
if
(
hour
)
{
_DefineDataProperty
(
result
"
hour
"
hour
)
;
}
if
(
minute
)
{
_DefineDataProperty
(
result
"
minute
"
minute
)
;
}
if
(
second
)
{
_DefineDataProperty
(
result
"
second
"
second
)
;
}
#
ifdef
NIGHTLY_BUILD
if
(
fractionalSecondDigits
)
{
_DefineDataProperty
(
result
"
fractionalSecondDigits
"
fractionalSecondDigits
)
;
}
#
endif
if
(
timeZoneName
)
{
_DefineDataProperty
(
result
"
timeZoneName
"
timeZoneName
)
;
}
}
