#
ifndef
builtin_intl_CommonFunctions_h
#
define
builtin_intl_CommonFunctions_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
vm
/
StringType
.
h
"
struct
UFormattedValue
;
namespace
mozilla
:
:
intl
{
enum
class
ICUError
:
uint8_t
;
}
namespace
js
{
namespace
intl
{
extern
bool
InitializeObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
PropertyName
*
>
initializer
JS
:
:
Handle
<
JS
:
:
Value
>
locales
JS
:
:
Handle
<
JS
:
:
Value
>
options
)
;
enum
class
DateTimeFormatOptions
{
Standard
EnableMozExtensions
}
;
extern
bool
LegacyInitializeObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
PropertyName
*
>
initializer
JS
:
:
Handle
<
JS
:
:
Value
>
thisValue
JS
:
:
Handle
<
JS
:
:
Value
>
locales
JS
:
:
Handle
<
JS
:
:
Value
>
options
DateTimeFormatOptions
dtfOptions
JS
:
:
MutableHandle
<
JS
:
:
Value
>
result
)
;
extern
JSObject
*
GetInternalsObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
;
extern
void
ReportInternalError
(
JSContext
*
cx
)
;
extern
void
ReportInternalError
(
JSContext
*
cx
mozilla
:
:
intl
:
:
ICUError
error
)
;
static
inline
bool
StringsAreEqual
(
const
char
*
s1
const
char
*
s2
)
{
return
!
strcmp
(
s1
s2
)
;
}
static
inline
const
char
*
LastDitchLocale
(
)
{
return
"
en
-
GB
"
;
}
struct
OldStyleLanguageTagMapping
{
const
char
*
const
oldStyle
;
const
char
*
const
modernStyle
;
constexpr
OldStyleLanguageTagMapping
(
const
char
*
oldStyle
const
char
*
modernStyle
)
:
oldStyle
(
oldStyle
)
modernStyle
(
modernStyle
)
{
}
}
;
extern
const
OldStyleLanguageTagMapping
oldStyleLanguageTagMappings
[
5
]
;
static
inline
const
char
*
IcuLocale
(
const
char
*
locale
)
{
if
(
StringsAreEqual
(
locale
"
und
"
)
)
{
return
"
"
;
}
return
locale
;
}
extern
UniqueChars
EncodeLocale
(
JSContext
*
cx
JSString
*
locale
)
;
static_assert
(
std
:
:
is_same_v
<
UChar
char16_t
>
"
SpiderMonkey
doesn
'
t
support
redefining
UChar
to
a
different
type
"
)
;
constexpr
size_t
INITIAL_CHAR_BUFFER_SIZE
=
32
;
template
<
typename
ICUStringFunction
typename
CharT
size_t
InlineCapacity
>
static
int32_t
CallICU
(
JSContext
*
cx
const
ICUStringFunction
&
strFn
Vector
<
CharT
InlineCapacity
>
&
chars
)
{
MOZ_ASSERT
(
chars
.
length
(
)
>
=
InlineCapacity
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
size
=
strFn
(
chars
.
begin
(
)
chars
.
length
(
)
&
status
)
;
if
(
status
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
MOZ_ASSERT
(
size
>
=
0
)
;
size
+
+
;
if
(
!
chars
.
resize
(
size_t
(
size
)
)
)
{
return
-
1
;
}
status
=
U_ZERO_ERROR
;
size
=
strFn
(
chars
.
begin
(
)
size
&
status
)
;
MOZ_ASSERT
(
status
!
=
U_STRING_NOT_TERMINATED_WARNING
)
;
}
if
(
U_FAILURE
(
status
)
)
{
ReportInternalError
(
cx
)
;
return
-
1
;
}
MOZ_ASSERT
(
size
>
=
0
)
;
return
size
;
}
template
<
typename
ICUStringFunction
>
static
JSString
*
CallICU
(
JSContext
*
cx
const
ICUStringFunction
&
strFn
)
{
Vector
<
char16_t
INITIAL_CHAR_BUFFER_SIZE
>
chars
(
cx
)
;
MOZ_ALWAYS_TRUE
(
chars
.
resize
(
INITIAL_CHAR_BUFFER_SIZE
)
)
;
int32_t
size
=
CallICU
(
cx
strFn
chars
)
;
if
(
size
<
0
)
{
return
nullptr
;
}
return
NewStringCopyN
<
CanGC
>
(
cx
chars
.
begin
(
)
size_t
(
size
)
)
;
}
void
AddICUCellMemory
(
JSObject
*
obj
size_t
nbytes
)
;
void
RemoveICUCellMemory
(
JSFreeOp
*
fop
JSObject
*
obj
size_t
nbytes
)
;
JSString
*
FormattedValueToString
(
JSContext
*
cx
const
UFormattedValue
*
formattedValue
)
;
}
}
#
endif
