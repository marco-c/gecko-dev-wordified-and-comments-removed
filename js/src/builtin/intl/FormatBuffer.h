#
ifndef
builtin_intl_FormatBuffer_h
#
define
builtin_intl_FormatBuffer_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gc
/
Allocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
:
:
intl
{
template
<
typename
CharT
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
TempAllocPolicy
>
class
FormatBuffer
{
public
:
using
CharType
=
CharT
;
FormatBuffer
(
FormatBuffer
&
&
other
)
noexcept
=
default
;
FormatBuffer
&
operator
=
(
FormatBuffer
&
&
other
)
noexcept
=
default
;
explicit
FormatBuffer
(
AllocPolicy
aP
=
AllocPolicy
(
)
)
:
buffer_
(
std
:
:
move
(
aP
)
)
{
}
operator
mozilla
:
:
Span
<
CharType
>
(
)
{
return
buffer_
;
}
operator
mozilla
:
:
Span
<
const
CharType
>
(
)
const
{
return
buffer_
;
}
[
[
nodiscard
]
]
bool
reserve
(
size_t
size
)
{
return
buffer_
.
reserve
(
size
)
;
}
CharType
*
data
(
)
{
return
buffer_
.
begin
(
)
;
}
size_t
length
(
)
const
{
return
buffer_
.
length
(
)
;
}
size_t
capacity
(
)
const
{
return
buffer_
.
capacity
(
)
;
}
void
written
(
size_t
amount
)
{
MOZ_ASSERT
(
amount
<
=
buffer_
.
capacity
(
)
)
;
mozilla
:
:
DebugOnly
<
bool
>
result
=
buffer_
.
resizeUninitialized
(
amount
)
;
MOZ_ASSERT
(
result
)
;
}
JSLinearString
*
toString
(
JSContext
*
cx
)
const
{
if
constexpr
(
std
:
:
is_same_v
<
CharT
uint8_t
>
|
|
std
:
:
is_same_v
<
CharT
unsigned
char
>
|
|
std
:
:
is_same_v
<
CharT
char
>
)
{
return
NewStringCopyUTF8N
<
CanGC
>
(
cx
mozilla
:
:
Range
(
reinterpret_cast
<
unsigned
char
>
(
buffer_
.
begin
(
)
)
buffer_
.
length
(
)
)
)
;
}
else
{
static_assert
(
std
:
:
is_same_v
<
CharT
char16_t
>
)
;
return
NewStringCopyN
<
CanGC
>
(
cx
buffer_
.
begin
(
)
buffer_
.
length
(
)
)
;
}
}
UniquePtr
<
CharType
[
]
JS
:
:
FreePolicy
>
extractStringZ
(
)
{
MOZ_ASSERT_IF
(
!
buffer_
.
empty
(
)
buffer_
.
end
(
)
[
-
1
]
!
=
'
\
0
'
)
;
if
(
!
buffer_
.
append
(
'
\
0
'
)
)
{
return
nullptr
;
}
return
UniquePtr
<
CharType
[
]
JS
:
:
FreePolicy
>
(
buffer_
.
extractOrCopyRawBuffer
(
)
)
;
}
private
:
js
:
:
Vector
<
CharT
MinInlineCapacity
AllocPolicy
>
buffer_
;
}
;
}
#
endif
