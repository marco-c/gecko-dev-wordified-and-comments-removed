#
ifndef
builtin_intl_FormatBuffer_h
#
define
builtin_intl_FormatBuffer_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gc
/
Allocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
:
:
intl
{
template
<
typename
CharT
size_t
MinInlineCapacity
=
0
>
class
FormatBuffer
{
public
:
using
CharType
=
CharT
;
FormatBuffer
(
FormatBuffer
&
&
other
)
noexcept
=
default
;
FormatBuffer
&
operator
=
(
FormatBuffer
&
&
other
)
noexcept
=
default
;
explicit
FormatBuffer
(
JSContext
*
cx
)
:
cx_
(
cx
)
buffer_
(
cx
)
{
MOZ_ASSERT
(
cx
)
;
}
[
[
nodiscard
]
]
bool
reserve
(
const
size_t
size
)
{
return
buffer_
.
reserve
(
size
)
;
}
CharType
*
data
(
)
{
return
buffer_
.
begin
(
)
;
}
size_t
length
(
)
const
{
return
buffer_
.
length
(
)
;
}
size_t
capacity
(
)
const
{
return
buffer_
.
capacity
(
)
;
}
void
written
(
size_t
amount
)
{
MOZ_ASSERT
(
amount
<
=
buffer_
.
capacity
(
)
)
;
mozilla
:
:
DebugOnly
<
bool
>
result
=
buffer_
.
resizeUninitialized
(
amount
)
;
MOZ_ASSERT
(
result
)
;
}
JSString
*
toString
(
)
const
{
if
constexpr
(
std
:
:
is_same_v
<
CharT
uint8_t
>
|
|
std
:
:
is_same_v
<
CharT
unsigned
char
>
|
|
std
:
:
is_same_v
<
CharT
char
>
)
{
return
NewStringCopyUTF8N
<
CanGC
>
(
cx_
mozilla
:
:
Range
(
reinterpret_cast
<
unsigned
char
>
(
buffer_
.
begin
(
)
)
buffer_
.
length
(
)
)
)
;
}
else
{
static_assert
(
std
:
:
is_same_v
<
CharT
char16_t
>
)
;
return
NewStringCopyN
<
CanGC
>
(
cx_
buffer_
.
begin
(
)
buffer_
.
length
(
)
)
;
}
}
private
:
JSContext
*
cx_
;
js
:
:
Vector
<
CharT
MinInlineCapacity
>
buffer_
;
}
;
}
#
endif
