#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
namespace
intl
{
using
namespace
js
:
:
intl
:
:
LanguageTagLimits
;
using
ConstCharRange
=
mozilla
:
:
Range
<
const
char
>
;
#
ifdef
DEBUG
template
<
typename
CharT
>
bool
IsStructurallyValidLanguageTag
(
const
mozilla
:
:
Range
<
const
CharT
>
&
language
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
size_t
length
=
language
.
length
(
)
;
const
CharT
*
str
=
language
.
begin
(
)
.
get
(
)
;
return
(
(
2
<
=
length
&
&
length
<
=
3
)
|
|
(
5
<
=
length
&
&
length
<
=
8
)
)
&
&
std
:
:
all_of
(
str
str
+
length
mozilla
:
:
IsAsciiLowercaseAlpha
<
CharT
>
)
;
}
template
bool
IsStructurallyValidLanguageTag
(
const
mozilla
:
:
Range
<
const
Latin1Char
>
&
language
)
;
template
bool
IsStructurallyValidLanguageTag
(
const
mozilla
:
:
Range
<
const
char16_t
>
&
language
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidScriptTag
(
const
mozilla
:
:
Range
<
const
CharT
>
&
script
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
size_t
length
=
script
.
length
(
)
;
const
CharT
*
str
=
script
.
begin
(
)
.
get
(
)
;
return
length
=
=
4
&
&
mozilla
:
:
IsAsciiUppercaseAlpha
<
CharT
>
(
str
[
0
]
)
&
&
std
:
:
all_of
(
str
+
1
str
+
length
mozilla
:
:
IsAsciiLowercaseAlpha
<
CharT
>
)
;
}
template
bool
IsStructurallyValidScriptTag
(
const
mozilla
:
:
Range
<
const
Latin1Char
>
&
script
)
;
template
bool
IsStructurallyValidScriptTag
(
const
mozilla
:
:
Range
<
const
char16_t
>
&
script
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidRegionTag
(
const
mozilla
:
:
Range
<
const
CharT
>
&
region
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
size_t
length
=
region
.
length
(
)
;
const
CharT
*
str
=
region
.
begin
(
)
.
get
(
)
;
return
(
length
=
=
2
&
&
std
:
:
all_of
(
str
str
+
length
mozilla
:
:
IsAsciiUppercaseAlpha
<
CharT
>
)
)
|
|
(
length
=
=
3
&
&
std
:
:
all_of
(
str
str
+
length
mozilla
:
:
IsAsciiDigit
<
CharT
>
)
)
;
}
template
bool
IsStructurallyValidRegionTag
(
const
mozilla
:
:
Range
<
const
Latin1Char
>
&
region
)
;
template
bool
IsStructurallyValidRegionTag
(
const
mozilla
:
:
Range
<
const
char16_t
>
&
region
)
;
bool
IsStructurallyValidVariantTag
(
const
ConstCharRange
&
variant
)
{
auto
isAsciiLowercaseAlphanumeric
=
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
|
|
mozilla
:
:
IsAsciiDigit
(
c
)
;
}
;
size_t
length
=
variant
.
length
(
)
;
const
char
*
str
=
variant
.
begin
(
)
.
get
(
)
;
return
(
(
5
<
=
length
&
&
length
<
=
8
)
|
|
(
length
=
=
4
&
&
mozilla
:
:
IsAsciiDigit
(
str
[
0
]
)
)
)
&
&
std
:
:
all_of
(
str
str
+
length
isAsciiLowercaseAlphanumeric
)
;
}
bool
IsStructurallyValidUnicodeExtensionTag
(
const
ConstCharRange
&
extension
)
{
auto
isAsciiLowercaseAlphanumericOrDash
=
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
|
|
mozilla
:
:
IsAsciiDigit
(
c
)
|
|
c
=
=
'
-
'
;
}
;
size_t
length
=
extension
.
length
(
)
;
const
char
*
str
=
extension
.
begin
(
)
.
get
(
)
;
return
LanguageTagParser
:
:
canParseUnicodeExtension
(
extension
)
&
&
std
:
:
all_of
(
str
str
+
length
isAsciiLowercaseAlphanumericOrDash
)
;
}
static
bool
IsStructurallyValidExtensionTag
(
const
ConstCharRange
&
extension
)
{
auto
isAsciiDigitOrLowercaseAlpha
=
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiDigit
(
c
)
|
|
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
;
}
;
size_t
length
=
extension
.
length
(
)
;
const
char
*
str
=
extension
.
begin
(
)
.
get
(
)
;
if
(
length
<
=
2
)
{
return
false
;
}
if
(
!
isAsciiDigitOrLowercaseAlpha
(
str
[
0
]
)
|
|
str
[
0
]
=
=
'
x
'
)
{
return
false
;
}
str
+
+
;
if
(
*
str
+
+
!
=
'
-
'
)
{
return
false
;
}
while
(
true
)
{
const
char
*
sep
=
reinterpret_cast
<
const
char
*
>
(
memchr
(
str
'
-
'
extension
.
end
(
)
.
get
(
)
-
str
)
)
;
size_t
len
=
(
sep
?
sep
:
extension
.
end
(
)
.
get
(
)
)
-
str
;
if
(
len
<
2
|
|
len
>
8
|
|
!
std
:
:
all_of
(
str
str
+
len
isAsciiDigitOrLowercaseAlpha
)
)
{
return
false
;
}
if
(
!
sep
)
{
return
true
;
}
str
=
sep
+
1
;
}
}
bool
IsStructurallyValidPrivateUseTag
(
const
ConstCharRange
&
privateUse
)
{
auto
isAsciiDigitOrLowercaseAlpha
=
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiDigit
(
c
)
|
|
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
;
}
;
size_t
length
=
privateUse
.
length
(
)
;
const
char
*
str
=
privateUse
.
begin
(
)
.
get
(
)
;
if
(
length
<
=
2
|
|
*
str
+
+
!
=
'
x
'
|
|
*
str
+
+
!
=
'
-
'
)
{
return
false
;
}
while
(
true
)
{
const
char
*
sep
=
reinterpret_cast
<
const
char
*
>
(
memchr
(
str
'
-
'
privateUse
.
end
(
)
.
get
(
)
-
str
)
)
;
size_t
len
=
(
sep
?
sep
:
privateUse
.
end
(
)
.
get
(
)
)
-
str
;
if
(
len
=
=
0
|
|
len
>
8
|
|
!
std
:
:
all_of
(
str
str
+
len
isAsciiDigitOrLowercaseAlpha
)
)
{
return
false
;
}
if
(
!
sep
)
{
return
true
;
}
str
=
sep
+
1
;
}
}
#
endif
ptrdiff_t
LanguageTag
:
:
unicodeExtensionIndex
(
)
const
{
auto
p
=
std
:
:
find_if
(
extensions
(
)
.
begin
(
)
extensions
(
)
.
end
(
)
[
]
(
const
auto
&
ext
)
{
return
ext
[
0
]
=
=
'
u
'
|
|
ext
[
0
]
=
=
'
U
'
;
}
)
;
if
(
p
!
=
extensions
(
)
.
end
(
)
)
{
return
std
:
:
distance
(
extensions
(
)
.
begin
(
)
p
)
;
}
return
-
1
;
}
const
char
*
LanguageTag
:
:
unicodeExtension
(
)
const
{
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
return
extensions
(
)
[
index
]
.
get
(
)
;
}
return
nullptr
;
}
bool
LanguageTag
:
:
setUnicodeExtension
(
UniqueChars
extension
)
{
MOZ_ASSERT
(
IsStructurallyValidUnicodeExtensionTag
(
{
extension
.
get
(
)
strlen
(
extension
.
get
(
)
)
}
)
)
;
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
extensions_
[
index
]
=
std
:
:
move
(
extension
)
;
return
true
;
}
return
extensions_
.
append
(
std
:
:
move
(
extension
)
)
;
}
void
LanguageTag
:
:
clearUnicodeExtension
(
)
{
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
extensions_
.
erase
(
extensions_
.
begin
(
)
+
index
)
;
}
}
template
<
size_t
InitialCapacity
>
static
bool
SortAlphabetically
(
JSContext
*
cx
Vector
<
UniqueChars
InitialCapacity
>
&
subtags
)
{
size_t
length
=
subtags
.
length
(
)
;
if
(
length
<
2
)
{
return
true
;
}
if
(
length
=
=
2
)
{
if
(
strcmp
(
subtags
[
0
]
.
get
(
)
subtags
[
1
]
.
get
(
)
)
>
0
)
{
subtags
[
0
]
.
swap
(
subtags
[
1
]
)
;
}
return
true
;
}
Vector
<
char
*
8
>
scratch
(
cx
)
;
if
(
!
scratch
.
resizeUninitialized
(
length
*
2
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
scratch
[
i
]
=
subtags
[
i
]
.
release
(
)
;
}
MOZ_ALWAYS_TRUE
(
MergeSort
(
scratch
.
begin
(
)
length
scratch
.
begin
(
)
+
length
[
]
(
const
char
*
a
const
char
*
b
bool
*
lessOrEqualp
)
{
*
lessOrEqualp
=
strcmp
(
a
b
)
<
=
0
;
return
true
;
}
)
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
subtags
[
i
]
=
UniqueChars
(
scratch
[
i
]
)
;
}
return
true
;
}
bool
LanguageTag
:
:
canonicalizeBaseName
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
language
(
)
.
range
(
)
)
)
;
MOZ_ASSERT
(
script
(
)
.
length
(
)
=
=
0
|
|
IsStructurallyValidScriptTag
(
script
(
)
.
range
(
)
)
)
;
MOZ_ASSERT
(
region
(
)
.
length
(
)
=
=
0
|
|
IsStructurallyValidRegionTag
(
region
(
)
.
range
(
)
)
)
;
#
ifdef
DEBUG
auto
validVariant
=
[
]
(
const
auto
&
variant
)
{
const
char
*
str
=
variant
.
get
(
)
;
return
IsStructurallyValidVariantTag
(
{
str
strlen
(
str
)
}
)
;
}
;
MOZ_ASSERT
(
std
:
:
all_of
(
variants
(
)
.
begin
(
)
variants
(
)
.
end
(
)
validVariant
)
)
;
auto
validExtension
=
[
]
(
const
auto
&
extension
)
{
const
char
*
str
=
extension
.
get
(
)
;
return
IsStructurallyValidExtensionTag
(
{
str
strlen
(
str
)
}
)
;
}
;
MOZ_ASSERT
(
std
:
:
all_of
(
extensions
(
)
.
begin
(
)
extensions
(
)
.
end
(
)
validExtension
)
)
;
#
endif
MOZ_ASSERT
(
!
privateuse
(
)
|
|
IsStructurallyValidPrivateUseTag
(
{
privateuse
(
)
strlen
(
privateuse
(
)
)
}
)
)
;
if
(
!
SortAlphabetically
(
cx
variants_
)
)
{
return
false
;
}
if
(
!
updateGrandfatheredMappings
(
cx
)
)
{
return
false
;
}
if
(
!
languageMapping
(
language_
)
&
&
complexLanguageMapping
(
language_
)
)
{
performComplexLanguageMappings
(
)
;
}
if
(
region
(
)
.
length
(
)
>
0
)
{
if
(
!
regionMapping
(
region_
)
&
&
complexRegionMapping
(
region_
)
)
{
performComplexRegionMappings
(
)
;
}
}
return
true
;
}
bool
LanguageTag
:
:
canonicalizeExtensions
(
JSContext
*
cx
UnicodeExtensionCanonicalForm
canonicalForm
)
{
if
(
!
SortAlphabetically
(
cx
extensions_
)
)
{
return
false
;
}
for
(
UniqueChars
&
extension
:
extensions_
)
{
if
(
extension
[
0
]
=
=
'
u
'
)
{
if
(
!
canonicalizeUnicodeExtension
(
cx
extension
canonicalForm
)
)
{
return
false
;
}
}
else
if
(
extension
[
0
]
=
=
'
t
'
)
{
if
(
!
canonicalizeTransformExtension
(
cx
extension
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
LanguageTag
:
:
canonicalizeUnicodeExtension
(
JSContext
*
cx
JS
:
:
UniqueChars
&
unicodeExtension
UnicodeExtensionCanonicalForm
canonicalForm
)
{
const
char
*
const
extension
=
unicodeExtension
.
get
(
)
;
MOZ_ASSERT
(
extension
[
0
]
=
=
'
u
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
IsStructurallyValidExtensionTag
(
{
extension
strlen
(
extension
)
}
)
)
;
size_t
length
=
strlen
(
extension
)
;
LanguageTagParser
:
:
AttributesVector
attributes
(
cx
)
;
LanguageTagParser
:
:
KeywordsVector
keywords
(
cx
)
;
using
Attribute
=
LanguageTagParser
:
:
AttributesVector
:
:
ElementType
;
using
Keyword
=
LanguageTagParser
:
:
KeywordsVector
:
:
ElementType
;
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
LanguageTagParser
:
:
parseUnicodeExtension
(
cx
ConstCharRange
(
extension
length
)
attributes
keywords
)
)
;
MOZ_ASSERT
(
ok
"
unexpected
invalid
Unicode
extension
subtag
"
)
;
auto
attributesLessOrEqual
=
[
extension
]
(
const
Attribute
&
a
const
Attribute
&
b
)
{
const
char
*
astr
=
a
.
begin
(
extension
)
;
const
char
*
bstr
=
b
.
begin
(
extension
)
;
size_t
alen
=
a
.
length
(
)
;
size_t
blen
=
b
.
length
(
)
;
if
(
int
r
=
std
:
:
char_traits
<
char
>
:
:
compare
(
astr
bstr
std
:
:
min
(
alen
blen
)
)
)
{
return
r
<
0
;
}
return
alen
<
=
blen
;
}
;
size_t
attributesLength
=
attributes
.
length
(
)
;
if
(
attributesLength
>
1
)
{
if
(
!
attributes
.
growByUninitialized
(
attributesLength
)
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
MergeSort
(
attributes
.
begin
(
)
attributesLength
attributes
.
begin
(
)
+
attributesLength
[
&
]
(
const
auto
&
a
const
auto
&
b
bool
*
lessOrEqualp
)
{
*
lessOrEqualp
=
attributesLessOrEqual
(
a
b
)
;
return
true
;
}
)
)
;
attributes
.
shrinkBy
(
attributesLength
)
;
}
auto
keywordsLessOrEqual
=
[
extension
]
(
const
Keyword
&
a
const
Keyword
&
b
)
{
const
char
*
astr
=
a
.
begin
(
extension
)
;
const
char
*
bstr
=
b
.
begin
(
extension
)
;
MOZ_ASSERT
(
a
.
length
(
)
>
=
UnicodeKeyLength
)
;
MOZ_ASSERT
(
b
.
length
(
)
>
=
UnicodeKeyLength
)
;
return
std
:
:
char_traits
<
char
>
:
:
compare
(
astr
bstr
UnicodeKeyLength
)
<
=
0
;
}
;
size_t
keywordsLength
=
keywords
.
length
(
)
;
if
(
keywordsLength
>
1
)
{
if
(
!
keywords
.
growByUninitialized
(
keywordsLength
)
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
MergeSort
(
keywords
.
begin
(
)
keywordsLength
keywords
.
begin
(
)
+
keywordsLength
[
&
]
(
const
auto
&
a
const
auto
&
b
bool
*
lessOrEqualp
)
{
*
lessOrEqualp
=
keywordsLessOrEqual
(
a
b
)
;
return
true
;
}
)
)
;
keywords
.
shrinkBy
(
keywordsLength
)
;
}
Vector
<
char
32
>
sb
(
cx
)
;
if
(
!
sb
.
append
(
'
u
'
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
attributes
.
length
(
)
;
i
+
+
)
{
const
auto
&
attribute
=
attributes
[
i
]
;
if
(
canonicalForm
=
=
UnicodeExtensionCanonicalForm
:
:
Yes
&
&
i
>
0
)
{
const
auto
&
lastAttribute
=
attributes
[
i
-
1
]
;
if
(
attribute
.
length
(
)
=
=
lastAttribute
.
length
(
)
&
&
std
:
:
char_traits
<
char
>
:
:
compare
(
attribute
.
begin
(
extension
)
lastAttribute
.
begin
(
extension
)
attribute
.
length
(
)
)
=
=
0
)
{
continue
;
}
MOZ_ASSERT
(
!
attributesLessOrEqual
(
attribute
lastAttribute
)
)
;
}
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
false
;
}
if
(
!
sb
.
append
(
attribute
.
begin
(
extension
)
attribute
.
length
(
)
)
)
{
return
false
;
}
}
static
constexpr
size_t
UnicodeKeyWithSepLength
=
UnicodeKeyLength
+
1
;
static
auto
isTrue
=
[
]
(
const
ConstCharRange
&
type
)
{
constexpr
char
True
[
]
=
"
true
"
;
const
size_t
TrueLength
=
strlen
(
True
)
;
return
type
.
length
(
)
=
=
TrueLength
&
&
std
:
:
char_traits
<
char
>
:
:
compare
(
type
.
begin
(
)
.
get
(
)
True
TrueLength
)
=
=
0
;
}
;
auto
appendKey
=
[
&
sb
extension
]
(
const
Keyword
&
keyword
)
{
MOZ_ASSERT
(
keyword
.
length
(
)
=
=
UnicodeKeyLength
)
;
return
sb
.
append
(
keyword
.
begin
(
extension
)
UnicodeKeyLength
)
;
}
;
auto
appendKeyword
=
[
&
sb
extension
]
(
const
Keyword
&
keyword
const
ConstCharRange
&
type
)
{
MOZ_ASSERT
(
keyword
.
length
(
)
>
UnicodeKeyLength
)
;
if
(
isTrue
(
type
)
)
{
return
sb
.
append
(
keyword
.
begin
(
extension
)
UnicodeKeyLength
)
;
}
return
sb
.
append
(
keyword
.
begin
(
extension
)
keyword
.
length
(
)
)
;
}
;
auto
appendReplacement
=
[
&
sb
extension
]
(
const
Keyword
&
keyword
const
ConstCharRange
&
replacement
)
{
MOZ_ASSERT
(
keyword
.
length
(
)
>
UnicodeKeyLength
)
;
if
(
isTrue
(
replacement
)
)
{
return
sb
.
append
(
keyword
.
begin
(
extension
)
UnicodeKeyLength
)
;
}
return
sb
.
append
(
keyword
.
begin
(
extension
)
UnicodeKeyWithSepLength
)
&
&
sb
.
append
(
replacement
.
begin
(
)
.
get
(
)
replacement
.
length
(
)
)
;
}
;
for
(
size_t
i
=
0
;
i
<
keywords
.
length
(
)
;
i
+
+
)
{
const
auto
&
keyword
=
keywords
[
i
]
;
if
(
canonicalForm
=
=
UnicodeExtensionCanonicalForm
:
:
Yes
&
&
i
>
0
)
{
const
auto
&
lastKeyword
=
keywords
[
i
-
1
]
;
if
(
std
:
:
char_traits
<
char
>
:
:
compare
(
keyword
.
begin
(
extension
)
lastKeyword
.
begin
(
extension
)
UnicodeKeyLength
)
=
=
0
)
{
continue
;
}
MOZ_ASSERT
(
!
keywordsLessOrEqual
(
keyword
lastKeyword
)
)
;
}
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
false
;
}
if
(
keyword
.
length
(
)
=
=
UnicodeKeyLength
)
{
if
(
!
appendKey
(
keyword
)
)
{
return
false
;
}
}
else
{
ConstCharRange
key
(
keyword
.
begin
(
extension
)
UnicodeKeyLength
)
;
ConstCharRange
type
(
keyword
.
begin
(
extension
)
+
UnicodeKeyWithSepLength
keyword
.
length
(
)
-
UnicodeKeyWithSepLength
)
;
if
(
canonicalForm
=
=
UnicodeExtensionCanonicalForm
:
:
Yes
)
{
if
(
const
char
*
replacement
=
replaceUnicodeExtensionType
(
key
type
)
)
{
if
(
!
appendReplacement
(
keyword
ConstCharRange
(
replacement
strlen
(
replacement
)
)
)
)
{
return
false
;
}
}
else
{
if
(
!
appendKeyword
(
keyword
type
)
)
{
return
false
;
}
}
}
else
{
if
(
!
appendKeyword
(
keyword
type
)
)
{
return
false
;
}
}
}
}
if
(
sb
.
length
(
)
!
=
length
|
|
std
:
:
char_traits
<
char
>
:
:
compare
(
sb
.
begin
(
)
extension
length
)
!
=
0
)
{
if
(
!
sb
.
append
(
'
\
0
'
)
)
{
return
false
;
}
UniqueChars
canonical
(
sb
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
canonical
)
{
return
false
;
}
unicodeExtension
=
std
:
:
move
(
canonical
)
;
}
return
true
;
}
template
<
class
Buffer
>
static
bool
LanguageTagToString
(
JSContext
*
cx
const
LanguageTag
&
tag
Buffer
&
sb
)
{
auto
appendSubtag
=
[
&
sb
]
(
const
auto
&
subtag
)
{
auto
range
=
subtag
.
range
(
)
;
MOZ_ASSERT
(
range
.
length
(
)
>
0
)
;
return
sb
.
append
(
range
.
begin
(
)
.
get
(
)
range
.
length
(
)
)
;
}
;
auto
appendSubtagZ
=
[
&
sb
]
(
const
char
*
subtag
)
{
MOZ_ASSERT
(
strlen
(
subtag
)
>
0
)
;
return
sb
.
append
(
subtag
strlen
(
subtag
)
)
;
}
;
auto
appendSubtagsZ
=
[
&
sb
&
appendSubtagZ
]
(
const
auto
&
subtags
)
{
for
(
const
auto
&
subtag
:
subtags
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtagZ
(
subtag
.
get
(
)
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
!
appendSubtag
(
tag
.
language
(
)
)
)
{
return
false
;
}
if
(
tag
.
script
(
)
.
length
(
)
>
0
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtag
(
tag
.
script
(
)
)
)
{
return
false
;
}
}
if
(
tag
.
region
(
)
.
length
(
)
>
0
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtag
(
tag
.
region
(
)
)
)
{
return
false
;
}
}
if
(
!
appendSubtagsZ
(
tag
.
variants
(
)
)
)
{
return
false
;
}
if
(
!
appendSubtagsZ
(
tag
.
extensions
(
)
)
)
{
return
false
;
}
if
(
tag
.
privateuse
(
)
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtagZ
(
tag
.
privateuse
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
LanguageTag
:
:
canonicalizeTransformExtension
(
JSContext
*
cx
JS
:
:
UniqueChars
&
transformExtension
)
{
const
char
*
const
extension
=
transformExtension
.
get
(
)
;
MOZ_ASSERT
(
extension
[
0
]
=
=
'
t
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
IsStructurallyValidExtensionTag
(
{
extension
strlen
(
extension
)
}
)
)
;
size_t
length
=
strlen
(
extension
)
;
LanguageTag
tag
(
cx
)
;
LanguageTagParser
:
:
TFieldVector
fields
(
cx
)
;
using
TField
=
LanguageTagParser
:
:
TFieldVector
:
:
ElementType
;
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
LanguageTagParser
:
:
parseTransformExtension
(
cx
ConstCharRange
(
extension
length
)
tag
fields
)
)
;
MOZ_ASSERT
(
ok
"
unexpected
invalid
transform
extension
subtag
"
)
;
auto
tfieldLessOrEqual
=
[
extension
]
(
const
TField
&
a
const
TField
&
b
)
{
MOZ_ASSERT
(
a
.
length
(
)
>
TransformKeyLength
)
;
MOZ_ASSERT
(
b
.
length
(
)
>
TransformKeyLength
)
;
const
char
*
astr
=
a
.
begin
(
extension
)
;
const
char
*
bstr
=
b
.
begin
(
extension
)
;
return
std
:
:
char_traits
<
char
>
:
:
compare
(
astr
bstr
TransformKeyLength
)
<
=
0
;
}
;
size_t
fieldsLength
=
fields
.
length
(
)
;
if
(
fieldsLength
>
1
)
{
if
(
!
fields
.
growByUninitialized
(
fieldsLength
)
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
MergeSort
(
fields
.
begin
(
)
fieldsLength
fields
.
begin
(
)
+
fieldsLength
[
&
]
(
const
auto
&
a
const
auto
&
b
bool
*
lessOrEqualp
)
{
*
lessOrEqualp
=
tfieldLessOrEqual
(
a
b
)
;
return
true
;
}
)
)
;
fields
.
shrinkBy
(
fieldsLength
)
;
}
Vector
<
char
32
>
sb
(
cx
)
;
if
(
!
sb
.
append
(
'
t
'
)
)
{
return
false
;
}
if
(
tag
.
language
(
)
.
length
(
)
>
0
)
{
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
false
;
}
if
(
!
LanguageTagToString
(
cx
tag
sb
)
)
{
return
false
;
}
}
for
(
const
auto
&
field
:
fields
)
{
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
false
;
}
if
(
!
sb
.
append
(
field
.
begin
(
extension
)
field
.
length
(
)
)
)
{
return
false
;
}
}
if
(
sb
.
length
(
)
!
=
length
|
|
std
:
:
char_traits
<
char
>
:
:
compare
(
sb
.
begin
(
)
extension
length
)
!
=
0
)
{
if
(
!
sb
.
append
(
'
\
0
'
)
)
{
return
false
;
}
UniqueChars
canonical
(
sb
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
canonical
)
{
return
false
;
}
transformExtension
=
std
:
:
move
(
canonical
)
;
}
return
true
;
}
JSString
*
LanguageTag
:
:
toString
(
JSContext
*
cx
)
const
{
JSStringBuilder
sb
(
cx
)
;
if
(
!
LanguageTagToString
(
cx
*
this
sb
)
)
{
return
nullptr
;
}
return
sb
.
finishString
(
)
;
}
using
LocaleId
=
js
:
:
Vector
<
char
LanguageLength
+
1
+
ScriptLength
+
1
+
RegionLength
+
1
>
;
enum
class
LikelySubtags
:
bool
{
Add
Remove
}
;
static
bool
HasLikelySubtags
(
LikelySubtags
likelySubtags
const
LanguageTag
&
tag
)
{
if
(
likelySubtags
=
=
LikelySubtags
:
:
Add
)
{
return
!
tag
.
language
(
)
.
equalTo
(
"
und
"
)
&
&
(
tag
.
script
(
)
.
length
(
)
>
0
&
&
!
tag
.
script
(
)
.
equalTo
(
"
Zzzz
"
)
)
&
&
(
tag
.
region
(
)
.
length
(
)
>
0
&
&
!
tag
.
region
(
)
.
equalTo
(
"
ZZ
"
)
)
;
}
return
!
tag
.
language
(
)
.
equalTo
(
"
und
"
)
&
&
tag
.
script
(
)
.
length
(
)
=
=
0
&
&
tag
.
region
(
)
.
length
(
)
=
=
0
;
}
static
bool
CreateLocaleForLikelySubtags
(
const
LanguageTag
&
tag
LocaleId
&
locale
)
{
MOZ_ASSERT
(
locale
.
length
(
)
=
=
0
)
;
auto
appendSubtag
=
[
&
locale
]
(
const
auto
&
subtag
)
{
auto
range
=
subtag
.
range
(
)
;
MOZ_ASSERT
(
range
.
length
(
)
>
0
)
;
return
locale
.
append
(
range
.
begin
(
)
.
get
(
)
range
.
length
(
)
)
;
}
;
if
(
!
appendSubtag
(
tag
.
language
(
)
)
)
{
return
false
;
}
if
(
tag
.
script
(
)
.
length
(
)
>
0
)
{
if
(
!
locale
.
append
(
'
_
'
)
|
|
!
appendSubtag
(
tag
.
script
(
)
)
)
{
return
false
;
}
}
if
(
tag
.
region
(
)
.
length
(
)
>
0
)
{
if
(
!
locale
.
append
(
'
_
'
)
|
|
!
appendSubtag
(
tag
.
region
(
)
)
)
{
return
false
;
}
}
return
locale
.
append
(
'
\
0
'
)
;
}
static
bool
AssignFromLocaleId
(
JSContext
*
cx
LocaleId
&
localeId
LanguageTag
&
tag
)
{
MOZ_ASSERT
(
localeId
.
back
(
)
=
=
'
\
0
'
"
Locale
ID
should
be
zero
-
terminated
for
ICU
"
)
;
std
:
:
replace
(
localeId
.
begin
(
)
localeId
.
end
(
)
'
_
'
'
-
'
)
;
if
(
localeId
[
0
]
=
=
'
\
0
'
|
|
localeId
[
0
]
=
=
'
-
'
)
{
static
constexpr
char
und
[
]
=
"
und
"
;
size_t
length
=
strlen
(
und
)
;
if
(
!
localeId
.
growBy
(
length
)
)
{
return
false
;
}
memmove
(
localeId
.
begin
(
)
+
length
localeId
.
begin
(
)
localeId
.
length
(
)
)
;
memmove
(
localeId
.
begin
(
)
und
length
)
;
}
ConstCharRange
localeRange
(
localeId
.
begin
(
)
localeId
.
length
(
)
-
1
)
;
LanguageTag
localeTag
(
cx
)
;
if
(
!
LanguageTagParser
:
:
parseBaseName
(
cx
localeRange
localeTag
)
)
{
return
false
;
}
tag
.
setLanguage
(
localeTag
.
language
(
)
)
;
tag
.
setScript
(
localeTag
.
script
(
)
)
;
tag
.
setRegion
(
localeTag
.
region
(
)
)
;
return
true
;
}
template
<
decltype
(
uloc_addLikelySubtags
)
likelySubtagsFn
>
static
bool
CallLikelySubtags
(
JSContext
*
cx
const
LocaleId
&
localeId
LocaleId
&
result
)
{
MOZ_ASSERT
(
localeId
.
back
(
)
=
=
'
\
0
'
)
;
MOZ_ASSERT
(
result
.
length
(
)
=
=
0
)
;
MOZ_ALWAYS_TRUE
(
result
.
resize
(
LocaleId
:
:
InlineLength
)
)
;
int32_t
length
=
intl
:
:
CallICU
(
cx
[
&
localeId
]
(
char
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
likelySubtagsFn
(
localeId
.
begin
(
)
chars
size
status
)
;
}
result
)
;
if
(
length
<
0
)
{
return
false
;
}
MOZ_ASSERT
(
size_t
(
length
)
<
=
LocaleId
:
:
InlineLength
"
Unexpected
extra
subtags
were
added
by
ICU
.
If
this
assertion
ever
"
"
fails
simply
remove
it
and
move
on
like
nothing
ever
happended
.
"
)
;
result
.
shrinkTo
(
length
)
;
return
result
.
append
(
'
\
0
'
)
;
}
static
bool
LikelySubtags
(
JSContext
*
cx
LikelySubtags
likelySubtags
LanguageTag
&
tag
)
{
if
(
HasLikelySubtags
(
likelySubtags
tag
)
)
{
return
true
;
}
LocaleId
locale
(
cx
)
;
if
(
!
CreateLocaleForLikelySubtags
(
tag
locale
)
)
{
return
false
;
}
LocaleId
localeLikelySubtags
(
cx
)
;
bool
addLikelySubtags
=
likelySubtags
=
=
LikelySubtags
:
:
Add
|
|
!
HasLikelySubtags
(
LikelySubtags
:
:
Add
tag
)
;
if
(
addLikelySubtags
)
{
if
(
!
CallLikelySubtags
<
uloc_addLikelySubtags
>
(
cx
locale
localeLikelySubtags
)
)
{
return
false
;
}
}
if
(
likelySubtags
=
=
LikelySubtags
:
:
Remove
)
{
if
(
addLikelySubtags
)
{
locale
=
std
:
:
move
(
localeLikelySubtags
)
;
localeLikelySubtags
=
LocaleId
(
cx
)
;
}
if
(
!
CallLikelySubtags
<
uloc_minimizeSubtags
>
(
cx
locale
localeLikelySubtags
)
)
{
return
false
;
}
}
if
(
!
AssignFromLocaleId
(
cx
localeLikelySubtags
tag
)
)
{
return
false
;
}
return
tag
.
canonicalizeBaseName
(
cx
)
;
}
bool
LanguageTag
:
:
addLikelySubtags
(
JSContext
*
cx
)
{
return
LikelySubtags
(
cx
LikelySubtags
:
:
Add
*
this
)
;
}
bool
LanguageTag
:
:
removeLikelySubtags
(
JSContext
*
cx
)
{
return
LikelySubtags
(
cx
LikelySubtags
:
:
Remove
*
this
)
;
}
LanguageTagParser
:
:
Token
LanguageTagParser
:
:
nextToken
(
)
{
MOZ_ASSERT
(
index_
<
=
length_
+
1
"
called
after
'
None
'
token
was
read
"
)
;
TokenKind
kind
=
TokenKind
:
:
None
;
size_t
tokenLength
=
0
;
for
(
size_t
i
=
index_
;
i
<
length_
;
i
+
+
)
{
char16_t
c
=
charAtUnchecked
(
i
)
;
if
(
mozilla
:
:
IsAsciiAlpha
(
c
)
)
{
kind
|
=
TokenKind
:
:
Alpha
;
}
else
if
(
mozilla
:
:
IsAsciiDigit
(
c
)
)
{
kind
|
=
TokenKind
:
:
Digit
;
}
else
if
(
c
=
=
'
-
'
&
&
i
>
index_
&
&
i
+
1
<
length_
)
{
break
;
}
else
{
return
{
TokenKind
:
:
Error
0
0
}
;
}
tokenLength
+
=
1
;
}
Token
token
{
kind
index_
tokenLength
}
;
index_
+
=
tokenLength
+
1
;
return
token
;
}
UniqueChars
LanguageTagParser
:
:
chars
(
JSContext
*
cx
size_t
index
size_t
length
)
const
{
auto
chars
=
cx
-
>
make_pod_array
<
char
>
(
length
+
1
)
;
if
(
chars
)
{
char
*
dest
=
chars
.
get
(
)
;
if
(
locale_
.
is
<
const
JS
:
:
Latin1Char
*
>
(
)
)
{
std
:
:
copy_n
(
locale_
.
as
<
const
JS
:
:
Latin1Char
*
>
(
)
+
index
length
dest
)
;
}
else
{
std
:
:
copy_n
(
locale_
.
as
<
const
char16_t
*
>
(
)
+
index
length
dest
)
;
}
dest
[
length
]
=
'
\
0
'
;
}
return
chars
;
}
UniqueChars
LanguageTagParser
:
:
extension
(
JSContext
*
cx
const
Token
&
start
const
Token
&
end
)
const
{
MOZ_ASSERT
(
start
.
index
(
)
<
end
.
index
(
)
)
;
size_t
length
=
end
.
index
(
)
-
1
-
start
.
index
(
)
;
UniqueChars
extension
=
chars
(
cx
start
.
index
(
)
length
)
;
if
(
extension
)
{
AsciiToLowerCase
(
extension
.
get
(
)
length
extension
.
get
(
)
)
;
}
return
extension
;
}
JS
:
:
Result
<
bool
>
LanguageTagParser
:
:
internalParseBaseName
(
JSContext
*
cx
LanguageTagParser
&
ts
LanguageTag
&
tag
Token
&
tok
BaseNameParsing
parseType
)
{
#
ifdef
DEBUG
auto
isAsciiLowerCase
=
[
]
(
const
auto
&
range
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
char
*
ptr
=
range
.
begin
(
)
.
get
(
)
;
size_t
length
=
range
.
length
(
)
;
return
std
:
:
all_of
(
ptr
ptr
+
length
mozilla
:
:
IsAsciiLowercaseAlpha
<
char
>
)
;
}
;
auto
isAsciiDigit
=
[
]
(
const
auto
&
range
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
char
*
ptr
=
range
.
begin
(
)
.
get
(
)
;
size_t
length
=
range
.
length
(
)
;
return
std
:
:
all_of
(
ptr
ptr
+
length
mozilla
:
:
IsAsciiDigit
<
char
>
)
;
}
;
#
endif
if
(
ts
.
isLanguage
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
language_
)
;
if
(
parseType
=
=
BaseNameParsing
:
:
Normal
)
{
tag
.
language_
.
toLowerCase
(
)
;
}
else
{
MOZ_ASSERT
(
isAsciiLowerCase
(
tag
.
language_
.
range
(
)
)
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
else
{
MOZ_ASSERT
(
parseType
=
=
BaseNameParsing
:
:
Normal
)
;
return
false
;
}
if
(
ts
.
isScript
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
script_
)
;
if
(
parseType
=
=
BaseNameParsing
:
:
Normal
)
{
tag
.
script_
.
toTitleCase
(
)
;
}
else
{
MOZ_ASSERT
(
isAsciiLowerCase
(
tag
.
script_
.
range
(
)
)
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
if
(
ts
.
isRegion
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
region_
)
;
if
(
parseType
=
=
BaseNameParsing
:
:
Normal
)
{
tag
.
region_
.
toUpperCase
(
)
;
}
else
{
MOZ_ASSERT_IF
(
tok
.
length
(
)
=
=
2
isAsciiLowerCase
(
tag
.
region_
.
range
(
)
)
)
;
MOZ_ASSERT_IF
(
tok
.
length
(
)
=
=
3
isAsciiDigit
(
tag
.
region_
.
range
(
)
)
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
auto
&
variants
=
tag
.
variants_
;
MOZ_ASSERT
(
variants
.
length
(
)
=
=
0
)
;
while
(
ts
.
isVariant
(
tok
)
)
{
auto
variant
=
ts
.
chars
(
cx
tok
)
;
if
(
!
variant
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
if
(
parseType
=
=
BaseNameParsing
:
:
Normal
)
{
AsciiToLowerCase
(
variant
.
get
(
)
tok
.
length
(
)
variant
.
get
(
)
)
;
for
(
const
auto
&
seenVariant
:
variants
)
{
if
(
strcmp
(
variant
.
get
(
)
seenVariant
.
get
(
)
)
=
=
0
)
{
return
false
;
}
}
}
else
{
}
if
(
!
variants
.
append
(
std
:
:
move
(
variant
)
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
return
true
;
}
static
mozilla
:
:
Variant
<
const
Latin1Char
*
const
char16_t
*
>
StringChars
(
const
char
*
locale
)
{
return
mozilla
:
:
AsVariant
(
reinterpret_cast
<
const
JS
:
:
Latin1Char
*
>
(
locale
)
)
;
}
static
mozilla
:
:
Variant
<
const
Latin1Char
*
const
char16_t
*
>
StringChars
(
JSLinearString
*
linear
JS
:
:
AutoCheckCannotGC
&
nogc
)
{
if
(
linear
-
>
hasLatin1Chars
(
)
)
{
return
mozilla
:
:
AsVariant
(
linear
-
>
latin1Chars
(
nogc
)
)
;
}
return
mozilla
:
:
AsVariant
(
linear
-
>
twoByteChars
(
nogc
)
)
;
}
JS
:
:
Result
<
bool
>
LanguageTagParser
:
:
tryParse
(
JSContext
*
cx
JSLinearString
*
locale
LanguageTag
&
tag
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
LocaleChars
localeChars
=
StringChars
(
locale
nogc
)
;
LanguageTagParser
ts
(
localeChars
locale
-
>
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
bool
ok
;
MOZ_TRY_VAR
(
ok
parseBaseName
(
cx
ts
tag
tok
)
)
;
if
(
!
ok
)
{
return
false
;
}
uint64_t
seenSingletons
=
0
;
auto
&
extensions
=
tag
.
extensions_
;
while
(
ts
.
isExtensionStart
(
tok
)
)
{
char
singleton
=
ts
.
singletonKey
(
tok
)
;
uint64_t
hash
=
1ULL
<
<
(
mozilla
:
:
AsciiAlphanumericToNumber
(
singleton
)
+
1
)
;
if
(
seenSingletons
&
hash
)
{
return
false
;
}
seenSingletons
|
=
hash
;
Token
start
=
tok
;
tok
=
ts
.
nextToken
(
)
;
size_t
startValue
=
tok
.
index
(
)
;
if
(
singleton
=
=
'
u
'
)
{
while
(
ts
.
isUnicodeExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
else
if
(
singleton
=
=
'
t
'
)
{
if
(
ts
.
isLanguage
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
if
(
ts
.
isScript
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
ts
.
isRegion
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isVariant
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
while
(
ts
.
isTransformExtensionKey
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
size_t
startTValue
=
tok
.
index
(
)
;
while
(
ts
.
isTransformExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startTValue
)
{
return
false
;
}
}
}
else
{
while
(
ts
.
isOtherExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
if
(
tok
.
index
(
)
<
=
startValue
)
{
return
false
;
}
UniqueChars
extension
=
ts
.
extension
(
cx
start
tok
)
;
if
(
!
extension
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
if
(
!
extensions
.
append
(
std
:
:
move
(
extension
)
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
}
if
(
ts
.
isPrivateUseStart
(
tok
)
)
{
Token
start
=
tok
;
tok
=
ts
.
nextToken
(
)
;
size_t
startValue
=
tok
.
index
(
)
;
while
(
ts
.
isPrivateUsePart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startValue
)
{
return
false
;
}
UniqueChars
privateUse
=
ts
.
extension
(
cx
start
tok
)
;
if
(
!
privateUse
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
tag
.
privateuse_
=
std
:
:
move
(
privateUse
)
;
}
return
tok
.
isNone
(
)
;
}
bool
LanguageTagParser
:
:
parse
(
JSContext
*
cx
JSLinearString
*
locale
LanguageTag
&
tag
)
{
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
tryParse
(
cx
locale
tag
)
)
;
if
(
ok
)
{
return
true
;
}
if
(
UniqueChars
localeChars
=
QuoteString
(
cx
locale
'
"
'
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_LANGUAGE_TAG
localeChars
.
get
(
)
)
;
}
return
false
;
}
bool
LanguageTagParser
:
:
parseBaseName
(
JSContext
*
cx
ConstCharRange
locale
LanguageTag
&
tag
)
{
LocaleChars
localeChars
=
StringChars
(
locale
.
begin
(
)
.
get
(
)
)
;
LanguageTagParser
ts
(
localeChars
locale
.
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
bool
ok
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
ok
parseBaseName
(
cx
ts
tag
tok
)
)
;
if
(
ok
)
{
return
true
;
}
if
(
UniqueChars
localeChars
=
DuplicateString
(
locale
.
begin
(
)
.
get
(
)
locale
.
length
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_LANGUAGE_TAG
localeChars
.
get
(
)
)
;
}
else
{
JS_ReportOutOfMemory
(
cx
)
;
}
return
false
;
}
JS
:
:
Result
<
bool
>
LanguageTagParser
:
:
parseTransformExtension
(
JSContext
*
cx
ConstCharRange
extension
LanguageTag
&
tag
TFieldVector
&
fields
)
{
LocaleChars
extensionChars
=
StringChars
(
extension
.
begin
(
)
.
get
(
)
)
;
LanguageTagParser
ts
(
extensionChars
extension
.
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
t
'
)
{
return
false
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
false
;
}
if
(
ts
.
isLanguage
(
tok
)
)
{
MOZ_TRY
(
parseTlangInTransformExtension
(
cx
ts
tag
tok
)
)
;
MOZ_ASSERT
(
ts
.
isTransformExtensionKey
(
tok
)
|
|
tok
.
isNone
(
)
)
;
}
else
{
MOZ_ASSERT
(
ts
.
isTransformExtensionKey
(
tok
)
)
;
}
while
(
ts
.
isTransformExtensionKey
(
tok
)
)
{
size_t
begin
=
tok
.
index
(
)
;
tok
=
ts
.
nextToken
(
)
;
size_t
startTValue
=
tok
.
index
(
)
;
while
(
ts
.
isTransformExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startTValue
)
{
return
false
;
}
size_t
length
=
tok
.
index
(
)
-
1
-
begin
;
if
(
!
fields
.
emplaceBack
(
begin
length
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
}
return
tok
.
isNone
(
)
;
}
JS
:
:
Result
<
bool
>
LanguageTagParser
:
:
parseUnicodeExtension
(
JSContext
*
cx
ConstCharRange
extension
AttributesVector
&
attributes
KeywordsVector
&
keywords
)
{
LocaleChars
extensionChars
=
StringChars
(
extension
.
begin
(
)
.
get
(
)
)
;
LanguageTagParser
ts
(
extensionChars
extension
.
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
u
'
)
{
return
false
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
false
;
}
while
(
ts
.
isUnicodeExtensionAttribute
(
tok
)
)
{
if
(
!
attributes
.
emplaceBack
(
tok
.
index
(
)
tok
.
length
(
)
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isUnicodeExtensionKey
(
tok
)
)
{
size_t
begin
=
tok
.
index
(
)
;
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
isError
(
)
)
{
return
false
;
}
size_t
length
=
tok
.
index
(
)
-
1
-
begin
;
if
(
!
keywords
.
emplaceBack
(
begin
length
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
}
return
tok
.
isNone
(
)
;
}
bool
LanguageTagParser
:
:
canParseUnicodeExtension
(
ConstCharRange
extension
)
{
LocaleChars
extensionChars
=
StringChars
(
extension
.
begin
(
)
.
get
(
)
)
;
LanguageTagParser
ts
(
extensionChars
extension
.
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
u
'
)
{
return
false
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
false
;
}
while
(
ts
.
isUnicodeExtensionAttribute
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isUnicodeExtensionKey
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
isError
(
)
)
{
return
false
;
}
}
return
tok
.
isNone
(
)
;
}
bool
LanguageTagParser
:
:
canParseUnicodeExtensionType
(
JSLinearString
*
unicodeType
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
LocaleChars
unicodeTypeChars
=
StringChars
(
unicodeType
nogc
)
;
LanguageTagParser
ts
(
unicodeTypeChars
unicodeType
-
>
length
(
)
)
;
Token
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
return
tok
.
isNone
(
)
;
}
bool
ParseStandaloneLanguagTag
(
HandleLinearString
str
LanguageSubtag
&
result
)
{
auto
isLanguage
=
[
]
(
const
auto
*
language
size_t
length
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
using
T
=
std
:
:
remove_pointer_t
<
decltype
(
language
)
>
;
return
length
>
=
2
&
&
length
!
=
4
&
&
length
<
=
8
&
&
std
:
:
all_of
(
language
language
+
length
mozilla
:
:
IsAsciiAlpha
<
T
>
)
;
}
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
if
(
!
isLanguage
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
latin1Range
(
nogc
)
)
;
}
else
{
if
(
!
isLanguage
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
result
.
toLowerCase
(
)
;
return
true
;
}
bool
ParseStandaloneScriptTag
(
HandleLinearString
str
ScriptSubtag
&
result
)
{
auto
isScript
=
[
]
(
const
auto
*
script
size_t
length
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
using
T
=
std
:
:
remove_pointer_t
<
decltype
(
script
)
>
;
return
length
=
=
ScriptLength
&
&
std
:
:
all_of
(
script
script
+
ScriptLength
mozilla
:
:
IsAsciiAlpha
<
T
>
)
;
}
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
if
(
!
isScript
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
latin1Range
(
nogc
)
)
;
}
else
{
if
(
!
isScript
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
result
.
toTitleCase
(
)
;
return
true
;
}
bool
ParseStandaloneRegionTag
(
HandleLinearString
str
RegionSubtag
&
result
)
{
auto
isRegion
=
[
]
(
const
auto
*
region
size_t
length
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
using
T
=
std
:
:
remove_pointer_t
<
decltype
(
region
)
>
;
return
(
length
=
=
AlphaRegionLength
&
&
std
:
:
all_of
(
region
region
+
AlphaRegionLength
mozilla
:
:
IsAsciiAlpha
<
T
>
)
)
|
|
(
length
=
=
DigitRegionLength
&
&
std
:
:
all_of
(
region
region
+
DigitRegionLength
mozilla
:
:
IsAsciiDigit
<
T
>
)
)
;
}
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
if
(
!
isRegion
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
latin1Range
(
nogc
)
)
;
}
else
{
if
(
!
isRegion
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
)
{
return
false
;
}
result
.
set
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
result
.
toUpperCase
(
)
;
return
true
;
}
template
<
typename
CharT
>
static
bool
IsAsciiLowercaseAlpha
(
const
mozilla
:
:
Range
<
const
CharT
>
&
range
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
CharT
*
ptr
=
range
.
begin
(
)
.
get
(
)
;
size_t
length
=
range
.
length
(
)
;
return
std
:
:
all_of
(
ptr
ptr
+
length
mozilla
:
:
IsAsciiLowercaseAlpha
<
CharT
>
)
;
}
static
bool
IsAsciiLowercaseAlpha
(
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
str
-
>
hasLatin1Chars
(
)
?
IsAsciiLowercaseAlpha
(
str
-
>
latin1Range
(
nogc
)
)
:
IsAsciiLowercaseAlpha
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
template
<
typename
CharT
>
static
bool
IsAsciiAlpha
(
const
mozilla
:
:
Range
<
const
CharT
>
&
range
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
CharT
*
ptr
=
range
.
begin
(
)
.
get
(
)
;
size_t
length
=
range
.
length
(
)
;
return
std
:
:
all_of
(
ptr
ptr
+
length
mozilla
:
:
IsAsciiAlpha
<
CharT
>
)
;
}
static
bool
IsAsciiAlpha
(
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
str
-
>
hasLatin1Chars
(
)
?
IsAsciiAlpha
(
str
-
>
latin1Range
(
nogc
)
)
:
IsAsciiAlpha
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
JS
:
:
Result
<
JSString
*
>
ParseStandaloneISO639LanguageTag
(
JSContext
*
cx
HandleLinearString
str
)
{
size_t
length
=
str
-
>
length
(
)
;
if
(
length
!
=
2
&
&
length
!
=
3
)
{
return
nullptr
;
}
bool
isLowerCase
=
IsAsciiLowercaseAlpha
(
str
)
;
if
(
!
isLowerCase
)
{
if
(
!
IsAsciiAlpha
(
str
)
)
{
return
nullptr
;
}
}
LanguageSubtag
languageTag
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
languageTag
.
set
(
str
-
>
latin1Range
(
nogc
)
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
languageTag
.
set
(
str
-
>
twoByteRange
(
nogc
)
)
;
}
if
(
!
isLowerCase
)
{
languageTag
.
toLowerCase
(
)
;
}
if
(
LanguageTag
:
:
complexLanguageMapping
(
languageTag
)
)
{
return
nullptr
;
}
JSString
*
result
;
if
(
LanguageTag
:
:
languageMapping
(
languageTag
)
|
|
!
isLowerCase
)
{
auto
range
=
languageTag
.
range
(
)
;
result
=
NewStringCopyN
<
CanGC
>
(
cx
range
.
begin
(
)
.
get
(
)
range
.
length
(
)
)
;
}
else
{
result
=
str
;
}
if
(
!
result
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
return
result
;
}
}
}
