#
include
"
builtin
/
intl
/
DurationFormat
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
DateTimeFormat
.
h
"
#
include
"
mozilla
/
intl
/
ListFormat
.
h
"
#
include
"
mozilla
/
intl
/
NumberFormat
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
array
>
#
include
<
charconv
>
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
builtin
/
intl
/
CommonFunctions
.
h
"
#
include
"
builtin
/
intl
/
FormatBuffer
.
h
"
#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
#
include
"
builtin
/
intl
/
ListFormat
.
h
"
#
include
"
builtin
/
intl
/
NumberFormat
.
h
"
#
include
"
builtin
/
temporal
/
Duration
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
intl
;
static
constexpr
auto
durationUnits
=
std
:
:
array
{
temporal
:
:
TemporalUnit
:
:
Year
temporal
:
:
TemporalUnit
:
:
Month
temporal
:
:
TemporalUnit
:
:
Week
temporal
:
:
TemporalUnit
:
:
Day
temporal
:
:
TemporalUnit
:
:
Hour
temporal
:
:
TemporalUnit
:
:
Minute
temporal
:
:
TemporalUnit
:
:
Second
temporal
:
:
TemporalUnit
:
:
Millisecond
temporal
:
:
TemporalUnit
:
:
Microsecond
temporal
:
:
TemporalUnit
:
:
Nanosecond
}
;
const
JSClass
DurationFormatObject
:
:
class_
=
{
"
Intl
.
DurationFormat
"
JSCLASS_HAS_RESERVED_SLOTS
(
DurationFormatObject
:
:
SLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_DurationFormat
)
|
JSCLASS_FOREGROUND_FINALIZE
&
DurationFormatObject
:
:
classOps_
&
DurationFormatObject
:
:
classSpec_
}
;
const
JSClass
&
DurationFormatObject
:
:
protoClass_
=
PlainObject
:
:
class_
;
static
bool
durationFormat_format
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
durationFormat_formatToParts
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
durationFormat_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
DurationFormat
)
;
return
true
;
}
static
const
JSFunctionSpec
durationFormat_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
supportedLocalesOf
"
"
Intl_DurationFormat_supportedLocalesOf
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
durationFormat_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
resolvedOptions
"
"
Intl_DurationFormat_resolvedOptions
"
0
0
)
JS_FN
(
"
format
"
durationFormat_format
1
0
)
JS_FN
(
"
formatToParts
"
durationFormat_formatToParts
1
0
)
JS_FN
(
"
toSource
"
durationFormat_toSource
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
durationFormat_properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
Intl
.
DurationFormat
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
bool
DurationFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
const
JSClassOps
DurationFormatObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
DurationFormatObject
:
:
finalize
nullptr
nullptr
nullptr
}
;
const
ClassSpec
DurationFormatObject
:
:
classSpec_
=
{
GenericCreateConstructor
<
DurationFormat
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
DurationFormatObject
>
durationFormat_static_methods
nullptr
durationFormat_methods
durationFormat_properties
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
void
js
:
:
DurationFormatObject
:
:
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
MOZ_ASSERT
(
gcx
-
>
onMainThread
(
)
)
;
auto
*
durationFormat
=
&
obj
-
>
as
<
DurationFormatObject
>
(
)
;
for
(
auto
unit
:
durationUnits
)
{
if
(
auto
*
nf
=
durationFormat
-
>
getNumberFormat
(
unit
)
)
{
RemoveICUCellMemory
(
gcx
obj
NumberFormatObject
:
:
EstimatedMemoryUse
)
;
delete
nf
;
}
}
if
(
auto
*
lf
=
durationFormat
-
>
getListFormat
(
)
)
{
RemoveICUCellMemory
(
gcx
obj
ListFormatObject
:
:
EstimatedMemoryUse
)
;
delete
lf
;
}
if
(
auto
*
options
=
durationFormat
-
>
getOptions
(
)
)
{
gcx
-
>
delete_
(
obj
options
MemoryUse
:
:
IntlOptions
)
;
}
}
static
bool
DurationFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
Intl
.
DurationFormat
"
)
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_DurationFormat
&
proto
)
)
{
return
false
;
}
Rooted
<
DurationFormatObject
*
>
durationFormat
(
cx
NewObjectWithClassProto
<
DurationFormatObject
>
(
cx
proto
)
)
;
if
(
!
durationFormat
)
{
return
false
;
}
HandleValue
locales
=
args
.
get
(
0
)
;
HandleValue
options
=
args
.
get
(
1
)
;
if
(
!
InitializeObject
(
cx
durationFormat
cx
-
>
names
(
)
.
InitializeDurationFormat
locales
options
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
durationFormat
)
;
return
true
;
}
static
JSString
*
GetTimeSeparator
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
if
(
auto
*
separator
=
durationFormat
-
>
getTimeSeparator
(
)
)
{
return
separator
;
}
Rooted
<
JSObject
*
>
internals
(
cx
GetInternalsObject
(
cx
durationFormat
)
)
;
if
(
!
internals
)
{
return
nullptr
;
}
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
{
return
nullptr
;
}
UniqueChars
locale
=
EncodeLocale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
{
return
nullptr
;
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
numberingSystem
&
value
)
)
{
return
nullptr
;
}
UniqueChars
numberingSystem
=
EncodeAscii
(
cx
value
.
toString
(
)
)
;
if
(
!
numberingSystem
)
{
return
nullptr
;
}
FormatBuffer
<
char16_t
INITIAL_CHAR_BUFFER_SIZE
>
separator
(
cx
)
;
auto
result
=
mozilla
:
:
intl
:
:
DateTimeFormat
:
:
GetTimeSeparator
(
mozilla
:
:
MakeStringSpan
(
locale
.
get
(
)
)
mozilla
:
:
MakeStringSpan
(
numberingSystem
.
get
(
)
)
separator
)
;
if
(
result
.
isErr
(
)
)
{
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
auto
*
string
=
separator
.
toString
(
cx
)
;
if
(
!
string
)
{
return
nullptr
;
}
durationFormat
-
>
setTimeSeparator
(
string
)
;
return
string
;
}
struct
DurationValue
{
static
constexpr
size_t
MaximumDecimalStringLength
=
1
+
16
+
1
+
9
;
static
constexpr
size_t
DecimalStringCapacity
=
32
;
double
number
=
0
;
char
decimal
[
DecimalStringCapacity
]
=
{
}
;
explicit
DurationValue
(
)
=
default
;
explicit
DurationValue
(
double
number
)
:
number
(
number
)
{
}
bool
isNegative
(
)
const
{
return
mozilla
:
:
IsNegative
(
number
)
|
|
decimal
[
0
]
=
=
'
-
'
;
}
auto
abs
(
)
const
{
if
(
!
isNegative
(
)
)
{
return
*
this
;
}
if
(
!
isDecimal
(
)
)
{
return
DurationValue
{
std
:
:
abs
(
number
)
}
;
}
auto
result
=
DurationValue
{
}
;
std
:
:
copy
(
std
:
:
next
(
decimal
)
std
:
:
end
(
decimal
)
result
.
decimal
)
;
return
result
;
}
bool
isDecimal
(
)
const
{
return
decimal
[
0
]
!
=
'
\
0
'
;
}
bool
isZero
(
)
const
{
return
number
=
=
0
&
&
!
isDecimal
(
)
;
}
operator
std
:
:
string_view
(
)
const
{
MOZ_ASSERT
(
isDecimal
(
)
)
;
return
{
decimal
}
;
}
}
;
static
auto
ToDurationValue
(
const
temporal
:
:
Duration
&
duration
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
DurationValue
{
duration
.
years
}
;
case
TemporalUnit
:
:
Month
:
return
DurationValue
{
duration
.
months
}
;
case
TemporalUnit
:
:
Week
:
return
DurationValue
{
duration
.
weeks
}
;
case
TemporalUnit
:
:
Day
:
return
DurationValue
{
duration
.
days
}
;
case
TemporalUnit
:
:
Hour
:
return
DurationValue
{
duration
.
hours
}
;
case
TemporalUnit
:
:
Minute
:
return
DurationValue
{
duration
.
minutes
}
;
case
TemporalUnit
:
:
Second
:
return
DurationValue
{
duration
.
seconds
}
;
case
TemporalUnit
:
:
Millisecond
:
return
DurationValue
{
duration
.
milliseconds
}
;
case
TemporalUnit
:
:
Microsecond
:
return
DurationValue
{
duration
.
microseconds
}
;
case
TemporalUnit
:
:
Nanosecond
:
return
DurationValue
{
duration
.
nanoseconds
}
;
case
TemporalUnit
:
:
Auto
:
break
;
}
MOZ_CRASH
(
"
invalid
temporal
unit
"
)
;
}
static
PropertyName
*
DurationDisplayName
(
temporal
:
:
TemporalUnit
unit
JSContext
*
cx
)
{
using
namespace
temporal
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
cx
-
>
names
(
)
.
yearsDisplay
;
case
TemporalUnit
:
:
Month
:
return
cx
-
>
names
(
)
.
monthsDisplay
;
case
TemporalUnit
:
:
Week
:
return
cx
-
>
names
(
)
.
weeksDisplay
;
case
TemporalUnit
:
:
Day
:
return
cx
-
>
names
(
)
.
daysDisplay
;
case
TemporalUnit
:
:
Hour
:
return
cx
-
>
names
(
)
.
hoursDisplay
;
case
TemporalUnit
:
:
Minute
:
return
cx
-
>
names
(
)
.
minutesDisplay
;
case
TemporalUnit
:
:
Second
:
return
cx
-
>
names
(
)
.
secondsDisplay
;
case
TemporalUnit
:
:
Millisecond
:
return
cx
-
>
names
(
)
.
millisecondsDisplay
;
case
TemporalUnit
:
:
Microsecond
:
return
cx
-
>
names
(
)
.
microsecondsDisplay
;
case
TemporalUnit
:
:
Nanosecond
:
return
cx
-
>
names
(
)
.
nanosecondsDisplay
;
case
TemporalUnit
:
:
Auto
:
break
;
}
MOZ_CRASH
(
"
invalid
temporal
unit
"
)
;
}
static
bool
ToDurationDisplay
(
JSContext
*
cx
const
Value
&
value
DurationDisplay
*
result
)
{
MOZ_ASSERT
(
value
.
isString
(
)
)
;
auto
*
linear
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
if
(
StringEqualsAscii
(
linear
"
auto
"
)
)
{
*
result
=
DurationDisplay
:
:
Auto
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
linear
"
always
"
)
)
;
*
result
=
DurationDisplay
:
:
Always
;
}
return
true
;
}
static
PropertyName
*
DurationStyleName
(
temporal
:
:
TemporalUnit
unit
JSContext
*
cx
)
{
using
namespace
temporal
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
cx
-
>
names
(
)
.
yearsStyle
;
case
TemporalUnit
:
:
Month
:
return
cx
-
>
names
(
)
.
monthsStyle
;
case
TemporalUnit
:
:
Week
:
return
cx
-
>
names
(
)
.
weeksStyle
;
case
TemporalUnit
:
:
Day
:
return
cx
-
>
names
(
)
.
daysStyle
;
case
TemporalUnit
:
:
Hour
:
return
cx
-
>
names
(
)
.
hoursStyle
;
case
TemporalUnit
:
:
Minute
:
return
cx
-
>
names
(
)
.
minutesStyle
;
case
TemporalUnit
:
:
Second
:
return
cx
-
>
names
(
)
.
secondsStyle
;
case
TemporalUnit
:
:
Millisecond
:
return
cx
-
>
names
(
)
.
millisecondsStyle
;
case
TemporalUnit
:
:
Microsecond
:
return
cx
-
>
names
(
)
.
microsecondsStyle
;
case
TemporalUnit
:
:
Nanosecond
:
return
cx
-
>
names
(
)
.
nanosecondsStyle
;
case
TemporalUnit
:
:
Auto
:
break
;
}
MOZ_CRASH
(
"
invalid
temporal
unit
"
)
;
}
static
bool
ToDurationStyle
(
JSContext
*
cx
const
Value
&
value
DurationStyle
*
result
)
{
MOZ_ASSERT
(
value
.
isString
(
)
)
;
auto
*
linear
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
if
(
StringEqualsAscii
(
linear
"
long
"
)
)
{
*
result
=
DurationStyle
:
:
Long
;
}
else
if
(
StringEqualsAscii
(
linear
"
short
"
)
)
{
*
result
=
DurationStyle
:
:
Short
;
}
else
if
(
StringEqualsAscii
(
linear
"
narrow
"
)
)
{
*
result
=
DurationStyle
:
:
Narrow
;
}
else
if
(
StringEqualsAscii
(
linear
"
numeric
"
)
)
{
*
result
=
DurationStyle
:
:
Numeric
;
}
else
{
MOZ_ASSERT
(
StringEqualsAscii
(
linear
"
2
-
digit
"
)
)
;
*
result
=
DurationStyle
:
:
TwoDigit
;
}
return
true
;
}
static
std
:
:
pair
<
uint32_t
uint32_t
>
GetFractionalDigits
(
const
DurationFormatObject
*
durationFormat
)
{
auto
*
options
=
durationFormat
-
>
getOptions
(
)
;
MOZ_ASSERT
(
options
"
unexpected
unresolved
duration
format
options
"
)
;
int8_t
digits
=
options
-
>
fractionalDigits
;
MOZ_ASSERT
(
digits
<
=
9
)
;
if
(
digits
<
0
)
{
return
{
0U
9U
}
;
}
return
{
uint32_t
(
digits
)
uint32_t
(
digits
)
}
;
}
static
DurationUnitOptions
GetUnitOptions
(
const
DurationFormatOptions
&
options
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
switch
(
unit
)
{
#
define
GET_UNIT_OPTIONS
(
name
)
\
DurationUnitOptions
{
options
.
name
#
#
Display
options
.
name
#
#
Style
}
case
TemporalUnit
:
:
Year
:
return
GET_UNIT_OPTIONS
(
years
)
;
case
TemporalUnit
:
:
Month
:
return
GET_UNIT_OPTIONS
(
months
)
;
case
TemporalUnit
:
:
Week
:
return
GET_UNIT_OPTIONS
(
weeks
)
;
case
TemporalUnit
:
:
Day
:
return
GET_UNIT_OPTIONS
(
days
)
;
case
TemporalUnit
:
:
Hour
:
return
GET_UNIT_OPTIONS
(
hours
)
;
case
TemporalUnit
:
:
Minute
:
return
GET_UNIT_OPTIONS
(
minutes
)
;
case
TemporalUnit
:
:
Second
:
return
GET_UNIT_OPTIONS
(
seconds
)
;
case
TemporalUnit
:
:
Millisecond
:
return
GET_UNIT_OPTIONS
(
milliseconds
)
;
case
TemporalUnit
:
:
Microsecond
:
return
GET_UNIT_OPTIONS
(
microseconds
)
;
case
TemporalUnit
:
:
Nanosecond
:
return
GET_UNIT_OPTIONS
(
nanoseconds
)
;
case
TemporalUnit
:
:
Auto
:
break
;
#
undef
GET_UNIT_OPTIONS
}
MOZ_CRASH
(
"
invalid
duration
unit
"
)
;
}
static
void
SetUnitOptions
(
DurationFormatOptions
&
options
temporal
:
:
TemporalUnit
unit
const
DurationUnitOptions
&
unitOptions
)
{
using
namespace
temporal
;
switch
(
unit
)
{
#
define
SET_UNIT_OPTIONS
(
name
)
\
do
{
\
options
.
name
#
#
Display
=
unitOptions
.
display_
;
\
options
.
name
#
#
Style
=
unitOptions
.
style_
;
\
}
while
(
0
)
case
TemporalUnit
:
:
Year
:
SET_UNIT_OPTIONS
(
years
)
;
return
;
case
TemporalUnit
:
:
Month
:
SET_UNIT_OPTIONS
(
months
)
;
return
;
case
TemporalUnit
:
:
Week
:
SET_UNIT_OPTIONS
(
weeks
)
;
return
;
case
TemporalUnit
:
:
Day
:
SET_UNIT_OPTIONS
(
days
)
;
return
;
case
TemporalUnit
:
:
Hour
:
SET_UNIT_OPTIONS
(
hours
)
;
return
;
case
TemporalUnit
:
:
Minute
:
SET_UNIT_OPTIONS
(
minutes
)
;
return
;
case
TemporalUnit
:
:
Second
:
SET_UNIT_OPTIONS
(
seconds
)
;
return
;
case
TemporalUnit
:
:
Millisecond
:
SET_UNIT_OPTIONS
(
milliseconds
)
;
return
;
case
TemporalUnit
:
:
Microsecond
:
SET_UNIT_OPTIONS
(
microseconds
)
;
return
;
case
TemporalUnit
:
:
Nanosecond
:
SET_UNIT_OPTIONS
(
nanoseconds
)
;
return
;
case
TemporalUnit
:
:
Auto
:
break
;
#
undef
SET_UNIT_OPTIONS
}
MOZ_CRASH
(
"
invalid
duration
unit
"
)
;
}
static
DurationFormatOptions
*
NewDurationFormatOptions
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
Rooted
<
JSObject
*
>
internals
(
cx
GetInternalsObject
(
cx
durationFormat
)
)
;
if
(
!
internals
)
{
return
nullptr
;
}
auto
options
=
cx
-
>
make_unique
<
DurationFormatOptions
>
(
)
;
if
(
!
options
)
{
return
nullptr
;
}
Rooted
<
Value
>
value
(
cx
)
;
for
(
temporal
:
:
TemporalUnit
unit
:
durationUnits
)
{
DurationDisplay
display
;
if
(
!
GetProperty
(
cx
internals
internals
DurationDisplayName
(
unit
cx
)
&
value
)
)
{
return
nullptr
;
}
if
(
!
ToDurationDisplay
(
cx
value
&
display
)
)
{
return
nullptr
;
}
DurationStyle
style
;
if
(
!
GetProperty
(
cx
internals
internals
DurationStyleName
(
unit
cx
)
&
value
)
)
{
return
nullptr
;
}
if
(
!
ToDurationStyle
(
cx
value
&
style
)
)
{
return
nullptr
;
}
SetUnitOptions
(
*
options
unit
DurationUnitOptions
{
static_cast
<
uint8_t
>
(
display
)
static_cast
<
uint8_t
>
(
style
)
}
)
;
}
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
fractionalDigits
&
value
)
)
{
return
nullptr
;
}
if
(
value
.
isUndefined
(
)
)
{
options
-
>
fractionalDigits
=
-
1
;
}
else
{
options
-
>
fractionalDigits
=
value
.
toInt32
(
)
;
}
return
options
.
release
(
)
;
}
static
DurationFormatOptions
*
GetOrCreateDurationFormatOptions
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
auto
*
options
=
durationFormat
-
>
getOptions
(
)
;
if
(
options
)
{
return
options
;
}
options
=
NewDurationFormatOptions
(
cx
durationFormat
)
;
if
(
!
options
)
{
return
nullptr
;
}
durationFormat
-
>
setOptions
(
options
)
;
AddCellMemory
(
durationFormat
sizeof
(
DurationFormatOptions
)
MemoryUse
:
:
IntlOptions
)
;
return
options
;
}
static
UniqueChars
NewDurationNumberFormatLocale
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
Rooted
<
JSObject
*
>
internals
(
cx
GetInternalsObject
(
cx
durationFormat
)
)
;
if
(
!
internals
)
{
return
nullptr
;
}
JS
:
:
RootedVector
<
UnicodeExtensionKeyword
>
keywords
(
cx
)
;
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
numberingSystem
&
value
)
)
{
return
nullptr
;
}
{
auto
*
numberingSystem
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
numberingSystem
)
{
return
nullptr
;
}
if
(
!
keywords
.
emplaceBack
(
"
nu
"
numberingSystem
)
)
{
return
nullptr
;
}
}
return
FormatLocale
(
cx
internals
keywords
)
;
}
static
mozilla
:
:
intl
:
:
NumberFormat
*
NewDurationNumberFormat
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
const
mozilla
:
:
intl
:
:
NumberFormatOptions
&
options
)
{
auto
locale
=
NewDurationNumberFormatLocale
(
cx
durationFormat
)
;
if
(
!
locale
)
{
return
nullptr
;
}
auto
result
=
mozilla
:
:
intl
:
:
NumberFormat
:
:
TryCreate
(
locale
.
get
(
)
options
)
;
if
(
result
.
isErr
(
)
)
{
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
return
result
.
unwrap
(
)
.
release
(
)
;
}
static
std
:
:
string_view
UnitName
(
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
"
year
"
;
case
TemporalUnit
:
:
Month
:
return
"
month
"
;
case
TemporalUnit
:
:
Week
:
return
"
week
"
;
case
TemporalUnit
:
:
Day
:
return
"
day
"
;
case
TemporalUnit
:
:
Hour
:
return
"
hour
"
;
case
TemporalUnit
:
:
Minute
:
return
"
minute
"
;
case
TemporalUnit
:
:
Second
:
return
"
second
"
;
case
TemporalUnit
:
:
Millisecond
:
return
"
millisecond
"
;
case
TemporalUnit
:
:
Microsecond
:
return
"
microsecond
"
;
case
TemporalUnit
:
:
Nanosecond
:
return
"
nanosecond
"
;
case
TemporalUnit
:
:
Auto
:
break
;
}
MOZ_CRASH
(
"
invalid
temporal
unit
"
)
;
}
static
auto
PartUnitName
(
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Year
:
return
&
JSAtomState
:
:
year
;
case
TemporalUnit
:
:
Month
:
return
&
JSAtomState
:
:
month
;
case
TemporalUnit
:
:
Week
:
return
&
JSAtomState
:
:
week
;
case
TemporalUnit
:
:
Day
:
return
&
JSAtomState
:
:
day
;
case
TemporalUnit
:
:
Hour
:
return
&
JSAtomState
:
:
hour
;
case
TemporalUnit
:
:
Minute
:
return
&
JSAtomState
:
:
minute
;
case
TemporalUnit
:
:
Second
:
return
&
JSAtomState
:
:
second
;
case
TemporalUnit
:
:
Millisecond
:
return
&
JSAtomState
:
:
millisecond
;
case
TemporalUnit
:
:
Microsecond
:
return
&
JSAtomState
:
:
microsecond
;
case
TemporalUnit
:
:
Nanosecond
:
return
&
JSAtomState
:
:
nanosecond
;
case
TemporalUnit
:
:
Auto
:
break
;
}
MOZ_CRASH
(
"
invalid
temporal
unit
"
)
;
}
static
auto
UnitDisplay
(
DurationStyle
style
)
{
using
UnitDisplay
=
mozilla
:
:
intl
:
:
NumberFormatOptions
:
:
UnitDisplay
;
switch
(
style
)
{
case
DurationStyle
:
:
Long
:
return
UnitDisplay
:
:
Long
;
case
DurationStyle
:
:
Short
:
return
UnitDisplay
:
:
Short
;
case
DurationStyle
:
:
Narrow
:
return
UnitDisplay
:
:
Narrow
;
case
DurationStyle
:
:
Numeric
:
case
DurationStyle
:
:
TwoDigit
:
break
;
}
MOZ_CRASH
(
"
invalid
duration
style
"
)
;
}
static
auto
ComputeFractionalDigits
(
const
temporal
:
:
Duration
&
duration
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
MOZ_ASSERT
(
IsValidDuration
(
duration
)
)
;
MOZ_ASSERT
(
TemporalUnit
:
:
Second
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Microsecond
)
;
TimeDuration
timeDuration
;
int32_t
exponent
;
switch
(
unit
)
{
case
TemporalUnit
:
:
Second
:
{
if
(
duration
.
milliseconds
=
=
0
&
&
duration
.
microseconds
=
=
0
&
&
duration
.
nanoseconds
=
=
0
)
{
return
DurationValue
{
duration
.
seconds
}
;
}
timeDuration
=
TimeDurationFromComponents
(
{
0
0
0
0
0
0
duration
.
seconds
duration
.
milliseconds
duration
.
microseconds
duration
.
nanoseconds
}
)
;
exponent
=
100
'
000
'
000
;
break
;
}
case
TemporalUnit
:
:
Millisecond
:
{
if
(
duration
.
microseconds
=
=
0
&
&
duration
.
nanoseconds
=
=
0
)
{
return
DurationValue
{
duration
.
milliseconds
}
;
}
timeDuration
=
TimeDurationFromComponents
(
{
0
0
0
0
0
0
0
duration
.
milliseconds
duration
.
microseconds
duration
.
nanoseconds
}
)
;
exponent
=
100
'
000
;
break
;
}
case
TemporalUnit
:
:
Microsecond
:
{
if
(
duration
.
nanoseconds
=
=
0
)
{
return
DurationValue
{
duration
.
microseconds
}
;
}
timeDuration
=
TimeDurationFromComponents
(
{
0
0
0
0
0
0
0
0
duration
.
microseconds
duration
.
nanoseconds
}
)
;
exponent
=
100
;
break
;
}
default
:
MOZ_CRASH
(
"
bad
temporal
unit
"
)
;
}
DurationValue
result
{
}
;
char
*
chars
=
result
.
decimal
;
if
(
timeDuration
<
TimeDuration
{
}
)
{
*
chars
+
+
=
'
-
'
;
timeDuration
=
timeDuration
.
abs
(
)
;
}
auto
res
=
std
:
:
to_chars
(
chars
std
:
:
end
(
result
.
decimal
)
timeDuration
.
seconds
)
;
MOZ_ASSERT
(
res
.
ec
=
=
std
:
:
errc
(
)
)
;
chars
=
res
.
ptr
;
int32_t
nanos
=
timeDuration
.
nanoseconds
;
for
(
int32_t
k
=
100
'
000
'
000
;
k
!
=
0
&
&
nanos
!
=
0
;
k
/
=
10
)
{
if
(
k
=
=
exponent
)
{
*
chars
+
+
=
'
.
'
;
}
*
chars
+
+
=
char
(
'
0
'
+
(
nanos
/
k
)
)
;
nanos
%
=
k
;
}
MOZ_ASSERT
(
(
chars
-
result
.
decimal
)
<
=
ptrdiff_t
(
DurationValue
:
:
MaximumDecimalStringLength
)
"
unexpected
decimal
string
length
"
)
;
return
result
;
}
static
mozilla
:
:
intl
:
:
NumberFormat
*
NewNumericFormatter
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
temporal
:
:
TemporalUnit
unit
)
{
auto
*
dfOptions
=
durationFormat
-
>
getOptions
(
)
;
MOZ_ASSERT
(
dfOptions
"
unexpected
unresolved
duration
format
options
"
)
;
auto
style
=
GetUnitOptions
(
*
dfOptions
unit
)
.
style
(
)
;
MOZ_ASSERT
(
style
=
=
DurationStyle
:
:
Numeric
|
|
style
=
=
DurationStyle
:
:
TwoDigit
)
;
mozilla
:
:
intl
:
:
NumberFormatOptions
options
{
}
;
if
(
style
=
=
DurationStyle
:
:
TwoDigit
)
{
options
.
mMinIntegerDigits
=
mozilla
:
:
Some
(
2
)
;
}
options
.
mGrouping
=
mozilla
:
:
intl
:
:
NumberFormatOptions
:
:
Grouping
:
:
Never
;
if
(
unit
=
=
temporal
:
:
TemporalUnit
:
:
Second
)
{
auto
fractionalDigits
=
GetFractionalDigits
(
durationFormat
)
;
options
.
mFractionDigits
=
mozilla
:
:
Some
(
fractionalDigits
)
;
options
.
mRoundingMode
=
mozilla
:
:
intl
:
:
NumberFormatOptions
:
:
RoundingMode
:
:
Trunc
;
}
return
NewDurationNumberFormat
(
cx
durationFormat
options
)
;
}
static
mozilla
:
:
intl
:
:
NumberFormat
*
GetOrCreateNumericFormatter
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
temporal
:
:
TemporalUnit
unit
)
{
auto
*
nf
=
durationFormat
-
>
getNumberFormat
(
unit
)
;
if
(
nf
)
{
return
nf
;
}
nf
=
NewNumericFormatter
(
cx
durationFormat
unit
)
;
if
(
!
nf
)
{
return
nullptr
;
}
durationFormat
-
>
setNumberFormat
(
unit
nf
)
;
AddICUCellMemory
(
durationFormat
NumberFormatObject
:
:
EstimatedMemoryUse
)
;
return
nf
;
}
static
bool
NextUnitFractional
(
const
DurationFormatObject
*
durationFormat
temporal
:
:
TemporalUnit
unit
)
{
using
namespace
temporal
;
if
(
TemporalUnit
:
:
Second
<
=
unit
&
&
unit
<
=
TemporalUnit
:
:
Microsecond
)
{
auto
*
options
=
durationFormat
-
>
getOptions
(
)
;
MOZ_ASSERT
(
options
"
unexpected
unresolved
duration
format
options
"
)
;
using
TemporalUnitType
=
std
:
:
underlying_type_t
<
TemporalUnit
>
;
auto
nextUnit
=
static_cast
<
TemporalUnit
>
(
static_cast
<
TemporalUnitType
>
(
unit
)
+
1
)
;
auto
nextStyle
=
GetUnitOptions
(
*
options
nextUnit
)
.
style
(
)
;
return
nextStyle
=
=
DurationStyle
:
:
Numeric
;
}
return
false
;
}
static
mozilla
:
:
intl
:
:
NumberFormat
*
NewNumberFormat
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
temporal
:
:
TemporalUnit
unit
DurationStyle
style
)
{
mozilla
:
:
intl
:
:
NumberFormatOptions
options
{
}
;
if
(
NextUnitFractional
(
durationFormat
unit
)
)
{
auto
fractionalDigits
=
GetFractionalDigits
(
durationFormat
)
;
options
.
mFractionDigits
=
mozilla
:
:
Some
(
fractionalDigits
)
;
options
.
mRoundingMode
=
mozilla
:
:
intl
:
:
NumberFormatOptions
:
:
RoundingMode
:
:
Trunc
;
}
options
.
mUnit
=
mozilla
:
:
Some
(
std
:
:
pair
{
UnitName
(
unit
)
UnitDisplay
(
style
)
}
)
;
return
NewDurationNumberFormat
(
cx
durationFormat
options
)
;
}
static
mozilla
:
:
intl
:
:
NumberFormat
*
GetOrCreateNumberFormat
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
temporal
:
:
TemporalUnit
unit
DurationStyle
style
)
{
auto
*
nf
=
durationFormat
-
>
getNumberFormat
(
unit
)
;
if
(
nf
)
{
return
nf
;
}
nf
=
NewNumberFormat
(
cx
durationFormat
unit
style
)
;
if
(
!
nf
)
{
return
nullptr
;
}
durationFormat
-
>
setNumberFormat
(
unit
nf
)
;
AddICUCellMemory
(
durationFormat
NumberFormatObject
:
:
EstimatedMemoryUse
)
;
return
nf
;
}
static
JSLinearString
*
FormatDurationValueToString
(
JSContext
*
cx
mozilla
:
:
intl
:
:
NumberFormat
*
nf
const
DurationValue
&
value
)
{
if
(
value
.
isDecimal
(
)
)
{
return
FormatNumber
(
cx
nf
std
:
:
string_view
{
value
}
)
;
}
return
FormatNumber
(
cx
nf
value
.
number
)
;
}
static
ArrayObject
*
FormatDurationValueToParts
(
JSContext
*
cx
mozilla
:
:
intl
:
:
NumberFormat
*
nf
const
DurationValue
&
value
temporal
:
:
TemporalUnit
unit
)
{
if
(
value
.
isDecimal
(
)
)
{
return
FormatNumberToParts
(
cx
nf
std
:
:
string_view
{
value
}
PartUnitName
(
unit
)
)
;
}
return
FormatNumberToParts
(
cx
nf
value
.
number
PartUnitName
(
unit
)
)
;
}
static
bool
FormatDurationValue
(
JSContext
*
cx
mozilla
:
:
intl
:
:
NumberFormat
*
nf
temporal
:
:
TemporalUnit
unit
const
DurationValue
&
value
bool
formatToParts
MutableHandle
<
Value
>
result
)
{
if
(
!
formatToParts
)
{
auto
*
str
=
FormatDurationValueToString
(
cx
nf
value
)
;
if
(
!
str
)
{
return
false
;
}
result
.
setString
(
str
)
;
}
else
{
auto
*
parts
=
FormatDurationValueToParts
(
cx
nf
value
unit
)
;
if
(
!
parts
)
{
return
false
;
}
result
.
setObject
(
*
parts
)
;
}
return
true
;
}
static
bool
FormatNumericHoursOrMinutesOrSeconds
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
temporal
:
:
TemporalUnit
unit
const
DurationValue
&
value
bool
formatToParts
MutableHandle
<
Value
>
result
)
{
MOZ_ASSERT
(
temporal
:
:
TemporalUnit
:
:
Hour
<
=
unit
&
&
unit
<
=
temporal
:
:
TemporalUnit
:
:
Second
)
;
auto
*
nf
=
GetOrCreateNumericFormatter
(
cx
durationFormat
unit
)
;
if
(
!
nf
)
{
return
false
;
}
return
FormatDurationValue
(
cx
nf
unit
value
formatToParts
result
)
;
}
static
PlainObject
*
NewLiteralPart
(
JSContext
*
cx
JSString
*
value
)
{
Rooted
<
IdValueVector
>
properties
(
cx
cx
)
;
if
(
!
properties
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
type
)
StringValue
(
cx
-
>
names
(
)
.
literal
)
)
)
{
return
nullptr
;
}
if
(
!
properties
.
emplaceBack
(
NameToId
(
cx
-
>
names
(
)
.
value
)
StringValue
(
value
)
)
)
{
return
nullptr
;
}
return
NewPlainObjectWithUniqueNames
(
cx
properties
)
;
}
static
bool
FormatNumericUnits
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
const
temporal
:
:
Duration
&
duration
temporal
:
:
TemporalUnit
firstNumericUnit
bool
signDisplayed
bool
formatToParts
MutableHandle
<
Value
>
result
)
{
using
namespace
temporal
;
auto
*
options
=
durationFormat
-
>
getOptions
(
)
;
MOZ_ASSERT
(
options
"
unexpected
unresolved
duration
format
options
"
)
;
Rooted
<
Value
>
formattedValue
(
cx
)
;
MOZ_ASSERT
(
TemporalUnit
:
:
Hour
<
=
firstNumericUnit
&
&
firstNumericUnit
<
=
TemporalUnit
:
:
Second
)
;
using
FormattedNumericUnitsVector
=
JS
:
:
GCVector
<
Value
3
>
;
Rooted
<
FormattedNumericUnitsVector
>
numericPartsList
(
cx
cx
)
;
if
(
!
numericPartsList
.
reserve
(
3
)
)
{
return
false
;
}
auto
hoursValue
=
DurationValue
{
duration
.
hours
}
;
auto
hoursDisplay
=
GetUnitOptions
(
*
options
TemporalUnit
:
:
Hour
)
.
display
(
)
;
auto
minutesValue
=
DurationValue
{
duration
.
minutes
}
;
auto
minutesDisplay
=
GetUnitOptions
(
*
options
TemporalUnit
:
:
Minute
)
.
display
(
)
;
auto
secondsValue
=
ComputeFractionalDigits
(
duration
TemporalUnit
:
:
Second
)
;
auto
secondsDisplay
=
GetUnitOptions
(
*
options
TemporalUnit
:
:
Second
)
.
display
(
)
;
bool
hoursFormatted
=
false
;
if
(
firstNumericUnit
=
=
TemporalUnit
:
:
Hour
)
{
hoursFormatted
=
!
hoursValue
.
isZero
(
)
|
|
hoursDisplay
=
=
DurationDisplay
:
:
Always
;
}
bool
secondsFormatted
=
!
secondsValue
.
isZero
(
)
|
|
secondsDisplay
=
=
DurationDisplay
:
:
Always
;
bool
minutesFormatted
=
false
;
if
(
firstNumericUnit
=
=
TemporalUnit
:
:
Hour
|
|
firstNumericUnit
=
=
TemporalUnit
:
:
Minute
)
{
minutesFormatted
=
(
hoursFormatted
&
&
secondsFormatted
)
|
|
!
minutesValue
.
isZero
(
)
|
|
minutesDisplay
=
=
DurationDisplay
:
:
Always
;
}
if
(
!
hoursFormatted
&
&
!
minutesFormatted
&
&
!
secondsFormatted
)
{
return
true
;
}
if
(
hoursFormatted
)
{
if
(
signDisplayed
)
{
if
(
hoursValue
.
isZero
(
)
&
&
temporal
:
:
DurationSign
(
duration
)
<
0
)
{
hoursValue
=
DurationValue
{
-
0
.
0
}
;
}
}
else
{
hoursValue
=
hoursValue
.
abs
(
)
;
}
if
(
!
FormatNumericHoursOrMinutesOrSeconds
(
cx
durationFormat
TemporalUnit
:
:
Hour
hoursValue
formatToParts
&
formattedValue
)
)
{
return
false
;
}
numericPartsList
.
infallibleAppend
(
formattedValue
)
;
signDisplayed
=
false
;
}
if
(
minutesFormatted
)
{
if
(
signDisplayed
)
{
if
(
minutesValue
.
isZero
(
)
&
&
temporal
:
:
DurationSign
(
duration
)
<
0
)
{
minutesValue
=
DurationValue
{
-
0
.
0
}
;
}
}
else
{
minutesValue
=
minutesValue
.
abs
(
)
;
}
if
(
!
FormatNumericHoursOrMinutesOrSeconds
(
cx
durationFormat
TemporalUnit
:
:
Minute
minutesValue
formatToParts
&
formattedValue
)
)
{
return
false
;
}
numericPartsList
.
infallibleAppend
(
formattedValue
)
;
signDisplayed
=
false
;
}
if
(
secondsFormatted
)
{
if
(
!
signDisplayed
)
{
secondsValue
=
secondsValue
.
abs
(
)
;
}
if
(
!
FormatNumericHoursOrMinutesOrSeconds
(
cx
durationFormat
TemporalUnit
:
:
Second
secondsValue
formatToParts
&
formattedValue
)
)
{
return
false
;
}
numericPartsList
.
infallibleAppend
(
formattedValue
)
;
}
MOZ_ASSERT
(
numericPartsList
.
length
(
)
>
0
)
;
if
(
numericPartsList
.
length
(
)
<
=
1
)
{
result
.
set
(
numericPartsList
[
0
]
)
;
return
true
;
}
Rooted
<
JSString
*
>
timeSeparator
(
cx
GetTimeSeparator
(
cx
durationFormat
)
)
;
if
(
!
timeSeparator
)
{
return
false
;
}
if
(
!
formatToParts
)
{
Rooted
<
JSString
*
>
string
(
cx
numericPartsList
[
0
]
.
toString
(
)
)
;
Rooted
<
JSString
*
>
nextString
(
cx
)
;
for
(
size_t
i
=
1
;
i
<
numericPartsList
.
length
(
)
;
i
+
+
)
{
string
=
ConcatStrings
<
CanGC
>
(
cx
string
timeSeparator
)
;
if
(
!
string
)
{
return
false
;
}
nextString
=
numericPartsList
[
i
]
.
toString
(
)
;
string
=
ConcatStrings
<
CanGC
>
(
cx
string
nextString
)
;
if
(
!
string
)
{
return
false
;
}
}
result
.
setString
(
string
)
;
}
else
{
size_t
length
=
0
;
for
(
size_t
i
=
0
;
i
<
numericPartsList
.
length
(
)
;
i
+
+
)
{
length
+
=
numericPartsList
[
i
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
.
length
(
)
;
}
length
+
=
numericPartsList
.
length
(
)
-
1
;
Rooted
<
ArrayObject
*
>
array
(
cx
NewDenseFullyAllocatedArray
(
cx
length
)
)
;
if
(
!
array
)
{
return
false
;
}
array
-
>
ensureDenseInitializedLength
(
0
length
)
;
size_t
index
=
0
;
for
(
size_t
i
=
0
;
i
<
numericPartsList
.
length
(
)
;
i
+
+
)
{
if
(
i
>
0
)
{
auto
*
timeSeparatorPart
=
NewLiteralPart
(
cx
timeSeparator
)
;
if
(
!
timeSeparatorPart
)
{
return
false
;
}
array
-
>
initDenseElement
(
index
+
+
ObjectValue
(
*
timeSeparatorPart
)
)
;
}
auto
*
part
=
&
numericPartsList
[
i
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
MOZ_ASSERT
(
IsPackedArray
(
part
)
)
;
for
(
size_t
j
=
0
;
j
<
part
-
>
length
(
)
;
j
+
+
)
{
array
-
>
initDenseElement
(
index
+
+
part
-
>
getDenseElement
(
j
)
)
;
}
}
MOZ_ASSERT
(
index
=
=
length
)
;
result
.
setObject
(
*
array
)
;
}
return
true
;
}
static
mozilla
:
:
intl
:
:
ListFormat
*
NewDurationListFormat
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
Rooted
<
JSObject
*
>
internals
(
cx
GetInternalsObject
(
cx
durationFormat
)
)
;
if
(
!
internals
)
{
return
nullptr
;
}
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
locale
&
value
)
)
{
return
nullptr
;
}
UniqueChars
locale
=
EncodeLocale
(
cx
value
.
toString
(
)
)
;
if
(
!
locale
)
{
return
nullptr
;
}
mozilla
:
:
intl
:
:
ListFormat
:
:
Options
options
;
options
.
mType
=
mozilla
:
:
intl
:
:
ListFormat
:
:
Type
:
:
Unit
;
if
(
!
GetProperty
(
cx
internals
internals
cx
-
>
names
(
)
.
style
&
value
)
)
{
return
nullptr
;
}
{
auto
*
linear
=
value
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
nullptr
;
}
using
ListFormatStyle
=
mozilla
:
:
intl
:
:
ListFormat
:
:
Style
;
if
(
StringEqualsLiteral
(
linear
"
long
"
)
)
{
options
.
mStyle
=
ListFormatStyle
:
:
Long
;
}
else
if
(
StringEqualsLiteral
(
linear
"
short
"
)
)
{
options
.
mStyle
=
ListFormatStyle
:
:
Short
;
}
else
if
(
StringEqualsLiteral
(
linear
"
narrow
"
)
)
{
options
.
mStyle
=
ListFormatStyle
:
:
Narrow
;
}
else
{
MOZ_ASSERT
(
StringEqualsLiteral
(
linear
"
digital
"
)
)
;
options
.
mStyle
=
ListFormatStyle
:
:
Short
;
}
}
auto
result
=
mozilla
:
:
intl
:
:
ListFormat
:
:
TryCreate
(
mozilla
:
:
MakeStringSpan
(
locale
.
get
(
)
)
options
)
;
if
(
result
.
isErr
(
)
)
{
ReportInternalError
(
cx
result
.
unwrapErr
(
)
)
;
return
nullptr
;
}
return
result
.
unwrap
(
)
.
release
(
)
;
}
static
mozilla
:
:
intl
:
:
ListFormat
*
GetOrCreateListFormat
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
)
{
auto
*
lf
=
durationFormat
-
>
getListFormat
(
)
;
if
(
lf
)
{
return
lf
;
}
lf
=
NewDurationListFormat
(
cx
durationFormat
)
;
if
(
!
lf
)
{
return
nullptr
;
}
durationFormat
-
>
setListFormat
(
lf
)
;
AddICUCellMemory
(
durationFormat
ListFormatObject
:
:
EstimatedMemoryUse
)
;
return
lf
;
}
static
constexpr
size_t
FormattedDurationValueVectorCapacity
=
10
;
using
FormattedDurationValueVector
=
JS
:
:
GCVector
<
JS
:
:
Value
FormattedDurationValueVectorCapacity
>
;
static
bool
ListFormatParts
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
Handle
<
FormattedDurationValueVector
>
partitionedPartsList
bool
formatToParts
MutableHandle
<
Value
>
result
)
{
auto
*
lf
=
GetOrCreateListFormat
(
cx
durationFormat
)
;
if
(
!
lf
)
{
return
false
;
}
Vector
<
UniqueTwoByteChars
mozilla
:
:
intl
:
:
DEFAULT_LIST_LENGTH
>
strings
(
cx
)
;
mozilla
:
:
intl
:
:
ListFormat
:
:
StringList
stringList
{
}
;
Rooted
<
JSString
*
>
string
(
cx
)
;
Rooted
<
JSString
*
>
nextString
(
cx
)
;
Rooted
<
ArrayObject
*
>
parts
(
cx
)
;
Rooted
<
NativeObject
*
>
part
(
cx
)
;
Rooted
<
Value
>
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
partitionedPartsList
.
length
(
)
;
i
+
+
)
{
if
(
!
formatToParts
)
{
string
=
partitionedPartsList
[
i
]
.
toString
(
)
;
}
else
{
parts
=
&
partitionedPartsList
[
i
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
MOZ_ASSERT
(
IsPackedArray
(
parts
)
)
;
string
=
cx
-
>
emptyString
(
)
;
for
(
size_t
j
=
0
;
j
<
parts
-
>
length
(
)
;
j
+
+
)
{
part
=
&
parts
-
>
getDenseElement
(
j
)
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
part
-
>
containsPure
(
cx
-
>
names
(
)
.
type
)
&
&
part
-
>
containsPure
(
cx
-
>
names
(
)
.
value
)
"
part
is
a
number
-
formatted
element
"
)
;
if
(
!
GetProperty
(
cx
part
part
cx
-
>
names
(
)
.
value
&
value
)
)
{
return
false
;
}
MOZ_ASSERT
(
value
.
isString
(
)
)
;
nextString
=
value
.
toString
(
)
;
string
=
ConcatStrings
<
CanGC
>
(
cx
string
nextString
)
;
if
(
!
string
)
{
return
false
;
}
}
}
auto
*
linear
=
string
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
size_t
linearLength
=
linear
-
>
length
(
)
;
auto
chars
=
cx
-
>
make_pod_array
<
char16_t
>
(
linearLength
)
;
if
(
!
chars
)
{
return
false
;
}
CopyChars
(
chars
.
get
(
)
*
linear
)
;
if
(
!
strings
.
append
(
std
:
:
move
(
chars
)
)
)
{
return
false
;
}
if
(
!
stringList
.
emplaceBack
(
strings
[
i
]
.
get
(
)
linearLength
)
)
{
return
false
;
}
}
FormatBuffer
<
char16_t
INITIAL_CHAR_BUFFER_SIZE
>
buffer
(
cx
)
;
mozilla
:
:
intl
:
:
ListFormat
:
:
PartVector
partVector
{
}
;
auto
formatResult
=
formatToParts
?
lf
-
>
FormatToParts
(
stringList
buffer
partVector
)
:
lf
-
>
Format
(
stringList
buffer
)
;
if
(
formatResult
.
isErr
(
)
)
{
ReportInternalError
(
cx
formatResult
.
unwrapErr
(
)
)
;
return
false
;
}
Rooted
<
JSLinearString
*
>
overallResult
(
cx
buffer
.
toString
(
cx
)
)
;
if
(
!
overallResult
)
{
return
false
;
}
if
(
!
formatToParts
)
{
result
.
setString
(
overallResult
)
;
return
true
;
}
size_t
partitionedPartsIndex
=
0
;
size_t
flattenedLength
=
0
;
for
(
size_t
i
=
0
;
i
<
partitionedPartsList
.
length
(
)
;
i
+
+
)
{
auto
*
parts
=
&
partitionedPartsList
[
i
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
flattenedLength
+
=
parts
-
>
length
(
)
;
}
for
(
const
auto
&
part
:
partVector
)
{
if
(
part
.
first
=
=
mozilla
:
:
intl
:
:
ListFormat
:
:
PartType
:
:
Literal
)
{
flattenedLength
+
=
1
;
}
}
Rooted
<
ArrayObject
*
>
flattenedPartsList
(
cx
NewDenseFullyAllocatedArray
(
cx
flattenedLength
)
)
;
if
(
!
flattenedPartsList
)
{
return
false
;
}
flattenedPartsList
-
>
ensureDenseInitializedLength
(
0
flattenedLength
)
;
size_t
flattenedPartsIndex
=
0
;
size_t
partBeginIndex
=
0
;
for
(
const
auto
&
part
:
partVector
)
{
if
(
part
.
first
=
=
mozilla
:
:
intl
:
:
ListFormat
:
:
PartType
:
:
Element
)
{
MOZ_ASSERT
(
partitionedPartsIndex
<
partitionedPartsList
.
length
(
)
"
partitionedPartsIndex
is
an
index
into
result
"
)
;
auto
*
parts
=
&
partitionedPartsList
[
partitionedPartsIndex
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
MOZ_ASSERT
(
IsPackedArray
(
parts
)
)
;
for
(
size_t
i
=
0
;
i
<
parts
-
>
length
(
)
;
i
+
+
)
{
flattenedPartsList
-
>
initDenseElement
(
flattenedPartsIndex
+
+
parts
-
>
getDenseElement
(
i
)
)
;
}
partitionedPartsIndex
+
=
1
;
}
else
{
MOZ_ASSERT
(
part
.
first
=
=
mozilla
:
:
intl
:
:
ListFormat
:
:
PartType
:
:
Literal
)
;
MOZ_ASSERT
(
part
.
second
>
=
partBeginIndex
)
;
auto
*
partStr
=
NewDependentString
(
cx
overallResult
partBeginIndex
part
.
second
-
partBeginIndex
)
;
if
(
!
partStr
)
{
return
false
;
}
auto
*
literalPart
=
NewLiteralPart
(
cx
partStr
)
;
if
(
!
literalPart
)
{
return
false
;
}
flattenedPartsList
-
>
initDenseElement
(
flattenedPartsIndex
+
+
ObjectValue
(
*
literalPart
)
)
;
}
partBeginIndex
=
part
.
second
;
}
MOZ_ASSERT
(
partitionedPartsIndex
=
=
partitionedPartsList
.
length
(
)
"
all
number
-
formatted
parts
handled
"
)
;
MOZ_ASSERT
(
flattenedPartsIndex
=
=
flattenedLength
"
flattened
array
length
miscomputed
"
)
;
result
.
setObject
(
*
flattenedPartsList
)
;
return
true
;
}
static
bool
PartitionDurationFormatPattern
(
JSContext
*
cx
Handle
<
DurationFormatObject
*
>
durationFormat
Handle
<
Value
>
durationLike
bool
formatToParts
MutableHandle
<
Value
>
result
)
{
using
namespace
temporal
;
Duration
duration
;
if
(
!
ToTemporalDuration
(
cx
durationLike
&
duration
)
)
{
return
false
;
}
duration
.
years
+
=
+
0
.
0
;
duration
.
months
+
=
+
0
.
0
;
duration
.
weeks
+
=
+
0
.
0
;
duration
.
days
+
=
+
0
.
0
;
duration
.
hours
+
=
+
0
.
0
;
duration
.
minutes
+
=
+
0
.
0
;
duration
.
seconds
+
=
+
0
.
0
;
duration
.
milliseconds
+
=
+
0
.
0
;
duration
.
microseconds
+
=
+
0
.
0
;
duration
.
nanoseconds
+
=
+
0
.
0
;
static_assert
(
durationUnits
.
size
(
)
=
=
FormattedDurationValueVectorCapacity
"
inline
stack
capacity
large
enough
for
all
duration
units
"
)
;
auto
*
options
=
GetOrCreateDurationFormatOptions
(
cx
durationFormat
)
;
if
(
!
options
)
{
return
false
;
}
Rooted
<
Value
>
formattedValue
(
cx
)
;
Rooted
<
FormattedDurationValueVector
>
formattedValues
(
cx
cx
)
;
if
(
!
formattedValues
.
reserve
(
FormattedDurationValueVectorCapacity
)
)
{
return
false
;
}
bool
signDisplayed
=
true
;
bool
numericUnitFound
=
false
;
for
(
auto
unit
:
durationUnits
)
{
if
(
numericUnitFound
)
{
break
;
}
auto
unitOptions
=
GetUnitOptions
(
*
options
unit
)
;
auto
style
=
unitOptions
.
style
(
)
;
auto
display
=
unitOptions
.
display
(
)
;
if
(
style
=
=
DurationStyle
:
:
Numeric
|
|
style
=
=
DurationStyle
:
:
TwoDigit
)
{
if
(
!
FormatNumericUnits
(
cx
durationFormat
duration
unit
signDisplayed
formatToParts
&
formattedValue
)
)
{
return
false
;
}
if
(
!
formattedValue
.
isUndefined
(
)
)
{
formattedValues
.
infallibleAppend
(
formattedValue
)
;
}
numericUnitFound
=
true
;
}
else
{
auto
value
=
ToDurationValue
(
duration
unit
)
;
if
(
NextUnitFractional
(
durationFormat
unit
)
)
{
value
=
ComputeFractionalDigits
(
duration
unit
)
;
numericUnitFound
=
true
;
}
if
(
display
=
=
DurationDisplay
:
:
Auto
&
&
value
.
isZero
(
)
)
{
continue
;
}
if
(
signDisplayed
)
{
signDisplayed
=
false
;
if
(
value
.
isZero
(
)
&
&
temporal
:
:
DurationSign
(
duration
)
<
0
)
{
value
=
DurationValue
{
-
0
.
0
}
;
}
}
else
{
value
=
value
.
abs
(
)
;
}
auto
*
nf
=
GetOrCreateNumberFormat
(
cx
durationFormat
unit
style
)
;
if
(
!
nf
)
{
return
false
;
}
if
(
!
FormatDurationValue
(
cx
nf
unit
value
formatToParts
&
formattedValue
)
)
{
return
false
;
}
formattedValues
.
infallibleAppend
(
formattedValue
)
;
}
}
return
ListFormatParts
(
cx
durationFormat
formattedValues
formatToParts
result
)
;
}
static
bool
IsDurationFormat
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
DurationFormatObject
>
(
)
;
}
static
bool
durationFormat_format
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
Rooted
<
DurationFormatObject
*
>
durationFormat
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationFormatObject
>
(
)
)
;
return
PartitionDurationFormatPattern
(
cx
durationFormat
args
.
get
(
0
)
false
args
.
rval
(
)
)
;
}
static
bool
durationFormat_format
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDurationFormat
durationFormat_format
>
(
cx
args
)
;
}
static
bool
durationFormat_formatToParts
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
Rooted
<
DurationFormatObject
*
>
durationFormat
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
DurationFormatObject
>
(
)
)
;
return
PartitionDurationFormatPattern
(
cx
durationFormat
args
.
get
(
0
)
true
args
.
rval
(
)
)
;
}
static
bool
durationFormat_formatToParts
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsDurationFormat
durationFormat_formatToParts
>
(
cx
args
)
;
}
bool
js
:
:
TemporalDurationToLocaleString
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
thisv
(
)
.
isObject
(
)
)
;
MOZ_ASSERT
(
args
.
thisv
(
)
.
toObject
(
)
.
is
<
temporal
:
:
DurationObject
>
(
)
)
;
Rooted
<
DurationFormatObject
*
>
durationFormat
(
cx
NewBuiltinClassInstance
<
DurationFormatObject
>
(
cx
)
)
;
if
(
!
durationFormat
)
{
return
false
;
}
if
(
!
intl
:
:
InitializeObject
(
cx
durationFormat
cx
-
>
names
(
)
.
InitializeDurationFormat
args
.
get
(
0
)
args
.
get
(
1
)
)
)
{
return
false
;
}
return
PartitionDurationFormatPattern
(
cx
durationFormat
args
.
thisv
(
)
false
args
.
rval
(
)
)
;
}
