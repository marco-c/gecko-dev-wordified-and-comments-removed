var
internalIntlRegExps
=
std_Object_create
(
null
)
;
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
null
;
internalIntlRegExps
.
languageTagRE
=
null
;
internalIntlRegExps
.
duplicateVariantRE
=
null
;
internalIntlRegExps
.
duplicateSingletonRE
=
null
;
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
=
null
;
internalIntlRegExps
.
currencyDigitsRE
=
null
;
function
getUnicodeLocaleExtensionSequenceRE
(
)
{
return
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
|
|
(
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
RegExpCreate
(
"
-
u
(
?
:
-
[
a
-
z0
-
9
]
{
2
8
}
)
+
"
)
)
;
}
function
removeUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
locale
;
var
pos
=
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
;
if
(
pos
<
0
)
pos
=
locale
.
length
;
var
left
=
callFunction
(
String_substring
locale
0
pos
)
;
var
right
=
callFunction
(
String_substring
locale
pos
)
;
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensions
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
left
)
;
if
(
extensions
!
=
=
null
)
{
left
=
callFunction
(
String_substring
left
0
extensions
.
index
)
+
callFunction
(
String_substring
left
extensions
.
index
+
extensions
[
0
]
.
length
)
;
}
var
combined
=
left
+
right
;
assert
(
IsStructurallyValidLanguageTag
(
combined
)
"
recombination
produced
an
invalid
language
tag
"
)
;
assert
(
function
(
)
{
var
uindex
=
callFunction
(
std_String_indexOf
combined
"
-
u
-
"
)
;
if
(
uindex
<
0
)
return
true
;
var
xindex
=
callFunction
(
std_String_indexOf
combined
"
-
x
-
"
)
;
return
xindex
>
0
&
&
xindex
<
uindex
;
}
(
)
"
recombination
failed
to
remove
all
Unicode
locale
extension
sequences
"
)
;
return
combined
;
}
function
getLanguageTagRE
(
)
{
if
(
internalIntlRegExps
.
languageTagRE
)
return
internalIntlRegExps
.
languageTagRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
regular
=
"
(
?
:
art
-
lojban
|
cel
-
gaulish
|
no
-
bok
|
no
-
nyn
|
zh
-
guoyu
|
zh
-
hakka
|
zh
-
min
|
zh
-
min
-
nan
|
zh
-
xiang
)
"
;
var
irregular
=
"
(
?
:
en
-
GB
-
oed
|
i
-
ami
|
i
-
bnn
|
i
-
default
|
i
-
enochian
|
i
-
hak
|
i
-
klingon
|
i
-
lux
|
i
-
mingo
|
i
-
navajo
|
i
-
pwn
|
i
-
tao
|
i
-
tay
|
i
-
tsu
|
sgn
-
BE
-
FR
|
sgn
-
BE
-
NL
|
sgn
-
CH
-
DE
)
"
;
var
grandfathered
=
"
(
?
:
"
+
irregular
+
"
|
"
+
regular
+
"
)
"
;
var
privateuse
=
"
(
?
:
x
(
?
:
-
[
a
-
z0
-
9
]
{
1
8
}
)
+
)
"
;
var
singleton
=
"
(
?
:
"
+
DIGIT
+
"
|
[
A
-
WY
-
Za
-
wy
-
z
]
)
"
;
var
extension
=
"
(
?
:
"
+
singleton
+
"
(
?
:
-
"
+
alphanum
+
"
{
2
8
}
)
+
)
"
;
var
variant
=
"
(
?
:
"
+
alphanum
+
"
{
5
8
}
|
(
?
:
"
+
DIGIT
+
alphanum
+
"
{
3
}
)
)
"
;
var
region
=
"
(
?
:
"
+
ALPHA
+
"
{
2
}
|
"
+
DIGIT
+
"
{
3
}
)
"
;
var
script
=
"
(
?
:
"
+
ALPHA
+
"
{
4
}
)
"
;
var
extlang
=
"
(
?
:
"
+
ALPHA
+
"
{
3
}
(
?
:
-
"
+
ALPHA
+
"
{
3
}
)
{
0
2
}
)
"
;
var
language
=
"
(
?
:
"
+
ALPHA
+
"
{
2
3
}
(
?
:
-
"
+
extlang
+
"
)
?
|
"
+
ALPHA
+
"
{
4
}
|
"
+
ALPHA
+
"
{
5
8
}
)
"
;
var
langtag
=
language
+
"
(
?
:
-
"
+
script
+
"
)
?
(
?
:
-
"
+
region
+
"
)
?
(
?
:
-
"
+
variant
+
"
)
*
(
?
:
-
"
+
extension
+
"
)
*
(
?
:
-
"
+
privateuse
+
"
)
?
"
;
var
languageTag
=
"
^
(
?
:
"
+
langtag
+
"
|
"
+
privateuse
+
"
|
"
+
grandfathered
+
"
)
"
;
return
(
internalIntlRegExps
.
languageTagRE
=
RegExpCreate
(
languageTag
"
i
"
)
)
;
}
function
getDuplicateVariantRE
(
)
{
if
(
internalIntlRegExps
.
duplicateVariantRE
)
return
internalIntlRegExps
.
duplicateVariantRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
variant
=
"
(
?
:
"
+
alphanum
+
"
{
5
8
}
|
(
?
:
"
+
DIGIT
+
alphanum
+
"
{
3
}
)
)
"
;
var
duplicateVariant
=
"
^
(
?
:
"
+
alphanum
+
"
{
2
8
}
-
)
+
"
+
"
(
"
+
variant
+
"
)
-
"
+
"
(
?
:
"
+
alphanum
+
"
{
2
8
}
-
)
*
"
+
"
\
\
1
"
+
"
(
?
!
"
+
alphanum
+
"
)
"
;
return
(
internalIntlRegExps
.
duplicateVariantRE
=
RegExpCreate
(
duplicateVariant
"
i
"
)
)
;
}
function
getDuplicateSingletonRE
(
)
{
if
(
internalIntlRegExps
.
duplicateSingletonRE
)
return
internalIntlRegExps
.
duplicateSingletonRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
singleton
=
"
(
?
:
"
+
DIGIT
+
"
|
[
A
-
WY
-
Za
-
wy
-
z
]
)
"
;
var
duplicateSingleton
=
"
-
(
"
+
singleton
+
"
)
-
"
+
"
(
?
:
"
+
alphanum
+
"
+
-
)
*
"
+
"
\
\
1
"
+
"
(
?
!
"
+
alphanum
+
"
)
"
;
return
(
internalIntlRegExps
.
duplicateSingletonRE
=
RegExpCreate
(
duplicateSingleton
"
i
"
)
)
;
}
function
IsStructurallyValidLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
IsStructurallyValidLanguageTag
"
)
;
var
languageTagRE
=
getLanguageTagRE
(
)
;
if
(
!
regexp_test_no_statics
(
languageTagRE
locale
)
)
return
false
;
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
true
;
var
pos
=
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
;
if
(
pos
!
=
=
-
1
)
locale
=
callFunction
(
String_substring
locale
0
pos
)
;
var
duplicateVariantRE
=
getDuplicateVariantRE
(
)
;
var
duplicateSingletonRE
=
getDuplicateSingletonRE
(
)
;
return
!
regexp_test_no_statics
(
duplicateVariantRE
locale
)
&
&
!
regexp_test_no_statics
(
duplicateSingletonRE
locale
)
;
}
function
ArrayJoinRange
(
array
separator
from
to
=
array
.
length
)
{
assert
(
typeof
separator
=
=
=
"
string
"
"
|
separator
|
is
a
string
value
"
)
;
assert
(
typeof
from
=
=
=
"
number
"
"
|
from
|
is
a
number
value
"
)
;
assert
(
typeof
to
=
=
=
"
number
"
"
|
to
|
is
a
number
value
"
)
;
assert
(
0
<
=
from
&
&
from
<
=
to
&
&
to
<
=
array
.
length
"
|
from
|
and
|
to
|
form
a
valid
range
"
)
;
if
(
from
=
=
=
to
)
return
"
"
;
var
result
=
array
[
from
]
;
for
(
var
i
=
from
+
1
;
i
<
to
;
i
+
+
)
{
result
+
=
separator
+
array
[
i
]
;
}
return
result
;
}
function
CanonicalizeLanguageTag
(
locale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
CanonicalizeLanguageTag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
if
(
hasOwn
(
locale
langTagMappings
)
)
return
langTagMappings
[
locale
]
;
var
subtags
=
StringSplitString
(
locale
"
-
"
)
;
var
i
=
0
;
while
(
i
<
subtags
.
length
)
{
var
subtag
=
subtags
[
i
]
;
if
(
subtag
.
length
=
=
=
1
&
&
(
i
>
0
|
|
subtag
=
=
=
"
x
"
)
)
break
;
if
(
i
!
=
=
0
)
{
if
(
subtag
.
length
=
=
=
4
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
[
0
]
)
+
callFunction
(
String_substring
subtag
1
)
;
}
else
if
(
subtag
.
length
=
=
=
2
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
)
;
}
}
if
(
hasOwn
(
subtag
langSubtagMappings
)
)
{
subtag
=
langSubtagMappings
[
subtag
]
;
}
else
if
(
hasOwn
(
subtag
extlangMappings
)
)
{
if
(
i
=
=
=
1
&
&
extlangMappings
[
subtag
]
=
=
=
subtags
[
0
]
)
{
callFunction
(
std_Array_shift
subtags
)
;
i
-
-
;
}
}
subtags
[
i
]
=
subtag
;
i
+
+
;
}
if
(
i
=
=
=
subtags
.
length
)
return
callFunction
(
std_Array_join
subtags
"
-
"
)
;
var
normal
=
ArrayJoinRange
(
subtags
"
-
"
0
i
)
;
var
extensions
=
[
]
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
!
=
=
"
x
"
)
{
var
extensionStart
=
i
;
i
+
+
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
.
length
>
1
)
i
+
+
;
var
extension
=
ArrayJoinRange
(
subtags
"
-
"
extensionStart
i
)
;
_DefineDataProperty
(
extensions
extensions
.
length
extension
)
;
}
callFunction
(
ArraySort
extensions
)
;
var
privateUse
=
"
"
;
if
(
i
<
subtags
.
length
)
privateUse
=
ArrayJoinRange
(
subtags
"
-
"
i
)
;
var
canonical
=
normal
;
if
(
extensions
.
length
>
0
)
canonical
+
=
"
-
"
+
callFunction
(
std_Array_join
extensions
"
-
"
)
;
if
(
privateUse
.
length
>
0
)
{
if
(
canonical
.
length
>
0
)
canonical
+
=
"
-
"
+
privateUse
;
else
canonical
=
privateUse
;
}
return
canonical
;
}
function
IsASCIIAlphaString
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
IsASCIIAlphaString
"
)
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
if
(
!
(
(
0x41
<
=
c
&
&
c
<
=
0x5A
)
|
|
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
)
)
return
false
;
}
return
true
;
}
function
ValidateAndCanonicalizeLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
ValidateAndCanonicalizeLanguageTag
"
)
;
if
(
locale
.
length
=
=
=
2
|
|
(
locale
.
length
=
=
=
3
&
&
locale
[
1
]
!
=
=
"
-
"
)
)
{
if
(
!
IsASCIIAlphaString
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
2
*
3ALPHA
is
a
valid
language
tag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
assert
(
!
hasOwn
(
locale
langTagMappings
)
"
langTagMappings
contains
no
2
*
3ALPHA
mappings
"
)
;
locale
=
hasOwn
(
locale
langSubtagMappings
)
?
langSubtagMappings
[
locale
]
:
locale
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
expected
same
canonicalization
"
)
;
return
locale
;
}
if
(
!
IsStructurallyValidLanguageTag
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
return
CanonicalizeLanguageTag
(
locale
)
;
}
function
localeContainsNoUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
=
=
=
-
1
)
return
true
;
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
>
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
)
return
true
;
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
true
;
return
false
;
}
function
lastDitchLocale
(
)
{
return
"
en
-
GB
"
;
}
var
oldStyleLanguageTagMappings
=
{
"
pa
-
PK
"
:
"
pa
-
Arab
-
PK
"
"
zh
-
CN
"
:
"
zh
-
Hans
-
CN
"
"
zh
-
HK
"
:
"
zh
-
Hant
-
HK
"
"
zh
-
SG
"
:
"
zh
-
Hans
-
SG
"
"
zh
-
TW
"
:
"
zh
-
Hant
-
TW
"
}
;
var
localeCandidateCache
=
{
runtimeDefaultLocale
:
undefined
candidateDefaultLocale
:
undefined
}
;
var
localeCache
=
{
runtimeDefaultLocale
:
undefined
defaultLocale
:
undefined
}
;
function
DefaultLocaleIgnoringAvailableLocales
(
)
{
const
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
if
(
runtimeDefaultLocale
=
=
=
localeCandidateCache
.
runtimeDefaultLocale
)
return
localeCandidateCache
.
candidateDefaultLocale
;
var
candidate
;
if
(
!
IsStructurallyValidLanguageTag
(
runtimeDefaultLocale
)
)
{
candidate
=
lastDitchLocale
(
)
;
}
else
{
candidate
=
CanonicalizeLanguageTag
(
runtimeDefaultLocale
)
;
candidate
=
removeUnicodeExtensions
(
candidate
)
;
if
(
hasOwn
(
candidate
oldStyleLanguageTagMappings
)
)
candidate
=
oldStyleLanguageTagMappings
[
candidate
]
;
}
localeCandidateCache
.
candidateDefaultLocale
=
candidate
;
localeCandidateCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
assert
(
IsStructurallyValidLanguageTag
(
candidate
)
"
the
candidate
must
be
structurally
valid
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
candidate
)
"
the
candidate
must
not
contain
a
Unicode
extension
sequence
"
)
;
return
candidate
;
}
function
DefaultLocale
(
)
{
if
(
IsRuntimeDefaultLocale
(
localeCache
.
runtimeDefaultLocale
)
)
return
localeCache
.
defaultLocale
;
var
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
var
candidate
=
DefaultLocaleIgnoringAvailableLocales
(
)
;
var
locale
;
if
(
BestAvailableLocaleIgnoringDefault
(
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
dateTimeFormatInternalProperties
.
availableLocales
dateTimeFormatInternalProperties
)
candidate
)
)
{
locale
=
candidate
;
}
else
{
locale
=
lastDitchLocale
(
)
;
}
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
structurally
valid
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
canonical
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
the
computed
default
locale
must
not
contain
a
Unicode
extension
sequence
"
)
;
localeCache
.
defaultLocale
=
locale
;
localeCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
return
locale
;
}
function
addSpecialMissingLanguageTags
(
availableLocales
)
{
var
oldStyleLocales
=
std_Object_getOwnPropertyNames
(
oldStyleLanguageTagMappings
)
;
for
(
var
i
=
0
;
i
<
oldStyleLocales
.
length
;
i
+
+
)
{
var
oldStyleLocale
=
oldStyleLocales
[
i
]
;
if
(
availableLocales
[
oldStyleLanguageTagMappings
[
oldStyleLocale
]
]
)
availableLocales
[
oldStyleLocale
]
=
true
;
}
var
lastDitch
=
lastDitchLocale
(
)
;
assert
(
lastDitch
=
=
=
"
en
-
GB
"
&
&
availableLocales
.
en
"
shouldn
'
t
be
a
need
to
add
every
locale
implied
by
the
last
-
"
+
"
ditch
locale
merely
just
the
last
-
ditch
locale
"
)
;
availableLocales
[
lastDitch
]
=
true
;
}
function
CanonicalizeLocaleList
(
locales
)
{
if
(
locales
=
=
=
undefined
)
return
[
]
;
if
(
typeof
locales
=
=
=
"
string
"
)
{
if
(
!
IsStructurallyValidLanguageTag
(
locales
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locales
)
;
return
[
CanonicalizeLanguageTag
(
locales
)
]
;
}
var
seen
=
[
]
;
var
O
=
ToObject
(
locales
)
;
var
len
=
ToLength
(
O
.
length
)
;
var
k
=
0
;
while
(
k
<
len
)
{
var
kPresent
=
HasProperty
(
O
k
)
;
if
(
kPresent
)
{
var
kValue
=
O
[
k
]
;
if
(
!
(
typeof
kValue
=
=
=
"
string
"
|
|
IsObject
(
kValue
)
)
)
ThrowTypeError
(
JSMSG_INVALID_LOCALES_ELEMENT
)
;
var
tag
=
ToString
(
kValue
)
;
if
(
!
IsStructurallyValidLanguageTag
(
tag
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
tag
)
;
tag
=
CanonicalizeLanguageTag
(
tag
)
;
if
(
callFunction
(
ArrayIndexOf
seen
tag
)
=
=
=
-
1
)
_DefineDataProperty
(
seen
seen
.
length
tag
)
;
}
k
+
+
;
}
return
seen
;
}
function
BestAvailableLocaleHelper
(
availableLocales
locale
considerDefaultLocale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
invalid
BestAvailableLocale
locale
structure
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
non
-
canonical
BestAvailableLocale
locale
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
locale
must
contain
no
Unicode
extensions
"
)
;
var
defaultLocale
;
if
(
considerDefaultLocale
)
defaultLocale
=
DefaultLocale
(
)
;
var
candidate
=
locale
;
while
(
true
)
{
if
(
availableLocales
[
candidate
]
)
return
candidate
;
if
(
considerDefaultLocale
&
&
candidate
.
length
<
=
defaultLocale
.
length
)
{
if
(
candidate
=
=
=
defaultLocale
)
return
candidate
;
if
(
callFunction
(
std_String_startsWith
defaultLocale
candidate
+
"
-
"
)
)
return
candidate
;
}
var
pos
=
callFunction
(
std_String_lastIndexOf
candidate
"
-
"
)
;
if
(
pos
=
=
=
-
1
)
return
undefined
;
if
(
pos
>
=
2
&
&
candidate
[
pos
-
2
]
=
=
=
"
-
"
)
pos
-
=
2
;
candidate
=
callFunction
(
String_substring
candidate
0
pos
)
;
}
}
function
BestAvailableLocale
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
true
)
;
}
function
BestAvailableLocaleIgnoringDefault
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
false
)
;
}
function
LookupMatcher
(
availableLocales
requestedLocales
)
{
var
i
=
0
;
var
len
=
requestedLocales
.
length
;
var
availableLocale
;
var
locale
noExtensionsLocale
;
while
(
i
<
len
&
&
availableLocale
=
=
=
undefined
)
{
locale
=
requestedLocales
[
i
]
;
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
i
+
+
;
}
var
result
=
new
Record
(
)
;
if
(
availableLocale
!
=
=
undefined
)
{
result
.
locale
=
availableLocale
;
if
(
locale
!
=
=
noExtensionsLocale
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
locale
)
;
result
.
extension
=
extensionMatch
[
0
]
;
}
}
else
{
result
.
locale
=
DefaultLocale
(
)
;
}
return
result
;
}
function
BestFitMatcher
(
availableLocales
requestedLocales
)
{
return
LookupMatcher
(
availableLocales
requestedLocales
)
;
}
function
UnicodeExtensionValue
(
extension
key
)
{
assert
(
typeof
extension
=
=
=
"
string
"
"
extension
is
a
string
value
"
)
;
assert
(
function
(
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
extension
)
;
return
extensionMatch
!
=
=
null
&
&
extensionMatch
[
0
]
=
=
=
extension
;
}
(
)
"
extension
is
a
Unicode
extension
subtag
"
)
;
assert
(
typeof
key
=
=
=
"
string
"
"
key
is
a
string
value
"
)
;
assert
(
key
.
length
=
=
=
2
"
key
is
a
Unicode
extension
key
subtag
"
)
;
var
size
=
extension
.
length
;
var
searchValue
=
"
-
"
+
key
+
"
-
"
;
var
pos
=
callFunction
(
std_String_indexOf
extension
searchValue
)
;
if
(
pos
!
=
=
-
1
)
{
var
start
=
pos
+
4
;
var
end
=
start
;
var
k
=
start
;
while
(
true
)
{
var
e
=
callFunction
(
std_String_indexOf
extension
"
-
"
k
)
;
var
len
=
e
=
=
=
-
1
?
size
-
k
:
e
-
k
;
if
(
len
=
=
=
2
)
break
;
if
(
e
=
=
=
-
1
)
{
end
=
size
;
break
;
}
end
=
e
;
k
=
e
+
1
;
}
return
callFunction
(
String_substring
extension
start
end
)
;
}
searchValue
=
"
-
"
+
key
;
if
(
callFunction
(
std_String_endsWith
extension
searchValue
)
)
return
"
"
;
}
function
ResolveLocale
(
availableLocales
requestedLocales
options
relevantExtensionKeys
localeData
)
{
var
matcher
=
options
.
localeMatcher
;
var
r
=
(
matcher
=
=
=
"
lookup
"
)
?
LookupMatcher
(
availableLocales
requestedLocales
)
:
BestFitMatcher
(
availableLocales
requestedLocales
)
;
var
foundLocale
=
r
.
locale
;
var
extension
=
r
.
extension
;
var
result
=
new
Record
(
)
;
result
.
dataLocale
=
foundLocale
;
var
supportedExtension
=
"
-
u
"
;
var
localeDataProvider
=
localeData
(
)
;
for
(
var
i
=
0
;
i
<
relevantExtensionKeys
.
length
;
i
+
+
)
{
var
key
=
relevantExtensionKeys
[
i
]
;
var
keyLocaleData
=
undefined
;
var
value
=
undefined
;
var
supportedExtensionAddition
=
"
"
;
if
(
extension
!
=
=
undefined
)
{
var
requestedValue
=
UnicodeExtensionValue
(
extension
key
)
;
if
(
requestedValue
!
=
=
undefined
)
{
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
requestedValue
!
=
=
"
"
)
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
requestedValue
)
!
=
=
-
1
)
{
value
=
requestedValue
;
supportedExtensionAddition
=
"
-
"
+
key
+
"
-
"
+
value
;
}
}
else
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
"
true
"
)
!
=
=
-
1
)
value
=
"
true
"
;
}
}
}
var
optionsValue
=
options
[
key
]
;
if
(
optionsValue
!
=
=
undefined
&
&
optionsValue
!
=
=
value
)
{
if
(
keyLocaleData
=
=
=
undefined
)
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
optionsValue
)
!
=
=
-
1
)
{
value
=
optionsValue
;
supportedExtensionAddition
=
"
"
;
}
}
if
(
value
=
=
=
undefined
)
{
value
=
keyLocaleData
=
=
=
undefined
?
callFunction
(
localeDataProvider
.
default
[
key
]
null
foundLocale
)
:
keyLocaleData
[
0
]
;
}
assert
(
typeof
value
=
=
=
"
string
"
|
|
value
=
=
=
null
"
unexpected
locale
data
value
"
)
;
result
[
key
]
=
value
;
supportedExtension
+
=
supportedExtensionAddition
;
}
if
(
supportedExtension
.
length
>
2
)
{
assert
(
!
callFunction
(
std_String_startsWith
foundLocale
"
x
-
"
)
"
unexpected
privateuse
-
only
locale
returned
from
ICU
"
)
;
var
privateIndex
=
callFunction
(
std_String_indexOf
foundLocale
"
-
x
-
"
)
;
if
(
privateIndex
=
=
=
-
1
)
{
foundLocale
+
=
supportedExtension
;
}
else
{
var
preExtension
=
callFunction
(
String_substring
foundLocale
0
privateIndex
)
;
var
postExtension
=
callFunction
(
String_substring
foundLocale
privateIndex
)
;
foundLocale
=
preExtension
+
supportedExtension
+
postExtension
;
}
assert
(
IsStructurallyValidLanguageTag
(
foundLocale
)
"
invalid
locale
after
concatenation
"
)
;
assert
(
foundLocale
=
=
=
CanonicalizeLanguageTag
(
foundLocale
)
"
same
locale
with
extension
"
)
;
}
result
.
locale
=
foundLocale
;
return
result
;
}
function
LookupSupportedLocales
(
availableLocales
requestedLocales
)
{
var
len
=
requestedLocales
.
length
;
var
subset
=
[
]
;
var
k
=
0
;
while
(
k
<
len
)
{
var
locale
=
requestedLocales
[
k
]
;
var
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
var
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
if
(
availableLocale
!
=
=
undefined
)
_DefineDataProperty
(
subset
subset
.
length
locale
)
;
k
+
+
;
}
return
subset
;
}
function
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
{
return
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
}
function
SupportedLocales
(
availableLocales
requestedLocales
options
)
{
var
matcher
;
if
(
options
!
=
=
undefined
)
{
options
=
ToObject
(
options
)
;
matcher
=
options
.
localeMatcher
;
if
(
matcher
!
=
=
undefined
)
{
matcher
=
ToString
(
matcher
)
;
if
(
matcher
!
=
=
"
lookup
"
&
&
matcher
!
=
=
"
best
fit
"
)
ThrowRangeError
(
JSMSG_INVALID_LOCALE_MATCHER
matcher
)
;
}
}
var
subset
=
(
matcher
=
=
=
undefined
|
|
matcher
=
=
=
"
best
fit
"
)
?
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
:
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
for
(
var
i
=
0
;
i
<
subset
.
length
;
i
+
+
)
{
_DefineDataProperty
(
subset
i
subset
[
i
]
ATTR_ENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
}
_DefineDataProperty
(
subset
"
length
"
subset
.
length
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
subset
;
}
function
GetOption
(
options
property
type
values
fallback
)
{
var
value
=
options
[
property
]
;
if
(
value
!
=
=
undefined
)
{
if
(
type
=
=
=
"
boolean
"
)
value
=
ToBoolean
(
value
)
;
else
if
(
type
=
=
=
"
string
"
)
value
=
ToString
(
value
)
;
else
assert
(
false
"
GetOption
"
)
;
if
(
values
!
=
=
undefined
&
&
callFunction
(
ArrayIndexOf
values
value
)
=
=
=
-
1
)
ThrowRangeError
(
JSMSG_INVALID_OPTION_VALUE
property
value
)
;
return
value
;
}
return
fallback
;
}
function
DefaultNumberOption
(
value
minimum
maximum
fallback
)
{
assert
(
typeof
minimum
=
=
=
"
number
"
&
&
(
minimum
|
0
)
=
=
=
minimum
"
DefaultNumberOption
"
)
;
assert
(
typeof
maximum
=
=
=
"
number
"
&
&
(
maximum
|
0
)
=
=
=
maximum
"
DefaultNumberOption
"
)
;
assert
(
typeof
fallback
=
=
=
"
number
"
&
&
(
fallback
|
0
)
=
=
=
fallback
"
DefaultNumberOption
"
)
;
assert
(
minimum
<
=
fallback
&
&
fallback
<
=
maximum
"
DefaultNumberOption
"
)
;
if
(
value
!
=
=
undefined
)
{
value
=
ToNumber
(
value
)
;
if
(
Number_isNaN
(
value
)
|
|
value
<
minimum
|
|
value
>
maximum
)
ThrowRangeError
(
JSMSG_INVALID_DIGITS_VALUE
value
)
;
return
std_Math_floor
(
value
)
|
0
;
}
return
fallback
;
}
function
GetNumberOption
(
options
property
minimum
maximum
fallback
)
{
return
DefaultNumberOption
(
options
[
property
]
minimum
maximum
fallback
)
;
}
var
intlFallbackSymbolHolder
=
{
value
:
undefined
}
;
function
intlFallbackSymbol
(
)
{
var
fallbackSymbol
=
intlFallbackSymbolHolder
.
value
;
if
(
!
fallbackSymbol
)
{
fallbackSymbol
=
std_Symbol
(
"
IntlLegacyConstructedSymbol
"
)
;
intlFallbackSymbolHolder
.
value
=
fallbackSymbol
;
}
return
fallbackSymbol
;
}
function
initializeIntlObject
(
obj
type
lazyData
)
{
assert
(
IsObject
(
obj
)
"
Non
-
object
passed
to
initializeIntlObject
"
)
;
assert
(
(
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
IsObject
(
lazyData
)
"
non
-
object
lazy
data
"
)
;
var
internals
=
std_Object_create
(
null
)
;
internals
.
type
=
type
;
internals
.
lazyData
=
lazyData
;
internals
.
internalProps
=
null
;
assert
(
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
=
=
=
null
"
Internal
slot
already
initialized
?
"
)
;
UnsafeSetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
internals
)
;
}
function
setInternalProperties
(
internals
internalProps
)
{
assert
(
IsObject
(
internals
.
lazyData
)
"
lazy
data
must
exist
already
"
)
;
assert
(
IsObject
(
internalProps
)
"
internalProps
argument
should
be
an
object
"
)
;
internals
.
internalProps
=
internalProps
;
internals
.
lazyData
=
null
;
}
function
maybeInternalProperties
(
internals
)
{
assert
(
IsObject
(
internals
)
"
non
-
object
passed
to
maybeInternalProperties
"
)
;
var
lazyData
=
internals
.
lazyData
;
if
(
lazyData
)
return
null
;
assert
(
IsObject
(
internals
.
internalProps
)
"
missing
lazy
data
and
computed
internals
"
)
;
return
internals
.
internalProps
;
}
function
getIntlObjectInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Object
"
)
;
assert
(
IsCollator
(
obj
)
|
|
IsDateTimeFormat
(
obj
)
|
|
IsNumberFormat
(
obj
)
|
|
IsPluralRules
(
obj
)
|
|
IsRelativeTimeFormat
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Intl
object
"
)
;
var
internals
=
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
;
assert
(
IsObject
(
internals
)
"
internals
not
an
object
"
)
;
assert
(
hasOwn
(
"
type
"
internals
)
"
missing
type
"
)
;
assert
(
(
internals
.
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
hasOwn
(
"
lazyData
"
internals
)
"
missing
lazyData
"
)
;
assert
(
hasOwn
(
"
internalProps
"
internals
)
"
missing
internalProps
"
)
;
return
internals
;
}
function
getInternals
(
obj
)
{
var
internals
=
getIntlObjectInternals
(
obj
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
var
type
=
internals
.
type
;
if
(
type
=
=
=
"
Collator
"
)
internalProps
=
resolveCollatorInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
DateTimeFormat
"
)
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
NumberFormat
"
)
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
else
internalProps
=
resolvePluralRulesInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
