var
internalIntlRegExps
=
std_Object_create
(
null
)
;
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
null
;
function
getUnicodeLocaleExtensionSequenceRE
(
)
{
return
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
|
|
(
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
RegExpCreate
(
"
-
u
(
?
:
-
[
a
-
z0
-
9
]
{
2
8
}
)
+
"
)
)
;
}
function
removeUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
locale
;
var
pos
=
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
;
if
(
pos
<
0
)
pos
=
locale
.
length
;
var
left
=
callFunction
(
String_substring
locale
0
pos
)
;
var
right
=
callFunction
(
String_substring
locale
pos
)
;
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensions
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
left
)
;
if
(
extensions
!
=
=
null
)
{
left
=
callFunction
(
String_substring
left
0
extensions
.
index
)
+
callFunction
(
String_substring
left
extensions
.
index
+
extensions
[
0
]
.
length
)
;
}
var
combined
=
left
+
right
;
assert
(
IsStructurallyValidLanguageTag
(
combined
)
"
recombination
produced
an
invalid
language
tag
"
)
;
assert
(
function
(
)
{
var
uindex
=
callFunction
(
std_String_indexOf
combined
"
-
u
-
"
)
;
if
(
uindex
<
0
)
return
true
;
var
xindex
=
callFunction
(
std_String_indexOf
combined
"
-
x
-
"
)
;
return
xindex
>
0
&
&
xindex
<
uindex
;
}
(
)
"
recombination
failed
to
remove
all
Unicode
locale
extension
sequences
"
)
;
return
combined
;
}
function
IsStructurallyValidLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
locale
is
a
string
"
)
;
var
index
=
0
;
#
define
NONE
0b00
#
define
ALPHA
0b01
#
define
DIGIT
0b10
var
token
=
0
;
var
tokenStart
=
0
;
var
tokenLength
=
0
;
#
define
HYPHEN
0x2D
#
define
DIGIT_ZERO
0x30
#
define
DIGIT_NINE
0x39
#
define
UPPER_A
0x41
#
define
UPPER_Z
0x5A
#
define
LOWER_A
0x61
#
define
LOWER_X
0x78
#
define
LOWER_Z
0x7A
assert
(
std_String_fromCharCode
(
HYPHEN
)
=
=
=
"
-
"
&
&
std_String_fromCharCode
(
DIGIT_ZERO
)
=
=
=
"
0
"
&
&
std_String_fromCharCode
(
DIGIT_NINE
)
=
=
=
"
9
"
&
&
std_String_fromCharCode
(
UPPER_A
)
=
=
=
"
A
"
&
&
std_String_fromCharCode
(
UPPER_Z
)
=
=
=
"
Z
"
&
&
std_String_fromCharCode
(
LOWER_A
)
=
=
=
"
a
"
&
&
std_String_fromCharCode
(
LOWER_X
)
=
=
=
"
x
"
&
&
std_String_fromCharCode
(
LOWER_Z
)
=
=
=
"
z
"
"
code
unit
constants
should
match
the
expected
characters
"
)
;
function
nextToken
(
)
{
var
type
=
NONE
;
for
(
var
i
=
index
;
i
<
locale
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
locale
i
)
;
if
(
(
UPPER_A
<
=
c
&
&
c
<
=
UPPER_Z
)
|
|
(
LOWER_A
<
=
c
&
&
c
<
=
LOWER_Z
)
)
type
|
=
ALPHA
;
else
if
(
DIGIT_ZERO
<
=
c
&
&
c
<
=
DIGIT_NINE
)
type
|
=
DIGIT
;
else
if
(
c
=
=
=
HYPHEN
&
&
i
>
index
&
&
i
+
1
<
locale
.
length
)
break
;
else
return
false
;
}
token
=
type
;
tokenStart
=
index
;
tokenLength
=
i
-
index
;
index
=
i
+
1
;
return
true
;
}
function
tokenStartCodeUnitLower
(
)
{
var
c
=
callFunction
(
std_String_charCodeAt
locale
tokenStart
)
;
if
(
UPPER_A
<
=
c
&
&
c
<
=
UPPER_Z
)
c
|
=
0x20
;
assert
(
(
DIGIT_ZERO
<
=
c
&
&
c
<
=
DIGIT_NINE
)
|
|
(
LOWER_A
<
=
c
&
&
c
<
=
LOWER_Z
)
"
unexpected
code
unit
"
)
;
return
c
;
}
if
(
!
nextToken
(
)
)
return
false
;
if
(
token
!
=
=
ALPHA
|
|
tokenLength
>
8
)
return
false
;
assert
(
tokenLength
>
0
"
token
length
is
not
zero
if
type
is
ALPHA
"
)
;
if
(
tokenLength
>
1
)
{
if
(
tokenLength
<
=
3
)
{
if
(
!
nextToken
(
)
)
return
false
;
if
(
token
=
=
=
ALPHA
&
&
tokenLength
=
=
=
3
)
{
if
(
!
nextToken
(
)
)
return
false
;
if
(
token
=
=
=
ALPHA
&
&
tokenLength
=
=
=
3
)
{
if
(
!
nextToken
(
)
)
return
false
;
if
(
token
=
=
=
ALPHA
&
&
tokenLength
=
=
=
3
)
{
if
(
!
nextToken
(
)
)
return
false
;
}
}
}
}
else
{
assert
(
4
<
=
tokenLength
&
&
tokenLength
<
=
8
"
reserved
/
registered
language
subtags
"
)
;
if
(
!
nextToken
(
)
)
return
false
;
}
if
(
tokenLength
=
=
=
4
&
&
token
=
=
=
ALPHA
)
{
if
(
!
nextToken
(
)
)
return
false
;
}
if
(
(
tokenLength
=
=
=
2
&
&
token
=
=
=
ALPHA
)
|
|
(
tokenLength
=
=
=
3
&
&
token
=
=
=
DIGIT
)
)
{
if
(
!
nextToken
(
)
)
return
false
;
}
var
seenVariants
=
[
]
;
while
(
(
5
<
=
tokenLength
&
&
tokenLength
<
=
8
)
|
|
(
tokenLength
=
=
=
4
&
&
tokenStartCodeUnitLower
(
)
<
=
DIGIT_NINE
)
)
{
assert
(
!
(
tokenStartCodeUnitLower
(
)
<
=
DIGIT_NINE
)
|
|
tokenStartCodeUnitLower
(
)
>
=
DIGIT_ZERO
"
token
-
start
-
code
-
unit
<
=
'
9
'
implies
token
-
start
-
code
-
unit
is
in
'
0
'
.
.
'
9
'
"
)
;
var
variant
=
Substring
(
locale
tokenStart
tokenLength
)
;
variant
=
callFunction
(
std_String_toLowerCase
variant
)
;
if
(
callFunction
(
ArrayIndexOf
seenVariants
variant
)
!
=
=
-
1
)
return
false
;
_DefineDataProperty
(
seenVariants
seenVariants
.
length
variant
)
;
if
(
!
nextToken
(
)
)
return
false
;
}
var
seenSingletons
=
[
]
;
while
(
tokenLength
=
=
=
1
)
{
var
singleton
=
tokenStartCodeUnitLower
(
)
;
if
(
singleton
=
=
=
LOWER_X
)
break
;
assert
(
!
(
UPPER_A
<
=
singleton
&
&
singleton
<
=
UPPER_Z
)
"
unexpected
upper
-
case
code
unit
"
)
;
if
(
callFunction
(
ArrayIndexOf
seenSingletons
singleton
)
!
=
=
-
1
)
return
false
;
_DefineDataProperty
(
seenSingletons
seenSingletons
.
length
singleton
)
;
if
(
!
nextToken
(
)
)
return
false
;
if
(
!
(
2
<
=
tokenLength
&
&
tokenLength
<
=
8
)
)
return
false
;
do
{
if
(
!
nextToken
(
)
)
return
false
;
}
while
(
2
<
=
tokenLength
&
&
tokenLength
<
=
8
)
;
}
}
if
(
tokenLength
=
=
=
1
&
&
tokenStartCodeUnitLower
(
)
=
=
=
LOWER_X
)
{
if
(
!
nextToken
(
)
)
return
false
;
if
(
!
(
1
<
=
tokenLength
&
&
tokenLength
<
=
8
)
)
return
false
;
do
{
if
(
!
nextToken
(
)
)
return
false
;
}
while
(
1
<
=
tokenLength
&
&
tokenLength
<
=
8
)
;
}
if
(
token
=
=
=
NONE
)
return
true
;
do
{
if
(
!
nextToken
(
)
)
return
false
;
}
while
(
token
!
=
=
NONE
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
switch
(
locale
)
{
#
ifdef
DEBUG
case
"
art
-
lojban
"
:
case
"
cel
-
gaulish
"
:
case
"
no
-
bok
"
:
case
"
no
-
nyn
"
:
case
"
zh
-
guoyu
"
:
case
"
zh
-
hakka
"
:
case
"
zh
-
min
"
:
case
"
zh
-
min
-
nan
"
:
case
"
zh
-
xiang
"
:
assert
(
false
"
regular
grandfathered
tags
should
have
been
matched
above
"
)
;
#
endif
/
*
DEBUG
*
/
case
"
en
-
gb
-
oed
"
:
case
"
i
-
ami
"
:
case
"
i
-
bnn
"
:
case
"
i
-
default
"
:
case
"
i
-
enochian
"
:
case
"
i
-
hak
"
:
case
"
i
-
klingon
"
:
case
"
i
-
lux
"
:
case
"
i
-
mingo
"
:
case
"
i
-
navajo
"
:
case
"
i
-
pwn
"
:
case
"
i
-
tao
"
:
case
"
i
-
tay
"
:
case
"
i
-
tsu
"
:
case
"
sgn
-
be
-
fr
"
:
case
"
sgn
-
be
-
nl
"
:
case
"
sgn
-
ch
-
de
"
:
return
true
;
default
:
return
false
;
}
#
undef
NONE
#
undef
ALPHA
#
undef
DIGIT
#
undef
HYPHEN
#
undef
DIGIT_ZERO
#
undef
DIGIT_NINE
#
undef
UPPER_A
#
undef
UPPER_Z
#
undef
LOWER_A
#
undef
LOWER_X
#
undef
LOWER_Z
}
function
ArrayJoinRange
(
array
separator
from
to
=
array
.
length
)
{
assert
(
typeof
separator
=
=
=
"
string
"
"
|
separator
|
is
a
string
value
"
)
;
assert
(
typeof
from
=
=
=
"
number
"
"
|
from
|
is
a
number
value
"
)
;
assert
(
typeof
to
=
=
=
"
number
"
"
|
to
|
is
a
number
value
"
)
;
assert
(
0
<
=
from
&
&
from
<
=
to
&
&
to
<
=
array
.
length
"
|
from
|
and
|
to
|
form
a
valid
range
"
)
;
if
(
from
=
=
=
to
)
return
"
"
;
var
result
=
array
[
from
]
;
for
(
var
i
=
from
+
1
;
i
<
to
;
i
+
+
)
{
result
+
=
separator
+
array
[
i
]
;
}
return
result
;
}
function
CanonicalizeLanguageTag
(
locale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
CanonicalizeLanguageTag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
if
(
hasOwn
(
locale
langTagMappings
)
)
return
langTagMappings
[
locale
]
;
var
subtags
=
StringSplitString
(
locale
"
-
"
)
;
var
i
=
0
;
while
(
i
<
subtags
.
length
)
{
var
subtag
=
subtags
[
i
]
;
if
(
subtag
.
length
=
=
=
1
&
&
(
i
>
0
|
|
subtag
=
=
=
"
x
"
)
)
break
;
if
(
i
!
=
=
0
)
{
if
(
subtag
.
length
=
=
=
4
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
[
0
]
)
+
callFunction
(
String_substring
subtag
1
)
;
}
else
if
(
subtag
.
length
=
=
=
2
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
)
;
}
}
if
(
hasOwn
(
subtag
langSubtagMappings
)
)
{
subtag
=
langSubtagMappings
[
subtag
]
;
}
else
if
(
hasOwn
(
subtag
extlangMappings
)
)
{
if
(
i
=
=
=
1
&
&
extlangMappings
[
subtag
]
=
=
=
subtags
[
0
]
)
{
callFunction
(
std_Array_shift
subtags
)
;
i
-
-
;
}
}
subtags
[
i
]
=
subtag
;
i
+
+
;
}
if
(
i
=
=
=
subtags
.
length
)
return
callFunction
(
std_Array_join
subtags
"
-
"
)
;
var
normal
=
ArrayJoinRange
(
subtags
"
-
"
0
i
)
;
var
extensions
=
[
]
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
!
=
=
"
x
"
)
{
var
extensionStart
=
i
;
i
+
+
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
.
length
>
1
)
i
+
+
;
var
extension
=
ArrayJoinRange
(
subtags
"
-
"
extensionStart
i
)
;
_DefineDataProperty
(
extensions
extensions
.
length
extension
)
;
}
callFunction
(
ArraySort
extensions
)
;
var
privateUse
=
"
"
;
if
(
i
<
subtags
.
length
)
privateUse
=
ArrayJoinRange
(
subtags
"
-
"
i
)
;
var
canonical
=
normal
;
if
(
extensions
.
length
>
0
)
canonical
+
=
"
-
"
+
callFunction
(
std_Array_join
extensions
"
-
"
)
;
if
(
privateUse
.
length
>
0
)
{
if
(
canonical
.
length
>
0
)
canonical
+
=
"
-
"
+
privateUse
;
else
canonical
=
privateUse
;
}
return
canonical
;
}
function
IsASCIIAlphaString
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
IsASCIIAlphaString
"
)
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
if
(
!
(
(
0x41
<
=
c
&
&
c
<
=
0x5A
)
|
|
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
)
)
return
false
;
}
return
true
;
}
function
ValidateAndCanonicalizeLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
ValidateAndCanonicalizeLanguageTag
"
)
;
if
(
locale
.
length
=
=
=
2
|
|
(
locale
.
length
=
=
=
3
&
&
locale
[
1
]
!
=
=
"
-
"
)
)
{
if
(
!
IsASCIIAlphaString
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
2
*
3ALPHA
is
a
valid
language
tag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
assert
(
!
hasOwn
(
locale
langTagMappings
)
"
langTagMappings
contains
no
2
*
3ALPHA
mappings
"
)
;
locale
=
hasOwn
(
locale
langSubtagMappings
)
?
langSubtagMappings
[
locale
]
:
locale
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
expected
same
canonicalization
"
)
;
return
locale
;
}
if
(
!
IsStructurallyValidLanguageTag
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
return
CanonicalizeLanguageTag
(
locale
)
;
}
function
localeContainsNoUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
=
=
=
-
1
)
return
true
;
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
>
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
)
return
true
;
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
true
;
return
false
;
}
function
lastDitchLocale
(
)
{
return
"
en
-
GB
"
;
}
var
oldStyleLanguageTagMappings
=
{
"
pa
-
PK
"
:
"
pa
-
Arab
-
PK
"
"
zh
-
CN
"
:
"
zh
-
Hans
-
CN
"
"
zh
-
HK
"
:
"
zh
-
Hant
-
HK
"
"
zh
-
SG
"
:
"
zh
-
Hans
-
SG
"
"
zh
-
TW
"
:
"
zh
-
Hant
-
TW
"
}
;
var
localeCandidateCache
=
{
runtimeDefaultLocale
:
undefined
candidateDefaultLocale
:
undefined
}
;
var
localeCache
=
{
runtimeDefaultLocale
:
undefined
defaultLocale
:
undefined
}
;
function
DefaultLocaleIgnoringAvailableLocales
(
)
{
const
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
if
(
runtimeDefaultLocale
=
=
=
localeCandidateCache
.
runtimeDefaultLocale
)
return
localeCandidateCache
.
candidateDefaultLocale
;
var
candidate
;
if
(
!
IsStructurallyValidLanguageTag
(
runtimeDefaultLocale
)
)
{
candidate
=
lastDitchLocale
(
)
;
}
else
{
candidate
=
CanonicalizeLanguageTag
(
runtimeDefaultLocale
)
;
candidate
=
removeUnicodeExtensions
(
candidate
)
;
if
(
hasOwn
(
candidate
oldStyleLanguageTagMappings
)
)
candidate
=
oldStyleLanguageTagMappings
[
candidate
]
;
}
localeCandidateCache
.
candidateDefaultLocale
=
candidate
;
localeCandidateCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
assert
(
IsStructurallyValidLanguageTag
(
candidate
)
"
the
candidate
must
be
structurally
valid
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
candidate
)
"
the
candidate
must
not
contain
a
Unicode
extension
sequence
"
)
;
return
candidate
;
}
function
DefaultLocale
(
)
{
if
(
IsRuntimeDefaultLocale
(
localeCache
.
runtimeDefaultLocale
)
)
return
localeCache
.
defaultLocale
;
var
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
var
candidate
=
DefaultLocaleIgnoringAvailableLocales
(
)
;
var
locale
;
if
(
BestAvailableLocaleIgnoringDefault
(
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
dateTimeFormatInternalProperties
.
availableLocales
dateTimeFormatInternalProperties
)
candidate
)
)
{
locale
=
candidate
;
}
else
{
locale
=
lastDitchLocale
(
)
;
}
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
structurally
valid
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
canonical
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
the
computed
default
locale
must
not
contain
a
Unicode
extension
sequence
"
)
;
localeCache
.
defaultLocale
=
locale
;
localeCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
return
locale
;
}
function
addSpecialMissingLanguageTags
(
availableLocales
)
{
var
oldStyleLocales
=
std_Object_getOwnPropertyNames
(
oldStyleLanguageTagMappings
)
;
for
(
var
i
=
0
;
i
<
oldStyleLocales
.
length
;
i
+
+
)
{
var
oldStyleLocale
=
oldStyleLocales
[
i
]
;
if
(
availableLocales
[
oldStyleLanguageTagMappings
[
oldStyleLocale
]
]
)
availableLocales
[
oldStyleLocale
]
=
true
;
}
var
lastDitch
=
lastDitchLocale
(
)
;
assert
(
lastDitch
=
=
=
"
en
-
GB
"
&
&
availableLocales
.
en
"
shouldn
'
t
be
a
need
to
add
every
locale
implied
by
the
last
-
"
+
"
ditch
locale
merely
just
the
last
-
ditch
locale
"
)
;
availableLocales
[
lastDitch
]
=
true
;
}
function
CanonicalizeLocaleList
(
locales
)
{
if
(
locales
=
=
=
undefined
)
return
[
]
;
if
(
typeof
locales
=
=
=
"
string
"
)
{
if
(
!
IsStructurallyValidLanguageTag
(
locales
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locales
)
;
return
[
CanonicalizeLanguageTag
(
locales
)
]
;
}
var
seen
=
[
]
;
var
O
=
ToObject
(
locales
)
;
var
len
=
ToLength
(
O
.
length
)
;
var
k
=
0
;
while
(
k
<
len
)
{
var
kPresent
=
HasProperty
(
O
k
)
;
if
(
kPresent
)
{
var
kValue
=
O
[
k
]
;
if
(
!
(
typeof
kValue
=
=
=
"
string
"
|
|
IsObject
(
kValue
)
)
)
ThrowTypeError
(
JSMSG_INVALID_LOCALES_ELEMENT
)
;
var
tag
=
ToString
(
kValue
)
;
if
(
!
IsStructurallyValidLanguageTag
(
tag
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
tag
)
;
tag
=
CanonicalizeLanguageTag
(
tag
)
;
if
(
callFunction
(
ArrayIndexOf
seen
tag
)
=
=
=
-
1
)
_DefineDataProperty
(
seen
seen
.
length
tag
)
;
}
k
+
+
;
}
return
seen
;
}
function
BestAvailableLocaleHelper
(
availableLocales
locale
considerDefaultLocale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
invalid
BestAvailableLocale
locale
structure
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
non
-
canonical
BestAvailableLocale
locale
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
locale
must
contain
no
Unicode
extensions
"
)
;
var
defaultLocale
;
if
(
considerDefaultLocale
)
defaultLocale
=
DefaultLocale
(
)
;
var
candidate
=
locale
;
while
(
true
)
{
if
(
availableLocales
[
candidate
]
)
return
candidate
;
if
(
considerDefaultLocale
&
&
candidate
.
length
<
=
defaultLocale
.
length
)
{
if
(
candidate
=
=
=
defaultLocale
)
return
candidate
;
if
(
callFunction
(
std_String_startsWith
defaultLocale
candidate
+
"
-
"
)
)
return
candidate
;
}
var
pos
=
callFunction
(
std_String_lastIndexOf
candidate
"
-
"
)
;
if
(
pos
=
=
=
-
1
)
return
undefined
;
if
(
pos
>
=
2
&
&
candidate
[
pos
-
2
]
=
=
=
"
-
"
)
pos
-
=
2
;
candidate
=
callFunction
(
String_substring
candidate
0
pos
)
;
}
}
function
BestAvailableLocale
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
true
)
;
}
function
BestAvailableLocaleIgnoringDefault
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
false
)
;
}
function
LookupMatcher
(
availableLocales
requestedLocales
)
{
var
i
=
0
;
var
len
=
requestedLocales
.
length
;
var
availableLocale
;
var
locale
noExtensionsLocale
;
while
(
i
<
len
&
&
availableLocale
=
=
=
undefined
)
{
locale
=
requestedLocales
[
i
]
;
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
i
+
+
;
}
var
result
=
new
Record
(
)
;
if
(
availableLocale
!
=
=
undefined
)
{
result
.
locale
=
availableLocale
;
if
(
locale
!
=
=
noExtensionsLocale
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
locale
)
;
result
.
extension
=
extensionMatch
[
0
]
;
}
}
else
{
result
.
locale
=
DefaultLocale
(
)
;
}
return
result
;
}
function
BestFitMatcher
(
availableLocales
requestedLocales
)
{
return
LookupMatcher
(
availableLocales
requestedLocales
)
;
}
function
UnicodeExtensionValue
(
extension
key
)
{
assert
(
typeof
extension
=
=
=
"
string
"
"
extension
is
a
string
value
"
)
;
assert
(
function
(
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
extension
)
;
return
extensionMatch
!
=
=
null
&
&
extensionMatch
[
0
]
=
=
=
extension
;
}
(
)
"
extension
is
a
Unicode
extension
subtag
"
)
;
assert
(
typeof
key
=
=
=
"
string
"
"
key
is
a
string
value
"
)
;
assert
(
key
.
length
=
=
=
2
"
key
is
a
Unicode
extension
key
subtag
"
)
;
var
size
=
extension
.
length
;
var
searchValue
=
"
-
"
+
key
+
"
-
"
;
var
pos
=
callFunction
(
std_String_indexOf
extension
searchValue
)
;
if
(
pos
!
=
=
-
1
)
{
var
start
=
pos
+
4
;
var
end
=
start
;
var
k
=
start
;
while
(
true
)
{
var
e
=
callFunction
(
std_String_indexOf
extension
"
-
"
k
)
;
var
len
=
e
=
=
=
-
1
?
size
-
k
:
e
-
k
;
if
(
len
=
=
=
2
)
break
;
if
(
e
=
=
=
-
1
)
{
end
=
size
;
break
;
}
end
=
e
;
k
=
e
+
1
;
}
return
callFunction
(
String_substring
extension
start
end
)
;
}
searchValue
=
"
-
"
+
key
;
if
(
callFunction
(
std_String_endsWith
extension
searchValue
)
)
return
"
"
;
}
function
ResolveLocale
(
availableLocales
requestedLocales
options
relevantExtensionKeys
localeData
)
{
var
matcher
=
options
.
localeMatcher
;
var
r
=
(
matcher
=
=
=
"
lookup
"
)
?
LookupMatcher
(
availableLocales
requestedLocales
)
:
BestFitMatcher
(
availableLocales
requestedLocales
)
;
var
foundLocale
=
r
.
locale
;
var
extension
=
r
.
extension
;
var
result
=
new
Record
(
)
;
result
.
dataLocale
=
foundLocale
;
var
supportedExtension
=
"
-
u
"
;
var
localeDataProvider
=
localeData
(
)
;
for
(
var
i
=
0
;
i
<
relevantExtensionKeys
.
length
;
i
+
+
)
{
var
key
=
relevantExtensionKeys
[
i
]
;
var
keyLocaleData
=
undefined
;
var
value
=
undefined
;
var
supportedExtensionAddition
=
"
"
;
if
(
extension
!
=
=
undefined
)
{
var
requestedValue
=
UnicodeExtensionValue
(
extension
key
)
;
if
(
requestedValue
!
=
=
undefined
)
{
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
requestedValue
!
=
=
"
"
)
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
requestedValue
)
!
=
=
-
1
)
{
value
=
requestedValue
;
supportedExtensionAddition
=
"
-
"
+
key
+
"
-
"
+
value
;
}
}
else
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
"
true
"
)
!
=
=
-
1
)
value
=
"
true
"
;
}
}
}
var
optionsValue
=
options
[
key
]
;
if
(
optionsValue
!
=
=
undefined
&
&
optionsValue
!
=
=
value
)
{
if
(
keyLocaleData
=
=
=
undefined
)
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
optionsValue
)
!
=
=
-
1
)
{
value
=
optionsValue
;
supportedExtensionAddition
=
"
"
;
}
}
if
(
value
=
=
=
undefined
)
{
value
=
keyLocaleData
=
=
=
undefined
?
callFunction
(
localeDataProvider
.
default
[
key
]
null
foundLocale
)
:
keyLocaleData
[
0
]
;
}
assert
(
typeof
value
=
=
=
"
string
"
|
|
value
=
=
=
null
"
unexpected
locale
data
value
"
)
;
result
[
key
]
=
value
;
supportedExtension
+
=
supportedExtensionAddition
;
}
if
(
supportedExtension
.
length
>
2
)
{
assert
(
!
callFunction
(
std_String_startsWith
foundLocale
"
x
-
"
)
"
unexpected
privateuse
-
only
locale
returned
from
ICU
"
)
;
var
privateIndex
=
callFunction
(
std_String_indexOf
foundLocale
"
-
x
-
"
)
;
if
(
privateIndex
=
=
=
-
1
)
{
foundLocale
+
=
supportedExtension
;
}
else
{
var
preExtension
=
callFunction
(
String_substring
foundLocale
0
privateIndex
)
;
var
postExtension
=
callFunction
(
String_substring
foundLocale
privateIndex
)
;
foundLocale
=
preExtension
+
supportedExtension
+
postExtension
;
}
assert
(
IsStructurallyValidLanguageTag
(
foundLocale
)
"
invalid
locale
after
concatenation
"
)
;
assert
(
foundLocale
=
=
=
CanonicalizeLanguageTag
(
foundLocale
)
"
same
locale
with
extension
"
)
;
}
result
.
locale
=
foundLocale
;
return
result
;
}
function
LookupSupportedLocales
(
availableLocales
requestedLocales
)
{
var
len
=
requestedLocales
.
length
;
var
subset
=
[
]
;
var
k
=
0
;
while
(
k
<
len
)
{
var
locale
=
requestedLocales
[
k
]
;
var
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
var
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
if
(
availableLocale
!
=
=
undefined
)
_DefineDataProperty
(
subset
subset
.
length
locale
)
;
k
+
+
;
}
return
subset
;
}
function
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
{
return
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
}
function
SupportedLocales
(
availableLocales
requestedLocales
options
)
{
var
matcher
;
if
(
options
!
=
=
undefined
)
{
options
=
ToObject
(
options
)
;
matcher
=
options
.
localeMatcher
;
if
(
matcher
!
=
=
undefined
)
{
matcher
=
ToString
(
matcher
)
;
if
(
matcher
!
=
=
"
lookup
"
&
&
matcher
!
=
=
"
best
fit
"
)
ThrowRangeError
(
JSMSG_INVALID_LOCALE_MATCHER
matcher
)
;
}
}
var
subset
=
(
matcher
=
=
=
undefined
|
|
matcher
=
=
=
"
best
fit
"
)
?
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
:
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
for
(
var
i
=
0
;
i
<
subset
.
length
;
i
+
+
)
{
_DefineDataProperty
(
subset
i
subset
[
i
]
ATTR_ENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
}
_DefineDataProperty
(
subset
"
length
"
subset
.
length
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
subset
;
}
function
GetOption
(
options
property
type
values
fallback
)
{
var
value
=
options
[
property
]
;
if
(
value
!
=
=
undefined
)
{
if
(
type
=
=
=
"
boolean
"
)
value
=
ToBoolean
(
value
)
;
else
if
(
type
=
=
=
"
string
"
)
value
=
ToString
(
value
)
;
else
assert
(
false
"
GetOption
"
)
;
if
(
values
!
=
=
undefined
&
&
callFunction
(
ArrayIndexOf
values
value
)
=
=
=
-
1
)
ThrowRangeError
(
JSMSG_INVALID_OPTION_VALUE
property
value
)
;
return
value
;
}
return
fallback
;
}
function
DefaultNumberOption
(
value
minimum
maximum
fallback
)
{
assert
(
typeof
minimum
=
=
=
"
number
"
&
&
(
minimum
|
0
)
=
=
=
minimum
"
DefaultNumberOption
"
)
;
assert
(
typeof
maximum
=
=
=
"
number
"
&
&
(
maximum
|
0
)
=
=
=
maximum
"
DefaultNumberOption
"
)
;
assert
(
typeof
fallback
=
=
=
"
number
"
&
&
(
fallback
|
0
)
=
=
=
fallback
"
DefaultNumberOption
"
)
;
assert
(
minimum
<
=
fallback
&
&
fallback
<
=
maximum
"
DefaultNumberOption
"
)
;
if
(
value
!
=
=
undefined
)
{
value
=
ToNumber
(
value
)
;
if
(
Number_isNaN
(
value
)
|
|
value
<
minimum
|
|
value
>
maximum
)
ThrowRangeError
(
JSMSG_INVALID_DIGITS_VALUE
value
)
;
return
std_Math_floor
(
value
)
|
0
;
}
return
fallback
;
}
function
GetNumberOption
(
options
property
minimum
maximum
fallback
)
{
return
DefaultNumberOption
(
options
[
property
]
minimum
maximum
fallback
)
;
}
var
intlFallbackSymbolHolder
=
{
value
:
undefined
}
;
function
intlFallbackSymbol
(
)
{
var
fallbackSymbol
=
intlFallbackSymbolHolder
.
value
;
if
(
!
fallbackSymbol
)
{
fallbackSymbol
=
std_Symbol
(
"
IntlLegacyConstructedSymbol
"
)
;
intlFallbackSymbolHolder
.
value
=
fallbackSymbol
;
}
return
fallbackSymbol
;
}
function
initializeIntlObject
(
obj
type
lazyData
)
{
assert
(
IsObject
(
obj
)
"
Non
-
object
passed
to
initializeIntlObject
"
)
;
assert
(
(
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
IsObject
(
lazyData
)
"
non
-
object
lazy
data
"
)
;
var
internals
=
std_Object_create
(
null
)
;
internals
.
type
=
type
;
internals
.
lazyData
=
lazyData
;
internals
.
internalProps
=
null
;
assert
(
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
=
=
=
null
"
Internal
slot
already
initialized
?
"
)
;
UnsafeSetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
internals
)
;
}
function
setInternalProperties
(
internals
internalProps
)
{
assert
(
IsObject
(
internals
.
lazyData
)
"
lazy
data
must
exist
already
"
)
;
assert
(
IsObject
(
internalProps
)
"
internalProps
argument
should
be
an
object
"
)
;
internals
.
internalProps
=
internalProps
;
internals
.
lazyData
=
null
;
}
function
maybeInternalProperties
(
internals
)
{
assert
(
IsObject
(
internals
)
"
non
-
object
passed
to
maybeInternalProperties
"
)
;
var
lazyData
=
internals
.
lazyData
;
if
(
lazyData
)
return
null
;
assert
(
IsObject
(
internals
.
internalProps
)
"
missing
lazy
data
and
computed
internals
"
)
;
return
internals
.
internalProps
;
}
function
getIntlObjectInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Object
"
)
;
assert
(
IsCollator
(
obj
)
|
|
IsDateTimeFormat
(
obj
)
|
|
IsNumberFormat
(
obj
)
|
|
IsPluralRules
(
obj
)
|
|
IsRelativeTimeFormat
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Intl
object
"
)
;
var
internals
=
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
;
assert
(
IsObject
(
internals
)
"
internals
not
an
object
"
)
;
assert
(
hasOwn
(
"
type
"
internals
)
"
missing
type
"
)
;
assert
(
(
internals
.
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
hasOwn
(
"
lazyData
"
internals
)
"
missing
lazyData
"
)
;
assert
(
hasOwn
(
"
internalProps
"
internals
)
"
missing
internalProps
"
)
;
return
internals
;
}
function
getInternals
(
obj
)
{
var
internals
=
getIntlObjectInternals
(
obj
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
var
type
=
internals
.
type
;
if
(
type
=
=
=
"
Collator
"
)
internalProps
=
resolveCollatorInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
DateTimeFormat
"
)
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
NumberFormat
"
)
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
else
internalProps
=
resolvePluralRulesInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
