#
ifndef
builtin_ModuleObject_h
#
define
builtin_ModuleObject_h
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
class
JSAtom
;
class
JSScript
;
class
JSTracer
;
namespace
JS
{
class
PropertyDescriptor
;
class
Value
;
}
namespace
js
{
class
ArrayObject
;
class
CyclicModuleFields
;
class
SyntheticModuleFields
;
class
ListObject
;
class
ModuleEnvironmentObject
;
class
ModuleObject
;
class
PromiseObject
;
class
ScriptSourceObject
;
class
ImportAttribute
{
const
HeapPtr
<
JSAtom
*
>
key_
;
const
HeapPtr
<
JSString
*
>
value_
;
public
:
ImportAttribute
(
Handle
<
JSAtom
*
>
key
Handle
<
JSString
*
>
value
)
;
JSAtom
*
key
(
)
const
{
return
key_
;
}
JSString
*
value
(
)
const
{
return
value_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ImportAttributeVector
=
GCVector
<
ImportAttribute
0
SystemAllocPolicy
>
;
class
ModuleRequestObject
:
public
NativeObject
{
public
:
enum
{
SpecifierSlot
=
0
FirstUnsupportedAttributeKeySlot
ModuleTypeSlot
SlotCount
}
;
static
const
JSClass
class_
;
static
bool
isInstance
(
HandleValue
value
)
;
[
[
nodiscard
]
]
static
ModuleRequestObject
*
create
(
JSContext
*
cx
Handle
<
JSAtom
*
>
specifier
Handle
<
ImportAttributeVector
>
maybeAttributes
)
;
[
[
nodiscard
]
]
static
ModuleRequestObject
*
create
(
JSContext
*
cx
Handle
<
JSAtom
*
>
specifier
JS
:
:
ModuleType
moduleType
)
;
JSAtom
*
specifier
(
)
const
;
JS
:
:
ModuleType
moduleType
(
)
const
;
void
setFirstUnsupportedAttributeKey
(
Handle
<
JSAtom
*
>
key
)
;
bool
hasFirstUnsupportedAttributeKey
(
)
const
;
JSAtom
*
getFirstUnsupportedAttributeKey
(
)
const
;
}
;
using
ModuleRequestVector
=
GCVector
<
HeapPtr
<
ModuleRequestObject
*
>
0
SystemAllocPolicy
>
;
class
ImportEntry
{
const
HeapPtr
<
ModuleRequestObject
*
>
moduleRequest_
;
const
HeapPtr
<
JSAtom
*
>
importName_
;
const
HeapPtr
<
JSAtom
*
>
localName_
;
const
uint32_t
lineNumber_
;
const
JS
:
:
ColumnNumberOneOrigin
columnNumber_
;
public
:
ImportEntry
(
Handle
<
ModuleRequestObject
*
>
moduleRequest
Handle
<
JSAtom
*
>
maybeImportName
Handle
<
JSAtom
*
>
localName
uint32_t
lineNumber
JS
:
:
ColumnNumberOneOrigin
columnNumber
)
;
ModuleRequestObject
*
moduleRequest
(
)
const
{
return
moduleRequest_
;
}
JSAtom
*
importName
(
)
const
{
return
importName_
;
}
JSAtom
*
localName
(
)
const
{
return
localName_
;
}
uint32_t
lineNumber
(
)
const
{
return
lineNumber_
;
}
JS
:
:
ColumnNumberOneOrigin
columnNumber
(
)
const
{
return
columnNumber_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ImportEntryVector
=
GCVector
<
ImportEntry
0
SystemAllocPolicy
>
;
class
ExportEntry
{
const
HeapPtr
<
JSAtom
*
>
exportName_
;
const
HeapPtr
<
ModuleRequestObject
*
>
moduleRequest_
;
const
HeapPtr
<
JSAtom
*
>
importName_
;
const
HeapPtr
<
JSAtom
*
>
localName_
;
const
uint32_t
lineNumber_
;
const
JS
:
:
ColumnNumberOneOrigin
columnNumber_
;
public
:
ExportEntry
(
Handle
<
JSAtom
*
>
maybeExportName
Handle
<
ModuleRequestObject
*
>
maybeModuleRequest
Handle
<
JSAtom
*
>
maybeImportName
Handle
<
JSAtom
*
>
maybeLocalName
uint32_t
lineNumber
JS
:
:
ColumnNumberOneOrigin
columnNumber
)
;
JSAtom
*
exportName
(
)
const
{
return
exportName_
;
}
ModuleRequestObject
*
moduleRequest
(
)
const
{
return
moduleRequest_
;
}
JSAtom
*
importName
(
)
const
{
return
importName_
;
}
JSAtom
*
localName
(
)
const
{
return
localName_
;
}
uint32_t
lineNumber
(
)
const
{
return
lineNumber_
;
}
JS
:
:
ColumnNumberOneOrigin
columnNumber
(
)
const
{
return
columnNumber_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ExportEntryVector
=
GCVector
<
ExportEntry
0
SystemAllocPolicy
>
;
class
RequestedModule
{
const
HeapPtr
<
ModuleRequestObject
*
>
moduleRequest_
;
const
uint32_t
lineNumber_
;
const
JS
:
:
ColumnNumberOneOrigin
columnNumber_
;
public
:
RequestedModule
(
Handle
<
ModuleRequestObject
*
>
moduleRequest
uint32_t
lineNumber
JS
:
:
ColumnNumberOneOrigin
columnNumber
)
;
ModuleRequestObject
*
moduleRequest
(
)
const
{
return
moduleRequest_
;
}
uint32_t
lineNumber
(
)
const
{
return
lineNumber_
;
}
JS
:
:
ColumnNumberOneOrigin
columnNumber
(
)
const
{
return
columnNumber_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
using
RequestedModuleVector
=
GCVector
<
RequestedModule
0
SystemAllocPolicy
>
;
class
ResolvedBindingObject
:
public
NativeObject
{
public
:
enum
{
ModuleSlot
=
0
BindingNameSlot
SlotCount
}
;
static
const
JSClass
class_
;
static
bool
isInstance
(
HandleValue
value
)
;
static
ResolvedBindingObject
*
create
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
Handle
<
JSAtom
*
>
bindingName
)
;
ModuleObject
*
module
(
)
const
;
JSAtom
*
bindingName
(
)
const
;
}
;
class
IndirectBindingMap
{
public
:
void
trace
(
JSTracer
*
trc
)
;
bool
put
(
JSContext
*
cx
HandleId
name
Handle
<
ModuleEnvironmentObject
*
>
environment
HandleId
targetName
)
;
size_t
count
(
)
const
{
return
map_
?
map_
-
>
count
(
)
:
0
;
}
bool
has
(
jsid
name
)
const
{
return
map_
?
map_
-
>
has
(
name
)
:
false
;
}
bool
lookup
(
jsid
name
ModuleEnvironmentObject
*
*
envOut
mozilla
:
:
Maybe
<
PropertyInfo
>
*
propOut
)
const
;
template
<
typename
Func
>
void
forEachExportedName
(
Func
func
)
const
{
if
(
!
map_
)
{
return
;
}
for
(
auto
r
=
map_
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
func
(
r
.
front
(
)
.
key
(
)
)
;
}
}
private
:
struct
Binding
{
Binding
(
ModuleEnvironmentObject
*
environment
jsid
targetName
PropertyInfo
prop
)
;
HeapPtr
<
ModuleEnvironmentObject
*
>
environment
;
#
ifdef
DEBUG
HeapPtr
<
jsid
>
targetName
;
#
endif
PropertyInfo
prop
;
}
;
using
Map
=
mozilla
:
:
HashMap
<
PreBarriered
<
jsid
>
Binding
mozilla
:
:
DefaultHasher
<
PreBarriered
<
jsid
>
>
CellAllocPolicy
>
;
mozilla
:
:
Maybe
<
Map
>
map_
;
}
;
using
ExportNameVector
=
GCVector
<
HeapPtr
<
JSAtom
*
>
0
SystemAllocPolicy
>
;
class
ModuleNamespaceObject
:
public
ProxyObject
{
public
:
enum
ModuleNamespaceSlot
{
ExportsSlot
=
0
BindingsSlot
}
;
static
bool
isInstance
(
HandleValue
value
)
;
static
ModuleNamespaceObject
*
create
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
MutableHandle
<
UniquePtr
<
ExportNameVector
>
>
exports
MutableHandle
<
UniquePtr
<
IndirectBindingMap
>
>
bindings
)
;
ModuleObject
&
module
(
)
;
const
ExportNameVector
&
exports
(
)
const
;
IndirectBindingMap
&
bindings
(
)
;
bool
addBinding
(
JSContext
*
cx
Handle
<
JSAtom
*
>
exportedName
Handle
<
ModuleObject
*
>
targetModule
Handle
<
JSAtom
*
>
targetName
)
;
private
:
struct
ProxyHandler
:
public
BaseProxyHandler
{
constexpr
ProxyHandler
(
)
:
BaseProxyHandler
(
&
family
false
)
{
}
bool
getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
const
override
;
bool
defineProperty
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
const
override
;
bool
ownPropertyKeys
(
JSContext
*
cx
HandleObject
proxy
MutableHandleIdVector
props
)
const
override
;
bool
delete_
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
ObjectOpResult
&
result
)
const
override
;
bool
getPrototype
(
JSContext
*
cx
HandleObject
proxy
MutableHandleObject
protop
)
const
override
;
bool
setPrototype
(
JSContext
*
cx
HandleObject
proxy
HandleObject
proto
ObjectOpResult
&
result
)
const
override
;
bool
getPrototypeIfOrdinary
(
JSContext
*
cx
HandleObject
proxy
bool
*
isOrdinary
MutableHandleObject
protop
)
const
override
;
bool
setImmutablePrototype
(
JSContext
*
cx
HandleObject
proxy
bool
*
succeeded
)
const
override
;
bool
preventExtensions
(
JSContext
*
cx
HandleObject
proxy
ObjectOpResult
&
result
)
const
override
;
bool
isExtensible
(
JSContext
*
cx
HandleObject
proxy
bool
*
extensible
)
const
override
;
bool
has
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
bool
*
bp
)
const
override
;
bool
get
(
JSContext
*
cx
HandleObject
proxy
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
const
override
;
bool
set
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
const
override
;
void
trace
(
JSTracer
*
trc
JSObject
*
proxy
)
const
override
;
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
proxy
)
const
override
;
static
const
char
family
;
}
;
bool
hasBindings
(
)
const
;
bool
hasExports
(
)
const
;
ExportNameVector
&
mutableExports
(
)
;
public
:
static
const
ProxyHandler
proxyHandler
;
}
;
enum
class
ModuleStatus
:
int8_t
{
New
Unlinked
Linking
Linked
Evaluating
EvaluatingAsync
Evaluated
Evaluated_Error
}
;
constexpr
uint32_t
ASYNC_EVALUATING_POST_ORDER_INIT
=
1
;
constexpr
uint32_t
ASYNC_EVALUATING_POST_ORDER_CLEARED
=
0
;
using
LoadedModuleMap
=
GCHashMap
<
HeapPtr
<
JSObject
*
>
HeapPtr
<
ModuleObject
*
>
StableCellHasher
<
HeapPtr
<
JSObject
*
>
>
SystemAllocPolicy
>
;
class
ModuleObject
:
public
NativeObject
{
public
:
enum
ModuleSlot
{
ScriptSlot
=
0
EnvironmentSlot
NamespaceSlot
CyclicModuleFieldsSlot
SyntheticModuleFieldsSlot
SlotCount
}
;
static
const
JSClass
class_
;
static
bool
isInstance
(
HandleValue
value
)
;
static
ModuleObject
*
create
(
JSContext
*
cx
)
;
static
ModuleObject
*
createSynthetic
(
JSContext
*
cx
MutableHandle
<
ExportNameVector
>
exportNames
)
;
void
initScriptSlots
(
HandleScript
script
)
;
void
setInitialEnvironment
(
Handle
<
ModuleEnvironmentObject
*
>
initialEnvironment
)
;
void
initFunctionDeclarations
(
UniquePtr
<
FunctionDeclarationVector
>
decls
)
;
void
initImportExportData
(
MutableHandle
<
RequestedModuleVector
>
requestedModules
MutableHandle
<
ImportEntryVector
>
importEntries
MutableHandle
<
ExportEntryVector
>
exportEntries
uint32_t
localExportCount
uint32_t
indirectExportCount
uint32_t
starExportCount
)
;
static
bool
Freeze
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
)
;
#
ifdef
DEBUG
static
bool
AssertFrozen
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
)
;
#
endif
JSScript
*
maybeScript
(
)
const
;
JSScript
*
script
(
)
const
;
const
char
*
filename
(
)
const
;
ModuleEnvironmentObject
&
initialEnvironment
(
)
const
;
ModuleEnvironmentObject
*
environment
(
)
const
;
ModuleNamespaceObject
*
namespace_
(
)
;
ModuleStatus
status
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
maybeDfsIndex
(
)
const
;
uint32_t
dfsIndex
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
maybeDfsAncestorIndex
(
)
const
;
uint32_t
dfsAncestorIndex
(
)
const
;
bool
hadEvaluationError
(
)
const
;
Value
maybeEvaluationError
(
)
const
;
Value
evaluationError
(
)
const
;
JSObject
*
metaObject
(
)
const
;
ScriptSourceObject
*
scriptSourceObject
(
)
const
;
mozilla
:
:
Span
<
const
RequestedModule
>
requestedModules
(
)
const
;
mozilla
:
:
Span
<
const
ImportEntry
>
importEntries
(
)
const
;
mozilla
:
:
Span
<
const
ExportEntry
>
localExportEntries
(
)
const
;
mozilla
:
:
Span
<
const
ExportEntry
>
indirectExportEntries
(
)
const
;
mozilla
:
:
Span
<
const
ExportEntry
>
starExportEntries
(
)
const
;
const
ExportNameVector
&
syntheticExportNames
(
)
const
;
IndirectBindingMap
&
importBindings
(
)
;
void
setStatus
(
ModuleStatus
newStatus
)
;
void
setDfsIndex
(
uint32_t
index
)
;
void
setDfsAncestorIndex
(
uint32_t
index
)
;
void
clearDfsIndexes
(
)
;
static
PromiseObject
*
createTopLevelCapability
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
)
;
bool
hasTopLevelAwait
(
)
const
;
bool
isAsyncEvaluating
(
)
const
;
void
setAsyncEvaluating
(
)
;
void
setEvaluationError
(
HandleValue
newValue
)
;
void
setPendingAsyncDependencies
(
uint32_t
newValue
)
;
void
setInitialTopLevelCapability
(
Handle
<
PromiseObject
*
>
capability
)
;
bool
hasTopLevelCapability
(
)
const
;
PromiseObject
*
maybeTopLevelCapability
(
)
const
;
PromiseObject
*
topLevelCapability
(
)
const
;
ListObject
*
asyncParentModules
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
maybePendingAsyncDependencies
(
)
const
;
uint32_t
pendingAsyncDependencies
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
maybeAsyncEvaluatingPostOrder
(
)
const
;
uint32_t
getAsyncEvaluatingPostOrder
(
)
const
;
void
clearAsyncEvaluatingPostOrder
(
)
;
void
setCycleRoot
(
ModuleObject
*
cycleRoot
)
;
ModuleObject
*
getCycleRoot
(
)
const
;
bool
hasCyclicModuleFields
(
)
const
;
bool
hasSyntheticModuleFields
(
)
const
;
LoadedModuleMap
&
loadedModules
(
)
;
const
LoadedModuleMap
&
loadedModules
(
)
const
;
static
void
onTopLevelEvaluationFinished
(
ModuleObject
*
module
)
;
static
bool
appendAsyncParentModule
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
Handle
<
ModuleObject
*
>
parent
)
;
[
[
nodiscard
]
]
static
bool
topLevelCapabilityResolve
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
)
;
[
[
nodiscard
]
]
static
bool
topLevelCapabilityReject
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
HandleValue
error
)
;
void
setMetaObject
(
JSObject
*
obj
)
;
static
bool
instantiateFunctionDeclarations
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
)
;
static
bool
execute
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
)
;
static
ModuleNamespaceObject
*
createNamespace
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
MutableHandle
<
UniquePtr
<
ExportNameVector
>
>
exports
)
;
static
bool
createEnvironment
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
)
;
static
bool
createSyntheticEnvironment
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
self
JS
:
:
HandleVector
<
Value
>
values
)
;
void
initAsyncSlots
(
JSContext
*
cx
bool
hasTopLevelAwait
Handle
<
ListObject
*
>
asyncParentModules
)
;
private
:
static
const
JSClassOps
classOps_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
CyclicModuleFields
*
cyclicModuleFields
(
)
;
const
CyclicModuleFields
*
cyclicModuleFields
(
)
const
;
SyntheticModuleFields
*
syntheticModuleFields
(
)
;
const
SyntheticModuleFields
*
syntheticModuleFields
(
)
const
;
}
;
using
VisitedModuleSet
=
GCHashSet
<
HeapPtr
<
ModuleObject
*
>
DefaultHasher
<
HeapPtr
<
ModuleObject
*
>
>
SystemAllocPolicy
>
;
struct
GraphLoadingStateRecord
{
explicit
GraphLoadingStateRecord
(
JSContext
*
cx
)
;
GraphLoadingStateRecord
(
JSContext
*
cx
JS
:
:
LoadModuleResolvedCallback
&
&
resolved
JS
:
:
LoadModuleRejectedCallback
&
&
rejected
)
;
void
trace
(
JSTracer
*
trc
)
;
VisitedModuleSet
visited
;
JS
:
:
LoadModuleResolvedCallback
resolved
;
JS
:
:
LoadModuleRejectedCallback
rejected
;
}
;
class
GraphLoadingStateRecordObject
:
public
NativeObject
{
public
:
enum
{
StateSlot
=
0
PromiseSlot
IsLoadingSlot
PendingModulesCountSlot
HostDefinedSlot
SlotCount
}
;
static
const
JSClass
class_
;
static
const
JSClassOps
classOps_
;
[
[
nodiscard
]
]
static
GraphLoadingStateRecordObject
*
create
(
JSContext
*
cx
bool
isLoading
uint32_t
pendingModulesCount
JS
:
:
LoadModuleResolvedCallback
&
&
resolved
JS
:
:
LoadModuleRejectedCallback
&
&
rejected
Handle
<
Value
>
hostDefined
)
;
[
[
nodiscard
]
]
static
GraphLoadingStateRecordObject
*
create
(
JSContext
*
cx
bool
isLoading
uint32_t
pendingModulesCount
Handle
<
PromiseObject
*
>
promise
Handle
<
Value
>
hostDefined
)
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
PromiseObject
*
promise
(
)
;
bool
isLoading
(
)
;
void
setIsLoading
(
bool
isLoading
)
;
uint32_t
pendingModulesCount
(
)
;
void
setPendingModulesCount
(
uint32_t
count
)
;
VisitedModuleSet
&
visited
(
)
;
Value
hostDefined
(
)
;
bool
resolved
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
hostDefined
)
;
bool
rejected
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
hostDefined
Handle
<
JS
:
:
Value
>
error
)
;
}
;
JSObject
*
GetOrCreateModuleMetaObject
(
JSContext
*
cx
HandleObject
module
)
;
JSObject
*
StartDynamicModuleImport
(
JSContext
*
cx
HandleScript
script
HandleValue
specifier
HandleValue
options
)
;
bool
OnModuleEvaluationFailure
(
JSContext
*
cx
HandleObject
evaluationPromise
JS
:
:
ModuleErrorBehaviour
errorBehaviour
)
;
bool
FinishDynamicModuleImport
(
JSContext
*
cx
HandleValue
contextValue
HandleObject
evaluationPromise
)
;
bool
ContinueLoadingImportedModule
(
JSContext
*
cx
Handle
<
Value
>
statePrivate
Handle
<
JSObject
*
>
result
Handle
<
Value
>
error
)
;
bool
FinishLoadingImportedModule
(
JSContext
*
cx
Handle
<
JSObject
*
>
referrer
HandleValue
referencingPrivate
Handle
<
JSObject
*
>
moduleRequest
HandleValue
statePrivate
Handle
<
JSObject
*
>
result
)
;
bool
FinishLoadingImportedModule
(
JSContext
*
cx
Handle
<
JSObject
*
>
referrer
HandleValue
referencingPrivate
Handle
<
JSObject
*
>
moduleRequest
Handle
<
JSObject
*
>
promise
Handle
<
JSObject
*
>
result
bool
usePromise
)
;
bool
FinishLoadingImportedModuleFailed
(
JSContext
*
cx
HandleValue
statePrivate
HandleValue
error
)
;
bool
FinishLoadingImportedModuleFailed
(
JSContext
*
cx
Handle
<
JSObject
*
>
promise
HandleValue
error
)
;
bool
FinishLoadingImportedModuleFailedWithPendingException
(
JSContext
*
cx
Handle
<
JSObject
*
>
promise
)
;
bool
ContinueDynamicImport
(
JSContext
*
cx
Handle
<
Value
>
referencingPrivate
Handle
<
JSObject
*
>
moduleRequest
Handle
<
JSObject
*
>
promise
Handle
<
JSObject
*
>
result
bool
usePromise
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
ModuleNamespaceObject
>
(
)
const
{
return
js
:
:
IsDerivedProxyObject
(
this
&
js
:
:
ModuleNamespaceObject
:
:
proxyHandler
)
;
}
#
endif
