#
include
"
builtin
/
ShadowRealm
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
builtin
/
WrappedFunctionObject
.
h
"
#
include
"
frontend
/
BytecodeCompilation
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
GlobalObject
.
h
"
#
include
"
js
/
Principals
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
ShadowRealmCallbacks
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
builtin
/
HandlerFunction
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
AutoStableStringChars
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
SourceOwnership
;
using
JS
:
:
SourceText
;
static
JSObject
*
DefaultNewShadowRealmGlobal
(
JSContext
*
cx
JS
:
:
RealmOptions
&
options
JSPrincipals
*
principals
Handle
<
JSObject
*
>
unused
)
{
static
const
JSClass
shadowRealmGlobal
=
{
"
ShadowRealmGlobal
"
JSCLASS_GLOBAL_FLAGS
&
JS
:
:
DefaultGlobalClassOps
}
;
return
JS_NewGlobalObject
(
cx
&
shadowRealmGlobal
principals
JS
:
:
FireOnNewGlobalHook
options
)
;
}
bool
ShadowRealmObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
isConstructing
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_CONSTRUCTOR
"
ShadowRealm
"
)
;
return
false
;
}
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_ShadowRealm
&
proto
)
)
{
return
false
;
}
Rooted
<
ShadowRealmObject
*
>
shadowRealmObj
(
cx
NewObjectWithClassProto
<
ShadowRealmObject
>
(
cx
proto
)
)
;
if
(
!
shadowRealmObj
)
{
return
false
;
}
JS
:
:
RealmOptions
options
(
cx
-
>
realm
(
)
-
>
creationOptions
(
)
cx
-
>
realm
(
)
-
>
behaviors
(
)
)
;
options
.
creationOptions
(
)
.
setExistingCompartment
(
cx
-
>
compartment
(
)
)
;
JS
:
:
GlobalCreationCallback
newGlobal
=
cx
-
>
runtime
(
)
-
>
getShadowRealmGlobalCreationCallback
(
)
;
if
(
!
newGlobal
)
{
newGlobal
=
DefaultNewShadowRealmGlobal
;
}
JSPrincipals
*
principals
=
JS
:
:
GetRealmPrincipals
(
cx
-
>
realm
(
)
)
;
Rooted
<
JSObject
*
>
global
(
cx
newGlobal
(
cx
options
principals
cx
-
>
global
(
)
)
)
;
if
(
!
global
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
global
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
shadowRealmObj
-
>
initFixedSlot
(
GlobalSlot
ObjectValue
(
*
global
)
)
;
JS
:
:
GlobalInitializeCallback
hostInitializeShadowRealm
=
cx
-
>
runtime
(
)
-
>
getShadowRealmInitializeGlobalCallback
(
)
;
if
(
hostInitializeShadowRealm
)
{
if
(
!
hostInitializeShadowRealm
(
cx
global
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setObject
(
*
shadowRealmObj
)
;
return
true
;
}
static
ShadowRealmObject
*
ValidateShadowRealmObject
(
JSContext
*
cx
Handle
<
JSObject
*
>
O
)
{
Rooted
<
JSObject
*
>
maybeUnwrappedO
(
cx
O
)
;
if
(
IsCrossCompartmentWrapper
(
O
)
)
{
maybeUnwrappedO
=
CheckedUnwrapDynamic
(
O
cx
)
;
if
(
!
maybeUnwrappedO
)
{
return
nullptr
;
}
}
if
(
!
maybeUnwrappedO
-
>
is
<
ShadowRealmObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_SHADOW_REALM
)
;
return
nullptr
;
}
return
&
maybeUnwrappedO
-
>
as
<
ShadowRealmObject
>
(
)
;
}
void
js
:
:
ReportPotentiallyDetailedMessage
(
JSContext
*
cx
const
unsigned
detailedError
const
unsigned
genericError
)
{
Rooted
<
Value
>
exception
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exception
)
)
{
return
;
}
JS_ClearPendingException
(
cx
)
;
JS
:
:
ErrorReportBuilder
jsReport
(
cx
)
;
JS
:
:
ExceptionStack
exnStack
(
cx
exception
nullptr
)
;
if
(
!
jsReport
.
init
(
cx
exnStack
JS
:
:
ErrorReportBuilder
:
:
NoSideEffects
)
)
{
JS_ClearPendingException
(
cx
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
genericError
)
;
return
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
detailedError
jsReport
.
toStringResult
(
)
.
c_str
(
)
)
;
}
static
bool
PerformShadowRealmEval
(
JSContext
*
cx
Handle
<
JSString
*
>
sourceText
Realm
*
callerRealm
Realm
*
evalRealm
MutableHandle
<
Value
>
rval
)
{
MOZ_ASSERT
(
callerRealm
!
=
evalRealm
)
;
if
(
!
cx
-
>
isRuntimeCodeGenEnabled
(
JS
:
:
RuntimeCode
:
:
JS
sourceText
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CSP_BLOCKED_SHADOWREALM
)
;
return
false
;
}
bool
compileSuccess
=
false
;
bool
evalSuccess
=
false
;
do
{
Rooted
<
GlobalObject
*
>
evalRealmGlobal
(
cx
evalRealm
-
>
maybeGlobal
(
)
)
;
AutoRealm
ar
(
cx
evalRealmGlobal
)
;
AutoStableStringChars
linearChars
(
cx
)
;
if
(
!
linearChars
.
initTwoByte
(
cx
sourceText
)
)
{
return
false
;
}
SourceText
<
char16_t
>
srcBuf
;
const
char16_t
*
chars
=
linearChars
.
twoByteRange
(
)
.
begin
(
)
.
get
(
)
;
SourceOwnership
ownership
=
linearChars
.
maybeGiveOwnershipToCaller
(
)
?
SourceOwnership
:
:
TakeOwnership
:
SourceOwnership
:
:
Borrowed
;
if
(
!
srcBuf
.
init
(
cx
chars
linearChars
.
length
(
)
ownership
)
)
{
return
false
;
}
RootedScript
callerScript
(
cx
)
;
const
char
*
filename
;
unsigned
lineno
;
uint32_t
pcOffset
;
bool
mutedErrors
;
DescribeScriptedCallerForCompilation
(
cx
&
callerScript
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
CompileOptions
options
(
cx
)
;
options
.
setIsRunOnce
(
true
)
.
setNoScriptRval
(
false
)
.
setMutedErrors
(
mutedErrors
)
.
setFileAndLine
(
filename
lineno
)
;
Rooted
<
Scope
*
>
enclosing
(
cx
&
evalRealmGlobal
-
>
emptyGlobalScope
(
)
)
;
RootedScript
script
(
cx
frontend
:
:
CompileEvalScript
(
cx
options
srcBuf
enclosing
evalRealmGlobal
)
)
;
compileSuccess
=
!
!
script
;
if
(
!
compileSuccess
)
{
break
;
}
Rooted
<
JSObject
*
>
environment
(
cx
&
evalRealmGlobal
-
>
lexicalEnvironment
(
)
)
;
evalSuccess
=
ExecuteKernel
(
cx
script
environment
NullFramePtr
(
)
rval
)
;
}
while
(
false
)
;
if
(
!
compileSuccess
)
{
Rooted
<
Value
>
exception
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exception
)
)
{
return
false
;
}
JS_ClearPendingException
(
cx
)
;
Rooted
<
Value
>
clonedException
(
cx
)
;
if
(
!
JS_StructuredClone
(
cx
exception
&
clonedException
nullptr
nullptr
)
)
{
return
false
;
}
JS_SetPendingException
(
cx
clonedException
)
;
return
false
;
}
if
(
!
evalSuccess
)
{
ReportPotentiallyDetailedMessage
(
cx
JSMSG_SHADOW_REALM_EVALUATE_FAILURE_DETAIL
JSMSG_SHADOW_REALM_EVALUATE_FAILURE
)
;
return
false
;
}
return
GetWrappedValue
(
cx
callerRealm
rval
rval
)
;
}
static
bool
ShadowRealm_evaluate
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
JSObject
*
>
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
{
return
false
;
}
Rooted
<
ShadowRealmObject
*
>
shadowRealm
(
cx
ValidateShadowRealmObject
(
cx
obj
)
)
;
if
(
!
shadowRealm
)
{
return
false
;
}
if
(
!
args
.
get
(
0
)
.
isString
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_EVALUATE_NOT_STRING
)
;
return
false
;
}
Rooted
<
JSString
*
>
sourceText
(
cx
args
.
get
(
0
)
.
toString
(
)
)
;
Realm
*
callerRealm
=
cx
-
>
realm
(
)
;
Realm
*
evalRealm
=
shadowRealm
-
>
getShadowRealm
(
)
;
return
PerformShadowRealmEval
(
cx
sourceText
callerRealm
evalRealm
args
.
rval
(
)
)
;
}
static
JSObject
*
ShadowRealmImportValue
(
JSContext
*
cx
Handle
<
JSString
*
>
specifierString
Handle
<
JSString
*
>
exportName
Realm
*
callerRealm
Realm
*
evalRealm
)
{
Rooted
<
JSObject
*
>
promiseConstructor
(
cx
JS
:
:
GetPromiseConstructor
(
cx
)
)
;
if
(
!
promiseConstructor
)
{
return
nullptr
;
}
Rooted
<
JSObject
*
>
promiseObject
(
cx
JS
:
:
NewPromiseObject
(
cx
nullptr
)
)
;
if
(
!
promiseObject
)
{
return
nullptr
;
}
Handle
<
PromiseObject
*
>
promise
=
promiseObject
.
as
<
PromiseObject
>
(
)
;
JS
:
:
ModuleDynamicImportHook
importHook
=
cx
-
>
runtime
(
)
-
>
moduleDynamicImportHook
;
if
(
!
importHook
)
{
JS_ReportErrorASCII
(
cx
"
Dynamic
module
import
is
disabled
or
not
supported
in
this
context
"
)
;
if
(
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
{
Rooted
<
GlobalObject
*
>
evalRealmGlobal
(
cx
evalRealm
-
>
maybeGlobal
(
)
)
;
AutoRealm
ar
(
cx
evalRealmGlobal
)
;
RootedScript
script
(
cx
)
;
const
char
*
filename
;
unsigned
lineno
;
uint32_t
pcOffset
;
bool
mutedErrors
;
DescribeScriptedCallerForCompilation
(
cx
&
script
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
MOZ_ASSERT
(
script
)
;
Rooted
<
Value
>
referencingPrivate
(
cx
script
-
>
sourceObject
(
)
-
>
getPrivate
(
)
)
;
cx
-
>
runtime
(
)
-
>
addRefScriptPrivate
(
referencingPrivate
)
;
Rooted
<
JSAtom
*
>
specifierAtom
(
cx
AtomizeString
(
cx
specifierString
)
)
;
if
(
!
specifierAtom
)
{
if
(
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
Rooted
<
ArrayObject
*
>
assertionArray
(
cx
)
;
Rooted
<
JSObject
*
>
moduleRequest
(
cx
ModuleRequestObject
:
:
create
(
cx
specifierAtom
assertionArray
)
)
;
if
(
!
moduleRequest
)
{
if
(
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
if
(
!
importHook
(
cx
referencingPrivate
moduleRequest
promise
)
)
{
cx
-
>
runtime
(
)
-
>
releaseScriptPrivate
(
referencingPrivate
)
;
if
(
!
cx
-
>
isExceptionPending
(
)
|
|
!
RejectPromiseWithPendingError
(
cx
promise
)
)
{
return
nullptr
;
}
return
promise
;
}
}
Rooted
<
JSObject
*
>
handlerObject
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
handlerObject
)
{
return
nullptr
;
}
Rooted
<
Value
>
calleeRealmValue
(
cx
PrivateValue
(
callerRealm
)
)
;
if
(
!
JS_DefineProperty
(
cx
handlerObject
"
calleeRealm
"
calleeRealmValue
JSPROP_READONLY
)
)
{
return
nullptr
;
}
if
(
!
JS_DefineProperty
(
cx
handlerObject
"
exportNameString
"
exportName
JSPROP_READONLY
)
)
{
return
nullptr
;
}
Rooted
<
Value
>
handlerValue
(
cx
ObjectValue
(
*
handlerObject
)
)
;
Rooted
<
JSFunction
*
>
onFulfilled
(
cx
NewHandlerWithExtraValue
(
cx
[
]
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
Rooted
<
JSObject
*
>
handlerObject
(
cx
&
ExtraValueFromHandler
(
args
)
.
toObject
(
)
)
;
Rooted
<
Value
>
realmValue
(
cx
)
;
Rooted
<
Value
>
exportNameValue
(
cx
)
;
MOZ_ALWAYS_TRUE
(
JS_GetProperty
(
cx
handlerObject
"
calleeRealm
"
&
realmValue
)
)
;
MOZ_ALWAYS_TRUE
(
JS_GetProperty
(
cx
handlerObject
"
exportNameString
"
&
exportNameValue
)
)
;
Rooted
<
Value
>
exportsValue
(
cx
args
.
get
(
0
)
)
;
MOZ_ASSERT
(
exportsValue
.
isObject
(
)
&
&
exportsValue
.
toObject
(
)
.
is
<
ModuleNamespaceObject
>
(
)
)
;
Rooted
<
ModuleNamespaceObject
*
>
exports
(
cx
&
exportsValue
.
toObject
(
)
.
as
<
ModuleNamespaceObject
>
(
)
)
;
MOZ_ASSERT
(
exportNameValue
.
isString
(
)
)
;
Rooted
<
JSString
*
>
string
(
cx
exportNameValue
.
toString
(
)
)
;
Rooted
<
jsid
>
stringId
(
cx
)
;
if
(
!
JS_StringToId
(
cx
string
&
stringId
)
)
{
return
false
;
}
bool
hasOwn
=
false
;
if
(
!
HasOwnProperty
(
cx
exports
stringId
&
hasOwn
)
)
{
return
false
;
}
if
(
!
hasOwn
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_VALUE_NOT_EXPORTED
)
;
return
false
;
}
Rooted
<
Value
>
value
(
cx
)
;
if
(
!
JS_GetPropertyById
(
cx
exports
stringId
&
value
)
)
{
return
false
;
}
Realm
*
callerRealm
=
static_cast
<
Realm
*
>
(
realmValue
.
toPrivate
(
)
)
;
return
GetWrappedValue
(
cx
callerRealm
value
args
.
rval
(
)
)
;
}
promise
handlerValue
)
)
;
if
(
!
onFulfilled
)
{
return
nullptr
;
}
Rooted
<
JSFunction
*
>
onRejected
(
cx
NewHandler
(
cx
[
]
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_IMPORTVALUE_FAILED
)
;
return
false
;
}
promise
)
)
;
if
(
!
onFulfilled
)
{
return
nullptr
;
}
return
JS
:
:
CallOriginalPromiseThen
(
cx
promise
onFulfilled
onRejected
)
;
}
static
bool
ShadowRealm_importValue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
JSObject
*
>
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
{
return
false
;
}
Rooted
<
ShadowRealmObject
*
>
shadowRealm
(
cx
ValidateShadowRealmObject
(
cx
obj
)
)
;
if
(
!
shadowRealm
)
{
return
false
;
}
Rooted
<
JSString
*
>
specifierString
(
cx
ToString
<
CanGC
>
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
specifierString
)
{
return
false
;
}
if
(
!
args
.
get
(
1
)
.
isString
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHADOW_REALM_EXPORT_NOT_STRING
)
;
return
false
;
}
Rooted
<
JSString
*
>
exportName
(
cx
args
.
get
(
1
)
.
toString
(
)
)
;
if
(
!
exportName
)
{
return
false
;
}
Realm
*
callerRealm
=
cx
-
>
realm
(
)
;
Realm
*
evalRealm
=
shadowRealm
-
>
getShadowRealm
(
)
;
Rooted
<
JSObject
*
>
res
(
cx
ShadowRealmImportValue
(
cx
specifierString
exportName
callerRealm
evalRealm
)
)
;
if
(
!
res
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
ObjectValue
(
*
res
)
)
;
return
true
;
}
static
const
JSFunctionSpec
shadowrealm_methods
[
]
=
{
JS_FN
(
"
evaluate
"
ShadowRealm_evaluate
1
0
)
JS_FN
(
"
importValue
"
ShadowRealm_importValue
2
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
shadowrealm_properties
[
]
=
{
JS_STRING_SYM_PS
(
toStringTag
"
ShadowRealm
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
ClassSpec
ShadowRealmObjectClassSpec
=
{
GenericCreateConstructor
<
ShadowRealmObject
:
:
construct
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
ShadowRealmObject
>
nullptr
nullptr
shadowrealm_methods
shadowrealm_properties
}
;
const
JSClass
ShadowRealmObject
:
:
class_
=
{
"
ShadowRealm
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_ShadowRealm
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
ShadowRealmObject
:
:
SlotCount
)
JS_NULL_CLASS_OPS
&
ShadowRealmObjectClassSpec
}
;
const
JSClass
ShadowRealmObject
:
:
protoClass_
=
{
"
ShadowRealm
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_ShadowRealm
)
JS_NULL_CLASS_OPS
&
ShadowRealmObjectClassSpec
}
;
