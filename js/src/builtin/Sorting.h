#
ifndef
builtin_Sorting_h
#
define
builtin_Sorting_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
JSObject
.
h
"
namespace
js
{
enum
class
ArraySortResult
:
uint32_t
{
Failure
Done
CallJS
CallJSSameRealmNoUnderflow
}
;
enum
class
ArraySortKind
{
Array
TypedArray
}
;
class
alignas
(
8
)
ArraySortData
{
public
:
enum
class
ComparatorKind
:
uint8_t
{
Unoptimized
JS
JSSameRealmNoUnderflow
}
;
static
constexpr
size_t
InsertionSortMaxLength
=
8
;
static
constexpr
size_t
ComparatorActualArgs
=
2
;
using
ValueVector
=
GCVector
<
Value
8
SystemAllocPolicy
>
;
protected
:
uintptr_t
descriptor_
;
JSObject
*
comparator_
=
nullptr
;
Value
thisv
;
Value
callArgs
[
ComparatorActualArgs
]
;
private
:
ValueVector
vec
;
Value
item
;
JSContext
*
cx_
;
JSObject
*
obj_
=
nullptr
;
Value
*
list
;
Value
*
out
;
uint32_t
length
;
uint32_t
denseLen
;
uint32_t
windowSize
;
uint32_t
start
;
uint32_t
mid
;
uint32_t
end
;
uint32_t
i
j
k
;
enum
class
State
:
uint8_t
{
Initial
InsertionSortCall1
InsertionSortCall2
MergeSortCall1
MergeSortCall2
}
;
State
state
=
State
:
:
Initial
;
ComparatorKind
comparatorKind_
;
#
if
!
defined
(
JS_64BIT
)
&
&
!
defined
(
DEBUG
)
protected
:
uint32_t
padding
[
2
]
;
#
endif
private
:
static_assert
(
decltype
(
vec
)
:
:
InlineLength
<
=
InsertionSortMaxLength
)
;
template
<
ArraySortKind
Kind
>
static
MOZ_ALWAYS_INLINE
ArraySortResult
sortWithComparatorShared
(
ArraySortData
*
d
)
;
public
:
explicit
inline
ArraySortData
(
JSContext
*
cx
)
;
void
MOZ_ALWAYS_INLINE
init
(
JSObject
*
obj
JSObject
*
comparator
ValueVector
&
&
vec
uint32_t
length
uint32_t
denseLen
)
;
JSContext
*
cx
(
)
const
{
return
cx_
;
}
JSObject
*
comparator
(
)
const
{
MOZ_ASSERT
(
comparator_
)
;
return
comparator_
;
}
Value
returnValue
(
)
const
{
return
callArgs
[
0
]
;
}
void
setReturnValue
(
JSObject
*
obj
)
{
callArgs
[
0
]
.
setObject
(
*
obj
)
;
}
Value
comparatorArg
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
ComparatorActualArgs
)
;
return
callArgs
[
index
]
;
}
Value
comparatorThisValue
(
)
const
{
return
thisv
;
}
Value
comparatorReturnValue
(
)
const
{
return
callArgs
[
0
]
;
}
void
setComparatorArgs
(
const
Value
&
x
const
Value
&
y
)
{
callArgs
[
0
]
=
x
;
callArgs
[
1
]
=
y
;
}
void
setComparatorReturnValue
(
const
Value
&
v
)
{
callArgs
[
0
]
=
v
;
}
ComparatorKind
comparatorKind
(
)
const
{
return
comparatorKind_
;
}
static
ArraySortResult
sortArrayWithComparator
(
ArraySortData
*
d
)
;
static
ArraySortResult
sortTypedArrayWithComparator
(
ArraySortData
*
d
)
;
inline
void
freeMallocData
(
)
;
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
int32_t
offsetOfDescriptor
(
)
{
return
offsetof
(
ArraySortData
descriptor_
)
;
}
static
constexpr
int32_t
offsetOfComparator
(
)
{
return
offsetof
(
ArraySortData
comparator_
)
;
}
static
constexpr
int32_t
offsetOfComparatorReturnValue
(
)
{
return
offsetof
(
ArraySortData
callArgs
[
0
]
)
;
}
static
constexpr
int32_t
offsetOfComparatorThis
(
)
{
return
offsetof
(
ArraySortData
thisv
)
;
}
static
constexpr
int32_t
offsetOfComparatorArgs
(
)
{
return
offsetof
(
ArraySortData
callArgs
)
;
}
}
;
ArraySortResult
CallComparatorSlow
(
ArraySortData
*
d
const
Value
&
x
const
Value
&
y
)
;
}
#
endif
