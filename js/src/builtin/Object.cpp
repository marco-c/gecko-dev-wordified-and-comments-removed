#
include
"
builtin
/
Object
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
AsyncFunction
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
#
ifdef
FUZZING
#
include
"
builtin
/
TestingFunctions
.
h
"
#
endif
using
namespace
js
;
using
js
:
:
frontend
:
:
IsIdentifier
;
using
mozilla
:
:
ArrayLength
;
bool
js
:
:
obj_construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
nullptr
)
;
if
(
args
.
isConstructing
(
)
&
&
(
&
args
.
newTarget
(
)
.
toObject
(
)
!
=
&
args
.
callee
(
)
)
)
{
RootedObject
newTarget
(
cx
&
args
.
newTarget
(
)
.
toObject
(
)
)
;
obj
=
CreateThis
(
cx
&
PlainObject
:
:
class_
newTarget
)
;
if
(
!
obj
)
return
false
;
}
else
if
(
args
.
length
(
)
>
0
&
&
!
args
[
0
]
.
isNullOrUndefined
(
)
)
{
obj
=
ToObject
(
cx
args
[
0
]
)
;
if
(
!
obj
)
return
false
;
}
else
{
if
(
!
NewObjectScriptedCall
(
cx
&
obj
)
)
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
js
:
:
obj_propertyIsEnumerable
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
idValue
=
args
.
get
(
0
)
;
jsid
id
;
if
(
args
.
thisv
(
)
.
isObject
(
)
&
&
ValueToId
<
NoGC
>
(
cx
idValue
&
id
)
)
{
JSObject
*
obj
=
&
args
.
thisv
(
)
.
toObject
(
)
;
PropertyResult
prop
;
if
(
obj
-
>
isNative
(
)
&
&
NativeLookupOwnProperty
<
NoGC
>
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
id
&
prop
)
)
{
if
(
!
prop
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
unsigned
attrs
=
GetPropertyAttributes
(
obj
prop
)
;
args
.
rval
(
)
.
setBoolean
(
(
attrs
&
JSPROP_ENUMERATE
)
!
=
0
)
;
return
true
;
}
}
RootedId
idRoot
(
cx
)
;
if
(
!
ToPropertyKey
(
cx
idValue
&
idRoot
)
)
return
false
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
idRoot
&
desc
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
desc
.
object
(
)
&
&
desc
.
enumerable
(
)
)
;
return
true
;
}
#
if
JS_HAS_TOSOURCE
static
bool
obj_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
CheckRecursionLimit
(
cx
)
)
return
false
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
JSString
*
str
=
ObjectToSource
(
cx
obj
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
template
<
typename
CharT
>
static
bool
Consume
(
const
CharT
*
&
s
const
CharT
*
e
const
char
*
chars
)
{
size_t
len
=
strlen
(
chars
)
;
if
(
s
+
len
>
=
e
)
return
false
;
if
(
!
EqualChars
(
s
chars
len
)
)
return
false
;
s
+
=
len
;
return
true
;
}
template
<
typename
CharT
>
static
void
ConsumeSpaces
(
const
CharT
*
&
s
const
CharT
*
e
)
{
while
(
*
s
=
=
'
'
&
&
s
<
e
)
s
+
+
;
}
template
<
typename
CharT
>
static
bool
ArgsAndBodySubstring
(
mozilla
:
:
Range
<
const
CharT
>
chars
size_t
*
outOffset
size_t
*
outLen
)
{
const
CharT
*
const
start
=
chars
.
begin
(
)
.
get
(
)
;
const
CharT
*
s
=
start
;
const
CharT
*
e
=
chars
.
end
(
)
.
get
(
)
;
if
(
s
=
=
e
)
return
false
;
if
(
*
s
=
=
'
(
'
&
&
*
(
e
-
1
)
=
=
'
)
'
)
{
s
+
+
;
e
-
-
;
}
(
void
)
Consume
(
s
e
"
async
"
)
;
ConsumeSpaces
(
s
e
)
;
(
void
)
(
Consume
(
s
e
"
function
"
)
|
|
Consume
(
s
e
"
get
"
)
|
|
Consume
(
s
e
"
set
"
)
)
;
ConsumeSpaces
(
s
e
)
;
(
void
)
Consume
(
s
e
"
*
"
)
;
ConsumeSpaces
(
s
e
)
;
if
(
Consume
(
s
e
"
[
"
)
)
{
s
=
js_strchr_limit
(
s
'
]
'
e
)
;
if
(
!
s
)
return
false
;
s
+
+
;
ConsumeSpaces
(
s
e
)
;
if
(
*
s
!
=
'
(
'
)
return
false
;
}
else
{
s
=
js_strchr_limit
(
s
'
(
'
e
)
;
if
(
!
s
)
return
false
;
}
*
outOffset
=
s
-
start
;
*
outLen
=
e
-
s
;
MOZ_ASSERT
(
*
outOffset
+
*
outLen
<
=
chars
.
length
(
)
)
;
return
true
;
}
enum
class
PropertyKind
{
Getter
Setter
Method
Normal
}
;
JSString
*
js
:
:
ObjectToSource
(
JSContext
*
cx
HandleObject
obj
)
{
bool
outermost
=
cx
-
>
cycleDetectorVector
(
)
.
empty
(
)
;
AutoCycleDetector
detector
(
cx
obj
)
;
if
(
!
detector
.
init
(
)
)
return
nullptr
;
if
(
detector
.
foundCycle
(
)
)
return
NewStringCopyZ
<
CanGC
>
(
cx
"
{
}
"
)
;
StringBuffer
buf
(
cx
)
;
if
(
outermost
&
&
!
buf
.
append
(
'
(
'
)
)
return
nullptr
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
nullptr
;
AutoIdVector
idv
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
idv
)
)
return
nullptr
;
bool
comma
=
false
;
auto
AddProperty
=
[
cx
&
comma
&
buf
]
(
HandleId
id
HandleValue
val
PropertyKind
kind
)
-
>
bool
{
RootedString
idstr
(
cx
)
;
if
(
JSID_IS_SYMBOL
(
id
)
)
{
RootedValue
v
(
cx
SymbolValue
(
JSID_TO_SYMBOL
(
id
)
)
)
;
idstr
=
ValueToSource
(
cx
v
)
;
if
(
!
idstr
)
return
false
;
}
else
{
RootedValue
idv
(
cx
IdToValue
(
id
)
)
;
idstr
=
ToString
<
CanGC
>
(
cx
idv
)
;
if
(
!
idstr
)
return
false
;
if
(
JSID_IS_ATOM
(
id
)
?
!
IsIdentifier
(
JSID_TO_ATOM
(
id
)
)
:
JSID_TO_INT
(
id
)
<
0
)
{
idstr
=
QuoteString
(
cx
idstr
char16_t
(
'
\
'
'
)
)
;
if
(
!
idstr
)
return
false
;
}
}
RootedString
valsource
(
cx
ValueToSource
(
cx
val
)
)
;
if
(
!
valsource
)
return
false
;
RootedLinearString
valstr
(
cx
valsource
-
>
ensureLinear
(
cx
)
)
;
if
(
!
valstr
)
return
false
;
if
(
comma
&
&
!
buf
.
append
(
"
"
)
)
return
false
;
comma
=
true
;
size_t
voffset
vlength
;
if
(
kind
=
=
PropertyKind
:
:
Getter
|
|
kind
=
=
PropertyKind
:
:
Setter
|
|
kind
=
=
PropertyKind
:
:
Method
)
{
RootedFunction
fun
(
cx
)
;
if
(
val
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
fun
=
&
val
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
(
(
fun
-
>
isGetter
(
)
&
&
kind
=
=
PropertyKind
:
:
Getter
)
|
|
(
fun
-
>
isSetter
(
)
&
&
kind
=
=
PropertyKind
:
:
Setter
)
|
|
kind
=
=
PropertyKind
:
:
Method
)
&
&
fun
-
>
explicitName
(
)
)
{
bool
result
;
if
(
!
EqualStrings
(
cx
fun
-
>
explicitName
(
)
idstr
&
result
)
)
return
false
;
if
(
result
)
{
if
(
!
buf
.
append
(
valstr
)
)
return
false
;
return
true
;
}
}
}
{
bool
success
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
valstr
-
>
hasLatin1Chars
(
)
)
success
=
ArgsAndBodySubstring
(
valstr
-
>
latin1Range
(
nogc
)
&
voffset
&
vlength
)
;
else
success
=
ArgsAndBodySubstring
(
valstr
-
>
twoByteRange
(
nogc
)
&
voffset
&
vlength
)
;
if
(
!
success
)
kind
=
PropertyKind
:
:
Normal
;
}
if
(
kind
=
=
PropertyKind
:
:
Getter
)
{
if
(
!
buf
.
append
(
"
get
"
)
)
return
false
;
}
else
if
(
kind
=
=
PropertyKind
:
:
Setter
)
{
if
(
!
buf
.
append
(
"
set
"
)
)
return
false
;
}
else
if
(
kind
=
=
PropertyKind
:
:
Method
&
&
fun
)
{
if
(
IsWrappedAsyncFunction
(
fun
)
)
{
if
(
!
buf
.
append
(
"
async
"
)
)
return
false
;
}
if
(
fun
-
>
isStarGenerator
(
)
)
{
if
(
!
buf
.
append
(
'
*
'
)
)
return
false
;
}
}
}
bool
needsBracket
=
JSID_IS_SYMBOL
(
id
)
;
if
(
needsBracket
&
&
!
buf
.
append
(
'
[
'
)
)
return
false
;
if
(
!
buf
.
append
(
idstr
)
)
return
false
;
if
(
needsBracket
&
&
!
buf
.
append
(
'
]
'
)
)
return
false
;
if
(
kind
=
=
PropertyKind
:
:
Getter
|
|
kind
=
=
PropertyKind
:
:
Setter
|
|
kind
=
=
PropertyKind
:
:
Method
)
{
if
(
!
buf
.
appendSubstring
(
valstr
voffset
vlength
)
)
return
false
;
}
else
{
if
(
!
buf
.
append
(
'
:
'
)
)
return
false
;
if
(
!
buf
.
append
(
valstr
)
)
return
false
;
}
return
true
;
}
;
RootedId
id
(
cx
)
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
RootedValue
val
(
cx
)
;
RootedFunction
fun
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
idv
.
length
(
)
;
+
+
i
)
{
id
=
idv
[
i
]
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
)
return
nullptr
;
if
(
!
desc
.
object
(
)
)
continue
;
if
(
desc
.
isAccessorDescriptor
(
)
)
{
if
(
desc
.
hasGetterObject
(
)
&
&
desc
.
getterObject
(
)
)
{
val
.
setObject
(
*
desc
.
getterObject
(
)
)
;
if
(
!
AddProperty
(
id
val
PropertyKind
:
:
Getter
)
)
return
nullptr
;
}
if
(
desc
.
hasSetterObject
(
)
&
&
desc
.
setterObject
(
)
)
{
val
.
setObject
(
*
desc
.
setterObject
(
)
)
;
if
(
!
AddProperty
(
id
val
PropertyKind
:
:
Setter
)
)
return
nullptr
;
}
continue
;
}
val
.
set
(
desc
.
value
(
)
)
;
if
(
IsFunctionObject
(
val
fun
.
address
(
)
)
)
{
if
(
IsWrappedAsyncFunction
(
fun
)
)
fun
=
GetUnwrappedAsyncFunction
(
fun
)
;
if
(
fun
-
>
isMethod
(
)
)
{
if
(
!
AddProperty
(
id
val
PropertyKind
:
:
Method
)
)
return
nullptr
;
continue
;
}
}
if
(
!
AddProperty
(
id
val
PropertyKind
:
:
Normal
)
)
return
nullptr
;
}
if
(
!
buf
.
append
(
'
}
'
)
)
return
nullptr
;
if
(
outermost
&
&
!
buf
.
append
(
'
)
'
)
)
return
nullptr
;
return
buf
.
finishString
(
)
;
}
#
endif
static
bool
GetBuiltinTagSlow
(
JSContext
*
cx
HandleObject
obj
MutableHandleString
builtinTag
)
{
bool
isArray
;
if
(
!
IsArray
(
cx
obj
&
isArray
)
)
return
false
;
if
(
isArray
)
{
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectArray
)
;
return
true
;
}
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
return
false
;
switch
(
cls
)
{
case
ESClass
:
:
String
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectString
)
;
return
true
;
case
ESClass
:
:
Arguments
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectArguments
)
;
return
true
;
case
ESClass
:
:
Error
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectError
)
;
return
true
;
case
ESClass
:
:
Boolean
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectBoolean
)
;
return
true
;
case
ESClass
:
:
Number
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectNumber
)
;
return
true
;
case
ESClass
:
:
Date
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectDate
)
;
return
true
;
case
ESClass
:
:
RegExp
:
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectRegExp
)
;
return
true
;
default
:
if
(
obj
-
>
isCallable
(
)
)
{
RootedObject
unwrapped
(
cx
CheckedUnwrap
(
obj
)
)
;
if
(
!
unwrapped
|
|
!
unwrapped
-
>
getClass
(
)
-
>
isDOMClass
(
)
)
{
builtinTag
.
set
(
cx
-
>
names
(
)
.
objectFunction
)
;
return
true
;
}
}
builtinTag
.
set
(
nullptr
)
;
return
true
;
}
}
bool
js
:
:
obj_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
thisv
(
)
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
objectUndefined
)
;
return
true
;
}
if
(
args
.
thisv
(
)
.
isNull
(
)
)
{
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
objectNull
)
;
return
true
;
}
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
RootedString
builtinTag
(
cx
)
;
const
Class
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
MOZ_UNLIKELY
(
clasp
-
>
isProxy
(
)
)
)
{
if
(
!
GetBuiltinTagSlow
(
cx
obj
&
builtinTag
)
)
return
false
;
}
else
{
if
(
clasp
=
=
&
PlainObject
:
:
class_
|
|
clasp
=
=
&
UnboxedPlainObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectObject
;
}
else
if
(
clasp
=
=
&
ArrayObject
:
:
class_
|
|
clasp
=
=
&
UnboxedArrayObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectArray
;
}
else
if
(
clasp
=
=
&
JSFunction
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectFunction
;
}
else
if
(
clasp
=
=
&
StringObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectString
;
}
else
if
(
clasp
=
=
&
NumberObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectNumber
;
}
else
if
(
clasp
=
=
&
BooleanObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectBoolean
;
}
else
if
(
clasp
=
=
&
DateObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectDate
;
}
else
if
(
clasp
=
=
&
RegExpObject
:
:
class_
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectRegExp
;
}
else
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectArguments
;
}
else
if
(
obj
-
>
is
<
ErrorObject
>
(
)
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectError
;
}
else
if
(
obj
-
>
isCallable
(
)
&
&
!
obj
-
>
getClass
(
)
-
>
isDOMClass
(
)
)
{
builtinTag
=
cx
-
>
names
(
)
.
objectFunction
;
}
#
ifdef
DEBUG
RootedString
builtinTagSlow
(
cx
)
;
if
(
!
GetBuiltinTagSlow
(
cx
obj
&
builtinTagSlow
)
)
return
false
;
if
(
clasp
=
=
&
PlainObject
:
:
class_
|
|
clasp
=
=
&
UnboxedPlainObject
:
:
class_
)
MOZ_ASSERT
(
!
builtinTagSlow
)
;
else
MOZ_ASSERT
(
builtinTagSlow
=
=
builtinTag
)
;
#
endif
}
RootedValue
tag
(
cx
)
;
if
(
!
GetInterestingSymbolProperty
(
cx
obj
cx
-
>
wellKnownSymbols
(
)
.
toStringTag
&
tag
)
)
return
false
;
if
(
!
tag
.
isString
(
)
)
{
if
(
!
builtinTag
)
{
const
char
*
className
=
GetObjectClassName
(
cx
obj
)
;
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
"
[
object
"
)
|
|
!
sb
.
append
(
className
strlen
(
className
)
)
|
|
!
sb
.
append
(
"
]
"
)
)
{
return
false
;
}
builtinTag
=
sb
.
finishAtom
(
)
;
if
(
!
builtinTag
)
return
false
;
}
args
.
rval
(
)
.
setString
(
builtinTag
)
;
return
true
;
}
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
"
[
object
"
)
|
|
!
sb
.
append
(
tag
.
toString
(
)
)
|
|
!
sb
.
append
(
"
]
"
)
)
return
false
;
JSString
*
str
=
sb
.
finishAtom
(
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
obj_setPrototypeOf
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
<
2
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_MORE_ARGS_NEEDED
"
Object
.
setPrototypeOf
"
"
1
"
"
"
)
;
return
false
;
}
if
(
args
[
0
]
.
isNullOrUndefined
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_CONVERT_TO
args
[
0
]
.
isNull
(
)
?
"
null
"
:
"
undefined
"
"
object
"
)
;
return
false
;
}
if
(
!
args
[
1
]
.
isObjectOrNull
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_EXPECTED_TYPE
"
Object
.
setPrototypeOf
"
"
an
object
or
null
"
InformalValueTypeName
(
args
[
1
]
)
)
;
return
false
;
}
if
(
!
args
[
0
]
.
isObject
(
)
)
{
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
}
RootedObject
obj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedObject
newProto
(
cx
args
[
1
]
.
toObjectOrNull
(
)
)
;
if
(
!
SetPrototype
(
cx
obj
newProto
)
)
return
false
;
args
.
rval
(
)
.
set
(
args
[
0
]
)
;
return
true
;
}
static
bool
PropertyIsEnumerable
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
enumerable
)
{
PropertyResult
prop
;
if
(
obj
-
>
isNative
(
)
&
&
NativeLookupOwnProperty
<
NoGC
>
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
id
&
prop
)
)
{
if
(
!
prop
)
{
*
enumerable
=
false
;
return
true
;
}
unsigned
attrs
=
GetPropertyAttributes
(
obj
prop
)
;
*
enumerable
=
(
attrs
&
JSPROP_ENUMERATE
)
!
=
0
;
return
true
;
}
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
)
return
false
;
*
enumerable
=
desc
.
object
(
)
&
&
desc
.
enumerable
(
)
;
return
true
;
}
static
bool
TryAssignNative
(
JSContext
*
cx
HandleObject
to
HandleObject
from
bool
*
optimized
)
{
*
optimized
=
false
;
if
(
!
from
-
>
isNative
(
)
|
|
!
to
-
>
isNative
(
)
)
return
true
;
NativeObject
*
fromNative
=
&
from
-
>
as
<
NativeObject
>
(
)
;
if
(
fromNative
-
>
getDenseInitializedLength
(
)
>
0
|
|
fromNative
-
>
isIndexed
(
)
|
|
fromNative
-
>
is
<
TypedArrayObject
>
(
)
|
|
fromNative
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
|
|
fromNative
-
>
getClass
(
)
-
>
getEnumerate
(
)
)
{
return
true
;
}
using
ShapeVector
=
GCVector
<
Shape
*
8
>
;
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
RootedShape
fromShape
(
cx
fromNative
-
>
lastProperty
(
)
)
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
fromShape
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
if
(
MOZ_UNLIKELY
(
JSID_IS_SYMBOL
(
r
.
front
(
)
.
propidRaw
(
)
)
)
)
return
true
;
if
(
MOZ_UNLIKELY
(
!
shapes
.
append
(
&
r
.
front
(
)
)
)
)
return
false
;
}
*
optimized
=
true
;
RootedShape
shape
(
cx
)
;
RootedValue
propValue
(
cx
)
;
RootedId
nextKey
(
cx
)
;
RootedValue
toReceiver
(
cx
ObjectValue
(
*
to
)
)
;
for
(
size_t
i
=
shapes
.
length
(
)
;
i
>
0
;
i
-
-
)
{
shape
=
shapes
[
i
-
1
]
;
nextKey
=
shape
-
>
propid
(
)
;
if
(
MOZ_LIKELY
(
from
-
>
isNative
(
)
&
&
from
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
=
=
fromShape
&
&
shape
-
>
hasDefaultGetter
(
)
&
&
shape
-
>
hasSlot
(
)
)
)
{
if
(
!
shape
-
>
enumerable
(
)
)
continue
;
propValue
=
from
-
>
as
<
NativeObject
>
(
)
.
getSlot
(
shape
-
>
slot
(
)
)
;
}
else
{
bool
enumerable
;
if
(
!
PropertyIsEnumerable
(
cx
from
nextKey
&
enumerable
)
)
return
false
;
if
(
!
enumerable
)
continue
;
if
(
!
GetProperty
(
cx
from
from
nextKey
&
propValue
)
)
return
false
;
}
ObjectOpResult
result
;
if
(
MOZ_UNLIKELY
(
!
SetProperty
(
cx
to
nextKey
propValue
toReceiver
result
)
)
)
return
false
;
if
(
MOZ_UNLIKELY
(
!
result
.
checkStrict
(
cx
to
nextKey
)
)
)
return
false
;
}
return
true
;
}
static
bool
AssignSlow
(
JSContext
*
cx
HandleObject
to
HandleObject
from
)
{
AutoIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
from
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
&
keys
)
)
return
false
;
RootedId
nextKey
(
cx
)
;
RootedValue
propValue
(
cx
)
;
for
(
size_t
i
=
0
len
=
keys
.
length
(
)
;
i
<
len
;
i
+
+
)
{
nextKey
=
keys
[
i
]
;
bool
enumerable
;
if
(
MOZ_UNLIKELY
(
!
PropertyIsEnumerable
(
cx
from
nextKey
&
enumerable
)
)
)
return
false
;
if
(
!
enumerable
)
continue
;
if
(
MOZ_UNLIKELY
(
!
GetProperty
(
cx
from
from
nextKey
&
propValue
)
)
)
return
false
;
if
(
MOZ_UNLIKELY
(
!
SetProperty
(
cx
to
nextKey
propValue
)
)
)
return
false
;
}
return
true
;
}
static
bool
obj_assign
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
to
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
to
)
return
false
;
RootedObject
from
(
cx
)
;
for
(
size_t
i
=
1
;
i
<
args
.
length
(
)
;
i
+
+
)
{
if
(
args
[
i
]
.
isNullOrUndefined
(
)
)
continue
;
from
=
ToObject
(
cx
args
[
i
]
)
;
if
(
!
from
)
return
false
;
bool
optimized
;
if
(
!
TryAssignNative
(
cx
to
from
&
optimized
)
)
return
false
;
if
(
optimized
)
continue
;
if
(
!
AssignSlow
(
cx
to
from
)
)
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
to
)
;
return
true
;
}
#
if
JS_HAS_OBJ_WATCHPOINT
bool
js
:
:
WatchHandler
(
JSContext
*
cx
JSObject
*
obj_
jsid
id_
const
JS
:
:
Value
&
old
JS
:
:
Value
*
nvp
void
*
closure
)
{
RootedObject
obj
(
cx
obj_
)
;
RootedId
id
(
cx
id_
)
;
AutoResolving
resolving
(
cx
obj
id
AutoResolving
:
:
WATCH
)
;
if
(
resolving
.
alreadyStarted
(
)
)
return
true
;
FixedInvokeArgs
<
3
>
args
(
cx
)
;
args
[
0
]
.
set
(
IdToValue
(
id
)
)
;
args
[
1
]
.
set
(
old
)
;
args
[
2
]
.
set
(
*
nvp
)
;
RootedValue
callable
(
cx
ObjectValue
(
*
static_cast
<
JSObject
*
>
(
closure
)
)
)
;
RootedValue
thisv
(
cx
ObjectValue
(
*
obj
)
)
;
RootedValue
rv
(
cx
)
;
if
(
!
Call
(
cx
callable
thisv
args
&
rv
)
)
return
false
;
*
nvp
=
rv
;
return
true
;
}
static
bool
obj_watch
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
if
(
!
GlobalObject
:
:
warnOnceAboutWatch
(
cx
obj
)
)
return
false
;
if
(
args
.
length
(
)
<
=
1
)
{
ReportMissingArg
(
cx
args
.
calleev
(
)
1
)
;
return
false
;
}
RootedObject
callable
(
cx
ValueToCallable
(
cx
args
[
1
]
args
.
length
(
)
-
2
)
)
;
if
(
!
callable
)
return
false
;
RootedId
propid
(
cx
)
;
if
(
!
ValueToId
<
CanGC
>
(
cx
args
[
0
]
&
propid
)
)
return
false
;
if
(
!
WatchProperty
(
cx
obj
propid
callable
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
obj_unwatch
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
if
(
!
GlobalObject
:
:
warnOnceAboutWatch
(
cx
obj
)
)
return
false
;
RootedId
id
(
cx
)
;
if
(
args
.
length
(
)
!
=
0
)
{
if
(
!
ValueToId
<
CanGC
>
(
cx
args
[
0
]
&
id
)
)
return
false
;
}
else
{
id
=
JSID_VOID
;
}
if
(
!
UnwatchProperty
(
cx
obj
id
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
#
endif
static
bool
obj_isPrototypeOf
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
<
1
|
|
!
args
[
0
]
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
bool
isDelegate
;
if
(
!
IsDelegate
(
cx
obj
args
[
0
]
&
isDelegate
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
isDelegate
)
;
return
true
;
}
PlainObject
*
js
:
:
ObjectCreateImpl
(
JSContext
*
cx
HandleObject
proto
NewObjectKind
newKind
HandleObjectGroup
group
)
{
gc
:
:
AllocKind
allocKind
=
GuessObjectGCKind
(
0
)
;
if
(
!
proto
)
{
RootedObjectGroup
ngroup
(
cx
group
)
;
if
(
!
ngroup
)
{
ngroup
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Null
)
;
if
(
!
ngroup
)
return
nullptr
;
}
MOZ_ASSERT
(
!
ngroup
-
>
proto
(
)
.
toObjectOrNull
(
)
)
;
return
NewObjectWithGroup
<
PlainObject
>
(
cx
ngroup
allocKind
newKind
)
;
}
return
NewObjectWithGivenProto
<
PlainObject
>
(
cx
proto
allocKind
newKind
)
;
}
PlainObject
*
js
:
:
ObjectCreateWithTemplate
(
JSContext
*
cx
HandlePlainObject
templateObj
)
{
RootedObject
proto
(
cx
templateObj
-
>
staticPrototype
(
)
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
return
ObjectCreateImpl
(
cx
proto
GenericObject
group
)
;
}
static
bool
ObjectDefineProperties
(
JSContext
*
cx
HandleObject
obj
HandleValue
properties
)
{
RootedObject
props
(
cx
ToObject
(
cx
properties
)
)
;
if
(
!
props
)
return
false
;
AutoIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
props
JSITER_OWNONLY
|
JSITER_SYMBOLS
|
JSITER_HIDDEN
&
keys
)
)
return
false
;
RootedId
nextKey
(
cx
)
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
RootedValue
descObj
(
cx
)
;
Rooted
<
PropertyDescriptorVector
>
descriptors
(
cx
PropertyDescriptorVector
(
cx
)
)
;
AutoIdVector
descriptorKeys
(
cx
)
;
for
(
size_t
i
=
0
len
=
keys
.
length
(
)
;
i
<
len
;
i
+
+
)
{
nextKey
=
keys
[
i
]
;
if
(
!
GetOwnPropertyDescriptor
(
cx
props
nextKey
&
desc
)
)
return
false
;
if
(
desc
.
object
(
)
&
&
desc
.
enumerable
(
)
)
{
if
(
!
GetProperty
(
cx
props
props
nextKey
&
descObj
)
|
|
!
ToPropertyDescriptor
(
cx
descObj
true
&
desc
)
|
|
!
descriptors
.
append
(
desc
)
|
|
!
descriptorKeys
.
append
(
nextKey
)
)
{
return
false
;
}
}
}
for
(
size_t
i
=
0
len
=
descriptors
.
length
(
)
;
i
<
len
;
i
+
+
)
{
if
(
!
DefineProperty
(
cx
obj
descriptorKeys
[
i
]
descriptors
[
i
]
)
)
return
false
;
}
return
true
;
}
bool
js
:
:
obj_create
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_MORE_ARGS_NEEDED
"
Object
.
create
"
"
0
"
"
s
"
)
;
return
false
;
}
if
(
!
args
[
0
]
.
isObjectOrNull
(
)
)
{
RootedValue
v
(
cx
args
[
0
]
)
;
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
v
nullptr
)
;
if
(
!
bytes
)
return
false
;
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_UNEXPECTED_TYPE
bytes
.
get
(
)
"
not
an
object
or
null
"
)
;
return
false
;
}
RootedObject
proto
(
cx
args
[
0
]
.
toObjectOrNull
(
)
)
;
RootedPlainObject
obj
(
cx
ObjectCreateImpl
(
cx
proto
)
)
;
if
(
!
obj
)
return
false
;
if
(
args
.
hasDefined
(
1
)
)
{
if
(
!
ObjectDefineProperties
(
cx
obj
args
[
1
]
)
)
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
bool
js
:
:
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
obj
)
return
false
;
RootedId
id
(
cx
)
;
if
(
!
ToPropertyKey
(
cx
args
.
get
(
1
)
&
id
)
)
return
false
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
return
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
&
&
JS
:
:
FromPropertyDescriptor
(
cx
desc
args
.
rval
(
)
)
;
}
enum
EnumerableOwnPropertiesKind
{
Keys
Values
KeysAndValues
}
;
static
bool
EnumerableOwnProperties
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
EnumerableOwnPropertiesKind
kind
)
{
RootedObject
obj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
obj
)
return
false
;
AutoIdVector
ids
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
JSITER_OWNONLY
|
JSITER_HIDDEN
&
ids
)
)
return
false
;
AutoValueVector
properties
(
cx
)
;
size_t
len
=
ids
.
length
(
)
;
if
(
!
properties
.
resize
(
len
)
)
return
false
;
RootedId
id
(
cx
)
;
RootedValue
key
(
cx
)
;
RootedValue
value
(
cx
)
;
RootedNativeObject
nobj
(
cx
)
;
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
RootedShape
shape
(
cx
)
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
size_t
out
=
0
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
id
=
ids
[
i
]
;
MOZ_ASSERT
(
!
JSID_IS_SYMBOL
(
id
)
)
;
if
(
kind
!
=
Values
)
{
if
(
!
IdToStringOrSymbol
(
cx
id
&
key
)
)
return
false
;
}
if
(
nobj
)
{
if
(
JSID_IS_INT
(
id
)
&
&
nobj
-
>
containsDenseElement
(
JSID_TO_INT
(
id
)
)
)
{
value
=
nobj
-
>
getDenseOrTypedArrayElement
(
JSID_TO_INT
(
id
)
)
;
}
else
{
shape
=
nobj
-
>
lookup
(
cx
id
)
;
if
(
!
shape
|
|
!
(
shape
-
>
attributes
(
)
&
JSPROP_ENUMERATE
)
)
continue
;
if
(
!
shape
-
>
isAccessorShape
(
)
)
{
if
(
!
NativeGetExistingProperty
(
cx
nobj
nobj
shape
&
value
)
)
return
false
;
}
else
if
(
!
GetProperty
(
cx
obj
obj
id
&
value
)
)
{
return
false
;
}
}
}
else
{
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
)
return
false
;
if
(
!
desc
.
object
(
)
|
|
!
desc
.
enumerable
(
)
)
continue
;
if
(
!
GetProperty
(
cx
obj
obj
id
&
value
)
)
return
false
;
}
if
(
kind
=
=
Values
)
properties
[
out
+
+
]
.
set
(
value
)
;
else
if
(
!
NewValuePair
(
cx
key
value
properties
[
out
+
+
]
)
)
return
false
;
}
JSObject
*
aobj
=
NewDenseCopiedArray
(
cx
out
properties
.
begin
(
)
)
;
if
(
!
aobj
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
aobj
)
;
return
true
;
}
static
bool
obj_keys
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
GetOwnPropertyKeys
(
cx
args
JSITER_OWNONLY
)
;
}
static
bool
obj_values
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
EnumerableOwnProperties
(
cx
args
Values
)
;
}
static
bool
obj_entries
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
EnumerableOwnProperties
(
cx
args
KeysAndValues
)
;
}
static
bool
obj_is
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
same
;
if
(
!
SameValue
(
cx
args
.
get
(
0
)
args
.
get
(
1
)
&
same
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
same
)
;
return
true
;
}
bool
js
:
:
IdToStringOrSymbol
(
JSContext
*
cx
HandleId
id
MutableHandleValue
result
)
{
if
(
JSID_IS_INT
(
id
)
)
{
JSString
*
str
=
Int32ToString
<
CanGC
>
(
cx
JSID_TO_INT
(
id
)
)
;
if
(
!
str
)
return
false
;
result
.
setString
(
str
)
;
}
else
if
(
JSID_IS_ATOM
(
id
)
)
{
result
.
setString
(
JSID_TO_STRING
(
id
)
)
;
}
else
{
result
.
setSymbol
(
JSID_TO_SYMBOL
(
id
)
)
;
}
return
true
;
}
bool
js
:
:
GetOwnPropertyKeys
(
JSContext
*
cx
const
JS
:
:
CallArgs
&
args
unsigned
flags
)
{
RootedObject
obj
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
obj
)
return
false
;
AutoIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
flags
&
keys
)
)
return
false
;
AutoValueVector
vals
(
cx
)
;
if
(
!
vals
.
resize
(
keys
.
length
(
)
)
)
return
false
;
for
(
size_t
i
=
0
len
=
keys
.
length
(
)
;
i
<
len
;
i
+
+
)
{
MOZ_ASSERT_IF
(
JSID_IS_SYMBOL
(
keys
[
i
]
)
flags
&
JSITER_SYMBOLS
)
;
MOZ_ASSERT_IF
(
!
JSID_IS_SYMBOL
(
keys
[
i
]
)
!
(
flags
&
JSITER_SYMBOLSONLY
)
)
;
if
(
!
IdToStringOrSymbol
(
cx
keys
[
i
]
vals
[
i
]
)
)
return
false
;
}
JSObject
*
aobj
=
NewDenseCopiedArray
(
cx
vals
.
length
(
)
vals
.
begin
(
)
)
;
if
(
!
aobj
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
aobj
)
;
return
true
;
}
bool
js
:
:
obj_getOwnPropertyNames
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
GetOwnPropertyKeys
(
cx
args
JSITER_OWNONLY
|
JSITER_HIDDEN
)
;
}
static
bool
obj_getOwnPropertySymbols
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
GetOwnPropertyKeys
(
cx
args
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
|
JSITER_SYMBOLSONLY
)
;
}
bool
js
:
:
obj_defineProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
)
;
if
(
!
GetFirstArgumentAsObject
(
cx
args
"
Object
.
defineProperty
"
&
obj
)
)
return
false
;
RootedId
id
(
cx
)
;
if
(
!
ToPropertyKey
(
cx
args
.
get
(
1
)
&
id
)
)
return
false
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
if
(
!
ToPropertyDescriptor
(
cx
args
.
get
(
2
)
true
&
desc
)
)
return
false
;
if
(
!
DefineProperty
(
cx
obj
id
desc
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
obj_defineProperties
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
)
;
if
(
!
GetFirstArgumentAsObject
(
cx
args
"
Object
.
defineProperties
"
&
obj
)
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
obj
)
;
if
(
args
.
length
(
)
<
2
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_MORE_ARGS_NEEDED
"
Object
.
defineProperties
"
"
0
"
"
s
"
)
;
return
false
;
}
return
ObjectDefineProperties
(
cx
obj
args
[
1
]
)
;
}
static
bool
obj_preventExtensions
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
args
.
get
(
0
)
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
)
;
return
PreventExtensions
(
cx
obj
)
;
}
static
bool
obj_freeze
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
args
.
get
(
0
)
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
)
;
return
SetIntegrityLevel
(
cx
obj
IntegrityLevel
:
:
Frozen
)
;
}
static
bool
obj_isFrozen
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
frozen
=
true
;
if
(
args
.
get
(
0
)
.
isObject
(
)
)
{
RootedObject
obj
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
)
;
if
(
!
TestIntegrityLevel
(
cx
obj
IntegrityLevel
:
:
Frozen
&
frozen
)
)
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
frozen
)
;
return
true
;
}
static
bool
obj_seal
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
args
.
get
(
0
)
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
)
;
return
SetIntegrityLevel
(
cx
obj
IntegrityLevel
:
:
Sealed
)
;
}
static
bool
obj_isSealed
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
sealed
=
true
;
if
(
args
.
get
(
0
)
.
isObject
(
)
)
{
RootedObject
obj
(
cx
&
args
.
get
(
0
)
.
toObject
(
)
)
;
if
(
!
TestIntegrityLevel
(
cx
obj
IntegrityLevel
:
:
Sealed
&
sealed
)
)
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
sealed
)
;
return
true
;
}
static
bool
ProtoGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedValue
thisv
(
cx
args
.
thisv
(
)
)
;
if
(
thisv
.
isPrimitive
(
)
)
{
if
(
thisv
.
isNullOrUndefined
(
)
)
{
ReportIncompatible
(
cx
args
)
;
return
false
;
}
if
(
!
BoxNonStrictThis
(
cx
thisv
&
thisv
)
)
return
false
;
}
RootedObject
obj
(
cx
&
thisv
.
toObject
(
)
)
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototype
(
cx
obj
&
proto
)
)
return
false
;
args
.
rval
(
)
.
setObjectOrNull
(
proto
)
;
return
true
;
}
namespace
js
{
size_t
sSetProtoCalled
=
0
;
}
static
bool
ProtoSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
thisv
=
args
.
thisv
(
)
;
if
(
thisv
.
isNullOrUndefined
(
)
)
{
ReportIncompatible
(
cx
args
)
;
return
false
;
}
if
(
thisv
.
isPrimitive
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
if
(
!
cx
-
>
runningWithTrustedPrincipals
(
)
)
+
+
sSetProtoCalled
;
Rooted
<
JSObject
*
>
obj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
if
(
args
.
length
(
)
=
=
0
|
|
!
args
[
0
]
.
isObjectOrNull
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
JSObject
*
>
newProto
(
cx
args
[
0
]
.
toObjectOrNull
(
)
)
;
if
(
!
SetPrototype
(
cx
obj
newProto
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
const
JSFunctionSpec
object_methods
[
]
=
{
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
obj_toSource
0
0
)
#
endif
JS_FN
(
js_toString_str
obj_toString
0
0
)
JS_SELF_HOSTED_FN
(
js_toLocaleString_str
"
Object_toLocaleString
"
0
0
)
JS_SELF_HOSTED_FN
(
js_valueOf_str
"
Object_valueOf
"
0
0
)
#
if
JS_HAS_OBJ_WATCHPOINT
JS_FN
(
js_watch_str
obj_watch
2
0
)
JS_FN
(
js_unwatch_str
obj_unwatch
1
0
)
#
endif
JS_SELF_HOSTED_FN
(
js_hasOwnProperty_str
"
Object_hasOwnProperty
"
1
0
)
JS_FN
(
js_isPrototypeOf_str
obj_isPrototypeOf
1
0
)
JS_FN
(
js_propertyIsEnumerable_str
obj_propertyIsEnumerable
1
0
)
#
if
JS_OLD_GETTER_SETTER_METHODS
JS_SELF_HOSTED_FN
(
js_defineGetter_str
"
ObjectDefineGetter
"
2
0
)
JS_SELF_HOSTED_FN
(
js_defineSetter_str
"
ObjectDefineSetter
"
2
0
)
JS_SELF_HOSTED_FN
(
js_lookupGetter_str
"
ObjectLookupGetter
"
1
0
)
JS_SELF_HOSTED_FN
(
js_lookupSetter_str
"
ObjectLookupSetter
"
1
0
)
#
endif
JS_FS_END
}
;
static
const
JSPropertySpec
object_properties
[
]
=
{
#
if
JS_HAS_OBJ_PROTO_PROP
JS_PSGS
(
"
__proto__
"
ProtoGetter
ProtoSetter
0
)
#
endif
JS_PS_END
}
;
static
const
JSFunctionSpec
object_static_methods
[
]
=
{
JS_FN
(
"
assign
"
obj_assign
2
0
)
JS_SELF_HOSTED_FN
(
"
getPrototypeOf
"
"
ObjectGetPrototypeOf
"
1
0
)
JS_FN
(
"
setPrototypeOf
"
obj_setPrototypeOf
2
0
)
JS_FN
(
"
getOwnPropertyDescriptor
"
obj_getOwnPropertyDescriptor
2
0
)
JS_SELF_HOSTED_FN
(
"
getOwnPropertyDescriptors
"
"
ObjectGetOwnPropertyDescriptors
"
1
0
)
JS_FN
(
"
keys
"
obj_keys
1
0
)
JS_FN
(
"
values
"
obj_values
1
0
)
JS_FN
(
"
entries
"
obj_entries
1
0
)
JS_FN
(
"
is
"
obj_is
2
0
)
JS_FN
(
"
defineProperty
"
obj_defineProperty
3
0
)
JS_FN
(
"
defineProperties
"
obj_defineProperties
2
0
)
JS_INLINABLE_FN
(
"
create
"
obj_create
2
0
ObjectCreate
)
JS_FN
(
"
getOwnPropertyNames
"
obj_getOwnPropertyNames
1
0
)
JS_FN
(
"
getOwnPropertySymbols
"
obj_getOwnPropertySymbols
1
0
)
JS_SELF_HOSTED_FN
(
"
isExtensible
"
"
ObjectIsExtensible
"
1
0
)
JS_FN
(
"
preventExtensions
"
obj_preventExtensions
1
0
)
JS_FN
(
"
freeze
"
obj_freeze
1
0
)
JS_FN
(
"
isFrozen
"
obj_isFrozen
1
0
)
JS_FN
(
"
seal
"
obj_seal
1
0
)
JS_FN
(
"
isSealed
"
obj_isSealed
1
0
)
JS_FS_END
}
;
static
JSObject
*
CreateObjectConstructor
(
JSContext
*
cx
JSProtoKey
key
)
{
Rooted
<
GlobalObject
*
>
self
(
cx
cx
-
>
global
(
)
)
;
if
(
!
GlobalObject
:
:
ensureConstructor
(
cx
self
JSProto_Function
)
)
return
nullptr
;
return
NewNativeConstructor
(
cx
obj_construct
1
HandlePropertyName
(
cx
-
>
names
(
)
.
Object
)
gc
:
:
AllocKind
:
:
FUNCTION
SingletonObject
)
;
}
static
JSObject
*
CreateObjectPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
cx
-
>
compartment
(
)
)
)
;
MOZ_ASSERT
(
cx
-
>
global
(
)
-
>
isNative
(
)
)
;
RootedPlainObject
objectProto
(
cx
NewObjectWithGivenProto
<
PlainObject
>
(
cx
nullptr
SingletonObject
)
)
;
if
(
!
objectProto
)
return
nullptr
;
bool
succeeded
;
if
(
!
SetImmutablePrototype
(
cx
objectProto
&
succeeded
)
)
return
nullptr
;
MOZ_ASSERT
(
succeeded
"
should
have
been
able
to
make
a
fresh
Object
.
prototype
'
s
"
"
[
[
Prototype
]
]
immutable
"
)
;
if
(
!
JSObject
:
:
setNewGroupUnknown
(
cx
&
PlainObject
:
:
class_
objectProto
)
)
return
nullptr
;
return
objectProto
;
}
static
bool
FinishObjectClassInit
(
JSContext
*
cx
JS
:
:
HandleObject
ctor
JS
:
:
HandleObject
proto
)
{
Rooted
<
GlobalObject
*
>
global
(
cx
cx
-
>
global
(
)
)
;
RootedId
evalId
(
cx
NameToId
(
cx
-
>
names
(
)
.
eval
)
)
;
JSObject
*
evalobj
=
DefineFunction
(
cx
global
evalId
IndirectEval
1
JSFUN_STUB_GSOPS
|
JSPROP_RESOLVING
)
;
if
(
!
evalobj
)
return
false
;
global
-
>
setOriginalEval
(
evalobj
)
;
#
ifdef
FUZZING
if
(
cx
-
>
options
(
)
.
fuzzing
(
)
)
{
if
(
!
DefineTestingFunctions
(
cx
global
true
false
)
)
{
return
false
;
}
}
#
endif
Rooted
<
NativeObject
*
>
holder
(
cx
GlobalObject
:
:
getIntrinsicsHolder
(
cx
global
)
)
;
if
(
!
holder
)
return
false
;
Rooted
<
TaggedProto
>
tagged
(
cx
TaggedProto
(
proto
)
)
;
if
(
global
-
>
shouldSplicePrototype
(
)
)
{
if
(
!
JSObject
:
:
splicePrototype
(
cx
global
global
-
>
getClass
(
)
tagged
)
)
return
false
;
}
return
true
;
}
static
const
ClassSpec
PlainObjectClassSpec
=
{
CreateObjectConstructor
CreateObjectPrototype
object_static_methods
nullptr
object_methods
object_properties
FinishObjectClassInit
}
;
const
Class
PlainObject
:
:
class_
=
{
js_Object_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Object
)
JS_NULL_CLASS_OPS
&
PlainObjectClassSpec
}
;
const
Class
*
const
js
:
:
ObjectClassPtr
=
&
PlainObject
:
:
class_
;
