#
ifndef
builtin_MapObject_inl_h
#
define
builtin_MapObject_inl_h
#
include
"
builtin
/
MapObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
namespace
js
{
template
<
JSProtoKey
ProtoKey
>
[
[
nodiscard
]
]
static
bool
IsOptimizableInitForMapOrSet
(
JSNative
addOrSetNative
NativeObject
*
mapOrSetObject
const
Value
&
iterable
JSContext
*
cx
)
{
constexpr
bool
isMap
=
ProtoKey
=
=
JSProto_Map
|
|
ProtoKey
=
=
JSProto_WeakMap
;
constexpr
bool
isSet
=
ProtoKey
=
=
JSProto_Set
|
|
ProtoKey
=
=
JSProto_WeakSet
;
static_assert
(
isMap
!
=
isSet
"
must
be
either
a
Map
or
a
Set
"
)
;
if
(
!
iterable
.
isObject
(
)
)
{
return
false
;
}
if
(
!
IsArrayWithDefaultIterator
<
MustBePacked
:
:
Yes
>
(
&
iterable
.
toObject
(
)
cx
)
)
{
return
false
;
}
ArrayObject
*
array
=
&
iterable
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
if
constexpr
(
isMap
)
{
size_t
len
=
array
-
>
length
(
)
;
static
constexpr
size_t
MaxLength
=
100
;
if
(
len
>
MaxLength
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
Value
elem
=
array
-
>
getDenseElement
(
i
)
;
if
(
!
elem
.
isObject
(
)
)
{
return
false
;
}
JSObject
*
obj
=
&
elem
.
toObject
(
)
;
if
(
!
IsPackedArray
(
obj
)
|
|
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
<
2
)
{
return
false
;
}
}
}
JSObject
*
proto
=
mapOrSetObject
-
>
staticPrototype
(
)
;
MOZ_ASSERT
(
proto
)
;
if
(
proto
!
=
cx
-
>
global
(
)
-
>
maybeGetPrototype
(
ProtoKey
)
)
{
return
false
;
}
auto
*
nproto
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
PropertyName
*
propName
=
isSet
?
cx
-
>
names
(
)
.
add
:
cx
-
>
names
(
)
.
set
;
mozilla
:
:
Maybe
<
PropertyInfo
>
prop
=
nproto
-
>
lookup
(
cx
propName
)
;
if
(
prop
.
isNothing
(
)
|
|
!
prop
-
>
isDataProperty
(
)
)
{
return
false
;
}
Value
propVal
=
nproto
-
>
getSlot
(
prop
-
>
slot
(
)
)
;
if
(
!
IsNativeFunction
(
propVal
addOrSetNative
)
)
{
return
false
;
}
return
true
;
}
}
#
endif
