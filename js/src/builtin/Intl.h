#
ifndef
builtin_Intl_h
#
define
builtin_Intl_h
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jsalloc
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
if
ENABLE_INTL_API
#
include
"
unicode
/
utypes
.
h
"
#
endif
namespace
js
{
extern
JSObject
*
InitIntlClass
(
JSContext
*
cx
HandleObject
obj
)
;
class
SharedIntlData
{
using
TimeZoneName
=
JSAtom
*
;
struct
TimeZoneHasher
{
struct
Lookup
{
union
{
const
JS
:
:
Latin1Char
*
latin1Chars
;
const
char16_t
*
twoByteChars
;
}
;
bool
isLatin1
;
size_t
length
;
JS
:
:
AutoCheckCannotGC
nogc
;
HashNumber
hash
;
explicit
Lookup
(
JSLinearString
*
timeZone
)
;
}
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
lookup
.
hash
;
}
static
bool
match
(
TimeZoneName
key
const
Lookup
&
lookup
)
;
}
;
using
TimeZoneSet
=
js
:
:
GCHashSet
<
TimeZoneName
TimeZoneHasher
js
:
:
SystemAllocPolicy
>
;
using
TimeZoneMap
=
js
:
:
GCHashMap
<
TimeZoneName
TimeZoneName
TimeZoneHasher
js
:
:
SystemAllocPolicy
>
;
TimeZoneSet
availableTimeZones
;
TimeZoneSet
ianaZonesTreatedAsLinksByICU
;
TimeZoneMap
ianaLinksCanonicalizedDifferentlyByICU
;
bool
timeZoneDataInitialized
=
false
;
bool
ensureTimeZones
(
JSContext
*
cx
)
;
public
:
bool
validateTimeZoneName
(
JSContext
*
cx
JS
:
:
HandleString
timeZone
JS
:
:
MutableHandleString
result
)
;
bool
tryCanonicalizeTimeZoneConsistentWithIANA
(
JSContext
*
cx
JS
:
:
HandleString
timeZone
JS
:
:
MutableHandleString
result
)
;
void
destroyInstance
(
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
extern
MOZ_MUST_USE
bool
intl_Collator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_Collator_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_availableCollations
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_CompareStrings
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_NumberFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_NumberFormat_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_numberingSystem
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_FormatNumber
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_DateTimeFormat
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_DateTimeFormat_availableLocales
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_availableCalendars
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_IsValidTimeZoneName
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_canonicalizeTimeZone
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_defaultTimeZone
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_defaultTimeZoneOffset
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_patternForSkeleton
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_FormatDateTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
MOZ_MUST_USE
bool
intl_GetCalendarInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
#
if
ENABLE_INTL_API
inline
const
UChar
*
Char16ToUChar
(
const
char16_t
*
chars
)
{
return
reinterpret_cast
<
const
UChar
*
>
(
chars
)
;
}
inline
UChar
*
Char16ToUChar
(
char16_t
*
chars
)
{
return
reinterpret_cast
<
UChar
*
>
(
chars
)
;
}
#
endif
}
#
endif
