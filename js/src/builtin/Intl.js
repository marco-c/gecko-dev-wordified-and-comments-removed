function
toASCIIUpperCase
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
toASCIIUpperCase
"
)
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
result
+
=
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
?
callFunction
(
std_String_fromCharCode
null
c
&
~
0x20
)
:
s
[
i
]
;
}
return
result
;
}
var
internalIntlRegExps
=
std_Object_create
(
null
)
;
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
null
;
internalIntlRegExps
.
languageTagRE
=
null
;
internalIntlRegExps
.
duplicateVariantRE
=
null
;
internalIntlRegExps
.
duplicateSingletonRE
=
null
;
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
=
null
;
internalIntlRegExps
.
currencyDigitsRE
=
null
;
function
getUnicodeLocaleExtensionSequenceRE
(
)
{
return
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
|
|
(
internalIntlRegExps
.
unicodeLocaleExtensionSequenceRE
=
RegExpCreate
(
"
-
u
(
?
:
-
[
a
-
z0
-
9
]
{
2
8
}
)
+
"
)
)
;
}
function
removeUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
locale
;
var
pos
=
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
;
if
(
pos
<
0
)
pos
=
locale
.
length
;
var
left
=
callFunction
(
String_substring
locale
0
pos
)
;
var
right
=
callFunction
(
String_substring
locale
pos
)
;
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensions
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
left
)
;
if
(
extensions
!
=
=
null
)
{
left
=
callFunction
(
String_substring
left
0
extensions
.
index
)
+
callFunction
(
String_substring
left
extensions
.
index
+
extensions
[
0
]
.
length
)
;
}
var
combined
=
left
+
right
;
assert
(
IsStructurallyValidLanguageTag
(
combined
)
"
recombination
produced
an
invalid
language
tag
"
)
;
assert
(
function
(
)
{
var
uindex
=
callFunction
(
std_String_indexOf
combined
"
-
u
-
"
)
;
if
(
uindex
<
0
)
return
true
;
var
xindex
=
callFunction
(
std_String_indexOf
combined
"
-
x
-
"
)
;
return
xindex
>
0
&
&
xindex
<
uindex
;
}
(
)
"
recombination
failed
to
remove
all
Unicode
locale
extension
sequences
"
)
;
return
combined
;
}
function
getLanguageTagRE
(
)
{
if
(
internalIntlRegExps
.
languageTagRE
)
return
internalIntlRegExps
.
languageTagRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
regular
=
"
(
?
:
art
-
lojban
|
cel
-
gaulish
|
no
-
bok
|
no
-
nyn
|
zh
-
guoyu
|
zh
-
hakka
|
zh
-
min
|
zh
-
min
-
nan
|
zh
-
xiang
)
"
;
var
irregular
=
"
(
?
:
en
-
GB
-
oed
|
i
-
ami
|
i
-
bnn
|
i
-
default
|
i
-
enochian
|
i
-
hak
|
i
-
klingon
|
i
-
lux
|
i
-
mingo
|
i
-
navajo
|
i
-
pwn
|
i
-
tao
|
i
-
tay
|
i
-
tsu
|
sgn
-
BE
-
FR
|
sgn
-
BE
-
NL
|
sgn
-
CH
-
DE
)
"
;
var
grandfathered
=
"
(
?
:
"
+
irregular
+
"
|
"
+
regular
+
"
)
"
;
var
privateuse
=
"
(
?
:
x
(
?
:
-
[
a
-
z0
-
9
]
{
1
8
}
)
+
)
"
;
var
singleton
=
"
(
?
:
"
+
DIGIT
+
"
|
[
A
-
WY
-
Za
-
wy
-
z
]
)
"
;
var
extension
=
"
(
?
:
"
+
singleton
+
"
(
?
:
-
"
+
alphanum
+
"
{
2
8
}
)
+
)
"
;
var
variant
=
"
(
?
:
"
+
alphanum
+
"
{
5
8
}
|
(
?
:
"
+
DIGIT
+
alphanum
+
"
{
3
}
)
)
"
;
var
region
=
"
(
?
:
"
+
ALPHA
+
"
{
2
}
|
"
+
DIGIT
+
"
{
3
}
)
"
;
var
script
=
"
(
?
:
"
+
ALPHA
+
"
{
4
}
)
"
;
var
extlang
=
"
(
?
:
"
+
ALPHA
+
"
{
3
}
(
?
:
-
"
+
ALPHA
+
"
{
3
}
)
{
0
2
}
)
"
;
var
language
=
"
(
?
:
"
+
ALPHA
+
"
{
2
3
}
(
?
:
-
"
+
extlang
+
"
)
?
|
"
+
ALPHA
+
"
{
4
}
|
"
+
ALPHA
+
"
{
5
8
}
)
"
;
var
langtag
=
language
+
"
(
?
:
-
"
+
script
+
"
)
?
(
?
:
-
"
+
region
+
"
)
?
(
?
:
-
"
+
variant
+
"
)
*
(
?
:
-
"
+
extension
+
"
)
*
(
?
:
-
"
+
privateuse
+
"
)
?
"
;
var
languageTag
=
"
^
(
?
:
"
+
langtag
+
"
|
"
+
privateuse
+
"
|
"
+
grandfathered
+
"
)
"
;
return
(
internalIntlRegExps
.
languageTagRE
=
RegExpCreate
(
languageTag
"
i
"
)
)
;
}
function
getDuplicateVariantRE
(
)
{
if
(
internalIntlRegExps
.
duplicateVariantRE
)
return
internalIntlRegExps
.
duplicateVariantRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
variant
=
"
(
?
:
"
+
alphanum
+
"
{
5
8
}
|
(
?
:
"
+
DIGIT
+
alphanum
+
"
{
3
}
)
)
"
;
var
duplicateVariant
=
"
^
(
?
:
"
+
alphanum
+
"
{
2
8
}
-
)
+
"
+
"
(
"
+
variant
+
"
)
-
"
+
"
(
?
:
"
+
alphanum
+
"
{
2
8
}
-
)
*
"
+
"
\
\
1
"
+
"
(
?
!
"
+
alphanum
+
"
)
"
;
return
(
internalIntlRegExps
.
duplicateVariantRE
=
RegExpCreate
(
duplicateVariant
"
i
"
)
)
;
}
function
getDuplicateSingletonRE
(
)
{
if
(
internalIntlRegExps
.
duplicateSingletonRE
)
return
internalIntlRegExps
.
duplicateSingletonRE
;
var
ALPHA
=
"
[
a
-
zA
-
Z
]
"
;
var
DIGIT
=
"
[
0
-
9
]
"
;
var
alphanum
=
"
(
?
:
"
+
ALPHA
+
"
|
"
+
DIGIT
+
"
)
"
;
var
singleton
=
"
(
?
:
"
+
DIGIT
+
"
|
[
A
-
WY
-
Za
-
wy
-
z
]
)
"
;
var
duplicateSingleton
=
"
-
(
"
+
singleton
+
"
)
-
"
+
"
(
?
:
"
+
alphanum
+
"
+
-
)
*
"
+
"
\
\
1
"
+
"
(
?
!
"
+
alphanum
+
"
)
"
;
return
(
internalIntlRegExps
.
duplicateSingletonRE
=
RegExpCreate
(
duplicateSingleton
"
i
"
)
)
;
}
function
IsStructurallyValidLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
IsStructurallyValidLanguageTag
"
)
;
var
languageTagRE
=
getLanguageTagRE
(
)
;
if
(
!
regexp_test_no_statics
(
languageTagRE
locale
)
)
return
false
;
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
true
;
var
pos
=
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
;
if
(
pos
!
=
=
-
1
)
locale
=
callFunction
(
String_substring
locale
0
pos
)
;
var
duplicateVariantRE
=
getDuplicateVariantRE
(
)
;
var
duplicateSingletonRE
=
getDuplicateSingletonRE
(
)
;
return
!
regexp_test_no_statics
(
duplicateVariantRE
locale
)
&
&
!
regexp_test_no_statics
(
duplicateSingletonRE
locale
)
;
}
function
CanonicalizeLanguageTag
(
locale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
CanonicalizeLanguageTag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
if
(
hasOwn
(
locale
langTagMappings
)
)
return
langTagMappings
[
locale
]
;
var
subtags
=
StringSplitString
(
locale
"
-
"
)
;
var
i
=
0
;
while
(
i
<
subtags
.
length
)
{
var
subtag
=
subtags
[
i
]
;
if
(
subtag
.
length
=
=
=
1
&
&
(
i
>
0
|
|
subtag
=
=
=
"
x
"
)
)
break
;
if
(
i
!
=
=
0
)
{
if
(
subtag
.
length
=
=
=
4
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
[
0
]
)
+
callFunction
(
String_substring
subtag
1
)
;
}
else
if
(
subtag
.
length
=
=
=
2
)
{
subtag
=
callFunction
(
std_String_toUpperCase
subtag
)
;
}
}
if
(
hasOwn
(
subtag
langSubtagMappings
)
)
{
subtag
=
langSubtagMappings
[
subtag
]
;
}
else
if
(
hasOwn
(
subtag
extlangMappings
)
)
{
if
(
i
=
=
=
1
&
&
extlangMappings
[
subtag
]
=
=
=
subtags
[
0
]
)
{
callFunction
(
std_Array_shift
subtags
)
;
i
-
-
;
}
}
subtags
[
i
]
=
subtag
;
i
+
+
;
}
if
(
i
=
=
=
subtags
.
length
)
return
callFunction
(
std_Array_join
subtags
"
-
"
)
;
var
normal
=
ArrayJoinRange
(
subtags
"
-
"
0
i
)
;
var
extensions
=
[
]
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
!
=
=
"
x
"
)
{
var
extensionStart
=
i
;
i
+
+
;
while
(
i
<
subtags
.
length
&
&
subtags
[
i
]
.
length
>
1
)
i
+
+
;
var
extension
=
ArrayJoinRange
(
subtags
"
-
"
extensionStart
i
)
;
_DefineDataProperty
(
extensions
extensions
.
length
extension
)
;
}
callFunction
(
ArraySort
extensions
)
;
var
privateUse
=
"
"
;
if
(
i
<
subtags
.
length
)
privateUse
=
ArrayJoinRange
(
subtags
"
-
"
i
)
;
var
canonical
=
normal
;
if
(
extensions
.
length
>
0
)
canonical
+
=
"
-
"
+
callFunction
(
std_Array_join
extensions
"
-
"
)
;
if
(
privateUse
.
length
>
0
)
{
if
(
canonical
.
length
>
0
)
canonical
+
=
"
-
"
+
privateUse
;
else
canonical
=
privateUse
;
}
return
canonical
;
}
function
ArrayJoinRange
(
array
separator
from
to
=
array
.
length
)
{
assert
(
typeof
separator
=
=
=
"
string
"
"
|
separator
|
is
a
string
value
"
)
;
assert
(
typeof
from
=
=
=
"
number
"
"
|
from
|
is
a
number
value
"
)
;
assert
(
typeof
to
=
=
=
"
number
"
"
|
to
|
is
a
number
value
"
)
;
assert
(
0
<
=
from
&
&
from
<
=
to
&
&
to
<
=
array
.
length
"
|
from
|
and
|
to
|
form
a
valid
range
"
)
;
if
(
from
=
=
=
to
)
return
"
"
;
var
result
=
array
[
from
]
;
for
(
var
i
=
from
+
1
;
i
<
to
;
i
+
+
)
{
result
+
=
separator
+
array
[
i
]
;
}
return
result
;
}
function
IsASCIIAlphaString
(
s
)
{
assert
(
typeof
s
=
=
=
"
string
"
"
IsASCIIAlphaString
"
)
;
for
(
var
i
=
0
;
i
<
s
.
length
;
i
+
+
)
{
var
c
=
callFunction
(
std_String_charCodeAt
s
i
)
;
if
(
!
(
(
0x41
<
=
c
&
&
c
<
=
0x5A
)
|
|
(
0x61
<
=
c
&
&
c
<
=
0x7A
)
)
)
return
false
;
}
return
true
;
}
function
ValidateAndCanonicalizeLanguageTag
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
ValidateAndCanonicalizeLanguageTag
"
)
;
if
(
locale
.
length
=
=
=
2
|
|
(
locale
.
length
=
=
=
3
&
&
locale
[
1
]
!
=
=
"
-
"
)
)
{
if
(
!
IsASCIIAlphaString
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
2
*
3ALPHA
is
a
valid
language
tag
"
)
;
locale
=
callFunction
(
std_String_toLowerCase
locale
)
;
assert
(
!
hasOwn
(
locale
langTagMappings
)
"
langTagMappings
contains
no
2
*
3ALPHA
mappings
"
)
;
locale
=
hasOwn
(
locale
langSubtagMappings
)
?
langSubtagMappings
[
locale
]
:
locale
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
expected
same
canonicalization
"
)
;
return
locale
;
}
if
(
!
IsStructurallyValidLanguageTag
(
locale
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locale
)
;
return
CanonicalizeLanguageTag
(
locale
)
;
}
function
localeContainsNoUnicodeExtensions
(
locale
)
{
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
=
=
=
-
1
)
return
true
;
if
(
callFunction
(
std_String_indexOf
locale
"
-
u
-
"
)
>
callFunction
(
std_String_indexOf
locale
"
-
x
-
"
)
)
return
true
;
if
(
callFunction
(
std_String_startsWith
locale
"
x
-
"
)
)
return
true
;
return
false
;
}
function
lastDitchLocale
(
)
{
return
"
en
-
GB
"
;
}
var
oldStyleLanguageTagMappings
=
{
"
pa
-
PK
"
:
"
pa
-
Arab
-
PK
"
"
zh
-
CN
"
:
"
zh
-
Hans
-
CN
"
"
zh
-
HK
"
:
"
zh
-
Hant
-
HK
"
"
zh
-
SG
"
:
"
zh
-
Hans
-
SG
"
"
zh
-
TW
"
:
"
zh
-
Hant
-
TW
"
}
;
var
localeCandidateCache
=
{
runtimeDefaultLocale
:
undefined
candidateDefaultLocale
:
undefined
}
;
var
localeCache
=
{
runtimeDefaultLocale
:
undefined
defaultLocale
:
undefined
}
;
function
DefaultLocaleIgnoringAvailableLocales
(
)
{
const
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
if
(
runtimeDefaultLocale
=
=
=
localeCandidateCache
.
runtimeDefaultLocale
)
return
localeCandidateCache
.
candidateDefaultLocale
;
var
candidate
;
if
(
!
IsStructurallyValidLanguageTag
(
runtimeDefaultLocale
)
)
{
candidate
=
lastDitchLocale
(
)
;
}
else
{
candidate
=
CanonicalizeLanguageTag
(
runtimeDefaultLocale
)
;
candidate
=
removeUnicodeExtensions
(
candidate
)
;
if
(
hasOwn
(
candidate
oldStyleLanguageTagMappings
)
)
candidate
=
oldStyleLanguageTagMappings
[
candidate
]
;
}
localeCandidateCache
.
candidateDefaultLocale
=
candidate
;
localeCandidateCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
assert
(
IsStructurallyValidLanguageTag
(
candidate
)
"
the
candidate
must
be
structurally
valid
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
candidate
)
"
the
candidate
must
not
contain
a
Unicode
extension
sequence
"
)
;
return
candidate
;
}
function
DefaultLocale
(
)
{
if
(
IsRuntimeDefaultLocale
(
localeCache
.
runtimeDefaultLocale
)
)
return
localeCache
.
defaultLocale
;
var
runtimeDefaultLocale
=
RuntimeDefaultLocale
(
)
;
var
candidate
=
DefaultLocaleIgnoringAvailableLocales
(
)
;
var
locale
;
if
(
BestAvailableLocaleIgnoringDefault
(
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
candidate
)
&
&
BestAvailableLocaleIgnoringDefault
(
callFunction
(
dateTimeFormatInternalProperties
.
availableLocales
dateTimeFormatInternalProperties
)
candidate
)
)
{
locale
=
candidate
;
}
else
{
locale
=
lastDitchLocale
(
)
;
}
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
structurally
valid
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
the
computed
default
locale
must
be
canonical
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
the
computed
default
locale
must
not
contain
a
Unicode
extension
sequence
"
)
;
localeCache
.
defaultLocale
=
locale
;
localeCache
.
runtimeDefaultLocale
=
runtimeDefaultLocale
;
return
locale
;
}
function
getIsWellFormedCurrencyCodeRE
(
)
{
return
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
|
|
(
internalIntlRegExps
.
isWellFormedCurrencyCodeRE
=
RegExpCreate
(
"
[
^
A
-
Z
]
"
)
)
;
}
function
IsWellFormedCurrencyCode
(
currency
)
{
var
c
=
ToString
(
currency
)
;
var
normalized
=
toASCIIUpperCase
(
c
)
;
if
(
normalized
.
length
!
=
=
3
)
return
false
;
return
!
regexp_test_no_statics
(
getIsWellFormedCurrencyCodeRE
(
)
normalized
)
;
}
var
timeZoneCache
=
{
icuDefaultTimeZone
:
undefined
defaultTimeZone
:
undefined
}
;
function
CanonicalizeTimeZoneName
(
timeZone
)
{
assert
(
typeof
timeZone
=
=
=
"
string
"
"
CanonicalizeTimeZoneName
"
)
;
assert
(
timeZone
!
=
=
"
Etc
/
Unknown
"
"
Invalid
time
zone
"
)
;
assert
(
timeZone
=
=
=
intl_IsValidTimeZoneName
(
timeZone
)
"
Time
zone
name
not
normalized
"
)
;
var
ianaTimeZone
=
intl_canonicalizeTimeZone
(
timeZone
)
;
assert
(
ianaTimeZone
!
=
=
"
Etc
/
Unknown
"
"
Invalid
canonical
time
zone
"
)
;
assert
(
ianaTimeZone
=
=
=
intl_IsValidTimeZoneName
(
ianaTimeZone
)
"
Unsupported
canonical
time
zone
"
)
;
if
(
ianaTimeZone
=
=
=
"
Etc
/
UTC
"
|
|
ianaTimeZone
=
=
=
"
Etc
/
GMT
"
)
{
if
(
timeZone
=
=
=
"
Etc
/
UCT
"
|
|
timeZone
=
=
=
"
UCT
"
)
ianaTimeZone
=
"
Etc
/
UCT
"
;
else
ianaTimeZone
=
"
UTC
"
;
}
return
ianaTimeZone
;
}
function
DefaultTimeZone
(
)
{
if
(
intl_isDefaultTimeZone
(
timeZoneCache
.
icuDefaultTimeZone
)
)
return
timeZoneCache
.
defaultTimeZone
;
var
icuDefaultTimeZone
=
intl_defaultTimeZone
(
)
;
var
timeZone
=
intl_IsValidTimeZoneName
(
icuDefaultTimeZone
)
;
if
(
timeZone
=
=
=
null
)
{
const
msPerHour
=
60
*
60
*
1000
;
var
offset
=
intl_defaultTimeZoneOffset
(
)
;
assert
(
offset
=
=
=
(
offset
|
0
)
"
milliseconds
offset
shouldn
'
t
be
able
to
exceed
int32_t
range
"
)
;
var
offsetHours
=
offset
/
msPerHour
offsetHoursFraction
=
offset
%
msPerHour
;
if
(
offsetHoursFraction
=
=
=
0
)
{
timeZone
=
"
Etc
/
GMT
"
+
(
offsetHours
<
0
?
"
+
"
:
"
-
"
)
+
std_Math_abs
(
offsetHours
)
;
timeZone
=
intl_IsValidTimeZoneName
(
timeZone
)
;
}
if
(
timeZone
=
=
=
null
)
timeZone
=
"
UTC
"
;
}
var
defaultTimeZone
=
CanonicalizeTimeZoneName
(
timeZone
)
;
timeZoneCache
.
defaultTimeZone
=
defaultTimeZone
;
timeZoneCache
.
icuDefaultTimeZone
=
icuDefaultTimeZone
;
return
defaultTimeZone
;
}
function
addSpecialMissingLanguageTags
(
availableLocales
)
{
var
oldStyleLocales
=
std_Object_getOwnPropertyNames
(
oldStyleLanguageTagMappings
)
;
for
(
var
i
=
0
;
i
<
oldStyleLocales
.
length
;
i
+
+
)
{
var
oldStyleLocale
=
oldStyleLocales
[
i
]
;
if
(
availableLocales
[
oldStyleLanguageTagMappings
[
oldStyleLocale
]
]
)
availableLocales
[
oldStyleLocale
]
=
true
;
}
var
lastDitch
=
lastDitchLocale
(
)
;
assert
(
lastDitch
=
=
=
"
en
-
GB
"
&
&
availableLocales
.
en
"
shouldn
'
t
be
a
need
to
add
every
locale
implied
by
the
last
-
"
+
"
ditch
locale
merely
just
the
last
-
ditch
locale
"
)
;
availableLocales
[
lastDitch
]
=
true
;
}
function
CanonicalizeLocaleList
(
locales
)
{
if
(
locales
=
=
=
undefined
)
return
[
]
;
if
(
typeof
locales
=
=
=
"
string
"
)
{
if
(
!
IsStructurallyValidLanguageTag
(
locales
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
locales
)
;
return
[
CanonicalizeLanguageTag
(
locales
)
]
;
}
var
seen
=
[
]
;
var
O
=
ToObject
(
locales
)
;
var
len
=
ToLength
(
O
.
length
)
;
var
k
=
0
;
while
(
k
<
len
)
{
var
kPresent
=
HasProperty
(
O
k
)
;
if
(
kPresent
)
{
var
kValue
=
O
[
k
]
;
if
(
!
(
typeof
kValue
=
=
=
"
string
"
|
|
IsObject
(
kValue
)
)
)
ThrowTypeError
(
JSMSG_INVALID_LOCALES_ELEMENT
)
;
var
tag
=
ToString
(
kValue
)
;
if
(
!
IsStructurallyValidLanguageTag
(
tag
)
)
ThrowRangeError
(
JSMSG_INVALID_LANGUAGE_TAG
tag
)
;
tag
=
CanonicalizeLanguageTag
(
tag
)
;
if
(
callFunction
(
ArrayIndexOf
seen
tag
)
=
=
=
-
1
)
_DefineDataProperty
(
seen
seen
.
length
tag
)
;
}
k
+
+
;
}
return
seen
;
}
function
BestAvailableLocaleHelper
(
availableLocales
locale
considerDefaultLocale
)
{
assert
(
IsStructurallyValidLanguageTag
(
locale
)
"
invalid
BestAvailableLocale
locale
structure
"
)
;
assert
(
locale
=
=
=
CanonicalizeLanguageTag
(
locale
)
"
non
-
canonical
BestAvailableLocale
locale
"
)
;
assert
(
localeContainsNoUnicodeExtensions
(
locale
)
"
locale
must
contain
no
Unicode
extensions
"
)
;
var
defaultLocale
;
if
(
considerDefaultLocale
)
defaultLocale
=
DefaultLocale
(
)
;
var
candidate
=
locale
;
while
(
true
)
{
if
(
availableLocales
[
candidate
]
)
return
candidate
;
if
(
considerDefaultLocale
&
&
candidate
.
length
<
=
defaultLocale
.
length
)
{
if
(
candidate
=
=
=
defaultLocale
)
return
candidate
;
if
(
callFunction
(
std_String_startsWith
defaultLocale
candidate
+
"
-
"
)
)
return
candidate
;
}
var
pos
=
callFunction
(
std_String_lastIndexOf
candidate
"
-
"
)
;
if
(
pos
=
=
=
-
1
)
return
undefined
;
if
(
pos
>
=
2
&
&
candidate
[
pos
-
2
]
=
=
=
"
-
"
)
pos
-
=
2
;
candidate
=
callFunction
(
String_substring
candidate
0
pos
)
;
}
}
function
BestAvailableLocale
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
true
)
;
}
function
BestAvailableLocaleIgnoringDefault
(
availableLocales
locale
)
{
return
BestAvailableLocaleHelper
(
availableLocales
locale
false
)
;
}
function
LookupMatcher
(
availableLocales
requestedLocales
)
{
var
i
=
0
;
var
len
=
requestedLocales
.
length
;
var
availableLocale
;
var
locale
noExtensionsLocale
;
while
(
i
<
len
&
&
availableLocale
=
=
=
undefined
)
{
locale
=
requestedLocales
[
i
]
;
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
i
+
+
;
}
var
result
=
new
Record
(
)
;
if
(
availableLocale
!
=
=
undefined
)
{
result
.
locale
=
availableLocale
;
if
(
locale
!
=
=
noExtensionsLocale
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
locale
)
;
result
.
extension
=
extensionMatch
[
0
]
;
}
}
else
{
result
.
locale
=
DefaultLocale
(
)
;
}
return
result
;
}
function
BestFitMatcher
(
availableLocales
requestedLocales
)
{
return
LookupMatcher
(
availableLocales
requestedLocales
)
;
}
function
UnicodeExtensionValue
(
extension
key
)
{
assert
(
typeof
extension
=
=
=
"
string
"
"
extension
is
a
string
value
"
)
;
assert
(
function
(
)
{
var
unicodeLocaleExtensionSequenceRE
=
getUnicodeLocaleExtensionSequenceRE
(
)
;
var
extensionMatch
=
regexp_exec_no_statics
(
unicodeLocaleExtensionSequenceRE
extension
)
;
return
extensionMatch
!
=
=
null
&
&
extensionMatch
[
0
]
=
=
=
extension
;
}
(
)
"
extension
is
a
Unicode
extension
subtag
"
)
;
assert
(
typeof
key
=
=
=
"
string
"
"
key
is
a
string
value
"
)
;
assert
(
key
.
length
=
=
=
2
"
key
is
a
Unicode
extension
key
subtag
"
)
;
var
size
=
extension
.
length
;
var
searchValue
=
"
-
"
+
key
+
"
-
"
;
var
pos
=
callFunction
(
std_String_indexOf
extension
searchValue
)
;
if
(
pos
!
=
=
-
1
)
{
var
start
=
pos
+
4
;
var
end
=
start
;
var
k
=
start
;
while
(
true
)
{
var
e
=
callFunction
(
std_String_indexOf
extension
"
-
"
k
)
;
var
len
=
e
=
=
=
-
1
?
size
-
k
:
e
-
k
;
if
(
len
=
=
=
2
)
break
;
if
(
e
=
=
=
-
1
)
{
end
=
size
;
break
;
}
end
=
e
;
k
=
e
+
1
;
}
return
callFunction
(
String_substring
extension
start
end
)
;
}
searchValue
=
"
-
"
+
key
;
if
(
callFunction
(
std_String_endsWith
extension
searchValue
)
)
return
"
"
;
}
function
ResolveLocale
(
availableLocales
requestedLocales
options
relevantExtensionKeys
localeData
)
{
var
matcher
=
options
.
localeMatcher
;
var
r
=
(
matcher
=
=
=
"
lookup
"
)
?
LookupMatcher
(
availableLocales
requestedLocales
)
:
BestFitMatcher
(
availableLocales
requestedLocales
)
;
var
foundLocale
=
r
.
locale
;
var
extension
=
r
.
extension
;
var
result
=
new
Record
(
)
;
result
.
dataLocale
=
foundLocale
;
var
supportedExtension
=
"
-
u
"
;
var
localeDataProvider
=
localeData
(
)
;
for
(
var
i
=
0
;
i
<
relevantExtensionKeys
.
length
;
i
+
+
)
{
var
key
=
relevantExtensionKeys
[
i
]
;
var
keyLocaleData
=
undefined
;
var
value
=
undefined
;
var
supportedExtensionAddition
=
"
"
;
if
(
extension
!
=
=
undefined
)
{
var
requestedValue
=
UnicodeExtensionValue
(
extension
key
)
;
if
(
requestedValue
!
=
=
undefined
)
{
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
requestedValue
!
=
=
"
"
)
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
requestedValue
)
!
=
=
-
1
)
{
value
=
requestedValue
;
supportedExtensionAddition
=
"
-
"
+
key
+
"
-
"
+
value
;
}
}
else
{
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
"
true
"
)
!
=
=
-
1
)
value
=
"
true
"
;
}
}
}
var
optionsValue
=
options
[
key
]
;
if
(
optionsValue
!
=
=
undefined
&
&
optionsValue
!
=
=
value
)
{
if
(
keyLocaleData
=
=
=
undefined
)
keyLocaleData
=
callFunction
(
localeDataProvider
[
key
]
null
foundLocale
)
;
if
(
callFunction
(
ArrayIndexOf
keyLocaleData
optionsValue
)
!
=
=
-
1
)
{
value
=
optionsValue
;
supportedExtensionAddition
=
"
"
;
}
}
if
(
value
=
=
=
undefined
)
{
value
=
keyLocaleData
=
=
=
undefined
?
callFunction
(
localeDataProvider
.
default
[
key
]
null
foundLocale
)
:
keyLocaleData
[
0
]
;
}
assert
(
typeof
value
=
=
=
"
string
"
|
|
value
=
=
=
null
"
unexpected
locale
data
value
"
)
;
result
[
key
]
=
value
;
supportedExtension
+
=
supportedExtensionAddition
;
}
if
(
supportedExtension
.
length
>
2
)
{
assert
(
!
callFunction
(
std_String_startsWith
foundLocale
"
x
-
"
)
"
unexpected
privateuse
-
only
locale
returned
from
ICU
"
)
;
var
privateIndex
=
callFunction
(
std_String_indexOf
foundLocale
"
-
x
-
"
)
;
if
(
privateIndex
=
=
=
-
1
)
{
foundLocale
+
=
supportedExtension
;
}
else
{
var
preExtension
=
callFunction
(
String_substring
foundLocale
0
privateIndex
)
;
var
postExtension
=
callFunction
(
String_substring
foundLocale
privateIndex
)
;
foundLocale
=
preExtension
+
supportedExtension
+
postExtension
;
}
assert
(
IsStructurallyValidLanguageTag
(
foundLocale
)
"
invalid
locale
after
concatenation
"
)
;
assert
(
foundLocale
=
=
=
CanonicalizeLanguageTag
(
foundLocale
)
"
same
locale
with
extension
"
)
;
}
result
.
locale
=
foundLocale
;
return
result
;
}
function
LookupSupportedLocales
(
availableLocales
requestedLocales
)
{
var
len
=
requestedLocales
.
length
;
var
subset
=
[
]
;
var
k
=
0
;
while
(
k
<
len
)
{
var
locale
=
requestedLocales
[
k
]
;
var
noExtensionsLocale
=
removeUnicodeExtensions
(
locale
)
;
var
availableLocale
=
BestAvailableLocale
(
availableLocales
noExtensionsLocale
)
;
if
(
availableLocale
!
=
=
undefined
)
_DefineDataProperty
(
subset
subset
.
length
locale
)
;
k
+
+
;
}
return
subset
;
}
function
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
{
return
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
}
function
SupportedLocales
(
availableLocales
requestedLocales
options
)
{
var
matcher
;
if
(
options
!
=
=
undefined
)
{
options
=
ToObject
(
options
)
;
matcher
=
options
.
localeMatcher
;
if
(
matcher
!
=
=
undefined
)
{
matcher
=
ToString
(
matcher
)
;
if
(
matcher
!
=
=
"
lookup
"
&
&
matcher
!
=
=
"
best
fit
"
)
ThrowRangeError
(
JSMSG_INVALID_LOCALE_MATCHER
matcher
)
;
}
}
var
subset
=
(
matcher
=
=
=
undefined
|
|
matcher
=
=
=
"
best
fit
"
)
?
BestFitSupportedLocales
(
availableLocales
requestedLocales
)
:
LookupSupportedLocales
(
availableLocales
requestedLocales
)
;
for
(
var
i
=
0
;
i
<
subset
.
length
;
i
+
+
)
{
_DefineDataProperty
(
subset
i
subset
[
i
]
ATTR_ENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
}
_DefineDataProperty
(
subset
"
length
"
subset
.
length
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
subset
;
}
function
GetOption
(
options
property
type
values
fallback
)
{
var
value
=
options
[
property
]
;
if
(
value
!
=
=
undefined
)
{
if
(
type
=
=
=
"
boolean
"
)
value
=
ToBoolean
(
value
)
;
else
if
(
type
=
=
=
"
string
"
)
value
=
ToString
(
value
)
;
else
assert
(
false
"
GetOption
"
)
;
if
(
values
!
=
=
undefined
&
&
callFunction
(
ArrayIndexOf
values
value
)
=
=
=
-
1
)
ThrowRangeError
(
JSMSG_INVALID_OPTION_VALUE
property
value
)
;
return
value
;
}
return
fallback
;
}
function
DefaultNumberOption
(
value
minimum
maximum
fallback
)
{
assert
(
typeof
minimum
=
=
=
"
number
"
&
&
(
minimum
|
0
)
=
=
=
minimum
"
DefaultNumberOption
"
)
;
assert
(
typeof
maximum
=
=
=
"
number
"
&
&
(
maximum
|
0
)
=
=
=
maximum
"
DefaultNumberOption
"
)
;
assert
(
typeof
fallback
=
=
=
"
number
"
&
&
(
fallback
|
0
)
=
=
=
fallback
"
DefaultNumberOption
"
)
;
assert
(
minimum
<
=
fallback
&
&
fallback
<
=
maximum
"
DefaultNumberOption
"
)
;
if
(
value
!
=
=
undefined
)
{
value
=
ToNumber
(
value
)
;
if
(
Number_isNaN
(
value
)
|
|
value
<
minimum
|
|
value
>
maximum
)
ThrowRangeError
(
JSMSG_INVALID_DIGITS_VALUE
value
)
;
return
std_Math_floor
(
value
)
|
0
;
}
return
fallback
;
}
function
GetNumberOption
(
options
property
minimum
maximum
fallback
)
{
return
DefaultNumberOption
(
options
[
property
]
minimum
maximum
fallback
)
;
}
var
intlFallbackSymbolHolder
=
{
value
:
undefined
}
;
function
intlFallbackSymbol
(
)
{
var
fallbackSymbol
=
intlFallbackSymbolHolder
.
value
;
if
(
!
fallbackSymbol
)
{
fallbackSymbol
=
std_Symbol
(
"
IntlLegacyConstructedSymbol
"
)
;
intlFallbackSymbolHolder
.
value
=
fallbackSymbol
;
}
return
fallbackSymbol
;
}
function
initializeIntlObject
(
obj
type
lazyData
)
{
assert
(
IsObject
(
obj
)
"
Non
-
object
passed
to
initializeIntlObject
"
)
;
assert
(
(
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
IsObject
(
lazyData
)
"
non
-
object
lazy
data
"
)
;
var
internals
=
std_Object_create
(
null
)
;
internals
.
type
=
type
;
internals
.
lazyData
=
lazyData
;
internals
.
internalProps
=
null
;
assert
(
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
=
=
=
null
"
Internal
slot
already
initialized
?
"
)
;
UnsafeSetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
internals
)
;
}
function
setInternalProperties
(
internals
internalProps
)
{
assert
(
IsObject
(
internals
.
lazyData
)
"
lazy
data
must
exist
already
"
)
;
assert
(
IsObject
(
internalProps
)
"
internalProps
argument
should
be
an
object
"
)
;
internals
.
internalProps
=
internalProps
;
internals
.
lazyData
=
null
;
}
function
maybeInternalProperties
(
internals
)
{
assert
(
IsObject
(
internals
)
"
non
-
object
passed
to
maybeInternalProperties
"
)
;
var
lazyData
=
internals
.
lazyData
;
if
(
lazyData
)
return
null
;
assert
(
IsObject
(
internals
.
internalProps
)
"
missing
lazy
data
and
computed
internals
"
)
;
return
internals
.
internalProps
;
}
function
getIntlObjectInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Object
"
)
;
assert
(
IsCollator
(
obj
)
|
|
IsDateTimeFormat
(
obj
)
|
|
IsNumberFormat
(
obj
)
|
|
IsPluralRules
(
obj
)
|
|
IsRelativeTimeFormat
(
obj
)
"
getIntlObjectInternals
called
with
non
-
Intl
object
"
)
;
var
internals
=
UnsafeGetReservedSlot
(
obj
INTL_INTERNALS_OBJECT_SLOT
)
;
assert
(
IsObject
(
internals
)
"
internals
not
an
object
"
)
;
assert
(
hasOwn
(
"
type
"
internals
)
"
missing
type
"
)
;
assert
(
(
internals
.
type
=
=
=
"
Collator
"
&
&
IsCollator
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
DateTimeFormat
"
&
&
IsDateTimeFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
NumberFormat
"
&
&
IsNumberFormat
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
PluralRules
"
&
&
IsPluralRules
(
obj
)
)
|
|
(
internals
.
type
=
=
=
"
RelativeTimeFormat
"
&
&
IsRelativeTimeFormat
(
obj
)
)
"
type
must
match
the
object
'
s
class
"
)
;
assert
(
hasOwn
(
"
lazyData
"
internals
)
"
missing
lazyData
"
)
;
assert
(
hasOwn
(
"
internalProps
"
internals
)
"
missing
internalProps
"
)
;
return
internals
;
}
function
getInternals
(
obj
)
{
var
internals
=
getIntlObjectInternals
(
obj
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
var
type
=
internals
.
type
;
if
(
type
=
=
=
"
Collator
"
)
internalProps
=
resolveCollatorInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
DateTimeFormat
"
)
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
else
if
(
type
=
=
=
"
NumberFormat
"
)
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
else
internalProps
=
resolvePluralRulesInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
var
collatorKeyMappings
=
{
kn
:
{
property
:
"
numeric
"
type
:
"
boolean
"
}
kf
:
{
property
:
"
caseFirst
"
type
:
"
string
"
values
:
[
"
upper
"
"
lower
"
"
false
"
]
}
}
;
function
resolveCollatorInternals
(
lazyCollatorData
)
{
assert
(
IsObject
(
lazyCollatorData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
internalProps
.
usage
=
lazyCollatorData
.
usage
;
var
Collator
=
collatorInternalProperties
;
var
collatorIsSorting
=
lazyCollatorData
.
usage
=
=
=
"
sort
"
;
var
localeData
=
collatorIsSorting
?
Collator
.
sortLocaleData
:
Collator
.
searchLocaleData
;
var
relevantExtensionKeys
=
Collator
.
relevantExtensionKeys
;
var
r
=
ResolveLocale
(
callFunction
(
Collator
.
availableLocales
Collator
)
lazyCollatorData
.
requestedLocales
lazyCollatorData
.
opt
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
var
key
property
value
mapping
;
var
i
=
0
len
=
relevantExtensionKeys
.
length
;
while
(
i
<
len
)
{
key
=
relevantExtensionKeys
[
i
]
;
if
(
key
=
=
=
"
co
"
)
{
property
=
"
collation
"
;
value
=
r
.
co
=
=
=
null
?
"
default
"
:
r
.
co
;
}
else
{
mapping
=
collatorKeyMappings
[
key
]
;
property
=
mapping
.
property
;
value
=
r
[
key
]
;
if
(
mapping
.
type
=
=
=
"
boolean
"
)
value
=
value
=
=
=
"
true
"
;
}
internalProps
[
property
]
=
value
;
i
+
+
;
}
var
s
=
lazyCollatorData
.
rawSensitivity
;
if
(
s
=
=
=
undefined
)
{
s
=
"
variant
"
;
}
internalProps
.
sensitivity
=
s
;
internalProps
.
ignorePunctuation
=
lazyCollatorData
.
ignorePunctuation
;
internalProps
.
boundFormat
=
undefined
;
return
internalProps
;
}
function
getCollatorInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getCollatorInternals
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
obj
)
"
getCollatorInternals
called
with
non
-
Collator
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
Collator
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveCollatorInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
InitializeCollator
(
collator
locales
options
)
{
assert
(
IsObject
(
collator
)
"
InitializeCollator
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
collator
)
"
InitializeCollator
called
with
non
-
Collator
"
)
;
var
lazyCollatorData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyCollatorData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
u
=
GetOption
(
options
"
usage
"
"
string
"
[
"
sort
"
"
search
"
]
"
sort
"
)
;
lazyCollatorData
.
usage
=
u
;
var
opt
=
new
Record
(
)
;
lazyCollatorData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
numericValue
=
GetOption
(
options
"
numeric
"
"
boolean
"
undefined
undefined
)
;
if
(
numericValue
!
=
=
undefined
)
numericValue
=
numericValue
?
"
true
"
:
"
false
"
;
opt
.
kn
=
numericValue
;
var
caseFirstValue
=
GetOption
(
options
"
caseFirst
"
"
string
"
[
"
upper
"
"
lower
"
"
false
"
]
undefined
)
;
opt
.
kf
=
caseFirstValue
;
var
s
=
GetOption
(
options
"
sensitivity
"
"
string
"
[
"
base
"
"
accent
"
"
case
"
"
variant
"
]
undefined
)
;
lazyCollatorData
.
rawSensitivity
=
s
;
var
ip
=
GetOption
(
options
"
ignorePunctuation
"
"
boolean
"
undefined
false
)
;
lazyCollatorData
.
ignorePunctuation
=
ip
;
initializeIntlObject
(
collator
"
Collator
"
lazyCollatorData
)
;
}
function
Intl_Collator_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
var
collatorInternalProperties
=
{
sortLocaleData
:
collatorSortLocaleData
searchLocaleData
:
collatorSearchLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_Collator_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
co
"
"
kn
"
"
kf
"
]
}
;
function
collatorActualLocale
(
locale
)
{
assert
(
typeof
locale
=
=
=
"
string
"
"
locale
should
be
string
"
)
;
var
availableLocales
=
callFunction
(
collatorInternalProperties
.
availableLocales
collatorInternalProperties
)
;
return
BestAvailableLocaleIgnoringDefault
(
availableLocales
locale
)
;
}
function
collatorSortCaseFirst
(
locale
)
{
var
actualLocale
=
collatorActualLocale
(
locale
)
;
if
(
intl_isUpperCaseFirst
(
actualLocale
)
)
return
[
"
upper
"
"
false
"
"
lower
"
]
;
return
[
"
false
"
"
lower
"
"
upper
"
]
;
}
function
collatorSortCaseFirstDefault
(
locale
)
{
var
actualLocale
=
collatorActualLocale
(
locale
)
;
if
(
intl_isUpperCaseFirst
(
actualLocale
)
)
return
"
upper
"
;
return
"
false
"
;
}
function
collatorSortLocaleData
(
)
{
return
{
co
:
intl_availableCollations
kn
:
function
(
)
{
return
[
"
false
"
"
true
"
]
;
}
kf
:
collatorSortCaseFirst
default
:
{
co
:
function
(
)
{
return
null
;
}
kn
:
function
(
)
{
return
"
false
"
;
}
kf
:
collatorSortCaseFirstDefault
}
}
;
}
function
collatorSearchLocaleData
(
)
{
return
{
co
:
function
(
)
{
return
[
null
]
;
}
kn
:
function
(
)
{
return
[
"
false
"
"
true
"
]
;
}
kf
:
function
(
)
{
return
[
"
false
"
"
lower
"
"
upper
"
]
;
}
default
:
{
co
:
function
(
)
{
return
null
;
}
kn
:
function
(
)
{
return
"
false
"
;
}
kf
:
function
(
)
{
return
"
false
"
;
}
}
}
;
}
function
collatorCompareToBind
(
x
y
)
{
var
collator
=
this
;
assert
(
IsObject
(
collator
)
"
collatorCompareToBind
called
with
non
-
object
"
)
;
assert
(
IsCollator
(
collator
)
"
collatorCompareToBind
called
with
non
-
Collator
"
)
;
var
X
=
ToString
(
x
)
;
var
Y
=
ToString
(
y
)
;
return
intl_CompareStrings
(
collator
X
Y
)
;
}
function
Intl_Collator_compare_get
(
)
{
var
collator
=
this
;
if
(
!
IsObject
(
collator
)
|
|
!
IsCollator
(
collator
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
Collator
"
"
compare
"
"
Collator
"
)
;
var
internals
=
getCollatorInternals
(
collator
)
;
if
(
internals
.
boundCompare
=
=
=
undefined
)
{
var
F
=
collatorCompareToBind
;
var
bc
=
callFunction
(
FunctionBind
F
collator
)
;
internals
.
boundCompare
=
bc
;
}
return
internals
.
boundCompare
;
}
_SetCanonicalName
(
Intl_Collator_compare_get
"
get
compare
"
)
;
function
Intl_Collator_resolvedOptions
(
)
{
if
(
!
IsObject
(
this
)
|
|
!
IsCollator
(
this
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
Collator
"
"
resolvedOptions
"
"
Collator
"
)
;
var
internals
=
getCollatorInternals
(
this
)
;
var
result
=
{
locale
:
internals
.
locale
usage
:
internals
.
usage
sensitivity
:
internals
.
sensitivity
ignorePunctuation
:
internals
.
ignorePunctuation
}
;
var
relevantExtensionKeys
=
collatorInternalProperties
.
relevantExtensionKeys
;
for
(
var
i
=
0
;
i
<
relevantExtensionKeys
.
length
;
i
+
+
)
{
var
key
=
relevantExtensionKeys
[
i
]
;
var
property
=
(
key
=
=
=
"
co
"
)
?
"
collation
"
:
collatorKeyMappings
[
key
]
.
property
;
_DefineDataProperty
(
result
property
internals
[
property
]
)
;
}
return
result
;
}
var
numberFormatInternalProperties
=
{
localeData
:
numberFormatLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_NumberFormat_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
nu
"
]
}
;
function
resolveNumberFormatInternals
(
lazyNumberFormatData
)
{
assert
(
IsObject
(
lazyNumberFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
requestedLocales
=
lazyNumberFormatData
.
requestedLocales
;
var
opt
=
lazyNumberFormatData
.
opt
;
var
NumberFormat
=
numberFormatInternalProperties
;
var
localeData
=
NumberFormat
.
localeData
;
var
r
=
ResolveLocale
(
callFunction
(
NumberFormat
.
availableLocales
NumberFormat
)
requestedLocales
opt
NumberFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
style
=
lazyNumberFormatData
.
style
;
internalProps
.
style
=
style
;
if
(
style
=
=
=
"
currency
"
)
{
internalProps
.
currency
=
lazyNumberFormatData
.
currency
;
internalProps
.
currencyDisplay
=
lazyNumberFormatData
.
currencyDisplay
;
}
internalProps
.
minimumIntegerDigits
=
lazyNumberFormatData
.
minimumIntegerDigits
;
internalProps
.
minimumFractionDigits
=
lazyNumberFormatData
.
minimumFractionDigits
;
internalProps
.
maximumFractionDigits
=
lazyNumberFormatData
.
maximumFractionDigits
;
if
(
"
minimumSignificantDigits
"
in
lazyNumberFormatData
)
{
assert
(
"
maximumSignificantDigits
"
in
lazyNumberFormatData
"
min
/
max
sig
digits
mismatch
"
)
;
internalProps
.
minimumSignificantDigits
=
lazyNumberFormatData
.
minimumSignificantDigits
;
internalProps
.
maximumSignificantDigits
=
lazyNumberFormatData
.
maximumSignificantDigits
;
}
internalProps
.
useGrouping
=
lazyNumberFormatData
.
useGrouping
;
internalProps
.
boundFormat
=
undefined
;
return
internalProps
;
}
function
getNumberFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getNumberFormatInternals
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
obj
)
"
getNumberFormatInternals
called
with
non
-
NumberFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
NumberFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveNumberFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapNumberFormat
(
nf
methodName
)
{
if
(
IsObject
(
nf
)
&
&
!
IsNumberFormat
(
nf
)
&
&
nf
instanceof
GetNumberFormatConstructor
(
)
)
nf
=
nf
[
intlFallbackSymbol
(
)
]
;
if
(
!
IsObject
(
nf
)
|
|
!
IsNumberFormat
(
nf
)
)
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
NumberFormat
"
methodName
"
NumberFormat
"
)
;
return
nf
;
}
function
SetNumberFormatDigitOptions
(
lazyData
options
mnfdDefault
mxfdDefault
)
{
assert
(
IsObject
(
options
)
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mnfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
typeof
mxfdDefault
=
=
=
"
number
"
"
SetNumberFormatDigitOptions
"
)
;
assert
(
mnfdDefault
<
=
mxfdDefault
"
SetNumberFormatDigitOptions
"
)
;
const
mnid
=
GetNumberOption
(
options
"
minimumIntegerDigits
"
1
21
1
)
;
const
mnfd
=
GetNumberOption
(
options
"
minimumFractionDigits
"
0
20
mnfdDefault
)
;
const
mxfdActualDefault
=
std_Math_max
(
mnfd
mxfdDefault
)
;
const
mxfd
=
GetNumberOption
(
options
"
maximumFractionDigits
"
mnfd
20
mxfdActualDefault
)
;
let
mnsd
=
options
.
minimumSignificantDigits
;
let
mxsd
=
options
.
maximumSignificantDigits
;
lazyData
.
minimumIntegerDigits
=
mnid
;
lazyData
.
minimumFractionDigits
=
mnfd
;
lazyData
.
maximumFractionDigits
=
mxfd
;
if
(
mnsd
!
=
=
undefined
|
|
mxsd
!
=
=
undefined
)
{
mnsd
=
DefaultNumberOption
(
mnsd
1
21
1
)
;
mxsd
=
DefaultNumberOption
(
mxsd
mnsd
21
21
)
;
lazyData
.
minimumSignificantDigits
=
mnsd
;
lazyData
.
maximumSignificantDigits
=
mxsd
;
}
}
function
InitializeNumberFormat
(
numberFormat
thisValue
locales
options
)
{
assert
(
IsObject
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
numberFormat
)
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
lazyNumberFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyNumberFormatData
.
requestedLocales
=
requestedLocales
;
if
(
options
=
=
=
undefined
)
options
=
std_Object_create
(
null
)
;
else
options
=
ToObject
(
options
)
;
var
opt
=
new
Record
(
)
;
lazyNumberFormatData
.
opt
=
opt
;
var
matcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
opt
.
localeMatcher
=
matcher
;
var
style
=
GetOption
(
options
"
style
"
"
string
"
[
"
decimal
"
"
percent
"
"
currency
"
]
"
decimal
"
)
;
lazyNumberFormatData
.
style
=
style
;
var
c
=
GetOption
(
options
"
currency
"
"
string
"
undefined
undefined
)
;
if
(
c
!
=
=
undefined
&
&
!
IsWellFormedCurrencyCode
(
c
)
)
ThrowRangeError
(
JSMSG_INVALID_CURRENCY_CODE
c
)
;
var
cDigits
;
if
(
style
=
=
=
"
currency
"
)
{
if
(
c
=
=
=
undefined
)
ThrowTypeError
(
JSMSG_UNDEFINED_CURRENCY
)
;
c
=
toASCIIUpperCase
(
c
)
;
lazyNumberFormatData
.
currency
=
c
;
cDigits
=
CurrencyDigits
(
c
)
;
}
var
cd
=
GetOption
(
options
"
currencyDisplay
"
"
string
"
[
"
code
"
"
symbol
"
"
name
"
]
"
symbol
"
)
;
if
(
style
=
=
=
"
currency
"
)
lazyNumberFormatData
.
currencyDisplay
=
cd
;
var
mnfdDefault
mxfdDefault
;
if
(
style
=
=
=
"
currency
"
)
{
mnfdDefault
=
cDigits
;
mxfdDefault
=
cDigits
;
}
else
{
mnfdDefault
=
0
;
mxfdDefault
=
style
=
=
=
"
percent
"
?
0
:
3
;
}
SetNumberFormatDigitOptions
(
lazyNumberFormatData
options
mnfdDefault
mxfdDefault
)
;
var
g
=
GetOption
(
options
"
useGrouping
"
"
boolean
"
undefined
true
)
;
lazyNumberFormatData
.
useGrouping
=
g
;
initializeIntlObject
(
numberFormat
"
NumberFormat
"
lazyNumberFormatData
)
;
if
(
numberFormat
!
=
=
thisValue
&
&
IsObject
(
thisValue
)
&
&
thisValue
instanceof
GetNumberFormatConstructor
(
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
numberFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
numberFormat
;
}
function
getCurrencyDigitsRE
(
)
{
return
internalIntlRegExps
.
currencyDigitsRE
|
|
(
internalIntlRegExps
.
currencyDigitsRE
=
RegExpCreate
(
"
^
[
A
-
Z
]
{
3
}
"
)
)
;
}
function
CurrencyDigits
(
currency
)
{
assert
(
typeof
currency
=
=
=
"
string
"
"
CurrencyDigits
"
)
;
assert
(
regexp_test_no_statics
(
getCurrencyDigitsRE
(
)
currency
)
"
CurrencyDigits
"
)
;
if
(
hasOwn
(
currency
currencyDigits
)
)
return
currencyDigits
[
currency
]
;
return
2
;
}
function
Intl_NumberFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
numberFormatInternalProperties
.
availableLocales
numberFormatInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
function
getNumberingSystems
(
locale
)
{
var
defaultNumberingSystem
=
intl_numberingSystem
(
locale
)
;
return
[
defaultNumberingSystem
"
arab
"
"
arabext
"
"
bali
"
"
beng
"
"
deva
"
"
fullwide
"
"
gujr
"
"
guru
"
"
hanidec
"
"
khmr
"
"
knda
"
"
laoo
"
"
latn
"
"
limb
"
"
mlym
"
"
mong
"
"
mymr
"
"
orya
"
"
tamldec
"
"
telu
"
"
thai
"
"
tibt
"
]
;
}
function
numberFormatLocaleData
(
)
{
return
{
nu
:
getNumberingSystems
default
:
{
nu
:
intl_numberingSystem
}
}
;
}
function
numberFormatFormatToBind
(
value
)
{
var
nf
=
this
;
assert
(
IsObject
(
nf
)
"
InitializeNumberFormat
called
with
non
-
object
"
)
;
assert
(
IsNumberFormat
(
nf
)
"
InitializeNumberFormat
called
with
non
-
NumberFormat
"
)
;
var
x
=
ToNumber
(
value
)
;
return
intl_FormatNumber
(
nf
x
false
)
;
}
function
Intl_NumberFormat_format_get
(
)
{
var
nf
=
UnwrapNumberFormat
(
this
"
format
"
)
;
var
internals
=
getNumberFormatInternals
(
nf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
var
F
=
numberFormatFormatToBind
;
var
bf
=
callFunction
(
FunctionBind
F
nf
)
;
internals
.
boundFormat
=
bf
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_NumberFormat_format_get
"
get
format
"
)
;
function
Intl_NumberFormat_formatToParts
(
value
)
{
var
nf
=
this
;
if
(
!
IsObject
(
nf
)
|
|
!
IsNumberFormat
(
nf
)
)
{
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
NumberFormat
"
"
formatToParts
"
"
NumberFormat
"
)
;
}
getNumberFormatInternals
(
nf
)
;
var
x
=
ToNumber
(
value
)
;
return
intl_FormatNumber
(
nf
x
true
)
;
}
function
Intl_NumberFormat_resolvedOptions
(
)
{
var
nf
=
UnwrapNumberFormat
(
this
"
resolvedOptions
"
)
;
var
internals
=
getNumberFormatInternals
(
nf
)
;
var
result
=
{
locale
:
internals
.
locale
numberingSystem
:
internals
.
numberingSystem
style
:
internals
.
style
minimumIntegerDigits
:
internals
.
minimumIntegerDigits
minimumFractionDigits
:
internals
.
minimumFractionDigits
maximumFractionDigits
:
internals
.
maximumFractionDigits
useGrouping
:
internals
.
useGrouping
}
;
var
optionalProperties
=
[
"
currency
"
"
currencyDisplay
"
"
minimumSignificantDigits
"
"
maximumSignificantDigits
"
]
;
for
(
var
i
=
0
;
i
<
optionalProperties
.
length
;
i
+
+
)
{
var
p
=
optionalProperties
[
i
]
;
if
(
hasOwn
(
p
internals
)
)
_DefineDataProperty
(
result
p
internals
[
p
]
)
;
}
return
result
;
}
function
resolveDateTimeFormatInternals
(
lazyDateTimeFormatData
)
{
assert
(
IsObject
(
lazyDateTimeFormatData
)
"
lazy
data
not
an
object
?
"
)
;
var
internalProps
=
std_Object_create
(
null
)
;
var
DateTimeFormat
=
dateTimeFormatInternalProperties
;
var
localeData
=
DateTimeFormat
.
localeData
;
var
r
=
ResolveLocale
(
callFunction
(
DateTimeFormat
.
availableLocales
DateTimeFormat
)
lazyDateTimeFormatData
.
requestedLocales
lazyDateTimeFormatData
.
localeOpt
DateTimeFormat
.
relevantExtensionKeys
localeData
)
;
internalProps
.
locale
=
r
.
locale
;
internalProps
.
calendar
=
r
.
ca
;
internalProps
.
numberingSystem
=
r
.
nu
;
var
dataLocale
=
r
.
dataLocale
;
internalProps
.
timeZone
=
lazyDateTimeFormatData
.
timeZone
;
var
formatOpt
=
lazyDateTimeFormatData
.
formatOpt
;
if
(
r
.
hc
!
=
=
null
&
&
formatOpt
.
hour12
=
=
=
undefined
)
formatOpt
.
hourCycle
=
r
.
hc
;
var
pattern
;
if
(
lazyDateTimeFormatData
.
mozExtensions
)
{
if
(
lazyDateTimeFormatData
.
patternOption
!
=
=
undefined
)
{
pattern
=
lazyDateTimeFormatData
.
patternOption
;
internalProps
.
patternOption
=
lazyDateTimeFormatData
.
patternOption
;
}
else
if
(
lazyDateTimeFormatData
.
dateStyle
|
|
lazyDateTimeFormatData
.
timeStyle
)
{
pattern
=
intl_patternForStyle
(
dataLocale
lazyDateTimeFormatData
.
dateStyle
lazyDateTimeFormatData
.
timeStyle
lazyDateTimeFormatData
.
timeZone
)
;
internalProps
.
dateStyle
=
lazyDateTimeFormatData
.
dateStyle
;
internalProps
.
timeStyle
=
lazyDateTimeFormatData
.
timeStyle
;
}
else
{
pattern
=
toBestICUPattern
(
dataLocale
formatOpt
)
;
}
internalProps
.
mozExtensions
=
true
;
}
else
{
pattern
=
toBestICUPattern
(
dataLocale
formatOpt
)
;
}
if
(
formatOpt
.
hourCycle
!
=
=
undefined
)
pattern
=
replaceHourRepresentation
(
pattern
formatOpt
.
hourCycle
)
;
internalProps
.
pattern
=
pattern
;
internalProps
.
boundFormat
=
undefined
;
return
internalProps
;
}
function
replaceHourRepresentation
(
pattern
hourCycle
)
{
var
hour
;
switch
(
hourCycle
)
{
case
"
h11
"
:
hour
=
"
K
"
;
break
;
case
"
h12
"
:
hour
=
"
h
"
;
break
;
case
"
h23
"
:
hour
=
"
H
"
;
break
;
case
"
h24
"
:
hour
=
"
k
"
;
break
;
}
assert
(
hour
!
=
=
undefined
"
Unexpected
hourCycle
requested
:
"
+
hourCycle
)
;
var
resultPattern
=
"
"
;
var
inQuote
=
false
;
for
(
var
i
=
0
;
i
<
pattern
.
length
;
i
+
+
)
{
var
ch
=
pattern
[
i
]
;
if
(
ch
=
=
=
"
'
"
)
{
inQuote
=
!
inQuote
;
}
else
if
(
!
inQuote
&
&
(
ch
=
=
=
"
h
"
|
|
ch
=
=
=
"
H
"
|
|
ch
=
=
=
"
k
"
|
|
ch
=
=
=
"
K
"
)
)
{
ch
=
hour
;
}
resultPattern
+
=
ch
;
}
return
resultPattern
;
}
function
getDateTimeFormatInternals
(
obj
)
{
assert
(
IsObject
(
obj
)
"
getDateTimeFormatInternals
called
with
non
-
object
"
)
;
assert
(
IsDateTimeFormat
(
obj
)
"
getDateTimeFormatInternals
called
with
non
-
DateTimeFormat
"
)
;
var
internals
=
getIntlObjectInternals
(
obj
)
;
assert
(
internals
.
type
=
=
=
"
DateTimeFormat
"
"
bad
type
escaped
getIntlObjectInternals
"
)
;
var
internalProps
=
maybeInternalProperties
(
internals
)
;
if
(
internalProps
)
return
internalProps
;
internalProps
=
resolveDateTimeFormatInternals
(
internals
.
lazyData
)
;
setInternalProperties
(
internals
internalProps
)
;
return
internalProps
;
}
function
UnwrapDateTimeFormat
(
dtf
methodName
)
{
if
(
IsObject
(
dtf
)
&
&
!
IsDateTimeFormat
(
dtf
)
&
&
dtf
instanceof
GetDateTimeFormatConstructor
(
)
)
dtf
=
dtf
[
intlFallbackSymbol
(
)
]
;
if
(
!
IsObject
(
dtf
)
|
|
!
IsDateTimeFormat
(
dtf
)
)
{
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
DateTimeFormat
"
methodName
"
DateTimeFormat
"
)
;
}
return
dtf
;
}
function
InitializeDateTimeFormat
(
dateTimeFormat
thisValue
locales
options
mozExtensions
)
{
assert
(
IsObject
(
dateTimeFormat
)
"
InitializeDateTimeFormat
called
with
non
-
Object
"
)
;
assert
(
IsDateTimeFormat
(
dateTimeFormat
)
"
InitializeDateTimeFormat
called
with
non
-
DateTimeFormat
"
)
;
var
lazyDateTimeFormatData
=
std_Object_create
(
null
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
lazyDateTimeFormatData
.
requestedLocales
=
requestedLocales
;
options
=
ToDateTimeOptions
(
options
"
any
"
"
date
"
)
;
var
localeOpt
=
new
Record
(
)
;
lazyDateTimeFormatData
.
localeOpt
=
localeOpt
;
var
localeMatcher
=
GetOption
(
options
"
localeMatcher
"
"
string
"
[
"
lookup
"
"
best
fit
"
]
"
best
fit
"
)
;
localeOpt
.
localeMatcher
=
localeMatcher
;
var
hc
=
GetOption
(
options
"
hourCycle
"
"
string
"
[
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
undefined
)
;
localeOpt
.
hc
=
hc
;
var
tz
=
options
.
timeZone
;
if
(
tz
!
=
=
undefined
)
{
tz
=
ToString
(
tz
)
;
var
timeZone
=
intl_IsValidTimeZoneName
(
tz
)
;
if
(
timeZone
=
=
=
null
)
ThrowRangeError
(
JSMSG_INVALID_TIME_ZONE
tz
)
;
tz
=
CanonicalizeTimeZoneName
(
timeZone
)
;
}
else
{
tz
=
DefaultTimeZone
(
)
;
}
lazyDateTimeFormatData
.
timeZone
=
tz
;
var
formatOpt
=
new
Record
(
)
;
lazyDateTimeFormatData
.
formatOpt
=
formatOpt
;
lazyDateTimeFormatData
.
mozExtensions
=
mozExtensions
;
if
(
mozExtensions
)
{
let
pattern
=
GetOption
(
options
"
pattern
"
"
string
"
undefined
undefined
)
;
lazyDateTimeFormatData
.
patternOption
=
pattern
;
let
dateStyle
=
GetOption
(
options
"
dateStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
dateStyle
=
dateStyle
;
let
timeStyle
=
GetOption
(
options
"
timeStyle
"
"
string
"
[
"
full
"
"
long
"
"
medium
"
"
short
"
]
undefined
)
;
lazyDateTimeFormatData
.
timeStyle
=
timeStyle
;
}
formatOpt
.
weekday
=
GetOption
(
options
"
weekday
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
era
=
GetOption
(
options
"
era
"
"
string
"
[
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
year
=
GetOption
(
options
"
year
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
month
=
GetOption
(
options
"
month
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
"
narrow
"
"
short
"
"
long
"
]
undefined
)
;
formatOpt
.
day
=
GetOption
(
options
"
day
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
hour
=
GetOption
(
options
"
hour
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
minute
=
GetOption
(
options
"
minute
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
second
=
GetOption
(
options
"
second
"
"
string
"
[
"
2
-
digit
"
"
numeric
"
]
undefined
)
;
formatOpt
.
timeZoneName
=
GetOption
(
options
"
timeZoneName
"
"
string
"
[
"
short
"
"
long
"
]
undefined
)
;
var
formatMatcher
=
GetOption
(
options
"
formatMatcher
"
"
string
"
[
"
basic
"
"
best
fit
"
]
"
best
fit
"
)
;
void
formatMatcher
;
var
hr12
=
GetOption
(
options
"
hour12
"
"
boolean
"
undefined
undefined
)
;
if
(
hr12
!
=
=
undefined
)
formatOpt
.
hour12
=
hr12
;
initializeIntlObject
(
dateTimeFormat
"
DateTimeFormat
"
lazyDateTimeFormatData
)
;
if
(
dateTimeFormat
!
=
=
thisValue
&
&
IsObject
(
thisValue
)
&
&
thisValue
instanceof
GetDateTimeFormatConstructor
(
)
)
{
_DefineDataProperty
(
thisValue
intlFallbackSymbol
(
)
dateTimeFormat
ATTR_NONENUMERABLE
|
ATTR_NONCONFIGURABLE
|
ATTR_NONWRITABLE
)
;
return
thisValue
;
}
return
dateTimeFormat
;
}
function
toBestICUPattern
(
locale
options
)
{
var
skeleton
=
"
"
;
switch
(
options
.
weekday
)
{
case
"
narrow
"
:
skeleton
+
=
"
EEEEE
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
E
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
EEEE
"
;
}
switch
(
options
.
era
)
{
case
"
narrow
"
:
skeleton
+
=
"
GGGGG
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
G
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
GGGG
"
;
break
;
}
switch
(
options
.
year
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
yy
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
y
"
;
break
;
}
switch
(
options
.
month
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
MM
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
M
"
;
break
;
case
"
narrow
"
:
skeleton
+
=
"
MMMMM
"
;
break
;
case
"
short
"
:
skeleton
+
=
"
MMM
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
MMMM
"
;
break
;
}
switch
(
options
.
day
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
dd
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
d
"
;
break
;
}
var
hourSkeletonChar
=
"
j
"
;
if
(
options
.
hour12
!
=
=
undefined
)
{
if
(
options
.
hour12
)
hourSkeletonChar
=
"
h
"
;
else
hourSkeletonChar
=
"
H
"
;
}
else
{
switch
(
options
.
hourCycle
)
{
case
"
h11
"
:
case
"
h12
"
:
hourSkeletonChar
=
"
h
"
;
break
;
case
"
h23
"
:
case
"
h24
"
:
hourSkeletonChar
=
"
H
"
;
break
;
}
}
switch
(
options
.
hour
)
{
case
"
2
-
digit
"
:
skeleton
+
=
hourSkeletonChar
+
hourSkeletonChar
;
break
;
case
"
numeric
"
:
skeleton
+
=
hourSkeletonChar
;
break
;
}
switch
(
options
.
minute
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
mm
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
m
"
;
break
;
}
switch
(
options
.
second
)
{
case
"
2
-
digit
"
:
skeleton
+
=
"
ss
"
;
break
;
case
"
numeric
"
:
skeleton
+
=
"
s
"
;
break
;
}
switch
(
options
.
timeZoneName
)
{
case
"
short
"
:
skeleton
+
=
"
z
"
;
break
;
case
"
long
"
:
skeleton
+
=
"
zzzz
"
;
break
;
}
return
intl_patternForSkeleton
(
locale
skeleton
)
;
}
function
ToDateTimeOptions
(
options
required
defaults
)
{
assert
(
typeof
required
=
=
=
"
string
"
"
ToDateTimeOptions
"
)
;
assert
(
typeof
defaults
=
=
=
"
string
"
"
ToDateTimeOptions
"
)
;
if
(
options
=
=
=
undefined
)
options
=
null
;
else
options
=
ToObject
(
options
)
;
options
=
std_Object_create
(
options
)
;
var
needDefaults
=
true
;
if
(
(
required
=
=
=
"
date
"
|
|
required
=
=
=
"
any
"
)
&
&
(
options
.
weekday
!
=
=
undefined
|
|
options
.
year
!
=
=
undefined
|
|
options
.
month
!
=
=
undefined
|
|
options
.
day
!
=
=
undefined
)
)
{
needDefaults
=
false
;
}
if
(
(
required
=
=
=
"
time
"
|
|
required
=
=
=
"
any
"
)
&
&
(
options
.
hour
!
=
=
undefined
|
|
options
.
minute
!
=
=
undefined
|
|
options
.
second
!
=
=
undefined
)
)
{
needDefaults
=
false
;
}
if
(
needDefaults
&
&
(
defaults
=
=
=
"
date
"
|
|
defaults
=
=
=
"
all
"
)
)
{
_DefineDataProperty
(
options
"
year
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
month
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
day
"
"
numeric
"
)
;
}
if
(
needDefaults
&
&
(
defaults
=
=
=
"
time
"
|
|
defaults
=
=
=
"
all
"
)
)
{
_DefineDataProperty
(
options
"
hour
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
minute
"
"
numeric
"
)
;
_DefineDataProperty
(
options
"
second
"
"
numeric
"
)
;
}
return
options
;
}
function
Intl_DateTimeFormat_supportedLocalesOf
(
locales
)
{
var
options
=
arguments
.
length
>
1
?
arguments
[
1
]
:
undefined
;
var
availableLocales
=
callFunction
(
dateTimeFormatInternalProperties
.
availableLocales
dateTimeFormatInternalProperties
)
;
var
requestedLocales
=
CanonicalizeLocaleList
(
locales
)
;
return
SupportedLocales
(
availableLocales
requestedLocales
options
)
;
}
var
dateTimeFormatInternalProperties
=
{
localeData
:
dateTimeFormatLocaleData
_availableLocales
:
null
availableLocales
:
function
(
)
{
var
locales
=
this
.
_availableLocales
;
if
(
locales
)
return
locales
;
locales
=
intl_DateTimeFormat_availableLocales
(
)
;
addSpecialMissingLanguageTags
(
locales
)
;
return
(
this
.
_availableLocales
=
locales
)
;
}
relevantExtensionKeys
:
[
"
ca
"
"
nu
"
"
hc
"
]
}
;
function
dateTimeFormatLocaleData
(
)
{
return
{
ca
:
intl_availableCalendars
nu
:
getNumberingSystems
hc
:
(
)
=
>
{
return
[
null
"
h11
"
"
h12
"
"
h23
"
"
h24
"
]
;
}
default
:
{
ca
:
intl_defaultCalendar
nu
:
intl_numberingSystem
hc
:
(
)
=
>
{
return
null
;
}
}
}
;
}
function
dateTimeFormatFormatToBind
(
date
)
{
var
dtf
=
this
;
assert
(
IsObject
(
dtf
)
"
dateTimeFormatFormatToBind
called
with
non
-
Object
"
)
;
assert
(
IsDateTimeFormat
(
dtf
)
"
dateTimeFormatFormatToBind
called
with
non
-
DateTimeFormat
"
)
;
var
x
=
(
date
=
=
=
undefined
)
?
std_Date_now
(
)
:
ToNumber
(
date
)
;
return
intl_FormatDateTime
(
dtf
x
false
)
;
}
function
Intl_DateTimeFormat_format_get
(
)
{
var
dtf
=
UnwrapDateTimeFormat
(
this
"
format
"
)
;
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
if
(
internals
.
boundFormat
=
=
=
undefined
)
{
var
F
=
dateTimeFormatFormatToBind
;
var
bf
=
callFunction
(
FunctionBind
F
dtf
)
;
internals
.
boundFormat
=
bf
;
}
return
internals
.
boundFormat
;
}
_SetCanonicalName
(
Intl_DateTimeFormat_format_get
"
get
format
"
)
;
function
Intl_DateTimeFormat_formatToParts
(
date
)
{
var
dtf
=
this
;
if
(
!
IsObject
(
dtf
)
|
|
!
IsDateTimeFormat
(
dtf
)
)
{
ThrowTypeError
(
JSMSG_INTL_OBJECT_NOT_INITED
"
DateTimeFormat
"
"
formatToParts
"
"
DateTimeFormat
"
)
;
}
getDateTimeFormatInternals
(
dtf
)
;
var
x
=
(
date
=
=
=
undefined
)
?
std_Date_now
(
)
:
ToNumber
(
date
)
;
return
intl_FormatDateTime
(
dtf
x
true
)
;
}
function
Intl_DateTimeFormat_resolvedOptions
(
)
{
var
dtf
=
UnwrapDateTimeFormat
(
this
"
resolvedOptions
"
)
;
var
internals
=
getDateTimeFormatInternals
(
dtf
)
;
var
result
=
{
locale
:
internals
.
locale
calendar
:
internals
.
calendar
numberingSystem
:
internals
.
numberingSystem
timeZone
:
internals
.
timeZone
}
;
if
(
internals
.
mozExtensions
)
{
if
(
internals
.
patternOption
!
=
=
undefined
)
{
result
.
pattern
=
internals
.
pattern
;
}
else
if
(
internals
.
dateStyle
|
|
internals
.
timeStyle
)
{
result
.
dateStyle
=
internals
.
dateStyle
;
result
.
timeStyle
=
internals
.
timeStyle
;
}
}
resolveICUPattern
(
internals
.
pattern
result
)
;
return
result
;
}
var
icuPatternCharToComponent
=
{
E
:
"
weekday
"
G
:
"
era
"
y
:
"
year
"
M
:
"
month
"
L
:
"
month
"
d
:
"
day
"
h
:
"
hour
"
H
:
"
hour
"
k
:
"
hour
"
K
:
"
hour
"
m
:
"
minute
"
s
:
"
second
"
z
:
"
timeZoneName
"
v
:
"
timeZoneName
"
V
:
"
timeZoneName
"
}
;
function
resolveICUPattern
(
pattern
result
)
{
assert
(
IsObject
(
result
)
"
resolveICUPattern
"
)
;
var
i
=
0
;
while
(
i
<
pattern
.
length
)
{
var
c
=
pattern
[
i
+
+
]
;
if
(
c
=
=
=
"
'
"
)
{
while
(
i
<
pattern
.
length
&
&
pattern
[
i
]
!
=
=
"
'
"
)
i
+
+
;
i
+
+
;
}
else
{
var
count
=
1
;
while
(
i
<
pattern
.
length
&
&
pattern
[
i
]
=
=
=
c
)
{
i
+
+
;
count
+
+
;
}
var
value
;
switch
(
c
)
{
case
"
G
"
:
case
"
E
"
:
case
"
z
"
:
case
"
v
"
:
case
"
V
"
:
if
(
count
<
=
3
)
value
=
"
short
"
;
else
if
(
count
=
=
=
4
)
value
=
"
long
"
;
else
value
=
"
narrow
"
;
break
;
case
"
y
"
:
case
"
d
"
:
case
"
h
"
:
case
"
H
"
:
case
"
m
"
:
case
"
s
"
:
case
"
k
"
:
case
"
K
"
:
if
(
count
=
=
=
2
)
value
=
"
2
-
digit
"
;
else
value
=
"
numeric
"
;
break
;
case
"
M
"
:
case
"
L
"
:
if
(
count
=
=
=
1
)
value
=
"
numeric
"
;
else
if
(
count
=
=
=
2
)
value
=
"
2
-
digit
"
;
else
if
(
count
=
=
=
3
)
value
=
"
short
"
;
else
if
(
count
=
=
=
4
)
value
=
"
long
"
;
else
value
=
"
narrow
"
;
break
;
default
:
}
if
(
hasOwn
(
c
icuPatternCharToComponent
)
)
_DefineDataProperty
(
result
icuPatternCharToComponent
[
c
]
value
)
;
switch
(
c
)
{
case
"
h
"
:
_DefineDataProperty
(
result
"
hourCycle
"
"
h12
"
)
;
_DefineDataProperty
(
result
"
hour12
"
true
)
;
break
;
case
"
K
"
:
_DefineDataProperty
(
result
"
hourCycle
"
"
h11
"
)
;
_DefineDataProperty
(
result
"
hour12
"
true
)
;
break
;
case
"
H
"
:
_DefineDataProperty
(
result
"
hourCycle
"
"
h23
"
)
;
_DefineDataProperty
(
result
"
hour12
"
false
)
;
break
;
case
"
k
"
:
_DefineDataProperty
(
result
"
hourCycle
"
"
h24
"
)
;
_DefineDataProperty
(
result
"
hour12
"
false
)
;
break
;
}
}
}
}
