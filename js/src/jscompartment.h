#
ifndef
jscompartment_h
#
define
jscompartment_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
"
builtin
/
RegExp
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
PIC
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
#
include
"
vm
/
Time
.
h
"
namespace
js
{
namespace
jit
{
class
JitCompartment
;
}
namespace
gc
{
template
<
class
Node
>
class
ComponentFinder
;
}
namespace
wasm
{
class
Module
;
}
struct
NativeIterator
;
class
ClonedBlockObject
;
class
DtoaCache
{
double
d
;
int
base
;
JSFlatString
*
s
;
public
:
DtoaCache
(
)
:
s
(
nullptr
)
{
}
void
purge
(
)
{
s
=
nullptr
;
}
JSFlatString
*
lookup
(
int
base
double
d
)
{
return
this
-
>
s
&
&
base
=
=
this
-
>
base
&
&
d
=
=
this
-
>
d
?
this
-
>
s
:
nullptr
;
}
void
cache
(
int
base
double
d
JSFlatString
*
s
)
{
this
-
>
base
=
base
;
this
-
>
d
=
d
;
this
-
>
s
=
s
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkCacheAfterMovingGC
(
)
{
MOZ_ASSERT
(
!
s
|
|
!
IsForwarded
(
s
)
)
;
}
#
endif
}
;
struct
CrossCompartmentKey
{
enum
Kind
{
ObjectWrapper
StringWrapper
DebuggerScript
DebuggerSource
DebuggerObject
DebuggerEnvironment
DebuggerWasmScript
DebuggerWasmSource
}
;
Kind
kind
;
JSObject
*
debugger
;
js
:
:
gc
:
:
Cell
*
wrapped
;
explicit
CrossCompartmentKey
(
JSObject
*
wrapped
)
:
kind
(
ObjectWrapper
)
debugger
(
nullptr
)
wrapped
(
wrapped
)
{
MOZ_RELEASE_ASSERT
(
wrapped
)
;
}
explicit
CrossCompartmentKey
(
JSString
*
wrapped
)
:
kind
(
StringWrapper
)
debugger
(
nullptr
)
wrapped
(
wrapped
)
{
MOZ_RELEASE_ASSERT
(
wrapped
)
;
}
explicit
CrossCompartmentKey
(
Value
wrappedArg
)
:
kind
(
wrappedArg
.
isString
(
)
?
StringWrapper
:
ObjectWrapper
)
debugger
(
nullptr
)
wrapped
(
(
js
:
:
gc
:
:
Cell
*
)
wrappedArg
.
toGCThing
(
)
)
{
MOZ_RELEASE_ASSERT
(
wrappedArg
.
isString
(
)
|
|
wrappedArg
.
isObject
(
)
)
;
MOZ_RELEASE_ASSERT
(
wrapped
)
;
}
explicit
CrossCompartmentKey
(
const
RootedValue
&
wrappedArg
)
:
kind
(
wrappedArg
.
get
(
)
.
isString
(
)
?
StringWrapper
:
ObjectWrapper
)
debugger
(
nullptr
)
wrapped
(
(
js
:
:
gc
:
:
Cell
*
)
wrappedArg
.
get
(
)
.
toGCThing
(
)
)
{
MOZ_RELEASE_ASSERT
(
wrappedArg
.
isString
(
)
|
|
wrappedArg
.
isObject
(
)
)
;
MOZ_RELEASE_ASSERT
(
wrapped
)
;
}
CrossCompartmentKey
(
Kind
kind
JSObject
*
dbg
js
:
:
gc
:
:
Cell
*
wrapped
)
:
kind
(
kind
)
debugger
(
dbg
)
wrapped
(
wrapped
)
{
MOZ_RELEASE_ASSERT
(
dbg
)
;
MOZ_RELEASE_ASSERT
(
wrapped
)
;
}
bool
needsSweep
(
)
;
private
:
CrossCompartmentKey
(
)
=
delete
;
}
;
struct
WrapperHasher
:
public
DefaultHasher
<
CrossCompartmentKey
>
{
static
HashNumber
hash
(
const
CrossCompartmentKey
&
key
)
{
static_assert
(
sizeof
(
HashNumber
)
=
=
sizeof
(
uint32_t
)
"
subsequent
code
assumes
a
four
-
byte
hash
"
)
;
return
uint32_t
(
uintptr_t
(
key
.
wrapped
)
)
|
uint32_t
(
key
.
kind
)
;
}
static
bool
match
(
const
CrossCompartmentKey
&
l
const
CrossCompartmentKey
&
k
)
{
return
l
.
kind
=
=
k
.
kind
&
&
l
.
debugger
=
=
k
.
debugger
&
&
l
.
wrapped
=
=
k
.
wrapped
;
}
}
;
using
WrapperMap
=
GCRekeyableHashMap
<
CrossCompartmentKey
ReadBarrieredValue
WrapperHasher
SystemAllocPolicy
>
;
struct
ImmediateMetadata
{
}
;
struct
DelayMetadata
{
}
;
using
PendingMetadata
=
ReadBarrieredObject
;
using
NewObjectMetadataState
=
mozilla
:
:
Variant
<
ImmediateMetadata
DelayMetadata
PendingMetadata
>
;
class
MOZ_RAII
AutoSetNewObjectMetadata
:
private
JS
:
:
CustomAutoRooter
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
JSContext
*
cx_
;
NewObjectMetadataState
prevState_
;
AutoSetNewObjectMetadata
(
const
AutoSetNewObjectMetadata
&
aOther
)
=
delete
;
void
operator
=
(
const
AutoSetNewObjectMetadata
&
aOther
)
=
delete
;
protected
:
virtual
void
trace
(
JSTracer
*
trc
)
override
{
if
(
prevState_
.
is
<
PendingMetadata
>
(
)
)
{
TraceRoot
(
trc
prevState_
.
as
<
PendingMetadata
>
(
)
.
unsafeUnbarrieredForTracing
(
)
"
Object
pending
metadata
"
)
;
}
}
public
:
explicit
AutoSetNewObjectMetadata
(
ExclusiveContext
*
ecx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoSetNewObjectMetadata
(
)
;
}
;
}
namespace
js
{
class
DebugScopes
;
class
ObjectWeakMap
;
class
WatchpointMap
;
class
WeakMapBase
;
}
struct
JSCompartment
{
const
JS
:
:
CompartmentCreationOptions
creationOptions_
;
JS
:
:
CompartmentBehaviors
behaviors_
;
private
:
JS
:
:
Zone
*
zone_
;
JSRuntime
*
runtime_
;
public
:
inline
JSPrincipals
*
principals
(
)
{
return
principals_
;
}
inline
void
setPrincipals
(
JSPrincipals
*
principals
)
{
if
(
principals_
=
=
principals
)
return
;
performanceMonitoring
.
unlink
(
)
;
principals_
=
principals
;
}
inline
bool
isSystem
(
)
const
{
return
isSystem_
;
}
inline
void
setIsSystem
(
bool
isSystem
)
{
if
(
isSystem_
=
=
isSystem
)
return
;
performanceMonitoring
.
unlink
(
)
;
isSystem_
=
isSystem
;
}
inline
bool
isProbablySystemOrAddonCode
(
)
const
{
if
(
creationOptions_
.
addonIdOrNull
(
)
)
return
true
;
return
isSystem_
;
}
private
:
JSPrincipals
*
principals_
;
bool
isSystem_
;
public
:
bool
isSelfHosting
;
bool
marked
;
bool
warnedAboutFlagsArgument
;
bool
warnedAboutExprClosure
;
#
ifdef
DEBUG
bool
firedOnNewGlobalObject
;
#
endif
void
mark
(
)
{
marked
=
true
;
}
private
:
friend
struct
JSRuntime
;
friend
struct
JSContext
;
friend
class
js
:
:
ExclusiveContext
;
js
:
:
ReadBarrieredGlobalObject
global_
;
unsigned
enterCompartmentDepth
;
int64_t
startInterval
;
public
:
js
:
:
PerformanceGroupHolder
performanceMonitoring
;
void
enter
(
)
{
enterCompartmentDepth
+
+
;
}
void
leave
(
)
{
enterCompartmentDepth
-
-
;
}
bool
hasBeenEntered
(
)
{
return
!
!
enterCompartmentDepth
;
}
JS
:
:
Zone
*
zone
(
)
{
return
zone_
;
}
const
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
const
JS
:
:
CompartmentCreationOptions
&
creationOptions
(
)
const
{
return
creationOptions_
;
}
JS
:
:
CompartmentBehaviors
&
behaviors
(
)
{
return
behaviors_
;
}
const
JS
:
:
CompartmentBehaviors
&
behaviors
(
)
const
{
return
behaviors_
;
}
JSRuntime
*
runtimeFromMainThread
(
)
const
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
return
runtime_
;
}
inline
js
:
:
GlobalObject
*
maybeGlobal
(
)
const
;
inline
js
:
:
GlobalObject
*
unsafeUnbarrieredMaybeGlobal
(
)
const
;
inline
void
initGlobal
(
js
:
:
GlobalObject
&
global
)
;
public
:
void
*
data
;
private
:
const
js
:
:
AllocationMetadataBuilder
*
allocationMetadataBuilder
;
js
:
:
SavedStacks
savedStacks_
;
js
:
:
WrapperMap
crossCompartmentWrappers
;
public
:
int64_t
lastAnimationTime
;
js
:
:
RegExpCompartment
regExps
;
bool
globalWriteBarriered
;
int32_t
detachedTypedObjects
;
private
:
friend
class
js
:
:
AutoSetNewObjectMetadata
;
js
:
:
NewObjectMetadataState
objectMetadataState
;
public
:
void
chooseAllocationSamplingProbability
(
)
{
savedStacks_
.
chooseSamplingProbability
(
this
)
;
}
bool
hasObjectPendingMetadata
(
)
const
{
return
objectMetadataState
.
is
<
js
:
:
PendingMetadata
>
(
)
;
}
void
setObjectPendingMetadata
(
JSContext
*
cx
JSObject
*
obj
)
{
MOZ_ASSERT
(
objectMetadataState
.
is
<
js
:
:
DelayMetadata
>
(
)
)
;
objectMetadataState
=
js
:
:
NewObjectMetadataState
(
js
:
:
PendingMetadata
(
obj
)
)
;
}
void
setObjectPendingMetadata
(
js
:
:
ExclusiveContext
*
ecx
JSObject
*
obj
)
{
if
(
JSContext
*
cx
=
ecx
-
>
maybeJSContext
(
)
)
setObjectPendingMetadata
(
cx
obj
)
;
}
public
:
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
tiAllocationSiteTables
size_t
*
tiArrayTypeTables
size_t
*
tiObjectTypeTables
size_t
*
compartmentObject
size_t
*
compartmentTables
size_t
*
innerViews
size_t
*
lazyArrayBuffers
size_t
*
objectMetadataTables
size_t
*
crossCompartmentWrappers
size_t
*
regexpCompartment
size_t
*
savedStacksSet
size_t
*
nonSyntacticLexicalScopes
size_t
*
jitCompartment
size_t
*
privateData
)
;
js
:
:
PropertyTree
propertyTree
;
js
:
:
BaseShapeSet
baseShapes
;
void
sweepBaseShapeTable
(
)
;
js
:
:
InitialShapeSet
initialShapes
;
void
sweepInitialShapeTable
(
)
;
js
:
:
ObjectGroupCompartment
objectGroups
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkInitialShapesTableAfterMovingGC
(
)
;
void
checkWrapperMapAfterMovingGC
(
)
;
void
checkBaseShapeTableAfterMovingGC
(
)
;
#
endif
js
:
:
ReadBarrieredScriptSourceObject
selfHostingScriptSource
;
js
:
:
ObjectWeakMap
*
objectMetadataTable
;
js
:
:
InnerViewTable
innerViews
;
js
:
:
ObjectWeakMap
*
lazyArrayBuffers
;
mozilla
:
:
LinkedList
<
js
:
:
UnboxedLayout
>
unboxedLayouts
;
mozilla
:
:
LinkedList
<
js
:
:
wasm
:
:
Module
>
wasmModuleWeakList
;
private
:
js
:
:
ObjectWeakMap
*
nonSyntacticLexicalScopes_
;
public
:
unsigned
gcIndex
;
JSObject
*
gcIncomingGrayPointers
;
private
:
enum
{
IsDebuggee
=
1
<
<
0
DebuggerObservesAllExecution
=
1
<
<
1
DebuggerObservesAsmJS
=
1
<
<
2
DebuggerObservesCoverage
=
1
<
<
3
DebuggerNeedsDelazification
=
1
<
<
4
}
;
unsigned
debugModeBits
;
friend
class
AutoRestoreCompartmentDebugMode
;
static
const
unsigned
DebuggerObservesMask
=
IsDebuggee
|
DebuggerObservesAllExecution
|
DebuggerObservesCoverage
|
DebuggerObservesAsmJS
;
void
updateDebuggerObservesFlag
(
unsigned
flag
)
;
public
:
JSCompartment
(
JS
:
:
Zone
*
zone
const
JS
:
:
CompartmentOptions
&
options
)
;
~
JSCompartment
(
)
;
MOZ_WARN_UNUSED_RESULT
bool
init
(
JSContext
*
maybecx
)
;
MOZ_WARN_UNUSED_RESULT
inline
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleValue
vp
JS
:
:
HandleObject
existing
=
nullptr
)
;
MOZ_WARN_UNUSED_RESULT
bool
wrap
(
JSContext
*
cx
js
:
:
MutableHandleString
strp
)
;
MOZ_WARN_UNUSED_RESULT
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleObject
obj
JS
:
:
HandleObject
existingArg
=
nullptr
)
;
MOZ_WARN_UNUSED_RESULT
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandle
<
js
:
:
PropertyDescriptor
>
desc
)
;
template
<
typename
T
>
MOZ_WARN_UNUSED_RESULT
bool
wrap
(
JSContext
*
cx
JS
:
:
AutoVectorRooter
<
T
>
&
vec
)
{
for
(
size_t
i
=
0
;
i
<
vec
.
length
(
)
;
+
+
i
)
{
if
(
!
wrap
(
cx
vec
[
i
]
)
)
return
false
;
}
return
true
;
}
;
MOZ_WARN_UNUSED_RESULT
bool
putWrapper
(
JSContext
*
cx
const
js
:
:
CrossCompartmentKey
&
wrapped
const
js
:
:
Value
&
wrapper
)
;
js
:
:
WrapperMap
:
:
Ptr
lookupWrapper
(
const
js
:
:
Value
&
wrapped
)
const
{
return
crossCompartmentWrappers
.
lookup
(
js
:
:
CrossCompartmentKey
(
wrapped
)
)
;
}
void
removeWrapper
(
js
:
:
WrapperMap
:
:
Ptr
p
)
{
crossCompartmentWrappers
.
remove
(
p
)
;
}
struct
WrapperEnum
:
public
js
:
:
WrapperMap
:
:
Enum
{
explicit
WrapperEnum
(
JSCompartment
*
c
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
)
{
}
}
;
js
:
:
ClonedBlockObject
*
getOrCreateNonSyntacticLexicalScope
(
JSContext
*
cx
js
:
:
HandleObject
enclosingStatic
js
:
:
HandleObject
enclosingScope
)
;
js
:
:
ClonedBlockObject
*
getNonSyntacticLexicalScope
(
JSObject
*
enclosingScope
)
const
;
void
trace
(
JSTracer
*
trc
)
;
void
traceRoots
(
JSTracer
*
trc
js
:
:
gc
:
:
GCRuntime
:
:
TraceOrMarkRuntime
traceOrMark
)
;
void
traceOutgoingCrossCompartmentWrappers
(
JSTracer
*
trc
)
;
static
void
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
)
;
bool
preserveJitCode
(
)
{
return
creationOptions_
.
preserveJitCode
(
)
;
}
void
sweepAfterMinorGC
(
)
;
void
sweepInnerViews
(
)
;
void
sweepCrossCompartmentWrappers
(
)
;
void
sweepSavedStacks
(
)
;
void
sweepGlobalObject
(
js
:
:
FreeOp
*
fop
)
;
void
sweepObjectPendingMetadata
(
)
;
void
sweepSelfHostingScriptSource
(
)
;
void
sweepJitCompartment
(
js
:
:
FreeOp
*
fop
)
;
void
sweepRegExps
(
)
;
void
sweepDebugScopes
(
)
;
void
sweepNativeIterators
(
)
;
void
sweepTemplateObjects
(
)
;
void
purge
(
)
;
void
clearTables
(
)
;
static
void
fixupCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
;
void
fixupInitialShapeTable
(
)
;
void
fixupAfterMovingGC
(
)
;
void
fixupGlobal
(
)
;
bool
hasAllocationMetadataBuilder
(
)
const
{
return
allocationMetadataBuilder
;
}
const
js
:
:
AllocationMetadataBuilder
*
getAllocationMetadataBuilder
(
)
const
{
return
allocationMetadataBuilder
;
}
void
setAllocationMetadataBuilder
(
const
js
:
:
AllocationMetadataBuilder
*
builder
)
;
void
forgetAllocationMetadataBuilder
(
)
{
allocationMetadataBuilder
=
nullptr
;
}
void
setNewObjectMetadata
(
JSContext
*
cx
JS
:
:
HandleObject
obj
)
;
void
clearObjectMetadata
(
)
;
const
void
*
addressOfMetadataBuilder
(
)
const
{
return
&
allocationMetadataBuilder
;
}
js
:
:
SavedStacks
&
savedStacks
(
)
{
return
savedStacks_
;
}
void
findOutgoingEdges
(
js
:
:
gc
:
:
ComponentFinder
<
JS
:
:
Zone
>
&
finder
)
;
js
:
:
DtoaCache
dtoaCache
;
mozilla
:
:
Maybe
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
randomNumberGenerator
;
void
ensureRandomNumberGenerator
(
)
;
static
size_t
offsetOfRegExps
(
)
{
return
offsetof
(
JSCompartment
regExps
)
;
}
private
:
JSCompartment
*
thisForCtor
(
)
{
return
this
;
}
public
:
bool
isDebuggee
(
)
const
{
return
!
!
(
debugModeBits
&
IsDebuggee
)
;
}
void
setIsDebuggee
(
)
{
debugModeBits
|
=
IsDebuggee
;
}
void
unsetIsDebuggee
(
)
;
bool
debuggerObservesAllExecution
(
)
const
{
static
const
unsigned
Mask
=
IsDebuggee
|
DebuggerObservesAllExecution
;
return
(
debugModeBits
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesAllExecution
(
)
{
updateDebuggerObservesFlag
(
DebuggerObservesAllExecution
)
;
}
bool
debuggerObservesAsmJS
(
)
const
{
static
const
unsigned
Mask
=
IsDebuggee
|
DebuggerObservesAsmJS
;
return
(
debugModeBits
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesAsmJS
(
)
{
updateDebuggerObservesFlag
(
DebuggerObservesAsmJS
)
;
}
bool
debuggerObservesCoverage
(
)
const
{
static
const
unsigned
Mask
=
DebuggerObservesCoverage
;
return
(
debugModeBits
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesCoverage
(
)
;
bool
collectCoverage
(
)
const
;
void
clearScriptCounts
(
)
;
bool
needsDelazificationForDebugger
(
)
const
{
return
debugModeBits
&
DebuggerNeedsDelazification
;
}
void
scheduleDelazificationForDebugger
(
)
{
debugModeBits
|
=
DebuggerNeedsDelazification
;
}
bool
ensureDelazifyScriptsForDebugger
(
JSContext
*
cx
)
;
void
clearBreakpointsIn
(
js
:
:
FreeOp
*
fop
js
:
:
Debugger
*
dbg
JS
:
:
HandleObject
handler
)
;
private
:
void
sweepBreakpoints
(
js
:
:
FreeOp
*
fop
)
;
public
:
js
:
:
WatchpointMap
*
watchpointMap
;
js
:
:
ScriptCountsMap
*
scriptCountsMap
;
js
:
:
DebugScriptMap
*
debugScriptMap
;
js
:
:
DebugScopes
*
debugScopes
;
js
:
:
NativeIterator
*
enumerators
;
void
*
compartmentStats
;
bool
scheduledForDestruction
;
bool
maybeAlive
;
private
:
js
:
:
jit
:
:
JitCompartment
*
jitCompartment_
;
js
:
:
ReadBarriered
<
js
:
:
ArgumentsObject
*
>
mappedArgumentsTemplate_
;
js
:
:
ReadBarriered
<
js
:
:
ArgumentsObject
*
>
unmappedArgumentsTemplate_
;
public
:
bool
ensureJitCompartmentExists
(
JSContext
*
cx
)
;
js
:
:
jit
:
:
JitCompartment
*
jitCompartment
(
)
{
return
jitCompartment_
;
}
enum
DeprecatedLanguageExtension
{
DeprecatedForEach
=
0
DeprecatedLegacyGenerator
=
2
DeprecatedExpressionClosure
=
3
DeprecatedFlagsArgument
=
7
DeprecatedBlockScopeFunRedecl
=
10
DeprecatedLanguageExtensionCount
}
;
js
:
:
ArgumentsObject
*
getOrCreateArgumentsTemplateObject
(
JSContext
*
cx
bool
mapped
)
;
private
:
bool
sawDeprecatedLanguageExtension
[
DeprecatedLanguageExtensionCount
]
;
void
reportTelemetry
(
)
;
public
:
void
addTelemetry
(
const
char
*
filename
DeprecatedLanguageExtension
e
)
;
public
:
js
:
:
coverage
:
:
LCovCompartment
lcovOutput
;
}
;
inline
bool
JSRuntime
:
:
isAtomsZone
(
const
JS
:
:
Zone
*
zone
)
const
{
return
zone
=
=
atomsCompartment_
-
>
zone
(
)
;
}
namespace
js
{
template
<
typename
T
>
inline
void
SetMaybeAliveFlag
(
T
*
thing
)
{
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSObject
*
thing
)
{
thing
-
>
compartment
(
)
-
>
maybeAlive
=
true
;
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSScript
*
thing
)
{
thing
-
>
compartment
(
)
-
>
maybeAlive
=
true
;
}
inline
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
ExclusiveContext
:
:
global
(
)
const
{
MOZ_ASSERT
(
compartment_
"
Caller
needs
to
enter
a
compartment
first
"
)
;
return
Handle
<
GlobalObject
*
>
:
:
fromMarkedLocation
(
compartment_
-
>
global_
.
unsafeGet
(
)
)
;
}
class
MOZ_RAII
AssertCompartmentUnchanged
{
public
:
explicit
AssertCompartmentUnchanged
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
cx
(
cx
)
oldCompartment
(
cx
-
>
compartment
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AssertCompartmentUnchanged
(
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
oldCompartment
)
;
}
protected
:
JSContext
*
const
cx
;
JSCompartment
*
const
oldCompartment
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
AutoCompartment
{
ExclusiveContext
*
const
cx_
;
JSCompartment
*
const
origin_
;
public
:
inline
AutoCompartment
(
ExclusiveContext
*
cx
JSObject
*
target
)
;
inline
AutoCompartment
(
ExclusiveContext
*
cx
JSCompartment
*
target
)
;
inline
~
AutoCompartment
(
)
;
ExclusiveContext
*
context
(
)
const
{
return
cx_
;
}
JSCompartment
*
origin
(
)
const
{
return
origin_
;
}
private
:
AutoCompartment
(
const
AutoCompartment
&
)
=
delete
;
AutoCompartment
&
operator
=
(
const
AutoCompartment
&
)
=
delete
;
}
;
class
ErrorCopier
{
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
;
public
:
explicit
ErrorCopier
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
)
:
ac
(
ac
)
{
}
~
ErrorCopier
(
)
;
}
;
struct
WrapperValue
{
explicit
WrapperValue
(
const
WrapperMap
:
:
Ptr
&
ptr
)
:
value
(
*
ptr
-
>
value
(
)
.
unsafeGet
(
)
)
{
}
explicit
WrapperValue
(
const
WrapperMap
:
:
Enum
&
e
)
:
value
(
*
e
.
front
(
)
.
value
(
)
.
unsafeGet
(
)
)
{
}
Value
&
get
(
)
{
return
value
;
}
Value
get
(
)
const
{
return
value
;
}
operator
const
Value
&
(
)
const
{
return
value
;
}
JSObject
&
toObject
(
)
const
{
return
value
.
toObject
(
)
;
}
private
:
Value
value
;
}
;
class
MOZ_RAII
AutoWrapperVector
:
public
JS
:
:
AutoVectorRooterBase
<
WrapperValue
>
{
public
:
explicit
AutoWrapperVector
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
AutoVectorRooterBase
<
WrapperValue
>
(
cx
WRAPVECTOR
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoWrapperRooter
:
private
JS
:
:
AutoGCRooter
{
public
:
AutoWrapperRooter
(
JSContext
*
cx
WrapperValue
v
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
AutoGCRooter
(
cx
WRAPPER
)
value
(
v
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
operator
JSObject
*
(
)
const
{
return
value
.
get
(
)
.
toObjectOrNull
(
)
;
}
friend
void
JS
:
:
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
private
:
WrapperValue
value
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoSuppressAllocationMetadataBuilder
{
JS
:
:
Zone
*
zone
;
bool
saved
;
public
:
explicit
AutoSuppressAllocationMetadataBuilder
(
ExclusiveContext
*
cx
)
:
AutoSuppressAllocationMetadataBuilder
(
cx
-
>
compartment
(
)
-
>
zone
(
)
)
{
}
explicit
AutoSuppressAllocationMetadataBuilder
(
JS
:
:
Zone
*
zone
)
:
zone
(
zone
)
saved
(
zone
-
>
suppressAllocationMetadataBuilder
)
{
zone
-
>
suppressAllocationMetadataBuilder
=
true
;
}
~
AutoSuppressAllocationMetadataBuilder
(
)
{
zone
-
>
suppressAllocationMetadataBuilder
=
saved
;
}
}
;
}
#
endif
