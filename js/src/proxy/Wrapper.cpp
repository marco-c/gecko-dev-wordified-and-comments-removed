#
include
"
jscntxt
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
jsobjinlines
.
h
"
using
namespace
js
;
JSObject
*
Wrapper
:
:
New
(
JSContext
*
cx
JSObject
*
obj
const
Wrapper
*
handler
const
WrapperOptions
&
options
)
{
RootedValue
priv
(
cx
ObjectValue
(
*
obj
)
)
;
return
NewProxyObject
(
cx
handler
priv
options
.
proto
(
)
options
)
;
}
JSObject
*
Wrapper
:
:
Renew
(
JSContext
*
cx
JSObject
*
existing
JSObject
*
obj
const
Wrapper
*
handler
)
{
existing
-
>
as
<
ProxyObject
>
(
)
.
renew
(
cx
handler
ObjectValue
(
*
obj
)
)
;
return
existing
;
}
const
Wrapper
*
Wrapper
:
:
wrapperHandler
(
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
-
>
is
<
WrapperObject
>
(
)
)
;
return
static_cast
<
const
Wrapper
*
>
(
wrapper
-
>
as
<
ProxyObject
>
(
)
.
handler
(
)
)
;
}
JSObject
*
Wrapper
:
:
wrappedObject
(
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
-
>
is
<
WrapperObject
>
(
)
)
;
return
wrapper
-
>
as
<
ProxyObject
>
(
)
.
target
(
)
;
}
bool
Wrapper
:
:
isConstructor
(
JSObject
*
obj
)
const
{
return
isCallable
(
obj
)
;
}
JS_FRIEND_API
(
JSObject
*
)
js
:
:
UncheckedUnwrap
(
JSObject
*
wrapped
bool
stopAtWindowProxy
unsigned
*
flagsp
)
{
unsigned
flags
=
0
;
while
(
true
)
{
if
(
!
wrapped
-
>
is
<
WrapperObject
>
(
)
|
|
MOZ_UNLIKELY
(
stopAtWindowProxy
&
&
IsWindowProxy
(
wrapped
)
)
)
{
break
;
}
flags
|
=
Wrapper
:
:
wrapperHandler
(
wrapped
)
-
>
flags
(
)
;
wrapped
=
wrapped
-
>
as
<
ProxyObject
>
(
)
.
private_
(
)
.
toObjectOrNull
(
)
;
if
(
wrapped
)
wrapped
=
MaybeForwarded
(
wrapped
)
;
}
if
(
flagsp
)
*
flagsp
=
flags
;
return
wrapped
;
}
JS_FRIEND_API
(
JSObject
*
)
js
:
:
CheckedUnwrap
(
JSObject
*
obj
bool
stopAtWindowProxy
)
{
while
(
true
)
{
JSObject
*
wrapper
=
obj
;
obj
=
UnwrapOneChecked
(
obj
stopAtWindowProxy
)
;
if
(
!
obj
|
|
obj
=
=
wrapper
)
return
obj
;
}
}
JS_FRIEND_API
(
JSObject
*
)
js
:
:
UnwrapOneChecked
(
JSObject
*
obj
bool
stopAtWindowProxy
)
{
if
(
!
obj
-
>
is
<
WrapperObject
>
(
)
|
|
MOZ_UNLIKELY
(
IsWindowProxy
(
obj
)
&
&
stopAtWindowProxy
)
)
{
return
obj
;
}
const
Wrapper
*
handler
=
Wrapper
:
:
wrapperHandler
(
obj
)
;
return
handler
-
>
hasSecurityPolicy
(
)
?
nullptr
:
Wrapper
:
:
wrappedObject
(
obj
)
;
}
const
char
Wrapper
:
:
family
=
0
;
const
Wrapper
Wrapper
:
:
singleton
(
(
unsigned
)
0
)
;
const
Wrapper
Wrapper
:
:
singletonWithPrototype
(
(
unsigned
)
0
true
)
;
JSObject
*
Wrapper
:
:
defaultProto
=
TaggedProto
:
:
LazyProto
;
extern
JSObject
*
js
:
:
TransparentObjectWrapper
(
JSContext
*
cx
HandleObject
existing
HandleObject
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
WrapperObject
>
(
)
|
|
IsWindowProxy
(
obj
)
)
;
return
Wrapper
:
:
New
(
cx
obj
&
CrossCompartmentWrapper
:
:
singleton
)
;
}
ErrorCopier
:
:
~
ErrorCopier
(
)
{
JSContext
*
cx
=
ac
-
>
context
(
)
-
>
asJSContext
(
)
;
if
(
ac
-
>
origin
(
)
!
=
cx
-
>
compartment
(
)
&
&
cx
-
>
isExceptionPending
(
)
&
&
!
cx
-
>
isThrowingDebuggeeWouldRun
(
)
)
{
RootedValue
exc
(
cx
)
;
if
(
cx
-
>
getPendingException
(
&
exc
)
&
&
exc
.
isObject
(
)
&
&
exc
.
toObject
(
)
.
is
<
ErrorObject
>
(
)
)
{
cx
-
>
clearPendingException
(
)
;
ac
.
reset
(
)
;
Rooted
<
ErrorObject
*
>
errObj
(
cx
&
exc
.
toObject
(
)
.
as
<
ErrorObject
>
(
)
)
;
JSObject
*
copyobj
=
CopyErrorObject
(
cx
errObj
)
;
if
(
copyobj
)
cx
-
>
setPendingException
(
ObjectValue
(
*
copyobj
)
)
;
}
}
}
bool
Wrapper
:
:
finalizeInBackground
(
Value
priv
)
const
{
if
(
!
priv
.
isObject
(
)
)
return
true
;
if
(
IsInsideNursery
(
&
priv
.
toObject
(
)
)
)
return
true
;
return
IsBackgroundFinalized
(
priv
.
toObject
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
