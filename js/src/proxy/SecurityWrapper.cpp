#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
enter
(
JSContext
*
cx
HandleObject
wrapper
HandleId
id
Wrapper
:
:
Action
act
bool
mayThrow
bool
*
bp
)
const
{
ReportAccessDenied
(
cx
)
;
*
bp
=
false
;
return
false
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
nativeCall
(
JSContext
*
cx
IsAcceptableThis
test
NativeImpl
impl
const
CallArgs
&
args
)
const
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
setPrototype
(
JSContext
*
cx
HandleObject
wrapper
HandleObject
proto
ObjectOpResult
&
result
)
const
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
setImmutablePrototype
(
JSContext
*
cx
HandleObject
wrapper
bool
*
succeeded
)
const
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
preventExtensions
(
JSContext
*
cx
HandleObject
wrapper
ObjectOpResult
&
result
)
const
{
return
result
.
fail
(
JSMSG_CANT_CHANGE_EXTENSIBILITY
)
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
isExtensible
(
JSContext
*
cx
HandleObject
wrapper
bool
*
extensible
)
const
{
*
extensible
=
true
;
return
true
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
getBuiltinClass
(
JSContext
*
cx
HandleObject
wrapper
ESClass
*
cls
)
const
{
*
cls
=
ESClass
:
:
Other
;
return
true
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
isArray
(
JSContext
*
cx
HandleObject
obj
JS
:
:
IsArrayAnswer
*
answer
)
const
{
*
answer
=
JS
:
:
IsArrayAnswer
:
:
NotArray
;
return
true
;
}
template
<
class
Base
>
RegExpShared
*
SecurityWrapper
<
Base
>
:
:
regexp_toShared
(
JSContext
*
cx
HandleObject
obj
)
const
{
return
Base
:
:
regexp_toShared
(
cx
obj
)
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
boxedValue_unbox
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
vp
)
const
{
vp
.
setUndefined
(
)
;
return
true
;
}
template
<
class
Base
>
bool
SecurityWrapper
<
Base
>
:
:
defineProperty
(
JSContext
*
cx
HandleObject
wrapper
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
const
{
if
(
desc
.
isAccessorDescriptor
(
)
)
{
return
Throw
(
cx
id
JSMSG_ACCESSOR_DEF_DENIED
)
;
}
return
Base
:
:
defineProperty
(
cx
wrapper
id
desc
result
)
;
}
template
class
js
:
:
SecurityWrapper
<
Wrapper
>
;
template
class
js
:
:
SecurityWrapper
<
CrossCompartmentWrapper
>
;
