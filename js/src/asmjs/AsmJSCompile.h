#
ifndef
jit_AsmJSCompile_h
#
define
jit_AsmJSCompile_h
#
include
"
jit
/
CompileWrappers
.
h
"
namespace
js
{
class
AsmFunction
;
class
LifoAlloc
;
class
ModuleCompiler
;
class
ModuleCompileResults
;
namespace
jit
{
class
LIRGraph
;
class
MIRGenerator
;
}
struct
ModuleCompileInputs
{
jit
:
:
CompileCompartment
*
compartment
;
jit
:
:
CompileRuntime
*
runtime
;
bool
usesSignalHandlersForOOB
;
ModuleCompileInputs
(
jit
:
:
CompileCompartment
*
compartment
jit
:
:
CompileRuntime
*
runtime
bool
usesSignalHandlersForOOB
)
:
compartment
(
compartment
)
runtime
(
runtime
)
usesSignalHandlersForOOB
(
usesSignalHandlersForOOB
)
{
}
}
;
class
MOZ_RAII
AsmModuleCompilerScope
{
ModuleCompiler
*
m_
;
AsmModuleCompilerScope
(
const
AsmModuleCompilerScope
&
)
=
delete
;
AsmModuleCompilerScope
(
const
AsmModuleCompilerScope
&
&
)
=
delete
;
AsmModuleCompilerScope
&
operator
=
(
const
AsmModuleCompilerScope
&
&
)
=
delete
;
public
:
AsmModuleCompilerScope
(
)
:
m_
(
nullptr
)
{
}
void
setModule
(
ModuleCompiler
*
m
)
{
MOZ_ASSERT
(
m
)
;
m_
=
m
;
}
ModuleCompiler
&
module
(
)
const
{
MOZ_ASSERT
(
m_
)
;
return
*
m_
;
}
~
AsmModuleCompilerScope
(
)
;
}
;
bool
CreateAsmModuleCompiler
(
ModuleCompileInputs
mci
AsmModuleCompilerScope
*
scope
)
;
bool
GenerateAsmFunctionMIR
(
ModuleCompiler
&
m
LifoAlloc
&
lifo
AsmFunction
&
func
jit
:
:
MIRGenerator
*
*
mir
)
;
bool
GenerateAsmFunctionCode
(
ModuleCompiler
&
m
AsmFunction
&
func
jit
:
:
MIRGenerator
&
mir
jit
:
:
LIRGraph
&
lir
)
;
void
FinishAsmModuleCompilation
(
ModuleCompiler
&
m
ScopedJSDeletePtr
<
ModuleCompileResults
>
*
results
)
;
}
#
endif
