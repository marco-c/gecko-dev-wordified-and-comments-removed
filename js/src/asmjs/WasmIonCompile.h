#
ifndef
wasm_ion_compile_h
#
define
wasm_ion_compile_h
#
include
"
asmjs
/
WasmBinary
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
namespace
js
{
namespace
wasm
{
struct
ModuleGeneratorData
;
typedef
Vector
<
jit
:
:
MIRType
8
SystemAllocPolicy
>
MIRTypeVector
;
typedef
jit
:
:
ABIArgIter
<
MIRTypeVector
>
ABIArgMIRTypeIter
;
typedef
jit
:
:
ABIArgIter
<
ValTypeVector
>
ABIArgValTypeIter
;
class
FuncBytes
{
Bytes
bytes_
;
uint32_t
index_
;
const
SigWithId
&
sig_
;
uint32_t
lineOrBytecode_
;
Uint32Vector
callSiteLineNums_
;
public
:
FuncBytes
(
Bytes
&
&
bytes
uint32_t
index
const
SigWithId
&
sig
uint32_t
lineOrBytecode
Uint32Vector
&
&
callSiteLineNums
)
:
bytes_
(
Move
(
bytes
)
)
index_
(
index
)
sig_
(
sig
)
lineOrBytecode_
(
lineOrBytecode
)
callSiteLineNums_
(
Move
(
callSiteLineNums
)
)
{
}
Bytes
&
bytes
(
)
{
return
bytes_
;
}
const
Bytes
&
bytes
(
)
const
{
return
bytes_
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
const
SigWithId
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
const
Uint32Vector
&
callSiteLineNums
(
)
const
{
return
callSiteLineNums_
;
}
}
;
typedef
UniquePtr
<
FuncBytes
>
UniqueFuncBytes
;
class
FuncCompileResults
{
jit
:
:
TempAllocator
alloc_
;
jit
:
:
MacroAssembler
masm_
;
FuncOffsets
offsets_
;
FuncCompileResults
(
const
FuncCompileResults
&
)
=
delete
;
FuncCompileResults
&
operator
=
(
const
FuncCompileResults
&
)
=
delete
;
public
:
explicit
FuncCompileResults
(
LifoAlloc
&
lifo
)
:
alloc_
(
&
lifo
)
masm_
(
jit
:
:
MacroAssembler
:
:
AsmJSToken
(
)
alloc_
)
{
}
jit
:
:
TempAllocator
&
alloc
(
)
{
return
alloc_
;
}
jit
:
:
MacroAssembler
&
masm
(
)
{
return
masm_
;
}
FuncOffsets
&
offsets
(
)
{
return
offsets_
;
}
}
;
class
IonCompileTask
{
public
:
enum
class
CompileMode
{
None
Baseline
Ion
}
;
private
:
const
ModuleGeneratorData
&
mg_
;
LifoAlloc
lifo_
;
UniqueFuncBytes
func_
;
CompileMode
mode_
;
Maybe
<
FuncCompileResults
>
results_
;
IonCompileTask
(
const
IonCompileTask
&
)
=
delete
;
IonCompileTask
&
operator
=
(
const
IonCompileTask
&
)
=
delete
;
public
:
IonCompileTask
(
const
ModuleGeneratorData
&
mg
size_t
defaultChunkSize
)
:
mg_
(
mg
)
lifo_
(
defaultChunkSize
)
func_
(
nullptr
)
mode_
(
CompileMode
:
:
None
)
{
}
LifoAlloc
&
lifo
(
)
{
return
lifo_
;
}
const
ModuleGeneratorData
&
mg
(
)
const
{
return
mg_
;
}
void
init
(
UniqueFuncBytes
func
CompileMode
mode
)
{
MOZ_ASSERT
(
!
func_
)
;
func_
=
Move
(
func
)
;
results_
.
emplace
(
lifo_
)
;
mode_
=
mode
;
}
CompileMode
mode
(
)
const
{
return
mode_
;
}
const
FuncBytes
&
func
(
)
const
{
MOZ_ASSERT
(
func_
)
;
return
*
func_
;
}
FuncCompileResults
&
results
(
)
{
return
*
results_
;
}
void
reset
(
Bytes
*
recycled
)
{
if
(
func_
)
*
recycled
=
Move
(
func_
-
>
bytes
(
)
)
;
func_
.
reset
(
nullptr
)
;
results_
.
reset
(
)
;
lifo_
.
releaseAll
(
)
;
mode_
=
CompileMode
:
:
None
;
}
}
;
MOZ_MUST_USE
bool
IonCompileFunction
(
IonCompileTask
*
task
)
;
bool
CompileFunction
(
IonCompileTask
*
task
)
;
}
}
#
endif
