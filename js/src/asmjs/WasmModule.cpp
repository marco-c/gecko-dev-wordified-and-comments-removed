#
include
"
asmjs
/
WasmModule
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
asmjs
/
WasmInstance
.
h
"
#
include
"
asmjs
/
WasmJS
.
h
"
#
include
"
asmjs
/
WasmSerialize
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
wasm
;
#
if
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
LinkData
:
:
InternalLink
:
:
InternalLink
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
=
=
CodeLabel
|
|
kind
=
=
InstructionImmediate
)
;
}
bool
LinkData
:
:
InternalLink
:
:
isRawPointerPatch
(
)
{
return
false
;
}
#
else
LinkData
:
:
InternalLink
:
:
InternalLink
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
=
=
CodeLabel
|
|
kind
=
=
RawPointer
)
;
}
bool
LinkData
:
:
InternalLink
:
:
isRawPointerPatch
(
)
{
return
true
;
}
#
endif
size_t
LinkData
:
:
SymbolicLinkArray
:
:
serializedSize
(
)
const
{
size_t
size
=
0
;
for
(
const
Uint32Vector
&
offsets
:
*
this
)
size
+
=
SerializedPodVectorSize
(
offsets
)
;
return
size
;
}
uint8_t
*
LinkData
:
:
SymbolicLinkArray
:
:
serialize
(
uint8_t
*
cursor
)
const
{
for
(
const
Uint32Vector
&
offsets
:
*
this
)
cursor
=
SerializePodVector
(
cursor
offsets
)
;
return
cursor
;
}
const
uint8_t
*
LinkData
:
:
SymbolicLinkArray
:
:
deserialize
(
const
uint8_t
*
cursor
)
{
for
(
Uint32Vector
&
offsets
:
*
this
)
{
cursor
=
DeserializePodVector
(
cursor
&
offsets
)
;
if
(
!
cursor
)
return
nullptr
;
}
return
cursor
;
}
size_t
LinkData
:
:
SymbolicLinkArray
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
for
(
const
Uint32Vector
&
offsets
:
*
this
)
size
+
=
offsets
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
return
size
;
}
size_t
LinkData
:
:
FuncTable
:
:
serializedSize
(
)
const
{
return
sizeof
(
globalDataOffset
)
+
SerializedPodVectorSize
(
elemOffsets
)
;
}
uint8_t
*
LinkData
:
:
FuncTable
:
:
serialize
(
uint8_t
*
cursor
)
const
{
cursor
=
WriteBytes
(
cursor
&
globalDataOffset
sizeof
(
globalDataOffset
)
)
;
cursor
=
SerializePodVector
(
cursor
elemOffsets
)
;
return
cursor
;
}
const
uint8_t
*
LinkData
:
:
FuncTable
:
:
deserialize
(
const
uint8_t
*
cursor
)
{
(
cursor
=
ReadBytes
(
cursor
&
globalDataOffset
sizeof
(
globalDataOffset
)
)
)
&
&
(
cursor
=
DeserializePodVector
(
cursor
&
elemOffsets
)
)
;
return
cursor
;
}
size_t
LinkData
:
:
FuncTable
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
elemOffsets
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
LinkData
:
:
serializedSize
(
)
const
{
return
sizeof
(
pod
(
)
)
+
SerializedPodVectorSize
(
internalLinks
)
+
symbolicLinks
.
serializedSize
(
)
+
SerializedVectorSize
(
funcTables
)
;
}
uint8_t
*
LinkData
:
:
serialize
(
uint8_t
*
cursor
)
const
{
cursor
=
WriteBytes
(
cursor
&
pod
(
)
sizeof
(
pod
(
)
)
)
;
cursor
=
SerializePodVector
(
cursor
internalLinks
)
;
cursor
=
symbolicLinks
.
serialize
(
cursor
)
;
cursor
=
SerializeVector
(
cursor
funcTables
)
;
return
cursor
;
}
const
uint8_t
*
LinkData
:
:
deserialize
(
const
uint8_t
*
cursor
)
{
(
cursor
=
ReadBytes
(
cursor
&
pod
(
)
sizeof
(
pod
(
)
)
)
)
&
&
(
cursor
=
DeserializePodVector
(
cursor
&
internalLinks
)
)
&
&
(
cursor
=
symbolicLinks
.
deserialize
(
cursor
)
)
&
&
(
cursor
=
DeserializeVector
(
cursor
&
funcTables
)
)
;
return
cursor
;
}
size_t
LinkData
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
internalLinks
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
symbolicLinks
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
SizeOfVectorExcludingThis
(
funcTables
mallocSizeOf
)
;
}
size_t
ImportName
:
:
serializedSize
(
)
const
{
return
module
.
serializedSize
(
)
+
func
.
serializedSize
(
)
;
}
uint8_t
*
ImportName
:
:
serialize
(
uint8_t
*
cursor
)
const
{
cursor
=
module
.
serialize
(
cursor
)
;
cursor
=
func
.
serialize
(
cursor
)
;
return
cursor
;
}
const
uint8_t
*
ImportName
:
:
deserialize
(
const
uint8_t
*
cursor
)
{
(
cursor
=
module
.
deserialize
(
cursor
)
)
&
&
(
cursor
=
func
.
deserialize
(
cursor
)
)
;
return
cursor
;
}
size_t
ImportName
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
module
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
func
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
ExportMap
:
:
serializedSize
(
)
const
{
return
SerializedVectorSize
(
fieldNames
)
+
SerializedPodVectorSize
(
fieldsToExports
)
;
}
uint8_t
*
ExportMap
:
:
serialize
(
uint8_t
*
cursor
)
const
{
cursor
=
SerializeVector
(
cursor
fieldNames
)
;
cursor
=
SerializePodVector
(
cursor
fieldsToExports
)
;
return
cursor
;
}
const
uint8_t
*
ExportMap
:
:
deserialize
(
const
uint8_t
*
cursor
)
{
(
cursor
=
DeserializeVector
(
cursor
&
fieldNames
)
)
&
&
(
cursor
=
DeserializePodVector
(
cursor
&
fieldsToExports
)
)
;
return
cursor
;
}
size_t
ExportMap
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
SizeOfVectorExcludingThis
(
fieldNames
mallocSizeOf
)
&
&
fieldsToExports
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
Module
:
:
serializedSize
(
)
const
{
return
SerializedPodVectorSize
(
code_
)
+
linkData_
.
serializedSize
(
)
+
SerializedVectorSize
(
importNames_
)
+
exportMap_
.
serializedSize
(
)
+
SerializedPodVectorSize
(
dataSegments_
)
+
metadata_
-
>
serializedSize
(
)
+
SerializedPodVectorSize
(
bytecode_
-
>
bytes
)
;
}
uint8_t
*
Module
:
:
serialize
(
uint8_t
*
cursor
)
const
{
cursor
=
SerializePodVector
(
cursor
code_
)
;
cursor
=
linkData_
.
serialize
(
cursor
)
;
cursor
=
SerializeVector
(
cursor
importNames_
)
;
cursor
=
exportMap_
.
serialize
(
cursor
)
;
cursor
=
SerializePodVector
(
cursor
dataSegments_
)
;
cursor
=
metadata_
-
>
serialize
(
cursor
)
;
cursor
=
SerializePodVector
(
cursor
bytecode_
-
>
bytes
)
;
return
cursor
;
}
const
uint8_t
*
Module
:
:
deserialize
(
const
uint8_t
*
cursor
UniquePtr
<
Module
>
*
module
Metadata
*
maybeMetadata
)
{
Bytes
code
;
cursor
=
DeserializePodVector
(
cursor
&
code
)
;
if
(
!
cursor
)
return
nullptr
;
LinkData
linkData
;
cursor
=
linkData
.
deserialize
(
cursor
)
;
if
(
!
cursor
)
return
nullptr
;
ImportNameVector
importNames
;
cursor
=
DeserializeVector
(
cursor
&
importNames
)
;
if
(
!
cursor
)
return
nullptr
;
ExportMap
exportMap
;
cursor
=
exportMap
.
deserialize
(
cursor
)
;
if
(
!
cursor
)
return
nullptr
;
DataSegmentVector
dataSegments
;
cursor
=
DeserializePodVector
(
cursor
&
dataSegments
)
;
if
(
!
cursor
)
return
nullptr
;
MutableMetadata
metadata
;
if
(
maybeMetadata
)
{
metadata
=
maybeMetadata
;
}
else
{
metadata
=
js_new
<
Metadata
>
(
)
;
if
(
!
metadata
)
return
nullptr
;
}
cursor
=
metadata
-
>
deserialize
(
cursor
)
;
if
(
!
cursor
)
return
nullptr
;
MOZ_RELEASE_ASSERT
(
!
!
maybeMetadata
=
=
metadata
-
>
isAsmJS
(
)
)
;
MutableBytes
bytecode
=
js_new
<
ShareableBytes
>
(
)
;
if
(
!
bytecode
)
return
nullptr
;
cursor
=
DeserializePodVector
(
cursor
&
bytecode
-
>
bytes
)
;
if
(
!
cursor
)
return
nullptr
;
*
module
=
js
:
:
MakeUnique
<
Module
>
(
Move
(
code
)
Move
(
linkData
)
Move
(
importNames
)
Move
(
exportMap
)
Move
(
dataSegments
)
*
metadata
*
bytecode
)
;
if
(
!
*
module
)
return
nullptr
;
return
cursor
;
}
void
Module
:
:
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
ShareableBytes
:
:
SeenSet
*
seenBytes
size_t
*
code
size_t
*
data
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
+
code_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
linkData_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
importNames_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
exportMap_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
dataSegments_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
metadata_
-
>
sizeOfIncludingThisIfNotSeen
(
mallocSizeOf
seenMetadata
)
+
bytecode_
-
>
sizeOfIncludingThisIfNotSeen
(
mallocSizeOf
seenBytes
)
;
}
bool
Module
:
:
instantiate
(
JSContext
*
cx
Handle
<
FunctionVector
>
funcImports
Handle
<
ArrayBufferObjectMaybeShared
*
>
asmJSHeap
HandleWasmInstanceObject
instanceObj
)
const
{
MOZ_ASSERT
(
funcImports
.
length
(
)
=
=
metadata_
-
>
imports
.
length
(
)
)
;
MOZ_ASSERT_IF
(
asmJSHeap
metadata_
-
>
isAsmJS
(
)
)
;
Rooted
<
ArrayBufferObjectMaybeShared
*
>
heap
(
cx
asmJSHeap
)
;
if
(
metadata_
-
>
usesHeap
(
)
&
&
!
heap
)
{
MOZ_ASSERT
(
!
metadata_
-
>
isAsmJS
(
)
)
;
heap
=
ArrayBufferObject
:
:
createForWasm
(
cx
metadata_
-
>
initialHeapLength
metadata_
-
>
usesSignal
.
forOOB
)
;
if
(
!
heap
)
return
false
;
}
uint8_t
*
memoryBase
=
heap
?
heap
-
>
dataPointerEither
(
)
.
unwrap
(
)
:
nullptr
;
uint32_t
memoryLength
=
heap
?
heap
-
>
byteLength
(
)
:
0
;
const
uint8_t
*
bytecode
=
bytecode_
-
>
begin
(
)
;
for
(
const
DataSegment
&
seg
:
dataSegments_
)
memcpy
(
memoryBase
+
seg
.
memoryOffset
bytecode
+
seg
.
bytecodeOffset
seg
.
length
)
;
auto
cs
=
CodeSegment
:
:
create
(
cx
code_
linkData_
*
metadata_
memoryBase
memoryLength
)
;
if
(
!
cs
)
return
false
;
const
ShareableBytes
*
maybeBytecode
=
nullptr
;
if
(
cx
-
>
compartment
(
)
-
>
isDebuggee
(
)
|
|
!
metadata_
-
>
funcNames
.
empty
(
)
)
maybeBytecode
=
bytecode_
.
get
(
)
;
TypedFuncTableVector
typedFuncTables
;
if
(
metadata_
-
>
isAsmJS
(
)
)
{
if
(
!
typedFuncTables
.
reserve
(
linkData_
.
funcTables
.
length
(
)
)
)
return
false
;
for
(
const
LinkData
:
:
FuncTable
&
tbl
:
linkData_
.
funcTables
)
typedFuncTables
.
infallibleEmplaceBack
(
tbl
.
globalDataOffset
tbl
.
elemOffsets
.
length
(
)
)
;
}
return
Instance
:
:
create
(
cx
Move
(
cs
)
*
metadata_
maybeBytecode
Move
(
typedFuncTables
)
heap
funcImports
exportMap_
instanceObj
)
;
}
