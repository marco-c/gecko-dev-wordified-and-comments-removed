#
include
"
asmjs
/
WasmStubs
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
asmjs
/
AsmJSModule
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
ArrayLength
;
typedef
Vector
<
MIRType
8
SystemAllocPolicy
>
MIRTypeVector
;
typedef
ABIArgIter
<
MIRTypeVector
>
ABIArgMIRTypeIter
;
typedef
ABIArgIter
<
MallocSig
:
:
ArgVector
>
ABIArgValTypeIter
;
static
void
AssertStackAlignment
(
MacroAssembler
&
masm
uint32_t
alignment
uint32_t
addBeforeAssert
=
0
)
{
MOZ_ASSERT
(
(
sizeof
(
AsmJSFrame
)
+
masm
.
framePushed
(
)
+
addBeforeAssert
)
%
alignment
=
=
0
)
;
masm
.
assertStackAlignment
(
alignment
addBeforeAssert
)
;
}
static
unsigned
StackDecrementForCall
(
MacroAssembler
&
masm
uint32_t
alignment
unsigned
bytesToPush
)
{
return
StackDecrementForCall
(
alignment
sizeof
(
AsmJSFrame
)
+
masm
.
framePushed
(
)
bytesToPush
)
;
}
template
<
class
VectorT
>
static
unsigned
StackArgBytes
(
const
VectorT
&
args
)
{
ABIArgIter
<
VectorT
>
iter
(
args
)
;
while
(
!
iter
.
done
(
)
)
iter
+
+
;
return
iter
.
stackBytesConsumedSoFar
(
)
;
}
template
<
class
VectorT
>
static
unsigned
StackDecrementForCall
(
MacroAssembler
&
masm
uint32_t
alignment
const
VectorT
&
args
unsigned
extraBytes
=
0
)
{
return
StackDecrementForCall
(
masm
alignment
StackArgBytes
(
args
)
+
extraBytes
)
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
static
const
LiveRegisterSet
NonVolatileRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
NonVolatileMask
&
~
(
uint32_t
(
1
)
<
<
Registers
:
:
lr
)
)
FloatRegisterSet
(
FloatRegisters
:
:
NonVolatileMask
|
(
1ULL
<
<
FloatRegisters
:
:
d15
)
|
(
1ULL
<
<
FloatRegisters
:
:
s31
)
)
)
;
#
else
static
const
LiveRegisterSet
NonVolatileRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
NonVolatileMask
)
FloatRegisterSet
(
FloatRegisters
:
:
NonVolatileMask
)
)
;
#
endif
#
if
defined
(
JS_CODEGEN_MIPS32
)
static
const
unsigned
FramePushedAfterSave
=
NonVolatileRegs
.
gprs
(
)
.
size
(
)
*
sizeof
(
intptr_t
)
+
NonVolatileRegs
.
fpus
(
)
.
getPushSizeInBytes
(
)
+
sizeof
(
double
)
;
#
elif
defined
(
JS_CODEGEN_NONE
)
static
const
unsigned
FramePushedAfterSave
=
0
;
#
else
static
const
unsigned
FramePushedAfterSave
=
NonVolatileRegs
.
gprs
(
)
.
size
(
)
*
sizeof
(
intptr_t
)
+
NonVolatileRegs
.
fpus
(
)
.
getPushSizeInBytes
(
)
;
#
endif
static
const
unsigned
FramePushedForEntrySP
=
FramePushedAfterSave
+
sizeof
(
void
*
)
;
static
bool
GenerateEntry
(
MacroAssembler
&
masm
AsmJSModule
&
module
unsigned
exportIndex
const
FuncOffsetVector
&
funcOffsets
)
{
AsmJSModule
:
:
ExportedFunction
&
exp
=
module
.
exportedFunction
(
exportIndex
)
;
if
(
exp
.
isChangeHeap
(
)
)
return
true
;
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
masm
.
push
(
lr
)
;
#
elif
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
masm
.
push
(
ra
)
;
#
elif
defined
(
JS_CODEGEN_X86
)
static
const
unsigned
EntryFrameSize
=
sizeof
(
void
*
)
;
#
endif
masm
.
setFramePushed
(
0
)
;
masm
.
PushRegsInMask
(
NonVolatileRegs
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
FramePushedAfterSave
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
masm
.
movePtr
(
IntArgReg1
GlobalReg
)
;
masm
.
addPtr
(
Imm32
(
AsmJSGlobalRegBias
)
GlobalReg
)
;
#
endif
masm
.
loadAsmJSHeapRegisterFromGlobalData
(
)
;
Register
argv
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
Register
scratch
=
ABIArgGenerator
:
:
NonArgReturnReg1
;
#
if
defined
(
JS_CODEGEN_X86
)
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
EntryFrameSize
+
masm
.
framePushed
(
)
)
argv
)
;
#
else
masm
.
movePtr
(
IntArgReg0
argv
)
;
#
endif
masm
.
Push
(
argv
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
FramePushedForEntrySP
)
;
masm
.
loadAsmJSActivation
(
scratch
)
;
masm
.
storeStackPtr
(
Address
(
scratch
AsmJSActivation
:
:
offsetOfEntrySP
(
)
)
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
AsmJSStackAlignment
-
1
)
)
)
;
masm
.
reserveStack
(
AlignBytes
(
StackArgBytes
(
exp
.
sig
(
)
.
args
(
)
)
AsmJSStackAlignment
)
)
;
for
(
ABIArgValTypeIter
iter
(
exp
.
sig
(
)
.
args
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
unsigned
argOffset
=
iter
.
index
(
)
*
sizeof
(
AsmJSModule
:
:
EntryArg
)
;
Address
src
(
argv
argOffset
)
;
MIRType
type
=
iter
.
mirType
(
)
;
switch
(
iter
-
>
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
masm
.
load32
(
src
iter
-
>
gpr
(
)
)
;
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
MOZ_CRASH
(
"
AsmJS
uses
hardfp
for
function
calls
.
"
)
;
break
;
#
endif
case
ABIArg
:
:
FPU
:
{
static_assert
(
sizeof
(
AsmJSModule
:
:
EntryArg
)
>
=
jit
:
:
Simd128DataSize
"
EntryArg
must
be
big
enough
to
store
SIMD
values
"
)
;
switch
(
type
)
{
case
MIRType_Int32x4
:
masm
.
loadUnalignedInt32x4
(
src
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType_Float32x4
:
masm
.
loadUnalignedFloat32x4
(
src
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType_Double
:
masm
.
loadDouble
(
src
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType_Float32
:
masm
.
loadFloat32
(
src
iter
-
>
fpu
(
)
)
;
break
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
unexpected
FPU
type
"
)
;
break
;
}
break
;
}
case
ABIArg
:
:
Stack
:
switch
(
type
)
{
case
MIRType_Int32
:
masm
.
load32
(
src
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType_Double
:
masm
.
loadDouble
(
src
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType_Float32
:
masm
.
loadFloat32
(
src
ScratchFloat32Reg
)
;
masm
.
storeFloat32
(
ScratchFloat32Reg
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType_Int32x4
:
masm
.
loadUnalignedInt32x4
(
src
ScratchSimd128Reg
)
;
masm
.
storeAlignedInt32x4
(
ScratchSimd128Reg
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType_Float32x4
:
masm
.
loadUnalignedFloat32x4
(
src
ScratchSimd128Reg
)
;
masm
.
storeAlignedFloat32x4
(
ScratchSimd128Reg
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
unexpected
stack
arg
type
"
)
;
}
break
;
}
}
masm
.
assertStackAlignment
(
AsmJSStackAlignment
)
;
Label
target
;
target
.
bind
(
funcOffsets
[
exp
.
funcIndex
(
)
]
)
;
masm
.
call
(
CallSiteDesc
(
CallSiteDesc
:
:
Relative
)
&
target
)
;
masm
.
loadAsmJSActivation
(
scratch
)
;
masm
.
loadStackPtr
(
Address
(
scratch
AsmJSActivation
:
:
offsetOfEntrySP
(
)
)
)
;
masm
.
setFramePushed
(
FramePushedForEntrySP
)
;
masm
.
Pop
(
argv
)
;
switch
(
exp
.
sig
(
)
.
ret
(
)
)
{
case
ExprType
:
:
Void
:
break
;
case
ExprType
:
:
I32
:
masm
.
storeValue
(
JSVAL_TYPE_INT32
ReturnReg
Address
(
argv
0
)
)
;
break
;
case
ExprType
:
:
I64
:
MOZ_CRASH
(
"
no
int64
in
asm
.
js
"
)
;
case
ExprType
:
:
F32
:
masm
.
convertFloat32ToDouble
(
ReturnFloat32Reg
ReturnDoubleReg
)
;
case
ExprType
:
:
F64
:
masm
.
canonicalizeDouble
(
ReturnDoubleReg
)
;
masm
.
storeDouble
(
ReturnDoubleReg
Address
(
argv
0
)
)
;
break
;
case
ExprType
:
:
I32x4
:
masm
.
storeUnalignedInt32x4
(
ReturnSimd128Reg
Address
(
argv
0
)
)
;
break
;
case
ExprType
:
:
F32x4
:
masm
.
storeUnalignedFloat32x4
(
ReturnSimd128Reg
Address
(
argv
0
)
)
;
break
;
}
masm
.
PopRegsInMask
(
NonVolatileRegs
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
masm
.
move32
(
Imm32
(
true
)
ReturnReg
)
;
masm
.
ret
(
)
;
if
(
masm
.
oom
(
)
)
return
false
;
exp
.
initCodeOffset
(
offsets
.
begin
)
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Entry
offsets
)
;
}
static
bool
GenerateBuiltinThunk
(
MacroAssembler
&
masm
AsmJSModule
&
module
AsmJSExit
:
:
BuiltinKind
builtin
)
{
MIRTypeVector
args
;
switch
(
builtin
)
{
case
AsmJSExit
:
:
Builtin_ToInt32
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
break
;
#
if
defined
(
JS_CODEGEN_ARM
)
case
AsmJSExit
:
:
Builtin_IDivMod
:
case
AsmJSExit
:
:
Builtin_UDivMod
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
break
;
case
AsmJSExit
:
:
Builtin_AtomicCmpXchg
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
break
;
case
AsmJSExit
:
:
Builtin_AtomicXchg
:
case
AsmJSExit
:
:
Builtin_AtomicFetchAdd
:
case
AsmJSExit
:
:
Builtin_AtomicFetchSub
:
case
AsmJSExit
:
:
Builtin_AtomicFetchAnd
:
case
AsmJSExit
:
:
Builtin_AtomicFetchOr
:
case
AsmJSExit
:
:
Builtin_AtomicFetchXor
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Int32
)
)
;
break
;
#
endif
case
AsmJSExit
:
:
Builtin_SinD
:
case
AsmJSExit
:
:
Builtin_CosD
:
case
AsmJSExit
:
:
Builtin_TanD
:
case
AsmJSExit
:
:
Builtin_ASinD
:
case
AsmJSExit
:
:
Builtin_ACosD
:
case
AsmJSExit
:
:
Builtin_ATanD
:
case
AsmJSExit
:
:
Builtin_CeilD
:
case
AsmJSExit
:
:
Builtin_FloorD
:
case
AsmJSExit
:
:
Builtin_ExpD
:
case
AsmJSExit
:
:
Builtin_LogD
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Double
)
)
;
break
;
case
AsmJSExit
:
:
Builtin_ModD
:
case
AsmJSExit
:
:
Builtin_PowD
:
case
AsmJSExit
:
:
Builtin_ATan2D
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Double
)
)
;
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Double
)
)
;
break
;
case
AsmJSExit
:
:
Builtin_CeilF
:
case
AsmJSExit
:
:
Builtin_FloorF
:
MOZ_ALWAYS_TRUE
(
args
.
append
(
MIRType_Float32
)
)
;
break
;
case
AsmJSExit
:
:
Builtin_Limit
:
MOZ_CRASH
(
"
Bad
builtin
"
)
;
}
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
uint32_t
framePushed
=
StackDecrementForCall
(
masm
ABIStackAlignment
args
)
;
AsmJSProfilingOffsets
offsets
;
GenerateAsmJSExitPrologue
(
masm
framePushed
AsmJSExit
:
:
Builtin
(
builtin
)
&
offsets
)
;
for
(
ABIArgMIRTypeIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
if
(
i
-
>
kind
(
)
!
=
ABIArg
:
:
Stack
)
continue
;
#
if
!
defined
(
JS_CODEGEN_ARM
)
unsigned
offsetToCallerStackArgs
=
sizeof
(
AsmJSFrame
)
+
masm
.
framePushed
(
)
;
Address
srcAddr
(
masm
.
getStackPointer
(
)
offsetToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
Address
dstAddr
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
;
if
(
i
.
mirType
(
)
=
=
MIRType_Int32
|
|
i
.
mirType
(
)
=
=
MIRType_Float32
)
{
masm
.
load32
(
srcAddr
ABIArgGenerator
:
:
NonArg_VolatileReg
)
;
masm
.
store32
(
ABIArgGenerator
:
:
NonArg_VolatileReg
dstAddr
)
;
}
else
{
MOZ_ASSERT
(
i
.
mirType
(
)
=
=
MIRType_Double
)
;
masm
.
loadDouble
(
srcAddr
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
dstAddr
)
;
}
#
else
MOZ_CRASH
(
"
Architecture
should
have
enough
registers
for
all
builtin
calls
"
)
;
#
endif
}
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
call
(
BuiltinToImmKind
(
builtin
)
)
;
GenerateAsmJSExitEpilogue
(
masm
framePushed
AsmJSExit
:
:
Builtin
(
builtin
)
&
offsets
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addBuiltinThunkCodeRange
(
builtin
offsets
)
;
}
static
void
FillArgumentArray
(
MacroAssembler
&
masm
const
MallocSig
:
:
ArgVector
&
args
unsigned
argOffset
unsigned
offsetToCallerStackArgs
Register
scratch
)
{
for
(
ABIArgValTypeIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
Address
dstAddr
(
masm
.
getStackPointer
(
)
argOffset
+
i
.
index
(
)
*
sizeof
(
Value
)
)
;
switch
(
i
-
>
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
masm
.
storeValue
(
JSVAL_TYPE_INT32
i
-
>
gpr
(
)
dstAddr
)
;
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
MOZ_CRASH
(
"
AsmJS
uses
hardfp
for
function
calls
.
"
)
;
break
;
#
endif
case
ABIArg
:
:
FPU
:
masm
.
canonicalizeDouble
(
i
-
>
fpu
(
)
)
;
masm
.
storeDouble
(
i
-
>
fpu
(
)
dstAddr
)
;
break
;
case
ABIArg
:
:
Stack
:
if
(
i
.
mirType
(
)
=
=
MIRType_Int32
)
{
Address
src
(
masm
.
getStackPointer
(
)
offsetToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
#
if
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
masm
.
load32
(
src
scratch
)
;
masm
.
storeValue
(
JSVAL_TYPE_INT32
scratch
dstAddr
)
;
#
else
masm
.
memIntToValue
(
src
dstAddr
)
;
#
endif
}
else
{
MOZ_ASSERT
(
i
.
mirType
(
)
=
=
MIRType_Double
)
;
Address
src
(
masm
.
getStackPointer
(
)
offsetToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
masm
.
loadDouble
(
src
ScratchDoubleReg
)
;
masm
.
canonicalizeDouble
(
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
dstAddr
)
;
}
break
;
}
}
}
static
void
CheckForHeapDetachment
(
MacroAssembler
&
masm
const
AsmJSModule
&
module
Register
scratch
Label
*
onDetached
)
{
if
(
!
module
.
hasArrayView
(
)
)
return
;
MOZ_ASSERT
(
int
(
masm
.
framePushed
(
)
)
>
=
int
(
ShadowStackSpace
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
#
if
defined
(
JS_CODEGEN_X86
)
CodeOffset
offset
=
masm
.
movlWithPatch
(
PatchedAbsoluteAddress
(
)
scratch
)
;
masm
.
append
(
AsmJSGlobalAccess
(
offset
AsmJSHeapGlobalDataOffset
)
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch
scratch
onDetached
)
;
#
else
masm
.
branchTestPtr
(
Assembler
:
:
Zero
HeapReg
HeapReg
onDetached
)
;
#
endif
}
static
bool
GenerateInterpExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
unsigned
exitIndex
Label
*
throwLabel
Label
*
onDetached
)
{
AsmJSModule
:
:
Exit
&
exit
=
module
.
exit
(
exitIndex
)
;
masm
.
setFramePushed
(
0
)
;
static
const
MIRType
typeArray
[
]
=
{
MIRType_Pointer
MIRType_Int32
MIRType_Pointer
}
;
MIRTypeVector
invokeArgTypes
;
MOZ_ALWAYS_TRUE
(
invokeArgTypes
.
append
(
typeArray
ArrayLength
(
typeArray
)
)
)
;
unsigned
argOffset
=
AlignBytes
(
StackArgBytes
(
invokeArgTypes
)
sizeof
(
double
)
)
;
unsigned
argBytes
=
Max
<
size_t
>
(
1
exit
.
sig
(
)
.
args
(
)
.
length
(
)
)
*
sizeof
(
Value
)
;
unsigned
framePushed
=
StackDecrementForCall
(
masm
ABIStackAlignment
argOffset
+
argBytes
)
;
AsmJSProfilingOffsets
offsets
;
GenerateAsmJSExitPrologue
(
masm
framePushed
AsmJSExit
:
:
SlowFFI
&
offsets
)
;
unsigned
offsetToCallerStackArgs
=
sizeof
(
AsmJSFrame
)
+
masm
.
framePushed
(
)
;
Register
scratch
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
FillArgumentArray
(
masm
exit
.
sig
(
)
.
args
(
)
argOffset
offsetToCallerStackArgs
scratch
)
;
ABIArgMIRTypeIter
i
(
invokeArgTypes
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
masm
.
mov
(
ImmWord
(
exitIndex
)
i
-
>
gpr
(
)
)
;
else
masm
.
store32
(
Imm32
(
exitIndex
)
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
i
+
+
;
unsigned
argc
=
exit
.
sig
(
)
.
args
(
)
.
length
(
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
masm
.
mov
(
ImmWord
(
argc
)
i
-
>
gpr
(
)
)
;
else
masm
.
store32
(
Imm32
(
argc
)
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
i
+
+
;
Address
argv
(
masm
.
getStackPointer
(
)
argOffset
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
computeEffectiveAddress
(
argv
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
computeEffectiveAddress
(
argv
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
MOZ_ASSERT
(
i
.
done
(
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
switch
(
exit
.
sig
(
)
.
ret
(
)
)
{
case
ExprType
:
:
Void
:
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_InvokeFromAsmJS_Ignore
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
break
;
case
ExprType
:
:
I32
:
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_InvokeFromAsmJS_ToInt32
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
unboxInt32
(
argv
ReturnReg
)
;
break
;
case
ExprType
:
:
I64
:
MOZ_CRASH
(
"
no
int64
in
asm
.
js
"
)
;
case
ExprType
:
:
F32
:
MOZ_CRASH
(
"
Float32
shouldn
'
t
be
returned
from
a
FFI
"
)
;
case
ExprType
:
:
F64
:
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_InvokeFromAsmJS_ToNumber
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
loadDouble
(
argv
ReturnDoubleReg
)
;
break
;
case
ExprType
:
:
I32x4
:
case
ExprType
:
:
F32x4
:
MOZ_CRASH
(
"
SIMD
types
shouldn
'
t
be
returned
from
a
FFI
"
)
;
}
masm
.
loadAsmJSHeapRegisterFromGlobalData
(
)
;
CheckForHeapDetachment
(
masm
module
ABIArgGenerator
:
:
NonReturn_VolatileReg0
onDetached
)
;
GenerateAsmJSExitEpilogue
(
masm
framePushed
AsmJSExit
:
:
SlowFFI
&
offsets
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
exit
.
initInterpOffset
(
offsets
.
begin
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
SlowFFI
offsets
)
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
static
const
unsigned
MaybeSavedGlobalReg
=
sizeof
(
void
*
)
;
#
else
static
const
unsigned
MaybeSavedGlobalReg
=
0
;
#
endif
static
bool
GenerateIonExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
unsigned
exitIndex
Label
*
throwLabel
Label
*
onDetached
)
{
AsmJSModule
:
:
Exit
&
exit
=
module
.
exit
(
exitIndex
)
;
masm
.
setFramePushed
(
0
)
;
static_assert
(
AsmJSStackAlignment
>
=
JitStackAlignment
"
subsumes
"
)
;
unsigned
sizeOfRetAddr
=
sizeof
(
void
*
)
;
unsigned
ionFrameBytes
=
3
*
sizeof
(
void
*
)
+
(
1
+
exit
.
sig
(
)
.
args
(
)
.
length
(
)
)
*
sizeof
(
Value
)
;
unsigned
totalIonBytes
=
sizeOfRetAddr
+
ionFrameBytes
+
MaybeSavedGlobalReg
;
unsigned
ionFramePushed
=
StackDecrementForCall
(
masm
JitStackAlignment
totalIonBytes
)
-
sizeOfRetAddr
;
AsmJSProfilingOffsets
offsets
;
GenerateAsmJSExitPrologue
(
masm
ionFramePushed
AsmJSExit
:
:
JitFFI
&
offsets
)
;
size_t
argOffset
=
0
;
uint32_t
descriptor
=
MakeFrameDescriptor
(
ionFramePushed
JitFrame_Entry
)
;
masm
.
storePtr
(
ImmWord
(
uintptr_t
(
descriptor
)
)
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
size_t
)
;
Register
callee
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
Register
scratch
=
ABIArgGenerator
:
:
NonArgReturnReg1
;
unsigned
globalDataOffset
=
module
.
exit
(
exitIndex
)
.
globalDataOffset
(
)
;
#
if
defined
(
JS_CODEGEN_X64
)
masm
.
append
(
AsmJSGlobalAccess
(
masm
.
leaRipRelative
(
callee
)
globalDataOffset
)
)
;
#
elif
defined
(
JS_CODEGEN_X86
)
masm
.
append
(
AsmJSGlobalAccess
(
masm
.
movlWithPatch
(
Imm32
(
0
)
callee
)
globalDataOffset
)
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
masm
.
computeEffectiveAddress
(
Address
(
GlobalReg
globalDataOffset
-
AsmJSGlobalRegBias
)
callee
)
;
#
endif
masm
.
loadPtr
(
Address
(
callee
offsetof
(
AsmJSModule
:
:
ExitDatum
fun
)
)
callee
)
;
masm
.
storePtr
(
callee
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
size_t
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
masm
.
loadBaselineOrIonNoArgCheck
(
callee
callee
nullptr
)
;
unsigned
argc
=
exit
.
sig
(
)
.
args
(
)
.
length
(
)
;
masm
.
storePtr
(
ImmWord
(
uintptr_t
(
argc
)
)
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
size_t
)
;
masm
.
storeValue
(
UndefinedValue
(
)
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
Value
)
;
unsigned
offsetToCallerStackArgs
=
ionFramePushed
+
sizeof
(
AsmJSFrame
)
;
FillArgumentArray
(
masm
exit
.
sig
(
)
.
args
(
)
argOffset
offsetToCallerStackArgs
scratch
)
;
argOffset
+
=
exit
.
sig
(
)
.
args
(
)
.
length
(
)
*
sizeof
(
Value
)
;
MOZ_ASSERT
(
argOffset
=
=
ionFrameBytes
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
static_assert
(
MaybeSavedGlobalReg
=
=
sizeof
(
void
*
)
"
stack
frame
accounting
"
)
;
masm
.
storePtr
(
GlobalReg
Address
(
masm
.
getStackPointer
(
)
ionFrameBytes
)
)
;
#
endif
{
MOZ_ASSERT
(
callee
=
=
AsmJSIonExitRegCallee
)
;
Register
reg0
=
AsmJSIonExitRegE0
;
Register
reg1
=
AsmJSIonExitRegE1
;
Register
reg2
=
AsmJSIonExitRegE2
;
Register
reg3
=
AsmJSIonExitRegE3
;
size_t
offsetOfActivation
=
JSRuntime
:
:
offsetOfActivation
(
)
;
size_t
offsetOfJitTop
=
offsetof
(
JSRuntime
jitTop
)
;
size_t
offsetOfJitJSContext
=
offsetof
(
JSRuntime
jitJSContext
)
;
size_t
offsetOfJitActivation
=
offsetof
(
JSRuntime
jitActivation
)
;
size_t
offsetOfProfilingActivation
=
JSRuntime
:
:
offsetOfProfilingActivation
(
)
;
masm
.
loadAsmJSActivation
(
reg0
)
;
masm
.
loadPtr
(
Address
(
reg0
AsmJSActivation
:
:
offsetOfContext
(
)
)
reg3
)
;
masm
.
loadPtr
(
Address
(
reg3
JSContext
:
:
offsetOfRuntime
(
)
)
reg0
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfActivation
)
reg1
)
;
masm
.
store8
(
Imm32
(
1
)
Address
(
reg1
JitActivation
:
:
offsetOfActiveUint8
(
)
)
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfJitTop
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitTop
(
)
)
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfJitJSContext
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitJSContext
(
)
)
)
;
masm
.
storePtr
(
reg3
Address
(
reg0
offsetOfJitJSContext
)
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfJitActivation
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitActivation
(
)
)
)
;
masm
.
storePtr
(
reg1
Address
(
reg0
offsetOfJitActivation
)
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfProfilingActivation
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg1
Activation
:
:
offsetOfPrevProfiling
(
)
)
)
;
masm
.
storePtr
(
reg1
Address
(
reg0
offsetOfProfilingActivation
)
)
;
}
AssertStackAlignment
(
masm
JitStackAlignment
sizeOfRetAddr
)
;
masm
.
callJitNoProfiler
(
callee
)
;
AssertStackAlignment
(
masm
JitStackAlignment
sizeOfRetAddr
)
;
{
MOZ_ASSERT
(
JSReturnReg_Data
=
=
AsmJSIonExitRegReturnData
)
;
MOZ_ASSERT
(
JSReturnReg_Type
=
=
AsmJSIonExitRegReturnType
)
;
Register
reg0
=
AsmJSIonExitRegD0
;
Register
reg1
=
AsmJSIonExitRegD1
;
Register
reg2
=
AsmJSIonExitRegD2
;
size_t
offsetOfActivation
=
JSRuntime
:
:
offsetOfActivation
(
)
;
size_t
offsetOfJitTop
=
offsetof
(
JSRuntime
jitTop
)
;
size_t
offsetOfJitJSContext
=
offsetof
(
JSRuntime
jitJSContext
)
;
size_t
offsetOfJitActivation
=
offsetof
(
JSRuntime
jitActivation
)
;
size_t
offsetOfProfilingActivation
=
JSRuntime
:
:
offsetOfProfilingActivation
(
)
;
masm
.
movePtr
(
AsmJSImmPtr
(
AsmJSImm_Runtime
)
reg0
)
;
masm
.
loadPtr
(
Address
(
reg0
offsetOfActivation
)
reg1
)
;
masm
.
loadPtr
(
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitTop
(
)
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg0
offsetOfJitTop
)
)
;
masm
.
loadPtr
(
Address
(
reg1
Activation
:
:
offsetOfPrevProfiling
(
)
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg0
offsetOfProfilingActivation
)
)
;
masm
.
store8
(
Imm32
(
0
)
Address
(
reg1
JitActivation
:
:
offsetOfActiveUint8
(
)
)
)
;
masm
.
loadPtr
(
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitJSContext
(
)
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg0
offsetOfJitJSContext
)
)
;
masm
.
loadPtr
(
Address
(
reg1
JitActivation
:
:
offsetOfPrevJitActivation
(
)
)
reg2
)
;
masm
.
storePtr
(
reg2
Address
(
reg0
offsetOfJitActivation
)
)
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
static_assert
(
MaybeSavedGlobalReg
=
=
sizeof
(
void
*
)
"
stack
frame
accounting
"
)
;
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
ionFrameBytes
)
GlobalReg
)
;
#
endif
static_assert
(
ABIStackAlignment
<
=
JitStackAlignment
"
subsumes
"
)
;
masm
.
reserveStack
(
sizeOfRetAddr
)
;
unsigned
nativeFramePushed
=
masm
.
framePushed
(
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
JSReturnOperand
throwLabel
)
;
Label
oolConvert
;
switch
(
exit
.
sig
(
)
.
ret
(
)
)
{
case
ExprType
:
:
Void
:
break
;
case
ExprType
:
:
I32
:
masm
.
convertValueToInt32
(
JSReturnOperand
ReturnDoubleReg
ReturnReg
&
oolConvert
false
)
;
break
;
case
ExprType
:
:
I64
:
MOZ_CRASH
(
"
no
int64
in
asm
.
js
"
)
;
case
ExprType
:
:
F32
:
MOZ_CRASH
(
"
Float
shouldn
'
t
be
returned
from
a
FFI
"
)
;
case
ExprType
:
:
F64
:
masm
.
convertValueToDouble
(
JSReturnOperand
ReturnDoubleReg
&
oolConvert
)
;
break
;
case
ExprType
:
:
I32x4
:
case
ExprType
:
:
F32x4
:
MOZ_CRASH
(
"
SIMD
types
shouldn
'
t
be
returned
from
a
FFI
"
)
;
}
Label
done
;
masm
.
bind
(
&
done
)
;
masm
.
loadAsmJSHeapRegisterFromGlobalData
(
)
;
CheckForHeapDetachment
(
masm
module
ABIArgGenerator
:
:
NonReturn_VolatileReg0
onDetached
)
;
GenerateAsmJSExitEpilogue
(
masm
masm
.
framePushed
(
)
AsmJSExit
:
:
JitFFI
&
offsets
)
;
if
(
oolConvert
.
used
(
)
)
{
masm
.
bind
(
&
oolConvert
)
;
masm
.
setFramePushed
(
nativeFramePushed
)
;
MIRTypeVector
coerceArgTypes
;
JS_ALWAYS_TRUE
(
coerceArgTypes
.
append
(
MIRType_Pointer
)
)
;
unsigned
offsetToCoerceArgv
=
AlignBytes
(
StackArgBytes
(
coerceArgTypes
)
sizeof
(
Value
)
)
;
MOZ_ASSERT
(
nativeFramePushed
>
=
offsetToCoerceArgv
+
sizeof
(
Value
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
storeValue
(
JSReturnOperand
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
)
;
ABIArgMIRTypeIter
i
(
coerceArgTypes
)
;
Address
argv
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
computeEffectiveAddress
(
argv
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
computeEffectiveAddress
(
argv
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
MOZ_ASSERT
(
i
.
done
(
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
switch
(
exit
.
sig
(
)
.
ret
(
)
)
{
case
ExprType
:
:
I32
:
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_CoerceInPlace_ToInt32
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
unboxInt32
(
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
ReturnReg
)
;
break
;
case
ExprType
:
:
F64
:
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_CoerceInPlace_ToNumber
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
loadDouble
(
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
ReturnDoubleReg
)
;
break
;
default
:
MOZ_CRASH
(
"
Unsupported
convert
type
"
)
;
}
masm
.
jump
(
&
done
)
;
masm
.
setFramePushed
(
0
)
;
}
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
exit
.
initJitOffset
(
offsets
.
begin
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
JitFFI
offsets
)
;
}
static
bool
GenerateOnDetachedExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
onDetached
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
masm
.
bind
(
onDetached
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_OnDetached
)
)
;
masm
.
jump
(
throwLabel
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
static
bool
GenerateStackOverflowExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
masm
.
bind
(
masm
.
asmStackOverflowLabel
(
)
)
;
Register
activation
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
masm
.
loadAsmJSActivation
(
activation
)
;
masm
.
storePtr
(
masm
.
getStackPointer
(
)
Address
(
activation
AsmJSActivation
:
:
offsetOfFP
(
)
)
)
;
if
(
uint32_t
d
=
StackDecrementForCall
(
ABIStackAlignment
sizeof
(
AsmJSFrame
)
ShadowStackSpace
)
)
masm
.
subFromStackPtr
(
Imm32
(
d
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_ReportOverRecursed
)
)
;
masm
.
jump
(
throwLabel
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
static
bool
GenerateSyncInterruptExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
setFramePushed
(
0
)
;
unsigned
framePushed
=
StackDecrementForCall
(
masm
ABIStackAlignment
ShadowStackSpace
)
;
AsmJSProfilingOffsets
offsets
;
GenerateAsmJSExitPrologue
(
masm
framePushed
AsmJSExit
:
:
Interrupt
&
offsets
masm
.
asmSyncInterruptLabel
(
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_HandleExecutionInterrupt
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
throwLabel
)
;
GenerateAsmJSExitEpilogue
(
masm
framePushed
AsmJSExit
:
:
Interrupt
&
offsets
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Interrupt
offsets
)
;
}
static
bool
GenerateConversionErrorExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
masm
.
bind
(
masm
.
asmOnConversionErrorLabel
(
)
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImm_OnImpreciseConversion
)
;
masm
.
jump
(
throwLabel
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
module
.
setOnOutOfBoundsExitOffset
(
offsets
.
begin
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
static
bool
GenerateOutOfBoundsExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
masm
.
bind
(
masm
.
asmOnOutOfBoundsLabel
(
)
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImm_OnOutOfBounds
)
;
masm
.
jump
(
throwLabel
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
module
.
setOnOutOfBoundsExitOffset
(
offsets
.
begin
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
static
const
LiveRegisterSet
AllRegsExceptSP
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
uint32_t
(
1
)
<
<
Registers
:
:
StackPointer
)
)
FloatRegisterSet
(
FloatRegisters
:
:
AllMask
)
)
;
static
bool
GenerateAsyncInterruptExit
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
masm
.
push
(
Imm32
(
0
)
)
;
masm
.
pushFlags
(
)
;
masm
.
setFramePushed
(
0
)
;
masm
.
PushRegsInMask
(
AllRegsExceptSP
)
;
Register
scratch
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
masm
.
loadAsmJSActivation
(
scratch
)
;
masm
.
loadPtr
(
Address
(
scratch
AsmJSActivation
:
:
offsetOfResumePC
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
masm
.
framePushed
(
)
+
sizeof
(
void
*
)
)
)
;
masm
.
moveStackPtrTo
(
ABIArgGenerator
:
:
NonVolatileReg
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
if
(
ShadowStackSpace
)
masm
.
subFromStackPtr
(
Imm32
(
ShadowStackSpace
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImmPtr
(
AsmJSImm_HandleExecutionInterrupt
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
throwLabel
)
;
masm
.
moveToStackPtr
(
ABIArgGenerator
:
:
NonVolatileReg
)
;
masm
.
PopRegsInMask
(
AllRegsExceptSP
)
;
masm
.
popFlags
(
)
;
masm
.
ret
(
)
;
#
elif
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
masm
.
subFromStackPtr
(
Imm32
(
sizeof
(
intptr_t
)
)
)
;
masm
.
setFramePushed
(
0
)
;
JS_STATIC_ASSERT
(
!
SupportsSimd
)
;
masm
.
PushRegsInMask
(
AllRegsExceptSP
)
;
masm
.
moveStackPtrTo
(
s0
)
;
masm
.
ma_and
(
StackPointer
StackPointer
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
masm
.
loadAsmJSActivation
(
IntArgReg0
)
;
masm
.
loadPtr
(
Address
(
IntArgReg0
AsmJSActivation
:
:
offsetOfResumePC
(
)
)
IntArgReg1
)
;
masm
.
storePtr
(
IntArgReg1
Address
(
s0
masm
.
framePushed
(
)
)
)
;
masm
.
subFromStackPtr
(
Imm32
(
4
*
sizeof
(
intptr_t
)
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImm_HandleExecutionInterrupt
)
;
masm
.
addToStackPtr
(
Imm32
(
4
*
sizeof
(
intptr_t
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
throwLabel
)
;
masm
.
moveToStackPtr
(
s0
)
;
masm
.
PopRegsInMask
(
AllRegsExceptSP
)
;
masm
.
pop
(
HeapReg
)
;
masm
.
as_jr
(
HeapReg
)
;
masm
.
loadAsmJSHeapRegisterFromGlobalData
(
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
masm
.
setFramePushed
(
0
)
;
masm
.
PushRegsInMask
(
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
1
<
<
Registers
:
:
sp
)
)
FloatRegisterSet
(
uint32_t
(
0
)
)
)
)
;
masm
.
as_mrs
(
r4
)
;
masm
.
as_vmrs
(
r5
)
;
masm
.
mov
(
sp
r6
)
;
masm
.
ma_and
(
Imm32
(
~
7
)
sp
sp
)
;
masm
.
loadAsmJSActivation
(
IntArgReg0
)
;
masm
.
loadPtr
(
Address
(
IntArgReg0
AsmJSActivation
:
:
offsetOfResumePC
(
)
)
IntArgReg1
)
;
masm
.
storePtr
(
IntArgReg1
Address
(
r6
14
*
sizeof
(
uint32_t
*
)
)
)
;
JS_STATIC_ASSERT
(
!
SupportsSimd
)
;
masm
.
PushRegsInMask
(
LiveRegisterSet
(
GeneralRegisterSet
(
0
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
AsmJSImm_HandleExecutionInterrupt
)
;
masm
.
branchIfFalseBool
(
ReturnReg
throwLabel
)
;
masm
.
PopRegsInMask
(
LiveRegisterSet
(
GeneralRegisterSet
(
0
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
)
;
masm
.
mov
(
r6
sp
)
;
masm
.
as_vmsr
(
r5
)
;
masm
.
as_msr
(
r4
)
;
masm
.
startDataTransferM
(
IsLoad
sp
IA
WriteBack
)
;
masm
.
transferReg
(
r0
)
;
masm
.
transferReg
(
r1
)
;
masm
.
transferReg
(
r2
)
;
masm
.
transferReg
(
r3
)
;
masm
.
transferReg
(
r4
)
;
masm
.
transferReg
(
r5
)
;
masm
.
transferReg
(
r6
)
;
masm
.
transferReg
(
r7
)
;
masm
.
transferReg
(
r8
)
;
masm
.
transferReg
(
r9
)
;
masm
.
transferReg
(
r10
)
;
masm
.
transferReg
(
r11
)
;
masm
.
transferReg
(
r12
)
;
masm
.
transferReg
(
lr
)
;
masm
.
finishDataTransfer
(
)
;
masm
.
ret
(
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
MOZ_CRASH
(
)
;
#
elif
defined
(
JS_CODEGEN_NONE
)
MOZ_CRASH
(
)
;
#
else
#
error
"
Unknown
architecture
!
"
#
endif
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
module
.
setAsyncInterruptOffset
(
offsets
.
begin
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
static
bool
GenerateThrowStub
(
MacroAssembler
&
masm
AsmJSModule
&
module
Label
*
throwLabel
)
{
masm
.
haltingAlign
(
CodeAlignment
)
;
AsmJSOffsets
offsets
;
offsets
.
begin
=
masm
.
currentOffset
(
)
;
masm
.
bind
(
throwLabel
)
;
Register
scratch
=
ABIArgGenerator
:
:
NonArgReturnReg0
;
masm
.
loadAsmJSActivation
(
scratch
)
;
masm
.
storePtr
(
ImmWord
(
0
)
Address
(
scratch
AsmJSActivation
:
:
offsetOfFP
(
)
)
)
;
masm
.
setFramePushed
(
FramePushedForEntrySP
)
;
masm
.
loadStackPtr
(
Address
(
scratch
AsmJSActivation
:
:
offsetOfEntrySP
(
)
)
)
;
masm
.
Pop
(
scratch
)
;
masm
.
PopRegsInMask
(
NonVolatileRegs
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
masm
.
mov
(
ImmWord
(
0
)
ReturnReg
)
;
masm
.
ret
(
)
;
if
(
masm
.
oom
(
)
)
return
false
;
offsets
.
end
=
masm
.
currentOffset
(
)
;
return
module
.
addCodeRange
(
AsmJSModule
:
:
CodeRange
:
:
Inline
offsets
)
;
}
bool
wasm
:
:
GenerateStubs
(
MacroAssembler
&
masm
AsmJSModule
&
module
const
FuncOffsetVector
&
funcOffsets
)
{
for
(
unsigned
i
=
0
;
i
<
module
.
numExportedFunctions
(
)
;
i
+
+
)
{
if
(
!
GenerateEntry
(
masm
module
i
funcOffsets
)
)
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
AsmJSExit
:
:
Builtin_Limit
;
i
+
+
)
{
if
(
!
GenerateBuiltinThunk
(
masm
module
AsmJSExit
:
:
BuiltinKind
(
i
)
)
)
return
false
;
}
Label
onThrow
;
{
Label
onDetached
;
for
(
size_t
i
=
0
;
i
<
module
.
numExits
(
)
;
i
+
+
)
{
if
(
!
GenerateInterpExit
(
masm
module
i
&
onThrow
&
onDetached
)
)
return
false
;
if
(
!
GenerateIonExit
(
masm
module
i
&
onThrow
&
onDetached
)
)
return
false
;
}
if
(
onDetached
.
used
(
)
)
{
if
(
!
GenerateOnDetachedExit
(
masm
module
&
onDetached
&
onThrow
)
)
return
false
;
}
}
if
(
masm
.
asmStackOverflowLabel
(
)
-
>
used
(
)
)
{
if
(
!
GenerateStackOverflowExit
(
masm
module
&
onThrow
)
)
return
false
;
}
if
(
masm
.
asmSyncInterruptLabel
(
)
-
>
used
(
)
)
{
if
(
!
GenerateSyncInterruptExit
(
masm
module
&
onThrow
)
)
return
false
;
}
if
(
masm
.
asmOnConversionErrorLabel
(
)
-
>
used
(
)
)
{
if
(
!
GenerateConversionErrorExit
(
masm
module
&
onThrow
)
)
return
false
;
}
if
(
!
GenerateOutOfBoundsExit
(
masm
module
&
onThrow
)
)
return
false
;
if
(
!
GenerateAsyncInterruptExit
(
masm
module
&
onThrow
)
)
return
false
;
if
(
onThrow
.
used
(
)
)
{
if
(
!
GenerateThrowStub
(
masm
module
&
onThrow
)
)
return
false
;
}
return
true
;
}
