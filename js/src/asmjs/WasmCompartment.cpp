#
include
"
asmjs
/
WasmCompartment
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
asmjs
/
WasmInstance
.
h
"
#
include
"
vm
/
Debugger
-
inl
.
h
"
using
namespace
js
;
using
namespace
wasm
;
Compartment
:
:
Compartment
(
Zone
*
zone
)
:
mutatingInstances_
(
false
)
instanceObjects_
(
zone
InstanceObjectSet
(
)
)
activationCount_
(
0
)
profilingEnabled_
(
false
)
{
}
Compartment
:
:
~
Compartment
(
)
{
MOZ_ASSERT
(
activationCount_
=
=
0
)
;
MOZ_ASSERT
(
!
instanceObjects_
.
initialized
(
)
|
|
instanceObjects_
.
empty
(
)
)
;
MOZ_ASSERT
(
instances_
.
empty
(
)
)
;
MOZ_ASSERT
(
!
mutatingInstances_
)
;
}
struct
InstanceComparator
{
const
Instance
&
target
;
explicit
InstanceComparator
(
const
Instance
&
target
)
:
target
(
target
)
{
}
int
operator
(
)
(
const
Instance
*
instance
)
const
{
if
(
instance
=
=
&
target
)
return
0
;
MOZ_ASSERT
(
!
target
.
codeSegment
(
)
.
containsCodePC
(
instance
-
>
codeBase
(
)
)
)
;
MOZ_ASSERT
(
!
instance
-
>
codeSegment
(
)
.
containsCodePC
(
target
.
codeBase
(
)
)
)
;
return
target
.
codeBase
(
)
<
instance
-
>
codeBase
(
)
?
-
1
:
1
;
}
}
;
void
Compartment
:
:
trace
(
JSTracer
*
trc
)
{
if
(
activationCount_
)
instanceObjects_
.
get
(
)
.
trace
(
trc
)
;
}
bool
Compartment
:
:
registerInstance
(
JSContext
*
cx
HandleWasmInstanceObject
instanceObj
)
{
Instance
&
instance
=
instanceObj
-
>
instance
(
)
;
MOZ_ASSERT
(
this
=
=
&
instance
.
compartment
(
)
-
>
wasm
)
;
if
(
!
instance
.
ensureProfilingState
(
cx
profilingEnabled_
)
)
return
false
;
if
(
!
instanceObjects_
.
initialized
(
)
&
&
!
instanceObjects_
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
instanceObjects_
.
putNew
(
instanceObj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
size_t
index
;
if
(
BinarySearchIf
(
instances_
0
instances_
.
length
(
)
InstanceComparator
(
instance
)
&
index
)
)
MOZ_CRASH
(
"
duplicate
registration
"
)
;
{
AutoMutateInstances
guard
(
*
this
)
;
if
(
!
instances_
.
insert
(
instances_
.
begin
(
)
+
index
&
instance
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
Debugger
:
:
onNewWasmInstance
(
cx
instanceObj
)
;
return
true
;
}
void
Compartment
:
:
unregisterInstance
(
Instance
&
instance
)
{
size_t
index
;
if
(
!
BinarySearchIf
(
instances_
0
instances_
.
length
(
)
InstanceComparator
(
instance
)
&
index
)
)
return
;
AutoMutateInstances
guard
(
*
this
)
;
instances_
.
erase
(
instances_
.
begin
(
)
+
index
)
;
}
struct
PCComparator
{
const
void
*
pc
;
explicit
PCComparator
(
const
void
*
pc
)
:
pc
(
pc
)
{
}
int
operator
(
)
(
const
Instance
*
instance
)
const
{
if
(
instance
-
>
codeSegment
(
)
.
containsCodePC
(
pc
)
)
return
0
;
return
pc
<
instance
-
>
codeBase
(
)
?
-
1
:
1
;
}
}
;
Code
*
Compartment
:
:
lookupCode
(
const
void
*
pc
)
const
{
Instance
*
instance
=
lookupInstanceDeprecated
(
pc
)
;
return
instance
?
&
instance
-
>
code
(
)
:
nullptr
;
}
Instance
*
Compartment
:
:
lookupInstanceDeprecated
(
const
void
*
pc
)
const
{
MOZ_ASSERT
(
!
mutatingInstances_
)
;
size_t
index
;
if
(
!
BinarySearchIf
(
instances_
0
instances_
.
length
(
)
PCComparator
(
pc
)
&
index
)
)
return
nullptr
;
return
instances_
[
index
]
;
}
bool
Compartment
:
:
ensureProfilingState
(
JSContext
*
cx
)
{
bool
newProfilingEnabled
=
cx
-
>
spsProfiler
.
enabled
(
)
;
if
(
profilingEnabled_
=
=
newProfilingEnabled
)
return
true
;
if
(
activationCount_
>
0
)
return
true
;
for
(
Instance
*
instance
:
instances_
)
{
if
(
!
instance
-
>
ensureProfilingState
(
cx
newProfilingEnabled
)
)
return
false
;
}
profilingEnabled_
=
newProfilingEnabled
;
return
true
;
}
bool
Compartment
:
:
profilingEnabled
(
)
const
{
return
profilingEnabled_
&
&
!
mutatingInstances_
;
}
void
Compartment
:
:
addSizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
size_t
*
compartmentTables
)
{
*
compartmentTables
+
=
instanceObjects_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
