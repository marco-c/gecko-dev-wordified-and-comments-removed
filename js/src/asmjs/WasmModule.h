#
ifndef
wasm_module_h
#
define
wasm_module_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
asmjs
/
WasmTypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
AsmJSModule
;
class
WasmActivation
;
class
WasmModuleObject
;
namespace
jit
{
struct
BaselineScript
;
}
namespace
wasm
{
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
ExclusiveContext
*
cx
const
uint8_t
*
cursor
)
;
\
bool
clone
(
JSContext
*
cx
Type
*
out
)
const
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
struct
StaticLinkData
{
struct
InternalLink
{
enum
Kind
{
RawPointer
CodeLabel
InstructionImmediate
}
;
uint32_t
patchAtOffset
;
uint32_t
targetOffset
;
InternalLink
(
)
=
default
;
explicit
InternalLink
(
Kind
kind
)
;
bool
isRawPointerPatch
(
)
;
}
;
typedef
Vector
<
InternalLink
0
SystemAllocPolicy
>
InternalLinkVector
;
struct
SymbolicLinkArray
:
EnumeratedArray
<
SymbolicAddress
SymbolicAddress
:
:
Limit
Uint32Vector
>
{
WASM_DECLARE_SERIALIZABLE
(
SymbolicLinkArray
)
}
;
struct
FuncPtrTable
{
uint32_t
globalDataOffset
;
Uint32Vector
elemOffsets
;
FuncPtrTable
(
uint32_t
globalDataOffset
Uint32Vector
&
&
elemOffsets
)
:
globalDataOffset
(
globalDataOffset
)
elemOffsets
(
Move
(
elemOffsets
)
)
{
}
FuncPtrTable
(
FuncPtrTable
&
&
rhs
)
:
globalDataOffset
(
rhs
.
globalDataOffset
)
elemOffsets
(
Move
(
rhs
.
elemOffsets
)
)
{
}
FuncPtrTable
(
)
=
default
;
WASM_DECLARE_SERIALIZABLE
(
FuncPtrTable
)
}
;
typedef
Vector
<
FuncPtrTable
0
SystemAllocPolicy
>
FuncPtrTableVector
;
struct
CacheablePod
{
uint32_t
interruptOffset
;
uint32_t
outOfBoundsOffset
;
}
pod
;
InternalLinkVector
internalLinks
;
SymbolicLinkArray
symbolicLinks
;
FuncPtrTableVector
funcPtrTables
;
WASM_DECLARE_SERIALIZABLE
(
StaticLinkData
)
}
;
typedef
UniquePtr
<
StaticLinkData
>
UniqueStaticLinkData
;
class
Export
{
Sig
sig_
;
struct
CacheablePod
{
uint32_t
stubOffset_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
Sig
&
&
sig
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
stubOffset_
=
UINT32_MAX
;
}
Export
(
Export
&
&
rhs
)
:
sig_
(
Move
(
rhs
.
sig_
)
)
pod
(
rhs
.
pod
)
{
}
void
initStubOffset
(
uint32_t
stubOffset
)
{
MOZ_ASSERT
(
pod
.
stubOffset_
=
=
UINT32_MAX
)
;
pod
.
stubOffset_
=
stubOffset
;
}
uint32_t
stubOffset
(
)
const
{
return
pod
.
stubOffset_
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
class
Import
{
Sig
sig_
;
struct
CacheablePod
{
uint32_t
exitGlobalDataOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
}
pod
;
public
:
Import
(
)
{
}
Import
(
Import
&
&
rhs
)
:
sig_
(
Move
(
rhs
.
sig_
)
)
pod
(
rhs
.
pod
)
{
}
Import
(
Sig
&
&
sig
uint32_t
exitGlobalDataOffset
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
exitGlobalDataOffset_
=
exitGlobalDataOffset
;
pod
.
interpExitCodeOffset_
=
0
;
pod
.
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
interpExitCodeOffset_
)
;
pod
.
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
jitExitCodeOffset_
)
;
pod
.
jitExitCodeOffset_
=
off
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
exitGlobalDataOffset
(
)
const
{
return
pod
.
exitGlobalDataOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
pod
.
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
pod
.
jitExitCodeOffset_
;
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
CodeRange
{
uint32_t
funcIndex_
;
uint32_t
funcLineOrBytecode_
;
uint32_t
begin_
;
uint32_t
profilingReturn_
;
uint32_t
end_
;
union
{
struct
{
uint8_t
kind_
;
uint8_t
beginToEntry_
;
uint8_t
profilingJumpToProfilingReturn_
;
uint8_t
profilingEpilogueToProfilingReturn_
;
}
func
;
uint8_t
kind_
;
}
u
;
void
assertValid
(
)
;
public
:
enum
Kind
{
Function
Entry
ImportJitExit
ImportInterpExit
ErrorExit
Inline
CallThunk
}
;
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
ProfilingOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
Kind
(
u
.
kind_
)
;
}
uint32_t
profilingReturn
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
|
|
isImportExit
(
)
)
;
return
profilingReturn_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
;
}
bool
isErrorExit
(
)
const
{
return
kind
(
)
=
=
ErrorExit
;
}
uint32_t
funcProfilingEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin
(
)
;
}
uint32_t
funcNonProfilingEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToEntry_
;
}
uint32_t
functionProfilingJump
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
profilingReturn_
-
u
.
func
.
profilingJumpToProfilingReturn_
;
}
uint32_t
funcProfilingEpilogue
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
profilingReturn_
-
u
.
func
.
profilingEpilogueToProfilingReturn_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
funcIndex_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
funcLineOrBytecode_
;
}
struct
PC
{
size_t
offset
;
explicit
PC
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
}
}
namespace
mozilla
{
template
<
>
struct
IsPod
<
js
:
:
wasm
:
:
CodeRange
>
:
TrueType
{
}
;
}
namespace
js
{
namespace
wasm
{
typedef
Vector
<
CodeRange
0
SystemAllocPolicy
>
CodeRangeVector
;
struct
CallThunk
{
uint32_t
offset
;
union
{
uint32_t
funcIndex
;
uint32_t
codeRangeIndex
;
}
u
;
CallThunk
(
uint32_t
offset
uint32_t
funcIndex
)
:
offset
(
offset
)
{
u
.
funcIndex
=
funcIndex
;
}
CallThunk
(
)
=
default
;
}
;
typedef
Vector
<
CallThunk
0
SystemAllocPolicy
>
CallThunkVector
;
}
}
namespace
mozilla
{
template
<
>
struct
IsPod
<
js
:
:
wasm
:
:
CallThunk
>
:
TrueType
{
}
;
}
namespace
js
{
namespace
wasm
{
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
Move
(
rhs
)
)
{
}
CacheableChars
(
CacheableChars
&
&
rhs
)
:
UniqueChars
(
Move
(
rhs
)
)
{
}
void
operator
=
(
CacheableChars
&
&
rhs
)
{
UniqueChars
:
:
operator
=
(
Move
(
rhs
)
)
;
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
static
const
uint32_t
MemoryExport
=
UINT32_MAX
;
struct
ExportMap
{
CacheableCharsVector
fieldNames
;
Uint32Vector
fieldsToExports
;
Uint32Vector
exportFuncIndices
;
WASM_DECLARE_SERIALIZABLE
(
ExportMap
)
}
;
typedef
UniquePtr
<
ExportMap
>
UniqueExportMap
;
class
CodeDeleter
{
uint32_t
bytes_
;
public
:
CodeDeleter
(
)
:
bytes_
(
0
)
{
}
explicit
CodeDeleter
(
uint32_t
bytes
)
:
bytes_
(
bytes
)
{
}
void
operator
(
)
(
uint8_t
*
p
)
;
}
;
typedef
UniquePtr
<
uint8_t
CodeDeleter
>
UniqueCodePtr
;
UniqueCodePtr
AllocateCode
(
ExclusiveContext
*
cx
size_t
bytes
)
;
enum
class
HeapUsage
{
None
=
false
Unshared
=
1
Shared
=
2
}
;
static
inline
bool
UsesHeap
(
HeapUsage
heapUsage
)
{
return
bool
(
heapUsage
)
;
}
struct
ModuleCacheablePod
{
uint32_t
functionBytes
;
uint32_t
codeBytes
;
uint32_t
globalBytes
;
uint32_t
numFuncs
;
ModuleKind
kind
;
HeapUsage
heapUsage
;
CompileArgs
compileArgs
;
uint32_t
totalBytes
(
)
const
{
return
codeBytes
+
globalBytes
;
}
}
;
struct
ModuleData
:
ModuleCacheablePod
{
ModuleData
(
)
:
loadedFromCache
(
false
)
{
mozilla
:
:
PodZero
(
&
pod
(
)
)
;
}
ModuleCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
ModuleCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
UniqueCodePtr
code
;
ImportVector
imports
;
ExportVector
exports
;
HeapAccessVector
heapAccesses
;
CodeRangeVector
codeRanges
;
CallSiteVector
callSites
;
CallThunkVector
callThunks
;
CacheableCharsVector
prettyFuncNames
;
CacheableChars
filename
;
bool
loadedFromCache
;
WASM_DECLARE_SERIALIZABLE
(
ModuleData
)
;
}
;
typedef
UniquePtr
<
ModuleData
>
UniqueModuleData
;
class
Module
:
public
mozilla
:
:
LinkedListElement
<
Module
>
{
typedef
UniquePtr
<
const
ModuleData
>
UniqueConstModuleData
;
struct
ImportExit
{
void
*
code
;
jit
:
:
BaselineScript
*
baselineScript
;
HeapPtrFunction
fun
;
static_assert
(
sizeof
(
HeapPtrFunction
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
EntryArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
typedef
int32_t
(
*
EntryFuncPtr
)
(
EntryArg
*
args
uint8_t
*
global
)
;
struct
FuncPtrTable
{
uint32_t
globalDataOffset
;
uint32_t
numElems
;
explicit
FuncPtrTable
(
const
StaticLinkData
:
:
FuncPtrTable
&
table
)
:
globalDataOffset
(
table
.
globalDataOffset
)
numElems
(
table
.
elemOffsets
.
length
(
)
)
{
}
}
;
typedef
Vector
<
FuncPtrTable
0
SystemAllocPolicy
>
FuncPtrTableVector
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
FuncLabelVector
;
typedef
RelocatablePtrArrayBufferObjectMaybeShared
BufferPtr
;
typedef
HeapPtr
<
WasmModuleObject
*
>
ModuleObjectPtr
;
const
UniqueConstModuleData
module_
;
bool
staticallyLinked_
;
uint8_t
*
interrupt_
;
uint8_t
*
outOfBounds_
;
FuncPtrTableVector
funcPtrTables_
;
bool
dynamicallyLinked_
;
BufferPtr
heap_
;
bool
profilingEnabled_
;
FuncLabelVector
funcLabels_
;
ModuleObjectPtr
ownerObject_
;
Bytes
source_
;
uint8_t
*
rawHeapPtr
(
)
const
;
uint8_t
*
&
rawHeapPtr
(
)
;
WasmActivation
*
&
activation
(
)
;
void
specializeToHeap
(
ArrayBufferObjectMaybeShared
*
heap
)
;
void
despecializeFromHeap
(
ArrayBufferObjectMaybeShared
*
heap
)
;
bool
sendCodeRangesToProfiler
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
setProfilingEnabled
(
JSContext
*
cx
bool
enabled
)
;
ImportExit
&
importToExit
(
const
Import
&
import
)
;
friend
class
js
:
:
WasmActivation
;
protected
:
const
ModuleData
&
base
(
)
const
{
return
*
module_
;
}
bool
clone
(
JSContext
*
cx
const
StaticLinkData
&
link
Module
*
clone
)
const
;
public
:
static
const
unsigned
SizeOfImportExit
=
sizeof
(
ImportExit
)
;
static
const
unsigned
OffsetOfImportExitFun
=
offsetof
(
ImportExit
fun
)
;
static
const
unsigned
SizeOfEntryArg
=
sizeof
(
EntryArg
)
;
explicit
Module
(
UniqueModuleData
module
)
;
virtual
~
Module
(
)
;
virtual
void
trace
(
JSTracer
*
trc
)
;
virtual
void
readBarrier
(
)
;
virtual
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
;
void
setOwner
(
WasmModuleObject
*
owner
)
{
MOZ_ASSERT
(
!
ownerObject_
)
;
ownerObject_
=
owner
;
}
inline
const
HeapPtr
<
WasmModuleObject
*
>
&
owner
(
)
const
;
void
setSource
(
Bytes
&
&
source
)
{
source_
=
Move
(
source
)
;
}
uint8_t
*
code
(
)
const
{
return
module_
-
>
code
.
get
(
)
;
}
uint32_t
codeBytes
(
)
const
{
return
module_
-
>
codeBytes
;
}
uint8_t
*
globalData
(
)
const
{
return
code
(
)
+
module_
-
>
codeBytes
;
}
uint32_t
globalBytes
(
)
const
{
return
module_
-
>
globalBytes
;
}
HeapUsage
heapUsage
(
)
const
{
return
module_
-
>
heapUsage
;
}
bool
usesHeap
(
)
const
{
return
UsesHeap
(
module_
-
>
heapUsage
)
;
}
bool
hasSharedHeap
(
)
const
{
return
module_
-
>
heapUsage
=
=
HeapUsage
:
:
Shared
;
}
CompileArgs
compileArgs
(
)
const
{
return
module_
-
>
compileArgs
;
}
const
ImportVector
&
imports
(
)
const
{
return
module_
-
>
imports
;
}
const
ExportVector
&
exports
(
)
const
{
return
module_
-
>
exports
;
}
const
CodeRangeVector
&
codeRanges
(
)
const
{
return
module_
-
>
codeRanges
;
}
const
char
*
filename
(
)
const
{
return
module_
-
>
filename
.
get
(
)
;
}
bool
loadedFromCache
(
)
const
{
return
module_
-
>
loadedFromCache
;
}
bool
staticallyLinked
(
)
const
{
return
staticallyLinked_
;
}
bool
dynamicallyLinked
(
)
const
{
return
dynamicallyLinked_
;
}
bool
isAsmJS
(
)
const
{
return
module_
-
>
kind
=
=
ModuleKind
:
:
AsmJS
;
}
AsmJSModule
&
asAsmJS
(
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
*
(
AsmJSModule
*
)
this
;
}
const
AsmJSModule
&
asAsmJS
(
)
const
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
*
(
const
AsmJSModule
*
)
this
;
}
virtual
bool
mutedErrors
(
)
const
;
virtual
const
char16_t
*
displayURL
(
)
const
;
virtual
ScriptSource
*
maybeScriptSource
(
)
const
{
return
nullptr
;
}
bool
containsFunctionPC
(
void
*
pc
)
const
;
bool
containsCodePC
(
void
*
pc
)
const
;
const
CallSite
*
lookupCallSite
(
void
*
returnAddress
)
const
;
const
CodeRange
*
lookupCodeRange
(
void
*
pc
)
const
;
const
HeapAccess
*
lookupHeapAccess
(
void
*
pc
)
const
;
bool
staticallyLink
(
ExclusiveContext
*
cx
const
StaticLinkData
&
link
)
;
bool
dynamicallyLink
(
JSContext
*
cx
Handle
<
WasmModuleObject
*
>
moduleObj
Handle
<
ArrayBufferObjectMaybeShared
*
>
heap
Handle
<
FunctionVector
>
imports
const
ExportMap
&
exportMap
MutableHandleObject
exportObj
)
;
SharedMem
<
uint8_t
*
>
heap
(
)
const
;
size_t
heapLength
(
)
const
;
bool
callExport
(
JSContext
*
cx
uint32_t
exportIndex
CallArgs
args
)
;
bool
callImport
(
JSContext
*
cx
uint32_t
importIndex
unsigned
argc
const
uint64_t
*
argv
MutableHandleValue
rval
)
;
void
deoptimizeImportExit
(
uint32_t
importIndex
)
;
uint8_t
*
interrupt
(
)
const
{
MOZ_ASSERT
(
staticallyLinked_
)
;
return
interrupt_
;
}
uint8_t
*
outOfBounds
(
)
const
{
MOZ_ASSERT
(
staticallyLinked_
)
;
return
outOfBounds_
;
}
const
char
*
prettyFuncName
(
uint32_t
funcIndex
)
const
;
const
char
*
getFuncName
(
JSContext
*
cx
uint32_t
funcIndex
UniqueChars
*
owner
)
const
;
JSAtom
*
getFuncAtom
(
JSContext
*
cx
uint32_t
funcIndex
)
const
;
JSString
*
createText
(
JSContext
*
cx
)
;
bool
profilingEnabled
(
)
const
{
return
profilingEnabled_
;
}
const
char
*
profilingLabel
(
uint32_t
funcIndex
)
const
;
}
;
typedef
UniquePtr
<
Module
>
UniqueModule
;
extern
bool
IsExportedFunction
(
JSFunction
*
fun
)
;
extern
WasmModuleObject
*
ExportedFunctionToModuleObject
(
JSFunction
*
fun
)
;
extern
uint32_t
ExportedFunctionToIndex
(
JSFunction
*
fun
)
;
}
class
WasmModuleObject
:
public
NativeObject
{
static
const
unsigned
MODULE_SLOT
=
0
;
static
const
ClassOps
classOps_
;
bool
hasModule
(
)
const
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
WasmModuleObject
*
create
(
ExclusiveContext
*
cx
)
;
bool
init
(
wasm
:
:
Module
*
module
)
;
wasm
:
:
Module
&
module
(
)
const
;
void
addSizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
;
static
const
Class
class_
;
}
;
inline
const
HeapPtr
<
WasmModuleObject
*
>
&
wasm
:
:
Module
:
:
owner
(
)
const
{
MOZ_ASSERT
(
&
ownerObject_
-
>
module
(
)
=
=
this
)
;
return
ownerObject_
;
}
using
WasmModuleObjectVector
=
GCVector
<
WasmModuleObject
*
>
;
}
#
endif
