#
ifndef
wasm_module_h
#
define
wasm_module_h
#
include
"
asmjs
/
WasmCode
.
h
"
#
include
"
asmjs
/
WasmTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
wasm
{
struct
LinkDataCacheablePod
{
uint32_t
functionCodeLength
;
uint32_t
globalDataLength
;
uint32_t
interruptOffset
;
uint32_t
outOfBoundsOffset
;
uint32_t
unalignedAccessOffset
;
LinkDataCacheablePod
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
}
;
struct
LinkData
:
LinkDataCacheablePod
{
LinkDataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
LinkDataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
struct
InternalLink
{
enum
Kind
{
RawPointer
CodeLabel
InstructionImmediate
}
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
patchAtOffset
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
targetOffset
;
InternalLink
(
)
=
default
;
explicit
InternalLink
(
Kind
kind
)
;
bool
isRawPointerPatch
(
)
;
}
;
typedef
Vector
<
InternalLink
0
SystemAllocPolicy
>
InternalLinkVector
;
struct
SymbolicLinkArray
:
EnumeratedArray
<
SymbolicAddress
SymbolicAddress
:
:
Limit
Uint32Vector
>
{
WASM_DECLARE_SERIALIZABLE
(
SymbolicLinkArray
)
}
;
InternalLinkVector
internalLinks
;
SymbolicLinkArray
symbolicLinks
;
WASM_DECLARE_SERIALIZABLE
(
LinkData
)
}
;
typedef
UniquePtr
<
LinkData
>
UniqueLinkData
;
typedef
UniquePtr
<
const
LinkData
>
UniqueConstLinkData
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
Move
(
module
)
)
field
(
Move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
struct
ElemSegment
{
uint32_t
tableIndex
;
InitExpr
offset
;
Uint32Vector
elemFuncIndices
;
Uint32Vector
elemCodeRangeIndices
;
ElemSegment
(
)
=
default
;
ElemSegment
(
uint32_t
tableIndex
InitExpr
offset
Uint32Vector
&
&
elemFuncIndices
)
:
tableIndex
(
tableIndex
)
offset
(
offset
)
elemFuncIndices
(
Move
(
elemFuncIndices
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
typedef
Vector
<
ElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
class
Module
:
public
JS
:
:
WasmModule
{
const
Assumptions
assumptions_
;
const
Bytes
code_
;
const
LinkData
linkData_
;
const
ImportVector
imports_
;
const
ExportVector
exports_
;
const
DataSegmentVector
dataSegments_
;
const
ElemSegmentVector
elemSegments_
;
const
SharedMetadata
metadata_
;
const
SharedBytes
bytecode_
;
bool
instantiateFunctions
(
JSContext
*
cx
Handle
<
FunctionVector
>
funcImports
)
const
;
bool
instantiateMemory
(
JSContext
*
cx
MutableHandleWasmMemoryObject
memory
)
const
;
bool
instantiateTable
(
JSContext
*
cx
MutableHandleWasmTableObject
table
SharedTableVector
*
tables
)
const
;
bool
initSegments
(
JSContext
*
cx
HandleWasmInstanceObject
instance
Handle
<
FunctionVector
>
funcImports
HandleWasmMemoryObject
memory
const
ValVector
&
globalImports
)
const
;
public
:
Module
(
Assumptions
&
&
assumptions
Bytes
&
&
code
LinkData
&
&
linkData
ImportVector
&
&
imports
ExportVector
&
&
exports
DataSegmentVector
&
&
dataSegments
ElemSegmentVector
&
&
elemSegments
const
Metadata
&
metadata
const
ShareableBytes
&
bytecode
)
:
assumptions_
(
Move
(
assumptions
)
)
code_
(
Move
(
code
)
)
linkData_
(
Move
(
linkData
)
)
imports_
(
Move
(
imports
)
)
exports_
(
Move
(
exports
)
)
dataSegments_
(
Move
(
dataSegments
)
)
elemSegments_
(
Move
(
elemSegments
)
)
metadata_
(
&
metadata
)
bytecode_
(
&
bytecode
)
{
}
~
Module
(
)
override
{
}
const
Metadata
&
metadata
(
)
const
{
return
*
metadata_
;
}
const
ImportVector
&
imports
(
)
const
{
return
imports_
;
}
bool
instantiate
(
JSContext
*
cx
Handle
<
FunctionVector
>
funcImports
HandleWasmTableObject
tableImport
HandleWasmMemoryObject
memoryImport
const
ValVector
&
globalImports
HandleObject
instanceProto
MutableHandleWasmInstanceObject
instanceObj
)
const
;
void
serializedSize
(
size_t
*
bytecodeSize
size_t
*
compiledSize
)
const
override
;
void
serialize
(
uint8_t
*
bytecodeBegin
size_t
bytecodeSize
uint8_t
*
compiledBegin
size_t
compiledSize
)
const
override
;
static
bool
assumptionsMatch
(
const
Assumptions
&
current
const
uint8_t
*
compiledBegin
)
;
static
RefPtr
<
Module
>
deserialize
(
const
uint8_t
*
bytecodeBegin
size_t
bytecodeSize
const
uint8_t
*
compiledBegin
size_t
compiledSize
Metadata
*
maybeMetadata
=
nullptr
)
;
JSObject
*
createObject
(
JSContext
*
cx
)
override
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
ShareableBytes
:
:
SeenSet
*
seenBytes
size_t
*
code
size_t
*
data
)
const
;
bool
extractCode
(
JSContext
*
cx
MutableHandleValue
vp
)
;
}
;
typedef
RefPtr
<
Module
>
SharedModule
;
bool
CompiledModuleAssumptionsMatch
(
PRFileDesc
*
compiled
JS
:
:
BuildIdCharVector
&
&
buildId
)
;
SharedModule
DeserializeModule
(
PRFileDesc
*
bytecode
PRFileDesc
*
maybeCompiled
JS
:
:
BuildIdCharVector
&
&
buildId
UniqueChars
filename
unsigned
line
unsigned
column
)
;
}
}
#
endif
