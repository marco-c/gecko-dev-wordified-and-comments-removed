#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
class
PropertyName
;
namespace
wasm
{
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
MallocSizeOf
;
typedef
Vector
<
uint32_t
0
SystemAllocPolicy
>
Uint32Vector
;
enum
class
ValType
{
I32
I64
F32
F64
I32x4
F32x4
B32x4
Limit
}
;
typedef
Vector
<
ValType
8
SystemAllocPolicy
>
ValTypeVector
;
static
inline
bool
IsSimdType
(
ValType
vt
)
{
return
vt
=
=
ValType
:
:
I32x4
|
|
vt
=
=
ValType
:
:
F32x4
|
|
vt
=
=
ValType
:
:
B32x4
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType_Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType_Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType_Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType_Double
;
case
ValType
:
:
I32x4
:
return
jit
:
:
MIRType_Int32x4
;
case
ValType
:
:
F32x4
:
return
jit
:
:
MIRType_Float32x4
;
case
ValType
:
:
B32x4
:
return
jit
:
:
MIRType_Bool32x4
;
case
ValType
:
:
Limit
:
break
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
class
Val
{
public
:
typedef
int32_t
I32x4
[
4
]
;
typedef
float
F32x4
[
4
]
;
private
:
ValType
type_
;
union
{
uint32_t
i32_
;
uint64_t
i64_
;
float
f32_
;
double
f64_
;
I32x4
i32x4_
;
F32x4
f32x4_
;
}
u
;
public
:
Val
(
)
=
default
;
explicit
Val
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
u
.
i32_
=
i32
;
}
explicit
Val
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
u
.
i64_
=
i64
;
}
explicit
Val
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
u
.
f32_
=
f32
;
}
explicit
Val
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
u
.
f64_
=
f64
;
}
explicit
Val
(
const
I32x4
&
i32x4
ValType
type
=
ValType
:
:
I32x4
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32x4
|
|
type_
=
=
ValType
:
:
B32x4
)
;
memcpy
(
u
.
i32x4_
i32x4
sizeof
(
u
.
i32x4_
)
)
;
}
explicit
Val
(
const
F32x4
&
f32x4
)
:
type_
(
ValType
:
:
F32x4
)
{
memcpy
(
u
.
f32x4_
f32x4
sizeof
(
u
.
f32x4_
)
)
;
}
ValType
type
(
)
const
{
return
type_
;
}
bool
isSimd
(
)
const
{
return
IsSimdType
(
type
(
)
)
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
u
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
u
.
i64_
;
}
float
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
u
.
f32_
;
}
double
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
u
.
f64_
;
}
const
I32x4
&
i32x4
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32x4
|
|
type_
=
=
ValType
:
:
B32x4
)
;
return
u
.
i32x4_
;
}
const
F32x4
&
f32x4
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32x4
)
;
return
u
.
f32x4_
;
}
}
;
enum
class
ExprType
:
uint16_t
{
I32
=
uint8_t
(
ValType
:
:
I32
)
I64
=
uint8_t
(
ValType
:
:
I64
)
F32
=
uint8_t
(
ValType
:
:
F32
)
F64
=
uint8_t
(
ValType
:
:
F64
)
I32x4
=
uint8_t
(
ValType
:
:
I32x4
)
F32x4
=
uint8_t
(
ValType
:
:
F32x4
)
B32x4
=
uint8_t
(
ValType
:
:
B32x4
)
Void
Limit
}
;
static
inline
bool
IsVoid
(
ExprType
et
)
{
return
et
=
=
ExprType
:
:
Void
;
}
static
inline
ValType
NonVoidToValType
(
ExprType
et
)
{
MOZ_ASSERT
(
!
IsVoid
(
et
)
)
;
return
ValType
(
et
)
;
}
static
inline
ExprType
ToExprType
(
ValType
vt
)
{
return
ExprType
(
vt
)
;
}
static
inline
bool
IsSimdType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
false
:
IsSimdType
(
ValType
(
et
)
)
;
}
static
inline
bool
IsSimdBoolType
(
ExprType
vt
)
{
return
vt
=
=
ExprType
:
:
B32x4
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
jit
:
:
MIRType_None
:
ToMIRType
(
ValType
(
et
)
)
;
}
static
inline
const
char
*
ToCString
(
ExprType
type
)
{
switch
(
type
)
{
case
ExprType
:
:
Void
:
return
"
void
"
;
case
ExprType
:
:
I32
:
return
"
i32
"
;
case
ExprType
:
:
I64
:
return
"
i64
"
;
case
ExprType
:
:
F32
:
return
"
f32
"
;
case
ExprType
:
:
F64
:
return
"
f64
"
;
case
ExprType
:
:
I32x4
:
return
"
i32x4
"
;
case
ExprType
:
:
F32x4
:
return
"
f32x4
"
;
case
ExprType
:
:
B32x4
:
return
"
b32x4
"
;
case
ExprType
:
:
Limit
:
;
}
MOZ_CRASH
(
"
bad
expression
type
"
)
;
}
static
inline
const
char
*
ToCString
(
ValType
type
)
{
return
ToCString
(
ToExprType
(
type
)
)
;
}
class
Sig
{
ValTypeVector
args_
;
ExprType
ret_
;
Sig
(
const
Sig
&
)
=
delete
;
Sig
&
operator
=
(
const
Sig
&
)
=
delete
;
public
:
Sig
(
)
:
args_
(
)
ret_
(
ExprType
:
:
Void
)
{
}
Sig
(
Sig
&
&
rhs
)
:
args_
(
Move
(
rhs
.
args_
)
)
ret_
(
rhs
.
ret_
)
{
}
Sig
(
ValTypeVector
&
&
args
ExprType
ret
)
:
args_
(
Move
(
args
)
)
ret_
(
ret
)
{
}
bool
clone
(
const
Sig
&
rhs
)
{
ret_
=
rhs
.
ret_
;
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
return
args_
.
appendAll
(
rhs
.
args_
)
;
}
Sig
&
operator
=
(
Sig
&
&
rhs
)
{
ret_
=
rhs
.
ret_
;
args_
=
Move
(
rhs
.
args_
)
;
return
*
this
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
const
ExprType
&
ret
(
)
const
{
return
ret_
;
}
HashNumber
hash
(
)
const
{
return
AddContainerToHash
(
args_
HashNumber
(
ret_
)
)
;
}
bool
operator
=
=
(
const
Sig
&
rhs
)
const
{
return
ret
(
)
=
=
rhs
.
ret
(
)
&
&
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
;
}
bool
operator
!
=
(
const
Sig
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
struct
SigHashPolicy
{
typedef
const
Sig
&
Lookup
;
static
HashNumber
hash
(
Lookup
sig
)
{
return
sig
.
hash
(
)
;
}
static
bool
match
(
const
Sig
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
struct
DeclaredSig
:
Sig
{
DeclaredSig
(
)
=
default
;
DeclaredSig
(
DeclaredSig
&
&
rhs
)
:
Sig
(
Move
(
rhs
)
)
{
}
explicit
DeclaredSig
(
Sig
&
&
sig
)
:
Sig
(
Move
(
sig
)
)
{
}
void
operator
=
(
Sig
&
&
rhs
)
{
Sig
&
base
=
*
this
;
base
=
Move
(
rhs
)
;
}
}
;
typedef
Vector
<
DeclaredSig
0
SystemAllocPolicy
>
DeclaredSigVector
;
typedef
Vector
<
const
DeclaredSig
*
0
SystemAllocPolicy
>
DeclaredSigPtrVector
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
void
offsetBy
(
uint32_t
offset
)
{
begin
+
=
offset
;
end
+
=
offset
;
}
}
;
struct
ProfilingOffsets
:
Offsets
{
MOZ_IMPLICIT
ProfilingOffsets
(
uint32_t
profilingReturn
=
0
)
:
Offsets
(
)
profilingReturn
(
profilingReturn
)
{
}
uint32_t
profilingEntry
(
)
const
{
return
begin
;
}
uint32_t
profilingReturn
;
void
offsetBy
(
uint32_t
offset
)
{
Offsets
:
:
offsetBy
(
offset
)
;
profilingReturn
+
=
offset
;
}
}
;
struct
FuncOffsets
:
ProfilingOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
uint32_t
nonProfilingEntry
=
0
uint32_t
profilingJump
=
0
uint32_t
profilingEpilogue
=
0
)
:
ProfilingOffsets
(
)
nonProfilingEntry
(
nonProfilingEntry
)
profilingJump
(
profilingJump
)
profilingEpilogue
(
profilingEpilogue
)
{
}
uint32_t
nonProfilingEntry
;
uint32_t
profilingJump
;
uint32_t
profilingEpilogue
;
void
offsetBy
(
uint32_t
offset
)
{
ProfilingOffsets
:
:
offsetBy
(
offset
)
;
nonProfilingEntry
+
=
offset
;
profilingJump
+
=
offset
;
profilingEpilogue
+
=
offset
;
}
}
;
class
CallSiteDesc
{
uint32_t
lineOrBytecode_
:
31
;
uint32_t
kind_
:
1
;
public
:
enum
Kind
{
Relative
Register
}
;
CallSiteDesc
(
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
lineOrBytecode_
=
=
lineOrBytecode
"
must
fit
in
31
bits
"
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
uint32_t
stackDepth_
;
public
:
CallSite
(
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
uint32_t
stackDepth
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
stackDepth_
(
stackDepth
)
{
}
void
setReturnAddressOffset
(
uint32_t
r
)
{
returnAddressOffset_
=
r
;
}
void
offsetReturnAddressBy
(
int32_t
o
)
{
returnAddressOffset_
+
=
o
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
uint32_t
stackDepth
(
)
const
{
return
stackDepth_
;
}
}
;
class
CallSiteAndTarget
:
public
CallSite
{
uint32_t
targetIndex_
;
public
:
CallSiteAndTarget
(
CallSite
cs
uint32_t
targetIndex
)
:
CallSite
(
cs
)
targetIndex_
(
targetIndex
)
{
}
static
const
uint32_t
NOT_INTERNAL
=
UINT32_MAX
;
bool
isInternal
(
)
const
{
return
targetIndex_
!
=
NOT_INTERNAL
;
}
uint32_t
targetIndex
(
)
const
{
MOZ_ASSERT
(
isInternal
(
)
)
;
return
targetIndex_
;
}
}
;
typedef
Vector
<
CallSite
0
SystemAllocPolicy
>
CallSiteVector
;
typedef
Vector
<
CallSiteAndTarget
0
SystemAllocPolicy
>
CallSiteAndTargetVector
;
#
if
defined
(
JS_CODEGEN_X86
)
class
HeapAccess
{
uint32_t
insnOffset_
;
uint8_t
opLength_
;
uint8_t
cmpDelta_
;
public
:
HeapAccess
(
)
=
default
;
static
const
uint32_t
NoLengthCheck
=
UINT32_MAX
;
HeapAccess
(
uint32_t
insnOffset
uint32_t
after
uint32_t
cmp
=
NoLengthCheck
)
{
mozilla
:
:
PodZero
(
this
)
;
insnOffset_
=
insnOffset
;
opLength_
=
after
-
insnOffset
;
cmpDelta_
=
cmp
=
=
NoLengthCheck
?
0
:
insnOffset
-
cmp
;
}
uint32_t
insnOffset
(
)
const
{
return
insnOffset_
;
}
void
setInsnOffset
(
uint32_t
insnOffset
)
{
insnOffset_
=
insnOffset
;
}
void
offsetInsnOffsetBy
(
uint32_t
offset
)
{
insnOffset_
+
=
offset
;
}
void
*
patchHeapPtrImmAt
(
uint8_t
*
code
)
const
{
return
code
+
(
insnOffset_
+
opLength_
)
;
}
bool
hasLengthCheck
(
)
const
{
return
cmpDelta_
>
0
;
}
void
*
patchLengthAt
(
uint8_t
*
code
)
const
{
MOZ_ASSERT
(
hasLengthCheck
(
)
)
;
return
code
+
(
insnOffset_
-
cmpDelta_
)
;
}
}
;
#
elif
defined
(
JS_CODEGEN_X64
)
class
HeapAccess
{
public
:
enum
WhatToDoOnOOB
{
CarryOn
Throw
}
;
private
:
uint32_t
insnOffset_
;
uint8_t
offsetWithinWholeSimdVector_
;
bool
throwOnOOB_
;
uint8_t
cmpDelta_
;
public
:
HeapAccess
(
)
=
default
;
static
const
uint32_t
NoLengthCheck
=
UINT32_MAX
;
HeapAccess
(
uint32_t
insnOffset
WhatToDoOnOOB
oob
uint32_t
cmp
=
NoLengthCheck
uint32_t
offsetWithinWholeSimdVector
=
0
)
{
mozilla
:
:
PodZero
(
this
)
;
insnOffset_
=
insnOffset
;
offsetWithinWholeSimdVector_
=
offsetWithinWholeSimdVector
;
throwOnOOB_
=
oob
=
=
Throw
;
cmpDelta_
=
cmp
=
=
NoLengthCheck
?
0
:
insnOffset
-
cmp
;
MOZ_ASSERT
(
offsetWithinWholeSimdVector_
=
=
offsetWithinWholeSimdVector
)
;
}
uint32_t
insnOffset
(
)
const
{
return
insnOffset_
;
}
void
setInsnOffset
(
uint32_t
insnOffset
)
{
insnOffset_
=
insnOffset
;
}
void
offsetInsnOffsetBy
(
uint32_t
offset
)
{
insnOffset_
+
=
offset
;
}
bool
throwOnOOB
(
)
const
{
return
throwOnOOB_
;
}
uint32_t
offsetWithinWholeSimdVector
(
)
const
{
return
offsetWithinWholeSimdVector_
;
}
bool
hasLengthCheck
(
)
const
{
return
cmpDelta_
>
0
;
}
void
*
patchLengthAt
(
uint8_t
*
code
)
const
{
MOZ_ASSERT
(
hasLengthCheck
(
)
)
;
return
code
+
(
insnOffset_
-
cmpDelta_
)
;
}
}
;
#
elif
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
|
|
\
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
class
HeapAccess
{
uint32_t
insnOffset_
;
public
:
HeapAccess
(
)
=
default
;
explicit
HeapAccess
(
uint32_t
insnOffset
)
:
insnOffset_
(
insnOffset
)
{
}
uint32_t
insnOffset
(
)
const
{
return
insnOffset_
;
}
void
setInsnOffset
(
uint32_t
insnOffset
)
{
insnOffset_
=
insnOffset
;
}
void
offsetInsnOffsetBy
(
uint32_t
offset
)
{
insnOffset_
+
=
offset
;
}
}
;
#
elif
defined
(
JS_CODEGEN_NONE
)
class
HeapAccess
{
public
:
void
offsetInsnOffsetBy
(
uint32_t
)
{
MOZ_CRASH
(
)
;
}
uint32_t
insnOffset
(
)
const
{
MOZ_CRASH
(
)
;
}
}
;
#
endif
typedef
Vector
<
HeapAccess
0
SystemAllocPolicy
>
HeapAccessVector
;
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
AtomicCmpXchg
AtomicXchg
AtomicFetchAdd
AtomicFetchSub
AtomicFetchAnd
AtomicFetchOr
AtomicFetchXor
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
ExpD
LogD
PowD
ATan2D
Runtime
RuntimeInterruptUint32
StackLimit
ReportOverRecursed
OnOutOfBounds
OnImpreciseConversion
BadIndirectCall
HandleExecutionInterrupt
InvokeImport_Void
InvokeImport_I32
InvokeImport_F64
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
Limit
}
;
void
*
AddressOf
(
SymbolicAddress
imm
ExclusiveContext
*
cx
)
;
enum
class
JumpTarget
{
StackOverflow
OutOfBounds
ConversionError
BadIndirectCall
Throw
Limit
}
;
typedef
EnumeratedArray
<
JumpTarget
JumpTarget
:
:
Limit
Uint32Vector
>
JumpSiteArray
;
struct
CompileArgs
{
bool
useSignalHandlersForOOB
;
bool
useSignalHandlersForInterrupt
;
CompileArgs
(
)
=
default
;
explicit
CompileArgs
(
ExclusiveContext
*
cx
)
;
bool
operator
=
=
(
CompileArgs
rhs
)
const
;
bool
operator
!
=
(
CompileArgs
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
static
const
unsigned
ActivationGlobalDataOffset
=
0
;
static
const
unsigned
HeapGlobalDataOffset
=
ActivationGlobalDataOffset
+
sizeof
(
void
*
)
;
static
const
unsigned
NaN64GlobalDataOffset
=
HeapGlobalDataOffset
+
sizeof
(
void
*
)
;
static
const
unsigned
NaN32GlobalDataOffset
=
NaN64GlobalDataOffset
+
sizeof
(
double
)
;
static
const
unsigned
InitialGlobalDataBytes
=
NaN32GlobalDataOffset
+
sizeof
(
float
)
;
}
}
#
endif
