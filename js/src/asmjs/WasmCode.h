#
ifndef
wasm_code_h
#
define
wasm_code_h
#
include
"
asmjs
/
WasmTypes
.
h
"
namespace
js
{
struct
AsmJSMetadata
;
namespace
wasm
{
struct
LinkData
;
struct
Metadata
;
class
CodeSegment
;
typedef
UniquePtr
<
CodeSegment
>
UniqueCodeSegment
;
class
CodeSegment
{
uint8_t
*
bytes_
;
uint32_t
functionCodeLength_
;
uint32_t
codeLength_
;
uint32_t
globalDataLength_
;
uint8_t
*
interruptCode_
;
uint8_t
*
outOfBoundsCode_
;
bool
profilingEnabled_
;
CodeSegment
(
)
{
PodZero
(
this
)
;
}
template
<
class
>
friend
struct
js
:
:
MallocProvider
;
CodeSegment
(
const
CodeSegment
&
)
=
delete
;
CodeSegment
(
CodeSegment
&
&
)
=
delete
;
void
operator
=
(
const
CodeSegment
&
)
=
delete
;
void
operator
=
(
CodeSegment
&
&
)
=
delete
;
public
:
static
UniqueCodeSegment
create
(
ExclusiveContext
*
cx
const
Bytes
&
code
const
LinkData
&
linkData
const
Metadata
&
metadata
uint8_t
*
heapBase
uint32_t
heapLength
)
;
~
CodeSegment
(
)
;
uint8_t
*
code
(
)
const
{
return
bytes_
;
}
uint8_t
*
globalData
(
)
const
{
return
bytes_
+
codeLength_
;
}
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
uint32_t
globalDataLength
(
)
const
{
return
globalDataLength_
;
}
uint32_t
totalLength
(
)
const
{
return
codeLength_
+
globalDataLength_
;
}
uint8_t
*
interruptCode
(
)
const
{
return
interruptCode_
;
}
uint8_t
*
outOfBoundsCode
(
)
const
{
return
outOfBoundsCode_
;
}
bool
containsFunctionPC
(
void
*
pc
)
const
{
return
pc
>
=
code
(
)
&
&
pc
<
(
code
(
)
+
functionCodeLength_
)
;
}
bool
containsCodePC
(
void
*
pc
)
const
{
return
pc
>
=
code
(
)
&
&
pc
<
(
code
(
)
+
codeLength_
)
;
}
WASM_DECLARE_SERIALIZABLE
(
CodeSegment
)
}
;
template
<
class
T
>
struct
ShareableBase
:
RefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
return
0
;
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
ShareableBytes
:
ShareableBase
<
ShareableBytes
>
{
Bytes
bytes
;
size_t
sizeOfExcludingThis
(
MallocSizeOf
m
)
const
{
return
bytes
.
sizeOfExcludingThis
(
m
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
bytes
.
begin
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
bytes
.
end
(
)
;
}
bool
append
(
const
uint8_t
*
p
uint32_t
ct
)
{
return
bytes
.
append
(
p
ct
)
;
}
}
;
typedef
RefPtr
<
ShareableBytes
>
MutableBytes
;
typedef
RefPtr
<
const
ShareableBytes
>
SharedBytes
;
class
Export
{
Sig
sig_
;
struct
CacheablePod
{
uint32_t
funcIndex_
;
uint32_t
stubOffset_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
Sig
&
&
sig
uint32_t
funcIndex
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
funcIndex_
=
funcIndex
;
pod
.
stubOffset_
=
UINT32_MAX
;
}
void
initStubOffset
(
uint32_t
stubOffset
)
{
MOZ_ASSERT
(
pod
.
stubOffset_
=
=
UINT32_MAX
)
;
pod
.
stubOffset_
=
stubOffset
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
funcIndex
(
)
const
{
return
pod
.
funcIndex_
;
}
uint32_t
stubOffset
(
)
const
{
MOZ_ASSERT
(
pod
.
stubOffset_
!
=
UINT32_MAX
)
;
return
pod
.
stubOffset_
;
}
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
class
Import
{
Sig
sig_
;
struct
CacheablePod
{
uint32_t
exitGlobalDataOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
}
pod
;
public
:
Import
(
)
=
default
;
Import
(
Sig
&
&
sig
uint32_t
exitGlobalDataOffset
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
exitGlobalDataOffset_
=
exitGlobalDataOffset
;
pod
.
interpExitCodeOffset_
=
0
;
pod
.
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
interpExitCodeOffset_
)
;
pod
.
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
jitExitCodeOffset_
)
;
pod
.
jitExitCodeOffset_
=
off
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
exitGlobalDataOffset
(
)
const
{
return
pod
.
exitGlobalDataOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
pod
.
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
pod
.
jitExitCodeOffset_
;
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
CodeRange
{
public
:
enum
Kind
{
Function
Entry
ImportJitExit
ImportInterpExit
Inline
CallThunk
}
;
private
:
uint32_t
begin_
;
uint32_t
profilingReturn_
;
uint32_t
end_
;
uint32_t
funcIndex_
;
uint32_t
funcLineOrBytecode_
;
uint8_t
funcBeginToTableEntry_
;
uint8_t
funcBeginToTableProfilingJump_
;
uint8_t
funcBeginToNonProfilingEntry_
;
uint8_t
funcProfilingJumpToProfilingReturn_
;
uint8_t
funcProfilingEpilogueToProfilingReturn_
;
Kind
kind_
:
8
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
ProfilingOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
;
}
bool
isInline
(
)
const
{
return
kind
(
)
=
=
Inline
;
}
uint32_t
profilingReturn
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
|
|
isImportExit
(
)
)
;
return
profilingReturn_
;
}
uint32_t
funcProfilingEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin
(
)
;
}
uint32_t
funcTableEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
funcBeginToTableEntry_
;
}
uint32_t
funcTableProfilingJump
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
funcBeginToTableProfilingJump_
;
}
uint32_t
funcNonProfilingEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
funcBeginToNonProfilingEntry_
;
}
uint32_t
funcProfilingJump
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
profilingReturn_
-
funcProfilingJumpToProfilingReturn_
;
}
uint32_t
funcProfilingEpilogue
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
profilingReturn_
-
funcProfilingEpilogueToProfilingReturn_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
funcIndex_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
funcLineOrBytecode_
;
}
struct
PC
{
size_t
offset
;
explicit
PC
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
struct
CallThunk
{
uint32_t
offset
;
union
{
uint32_t
funcIndex
;
uint32_t
codeRangeIndex
;
}
u
;
CallThunk
(
uint32_t
offset
uint32_t
funcIndex
)
:
offset
(
offset
)
{
u
.
funcIndex
=
funcIndex
;
}
CallThunk
(
)
=
default
;
}
;
WASM_DECLARE_POD_VECTOR
(
CallThunk
CallThunkVector
)
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
Move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
enum
class
HeapUsage
{
None
=
false
Unshared
=
1
Shared
=
2
}
;
static
inline
bool
UsesHeap
(
HeapUsage
heapUsage
)
{
return
bool
(
heapUsage
)
;
}
struct
MetadataCacheablePod
{
ModuleKind
kind
;
HeapUsage
heapUsage
;
CompileArgs
compileArgs
;
MetadataCacheablePod
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
}
;
struct
Metadata
:
ShareableBase
<
Metadata
>
MetadataCacheablePod
{
virtual
~
Metadata
(
)
{
}
MetadataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
MetadataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
ImportVector
imports
;
ExportVector
exports
;
MemoryAccessVector
memoryAccesses
;
BoundsCheckVector
boundsChecks
;
CodeRangeVector
codeRanges
;
CallSiteVector
callSites
;
CallThunkVector
callThunks
;
CacheableCharsVector
funcNames
;
CacheableChars
filename
;
bool
usesHeap
(
)
const
{
return
UsesHeap
(
heapUsage
)
;
}
bool
hasSharedHeap
(
)
const
{
return
heapUsage
=
=
HeapUsage
:
:
Shared
;
}
const
char
*
getFuncName
(
ExclusiveContext
*
cx
uint32_t
funcIndex
UniqueChars
*
owner
)
const
;
JSAtom
*
getFuncAtom
(
JSContext
*
cx
uint32_t
funcIndex
)
const
;
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
const
AsmJSMetadata
&
asAsmJS
(
)
const
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
*
(
const
AsmJSMetadata
*
)
this
;
}
virtual
bool
mutedErrors
(
)
const
{
return
false
;
}
virtual
const
char16_t
*
displayURL
(
)
const
{
return
nullptr
;
}
virtual
ScriptSource
*
maybeScriptSource
(
)
const
{
return
nullptr
;
}
WASM_DECLARE_SERIALIZABLE_VIRTUAL
(
Metadata
)
;
}
;
typedef
RefPtr
<
Metadata
>
MutableMetadata
;
typedef
RefPtr
<
const
Metadata
>
SharedMetadata
;
}
}
#
endif
