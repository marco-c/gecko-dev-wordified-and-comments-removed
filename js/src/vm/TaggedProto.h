#
ifndef
vm_TaggedProto_h
#
define
vm_TaggedProto_h
#
include
"
gc
/
Tracer
.
h
"
namespace
js
{
class
TaggedProto
:
public
JS
:
:
Traceable
{
public
:
static
JSObject
*
const
LazyProto
;
TaggedProto
(
)
:
proto
(
nullptr
)
{
}
explicit
TaggedProto
(
JSObject
*
proto
)
:
proto
(
proto
)
{
}
uintptr_t
toWord
(
)
const
{
return
uintptr_t
(
proto
)
;
}
bool
isLazy
(
)
const
{
return
proto
=
=
LazyProto
;
}
bool
isObject
(
)
const
{
return
uintptr_t
(
proto
)
>
uintptr_t
(
TaggedProto
:
:
LazyProto
)
;
}
JSObject
*
toObject
(
)
const
{
MOZ_ASSERT
(
isObject
(
)
)
;
return
proto
;
}
JSObject
*
toObjectOrNull
(
)
const
{
MOZ_ASSERT
(
!
proto
|
|
isObject
(
)
)
;
return
proto
;
}
JSObject
*
raw
(
)
const
{
return
proto
;
}
bool
operator
=
=
(
const
TaggedProto
&
other
)
const
{
return
proto
=
=
other
.
proto
;
}
bool
operator
!
=
(
const
TaggedProto
&
other
)
const
{
return
proto
!
=
other
.
proto
;
}
static
void
trace
(
TaggedProto
*
protop
JSTracer
*
trc
)
{
TraceManuallyBarrieredEdge
(
trc
protop
"
TaggedProto
"
)
;
}
private
:
JSObject
*
proto
;
}
;
template
<
>
struct
GCMethods
<
TaggedProto
>
{
static
TaggedProto
initial
(
)
{
return
TaggedProto
(
)
;
}
}
;
template
<
>
struct
InternalGCMethods
<
TaggedProto
>
{
static
void
preBarrier
(
TaggedProto
&
proto
)
;
static
void
postBarrier
(
TaggedProto
*
vp
TaggedProto
prev
TaggedProto
next
)
;
static
bool
isMarkableTaggedPointer
(
TaggedProto
proto
)
{
return
proto
.
isObject
(
)
;
}
static
bool
isMarkable
(
TaggedProto
proto
)
{
return
proto
.
isObject
(
)
;
}
}
;
template
<
class
Outer
>
class
TaggedProtoOperations
{
const
TaggedProto
&
value
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
uintptr_t
toWord
(
)
const
{
return
value
(
)
.
toWord
(
)
;
}
inline
bool
isLazy
(
)
const
{
return
value
(
)
.
isLazy
(
)
;
}
inline
bool
isObject
(
)
const
{
return
value
(
)
.
isObject
(
)
;
}
inline
JSObject
*
toObject
(
)
const
{
return
value
(
)
.
toObject
(
)
;
}
inline
JSObject
*
toObjectOrNull
(
)
const
{
return
value
(
)
.
toObjectOrNull
(
)
;
}
JSObject
*
raw
(
)
const
{
return
value
(
)
.
raw
(
)
;
}
}
;
template
<
>
class
HandleBase
<
TaggedProto
>
:
public
TaggedProtoOperations
<
Handle
<
TaggedProto
>
>
{
}
;
template
<
>
class
RootedBase
<
TaggedProto
>
:
public
TaggedProtoOperations
<
Rooted
<
TaggedProto
>
>
{
}
;
template
<
>
class
BarrieredBaseMixins
<
TaggedProto
>
:
public
TaggedProtoOperations
<
HeapPtr
<
TaggedProto
>
>
{
}
;
template
<
typename
F
typename
.
.
.
Args
>
auto
DispatchTyped
(
F
f
TaggedProto
&
proto
Args
&
&
.
.
.
args
)
-
>
decltype
(
f
(
static_cast
<
JSObject
*
>
(
nullptr
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
{
if
(
proto
.
isObject
(
)
)
return
f
(
proto
.
toObject
(
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
return
F
:
:
defaultValue
(
proto
)
;
}
inline
Handle
<
TaggedProto
>
AsTaggedProto
(
HandleObject
obj
)
{
static_assert
(
sizeof
(
JSObject
*
)
=
=
sizeof
(
TaggedProto
)
"
TaggedProto
must
be
binary
compatible
with
JSObject
"
)
;
return
Handle
<
TaggedProto
>
:
:
fromMarkedLocation
(
reinterpret_cast
<
TaggedProto
const
*
>
(
obj
.
address
(
)
)
)
;
}
}
#
endif
