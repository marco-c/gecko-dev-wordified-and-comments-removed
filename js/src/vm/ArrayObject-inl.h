#
ifndef
vm_ArrayObject_inl_h
#
define
vm_ArrayObject_inl_h
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
namespace
js
{
MOZ_ALWAYS_INLINE
ArrayObject
*
ArrayObject
:
:
create
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
Handle
<
SharedShape
*
>
shape
uint32_t
length
uint32_t
slotSpan
AutoSetNewObjectMetadata
&
metadata
gc
:
:
AllocSite
*
site
)
{
debugCheckNewObject
(
shape
kind
heap
)
;
const
JSClass
*
clasp
=
&
ArrayObject
:
:
class_
;
MOZ_ASSERT
(
shape
)
;
MOZ_ASSERT
(
shape
-
>
getObjectClass
(
)
=
=
clasp
)
;
MOZ_ASSERT
(
clasp
-
>
isNativeObject
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
hasFinalize
(
)
)
;
MOZ_ASSERT
(
shape
-
>
slotSpan
(
)
=
=
slotSpan
)
;
MOZ_ASSERT
(
shape
-
>
numFixedSlots
(
)
=
=
0
)
;
size_t
nDynamicSlots
=
calculateDynamicSlots
(
0
slotSpan
clasp
)
;
ArrayObject
*
aobj
=
cx
-
>
newCell
<
ArrayObject
>
(
kind
heap
clasp
site
)
;
if
(
!
aobj
)
{
return
nullptr
;
}
aobj
-
>
initShape
(
shape
)
;
aobj
-
>
initFixedElements
(
kind
length
)
;
if
(
!
nDynamicSlots
)
{
aobj
-
>
initEmptyDynamicSlots
(
)
;
}
else
if
(
!
aobj
-
>
allocateInitialSlots
(
cx
nDynamicSlots
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
aobj
)
;
if
(
slotSpan
>
0
)
{
aobj
-
>
initDynamicSlots
(
slotSpan
)
;
}
gc
:
:
gcprobes
:
:
CreateObject
(
aobj
)
;
return
aobj
;
}
inline
DenseElementResult
ArrayObject
:
:
addDenseElementNoLengthChange
(
JSContext
*
cx
uint32_t
index
const
Value
&
val
)
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
if
(
index
>
=
length
(
)
|
|
containsDenseElement
(
index
)
|
|
isIndexed
(
)
)
{
return
DenseElementResult
:
:
Incomplete
;
}
DenseElementResult
res
=
ensureDenseElements
(
cx
index
1
)
;
if
(
MOZ_UNLIKELY
(
res
!
=
DenseElementResult
:
:
Success
)
)
{
return
res
;
}
initDenseElement
(
index
val
)
;
return
DenseElementResult
:
:
Success
;
}
}
#
endif
