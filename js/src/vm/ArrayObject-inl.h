#
ifndef
vm_ArrayObject_inl_h
#
define
vm_ArrayObject_inl_h
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectGroup
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
namespace
js
{
inline
ArrayObject
*
ArrayObject
:
:
createArrayInternal
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
HandleShape
shape
HandleObjectGroup
group
AutoSetNewObjectMetadata
&
)
{
const
JSClass
*
clasp
=
group
-
>
clasp
(
)
;
MOZ_ASSERT
(
shape
&
&
group
)
;
MOZ_ASSERT
(
clasp
=
=
shape
-
>
getObjectClass
(
)
)
;
MOZ_ASSERT
(
clasp
=
=
&
ArrayObject
:
:
class_
)
;
MOZ_ASSERT_IF
(
clasp
-
>
hasFinalize
(
)
heap
=
=
gc
:
:
TenuredHeap
)
;
MOZ_ASSERT
(
shape
-
>
numFixedSlots
(
)
=
=
0
)
;
size_t
nDynamicSlots
=
calculateDynamicSlots
(
0
shape
-
>
slotSpan
(
)
clasp
)
;
JSObject
*
obj
=
js
:
:
AllocateObject
(
cx
kind
nDynamicSlots
heap
clasp
)
;
if
(
!
obj
)
{
return
nullptr
;
}
ArrayObject
*
aobj
=
static_cast
<
ArrayObject
*
>
(
obj
)
;
aobj
-
>
initGroup
(
group
)
;
aobj
-
>
initShape
(
shape
)
;
if
(
!
nDynamicSlots
)
{
aobj
-
>
initEmptyDynamicSlots
(
)
;
}
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
cx
aobj
)
;
return
aobj
;
}
inline
ArrayObject
*
ArrayObject
:
:
finishCreateArray
(
ArrayObject
*
obj
HandleShape
shape
AutoSetNewObjectMetadata
&
metadata
)
{
size_t
span
=
shape
-
>
slotSpan
(
)
;
if
(
span
)
{
obj
-
>
initializeSlotRange
(
0
span
)
;
}
gc
:
:
gcprobes
:
:
CreateObject
(
obj
)
;
return
obj
;
}
inline
ArrayObject
*
ArrayObject
:
:
createArray
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
HandleShape
shape
HandleObjectGroup
group
uint32_t
length
AutoSetNewObjectMetadata
&
metadata
)
{
ArrayObject
*
obj
=
createArrayInternal
(
cx
kind
heap
shape
group
metadata
)
;
if
(
!
obj
)
{
return
nullptr
;
}
uint32_t
capacity
=
gc
:
:
GetGCKindSlots
(
kind
)
-
ObjectElements
:
:
VALUES_PER_HEADER
;
obj
-
>
setFixedElements
(
)
;
new
(
obj
-
>
getElementsHeader
(
)
)
ObjectElements
(
capacity
length
)
;
return
finishCreateArray
(
obj
shape
metadata
)
;
}
inline
ArrayObject
*
ArrayObject
:
:
createCopyOnWriteArray
(
JSContext
*
cx
gc
:
:
InitialHeap
heap
HandleArrayObject
sharedElementsOwner
)
{
MOZ_ASSERT
(
sharedElementsOwner
-
>
getElementsHeader
(
)
-
>
isCopyOnWrite
(
)
)
;
MOZ_ASSERT
(
sharedElementsOwner
-
>
getElementsHeader
(
)
-
>
ownerObject
(
)
=
=
sharedElementsOwner
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
AllocKind
:
:
OBJECT0_BACKGROUND
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
RootedShape
shape
(
cx
sharedElementsOwner
-
>
lastProperty
(
)
)
;
RootedObjectGroup
group
(
cx
sharedElementsOwner
-
>
group
(
)
)
;
ArrayObject
*
obj
=
createArrayInternal
(
cx
kind
heap
shape
group
metadata
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
elements_
=
sharedElementsOwner
-
>
getDenseElementsAllowCopyOnWrite
(
)
;
return
finishCreateArray
(
obj
shape
metadata
)
;
}
}
#
endif
