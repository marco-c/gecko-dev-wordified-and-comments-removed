#
ifndef
vm_ArrayObject_inl_h
#
define
vm_ArrayObject_inl_h
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
namespace
js
{
inline
ArrayObject
*
ArrayObject
:
:
create
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
HandleShape
shape
uint32_t
length
AutoSetNewObjectMetadata
&
metadata
gc
:
:
AllocSite
*
site
)
{
debugCheckNewObject
(
shape
kind
heap
)
;
const
JSClass
*
clasp
=
&
ArrayObject
:
:
class_
;
MOZ_ASSERT
(
shape
)
;
MOZ_ASSERT
(
shape
-
>
getObjectClass
(
)
=
=
clasp
)
;
MOZ_ASSERT
(
clasp
-
>
isNativeObject
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
hasFinalize
(
)
)
;
MOZ_ASSERT
(
shape
-
>
numFixedSlots
(
)
=
=
0
)
;
size_t
slotSpan
=
shape
-
>
slotSpan
(
)
;
size_t
nDynamicSlots
=
calculateDynamicSlots
(
0
slotSpan
clasp
)
;
JSObject
*
obj
=
js
:
:
AllocateObject
(
cx
kind
nDynamicSlots
heap
clasp
site
)
;
if
(
!
obj
)
{
return
nullptr
;
}
ArrayObject
*
aobj
=
static_cast
<
ArrayObject
*
>
(
obj
)
;
aobj
-
>
initShape
(
shape
)
;
if
(
!
nDynamicSlots
)
{
aobj
-
>
initEmptyDynamicSlots
(
)
;
}
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
cx
aobj
)
;
uint32_t
capacity
=
gc
:
:
GetGCKindSlots
(
kind
)
-
ObjectElements
:
:
VALUES_PER_HEADER
;
aobj
-
>
setFixedElements
(
)
;
new
(
aobj
-
>
getElementsHeader
(
)
)
ObjectElements
(
capacity
length
)
;
if
(
slotSpan
>
0
)
{
aobj
-
>
initializeSlotRange
(
0
slotSpan
)
;
}
gc
:
:
gcprobes
:
:
CreateObject
(
aobj
)
;
return
aobj
;
}
}
#
endif
