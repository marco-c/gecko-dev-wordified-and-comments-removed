#
ifndef
vm_Interpreter_h
#
define
vm_Interpreter_h
#
include
"
jsiter
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
class
ScopeIter
;
extern
bool
BoxNonStrictThis
(
JSContext
*
cx
const
CallReceiver
&
call
)
;
extern
bool
BoxNonStrictThis
(
JSContext
*
cx
HandleValue
thisv
MutableHandleValue
vp
)
;
extern
bool
GetFunctionThis
(
JSContext
*
cx
AbstractFramePtr
frame
MutableHandleValue
res
)
;
extern
bool
GetNonSyntacticGlobalThis
(
JSContext
*
cx
HandleObject
scopeChain
MutableHandleValue
res
)
;
extern
bool
ReportIsNotFunction
(
JSContext
*
cx
HandleValue
v
int
numToSkip
MaybeConstruct
construct
=
NO_CONSTRUCT
)
;
extern
JSObject
*
ValueToCallable
(
JSContext
*
cx
HandleValue
v
int
numToSkip
=
-
1
MaybeConstruct
construct
=
NO_CONSTRUCT
)
;
extern
bool
Invoke
(
JSContext
*
cx
const
CallArgs
&
args
MaybeConstruct
construct
=
NO_CONSTRUCT
)
;
extern
bool
Invoke
(
JSContext
*
cx
const
Value
&
thisv
const
Value
&
fval
unsigned
argc
const
Value
*
argv
MutableHandleValue
rval
)
;
extern
bool
InvokeGetter
(
JSContext
*
cx
const
Value
&
thisv
Value
fval
MutableHandleValue
rval
)
;
extern
bool
InvokeSetter
(
JSContext
*
cx
const
Value
&
thisv
Value
fval
HandleValue
v
)
;
extern
bool
Construct
(
JSContext
*
cx
HandleValue
fval
const
ConstructArgs
&
args
HandleValue
newTarget
MutableHandleValue
rval
)
;
extern
bool
InternalConstructWithProvidedThis
(
JSContext
*
cx
HandleValue
fval
HandleValue
thisv
const
ConstructArgs
&
args
HandleValue
newTarget
MutableHandleValue
rval
)
;
extern
bool
ExecuteKernel
(
JSContext
*
cx
HandleScript
script
JSObject
&
scopeChain
const
Value
&
newTargetVal
AbstractFramePtr
evalInFrame
Value
*
result
)
;
extern
bool
Execute
(
JSContext
*
cx
HandleScript
script
JSObject
&
scopeChain
Value
*
rval
)
;
class
ExecuteState
;
class
InvokeState
;
class
RunState
{
protected
:
enum
Kind
{
Execute
Invoke
}
;
Kind
kind_
;
RootedScript
script_
;
explicit
RunState
(
JSContext
*
cx
Kind
kind
JSScript
*
script
)
:
kind_
(
kind
)
script_
(
cx
script
)
{
}
public
:
bool
isExecute
(
)
const
{
return
kind_
=
=
Execute
;
}
bool
isInvoke
(
)
const
{
return
kind_
=
=
Invoke
;
}
ExecuteState
*
asExecute
(
)
const
{
MOZ_ASSERT
(
isExecute
(
)
)
;
return
(
ExecuteState
*
)
this
;
}
InvokeState
*
asInvoke
(
)
const
{
MOZ_ASSERT
(
isInvoke
(
)
)
;
return
(
InvokeState
*
)
this
;
}
JS
:
:
HandleScript
script
(
)
const
{
return
script_
;
}
virtual
InterpreterFrame
*
pushInterpreterFrame
(
JSContext
*
cx
)
=
0
;
virtual
void
setReturnValue
(
Value
v
)
=
0
;
bool
maybeCreateThisForConstructor
(
JSContext
*
cx
)
;
private
:
RunState
(
const
RunState
&
other
)
=
delete
;
RunState
(
const
ExecuteState
&
other
)
=
delete
;
RunState
(
const
InvokeState
&
other
)
=
delete
;
void
operator
=
(
const
RunState
&
other
)
=
delete
;
}
;
class
ExecuteState
:
public
RunState
{
RootedValue
newTargetValue_
;
RootedObject
scopeChain_
;
AbstractFramePtr
evalInFrame_
;
Value
*
result_
;
public
:
ExecuteState
(
JSContext
*
cx
JSScript
*
script
const
Value
&
newTargetValue
JSObject
&
scopeChain
AbstractFramePtr
evalInFrame
Value
*
result
)
:
RunState
(
cx
Execute
script
)
newTargetValue_
(
cx
newTargetValue
)
scopeChain_
(
cx
&
scopeChain
)
evalInFrame_
(
evalInFrame
)
result_
(
result
)
{
}
Value
newTarget
(
)
{
return
newTargetValue_
;
}
JSObject
*
scopeChain
(
)
const
{
return
scopeChain_
;
}
bool
isDebuggerEval
(
)
const
{
return
!
!
evalInFrame_
;
}
virtual
InterpreterFrame
*
pushInterpreterFrame
(
JSContext
*
cx
)
;
virtual
void
setReturnValue
(
Value
v
)
{
if
(
result_
)
*
result_
=
v
;
}
}
;
class
InvokeState
:
public
RunState
{
const
CallArgs
&
args_
;
MaybeConstruct
construct_
;
bool
createSingleton_
;
public
:
InvokeState
(
JSContext
*
cx
const
CallArgs
&
args
MaybeConstruct
construct
)
:
RunState
(
cx
Invoke
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
.
nonLazyScript
(
)
)
args_
(
args
)
construct_
(
construct
)
createSingleton_
(
false
)
{
}
bool
createSingleton
(
)
const
{
return
createSingleton_
;
}
void
setCreateSingleton
(
)
{
createSingleton_
=
true
;
}
bool
constructing
(
)
const
{
return
construct_
;
}
const
CallArgs
&
args
(
)
const
{
return
args_
;
}
virtual
InterpreterFrame
*
pushInterpreterFrame
(
JSContext
*
cx
)
;
virtual
void
setReturnValue
(
Value
v
)
{
args_
.
rval
(
)
.
set
(
v
)
;
}
}
;
extern
bool
RunScript
(
JSContext
*
cx
RunState
&
state
)
;
extern
bool
StrictlyEqual
(
JSContext
*
cx
HandleValue
lval
HandleValue
rval
bool
*
equal
)
;
extern
bool
LooselyEqual
(
JSContext
*
cx
HandleValue
lval
HandleValue
rval
bool
*
equal
)
;
extern
bool
SameValue
(
JSContext
*
cx
HandleValue
v1
HandleValue
v2
bool
*
same
)
;
extern
JSType
TypeOfObject
(
JSObject
*
obj
)
;
extern
JSType
TypeOfValue
(
const
Value
&
v
)
;
extern
bool
HasInstance
(
JSContext
*
cx
HandleObject
obj
HandleValue
v
bool
*
bp
)
;
extern
void
UnwindScope
(
JSContext
*
cx
ScopeIter
&
si
jsbytecode
*
pc
)
;
extern
void
UnwindAllScopesInFrame
(
JSContext
*
cx
ScopeIter
&
si
)
;
extern
jsbytecode
*
UnwindScopeToTryPc
(
JSScript
*
script
JSTryNote
*
tn
)
;
template
<
class
StackDepthOp
>
class
MOZ_STACK_CLASS
TryNoteIter
{
RootedScript
script_
;
uint32_t
pcOffset_
;
JSTryNote
*
tn_
;
JSTryNote
*
tnEnd_
;
StackDepthOp
getStackDepth_
;
void
settle
(
)
{
for
(
;
tn_
!
=
tnEnd_
;
+
+
tn_
)
{
if
(
pcOffset_
-
tn_
-
>
start
>
=
tn_
-
>
length
)
continue
;
if
(
tn_
-
>
stackDepth
<
=
getStackDepth_
(
)
)
break
;
}
}
public
:
TryNoteIter
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
StackDepthOp
getStackDepth
)
:
script_
(
cx
script
)
pcOffset_
(
pc
-
script
-
>
main
(
)
)
getStackDepth_
(
getStackDepth
)
{
if
(
script
-
>
hasTrynotes
(
)
)
{
tn_
=
script
-
>
trynotes
(
)
-
>
vector
;
tnEnd_
=
tn_
+
script
-
>
trynotes
(
)
-
>
length
;
}
else
{
tn_
=
tnEnd_
=
nullptr
;
}
settle
(
)
;
}
void
operator
+
+
(
)
{
+
+
tn_
;
settle
(
)
;
}
bool
done
(
)
const
{
return
tn_
=
=
tnEnd_
;
}
JSTryNote
*
operator
*
(
)
const
{
return
tn_
;
}
}
;
bool
HandleClosingGeneratorReturn
(
JSContext
*
cx
AbstractFramePtr
frame
bool
ok
)
;
bool
Throw
(
JSContext
*
cx
HandleValue
v
)
;
bool
ThrowingOperation
(
JSContext
*
cx
HandleValue
v
)
;
bool
GetProperty
(
JSContext
*
cx
HandleValue
value
HandlePropertyName
name
MutableHandleValue
vp
)
;
bool
GetScopeName
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
MutableHandleValue
vp
)
;
bool
GetScopeNameForTypeOf
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
MutableHandleValue
vp
)
;
JSObject
*
Lambda
(
JSContext
*
cx
HandleFunction
fun
HandleObject
parent
)
;
JSObject
*
LambdaArrow
(
JSContext
*
cx
HandleFunction
fun
HandleObject
parent
HandleValue
newTargetv
)
;
bool
GetElement
(
JSContext
*
cx
MutableHandleValue
lref
HandleValue
rref
MutableHandleValue
res
)
;
bool
CallElement
(
JSContext
*
cx
MutableHandleValue
lref
HandleValue
rref
MutableHandleValue
res
)
;
bool
SetObjectElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
index
HandleValue
value
bool
strict
)
;
bool
SetObjectElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
index
HandleValue
value
bool
strict
HandleScript
script
jsbytecode
*
pc
)
;
bool
SetObjectElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
index
HandleValue
value
HandleValue
receiver
bool
strict
HandleScript
script
jsbytecode
*
pc
)
;
bool
InitElementArray
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
uint32_t
index
HandleValue
value
)
;
bool
AddValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
SubValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
MulValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
DivValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
ModValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
UrshValues
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
MutableHandleValue
res
)
;
bool
AtomicIsLockFree
(
JSContext
*
cx
HandleValue
in
int
*
out
)
;
template
<
bool
strict
>
bool
DeletePropertyJit
(
JSContext
*
ctx
HandleValue
val
HandlePropertyName
name
bool
*
bv
)
;
template
<
bool
strict
>
bool
DeleteElementJit
(
JSContext
*
cx
HandleValue
val
HandleValue
index
bool
*
bv
)
;
bool
DefFunOperation
(
JSContext
*
cx
HandleScript
script
HandleObject
scopeChain
HandleFunction
funArg
)
;
bool
ThrowMsgOperation
(
JSContext
*
cx
const
unsigned
errorNum
)
;
bool
GetAndClearException
(
JSContext
*
cx
MutableHandleValue
res
)
;
bool
DeleteNameOperation
(
JSContext
*
cx
HandlePropertyName
name
HandleObject
scopeObj
MutableHandleValue
res
)
;
bool
ImplicitThisOperation
(
JSContext
*
cx
HandleObject
scopeObj
HandlePropertyName
name
MutableHandleValue
res
)
;
bool
RunOnceScriptPrologue
(
JSContext
*
cx
HandleScript
script
)
;
bool
InitGetterSetterOperation
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
HandleId
id
HandleObject
val
)
;
bool
InitGetterSetterOperation
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
HandlePropertyName
name
HandleObject
val
)
;
unsigned
GetInitDataPropAttrs
(
JSOp
op
)
;
bool
EnterWithOperation
(
JSContext
*
cx
AbstractFramePtr
frame
HandleValue
val
HandleObject
staticWith
)
;
bool
InitGetterSetterOperation
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
HandleValue
idval
HandleObject
val
)
;
bool
SpreadCallOperation
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
HandleValue
callee
HandleValue
arr
HandleValue
newTarget
MutableHandleValue
res
)
;
bool
OptimizeSpreadCall
(
JSContext
*
cx
HandleValue
arg
bool
*
optimized
)
;
JSObject
*
NewObjectOperation
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
NewObjectKind
newKind
=
GenericObject
)
;
JSObject
*
NewObjectOperationWithTemplate
(
JSContext
*
cx
HandleObject
templateObject
)
;
JSObject
*
NewArrayOperation
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
uint32_t
length
NewObjectKind
newKind
=
GenericObject
)
;
JSObject
*
NewArrayOperationWithTemplate
(
JSContext
*
cx
HandleObject
templateObject
)
;
void
ReportRuntimeLexicalError
(
JSContext
*
cx
unsigned
errorNumber
HandleId
id
)
;
void
ReportRuntimeLexicalError
(
JSContext
*
cx
unsigned
errorNumber
HandlePropertyName
name
)
;
void
ReportRuntimeLexicalError
(
JSContext
*
cx
unsigned
errorNumber
HandleScript
script
jsbytecode
*
pc
)
;
void
ReportRuntimeRedeclaration
(
JSContext
*
cx
HandlePropertyName
name
frontend
:
:
Definition
:
:
Kind
declKind
)
;
bool
ThrowUninitializedThis
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
bool
DefaultClassConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
bool
DefaultDerivedClassConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
bool
Debug_CheckSelfHosted
(
JSContext
*
cx
HandleValue
v
)
;
}
#
endif
