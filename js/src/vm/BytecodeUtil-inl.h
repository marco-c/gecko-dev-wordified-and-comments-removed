#
ifndef
vm_BytecodeUtil_inl_h
#
define
vm_BytecodeUtil_inl_h
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
static
inline
unsigned
GetDefCount
(
jsbytecode
*
pc
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
switch
(
op
)
{
case
JSOp
:
:
Or
:
case
JSOp
:
:
And
:
case
JSOp
:
:
Coalesce
:
return
1
;
case
JSOp
:
:
Pick
:
case
JSOp
:
:
Unpick
:
return
pc
[
1
]
+
1
;
default
:
return
StackDefs
(
op
)
;
}
}
static
inline
unsigned
GetUseCount
(
jsbytecode
*
pc
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
if
(
op
=
=
JSOp
:
:
Pick
|
|
op
=
=
JSOp
:
:
Unpick
)
{
return
pc
[
1
]
+
1
;
}
return
StackUses
(
op
pc
)
;
}
static
inline
JSOp
ReverseCompareOp
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOp
:
:
Gt
:
return
JSOp
:
:
Lt
;
case
JSOp
:
:
Ge
:
return
JSOp
:
:
Le
;
case
JSOp
:
:
Lt
:
return
JSOp
:
:
Gt
;
case
JSOp
:
:
Le
:
return
JSOp
:
:
Ge
;
case
JSOp
:
:
Eq
:
case
JSOp
:
:
Ne
:
case
JSOp
:
:
StrictEq
:
case
JSOp
:
:
StrictNe
:
return
op
;
default
:
MOZ_CRASH
(
"
unrecognized
op
"
)
;
}
}
static
inline
JSOp
NegateCompareOp
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOp
:
:
Gt
:
return
JSOp
:
:
Le
;
case
JSOp
:
:
Ge
:
return
JSOp
:
:
Lt
;
case
JSOp
:
:
Lt
:
return
JSOp
:
:
Ge
;
case
JSOp
:
:
Le
:
return
JSOp
:
:
Gt
;
case
JSOp
:
:
Eq
:
return
JSOp
:
:
Ne
;
case
JSOp
:
:
Ne
:
return
JSOp
:
:
Eq
;
case
JSOp
:
:
StrictNe
:
return
JSOp
:
:
StrictEq
;
case
JSOp
:
:
StrictEq
:
return
JSOp
:
:
StrictNe
;
default
:
MOZ_CRASH
(
"
unrecognized
op
"
)
;
}
}
class
BytecodeRange
{
public
:
BytecodeRange
(
JSContext
*
cx
JSScript
*
script
)
:
script
(
cx
script
)
pc
(
script
-
>
code
(
)
)
end
(
pc
+
script
-
>
length
(
)
)
{
}
bool
empty
(
)
const
{
return
pc
=
=
end
;
}
jsbytecode
*
frontPC
(
)
const
{
return
pc
;
}
JSOp
frontOpcode
(
)
const
{
return
JSOp
(
*
pc
)
;
}
size_t
frontOffset
(
)
const
{
return
script
-
>
pcToOffset
(
pc
)
;
}
void
popFront
(
)
{
pc
+
=
GetBytecodeLength
(
pc
)
;
}
private
:
RootedScript
script
;
jsbytecode
*
pc
;
jsbytecode
*
end
;
}
;
class
BytecodeRangeWithPosition
:
private
BytecodeRange
{
public
:
using
BytecodeRange
:
:
empty
;
using
BytecodeRange
:
:
frontOffset
;
using
BytecodeRange
:
:
frontOpcode
;
using
BytecodeRange
:
:
frontPC
;
BytecodeRangeWithPosition
(
JSContext
*
cx
JSScript
*
script
)
:
BytecodeRange
(
cx
script
)
initialLine
(
script
-
>
lineno
(
)
)
lineno
(
script
-
>
lineno
(
)
)
column
(
script
-
>
column
(
)
)
sn
(
script
-
>
notes
(
)
)
snEnd
(
script
-
>
notesEnd
(
)
)
snpc
(
script
-
>
code
(
)
)
isEntryPoint
(
false
)
isBreakpoint
(
false
)
seenStepSeparator
(
false
)
wasArtifactEntryPoint
(
false
)
{
if
(
sn
<
snEnd
)
{
snpc
+
=
sn
-
>
delta
(
)
;
}
updatePosition
(
)
;
while
(
frontPC
(
)
!
=
script
-
>
main
(
)
)
{
popFront
(
)
;
}
if
(
frontOpcode
(
)
!
=
JSOp
:
:
JumpTarget
)
{
isEntryPoint
=
true
;
}
else
{
wasArtifactEntryPoint
=
true
;
}
}
void
popFront
(
)
{
BytecodeRange
:
:
popFront
(
)
;
if
(
empty
(
)
)
{
isEntryPoint
=
false
;
}
else
{
updatePosition
(
)
;
}
if
(
wasArtifactEntryPoint
)
{
wasArtifactEntryPoint
=
false
;
isEntryPoint
=
true
;
}
if
(
isEntryPoint
&
&
frontOpcode
(
)
=
=
JSOp
:
:
JumpTarget
)
{
wasArtifactEntryPoint
=
isEntryPoint
;
isEntryPoint
=
false
;
}
}
uint32_t
frontLineNumber
(
)
const
{
return
lineno
;
}
JS
:
:
LimitedColumnNumberOneOrigin
frontColumnNumber
(
)
const
{
return
column
;
}
bool
frontIsEntryPoint
(
)
const
{
return
isEntryPoint
;
}
bool
frontIsBreakablePoint
(
)
const
{
return
isBreakpoint
;
}
bool
frontIsBreakableStepPoint
(
)
const
{
return
isBreakpoint
&
&
seenStepSeparator
;
}
private
:
void
updatePosition
(
)
{
if
(
isBreakpoint
)
{
isBreakpoint
=
false
;
seenStepSeparator
=
false
;
}
jsbytecode
*
lastLinePC
=
nullptr
;
SrcNoteIterator
iter
(
sn
snEnd
)
;
while
(
!
iter
.
atEnd
(
)
&
&
snpc
<
=
frontPC
(
)
)
{
auto
sn
=
*
iter
;
SrcNoteType
type
=
sn
-
>
type
(
)
;
if
(
type
=
=
SrcNoteType
:
:
ColSpan
)
{
column
+
=
SrcNote
:
:
ColSpan
:
:
getSpan
(
sn
)
;
}
else
if
(
type
=
=
SrcNoteType
:
:
SetLine
)
{
lineno
=
SrcNote
:
:
SetLine
:
:
getLine
(
sn
initialLine
)
;
column
=
JS
:
:
LimitedColumnNumberOneOrigin
(
)
;
}
else
if
(
type
=
=
SrcNoteType
:
:
SetLineColumn
)
{
lineno
=
SrcNote
:
:
SetLineColumn
:
:
getLine
(
sn
initialLine
)
;
column
=
SrcNote
:
:
SetLineColumn
:
:
getColumn
(
sn
)
;
}
else
if
(
type
=
=
SrcNoteType
:
:
NewLine
)
{
lineno
+
+
;
column
=
JS
:
:
LimitedColumnNumberOneOrigin
(
)
;
}
else
if
(
type
=
=
SrcNoteType
:
:
NewLineColumn
)
{
lineno
+
+
;
column
=
SrcNote
:
:
NewLineColumn
:
:
getColumn
(
sn
)
;
}
else
if
(
type
=
=
SrcNoteType
:
:
Breakpoint
)
{
isBreakpoint
=
true
;
}
else
if
(
type
=
=
SrcNoteType
:
:
BreakpointStepSep
)
{
isBreakpoint
=
true
;
seenStepSeparator
=
true
;
}
lastLinePC
=
snpc
;
+
+
iter
;
if
(
!
iter
.
atEnd
(
)
)
{
snpc
+
=
(
*
iter
)
-
>
delta
(
)
;
}
}
sn
=
*
iter
;
isEntryPoint
=
lastLinePC
=
=
frontPC
(
)
;
}
uint32_t
initialLine
;
uint32_t
lineno
;
JS
:
:
LimitedColumnNumberOneOrigin
column
;
const
SrcNote
*
sn
;
const
SrcNote
*
snEnd
;
jsbytecode
*
snpc
;
bool
isEntryPoint
;
bool
isBreakpoint
;
bool
seenStepSeparator
;
bool
wasArtifactEntryPoint
;
}
;
}
#
endif
