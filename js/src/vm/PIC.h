#
ifndef
vm_PIC_h
#
define
vm_PIC_h
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
Shape
;
template
<
typename
Category
>
class
PICChain
;
template
<
typename
Category
>
class
PICStub
{
friend
class
PICChain
<
Category
>
;
private
:
using
CatStub
=
typename
Category
:
:
Stub
;
using
CatChain
=
typename
Category
:
:
Chain
;
protected
:
CatStub
*
next_
;
PICStub
(
)
:
next_
(
nullptr
)
{
}
explicit
PICStub
(
const
CatStub
*
next
)
:
next_
(
next
)
{
MOZ_ASSERT
(
next_
)
;
}
explicit
PICStub
(
const
CatStub
&
other
)
:
next_
(
other
.
next_
)
{
}
public
:
CatStub
*
next
(
)
const
{
return
next_
;
}
protected
:
void
append
(
CatStub
*
stub
)
{
MOZ_ASSERT
(
!
next_
)
;
MOZ_ASSERT
(
!
stub
-
>
next_
)
;
next_
=
stub
;
}
}
;
template
<
typename
Category
>
class
PICChain
{
private
:
using
CatStub
=
typename
Category
:
:
Stub
;
using
CatChain
=
typename
Category
:
:
Chain
;
protected
:
CatStub
*
stubs_
;
PICChain
(
)
:
stubs_
(
nullptr
)
{
}
PICChain
(
const
PICChain
<
Category
>
&
other
)
=
delete
;
public
:
CatStub
*
stubs
(
)
const
{
return
stubs_
;
}
void
addStub
(
JSObject
*
obj
CatStub
*
stub
)
;
unsigned
numStubs
(
)
const
{
unsigned
count
=
0
;
for
(
CatStub
*
stub
=
stubs_
;
stub
;
stub
=
stub
-
>
next
(
)
)
{
count
+
+
;
}
return
count
;
}
}
;
class
ForOfPICObject
:
public
NativeObject
{
public
:
enum
{
ChainSlot
SlotCount
}
;
static
const
JSClass
class_
;
}
;
struct
ForOfPIC
{
class
Stub
;
class
Chain
;
ForOfPIC
(
)
=
delete
;
ForOfPIC
(
const
ForOfPIC
&
other
)
=
delete
;
using
BaseStub
=
PICStub
<
ForOfPIC
>
;
using
BaseChain
=
PICChain
<
ForOfPIC
>
;
class
Stub
:
public
BaseStub
{
private
:
Shape
*
shape_
;
public
:
explicit
Stub
(
Shape
*
shape
)
:
BaseStub
(
)
shape_
(
shape
)
{
MOZ_ASSERT
(
shape_
)
;
}
Shape
*
shape
(
)
{
return
shape_
;
}
}
;
class
Chain
:
public
BaseChain
{
private
:
const
GCPtr
<
JSObject
*
>
picObject_
;
GCPtr
<
NativeObject
*
>
arrayProto_
;
GCPtr
<
NativeObject
*
>
arrayIteratorProto_
;
GCPtr
<
Shape
*
>
arrayProtoShape_
;
uint32_t
arrayProtoIteratorSlot_
;
GCPtr
<
Value
>
canonicalIteratorFunc_
;
GCPtr
<
Shape
*
>
arrayIteratorProtoShape_
;
uint32_t
arrayIteratorProtoNextSlot_
;
GCPtr
<
Value
>
canonicalNextFunc_
;
bool
initialized_
;
bool
disabled_
;
static
const
unsigned
MAX_STUBS
=
10
;
public
:
explicit
Chain
(
JSObject
*
picObject
)
:
BaseChain
(
)
picObject_
(
picObject
)
arrayProto_
(
nullptr
)
arrayIteratorProto_
(
nullptr
)
arrayProtoShape_
(
nullptr
)
arrayProtoIteratorSlot_
(
-
1
)
canonicalIteratorFunc_
(
UndefinedValue
(
)
)
arrayIteratorProtoShape_
(
nullptr
)
arrayIteratorProtoNextSlot_
(
-
1
)
initialized_
(
false
)
disabled_
(
false
)
{
}
bool
initialize
(
JSContext
*
cx
)
;
bool
tryOptimizeArray
(
JSContext
*
cx
Handle
<
ArrayObject
*
>
array
bool
*
optimized
)
;
bool
tryOptimizeArrayIteratorNext
(
JSContext
*
cx
bool
*
optimized
)
;
void
trace
(
JSTracer
*
trc
)
;
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
private
:
bool
isArrayStateStillSane
(
)
;
inline
bool
isArrayNextStillSane
(
)
{
return
(
arrayIteratorProto_
-
>
shape
(
)
=
=
arrayIteratorProtoShape_
)
&
&
(
arrayIteratorProto_
-
>
getSlot
(
arrayIteratorProtoNextSlot_
)
=
=
canonicalNextFunc_
)
;
}
bool
hasMatchingStub
(
ArrayObject
*
obj
)
;
void
reset
(
JSContext
*
cx
)
;
void
eraseChain
(
JSContext
*
cx
)
;
void
freeAllStubs
(
JS
:
:
GCContext
*
gcx
)
;
}
;
static
NativeObject
*
createForOfPICObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
inline
Chain
*
fromJSObject
(
NativeObject
*
obj
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ForOfPICObject
>
(
)
)
;
return
obj
-
>
maybePtrFromReservedSlot
<
Chain
>
(
ForOfPICObject
:
:
ChainSlot
)
;
}
static
inline
Chain
*
getOrCreate
(
JSContext
*
cx
)
{
NativeObject
*
obj
=
cx
-
>
global
(
)
-
>
getForOfPICObject
(
)
;
if
(
obj
)
{
return
fromJSObject
(
obj
)
;
}
return
create
(
cx
)
;
}
static
Chain
*
create
(
JSContext
*
cx
)
;
}
;
}
#
endif
