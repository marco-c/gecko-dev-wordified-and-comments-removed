#
include
"
vm
/
Shape
-
inl
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jshashutil
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
jscntxtinlines
.
h
"
#
include
"
jscompartmentinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
Caches
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
CeilingLog2Size
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
RotateLeft
;
using
JS
:
:
AutoCheckCannotGC
;
Shape
*
const
ShapeTable
:
:
Entry
:
:
SHAPE_REMOVED
=
(
Shape
*
)
ShapeTable
:
:
Entry
:
:
SHAPE_COLLISION
;
bool
ShapeTable
:
:
init
(
JSContext
*
cx
Shape
*
lastProp
)
{
uint32_t
sizeLog2
=
CeilingLog2Size
(
entryCount_
)
;
uint32_t
size
=
JS_BIT
(
sizeLog2
)
;
if
(
entryCount_
>
=
size
-
(
size
>
>
2
)
)
sizeLog2
+
+
;
if
(
sizeLog2
<
MIN_SIZE_LOG2
)
sizeLog2
=
MIN_SIZE_LOG2
;
size
=
JS_BIT
(
sizeLog2
)
;
entries_
=
cx
-
>
pod_calloc
<
Entry
>
(
size
)
;
if
(
!
entries_
)
return
false
;
MOZ_ASSERT
(
sizeLog2
<
=
HASH_BITS
)
;
hashShift_
=
HASH_BITS
-
sizeLog2
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
lastProp
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
Shape
&
shape
=
r
.
front
(
)
;
Entry
&
entry
=
searchUnchecked
<
MaybeAdding
:
:
Adding
>
(
shape
.
propid
(
)
)
;
if
(
!
entry
.
shape
(
)
)
entry
.
setPreservingCollision
(
&
shape
)
;
}
MOZ_ASSERT
(
capacity
(
)
=
=
size
)
;
MOZ_ASSERT
(
size
>
=
MIN_SIZE
)
;
MOZ_ASSERT
(
!
needsToGrow
(
)
)
;
return
true
;
}
void
Shape
:
:
removeFromDictionary
(
NativeObject
*
obj
)
{
MOZ_ASSERT
(
inDictionary
(
)
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
listp
)
;
MOZ_ASSERT
(
obj
-
>
shape_
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
obj
-
>
shape_
-
>
listp
=
=
&
obj
-
>
shape_
)
;
if
(
parent
)
parent
-
>
listp
=
listp
;
*
listp
=
parent
;
listp
=
nullptr
;
obj
-
>
shape_
-
>
clearCachedBigEnoughForShapeTable
(
)
;
}
void
Shape
:
:
insertIntoDictionary
(
GCPtrShape
*
dictp
)
{
MOZ_ASSERT
(
inDictionary
(
)
)
;
MOZ_ASSERT
(
!
listp
)
;
MOZ_ASSERT_IF
(
*
dictp
(
*
dictp
)
-
>
inDictionary
(
)
)
;
MOZ_ASSERT_IF
(
*
dictp
(
*
dictp
)
-
>
listp
=
=
dictp
)
;
MOZ_ASSERT_IF
(
*
dictp
zone
(
)
=
=
(
*
dictp
)
-
>
zone
(
)
)
;
setParent
(
dictp
-
>
get
(
)
)
;
if
(
parent
)
parent
-
>
listp
=
&
parent
;
listp
=
(
GCPtrShape
*
)
dictp
;
*
dictp
=
this
;
}
bool
Shape
:
:
makeOwnBaseShape
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
base
(
)
-
>
isOwned
(
)
)
;
MOZ_ASSERT
(
cx
-
>
zone
(
)
=
=
zone
(
)
)
;
BaseShape
*
nbase
=
Allocate
<
BaseShape
NoGC
>
(
cx
)
;
if
(
!
nbase
)
return
false
;
new
(
nbase
)
BaseShape
(
StackBaseShape
(
this
)
)
;
nbase
-
>
setOwned
(
base
(
)
-
>
toUnowned
(
)
)
;
this
-
>
base_
=
nbase
;
return
true
;
}
void
Shape
:
:
handoffTableTo
(
Shape
*
shape
)
{
MOZ_ASSERT
(
inDictionary
(
)
&
&
shape
-
>
inDictionary
(
)
)
;
if
(
this
=
=
shape
)
return
;
MOZ_ASSERT
(
base
(
)
-
>
isOwned
(
)
&
&
!
shape
-
>
base
(
)
-
>
isOwned
(
)
)
;
BaseShape
*
nbase
=
base
(
)
;
MOZ_ASSERT_IF
(
shape
-
>
hasSlot
(
)
nbase
-
>
slotSpan
(
)
>
shape
-
>
slot
(
)
)
;
this
-
>
base_
=
nbase
-
>
baseUnowned
(
)
;
nbase
-
>
adoptUnowned
(
shape
-
>
base
(
)
-
>
toUnowned
(
)
)
;
shape
-
>
base_
=
nbase
;
}
bool
Shape
:
:
hashify
(
JSContext
*
cx
Shape
*
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
hasTable
(
)
)
;
if
(
!
shape
-
>
ensureOwnBaseShape
(
cx
)
)
return
false
;
ShapeTable
*
table
=
cx
-
>
new_
<
ShapeTable
>
(
shape
-
>
entryCount
(
)
)
;
if
(
!
table
)
return
false
;
if
(
!
table
-
>
init
(
cx
shape
)
)
{
js_free
(
table
)
;
return
false
;
}
shape
-
>
base
(
)
-
>
setTable
(
table
)
;
return
true
;
}
static
HashNumber
Hash1
(
HashNumber
hash0
uint32_t
shift
)
{
return
hash0
>
>
shift
;
}
static
HashNumber
Hash2
(
HashNumber
hash0
uint32_t
log2
uint32_t
shift
)
{
return
(
(
hash0
<
<
log2
)
>
>
shift
)
|
1
;
}
template
<
MaybeAdding
Adding
>
ShapeTable
:
:
Entry
&
ShapeTable
:
:
searchUnchecked
(
jsid
id
)
{
MOZ_ASSERT
(
entries_
)
;
MOZ_ASSERT
(
!
JSID_IS_EMPTY
(
id
)
)
;
HashNumber
hash0
=
HashId
(
id
)
;
HashNumber
hash1
=
Hash1
(
hash0
hashShift_
)
;
Entry
*
entry
=
&
getEntry
(
hash1
)
;
if
(
entry
-
>
isFree
(
)
)
return
*
entry
;
Shape
*
shape
=
entry
-
>
shape
(
)
;
if
(
shape
&
&
shape
-
>
propidRaw
(
)
=
=
id
)
return
*
entry
;
uint32_t
sizeLog2
=
HASH_BITS
-
hashShift_
;
HashNumber
hash2
=
Hash2
(
hash0
sizeLog2
hashShift_
)
;
uint32_t
sizeMask
=
JS_BITMASK
(
sizeLog2
)
;
Entry
*
firstRemoved
;
if
(
Adding
=
=
MaybeAdding
:
:
Adding
)
{
if
(
entry
-
>
isRemoved
(
)
)
{
firstRemoved
=
entry
;
}
else
{
firstRemoved
=
nullptr
;
if
(
!
entry
-
>
hadCollision
(
)
)
entry
-
>
flagCollision
(
)
;
}
}
#
ifdef
DEBUG
bool
collisionFlag
=
true
;
if
(
!
entry
-
>
isRemoved
(
)
)
collisionFlag
=
entry
-
>
hadCollision
(
)
;
#
endif
while
(
true
)
{
hash1
-
=
hash2
;
hash1
&
=
sizeMask
;
entry
=
&
getEntry
(
hash1
)
;
if
(
entry
-
>
isFree
(
)
)
return
(
Adding
=
=
MaybeAdding
:
:
Adding
&
&
firstRemoved
)
?
*
firstRemoved
:
*
entry
;
shape
=
entry
-
>
shape
(
)
;
if
(
shape
&
&
shape
-
>
propidRaw
(
)
=
=
id
)
{
MOZ_ASSERT
(
collisionFlag
)
;
return
*
entry
;
}
if
(
Adding
=
=
MaybeAdding
:
:
Adding
)
{
if
(
entry
-
>
isRemoved
(
)
)
{
if
(
!
firstRemoved
)
firstRemoved
=
entry
;
}
else
{
if
(
!
entry
-
>
hadCollision
(
)
)
entry
-
>
flagCollision
(
)
;
}
}
#
ifdef
DEBUG
if
(
!
entry
-
>
isRemoved
(
)
)
collisionFlag
&
=
entry
-
>
hadCollision
(
)
;
#
endif
}
MOZ_CRASH
(
"
Shape
:
:
search
failed
to
find
an
expected
entry
.
"
)
;
}
template
ShapeTable
:
:
Entry
&
ShapeTable
:
:
searchUnchecked
<
MaybeAdding
:
:
Adding
>
(
jsid
id
)
;
template
ShapeTable
:
:
Entry
&
ShapeTable
:
:
searchUnchecked
<
MaybeAdding
:
:
NotAdding
>
(
jsid
id
)
;
bool
ShapeTable
:
:
change
(
JSContext
*
cx
int
log2Delta
)
{
MOZ_ASSERT
(
entries_
)
;
MOZ_ASSERT
(
-
1
<
=
log2Delta
&
&
log2Delta
<
=
1
)
;
uint32_t
oldLog2
=
HASH_BITS
-
hashShift_
;
uint32_t
newLog2
=
oldLog2
+
log2Delta
;
uint32_t
oldSize
=
JS_BIT
(
oldLog2
)
;
uint32_t
newSize
=
JS_BIT
(
newLog2
)
;
Entry
*
newTable
=
cx
-
>
maybe_pod_calloc
<
Entry
>
(
newSize
)
;
if
(
!
newTable
)
return
false
;
MOZ_ASSERT
(
newLog2
<
=
HASH_BITS
)
;
hashShift_
=
HASH_BITS
-
newLog2
;
removedCount_
=
0
;
Entry
*
oldTable
=
entries_
;
entries_
=
newTable
;
AutoCheckCannotGC
nogc
;
for
(
Entry
*
oldEntry
=
oldTable
;
oldSize
!
=
0
;
oldEntry
+
+
)
{
if
(
Shape
*
shape
=
oldEntry
-
>
shape
(
)
)
{
Entry
&
entry
=
search
<
MaybeAdding
:
:
Adding
>
(
shape
-
>
propid
(
)
nogc
)
;
MOZ_ASSERT
(
entry
.
isFree
(
)
)
;
entry
.
setShape
(
shape
)
;
}
oldSize
-
-
;
}
MOZ_ASSERT
(
capacity
(
)
=
=
newSize
)
;
js_free
(
oldTable
)
;
return
true
;
}
bool
ShapeTable
:
:
grow
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
needsToGrow
(
)
)
;
uint32_t
size
=
capacity
(
)
;
int
delta
=
removedCount_
<
(
size
>
>
2
)
;
MOZ_ASSERT
(
entryCount_
+
removedCount_
<
=
size
-
1
)
;
if
(
!
change
(
cx
delta
)
)
{
if
(
entryCount_
+
removedCount_
=
=
size
-
1
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
return
true
;
}
void
ShapeTable
:
:
trace
(
JSTracer
*
trc
)
{
for
(
size_t
i
=
0
;
i
<
capacity
(
)
;
i
+
+
)
{
Entry
&
entry
=
getEntry
(
i
)
;
Shape
*
shape
=
entry
.
shape
(
)
;
if
(
shape
)
{
TraceManuallyBarrieredEdge
(
trc
&
shape
"
ShapeTable
shape
"
)
;
if
(
shape
!
=
entry
.
shape
(
)
)
entry
.
setPreservingCollision
(
shape
)
;
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
ShapeTable
:
:
checkAfterMovingGC
(
)
{
for
(
size_t
i
=
0
;
i
<
capacity
(
)
;
i
+
+
)
{
Entry
&
entry
=
getEntry
(
i
)
;
Shape
*
shape
=
entry
.
shape
(
)
;
if
(
shape
)
CheckGCThingAfterMovingGC
(
shape
)
;
}
}
#
endif
Shape
*
Shape
:
:
replaceLastProperty
(
JSContext
*
cx
StackBaseShape
&
base
TaggedProto
proto
HandleShape
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
inDictionary
(
)
)
;
if
(
!
shape
-
>
parent
)
{
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
shape
-
>
numFixedSlots
(
)
)
;
return
EmptyShape
:
:
getInitialShape
(
cx
base
.
clasp
proto
kind
base
.
flags
&
BaseShape
:
:
OBJECT_FLAG_MASK
)
;
}
UnownedBaseShape
*
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
nullptr
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
shape
)
)
;
child
.
setBase
(
nbase
)
;
return
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
getChild
(
cx
shape
-
>
parent
child
)
;
}
Shape
*
NativeObject
:
:
getChildPropertyOnDictionary
(
JSContext
*
cx
HandleNativeObject
obj
HandleShape
parent
MutableHandle
<
StackShape
>
child
)
{
if
(
!
child
.
hasSlot
(
)
)
{
child
.
setSlot
(
parent
-
>
maybeSlot
(
)
)
;
}
else
{
if
(
child
.
hasMissingSlot
(
)
)
{
uint32_t
slot
;
if
(
!
allocSlot
(
cx
obj
&
slot
)
)
return
nullptr
;
child
.
setSlot
(
slot
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
|
|
parent
-
>
hasMissingSlot
(
)
|
|
child
.
slot
(
)
=
=
parent
-
>
maybeSlot
(
)
+
1
|
|
(
parent
-
>
maybeSlot
(
)
+
1
<
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
&
&
child
.
slot
(
)
=
=
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
)
)
;
}
}
RootedShape
shape
(
cx
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
MOZ_ASSERT
(
parent
=
=
obj
-
>
lastProperty
(
)
)
;
shape
=
child
.
isAccessorShape
(
)
?
Allocate
<
AccessorShape
>
(
cx
)
:
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
return
nullptr
;
if
(
child
.
hasSlot
(
)
&
&
child
.
slot
(
)
>
=
obj
-
>
lastProperty
(
)
-
>
base
(
)
-
>
slotSpan
(
)
)
{
if
(
!
obj
-
>
setSlotSpan
(
cx
child
.
slot
(
)
+
1
)
)
{
new
(
shape
)
Shape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
-
>
unowned
(
)
0
)
;
return
nullptr
;
}
}
shape
-
>
initDictionaryShape
(
child
obj
-
>
numFixedSlots
(
)
&
obj
-
>
shape_
)
;
}
return
shape
;
}
Shape
*
NativeObject
:
:
getChildProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleShape
parent
MutableHandle
<
StackShape
>
child
)
{
Shape
*
shape
=
getChildPropertyOnDictionary
(
cx
obj
parent
child
)
;
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
shape
=
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
getChild
(
cx
parent
child
)
;
if
(
!
shape
)
return
nullptr
;
if
(
!
obj
-
>
setLastProperty
(
cx
shape
)
)
return
nullptr
;
}
return
shape
;
}
bool
js
:
:
NativeObject
:
:
toDictionaryMode
(
JSContext
*
cx
HandleNativeObject
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
cx
-
>
isInsideCurrentCompartment
(
obj
)
)
;
uint32_t
span
=
obj
-
>
slotSpan
(
)
;
RootedShape
root
(
cx
)
;
RootedShape
dictionaryShape
(
cx
)
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
)
;
while
(
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
inDictionary
(
)
)
;
Shape
*
dprop
=
shape
-
>
isAccessorShape
(
)
?
Allocate
<
AccessorShape
>
(
cx
)
:
Allocate
<
Shape
>
(
cx
)
;
if
(
!
dprop
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
GCPtrShape
*
listp
=
dictionaryShape
?
&
dictionaryShape
-
>
parent
:
nullptr
;
StackShape
child
(
shape
)
;
dprop
-
>
initDictionaryShape
(
child
obj
-
>
numFixedSlots
(
)
listp
)
;
if
(
!
dictionaryShape
)
root
=
dprop
;
MOZ_ASSERT
(
!
dprop
-
>
hasTable
(
)
)
;
dictionaryShape
=
dprop
;
shape
=
shape
-
>
previous
(
)
;
}
if
(
!
Shape
:
:
hashify
(
cx
root
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
IsInsideNursery
(
obj
)
&
&
!
cx
-
>
nursery
(
)
.
queueDictionaryModeObjectToSweep
(
obj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
MOZ_ASSERT
(
root
-
>
listp
=
=
nullptr
)
;
root
-
>
listp
=
&
obj
-
>
shape_
;
obj
-
>
shape_
=
root
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
root
-
>
base
(
)
-
>
setSlotSpan
(
span
)
;
return
true
;
}
Shape
*
NativeObject
:
:
addProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
GetterOp
getter
SetterOp
setter
uint32_t
slot
unsigned
attrs
unsigned
flags
bool
allowDictionary
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
MOZ_ASSERT
(
getter
!
=
JS_PropertyStub
)
;
MOZ_ASSERT
(
setter
!
=
JS_StrictPropertyStub
)
;
bool
extensible
;
if
(
!
IsExtensible
(
cx
obj
&
extensible
)
)
return
nullptr
;
if
(
!
extensible
)
{
if
(
!
cx
-
>
helperThread
(
)
)
JSObject
:
:
reportNotExtensible
(
cx
obj
)
;
return
nullptr
;
}
AutoKeepShapeTables
keep
(
cx
)
;
ShapeTable
:
:
Entry
*
entry
=
nullptr
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
keep
)
;
if
(
!
table
)
return
nullptr
;
entry
=
&
table
-
>
search
<
MaybeAdding
:
:
Adding
>
(
id
keep
)
;
}
return
addPropertyInternal
(
cx
obj
id
getter
setter
slot
attrs
flags
entry
allowDictionary
keep
)
;
}
static
bool
ShouldConvertToDictionary
(
NativeObject
*
obj
)
{
if
(
obj
-
>
hadElementsAccess
(
)
)
return
obj
-
>
lastProperty
(
)
-
>
entryCount
(
)
>
=
PropertyTree
:
:
MAX_HEIGHT_WITH_ELEMENTS_ACCESS
;
return
obj
-
>
lastProperty
(
)
-
>
entryCount
(
)
>
=
PropertyTree
:
:
MAX_HEIGHT
;
}
Shape
*
NativeObject
:
:
addPropertyInternal
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
GetterOp
getter
SetterOp
setter
uint32_t
slot
unsigned
attrs
unsigned
flags
ShapeTable
:
:
Entry
*
entry
bool
allowDictionary
const
AutoKeepShapeTables
&
keep
)
{
MOZ_ASSERT_IF
(
!
allowDictionary
!
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
getter
!
=
JS_PropertyStub
)
;
MOZ_ASSERT
(
setter
!
=
JS_StrictPropertyStub
)
;
AutoRooterGetterSetter
gsRoot
(
cx
attrs
&
getter
&
setter
)
;
ShapeTable
*
table
=
nullptr
;
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
bool
stableSlot
=
(
slot
=
=
SHAPE_INVALID_SLOT
)
|
|
obj
-
>
lastProperty
(
)
-
>
hasMissingSlot
(
)
|
|
(
slot
=
=
obj
-
>
lastProperty
(
)
-
>
maybeSlot
(
)
+
1
)
;
MOZ_ASSERT_IF
(
!
allowDictionary
stableSlot
)
;
if
(
allowDictionary
&
&
(
!
stableSlot
|
|
ShouldConvertToDictionary
(
obj
)
)
)
{
if
(
!
toDictionaryMode
(
cx
obj
)
)
return
nullptr
;
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
keep
)
;
entry
=
&
table
-
>
search
<
MaybeAdding
:
:
Adding
>
(
id
keep
)
;
}
}
else
{
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
keep
)
;
if
(
!
table
)
return
nullptr
;
if
(
table
-
>
needsToGrow
(
)
)
{
if
(
!
table
-
>
grow
(
cx
)
)
return
nullptr
;
entry
=
&
table
-
>
search
<
MaybeAdding
:
:
Adding
>
(
id
keep
)
;
MOZ_ASSERT
(
!
entry
-
>
shape
(
)
)
;
}
}
MOZ_ASSERT
(
!
!
table
=
=
!
!
entry
)
;
RootedShape
shape
(
cx
)
;
{
RootedShape
last
(
cx
obj
-
>
lastProperty
(
)
)
;
uint32_t
index
;
bool
indexed
=
IdIsIndex
(
id
&
index
)
;
Rooted
<
UnownedBaseShape
*
>
nbase
(
cx
)
;
if
(
!
indexed
)
{
nbase
=
last
-
>
base
(
)
-
>
unowned
(
)
;
}
else
{
StackBaseShape
base
(
last
-
>
base
(
)
)
;
base
.
flags
|
=
BaseShape
:
:
INDEXED
;
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
nullptr
;
}
Rooted
<
StackShape
>
child
(
cx
StackShape
(
nbase
id
slot
attrs
flags
)
)
;
child
.
updateGetterSetter
(
getter
setter
)
;
shape
=
getChildProperty
(
cx
obj
last
&
child
)
;
}
if
(
shape
)
{
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
if
(
table
)
{
entry
-
>
setPreservingCollision
(
shape
)
;
table
-
>
incEntryCount
(
)
;
MOZ_ASSERT
(
shape
-
>
parent
-
>
maybeTable
(
keep
)
=
=
table
)
;
shape
-
>
parent
-
>
handoffTableTo
(
shape
)
;
}
obj
-
>
checkShapeConsistency
(
)
;
return
shape
;
}
obj
-
>
checkShapeConsistency
(
)
;
return
nullptr
;
}
Shape
*
js
:
:
ReshapeForAllocKind
(
JSContext
*
cx
Shape
*
shape
TaggedProto
proto
gc
:
:
AllocKind
allocKind
)
{
size_t
nfixed
=
gc
:
:
GetGCKindSlots
(
allocKind
shape
-
>
getObjectClass
(
)
)
;
js
:
:
AutoIdVector
ids
(
cx
)
;
{
for
(
unsigned
i
=
0
;
i
<
shape
-
>
slotSpan
(
)
;
i
+
+
)
{
if
(
!
ids
.
append
(
JSID_VOID
)
)
return
nullptr
;
}
Shape
*
nshape
=
shape
;
while
(
!
nshape
-
>
isEmptyShape
(
)
)
{
ids
[
nshape
-
>
slot
(
)
]
.
set
(
nshape
-
>
propid
(
)
)
;
nshape
=
nshape
-
>
previous
(
)
;
}
}
RootedId
id
(
cx
)
;
RootedShape
newShape
(
cx
EmptyShape
:
:
getInitialShape
(
cx
shape
-
>
getObjectClass
(
)
proto
nfixed
shape
-
>
getObjectFlags
(
)
)
)
;
if
(
!
newShape
)
return
nullptr
;
for
(
unsigned
i
=
0
;
i
<
ids
.
length
(
)
;
i
+
+
)
{
id
=
ids
[
i
]
;
uint32_t
index
;
bool
indexed
=
IdIsIndex
(
id
&
index
)
;
Rooted
<
UnownedBaseShape
*
>
nbase
(
cx
newShape
-
>
base
(
)
-
>
unowned
(
)
)
;
if
(
indexed
)
{
StackBaseShape
base
(
nbase
)
;
base
.
flags
|
=
BaseShape
:
:
INDEXED
;
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
nullptr
;
}
Rooted
<
StackShape
>
child
(
cx
StackShape
(
nbase
id
i
JSPROP_ENUMERATE
0
)
)
;
newShape
=
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
getChild
(
cx
newShape
child
)
;
if
(
!
newShape
)
return
nullptr
;
}
return
newShape
;
}
static
inline
bool
CheckCanChangeAttrs
(
JSContext
*
cx
JSObject
*
obj
Shape
*
shape
unsigned
*
attrsp
)
{
if
(
shape
-
>
configurable
(
)
)
return
true
;
*
attrsp
|
=
JSPROP_PERMANENT
;
if
(
shape
-
>
isDataDescriptor
(
)
&
&
shape
-
>
hasSlot
(
)
&
&
(
*
attrsp
&
(
JSPROP_GETTER
|
JSPROP_SETTER
|
JSPROP_SHARED
)
)
)
{
if
(
!
cx
-
>
helperThread
(
)
)
JSObject
:
:
reportNotConfigurable
(
cx
shape
-
>
propid
(
)
)
;
return
false
;
}
return
true
;
}
Shape
*
NativeObject
:
:
putProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
GetterOp
getter
SetterOp
setter
uint32_t
slot
unsigned
attrs
unsigned
flags
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
MOZ_ASSERT
(
getter
!
=
JS_PropertyStub
)
;
MOZ_ASSERT
(
setter
!
=
JS_StrictPropertyStub
)
;
#
ifdef
DEBUG
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
ArrayObject
*
arr
=
&
obj
-
>
as
<
ArrayObject
>
(
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
MOZ_ASSERT
(
index
<
arr
-
>
length
(
)
|
|
arr
-
>
lengthIsWritable
(
)
)
;
}
#
endif
AutoRooterGetterSetter
gsRoot
(
cx
attrs
&
getter
&
setter
)
;
AutoKeepShapeTables
keep
(
cx
)
;
ShapeTable
:
:
Entry
*
entry
;
RootedShape
shape
(
cx
)
;
if
(
!
Shape
:
:
search
<
MaybeAdding
:
:
Adding
>
(
cx
obj
-
>
lastProperty
(
)
id
keep
shape
.
address
(
)
&
entry
)
)
{
return
nullptr
;
}
if
(
!
shape
)
{
bool
extensible
;
if
(
!
IsExtensible
(
cx
obj
&
extensible
)
)
return
nullptr
;
if
(
!
extensible
)
{
if
(
!
cx
-
>
helperThread
(
)
)
JSObject
:
:
reportNotExtensible
(
cx
obj
)
;
return
nullptr
;
}
return
addPropertyInternal
(
cx
obj
id
getter
setter
slot
attrs
flags
entry
true
keep
)
;
}
MOZ_ASSERT_IF
(
entry
!
entry
-
>
isRemoved
(
)
)
;
if
(
!
CheckCanChangeAttrs
(
cx
obj
shape
&
attrs
)
)
return
nullptr
;
bool
hadSlot
=
shape
-
>
hasSlot
(
)
;
uint32_t
oldSlot
=
shape
-
>
maybeSlot
(
)
;
if
(
!
(
attrs
&
JSPROP_SHARED
)
&
&
slot
=
=
SHAPE_INVALID_SLOT
&
&
hadSlot
)
slot
=
oldSlot
;
Rooted
<
UnownedBaseShape
*
>
nbase
(
cx
)
;
{
uint32_t
index
;
bool
indexed
=
IdIsIndex
(
id
&
index
)
;
StackBaseShape
base
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
)
;
if
(
indexed
)
base
.
flags
|
=
BaseShape
:
:
INDEXED
;
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
nullptr
;
}
if
(
shape
-
>
matchesParamsAfterId
(
nbase
slot
attrs
flags
getter
setter
)
)
return
shape
;
if
(
shape
!
=
obj
-
>
lastProperty
(
)
&
&
!
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
toDictionaryMode
(
cx
obj
)
)
return
nullptr
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
keep
)
;
MOZ_ASSERT
(
table
)
;
entry
=
&
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
shape
-
>
propid
(
)
keep
)
;
shape
=
entry
-
>
shape
(
)
;
}
MOZ_ASSERT_IF
(
shape
-
>
hasSlot
(
)
&
&
!
(
attrs
&
JSPROP_SHARED
)
shape
-
>
slot
(
)
=
=
slot
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
bool
updateLast
=
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
bool
accessorShape
=
getter
|
|
setter
|
|
(
attrs
&
(
JSPROP_GETTER
|
JSPROP_SETTER
)
)
;
shape
=
NativeObject
:
:
replaceWithNewEquivalentShape
(
cx
obj
shape
nullptr
accessorShape
)
;
if
(
!
shape
)
return
nullptr
;
if
(
!
updateLast
&
&
!
NativeObject
:
:
generateOwnShape
(
cx
obj
)
)
return
nullptr
;
if
(
slot
=
=
SHAPE_INVALID_SLOT
&
&
!
(
attrs
&
JSPROP_SHARED
)
)
{
if
(
!
allocSlot
(
cx
obj
&
slot
)
)
return
nullptr
;
}
if
(
updateLast
)
shape
-
>
base
(
)
-
>
adoptUnowned
(
nbase
)
;
else
shape
-
>
base_
=
nbase
;
MOZ_ASSERT_IF
(
attrs
&
(
JSPROP_GETTER
|
JSPROP_SETTER
)
attrs
&
JSPROP_SHARED
)
;
shape
-
>
setSlot
(
slot
)
;
shape
-
>
attrs
=
uint8_t
(
attrs
)
;
shape
-
>
flags
=
flags
|
Shape
:
:
IN_DICTIONARY
|
(
accessorShape
?
Shape
:
:
ACCESSOR_SHAPE
:
0
)
;
if
(
shape
-
>
isAccessorShape
(
)
)
{
AccessorShape
&
accShape
=
shape
-
>
asAccessorShape
(
)
;
accShape
.
rawGetter
=
getter
;
accShape
.
rawSetter
=
setter
;
GetterSetterWriteBarrierPost
(
&
accShape
)
;
}
else
{
MOZ_ASSERT
(
!
getter
)
;
MOZ_ASSERT
(
!
setter
)
;
}
}
else
{
StackBaseShape
base
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
)
;
UnownedBaseShape
*
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
nullptr
;
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
nbase
id
slot
attrs
flags
)
)
;
child
.
updateGetterSetter
(
getter
setter
)
;
RootedShape
parent
(
cx
shape
-
>
parent
)
;
Shape
*
newShape
=
getChildProperty
(
cx
obj
parent
&
child
)
;
if
(
!
newShape
)
{
obj
-
>
checkShapeConsistency
(
)
;
return
nullptr
;
}
shape
=
newShape
;
}
if
(
hadSlot
&
&
!
shape
-
>
hasSlot
(
)
)
{
if
(
oldSlot
<
obj
-
>
slotSpan
(
)
)
obj
-
>
freeSlot
(
cx
oldSlot
)
;
if
(
!
cx
-
>
helperThread
(
)
)
+
+
cx
-
>
propertyRemovals
;
}
obj
-
>
checkShapeConsistency
(
)
;
return
shape
;
}
Shape
*
NativeObject
:
:
changeProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleShape
shape
unsigned
attrs
GetterOp
getter
SetterOp
setter
)
{
MOZ_ASSERT
(
obj
-
>
containsPure
(
shape
)
)
;
MOZ_ASSERT
(
getter
!
=
JS_PropertyStub
)
;
MOZ_ASSERT
(
setter
!
=
JS_StrictPropertyStub
)
;
MOZ_ASSERT_IF
(
attrs
&
(
JSPROP_GETTER
|
JSPROP_SETTER
)
attrs
&
JSPROP_SHARED
)
;
MOZ_ASSERT
(
!
(
(
attrs
^
shape
-
>
attrs
)
&
JSPROP_SHARED
)
|
|
!
(
attrs
&
JSPROP_SHARED
)
)
;
MarkTypePropertyNonData
(
cx
obj
shape
-
>
propid
(
)
)
;
if
(
!
CheckCanChangeAttrs
(
cx
obj
shape
&
attrs
)
)
return
nullptr
;
if
(
shape
-
>
attrs
=
=
attrs
&
&
shape
-
>
getter
(
)
=
=
getter
&
&
shape
-
>
setter
(
)
=
=
setter
)
return
shape
;
RootedId
propid
(
cx
shape
-
>
propid
(
)
)
;
Shape
*
newShape
=
putProperty
(
cx
obj
propid
getter
setter
shape
-
>
maybeSlot
(
)
attrs
shape
-
>
flags
)
;
obj
-
>
checkShapeConsistency
(
)
;
return
newShape
;
}
bool
NativeObject
:
:
removeProperty
(
JSContext
*
cx
HandleNativeObject
obj
jsid
id_
)
{
RootedId
id
(
cx
id_
)
;
AutoKeepShapeTables
keep
(
cx
)
;
ShapeTable
:
:
Entry
*
entry
;
RootedShape
shape
(
cx
)
;
if
(
!
Shape
:
:
search
(
cx
obj
-
>
lastProperty
(
)
id
keep
shape
.
address
(
)
&
entry
)
)
return
false
;
if
(
!
shape
)
return
true
;
if
(
!
obj
-
>
inDictionaryMode
(
)
&
&
(
shape
!
=
obj
-
>
lastProperty
(
)
|
|
!
obj
-
>
canRemoveLastProperty
(
)
)
)
{
if
(
!
toDictionaryMode
(
cx
obj
)
)
return
false
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
keep
)
;
MOZ_ASSERT
(
table
)
;
entry
=
&
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
shape
-
>
propid
(
)
keep
)
;
shape
=
entry
-
>
shape
(
)
;
}
RootedShape
spare
(
cx
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
spare
=
Allocate
<
AccessorShape
>
(
cx
)
;
if
(
!
spare
)
return
false
;
new
(
spare
)
Shape
(
shape
-
>
base
(
)
-
>
unowned
(
)
0
)
;
if
(
shape
=
=
obj
-
>
lastProperty
(
)
)
{
RootedShape
previous
(
cx
obj
-
>
lastProperty
(
)
-
>
parent
)
;
StackBaseShape
base
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
)
;
BaseShape
*
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
false
;
previous
-
>
base_
=
nbase
;
}
}
if
(
shape
-
>
hasSlot
(
)
)
{
obj
-
>
freeSlot
(
cx
shape
-
>
slot
(
)
)
;
if
(
!
cx
-
>
helperThread
(
)
)
+
+
cx
-
>
propertyRemovals
;
}
if
(
obj
-
>
inDictionaryMode
(
)
)
{
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
keep
)
;
MOZ_ASSERT
(
table
)
;
if
(
entry
-
>
hadCollision
(
)
)
{
entry
-
>
setRemoved
(
)
;
table
-
>
decEntryCount
(
)
;
table
-
>
incRemovedCount
(
)
;
}
else
{
entry
-
>
setFree
(
)
;
table
-
>
decEntryCount
(
)
;
#
ifdef
DEBUG
Shape
*
aprop
=
obj
-
>
lastProperty
(
)
;
for
(
int
n
=
50
;
-
-
n
>
=
0
&
&
aprop
-
>
parent
;
aprop
=
aprop
-
>
parent
)
MOZ_ASSERT_IF
(
aprop
!
=
shape
obj
-
>
contains
(
cx
aprop
)
)
;
#
endif
}
{
Shape
*
oldLastProp
=
obj
-
>
lastProperty
(
)
;
shape
-
>
removeFromDictionary
(
obj
)
;
oldLastProp
-
>
handoffTableTo
(
obj
-
>
lastProperty
(
)
)
;
}
JS_ALWAYS_TRUE
(
NativeObject
:
:
generateOwnShape
(
cx
obj
spare
)
)
;
uint32_t
size
=
table
-
>
capacity
(
)
;
if
(
size
>
ShapeTable
:
:
MIN_SIZE
&
&
table
-
>
entryCount
(
)
<
=
size
>
>
2
)
(
void
)
table
-
>
change
(
cx
-
1
)
;
}
else
{
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
obj
-
>
removeLastProperty
(
cx
)
;
}
obj
-
>
checkShapeConsistency
(
)
;
return
true
;
}
void
NativeObject
:
:
clear
(
JSContext
*
cx
HandleNativeObject
obj
)
{
Shape
*
shape
=
obj
-
>
lastProperty
(
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
=
=
shape
-
>
inDictionary
(
)
)
;
while
(
shape
-
>
parent
)
{
shape
=
shape
-
>
parent
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
=
=
shape
-
>
inDictionary
(
)
)
;
}
MOZ_ASSERT
(
shape
-
>
isEmptyShape
(
)
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
shape
-
>
listp
=
&
obj
-
>
shape_
;
JS_ALWAYS_TRUE
(
obj
-
>
setLastProperty
(
cx
shape
)
)
;
if
(
!
cx
-
>
helperThread
(
)
)
+
+
cx
-
>
propertyRemovals
;
obj
-
>
checkShapeConsistency
(
)
;
}
bool
NativeObject
:
:
rollbackProperties
(
JSContext
*
cx
HandleNativeObject
obj
uint32_t
slotSpan
)
{
MOZ_ASSERT
(
!
obj
-
>
inDictionaryMode
(
)
&
&
slotSpan
<
=
obj
-
>
slotSpan
(
)
)
;
while
(
true
)
{
if
(
obj
-
>
lastProperty
(
)
-
>
isEmptyShape
(
)
)
{
MOZ_ASSERT
(
slotSpan
=
=
0
)
;
break
;
}
else
{
uint32_t
slot
=
obj
-
>
lastProperty
(
)
-
>
slot
(
)
;
if
(
slot
<
slotSpan
)
break
;
}
if
(
!
NativeObject
:
:
removeProperty
(
cx
obj
obj
-
>
lastProperty
(
)
-
>
propid
(
)
)
)
return
false
;
}
return
true
;
}
Shape
*
NativeObject
:
:
replaceWithNewEquivalentShape
(
JSContext
*
cx
HandleNativeObject
obj
Shape
*
oldShape
Shape
*
newShape
bool
accessorShape
)
{
MOZ_ASSERT
(
cx
-
>
isInsideCurrentZone
(
oldShape
)
)
;
MOZ_ASSERT_IF
(
oldShape
!
=
obj
-
>
lastProperty
(
)
obj
-
>
inDictionaryMode
(
)
&
&
obj
-
>
lookup
(
cx
oldShape
-
>
propidRef
(
)
)
=
=
oldShape
)
;
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
RootedShape
newRoot
(
cx
newShape
)
;
if
(
!
toDictionaryMode
(
cx
obj
)
)
return
nullptr
;
oldShape
=
obj
-
>
lastProperty
(
)
;
newShape
=
newRoot
;
}
if
(
!
newShape
)
{
RootedShape
oldRoot
(
cx
oldShape
)
;
newShape
=
(
oldShape
-
>
isAccessorShape
(
)
|
|
accessorShape
)
?
Allocate
<
AccessorShape
>
(
cx
)
:
Allocate
<
Shape
>
(
cx
)
;
if
(
!
newShape
)
return
nullptr
;
new
(
newShape
)
Shape
(
oldRoot
-
>
base
(
)
-
>
unowned
(
)
0
)
;
oldShape
=
oldRoot
;
}
AutoCheckCannotGC
nogc
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
nogc
)
;
if
(
!
table
)
return
nullptr
;
ShapeTable
:
:
Entry
*
entry
=
oldShape
-
>
isEmptyShape
(
)
?
nullptr
:
&
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
oldShape
-
>
propidRef
(
)
nogc
)
;
StackShape
nshape
(
oldShape
)
;
newShape
-
>
initDictionaryShape
(
nshape
obj
-
>
numFixedSlots
(
)
oldShape
-
>
listp
)
;
MOZ_ASSERT
(
newShape
-
>
parent
=
=
oldShape
)
;
oldShape
-
>
removeFromDictionary
(
obj
)
;
if
(
newShape
=
=
obj
-
>
lastProperty
(
)
)
oldShape
-
>
handoffTableTo
(
newShape
)
;
if
(
entry
)
entry
-
>
setPreservingCollision
(
newShape
)
;
return
newShape
;
}
bool
NativeObject
:
:
shadowingShapeChange
(
JSContext
*
cx
HandleNativeObject
obj
const
Shape
&
shape
)
{
return
generateOwnShape
(
cx
obj
)
;
}
bool
JSObject
:
:
setFlags
(
JSContext
*
cx
HandleObject
obj
BaseShape
:
:
Flag
flags
GenerateShape
generateShape
)
{
if
(
obj
-
>
hasAllFlags
(
flags
)
)
return
true
;
if
(
obj
-
>
isNative
(
)
&
&
obj
-
>
as
<
NativeObject
>
(
)
.
inDictionaryMode
(
)
)
{
if
(
generateShape
=
=
GENERATE_SHAPE
)
{
if
(
!
NativeObject
:
:
generateOwnShape
(
cx
obj
.
as
<
NativeObject
>
(
)
)
)
return
false
;
}
StackBaseShape
base
(
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
base
.
flags
|
=
flags
;
UnownedBaseShape
*
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
false
;
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
-
>
base
(
)
-
>
adoptUnowned
(
nbase
)
;
return
true
;
}
Shape
*
existingShape
=
obj
-
>
ensureShape
(
cx
)
;
if
(
!
existingShape
)
return
false
;
Shape
*
newShape
=
Shape
:
:
setObjectFlags
(
cx
flags
obj
-
>
taggedProto
(
)
existingShape
)
;
if
(
!
newShape
)
return
false
;
obj
-
>
as
<
ShapedObject
>
(
)
.
setShape
(
newShape
)
;
return
true
;
}
bool
NativeObject
:
:
clearFlag
(
JSContext
*
cx
HandleNativeObject
obj
BaseShape
:
:
Flag
flag
)
{
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
-
>
getObjectFlags
(
)
&
flag
)
;
StackBaseShape
base
(
obj
-
>
lastProperty
(
)
)
;
base
.
flags
&
=
~
flag
;
UnownedBaseShape
*
nbase
=
BaseShape
:
:
getUnowned
(
cx
base
)
;
if
(
!
nbase
)
return
false
;
obj
-
>
lastProperty
(
)
-
>
base
(
)
-
>
adoptUnowned
(
nbase
)
;
return
true
;
}
Shape
*
Shape
:
:
setObjectFlags
(
JSContext
*
cx
BaseShape
:
:
Flag
flags
TaggedProto
proto
Shape
*
last
)
{
if
(
(
last
-
>
getObjectFlags
(
)
&
flags
)
=
=
flags
)
return
last
;
StackBaseShape
base
(
last
)
;
base
.
flags
|
=
flags
;
RootedShape
lastRoot
(
cx
last
)
;
return
replaceLastProperty
(
cx
base
proto
lastRoot
)
;
}
inline
HashNumber
StackBaseShape
:
:
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
lookup
.
flags
;
hash
=
RotateLeft
(
hash
4
)
^
(
uintptr_t
(
lookup
.
clasp
)
>
>
3
)
;
return
hash
;
}
inline
bool
StackBaseShape
:
:
match
(
ReadBarriered
<
UnownedBaseShape
*
>
key
const
Lookup
&
lookup
)
{
return
key
.
unbarrieredGet
(
)
-
>
flags
=
=
lookup
.
flags
&
&
key
.
unbarrieredGet
(
)
-
>
clasp_
=
=
lookup
.
clasp
;
}
inline
BaseShape
:
:
BaseShape
(
const
StackBaseShape
&
base
)
:
clasp_
(
base
.
clasp
)
flags
(
base
.
flags
)
slotSpan_
(
0
)
unowned_
(
nullptr
)
table_
(
nullptr
)
{
}
void
BaseShape
:
:
copyFromUnowned
(
BaseShape
&
dest
UnownedBaseShape
&
src
)
{
dest
.
clasp_
=
src
.
clasp_
;
dest
.
slotSpan_
=
src
.
slotSpan_
;
dest
.
unowned_
=
&
src
;
dest
.
flags
=
src
.
flags
|
OWNED_SHAPE
;
}
inline
void
BaseShape
:
:
adoptUnowned
(
UnownedBaseShape
*
other
)
{
MOZ_ASSERT
(
isOwned
(
)
)
;
uint32_t
span
=
slotSpan
(
)
;
BaseShape
:
:
copyFromUnowned
(
*
this
*
other
)
;
setSlotSpan
(
span
)
;
assertConsistency
(
)
;
}
UnownedBaseShape
*
BaseShape
:
:
getUnowned
(
JSContext
*
cx
StackBaseShape
&
base
)
{
auto
&
table
=
cx
-
>
zone
(
)
-
>
baseShapes
(
)
;
if
(
!
table
.
initialized
(
)
&
&
!
table
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
auto
p
=
MakeDependentAddPtr
(
cx
table
base
)
;
if
(
p
)
return
*
p
;
BaseShape
*
nbase_
=
Allocate
<
BaseShape
>
(
cx
)
;
if
(
!
nbase_
)
return
nullptr
;
new
(
nbase_
)
BaseShape
(
base
)
;
UnownedBaseShape
*
nbase
=
static_cast
<
UnownedBaseShape
*
>
(
nbase_
)
;
if
(
!
p
.
add
(
cx
table
base
nbase
)
)
return
nullptr
;
return
nbase
;
}
void
BaseShape
:
:
assertConsistency
(
)
{
#
ifdef
DEBUG
if
(
isOwned
(
)
)
{
UnownedBaseShape
*
unowned
=
baseUnowned
(
)
;
MOZ_ASSERT
(
getObjectFlags
(
)
=
=
unowned
-
>
getObjectFlags
(
)
)
;
}
#
endif
}
void
BaseShape
:
:
traceChildren
(
JSTracer
*
trc
)
{
traceChildrenSkipShapeTable
(
trc
)
;
traceShapeTable
(
trc
)
;
}
void
BaseShape
:
:
traceChildrenSkipShapeTable
(
JSTracer
*
trc
)
{
if
(
isOwned
(
)
)
TraceEdge
(
trc
&
unowned_
"
base
"
)
;
assertConsistency
(
)
;
}
void
BaseShape
:
:
traceShapeTable
(
JSTracer
*
trc
)
{
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
maybeTable
(
nogc
)
)
table
-
>
trace
(
trc
)
;
}
#
ifdef
DEBUG
bool
BaseShape
:
:
canSkipMarkingShapeTable
(
Shape
*
lastShape
)
{
AutoCheckCannotGC
nogc
;
ShapeTable
*
table
=
maybeTable
(
nogc
)
;
if
(
!
table
)
return
true
;
uint32_t
count
=
0
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
lastShape
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
Shape
*
shape
=
&
r
.
front
(
)
;
ShapeTable
:
:
Entry
&
entry
=
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
shape
-
>
propid
(
)
nogc
)
;
if
(
entry
.
isLive
(
)
)
count
+
+
;
}
return
count
=
=
table
-
>
entryCount
(
)
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkBaseShapeTableAfterMovingGC
(
)
{
if
(
!
baseShapes
(
)
.
initialized
(
)
)
return
;
for
(
BaseShapeSet
:
:
Enum
e
(
baseShapes
(
)
.
get
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
UnownedBaseShape
*
base
=
e
.
front
(
)
.
unbarrieredGet
(
)
;
CheckGCThingAfterMovingGC
(
base
)
;
BaseShapeSet
:
:
Ptr
ptr
=
baseShapes
(
)
.
lookup
(
base
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
void
BaseShape
:
:
finalize
(
FreeOp
*
fop
)
{
if
(
table_
)
{
fop
-
>
delete_
(
table_
)
;
table_
=
nullptr
;
}
}
inline
InitialShapeEntry
:
:
InitialShapeEntry
(
)
:
shape
(
nullptr
)
proto
(
)
{
}
inline
InitialShapeEntry
:
:
InitialShapeEntry
(
Shape
*
shape
const
Lookup
:
:
ShapeProto
&
proto
)
:
shape
(
shape
)
proto
(
proto
)
{
}
inline
HashNumber
InitialShapeEntry
:
:
hash
(
const
Lookup
&
lookup
)
{
return
(
RotateLeft
(
uintptr_t
(
lookup
.
clasp
)
>
>
3
4
)
^
lookup
.
proto
.
hashCode
(
)
)
+
lookup
.
nfixed
;
}
inline
bool
InitialShapeEntry
:
:
match
(
const
InitialShapeEntry
&
key
const
Lookup
&
lookup
)
{
const
Shape
*
shape
=
key
.
shape
.
unbarrieredGet
(
)
;
return
lookup
.
clasp
=
=
shape
-
>
getObjectClass
(
)
&
&
lookup
.
nfixed
=
=
shape
-
>
numFixedSlots
(
)
&
&
lookup
.
baseFlags
=
=
shape
-
>
getObjectFlags
(
)
&
&
lookup
.
proto
.
match
(
key
.
proto
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkInitialShapesTableAfterMovingGC
(
)
{
if
(
!
initialShapes
(
)
.
initialized
(
)
)
return
;
for
(
InitialShapeSet
:
:
Enum
e
(
initialShapes
(
)
.
get
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
InitialShapeEntry
entry
=
e
.
front
(
)
;
JSProtoKey
protoKey
=
entry
.
proto
.
key
(
)
;
TaggedProto
proto
=
entry
.
proto
.
proto
(
)
.
unbarrieredGet
(
)
;
Shape
*
shape
=
entry
.
shape
.
unbarrieredGet
(
)
;
CheckGCThingAfterMovingGC
(
shape
)
;
if
(
proto
.
isObject
(
)
)
CheckGCThingAfterMovingGC
(
proto
.
toObject
(
)
)
;
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
Lookup
:
:
ShapeProto
(
protoKey
proto
)
shape
-
>
numFixedSlots
(
)
shape
-
>
getObjectFlags
(
)
)
;
InitialShapeSet
:
:
Ptr
ptr
=
initialShapes
(
)
.
lookup
(
lookup
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
Shape
*
EmptyShape
:
:
new_
(
JSContext
*
cx
Handle
<
UnownedBaseShape
*
>
base
uint32_t
nfixed
)
{
Shape
*
shape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
new
(
shape
)
EmptyShape
(
base
nfixed
)
;
return
shape
;
}
static
bool
IsOriginalProto
(
GlobalObject
*
global
JSProtoKey
key
JSObject
&
proto
)
{
if
(
global
-
>
getPrototype
(
key
)
!
=
ObjectValue
(
proto
)
)
return
false
;
if
(
key
=
=
JSProto_Object
)
{
MOZ_ASSERT
(
proto
.
staticPrototypeIsImmutable
(
)
"
proto
should
be
Object
.
prototype
whose
prototype
is
"
"
immutable
"
)
;
MOZ_ASSERT
(
proto
.
staticPrototype
(
)
=
=
nullptr
"
Object
.
prototype
must
have
null
prototype
"
)
;
return
true
;
}
JSObject
*
protoProto
=
proto
.
staticPrototype
(
)
;
if
(
!
protoProto
|
|
global
-
>
getPrototype
(
JSProto_Object
)
!
=
ObjectValue
(
*
protoProto
)
)
return
false
;
MOZ_ASSERT
(
protoProto
-
>
staticPrototypeIsImmutable
(
)
"
protoProto
should
be
Object
.
prototype
whose
prototype
is
"
"
immutable
"
)
;
MOZ_ASSERT
(
protoProto
-
>
staticPrototype
(
)
=
=
nullptr
"
Object
.
prototype
must
have
null
prototype
"
)
;
return
true
;
}
static
JSProtoKey
GetInitialShapeProtoKey
(
TaggedProto
proto
JSContext
*
cx
)
{
if
(
proto
.
isObject
(
)
&
&
proto
.
toObject
(
)
-
>
hasStaticPrototype
(
)
)
{
GlobalObject
*
global
=
cx
-
>
global
(
)
;
JSObject
&
obj
=
*
proto
.
toObject
(
)
;
MOZ_ASSERT
(
global
=
=
&
obj
.
global
(
)
)
;
if
(
IsOriginalProto
(
global
JSProto_Object
obj
)
)
return
JSProto_Object
;
if
(
IsOriginalProto
(
global
JSProto_Function
obj
)
)
return
JSProto_Function
;
if
(
IsOriginalProto
(
global
JSProto_Array
obj
)
)
return
JSProto_Array
;
if
(
IsOriginalProto
(
global
JSProto_RegExp
obj
)
)
return
JSProto_RegExp
;
}
return
JSProto_LIMIT
;
}
Shape
*
EmptyShape
:
:
getInitialShape
(
JSContext
*
cx
const
Class
*
clasp
TaggedProto
proto
size_t
nfixed
uint32_t
objectFlags
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
auto
&
table
=
cx
-
>
zone
(
)
-
>
initialShapes
(
)
;
if
(
!
table
.
initialized
(
)
&
&
!
table
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
auto
protoPointer
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
Lookup
:
:
ShapeProto
(
proto
)
nfixed
objectFlags
)
)
;
if
(
protoPointer
)
return
protoPointer
-
>
shape
;
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
Shape
*
shape
=
nullptr
;
bool
insertKey
=
false
;
mozilla
:
:
Maybe
<
DependentAddPtr
<
InitialShapeSet
>
>
keyPointer
;
JSProtoKey
key
=
GetInitialShapeProtoKey
(
protoRoot
cx
)
;
if
(
key
!
=
JSProto_LIMIT
)
{
keyPointer
.
emplace
(
MakeDependentAddPtr
(
cx
table
.
get
(
)
Lookup
(
clasp
Lookup
:
:
ShapeProto
(
key
)
nfixed
objectFlags
)
)
)
;
if
(
keyPointer
.
ref
(
)
)
{
shape
=
keyPointer
.
ref
(
)
-
>
shape
;
MOZ_ASSERT
(
shape
)
;
}
else
{
insertKey
=
true
;
}
}
if
(
!
shape
)
{
StackBaseShape
base
(
cx
clasp
objectFlags
)
;
Rooted
<
UnownedBaseShape
*
>
nbase
(
cx
BaseShape
:
:
getUnowned
(
cx
base
)
)
;
if
(
!
nbase
)
return
nullptr
;
shape
=
EmptyShape
:
:
new_
(
cx
nbase
nfixed
)
;
if
(
!
shape
)
return
nullptr
;
}
Lookup
:
:
ShapeProto
shapeProto
(
protoRoot
)
;
Lookup
lookup
(
clasp
shapeProto
nfixed
objectFlags
)
;
if
(
!
protoPointer
.
add
(
cx
table
lookup
InitialShapeEntry
(
shape
shapeProto
)
)
)
return
nullptr
;
if
(
insertKey
)
{
Lookup
:
:
ShapeProto
shapeProto
(
key
)
;
Lookup
lookup
(
clasp
shapeProto
nfixed
objectFlags
)
;
if
(
!
keyPointer
-
>
add
(
cx
table
.
get
(
)
lookup
InitialShapeEntry
(
shape
shapeProto
)
)
)
return
nullptr
;
}
return
shape
;
}
Shape
*
EmptyShape
:
:
getInitialShape
(
JSContext
*
cx
const
Class
*
clasp
TaggedProto
proto
AllocKind
kind
uint32_t
objectFlags
)
{
return
getInitialShape
(
cx
clasp
proto
GetGCKindSlots
(
kind
clasp
)
objectFlags
)
;
}
void
NewObjectCache
:
:
invalidateEntriesForShape
(
JSContext
*
cx
HandleShape
shape
HandleObject
proto
)
{
const
Class
*
clasp
=
shape
-
>
getObjectClass
(
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
shape
-
>
numFixedSlots
(
)
)
;
if
(
CanBeFinalizedInBackground
(
kind
clasp
)
)
kind
=
GetBackgroundAllocKind
(
kind
)
;
RootedObjectGroup
group
(
cx
ObjectGroup
:
:
defaultNewGroup
(
cx
clasp
TaggedProto
(
proto
)
)
)
;
if
(
!
group
)
{
purge
(
)
;
cx
-
>
recoverFromOutOfMemory
(
)
;
return
;
}
EntryIndex
entry
;
for
(
CompartmentsInZoneIter
comp
(
shape
-
>
zone
(
)
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
GlobalObject
*
global
=
comp
-
>
unsafeUnbarrieredMaybeGlobal
(
)
)
{
if
(
lookupGlobal
(
clasp
global
kind
&
entry
)
)
PodZero
(
&
entries
[
entry
]
)
;
}
}
if
(
!
proto
-
>
is
<
GlobalObject
>
(
)
&
&
lookupProto
(
clasp
proto
kind
&
entry
)
)
PodZero
(
&
entries
[
entry
]
)
;
if
(
lookupGroup
(
group
kind
&
entry
)
)
PodZero
(
&
entries
[
entry
]
)
;
}
void
EmptyShape
:
:
insertInitialShape
(
JSContext
*
cx
HandleShape
shape
HandleObject
proto
)
{
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
Lookup
:
:
ShapeProto
(
TaggedProto
(
proto
)
)
shape
-
>
numFixedSlots
(
)
shape
-
>
getObjectFlags
(
)
)
;
InitialShapeSet
:
:
Ptr
p
=
cx
-
>
zone
(
)
-
>
initialShapes
(
)
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
)
;
InitialShapeEntry
&
entry
=
const_cast
<
InitialShapeEntry
&
>
(
*
p
)
;
if
(
entry
.
shape
=
=
shape
)
return
;
#
ifdef
DEBUG
Shape
*
nshape
=
shape
;
while
(
!
nshape
-
>
isEmptyShape
(
)
)
nshape
=
nshape
-
>
previous
(
)
;
MOZ_ASSERT
(
nshape
=
=
entry
.
shape
)
;
#
endif
entry
.
shape
=
ReadBarrieredShape
(
shape
)
;
JSProtoKey
key
=
GetInitialShapeProtoKey
(
TaggedProto
(
proto
)
cx
)
;
if
(
key
!
=
JSProto_LIMIT
)
{
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
Lookup
:
:
ShapeProto
(
key
)
shape
-
>
numFixedSlots
(
)
shape
-
>
getObjectFlags
(
)
)
;
if
(
InitialShapeSet
:
:
Ptr
p
=
cx
-
>
zone
(
)
-
>
initialShapes
(
)
.
lookup
(
lookup
)
)
{
InitialShapeEntry
&
entry
=
const_cast
<
InitialShapeEntry
&
>
(
*
p
)
;
if
(
entry
.
shape
!
=
shape
)
entry
.
shape
=
ReadBarrieredShape
(
shape
)
;
}
}
if
(
!
cx
-
>
helperThread
(
)
)
cx
-
>
caches
(
)
.
newObjectCache
.
invalidateEntriesForShape
(
cx
shape
proto
)
;
}
void
Zone
:
:
fixupInitialShapeTable
(
)
{
if
(
!
initialShapes
(
)
.
initialized
(
)
)
return
;
for
(
InitialShapeSet
:
:
Enum
e
(
initialShapes
(
)
.
get
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Shape
*
shape
=
e
.
front
(
)
.
shape
.
unbarrieredGet
(
)
;
if
(
IsForwarded
(
shape
)
)
{
shape
=
Forwarded
(
shape
)
;
e
.
mutableFront
(
)
.
shape
.
set
(
shape
)
;
}
shape
-
>
updateBaseShapeAfterMovingGC
(
)
;
InitialShapeEntry
entry
=
e
.
front
(
)
;
if
(
entry
.
proto
.
proto
(
)
.
isObject
(
)
&
&
IsForwarded
(
entry
.
proto
.
proto
(
)
.
toObject
(
)
)
)
{
entry
.
proto
.
setProto
(
TaggedProto
(
Forwarded
(
entry
.
proto
.
proto
(
)
.
toObject
(
)
)
)
)
;
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
Lookup
relookup
(
shape
-
>
getObjectClass
(
)
Lookup
:
:
ShapeProto
(
entry
.
proto
)
shape
-
>
numFixedSlots
(
)
shape
-
>
getObjectFlags
(
)
)
;
e
.
rekeyFront
(
relookup
entry
)
;
}
}
}
void
AutoRooterGetterSetter
:
:
Inner
:
:
trace
(
JSTracer
*
trc
)
{
if
(
(
attrs
&
JSPROP_GETTER
)
&
&
*
pgetter
)
TraceRoot
(
trc
(
JSObject
*
*
)
pgetter
"
AutoRooterGetterSetter
getter
"
)
;
if
(
(
attrs
&
JSPROP_SETTER
)
&
&
*
psetter
)
TraceRoot
(
trc
(
JSObject
*
*
)
psetter
"
AutoRooterGetterSetter
setter
"
)
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
Shape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
get
(
)
.
maybeTable
(
nogc
)
)
size
+
=
table
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
!
get
(
)
.
inDictionary
(
)
&
&
get
(
)
.
kids
.
isHash
(
)
)
size
+
=
get
(
)
.
kids
.
toHash
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
size
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
BaseShape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
void
PropertyResult
:
:
trace
(
JSTracer
*
trc
)
{
if
(
isNativeProperty
(
)
)
TraceRoot
(
trc
&
shape_
"
PropertyResult
:
:
shape_
"
)
;
}
