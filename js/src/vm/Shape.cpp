#
include
"
vm
/
Shape
-
inl
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Caches
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
CeilingLog2Size
;
using
mozilla
:
:
PodZero
;
using
JS
:
:
AutoCheckCannotGC
;
bool
ShapeIC
:
:
init
(
JSContext
*
cx
)
{
size_
=
MAX_SIZE
;
entries_
.
reset
(
cx
-
>
pod_calloc
<
Entry
>
(
size_
)
)
;
return
(
!
entries_
)
?
false
:
true
;
}
bool
ShapeTable
:
:
init
(
JSContext
*
cx
Shape
*
lastProp
)
{
if
(
!
set_
.
reserve
(
lastProp
-
>
entryCount
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
Shape
:
:
Range
<
NoGC
>
r
(
lastProp
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
Shape
&
shape
=
r
.
front
(
)
;
set_
.
putNewInfallible
(
shape
.
propidRaw
(
)
&
shape
)
;
}
return
true
;
}
void
Shape
:
:
removeFromDictionary
(
NativeObject
*
obj
)
{
MOZ_ASSERT
(
inDictionary
(
)
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
obj
-
>
shape
(
)
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
obj
-
>
shape
(
)
-
>
dictNext
.
isNone
(
)
)
;
if
(
parent
)
{
parent
-
>
setDictionaryNextPtr
(
dictNext
)
;
}
if
(
dictNext
.
isShape
(
)
)
{
dictNext
.
toShape
(
)
-
>
setParent
(
parent
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
=
=
this
)
;
obj
-
>
setShape
(
parent
)
;
}
clearDictionaryNextPtr
(
)
;
obj
-
>
shape
(
)
-
>
clearCachedBigEnoughForShapeTable
(
)
;
}
void
Shape
:
:
initDictionaryShapeAtEnd
(
const
StackShape
&
child
NativeObject
*
obj
)
{
new
(
this
)
Shape
(
child
obj
-
>
numFixedSlots
(
)
)
;
this
-
>
immutableFlags
|
=
IN_DICTIONARY
;
MOZ_ASSERT
(
!
parent
)
;
MOZ_ASSERT
(
dictNext
.
isNone
(
)
)
;
Shape
*
prev
=
obj
-
>
lastProperty
(
)
;
MOZ_ASSERT
(
prev
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
zone
(
)
=
=
prev
-
>
zone
(
)
)
;
MOZ_ASSERT
(
prev
-
>
dictNext
.
isNone
(
)
)
;
this
-
>
setParent
(
prev
)
;
prev
-
>
setNextDictionaryShape
(
this
)
;
obj
-
>
setShape
(
this
)
;
}
void
Shape
:
:
initDictionaryShapeAtFront
(
const
StackShape
&
child
uint32_t
nfixed
Shape
*
next
)
{
new
(
this
)
Shape
(
child
nfixed
)
;
this
-
>
immutableFlags
|
=
IN_DICTIONARY
;
MOZ_ASSERT
(
!
parent
)
;
MOZ_ASSERT
(
dictNext
.
isNone
(
)
)
;
if
(
next
)
{
MOZ_ASSERT
(
next
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
zone
(
)
=
=
next
-
>
zone
(
)
)
;
MOZ_ASSERT
(
!
next
-
>
parent
)
;
this
-
>
setNextDictionaryShape
(
next
)
;
next
-
>
setParent
(
this
)
;
}
}
void
Shape
:
:
handoffTableTo
(
Shape
*
shape
)
{
MOZ_ASSERT
(
inDictionary
(
)
&
&
shape
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
this
!
=
shape
)
;
ShapeTable
*
table
=
cache_
.
getTablePointer
(
)
;
shape
-
>
setTable
(
table
)
;
cache_
=
ShapeCachePtr
(
)
;
RemoveCellMemory
(
this
sizeof
(
ShapeTable
)
MemoryUse
:
:
ShapeCache
)
;
AddCellMemory
(
shape
sizeof
(
ShapeTable
)
MemoryUse
:
:
ShapeCache
)
;
}
bool
Shape
:
:
hashify
(
JSContext
*
cx
Shape
*
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
hasTable
(
)
)
;
UniquePtr
<
ShapeTable
>
table
=
cx
-
>
make_unique
<
ShapeTable
>
(
)
;
if
(
!
table
)
{
return
false
;
}
if
(
!
table
-
>
init
(
cx
shape
)
)
{
return
false
;
}
shape
-
>
maybePurgeCache
(
cx
-
>
defaultFreeOp
(
)
)
;
shape
-
>
setTable
(
table
.
release
(
)
)
;
AddCellMemory
(
shape
sizeof
(
ShapeTable
)
MemoryUse
:
:
ShapeCache
)
;
return
true
;
}
void
ShapeCachePtr
:
:
maybePurgeCache
(
JSFreeOp
*
fop
Shape
*
shape
)
{
if
(
isTable
(
)
)
{
ShapeTable
*
table
=
getTablePointer
(
)
;
if
(
table
-
>
freeList
(
)
=
=
SHAPE_INVALID_SLOT
)
{
fop
-
>
delete_
(
shape
getTablePointer
(
)
MemoryUse
:
:
ShapeCache
)
;
p
=
0
;
}
else
{
table
-
>
compact
(
)
;
}
}
else
if
(
isIC
(
)
)
{
fop
-
>
delete_
<
ShapeIC
>
(
shape
getICPointer
(
)
MemoryUse
:
:
ShapeCache
)
;
p
=
0
;
}
}
bool
Shape
:
:
cachify
(
JSContext
*
cx
Shape
*
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
hasTable
(
)
&
&
!
shape
-
>
hasIC
(
)
)
;
UniquePtr
<
ShapeIC
>
ic
=
cx
-
>
make_unique
<
ShapeIC
>
(
)
;
if
(
!
ic
)
{
return
false
;
}
if
(
!
ic
-
>
init
(
cx
)
)
{
return
false
;
}
shape
-
>
setIC
(
ic
.
release
(
)
)
;
AddCellMemory
(
shape
sizeof
(
ShapeIC
)
MemoryUse
:
:
ShapeCache
)
;
return
true
;
}
void
ShapeCachePtr
:
:
trace
(
JSTracer
*
trc
)
{
if
(
isIC
(
)
)
{
getICPointer
(
)
-
>
trace
(
trc
)
;
}
else
if
(
isTable
(
)
)
{
getTablePointer
(
)
-
>
trace
(
trc
)
;
}
}
void
ShapeIC
:
:
trace
(
JSTracer
*
trc
)
{
for
(
size_t
i
=
0
;
i
<
entryCount
(
)
;
i
+
+
)
{
Entry
&
entry
=
entries_
[
i
]
;
if
(
entry
.
shape_
)
{
TraceManuallyBarrieredEdge
(
trc
&
entry
.
shape_
"
ShapeIC
shape
"
)
;
}
}
}
void
ShapeTable
:
:
trace
(
JSTracer
*
trc
)
{
for
(
Set
:
:
Enum
e
(
set_
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Shape
*
shape
=
e
.
front
(
)
;
MOZ_ASSERT
(
shape
)
;
TraceManuallyBarrieredEdge
(
trc
&
shape
"
ShapeTable
shape
"
)
;
if
(
shape
!
=
e
.
front
(
)
)
{
e
.
mutableFront
(
)
=
shape
;
}
}
}
inline
void
ShapeCachePtr
:
:
destroy
(
JSFreeOp
*
fop
Shape
*
shape
)
{
if
(
isTable
(
)
)
{
fop
-
>
delete_
(
shape
getTablePointer
(
)
MemoryUse
:
:
ShapeCache
)
;
}
else
if
(
isIC
(
)
)
{
fop
-
>
delete_
(
shape
getICPointer
(
)
MemoryUse
:
:
ShapeCache
)
;
}
p
=
0
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
ShapeCachePtr
:
:
checkAfterMovingGC
(
)
{
if
(
isIC
(
)
)
{
getICPointer
(
)
-
>
checkAfterMovingGC
(
)
;
}
else
if
(
isTable
(
)
)
{
getTablePointer
(
)
-
>
checkAfterMovingGC
(
)
;
}
}
void
ShapeIC
:
:
checkAfterMovingGC
(
)
{
for
(
size_t
i
=
0
;
i
<
entryCount
(
)
;
i
+
+
)
{
Entry
&
entry
=
entries_
[
i
]
;
Shape
*
shape
=
entry
.
shape_
;
if
(
shape
)
{
CheckGCThingAfterMovingGC
(
shape
)
;
}
}
}
void
ShapeTable
:
:
checkAfterMovingGC
(
)
{
for
(
Set
:
:
Enum
e
(
set_
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Shape
*
shape
=
e
.
front
(
)
;
MOZ_ASSERT
(
shape
)
;
CheckGCThingAfterMovingGC
(
shape
)
;
}
}
#
endif
Shape
*
Shape
:
:
replaceLastProperty
(
JSContext
*
cx
ObjectFlags
objectFlags
TaggedProto
proto
HandleShape
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
inDictionary
(
)
)
;
if
(
!
shape
-
>
parent
)
{
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
shape
-
>
numFixedSlots
(
)
)
;
return
EmptyShape
:
:
getInitialShape
(
cx
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
proto
kind
objectFlags
)
;
}
Rooted
<
StackShape
>
child
(
cx
StackShape
(
shape
)
)
;
child
.
setObjectFlags
(
objectFlags
)
;
if
(
proto
!
=
shape
-
>
proto
(
)
)
{
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
BaseShape
*
nbase
=
BaseShape
:
:
get
(
cx
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
protoRoot
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
child
.
setBase
(
nbase
)
;
}
return
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
getChild
(
cx
shape
-
>
parent
child
)
;
}
MOZ_ALWAYS_INLINE
Shape
*
NativeObject
:
:
getChildProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleShape
parent
MutableHandle
<
StackShape
>
child
)
{
MOZ_ASSERT
(
!
child
.
isCustomDataProperty
(
)
)
;
if
(
child
.
hasMissingSlot
(
)
)
{
uint32_t
slot
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
allocDictionarySlot
(
cx
obj
&
slot
)
)
{
return
nullptr
;
}
}
else
{
slot
=
obj
-
>
slotSpan
(
)
;
MOZ_ASSERT
(
slot
>
=
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
)
;
MOZ_ASSERT
(
slot
<
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
+
PropertyTree
:
:
MAX_HEIGHT
)
;
MOZ_ASSERT
(
slot
<
SHAPE_MAXIMUM_SLOT
)
;
}
child
.
setSlot
(
slot
)
;
}
else
{
MOZ_ASSERT
(
child
.
slot
(
)
<
obj
-
>
slotSpan
(
)
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
|
|
parent
-
>
hasMissingSlot
(
)
|
|
child
.
slot
(
)
=
=
parent
-
>
maybeSlot
(
)
+
1
|
|
(
parent
-
>
maybeSlot
(
)
+
1
<
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
&
&
child
.
slot
(
)
=
=
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
)
)
;
}
if
(
obj
-
>
inDictionaryMode
(
)
)
{
AutoKeepShapeCaches
keep
(
cx
)
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
keep
)
;
if
(
!
table
)
{
return
nullptr
;
}
MOZ_ASSERT
(
parent
=
=
obj
-
>
lastProperty
(
)
)
;
Shape
*
shape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
{
return
nullptr
;
}
MOZ_ASSERT
(
child
.
slot
(
)
<
obj
-
>
slotSpan
(
)
)
;
shape
-
>
initDictionaryShapeAtEnd
(
child
obj
)
;
if
(
!
table
-
>
add
(
cx
child
.
propid
(
)
shape
)
)
{
shape
-
>
removeFromDictionary
(
obj
)
;
return
nullptr
;
}
MOZ_ASSERT
(
shape
-
>
previous
(
)
-
>
maybeTable
(
keep
)
=
=
table
)
;
shape
-
>
previous
(
)
-
>
handoffTableTo
(
shape
)
;
return
shape
;
}
Shape
*
shape
=
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
inlinedGetChild
(
cx
parent
child
)
;
if
(
!
shape
)
{
return
nullptr
;
}
MOZ_ASSERT
(
shape
-
>
parent
=
=
parent
)
;
MOZ_ASSERT_IF
(
parent
!
=
obj
-
>
lastProperty
(
)
parent
=
=
obj
-
>
lastProperty
(
)
-
>
parent
)
;
if
(
!
obj
-
>
setLastProperty
(
cx
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
MOZ_ALWAYS_INLINE
Shape
*
NativeObject
:
:
getChildCustomDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleShape
parent
MutableHandle
<
StackShape
>
child
)
{
MOZ_ASSERT
(
child
.
isCustomDataProperty
(
)
)
;
child
.
setSlot
(
parent
-
>
maybeSlot
(
)
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
AutoKeepShapeCaches
keep
(
cx
)
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
keep
)
;
if
(
!
table
)
{
return
nullptr
;
}
MOZ_ASSERT
(
parent
=
=
obj
-
>
lastProperty
(
)
)
;
Shape
*
shape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
{
return
nullptr
;
}
shape
-
>
initDictionaryShapeAtEnd
(
child
obj
)
;
if
(
!
table
-
>
add
(
cx
child
.
propid
(
)
shape
)
)
{
shape
-
>
removeFromDictionary
(
obj
)
;
return
nullptr
;
}
MOZ_ASSERT
(
shape
-
>
previous
(
)
-
>
maybeTable
(
keep
)
=
=
table
)
;
shape
-
>
previous
(
)
-
>
handoffTableTo
(
shape
)
;
return
shape
;
}
Shape
*
shape
=
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
inlinedGetChild
(
cx
parent
child
)
;
if
(
!
shape
)
{
return
nullptr
;
}
MOZ_ASSERT
(
shape
-
>
parent
=
=
parent
)
;
MOZ_ASSERT_IF
(
parent
!
=
obj
-
>
lastProperty
(
)
parent
=
=
obj
-
>
lastProperty
(
)
-
>
parent
)
;
if
(
!
obj
-
>
setLastProperty
(
cx
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
bool
js
:
:
NativeObject
:
:
toDictionaryMode
(
JSContext
*
cx
HandleNativeObject
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
cx
-
>
isInsideCurrentCompartment
(
obj
)
)
;
uint32_t
span
=
obj
-
>
slotSpan
(
)
;
RootedShape
root
(
cx
)
;
RootedShape
dictionaryShape
(
cx
)
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
)
;
while
(
shape
)
{
MOZ_ASSERT
(
!
shape
-
>
inDictionary
(
)
)
;
Shape
*
dprop
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
dprop
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
StackShape
child
(
shape
)
;
dprop
-
>
initDictionaryShapeAtFront
(
child
obj
-
>
numFixedSlots
(
)
dictionaryShape
)
;
if
(
!
dictionaryShape
)
{
root
=
dprop
;
}
MOZ_ASSERT
(
!
dprop
-
>
hasTable
(
)
)
;
dictionaryShape
=
dprop
;
shape
=
shape
-
>
previous
(
)
;
}
if
(
!
Shape
:
:
hashify
(
cx
root
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
MOZ_ASSERT
(
root
-
>
dictNext
.
isNone
(
)
)
;
obj
-
>
setShape
(
root
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
obj
-
>
setDictionaryModeSlotSpan
(
span
)
;
return
true
;
}
static
bool
ShouldConvertToDictionary
(
NativeObject
*
obj
)
{
if
(
obj
-
>
hadElementsAccess
(
)
)
{
return
obj
-
>
lastProperty
(
)
-
>
entryCount
(
)
>
=
PropertyTree
:
:
MAX_HEIGHT_WITH_ELEMENTS_ACCESS
;
}
return
obj
-
>
lastProperty
(
)
-
>
entryCount
(
)
>
=
PropertyTree
:
:
MAX_HEIGHT
;
}
namespace
js
{
class
MOZ_RAII
AutoCheckShapeConsistency
{
#
ifdef
DEBUG
HandleNativeObject
obj_
;
#
endif
public
:
explicit
AutoCheckShapeConsistency
(
HandleNativeObject
obj
)
#
ifdef
DEBUG
:
obj_
(
obj
)
#
endif
{
}
#
ifdef
DEBUG
~
AutoCheckShapeConsistency
(
)
{
obj_
-
>
checkShapeConsistency
(
)
;
}
#
endif
}
;
}
MOZ_ALWAYS_INLINE
bool
NativeObject
:
:
maybeConvertToDictionaryForAdd
(
JSContext
*
cx
HandleNativeObject
obj
)
{
if
(
obj
-
>
inDictionaryMode
(
)
)
{
return
true
;
}
if
(
!
ShouldConvertToDictionary
(
obj
)
)
{
return
true
;
}
return
toDictionaryMode
(
cx
obj
)
;
}
static
void
AssertValidCustomDataProp
(
NativeObject
*
obj
PropertyFlags
flags
)
{
MOZ_ASSERT
(
flags
.
isCustomDataProperty
(
)
)
;
MOZ_ASSERT
(
!
flags
.
isAccessorProperty
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
ArrayObject
>
(
)
|
|
obj
-
>
is
<
ArgumentsObject
>
(
)
)
;
}
bool
NativeObject
:
:
addCustomDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
PropertyFlags
flags
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
MOZ_ASSERT
(
!
id
.
isPrivateName
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidCustomDataProp
(
obj
flags
)
;
if
(
!
maybeConvertToDictionaryForAdd
(
cx
obj
)
)
{
return
false
;
}
RootedShape
shape
(
cx
)
;
{
RootedShape
last
(
cx
obj
-
>
lastProperty
(
)
)
;
ObjectFlags
objectFlags
=
GetObjectFlagsForNewProperty
(
last
id
flags
cx
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
last
-
>
base
(
)
objectFlags
id
SHAPE_INVALID_SLOT
flags
)
)
;
shape
=
getChildCustomDataProperty
(
cx
obj
last
&
child
)
;
if
(
!
shape
)
{
return
false
;
}
}
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
return
true
;
}
bool
NativeObject
:
:
addProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
uint32_t
slot
PropertyFlags
flags
uint32_t
*
slotOut
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
"
Use
addCustomDataProperty
for
custom
data
properties
"
)
;
MOZ_ASSERT
(
slot
=
=
SHAPE_INVALID_SLOT
|
|
slot
<
JSCLASS_RESERVED_SLOTS
(
obj
-
>
getClass
(
)
)
)
;
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
MOZ_ASSERT_IF
(
!
id
.
isPrivateName
(
)
obj
-
>
isExtensible
(
)
|
|
(
JSID_IS_INT
(
id
)
&
&
obj
-
>
containsDenseElement
(
JSID_TO_INT
(
id
)
)
)
)
;
if
(
!
maybeConvertToDictionaryForAdd
(
cx
obj
)
)
{
return
false
;
}
RootedShape
last
(
cx
obj
-
>
lastProperty
(
)
)
;
ObjectFlags
objectFlags
=
GetObjectFlagsForNewProperty
(
last
id
flags
cx
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
last
-
>
base
(
)
objectFlags
id
slot
flags
)
)
;
Shape
*
shape
=
getChildProperty
(
cx
obj
last
&
child
)
;
if
(
!
shape
)
{
return
false
;
}
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
*
slotOut
=
shape
-
>
slot
(
)
;
return
true
;
}
static
MOZ_ALWAYS_INLINE
Shape
*
PropertyTreeReadBarrier
(
JSContext
*
cx
Shape
*
parent
Shape
*
shape
)
{
JS
:
:
Zone
*
zone
=
shape
-
>
zone
(
)
;
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
ReadBarrier
(
shape
)
;
return
shape
;
}
if
(
MOZ_LIKELY
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
|
|
!
IsAboutToBeFinalizedUnbarriered
(
&
shape
)
)
)
{
if
(
shape
-
>
isMarkedGray
(
)
)
{
UnmarkGrayShapeRecursively
(
shape
)
;
}
return
shape
;
}
MOZ_ASSERT
(
parent
-
>
isMarkedAny
(
)
)
;
parent
-
>
removeChild
(
cx
-
>
defaultFreeOp
(
)
shape
)
;
return
nullptr
;
}
bool
NativeObject
:
:
addEnumerableDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
uint32_t
*
slotOut
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
constexpr
PropertyFlags
flags
=
PropertyFlags
:
:
defaultDataPropFlags
;
ObjectFlags
objectFlags
=
GetObjectFlagsForNewProperty
(
obj
-
>
lastProperty
(
)
id
flags
cx
)
;
do
{
AutoCheckCannotGC
nogc
;
Shape
*
lastProperty
=
obj
-
>
lastProperty
(
)
;
if
(
lastProperty
-
>
inDictionary
(
)
)
{
break
;
}
ShapeChildren
*
childp
=
&
lastProperty
-
>
children
;
if
(
!
childp
-
>
isSingleShape
(
)
)
{
break
;
}
Shape
*
child
=
childp
-
>
toSingleShape
(
)
;
MOZ_ASSERT
(
!
child
-
>
inDictionary
(
)
)
;
if
(
child
-
>
propidRaw
(
)
!
=
id
|
|
child
-
>
objectFlags
(
)
!
=
objectFlags
|
|
child
-
>
propFlags
!
=
flags
|
|
child
-
>
base
(
)
!
=
lastProperty
-
>
base
(
)
)
{
break
;
}
MOZ_ASSERT
(
child
-
>
property
(
)
.
isDataProperty
(
)
)
;
child
=
PropertyTreeReadBarrier
(
cx
lastProperty
child
)
;
if
(
!
child
)
{
break
;
}
*
slotOut
=
child
-
>
slot
(
)
;
return
obj
-
>
setLastPropertyForNewDataProperty
(
cx
child
)
;
}
while
(
0
)
;
if
(
!
maybeConvertToDictionaryForAdd
(
cx
obj
)
)
{
return
false
;
}
Shape
*
shape
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
AutoKeepShapeCaches
keep
(
cx
)
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
keep
)
;
if
(
!
table
)
{
return
false
;
}
uint32_t
slot
;
if
(
!
allocDictionarySlot
(
cx
obj
&
slot
)
)
{
return
false
;
}
Rooted
<
StackShape
>
child
(
cx
StackShape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
objectFlags
id
slot
flags
)
)
;
shape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
{
return
false
;
}
MOZ_ASSERT
(
slot
<
obj
-
>
slotSpan
(
)
)
;
shape
-
>
initDictionaryShapeAtEnd
(
child
obj
)
;
if
(
!
table
-
>
add
(
cx
id
shape
)
)
{
shape
-
>
removeFromDictionary
(
obj
)
;
return
false
;
}
MOZ_ASSERT
(
shape
-
>
previous
(
)
-
>
maybeTable
(
keep
)
=
=
table
)
;
shape
-
>
previous
(
)
-
>
handoffTableTo
(
shape
)
;
}
else
{
uint32_t
slot
=
obj
-
>
slotSpan
(
)
;
MOZ_ASSERT
(
slot
>
=
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
)
;
MOZ_ASSERT
(
slot
<
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
+
PropertyTree
:
:
MAX_HEIGHT
)
;
MOZ_ASSERT
(
slot
<
SHAPE_MAXIMUM_SLOT
)
;
Shape
*
last
=
obj
-
>
lastProperty
(
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
last
-
>
base
(
)
objectFlags
id
slot
flags
)
)
;
shape
=
cx
-
>
zone
(
)
-
>
propertyTree
(
)
.
inlinedGetChild
(
cx
last
child
)
;
if
(
!
shape
)
{
return
false
;
}
if
(
!
obj
-
>
setLastPropertyForNewDataProperty
(
cx
shape
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
*
slotOut
=
shape
-
>
slot
(
)
;
return
true
;
}
static
void
AssertCanChangeFlags
(
Shape
*
shape
PropertyFlags
flags
)
{
#
ifdef
DEBUG
ShapeProperty
prop
=
shape
-
>
property
(
)
;
if
(
prop
.
configurable
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
flags
.
configurable
(
)
)
;
MOZ_ASSERT_IF
(
prop
.
isDataProperty
(
)
flags
.
isDataProperty
(
)
)
;
MOZ_ASSERT_IF
(
prop
.
isAccessorProperty
(
)
flags
.
isAccessorProperty
(
)
)
;
#
endif
}
static
void
AssertValidArrayIndex
(
NativeObject
*
obj
jsid
id
)
{
#
ifdef
DEBUG
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
ArrayObject
*
arr
=
&
obj
-
>
as
<
ArrayObject
>
(
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
MOZ_ASSERT
(
index
<
arr
-
>
length
(
)
|
|
arr
-
>
lengthIsWritable
(
)
)
;
}
}
#
endif
}
bool
NativeObject
:
:
maybeToDictionaryModeForChange
(
JSContext
*
cx
HandleNativeObject
obj
MutableHandleShape
shape
)
{
if
(
shape
=
=
obj
-
>
lastProperty
(
)
|
|
obj
-
>
inDictionaryMode
(
)
)
{
return
true
;
}
if
(
!
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
AutoCheckCannotGC
nogc
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
nogc
)
;
MOZ_ASSERT
(
table
)
;
shape
.
set
(
*
table
-
>
search
(
shape
-
>
propid
(
)
nogc
)
)
;
return
true
;
}
bool
NativeObject
:
:
changeProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
PropertyFlags
flags
uint32_t
*
slotOut
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidArrayIndex
(
obj
id
)
;
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
"
Use
changeCustomDataPropAttributes
for
custom
data
properties
"
)
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
-
>
search
(
cx
id
)
)
;
MOZ_ASSERT
(
shape
)
;
AssertCanChangeFlags
(
shape
flags
)
;
uint32_t
slot
=
shape
-
>
hasSlot
(
)
?
shape
-
>
slot
(
)
:
SHAPE_INVALID_SLOT
;
ObjectFlags
objectFlags
=
GetObjectFlagsForNewProperty
(
obj
-
>
lastProperty
(
)
id
flags
cx
)
;
if
(
shape
-
>
property
(
)
.
isAccessorProperty
(
)
)
{
objectFlags
.
setFlag
(
ObjectFlag
:
:
HadGetterSetterChange
)
;
}
if
(
shape
-
>
matchesPropertyParamsAfterId
(
slot
flags
)
&
&
obj
-
>
lastProperty
(
)
-
>
objectFlags
(
)
=
=
objectFlags
)
{
MOZ_ASSERT
(
slot
!
=
SHAPE_INVALID_SLOT
)
;
*
slotOut
=
slot
;
return
true
;
}
if
(
!
maybeToDictionaryModeForChange
(
cx
obj
&
shape
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
shape
-
>
hasSlot
(
)
shape
-
>
slot
(
)
=
=
slot
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
bool
updateLast
=
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
if
(
!
NativeObject
:
:
generateOwnShape
(
cx
obj
)
)
{
return
false
;
}
if
(
updateLast
)
{
shape
=
obj
-
>
lastProperty
(
)
;
}
if
(
slot
=
=
SHAPE_INVALID_SLOT
)
{
if
(
!
allocDictionarySlot
(
cx
obj
&
slot
)
)
{
return
false
;
}
}
obj
-
>
lastProperty
(
)
-
>
setObjectFlags
(
objectFlags
)
;
MOZ_ASSERT
(
shape
-
>
inDictionary
(
)
)
;
shape
-
>
setSlot
(
slot
)
;
shape
-
>
propFlags
=
flags
;
}
else
{
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
objectFlags
id
slot
flags
)
)
;
RootedShape
parent
(
cx
shape
-
>
parent
)
;
shape
=
getChildProperty
(
cx
obj
parent
&
child
)
;
if
(
!
shape
)
{
return
false
;
}
}
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
-
>
objectFlags
(
)
=
=
objectFlags
)
;
*
slotOut
=
shape
-
>
slot
(
)
;
return
true
;
}
bool
NativeObject
:
:
changeCustomDataPropAttributes
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
PropertyFlags
flags
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
id
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidArrayIndex
(
obj
id
)
;
AssertValidCustomDataProp
(
obj
flags
)
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
-
>
search
(
cx
id
)
)
;
MOZ_ASSERT
(
shape
)
;
MOZ_ASSERT
(
shape
-
>
isCustomDataProperty
(
)
)
;
AssertCanChangeFlags
(
shape
flags
)
;
ObjectFlags
objectFlags
=
GetObjectFlagsForNewProperty
(
obj
-
>
lastProperty
(
)
id
flags
cx
)
;
if
(
shape
-
>
matchesPropertyParamsAfterId
(
SHAPE_INVALID_SLOT
flags
)
&
&
obj
-
>
lastProperty
(
)
-
>
objectFlags
(
)
=
=
objectFlags
)
{
return
true
;
}
if
(
!
maybeToDictionaryModeForChange
(
cx
obj
&
shape
)
)
{
return
false
;
}
if
(
obj
-
>
inDictionaryMode
(
)
)
{
bool
updateLast
=
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
if
(
!
NativeObject
:
:
generateOwnShape
(
cx
obj
)
)
{
return
false
;
}
if
(
updateLast
)
{
shape
=
obj
-
>
lastProperty
(
)
;
}
obj
-
>
lastProperty
(
)
-
>
setObjectFlags
(
objectFlags
)
;
MOZ_ASSERT
(
shape
-
>
inDictionary
(
)
)
;
shape
-
>
setSlot
(
SHAPE_INVALID_SLOT
)
;
shape
-
>
propFlags
=
flags
;
}
else
{
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
objectFlags
id
SHAPE_INVALID_SLOT
flags
)
)
;
RootedShape
parent
(
cx
shape
-
>
parent
)
;
shape
=
getChildCustomDataProperty
(
cx
obj
parent
&
child
)
;
if
(
!
shape
)
{
return
false
;
}
}
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
-
>
objectFlags
(
)
=
=
objectFlags
)
;
MOZ_ASSERT
(
shape
-
>
isCustomDataProperty
(
)
)
;
return
true
;
}
void
NativeObject
:
:
removeDictionaryPropertyWithoutReshape
(
ShapeTable
*
table
ShapeTable
:
:
Ptr
ptr
Shape
*
shape
)
{
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
lastProperty
(
)
-
>
maybeTable
(
nogc
)
=
=
table
)
;
MOZ_ASSERT
(
*
ptr
=
=
shape
)
;
if
(
shape
-
>
hasSlot
(
)
)
{
freeDictionarySlot
(
table
shape
-
>
slot
(
)
)
;
}
bool
removingLastProperty
=
(
shape
=
=
lastProperty
(
)
)
;
shape
-
>
removeFromDictionary
(
this
)
;
table
-
>
remove
(
ptr
)
;
if
(
removingLastProperty
)
{
MOZ_ASSERT
(
lastProperty
(
)
!
=
shape
)
;
shape
-
>
handoffTableTo
(
lastProperty
(
)
)
;
lastProperty
(
)
-
>
setBase
(
shape
-
>
base
(
)
)
;
lastProperty
(
)
-
>
setObjectFlags
(
shape
-
>
objectFlags
(
)
)
;
}
}
bool
NativeObject
:
:
removeProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
AutoKeepShapeCaches
keep
(
cx
)
;
ShapeTable
*
table
;
ShapeTable
:
:
Ptr
ptr
;
RootedShape
shape
(
cx
)
;
if
(
!
Shape
:
:
search
(
cx
obj
-
>
lastProperty
(
)
id
keep
shape
.
address
(
)
&
table
&
ptr
)
)
{
return
false
;
}
if
(
!
shape
)
{
return
true
;
}
if
(
shape
-
>
property
(
)
.
isAccessorProperty
(
)
&
&
!
obj
-
>
hadGetterSetterChange
(
)
)
{
if
(
!
NativeObject
:
:
setHadGetterSetterChange
(
cx
obj
)
)
{
return
false
;
}
if
(
!
Shape
:
:
search
(
cx
obj
-
>
lastProperty
(
)
id
keep
shape
.
address
(
)
&
table
&
ptr
)
)
{
return
false
;
}
}
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
if
(
shape
=
=
obj
-
>
lastProperty
(
)
&
&
obj
-
>
canRemoveLastProperty
(
)
)
{
if
(
shape
-
>
hasSlot
(
)
)
{
obj
-
>
setSlot
(
shape
-
>
slot
(
)
UndefinedValue
(
)
)
;
}
obj
-
>
removeLastProperty
(
cx
)
;
return
true
;
}
if
(
!
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
keep
)
;
MOZ_ASSERT
(
table
)
;
ptr
=
table
-
>
search
(
shape
-
>
propid
(
)
keep
)
;
shape
=
*
ptr
;
}
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
Shape
*
spare
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
spare
)
{
return
false
;
}
new
(
spare
)
Shape
(
shape
-
>
base
(
)
ObjectFlags
(
)
0
)
;
obj
-
>
removeDictionaryPropertyWithoutReshape
(
table
ptr
shape
)
;
MOZ_ALWAYS_TRUE
(
NativeObject
:
:
generateOwnShape
(
cx
obj
spare
)
)
;
return
true
;
}
bool
NativeObject
:
:
densifySparseElements
(
JSContext
*
cx
HandleNativeObject
obj
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
Shape
*
spare
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
spare
)
{
return
false
;
}
new
(
spare
)
Shape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
ObjectFlags
(
)
0
)
;
{
AutoCheckCannotGC
nogc
;
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
nogc
)
;
if
(
!
table
)
{
return
false
;
}
Shape
*
shape
=
obj
-
>
lastProperty
(
)
;
while
(
!
shape
-
>
isEmptyShape
(
)
)
{
jsid
id
=
shape
-
>
propid
(
)
;
uint32_t
index
;
if
(
!
IdIsIndex
(
id
&
index
)
)
{
shape
=
shape
-
>
previous
(
)
;
continue
;
}
Value
value
=
obj
-
>
getSlot
(
shape
-
>
slot
(
)
)
;
obj
-
>
setDenseElement
(
index
value
)
;
Shape
*
previous
=
shape
-
>
previous
(
)
;
ShapeTable
:
:
Ptr
ptr
=
table
-
>
search
(
id
nogc
)
;
obj
-
>
removeDictionaryPropertyWithoutReshape
(
table
ptr
shape
)
;
shape
=
previous
;
}
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
nogc
)
=
=
table
)
;
}
MOZ_ALWAYS_TRUE
(
NativeObject
:
:
generateOwnShape
(
cx
obj
spare
)
)
;
return
true
;
}
bool
NativeObject
:
:
generateOwnShape
(
JSContext
*
cx
HandleNativeObject
obj
Shape
*
newShape
)
{
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
RootedShape
newRoot
(
cx
newShape
)
;
if
(
!
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
newShape
=
newRoot
;
}
if
(
!
newShape
)
{
newShape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
newShape
)
{
return
false
;
}
new
(
newShape
)
Shape
(
obj
-
>
lastProperty
(
)
-
>
base
(
)
ObjectFlags
(
)
0
)
;
}
Shape
*
oldShape
=
obj
-
>
lastProperty
(
)
;
AutoCheckCannotGC
nogc
;
ShapeTable
*
table
=
oldShape
-
>
ensureTableForDictionary
(
cx
nogc
)
;
if
(
!
table
)
{
return
false
;
}
StackShape
nshape
(
oldShape
)
;
newShape
-
>
initDictionaryShapeAtEnd
(
nshape
obj
)
;
MOZ_ASSERT
(
newShape
-
>
parent
=
=
oldShape
)
;
oldShape
-
>
removeFromDictionary
(
obj
)
;
MOZ_ASSERT
(
newShape
=
=
obj
-
>
lastProperty
(
)
)
;
oldShape
-
>
handoffTableTo
(
newShape
)
;
if
(
!
newShape
-
>
isEmptyShape
(
)
)
{
ShapeTable
:
:
Ptr
ptr
=
table
-
>
search
(
oldShape
-
>
propidRef
(
)
nogc
)
;
MOZ_ASSERT
(
*
ptr
=
=
oldShape
)
;
table
-
>
replaceShape
(
ptr
newShape
-
>
propidRaw
(
)
newShape
)
;
}
return
true
;
}
bool
JSObject
:
:
setFlag
(
JSContext
*
cx
HandleObject
obj
ObjectFlag
flag
GenerateShape
generateShape
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
if
(
obj
-
>
hasFlag
(
flag
)
)
{
return
true
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
&
&
obj
-
>
as
<
NativeObject
>
(
)
.
inDictionaryMode
(
)
)
{
if
(
generateShape
=
=
GENERATE_SHAPE
)
{
if
(
!
NativeObject
:
:
generateOwnShape
(
cx
obj
.
as
<
NativeObject
>
(
)
)
)
{
return
false
;
}
}
Shape
*
last
=
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
;
ObjectFlags
flags
=
last
-
>
objectFlags
(
)
;
flags
.
setFlag
(
flag
)
;
last
-
>
setObjectFlags
(
flags
)
;
return
true
;
}
Shape
*
newShape
=
Shape
:
:
setObjectFlag
(
cx
flag
obj
-
>
shape
(
)
)
;
if
(
!
newShape
)
{
return
false
;
}
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
bool
JSObject
:
:
setProtoUnchecked
(
JSContext
*
cx
HandleObject
obj
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
;
if
(
obj
-
>
shape
(
)
-
>
proto
(
)
=
=
proto
)
{
return
true
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
&
&
obj
-
>
as
<
NativeObject
>
(
)
.
inDictionaryMode
(
)
)
{
HandleNativeObject
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
nobj
-
>
getClass
(
)
nobj
-
>
realm
(
)
proto
)
)
;
if
(
!
nbase
)
{
return
false
;
}
if
(
!
NativeObject
:
:
generateOwnShape
(
cx
nobj
)
)
{
return
false
;
}
nobj
-
>
shape
(
)
-
>
setBase
(
nbase
)
;
return
true
;
}
Shape
*
newShape
=
Shape
:
:
setProto
(
cx
proto
obj
-
>
shape
(
)
)
;
if
(
!
newShape
)
{
return
false
;
}
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
bool
NativeObject
:
:
clearFlag
(
JSContext
*
cx
HandleNativeObject
obj
ObjectFlag
flag
)
{
MOZ_ASSERT
(
obj
-
>
lastProperty
(
)
-
>
hasObjectFlag
(
flag
)
)
;
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
}
Shape
*
last
=
obj
-
>
lastProperty
(
)
;
ObjectFlags
flags
=
last
-
>
objectFlags
(
)
;
flags
.
clearFlag
(
flag
)
;
last
-
>
setObjectFlags
(
flags
)
;
return
true
;
}
Shape
*
Shape
:
:
setObjectFlag
(
JSContext
*
cx
ObjectFlag
flag
Shape
*
last
)
{
MOZ_ASSERT
(
!
last
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
!
last
-
>
hasObjectFlag
(
flag
)
)
;
ObjectFlags
objectFlags
=
last
-
>
objectFlags
(
)
;
objectFlags
.
setFlag
(
flag
)
;
RootedShape
lastRoot
(
cx
last
)
;
return
replaceLastProperty
(
cx
objectFlags
last
-
>
proto
(
)
lastRoot
)
;
}
Shape
*
Shape
:
:
setProto
(
JSContext
*
cx
TaggedProto
proto
Shape
*
last
)
{
MOZ_ASSERT
(
!
last
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
last
-
>
proto
(
)
!
=
proto
)
;
RootedShape
lastRoot
(
cx
last
)
;
return
replaceLastProperty
(
cx
last
-
>
objectFlags
(
)
proto
lastRoot
)
;
}
BaseShape
:
:
BaseShape
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
)
:
TenuredCellWithNonGCPointer
(
clasp
)
realm_
(
realm
)
proto_
(
proto
)
{
MOZ_ASSERT
(
JS
:
:
StringIsASCII
(
clasp
-
>
name
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
compartment
(
)
=
=
proto
.
toObject
(
)
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
#
ifdef
DEBUG
if
(
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
)
{
AssertTargetIsNotGray
(
global
)
;
}
#
endif
}
BaseShape
*
BaseShape
:
:
get
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
Handle
<
TaggedProto
>
proto
)
{
auto
&
table
=
cx
-
>
zone
(
)
-
>
baseShapes
(
)
;
using
Lookup
=
BaseShapeHasher
:
:
Lookup
;
auto
p
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
)
)
;
if
(
p
)
{
return
*
p
;
}
BaseShape
*
nbase
=
Allocate
<
BaseShape
>
(
cx
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
new
(
nbase
)
BaseShape
(
clasp
realm
proto
)
;
if
(
!
p
.
add
(
cx
table
Lookup
(
clasp
realm
proto
)
nbase
)
)
{
return
nullptr
;
}
return
nbase
;
}
#
ifdef
DEBUG
bool
Shape
:
:
canSkipMarkingShapeCache
(
)
{
AutoCheckCannotGC
nogc
;
ShapeCachePtr
cache
=
getCache
(
nogc
)
;
if
(
!
cache
.
isTable
(
)
)
{
return
true
;
}
uint32_t
count
=
0
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
this
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
Shape
*
shape
=
&
r
.
front
(
)
;
ShapeTable
:
:
Ptr
p
=
cache
.
getTablePointer
(
)
-
>
search
(
shape
-
>
propid
(
)
nogc
)
;
MOZ_ASSERT
(
*
p
=
=
shape
)
;
count
+
+
;
}
return
count
=
=
cache
.
getTablePointer
(
)
-
>
entryCount
(
)
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkBaseShapeTableAfterMovingGC
(
)
{
for
(
auto
r
=
baseShapes
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseShape
*
base
=
r
.
front
(
)
.
unbarrieredGet
(
)
;
CheckGCThingAfterMovingGC
(
base
)
;
BaseShapeHasher
:
:
Lookup
lookup
(
base
-
>
clasp
(
)
base
-
>
realm
(
)
base
-
>
proto
(
)
)
;
BaseShapeSet
:
:
Ptr
ptr
=
baseShapes
(
)
.
lookup
(
lookup
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
inline
InitialShapeEntry
:
:
InitialShapeEntry
(
)
:
shape
(
nullptr
)
{
}
inline
InitialShapeEntry
:
:
InitialShapeEntry
(
Shape
*
shape
)
:
shape
(
shape
)
{
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkInitialShapesTableAfterMovingGC
(
)
{
for
(
auto
r
=
initialShapes
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
InitialShapeEntry
entry
=
r
.
front
(
)
;
Shape
*
shape
=
entry
.
shape
.
unbarrieredGet
(
)
;
CheckGCThingAfterMovingGC
(
shape
)
;
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
shape
-
>
proto
(
)
shape
-
>
numFixedSlots
(
)
shape
-
>
objectFlags
(
)
)
;
InitialShapeSet
:
:
Ptr
ptr
=
initialShapes
(
)
.
lookup
(
lookup
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
Shape
*
EmptyShape
:
:
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
uint32_t
nfixed
)
{
Shape
*
shape
=
Allocate
<
Shape
>
(
cx
)
;
if
(
!
shape
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
new
(
shape
)
EmptyShape
(
base
objectFlags
nfixed
)
;
return
shape
;
}
MOZ_ALWAYS_INLINE
HashNumber
ShapeHasher
:
:
hash
(
const
Lookup
&
l
)
{
return
l
.
hash
(
)
;
}
MOZ_ALWAYS_INLINE
bool
ShapeHasher
:
:
match
(
const
Key
k
const
Lookup
&
l
)
{
return
k
-
>
matches
(
l
)
;
}
static
ShapeSet
*
MakeShapeSet
(
Shape
*
child1
Shape
*
child2
)
{
auto
hash
=
MakeUnique
<
ShapeSet
>
(
)
;
if
(
!
hash
|
|
!
hash
-
>
reserve
(
2
)
)
{
return
nullptr
;
}
hash
-
>
putNewInfallible
(
StackShape
(
child1
)
child1
)
;
hash
-
>
putNewInfallible
(
StackShape
(
child2
)
child2
)
;
return
hash
.
release
(
)
;
}
bool
PropertyTree
:
:
insertChild
(
JSContext
*
cx
Shape
*
parent
Shape
*
child
)
{
MOZ_ASSERT
(
!
parent
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
!
child
-
>
parent
)
;
MOZ_ASSERT
(
!
child
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
child
-
>
zone
(
)
=
=
parent
-
>
zone
(
)
)
;
MOZ_ASSERT
(
cx
-
>
zone
(
)
=
=
zone_
)
;
ShapeChildren
*
childp
=
&
parent
-
>
children
;
if
(
childp
-
>
isNone
(
)
)
{
child
-
>
setParent
(
parent
)
;
childp
-
>
setSingleShape
(
child
)
;
return
true
;
}
if
(
childp
-
>
isSingleShape
(
)
)
{
Shape
*
shape
=
childp
-
>
toSingleShape
(
)
;
MOZ_ASSERT
(
shape
!
=
child
)
;
MOZ_ASSERT
(
!
shape
-
>
matches
(
child
)
)
;
ShapeSet
*
hash
=
MakeShapeSet
(
shape
child
)
;
if
(
!
hash
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
childp
-
>
setShapeSet
(
hash
)
;
AddCellMemory
(
parent
sizeof
(
ShapeSet
)
MemoryUse
:
:
ShapeChildren
)
;
child
-
>
setParent
(
parent
)
;
return
true
;
}
if
(
!
childp
-
>
toShapeSet
(
)
-
>
putNew
(
StackShape
(
child
)
child
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
child
-
>
setParent
(
parent
)
;
return
true
;
}
void
Shape
:
:
removeChild
(
JSFreeOp
*
fop
Shape
*
child
)
{
MOZ_ASSERT
(
!
child
-
>
inDictionary
(
)
)
;
MOZ_ASSERT
(
child
-
>
parent
=
=
this
)
;
ShapeChildren
*
childp
=
&
children
;
if
(
childp
-
>
isSingleShape
(
)
)
{
MOZ_ASSERT
(
childp
-
>
toSingleShape
(
)
=
=
child
)
;
childp
-
>
setNone
(
)
;
child
-
>
parent
=
nullptr
;
return
;
}
ShapeSet
*
set
=
childp
-
>
toShapeSet
(
)
;
MOZ_ASSERT
(
set
-
>
count
(
)
>
=
2
)
;
#
ifdef
DEBUG
size_t
oldCount
=
set
-
>
count
(
)
;
#
endif
set
-
>
remove
(
StackShape
(
child
)
)
;
child
-
>
parent
=
nullptr
;
MOZ_ASSERT
(
set
-
>
count
(
)
=
=
oldCount
-
1
)
;
if
(
set
-
>
count
(
)
=
=
1
)
{
ShapeSet
:
:
Range
r
=
set
-
>
all
(
)
;
Shape
*
otherChild
=
r
.
front
(
)
;
MOZ_ASSERT
(
(
r
.
popFront
(
)
r
.
empty
(
)
)
)
;
childp
-
>
setSingleShape
(
otherChild
)
;
fop
-
>
delete_
(
this
set
MemoryUse
:
:
ShapeChildren
)
;
}
}
MOZ_ALWAYS_INLINE
Shape
*
PropertyTree
:
:
inlinedGetChild
(
JSContext
*
cx
Shape
*
parent
Handle
<
StackShape
>
childSpec
)
{
MOZ_ASSERT
(
parent
)
;
Shape
*
existingShape
=
nullptr
;
ShapeChildren
*
childp
=
&
parent
-
>
children
;
if
(
childp
-
>
isSingleShape
(
)
)
{
Shape
*
child
=
childp
-
>
toSingleShape
(
)
;
if
(
child
-
>
matches
(
childSpec
)
)
{
existingShape
=
child
;
}
}
else
if
(
childp
-
>
isShapeSet
(
)
)
{
if
(
ShapeSet
:
:
Ptr
p
=
childp
-
>
toShapeSet
(
)
-
>
lookup
(
childSpec
)
)
{
existingShape
=
*
p
;
}
}
else
{
}
if
(
existingShape
)
{
existingShape
=
PropertyTreeReadBarrier
(
cx
parent
existingShape
)
;
if
(
existingShape
)
{
return
existingShape
;
}
}
RootedShape
parentRoot
(
cx
parent
)
;
Shape
*
shape
=
Shape
:
:
new_
(
cx
childSpec
parentRoot
-
>
numFixedSlots
(
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
if
(
!
insertChild
(
cx
parentRoot
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
Shape
*
PropertyTree
:
:
getChild
(
JSContext
*
cx
Shape
*
parent
Handle
<
StackShape
>
child
)
{
return
inlinedGetChild
(
cx
parent
child
)
;
}
void
Shape
:
:
sweep
(
JSFreeOp
*
fop
)
{
MOZ_ASSERT
(
zone
(
)
-
>
isGCSweeping
(
)
)
;
MOZ_ASSERT_IF
(
parent
parent
-
>
zone
(
)
=
=
zone
(
)
)
;
if
(
parent
&
&
parent
-
>
isMarkedAny
(
)
)
{
if
(
inDictionary
(
)
)
{
if
(
parent
-
>
dictNext
=
=
DictionaryShapeLink
(
this
)
)
{
parent
-
>
dictNext
.
setNone
(
)
;
}
}
else
{
parent
-
>
removeChild
(
fop
this
)
;
}
}
}
void
Shape
:
:
finalize
(
JSFreeOp
*
fop
)
{
if
(
!
inDictionary
(
)
&
&
children
.
isShapeSet
(
)
)
{
fop
-
>
delete_
(
this
children
.
toShapeSet
(
)
MemoryUse
:
:
ShapeChildren
)
;
}
if
(
cache_
.
isInitialized
(
)
)
{
cache_
.
destroy
(
fop
this
)
;
}
}
void
Shape
:
:
fixupDictionaryShapeAfterMovingGC
(
)
{
if
(
dictNext
.
isShape
(
)
)
{
Shape
*
shape
=
dictNext
.
toShape
(
)
;
if
(
gc
:
:
IsForwarded
(
shape
)
)
{
dictNext
.
setShape
(
gc
:
:
Forwarded
(
shape
)
)
;
}
}
else
{
MOZ_ASSERT
(
dictNext
.
isNone
(
)
)
;
}
}
void
Shape
:
:
fixupShapeTreeAfterMovingGC
(
)
{
if
(
children
.
isNone
(
)
)
{
return
;
}
if
(
children
.
isSingleShape
(
)
)
{
if
(
gc
:
:
IsForwarded
(
children
.
toSingleShape
(
)
)
)
{
children
.
setSingleShape
(
gc
:
:
Forwarded
(
children
.
toSingleShape
(
)
)
)
;
}
return
;
}
MOZ_ASSERT
(
children
.
isShapeSet
(
)
)
;
ShapeSet
*
set
=
children
.
toShapeSet
(
)
;
for
(
ShapeSet
:
:
Enum
e
(
*
set
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Shape
*
key
=
MaybeForwarded
(
e
.
front
(
)
)
;
BaseShape
*
base
=
MaybeForwarded
(
key
-
>
base
(
)
)
;
StackShape
lookup
(
base
key
-
>
objectFlags
(
)
key
-
>
propidRef
(
)
key
-
>
immutableFlags
&
Shape
:
:
SLOT_MASK
key
-
>
propFlags
)
;
e
.
rekeyFront
(
lookup
key
)
;
}
}
void
Shape
:
:
fixupAfterMovingGC
(
)
{
if
(
inDictionary
(
)
)
{
fixupDictionaryShapeAfterMovingGC
(
)
;
}
else
{
fixupShapeTreeAfterMovingGC
(
)
;
}
}
#
ifdef
DEBUG
void
ShapeChildren
:
:
checkHasChild
(
Shape
*
child
)
const
{
if
(
isSingleShape
(
)
)
{
MOZ_ASSERT
(
toSingleShape
(
)
=
=
child
)
;
}
else
{
MOZ_ASSERT
(
isShapeSet
(
)
)
;
ShapeSet
*
set
=
toShapeSet
(
)
;
ShapeSet
:
:
Ptr
ptr
=
set
-
>
lookup
(
StackShape
(
child
)
)
;
MOZ_ASSERT
(
*
ptr
=
=
child
)
;
}
}
void
Shape
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
const
{
jsid
propid
=
this
-
>
propid
(
)
;
MOZ_ASSERT
(
!
JSID_IS_VOID
(
propid
)
)
;
if
(
JSID_IS_INT
(
propid
)
)
{
out
.
printf
(
"
[
%
ld
]
"
(
long
)
JSID_TO_INT
(
propid
)
)
;
}
else
if
(
JSID_IS_ATOM
(
propid
)
)
{
if
(
JSLinearString
*
str
=
propid
.
toAtom
(
)
)
{
EscapedStringPrinter
(
out
str
'
"
'
)
;
}
else
{
out
.
put
(
"
<
error
>
"
)
;
}
}
else
{
MOZ_ASSERT
(
JSID_IS_SYMBOL
(
propid
)
)
;
JSID_TO_SYMBOL
(
propid
)
-
>
dump
(
out
)
;
}
out
.
printf
(
"
slot
%
d
propFlags
%
x
"
hasSlot
(
)
?
int32_t
(
slot
(
)
)
:
-
1
propFlags
.
toRaw
(
)
)
;
if
(
!
propFlags
.
isEmpty
(
)
)
{
bool
first
=
true
;
auto
dumpFlag
=
[
&
]
(
PropertyFlag
flag
const
char
*
name
)
{
if
(
!
propFlags
.
hasFlag
(
flag
)
)
{
return
;
}
if
(
!
first
)
{
out
.
putChar
(
'
'
)
;
}
out
.
put
(
name
)
;
first
=
false
;
}
;
out
.
putChar
(
'
(
'
)
;
dumpFlag
(
PropertyFlag
:
:
Enumerable
"
enumerable
"
)
;
dumpFlag
(
PropertyFlag
:
:
Configurable
"
configurable
"
)
;
dumpFlag
(
PropertyFlag
:
:
Writable
"
writable
"
)
;
dumpFlag
(
PropertyFlag
:
:
AccessorProperty
"
accessor
"
)
;
dumpFlag
(
PropertyFlag
:
:
CustomDataProperty
"
custom
-
data
"
)
;
out
.
putChar
(
'
)
'
)
;
}
out
.
printf
(
"
immutableFlags
%
x
"
immutableFlags
)
;
if
(
immutableFlags
)
{
int
first
=
1
;
out
.
putChar
(
'
(
'
)
;
#
define
DUMP_FLAG
(
name
display
)
\
if
(
immutableFlags
&
name
)
out
.
put
(
&
(
"
"
#
display
)
[
first
]
)
first
=
0
DUMP_FLAG
(
IN_DICTIONARY
in_dictionary
)
;
#
undef
DUMP_FLAG
out
.
putChar
(
'
)
'
)
;
}
}
void
Shape
:
:
dump
(
)
const
{
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
void
Shape
:
:
dumpSubtree
(
int
level
js
:
:
GenericPrinter
&
out
)
const
{
if
(
!
parent
)
{
MOZ_ASSERT
(
level
=
=
0
)
;
MOZ_ASSERT
(
JSID_IS_EMPTY
(
propid_
)
)
;
out
.
printf
(
"
class
%
s
emptyShape
\
n
"
getObjectClass
(
)
-
>
name
)
;
}
else
{
out
.
printf
(
"
%
*
sid
"
level
"
"
)
;
dump
(
out
)
;
}
if
(
!
children
.
isNone
(
)
)
{
+
+
level
;
if
(
children
.
isSingleShape
(
)
)
{
Shape
*
child
=
children
.
toSingleShape
(
)
;
MOZ_ASSERT
(
child
-
>
parent
=
=
this
)
;
child
-
>
dumpSubtree
(
level
out
)
;
}
else
{
const
ShapeSet
&
set
=
*
children
.
toShapeSet
(
)
;
for
(
ShapeSet
:
:
Range
range
=
set
.
all
(
)
;
!
range
.
empty
(
)
;
range
.
popFront
(
)
)
{
Shape
*
child
=
range
.
front
(
)
;
MOZ_ASSERT
(
child
-
>
parent
=
=
this
)
;
child
-
>
dumpSubtree
(
level
out
)
;
}
}
}
}
#
endif
Shape
*
EmptyShape
:
:
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
size_t
nfixed
ObjectFlags
objectFlags
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
realm
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setIsUsedAsPrototype
(
cx
protoObj
)
)
{
return
nullptr
;
}
uint64_t
unused
;
if
(
!
cx
-
>
zone
(
)
-
>
getOrCreateUniqueId
(
protoObj
&
unused
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
proto
=
TaggedProto
(
protoObj
)
;
}
auto
&
table
=
realm
-
>
zone
(
)
-
>
initialShapes
(
)
;
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
auto
protoPointer
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
nfixed
objectFlags
)
)
;
if
(
protoPointer
)
{
return
protoPointer
-
>
shape
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
clasp
realm
protoRoot
)
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
RootedShape
shape
(
cx
EmptyShape
:
:
new_
(
cx
nbase
objectFlags
nfixed
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
Lookup
lookup
(
clasp
realm
protoRoot
nfixed
objectFlags
)
;
if
(
!
protoPointer
.
add
(
cx
table
lookup
InitialShapeEntry
(
shape
)
)
)
{
return
nullptr
;
}
return
shape
;
}
Shape
*
EmptyShape
:
:
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
gc
:
:
AllocKind
kind
ObjectFlags
objectFlags
)
{
return
getInitialShape
(
cx
clasp
realm
proto
GetGCKindSlots
(
kind
clasp
)
objectFlags
)
;
}
void
NewObjectCache
:
:
invalidateEntriesForShape
(
Shape
*
shape
)
{
const
JSClass
*
clasp
=
shape
-
>
getObjectClass
(
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
shape
-
>
numFixedSlots
(
)
)
;
if
(
CanChangeToBackgroundAllocKind
(
kind
clasp
)
)
{
kind
=
ForegroundToBackgroundAllocKind
(
kind
)
;
}
EntryIndex
entry
;
for
(
RealmsInZoneIter
realm
(
shape
-
>
zone
(
)
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
if
(
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
)
{
if
(
lookupGlobal
(
clasp
global
kind
&
entry
)
)
{
PodZero
(
&
entries
[
entry
]
)
;
}
}
}
JSObject
*
proto
=
shape
-
>
proto
(
)
.
toObject
(
)
;
if
(
!
proto
-
>
is
<
GlobalObject
>
(
)
&
&
lookupProto
(
clasp
proto
kind
&
entry
)
)
{
PodZero
(
&
entries
[
entry
]
)
;
}
}
void
EmptyShape
:
:
insertInitialShape
(
JSContext
*
cx
HandleShape
shape
)
{
using
Lookup
=
InitialShapeEntry
:
:
Lookup
;
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
shape
-
>
proto
(
)
shape
-
>
numFixedSlots
(
)
shape
-
>
objectFlags
(
)
)
;
InitialShapeSet
:
:
Ptr
p
=
cx
-
>
zone
(
)
-
>
initialShapes
(
)
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
)
;
InitialShapeEntry
&
entry
=
const_cast
<
InitialShapeEntry
&
>
(
*
p
)
;
if
(
entry
.
shape
=
=
shape
)
{
return
;
}
#
ifdef
DEBUG
Shape
*
nshape
=
shape
;
while
(
!
nshape
-
>
isEmptyShape
(
)
)
{
nshape
=
nshape
-
>
previous
(
)
;
}
MOZ_ASSERT
(
nshape
=
=
entry
.
shape
)
;
#
endif
entry
.
shape
=
WeakHeapPtrShape
(
shape
)
;
if
(
!
cx
-
>
isHelperThreadContext
(
)
)
{
cx
-
>
caches
(
)
.
newObjectCache
.
invalidateEntriesForShape
(
shape
)
;
}
}
void
Zone
:
:
fixupInitialShapeTable
(
)
{
for
(
InitialShapeSet
:
:
Enum
e
(
initialShapes
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Shape
*
shape
=
e
.
front
(
)
.
shape
.
unbarrieredGet
(
)
;
if
(
IsForwarded
(
shape
)
)
{
shape
=
Forwarded
(
shape
)
;
e
.
mutableFront
(
)
.
shape
.
set
(
shape
)
;
}
shape
-
>
updateBaseShapeAfterMovingGC
(
)
;
}
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
Shape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
get
(
)
.
maybeTable
(
nogc
)
)
{
size
+
=
table
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
if
(
!
get
(
)
.
inDictionary
(
)
&
&
get
(
)
.
children
.
isShapeSet
(
)
)
{
size
+
=
get
(
)
.
children
.
toShapeSet
(
)
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
BaseShape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
