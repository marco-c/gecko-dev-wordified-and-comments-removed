#
include
"
vm
/
Shape
-
inl
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ShapeZone
.
h
"
#
include
"
vm
/
Watchtower
.
h
"
#
include
"
gc
/
Zone
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
CeilingLog2Size
;
using
mozilla
:
:
PodZero
;
using
JS
:
:
AutoCheckCannotGC
;
bool
Shape
:
:
replaceShape
(
JSContext
*
cx
HandleObject
obj
ObjectFlags
objectFlags
TaggedProto
proto
uint32_t
nfixed
)
{
Shape
*
newShape
;
switch
(
obj
-
>
shape
(
)
-
>
kind
(
)
)
{
case
Kind
:
:
Shared
:
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
shape
(
)
-
>
propMap
(
)
)
{
Rooted
<
BaseShape
*
>
base
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
)
;
if
(
proto
!
=
base
-
>
proto
(
)
)
{
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
base
=
BaseShape
:
:
get
(
cx
base
-
>
clasp
(
)
base
-
>
realm
(
)
protoRoot
)
;
if
(
!
base
)
{
return
false
;
}
}
Rooted
<
SharedPropMap
*
>
map
(
cx
nobj
-
>
sharedShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
nobj
-
>
shape
(
)
-
>
propMapLength
(
)
;
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
base
nfixed
map
mapLength
objectFlags
)
;
}
else
{
newShape
=
SharedShape
:
:
getInitialShape
(
cx
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
obj
-
>
shape
(
)
-
>
realm
(
)
proto
nfixed
objectFlags
)
;
}
break
;
}
case
Kind
:
:
Proxy
:
MOZ_ASSERT
(
nfixed
=
=
0
)
;
newShape
=
ProxyShape
:
:
getShape
(
cx
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
obj
-
>
shape
(
)
-
>
realm
(
)
proto
objectFlags
)
;
break
;
case
Kind
:
:
WasmGC
:
MOZ_ASSERT
(
nfixed
=
=
0
)
;
newShape
=
WasmGCShape
:
:
getShape
(
cx
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
obj
-
>
shape
(
)
-
>
realm
(
)
proto
objectFlags
)
;
break
;
case
Kind
:
:
Dictionary
:
MOZ_CRASH
(
"
Unexpected
dictionary
shape
"
)
;
}
if
(
!
newShape
)
{
return
false
;
}
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
bool
js
:
:
NativeObject
:
:
toDictionaryMode
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
cx
-
>
isInsideCurrentCompartment
(
obj
)
)
;
Rooted
<
NativeShape
*
>
shape
(
cx
obj
-
>
shape
(
)
)
;
uint32_t
span
=
obj
-
>
slotSpan
(
)
;
uint32_t
mapLength
=
shape
-
>
propMapLength
(
)
;
MOZ_ASSERT
(
mapLength
>
0
"
shouldn
'
t
convert
empty
object
to
dictionary
"
)
;
Rooted
<
SharedPropMap
*
>
map
(
cx
shape
-
>
propMap
(
)
-
>
asShared
(
)
)
;
Rooted
<
DictionaryPropMap
*
>
dictMap
(
cx
SharedPropMap
:
:
toDictionaryMap
(
cx
map
mapLength
)
)
;
if
(
!
dictMap
)
{
return
false
;
}
Rooted
<
BaseShape
*
>
base
(
cx
shape
-
>
base
(
)
)
;
shape
=
DictionaryShape
:
:
new_
(
cx
base
shape
-
>
objectFlags
(
)
shape
-
>
numFixedSlots
(
)
dictMap
mapLength
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setShape
(
shape
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
obj
-
>
setDictionaryModeSlotSpan
(
span
)
;
return
true
;
}
namespace
js
{
class
MOZ_RAII
AutoCheckShapeConsistency
{
#
ifdef
DEBUG
Handle
<
NativeObject
*
>
obj_
;
#
endif
public
:
explicit
AutoCheckShapeConsistency
(
Handle
<
NativeObject
*
>
obj
)
#
ifdef
DEBUG
:
obj_
(
obj
)
#
endif
{
}
#
ifdef
DEBUG
~
AutoCheckShapeConsistency
(
)
{
obj_
-
>
checkShapeConsistency
(
)
;
}
#
endif
}
;
}
MOZ_ALWAYS_INLINE
bool
NativeObject
:
:
maybeConvertToDictionaryForAdd
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
)
{
if
(
obj
-
>
inDictionaryMode
(
)
)
{
return
true
;
}
SharedPropMap
*
map
=
obj
-
>
sharedShape
(
)
-
>
propMap
(
)
;
if
(
!
map
)
{
return
true
;
}
if
(
MOZ_LIKELY
(
!
map
-
>
shouldConvertToDictionaryForAdd
(
)
)
)
{
return
true
;
}
return
toDictionaryMode
(
cx
obj
)
;
}
static
void
AssertValidCustomDataProp
(
NativeObject
*
obj
PropertyFlags
flags
)
{
MOZ_ASSERT
(
flags
.
isCustomDataProperty
(
)
)
;
MOZ_ASSERT
(
!
flags
.
isAccessorProperty
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
ArrayObject
>
(
)
|
|
obj
-
>
is
<
ArgumentsObject
>
(
)
)
;
}
bool
NativeObject
:
:
addCustomDataProperty
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
PropertyFlags
flags
)
{
MOZ_ASSERT
(
!
id
.
isVoid
(
)
)
;
MOZ_ASSERT
(
!
id
.
isPrivateName
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidCustomDataProp
(
obj
flags
)
;
if
(
!
Watchtower
:
:
watchPropertyAdd
(
cx
obj
id
)
)
{
return
false
;
}
if
(
!
maybeConvertToDictionaryForAdd
(
cx
obj
)
)
{
return
false
;
}
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
Rooted
<
DictionaryPropMap
*
>
map
(
cx
obj
-
>
dictionaryShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
if
(
!
DictionaryPropMap
:
:
addProperty
(
cx
clasp
&
map
&
mapLength
id
flags
SHAPE_INVALID_SLOT
&
objectFlags
)
)
{
return
false
;
}
obj
-
>
dictionaryShape
(
)
-
>
updateNewShape
(
objectFlags
map
mapLength
)
;
return
true
;
}
Rooted
<
SharedPropMap
*
>
map
(
cx
obj
-
>
sharedShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
if
(
!
SharedPropMap
:
:
addCustomDataProperty
(
cx
clasp
&
map
&
mapLength
id
flags
&
objectFlags
)
)
{
return
false
;
}
Shape
*
shape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
map
mapLength
objectFlags
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setShape
(
shape
)
;
return
true
;
}
static
ShapeSetForAdd
*
MakeShapeSetForAdd
(
SharedShape
*
shape1
SharedShape
*
shape2
)
{
MOZ_ASSERT
(
shape1
!
=
shape2
)
;
MOZ_ASSERT
(
shape1
-
>
propMapLength
(
)
=
=
shape2
-
>
propMapLength
(
)
)
;
auto
hash
=
MakeUnique
<
ShapeSetForAdd
>
(
)
;
if
(
!
hash
|
|
!
hash
-
>
reserve
(
2
)
)
{
return
nullptr
;
}
PropertyInfoWithKey
prop
=
shape1
-
>
lastProperty
(
)
;
hash
-
>
putNewInfallible
(
ShapeForAddHasher
:
:
Lookup
(
prop
.
key
(
)
prop
.
flags
(
)
)
shape1
)
;
prop
=
shape2
-
>
lastProperty
(
)
;
hash
-
>
putNewInfallible
(
ShapeForAddHasher
:
:
Lookup
(
prop
.
key
(
)
prop
.
flags
(
)
)
shape2
)
;
return
hash
.
release
(
)
;
}
static
MOZ_ALWAYS_INLINE
SharedShape
*
LookupShapeForAdd
(
Shape
*
shape
PropertyKey
key
PropertyFlags
flags
uint32_t
*
slot
)
{
ShapeCachePtr
cache
=
shape
-
>
cache
(
)
;
if
(
cache
.
isSingleShapeForAdd
(
)
)
{
SharedShape
*
newShape
=
cache
.
toSingleShapeForAdd
(
)
;
if
(
newShape
-
>
lastPropertyMatchesForAdd
(
key
flags
slot
)
)
{
return
newShape
;
}
return
nullptr
;
}
if
(
cache
.
isShapeSetForAdd
(
)
)
{
ShapeSetForAdd
*
set
=
cache
.
toShapeSetForAdd
(
)
;
ShapeForAddHasher
:
:
Lookup
lookup
(
key
flags
)
;
if
(
auto
p
=
set
-
>
lookup
(
lookup
)
)
{
SharedShape
*
newShape
=
*
p
;
*
slot
=
newShape
-
>
lastProperty
(
)
.
slot
(
)
;
return
newShape
;
}
return
nullptr
;
}
MOZ_ASSERT
(
!
cache
.
isForAdd
(
)
)
;
return
nullptr
;
}
static
bool
RegisterShapeCache
(
JSContext
*
cx
Shape
*
shape
)
{
ShapeCachePtr
cache
=
shape
-
>
cache
(
)
;
if
(
!
cache
.
isNone
(
)
)
{
return
true
;
}
return
cx
-
>
zone
(
)
-
>
shapeZone
(
)
.
shapesWithCache
.
append
(
shape
)
;
}
bool
NativeObject
:
:
addProperty
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
PropertyFlags
flags
uint32_t
*
slot
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
"
Use
addCustomDataProperty
for
custom
data
properties
"
)
;
MOZ_ASSERT
(
!
id
.
isVoid
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
MOZ_ASSERT_IF
(
!
id
.
isPrivateName
(
)
obj
-
>
isExtensible
(
)
|
|
(
id
.
isInt
(
)
&
&
obj
-
>
containsDenseElement
(
id
.
toInt
(
)
)
)
|
|
IF_RECORD_TUPLE
(
IsExtendedPrimitiveWrapper
(
*
obj
)
false
)
)
;
if
(
!
Watchtower
:
:
watchPropertyAdd
(
cx
obj
id
)
)
{
return
false
;
}
if
(
!
maybeConvertToDictionaryForAdd
(
cx
obj
)
)
{
return
false
;
}
if
(
auto
*
shape
=
LookupShapeForAdd
(
obj
-
>
shape
(
)
id
flags
slot
)
)
{
return
obj
-
>
setShapeAndAddNewSlot
(
cx
shape
*
slot
)
;
}
if
(
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
if
(
!
allocDictionarySlot
(
cx
obj
slot
)
)
{
return
false
;
}
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
Rooted
<
DictionaryPropMap
*
>
map
(
cx
obj
-
>
shape
(
)
-
>
propMap
(
)
-
>
asDictionary
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
if
(
!
DictionaryPropMap
:
:
addProperty
(
cx
clasp
&
map
&
mapLength
id
flags
*
slot
&
objectFlags
)
)
{
return
false
;
}
obj
-
>
dictionaryShape
(
)
-
>
updateNewShape
(
objectFlags
map
mapLength
)
;
return
true
;
}
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
Rooted
<
SharedPropMap
*
>
map
(
cx
obj
-
>
sharedShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
if
(
!
SharedPropMap
:
:
addProperty
(
cx
clasp
&
map
&
mapLength
id
flags
&
objectFlags
slot
)
)
{
return
false
;
}
bool
allocatedNewShape
;
SharedShape
*
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
map
mapLength
objectFlags
&
allocatedNewShape
)
;
if
(
!
newShape
)
{
return
false
;
}
Shape
*
oldShape
=
obj
-
>
shape
(
)
;
if
(
!
obj
-
>
setShapeAndAddNewSlot
(
cx
newShape
*
slot
)
)
{
return
false
;
}
if
(
allocatedNewShape
)
{
return
true
;
}
if
(
!
RegisterShapeCache
(
cx
oldShape
)
)
{
return
true
;
}
ShapeCachePtr
&
cache
=
oldShape
-
>
cacheRef
(
)
;
if
(
!
cache
.
isForAdd
(
)
)
{
cache
.
setSingleShapeForAdd
(
newShape
)
;
}
else
if
(
cache
.
isSingleShapeForAdd
(
)
)
{
SharedShape
*
prevShape
=
cache
.
toSingleShapeForAdd
(
)
;
if
(
ShapeSetForAdd
*
set
=
MakeShapeSetForAdd
(
prevShape
newShape
)
)
{
cache
.
setShapeSetForAdd
(
set
)
;
AddCellMemory
(
oldShape
sizeof
(
ShapeSetForAdd
)
MemoryUse
:
:
ShapeSetForAdd
)
;
}
}
else
{
ShapeForAddHasher
:
:
Lookup
lookup
(
id
flags
)
;
(
void
)
cache
.
toShapeSetForAdd
(
)
-
>
putNew
(
lookup
newShape
)
;
}
return
true
;
}
void
Shape
:
:
maybeCacheIterator
(
JSContext
*
cx
PropertyIteratorObject
*
iter
)
{
if
(
!
cache
(
)
.
isNone
(
)
&
&
!
cache
(
)
.
isIterator
(
)
)
{
return
;
}
if
(
MOZ_UNLIKELY
(
!
RegisterShapeCache
(
cx
this
)
)
)
{
return
;
}
cacheRef
(
)
.
setIterator
(
iter
)
;
}
bool
NativeObject
:
:
addPropertyInReservedSlot
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
uint32_t
slot
PropertyFlags
flags
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
"
Use
addCustomDataProperty
for
custom
data
properties
"
)
;
MOZ_ASSERT
(
slot
<
JSCLASS_RESERVED_SLOTS
(
obj
-
>
getClass
(
)
)
)
;
MOZ_ASSERT
(
!
id
.
isVoid
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
MOZ_ASSERT
(
!
id
.
isPrivateName
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isExtensible
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
!
Watchtower
:
:
watchesPropertyAdd
(
obj
)
)
;
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
Rooted
<
SharedPropMap
*
>
map
(
cx
obj
-
>
sharedShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
if
(
!
SharedPropMap
:
:
addPropertyInReservedSlot
(
cx
clasp
&
map
&
mapLength
id
flags
slot
&
objectFlags
)
)
{
return
false
;
}
Shape
*
shape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
map
mapLength
objectFlags
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setShape
(
shape
)
;
MOZ_ASSERT
(
obj
-
>
getLastProperty
(
)
.
slot
(
)
=
=
slot
)
;
return
true
;
}
static
void
AssertCanChangeFlags
(
PropertyInfo
prop
PropertyFlags
flags
)
{
#
ifdef
DEBUG
if
(
prop
.
configurable
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
flags
.
configurable
(
)
)
;
MOZ_ASSERT_IF
(
prop
.
isDataProperty
(
)
flags
.
isDataProperty
(
)
)
;
MOZ_ASSERT_IF
(
prop
.
isAccessorProperty
(
)
flags
.
isAccessorProperty
(
)
)
;
#
endif
}
static
void
AssertValidArrayIndex
(
NativeObject
*
obj
jsid
id
)
{
#
ifdef
DEBUG
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
ArrayObject
*
arr
=
&
obj
-
>
as
<
ArrayObject
>
(
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
MOZ_ASSERT
(
index
<
arr
-
>
length
(
)
|
|
arr
-
>
lengthIsWritable
(
)
)
;
}
}
#
endif
}
bool
NativeObject
:
:
changeProperty
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
PropertyFlags
flags
uint32_t
*
slotOut
)
{
MOZ_ASSERT
(
!
id
.
isVoid
(
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidArrayIndex
(
obj
id
)
;
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
"
Use
changeCustomDataPropAttributes
for
custom
data
properties
"
)
;
if
(
!
Watchtower
:
:
watchPropertyChange
(
cx
obj
id
)
)
{
return
false
;
}
Rooted
<
PropMap
*
>
map
(
cx
obj
-
>
shape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
uint32_t
propIndex
;
Rooted
<
PropMap
*
>
propMap
(
cx
map
-
>
lookup
(
cx
mapLength
id
&
propIndex
)
)
;
MOZ_ASSERT
(
propMap
)
;
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
PropertyInfo
oldProp
=
propMap
-
>
getPropertyInfo
(
propIndex
)
;
AssertCanChangeFlags
(
oldProp
flags
)
;
if
(
oldProp
.
isAccessorProperty
(
)
)
{
objectFlags
.
setFlag
(
ObjectFlag
:
:
HadGetterSetterChange
)
;
}
if
(
oldProp
.
flags
(
)
=
=
flags
)
{
if
(
objectFlags
=
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
)
{
*
slotOut
=
oldProp
.
slot
(
)
;
return
true
;
}
if
(
map
-
>
isShared
(
)
)
{
if
(
!
Shape
:
:
replaceShape
(
cx
obj
objectFlags
obj
-
>
shape
(
)
-
>
proto
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
)
)
{
return
false
;
}
*
slotOut
=
oldProp
.
slot
(
)
;
return
true
;
}
}
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
if
(
map
-
>
isShared
(
)
)
{
if
(
propMap
=
=
map
&
&
propIndex
=
=
mapLength
-
1
)
{
MOZ_ASSERT
(
obj
-
>
getLastProperty
(
)
.
key
(
)
=
=
id
)
;
Rooted
<
SharedPropMap
*
>
sharedMap
(
cx
map
-
>
asShared
(
)
)
;
SharedPropMap
:
:
getPrevious
(
&
sharedMap
&
mapLength
)
;
if
(
MOZ_LIKELY
(
oldProp
.
hasSlot
(
)
)
)
{
*
slotOut
=
oldProp
.
slot
(
)
;
if
(
!
SharedPropMap
:
:
addPropertyWithKnownSlot
(
cx
clasp
&
sharedMap
&
mapLength
id
flags
*
slotOut
&
objectFlags
)
)
{
return
false
;
}
}
else
{
if
(
!
SharedPropMap
:
:
addProperty
(
cx
clasp
&
sharedMap
&
mapLength
id
flags
&
objectFlags
slotOut
)
)
{
return
false
;
}
}
SharedShape
*
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
sharedMap
mapLength
objectFlags
)
;
if
(
!
newShape
)
{
return
false
;
}
if
(
MOZ_LIKELY
(
oldProp
.
hasSlot
(
)
)
)
{
MOZ_ASSERT
(
obj
-
>
sharedShape
(
)
-
>
slotSpan
(
)
=
=
newShape
-
>
slotSpan
(
)
)
;
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
return
obj
-
>
setShapeAndAddNewSlot
(
cx
newShape
*
slotOut
)
;
}
if
(
!
NativeObject
:
:
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
map
=
obj
-
>
shape
(
)
-
>
propMap
(
)
;
propMap
=
map
-
>
lookup
(
cx
mapLength
id
&
propIndex
)
;
MOZ_ASSERT
(
propMap
)
;
}
else
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
map
-
>
isDictionary
(
)
)
;
MOZ_ASSERT
(
propMap
-
>
isDictionary
(
)
)
;
uint32_t
slot
=
oldProp
.
hasSlot
(
)
?
oldProp
.
slot
(
)
:
SHAPE_INVALID_SLOT
;
if
(
slot
=
=
SHAPE_INVALID_SLOT
)
{
if
(
!
allocDictionarySlot
(
cx
obj
&
slot
)
)
{
return
false
;
}
}
propMap
-
>
asDictionary
(
)
-
>
changeProperty
(
cx
clasp
propIndex
flags
slot
&
objectFlags
)
;
obj
-
>
dictionaryShape
(
)
-
>
setObjectFlagsOfNewShape
(
objectFlags
)
;
*
slotOut
=
slot
;
return
true
;
}
bool
NativeObject
:
:
changeCustomDataPropAttributes
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
PropertyFlags
flags
)
{
MOZ_ASSERT
(
!
id
.
isVoid
(
)
)
;
AutoCheckShapeConsistency
check
(
obj
)
;
AssertValidArrayIndex
(
obj
id
)
;
AssertValidCustomDataProp
(
obj
flags
)
;
if
(
!
Watchtower
:
:
watchPropertyChange
(
cx
obj
id
)
)
{
return
false
;
}
Rooted
<
PropMap
*
>
map
(
cx
obj
-
>
shape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
uint32_t
propIndex
;
Rooted
<
PropMap
*
>
propMap
(
cx
map
-
>
lookup
(
cx
mapLength
id
&
propIndex
)
)
;
MOZ_ASSERT
(
propMap
)
;
PropertyInfo
oldProp
=
propMap
-
>
getPropertyInfo
(
propIndex
)
;
MOZ_ASSERT
(
oldProp
.
isCustomDataProperty
(
)
)
;
AssertCanChangeFlags
(
oldProp
flags
)
;
if
(
oldProp
.
flags
(
)
=
=
flags
)
{
return
true
;
}
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
if
(
map
-
>
isShared
(
)
)
{
if
(
propMap
=
=
map
&
&
propIndex
=
=
mapLength
-
1
)
{
MOZ_ASSERT
(
obj
-
>
getLastProperty
(
)
.
key
(
)
=
=
id
)
;
Rooted
<
SharedPropMap
*
>
sharedMap
(
cx
map
-
>
asShared
(
)
)
;
SharedPropMap
:
:
getPrevious
(
&
sharedMap
&
mapLength
)
;
if
(
!
SharedPropMap
:
:
addCustomDataProperty
(
cx
clasp
&
sharedMap
&
mapLength
id
flags
&
objectFlags
)
)
{
return
false
;
}
Shape
*
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
sharedMap
mapLength
objectFlags
)
;
if
(
!
newShape
)
{
return
false
;
}
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
if
(
!
NativeObject
:
:
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
map
=
obj
-
>
shape
(
)
-
>
propMap
(
)
;
propMap
=
map
-
>
lookup
(
cx
mapLength
id
&
propIndex
)
;
MOZ_ASSERT
(
propMap
)
;
}
else
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
map
-
>
isDictionary
(
)
)
;
MOZ_ASSERT
(
propMap
-
>
isDictionary
(
)
)
;
propMap
-
>
asDictionary
(
)
-
>
changePropertyFlags
(
cx
clasp
propIndex
flags
&
objectFlags
)
;
obj
-
>
dictionaryShape
(
)
-
>
setObjectFlagsOfNewShape
(
objectFlags
)
;
return
true
;
}
void
NativeObject
:
:
maybeFreeDictionaryPropSlots
(
JSContext
*
cx
DictionaryPropMap
*
map
uint32_t
mapLength
)
{
MOZ_ASSERT
(
dictionaryShape
(
)
-
>
propMap
(
)
=
=
map
)
;
MOZ_ASSERT
(
shape
(
)
-
>
propMapLength
(
)
=
=
mapLength
)
;
if
(
mapLength
>
1
|
|
map
-
>
previous
(
)
)
{
return
;
}
if
(
mapLength
=
=
1
&
&
map
-
>
getPropertyInfo
(
0
)
.
hasSlot
(
)
)
{
return
;
}
uint32_t
oldSpan
=
dictionaryModeSlotSpan
(
)
;
uint32_t
newSpan
=
JSCLASS_RESERVED_SLOTS
(
getClass
(
)
)
;
if
(
oldSpan
=
=
newSpan
)
{
return
;
}
MOZ_ASSERT
(
newSpan
<
oldSpan
)
;
prepareSlotRangeForOverwrite
(
newSpan
oldSpan
)
;
invalidateSlotRange
(
newSpan
oldSpan
)
;
uint32_t
oldCapacity
=
numDynamicSlots
(
)
;
uint32_t
newCapacity
=
calculateDynamicSlots
(
numFixedSlots
(
)
newSpan
getClass
(
)
)
;
if
(
newCapacity
<
oldCapacity
)
{
shrinkSlots
(
cx
oldCapacity
newCapacity
)
;
}
setDictionaryModeSlotSpan
(
newSpan
)
;
map
-
>
setFreeList
(
SHAPE_INVALID_SLOT
)
;
}
void
NativeObject
:
:
setShapeAndRemoveLastSlot
(
JSContext
*
cx
SharedShape
*
newShape
uint32_t
slot
)
{
MOZ_ASSERT
(
!
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
newShape
-
>
isShared
(
)
)
;
MOZ_ASSERT
(
newShape
-
>
slotSpan
(
)
=
=
slot
)
;
uint32_t
numFixed
=
newShape
-
>
numFixedSlots
(
)
;
if
(
slot
<
numFixed
)
{
setFixedSlot
(
slot
UndefinedValue
(
)
)
;
}
else
{
setDynamicSlot
(
numFixed
slot
UndefinedValue
(
)
)
;
uint32_t
oldCapacity
=
numDynamicSlots
(
)
;
uint32_t
newCapacity
=
calculateDynamicSlots
(
numFixed
slot
getClass
(
)
)
;
MOZ_ASSERT
(
newCapacity
<
=
oldCapacity
)
;
if
(
newCapacity
<
oldCapacity
)
{
shrinkSlots
(
cx
oldCapacity
newCapacity
)
;
}
}
setShape
(
newShape
)
;
}
bool
NativeObject
:
:
removeProperty
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
HandleId
id
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
Rooted
<
PropMap
*
>
map
(
cx
obj
-
>
shape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
AutoKeepPropMapTables
keep
(
cx
)
;
PropMapTable
*
table
;
PropMapTable
:
:
Ptr
ptr
;
Rooted
<
PropMap
*
>
propMap
(
cx
)
;
uint32_t
propIndex
;
if
(
!
PropMap
:
:
lookupForRemove
(
cx
map
mapLength
id
keep
propMap
.
address
(
)
&
propIndex
&
table
&
ptr
)
)
{
return
false
;
}
if
(
!
propMap
)
{
return
true
;
}
if
(
!
Watchtower
:
:
watchPropertyRemove
(
cx
obj
id
)
)
{
return
false
;
}
PropertyInfo
prop
=
propMap
-
>
getPropertyInfo
(
propIndex
)
;
if
(
prop
.
isAccessorProperty
(
)
&
&
!
obj
-
>
hadGetterSetterChange
(
)
)
{
if
(
!
NativeObject
:
:
setHadGetterSetterChange
(
cx
obj
)
)
{
return
false
;
}
}
if
(
map
-
>
isShared
(
)
)
{
if
(
propMap
=
=
map
&
&
propIndex
=
=
mapLength
-
1
)
{
MOZ_ASSERT
(
obj
-
>
getLastProperty
(
)
.
key
(
)
=
=
id
)
;
Rooted
<
SharedPropMap
*
>
sharedMap
(
cx
map
-
>
asShared
(
)
)
;
SharedPropMap
:
:
getPrevious
(
&
sharedMap
&
mapLength
)
;
SharedShape
*
shape
=
obj
-
>
sharedShape
(
)
;
SharedShape
*
newShape
;
if
(
sharedMap
)
{
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
shape
-
>
base
(
)
shape
-
>
numFixedSlots
(
)
sharedMap
mapLength
shape
-
>
objectFlags
(
)
)
;
}
else
{
newShape
=
SharedShape
:
:
getInitialShape
(
cx
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
shape
-
>
proto
(
)
shape
-
>
numFixedSlots
(
)
shape
-
>
objectFlags
(
)
)
;
}
if
(
!
newShape
)
{
return
false
;
}
if
(
MOZ_LIKELY
(
prop
.
hasSlot
(
)
)
)
{
if
(
MOZ_LIKELY
(
prop
.
slot
(
)
=
=
newShape
-
>
slotSpan
(
)
)
)
{
obj
-
>
setShapeAndRemoveLastSlot
(
cx
newShape
prop
.
slot
(
)
)
;
return
true
;
}
MOZ_ASSERT
(
prop
.
slot
(
)
<
JSCLASS_RESERVED_SLOTS
(
obj
-
>
getClass
(
)
)
)
;
obj
-
>
setSlot
(
prop
.
slot
(
)
UndefinedValue
(
)
)
;
}
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
if
(
!
NativeObject
:
:
toDictionaryMode
(
cx
obj
)
)
{
return
false
;
}
map
=
obj
-
>
shape
(
)
-
>
propMap
(
)
;
if
(
!
PropMap
:
:
lookupForRemove
(
cx
map
mapLength
id
keep
propMap
.
address
(
)
&
propIndex
&
table
&
ptr
)
)
{
return
false
;
}
}
else
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
map
-
>
isDictionary
(
)
)
;
MOZ_ASSERT
(
table
)
;
MOZ_ASSERT
(
prop
=
=
ptr
-
>
propertyInfo
(
)
)
;
Rooted
<
DictionaryPropMap
*
>
dictMap
(
cx
map
-
>
asDictionary
(
)
)
;
if
(
prop
.
hasSlot
(
)
)
{
obj
-
>
freeDictionarySlot
(
prop
.
slot
(
)
)
;
}
DictionaryPropMap
:
:
removeProperty
(
cx
&
dictMap
&
mapLength
table
ptr
)
;
obj
-
>
dictionaryShape
(
)
-
>
updateNewShape
(
obj
-
>
shape
(
)
-
>
objectFlags
(
)
dictMap
mapLength
)
;
static
constexpr
size_t
MinSlotSpanForFree
=
64
;
if
(
obj
-
>
dictionaryModeSlotSpan
(
)
>
=
MinSlotSpanForFree
)
{
obj
-
>
maybeFreeDictionaryPropSlots
(
cx
dictMap
mapLength
)
;
}
return
true
;
}
bool
NativeObject
:
:
densifySparseElements
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
Rooted
<
DictionaryPropMap
*
>
map
(
cx
obj
-
>
shape
(
)
-
>
propMap
(
)
-
>
asDictionary
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
DictionaryPropMap
:
:
densifyElements
(
cx
&
map
&
mapLength
obj
)
;
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
objectFlags
.
clearFlag
(
ObjectFlag
:
:
Indexed
)
;
obj
-
>
dictionaryShape
(
)
-
>
updateNewShape
(
objectFlags
map
mapLength
)
;
obj
-
>
maybeFreeDictionaryPropSlots
(
cx
map
mapLength
)
;
return
true
;
}
bool
NativeObject
:
:
freezeOrSealProperties
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
IntegrityLevel
level
)
{
AutoCheckShapeConsistency
check
(
obj
)
;
if
(
!
Watchtower
:
:
watchFreezeOrSeal
(
cx
obj
)
)
{
return
false
;
}
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
MOZ_ASSERT
(
mapLength
>
0
)
;
const
JSClass
*
clasp
=
obj
-
>
shape
(
)
-
>
getObjectClass
(
)
;
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
DictionaryPropMap
*
map
=
obj
-
>
dictionaryShape
(
)
-
>
propMap
(
)
;
map
-
>
freezeOrSealProperties
(
cx
level
clasp
mapLength
&
objectFlags
)
;
obj
-
>
dictionaryShape
(
)
-
>
updateNewShape
(
objectFlags
map
mapLength
)
;
return
true
;
}
Rooted
<
SharedPropMap
*
>
map
(
cx
obj
-
>
sharedShape
(
)
-
>
propMap
(
)
)
;
if
(
!
SharedPropMap
:
:
freezeOrSealProperties
(
cx
level
clasp
&
map
mapLength
&
objectFlags
)
)
{
return
false
;
}
SharedShape
*
newShape
=
SharedShape
:
:
getPropMapShape
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
obj
-
>
numFixedSlots
(
)
map
mapLength
objectFlags
)
;
if
(
!
newShape
)
{
return
false
;
}
MOZ_ASSERT
(
obj
-
>
sharedShape
(
)
-
>
slotSpan
(
)
=
=
newShape
-
>
slotSpan
(
)
)
;
obj
-
>
setShape
(
newShape
)
;
return
true
;
}
bool
NativeObject
:
:
generateNewDictionaryShape
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
)
{
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
Rooted
<
BaseShape
*
>
base
(
cx
obj
-
>
shape
(
)
-
>
base
(
)
)
;
Rooted
<
DictionaryPropMap
*
>
map
(
cx
obj
-
>
dictionaryShape
(
)
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
obj
-
>
shape
(
)
-
>
propMapLength
(
)
;
Shape
*
shape
=
DictionaryShape
:
:
new_
(
cx
base
obj
-
>
shape
(
)
-
>
objectFlags
(
)
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
map
mapLength
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setShape
(
shape
)
;
return
true
;
}
bool
JSObject
:
:
setFlag
(
JSContext
*
cx
HandleObject
obj
ObjectFlag
flag
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
if
(
obj
-
>
hasFlag
(
flag
)
)
{
return
true
;
}
ObjectFlags
objectFlags
=
obj
-
>
shape
(
)
-
>
objectFlags
(
)
;
objectFlags
.
setFlag
(
flag
)
;
uint32_t
numFixed
=
0
;
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
inDictionaryMode
(
)
)
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
nobj
)
)
{
return
false
;
}
nobj
-
>
dictionaryShape
(
)
-
>
setObjectFlagsOfNewShape
(
objectFlags
)
;
return
true
;
}
numFixed
=
nobj
-
>
numFixedSlots
(
)
;
}
return
Shape
:
:
replaceShape
(
cx
obj
objectFlags
obj
-
>
shape
(
)
-
>
proto
(
)
numFixed
)
;
}
static
bool
SetObjectIsUsedAsPrototype
(
JSContext
*
cx
Handle
<
JSObject
*
>
proto
)
{
MOZ_ASSERT
(
!
proto
-
>
isUsedAsPrototype
(
)
)
;
uint64_t
unused
;
if
(
!
cx
-
>
zone
(
)
-
>
getOrCreateUniqueId
(
proto
&
unused
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
JSObject
:
:
setIsUsedAsPrototype
(
cx
proto
)
;
}
bool
JSObject
:
:
setProtoUnchecked
(
JSContext
*
cx
HandleObject
obj
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
staticPrototypeIsImmutable
(
)
)
;
MOZ_ASSERT_IF
(
!
obj
-
>
is
<
ProxyObject
>
(
)
obj
-
>
nonProxyIsExtensible
(
)
)
;
MOZ_ASSERT
(
obj
-
>
shape
(
)
-
>
proto
(
)
!
=
proto
)
;
if
(
!
Watchtower
:
:
watchProtoChange
(
cx
obj
)
)
{
return
false
;
}
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
SetObjectIsUsedAsPrototype
(
cx
protoObj
)
)
{
return
false
;
}
}
uint32_t
numFixed
=
0
;
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
inDictionaryMode
(
)
)
{
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
nobj
-
>
getClass
(
)
nobj
-
>
realm
(
)
proto
)
)
;
if
(
!
nbase
)
{
return
false
;
}
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
nobj
)
)
{
return
false
;
}
nobj
-
>
dictionaryShape
(
)
-
>
setBaseOfNewShape
(
nbase
)
;
return
true
;
}
numFixed
=
nobj
-
>
numFixedSlots
(
)
;
}
return
Shape
:
:
replaceShape
(
cx
obj
obj
-
>
shape
(
)
-
>
objectFlags
(
)
proto
numFixed
)
;
}
bool
NativeObject
:
:
changeNumFixedSlotsAfterSwap
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
uint32_t
nfixed
)
{
MOZ_ASSERT
(
nfixed
!
=
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
)
;
if
(
obj
-
>
inDictionaryMode
(
)
)
{
if
(
!
NativeObject
:
:
generateNewDictionaryShape
(
cx
obj
)
)
{
return
false
;
}
obj
-
>
dictionaryShape
(
)
-
>
setNumFixedSlotsOfNewShape
(
nfixed
)
;
return
true
;
}
return
Shape
:
:
replaceShape
(
cx
obj
obj
-
>
shape
(
)
-
>
objectFlags
(
)
obj
-
>
shape
(
)
-
>
proto
(
)
nfixed
)
;
}
BaseShape
:
:
BaseShape
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
)
:
TenuredCellWithNonGCPointer
(
clasp
)
realm_
(
realm
)
proto_
(
proto
)
{
#
ifdef
DEBUG
AssertJSClassInvariants
(
clasp
)
;
#
endif
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
compartment
(
)
=
=
proto
.
toObject
(
)
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
#
ifdef
DEBUG
if
(
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
)
{
AssertTargetIsNotGray
(
global
)
;
}
#
endif
}
BaseShape
*
BaseShape
:
:
get
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
Handle
<
TaggedProto
>
proto
)
{
auto
&
table
=
cx
-
>
zone
(
)
-
>
shapeZone
(
)
.
baseShapes
;
using
Lookup
=
BaseShapeHasher
:
:
Lookup
;
auto
p
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
)
)
;
if
(
p
)
{
return
*
p
;
}
BaseShape
*
nbase
=
cx
-
>
newCell
<
BaseShape
>
(
clasp
realm
proto
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
if
(
!
p
.
add
(
cx
table
Lookup
(
clasp
realm
proto
)
nbase
)
)
{
return
nullptr
;
}
return
nbase
;
}
SharedShape
*
SharedShape
:
:
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
uint32_t
nfixed
Handle
<
SharedPropMap
*
>
map
uint32_t
mapLength
)
{
return
cx
-
>
newCell
<
SharedShape
>
(
base
objectFlags
nfixed
map
mapLength
)
;
}
DictionaryShape
*
DictionaryShape
:
:
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
uint32_t
nfixed
Handle
<
DictionaryPropMap
*
>
map
uint32_t
mapLength
)
{
return
cx
-
>
newCell
<
DictionaryShape
>
(
base
objectFlags
nfixed
map
mapLength
)
;
}
ProxyShape
*
ProxyShape
:
:
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
)
{
return
cx
-
>
newCell
<
ProxyShape
>
(
base
objectFlags
)
;
}
WasmGCShape
*
WasmGCShape
:
:
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
)
{
return
cx
-
>
newCell
<
WasmGCShape
>
(
base
objectFlags
)
;
}
MOZ_ALWAYS_INLINE
HashNumber
ShapeForAddHasher
:
:
hash
(
const
Lookup
&
l
)
{
HashNumber
hash
=
HashPropertyKey
(
l
.
key
)
;
return
mozilla
:
:
AddToHash
(
hash
l
.
flags
.
toRaw
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
ShapeForAddHasher
:
:
match
(
SharedShape
*
shape
const
Lookup
&
l
)
{
uint32_t
slot
;
return
shape
-
>
lastPropertyMatchesForAdd
(
l
.
key
l
.
flags
&
slot
)
;
}
#
ifdef
DEBUG
void
Shape
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
const
{
out
.
printf
(
"
shape
0x
%
p
\
n
"
this
)
;
out
.
printf
(
"
base
:
0x
%
p
\
n
"
base
(
)
)
;
switch
(
kind
(
)
)
{
case
Kind
:
:
Shared
:
out
.
printf
(
"
kind
:
Shared
\
n
"
)
;
break
;
case
Kind
:
:
Dictionary
:
out
.
printf
(
"
kind
:
Dictionary
\
n
"
)
;
break
;
case
Kind
:
:
Proxy
:
out
.
printf
(
"
kind
:
Proxy
\
n
"
)
;
break
;
case
Kind
:
:
WasmGC
:
out
.
printf
(
"
kind
:
WasmGC
\
n
"
)
;
break
;
}
if
(
isNative
(
)
)
{
out
.
printf
(
"
mapLength
:
%
u
\
n
"
asNative
(
)
.
propMapLength
(
)
)
;
if
(
nativePropMap_
)
{
out
.
printf
(
"
map
:
\
n
"
)
;
nativePropMap_
-
>
dump
(
out
)
;
}
else
{
out
.
printf
(
"
map
:
(
none
)
\
n
"
)
;
}
}
}
void
Shape
:
:
dump
(
)
const
{
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
#
endif
SharedShape
*
SharedShape
:
:
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
size_t
nfixed
ObjectFlags
objectFlags
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
realm
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
proto
.
isObject
(
)
)
{
if
(
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
{
JSObject
*
protoObj
=
proto
.
toObject
(
)
;
Shape
*
protoObjShape
=
protoObj
-
>
shape
(
)
;
if
(
protoObjShape
-
>
cache
(
)
.
isShapeWithProto
(
)
)
{
SharedShape
*
shape
=
protoObjShape
-
>
cache
(
)
.
toShapeWithProto
(
)
;
if
(
shape
-
>
numFixedSlots
(
)
=
=
nfixed
&
&
shape
-
>
objectFlags
(
)
=
=
objectFlags
&
&
shape
-
>
getObjectClass
(
)
=
=
clasp
&
&
shape
-
>
realm
(
)
=
=
realm
&
&
shape
-
>
proto
(
)
=
=
proto
)
{
#
ifdef
DEBUG
using
Lookup
=
InitialShapeHasher
:
:
Lookup
;
Lookup
lookup
(
clasp
realm
proto
nfixed
objectFlags
)
;
auto
p
=
realm
-
>
zone
(
)
-
>
shapeZone
(
)
.
initialShapes
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
*
p
=
=
shape
)
;
#
endif
return
shape
;
}
}
}
else
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
SetObjectIsUsedAsPrototype
(
cx
protoObj
)
)
{
return
nullptr
;
}
proto
=
TaggedProto
(
protoObj
)
;
}
}
auto
&
table
=
realm
-
>
zone
(
)
-
>
shapeZone
(
)
.
initialShapes
;
using
Lookup
=
InitialShapeHasher
:
:
Lookup
;
auto
ptr
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
nfixed
objectFlags
)
)
;
if
(
ptr
)
{
if
(
proto
.
isObject
(
)
)
{
JSObject
*
protoObj
=
proto
.
toObject
(
)
;
Shape
*
protoShape
=
protoObj
-
>
shape
(
)
;
if
(
!
protoShape
-
>
cache
(
)
.
isForAdd
(
)
&
&
RegisterShapeCache
(
cx
protoShape
)
)
{
protoShape
-
>
cacheRef
(
)
.
setShapeWithProto
(
*
ptr
)
;
}
}
return
*
ptr
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
clasp
realm
protoRoot
)
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
Rooted
<
SharedShape
*
>
shape
(
cx
SharedShape
:
:
new_
(
cx
nbase
objectFlags
nfixed
nullptr
0
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
Lookup
lookup
(
clasp
realm
protoRoot
nfixed
objectFlags
)
;
if
(
!
ptr
.
add
(
cx
table
lookup
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
SharedShape
*
SharedShape
:
:
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
gc
:
:
AllocKind
kind
ObjectFlags
objectFlags
)
{
return
getInitialShape
(
cx
clasp
realm
proto
GetGCKindSlots
(
kind
)
objectFlags
)
;
}
SharedShape
*
SharedShape
:
:
getPropMapShape
(
JSContext
*
cx
BaseShape
*
base
size_t
nfixed
Handle
<
SharedPropMap
*
>
map
uint32_t
mapLength
ObjectFlags
objectFlags
bool
*
allocatedNewShape
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
base
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
base
-
>
proto
(
)
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
base
-
>
proto
(
)
.
toObject
(
)
)
)
;
MOZ_ASSERT_IF
(
base
-
>
proto
(
)
.
isObject
(
)
base
-
>
proto
(
)
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
;
MOZ_ASSERT
(
map
)
;
MOZ_ASSERT
(
mapLength
>
0
)
;
auto
&
table
=
cx
-
>
zone
(
)
-
>
shapeZone
(
)
.
propMapShapes
;
using
Lookup
=
PropMapShapeHasher
:
:
Lookup
;
auto
ptr
=
MakeDependentAddPtr
(
cx
table
Lookup
(
base
nfixed
map
mapLength
objectFlags
)
)
;
if
(
ptr
)
{
if
(
allocatedNewShape
)
{
*
allocatedNewShape
=
false
;
}
return
*
ptr
;
}
Rooted
<
BaseShape
*
>
baseRoot
(
cx
base
)
;
Rooted
<
SharedShape
*
>
shape
(
cx
SharedShape
:
:
new_
(
cx
baseRoot
objectFlags
nfixed
map
mapLength
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
Lookup
lookup
(
baseRoot
nfixed
map
mapLength
objectFlags
)
;
if
(
!
ptr
.
add
(
cx
table
lookup
shape
)
)
{
return
nullptr
;
}
if
(
allocatedNewShape
)
{
*
allocatedNewShape
=
true
;
}
return
shape
;
}
SharedShape
*
SharedShape
:
:
getInitialOrPropMapShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
size_t
nfixed
Handle
<
SharedPropMap
*
>
map
uint32_t
mapLength
ObjectFlags
objectFlags
)
{
if
(
!
map
)
{
MOZ_ASSERT
(
mapLength
=
=
0
)
;
return
getInitialShape
(
cx
clasp
realm
proto
nfixed
objectFlags
)
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
BaseShape
*
nbase
=
BaseShape
:
:
get
(
cx
clasp
realm
protoRoot
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
return
getPropMapShape
(
cx
nbase
nfixed
map
mapLength
objectFlags
)
;
}
void
SharedShape
:
:
insertInitialShape
(
JSContext
*
cx
Handle
<
SharedShape
*
>
shape
)
{
using
Lookup
=
InitialShapeHasher
:
:
Lookup
;
Lookup
lookup
(
shape
-
>
getObjectClass
(
)
shape
-
>
realm
(
)
shape
-
>
proto
(
)
shape
-
>
numFixedSlots
(
)
shape
-
>
objectFlags
(
)
)
;
auto
&
table
=
cx
-
>
zone
(
)
-
>
shapeZone
(
)
.
initialShapes
;
InitialShapeSet
:
:
Ptr
p
=
table
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
)
;
SharedShape
*
initialShape
=
*
p
;
if
(
initialShape
=
=
shape
)
{
return
;
}
MOZ_ASSERT
(
initialShape
-
>
numFixedSlots
(
)
=
=
shape
-
>
numFixedSlots
(
)
)
;
MOZ_ASSERT
(
initialShape
-
>
base
(
)
=
=
shape
-
>
base
(
)
)
;
MOZ_ASSERT
(
initialShape
-
>
objectFlags
(
)
=
=
shape
-
>
objectFlags
(
)
)
;
table
.
replaceKey
(
p
lookup
shape
.
get
(
)
)
;
if
(
shape
-
>
proto
(
)
.
isObject
(
)
)
{
JSObject
*
protoObj
=
shape
-
>
proto
(
)
.
toObject
(
)
;
if
(
protoObj
-
>
shape
(
)
-
>
cache
(
)
.
isShapeWithProto
(
)
)
{
protoObj
-
>
shape
(
)
-
>
cacheRef
(
)
.
setNone
(
)
;
}
}
}
ProxyShape
*
ProxyShape
:
:
getShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
ObjectFlags
objectFlags
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
realm
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
SetObjectIsUsedAsPrototype
(
cx
protoObj
)
)
{
return
nullptr
;
}
proto
=
TaggedProto
(
protoObj
)
;
}
auto
&
table
=
realm
-
>
zone
(
)
-
>
shapeZone
(
)
.
proxyShapes
;
using
Lookup
=
ProxyShapeHasher
:
:
Lookup
;
auto
ptr
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
objectFlags
)
)
;
if
(
ptr
)
{
return
*
ptr
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
clasp
realm
protoRoot
)
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
Rooted
<
ProxyShape
*
>
shape
(
cx
ProxyShape
:
:
new_
(
cx
nbase
objectFlags
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
Lookup
lookup
(
clasp
realm
protoRoot
objectFlags
)
;
if
(
!
ptr
.
add
(
cx
table
lookup
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
WasmGCShape
*
WasmGCShape
:
:
getShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
ObjectFlags
objectFlags
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
realm
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isUsedAsPrototype
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
SetObjectIsUsedAsPrototype
(
cx
protoObj
)
)
{
return
nullptr
;
}
proto
=
TaggedProto
(
protoObj
)
;
}
auto
&
table
=
realm
-
>
zone
(
)
-
>
shapeZone
(
)
.
wasmGCShapes
;
using
Lookup
=
WasmGCShapeHasher
:
:
Lookup
;
auto
ptr
=
MakeDependentAddPtr
(
cx
table
Lookup
(
clasp
realm
proto
objectFlags
)
)
;
if
(
ptr
)
{
return
*
ptr
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
Rooted
<
BaseShape
*
>
nbase
(
cx
BaseShape
:
:
get
(
cx
clasp
realm
protoRoot
)
)
;
if
(
!
nbase
)
{
return
nullptr
;
}
Rooted
<
WasmGCShape
*
>
shape
(
cx
WasmGCShape
:
:
new_
(
cx
nbase
objectFlags
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
Lookup
lookup
(
clasp
realm
protoRoot
objectFlags
)
;
if
(
!
ptr
.
add
(
cx
table
lookup
shape
)
)
{
return
nullptr
;
}
return
shape
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
Shape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
if
(
get
(
)
.
cache
(
)
.
isShapeSetForAdd
(
)
)
{
ShapeSetForAdd
*
set
=
get
(
)
.
cache
(
)
.
toShapeSetForAdd
(
)
;
size
+
=
set
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
BaseShape
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
