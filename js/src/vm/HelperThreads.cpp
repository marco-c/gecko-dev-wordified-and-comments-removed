#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
algorithm
>
#
include
"
frontend
/
BytecodeCompilation
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
jit
/
IonCompileTask
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
HelperThreadAPI
.
h
"
#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
CpuCount
.
h
"
#
include
"
util
/
NativeStack
.
h
"
#
include
"
vm
/
ErrorReporting
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
InternalThreadPool
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
debugger
/
DebugAPI
-
inl
.
h
"
#
include
"
gc
/
ArenaList
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
Utf8Unit
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
DispatchReason
;
using
JS
:
:
ReadOnlyCompileOptions
;
namespace
js
{
Mutex
gHelperThreadLock
(
mutexid
:
:
GlobalHelperThreadState
)
;
GlobalHelperThreadState
*
gHelperThreadState
=
nullptr
;
}
bool
js
:
:
CreateHelperThreadsState
(
)
{
MOZ_ASSERT
(
!
gHelperThreadState
)
;
gHelperThreadState
=
js_new
<
GlobalHelperThreadState
>
(
)
;
return
gHelperThreadState
;
}
void
js
:
:
DestroyHelperThreadsState
(
)
{
AutoLockHelperThreadState
lock
;
if
(
!
gHelperThreadState
)
{
return
;
}
gHelperThreadState
-
>
finish
(
lock
)
;
js_delete
(
gHelperThreadState
)
;
gHelperThreadState
=
nullptr
;
}
bool
js
:
:
EnsureHelperThreadsInitialized
(
)
{
MOZ_ASSERT
(
gHelperThreadState
)
;
return
gHelperThreadState
-
>
ensureInitialized
(
)
;
}
static
size_t
ClampDefaultCPUCount
(
size_t
cpuCount
)
{
return
std
:
:
min
<
size_t
>
(
cpuCount
8
)
;
}
static
size_t
ThreadCountForCPUCount
(
size_t
cpuCount
)
{
return
std
:
:
max
<
size_t
>
(
cpuCount
2
)
;
}
bool
js
:
:
SetFakeCPUCount
(
size_t
count
)
{
HelperThreadState
(
)
.
setCpuCount
(
count
)
;
return
true
;
}
void
GlobalHelperThreadState
:
:
setCpuCount
(
size_t
count
)
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
isInitialized
(
lock
)
)
;
MOZ_ASSERT
(
!
dispatchTaskCallback
)
;
cpuCount
=
count
;
threadCount
=
ThreadCountForCPUCount
(
count
)
;
}
size_t
js
:
:
GetHelperThreadCount
(
)
{
return
HelperThreadState
(
)
.
threadCount
;
}
size_t
js
:
:
GetHelperThreadCPUCount
(
)
{
return
HelperThreadState
(
)
.
cpuCount
;
}
size_t
js
:
:
GetMaxWasmCompilationThreads
(
)
{
return
HelperThreadState
(
)
.
maxWasmCompilationThreads
(
)
;
}
void
JS
:
:
SetProfilingThreadCallbacks
(
JS
:
:
RegisterThreadCallback
registerThread
JS
:
:
UnregisterThreadCallback
unregisterThread
)
{
HelperThreadState
(
)
.
registerThread
=
registerThread
;
HelperThreadState
(
)
.
unregisterThread
=
unregisterThread
;
}
static
size_t
ThreadStackQuotaForSize
(
size_t
size
)
{
return
size_t
(
double
(
size
)
*
0
.
9
)
;
}
JS_PUBLIC_API
MOZ_NEVER_INLINE
void
JS
:
:
SetHelperThreadTaskCallback
(
HelperThreadTaskCallback
callback
size_t
threadCount
size_t
stackSize
)
{
AutoLockHelperThreadState
lock
;
HelperThreadState
(
)
.
setDispatchTaskCallback
(
callback
threadCount
stackSize
lock
)
;
}
void
GlobalHelperThreadState
:
:
setDispatchTaskCallback
(
JS
:
:
HelperThreadTaskCallback
callback
size_t
threadCount
size_t
stackSize
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
isInitialized
(
lock
)
)
;
MOZ_ASSERT
(
!
dispatchTaskCallback
)
;
MOZ_ASSERT
(
threadCount
!
=
0
)
;
MOZ_ASSERT
(
stackSize
>
=
16
*
1024
)
;
dispatchTaskCallback
=
callback
;
this
-
>
threadCount
=
threadCount
;
this
-
>
stackQuota
=
ThreadStackQuotaForSize
(
stackSize
)
;
}
bool
js
:
:
StartOffThreadWasmCompile
(
wasm
:
:
CompileTask
*
task
wasm
:
:
CompileMode
mode
)
{
return
HelperThreadState
(
)
.
submitTask
(
task
mode
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
wasm
:
:
CompileTask
*
task
wasm
:
:
CompileMode
mode
)
{
AutoLockHelperThreadState
lock
;
if
(
!
wasmWorklist
(
lock
mode
)
.
pushBack
(
task
)
)
{
return
false
;
}
dispatch
(
DispatchReason
:
:
NewTask
lock
)
;
return
true
;
}
size_t
js
:
:
RemovePendingWasmCompileTasks
(
const
wasm
:
:
CompileTaskState
&
taskState
wasm
:
:
CompileMode
mode
const
AutoLockHelperThreadState
&
lock
)
{
wasm
:
:
CompileTaskPtrFifo
&
worklist
=
HelperThreadState
(
)
.
wasmWorklist
(
lock
mode
)
;
return
worklist
.
eraseIf
(
[
&
taskState
]
(
wasm
:
:
CompileTask
*
task
)
{
return
&
task
-
>
state
=
=
&
taskState
;
}
)
;
}
void
js
:
:
StartOffThreadWasmTier2Generator
(
wasm
:
:
UniqueTier2GeneratorTask
task
)
{
(
void
)
HelperThreadState
(
)
.
submitTask
(
std
:
:
move
(
task
)
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
wasm
:
:
UniqueTier2GeneratorTask
task
)
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
isInitialized
(
lock
)
)
;
if
(
!
wasmTier2GeneratorWorklist
(
lock
)
.
append
(
task
.
get
(
)
)
)
{
return
false
;
}
(
void
)
task
.
release
(
)
;
dispatch
(
DispatchReason
:
:
NewTask
lock
)
;
return
true
;
}
static
void
CancelOffThreadWasmTier2GeneratorLocked
(
AutoLockHelperThreadState
&
lock
)
{
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
{
wasm
:
:
Tier2GeneratorTaskPtrVector
&
worklist
=
HelperThreadState
(
)
.
wasmTier2GeneratorWorklist
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
worklist
.
length
(
)
;
i
+
+
)
{
wasm
:
:
Tier2GeneratorTask
*
task
=
worklist
[
i
]
;
HelperThreadState
(
)
.
remove
(
worklist
&
i
)
;
js_delete
(
task
)
;
}
}
static_assert
(
GlobalHelperThreadState
:
:
MaxTier2GeneratorTasks
=
=
1
"
code
must
be
generalized
"
)
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
wasm
:
:
Tier2GeneratorTask
>
(
)
)
{
helper
-
>
as
<
wasm
:
:
Tier2GeneratorTask
>
(
)
-
>
cancel
(
)
;
uint32_t
oldFinishedCount
=
HelperThreadState
(
)
.
wasmTier2GeneratorsFinished
(
lock
)
;
while
(
HelperThreadState
(
)
.
wasmTier2GeneratorsFinished
(
lock
)
=
=
oldFinishedCount
)
{
HelperThreadState
(
)
.
wait
(
lock
)
;
}
break
;
}
}
}
void
js
:
:
CancelOffThreadWasmTier2Generator
(
)
{
AutoLockHelperThreadState
lock
;
CancelOffThreadWasmTier2GeneratorLocked
(
lock
)
;
}
bool
js
:
:
StartOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
return
HelperThreadState
(
)
.
submitTask
(
task
lock
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
locked
)
{
MOZ_ASSERT
(
isInitialized
(
locked
)
)
;
if
(
!
ionWorklist
(
locked
)
.
append
(
task
)
)
{
return
false
;
}
task
-
>
alloc
(
)
.
lifoAlloc
(
)
-
>
setReadOnly
(
)
;
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
bool
js
:
:
StartOffThreadIonFree
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
js
:
:
UniquePtr
<
jit
:
:
IonFreeTask
>
freeTask
=
js
:
:
MakeUnique
<
jit
:
:
IonFreeTask
>
(
task
)
;
if
(
!
freeTask
)
{
return
false
;
}
return
HelperThreadState
(
)
.
submitTask
(
std
:
:
move
(
freeTask
)
lock
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
UniquePtr
<
jit
:
:
IonFreeTask
>
task
const
AutoLockHelperThreadState
&
locked
)
{
MOZ_ASSERT
(
isInitialized
(
locked
)
)
;
if
(
!
ionFreeList
(
locked
)
.
append
(
std
:
:
move
(
task
)
)
)
{
return
false
;
}
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
void
js
:
:
FinishOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
HelperThreadState
(
)
.
ionFinishedList
(
lock
)
.
append
(
task
)
)
{
oomUnsafe
.
crash
(
"
FinishOffThreadIonCompile
"
)
;
}
task
-
>
script
(
)
-
>
runtimeFromAnyThread
(
)
-
>
jitRuntime
(
)
-
>
numFinishedOffThreadTasksRef
(
lock
)
+
+
;
}
static
JSRuntime
*
GetSelectorRuntime
(
const
CompilationSelector
&
selector
)
{
struct
Matcher
{
JSRuntime
*
operator
(
)
(
JSScript
*
script
)
{
return
script
-
>
runtimeFromMainThread
(
)
;
}
JSRuntime
*
operator
(
)
(
Realm
*
realm
)
{
return
realm
-
>
runtimeFromMainThread
(
)
;
}
JSRuntime
*
operator
(
)
(
Zone
*
zone
)
{
return
zone
-
>
runtimeFromMainThread
(
)
;
}
JSRuntime
*
operator
(
)
(
ZonesInState
zbs
)
{
return
zbs
.
runtime
;
}
JSRuntime
*
operator
(
)
(
JSRuntime
*
runtime
)
{
return
runtime
;
}
}
;
return
selector
.
match
(
Matcher
(
)
)
;
}
static
bool
JitDataStructuresExist
(
const
CompilationSelector
&
selector
)
{
struct
Matcher
{
bool
operator
(
)
(
JSScript
*
script
)
{
return
!
!
script
-
>
realm
(
)
-
>
jitRealm
(
)
;
}
bool
operator
(
)
(
Realm
*
realm
)
{
return
!
!
realm
-
>
jitRealm
(
)
;
}
bool
operator
(
)
(
Zone
*
zone
)
{
return
!
!
zone
-
>
jitZone
(
)
;
}
bool
operator
(
)
(
ZonesInState
zbs
)
{
return
zbs
.
runtime
-
>
hasJitRuntime
(
)
;
}
bool
operator
(
)
(
JSRuntime
*
runtime
)
{
return
runtime
-
>
hasJitRuntime
(
)
;
}
}
;
return
selector
.
match
(
Matcher
(
)
)
;
}
static
bool
IonCompileTaskMatches
(
const
CompilationSelector
&
selector
jit
:
:
IonCompileTask
*
task
)
{
struct
TaskMatches
{
jit
:
:
IonCompileTask
*
task_
;
bool
operator
(
)
(
JSScript
*
script
)
{
return
script
=
=
task_
-
>
script
(
)
;
}
bool
operator
(
)
(
Realm
*
realm
)
{
return
realm
=
=
task_
-
>
script
(
)
-
>
realm
(
)
;
}
bool
operator
(
)
(
Zone
*
zone
)
{
return
zone
=
=
task_
-
>
script
(
)
-
>
zoneFromAnyThread
(
)
;
}
bool
operator
(
)
(
JSRuntime
*
runtime
)
{
return
runtime
=
=
task_
-
>
script
(
)
-
>
runtimeFromAnyThread
(
)
;
}
bool
operator
(
)
(
ZonesInState
zbs
)
{
return
zbs
.
runtime
=
=
task_
-
>
script
(
)
-
>
runtimeFromAnyThread
(
)
&
&
zbs
.
state
=
=
task_
-
>
script
(
)
-
>
zoneFromAnyThread
(
)
-
>
gcState
(
)
;
}
}
;
return
selector
.
match
(
TaskMatches
{
task
}
)
;
}
static
void
CancelOffThreadIonCompileLocked
(
const
CompilationSelector
&
selector
AutoLockHelperThreadState
&
lock
)
{
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
GlobalHelperThreadState
:
:
IonCompileTaskVector
&
worklist
=
HelperThreadState
(
)
.
ionWorklist
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
worklist
.
length
(
)
;
i
+
+
)
{
jit
:
:
IonCompileTask
*
task
=
worklist
[
i
]
;
if
(
IonCompileTaskMatches
(
selector
task
)
)
{
worklist
[
i
]
-
>
alloc
(
)
.
lifoAlloc
(
)
-
>
setReadWrite
(
)
;
FinishOffThreadIonCompile
(
task
lock
)
;
HelperThreadState
(
)
.
remove
(
worklist
&
i
)
;
}
}
bool
cancelled
;
do
{
cancelled
=
false
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
!
helper
-
>
is
<
jit
:
:
IonCompileTask
>
(
)
)
{
continue
;
}
jit
:
:
IonCompileTask
*
ionCompileTask
=
helper
-
>
as
<
jit
:
:
IonCompileTask
>
(
)
;
if
(
IonCompileTaskMatches
(
selector
ionCompileTask
)
)
{
ionCompileTask
-
>
mirGen
(
)
.
cancel
(
)
;
cancelled
=
true
;
}
}
if
(
cancelled
)
{
HelperThreadState
(
)
.
wait
(
lock
)
;
}
}
while
(
cancelled
)
;
GlobalHelperThreadState
:
:
IonCompileTaskVector
&
finished
=
HelperThreadState
(
)
.
ionFinishedList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
finished
.
length
(
)
;
i
+
+
)
{
jit
:
:
IonCompileTask
*
task
=
finished
[
i
]
;
if
(
IonCompileTaskMatches
(
selector
task
)
)
{
JSRuntime
*
rt
=
task
-
>
script
(
)
-
>
runtimeFromAnyThread
(
)
;
rt
-
>
jitRuntime
(
)
-
>
numFinishedOffThreadTasksRef
(
lock
)
-
-
;
jit
:
:
FinishOffThreadTask
(
rt
task
lock
)
;
HelperThreadState
(
)
.
remove
(
finished
&
i
)
;
}
}
JSRuntime
*
runtime
=
GetSelectorRuntime
(
selector
)
;
jit
:
:
IonCompileTask
*
task
=
runtime
-
>
jitRuntime
(
)
-
>
ionLazyLinkList
(
runtime
)
.
getFirst
(
)
;
while
(
task
)
{
jit
:
:
IonCompileTask
*
next
=
task
-
>
getNext
(
)
;
if
(
IonCompileTaskMatches
(
selector
task
)
)
{
jit
:
:
FinishOffThreadTask
(
runtime
task
lock
)
;
}
task
=
next
;
}
}
void
js
:
:
CancelOffThreadIonCompile
(
const
CompilationSelector
&
selector
)
{
if
(
!
JitDataStructuresExist
(
selector
)
)
{
return
;
}
AutoLockHelperThreadState
lock
;
CancelOffThreadIonCompileLocked
(
selector
lock
)
;
}
#
ifdef
DEBUG
bool
js
:
:
HasOffThreadIonCompile
(
Realm
*
realm
)
{
AutoLockHelperThreadState
lock
;
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
false
;
}
GlobalHelperThreadState
:
:
IonCompileTaskVector
&
worklist
=
HelperThreadState
(
)
.
ionWorklist
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
worklist
.
length
(
)
;
i
+
+
)
{
jit
:
:
IonCompileTask
*
task
=
worklist
[
i
]
;
if
(
task
-
>
script
(
)
-
>
realm
(
)
=
=
realm
)
{
return
true
;
}
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
jit
:
:
IonCompileTask
>
(
)
&
&
helper
-
>
as
<
jit
:
:
IonCompileTask
>
(
)
-
>
script
(
)
-
>
realm
(
)
=
=
realm
)
{
return
true
;
}
}
GlobalHelperThreadState
:
:
IonCompileTaskVector
&
finished
=
HelperThreadState
(
)
.
ionFinishedList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
finished
.
length
(
)
;
i
+
+
)
{
jit
:
:
IonCompileTask
*
task
=
finished
[
i
]
;
if
(
task
-
>
script
(
)
-
>
realm
(
)
=
=
realm
)
{
return
true
;
}
}
JSRuntime
*
rt
=
realm
-
>
runtimeFromMainThread
(
)
;
jit
:
:
IonCompileTask
*
task
=
rt
-
>
jitRuntime
(
)
-
>
ionLazyLinkList
(
rt
)
.
getFirst
(
)
;
while
(
task
)
{
if
(
task
-
>
script
(
)
-
>
realm
(
)
=
=
realm
)
{
return
true
;
}
task
=
task
-
>
getNext
(
)
;
}
return
false
;
}
#
endif
struct
MOZ_RAII
AutoSetContextOffThreadFrontendErrors
{
explicit
AutoSetContextOffThreadFrontendErrors
(
OffThreadFrontendErrors
*
errors
)
{
TlsContext
.
get
(
)
-
>
setOffThreadFrontendErrors
(
errors
)
;
}
~
AutoSetContextOffThreadFrontendErrors
(
)
{
TlsContext
.
get
(
)
-
>
setOffThreadFrontendErrors
(
nullptr
)
;
}
}
;
AutoSetHelperThreadContext
:
:
AutoSetHelperThreadContext
(
const
JS
:
:
ContextOptions
&
options
AutoLockHelperThreadState
&
lock
)
:
lock
(
lock
)
{
cx
=
HelperThreadState
(
)
.
getFirstUnusedContext
(
lock
)
;
MOZ_ASSERT
(
cx
)
;
cx
-
>
setHelperThread
(
options
lock
)
;
JS_SetNativeStackQuota
(
cx
HelperThreadState
(
)
.
stackQuota
)
;
}
AutoSetHelperThreadContext
:
:
~
AutoSetHelperThreadContext
(
)
{
cx
-
>
tempLifoAlloc
(
)
.
releaseAll
(
)
;
if
(
cx
-
>
shouldFreeUnusedMemory
(
)
)
{
cx
-
>
tempLifoAlloc
(
)
.
freeAll
(
)
;
cx
-
>
setFreeUnusedMemory
(
false
)
;
}
cx
-
>
clearHelperThread
(
lock
)
;
cx
=
nullptr
;
}
ParseTask
:
:
ParseTask
(
ParseTaskKind
kind
JSContext
*
cx
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
:
kind
(
kind
)
options
(
cx
)
contextOptions
(
cx
-
>
options
(
)
)
callback
(
callback
)
callbackData
(
callbackData
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
}
bool
ParseTask
:
:
init
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
if
(
!
this
-
>
options
.
copy
(
cx
options
)
)
{
return
false
;
}
runtime
=
cx
-
>
runtime
(
)
;
MOZ_ASSERT_IF
(
this
-
>
options
.
allocateInstantiationStorage
kind
!
=
ParseTaskKind
:
:
MultiStencilsDecode
)
;
if
(
this
-
>
options
.
allocateInstantiationStorage
)
{
gcOutput_
=
cx
-
>
make_unique
<
frontend
:
:
CompilationGCOutput
>
(
)
;
if
(
!
gcOutput_
)
{
return
false
;
}
}
return
true
;
}
void
ParseTask
:
:
moveGCOutputInto
(
JS
:
:
InstantiationStorage
&
storage
)
{
storage
.
gcOutput_
=
gcOutput_
.
release
(
)
;
}
void
ParseTask
:
:
activate
(
JSRuntime
*
rt
)
{
rt
-
>
addParseTaskRef
(
)
;
}
void
ParseTask
:
:
deactivate
(
JSRuntime
*
rt
)
{
rt
-
>
decParseTaskRef
(
)
;
}
ParseTask
:
:
~
ParseTask
(
)
=
default
;
void
ParseTask
:
:
trace
(
JSTracer
*
trc
)
{
if
(
runtime
!
=
trc
-
>
runtime
(
)
)
{
return
;
}
if
(
stencilInput_
)
{
stencilInput_
-
>
trace
(
trc
)
;
}
if
(
gcOutput_
)
{
gcOutput_
-
>
trace
(
trc
)
;
}
}
size_t
ParseTask
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
stencilInputSize
=
stencilInput_
?
stencilInput_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
size_t
stencilSize
=
stencil_
?
stencil_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
size_t
gcOutputSize
=
gcOutput_
?
gcOutput_
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
:
0
;
return
options
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
stencilInputSize
+
stencilSize
+
gcOutputSize
;
}
void
ParseTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
{
runTask
(
locked
)
;
scheduleDelazifyTask
(
locked
)
;
callback
(
this
callbackData
)
;
HelperThreadState
(
)
.
parseFinishedList
(
locked
)
.
insertBack
(
this
)
;
}
void
ParseTask
:
:
runTask
(
AutoLockHelperThreadState
&
lock
)
{
AutoSetHelperThreadContext
usesContext
(
contextOptions
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
AutoSetContextRuntime
ascr
(
runtime
)
;
AutoSetContextOffThreadFrontendErrors
recordErrors
(
&
this
-
>
errors
)
;
parse
(
cx
)
;
MOZ_ASSERT
(
cx
-
>
tempLifoAlloc
(
)
.
isEmpty
(
)
)
;
cx
-
>
tempLifoAlloc
(
)
.
freeAll
(
)
;
cx
-
>
frontendCollectionPool
(
)
.
purge
(
)
;
}
void
ParseTask
:
:
scheduleDelazifyTask
(
AutoLockHelperThreadState
&
lock
)
{
if
(
!
stencil_
)
{
return
;
}
auto
strategy
=
options
.
eagerDelazificationStrategy
(
)
;
if
(
strategy
=
=
JS
:
:
DelazificationOption
:
:
OnDemandOnly
|
|
strategy
=
=
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
)
{
return
;
}
UniquePtr
<
DelazifyTask
>
task
;
{
AutoSetHelperThreadContext
usesContext
(
contextOptions
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
AutoSetContextRuntime
ascr
(
runtime
)
;
task
=
DelazifyTask
:
:
Create
(
cx
runtime
contextOptions
options
*
stencil_
)
;
if
(
!
task
)
{
return
;
}
}
if
(
!
task
-
>
strategy
-
>
done
(
)
)
{
HelperThreadState
(
)
.
submitTask
(
task
.
release
(
)
lock
)
;
}
}
template
<
typename
Unit
>
struct
CompileToStencilTask
:
public
ParseTask
{
JS
:
:
SourceText
<
Unit
>
data
;
CompileToStencilTask
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
template
<
typename
Unit
>
struct
CompileModuleToStencilTask
:
public
ParseTask
{
JS
:
:
SourceText
<
Unit
>
data
;
CompileModuleToStencilTask
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
struct
DecodeStencilTask
:
public
ParseTask
{
const
JS
:
:
TranscodeRange
range
;
DecodeStencilTask
(
JSContext
*
cx
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
struct
MultiStencilsDecodeTask
:
public
ParseTask
{
JS
:
:
TranscodeSources
*
sources
;
MultiStencilsDecodeTask
(
JSContext
*
cx
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
template
<
typename
Unit
>
CompileToStencilTask
<
Unit
>
:
:
CompileToStencilTask
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
:
ParseTask
(
ParseTaskKind
:
:
ScriptStencil
cx
callback
callbackData
)
data
(
std
:
:
move
(
srcBuf
)
)
{
}
template
<
typename
Unit
>
void
CompileToStencilTask
<
Unit
>
:
:
parse
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
isHelperThreadContext
(
)
)
;
ScopeKind
scopeKind
=
options
.
nonSyntacticScope
?
ScopeKind
:
:
NonSyntactic
:
ScopeKind
:
:
Global
;
stencilInput_
=
cx
-
>
make_unique
<
frontend
:
:
CompilationInput
>
(
options
)
;
if
(
!
stencilInput_
)
{
return
;
}
js
:
:
LifoAlloc
tempLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
stencil_
=
frontend
:
:
CompileGlobalScriptToStencil
(
cx
tempLifoAlloc
*
stencilInput_
data
scopeKind
)
;
if
(
!
stencil_
)
{
return
;
}
if
(
options
.
allocateInstantiationStorage
)
{
if
(
!
frontend
:
:
PrepareForInstantiate
(
cx
*
stencilInput_
*
stencil_
*
gcOutput_
)
)
{
stencil_
=
nullptr
;
}
}
}
template
<
typename
Unit
>
CompileModuleToStencilTask
<
Unit
>
:
:
CompileModuleToStencilTask
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
:
ParseTask
(
ParseTaskKind
:
:
ModuleStencil
cx
callback
callbackData
)
data
(
std
:
:
move
(
srcBuf
)
)
{
}
template
<
typename
Unit
>
void
CompileModuleToStencilTask
<
Unit
>
:
:
parse
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
isHelperThreadContext
(
)
)
;
stencilInput_
=
cx
-
>
make_unique
<
frontend
:
:
CompilationInput
>
(
options
)
;
if
(
!
stencilInput_
)
{
return
;
}
stencil_
=
frontend
:
:
ParseModuleToStencil
(
cx
*
stencilInput_
data
)
;
if
(
!
stencil_
)
{
return
;
}
if
(
options
.
allocateInstantiationStorage
)
{
if
(
!
frontend
:
:
PrepareForInstantiate
(
cx
*
stencilInput_
*
stencil_
*
gcOutput_
)
)
{
stencil_
=
nullptr
;
}
}
}
DecodeStencilTask
:
:
DecodeStencilTask
(
JSContext
*
cx
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
:
ParseTask
(
ParseTaskKind
:
:
StencilDecode
cx
callback
callbackData
)
range
(
range
)
{
MOZ_ASSERT
(
JS
:
:
IsTranscodingBytecodeAligned
(
range
.
begin
(
)
.
get
(
)
)
)
;
}
void
DecodeStencilTask
:
:
parse
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
isHelperThreadContext
(
)
)
;
stencilInput_
=
cx
-
>
make_unique
<
frontend
:
:
CompilationInput
>
(
options
)
;
if
(
!
stencilInput_
)
{
return
;
}
if
(
!
stencilInput_
-
>
initForGlobal
(
cx
)
)
{
return
;
}
stencil_
=
cx
-
>
new_
<
frontend
:
:
CompilationStencil
>
(
stencilInput_
-
>
source
)
;
if
(
!
stencil_
)
{
return
;
}
bool
succeeded
=
false
;
(
void
)
stencil_
-
>
deserializeStencils
(
cx
*
stencilInput_
range
&
succeeded
)
;
if
(
!
succeeded
)
{
stencil_
=
nullptr
;
return
;
}
if
(
options
.
allocateInstantiationStorage
)
{
if
(
!
frontend
:
:
PrepareForInstantiate
(
cx
*
stencilInput_
*
stencil_
*
gcOutput_
)
)
{
stencil_
=
nullptr
;
}
}
}
MultiStencilsDecodeTask
:
:
MultiStencilsDecodeTask
(
JSContext
*
cx
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
:
ParseTask
(
ParseTaskKind
:
:
MultiStencilsDecode
cx
callback
callbackData
)
sources
(
&
sources
)
{
}
void
MultiStencilsDecodeTask
:
:
parse
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
isHelperThreadContext
(
)
)
;
if
(
!
stencils
.
reserve
(
sources
-
>
length
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
;
}
for
(
auto
&
source
:
*
sources
)
{
JS
:
:
DecodeOptions
decodeOptions
(
options
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
;
if
(
JS
:
:
DecodeStencil
(
cx
decodeOptions
source
.
range
getter_AddRefs
(
stencil
)
)
!
=
JS
:
:
TranscodeResult
:
:
Ok
)
{
break
;
}
if
(
stencil
)
{
stencils
.
infallibleEmplaceBack
(
stencil
.
forget
(
)
)
;
}
else
{
break
;
}
}
}
bool
js
:
:
StartOffThreadDelazification
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
frontend
:
:
CompilationStencil
&
stencil
)
{
auto
strategy
=
options
.
eagerDelazificationStrategy
(
)
;
if
(
strategy
=
=
JS
:
:
DelazificationOption
:
:
OnDemandOnly
|
|
strategy
=
=
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
)
{
return
true
;
}
if
(
cx
-
>
realm
(
)
-
>
collectCoverageForDebug
(
)
)
{
return
true
;
}
if
(
!
CanUseExtraThreads
(
)
)
{
return
true
;
}
JSRuntime
*
runtime
=
cx
-
>
runtime
(
)
;
UniquePtr
<
DelazifyTask
>
task
;
task
=
DelazifyTask
:
:
Create
(
cx
runtime
cx
-
>
options
(
)
options
stencil
)
;
if
(
!
task
)
{
return
false
;
}
if
(
!
task
-
>
strategy
-
>
done
(
)
)
{
AutoLockHelperThreadState
lock
;
HelperThreadState
(
)
.
submitTask
(
task
.
release
(
)
lock
)
;
}
return
true
;
}
bool
DepthFirstDelazification
:
:
add
(
JSContext
*
cx
const
frontend
:
:
CompilationStencil
&
stencil
ScriptIndex
index
)
{
using
namespace
js
:
:
frontend
;
ScriptStencilRef
scriptRef
{
stencil
index
}
;
MOZ_ASSERT
(
!
scriptRef
.
scriptData
(
)
.
isGhost
(
)
)
;
MOZ_ASSERT
(
scriptRef
.
scriptData
(
)
.
hasSharedData
(
)
)
;
size_t
offset
=
scriptRef
.
scriptData
(
)
.
gcThingsOffset
.
index
;
size_t
length
=
scriptRef
.
scriptData
(
)
.
gcThingsLength
;
auto
gcThingData
=
stencil
.
gcThingData
.
Subspan
(
offset
length
)
;
for
(
TaggedScriptThingIndex
index
:
mozilla
:
:
Reversed
(
gcThingData
)
)
{
if
(
!
index
.
isFunction
(
)
)
{
continue
;
}
ScriptIndex
innerScriptIndex
=
index
.
toFunction
(
)
;
ScriptStencilRef
innerScriptRef
{
stencil
innerScriptIndex
}
;
if
(
innerScriptRef
.
scriptData
(
)
.
isGhost
(
)
|
|
!
innerScriptRef
.
scriptData
(
)
.
functionFlags
.
isInterpreted
(
)
)
{
continue
;
}
if
(
innerScriptRef
.
scriptData
(
)
.
hasSharedData
(
)
)
{
if
(
!
add
(
cx
stencil
innerScriptIndex
)
)
{
return
false
;
}
continue
;
}
if
(
!
stack
.
append
(
innerScriptIndex
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
return
true
;
}
UniquePtr
<
DelazifyTask
>
DelazifyTask
:
:
Create
(
JSContext
*
cx
JSRuntime
*
runtime
const
JS
:
:
ContextOptions
&
contextOptions
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
frontend
:
:
CompilationStencil
&
stencil
)
{
OffThreadFrontendErrors
errors
;
AutoSetContextOffThreadFrontendErrors
recordErrors
(
&
errors
)
;
UniquePtr
<
DelazifyTask
>
task
;
task
.
reset
(
js_new
<
DelazifyTask
>
(
runtime
contextOptions
)
)
;
if
(
!
task
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
RefPtr
<
ScriptSource
>
source
(
stencil
.
source
)
;
StencilCache
&
cache
=
runtime
-
>
caches
(
)
.
delazificationCache
;
if
(
!
cache
.
startCaching
(
std
:
:
move
(
source
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
auto
initial
=
cx
-
>
make_unique
<
frontend
:
:
ExtensibleCompilationStencil
>
(
cx
options
stencil
.
source
)
;
if
(
!
initial
|
|
!
initial
-
>
cloneFrom
(
cx
stencil
)
)
{
return
nullptr
;
}
if
(
!
task
-
>
init
(
cx
options
std
:
:
move
(
initial
)
)
)
{
return
nullptr
;
}
task
-
>
errors_
=
std
:
:
move
(
errors
)
;
return
task
;
}
DelazifyTask
:
:
DelazifyTask
(
JSRuntime
*
runtime
const
JS
:
:
ContextOptions
&
options
)
:
runtime
(
runtime
)
contextOptions
(
options
)
merger
(
)
errors_
(
)
{
runtime
-
>
addParseTaskRef
(
)
;
}
bool
DelazifyTask
:
:
init
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
UniquePtr
<
frontend
:
:
ExtensibleCompilationStencil
>
&
&
initial
)
{
using
namespace
js
:
:
frontend
;
if
(
!
merger
.
setInitial
(
cx
std
:
:
move
(
initial
)
)
)
{
return
false
;
}
switch
(
options
.
eagerDelazificationStrategy
(
)
)
{
case
JS
:
:
DelazificationOption
:
:
OnDemandOnly
:
MOZ_CRASH
(
"
OnDemandOnly
should
not
create
a
DelazifyTask
.
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
CheckConcurrentWithOnDemand
:
case
JS
:
:
DelazificationOption
:
:
ConcurrentDepthFirst
:
strategy
=
cx
-
>
make_unique
<
DepthFirstDelazification
>
(
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
:
MOZ_CRASH
(
"
ParseEverythingEagerly
should
not
create
a
DelazifyTask
"
)
;
break
;
}
if
(
!
strategy
)
{
return
false
;
}
BorrowingCompilationStencil
borrow
(
merger
.
getResult
(
)
)
;
ScriptIndex
topLevel
{
0
}
;
return
strategy
-
>
add
(
cx
borrow
topLevel
)
;
}
size_t
DelazifyTask
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
mergerSize
=
merger
.
getResult
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
mergerSize
;
}
void
DelazifyTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
lock
)
{
{
AutoSetHelperThreadContext
usesContext
(
contextOptions
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
if
(
!
runTask
(
cx
)
)
{
strategy
-
>
clear
(
)
;
}
MOZ_ASSERT
(
cx
-
>
tempLifoAlloc
(
)
.
isEmpty
(
)
)
;
cx
-
>
tempLifoAlloc
(
)
.
freeAll
(
)
;
cx
-
>
frontendCollectionPool
(
)
.
purge
(
)
;
}
if
(
!
strategy
-
>
done
(
)
)
{
HelperThreadState
(
)
.
submitTask
(
this
lock
)
;
}
else
{
UniquePtr
<
FreeDelazifyTask
>
freeTask
(
js_new
<
FreeDelazifyTask
>
(
this
)
)
;
if
(
freeTask
)
{
HelperThreadState
(
)
.
submitTask
(
std
:
:
move
(
freeTask
)
lock
)
;
}
}
}
bool
DelazifyTask
:
:
runTask
(
JSContext
*
cx
)
{
AutoSetContextRuntime
ascr
(
runtime
)
;
AutoSetContextOffThreadFrontendErrors
recordErrors
(
&
this
-
>
errors_
)
;
gc
:
:
AutoSuppressNurseryCellAlloc
noNurseryAlloc
(
cx
)
;
using
namespace
js
:
:
frontend
;
while
(
!
strategy
-
>
done
(
)
|
|
isInterrupted
(
)
)
{
RefPtr
<
CompilationStencil
>
innerStencil
;
ScriptIndex
scriptIndex
=
strategy
-
>
next
(
)
;
{
BorrowingCompilationStencil
borrow
(
merger
.
getResult
(
)
)
;
ScriptStencilRef
scriptRef
{
borrow
scriptIndex
}
;
MOZ_ASSERT
(
!
scriptRef
.
scriptData
(
)
.
isGhost
(
)
)
;
MOZ_ASSERT
(
!
scriptRef
.
scriptData
(
)
.
hasSharedData
(
)
)
;
innerStencil
=
DelazifyCanonicalScriptedFunction
(
cx
borrow
scriptIndex
)
;
if
(
!
innerStencil
)
{
return
false
;
}
StencilCache
&
cache
=
runtime
-
>
caches
(
)
.
delazificationCache
;
StencilContext
key
(
borrow
.
source
scriptRef
.
scriptExtra
(
)
.
extent
)
;
if
(
auto
guard
=
cache
.
isSourceCached
(
borrow
.
source
)
)
{
if
(
!
cache
.
putNew
(
guard
key
innerStencil
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
else
{
strategy
-
>
clear
(
)
;
return
true
;
}
}
if
(
!
merger
.
addDelazification
(
cx
*
innerStencil
)
)
{
return
false
;
}
{
BorrowingCompilationStencil
borrow
(
merger
.
getResult
(
)
)
;
if
(
!
strategy
-
>
add
(
cx
borrow
scriptIndex
)
)
{
return
false
;
}
}
}
return
true
;
}
void
FreeDelazifyTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
{
{
AutoUnlockHelperThreadState
unlock
(
locked
)
;
js_delete
(
task
)
;
task
=
nullptr
;
}
js_delete
(
this
)
;
}
static
void
WaitForOffThreadParses
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
{
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
GlobalHelperThreadState
:
:
ParseTaskVector
&
worklist
=
HelperThreadState
(
)
.
parseWorklist
(
lock
)
;
while
(
true
)
{
bool
pending
=
false
;
for
(
const
auto
&
task
:
worklist
)
{
if
(
task
-
>
runtimeMatches
(
rt
)
)
{
pending
=
true
;
break
;
}
}
if
(
!
pending
)
{
bool
inProgress
=
false
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
ParseTask
>
(
)
&
&
helper
-
>
as
<
ParseTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
{
inProgress
=
true
;
break
;
}
}
if
(
!
inProgress
)
{
break
;
}
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
#
ifdef
DEBUG
for
(
const
auto
&
task
:
worklist
)
{
MOZ_ASSERT
(
!
task
-
>
runtimeMatches
(
rt
)
)
;
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
MOZ_ASSERT_IF
(
helper
-
>
is
<
ParseTask
>
(
)
!
helper
-
>
as
<
ParseTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
;
}
#
endif
}
void
js
:
:
CancelOffThreadParses
(
JSRuntime
*
rt
)
{
AutoLockHelperThreadState
lock
;
WaitForOffThreadParses
(
rt
lock
)
;
auto
&
finished
=
HelperThreadState
(
)
.
parseFinishedList
(
lock
)
;
while
(
true
)
{
bool
found
=
false
;
ParseTask
*
next
;
ParseTask
*
task
=
finished
.
getFirst
(
)
;
while
(
task
)
{
next
=
task
-
>
getNext
(
)
;
if
(
task
-
>
runtimeMatches
(
rt
)
)
{
found
=
true
;
task
-
>
remove
(
)
;
HelperThreadState
(
)
.
destroyParseTask
(
rt
task
)
;
}
task
=
next
;
}
if
(
!
found
)
{
break
;
}
}
#
ifdef
DEBUG
for
(
ParseTask
*
task
:
finished
)
{
MOZ_ASSERT
(
!
task
-
>
runtimeMatches
(
rt
)
)
;
}
#
endif
}
static
void
CancelPendingDelazifyTask
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
{
auto
&
delazifyList
=
HelperThreadState
(
)
.
delazifyWorklist
(
lock
)
;
auto
end
=
delazifyList
.
end
(
)
;
for
(
auto
iter
=
delazifyList
.
begin
(
)
;
iter
!
=
end
;
)
{
DelazifyTask
*
task
=
*
iter
;
+
+
iter
;
if
(
task
-
>
runtimeMatches
(
rt
)
)
{
task
-
>
removeFrom
(
delazifyList
)
;
js_delete
(
task
)
;
}
}
}
static
void
WaitUntilCancelledDelazifyTasks
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
{
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
while
(
true
)
{
CancelPendingDelazifyTask
(
rt
lock
)
;
bool
inProgress
=
false
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
DelazifyTask
>
(
)
&
&
helper
-
>
as
<
DelazifyTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
{
inProgress
=
true
;
break
;
}
}
if
(
!
inProgress
)
{
break
;
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
#
ifdef
DEBUG
for
(
DelazifyTask
*
task
:
HelperThreadState
(
)
.
delazifyWorklist
(
lock
)
)
{
MOZ_ASSERT
(
!
task
-
>
runtimeMatches
(
rt
)
)
;
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
MOZ_ASSERT_IF
(
helper
-
>
is
<
DelazifyTask
>
(
)
!
helper
-
>
as
<
DelazifyTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
;
}
#
endif
}
static
void
WaitUntilEmptyFreeDelazifyTaskVector
(
AutoLockHelperThreadState
&
lock
)
{
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
while
(
true
)
{
bool
inProgress
=
false
;
auto
&
freeList
=
HelperThreadState
(
)
.
freeDelazifyTaskVector
(
lock
)
;
if
(
!
freeList
.
empty
(
)
)
{
inProgress
=
true
;
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
FreeDelazifyTask
>
(
)
)
{
inProgress
=
true
;
break
;
}
}
if
(
!
inProgress
)
{
break
;
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
}
void
js
:
:
CancelOffThreadDelazify
(
JSRuntime
*
runtime
)
{
AutoLockHelperThreadState
lock
;
WaitUntilCancelledDelazifyTasks
(
runtime
lock
)
;
WaitUntilEmptyFreeDelazifyTaskVector
(
lock
)
;
}
static
bool
HasAnyDelazifyTask
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
{
auto
&
delazifyList
=
HelperThreadState
(
)
.
delazifyWorklist
(
lock
)
;
for
(
auto
task
:
delazifyList
)
{
if
(
task
-
>
runtimeMatches
(
rt
)
)
{
return
true
;
}
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
DelazifyTask
>
(
)
&
&
helper
-
>
as
<
DelazifyTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
{
return
true
;
}
}
return
false
;
}
void
js
:
:
WaitForAllDelazifyTasks
(
JSRuntime
*
rt
)
{
AutoLockHelperThreadState
lock
;
if
(
!
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
{
return
;
}
while
(
true
)
{
if
(
!
HasAnyDelazifyTask
(
rt
lock
)
)
{
break
;
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
}
static
bool
QueueOffThreadParseTask
(
JSContext
*
cx
UniquePtr
<
ParseTask
>
task
)
{
AutoLockHelperThreadState
lock
;
bool
result
=
HelperThreadState
(
)
.
submitTask
(
cx
-
>
runtime
(
)
std
:
:
move
(
task
)
lock
)
;
if
(
!
result
)
{
ReportOutOfMemory
(
cx
)
;
}
return
result
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
JSRuntime
*
rt
UniquePtr
<
ParseTask
>
task
const
AutoLockHelperThreadState
&
locked
)
{
if
(
!
parseWorklist
(
locked
)
.
append
(
std
:
:
move
(
task
)
)
)
{
return
false
;
}
parseWorklist
(
locked
)
.
back
(
)
-
>
activate
(
rt
)
;
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
void
GlobalHelperThreadState
:
:
submitTask
(
DelazifyTask
*
task
const
AutoLockHelperThreadState
&
locked
)
{
delazifyWorklist
(
locked
)
.
insertBack
(
task
)
;
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
UniquePtr
<
FreeDelazifyTask
>
task
const
AutoLockHelperThreadState
&
locked
)
{
if
(
!
freeDelazifyTaskVector
(
locked
)
.
append
(
std
:
:
move
(
task
)
)
)
{
return
false
;
}
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
static
JS
:
:
OffThreadToken
*
StartOffThreadParseTask
(
JSContext
*
cx
UniquePtr
<
ParseTask
>
task
const
ReadOnlyCompileOptions
&
options
)
{
gc
:
:
AutoSuppressGC
nogc
(
cx
)
;
if
(
!
task
-
>
init
(
cx
options
)
)
{
return
nullptr
;
}
JS
:
:
OffThreadToken
*
token
=
task
.
get
(
)
;
if
(
!
QueueOffThreadParseTask
(
cx
std
:
:
move
(
task
)
)
)
{
return
nullptr
;
}
return
token
;
}
template
<
typename
Unit
>
static
JS
:
:
OffThreadToken
*
StartOffThreadCompileToStencilInternal
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
auto
task
=
cx
-
>
make_unique
<
CompileToStencilTask
<
Unit
>
>
(
cx
srcBuf
callback
callbackData
)
;
if
(
!
task
)
{
return
nullptr
;
}
return
StartOffThreadParseTask
(
cx
std
:
:
move
(
task
)
options
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadCompileToStencil
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
return
StartOffThreadCompileToStencilInternal
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadCompileToStencil
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
return
StartOffThreadCompileToStencilInternal
(
cx
options
srcBuf
callback
callbackData
)
;
}
template
<
typename
Unit
>
static
JS
:
:
OffThreadToken
*
StartOffThreadCompileModuleToStencilInternal
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
auto
task
=
cx
-
>
make_unique
<
CompileModuleToStencilTask
<
Unit
>
>
(
cx
srcBuf
callback
callbackData
)
;
if
(
!
task
)
{
return
nullptr
;
}
return
StartOffThreadParseTask
(
cx
std
:
:
move
(
task
)
options
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadCompileModuleToStencil
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
return
StartOffThreadCompileModuleToStencilInternal
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadCompileModuleToStencil
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
return
StartOffThreadCompileModuleToStencilInternal
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadDecodeStencil
(
JSContext
*
cx
const
JS
:
:
DecodeOptions
&
options
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
auto
task
=
cx
-
>
make_unique
<
DecodeStencilTask
>
(
cx
range
callback
callbackData
)
;
if
(
!
task
)
{
return
nullptr
;
}
JS
:
:
CompileOptions
compileOptions
(
cx
)
;
options
.
copyTo
(
compileOptions
)
;
return
StartOffThreadParseTask
(
cx
std
:
:
move
(
task
)
compileOptions
)
;
}
JS
:
:
OffThreadToken
*
js
:
:
StartOffThreadDecodeMultiStencils
(
JSContext
*
cx
const
JS
:
:
DecodeOptions
&
options
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
{
auto
task
=
cx
-
>
make_unique
<
MultiStencilsDecodeTask
>
(
cx
sources
callback
callbackData
)
;
if
(
!
task
)
{
return
nullptr
;
}
JS
:
:
CompileOptions
compileOptions
(
cx
)
;
options
.
copyTo
(
compileOptions
)
;
return
StartOffThreadParseTask
(
cx
std
:
:
move
(
task
)
compileOptions
)
;
}
bool
js
:
:
CurrentThreadIsParseThread
(
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
return
cx
&
&
cx
-
>
isHelperThreadContext
(
)
&
&
cx
-
>
offThreadFrontendErrors
(
)
;
}
bool
GlobalHelperThreadState
:
:
ensureInitialized
(
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
MOZ_ASSERT
(
this
=
=
&
HelperThreadState
(
)
)
;
AutoLockHelperThreadState
lock
;
if
(
isInitialized
(
lock
)
)
{
return
true
;
}
for
(
size_t
&
i
:
runningTaskCount
)
{
i
=
0
;
}
useInternalThreadPool_
=
!
dispatchTaskCallback
;
if
(
useInternalThreadPool
(
lock
)
)
{
if
(
!
InternalThreadPool
:
:
Initialize
(
threadCount
lock
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
dispatchTaskCallback
)
;
if
(
!
ensureThreadCount
(
threadCount
lock
)
)
{
finishThreads
(
lock
)
;
return
false
;
}
MOZ_ASSERT
(
threadCount
!
=
0
)
;
isInitialized_
=
true
;
return
true
;
}
bool
GlobalHelperThreadState
:
:
ensureThreadCount
(
size_t
count
AutoLockHelperThreadState
&
lock
)
{
if
(
!
helperTasks_
.
reserve
(
count
)
)
{
return
false
;
}
if
(
useInternalThreadPool
(
lock
)
)
{
InternalThreadPool
&
pool
=
InternalThreadPool
:
:
Get
(
)
;
if
(
pool
.
threadCount
(
lock
)
<
count
)
{
if
(
!
pool
.
ensureThreadCount
(
count
lock
)
)
{
return
false
;
}
threadCount
=
pool
.
threadCount
(
lock
)
;
}
}
return
true
;
}
GlobalHelperThreadState
:
:
GlobalHelperThreadState
(
)
:
cpuCount
(
0
)
threadCount
(
0
)
totalCountRunningTasks
(
0
)
registerThread
(
nullptr
)
unregisterThread
(
nullptr
)
wasmTier2GeneratorsFinished_
(
0
)
{
MOZ_ASSERT
(
!
gHelperThreadState
)
;
cpuCount
=
ClampDefaultCPUCount
(
GetCPUCount
(
)
)
;
threadCount
=
ThreadCountForCPUCount
(
cpuCount
)
;
gcParallelThreadCount
=
threadCount
;
MOZ_ASSERT
(
cpuCount
>
0
"
GetCPUCount
(
)
seems
broken
"
)
;
}
void
GlobalHelperThreadState
:
:
finish
(
AutoLockHelperThreadState
&
lock
)
{
if
(
!
isInitialized
(
lock
)
)
{
return
;
}
finishThreads
(
lock
)
;
auto
&
freeList
=
ionFreeList
(
lock
)
;
while
(
!
freeList
.
empty
(
)
)
{
UniquePtr
<
jit
:
:
IonFreeTask
>
task
=
std
:
:
move
(
freeList
.
back
(
)
)
;
freeList
.
popBack
(
)
;
jit
:
:
FreeIonCompileTask
(
task
-
>
compileTask
(
)
)
;
}
destroyHelperContexts
(
lock
)
;
}
void
GlobalHelperThreadState
:
:
finishThreads
(
AutoLockHelperThreadState
&
lock
)
{
waitForAllTasksLocked
(
lock
)
;
terminating_
=
true
;
if
(
InternalThreadPool
:
:
IsInitialized
(
)
)
{
InternalThreadPool
:
:
ShutDown
(
lock
)
;
}
}
JSContext
*
GlobalHelperThreadState
:
:
getFirstUnusedContext
(
AutoLockHelperThreadState
&
locked
)
{
for
(
auto
&
cx
:
helperContexts_
)
{
if
(
cx
-
>
contextAvailable
(
locked
)
)
{
return
cx
;
}
}
MOZ_ASSERT
(
helperContexts_
.
length
(
)
<
threadCount
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
auto
cx
=
js
:
:
MakeUnique
<
JSContext
>
(
nullptr
JS
:
:
ContextOptions
(
)
)
;
if
(
!
cx
|
|
!
cx
-
>
init
(
ContextKind
:
:
HelperThread
)
|
|
!
helperContexts_
.
append
(
cx
.
get
(
)
)
)
{
oomUnsafe
.
crash
(
"
GlobalHelperThreadState
:
:
getFirstUnusedContext
"
)
;
}
return
cx
.
release
(
)
;
}
void
GlobalHelperThreadState
:
:
destroyHelperContexts
(
AutoLockHelperThreadState
&
lock
)
{
while
(
helperContexts_
.
length
(
)
>
0
)
{
js_delete
(
helperContexts_
.
popCopy
(
)
)
;
}
}
#
ifdef
DEBUG
void
GlobalHelperThreadState
:
:
assertIsLockedByCurrentThread
(
)
const
{
gHelperThreadLock
.
assertOwnedByCurrentThread
(
)
;
}
#
endif
void
GlobalHelperThreadState
:
:
dispatch
(
DispatchReason
reason
const
AutoLockHelperThreadState
&
locked
)
{
if
(
canStartTasks
(
locked
)
&
&
tasksPending_
<
threadCount
)
{
tasksPending_
+
+
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
dispatchTaskCallback
(
reason
)
;
}
}
void
GlobalHelperThreadState
:
:
wait
(
AutoLockHelperThreadState
&
locked
TimeDuration
timeout
)
{
consumerWakeup
.
wait_for
(
locked
timeout
)
;
}
void
GlobalHelperThreadState
:
:
notifyAll
(
const
AutoLockHelperThreadState
&
)
{
consumerWakeup
.
notify_all
(
)
;
}
void
GlobalHelperThreadState
:
:
notifyOne
(
const
AutoLockHelperThreadState
&
)
{
consumerWakeup
.
notify_one
(
)
;
}
bool
GlobalHelperThreadState
:
:
hasActiveThreads
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
helperTasks
(
lock
)
.
empty
(
)
;
}
void
js
:
:
WaitForAllHelperThreads
(
)
{
HelperThreadState
(
)
.
waitForAllTasks
(
)
;
}
void
js
:
:
WaitForAllHelperThreads
(
AutoLockHelperThreadState
&
lock
)
{
HelperThreadState
(
)
.
waitForAllTasksLocked
(
lock
)
;
}
void
GlobalHelperThreadState
:
:
waitForAllTasks
(
)
{
AutoLockHelperThreadState
lock
;
waitForAllTasksLocked
(
lock
)
;
}
void
GlobalHelperThreadState
:
:
waitForAllTasksLocked
(
AutoLockHelperThreadState
&
lock
)
{
CancelOffThreadWasmTier2GeneratorLocked
(
lock
)
;
while
(
canStartTasks
(
lock
)
|
|
tasksPending_
|
|
hasActiveThreads
(
lock
)
)
{
wait
(
lock
)
;
}
MOZ_ASSERT
(
gcParallelWorklist
(
lock
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
ionWorklist
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
wasmWorklist
(
lock
wasm
:
:
CompileMode
:
:
Tier1
)
.
empty
(
)
)
;
MOZ_ASSERT
(
promiseHelperTasks
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
parseWorklist
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
compressionWorklist
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
ionFreeList
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
wasmWorklist
(
lock
wasm
:
:
CompileMode
:
:
Tier2
)
.
empty
(
)
)
;
MOZ_ASSERT
(
wasmTier2GeneratorWorklist
(
lock
)
.
empty
(
)
)
;
MOZ_ASSERT
(
!
tasksPending_
)
;
MOZ_ASSERT
(
!
hasActiveThreads
(
lock
)
)
;
}
bool
GlobalHelperThreadState
:
:
checkTaskThreadLimit
(
ThreadType
threadType
size_t
maxThreads
bool
isMaster
const
AutoLockHelperThreadState
&
lock
)
const
{
MOZ_ASSERT
(
maxThreads
>
0
)
;
if
(
!
isMaster
&
&
maxThreads
>
=
threadCount
)
{
return
true
;
}
size_t
count
=
runningTaskCount
[
threadType
]
;
if
(
count
>
=
maxThreads
)
{
return
false
;
}
MOZ_ASSERT
(
threadCount
>
=
totalCountRunningTasks
)
;
size_t
idle
=
threadCount
-
totalCountRunningTasks
;
if
(
idle
=
=
0
)
{
return
false
;
}
if
(
isMaster
&
&
idle
=
=
1
)
{
return
false
;
}
return
true
;
}
void
GlobalHelperThreadState
:
:
triggerFreeUnusedMemory
(
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
return
;
}
AutoLockHelperThreadState
lock
;
for
(
auto
&
context
:
helperContexts_
)
{
if
(
context
-
>
shouldFreeUnusedMemory
(
)
&
&
context
-
>
contextAvailable
(
lock
)
)
{
context
-
>
tempLifoAllocNoCheck
(
)
.
freeAll
(
)
;
context
-
>
setFreeUnusedMemory
(
false
)
;
}
else
{
context
-
>
setFreeUnusedMemory
(
true
)
;
}
}
}
static
inline
bool
IsHelperThreadSimulatingOOM
(
js
:
:
ThreadType
threadType
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
return
js
:
:
oom
:
:
simulator
.
targetThread
(
)
=
=
threadType
;
#
else
return
false
;
#
endif
}
void
GlobalHelperThreadState
:
:
addSizeOfIncludingThis
(
JS
:
:
GlobalStats
*
stats
AutoLockHelperThreadState
&
lock
)
const
{
#
ifdef
DEBUG
assertIsLockedByCurrentThread
(
)
;
#
endif
mozilla
:
:
MallocSizeOf
mallocSizeOf
=
stats
-
>
mallocSizeOf_
;
JS
:
:
HelperThreadStats
&
htStats
=
stats
-
>
helperThread
;
htStats
.
stateData
+
=
mallocSizeOf
(
this
)
;
if
(
InternalThreadPool
:
:
IsInitialized
(
)
)
{
htStats
.
stateData
+
=
InternalThreadPool
:
:
Get
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
lock
)
;
}
htStats
.
stateData
+
=
ionWorklist_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
ionFinishedList_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
ionFreeList_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
wasmWorklist_tier1_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
wasmWorklist_tier2_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
wasmTier2GeneratorWorklist_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
promiseHelperTasks_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
parseWorklist_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
parseFinishedList_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
compressionPendingList_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
compressionWorklist_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
compressionFinishedList_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
gcParallelWorklist_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
helperContexts_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
helperTasks_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
const
auto
&
task
:
parseWorklist_
)
{
htStats
.
parseTask
+
=
task
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
for
(
auto
task
:
parseFinishedList_
)
{
htStats
.
parseTask
+
=
task
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
for
(
auto
task
:
ionWorklist_
)
{
htStats
.
ionCompileTask
+
=
task
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
for
(
auto
task
:
ionFinishedList_
)
{
htStats
.
ionCompileTask
+
=
task
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
for
(
const
auto
&
task
:
ionFreeList_
)
{
htStats
.
ionCompileTask
+
=
task
-
>
compileTask
(
)
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
for
(
auto
task
:
wasmWorklist_tier1_
)
{
htStats
.
wasmCompile
+
=
task
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
for
(
auto
task
:
wasmWorklist_tier2_
)
{
htStats
.
wasmCompile
+
=
task
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
{
AutoNoteSingleThreadedRegion
anstr
;
for
(
auto
*
cx
:
helperContexts_
)
{
htStats
.
contexts
+
=
cx
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
MOZ_ASSERT
(
htStats
.
idleThreadCount
=
=
0
)
;
MOZ_ASSERT
(
threadCount
>
=
totalCountRunningTasks
)
;
htStats
.
activeThreadCount
=
totalCountRunningTasks
;
htStats
.
idleThreadCount
=
threadCount
-
totalCountRunningTasks
;
}
size_t
GlobalHelperThreadState
:
:
maxIonCompilationThreads
(
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_ION
)
)
{
return
1
;
}
return
threadCount
;
}
size_t
GlobalHelperThreadState
:
:
maxWasmCompilationThreads
(
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_WASM_COMPILE_TIER1
)
|
|
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_WASM_COMPILE_TIER2
)
)
{
return
1
;
}
return
std
:
:
min
(
cpuCount
threadCount
)
;
}
size_t
GlobalHelperThreadState
:
:
maxWasmTier2GeneratorThreads
(
)
const
{
return
MaxTier2GeneratorTasks
;
}
size_t
GlobalHelperThreadState
:
:
maxPromiseHelperThreads
(
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_WASM_COMPILE_TIER1
)
|
|
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_WASM_COMPILE_TIER2
)
)
{
return
1
;
}
return
std
:
:
min
(
cpuCount
threadCount
)
;
}
size_t
GlobalHelperThreadState
:
:
maxParseThreads
(
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_PARSE
)
)
{
return
1
;
}
return
std
:
:
min
(
cpuCount
threadCount
)
;
}
size_t
GlobalHelperThreadState
:
:
maxCompressionThreads
(
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_COMPRESS
)
)
{
return
1
;
}
return
1
;
}
size_t
GlobalHelperThreadState
:
:
maxGCParallelThreads
(
const
AutoLockHelperThreadState
&
lock
)
const
{
if
(
IsHelperThreadSimulatingOOM
(
js
:
:
THREAD_TYPE_GCPARALLEL
)
)
{
return
1
;
}
return
gcParallelThreadCount
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetWasmTier1CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
maybeGetWasmCompile
(
lock
wasm
:
:
CompileMode
:
:
Tier1
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetWasmTier2CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
maybeGetWasmCompile
(
lock
wasm
:
:
CompileMode
:
:
Tier2
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetWasmCompile
(
const
AutoLockHelperThreadState
&
lock
wasm
:
:
CompileMode
mode
)
{
if
(
!
canStartWasmCompile
(
lock
mode
)
)
{
return
nullptr
;
}
return
wasmWorklist
(
lock
mode
)
.
popCopyFront
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartWasmTier1CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
canStartWasmCompile
(
lock
wasm
:
:
CompileMode
:
:
Tier1
)
;
}
bool
GlobalHelperThreadState
:
:
canStartWasmTier2CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
canStartWasmCompile
(
lock
wasm
:
:
CompileMode
:
:
Tier2
)
;
}
bool
GlobalHelperThreadState
:
:
canStartWasmCompile
(
const
AutoLockHelperThreadState
&
lock
wasm
:
:
CompileMode
mode
)
{
if
(
wasmWorklist
(
lock
mode
)
.
empty
(
)
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
cpuCount
>
1
)
;
bool
tier2oversubscribed
=
wasmTier2GeneratorWorklist
(
lock
)
.
length
(
)
>
20
;
size_t
physCoresAvailable
=
size_t
(
ceil
(
cpuCount
/
3
.
0
)
)
;
size_t
threads
;
ThreadType
threadType
;
if
(
mode
=
=
wasm
:
:
CompileMode
:
:
Tier2
)
{
if
(
tier2oversubscribed
)
{
threads
=
maxWasmCompilationThreads
(
)
;
}
else
{
threads
=
physCoresAvailable
;
}
threadType
=
THREAD_TYPE_WASM_COMPILE_TIER2
;
}
else
{
if
(
tier2oversubscribed
)
{
threads
=
0
;
}
else
{
threads
=
maxWasmCompilationThreads
(
)
;
}
threadType
=
THREAD_TYPE_WASM_COMPILE_TIER1
;
}
return
threads
!
=
0
&
&
checkTaskThreadLimit
(
threadType
threads
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetWasmTier2GeneratorTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartWasmTier2GeneratorTask
(
lock
)
)
{
return
nullptr
;
}
return
wasmTier2GeneratorWorklist
(
lock
)
.
popCopy
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartWasmTier2GeneratorTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
wasmTier2GeneratorWorklist
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_WASM_GENERATOR_TIER2
maxWasmTier2GeneratorThreads
(
)
true
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetPromiseHelperTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartPromiseHelperTask
(
lock
)
)
{
return
nullptr
;
}
return
promiseHelperTasks
(
lock
)
.
popCopy
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartPromiseHelperTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
promiseHelperTasks
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_PROMISE_TASK
maxPromiseHelperThreads
(
)
true
lock
)
;
}
static
bool
IonCompileTaskHasHigherPriority
(
jit
:
:
IonCompileTask
*
first
jit
:
:
IonCompileTask
*
second
)
{
jit
:
:
JitScript
*
firstJitScript
=
first
-
>
script
(
)
-
>
jitScript
(
)
;
jit
:
:
JitScript
*
secondJitScript
=
second
-
>
script
(
)
-
>
jitScript
(
)
;
return
firstJitScript
-
>
warmUpCount
(
)
/
first
-
>
script
(
)
-
>
length
(
)
>
secondJitScript
-
>
warmUpCount
(
)
/
second
-
>
script
(
)
-
>
length
(
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartIonCompileTask
(
lock
)
)
{
return
nullptr
;
}
return
highestPriorityPendingIonCompile
(
lock
true
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetLowPrioIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartIonCompileTask
(
lock
)
)
{
return
nullptr
;
}
return
highestPriorityPendingIonCompile
(
lock
false
)
;
}
bool
GlobalHelperThreadState
:
:
canStartIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
ionWorklist
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_ION
maxIonCompilationThreads
(
)
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetIonFreeTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartIonFreeTask
(
lock
)
)
{
return
nullptr
;
}
UniquePtr
<
jit
:
:
IonFreeTask
>
task
=
std
:
:
move
(
ionFreeList
(
lock
)
.
back
(
)
)
;
ionFreeList
(
lock
)
.
popBack
(
)
;
return
task
.
release
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartIonFreeTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
ionFreeList
(
lock
)
.
empty
(
)
;
}
jit
:
:
IonCompileTask
*
GlobalHelperThreadState
:
:
highestPriorityPendingIonCompile
(
const
AutoLockHelperThreadState
&
lock
bool
checkExecutionStatus
)
{
auto
&
worklist
=
ionWorklist
(
lock
)
;
MOZ_ASSERT
(
!
worklist
.
empty
(
)
)
;
size_t
index
=
worklist
.
length
(
)
;
for
(
size_t
i
=
0
;
i
<
worklist
.
length
(
)
;
i
+
+
)
{
if
(
checkExecutionStatus
&
&
!
worklist
[
i
]
-
>
isMainThreadRunningJS
(
)
)
{
continue
;
}
if
(
i
<
index
|
|
IonCompileTaskHasHigherPriority
(
worklist
[
i
]
worklist
[
index
]
)
)
{
index
=
i
;
}
}
if
(
index
=
=
worklist
.
length
(
)
)
{
return
nullptr
;
}
jit
:
:
IonCompileTask
*
task
=
worklist
[
index
]
;
worklist
.
erase
(
&
worklist
[
index
]
)
;
return
task
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetParseTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartParseTask
(
lock
)
)
{
return
nullptr
;
}
auto
&
worklist
=
parseWorklist
(
lock
)
;
UniquePtr
<
ParseTask
>
task
=
std
:
:
move
(
worklist
.
back
(
)
)
;
worklist
.
popBack
(
)
;
return
task
.
release
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartParseTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
parseWorklist
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_PARSE
maxParseThreads
(
)
true
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetFreeDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
{
auto
&
freeList
=
freeDelazifyTaskVector
(
lock
)
;
if
(
!
freeList
.
empty
(
)
)
{
UniquePtr
<
FreeDelazifyTask
>
task
=
std
:
:
move
(
freeList
.
back
(
)
)
;
freeList
.
popBack
(
)
;
return
task
.
release
(
)
;
}
return
nullptr
;
}
bool
GlobalHelperThreadState
:
:
canStartFreeDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
freeDelazifyTaskVector
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_DELAZIFY_FREE
maxParseThreads
(
)
true
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
{
auto
&
worklist
=
delazifyWorklist
(
lock
)
;
if
(
worklist
.
isEmpty
(
)
)
{
return
nullptr
;
}
return
worklist
.
popFirst
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
delazifyWorklist
(
lock
)
.
isEmpty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_DELAZIFY
maxParseThreads
(
)
true
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetCompressionTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartCompressionTask
(
lock
)
)
{
return
nullptr
;
}
auto
&
worklist
=
compressionWorklist
(
lock
)
;
UniquePtr
<
SourceCompressionTask
>
task
=
std
:
:
move
(
worklist
.
back
(
)
)
;
worklist
.
popBack
(
)
;
return
task
.
release
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartCompressionTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
compressionWorklist
(
lock
)
.
empty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_COMPRESS
maxCompressionThreads
(
)
lock
)
;
}
void
GlobalHelperThreadState
:
:
startHandlingCompressionTasks
(
ScheduleCompressionTask
schedule
JSRuntime
*
maybeRuntime
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
(
schedule
=
=
ScheduleCompressionTask
:
:
GC
)
=
=
(
maybeRuntime
!
=
nullptr
)
)
;
auto
&
pending
=
compressionPendingList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
pending
.
length
(
)
;
i
+
+
)
{
UniquePtr
<
SourceCompressionTask
>
&
task
=
pending
[
i
]
;
if
(
schedule
=
=
ScheduleCompressionTask
:
:
API
|
|
(
task
-
>
runtimeMatches
(
maybeRuntime
)
&
&
task
-
>
shouldStart
(
)
)
)
{
(
void
)
submitTask
(
std
:
:
move
(
task
)
lock
)
;
remove
(
pending
&
i
)
;
}
}
}
bool
GlobalHelperThreadState
:
:
submitTask
(
UniquePtr
<
SourceCompressionTask
>
task
const
AutoLockHelperThreadState
&
locked
)
{
if
(
!
compressionWorklist
(
locked
)
.
append
(
std
:
:
move
(
task
)
)
)
{
return
false
;
}
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
GCParallelTask
*
task
const
AutoLockHelperThreadState
&
locked
)
{
gcParallelWorklist
(
locked
)
.
insertBack
(
task
)
;
dispatch
(
DispatchReason
:
:
NewTask
locked
)
;
return
true
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
maybeGetGCParallelTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
canStartGCParallelTask
(
lock
)
)
{
return
nullptr
;
}
return
gcParallelWorklist
(
lock
)
.
popFirst
(
)
;
}
bool
GlobalHelperThreadState
:
:
canStartGCParallelTask
(
const
AutoLockHelperThreadState
&
lock
)
{
return
!
gcParallelWorklist
(
lock
)
.
isEmpty
(
)
&
&
checkTaskThreadLimit
(
THREAD_TYPE_GCPARALLEL
maxGCParallelThreads
(
lock
)
lock
)
;
}
ParseTask
*
GlobalHelperThreadState
:
:
removeFinishedParseTask
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
{
auto
task
=
static_cast
<
ParseTask
*
>
(
token
)
;
MOZ_RELEASE_ASSERT
(
task
-
>
runtime
=
=
cx
-
>
runtime
(
)
)
;
MOZ_RELEASE_ASSERT
(
task
-
>
kind
=
=
kind
)
;
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
parseFinishedList
(
lock
)
.
contains
(
task
)
)
;
task
-
>
remove
(
)
;
return
task
;
}
UniquePtr
<
ParseTask
>
GlobalHelperThreadState
:
:
finishParseTaskCommon
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
)
;
Rooted
<
UniquePtr
<
ParseTask
>
>
parseTask
(
cx
removeFinishedParseTask
(
cx
kind
token
)
)
;
if
(
parseTask
-
>
errors
.
outOfMemory
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
for
(
UniquePtr
<
CompileError
>
&
error
:
parseTask
-
>
errors
.
errors
)
{
error
-
>
throwError
(
cx
)
;
}
if
(
parseTask
-
>
errors
.
overRecursed
)
{
ReportOverRecursed
(
cx
)
;
}
if
(
cx
-
>
isExceptionPending
(
)
)
{
return
nullptr
;
}
return
std
:
:
move
(
parseTask
.
get
(
)
)
;
}
already_AddRefed
<
frontend
:
:
CompilationStencil
>
GlobalHelperThreadState
:
:
finishCompileToStencilTask
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
Rooted
<
UniquePtr
<
ParseTask
>
>
parseTask
(
cx
finishParseTaskCommon
(
cx
kind
token
)
)
;
if
(
!
parseTask
)
{
return
nullptr
;
}
MOZ_ASSERT
(
parseTask
-
>
stencilInput_
.
get
(
)
)
;
MOZ_ASSERT
(
parseTask
-
>
stencil_
.
get
(
)
)
;
if
(
storage
)
{
MOZ_ASSERT
(
parseTask
-
>
options
.
allocateInstantiationStorage
)
;
parseTask
-
>
moveGCOutputInto
(
*
storage
)
;
}
return
parseTask
-
>
stencil_
.
forget
(
)
;
}
bool
GlobalHelperThreadState
:
:
finishMultiParseTask
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
mozilla
:
:
Vector
<
RefPtr
<
JS
:
:
Stencil
>
>
*
stencils
)
{
MOZ_ASSERT
(
stencils
)
;
Rooted
<
UniquePtr
<
ParseTask
>
>
parseTask
(
cx
finishParseTaskCommon
(
cx
kind
token
)
)
;
if
(
!
parseTask
)
{
return
false
;
}
MOZ_ASSERT
(
parseTask
-
>
kind
=
=
ParseTaskKind
:
:
MultiStencilsDecode
)
;
auto
task
=
static_cast
<
MultiStencilsDecodeTask
*
>
(
parseTask
.
get
(
)
.
get
(
)
)
;
size_t
expectedLength
=
task
-
>
sources
-
>
length
(
)
;
if
(
!
stencils
-
>
reserve
(
parseTask
-
>
stencils
.
length
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
auto
&
stencil
:
parseTask
-
>
stencils
)
{
stencils
-
>
infallibleEmplaceBack
(
stencil
.
forget
(
)
)
;
}
if
(
stencils
-
>
length
(
)
!
=
expectedLength
)
{
MOZ_ASSERT
(
false
"
Expected
more
stencils
"
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
already_AddRefed
<
frontend
:
:
CompilationStencil
>
GlobalHelperThreadState
:
:
finishCompileToStencilTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
return
finishCompileToStencilTask
(
cx
ParseTaskKind
:
:
ScriptStencil
token
storage
)
;
}
already_AddRefed
<
frontend
:
:
CompilationStencil
>
GlobalHelperThreadState
:
:
finishCompileModuleToStencilTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
return
finishCompileToStencilTask
(
cx
ParseTaskKind
:
:
ModuleStencil
token
storage
)
;
}
already_AddRefed
<
frontend
:
:
CompilationStencil
>
GlobalHelperThreadState
:
:
finishDecodeStencilTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
Rooted
<
UniquePtr
<
ParseTask
>
>
parseTask
(
cx
finishParseTaskCommon
(
cx
ParseTaskKind
:
:
StencilDecode
token
)
)
;
if
(
!
parseTask
)
{
return
nullptr
;
}
MOZ_ASSERT
(
parseTask
-
>
stencil_
.
get
(
)
)
;
if
(
storage
)
{
MOZ_ASSERT
(
parseTask
-
>
options
.
allocateInstantiationStorage
)
;
parseTask
-
>
moveGCOutputInto
(
*
storage
)
;
}
return
parseTask
-
>
stencil_
.
forget
(
)
;
}
bool
GlobalHelperThreadState
:
:
finishMultiStencilsDecodeTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
mozilla
:
:
Vector
<
RefPtr
<
JS
:
:
Stencil
>
>
*
stencils
)
{
return
finishMultiParseTask
(
cx
ParseTaskKind
:
:
MultiStencilsDecode
token
stencils
)
;
}
void
GlobalHelperThreadState
:
:
cancelParseTask
(
JSRuntime
*
rt
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
token
)
;
ParseTask
*
task
=
static_cast
<
ParseTask
*
>
(
token
)
;
GlobalHelperThreadState
:
:
ParseTaskVector
&
worklist
=
HelperThreadState
(
)
.
parseWorklist
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
worklist
.
length
(
)
;
i
+
+
)
{
if
(
task
=
=
worklist
[
i
]
)
{
MOZ_ASSERT
(
task
-
>
kind
=
=
kind
)
;
MOZ_ASSERT
(
task
-
>
runtimeMatches
(
rt
)
)
;
task
-
>
deactivate
(
rt
)
;
HelperThreadState
(
)
.
remove
(
worklist
&
i
)
;
return
;
}
}
while
(
true
)
{
bool
foundTask
=
false
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
ParseTask
>
(
)
&
&
helper
-
>
as
<
ParseTask
>
(
)
=
=
task
)
{
MOZ_ASSERT
(
helper
-
>
as
<
ParseTask
>
(
)
-
>
kind
=
=
kind
)
;
MOZ_ASSERT
(
helper
-
>
as
<
ParseTask
>
(
)
-
>
runtimeMatches
(
rt
)
)
;
foundTask
=
true
;
break
;
}
}
if
(
!
foundTask
)
{
break
;
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
auto
&
finished
=
HelperThreadState
(
)
.
parseFinishedList
(
lock
)
;
for
(
auto
*
t
:
finished
)
{
if
(
task
=
=
t
)
{
MOZ_ASSERT
(
task
-
>
kind
=
=
kind
)
;
MOZ_ASSERT
(
task
-
>
runtimeMatches
(
rt
)
)
;
task
-
>
remove
(
)
;
HelperThreadState
(
)
.
destroyParseTask
(
rt
task
)
;
return
;
}
}
}
void
GlobalHelperThreadState
:
:
destroyParseTask
(
JSRuntime
*
rt
ParseTask
*
parseTask
)
{
MOZ_ASSERT
(
!
parseTask
-
>
isInList
(
)
)
;
parseTask
-
>
deactivate
(
rt
)
;
js_delete
(
parseTask
)
;
}
bool
JSContext
:
:
addPendingCompileError
(
js
:
:
CompileError
*
*
error
)
{
auto
errorPtr
=
make_unique
<
js
:
:
CompileError
>
(
)
;
if
(
!
errorPtr
)
{
return
false
;
}
if
(
!
errors_
-
>
errors
.
append
(
std
:
:
move
(
errorPtr
)
)
)
{
ReportOutOfMemory
(
this
)
;
return
false
;
}
*
error
=
errors_
-
>
errors
.
back
(
)
.
get
(
)
;
return
true
;
}
bool
JSContext
:
:
isCompileErrorPending
(
)
const
{
return
errors_
-
>
errors
.
length
(
)
>
0
;
}
void
JSContext
:
:
addPendingOverRecursed
(
)
{
if
(
errors_
)
{
errors_
-
>
overRecursed
=
true
;
}
}
void
JSContext
:
:
addPendingOutOfMemory
(
)
{
if
(
errors_
)
{
errors_
-
>
outOfMemory
=
true
;
}
}
bool
js
:
:
EnqueueOffThreadCompression
(
JSContext
*
cx
UniquePtr
<
SourceCompressionTask
>
task
)
{
MOZ_ASSERT
(
cx
-
>
isMainThreadContext
(
)
)
;
AutoLockHelperThreadState
lock
;
auto
&
pending
=
HelperThreadState
(
)
.
compressionPendingList
(
lock
)
;
if
(
!
pending
.
append
(
std
:
:
move
(
task
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
js
:
:
StartHandlingCompressionsOnGC
(
JSRuntime
*
runtime
)
{
AutoLockHelperThreadState
lock
;
HelperThreadState
(
)
.
startHandlingCompressionTasks
(
GlobalHelperThreadState
:
:
ScheduleCompressionTask
:
:
GC
runtime
lock
)
;
}
template
<
typename
T
>
static
void
ClearCompressionTaskList
(
T
&
list
JSRuntime
*
runtime
)
{
for
(
size_t
i
=
0
;
i
<
list
.
length
(
)
;
i
+
+
)
{
if
(
list
[
i
]
-
>
runtimeMatches
(
runtime
)
)
{
HelperThreadState
(
)
.
remove
(
list
&
i
)
;
}
}
}
void
js
:
:
CancelOffThreadCompressions
(
JSRuntime
*
runtime
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
return
;
}
AutoLockHelperThreadState
lock
;
ClearCompressionTaskList
(
HelperThreadState
(
)
.
compressionPendingList
(
lock
)
runtime
)
;
ClearCompressionTaskList
(
HelperThreadState
(
)
.
compressionWorklist
(
lock
)
runtime
)
;
while
(
true
)
{
bool
inProgress
=
false
;
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
!
helper
-
>
is
<
SourceCompressionTask
>
(
)
)
{
continue
;
}
if
(
helper
-
>
as
<
SourceCompressionTask
>
(
)
-
>
runtimeMatches
(
runtime
)
)
{
inProgress
=
true
;
}
}
if
(
!
inProgress
)
{
break
;
}
HelperThreadState
(
)
.
wait
(
lock
)
;
}
ClearCompressionTaskList
(
HelperThreadState
(
)
.
compressionFinishedList
(
lock
)
runtime
)
;
}
void
js
:
:
AttachFinishedCompressions
(
JSRuntime
*
runtime
AutoLockHelperThreadState
&
lock
)
{
auto
&
finished
=
HelperThreadState
(
)
.
compressionFinishedList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
finished
.
length
(
)
;
i
+
+
)
{
if
(
finished
[
i
]
-
>
runtimeMatches
(
runtime
)
)
{
UniquePtr
<
SourceCompressionTask
>
compressionTask
(
std
:
:
move
(
finished
[
i
]
)
)
;
HelperThreadState
(
)
.
remove
(
finished
&
i
)
;
compressionTask
-
>
complete
(
)
;
}
}
}
void
js
:
:
SweepPendingCompressions
(
AutoLockHelperThreadState
&
lock
)
{
auto
&
pending
=
HelperThreadState
(
)
.
compressionPendingList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
pending
.
length
(
)
;
i
+
+
)
{
if
(
pending
[
i
]
-
>
shouldCancel
(
)
)
{
HelperThreadState
(
)
.
remove
(
pending
&
i
)
;
}
}
}
void
js
:
:
RunPendingSourceCompressions
(
JSRuntime
*
runtime
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
return
;
}
AutoLockHelperThreadState
lock
;
HelperThreadState
(
)
.
startHandlingCompressionTasks
(
GlobalHelperThreadState
:
:
ScheduleCompressionTask
:
:
API
nullptr
lock
)
;
while
(
!
HelperThreadState
(
)
.
compressionWorklist
(
lock
)
.
empty
(
)
)
{
HelperThreadState
(
)
.
wait
(
lock
)
;
}
HelperThreadState
(
)
.
waitForAllTasksLocked
(
lock
)
;
AttachFinishedCompressions
(
runtime
lock
)
;
}
void
PromiseHelperTask
:
:
executeAndResolveAndDestroy
(
JSContext
*
cx
)
{
execute
(
)
;
run
(
cx
JS
:
:
Dispatchable
:
:
NotShuttingDown
)
;
}
void
PromiseHelperTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
lock
)
{
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
execute
(
)
;
}
dispatchResolveAndDestroy
(
lock
)
;
}
bool
js
:
:
StartOffThreadPromiseHelperTask
(
JSContext
*
cx
UniquePtr
<
PromiseHelperTask
>
task
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
task
.
release
(
)
-
>
executeAndResolveAndDestroy
(
cx
)
;
return
true
;
}
if
(
!
HelperThreadState
(
)
.
submitTask
(
task
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
(
void
)
task
.
release
(
)
;
return
true
;
}
bool
js
:
:
StartOffThreadPromiseHelperTask
(
PromiseHelperTask
*
task
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
return
HelperThreadState
(
)
.
submitTask
(
task
)
;
}
bool
GlobalHelperThreadState
:
:
submitTask
(
PromiseHelperTask
*
task
)
{
AutoLockHelperThreadState
lock
;
if
(
!
promiseHelperTasks
(
lock
)
.
append
(
task
)
)
{
return
false
;
}
dispatch
(
DispatchReason
:
:
NewTask
lock
)
;
return
true
;
}
void
GlobalHelperThreadState
:
:
trace
(
JSTracer
*
trc
)
{
AutoLockHelperThreadState
lock
;
#
ifdef
DEBUG
GCMarker
*
marker
=
nullptr
;
if
(
trc
-
>
isMarkingTracer
(
)
)
{
marker
=
GCMarker
:
:
fromTracer
(
trc
)
;
marker
-
>
setCheckAtomMarking
(
false
)
;
}
auto
reenableAtomMarkingCheck
=
mozilla
:
:
MakeScopeExit
(
[
marker
]
{
if
(
marker
)
{
marker
-
>
setCheckAtomMarking
(
true
)
;
}
}
)
;
#
endif
for
(
auto
task
:
ionWorklist
(
lock
)
)
{
task
-
>
alloc
(
)
.
lifoAlloc
(
)
-
>
setReadWrite
(
)
;
task
-
>
trace
(
trc
)
;
task
-
>
alloc
(
)
.
lifoAlloc
(
)
-
>
setReadOnly
(
)
;
}
for
(
auto
task
:
ionFinishedList
(
lock
)
)
{
task
-
>
trace
(
trc
)
;
}
for
(
auto
*
helper
:
HelperThreadState
(
)
.
helperTasks
(
lock
)
)
{
if
(
helper
-
>
is
<
jit
:
:
IonCompileTask
>
(
)
)
{
helper
-
>
as
<
jit
:
:
IonCompileTask
>
(
)
-
>
trace
(
trc
)
;
}
}
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
if
(
auto
*
jitRuntime
=
rt
-
>
jitRuntime
(
)
)
{
jit
:
:
IonCompileTask
*
task
=
jitRuntime
-
>
ionLazyLinkList
(
rt
)
.
getFirst
(
)
;
while
(
task
)
{
task
-
>
trace
(
trc
)
;
task
=
task
-
>
getNext
(
)
;
}
}
for
(
auto
&
parseTask
:
parseWorklist_
)
{
parseTask
-
>
trace
(
trc
)
;
}
for
(
auto
parseTask
:
parseFinishedList_
)
{
parseTask
-
>
trace
(
trc
)
;
}
}
const
GlobalHelperThreadState
:
:
Selector
GlobalHelperThreadState
:
:
selectors
[
]
=
{
&
GlobalHelperThreadState
:
:
maybeGetGCParallelTask
&
GlobalHelperThreadState
:
:
maybeGetIonCompileTask
&
GlobalHelperThreadState
:
:
maybeGetWasmTier1CompileTask
&
GlobalHelperThreadState
:
:
maybeGetPromiseHelperTask
&
GlobalHelperThreadState
:
:
maybeGetParseTask
&
GlobalHelperThreadState
:
:
maybeGetFreeDelazifyTask
&
GlobalHelperThreadState
:
:
maybeGetDelazifyTask
&
GlobalHelperThreadState
:
:
maybeGetCompressionTask
&
GlobalHelperThreadState
:
:
maybeGetLowPrioIonCompileTask
&
GlobalHelperThreadState
:
:
maybeGetIonFreeTask
&
GlobalHelperThreadState
:
:
maybeGetWasmTier2CompileTask
&
GlobalHelperThreadState
:
:
maybeGetWasmTier2GeneratorTask
}
;
bool
GlobalHelperThreadState
:
:
canStartTasks
(
const
AutoLockHelperThreadState
&
lock
)
{
return
canStartGCParallelTask
(
lock
)
|
|
canStartIonCompileTask
(
lock
)
|
|
canStartWasmTier1CompileTask
(
lock
)
|
|
canStartPromiseHelperTask
(
lock
)
|
|
canStartParseTask
(
lock
)
|
|
canStartFreeDelazifyTask
(
lock
)
|
|
canStartDelazifyTask
(
lock
)
|
|
canStartCompressionTask
(
lock
)
|
|
canStartIonFreeTask
(
lock
)
|
|
canStartWasmTier2CompileTask
(
lock
)
|
|
canStartWasmTier2GeneratorTask
(
lock
)
;
}
void
JS
:
:
RunHelperThreadTask
(
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
AutoLockHelperThreadState
lock
;
if
(
!
gHelperThreadState
|
|
HelperThreadState
(
)
.
isTerminating
(
lock
)
)
{
return
;
}
HelperThreadState
(
)
.
runOneTask
(
lock
)
;
}
void
GlobalHelperThreadState
:
:
runOneTask
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
tasksPending_
>
0
)
;
tasksPending_
-
-
;
HelperThreadTask
*
task
=
findHighestPriorityTask
(
lock
)
;
if
(
task
)
{
runTaskLocked
(
task
lock
)
;
dispatch
(
DispatchReason
:
:
FinishedTask
lock
)
;
}
notifyAll
(
lock
)
;
}
HelperThreadTask
*
GlobalHelperThreadState
:
:
findHighestPriorityTask
(
const
AutoLockHelperThreadState
&
locked
)
{
for
(
const
auto
&
selector
:
selectors
)
{
if
(
auto
*
task
=
(
this
-
>
*
(
selector
)
)
(
locked
)
)
{
return
task
;
}
}
return
nullptr
;
}
void
GlobalHelperThreadState
:
:
runTaskLocked
(
HelperThreadTask
*
task
AutoLockHelperThreadState
&
locked
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
HelperThreadState
(
)
.
helperTasks
(
locked
)
.
infallibleEmplaceBack
(
task
)
;
ThreadType
threadType
=
task
-
>
threadType
(
)
;
js
:
:
oom
:
:
SetThreadType
(
threadType
)
;
runningTaskCount
[
threadType
]
+
+
;
totalCountRunningTasks
+
+
;
task
-
>
runHelperThreadTask
(
locked
)
;
HelperThreadState
(
)
.
helperTasks
(
locked
)
.
eraseIfEqual
(
task
)
;
totalCountRunningTasks
-
-
;
runningTaskCount
[
threadType
]
-
-
;
js
:
:
oom
:
:
SetThreadType
(
js
:
:
THREAD_TYPE_NONE
)
;
}
