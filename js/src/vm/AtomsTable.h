#
ifndef
vm_AtomsTable_h
#
define
vm_AtomsTable_h
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
struct
AtomHasher
{
struct
Lookup
;
static
inline
HashNumber
hash
(
const
Lookup
&
l
)
;
static
MOZ_ALWAYS_INLINE
bool
match
(
const
WeakHeapPtr
<
JSAtom
*
>
&
entry
const
Lookup
&
lookup
)
;
static
void
rekey
(
WeakHeapPtr
<
JSAtom
*
>
&
k
const
WeakHeapPtr
<
JSAtom
*
>
&
newKey
)
{
k
=
newKey
;
}
}
;
class
AtomSet
:
public
JS
:
:
GCHashSet
<
WeakHeapPtr
<
JSAtom
*
>
AtomHasher
SystemAllocPolicy
>
{
using
Base
=
JS
:
:
GCHashSet
<
WeakHeapPtr
<
JSAtom
*
>
AtomHasher
SystemAllocPolicy
>
;
public
:
AtomSet
(
)
=
default
;
explicit
AtomSet
(
size_t
length
)
:
Base
(
length
)
{
}
;
}
;
class
FrozenAtomSet
{
AtomSet
*
mSet
;
public
:
explicit
FrozenAtomSet
(
AtomSet
*
set
)
{
mSet
=
set
;
}
~
FrozenAtomSet
(
)
{
js_delete
(
mSet
)
;
}
MOZ_ALWAYS_INLINE
AtomSet
:
:
Ptr
readonlyThreadsafeLookup
(
const
AtomSet
:
:
Lookup
&
l
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mSet
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
using
Range
=
AtomSet
:
:
Range
;
AtomSet
:
:
Range
all
(
)
const
{
return
mSet
-
>
all
(
)
;
}
}
;
class
AtomsTable
{
static
const
size_t
InitialTableSize
=
16
;
AtomSet
atoms
;
AtomSet
*
atomsAddedWhileSweeping
;
Vector
<
JSAtom
*
0
SystemAllocPolicy
>
pinnedAtoms
;
public
:
using
SweepIterator
=
AtomSet
:
:
Enum
;
AtomsTable
(
)
;
~
AtomsTable
(
)
;
bool
init
(
)
;
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
JSAtom
*
atomizeAndCopyCharsNonStaticValidLength
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
const
mozilla
:
:
Maybe
<
uint32_t
>
&
indexValue
const
AtomHasher
:
:
Lookup
&
lookup
)
;
bool
maybePinExistingAtom
(
JSContext
*
cx
JSAtom
*
atom
)
;
void
tracePinnedAtoms
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
bool
startIncrementalSweep
(
mozilla
:
:
Maybe
<
SweepIterator
>
&
atomsToSweepOut
)
;
bool
sweepIncrementally
(
SweepIterator
&
atomsToSweep
SliceBudget
&
budget
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
void
mergeAtomsAddedWhileSweeping
(
)
;
}
;
bool
AtomIsPinned
(
JSContext
*
cx
JSAtom
*
atom
)
;
}
#
endif
