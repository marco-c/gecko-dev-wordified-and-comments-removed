#
ifndef
vm_AtomsTable_h
#
define
vm_AtomsTable_h
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
namespace
js
{
class
AtomStateEntry
{
uintptr_t
bits
;
static
const
uintptr_t
NO_TAG_MASK
=
uintptr_t
(
-
1
)
-
1
;
public
:
AtomStateEntry
(
)
:
bits
(
0
)
{
}
AtomStateEntry
(
const
AtomStateEntry
&
other
)
=
default
;
AtomStateEntry
(
JSAtom
*
ptr
bool
tagged
)
:
bits
(
uintptr_t
(
ptr
)
|
uintptr_t
(
tagged
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
ptr
)
&
0x1
)
=
=
0
)
;
}
bool
isPinned
(
)
const
{
return
bits
&
0x1
;
}
void
setPinned
(
bool
pinned
)
const
{
const_cast
<
AtomStateEntry
*
>
(
this
)
-
>
bits
|
=
uintptr_t
(
pinned
)
;
}
JSAtom
*
asPtrUnbarriered
(
)
const
{
MOZ_ASSERT
(
bits
)
;
return
reinterpret_cast
<
JSAtom
*
>
(
bits
&
NO_TAG_MASK
)
;
}
JSAtom
*
asPtr
(
JSContext
*
cx
)
const
;
}
;
struct
AtomHasher
{
struct
Lookup
;
static
inline
HashNumber
hash
(
const
Lookup
&
l
)
;
static
MOZ_ALWAYS_INLINE
bool
match
(
const
AtomStateEntry
&
entry
const
Lookup
&
lookup
)
;
static
void
rekey
(
AtomStateEntry
&
k
const
AtomStateEntry
&
newKey
)
{
k
=
newKey
;
}
}
;
using
AtomSet
=
JS
:
:
GCHashSet
<
AtomStateEntry
AtomHasher
SystemAllocPolicy
>
;
class
FrozenAtomSet
{
AtomSet
*
mSet
;
public
:
explicit
FrozenAtomSet
(
AtomSet
*
set
)
{
mSet
=
set
;
}
~
FrozenAtomSet
(
)
{
js_delete
(
mSet
)
;
}
MOZ_ALWAYS_INLINE
AtomSet
:
:
Ptr
readonlyThreadsafeLookup
(
const
AtomSet
:
:
Lookup
&
l
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mSet
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
using
Range
=
AtomSet
:
:
Range
;
AtomSet
:
:
Range
all
(
)
const
{
return
mSet
-
>
all
(
)
;
}
}
;
class
AtomsTable
{
static
const
size_t
InitialTableSize
=
16
;
AtomSet
atoms
;
AtomSet
*
atomsAddedWhileSweeping
;
Vector
<
JSAtom
*
0
SystemAllocPolicy
>
pinnedAtoms
;
public
:
using
SweepIterator
=
AtomSet
:
:
Enum
;
AtomsTable
(
)
;
~
AtomsTable
(
)
;
bool
init
(
)
;
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
JSAtom
*
atomizeAndCopyChars
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
PinningBehavior
pin
const
mozilla
:
:
Maybe
<
uint32_t
>
&
indexValue
const
AtomHasher
:
:
Lookup
&
lookup
)
;
bool
atomIsPinned
(
JSRuntime
*
rt
JSAtom
*
atom
)
;
bool
maybePinExistingAtom
(
JSContext
*
cx
JSAtom
*
atom
)
;
void
tracePinnedAtoms
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
bool
startIncrementalSweep
(
mozilla
:
:
Maybe
<
SweepIterator
>
&
atomsToSweepOut
)
;
bool
sweepIncrementally
(
SweepIterator
&
atomsToSweep
SliceBudget
&
budget
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
void
mergeAtomsAddedWhileSweeping
(
)
;
}
;
bool
AtomIsPinned
(
JSContext
*
cx
JSAtom
*
atom
)
;
}
#
endif
