#
include
"
vm
/
SymbolType
.
h
"
#
include
"
builtin
/
Symbol
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Symbol
;
using
namespace
js
;
Symbol
*
Symbol
:
:
newInternal
(
JSContext
*
cx
JS
:
:
SymbolCode
code
uint32_t
hash
JSAtom
*
description
const
AutoAccessAtomsZone
&
access
)
{
MOZ_ASSERT
(
cx
-
>
zone
(
)
=
=
cx
-
>
atomsZone
(
access
)
)
;
Symbol
*
p
=
Allocate
<
JS
:
:
Symbol
NoGC
>
(
cx
)
;
if
(
!
p
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
new
(
p
)
Symbol
(
code
hash
description
)
;
}
Symbol
*
Symbol
:
:
new_
(
JSContext
*
cx
JS
:
:
SymbolCode
code
JSString
*
description
)
{
JSAtom
*
atom
=
nullptr
;
if
(
description
)
{
atom
=
AtomizeString
(
cx
description
)
;
if
(
!
atom
)
return
nullptr
;
}
AutoLockForExclusiveAccess
lock
(
cx
)
;
Symbol
*
sym
;
{
AutoAtomsZone
az
(
cx
lock
)
;
sym
=
newInternal
(
cx
code
cx
-
>
runtime
(
)
-
>
randomHashCode
(
)
atom
lock
)
;
}
if
(
sym
)
cx
-
>
markAtom
(
sym
)
;
return
sym
;
}
Symbol
*
Symbol
:
:
for_
(
JSContext
*
cx
HandleString
description
)
{
JSAtom
*
atom
=
AtomizeString
(
cx
description
)
;
if
(
!
atom
)
return
nullptr
;
AutoLockForExclusiveAccess
lock
(
cx
)
;
SymbolRegistry
&
registry
=
cx
-
>
symbolRegistry
(
lock
)
;
SymbolRegistry
:
:
AddPtr
p
=
registry
.
lookupForAdd
(
atom
)
;
if
(
p
)
{
cx
-
>
markAtom
(
*
p
)
;
return
*
p
;
}
Symbol
*
sym
;
{
AutoAtomsZone
az
(
cx
lock
)
;
HashNumber
hash
=
mozilla
:
:
HashGeneric
(
atom
-
>
hash
(
)
)
;
sym
=
newInternal
(
cx
SymbolCode
:
:
InSymbolRegistry
hash
atom
lock
)
;
if
(
!
sym
)
return
nullptr
;
if
(
!
registry
.
add
(
p
sym
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
cx
-
>
markAtom
(
sym
)
;
return
sym
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
Symbol
:
:
dump
(
)
{
js
:
:
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
void
Symbol
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
{
if
(
isWellKnownSymbol
(
)
)
{
description_
-
>
dumpCharsNoNewline
(
out
)
;
}
else
if
(
code_
=
=
SymbolCode
:
:
InSymbolRegistry
|
|
code_
=
=
SymbolCode
:
:
UniqueSymbol
)
{
out
.
printf
(
code_
=
=
SymbolCode
:
:
InSymbolRegistry
?
"
Symbol
.
for
(
"
:
"
Symbol
(
"
)
;
if
(
description_
)
description_
-
>
dumpCharsNoNewline
(
out
)
;
else
out
.
printf
(
"
undefined
"
)
;
out
.
putChar
(
'
)
'
)
;
if
(
code_
=
=
SymbolCode
:
:
UniqueSymbol
)
out
.
printf
(
"
%
p
"
(
void
*
)
this
)
;
}
else
{
out
.
printf
(
"
<
Invalid
Symbol
code
=
%
u
>
"
unsigned
(
code_
)
)
;
}
}
#
endif
bool
js
:
:
SymbolDescriptiveString
(
JSContext
*
cx
Symbol
*
sym
MutableHandleValue
result
)
{
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
"
Symbol
(
"
)
)
return
false
;
RootedString
str
(
cx
sym
-
>
description
(
)
)
;
if
(
str
)
{
if
(
!
sb
.
append
(
str
)
)
return
false
;
}
if
(
!
sb
.
append
(
'
)
'
)
)
return
false
;
str
=
sb
.
finishString
(
)
;
if
(
!
str
)
return
false
;
result
.
setString
(
str
)
;
return
true
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
JS
:
:
Symbol
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
MOZ_ASSERT
(
get
(
)
.
isTenured
(
)
)
;
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
