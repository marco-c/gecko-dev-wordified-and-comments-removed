#
include
"
vm
/
JSFunction
-
inl
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
<
algorithm
>
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
BigInt
.
h
"
#
include
"
builtin
/
Object
.
h
"
#
include
"
builtin
/
Symbol
.
h
"
#
include
"
frontend
/
BytecodeCompilation
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
js
/
CallNonGenericMethod
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BooleanObject
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
ErrorContext
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
NumberObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
StringObject
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
ifdef
ENABLE_RECORD_TUPLE
#
include
"
vm
/
RecordType
.
h
"
#
include
"
vm
/
TupleType
.
h
"
#
endif
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Some
;
using
JS
:
:
AutoStableStringChars
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
SourceOwnership
;
using
JS
:
:
SourceText
;
static
bool
fun_enumerate
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
obj
-
>
is
<
JSFunction
>
(
)
)
;
RootedId
id
(
cx
)
;
bool
found
;
if
(
!
obj
-
>
isBoundFunction
(
)
&
&
!
obj
-
>
as
<
JSFunction
>
(
)
.
isArrow
(
)
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
prototype
)
;
if
(
!
HasOwnProperty
(
cx
obj
id
&
found
)
)
{
return
false
;
}
}
if
(
!
obj
-
>
as
<
JSFunction
>
(
)
.
hasResolvedLength
(
)
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
length
)
;
if
(
!
HasOwnProperty
(
cx
obj
id
&
found
)
)
{
return
false
;
}
}
if
(
!
obj
-
>
as
<
JSFunction
>
(
)
.
hasResolvedName
(
)
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
name
)
;
if
(
!
HasOwnProperty
(
cx
obj
id
&
found
)
)
{
return
false
;
}
}
return
true
;
}
bool
IsFunction
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
JSFunction
>
(
)
;
}
static
bool
AdvanceToActiveCallLinear
(
JSContext
*
cx
NonBuiltinScriptFrameIter
&
iter
HandleFunction
fun
)
{
MOZ_ASSERT
(
!
fun
-
>
isBuiltin
(
)
)
;
for
(
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
!
iter
.
isFunctionFrame
(
)
)
{
continue
;
}
if
(
iter
.
matchCallee
(
cx
fun
)
)
{
return
true
;
}
}
return
false
;
}
void
js
:
:
ThrowTypeErrorBehavior
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_THROW_TYPE_ERROR
)
;
}
static
bool
IsSloppyNormalFunction
(
JSFunction
*
fun
)
{
if
(
fun
-
>
kind
(
)
=
=
FunctionFlags
:
:
NormalFunction
)
{
if
(
fun
-
>
isBuiltin
(
)
|
|
fun
-
>
isBoundFunction
(
)
)
{
return
false
;
}
if
(
fun
-
>
isGenerator
(
)
|
|
fun
-
>
isAsync
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
return
!
fun
-
>
strict
(
)
;
}
if
(
fun
-
>
kind
(
)
=
=
FunctionFlags
:
:
AsmJS
)
{
return
!
IsAsmJSStrictModeModuleOrFunction
(
fun
)
;
}
return
false
;
}
static
bool
ArgumentsRestrictions
(
JSContext
*
cx
HandleFunction
fun
)
{
if
(
!
IsSloppyNormalFunction
(
fun
)
)
{
ThrowTypeErrorBehavior
(
cx
)
;
return
false
;
}
return
true
;
}
bool
ArgumentsGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
ArgumentsRestrictions
(
cx
fun
)
)
{
return
false
;
}
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
NonBuiltinScriptFrameIter
iter
(
cx
)
;
if
(
!
AdvanceToActiveCallLinear
(
cx
iter
fun
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
Rooted
<
ArgumentsObject
*
>
argsobj
(
cx
ArgumentsObject
:
:
createUnexpected
(
cx
iter
)
)
;
if
(
!
argsobj
)
{
return
false
;
}
#
ifndef
JS_CODEGEN_NONE
JSScript
*
script
=
iter
.
script
(
)
;
jit
:
:
ForbidCompilation
(
cx
script
)
;
#
endif
args
.
rval
(
)
.
setObject
(
*
argsobj
)
;
return
true
;
}
static
bool
ArgumentsGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
ArgumentsGetterImpl
>
(
cx
args
)
;
}
bool
ArgumentsSetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
ArgumentsRestrictions
(
cx
fun
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ArgumentsSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
ArgumentsSetterImpl
>
(
cx
args
)
;
}
static
bool
CallerRestrictions
(
JSContext
*
cx
HandleFunction
fun
)
{
if
(
!
IsSloppyNormalFunction
(
fun
)
)
{
ThrowTypeErrorBehavior
(
cx
)
;
return
false
;
}
return
true
;
}
bool
CallerGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
CallerRestrictions
(
cx
fun
)
)
{
return
false
;
}
NonBuiltinScriptFrameIter
iter
(
cx
)
;
if
(
!
AdvanceToActiveCallLinear
(
cx
iter
fun
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
+
+
iter
;
while
(
!
iter
.
done
(
)
&
&
iter
.
isEvalFrame
(
)
)
{
+
+
iter
;
}
if
(
iter
.
done
(
)
|
|
!
iter
.
isFunctionFrame
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
RootedObject
caller
(
cx
iter
.
callee
(
cx
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
caller
)
)
{
return
false
;
}
{
JSObject
*
callerObj
=
CheckedUnwrapStatic
(
caller
)
;
if
(
!
callerObj
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
if
(
JS_IsDeadWrapper
(
callerObj
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEAD_OBJECT
)
;
return
false
;
}
JSFunction
*
callerFun
=
&
callerObj
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
!
callerFun
-
>
isBuiltin
(
)
"
non
-
builtin
iterator
returned
a
builtin
?
"
)
;
if
(
callerFun
-
>
strict
(
)
|
|
callerFun
-
>
isAsync
(
)
|
|
callerFun
-
>
isGenerator
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
}
args
.
rval
(
)
.
setObject
(
*
caller
)
;
return
true
;
}
static
bool
CallerGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
CallerGetterImpl
>
(
cx
args
)
;
}
bool
CallerSetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
if
(
!
CallerGetterImpl
(
cx
args
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
CallerSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
CallerSetterImpl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
function_properties
[
]
=
{
JS_PSGS
(
"
arguments
"
ArgumentsGetter
ArgumentsSetter
0
)
JS_PSGS
(
"
caller
"
CallerGetter
CallerSetter
0
)
JS_PS_END
}
;
static
bool
ResolveInterpretedFunctionPrototype
(
JSContext
*
cx
HandleFunction
fun
HandleId
id
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
|
|
fun
-
>
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
fun
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
bool
isGenerator
=
fun
-
>
isGenerator
(
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
&
fun
-
>
global
(
)
)
;
RootedObject
objProto
(
cx
)
;
if
(
isGenerator
&
&
fun
-
>
isAsync
(
)
)
{
objProto
=
GlobalObject
:
:
getOrCreateAsyncGeneratorPrototype
(
cx
global
)
;
}
else
if
(
isGenerator
)
{
objProto
=
GlobalObject
:
:
getOrCreateGeneratorObjectPrototype
(
cx
global
)
;
}
else
{
objProto
=
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
global
)
;
}
if
(
!
objProto
)
{
return
false
;
}
Rooted
<
PlainObject
*
>
proto
(
cx
NewPlainObjectWithProto
(
cx
objProto
TenuredObject
)
)
;
if
(
!
proto
)
{
return
false
;
}
if
(
!
isGenerator
)
{
RootedValue
objVal
(
cx
ObjectValue
(
*
fun
)
)
;
if
(
!
DefineDataProperty
(
cx
proto
cx
-
>
names
(
)
.
constructor
objVal
0
)
)
{
return
false
;
}
}
RootedValue
protoVal
(
cx
ObjectValue
(
*
proto
)
)
;
return
DefineDataProperty
(
cx
fun
id
protoVal
JSPROP_PERMANENT
|
JSPROP_RESOLVING
)
;
}
bool
JSFunction
:
:
needsPrototypeProperty
(
)
{
return
!
isBuiltin
(
)
&
&
(
isConstructor
(
)
|
|
isGenerator
(
)
)
;
}
bool
JSFunction
:
:
hasNonConfigurablePrototypeDataProperty
(
)
{
if
(
!
isBuiltin
(
)
)
{
return
needsPrototypeProperty
(
)
;
}
if
(
isSelfHostedBuiltin
(
)
)
{
if
(
!
isConstructor
(
)
|
|
isBoundFunction
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
PropertyName
*
prototypeName
=
runtimeFromMainThread
(
)
-
>
commonNames
-
>
prototype
;
Maybe
<
PropertyInfo
>
prop
=
lookupPure
(
prototypeName
)
;
MOZ_ASSERT
(
prop
.
isSome
(
)
)
;
MOZ_ASSERT
(
prop
-
>
isDataProperty
(
)
)
;
MOZ_ASSERT
(
!
prop
-
>
configurable
(
)
)
;
#
endif
return
true
;
}
if
(
!
isConstructor
(
)
)
{
return
false
;
}
PropertyName
*
prototypeName
=
runtimeFromMainThread
(
)
-
>
commonNames
-
>
prototype
;
Maybe
<
PropertyInfo
>
prop
=
lookupPure
(
prototypeName
)
;
return
prop
.
isSome
(
)
&
&
prop
-
>
isDataProperty
(
)
&
&
!
prop
-
>
configurable
(
)
;
}
static
bool
fun_mayResolve
(
const
JSAtomState
&
names
jsid
id
JSObject
*
)
{
if
(
!
id
.
isAtom
(
)
)
{
return
false
;
}
JSAtom
*
atom
=
id
.
toAtom
(
)
;
return
atom
=
=
names
.
prototype
|
|
atom
=
=
names
.
length
|
|
atom
=
=
names
.
name
;
}
static
bool
fun_resolve
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
resolvedp
)
{
if
(
!
id
.
isAtom
(
)
)
{
return
true
;
}
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
id
.
isAtom
(
cx
-
>
names
(
)
.
prototype
)
)
{
if
(
!
fun
-
>
needsPrototypeProperty
(
)
)
{
return
true
;
}
if
(
!
ResolveInterpretedFunctionPrototype
(
cx
fun
id
)
)
{
return
false
;
}
*
resolvedp
=
true
;
return
true
;
}
bool
isLength
=
id
.
isAtom
(
cx
-
>
names
(
)
.
length
)
;
if
(
isLength
|
|
id
.
isAtom
(
cx
-
>
names
(
)
.
name
)
)
{
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
obj
)
)
;
RootedValue
v
(
cx
)
;
if
(
isLength
)
{
if
(
fun
-
>
hasResolvedLength
(
)
)
{
return
true
;
}
if
(
!
JSFunction
:
:
getUnresolvedLength
(
cx
fun
&
v
)
)
{
return
false
;
}
}
else
{
if
(
fun
-
>
hasResolvedName
(
)
)
{
return
true
;
}
if
(
!
JSFunction
:
:
getUnresolvedName
(
cx
fun
&
v
)
)
{
return
false
;
}
}
if
(
!
NativeDefineDataProperty
(
cx
fun
id
v
JSPROP_READONLY
|
JSPROP_RESOLVING
)
)
{
return
false
;
}
if
(
isLength
)
{
fun
-
>
setResolvedLength
(
)
;
}
else
{
fun
-
>
setResolvedName
(
)
;
}
*
resolvedp
=
true
;
return
true
;
}
return
true
;
}
static
bool
fun_symbolHasInstance
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
<
1
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
HandleValue
func
=
args
.
thisv
(
)
;
if
(
!
func
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
RootedObject
obj
(
cx
&
func
.
toObject
(
)
)
;
bool
result
;
if
(
!
OrdinaryHasInstance
(
cx
obj
args
[
0
]
&
result
)
)
{
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
result
)
;
return
true
;
}
bool
JS
:
:
OrdinaryHasInstance
(
JSContext
*
cx
HandleObject
objArg
HandleValue
v
bool
*
bp
)
{
AssertHeapIsIdle
(
)
;
cx
-
>
check
(
objArg
v
)
;
RootedObject
obj
(
cx
objArg
)
;
if
(
!
obj
-
>
isCallable
(
)
)
{
*
bp
=
false
;
return
true
;
}
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
isBoundFunction
(
)
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
obj
=
obj
-
>
as
<
JSFunction
>
(
)
.
getBoundFunctionTarget
(
)
;
return
InstanceofOperator
(
cx
obj
v
bp
)
;
}
if
(
!
v
.
isObject
(
)
)
{
*
bp
=
false
;
return
true
;
}
RootedValue
pval
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
prototype
&
pval
)
)
{
return
false
;
}
if
(
pval
.
isPrimitive
(
)
)
{
RootedValue
val
(
cx
ObjectValue
(
*
obj
)
)
;
ReportValueError
(
cx
JSMSG_BAD_PROTOTYPE
-
1
val
nullptr
)
;
return
false
;
}
RootedObject
pobj
(
cx
&
pval
.
toObject
(
)
)
;
bool
isPrototype
;
if
(
!
IsPrototypeOf
(
cx
pobj
&
v
.
toObject
(
)
&
isPrototype
)
)
{
return
false
;
}
*
bp
=
isPrototype
;
return
true
;
}
inline
void
JSFunction
:
:
trace
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
!
getFixedSlot
(
NativeJitInfoOrInterpretedScriptSlot
)
.
isGCThing
(
)
)
;
if
(
isInterpreted
(
)
&
&
hasBaseScript
(
)
)
{
if
(
BaseScript
*
script
=
baseScript
(
)
)
{
TraceManuallyBarrieredEdge
(
trc
&
script
"
script
"
)
;
if
(
baseScript
(
)
!
=
script
)
{
HeapSlot
&
slot
=
getFixedSlotRef
(
NativeJitInfoOrInterpretedScriptSlot
)
;
slot
.
unbarrieredSet
(
JS
:
:
PrivateValue
(
script
)
)
;
}
}
}
if
(
isAsmJSNative
(
)
|
|
isWasm
(
)
)
{
const
Value
&
v
=
getExtendedSlot
(
FunctionExtended
:
:
WASM_INSTANCE_SLOT
)
;
if
(
!
v
.
isUndefined
(
)
)
{
js
:
:
wasm
:
:
Instance
*
instance
=
static_cast
<
js
:
:
wasm
:
:
Instance
*
>
(
v
.
toPrivate
(
)
)
;
instance
-
>
trace
(
trc
)
;
}
}
}
static
void
fun_trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
obj
-
>
as
<
JSFunction
>
(
)
.
trace
(
trc
)
;
}
static
JSObject
*
CreateFunctionConstructor
(
JSContext
*
cx
JSProtoKey
key
)
{
Rooted
<
GlobalObject
*
>
global
(
cx
cx
-
>
global
(
)
)
;
RootedObject
functionProto
(
cx
&
global
-
>
getPrototype
(
JSProto_Function
)
)
;
RootedObject
functionCtor
(
cx
NewFunctionWithProto
(
cx
Function
1
FunctionFlags
:
:
NATIVE_CTOR
nullptr
Handle
<
PropertyName
*
>
(
cx
-
>
names
(
)
.
Function
)
functionProto
gc
:
:
AllocKind
:
:
FUNCTION
TenuredObject
)
)
;
if
(
!
functionCtor
)
{
return
nullptr
;
}
return
functionCtor
;
}
static
bool
FunctionPrototype
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
JSObject
*
CreateFunctionPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
Rooted
<
GlobalObject
*
>
self
(
cx
cx
-
>
global
(
)
)
;
RootedObject
objectProto
(
cx
&
self
-
>
getPrototype
(
JSProto_Object
)
)
;
return
NewFunctionWithProto
(
cx
FunctionPrototype
0
FunctionFlags
:
:
NATIVE_FUN
nullptr
Handle
<
PropertyName
*
>
(
cx
-
>
names
(
)
.
empty
)
objectProto
gc
:
:
AllocKind
:
:
FUNCTION
TenuredObject
)
;
}
JSString
*
js
:
:
FunctionToStringCache
:
:
lookup
(
BaseScript
*
script
)
const
{
for
(
size_t
i
=
0
;
i
<
NumEntries
;
i
+
+
)
{
if
(
entries_
[
i
]
.
script
=
=
script
)
{
return
entries_
[
i
]
.
string
;
}
}
return
nullptr
;
}
void
js
:
:
FunctionToStringCache
:
:
put
(
BaseScript
*
script
JSString
*
string
)
{
for
(
size_t
i
=
NumEntries
-
1
;
i
>
0
;
i
-
-
)
{
entries_
[
i
]
=
entries_
[
i
-
1
]
;
}
entries_
[
0
]
.
set
(
script
string
)
;
}
JSString
*
js
:
:
FunctionToString
(
JSContext
*
cx
HandleFunction
fun
bool
isToSource
)
{
if
(
IsAsmJSModule
(
fun
)
)
{
return
AsmJSModuleToString
(
cx
fun
isToSource
)
;
}
if
(
IsAsmJSFunction
(
fun
)
)
{
return
AsmJSFunctionToString
(
cx
fun
)
;
}
bool
haveSource
=
fun
-
>
isInterpreted
(
)
&
&
!
fun
-
>
isSelfHostedBuiltin
(
)
;
bool
addParentheses
=
haveSource
&
&
isToSource
&
&
(
fun
-
>
isLambda
(
)
&
&
!
fun
-
>
isArrow
(
)
)
;
if
(
haveSource
)
{
if
(
!
ScriptSource
:
:
loadSource
(
cx
fun
-
>
baseScript
(
)
-
>
scriptSource
(
)
&
haveSource
)
)
{
return
nullptr
;
}
}
if
(
!
addParentheses
&
&
haveSource
)
{
FunctionToStringCache
&
cache
=
cx
-
>
zone
(
)
-
>
functionToStringCache
(
)
;
if
(
JSString
*
str
=
cache
.
lookup
(
fun
-
>
baseScript
(
)
)
)
{
return
str
;
}
BaseScript
*
script
=
fun
-
>
baseScript
(
)
;
size_t
start
=
script
-
>
toStringStart
(
)
;
size_t
end
=
script
-
>
toStringEnd
(
)
;
JSString
*
str
=
(
end
-
start
<
=
ScriptSource
:
:
SourceDeflateLimit
)
?
script
-
>
scriptSource
(
)
-
>
substring
(
cx
start
end
)
:
script
-
>
scriptSource
(
)
-
>
substringDontDeflate
(
cx
start
end
)
;
if
(
!
str
)
{
return
nullptr
;
}
cache
.
put
(
fun
-
>
baseScript
(
)
str
)
;
return
str
;
}
JSStringBuilder
out
(
cx
)
;
if
(
addParentheses
)
{
if
(
!
out
.
append
(
'
(
'
)
)
{
return
nullptr
;
}
}
if
(
haveSource
)
{
if
(
!
fun
-
>
baseScript
(
)
-
>
appendSourceDataForToString
(
cx
out
)
)
{
return
nullptr
;
}
}
else
if
(
!
isToSource
)
{
auto
hasGetterOrSetterPrefix
=
[
]
(
JSAtom
*
name
)
{
auto
hasGetterOrSetterPrefix
=
[
]
(
const
auto
*
chars
)
{
return
(
chars
[
0
]
=
=
'
g
'
|
|
chars
[
0
]
=
=
'
s
'
)
&
&
chars
[
1
]
=
=
'
e
'
&
&
chars
[
2
]
=
=
'
t
'
&
&
chars
[
3
]
=
=
'
'
;
}
;
JS
:
:
AutoCheckCannotGC
nogc
;
return
name
-
>
length
(
)
>
=
4
&
&
(
name
-
>
hasLatin1Chars
(
)
?
hasGetterOrSetterPrefix
(
name
-
>
latin1Chars
(
nogc
)
)
:
hasGetterOrSetterPrefix
(
name
-
>
twoByteChars
(
nogc
)
)
)
;
}
;
if
(
!
out
.
append
(
"
function
"
)
)
{
return
nullptr
;
}
if
(
fun
-
>
explicitName
(
)
&
&
!
fun
-
>
isBoundFunction
(
)
&
&
(
fun
-
>
kind
(
)
=
=
FunctionFlags
:
:
NormalFunction
|
|
fun
-
>
kind
(
)
=
=
FunctionFlags
:
:
Wasm
|
|
fun
-
>
kind
(
)
=
=
FunctionFlags
:
:
ClassConstructor
)
)
{
if
(
!
out
.
append
(
'
'
)
)
{
return
nullptr
;
}
JSAtom
*
name
=
fun
-
>
explicitName
(
)
;
size_t
offset
=
hasGetterOrSetterPrefix
(
name
)
?
4
:
0
;
if
(
!
out
.
appendSubstring
(
name
offset
name
-
>
length
(
)
-
offset
)
)
{
return
nullptr
;
}
}
if
(
!
out
.
append
(
"
(
)
{
\
n
[
native
code
]
\
n
}
"
)
)
{
return
nullptr
;
}
}
else
{
if
(
fun
-
>
isAsync
(
)
)
{
if
(
!
out
.
append
(
"
async
"
)
)
{
return
nullptr
;
}
}
if
(
!
fun
-
>
isArrow
(
)
)
{
if
(
!
out
.
append
(
"
function
"
)
)
{
return
nullptr
;
}
if
(
fun
-
>
isGenerator
(
)
)
{
if
(
!
out
.
append
(
'
*
'
)
)
{
return
nullptr
;
}
}
}
if
(
fun
-
>
explicitName
(
)
)
{
if
(
!
out
.
append
(
'
'
)
)
{
return
nullptr
;
}
if
(
fun
-
>
isBoundFunction
(
)
)
{
JSLinearString
*
boundName
=
JSFunction
:
:
getBoundFunctionName
(
cx
fun
)
;
if
(
!
boundName
|
|
!
out
.
append
(
boundName
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
out
.
append
(
fun
-
>
explicitName
(
)
)
)
{
return
nullptr
;
}
}
}
if
(
!
out
.
append
(
"
(
)
{
\
n
[
native
code
]
\
n
}
"
)
)
{
return
nullptr
;
}
}
if
(
addParentheses
)
{
if
(
!
out
.
append
(
'
)
'
)
)
{
return
nullptr
;
}
}
return
out
.
finishString
(
)
;
}
JSString
*
fun_toStringHelper
(
JSContext
*
cx
HandleObject
obj
bool
isToSource
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
JSFunToStringOp
op
=
obj
-
>
getOpsFunToString
(
)
)
{
return
op
(
cx
obj
isToSource
)
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
js_Function_str
js_toString_str
"
object
"
)
;
return
nullptr
;
}
return
FunctionToString
(
cx
obj
.
as
<
JSFunction
>
(
)
isToSource
)
;
}
bool
js
:
:
fun_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
IsFunctionObject
(
args
.
calleev
(
)
)
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
{
return
false
;
}
JSString
*
str
=
fun_toStringHelper
(
cx
obj
false
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
fun_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
IsFunctionObject
(
args
.
calleev
(
)
)
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
{
return
false
;
}
RootedString
str
(
cx
)
;
if
(
obj
-
>
isCallable
(
)
)
{
str
=
fun_toStringHelper
(
cx
obj
true
)
;
}
else
{
str
=
ObjectToSource
(
cx
obj
)
;
}
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
js
:
:
fun_call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
func
=
args
.
thisv
(
)
;
if
(
!
IsCallable
(
func
)
)
{
ReportIncompatibleMethod
(
cx
args
&
FunctionClass
)
;
return
false
;
}
size_t
argCount
=
args
.
length
(
)
;
if
(
argCount
>
0
)
{
argCount
-
-
;
}
InvokeArgs
iargs
(
cx
)
;
if
(
!
iargs
.
init
(
cx
argCount
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
argCount
;
i
+
+
)
{
iargs
[
i
]
.
set
(
args
[
i
+
1
]
)
;
}
return
Call
(
cx
func
args
.
get
(
0
)
iargs
args
.
rval
(
)
CallReason
:
:
FunCall
)
;
}
bool
js
:
:
fun_apply
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
fval
=
args
.
thisv
(
)
;
if
(
!
IsCallable
(
fval
)
)
{
ReportIncompatibleMethod
(
cx
args
&
FunctionClass
)
;
return
false
;
}
if
(
args
.
length
(
)
<
2
|
|
args
[
1
]
.
isNullOrUndefined
(
)
)
{
return
fun_call
(
cx
(
args
.
length
(
)
>
0
)
?
1
:
0
vp
)
;
}
if
(
!
args
[
1
]
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_APPLY_ARGS
js_apply_str
)
;
return
false
;
}
RootedObject
aobj
(
cx
&
args
[
1
]
.
toObject
(
)
)
;
uint64_t
length
;
if
(
!
GetLengthProperty
(
cx
aobj
&
length
)
)
{
return
false
;
}
InvokeArgs
args2
(
cx
)
;
if
(
!
args2
.
init
(
cx
length
)
)
{
return
false
;
}
MOZ_ASSERT
(
length
<
=
ARGS_LENGTH_MAX
)
;
if
(
!
GetElements
(
cx
aobj
length
args2
.
array
(
)
)
)
{
return
false
;
}
return
Call
(
cx
fval
args
[
0
]
args2
args
.
rval
(
)
CallReason
:
:
FunCall
)
;
}
static
const
JSFunctionSpec
function_methods
[
]
=
{
JS_FN
(
js_toSource_str
fun_toSource
0
0
)
JS_FN
(
js_toString_str
fun_toString
0
0
)
JS_FN
(
js_apply_str
fun_apply
2
0
)
JS_FN
(
js_call_str
fun_call
1
0
)
JS_SELF_HOSTED_FN
(
"
bind
"
"
FunctionBind
"
2
0
)
JS_SYM_FN
(
hasInstance
fun_symbolHasInstance
1
JSPROP_READONLY
|
JSPROP_PERMANENT
)
JS_FS_END
}
;
static
const
JSClassOps
JSFunctionClassOps
=
{
nullptr
nullptr
fun_enumerate
nullptr
fun_resolve
fun_mayResolve
nullptr
nullptr
nullptr
fun_trace
}
;
static
const
ClassSpec
JSFunctionClassSpec
=
{
CreateFunctionConstructor
CreateFunctionPrototype
nullptr
nullptr
function_methods
function_properties
}
;
const
JSClass
js
:
:
FunctionClass
=
{
js_Function_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Function
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
JSFunction
:
:
SlotCount
)
&
JSFunctionClassOps
&
JSFunctionClassSpec
}
;
const
JSClass
js
:
:
ExtendedFunctionClass
=
{
js_Function_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Function
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
FunctionExtended
:
:
SlotCount
)
&
JSFunctionClassOps
&
JSFunctionClassSpec
}
;
const
JSClass
*
const
js
:
:
FunctionClassPtr
=
&
FunctionClass
;
const
JSClass
*
const
js
:
:
FunctionExtendedClassPtr
=
&
ExtendedFunctionClass
;
bool
JSFunction
:
:
isDerivedClassConstructor
(
)
const
{
bool
derived
=
hasBaseScript
(
)
&
&
baseScript
(
)
-
>
isDerivedClassConstructor
(
)
;
MOZ_ASSERT_IF
(
derived
isClassConstructor
(
)
)
;
return
derived
;
}
bool
JSFunction
:
:
isSyntheticFunction
(
)
const
{
bool
synthetic
=
hasBaseScript
(
)
&
&
baseScript
(
)
-
>
isSyntheticFunction
(
)
;
MOZ_ASSERT_IF
(
synthetic
isMethod
(
)
)
;
return
synthetic
;
}
bool
JSFunction
:
:
getLength
(
JSContext
*
cx
HandleFunction
fun
uint16_t
*
length
)
{
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
if
(
fun
-
>
isNativeFun
(
)
)
{
*
length
=
fun
-
>
nargs
(
)
;
return
true
;
}
JSScript
*
script
=
getOrCreateScript
(
cx
fun
)
;
if
(
!
script
)
{
return
false
;
}
*
length
=
script
-
>
funLength
(
)
;
return
true
;
}
bool
JSFunction
:
:
getUnresolvedLength
(
JSContext
*
cx
HandleFunction
fun
MutableHandleValue
v
)
{
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
fun
)
)
;
MOZ_ASSERT
(
!
fun
-
>
hasResolvedLength
(
)
)
;
if
(
fun
-
>
isBoundFunction
(
)
)
{
constexpr
auto
lengthSlot
=
FunctionExtended
:
:
BOUND_FUNCTION_LENGTH_SLOT
;
MOZ_ASSERT
(
fun
-
>
getExtendedSlot
(
lengthSlot
)
.
isNumber
(
)
)
;
v
.
set
(
fun
-
>
getExtendedSlot
(
lengthSlot
)
)
;
return
true
;
}
uint16_t
length
;
if
(
!
JSFunction
:
:
getLength
(
cx
fun
&
length
)
)
{
return
false
;
}
v
.
setInt32
(
length
)
;
return
true
;
}
JSAtom
*
JSFunction
:
:
infallibleGetUnresolvedName
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
this
)
)
;
MOZ_ASSERT
(
!
hasResolvedName
(
)
)
;
if
(
JSAtom
*
name
=
explicitOrInferredName
(
)
)
{
return
name
;
}
return
cx
-
>
names
(
)
.
empty
;
}
bool
JSFunction
:
:
getUnresolvedName
(
JSContext
*
cx
HandleFunction
fun
MutableHandleValue
v
)
{
if
(
fun
-
>
isBoundFunction
(
)
)
{
JSLinearString
*
name
=
JSFunction
:
:
getBoundFunctionName
(
cx
fun
)
;
if
(
!
name
)
{
return
false
;
}
v
.
setString
(
name
)
;
return
true
;
}
v
.
setString
(
fun
-
>
infallibleGetUnresolvedName
(
cx
)
)
;
return
true
;
}
JSLinearString
*
JSFunction
:
:
getBoundFunctionName
(
JSContext
*
cx
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isBoundFunction
(
)
)
;
JSAtom
*
name
=
fun
-
>
explicitName
(
)
;
MOZ_ASSERT
(
name
)
;
if
(
fun
-
>
hasBoundFunctionNamePrefix
(
)
)
{
return
name
;
}
size_t
boundTargets
=
0
;
for
(
JSFunction
*
boundFn
=
fun
;
boundFn
-
>
isBoundFunction
(
)
;
)
{
boundTargets
+
+
;
JSObject
*
target
=
boundFn
-
>
getBoundFunctionTarget
(
)
;
if
(
!
target
-
>
is
<
JSFunction
>
(
)
)
{
break
;
}
boundFn
=
&
target
-
>
as
<
JSFunction
>
(
)
;
}
if
(
name
-
>
empty
(
)
&
&
boundTargets
=
=
1
)
{
return
cx
-
>
names
(
)
.
boundWithSpace
;
}
static
constexpr
char
boundWithSpaceChars
[
]
=
"
bound
"
;
static
constexpr
size_t
boundWithSpaceCharsLength
=
js_strlen
(
boundWithSpaceChars
)
;
MOZ_ASSERT
(
StringEqualsAscii
(
cx
-
>
names
(
)
.
boundWithSpace
boundWithSpaceChars
)
)
;
JSStringBuilder
sb
(
cx
)
;
if
(
name
-
>
hasTwoByteChars
(
)
&
&
!
sb
.
ensureTwoByteChars
(
)
)
{
return
nullptr
;
}
CheckedInt
<
size_t
>
len
(
boundTargets
)
;
len
*
=
boundWithSpaceCharsLength
;
len
+
=
name
-
>
length
(
)
;
if
(
!
len
.
isValid
(
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
nullptr
;
}
if
(
!
sb
.
reserve
(
len
.
value
(
)
)
)
{
return
nullptr
;
}
while
(
boundTargets
-
-
)
{
sb
.
infallibleAppend
(
boundWithSpaceChars
boundWithSpaceCharsLength
)
;
}
sb
.
infallibleAppendSubstring
(
name
0
name
-
>
length
(
)
)
;
return
sb
.
finishString
(
)
;
}
static
const
js
:
:
Value
&
BoundFunctionEnvironmentSlotValue
(
const
JSFunction
*
fun
uint32_t
slotIndex
)
{
MOZ_ASSERT
(
fun
-
>
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
fun
-
>
environment
(
)
-
>
is
<
CallObject
>
(
)
)
;
CallObject
*
callObject
=
&
fun
-
>
environment
(
)
-
>
as
<
CallObject
>
(
)
;
return
callObject
-
>
getSlot
(
slotIndex
)
;
}
JSObject
*
JSFunction
:
:
getBoundFunctionTarget
(
)
const
{
js
:
:
Value
targetVal
=
BoundFunctionEnvironmentSlotValue
(
this
BoundFunctionEnvTargetSlot
)
;
MOZ_ASSERT
(
IsCallable
(
targetVal
)
)
;
return
&
targetVal
.
toObject
(
)
;
}
const
js
:
:
Value
&
JSFunction
:
:
getBoundFunctionThis
(
)
const
{
return
BoundFunctionEnvironmentSlotValue
(
this
BoundFunctionEnvThisSlot
)
;
}
static
ArrayObject
*
GetBoundFunctionArguments
(
const
JSFunction
*
boundFun
)
{
js
:
:
Value
argsVal
=
BoundFunctionEnvironmentSlotValue
(
boundFun
BoundFunctionEnvArgsSlot
)
;
return
&
argsVal
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
}
const
js
:
:
Value
&
JSFunction
:
:
getBoundFunctionArgument
(
unsigned
which
)
const
{
MOZ_ASSERT
(
which
<
getBoundFunctionArgumentCount
(
)
)
;
return
GetBoundFunctionArguments
(
this
)
-
>
getDenseElement
(
which
)
;
}
size_t
JSFunction
:
:
getBoundFunctionArgumentCount
(
)
const
{
return
GetBoundFunctionArguments
(
this
)
-
>
length
(
)
;
}
static
JSAtom
*
AppendBoundFunctionPrefix
(
JSContext
*
cx
JSString
*
str
)
{
static
constexpr
char
boundWithSpaceChars
[
]
=
"
bound
"
;
MOZ_ASSERT
(
StringEqualsAscii
(
cx
-
>
names
(
)
.
boundWithSpace
boundWithSpaceChars
)
)
;
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
boundWithSpaceChars
)
|
|
!
sb
.
append
(
str
)
)
{
return
nullptr
;
}
return
sb
.
finishAtom
(
)
;
}
bool
JSFunction
:
:
finishBoundFunctionInit
(
JSContext
*
cx
HandleFunction
bound
HandleObject
targetObj
int32_t
argCount
)
{
bound
-
>
setIsBoundFunction
(
)
;
MOZ_ASSERT
(
bound
-
>
getBoundFunctionTarget
(
)
=
=
targetObj
)
;
if
(
targetObj
-
>
isConstructor
(
)
)
{
bound
-
>
setIsConstructor
(
)
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototype
(
cx
targetObj
&
proto
)
)
{
return
false
;
}
if
(
bound
-
>
staticPrototype
(
)
!
=
proto
)
{
if
(
!
SetPrototype
(
cx
bound
proto
)
)
{
return
false
;
}
}
double
length
=
0
.
0
;
if
(
targetObj
-
>
is
<
JSFunction
>
(
)
&
&
!
targetObj
-
>
as
<
JSFunction
>
(
)
.
hasResolvedLength
(
)
)
{
RootedValue
targetLength
(
cx
)
;
if
(
!
JSFunction
:
:
getUnresolvedLength
(
cx
targetObj
.
as
<
JSFunction
>
(
)
&
targetLength
)
)
{
return
false
;
}
length
=
std
:
:
max
(
0
.
0
targetLength
.
toNumber
(
)
-
argCount
)
;
}
else
{
bool
hasLength
;
RootedId
idRoot
(
cx
NameToId
(
cx
-
>
names
(
)
.
length
)
)
;
if
(
!
HasOwnProperty
(
cx
targetObj
idRoot
&
hasLength
)
)
{
return
false
;
}
if
(
hasLength
)
{
RootedValue
targetLength
(
cx
)
;
if
(
!
GetProperty
(
cx
targetObj
targetObj
idRoot
&
targetLength
)
)
{
return
false
;
}
if
(
targetLength
.
isNumber
(
)
)
{
length
=
std
:
:
max
(
0
.
0
JS
:
:
ToInteger
(
targetLength
.
toNumber
(
)
)
-
argCount
)
;
}
}
}
bound
-
>
setExtendedSlot
(
FunctionExtended
:
:
BOUND_FUNCTION_LENGTH_SLOT
NumberValue
(
length
)
)
;
MOZ_ASSERT
(
!
bound
-
>
hasGuessedAtom
(
)
)
;
if
(
targetObj
-
>
is
<
JSFunction
>
(
)
&
&
!
targetObj
-
>
as
<
JSFunction
>
(
)
.
hasResolvedName
(
)
)
{
JSFunction
*
targetFn
=
&
targetObj
-
>
as
<
JSFunction
>
(
)
;
if
(
targetFn
-
>
isBoundFunction
(
)
&
&
targetFn
-
>
hasBoundFunctionNamePrefix
(
)
)
{
JSAtom
*
name
=
AppendBoundFunctionPrefix
(
cx
targetFn
-
>
explicitName
(
)
)
;
if
(
!
name
)
{
return
false
;
}
bound
-
>
setPrefixedBoundFunctionName
(
name
)
;
}
else
{
JSAtom
*
name
=
targetFn
-
>
infallibleGetUnresolvedName
(
cx
)
;
MOZ_ASSERT
(
name
)
;
bound
-
>
setAtom
(
name
)
;
}
}
else
{
RootedValue
targetName
(
cx
)
;
if
(
!
GetProperty
(
cx
targetObj
targetObj
cx
-
>
names
(
)
.
name
&
targetName
)
)
{
return
false
;
}
if
(
!
targetName
.
isString
(
)
)
{
targetName
.
setString
(
cx
-
>
names
(
)
.
empty
)
;
}
if
(
targetObj
-
>
is
<
JSFunction
>
(
)
&
&
targetObj
-
>
as
<
JSFunction
>
(
)
.
isBoundFunction
(
)
)
{
JSAtom
*
name
=
AppendBoundFunctionPrefix
(
cx
targetName
.
toString
(
)
)
;
if
(
!
name
)
{
return
false
;
}
bound
-
>
setPrefixedBoundFunctionName
(
name
)
;
}
else
{
JSAtom
*
name
=
AtomizeString
(
cx
targetName
.
toString
(
)
)
;
if
(
!
name
)
{
return
false
;
}
bound
-
>
setAtom
(
name
)
;
}
}
return
true
;
}
bool
JSFunction
:
:
delazifyLazilyInterpretedFunction
(
JSContext
*
cx
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
hasBaseScript
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
fun
-
>
compartment
(
)
)
;
AutoRealm
ar
(
cx
fun
)
;
Rooted
<
BaseScript
*
>
lazy
(
cx
fun
-
>
baseScript
(
)
)
;
RootedFunction
canonicalFun
(
cx
lazy
-
>
function
(
)
)
;
if
(
fun
!
=
canonicalFun
)
{
JSScript
*
script
=
JSFunction
:
:
getOrCreateScript
(
cx
canonicalFun
)
;
if
(
!
script
)
{
return
false
;
}
MOZ_ASSERT
(
fun
-
>
hasBytecode
(
)
)
;
return
true
;
}
MainThreadErrorContext
ec
(
cx
)
;
if
(
!
frontend
:
:
DelazifyCanonicalScriptedFunction
(
cx
&
ec
cx
-
>
stackLimitForCurrentPrincipal
(
)
fun
)
)
{
MOZ_ASSERT
(
fun
-
>
baseScript
(
)
=
=
lazy
)
;
MOZ_ASSERT
(
lazy
-
>
isReadyForDelazification
(
)
)
;
return
false
;
}
return
true
;
}
bool
JSFunction
:
:
delazifySelfHostedLazyFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
fun
-
>
compartment
(
)
)
;
AutoRealm
ar
(
cx
fun
)
;
MOZ_ASSERT
(
fun
-
>
isSelfHostedBuiltin
(
)
)
;
Rooted
<
PropertyName
*
>
funName
(
cx
GetClonedSelfHostedFunctionName
(
fun
)
)
;
if
(
!
funName
)
{
return
false
;
}
return
cx
-
>
runtime
(
)
-
>
delazifySelfHostedFunction
(
cx
funName
fun
)
;
}
void
JSFunction
:
:
maybeRelazify
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
!
isIncomplete
(
)
"
Cannot
relazify
incomplete
functions
"
)
;
Realm
*
realm
=
this
-
>
realm
(
)
;
if
(
!
rt
-
>
allowRelazificationForTesting
)
{
if
(
realm
-
>
compartment
(
)
-
>
gcState
.
hasEnteredRealm
)
{
return
;
}
MOZ_ASSERT
(
!
realm
-
>
hasBeenEnteredIgnoringJit
(
)
)
;
}
if
(
realm
-
>
isDebuggee
(
)
)
{
return
;
}
if
(
coverage
:
:
IsLCovEnabled
(
)
)
{
return
;
}
JSScript
*
script
=
nonLazyScript
(
)
;
if
(
!
script
-
>
allowRelazify
(
)
)
{
return
;
}
MOZ_ASSERT
(
script
-
>
isRelazifiable
(
)
)
;
if
(
script
-
>
hasJitScript
(
)
)
{
return
;
}
if
(
isSelfHostedBuiltin
(
)
)
{
gc
:
:
PreWriteBarrier
(
script
)
;
initSelfHostedLazyScript
(
&
rt
-
>
selfHostedLazyScript
.
ref
(
)
)
;
}
else
{
script
-
>
relazify
(
rt
)
;
}
}
js
:
:
GeneratorKind
JSFunction
:
:
clonedSelfHostedGeneratorKind
(
)
const
{
MOZ_ASSERT
(
hasSelfHostedLazyScript
(
)
)
;
MOZ_RELEASE_ASSERT
(
isExtended
(
)
)
;
PropertyName
*
name
=
GetClonedSelfHostedFunctionName
(
this
)
;
return
runtimeFromMainThread
(
)
-
>
getSelfHostedFunctionGeneratorKind
(
name
)
;
}
static
bool
CreateDynamicFunction
(
JSContext
*
cx
const
CallArgs
&
args
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
)
{
using
namespace
frontend
;
bool
isGenerator
=
generatorKind
=
=
GeneratorKind
:
:
Generator
;
bool
isAsync
=
asyncKind
=
=
FunctionAsyncKind
:
:
AsyncFunction
;
RootedScript
maybeScript
(
cx
)
;
const
char
*
filename
;
unsigned
lineno
;
bool
mutedErrors
;
uint32_t
pcOffset
;
DescribeScriptedCallerForCompilation
(
cx
&
maybeScript
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
const
char
*
introductionType
=
"
Function
"
;
if
(
isAsync
)
{
if
(
isGenerator
)
{
introductionType
=
"
AsyncGenerator
"
;
}
else
{
introductionType
=
"
AsyncFunction
"
;
}
}
else
if
(
isGenerator
)
{
introductionType
=
"
GeneratorFunction
"
;
}
const
char
*
introducerFilename
=
filename
;
if
(
maybeScript
&
&
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
)
{
introducerFilename
=
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
;
}
CompileOptions
options
(
cx
)
;
options
.
setMutedErrors
(
mutedErrors
)
.
setFileAndLine
(
filename
1
)
.
setNoScriptRval
(
false
)
.
setIntroductionInfo
(
introducerFilename
introductionType
lineno
pcOffset
)
.
setDeferDebugMetadata
(
)
;
JSStringBuilder
sb
(
cx
)
;
if
(
isAsync
)
{
if
(
!
sb
.
append
(
"
async
"
)
)
{
return
false
;
}
}
if
(
!
sb
.
append
(
"
function
"
)
)
{
return
false
;
}
if
(
isGenerator
)
{
if
(
!
sb
.
append
(
'
*
'
)
)
{
return
false
;
}
}
if
(
!
sb
.
append
(
"
anonymous
(
"
)
)
{
return
false
;
}
if
(
args
.
length
(
)
>
1
)
{
RootedString
str
(
cx
)
;
unsigned
n
=
args
.
length
(
)
-
1
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
{
str
=
ToString
<
CanGC
>
(
cx
args
[
i
]
)
;
if
(
!
str
)
{
return
false
;
}
if
(
!
sb
.
append
(
str
)
)
{
return
false
;
}
if
(
i
<
args
.
length
(
)
-
2
)
{
if
(
!
sb
.
append
(
'
'
)
)
{
return
false
;
}
}
}
}
if
(
!
sb
.
append
(
'
\
n
'
)
)
{
return
false
;
}
Maybe
<
uint32_t
>
parameterListEnd
=
Some
(
uint32_t
(
sb
.
length
(
)
)
)
;
static_assert
(
FunctionConstructorMedialSigils
[
0
]
=
=
'
)
'
)
;
if
(
!
sb
.
append
(
FunctionConstructorMedialSigils
.
data
(
)
FunctionConstructorMedialSigils
.
length
(
)
)
)
{
return
false
;
}
if
(
args
.
length
(
)
>
0
)
{
RootedString
body
(
cx
ToString
<
CanGC
>
(
cx
args
[
args
.
length
(
)
-
1
]
)
)
;
if
(
!
body
|
|
!
sb
.
append
(
body
)
)
{
return
false
;
}
}
if
(
!
sb
.
append
(
FunctionConstructorFinalBrace
.
data
(
)
FunctionConstructorFinalBrace
.
length
(
)
)
)
{
return
false
;
}
if
(
!
sb
.
ensureTwoByteChars
(
)
)
{
return
false
;
}
RootedString
functionText
(
cx
sb
.
finishString
(
)
)
;
if
(
!
functionText
)
{
return
false
;
}
if
(
!
cx
-
>
isRuntimeCodeGenEnabled
(
JS
:
:
RuntimeCode
:
:
JS
functionText
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CSP_BLOCKED_FUNCTION
)
;
return
false
;
}
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
functionText
)
)
{
return
false
;
}
mozilla
:
:
Range
<
const
char16_t
>
chars
=
stableChars
.
twoByteRange
(
)
;
SourceOwnership
ownership
=
stableChars
.
maybeGiveOwnershipToCaller
(
)
?
SourceOwnership
:
:
TakeOwnership
:
SourceOwnership
:
:
Borrowed
;
SourceText
<
char16_t
>
srcBuf
;
if
(
!
srcBuf
.
init
(
cx
chars
.
begin
(
)
.
get
(
)
chars
.
length
(
)
ownership
)
)
{
return
false
;
}
FunctionSyntaxKind
syntaxKind
=
FunctionSyntaxKind
:
:
Expression
;
RootedFunction
fun
(
cx
)
;
JSProtoKey
protoKey
;
if
(
isAsync
)
{
if
(
isGenerator
)
{
fun
=
CompileStandaloneAsyncGenerator
(
cx
options
srcBuf
parameterListEnd
syntaxKind
)
;
protoKey
=
JSProto_AsyncGeneratorFunction
;
}
else
{
fun
=
CompileStandaloneAsyncFunction
(
cx
options
srcBuf
parameterListEnd
syntaxKind
)
;
protoKey
=
JSProto_AsyncFunction
;
}
}
else
{
if
(
isGenerator
)
{
fun
=
CompileStandaloneGenerator
(
cx
options
srcBuf
parameterListEnd
syntaxKind
)
;
protoKey
=
JSProto_GeneratorFunction
;
}
else
{
fun
=
CompileStandaloneFunction
(
cx
options
srcBuf
parameterListEnd
syntaxKind
)
;
protoKey
=
JSProto_Function
;
}
}
if
(
!
fun
)
{
return
false
;
}
RootedValue
undefValue
(
cx
)
;
RootedScript
funScript
(
cx
JS_GetFunctionScript
(
cx
fun
)
)
;
JS
:
:
InstantiateOptions
instantiateOptions
(
options
)
;
if
(
funScript
&
&
!
UpdateDebugMetadata
(
cx
funScript
instantiateOptions
undefValue
nullptr
maybeScript
maybeScript
)
)
{
return
false
;
}
if
(
fun
-
>
isInterpreted
(
)
)
{
fun
-
>
initEnvironment
(
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
protoKey
&
proto
)
)
{
return
false
;
}
if
(
proto
&
&
!
SetPrototype
(
cx
fun
proto
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
fun
)
;
return
true
;
}
bool
js
:
:
Function
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CreateDynamicFunction
(
cx
args
GeneratorKind
:
:
NotGenerator
FunctionAsyncKind
:
:
SyncFunction
)
;
}
bool
js
:
:
Generator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CreateDynamicFunction
(
cx
args
GeneratorKind
:
:
Generator
FunctionAsyncKind
:
:
SyncFunction
)
;
}
bool
js
:
:
AsyncFunctionConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CreateDynamicFunction
(
cx
args
GeneratorKind
:
:
NotGenerator
FunctionAsyncKind
:
:
AsyncFunction
)
;
}
bool
js
:
:
AsyncGeneratorConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CreateDynamicFunction
(
cx
args
GeneratorKind
:
:
Generator
FunctionAsyncKind
:
:
AsyncFunction
)
;
}
bool
JSFunction
:
:
isBuiltinFunctionConstructor
(
)
{
return
maybeNative
(
)
=
=
Function
|
|
maybeNative
(
)
=
=
Generator
;
}
bool
JSFunction
:
:
needsExtraBodyVarEnvironment
(
)
const
{
if
(
isNativeFun
(
)
)
{
return
false
;
}
if
(
!
nonLazyScript
(
)
-
>
functionHasExtraBodyVarScope
(
)
)
{
return
false
;
}
return
nonLazyScript
(
)
-
>
functionExtraBodyVarScope
(
)
-
>
hasEnvironment
(
)
;
}
bool
JSFunction
:
:
needsNamedLambdaEnvironment
(
)
const
{
if
(
!
isNamedLambda
(
)
)
{
return
false
;
}
LexicalScope
*
scope
=
nonLazyScript
(
)
-
>
maybeNamedLambdaScope
(
)
;
if
(
!
scope
)
{
return
false
;
}
return
scope
-
>
hasEnvironment
(
)
;
}
bool
JSFunction
:
:
needsCallObject
(
)
const
{
if
(
isNativeFun
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
hasBytecode
(
)
)
;
MOZ_ASSERT_IF
(
baseScript
(
)
-
>
funHasExtensibleScope
(
)
|
|
isGenerator
(
)
|
|
isAsync
(
)
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
)
;
return
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
;
}
#
ifdef
DEBUG
static
JSObject
*
SkipEnvironmentObjects
(
JSObject
*
env
)
{
if
(
!
env
)
{
return
nullptr
;
}
while
(
env
-
>
is
<
EnvironmentObject
>
(
)
)
{
env
=
&
env
-
>
as
<
EnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
}
return
env
;
}
static
bool
NewFunctionEnvironmentIsWellFormed
(
JSContext
*
cx
HandleObject
env
)
{
RootedObject
terminatingEnv
(
cx
SkipEnvironmentObjects
(
env
)
)
;
return
!
terminatingEnv
|
|
terminatingEnv
=
=
cx
-
>
global
(
)
|
|
terminatingEnv
-
>
is
<
DebugEnvironmentProxy
>
(
)
;
}
#
endif
static
inline
const
JSClass
*
FunctionClassForAllocKind
(
gc
:
:
AllocKind
allocKind
)
{
return
(
allocKind
=
=
gc
:
:
AllocKind
:
:
FUNCTION
)
?
FunctionClassPtr
:
FunctionExtendedClassPtr
;
}
static
void
AssertClassMatchesAllocKind
(
const
JSClass
*
clasp
gc
:
:
AllocKind
kind
)
{
#
ifdef
DEBUG
if
(
kind
=
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
{
MOZ_ASSERT
(
clasp
=
=
FunctionExtendedClassPtr
)
;
}
else
{
MOZ_ASSERT
(
kind
=
=
gc
:
:
AllocKind
:
:
FUNCTION
)
;
MOZ_ASSERT
(
clasp
=
=
FunctionClassPtr
)
;
}
#
endif
}
static
Shape
*
GetFunctionShape
(
JSContext
*
cx
const
JSClass
*
clasp
JSObject
*
proto
gc
:
:
AllocKind
allocKind
)
{
AssertClassMatchesAllocKind
(
clasp
allocKind
)
;
size_t
nfixed
=
GetGCKindSlots
(
allocKind
)
;
return
SharedShape
:
:
getInitialShape
(
cx
clasp
cx
-
>
realm
(
)
TaggedProto
(
proto
)
nfixed
ObjectFlags
(
)
)
;
}
Shape
*
GlobalObject
:
:
createFunctionShapeWithDefaultProto
(
JSContext
*
cx
bool
extended
)
{
GlobalObjectData
&
data
=
cx
-
>
global
(
)
-
>
data
(
)
;
HeapPtr
<
Shape
*
>
&
shapeRef
=
extended
?
data
.
extendedFunctionShapeWithDefaultProto
:
data
.
functionShapeWithDefaultProto
;
MOZ_ASSERT
(
!
shapeRef
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_Function
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
if
(
shapeRef
)
{
return
shapeRef
;
}
gc
:
:
AllocKind
allocKind
=
extended
?
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
:
gc
:
:
AllocKind
:
:
FUNCTION
;
const
JSClass
*
clasp
=
FunctionClassForAllocKind
(
allocKind
)
;
Shape
*
shape
=
GetFunctionShape
(
cx
clasp
proto
allocKind
)
;
if
(
!
shape
)
{
return
nullptr
;
}
shapeRef
.
init
(
shape
)
;
return
shape
;
}
JSFunction
*
js
:
:
NewFunctionWithProto
(
JSContext
*
cx
Native
native
unsigned
nargs
FunctionFlags
flags
HandleObject
enclosingEnv
Handle
<
JSAtom
*
>
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
MOZ_ASSERT
(
allocKind
=
=
gc
:
:
AllocKind
:
:
FUNCTION
|
|
allocKind
=
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
;
MOZ_ASSERT_IF
(
native
!
enclosingEnv
)
;
MOZ_ASSERT
(
NewFunctionEnvironmentIsWellFormed
(
cx
enclosingEnv
)
)
;
const
JSClass
*
clasp
=
FunctionClassForAllocKind
(
allocKind
)
;
Rooted
<
Shape
*
>
shape
(
cx
)
;
if
(
!
proto
)
{
bool
extended
=
(
allocKind
=
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
;
shape
=
GlobalObject
:
:
getFunctionShapeWithDefaultProto
(
cx
extended
)
;
}
else
{
shape
=
GetFunctionShape
(
cx
clasp
proto
allocKind
)
;
}
if
(
!
shape
)
{
return
nullptr
;
}
gc
:
:
InitialHeap
heap
=
GetInitialHeap
(
newKind
clasp
)
;
JSFunction
*
fun
=
JSFunction
:
:
create
(
cx
allocKind
heap
shape
)
;
if
(
!
fun
)
{
return
nullptr
;
}
if
(
allocKind
=
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
{
flags
.
setIsExtended
(
)
;
}
MOZ_ASSERT
(
!
flags
.
hasSelfHostedLazyScript
(
)
)
;
MOZ_ASSERT
(
!
flags
.
isWasmWithJitEntry
(
)
)
;
fun
-
>
setArgCount
(
uint16_t
(
nargs
)
)
;
fun
-
>
setFlags
(
flags
)
;
if
(
fun
-
>
isInterpreted
(
)
)
{
fun
-
>
initScript
(
nullptr
)
;
fun
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
{
MOZ_ASSERT
(
fun
-
>
isNativeFun
(
)
)
;
fun
-
>
initNative
(
native
nullptr
)
;
}
fun
-
>
initAtom
(
atom
)
;
return
fun
;
}
bool
js
:
:
GetFunctionPrototype
(
JSContext
*
cx
js
:
:
GeneratorKind
generatorKind
js
:
:
FunctionAsyncKind
asyncKind
js
:
:
MutableHandleObject
proto
)
{
if
(
generatorKind
=
=
js
:
:
GeneratorKind
:
:
NotGenerator
)
{
if
(
asyncKind
=
=
js
:
:
FunctionAsyncKind
:
:
SyncFunction
)
{
proto
.
set
(
nullptr
)
;
return
true
;
}
proto
.
set
(
GlobalObject
:
:
getOrCreateAsyncFunctionPrototype
(
cx
cx
-
>
global
(
)
)
)
;
}
else
{
if
(
asyncKind
=
=
js
:
:
FunctionAsyncKind
:
:
SyncFunction
)
{
proto
.
set
(
GlobalObject
:
:
getOrCreateGeneratorFunctionPrototype
(
cx
cx
-
>
global
(
)
)
)
;
}
else
{
proto
.
set
(
GlobalObject
:
:
getOrCreateAsyncGenerator
(
cx
cx
-
>
global
(
)
)
)
;
}
}
return
!
!
proto
;
}
bool
js
:
:
CanReuseScriptForClone
(
JS
:
:
Realm
*
realm
HandleFunction
fun
HandleObject
newEnclosingEnv
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
if
(
realm
!
=
fun
-
>
realm
(
)
)
{
return
false
;
}
if
(
newEnclosingEnv
-
>
is
<
GlobalObject
>
(
)
)
{
return
true
;
}
if
(
IsSyntacticEnvironment
(
newEnclosingEnv
)
)
{
return
true
;
}
BaseScript
*
script
=
fun
-
>
baseScript
(
)
;
return
script
-
>
hasNonSyntacticScope
(
)
|
|
script
-
>
enclosingScope
(
)
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
;
}
static
inline
JSFunction
*
NewFunctionClone
(
JSContext
*
cx
HandleFunction
fun
HandleObject
proto
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
fun
-
>
realm
(
)
)
;
MOZ_ASSERT
(
proto
)
;
const
JSClass
*
clasp
=
fun
-
>
getClass
(
)
;
gc
:
:
AllocKind
allocKind
=
fun
-
>
getAllocKind
(
)
;
AssertClassMatchesAllocKind
(
clasp
allocKind
)
;
Rooted
<
Shape
*
>
shape
(
cx
)
;
if
(
fun
-
>
staticPrototype
(
)
=
=
proto
)
{
MOZ_ASSERT
(
fun
-
>
shape
(
)
-
>
propMapLength
(
)
=
=
0
)
;
MOZ_ASSERT
(
fun
-
>
shape
(
)
-
>
objectFlags
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
fun
-
>
shape
(
)
-
>
realm
(
)
=
=
cx
-
>
realm
(
)
)
;
shape
=
fun
-
>
shape
(
)
;
}
else
{
shape
=
GetFunctionShape
(
cx
clasp
proto
allocKind
)
;
if
(
!
shape
)
{
return
nullptr
;
}
}
JSFunction
*
clone
=
JSFunction
:
:
create
(
cx
allocKind
gc
:
:
DefaultHeap
shape
)
;
if
(
!
clone
)
{
return
nullptr
;
}
constexpr
uint16_t
NonCloneableFlags
=
FunctionFlags
:
:
RESOLVED_LENGTH
|
FunctionFlags
:
:
RESOLVED_NAME
;
FunctionFlags
flags
=
fun
-
>
flags
(
)
;
flags
.
clearFlags
(
NonCloneableFlags
)
;
clone
-
>
setArgCount
(
fun
-
>
nargs
(
)
)
;
clone
-
>
setFlags
(
flags
)
;
clone
-
>
initAtom
(
fun
-
>
displayAtom
(
)
)
;
return
clone
;
}
JSFunction
*
js
:
:
CloneFunctionReuseScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
HandleObject
proto
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
fun
-
>
realm
(
)
)
;
MOZ_ASSERT
(
NewFunctionEnvironmentIsWellFormed
(
cx
enclosingEnv
)
)
;
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
CanReuseScriptForClone
(
cx
-
>
realm
(
)
fun
enclosingEnv
)
)
;
RootedFunction
clone
(
cx
NewFunctionClone
(
cx
fun
proto
)
)
;
if
(
!
clone
)
{
return
nullptr
;
}
if
(
fun
-
>
hasBaseScript
(
)
)
{
BaseScript
*
base
=
fun
-
>
baseScript
(
)
;
clone
-
>
initScript
(
base
)
;
clone
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
{
MOZ_ASSERT
(
fun
-
>
hasSelfHostedLazyScript
(
)
)
;
SelfHostedLazyScript
*
lazy
=
fun
-
>
selfHostedLazyScript
(
)
;
clone
-
>
initSelfHostedLazyScript
(
lazy
)
;
clone
-
>
initEnvironment
(
enclosingEnv
)
;
}
#
ifdef
DEBUG
if
(
fun
-
>
isExtended
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
FunctionExtended
:
:
NUM_EXTENDED_SLOTS
;
i
+
+
)
{
MOZ_ASSERT
(
fun
-
>
getExtendedSlot
(
i
)
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
clone
-
>
getExtendedSlot
(
i
)
.
isUndefined
(
)
)
;
}
}
#
endif
return
clone
;
}
JSFunction
*
js
:
:
CloneAsmJSModuleFunction
(
JSContext
*
cx
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isNativeFun
(
)
)
;
MOZ_ASSERT
(
IsAsmJSModule
(
fun
)
)
;
MOZ_ASSERT
(
fun
-
>
isExtended
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
fun
-
>
compartment
(
)
)
;
RootedObject
proto
(
cx
fun
-
>
staticPrototype
(
)
)
;
JSFunction
*
clone
=
NewFunctionClone
(
cx
fun
proto
)
;
if
(
!
clone
)
{
return
nullptr
;
}
MOZ_ASSERT
(
fun
-
>
native
(
)
=
=
InstantiateAsmJS
)
;
MOZ_ASSERT
(
!
fun
-
>
hasJitInfo
(
)
)
;
clone
-
>
initNative
(
InstantiateAsmJS
nullptr
)
;
JSObject
*
moduleObj
=
&
fun
-
>
getExtendedSlot
(
FunctionExtended
:
:
ASMJS_MODULE_SLOT
)
.
toObject
(
)
;
clone
-
>
initExtendedSlot
(
FunctionExtended
:
:
ASMJS_MODULE_SLOT
ObjectValue
(
*
moduleObj
)
)
;
return
clone
;
}
static
JSAtom
*
SymbolToFunctionName
(
JSContext
*
cx
JS
:
:
Symbol
*
symbol
FunctionPrefixKind
prefixKind
)
{
JSAtom
*
desc
=
symbol
-
>
description
(
)
;
if
(
!
desc
&
&
prefixKind
=
=
FunctionPrefixKind
:
:
None
)
{
return
cx
-
>
names
(
)
.
empty
;
}
StringBuffer
sb
(
cx
)
;
if
(
prefixKind
=
=
FunctionPrefixKind
:
:
Get
)
{
if
(
!
sb
.
append
(
"
get
"
)
)
{
return
nullptr
;
}
}
else
if
(
prefixKind
=
=
FunctionPrefixKind
:
:
Set
)
{
if
(
!
sb
.
append
(
"
set
"
)
)
{
return
nullptr
;
}
}
if
(
desc
)
{
if
(
symbol
-
>
isPrivateName
(
)
)
{
if
(
!
sb
.
append
(
desc
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
sb
.
append
(
'
[
'
)
|
|
!
sb
.
append
(
desc
)
|
|
!
sb
.
append
(
'
]
'
)
)
{
return
nullptr
;
}
}
}
return
sb
.
finishAtom
(
)
;
}
static
JSAtom
*
NameToFunctionName
(
JSContext
*
cx
HandleValue
name
FunctionPrefixKind
prefixKind
)
{
MOZ_ASSERT
(
name
.
isString
(
)
|
|
name
.
isNumeric
(
)
)
;
if
(
prefixKind
=
=
FunctionPrefixKind
:
:
None
)
{
return
ToAtom
<
CanGC
>
(
cx
name
)
;
}
JSString
*
nameStr
=
ToString
(
cx
name
)
;
if
(
!
nameStr
)
{
return
nullptr
;
}
StringBuffer
sb
(
cx
)
;
if
(
prefixKind
=
=
FunctionPrefixKind
:
:
Get
)
{
if
(
!
sb
.
append
(
"
get
"
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
sb
.
append
(
"
set
"
)
)
{
return
nullptr
;
}
}
if
(
!
sb
.
append
(
nameStr
)
)
{
return
nullptr
;
}
return
sb
.
finishAtom
(
)
;
}
JSAtom
*
js
:
:
IdToFunctionName
(
JSContext
*
cx
HandleId
id
FunctionPrefixKind
prefixKind
)
{
MOZ_ASSERT
(
id
.
isString
(
)
|
|
id
.
isSymbol
(
)
|
|
id
.
isInt
(
)
)
;
if
(
id
.
isAtom
(
)
&
&
prefixKind
=
=
FunctionPrefixKind
:
:
None
)
{
return
id
.
toAtom
(
)
;
}
if
(
id
.
isSymbol
(
)
)
{
return
SymbolToFunctionName
(
cx
id
.
toSymbol
(
)
prefixKind
)
;
}
RootedValue
idv
(
cx
IdToValue
(
id
)
)
;
return
NameToFunctionName
(
cx
idv
prefixKind
)
;
}
bool
js
:
:
SetFunctionName
(
JSContext
*
cx
HandleFunction
fun
HandleValue
name
FunctionPrefixKind
prefixKind
)
{
MOZ_ASSERT
(
name
.
isString
(
)
|
|
name
.
isSymbol
(
)
|
|
name
.
isNumeric
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
hasInferredName
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
containsPure
(
cx
-
>
names
(
)
.
name
)
)
;
MOZ_ASSERT
(
!
fun
-
>
hasResolvedName
(
)
)
;
JSAtom
*
funName
=
name
.
isSymbol
(
)
?
SymbolToFunctionName
(
cx
name
.
toSymbol
(
)
prefixKind
)
:
NameToFunctionName
(
cx
name
prefixKind
)
;
if
(
!
funName
)
{
return
false
;
}
fun
-
>
setInferredName
(
funName
)
;
return
true
;
}
JSFunction
*
js
:
:
DefineFunction
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Native
native
unsigned
nargs
unsigned
flags
gc
:
:
AllocKind
allocKind
)
{
Rooted
<
JSAtom
*
>
atom
(
cx
IdToFunctionName
(
cx
id
)
)
;
if
(
!
atom
)
{
return
nullptr
;
}
MOZ_ASSERT
(
native
)
;
RootedFunction
fun
(
cx
)
;
if
(
flags
&
JSFUN_CONSTRUCTOR
)
{
fun
=
NewNativeConstructor
(
cx
native
nargs
atom
allocKind
)
;
}
else
{
fun
=
NewNativeFunction
(
cx
native
nargs
atom
allocKind
)
;
}
if
(
!
fun
)
{
return
nullptr
;
}
RootedValue
funVal
(
cx
ObjectValue
(
*
fun
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
id
funVal
flags
&
~
JSFUN_FLAGS_MASK
)
)
{
return
nullptr
;
}
return
fun
;
}
void
js
:
:
ReportIncompatibleMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
JSClass
*
clasp
)
{
RootedValue
thisv
(
cx
args
.
thisv
(
)
)
;
#
ifdef
DEBUG
switch
(
thisv
.
type
(
)
)
{
case
ValueType
:
:
Object
:
MOZ_ASSERT
(
thisv
.
toObject
(
)
.
getClass
(
)
!
=
clasp
|
|
!
thisv
.
toObject
(
)
.
is
<
NativeObject
>
(
)
|
|
!
thisv
.
toObject
(
)
.
staticPrototype
(
)
|
|
thisv
.
toObject
(
)
.
staticPrototype
(
)
-
>
getClass
(
)
!
=
clasp
)
;
break
;
#
ifdef
ENABLE_RECORD_TUPLE
case
ValueType
:
:
ExtendedPrimitive
:
MOZ_CRASH
(
"
ExtendedPrimitive
is
not
supported
yet
"
)
;
break
;
#
endif
case
ValueType
:
:
String
:
MOZ_ASSERT
(
clasp
!
=
&
StringObject
:
:
class_
)
;
break
;
case
ValueType
:
:
Double
:
case
ValueType
:
:
Int32
:
MOZ_ASSERT
(
clasp
!
=
&
NumberObject
:
:
class_
)
;
break
;
case
ValueType
:
:
Boolean
:
MOZ_ASSERT
(
clasp
!
=
&
BooleanObject
:
:
class_
)
;
break
;
case
ValueType
:
:
Symbol
:
MOZ_ASSERT
(
clasp
!
=
&
SymbolObject
:
:
class_
)
;
break
;
case
ValueType
:
:
BigInt
:
MOZ_ASSERT
(
clasp
!
=
&
BigIntObject
:
:
class_
)
;
break
;
case
ValueType
:
:
Undefined
:
case
ValueType
:
:
Null
:
break
;
case
ValueType
:
:
Magic
:
case
ValueType
:
:
PrivateGCThing
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
#
endif
if
(
JSFunction
*
fun
=
ReportIfNotFunction
(
cx
args
.
calleev
(
)
)
)
{
UniqueChars
funNameBytes
;
if
(
const
char
*
funName
=
GetFunctionNameBytes
(
cx
fun
&
funNameBytes
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
clasp
-
>
name
funName
InformalValueTypeName
(
thisv
)
)
;
}
}
}
void
js
:
:
ReportIncompatible
(
JSContext
*
cx
const
CallArgs
&
args
)
{
if
(
JSFunction
*
fun
=
ReportIfNotFunction
(
cx
args
.
calleev
(
)
)
)
{
UniqueChars
funNameBytes
;
if
(
const
char
*
funName
=
GetFunctionNameBytes
(
cx
fun
&
funNameBytes
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_METHOD
funName
"
method
"
InformalValueTypeName
(
args
.
thisv
(
)
)
)
;
}
}
}
namespace
JS
{
namespace
detail
{
JS_PUBLIC_API
void
CheckIsValidConstructible
(
const
Value
&
calleev
)
{
MOZ_ASSERT
(
calleev
.
toObject
(
)
.
isConstructor
(
)
)
;
}
}
}
