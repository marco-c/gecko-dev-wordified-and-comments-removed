#
ifndef
vm_Shape_h
#
define
vm_Shape_h
#
include
"
js
/
shadow
/
Shape
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
<
algorithm
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
MaybeRooted
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
util
/
EnumFlags
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
MOZ_ALWAYS_INLINE
size_t
JSSLOT_FREE
(
const
JSClass
*
clasp
)
{
MOZ_ASSERT
(
!
clasp
-
>
isProxyObject
(
)
)
;
return
JSCLASS_RESERVED_SLOTS
(
clasp
)
;
}
namespace
js
{
static
constexpr
uint32_t
SHAPE_INVALID_SLOT
=
Bit
(
24
)
-
1
;
static
constexpr
uint32_t
SHAPE_MAXIMUM_SLOT
=
Bit
(
24
)
-
2
;
class
Shape
;
struct
StackShape
;
enum
class
ShapePropertyFlag
:
uint8_t
{
Configurable
=
1
<
<
0
Enumerable
=
1
<
<
1
Writable
=
1
<
<
2
AccessorProperty
=
1
<
<
3
CustomDataProperty
=
1
<
<
4
}
;
class
ShapePropertyFlags
:
public
EnumFlags
<
ShapePropertyFlag
>
{
using
Base
=
EnumFlags
<
ShapePropertyFlag
>
;
using
Base
:
:
Base
;
public
:
static
const
ShapePropertyFlags
defaultDataPropFlags
;
static
ShapePropertyFlags
fromRaw
(
uint8_t
flags
)
{
return
ShapePropertyFlags
(
flags
)
;
}
bool
configurable
(
)
const
{
return
hasFlag
(
ShapePropertyFlag
:
:
Configurable
)
;
}
bool
enumerable
(
)
const
{
return
hasFlag
(
ShapePropertyFlag
:
:
Enumerable
)
;
}
bool
writable
(
)
const
{
MOZ_ASSERT
(
isDataDescriptor
(
)
)
;
return
hasFlag
(
ShapePropertyFlag
:
:
Writable
)
;
}
bool
isDataProperty
(
)
const
{
return
!
isAccessorProperty
(
)
&
&
!
isCustomDataProperty
(
)
;
}
bool
isAccessorProperty
(
)
const
{
return
hasFlag
(
ShapePropertyFlag
:
:
AccessorProperty
)
;
}
bool
isCustomDataProperty
(
)
const
{
return
hasFlag
(
ShapePropertyFlag
:
:
CustomDataProperty
)
;
}
bool
isDataDescriptor
(
)
const
{
return
!
isAccessorProperty
(
)
;
}
}
;
constexpr
ShapePropertyFlags
ShapePropertyFlags
:
:
defaultDataPropFlags
=
{
ShapePropertyFlag
:
:
Configurable
ShapePropertyFlag
:
:
Enumerable
ShapePropertyFlag
:
:
Writable
}
;
class
ShapeProperty
{
static
constexpr
uint32_t
FlagsMask
=
0xff
;
static
constexpr
uint32_t
SlotShift
=
8
;
uint32_t
slotAndFlags_
=
0
;
static_assert
(
SHAPE_INVALID_SLOT
<
=
(
UINT32_MAX
>
>
SlotShift
)
"
SHAPE_INVALID_SLOT
must
fit
in
slotAndFlags_
"
)
;
static_assert
(
SHAPE_MAXIMUM_SLOT
<
=
(
UINT32_MAX
>
>
SlotShift
)
"
SHAPE_MAXIMUM_SLOT
must
fit
in
slotAndFlags_
"
)
;
public
:
ShapeProperty
(
ShapePropertyFlags
flags
uint32_t
slot
)
:
slotAndFlags_
(
(
slot
<
<
SlotShift
)
|
flags
.
toRaw
(
)
)
{
MOZ_ASSERT
(
maybeSlot
(
)
=
=
slot
)
;
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
flags
)
;
}
ShapeProperty
(
const
ShapeProperty
&
other
)
=
default
;
bool
isDataProperty
(
)
const
{
return
flags
(
)
.
isDataProperty
(
)
;
}
bool
isCustomDataProperty
(
)
const
{
return
flags
(
)
.
isCustomDataProperty
(
)
;
}
bool
isAccessorProperty
(
)
const
{
return
flags
(
)
.
isAccessorProperty
(
)
;
}
bool
isDataDescriptor
(
)
const
{
return
flags
(
)
.
isDataDescriptor
(
)
;
}
bool
hasSlot
(
)
const
{
return
!
isCustomDataProperty
(
)
;
}
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
hasSlot
(
)
)
;
MOZ_ASSERT
(
maybeSlot
(
)
<
SHAPE_INVALID_SLOT
)
;
return
maybeSlot
(
)
;
}
uint32_t
maybeSlot
(
)
const
{
return
slotAndFlags_
>
>
SlotShift
;
}
ShapePropertyFlags
flags
(
)
const
{
return
ShapePropertyFlags
:
:
fromRaw
(
slotAndFlags_
&
FlagsMask
)
;
}
bool
writable
(
)
const
{
return
flags
(
)
.
writable
(
)
;
}
bool
configurable
(
)
const
{
return
flags
(
)
.
configurable
(
)
;
}
bool
enumerable
(
)
const
{
return
flags
(
)
.
enumerable
(
)
;
}
JS
:
:
PropertyAttributes
propAttributes
(
)
const
{
JS
:
:
PropertyAttributes
attrs
{
}
;
if
(
configurable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Configurable
;
}
if
(
enumerable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Enumerable
;
}
if
(
isDataDescriptor
(
)
&
&
writable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Writable
;
}
return
attrs
;
}
bool
operator
=
=
(
const
ShapeProperty
&
other
)
const
{
return
slotAndFlags_
=
=
other
.
slotAndFlags_
;
}
bool
operator
!
=
(
const
ShapeProperty
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
}
;
class
ShapePropertyWithKey
:
public
ShapeProperty
{
PropertyKey
key_
;
public
:
ShapePropertyWithKey
(
ShapePropertyFlags
flags
uint32_t
slot
PropertyKey
key
)
:
ShapeProperty
(
flags
slot
)
key_
(
key
)
{
}
PropertyKey
key
(
)
const
{
return
key_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
key_
"
ShapePropertyWithKey
-
key
"
)
;
}
}
;
template
<
class
Wrapper
>
class
WrappedPtrOperations
<
ShapePropertyWithKey
Wrapper
>
{
const
ShapePropertyWithKey
&
value
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isDataProperty
(
)
const
{
return
value
(
)
.
isDataProperty
(
)
;
}
uint32_t
slot
(
)
const
{
return
value
(
)
.
slot
(
)
;
}
PropertyKey
key
(
)
const
{
return
value
(
)
.
key
(
)
;
}
ShapePropertyFlags
flags
(
)
const
{
return
value
(
)
.
flags
(
)
;
}
}
;
struct
ShapeHasher
:
public
DefaultHasher
<
Shape
*
>
{
using
Key
=
Shape
*
;
using
Lookup
=
StackShape
;
static
MOZ_ALWAYS_INLINE
HashNumber
hash
(
const
Lookup
&
l
)
;
static
MOZ_ALWAYS_INLINE
bool
match
(
Key
k
const
Lookup
&
l
)
;
}
;
using
ShapeSet
=
HashSet
<
Shape
*
ShapeHasher
SystemAllocPolicy
>
;
class
ShapeChildren
{
enum
{
SINGLE_SHAPE
=
0
SHAPE_SET
=
1
MASK
=
3
}
;
uintptr_t
bits
=
0
;
public
:
bool
isNone
(
)
const
{
return
!
bits
;
}
void
setNone
(
)
{
bits
=
0
;
}
bool
isSingleShape
(
)
const
{
return
(
bits
&
MASK
)
=
=
SINGLE_SHAPE
&
&
!
isNone
(
)
;
}
Shape
*
toSingleShape
(
)
const
{
MOZ_ASSERT
(
isSingleShape
(
)
)
;
return
reinterpret_cast
<
Shape
*
>
(
bits
&
~
uintptr_t
(
MASK
)
)
;
}
void
setSingleShape
(
Shape
*
shape
)
{
MOZ_ASSERT
(
shape
)
;
MOZ_ASSERT
(
(
uintptr_t
(
shape
)
&
MASK
)
=
=
0
)
;
bits
=
uintptr_t
(
shape
)
|
SINGLE_SHAPE
;
}
bool
isShapeSet
(
)
const
{
return
(
bits
&
MASK
)
=
=
SHAPE_SET
;
}
ShapeSet
*
toShapeSet
(
)
const
{
MOZ_ASSERT
(
isShapeSet
(
)
)
;
return
reinterpret_cast
<
ShapeSet
*
>
(
bits
&
~
uintptr_t
(
MASK
)
)
;
}
void
setShapeSet
(
ShapeSet
*
hash
)
{
MOZ_ASSERT
(
hash
)
;
MOZ_ASSERT
(
(
uintptr_t
(
hash
)
&
MASK
)
=
=
0
)
;
bits
=
uintptr_t
(
hash
)
|
SHAPE_SET
;
}
#
ifdef
DEBUG
void
checkHasChild
(
Shape
*
child
)
const
;
#
endif
}
JS_HAZ_GC_POINTER
;
class
DictionaryShapeLink
{
enum
{
SHAPE
=
2
MASK
=
3
}
;
uintptr_t
bits
=
0
;
public
:
DictionaryShapeLink
(
)
{
}
explicit
DictionaryShapeLink
(
Shape
*
shape
)
{
setShape
(
shape
)
;
}
bool
isNone
(
)
const
{
return
!
bits
;
}
void
setNone
(
)
{
bits
=
0
;
}
bool
isShape
(
)
const
{
return
(
bits
&
MASK
)
=
=
SHAPE
;
}
Shape
*
toShape
(
)
const
{
MOZ_ASSERT
(
isShape
(
)
)
;
return
reinterpret_cast
<
Shape
*
>
(
bits
&
~
uintptr_t
(
MASK
)
)
;
}
void
setShape
(
Shape
*
shape
)
{
MOZ_ASSERT
(
shape
)
;
MOZ_ASSERT
(
(
uintptr_t
(
shape
)
&
MASK
)
=
=
0
)
;
bits
=
uintptr_t
(
shape
)
|
SHAPE
;
}
bool
operator
=
=
(
const
DictionaryShapeLink
&
other
)
const
{
return
bits
=
=
other
.
bits
;
}
bool
operator
!
=
(
const
DictionaryShapeLink
&
other
)
const
{
return
!
(
(
*
this
)
=
=
other
)
;
}
}
JS_HAZ_GC_POINTER
;
class
PropertyTree
{
friend
class
:
:
JSFunction
;
#
ifdef
DEBUG
JS
:
:
Zone
*
zone_
;
#
endif
bool
insertChild
(
JSContext
*
cx
Shape
*
parent
Shape
*
child
)
;
PropertyTree
(
)
;
public
:
enum
{
MAX_HEIGHT
=
512
MAX_HEIGHT_WITH_ELEMENTS_ACCESS
=
128
}
;
explicit
PropertyTree
(
JS
:
:
Zone
*
zone
)
#
ifdef
DEBUG
:
zone_
(
zone
)
#
endif
{
}
MOZ_ALWAYS_INLINE
Shape
*
inlinedGetChild
(
JSContext
*
cx
Shape
*
parent
JS
:
:
Handle
<
StackShape
>
childSpec
)
;
Shape
*
getChild
(
JSContext
*
cx
Shape
*
parent
JS
:
:
Handle
<
StackShape
>
child
)
;
}
;
class
TenuringTracer
;
class
AutoKeepShapeCaches
;
class
ShapeIC
{
public
:
friend
class
NativeObject
;
friend
class
BaseShape
;
friend
class
Shape
;
ShapeIC
(
)
:
size_
(
0
)
nextFreeIndex_
(
0
)
entries_
(
nullptr
)
{
}
~
ShapeIC
(
)
=
default
;
bool
isFull
(
)
const
{
MOZ_ASSERT
(
nextFreeIndex_
<
=
size_
)
;
return
size_
=
=
nextFreeIndex_
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
mallocSizeOf
(
entries_
.
get
(
)
)
;
}
uint32_t
entryCount
(
)
{
return
nextFreeIndex_
;
}
bool
init
(
JSContext
*
cx
)
;
void
trace
(
JSTracer
*
trc
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkAfterMovingGC
(
)
;
#
endif
MOZ_ALWAYS_INLINE
bool
search
(
jsid
id
Shape
*
*
foundShape
)
;
MOZ_ALWAYS_INLINE
bool
appendEntry
(
jsid
id
Shape
*
shape
)
{
MOZ_ASSERT
(
nextFreeIndex_
<
=
size_
)
;
if
(
nextFreeIndex_
=
=
size_
)
{
return
false
;
}
entries_
[
nextFreeIndex_
]
.
id_
=
id
;
entries_
[
nextFreeIndex_
]
.
shape_
=
shape
;
nextFreeIndex_
+
+
;
return
true
;
}
private
:
static
const
uint32_t
MAX_SIZE
=
7
;
class
Entry
{
public
:
jsid
id_
;
Shape
*
shape_
;
Entry
(
)
=
delete
;
Entry
(
const
Entry
&
)
=
delete
;
Entry
&
operator
=
(
const
Entry
&
)
=
delete
;
}
;
uint8_t
size_
;
uint8_t
nextFreeIndex_
;
UniquePtr
<
Entry
[
]
JS
:
:
FreePolicy
>
entries_
;
}
;
class
ShapeTable
{
public
:
friend
class
NativeObject
;
friend
class
BaseShape
;
friend
class
Shape
;
friend
class
ShapeCachePtr
;
private
:
struct
Hasher
:
public
DefaultHasher
<
Shape
*
>
{
using
Key
=
Shape
*
;
using
Lookup
=
PropertyKey
;
static
MOZ_ALWAYS_INLINE
HashNumber
hash
(
PropertyKey
key
)
;
static
MOZ_ALWAYS_INLINE
bool
match
(
Shape
*
shape
PropertyKey
key
)
;
}
;
using
Set
=
HashSet
<
Shape
*
Hasher
SystemAllocPolicy
>
;
Set
set_
;
uint32_t
freeList_
=
SHAPE_INVALID_SLOT
;
MOZ_ALWAYS_INLINE
Set
:
:
Ptr
searchUnchecked
(
jsid
id
)
{
return
set_
.
lookup
(
id
)
;
}
public
:
using
Ptr
=
Set
:
:
Ptr
;
ShapeTable
(
)
=
default
;
~
ShapeTable
(
)
=
default
;
uint32_t
entryCount
(
)
const
{
return
set_
.
count
(
)
;
}
uint32_t
freeList
(
)
const
{
return
freeList_
;
}
void
setFreeList
(
uint32_t
slot
)
{
freeList_
=
slot
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
set_
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
init
(
JSContext
*
cx
Shape
*
lastProp
)
;
MOZ_ALWAYS_INLINE
Set
:
:
Ptr
search
(
jsid
id
const
AutoKeepShapeCaches
&
)
{
return
searchUnchecked
(
id
)
;
}
MOZ_ALWAYS_INLINE
Set
:
:
Ptr
search
(
jsid
id
const
JS
:
:
AutoCheckCannotGC
&
)
{
return
searchUnchecked
(
id
)
;
}
bool
add
(
JSContext
*
cx
PropertyKey
key
Shape
*
shape
)
{
if
(
!
set_
.
putNew
(
key
shape
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
remove
(
Ptr
ptr
)
{
set_
.
remove
(
ptr
)
;
}
void
remove
(
PropertyKey
key
)
{
set_
.
remove
(
key
)
;
}
void
replaceShape
(
Ptr
ptr
PropertyKey
key
Shape
*
newShape
)
{
MOZ_ASSERT
(
*
ptr
!
=
newShape
)
;
set_
.
replaceKey
(
ptr
key
newShape
)
;
}
void
compact
(
)
{
set_
.
compact
(
)
;
}
void
trace
(
JSTracer
*
trc
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkAfterMovingGC
(
)
;
#
endif
}
;
class
ShapeCachePtr
{
uintptr_t
p
;
enum
class
CacheType
{
IC
=
0x1
Table
=
0x2
}
;
static
const
uint32_t
MASK_BITS
=
0x3
;
static
const
uintptr_t
CACHETYPE_MASK
=
0x3
;
void
*
getPointer
(
)
const
{
uintptr_t
ptrVal
=
p
&
~
CACHETYPE_MASK
;
return
reinterpret_cast
<
void
*
>
(
ptrVal
)
;
}
CacheType
getType
(
)
const
{
return
static_cast
<
CacheType
>
(
p
&
CACHETYPE_MASK
)
;
}
public
:
static
const
uint32_t
MIN_ENTRIES
=
3
;
ShapeCachePtr
(
)
:
p
(
0
)
{
}
MOZ_ALWAYS_INLINE
bool
search
(
jsid
id
Shape
*
start
Shape
*
*
foundShape
)
;
bool
isIC
(
)
const
{
return
(
getType
(
)
=
=
CacheType
:
:
IC
)
;
}
bool
isTable
(
)
const
{
return
(
getType
(
)
=
=
CacheType
:
:
Table
)
;
}
bool
isInitialized
(
)
const
{
return
isTable
(
)
|
|
isIC
(
)
;
}
ShapeTable
*
getTablePointer
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
reinterpret_cast
<
ShapeTable
*
>
(
getPointer
(
)
)
;
}
ShapeIC
*
getICPointer
(
)
const
{
MOZ_ASSERT
(
isIC
(
)
)
;
return
reinterpret_cast
<
ShapeIC
*
>
(
getPointer
(
)
)
;
}
void
initializeTable
(
ShapeTable
*
table
)
{
MOZ_ASSERT
(
!
isTable
(
)
&
&
!
isIC
(
)
)
;
uintptr_t
tableptr
=
uintptr_t
(
table
)
;
MOZ_ASSERT
(
(
tableptr
&
CACHETYPE_MASK
)
=
=
0
)
;
tableptr
|
=
static_cast
<
uintptr_t
>
(
CacheType
:
:
Table
)
;
p
=
tableptr
;
}
void
initializeIC
(
ShapeIC
*
ic
)
{
MOZ_ASSERT
(
!
isTable
(
)
&
&
!
isIC
(
)
)
;
uintptr_t
icptr
=
uintptr_t
(
ic
)
;
MOZ_ASSERT
(
(
icptr
&
CACHETYPE_MASK
)
=
=
0
)
;
icptr
|
=
static_cast
<
uintptr_t
>
(
CacheType
:
:
IC
)
;
p
=
icptr
;
}
void
destroy
(
JSFreeOp
*
fop
Shape
*
shape
)
;
void
maybePurgeCache
(
JSFreeOp
*
fop
Shape
*
shape
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
if
(
isIC
(
)
)
{
size
=
getICPointer
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
else
if
(
isTable
(
)
)
{
size
=
getTablePointer
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
uint32_t
entryCount
(
)
{
uint32_t
count
=
0
;
if
(
isIC
(
)
)
{
count
=
getICPointer
(
)
-
>
entryCount
(
)
;
}
else
if
(
isTable
(
)
)
{
count
=
getTablePointer
(
)
-
>
entryCount
(
)
;
}
return
count
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkAfterMovingGC
(
)
;
#
endif
}
;
class
MOZ_RAII
AutoKeepShapeCaches
{
JSContext
*
cx_
;
bool
prev_
;
public
:
void
operator
=
(
const
AutoKeepShapeCaches
&
)
=
delete
;
AutoKeepShapeCaches
(
const
AutoKeepShapeCaches
&
)
=
delete
;
explicit
inline
AutoKeepShapeCaches
(
JSContext
*
cx
)
;
inline
~
AutoKeepShapeCaches
(
)
;
}
;
class
Shape
;
struct
StackBaseShape
;
enum
class
ObjectFlag
:
uint16_t
{
IsUsedAsPrototype
=
1
<
<
0
NotExtensible
=
1
<
<
1
Indexed
=
1
<
<
2
HasInterestingSymbol
=
1
<
<
3
HadElementsAccess
=
1
<
<
4
FrozenElements
=
1
<
<
5
UncacheableProto
=
1
<
<
6
ImmutablePrototype
=
1
<
<
7
QualifiedVarObj
=
1
<
<
8
HasNonWritableOrAccessorPropExclProto
=
1
<
<
9
HadGetterSetterChange
=
1
<
<
10
}
;
using
ObjectFlags
=
EnumFlags
<
ObjectFlag
>
;
class
BaseShape
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
const
JSClass
>
{
public
:
friend
class
Shape
;
friend
struct
StackBaseShape
;
friend
struct
StackShape
;
const
JSClass
*
clasp
(
)
const
{
return
headerPtr
(
)
;
}
private
:
JS
:
:
Realm
*
realm_
;
GCPtr
<
TaggedProto
>
proto_
;
BaseShape
(
const
BaseShape
&
base
)
=
delete
;
BaseShape
&
operator
=
(
const
BaseShape
&
other
)
=
delete
;
public
:
void
finalize
(
JSFreeOp
*
fop
)
{
}
explicit
inline
BaseShape
(
const
StackBaseShape
&
base
)
;
~
BaseShape
(
)
=
delete
;
JS
:
:
Realm
*
realm
(
)
const
{
return
realm_
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
JS
:
:
GetCompartmentForRealm
(
realm
(
)
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
TaggedProto
proto
(
)
const
{
return
proto_
;
}
void
setRealmForMergeRealms
(
JS
:
:
Realm
*
realm
)
{
realm_
=
realm
;
}
void
setProtoForMergeRealms
(
TaggedProto
proto
)
{
proto_
=
proto
;
}
static
BaseShape
*
get
(
JSContext
*
cx
Handle
<
StackBaseShape
>
base
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
BaseShape
;
void
traceChildren
(
JSTracer
*
trc
)
;
static
constexpr
size_t
offsetOfClasp
(
)
{
return
offsetOfHeaderPtr
(
)
;
}
static
constexpr
size_t
offsetOfRealm
(
)
{
return
offsetof
(
BaseShape
realm_
)
;
}
static
constexpr
size_t
offsetOfProto
(
)
{
return
offsetof
(
BaseShape
proto_
)
;
}
private
:
static
void
staticAsserts
(
)
{
static_assert
(
offsetOfClasp
(
)
=
=
offsetof
(
JS
:
:
shadow
:
:
BaseShape
clasp
)
)
;
static_assert
(
offsetOfRealm
(
)
=
=
offsetof
(
JS
:
:
shadow
:
:
BaseShape
realm
)
)
;
static_assert
(
sizeof
(
BaseShape
)
%
gc
:
:
CellAlignBytes
=
=
0
"
Things
inheriting
from
gc
:
:
Cell
must
have
a
size
that
'
s
"
"
a
multiple
of
gc
:
:
CellAlignBytes
"
)
;
#
ifdef
JS_64BIT
static_assert
(
sizeof
(
BaseShape
)
=
=
3
*
sizeof
(
void
*
)
)
;
#
else
static_assert
(
sizeof
(
BaseShape
)
=
=
4
*
sizeof
(
void
*
)
)
;
#
endif
}
}
;
struct
StackBaseShape
:
public
DefaultHasher
<
WeakHeapPtr
<
BaseShape
*
>
>
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
inline
StackBaseShape
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
)
;
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
MOZ_IMPLICIT
Lookup
(
const
StackBaseShape
&
base
)
:
clasp
(
base
.
clasp
)
realm
(
base
.
realm
)
proto
(
base
.
proto
)
{
}
MOZ_IMPLICIT
Lookup
(
BaseShape
*
base
)
:
clasp
(
base
-
>
clasp
(
)
)
realm
(
base
-
>
realm
(
)
)
proto
(
base
-
>
proto
(
)
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashGeneric
(
lookup
.
clasp
lookup
.
realm
)
)
;
}
static
inline
bool
match
(
const
WeakHeapPtr
<
BaseShape
*
>
&
key
const
Lookup
&
lookup
)
{
return
key
.
unbarrieredGet
(
)
-
>
clasp
(
)
=
=
lookup
.
clasp
&
&
key
.
unbarrieredGet
(
)
-
>
realm
(
)
=
=
lookup
.
realm
&
&
key
.
unbarrieredGet
(
)
-
>
proto
(
)
=
=
lookup
.
proto
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
StackBaseShape
Wrapper
>
{
}
;
static
MOZ_ALWAYS_INLINE
js
:
:
HashNumber
HashId
(
jsid
id
)
{
if
(
MOZ_LIKELY
(
JSID_IS_ATOM
(
id
)
)
)
{
return
id
.
toAtom
(
)
-
>
hash
(
)
;
}
if
(
JSID_IS_SYMBOL
(
id
)
)
{
return
JSID_TO_SYMBOL
(
id
)
-
>
hash
(
)
;
}
return
mozilla
:
:
HashGeneric
(
JSID_BITS
(
id
)
)
;
}
}
namespace
mozilla
{
template
<
>
struct
DefaultHasher
<
jsid
>
{
using
Lookup
=
jsid
;
static
HashNumber
hash
(
jsid
id
)
{
return
js
:
:
HashId
(
id
)
;
}
static
bool
match
(
jsid
id1
jsid
id2
)
{
return
id1
=
=
id2
;
}
}
;
}
namespace
js
{
using
BaseShapeSet
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
BaseShape
*
>
StackBaseShape
SystemAllocPolicy
>
>
;
class
Shape
:
public
gc
:
:
CellWithTenuredGCPointer
<
gc
:
:
TenuredCell
BaseShape
>
{
friend
class
:
:
JSObject
;
friend
class
:
:
JSFunction
;
friend
class
GCMarker
;
friend
class
NativeObject
;
friend
class
PropertyTree
;
friend
class
TenuringTracer
;
friend
struct
StackBaseShape
;
friend
struct
StackShape
;
friend
class
JS
:
:
ubi
:
:
Concrete
<
Shape
>
;
friend
class
js
:
:
gc
:
:
RelocationOverlay
;
friend
class
js
:
:
ShapeTable
;
public
:
BaseShape
*
base
(
)
const
{
return
headerPtr
(
)
;
}
protected
:
const
GCPtr
<
PropertyKey
>
propid_
;
enum
ImmutableFlags
:
uint32_t
{
SLOT_MASK
=
BitMask
(
24
)
FIXED_SLOTS_MAX
=
0x1f
FIXED_SLOTS_SHIFT
=
24
FIXED_SLOTS_MASK
=
uint32_t
(
FIXED_SLOTS_MAX
<
<
FIXED_SLOTS_SHIFT
)
IN_DICTIONARY
=
1
<
<
29
}
;
enum
MutableFlags
:
uint8_t
{
LINEAR_SEARCHES_MAX
=
0x5
LINEAR_SEARCHES_MASK
=
0x7
HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
=
0x08
CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
=
0x10
}
;
private
:
uint32_t
immutableFlags
;
ObjectFlags
objectFlags_
;
ShapePropertyFlags
propFlags
;
uint8_t
mutableFlags
;
GCPtrShape
parent
;
friend
class
DictionaryShapeLink
;
ShapeCachePtr
cache_
;
union
{
ShapeChildren
children
;
DictionaryShapeLink
dictNext
;
}
;
void
setNextDictionaryShape
(
Shape
*
shape
)
;
void
setDictionaryNextPtr
(
DictionaryShapeLink
next
)
;
void
clearDictionaryNextPtr
(
)
;
static
MOZ_ALWAYS_INLINE
Shape
*
search
(
JSContext
*
cx
Shape
*
start
jsid
id
)
;
[
[
nodiscard
]
]
static
inline
bool
search
(
JSContext
*
cx
Shape
*
start
jsid
id
const
AutoKeepShapeCaches
&
Shape
*
*
pshape
ShapeTable
*
*
ptable
ShapeTable
:
:
Ptr
*
pptr
)
;
static
inline
Shape
*
searchNoHashify
(
Shape
*
start
jsid
id
)
;
void
removeFromDictionary
(
NativeObject
*
obj
)
;
void
initDictionaryShapeAtEnd
(
const
StackShape
&
child
NativeObject
*
obj
)
;
void
initDictionaryShapeAtFront
(
const
StackShape
&
child
uint32_t
nfixed
Shape
*
next
)
;
static
Shape
*
replaceLastProperty
(
JSContext
*
cx
ObjectFlags
objectFlags
TaggedProto
proto
HandleShape
shape
)
;
static
bool
hashify
(
JSContext
*
cx
Shape
*
shape
)
;
static
bool
cachify
(
JSContext
*
cx
Shape
*
shape
)
;
void
handoffTableTo
(
Shape
*
newShape
)
;
void
setParent
(
Shape
*
p
)
{
MOZ_ASSERT_IF
(
p
&
&
!
p
-
>
hasMissingSlot
(
)
&
&
!
inDictionary
(
)
p
-
>
maybeSlot
(
)
<
=
maybeSlot
(
)
)
;
MOZ_ASSERT_IF
(
p
&
&
!
inDictionary
(
)
hasSlot
(
)
=
=
(
p
-
>
maybeSlot
(
)
!
=
maybeSlot
(
)
)
)
;
parent
=
p
;
}
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
maybeCreateCacheForLookup
(
JSContext
*
cx
)
;
void
setObjectFlags
(
ObjectFlags
flags
)
{
MOZ_ASSERT
(
inDictionary
(
)
)
;
objectFlags_
=
flags
;
}
public
:
bool
hasTable
(
)
const
{
return
cache_
.
isTable
(
)
;
}
bool
hasIC
(
)
const
{
return
cache_
.
isIC
(
)
;
}
void
setTable
(
ShapeTable
*
table
)
{
cache_
.
initializeTable
(
table
)
;
}
void
setIC
(
ShapeIC
*
ic
)
{
cache_
.
initializeIC
(
ic
)
;
}
ShapeCachePtr
getCache
(
const
AutoKeepShapeCaches
&
)
const
{
return
cache_
;
}
ShapeCachePtr
getCache
(
const
JS
:
:
AutoCheckCannotGC
&
)
const
{
return
cache_
;
}
ShapeTable
*
maybeTable
(
const
AutoKeepShapeCaches
&
)
const
{
return
cache_
.
isTable
(
)
?
cache_
.
getTablePointer
(
)
:
nullptr
;
}
ShapeTable
*
maybeTable
(
const
JS
:
:
AutoCheckCannotGC
&
)
const
{
return
cache_
.
isTable
(
)
?
cache_
.
getTablePointer
(
)
:
nullptr
;
}
ShapeIC
*
maybeIC
(
const
AutoKeepShapeCaches
&
)
const
{
return
cache_
.
isIC
(
)
?
cache_
.
getICPointer
(
)
:
nullptr
;
}
ShapeIC
*
maybeIC
(
const
JS
:
:
AutoCheckCannotGC
&
)
const
{
return
cache_
.
isIC
(
)
?
cache_
.
getICPointer
(
)
:
nullptr
;
}
void
maybePurgeCache
(
JSFreeOp
*
fop
)
{
cache_
.
maybePurgeCache
(
fop
this
)
;
}
bool
appendShapeToIC
(
jsid
id
Shape
*
shape
const
JS
:
:
AutoCheckCannotGC
&
check
)
{
MOZ_ASSERT
(
hasIC
(
)
)
;
ShapeCachePtr
cache
=
getCache
(
check
)
;
return
cache
.
getICPointer
(
)
-
>
appendEntry
(
id
shape
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
ShapeTable
*
ensureTableForDictionary
(
JSContext
*
cx
const
T
&
nogc
)
{
MOZ_ASSERT
(
inDictionary
(
)
)
;
if
(
ShapeTable
*
table
=
maybeTable
(
nogc
)
)
{
return
table
;
}
if
(
!
hashify
(
cx
this
)
)
{
return
nullptr
;
}
ShapeTable
*
table
=
maybeTable
(
nogc
)
;
MOZ_ASSERT
(
table
)
;
return
table
;
}
void
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ShapeInfo
*
info
)
const
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
inDictionary
(
)
)
{
info
-
>
shapesMallocHeapDictTables
+
=
getCache
(
nogc
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
else
{
info
-
>
shapesMallocHeapTreeTables
+
=
getCache
(
nogc
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
if
(
!
inDictionary
(
)
&
&
children
.
isShapeSet
(
)
)
{
info
-
>
shapesMallocHeapTreeChildren
+
=
children
.
toShapeSet
(
)
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
const
GCPtrShape
&
previous
(
)
const
{
return
parent
;
}
template
<
AllowGC
allowGC
>
class
Range
{
protected
:
friend
class
Shape
;
typename
MaybeRooted
<
Shape
*
allowGC
>
:
:
RootType
cursor
;
public
:
Range
(
JSContext
*
cx
Shape
*
shape
)
:
cursor
(
cx
shape
)
{
static_assert
(
allowGC
=
=
CanGC
)
;
}
explicit
Range
(
Shape
*
shape
)
:
cursor
(
nullptr
shape
)
{
static_assert
(
allowGC
=
=
NoGC
)
;
}
bool
empty
(
)
const
{
return
!
cursor
|
|
cursor
-
>
isEmptyShape
(
)
;
}
Shape
&
front
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
*
cursor
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
cursor
=
cursor
-
>
parent
;
}
}
;
const
JSClass
*
getObjectClass
(
)
const
{
return
base
(
)
-
>
clasp
(
)
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
base
(
)
-
>
realm
(
)
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
base
(
)
-
>
compartment
(
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
base
(
)
-
>
maybeCompartment
(
)
;
}
TaggedProto
proto
(
)
const
{
return
base
(
)
-
>
proto
(
)
;
}
static
Shape
*
setObjectFlag
(
JSContext
*
cx
ObjectFlag
flag
Shape
*
last
)
;
static
Shape
*
setProto
(
JSContext
*
cx
TaggedProto
proto
Shape
*
last
)
;
ObjectFlags
objectFlags
(
)
const
{
return
objectFlags_
;
}
bool
hasObjectFlag
(
ObjectFlag
flag
)
const
{
return
objectFlags_
.
hasFlag
(
flag
)
;
}
protected
:
inline
Shape
(
const
StackShape
&
other
uint32_t
nfixed
)
;
inline
Shape
(
BaseShape
*
base
ObjectFlags
objectFlags
uint32_t
nfixed
)
;
Shape
(
const
Shape
&
other
)
=
delete
;
static
inline
Shape
*
new_
(
JSContext
*
cx
Handle
<
StackShape
>
other
uint32_t
nfixed
)
;
bool
hasMissingSlot
(
)
const
{
return
maybeSlot
(
)
=
=
SHAPE_INVALID_SLOT
;
}
public
:
bool
inDictionary
(
)
const
{
return
immutableFlags
&
IN_DICTIONARY
;
}
bool
matches
(
const
Shape
*
other
)
const
{
return
propid_
.
get
(
)
=
=
other
-
>
propid_
.
get
(
)
&
&
matchesParamsAfterId
(
other
-
>
base
(
)
other
-
>
objectFlags
(
)
other
-
>
maybeSlot
(
)
other
-
>
propFlags
)
;
}
inline
bool
matches
(
const
StackShape
&
other
)
const
;
bool
matchesParamsAfterId
(
BaseShape
*
base
ObjectFlags
aobjectFlags
uint32_t
aslot
ShapePropertyFlags
aflags
)
const
{
return
base
=
=
this
-
>
base
(
)
&
&
objectFlags
(
)
=
=
aobjectFlags
&
&
matchesPropertyParamsAfterId
(
aslot
aflags
)
;
}
bool
matchesPropertyParamsAfterId
(
uint32_t
aslot
ShapePropertyFlags
aflags
)
const
{
return
maybeSlot
(
)
=
=
aslot
&
&
propFlags
=
=
aflags
;
}
private
:
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
hasSlot
(
)
)
;
return
maybeSlot
(
)
;
}
uint32_t
maybeSlot
(
)
const
{
return
immutableFlags
&
SLOT_MASK
;
}
bool
hasSlot
(
)
const
{
MOZ_ASSERT
(
!
isEmptyShape
(
)
)
;
MOZ_ASSERT_IF
(
!
isCustomDataProperty
(
)
!
hasMissingSlot
(
)
)
;
return
!
isCustomDataProperty
(
)
;
}
bool
isCustomDataProperty
(
)
const
{
return
propFlags
.
isCustomDataProperty
(
)
;
}
public
:
bool
isEmptyShape
(
)
const
{
MOZ_ASSERT_IF
(
JSID_IS_EMPTY
(
propid_
)
hasMissingSlot
(
)
)
;
return
JSID_IS_EMPTY
(
propid_
)
;
}
uint32_t
slotSpan
(
)
const
{
MOZ_ASSERT
(
!
inDictionary
(
)
)
;
const
JSClass
*
clasp
=
getObjectClass
(
)
;
MOZ_ASSERT
(
clasp
-
>
isNativeObject
(
)
)
;
uint32_t
free
=
JSSLOT_FREE
(
clasp
)
;
return
hasMissingSlot
(
)
?
free
:
std
:
:
max
(
free
maybeSlot
(
)
+
1
)
;
}
void
setSlot
(
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
=
SHAPE_INVALID_SLOT
)
;
immutableFlags
=
(
immutableFlags
&
~
Shape
:
:
SLOT_MASK
)
|
slot
;
}
uint32_t
numFixedSlots
(
)
const
{
return
(
immutableFlags
&
FIXED_SLOTS_MASK
)
>
>
FIXED_SLOTS_SHIFT
;
}
void
setNumFixedSlots
(
uint32_t
nfixed
)
{
MOZ_ASSERT
(
nfixed
<
FIXED_SLOTS_MAX
)
;
immutableFlags
=
immutableFlags
&
~
FIXED_SLOTS_MASK
;
immutableFlags
=
immutableFlags
|
(
nfixed
<
<
FIXED_SLOTS_SHIFT
)
;
}
uint32_t
numLinearSearches
(
)
const
{
return
mutableFlags
&
LINEAR_SEARCHES_MASK
;
}
void
incrementNumLinearSearches
(
)
{
uint32_t
count
=
numLinearSearches
(
)
;
MOZ_ASSERT
(
count
<
LINEAR_SEARCHES_MAX
)
;
mutableFlags
=
(
mutableFlags
&
~
LINEAR_SEARCHES_MASK
)
|
(
count
+
1
)
;
}
private
:
const
GCPtrId
&
propid
(
)
const
{
MOZ_ASSERT
(
!
isEmptyShape
(
)
)
;
MOZ_ASSERT
(
!
JSID_IS_VOID
(
propid_
)
)
;
return
propid_
;
}
const
GCPtrId
&
propidRef
(
)
{
MOZ_ASSERT
(
!
JSID_IS_VOID
(
propid_
)
)
;
return
propid_
;
}
jsid
propidRaw
(
)
const
{
return
propid
(
)
;
}
public
:
ShapeProperty
property
(
)
const
{
MOZ_ASSERT
(
!
isEmptyShape
(
)
)
;
return
ShapeProperty
(
propFlags
maybeSlot
(
)
)
;
}
ShapePropertyWithKey
propertyWithKey
(
)
const
{
return
ShapePropertyWithKey
(
propFlags
maybeSlot
(
)
propid
(
)
)
;
}
uint32_t
entryCount
(
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
maybeTable
(
nogc
)
)
{
return
table
-
>
entryCount
(
)
;
}
uint32_t
count
=
0
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
this
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
+
+
count
;
}
return
count
;
}
private
:
void
setBase
(
BaseShape
*
base
)
{
MOZ_ASSERT
(
base
)
;
MOZ_ASSERT
(
inDictionary
(
)
)
;
setHeaderPtr
(
base
)
;
}
bool
isBigEnoughForAShapeTableSlow
(
)
{
uint32_t
count
=
0
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
this
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
+
+
count
;
if
(
count
>
=
ShapeCachePtr
:
:
MIN_ENTRIES
)
{
return
true
;
}
}
return
false
;
}
void
clearCachedBigEnoughForShapeTable
(
)
{
mutableFlags
&
=
~
(
HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
|
CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
)
;
}
public
:
bool
isBigEnoughForAShapeTable
(
)
{
MOZ_ASSERT
(
!
hasTable
(
)
)
;
if
(
mutableFlags
&
HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
)
{
bool
res
=
mutableFlags
&
CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
;
MOZ_ASSERT
(
res
=
=
isBigEnoughForAShapeTableSlow
(
)
)
;
return
res
;
}
MOZ_ASSERT
(
!
(
mutableFlags
&
CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
)
)
;
bool
res
=
isBigEnoughForAShapeTableSlow
(
)
;
if
(
res
)
{
mutableFlags
|
=
CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
;
}
mutableFlags
|
=
HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE
;
return
res
;
}
#
ifdef
DEBUG
void
dump
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dump
(
)
const
;
void
dumpSubtree
(
int
level
js
:
:
GenericPrinter
&
out
)
const
;
#
endif
void
sweep
(
JSFreeOp
*
fop
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
void
removeChild
(
JSFreeOp
*
fop
Shape
*
child
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Shape
;
void
traceChildren
(
JSTracer
*
trc
)
;
#
ifdef
DEBUG
bool
canSkipMarkingShapeCache
(
)
;
#
endif
MOZ_ALWAYS_INLINE
Shape
*
search
(
JSContext
*
cx
jsid
id
)
;
MOZ_ALWAYS_INLINE
Shape
*
searchLinear
(
jsid
id
)
;
void
fixupAfterMovingGC
(
)
;
void
updateBaseShapeAfterMovingGC
(
)
;
static
constexpr
size_t
offsetOfBaseShape
(
)
{
return
offsetOfHeaderPtr
(
)
;
}
static
constexpr
size_t
offsetOfObjectFlags
(
)
{
return
offsetof
(
Shape
objectFlags_
)
;
}
#
ifdef
DEBUG
static
inline
size_t
offsetOfImmutableFlags
(
)
{
return
offsetof
(
Shape
immutableFlags
)
;
}
static
inline
uint32_t
fixedSlotsMask
(
)
{
return
FIXED_SLOTS_MASK
;
}
#
endif
private
:
void
fixupDictionaryShapeAfterMovingGC
(
)
;
void
fixupShapeTreeAfterMovingGC
(
)
;
static
void
staticAsserts
(
)
{
static_assert
(
offsetOfBaseShape
(
)
=
=
offsetof
(
JS
:
:
shadow
:
:
Shape
base
)
)
;
static_assert
(
offsetof
(
Shape
immutableFlags
)
=
=
offsetof
(
JS
:
:
shadow
:
:
Shape
immutableFlags
)
)
;
static_assert
(
FIXED_SLOTS_SHIFT
=
=
JS
:
:
shadow
:
:
Shape
:
:
FIXED_SLOTS_SHIFT
)
;
static_assert
(
FIXED_SLOTS_MASK
=
=
JS
:
:
shadow
:
:
Shape
:
:
FIXED_SLOTS_MASK
)
;
#
ifdef
JS_64BIT
static_assert
(
sizeof
(
Shape
)
=
=
6
*
sizeof
(
void
*
)
)
;
#
else
static_assert
(
sizeof
(
Shape
)
=
=
8
*
sizeof
(
void
*
)
)
;
#
endif
}
}
;
struct
EmptyShape
:
public
js
:
:
Shape
{
EmptyShape
(
BaseShape
*
base
ObjectFlags
objectFlags
uint32_t
nfixed
)
:
js
:
:
Shape
(
base
objectFlags
nfixed
)
{
}
static
Shape
*
new_
(
JSContext
*
cx
Handle
<
BaseShape
*
>
base
ObjectFlags
objectFlags
uint32_t
nfixed
)
;
static
Shape
*
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
size_t
nfixed
ObjectFlags
objectFlags
=
{
}
)
;
static
Shape
*
getInitialShape
(
JSContext
*
cx
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
gc
:
:
AllocKind
kind
ObjectFlags
objectFlags
=
{
}
)
;
static
void
insertInitialShape
(
JSContext
*
cx
HandleShape
shape
)
;
template
<
class
ObjectSubclass
>
static
inline
bool
ensureInitialCustomShape
(
JSContext
*
cx
Handle
<
ObjectSubclass
*
>
obj
)
;
}
;
struct
InitialShapeEntry
{
WeakHeapPtr
<
Shape
*
>
shape
;
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
uint32_t
nfixed
;
ObjectFlags
objectFlags
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
const
TaggedProto
&
proto
uint32_t
nfixed
ObjectFlags
objectFlags
)
:
clasp
(
clasp
)
realm
(
realm
)
proto
(
proto
)
nfixed
(
nfixed
)
objectFlags
(
objectFlags
)
{
}
}
;
inline
InitialShapeEntry
(
)
;
inline
explicit
InitialShapeEntry
(
Shape
*
shape
)
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashGeneric
(
lookup
.
clasp
lookup
.
realm
lookup
.
nfixed
lookup
.
objectFlags
.
toRaw
(
)
)
)
;
}
static
inline
bool
match
(
const
InitialShapeEntry
&
key
const
Lookup
&
lookup
)
{
const
Shape
*
shape
=
key
.
shape
.
unbarrieredGet
(
)
;
return
lookup
.
clasp
=
=
shape
-
>
getObjectClass
(
)
&
&
lookup
.
realm
=
=
shape
-
>
realm
(
)
&
&
lookup
.
nfixed
=
=
shape
-
>
numFixedSlots
(
)
&
&
lookup
.
objectFlags
=
=
shape
-
>
objectFlags
(
)
&
&
lookup
.
proto
=
=
shape
-
>
proto
(
)
;
}
static
void
rekey
(
InitialShapeEntry
&
k
const
InitialShapeEntry
&
newKey
)
{
k
=
newKey
;
}
bool
needsSweep
(
)
{
Shape
*
ushape
=
shape
.
unbarrieredGet
(
)
;
return
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
ushape
)
;
}
bool
operator
=
=
(
const
InitialShapeEntry
&
other
)
const
{
return
shape
=
=
other
.
shape
;
}
}
;
using
InitialShapeSet
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
InitialShapeEntry
InitialShapeEntry
SystemAllocPolicy
>
>
;
struct
StackShape
{
BaseShape
*
base
;
jsid
propid
;
uint32_t
immutableFlags
;
ObjectFlags
objectFlags
;
ShapePropertyFlags
propFlags
;
uint8_t
mutableFlags
;
explicit
StackShape
(
BaseShape
*
base
ObjectFlags
objectFlags
jsid
propid
uint32_t
slot
ShapePropertyFlags
propFlags
)
:
base
(
base
)
propid
(
propid
)
immutableFlags
(
slot
)
objectFlags
(
objectFlags
)
propFlags
(
propFlags
)
mutableFlags
(
0
)
{
MOZ_ASSERT
(
base
)
;
MOZ_ASSERT
(
!
JSID_IS_VOID
(
propid
)
)
;
MOZ_ASSERT
(
slot
<
=
SHAPE_INVALID_SLOT
)
;
}
explicit
StackShape
(
Shape
*
shape
)
:
base
(
shape
-
>
base
(
)
)
propid
(
shape
-
>
propidRef
(
)
)
immutableFlags
(
shape
-
>
immutableFlags
)
objectFlags
(
shape
-
>
objectFlags
(
)
)
propFlags
(
shape
-
>
propFlags
)
mutableFlags
(
shape
-
>
mutableFlags
)
{
}
bool
hasMissingSlot
(
)
const
{
return
maybeSlot
(
)
=
=
SHAPE_INVALID_SLOT
;
}
bool
isCustomDataProperty
(
)
const
{
return
propFlags
.
isCustomDataProperty
(
)
;
}
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
!
hasMissingSlot
(
)
)
;
return
maybeSlot
(
)
;
}
uint32_t
maybeSlot
(
)
const
{
return
immutableFlags
&
Shape
:
:
SLOT_MASK
;
}
void
setSlot
(
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
=
SHAPE_INVALID_SLOT
)
;
immutableFlags
=
(
immutableFlags
&
~
Shape
:
:
SLOT_MASK
)
|
slot
;
}
HashNumber
hash
(
)
const
{
HashNumber
hash
=
HashId
(
propid
)
;
return
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashGeneric
(
base
objectFlags
.
toRaw
(
)
propFlags
.
toRaw
(
)
maybeSlot
(
)
)
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
StackShape
Wrapper
>
{
const
StackShape
&
ss
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isCustomDataProperty
(
)
const
{
return
ss
(
)
.
isCustomDataProperty
(
)
;
}
bool
hasMissingSlot
(
)
const
{
return
ss
(
)
.
hasMissingSlot
(
)
;
}
uint32_t
slot
(
)
const
{
return
ss
(
)
.
slot
(
)
;
}
uint32_t
maybeSlot
(
)
const
{
return
ss
(
)
.
maybeSlot
(
)
;
}
uint32_t
slotSpan
(
)
const
{
return
ss
(
)
.
slotSpan
(
)
;
}
ShapePropertyFlags
propFlags
(
)
const
{
return
ss
(
)
.
propFlags
;
}
ObjectFlags
objectFlags
(
)
const
{
return
ss
(
)
.
objectFlags
;
}
jsid
propid
(
)
const
{
return
ss
(
)
.
propid
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
StackShape
Wrapper
>
:
public
WrappedPtrOperations
<
StackShape
Wrapper
>
{
StackShape
&
ss
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
setSlot
(
uint32_t
slot
)
{
ss
(
)
.
setSlot
(
slot
)
;
}
void
setBase
(
BaseShape
*
base
)
{
ss
(
)
.
base
=
base
;
}
void
setPropFlags
(
ShapePropertyFlags
flags
)
{
ss
(
)
.
propFlags
=
flags
;
}
void
setObjectFlags
(
ObjectFlags
objectFlags
)
{
ss
(
)
.
objectFlags
=
objectFlags
;
}
}
;
inline
Shape
:
:
Shape
(
const
StackShape
&
other
uint32_t
nfixed
)
:
CellWithTenuredGCPointer
(
other
.
base
)
propid_
(
other
.
propid
)
immutableFlags
(
other
.
immutableFlags
)
objectFlags_
(
other
.
objectFlags
)
propFlags
(
other
.
propFlags
)
mutableFlags
(
other
.
mutableFlags
)
parent
(
nullptr
)
{
setNumFixedSlots
(
nfixed
)
;
MOZ_ASSERT_IF
(
!
isEmptyShape
(
)
AtomIsMarked
(
zone
(
)
propid
(
)
)
)
;
children
.
setNone
(
)
;
}
inline
Shape
:
:
Shape
(
BaseShape
*
base
ObjectFlags
objectFlags
uint32_t
nfixed
)
:
CellWithTenuredGCPointer
(
base
)
propid_
(
JSID_EMPTY
)
immutableFlags
(
SHAPE_INVALID_SLOT
|
(
nfixed
<
<
FIXED_SLOTS_SHIFT
)
)
objectFlags_
(
objectFlags
)
propFlags
(
)
mutableFlags
(
0
)
parent
(
nullptr
)
{
MOZ_ASSERT
(
base
)
;
children
.
setNone
(
)
;
}
inline
Shape
*
Shape
:
:
searchLinear
(
jsid
id
)
{
for
(
Shape
*
shape
=
this
;
shape
;
)
{
if
(
shape
-
>
propidRef
(
)
=
=
id
)
{
return
shape
;
}
shape
=
shape
-
>
parent
;
}
return
nullptr
;
}
inline
bool
Shape
:
:
matches
(
const
StackShape
&
other
)
const
{
return
propid_
.
get
(
)
=
=
other
.
propid
&
&
matchesParamsAfterId
(
other
.
base
other
.
objectFlags
other
.
maybeSlot
(
)
other
.
propFlags
)
;
}
MOZ_ALWAYS_INLINE
bool
ShapeCachePtr
:
:
search
(
jsid
id
Shape
*
start
Shape
*
*
foundShape
)
{
bool
found
=
false
;
if
(
isIC
(
)
)
{
ShapeIC
*
ic
=
getICPointer
(
)
;
found
=
ic
-
>
search
(
id
foundShape
)
;
}
else
if
(
isTable
(
)
)
{
ShapeTable
*
table
=
getTablePointer
(
)
;
auto
p
=
table
-
>
searchUnchecked
(
id
)
;
*
foundShape
=
p
?
*
p
:
nullptr
;
found
=
true
;
}
return
found
;
}
MOZ_ALWAYS_INLINE
bool
ShapeIC
:
:
search
(
jsid
id
Shape
*
*
foundShape
)
{
Entry
*
entriesArray
=
entries_
.
get
(
)
;
for
(
uint8_t
i
=
0
;
i
<
nextFreeIndex_
;
i
+
+
)
{
Entry
&
entry
=
entriesArray
[
i
]
;
if
(
entry
.
id_
=
=
id
)
{
*
foundShape
=
entry
.
shape_
;
return
true
;
}
}
return
false
;
}
using
ShapePropertyVector
=
GCVector
<
ShapePropertyWithKey
8
>
;
template
<
AllowGC
allowGC
>
class
MOZ_RAII
ShapePropertyIter
{
protected
:
friend
class
Shape
;
typename
MaybeRooted
<
Shape
*
allowGC
>
:
:
RootType
cursor_
;
public
:
ShapePropertyIter
(
JSContext
*
cx
Shape
*
shape
)
:
cursor_
(
cx
shape
)
{
static_assert
(
allowGC
=
=
CanGC
)
;
MOZ_ASSERT
(
shape
-
>
getObjectClass
(
)
-
>
isNativeObject
(
)
)
;
}
explicit
ShapePropertyIter
(
Shape
*
shape
)
:
cursor_
(
nullptr
shape
)
{
static_assert
(
allowGC
=
=
NoGC
)
;
MOZ_ASSERT
(
shape
-
>
getObjectClass
(
)
-
>
isNativeObject
(
)
)
;
}
bool
done
(
)
const
{
return
cursor_
-
>
isEmptyShape
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
cursor_
=
cursor_
-
>
previous
(
)
;
}
ShapePropertyWithKey
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
cursor_
-
>
propertyWithKey
(
)
;
}
ShapePropertyWithKey
operator
*
(
)
const
{
return
get
(
)
;
}
struct
FakePtr
{
ShapePropertyWithKey
val_
;
const
ShapePropertyWithKey
*
operator
-
>
(
)
const
{
return
&
val_
;
}
}
;
FakePtr
operator
-
>
(
)
const
{
return
{
get
(
)
}
;
}
}
;
MOZ_ALWAYS_INLINE
HashNumber
ShapeTable
:
:
Hasher
:
:
hash
(
PropertyKey
key
)
{
return
HashId
(
key
)
;
}
MOZ_ALWAYS_INLINE
bool
ShapeTable
:
:
Hasher
:
:
match
(
Shape
*
shape
PropertyKey
key
)
{
return
shape
-
>
propidRaw
(
)
=
=
key
;
}
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
Shape
>
:
TracerConcrete
<
js
:
:
Shape
>
{
protected
:
explicit
Concrete
(
js
:
:
Shape
*
ptr
)
:
TracerConcrete
<
js
:
:
Shape
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
Shape
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
template
<
>
class
Concrete
<
js
:
:
BaseShape
>
:
TracerConcrete
<
js
:
:
BaseShape
>
{
protected
:
explicit
Concrete
(
js
:
:
BaseShape
*
ptr
)
:
TracerConcrete
<
js
:
:
BaseShape
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
BaseShape
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
