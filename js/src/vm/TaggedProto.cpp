#
include
"
vm
/
TaggedProto
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Zone
.
h
"
namespace
js
{
void
InternalBarrierMethods
<
TaggedProto
>
:
:
preBarrier
(
TaggedProto
&
proto
)
{
InternalBarrierMethods
<
JSObject
*
>
:
:
preBarrier
(
proto
.
toObjectOrNull
(
)
)
;
}
void
InternalBarrierMethods
<
TaggedProto
>
:
:
postBarrier
(
TaggedProto
*
vp
TaggedProto
prev
TaggedProto
next
)
{
JSObject
*
prevObj
=
prev
.
isObject
(
)
?
prev
.
toObject
(
)
:
nullptr
;
JSObject
*
nextObj
=
next
.
isObject
(
)
?
next
.
toObject
(
)
:
nullptr
;
InternalBarrierMethods
<
JSObject
*
>
:
:
postBarrier
(
reinterpret_cast
<
JSObject
*
*
>
(
vp
)
prevObj
nextObj
)
;
}
void
InternalBarrierMethods
<
TaggedProto
>
:
:
readBarrier
(
const
TaggedProto
&
proto
)
{
InternalBarrierMethods
<
JSObject
*
>
:
:
readBarrier
(
proto
.
toObjectOrNull
(
)
)
;
}
}
js
:
:
HashNumber
js
:
:
TaggedProto
:
:
hashCode
(
)
const
{
return
Zone
:
:
UniqueIdToHash
(
uniqueId
(
)
)
;
}
bool
js
:
:
TaggedProto
:
:
hasUniqueId
(
)
const
{
if
(
!
isObject
(
)
)
return
true
;
JSObject
*
obj
=
toObject
(
)
;
return
obj
-
>
zone
(
)
-
>
hasUniqueId
(
obj
)
;
}
bool
js
:
:
TaggedProto
:
:
ensureUniqueId
(
)
const
{
if
(
!
isObject
(
)
)
return
true
;
uint64_t
unusedId
;
JSObject
*
obj
=
toObject
(
)
;
return
obj
-
>
zone
(
)
-
>
getUniqueId
(
obj
&
unusedId
)
;
}
uint64_t
js
:
:
TaggedProto
:
:
uniqueId
(
)
const
{
if
(
isDynamic
(
)
)
return
uint64_t
(
1
)
;
JSObject
*
obj
=
toObjectOrNull
(
)
;
if
(
!
obj
)
return
uint64_t
(
0
)
;
return
obj
-
>
zone
(
)
-
>
getUniqueIdInfallible
(
obj
)
;
}
