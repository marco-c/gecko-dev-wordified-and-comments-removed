#
ifndef
vm_HelperThreadState_h
#
define
vm_HelperThreadState_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
ds
/
Fifo
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
HelperThreadAPI
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
ConcurrentDelazification
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
HelperThreadTask
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
class
JSTracer
;
namespace
js
{
struct
DelazifyTask
;
struct
FreeDelazifyTask
;
struct
PromiseHelperTask
;
class
PromiseObject
;
namespace
jit
{
class
IonCompileTask
;
class
IonFreeTask
;
}
namespace
wasm
{
struct
CompileTask
;
typedef
Fifo
<
CompileTask
*
0
SystemAllocPolicy
>
CompileTaskPtrFifo
;
struct
Tier2GeneratorTask
:
public
HelperThreadTask
{
virtual
~
Tier2GeneratorTask
(
)
=
default
;
virtual
void
cancel
(
)
=
0
;
}
;
using
UniqueTier2GeneratorTask
=
UniquePtr
<
Tier2GeneratorTask
>
;
typedef
Vector
<
Tier2GeneratorTask
*
0
SystemAllocPolicy
>
Tier2GeneratorTaskPtrVector
;
}
using
HelperThreadTaskVector
=
Vector
<
HelperThreadTask
*
0
SystemAllocPolicy
>
;
class
GlobalHelperThreadState
{
friend
class
AutoLockHelperThreadState
;
friend
class
AutoUnlockHelperThreadState
;
public
:
static
const
size_t
MaxTier2GeneratorTasks
=
1
;
size_t
cpuCount
;
size_t
threadCount
;
size_t
stackQuota
;
bool
terminating_
=
false
;
typedef
Vector
<
jit
:
:
IonCompileTask
*
0
SystemAllocPolicy
>
IonCompileTaskVector
;
using
IonFreeTaskVector
=
Vector
<
js
:
:
UniquePtr
<
jit
:
:
IonFreeTask
>
0
SystemAllocPolicy
>
;
using
DelazifyTaskList
=
mozilla
:
:
LinkedList
<
DelazifyTask
>
;
using
FreeDelazifyTaskVector
=
Vector
<
js
:
:
UniquePtr
<
FreeDelazifyTask
>
1
SystemAllocPolicy
>
;
typedef
Vector
<
UniquePtr
<
SourceCompressionTask
>
0
SystemAllocPolicy
>
SourceCompressionTaskVector
;
typedef
Vector
<
PromiseHelperTask
*
0
SystemAllocPolicy
>
PromiseHelperTaskVector
;
mozilla
:
:
EnumeratedArray
<
ThreadType
size_t
size_t
(
ThreadType
:
:
THREAD_TYPE_MAX
)
>
runningTaskCount
;
size_t
totalCountRunningTasks
;
WriteOnceData
<
JS
:
:
RegisterThreadCallback
>
registerThread
;
WriteOnceData
<
JS
:
:
UnregisterThreadCallback
>
unregisterThread
;
HelperThreadLockData
<
size_t
>
gcParallelMarkingThreads
;
private
:
IonCompileTaskVector
ionWorklist_
ionFinishedList_
;
IonFreeTaskVector
ionFreeList_
;
wasm
:
:
CompileTaskPtrFifo
wasmWorklist_tier1_
;
wasm
:
:
CompileTaskPtrFifo
wasmWorklist_tier2_
;
wasm
:
:
Tier2GeneratorTaskPtrVector
wasmTier2GeneratorWorklist_
;
uint32_t
wasmTier2GeneratorsFinished_
;
PromiseHelperTaskVector
promiseHelperTasks_
;
DelazifyTaskList
delazifyWorklist_
;
FreeDelazifyTaskVector
freeDelazifyTaskVector_
;
SourceCompressionTaskVector
compressionPendingList_
;
SourceCompressionTaskVector
compressionWorklist_
;
SourceCompressionTaskVector
compressionFinishedList_
;
GCParallelTaskList
gcParallelWorklist_
;
HelperThreadTaskVector
helperTasks_
;
JS
:
:
HelperThreadTaskCallback
dispatchTaskCallback
=
nullptr
;
js
:
:
ConditionVariable
consumerWakeup
;
#
ifdef
DEBUG
size_t
tasksPending_
=
0
;
#
endif
bool
isInitialized_
=
false
;
bool
useInternalThreadPool_
=
true
;
public
:
void
addSizeOfIncludingThis
(
JS
:
:
GlobalStats
*
stats
const
AutoLockHelperThreadState
&
lock
)
const
;
size_t
maxIonCompilationThreads
(
)
const
;
size_t
maxIonFreeThreads
(
)
const
;
size_t
maxWasmCompilationThreads
(
)
const
;
size_t
maxWasmTier2GeneratorThreads
(
)
const
;
size_t
maxPromiseHelperThreads
(
)
const
;
size_t
maxDelazifyThreads
(
)
const
;
size_t
maxCompressionThreads
(
)
const
;
size_t
maxGCParallelThreads
(
)
const
;
GlobalHelperThreadState
(
)
;
bool
isInitialized
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
isInitialized_
;
}
[
[
nodiscard
]
]
bool
ensureInitialized
(
)
;
[
[
nodiscard
]
]
bool
ensureThreadCount
(
size_t
count
AutoLockHelperThreadState
&
lock
)
;
void
finish
(
AutoLockHelperThreadState
&
lock
)
;
void
finishThreads
(
AutoLockHelperThreadState
&
lock
)
;
void
setCpuCount
(
size_t
count
)
;
void
setDispatchTaskCallback
(
JS
:
:
HelperThreadTaskCallback
callback
size_t
threadCount
size_t
stackSize
const
AutoLockHelperThreadState
&
lock
)
;
void
destroyHelperContexts
(
AutoLockHelperThreadState
&
lock
)
;
#
ifdef
DEBUG
void
assertIsLockedByCurrentThread
(
)
const
;
#
endif
void
wait
(
AutoLockHelperThreadState
&
locked
mozilla
:
:
TimeDuration
timeout
=
mozilla
:
:
TimeDuration
:
:
Forever
(
)
)
;
void
notifyAll
(
const
AutoLockHelperThreadState
&
)
;
bool
useInternalThreadPool
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
useInternalThreadPool_
;
}
bool
isTerminating
(
const
AutoLockHelperThreadState
&
locked
)
const
{
return
terminating_
;
}
private
:
void
notifyOne
(
const
AutoLockHelperThreadState
&
)
;
public
:
template
<
typename
T
>
static
void
remove
(
T
&
vector
size_t
*
index
)
{
if
(
*
index
!
=
vector
.
length
(
)
-
1
)
{
vector
[
*
index
]
=
std
:
:
move
(
vector
.
back
(
)
)
;
}
(
*
index
)
-
-
;
vector
.
popBack
(
)
;
}
IonCompileTaskVector
&
ionWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
ionWorklist_
;
}
IonCompileTaskVector
&
ionFinishedList
(
const
AutoLockHelperThreadState
&
)
{
return
ionFinishedList_
;
}
IonFreeTaskVector
&
ionFreeList
(
const
AutoLockHelperThreadState
&
)
{
return
ionFreeList_
;
}
wasm
:
:
CompileTaskPtrFifo
&
wasmWorklist
(
const
AutoLockHelperThreadState
&
wasm
:
:
CompileMode
m
)
{
switch
(
m
)
{
case
wasm
:
:
CompileMode
:
:
Once
:
case
wasm
:
:
CompileMode
:
:
Tier1
:
return
wasmWorklist_tier1_
;
case
wasm
:
:
CompileMode
:
:
Tier2
:
return
wasmWorklist_tier2_
;
default
:
MOZ_CRASH
(
)
;
}
}
wasm
:
:
Tier2GeneratorTaskPtrVector
&
wasmTier2GeneratorWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
wasmTier2GeneratorWorklist_
;
}
void
incWasmTier2GeneratorsFinished
(
const
AutoLockHelperThreadState
&
)
{
wasmTier2GeneratorsFinished_
+
+
;
}
uint32_t
wasmTier2GeneratorsFinished
(
const
AutoLockHelperThreadState
&
)
const
{
return
wasmTier2GeneratorsFinished_
;
}
PromiseHelperTaskVector
&
promiseHelperTasks
(
const
AutoLockHelperThreadState
&
)
{
return
promiseHelperTasks_
;
}
DelazifyTaskList
&
delazifyWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
delazifyWorklist_
;
}
FreeDelazifyTaskVector
&
freeDelazifyTaskVector
(
const
AutoLockHelperThreadState
&
)
{
return
freeDelazifyTaskVector_
;
}
SourceCompressionTaskVector
&
compressionPendingList
(
const
AutoLockHelperThreadState
&
)
{
return
compressionPendingList_
;
}
SourceCompressionTaskVector
&
compressionWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
compressionWorklist_
;
}
SourceCompressionTaskVector
&
compressionFinishedList
(
const
AutoLockHelperThreadState
&
)
{
return
compressionFinishedList_
;
}
private
:
GCParallelTaskList
&
gcParallelWorklist
(
)
{
return
gcParallelWorklist_
;
}
HelperThreadTaskVector
&
helperTasks
(
const
AutoLockHelperThreadState
&
)
{
return
helperTasks_
;
}
bool
canStartWasmCompile
(
const
AutoLockHelperThreadState
&
lock
wasm
:
:
CompileMode
mode
)
;
bool
canStartWasmTier1CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartWasmTier2CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartWasmTier2GeneratorTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartPromiseHelperTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartIonFreeTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartFreeDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartCompressionTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartGCParallelTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetWasmCompile
(
const
AutoLockHelperThreadState
&
lock
wasm
:
:
CompileMode
mode
)
;
HelperThreadTask
*
maybeGetWasmTier1CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetWasmTier2CompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetWasmTier2GeneratorTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetPromiseHelperTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetLowPrioIonCompileTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetIonFreeTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetFreeDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetDelazifyTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetCompressionTask
(
const
AutoLockHelperThreadState
&
lock
)
;
HelperThreadTask
*
maybeGetGCParallelTask
(
const
AutoLockHelperThreadState
&
lock
)
;
jit
:
:
IonCompileTask
*
highestPriorityPendingIonCompile
(
const
AutoLockHelperThreadState
&
lock
bool
checkExecutionStatus
)
;
bool
checkTaskThreadLimit
(
ThreadType
threadType
size_t
maxThreads
bool
isMaster
const
AutoLockHelperThreadState
&
lock
)
const
;
bool
checkTaskThreadLimit
(
ThreadType
threadType
size_t
maxThreads
const
AutoLockHelperThreadState
&
lock
)
const
{
return
checkTaskThreadLimit
(
threadType
maxThreads
false
lock
)
;
}
bool
hasActiveThreads
(
const
AutoLockHelperThreadState
&
)
;
bool
canStartTasks
(
const
AutoLockHelperThreadState
&
locked
)
;
public
:
enum
class
ScheduleCompressionTask
{
GC
API
}
;
void
startHandlingCompressionTasks
(
ScheduleCompressionTask
schedule
JSRuntime
*
maybeRuntime
const
AutoLockHelperThreadState
&
lock
)
;
void
runPendingSourceCompressions
(
JSRuntime
*
runtime
AutoLockHelperThreadState
&
lock
)
;
void
trace
(
JSTracer
*
trc
)
;
void
waitForAllTasks
(
)
;
void
waitForAllTasksLocked
(
AutoLockHelperThreadState
&
)
;
#
ifdef
DEBUG
bool
hasOffThreadIonCompile
(
Zone
*
zone
AutoLockHelperThreadState
&
lock
)
;
#
endif
void
cancelOffThreadIonCompile
(
const
CompilationSelector
&
selector
)
;
void
cancelOffThreadWasmTier2Generator
(
AutoLockHelperThreadState
&
lock
)
;
bool
hasAnyDelazifyTask
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
;
void
cancelPendingDelazifyTask
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
;
void
waitUntilCancelledDelazifyTasks
(
JSRuntime
*
rt
AutoLockHelperThreadState
&
lock
)
;
void
waitUntilEmptyFreeDelazifyTaskVector
(
AutoLockHelperThreadState
&
lock
)
;
void
cancelOffThreadCompressions
(
JSRuntime
*
runtime
AutoLockHelperThreadState
&
lock
)
;
void
triggerFreeUnusedMemory
(
)
;
bool
submitTask
(
wasm
:
:
UniqueTier2GeneratorTask
task
)
;
bool
submitTask
(
wasm
:
:
CompileTask
*
task
wasm
:
:
CompileMode
mode
)
;
bool
submitTask
(
UniquePtr
<
jit
:
:
IonFreeTask
>
&
&
task
const
AutoLockHelperThreadState
&
lock
)
;
bool
submitTask
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
locked
)
;
bool
submitTask
(
UniquePtr
<
SourceCompressionTask
>
task
const
AutoLockHelperThreadState
&
locked
)
;
void
submitTask
(
DelazifyTask
*
task
const
AutoLockHelperThreadState
&
locked
)
;
bool
submitTask
(
UniquePtr
<
FreeDelazifyTask
>
task
const
AutoLockHelperThreadState
&
locked
)
;
bool
submitTask
(
PromiseHelperTask
*
task
)
;
bool
submitTask
(
GCParallelTask
*
task
const
AutoLockHelperThreadState
&
locked
)
;
void
runOneTask
(
HelperThreadTask
*
task
AutoLockHelperThreadState
&
lock
)
;
private
:
void
dispatch
(
JS
:
:
DispatchReason
reason
const
AutoLockHelperThreadState
&
locked
)
;
HelperThreadTask
*
findHighestPriorityTask
(
const
AutoLockHelperThreadState
&
locked
)
;
void
runTaskLocked
(
HelperThreadTask
*
task
AutoLockHelperThreadState
&
lock
)
;
using
Selector
=
HelperThreadTask
*
(
GlobalHelperThreadState
:
:
*
)
(
const
AutoLockHelperThreadState
&
)
;
static
const
Selector
selectors
[
]
;
}
;
static
inline
bool
IsHelperThreadStateInitialized
(
)
{
extern
GlobalHelperThreadState
*
gHelperThreadState
;
return
gHelperThreadState
;
}
static
inline
GlobalHelperThreadState
&
HelperThreadState
(
)
{
extern
GlobalHelperThreadState
*
gHelperThreadState
;
MOZ_ASSERT
(
gHelperThreadState
)
;
return
*
gHelperThreadState
;
}
struct
DelazifyTask
:
public
mozilla
:
:
LinkedListElement
<
DelazifyTask
>
public
HelperThreadTask
{
JSRuntime
*
maybeRuntime
=
nullptr
;
DelazificationContext
delazificationCx
;
static
UniquePtr
<
DelazifyTask
>
Create
(
JSRuntime
*
maybeRuntime
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
frontend
:
:
CompilationStencil
&
stencil
)
;
DelazifyTask
(
JSRuntime
*
maybeRuntime
const
JS
:
:
PrefableCompileOptions
&
initialPrefableOptions
)
;
~
DelazifyTask
(
)
;
[
[
nodiscard
]
]
bool
init
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
frontend
:
:
CompilationStencil
&
stencil
)
;
bool
runtimeMatchesOrNoRuntime
(
JSRuntime
*
rt
)
{
return
!
maybeRuntime
|
|
maybeRuntime
=
=
rt
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
override
;
[
[
nodiscard
]
]
bool
runTask
(
)
;
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_DELAZIFY
;
}
bool
done
(
)
const
;
}
;
struct
FreeDelazifyTask
:
public
HelperThreadTask
{
DelazifyTask
*
task
;
explicit
FreeDelazifyTask
(
DelazifyTask
*
t
)
:
task
(
t
)
{
}
void
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
override
;
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_DELAZIFY_FREE
;
}
}
;
class
SourceCompressionTask
:
public
HelperThreadTask
{
friend
class
HelperThread
;
friend
class
ScriptSource
;
JSRuntime
*
runtime_
;
uint64_t
majorGCNumber_
;
RefPtr
<
ScriptSource
>
source_
;
SharedImmutableString
resultString_
;
public
:
SourceCompressionTask
(
JSRuntime
*
rt
ScriptSource
*
source
)
:
runtime_
(
rt
)
majorGCNumber_
(
rt
-
>
gc
.
majorGCCount
(
)
)
source_
(
source
)
{
source
-
>
noteSourceCompressionTask
(
)
;
}
virtual
~
SourceCompressionTask
(
)
=
default
;
bool
runtimeMatches
(
JSRuntime
*
runtime
)
const
{
return
runtime
=
=
runtime_
;
}
bool
shouldStart
(
)
const
{
return
runtime_
-
>
gc
.
majorGCCount
(
)
>
majorGCNumber_
+
1
;
}
bool
shouldCancel
(
)
const
{
return
source_
-
>
refs
=
=
1
;
}
void
runTask
(
)
;
void
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
override
;
void
complete
(
)
;
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_COMPRESS
;
}
private
:
struct
PerformTaskWork
;
friend
struct
PerformTaskWork
;
template
<
typename
CharT
>
void
workEncodingSpecific
(
)
;
}
;
struct
PromiseHelperTask
:
OffThreadPromiseTask
public
HelperThreadTask
{
PromiseHelperTask
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
)
:
OffThreadPromiseTask
(
cx
promise
)
{
}
virtual
void
execute
(
)
=
0
;
void
executeAndResolveAndDestroy
(
JSContext
*
cx
)
;
void
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
override
;
ThreadType
threadType
(
)
override
{
return
THREAD_TYPE_PROMISE_TASK
;
}
}
;
}
#
endif
