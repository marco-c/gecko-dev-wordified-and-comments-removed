#
include
"
vm
/
SavedStacks
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jshashutil
.
h
"
#
include
"
jsmath
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
GeckoProfiler
.
h
"
#
include
"
vm
/
JSCompartment
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
mozilla
:
:
AddToHash
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
HashString
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
namespace
js
{
const
uint32_t
ASYNC_STACK_MAX_FRAME_COUNT
=
60
;
Maybe
<
LiveSavedFrameCache
:
:
FramePtr
>
LiveSavedFrameCache
:
:
getFramePtr
(
FrameIter
&
iter
)
{
if
(
iter
.
hasUsableAbstractFramePtr
(
)
)
return
Some
(
FramePtr
(
iter
.
abstractFramePtr
(
)
)
)
;
if
(
iter
.
isPhysicalIonFrame
(
)
)
return
Some
(
FramePtr
(
iter
.
physicalIonFrame
(
)
)
)
;
return
Nothing
(
)
;
}
void
LiveSavedFrameCache
:
:
trace
(
JSTracer
*
trc
)
{
if
(
!
initialized
(
)
)
return
;
for
(
auto
*
entry
=
frames
-
>
begin
(
)
;
entry
<
frames
-
>
end
(
)
;
entry
+
+
)
{
TraceEdge
(
trc
&
entry
-
>
savedFrame
"
LiveSavedFrameCache
:
:
frames
SavedFrame
"
)
;
}
}
bool
LiveSavedFrameCache
:
:
insert
(
JSContext
*
cx
FramePtr
&
framePtr
jsbytecode
*
pc
HandleSavedFrame
savedFrame
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
if
(
!
frames
-
>
emplaceBack
(
framePtr
pc
savedFrame
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
framePtr
.
is
<
AbstractFramePtr
>
(
)
)
framePtr
.
as
<
AbstractFramePtr
>
(
)
.
setHasCachedSavedFrame
(
)
;
else
framePtr
.
as
<
jit
:
:
CommonFrameLayout
*
>
(
)
-
>
setHasCachedSavedFrame
(
)
;
return
true
;
}
void
LiveSavedFrameCache
:
:
find
(
JSContext
*
cx
FrameIter
&
frameIter
MutableHandleSavedFrame
frame
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
MOZ_ASSERT
(
!
frameIter
.
done
(
)
)
;
MOZ_ASSERT
(
frameIter
.
hasCachedSavedFrame
(
)
)
;
Maybe
<
FramePtr
>
maybeFramePtr
=
getFramePtr
(
frameIter
)
;
MOZ_ASSERT
(
maybeFramePtr
.
isSome
(
)
)
;
FramePtr
framePtr
(
*
maybeFramePtr
)
;
jsbytecode
*
pc
=
frameIter
.
pc
(
)
;
size_t
numberStillValid
=
0
;
frame
.
set
(
nullptr
)
;
for
(
auto
*
p
=
frames
-
>
begin
(
)
;
p
<
frames
-
>
end
(
)
;
p
+
+
)
{
numberStillValid
+
+
;
if
(
framePtr
=
=
p
-
>
framePtr
&
&
pc
=
=
p
-
>
pc
)
{
frame
.
set
(
p
-
>
savedFrame
)
;
break
;
}
}
if
(
!
frame
)
{
frames
-
>
clear
(
)
;
return
;
}
MOZ_ASSERT
(
0
<
numberStillValid
&
&
numberStillValid
<
=
frames
-
>
length
(
)
)
;
if
(
frame
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
frame
.
set
(
nullptr
)
;
numberStillValid
-
-
;
}
frames
-
>
shrinkBy
(
frames
-
>
length
(
)
-
numberStillValid
)
;
}
struct
SavedFrame
:
:
Lookup
{
Lookup
(
JSAtom
*
source
uint32_t
line
uint32_t
column
JSAtom
*
functionDisplayName
JSAtom
*
asyncCause
SavedFrame
*
parent
JSPrincipals
*
principals
const
Maybe
<
LiveSavedFrameCache
:
:
FramePtr
>
&
framePtr
=
Nothing
(
)
jsbytecode
*
pc
=
nullptr
Activation
*
activation
=
nullptr
)
:
source
(
source
)
line
(
line
)
column
(
column
)
functionDisplayName
(
functionDisplayName
)
asyncCause
(
asyncCause
)
parent
(
parent
)
principals
(
principals
)
framePtr
(
framePtr
)
pc
(
pc
)
activation
(
activation
)
{
MOZ_ASSERT
(
source
)
;
MOZ_ASSERT_IF
(
framePtr
.
isSome
(
)
activation
)
;
#
ifdef
JS_MORE_DETERMINISTIC
column
=
0
;
#
endif
}
explicit
Lookup
(
SavedFrame
&
savedFrame
)
:
source
(
savedFrame
.
getSource
(
)
)
line
(
savedFrame
.
getLine
(
)
)
column
(
savedFrame
.
getColumn
(
)
)
functionDisplayName
(
savedFrame
.
getFunctionDisplayName
(
)
)
asyncCause
(
savedFrame
.
getAsyncCause
(
)
)
parent
(
savedFrame
.
getParent
(
)
)
principals
(
savedFrame
.
getPrincipals
(
)
)
framePtr
(
Nothing
(
)
)
pc
(
nullptr
)
activation
(
nullptr
)
{
MOZ_ASSERT
(
source
)
;
}
JSAtom
*
source
;
uint32_t
line
;
uint32_t
column
;
JSAtom
*
functionDisplayName
;
JSAtom
*
asyncCause
;
SavedFrame
*
parent
;
JSPrincipals
*
principals
;
Maybe
<
LiveSavedFrameCache
:
:
FramePtr
>
framePtr
;
jsbytecode
*
pc
;
Activation
*
activation
;
void
trace
(
JSTracer
*
trc
)
{
TraceManuallyBarrieredEdge
(
trc
&
source
"
SavedFrame
:
:
Lookup
:
:
source
"
)
;
if
(
functionDisplayName
)
{
TraceManuallyBarrieredEdge
(
trc
&
functionDisplayName
"
SavedFrame
:
:
Lookup
:
:
functionDisplayName
"
)
;
}
if
(
asyncCause
)
TraceManuallyBarrieredEdge
(
trc
&
asyncCause
"
SavedFrame
:
:
Lookup
:
:
asyncCause
"
)
;
if
(
parent
)
TraceManuallyBarrieredEdge
(
trc
&
parent
"
SavedFrame
:
:
Lookup
:
:
parent
"
)
;
}
}
;
class
MOZ_STACK_CLASS
SavedFrame
:
:
AutoLookupVector
:
public
JS
:
:
CustomAutoRooter
{
public
:
explicit
AutoLookupVector
(
JSContext
*
cx
)
:
JS
:
:
CustomAutoRooter
(
cx
)
lookups
(
cx
)
{
}
typedef
Vector
<
Lookup
ASYNC_STACK_MAX_FRAME_COUNT
>
LookupVector
;
inline
LookupVector
*
operator
-
>
(
)
{
return
&
lookups
;
}
inline
HandleLookup
operator
[
]
(
size_t
i
)
{
return
HandleLookup
(
lookups
[
i
]
)
;
}
private
:
LookupVector
lookups
;
virtual
void
trace
(
JSTracer
*
trc
)
override
{
for
(
size_t
i
=
0
;
i
<
lookups
.
length
(
)
;
i
+
+
)
lookups
[
i
]
.
trace
(
trc
)
;
}
}
;
bool
SavedFrame
:
:
HashPolicy
:
:
hasHash
(
const
Lookup
&
l
)
{
return
SavedFramePtrHasher
:
:
hasHash
(
l
.
parent
)
;
}
bool
SavedFrame
:
:
HashPolicy
:
:
ensureHash
(
const
Lookup
&
l
)
{
return
SavedFramePtrHasher
:
:
ensureHash
(
l
.
parent
)
;
}
HashNumber
SavedFrame
:
:
HashPolicy
:
:
hash
(
const
Lookup
&
lookup
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
AddToHash
(
lookup
.
line
lookup
.
column
lookup
.
source
lookup
.
functionDisplayName
lookup
.
asyncCause
SavedFramePtrHasher
:
:
hash
(
lookup
.
parent
)
JSPrincipalsPtrHasher
:
:
hash
(
lookup
.
principals
)
)
;
}
bool
SavedFrame
:
:
HashPolicy
:
:
match
(
SavedFrame
*
existing
const
Lookup
&
lookup
)
{
MOZ_ASSERT
(
existing
)
;
if
(
existing
-
>
getLine
(
)
!
=
lookup
.
line
)
return
false
;
if
(
existing
-
>
getColumn
(
)
!
=
lookup
.
column
)
return
false
;
if
(
existing
-
>
getParent
(
)
!
=
lookup
.
parent
)
return
false
;
if
(
existing
-
>
getPrincipals
(
)
!
=
lookup
.
principals
)
return
false
;
JSAtom
*
source
=
existing
-
>
getSource
(
)
;
if
(
source
!
=
lookup
.
source
)
return
false
;
JSAtom
*
functionDisplayName
=
existing
-
>
getFunctionDisplayName
(
)
;
if
(
functionDisplayName
!
=
lookup
.
functionDisplayName
)
return
false
;
JSAtom
*
asyncCause
=
existing
-
>
getAsyncCause
(
)
;
if
(
asyncCause
!
=
lookup
.
asyncCause
)
return
false
;
return
true
;
}
void
SavedFrame
:
:
HashPolicy
:
:
rekey
(
Key
&
key
const
Key
&
newKey
)
{
key
=
newKey
;
}
bool
SavedFrame
:
:
finishSavedFrameInit
(
JSContext
*
cx
HandleObject
ctor
HandleObject
proto
)
{
proto
-
>
as
<
NativeObject
>
(
)
.
setReservedSlot
(
SavedFrame
:
:
JSSLOT_SOURCE
NullValue
(
)
)
;
return
FreezeObject
(
cx
proto
)
;
}
static
const
ClassOps
SavedFrameClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
SavedFrame
:
:
finalize
nullptr
nullptr
nullptr
nullptr
}
;
const
ClassSpec
SavedFrame
:
:
classSpec_
=
{
GenericCreateConstructor
<
SavedFrame
:
:
construct
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
SavedFrame
:
:
staticFunctions
nullptr
SavedFrame
:
:
protoFunctions
SavedFrame
:
:
protoAccessors
SavedFrame
:
:
finishSavedFrameInit
ClassSpec
:
:
DontDefineConstructor
}
;
const
Class
SavedFrame
:
:
class_
=
{
"
SavedFrame
"
JSCLASS_HAS_PRIVATE
|
JSCLASS_HAS_RESERVED_SLOTS
(
SavedFrame
:
:
JSSLOT_COUNT
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_SavedFrame
)
|
JSCLASS_IS_ANONYMOUS
|
JSCLASS_FOREGROUND_FINALIZE
&
SavedFrameClassOps
&
SavedFrame
:
:
classSpec_
}
;
const
JSFunctionSpec
SavedFrame
:
:
staticFunctions
[
]
=
{
JS_FS_END
}
;
const
JSFunctionSpec
SavedFrame
:
:
protoFunctions
[
]
=
{
JS_FN
(
"
constructor
"
SavedFrame
:
:
construct
0
0
)
JS_FN
(
"
toString
"
SavedFrame
:
:
toStringMethod
0
0
)
JS_FS_END
}
;
const
JSPropertySpec
SavedFrame
:
:
protoAccessors
[
]
=
{
JS_PSG
(
"
source
"
SavedFrame
:
:
sourceProperty
0
)
JS_PSG
(
"
line
"
SavedFrame
:
:
lineProperty
0
)
JS_PSG
(
"
column
"
SavedFrame
:
:
columnProperty
0
)
JS_PSG
(
"
functionDisplayName
"
SavedFrame
:
:
functionDisplayNameProperty
0
)
JS_PSG
(
"
asyncCause
"
SavedFrame
:
:
asyncCauseProperty
0
)
JS_PSG
(
"
asyncParent
"
SavedFrame
:
:
asyncParentProperty
0
)
JS_PSG
(
"
parent
"
SavedFrame
:
:
parentProperty
0
)
JS_PS_END
}
;
void
SavedFrame
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onActiveCooperatingThread
(
)
)
;
JSPrincipals
*
p
=
obj
-
>
as
<
SavedFrame
>
(
)
.
getPrincipals
(
)
;
if
(
p
)
{
JSRuntime
*
rt
=
obj
-
>
runtimeFromActiveCooperatingThread
(
)
;
JS_DropPrincipals
(
rt
-
>
activeContextFromOwnThread
(
)
p
)
;
}
}
JSAtom
*
SavedFrame
:
:
getSource
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_SOURCE
)
;
JSString
*
s
=
v
.
toString
(
)
;
return
&
s
-
>
asAtom
(
)
;
}
uint32_t
SavedFrame
:
:
getLine
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_LINE
)
;
return
v
.
toPrivateUint32
(
)
;
}
uint32_t
SavedFrame
:
:
getColumn
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_COLUMN
)
;
return
v
.
toPrivateUint32
(
)
;
}
JSAtom
*
SavedFrame
:
:
getFunctionDisplayName
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_FUNCTIONDISPLAYNAME
)
;
if
(
v
.
isNull
(
)
)
return
nullptr
;
JSString
*
s
=
v
.
toString
(
)
;
return
&
s
-
>
asAtom
(
)
;
}
JSAtom
*
SavedFrame
:
:
getAsyncCause
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_ASYNCCAUSE
)
;
if
(
v
.
isNull
(
)
)
return
nullptr
;
JSString
*
s
=
v
.
toString
(
)
;
return
&
s
-
>
asAtom
(
)
;
}
SavedFrame
*
SavedFrame
:
:
getParent
(
)
const
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_PARENT
)
;
return
v
.
isObject
(
)
?
&
v
.
toObject
(
)
.
as
<
SavedFrame
>
(
)
:
nullptr
;
}
JSPrincipals
*
SavedFrame
:
:
getPrincipals
(
)
{
const
Value
&
v
=
getReservedSlot
(
JSSLOT_PRINCIPALS
)
;
if
(
v
.
isUndefined
(
)
)
return
nullptr
;
return
static_cast
<
JSPrincipals
*
>
(
v
.
toPrivate
(
)
)
;
}
void
SavedFrame
:
:
initSource
(
JSAtom
*
source
)
{
MOZ_ASSERT
(
source
)
;
initReservedSlot
(
JSSLOT_SOURCE
StringValue
(
source
)
)
;
}
void
SavedFrame
:
:
initLine
(
uint32_t
line
)
{
initReservedSlot
(
JSSLOT_LINE
PrivateUint32Value
(
line
)
)
;
}
void
SavedFrame
:
:
initColumn
(
uint32_t
column
)
{
#
ifdef
JS_MORE_DETERMINISTIC
column
=
0
;
#
endif
initReservedSlot
(
JSSLOT_COLUMN
PrivateUint32Value
(
column
)
)
;
}
void
SavedFrame
:
:
initPrincipals
(
JSPrincipals
*
principals
)
{
if
(
principals
)
JS_HoldPrincipals
(
principals
)
;
initPrincipalsAlreadyHeld
(
principals
)
;
}
void
SavedFrame
:
:
initPrincipalsAlreadyHeld
(
JSPrincipals
*
principals
)
{
MOZ_ASSERT_IF
(
principals
principals
-
>
refcount
>
0
)
;
initReservedSlot
(
JSSLOT_PRINCIPALS
PrivateValue
(
principals
)
)
;
}
void
SavedFrame
:
:
initFunctionDisplayName
(
JSAtom
*
maybeName
)
{
initReservedSlot
(
JSSLOT_FUNCTIONDISPLAYNAME
maybeName
?
StringValue
(
maybeName
)
:
NullValue
(
)
)
;
}
void
SavedFrame
:
:
initAsyncCause
(
JSAtom
*
maybeCause
)
{
initReservedSlot
(
JSSLOT_ASYNCCAUSE
maybeCause
?
StringValue
(
maybeCause
)
:
NullValue
(
)
)
;
}
void
SavedFrame
:
:
initParent
(
SavedFrame
*
maybeParent
)
{
initReservedSlot
(
JSSLOT_PARENT
ObjectOrNullValue
(
maybeParent
)
)
;
}
void
SavedFrame
:
:
initFromLookup
(
JSContext
*
cx
SavedFrame
:
:
HandleLookup
lookup
)
{
if
(
lookup
-
>
source
)
cx
-
>
markAtom
(
lookup
-
>
source
)
;
if
(
lookup
-
>
functionDisplayName
)
cx
-
>
markAtom
(
lookup
-
>
functionDisplayName
)
;
if
(
lookup
-
>
asyncCause
)
cx
-
>
markAtom
(
lookup
-
>
asyncCause
)
;
initSource
(
lookup
-
>
source
)
;
initLine
(
lookup
-
>
line
)
;
initColumn
(
lookup
-
>
column
)
;
initFunctionDisplayName
(
lookup
-
>
functionDisplayName
)
;
initAsyncCause
(
lookup
-
>
asyncCause
)
;
initParent
(
lookup
-
>
parent
)
;
initPrincipals
(
lookup
-
>
principals
)
;
}
SavedFrame
*
SavedFrame
:
:
create
(
JSContext
*
cx
)
{
RootedGlobalObject
global
(
cx
cx
-
>
global
(
)
)
;
assertSameCompartment
(
cx
global
)
;
SavedStacks
:
:
AutoReentrancyGuard
guard
(
cx
-
>
compartment
(
)
-
>
savedStacks
(
)
)
;
RootedNativeObject
proto
(
cx
GlobalObject
:
:
getOrCreateSavedFramePrototype
(
cx
global
)
)
;
if
(
!
proto
)
return
nullptr
;
assertSameCompartment
(
cx
proto
)
;
RootedObject
frameObj
(
cx
NewObjectWithGivenProto
(
cx
&
SavedFrame
:
:
class_
proto
TenuredObject
)
)
;
if
(
!
frameObj
)
return
nullptr
;
return
&
frameObj
-
>
as
<
SavedFrame
>
(
)
;
}
bool
SavedFrame
:
:
isSelfHosted
(
JSContext
*
cx
)
{
JSAtom
*
source
=
getSource
(
)
;
return
source
=
=
cx
-
>
names
(
)
.
selfHosted
;
}
bool
SavedFrame
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NO_CONSTRUCTOR
"
SavedFrame
"
)
;
return
false
;
}
static
bool
SavedFrameSubsumedByCaller
(
JSContext
*
cx
HandleSavedFrame
frame
)
{
auto
subsumes
=
cx
-
>
runtime
(
)
-
>
securityCallbacks
-
>
subsumes
;
if
(
!
subsumes
)
return
true
;
auto
currentCompartmentPrincipals
=
cx
-
>
compartment
(
)
-
>
principals
(
)
;
MOZ_ASSERT
(
!
ReconstructedSavedFramePrincipals
:
:
is
(
currentCompartmentPrincipals
)
)
;
auto
framePrincipals
=
frame
-
>
getPrincipals
(
)
;
if
(
framePrincipals
=
=
&
ReconstructedSavedFramePrincipals
:
:
IsSystem
)
return
cx
-
>
runningWithTrustedPrincipals
(
)
;
if
(
framePrincipals
=
=
&
ReconstructedSavedFramePrincipals
:
:
IsNotSystem
)
return
true
;
return
subsumes
(
currentCompartmentPrincipals
framePrincipals
)
;
}
static
SavedFrame
*
GetFirstSubsumedFrame
(
JSContext
*
cx
HandleSavedFrame
frame
JS
:
:
SavedFrameSelfHosted
selfHosted
bool
&
skippedAsync
)
{
skippedAsync
=
false
;
RootedSavedFrame
rootedFrame
(
cx
frame
)
;
while
(
rootedFrame
)
{
if
(
(
selfHosted
=
=
JS
:
:
SavedFrameSelfHosted
:
:
Include
|
|
!
rootedFrame
-
>
isSelfHosted
(
cx
)
)
&
&
SavedFrameSubsumedByCaller
(
cx
rootedFrame
)
)
{
return
rootedFrame
;
}
if
(
rootedFrame
-
>
getAsyncCause
(
)
)
skippedAsync
=
true
;
rootedFrame
=
rootedFrame
-
>
getParent
(
)
;
}
return
nullptr
;
}
JS_FRIEND_API
(
JSObject
*
)
GetFirstSubsumedSavedFrame
(
JSContext
*
cx
HandleObject
savedFrame
JS
:
:
SavedFrameSelfHosted
selfHosted
)
{
if
(
!
savedFrame
)
return
nullptr
;
bool
skippedAsync
;
RootedSavedFrame
frame
(
cx
&
savedFrame
-
>
as
<
SavedFrame
>
(
)
)
;
return
GetFirstSubsumedFrame
(
cx
frame
selfHosted
skippedAsync
)
;
}
static
MOZ_MUST_USE
bool
SavedFrame_checkThis
(
JSContext
*
cx
CallArgs
&
args
const
char
*
fnName
MutableHandleObject
frame
)
{
const
Value
&
thisValue
=
args
.
thisv
(
)
;
if
(
!
thisValue
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_NONNULL_OBJECT
InformalValueTypeName
(
thisValue
)
)
;
return
false
;
}
JSObject
*
thisObject
=
CheckedUnwrap
(
&
thisValue
.
toObject
(
)
)
;
if
(
!
thisObject
|
|
!
thisObject
-
>
is
<
SavedFrame
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
SavedFrame
:
:
class_
.
name
fnName
thisObject
?
thisObject
-
>
getClass
(
)
-
>
name
:
"
object
"
)
;
return
false
;
}
if
(
!
SavedFrame
:
:
isSavedFrameAndNotProto
(
*
thisObject
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
SavedFrame
:
:
class_
.
name
fnName
"
prototype
object
"
)
;
return
false
;
}
frame
.
set
(
&
thisValue
.
toObject
(
)
)
;
return
true
;
}
#
define
THIS_SAVEDFRAME
(
cx
argc
vp
fnName
args
frame
)
\
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
\
RootedObject
frame
(
cx
)
;
\
if
(
!
SavedFrame_checkThis
(
cx
args
fnName
&
frame
)
)
\
return
false
;
}
namespace
JS
{
namespace
{
class
MOZ_STACK_CLASS
AutoMaybeEnterFrameCompartment
{
public
:
AutoMaybeEnterFrameCompartment
(
JSContext
*
cx
HandleObject
obj
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
if
(
obj
)
MOZ_RELEASE_ASSERT
(
obj
-
>
compartment
(
)
)
;
if
(
obj
&
&
cx
-
>
compartment
(
)
!
=
obj
-
>
compartment
(
)
)
{
JSSubsumesOp
subsumes
=
cx
-
>
runtime
(
)
-
>
securityCallbacks
-
>
subsumes
;
if
(
subsumes
&
&
subsumes
(
cx
-
>
compartment
(
)
-
>
principals
(
)
obj
-
>
compartment
(
)
-
>
principals
(
)
)
)
{
ac_
.
emplace
(
cx
obj
)
;
}
}
}
private
:
Maybe
<
JSAutoCompartment
>
ac_
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
static
inline
js
:
:
SavedFrame
*
UnwrapSavedFrame
(
JSContext
*
cx
HandleObject
obj
SavedFrameSelfHosted
selfHosted
bool
&
skippedAsync
)
{
if
(
!
obj
)
return
nullptr
;
RootedObject
savedFrameObj
(
cx
CheckedUnwrap
(
obj
)
)
;
if
(
!
savedFrameObj
)
return
nullptr
;
MOZ_RELEASE_ASSERT
(
js
:
:
SavedFrame
:
:
isSavedFrameAndNotProto
(
*
savedFrameObj
)
)
;
js
:
:
RootedSavedFrame
frame
(
cx
&
savedFrameObj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
return
GetFirstSubsumedFrame
(
cx
frame
selfHosted
skippedAsync
)
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameSource
(
JSContext
*
cx
HandleObject
savedFrame
MutableHandleString
sourcep
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
{
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
sourcep
.
set
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
return
SavedFrameResult
:
:
AccessDenied
;
}
sourcep
.
set
(
frame
-
>
getSource
(
)
)
;
}
if
(
sourcep
-
>
isAtom
(
)
)
cx
-
>
markAtom
(
&
sourcep
-
>
asAtom
(
)
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameLine
(
JSContext
*
cx
HandleObject
savedFrame
uint32_t
*
linep
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
linep
)
;
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
*
linep
=
0
;
return
SavedFrameResult
:
:
AccessDenied
;
}
*
linep
=
frame
-
>
getLine
(
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameColumn
(
JSContext
*
cx
HandleObject
savedFrame
uint32_t
*
columnp
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
columnp
)
;
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
*
columnp
=
0
;
return
SavedFrameResult
:
:
AccessDenied
;
}
*
columnp
=
frame
-
>
getColumn
(
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameFunctionDisplayName
(
JSContext
*
cx
HandleObject
savedFrame
MutableHandleString
namep
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
{
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
namep
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
AccessDenied
;
}
namep
.
set
(
frame
-
>
getFunctionDisplayName
(
)
)
;
}
if
(
namep
&
&
namep
-
>
isAtom
(
)
)
cx
-
>
markAtom
(
&
namep
-
>
asAtom
(
)
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameAsyncCause
(
JSContext
*
cx
HandleObject
savedFrame
MutableHandleString
asyncCausep
SavedFrameSelfHosted
unused_
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
{
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
SavedFrameSelfHosted
:
:
Include
skippedAsync
)
)
;
if
(
!
frame
)
{
asyncCausep
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
AccessDenied
;
}
asyncCausep
.
set
(
frame
-
>
getAsyncCause
(
)
)
;
if
(
!
asyncCausep
&
&
skippedAsync
)
asyncCausep
.
set
(
cx
-
>
names
(
)
.
Async
)
;
}
if
(
asyncCausep
&
&
asyncCausep
-
>
isAtom
(
)
)
cx
-
>
markAtom
(
&
asyncCausep
-
>
asAtom
(
)
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameAsyncParent
(
JSContext
*
cx
HandleObject
savedFrame
MutableHandleObject
asyncParentp
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
asyncParentp
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
AccessDenied
;
}
js
:
:
RootedSavedFrame
parent
(
cx
frame
-
>
getParent
(
)
)
;
js
:
:
RootedSavedFrame
subsumedParent
(
cx
GetFirstSubsumedFrame
(
cx
parent
selfHosted
skippedAsync
)
)
;
if
(
subsumedParent
&
&
(
subsumedParent
-
>
getAsyncCause
(
)
|
|
skippedAsync
)
)
asyncParentp
.
set
(
parent
)
;
else
asyncParentp
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
Ok
;
}
JS_PUBLIC_API
(
SavedFrameResult
)
GetSavedFrameParent
(
JSContext
*
cx
HandleObject
savedFrame
MutableHandleObject
parentp
SavedFrameSelfHosted
selfHosted
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
AutoMaybeEnterFrameCompartment
ac
(
cx
savedFrame
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
savedFrame
selfHosted
skippedAsync
)
)
;
if
(
!
frame
)
{
parentp
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
AccessDenied
;
}
js
:
:
RootedSavedFrame
parent
(
cx
frame
-
>
getParent
(
)
)
;
js
:
:
RootedSavedFrame
subsumedParent
(
cx
GetFirstSubsumedFrame
(
cx
parent
selfHosted
skippedAsync
)
)
;
if
(
subsumedParent
&
&
!
(
subsumedParent
-
>
getAsyncCause
(
)
|
|
skippedAsync
)
)
parentp
.
set
(
parent
)
;
else
parentp
.
set
(
nullptr
)
;
return
SavedFrameResult
:
:
Ok
;
}
static
bool
FormatSpiderMonkeyStackFrame
(
JSContext
*
cx
js
:
:
StringBuffer
&
sb
js
:
:
HandleSavedFrame
frame
size_t
indent
bool
skippedAsync
)
{
RootedString
asyncCause
(
cx
frame
-
>
getAsyncCause
(
)
)
;
if
(
!
asyncCause
&
&
skippedAsync
)
asyncCause
.
set
(
cx
-
>
names
(
)
.
Async
)
;
js
:
:
RootedAtom
name
(
cx
frame
-
>
getFunctionDisplayName
(
)
)
;
return
(
!
indent
|
|
sb
.
appendN
(
'
'
indent
)
)
&
&
(
!
asyncCause
|
|
(
sb
.
append
(
asyncCause
)
&
&
sb
.
append
(
'
*
'
)
)
)
&
&
(
!
name
|
|
sb
.
append
(
name
)
)
&
&
sb
.
append
(
'
'
)
&
&
sb
.
append
(
frame
-
>
getSource
(
)
)
&
&
sb
.
append
(
'
:
'
)
&
&
NumberValueToStringBuffer
(
cx
NumberValue
(
frame
-
>
getLine
(
)
)
sb
)
&
&
sb
.
append
(
'
:
'
)
&
&
NumberValueToStringBuffer
(
cx
NumberValue
(
frame
-
>
getColumn
(
)
)
sb
)
&
&
sb
.
append
(
'
\
n
'
)
;
}
static
bool
FormatV8StackFrame
(
JSContext
*
cx
js
:
:
StringBuffer
&
sb
js
:
:
HandleSavedFrame
frame
size_t
indent
bool
lastFrame
)
{
js
:
:
RootedAtom
name
(
cx
frame
-
>
getFunctionDisplayName
(
)
)
;
return
sb
.
appendN
(
'
'
indent
+
4
)
&
&
sb
.
append
(
'
a
'
)
&
&
sb
.
append
(
'
t
'
)
&
&
sb
.
append
(
'
'
)
&
&
(
!
name
|
|
(
sb
.
append
(
name
)
&
&
sb
.
append
(
'
'
)
&
&
sb
.
append
(
'
(
'
)
)
)
&
&
sb
.
append
(
frame
-
>
getSource
(
)
)
&
&
sb
.
append
(
'
:
'
)
&
&
NumberValueToStringBuffer
(
cx
NumberValue
(
frame
-
>
getLine
(
)
)
sb
)
&
&
sb
.
append
(
'
:
'
)
&
&
NumberValueToStringBuffer
(
cx
NumberValue
(
frame
-
>
getColumn
(
)
)
sb
)
&
&
(
!
name
|
|
sb
.
append
(
'
)
'
)
)
&
&
(
lastFrame
|
|
sb
.
append
(
'
\
n
'
)
)
;
}
JS_PUBLIC_API
(
bool
)
BuildStackString
(
JSContext
*
cx
HandleObject
stack
MutableHandleString
stringp
size_t
indent
js
:
:
StackFormat
format
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_REQUEST
(
cx
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
js
:
:
StringBuffer
sb
(
cx
)
;
if
(
format
=
=
js
:
:
StackFormat
:
:
Default
)
format
=
cx
-
>
runtime
(
)
-
>
stackFormat
(
)
;
MOZ_ASSERT
(
format
!
=
js
:
:
StackFormat
:
:
Default
)
;
{
AutoMaybeEnterFrameCompartment
ac
(
cx
stack
)
;
bool
skippedAsync
;
js
:
:
RootedSavedFrame
frame
(
cx
UnwrapSavedFrame
(
cx
stack
SavedFrameSelfHosted
:
:
Exclude
skippedAsync
)
)
;
if
(
!
frame
)
{
stringp
.
set
(
cx
-
>
runtime
(
)
-
>
emptyString
)
;
return
true
;
}
js
:
:
RootedSavedFrame
parent
(
cx
)
;
do
{
MOZ_ASSERT
(
SavedFrameSubsumedByCaller
(
cx
frame
)
)
;
MOZ_ASSERT
(
!
frame
-
>
isSelfHosted
(
cx
)
)
;
parent
=
frame
-
>
getParent
(
)
;
bool
skippedNextAsync
;
js
:
:
RootedSavedFrame
nextFrame
(
cx
js
:
:
GetFirstSubsumedFrame
(
cx
parent
SavedFrameSelfHosted
:
:
Exclude
skippedNextAsync
)
)
;
switch
(
format
)
{
case
js
:
:
StackFormat
:
:
SpiderMonkey
:
if
(
!
FormatSpiderMonkeyStackFrame
(
cx
sb
frame
indent
skippedAsync
)
)
return
false
;
break
;
case
js
:
:
StackFormat
:
:
V8
:
if
(
!
FormatV8StackFrame
(
cx
sb
frame
indent
!
nextFrame
)
)
return
false
;
break
;
case
js
:
:
StackFormat
:
:
Default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
value
"
)
;
break
;
}
frame
=
nextFrame
;
skippedAsync
=
skippedNextAsync
;
}
while
(
frame
)
;
}
JSString
*
str
=
sb
.
finishString
(
)
;
if
(
!
str
)
return
false
;
assertSameCompartment
(
cx
str
)
;
stringp
.
set
(
str
)
;
return
true
;
}
JS_PUBLIC_API
(
bool
)
IsSavedFrame
(
JSObject
*
obj
)
{
if
(
!
obj
)
return
false
;
JSObject
*
unwrapped
=
js
:
:
CheckedUnwrap
(
obj
)
;
if
(
!
unwrapped
)
return
false
;
return
js
:
:
SavedFrame
:
:
isSavedFrameAndNotProto
(
*
unwrapped
)
;
}
}
namespace
js
{
bool
SavedFrame
:
:
sourceProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
source
)
"
args
frame
)
;
RootedString
source
(
cx
)
;
if
(
JS
:
:
GetSavedFrameSource
(
cx
frame
&
source
)
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
source
)
)
return
false
;
args
.
rval
(
)
.
setString
(
source
)
;
}
else
{
args
.
rval
(
)
.
setNull
(
)
;
}
return
true
;
}
bool
SavedFrame
:
:
lineProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
line
)
"
args
frame
)
;
uint32_t
line
;
if
(
JS
:
:
GetSavedFrameLine
(
cx
frame
&
line
)
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
args
.
rval
(
)
.
setNumber
(
line
)
;
else
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
bool
SavedFrame
:
:
columnProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
column
)
"
args
frame
)
;
uint32_t
column
;
if
(
JS
:
:
GetSavedFrameColumn
(
cx
frame
&
column
)
=
=
JS
:
:
SavedFrameResult
:
:
Ok
)
args
.
rval
(
)
.
setNumber
(
column
)
;
else
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
bool
SavedFrame
:
:
functionDisplayNameProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
functionDisplayName
)
"
args
frame
)
;
RootedString
name
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameFunctionDisplayName
(
cx
frame
&
name
)
;
if
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
&
&
name
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
name
)
)
return
false
;
args
.
rval
(
)
.
setString
(
name
)
;
}
else
{
args
.
rval
(
)
.
setNull
(
)
;
}
return
true
;
}
bool
SavedFrame
:
:
asyncCauseProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
asyncCause
)
"
args
frame
)
;
RootedString
asyncCause
(
cx
)
;
JS
:
:
SavedFrameResult
result
=
JS
:
:
GetSavedFrameAsyncCause
(
cx
frame
&
asyncCause
)
;
if
(
result
=
=
JS
:
:
SavedFrameResult
:
:
Ok
&
&
asyncCause
)
{
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
asyncCause
)
)
return
false
;
args
.
rval
(
)
.
setString
(
asyncCause
)
;
}
else
{
args
.
rval
(
)
.
setNull
(
)
;
}
return
true
;
}
bool
SavedFrame
:
:
asyncParentProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
asyncParent
)
"
args
frame
)
;
RootedObject
asyncParent
(
cx
)
;
(
void
)
JS
:
:
GetSavedFrameAsyncParent
(
cx
frame
&
asyncParent
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
asyncParent
)
)
return
false
;
args
.
rval
(
)
.
setObjectOrNull
(
asyncParent
)
;
return
true
;
}
bool
SavedFrame
:
:
parentProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
(
get
parent
)
"
args
frame
)
;
RootedObject
parent
(
cx
)
;
(
void
)
JS
:
:
GetSavedFrameParent
(
cx
frame
&
parent
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
parent
)
)
return
false
;
args
.
rval
(
)
.
setObjectOrNull
(
parent
)
;
return
true
;
}
bool
SavedFrame
:
:
toStringMethod
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
THIS_SAVEDFRAME
(
cx
argc
vp
"
toString
"
args
frame
)
;
RootedString
string
(
cx
)
;
if
(
!
JS
:
:
BuildStackString
(
cx
frame
&
string
)
)
return
false
;
args
.
rval
(
)
.
setString
(
string
)
;
return
true
;
}
bool
SavedStacks
:
:
init
(
)
{
return
frames
.
init
(
)
&
&
pcLocationMap
.
init
(
)
;
}
bool
SavedStacks
:
:
saveCurrentStack
(
JSContext
*
cx
MutableHandleSavedFrame
frame
JS
:
:
StackCapture
&
&
capture
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
assertSameCompartment
(
cx
this
)
;
if
(
creatingSavedFrame
|
|
cx
-
>
isExceptionPending
(
)
|
|
!
cx
-
>
global
(
)
|
|
!
cx
-
>
global
(
)
-
>
isStandardClassResolved
(
JSProto_Object
)
)
{
frame
.
set
(
nullptr
)
;
return
true
;
}
AutoGeckoProfilerEntry
pseudoFrame
(
cx
"
js
:
:
SavedStacks
:
:
saveCurrentStack
"
)
;
FrameIter
iter
(
cx
)
;
return
insertFrames
(
cx
iter
frame
mozilla
:
:
Move
(
capture
)
)
;
}
bool
SavedStacks
:
:
copyAsyncStack
(
JSContext
*
cx
HandleObject
asyncStack
HandleString
asyncCause
MutableHandleSavedFrame
adoptedStack
uint32_t
maxFrameCount
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
compartment
(
)
)
;
assertSameCompartment
(
cx
this
)
;
RootedObject
asyncStackObj
(
cx
CheckedUnwrap
(
asyncStack
)
)
;
MOZ_RELEASE_ASSERT
(
asyncStackObj
)
;
MOZ_RELEASE_ASSERT
(
js
:
:
SavedFrame
:
:
isSavedFrameAndNotProto
(
*
asyncStackObj
)
)
;
RootedSavedFrame
frame
(
cx
&
asyncStackObj
-
>
as
<
js
:
:
SavedFrame
>
(
)
)
;
return
adoptAsyncStack
(
cx
frame
asyncCause
adoptedStack
maxFrameCount
)
;
}
void
SavedStacks
:
:
sweep
(
)
{
frames
.
sweep
(
)
;
pcLocationMap
.
sweep
(
)
;
}
void
SavedStacks
:
:
trace
(
JSTracer
*
trc
)
{
pcLocationMap
.
trace
(
trc
)
;
}
uint32_t
SavedStacks
:
:
count
(
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
frames
.
count
(
)
;
}
void
SavedStacks
:
:
clear
(
)
{
frames
.
clear
(
)
;
}
size_t
SavedStacks
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
frames
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
pcLocationMap
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
static
inline
bool
captureIsSatisfied
(
JSContext
*
cx
JSPrincipals
*
principals
const
JSAtom
*
source
JS
:
:
StackCapture
&
capture
)
{
class
Matcher
{
JSContext
*
cx_
;
JSPrincipals
*
framePrincipals_
;
const
JSAtom
*
frameSource_
;
public
:
Matcher
(
JSContext
*
cx
JSPrincipals
*
principals
const
JSAtom
*
source
)
:
cx_
(
cx
)
framePrincipals_
(
principals
)
frameSource_
(
source
)
{
}
bool
match
(
JS
:
:
FirstSubsumedFrame
&
target
)
{
auto
subsumes
=
cx_
-
>
runtime
(
)
-
>
securityCallbacks
-
>
subsumes
;
return
(
!
subsumes
|
|
subsumes
(
target
.
principals
framePrincipals_
)
)
&
&
(
!
target
.
ignoreSelfHosted
|
|
frameSource_
!
=
cx_
-
>
names
(
)
.
selfHosted
)
;
}
bool
match
(
JS
:
:
MaxFrames
&
target
)
{
return
target
.
maxFrames
=
=
1
;
}
bool
match
(
JS
:
:
AllFrames
&
)
{
return
false
;
}
}
;
Matcher
m
(
cx
principals
source
)
;
return
capture
.
match
(
m
)
;
}
bool
SavedStacks
:
:
insertFrames
(
JSContext
*
cx
FrameIter
&
iter
MutableHandleSavedFrame
frame
JS
:
:
StackCapture
&
&
capture
)
{
Activation
*
asyncActivation
=
nullptr
;
RootedSavedFrame
asyncStack
(
cx
nullptr
)
;
RootedString
asyncCause
(
cx
nullptr
)
;
bool
parentIsInCache
=
false
;
RootedSavedFrame
cachedFrame
(
cx
nullptr
)
;
SavedFrame
:
:
AutoLookupVector
stackChain
(
cx
)
;
while
(
!
iter
.
done
(
)
)
{
Activation
&
activation
=
*
iter
.
activation
(
)
;
if
(
asyncActivation
&
&
asyncActivation
!
=
&
activation
)
{
if
(
asyncActivation
-
>
asyncCallIsExplicit
(
)
)
break
;
asyncActivation
=
nullptr
;
}
if
(
!
asyncActivation
)
{
asyncStack
=
activation
.
asyncStack
(
)
;
if
(
asyncStack
)
{
AutoCompartmentUnchecked
ac
(
cx
iter
.
compartment
(
)
)
;
const
char
*
cause
=
activation
.
asyncCause
(
)
;
UTF8Chars
utf8Chars
(
cause
strlen
(
cause
)
)
;
size_t
twoByteCharsLen
=
0
;
char16_t
*
twoByteChars
=
UTF8CharsToNewTwoByteCharsZ
(
cx
utf8Chars
&
twoByteCharsLen
)
.
get
(
)
;
if
(
!
twoByteChars
)
return
false
;
asyncCause
=
JS_AtomizeUCStringN
(
cx
twoByteChars
twoByteCharsLen
)
;
js_free
(
twoByteChars
)
;
if
(
!
asyncCause
)
return
false
;
asyncActivation
=
&
activation
;
}
}
Rooted
<
LocationValue
>
location
(
cx
)
;
{
AutoCompartmentUnchecked
ac
(
cx
iter
.
compartment
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
savedStacks
(
)
.
getLocation
(
cx
iter
&
location
)
)
return
false
;
}
if
(
capture
.
is
<
JS
:
:
AllFrames
>
(
)
)
parentIsInCache
=
iter
.
hasCachedSavedFrame
(
)
;
auto
principals
=
iter
.
compartment
(
)
-
>
principals
(
)
;
auto
displayAtom
=
(
iter
.
isWasm
(
)
|
|
iter
.
isFunctionFrame
(
)
)
?
iter
.
functionDisplayAtom
(
)
:
nullptr
;
Maybe
<
LiveSavedFrameCache
:
:
FramePtr
>
framePtr
=
LiveSavedFrameCache
:
:
getFramePtr
(
iter
)
;
MOZ_ASSERT_IF
(
framePtr
&
&
!
iter
.
isWasm
(
)
iter
.
pc
(
)
)
;
if
(
!
stackChain
-
>
emplaceBack
(
location
.
source
(
)
location
.
line
(
)
location
.
column
(
)
displayAtom
nullptr
nullptr
principals
framePtr
iter
.
pc
(
)
&
activation
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
captureIsSatisfied
(
cx
principals
location
.
source
(
)
capture
)
)
{
asyncStack
.
set
(
nullptr
)
;
break
;
}
+
+
iter
;
if
(
parentIsInCache
&
&
!
iter
.
done
(
)
&
&
iter
.
hasCachedSavedFrame
(
)
)
{
auto
*
cache
=
activation
.
getLiveSavedFrameCache
(
cx
)
;
if
(
!
cache
)
return
false
;
cache
-
>
find
(
cx
iter
&
cachedFrame
)
;
if
(
cachedFrame
)
break
;
}
if
(
capture
.
is
<
JS
:
:
MaxFrames
>
(
)
)
capture
.
as
<
JS
:
:
MaxFrames
>
(
)
.
maxFrames
-
-
;
}
RootedSavedFrame
parentFrame
(
cx
cachedFrame
)
;
if
(
asyncStack
&
&
!
capture
.
is
<
JS
:
:
FirstSubsumedFrame
>
(
)
)
{
uint32_t
maxAsyncFrames
=
capture
.
is
<
JS
:
:
MaxFrames
>
(
)
?
capture
.
as
<
JS
:
:
MaxFrames
>
(
)
.
maxFrames
:
ASYNC_STACK_MAX_FRAME_COUNT
;
if
(
!
adoptAsyncStack
(
cx
asyncStack
asyncCause
&
parentFrame
maxAsyncFrames
)
)
return
false
;
}
for
(
size_t
i
=
stackChain
-
>
length
(
)
;
i
!
=
0
;
i
-
-
)
{
SavedFrame
:
:
HandleLookup
lookup
=
stackChain
[
i
-
1
]
;
lookup
-
>
parent
=
parentFrame
;
parentFrame
.
set
(
getOrCreateSavedFrame
(
cx
lookup
)
)
;
if
(
!
parentFrame
)
return
false
;
if
(
capture
.
is
<
JS
:
:
AllFrames
>
(
)
&
&
lookup
-
>
framePtr
&
&
parentFrame
!
=
cachedFrame
)
{
auto
*
cache
=
lookup
-
>
activation
-
>
getLiveSavedFrameCache
(
cx
)
;
if
(
!
cache
|
|
!
cache
-
>
insert
(
cx
*
lookup
-
>
framePtr
lookup
-
>
pc
parentFrame
)
)
return
false
;
}
}
frame
.
set
(
parentFrame
)
;
return
true
;
}
bool
SavedStacks
:
:
adoptAsyncStack
(
JSContext
*
cx
HandleSavedFrame
asyncStack
HandleString
asyncCause
MutableHandleSavedFrame
adoptedStack
uint32_t
maxFrameCount
)
{
RootedAtom
asyncCauseAtom
(
cx
AtomizeString
(
cx
asyncCause
)
)
;
if
(
!
asyncCauseAtom
)
return
false
;
uint32_t
maxFrames
=
maxFrameCount
>
0
?
maxFrameCount
:
ASYNC_STACK_MAX_FRAME_COUNT
;
SavedFrame
:
:
AutoLookupVector
stackChain
(
cx
)
;
SavedFrame
*
currentSavedFrame
=
asyncStack
;
SavedFrame
*
firstSavedFrameParent
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
maxFrames
&
&
currentSavedFrame
;
i
+
+
)
{
if
(
!
stackChain
-
>
emplaceBack
(
*
currentSavedFrame
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
currentSavedFrame
=
currentSavedFrame
-
>
getParent
(
)
;
if
(
i
=
=
0
)
{
stackChain
-
>
back
(
)
.
asyncCause
=
asyncCauseAtom
;
firstSavedFrameParent
=
currentSavedFrame
;
}
}
size_t
oldestFramePosition
=
stackChain
-
>
length
(
)
;
RootedSavedFrame
parentFrame
(
cx
nullptr
)
;
if
(
currentSavedFrame
=
=
nullptr
&
&
asyncStack
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
{
oldestFramePosition
=
1
;
parentFrame
=
firstSavedFrameParent
;
}
else
if
(
maxFrameCount
=
=
0
&
&
oldestFramePosition
=
=
ASYNC_STACK_MAX_FRAME_COUNT
)
{
oldestFramePosition
=
ASYNC_STACK_MAX_FRAME_COUNT
/
2
;
}
for
(
size_t
i
=
oldestFramePosition
;
i
!
=
0
;
i
-
-
)
{
SavedFrame
:
:
HandleLookup
lookup
=
stackChain
[
i
-
1
]
;
lookup
-
>
parent
=
parentFrame
;
parentFrame
.
set
(
getOrCreateSavedFrame
(
cx
lookup
)
)
;
if
(
!
parentFrame
)
return
false
;
}
adoptedStack
.
set
(
parentFrame
)
;
return
true
;
}
SavedFrame
*
SavedStacks
:
:
getOrCreateSavedFrame
(
JSContext
*
cx
SavedFrame
:
:
HandleLookup
lookup
)
{
const
SavedFrame
:
:
Lookup
&
lookupInstance
=
lookup
.
get
(
)
;
DependentAddPtr
<
SavedFrame
:
:
Set
>
p
(
cx
frames
lookupInstance
)
;
if
(
p
)
{
MOZ_ASSERT
(
*
p
)
;
return
*
p
;
}
RootedSavedFrame
frame
(
cx
createFrameFromLookup
(
cx
lookup
)
)
;
if
(
!
frame
)
return
nullptr
;
if
(
!
p
.
add
(
cx
frames
lookupInstance
frame
)
)
return
nullptr
;
return
frame
;
}
SavedFrame
*
SavedStacks
:
:
createFrameFromLookup
(
JSContext
*
cx
SavedFrame
:
:
HandleLookup
lookup
)
{
RootedSavedFrame
frame
(
cx
SavedFrame
:
:
create
(
cx
)
)
;
if
(
!
frame
)
return
nullptr
;
frame
-
>
initFromLookup
(
cx
lookup
)
;
if
(
!
FreezeObject
(
cx
frame
)
)
return
nullptr
;
return
frame
;
}
bool
SavedStacks
:
:
getLocation
(
JSContext
*
cx
const
FrameIter
&
iter
MutableHandle
<
LocationValue
>
locationp
)
{
assertSameCompartment
(
cx
this
iter
.
compartment
(
)
)
;
if
(
!
iter
.
hasScript
(
)
)
{
if
(
const
char16_t
*
displayURL
=
iter
.
displayURL
(
)
)
{
locationp
.
setSource
(
AtomizeChars
(
cx
displayURL
js_strlen
(
displayURL
)
)
)
;
}
else
{
const
char
*
filename
=
iter
.
filename
(
)
?
iter
.
filename
(
)
:
"
"
;
locationp
.
setSource
(
Atomize
(
cx
filename
strlen
(
filename
)
)
)
;
}
if
(
!
locationp
.
source
(
)
)
return
false
;
uint32_t
column
=
0
;
locationp
.
setLine
(
iter
.
computeLine
(
&
column
)
)
;
locationp
.
setColumn
(
column
+
1
)
;
return
true
;
}
RootedScript
script
(
cx
iter
.
script
(
)
)
;
jsbytecode
*
pc
=
iter
.
pc
(
)
;
PCKey
key
(
script
pc
)
;
PCLocationMap
:
:
AddPtr
p
=
pcLocationMap
.
lookupForAdd
(
key
)
;
if
(
!
p
)
{
RootedAtom
source
(
cx
)
;
if
(
const
char16_t
*
displayURL
=
iter
.
displayURL
(
)
)
{
source
=
AtomizeChars
(
cx
displayURL
js_strlen
(
displayURL
)
)
;
}
else
{
const
char
*
filename
=
script
-
>
filename
(
)
?
script
-
>
filename
(
)
:
"
"
;
source
=
Atomize
(
cx
filename
strlen
(
filename
)
)
;
}
if
(
!
source
)
return
false
;
uint32_t
column
;
uint32_t
line
=
PCToLineNumber
(
script
pc
&
column
)
;
LocationValue
value
(
source
line
column
+
1
)
;
if
(
!
pcLocationMap
.
add
(
p
key
value
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
locationp
.
set
(
p
-
>
value
(
)
)
;
return
true
;
}
void
SavedStacks
:
:
chooseSamplingProbability
(
JSCompartment
*
compartment
)
{
GlobalObject
*
global
=
compartment
-
>
maybeGlobal
(
)
;
if
(
!
global
)
return
;
GlobalObject
:
:
DebuggerVector
*
dbgs
=
global
-
>
getDebuggers
(
)
;
if
(
!
dbgs
|
|
dbgs
-
>
empty
(
)
)
return
;
mozilla
:
:
DebugOnly
<
ReadBarriered
<
Debugger
*
>
*
>
begin
=
dbgs
-
>
begin
(
)
;
mozilla
:
:
DebugOnly
<
bool
>
foundAnyDebuggers
=
false
;
double
probability
=
0
;
for
(
auto
dbgp
=
dbgs
-
>
begin
(
)
;
dbgp
<
dbgs
-
>
end
(
)
;
dbgp
+
+
)
{
MOZ_ASSERT
(
dbgs
-
>
begin
(
)
=
=
begin
)
;
if
(
(
*
dbgp
)
-
>
trackingAllocationSites
&
&
(
*
dbgp
)
-
>
enabled
)
{
foundAnyDebuggers
=
true
;
probability
=
std
:
:
max
(
(
*
dbgp
)
-
>
allocationSamplingProbability
probability
)
;
}
}
MOZ_ASSERT
(
foundAnyDebuggers
)
;
if
(
!
bernoulliSeeded
)
{
mozilla
:
:
Array
<
uint64_t
2
>
seed
;
GenerateXorShift128PlusSeed
(
seed
)
;
bernoulli
.
setRandomState
(
seed
[
0
]
seed
[
1
]
)
;
bernoulliSeeded
=
true
;
}
bernoulli
.
setProbability
(
probability
)
;
}
JSObject
*
SavedStacks
:
:
MetadataBuilder
:
:
build
(
JSContext
*
cx
HandleObject
target
AutoEnterOOMUnsafeRegion
&
oomUnsafe
)
const
{
RootedObject
obj
(
cx
target
)
;
SavedStacks
&
stacks
=
cx
-
>
compartment
(
)
-
>
savedStacks
(
)
;
if
(
!
stacks
.
bernoulli
.
trial
(
)
)
return
nullptr
;
RootedSavedFrame
frame
(
cx
)
;
if
(
!
stacks
.
saveCurrentStack
(
cx
&
frame
)
)
oomUnsafe
.
crash
(
"
SavedStacksMetadataBuilder
"
)
;
if
(
!
Debugger
:
:
onLogAllocationSite
(
cx
obj
frame
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
)
oomUnsafe
.
crash
(
"
SavedStacksMetadataBuilder
"
)
;
MOZ_ASSERT_IF
(
frame
!
frame
-
>
is
<
WrapperObject
>
(
)
)
;
return
frame
;
}
const
SavedStacks
:
:
MetadataBuilder
SavedStacks
:
:
metadataBuilder
;
#
ifdef
JS_CRASH_DIAGNOSTICS
void
CompartmentChecker
:
:
check
(
SavedStacks
*
stacks
)
{
if
(
&
compartment
-
>
savedStacks
(
)
!
=
stacks
)
{
printf
(
"
*
*
*
Compartment
SavedStacks
mismatch
:
%
p
vs
.
%
p
\
n
"
(
void
*
)
&
compartment
-
>
savedStacks
(
)
stacks
)
;
MOZ_CRASH
(
)
;
}
}
#
endif
ReconstructedSavedFramePrincipals
ReconstructedSavedFramePrincipals
:
:
IsSystem
;
ReconstructedSavedFramePrincipals
ReconstructedSavedFramePrincipals
:
:
IsNotSystem
;
UTF8CharsZ
BuildUTF8StackString
(
JSContext
*
cx
HandleObject
stack
)
{
RootedString
stackStr
(
cx
)
;
if
(
!
JS
:
:
BuildStackString
(
cx
stack
&
stackStr
)
)
return
UTF8CharsZ
(
)
;
char
*
chars
=
JS_EncodeStringToUTF8
(
cx
stackStr
)
;
return
UTF8CharsZ
(
chars
strlen
(
chars
)
)
;
}
}
namespace
JS
{
namespace
ubi
{
bool
ConcreteStackFrame
<
SavedFrame
>
:
:
isSystem
(
)
const
{
auto
trustedPrincipals
=
get
(
)
.
runtimeFromAnyThread
(
)
-
>
trustedPrincipals
(
)
;
return
get
(
)
.
getPrincipals
(
)
=
=
trustedPrincipals
|
|
get
(
)
.
getPrincipals
(
)
=
=
&
js
:
:
ReconstructedSavedFramePrincipals
:
:
IsSystem
;
}
bool
ConcreteStackFrame
<
SavedFrame
>
:
:
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
outSavedFrameStack
)
const
{
outSavedFrameStack
.
set
(
&
get
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
outSavedFrameStack
)
)
{
outSavedFrameStack
.
set
(
nullptr
)
;
return
false
;
}
return
true
;
}
struct
MOZ_STACK_CLASS
AtomizingMatcher
{
JSContext
*
cx
;
size_t
length
;
explicit
AtomizingMatcher
(
JSContext
*
cx
size_t
length
)
:
cx
(
cx
)
length
(
length
)
{
}
JSAtom
*
match
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
atom
)
;
return
atom
;
}
JSAtom
*
match
(
const
char16_t
*
chars
)
{
MOZ_ASSERT
(
chars
)
;
return
AtomizeChars
(
cx
chars
length
)
;
}
}
;
JS_PUBLIC_API
(
bool
)
ConstructSavedFrameStackSlow
(
JSContext
*
cx
JS
:
:
ubi
:
:
StackFrame
&
frame
MutableHandleObject
outSavedFrameStack
)
{
SavedFrame
:
:
AutoLookupVector
stackChain
(
cx
)
;
Rooted
<
JS
:
:
ubi
:
:
StackFrame
>
ubiFrame
(
cx
frame
)
;
while
(
ubiFrame
.
get
(
)
)
{
js
:
:
RootedAtom
source
(
cx
)
;
AtomizingMatcher
atomizer
(
cx
ubiFrame
.
get
(
)
.
sourceLength
(
)
)
;
source
=
ubiFrame
.
get
(
)
.
source
(
)
.
match
(
atomizer
)
;
if
(
!
source
)
return
false
;
js
:
:
RootedAtom
functionDisplayName
(
cx
)
;
auto
nameLength
=
ubiFrame
.
get
(
)
.
functionDisplayNameLength
(
)
;
if
(
nameLength
>
0
)
{
AtomizingMatcher
atomizer
(
cx
nameLength
)
;
functionDisplayName
=
ubiFrame
.
get
(
)
.
functionDisplayName
(
)
.
match
(
atomizer
)
;
if
(
!
functionDisplayName
)
return
false
;
}
auto
principals
=
js
:
:
ReconstructedSavedFramePrincipals
:
:
getSingleton
(
ubiFrame
.
get
(
)
)
;
if
(
!
stackChain
-
>
emplaceBack
(
source
ubiFrame
.
get
(
)
.
line
(
)
ubiFrame
.
get
(
)
.
column
(
)
functionDisplayName
nullptr
nullptr
principals
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
ubiFrame
=
ubiFrame
.
get
(
)
.
parent
(
)
;
}
js
:
:
RootedSavedFrame
parentFrame
(
cx
)
;
for
(
size_t
i
=
stackChain
-
>
length
(
)
;
i
!
=
0
;
i
-
-
)
{
SavedFrame
:
:
HandleLookup
lookup
=
stackChain
[
i
-
1
]
;
lookup
-
>
parent
=
parentFrame
;
parentFrame
=
cx
-
>
compartment
(
)
-
>
savedStacks
(
)
.
getOrCreateSavedFrame
(
cx
lookup
)
;
if
(
!
parentFrame
)
return
false
;
}
outSavedFrameStack
.
set
(
parentFrame
)
;
return
true
;
}
}
}
