#
include
"
vm
/
BigIntType
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
<
gmp
.
h
>
#
include
<
math
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
BigInt
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Range
;
using
mozilla
:
:
RangedPtr
;
static
void
*
js_mp_realloc
(
void
*
ptr
size_t
old_size
size_t
new_size
)
{
return
js_realloc
(
ptr
new_size
)
;
}
static
void
js_mp_free
(
void
*
ptr
size_t
size
)
{
return
js_free
(
ptr
)
;
}
static
bool
memoryFunctionsInitialized
=
false
;
JS_PUBLIC_API
(
void
)
JS
:
:
SetGMPMemoryFunctions
(
JS
:
:
GMPAllocFn
allocFn
JS
:
:
GMPReallocFn
reallocFn
JS
:
:
GMPFreeFn
freeFn
)
{
MOZ_ASSERT
(
JS
:
:
detail
:
:
libraryInitState
=
=
JS
:
:
detail
:
:
InitState
:
:
Uninitialized
)
;
memoryFunctionsInitialized
=
true
;
mp_set_memory_functions
(
allocFn
reallocFn
freeFn
)
;
}
void
BigInt
:
:
init
(
)
{
if
(
!
memoryFunctionsInitialized
)
{
memoryFunctionsInitialized
=
true
;
mp_set_memory_functions
(
js_malloc
js_mp_realloc
js_mp_free
)
;
}
}
BigInt
*
BigInt
:
:
create
(
JSContext
*
cx
)
{
BigInt
*
x
=
Allocate
<
BigInt
>
(
cx
)
;
if
(
!
x
)
{
return
nullptr
;
}
mpz_init
(
x
-
>
num_
)
;
return
x
;
}
BigInt
*
BigInt
:
:
createFromDouble
(
JSContext
*
cx
double
d
)
{
BigInt
*
x
=
Allocate
<
BigInt
>
(
cx
)
;
if
(
!
x
)
{
return
nullptr
;
}
mpz_init_set_d
(
x
-
>
num_
d
)
;
return
x
;
}
BigInt
*
BigInt
:
:
createFromBoolean
(
JSContext
*
cx
bool
b
)
{
BigInt
*
x
=
Allocate
<
BigInt
>
(
cx
)
;
if
(
!
x
)
{
return
nullptr
;
}
mpz_init_set_ui
(
x
-
>
num_
b
)
;
return
x
;
}
BigInt
*
BigInt
:
:
createFromBytes
(
JSContext
*
cx
int
sign
void
*
bytes
size_t
nbytes
)
{
BigInt
*
x
=
Allocate
<
BigInt
>
(
cx
)
;
if
(
!
x
)
{
return
nullptr
;
}
mpz_init
(
x
-
>
num_
)
;
if
(
nbytes
=
=
0
)
{
return
x
;
}
mpz_import
(
x
-
>
num_
nbytes
-
1
1
0
0
bytes
)
;
if
(
sign
<
0
)
{
mpz_neg
(
x
-
>
num_
x
-
>
num_
)
;
}
return
x
;
}
static
bool
IsInteger
(
double
d
)
{
if
(
!
mozilla
:
:
IsFinite
(
d
)
)
{
return
false
;
}
double
i
=
JS
:
:
ToInteger
(
d
)
;
if
(
i
!
=
d
)
{
return
false
;
}
return
true
;
}
BigInt
*
js
:
:
NumberToBigInt
(
JSContext
*
cx
double
d
)
{
if
(
!
IsInteger
(
d
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NUMBER_TO_BIGINT
)
;
return
nullptr
;
}
return
BigInt
:
:
createFromDouble
(
cx
d
)
;
}
BigInt
*
BigInt
:
:
copy
(
JSContext
*
cx
HandleBigInt
x
)
{
BigInt
*
bi
=
Allocate
<
BigInt
>
(
cx
)
;
if
(
!
bi
)
{
return
nullptr
;
}
mpz_init_set
(
bi
-
>
num_
x
-
>
num_
)
;
return
bi
;
}
BigInt
*
BigInt
:
:
add
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_add
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
sub
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_sub
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
mul
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_mul
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
div
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
if
(
mpz_size
(
y
-
>
num_
)
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_DIVISION_BY_ZERO
)
;
return
nullptr
;
}
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_tdiv_q
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
mod
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
if
(
mpz_size
(
y
-
>
num_
)
=
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_DIVISION_BY_ZERO
)
;
return
nullptr
;
}
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_tdiv_r
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
pow
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
if
(
mpz_sgn
(
y
-
>
num_
)
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_NEGATIVE_EXPONENT
)
;
return
nullptr
;
}
if
(
!
mpz_fits_uint_p
(
y
-
>
num_
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_TOO_LARGE
)
;
return
nullptr
;
}
unsigned
long
int
power
=
mpz_get_ui
(
y
-
>
num_
)
;
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_pow_ui
(
z
-
>
num_
x
-
>
num_
power
)
;
return
z
;
}
BigInt
*
BigInt
:
:
neg
(
JSContext
*
cx
HandleBigInt
x
)
{
BigInt
*
res
=
create
(
cx
)
;
if
(
!
res
)
{
return
nullptr
;
}
mpz_neg
(
res
-
>
num_
x
-
>
num_
)
;
return
res
;
}
BigInt
*
BigInt
:
:
lsh
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
if
(
mpz_sgn
(
y
-
>
num_
)
<
0
)
{
mpz_fdiv_q_2exp
(
z
-
>
num_
x
-
>
num_
mpz_get_ui
(
y
-
>
num_
)
)
;
return
z
;
}
mpz_mul_2exp
(
z
-
>
num_
x
-
>
num_
mpz_get_ui
(
y
-
>
num_
)
)
;
return
z
;
}
BigInt
*
BigInt
:
:
rsh
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
if
(
mpz_sgn
(
y
-
>
num_
)
>
=
0
)
{
mpz_fdiv_q_2exp
(
z
-
>
num_
x
-
>
num_
mpz_get_ui
(
y
-
>
num_
)
)
;
return
z
;
}
mpz_mul_2exp
(
z
-
>
num_
x
-
>
num_
mpz_get_ui
(
y
-
>
num_
)
)
;
return
z
;
}
BigInt
*
BigInt
:
:
bitAnd
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_and
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
bitXor
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_xor
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
bitOr
(
JSContext
*
cx
HandleBigInt
x
HandleBigInt
y
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_ior
(
z
-
>
num_
x
-
>
num_
y
-
>
num_
)
;
return
z
;
}
BigInt
*
BigInt
:
:
bitNot
(
JSContext
*
cx
HandleBigInt
x
)
{
BigInt
*
z
=
create
(
cx
)
;
if
(
!
z
)
{
return
nullptr
;
}
mpz_neg
(
z
-
>
num_
x
-
>
num_
)
;
mpz_sub_ui
(
z
-
>
num_
z
-
>
num_
1
)
;
return
z
;
}
static
bool
ValidBigIntOperands
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
)
{
MOZ_ASSERT
(
lhs
.
isBigInt
(
)
|
|
rhs
.
isBigInt
(
)
)
;
if
(
!
lhs
.
isBigInt
(
)
|
|
!
rhs
.
isBigInt
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_TO_NUMBER
)
;
return
false
;
}
return
true
;
}
bool
BigInt
:
:
add
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
add
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
sub
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
sub
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
mul
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
mul
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
div
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
div
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
mod
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
mod
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
pow
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
pow
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
neg
(
JSContext
*
cx
HandleValue
operand
MutableHandleValue
res
)
{
MOZ_ASSERT
(
operand
.
isBigInt
(
)
)
;
RootedBigInt
operandBigInt
(
cx
operand
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
neg
(
cx
operandBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
lsh
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
lsh
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
rsh
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
rsh
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
bitAnd
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
bitAnd
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
bitXor
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
bitXor
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
bitOr
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
if
(
!
ValidBigIntOperands
(
cx
lhs
rhs
)
)
{
return
false
;
}
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
bitOr
(
cx
lhsBigInt
rhsBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
bool
BigInt
:
:
bitNot
(
JSContext
*
cx
HandleValue
operand
MutableHandleValue
res
)
{
MOZ_ASSERT
(
operand
.
isBigInt
(
)
)
;
RootedBigInt
operandBigInt
(
cx
operand
.
toBigInt
(
)
)
;
BigInt
*
resBigInt
=
BigInt
:
:
bitNot
(
cx
operandBigInt
)
;
if
(
!
resBigInt
)
{
return
false
;
}
res
.
setBigInt
(
resBigInt
)
;
return
true
;
}
BigInt
*
js
:
:
ToBigInt
(
JSContext
*
cx
HandleValue
val
)
{
RootedValue
v
(
cx
val
)
;
if
(
!
ToPrimitive
(
cx
JSTYPE_NUMBER
&
v
)
)
{
return
nullptr
;
}
if
(
v
.
isBigInt
(
)
)
{
return
v
.
toBigInt
(
)
;
}
if
(
v
.
isBoolean
(
)
)
{
return
BigInt
:
:
createFromBoolean
(
cx
v
.
toBoolean
(
)
)
;
}
if
(
v
.
isString
(
)
)
{
RootedString
str
(
cx
v
.
toString
(
)
)
;
BigInt
*
bi
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
bi
StringToBigInt
(
cx
str
0
)
)
;
if
(
!
bi
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BIGINT_INVALID_SYNTAX
)
;
return
nullptr
;
}
return
bi
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_BIGINT
)
;
return
nullptr
;
}
double
BigInt
:
:
numberValue
(
BigInt
*
x
)
{
signed
long
int
exp
;
double
d
=
mpz_get_d_2exp
(
&
exp
x
-
>
num_
)
;
return
ldexp
(
d
exp
)
;
}
bool
BigInt
:
:
equal
(
BigInt
*
lhs
BigInt
*
rhs
)
{
if
(
lhs
=
=
rhs
)
{
return
true
;
}
if
(
mpz_cmp
(
lhs
-
>
num_
rhs
-
>
num_
)
=
=
0
)
{
return
true
;
}
return
false
;
}
bool
BigInt
:
:
equal
(
BigInt
*
lhs
double
rhs
)
{
if
(
mozilla
:
:
IsNaN
(
rhs
)
)
{
return
false
;
}
if
(
mpz_cmp_d
(
lhs
-
>
num_
rhs
)
=
=
0
)
{
return
true
;
}
return
false
;
}
JS
:
:
Result
<
bool
>
BigInt
:
:
looselyEqual
(
JSContext
*
cx
HandleBigInt
lhs
HandleValue
rhs
)
{
if
(
rhs
.
isBigInt
(
)
)
{
return
equal
(
lhs
rhs
.
toBigInt
(
)
)
;
}
if
(
rhs
.
isString
(
)
)
{
RootedBigInt
rhsBigInt
(
cx
)
;
RootedString
rhsString
(
cx
rhs
.
toString
(
)
)
;
MOZ_TRY_VAR
(
rhsBigInt
StringToBigInt
(
cx
rhsString
0
)
)
;
if
(
!
rhsBigInt
)
{
return
false
;
}
return
equal
(
lhs
rhsBigInt
)
;
}
if
(
rhs
.
isObject
(
)
)
{
RootedValue
rhsPrimitive
(
cx
rhs
)
;
if
(
!
ToPrimitive
(
cx
&
rhsPrimitive
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
looselyEqual
(
cx
lhs
rhsPrimitive
)
;
}
if
(
rhs
.
isNumber
(
)
)
{
return
equal
(
lhs
rhs
.
toNumber
(
)
)
;
}
return
false
;
}
bool
BigInt
:
:
lessThan
(
BigInt
*
x
BigInt
*
y
)
{
return
mpz_cmp
(
x
-
>
num_
y
-
>
num_
)
<
0
;
}
Maybe
<
bool
>
BigInt
:
:
lessThan
(
BigInt
*
lhs
double
rhs
)
{
if
(
mozilla
:
:
IsNaN
(
rhs
)
)
{
return
Maybe
<
bool
>
(
Nothing
(
)
)
;
}
return
Some
(
mpz_cmp_d
(
lhs
-
>
num_
rhs
)
<
0
)
;
}
Maybe
<
bool
>
BigInt
:
:
lessThan
(
double
lhs
BigInt
*
rhs
)
{
if
(
mozilla
:
:
IsNaN
(
lhs
)
)
{
return
Maybe
<
bool
>
(
Nothing
(
)
)
;
}
return
Some
(
-
mpz_cmp_d
(
rhs
-
>
num_
lhs
)
<
0
)
;
}
JS
:
:
Result
<
Maybe
<
bool
>
>
BigInt
:
:
lessThan
(
JSContext
*
cx
HandleBigInt
lhs
HandleString
rhs
)
{
RootedBigInt
rhsBigInt
(
cx
)
;
MOZ_TRY_VAR
(
rhsBigInt
StringToBigInt
(
cx
rhs
0
)
)
;
if
(
!
rhsBigInt
)
{
return
Maybe
<
bool
>
(
Nothing
(
)
)
;
}
return
Some
(
lessThan
(
lhs
rhsBigInt
)
)
;
}
JS
:
:
Result
<
Maybe
<
bool
>
>
BigInt
:
:
lessThan
(
JSContext
*
cx
HandleString
lhs
HandleBigInt
rhs
)
{
RootedBigInt
lhsBigInt
(
cx
)
;
MOZ_TRY_VAR
(
lhsBigInt
StringToBigInt
(
cx
lhs
0
)
)
;
if
(
!
lhsBigInt
)
{
return
Maybe
<
bool
>
(
Nothing
(
)
)
;
}
return
Some
(
lessThan
(
lhsBigInt
rhs
)
)
;
}
JS
:
:
Result
<
Maybe
<
bool
>
>
BigInt
:
:
lessThan
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
)
{
if
(
lhs
.
isBigInt
(
)
)
{
if
(
rhs
.
isString
(
)
)
{
RootedBigInt
lhsBigInt
(
cx
lhs
.
toBigInt
(
)
)
;
RootedString
rhsString
(
cx
rhs
.
toString
(
)
)
;
return
lessThan
(
cx
lhsBigInt
rhsString
)
;
}
if
(
rhs
.
isNumber
(
)
)
{
return
lessThan
(
lhs
.
toBigInt
(
)
rhs
.
toNumber
(
)
)
;
}
MOZ_ASSERT
(
rhs
.
isBigInt
(
)
)
;
return
Some
(
lessThan
(
lhs
.
toBigInt
(
)
rhs
.
toBigInt
(
)
)
)
;
}
MOZ_ASSERT
(
rhs
.
isBigInt
(
)
)
;
if
(
lhs
.
isString
(
)
)
{
RootedString
lhsString
(
cx
lhs
.
toString
(
)
)
;
RootedBigInt
rhsBigInt
(
cx
rhs
.
toBigInt
(
)
)
;
return
lessThan
(
cx
lhsString
rhsBigInt
)
;
}
MOZ_ASSERT
(
lhs
.
isNumber
(
)
)
;
return
lessThan
(
lhs
.
toNumber
(
)
rhs
.
toBigInt
(
)
)
;
}
JSLinearString
*
BigInt
:
:
toString
(
JSContext
*
cx
BigInt
*
x
uint8_t
radix
)
{
MOZ_ASSERT
(
2
<
=
radix
&
&
radix
<
=
36
)
;
size_t
strSize
=
mpz_sizeinbase
(
x
-
>
num_
10
)
+
2
;
UniqueChars
str
(
js_pod_malloc
<
char
>
(
strSize
)
)
;
if
(
!
str
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
mpz_get_str
(
str
.
get
(
)
radix
x
-
>
num_
)
;
return
NewStringCopyZ
<
CanGC
>
(
cx
str
.
get
(
)
)
;
}
template
<
typename
CharT
>
bool
js
:
:
StringToBigIntImpl
(
const
Range
<
const
CharT
>
&
chars
uint8_t
radix
HandleBigInt
res
)
{
const
RangedPtr
<
const
CharT
>
end
=
chars
.
end
(
)
;
RangedPtr
<
const
CharT
>
s
=
chars
.
begin
(
)
;
Maybe
<
int8_t
>
sign
;
s
=
SkipSpace
(
s
.
get
(
)
end
.
get
(
)
)
;
if
(
s
!
=
end
&
&
s
[
0
]
=
=
'
+
'
)
{
sign
.
emplace
(
1
)
;
s
+
+
;
}
else
if
(
s
!
=
end
&
&
s
[
0
]
=
=
'
-
'
)
{
sign
.
emplace
(
-
1
)
;
s
+
+
;
}
if
(
!
radix
)
{
radix
=
10
;
if
(
end
-
s
>
=
2
&
&
s
[
0
]
=
=
'
0
'
)
{
if
(
s
[
1
]
=
=
'
x
'
|
|
s
[
1
]
=
=
'
X
'
)
{
radix
=
16
;
s
+
=
2
;
}
else
if
(
s
[
1
]
=
=
'
o
'
|
|
s
[
1
]
=
=
'
O
'
)
{
radix
=
8
;
s
+
=
2
;
}
else
if
(
s
[
1
]
=
=
'
b
'
|
|
s
[
1
]
=
=
'
B
'
)
{
radix
=
2
;
s
+
=
2
;
}
if
(
radix
!
=
10
&
&
s
=
=
end
)
{
return
false
;
}
}
}
if
(
sign
&
&
radix
!
=
10
)
{
return
false
;
}
mpz_set_ui
(
res
-
>
num_
0
)
;
for
(
;
s
<
end
;
s
+
+
)
{
unsigned
digit
;
if
(
!
mozilla
:
:
IsAsciiAlphanumeric
(
s
[
0
]
)
)
{
s
=
SkipSpace
(
s
.
get
(
)
end
.
get
(
)
)
;
if
(
s
=
=
end
)
{
break
;
}
return
false
;
}
digit
=
mozilla
:
:
AsciiAlphanumericToNumber
(
s
[
0
]
)
;
if
(
digit
>
=
radix
)
{
return
false
;
}
mpz_mul_ui
(
res
-
>
num_
res
-
>
num_
radix
)
;
mpz_add_ui
(
res
-
>
num_
res
-
>
num_
digit
)
;
}
if
(
sign
.
valueOr
(
1
)
<
0
)
{
mpz_neg
(
res
-
>
num_
res
-
>
num_
)
;
}
return
true
;
}
JS
:
:
Result
<
BigInt
*
JS
:
:
OOM
&
>
js
:
:
StringToBigInt
(
JSContext
*
cx
HandleString
str
uint8_t
radix
)
{
RootedBigInt
res
(
cx
BigInt
:
:
create
(
cx
)
)
;
if
(
!
res
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
linear
-
>
hasLatin1Chars
(
)
)
{
if
(
StringToBigIntImpl
(
linear
-
>
latin1Range
(
nogc
)
radix
res
)
)
{
return
res
.
get
(
)
;
}
}
else
{
if
(
StringToBigIntImpl
(
linear
-
>
twoByteRange
(
nogc
)
radix
res
)
)
{
return
res
.
get
(
)
;
}
}
}
return
nullptr
;
}
size_t
BigInt
:
:
byteLength
(
BigInt
*
x
)
{
if
(
mpz_sgn
(
x
-
>
num_
)
=
=
0
)
{
return
0
;
}
return
JS_HOWMANY
(
mpz_sizeinbase
(
x
-
>
num_
2
)
8
)
;
}
void
BigInt
:
:
writeBytes
(
BigInt
*
x
RangedPtr
<
uint8_t
>
buffer
)
{
#
ifdef
DEBUG
size_t
reprSize
=
byteLength
(
x
)
;
MOZ_ASSERT
(
buffer
+
reprSize
"
out
of
bounds
access
to
buffer
"
)
;
#
endif
size_t
count
;
mpz_export
(
buffer
.
get
(
)
&
count
-
1
1
0
0
x
-
>
num_
)
;
MOZ_ASSERT
(
count
=
=
reprSize
)
;
}
void
BigInt
:
:
finalize
(
js
:
:
FreeOp
*
fop
)
{
mpz_clear
(
num_
)
;
}
JSAtom
*
js
:
:
BigIntToAtom
(
JSContext
*
cx
BigInt
*
bi
)
{
JSString
*
str
=
BigInt
:
:
toString
(
cx
bi
10
)
;
if
(
!
str
)
{
return
nullptr
;
}
return
AtomizeString
(
cx
str
)
;
}
bool
BigInt
:
:
toBoolean
(
)
{
return
mpz_sgn
(
num_
)
!
=
0
;
}
int8_t
BigInt
:
:
sign
(
)
{
return
mpz_sgn
(
num_
)
;
}
js
:
:
HashNumber
BigInt
:
:
hash
(
)
{
const
mp_limb_t
*
limbs
=
mpz_limbs_read
(
num_
)
;
size_t
limbCount
=
mpz_size
(
num_
)
;
uint32_t
hash
=
mozilla
:
:
HashBytes
(
limbs
limbCount
*
sizeof
(
mp_limb_t
)
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
mpz_sgn
(
num_
)
)
;
return
hash
;
}
size_t
BigInt
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
mpz_srcptr
n
=
static_cast
<
mpz_srcptr
>
(
num_
)
;
return
sizeof
(
*
n
)
+
sizeof
(
mp_limb_t
)
*
n
-
>
_mp_alloc
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
BigInt
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
BigInt
&
bi
=
get
(
)
;
MOZ_ASSERT
(
bi
.
isTenured
(
)
)
;
size_t
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
bi
.
asTenured
(
)
.
getAllocKind
(
)
)
;
size
+
=
bi
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
return
size
;
}
