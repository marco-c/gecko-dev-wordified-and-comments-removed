#
include
"
vm
/
Scope
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
MakeScopeExit
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
const
char
*
js
:
:
BindingKindString
(
BindingKind
kind
)
{
switch
(
kind
)
{
case
BindingKind
:
:
Import
:
return
"
import
"
;
case
BindingKind
:
:
FormalParameter
:
return
"
formal
parameter
"
;
case
BindingKind
:
:
Var
:
return
"
var
"
;
case
BindingKind
:
:
Let
:
return
"
let
"
;
case
BindingKind
:
:
Const
:
return
"
const
"
;
case
BindingKind
:
:
NamedLambdaCallee
:
return
"
named
lambda
callee
"
;
}
MOZ_CRASH
(
"
Bad
BindingKind
"
)
;
}
const
char
*
js
:
:
ScopeKindString
(
ScopeKind
kind
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
Function
:
return
"
function
"
;
case
ScopeKind
:
:
FunctionBodyVar
:
return
"
function
body
var
"
;
case
ScopeKind
:
:
ParameterExpressionVar
:
return
"
parameter
expression
var
"
;
case
ScopeKind
:
:
Lexical
:
return
"
lexical
"
;
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
return
"
catch
"
;
case
ScopeKind
:
:
NamedLambda
:
return
"
named
lambda
"
;
case
ScopeKind
:
:
StrictNamedLambda
:
return
"
strict
named
lambda
"
;
case
ScopeKind
:
:
With
:
return
"
with
"
;
case
ScopeKind
:
:
Eval
:
return
"
eval
"
;
case
ScopeKind
:
:
StrictEval
:
return
"
strict
eval
"
;
case
ScopeKind
:
:
Global
:
return
"
global
"
;
case
ScopeKind
:
:
NonSyntactic
:
return
"
non
-
syntactic
"
;
case
ScopeKind
:
:
Module
:
return
"
module
"
;
case
ScopeKind
:
:
WasmFunction
:
return
"
wasm
function
"
;
}
MOZ_CRASH
(
"
Bad
ScopeKind
"
)
;
}
static
Shape
*
EmptyEnvironmentShape
(
ExclusiveContext
*
cx
const
Class
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
{
uint32_t
numFixed
=
gc
:
:
GetGCKindSlots
(
gc
:
:
GetGCObjectKind
(
numSlots
)
)
;
return
EmptyShape
:
:
getInitialShape
(
cx
cls
TaggedProto
(
nullptr
)
numFixed
baseShapeFlags
)
;
}
static
Shape
*
NextEnvironmentShape
(
ExclusiveContext
*
cx
HandleAtom
name
BindingKind
bindKind
uint32_t
slot
StackBaseShape
&
stackBase
HandleShape
shape
)
{
UnownedBaseShape
*
base
=
BaseShape
:
:
getUnowned
(
cx
stackBase
)
;
if
(
!
base
)
return
nullptr
;
unsigned
attrs
=
JSPROP_PERMANENT
|
JSPROP_ENUMERATE
;
switch
(
bindKind
)
{
case
BindingKind
:
:
Const
:
case
BindingKind
:
:
NamedLambdaCallee
:
attrs
|
=
JSPROP_READONLY
;
break
;
default
:
break
;
}
jsid
id
=
NameToId
(
name
-
>
asPropertyName
(
)
)
;
Rooted
<
StackShape
>
child
(
cx
StackShape
(
base
id
slot
attrs
0
)
)
;
return
cx
-
>
zone
(
)
-
>
propertyTree
.
getChild
(
cx
shape
child
)
;
}
static
Shape
*
CreateEnvironmentShape
(
ExclusiveContext
*
cx
BindingIter
&
bi
const
Class
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
{
RootedShape
shape
(
cx
EmptyEnvironmentShape
(
cx
cls
numSlots
baseShapeFlags
)
)
;
if
(
!
shape
)
return
nullptr
;
RootedAtom
name
(
cx
)
;
StackBaseShape
stackBase
(
cx
cls
baseShapeFlags
)
;
for
(
;
bi
;
bi
+
+
)
{
BindingLocation
loc
=
bi
.
location
(
)
;
if
(
loc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Environment
)
{
name
=
bi
.
name
(
)
;
cx
-
>
markAtom
(
name
)
;
shape
=
NextEnvironmentShape
(
cx
name
bi
.
kind
(
)
loc
.
slot
(
)
stackBase
shape
)
;
if
(
!
shape
)
return
nullptr
;
}
}
return
shape
;
}
template
<
typename
ConcreteScope
>
static
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
CopyScopeData
(
ExclusiveContext
*
cx
Handle
<
typename
ConcreteScope
:
:
Data
*
>
data
)
{
BindingName
*
names
=
nullptr
;
uint32_t
length
=
0
;
ConcreteScope
:
:
getDataNamesAndLength
(
data
&
names
&
length
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
JSAtom
*
name
=
names
[
i
]
.
name
(
)
)
cx
-
>
markAtom
(
name
)
;
}
size_t
dataSize
=
ConcreteScope
:
:
sizeOfData
(
data
-
>
length
)
;
uint8_t
*
copyBytes
=
cx
-
>
zone
(
)
-
>
pod_malloc
<
uint8_t
>
(
dataSize
)
;
if
(
!
copyBytes
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
mozilla
:
:
PodCopy
<
uint8_t
>
(
copyBytes
reinterpret_cast
<
uint8_t
*
>
(
data
.
get
(
)
)
dataSize
)
;
auto
dataCopy
=
reinterpret_cast
<
typename
ConcreteScope
:
:
Data
*
>
(
copyBytes
)
;
return
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
(
dataCopy
)
;
}
template
<
typename
ConcreteScope
>
static
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
CopyScopeData
(
ExclusiveContext
*
cx
BindingIter
&
bi
Handle
<
typename
ConcreteScope
:
:
Data
*
>
data
const
Class
*
cls
uint32_t
baseShapeFlags
MutableHandleShape
envShape
)
{
BindingIter
freshBi
(
bi
)
;
while
(
bi
)
bi
+
+
;
data
-
>
nextFrameSlot
=
bi
.
canHaveFrameSlots
(
)
?
bi
.
nextFrameSlot
(
)
:
LOCALNO_LIMIT
;
if
(
bi
.
nextEnvironmentSlot
(
)
=
=
JSSLOT_FREE
(
cls
)
)
{
envShape
.
set
(
nullptr
)
;
}
else
{
envShape
.
set
(
CreateEnvironmentShape
(
cx
freshBi
cls
bi
.
nextEnvironmentSlot
(
)
baseShapeFlags
)
)
;
if
(
!
envShape
)
return
nullptr
;
}
return
CopyScopeData
<
ConcreteScope
>
(
cx
data
)
;
}
template
<
typename
ConcreteScope
>
static
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
NewEmptyScopeData
(
ExclusiveContext
*
cx
uint32_t
length
=
0
)
{
uint8_t
*
bytes
=
cx
-
>
zone
(
)
-
>
pod_calloc
<
uint8_t
>
(
ConcreteScope
:
:
sizeOfData
(
length
)
)
;
if
(
!
bytes
)
ReportOutOfMemory
(
cx
)
;
auto
data
=
reinterpret_cast
<
typename
ConcreteScope
:
:
Data
*
>
(
bytes
)
;
return
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
(
data
)
;
}
static
bool
XDRBindingName
(
XDRState
<
XDR_ENCODE
>
*
xdr
BindingName
*
bindingName
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
RootedAtom
atom
(
cx
bindingName
-
>
name
(
)
)
;
bool
hasAtom
=
!
!
atom
;
uint8_t
u8
=
uint8_t
(
hasAtom
<
<
1
)
|
uint8_t
(
bindingName
-
>
closedOver
(
)
)
;
if
(
!
xdr
-
>
codeUint8
(
&
u8
)
)
return
false
;
if
(
atom
&
&
!
XDRAtom
(
xdr
&
atom
)
)
return
false
;
return
true
;
}
static
bool
XDRBindingName
(
XDRState
<
XDR_DECODE
>
*
xdr
BindingName
*
bindingName
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
uint8_t
u8
;
if
(
!
xdr
-
>
codeUint8
(
&
u8
)
)
return
false
;
bool
closedOver
=
u8
&
1
;
bool
hasAtom
=
u8
>
>
1
;
RootedAtom
atom
(
cx
)
;
if
(
hasAtom
&
&
!
XDRAtom
(
xdr
&
atom
)
)
return
false
;
*
bindingName
=
BindingName
(
atom
closedOver
)
;
return
true
;
}
template
<
typename
ConcreteScope
XDRMode
mode
>
bool
Scope
:
:
XDRSizedBindingNames
(
XDRState
<
mode
>
*
xdr
Handle
<
ConcreteScope
*
>
scope
MutableHandle
<
typename
ConcreteScope
:
:
Data
*
>
data
)
{
MOZ_ASSERT
(
!
data
)
;
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
uint32_t
length
;
if
(
mode
=
=
XDR_ENCODE
)
length
=
scope
-
>
data
(
)
.
length
;
if
(
!
xdr
-
>
codeUint32
(
&
length
)
)
return
false
;
if
(
mode
=
=
XDR_ENCODE
)
{
data
.
set
(
&
scope
-
>
data
(
)
)
;
}
else
{
data
.
set
(
NewEmptyScopeData
<
ConcreteScope
>
(
cx
length
)
.
release
(
)
)
;
if
(
!
data
)
return
false
;
data
-
>
length
=
length
;
}
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
!
XDRBindingName
(
xdr
&
data
-
>
names
[
i
]
)
)
{
if
(
mode
=
=
XDR_DECODE
)
{
js_free
(
data
)
;
data
.
set
(
nullptr
)
;
}
return
false
;
}
}
return
true
;
}
Scope
*
Scope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
)
{
Scope
*
scope
=
Allocate
<
Scope
>
(
cx
)
;
if
(
scope
)
new
(
scope
)
Scope
(
kind
enclosing
envShape
)
;
return
scope
;
}
template
<
typename
T
typename
D
>
Scope
*
Scope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
mozilla
:
:
UniquePtr
<
T
D
>
data
)
{
Scope
*
scope
=
create
(
cx
kind
enclosing
envShape
)
;
if
(
!
scope
)
return
nullptr
;
MOZ_ASSERT
(
data
)
;
scope
-
>
initData
(
Move
(
data
)
)
;
return
scope
;
}
uint32_t
Scope
:
:
chainLength
(
)
const
{
uint32_t
length
=
0
;
for
(
ScopeIter
si
(
const_cast
<
Scope
*
>
(
this
)
)
;
si
;
si
+
+
)
length
+
+
;
return
length
;
}
uint32_t
Scope
:
:
environmentChainLength
(
)
const
{
uint32_t
length
=
0
;
for
(
ScopeIter
si
(
const_cast
<
Scope
*
>
(
this
)
)
;
si
;
si
+
+
)
{
if
(
si
.
hasSyntacticEnvironment
(
)
)
length
+
+
;
}
return
length
;
}
Shape
*
Scope
:
:
maybeCloneEnvironmentShape
(
JSContext
*
cx
)
{
if
(
environmentShape_
&
&
environmentShape_
-
>
zoneFromAnyThread
(
)
!
=
cx
-
>
zone
(
)
)
{
BindingIter
bi
(
this
)
;
return
CreateEnvironmentShape
(
cx
bi
environmentShape_
-
>
getObjectClass
(
)
environmentShape_
-
>
slotSpan
(
)
environmentShape_
-
>
getObjectFlags
(
)
)
;
}
return
environmentShape_
;
}
Scope
*
Scope
:
:
clone
(
JSContext
*
cx
HandleScope
scope
HandleScope
enclosing
)
{
RootedShape
envShape
(
cx
)
;
if
(
scope
-
>
environmentShape
(
)
)
{
envShape
=
scope
-
>
maybeCloneEnvironmentShape
(
cx
)
;
if
(
!
envShape
)
return
nullptr
;
}
switch
(
scope
-
>
kind_
)
{
case
ScopeKind
:
:
Function
:
MOZ_CRASH
(
"
Use
FunctionScope
:
:
clone
.
"
)
;
break
;
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
ParameterExpressionVar
:
{
Rooted
<
VarScope
:
:
Data
*
>
original
(
cx
&
scope
-
>
as
<
VarScope
>
(
)
.
data
(
)
)
;
UniquePtr
<
VarScope
:
:
Data
>
dataClone
=
CopyScopeData
<
VarScope
>
(
cx
original
)
;
if
(
!
dataClone
)
return
nullptr
;
return
create
(
cx
scope
-
>
kind_
enclosing
envShape
Move
(
dataClone
)
)
;
}
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
{
Rooted
<
LexicalScope
:
:
Data
*
>
original
(
cx
&
scope
-
>
as
<
LexicalScope
>
(
)
.
data
(
)
)
;
UniquePtr
<
LexicalScope
:
:
Data
>
dataClone
=
CopyScopeData
<
LexicalScope
>
(
cx
original
)
;
if
(
!
dataClone
)
return
nullptr
;
return
create
(
cx
scope
-
>
kind_
enclosing
envShape
Move
(
dataClone
)
)
;
}
case
ScopeKind
:
:
With
:
return
create
(
cx
scope
-
>
kind_
enclosing
envShape
)
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
{
Rooted
<
EvalScope
:
:
Data
*
>
original
(
cx
&
scope
-
>
as
<
EvalScope
>
(
)
.
data
(
)
)
;
UniquePtr
<
EvalScope
:
:
Data
>
dataClone
=
CopyScopeData
<
EvalScope
>
(
cx
original
)
;
if
(
!
dataClone
)
return
nullptr
;
return
create
(
cx
scope
-
>
kind_
enclosing
envShape
Move
(
dataClone
)
)
;
}
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
MOZ_CRASH
(
"
Use
GlobalScope
:
:
clone
.
"
)
;
break
;
case
ScopeKind
:
:
WasmFunction
:
MOZ_CRASH
(
"
wasm
functions
are
not
nested
in
JSScript
"
)
;
break
;
case
ScopeKind
:
:
Module
:
MOZ_CRASH
(
"
NYI
"
)
;
break
;
}
return
nullptr
;
}
void
Scope
:
:
finalize
(
FreeOp
*
fop
)
{
if
(
data_
)
{
fop
-
>
free_
(
reinterpret_cast
<
void
*
>
(
data_
)
)
;
data_
=
0
;
}
}
size_t
Scope
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
if
(
data_
)
return
mallocSizeOf
(
reinterpret_cast
<
void
*
>
(
data_
)
)
;
return
0
;
}
void
Scope
:
:
dump
(
)
{
for
(
ScopeIter
si
(
this
)
;
si
;
si
+
+
)
{
fprintf
(
stderr
"
%
s
[
%
p
]
"
ScopeKindString
(
si
.
kind
(
)
)
si
.
scope
(
)
)
;
if
(
si
.
scope
(
)
-
>
enclosing
(
)
)
fprintf
(
stderr
"
-
>
"
)
;
}
fprintf
(
stderr
"
\
n
"
)
;
}
uint32_t
LexicalScope
:
:
firstFrameSlot
(
)
const
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
return
nextFrameSlot
(
enclosing
(
)
)
;
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
return
LOCALNO_LIMIT
;
default
:
break
;
}
return
0
;
}
uint32_t
LexicalScope
:
:
nextFrameSlot
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
switch
(
si
.
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
return
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
ParameterExpressionVar
:
return
si
.
scope
(
)
-
>
as
<
VarScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
return
si
.
scope
(
)
-
>
as
<
LexicalScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
return
0
;
case
ScopeKind
:
:
With
:
continue
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
return
si
.
scope
(
)
-
>
as
<
EvalScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
0
;
case
ScopeKind
:
:
Module
:
return
si
.
scope
(
)
-
>
as
<
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
WasmFunction
:
return
0
;
}
}
MOZ_CRASH
(
"
Not
an
enclosing
intra
-
frame
Scope
"
)
;
}
LexicalScope
*
LexicalScope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
HandleScope
enclosing
)
{
bool
isNamedLambda
=
kind
=
=
ScopeKind
:
:
NamedLambda
|
|
kind
=
=
ScopeKind
:
:
StrictNamedLambda
;
MOZ_ASSERT
(
data
"
LexicalScopes
should
not
be
created
if
there
are
no
bindings
.
"
)
;
MOZ_ASSERT_IF
(
!
isNamedLambda
&
&
firstFrameSlot
!
=
0
firstFrameSlot
=
=
nextFrameSlot
(
enclosing
)
)
;
MOZ_ASSERT_IF
(
isNamedLambda
firstFrameSlot
=
=
LOCALNO_LIMIT
)
;
RootedShape
envShape
(
cx
)
;
BindingIter
bi
(
*
data
firstFrameSlot
isNamedLambda
)
;
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
CopyScopeData
<
LexicalScope
>
(
cx
bi
data
&
LexicalEnvironmentObject
:
:
class_
BaseShape
:
:
NOT_EXTENSIBLE
|
BaseShape
:
:
DELEGATE
&
envShape
)
)
;
if
(
!
copy
)
return
nullptr
;
Scope
*
scope
=
Scope
:
:
create
(
cx
kind
enclosing
envShape
Move
(
copy
.
get
(
)
)
)
;
if
(
!
scope
)
return
nullptr
;
MOZ_ASSERT
(
scope
-
>
as
<
LexicalScope
>
(
)
.
firstFrameSlot
(
)
=
=
firstFrameSlot
)
;
return
&
scope
-
>
as
<
LexicalScope
>
(
)
;
}
Shape
*
LexicalScope
:
:
getEmptyExtensibleEnvironmentShape
(
ExclusiveContext
*
cx
)
{
const
Class
*
cls
=
&
LexicalEnvironmentObject
:
:
class_
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
BaseShape
:
:
DELEGATE
)
;
}
template
<
XDRMode
mode
>
bool
LexicalScope
:
:
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
Rooted
<
Data
*
>
data
(
cx
)
;
if
(
!
XDRSizedBindingNames
<
LexicalScope
>
(
xdr
scope
.
as
<
LexicalScope
>
(
)
&
data
)
)
return
false
;
{
auto
freeOnLeave
=
MakeScopeExit
(
[
&
data
]
(
)
{
if
(
mode
=
=
XDR_DECODE
)
js_free
(
data
)
;
}
)
;
uint32_t
firstFrameSlot
;
uint32_t
nextFrameSlot
;
if
(
mode
=
=
XDR_ENCODE
)
{
firstFrameSlot
=
scope
-
>
as
<
LexicalScope
>
(
)
.
firstFrameSlot
(
)
;
nextFrameSlot
=
data
-
>
nextFrameSlot
;
}
if
(
!
xdr
-
>
codeUint32
(
&
data
-
>
constStart
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
firstFrameSlot
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
nextFrameSlot
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
scope
.
set
(
create
(
cx
kind
data
firstFrameSlot
enclosing
)
)
;
if
(
!
scope
)
return
false
;
MOZ_ASSERT
(
nextFrameSlot
=
=
scope
-
>
as
<
LexicalScope
>
(
)
.
data
(
)
.
nextFrameSlot
)
;
}
}
return
true
;
}
template
bool
LexicalScope
:
:
XDR
(
XDRState
<
XDR_ENCODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
template
bool
LexicalScope
:
:
XDR
(
XDRState
<
XDR_DECODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
static
inline
uint32_t
FunctionScopeEnvShapeFlags
(
bool
hasParameterExprs
)
{
if
(
hasParameterExprs
)
return
BaseShape
:
:
DELEGATE
;
return
BaseShape
:
:
QUALIFIED_VAROBJ
|
BaseShape
:
:
DELEGATE
;
}
UniquePtr
<
FunctionScope
:
:
Data
>
FunctionScope
:
:
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
bool
hasParameterExprs
MutableHandleShape
envShape
)
{
if
(
data
)
{
BindingIter
bi
(
*
data
hasParameterExprs
)
;
uint32_t
shapeFlags
=
FunctionScopeEnvShapeFlags
(
hasParameterExprs
)
;
return
CopyScopeData
<
FunctionScope
>
(
cx
bi
data
&
CallObject
:
:
class_
shapeFlags
envShape
)
;
}
return
NewEmptyScopeData
<
FunctionScope
>
(
cx
)
;
}
FunctionScope
*
FunctionScope
:
:
create
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
bool
hasParameterExprs
bool
needsEnvironment
HandleFunction
fun
HandleScope
enclosing
)
{
MOZ_ASSERT
(
fun
-
>
isTenured
(
)
)
;
Rooted
<
FunctionScope
*
>
funScope
(
cx
)
;
{
RootedShape
envShape
(
cx
)
;
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
copyData
(
cx
data
hasParameterExprs
&
envShape
)
)
;
if
(
!
copy
)
return
nullptr
;
copy
-
>
hasParameterExprs
=
hasParameterExprs
;
if
(
!
envShape
&
&
needsEnvironment
)
{
envShape
=
getEmptyEnvironmentShape
(
cx
hasParameterExprs
)
;
if
(
!
envShape
)
return
nullptr
;
}
Scope
*
scope
=
Scope
:
:
create
(
cx
ScopeKind
:
:
Function
enclosing
envShape
)
;
if
(
!
scope
)
return
nullptr
;
copy
-
>
canonicalFunction
.
init
(
fun
)
;
funScope
=
&
scope
-
>
as
<
FunctionScope
>
(
)
;
funScope
-
>
initData
(
Move
(
copy
.
get
(
)
)
)
;
}
return
funScope
;
}
JSScript
*
FunctionScope
:
:
script
(
)
const
{
return
canonicalFunction
(
)
-
>
nonLazyScript
(
)
;
}
Shape
*
FunctionScope
:
:
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
bool
hasParameterExprs
)
{
const
Class
*
cls
=
&
CallObject
:
:
class_
;
uint32_t
shapeFlags
=
FunctionScopeEnvShapeFlags
(
hasParameterExprs
)
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
shapeFlags
)
;
}
FunctionScope
*
FunctionScope
:
:
clone
(
JSContext
*
cx
Handle
<
FunctionScope
*
>
scope
HandleFunction
fun
HandleScope
enclosing
)
{
MOZ_ASSERT
(
fun
!
=
scope
-
>
canonicalFunction
(
)
)
;
Rooted
<
FunctionScope
*
>
funScopeClone
(
cx
)
;
{
RootedShape
envShape
(
cx
)
;
if
(
scope
-
>
environmentShape
(
)
)
{
envShape
=
scope
-
>
maybeCloneEnvironmentShape
(
cx
)
;
if
(
!
envShape
)
return
nullptr
;
}
Rooted
<
Data
*
>
dataOriginal
(
cx
&
scope
-
>
as
<
FunctionScope
>
(
)
.
data
(
)
)
;
Rooted
<
UniquePtr
<
Data
>
>
dataClone
(
cx
CopyScopeData
<
FunctionScope
>
(
cx
dataOriginal
)
)
;
if
(
!
dataClone
)
return
nullptr
;
Scope
*
scopeClone
=
Scope
:
:
create
(
cx
scope
-
>
kind
(
)
enclosing
envShape
)
;
if
(
!
scopeClone
)
return
nullptr
;
dataClone
-
>
canonicalFunction
.
init
(
fun
)
;
funScopeClone
=
&
scopeClone
-
>
as
<
FunctionScope
>
(
)
;
funScopeClone
-
>
initData
(
Move
(
dataClone
.
get
(
)
)
)
;
}
return
funScopeClone
;
}
template
<
XDRMode
mode
>
bool
FunctionScope
:
:
XDR
(
XDRState
<
mode
>
*
xdr
HandleFunction
fun
HandleScope
enclosing
MutableHandleScope
scope
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
Rooted
<
Data
*
>
data
(
cx
)
;
if
(
!
XDRSizedBindingNames
<
FunctionScope
>
(
xdr
scope
.
as
<
FunctionScope
>
(
)
&
data
)
)
return
false
;
{
auto
freeOnLeave
=
MakeScopeExit
(
[
&
data
]
(
)
{
if
(
mode
=
=
XDR_DECODE
)
js_free
(
data
)
;
}
)
;
uint8_t
needsEnvironment
;
uint8_t
hasParameterExprs
;
uint32_t
nextFrameSlot
;
if
(
mode
=
=
XDR_ENCODE
)
{
needsEnvironment
=
scope
-
>
hasEnvironment
(
)
;
hasParameterExprs
=
data
-
>
hasParameterExprs
;
nextFrameSlot
=
data
-
>
nextFrameSlot
;
}
if
(
!
xdr
-
>
codeUint8
(
&
needsEnvironment
)
)
return
false
;
if
(
!
xdr
-
>
codeUint8
(
&
hasParameterExprs
)
)
return
false
;
if
(
!
xdr
-
>
codeUint16
(
&
data
-
>
nonPositionalFormalStart
)
)
return
false
;
if
(
!
xdr
-
>
codeUint16
(
&
data
-
>
varStart
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
nextFrameSlot
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
if
(
!
data
-
>
length
)
{
MOZ_ASSERT
(
!
data
-
>
nonPositionalFormalStart
)
;
MOZ_ASSERT
(
!
data
-
>
varStart
)
;
MOZ_ASSERT
(
!
data
-
>
nextFrameSlot
)
;
js_free
(
data
)
;
data
=
nullptr
;
}
scope
.
set
(
create
(
cx
data
hasParameterExprs
needsEnvironment
fun
enclosing
)
)
;
if
(
!
scope
)
return
false
;
MOZ_ASSERT
(
nextFrameSlot
=
=
scope
-
>
as
<
FunctionScope
>
(
)
.
data
(
)
.
nextFrameSlot
)
;
}
}
return
true
;
}
template
bool
FunctionScope
:
:
XDR
(
XDRState
<
XDR_ENCODE
>
*
xdr
HandleFunction
fun
HandleScope
enclosing
MutableHandleScope
scope
)
;
template
bool
FunctionScope
:
:
XDR
(
XDRState
<
XDR_DECODE
>
*
xdr
HandleFunction
fun
HandleScope
enclosing
MutableHandleScope
scope
)
;
static
const
uint32_t
VarScopeEnvShapeFlags
=
BaseShape
:
:
QUALIFIED_VAROBJ
|
BaseShape
:
:
DELEGATE
;
UniquePtr
<
VarScope
:
:
Data
>
VarScope
:
:
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
MutableHandleShape
envShape
)
{
if
(
data
)
{
BindingIter
bi
(
*
data
firstFrameSlot
)
;
return
CopyScopeData
<
VarScope
>
(
cx
bi
data
&
VarEnvironmentObject
:
:
class_
VarScopeEnvShapeFlags
envShape
)
;
}
UniquePtr
<
Data
>
empty
=
NewEmptyScopeData
<
VarScope
>
(
cx
)
;
if
(
empty
)
empty
-
>
nextFrameSlot
=
firstFrameSlot
;
return
empty
;
}
VarScope
*
VarScope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
bool
needsEnvironment
HandleScope
enclosing
)
{
RootedShape
envShape
(
cx
)
;
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
copyData
(
cx
data
firstFrameSlot
&
envShape
)
)
;
if
(
!
copy
)
return
nullptr
;
if
(
!
envShape
&
&
needsEnvironment
)
{
envShape
=
getEmptyEnvironmentShape
(
cx
)
;
if
(
!
envShape
)
return
nullptr
;
}
Scope
*
scope
=
Scope
:
:
create
(
cx
kind
enclosing
envShape
Move
(
copy
.
get
(
)
)
)
;
if
(
!
scope
)
return
nullptr
;
return
&
scope
-
>
as
<
VarScope
>
(
)
;
}
Shape
*
VarScope
:
:
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
{
const
Class
*
cls
=
&
VarEnvironmentObject
:
:
class_
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
VarScopeEnvShapeFlags
)
;
}
uint32_t
VarScope
:
:
firstFrameSlot
(
)
const
{
if
(
enclosing
(
)
-
>
is
<
FunctionScope
>
(
)
)
return
enclosing
(
)
-
>
as
<
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
return
0
;
}
template
<
XDRMode
mode
>
bool
VarScope
:
:
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
Rooted
<
Data
*
>
data
(
cx
)
;
if
(
!
XDRSizedBindingNames
<
VarScope
>
(
xdr
scope
.
as
<
VarScope
>
(
)
&
data
)
)
return
false
;
{
auto
freeOnLeave
=
MakeScopeExit
(
[
&
data
]
(
)
{
if
(
mode
=
=
XDR_DECODE
)
js_free
(
data
)
;
}
)
;
uint8_t
needsEnvironment
;
uint32_t
firstFrameSlot
;
uint32_t
nextFrameSlot
;
if
(
mode
=
=
XDR_ENCODE
)
{
needsEnvironment
=
scope
-
>
hasEnvironment
(
)
;
firstFrameSlot
=
scope
-
>
as
<
VarScope
>
(
)
.
firstFrameSlot
(
)
;
nextFrameSlot
=
data
-
>
nextFrameSlot
;
}
if
(
!
xdr
-
>
codeUint8
(
&
needsEnvironment
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
firstFrameSlot
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
nextFrameSlot
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
if
(
!
data
-
>
length
)
{
MOZ_ASSERT
(
!
data
-
>
nextFrameSlot
)
;
js_free
(
data
)
;
data
=
nullptr
;
}
scope
.
set
(
create
(
cx
kind
data
firstFrameSlot
needsEnvironment
enclosing
)
)
;
if
(
!
scope
)
return
false
;
MOZ_ASSERT
(
nextFrameSlot
=
=
scope
-
>
as
<
VarScope
>
(
)
.
data
(
)
.
nextFrameSlot
)
;
}
}
return
true
;
}
template
bool
VarScope
:
:
XDR
(
XDRState
<
XDR_ENCODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
template
bool
VarScope
:
:
XDR
(
XDRState
<
XDR_DECODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
UniquePtr
<
GlobalScope
:
:
Data
>
GlobalScope
:
:
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
)
{
if
(
data
)
{
return
CopyScopeData
<
GlobalScope
>
(
cx
data
)
;
}
return
NewEmptyScopeData
<
GlobalScope
>
(
cx
)
;
}
GlobalScope
*
GlobalScope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
)
{
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
copyData
(
cx
data
)
)
;
if
(
!
copy
)
return
nullptr
;
Scope
*
scope
=
Scope
:
:
create
(
cx
kind
nullptr
nullptr
Move
(
copy
.
get
(
)
)
)
;
if
(
!
scope
)
return
nullptr
;
return
&
scope
-
>
as
<
GlobalScope
>
(
)
;
}
GlobalScope
*
GlobalScope
:
:
clone
(
JSContext
*
cx
Handle
<
GlobalScope
*
>
scope
ScopeKind
kind
)
{
Rooted
<
Data
*
>
dataOriginal
(
cx
&
scope
-
>
as
<
GlobalScope
>
(
)
.
data
(
)
)
;
Rooted
<
UniquePtr
<
Data
>
>
dataClone
(
cx
CopyScopeData
<
GlobalScope
>
(
cx
dataOriginal
)
)
;
if
(
!
dataClone
)
return
nullptr
;
Scope
*
scopeClone
=
Scope
:
:
create
(
cx
kind
nullptr
nullptr
Move
(
dataClone
.
get
(
)
)
)
;
if
(
!
scopeClone
)
return
nullptr
;
return
&
scopeClone
-
>
as
<
GlobalScope
>
(
)
;
}
template
<
XDRMode
mode
>
bool
GlobalScope
:
:
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
MutableHandleScope
scope
)
{
MOZ_ASSERT
(
(
mode
=
=
XDR_DECODE
)
=
=
!
scope
)
;
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
Rooted
<
Data
*
>
data
(
cx
)
;
if
(
!
XDRSizedBindingNames
<
GlobalScope
>
(
xdr
scope
.
as
<
GlobalScope
>
(
)
&
data
)
)
return
false
;
{
auto
freeOnLeave
=
MakeScopeExit
(
[
&
data
]
(
)
{
if
(
mode
=
=
XDR_DECODE
)
js_free
(
data
)
;
}
)
;
if
(
!
xdr
-
>
codeUint32
(
&
data
-
>
varStart
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
data
-
>
letStart
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
data
-
>
constStart
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
if
(
!
data
-
>
length
)
{
MOZ_ASSERT
(
!
data
-
>
varStart
)
;
MOZ_ASSERT
(
!
data
-
>
letStart
)
;
MOZ_ASSERT
(
!
data
-
>
constStart
)
;
js_free
(
data
)
;
data
=
nullptr
;
}
scope
.
set
(
create
(
cx
kind
data
)
)
;
if
(
!
scope
)
return
false
;
}
}
return
true
;
}
template
bool
GlobalScope
:
:
XDR
(
XDRState
<
XDR_ENCODE
>
*
xdr
ScopeKind
kind
MutableHandleScope
scope
)
;
template
bool
GlobalScope
:
:
XDR
(
XDRState
<
XDR_DECODE
>
*
xdr
ScopeKind
kind
MutableHandleScope
scope
)
;
WithScope
*
WithScope
:
:
create
(
ExclusiveContext
*
cx
HandleScope
enclosing
)
{
Scope
*
scope
=
Scope
:
:
create
(
cx
ScopeKind
:
:
With
enclosing
nullptr
)
;
return
static_cast
<
WithScope
*
>
(
scope
)
;
}
static
const
uint32_t
EvalScopeEnvShapeFlags
=
BaseShape
:
:
QUALIFIED_VAROBJ
|
BaseShape
:
:
DELEGATE
;
UniquePtr
<
EvalScope
:
:
Data
>
EvalScope
:
:
copyData
(
ExclusiveContext
*
cx
ScopeKind
scopeKind
Handle
<
Data
*
>
data
MutableHandleShape
envShape
)
{
if
(
data
)
{
if
(
scopeKind
=
=
ScopeKind
:
:
StrictEval
)
{
BindingIter
bi
(
*
data
true
)
;
return
CopyScopeData
<
EvalScope
>
(
cx
bi
data
&
VarEnvironmentObject
:
:
class_
EvalScopeEnvShapeFlags
envShape
)
;
}
return
CopyScopeData
<
EvalScope
>
(
cx
data
)
;
}
return
NewEmptyScopeData
<
EvalScope
>
(
cx
)
;
}
EvalScope
*
EvalScope
:
:
create
(
ExclusiveContext
*
cx
ScopeKind
scopeKind
Handle
<
Data
*
>
data
HandleScope
enclosing
)
{
RootedShape
envShape
(
cx
)
;
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
copyData
(
cx
scopeKind
data
&
envShape
)
)
;
if
(
!
copy
)
return
nullptr
;
if
(
!
envShape
&
&
scopeKind
=
=
ScopeKind
:
:
StrictEval
)
{
envShape
=
getEmptyEnvironmentShape
(
cx
)
;
if
(
!
envShape
)
return
nullptr
;
}
Scope
*
scope
=
Scope
:
:
create
(
cx
scopeKind
enclosing
envShape
Move
(
copy
.
get
(
)
)
)
;
if
(
!
scope
)
return
nullptr
;
return
&
scope
-
>
as
<
EvalScope
>
(
)
;
}
Scope
*
EvalScope
:
:
nearestVarScopeForDirectEval
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
switch
(
si
.
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
ParameterExpressionVar
:
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
scope
;
default
:
break
;
}
}
return
nullptr
;
}
Shape
*
EvalScope
:
:
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
{
const
Class
*
cls
=
&
VarEnvironmentObject
:
:
class_
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
EvalScopeEnvShapeFlags
)
;
}
template
<
XDRMode
mode
>
bool
EvalScope
:
:
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
{
ExclusiveContext
*
cx
=
xdr
-
>
cx
(
)
;
Rooted
<
Data
*
>
data
(
cx
)
;
{
auto
freeOnLeave
=
MakeScopeExit
(
[
&
data
]
(
)
{
if
(
mode
=
=
XDR_DECODE
)
js_free
(
data
)
;
}
)
;
if
(
!
XDRSizedBindingNames
<
EvalScope
>
(
xdr
scope
.
as
<
EvalScope
>
(
)
&
data
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
if
(
!
data
-
>
length
)
{
MOZ_ASSERT
(
!
data
-
>
nextFrameSlot
)
;
js_free
(
data
)
;
data
=
nullptr
;
}
scope
.
set
(
create
(
cx
kind
data
enclosing
)
)
;
if
(
!
scope
)
return
false
;
}
}
return
true
;
}
template
bool
EvalScope
:
:
XDR
(
XDRState
<
XDR_ENCODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
template
bool
EvalScope
:
:
XDR
(
XDRState
<
XDR_DECODE
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
static
const
uint32_t
ModuleScopeEnvShapeFlags
=
BaseShape
:
:
NOT_EXTENSIBLE
|
BaseShape
:
:
QUALIFIED_VAROBJ
|
BaseShape
:
:
DELEGATE
;
UniquePtr
<
ModuleScope
:
:
Data
>
ModuleScope
:
:
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
MutableHandleShape
envShape
)
{
if
(
data
)
{
BindingIter
bi
(
*
data
)
;
return
CopyScopeData
<
ModuleScope
>
(
cx
bi
data
&
ModuleEnvironmentObject
:
:
class_
ModuleScopeEnvShapeFlags
envShape
)
;
}
return
NewEmptyScopeData
<
ModuleScope
>
(
cx
)
;
}
ModuleScope
*
ModuleScope
:
:
create
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
HandleModuleObject
module
HandleScope
enclosing
)
{
MOZ_ASSERT
(
enclosing
-
>
is
<
GlobalScope
>
(
)
)
;
Rooted
<
ModuleScope
*
>
moduleScope
(
cx
)
;
{
RootedShape
envShape
(
cx
)
;
Rooted
<
UniquePtr
<
Data
>
>
copy
(
cx
copyData
(
cx
data
&
envShape
)
)
;
if
(
!
copy
)
return
nullptr
;
if
(
!
envShape
)
{
envShape
=
getEmptyEnvironmentShape
(
cx
)
;
if
(
!
envShape
)
return
nullptr
;
}
Scope
*
scope
=
Scope
:
:
create
(
cx
ScopeKind
:
:
Module
enclosing
envShape
)
;
if
(
!
scope
)
return
nullptr
;
copy
-
>
module
.
init
(
module
)
;
moduleScope
=
&
scope
-
>
as
<
ModuleScope
>
(
)
;
moduleScope
-
>
initData
(
Move
(
copy
.
get
(
)
)
)
;
}
return
moduleScope
;
}
Shape
*
ModuleScope
:
:
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
{
const
Class
*
cls
=
&
ModuleEnvironmentObject
:
:
class_
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
ModuleScopeEnvShapeFlags
)
;
}
JSScript
*
ModuleScope
:
:
script
(
)
const
{
return
module
(
)
-
>
script
(
)
;
}
static
const
uint32_t
WasmFunctionEnvShapeFlags
=
BaseShape
:
:
NOT_EXTENSIBLE
|
BaseShape
:
:
DELEGATE
;
WasmFunctionScope
*
WasmFunctionScope
:
:
create
(
JSContext
*
cx
WasmInstanceObject
*
instance
uint32_t
funcIndex
)
{
Rooted
<
WasmFunctionScope
*
>
wasmFunctionScope
(
cx
)
;
{
Rooted
<
UniquePtr
<
Data
>
>
data
(
cx
NewEmptyScopeData
<
WasmFunctionScope
>
(
cx
)
)
;
if
(
!
data
)
return
nullptr
;
Rooted
<
Scope
*
>
enclosingScope
(
cx
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
data
-
>
instance
.
init
(
instance
)
;
data
-
>
funcIndex
=
funcIndex
;
Scope
*
scope
=
Scope
:
:
create
(
cx
ScopeKind
:
:
WasmFunction
enclosingScope
nullptr
)
;
if
(
!
scope
)
return
nullptr
;
wasmFunctionScope
=
&
scope
-
>
as
<
WasmFunctionScope
>
(
)
;
wasmFunctionScope
-
>
initData
(
Move
(
data
.
get
(
)
)
)
;
}
return
wasmFunctionScope
;
}
Shape
*
WasmFunctionScope
:
:
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
{
const
Class
*
cls
=
&
WasmFunctionCallObject
:
:
class_
;
return
EmptyEnvironmentShape
(
cx
cls
JSSLOT_FREE
(
cls
)
WasmFunctionEnvShapeFlags
)
;
}
ScopeIter
:
:
ScopeIter
(
JSScript
*
script
)
:
scope_
(
script
-
>
bodyScope
(
)
)
{
}
bool
ScopeIter
:
:
hasSyntacticEnvironment
(
)
const
{
return
scope
(
)
-
>
hasEnvironment
(
)
&
&
scope
(
)
-
>
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
BindingIter
:
:
BindingIter
(
Scope
*
scope
)
{
switch
(
scope
-
>
kind
(
)
)
{
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
init
(
scope
-
>
as
<
LexicalScope
>
(
)
.
data
(
)
scope
-
>
as
<
LexicalScope
>
(
)
.
firstFrameSlot
(
)
0
)
;
break
;
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
init
(
scope
-
>
as
<
LexicalScope
>
(
)
.
data
(
)
LOCALNO_LIMIT
IsNamedLambda
)
;
break
;
case
ScopeKind
:
:
With
:
index_
=
length_
=
0
;
MOZ_ASSERT
(
done
(
)
)
;
break
;
case
ScopeKind
:
:
Function
:
{
uint8_t
flags
=
IgnoreDestructuredFormalParameters
;
if
(
scope
-
>
as
<
FunctionScope
>
(
)
.
hasParameterExprs
(
)
)
flags
|
=
HasFormalParameterExprs
;
init
(
scope
-
>
as
<
FunctionScope
>
(
)
.
data
(
)
flags
)
;
break
;
}
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
ParameterExpressionVar
:
init
(
scope
-
>
as
<
VarScope
>
(
)
.
data
(
)
scope
-
>
as
<
VarScope
>
(
)
.
firstFrameSlot
(
)
)
;
break
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
init
(
scope
-
>
as
<
EvalScope
>
(
)
.
data
(
)
scope
-
>
kind
(
)
=
=
ScopeKind
:
:
StrictEval
)
;
break
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
init
(
scope
-
>
as
<
GlobalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Module
:
init
(
scope
-
>
as
<
ModuleScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
WasmFunction
:
init
(
scope
-
>
as
<
WasmFunctionScope
>
(
)
.
data
(
)
)
;
break
;
}
}
BindingIter
:
:
BindingIter
(
JSScript
*
script
)
:
BindingIter
(
script
-
>
bodyScope
(
)
)
{
}
void
BindingIter
:
:
init
(
LexicalScope
:
:
Data
&
data
uint32_t
firstFrameSlot
uint8_t
flags
)
{
if
(
flags
&
IsNamedLambda
)
{
init
(
0
0
0
0
0
0
CanHaveEnvironmentSlots
|
flags
firstFrameSlot
JSSLOT_FREE
(
&
LexicalEnvironmentObject
:
:
class_
)
data
.
names
data
.
length
)
;
}
else
{
init
(
0
0
0
0
0
data
.
constStart
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
|
flags
firstFrameSlot
JSSLOT_FREE
(
&
LexicalEnvironmentObject
:
:
class_
)
data
.
names
data
.
length
)
;
}
}
void
BindingIter
:
:
init
(
FunctionScope
:
:
Data
&
data
uint8_t
flags
)
{
flags
=
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
|
flags
;
if
(
!
(
flags
&
HasFormalParameterExprs
)
)
flags
|
=
CanHaveArgumentSlots
;
init
(
0
data
.
nonPositionalFormalStart
data
.
varStart
data
.
varStart
data
.
length
data
.
length
flags
0
JSSLOT_FREE
(
&
CallObject
:
:
class_
)
data
.
names
data
.
length
)
;
}
void
BindingIter
:
:
init
(
VarScope
:
:
Data
&
data
uint32_t
firstFrameSlot
)
{
init
(
0
0
0
0
data
.
length
data
.
length
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
firstFrameSlot
JSSLOT_FREE
(
&
VarEnvironmentObject
:
:
class_
)
data
.
names
data
.
length
)
;
}
void
BindingIter
:
:
init
(
GlobalScope
:
:
Data
&
data
)
{
init
(
0
0
0
data
.
varStart
data
.
letStart
data
.
constStart
CannotHaveSlots
UINT32_MAX
UINT32_MAX
data
.
names
data
.
length
)
;
}
void
BindingIter
:
:
init
(
EvalScope
:
:
Data
&
data
bool
strict
)
{
uint32_t
flags
;
uint32_t
firstFrameSlot
;
uint32_t
firstEnvironmentSlot
;
if
(
strict
)
{
flags
=
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
;
firstFrameSlot
=
0
;
firstEnvironmentSlot
=
JSSLOT_FREE
(
&
VarEnvironmentObject
:
:
class_
)
;
}
else
{
flags
=
CannotHaveSlots
;
firstFrameSlot
=
UINT32_MAX
;
firstEnvironmentSlot
=
UINT32_MAX
;
}
init
(
0
0
0
data
.
varStart
data
.
length
data
.
length
flags
firstFrameSlot
firstEnvironmentSlot
data
.
names
data
.
length
)
;
}
void
BindingIter
:
:
init
(
ModuleScope
:
:
Data
&
data
)
{
init
(
data
.
varStart
data
.
varStart
data
.
varStart
data
.
varStart
data
.
letStart
data
.
constStart
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
0
JSSLOT_FREE
(
&
ModuleEnvironmentObject
:
:
class_
)
data
.
names
data
.
length
)
;
}
void
BindingIter
:
:
init
(
WasmFunctionScope
:
:
Data
&
data
)
{
init
(
0
0
0
0
0
0
CanHaveFrameSlots
|
CanHaveEnvironmentSlots
UINT32_MAX
UINT32_MAX
data
.
names
data
.
length
)
;
}
PositionalFormalParameterIter
:
:
PositionalFormalParameterIter
(
JSScript
*
script
)
:
BindingIter
(
script
)
{
if
(
script
-
>
bodyScope
(
)
-
>
is
<
FunctionScope
>
(
)
)
init
(
script
-
>
bodyScope
(
)
-
>
as
<
FunctionScope
>
(
)
.
data
(
)
0
)
;
settle
(
)
;
}
void
js
:
:
DumpBindings
(
JSContext
*
cx
Scope
*
scopeArg
)
{
RootedScope
scope
(
cx
scopeArg
)
;
for
(
Rooted
<
BindingIter
>
bi
(
cx
BindingIter
(
scope
)
)
;
bi
;
bi
+
+
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
cx
bi
.
name
(
)
&
bytes
)
)
return
;
fprintf
(
stderr
"
%
s
%
s
"
BindingKindString
(
bi
.
kind
(
)
)
bytes
.
ptr
(
)
)
;
switch
(
bi
.
location
(
)
.
kind
(
)
)
{
case
BindingLocation
:
:
Kind
:
:
Global
:
if
(
bi
.
isTopLevelFunction
(
)
)
fprintf
(
stderr
"
global
function
\
n
"
)
;
else
fprintf
(
stderr
"
global
\
n
"
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Argument
:
fprintf
(
stderr
"
arg
slot
%
u
\
n
"
bi
.
location
(
)
.
argumentSlot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Frame
:
fprintf
(
stderr
"
frame
slot
%
u
\
n
"
bi
.
location
(
)
.
slot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Environment
:
fprintf
(
stderr
"
env
slot
%
u
\
n
"
bi
.
location
(
)
.
slot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
NamedLambdaCallee
:
fprintf
(
stderr
"
named
lambda
callee
\
n
"
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Import
:
fprintf
(
stderr
"
import
\
n
"
)
;
break
;
}
}
}
static
JSAtom
*
GetFrameSlotNameInScope
(
Scope
*
scope
uint32_t
slot
)
{
for
(
BindingIter
bi
(
scope
)
;
bi
;
bi
+
+
)
{
BindingLocation
loc
=
bi
.
location
(
)
;
if
(
loc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Frame
&
&
loc
.
slot
(
)
=
=
slot
)
return
bi
.
name
(
)
;
}
return
nullptr
;
}
JSAtom
*
js
:
:
FrameSlotName
(
JSScript
*
script
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
IsLocalOp
(
JSOp
(
*
pc
)
)
)
;
uint32_t
slot
=
GET_LOCALNO
(
pc
)
;
MOZ_ASSERT
(
slot
<
script
-
>
nfixed
(
)
)
;
if
(
JSAtom
*
name
=
GetFrameSlotNameInScope
(
script
-
>
bodyScope
(
)
slot
)
)
return
name
;
if
(
script
-
>
functionHasExtraBodyVarScope
(
)
)
{
if
(
JSAtom
*
name
=
GetFrameSlotNameInScope
(
script
-
>
functionExtraBodyVarScope
(
)
slot
)
)
return
name
;
}
for
(
ScopeIter
si
(
script
-
>
innermostScope
(
pc
)
)
;
si
;
si
+
+
)
{
if
(
!
si
.
scope
(
)
-
>
is
<
LexicalScope
>
(
)
)
continue
;
LexicalScope
&
lexicalScope
=
si
.
scope
(
)
-
>
as
<
LexicalScope
>
(
)
;
if
(
slot
<
lexicalScope
.
firstFrameSlot
(
)
)
continue
;
if
(
slot
>
=
lexicalScope
.
nextFrameSlot
(
)
)
break
;
if
(
JSAtom
*
name
=
GetFrameSlotNameInScope
(
&
lexicalScope
slot
)
)
return
name
;
}
MOZ_CRASH
(
"
Frame
slot
not
found
"
)
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
Scope
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
+
get
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
