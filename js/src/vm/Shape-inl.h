#
ifndef
vm_Shape_inl_h
#
define
vm_Shape_inl_h
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PropertyResult
.
h
"
#
include
"
gc
/
GCContext
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
vm
/
PropMap
-
inl
.
h
"
namespace
js
{
template
<
class
ObjectSubclass
>
inline
bool
SharedShape
:
:
ensureInitialCustomShape
(
JSContext
*
cx
Handle
<
ObjectSubclass
*
>
obj
)
{
static_assert
(
std
:
:
is_base_of_v
<
JSObject
ObjectSubclass
>
"
ObjectSubclass
must
be
a
subclass
of
JSObject
"
)
;
if
(
!
obj
-
>
empty
(
)
)
{
return
true
;
}
Rooted
<
Shape
*
>
emptyShape
(
cx
obj
-
>
shape
(
)
)
;
Rooted
<
SharedShape
*
>
shape
(
cx
ObjectSubclass
:
:
assignInitialShape
(
cx
obj
)
)
;
if
(
!
shape
)
{
return
false
;
}
MOZ_ASSERT
(
!
obj
-
>
empty
(
)
)
;
SharedShape
:
:
insertInitialShape
(
cx
shape
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
PropMap
*
NativeShape
:
:
lookup
(
JSContext
*
cx
PropertyKey
key
uint32_t
*
index
)
{
uint32_t
len
=
propMapLength
(
)
;
return
len
>
0
?
nativePropMap_
-
>
lookup
(
cx
len
key
index
)
:
nullptr
;
}
MOZ_ALWAYS_INLINE
PropMap
*
NativeShape
:
:
lookupPure
(
PropertyKey
key
uint32_t
*
index
)
{
uint32_t
len
=
propMapLength
(
)
;
return
len
>
0
?
nativePropMap_
-
>
lookupPure
(
len
key
index
)
:
nullptr
;
}
inline
void
Shape
:
:
purgeCache
(
JS
:
:
GCContext
*
gcx
)
{
if
(
cache_
.
isShapeSetForAdd
(
)
)
{
gcx
-
>
delete_
(
this
cache_
.
toShapeSetForAdd
(
)
MemoryUse
:
:
ShapeSetForAdd
)
;
}
cache_
.
setNone
(
)
;
}
inline
void
Shape
:
:
finalize
(
JS
:
:
GCContext
*
gcx
)
{
if
(
!
cache_
.
isNone
(
)
)
{
purgeCache
(
gcx
)
;
}
}
inline
SharedPropMap
*
SharedShape
:
:
propMapMaybeForwarded
(
)
const
{
MOZ_ASSERT
(
isShared
(
)
)
;
PropMap
*
propMap
=
nativePropMap_
;
return
propMap
?
MaybeForwarded
(
propMap
)
-
>
asShared
(
)
:
nullptr
;
}
static
inline
JS
:
:
PropertyAttributes
GetPropertyAttributes
(
JSObject
*
obj
PropertyResult
prop
)
{
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
if
(
prop
.
isDenseElement
(
)
)
{
return
obj
-
>
as
<
NativeObject
>
(
)
.
getElementsHeader
(
)
-
>
elementAttributes
(
)
;
}
if
(
prop
.
isTypedArrayElement
(
)
)
{
return
{
JS
:
:
PropertyAttribute
:
:
Configurable
JS
:
:
PropertyAttribute
:
:
Enumerable
JS
:
:
PropertyAttribute
:
:
Writable
}
;
}
return
prop
.
propertyInfo
(
)
.
propAttributes
(
)
;
}
}
#
endif
