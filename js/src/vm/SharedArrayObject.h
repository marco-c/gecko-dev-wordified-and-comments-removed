#
ifndef
vm_SharedArrayObject_h
#
define
vm_SharedArrayObject_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
namespace
js
{
class
FutexWaiter
;
class
WasmSharedArrayRawBuffer
;
class
SharedArrayRawBuffer
{
protected
:
bool
isWasm_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
refcount_
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
SequentiallyConsistent
>
length_
;
FutexWaiter
*
waiters_
=
nullptr
;
protected
:
SharedArrayRawBuffer
(
bool
isWasm
uint8_t
*
buffer
size_t
length
)
:
isWasm_
(
isWasm
)
refcount_
(
1
)
length_
(
length
)
{
MOZ_ASSERT
(
buffer
=
=
dataPointerShared
(
)
)
;
}
public
:
static
SharedArrayRawBuffer
*
Allocate
(
size_t
length
)
;
inline
WasmSharedArrayRawBuffer
*
toWasmBuffer
(
)
;
FutexWaiter
*
waiters
(
)
const
{
return
waiters_
;
}
void
setWaiters
(
FutexWaiter
*
waiters
)
{
waiters_
=
waiters
;
}
inline
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
;
size_t
volatileByteLength
(
)
const
{
return
length_
;
}
bool
isWasm
(
)
const
{
return
isWasm_
;
}
uint32_t
refcount
(
)
const
{
return
refcount_
;
}
[
[
nodiscard
]
]
bool
addReference
(
)
;
void
dropReference
(
)
;
static
int32_t
liveBuffers
(
)
;
}
;
class
WasmSharedArrayRawBuffer
:
public
SharedArrayRawBuffer
{
private
:
Mutex
growLock_
MOZ_UNANNOTATED
;
wasm
:
:
IndexType
indexType_
;
wasm
:
:
Pages
clampedMaxPages_
;
wasm
:
:
Pages
sourceMaxPages_
;
size_t
mappedSize_
;
uint8_t
*
basePointer
(
)
{
SharedMem
<
uint8_t
*
>
p
=
dataPointerShared
(
)
-
gc
:
:
SystemPageSize
(
)
;
MOZ_ASSERT
(
p
.
asValue
(
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
return
p
.
unwrap
(
)
;
}
protected
:
WasmSharedArrayRawBuffer
(
uint8_t
*
buffer
size_t
length
wasm
:
:
IndexType
indexType
wasm
:
:
Pages
clampedMaxPages
wasm
:
:
Pages
sourceMaxPages
size_t
mappedSize
)
:
SharedArrayRawBuffer
(
true
buffer
length
)
growLock_
(
mutexid
:
:
SharedArrayGrow
)
indexType_
(
indexType
)
clampedMaxPages_
(
clampedMaxPages
)
sourceMaxPages_
(
sourceMaxPages
)
mappedSize_
(
mappedSize
)
{
}
public
:
friend
class
SharedArrayRawBuffer
;
class
Lock
;
friend
class
Lock
;
class
MOZ_RAII
Lock
{
WasmSharedArrayRawBuffer
*
buf
;
public
:
explicit
Lock
(
WasmSharedArrayRawBuffer
*
buf
)
:
buf
(
buf
)
{
buf
-
>
growLock_
.
lock
(
)
;
}
~
Lock
(
)
{
buf
-
>
growLock_
.
unlock
(
)
;
}
}
;
static
WasmSharedArrayRawBuffer
*
AllocateWasm
(
wasm
:
:
IndexType
indexType
wasm
:
:
Pages
initialPages
wasm
:
:
Pages
clampedMaxPages
const
mozilla
:
:
Maybe
<
wasm
:
:
Pages
>
&
sourceMaxPages
const
mozilla
:
:
Maybe
<
size_t
>
&
mappedSize
)
;
static
const
WasmSharedArrayRawBuffer
*
fromDataPtr
(
const
uint8_t
*
dataPtr
)
{
return
reinterpret_cast
<
const
WasmSharedArrayRawBuffer
*
>
(
dataPtr
-
sizeof
(
WasmSharedArrayRawBuffer
)
)
;
}
wasm
:
:
IndexType
wasmIndexType
(
)
const
{
return
indexType_
;
}
wasm
:
:
Pages
volatileWasmPages
(
)
const
{
return
wasm
:
:
Pages
:
:
fromByteLengthExact
(
length_
)
;
}
wasm
:
:
Pages
wasmClampedMaxPages
(
)
const
{
return
clampedMaxPages_
;
}
wasm
:
:
Pages
wasmSourceMaxPages
(
)
const
{
return
sourceMaxPages_
;
}
size_t
wasmMappedSize
(
)
const
{
return
mappedSize_
;
}
void
tryGrowMaxPagesInPlace
(
wasm
:
:
Pages
deltaMaxPages
)
;
bool
wasmGrowToPagesInPlace
(
const
Lock
&
wasm
:
:
IndexType
t
wasm
:
:
Pages
newPages
)
;
}
;
inline
WasmSharedArrayRawBuffer
*
SharedArrayRawBuffer
:
:
toWasmBuffer
(
)
{
MOZ_ASSERT
(
isWasm
(
)
)
;
return
static_cast
<
WasmSharedArrayRawBuffer
*
>
(
this
)
;
}
inline
SharedMem
<
uint8_t
*
>
SharedArrayRawBuffer
:
:
dataPointerShared
(
)
const
{
uint8_t
*
ptr
=
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
SharedArrayRawBuffer
*
>
(
this
)
)
;
ptr
+
=
isWasm
(
)
?
sizeof
(
WasmSharedArrayRawBuffer
)
:
sizeof
(
SharedArrayRawBuffer
)
;
return
SharedMem
<
uint8_t
*
>
:
:
shared
(
ptr
)
;
}
class
SharedArrayBufferObject
:
public
ArrayBufferObjectMaybeShared
{
static
bool
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
public
:
static
const
uint8_t
RAWBUF_SLOT
=
0
;
static
const
uint8_t
LENGTH_SLOT
=
1
;
static_assert
(
LENGTH_SLOT
=
=
ArrayBufferObject
:
:
BYTE_LENGTH_SLOT
"
JIT
code
assumes
the
same
slot
is
used
for
the
length
"
)
;
static
const
uint8_t
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
bool
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
isOriginalByteLengthGetter
(
Native
native
)
{
return
native
=
=
byteLengthGetter
;
}
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
size_t
length
HandleObject
proto
=
nullptr
)
;
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
size_t
length
HandleObject
proto
=
nullptr
)
;
static
void
Finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
;
static
void
copyData
(
Handle
<
ArrayBufferObjectMaybeShared
*
>
toBuffer
size_t
toIndex
Handle
<
ArrayBufferObjectMaybeShared
*
>
fromBuffer
size_t
fromIndex
size_t
count
)
;
SharedArrayRawBuffer
*
rawBufferObject
(
)
const
;
WasmSharedArrayRawBuffer
*
rawWasmBufferObject
(
)
const
{
return
rawBufferObject
(
)
-
>
toWasmBuffer
(
)
;
}
uintptr_t
globalID
(
)
const
{
return
dataPointerShared
(
)
.
asValue
(
)
;
}
size_t
byteLength
(
)
const
{
return
size_t
(
getFixedSlot
(
LENGTH_SLOT
)
.
toPrivate
(
)
)
;
}
bool
isWasm
(
)
const
{
return
rawBufferObject
(
)
-
>
isWasm
(
)
;
}
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
{
return
rawBufferObject
(
)
-
>
dataPointerShared
(
)
;
}
static
SharedArrayBufferObject
*
createFromNewRawBuffer
(
JSContext
*
cx
WasmSharedArrayRawBuffer
*
buffer
size_t
initialSize
)
;
wasm
:
:
Pages
volatileWasmPages
(
)
const
{
return
rawWasmBufferObject
(
)
-
>
volatileWasmPages
(
)
;
}
wasm
:
:
Pages
wasmClampedMaxPages
(
)
const
{
return
rawWasmBufferObject
(
)
-
>
wasmClampedMaxPages
(
)
;
}
wasm
:
:
Pages
wasmSourceMaxPages
(
)
const
{
return
rawWasmBufferObject
(
)
-
>
wasmSourceMaxPages
(
)
;
}
size_t
wasmMappedSize
(
)
const
{
return
rawWasmBufferObject
(
)
-
>
wasmMappedSize
(
)
;
}
private
:
[
[
nodiscard
]
]
bool
acceptRawBuffer
(
SharedArrayRawBuffer
*
buffer
size_t
length
)
;
void
dropRawBuffer
(
)
;
}
;
using
RootedSharedArrayBufferObject
=
Rooted
<
SharedArrayBufferObject
*
>
;
using
HandleSharedArrayBufferObject
=
Handle
<
SharedArrayBufferObject
*
>
;
using
MutableHandleSharedArrayBufferObject
=
MutableHandle
<
SharedArrayBufferObject
*
>
;
}
#
endif
