#
ifndef
vm_SharedArrayObject_h
#
define
vm_SharedArrayObject_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
namespace
js
{
class
FutexWaiter
;
class
SharedArrayRawBuffer
{
private
:
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
refcount_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
>
length_
;
Mutex
growLock_
;
uint32_t
maxSize_
;
size_t
mappedSize_
;
bool
preparedForWasm_
;
FutexWaiter
*
waiters_
;
uint8_t
*
basePointer
(
)
{
SharedMem
<
uint8_t
*
>
p
=
dataPointerShared
(
)
-
gc
:
:
SystemPageSize
(
)
;
MOZ_ASSERT
(
p
.
asValue
(
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
return
p
.
unwrap
(
)
;
}
protected
:
SharedArrayRawBuffer
(
uint8_t
*
buffer
uint32_t
length
uint32_t
maxSize
size_t
mappedSize
bool
preparedForWasm
)
:
refcount_
(
1
)
length_
(
length
)
growLock_
(
mutexid
:
:
SharedArrayGrow
)
maxSize_
(
maxSize
)
mappedSize_
(
mappedSize
)
preparedForWasm_
(
preparedForWasm
)
waiters_
(
nullptr
)
{
MOZ_ASSERT
(
buffer
=
=
dataPointerShared
(
)
)
;
}
public
:
class
Lock
;
friend
class
Lock
;
class
MOZ_STACK_CLASS
Lock
{
SharedArrayRawBuffer
*
buf
;
public
:
explicit
Lock
(
SharedArrayRawBuffer
*
buf
)
:
buf
(
buf
)
{
buf
-
>
growLock_
.
lock
(
)
;
}
~
Lock
(
)
{
buf
-
>
growLock_
.
unlock
(
)
;
}
}
;
static
SharedArrayRawBuffer
*
Allocate
(
uint32_t
length
const
mozilla
:
:
Maybe
<
uint32_t
>
&
maxSize
const
mozilla
:
:
Maybe
<
size_t
>
&
mappedSize
)
;
FutexWaiter
*
waiters
(
)
const
{
return
waiters_
;
}
void
setWaiters
(
FutexWaiter
*
waiters
)
{
waiters_
=
waiters
;
}
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
{
uint8_t
*
ptr
=
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
SharedArrayRawBuffer
*
>
(
this
)
)
;
return
SharedMem
<
uint8_t
*
>
:
:
shared
(
ptr
+
sizeof
(
SharedArrayRawBuffer
)
)
;
}
static
const
SharedArrayRawBuffer
*
fromDataPtr
(
const
uint8_t
*
dataPtr
)
{
return
reinterpret_cast
<
const
SharedArrayRawBuffer
*
>
(
dataPtr
-
sizeof
(
SharedArrayRawBuffer
)
)
;
}
uint32_t
volatileByteLength
(
)
const
{
return
length_
;
}
uint32_t
maxSize
(
)
const
{
return
maxSize_
;
}
size_t
mappedSize
(
)
const
{
return
mappedSize_
;
}
bool
isWasm
(
)
const
{
return
preparedForWasm_
;
}
void
tryGrowMaxSizeInPlace
(
uint32_t
deltaMaxSize
)
;
bool
wasmGrowToSizeInPlace
(
const
Lock
&
uint32_t
newLength
)
;
uint32_t
refcount
(
)
const
{
return
refcount_
;
}
MOZ_MUST_USE
bool
addReference
(
)
;
void
dropReference
(
)
;
static
int32_t
liveBuffers
(
)
;
}
;
class
SharedArrayBufferObject
:
public
ArrayBufferObjectMaybeShared
{
static
bool
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
public
:
static
const
uint8_t
RAWBUF_SLOT
=
0
;
static
const
uint8_t
LENGTH_SLOT
=
1
;
static
const
uint8_t
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
bool
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
uint32_t
length
HandleObject
proto
=
nullptr
)
;
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
uint32_t
length
HandleObject
proto
=
nullptr
)
;
static
void
Finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
)
;
static
void
copyData
(
Handle
<
SharedArrayBufferObject
*
>
toBuffer
uint32_t
toIndex
Handle
<
SharedArrayBufferObject
*
>
fromBuffer
uint32_t
fromIndex
uint32_t
count
)
;
SharedArrayRawBuffer
*
rawBufferObject
(
)
const
;
uintptr_t
globalID
(
)
const
{
return
dataPointerShared
(
)
.
asValue
(
)
;
}
uint32_t
byteLength
(
)
const
{
return
getReservedSlot
(
LENGTH_SLOT
)
.
toPrivateUint32
(
)
;
}
bool
isWasm
(
)
const
{
return
rawBufferObject
(
)
-
>
isWasm
(
)
;
}
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
{
return
rawBufferObject
(
)
-
>
dataPointerShared
(
)
;
}
static
SharedArrayBufferObject
*
createFromNewRawBuffer
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
uint32_t
initialSize
)
;
mozilla
:
:
Maybe
<
uint32_t
>
wasmMaxSize
(
)
const
{
return
mozilla
:
:
Some
(
rawBufferObject
(
)
-
>
maxSize
(
)
)
;
}
size_t
wasmMappedSize
(
)
const
{
return
rawBufferObject
(
)
-
>
mappedSize
(
)
;
}
private
:
MOZ_MUST_USE
bool
acceptRawBuffer
(
SharedArrayRawBuffer
*
buffer
uint32_t
length
)
;
void
dropRawBuffer
(
)
;
}
;
bool
IsSharedArrayBuffer
(
HandleValue
v
)
;
bool
IsSharedArrayBuffer
(
HandleObject
o
)
;
bool
IsSharedArrayBuffer
(
JSObject
*
o
)
;
SharedArrayBufferObject
&
AsSharedArrayBuffer
(
HandleObject
o
)
;
typedef
Rooted
<
SharedArrayBufferObject
*
>
RootedSharedArrayBufferObject
;
typedef
Handle
<
SharedArrayBufferObject
*
>
HandleSharedArrayBufferObject
;
typedef
MutableHandle
<
SharedArrayBufferObject
*
>
MutableHandleSharedArrayBufferObject
;
}
#
endif
