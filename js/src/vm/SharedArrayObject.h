#
ifndef
vm_SharedArrayObject_h
#
define
vm_SharedArrayObject_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
wasm
/
WasmPages
.
h
"
namespace
js
{
class
FutexWaiter
;
class
SharedArrayRawBuffer
{
private
:
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
refcount_
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
SequentiallyConsistent
>
length_
;
Mutex
growLock_
;
wasm
:
:
Pages
wasmMaxPages_
;
size_t
mappedSize_
;
bool
preparedForWasm_
;
FutexWaiter
*
waiters_
;
uint8_t
*
basePointer
(
)
{
SharedMem
<
uint8_t
*
>
p
=
dataPointerShared
(
)
-
gc
:
:
SystemPageSize
(
)
;
MOZ_ASSERT
(
p
.
asValue
(
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
return
p
.
unwrap
(
)
;
}
protected
:
SharedArrayRawBuffer
(
uint8_t
*
buffer
size_t
length
wasm
:
:
Pages
wasmMaxPages
size_t
mappedSize
bool
preparedForWasm
)
:
refcount_
(
1
)
length_
(
length
)
growLock_
(
mutexid
:
:
SharedArrayGrow
)
wasmMaxPages_
(
wasmMaxPages
)
mappedSize_
(
mappedSize
)
preparedForWasm_
(
preparedForWasm
)
waiters_
(
nullptr
)
{
MOZ_ASSERT
(
buffer
=
=
dataPointerShared
(
)
)
;
}
static
SharedArrayRawBuffer
*
AllocateInternal
(
size_t
length
const
mozilla
:
:
Maybe
<
wasm
:
:
Pages
>
&
wasmMaxPages
const
mozilla
:
:
Maybe
<
size_t
>
&
wasmMappedSize
)
;
public
:
class
Lock
;
friend
class
Lock
;
class
MOZ_STACK_CLASS
Lock
{
SharedArrayRawBuffer
*
buf
;
public
:
explicit
Lock
(
SharedArrayRawBuffer
*
buf
)
:
buf
(
buf
)
{
buf
-
>
growLock_
.
lock
(
)
;
}
~
Lock
(
)
{
buf
-
>
growLock_
.
unlock
(
)
;
}
}
;
static
SharedArrayRawBuffer
*
Allocate
(
size_t
length
)
;
static
SharedArrayRawBuffer
*
AllocateWasm
(
wasm
:
:
Pages
initialPages
const
mozilla
:
:
Maybe
<
wasm
:
:
Pages
>
&
maxPages
const
mozilla
:
:
Maybe
<
size_t
>
&
mappedSize
)
;
FutexWaiter
*
waiters
(
)
const
{
return
waiters_
;
}
void
setWaiters
(
FutexWaiter
*
waiters
)
{
waiters_
=
waiters
;
}
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
{
uint8_t
*
ptr
=
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
SharedArrayRawBuffer
*
>
(
this
)
)
;
return
SharedMem
<
uint8_t
*
>
:
:
shared
(
ptr
+
sizeof
(
SharedArrayRawBuffer
)
)
;
}
static
const
SharedArrayRawBuffer
*
fromDataPtr
(
const
uint8_t
*
dataPtr
)
{
return
reinterpret_cast
<
const
SharedArrayRawBuffer
*
>
(
dataPtr
-
sizeof
(
SharedArrayRawBuffer
)
)
;
}
size_t
volatileByteLength
(
)
const
{
return
length_
;
}
wasm
:
:
Pages
volatileWasmPages
(
)
const
{
return
wasm
:
:
Pages
:
:
fromByteLengthExact
(
length_
)
;
}
wasm
:
:
Pages
wasmMaxPages
(
)
const
{
return
wasmMaxPages_
;
}
size_t
mappedSize
(
)
const
{
return
mappedSize_
;
}
bool
isWasm
(
)
const
{
return
preparedForWasm_
;
}
void
tryGrowMaxPagesInPlace
(
wasm
:
:
Pages
deltaMaxPages
)
;
bool
wasmGrowToPagesInPlace
(
const
Lock
&
wasm
:
:
Pages
newPages
)
;
uint32_t
refcount
(
)
const
{
return
refcount_
;
}
[
[
nodiscard
]
]
bool
addReference
(
)
;
void
dropReference
(
)
;
static
int32_t
liveBuffers
(
)
;
}
;
class
SharedArrayBufferObject
:
public
ArrayBufferObjectMaybeShared
{
static
bool
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
public
:
static
const
uint8_t
RAWBUF_SLOT
=
0
;
static
const
uint8_t
LENGTH_SLOT
=
1
;
static_assert
(
LENGTH_SLOT
=
=
ArrayBufferObject
:
:
BYTE_LENGTH_SLOT
"
JIT
code
assumes
the
same
slot
is
used
for
the
length
"
)
;
static
const
uint8_t
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
bool
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
isOriginalByteLengthGetter
(
Native
native
)
{
return
native
=
=
byteLengthGetter
;
}
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
size_t
length
HandleObject
proto
=
nullptr
)
;
static
SharedArrayBufferObject
*
New
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
size_t
length
HandleObject
proto
=
nullptr
)
;
static
void
Finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
)
;
static
void
copyData
(
Handle
<
SharedArrayBufferObject
*
>
toBuffer
size_t
toIndex
Handle
<
SharedArrayBufferObject
*
>
fromBuffer
size_t
fromIndex
size_t
count
)
;
SharedArrayRawBuffer
*
rawBufferObject
(
)
const
;
uintptr_t
globalID
(
)
const
{
return
dataPointerShared
(
)
.
asValue
(
)
;
}
size_t
byteLength
(
)
const
{
return
size_t
(
getFixedSlot
(
LENGTH_SLOT
)
.
toPrivate
(
)
)
;
}
bool
isWasm
(
)
const
{
return
rawBufferObject
(
)
-
>
isWasm
(
)
;
}
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
{
return
rawBufferObject
(
)
-
>
dataPointerShared
(
)
;
}
static
SharedArrayBufferObject
*
createFromNewRawBuffer
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
size_t
initialSize
)
;
wasm
:
:
Pages
volatileWasmPages
(
)
const
{
return
rawBufferObject
(
)
-
>
volatileWasmPages
(
)
;
}
wasm
:
:
Pages
wasmMaxPages
(
)
const
{
return
rawBufferObject
(
)
-
>
wasmMaxPages
(
)
;
}
size_t
wasmMappedSize
(
)
const
{
return
rawBufferObject
(
)
-
>
mappedSize
(
)
;
}
private
:
[
[
nodiscard
]
]
bool
acceptRawBuffer
(
SharedArrayRawBuffer
*
buffer
size_t
length
)
;
void
dropRawBuffer
(
)
;
}
;
using
RootedSharedArrayBufferObject
=
Rooted
<
SharedArrayBufferObject
*
>
;
using
HandleSharedArrayBufferObject
=
Handle
<
SharedArrayBufferObject
*
>
;
using
MutableHandleSharedArrayBufferObject
=
MutableHandle
<
SharedArrayBufferObject
*
>
;
}
#
endif
