#
ifndef
vm_JitActivation_h
#
define
vm_JitActivation_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
ifdef
CHECK_OSIPOINT_REGISTERS
#
include
"
jit
/
Registers
.
h
"
#
endif
#
include
"
jit
/
RematerializedFrame
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
Activation
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmFrameIter
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSTracer
;
namespace
js
{
namespace
jit
{
class
BailoutFrameInfo
;
class
JitActivation
:
public
Activation
{
uint8_t
*
packedExitFP_
;
uint32_t
encodedWasmExitReason_
;
JitActivation
*
prevJitActivation_
;
using
RematerializedFrameVector
=
JS
:
:
GCVector
<
js
:
:
UniquePtr
<
RematerializedFrame
>
>
;
using
RematerializedFrameTable
=
js
:
:
HashMap
<
uint8_t
*
RematerializedFrameVector
>
;
js
:
:
UniquePtr
<
RematerializedFrameTable
>
rematerializedFrames_
;
using
IonRecoveryMap
=
Vector
<
RInstructionResults
1
>
;
IonRecoveryMap
ionRecovery_
;
BailoutFrameInfo
*
bailoutData_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
lastProfilingFrame_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
lastProfilingCallSite_
;
static_assert
(
sizeof
(
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
)
=
=
sizeof
(
void
*
)
"
Atomic
should
have
same
memory
format
as
underlying
type
.
"
)
;
mozilla
:
:
Maybe
<
wasm
:
:
TrapData
>
wasmTrapData_
;
void
clearRematerializedFrames
(
)
;
#
ifdef
CHECK_OSIPOINT_REGISTERS
protected
:
uint32_t
checkRegs_
=
0
;
RegisterDump
regs_
;
#
endif
public
:
explicit
JitActivation
(
JSContext
*
cx
)
;
~
JitActivation
(
)
;
bool
isProfiling
(
)
const
{
return
true
;
}
JitActivation
*
prevJitActivation
(
)
const
{
return
prevJitActivation_
;
}
static
size_t
offsetOfPrevJitActivation
(
)
{
return
offsetof
(
JitActivation
prevJitActivation_
)
;
}
bool
hasExitFP
(
)
const
{
return
!
!
packedExitFP_
;
}
uint8_t
*
jsOrWasmExitFP
(
)
const
{
if
(
hasWasmExitFP
(
)
)
{
return
wasm
:
:
Frame
:
:
toJitEntryCaller
(
packedExitFP_
)
;
}
return
packedExitFP_
;
}
static
size_t
offsetOfPackedExitFP
(
)
{
return
offsetof
(
JitActivation
packedExitFP_
)
;
}
bool
hasJSExitFP
(
)
const
{
return
!
hasWasmExitFP
(
)
;
}
uint8_t
*
jsExitFP
(
)
const
{
MOZ_ASSERT
(
hasJSExitFP
(
)
)
;
return
packedExitFP_
;
}
void
setJSExitFP
(
uint8_t
*
fp
)
{
packedExitFP_
=
fp
;
}
#
ifdef
CHECK_OSIPOINT_REGISTERS
void
setCheckRegs
(
bool
check
)
{
checkRegs_
=
check
;
}
static
size_t
offsetOfCheckRegs
(
)
{
return
offsetof
(
JitActivation
checkRegs_
)
;
}
static
size_t
offsetOfRegs
(
)
{
return
offsetof
(
JitActivation
regs_
)
;
}
#
endif
RematerializedFrame
*
getRematerializedFrame
(
JSContext
*
cx
const
JSJitFrameIter
&
iter
size_t
inlineDepth
=
0
)
;
RematerializedFrame
*
lookupRematerializedFrame
(
uint8_t
*
top
size_t
inlineDepth
=
0
)
;
void
removeRematerializedFramesFromDebugger
(
JSContext
*
cx
uint8_t
*
top
)
;
bool
hasRematerializedFrame
(
uint8_t
*
top
size_t
inlineDepth
=
0
)
{
return
!
!
lookupRematerializedFrame
(
top
inlineDepth
)
;
}
void
removeRematerializedFrame
(
uint8_t
*
top
)
;
void
traceRematerializedFrames
(
JSTracer
*
trc
)
;
bool
registerIonFrameRecovery
(
RInstructionResults
&
&
results
)
;
RInstructionResults
*
maybeIonFrameRecovery
(
JitFrameLayout
*
fp
)
;
void
removeIonFrameRecovery
(
JitFrameLayout
*
fp
)
;
void
traceIonRecovery
(
JSTracer
*
trc
)
;
const
BailoutFrameInfo
*
bailoutData
(
)
const
{
return
bailoutData_
;
}
void
setBailoutData
(
BailoutFrameInfo
*
bailoutData
)
;
void
cleanBailoutData
(
)
;
static
size_t
offsetOfLastProfilingFrame
(
)
{
return
offsetof
(
JitActivation
lastProfilingFrame_
)
;
}
void
*
lastProfilingFrame
(
)
{
return
lastProfilingFrame_
;
}
void
setLastProfilingFrame
(
void
*
ptr
)
{
lastProfilingFrame_
=
ptr
;
}
static
size_t
offsetOfLastProfilingCallSite
(
)
{
return
offsetof
(
JitActivation
lastProfilingCallSite_
)
;
}
void
*
lastProfilingCallSite
(
)
{
return
lastProfilingCallSite_
;
}
void
setLastProfilingCallSite
(
void
*
ptr
)
{
lastProfilingCallSite_
=
ptr
;
}
bool
hasWasmExitFP
(
)
const
{
return
wasm
:
:
Frame
:
:
isExitOrJitEntryFP
(
packedExitFP_
)
;
}
wasm
:
:
Frame
*
wasmExitFP
(
)
const
{
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
return
reinterpret_cast
<
wasm
:
:
Frame
*
>
(
wasm
:
:
Frame
:
:
toJitEntryCaller
(
packedExitFP_
)
)
;
}
wasm
:
:
TlsData
*
wasmExitTls
(
)
const
{
return
wasm
:
:
GetNearestEffectiveTls
(
wasmExitFP
(
)
)
;
}
void
setWasmExitFP
(
const
wasm
:
:
Frame
*
fp
)
{
if
(
fp
)
{
MOZ_ASSERT
(
!
wasm
:
:
Frame
:
:
isExitOrJitEntryFP
(
fp
)
)
;
packedExitFP_
=
wasm
:
:
Frame
:
:
addExitOrJitEntryFPTag
(
fp
)
;
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
}
else
{
packedExitFP_
=
nullptr
;
}
}
wasm
:
:
ExitReason
wasmExitReason
(
)
const
{
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
return
wasm
:
:
ExitReason
:
:
Decode
(
encodedWasmExitReason_
)
;
}
static
size_t
offsetOfEncodedWasmExitReason
(
)
{
return
offsetof
(
JitActivation
encodedWasmExitReason_
)
;
}
void
startWasmTrap
(
wasm
:
:
Trap
trap
uint32_t
bytecodeOffset
const
wasm
:
:
RegisterState
&
state
)
;
void
finishWasmTrap
(
)
;
bool
isWasmTrapping
(
)
const
{
return
!
!
wasmTrapData_
;
}
const
wasm
:
:
TrapData
&
wasmTrapData
(
)
{
return
*
wasmTrapData_
;
}
}
;
class
JitActivationIterator
:
public
ActivationIterator
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
activation_
-
>
isJit
(
)
)
{
ActivationIterator
:
:
operator
+
+
(
)
;
}
}
public
:
explicit
JitActivationIterator
(
JSContext
*
cx
)
:
ActivationIterator
(
cx
)
{
settle
(
)
;
}
JitActivationIterator
&
operator
+
+
(
)
{
ActivationIterator
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
}
}
#
endif
