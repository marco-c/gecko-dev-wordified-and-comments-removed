#
include
"
vm
/
PlainObject
-
inl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
ds
/
IdValuePair
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
Handle
;
using
JS
:
:
Rooted
;
PlainObject
*
js
:
:
CreateThisForFunction
(
JSContext
*
cx
Handle
<
JSFunction
*
>
callee
Handle
<
JSObject
*
>
newTarget
NewObjectKind
newKind
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
callee
-
>
realm
(
)
)
;
MOZ_ASSERT
(
!
callee
-
>
constructorNeedsUninitializedThis
(
)
)
;
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototypeFromConstructor
(
cx
newTarget
JSProto_Object
&
proto
)
)
{
return
nullptr
;
}
PlainObject
*
res
;
if
(
proto
)
{
js
:
:
gc
:
:
AllocKind
allocKind
=
NewObjectGCKind
(
)
;
res
=
NewObjectWithGivenProtoAndKinds
<
PlainObject
>
(
cx
proto
allocKind
newKind
)
;
}
else
{
res
=
NewBuiltinClassInstanceWithKind
<
PlainObject
>
(
cx
newKind
)
;
}
MOZ_ASSERT_IF
(
res
res
-
>
nonCCWRealm
(
)
=
=
callee
-
>
realm
(
)
)
;
return
res
;
}
#
ifdef
DEBUG
void
PlainObject
:
:
assertHasNoNonWritableOrAccessorPropExclProto
(
)
const
{
static
constexpr
size_t
MaxCount
=
8
;
size_t
count
=
0
;
PropertyName
*
protoName
=
runtimeFromMainThread
(
)
-
>
commonNames
-
>
proto
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
if
(
iter
-
>
key
(
)
.
isAtom
(
protoName
)
)
{
continue
;
}
MOZ_ASSERT
(
iter
-
>
isDataProperty
(
)
)
;
MOZ_ASSERT
(
iter
-
>
writable
(
)
)
;
count
+
+
;
if
(
count
>
MaxCount
)
{
return
;
}
}
}
#
endif
JS
:
:
Result
<
PlainObject
*
JS
:
:
OOM
>
PlainObject
:
:
createWithTemplateFromDifferentRealm
(
JSContext
*
cx
HandlePlainObject
templateObject
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
!
=
templateObject
-
>
realm
(
)
"
Use
createWithTemplate
(
)
for
same
-
realm
objects
"
)
;
MOZ_ASSERT
(
templateObject
-
>
staticPrototype
(
)
=
=
nullptr
)
;
MOZ_ASSERT
(
!
templateObject
-
>
shape
(
)
-
>
isDictionary
(
)
)
;
TaggedProto
proto
=
TaggedProto
(
nullptr
)
;
Shape
*
templateShape
=
templateObject
-
>
shape
(
)
;
Rooted
<
SharedPropMap
*
>
map
(
cx
templateShape
-
>
propMap
(
)
-
>
asShared
(
)
)
;
RootedShape
shape
(
cx
SharedShape
:
:
getInitialOrPropMapShape
(
cx
&
PlainObject
:
:
class_
cx
-
>
realm
(
)
proto
templateShape
-
>
numFixedSlots
(
)
map
templateShape
-
>
propMapLength
(
)
templateShape
-
>
objectFlags
(
)
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
return
createWithShape
(
cx
shape
)
;
}
static
bool
AddPlainObjectProperties
(
JSContext
*
cx
HandlePlainObject
obj
IdValuePair
*
properties
size_t
nproperties
)
{
RootedId
propid
(
cx
)
;
RootedValue
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
nproperties
;
i
+
+
)
{
propid
=
properties
[
i
]
.
id
;
value
=
properties
[
i
]
.
value
;
if
(
!
NativeDefineDataProperty
(
cx
obj
propid
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
return
true
;
}
PlainObject
*
js
:
:
NewPlainObjectWithProperties
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
{
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
nproperties
)
;
RootedPlainObject
obj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
allocKind
newKind
)
)
;
if
(
!
obj
|
|
!
AddPlainObjectProperties
(
cx
obj
properties
nproperties
)
)
{
return
nullptr
;
}
return
obj
;
}
