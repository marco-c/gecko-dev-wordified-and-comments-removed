#
ifndef
vm_ShapedObject_h
#
define
vm_ShapedObject_h
#
include
"
vm
/
JSObject
.
h
"
namespace
js
{
namespace
jit
{
class
CacheIRCompiler
;
}
class
ShapedObject
:
public
JSObject
{
protected
:
MOZ_ALWAYS_INLINE
const
GCPtrShape
&
shapeRef
(
)
const
{
return
*
reinterpret_cast
<
const
GCPtrShape
*
>
(
&
(
this
-
>
shapeOrExpando_
)
)
;
}
MOZ_ALWAYS_INLINE
GCPtrShape
&
shapeRef
(
)
{
return
*
reinterpret_cast
<
GCPtrShape
*
>
(
&
(
this
-
>
shapeOrExpando_
)
)
;
}
MOZ_ALWAYS_INLINE
GCPtrShape
*
shapePtr
(
)
{
return
reinterpret_cast
<
GCPtrShape
*
>
(
&
(
this
-
>
shapeOrExpando_
)
)
;
}
public
:
void
initShape
(
Shape
*
shape
)
{
MOZ_ASSERT
(
zone
(
)
=
=
shape
-
>
zone
(
)
)
;
shapeRef
(
)
.
init
(
shape
)
;
}
void
setShape
(
Shape
*
shape
)
{
MOZ_ASSERT
(
zone
(
)
=
=
shape
-
>
zone
(
)
)
;
shapeRef
(
)
=
shape
;
}
Shape
*
shape
(
)
const
{
return
shapeRef
(
)
;
}
void
traceShape
(
JSTracer
*
trc
)
{
TraceEdge
(
trc
shapePtr
(
)
"
shape
"
)
;
}
static
JSObject
*
fromShapeFieldPointer
(
uintptr_t
p
)
{
return
reinterpret_cast
<
JSObject
*
>
(
p
-
ShapedObject
:
:
offsetOfShape
(
)
)
;
}
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
friend
class
js
:
:
jit
:
:
CacheIRCompiler
;
static
constexpr
size_t
offsetOfShape
(
)
{
static_assert
(
offsetOfShapeOrExpando
(
)
=
=
offsetof
(
shadow
:
:
Object
shape
)
"
shadow
shape
must
match
actual
shape
"
)
;
return
offsetOfShapeOrExpando
(
)
;
}
}
;
}
#
endif
