#
ifndef
vm_SavedStacks_h
#
define
vm_SavedStacks_h
#
include
"
mozilla
/
FastBernoulliTrial
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsmath
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
class
SavedStacks
{
friend
class
SavedFrame
;
friend
JSObject
*
SavedStacksMetadataCallback
(
JSContext
*
cx
JSObject
*
target
)
;
friend
bool
JS
:
:
ubi
:
:
ConstructSavedFrameStackSlow
(
JSContext
*
cx
JS
:
:
ubi
:
:
StackFrame
&
ubiFrame
MutableHandleObject
outSavedFrameStack
)
;
public
:
SavedStacks
(
)
:
frames
(
)
bernoulliSeeded
(
false
)
bernoulli
(
1
.
0
0x59fdad7f6b4cc573
0x91adf38db96a9354
)
creatingSavedFrame
(
false
)
{
}
bool
init
(
)
;
bool
initialized
(
)
const
{
return
frames
.
initialized
(
)
;
}
bool
saveCurrentStack
(
JSContext
*
cx
MutableHandleSavedFrame
frame
unsigned
maxFrameCount
=
0
)
;
bool
copyAsyncStack
(
JSContext
*
cx
HandleObject
asyncStack
HandleString
asyncCause
MutableHandleSavedFrame
adoptedStack
unsigned
maxFrameCount
=
0
)
;
void
sweep
(
)
;
void
trace
(
JSTracer
*
trc
)
;
uint32_t
count
(
)
;
void
clear
(
)
;
void
chooseSamplingProbability
(
JSCompartment
*
)
;
void
setRNGState
(
uint64_t
state0
uint64_t
state1
)
{
bernoulli
.
setRandomState
(
state0
state1
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
SavedFrame
:
:
Set
frames
;
bool
bernoulliSeeded
;
mozilla
:
:
FastBernoulliTrial
bernoulli
;
bool
creatingSavedFrame
;
struct
MOZ_RAII
AutoReentrancyGuard
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
SavedStacks
&
stacks
;
explicit
AutoReentrancyGuard
(
SavedStacks
&
stacks
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
stacks
(
stacks
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
stacks
.
creatingSavedFrame
=
true
;
}
~
AutoReentrancyGuard
(
)
{
stacks
.
creatingSavedFrame
=
false
;
}
}
;
bool
insertFrames
(
JSContext
*
cx
FrameIter
&
iter
MutableHandleSavedFrame
frame
unsigned
maxFrameCount
=
0
)
;
bool
adoptAsyncStack
(
JSContext
*
cx
HandleSavedFrame
asyncStack
HandleString
asyncCause
MutableHandleSavedFrame
adoptedStack
unsigned
maxFrameCount
)
;
SavedFrame
*
getOrCreateSavedFrame
(
JSContext
*
cx
SavedFrame
:
:
HandleLookup
lookup
)
;
SavedFrame
*
createFrameFromLookup
(
JSContext
*
cx
SavedFrame
:
:
HandleLookup
lookup
)
;
struct
PCKey
{
PCKey
(
JSScript
*
script
jsbytecode
*
pc
)
:
script
(
script
)
pc
(
pc
)
{
}
RelocatablePtrScript
script
;
jsbytecode
*
pc
;
void
trace
(
JSTracer
*
trc
)
{
}
bool
needsSweep
(
)
{
return
IsAboutToBeFinalized
(
&
script
)
;
}
}
;
public
:
struct
LocationValue
{
LocationValue
(
)
:
source
(
nullptr
)
line
(
0
)
column
(
0
)
{
}
LocationValue
(
JSAtom
*
source
size_t
line
uint32_t
column
)
:
source
(
source
)
line
(
line
)
column
(
column
)
{
}
void
trace
(
JSTracer
*
trc
)
{
if
(
source
)
TraceEdge
(
trc
&
source
"
SavedStacks
:
:
LocationValue
:
:
source
"
)
;
}
bool
needsSweep
(
)
{
MOZ_ASSERT
(
source
)
;
MOZ_ASSERT
(
!
IsAboutToBeFinalized
(
&
source
)
)
;
return
true
;
}
RelocatablePtrAtom
source
;
size_t
line
;
uint32_t
column
;
}
;
template
<
typename
Outer
>
struct
LocationValueOperations
{
JSAtom
*
source
(
)
const
{
return
loc
(
)
.
source
;
}
size_t
line
(
)
const
{
return
loc
(
)
.
line
;
}
uint32_t
column
(
)
const
{
return
loc
(
)
.
column
;
}
private
:
const
LocationValue
&
loc
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
get
(
)
;
}
}
;
template
<
typename
Outer
>
struct
MutableLocationValueOperations
:
public
LocationValueOperations
<
Outer
>
{
void
setSource
(
JSAtom
*
v
)
{
loc
(
)
.
source
=
v
;
}
void
setLine
(
size_t
v
)
{
loc
(
)
.
line
=
v
;
}
void
setColumn
(
uint32_t
v
)
{
loc
(
)
.
column
=
v
;
}
private
:
LocationValue
&
loc
(
)
{
return
static_cast
<
Outer
*
>
(
this
)
-
>
get
(
)
;
}
}
;
private
:
struct
PCLocationHasher
:
public
DefaultHasher
<
PCKey
>
{
using
ScriptPtrHasher
=
DefaultHasher
<
JSScript
*
>
;
using
BytecodePtrHasher
=
DefaultHasher
<
jsbytecode
*
>
;
static
HashNumber
hash
(
const
PCKey
&
key
)
{
return
mozilla
:
:
AddToHash
(
ScriptPtrHasher
:
:
hash
(
key
.
script
)
BytecodePtrHasher
:
:
hash
(
key
.
pc
)
)
;
}
static
bool
match
(
const
PCKey
&
l
const
PCKey
&
k
)
{
return
ScriptPtrHasher
:
:
match
(
l
.
script
k
.
script
)
&
&
BytecodePtrHasher
:
:
match
(
l
.
pc
k
.
pc
)
;
}
}
;
using
PCLocationMap
=
GCHashMap
<
PCKey
LocationValue
PCLocationHasher
SystemAllocPolicy
>
;
PCLocationMap
pcLocationMap
;
bool
getLocation
(
JSContext
*
cx
const
FrameIter
&
iter
MutableHandle
<
LocationValue
>
locationp
)
;
}
;
JSObject
*
SavedStacksMetadataCallback
(
JSContext
*
cx
JSObject
*
target
)
;
template
<
>
class
RootedBase
<
SavedStacks
:
:
LocationValue
>
:
public
SavedStacks
:
:
MutableLocationValueOperations
<
JS
:
:
Rooted
<
SavedStacks
:
:
LocationValue
>
>
{
}
;
template
<
>
class
MutableHandleBase
<
SavedStacks
:
:
LocationValue
>
:
public
SavedStacks
:
:
MutableLocationValueOperations
<
JS
:
:
MutableHandle
<
SavedStacks
:
:
LocationValue
>
>
{
}
;
}
#
endif
