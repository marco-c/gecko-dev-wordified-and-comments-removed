#
ifndef
vm_SharedStencil_h
#
define
vm_SharedStencil_h
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
namespace
js
{
struct
TryNote
{
uint32_t
kind_
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
TryNote
(
uint32_t
kind
uint32_t
stackDepth
uint32_t
start
uint32_t
length
)
:
kind_
(
kind
)
stackDepth
(
stackDepth
)
start
(
start
)
length
(
length
)
{
}
TryNote
(
)
=
default
;
TryNoteKind
kind
(
)
const
{
return
TryNoteKind
(
kind_
)
;
}
bool
isLoop
(
)
const
{
switch
(
kind
(
)
)
{
case
TryNoteKind
:
:
Loop
:
case
TryNoteKind
:
:
ForIn
:
case
TryNoteKind
:
:
ForOf
:
return
true
;
case
TryNoteKind
:
:
Catch
:
case
TryNoteKind
:
:
Finally
:
case
TryNoteKind
:
:
ForOfIterClose
:
case
TryNoteKind
:
:
Destructuring
:
return
false
;
}
MOZ_CRASH
(
"
Unexpected
try
note
kind
"
)
;
}
}
;
struct
ScopeNote
{
static
const
uint32_t
NoScopeIndex
=
UINT32_MAX
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
uint32_t
index
=
0
;
uint32_t
start
=
0
;
uint32_t
length
=
0
;
uint32_t
parent
=
0
;
}
;
template
<
typename
EnumType
>
class
ScriptFlagBase
{
protected
:
uint32_t
flags_
=
0
;
public
:
ScriptFlagBase
(
)
=
default
;
explicit
ScriptFlagBase
(
uint32_t
rawFlags
)
:
flags_
(
rawFlags
)
{
}
MOZ_MUST_USE
bool
hasFlag
(
EnumType
flag
)
const
{
return
flags_
&
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
)
{
flags_
|
=
static_cast
<
uint32_t
>
(
flag
)
;
}
void
clearFlag
(
EnumType
flag
)
{
flags_
&
=
~
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
operator
uint32_t
(
)
const
{
return
flags_
;
}
ScriptFlagBase
&
operator
|
=
(
const
uint32_t
rhs
)
{
flags_
|
=
rhs
;
return
*
this
;
}
}
;
class
ImmutableScriptFlags
:
public
ScriptFlagBase
<
ImmutableScriptFlagsEnum
>
{
public
:
using
ScriptFlagBase
<
ImmutableScriptFlagsEnum
>
:
:
ScriptFlagBase
;
void
operator
=
(
uint32_t
flag
)
{
flags_
=
flag
;
}
static
ImmutableScriptFlags
fromCompileOptions
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
{
ImmutableScriptFlags
isf
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NoScriptRval
options
.
noScriptRval
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
SelfHosted
options
.
selfHostingMode
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
return
isf
;
}
;
static
ImmutableScriptFlags
fromCompileOptions
(
const
JS
:
:
TransitiveCompileOptions
&
options
)
{
ImmutableScriptFlags
isf
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NoScriptRval
false
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
SelfHosted
options
.
selfHostingMode
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
TreatAsRunOnce
false
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
return
isf
;
}
;
}
;
class
MutableScriptFlags
:
public
ScriptFlagBase
<
MutableScriptFlagsEnum
>
{
public
:
MutableScriptFlags
(
)
=
default
;
MutableScriptFlags
&
operator
&
=
(
const
uint32_t
rhs
)
{
flags_
&
=
rhs
;
return
*
this
;
}
}
;
class
alignas
(
uint32_t
)
ImmutableScriptData
final
{
private
:
using
Offset
=
uint32_t
;
Offset
optArrayOffset_
=
0
;
uint32_t
codeLength_
=
0
;
public
:
uint32_t
mainOffset
=
0
;
uint32_t
nfixed
=
0
;
uint32_t
nslots
=
0
;
uint32_t
bodyScopeIndex
=
0
;
uint32_t
numICEntries
=
0
;
uint16_t
funLength
=
0
;
uint16_t
numBytecodeTypeSets
=
0
;
private
:
struct
Flags
{
uint8_t
resumeOffsetsEndIndex
:
2
;
uint8_t
scopeNotesEndIndex
:
2
;
uint8_t
tryNotesEndIndex
:
2
;
uint8_t
_unused
:
2
;
}
;
static_assert
(
sizeof
(
Flags
)
=
=
sizeof
(
uint8_t
)
"
Structure
packing
is
broken
"
)
;
size_t
flagOffset
(
)
const
{
return
offsetOfCode
(
)
-
sizeof
(
Flags
)
;
}
size_t
codeOffset
(
)
const
{
return
offsetOfCode
(
)
;
}
size_t
noteOffset
(
)
const
{
return
offsetOfCode
(
)
+
codeLength_
;
}
size_t
optionalOffsetsOffset
(
)
const
{
unsigned
numOffsets
=
flags
(
)
.
tryNotesEndIndex
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
scopeNotesEndIndex
)
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
resumeOffsetsEndIndex
)
;
return
optArrayOffset_
-
(
numOffsets
*
sizeof
(
Offset
)
)
;
}
size_t
resumeOffsetsOffset
(
)
const
{
return
optArrayOffset_
;
}
size_t
scopeNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
resumeOffsetsEndIndex
)
;
}
size_t
tryNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
scopeNotesEndIndex
)
;
}
size_t
endOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
tryNotesEndIndex
)
;
}
static
size_t
AllocationSize
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
template
<
typename
T
>
T
*
offsetToPointer
(
size_t
offset
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
return
reinterpret_cast
<
T
*
>
(
base
+
offset
)
;
}
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
void
initOptionalArrays
(
size_t
*
cursor
Flags
*
flags
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
ImmutableScriptData
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
void
setOptionalOffset
(
int
index
Offset
offset
)
{
MOZ_ASSERT
(
index
>
0
)
;
MOZ_ASSERT
(
offset
!
=
optArrayOffset_
"
Do
not
store
implicit
offset
"
)
;
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
=
offset
;
}
Offset
getOptionalOffset
(
int
index
)
const
{
if
(
index
=
=
0
)
{
return
optArrayOffset_
;
}
ImmutableScriptData
*
this_
=
const_cast
<
ImmutableScriptData
*
>
(
this
)
;
return
this_
-
>
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
;
}
public
:
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
mainOffset
uint32_t
nfixed
uint32_t
nslots
uint32_t
bodyScopeIndex
uint32_t
numICEntries
uint32_t
numBytecodeTypeSets
bool
isFunction
uint16_t
funLength
mozilla
:
:
Span
<
const
jsbytecode
>
code
mozilla
:
:
Span
<
const
SrcNote
>
notes
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
mozilla
:
:
Span
<
const
ScopeNote
>
scopeNotes
mozilla
:
:
Span
<
const
TryNote
>
tryNotes
)
;
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
static
constexpr
size_t
CodeNoteAlign
=
sizeof
(
uint32_t
)
;
static
uint32_t
ComputeNotePadding
(
uint32_t
codeLength
uint32_t
noteLength
)
{
uint32_t
flagLength
=
sizeof
(
Flags
)
;
uint32_t
nullLength
=
CodeNoteAlign
-
(
flagLength
+
codeLength
+
noteLength
)
%
CodeNoteAlign
;
MOZ_ASSERT
(
nullLength
>
=
1
)
;
return
nullLength
;
}
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
(
)
const
{
size_t
allocSize
=
endOffset
(
)
;
return
mozilla
:
:
MakeSpan
(
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
allocSize
)
;
}
private
:
Flags
&
flagsRef
(
)
{
return
*
offsetToPointer
<
Flags
>
(
flagOffset
(
)
)
;
}
const
Flags
&
flags
(
)
const
{
return
const_cast
<
ImmutableScriptData
*
>
(
this
)
-
>
flagsRef
(
)
;
}
public
:
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
offsetToPointer
<
jsbytecode
>
(
codeOffset
(
)
)
;
}
mozilla
:
:
Span
<
jsbytecode
>
codeSpan
(
)
{
return
{
code
(
)
codeLength
(
)
}
;
}
uint32_t
noteLength
(
)
const
{
return
optionalOffsetsOffset
(
)
-
noteOffset
(
)
;
}
SrcNote
*
notes
(
)
{
return
offsetToPointer
<
SrcNote
>
(
noteOffset
(
)
)
;
}
mozilla
:
:
Span
<
SrcNote
>
notesSpan
(
)
{
return
{
notes
(
)
noteLength
(
)
}
;
}
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
uint32_t
>
(
resumeOffsetsOffset
(
)
)
offsetToPointer
<
uint32_t
>
(
scopeNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
ScopeNote
>
(
scopeNotesOffset
(
)
)
offsetToPointer
<
ScopeNote
>
(
tryNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
TryNote
>
tryNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
TryNote
>
(
tryNotesOffset
(
)
)
offsetToPointer
<
TryNote
>
(
endOffset
(
)
)
)
;
}
static
constexpr
size_t
offsetOfCode
(
)
{
return
sizeof
(
ImmutableScriptData
)
+
sizeof
(
Flags
)
;
}
static
constexpr
size_t
offsetOfResumeOffsetsOffset
(
)
{
return
offsetof
(
ImmutableScriptData
optArrayOffset_
)
;
}
static
constexpr
size_t
offsetOfNfixed
(
)
{
return
offsetof
(
ImmutableScriptData
nfixed
)
;
}
static
constexpr
size_t
offsetOfNslots
(
)
{
return
offsetof
(
ImmutableScriptData
nslots
)
;
}
static
constexpr
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
ImmutableScriptData
funLength
)
;
}
ImmutableScriptData
(
const
ImmutableScriptData
&
)
=
delete
;
ImmutableScriptData
&
operator
=
(
const
ImmutableScriptData
&
)
=
delete
;
}
;
}
#
endif
