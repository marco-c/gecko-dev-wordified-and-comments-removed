#
ifndef
vm_SharedStencil_h
#
define
vm_SharedStencil_h
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
#
include
"
vm
/
Xdr
.
h
"
namespace
js
{
class
GCThingIndexType
;
class
GCThingIndex
:
public
frontend
:
:
TypedIndex
<
GCThingIndexType
>
{
using
Base
=
frontend
:
:
TypedIndex
<
GCThingIndexType
>
;
using
Base
:
:
Base
;
public
:
static
constexpr
GCThingIndex
outermostScopeIndex
(
)
{
return
GCThingIndex
(
0
)
;
}
static
constexpr
GCThingIndex
invalid
(
)
{
return
GCThingIndex
(
UINT32_MAX
)
;
}
GCThingIndex
next
(
)
const
{
return
GCThingIndex
(
index
+
1
)
;
}
}
;
struct
TryNote
{
uint32_t
kind_
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
TryNote
(
uint32_t
kind
uint32_t
stackDepth
uint32_t
start
uint32_t
length
)
:
kind_
(
kind
)
stackDepth
(
stackDepth
)
start
(
start
)
length
(
length
)
{
}
TryNote
(
)
=
default
;
TryNoteKind
kind
(
)
const
{
return
TryNoteKind
(
kind_
)
;
}
bool
isLoop
(
)
const
{
switch
(
kind
(
)
)
{
case
TryNoteKind
:
:
Loop
:
case
TryNoteKind
:
:
ForIn
:
case
TryNoteKind
:
:
ForOf
:
return
true
;
case
TryNoteKind
:
:
Catch
:
case
TryNoteKind
:
:
Finally
:
case
TryNoteKind
:
:
ForOfIterClose
:
case
TryNoteKind
:
:
Destructuring
:
return
false
;
}
MOZ_CRASH
(
"
Unexpected
try
note
kind
"
)
;
}
}
;
struct
ScopeNote
{
static
constexpr
GCThingIndex
NoScopeIndex
=
GCThingIndex
:
:
invalid
(
)
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
GCThingIndex
index
;
uint32_t
start
=
0
;
uint32_t
length
=
0
;
uint32_t
parent
=
0
;
}
;
struct
SourceExtent
{
SourceExtent
(
)
=
default
;
SourceExtent
(
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
)
:
sourceStart
(
sourceStart
)
sourceEnd
(
sourceEnd
)
toStringStart
(
toStringStart
)
toStringEnd
(
toStringEnd
)
lineno
(
lineno
)
column
(
column
)
{
}
static
SourceExtent
makeGlobalExtent
(
uint32_t
len
)
{
return
SourceExtent
(
0
len
0
len
1
0
)
;
}
static
SourceExtent
makeGlobalExtent
(
uint32_t
len
uint32_t
lineno
uint32_t
column
)
{
return
SourceExtent
(
0
len
0
len
lineno
column
)
;
}
uint32_t
sourceStart
=
0
;
uint32_t
sourceEnd
=
0
;
uint32_t
toStringStart
=
0
;
uint32_t
toStringEnd
=
0
;
uint32_t
lineno
=
1
;
uint32_t
column
=
0
;
}
;
template
<
typename
EnumType
>
class
ScriptFlagBase
{
protected
:
uint32_t
flags_
=
0
;
public
:
ScriptFlagBase
(
)
=
default
;
explicit
ScriptFlagBase
(
uint32_t
rawFlags
)
:
flags_
(
rawFlags
)
{
}
MOZ_MUST_USE
bool
hasFlag
(
EnumType
flag
)
const
{
return
flags_
&
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
)
{
flags_
|
=
static_cast
<
uint32_t
>
(
flag
)
;
}
void
clearFlag
(
EnumType
flag
)
{
flags_
&
=
~
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
operator
uint32_t
(
)
const
{
return
flags_
;
}
ScriptFlagBase
&
operator
|
=
(
const
uint32_t
rhs
)
{
flags_
|
=
rhs
;
return
*
this
;
}
}
;
class
ImmutableScriptFlags
:
public
ScriptFlagBase
<
ImmutableScriptFlagsEnum
>
{
public
:
using
ScriptFlagBase
<
ImmutableScriptFlagsEnum
>
:
:
ScriptFlagBase
;
void
operator
=
(
uint32_t
flag
)
{
flags_
=
flag
;
}
}
;
class
MutableScriptFlags
:
public
ScriptFlagBase
<
MutableScriptFlagsEnum
>
{
public
:
MutableScriptFlags
(
)
=
default
;
MutableScriptFlags
&
operator
&
=
(
const
uint32_t
rhs
)
{
flags_
&
=
rhs
;
return
*
this
;
}
}
;
class
alignas
(
uint32_t
)
ImmutableScriptData
final
:
public
TrailingArray
{
private
:
Offset
optArrayOffset_
=
0
;
uint32_t
codeLength_
=
0
;
public
:
uint32_t
mainOffset
=
0
;
uint32_t
nfixed
=
0
;
uint32_t
nslots
=
0
;
GCThingIndex
bodyScopeIndex
;
uint32_t
numICEntries
=
0
;
uint16_t
funLength
=
0
;
uint16_t
numBytecodeTypeSets
=
0
;
private
:
struct
Flags
{
uint8_t
resumeOffsetsEndIndex
:
2
;
uint8_t
scopeNotesEndIndex
:
2
;
uint8_t
tryNotesEndIndex
:
2
;
uint8_t
_unused
:
2
;
}
;
static_assert
(
sizeof
(
Flags
)
=
=
sizeof
(
uint8_t
)
"
Structure
packing
is
broken
"
)
;
Offset
flagOffset
(
)
const
{
return
offsetOfCode
(
)
-
sizeof
(
Flags
)
;
}
Offset
codeOffset
(
)
const
{
return
offsetOfCode
(
)
;
}
Offset
noteOffset
(
)
const
{
return
offsetOfCode
(
)
+
codeLength_
;
}
Offset
optionalOffsetsOffset
(
)
const
{
unsigned
numOffsets
=
flags
(
)
.
tryNotesEndIndex
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
scopeNotesEndIndex
)
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
resumeOffsetsEndIndex
)
;
return
optArrayOffset_
-
(
numOffsets
*
sizeof
(
Offset
)
)
;
}
Offset
resumeOffsetsOffset
(
)
const
{
return
optArrayOffset_
;
}
Offset
scopeNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
resumeOffsetsEndIndex
)
;
}
Offset
tryNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
scopeNotesEndIndex
)
;
}
Offset
endOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
tryNotesEndIndex
)
;
}
void
initOptionalArrays
(
Offset
*
cursor
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
ImmutableScriptData
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
void
setOptionalOffset
(
int
index
Offset
offset
)
{
MOZ_ASSERT
(
index
>
0
)
;
MOZ_ASSERT
(
offset
!
=
optArrayOffset_
"
Do
not
store
implicit
offset
"
)
;
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
=
offset
;
}
Offset
getOptionalOffset
(
int
index
)
const
{
if
(
index
=
=
0
)
{
return
optArrayOffset_
;
}
ImmutableScriptData
*
this_
=
const_cast
<
ImmutableScriptData
*
>
(
this
)
;
return
this_
-
>
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
;
}
public
:
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
mainOffset
uint32_t
nfixed
uint32_t
nslots
GCThingIndex
bodyScopeIndex
uint32_t
numICEntries
uint32_t
numBytecodeTypeSets
bool
isFunction
uint16_t
funLength
mozilla
:
:
Span
<
const
jsbytecode
>
code
mozilla
:
:
Span
<
const
SrcNote
>
notes
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
mozilla
:
:
Span
<
const
ScopeNote
>
scopeNotes
mozilla
:
:
Span
<
const
TryNote
>
tryNotes
)
;
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
static
constexpr
size_t
CodeNoteAlign
=
sizeof
(
uint32_t
)
;
static
uint32_t
ComputeNotePadding
(
uint32_t
codeLength
uint32_t
noteLength
)
{
uint32_t
flagLength
=
sizeof
(
Flags
)
;
uint32_t
nullLength
=
CodeNoteAlign
-
(
flagLength
+
codeLength
+
noteLength
)
%
CodeNoteAlign
;
MOZ_ASSERT
(
nullLength
>
=
1
)
;
return
nullLength
;
}
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
(
)
const
{
size_t
allocSize
=
endOffset
(
)
;
return
mozilla
:
:
Span
{
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
allocSize
}
;
}
private
:
Flags
&
flagsRef
(
)
{
return
*
offsetToPointer
<
Flags
>
(
flagOffset
(
)
)
;
}
const
Flags
&
flags
(
)
const
{
return
const_cast
<
ImmutableScriptData
*
>
(
this
)
-
>
flagsRef
(
)
;
}
public
:
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
offsetToPointer
<
jsbytecode
>
(
codeOffset
(
)
)
;
}
mozilla
:
:
Span
<
jsbytecode
>
codeSpan
(
)
{
return
{
code
(
)
codeLength
(
)
}
;
}
uint32_t
noteLength
(
)
const
{
return
numElements
<
SrcNote
>
(
noteOffset
(
)
optionalOffsetsOffset
(
)
)
;
}
SrcNote
*
notes
(
)
{
return
offsetToPointer
<
SrcNote
>
(
noteOffset
(
)
)
;
}
mozilla
:
:
Span
<
SrcNote
>
notesSpan
(
)
{
return
{
notes
(
)
noteLength
(
)
}
;
}
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
uint32_t
>
(
resumeOffsetsOffset
(
)
)
offsetToPointer
<
uint32_t
>
(
scopeNotesOffset
(
)
)
}
;
}
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
ScopeNote
>
(
scopeNotesOffset
(
)
)
offsetToPointer
<
ScopeNote
>
(
tryNotesOffset
(
)
)
}
;
}
mozilla
:
:
Span
<
TryNote
>
tryNotes
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
TryNote
>
(
tryNotesOffset
(
)
)
offsetToPointer
<
TryNote
>
(
endOffset
(
)
)
}
;
}
static
constexpr
size_t
offsetOfCode
(
)
{
return
sizeof
(
ImmutableScriptData
)
+
sizeof
(
Flags
)
;
}
static
constexpr
size_t
offsetOfResumeOffsetsOffset
(
)
{
static_assert
(
sizeof
(
Offset
)
=
=
sizeof
(
uint32_t
)
"
JIT
expect
Offset
to
be
uint32_t
"
)
;
return
offsetof
(
ImmutableScriptData
optArrayOffset_
)
;
}
static
constexpr
size_t
offsetOfNfixed
(
)
{
return
offsetof
(
ImmutableScriptData
nfixed
)
;
}
static
constexpr
size_t
offsetOfNslots
(
)
{
return
offsetof
(
ImmutableScriptData
nslots
)
;
}
static
constexpr
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
ImmutableScriptData
funLength
)
;
}
ImmutableScriptData
(
const
ImmutableScriptData
&
)
=
delete
;
ImmutableScriptData
&
operator
=
(
const
ImmutableScriptData
&
)
=
delete
;
}
;
class
RuntimeScriptData
{
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
>
refCount_
=
{
}
;
js
:
:
UniquePtr
<
ImmutableScriptData
>
isd_
=
nullptr
;
friend
class
:
:
JSScript
;
public
:
RuntimeScriptData
(
)
=
default
;
struct
Hasher
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
AddRef
(
)
{
refCount_
+
+
;
}
void
Release
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
uint32_t
remain
=
-
-
refCount_
;
if
(
remain
=
=
0
)
{
isd_
=
nullptr
;
js_free
(
this
)
;
}
}
static
constexpr
size_t
offsetOfISD
(
)
{
return
offsetof
(
RuntimeScriptData
isd_
)
;
}
private
:
static
RuntimeScriptData
*
create
(
JSContext
*
cx
)
;
public
:
static
RuntimeScriptData
*
createWith
(
JSContext
*
cx
js
:
:
UniquePtr
<
ImmutableScriptData
>
&
&
isd
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
mallocSizeOf
(
isd_
.
get
(
)
)
;
}
RuntimeScriptData
(
const
RuntimeScriptData
&
)
=
delete
;
RuntimeScriptData
&
operator
=
(
const
RuntimeScriptData
&
)
=
delete
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
RefPtr
<
RuntimeScriptData
>
&
rsd
)
;
static
bool
shareScriptData
(
JSContext
*
cx
RefPtr
<
RuntimeScriptData
>
&
rsd
)
;
size_t
immutableDataLength
(
)
const
{
return
isd_
-
>
immutableData
(
)
.
Length
(
)
;
}
}
;
struct
RuntimeScriptData
:
:
Hasher
{
using
Lookup
=
RefPtr
<
RuntimeScriptData
>
;
static
mozilla
:
:
HashNumber
hash
(
const
Lookup
&
l
)
{
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
=
l
-
>
isd_
-
>
immutableData
(
)
;
return
mozilla
:
:
HashBytes
(
immutableData
.
data
(
)
immutableData
.
size
(
)
)
;
}
static
bool
match
(
RuntimeScriptData
*
entry
const
Lookup
&
lookup
)
{
return
(
entry
-
>
isd_
-
>
immutableData
(
)
=
=
lookup
-
>
isd_
-
>
immutableData
(
)
)
;
}
}
;
using
RuntimeScriptDataTable
=
mozilla
:
:
HashSet
<
RuntimeScriptData
*
RuntimeScriptData
:
:
Hasher
SystemAllocPolicy
>
;
}
#
endif
