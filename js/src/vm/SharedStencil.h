#
ifndef
vm_SharedStencil_h
#
define
vm_SharedStencil_h
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
vm
/
TryNoteKind
.
h
"
namespace
js
{
struct
TryNote
{
uint32_t
kind
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
TryNote
(
uint32_t
kind
uint32_t
stackDepth
uint32_t
start
uint32_t
length
)
:
kind
(
kind
)
stackDepth
(
stackDepth
)
start
(
start
)
length
(
length
)
{
}
TryNote
(
)
=
default
;
bool
isLoop
(
)
const
{
switch
(
kind
)
{
case
JSTRY_LOOP
:
case
JSTRY_FOR_IN
:
case
JSTRY_FOR_OF
:
return
true
;
case
JSTRY_CATCH
:
case
JSTRY_FINALLY
:
case
JSTRY_FOR_OF_ITERCLOSE
:
case
JSTRY_DESTRUCTURING
:
return
false
;
}
MOZ_CRASH
(
"
Unexpected
try
note
kind
"
)
;
}
}
;
struct
ScopeNote
{
static
const
uint32_t
NoScopeIndex
=
UINT32_MAX
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
uint32_t
index
=
0
;
uint32_t
start
=
0
;
uint32_t
length
=
0
;
uint32_t
parent
=
0
;
}
;
template
<
typename
EnumType
>
class
ScriptFlagBase
{
friend
class
js
:
:
BaseScript
;
protected
:
uint32_t
flags_
=
0
;
public
:
MOZ_MUST_USE
bool
hasFlag
(
EnumType
flag
)
const
{
return
flags_
&
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
)
{
flags_
|
=
static_cast
<
uint32_t
>
(
flag
)
;
}
void
clearFlag
(
EnumType
flag
)
{
flags_
&
=
~
static_cast
<
uint32_t
>
(
flag
)
;
}
void
setFlag
(
EnumType
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
operator
uint32_t
(
)
const
{
return
flags_
;
}
}
;
enum
class
ImmutableScriptFlagsEnum
:
uint32_t
{
NoScriptRval
=
1
<
<
0
SelfHosted
=
1
<
<
1
TreatAsRunOnce
=
1
<
<
2
ForceStrict
=
1
<
<
3
Strict
=
1
<
<
4
BindingsAccessedDynamically
=
1
<
<
5
FunHasExtensibleScope
=
1
<
<
6
HasCallSiteObj
=
1
<
<
7
HasModuleGoal
=
1
<
<
8
FunctionHasThisBinding
=
1
<
<
9
HasMappedArgsObj
=
1
<
<
10
HasInnerFunctions
=
1
<
<
11
NeedsHomeObject
=
1
<
<
12
IsDerivedClassConstructor
=
1
<
<
13
IsLikelyConstructorWrapper
=
1
<
<
14
IsGenerator
=
1
<
<
15
IsAsync
=
1
<
<
16
HasRest
=
1
<
<
17
ArgumentsHasVarBinding
=
1
<
<
18
IsForEval
=
1
<
<
19
IsModule
=
1
<
<
20
ShouldDeclareArguments
=
1
<
<
21
IsFunction
=
1
<
<
22
HasDirectEval
=
1
<
<
23
HasNonSyntacticScope
=
1
<
<
24
FunctionHasExtraBodyVarScope
=
1
<
<
25
NeedsFunctionEnvironmentObjects
=
1
<
<
26
}
;
class
ImmutableScriptFlags
:
public
ScriptFlagBase
<
ImmutableScriptFlagsEnum
>
{
public
:
ImmutableScriptFlags
(
)
=
default
;
void
static_asserts
(
)
{
static_assert
(
sizeof
(
ImmutableScriptFlags
)
=
=
sizeof
(
flags_
)
"
No
extra
members
allowed
"
)
;
static_assert
(
offsetof
(
ImmutableScriptFlags
flags_
)
=
=
0
"
Required
for
JIT
flag
access
"
)
;
}
void
operator
=
(
uint32_t
flag
)
{
flags_
=
flag
;
}
static
ImmutableScriptFlags
fromCompileOptions
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
{
ImmutableScriptFlags
isf
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NoScriptRval
options
.
noScriptRval
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
SelfHosted
options
.
selfHostingMode
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
return
isf
;
}
;
static
ImmutableScriptFlags
fromCompileOptions
(
const
JS
:
:
TransitiveCompileOptions
&
options
)
{
ImmutableScriptFlags
isf
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NoScriptRval
false
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
SelfHosted
options
.
selfHostingMode
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
TreatAsRunOnce
false
)
;
isf
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
return
isf
;
}
;
}
;
enum
class
MutableScriptFlagsEnum
:
uint32_t
{
WarmupResets_MASK
=
0xFF
HasRunOnce
=
1
<
<
9
HasBeenCloned
=
1
<
<
10
HasScriptCounts
=
1
<
<
12
HasDebugScript
=
1
<
<
13
AllowRelazify
=
1
<
<
14
FailedBoundsCheck
=
1
<
<
15
FailedShapeGuard
=
1
<
<
16
HadFrequentBailouts
=
1
<
<
17
HadOverflowBailout
=
1
<
<
18
BaselineDisabled
=
1
<
<
19
IonDisabled
=
1
<
<
20
Uninlineable
=
1
<
<
21
InvalidatedIdempotentCache
=
1
<
<
22
FailedLexicalCheck
=
1
<
<
23
NeedsArgsAnalysis
=
1
<
<
24
NeedsArgsObj
=
1
<
<
25
SpewEnabled
=
1
<
<
26
}
;
class
MutableScriptFlags
:
public
ScriptFlagBase
<
MutableScriptFlagsEnum
>
{
public
:
MutableScriptFlags
(
)
=
default
;
void
static_asserts
(
)
{
static_assert
(
sizeof
(
MutableScriptFlags
)
=
=
sizeof
(
flags_
)
"
No
extra
members
allowed
"
)
;
static_assert
(
offsetof
(
MutableScriptFlags
flags_
)
=
=
0
"
Required
for
JIT
flag
access
"
)
;
}
MutableScriptFlags
&
operator
&
=
(
const
uint32_t
rhs
)
{
flags_
&
=
rhs
;
return
*
this
;
}
MutableScriptFlags
&
operator
|
=
(
const
uint32_t
rhs
)
{
flags_
|
=
rhs
;
return
*
this
;
}
}
;
class
alignas
(
uint32_t
)
ImmutableScriptData
final
{
using
Offset
=
uint32_t
;
Offset
optArrayOffset_
=
0
;
uint32_t
codeLength_
=
0
;
uint32_t
mainOffset
=
0
;
uint32_t
nfixed
=
0
;
uint32_t
nslots
=
0
;
uint32_t
bodyScopeIndex
=
0
;
uint32_t
numICEntries
=
0
;
uint16_t
funLength
=
0
;
uint16_t
numBytecodeTypeSets
=
0
;
struct
Flags
{
uint8_t
resumeOffsetsEndIndex
:
2
;
uint8_t
scopeNotesEndIndex
:
2
;
uint8_t
tryNotesEndIndex
:
2
;
uint8_t
_unused
:
2
;
}
;
static_assert
(
sizeof
(
Flags
)
=
=
sizeof
(
uint8_t
)
"
Structure
packing
is
broken
"
)
;
friend
class
:
:
JSScript
;
private
:
size_t
flagOffset
(
)
const
{
return
offsetOfCode
(
)
-
sizeof
(
Flags
)
;
}
size_t
codeOffset
(
)
const
{
return
offsetOfCode
(
)
;
}
size_t
noteOffset
(
)
const
{
return
offsetOfCode
(
)
+
codeLength_
;
}
size_t
optionalOffsetsOffset
(
)
const
{
unsigned
numOffsets
=
flags
(
)
.
tryNotesEndIndex
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
scopeNotesEndIndex
)
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
resumeOffsetsEndIndex
)
;
return
optArrayOffset_
-
(
numOffsets
*
sizeof
(
Offset
)
)
;
}
size_t
resumeOffsetsOffset
(
)
const
{
return
optArrayOffset_
;
}
size_t
scopeNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
resumeOffsetsEndIndex
)
;
}
size_t
tryNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
scopeNotesEndIndex
)
;
}
size_t
endOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
tryNotesEndIndex
)
;
}
static
size_t
AllocationSize
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
template
<
typename
T
>
T
*
offsetToPointer
(
size_t
offset
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
return
reinterpret_cast
<
T
*
>
(
base
+
offset
)
;
}
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
void
initOptionalArrays
(
size_t
*
cursor
Flags
*
flags
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
ImmutableScriptData
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
void
setOptionalOffset
(
int
index
Offset
offset
)
{
MOZ_ASSERT
(
index
>
0
)
;
MOZ_ASSERT
(
offset
!
=
optArrayOffset_
"
Do
not
store
implicit
offset
"
)
;
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
=
offset
;
}
Offset
getOptionalOffset
(
int
index
)
const
{
if
(
index
=
=
0
)
{
return
optArrayOffset_
;
}
ImmutableScriptData
*
this_
=
const_cast
<
ImmutableScriptData
*
>
(
this
)
;
return
this_
-
>
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
;
}
public
:
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
mainOffset
uint32_t
nfixed
uint32_t
nslots
uint32_t
bodyScopeIndex
uint32_t
numICEntries
uint32_t
numBytecodeTypeSets
bool
isFunction
uint16_t
funLength
mozilla
:
:
Span
<
const
jsbytecode
>
code
mozilla
:
:
Span
<
const
SrcNote
>
notes
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
mozilla
:
:
Span
<
const
ScopeNote
>
scopeNotes
mozilla
:
:
Span
<
const
TryNote
>
tryNotes
)
;
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
static
constexpr
size_t
CodeNoteAlign
=
sizeof
(
uint32_t
)
;
static
uint32_t
ComputeNotePadding
(
uint32_t
codeLength
uint32_t
noteLength
)
{
uint32_t
flagLength
=
sizeof
(
Flags
)
;
uint32_t
nullLength
=
CodeNoteAlign
-
(
flagLength
+
codeLength
+
noteLength
)
%
CodeNoteAlign
;
MOZ_ASSERT
(
nullLength
>
=
1
)
;
return
nullLength
;
}
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
(
)
const
{
size_t
allocSize
=
endOffset
(
)
;
return
mozilla
:
:
MakeSpan
(
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
allocSize
)
;
}
Flags
&
flagsRef
(
)
{
return
*
offsetToPointer
<
Flags
>
(
flagOffset
(
)
)
;
}
const
Flags
&
flags
(
)
const
{
return
const_cast
<
ImmutableScriptData
*
>
(
this
)
-
>
flagsRef
(
)
;
}
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
offsetToPointer
<
jsbytecode
>
(
codeOffset
(
)
)
;
}
mozilla
:
:
Span
<
jsbytecode
>
codeSpan
(
)
{
return
{
code
(
)
codeLength
(
)
}
;
}
uint32_t
noteLength
(
)
const
{
return
optionalOffsetsOffset
(
)
-
noteOffset
(
)
;
}
SrcNote
*
notes
(
)
{
return
offsetToPointer
<
SrcNote
>
(
noteOffset
(
)
)
;
}
mozilla
:
:
Span
<
SrcNote
>
notesSpan
(
)
{
return
{
notes
(
)
noteLength
(
)
}
;
}
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
uint32_t
>
(
resumeOffsetsOffset
(
)
)
offsetToPointer
<
uint32_t
>
(
scopeNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
ScopeNote
>
(
scopeNotesOffset
(
)
)
offsetToPointer
<
ScopeNote
>
(
tryNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
TryNote
>
tryNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
TryNote
>
(
tryNotesOffset
(
)
)
offsetToPointer
<
TryNote
>
(
endOffset
(
)
)
)
;
}
static
constexpr
size_t
offsetOfCode
(
)
{
return
sizeof
(
ImmutableScriptData
)
+
sizeof
(
Flags
)
;
}
static
constexpr
size_t
offsetOfResumeOffsetsOffset
(
)
{
return
offsetof
(
ImmutableScriptData
optArrayOffset_
)
;
}
static
constexpr
size_t
offsetOfNfixed
(
)
{
return
offsetof
(
ImmutableScriptData
nfixed
)
;
}
static
constexpr
size_t
offsetOfNslots
(
)
{
return
offsetof
(
ImmutableScriptData
nslots
)
;
}
static
constexpr
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
ImmutableScriptData
funLength
)
;
}
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
UniquePtr
<
ImmutableScriptData
>
&
script
)
;
ImmutableScriptData
(
const
ImmutableScriptData
&
)
=
delete
;
ImmutableScriptData
&
operator
=
(
const
ImmutableScriptData
&
)
=
delete
;
}
;
}
#
endif
