#
ifndef
vm_SharedStencil_h
#
define
vm_SharedStencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
EnumFlags
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
namespace
js
{
namespace
frontend
{
class
StencilXDR
;
}
class
GCThingIndexType
;
class
GCThingIndex
:
public
frontend
:
:
TypedIndex
<
GCThingIndexType
>
{
using
Base
=
frontend
:
:
TypedIndex
<
GCThingIndexType
>
;
using
Base
:
:
Base
;
public
:
static
constexpr
GCThingIndex
outermostScopeIndex
(
)
{
return
GCThingIndex
(
0
)
;
}
static
constexpr
GCThingIndex
invalid
(
)
{
return
GCThingIndex
(
UINT32_MAX
)
;
}
GCThingIndex
next
(
)
const
{
return
GCThingIndex
(
index
+
1
)
;
}
}
;
struct
TryNote
{
uint32_t
kind_
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
TryNote
(
uint32_t
kind
uint32_t
stackDepth
uint32_t
start
uint32_t
length
)
:
kind_
(
kind
)
stackDepth
(
stackDepth
)
start
(
start
)
length
(
length
)
{
}
TryNote
(
)
=
default
;
TryNoteKind
kind
(
)
const
{
return
TryNoteKind
(
kind_
)
;
}
bool
isLoop
(
)
const
{
switch
(
kind
(
)
)
{
case
TryNoteKind
:
:
Loop
:
case
TryNoteKind
:
:
ForIn
:
case
TryNoteKind
:
:
ForOf
:
return
true
;
case
TryNoteKind
:
:
Catch
:
case
TryNoteKind
:
:
Finally
:
case
TryNoteKind
:
:
ForOfIterClose
:
case
TryNoteKind
:
:
Destructuring
:
return
false
;
}
MOZ_CRASH
(
"
Unexpected
try
note
kind
"
)
;
}
}
;
struct
ScopeNote
{
static
constexpr
GCThingIndex
NoScopeIndex
=
GCThingIndex
:
:
invalid
(
)
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
GCThingIndex
index
;
uint32_t
start
=
0
;
uint32_t
length
=
0
;
uint32_t
parent
=
0
;
}
;
struct
SourceExtent
{
SourceExtent
(
)
=
default
;
SourceExtent
(
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
)
:
sourceStart
(
sourceStart
)
sourceEnd
(
sourceEnd
)
toStringStart
(
toStringStart
)
toStringEnd
(
toStringEnd
)
lineno
(
lineno
)
column
(
column
)
{
}
static
SourceExtent
makeGlobalExtent
(
uint32_t
len
)
{
return
SourceExtent
(
0
len
0
len
1
0
)
;
}
static
SourceExtent
makeGlobalExtent
(
uint32_t
len
uint32_t
lineno
uint32_t
column
)
{
return
SourceExtent
(
0
len
0
len
lineno
column
)
;
}
using
FunctionKey
=
uint32_t
;
static
constexpr
FunctionKey
NullFunctionKey
=
0
;
uint32_t
sourceStart
=
0
;
uint32_t
sourceEnd
=
0
;
uint32_t
toStringStart
=
0
;
uint32_t
toStringEnd
=
0
;
uint32_t
lineno
=
1
;
uint32_t
column
=
0
;
FunctionKey
toFunctionKey
(
)
const
{
auto
result
=
sourceStart
+
1
;
MOZ_ASSERT
(
result
!
=
NullFunctionKey
)
;
return
result
;
}
}
;
class
ImmutableScriptFlags
:
public
EnumFlags
<
ImmutableScriptFlagsEnum
>
{
public
:
ImmutableScriptFlags
(
)
=
default
;
explicit
ImmutableScriptFlags
(
FieldType
rawFlags
)
:
EnumFlags
(
rawFlags
)
{
}
operator
FieldType
(
)
const
{
return
flags_
;
}
}
;
class
MutableScriptFlags
:
public
EnumFlags
<
MutableScriptFlagsEnum
>
{
public
:
MutableScriptFlags
(
)
=
default
;
MutableScriptFlags
&
operator
&
=
(
const
FieldType
rhs
)
{
flags_
&
=
rhs
;
return
*
this
;
}
MutableScriptFlags
&
operator
|
=
(
const
FieldType
rhs
)
{
flags_
|
=
rhs
;
return
*
this
;
}
operator
FieldType
(
)
const
{
return
flags_
;
}
}
;
#
define
GENERIC_FLAGS_READ_ONLY
(
Field
Enum
)
\
[
[
nodiscard
]
]
bool
hasFlag
(
Enum
flag
)
const
{
return
Field
.
hasFlag
(
flag
)
;
}
#
define
GENERIC_FLAGS_READ_WRITE
(
Field
Enum
)
\
[
[
nodiscard
]
]
bool
hasFlag
(
Enum
flag
)
const
{
return
Field
.
hasFlag
(
flag
)
;
}
\
void
setFlag
(
Enum
flag
bool
b
=
true
)
{
Field
.
setFlag
(
flag
b
)
;
}
\
void
clearFlag
(
Enum
flag
)
{
Field
.
clearFlag
(
flag
)
;
}
#
define
GENERIC_FLAG_GETTER
(
enumName
lowerName
name
)
\
bool
lowerName
(
)
const
{
return
hasFlag
(
enumName
:
:
name
)
;
}
#
define
GENERIC_FLAG_GETTER_SETTER
(
enumName
lowerName
name
)
\
GENERIC_FLAG_GETTER
(
enumName
lowerName
name
)
\
void
set
#
#
name
(
)
{
setFlag
(
enumName
:
:
name
)
;
}
\
void
set
#
#
name
(
bool
b
)
{
setFlag
(
enumName
:
:
name
b
)
;
}
\
void
clear
#
#
name
(
)
{
clearFlag
(
enumName
:
:
name
)
;
}
#
define
IMMUTABLE_SCRIPT_FLAGS_WITH_ACCESSORS
(
_
)
\
_
(
ImmutableFlags
isForEval
IsForEval
)
\
_
(
ImmutableFlags
isModule
IsModule
)
\
_
(
ImmutableFlags
isFunction
IsFunction
)
\
_
(
ImmutableFlags
selfHosted
SelfHosted
)
\
_
(
ImmutableFlags
forceStrict
ForceStrict
)
\
_
(
ImmutableFlags
hasNonSyntacticScope
HasNonSyntacticScope
)
\
_
(
ImmutableFlags
noScriptRval
NoScriptRval
)
\
_
(
ImmutableFlags
treatAsRunOnce
TreatAsRunOnce
)
\
_
(
ImmutableFlags
strict
Strict
)
\
_
(
ImmutableFlags
hasModuleGoal
HasModuleGoal
)
\
_
(
ImmutableFlags
hasInnerFunctions
HasInnerFunctions
)
\
_
(
ImmutableFlags
hasDirectEval
HasDirectEval
)
\
_
(
ImmutableFlags
bindingsAccessedDynamically
BindingsAccessedDynamically
)
\
_
(
ImmutableFlags
hasCallSiteObj
HasCallSiteObj
)
\
_
(
ImmutableFlags
isAsync
IsAsync
)
\
_
(
ImmutableFlags
isGenerator
IsGenerator
)
\
_
(
ImmutableFlags
funHasExtensibleScope
FunHasExtensibleScope
)
\
_
(
ImmutableFlags
functionHasThisBinding
FunctionHasThisBinding
)
\
_
(
ImmutableFlags
needsHomeObject
NeedsHomeObject
)
\
_
(
ImmutableFlags
isDerivedClassConstructor
IsDerivedClassConstructor
)
\
_
(
ImmutableFlags
isSyntheticFunction
IsSyntheticFunction
)
\
_
(
ImmutableFlags
useMemberInitializers
UseMemberInitializers
)
\
_
(
ImmutableFlags
hasRest
HasRest
)
\
_
(
ImmutableFlags
needsFunctionEnvironmentObjects
\
NeedsFunctionEnvironmentObjects
)
\
_
(
ImmutableFlags
functionHasExtraBodyVarScope
\
FunctionHasExtraBodyVarScope
)
\
_
(
ImmutableFlags
shouldDeclareArguments
ShouldDeclareArguments
)
\
_
(
ImmutableFlags
needsArgsObj
NeedsArgsObj
)
\
_
(
ImmutableFlags
hasMappedArgsObj
HasMappedArgsObj
)
\
_
(
ImmutableFlags
isInlinableLargeFunction
IsInlinableLargeFunction
)
\
_
(
ImmutableFlags
functionHasNewTargetBinding
FunctionHasNewTargetBinding
)
\
\
GeneratorKind
generatorKind
(
)
const
{
\
return
isGenerator
(
)
?
GeneratorKind
:
:
Generator
\
:
GeneratorKind
:
:
NotGenerator
;
\
}
\
\
FunctionAsyncKind
asyncKind
(
)
const
{
\
return
isAsync
(
)
?
FunctionAsyncKind
:
:
AsyncFunction
\
:
FunctionAsyncKind
:
:
SyncFunction
;
\
}
\
\
bool
isRelazifiable
(
)
const
{
\
/
*
\
*
*
A
script
may
not
be
relazifiable
if
parts
of
it
can
be
entrained
in
\
*
*
interesting
ways
:
\
*
*
-
Scripts
with
inner
-
functions
or
direct
-
eval
(
which
can
add
\
*
*
inner
-
functions
)
should
not
be
relazified
as
their
Scopes
may
be
\
*
*
part
of
another
scope
-
chain
.
\
*
*
-
Generators
and
async
functions
may
be
re
-
entered
in
complex
ways
so
\
*
*
don
'
t
discard
bytecode
.
The
JIT
resume
code
assumes
this
.
\
*
*
-
Functions
with
template
literals
must
always
return
the
same
object
\
*
*
instance
so
must
not
discard
it
by
relazifying
.
\
*
/
\
return
!
hasInnerFunctions
(
)
&
&
!
hasDirectEval
(
)
&
&
!
isGenerator
(
)
&
&
\
!
isAsync
(
)
&
&
!
hasCallSiteObj
(
)
;
\
}
#
define
RO_IMMUTABLE_SCRIPT_FLAGS
(
Field
)
\
using
ImmutableFlags
=
ImmutableScriptFlagsEnum
;
\
\
GENERIC_FLAGS_READ_ONLY
(
Field
ImmutableFlags
)
\
IMMUTABLE_SCRIPT_FLAGS_WITH_ACCESSORS
(
GENERIC_FLAG_GETTER
)
#
define
MUTABLE_SCRIPT_FLAGS_WITH_ACCESSORS
(
_
)
\
_
(
MutableFlags
hasRunOnce
HasRunOnce
)
\
_
(
MutableFlags
hasScriptCounts
HasScriptCounts
)
\
_
(
MutableFlags
hasDebugScript
HasDebugScript
)
\
_
(
MutableFlags
allowRelazify
AllowRelazify
)
\
_
(
MutableFlags
spewEnabled
SpewEnabled
)
\
_
(
MutableFlags
needsFinalWarmUpCount
NeedsFinalWarmUpCount
)
\
_
(
MutableFlags
failedBoundsCheck
FailedBoundsCheck
)
\
_
(
MutableFlags
hadLICMInvalidation
HadLICMInvalidation
)
\
_
(
MutableFlags
hadReorderingBailout
HadReorderingBailout
)
\
_
(
MutableFlags
hadEagerTruncationBailout
HadEagerTruncationBailout
)
\
_
(
MutableFlags
hadUnboxFoldingBailout
HadUnboxFoldingBailout
)
\
_
(
MutableFlags
baselineDisabled
BaselineDisabled
)
\
_
(
MutableFlags
ionDisabled
IonDisabled
)
\
_
(
MutableFlags
uninlineable
Uninlineable
)
\
_
(
MutableFlags
failedLexicalCheck
FailedLexicalCheck
)
\
_
(
MutableFlags
hadSpeculativePhiBailout
HadSpeculativePhiBailout
)
#
define
RW_MUTABLE_SCRIPT_FLAGS
(
Field
)
\
using
MutableFlags
=
MutableScriptFlagsEnum
;
\
\
GENERIC_FLAGS_READ_WRITE
(
Field
MutableFlags
)
\
MUTABLE_SCRIPT_FLAGS_WITH_ACCESSORS
(
GENERIC_FLAG_GETTER_SETTER
)
class
alignas
(
uint32_t
)
ImmutableScriptData
final
:
public
TrailingArray
{
private
:
Offset
optArrayOffset_
=
0
;
uint32_t
codeLength_
=
0
;
public
:
uint32_t
mainOffset
=
0
;
uint32_t
nfixed
=
0
;
uint32_t
nslots
=
0
;
GCThingIndex
bodyScopeIndex
;
uint32_t
numICEntries
=
0
;
uint16_t
funLength
=
0
;
uint16_t
padding
=
0
;
private
:
struct
Flags
{
uint8_t
resumeOffsetsEndIndex
:
2
;
uint8_t
scopeNotesEndIndex
:
2
;
uint8_t
tryNotesEndIndex
:
2
;
uint8_t
_unused
:
2
;
}
;
static_assert
(
sizeof
(
Flags
)
=
=
sizeof
(
uint8_t
)
"
Structure
packing
is
broken
"
)
;
Offset
flagOffset
(
)
const
{
return
offsetOfCode
(
)
-
sizeof
(
Flags
)
;
}
Offset
codeOffset
(
)
const
{
return
offsetOfCode
(
)
;
}
Offset
noteOffset
(
)
const
{
return
offsetOfCode
(
)
+
codeLength_
;
}
Offset
optionalOffsetsOffset
(
)
const
{
unsigned
numOffsets
=
flags
(
)
.
tryNotesEndIndex
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
scopeNotesEndIndex
)
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
resumeOffsetsEndIndex
)
;
return
optArrayOffset_
-
(
numOffsets
*
sizeof
(
Offset
)
)
;
}
Offset
resumeOffsetsOffset
(
)
const
{
return
optArrayOffset_
;
}
Offset
scopeNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
resumeOffsetsEndIndex
)
;
}
Offset
tryNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
scopeNotesEndIndex
)
;
}
Offset
endOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
tryNotesEndIndex
)
;
}
void
initOptionalArrays
(
Offset
*
cursor
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
ImmutableScriptData
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
void
setOptionalOffset
(
int
index
Offset
offset
)
{
MOZ_ASSERT
(
index
>
0
)
;
MOZ_ASSERT
(
offset
!
=
optArrayOffset_
"
Do
not
store
implicit
offset
"
)
;
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
=
offset
;
}
Offset
getOptionalOffset
(
int
index
)
const
{
if
(
index
=
=
0
)
{
return
optArrayOffset_
;
}
ImmutableScriptData
*
this_
=
const_cast
<
ImmutableScriptData
*
>
(
this
)
;
return
this_
-
>
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
;
}
public
:
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
mainOffset
uint32_t
nfixed
uint32_t
nslots
GCThingIndex
bodyScopeIndex
uint32_t
numICEntries
bool
isFunction
uint16_t
funLength
mozilla
:
:
Span
<
const
jsbytecode
>
code
mozilla
:
:
Span
<
const
SrcNote
>
notes
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
mozilla
:
:
Span
<
const
ScopeNote
>
scopeNotes
mozilla
:
:
Span
<
const
TryNote
>
tryNotes
)
;
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
static
js
:
:
UniquePtr
<
ImmutableScriptData
>
new_
(
JSContext
*
cx
uint32_t
totalSize
)
;
bool
validateLayout
(
uint32_t
expectedSize
)
;
private
:
static
mozilla
:
:
CheckedInt
<
uint32_t
>
sizeFor
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
public
:
static
constexpr
size_t
CodeNoteAlign
=
sizeof
(
uint32_t
)
;
static
uint32_t
ComputeNotePadding
(
uint32_t
codeLength
uint32_t
noteLength
)
{
uint32_t
flagLength
=
sizeof
(
Flags
)
;
uint32_t
nullLength
=
CodeNoteAlign
-
(
flagLength
+
codeLength
+
noteLength
)
%
CodeNoteAlign
;
MOZ_ASSERT
(
nullLength
>
=
1
)
;
return
nullLength
;
}
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
(
)
const
{
size_t
allocSize
=
endOffset
(
)
;
return
mozilla
:
:
Span
{
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
allocSize
}
;
}
private
:
Flags
&
flagsRef
(
)
{
return
*
offsetToPointer
<
Flags
>
(
flagOffset
(
)
)
;
}
const
Flags
&
flags
(
)
const
{
return
const_cast
<
ImmutableScriptData
*
>
(
this
)
-
>
flagsRef
(
)
;
}
public
:
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
offsetToPointer
<
jsbytecode
>
(
codeOffset
(
)
)
;
}
mozilla
:
:
Span
<
jsbytecode
>
codeSpan
(
)
{
return
{
code
(
)
codeLength
(
)
}
;
}
uint32_t
noteLength
(
)
const
{
return
numElements
<
SrcNote
>
(
noteOffset
(
)
optionalOffsetsOffset
(
)
)
;
}
SrcNote
*
notes
(
)
{
return
offsetToPointer
<
SrcNote
>
(
noteOffset
(
)
)
;
}
mozilla
:
:
Span
<
SrcNote
>
notesSpan
(
)
{
return
{
notes
(
)
noteLength
(
)
}
;
}
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
uint32_t
>
(
resumeOffsetsOffset
(
)
)
offsetToPointer
<
uint32_t
>
(
scopeNotesOffset
(
)
)
}
;
}
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
ScopeNote
>
(
scopeNotesOffset
(
)
)
offsetToPointer
<
ScopeNote
>
(
tryNotesOffset
(
)
)
}
;
}
mozilla
:
:
Span
<
TryNote
>
tryNotes
(
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
TryNote
>
(
tryNotesOffset
(
)
)
offsetToPointer
<
TryNote
>
(
endOffset
(
)
)
}
;
}
static
constexpr
size_t
offsetOfCode
(
)
{
return
sizeof
(
ImmutableScriptData
)
+
sizeof
(
Flags
)
;
}
static
constexpr
size_t
offsetOfResumeOffsetsOffset
(
)
{
static_assert
(
sizeof
(
Offset
)
=
=
sizeof
(
uint32_t
)
"
JIT
expect
Offset
to
be
uint32_t
"
)
;
return
offsetof
(
ImmutableScriptData
optArrayOffset_
)
;
}
static
constexpr
size_t
offsetOfNfixed
(
)
{
return
offsetof
(
ImmutableScriptData
nfixed
)
;
}
static
constexpr
size_t
offsetOfNslots
(
)
{
return
offsetof
(
ImmutableScriptData
nslots
)
;
}
static
constexpr
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
ImmutableScriptData
funLength
)
;
}
ImmutableScriptData
(
const
ImmutableScriptData
&
)
=
delete
;
ImmutableScriptData
&
operator
=
(
const
ImmutableScriptData
&
)
=
delete
;
}
;
class
SharedImmutableScriptData
{
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
>
refCount_
=
{
}
;
public
:
bool
isExternal
=
false
;
private
:
ImmutableScriptData
*
isd_
=
nullptr
;
friend
class
:
:
JSScript
;
friend
class
js
:
:
frontend
:
:
StencilXDR
;
public
:
SharedImmutableScriptData
(
)
=
default
;
~
SharedImmutableScriptData
(
)
{
reset
(
)
;
}
private
:
void
reset
(
)
{
if
(
isd_
&
&
!
isExternal
)
{
js_delete
(
isd_
)
;
}
isd_
=
nullptr
;
}
public
:
struct
Hasher
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
AddRef
(
)
{
refCount_
+
+
;
}
void
Release
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
uint32_t
remain
=
-
-
refCount_
;
if
(
remain
=
=
0
)
{
reset
(
)
;
js_free
(
this
)
;
}
}
static
constexpr
size_t
offsetOfISD
(
)
{
return
offsetof
(
SharedImmutableScriptData
isd_
)
;
}
private
:
static
SharedImmutableScriptData
*
create
(
JSContext
*
cx
)
;
public
:
static
SharedImmutableScriptData
*
createWith
(
JSContext
*
cx
js
:
:
UniquePtr
<
ImmutableScriptData
>
&
&
isd
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
isdSize
=
isExternal
?
0
:
mallocSizeOf
(
isd_
)
;
return
mallocSizeOf
(
this
)
+
isdSize
;
}
SharedImmutableScriptData
(
const
SharedImmutableScriptData
&
)
=
delete
;
SharedImmutableScriptData
&
operator
=
(
const
SharedImmutableScriptData
&
)
=
delete
;
static
bool
shareScriptData
(
JSContext
*
cx
RefPtr
<
SharedImmutableScriptData
>
&
sisd
)
;
static
bool
shareScriptData
(
JSContext
*
cx
ErrorContext
*
ec
RefPtr
<
SharedImmutableScriptData
>
&
sisd
)
;
size_t
immutableDataLength
(
)
const
{
return
isd_
-
>
immutableData
(
)
.
Length
(
)
;
}
uint32_t
nfixed
(
)
const
{
return
isd_
-
>
nfixed
;
}
ImmutableScriptData
*
get
(
)
{
return
isd_
;
}
void
setOwn
(
js
:
:
UniquePtr
<
ImmutableScriptData
>
&
&
isd
)
{
MOZ_ASSERT
(
!
isd_
)
;
isd_
=
isd
.
release
(
)
;
isExternal
=
false
;
}
void
setExternal
(
ImmutableScriptData
*
isd
)
{
MOZ_ASSERT
(
!
isd_
)
;
isd_
=
isd
;
isExternal
=
true
;
}
}
;
struct
SharedImmutableScriptData
:
:
Hasher
{
using
Lookup
=
RefPtr
<
SharedImmutableScriptData
>
;
static
mozilla
:
:
HashNumber
hash
(
const
Lookup
&
l
)
{
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
=
l
-
>
isd_
-
>
immutableData
(
)
;
return
mozilla
:
:
HashBytes
(
immutableData
.
data
(
)
immutableData
.
size
(
)
)
;
}
static
bool
match
(
SharedImmutableScriptData
*
entry
const
Lookup
&
lookup
)
{
return
(
entry
-
>
isd_
-
>
immutableData
(
)
=
=
lookup
-
>
isd_
-
>
immutableData
(
)
)
;
}
}
;
using
SharedImmutableScriptDataTable
=
mozilla
:
:
HashSet
<
SharedImmutableScriptData
*
SharedImmutableScriptData
:
:
Hasher
SystemAllocPolicy
>
;
struct
MemberInitializers
{
static
constexpr
size_t
NumBits
=
31
;
static
constexpr
uint32_t
MaxInitializers
=
BitMask
(
NumBits
)
;
#
ifdef
DEBUG
bool
valid
=
false
;
#
endif
bool
hasPrivateBrand
:
1
;
uint32_t
numMemberInitializers
:
NumBits
;
MemberInitializers
(
bool
hasPrivateBrand
uint32_t
numMemberInitializers
)
:
#
ifdef
DEBUG
valid
(
true
)
#
endif
hasPrivateBrand
(
hasPrivateBrand
)
numMemberInitializers
(
numMemberInitializers
)
{
MOZ_ASSERT
(
this
-
>
numMemberInitializers
=
=
numMemberInitializers
"
numMemberInitializers
should
easily
fit
in
the
31
-
bit
bitfield
"
)
;
}
static
MemberInitializers
Invalid
(
)
{
return
MemberInitializers
(
)
;
}
static
const
MemberInitializers
&
Empty
(
)
{
static
const
MemberInitializers
zeroInitializers
(
false
0
)
;
return
zeroInitializers
;
}
uint32_t
serialize
(
)
const
{
return
(
hasPrivateBrand
<
<
NumBits
)
|
numMemberInitializers
;
}
static
MemberInitializers
deserialize
(
uint32_t
bits
)
{
return
MemberInitializers
(
(
bits
&
Bit
(
NumBits
)
)
!
=
0
bits
&
BitMask
(
NumBits
)
)
;
}
private
:
MemberInitializers
(
)
:
#
ifdef
DEBUG
valid
(
false
)
#
endif
hasPrivateBrand
(
false
)
numMemberInitializers
(
0
)
{
}
}
;
}
#
endif
