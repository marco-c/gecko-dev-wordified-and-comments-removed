#
ifndef
vm_ArrayObject_h
#
define
vm_ArrayObject_h
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
AutoSetNewObjectMetadata
;
class
ArrayObject
:
public
NativeObject
{
public
:
static
const
uint32_t
EagerAllocationMaxLength
=
2048
-
ObjectElements
:
:
VALUES_PER_HEADER
;
static
const
Class
class_
;
bool
lengthIsWritable
(
)
const
{
return
!
getElementsHeader
(
)
-
>
hasNonwritableArrayLength
(
)
;
}
uint32_t
length
(
)
const
{
return
getElementsHeader
(
)
-
>
length
;
}
void
setNonWritableLength
(
JSContext
*
cx
)
{
if
(
getElementsHeader
(
)
-
>
numShiftedElements
(
)
>
0
)
unshiftElements
(
)
;
ObjectElements
*
header
=
getElementsHeader
(
)
;
uint32_t
len
=
header
-
>
initializedLength
;
if
(
header
-
>
capacity
>
len
)
{
shrinkElements
(
cx
len
)
;
header
=
getElementsHeader
(
)
;
header
-
>
capacity
=
len
;
}
header
-
>
setNonwritableArrayLength
(
)
;
}
inline
void
setLength
(
JSContext
*
cx
uint32_t
length
)
;
void
setLengthInt32
(
uint32_t
length
)
{
MOZ_ASSERT
(
lengthIsWritable
(
)
)
;
MOZ_ASSERT
(
length
<
=
INT32_MAX
)
;
getElementsHeader
(
)
-
>
length
=
length
;
}
static
inline
ArrayObject
*
createArray
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
HandleShape
shape
HandleObjectGroup
group
uint32_t
length
AutoSetNewObjectMetadata
&
metadata
)
;
static
inline
ArrayObject
*
createCopyOnWriteArray
(
JSContext
*
cx
gc
:
:
InitialHeap
heap
HandleArrayObject
sharedElementsOwner
)
;
private
:
static
inline
ArrayObject
*
createArrayInternal
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
HandleShape
shape
HandleObjectGroup
group
AutoSetNewObjectMetadata
&
)
;
static
inline
ArrayObject
*
finishCreateArray
(
ArrayObject
*
obj
HandleShape
shape
AutoSetNewObjectMetadata
&
metadata
)
;
}
;
}
#
endif
