#
ifndef
vm_RegExpObject_h
#
define
vm_RegExpObject_h
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
proxy
/
Proxy
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
RegExpShared
.
h
"
#
include
"
vm
/
Shape
.
h
"
namespace
js
{
class
GenericPrinter
;
class
JSONPrinter
;
extern
RegExpObject
*
RegExpAlloc
(
JSContext
*
cx
NewObjectKind
newKind
HandleObject
proto
=
nullptr
HandleObject
newTarget
=
nullptr
)
;
extern
JSObject
*
CloneRegExpObject
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regex
)
;
class
RegExpObject
:
public
NativeObject
{
static
const
unsigned
LAST_INDEX_SLOT
=
0
;
static
const
unsigned
SOURCE_SLOT
=
1
;
static
const
unsigned
FLAGS_SLOT
=
2
;
static_assert
(
RegExpObject
:
:
FLAGS_SLOT
=
=
REGEXP_FLAGS_SLOT
"
FLAGS_SLOT
values
should
be
in
sync
with
self
-
hosted
JS
"
)
;
static
RegExpObject
*
create
(
JSContext
*
cx
Handle
<
JSAtom
*
>
source
NewObjectKind
newKind
)
;
public
:
static
const
unsigned
SHARED_SLOT
=
3
;
static
const
unsigned
RESERVED_SLOTS
=
4
;
static
constexpr
gc
:
:
AllocKind
AllocKind
=
gc
:
:
AllocKind
:
:
OBJECT4
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
const
size_t
RegExpFlagsMask
=
JS
:
:
RegExpFlag
:
:
AllFlags
;
static
const
size_t
LegacyFeaturesEnabledBit
=
Bit
(
8
)
;
static_assert
(
(
RegExpFlagsMask
&
LegacyFeaturesEnabledBit
)
=
=
0
"
LegacyFeaturesEnabledBit
must
not
overlap
"
)
;
static
const
size_t
MaxPairCount
=
14
;
template
<
typename
CharT
>
static
RegExpObject
*
create
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
JS
:
:
RegExpFlags
flags
NewObjectKind
newKind
HandleObject
newTarget
=
nullptr
)
;
static
RegExpObject
*
createSyntaxChecked
(
JSContext
*
cx
Handle
<
JSAtom
*
>
source
JS
:
:
RegExpFlags
flags
NewObjectKind
newKind
HandleObject
newTarget
=
nullptr
)
;
static
RegExpObject
*
create
(
JSContext
*
cx
Handle
<
JSAtom
*
>
source
JS
:
:
RegExpFlags
flags
NewObjectKind
newKind
HandleObject
newTarget
=
nullptr
)
;
static
SharedShape
*
assignInitialShape
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
obj
)
;
static
constexpr
size_t
lastIndexSlot
(
)
{
return
LAST_INDEX_SLOT
;
}
static
constexpr
size_t
offsetOfLastIndex
(
)
{
return
getFixedSlotOffset
(
lastIndexSlot
(
)
)
;
}
static
bool
isInitialShape
(
RegExpObject
*
rx
)
{
MOZ_ASSERT
(
!
rx
-
>
empty
(
)
)
;
PropertyInfoWithKey
prop
=
rx
-
>
getLastProperty
(
)
;
return
prop
.
isDataProperty
(
)
&
&
prop
.
slot
(
)
=
=
LAST_INDEX_SLOT
&
&
prop
.
writable
(
)
;
}
const
Value
&
getLastIndex
(
)
const
{
return
getReservedSlot
(
LAST_INDEX_SLOT
)
;
}
void
setLastIndex
(
JSContext
*
cx
int32_t
lastIndex
)
{
MOZ_ASSERT
(
lastIndex
>
=
0
)
;
MOZ_ASSERT
(
lookupPure
(
cx
-
>
names
(
)
.
lastIndex
)
-
>
writable
(
)
"
can
'
t
infallibly
set
a
non
-
writable
lastIndex
on
a
"
"
RegExp
that
'
s
been
exposed
to
script
"
)
;
setReservedSlot
(
LAST_INDEX_SLOT
Int32Value
(
lastIndex
)
)
;
}
void
zeroLastIndex
(
JSContext
*
cx
)
{
setLastIndex
(
cx
0
)
;
}
static
JSLinearString
*
toString
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
obj
)
;
JSAtom
*
getSource
(
)
const
{
return
&
getReservedSlot
(
SOURCE_SLOT
)
.
toString
(
)
-
>
asAtom
(
)
;
}
void
setSource
(
JSAtom
*
source
)
{
setReservedSlot
(
SOURCE_SLOT
StringValue
(
source
)
)
;
}
static
constexpr
size_t
flagsSlot
(
)
{
return
FLAGS_SLOT
;
}
static
constexpr
size_t
offsetOfFlags
(
)
{
return
getFixedSlotOffset
(
flagsSlot
(
)
)
;
}
static
constexpr
size_t
offsetOfShared
(
)
{
return
getFixedSlotOffset
(
SHARED_SLOT
)
;
}
JS
:
:
RegExpFlags
getFlags
(
)
const
{
Value
flagsVal
=
getFixedSlot
(
FLAGS_SLOT
)
;
uint32_t
raw
=
flagsVal
.
toInt32
(
)
;
return
JS
:
:
RegExpFlags
(
raw
&
RegExpFlagsMask
)
;
}
void
setFlags
(
JS
:
:
RegExpFlags
flags
)
{
Value
flagsVal
=
getFixedSlot
(
FLAGS_SLOT
)
;
uint32_t
raw
=
0
;
if
(
flagsVal
.
isInt32
(
)
)
{
raw
=
static_cast
<
uint32_t
>
(
flagsVal
.
toInt32
(
)
)
;
}
uint32_t
newValue
=
flags
.
value
(
)
|
(
raw
&
~
RegExpFlagsMask
)
;
setFixedSlot
(
FLAGS_SLOT
Int32Value
(
newValue
)
)
;
}
bool
legacyFeaturesEnabled
(
)
const
{
if
(
!
JS
:
:
Prefs
:
:
experimental_legacy_regexp
(
)
)
{
return
false
;
}
return
(
getFixedSlot
(
FLAGS_SLOT
)
.
toInt32
(
)
&
LegacyFeaturesEnabledBit
)
;
}
void
setLegacyFeaturesEnabled
(
bool
enabled
)
{
MOZ_ASSERT_IF
(
enabled
JS
:
:
Prefs
:
:
experimental_legacy_regexp
(
)
)
;
Value
flagsVal
=
getFixedSlot
(
FLAGS_SLOT
)
;
uint32_t
raw
=
0
;
if
(
flagsVal
.
isInt32
(
)
)
{
raw
=
static_cast
<
uint32_t
>
(
flagsVal
.
toInt32
(
)
)
;
}
if
(
enabled
)
{
raw
|
=
LegacyFeaturesEnabledBit
;
}
else
{
raw
&
=
~
LegacyFeaturesEnabledBit
;
}
setFixedSlot
(
FLAGS_SLOT
Int32Value
(
raw
)
)
;
}
bool
hasIndices
(
)
const
{
return
getFlags
(
)
.
hasIndices
(
)
;
}
bool
global
(
)
const
{
return
getFlags
(
)
.
global
(
)
;
}
bool
ignoreCase
(
)
const
{
return
getFlags
(
)
.
ignoreCase
(
)
;
}
bool
multiline
(
)
const
{
return
getFlags
(
)
.
multiline
(
)
;
}
bool
dotAll
(
)
const
{
return
getFlags
(
)
.
dotAll
(
)
;
}
bool
unicode
(
)
const
{
return
getFlags
(
)
.
unicode
(
)
;
}
bool
unicodeSets
(
)
const
{
return
getFlags
(
)
.
unicodeSets
(
)
;
}
bool
sticky
(
)
const
{
return
getFlags
(
)
.
sticky
(
)
;
}
bool
isGlobalOrSticky
(
)
const
{
JS
:
:
RegExpFlags
flags
=
getFlags
(
)
;
return
flags
.
global
(
)
|
|
flags
.
sticky
(
)
;
}
static
RegExpShared
*
getShared
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
)
;
bool
hasShared
(
)
const
{
return
!
getFixedSlot
(
SHARED_SLOT
)
.
isUndefined
(
)
;
}
RegExpShared
*
getShared
(
)
const
{
return
static_cast
<
RegExpShared
*
>
(
getFixedSlot
(
SHARED_SLOT
)
.
toGCThing
(
)
)
;
}
void
setShared
(
RegExpShared
*
shared
)
{
MOZ_ASSERT
(
shared
)
;
setFixedSlot
(
SHARED_SLOT
PrivateGCThingValue
(
shared
)
)
;
}
void
clearShared
(
)
{
setFixedSlot
(
SHARED_SLOT
UndefinedValue
(
)
)
;
}
void
initIgnoringLastIndex
(
JSAtom
*
source
JS
:
:
RegExpFlags
flags
)
;
void
initAndZeroLastIndex
(
JSAtom
*
source
JS
:
:
RegExpFlags
flags
JSContext
*
cx
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpOwnFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpOwnStringContent
(
js
:
:
GenericPrinter
&
out
)
const
;
#
endif
private
:
static
RegExpShared
*
createShared
(
JSContext
*
cx
Handle
<
RegExpObject
*
>
regexp
)
;
void
setPrivate
(
void
*
priv
)
=
delete
;
}
;
bool
ParseRegExpFlags
(
JSContext
*
cx
JSString
*
flagStr
JS
:
:
RegExpFlags
*
flagsOut
)
;
inline
RegExpShared
*
RegExpToShared
(
JSContext
*
cx
HandleObject
obj
)
{
if
(
obj
-
>
is
<
RegExpObject
>
(
)
)
{
return
RegExpObject
:
:
getShared
(
cx
obj
.
as
<
RegExpObject
>
(
)
)
;
}
return
Proxy
:
:
regexp_toShared
(
cx
obj
)
;
}
extern
JSLinearString
*
EscapeRegExpPattern
(
JSContext
*
cx
Handle
<
JSAtom
*
>
src
)
;
template
<
typename
CharT
>
extern
bool
HasRegExpMetaChars
(
const
CharT
*
chars
size_t
length
)
;
extern
bool
StringHasRegExpMetaChars
(
const
JSLinearString
*
str
)
;
}
#
endif
