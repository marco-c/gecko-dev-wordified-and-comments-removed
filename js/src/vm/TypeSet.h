#
ifndef
vm_TypeSet_h
#
define
vm_TypeSet_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
initializer_list
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
DiagnosticAssertions
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSObject
;
namespace
JS
{
class
JS_PUBLIC_API
Compartment
;
class
JS_PUBLIC_API
Realm
;
class
JS_PUBLIC_API
Zone
;
}
namespace
js
{
namespace
jit
{
class
IonScript
;
class
TempAllocator
;
}
class
AutoClearTypeInferenceStateOnOOM
;
class
AutoSweepBase
;
class
AutoSweepObjectGroup
;
class
LifoAlloc
;
class
ObjectGroup
;
class
SystemAllocPolicy
;
class
TypeZone
;
enum
:
uint32_t
{
TYPE_FLAG_UNDEFINED
=
0x1
TYPE_FLAG_NULL
=
0x2
TYPE_FLAG_BOOLEAN
=
0x4
TYPE_FLAG_INT32
=
0x8
TYPE_FLAG_DOUBLE
=
0x10
TYPE_FLAG_STRING
=
0x20
TYPE_FLAG_SYMBOL
=
0x40
TYPE_FLAG_BIGINT
=
0x80
TYPE_FLAG_LAZYARGS
=
0x100
TYPE_FLAG_ANYOBJECT
=
0x200
TYPE_FLAG_PRIMITIVE_IMMEDIATE
=
TYPE_FLAG_UNDEFINED
|
TYPE_FLAG_NULL
|
TYPE_FLAG_BOOLEAN
|
TYPE_FLAG_INT32
|
TYPE_FLAG_DOUBLE
TYPE_FLAG_PRIMITIVE_GCTHING
=
TYPE_FLAG_STRING
|
TYPE_FLAG_SYMBOL
|
TYPE_FLAG_BIGINT
TYPE_FLAG_PRIMITIVE
=
TYPE_FLAG_PRIMITIVE_IMMEDIATE
|
TYPE_FLAG_PRIMITIVE_GCTHING
TYPE_FLAG_OBJECT_COUNT_MASK
=
0x3c00
TYPE_FLAG_OBJECT_COUNT_SHIFT
=
10
TYPE_FLAG_OBJECT_COUNT_LIMIT
=
7
TYPE_FLAG_DOMOBJECT_COUNT_LIMIT
=
TYPE_FLAG_OBJECT_COUNT_MASK
>
>
TYPE_FLAG_OBJECT_COUNT_SHIFT
TYPE_FLAG_UNKNOWN
=
0x00004000
TYPE_FLAG_BASE_MASK
=
TYPE_FLAG_PRIMITIVE
|
TYPE_FLAG_LAZYARGS
|
TYPE_FLAG_ANYOBJECT
|
TYPE_FLAG_UNKNOWN
TYPE_FLAG_NON_DATA_PROPERTY
=
0x00008000
TYPE_FLAG_NON_WRITABLE_PROPERTY
=
0x00010000
TYPE_FLAG_NON_CONSTANT_PROPERTY
=
0x00020000
TYPE_FLAG_DEFINITE_MASK
=
0xfffc0000
TYPE_FLAG_DEFINITE_SHIFT
=
18
}
;
using
TypeFlags
=
uint32_t
;
static_assert
(
TYPE_FLAG_PRIMITIVE
<
TYPE_FLAG_ANYOBJECT
&
&
TYPE_FLAG_LAZYARGS
<
TYPE_FLAG_ANYOBJECT
"
TYPE_FLAG_ANYOBJECT
should
be
greater
than
primitive
type
flags
"
)
;
enum
:
uint32_t
{
OBJECT_FLAG_FROM_ALLOCATION_SITE
=
0x1
OBJECT_FLAG_SINGLETON
=
0x2
OBJECT_FLAG_LAZY_SINGLETON
=
0x4
OBJECT_FLAG_SPARSE_INDEXES
=
0x00010000
OBJECT_FLAG_NON_PACKED
=
0x00020000
OBJECT_FLAG_LENGTH_OVERFLOW
=
0x00040000
OBJECT_FLAG_ITERATED
=
0x00080000
OBJECT_FLAG_NON_EXTENSIBLE_ELEMENTS
=
0x00100000
OBJECT_FLAG_PRE_TENURE
=
0x00800000
OBJECT_FLAG_COPY_ON_WRITE
=
0x01000000
OBJECT_FLAG_UNKNOWN_PROPERTIES
=
0x04000000
OBJECT_FLAG_DYNAMIC_MASK
=
0x07ff0000
OBJECT_FLAG_ADDENDUM_MASK
=
0x38000000
OBJECT_FLAG_ADDENDUM_SHIFT
=
27
OBJECT_FLAG_GENERATION_MASK
=
0x40000000
OBJECT_FLAG_GENERATION_SHIFT
=
30
}
;
using
ObjectGroupFlags
=
uint32_t
;
class
HeapTypeSet
;
class
TypeSet
{
protected
:
TypeFlags
flags
=
0
;
public
:
class
ObjectKey
;
protected
:
ObjectKey
*
*
objectSet
=
nullptr
;
public
:
TypeSet
(
)
=
default
;
class
ObjectKey
{
public
:
static
intptr_t
keyBits
(
ObjectKey
*
obj
)
{
return
(
intptr_t
)
obj
;
}
static
ObjectKey
*
getKey
(
ObjectKey
*
obj
)
{
return
obj
;
}
static
inline
ObjectKey
*
get
(
JSObject
*
obj
)
;
static
inline
ObjectKey
*
get
(
ObjectGroup
*
group
)
;
bool
isGroup
(
)
{
return
(
uintptr_t
(
this
)
&
1
)
=
=
0
;
}
bool
isSingleton
(
)
{
return
(
uintptr_t
(
this
)
&
1
)
!
=
0
;
}
static
constexpr
uintptr_t
TypeHashSetMarkBit
=
1
<
<
1
;
inline
ObjectGroup
*
group
(
)
;
inline
JSObject
*
singleton
(
)
;
inline
ObjectGroup
*
groupNoBarrier
(
)
;
inline
JSObject
*
singletonNoBarrier
(
)
;
const
JSClass
*
clasp
(
)
;
TaggedProto
proto
(
)
;
bool
unknownProperties
(
)
;
void
ensureTrackedProperty
(
JSContext
*
cx
jsid
id
)
;
ObjectGroup
*
maybeGroup
(
)
;
JS
:
:
Compartment
*
maybeCompartment
(
)
;
}
JS_HAZ_GC_POINTER
;
class
Type
{
friend
class
TypeSet
;
uintptr_t
data
;
explicit
Type
(
uintptr_t
data
)
:
data
(
data
)
{
}
public
:
uintptr_t
raw
(
)
const
{
return
data
;
}
bool
isPrimitive
(
)
const
{
return
data
<
JSVAL_TYPE_OBJECT
;
}
bool
isPrimitive
(
ValueType
type
)
const
{
MOZ_ASSERT
(
type
!
=
ValueType
:
:
Object
)
;
return
uintptr_t
(
type
)
=
=
data
;
}
ValueType
primitive
(
)
const
{
MOZ_ASSERT
(
isPrimitive
(
)
)
;
return
ValueType
(
data
)
;
}
bool
isSomeObject
(
)
const
{
return
data
=
=
JSVAL_TYPE_OBJECT
|
|
data
>
JSVAL_TYPE_UNKNOWN
;
}
bool
isAnyObject
(
)
const
{
return
data
=
=
JSVAL_TYPE_OBJECT
;
}
bool
isUnknown
(
)
const
{
return
data
=
=
JSVAL_TYPE_UNKNOWN
;
}
bool
isObject
(
)
const
{
MOZ_ASSERT
(
!
isAnyObject
(
)
&
&
!
isUnknown
(
)
)
;
return
data
>
JSVAL_TYPE_UNKNOWN
;
}
bool
isObjectUnchecked
(
)
const
{
return
data
>
JSVAL_TYPE_UNKNOWN
;
}
inline
ObjectKey
*
objectKey
(
)
const
;
bool
isSingleton
(
)
const
{
return
isObject
(
)
&
&
!
!
(
data
&
1
)
;
}
bool
isSingletonUnchecked
(
)
const
{
return
isObjectUnchecked
(
)
&
&
!
!
(
data
&
1
)
;
}
inline
JSObject
*
singleton
(
)
const
;
inline
JSObject
*
singletonNoBarrier
(
)
const
;
bool
isGroup
(
)
const
{
return
isObject
(
)
&
&
!
(
data
&
1
)
;
}
bool
isGroupUnchecked
(
)
const
{
return
isObjectUnchecked
(
)
&
&
!
(
data
&
1
)
;
}
inline
ObjectGroup
*
group
(
)
const
;
inline
ObjectGroup
*
groupNoBarrier
(
)
const
;
inline
void
trace
(
JSTracer
*
trc
)
;
JS
:
:
Compartment
*
maybeCompartment
(
)
;
bool
operator
=
=
(
Type
o
)
const
{
return
data
=
=
o
.
data
;
}
bool
operator
!
=
(
Type
o
)
const
{
return
data
!
=
o
.
data
;
}
}
JS_HAZ_GC_POINTER
;
static
inline
Type
UndefinedType
(
)
{
return
Type
(
JSVAL_TYPE_UNDEFINED
)
;
}
static
inline
Type
NullType
(
)
{
return
Type
(
JSVAL_TYPE_NULL
)
;
}
static
inline
Type
BooleanType
(
)
{
return
Type
(
JSVAL_TYPE_BOOLEAN
)
;
}
static
inline
Type
Int32Type
(
)
{
return
Type
(
JSVAL_TYPE_INT32
)
;
}
static
inline
Type
DoubleType
(
)
{
return
Type
(
JSVAL_TYPE_DOUBLE
)
;
}
static
inline
Type
StringType
(
)
{
return
Type
(
JSVAL_TYPE_STRING
)
;
}
static
inline
Type
SymbolType
(
)
{
return
Type
(
JSVAL_TYPE_SYMBOL
)
;
}
static
inline
Type
BigIntType
(
)
{
return
Type
(
JSVAL_TYPE_BIGINT
)
;
}
static
inline
Type
MagicArgType
(
)
{
return
Type
(
JSVAL_TYPE_MAGIC
)
;
}
static
inline
Type
AnyObjectType
(
)
{
return
Type
(
JSVAL_TYPE_OBJECT
)
;
}
static
inline
Type
UnknownType
(
)
{
return
Type
(
JSVAL_TYPE_UNKNOWN
)
;
}
protected
:
static
inline
Type
PrimitiveTypeFromTypeFlag
(
TypeFlags
flag
)
;
public
:
static
inline
Type
PrimitiveType
(
const
JS
:
:
Value
&
val
)
;
static
inline
Type
PrimitiveType
(
jit
:
:
MIRType
type
)
;
static
inline
Type
PrimitiveOrAnyObjectType
(
jit
:
:
MIRType
type
)
;
static
inline
Type
ObjectType
(
const
JSObject
*
obj
)
;
static
inline
Type
ObjectType
(
const
ObjectGroup
*
group
)
;
static
inline
Type
ObjectType
(
const
ObjectKey
*
key
)
;
static
const
char
*
NonObjectTypeString
(
Type
type
)
;
static
JS
:
:
UniqueChars
TypeString
(
const
Type
type
)
;
static
JS
:
:
UniqueChars
ObjectGroupString
(
const
ObjectGroup
*
group
)
;
void
print
(
FILE
*
fp
=
stderr
)
;
MOZ_ALWAYS_INLINE
bool
hasType
(
Type
type
)
const
;
TypeFlags
baseFlags
(
)
const
{
return
flags
&
TYPE_FLAG_BASE_MASK
;
}
bool
unknown
(
)
const
{
return
!
!
(
flags
&
TYPE_FLAG_UNKNOWN
)
;
}
bool
unknownObject
(
)
const
{
return
!
!
(
flags
&
(
TYPE_FLAG_UNKNOWN
|
TYPE_FLAG_ANYOBJECT
)
)
;
}
bool
empty
(
)
const
{
return
!
baseFlags
(
)
&
&
!
baseObjectCount
(
)
;
}
bool
hasAnyFlag
(
TypeFlags
flags
)
const
{
MOZ_ASSERT
(
(
flags
&
TYPE_FLAG_BASE_MASK
)
=
=
flags
)
;
return
!
!
(
baseFlags
(
)
&
flags
)
;
}
bool
nonDataProperty
(
)
const
{
return
flags
&
TYPE_FLAG_NON_DATA_PROPERTY
;
}
bool
nonWritableProperty
(
)
const
{
return
flags
&
TYPE_FLAG_NON_WRITABLE_PROPERTY
;
}
bool
nonConstantProperty
(
)
const
{
return
flags
&
TYPE_FLAG_NON_CONSTANT_PROPERTY
;
}
bool
definiteProperty
(
)
const
{
return
flags
&
TYPE_FLAG_DEFINITE_MASK
;
}
unsigned
definiteSlot
(
)
const
{
MOZ_ASSERT
(
definiteProperty
(
)
)
;
return
(
flags
>
>
TYPE_FLAG_DEFINITE_SHIFT
)
-
1
;
}
void
addType
(
Type
type
LifoAlloc
*
alloc
)
;
using
TypeList
=
Vector
<
Type
1
SystemAllocPolicy
>
;
bool
enumerateTypes
(
TypeList
*
list
)
const
;
inline
unsigned
getObjectCount
(
)
const
;
inline
bool
hasGroup
(
unsigned
i
)
const
;
inline
bool
hasSingleton
(
unsigned
i
)
const
;
inline
ObjectKey
*
getObject
(
unsigned
i
)
const
;
inline
JSObject
*
getSingleton
(
unsigned
i
)
const
;
inline
ObjectGroup
*
getGroup
(
unsigned
i
)
const
;
inline
JSObject
*
getSingletonNoBarrier
(
unsigned
i
)
const
;
inline
ObjectGroup
*
getGroupNoBarrier
(
unsigned
i
)
const
;
inline
const
JSClass
*
getObjectClass
(
unsigned
i
)
const
;
bool
canSetDefinite
(
unsigned
slot
)
{
return
(
slot
+
1
)
<
=
(
unsigned
(
TYPE_FLAG_DEFINITE_MASK
)
>
>
TYPE_FLAG_DEFINITE_SHIFT
)
;
}
void
setDefinite
(
unsigned
slot
)
{
MOZ_ASSERT
(
canSetDefinite
(
slot
)
)
;
flags
|
=
(
(
slot
+
1
)
<
<
TYPE_FLAG_DEFINITE_SHIFT
)
;
MOZ_ASSERT
(
definiteSlot
(
)
=
=
slot
)
;
}
bool
mightBeMIRType
(
jit
:
:
MIRType
type
)
const
;
bool
isSubset
(
std
:
:
initializer_list
<
jit
:
:
MIRType
>
types
)
const
;
bool
isSubset
(
const
TypeSet
*
other
)
const
;
bool
objectsAreSubset
(
TypeSet
*
other
)
;
bool
equals
(
const
TypeSet
*
other
)
const
{
return
this
-
>
isSubset
(
other
)
&
&
other
-
>
isSubset
(
this
)
;
}
bool
objectsIntersect
(
const
TypeSet
*
other
)
const
;
JS
:
:
Compartment
*
maybeCompartment
(
)
;
static
void
readBarrier
(
const
TypeSet
*
types
)
;
protected
:
uint32_t
baseObjectCount
(
)
const
{
return
(
flags
&
TYPE_FLAG_OBJECT_COUNT_MASK
)
>
>
TYPE_FLAG_OBJECT_COUNT_SHIFT
;
}
inline
void
setBaseObjectCount
(
uint32_t
count
)
;
void
clearObjects
(
)
;
public
:
static
inline
Type
GetValueType
(
const
JS
:
:
Value
&
val
)
;
static
inline
bool
IsUntrackedValue
(
const
JS
:
:
Value
&
val
)
;
static
inline
bool
IsUntrackedMIRType
(
jit
:
:
MIRType
type
)
;
static
inline
Type
GetMaybeUntrackedValueType
(
const
JS
:
:
Value
&
val
)
;
static
inline
Type
GetMaybeUntrackedType
(
jit
:
:
MIRType
type
)
;
static
bool
IsTypeMarked
(
JSRuntime
*
rt
Type
*
v
)
;
static
bool
IsTypeAboutToBeFinalized
(
Type
*
v
)
;
}
JS_HAZ_GC_POINTER
;
#
if
JS_BITS_PER_WORD
=
=
32
static
const
uintptr_t
BaseTypeInferenceMagic
=
0xa1a2b3b4
;
#
else
static
const
uintptr_t
BaseTypeInferenceMagic
=
0xa1a2b3b4c5c6d7d8
;
#
endif
static
const
uintptr_t
ConstraintTypeSetMagic
=
BaseTypeInferenceMagic
+
1
;
#
ifdef
JS_CRASH_DIAGNOSTICS
extern
void
ReportMagicWordFailure
(
uintptr_t
actual
uintptr_t
expected
)
;
extern
void
ReportMagicWordFailure
(
uintptr_t
actual
uintptr_t
expected
uintptr_t
flags
uintptr_t
objectSet
)
;
#
endif
class
ConstraintTypeSet
:
public
TypeSet
{
private
:
#
ifdef
JS_CRASH_DIAGNOSTICS
uintptr_t
magic_
=
ConstraintTypeSetMagic
;
#
endif
public
:
ConstraintTypeSet
(
)
=
default
;
void
checkMagic
(
)
const
{
#
ifdef
JS_CRASH_DIAGNOSTICS
if
(
MOZ_UNLIKELY
(
magic_
!
=
ConstraintTypeSetMagic
)
)
{
ReportMagicWordFailure
(
magic_
ConstraintTypeSetMagic
uintptr_t
(
flags
)
uintptr_t
(
objectSet
)
)
;
}
#
endif
}
void
addType
(
const
AutoSweepBase
&
sweep
JSContext
*
cx
Type
type
)
;
void
makeUnknown
(
const
AutoSweepBase
&
sweep
JSContext
*
cx
)
{
addType
(
sweep
cx
UnknownType
(
)
)
;
}
void
postWriteBarrier
(
JSContext
*
cx
Type
type
)
;
inline
void
sweep
(
const
AutoSweepBase
&
sweep
JS
:
:
Zone
*
zone
)
;
inline
void
trace
(
JS
:
:
Zone
*
zone
JSTracer
*
trc
)
;
}
;
class
HeapTypeSet
:
public
ConstraintTypeSet
{
inline
void
newPropertyState
(
const
AutoSweepObjectGroup
&
sweep
JSContext
*
cx
)
;
public
:
inline
void
setNonDataProperty
(
const
AutoSweepObjectGroup
&
sweep
JSContext
*
cx
)
;
inline
void
setNonWritableProperty
(
const
AutoSweepObjectGroup
&
sweep
JSContext
*
cx
)
;
inline
void
setNonConstantProperty
(
const
AutoSweepObjectGroup
&
sweep
JSContext
*
cx
)
;
inline
void
markLexicalBindingExists
(
const
AutoSweepObjectGroup
&
sweep
JSContext
*
cx
)
;
}
;
enum
class
DOMObjectKind
:
uint8_t
{
Proxy
Native
Unknown
}
;
}
#
endif
