#
ifndef
js_Mutex_h
#
define
js_Mutex_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
jslock
.
h
"
namespace
js
{
namespace
detail
{
class
MutexBase
{
private
:
mutable
PRLock
*
lock_
;
MutexBase
(
const
MutexBase
&
)
=
delete
;
MutexBase
&
operator
=
(
const
MutexBase
&
)
=
delete
;
public
:
MutexBase
(
MutexBase
&
&
rhs
)
:
lock_
(
rhs
.
lock_
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
"
self
-
move
disallowed
!
"
)
;
rhs
.
lock_
=
nullptr
;
}
~
MutexBase
(
)
;
protected
:
explicit
MutexBase
(
PRLock
*
lock
)
:
lock_
(
lock
)
{
MOZ_ASSERT
(
lock_
)
;
}
static
mozilla
:
:
Maybe
<
MutexBase
>
Create
(
)
;
void
acquire
(
)
const
;
void
release
(
)
const
;
}
;
}
template
<
typename
T
>
class
Mutex
:
private
detail
:
:
MutexBase
{
mutable
T
value_
;
Mutex
(
const
Mutex
&
)
=
delete
;
Mutex
&
operator
=
(
const
Mutex
&
)
=
delete
;
template
<
typename
U
>
explicit
Mutex
(
U
&
&
u
MutexBase
&
&
base
)
:
MutexBase
(
mozilla
:
:
Move
(
base
)
)
value_
(
mozilla
:
:
Forward
<
U
>
(
u
)
)
{
}
public
:
template
<
typename
U
>
static
mozilla
:
:
Maybe
<
Mutex
<
T
>
>
Create
(
U
&
&
u
)
{
auto
base
=
detail
:
:
MutexBase
:
:
Create
(
)
;
if
(
base
.
isNothing
(
)
)
return
mozilla
:
:
Nothing
(
)
;
return
mozilla
:
:
Some
(
Mutex
(
mozilla
:
:
Forward
<
U
>
(
u
)
mozilla
:
:
Move
(
*
base
)
)
)
;
}
Mutex
(
Mutex
&
&
rhs
)
:
MutexBase
(
mozilla
:
:
Move
(
static_cast
<
MutexBase
&
&
>
(
rhs
)
)
)
value_
(
mozilla
:
:
Move
(
rhs
.
value_
)
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
"
self
-
move
disallowed
!
"
)
;
}
Mutex
&
operator
=
(
Mutex
&
&
rhs
)
{
this
-
>
~
Mutex
(
)
;
new
(
this
)
Mutex
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
class
MOZ_STACK_CLASS
Guard
{
const
Mutex
*
parent_
;
Guard
(
const
Guard
&
)
=
delete
;
Guard
&
operator
=
(
const
Guard
&
)
=
delete
;
public
:
explicit
Guard
(
const
Mutex
&
parent
)
:
parent_
(
&
parent
)
{
parent_
-
>
acquire
(
)
;
}
Guard
(
Guard
&
&
rhs
)
:
parent_
(
rhs
.
parent_
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
"
self
-
move
disallowed
!
"
)
;
rhs
.
parent_
=
nullptr
;
}
Guard
&
operator
=
(
Guard
&
&
rhs
)
{
this
-
>
~
Guard
(
)
;
new
(
this
)
Guard
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
T
&
get
(
)
const
{
MOZ_ASSERT
(
parent_
)
;
return
parent_
-
>
value_
;
}
operator
T
&
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
&
get
(
)
;
}
~
Guard
(
)
{
if
(
parent_
)
parent_
-
>
release
(
)
;
}
}
;
Guard
lock
(
)
const
{
return
Guard
(
*
this
)
;
}
}
;
}
#
endif
