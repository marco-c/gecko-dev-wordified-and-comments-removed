#
ifndef
vm_Runtime_h
#
define
vm_Runtime_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
setjmp
.
h
>
#
include
"
jsatom
.
h
"
#
include
"
jsclist
.
h
"
#
include
"
jsscript
.
h
"
#
ifdef
XP_DARWIN
#
include
"
asmjs
/
WasmSignalHandlers
.
h
"
#
endif
#
include
"
builtin
/
AtomicsObject
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
ds
/
FixedSizeHash
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
irregexp
/
RegExpStack
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
ifdef
DEBUG
#
include
"
js
/
Proxy
.
h
"
#
endif
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
CodeCoverage
.
h
"
#
include
"
vm
/
CommonPropertyNames
.
h
"
#
include
"
vm
/
DateTime
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
SPSProfiler
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
Stopwatch
.
h
"
#
include
"
vm
/
Symbol
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4100
)
/
*
Silence
unreferenced
formal
parameter
warnings
*
/
#
endif
namespace
js
{
class
PerThreadData
;
class
ExclusiveContext
;
class
AutoKeepAtoms
;
class
EnterDebuggeeNoExecute
;
#
ifdef
JS_TRACE_LOGGING
class
TraceLoggerThread
;
#
endif
typedef
Vector
<
UniquePtr
<
PromiseTask
>
0
SystemAllocPolicy
>
PromiseTaskPtrVector
;
extern
MOZ_THREAD_LOCAL
(
PerThreadData
*
)
TlsPerThreadData
;
}
struct
DtoaState
;
#
ifdef
JS_SIMULATOR_ARM64
namespace
vixl
{
class
Simulator
;
}
#
endif
namespace
js
{
extern
MOZ_COLD
void
ReportOutOfMemory
(
ExclusiveContext
*
cx
)
;
extern
MOZ_COLD
void
ReportAllocationOverflow
(
ExclusiveContext
*
maybecx
)
;
extern
MOZ_COLD
void
ReportOverRecursed
(
ExclusiveContext
*
cx
)
;
class
Activation
;
class
ActivationIterator
;
class
WasmActivation
;
namespace
jit
{
class
JitRuntime
;
class
JitActivation
;
struct
PcScriptCache
;
struct
AutoFlushICache
;
class
CompileRuntime
;
#
ifdef
JS_SIMULATOR_ARM64
typedef
vixl
:
:
Simulator
Simulator
;
#
elif
defined
(
JS_SIMULATOR
)
class
Simulator
;
#
endif
}
class
FreeOp
:
public
JSFreeOp
{
Vector
<
void
*
0
SystemAllocPolicy
>
freeLaterList
;
jit
:
:
JitPoisonRangeVector
jitPoisonRanges
;
public
:
static
FreeOp
*
get
(
JSFreeOp
*
fop
)
{
return
static_cast
<
FreeOp
*
>
(
fop
)
;
}
explicit
FreeOp
(
JSRuntime
*
maybeRuntime
)
;
~
FreeOp
(
)
;
bool
onMainThread
(
)
const
{
return
runtime_
!
=
nullptr
;
}
bool
maybeOffMainThread
(
)
const
{
return
!
runtime_
;
}
bool
isDefaultFreeOp
(
)
const
;
inline
void
free_
(
void
*
p
)
;
inline
void
freeLater
(
void
*
p
)
;
inline
bool
appendJitPoisonRange
(
const
jit
:
:
JitPoisonRange
&
range
)
;
template
<
class
T
>
inline
void
delete_
(
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
free_
(
p
)
;
}
}
}
;
}
namespace
JS
{
struct
RuntimeSizes
;
}
struct
JSAtomState
{
#
define
PROPERTYNAME_FIELD
(
idpart
id
text
)
js
:
:
ImmutablePropertyNamePtr
id
;
FOR_EACH_COMMON_PROPERTYNAME
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
code
init
clasp
)
js
:
:
ImmutablePropertyNamePtr
name
;
JS_FOR_EACH_PROTOTYPE
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
)
js
:
:
ImmutablePropertyNamePtr
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
)
js
:
:
ImmutablePropertyNamePtr
Symbol_
#
#
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
js
:
:
ImmutablePropertyNamePtr
*
wellKnownSymbolNames
(
)
{
#
define
FIRST_PROPERTYNAME_FIELD
(
name
)
return
&
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
FIRST_PROPERTYNAME_FIELD
)
#
undef
FIRST_PROPERTYNAME_FIELD
}
js
:
:
ImmutablePropertyNamePtr
*
wellKnownSymbolDescriptions
(
)
{
#
define
FIRST_PROPERTYNAME_FIELD
(
name
)
return
&
Symbol_
#
#
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
FIRST_PROPERTYNAME_FIELD
)
#
undef
FIRST_PROPERTYNAME_FIELD
}
}
;
namespace
js
{
struct
WellKnownSymbols
{
#
define
DECLARE_SYMBOL
(
name
)
js
:
:
ImmutableSymbolPtr
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
DECLARE_SYMBOL
)
#
undef
DECLARE_SYMBOL
const
ImmutableSymbolPtr
&
get
(
size_t
u
)
const
{
MOZ_ASSERT
(
u
<
JS
:
:
WellKnownSymbolLimit
)
;
const
ImmutableSymbolPtr
*
symbols
=
reinterpret_cast
<
const
ImmutableSymbolPtr
*
>
(
this
)
;
return
symbols
[
u
]
;
}
const
ImmutableSymbolPtr
&
get
(
JS
:
:
SymbolCode
code
)
const
{
return
get
(
size_t
(
code
)
)
;
}
WellKnownSymbols
(
)
{
}
WellKnownSymbols
(
const
WellKnownSymbols
&
)
=
delete
;
WellKnownSymbols
&
operator
=
(
const
WellKnownSymbols
&
)
=
delete
;
}
;
#
define
NAME_OFFSET
(
name
)
offsetof
(
JSAtomState
name
)
inline
HandlePropertyName
AtomStateOffsetToName
(
const
JSAtomState
&
atomState
size_t
offset
)
{
return
*
reinterpret_cast
<
js
:
:
ImmutablePropertyNamePtr
*
>
(
(
char
*
)
&
atomState
+
offset
)
;
}
enum
RuntimeLock
{
ExclusiveAccessLock
HelperThreadStateLock
GCLock
}
;
inline
bool
CanUseExtraThreads
(
)
{
extern
bool
gCanUseExtraThreads
;
return
gCanUseExtraThreads
;
}
void
DisableExtraThreads
(
)
;
class
PerThreadData
{
JSRuntime
*
runtime_
;
public
:
#
ifdef
JS_TRACE_LOGGING
TraceLoggerThread
*
traceLogger
;
#
endif
js
:
:
jit
:
:
AutoFlushICache
*
autoFlushICache_
;
public
:
DtoaState
*
dtoaState
;
int32_t
suppressGC
;
#
ifdef
DEBUG
bool
ionCompiling
;
bool
ionCompilingSafeForMinorGC
;
bool
gcSweeping
;
#
endif
frontend
:
:
NameCollectionPool
frontendCollectionPool
;
explicit
PerThreadData
(
JSRuntime
*
runtime
)
;
~
PerThreadData
(
)
;
bool
init
(
)
;
bool
associatedWith
(
const
JSRuntime
*
rt
)
{
return
runtime_
=
=
rt
;
}
inline
JSRuntime
*
runtimeFromMainThread
(
)
;
inline
JSRuntime
*
runtimeIfOnOwnerThread
(
)
;
JSContext
*
contextFromMainThread
(
)
;
inline
bool
exclusiveThreadsPresent
(
)
;
class
MOZ_STACK_CLASS
AutoEnterRuntime
{
PerThreadData
*
pt
;
public
:
AutoEnterRuntime
(
PerThreadData
*
pt
JSRuntime
*
rt
)
:
pt
(
pt
)
{
MOZ_ASSERT
(
!
pt
-
>
runtime_
)
;
pt
-
>
runtime_
=
rt
;
}
~
AutoEnterRuntime
(
)
{
pt
-
>
runtime_
=
nullptr
;
}
}
;
js
:
:
jit
:
:
AutoFlushICache
*
autoFlushICache
(
)
const
;
void
setAutoFlushICache
(
js
:
:
jit
:
:
AutoFlushICache
*
afc
)
;
#
ifdef
JS_SIMULATOR
js
:
:
jit
:
:
Simulator
*
simulator
(
)
const
;
#
endif
}
;
using
ScriptAndCountsVector
=
GCVector
<
ScriptAndCounts
0
SystemAllocPolicy
>
;
class
AutoLockForExclusiveAccess
;
}
struct
JSRuntime
:
public
JS
:
:
shadow
:
:
Runtime
public
js
:
:
MallocProvider
<
JSRuntime
>
{
js
:
:
PerThreadData
mainThread
;
uint8_t
*
jitTop
;
js
:
:
jit
:
:
JitActivation
*
jitActivation
;
protected
:
mozilla
:
:
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
jitStackLimit_
;
uintptr_t
jitStackLimitNoInterrupt_
;
public
:
uintptr_t
jitStackLimit
(
)
const
{
return
jitStackLimit_
;
}
void
*
addressOfJitStackLimit
(
)
{
return
&
jitStackLimit_
;
}
static
size_t
offsetOfJitStackLimit
(
)
{
return
offsetof
(
JSRuntime
jitStackLimit_
)
;
}
void
*
addressOfJitStackLimitNoInterrupt
(
)
{
return
&
jitStackLimitNoInterrupt_
;
}
js
:
:
irregexp
:
:
RegExpStack
regexpStack
;
#
ifdef
DEBUG
private
:
uint32_t
ionBailAfter_
;
public
:
void
*
addressOfIonBailAfter
(
)
{
return
&
ionBailAfter_
;
}
void
setIonBailAfter
(
uint32_t
after
)
{
ionBailAfter_
=
after
;
}
#
endif
private
:
friend
class
js
:
:
Activation
;
friend
class
js
:
:
ActivationIterator
;
friend
class
js
:
:
jit
:
:
JitActivation
;
friend
class
js
:
:
WasmActivation
;
friend
class
js
:
:
jit
:
:
CompileRuntime
;
protected
:
js
:
:
Activation
*
activation_
;
js
:
:
Activation
*
volatile
profilingActivation_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
profilerSampleBufferGen_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
profilerSampleBufferLapCount_
;
js
:
:
WasmActivation
*
volatile
wasmActivationStack_
;
public
:
JS
:
:
dbg
:
:
AutoEntryMonitor
*
entryMonitor
;
js
:
:
EnterDebuggeeNoExecute
*
noExecuteDebuggerTop
;
js
:
:
Activation
*
const
*
addressOfActivation
(
)
const
{
return
&
activation_
;
}
static
unsigned
offsetOfActivation
(
)
{
return
offsetof
(
JSRuntime
activation_
)
;
}
js
:
:
Activation
*
profilingActivation
(
)
const
{
return
profilingActivation_
;
}
void
*
addressOfProfilingActivation
(
)
{
return
(
void
*
)
&
profilingActivation_
;
}
static
unsigned
offsetOfProfilingActivation
(
)
{
return
offsetof
(
JSRuntime
profilingActivation_
)
;
}
uint32_t
profilerSampleBufferGen
(
)
{
return
profilerSampleBufferGen_
;
}
void
resetProfilerSampleBufferGen
(
)
{
profilerSampleBufferGen_
=
0
;
}
void
setProfilerSampleBufferGen
(
uint32_t
gen
)
{
for
(
;
;
)
{
uint32_t
curGen
=
profilerSampleBufferGen_
;
if
(
curGen
>
=
gen
)
break
;
if
(
profilerSampleBufferGen_
.
compareExchange
(
curGen
gen
)
)
break
;
}
}
uint32_t
profilerSampleBufferLapCount
(
)
{
MOZ_ASSERT
(
profilerSampleBufferLapCount_
>
0
)
;
return
profilerSampleBufferLapCount_
;
}
void
resetProfilerSampleBufferLapCount
(
)
{
profilerSampleBufferLapCount_
=
1
;
}
void
updateProfilerSampleBufferLapCount
(
uint32_t
lapCount
)
{
MOZ_ASSERT
(
profilerSampleBufferLapCount_
>
0
)
;
for
(
;
;
)
{
uint32_t
curLapCount
=
profilerSampleBufferLapCount_
;
if
(
curLapCount
>
=
lapCount
)
break
;
if
(
profilerSampleBufferLapCount_
.
compareExchange
(
curLapCount
lapCount
)
)
break
;
}
}
js
:
:
WasmActivation
*
wasmActivationStack
(
)
const
{
return
wasmActivationStack_
;
}
static
js
:
:
WasmActivation
*
innermostWasmActivation
(
)
{
js
:
:
PerThreadData
*
ptd
=
js
:
:
TlsPerThreadData
.
get
(
)
;
return
ptd
?
ptd
-
>
runtimeFromMainThread
(
)
-
>
wasmActivationStack_
:
nullptr
;
}
js
:
:
Activation
*
activation
(
)
const
{
return
activation_
;
}
JSRuntime
*
parentRuntime
;
private
:
#
ifdef
DEBUG
mozilla
:
:
Atomic
<
size_t
>
childRuntimeCount
;
class
AutoUpdateChildRuntimeCount
{
JSRuntime
*
parent_
;
public
:
explicit
AutoUpdateChildRuntimeCount
(
JSRuntime
*
parent
)
:
parent_
(
parent
)
{
if
(
parent_
)
parent_
-
>
childRuntimeCount
+
+
;
}
~
AutoUpdateChildRuntimeCount
(
)
{
if
(
parent_
)
parent_
-
>
childRuntimeCount
-
-
;
}
}
;
AutoUpdateChildRuntimeCount
updateChildRuntimeCount
;
#
endif
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt_
;
JSAccumulateTelemetryDataCallback
telemetryCallback
;
public
:
void
addTelemetry
(
int
id
uint32_t
sample
const
char
*
key
=
nullptr
)
;
void
setTelemetryCallback
(
JSRuntime
*
rt
JSAccumulateTelemetryDataCallback
callback
)
;
enum
InterruptMode
{
RequestInterruptUrgent
RequestInterruptCanWait
}
;
void
requestInterrupt
(
InterruptMode
mode
)
;
bool
handleInterrupt
(
JSContext
*
cx
)
;
MOZ_ALWAYS_INLINE
bool
hasPendingInterrupt
(
)
const
{
return
interrupt_
;
}
void
*
addressOfInterruptUint32
(
)
{
static_assert
(
sizeof
(
interrupt_
)
=
=
sizeof
(
uint32_t
)
"
Assumed
by
JIT
callers
"
)
;
return
&
interrupt_
;
}
bool
handlingSegFault
;
private
:
mozilla
:
:
Atomic
<
bool
>
handlingJitInterrupt_
;
public
:
bool
startHandlingJitInterrupt
(
)
{
return
handlingJitInterrupt_
.
compareExchange
(
false
true
)
;
}
void
finishHandlingJitInterrupt
(
)
{
MOZ_ASSERT
(
handlingJitInterrupt_
)
;
handlingJitInterrupt_
=
false
;
}
bool
handlingJitInterrupt
(
)
const
{
return
handlingJitInterrupt_
;
}
using
InterruptCallbackVector
=
js
:
:
Vector
<
JSInterruptCallback
2
js
:
:
SystemAllocPolicy
>
;
InterruptCallbackVector
interruptCallbacks
;
bool
interruptCallbackDisabled
;
JSGetIncumbentGlobalCallback
getIncumbentGlobalCallback
;
JSEnqueuePromiseJobCallback
enqueuePromiseJobCallback
;
void
*
enqueuePromiseJobCallbackData
;
JSPromiseRejectionTrackerCallback
promiseRejectionTrackerCallback
;
void
*
promiseRejectionTrackerCallbackData
;
JS
:
:
StartAsyncTaskCallback
startAsyncTaskCallback
;
JS
:
:
FinishAsyncTaskCallback
finishAsyncTaskCallback
;
js
:
:
ExclusiveData
<
js
:
:
PromiseTaskPtrVector
>
promiseTasksToDestroy
;
private
:
js
:
:
Mutex
exclusiveAccessLock
;
#
ifdef
DEBUG
bool
mainThreadHasExclusiveAccess
;
#
endif
size_t
numExclusiveThreads
;
friend
class
js
:
:
AutoLockForExclusiveAccess
;
public
:
void
setUsedByExclusiveThread
(
JS
:
:
Zone
*
zone
)
;
void
clearUsedByExclusiveThread
(
JS
:
:
Zone
*
zone
)
;
bool
exclusiveThreadsPresent
(
)
const
{
return
numExclusiveThreads
>
0
;
}
size_t
numCompartments
;
const
JSLocaleCallbacks
*
localeCallbacks
;
char
*
defaultLocale
;
JSVersion
defaultVersion_
;
js
:
:
FutexRuntime
fx
;
private
:
js
:
:
Thread
:
:
Id
ownerThread_
;
size_t
ownerThreadNative_
;
friend
bool
js
:
:
CurrentThreadCanAccessRuntime
(
JSRuntime
*
rt
)
;
public
:
size_t
ownerThreadNative
(
)
const
{
return
ownerThreadNative_
;
}
static
const
size_t
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
=
4
*
1024
;
js
:
:
LifoAlloc
tempLifoAlloc
;
private
:
js
:
:
jit
:
:
JitRuntime
*
jitRuntime_
;
js
:
:
NativeObject
*
selfHostingGlobal_
;
static
js
:
:
GlobalObject
*
createSelfHostingGlobal
(
JSContext
*
cx
)
;
bool
getUnclonedSelfHostedValue
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
js
:
:
MutableHandleValue
vp
)
;
JSFunction
*
getUnclonedSelfHostedFunction
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
)
;
js
:
:
InterpreterStack
interpreterStack_
;
js
:
:
jit
:
:
JitRuntime
*
createJitRuntime
(
JSContext
*
cx
)
;
public
:
js
:
:
jit
:
:
JitRuntime
*
getJitRuntime
(
JSContext
*
cx
)
{
return
jitRuntime_
?
jitRuntime_
:
createJitRuntime
(
cx
)
;
}
js
:
:
jit
:
:
JitRuntime
*
jitRuntime
(
)
const
{
return
jitRuntime_
;
}
bool
hasJitRuntime
(
)
const
{
return
!
!
jitRuntime_
;
}
js
:
:
InterpreterStack
&
interpreterStack
(
)
{
return
interpreterStack_
;
}
inline
JSContext
*
unsafeContextFromAnyThread
(
)
;
inline
JSContext
*
contextFromMainThread
(
)
;
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
;
bool
enqueuePromiseJob
(
JSContext
*
cx
js
:
:
HandleFunction
job
js
:
:
HandleObject
promise
js
:
:
HandleObject
incumbentGlobal
)
;
void
addUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
void
removeUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
bool
hasInitializedSelfHosting
(
)
const
{
return
selfHostingGlobal_
;
}
bool
initSelfHosting
(
JSContext
*
cx
)
;
void
finishSelfHosting
(
)
;
void
markSelfHostingGlobal
(
JSTracer
*
trc
)
;
bool
isSelfHostingGlobal
(
JSObject
*
global
)
{
return
global
=
=
selfHostingGlobal_
;
}
bool
isSelfHostingCompartment
(
JSCompartment
*
comp
)
const
;
bool
isSelfHostingZone
(
const
JS
:
:
Zone
*
zone
)
const
;
bool
createLazySelfHostedFunctionClone
(
JSContext
*
cx
js
:
:
HandlePropertyName
selfHostedName
js
:
:
HandleAtom
name
unsigned
nargs
js
:
:
HandleObject
proto
js
:
:
NewObjectKind
newKind
js
:
:
MutableHandleFunction
fun
)
;
bool
cloneSelfHostedFunctionScript
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
Handle
<
JSFunction
*
>
targetFun
)
;
bool
cloneSelfHostedValue
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
MutableHandleValue
vp
)
;
void
assertSelfHostedFunctionHasCanonicalName
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
)
;
bool
setDefaultLocale
(
const
char
*
locale
)
;
void
resetDefaultLocale
(
)
;
const
char
*
getDefaultLocale
(
)
;
JSVersion
defaultVersion
(
)
const
{
return
defaultVersion_
;
}
void
setDefaultVersion
(
JSVersion
v
)
{
defaultVersion_
=
v
;
}
const
uintptr_t
nativeStackBase
;
size_t
nativeStackQuota
[
js
:
:
StackKindCount
]
;
JSDestroyCompartmentCallback
destroyCompartmentCallback
;
JSSizeOfIncludingThisCompartmentCallback
sizeOfIncludingThisCompartmentCallback
;
JSZoneCallback
destroyZoneCallback
;
JSZoneCallback
sweepZoneCallback
;
JSCompartmentNameCallback
compartmentNameCallback
;
js
:
:
ActivityCallback
activityCallback
;
void
*
activityCallbackArg
;
void
triggerActivityCallback
(
bool
active
)
;
unsigned
requestDepth
;
#
ifdef
DEBUG
unsigned
checkRequestDepth
;
#
endif
js
:
:
gc
:
:
GCRuntime
gc
;
bool
gcInitialized
;
bool
hasZealMode
(
js
:
:
gc
:
:
ZealMode
mode
)
{
return
gc
.
hasZealMode
(
mode
)
;
}
void
lockGC
(
)
{
gc
.
lockGC
(
)
;
}
void
unlockGC
(
)
{
gc
.
unlockGC
(
)
;
}
#
ifdef
JS_SIMULATOR
js
:
:
jit
:
:
Simulator
*
simulator_
;
#
endif
public
:
#
ifdef
JS_SIMULATOR
js
:
:
jit
:
:
Simulator
*
simulator
(
)
const
;
uintptr_t
*
addressOfSimulatorStackLimit
(
)
;
#
endif
JS
:
:
PersistentRooted
<
js
:
:
ScriptAndCountsVector
>
*
scriptAndCountsVector
;
js
:
:
coverage
:
:
LCovRuntime
lcovOutput
;
const
js
:
:
Value
NaNValue
;
const
js
:
:
Value
negativeInfinityValue
;
const
js
:
:
Value
positiveInfinityValue
;
js
:
:
PropertyName
*
emptyString
;
mozilla
:
:
UniquePtr
<
js
:
:
SourceHook
>
sourceHook
;
js
:
:
SPSProfiler
spsProfiler
;
bool
profilingScripts
;
private
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
suppressProfilerSampling
;
public
:
bool
isProfilerSamplingEnabled
(
)
const
{
return
!
suppressProfilerSampling
;
}
void
disableProfilerSampling
(
)
{
suppressProfilerSampling
=
true
;
}
void
enableProfilerSampling
(
)
{
suppressProfilerSampling
=
false
;
}
bool
hadOutOfMemory
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
bool
runningOOMTest
;
#
endif
bool
allowRelazificationForTesting
;
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
debuggerList
;
JSCList
onNewGlobalObjectWatchers
;
#
if
defined
(
XP_DARWIN
)
js
:
:
wasm
:
:
MachExceptionHandler
wasmMachExceptionHandler
;
#
endif
private
:
js
:
:
FreeOp
*
defaultFreeOp_
;
public
:
js
:
:
FreeOp
*
defaultFreeOp
(
)
{
MOZ_ASSERT
(
defaultFreeOp_
)
;
return
defaultFreeOp_
;
}
uint32_t
debuggerMutations
;
const
JSSecurityCallbacks
*
securityCallbacks
;
const
js
:
:
DOMCallbacks
*
DOMcallbacks
;
JSDestroyPrincipalsOp
destroyPrincipals
;
JSReadPrincipalsOp
readPrincipals
;
JS
:
:
WarningReporter
warningReporter
;
JS
:
:
BuildIdOp
buildIdOp
;
JS
:
:
AsmJSCacheOps
asmJSCacheOps
;
uint32_t
propertyRemovals
;
#
if
!
EXPOSE_INTL_API
const
char
*
thousandsSeparator
;
const
char
*
decimalSeparator
;
const
char
*
numGrouping
;
#
endif
private
:
mozilla
:
:
Maybe
<
js
:
:
SharedImmutableStringsCache
>
sharedImmutableStrings_
;
public
:
js
:
:
SharedImmutableStringsCache
*
maybeThisRuntimeSharedImmutableStrings
(
)
{
return
sharedImmutableStrings_
.
isSome
(
)
?
&
*
sharedImmutableStrings_
:
nullptr
;
}
js
:
:
SharedImmutableStringsCache
&
sharedImmutableStrings
(
)
{
MOZ_ASSERT_IF
(
parentRuntime
!
sharedImmutableStrings_
)
;
MOZ_ASSERT_IF
(
!
parentRuntime
sharedImmutableStrings_
)
;
return
parentRuntime
?
parentRuntime
-
>
sharedImmutableStrings
(
)
:
*
sharedImmutableStrings_
;
}
private
:
unsigned
keepAtoms_
;
friend
class
js
:
:
AutoKeepAtoms
;
public
:
bool
keepAtoms
(
)
{
return
keepAtoms_
!
=
0
|
|
exclusiveThreadsPresent
(
)
;
}
private
:
const
JSPrincipals
*
trustedPrincipals_
;
public
:
void
setTrustedPrincipals
(
const
JSPrincipals
*
p
)
{
trustedPrincipals_
=
p
;
}
const
JSPrincipals
*
trustedPrincipals
(
)
const
{
return
trustedPrincipals_
;
}
private
:
bool
beingDestroyed_
;
public
:
bool
isBeingDestroyed
(
)
const
{
return
beingDestroyed_
;
}
private
:
js
:
:
AtomSet
*
atoms_
;
JSCompartment
*
atomsCompartment_
;
js
:
:
SymbolRegistry
symbolRegistry_
;
public
:
bool
initializeAtoms
(
JSContext
*
cx
)
;
void
finishAtoms
(
)
;
bool
atomsAreFinished
(
)
const
{
return
!
atoms_
;
}
void
sweepAtoms
(
)
;
js
:
:
AtomSet
&
atoms
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
*
atoms_
;
}
JSCompartment
*
atomsCompartment
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
atomsCompartment_
;
}
bool
isAtomsCompartment
(
JSCompartment
*
comp
)
{
return
comp
=
=
atomsCompartment_
;
}
inline
bool
isAtomsZone
(
const
JS
:
:
Zone
*
zone
)
const
;
bool
activeGCInAtomsZone
(
)
;
js
:
:
SymbolRegistry
&
symbolRegistry
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
symbolRegistry_
;
}
js
:
:
StaticStrings
*
staticStrings
;
JSAtomState
*
commonNames
;
js
:
:
FrozenAtomSet
*
permanentAtoms
;
bool
transformToPermanentAtoms
(
JSContext
*
cx
)
;
js
:
:
WellKnownSymbols
*
wellKnownSymbols
;
const
JSWrapObjectCallbacks
*
wrapObjectCallbacks
;
js
:
:
PreserveWrapperCallback
preserveWrapperCallback
;
private
:
js
:
:
ScriptDataTable
scriptDataTable_
;
public
:
js
:
:
ScriptDataTable
&
scriptDataTable
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
scriptDataTable_
;
}
bool
jitSupportsFloatingPoint
;
bool
jitSupportsUnalignedAccesses
;
bool
jitSupportsSimd
;
js
:
:
jit
:
:
PcScriptCache
*
ionPcScriptCache
;
js
:
:
ScriptEnvironmentPreparer
*
scriptEnvironmentPreparer
;
js
:
:
CTypesActivityCallback
ctypesActivityCallback
;
private
:
static
mozilla
:
:
Atomic
<
size_t
>
liveRuntimesCount
;
public
:
static
bool
hasLiveRuntimes
(
)
{
return
liveRuntimesCount
>
0
;
}
protected
:
explicit
JSRuntime
(
JSRuntime
*
parentRuntime
)
;
void
destroyRuntime
(
)
;
bool
init
(
uint32_t
maxbytes
uint32_t
maxNurseryBytes
)
;
JSRuntime
*
thisFromCtor
(
)
{
return
this
;
}
public
:
void
updateMallocCounter
(
size_t
nbytes
)
;
void
updateMallocCounter
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
nullptr
)
;
}
JS_FRIEND_API
(
void
*
)
onOutOfMemory
(
js
:
:
AllocFunction
allocator
size_t
nbytes
void
*
reallocPtr
=
nullptr
JSContext
*
maybecx
=
nullptr
)
;
JS_FRIEND_API
(
void
*
)
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
allocator
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
RuntimeSizes
*
runtime
)
;
private
:
const
js
:
:
Class
*
windowProxyClass_
;
bool
offthreadIonCompilationEnabled_
;
bool
parallelParsingEnabled_
;
bool
autoWritableJitCodeActive_
;
public
:
void
setOffthreadIonCompilationEnabled
(
bool
value
)
{
offthreadIonCompilationEnabled_
=
value
;
}
bool
canUseOffthreadIonCompilation
(
)
const
{
return
offthreadIonCompilationEnabled_
;
}
void
setParallelParsingEnabled
(
bool
value
)
{
parallelParsingEnabled_
=
value
;
}
bool
canUseParallelParsing
(
)
const
{
return
parallelParsingEnabled_
;
}
void
toggleAutoWritableJitCodeActive
(
bool
b
)
{
MOZ_ASSERT
(
autoWritableJitCodeActive_
!
=
b
"
AutoWritableJitCode
should
not
be
nested
.
"
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
this
)
)
;
autoWritableJitCodeActive_
=
b
;
}
const
js
:
:
Class
*
maybeWindowProxyClass
(
)
const
{
return
windowProxyClass_
;
}
void
setWindowProxyClass
(
const
js
:
:
Class
*
clasp
)
{
windowProxyClass_
=
clasp
;
}
#
ifdef
DEBUG
public
:
js
:
:
AutoEnterPolicy
*
enteredPolicy
;
#
endif
JS
:
:
LargeAllocationFailureCallback
largeAllocationFailureCallback
;
void
*
largeAllocationFailureCallbackData
;
JS
:
:
OutOfMemoryCallback
oomCallback
;
void
*
oomCallbackData
;
static
const
unsigned
LARGE_ALLOCATION
=
25
*
1024
*
1024
;
template
<
typename
T
>
T
*
pod_callocCanGC
(
size_t
numElems
)
{
T
*
p
=
pod_calloc
<
T
>
(
numElems
)
;
if
(
MOZ_LIKELY
(
!
!
p
)
)
return
p
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
{
reportAllocationOverflow
(
)
;
return
nullptr
;
}
return
static_cast
<
T
*
>
(
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Calloc
bytes
)
)
;
}
template
<
typename
T
>
T
*
pod_reallocCanGC
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
T
*
p2
=
pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
if
(
MOZ_LIKELY
(
!
!
p2
)
)
return
p2
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
newSize
&
bytes
)
)
)
{
reportAllocationOverflow
(
)
;
return
nullptr
;
}
return
static_cast
<
T
*
>
(
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Realloc
bytes
p
)
)
;
}
mozilla
:
:
MallocSizeOf
debuggerMallocSizeOf
;
int64_t
lastAnimationTime
;
public
:
js
:
:
PerformanceMonitoring
performanceMonitoring
;
private
:
typedef
mozilla
:
:
LinkedList
<
js
:
:
jit
:
:
IonBuilder
>
IonBuilderList
;
IonBuilderList
ionLazyLinkList_
;
size_t
ionLazyLinkListSize_
;
public
:
IonBuilderList
&
ionLazyLinkList
(
)
;
size_t
ionLazyLinkListSize
(
)
{
return
ionLazyLinkListSize_
;
}
void
ionLazyLinkListRemove
(
js
:
:
jit
:
:
IonBuilder
*
builder
)
;
void
ionLazyLinkListAdd
(
js
:
:
jit
:
:
IonBuilder
*
builder
)
;
private
:
mozilla
:
:
Atomic
<
js
:
:
StackFormat
mozilla
:
:
ReleaseAcquire
>
stackFormat_
;
public
:
js
:
:
StackFormat
stackFormat
(
)
const
{
const
JSRuntime
*
rt
=
this
;
while
(
rt
-
>
parentRuntime
)
{
MOZ_ASSERT
(
rt
-
>
stackFormat_
=
=
js
:
:
StackFormat
:
:
Default
)
;
rt
=
rt
-
>
parentRuntime
;
}
MOZ_ASSERT
(
rt
-
>
stackFormat_
!
=
js
:
:
StackFormat
:
:
Default
)
;
return
rt
-
>
stackFormat_
;
}
void
setStackFormat
(
js
:
:
StackFormat
format
)
{
MOZ_ASSERT
(
!
parentRuntime
)
;
MOZ_ASSERT
(
format
!
=
js
:
:
StackFormat
:
:
Default
)
;
stackFormat_
=
format
;
}
}
;
namespace
js
{
static
inline
JSContext
*
GetJSContextFromMainThread
(
)
{
return
js
:
:
TlsPerThreadData
.
get
(
)
-
>
contextFromMainThread
(
)
;
}
namespace
VersionFlags
{
static
const
unsigned
MASK
=
0x0FFF
;
}
static
inline
JSVersion
VersionNumber
(
JSVersion
version
)
{
return
JSVersion
(
uint32_t
(
version
)
&
VersionFlags
:
:
MASK
)
;
}
static
inline
JSVersion
VersionExtractFlags
(
JSVersion
version
)
{
return
JSVersion
(
uint32_t
(
version
)
&
~
VersionFlags
:
:
MASK
)
;
}
static
inline
void
VersionCopyFlags
(
JSVersion
*
version
JSVersion
from
)
{
*
version
=
JSVersion
(
VersionNumber
(
*
version
)
|
VersionExtractFlags
(
from
)
)
;
}
static
inline
bool
VersionHasFlags
(
JSVersion
version
)
{
return
!
!
VersionExtractFlags
(
version
)
;
}
static
inline
bool
VersionIsKnown
(
JSVersion
version
)
{
return
VersionNumber
(
version
)
!
=
JSVERSION_UNKNOWN
;
}
inline
void
FreeOp
:
:
free_
(
void
*
p
)
{
js_free
(
p
)
;
}
inline
void
FreeOp
:
:
freeLater
(
void
*
p
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
freeLaterList
.
append
(
p
)
)
oomUnsafe
.
crash
(
"
FreeOp
:
:
freeLater
"
)
;
}
inline
bool
FreeOp
:
:
appendJitPoisonRange
(
const
jit
:
:
JitPoisonRange
&
range
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
return
jitPoisonRanges
.
append
(
range
)
;
}
class
MOZ_RAII
AutoLockGC
{
public
:
explicit
AutoLockGC
(
JSRuntime
*
rt
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
runtime_
(
rt
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
lock
(
)
;
}
~
AutoLockGC
(
)
{
unlock
(
)
;
}
void
lock
(
)
{
MOZ_ASSERT
(
lockGuard_
.
isNothing
(
)
)
;
lockGuard_
.
emplace
(
runtime_
-
>
gc
.
lock
)
;
}
void
unlock
(
)
{
MOZ_ASSERT
(
lockGuard_
.
isSome
(
)
)
;
lockGuard_
.
reset
(
)
;
}
js
:
:
LockGuard
<
js
:
:
Mutex
>
&
guard
(
)
{
return
lockGuard_
.
ref
(
)
;
}
private
:
JSRuntime
*
runtime_
;
mozilla
:
:
Maybe
<
js
:
:
LockGuard
<
js
:
:
Mutex
>
>
lockGuard_
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
AutoLockGC
(
const
AutoLockGC
&
)
=
delete
;
AutoLockGC
&
operator
=
(
const
AutoLockGC
&
)
=
delete
;
}
;
class
MOZ_RAII
AutoUnlockGC
{
public
:
explicit
AutoUnlockGC
(
AutoLockGC
&
lock
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
lock
(
lock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
lock
.
unlock
(
)
;
}
~
AutoUnlockGC
(
)
{
lock
.
lock
(
)
;
}
private
:
AutoLockGC
&
lock
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
AutoUnlockGC
(
const
AutoUnlockGC
&
)
=
delete
;
AutoUnlockGC
&
operator
=
(
const
AutoUnlockGC
&
)
=
delete
;
}
;
class
MOZ_RAII
AutoKeepAtoms
{
PerThreadData
*
pt
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoKeepAtoms
(
PerThreadData
*
pt
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
pt
(
pt
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
JSRuntime
*
rt
=
pt
-
>
runtimeIfOnOwnerThread
(
)
)
{
rt
-
>
keepAtoms_
+
+
;
}
else
{
MOZ_ASSERT
(
pt
-
>
exclusiveThreadsPresent
(
)
)
;
}
}
~
AutoKeepAtoms
(
)
{
if
(
JSRuntime
*
rt
=
pt
-
>
runtimeIfOnOwnerThread
(
)
)
{
MOZ_ASSERT
(
rt
-
>
keepAtoms_
)
;
rt
-
>
keepAtoms_
-
-
;
if
(
rt
-
>
gc
.
fullGCForAtomsRequested
(
)
&
&
!
rt
-
>
keepAtoms
(
)
)
rt
-
>
gc
.
triggerFullGCForAtoms
(
)
;
}
}
}
;
inline
JSRuntime
*
PerThreadData
:
:
runtimeFromMainThread
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
inline
JSRuntime
*
PerThreadData
:
:
runtimeIfOnOwnerThread
(
)
{
return
(
runtime_
&
&
CurrentThreadCanAccessRuntime
(
runtime_
)
)
?
runtime_
:
nullptr
;
}
inline
bool
PerThreadData
:
:
exclusiveThreadsPresent
(
)
{
return
runtime_
-
>
exclusiveThreadsPresent
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
vec
size_t
len
)
{
mozilla
:
:
PodZero
(
vec
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
beg
Value
*
end
)
{
mozilla
:
:
PodZero
(
beg
end
-
beg
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
beg
jsid
*
end
)
{
for
(
jsid
*
id
=
beg
;
id
!
=
end
;
+
+
id
)
*
id
=
INT_TO_JSID
(
0
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
vec
size_t
len
)
{
MakeRangeGCSafe
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
beg
Shape
*
*
end
)
{
mozilla
:
:
PodZero
(
beg
end
-
beg
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
vec
size_t
len
)
{
mozilla
:
:
PodZero
(
vec
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
v
-
>
setUndefined
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
vec
size_t
len
)
{
SetValueRangeToUndefined
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
v
-
>
setNull
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
vec
size_t
len
)
{
SetValueRangeToNull
(
vec
vec
+
len
)
;
}
class
RuntimeAllocPolicy
{
JSRuntime
*
const
runtime
;
public
:
MOZ_IMPLICIT
RuntimeAllocPolicy
(
JSRuntime
*
rt
)
:
runtime
(
rt
)
{
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
return
runtime
-
>
maybe_pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
return
runtime
-
>
maybe_pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
runtime
-
>
maybe_pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
runtime
-
>
pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
runtime
-
>
pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
runtime
-
>
pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
void
free_
(
void
*
p
)
{
js_free
(
p
)
;
}
void
reportAllocOverflow
(
)
const
{
}
bool
checkSimulatedOOM
(
)
const
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
}
;
extern
const
JSSecurityCallbacks
NullSecurityCallbacks
;
class
MOZ_RAII
AutoEnterIonCompilation
{
public
:
explicit
AutoEnterIonCompilation
(
bool
safeForMinorGC
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
DEBUG
PerThreadData
*
pt
=
js
:
:
TlsPerThreadData
.
get
(
)
;
MOZ_ASSERT
(
!
pt
-
>
ionCompiling
)
;
MOZ_ASSERT
(
!
pt
-
>
ionCompilingSafeForMinorGC
)
;
pt
-
>
ionCompiling
=
true
;
pt
-
>
ionCompilingSafeForMinorGC
=
safeForMinorGC
;
#
endif
}
~
AutoEnterIonCompilation
(
)
{
#
ifdef
DEBUG
PerThreadData
*
pt
=
js
:
:
TlsPerThreadData
.
get
(
)
;
MOZ_ASSERT
(
pt
-
>
ionCompiling
)
;
pt
-
>
ionCompiling
=
false
;
pt
-
>
ionCompilingSafeForMinorGC
=
false
;
#
endif
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
namespace
gc
{
struct
MOZ_RAII
AutoSetThreadIsSweeping
{
#
ifdef
DEBUG
AutoSetThreadIsSweeping
(
)
:
threadData_
(
js
:
:
TlsPerThreadData
.
get
(
)
)
{
MOZ_ASSERT
(
!
threadData_
-
>
gcSweeping
)
;
threadData_
-
>
gcSweeping
=
true
;
}
~
AutoSetThreadIsSweeping
(
)
{
MOZ_ASSERT
(
threadData_
-
>
gcSweeping
)
;
threadData_
-
>
gcSweeping
=
false
;
}
private
:
PerThreadData
*
threadData_
;
#
else
AutoSetThreadIsSweeping
(
)
{
}
#
endif
}
;
}
template
<
typename
T
>
struct
GCManagedDeletePolicy
{
void
operator
(
)
(
const
T
*
ptr
)
{
if
(
ptr
)
{
JSRuntime
*
rt
=
TlsPerThreadData
.
get
(
)
-
>
runtimeIfOnOwnerThread
(
)
;
if
(
rt
&
&
rt
-
>
gc
.
nursery
.
isEnabled
(
)
)
{
rt
-
>
gc
.
callAfterMinorGC
(
deletePtr
const_cast
<
T
*
>
(
ptr
)
)
;
}
else
{
gc
:
:
AutoSetThreadIsSweeping
threadIsSweeping
;
js_delete
(
const_cast
<
T
*
>
(
ptr
)
)
;
}
}
}
private
:
static
void
deletePtr
(
void
*
data
)
{
js_delete
(
reinterpret_cast
<
T
*
>
(
data
)
)
;
}
}
;
}
namespace
JS
{
template
<
typename
T
>
struct
DeletePolicy
<
js
:
:
GCPtr
<
T
>
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
GCPtr
<
T
>
>
{
}
;
template
<
>
struct
DeletePolicy
<
js
:
:
FunctionScope
:
:
Data
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
FunctionScope
:
:
Data
>
{
}
;
template
<
>
struct
DeletePolicy
<
js
:
:
ModuleScope
:
:
Data
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
ModuleScope
:
:
Data
>
{
}
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
endif
