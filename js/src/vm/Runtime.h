#
ifndef
vm_Runtime_h
#
define
vm_Runtime_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DoublyLinkedList
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
<
algorithm
>
#
ifdef
JS_HAS_INTL_API
#
include
"
builtin
/
intl
/
SharedIntlData
.
h
"
#
endif
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
AllocationRecording
.
h
"
#
include
"
js
/
BuildId
.
h
"
#
include
"
js
/
Context
.
h
"
#
include
"
js
/
experimental
/
CTypes
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
friend
/
UsageStatistics
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
MemoryCallbacks
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
js
/
ScriptPrivate
.
h
"
#
include
"
js
/
ShadowRealmCallbacks
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
js
/
StreamConsumer
.
h
"
#
include
"
js
/
Symbol
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
WaitCallbacks
.
h
"
#
include
"
js
/
Warnings
.
h
"
#
include
"
js
/
Zone
.
h
"
#
include
"
vm
/
Caches
.
h
"
#
include
"
vm
/
CodeCoverage
.
h
"
#
include
"
vm
/
GeckoProfiler
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
OffThreadPromiseRuntimeState
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
struct
JSAtomState
;
struct
JSClass
;
struct
JSErrorInterceptor
;
struct
JSWrapObjectCallbacks
;
namespace
js
{
class
AutoAssertNoContentJS
;
class
Debugger
;
class
EnterDebuggeeNoExecute
;
class
ErrorContext
;
class
StaticStrings
;
}
struct
DtoaState
;
struct
JSLocaleCallbacks
;
#
ifdef
JS_SIMULATOR_ARM64
namespace
vixl
{
class
Simulator
;
}
#
endif
namespace
js
{
extern
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
extern
MOZ_COLD
void
ReportAllocationOverflow
(
JSContext
*
maybecx
)
;
extern
MOZ_COLD
void
ReportAllocationOverflow
(
ErrorContext
*
ec
)
;
extern
MOZ_COLD
void
ReportOversizedAllocation
(
JSContext
*
cx
const
unsigned
errorNumber
)
;
class
Activation
;
class
ActivationIterator
;
class
Shape
;
class
SourceHook
;
namespace
jit
{
class
JitRuntime
;
class
JitActivation
;
struct
PcScriptCache
;
class
CompileRuntime
;
#
ifdef
JS_SIMULATOR_ARM64
typedef
vixl
:
:
Simulator
Simulator
;
#
elif
defined
(
JS_SIMULATOR
)
class
Simulator
;
#
endif
}
namespace
frontend
{
struct
CompilationInput
;
struct
CompilationStencil
;
class
WellKnownParserAtoms
;
}
}
namespace
JS
{
struct
RuntimeSizes
;
}
namespace
js
{
struct
WellKnownSymbols
{
#
define
DECLARE_SYMBOL
(
name
)
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
DECLARE_SYMBOL
)
#
undef
DECLARE_SYMBOL
const
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
&
get
(
size_t
u
)
const
{
MOZ_ASSERT
(
u
<
JS
:
:
WellKnownSymbolLimit
)
;
const
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
*
symbols
=
reinterpret_cast
<
const
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
*
>
(
this
)
;
return
symbols
[
u
]
;
}
const
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
&
get
(
JS
:
:
SymbolCode
code
)
const
{
return
get
(
size_t
(
code
)
)
;
}
WellKnownSymbols
(
)
=
default
;
WellKnownSymbols
(
const
WellKnownSymbols
&
)
=
delete
;
WellKnownSymbols
&
operator
=
(
const
WellKnownSymbols
&
)
=
delete
;
}
;
enum
RuntimeLock
{
HelperThreadStateLock
GCLock
}
;
inline
bool
CanUseExtraThreads
(
)
{
extern
bool
gCanUseExtraThreads
;
return
gCanUseExtraThreads
;
}
void
DisableExtraThreads
(
)
;
using
ScriptAndCountsVector
=
GCVector
<
ScriptAndCounts
0
SystemAllocPolicy
>
;
class
AutoLockScriptData
;
struct
SelfHostedLazyScript
{
SelfHostedLazyScript
(
)
=
default
;
uint8_t
*
jitCodeRaw_
=
nullptr
;
ScriptWarmUpData
warmUpData_
=
{
}
;
static
constexpr
size_t
offsetOfJitCodeRaw
(
)
{
return
offsetof
(
SelfHostedLazyScript
jitCodeRaw_
)
;
}
static
constexpr
size_t
offsetOfWarmUpData
(
)
{
return
offsetof
(
SelfHostedLazyScript
warmUpData_
)
;
}
}
;
class
Metrics
{
private
:
JSRuntime
*
rt_
;
public
:
explicit
Metrics
(
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
struct
TimeDuration_S
{
using
SourceType
=
mozilla
:
:
TimeDuration
;
static
uint32_t
convert
(
SourceType
td
)
{
return
uint32_t
(
td
.
ToSeconds
(
)
)
;
}
}
;
struct
TimeDuration_MS
{
using
SourceType
=
mozilla
:
:
TimeDuration
;
static
uint32_t
convert
(
SourceType
td
)
{
return
uint32_t
(
td
.
ToMilliseconds
(
)
)
;
}
}
;
struct
TimeDuration_US
{
using
SourceType
=
mozilla
:
:
TimeDuration
;
static
uint32_t
convert
(
SourceType
td
)
{
return
uint32_t
(
td
.
ToMicroseconds
(
)
)
;
}
}
;
struct
MemoryDistribution
{
using
SourceType
=
size_t
;
static
uint32_t
convert
(
SourceType
sz
)
{
return
static_cast
<
uint32_t
>
(
std
:
:
min
(
sz
size_t
(
UINT32_MAX
)
)
)
;
}
}
;
using
QuantityDistribution
=
MemoryDistribution
;
struct
Boolean
{
using
SourceType
=
bool
;
static
uint32_t
convert
(
SourceType
sample
)
{
return
static_cast
<
uint32_t
>
(
sample
)
;
}
}
;
struct
Enumeration
{
using
SourceType
=
int
;
static
uint32_t
convert
(
SourceType
sample
)
{
MOZ_ASSERT
(
sample
<
=
100
)
;
return
static_cast
<
uint32_t
>
(
sample
)
;
}
}
;
struct
Percentage
{
using
SourceType
=
int
;
static
uint32_t
convert
(
SourceType
sample
)
{
MOZ_ASSERT
(
sample
<
=
100
)
;
return
static_cast
<
uint32_t
>
(
sample
)
;
}
}
;
inline
void
addTelemetry
(
JSMetric
id
uint32_t
sample
)
;
#
define
DECLARE_METRIC_HELPER
(
NAME
TY
)
\
void
NAME
(
TY
:
:
SourceType
sample
)
{
\
addTelemetry
(
JSMetric
:
:
NAME
TY
:
:
convert
(
sample
)
)
;
\
}
FOR_EACH_JS_METRIC
(
DECLARE_METRIC_HELPER
)
#
undef
DECLARE_METRIC_HELPER
}
;
}
struct
JSRuntime
{
private
:
friend
class
js
:
:
Activation
;
friend
class
js
:
:
ActivationIterator
;
friend
class
js
:
:
jit
:
:
JitActivation
;
friend
class
js
:
:
jit
:
:
CompileRuntime
;
js
:
:
MainThreadData
<
js
:
:
InterpreterStack
>
interpreterStack_
;
public
:
js
:
:
InterpreterStack
&
interpreterStack
(
)
{
return
interpreterStack_
.
ref
(
)
;
}
JSRuntime
*
const
parentRuntime
;
bool
isMainRuntime
(
)
const
{
return
!
parentRuntime
;
}
#
ifdef
DEBUG
mozilla
:
:
Atomic
<
size_t
>
childRuntimeCount
;
class
AutoUpdateChildRuntimeCount
{
JSRuntime
*
parent_
;
public
:
explicit
AutoUpdateChildRuntimeCount
(
JSRuntime
*
parent
)
:
parent_
(
parent
)
{
if
(
parent_
)
{
parent_
-
>
childRuntimeCount
+
+
;
}
}
~
AutoUpdateChildRuntimeCount
(
)
{
if
(
parent_
)
{
parent_
-
>
childRuntimeCount
-
-
;
}
}
}
;
AutoUpdateChildRuntimeCount
updateChildRuntimeCount
;
#
endif
private
:
#
ifdef
DEBUG
js
:
:
WriteOnceData
<
bool
>
initialized_
;
#
endif
JSContext
*
mainContext_
;
public
:
JSContext
*
mainContextFromAnyThread
(
)
const
{
return
mainContext_
;
}
const
void
*
addressOfMainContext
(
)
{
return
&
mainContext_
;
}
js
:
:
Fprinter
parserWatcherFile
;
inline
JSContext
*
mainContextFromOwnThread
(
)
;
js
:
:
Metrics
metrics
(
)
{
return
js
:
:
Metrics
(
this
)
;
}
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
profilerSampleBufferRangeStart_
;
mozilla
:
:
Maybe
<
uint64_t
>
profilerSampleBufferRangeStart
(
)
{
if
(
beingDestroyed_
|
|
!
geckoProfiler
(
)
.
enabled
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
uint64_t
rangeStart
=
profilerSampleBufferRangeStart_
;
return
mozilla
:
:
Some
(
rangeStart
)
;
}
void
setProfilerSampleBufferRangeStart
(
uint64_t
rangeStart
)
{
profilerSampleBufferRangeStart_
=
rangeStart
;
}
JSAccumulateTelemetryDataCallback
telemetryCallback
;
js
:
:
MainThreadData
<
JSSetUseCounterCallback
>
useCounterCallback
;
public
:
void
addTelemetry
(
JSMetric
id
uint32_t
sample
)
;
void
setTelemetryCallback
(
JSRuntime
*
rt
JSAccumulateTelemetryDataCallback
callback
)
;
void
setUseCounter
(
JSObject
*
obj
JSUseCounter
counter
)
;
void
setUseCounterCallback
(
JSRuntime
*
rt
JSSetUseCounterCallback
callback
)
;
public
:
js
:
:
UnprotectedData
<
js
:
:
OffThreadPromiseRuntimeState
>
offThreadPromiseState
;
js
:
:
UnprotectedData
<
JS
:
:
ConsumeStreamCallback
>
consumeStreamCallback
;
js
:
:
UnprotectedData
<
JS
:
:
ReportStreamErrorCallback
>
reportStreamErrorCallback
;
js
:
:
GlobalObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
;
bool
enqueuePromiseJob
(
JSContext
*
cx
js
:
:
HandleFunction
job
js
:
:
HandleObject
promise
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
incumbentGlobal
)
;
void
addUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
void
removeUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
hadOutOfMemory
;
js
:
:
MainThreadData
<
bool
>
allowRelazificationForTesting
;
js
:
:
MainThreadData
<
JSDestroyZoneCallback
>
destroyZoneCallback
;
js
:
:
MainThreadData
<
JSDestroyCompartmentCallback
>
destroyCompartmentCallback
;
js
:
:
MainThreadData
<
JSSizeOfIncludingThisCompartmentCallback
>
sizeOfIncludingThisCompartmentCallback
;
void
(
*
constructUbiNodeForDOMObjectCallback
)
(
void
*
JSObject
*
)
=
nullptr
;
js
:
:
MainThreadData
<
JS
:
:
DestroyRealmCallback
>
destroyRealmCallback
;
js
:
:
MainThreadData
<
JS
:
:
RealmNameCallback
>
realmNameCallback
;
js
:
:
MainThreadData
<
mozilla
:
:
UniquePtr
<
js
:
:
SourceHook
>
>
sourceHook
;
js
:
:
MainThreadData
<
const
JSSecurityCallbacks
*
>
securityCallbacks
;
js
:
:
MainThreadData
<
const
js
:
:
DOMCallbacks
*
>
DOMcallbacks
;
js
:
:
MainThreadData
<
JSDestroyPrincipalsOp
>
destroyPrincipals
;
js
:
:
MainThreadData
<
JSReadPrincipalsOp
>
readPrincipals
;
js
:
:
MainThreadData
<
JS
:
:
WarningReporter
>
warningReporter
;
js
:
:
UnprotectedData
<
js
:
:
SelfHostedLazyScript
>
selfHostedLazyScript
;
private
:
js
:
:
WriteOnceData
<
js
:
:
frontend
:
:
CompilationInput
*
>
selfHostStencilInput_
;
js
:
:
WriteOnceData
<
js
:
:
frontend
:
:
CompilationStencil
*
>
selfHostStencil_
;
public
:
js
:
:
frontend
:
:
CompilationInput
&
selfHostStencilInput
(
)
{
MOZ_ASSERT
(
hasSelfHostStencil
(
)
)
;
return
*
selfHostStencilInput_
.
ref
(
)
;
}
js
:
:
frontend
:
:
CompilationStencil
&
selfHostStencil
(
)
{
MOZ_ASSERT
(
hasSelfHostStencil
(
)
)
;
return
*
selfHostStencil_
.
ref
(
)
;
}
bool
hasSelfHostStencil
(
)
const
{
return
bool
(
selfHostStencil_
.
ref
(
)
)
;
}
js
:
:
MainThreadData
<
JS
:
:
GCHashMap
<
js
:
:
PreBarriered
<
JSAtom
*
>
js
:
:
frontend
:
:
ScriptIndexRange
js
:
:
DefaultHasher
<
JSAtom
*
>
js
:
:
SystemAllocPolicy
>
>
selfHostScriptMap
;
private
:
js
:
:
UnprotectedData
<
js
:
:
GeckoProfilerRuntime
>
geckoProfiler_
;
public
:
js
:
:
GeckoProfilerRuntime
&
geckoProfiler
(
)
{
return
geckoProfiler_
.
ref
(
)
;
}
js
:
:
MainThreadData
<
mozilla
:
:
EnumeratedArray
<
JS
:
:
RootKind
JS
:
:
RootKind
:
:
Limit
mozilla
:
:
LinkedList
<
js
:
:
PersistentRootedBase
>
>
>
heapRoots
;
void
tracePersistentRoots
(
JSTracer
*
trc
)
;
void
finishPersistentRoots
(
)
;
void
finishRoots
(
)
;
private
:
js
:
:
UnprotectedData
<
const
JSPrincipals
*
>
trustedPrincipals_
;
public
:
void
setTrustedPrincipals
(
const
JSPrincipals
*
p
)
{
trustedPrincipals_
=
p
;
}
const
JSPrincipals
*
trustedPrincipals
(
)
const
{
return
trustedPrincipals_
;
}
js
:
:
MainThreadData
<
const
JSWrapObjectCallbacks
*
>
wrapObjectCallbacks
;
js
:
:
MainThreadData
<
js
:
:
PreserveWrapperCallback
>
preserveWrapperCallback
;
js
:
:
MainThreadData
<
js
:
:
HasReleasedWrapperCallback
>
hasReleasedWrapperCallback
;
js
:
:
MainThreadData
<
js
:
:
ScriptEnvironmentPreparer
*
>
scriptEnvironmentPreparer
;
js
:
:
MainThreadData
<
JS
:
:
CTypesActivityCallback
>
ctypesActivityCallback
;
private
:
js
:
:
WriteOnceData
<
const
JSClass
*
>
windowProxyClass_
;
public
:
const
JSClass
*
maybeWindowProxyClass
(
)
const
{
return
windowProxyClass_
;
}
void
setWindowProxyClass
(
const
JSClass
*
clasp
)
{
windowProxyClass_
=
clasp
;
}
private
:
js
:
:
MainThreadData
<
mozilla
:
:
LinkedList
<
JS
:
:
detail
:
:
WeakCacheBase
>
>
weakCaches_
;
public
:
mozilla
:
:
LinkedList
<
JS
:
:
detail
:
:
WeakCacheBase
>
&
weakCaches
(
)
{
return
weakCaches_
.
ref
(
)
;
}
void
registerWeakCache
(
JS
:
:
detail
:
:
WeakCacheBase
*
cachep
)
{
weakCaches
(
)
.
insertBack
(
cachep
)
;
}
template
<
typename
T
>
struct
GlobalObjectWatchersLinkAccess
{
static
mozilla
:
:
DoublyLinkedListElement
<
T
>
&
Get
(
T
*
aThis
)
{
return
aThis
-
>
onNewGlobalObjectWatchersLink
;
}
}
;
template
<
typename
T
>
struct
GarbageCollectionWatchersLinkAccess
{
static
mozilla
:
:
DoublyLinkedListElement
<
T
>
&
Get
(
T
*
aThis
)
{
return
aThis
-
>
onGarbageCollectionWatchersLink
;
}
}
;
using
OnNewGlobalWatchersList
=
mozilla
:
:
DoublyLinkedList
<
js
:
:
Debugger
GlobalObjectWatchersLinkAccess
<
js
:
:
Debugger
>
>
;
using
OnGarbageCollectionWatchersList
=
mozilla
:
:
DoublyLinkedList
<
js
:
:
Debugger
GarbageCollectionWatchersLinkAccess
<
js
:
:
Debugger
>
>
;
private
:
js
:
:
MainThreadData
<
OnNewGlobalWatchersList
>
onNewGlobalObjectWatchers_
;
js
:
:
MainThreadData
<
OnGarbageCollectionWatchersList
>
onGarbageCollectionWatchers_
;
public
:
OnNewGlobalWatchersList
&
onNewGlobalObjectWatchers
(
)
{
return
onNewGlobalObjectWatchers_
.
ref
(
)
;
}
OnGarbageCollectionWatchersList
&
onGarbageCollectionWatchers
(
)
{
return
onGarbageCollectionWatchers_
.
ref
(
)
;
}
private
:
js
:
:
MainThreadData
<
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
>
debuggerList_
;
public
:
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
&
debuggerList
(
)
{
return
debuggerList_
.
ref
(
)
;
}
private
:
js
:
:
Mutex
scriptDataLock
MOZ_UNANNOTATED
;
#
ifdef
DEBUG
bool
activeThreadHasScriptDataAccess
;
#
endif
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
SequentiallyConsistent
>
numParseTasks
;
friend
class
js
:
:
AutoLockScriptData
;
public
:
bool
hasParseTasks
(
)
const
{
return
numParseTasks
>
0
;
}
void
addParseTaskRef
(
)
{
numParseTasks
+
+
;
}
void
decParseTaskRef
(
)
{
numParseTasks
-
-
;
}
#
ifdef
DEBUG
void
assertCurrentThreadHasScriptDataAccess
(
)
const
{
if
(
!
hasParseTasks
(
)
)
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
this
)
&
&
activeThreadHasScriptDataAccess
)
;
return
;
}
scriptDataLock
.
assertOwnedByCurrentThread
(
)
;
}
#
endif
JS
:
:
HeapState
heapState
(
)
const
{
return
gc
.
heapState
(
)
;
}
js
:
:
MainThreadData
<
size_t
>
numRealms
;
js
:
:
MainThreadData
<
JS
:
:
RecordAllocationsCallback
>
recordAllocationCallback
;
js
:
:
MainThreadData
<
double
>
allocationSamplingProbability
;
private
:
js
:
:
MainThreadData
<
size_t
>
numDebuggeeRealms_
;
js
:
:
MainThreadData
<
size_t
>
numDebuggeeRealmsObservingCoverage_
;
public
:
void
incrementNumDebuggeeRealms
(
)
;
void
decrementNumDebuggeeRealms
(
)
;
size_t
numDebuggeeRealms
(
)
const
{
return
numDebuggeeRealms_
;
}
void
incrementNumDebuggeeRealmsObservingCoverage
(
)
;
void
decrementNumDebuggeeRealmsObservingCoverage
(
)
;
void
startRecordingAllocations
(
double
probability
JS
:
:
RecordAllocationsCallback
callback
)
;
void
stopRecordingAllocations
(
)
;
void
ensureRealmIsRecordingAllocations
(
JS
:
:
Handle
<
js
:
:
GlobalObject
*
>
global
)
;
js
:
:
MainThreadData
<
const
JSLocaleCallbacks
*
>
localeCallbacks
;
js
:
:
MainThreadData
<
js
:
:
UniqueChars
>
defaultLocale
;
js
:
:
MainThreadOrIonCompileData
<
bool
>
profilingScripts
;
js
:
:
MainThreadData
<
JS
:
:
PersistentRooted
<
js
:
:
ScriptAndCountsVector
>
*
>
scriptAndCountsVector
;
private
:
js
:
:
UnprotectedData
<
js
:
:
coverage
:
:
LCovRuntime
>
lcovOutput_
;
public
:
js
:
:
coverage
:
:
LCovRuntime
&
lcovOutput
(
)
{
return
lcovOutput_
.
ref
(
)
;
}
private
:
js
:
:
UnprotectedData
<
js
:
:
jit
:
:
JitRuntime
*
>
jitRuntime_
;
public
:
mozilla
:
:
Maybe
<
js
:
:
frontend
:
:
ScriptIndexRange
>
getSelfHostedScriptIndexRange
(
js
:
:
PropertyName
*
name
)
;
[
[
nodiscard
]
]
bool
createJitRuntime
(
JSContext
*
cx
)
;
js
:
:
jit
:
:
JitRuntime
*
jitRuntime
(
)
const
{
return
jitRuntime_
.
ref
(
)
;
}
bool
hasJitRuntime
(
)
const
{
return
!
!
jitRuntime_
;
}
private
:
mozilla
:
:
Maybe
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
randomKeyGenerator_
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
&
randomKeyGenerator
(
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
randomHashCodeGenerator_
;
public
:
mozilla
:
:
HashCodeScrambler
randomHashCodeScrambler
(
)
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
forkRandomKeyGenerator
(
)
;
js
:
:
HashNumber
randomHashCode
(
)
;
bool
hasInitializedSelfHosting
(
)
const
{
return
hasSelfHostStencil
(
)
;
}
bool
initSelfHostingStencil
(
JSContext
*
cx
JS
:
:
SelfHostedCache
xdrCache
JS
:
:
SelfHostedWriter
xdrWriter
)
;
bool
initSelfHostingFromStencil
(
JSContext
*
cx
)
;
void
finishSelfHosting
(
)
;
void
traceSelfHostingStencil
(
JSTracer
*
trc
)
;
js
:
:
GeneratorKind
getSelfHostedFunctionGeneratorKind
(
js
:
:
PropertyName
*
name
)
;
bool
delazifySelfHostedFunction
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
Handle
<
JSFunction
*
>
targetFun
)
;
bool
getSelfHostedValue
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
MutableHandleValue
vp
)
;
void
assertSelfHostedFunctionHasCanonicalName
(
JS
:
:
Handle
<
js
:
:
PropertyName
*
>
name
)
;
private
:
void
setSelfHostingStencil
(
JS
:
:
MutableHandle
<
js
:
:
UniquePtr
<
js
:
:
frontend
:
:
CompilationInput
>
>
input
RefPtr
<
js
:
:
frontend
:
:
CompilationStencil
>
&
&
stencil
)
;
public
:
bool
setDefaultLocale
(
const
char
*
locale
)
;
void
resetDefaultLocale
(
)
;
const
char
*
getDefaultLocale
(
)
;
js
:
:
gc
:
:
GCRuntime
gc
;
js
:
:
WriteOnceData
<
bool
>
gcInitialized
;
bool
hasZealMode
(
js
:
:
gc
:
:
ZealMode
mode
)
{
return
gc
.
hasZealMode
(
mode
)
;
}
void
lockGC
(
)
{
gc
.
lockGC
(
)
;
}
void
unlockGC
(
)
{
gc
.
unlockGC
(
)
;
}
js
:
:
WriteOnceData
<
js
:
:
PropertyName
*
>
emptyString
;
public
:
JS
:
:
GCContext
*
gcContext
(
)
{
return
&
gc
.
mainThreadContext
.
ref
(
)
;
}
#
if
!
JS_HAS_INTL_API
js
:
:
WriteOnceData
<
const
char
*
>
thousandsSeparator
;
js
:
:
WriteOnceData
<
const
char
*
>
decimalSeparator
;
js
:
:
WriteOnceData
<
const
char
*
>
numGrouping
;
#
endif
private
:
mozilla
:
:
Maybe
<
js
:
:
SharedImmutableStringsCache
>
sharedImmutableStrings_
;
public
:
js
:
:
SharedImmutableStringsCache
*
maybeThisRuntimeSharedImmutableStrings
(
)
{
return
sharedImmutableStrings_
.
isSome
(
)
?
&
*
sharedImmutableStrings_
:
nullptr
;
}
js
:
:
SharedImmutableStringsCache
&
sharedImmutableStrings
(
)
{
MOZ_ASSERT_IF
(
parentRuntime
!
sharedImmutableStrings_
)
;
MOZ_ASSERT_IF
(
!
parentRuntime
sharedImmutableStrings_
)
;
return
parentRuntime
?
parentRuntime
-
>
sharedImmutableStrings
(
)
:
*
sharedImmutableStrings_
;
}
private
:
js
:
:
WriteOnceData
<
bool
>
beingDestroyed_
;
public
:
bool
isBeingDestroyed
(
)
const
{
return
beingDestroyed_
;
}
private
:
bool
allowContentJS_
;
public
:
bool
allowContentJS
(
)
const
{
return
allowContentJS_
;
}
friend
class
js
:
:
AutoAssertNoContentJS
;
private
:
js
:
:
WriteOnceData
<
js
:
:
AtomsTable
*
>
atoms_
;
js
:
:
MainThreadOrGCTaskData
<
js
:
:
SymbolRegistry
>
symbolRegistry_
;
js
:
:
WriteOnceData
<
js
:
:
FrozenAtomSet
*
>
permanentAtoms_
;
public
:
bool
initializeAtoms
(
JSContext
*
cx
)
;
bool
initializeParserAtoms
(
JSContext
*
cx
)
;
void
finishAtoms
(
)
;
void
finishParserAtoms
(
)
;
bool
atomsAreFinished
(
)
const
{
return
!
atoms_
;
}
js
:
:
AtomsTable
*
atomsForSweeping
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
return
atoms_
;
}
js
:
:
AtomsTable
&
atoms
(
)
{
MOZ_ASSERT
(
atoms_
)
;
return
*
atoms_
;
}
const
JS
:
:
Zone
*
atomsZone
(
)
const
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
this
)
)
;
return
gc
.
atomsZone
;
}
JS
:
:
Zone
*
atomsZone
(
)
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
this
)
)
;
return
gc
.
atomsZone
;
}
JS
:
:
Zone
*
unsafeAtomsZone
(
)
{
return
gc
.
atomsZone
;
}
#
ifdef
DEBUG
bool
isAtomsZone
(
const
JS
:
:
Zone
*
zone
)
const
{
return
zone
=
=
gc
.
atomsZone
;
}
#
endif
bool
activeGCInAtomsZone
(
)
;
js
:
:
SymbolRegistry
&
symbolRegistry
(
)
{
return
symbolRegistry_
.
ref
(
)
;
}
js
:
:
WriteOnceData
<
js
:
:
StaticStrings
*
>
staticStrings
;
js
:
:
WriteOnceData
<
JSAtomState
*
>
commonNames
;
js
:
:
WriteOnceData
<
js
:
:
frontend
:
:
WellKnownParserAtoms
*
>
commonParserNames
;
const
js
:
:
FrozenAtomSet
*
permanentAtoms
(
)
const
{
MOZ_ASSERT
(
permanentAtomsPopulated
(
)
)
;
return
permanentAtoms_
.
ref
(
)
;
}
bool
permanentAtomsPopulated
(
)
const
{
return
permanentAtoms_
;
}
js
:
:
WriteOnceData
<
js
:
:
WellKnownSymbols
*
>
wellKnownSymbols
;
#
ifdef
JS_HAS_INTL_API
js
:
:
MainThreadData
<
js
:
:
intl
:
:
SharedIntlData
>
sharedIntlData
;
void
traceSharedIntlData
(
JSTracer
*
trc
)
;
#
endif
private
:
js
:
:
ScriptDataLockData
<
js
:
:
SharedImmutableScriptDataTable
>
scriptDataTable_
;
public
:
js
:
:
SharedImmutableScriptDataTable
&
scriptDataTable
(
const
js
:
:
AutoLockScriptData
&
lock
)
{
return
scriptDataTable_
.
ref
(
)
;
}
private
:
static
mozilla
:
:
Atomic
<
size_t
>
liveRuntimesCount
;
public
:
static
bool
hasLiveRuntimes
(
)
{
return
liveRuntimesCount
>
0
;
}
static
bool
hasSingleLiveRuntime
(
)
{
return
liveRuntimesCount
=
=
1
;
}
explicit
JSRuntime
(
JSRuntime
*
parentRuntime
)
;
~
JSRuntime
(
)
;
void
destroyRuntime
(
)
;
bool
init
(
JSContext
*
cx
uint32_t
maxbytes
)
;
JSRuntime
*
thisFromCtor
(
)
{
return
this
;
}
private
:
js
:
:
MainThreadData
<
uint64_t
>
liveSABs
;
public
:
void
incSABCount
(
)
{
MOZ_RELEASE_ASSERT
(
liveSABs
!
=
UINT64_MAX
)
;
liveSABs
+
+
;
}
void
decSABCount
(
)
{
MOZ_RELEASE_ASSERT
(
liveSABs
>
0
)
;
liveSABs
-
-
;
}
bool
hasLiveSABs
(
)
const
{
return
liveSABs
>
0
;
}
public
:
js
:
:
MainThreadData
<
JS
:
:
BeforeWaitCallback
>
beforeWaitCallback
;
js
:
:
MainThreadData
<
JS
:
:
AfterWaitCallback
>
afterWaitCallback
;
public
:
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
static_cast
<
JSContext
*
>
(
nullptr
)
)
;
}
JS_PUBLIC_API
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocator
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
=
nullptr
JSContext
*
maybecx
=
nullptr
)
;
JS_PUBLIC_API
void
*
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
allocator
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
;
static
const
unsigned
LARGE_ALLOCATION
=
25
*
1024
*
1024
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
RuntimeSizes
*
rtSizes
)
;
private
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
offthreadIonCompilationEnabled_
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
parallelParsingEnabled_
;
js
:
:
MainThreadData
<
bool
>
autoWritableJitCodeActive_
;
public
:
void
setOffthreadIonCompilationEnabled
(
bool
value
)
{
offthreadIonCompilationEnabled_
=
value
;
}
bool
canUseOffthreadIonCompilation
(
)
const
{
return
offthreadIonCompilationEnabled_
;
}
void
setParallelParsingEnabled
(
bool
value
)
{
parallelParsingEnabled_
=
value
;
}
bool
canUseParallelParsing
(
)
const
{
return
parallelParsingEnabled_
;
}
void
toggleAutoWritableJitCodeActive
(
bool
b
)
{
MOZ_ASSERT
(
autoWritableJitCodeActive_
!
=
b
"
AutoWritableJitCode
should
not
be
nested
.
"
)
;
autoWritableJitCodeActive_
=
b
;
}
js
:
:
MainThreadData
<
JS
:
:
OutOfMemoryCallback
>
oomCallback
;
js
:
:
MainThreadData
<
void
*
>
oomCallbackData
;
js
:
:
MainThreadData
<
mozilla
:
:
MallocSizeOf
>
debuggerMallocSizeOf
;
js
:
:
MainThreadData
<
mozilla
:
:
TimeStamp
>
lastAnimationTime
;
private
:
mozilla
:
:
Atomic
<
js
:
:
StackFormat
mozilla
:
:
ReleaseAcquire
>
stackFormat_
;
public
:
js
:
:
StackFormat
stackFormat
(
)
const
{
const
JSRuntime
*
rt
=
this
;
while
(
rt
-
>
parentRuntime
)
{
MOZ_ASSERT
(
rt
-
>
stackFormat_
=
=
js
:
:
StackFormat
:
:
Default
)
;
rt
=
rt
-
>
parentRuntime
;
}
MOZ_ASSERT
(
rt
-
>
stackFormat_
!
=
js
:
:
StackFormat
:
:
Default
)
;
return
rt
-
>
stackFormat_
;
}
void
setStackFormat
(
js
:
:
StackFormat
format
)
{
MOZ_ASSERT
(
!
parentRuntime
)
;
MOZ_ASSERT
(
format
!
=
js
:
:
StackFormat
:
:
Default
)
;
stackFormat_
=
format
;
}
private
:
js
:
:
MainThreadOrParseData
<
js
:
:
RuntimeCaches
>
caches_
;
public
:
js
:
:
RuntimeCaches
&
caches
(
)
{
return
caches_
.
ref
(
)
;
}
js
:
:
ExclusiveData
<
js
:
:
wasm
:
:
InstanceVector
>
wasmInstances
;
js
:
:
MainThreadData
<
uint32_t
>
moduleAsyncEvaluatingPostOrder
;
js
:
:
MainThreadData
<
JS
:
:
ModuleResolveHook
>
moduleResolveHook
;
js
:
:
MainThreadData
<
JS
:
:
ModuleMetadataHook
>
moduleMetadataHook
;
mozilla
:
:
Atomic
<
JS
:
:
ModuleDynamicImportHook
>
moduleDynamicImportHook
;
mozilla
:
:
Atomic
<
JS
:
:
SupportedAssertionsHook
>
supportedAssertionsHook
;
js
:
:
MainThreadData
<
JS
:
:
ScriptPrivateReferenceHook
>
scriptPrivateAddRefHook
;
js
:
:
MainThreadData
<
JS
:
:
ScriptPrivateReferenceHook
>
scriptPrivateReleaseHook
;
void
addRefScriptPrivate
(
const
JS
:
:
Value
&
value
)
{
if
(
!
value
.
isUndefined
(
)
&
&
scriptPrivateAddRefHook
)
{
scriptPrivateAddRefHook
(
value
)
;
}
}
void
releaseScriptPrivate
(
const
JS
:
:
Value
&
value
)
{
if
(
!
value
.
isUndefined
(
)
&
&
scriptPrivateReleaseHook
)
{
scriptPrivateReleaseHook
(
value
)
;
}
}
public
:
#
if
defined
(
NIGHTLY_BUILD
)
struct
ErrorInterceptionSupport
{
ErrorInterceptionSupport
(
)
:
isExecuting
(
false
)
interceptor
(
nullptr
)
{
}
bool
isExecuting
;
JSErrorInterceptor
*
interceptor
;
}
;
ErrorInterceptionSupport
errorInterception
;
#
endif
public
:
JS
:
:
GlobalInitializeCallback
getShadowRealmInitializeGlobalCallback
(
)
{
return
shadowRealmInitializeGlobalCallback
;
}
JS
:
:
GlobalCreationCallback
getShadowRealmGlobalCreationCallback
(
)
{
return
shadowRealmGlobalCreationCallback
;
}
js
:
:
MainThreadData
<
JS
:
:
GlobalInitializeCallback
>
shadowRealmInitializeGlobalCallback
;
js
:
:
MainThreadData
<
JS
:
:
GlobalCreationCallback
>
shadowRealmGlobalCreationCallback
;
}
;
namespace
js
{
void
Metrics
:
:
addTelemetry
(
JSMetric
id
uint32_t
sample
)
{
rt_
-
>
addTelemetry
(
id
sample
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
vec
size_t
len
)
{
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
vec
[
i
]
.
setDouble
(
+
0
.
0
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
beg
Value
*
end
)
{
MakeRangeGCSafe
(
beg
end
-
beg
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
beg
jsid
*
end
)
{
std
:
:
fill
(
beg
end
PropertyKey
:
:
Int
(
0
)
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
vec
size_t
len
)
{
MakeRangeGCSafe
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
beg
Shape
*
*
end
)
{
std
:
:
fill
(
beg
end
nullptr
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
vec
size_t
len
)
{
MakeRangeGCSafe
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
{
v
-
>
setUndefined
(
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
vec
size_t
len
)
{
SetValueRangeToUndefined
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
{
v
-
>
setNull
(
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
vec
size_t
len
)
{
SetValueRangeToNull
(
vec
vec
+
len
)
;
}
extern
const
JSSecurityCallbacks
NullSecurityCallbacks
;
extern
mozilla
:
:
Atomic
<
JS
:
:
LargeAllocationFailureCallback
>
OnLargeAllocationFailure
;
extern
mozilla
:
:
Atomic
<
JS
:
:
BuildIdOp
>
GetBuildId
;
extern
JS
:
:
FilenameValidationCallback
gFilenameValidationCallback
;
}
#
endif
