#
ifndef
vm_Runtime_h
#
define
vm_Runtime_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
setjmp
.
h
>
#
include
"
jsatom
.
h
"
#
include
"
jsclist
.
h
"
#
include
"
jsscript
.
h
"
#
ifdef
XP_DARWIN
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
endif
#
include
"
builtin
/
AtomicsObject
.
h
"
#
include
"
builtin
/
Intl
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
ds
/
FixedSizeHash
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
gc
/
ZoneGroup
.
h
"
#
include
"
irregexp
/
RegExpStack
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
ifdef
DEBUG
#
include
"
js
/
Proxy
.
h
"
#
endif
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
Caches
.
h
"
#
include
"
vm
/
CodeCoverage
.
h
"
#
include
"
vm
/
CommonPropertyNames
.
h
"
#
include
"
vm
/
DateTime
.
h
"
#
include
"
vm
/
GeckoProfiler
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
Stopwatch
.
h
"
#
include
"
vm
/
Symbol
.
h
"
#
include
"
wasm
/
WasmRuntime
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4100
)
/
*
Silence
unreferenced
formal
parameter
warnings
*
/
#
endif
namespace
js
{
class
AutoAssertNoContentJS
;
class
AutoKeepAtoms
;
class
EnterDebuggeeNoExecute
;
#
ifdef
JS_TRACE_LOGGING
class
TraceLoggerThread
;
#
endif
typedef
Vector
<
UniquePtr
<
PromiseTask
>
0
SystemAllocPolicy
>
PromiseTaskPtrVector
;
}
struct
DtoaState
;
#
ifdef
JS_SIMULATOR_ARM64
namespace
vixl
{
class
Simulator
;
}
#
endif
namespace
js
{
extern
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
extern
MOZ_COLD
mozilla
:
:
GenericErrorResult
<
OOM
&
>
ReportOutOfMemoryResult
(
JSContext
*
cx
)
;
extern
MOZ_COLD
void
ReportAllocationOverflow
(
JSContext
*
maybecx
)
;
extern
MOZ_COLD
void
ReportOverRecursed
(
JSContext
*
cx
)
;
class
Activation
;
class
ActivationIterator
;
class
WasmActivation
;
namespace
jit
{
class
JitRuntime
;
class
JitActivation
;
struct
PcScriptCache
;
struct
AutoFlushICache
;
class
CompileRuntime
;
#
ifdef
JS_SIMULATOR_ARM64
typedef
vixl
:
:
Simulator
Simulator
;
#
elif
defined
(
JS_SIMULATOR
)
class
Simulator
;
#
endif
}
class
FreeOp
:
public
JSFreeOp
{
Vector
<
void
*
0
SystemAllocPolicy
>
freeLaterList
;
jit
:
:
JitPoisonRangeVector
jitPoisonRanges
;
public
:
static
FreeOp
*
get
(
JSFreeOp
*
fop
)
{
return
static_cast
<
FreeOp
*
>
(
fop
)
;
}
explicit
FreeOp
(
JSRuntime
*
maybeRuntime
)
;
~
FreeOp
(
)
;
bool
onActiveCooperatingThread
(
)
const
{
return
runtime_
!
=
nullptr
;
}
bool
maybeOnHelperThread
(
)
const
{
return
!
runtime_
;
}
bool
isDefaultFreeOp
(
)
const
;
inline
void
free_
(
void
*
p
)
;
inline
void
freeLater
(
void
*
p
)
;
inline
bool
appendJitPoisonRange
(
const
jit
:
:
JitPoisonRange
&
range
)
;
template
<
class
T
>
inline
void
delete_
(
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
free_
(
p
)
;
}
}
}
;
}
namespace
JS
{
struct
RuntimeSizes
;
}
struct
JSAtomState
{
#
define
PROPERTYNAME_FIELD
(
idpart
id
text
)
js
:
:
ImmutablePropertyNamePtr
id
;
FOR_EACH_COMMON_PROPERTYNAME
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
code
init
clasp
)
js
:
:
ImmutablePropertyNamePtr
name
;
JS_FOR_EACH_PROTOTYPE
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
)
js
:
:
ImmutablePropertyNamePtr
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
#
define
PROPERTYNAME_FIELD
(
name
)
js
:
:
ImmutablePropertyNamePtr
Symbol_
#
#
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
PROPERTYNAME_FIELD
)
#
undef
PROPERTYNAME_FIELD
js
:
:
ImmutablePropertyNamePtr
*
wellKnownSymbolNames
(
)
{
#
define
FIRST_PROPERTYNAME_FIELD
(
name
)
return
&
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
FIRST_PROPERTYNAME_FIELD
)
#
undef
FIRST_PROPERTYNAME_FIELD
}
js
:
:
ImmutablePropertyNamePtr
*
wellKnownSymbolDescriptions
(
)
{
#
define
FIRST_PROPERTYNAME_FIELD
(
name
)
return
&
Symbol_
#
#
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
FIRST_PROPERTYNAME_FIELD
)
#
undef
FIRST_PROPERTYNAME_FIELD
}
}
;
namespace
js
{
struct
WellKnownSymbols
{
#
define
DECLARE_SYMBOL
(
name
)
js
:
:
ImmutableSymbolPtr
name
;
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
DECLARE_SYMBOL
)
#
undef
DECLARE_SYMBOL
const
ImmutableSymbolPtr
&
get
(
size_t
u
)
const
{
MOZ_ASSERT
(
u
<
JS
:
:
WellKnownSymbolLimit
)
;
const
ImmutableSymbolPtr
*
symbols
=
reinterpret_cast
<
const
ImmutableSymbolPtr
*
>
(
this
)
;
return
symbols
[
u
]
;
}
const
ImmutableSymbolPtr
&
get
(
JS
:
:
SymbolCode
code
)
const
{
return
get
(
size_t
(
code
)
)
;
}
WellKnownSymbols
(
)
{
}
WellKnownSymbols
(
const
WellKnownSymbols
&
)
=
delete
;
WellKnownSymbols
&
operator
=
(
const
WellKnownSymbols
&
)
=
delete
;
}
;
#
define
NAME_OFFSET
(
name
)
offsetof
(
JSAtomState
name
)
inline
HandlePropertyName
AtomStateOffsetToName
(
const
JSAtomState
&
atomState
size_t
offset
)
{
return
*
reinterpret_cast
<
js
:
:
ImmutablePropertyNamePtr
*
>
(
(
char
*
)
&
atomState
+
offset
)
;
}
enum
RuntimeLock
{
ExclusiveAccessLock
HelperThreadStateLock
GCLock
}
;
inline
bool
CanUseExtraThreads
(
)
{
extern
bool
gCanUseExtraThreads
;
return
gCanUseExtraThreads
;
}
void
DisableExtraThreads
(
)
;
using
ScriptAndCountsVector
=
GCVector
<
ScriptAndCounts
0
SystemAllocPolicy
>
;
class
AutoLockForExclusiveAccess
;
}
struct
JSRuntime
:
public
js
:
:
MallocProvider
<
JSRuntime
>
{
private
:
friend
class
js
:
:
Activation
;
friend
class
js
:
:
ActivationIterator
;
friend
class
js
:
:
jit
:
:
JitActivation
;
friend
class
js
:
:
WasmActivation
;
friend
class
js
:
:
jit
:
:
CompileRuntime
;
public
:
JSRuntime
*
const
parentRuntime
;
#
ifdef
DEBUG
mozilla
:
:
Atomic
<
size_t
>
childRuntimeCount
;
class
AutoUpdateChildRuntimeCount
{
JSRuntime
*
parent_
;
public
:
explicit
AutoUpdateChildRuntimeCount
(
JSRuntime
*
parent
)
:
parent_
(
parent
)
{
if
(
parent_
)
parent_
-
>
childRuntimeCount
+
+
;
}
~
AutoUpdateChildRuntimeCount
(
)
{
if
(
parent_
)
parent_
-
>
childRuntimeCount
-
-
;
}
}
;
AutoUpdateChildRuntimeCount
updateChildRuntimeCount
;
#
endif
private
:
#
ifdef
DEBUG
js
:
:
WriteOnceData
<
bool
>
initialized_
;
#
endif
mozilla
:
:
Atomic
<
JSContext
*
mozilla
:
:
ReleaseAcquire
>
activeContext_
;
js
:
:
ActiveThreadData
<
js
:
:
Vector
<
js
:
:
CooperatingContext
4
js
:
:
SystemAllocPolicy
>
>
cooperatingContexts_
;
js
:
:
ActiveThreadData
<
size_t
>
activeContextChangeProhibited_
;
js
:
:
ActiveThreadData
<
size_t
>
singleThreadedExecutionRequired_
;
js
:
:
ActiveThreadData
<
bool
>
startingSingleThreadedExecution_
;
public
:
JSContext
*
activeContext
(
)
const
{
return
activeContext_
;
}
const
void
*
addressOfActiveContext
(
)
{
return
&
activeContext_
;
}
void
setActiveContext
(
JSContext
*
cx
)
;
void
setNewbornActiveContext
(
JSContext
*
cx
)
;
void
deleteActiveContext
(
JSContext
*
cx
)
;
inline
JSContext
*
activeContextFromOwnThread
(
)
;
js
:
:
Vector
<
js
:
:
CooperatingContext
4
js
:
:
SystemAllocPolicy
>
&
cooperatingContexts
(
)
{
return
cooperatingContexts_
.
ref
(
)
;
}
class
MOZ_RAII
AutoProhibitActiveContextChange
{
JSRuntime
*
rt
;
public
:
explicit
AutoProhibitActiveContextChange
(
JSRuntime
*
rt
)
:
rt
(
rt
)
{
rt
-
>
activeContextChangeProhibited_
+
+
;
}
~
AutoProhibitActiveContextChange
(
)
{
rt
-
>
activeContextChangeProhibited_
-
-
;
}
}
;
bool
activeContextChangeProhibited
(
)
{
return
activeContextChangeProhibited_
;
}
bool
singleThreadedExecutionRequired
(
)
{
return
singleThreadedExecutionRequired_
;
}
js
:
:
ActiveThreadData
<
JS
:
:
BeginSingleThreadedExecutionCallback
>
beginSingleThreadedExecutionCallback
;
js
:
:
ActiveThreadData
<
JS
:
:
EndSingleThreadedExecutionCallback
>
endSingleThreadedExecutionCallback
;
bool
beginSingleThreadedExecution
(
JSContext
*
cx
)
;
void
endSingleThreadedExecution
(
JSContext
*
cx
)
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
profilerSampleBufferGen_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
profilerSampleBufferLapCount_
;
uint32_t
profilerSampleBufferGen
(
)
{
return
profilerSampleBufferGen_
;
}
void
resetProfilerSampleBufferGen
(
)
{
profilerSampleBufferGen_
=
0
;
}
void
setProfilerSampleBufferGen
(
uint32_t
gen
)
{
for
(
;
;
)
{
uint32_t
curGen
=
profilerSampleBufferGen_
;
if
(
curGen
>
=
gen
)
break
;
if
(
profilerSampleBufferGen_
.
compareExchange
(
curGen
gen
)
)
break
;
}
}
uint32_t
profilerSampleBufferLapCount
(
)
{
MOZ_ASSERT
(
profilerSampleBufferLapCount_
>
0
)
;
return
profilerSampleBufferLapCount_
;
}
void
resetProfilerSampleBufferLapCount
(
)
{
profilerSampleBufferLapCount_
=
1
;
}
void
updateProfilerSampleBufferLapCount
(
uint32_t
lapCount
)
{
MOZ_ASSERT
(
profilerSampleBufferLapCount_
>
0
)
;
for
(
;
;
)
{
uint32_t
curLapCount
=
profilerSampleBufferLapCount_
;
if
(
curLapCount
>
=
lapCount
)
break
;
if
(
profilerSampleBufferLapCount_
.
compareExchange
(
curLapCount
lapCount
)
)
break
;
}
}
js
:
:
ActiveThreadData
<
JSAccumulateTelemetryDataCallback
>
telemetryCallback
;
public
:
void
addTelemetry
(
int
id
uint32_t
sample
const
char
*
key
=
nullptr
)
;
void
setTelemetryCallback
(
JSRuntime
*
rt
JSAccumulateTelemetryDataCallback
callback
)
;
public
:
js
:
:
ActiveThreadData
<
JSGetIncumbentGlobalCallback
>
getIncumbentGlobalCallback
;
js
:
:
ActiveThreadData
<
JSEnqueuePromiseJobCallback
>
enqueuePromiseJobCallback
;
js
:
:
ActiveThreadData
<
void
*
>
enqueuePromiseJobCallbackData
;
js
:
:
ActiveThreadData
<
JSPromiseRejectionTrackerCallback
>
promiseRejectionTrackerCallback
;
js
:
:
ActiveThreadData
<
void
*
>
promiseRejectionTrackerCallbackData
;
js
:
:
ActiveThreadData
<
JS
:
:
StartAsyncTaskCallback
>
startAsyncTaskCallback
;
js
:
:
UnprotectedData
<
JS
:
:
FinishAsyncTaskCallback
>
finishAsyncTaskCallback
;
js
:
:
ExclusiveData
<
js
:
:
PromiseTaskPtrVector
>
promiseTasksToDestroy
;
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
;
bool
enqueuePromiseJob
(
JSContext
*
cx
js
:
:
HandleFunction
job
js
:
:
HandleObject
promise
js
:
:
HandleObject
incumbentGlobal
)
;
void
addUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
void
removeUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
mozilla
:
:
Atomic
<
bool
>
hadOutOfMemory
;
js
:
:
ActiveThreadData
<
bool
>
allowRelazificationForTesting
;
js
:
:
ActiveThreadData
<
JSDestroyCompartmentCallback
>
destroyCompartmentCallback
;
js
:
:
ActiveThreadData
<
JSSizeOfIncludingThisCompartmentCallback
>
sizeOfIncludingThisCompartmentCallback
;
js
:
:
ActiveThreadData
<
JSCompartmentNameCallback
>
compartmentNameCallback
;
js
:
:
ActiveThreadData
<
JSExternalStringSizeofCallback
>
externalStringSizeofCallback
;
js
:
:
ActiveThreadData
<
mozilla
:
:
UniquePtr
<
js
:
:
SourceHook
>
>
sourceHook
;
js
:
:
ActiveThreadData
<
const
JSSecurityCallbacks
*
>
securityCallbacks
;
js
:
:
ActiveThreadData
<
const
js
:
:
DOMCallbacks
*
>
DOMcallbacks
;
js
:
:
ActiveThreadData
<
JSDestroyPrincipalsOp
>
destroyPrincipals
;
js
:
:
ActiveThreadData
<
JSReadPrincipalsOp
>
readPrincipals
;
js
:
:
ActiveThreadData
<
JS
:
:
WarningReporter
>
warningReporter
;
private
:
js
:
:
UnprotectedData
<
js
:
:
GeckoProfiler
>
geckoProfiler_
;
public
:
js
:
:
GeckoProfiler
&
geckoProfiler
(
)
{
return
geckoProfiler_
.
ref
(
)
;
}
js
:
:
ActiveThreadData
<
mozilla
:
:
EnumeratedArray
<
JS
:
:
RootKind
JS
:
:
RootKind
:
:
Limit
mozilla
:
:
LinkedList
<
JS
:
:
PersistentRooted
<
void
*
>
>
>
>
heapRoots
;
void
tracePersistentRoots
(
JSTracer
*
trc
)
;
void
finishPersistentRoots
(
)
;
void
finishRoots
(
)
;
public
:
js
:
:
UnprotectedData
<
JS
:
:
BuildIdOp
>
buildIdOp
;
js
:
:
UnprotectedData
<
JS
:
:
AsmJSCacheOps
>
asmJSCacheOps
;
private
:
js
:
:
ActiveThreadData
<
js
:
:
wasm
:
:
Runtime
>
wasmRuntime_
;
public
:
js
:
:
wasm
:
:
Runtime
&
wasm
(
)
{
return
wasmRuntime_
.
ref
(
)
;
}
private
:
js
:
:
UnprotectedData
<
const
JSPrincipals
*
>
trustedPrincipals_
;
public
:
void
setTrustedPrincipals
(
const
JSPrincipals
*
p
)
{
trustedPrincipals_
=
p
;
}
const
JSPrincipals
*
trustedPrincipals
(
)
const
{
return
trustedPrincipals_
;
}
js
:
:
ActiveThreadData
<
const
JSWrapObjectCallbacks
*
>
wrapObjectCallbacks
;
js
:
:
ActiveThreadData
<
js
:
:
PreserveWrapperCallback
>
preserveWrapperCallback
;
js
:
:
ActiveThreadData
<
js
:
:
ScriptEnvironmentPreparer
*
>
scriptEnvironmentPreparer
;
js
:
:
ActiveThreadData
<
js
:
:
CTypesActivityCallback
>
ctypesActivityCallback
;
private
:
js
:
:
WriteOnceData
<
const
js
:
:
Class
*
>
windowProxyClass_
;
public
:
const
js
:
:
Class
*
maybeWindowProxyClass
(
)
const
{
return
windowProxyClass_
;
}
void
setWindowProxyClass
(
const
js
:
:
Class
*
clasp
)
{
windowProxyClass_
=
clasp
;
}
private
:
js
:
:
ActiveThreadData
<
mozilla
:
:
LinkedList
<
JS
:
:
WeakCache
<
void
*
>
>
>
weakCaches_
;
public
:
mozilla
:
:
LinkedList
<
JS
:
:
WeakCache
<
void
*
>
>
&
weakCaches
(
)
{
return
weakCaches_
.
ref
(
)
;
}
void
registerWeakCache
(
JS
:
:
WeakCache
<
void
*
>
*
cachep
)
{
weakCaches
(
)
.
insertBack
(
cachep
)
;
}
private
:
js
:
:
ActiveThreadData
<
JSCList
>
onNewGlobalObjectWatchers_
;
public
:
JSCList
&
onNewGlobalObjectWatchers
(
)
{
return
onNewGlobalObjectWatchers_
.
ref
(
)
;
}
private
:
js
:
:
Mutex
exclusiveAccessLock
;
#
ifdef
DEBUG
bool
activeThreadHasExclusiveAccess
;
#
endif
js
:
:
UnprotectedData
<
size_t
>
numHelperThreadZones
;
friend
class
js
:
:
AutoLockForExclusiveAccess
;
public
:
void
setUsedByHelperThread
(
JS
:
:
Zone
*
zone
)
;
void
clearUsedByHelperThread
(
JS
:
:
Zone
*
zone
)
;
bool
hasHelperThreadZones
(
)
const
{
return
numHelperThreadZones
>
0
;
}
#
ifdef
DEBUG
bool
currentThreadHasExclusiveAccess
(
)
const
{
return
(
!
hasHelperThreadZones
(
)
&
&
activeThreadHasExclusiveAccess
)
|
|
exclusiveAccessLock
.
ownedByCurrentThread
(
)
;
}
#
endif
js
:
:
ActiveThreadData
<
size_t
>
numCompartments
;
js
:
:
ActiveThreadData
<
const
JSLocaleCallbacks
*
>
localeCallbacks
;
js
:
:
ActiveThreadData
<
char
*
>
defaultLocale
;
js
:
:
ActiveThreadData
<
JSVersion
>
defaultVersion_
;
js
:
:
ActiveThreadOrIonCompileData
<
bool
>
profilingScripts
;
js
:
:
ActiveThreadData
<
JS
:
:
PersistentRooted
<
js
:
:
ScriptAndCountsVector
>
*
>
scriptAndCountsVector
;
private
:
js
:
:
UnprotectedData
<
js
:
:
coverage
:
:
LCovRuntime
>
lcovOutput_
;
public
:
js
:
:
coverage
:
:
LCovRuntime
&
lcovOutput
(
)
{
return
lcovOutput_
.
ref
(
)
;
}
private
:
js
:
:
UnprotectedData
<
js
:
:
jit
:
:
JitRuntime
*
>
jitRuntime_
;
js
:
:
WriteOnceData
<
js
:
:
NativeObject
*
>
selfHostingGlobal_
;
static
js
:
:
GlobalObject
*
createSelfHostingGlobal
(
JSContext
*
cx
)
;
bool
getUnclonedSelfHostedValue
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
js
:
:
MutableHandleValue
vp
)
;
JSFunction
*
getUnclonedSelfHostedFunction
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
)
;
js
:
:
jit
:
:
JitRuntime
*
createJitRuntime
(
JSContext
*
cx
)
;
public
:
js
:
:
jit
:
:
JitRuntime
*
getJitRuntime
(
JSContext
*
cx
)
{
return
jitRuntime_
?
jitRuntime_
.
ref
(
)
:
createJitRuntime
(
cx
)
;
}
js
:
:
jit
:
:
JitRuntime
*
jitRuntime
(
)
const
{
return
jitRuntime_
.
ref
(
)
;
}
bool
hasJitRuntime
(
)
const
{
return
!
!
jitRuntime_
;
}
private
:
mozilla
:
:
Maybe
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
randomKeyGenerator_
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
&
randomKeyGenerator
(
)
;
public
:
mozilla
:
:
HashCodeScrambler
randomHashCodeScrambler
(
)
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
forkRandomKeyGenerator
(
)
;
bool
hasInitializedSelfHosting
(
)
const
{
return
selfHostingGlobal_
;
}
bool
initSelfHosting
(
JSContext
*
cx
)
;
void
finishSelfHosting
(
)
;
void
traceSelfHostingGlobal
(
JSTracer
*
trc
)
;
bool
isSelfHostingGlobal
(
JSObject
*
global
)
{
return
global
=
=
selfHostingGlobal_
;
}
bool
isSelfHostingCompartment
(
JSCompartment
*
comp
)
const
;
bool
isSelfHostingZone
(
const
JS
:
:
Zone
*
zone
)
const
;
bool
createLazySelfHostedFunctionClone
(
JSContext
*
cx
js
:
:
HandlePropertyName
selfHostedName
js
:
:
HandleAtom
name
unsigned
nargs
js
:
:
HandleObject
proto
js
:
:
NewObjectKind
newKind
js
:
:
MutableHandleFunction
fun
)
;
bool
cloneSelfHostedFunctionScript
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
Handle
<
JSFunction
*
>
targetFun
)
;
bool
cloneSelfHostedValue
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
PropertyName
*
>
name
js
:
:
MutableHandleValue
vp
)
;
void
assertSelfHostedFunctionHasCanonicalName
(
JSContext
*
cx
js
:
:
HandlePropertyName
name
)
;
bool
setDefaultLocale
(
const
char
*
locale
)
;
void
resetDefaultLocale
(
)
;
const
char
*
getDefaultLocale
(
)
;
JSVersion
defaultVersion
(
)
const
{
return
defaultVersion_
;
}
void
setDefaultVersion
(
JSVersion
v
)
{
defaultVersion_
=
v
;
}
js
:
:
gc
:
:
GCRuntime
gc
;
js
:
:
WriteOnceData
<
bool
>
gcInitialized
;
bool
hasZealMode
(
js
:
:
gc
:
:
ZealMode
mode
)
{
return
gc
.
hasZealMode
(
mode
)
;
}
void
lockGC
(
)
{
gc
.
lockGC
(
)
;
}
void
unlockGC
(
)
{
gc
.
unlockGC
(
)
;
}
const
js
:
:
Value
NaNValue
;
const
js
:
:
Value
negativeInfinityValue
;
const
js
:
:
Value
positiveInfinityValue
;
js
:
:
WriteOnceData
<
js
:
:
PropertyName
*
>
emptyString
;
private
:
js
:
:
WriteOnceData
<
js
:
:
FreeOp
*
>
defaultFreeOp_
;
public
:
js
:
:
FreeOp
*
defaultFreeOp
(
)
{
MOZ_ASSERT
(
defaultFreeOp_
)
;
return
defaultFreeOp_
;
}
#
if
!
EXPOSE_INTL_API
js
:
:
WriteOnceData
<
const
char
*
>
thousandsSeparator
;
js
:
:
WriteOnceData
<
const
char
*
>
decimalSeparator
;
js
:
:
WriteOnceData
<
const
char
*
>
numGrouping
;
#
endif
private
:
mozilla
:
:
Maybe
<
js
:
:
SharedImmutableStringsCache
>
sharedImmutableStrings_
;
public
:
js
:
:
SharedImmutableStringsCache
*
maybeThisRuntimeSharedImmutableStrings
(
)
{
return
sharedImmutableStrings_
.
isSome
(
)
?
&
*
sharedImmutableStrings_
:
nullptr
;
}
js
:
:
SharedImmutableStringsCache
&
sharedImmutableStrings
(
)
{
MOZ_ASSERT_IF
(
parentRuntime
!
sharedImmutableStrings_
)
;
MOZ_ASSERT_IF
(
!
parentRuntime
sharedImmutableStrings_
)
;
return
parentRuntime
?
parentRuntime
-
>
sharedImmutableStrings
(
)
:
*
sharedImmutableStrings_
;
}
private
:
js
:
:
WriteOnceData
<
bool
>
beingDestroyed_
;
public
:
bool
isBeingDestroyed
(
)
const
{
return
beingDestroyed_
;
}
private
:
bool
allowContentJS_
;
public
:
bool
allowContentJS
(
)
const
{
return
allowContentJS_
;
}
friend
class
js
:
:
AutoAssertNoContentJS
;
private
:
js
:
:
ExclusiveAccessLockOrGCTaskData
<
js
:
:
AtomSet
*
>
atoms_
;
js
:
:
WriteOnceData
<
JSCompartment
*
>
atomsCompartment_
;
js
:
:
ExclusiveAccessLockOrGCTaskData
<
js
:
:
SymbolRegistry
>
symbolRegistry_
;
public
:
bool
initializeAtoms
(
JSContext
*
cx
)
;
void
finishAtoms
(
)
;
bool
atomsAreFinished
(
)
const
{
return
!
atoms_
;
}
void
sweepAtoms
(
)
;
js
:
:
AtomSet
&
atoms
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
*
atoms_
;
}
js
:
:
AtomSet
&
unsafeAtoms
(
)
{
return
*
atoms_
;
}
JSCompartment
*
atomsCompartment
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
atomsCompartment_
;
}
JSCompartment
*
unsafeAtomsCompartment
(
)
{
return
atomsCompartment_
;
}
bool
isAtomsCompartment
(
JSCompartment
*
comp
)
{
return
comp
=
=
atomsCompartment_
;
}
bool
isAtomsZone
(
const
JS
:
:
Zone
*
zone
)
const
{
return
zone
=
=
gc
.
atomsZone
;
}
bool
activeGCInAtomsZone
(
)
;
js
:
:
SymbolRegistry
&
symbolRegistry
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
symbolRegistry_
.
ref
(
)
;
}
js
:
:
SymbolRegistry
&
unsafeSymbolRegistry
(
)
{
return
symbolRegistry_
.
ref
(
)
;
}
js
:
:
WriteOnceData
<
js
:
:
StaticStrings
*
>
staticStrings
;
js
:
:
WriteOnceData
<
JSAtomState
*
>
commonNames
;
js
:
:
WriteOnceData
<
js
:
:
FrozenAtomSet
*
>
permanentAtoms
;
bool
transformToPermanentAtoms
(
JSContext
*
cx
)
;
js
:
:
WriteOnceData
<
js
:
:
WellKnownSymbols
*
>
wellKnownSymbols
;
js
:
:
ActiveThreadData
<
js
:
:
SharedIntlData
>
sharedIntlData
;
void
traceSharedIntlData
(
JSTracer
*
trc
)
;
private
:
js
:
:
ExclusiveAccessLockData
<
js
:
:
ScriptDataTable
>
scriptDataTable_
;
public
:
js
:
:
ScriptDataTable
&
scriptDataTable
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
scriptDataTable_
.
ref
(
)
;
}
js
:
:
WriteOnceData
<
bool
>
jitSupportsFloatingPoint
;
js
:
:
WriteOnceData
<
bool
>
jitSupportsUnalignedAccesses
;
js
:
:
WriteOnceData
<
bool
>
jitSupportsSimd
;
private
:
static
mozilla
:
:
Atomic
<
size_t
>
liveRuntimesCount
;
public
:
static
bool
hasLiveRuntimes
(
)
{
return
liveRuntimesCount
>
0
;
}
explicit
JSRuntime
(
JSRuntime
*
parentRuntime
)
;
~
JSRuntime
(
)
;
void
destroyRuntime
(
)
;
bool
init
(
JSContext
*
cx
uint32_t
maxbytes
uint32_t
maxNurseryBytes
)
;
JSRuntime
*
thisFromCtor
(
)
{
return
this
;
}
public
:
void
updateMallocCounter
(
size_t
nbytes
)
;
void
updateMallocCounter
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
nullptr
)
;
}
JS_FRIEND_API
(
void
*
)
onOutOfMemory
(
js
:
:
AllocFunction
allocator
size_t
nbytes
void
*
reallocPtr
=
nullptr
JSContext
*
maybecx
=
nullptr
)
;
JS_FRIEND_API
(
void
*
)
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
allocator
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
RuntimeSizes
*
runtime
)
;
private
:
mozilla
:
:
Atomic
<
bool
>
offthreadIonCompilationEnabled_
;
mozilla
:
:
Atomic
<
bool
>
parallelParsingEnabled_
;
js
:
:
ActiveThreadData
<
bool
>
autoWritableJitCodeActive_
;
public
:
void
setOffthreadIonCompilationEnabled
(
bool
value
)
{
offthreadIonCompilationEnabled_
=
value
;
}
bool
canUseOffthreadIonCompilation
(
)
const
{
return
offthreadIonCompilationEnabled_
;
}
void
setParallelParsingEnabled
(
bool
value
)
{
parallelParsingEnabled_
=
value
;
}
bool
canUseParallelParsing
(
)
const
{
return
parallelParsingEnabled_
;
}
void
toggleAutoWritableJitCodeActive
(
bool
b
)
{
MOZ_ASSERT
(
autoWritableJitCodeActive_
!
=
b
"
AutoWritableJitCode
should
not
be
nested
.
"
)
;
autoWritableJitCodeActive_
=
b
;
}
js
:
:
ActiveThreadData
<
JS
:
:
LargeAllocationFailureCallback
>
largeAllocationFailureCallback
;
js
:
:
ActiveThreadData
<
void
*
>
largeAllocationFailureCallbackData
;
js
:
:
ActiveThreadData
<
JS
:
:
OutOfMemoryCallback
>
oomCallback
;
js
:
:
ActiveThreadData
<
void
*
>
oomCallbackData
;
static
const
unsigned
LARGE_ALLOCATION
=
25
*
1024
*
1024
;
template
<
typename
T
>
T
*
pod_callocCanGC
(
size_t
numElems
)
{
T
*
p
=
pod_calloc
<
T
>
(
numElems
)
;
if
(
MOZ_LIKELY
(
!
!
p
)
)
return
p
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
{
reportAllocationOverflow
(
)
;
return
nullptr
;
}
return
static_cast
<
T
*
>
(
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Calloc
bytes
)
)
;
}
template
<
typename
T
>
T
*
pod_reallocCanGC
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
T
*
p2
=
pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
if
(
MOZ_LIKELY
(
!
!
p2
)
)
return
p2
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
newSize
&
bytes
)
)
)
{
reportAllocationOverflow
(
)
;
return
nullptr
;
}
return
static_cast
<
T
*
>
(
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Realloc
bytes
p
)
)
;
}
js
:
:
ActiveThreadData
<
mozilla
:
:
MallocSizeOf
>
debuggerMallocSizeOf
;
mozilla
:
:
Atomic
<
int64_t
>
lastAnimationTime
;
private
:
js
:
:
ActiveThreadData
<
js
:
:
PerformanceMonitoring
>
performanceMonitoring_
;
public
:
js
:
:
PerformanceMonitoring
&
performanceMonitoring
(
)
{
return
performanceMonitoring_
.
ref
(
)
;
}
private
:
typedef
mozilla
:
:
LinkedList
<
js
:
:
jit
:
:
IonBuilder
>
IonBuilderList
;
js
:
:
HelperThreadLockData
<
IonBuilderList
>
ionLazyLinkList_
;
js
:
:
HelperThreadLockData
<
size_t
>
ionLazyLinkListSize_
;
public
:
IonBuilderList
&
ionLazyLinkList
(
)
;
size_t
ionLazyLinkListSize
(
)
{
return
ionLazyLinkListSize_
;
}
void
ionLazyLinkListRemove
(
js
:
:
jit
:
:
IonBuilder
*
builder
)
;
void
ionLazyLinkListAdd
(
js
:
:
jit
:
:
IonBuilder
*
builder
)
;
private
:
mozilla
:
:
Atomic
<
js
:
:
StackFormat
mozilla
:
:
ReleaseAcquire
>
stackFormat_
;
public
:
js
:
:
StackFormat
stackFormat
(
)
const
{
const
JSRuntime
*
rt
=
this
;
while
(
rt
-
>
parentRuntime
)
{
MOZ_ASSERT
(
rt
-
>
stackFormat_
=
=
js
:
:
StackFormat
:
:
Default
)
;
rt
=
rt
-
>
parentRuntime
;
}
MOZ_ASSERT
(
rt
-
>
stackFormat_
!
=
js
:
:
StackFormat
:
:
Default
)
;
return
rt
-
>
stackFormat_
;
}
void
setStackFormat
(
js
:
:
StackFormat
format
)
{
MOZ_ASSERT
(
!
parentRuntime
)
;
MOZ_ASSERT
(
format
!
=
js
:
:
StackFormat
:
:
Default
)
;
stackFormat_
=
format
;
}
friend
class
js
:
:
gc
:
:
AutoTraceSession
;
friend
class
JS
:
:
AutoEnterCycleCollection
;
private
:
js
:
:
ActiveThreadData
<
js
:
:
RuntimeCaches
>
caches_
;
public
:
js
:
:
RuntimeCaches
&
caches
(
)
{
return
caches_
.
ref
(
)
;
}
}
;
namespace
js
{
namespace
VersionFlags
{
static
const
unsigned
MASK
=
0x0FFF
;
}
static
inline
JSVersion
VersionNumber
(
JSVersion
version
)
{
return
JSVersion
(
uint32_t
(
version
)
&
VersionFlags
:
:
MASK
)
;
}
static
inline
JSVersion
VersionExtractFlags
(
JSVersion
version
)
{
return
JSVersion
(
uint32_t
(
version
)
&
~
VersionFlags
:
:
MASK
)
;
}
static
inline
void
VersionCopyFlags
(
JSVersion
*
version
JSVersion
from
)
{
*
version
=
JSVersion
(
VersionNumber
(
*
version
)
|
VersionExtractFlags
(
from
)
)
;
}
static
inline
bool
VersionHasFlags
(
JSVersion
version
)
{
return
!
!
VersionExtractFlags
(
version
)
;
}
static
inline
bool
VersionIsKnown
(
JSVersion
version
)
{
return
VersionNumber
(
version
)
!
=
JSVERSION_UNKNOWN
;
}
inline
void
FreeOp
:
:
free_
(
void
*
p
)
{
js_free
(
p
)
;
}
inline
void
FreeOp
:
:
freeLater
(
void
*
p
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
freeLaterList
.
append
(
p
)
)
oomUnsafe
.
crash
(
"
FreeOp
:
:
freeLater
"
)
;
}
inline
bool
FreeOp
:
:
appendJitPoisonRange
(
const
jit
:
:
JitPoisonRange
&
range
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
return
jitPoisonRanges
.
append
(
range
)
;
}
class
MOZ_RAII
AutoLockGC
{
public
:
explicit
AutoLockGC
(
JSRuntime
*
rt
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
runtime_
(
rt
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
lock
(
)
;
}
~
AutoLockGC
(
)
{
unlock
(
)
;
}
void
lock
(
)
{
MOZ_ASSERT
(
lockGuard_
.
isNothing
(
)
)
;
lockGuard_
.
emplace
(
runtime_
-
>
gc
.
lock
)
;
}
void
unlock
(
)
{
MOZ_ASSERT
(
lockGuard_
.
isSome
(
)
)
;
lockGuard_
.
reset
(
)
;
}
js
:
:
LockGuard
<
js
:
:
Mutex
>
&
guard
(
)
{
return
lockGuard_
.
ref
(
)
;
}
private
:
JSRuntime
*
runtime_
;
mozilla
:
:
Maybe
<
js
:
:
LockGuard
<
js
:
:
Mutex
>
>
lockGuard_
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
AutoLockGC
(
const
AutoLockGC
&
)
=
delete
;
AutoLockGC
&
operator
=
(
const
AutoLockGC
&
)
=
delete
;
}
;
class
MOZ_RAII
AutoUnlockGC
{
public
:
explicit
AutoUnlockGC
(
AutoLockGC
&
lock
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
lock
(
lock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
lock
.
unlock
(
)
;
}
~
AutoUnlockGC
(
)
{
lock
.
lock
(
)
;
}
private
:
AutoLockGC
&
lock
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
AutoUnlockGC
(
const
AutoUnlockGC
&
)
=
delete
;
AutoUnlockGC
&
operator
=
(
const
AutoUnlockGC
&
)
=
delete
;
}
;
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
vec
size_t
len
)
{
mozilla
:
:
PodZero
(
vec
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Value
*
beg
Value
*
end
)
{
mozilla
:
:
PodZero
(
beg
end
-
beg
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
beg
jsid
*
end
)
{
for
(
jsid
*
id
=
beg
;
id
!
=
end
;
+
+
id
)
*
id
=
INT_TO_JSID
(
0
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
jsid
*
vec
size_t
len
)
{
MakeRangeGCSafe
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
beg
Shape
*
*
end
)
{
mozilla
:
:
PodZero
(
beg
end
-
beg
)
;
}
static
MOZ_ALWAYS_INLINE
void
MakeRangeGCSafe
(
Shape
*
*
vec
size_t
len
)
{
mozilla
:
:
PodZero
(
vec
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
v
-
>
setUndefined
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToUndefined
(
Value
*
vec
size_t
len
)
{
SetValueRangeToUndefined
(
vec
vec
+
len
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
beg
Value
*
end
)
{
for
(
Value
*
v
=
beg
;
v
!
=
end
;
+
+
v
)
v
-
>
setNull
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
SetValueRangeToNull
(
Value
*
vec
size_t
len
)
{
SetValueRangeToNull
(
vec
vec
+
len
)
;
}
class
RuntimeAllocPolicy
{
JSRuntime
*
const
runtime
;
public
:
MOZ_IMPLICIT
RuntimeAllocPolicy
(
JSRuntime
*
rt
)
:
runtime
(
rt
)
{
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
return
runtime
-
>
maybe_pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
return
runtime
-
>
maybe_pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
runtime
-
>
maybe_pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
runtime
-
>
pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
runtime
-
>
pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
runtime
-
>
pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
void
free_
(
void
*
p
)
{
js_free
(
p
)
;
}
void
reportAllocOverflow
(
)
const
{
}
bool
checkSimulatedOOM
(
)
const
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
}
;
extern
const
JSSecurityCallbacks
NullSecurityCallbacks
;
inline
Nursery
&
ZoneGroup
:
:
nursery
(
)
{
return
runtime
-
>
gc
.
nursery
(
)
;
}
inline
gc
:
:
StoreBuffer
&
ZoneGroup
:
:
storeBuffer
(
)
{
return
runtime
-
>
gc
.
storeBuffer
(
)
;
}
inline
void
ZoneGroup
:
:
callAfterMinorGC
(
void
(
*
thunk
)
(
void
*
data
)
void
*
data
)
{
nursery
(
)
.
queueSweepAction
(
thunk
data
)
;
}
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
endif
