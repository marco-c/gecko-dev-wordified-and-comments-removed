#
ifndef
vm_ArrayBufferViewObject_h
#
define
vm_ArrayBufferViewObject_h
#
include
"
builtin
/
TypedArrayConstants
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
SharedArrayObject
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
namespace
js
{
class
ArrayBufferViewObject
:
public
NativeObject
{
public
:
static
constexpr
size_t
BUFFER_SLOT
=
0
;
static_assert
(
BUFFER_SLOT
=
=
JS_TYPEDARRAYLAYOUT_BUFFER_SLOT
"
self
-
hosted
code
with
burned
-
in
constants
must
get
the
"
"
right
buffer
slot
"
)
;
static
constexpr
size_t
LENGTH_SLOT
=
1
;
static
constexpr
size_t
BYTEOFFSET_SLOT
=
2
;
static
constexpr
size_t
RESERVED_SLOTS
=
3
;
#
ifdef
DEBUG
static
const
uint8_t
ZeroLengthArrayData
=
0x4A
;
#
endif
static
constexpr
size_t
DATA_SLOT
=
3
;
static
constexpr
int
lengthOffset
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
LENGTH_SLOT
)
;
}
static
constexpr
int
byteOffsetOffset
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
BYTEOFFSET_SLOT
)
;
}
static
constexpr
int
dataOffset
(
)
{
return
NativeObject
:
:
getPrivateDataOffset
(
DATA_SLOT
)
;
}
private
:
void
*
dataPointerEither_
(
)
const
{
return
static_cast
<
void
*
>
(
getPrivate
(
DATA_SLOT
)
)
;
}
public
:
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
ArrayBufferObjectMaybeShared
*
buffer
uint32_t
byteOffset
uint32_t
length
uint32_t
bytesPerElement
)
;
static
ArrayBufferObjectMaybeShared
*
bufferObject
(
JSContext
*
cx
Handle
<
ArrayBufferViewObject
*
>
obj
)
;
void
notifyBufferDetached
(
)
;
void
initDataPointer
(
SharedMem
<
uint8_t
*
>
viewData
)
{
initPrivate
(
viewData
.
unwrap
(
)
)
;
}
SharedMem
<
void
*
>
dataPointerShared
(
)
const
{
return
SharedMem
<
void
*
>
:
:
shared
(
dataPointerEither_
(
)
)
;
}
SharedMem
<
void
*
>
dataPointerEither
(
)
const
{
if
(
isSharedMemory
(
)
)
{
return
SharedMem
<
void
*
>
:
:
shared
(
dataPointerEither_
(
)
)
;
}
return
SharedMem
<
void
*
>
:
:
unshared
(
dataPointerEither_
(
)
)
;
}
void
*
dataPointerUnshared
(
)
const
{
MOZ_ASSERT
(
!
isSharedMemory
(
)
)
;
return
dataPointerEither_
(
)
;
}
Value
bufferValue
(
)
const
{
return
getFixedSlot
(
BUFFER_SLOT
)
;
}
bool
hasBuffer
(
)
const
{
return
bufferValue
(
)
.
isObject
(
)
;
}
ArrayBufferObject
*
bufferUnshared
(
)
const
{
MOZ_ASSERT
(
!
isSharedMemory
(
)
)
;
ArrayBufferObjectMaybeShared
*
obj
=
bufferEither
(
)
;
if
(
!
obj
)
{
return
nullptr
;
}
return
&
obj
-
>
as
<
ArrayBufferObject
>
(
)
;
}
SharedArrayBufferObject
*
bufferShared
(
)
const
{
MOZ_ASSERT
(
isSharedMemory
(
)
)
;
ArrayBufferObjectMaybeShared
*
obj
=
bufferEither
(
)
;
if
(
!
obj
)
{
return
nullptr
;
}
return
&
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
}
ArrayBufferObjectMaybeShared
*
bufferEither
(
)
const
{
JSObject
*
obj
=
bufferValue
(
)
.
toObjectOrNull
(
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
isSharedMemory
(
)
?
obj
-
>
is
<
SharedArrayBufferObject
>
(
)
:
obj
-
>
is
<
ArrayBufferObject
>
(
)
)
;
return
&
obj
-
>
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
}
bool
hasDetachedBuffer
(
)
const
{
if
(
isSharedMemory
(
)
)
{
return
false
;
}
ArrayBufferObject
*
buffer
=
bufferUnshared
(
)
;
if
(
!
buffer
)
{
return
false
;
}
return
buffer
-
>
isDetached
(
)
;
}
BufferSize
byteOffset
(
)
const
{
return
BufferSize
(
size_t
(
getFixedSlot
(
BYTEOFFSET_SLOT
)
.
toPrivate
(
)
)
)
;
}
Value
byteOffsetValue
(
)
const
{
size_t
offset
=
byteOffset
(
)
.
get
(
)
;
return
NumberValue
(
offset
)
;
}
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
}
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
ArrayBufferViewObject
>
(
)
const
;
#
endif
