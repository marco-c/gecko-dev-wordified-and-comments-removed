#
ifndef
vm_ModuleBuilder_h
#
define
vm_ModuleBuilder_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
EitherParser
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
TaggedParserAtomIndexHasher
.
h
"
#
include
"
js
/
GCVector
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSAtom
;
namespace
js
{
namespace
frontend
{
class
BinaryNode
;
class
ListNode
;
class
ParseNode
;
}
class
MOZ_STACK_CLASS
ModuleBuilder
{
explicit
ModuleBuilder
(
FrontendContext
*
fc
const
frontend
:
:
EitherParser
&
eitherParser
)
;
public
:
template
<
class
Parser
>
explicit
ModuleBuilder
(
FrontendContext
*
fc
Parser
*
parser
)
:
ModuleBuilder
(
fc
frontend
:
:
EitherParser
(
parser
)
)
{
}
bool
processImport
(
frontend
:
:
BinaryNode
*
importNode
)
;
bool
processExport
(
frontend
:
:
ParseNode
*
exportNode
)
;
bool
processExportFrom
(
frontend
:
:
BinaryNode
*
exportNode
)
;
bool
hasExportedName
(
frontend
:
:
TaggedParserAtomIndex
name
)
const
;
bool
buildTables
(
frontend
:
:
StencilModuleMetadata
&
metadata
)
;
bool
noteFunctionDeclaration
(
FrontendContext
*
fc
uint32_t
funIndex
)
;
void
finishFunctionDecls
(
frontend
:
:
StencilModuleMetadata
&
metadata
)
;
void
noteAsync
(
frontend
:
:
StencilModuleMetadata
&
metadata
)
;
private
:
using
MaybeModuleRequestIndex
=
frontend
:
:
MaybeModuleRequestIndex
;
using
ModuleRequestVector
=
frontend
:
:
StencilModuleMetadata
:
:
RequestVector
;
using
RequestedModuleVector
=
frontend
:
:
StencilModuleMetadata
:
:
EntryVector
;
using
AtomSet
=
HashSet
<
frontend
:
:
TaggedParserAtomIndex
frontend
:
:
TaggedParserAtomIndexHasher
>
;
using
ExportEntryVector
=
Vector
<
frontend
:
:
StencilModuleEntry
>
;
using
ImportEntryMap
=
HashMap
<
frontend
:
:
TaggedParserAtomIndex
frontend
:
:
StencilModuleEntry
frontend
:
:
TaggedParserAtomIndexHasher
>
;
FrontendContext
*
fc_
;
frontend
:
:
EitherParser
eitherParser_
;
ModuleRequestVector
moduleRequests_
;
AtomSet
requestedModuleSpecifiers_
;
RequestedModuleVector
requestedModules_
;
ImportEntryMap
importEntries_
;
ExportEntryVector
exportEntries_
;
AtomSet
exportNames_
;
FunctionDeclarationVector
functionDecls_
;
frontend
:
:
StencilModuleEntry
*
importEntryFor
(
frontend
:
:
TaggedParserAtomIndex
localName
)
const
;
bool
processExportBinding
(
frontend
:
:
ParseNode
*
binding
)
;
bool
processExportArrayBinding
(
frontend
:
:
ListNode
*
array
)
;
bool
processExportObjectBinding
(
frontend
:
:
ListNode
*
obj
)
;
MaybeModuleRequestIndex
appendModuleRequest
(
frontend
:
:
TaggedParserAtomIndex
specifier
frontend
:
:
ListNode
*
assertionList
)
;
bool
appendExportEntry
(
frontend
:
:
TaggedParserAtomIndex
exportName
frontend
:
:
TaggedParserAtomIndex
localName
frontend
:
:
ParseNode
*
node
=
nullptr
)
;
bool
maybeAppendRequestedModule
(
MaybeModuleRequestIndex
moduleRequest
frontend
:
:
ParseNode
*
node
)
;
void
markUsedByStencil
(
frontend
:
:
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
processAssertions
(
frontend
:
:
StencilModuleRequest
&
request
frontend
:
:
ListNode
*
assertionList
)
;
[
[
nodiscard
]
]
bool
isAssertionSupported
(
frontend
:
:
TaggedParserAtomIndex
key
)
;
}
;
template
<
typename
T
>
ArrayObject
*
CreateArray
(
JSContext
*
cx
const
JS
:
:
Rooted
<
JS
:
:
GCVector
<
T
>
>
&
vector
)
;
}
#
endif
