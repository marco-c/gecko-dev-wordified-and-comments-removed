#
ifndef
TraceLoggingTypes_h
#
define
TraceLoggingTypes_h
#
include
"
builtin
/
String
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
define
TRACELOGGER_TREE_ITEMS
(
_
)
\
_
(
AnnotateScripts
)
\
_
(
Baseline
)
\
_
(
BaselineCompilation
)
\
_
(
Engine
)
\
_
(
GC
)
\
_
(
GCAllocation
)
\
_
(
GCSweeping
)
\
_
(
GCFree
)
\
_
(
Interpreter
)
\
_
(
InlinedScripts
)
\
_
(
IonAnalysis
)
\
_
(
IonCompilation
)
\
_
(
IonLinking
)
\
_
(
IonMonkey
)
\
_
(
IrregexpCompile
)
\
_
(
IrregexpExecute
)
\
_
(
MinorGC
)
\
_
(
Frontend
)
\
_
(
ParsingFull
)
\
_
(
ParsingSyntax
)
\
_
(
BytecodeEmission
)
\
_
(
BytecodeFoldConstants
)
\
_
(
BytecodeNameFunctions
)
\
_
(
DecodeScript
)
\
_
(
DecodeFunction
)
\
_
(
EncodeScript
)
\
_
(
EncodeFunction
)
\
_
(
Scripts
)
\
_
(
VM
)
\
_
(
CompressSource
)
\
_
(
WasmCompilation
)
\
_
(
Call
)
\
\
/
*
Specific
passes
during
ion
compilation
*
/
\
_
(
PruneUnusedBranches
)
\
_
(
FoldTests
)
\
_
(
FoldEmptyBlocks
)
\
_
(
SplitCriticalEdges
)
\
_
(
RenumberBlocks
)
\
_
(
ScalarReplacement
)
\
_
(
DominatorTree
)
\
_
(
PhiAnalysis
)
\
_
(
MakeLoopsContiguous
)
\
_
(
ApplyTypes
)
\
_
(
EagerSimdUnbox
)
\
_
(
AliasAnalysis
)
\
_
(
GVN
)
\
_
(
LICM
)
\
_
(
Sincos
)
\
_
(
RangeAnalysis
)
\
_
(
LoopUnrolling
)
\
_
(
Sink
)
\
_
(
RemoveUnnecessaryBitops
)
\
_
(
FoldLinearArithConstants
)
\
_
(
EffectiveAddressAnalysis
)
\
_
(
AlignmentMaskAnalysis
)
\
_
(
EliminateDeadCode
)
\
_
(
ReorderInstructions
)
\
_
(
EdgeCaseAnalysis
)
\
_
(
EliminateRedundantChecks
)
\
_
(
AddKeepAliveInstructions
)
\
_
(
GenerateLIR
)
\
_
(
RegisterAllocation
)
\
_
(
GenerateCode
)
\
_
(
IonBuilderRestartLoop
)
\
_
(
VMSpecific
)
#
define
TRACELOGGER_LOG_ITEMS
(
_
)
\
_
(
Bailout
)
\
_
(
Invalidation
)
\
_
(
Disable
)
\
_
(
Enable
)
\
_
(
Stop
)
enum
TraceLoggerTextId
{
TraceLogger_Error
=
0
TraceLogger_Internal
#
define
DEFINE_TEXT_ID
(
textId
)
TraceLogger_
#
#
textId
TRACELOGGER_TREE_ITEMS
(
DEFINE_TEXT_ID
)
TraceLogger_TreeItemEnd
TRACELOGGER_LOG_ITEMS
(
DEFINE_TEXT_ID
)
#
undef
DEFINE_TEXT_ID
TraceLogger_Last
}
;
inline
const
char
*
TLTextIdString
(
TraceLoggerTextId
id
)
{
switch
(
id
)
{
case
TraceLogger_Error
:
return
"
TraceLogger
failed
to
process
text
"
;
case
TraceLogger_Internal
:
case
TraceLogger_TreeItemEnd
:
return
"
TraceLogger
internal
event
"
;
#
define
NAME
(
textId
)
\
case
TraceLogger_
#
#
textId
:
\
return
#
textId
;
TRACELOGGER_TREE_ITEMS
(
NAME
)
TRACELOGGER_LOG_ITEMS
(
NAME
)
#
undef
NAME
default
:
MOZ_CRASH
(
)
;
}
}
uint32_t
TLStringToTextId
(
JSLinearString
*
str
)
;
inline
bool
TLTextIdIsTogglable
(
uint32_t
id
)
{
if
(
id
=
=
TraceLogger_Error
)
{
return
false
;
}
if
(
id
=
=
TraceLogger_Internal
)
{
return
false
;
}
if
(
id
=
=
TraceLogger_Stop
)
{
return
false
;
}
if
(
id
=
=
TraceLogger_TreeItemEnd
)
{
return
false
;
}
if
(
id
=
=
TraceLogger_Last
)
{
return
false
;
}
if
(
id
=
=
TraceLogger_IonMonkey
|
|
id
=
=
TraceLogger_Baseline
|
|
id
=
=
TraceLogger_Interpreter
)
{
return
false
;
}
return
true
;
}
inline
bool
TLTextIdIsEnumEvent
(
uint32_t
id
)
{
return
id
<
TraceLogger_Last
;
}
inline
bool
TLTextIdIsScriptEvent
(
uint32_t
id
)
{
return
!
TLTextIdIsEnumEvent
(
id
)
;
}
inline
bool
TLTextIdIsTreeEvent
(
uint32_t
id
)
{
return
(
id
>
TraceLogger_Error
&
&
id
<
TraceLogger_TreeItemEnd
)
|
|
id
>
=
TraceLogger_Last
;
}
inline
bool
TLTextIdIsLogEvent
(
uint32_t
id
)
{
return
(
id
>
TraceLogger_TreeItemEnd
&
&
id
<
TraceLogger_Last
)
;
}
inline
bool
TLTextIdIsInternalEvent
(
uint32_t
id
)
{
return
(
id
=
=
TraceLogger_Error
|
|
id
=
=
TraceLogger_Last
|
|
id
=
=
TraceLogger_TreeItemEnd
|
|
id
=
=
TraceLogger_Internal
|
|
id
=
=
TraceLogger_Stop
)
;
}
template
<
class
T
>
class
ContinuousSpace
{
T
*
data_
;
uint32_t
size_
;
uint32_t
capacity_
;
static
const
uint32_t
LIMIT
=
200
*
1024
*
1024
;
public
:
ContinuousSpace
(
)
:
data_
(
nullptr
)
size_
(
0
)
capacity_
(
0
)
{
}
bool
init
(
)
{
capacity_
=
64
;
size_
=
0
;
data_
=
js_pod_malloc
<
T
>
(
capacity_
)
;
if
(
!
data_
)
{
return
false
;
}
return
true
;
}
~
ContinuousSpace
(
)
{
js_free
(
data_
)
;
data_
=
nullptr
;
}
static
uint32_t
maxSize
(
)
{
return
LIMIT
/
sizeof
(
T
)
;
}
T
*
data
(
)
{
return
data_
;
}
uint32_t
capacity
(
)
const
{
return
capacity_
;
}
uint32_t
size
(
)
const
{
return
size_
;
}
bool
empty
(
)
const
{
return
size_
=
=
0
;
}
uint32_t
lastEntryId
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
size_
-
1
;
}
T
&
lastEntry
(
)
{
return
data
(
)
[
lastEntryId
(
)
]
;
}
bool
hasSpaceForAdd
(
uint32_t
count
=
1
)
{
if
(
size_
+
count
<
=
capacity_
)
{
return
true
;
}
return
false
;
}
bool
ensureSpaceBeforeAdd
(
uint32_t
count
=
1
)
{
MOZ_ASSERT
(
data_
)
;
if
(
hasSpaceForAdd
(
count
)
)
{
return
true
;
}
if
(
size_
+
count
>
maxSize
(
)
)
{
return
false
;
}
uint32_t
nCapacity
=
capacity_
*
2
;
nCapacity
=
(
nCapacity
<
maxSize
(
)
)
?
nCapacity
:
maxSize
(
)
;
T
*
entries
=
js_pod_realloc
<
T
>
(
data_
capacity_
nCapacity
)
;
if
(
!
entries
)
{
return
false
;
}
data_
=
entries
;
capacity_
=
nCapacity
;
return
true
;
}
T
&
operator
[
]
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
size_
)
;
return
data
(
)
[
i
]
;
}
void
push
(
T
&
data
)
{
MOZ_ASSERT
(
size_
<
capacity_
)
;
data
(
)
[
size_
+
+
]
=
data
;
}
T
&
pushUninitialized
(
)
{
MOZ_ASSERT
(
size_
<
capacity_
)
;
return
data
(
)
[
size_
+
+
]
;
}
void
pop
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
size_
-
-
;
}
void
clear
(
)
{
size_
=
0
;
}
bool
reset
(
)
{
size_t
oldCapacity
=
data_
?
capacity_
:
0
;
capacity_
=
64
;
size_
=
0
;
data_
=
js_pod_realloc
<
T
>
(
data_
oldCapacity
capacity_
)
;
if
(
!
data_
)
{
return
false
;
}
return
true
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
data_
)
;
}
}
;
struct
EventEntry
{
mozilla
:
:
TimeStamp
time
;
uint32_t
textId
;
EventEntry
(
)
:
textId
(
0
)
{
}
}
;
#
endif
