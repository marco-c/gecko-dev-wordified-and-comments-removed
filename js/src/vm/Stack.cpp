#
include
"
vm
/
Stack
-
inl
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
jit
/
JitcodeMap
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
FrameIter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
jit
/
JSJitFrameIter
-
inl
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
Probes
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
using
JS
:
:
Value
;
void
InterpreterFrame
:
:
initExecuteFrame
(
JSContext
*
cx
HandleScript
script
AbstractFramePtr
evalInFramePrev
HandleValue
newTargetValue
HandleObject
envChain
)
{
flags_
=
0
;
script_
=
script
;
Value
*
dstvp
=
(
Value
*
)
this
-
1
;
dstvp
[
0
]
=
newTargetValue
;
envChain_
=
envChain
.
get
(
)
;
prev_
=
nullptr
;
prevpc_
=
nullptr
;
prevsp_
=
nullptr
;
evalInFramePrev_
=
evalInFramePrev
;
MOZ_ASSERT_IF
(
evalInFramePrev
isDebuggerEvalFrame
(
)
)
;
if
(
script
-
>
isDebuggee
(
)
)
{
setIsDebuggee
(
)
;
}
#
ifdef
DEBUG
Debug_SetValueRangeToCrashOnTouch
(
&
rval_
1
)
;
#
endif
}
ArrayObject
*
InterpreterFrame
:
:
createRestParameter
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
script
(
)
-
>
hasRest
(
)
)
;
unsigned
nformal
=
callee
(
)
.
nargs
(
)
-
1
nactual
=
numActualArgs
(
)
;
unsigned
nrest
=
(
nactual
>
nformal
)
?
nactual
-
nformal
:
0
;
Value
*
restvp
=
argv
(
)
+
nformal
;
return
NewDenseCopiedArray
(
cx
nrest
restvp
)
;
}
static
inline
void
AssertScopeMatchesEnvironment
(
Scope
*
scope
JSObject
*
originalEnv
)
{
#
ifdef
DEBUG
JSObject
*
env
=
originalEnv
;
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
NonSyntactic
)
{
while
(
env
-
>
is
<
WithEnvironmentObject
>
(
)
|
|
env
-
>
is
<
NonSyntacticVariablesObject
>
(
)
|
|
(
env
-
>
is
<
LexicalEnvironmentObject
>
(
)
&
&
!
env
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
isSyntactic
(
)
)
)
{
MOZ_ASSERT
(
!
IsSyntacticEnvironment
(
env
)
)
;
env
=
&
env
-
>
as
<
EnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
}
}
else
if
(
si
.
hasSyntacticEnvironment
(
)
)
{
switch
(
si
.
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
MOZ_ASSERT
(
env
-
>
as
<
CallObject
>
(
)
.
callee
(
)
.
maybeCanonicalFunction
(
)
-
>
nonLazyScript
(
)
=
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
script
(
)
)
;
env
=
&
env
-
>
as
<
CallObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
FunctionBodyVar
:
MOZ_ASSERT
(
&
env
-
>
as
<
VarEnvironmentObject
>
(
)
.
scope
(
)
=
=
si
.
scope
(
)
)
;
env
=
&
env
-
>
as
<
VarEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
MOZ_ASSERT
(
&
env
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
scope
(
)
=
=
si
.
scope
(
)
)
;
env
=
&
env
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
With
:
MOZ_ASSERT
(
&
env
-
>
as
<
WithEnvironmentObject
>
(
)
.
scope
(
)
=
=
si
.
scope
(
)
)
;
env
=
&
env
-
>
as
<
WithEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
env
=
&
env
-
>
as
<
VarEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
Global
:
MOZ_ASSERT
(
env
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
isGlobal
(
)
)
;
env
=
&
env
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
MOZ_ASSERT
(
env
-
>
is
<
GlobalObject
>
(
)
)
;
break
;
case
ScopeKind
:
:
NonSyntactic
:
MOZ_CRASH
(
"
NonSyntactic
should
not
have
a
syntactic
environment
"
)
;
break
;
case
ScopeKind
:
:
Module
:
MOZ_ASSERT
(
&
env
-
>
as
<
ModuleEnvironmentObject
>
(
)
.
module
(
)
=
=
si
.
scope
(
)
-
>
as
<
ModuleScope
>
(
)
.
module
(
)
)
;
env
=
&
env
-
>
as
<
ModuleEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
WasmInstance
:
env
=
&
env
-
>
as
<
WasmInstanceEnvironmentObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
case
ScopeKind
:
:
WasmFunction
:
env
=
&
env
-
>
as
<
WasmFunctionCallObject
>
(
)
.
enclosingEnvironment
(
)
;
break
;
}
}
}
MOZ_ASSERT
(
env
-
>
is
<
GlobalObject
>
(
)
|
|
IsGlobalLexicalEnvironment
(
env
)
|
|
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
;
#
endif
}
static
inline
void
AssertScopeMatchesEnvironment
(
InterpreterFrame
*
fp
jsbytecode
*
pc
)
{
#
ifdef
DEBUG
if
(
fp
-
>
script
(
)
-
>
initialEnvironmentShape
(
)
&
&
fp
-
>
hasInitialEnvironment
(
)
)
{
AssertScopeMatchesEnvironment
(
fp
-
>
script
(
)
-
>
innermostScope
(
pc
)
fp
-
>
environmentChain
(
)
)
;
}
#
endif
}
bool
InterpreterFrame
:
:
initFunctionEnvironmentObjects
(
JSContext
*
cx
)
{
return
js
:
:
InitFunctionEnvironmentObjects
(
cx
this
)
;
}
bool
InterpreterFrame
:
:
prologue
(
JSContext
*
cx
)
{
RootedScript
script
(
cx
this
-
>
script
(
)
)
;
MOZ_ASSERT
(
cx
-
>
interpreterRegs
(
)
.
pc
=
=
script
-
>
code
(
)
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
script
-
>
realm
(
)
)
;
if
(
!
isFunctionFrame
(
)
)
{
return
probes
:
:
EnterScript
(
cx
script
nullptr
this
)
;
}
AssertScopeMatchesEnvironment
(
script
-
>
enclosingScope
(
)
environmentChain
(
)
)
;
if
(
callee
(
)
.
needsFunctionEnvironmentObjects
(
)
&
&
!
initFunctionEnvironmentObjects
(
cx
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
isConstructing
(
)
thisArgument
(
)
.
isObject
(
)
|
|
thisArgument
(
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
;
return
probes
:
:
EnterScript
(
cx
script
script
-
>
function
(
)
this
)
;
}
void
InterpreterFrame
:
:
epilogue
(
JSContext
*
cx
jsbytecode
*
pc
)
{
RootedScript
script
(
cx
this
-
>
script
(
)
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
script
-
>
realm
(
)
)
;
probes
:
:
ExitScript
(
cx
script
script
-
>
function
(
)
hasPushedGeckoProfilerFrame
(
)
)
;
AssertScopeMatchesEnvironment
(
this
pc
)
;
EnvironmentIter
ei
(
cx
this
pc
)
;
UnwindAllEnvironmentsInFrame
(
cx
ei
)
;
if
(
isFunctionFrame
(
)
)
{
if
(
!
callee
(
)
.
isGenerator
(
)
&
&
!
callee
(
)
.
isAsync
(
)
&
&
isConstructing
(
)
&
&
thisArgument
(
)
.
isObject
(
)
&
&
returnValue
(
)
.
isPrimitive
(
)
)
{
setReturnValue
(
thisArgument
(
)
)
;
}
return
;
}
MOZ_ASSERT
(
isEvalFrame
(
)
|
|
isGlobalFrame
(
)
|
|
isModuleFrame
(
)
)
;
}
bool
InterpreterFrame
:
:
checkReturn
(
JSContext
*
cx
HandleValue
thisv
)
{
MOZ_ASSERT
(
script
(
)
-
>
isDerivedClassConstructor
(
)
)
;
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
MOZ_ASSERT
(
callee
(
)
.
isClassConstructor
(
)
)
;
HandleValue
retVal
=
returnValue
(
)
;
if
(
retVal
.
isObject
(
)
)
{
return
true
;
}
if
(
!
retVal
.
isUndefined
(
)
)
{
ReportValueError
(
cx
JSMSG_BAD_DERIVED_RETURN
JSDVG_IGNORE_STACK
retVal
nullptr
)
;
return
false
;
}
if
(
thisv
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
{
return
ThrowUninitializedThis
(
cx
)
;
}
setReturnValue
(
thisv
)
;
return
true
;
}
bool
InterpreterFrame
:
:
pushVarEnvironment
(
JSContext
*
cx
HandleScope
scope
)
{
return
js
:
:
PushVarEnvironmentObject
(
cx
scope
this
)
;
}
bool
InterpreterFrame
:
:
pushLexicalEnvironment
(
JSContext
*
cx
Handle
<
LexicalScope
*
>
scope
)
{
LexicalEnvironmentObject
*
env
=
LexicalEnvironmentObject
:
:
createForFrame
(
cx
scope
this
)
;
if
(
!
env
)
{
return
false
;
}
pushOnEnvironmentChain
(
*
env
)
;
return
true
;
}
bool
InterpreterFrame
:
:
freshenLexicalEnvironment
(
JSContext
*
cx
)
{
Rooted
<
LexicalEnvironmentObject
*
>
env
(
cx
&
envChain_
-
>
as
<
LexicalEnvironmentObject
>
(
)
)
;
LexicalEnvironmentObject
*
fresh
=
LexicalEnvironmentObject
:
:
clone
(
cx
env
)
;
if
(
!
fresh
)
{
return
false
;
}
replaceInnermostEnvironment
(
*
fresh
)
;
return
true
;
}
bool
InterpreterFrame
:
:
recreateLexicalEnvironment
(
JSContext
*
cx
)
{
Rooted
<
LexicalEnvironmentObject
*
>
env
(
cx
&
envChain_
-
>
as
<
LexicalEnvironmentObject
>
(
)
)
;
LexicalEnvironmentObject
*
fresh
=
LexicalEnvironmentObject
:
:
recreate
(
cx
env
)
;
if
(
!
fresh
)
{
return
false
;
}
replaceInnermostEnvironment
(
*
fresh
)
;
return
true
;
}
void
InterpreterFrame
:
:
trace
(
JSTracer
*
trc
Value
*
sp
jsbytecode
*
pc
)
{
TraceRoot
(
trc
&
envChain_
"
env
chain
"
)
;
TraceRoot
(
trc
&
script_
"
script
"
)
;
if
(
flags_
&
HAS_ARGS_OBJ
)
{
TraceRoot
(
trc
&
argsObj_
"
arguments
"
)
;
}
if
(
hasReturnValue
(
)
)
{
TraceRoot
(
trc
&
rval_
"
rval
"
)
;
}
MOZ_ASSERT
(
sp
>
=
slots
(
)
)
;
if
(
hasArgs
(
)
)
{
TraceRootRange
(
trc
2
argv_
-
2
"
fp
callee
and
this
"
)
;
unsigned
argc
=
std
:
:
max
(
numActualArgs
(
)
numFormalArgs
(
)
)
;
TraceRootRange
(
trc
argc
+
isConstructing
(
)
argv_
"
fp
argv
"
)
;
}
else
{
TraceRoot
(
trc
(
(
Value
*
)
this
)
-
1
"
stack
newTarget
"
)
;
}
JSScript
*
script
=
this
-
>
script
(
)
;
size_t
nfixed
=
script
-
>
nfixed
(
)
;
size_t
nlivefixed
=
script
-
>
calculateLiveFixed
(
pc
)
;
if
(
nfixed
=
=
nlivefixed
)
{
traceValues
(
trc
0
sp
-
slots
(
)
)
;
}
else
{
traceValues
(
trc
nfixed
sp
-
slots
(
)
)
;
while
(
nfixed
>
nlivefixed
)
{
unaliasedLocal
(
-
-
nfixed
)
.
setUndefined
(
)
;
}
traceValues
(
trc
0
nlivefixed
)
;
}
if
(
auto
*
debugEnvs
=
script
-
>
realm
(
)
-
>
debugEnvs
(
)
)
{
debugEnvs
-
>
traceLiveFrame
(
trc
this
)
;
}
}
void
InterpreterFrame
:
:
traceValues
(
JSTracer
*
trc
unsigned
start
unsigned
end
)
{
if
(
start
<
end
)
{
TraceRootRange
(
trc
end
-
start
slots
(
)
+
start
"
vm_stack
"
)
;
}
}
static
void
TraceInterpreterActivation
(
JSTracer
*
trc
InterpreterActivation
*
act
)
{
for
(
InterpreterFrameIterator
frames
(
act
)
;
!
frames
.
done
(
)
;
+
+
frames
)
{
InterpreterFrame
*
fp
=
frames
.
frame
(
)
;
fp
-
>
trace
(
trc
frames
.
sp
(
)
frames
.
pc
(
)
)
;
}
}
void
js
:
:
TraceInterpreterActivations
(
JSContext
*
cx
JSTracer
*
trc
)
{
for
(
ActivationIterator
iter
(
cx
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
Activation
*
act
=
iter
.
activation
(
)
;
if
(
act
-
>
isInterpreter
(
)
)
{
TraceInterpreterActivation
(
trc
act
-
>
asInterpreter
(
)
)
;
}
}
}
void
InterpreterRegs
:
:
setToEndOfScript
(
)
{
sp
=
fp
(
)
-
>
base
(
)
;
}
InterpreterFrame
*
InterpreterStack
:
:
pushInvokeFrame
(
JSContext
*
cx
const
CallArgs
&
args
MaybeConstruct
constructing
)
{
LifoAlloc
:
:
Mark
mark
=
allocator_
.
mark
(
)
;
RootedFunction
fun
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedScript
script
(
cx
fun
-
>
nonLazyScript
(
)
)
;
Value
*
argv
;
InterpreterFrame
*
fp
=
getCallFrame
(
cx
args
script
constructing
&
argv
)
;
if
(
!
fp
)
{
return
nullptr
;
}
fp
-
>
mark_
=
mark
;
fp
-
>
initCallFrame
(
nullptr
nullptr
nullptr
*
fun
script
argv
args
.
length
(
)
constructing
)
;
return
fp
;
}
InterpreterFrame
*
InterpreterStack
:
:
pushExecuteFrame
(
JSContext
*
cx
HandleScript
script
HandleValue
newTargetValue
HandleObject
envChain
AbstractFramePtr
evalInFrame
)
{
LifoAlloc
:
:
Mark
mark
=
allocator_
.
mark
(
)
;
unsigned
nvars
=
1
+
script
-
>
nslots
(
)
;
uint8_t
*
buffer
=
allocateFrame
(
cx
sizeof
(
InterpreterFrame
)
+
nvars
*
sizeof
(
Value
)
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
InterpreterFrame
*
fp
=
reinterpret_cast
<
InterpreterFrame
*
>
(
buffer
+
1
*
sizeof
(
Value
)
)
;
fp
-
>
mark_
=
mark
;
fp
-
>
initExecuteFrame
(
cx
script
evalInFrame
newTargetValue
envChain
)
;
fp
-
>
initLocals
(
)
;
return
fp
;
}
InterpreterFrameIterator
&
InterpreterFrameIterator
:
:
operator
+
+
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
fp_
!
=
activation_
-
>
entryFrame_
)
{
pc_
=
fp_
-
>
prevpc
(
)
;
sp_
=
fp_
-
>
prevsp
(
)
;
fp_
=
fp_
-
>
prev
(
)
;
}
else
{
pc_
=
nullptr
;
sp_
=
nullptr
;
fp_
=
nullptr
;
}
return
*
this
;
}
JS
:
:
ProfilingFrameIterator
:
:
ProfilingFrameIterator
(
JSContext
*
cx
const
RegisterState
&
state
const
Maybe
<
uint64_t
>
&
samplePositionInProfilerBuffer
)
:
cx_
(
cx
)
samplePositionInProfilerBuffer_
(
samplePositionInProfilerBuffer
)
activation_
(
nullptr
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
MOZ_CRASH
(
"
ProfilingFrameIterator
called
when
geckoProfiler
not
enabled
for
"
"
runtime
.
"
)
;
}
if
(
!
cx
-
>
profilingActivation
(
)
)
{
return
;
}
if
(
!
cx
-
>
isProfilerSamplingEnabled
(
)
)
{
return
;
}
activation_
=
cx
-
>
profilingActivation
(
)
;
MOZ_ASSERT
(
activation_
-
>
isProfiling
(
)
)
;
static_assert
(
sizeof
(
wasm
:
:
ProfilingFrameIterator
)
<
=
StorageSpace
&
&
sizeof
(
jit
:
:
JSJitProfilingFrameIterator
)
<
=
StorageSpace
"
ProfilingFrameIterator
:
:
storage_
is
too
small
"
)
;
static_assert
(
alignof
(
void
*
)
>
=
alignof
(
wasm
:
:
ProfilingFrameIterator
)
&
&
alignof
(
void
*
)
>
=
alignof
(
jit
:
:
JSJitProfilingFrameIterator
)
"
ProfilingFrameIterator
:
:
storage_
is
too
weakly
aligned
"
)
;
iteratorConstruct
(
state
)
;
settle
(
)
;
}
JS
:
:
ProfilingFrameIterator
:
:
~
ProfilingFrameIterator
(
)
{
if
(
!
done
(
)
)
{
MOZ_ASSERT
(
activation_
-
>
isProfiling
(
)
)
;
iteratorDestroy
(
)
;
}
}
void
JS
:
:
ProfilingFrameIterator
:
:
operator
+
+
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
if
(
isWasm
(
)
)
{
+
+
wasmIter
(
)
;
}
else
{
+
+
jsJitIter
(
)
;
}
settle
(
)
;
}
void
JS
:
:
ProfilingFrameIterator
:
:
settleFrames
(
)
{
if
(
isJSJit
(
)
&
&
!
jsJitIter
(
)
.
done
(
)
&
&
jsJitIter
(
)
.
frameType
(
)
=
=
jit
:
:
FrameType
:
:
WasmToJSJit
)
{
wasm
:
:
Frame
*
fp
=
(
wasm
:
:
Frame
*
)
jsJitIter
(
)
.
fp
(
)
;
iteratorDestroy
(
)
;
new
(
storage
(
)
)
wasm
:
:
ProfilingFrameIterator
(
fp
)
;
kind_
=
Kind
:
:
Wasm
;
MOZ_ASSERT
(
!
wasmIter
(
)
.
done
(
)
)
;
return
;
}
if
(
isWasm
(
)
&
&
wasmIter
(
)
.
done
(
)
&
&
wasmIter
(
)
.
unwoundIonCallerFP
(
)
)
{
uint8_t
*
fp
=
wasmIter
(
)
.
unwoundIonCallerFP
(
)
;
iteratorDestroy
(
)
;
new
(
storage
(
)
)
jit
:
:
JSJitProfilingFrameIterator
(
(
jit
:
:
CommonFrameLayout
*
)
fp
)
;
kind_
=
Kind
:
:
JSJit
;
MOZ_ASSERT
(
!
jsJitIter
(
)
.
done
(
)
)
;
return
;
}
}
void
JS
:
:
ProfilingFrameIterator
:
:
settle
(
)
{
settleFrames
(
)
;
while
(
iteratorDone
(
)
)
{
iteratorDestroy
(
)
;
activation_
=
activation_
-
>
prevProfiling
(
)
;
if
(
!
activation_
)
{
return
;
}
iteratorConstruct
(
)
;
settleFrames
(
)
;
}
}
void
JS
:
:
ProfilingFrameIterator
:
:
iteratorConstruct
(
const
RegisterState
&
state
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
jit
:
:
JitActivation
*
activation
=
activation_
-
>
asJit
(
)
;
if
(
activation
-
>
hasWasmExitFP
(
)
|
|
wasm
:
:
InCompiledCode
(
state
.
pc
)
)
{
new
(
storage
(
)
)
wasm
:
:
ProfilingFrameIterator
(
*
activation
state
)
;
kind_
=
Kind
:
:
Wasm
;
return
;
}
new
(
storage
(
)
)
jit
:
:
JSJitProfilingFrameIterator
(
cx_
state
.
pc
)
;
kind_
=
Kind
:
:
JSJit
;
}
void
JS
:
:
ProfilingFrameIterator
:
:
iteratorConstruct
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
jit
:
:
JitActivation
*
activation
=
activation_
-
>
asJit
(
)
;
if
(
activation
-
>
hasWasmExitFP
(
)
)
{
new
(
storage
(
)
)
wasm
:
:
ProfilingFrameIterator
(
*
activation
)
;
kind_
=
Kind
:
:
Wasm
;
return
;
}
auto
*
fp
=
(
jit
:
:
ExitFrameLayout
*
)
activation
-
>
jsExitFP
(
)
;
new
(
storage
(
)
)
jit
:
:
JSJitProfilingFrameIterator
(
fp
)
;
kind_
=
Kind
:
:
JSJit
;
}
void
JS
:
:
ProfilingFrameIterator
:
:
iteratorDestroy
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
if
(
isWasm
(
)
)
{
wasmIter
(
)
.
~
ProfilingFrameIterator
(
)
;
return
;
}
jsJitIter
(
)
.
~
JSJitProfilingFrameIterator
(
)
;
}
bool
JS
:
:
ProfilingFrameIterator
:
:
iteratorDone
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
if
(
isWasm
(
)
)
{
return
wasmIter
(
)
.
done
(
)
;
}
return
jsJitIter
(
)
.
done
(
)
;
}
void
*
JS
:
:
ProfilingFrameIterator
:
:
stackAddress
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
activation_
-
>
isJit
(
)
)
;
if
(
isWasm
(
)
)
{
return
wasmIter
(
)
.
stackAddress
(
)
;
}
return
jsJitIter
(
)
.
stackAddress
(
)
;
}
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
JS
:
:
ProfilingFrameIterator
:
:
getPhysicalFrameAndEntry
(
jit
:
:
JitcodeGlobalEntry
*
entry
)
const
{
void
*
stackAddr
=
stackAddress
(
)
;
if
(
isWasm
(
)
)
{
Frame
frame
;
frame
.
kind
=
Frame_Wasm
;
frame
.
stackAddress
=
stackAddr
;
frame
.
returnAddress_
=
nullptr
;
frame
.
activation
=
activation_
;
frame
.
label
=
nullptr
;
frame
.
endStackAddress
=
activation_
-
>
asJit
(
)
-
>
jsOrWasmExitFP
(
)
;
frame
.
interpreterScript
=
nullptr
;
frame
.
realmID
=
0
;
return
mozilla
:
:
Some
(
frame
)
;
}
MOZ_ASSERT
(
isJSJit
(
)
)
;
void
*
returnAddr
=
jsJitIter
(
)
.
resumePCinCurrentFrame
(
)
;
jit
:
:
JitcodeGlobalTable
*
table
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getJitcodeGlobalTable
(
)
;
const
jit
:
:
JitcodeGlobalEntry
*
lookedUpEntry
=
nullptr
;
if
(
samplePositionInProfilerBuffer_
)
{
lookedUpEntry
=
table
-
>
lookupForSampler
(
returnAddr
cx_
-
>
runtime
(
)
*
samplePositionInProfilerBuffer_
)
;
}
else
{
lookedUpEntry
=
table
-
>
lookup
(
returnAddr
)
;
}
if
(
!
lookedUpEntry
)
{
return
mozilla
:
:
Nothing
(
)
;
}
*
entry
=
*
lookedUpEntry
;
MOZ_ASSERT
(
entry
-
>
isIon
(
)
|
|
entry
-
>
isBaseline
(
)
|
|
entry
-
>
isBaselineInterpreter
(
)
|
|
entry
-
>
isDummy
(
)
)
;
if
(
entry
-
>
isDummy
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
Frame
frame
;
if
(
entry
-
>
isBaselineInterpreter
(
)
)
{
frame
.
kind
=
Frame_BaselineInterpreter
;
}
else
if
(
entry
-
>
isBaseline
(
)
)
{
frame
.
kind
=
Frame_Baseline
;
}
else
{
frame
.
kind
=
Frame_Ion
;
}
frame
.
stackAddress
=
stackAddr
;
if
(
entry
-
>
isBaselineInterpreter
(
)
)
{
frame
.
label
=
jsJitIter
(
)
.
baselineInterpreterLabel
(
)
;
jsJitIter
(
)
.
baselineInterpreterScriptPC
(
&
frame
.
interpreterScript
&
frame
.
interpreterPC_
&
frame
.
realmID
)
;
MOZ_ASSERT
(
frame
.
interpreterScript
)
;
MOZ_ASSERT
(
frame
.
interpreterPC_
)
;
}
else
{
frame
.
interpreterScript
=
nullptr
;
frame
.
returnAddress_
=
returnAddr
;
frame
.
label
=
nullptr
;
frame
.
realmID
=
0
;
}
frame
.
activation
=
activation_
;
frame
.
endStackAddress
=
activation_
-
>
asJit
(
)
-
>
jsOrWasmExitFP
(
)
;
return
mozilla
:
:
Some
(
frame
)
;
}
uint32_t
JS
:
:
ProfilingFrameIterator
:
:
extractStack
(
Frame
*
frames
uint32_t
offset
uint32_t
end
)
const
{
if
(
offset
>
=
end
)
{
return
0
;
}
jit
:
:
JitcodeGlobalEntry
entry
;
Maybe
<
Frame
>
physicalFrame
=
getPhysicalFrameAndEntry
(
&
entry
)
;
if
(
physicalFrame
.
isNothing
(
)
)
{
return
0
;
}
if
(
isWasm
(
)
)
{
frames
[
offset
]
=
physicalFrame
.
value
(
)
;
frames
[
offset
]
.
label
=
wasmIter
(
)
.
label
(
)
;
return
1
;
}
if
(
physicalFrame
-
>
kind
=
=
Frame_BaselineInterpreter
)
{
frames
[
offset
]
=
physicalFrame
.
value
(
)
;
return
1
;
}
const
char
*
labels
[
64
]
;
uint32_t
depth
=
entry
.
callStackAtAddr
(
cx_
-
>
runtime
(
)
jsJitIter
(
)
.
resumePCinCurrentFrame
(
)
labels
std
:
:
size
(
labels
)
)
;
MOZ_ASSERT
(
depth
<
std
:
:
size
(
labels
)
)
;
for
(
uint32_t
i
=
0
;
i
<
depth
;
i
+
+
)
{
if
(
offset
+
i
>
=
end
)
{
return
i
;
}
frames
[
offset
+
i
]
=
physicalFrame
.
value
(
)
;
frames
[
offset
+
i
]
.
label
=
labels
[
i
]
;
}
return
depth
;
}
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
JS
:
:
ProfilingFrameIterator
:
:
getPhysicalFrameWithoutLabel
(
)
const
{
jit
:
:
JitcodeGlobalEntry
unused
;
return
getPhysicalFrameAndEntry
(
&
unused
)
;
}
bool
JS
:
:
ProfilingFrameIterator
:
:
isWasm
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
kind_
=
=
Kind
:
:
Wasm
;
}
bool
JS
:
:
ProfilingFrameIterator
:
:
isJSJit
(
)
const
{
return
kind_
=
=
Kind
:
:
JSJit
;
}
