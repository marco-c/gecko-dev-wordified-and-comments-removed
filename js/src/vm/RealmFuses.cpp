#
include
"
vm
/
RealmFuses
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
void
js
:
:
ArrayPrototypeIteratorFuse
:
:
popFuse
(
JSContext
*
cx
RealmFuses
&
realmFuses
)
{
RealmFuse
:
:
popFuse
(
cx
)
;
realmFuses
.
optimizeGetIteratorFuse
.
popFuse
(
cx
realmFuses
)
;
}
void
js
:
:
ArrayPrototypeIteratorNextFuse
:
:
popFuse
(
JSContext
*
cx
RealmFuses
&
realmFuses
)
{
RealmFuse
:
:
popFuse
(
cx
)
;
realmFuses
.
optimizeGetIteratorFuse
.
popFuse
(
cx
realmFuses
)
;
}
int32_t
js
:
:
RealmFuses
:
:
fuseOffsets
[
uint8_t
(
RealmFuses
:
:
FuseIndex
:
:
LastFuseIndex
)
]
=
{
#
define
FUSE
(
Name
LowerName
)
offsetof
(
RealmFuses
LowerName
)
FOR_EACH_REALM_FUSE
(
FUSE
)
#
undef
FUSE
}
;
int32_t
js
:
:
RealmFuses
:
:
offsetOfFuseWordRelativeToRealm
(
RealmFuses
:
:
FuseIndex
index
)
{
int32_t
base_offset
=
offsetof
(
Realm
realmFuses
)
;
int32_t
fuse_offset
=
RealmFuses
:
:
fuseOffsets
[
uint8_t
(
index
)
]
;
int32_t
fuseWordOffset
=
GuardFuse
:
:
fuseOffset
(
)
;
return
base_offset
+
fuse_offset
+
fuseWordOffset
;
}
const
char
*
js
:
:
RealmFuses
:
:
fuseNames
[
]
=
{
#
define
FUSE
(
Name
LowerName
)
#
LowerName
FOR_EACH_REALM_FUSE
(
FUSE
)
#
undef
FUSE
}
;
const
char
*
js
:
:
RealmFuses
:
:
getFuseName
(
RealmFuses
:
:
FuseIndex
index
)
{
uint8_t
rawIndex
=
uint8_t
(
index
)
;
MOZ_ASSERT
(
rawIndex
>
0
&
&
index
<
RealmFuses
:
:
FuseIndex
:
:
LastFuseIndex
)
;
return
fuseNames
[
rawIndex
]
;
}
bool
js
:
:
OptimizeGetIteratorFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
return
cx
-
>
realm
(
)
-
>
realmFuses
.
arrayPrototypeIteratorFuse
.
intact
(
)
&
&
cx
-
>
realm
(
)
-
>
realmFuses
.
arrayPrototypeIteratorNextFuse
.
intact
(
)
;
}
bool
js
:
:
ArrayPrototypeIteratorFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
auto
*
proto
=
cx
-
>
global
(
)
-
>
maybeGetArrayPrototype
(
)
;
if
(
!
proto
)
{
return
true
;
}
PropertyKey
iteratorKey
=
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
;
mozilla
:
:
Maybe
<
PropertyInfo
>
prop
=
proto
-
>
lookupPure
(
iteratorKey
)
;
if
(
prop
.
isNothing
(
)
|
|
!
prop
-
>
isDataProperty
(
)
)
{
return
false
;
}
auto
slot
=
prop
-
>
slot
(
)
;
const
Value
&
iterVal
=
proto
-
>
getSlot
(
slot
)
;
if
(
!
iterVal
.
isObject
(
)
|
|
!
iterVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
false
;
}
auto
*
iterFun
=
&
iterVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
return
IsSelfHostedFunctionWithName
(
iterFun
cx
-
>
names
(
)
.
dollar_ArrayValues_
)
;
}
bool
js
:
:
ArrayPrototypeIteratorNextFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
auto
*
proto
=
cx
-
>
global
(
)
-
>
maybeGetArrayIteratorPrototype
(
)
;
if
(
!
proto
)
{
return
true
;
}
mozilla
:
:
Maybe
<
PropertyInfo
>
prop
=
proto
-
>
lookupPure
(
cx
-
>
names
(
)
.
next
)
;
if
(
prop
.
isNothing
(
)
|
|
!
prop
-
>
isDataProperty
(
)
)
{
return
false
;
}
auto
slot
=
prop
-
>
slot
(
)
;
const
Value
&
nextVal
=
proto
-
>
getSlot
(
slot
)
;
if
(
!
nextVal
.
isObject
(
)
|
|
!
nextVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
false
;
}
auto
*
nextFun
=
&
nextVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
return
IsSelfHostedFunctionWithName
(
nextFun
cx
-
>
names
(
)
.
ArrayIteratorNext
)
;
}
