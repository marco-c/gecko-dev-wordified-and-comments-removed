#
include
"
vm
/
RealmFuses
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
ObjectOperations
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
void
js
:
:
InvalidatingRealmFuse
:
:
popFuse
(
JSContext
*
cx
RealmFuses
&
realmFuses
)
{
InvalidatingFuse
:
:
popFuse
(
cx
)
;
for
(
auto
&
fd
:
realmFuses
.
fuseDependencies
)
{
fd
.
invalidateForFuse
(
cx
this
)
;
}
}
bool
js
:
:
InvalidatingRealmFuse
:
:
addFuseDependency
(
JSContext
*
cx
Handle
<
JSScript
*
>
script
)
{
MOZ_ASSERT
(
script
-
>
realm
(
)
=
=
cx
-
>
realm
(
)
)
;
auto
*
dss
=
cx
-
>
realm
(
)
-
>
realmFuses
.
fuseDependencies
.
getOrCreateDependentScriptSet
(
cx
this
)
;
if
(
!
dss
)
{
return
false
;
}
return
dss
-
>
addScriptForFuse
(
this
script
)
;
}
void
js
:
:
PopsOptimizedGetIteratorFuse
:
:
popFuse
(
JSContext
*
cx
RealmFuses
&
realmFuses
)
{
RealmFuse
:
:
popFuse
(
cx
)
;
realmFuses
.
optimizeGetIteratorFuse
.
popFuse
(
cx
realmFuses
)
;
}
int32_t
js
:
:
RealmFuses
:
:
fuseOffsets
[
uint8_t
(
RealmFuses
:
:
FuseIndex
:
:
LastFuseIndex
)
]
=
{
#
define
FUSE
(
Name
LowerName
)
offsetof
(
RealmFuses
LowerName
)
FOR_EACH_REALM_FUSE
(
FUSE
)
#
undef
FUSE
}
;
int32_t
js
:
:
RealmFuses
:
:
offsetOfFuseWordRelativeToRealm
(
RealmFuses
:
:
FuseIndex
index
)
{
int32_t
base_offset
=
offsetof
(
Realm
realmFuses
)
;
int32_t
fuse_offset
=
RealmFuses
:
:
fuseOffsets
[
uint8_t
(
index
)
]
;
int32_t
fuseWordOffset
=
GuardFuse
:
:
fuseOffset
(
)
;
return
base_offset
+
fuse_offset
+
fuseWordOffset
;
}
const
char
*
js
:
:
RealmFuses
:
:
fuseNames
[
]
=
{
#
define
FUSE
(
Name
LowerName
)
#
LowerName
FOR_EACH_REALM_FUSE
(
FUSE
)
#
undef
FUSE
}
;
const
char
*
js
:
:
RealmFuses
:
:
getFuseName
(
RealmFuses
:
:
FuseIndex
index
)
{
uint8_t
rawIndex
=
uint8_t
(
index
)
;
MOZ_ASSERT
(
rawIndex
>
0
&
&
index
<
RealmFuses
:
:
FuseIndex
:
:
LastFuseIndex
)
;
return
fuseNames
[
rawIndex
]
;
}
void
js
:
:
OptimizeGetIteratorFuse
:
:
popFuse
(
JSContext
*
cx
RealmFuses
&
realmFuses
)
{
InvalidatingRealmFuse
:
:
popFuse
(
cx
realmFuses
)
;
MOZ_ASSERT
(
cx
-
>
global
(
)
)
;
cx
-
>
runtime
(
)
-
>
setUseCounter
(
cx
-
>
global
(
)
JSUseCounter
:
:
OPTIMIZE_GET_ITERATOR_FUSE
)
;
}
bool
js
:
:
OptimizeGetIteratorFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
auto
&
realmFuses
=
cx
-
>
realm
(
)
-
>
realmFuses
;
return
realmFuses
.
arrayPrototypeIteratorFuse
.
intact
(
)
&
&
realmFuses
.
arrayPrototypeIteratorNextFuse
.
intact
(
)
&
&
realmFuses
.
arrayIteratorPrototypeHasNoReturnProperty
.
intact
(
)
&
&
realmFuses
.
iteratorPrototypeHasNoReturnProperty
.
intact
(
)
&
&
realmFuses
.
arrayIteratorPrototypeHasIteratorProto
.
intact
(
)
&
&
realmFuses
.
iteratorPrototypeHasObjectProto
.
intact
(
)
&
&
realmFuses
.
objectPrototypeHasNoReturnProperty
.
intact
(
)
;
}
bool
js
:
:
ArrayPrototypeIteratorFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
auto
*
proto
=
cx
-
>
global
(
)
-
>
maybeGetArrayPrototype
(
)
;
if
(
!
proto
)
{
return
true
;
}
PropertyKey
iteratorKey
=
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
;
mozilla
:
:
Maybe
<
PropertyInfo
>
prop
=
proto
-
>
lookupPure
(
iteratorKey
)
;
if
(
prop
.
isNothing
(
)
|
|
!
prop
-
>
isDataProperty
(
)
)
{
return
false
;
}
auto
slot
=
prop
-
>
slot
(
)
;
const
Value
&
iterVal
=
proto
-
>
getSlot
(
slot
)
;
if
(
!
iterVal
.
isObject
(
)
|
|
!
iterVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
false
;
}
auto
*
iterFun
=
&
iterVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
return
IsSelfHostedFunctionWithName
(
iterFun
cx
-
>
names
(
)
.
dollar_ArrayValues_
)
;
}
bool
js
:
:
ArrayPrototypeIteratorNextFuse
:
:
checkInvariant
(
JSContext
*
cx
)
{
auto
*
proto
=
cx
-
>
global
(
)
-
>
maybeGetArrayIteratorPrototype
(
)
;
if
(
!
proto
)
{
return
true
;
}
mozilla
:
:
Maybe
<
PropertyInfo
>
prop
=
proto
-
>
lookupPure
(
cx
-
>
names
(
)
.
next
)
;
if
(
prop
.
isNothing
(
)
|
|
!
prop
-
>
isDataProperty
(
)
)
{
return
false
;
}
auto
slot
=
prop
-
>
slot
(
)
;
const
Value
&
nextVal
=
proto
-
>
getSlot
(
slot
)
;
if
(
!
nextVal
.
isObject
(
)
|
|
!
nextVal
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
false
;
}
auto
*
nextFun
=
&
nextVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
return
IsSelfHostedFunctionWithName
(
nextFun
cx
-
>
names
(
)
.
ArrayIteratorNext
)
;
}
static
bool
HasNoReturnName
(
JSContext
*
cx
JS
:
:
HandleObject
proto
)
{
if
(
!
proto
)
{
return
true
;
}
JS
:
:
RootedId
returnName
(
cx
NameToId
(
cx
-
>
names
(
)
.
return_
)
)
;
bool
found
=
true
;
if
(
!
HasOwnProperty
(
cx
proto
returnName
&
found
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
true
;
}
return
!
found
;
}
bool
js
:
:
ArrayIteratorPrototypeHasNoReturnProperty
:
:
checkInvariant
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
cx
-
>
global
(
)
-
>
maybeGetArrayIteratorPrototype
(
)
)
;
if
(
!
proto
)
{
return
true
;
}
return
HasNoReturnName
(
cx
proto
)
;
}
bool
js
:
:
IteratorPrototypeHasNoReturnProperty
:
:
checkInvariant
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
cx
-
>
global
(
)
-
>
maybeGetIteratorPrototype
(
)
)
;
if
(
!
proto
)
{
return
true
;
}
return
HasNoReturnName
(
cx
proto
)
;
}
bool
js
:
:
ArrayIteratorPrototypeHasIteratorProto
:
:
checkInvariant
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
cx
-
>
global
(
)
-
>
maybeGetArrayIteratorPrototype
(
)
)
;
if
(
!
proto
)
{
return
true
;
}
RootedObject
iterProto
(
cx
cx
-
>
global
(
)
-
>
maybeGetIteratorPrototype
(
)
)
;
if
(
!
iterProto
)
{
MOZ_CRASH
(
"
Can
we
have
the
array
iter
proto
without
the
iterator
proto
?
"
)
;
return
true
;
}
return
proto
-
>
staticPrototype
(
)
=
=
iterProto
;
}
bool
js
:
:
IteratorPrototypeHasObjectProto
:
:
checkInvariant
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
cx
-
>
global
(
)
-
>
maybeGetIteratorPrototype
(
)
)
;
if
(
!
proto
)
{
return
true
;
}
return
proto
-
>
staticPrototype
(
)
=
=
&
cx
-
>
global
(
)
-
>
getObjectPrototype
(
)
;
}
bool
js
:
:
ObjectPrototypeHasNoReturnProperty
:
:
checkInvariant
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getObjectPrototype
(
)
)
;
return
HasNoReturnName
(
cx
proto
)
;
}
