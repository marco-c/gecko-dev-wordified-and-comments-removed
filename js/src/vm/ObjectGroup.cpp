#
include
"
vm
/
ObjectGroup
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
builtin
/
DataViewObject
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
ObjectKind
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
TypeInference
-
inl
.
h
"
using
namespace
js
;
ObjectGroup
:
:
ObjectGroup
(
const
JSClass
*
clasp
TaggedProto
proto
JS
:
:
Realm
*
realm
ObjectGroupFlags
initialFlags
)
:
TenuredCellWithNonGCPointer
(
clasp
)
proto_
(
proto
)
realm_
(
realm
)
flags_
(
initialFlags
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
MOZ_ASSERT
(
JS
:
:
StringIsASCII
(
clasp
-
>
name
)
)
;
#
ifdef
DEBUG
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
)
{
AssertTargetIsNotGray
(
global
)
;
}
#
endif
setGeneration
(
zone
(
)
-
>
types
.
generation
)
;
}
void
ObjectGroup
:
:
setProtoUnchecked
(
TaggedProto
proto
)
{
proto_
=
proto
;
MOZ_ASSERT_IF
(
proto_
.
isObject
(
)
&
&
proto_
.
toObject
(
)
-
>
isNative
(
)
proto_
.
toObject
(
)
-
>
isDelegate
(
)
)
;
}
void
ObjectGroup
:
:
setProto
(
TaggedProto
proto
)
{
MOZ_ASSERT
(
singleton
(
)
)
;
setProtoUnchecked
(
proto
)
;
}
void
ObjectGroup
:
:
setAddendum
(
AddendumKind
kind
void
*
addendum
bool
isSweeping
)
{
MOZ_ASSERT
(
!
needsSweep
(
)
)
;
MOZ_ASSERT
(
unsigned
(
kind
)
<
=
(
OBJECT_FLAG_ADDENDUM_MASK
>
>
OBJECT_FLAG_ADDENDUM_SHIFT
)
)
;
MOZ_ASSERT_IF
(
addendumKind
(
)
!
=
Addendum_None
addendumKind
(
)
=
=
kind
)
;
flags_
&
=
~
OBJECT_FLAG_ADDENDUM_MASK
;
flags_
|
=
kind
<
<
OBJECT_FLAG_ADDENDUM_SHIFT
;
addendum_
=
addendum
;
}
bool
ObjectGroup
:
:
useSingletonForClone
(
JSFunction
*
fun
)
{
MOZ_RELEASE_ASSERT
(
!
IsTypeInferenceEnabled
(
)
)
;
return
false
;
}
bool
ObjectGroup
:
:
useSingletonForNewObject
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
{
if
(
!
IsTypeInferenceEnabled
(
)
)
{
return
false
;
}
if
(
script
-
>
isGenerator
(
)
|
|
script
-
>
isAsync
(
)
)
{
return
false
;
}
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
New
)
{
return
false
;
}
pc
+
=
JSOpLength_New
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
SetProp
)
{
return
false
;
}
return
script
-
>
getName
(
pc
)
=
=
cx
-
>
names
(
)
.
prototype
;
}
bool
ObjectGroup
:
:
useSingletonForAllocationSite
(
JSScript
*
script
jsbytecode
*
pc
JSProtoKey
key
)
{
if
(
!
IsTypeInferenceEnabled
(
)
)
{
return
false
;
}
if
(
script
-
>
function
(
)
)
{
return
false
;
}
if
(
key
!
=
JSProto_Object
)
{
return
false
;
}
uint32_t
offset
=
script
-
>
pcToOffset
(
pc
)
;
for
(
const
TryNote
&
tn
:
script
-
>
trynotes
(
)
)
{
if
(
tn
.
kind
(
)
!
=
TryNoteKind
:
:
ForIn
&
&
tn
.
kind
(
)
!
=
TryNoteKind
:
:
ForOf
&
&
tn
.
kind
(
)
!
=
TryNoteKind
:
:
Loop
)
{
continue
;
}
if
(
tn
.
start
<
=
offset
&
&
offset
<
tn
.
start
+
tn
.
length
)
{
return
false
;
}
}
return
true
;
}
bool
GlobalObject
:
:
shouldSplicePrototype
(
)
{
return
staticPrototype
(
)
=
=
nullptr
;
}
bool
JSObject
:
:
splicePrototype
(
JSContext
*
cx
HandleObject
obj
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isSingleton
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
#
ifdef
DEBUG
const
JSClass
*
oldClass
=
obj
-
>
getClass
(
)
;
#
endif
if
(
proto
.
isObject
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
false
;
}
}
RootedObjectGroup
group
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
group
)
{
return
false
;
}
RootedObjectGroup
protoGroup
(
cx
nullptr
)
;
if
(
proto
.
isObject
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
protoGroup
=
JSObject
:
:
getGroup
(
cx
protoObj
)
;
if
(
!
protoGroup
)
{
return
false
;
}
}
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
oldClass
"
splicing
a
prototype
doesn
'
t
change
a
group
'
s
class
"
)
;
group
-
>
setProto
(
proto
)
;
return
true
;
}
ObjectGroup
*
JSObject
:
:
makeLazyGroup
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
obj
-
>
hasLazyGroup
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
ObjectGroupFlags
initialFlags
=
OBJECT_FLAG_SINGLETON
|
OBJECT_FLAG_NON_PACKED
;
if
(
obj
-
>
isIteratedSingleton
(
)
)
{
initialFlags
|
=
OBJECT_FLAG_ITERATED
;
}
if
(
obj
-
>
isNative
(
)
&
&
obj
-
>
as
<
NativeObject
>
(
)
.
isIndexed
(
)
)
{
initialFlags
|
=
OBJECT_FLAG_SPARSE_INDEXES
;
}
if
(
obj
-
>
is
<
ArrayObject
>
(
)
&
&
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
{
initialFlags
|
=
OBJECT_FLAG_LENGTH_OVERFLOW
;
}
Rooted
<
TaggedProto
>
proto
(
cx
obj
-
>
taggedProto
(
)
)
;
ObjectGroup
*
group
=
ObjectGroupRealm
:
:
makeGroup
(
cx
obj
-
>
nonCCWRealm
(
)
obj
-
>
getClass
(
)
proto
initialFlags
)
;
if
(
!
group
)
{
return
nullptr
;
}
AutoEnterAnalysis
enter
(
cx
)
;
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
as
<
JSFunction
>
(
)
.
isInterpreted
(
)
)
{
group
-
>
setInterpretedFunction
(
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
}
obj
-
>
setGroupRaw
(
group
)
;
return
group
;
}
bool
JSObject
:
:
setNewGroupUnknown
(
JSContext
*
cx
ObjectGroupRealm
&
realm
const
JSClass
*
clasp
JS
:
:
HandleObject
obj
)
{
ObjectGroup
:
:
setDefaultNewGroupUnknown
(
cx
realm
clasp
obj
)
;
return
JSObject
:
:
setFlags
(
cx
obj
BaseShape
:
:
NEW_GROUP_UNKNOWN
)
;
}
struct
ObjectGroupRealm
:
:
NewEntry
{
WeakHeapPtrObjectGroup
group
;
JSObject
*
associated
;
NewEntry
(
ObjectGroup
*
group
JSObject
*
associated
)
:
group
(
group
)
associated
(
associated
)
{
}
struct
Lookup
{
const
JSClass
*
clasp
;
TaggedProto
proto
;
JSObject
*
associated
;
Lookup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
:
clasp
(
clasp
)
proto
(
proto
)
associated
(
associated
)
{
MOZ_ASSERT
(
clasp
)
;
MOZ_ASSERT_IF
(
associated
&
&
associated
-
>
is
<
JSFunction
>
(
)
clasp
=
=
&
PlainObject
:
:
class_
)
;
}
explicit
Lookup
(
const
NewEntry
&
entry
)
:
clasp
(
entry
.
group
.
unbarrieredGet
(
)
-
>
clasp
(
)
)
proto
(
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
)
associated
(
entry
.
associated
)
{
MOZ_ASSERT_IF
(
associated
&
&
associated
-
>
is
<
JSFunction
>
(
)
clasp
=
=
&
PlainObject
:
:
class_
)
;
}
}
;
bool
needsSweep
(
)
{
return
IsAboutToBeFinalized
(
&
group
)
|
|
(
associated
&
&
IsAboutToBeFinalizedUnbarriered
(
&
associated
)
)
;
}
bool
operator
=
=
(
const
NewEntry
&
other
)
const
{
return
group
=
=
other
.
group
&
&
associated
=
=
other
.
associated
;
}
}
;
namespace
js
{
template
<
>
struct
MovableCellHasher
<
ObjectGroupRealm
:
:
NewEntry
>
{
using
Key
=
ObjectGroupRealm
:
:
NewEntry
;
using
Lookup
=
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
hasHash
(
l
.
proto
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
hasHash
(
l
.
associated
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
ensureHash
(
l
.
proto
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
ensureHash
(
l
.
associated
)
;
}
static
inline
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
MovableCellHasher
<
JSObject
*
>
:
:
hash
(
lookup
.
associated
)
)
;
return
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashGeneric
(
lookup
.
clasp
)
)
;
}
static
inline
bool
match
(
const
ObjectGroupRealm
:
:
NewEntry
&
key
const
Lookup
&
lookup
)
{
if
(
key
.
group
.
unbarrieredGet
(
)
-
>
clasp
(
)
!
=
lookup
.
clasp
)
{
return
false
;
}
TaggedProto
proto
=
key
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
if
(
!
MovableCellHasher
<
TaggedProto
>
:
:
match
(
proto
lookup
.
proto
)
)
{
return
false
;
}
return
MovableCellHasher
<
JSObject
*
>
:
:
match
(
key
.
associated
lookup
.
associated
)
;
}
}
;
}
class
ObjectGroupRealm
:
:
NewTable
:
public
JS
:
:
WeakCache
<
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
>
{
using
Table
=
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
;
using
Base
=
JS
:
:
WeakCache
<
Table
>
;
public
:
explicit
NewTable
(
Zone
*
zone
)
:
Base
(
zone
)
{
}
}
;
ObjectGroupRealm
&
ObjectGroupRealm
:
:
get
(
const
ObjectGroup
*
group
)
{
return
group
-
>
realm
(
)
-
>
objectGroups_
;
}
ObjectGroupRealm
&
ObjectGroupRealm
:
:
getForNewObject
(
JSContext
*
cx
)
{
return
cx
-
>
realm
(
)
-
>
objectGroups_
;
}
MOZ_ALWAYS_INLINE
ObjectGroup
*
ObjectGroupRealm
:
:
DefaultNewGroupCache
:
:
lookup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
{
if
(
group_
&
&
associated_
=
=
associated
&
&
group_
-
>
proto
(
)
=
=
proto
&
&
group_
-
>
clasp
(
)
=
=
clasp
)
{
return
group_
;
}
return
nullptr
;
}
ObjectGroup
*
ObjectGroup
:
:
defaultNewGroup
(
JSContext
*
cx
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
{
MOZ_ASSERT
(
clasp
)
;
MOZ_ASSERT_IF
(
associated
proto
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
associated
&
&
!
associated
-
>
is
<
TypeDescr
>
(
)
)
{
associated
=
nullptr
;
}
if
(
associated
)
{
MOZ_ASSERT
(
associated
-
>
is
<
TypeDescr
>
(
)
)
;
if
(
!
IsTypedObjectClass
(
clasp
)
)
{
associated
=
nullptr
;
}
}
ObjectGroupRealm
&
groups
=
ObjectGroupRealm
:
:
getForNewObject
(
cx
)
;
if
(
ObjectGroup
*
group
=
groups
.
defaultNewGroupCache
.
lookup
(
clasp
proto
associated
)
)
{
return
group
;
}
AutoEnterAnalysis
enter
(
cx
)
;
ObjectGroupRealm
:
:
NewTable
*
&
table
=
groups
.
defaultNewTable
;
if
(
!
table
)
{
table
=
cx
-
>
new_
<
ObjectGroupRealm
:
:
NewTable
>
(
cx
-
>
zone
(
)
)
;
if
(
!
table
)
{
return
nullptr
;
}
}
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isDelegate
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
nullptr
;
}
if
(
protoObj
-
>
is
<
PlainObject
>
(
)
&
&
!
protoObj
-
>
isSingleton
(
)
&
&
IsTypeInferenceEnabled
(
)
)
{
if
(
!
JSObject
:
:
changeToSingleton
(
cx
protoObj
)
)
{
return
nullptr
;
}
if
(
protoObj
-
>
hasUncacheableProto
(
)
)
{
HandleNativeObject
nobj
=
protoObj
.
as
<
NativeObject
>
(
)
;
if
(
!
NativeObject
:
:
clearFlag
(
cx
nobj
BaseShape
:
:
UNCACHEABLE_PROTO
)
)
{
return
nullptr
;
}
}
}
}
ObjectGroupRealm
:
:
NewTable
:
:
AddPtr
p
=
table
-
>
lookupForAdd
(
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
(
clasp
proto
associated
)
)
;
if
(
p
)
{
ObjectGroup
*
group
=
p
-
>
group
;
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
clasp
)
;
MOZ_ASSERT
(
group
-
>
proto
(
)
=
=
proto
)
;
groups
.
defaultNewGroupCache
.
put
(
group
associated
)
;
return
group
;
}
ObjectGroupFlags
initialFlags
=
0
;
if
(
proto
.
isDynamic
(
)
|
|
(
proto
.
isObject
(
)
&
&
proto
.
toObject
(
)
-
>
isNewGroupUnknown
(
)
)
)
{
initialFlags
=
OBJECT_FLAG_DYNAMIC_MASK
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
ObjectGroup
*
group
=
ObjectGroupRealm
:
:
makeGroup
(
cx
cx
-
>
realm
(
)
clasp
protoRoot
initialFlags
)
;
if
(
!
group
)
{
return
nullptr
;
}
if
(
!
table
-
>
add
(
p
ObjectGroupRealm
:
:
NewEntry
(
group
associated
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
if
(
associated
)
{
group
-
>
setTypeDescr
(
&
associated
-
>
as
<
TypeDescr
>
(
)
)
;
}
groups
.
defaultNewGroupCache
.
put
(
group
associated
)
;
return
group
;
}
ObjectGroup
*
ObjectGroup
:
:
lazySingletonGroup
(
JSContext
*
cx
ObjectGroupRealm
&
realm
JS
:
:
Realm
*
objectRealm
const
JSClass
*
clasp
TaggedProto
proto
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
compartment
(
)
=
=
proto
.
toObject
(
)
-
>
compartment
(
)
)
;
ObjectGroupRealm
:
:
NewTable
*
&
table
=
realm
.
lazyTable
;
if
(
!
table
)
{
table
=
cx
-
>
new_
<
ObjectGroupRealm
:
:
NewTable
>
(
cx
-
>
zone
(
)
)
;
if
(
!
table
)
{
return
nullptr
;
}
}
ObjectGroupRealm
:
:
NewTable
:
:
AddPtr
p
=
table
-
>
lookupForAdd
(
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
(
clasp
proto
nullptr
)
)
;
if
(
p
)
{
ObjectGroup
*
group
=
p
-
>
group
;
MOZ_ASSERT
(
group
-
>
lazy
(
)
)
;
return
group
;
}
AutoEnterAnalysis
enter
(
cx
)
;
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
ObjectGroup
*
group
=
ObjectGroupRealm
:
:
makeGroup
(
cx
objectRealm
clasp
protoRoot
OBJECT_FLAG_SINGLETON
|
OBJECT_FLAG_LAZY_SINGLETON
)
;
if
(
!
group
)
{
return
nullptr
;
}
if
(
!
table
-
>
add
(
p
ObjectGroupRealm
:
:
NewEntry
(
group
nullptr
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
group
;
}
void
ObjectGroup
:
:
setDefaultNewGroupUnknown
(
JSContext
*
cx
ObjectGroupRealm
&
realm
const
JSClass
*
clasp
HandleObject
obj
)
{
ObjectGroupRealm
:
:
NewTable
*
table
=
realm
.
defaultNewTable
;
if
(
table
)
{
Rooted
<
TaggedProto
>
taggedProto
(
cx
TaggedProto
(
obj
)
)
;
auto
lookup
=
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
(
clasp
taggedProto
nullptr
)
;
auto
p
=
table
-
>
lookup
(
lookup
)
;
if
(
p
)
{
MarkObjectGroupUnknownProperties
(
cx
p
-
>
group
)
;
}
}
}
inline
const
JSClass
*
GetClassForProtoKey
(
JSProtoKey
key
)
{
switch
(
key
)
{
case
JSProto_Null
:
case
JSProto_Object
:
return
&
PlainObject
:
:
class_
;
case
JSProto_Array
:
return
&
ArrayObject
:
:
class_
;
case
JSProto_Int8Array
:
case
JSProto_Uint8Array
:
case
JSProto_Int16Array
:
case
JSProto_Uint16Array
:
case
JSProto_Int32Array
:
case
JSProto_Uint32Array
:
case
JSProto_Float32Array
:
case
JSProto_Float64Array
:
case
JSProto_Uint8ClampedArray
:
case
JSProto_BigInt64Array
:
case
JSProto_BigUint64Array
:
return
&
TypedArrayObject
:
:
classes
[
key
-
JSProto_Int8Array
]
;
default
:
MOZ_CRASH
(
"
Bad
proto
key
"
)
;
}
}
ObjectGroup
*
ObjectGroup
:
:
defaultNewGroup
(
JSContext
*
cx
JSProtoKey
key
)
{
JSObject
*
proto
=
nullptr
;
if
(
key
!
=
JSProto_Null
)
{
proto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
key
)
;
if
(
!
proto
)
{
return
nullptr
;
}
}
return
defaultNewGroup
(
cx
GetClassForProtoKey
(
key
)
TaggedProto
(
proto
)
)
;
}
ArrayObject
*
ObjectGroup
:
:
newArrayObject
(
JSContext
*
cx
const
Value
*
vp
size_t
length
NewObjectKind
newKind
NewArrayKind
arrayKind
)
{
MOZ_ASSERT
(
newKind
!
=
SingletonObject
)
;
if
(
arrayKind
=
=
NewArrayKind
:
:
CopyOnWrite
)
{
ArrayObject
*
obj
=
NewDenseCopiedArray
(
cx
length
vp
nullptr
newKind
)
;
if
(
!
obj
|
|
!
ObjectElements
:
:
MakeElementsCopyOnWrite
(
cx
obj
)
)
{
return
nullptr
;
}
return
obj
;
}
if
(
!
IsTypeInferenceEnabled
(
)
)
{
return
NewDenseCopiedArray
(
cx
length
vp
nullptr
newKind
)
;
}
MOZ_CRASH
(
"
TODO
(
no
-
TI
)
:
remove
"
)
;
}
static
bool
AddPlainObjectProperties
(
JSContext
*
cx
HandlePlainObject
obj
IdValuePair
*
properties
size_t
nproperties
)
{
RootedId
propid
(
cx
)
;
RootedValue
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
nproperties
;
i
+
+
)
{
propid
=
properties
[
i
]
.
id
;
value
=
properties
[
i
]
.
value
;
if
(
!
NativeDefineDataProperty
(
cx
obj
propid
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
return
true
;
}
PlainObject
*
js
:
:
NewPlainObjectWithProperties
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
{
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
nproperties
)
;
RootedPlainObject
obj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
allocKind
newKind
)
)
;
if
(
!
obj
|
|
!
AddPlainObjectProperties
(
cx
obj
properties
nproperties
)
)
{
return
nullptr
;
}
return
obj
;
}
JSObject
*
ObjectGroup
:
:
newPlainObject
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
{
if
(
!
IsTypeInferenceEnabled
(
)
|
|
newKind
=
=
SingletonObject
|
|
nproperties
=
=
0
|
|
nproperties
>
=
PropertyTree
:
:
MAX_HEIGHT
)
{
return
NewPlainObjectWithProperties
(
cx
properties
nproperties
newKind
)
;
}
MOZ_CRASH
(
"
TODO
(
no
-
TI
)
:
remove
"
)
;
}
struct
ObjectGroupRealm
:
:
AllocationSiteKey
{
WeakHeapPtrScript
script
;
uint32_t
offset
:
24
;
JSProtoKey
kind
:
8
;
WeakHeapPtrObject
proto
;
static
const
uint32_t
OFFSET_LIMIT
=
(
1
<
<
23
)
;
AllocationSiteKey
(
JSScript
*
script_
uint32_t
offset_
JSProtoKey
kind_
JSObject
*
proto_
)
:
script
(
script_
)
offset
(
offset_
)
kind
(
kind_
)
proto
(
proto_
)
{
MOZ_ASSERT
(
offset_
<
OFFSET_LIMIT
)
;
}
AllocationSiteKey
(
const
AllocationSiteKey
&
key
)
=
default
;
AllocationSiteKey
(
AllocationSiteKey
&
&
key
)
:
script
(
std
:
:
move
(
key
.
script
)
)
offset
(
key
.
offset
)
kind
(
key
.
kind
)
proto
(
std
:
:
move
(
key
.
proto
)
)
{
}
void
operator
=
(
AllocationSiteKey
&
&
key
)
{
script
=
std
:
:
move
(
key
.
script
)
;
offset
=
key
.
offset
;
kind
=
key
.
kind
;
proto
=
std
:
:
move
(
key
.
proto
)
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
script
"
AllocationSiteKey
script
"
)
;
TraceNullableRoot
(
trc
&
proto
"
AllocationSiteKey
proto
"
)
;
}
bool
needsSweep
(
)
{
return
IsAboutToBeFinalizedUnbarriered
(
script
.
unbarrieredAddress
(
)
)
|
|
(
proto
&
&
IsAboutToBeFinalizedUnbarriered
(
proto
.
unbarrieredAddress
(
)
)
)
;
}
bool
operator
=
=
(
const
AllocationSiteKey
&
other
)
const
{
return
script
=
=
other
.
script
&
&
offset
=
=
other
.
offset
&
&
kind
=
=
other
.
kind
&
&
proto
=
=
other
.
proto
;
}
}
;
namespace
js
{
template
<
>
struct
MovableCellHasher
<
ObjectGroupRealm
:
:
AllocationSiteKey
>
{
using
Key
=
ObjectGroupRealm
:
:
AllocationSiteKey
;
using
Lookup
=
ObjectGroupRealm
:
:
AllocationSiteKey
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
JSScript
*
>
:
:
hasHash
(
l
.
script
.
unbarrieredGet
(
)
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
hasHash
(
l
.
proto
.
unbarrieredGet
(
)
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
JSScript
*
>
:
:
ensureHash
(
l
.
script
.
unbarrieredGet
(
)
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
ensureHash
(
l
.
proto
.
unbarrieredGet
(
)
)
;
}
static
inline
HashNumber
hash
(
const
Key
&
key
)
{
HashNumber
hash
=
mozilla
:
:
HashGeneric
(
key
.
offset
key
.
kind
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
MovableCellHasher
<
JSScript
*
>
:
:
hash
(
key
.
script
.
unbarrieredGet
(
)
)
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
MovableCellHasher
<
JSObject
*
>
:
:
hash
(
key
.
proto
.
unbarrieredGet
(
)
)
)
;
return
hash
;
}
static
inline
bool
match
(
const
Key
&
a
const
Lookup
&
b
)
{
return
a
.
offset
=
=
b
.
offset
&
&
a
.
kind
=
=
b
.
kind
&
&
MovableCellHasher
<
JSScript
*
>
:
:
match
(
a
.
script
.
unbarrieredGet
(
)
b
.
script
.
unbarrieredGet
(
)
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
match
(
a
.
proto
.
unbarrieredGet
(
)
b
.
proto
.
unbarrieredGet
(
)
)
;
}
}
;
}
class
ObjectGroupRealm
:
:
AllocationSiteTable
:
public
JS
:
:
WeakCache
<
js
:
:
GCHashMap
<
AllocationSiteKey
WeakHeapPtrObjectGroup
MovableCellHasher
<
AllocationSiteKey
>
SystemAllocPolicy
>
>
{
using
Table
=
js
:
:
GCHashMap
<
AllocationSiteKey
WeakHeapPtrObjectGroup
MovableCellHasher
<
AllocationSiteKey
>
SystemAllocPolicy
>
;
using
Base
=
JS
:
:
WeakCache
<
Table
>
;
public
:
explicit
AllocationSiteTable
(
Zone
*
zone
)
:
Base
(
zone
)
{
}
}
;
ObjectGroup
*
ObjectGroup
:
:
allocationSiteGroup
(
JSContext
*
cx
JSScript
*
scriptArg
jsbytecode
*
pc
JSProtoKey
kind
HandleObject
protoArg
)
{
MOZ_ASSERT
(
!
useSingletonForAllocationSite
(
scriptArg
pc
kind
)
)
;
MOZ_ASSERT_IF
(
protoArg
kind
=
=
JSProto_Array
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
scriptArg
-
>
realm
(
)
)
;
uint32_t
offset
=
scriptArg
-
>
pcToOffset
(
pc
)
;
if
(
!
IsTypeInferenceEnabled
(
)
|
|
offset
>
=
ObjectGroupRealm
:
:
AllocationSiteKey
:
:
OFFSET_LIMIT
)
{
if
(
protoArg
)
{
return
defaultNewGroup
(
cx
GetClassForProtoKey
(
kind
)
TaggedProto
(
protoArg
)
)
;
}
return
defaultNewGroup
(
cx
kind
)
;
}
MOZ_CRASH
(
"
TODO
(
no
-
TI
)
:
remove
"
)
;
}
ObjectGroup
*
ObjectGroup
:
:
callingAllocationSiteGroup
(
JSContext
*
cx
JSProtoKey
key
HandleObject
proto
)
{
MOZ_ASSERT_IF
(
proto
key
=
=
JSProto_Array
)
;
if
(
IsTypeInferenceEnabled
(
)
)
{
jsbytecode
*
pc
;
RootedScript
script
(
cx
cx
-
>
currentScript
(
&
pc
)
)
;
if
(
script
)
{
return
allocationSiteGroup
(
cx
script
pc
key
proto
)
;
}
}
if
(
proto
)
{
return
defaultNewGroup
(
cx
GetClassForProtoKey
(
key
)
TaggedProto
(
proto
)
)
;
}
return
defaultNewGroup
(
cx
key
)
;
}
bool
ObjectGroup
:
:
setAllocationSiteObjectGroup
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
HandleObject
obj
bool
singleton
)
{
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
JSProtoKey
key
=
JSCLASS_CACHED_PROTO_KEY
(
obj
-
>
getClass
(
)
)
;
MOZ_ASSERT
(
key
!
=
JSProto_Null
)
;
MOZ_ASSERT
(
singleton
=
=
useSingletonForAllocationSite
(
script
pc
key
)
)
;
if
(
singleton
)
{
MOZ_ASSERT
(
obj
-
>
isSingleton
(
)
)
;
}
else
{
ObjectGroup
*
group
=
allocationSiteGroup
(
cx
script
pc
key
)
;
if
(
!
group
)
{
return
false
;
}
obj
-
>
setGroup
(
group
)
;
}
return
true
;
}
ArrayObject
*
ObjectGroup
:
:
getOrFixupCopyOnWriteObject
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
RootedArrayObject
obj
(
cx
&
script
-
>
getObject
(
pc
)
-
>
as
<
ArrayObject
>
(
)
)
;
MOZ_ASSERT
(
obj
-
>
denseElementsAreCopyOnWrite
(
)
)
;
{
AutoSweepObjectGroup
sweepObjGroup
(
obj
-
>
group
(
)
)
;
if
(
obj
-
>
group
(
)
-
>
fromAllocationSite
(
sweepObjGroup
)
)
{
MOZ_ASSERT
(
obj
-
>
group
(
)
-
>
hasAnyFlags
(
sweepObjGroup
OBJECT_FLAG_COPY_ON_WRITE
)
)
;
return
obj
;
}
}
RootedObjectGroup
group
(
cx
allocationSiteGroup
(
cx
script
pc
JSProto_Array
)
)
;
if
(
!
group
)
{
return
nullptr
;
}
AutoSweepObjectGroup
sweepGroup
(
group
)
;
group
-
>
addFlags
(
sweepGroup
OBJECT_FLAG_COPY_ON_WRITE
)
;
MOZ_ASSERT
(
obj
-
>
slotSpan
(
)
=
=
0
)
;
if
(
IsTypeInferenceEnabled
(
)
)
{
for
(
size_t
i
=
0
;
i
<
obj
-
>
getDenseInitializedLength
(
)
;
i
+
+
)
{
const
Value
&
v
=
obj
-
>
getDenseElement
(
i
)
;
AddTypePropertyId
(
cx
group
nullptr
JSID_VOID
v
)
;
}
}
obj
-
>
setGroup
(
group
)
;
return
obj
;
}
ArrayObject
*
ObjectGroup
:
:
getCopyOnWriteObject
(
JSScript
*
script
jsbytecode
*
pc
)
{
ArrayObject
*
obj
=
&
script
-
>
getObject
(
pc
)
-
>
as
<
ArrayObject
>
(
)
;
MOZ_ASSERT
(
obj
-
>
denseElementsAreCopyOnWrite
(
)
)
;
return
obj
;
}
bool
ObjectGroup
:
:
findAllocationSite
(
JSContext
*
cx
const
ObjectGroup
*
group
JSScript
*
*
script
uint32_t
*
offset
)
{
*
script
=
nullptr
;
*
offset
=
0
;
ObjectGroupRealm
&
realm
=
ObjectGroupRealm
:
:
get
(
group
)
;
const
ObjectGroupRealm
:
:
AllocationSiteTable
*
table
=
realm
.
allocationSiteTable
;
if
(
!
table
)
{
return
false
;
}
for
(
ObjectGroupRealm
:
:
AllocationSiteTable
:
:
Range
r
=
table
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
if
(
group
=
=
r
.
front
(
)
.
value
(
)
)
{
*
script
=
r
.
front
(
)
.
key
(
)
.
script
;
*
offset
=
r
.
front
(
)
.
key
(
)
.
offset
;
return
true
;
}
}
return
false
;
}
ObjectGroupRealm
:
:
~
ObjectGroupRealm
(
)
{
js_delete
(
defaultNewTable
)
;
js_delete
(
lazyTable
)
;
js_delete
(
allocationSiteTable
)
;
stringSplitStringGroup
=
nullptr
;
}
void
ObjectGroupRealm
:
:
removeDefaultNewGroup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
{
auto
p
=
defaultNewTable
-
>
lookup
(
NewEntry
:
:
Lookup
(
clasp
proto
associated
)
)
;
MOZ_RELEASE_ASSERT
(
p
)
;
defaultNewTable
-
>
remove
(
p
)
;
defaultNewGroupCache
.
purge
(
)
;
}
void
ObjectGroupRealm
:
:
replaceDefaultNewGroup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
ObjectGroup
*
group
)
{
NewEntry
:
:
Lookup
lookup
(
clasp
proto
associated
)
;
auto
p
=
defaultNewTable
-
>
lookup
(
lookup
)
;
MOZ_RELEASE_ASSERT
(
p
)
;
defaultNewTable
-
>
remove
(
p
)
;
defaultNewGroupCache
.
purge
(
)
;
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
defaultNewTable
-
>
putNew
(
lookup
NewEntry
(
group
associated
)
)
)
{
oomUnsafe
.
crash
(
"
Inconsistent
object
table
"
)
;
}
}
}
ObjectGroup
*
ObjectGroupRealm
:
:
makeGroup
(
JSContext
*
cx
Realm
*
realm
const
JSClass
*
clasp
Handle
<
TaggedProto
>
proto
ObjectGroupFlags
initialFlags
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
!
IsTypeInferenceEnabled
(
)
)
{
initialFlags
|
=
OBJECT_FLAG_DYNAMIC_MASK
;
}
ObjectGroup
*
group
=
Allocate
<
ObjectGroup
>
(
cx
)
;
if
(
!
group
)
{
return
nullptr
;
}
new
(
group
)
ObjectGroup
(
clasp
proto
realm
initialFlags
)
;
return
group
;
}
ObjectGroup
*
ObjectGroupRealm
:
:
getStringSplitStringGroup
(
JSContext
*
cx
)
{
ObjectGroupRealm
&
groups
=
ObjectGroupRealm
:
:
getForNewObject
(
cx
)
;
ObjectGroup
*
group
=
groups
.
stringSplitStringGroup
.
get
(
)
;
if
(
group
)
{
return
group
;
}
JSObject
*
proto
=
GlobalObject
:
:
getOrCreateArrayPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Rooted
<
TaggedProto
>
tagged
(
cx
TaggedProto
(
proto
)
)
;
group
=
makeGroup
(
cx
cx
-
>
realm
(
)
&
ArrayObject
:
:
class_
tagged
)
;
if
(
!
group
)
{
return
nullptr
;
}
groups
.
stringSplitStringGroup
.
set
(
group
)
;
return
group
;
}
void
ObjectGroupRealm
:
:
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
allocationSiteTables
size_t
*
arrayObjectGroupTables
size_t
*
plainObjectGroupTables
size_t
*
realmTables
)
{
if
(
allocationSiteTable
)
{
*
allocationSiteTables
+
=
allocationSiteTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
if
(
defaultNewTable
)
{
*
realmTables
+
=
defaultNewTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
if
(
lazyTable
)
{
*
realmTables
+
=
lazyTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
void
ObjectGroupRealm
:
:
clearTables
(
)
{
if
(
allocationSiteTable
)
{
allocationSiteTable
-
>
clear
(
)
;
}
if
(
defaultNewTable
)
{
defaultNewTable
-
>
clear
(
)
;
}
if
(
lazyTable
)
{
lazyTable
-
>
clear
(
)
;
}
defaultNewGroupCache
.
purge
(
)
;
}
void
ObjectGroupRealm
:
:
traceWeak
(
JSTracer
*
trc
)
{
if
(
stringSplitStringGroup
)
{
JS
:
:
GCPolicy
<
WeakHeapPtrObjectGroup
>
:
:
traceWeak
(
trc
&
stringSplitStringGroup
)
;
}
}
void
ObjectGroupRealm
:
:
fixupNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
table
)
{
for
(
NewTable
:
:
Enum
e
(
*
table
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
NewEntry
&
entry
=
e
.
mutableFront
(
)
;
ObjectGroup
*
group
=
entry
.
group
.
unbarrieredGet
(
)
;
if
(
IsForwarded
(
group
)
)
{
group
=
Forwarded
(
group
)
;
entry
.
group
.
set
(
group
)
;
}
TaggedProto
proto
=
group
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
&
&
IsForwarded
(
proto
.
toObject
(
)
)
)
{
proto
=
TaggedProto
(
Forwarded
(
proto
.
toObject
(
)
)
)
;
group
-
>
proto
(
)
=
proto
;
}
if
(
entry
.
associated
&
&
IsForwarded
(
entry
.
associated
)
)
{
entry
.
associated
=
Forwarded
(
entry
.
associated
)
;
}
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
ObjectGroupRealm
:
:
checkNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
!
table
)
{
return
;
}
for
(
auto
r
=
table
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
NewEntry
entry
=
r
.
front
(
)
;
CheckGCThingAfterMovingGC
(
entry
.
group
.
unbarrieredGet
(
)
)
;
TaggedProto
proto
=
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
)
{
CheckGCThingAfterMovingGC
(
proto
.
toObject
(
)
)
;
}
CheckGCThingAfterMovingGC
(
entry
.
associated
)
;
auto
ptr
=
table
-
>
lookup
(
NewEntry
:
:
Lookup
(
entry
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
