#
include
"
vm
/
ObjectGroup
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
builtin
/
DataViewObject
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
ObjectKind
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
ObjectGroup
*
MakeGroup
(
JSContext
*
cx
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
ObjectGroup
*
group
=
Allocate
<
ObjectGroup
>
(
cx
)
;
if
(
!
group
)
{
return
nullptr
;
}
new
(
group
)
ObjectGroup
(
proto
)
;
return
group
;
}
ObjectGroup
:
:
ObjectGroup
(
TaggedProto
proto
)
:
TenuredCellWithNonGCPointer
(
nullptr
)
proto_
(
proto
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
}
void
ObjectGroup
:
:
setProtoUnchecked
(
TaggedProto
proto
)
{
proto_
=
proto
;
MOZ_ASSERT_IF
(
proto_
.
isObject
(
)
&
&
proto_
.
toObject
(
)
-
>
is
<
NativeObject
>
(
)
proto_
.
toObject
(
)
-
>
isDelegate
(
)
)
;
}
bool
GlobalObject
:
:
shouldSplicePrototype
(
)
{
return
staticPrototype
(
)
=
=
nullptr
;
}
bool
GlobalObject
:
:
splicePrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
global
-
>
realm
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
if
(
proto
.
isObject
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
false
;
}
}
ObjectGroup
*
group
=
MakeGroup
(
cx
proto
)
;
if
(
!
group
)
{
return
false
;
}
global
-
>
setGroupRaw
(
group
)
;
return
true
;
}
struct
ObjectGroupRealm
:
:
NewEntry
{
WeakHeapPtrObjectGroup
group
;
explicit
NewEntry
(
ObjectGroup
*
group
)
:
group
(
group
)
{
}
struct
Lookup
{
TaggedProto
proto
;
explicit
Lookup
(
TaggedProto
proto
)
:
proto
(
proto
)
{
}
explicit
Lookup
(
const
NewEntry
&
entry
)
:
proto
(
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
)
{
}
}
;
bool
needsSweep
(
)
{
return
IsAboutToBeFinalized
(
&
group
)
;
}
bool
operator
=
=
(
const
NewEntry
&
other
)
const
{
return
group
=
=
other
.
group
;
}
}
;
namespace
js
{
template
<
>
struct
MovableCellHasher
<
ObjectGroupRealm
:
:
NewEntry
>
{
using
Key
=
ObjectGroupRealm
:
:
NewEntry
;
using
Lookup
=
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
hasHash
(
l
.
proto
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
ensureHash
(
l
.
proto
)
;
}
static
inline
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
}
static
inline
bool
match
(
const
ObjectGroupRealm
:
:
NewEntry
&
key
const
Lookup
&
lookup
)
{
TaggedProto
proto
=
key
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
return
MovableCellHasher
<
TaggedProto
>
:
:
match
(
proto
lookup
.
proto
)
;
}
}
;
}
class
ObjectGroupRealm
:
:
NewTable
:
public
JS
:
:
WeakCache
<
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
>
{
using
Table
=
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
;
using
Base
=
JS
:
:
WeakCache
<
Table
>
;
public
:
explicit
NewTable
(
Zone
*
zone
)
:
Base
(
zone
)
{
}
}
;
ObjectGroupRealm
&
ObjectGroupRealm
:
:
getForNewObject
(
JSContext
*
cx
)
{
return
cx
-
>
realm
(
)
-
>
objectGroups_
;
}
MOZ_ALWAYS_INLINE
ObjectGroup
*
ObjectGroupRealm
:
:
DefaultNewGroupCache
:
:
lookup
(
const
JSClass
*
clasp
TaggedProto
proto
)
{
if
(
group_
&
&
group_
-
>
proto
(
)
=
=
proto
)
{
return
group_
;
}
return
nullptr
;
}
ObjectGroup
*
ObjectGroup
:
:
defaultNewGroup
(
JSContext
*
cx
const
JSClass
*
clasp
TaggedProto
proto
)
{
MOZ_ASSERT
(
clasp
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
ObjectGroupRealm
&
groups
=
ObjectGroupRealm
:
:
getForNewObject
(
cx
)
;
if
(
ObjectGroup
*
group
=
groups
.
defaultNewGroupCache
.
lookup
(
clasp
proto
)
)
{
return
group
;
}
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
ObjectGroupRealm
:
:
NewTable
*
&
table
=
groups
.
defaultNewTable
;
if
(
!
table
)
{
table
=
cx
-
>
new_
<
ObjectGroupRealm
:
:
NewTable
>
(
cx
-
>
zone
(
)
)
;
if
(
!
table
)
{
return
nullptr
;
}
}
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isDelegate
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
nullptr
;
}
}
ObjectGroupRealm
:
:
NewTable
:
:
AddPtr
p
=
table
-
>
lookupForAdd
(
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
(
proto
)
)
;
if
(
p
)
{
ObjectGroup
*
group
=
p
-
>
group
;
MOZ_ASSERT
(
group
-
>
proto
(
)
=
=
proto
)
;
groups
.
defaultNewGroupCache
.
put
(
group
)
;
return
group
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
ObjectGroup
*
group
=
MakeGroup
(
cx
protoRoot
)
;
if
(
!
group
)
{
return
nullptr
;
}
if
(
!
table
-
>
add
(
p
ObjectGroupRealm
:
:
NewEntry
(
group
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
groups
.
defaultNewGroupCache
.
put
(
group
)
;
return
group
;
}
static
bool
AddPlainObjectProperties
(
JSContext
*
cx
HandlePlainObject
obj
IdValuePair
*
properties
size_t
nproperties
)
{
RootedId
propid
(
cx
)
;
RootedValue
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
nproperties
;
i
+
+
)
{
propid
=
properties
[
i
]
.
id
;
value
=
properties
[
i
]
.
value
;
if
(
!
NativeDefineDataProperty
(
cx
obj
propid
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
return
true
;
}
PlainObject
*
js
:
:
NewPlainObjectWithProperties
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
{
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
nproperties
)
;
RootedPlainObject
obj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
allocKind
newKind
)
)
;
if
(
!
obj
|
|
!
AddPlainObjectProperties
(
cx
obj
properties
nproperties
)
)
{
return
nullptr
;
}
return
obj
;
}
ObjectGroupRealm
:
:
~
ObjectGroupRealm
(
)
{
js_delete
(
defaultNewTable
)
;
}
void
ObjectGroupRealm
:
:
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
realmTables
)
{
if
(
defaultNewTable
)
{
*
realmTables
+
=
defaultNewTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
void
ObjectGroupRealm
:
:
clearTables
(
)
{
if
(
defaultNewTable
)
{
defaultNewTable
-
>
clear
(
)
;
}
defaultNewGroupCache
.
purge
(
)
;
}
void
ObjectGroupRealm
:
:
fixupNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
table
)
{
for
(
NewTable
:
:
Enum
e
(
*
table
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
NewEntry
&
entry
=
e
.
mutableFront
(
)
;
ObjectGroup
*
group
=
entry
.
group
.
unbarrieredGet
(
)
;
if
(
IsForwarded
(
group
)
)
{
group
=
Forwarded
(
group
)
;
entry
.
group
.
set
(
group
)
;
}
TaggedProto
proto
=
group
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
&
&
IsForwarded
(
proto
.
toObject
(
)
)
)
{
proto
=
TaggedProto
(
Forwarded
(
proto
.
toObject
(
)
)
)
;
group
-
>
proto
(
)
=
proto
;
}
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
ObjectGroupRealm
:
:
checkNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
!
table
)
{
return
;
}
for
(
auto
r
=
table
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
NewEntry
entry
=
r
.
front
(
)
;
CheckGCThingAfterMovingGC
(
entry
.
group
.
unbarrieredGet
(
)
)
;
TaggedProto
proto
=
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
)
{
CheckGCThingAfterMovingGC
(
proto
.
toObject
(
)
)
;
}
auto
ptr
=
table
-
>
lookup
(
NewEntry
:
:
Lookup
(
entry
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
ObjectGroup
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
return
size
;
}
