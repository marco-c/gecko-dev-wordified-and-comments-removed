#
include
"
vm
/
ObjectGroup
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
builtin
/
DataViewObject
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
ObjectKind
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
ObjectGroup
*
MakeGroup
(
JSContext
*
cx
const
JSClass
*
clasp
Handle
<
TaggedProto
>
proto
ObjectGroupFlags
initialFlags
=
0
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
ObjectGroup
*
group
=
Allocate
<
ObjectGroup
>
(
cx
)
;
if
(
!
group
)
{
return
nullptr
;
}
new
(
group
)
ObjectGroup
(
clasp
proto
cx
-
>
realm
(
)
initialFlags
)
;
return
group
;
}
ObjectGroup
:
:
ObjectGroup
(
const
JSClass
*
clasp
TaggedProto
proto
JS
:
:
Realm
*
realm
ObjectGroupFlags
initialFlags
)
:
TenuredCellWithNonGCPointer
(
clasp
)
proto_
(
proto
)
realm_
(
realm
)
flags_
(
initialFlags
)
{
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
MOZ_ASSERT
(
JS
:
:
StringIsASCII
(
clasp
-
>
name
)
)
;
#
ifdef
DEBUG
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
)
{
AssertTargetIsNotGray
(
global
)
;
}
#
endif
}
void
ObjectGroup
:
:
setProtoUnchecked
(
TaggedProto
proto
)
{
proto_
=
proto
;
MOZ_ASSERT_IF
(
proto_
.
isObject
(
)
&
&
proto_
.
toObject
(
)
-
>
isNative
(
)
proto_
.
toObject
(
)
-
>
isDelegate
(
)
)
;
}
void
ObjectGroup
:
:
setProto
(
TaggedProto
proto
)
{
MOZ_ASSERT
(
singleton
(
)
)
;
setProtoUnchecked
(
proto
)
;
}
bool
GlobalObject
:
:
shouldSplicePrototype
(
)
{
return
staticPrototype
(
)
=
=
nullptr
;
}
bool
JSObject
:
:
splicePrototype
(
JSContext
*
cx
HandleObject
obj
Handle
<
TaggedProto
>
proto
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isSingleton
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
!
IsWindow
(
proto
.
toObject
(
)
)
)
;
#
ifdef
DEBUG
const
JSClass
*
oldClass
=
obj
-
>
getClass
(
)
;
#
endif
if
(
proto
.
isObject
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
obj
-
>
group
(
)
-
>
clasp
(
)
=
=
oldClass
"
splicing
a
prototype
doesn
'
t
change
a
group
'
s
class
"
)
;
obj
-
>
group
(
)
-
>
setProto
(
proto
)
;
return
true
;
}
struct
ObjectGroupRealm
:
:
NewEntry
{
WeakHeapPtrObjectGroup
group
;
JSObject
*
associated
;
NewEntry
(
ObjectGroup
*
group
JSObject
*
associated
)
:
group
(
group
)
associated
(
associated
)
{
}
struct
Lookup
{
const
JSClass
*
clasp
;
TaggedProto
proto
;
JSObject
*
associated
;
Lookup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
:
clasp
(
clasp
)
proto
(
proto
)
associated
(
associated
)
{
MOZ_ASSERT
(
clasp
)
;
MOZ_ASSERT_IF
(
associated
&
&
associated
-
>
is
<
JSFunction
>
(
)
clasp
=
=
&
PlainObject
:
:
class_
)
;
}
explicit
Lookup
(
const
NewEntry
&
entry
)
:
clasp
(
entry
.
group
.
unbarrieredGet
(
)
-
>
clasp
(
)
)
proto
(
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
)
associated
(
entry
.
associated
)
{
MOZ_ASSERT_IF
(
associated
&
&
associated
-
>
is
<
JSFunction
>
(
)
clasp
=
=
&
PlainObject
:
:
class_
)
;
}
}
;
bool
needsSweep
(
)
{
return
IsAboutToBeFinalized
(
&
group
)
|
|
(
associated
&
&
IsAboutToBeFinalizedUnbarriered
(
&
associated
)
)
;
}
bool
operator
=
=
(
const
NewEntry
&
other
)
const
{
return
group
=
=
other
.
group
&
&
associated
=
=
other
.
associated
;
}
}
;
namespace
js
{
template
<
>
struct
MovableCellHasher
<
ObjectGroupRealm
:
:
NewEntry
>
{
using
Key
=
ObjectGroupRealm
:
:
NewEntry
;
using
Lookup
=
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
hasHash
(
l
.
proto
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
hasHash
(
l
.
associated
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
TaggedProto
>
:
:
ensureHash
(
l
.
proto
)
&
&
MovableCellHasher
<
JSObject
*
>
:
:
ensureHash
(
l
.
associated
)
;
}
static
inline
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
MovableCellHasher
<
JSObject
*
>
:
:
hash
(
lookup
.
associated
)
)
;
return
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashGeneric
(
lookup
.
clasp
)
)
;
}
static
inline
bool
match
(
const
ObjectGroupRealm
:
:
NewEntry
&
key
const
Lookup
&
lookup
)
{
if
(
key
.
group
.
unbarrieredGet
(
)
-
>
clasp
(
)
!
=
lookup
.
clasp
)
{
return
false
;
}
TaggedProto
proto
=
key
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
if
(
!
MovableCellHasher
<
TaggedProto
>
:
:
match
(
proto
lookup
.
proto
)
)
{
return
false
;
}
return
MovableCellHasher
<
JSObject
*
>
:
:
match
(
key
.
associated
lookup
.
associated
)
;
}
}
;
}
class
ObjectGroupRealm
:
:
NewTable
:
public
JS
:
:
WeakCache
<
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
>
{
using
Table
=
js
:
:
GCHashSet
<
NewEntry
MovableCellHasher
<
NewEntry
>
SystemAllocPolicy
>
;
using
Base
=
JS
:
:
WeakCache
<
Table
>
;
public
:
explicit
NewTable
(
Zone
*
zone
)
:
Base
(
zone
)
{
}
}
;
ObjectGroupRealm
&
ObjectGroupRealm
:
:
get
(
const
ObjectGroup
*
group
)
{
return
group
-
>
realm
(
)
-
>
objectGroups_
;
}
ObjectGroupRealm
&
ObjectGroupRealm
:
:
getForNewObject
(
JSContext
*
cx
)
{
return
cx
-
>
realm
(
)
-
>
objectGroups_
;
}
MOZ_ALWAYS_INLINE
ObjectGroup
*
ObjectGroupRealm
:
:
DefaultNewGroupCache
:
:
lookup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
{
if
(
group_
&
&
associated_
=
=
associated
&
&
group_
-
>
proto
(
)
=
=
proto
&
&
group_
-
>
clasp
(
)
=
=
clasp
)
{
return
group_
;
}
return
nullptr
;
}
ObjectGroup
*
ObjectGroup
:
:
defaultNewGroup
(
JSContext
*
cx
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
{
MOZ_ASSERT
(
clasp
)
;
MOZ_ASSERT_IF
(
associated
proto
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
isInsideCurrentCompartment
(
proto
.
toObject
(
)
)
)
;
if
(
associated
&
&
!
associated
-
>
is
<
TypeDescr
>
(
)
)
{
associated
=
nullptr
;
}
if
(
associated
)
{
MOZ_ASSERT
(
associated
-
>
is
<
TypeDescr
>
(
)
)
;
if
(
!
IsTypedObjectClass
(
clasp
)
)
{
associated
=
nullptr
;
}
}
ObjectGroupRealm
&
groups
=
ObjectGroupRealm
:
:
getForNewObject
(
cx
)
;
if
(
ObjectGroup
*
group
=
groups
.
defaultNewGroupCache
.
lookup
(
clasp
proto
associated
)
)
{
return
group
;
}
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
ObjectGroupRealm
:
:
NewTable
*
&
table
=
groups
.
defaultNewTable
;
if
(
!
table
)
{
table
=
cx
-
>
new_
<
ObjectGroupRealm
:
:
NewTable
>
(
cx
-
>
zone
(
)
)
;
if
(
!
table
)
{
return
nullptr
;
}
}
if
(
proto
.
isObject
(
)
&
&
!
proto
.
toObject
(
)
-
>
isDelegate
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setDelegate
(
cx
protoObj
)
)
{
return
nullptr
;
}
}
ObjectGroupRealm
:
:
NewTable
:
:
AddPtr
p
=
table
-
>
lookupForAdd
(
ObjectGroupRealm
:
:
NewEntry
:
:
Lookup
(
clasp
proto
associated
)
)
;
if
(
p
)
{
ObjectGroup
*
group
=
p
-
>
group
;
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
clasp
)
;
MOZ_ASSERT
(
group
-
>
proto
(
)
=
=
proto
)
;
groups
.
defaultNewGroupCache
.
put
(
group
associated
)
;
return
group
;
}
Rooted
<
TaggedProto
>
protoRoot
(
cx
proto
)
;
ObjectGroup
*
group
=
MakeGroup
(
cx
clasp
protoRoot
)
;
if
(
!
group
)
{
return
nullptr
;
}
if
(
!
table
-
>
add
(
p
ObjectGroupRealm
:
:
NewEntry
(
group
associated
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
if
(
associated
)
{
group
-
>
setTypeDescr
(
&
associated
-
>
as
<
TypeDescr
>
(
)
)
;
}
groups
.
defaultNewGroupCache
.
put
(
group
associated
)
;
return
group
;
}
static
bool
AddPlainObjectProperties
(
JSContext
*
cx
HandlePlainObject
obj
IdValuePair
*
properties
size_t
nproperties
)
{
RootedId
propid
(
cx
)
;
RootedValue
value
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
nproperties
;
i
+
+
)
{
propid
=
properties
[
i
]
.
id
;
value
=
properties
[
i
]
.
value
;
if
(
!
NativeDefineDataProperty
(
cx
obj
propid
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
return
true
;
}
PlainObject
*
js
:
:
NewPlainObjectWithProperties
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
{
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
nproperties
)
;
RootedPlainObject
obj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
allocKind
newKind
)
)
;
if
(
!
obj
|
|
!
AddPlainObjectProperties
(
cx
obj
properties
nproperties
)
)
{
return
nullptr
;
}
return
obj
;
}
ObjectGroupRealm
:
:
~
ObjectGroupRealm
(
)
{
js_delete
(
defaultNewTable
)
;
stringSplitStringGroup
=
nullptr
;
}
ObjectGroup
*
ObjectGroupRealm
:
:
getStringSplitStringGroup
(
JSContext
*
cx
)
{
ObjectGroupRealm
&
groups
=
ObjectGroupRealm
:
:
getForNewObject
(
cx
)
;
ObjectGroup
*
group
=
groups
.
stringSplitStringGroup
.
get
(
)
;
if
(
group
)
{
return
group
;
}
JSObject
*
proto
=
GlobalObject
:
:
getOrCreateArrayPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Rooted
<
TaggedProto
>
tagged
(
cx
TaggedProto
(
proto
)
)
;
group
=
MakeGroup
(
cx
&
ArrayObject
:
:
class_
tagged
)
;
if
(
!
group
)
{
return
nullptr
;
}
groups
.
stringSplitStringGroup
.
set
(
group
)
;
return
group
;
}
void
ObjectGroupRealm
:
:
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
allocationSiteTables
size_t
*
arrayObjectGroupTables
size_t
*
plainObjectGroupTables
size_t
*
realmTables
)
{
if
(
defaultNewTable
)
{
*
realmTables
+
=
defaultNewTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
void
ObjectGroupRealm
:
:
clearTables
(
)
{
if
(
defaultNewTable
)
{
defaultNewTable
-
>
clear
(
)
;
}
defaultNewGroupCache
.
purge
(
)
;
}
void
ObjectGroupRealm
:
:
traceWeak
(
JSTracer
*
trc
)
{
if
(
stringSplitStringGroup
)
{
JS
:
:
GCPolicy
<
WeakHeapPtrObjectGroup
>
:
:
traceWeak
(
trc
&
stringSplitStringGroup
)
;
}
}
void
ObjectGroupRealm
:
:
fixupNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
table
)
{
for
(
NewTable
:
:
Enum
e
(
*
table
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
NewEntry
&
entry
=
e
.
mutableFront
(
)
;
ObjectGroup
*
group
=
entry
.
group
.
unbarrieredGet
(
)
;
if
(
IsForwarded
(
group
)
)
{
group
=
Forwarded
(
group
)
;
entry
.
group
.
set
(
group
)
;
}
TaggedProto
proto
=
group
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
&
&
IsForwarded
(
proto
.
toObject
(
)
)
)
{
proto
=
TaggedProto
(
Forwarded
(
proto
.
toObject
(
)
)
)
;
group
-
>
proto
(
)
=
proto
;
}
if
(
entry
.
associated
&
&
IsForwarded
(
entry
.
associated
)
)
{
entry
.
associated
=
Forwarded
(
entry
.
associated
)
;
}
}
}
}
bool
JSObject
:
:
setSingleton
(
JSContext
*
cx
js
:
:
HandleObject
obj
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
MOZ_ASSERT
(
!
obj
-
>
isSingleton
(
)
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
obj
-
>
nonCCWRealm
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
GlobalObject
>
(
)
)
;
ObjectGroupFlags
initialFlags
=
OBJECT_FLAG_SINGLETON
;
Rooted
<
TaggedProto
>
proto
(
cx
obj
-
>
taggedProto
(
)
)
;
ObjectGroup
*
group
=
MakeGroup
(
cx
obj
-
>
getClass
(
)
proto
initialFlags
)
;
if
(
!
group
)
{
return
false
;
}
obj
-
>
setGroupRaw
(
group
)
;
return
true
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
ObjectGroupRealm
:
:
checkNewTableAfterMovingGC
(
NewTable
*
table
)
{
if
(
!
table
)
{
return
;
}
for
(
auto
r
=
table
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
NewEntry
entry
=
r
.
front
(
)
;
CheckGCThingAfterMovingGC
(
entry
.
group
.
unbarrieredGet
(
)
)
;
TaggedProto
proto
=
entry
.
group
.
unbarrieredGet
(
)
-
>
proto
(
)
;
if
(
proto
.
isObject
(
)
)
{
CheckGCThingAfterMovingGC
(
proto
.
toObject
(
)
)
;
}
CheckGCThingAfterMovingGC
(
entry
.
associated
)
;
auto
ptr
=
table
-
>
lookup
(
NewEntry
:
:
Lookup
(
entry
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
js
:
:
ObjectGroup
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
return
size
;
}
