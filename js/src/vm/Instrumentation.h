#
ifndef
vm_Instrumentation_h
#
define
vm_Instrumentation_h
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
namespace
js
{
namespace
frontend
{
struct
CompilationInfo
;
class
ParserAtom
;
}
#
define
FOR_EACH_INSTRUMENTATION_KIND
(
MACRO
)
\
MACRO
(
Main
"
main
"
1
<
<
0
)
\
/
*
Points
other
than
the
main
entry
point
where
a
frame
for
the
script
*
/
\
/
*
might
start
executing
.
*
/
\
MACRO
(
Entry
"
entry
"
1
<
<
1
)
\
/
*
Points
at
which
a
script
'
s
frame
will
be
popped
or
suspended
.
*
/
\
MACRO
(
Exit
"
exit
"
1
<
<
2
)
\
/
*
Breakpoint
sites
.
*
/
\
MACRO
(
Breakpoint
"
breakpoint
"
1
<
<
3
)
\
/
*
Property
access
operations
.
*
/
\
MACRO
(
GetProperty
"
getProperty
"
1
<
<
4
)
\
MACRO
(
SetProperty
"
setProperty
"
1
<
<
5
)
\
MACRO
(
GetElement
"
getElement
"
1
<
<
6
)
\
MACRO
(
SetElement
"
setElement
"
1
<
<
7
)
enum
class
InstrumentationKind
{
#
define
DEFINE_INSTRUMENTATION_ENUM
(
Name
_1
Value
)
Name
=
Value
FOR_EACH_INSTRUMENTATION_KIND
(
DEFINE_INSTRUMENTATION_ENUM
)
#
undef
DEFINE_INSTRUMENTATION_ENUM
}
;
class
RealmInstrumentation
{
const
GCPtrObject
callback
;
const
GCPtrObject
dbgObject
;
uint32_t
kinds
=
0
;
int32_t
active
=
0
;
public
:
static
bool
install
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleObject
callback
HandleObject
dbgObject
Handle
<
StringVector
>
kinds
)
;
static
JSObject
*
getCallback
(
GlobalObject
*
global
)
;
static
uint32_t
getInstrumentationKinds
(
GlobalObject
*
global
)
;
static
const
frontend
:
:
ParserAtom
*
getInstrumentationKindName
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
InstrumentationKind
kind
)
;
static
bool
getScriptId
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleScript
script
int32_t
*
id
)
;
static
bool
setActive
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
Debugger
*
dbg
bool
active
)
;
static
bool
isActive
(
GlobalObject
*
global
)
;
static
const
int32_t
*
addressOfActive
(
GlobalObject
*
global
)
;
RealmInstrumentation
(
Zone
*
zone
JSObject
*
callback
JSObject
*
dbgObject
uint32_t
kinds
)
;
void
trace
(
JSTracer
*
trc
)
;
static
void
holderFinalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
void
holderTrace
(
JSTracer
*
trc
JSObject
*
obj
)
;
}
;
enum
class
ShouldInstrument
{
No
Yes
}
;
bool
InstrumentationActiveOperation
(
JSContext
*
cx
MutableHandleValue
rv
)
;
JSObject
*
InstrumentationCallbackOperation
(
JSContext
*
cx
)
;
bool
InstrumentationScriptIdOperation
(
JSContext
*
cx
HandleScript
script
MutableHandleValue
rv
)
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
RealmInstrumentation
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
RealmInstrumentation
>
{
}
;
}
#
endif
