#
ifndef
vm_Float16_h
#
define
vm_Float16_h
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
<
type_traits
>
namespace
js
{
namespace
half
{
template
<
typename
T
>
struct
bits
{
typedef
unsigned
char
type
;
}
;
template
<
typename
T
>
struct
bits
<
const
T
>
:
bits
<
T
>
{
}
;
template
<
typename
T
>
struct
bits
<
volatile
T
>
:
bits
<
T
>
{
}
;
template
<
typename
T
>
struct
bits
<
const
volatile
T
>
:
bits
<
T
>
{
}
;
template
<
>
struct
bits
<
float
>
{
typedef
std
:
:
uint_least32_t
type
;
}
;
template
<
>
struct
bits
<
double
>
{
typedef
std
:
:
uint_least64_t
type
;
}
;
typedef
std
:
:
uint_fast32_t
uint32
;
constexpr
unsigned
int
overflow
(
unsigned
int
sign
=
0
)
{
return
sign
|
0x7C00
;
}
constexpr
unsigned
int
underflow
(
unsigned
int
sign
=
0
)
{
return
sign
;
}
constexpr
unsigned
int
rounded
(
unsigned
int
value
int
g
int
s
)
{
return
value
+
(
g
&
(
s
|
value
)
)
;
}
inline
unsigned
int
float2half_impl
(
float
value
)
{
bits
<
float
>
:
:
type
fbits
;
std
:
:
memcpy
(
&
fbits
&
value
sizeof
(
float
)
)
;
unsigned
int
sign
=
(
fbits
>
>
16
)
&
0x8000
;
fbits
&
=
0x7FFFFFFF
;
if
(
fbits
>
=
0x7F800000
)
return
sign
|
0x7C00
|
(
(
fbits
>
0x7F800000
)
?
(
0x200
|
(
(
fbits
>
>
13
)
&
0x3FF
)
)
:
0
)
;
if
(
fbits
>
=
0x47800000
)
return
overflow
(
sign
)
;
if
(
fbits
>
=
0x38800000
)
return
rounded
(
sign
|
(
(
(
fbits
>
>
23
)
-
112
)
<
<
10
)
|
(
(
fbits
>
>
13
)
&
0x3FF
)
(
fbits
>
>
12
)
&
1
(
fbits
&
0xFFF
)
!
=
0
)
;
if
(
fbits
>
=
0x33000000
)
{
int
i
=
125
-
(
fbits
>
>
23
)
;
fbits
=
(
fbits
&
0x7FFFFF
)
|
0x800000
;
return
rounded
(
sign
|
(
fbits
>
>
(
i
+
1
)
)
(
fbits
>
>
i
)
&
1
(
fbits
&
(
(
static_cast
<
uint32
>
(
1
)
<
<
i
)
-
1
)
)
!
=
0
)
;
}
if
(
fbits
!
=
0
)
return
underflow
(
sign
)
;
return
sign
;
}
inline
unsigned
int
float2half_impl
(
double
value
)
{
bits
<
double
>
:
:
type
dbits
;
std
:
:
memcpy
(
&
dbits
&
value
sizeof
(
double
)
)
;
uint32
hi
=
dbits
>
>
32
lo
=
dbits
&
0xFFFFFFFF
;
unsigned
int
sign
=
(
hi
>
>
16
)
&
0x8000
;
hi
&
=
0x7FFFFFFF
;
if
(
hi
>
=
0x7FF00000
)
return
sign
|
0x7C00
|
(
(
dbits
&
0xFFFFFFFFFFFFF
)
?
(
0x200
|
(
(
hi
>
>
10
)
&
0x3FF
)
)
:
0
)
;
if
(
hi
>
=
0x40F00000
)
return
overflow
(
sign
)
;
if
(
hi
>
=
0x3F100000
)
return
rounded
(
sign
|
(
(
(
hi
>
>
20
)
-
1008
)
<
<
10
)
|
(
(
hi
>
>
10
)
&
0x3FF
)
(
hi
>
>
9
)
&
1
(
(
hi
&
0x1FF
)
|
lo
)
!
=
0
)
;
if
(
hi
>
=
0x3E600000
)
{
int
i
=
1018
-
(
hi
>
>
20
)
;
hi
=
(
hi
&
0xFFFFF
)
|
0x100000
;
return
rounded
(
sign
|
(
hi
>
>
(
i
+
1
)
)
(
hi
>
>
i
)
&
1
(
(
hi
&
(
(
static_cast
<
uint32
>
(
1
)
<
<
i
)
-
1
)
)
|
lo
)
!
=
0
)
;
}
if
(
(
hi
|
lo
)
!
=
0
)
return
underflow
(
sign
)
;
return
sign
;
}
template
<
typename
T
>
inline
T
half2float_impl
(
unsigned
int
value
)
;
template
<
>
inline
double
half2float_impl
(
unsigned
int
value
)
{
uint32
hi
=
static_cast
<
uint32
>
(
value
&
0x8000
)
<
<
16
;
unsigned
int
abs
=
value
&
0x7FFF
;
if
(
abs
)
{
hi
|
=
0x3F000000
<
<
static_cast
<
unsigned
>
(
abs
>
=
0x7C00
)
;
for
(
;
abs
<
0x400
;
abs
<
<
=
1
hi
-
=
0x100000
)
;
hi
+
=
static_cast
<
uint32
>
(
abs
)
<
<
10
;
}
bits
<
double
>
:
:
type
dbits
=
static_cast
<
bits
<
double
>
:
:
type
>
(
hi
)
<
<
32
;
double
out
;
std
:
:
memcpy
(
&
out
&
dbits
sizeof
(
double
)
)
;
return
out
;
}
template
<
>
inline
float
half2float_impl
(
unsigned
int
value
)
{
bits
<
float
>
:
:
type
fbits
=
static_cast
<
bits
<
float
>
:
:
type
>
(
value
&
0x8000
)
<
<
16
;
int
abs
=
value
&
0x7FFF
;
if
(
abs
)
{
fbits
|
=
0x38000000
<
<
static_cast
<
unsigned
>
(
abs
>
=
0x7C00
)
;
for
(
;
abs
<
0x400
;
abs
<
<
=
1
fbits
-
=
0x800000
)
;
fbits
+
=
static_cast
<
bits
<
float
>
:
:
type
>
(
abs
)
<
<
13
;
}
float
out
;
std
:
:
memcpy
(
&
out
&
fbits
sizeof
(
float
)
)
;
return
out
;
}
}
class
float16
final
{
uint16_t
val
;
public
:
float16
(
)
=
default
;
constexpr
float16
(
const
float16
&
)
=
default
;
explicit
float16
(
float
x
)
:
val
(
half
:
:
float2half_impl
(
x
)
)
{
}
explicit
float16
(
double
x
)
:
val
(
half
:
:
float2half_impl
(
x
)
)
{
}
explicit
float16
(
std
:
:
int8_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
int16_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
int32_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
int64_t
x
)
:
float16
(
double
(
x
)
)
{
}
explicit
float16
(
std
:
:
uint8_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
uint16_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
uint32_t
x
)
:
float16
(
float
(
x
)
)
{
}
explicit
float16
(
std
:
:
uint64_t
x
)
:
float16
(
double
(
x
)
)
{
}
explicit
float16
(
bool
x
)
:
float16
(
float
(
x
)
)
{
}
constexpr
float16
&
operator
=
(
const
float16
&
)
=
default
;
float16
&
operator
=
(
float
x
)
{
*
this
=
float16
{
x
}
;
return
*
this
;
}
float16
&
operator
=
(
double
x
)
{
*
this
=
float16
{
x
}
;
return
*
this
;
}
explicit
operator
float
(
)
const
{
return
half
:
:
half2float_impl
<
float
>
(
val
)
;
}
explicit
operator
double
(
)
const
{
return
half
:
:
half2float_impl
<
double
>
(
val
)
;
}
uint16_t
toRawBits
(
)
const
{
return
val
;
}
static
constexpr
float16
fromRawBits
(
uint16_t
bits
)
{
float16
f16
{
}
;
f16
.
val
=
bits
;
return
f16
;
}
}
;
static_assert
(
sizeof
(
float16
)
=
=
2
"
float16
has
no
extra
padding
"
)
;
static_assert
(
std
:
:
is_trivial_v
<
float16
>
"
float16
must
be
trivial
to
be
eligible
for
memcpy
/
memset
optimizations
"
)
;
}
#
endif
