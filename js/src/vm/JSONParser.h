#
ifndef
vm_JSONParser_h
#
define
vm_JSONParser_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
ds
/
IdValuePair
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
enum
class
JSONToken
{
String
Number
True
False
Null
ArrayOpen
ArrayClose
ObjectOpen
ObjectClose
Colon
Comma
OOM
Error
}
;
enum
class
JSONStringType
{
PropertyName
LiteralValue
}
;
template
<
typename
CharT
typename
ParserT
typename
StringBuilderT
>
class
MOZ_STACK_CLASS
JSONTokenizer
{
public
:
using
CharPtr
=
mozilla
:
:
RangedPtr
<
const
CharT
>
;
protected
:
CharPtr
current
;
const
CharPtr
begin
end
;
ParserT
*
parser
=
nullptr
;
public
:
JSONTokenizer
(
CharPtr
current
const
CharPtr
begin
const
CharPtr
end
ParserT
*
parser
)
:
current
(
current
)
begin
(
begin
)
end
(
end
)
parser
(
parser
)
{
MOZ_ASSERT
(
current
<
=
end
)
;
MOZ_ASSERT
(
parser
)
;
}
explicit
JSONTokenizer
(
mozilla
:
:
Range
<
const
CharT
>
data
ParserT
*
parser
)
:
JSONTokenizer
(
data
.
begin
(
)
data
.
begin
(
)
data
.
end
(
)
parser
)
{
}
JSONTokenizer
(
JSONTokenizer
<
CharT
ParserT
StringBuilderT
>
&
&
other
)
noexcept
:
JSONTokenizer
(
other
.
current
other
.
begin
other
.
end
other
.
parser
)
{
}
JSONTokenizer
(
const
JSONTokenizer
<
CharT
ParserT
StringBuilderT
>
&
other
)
=
delete
;
void
operator
=
(
const
JSONTokenizer
<
CharT
ParserT
StringBuilderT
>
&
other
)
=
delete
;
void
fixupParser
(
ParserT
*
newParser
)
{
parser
=
newParser
;
}
void
getTextPosition
(
uint32_t
*
column
uint32_t
*
line
)
;
bool
consumeTrailingWhitespaces
(
)
;
JSONToken
advance
(
)
;
JSONToken
advancePropertyName
(
)
;
JSONToken
advancePropertyColon
(
)
;
JSONToken
advanceAfterProperty
(
)
;
JSONToken
advanceAfterObjectOpen
(
)
;
JSONToken
advanceAfterArrayElement
(
)
;
void
unget
(
)
{
-
-
current
;
}
#
ifdef
DEBUG
bool
finished
(
)
{
return
end
=
=
current
;
}
#
endif
JSONToken
token
(
JSONToken
t
)
{
MOZ_ASSERT
(
t
!
=
JSONToken
:
:
String
)
;
MOZ_ASSERT
(
t
!
=
JSONToken
:
:
Number
)
;
return
t
;
}
template
<
JSONStringType
ST
>
JSONToken
stringToken
(
const
CharPtr
start
size_t
length
)
;
template
<
JSONStringType
ST
>
JSONToken
stringToken
(
StringBuilderT
&
builder
)
;
JSONToken
numberToken
(
double
d
)
;
template
<
JSONStringType
ST
>
JSONToken
readString
(
)
;
JSONToken
readNumber
(
)
;
void
error
(
const
char
*
msg
)
;
}
;
enum
class
JSONParserState
{
FinishArrayElement
FinishObjectMember
JSONValue
}
;
class
MOZ_STACK_CLASS
JSONFullParseHandlerAnyChar
{
public
:
using
ElementVector
=
GCVector
<
Value
20
>
;
using
PropertyVector
=
GCVector
<
IdValuePair
10
>
;
enum
class
ParseType
{
JSONParse
AttemptForEval
}
;
struct
StackEntry
{
ElementVector
&
elements
(
)
{
MOZ_ASSERT
(
state
=
=
JSONParserState
:
:
FinishArrayElement
)
;
return
*
static_cast
<
ElementVector
*
>
(
vector
)
;
}
PropertyVector
&
properties
(
)
{
MOZ_ASSERT
(
state
=
=
JSONParserState
:
:
FinishObjectMember
)
;
return
*
static_cast
<
PropertyVector
*
>
(
vector
)
;
}
explicit
StackEntry
(
ElementVector
*
elements
)
:
state
(
JSONParserState
:
:
FinishArrayElement
)
vector
(
elements
)
{
}
explicit
StackEntry
(
PropertyVector
*
properties
)
:
state
(
JSONParserState
:
:
FinishObjectMember
)
vector
(
properties
)
{
}
JSONParserState
state
;
private
:
void
*
vector
;
}
;
public
:
JSContext
*
cx
;
Value
v
;
ParseType
parseType
=
ParseType
:
:
JSONParse
;
private
:
Vector
<
ElementVector
*
5
>
freeElements
;
Vector
<
PropertyVector
*
5
>
freeProperties
;
public
:
explicit
JSONFullParseHandlerAnyChar
(
JSContext
*
cx
)
:
cx
(
cx
)
freeElements
(
cx
)
freeProperties
(
cx
)
{
}
~
JSONFullParseHandlerAnyChar
(
)
;
JSONFullParseHandlerAnyChar
(
JSONFullParseHandlerAnyChar
&
&
other
)
noexcept
:
cx
(
other
.
cx
)
v
(
other
.
v
)
parseType
(
other
.
parseType
)
freeElements
(
std
:
:
move
(
other
.
freeElements
)
)
freeProperties
(
std
:
:
move
(
other
.
freeProperties
)
)
{
}
JSONFullParseHandlerAnyChar
(
const
JSONFullParseHandlerAnyChar
&
other
)
=
delete
;
void
operator
=
(
const
JSONFullParseHandlerAnyChar
&
other
)
=
delete
;
JSContext
*
context
(
)
{
return
cx
;
}
Value
numberValue
(
)
const
{
MOZ_ASSERT
(
v
.
isNumber
(
)
)
;
return
v
;
}
inline
void
setNumberValue
(
double
d
)
;
Value
stringValue
(
)
const
{
MOZ_ASSERT
(
v
.
isString
(
)
)
;
return
v
;
}
JSAtom
*
atomValue
(
)
const
{
Value
strval
=
stringValue
(
)
;
return
&
strval
.
toString
(
)
-
>
asAtom
(
)
;
}
inline
Value
booleanValue
(
bool
value
)
{
return
JS
:
:
BooleanValue
(
value
)
;
}
inline
Value
nullValue
(
)
{
return
JS
:
:
NullValue
(
)
;
}
inline
bool
objectOpen
(
Vector
<
StackEntry
10
>
&
stack
PropertyVector
*
*
properties
)
;
inline
bool
objectPropertyName
(
Vector
<
StackEntry
10
>
&
stack
bool
*
isProtoInEval
)
;
inline
void
finishObjectMember
(
Vector
<
StackEntry
10
>
&
stack
JS
:
:
Handle
<
JS
:
:
Value
>
value
PropertyVector
*
*
properties
)
;
inline
bool
finishObject
(
Vector
<
StackEntry
10
>
&
stack
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
PropertyVector
&
properties
)
;
inline
bool
arrayOpen
(
Vector
<
StackEntry
10
>
&
stack
ElementVector
*
*
elements
)
;
inline
bool
arrayElement
(
Vector
<
StackEntry
10
>
&
stack
JS
:
:
Handle
<
JS
:
:
Value
>
value
ElementVector
*
*
elements
)
;
inline
bool
finishArray
(
Vector
<
StackEntry
10
>
&
stack
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
ElementVector
&
elements
)
;
inline
bool
errorReturn
(
)
const
{
return
parseType
=
=
ParseType
:
:
AttemptForEval
;
}
inline
bool
ignoreError
(
)
const
{
return
parseType
=
=
ParseType
:
:
AttemptForEval
;
}
inline
void
freeStackEntry
(
StackEntry
&
entry
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONFullParseHandler
:
public
JSONFullParseHandlerAnyChar
{
using
Base
=
JSONFullParseHandlerAnyChar
;
using
CharPtr
=
mozilla
:
:
RangedPtr
<
const
CharT
>
;
public
:
using
ContextT
=
JSContext
;
class
StringBuilder
{
public
:
JSStringBuilder
buffer
;
explicit
StringBuilder
(
JSContext
*
cx
)
:
buffer
(
cx
)
{
}
bool
append
(
char16_t
c
)
;
bool
append
(
const
CharT
*
begin
const
CharT
*
end
)
;
}
;
explicit
JSONFullParseHandler
(
JSContext
*
cx
)
:
Base
(
cx
)
{
}
JSONFullParseHandler
(
JSONFullParseHandler
&
&
other
)
noexcept
:
Base
(
std
:
:
move
(
other
)
)
{
}
JSONFullParseHandler
(
const
JSONFullParseHandler
&
other
)
=
delete
;
void
operator
=
(
const
JSONFullParseHandler
&
other
)
=
delete
;
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
CharPtr
start
size_t
length
)
;
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
StringBuilder
&
builder
)
;
void
reportError
(
const
char
*
msg
const
char
*
lineString
const
char
*
columnString
)
;
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONSyntaxParseHandler
{
private
:
using
CharPtr
=
mozilla
:
:
RangedPtr
<
const
CharT
>
;
public
:
using
ContextT
=
FrontendContext
;
class
DummyValue
{
}
;
struct
ElementVector
{
}
;
struct
PropertyVector
{
}
;
class
StringBuilder
{
public
:
explicit
StringBuilder
(
FrontendContext
*
fc
)
{
}
bool
append
(
char16_t
c
)
{
return
true
;
}
bool
append
(
const
CharT
*
begin
const
CharT
*
end
)
{
return
true
;
}
}
;
struct
StackEntry
{
JSONParserState
state
;
}
;
public
:
FrontendContext
*
fc
;
explicit
JSONSyntaxParseHandler
(
FrontendContext
*
fc
)
:
fc
(
fc
)
{
}
JSONSyntaxParseHandler
(
JSONSyntaxParseHandler
&
&
other
)
noexcept
:
fc
(
other
.
fc
)
{
}
JSONSyntaxParseHandler
(
const
JSONSyntaxParseHandler
&
other
)
=
delete
;
void
operator
=
(
const
JSONSyntaxParseHandler
&
other
)
=
delete
;
FrontendContext
*
context
(
)
{
return
fc
;
}
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
CharPtr
start
size_t
length
)
{
return
true
;
}
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
StringBuilder
&
builder
)
{
return
true
;
}
inline
void
setNumberValue
(
double
d
)
{
}
inline
DummyValue
numberValue
(
)
const
{
return
DummyValue
(
)
;
}
inline
DummyValue
stringValue
(
)
const
{
return
DummyValue
(
)
;
}
inline
DummyValue
booleanValue
(
bool
value
)
{
return
DummyValue
(
)
;
}
inline
DummyValue
nullValue
(
)
{
return
DummyValue
(
)
;
}
inline
bool
objectOpen
(
Vector
<
StackEntry
10
>
&
stack
PropertyVector
*
*
properties
)
;
inline
bool
objectPropertyName
(
Vector
<
StackEntry
10
>
&
stack
bool
*
isProtoInEval
)
{
*
isProtoInEval
=
false
;
return
true
;
}
inline
void
finishObjectMember
(
Vector
<
StackEntry
10
>
&
stack
DummyValue
&
value
PropertyVector
*
*
properties
)
{
}
inline
bool
finishObject
(
Vector
<
StackEntry
10
>
&
stack
DummyValue
*
vp
PropertyVector
&
properties
)
;
inline
bool
arrayOpen
(
Vector
<
StackEntry
10
>
&
stack
ElementVector
*
*
elements
)
;
inline
bool
arrayElement
(
Vector
<
StackEntry
10
>
&
stack
DummyValue
&
value
ElementVector
*
*
elements
)
{
return
true
;
}
inline
bool
finishArray
(
Vector
<
StackEntry
10
>
&
stack
DummyValue
*
vp
ElementVector
&
elements
)
;
inline
bool
errorReturn
(
)
const
{
return
false
;
}
inline
bool
ignoreError
(
)
const
{
return
false
;
}
inline
void
freeStackEntry
(
StackEntry
&
entry
)
{
}
void
reportError
(
const
char
*
msg
const
char
*
lineString
const
char
*
columnString
)
;
}
;
template
<
typename
CharT
typename
HandlerT
>
class
MOZ_STACK_CLASS
JSONPerHandlerParser
{
using
ContextT
=
typename
HandlerT
:
:
ContextT
;
using
Tokenizer
=
JSONTokenizer
<
CharT
JSONPerHandlerParser
<
CharT
HandlerT
>
typename
HandlerT
:
:
StringBuilder
>
;
public
:
using
StringBuilder
=
typename
HandlerT
:
:
StringBuilder
;
public
:
HandlerT
handler
;
Tokenizer
tokenizer
;
Vector
<
typename
HandlerT
:
:
StackEntry
10
>
stack
;
public
:
JSONPerHandlerParser
(
ContextT
*
context
mozilla
:
:
Range
<
const
CharT
>
data
)
:
handler
(
context
)
tokenizer
(
data
this
)
stack
(
context
)
{
}
JSONPerHandlerParser
(
JSONPerHandlerParser
&
&
other
)
noexcept
:
handler
(
std
:
:
move
(
other
.
handler
)
)
tokenizer
(
std
:
:
move
(
other
.
tokenizer
)
)
stack
(
handler
.
context
(
)
)
{
tokenizer
.
fixupParser
(
this
)
;
}
~
JSONPerHandlerParser
(
)
;
JSONPerHandlerParser
(
const
JSONPerHandlerParser
<
CharT
HandlerT
>
&
other
)
=
delete
;
void
operator
=
(
const
JSONPerHandlerParser
<
CharT
HandlerT
>
&
other
)
=
delete
;
template
<
typename
TempValueT
typename
ResultSetter
>
inline
bool
parseImpl
(
TempValueT
&
value
ResultSetter
setResult
)
;
void
outOfMemory
(
)
;
void
error
(
const
char
*
msg
)
;
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONParser
:
JSONPerHandlerParser
<
CharT
JSONFullParseHandler
<
CharT
>
>
{
using
Base
=
JSONPerHandlerParser
<
CharT
JSONFullParseHandler
<
CharT
>
>
;
public
:
using
ParseType
=
JSONFullParseHandlerAnyChar
:
:
ParseType
;
JSONParser
(
JSContext
*
cx
mozilla
:
:
Range
<
const
CharT
>
data
ParseType
parseType
)
:
Base
(
cx
data
)
{
this
-
>
handler
.
parseType
=
parseType
;
}
JSONParser
(
JSONParser
&
&
other
)
noexcept
:
Base
(
std
:
:
move
(
other
)
)
{
}
JSONParser
(
const
JSONParser
&
other
)
=
delete
;
void
operator
=
(
const
JSONParser
&
other
)
=
delete
;
bool
parse
(
MutableHandleValue
vp
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
typename
CharT
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
JSONParser
<
CharT
>
Wrapper
>
:
public
WrappedPtrOperations
<
JSONParser
<
CharT
>
Wrapper
>
{
public
:
bool
parse
(
MutableHandleValue
vp
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
.
parse
(
vp
)
;
}
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONSyntaxParser
:
JSONPerHandlerParser
<
CharT
JSONSyntaxParseHandler
<
CharT
>
>
{
using
HandlerT
=
JSONSyntaxParseHandler
<
CharT
>
;
using
Base
=
JSONPerHandlerParser
<
CharT
HandlerT
>
;
public
:
JSONSyntaxParser
(
FrontendContext
*
fc
mozilla
:
:
Range
<
const
CharT
>
data
)
:
Base
(
fc
data
)
{
}
JSONSyntaxParser
(
JSONSyntaxParser
<
CharT
>
&
&
other
)
noexcept
:
Base
(
std
:
:
move
(
other
)
)
{
}
JSONSyntaxParser
(
const
JSONSyntaxParser
&
other
)
=
delete
;
void
operator
=
(
const
JSONSyntaxParser
&
other
)
=
delete
;
bool
parse
(
)
;
}
;
}
#
endif
