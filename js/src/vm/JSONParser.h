#
ifndef
vm_JSONParser_h
#
define
vm_JSONParser_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
ds
/
IdValuePair
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
class
JSStringBuilder
;
enum
class
JSONToken
{
String
Number
True
False
Null
ArrayOpen
ArrayClose
ObjectOpen
ObjectClose
Colon
Comma
OOM
Error
}
;
template
<
typename
CharT
>
class
JSONParser
;
enum
class
JSONStringType
{
PropertyName
LiteralValue
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONTokenizer
{
public
:
using
CharPtr
=
mozilla
:
:
RangedPtr
<
const
CharT
>
;
protected
:
CharPtr
current
;
const
CharPtr
begin
end
;
JSONParser
<
CharT
>
*
parser
=
nullptr
;
public
:
JSONTokenizer
(
CharPtr
current
const
CharPtr
begin
const
CharPtr
end
JSONParser
<
CharT
>
*
parser
)
:
current
(
current
)
begin
(
begin
)
end
(
end
)
parser
(
parser
)
{
MOZ_ASSERT
(
current
<
=
end
)
;
MOZ_ASSERT
(
parser
)
;
}
explicit
JSONTokenizer
(
mozilla
:
:
Range
<
const
CharT
>
data
JSONParser
<
CharT
>
*
parser
)
:
JSONTokenizer
(
data
.
begin
(
)
data
.
begin
(
)
data
.
end
(
)
parser
)
{
}
JSONTokenizer
(
JSONTokenizer
<
CharT
>
&
&
other
)
noexcept
:
JSONTokenizer
(
other
.
current
other
.
begin
other
.
end
other
.
parser
)
{
}
JSONTokenizer
(
const
JSONTokenizer
<
CharT
>
&
other
)
=
delete
;
void
operator
=
(
const
JSONTokenizer
<
CharT
>
&
other
)
=
delete
;
void
fixupParser
(
JSONParser
<
CharT
>
*
newParser
)
{
parser
=
newParser
;
}
void
getTextPosition
(
uint32_t
*
column
uint32_t
*
line
)
;
bool
consumeTrailingWhitespaces
(
)
;
JSONToken
advance
(
)
;
JSONToken
advancePropertyName
(
)
;
JSONToken
advancePropertyColon
(
)
;
JSONToken
advanceAfterProperty
(
)
;
JSONToken
advanceAfterObjectOpen
(
)
;
JSONToken
advanceAfterArrayElement
(
)
;
void
unget
(
)
{
-
-
current
;
}
#
ifdef
DEBUG
bool
finished
(
)
{
return
end
=
=
current
;
}
#
endif
JSONToken
token
(
JSONToken
t
)
{
MOZ_ASSERT
(
t
!
=
JSONToken
:
:
String
)
;
MOZ_ASSERT
(
t
!
=
JSONToken
:
:
Number
)
;
return
t
;
}
template
<
JSONStringType
ST
>
JSONToken
stringToken
(
const
CharPtr
start
size_t
length
)
;
template
<
JSONStringType
ST
>
JSONToken
stringToken
(
JSStringBuilder
&
builder
)
;
JSONToken
numberToken
(
double
d
)
;
template
<
JSONStringType
ST
>
JSONToken
readString
(
)
;
JSONToken
readNumber
(
)
;
void
error
(
const
char
*
msg
)
;
}
;
class
MOZ_STACK_CLASS
JSONParserBase
{
public
:
enum
class
ParseType
{
JSONParse
AttemptForEval
}
;
public
:
Value
v
;
JSContext
*
const
cx
;
protected
:
const
ParseType
parseType
;
typedef
GCVector
<
Value
20
>
ElementVector
;
typedef
GCVector
<
IdValuePair
10
>
PropertyVector
;
enum
ParserState
{
FinishArrayElement
FinishObjectMember
JSONValue
}
;
struct
StackEntry
{
ElementVector
&
elements
(
)
{
MOZ_ASSERT
(
state
=
=
FinishArrayElement
)
;
return
*
static_cast
<
ElementVector
*
>
(
vector
)
;
}
PropertyVector
&
properties
(
)
{
MOZ_ASSERT
(
state
=
=
FinishObjectMember
)
;
return
*
static_cast
<
PropertyVector
*
>
(
vector
)
;
}
explicit
StackEntry
(
ElementVector
*
elements
)
:
state
(
FinishArrayElement
)
vector
(
elements
)
{
}
explicit
StackEntry
(
PropertyVector
*
properties
)
:
state
(
FinishObjectMember
)
vector
(
properties
)
{
}
ParserState
state
;
private
:
void
*
vector
;
}
;
Vector
<
StackEntry
10
>
stack
;
Vector
<
ElementVector
*
5
>
freeElements
;
Vector
<
PropertyVector
*
5
>
freeProperties
;
JSONParserBase
(
JSContext
*
cx
ParseType
parseType
)
:
cx
(
cx
)
parseType
(
parseType
)
stack
(
cx
)
freeElements
(
cx
)
freeProperties
(
cx
)
{
}
~
JSONParserBase
(
)
;
JSONParserBase
(
JSONParserBase
&
&
other
)
:
v
(
other
.
v
)
cx
(
other
.
cx
)
parseType
(
other
.
parseType
)
stack
(
std
:
:
move
(
other
.
stack
)
)
freeElements
(
std
:
:
move
(
other
.
freeElements
)
)
freeProperties
(
std
:
:
move
(
other
.
freeProperties
)
)
{
}
Value
numberValue
(
)
const
{
MOZ_ASSERT
(
v
.
isNumber
(
)
)
;
return
v
;
}
Value
stringValue
(
)
const
{
MOZ_ASSERT
(
v
.
isString
(
)
)
;
return
v
;
}
JSAtom
*
atomValue
(
)
const
{
Value
strval
=
stringValue
(
)
;
return
&
strval
.
toString
(
)
-
>
asAtom
(
)
;
}
bool
errorReturn
(
)
;
bool
finishObject
(
MutableHandleValue
vp
PropertyVector
&
properties
)
;
bool
finishArray
(
MutableHandleValue
vp
ElementVector
&
elements
)
;
void
trace
(
JSTracer
*
trc
)
;
public
:
inline
void
setNumberValue
(
double
d
)
;
private
:
JSONParserBase
(
const
JSONParserBase
&
other
)
=
delete
;
void
operator
=
(
const
JSONParserBase
&
other
)
=
delete
;
}
;
template
<
typename
CharT
>
class
MOZ_STACK_CLASS
JSONParser
:
public
JSONParserBase
{
using
Tokenizer
=
JSONTokenizer
<
CharT
>
;
using
CharPtr
=
mozilla
:
:
RangedPtr
<
const
CharT
>
;
Tokenizer
tokenizer
;
public
:
JSONParser
(
JSContext
*
cx
mozilla
:
:
Range
<
const
CharT
>
data
ParseType
parseType
)
:
JSONParserBase
(
cx
parseType
)
tokenizer
(
data
this
)
{
}
JSONParser
(
JSONParser
&
&
other
)
:
JSONParserBase
(
std
:
:
move
(
other
)
)
tokenizer
(
std
:
:
move
(
other
.
tokenizer
)
)
{
tokenizer
.
fixupParser
(
this
)
;
}
bool
parse
(
MutableHandleValue
vp
)
;
void
trace
(
JSTracer
*
trc
)
{
JSONParserBase
:
:
trace
(
trc
)
;
}
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
CharPtr
start
size_t
length
)
;
template
<
JSONStringType
ST
>
inline
bool
setStringValue
(
JSStringBuilder
&
builder
)
;
void
error
(
const
char
*
msg
)
;
private
:
JSONParser
(
const
JSONParser
&
other
)
=
delete
;
void
operator
=
(
const
JSONParser
&
other
)
=
delete
;
}
;
template
<
typename
CharT
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
JSONParser
<
CharT
>
Wrapper
>
:
public
WrappedPtrOperations
<
JSONParser
<
CharT
>
Wrapper
>
{
public
:
bool
parse
(
MutableHandleValue
vp
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
.
parse
(
vp
)
;
}
}
;
}
#
endif
