#
include
"
vm
/
InternalThreadPool
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
js
/
ProfilingCategory
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
util
/
NativeStack
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
static
const
uint32_t
kDefaultHelperStackSize
=
2048
*
1024
-
2
*
4096
;
#
if
defined
(
MOZ_TSAN
)
static
const
uint32_t
HELPER_STACK_SIZE
=
2
*
kDefaultHelperStackSize
;
#
else
static
const
uint32_t
HELPER_STACK_SIZE
=
kDefaultHelperStackSize
;
#
endif
#
define
PROFILER_RAII_PASTE
(
id
line
)
id
#
#
line
#
define
PROFILER_RAII_EXPAND
(
id
line
)
PROFILER_RAII_PASTE
(
id
line
)
#
define
PROFILER_RAII
PROFILER_RAII_EXPAND
(
raiiObject
__LINE__
)
#
define
AUTO_PROFILER_LABEL
(
label
categoryPair
)
\
HelperThread
:
:
AutoProfilerLabel
PROFILER_RAII
(
\
this
label
JS
:
:
ProfilingCategoryPair
:
:
categoryPair
)
using
namespace
js
;
namespace
js
{
class
HelperThread
{
Thread
thread
;
ProfilingStack
*
profilingStack
=
nullptr
;
public
:
HelperThread
(
)
;
[
[
nodiscard
]
]
bool
init
(
InternalThreadPool
*
pool
)
;
ThreadId
threadId
(
)
{
return
thread
.
get_id
(
)
;
}
void
join
(
)
;
static
void
ThreadMain
(
InternalThreadPool
*
pool
HelperThread
*
helper
)
;
void
threadLoop
(
InternalThreadPool
*
pool
)
;
void
ensureRegisteredWithProfiler
(
)
;
void
unregisterWithProfilerIfNeeded
(
)
;
private
:
struct
AutoProfilerLabel
{
AutoProfilerLabel
(
HelperThread
*
helperThread
const
char
*
label
JS
:
:
ProfilingCategoryPair
categoryPair
)
;
~
AutoProfilerLabel
(
)
;
private
:
ProfilingStack
*
profilingStack
;
}
;
}
;
}
InternalThreadPool
*
InternalThreadPool
:
:
Instance
=
nullptr
;
InternalThreadPool
&
InternalThreadPool
:
:
Get
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
*
Instance
;
}
bool
InternalThreadPool
:
:
Initialize
(
size_t
threadCount
AutoLockHelperThreadState
&
lock
)
{
if
(
IsInitialized
(
)
)
{
return
true
;
}
auto
instance
=
MakeUnique
<
InternalThreadPool
>
(
)
;
if
(
!
instance
)
{
return
false
;
}
if
(
!
instance
-
>
ensureThreadCount
(
threadCount
lock
)
)
{
instance
-
>
shutDown
(
lock
)
;
return
false
;
}
Instance
=
instance
.
release
(
)
;
HelperThreadState
(
)
.
setDispatchTaskCallback
(
DispatchTask
threadCount
HELPER_STACK_SIZE
lock
)
;
return
true
;
}
bool
InternalThreadPool
:
:
ensureThreadCount
(
size_t
threadCount
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
threads
(
lock
)
.
length
(
)
<
threadCount
)
;
if
(
!
threads
(
lock
)
.
reserve
(
threadCount
)
)
{
return
false
;
}
while
(
threads
(
lock
)
.
length
(
)
<
threadCount
)
{
auto
thread
=
js
:
:
MakeUnique
<
HelperThread
>
(
)
;
if
(
!
thread
|
|
!
thread
-
>
init
(
this
)
)
{
return
false
;
}
threads
(
lock
)
.
infallibleEmplaceBack
(
std
:
:
move
(
thread
)
)
;
}
return
tasks_
.
ref
(
)
.
reserve
(
threadCount
)
;
}
size_t
InternalThreadPool
:
:
threadCount
(
const
AutoLockHelperThreadState
&
lock
)
{
return
threads
(
lock
)
.
length
(
)
;
}
void
InternalThreadPool
:
:
ShutDown
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
HelperThreadState
(
)
.
isTerminating
(
lock
)
)
;
Get
(
)
.
shutDown
(
lock
)
;
js_delete
(
Instance
)
;
Instance
=
nullptr
;
}
void
InternalThreadPool
:
:
shutDown
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
terminating
)
;
terminating
=
true
;
notifyAll
(
lock
)
;
for
(
auto
&
thread
:
threads
(
lock
)
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
thread
-
>
join
(
)
;
}
}
inline
HelperThreadVector
&
InternalThreadPool
:
:
threads
(
const
AutoLockHelperThreadState
&
lock
)
{
return
threads_
.
ref
(
)
;
}
inline
const
HelperThreadVector
&
InternalThreadPool
:
:
threads
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
threads_
.
ref
(
)
;
}
inline
HelperTaskVector
&
InternalThreadPool
:
:
tasks
(
const
AutoLockHelperThreadState
&
lock
)
{
return
tasks_
.
ref
(
)
;
}
size_t
InternalThreadPool
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
const
AutoLockHelperThreadState
&
lock
)
const
{
return
sizeof
(
InternalThreadPool
)
+
threads
(
lock
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
InternalThreadPool
:
:
DispatchTask
(
HelperThreadTask
*
task
JS
:
:
DispatchReason
reason
)
{
Get
(
)
.
dispatchTask
(
task
reason
)
;
}
void
InternalThreadPool
:
:
dispatchTask
(
HelperThreadTask
*
task
JS
:
:
DispatchReason
reason
)
{
gHelperThreadLock
.
assertOwnedByCurrentThread
(
)
;
tasks_
.
ref
(
)
.
infallibleAppend
(
task
)
;
if
(
reason
=
=
JS
:
:
DispatchReason
:
:
NewTask
)
{
wakeup
.
notify_one
(
)
;
}
else
{
MOZ_ASSERT
(
reason
=
=
JS
:
:
DispatchReason
:
:
FinishedTask
)
;
MOZ_ASSERT
(
!
TlsContext
.
get
(
)
"
we
should
be
on
a
helper
thread
"
)
;
}
}
void
InternalThreadPool
:
:
notifyAll
(
const
AutoLockHelperThreadState
&
lock
)
{
wakeup
.
notify_all
(
)
;
}
void
InternalThreadPool
:
:
wait
(
AutoLockHelperThreadState
&
lock
)
{
wakeup
.
wait_for
(
lock
mozilla
:
:
TimeDuration
:
:
Forever
(
)
)
;
}
HelperThread
:
:
HelperThread
(
)
:
thread
(
Thread
:
:
Options
(
)
.
setStackSize
(
HELPER_STACK_SIZE
)
)
{
}
bool
HelperThread
:
:
init
(
InternalThreadPool
*
pool
)
{
return
thread
.
init
(
HelperThread
:
:
ThreadMain
pool
this
)
;
}
void
HelperThread
:
:
join
(
)
{
thread
.
join
(
)
;
}
void
HelperThread
:
:
ThreadMain
(
InternalThreadPool
*
pool
HelperThread
*
helper
)
{
ThisThread
:
:
SetName
(
"
JS
Helper
"
)
;
helper
-
>
ensureRegisteredWithProfiler
(
)
;
helper
-
>
threadLoop
(
pool
)
;
helper
-
>
unregisterWithProfilerIfNeeded
(
)
;
}
void
HelperThread
:
:
ensureRegisteredWithProfiler
(
)
{
if
(
profilingStack
)
{
return
;
}
JS
:
:
RegisterThreadCallback
callback
=
HelperThreadState
(
)
.
registerThread
;
if
(
callback
)
{
profilingStack
=
callback
(
"
JS
Helper
"
reinterpret_cast
<
void
*
>
(
GetNativeStackBase
(
)
)
)
;
}
}
void
HelperThread
:
:
unregisterWithProfilerIfNeeded
(
)
{
if
(
!
profilingStack
)
{
return
;
}
JS
:
:
UnregisterThreadCallback
callback
=
HelperThreadState
(
)
.
unregisterThread
;
if
(
callback
)
{
callback
(
)
;
profilingStack
=
nullptr
;
}
}
HelperThread
:
:
AutoProfilerLabel
:
:
AutoProfilerLabel
(
HelperThread
*
helperThread
const
char
*
label
JS
:
:
ProfilingCategoryPair
categoryPair
)
:
profilingStack
(
helperThread
-
>
profilingStack
)
{
if
(
profilingStack
)
{
profilingStack
-
>
pushLabelFrame
(
label
nullptr
this
categoryPair
)
;
}
}
HelperThread
:
:
AutoProfilerLabel
:
:
~
AutoProfilerLabel
(
)
{
if
(
profilingStack
)
{
profilingStack
-
>
pop
(
)
;
}
}
void
HelperThread
:
:
threadLoop
(
InternalThreadPool
*
pool
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
AutoLockHelperThreadState
lock
;
while
(
!
pool
-
>
terminating
)
{
HelperTaskVector
&
tasks
=
pool
-
>
tasks
(
lock
)
;
if
(
!
tasks
.
empty
(
)
)
{
HelperThreadTask
*
*
taskp
=
tasks
.
begin
(
)
;
HelperThreadTask
*
task
=
*
taskp
;
tasks
.
erase
(
taskp
)
;
HelperThreadState
(
)
.
runOneTask
(
task
lock
)
;
continue
;
}
AUTO_PROFILER_LABEL
(
"
HelperThread
:
:
threadLoop
:
:
wait
"
IDLE
)
;
pool
-
>
wait
(
lock
)
;
}
}
