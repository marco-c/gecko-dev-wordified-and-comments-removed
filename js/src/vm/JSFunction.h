#
ifndef
vm_JSFunction_h
#
define
vm_JSFunction_h
#
include
"
jstypes
.
h
"
#
include
"
js
/
shadow
/
Function
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
FunctionPrefixKind
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
class
JSJitInfo
;
namespace
js
{
class
FunctionExtended
;
struct
SelfHostedLazyScript
;
using
Native
=
JSNative
;
static
constexpr
uint32_t
BoundFunctionEnvTargetSlot
=
2
;
static
constexpr
uint32_t
BoundFunctionEnvThisSlot
=
3
;
static
constexpr
uint32_t
BoundFunctionEnvArgsSlot
=
4
;
static
const
char
FunctionConstructorMedialSigils
[
]
=
"
)
{
\
n
"
;
static
const
char
FunctionConstructorFinalBrace
[
]
=
"
\
n
}
"
;
}
class
JSFunction
:
public
js
:
:
NativeObject
{
public
:
static
const
JSClass
class_
;
private
:
uint16_t
nargs_
;
using
FunctionFlags
=
js
:
:
FunctionFlags
;
FunctionFlags
flags_
;
union
U
{
class
{
friend
class
JSFunction
;
js
:
:
Native
func_
;
union
{
const
JSJitInfo
*
jitInfo_
;
uintptr_t
taggedWasmFuncIndex_
;
void
*
*
wasmJitEntry_
;
}
extra
;
}
native
;
struct
{
JSObject
*
env_
;
union
{
js
:
:
BaseScript
*
script_
;
js
:
:
SelfHostedLazyScript
*
selfHostedLazy_
;
}
s
;
}
scripted
;
}
u
;
js
:
:
GCPtrAtom
atom_
;
public
:
static
inline
JS
:
:
Result
<
JSFunction
*
JS
:
:
OOM
>
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
js
:
:
HandleObjectGroup
group
)
;
bool
needsCallObject
(
)
const
{
if
(
isNative
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
hasBytecode
(
)
)
;
MOZ_ASSERT_IF
(
baseScript
(
)
-
>
funHasExtensibleScope
(
)
|
|
isGenerator
(
)
|
|
isAsync
(
)
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
)
;
return
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
;
}
bool
needsExtraBodyVarEnvironment
(
)
const
;
bool
needsNamedLambdaEnvironment
(
)
const
;
bool
needsFunctionEnvironmentObjects
(
)
const
{
bool
res
=
nonLazyScript
(
)
-
>
needsFunctionEnvironmentObjects
(
)
;
MOZ_ASSERT
(
res
=
=
(
needsCallObject
(
)
|
|
needsNamedLambdaEnvironment
(
)
)
)
;
return
res
;
}
bool
needsSomeEnvironmentObject
(
)
const
{
return
needsFunctionEnvironmentObjects
(
)
|
|
needsExtraBodyVarEnvironment
(
)
;
}
static
constexpr
size_t
NArgsBits
=
sizeof
(
nargs_
)
*
CHAR_BIT
;
size_t
nargs
(
)
const
{
return
nargs_
;
}
FunctionFlags
flags
(
)
{
return
flags_
;
}
FunctionFlags
:
:
FunctionKind
kind
(
)
const
{
return
flags_
.
kind
(
)
;
}
bool
isInterpreted
(
)
const
{
return
flags_
.
isInterpreted
(
)
;
}
bool
isNative
(
)
const
{
return
flags_
.
isNative
(
)
;
}
bool
isConstructor
(
)
const
{
return
flags_
.
isConstructor
(
)
;
}
bool
isNonBuiltinConstructor
(
)
const
{
return
flags_
.
isNonBuiltinConstructor
(
)
;
}
bool
isAsmJSNative
(
)
const
{
return
flags_
.
isAsmJSNative
(
)
;
}
bool
isWasm
(
)
const
{
return
flags_
.
isWasm
(
)
;
}
bool
isWasmWithJitEntry
(
)
const
{
return
flags_
.
isWasmWithJitEntry
(
)
;
}
bool
isNativeWithoutJitEntry
(
)
const
{
return
flags_
.
isNativeWithoutJitEntry
(
)
;
}
bool
isBuiltinNative
(
)
const
{
return
flags_
.
isBuiltinNative
(
)
;
}
bool
hasJitEntry
(
)
const
{
return
flags_
.
hasJitEntry
(
)
;
}
bool
isBoundFunction
(
)
const
{
return
flags_
.
isBoundFunction
(
)
;
}
bool
hasInferredName
(
)
const
{
return
flags_
.
hasInferredName
(
)
;
}
bool
hasGuessedAtom
(
)
const
{
return
flags_
.
hasGuessedAtom
(
)
;
}
bool
hasBoundFunctionNamePrefix
(
)
const
{
return
flags_
.
hasBoundFunctionNamePrefix
(
)
;
}
bool
isLambda
(
)
const
{
return
flags_
.
isLambda
(
)
;
}
bool
hasSelfHostedLazyScript
(
)
const
{
return
flags_
.
hasSelfHostedLazyScript
(
)
;
}
bool
hasBaseScript
(
)
const
{
return
flags_
.
hasBaseScript
(
)
;
}
bool
hasBytecode
(
)
const
{
MOZ_ASSERT
(
!
isIncomplete
(
)
)
;
return
hasBaseScript
(
)
&
&
baseScript
(
)
-
>
hasBytecode
(
)
;
}
bool
isArrow
(
)
const
{
return
flags_
.
isArrow
(
)
;
}
bool
isMethod
(
)
const
{
return
flags_
.
isMethod
(
)
;
}
bool
isClassConstructor
(
)
const
{
return
flags_
.
isClassConstructor
(
)
;
}
bool
isGetter
(
)
const
{
return
flags_
.
isGetter
(
)
;
}
bool
isSetter
(
)
const
{
return
flags_
.
isSetter
(
)
;
}
bool
allowSuperProperty
(
)
const
{
return
flags_
.
allowSuperProperty
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
flags_
.
hasResolvedLength
(
)
;
}
bool
hasResolvedName
(
)
const
{
return
flags_
.
hasResolvedName
(
)
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
flags_
.
isSelfHostedOrIntrinsic
(
)
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
flags_
.
isSelfHostedBuiltin
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
flags_
.
isIntrinsic
(
)
;
}
bool
hasJitScript
(
)
const
{
if
(
!
hasBaseScript
(
)
)
{
return
false
;
}
return
baseScript
(
)
-
>
hasJitScript
(
)
;
}
bool
isBuiltin
(
)
const
{
return
isBuiltinNative
(
)
|
|
isSelfHostedBuiltin
(
)
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
.
isNamedLambda
(
displayAtom
(
)
!
=
nullptr
)
;
}
bool
hasLexicalThis
(
)
const
{
return
isArrow
(
)
;
}
bool
isBuiltinFunctionConstructor
(
)
;
bool
needsPrototypeProperty
(
)
;
bool
hasNonConfigurablePrototypeDataProperty
(
)
;
bool
constructorNeedsUninitializedThis
(
)
const
{
MOZ_ASSERT
(
isConstructor
(
)
)
;
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
isBoundFunction
(
)
|
|
isDerivedClassConstructor
(
)
;
}
bool
strict
(
)
const
{
return
baseScript
(
)
-
>
strict
(
)
;
}
void
setFlags
(
uint16_t
flags
)
{
flags_
=
FunctionFlags
(
flags
)
;
}
void
setFlags
(
FunctionFlags
flags
)
{
flags_
=
flags
;
}
void
setIsConstructor
(
)
{
flags_
.
setIsConstructor
(
)
;
}
void
setIsClassConstructor
(
)
{
flags_
.
setIsClassConstructor
(
)
;
}
void
setArgCount
(
uint16_t
nargs
)
{
this
-
>
nargs_
=
nargs
;
}
void
setIsBoundFunction
(
)
{
flags_
.
setIsBoundFunction
(
)
;
}
void
setIsSelfHostedBuiltin
(
)
{
flags_
.
setIsSelfHostedBuiltin
(
)
;
}
void
setIsIntrinsic
(
)
{
flags_
.
setIsIntrinsic
(
)
;
}
void
setResolvedLength
(
)
{
flags_
.
setResolvedLength
(
)
;
}
void
setResolvedName
(
)
{
flags_
.
setResolvedName
(
)
;
}
static
bool
getUnresolvedLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleValue
v
)
;
JSAtom
*
infallibleGetUnresolvedName
(
JSContext
*
cx
)
;
static
bool
getUnresolvedName
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleValue
v
)
;
static
JSLinearString
*
getBoundFunctionName
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
JSAtom
*
explicitName
(
)
const
{
return
(
hasInferredName
(
)
|
|
hasGuessedAtom
(
)
)
?
nullptr
:
atom_
.
get
(
)
;
}
JSAtom
*
explicitOrInferredName
(
)
const
{
return
hasGuessedAtom
(
)
?
nullptr
:
atom_
.
get
(
)
;
}
void
initAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
.
init
(
atom
)
;
}
void
setAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
=
atom
;
}
JSAtom
*
displayAtom
(
)
const
{
return
atom_
;
}
void
setInferredName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
setAtom
(
atom
)
;
flags_
.
setInferredName
(
)
;
}
void
clearInferredName
(
)
{
MOZ_ASSERT
(
hasInferredName
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
setAtom
(
nullptr
)
;
flags_
.
clearInferredName
(
)
;
}
JSAtom
*
inferredName
(
)
const
{
MOZ_ASSERT
(
hasInferredName
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
return
atom_
;
}
void
setGuessedAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasInferredName
(
)
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
setAtom
(
atom
)
;
flags_
.
setGuessedAtom
(
)
;
}
void
setPrefixedBoundFunctionName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
hasBoundFunctionNamePrefix
(
)
)
;
MOZ_ASSERT
(
atom
)
;
flags_
.
setPrefixedBoundFunctionName
(
)
;
setAtom
(
atom
)
;
}
enum
{
MAX_ARGS_AND_VARS
=
2
*
(
(
1U
<
<
16
)
-
1
)
}
;
JSObject
*
environment
(
)
const
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
u
.
scripted
.
env_
;
}
void
setEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
*
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
scripted
.
env_
)
=
obj
;
}
void
initEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
scripted
.
env_
)
-
>
init
(
obj
)
;
}
public
:
static
constexpr
size_t
offsetOfNargs
(
)
{
return
offsetof
(
JSFunction
nargs_
)
;
}
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
JSFunction
flags_
)
;
}
static
size_t
offsetOfEnvironment
(
)
{
return
offsetof
(
JSFunction
u
.
scripted
.
env_
)
;
}
static
size_t
offsetOfAtom
(
)
{
return
offsetof
(
JSFunction
atom_
)
;
}
static
bool
delazifyLazilyInterpretedFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
static
bool
delazifySelfHostedLazyFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
void
maybeRelazify
(
JSRuntime
*
rt
)
;
static
JSScript
*
getOrCreateScript
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
MOZ_ASSERT
(
cx
)
;
if
(
fun
-
>
hasSelfHostedLazyScript
(
)
)
{
if
(
!
delazifySelfHostedLazyFunction
(
cx
fun
)
)
{
return
nullptr
;
}
return
fun
-
>
nonLazyScript
(
)
;
}
MOZ_ASSERT
(
fun
-
>
hasBaseScript
(
)
)
;
JS
:
:
Rooted
<
js
:
:
BaseScript
*
>
script
(
cx
fun
-
>
baseScript
(
)
)
;
if
(
!
script
-
>
hasBytecode
(
)
)
{
if
(
!
delazifyLazilyInterpretedFunction
(
cx
fun
)
)
{
return
nullptr
;
}
}
return
fun
-
>
nonLazyScript
(
)
;
}
JSFunction
*
maybeCanonicalFunction
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
function
(
)
;
}
return
nullptr
;
}
bool
isIncomplete
(
)
const
{
return
isInterpreted
(
)
&
&
!
u
.
scripted
.
s
.
script_
;
}
JSScript
*
nonLazyScript
(
)
const
{
MOZ_ASSERT
(
hasBytecode
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
script_
)
;
return
static_cast
<
JSScript
*
>
(
u
.
scripted
.
s
.
script_
)
;
}
js
:
:
SelfHostedLazyScript
*
selfHostedLazyScript
(
)
const
{
MOZ_ASSERT
(
hasSelfHostedLazyScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
selfHostedLazy_
)
;
return
u
.
scripted
.
s
.
selfHostedLazy_
;
}
js
:
:
BaseScript
*
baseScript
(
)
const
{
MOZ_ASSERT
(
hasBaseScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
script_
)
;
return
u
.
scripted
.
s
.
script_
;
}
static
bool
getLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
uint16_t
*
length
)
;
js
:
:
Scope
*
enclosingScope
(
)
const
{
return
baseScript
(
)
-
>
enclosingScope
(
)
;
}
void
setEnclosingLazyScript
(
js
:
:
BaseScript
*
enclosingScript
)
{
baseScript
(
)
-
>
setEnclosingScript
(
enclosingScript
)
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
generatorKind
(
)
;
}
if
(
hasSelfHostedLazyScript
(
)
)
{
return
clonedSelfHostedGeneratorKind
(
)
;
}
return
js
:
:
GeneratorKind
:
:
NotGenerator
;
}
js
:
:
GeneratorKind
clonedSelfHostedGeneratorKind
(
)
const
;
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
GeneratorKind
:
:
Generator
;
}
js
:
:
FunctionAsyncKind
asyncKind
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
asyncKind
(
)
;
}
return
js
:
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
isAsync
(
)
const
{
return
asyncKind
(
)
=
=
js
:
:
FunctionAsyncKind
:
:
AsyncFunction
;
}
bool
isGeneratorOrAsync
(
)
const
{
return
isGenerator
(
)
|
|
isAsync
(
)
;
}
void
initScript
(
js
:
:
BaseScript
*
script
)
{
MOZ_ASSERT_IF
(
script
realm
(
)
=
=
script
-
>
realm
(
)
)
;
MOZ_ASSERT
(
isInterpreted
(
)
)
;
u
.
scripted
.
s
.
script_
=
script
;
}
void
initSelfHostedLazyScript
(
js
:
:
SelfHostedLazyScript
*
lazy
)
{
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
MOZ_ASSERT
(
isInterpreted
(
)
)
;
flags_
.
clearBaseScript
(
)
;
flags_
.
setSelfHostedLazy
(
)
;
u
.
scripted
.
s
.
selfHostedLazy_
=
lazy
;
MOZ_ASSERT
(
hasSelfHostedLazyScript
(
)
)
;
}
void
clearSelfHostedLazyScript
(
)
{
flags_
.
clearSelfHostedLazy
(
)
;
flags_
.
setBaseScript
(
)
;
u
.
scripted
.
s
.
script_
=
nullptr
;
MOZ_ASSERT
(
isIncomplete
(
)
)
;
}
JSNative
native
(
)
const
{
MOZ_ASSERT
(
isNative
(
)
)
;
return
u
.
native
.
func_
;
}
JSNative
nativeUnchecked
(
)
const
{
return
u
.
native
.
func_
;
}
JSNative
maybeNative
(
)
const
{
return
isInterpreted
(
)
?
nullptr
:
native
(
)
;
}
void
initNative
(
js
:
:
Native
native
const
JSJitInfo
*
jitInfo
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
MOZ_ASSERT_IF
(
jitInfo
isBuiltinNative
(
)
)
;
MOZ_ASSERT
(
native
)
;
u
.
native
.
func_
=
native
;
u
.
native
.
extra
.
jitInfo_
=
jitInfo
;
}
bool
hasJitInfo
(
)
const
{
return
isBuiltinNative
(
)
&
&
u
.
native
.
extra
.
jitInfo_
;
}
const
JSJitInfo
*
jitInfo
(
)
const
{
MOZ_ASSERT
(
hasJitInfo
(
)
)
;
return
u
.
native
.
extra
.
jitInfo_
;
}
const
JSJitInfo
*
jitInfoUnchecked
(
)
const
{
return
u
.
native
.
extra
.
jitInfo_
;
}
void
setJitInfo
(
const
JSJitInfo
*
data
)
{
MOZ_ASSERT
(
isBuiltinNative
(
)
)
;
u
.
native
.
extra
.
jitInfo_
=
data
;
}
void
setWasmFuncIndex
(
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
isWasm
(
)
|
|
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
!
u
.
native
.
extra
.
taggedWasmFuncIndex_
)
;
u
.
native
.
extra
.
taggedWasmFuncIndex_
=
(
uintptr_t
(
funcIndex
)
<
<
1
)
|
1
;
}
uint32_t
wasmFuncIndex
(
)
const
{
MOZ_ASSERT
(
isWasm
(
)
|
|
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
u
.
native
.
extra
.
taggedWasmFuncIndex_
&
1
)
;
return
u
.
native
.
extra
.
taggedWasmFuncIndex_
>
>
1
;
}
void
setWasmJitEntry
(
void
*
*
entry
)
{
MOZ_ASSERT
(
*
entry
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
flags_
.
setWasmJitEntry
(
)
;
u
.
native
.
extra
.
wasmJitEntry_
=
entry
;
MOZ_ASSERT
(
isWasmWithJitEntry
(
)
)
;
}
void
*
*
wasmJitEntry
(
)
const
{
MOZ_ASSERT
(
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
u
.
native
.
extra
.
wasmJitEntry_
)
;
return
u
.
native
.
extra
.
wasmJitEntry_
;
}
bool
isDerivedClassConstructor
(
)
const
;
bool
isFieldInitializer
(
)
const
;
static
unsigned
offsetOfNative
(
)
{
return
offsetof
(
JSFunction
u
.
native
.
func_
)
;
}
static
unsigned
offsetOfScript
(
)
{
static_assert
(
offsetof
(
U
scripted
.
s
.
script_
)
=
=
offsetof
(
U
native
.
extra
.
wasmJitEntry_
)
"
scripted
.
s
.
script_
must
be
at
the
same
offset
as
"
"
native
.
extra
.
wasmJitEntry_
"
)
;
return
offsetof
(
JSFunction
u
.
scripted
.
s
.
script_
)
;
}
static
unsigned
offsetOfNativeOrEnv
(
)
{
static_assert
(
offsetof
(
U
native
.
func_
)
=
=
offsetof
(
U
scripted
.
env_
)
"
U
.
native
.
func_
must
be
at
the
same
offset
as
U
.
scripted
.
env_
"
)
;
return
offsetOfNative
(
)
;
}
static
unsigned
offsetOfBaseScript
(
)
{
return
offsetof
(
JSFunction
u
.
scripted
.
s
.
script_
)
;
}
static
unsigned
offsetOfJitInfo
(
)
{
return
offsetof
(
JSFunction
u
.
native
.
extra
.
jitInfo_
)
;
}
inline
void
trace
(
JSTracer
*
trc
)
;
JSObject
*
getBoundFunctionTarget
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionThis
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionArgument
(
unsigned
which
)
const
;
size_t
getBoundFunctionArgumentCount
(
)
const
;
static
bool
finishBoundFunctionInit
(
JSContext
*
cx
js
:
:
HandleFunction
bound
js
:
:
HandleObject
targetObj
int32_t
argCount
)
;
private
:
inline
js
:
:
FunctionExtended
*
toExtended
(
)
;
inline
const
js
:
:
FunctionExtended
*
toExtended
(
)
const
;
public
:
inline
bool
isExtended
(
)
const
{
bool
extended
=
flags_
.
isExtended
(
)
;
MOZ_ASSERT_IF
(
isTenured
(
)
extended
=
=
(
asTenured
(
)
.
getAllocKind
(
)
=
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
return
extended
;
}
inline
void
initializeExtended
(
)
;
inline
void
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
void
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
const
js
:
:
Value
&
getExtendedSlot
(
size_t
which
)
const
;
inline
js
:
:
FunctionExtended
*
toExtendedOffMainThread
(
)
;
inline
const
js
:
:
FunctionExtended
*
toExtendedOffMainThread
(
)
const
;
inline
const
js
:
:
Value
&
getExtendedSlotOffMainThread
(
size_t
which
)
const
;
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
static_assert
(
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
!
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
"
extended
/
non
-
extended
AllocKinds
have
to
be
different
"
"
for
getAllocKind
(
)
to
have
a
reason
to
exist
"
)
;
js
:
:
gc
:
:
AllocKind
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
;
if
(
isExtended
(
)
)
{
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
}
MOZ_ASSERT_IF
(
isTenured
(
)
kind
=
=
asTenured
(
)
.
getAllocKind
(
)
)
;
return
kind
;
}
}
;
static_assert
(
sizeof
(
JSFunction
)
=
=
sizeof
(
JS
:
:
shadow
:
:
Function
)
"
shadow
interface
must
match
actual
interface
"
)
;
extern
JSString
*
fun_toStringHelper
(
JSContext
*
cx
js
:
:
HandleObject
obj
bool
isToSource
)
;
namespace
js
{
extern
bool
Function
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
Generator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncFunctionConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncGeneratorConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
JSFunction
*
NewFunctionWithProto
(
JSContext
*
cx
JSNative
native
unsigned
nargs
FunctionFlags
flags
HandleObject
enclosingEnv
HandleAtom
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
)
;
inline
JSFunction
*
NewNativeFunction
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
FunctionFlags
flags
=
FunctionFlags
:
:
NATIVE_FUN
)
{
MOZ_ASSERT
(
native
)
;
return
NewFunctionWithProto
(
cx
native
nargs
flags
nullptr
atom
nullptr
allocKind
newKind
)
;
}
inline
JSFunction
*
NewNativeConstructor
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
FunctionFlags
flags
=
FunctionFlags
:
:
NATIVE_CTOR
)
{
MOZ_ASSERT
(
native
)
;
MOZ_ASSERT
(
flags
.
isNativeConstructor
(
)
)
;
return
NewFunctionWithProto
(
cx
native
nargs
flags
nullptr
atom
nullptr
allocKind
newKind
)
;
}
extern
JSFunction
*
NewScriptedFunction
(
JSContext
*
cx
unsigned
nargs
FunctionFlags
flags
HandleAtom
atom
HandleObject
proto
=
nullptr
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
HandleObject
enclosingEnv
=
nullptr
)
;
extern
bool
GetFunctionPrototype
(
JSContext
*
cx
js
:
:
GeneratorKind
generatorKind
js
:
:
FunctionAsyncKind
asyncKind
js
:
:
MutableHandleObject
proto
)
;
extern
JSAtom
*
IdToFunctionName
(
JSContext
*
cx
HandleId
id
FunctionPrefixKind
prefixKind
=
FunctionPrefixKind
:
:
None
)
;
extern
bool
SetFunctionName
(
JSContext
*
cx
HandleFunction
fun
HandleValue
name
FunctionPrefixKind
prefixKind
)
;
extern
JSFunction
*
DefineFunction
(
JSContext
*
cx
HandleObject
obj
HandleId
id
JSNative
native
unsigned
nargs
unsigned
flags
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
)
;
extern
bool
fun_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
struct
WellKnownSymbols
;
extern
bool
FunctionHasDefaultHasInstance
(
JSFunction
*
fun
const
WellKnownSymbols
&
symbols
)
;
extern
void
ThrowTypeErrorBehavior
(
JSContext
*
cx
)
;
class
FunctionExtended
:
public
JSFunction
{
public
:
static
const
unsigned
NUM_EXTENDED_SLOTS
=
2
;
static
const
unsigned
ARROW_NEWTARGET_SLOT
=
0
;
static
const
unsigned
METHOD_HOMEOBJECT_SLOT
=
0
;
static
const
unsigned
BOUND_FUNCTION_LENGTH_SLOT
=
1
;
static
const
unsigned
WASM_INSTANCE_SLOT
=
0
;
static
const
unsigned
WASM_TLSDATA_SLOT
=
1
;
static
const
unsigned
ASMJS_MODULE_SLOT
=
0
;
static
inline
size_t
offsetOfExtendedSlot
(
unsigned
which
)
{
MOZ_ASSERT
(
which
<
NUM_EXTENDED_SLOTS
)
;
return
offsetof
(
FunctionExtended
extendedSlots
)
+
which
*
sizeof
(
GCPtrValue
)
;
}
static
inline
size_t
offsetOfArrowNewTargetSlot
(
)
{
return
offsetOfExtendedSlot
(
ARROW_NEWTARGET_SLOT
)
;
}
static
inline
size_t
offsetOfMethodHomeObjectSlot
(
)
{
return
offsetOfExtendedSlot
(
METHOD_HOMEOBJECT_SLOT
)
;
}
static
inline
size_t
offsetOfBoundFunctionLengthSlot
(
)
{
return
offsetOfExtendedSlot
(
BOUND_FUNCTION_LENGTH_SLOT
)
;
}
private
:
friend
class
JSFunction
;
GCPtrValue
extendedSlots
[
NUM_EXTENDED_SLOTS
]
;
}
;
extern
bool
CanReuseScriptForClone
(
JS
:
:
Realm
*
realm
HandleFunction
fun
HandleObject
newEnclosingEnv
)
;
extern
JSFunction
*
CloneFunctionReuseScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
gc
:
:
AllocKind
kind
HandleObject
proto
)
;
extern
JSFunction
*
CloneFunctionAndScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
HandleScope
newScope
Handle
<
ScriptSourceObject
*
>
sourceObject
gc
:
:
AllocKind
kind
HandleObject
proto
=
nullptr
)
;
extern
JSFunction
*
CloneAsmJSModuleFunction
(
JSContext
*
cx
HandleFunction
fun
)
;
extern
JSFunction
*
CloneSelfHostingIntrinsic
(
JSContext
*
cx
HandleFunction
fun
)
;
extern
bool
SetPrototypeForClonedFunction
(
JSContext
*
cx
HandleFunction
fun
HandleObject
proto
)
;
}
inline
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
const
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
const
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
const
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtendedOffMainThread
(
)
{
return
static_cast
<
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
const
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtendedOffMainThread
(
)
const
{
return
static_cast
<
const
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
void
JSFunction
:
:
initializeExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
MOZ_ASSERT
(
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
=
=
2
)
;
toExtended
(
)
-
>
extendedSlots
[
0
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
toExtended
(
)
-
>
extendedSlots
[
1
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
}
inline
void
JSFunction
:
:
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
.
init
(
val
)
;
}
inline
void
JSFunction
:
:
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
=
val
;
}
inline
const
js
:
:
Value
&
JSFunction
:
:
getExtendedSlot
(
size_t
which
)
const
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
return
toExtended
(
)
-
>
extendedSlots
[
which
]
;
}
inline
const
js
:
:
Value
&
JSFunction
:
:
getExtendedSlotOffMainThread
(
size_t
which
)
const
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtendedOffMainThread
(
)
-
>
extendedSlots
)
)
;
return
toExtendedOffMainThread
(
)
-
>
extendedSlots
[
which
]
;
}
namespace
js
{
JSString
*
FunctionToString
(
JSContext
*
cx
HandleFunction
fun
bool
isToSource
)
;
template
<
XDRMode
mode
>
XDRResult
XDRInterpretedFunction
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
MutableHandleFunction
objp
)
;
extern
void
ReportIncompatibleMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
JSClass
*
clasp
)
;
extern
void
ReportIncompatible
(
JSContext
*
cx
const
CallArgs
&
args
)
;
extern
bool
fun_apply
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
fun_call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
#
ifdef
DEBUG
namespace
JS
{
namespace
detail
{
JS_PUBLIC_API
void
CheckIsValidConstructible
(
const
Value
&
calleev
)
;
}
}
#
endif
#
endif
