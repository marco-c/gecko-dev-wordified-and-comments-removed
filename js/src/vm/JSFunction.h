#
ifndef
vm_JSFunction_h
#
define
vm_JSFunction_h
#
include
"
jstypes
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
class
FunctionExtended
;
struct
SelfHostedLazyScript
;
using
Native
=
JSNative
;
}
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_TARGET
=
2
;
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_THIS
=
3
;
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_ARGS
=
4
;
static
const
char
FunctionConstructorMedialSigils
[
]
=
"
)
{
\
n
"
;
static
const
char
FunctionConstructorFinalBrace
[
]
=
"
\
n
}
"
;
enum
class
FunctionPrefixKind
{
None
Get
Set
}
;
class
FunctionFlags
{
public
:
enum
FunctionKind
{
NormalFunction
=
0
Arrow
Method
ClassConstructor
Getter
Setter
AsmJS
Wasm
FunctionKindLimit
}
;
enum
Flags
:
uint16_t
{
FUNCTION_KIND_SHIFT
=
0
FUNCTION_KIND_MASK
=
0x0007
EXTENDED
=
1
<
<
3
SELF_HOSTED
=
1
<
<
4
BASESCRIPT
=
1
<
<
5
SELFHOSTLAZY
=
1
<
<
6
CONSTRUCTOR
=
1
<
<
7
BOUND_FUN
=
1
<
<
8
LAMBDA
=
1
<
<
9
WASM_JIT_ENTRY
=
1
<
<
10
HAS_INFERRED_NAME
=
1
<
<
11
ATOM_EXTRA_FLAG
=
1
<
<
12
HAS_GUESSED_ATOM
=
ATOM_EXTRA_FLAG
HAS_BOUND_FUNCTION_NAME_PREFIX
=
ATOM_EXTRA_FLAG
RESOLVED_NAME
=
1
<
<
13
RESOLVED_LENGTH
=
1
<
<
14
NEW_SCRIPT_CLEARED
=
1
<
<
15
NORMAL_KIND
=
NormalFunction
<
<
FUNCTION_KIND_SHIFT
ASMJS_KIND
=
AsmJS
<
<
FUNCTION_KIND_SHIFT
WASM_KIND
=
Wasm
<
<
FUNCTION_KIND_SHIFT
ARROW_KIND
=
Arrow
<
<
FUNCTION_KIND_SHIFT
METHOD_KIND
=
Method
<
<
FUNCTION_KIND_SHIFT
CLASSCONSTRUCTOR_KIND
=
ClassConstructor
<
<
FUNCTION_KIND_SHIFT
GETTER_KIND
=
Getter
<
<
FUNCTION_KIND_SHIFT
SETTER_KIND
=
Setter
<
<
FUNCTION_KIND_SHIFT
NATIVE_FUN
=
NORMAL_KIND
NATIVE_CTOR
=
CONSTRUCTOR
|
NORMAL_KIND
ASMJS_CTOR
=
CONSTRUCTOR
|
ASMJS_KIND
ASMJS_LAMBDA_CTOR
=
CONSTRUCTOR
|
LAMBDA
|
ASMJS_KIND
WASM
=
WASM_KIND
INTERPRETED_NORMAL
=
BASESCRIPT
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_CLASS_CTOR
=
BASESCRIPT
|
CONSTRUCTOR
|
CLASSCONSTRUCTOR_KIND
INTERPRETED_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
NORMAL_KIND
INTERPRETED_LAMBDA
=
BASESCRIPT
|
LAMBDA
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_LAMBDA_ARROW
=
BASESCRIPT
|
LAMBDA
|
ARROW_KIND
INTERPRETED_LAMBDA_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
LAMBDA
|
NORMAL_KIND
INTERPRETED_GETTER
=
BASESCRIPT
|
GETTER_KIND
INTERPRETED_SETTER
=
BASESCRIPT
|
SETTER_KIND
INTERPRETED_METHOD
=
BASESCRIPT
|
METHOD_KIND
MUTABLE_FLAGS
=
RESOLVED_NAME
|
RESOLVED_LENGTH
|
NEW_SCRIPT_CLEARED
STABLE_ACROSS_CLONES
=
CONSTRUCTOR
|
LAMBDA
|
SELF_HOSTED
|
FUNCTION_KIND_MASK
}
;
uint16_t
flags_
;
public
:
FunctionFlags
(
)
:
flags_
(
)
{
static_assert
(
sizeof
(
FunctionFlags
)
=
=
sizeof
(
flags_
)
"
No
extra
members
allowed
is
it
'
ll
grow
JSFunction
"
)
;
static_assert
(
offsetof
(
FunctionFlags
flags_
)
=
=
0
"
Required
for
JIT
flag
access
"
)
;
}
explicit
FunctionFlags
(
uint16_t
flags
)
:
flags_
(
flags
)
{
}
MOZ_IMPLICIT
FunctionFlags
(
Flags
f
)
:
flags_
(
f
)
{
}
static_assert
(
(
BASESCRIPT
|
SELFHOSTLAZY
)
=
=
js
:
:
JS_FUNCTION_INTERPRETED_BITS
"
jsfriendapi
.
h
'
s
FunctionFlags
:
:
INTERPRETED
-
alike
is
wrong
"
)
;
static_assert
(
(
(
FunctionKindLimit
-
1
)
<
<
FUNCTION_KIND_SHIFT
)
<
=
FUNCTION_KIND_MASK
"
FunctionKind
doesn
'
t
fit
into
flags_
"
)
;
uint16_t
toRaw
(
)
const
{
return
flags_
;
}
bool
hasFlags
(
uint16_t
flags
)
const
{
return
flags_
&
flags
;
}
void
setFlags
(
uint16_t
flags
)
{
flags_
|
=
flags
;
}
void
clearFlags
(
uint16_t
flags
)
{
flags_
&
=
~
flags
;
}
void
setFlags
(
uint16_t
flags
bool
set
)
{
if
(
set
)
{
setFlags
(
flags
)
;
}
else
{
clearFlags
(
flags
)
;
}
}
FunctionKind
kind
(
)
const
{
return
static_cast
<
FunctionKind
>
(
(
flags_
&
FUNCTION_KIND_MASK
)
>
>
FUNCTION_KIND_SHIFT
)
;
}
bool
isInterpreted
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isNative
(
)
const
{
return
!
isInterpreted
(
)
;
}
bool
isConstructor
(
)
const
{
return
hasFlags
(
CONSTRUCTOR
)
;
}
bool
isAsmJSNative
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
AsmJS
isNative
(
)
)
;
return
kind
(
)
=
=
AsmJS
;
}
bool
isWasm
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
Wasm
isNative
(
)
)
;
return
kind
(
)
=
=
Wasm
;
}
bool
isWasmWithJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
hasFlags
(
WASM_JIT_ENTRY
)
isWasm
(
)
)
;
return
hasFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isNativeWithJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
isWasmWithJitEntry
(
)
isNative
(
)
)
;
return
isWasmWithJitEntry
(
)
;
}
bool
isBuiltinNative
(
)
const
{
return
isNative
(
)
&
&
!
isAsmJSNative
(
)
&
&
!
isWasm
(
)
;
}
bool
isBoundFunction
(
)
const
{
return
hasFlags
(
BOUND_FUN
)
;
}
bool
hasInferredName
(
)
const
{
return
hasFlags
(
HAS_INFERRED_NAME
)
;
}
bool
hasGuessedAtom
(
)
const
{
static_assert
(
HAS_GUESSED_ATOM
=
=
HAS_BOUND_FUNCTION_NAME_PREFIX
"
HAS_GUESSED_ATOM
is
unused
for
bound
functions
"
)
;
bool
hasGuessedAtom
=
hasFlags
(
HAS_GUESSED_ATOM
)
;
bool
boundFun
=
hasFlags
(
BOUND_FUN
)
;
return
hasGuessedAtom
&
&
!
boundFun
;
}
bool
hasBoundFunctionNamePrefix
(
)
const
{
static_assert
(
HAS_BOUND_FUNCTION_NAME_PREFIX
=
=
HAS_GUESSED_ATOM
"
HAS_BOUND_FUNCTION_NAME_PREFIX
is
only
used
for
bound
functions
"
)
;
MOZ_ASSERT
(
isBoundFunction
(
)
)
;
return
hasFlags
(
HAS_BOUND_FUNCTION_NAME_PREFIX
)
;
}
bool
isLambda
(
)
const
{
return
hasFlags
(
LAMBDA
)
;
}
bool
isNamedLambda
(
JSAtom
*
atom
)
const
{
return
isLambda
(
)
&
&
atom
&
&
!
hasInferredName
(
)
&
&
!
hasGuessedAtom
(
)
;
}
bool
hasBaseScript
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
;
}
bool
hasSelfHostedLazyScript
(
)
const
{
return
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isArrow
(
)
const
{
return
kind
(
)
=
=
Arrow
;
}
bool
isMethod
(
)
const
{
return
kind
(
)
=
=
Method
|
|
kind
(
)
=
=
ClassConstructor
;
}
bool
isClassConstructor
(
)
const
{
return
kind
(
)
=
=
ClassConstructor
;
}
bool
isGetter
(
)
const
{
return
kind
(
)
=
=
Getter
;
}
bool
isSetter
(
)
const
{
return
kind
(
)
=
=
Setter
;
}
bool
allowSuperProperty
(
)
const
{
return
isMethod
(
)
|
|
isGetter
(
)
|
|
isSetter
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
hasFlags
(
RESOLVED_LENGTH
)
;
}
bool
hasResolvedName
(
)
const
{
return
hasFlags
(
RESOLVED_NAME
)
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
hasFlags
(
SELF_HOSTED
)
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
!
isNative
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
isNative
(
)
;
}
void
setKind
(
FunctionKind
kind
)
{
this
-
>
flags_
&
=
~
FUNCTION_KIND_MASK
;
this
-
>
flags_
|
=
static_cast
<
uint16_t
>
(
kind
)
<
<
FUNCTION_KIND_SHIFT
;
}
void
setIsConstructor
(
)
{
MOZ_ASSERT
(
!
isConstructor
(
)
)
;
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
setFlags
(
CONSTRUCTOR
)
;
}
void
setIsClassConstructor
(
)
{
MOZ_ASSERT
(
!
isClassConstructor
(
)
)
;
MOZ_ASSERT
(
isConstructor
(
)
)
;
setKind
(
ClassConstructor
)
;
}
void
clearIsSelfHosted
(
)
{
clearFlags
(
SELF_HOSTED
)
;
}
void
setIsBoundFunction
(
)
{
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
setFlags
(
BOUND_FUN
)
;
}
void
setIsSelfHostedBuiltin
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
MOZ_ASSERT
(
!
isSelfHostedBuiltin
(
)
)
;
setFlags
(
SELF_HOSTED
)
;
clearFlags
(
CONSTRUCTOR
)
;
}
void
setIsIntrinsic
(
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
MOZ_ASSERT
(
!
isIntrinsic
(
)
)
;
setFlags
(
SELF_HOSTED
)
;
}
void
setResolvedLength
(
)
{
setFlags
(
RESOLVED_LENGTH
)
;
}
void
setResolvedName
(
)
{
setFlags
(
RESOLVED_NAME
)
;
}
bool
wasNewScriptCleared
(
)
const
{
return
hasFlags
(
NEW_SCRIPT_CLEARED
)
;
}
void
setNewScriptCleared
(
)
{
setFlags
(
NEW_SCRIPT_CLEARED
)
;
}
void
setInferredName
(
)
{
setFlags
(
HAS_INFERRED_NAME
)
;
}
void
clearInferredName
(
)
{
clearFlags
(
HAS_INFERRED_NAME
)
;
}
void
setGuessedAtom
(
)
{
setFlags
(
HAS_GUESSED_ATOM
)
;
}
void
setPrefixedBoundFunctionName
(
)
{
setFlags
(
HAS_BOUND_FUNCTION_NAME_PREFIX
)
;
}
void
setSelfHostedLazy
(
)
{
setFlags
(
SELFHOSTLAZY
)
;
}
void
clearSelfHostedLazy
(
)
{
clearFlags
(
SELFHOSTLAZY
)
;
}
void
setBaseScript
(
)
{
setFlags
(
BASESCRIPT
)
;
}
void
clearBaseScript
(
)
{
clearFlags
(
BASESCRIPT
)
;
}
void
setWasmJitEntry
(
)
{
setFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isExtended
(
)
const
{
return
hasFlags
(
EXTENDED
)
;
}
void
setIsExtended
(
)
{
setFlags
(
EXTENDED
)
;
}
bool
isNativeConstructor
(
)
const
{
return
hasFlags
(
NATIVE_CTOR
)
;
}
}
;
class
JSFunction
:
public
js
:
:
NativeObject
{
public
:
static
const
JSClass
class_
;
private
:
uint16_t
nargs_
;
FunctionFlags
flags_
;
union
U
{
class
{
friend
class
JSFunction
;
js
:
:
Native
func_
;
union
{
const
JSJitInfo
*
jitInfo_
;
size_t
wasmFuncIndex_
;
void
*
*
wasmJitEntry_
;
}
extra
;
}
native
;
struct
{
JSObject
*
env_
;
union
{
js
:
:
BaseScript
*
script_
;
js
:
:
SelfHostedLazyScript
*
selfHostedLazy_
;
}
s
;
}
scripted
;
}
u
;
js
:
:
GCPtrAtom
atom_
;
public
:
static
inline
JS
:
:
Result
<
JSFunction
*
JS
:
:
OOM
&
>
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
js
:
:
HandleObjectGroup
group
)
;
bool
needsCallObject
(
)
const
{
if
(
isNative
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
hasBytecode
(
)
)
;
MOZ_ASSERT_IF
(
baseScript
(
)
-
>
funHasExtensibleScope
(
)
|
|
isGenerator
(
)
|
|
isAsync
(
)
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
)
;
return
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
;
}
bool
needsExtraBodyVarEnvironment
(
)
const
;
bool
needsNamedLambdaEnvironment
(
)
const
;
bool
needsFunctionEnvironmentObjects
(
)
const
{
bool
res
=
nonLazyScript
(
)
-
>
needsFunctionEnvironmentObjects
(
)
;
MOZ_ASSERT
(
res
=
=
(
needsCallObject
(
)
|
|
needsNamedLambdaEnvironment
(
)
)
)
;
return
res
;
}
bool
needsSomeEnvironmentObject
(
)
const
{
return
needsFunctionEnvironmentObjects
(
)
|
|
needsExtraBodyVarEnvironment
(
)
;
}
static
constexpr
size_t
NArgsBits
=
sizeof
(
nargs_
)
*
CHAR_BIT
;
size_t
nargs
(
)
const
{
return
nargs_
;
}
FunctionFlags
flags
(
)
{
return
flags_
;
}
FunctionFlags
:
:
FunctionKind
kind
(
)
const
{
return
flags_
.
kind
(
)
;
}
bool
isInterpreted
(
)
const
{
return
flags_
.
isInterpreted
(
)
;
}
bool
isNative
(
)
const
{
return
flags_
.
isNative
(
)
;
}
bool
isConstructor
(
)
const
{
return
flags_
.
isConstructor
(
)
;
}
bool
isAsmJSNative
(
)
const
{
return
flags_
.
isAsmJSNative
(
)
;
}
bool
isWasm
(
)
const
{
return
flags_
.
isWasm
(
)
;
}
bool
isWasmWithJitEntry
(
)
const
{
return
flags_
.
isWasmWithJitEntry
(
)
;
}
bool
isNativeWithJitEntry
(
)
const
{
return
flags_
.
isNativeWithJitEntry
(
)
;
}
bool
isBuiltinNative
(
)
const
{
return
flags_
.
isBuiltinNative
(
)
;
}
bool
isBoundFunction
(
)
const
{
return
flags_
.
isBoundFunction
(
)
;
}
bool
hasInferredName
(
)
const
{
return
flags_
.
hasInferredName
(
)
;
}
bool
hasGuessedAtom
(
)
const
{
return
flags_
.
hasGuessedAtom
(
)
;
}
bool
hasBoundFunctionNamePrefix
(
)
const
{
return
flags_
.
hasBoundFunctionNamePrefix
(
)
;
}
bool
isLambda
(
)
const
{
return
flags_
.
isLambda
(
)
;
}
bool
hasSelfHostedLazyScript
(
)
const
{
return
flags_
.
hasSelfHostedLazyScript
(
)
;
}
bool
hasBaseScript
(
)
const
{
return
flags_
.
hasBaseScript
(
)
;
}
bool
hasBytecode
(
)
const
{
MOZ_ASSERT
(
!
isIncomplete
(
)
)
;
return
hasBaseScript
(
)
&
&
baseScript
(
)
-
>
hasBytecode
(
)
;
}
bool
isArrow
(
)
const
{
return
flags_
.
isArrow
(
)
;
}
bool
isMethod
(
)
const
{
return
flags_
.
isMethod
(
)
;
}
bool
isClassConstructor
(
)
const
{
return
flags_
.
isClassConstructor
(
)
;
}
bool
isGetter
(
)
const
{
return
flags_
.
isGetter
(
)
;
}
bool
isSetter
(
)
const
{
return
flags_
.
isSetter
(
)
;
}
bool
allowSuperProperty
(
)
const
{
return
flags_
.
allowSuperProperty
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
flags_
.
hasResolvedLength
(
)
;
}
bool
hasResolvedName
(
)
const
{
return
flags_
.
hasResolvedName
(
)
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
flags_
.
isSelfHostedOrIntrinsic
(
)
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
flags_
.
isSelfHostedBuiltin
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
flags_
.
isIntrinsic
(
)
;
}
bool
hasJitScript
(
)
const
{
if
(
!
hasBaseScript
(
)
)
{
return
false
;
}
return
baseScript
(
)
-
>
hasJitScript
(
)
;
}
bool
hasJitEntry
(
)
const
{
return
hasBaseScript
(
)
|
|
hasSelfHostedLazyScript
(
)
|
|
isNativeWithJitEntry
(
)
;
}
bool
isBuiltin
(
)
const
{
return
isBuiltinNative
(
)
|
|
isSelfHostedBuiltin
(
)
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
.
isNamedLambda
(
displayAtom
(
)
)
;
}
bool
hasLexicalThis
(
)
const
{
return
isArrow
(
)
;
}
bool
isBuiltinFunctionConstructor
(
)
;
bool
needsPrototypeProperty
(
)
;
bool
hasNonConfigurablePrototypeDataProperty
(
)
;
bool
constructorNeedsUninitializedThis
(
)
const
{
MOZ_ASSERT
(
isConstructor
(
)
)
;
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
isBoundFunction
(
)
|
|
isDerivedClassConstructor
(
)
;
}
bool
strict
(
)
const
{
return
baseScript
(
)
-
>
strict
(
)
;
}
void
setFlags
(
uint16_t
flags
)
{
flags_
=
FunctionFlags
(
flags
)
;
}
void
setFlags
(
FunctionFlags
flags
)
{
flags_
=
flags
;
}
void
setIsConstructor
(
)
{
flags_
.
setIsConstructor
(
)
;
}
void
setIsClassConstructor
(
)
{
flags_
.
setIsClassConstructor
(
)
;
}
void
clearIsSelfHosted
(
)
{
flags_
.
clearIsSelfHosted
(
)
;
}
void
setArgCount
(
uint16_t
nargs
)
{
this
-
>
nargs_
=
nargs
;
}
void
setIsBoundFunction
(
)
{
flags_
.
setIsBoundFunction
(
)
;
}
void
setIsSelfHostedBuiltin
(
)
{
flags_
.
setIsSelfHostedBuiltin
(
)
;
}
void
setIsIntrinsic
(
)
{
flags_
.
setIsIntrinsic
(
)
;
}
void
setResolvedLength
(
)
{
flags_
.
setResolvedLength
(
)
;
}
void
setResolvedName
(
)
{
flags_
.
setResolvedName
(
)
;
}
bool
wasNewScriptCleared
(
)
const
{
return
flags_
.
wasNewScriptCleared
(
)
;
}
void
setNewScriptCleared
(
)
{
flags_
.
setNewScriptCleared
(
)
;
}
static
bool
getUnresolvedLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleValue
v
)
;
JSAtom
*
infallibleGetUnresolvedName
(
JSContext
*
cx
)
;
static
bool
getUnresolvedName
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleValue
v
)
;
static
JSLinearString
*
getBoundFunctionName
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
JSAtom
*
explicitName
(
)
const
{
return
(
hasInferredName
(
)
|
|
hasGuessedAtom
(
)
)
?
nullptr
:
atom_
.
get
(
)
;
}
JSAtom
*
explicitOrInferredName
(
)
const
{
return
hasGuessedAtom
(
)
?
nullptr
:
atom_
.
get
(
)
;
}
void
initAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
.
init
(
atom
)
;
}
void
setAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
=
atom
;
}
JSAtom
*
displayAtom
(
)
const
{
return
atom_
;
}
void
setInferredName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
setAtom
(
atom
)
;
flags_
.
setInferredName
(
)
;
}
void
clearInferredName
(
)
{
MOZ_ASSERT
(
hasInferredName
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
setAtom
(
nullptr
)
;
flags_
.
clearInferredName
(
)
;
}
JSAtom
*
inferredName
(
)
const
{
MOZ_ASSERT
(
hasInferredName
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
return
atom_
;
}
void
setGuessedAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasInferredName
(
)
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
setAtom
(
atom
)
;
flags_
.
setGuessedAtom
(
)
;
}
void
setPrefixedBoundFunctionName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
hasBoundFunctionNamePrefix
(
)
)
;
MOZ_ASSERT
(
atom
)
;
flags_
.
setPrefixedBoundFunctionName
(
)
;
setAtom
(
atom
)
;
}
enum
{
MAX_ARGS_AND_VARS
=
2
*
(
(
1U
<
<
16
)
-
1
)
}
;
JSObject
*
environment
(
)
const
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
u
.
scripted
.
env_
;
}
void
setEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
*
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
scripted
.
env_
)
=
obj
;
}
void
initEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
scripted
.
env_
)
-
>
init
(
obj
)
;
}
public
:
static
constexpr
size_t
offsetOfNargs
(
)
{
return
offsetof
(
JSFunction
nargs_
)
;
}
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
JSFunction
flags_
)
;
}
static
size_t
offsetOfEnvironment
(
)
{
return
offsetof
(
JSFunction
u
.
scripted
.
env_
)
;
}
static
size_t
offsetOfAtom
(
)
{
return
offsetof
(
JSFunction
atom_
)
;
}
static
bool
delazifyLazilyInterpretedFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
static
bool
delazifySelfHostedLazyFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
void
maybeRelazify
(
JSRuntime
*
rt
)
;
static
JSScript
*
getOrCreateScript
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
MOZ_ASSERT
(
cx
)
;
if
(
fun
-
>
hasBaseScript
(
)
&
&
!
fun
-
>
hasBytecode
(
)
)
{
if
(
!
delazifyLazilyInterpretedFunction
(
cx
fun
)
)
{
return
nullptr
;
}
}
else
if
(
fun
-
>
hasSelfHostedLazyScript
(
)
)
{
if
(
!
delazifySelfHostedLazyFunction
(
cx
fun
)
)
{
return
nullptr
;
}
}
return
fun
-
>
nonLazyScript
(
)
;
}
JSScript
*
existingScript
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
if
(
!
hasBytecode
(
)
)
{
JSFunction
*
canonicalFunction
=
baseScript
(
)
-
>
function
(
)
;
JSScript
*
script
=
canonicalFunction
-
>
nonLazyScript
(
)
;
clearLazyScript
(
)
;
initScript
(
script
)
;
}
return
nonLazyScript
(
)
;
}
JSFunction
*
maybeCanonicalFunction
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
function
(
)
;
}
return
nullptr
;
}
bool
isIncomplete
(
)
const
{
return
isInterpreted
(
)
&
&
!
u
.
scripted
.
s
.
script_
;
}
JSScript
*
nonLazyScript
(
)
const
{
MOZ_ASSERT
(
hasBaseScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
script_
)
;
return
static_cast
<
JSScript
*
>
(
u
.
scripted
.
s
.
script_
)
;
}
js
:
:
LazyScript
*
lazyScript
(
)
const
{
MOZ_ASSERT
(
hasBaseScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
script_
)
;
return
static_cast
<
js
:
:
LazyScript
*
>
(
u
.
scripted
.
s
.
script_
)
;
}
js
:
:
SelfHostedLazyScript
*
selfHostedLazyScript
(
)
const
{
MOZ_ASSERT
(
hasSelfHostedLazyScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
selfHostedLazy_
)
;
return
u
.
scripted
.
s
.
selfHostedLazy_
;
}
js
:
:
BaseScript
*
baseScript
(
)
const
{
MOZ_ASSERT
(
hasBaseScript
(
)
)
;
MOZ_ASSERT
(
u
.
scripted
.
s
.
script_
)
;
return
u
.
scripted
.
s
.
script_
;
}
static
bool
getLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
uint16_t
*
length
)
;
js
:
:
Scope
*
enclosingScope
(
)
const
{
return
baseScript
(
)
-
>
enclosingScope
(
)
;
}
void
setEnclosingScope
(
js
:
:
Scope
*
enclosingScope
)
{
baseScript
(
)
-
>
setEnclosingScope
(
enclosingScope
)
;
}
void
setEnclosingLazyScript
(
js
:
:
LazyScript
*
enclosingScript
)
{
baseScript
(
)
-
>
setEnclosingLazyScript
(
enclosingScript
)
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
generatorKind
(
)
;
}
return
js
:
:
GeneratorKind
:
:
NotGenerator
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
GeneratorKind
:
:
Generator
;
}
js
:
:
FunctionAsyncKind
asyncKind
(
)
const
{
if
(
hasBaseScript
(
)
)
{
return
baseScript
(
)
-
>
asyncKind
(
)
;
}
return
js
:
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
isAsync
(
)
const
{
return
asyncKind
(
)
=
=
js
:
:
FunctionAsyncKind
:
:
AsyncFunction
;
}
void
initScript
(
JSScript
*
script
)
{
MOZ_ASSERT_IF
(
script
realm
(
)
=
=
script
-
>
realm
(
)
)
;
u
.
scripted
.
s
.
script_
=
script
;
}
void
initLazyScript
(
js
:
:
LazyScript
*
lazy
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
u
.
scripted
.
s
.
script_
=
lazy
;
}
void
clearLazyScript
(
)
{
js
:
:
LazyScript
:
:
writeBarrierPre
(
lazyScript
(
)
)
;
u
.
scripted
.
s
.
script_
=
nullptr
;
MOZ_ASSERT
(
isIncomplete
(
)
)
;
}
void
initSelfHostedLazyScript
(
js
:
:
SelfHostedLazyScript
*
lazy
)
{
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
MOZ_ASSERT
(
isInterpreted
(
)
)
;
flags_
.
clearBaseScript
(
)
;
flags_
.
setSelfHostedLazy
(
)
;
u
.
scripted
.
s
.
selfHostedLazy_
=
lazy
;
MOZ_ASSERT
(
hasSelfHostedLazyScript
(
)
)
;
}
void
clearSelfHostedLazyScript
(
)
{
flags_
.
clearSelfHostedLazy
(
)
;
flags_
.
setBaseScript
(
)
;
u
.
scripted
.
s
.
script_
=
nullptr
;
MOZ_ASSERT
(
isIncomplete
(
)
)
;
}
void
setUnlazifiedScript
(
JSScript
*
script
)
{
MOZ_ASSERT
(
isInterpreted
(
)
&
&
!
hasBytecode
(
)
)
;
if
(
hasBaseScript
(
)
)
{
if
(
!
lazyScript
(
)
-
>
maybeScript
(
)
)
{
lazyScript
(
)
-
>
initScript
(
script
)
;
}
clearLazyScript
(
)
;
}
else
{
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
clearSelfHostedLazyScript
(
)
;
}
initScript
(
script
)
;
}
JSNative
native
(
)
const
{
MOZ_ASSERT
(
isNative
(
)
)
;
return
u
.
native
.
func_
;
}
JSNative
maybeNative
(
)
const
{
return
isInterpreted
(
)
?
nullptr
:
native
(
)
;
}
void
initNative
(
js
:
:
Native
native
const
JSJitInfo
*
jitInfo
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
MOZ_ASSERT_IF
(
jitInfo
isBuiltinNative
(
)
)
;
MOZ_ASSERT
(
native
)
;
u
.
native
.
func_
=
native
;
u
.
native
.
extra
.
jitInfo_
=
jitInfo
;
}
bool
hasJitInfo
(
)
const
{
return
isBuiltinNative
(
)
&
&
u
.
native
.
extra
.
jitInfo_
;
}
const
JSJitInfo
*
jitInfo
(
)
const
{
MOZ_ASSERT
(
hasJitInfo
(
)
)
;
return
u
.
native
.
extra
.
jitInfo_
;
}
void
setJitInfo
(
const
JSJitInfo
*
data
)
{
MOZ_ASSERT
(
isBuiltinNative
(
)
)
;
u
.
native
.
extra
.
jitInfo_
=
data
;
}
void
setWasmFuncIndex
(
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
isWasm
(
)
|
|
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
!
u
.
native
.
extra
.
wasmFuncIndex_
)
;
u
.
native
.
extra
.
wasmFuncIndex_
=
funcIndex
;
}
uint32_t
wasmFuncIndex
(
)
const
{
MOZ_ASSERT
(
isWasm
(
)
|
|
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
return
u
.
native
.
extra
.
wasmFuncIndex_
;
}
void
setWasmJitEntry
(
void
*
*
entry
)
{
MOZ_ASSERT
(
*
entry
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
MOZ_ASSERT
(
!
isWasmWithJitEntry
(
)
)
;
flags_
.
setWasmJitEntry
(
)
;
u
.
native
.
extra
.
wasmJitEntry_
=
entry
;
MOZ_ASSERT
(
isWasmWithJitEntry
(
)
)
;
}
void
*
*
wasmJitEntry
(
)
const
{
MOZ_ASSERT
(
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
u
.
native
.
extra
.
wasmJitEntry_
)
;
return
u
.
native
.
extra
.
wasmJitEntry_
;
}
bool
isDerivedClassConstructor
(
)
const
;
static
unsigned
offsetOfNative
(
)
{
return
offsetof
(
JSFunction
u
.
native
.
func_
)
;
}
static
unsigned
offsetOfScript
(
)
{
static_assert
(
offsetof
(
U
scripted
.
s
.
script_
)
=
=
offsetof
(
U
native
.
extra
.
wasmJitEntry_
)
"
scripted
.
s
.
script_
must
be
at
the
same
offset
as
"
"
native
.
extra
.
wasmJitEntry_
"
)
;
return
offsetof
(
JSFunction
u
.
scripted
.
s
.
script_
)
;
}
static
unsigned
offsetOfNativeOrEnv
(
)
{
static_assert
(
offsetof
(
U
native
.
func_
)
=
=
offsetof
(
U
scripted
.
env_
)
"
U
.
native
.
func_
must
be
at
the
same
offset
as
U
.
scripted
.
env_
"
)
;
return
offsetOfNative
(
)
;
}
static
unsigned
offsetOfScriptOrLazyScript
(
)
{
return
offsetof
(
JSFunction
u
.
scripted
.
s
.
script_
)
;
}
static
unsigned
offsetOfJitInfo
(
)
{
return
offsetof
(
JSFunction
u
.
native
.
extra
.
jitInfo_
)
;
}
inline
void
trace
(
JSTracer
*
trc
)
;
JSObject
*
getBoundFunctionTarget
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionThis
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionArgument
(
unsigned
which
)
const
;
size_t
getBoundFunctionArgumentCount
(
)
const
;
static
bool
finishBoundFunctionInit
(
JSContext
*
cx
js
:
:
HandleFunction
bound
js
:
:
HandleObject
targetObj
int32_t
argCount
)
;
private
:
inline
js
:
:
FunctionExtended
*
toExtended
(
)
;
inline
const
js
:
:
FunctionExtended
*
toExtended
(
)
const
;
public
:
inline
bool
isExtended
(
)
const
{
bool
extended
=
flags_
.
isExtended
(
)
;
MOZ_ASSERT_IF
(
isTenured
(
)
extended
=
=
(
asTenured
(
)
.
getAllocKind
(
)
=
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
return
extended
;
}
inline
void
initializeExtended
(
)
;
inline
void
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
void
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
const
js
:
:
Value
&
getExtendedSlot
(
size_t
which
)
const
;
inline
js
:
:
FunctionExtended
*
toExtendedOffMainThread
(
)
;
inline
const
js
:
:
FunctionExtended
*
toExtendedOffMainThread
(
)
const
;
inline
const
js
:
:
Value
&
getExtendedSlotOffMainThread
(
size_t
which
)
const
;
static
bool
setTypeForScriptedFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
bool
singleton
=
false
)
;
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
static_assert
(
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
!
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
"
extended
/
non
-
extended
AllocKinds
have
to
be
different
"
"
for
getAllocKind
(
)
to
have
a
reason
to
exist
"
)
;
js
:
:
gc
:
:
AllocKind
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
;
if
(
isExtended
(
)
)
{
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
}
MOZ_ASSERT_IF
(
isTenured
(
)
kind
=
=
asTenured
(
)
.
getAllocKind
(
)
)
;
return
kind
;
}
}
;
static_assert
(
sizeof
(
JSFunction
)
=
=
sizeof
(
js
:
:
shadow
:
:
Function
)
"
shadow
interface
must
match
actual
interface
"
)
;
extern
JSString
*
fun_toStringHelper
(
JSContext
*
cx
js
:
:
HandleObject
obj
bool
isToSource
)
;
namespace
js
{
extern
bool
Function
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
Generator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncFunctionConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncGeneratorConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
JSFunction
*
NewFunctionWithProto
(
JSContext
*
cx
JSNative
native
unsigned
nargs
FunctionFlags
flags
HandleObject
enclosingEnv
HandleAtom
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
)
;
inline
JSFunction
*
NewNativeFunction
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
FunctionFlags
flags
=
FunctionFlags
:
:
NATIVE_FUN
)
{
MOZ_ASSERT
(
native
)
;
return
NewFunctionWithProto
(
cx
native
nargs
flags
nullptr
atom
nullptr
allocKind
newKind
)
;
}
inline
JSFunction
*
NewNativeConstructor
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
FunctionFlags
flags
=
FunctionFlags
:
:
NATIVE_CTOR
)
{
MOZ_ASSERT
(
native
)
;
MOZ_ASSERT
(
flags
.
isNativeConstructor
(
)
)
;
return
NewFunctionWithProto
(
cx
native
nargs
flags
nullptr
atom
nullptr
allocKind
newKind
)
;
}
extern
JSFunction
*
NewScriptedFunction
(
JSContext
*
cx
unsigned
nargs
FunctionFlags
flags
HandleAtom
atom
HandleObject
proto
=
nullptr
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
HandleObject
enclosingEnv
=
nullptr
)
;
extern
bool
GetFunctionPrototype
(
JSContext
*
cx
js
:
:
GeneratorKind
generatorKind
js
:
:
FunctionAsyncKind
asyncKind
js
:
:
MutableHandleObject
proto
)
;
extern
JSAtom
*
IdToFunctionName
(
JSContext
*
cx
HandleId
id
FunctionPrefixKind
prefixKind
=
FunctionPrefixKind
:
:
None
)
;
extern
bool
SetFunctionName
(
JSContext
*
cx
HandleFunction
fun
HandleValue
name
FunctionPrefixKind
prefixKind
)
;
extern
JSFunction
*
DefineFunction
(
JSContext
*
cx
HandleObject
obj
HandleId
id
JSNative
native
unsigned
nargs
unsigned
flags
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
)
;
extern
bool
fun_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
struct
WellKnownSymbols
;
extern
bool
FunctionHasDefaultHasInstance
(
JSFunction
*
fun
const
WellKnownSymbols
&
symbols
)
;
extern
void
ThrowTypeErrorBehavior
(
JSContext
*
cx
)
;
class
FunctionExtended
:
public
JSFunction
{
public
:
static
const
unsigned
NUM_EXTENDED_SLOTS
=
2
;
static
const
unsigned
ARROW_NEWTARGET_SLOT
=
0
;
static
const
unsigned
METHOD_HOMEOBJECT_SLOT
=
0
;
static
const
unsigned
WASM_INSTANCE_SLOT
=
0
;
static
const
unsigned
WASM_TLSDATA_SLOT
=
1
;
static
const
unsigned
ASMJS_MODULE_SLOT
=
0
;
static
inline
size_t
offsetOfExtendedSlot
(
unsigned
which
)
{
MOZ_ASSERT
(
which
<
NUM_EXTENDED_SLOTS
)
;
return
offsetof
(
FunctionExtended
extendedSlots
)
+
which
*
sizeof
(
GCPtrValue
)
;
}
static
inline
size_t
offsetOfArrowNewTargetSlot
(
)
{
return
offsetOfExtendedSlot
(
ARROW_NEWTARGET_SLOT
)
;
}
static
inline
size_t
offsetOfMethodHomeObjectSlot
(
)
{
return
offsetOfExtendedSlot
(
METHOD_HOMEOBJECT_SLOT
)
;
}
private
:
friend
class
JSFunction
;
GCPtrValue
extendedSlots
[
NUM_EXTENDED_SLOTS
]
;
}
;
extern
bool
CanReuseScriptForClone
(
JS
:
:
Realm
*
realm
HandleFunction
fun
HandleObject
newEnclosingEnv
)
;
extern
JSFunction
*
CloneFunctionReuseScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
gc
:
:
AllocKind
kind
NewObjectKind
newKindArg
HandleObject
proto
)
;
extern
JSFunction
*
CloneFunctionAndScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
HandleScope
newScope
Handle
<
ScriptSourceObject
*
>
sourceObject
gc
:
:
AllocKind
kind
HandleObject
proto
=
nullptr
)
;
extern
JSFunction
*
CloneAsmJSModuleFunction
(
JSContext
*
cx
HandleFunction
fun
)
;
extern
JSFunction
*
CloneSelfHostingIntrinsic
(
JSContext
*
cx
HandleFunction
fun
)
;
}
inline
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
const
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
const
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
const
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtendedOffMainThread
(
)
{
return
static_cast
<
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
const
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtendedOffMainThread
(
)
const
{
return
static_cast
<
const
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
void
JSFunction
:
:
initializeExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
MOZ_ASSERT
(
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
=
=
2
)
;
toExtended
(
)
-
>
extendedSlots
[
0
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
toExtended
(
)
-
>
extendedSlots
[
1
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
}
inline
void
JSFunction
:
:
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
.
init
(
val
)
;
}
inline
void
JSFunction
:
:
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
=
val
;
}
inline
const
js
:
:
Value
&
JSFunction
:
:
getExtendedSlot
(
size_t
which
)
const
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
return
toExtended
(
)
-
>
extendedSlots
[
which
]
;
}
inline
const
js
:
:
Value
&
JSFunction
:
:
getExtendedSlotOffMainThread
(
size_t
which
)
const
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtendedOffMainThread
(
)
-
>
extendedSlots
)
)
;
return
toExtendedOffMainThread
(
)
-
>
extendedSlots
[
which
]
;
}
namespace
js
{
JSString
*
FunctionToString
(
JSContext
*
cx
HandleFunction
fun
bool
isToSource
)
;
template
<
XDRMode
mode
>
XDRResult
XDRInterpretedFunction
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
MutableHandleFunction
objp
)
;
extern
void
ReportIncompatibleMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
JSClass
*
clasp
)
;
extern
void
ReportIncompatible
(
JSContext
*
cx
const
CallArgs
&
args
)
;
extern
bool
fun_apply
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
fun_call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
#
ifdef
DEBUG
namespace
JS
{
namespace
detail
{
JS_PUBLIC_API
void
CheckIsValidConstructible
(
const
Value
&
calleev
)
;
}
}
#
endif
#
endif
