#
ifndef
vm_SharedImmutableStringsCache_h
#
define
vm_SharedImmutableStringsCache_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
cstring
>
#
include
<
new
>
#
include
"
jsstr
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
namespace
js
{
class
SharedImmutableStringsCache
;
class
SharedImmutableTwoByteString
;
class
SharedImmutableString
{
friend
class
SharedImmutableStringsCache
;
friend
class
SharedImmutableTwoByteString
;
SharedImmutableStringsCache
*
cache_
;
const
char
*
chars_
;
size_t
length_
;
#
ifdef
DEBUG
HashNumber
hash_
;
#
endif
SharedImmutableString
(
SharedImmutableStringsCache
*
cache
const
char
*
chars
size_t
length
)
:
cache_
(
cache
)
chars_
(
chars
)
length_
(
length
)
#
ifdef
DEBUG
hash_
(
mozilla
:
:
HashString
(
chars
length
)
)
#
endif
{
MOZ_ASSERT
(
cache
&
&
chars
)
;
}
public
:
SharedImmutableString
(
SharedImmutableString
&
&
rhs
)
:
cache_
(
rhs
.
cache_
)
chars_
(
rhs
.
chars_
)
length_
(
rhs
.
length_
)
#
ifdef
DEBUG
hash_
(
mozilla
:
:
HashString
(
rhs
.
chars_
rhs
.
length_
)
)
#
endif
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
not
allowed
"
)
;
MOZ_ASSERT
(
rhs
.
cache_
&
&
rhs
.
chars_
)
;
MOZ_ASSERT
(
rhs
.
hash_
=
=
hash_
)
;
rhs
.
cache_
=
nullptr
;
rhs
.
chars_
=
nullptr
;
}
SharedImmutableString
&
operator
=
(
SharedImmutableString
&
&
rhs
)
{
this
-
>
~
SharedImmutableString
(
)
;
new
(
this
)
SharedImmutableString
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
SharedImmutableString
clone
(
)
const
;
~
SharedImmutableString
(
)
;
const
char
*
chars
(
)
const
{
MOZ_ASSERT
(
cache_
&
&
chars_
)
;
return
chars_
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
cache_
&
&
chars_
)
;
return
length_
;
}
}
;
class
SharedImmutableTwoByteString
{
friend
class
SharedImmutableStringsCache
;
SharedImmutableString
string_
;
explicit
SharedImmutableTwoByteString
(
SharedImmutableString
&
&
string
)
:
string_
(
mozilla
:
:
Move
(
string
)
)
{
}
SharedImmutableTwoByteString
(
SharedImmutableStringsCache
*
cache
const
char
*
chars
size_t
length
)
:
string_
(
cache
chars
length
)
{
MOZ_ASSERT
(
length
%
sizeof
(
char16_t
)
=
=
0
)
;
}
public
:
SharedImmutableTwoByteString
(
SharedImmutableTwoByteString
&
&
rhs
)
:
string_
(
mozilla
:
:
Move
(
rhs
.
string_
)
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
not
allowed
"
)
;
}
SharedImmutableTwoByteString
&
operator
=
(
SharedImmutableTwoByteString
&
&
rhs
)
{
this
-
>
~
SharedImmutableTwoByteString
(
)
;
new
(
this
)
SharedImmutableTwoByteString
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
SharedImmutableTwoByteString
clone
(
)
const
;
const
char16_t
*
chars
(
)
const
{
return
reinterpret_cast
<
const
char16_t
*
>
(
string_
.
chars
(
)
)
;
}
size_t
length
(
)
const
{
return
string_
.
length
(
)
/
sizeof
(
char16_t
)
;
}
}
;
class
SharedImmutableStringsCache
{
friend
class
SharedImmutableString
;
struct
Hasher
;
public
:
using
OwnedChars
=
mozilla
:
:
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
;
using
OwnedTwoByteChars
=
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
;
template
<
typename
IntoOwnedChars
>
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
const
char
*
chars
size_t
length
IntoOwnedChars
intoOwnedChars
)
{
Hasher
:
:
Lookup
lookup
(
chars
length
)
;
auto
locked
=
set_
.
lock
(
)
;
if
(
!
locked
-
>
initialized
(
)
&
&
!
locked
-
>
init
(
)
)
return
mozilla
:
:
Nothing
(
)
;
auto
entry
=
locked
-
>
lookupForAdd
(
lookup
)
;
if
(
!
entry
)
{
OwnedChars
ownedChars
(
intoOwnedChars
(
)
)
;
if
(
!
ownedChars
)
return
mozilla
:
:
Nothing
(
)
;
MOZ_ASSERT
(
ownedChars
.
get
(
)
=
=
chars
|
|
memcmp
(
ownedChars
.
get
(
)
chars
length
)
=
=
0
)
;
StringBox
box
(
mozilla
:
:
Move
(
ownedChars
)
length
)
;
if
(
!
locked
-
>
add
(
entry
mozilla
:
:
Move
(
box
)
)
)
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ASSERT
(
entry
)
;
entry
-
>
refcount
+
+
;
return
mozilla
:
:
Some
(
SharedImmutableString
(
this
entry
-
>
chars
(
)
entry
-
>
length
(
)
)
)
;
}
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
OwnedChars
&
&
chars
size_t
length
)
;
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
const
char
*
chars
size_t
length
)
;
template
<
typename
IntoOwnedTwoByteChars
>
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
const
char16_t
*
chars
size_t
length
IntoOwnedTwoByteChars
intoOwnedTwoByteChars
)
{
Hasher
:
:
Lookup
lookup
(
chars
length
)
;
auto
locked
=
set_
.
lock
(
)
;
if
(
!
locked
-
>
initialized
(
)
&
&
!
locked
-
>
init
(
)
)
return
mozilla
:
:
Nothing
(
)
;
auto
entry
=
locked
-
>
lookupForAdd
(
lookup
)
;
if
(
!
entry
)
{
OwnedTwoByteChars
ownedTwoByteChars
(
intoOwnedTwoByteChars
(
)
)
;
if
(
!
ownedTwoByteChars
)
return
mozilla
:
:
Nothing
(
)
;
MOZ_ASSERT
(
ownedTwoByteChars
.
get
(
)
=
=
chars
|
|
memcmp
(
ownedTwoByteChars
.
get
(
)
chars
length
*
sizeof
(
char16_t
)
)
=
=
0
)
;
OwnedChars
ownedChars
(
reinterpret_cast
<
char
*
>
(
ownedTwoByteChars
.
release
(
)
)
)
;
StringBox
box
(
mozilla
:
:
Move
(
ownedChars
)
length
*
sizeof
(
char16_t
)
)
;
if
(
!
locked
-
>
add
(
entry
mozilla
:
:
Move
(
box
)
)
)
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ASSERT
(
entry
)
;
entry
-
>
refcount
+
+
;
return
mozilla
:
:
Some
(
SharedImmutableTwoByteString
(
this
entry
-
>
chars
(
)
entry
-
>
length
(
)
)
)
;
}
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
OwnedTwoByteChars
&
&
chars
size_t
length
)
;
MOZ_WARN_UNUSED_RESULT
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
const
char16_t
*
chars
size_t
length
)
;
SharedImmutableStringsCache
(
)
:
set_
(
Set
(
)
)
{
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
0
;
auto
locked
=
set_
.
lock
(
)
;
if
(
!
locked
-
>
initialized
(
)
)
return
n
;
n
+
=
locked
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
r
=
locked
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
n
+
=
mallocSizeOf
(
r
.
front
(
)
.
chars
(
)
)
;
return
n
;
}
private
:
class
StringBox
{
OwnedChars
chars_
;
size_t
length_
;
public
:
mutable
size_t
refcount
;
StringBox
(
OwnedChars
&
&
chars
size_t
length
)
:
chars_
(
mozilla
:
:
Move
(
chars
)
)
length_
(
length
)
refcount
(
0
)
{
MOZ_ASSERT
(
chars_
)
;
}
StringBox
(
StringBox
&
&
rhs
)
:
chars_
(
mozilla
:
:
Move
(
rhs
.
chars_
)
)
length_
(
rhs
.
length_
)
refcount
(
rhs
.
refcount
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
not
allowed
"
)
;
rhs
.
refcount
=
0
;
}
~
StringBox
(
)
{
MOZ_ASSERT
(
refcount
=
=
0
)
;
}
const
char
*
chars
(
)
const
{
return
chars_
.
get
(
)
;
}
size_t
length
(
)
const
{
return
length_
;
}
}
;
struct
Hasher
{
class
Lookup
{
friend
struct
Hasher
;
const
char
*
chars_
;
size_t
length_
;
public
:
Lookup
(
const
char
*
chars
size_t
length
)
:
chars_
(
chars
)
length_
(
length
)
{
MOZ_ASSERT
(
chars_
)
;
}
explicit
Lookup
(
const
char
*
chars
)
:
Lookup
(
chars
strlen
(
chars
)
)
{
}
Lookup
(
const
char16_t
*
chars
size_t
length
)
:
Lookup
(
reinterpret_cast
<
const
char
*
>
(
chars
)
length
*
sizeof
(
char16_t
)
)
{
}
explicit
Lookup
(
const
char16_t
*
chars
)
:
Lookup
(
chars
js_strlen
(
chars
)
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
MOZ_ASSERT
(
lookup
.
chars_
)
;
return
mozilla
:
:
HashString
(
lookup
.
chars_
lookup
.
length_
)
;
}
static
bool
match
(
const
StringBox
&
key
const
Lookup
&
lookup
)
{
MOZ_ASSERT
(
lookup
.
chars_
)
;
MOZ_ASSERT
(
key
.
chars
(
)
)
;
if
(
key
.
length
(
)
!
=
lookup
.
length_
)
return
false
;
if
(
key
.
chars
(
)
=
=
lookup
.
chars_
)
return
true
;
return
memcmp
(
key
.
chars
(
)
lookup
.
chars_
key
.
length
(
)
)
=
=
0
;
}
}
;
using
Set
=
HashSet
<
StringBox
Hasher
SystemAllocPolicy
>
;
ExclusiveData
<
Set
>
set_
;
}
;
}
#
endif
