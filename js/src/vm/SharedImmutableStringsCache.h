#
ifndef
vm_SharedImmutableStringsCache_h
#
define
vm_SharedImmutableStringsCache_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
cstring
>
#
include
<
new
>
#
include
"
jsstr
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
namespace
js
{
class
SharedImmutableString
;
class
SharedImmutableTwoByteString
;
class
SharedImmutableStringsCache
{
friend
class
SharedImmutableString
;
struct
Hasher
;
public
:
using
OwnedChars
=
mozilla
:
:
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
;
using
OwnedTwoByteChars
=
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
;
template
<
typename
IntoOwnedChars
>
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
const
char
*
chars
size_t
length
IntoOwnedChars
intoOwnedChars
)
;
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
OwnedChars
&
&
chars
size_t
length
)
;
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreate
(
const
char
*
chars
size_t
length
)
;
template
<
typename
IntoOwnedTwoByteChars
>
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
const
char16_t
*
chars
size_t
length
IntoOwnedTwoByteChars
intoOwnedTwoByteChars
)
;
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
OwnedTwoByteChars
&
&
chars
size_t
length
)
;
MOZ_MUST_USE
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreate
(
const
char16_t
*
chars
size_t
length
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
MOZ_ASSERT
(
inner_
)
;
size_t
n
=
mallocSizeOf
(
inner_
)
;
auto
locked
=
inner_
-
>
lock
(
)
;
if
(
!
locked
-
>
set
.
initialized
(
)
)
return
n
;
n
+
=
locked
-
>
set
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
r
=
locked
-
>
set
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
n
+
=
mallocSizeOf
(
r
.
front
(
)
.
chars
(
)
)
;
return
n
;
}
static
mozilla
:
:
Maybe
<
SharedImmutableStringsCache
>
Create
(
)
{
auto
inner
=
js_new
<
ExclusiveData
<
Inner
>
>
(
)
;
if
(
!
inner
)
return
mozilla
:
:
Nothing
(
)
;
auto
ret
=
mozilla
:
:
Some
(
SharedImmutableStringsCache
(
inner
)
)
;
#
ifdef
DEBUG
auto
locked
=
ret
-
>
inner_
-
>
lock
(
)
;
MOZ_ASSERT
(
locked
-
>
refcount
=
=
1
)
;
#
endif
return
ret
;
}
SharedImmutableStringsCache
(
SharedImmutableStringsCache
&
&
rhs
)
:
inner_
(
rhs
.
inner_
)
{
MOZ_ASSERT
(
inner_
)
;
rhs
.
inner_
=
nullptr
;
}
SharedImmutableStringsCache
&
operator
=
(
SharedImmutableStringsCache
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
not
allowed
"
)
;
new
(
this
)
SharedImmutableStringsCache
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
SharedImmutableStringsCache
clone
(
)
{
MOZ_ASSERT
(
inner_
)
;
auto
locked
=
inner_
-
>
lock
(
)
;
locked
-
>
refcount
+
+
;
return
SharedImmutableStringsCache
(
inner_
)
;
}
SharedImmutableStringsCache
&
operator
=
(
const
SharedImmutableStringsCache
&
)
=
delete
;
~
SharedImmutableStringsCache
(
)
{
if
(
!
inner_
)
return
;
bool
shouldDestroy
=
false
;
{
auto
locked
=
inner_
-
>
lock
(
)
;
MOZ_ASSERT
(
locked
-
>
refcount
>
0
)
;
locked
-
>
refcount
-
-
;
if
(
locked
-
>
refcount
=
=
0
)
shouldDestroy
=
true
;
}
if
(
shouldDestroy
)
js_delete
(
inner_
)
;
}
private
:
class
StringBox
{
OwnedChars
chars_
;
size_t
length_
;
public
:
mutable
size_t
refcount
;
StringBox
(
OwnedChars
&
&
chars
size_t
length
)
:
chars_
(
mozilla
:
:
Move
(
chars
)
)
length_
(
length
)
refcount
(
0
)
{
MOZ_ASSERT
(
chars_
)
;
}
StringBox
(
StringBox
&
&
rhs
)
:
chars_
(
mozilla
:
:
Move
(
rhs
.
chars_
)
)
length_
(
rhs
.
length_
)
refcount
(
rhs
.
refcount
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
not
allowed
"
)
;
rhs
.
refcount
=
0
;
}
~
StringBox
(
)
{
MOZ_RELEASE_ASSERT
(
refcount
=
=
0
"
There
are
SharedImmutable
[
TwoByte
]
String
s
outliving
their
"
"
associated
cache
!
This
always
leads
to
use
-
after
-
free
in
the
"
"
~
SharedImmutableString
destructor
!
"
)
;
}
const
char
*
chars
(
)
const
{
return
chars_
.
get
(
)
;
}
size_t
length
(
)
const
{
return
length_
;
}
}
;
struct
Hasher
{
class
Lookup
{
friend
struct
Hasher
;
const
char
*
chars_
;
size_t
length_
;
public
:
Lookup
(
const
char
*
chars
size_t
length
)
:
chars_
(
chars
)
length_
(
length
)
{
MOZ_ASSERT
(
chars_
)
;
}
explicit
Lookup
(
const
char
*
chars
)
:
Lookup
(
chars
strlen
(
chars
)
)
{
}
Lookup
(
const
char16_t
*
chars
size_t
length
)
:
Lookup
(
reinterpret_cast
<
const
char
*
>
(
chars
)
length
*
sizeof
(
char16_t
)
)
{
}
explicit
Lookup
(
const
char16_t
*
chars
)
:
Lookup
(
chars
js_strlen
(
chars
)
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
MOZ_ASSERT
(
lookup
.
chars_
)
;
return
mozilla
:
:
HashString
(
lookup
.
chars_
lookup
.
length_
)
;
}
static
bool
match
(
const
StringBox
&
key
const
Lookup
&
lookup
)
{
MOZ_ASSERT
(
lookup
.
chars_
)
;
MOZ_ASSERT
(
key
.
chars
(
)
)
;
if
(
key
.
length
(
)
!
=
lookup
.
length_
)
return
false
;
if
(
key
.
chars
(
)
=
=
lookup
.
chars_
)
return
true
;
return
memcmp
(
key
.
chars
(
)
lookup
.
chars_
key
.
length
(
)
)
=
=
0
;
}
}
;
struct
Inner
{
using
Set
=
HashSet
<
StringBox
Hasher
SystemAllocPolicy
>
;
size_t
refcount
;
Set
set
;
Inner
(
)
:
refcount
(
1
)
set
(
)
{
}
Inner
(
const
Inner
&
)
=
delete
;
Inner
&
operator
=
(
const
Inner
&
)
=
delete
;
~
Inner
(
)
{
MOZ_ASSERT
(
refcount
=
=
0
)
;
}
}
;
ExclusiveData
<
Inner
>
*
inner_
;
explicit
SharedImmutableStringsCache
(
ExclusiveData
<
Inner
>
*
inner
)
:
inner_
(
inner
)
{
MOZ_ASSERT
(
inner_
)
;
}
}
;
class
SharedImmutableString
{
friend
class
SharedImmutableStringsCache
;
friend
class
SharedImmutableTwoByteString
;
mutable
SharedImmutableStringsCache
cache_
;
const
char
*
chars_
;
size_t
length_
;
#
ifdef
DEBUG
HashNumber
hash_
;
#
endif
SharedImmutableString
(
SharedImmutableStringsCache
&
&
cache
const
char
*
chars
size_t
length
)
;
public
:
SharedImmutableString
(
SharedImmutableString
&
&
rhs
)
;
SharedImmutableString
&
operator
=
(
SharedImmutableString
&
&
rhs
)
;
SharedImmutableString
clone
(
)
const
;
SharedImmutableString
&
operator
=
(
const
SharedImmutableString
&
)
=
delete
;
~
SharedImmutableString
(
)
;
const
char
*
chars
(
)
const
{
MOZ_ASSERT
(
chars_
)
;
return
chars_
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
chars_
)
;
return
length_
;
}
}
;
class
SharedImmutableTwoByteString
{
friend
class
SharedImmutableStringsCache
;
SharedImmutableString
string_
;
explicit
SharedImmutableTwoByteString
(
SharedImmutableString
&
&
string
)
;
SharedImmutableTwoByteString
(
SharedImmutableStringsCache
&
&
cache
const
char
*
chars
size_t
length
)
;
public
:
SharedImmutableTwoByteString
(
SharedImmutableTwoByteString
&
&
rhs
)
;
SharedImmutableTwoByteString
&
operator
=
(
SharedImmutableTwoByteString
&
&
rhs
)
;
SharedImmutableTwoByteString
clone
(
)
const
;
SharedImmutableTwoByteString
&
operator
=
(
const
SharedImmutableTwoByteString
&
)
=
delete
;
const
char16_t
*
chars
(
)
const
{
return
reinterpret_cast
<
const
char16_t
*
>
(
string_
.
chars
(
)
)
;
}
size_t
length
(
)
const
{
return
string_
.
length
(
)
/
sizeof
(
char16_t
)
;
}
}
;
}
#
endif
