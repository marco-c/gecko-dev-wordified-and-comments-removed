#
include
"
vm
/
PropMap
-
inl
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
HashUtil
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
ObjectFlags
-
inl
.
h
"
using
namespace
js
;
SharedPropMap
*
SharedPropMap
:
:
create
(
JSContext
*
cx
Handle
<
SharedPropMap
*
>
prev
HandleId
id
PropertyInfo
prop
)
{
static
constexpr
size_t
MaxFirstSlot
=
CompactPropertyInfo
:
:
MaxSlotNumber
-
(
PropMap
:
:
Capacity
-
1
)
;
if
(
!
prev
&
&
prop
.
maybeSlot
(
)
<
=
MaxFirstSlot
)
{
CompactPropMap
*
map
=
Allocate
<
CompactPropMap
>
(
cx
)
;
if
(
!
map
)
{
return
nullptr
;
}
new
(
map
)
CompactPropMap
(
id
prop
)
;
return
map
;
}
NormalPropMap
*
map
=
Allocate
<
NormalPropMap
>
(
cx
)
;
if
(
!
map
)
{
return
nullptr
;
}
new
(
map
)
NormalPropMap
(
prev
id
prop
)
;
return
map
;
}
SharedPropMap
*
SharedPropMap
:
:
createInitial
(
JSContext
*
cx
HandleId
id
PropertyInfo
prop
)
{
using
Lookup
=
InitialPropMapHasher
:
:
Lookup
;
auto
&
table
=
cx
-
>
zone
(
)
-
>
shapeZone
(
)
.
initialPropMaps
;
auto
p
=
MakeDependentAddPtr
(
cx
table
Lookup
(
id
prop
)
)
;
if
(
p
)
{
return
*
p
;
}
SharedPropMap
*
result
=
create
(
cx
nullptr
id
prop
)
;
if
(
!
result
)
{
return
nullptr
;
}
Lookup
lookup
(
id
prop
)
;
if
(
!
p
.
add
(
cx
table
lookup
result
)
)
{
return
nullptr
;
}
return
result
;
}
SharedPropMap
*
SharedPropMap
:
:
clone
(
JSContext
*
cx
Handle
<
SharedPropMap
*
>
map
uint32_t
length
)
{
MOZ_ASSERT
(
length
>
0
)
;
if
(
map
-
>
isCompact
(
)
)
{
CompactPropMap
*
clone
=
Allocate
<
CompactPropMap
>
(
cx
)
;
if
(
!
clone
)
{
return
nullptr
;
}
new
(
clone
)
CompactPropMap
(
map
-
>
asCompact
(
)
length
)
;
return
clone
;
}
NormalPropMap
*
clone
=
Allocate
<
NormalPropMap
>
(
cx
)
;
if
(
!
clone
)
{
return
nullptr
;
}
new
(
clone
)
NormalPropMap
(
map
-
>
asNormal
(
)
length
)
;
return
clone
;
}
static
MOZ_ALWAYS_INLINE
SharedPropMap
*
PropMapChildReadBarrier
(
SharedPropMap
*
parent
SharedPropMap
*
child
)
{
JS
:
:
Zone
*
zone
=
child
-
>
zone
(
)
;
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
ReadBarrier
(
child
)
;
return
child
;
}
if
(
MOZ_LIKELY
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
|
|
!
IsAboutToBeFinalizedUnbarriered
(
&
child
)
)
)
{
return
child
;
}
MOZ_ASSERT
(
parent
-
>
isMarkedAny
(
)
)
;
parent
-
>
removeChild
(
zone
-
>
runtimeFromMainThread
(
)
-
>
defaultFreeOp
(
)
child
)
;
return
nullptr
;
}
SharedPropMap
*
SharedPropMap
:
:
lookupChild
(
uint32_t
length
HandleId
id
PropertyInfo
prop
)
{
MOZ_ASSERT
(
length
>
0
)
;
SharedChildrenPtr
children
=
treeDataRef
(
)
.
children
;
if
(
children
.
isNone
(
)
)
{
return
nullptr
;
}
if
(
!
hasChildrenSet
(
)
)
{
SharedPropMapAndIndex
prevChild
=
children
.
toSingleChild
(
)
;
if
(
prevChild
.
index
(
)
=
=
length
-
1
)
{
SharedPropMap
*
child
=
prevChild
.
map
(
)
;
uint32_t
newPropIndex
=
indexOfNextProperty
(
length
-
1
)
;
if
(
child
-
>
matchProperty
(
newPropIndex
id
prop
)
)
{
return
PropMapChildReadBarrier
(
this
child
)
;
}
}
return
nullptr
;
}
SharedChildrenSet
*
set
=
children
.
toChildrenSet
(
)
;
SharedChildrenHasher
:
:
Lookup
lookup
(
id
prop
length
-
1
)
;
if
(
auto
p
=
set
-
>
lookup
(
lookup
)
)
{
MOZ_ASSERT
(
p
-
>
index
(
)
=
=
length
-
1
)
;
SharedPropMap
*
child
=
p
-
>
map
(
)
;
return
PropMapChildReadBarrier
(
this
child
)
;
}
return
nullptr
;
}
bool
SharedPropMap
:
:
addChild
(
JSContext
*
cx
SharedPropMapAndIndex
child
HandleId
id
PropertyInfo
prop
)
{
SharedPropMap
*
childMap
=
child
.
map
(
)
;
#
ifdef
DEBUG
if
(
childMap
-
>
hasPrevious
(
)
)
{
if
(
child
.
index
(
)
=
=
PropMap
:
:
Capacity
-
1
)
{
MOZ_ASSERT
(
childMap
-
>
asLinked
(
)
-
>
previous
(
)
=
=
this
)
;
}
else
{
MOZ_ASSERT
(
childMap
-
>
asLinked
(
)
-
>
previous
(
)
=
=
asLinked
(
)
-
>
previous
(
)
)
;
}
}
else
{
MOZ_ASSERT
(
!
hasPrevious
(
)
)
;
}
#
endif
SharedChildrenPtr
&
childrenRef
=
treeDataRef
(
)
.
children
;
if
(
childrenRef
.
isNone
(
)
)
{
childrenRef
.
setSingleChild
(
child
)
;
childMap
-
>
treeDataRef
(
)
.
setParent
(
this
child
.
index
(
)
)
;
return
true
;
}
SharedChildrenHasher
:
:
Lookup
lookup
(
id
prop
child
.
index
(
)
)
;
if
(
hasChildrenSet
(
)
)
{
if
(
!
childrenRef
.
toChildrenSet
(
)
-
>
putNew
(
lookup
child
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
else
{
auto
hash
=
MakeUnique
<
SharedChildrenSet
>
(
)
;
if
(
!
hash
|
|
!
hash
-
>
reserve
(
2
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
SharedPropMapAndIndex
firstChild
=
childrenRef
.
toSingleChild
(
)
;
SharedPropMap
*
firstChildMap
=
firstChild
.
map
(
)
;
uint32_t
firstChildIndex
=
indexOfNextProperty
(
firstChild
.
index
(
)
)
;
SharedChildrenHasher
:
:
Lookup
lookupFirst
(
firstChildMap
-
>
getPropertyInfoWithKey
(
firstChildIndex
)
firstChild
.
index
(
)
)
;
hash
-
>
putNewInfallible
(
lookupFirst
firstChild
)
;
hash
-
>
putNewInfallible
(
lookup
child
)
;
childrenRef
.
setChildrenSet
(
hash
.
release
(
)
)
;
setHasChildrenSet
(
)
;
AddCellMemory
(
this
sizeof
(
SharedChildrenSet
)
MemoryUse
:
:
PropMapChildren
)
;
}
childMap
-
>
treeDataRef
(
)
.
setParent
(
this
child
.
index
(
)
)
;
return
true
;
}
bool
SharedPropMap
:
:
addProperty
(
JSContext
*
cx
const
JSClass
*
clasp
MutableHandle
<
SharedPropMap
*
>
map
uint32_t
*
mapLength
HandleId
id
PropertyFlags
flags
ObjectFlags
*
objectFlags
uint32_t
*
slot
)
{
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
)
;
*
slot
=
SharedPropMap
:
:
slotSpan
(
clasp
map
*
mapLength
)
;
if
(
MOZ_UNLIKELY
(
*
slot
>
SHAPE_MAXIMUM_SLOT
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
*
objectFlags
=
GetObjectFlagsForNewProperty
(
clasp
*
objectFlags
id
flags
cx
)
;
PropertyInfo
prop
=
PropertyInfo
(
flags
*
slot
)
;
return
addPropertyInternal
(
cx
map
mapLength
id
prop
)
;
}
bool
SharedPropMap
:
:
addPropertyInReservedSlot
(
JSContext
*
cx
const
JSClass
*
clasp
MutableHandle
<
SharedPropMap
*
>
map
uint32_t
*
mapLength
HandleId
id
PropertyFlags
flags
uint32_t
slot
ObjectFlags
*
objectFlags
)
{
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
)
;
MOZ_ASSERT
(
slot
<
JSCLASS_RESERVED_SLOTS
(
clasp
)
)
;
MOZ_ASSERT_IF
(
map
map
-
>
lastUsedSlot
(
*
mapLength
)
<
slot
)
;
*
objectFlags
=
GetObjectFlagsForNewProperty
(
clasp
*
objectFlags
id
flags
cx
)
;
PropertyInfo
prop
=
PropertyInfo
(
flags
slot
)
;
return
addPropertyInternal
(
cx
map
mapLength
id
prop
)
;
}
bool
SharedPropMap
:
:
addPropertyWithKnownSlot
(
JSContext
*
cx
const
JSClass
*
clasp
MutableHandle
<
SharedPropMap
*
>
map
uint32_t
*
mapLength
HandleId
id
PropertyFlags
flags
uint32_t
slot
ObjectFlags
*
objectFlags
)
{
MOZ_ASSERT
(
!
flags
.
isCustomDataProperty
(
)
)
;
if
(
MOZ_UNLIKELY
(
slot
<
JSCLASS_RESERVED_SLOTS
(
clasp
)
)
)
{
return
addPropertyInReservedSlot
(
cx
clasp
map
mapLength
id
flags
slot
objectFlags
)
;
}
MOZ_ASSERT
(
slot
=
=
SharedPropMap
:
:
slotSpan
(
clasp
map
*
mapLength
)
)
;
MOZ_RELEASE_ASSERT
(
slot
<
=
SHAPE_MAXIMUM_SLOT
)
;
*
objectFlags
=
GetObjectFlagsForNewProperty
(
clasp
*
objectFlags
id
flags
cx
)
;
PropertyInfo
prop
=
PropertyInfo
(
flags
slot
)
;
return
addPropertyInternal
(
cx
map
mapLength
id
prop
)
;
}
bool
SharedPropMap
:
:
addCustomDataProperty
(
JSContext
*
cx
const
JSClass
*
clasp
MutableHandle
<
SharedPropMap
*
>
map
uint32_t
*
mapLength
HandleId
id
PropertyFlags
flags
ObjectFlags
*
objectFlags
)
{
MOZ_ASSERT
(
flags
.
isCustomDataProperty
(
)
)
;
uint32_t
slot
=
map
?
map
-
>
lastUsedSlot
(
*
mapLength
)
:
SHAPE_INVALID_SLOT
;
*
objectFlags
=
GetObjectFlagsForNewProperty
(
clasp
*
objectFlags
id
flags
cx
)
;
PropertyInfo
prop
=
PropertyInfo
(
flags
slot
)
;
return
addPropertyInternal
(
cx
map
mapLength
id
prop
)
;
}
bool
SharedPropMap
:
:
addPropertyInternal
(
JSContext
*
cx
MutableHandle
<
SharedPropMap
*
>
map
uint32_t
*
mapLength
HandleId
id
PropertyInfo
prop
)
{
if
(
!
map
)
{
MOZ_ASSERT
(
*
mapLength
=
=
0
)
;
map
.
set
(
SharedPropMap
:
:
createInitial
(
cx
id
prop
)
)
;
if
(
!
map
)
{
return
false
;
}
*
mapLength
=
1
;
return
true
;
}
MOZ_ASSERT
(
*
mapLength
>
0
)
;
if
(
*
mapLength
<
PropMap
:
:
Capacity
)
{
if
(
!
map
-
>
hasKey
(
*
mapLength
)
)
{
if
(
map
-
>
canHaveTable
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
PropMapTable
*
table
=
map
-
>
asLinked
(
)
-
>
maybeTable
(
nogc
)
)
{
if
(
!
table
-
>
add
(
cx
id
PropMapAndIndex
(
map
*
mapLength
)
)
)
{
return
false
;
}
}
}
map
-
>
initProperty
(
*
mapLength
id
prop
)
;
*
mapLength
+
=
1
;
return
true
;
}
if
(
map
-
>
matchProperty
(
*
mapLength
id
prop
)
)
{
*
mapLength
+
=
1
;
return
true
;
}
if
(
SharedPropMap
*
child
=
map
-
>
lookupChild
(
*
mapLength
id
prop
)
)
{
map
.
set
(
child
)
;
*
mapLength
+
=
1
;
return
true
;
}
SharedPropMap
*
child
=
SharedPropMap
:
:
clone
(
cx
map
*
mapLength
)
;
if
(
!
child
)
{
return
false
;
}
child
-
>
initProperty
(
*
mapLength
id
prop
)
;
SharedPropMapAndIndex
childEntry
(
child
*
mapLength
-
1
)
;
if
(
!
map
-
>
addChild
(
cx
childEntry
id
prop
)
)
{
return
false
;
}
map
.
set
(
child
)
;
*
mapLength
+
=
1
;
return
true
;
}
MOZ_ASSERT
(
*
mapLength
=
=
PropMap
:
:
Capacity
)
;
if
(
SharedPropMap
*
child
=
map
-
>
lookupChild
(
*
mapLength
id
prop
)
)
{
map
.
set
(
child
)
;
*
mapLength
=
1
;
return
true
;
}
SharedPropMap
*
child
=
SharedPropMap
:
:
create
(
cx
map
id
prop
)
;
if
(
!
child
)
{
return
false
;
}
SharedPropMapAndIndex
childEntry
(
child
PropMap
:
:
Capacity
-
1
)
;
if
(
!
map
-
>
addChild
(
cx
childEntry
id
prop
)
)
{
return
false
;
}
if
(
map
-
>
canHaveTable
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
PropMapTable
*
table
=
map
-
>
asLinked
(
)
-
>
maybeTable
(
nogc
)
)
{
if
(
table
-
>
add
(
cx
id
PropMapAndIndex
(
child
0
)
)
)
{
gc
:
:
PreWriteBarrier
(
map
.
get
(
)
)
;
map
-
>
asLinked
(
)
-
>
handOffTableTo
(
child
-
>
asLinked
(
)
)
;
}
else
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
}
}
map
.
set
(
child
)
;
*
mapLength
=
1
;
return
true
;
}
void
LinkedPropMap
:
:
handOffTableTo
(
LinkedPropMap
*
next
)
{
MOZ_ASSERT
(
hasTable
(
)
)
;
MOZ_ASSERT
(
!
next
-
>
hasTable
(
)
)
;
next
-
>
data_
.
table
=
data_
.
table
;
data_
.
table
=
nullptr
;
RemoveCellMemory
(
this
sizeof
(
PropMapTable
)
MemoryUse
:
:
PropMapTable
)
;
AddCellMemory
(
next
sizeof
(
PropMapTable
)
MemoryUse
:
:
PropMapTable
)
;
}
void
SharedPropMap
:
:
fixupAfterMovingGC
(
)
{
SharedChildrenPtr
&
childrenRef
=
treeDataRef
(
)
.
children
;
if
(
childrenRef
.
isNone
(
)
)
{
return
;
}
if
(
!
hasChildrenSet
(
)
)
{
SharedPropMapAndIndex
child
=
childrenRef
.
toSingleChild
(
)
;
if
(
gc
:
:
IsForwarded
(
child
.
map
(
)
)
)
{
child
=
SharedPropMapAndIndex
(
gc
:
:
Forwarded
(
child
.
map
(
)
)
child
.
index
(
)
)
;
childrenRef
.
setSingleChild
(
child
)
;
}
return
;
}
SharedChildrenSet
*
set
=
childrenRef
.
toChildrenSet
(
)
;
for
(
SharedChildrenSet
:
:
Enum
e
(
*
set
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
SharedPropMapAndIndex
child
=
e
.
front
(
)
;
if
(
IsForwarded
(
child
.
map
(
)
)
)
{
child
=
SharedPropMapAndIndex
(
Forwarded
(
child
.
map
(
)
)
child
.
index
(
)
)
;
e
.
mutableFront
(
)
=
child
;
}
}
}
void
SharedPropMap
:
:
removeChild
(
JSFreeOp
*
fop
SharedPropMap
*
child
)
{
SharedPropMapAndIndex
&
parentRef
=
child
-
>
treeDataRef
(
)
.
parent
;
MOZ_ASSERT
(
parentRef
.
map
(
)
=
=
this
)
;
uint32_t
index
=
parentRef
.
index
(
)
;
parentRef
.
setNone
(
)
;
SharedChildrenPtr
&
childrenRef
=
treeDataRef
(
)
.
children
;
MOZ_ASSERT
(
!
childrenRef
.
isNone
(
)
)
;
if
(
!
hasChildrenSet
(
)
)
{
MOZ_ASSERT
(
childrenRef
.
toSingleChild
(
)
.
map
(
)
=
=
child
)
;
MOZ_ASSERT
(
childrenRef
.
toSingleChild
(
)
.
index
(
)
=
=
index
)
;
childrenRef
.
setNone
(
)
;
return
;
}
SharedChildrenSet
*
set
=
childrenRef
.
toChildrenSet
(
)
;
{
uint32_t
nextIndex
=
SharedPropMap
:
:
indexOfNextProperty
(
index
)
;
SharedChildrenHasher
:
:
Lookup
lookup
(
child
-
>
getPropertyInfoWithKey
(
nextIndex
)
index
)
;
auto
p
=
set
-
>
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
"
Child
must
be
in
children
set
"
)
;
set
-
>
remove
(
p
)
;
}
MOZ_ASSERT
(
set
-
>
count
(
)
>
=
1
)
;
if
(
set
-
>
count
(
)
=
=
1
)
{
SharedChildrenSet
:
:
Range
r
=
set
-
>
all
(
)
;
SharedPropMapAndIndex
remainingChild
=
r
.
front
(
)
;
childrenRef
.
setSingleChild
(
remainingChild
)
;
clearHasChildrenSet
(
)
;
fop
-
>
delete_
(
this
set
MemoryUse
:
:
PropMapChildren
)
;
}
}
void
LinkedPropMap
:
:
purgeTable
(
JSFreeOp
*
fop
)
{
MOZ_ASSERT
(
hasTable
(
)
)
;
fop
-
>
delete_
(
this
data_
.
table
MemoryUse
:
:
PropMapTable
)
;
data_
.
table
=
nullptr
;
}
uint32_t
PropMap
:
:
approximateEntryCount
(
)
const
{
const
PropMap
*
map
=
this
;
uint32_t
count
=
0
;
JS
:
:
AutoCheckCannotGC
nogc
;
while
(
true
)
{
if
(
!
map
-
>
hasPrevious
(
)
)
{
return
count
+
PropMap
:
:
Capacity
;
}
if
(
PropMapTable
*
table
=
map
-
>
asLinked
(
)
-
>
maybeTable
(
nogc
)
)
{
return
count
+
table
-
>
entryCount
(
)
;
}
count
+
=
PropMap
:
:
Capacity
;
map
=
map
-
>
asLinked
(
)
-
>
previous
(
)
;
}
}
bool
PropMapTable
:
:
init
(
JSContext
*
cx
LinkedPropMap
*
map
)
{
if
(
!
set_
.
reserve
(
map
-
>
approximateEntryCount
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
PropMap
*
curMap
=
map
;
while
(
true
)
{
for
(
uint32_t
i
=
0
;
i
<
PropMap
:
:
Capacity
;
i
+
+
)
{
if
(
curMap
-
>
hasKey
(
i
)
)
{
PropertyKey
key
=
curMap
-
>
getKey
(
i
)
;
set_
.
putNewInfallible
(
key
PropMapAndIndex
(
curMap
i
)
)
;
}
}
if
(
!
curMap
-
>
hasPrevious
(
)
)
{
break
;
}
curMap
=
curMap
-
>
asLinked
(
)
-
>
previous
(
)
;
}
return
true
;
}
void
PropMapTable
:
:
trace
(
JSTracer
*
trc
)
{
purgeCache
(
)
;
for
(
Set
:
:
Enum
e
(
set_
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
PropMap
*
map
=
e
.
front
(
)
.
map
(
)
;
TraceManuallyBarrieredEdge
(
trc
&
map
"
PropMapTable
map
"
)
;
if
(
map
!
=
e
.
front
(
)
.
map
(
)
)
{
e
.
mutableFront
(
)
=
PropMapAndIndex
(
map
e
.
front
(
)
.
index
(
)
)
;
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
PropMapTable
:
:
checkAfterMovingGC
(
)
{
for
(
Set
:
:
Enum
e
(
set_
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
PropMap
*
map
=
e
.
front
(
)
.
map
(
)
;
MOZ_ASSERT
(
map
)
;
CheckGCThingAfterMovingGC
(
map
)
;
PropertyKey
key
=
map
-
>
getKey
(
e
.
front
(
)
.
index
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
key
.
isVoid
(
)
)
;
auto
p
=
lookupRaw
(
key
)
;
MOZ_RELEASE_ASSERT
(
p
.
found
(
)
&
&
*
p
=
=
e
.
front
(
)
)
;
}
}
#
endif
#
ifdef
DEBUG
bool
LinkedPropMap
:
:
canSkipMarkingTable
(
)
{
if
(
!
hasTable
(
)
)
{
return
true
;
}
PropMapTable
*
table
=
data_
.
table
;
uint32_t
count
=
0
;
PropMap
*
map
=
this
;
while
(
true
)
{
for
(
uint32_t
i
=
0
;
i
<
Capacity
;
i
+
+
)
{
if
(
map
-
>
hasKey
(
i
)
)
{
PropertyKey
key
=
map
-
>
getKey
(
i
)
;
PropMapTable
:
:
Ptr
p
=
table
-
>
lookupRaw
(
key
)
;
MOZ_ASSERT
(
*
p
=
=
PropMapAndIndex
(
map
i
)
)
;
count
+
+
;
}
}
if
(
!
map
-
>
hasPrevious
(
)
)
{
break
;
}
map
=
map
-
>
asLinked
(
)
-
>
previous
(
)
;
}
return
count
=
=
table
-
>
entryCount
(
)
;
}
#
endif
bool
LinkedPropMap
:
:
createTable
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
canHaveTable
(
)
)
;
MOZ_ASSERT
(
!
hasTable
(
)
)
;
UniquePtr
<
PropMapTable
>
table
=
cx
-
>
make_unique
<
PropMapTable
>
(
)
;
if
(
!
table
)
{
return
false
;
}
if
(
!
table
-
>
init
(
cx
this
)
)
{
return
false
;
}
data_
.
table
=
table
.
release
(
)
;
AddCellMemory
(
this
sizeof
(
PropMapTable
)
MemoryUse
:
:
PropMapTable
)
;
return
true
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
PropMap
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
}
