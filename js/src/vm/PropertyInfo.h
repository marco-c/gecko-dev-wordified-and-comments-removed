#
ifndef
vm_PropertyInfo_h
#
define
vm_PropertyInfo_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
util
/
EnumFlags
.
h
"
namespace
js
{
static
constexpr
uint32_t
SHAPE_INVALID_SLOT
=
Bit
(
24
)
-
1
;
static
constexpr
uint32_t
SHAPE_MAXIMUM_SLOT
=
Bit
(
24
)
-
2
;
enum
class
PropertyFlag
:
uint8_t
{
Configurable
=
1
<
<
0
Enumerable
=
1
<
<
1
Writable
=
1
<
<
2
AccessorProperty
=
1
<
<
3
CustomDataProperty
=
1
<
<
4
}
;
class
PropertyFlags
:
public
EnumFlags
<
PropertyFlag
>
{
using
Base
=
EnumFlags
<
PropertyFlag
>
;
using
Base
:
:
Base
;
public
:
static
const
PropertyFlags
defaultDataPropFlags
;
static
PropertyFlags
fromRaw
(
uint8_t
flags
)
{
return
PropertyFlags
(
flags
)
;
}
bool
configurable
(
)
const
{
return
hasFlag
(
PropertyFlag
:
:
Configurable
)
;
}
bool
enumerable
(
)
const
{
return
hasFlag
(
PropertyFlag
:
:
Enumerable
)
;
}
bool
writable
(
)
const
{
MOZ_ASSERT
(
isDataDescriptor
(
)
)
;
return
hasFlag
(
PropertyFlag
:
:
Writable
)
;
}
bool
isDataProperty
(
)
const
{
return
!
isAccessorProperty
(
)
&
&
!
isCustomDataProperty
(
)
;
}
bool
isAccessorProperty
(
)
const
{
return
hasFlag
(
PropertyFlag
:
:
AccessorProperty
)
;
}
bool
isCustomDataProperty
(
)
const
{
return
hasFlag
(
PropertyFlag
:
:
CustomDataProperty
)
;
}
bool
isDataDescriptor
(
)
const
{
return
!
isAccessorProperty
(
)
;
}
}
;
constexpr
PropertyFlags
PropertyFlags
:
:
defaultDataPropFlags
=
{
PropertyFlag
:
:
Configurable
PropertyFlag
:
:
Enumerable
PropertyFlag
:
:
Writable
}
;
template
<
typename
T
>
class
PropertyInfoBase
{
static_assert
(
std
:
:
is_same_v
<
T
uint32_t
>
|
|
std
:
:
is_same_v
<
T
uint16_t
>
)
;
static
constexpr
uint32_t
FlagsMask
=
0xff
;
static
constexpr
uint32_t
SlotShift
=
8
;
T
slotAndFlags_
=
0
;
static_assert
(
SHAPE_INVALID_SLOT
<
=
(
UINT32_MAX
>
>
SlotShift
)
"
SHAPE_INVALID_SLOT
must
fit
in
slotAndFlags_
"
)
;
static_assert
(
SHAPE_MAXIMUM_SLOT
<
=
(
UINT32_MAX
>
>
SlotShift
)
"
SHAPE_MAXIMUM_SLOT
must
fit
in
slotAndFlags_
"
)
;
PropertyInfoBase
(
)
=
default
;
template
<
typename
U
>
friend
class
PropertyInfoBase
;
friend
class
CompactPropMap
;
friend
class
LinkedPropMap
;
public
:
static
constexpr
size_t
MaxSlotNumber
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
>
>
SlotShift
;
PropertyInfoBase
(
PropertyFlags
flags
uint32_t
slot
)
:
slotAndFlags_
(
(
slot
<
<
SlotShift
)
|
flags
.
toRaw
(
)
)
{
MOZ_ASSERT
(
maybeSlot
(
)
=
=
slot
)
;
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
flags
)
;
}
template
<
typename
U
>
explicit
PropertyInfoBase
(
PropertyInfoBase
<
U
>
other
)
:
slotAndFlags_
(
other
.
slotAndFlags_
)
{
MOZ_ASSERT
(
slotAndFlags_
=
=
other
.
slotAndFlags_
)
;
}
bool
isDataProperty
(
)
const
{
return
flags
(
)
.
isDataProperty
(
)
;
}
bool
isCustomDataProperty
(
)
const
{
return
flags
(
)
.
isCustomDataProperty
(
)
;
}
bool
isAccessorProperty
(
)
const
{
return
flags
(
)
.
isAccessorProperty
(
)
;
}
bool
isDataDescriptor
(
)
const
{
return
flags
(
)
.
isDataDescriptor
(
)
;
}
bool
hasSlot
(
)
const
{
return
!
isCustomDataProperty
(
)
;
}
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
hasSlot
(
)
)
;
MOZ_ASSERT
(
maybeSlot
(
)
<
SHAPE_INVALID_SLOT
)
;
return
maybeSlot
(
)
;
}
uint32_t
maybeSlot
(
)
const
{
return
slotAndFlags_
>
>
SlotShift
;
}
PropertyFlags
flags
(
)
const
{
return
PropertyFlags
:
:
fromRaw
(
slotAndFlags_
&
FlagsMask
)
;
}
bool
writable
(
)
const
{
return
flags
(
)
.
writable
(
)
;
}
bool
configurable
(
)
const
{
return
flags
(
)
.
configurable
(
)
;
}
bool
enumerable
(
)
const
{
return
flags
(
)
.
enumerable
(
)
;
}
JS
:
:
PropertyAttributes
propAttributes
(
)
const
{
JS
:
:
PropertyAttributes
attrs
{
}
;
if
(
configurable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Configurable
;
}
if
(
enumerable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Enumerable
;
}
if
(
isDataDescriptor
(
)
&
&
writable
(
)
)
{
attrs
+
=
JS
:
:
PropertyAttribute
:
:
Writable
;
}
return
attrs
;
}
T
toRaw
(
)
const
{
return
slotAndFlags_
;
}
bool
operator
=
=
(
const
PropertyInfoBase
<
T
>
&
other
)
const
{
return
slotAndFlags_
=
=
other
.
slotAndFlags_
;
}
bool
operator
!
=
(
const
PropertyInfoBase
<
T
>
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
}
;
using
PropertyInfo
=
PropertyInfoBase
<
uint32_t
>
;
using
CompactPropertyInfo
=
PropertyInfoBase
<
uint16_t
>
;
static_assert
(
sizeof
(
PropertyInfo
)
=
=
sizeof
(
uint32_t
)
)
;
static_assert
(
sizeof
(
CompactPropertyInfo
)
=
=
sizeof
(
uint16_t
)
)
;
class
PropertyInfoWithKey
:
public
PropertyInfo
{
PropertyKey
key_
;
public
:
PropertyInfoWithKey
(
PropertyFlags
flags
uint32_t
slot
PropertyKey
key
)
:
PropertyInfo
(
flags
slot
)
key_
(
key
)
{
}
PropertyInfoWithKey
(
PropertyInfo
prop
PropertyKey
key
)
:
PropertyInfo
(
prop
)
key_
(
key
)
{
}
PropertyKey
key
(
)
const
{
return
key_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
key_
"
PropertyInfoWithKey
-
key
"
)
;
}
}
;
template
<
class
Wrapper
>
class
WrappedPtrOperations
<
PropertyInfoWithKey
Wrapper
>
{
const
PropertyInfoWithKey
&
value
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isDataProperty
(
)
const
{
return
value
(
)
.
isDataProperty
(
)
;
}
uint32_t
slot
(
)
const
{
return
value
(
)
.
slot
(
)
;
}
PropertyKey
key
(
)
const
{
return
value
(
)
.
key
(
)
;
}
PropertyFlags
flags
(
)
const
{
return
value
(
)
.
flags
(
)
;
}
}
;
using
PropertyInfoWithKeyVector
=
GCVector
<
PropertyInfoWithKey
8
>
;
}
#
endif
