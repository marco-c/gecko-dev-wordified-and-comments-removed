#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TaggedAnonymousMemory
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
string
.
h
>
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
__wasi__
)
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
<
tuple
>
#
include
<
type_traits
>
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
endif
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
SharedArrayBuffer
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
WindowsWrapper
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
SharedArrayObject
.
h
"
#
include
"
vm
/
Warnings
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmLog
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
#
include
"
gc
/
GCContext
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
ToInt32
;
using
js
:
:
wasm
:
:
IndexType
;
using
js
:
:
wasm
:
:
Pages
;
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
namespace
js
;
#
if
defined
(
MOZ_TSAN
)
|
|
defined
(
MOZ_ASAN
)
static
const
uint64_t
WasmMemAsanOverhead
=
2
;
#
else
static
const
uint64_t
WasmMemAsanOverhead
=
1
;
#
endif
#
if
defined
(
JS_CODEGEN_ARM64
)
&
&
defined
(
ANDROID
)
static
const
uint64_t
WasmReservedBytesMax
=
75
*
wasm
:
:
HugeMappedSize
/
WasmMemAsanOverhead
;
static
const
uint64_t
WasmReservedBytesStartTriggering
=
15
*
wasm
:
:
HugeMappedSize
;
static
const
uint64_t
WasmReservedBytesStartSyncFullGC
=
WasmReservedBytesMax
-
15
*
wasm
:
:
HugeMappedSize
;
static
const
uint64_t
WasmReservedBytesPerTrigger
=
15
*
wasm
:
:
HugeMappedSize
;
#
elif
defined
(
WASM_SUPPORTS_HUGE_MEMORY
)
static
const
uint64_t
WasmReservedBytesMax
=
1000
*
wasm
:
:
HugeMappedSize
/
WasmMemAsanOverhead
;
static
const
uint64_t
WasmReservedBytesStartTriggering
=
100
*
wasm
:
:
HugeMappedSize
;
static
const
uint64_t
WasmReservedBytesStartSyncFullGC
=
WasmReservedBytesMax
-
100
*
wasm
:
:
HugeMappedSize
;
static
const
uint64_t
WasmReservedBytesPerTrigger
=
100
*
wasm
:
:
HugeMappedSize
;
#
else
static
const
uint64_t
GiB
=
1024
*
1024
*
1024
;
static
const
uint64_t
WasmReservedBytesMax
=
(
4
*
GiB
)
/
2
/
WasmMemAsanOverhead
;
static
const
uint64_t
WasmReservedBytesStartTriggering
=
(
4
*
GiB
)
/
8
;
static
const
uint64_t
WasmReservedBytesStartSyncFullGC
=
WasmReservedBytesMax
-
(
4
*
GiB
)
/
8
;
static
const
uint64_t
WasmReservedBytesPerTrigger
=
(
4
*
GiB
)
/
8
;
#
endif
static
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
wasmReservedBytes
(
0
)
;
static
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
wasmReservedBytesSinceLast
(
0
)
;
uint64_t
js
:
:
WasmReservedBytes
(
)
{
return
wasmReservedBytes
;
}
[
[
nodiscard
]
]
static
bool
CheckArrayBufferTooLarge
(
JSContext
*
cx
uint64_t
nbytes
)
{
if
(
MOZ_UNLIKELY
(
nbytes
>
ArrayBufferObject
:
:
MaxByteLength
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
false
;
}
return
true
;
}
void
*
js
:
:
MapBufferMemory
(
wasm
:
:
IndexType
t
size_t
mappedSize
size_t
initialCommittedSize
)
{
MOZ_ASSERT
(
mappedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
initialCommittedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
initialCommittedSize
<
=
mappedSize
)
;
auto
failed
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
wasmReservedBytes
-
=
uint64_t
(
mappedSize
)
;
}
)
;
wasmReservedBytes
+
=
uint64_t
(
mappedSize
)
;
if
(
wasmReservedBytes
>
=
WasmReservedBytesMax
)
{
if
(
OnLargeAllocationFailure
)
{
OnLargeAllocationFailure
(
)
;
}
if
(
wasmReservedBytes
>
=
WasmReservedBytesMax
)
{
return
nullptr
;
}
}
#
ifdef
XP_WIN
void
*
data
=
VirtualAlloc
(
nullptr
mappedSize
MEM_RESERVE
PAGE_NOACCESS
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
(
!
VirtualAlloc
(
data
initialCommittedSize
MEM_COMMIT
PAGE_READWRITE
)
)
{
VirtualFree
(
data
0
MEM_RELEASE
)
;
return
nullptr
;
}
#
elif
defined
(
__wasi__
)
void
*
data
=
nullptr
;
if
(
int
err
=
posix_memalign
(
&
data
gc
:
:
SystemPageSize
(
)
mappedSize
)
)
{
MOZ_ASSERT
(
err
=
=
ENOMEM
)
;
return
nullptr
;
}
MOZ_ASSERT
(
data
)
;
memset
(
data
0
mappedSize
)
;
#
else
void
*
data
=
MozTaggedAnonymousMmap
(
nullptr
mappedSize
PROT_NONE
MAP_PRIVATE
|
MAP_ANON
-
1
0
"
wasm
-
reserved
"
)
;
if
(
data
=
=
MAP_FAILED
)
{
return
nullptr
;
}
if
(
mprotect
(
data
initialCommittedSize
PROT_READ
|
PROT_WRITE
)
)
{
munmap
(
data
mappedSize
)
;
return
nullptr
;
}
#
endif
#
if
defined
(
MOZ_VALGRIND
)
&
&
\
defined
(
VALGRIND_DISABLE_ADDR_ERROR_REPORTING_IN_RANGE
)
VALGRIND_DISABLE_ADDR_ERROR_REPORTING_IN_RANGE
(
(
unsigned
char
*
)
data
+
initialCommittedSize
mappedSize
-
initialCommittedSize
)
;
#
endif
failed
.
release
(
)
;
return
data
;
}
bool
js
:
:
CommitBufferMemory
(
void
*
dataEnd
size_t
delta
)
{
MOZ_ASSERT
(
delta
)
;
MOZ_ASSERT
(
delta
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
#
ifdef
XP_WIN
if
(
!
VirtualAlloc
(
dataEnd
delta
MEM_COMMIT
PAGE_READWRITE
)
)
{
return
false
;
}
#
elif
defined
(
__wasi__
)
return
true
;
#
else
if
(
mprotect
(
dataEnd
delta
PROT_READ
|
PROT_WRITE
)
)
{
return
false
;
}
#
endif
#
if
defined
(
MOZ_VALGRIND
)
&
&
\
defined
(
VALGRIND_DISABLE_ADDR_ERROR_REPORTING_IN_RANGE
)
VALGRIND_ENABLE_ADDR_ERROR_REPORTING_IN_RANGE
(
(
unsigned
char
*
)
dataEnd
delta
)
;
#
endif
return
true
;
}
bool
js
:
:
ExtendBufferMapping
(
void
*
dataPointer
size_t
mappedSize
size_t
newMappedSize
)
{
MOZ_ASSERT
(
mappedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
newMappedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
newMappedSize
>
=
mappedSize
)
;
#
ifdef
XP_WIN
void
*
mappedEnd
=
(
char
*
)
dataPointer
+
mappedSize
;
uint32_t
delta
=
newMappedSize
-
mappedSize
;
if
(
!
VirtualAlloc
(
mappedEnd
delta
MEM_RESERVE
PAGE_NOACCESS
)
)
{
return
false
;
}
return
true
;
#
elif
defined
(
__wasi__
)
return
false
;
#
elif
defined
(
XP_LINUX
)
if
(
MAP_FAILED
=
=
mremap
(
dataPointer
mappedSize
newMappedSize
0
)
)
{
return
false
;
}
return
true
;
#
else
return
false
;
#
endif
}
void
js
:
:
UnmapBufferMemory
(
wasm
:
:
IndexType
t
void
*
base
size_t
mappedSize
)
{
MOZ_ASSERT
(
mappedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
#
ifdef
XP_WIN
VirtualFree
(
base
0
MEM_RELEASE
)
;
#
elif
defined
(
__wasi__
)
free
(
base
)
;
#
else
munmap
(
base
mappedSize
)
;
#
endif
#
if
defined
(
MOZ_VALGRIND
)
&
&
\
defined
(
VALGRIND_ENABLE_ADDR_ERROR_REPORTING_IN_RANGE
)
VALGRIND_ENABLE_ADDR_ERROR_REPORTING_IN_RANGE
(
(
unsigned
char
*
)
base
mappedSize
)
;
#
endif
wasmReservedBytes
-
=
uint64_t
(
mappedSize
)
;
}
static
const
JSClassOps
ArrayBufferObjectClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ArrayBufferObject
:
:
finalize
nullptr
nullptr
nullptr
}
;
static
const
JSFunctionSpec
arraybuffer_functions
[
]
=
{
JS_FN
(
"
isView
"
ArrayBufferObject
:
:
fun_isView
1
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
arraybuffer_properties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
ArrayBufferSpecies
"
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
arraybuffer_proto_functions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
slice
"
"
ArrayBufferSlice
"
2
0
)
JS_FN
(
"
transfer
"
ArrayBufferObject
:
:
transfer
0
0
)
JS_FN
(
"
transferToFixedLength
"
ArrayBufferObject
:
:
transferToFixedLength
0
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
arraybuffer_proto_properties
[
]
=
{
JS_PSG
(
"
byteLength
"
ArrayBufferObject
:
:
byteLengthGetter
0
)
JS_PSG
(
"
detached
"
ArrayBufferObject
:
:
detachedGetter
0
)
JS_STRING_SYM_PS
(
toStringTag
"
ArrayBuffer
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
ClassSpec
ArrayBufferObjectClassSpec
=
{
GenericCreateConstructor
<
ArrayBufferObject
:
:
class_constructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
ArrayBufferObject
>
arraybuffer_functions
arraybuffer_properties
arraybuffer_proto_functions
arraybuffer_proto_properties
}
;
static
const
ClassExtension
ArrayBufferObjectClassExtension
=
{
ArrayBufferObject
:
:
objectMoved
}
;
const
JSClass
ArrayBufferObject
:
:
class_
=
{
"
ArrayBuffer
"
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_HAS_RESERVED_SLOTS
(
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_ArrayBuffer
)
|
JSCLASS_BACKGROUND_FINALIZE
&
ArrayBufferObjectClassOps
&
ArrayBufferObjectClassSpec
&
ArrayBufferObjectClassExtension
}
;
const
JSClass
ArrayBufferObject
:
:
protoClass_
=
{
"
ArrayBuffer
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_ArrayBuffer
)
JS_NULL_CLASS_OPS
&
ArrayBufferObjectClassSpec
}
;
static
bool
IsArrayBuffer
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
ArrayBufferObject
>
(
)
;
}
MOZ_ALWAYS_INLINE
bool
ArrayBufferObject
:
:
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsArrayBuffer
(
args
.
thisv
(
)
)
)
;
auto
*
buffer
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
buffer
-
>
byteLength
(
)
)
;
return
true
;
}
bool
ArrayBufferObject
:
:
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsArrayBuffer
byteLengthGetterImpl
>
(
cx
args
)
;
}
static
ArrayBufferObject
*
ArrayBufferCopyAndDetach
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
arrayBuffer
Handle
<
Value
>
newLength
)
{
uint64_t
newByteLength
;
if
(
newLength
.
isUndefined
(
)
)
{
newByteLength
=
arrayBuffer
-
>
byteLength
(
)
;
}
else
{
if
(
!
ToIndex
(
cx
newLength
&
newByteLength
)
)
{
return
nullptr
;
}
}
if
(
arrayBuffer
-
>
isDetached
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
if
(
arrayBuffer
-
>
hasDefinedDetachKey
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_TRANSFER
)
;
return
nullptr
;
}
if
(
!
CheckArrayBufferTooLarge
(
cx
newByteLength
)
)
{
return
nullptr
;
}
return
ArrayBufferObject
:
:
copyAndDetach
(
cx
size_t
(
newByteLength
)
arrayBuffer
)
;
}
bool
ArrayBufferObject
:
:
detachedGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsArrayBuffer
(
args
.
thisv
(
)
)
)
;
auto
*
buffer
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
;
args
.
rval
(
)
.
setBoolean
(
buffer
-
>
isDetached
(
)
)
;
return
true
;
}
bool
ArrayBufferObject
:
:
detachedGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsArrayBuffer
detachedGetterImpl
>
(
cx
args
)
;
}
bool
ArrayBufferObject
:
:
transferImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsArrayBuffer
(
args
.
thisv
(
)
)
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
)
;
auto
*
newBuffer
=
ArrayBufferCopyAndDetach
(
cx
buffer
args
.
get
(
0
)
)
;
if
(
!
newBuffer
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
newBuffer
)
;
return
true
;
}
bool
ArrayBufferObject
:
:
transfer
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsArrayBuffer
transferImpl
>
(
cx
args
)
;
}
bool
ArrayBufferObject
:
:
transferToFixedLengthImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsArrayBuffer
(
args
.
thisv
(
)
)
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
ArrayBufferObject
>
(
)
)
;
auto
*
newBuffer
=
ArrayBufferCopyAndDetach
(
cx
buffer
args
.
get
(
0
)
)
;
if
(
!
newBuffer
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
newBuffer
)
;
return
true
;
}
bool
ArrayBufferObject
:
:
transferToFixedLength
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsArrayBuffer
transferToFixedLengthImpl
>
(
cx
args
)
;
}
bool
ArrayBufferObject
:
:
fun_isView
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setBoolean
(
args
.
get
(
0
)
.
isObject
(
)
&
&
JS_IsArrayBufferViewObject
(
&
args
.
get
(
0
)
.
toObject
(
)
)
)
;
return
true
;
}
bool
ArrayBufferObject
:
:
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
ArrayBuffer
"
)
)
{
return
false
;
}
uint64_t
byteLength
;
if
(
!
ToIndex
(
cx
args
.
get
(
0
)
&
byteLength
)
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_ArrayBuffer
&
proto
)
)
{
return
false
;
}
if
(
!
CheckArrayBufferTooLarge
(
cx
byteLength
)
)
{
return
false
;
}
JSObject
*
bufobj
=
createZeroed
(
cx
byteLength
proto
)
;
if
(
!
bufobj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
bufobj
)
;
return
true
;
}
using
ArrayBufferContents
=
UniquePtr
<
uint8_t
[
]
JS
:
:
FreePolicy
>
;
static
ArrayBufferContents
AllocateUninitializedArrayBufferContents
(
JSContext
*
cx
size_t
nbytes
)
{
uint8_t
*
p
=
cx
-
>
maybe_pod_arena_malloc
<
uint8_t
>
(
js
:
:
ArrayBufferContentsArena
nbytes
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
p
=
static_cast
<
uint8_t
*
>
(
cx
-
>
runtime
(
)
-
>
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Malloc
js
:
:
ArrayBufferContentsArena
nbytes
)
)
;
if
(
!
p
)
{
ReportOutOfMemory
(
cx
)
;
}
}
return
ArrayBufferContents
(
p
)
;
}
static
ArrayBufferContents
AllocateArrayBufferContents
(
JSContext
*
cx
size_t
nbytes
)
{
uint8_t
*
p
=
cx
-
>
maybe_pod_arena_calloc
<
uint8_t
>
(
js
:
:
ArrayBufferContentsArena
nbytes
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
p
=
static_cast
<
uint8_t
*
>
(
cx
-
>
runtime
(
)
-
>
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Calloc
js
:
:
ArrayBufferContentsArena
nbytes
)
)
;
if
(
!
p
)
{
ReportOutOfMemory
(
cx
)
;
}
}
return
ArrayBufferContents
(
p
)
;
}
static
ArrayBufferContents
ReallocateArrayBufferContents
(
JSContext
*
cx
uint8_t
*
old
size_t
oldSize
size_t
newSize
)
{
uint8_t
*
p
=
cx
-
>
maybe_pod_arena_realloc
<
uint8_t
>
(
js
:
:
ArrayBufferContentsArena
old
oldSize
newSize
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
p
=
static_cast
<
uint8_t
*
>
(
cx
-
>
runtime
(
)
-
>
onOutOfMemoryCanGC
(
js
:
:
AllocFunction
:
:
Realloc
js
:
:
ArrayBufferContentsArena
newSize
old
)
)
;
if
(
!
p
)
{
ReportOutOfMemory
(
cx
)
;
}
}
return
ArrayBufferContents
(
p
)
;
}
static
ArrayBufferContents
NewCopiedBufferContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
{
ArrayBufferContents
dataCopy
=
AllocateUninitializedArrayBufferContents
(
cx
buffer
-
>
byteLength
(
)
)
;
if
(
dataCopy
)
{
if
(
auto
count
=
buffer
-
>
byteLength
(
)
)
{
memcpy
(
dataCopy
.
get
(
)
buffer
-
>
dataPointer
(
)
count
)
;
}
}
return
dataCopy
;
}
void
ArrayBufferObject
:
:
detach
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
{
cx
-
>
check
(
buffer
)
;
MOZ_ASSERT
(
!
buffer
-
>
isPreparedForAsmJS
(
)
)
;
MOZ_ASSERT
(
!
buffer
-
>
isLengthPinned
(
)
)
;
auto
&
innerViews
=
ObjectRealm
:
:
get
(
buffer
)
.
innerViews
.
get
(
)
;
if
(
InnerViewTable
:
:
ViewVector
*
views
=
innerViews
.
maybeViewsUnbarriered
(
buffer
)
)
{
for
(
size_t
i
=
0
;
i
<
views
-
>
length
(
)
;
i
+
+
)
{
JSObject
*
view
=
(
*
views
)
[
i
]
;
view
-
>
as
<
ArrayBufferViewObject
>
(
)
.
notifyBufferDetached
(
)
;
}
innerViews
.
removeViews
(
buffer
)
;
}
if
(
JSObject
*
view
=
buffer
-
>
firstView
(
)
)
{
view
-
>
as
<
ArrayBufferViewObject
>
(
)
.
notifyBufferDetached
(
)
;
buffer
-
>
setFirstView
(
nullptr
)
;
}
if
(
buffer
-
>
dataPointer
(
)
)
{
buffer
-
>
releaseData
(
cx
-
>
gcContext
(
)
)
;
buffer
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
}
buffer
-
>
setByteLength
(
0
)
;
buffer
-
>
setIsDetached
(
)
;
}
[
[
nodiscard
]
]
bool
WasmArrayRawBuffer
:
:
growToPagesInPlace
(
Pages
newPages
)
{
size_t
newSize
=
newPages
.
byteLength
(
)
;
size_t
oldSize
=
byteLength
(
)
;
MOZ_ASSERT
(
newSize
>
=
oldSize
)
;
MOZ_ASSERT
(
newPages
<
=
clampedMaxPages
(
)
)
;
MOZ_ASSERT
(
newSize
<
=
mappedSize
(
)
)
;
size_t
delta
=
newSize
-
oldSize
;
MOZ_ASSERT
(
delta
%
wasm
:
:
PageSize
=
=
0
)
;
uint8_t
*
dataEnd
=
dataPointer
(
)
+
oldSize
;
MOZ_ASSERT
(
uintptr_t
(
dataEnd
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
if
(
delta
&
&
!
CommitBufferMemory
(
dataEnd
delta
)
)
{
return
false
;
}
length_
=
newSize
;
return
true
;
}
bool
WasmArrayRawBuffer
:
:
extendMappedSize
(
Pages
maxPages
)
{
size_t
newMappedSize
=
wasm
:
:
ComputeMappedSize
(
maxPages
)
;
MOZ_ASSERT
(
mappedSize_
<
=
newMappedSize
)
;
if
(
mappedSize_
=
=
newMappedSize
)
{
return
true
;
}
if
(
!
ExtendBufferMapping
(
dataPointer
(
)
mappedSize_
newMappedSize
)
)
{
return
false
;
}
mappedSize_
=
newMappedSize
;
return
true
;
}
void
WasmArrayRawBuffer
:
:
tryGrowMaxPagesInPlace
(
Pages
deltaMaxPages
)
{
Pages
newMaxPages
=
clampedMaxPages_
;
DebugOnly
<
bool
>
valid
=
newMaxPages
.
checkedIncrement
(
deltaMaxPages
)
;
MOZ_ASSERT
(
valid
)
;
MOZ_ASSERT_IF
(
sourceMaxPages_
.
isSome
(
)
newMaxPages
<
=
*
sourceMaxPages_
)
;
if
(
!
extendMappedSize
(
newMaxPages
)
)
{
return
;
}
clampedMaxPages_
=
newMaxPages
;
}
void
WasmArrayRawBuffer
:
:
discard
(
size_t
byteOffset
size_t
byteLen
)
{
uint8_t
*
memBase
=
dataPointer
(
)
;
MOZ_ASSERT
(
byteOffset
%
wasm
:
:
PageSize
=
=
0
)
;
MOZ_ASSERT
(
byteLen
%
wasm
:
:
PageSize
=
=
0
)
;
MOZ_ASSERT
(
wasm
:
:
MemoryBoundsCheck
(
uint64_t
(
byteOffset
)
uint64_t
(
byteLen
)
byteLength
(
)
)
)
;
if
(
byteLen
=
=
0
)
{
return
;
}
void
*
addr
=
memBase
+
uintptr_t
(
byteOffset
)
;
#
ifdef
XP_WIN
if
(
!
VirtualFree
(
addr
byteLen
MEM_DECOMMIT
)
)
{
MOZ_CRASH
(
"
wasm
discard
:
failed
to
decommit
memory
"
)
;
}
if
(
!
VirtualAlloc
(
addr
byteLen
MEM_COMMIT
PAGE_READWRITE
)
)
{
MOZ_CRASH
(
"
wasm
discard
:
decommitted
memory
but
failed
to
recommit
"
)
;
}
;
#
elif
defined
(
__wasi__
)
memset
(
addr
0
byteLen
)
;
#
else
void
*
data
=
MozTaggedAnonymousMmap
(
addr
byteLen
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANON
|
MAP_FIXED
-
1
0
"
wasm
-
reserved
"
)
;
if
(
data
=
=
MAP_FAILED
)
{
MOZ_CRASH
(
"
failed
to
discard
wasm
memory
;
memory
mappings
may
be
broken
"
)
;
}
#
endif
}
WasmArrayRawBuffer
*
WasmArrayRawBuffer
:
:
AllocateWasm
(
IndexType
indexType
Pages
initialPages
Pages
clampedMaxPages
const
Maybe
<
Pages
>
&
sourceMaxPages
const
Maybe
<
size_t
>
&
mapped
)
{
MOZ_ASSERT
(
initialPages
.
hasByteLength
(
)
)
;
size_t
numBytes
=
initialPages
.
byteLength
(
)
;
Pages
initialMappedPages
=
sourceMaxPages
.
isSome
(
)
?
clampedMaxPages
:
initialPages
;
size_t
mappedSize
=
mapped
.
isSome
(
)
?
*
mapped
:
wasm
:
:
ComputeMappedSize
(
initialMappedPages
)
;
MOZ_RELEASE_ASSERT
(
mappedSize
<
=
SIZE_MAX
-
gc
:
:
SystemPageSize
(
)
)
;
MOZ_RELEASE_ASSERT
(
numBytes
<
=
SIZE_MAX
-
gc
:
:
SystemPageSize
(
)
)
;
MOZ_RELEASE_ASSERT
(
initialPages
<
=
clampedMaxPages
)
;
MOZ_ASSERT
(
numBytes
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
mappedSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
uint64_t
mappedSizeWithHeader
=
mappedSize
+
gc
:
:
SystemPageSize
(
)
;
uint64_t
numBytesWithHeader
=
numBytes
+
gc
:
:
SystemPageSize
(
)
;
void
*
data
=
MapBufferMemory
(
indexType
(
size_t
)
mappedSizeWithHeader
(
size_t
)
numBytesWithHeader
)
;
if
(
!
data
)
{
return
nullptr
;
}
uint8_t
*
base
=
reinterpret_cast
<
uint8_t
*
>
(
data
)
+
gc
:
:
SystemPageSize
(
)
;
uint8_t
*
header
=
base
-
sizeof
(
WasmArrayRawBuffer
)
;
auto
rawBuf
=
new
(
header
)
WasmArrayRawBuffer
(
indexType
base
clampedMaxPages
sourceMaxPages
mappedSize
numBytes
)
;
return
rawBuf
;
}
void
WasmArrayRawBuffer
:
:
Release
(
void
*
mem
)
{
WasmArrayRawBuffer
*
header
=
(
WasmArrayRawBuffer
*
)
(
(
uint8_t
*
)
mem
-
sizeof
(
WasmArrayRawBuffer
)
)
;
MOZ_RELEASE_ASSERT
(
header
-
>
mappedSize
(
)
<
=
SIZE_MAX
-
gc
:
:
SystemPageSize
(
)
)
;
size_t
mappedSizeWithHeader
=
header
-
>
mappedSize
(
)
+
gc
:
:
SystemPageSize
(
)
;
static_assert
(
std
:
:
is_trivially_destructible_v
<
WasmArrayRawBuffer
>
"
no
need
to
call
the
destructor
"
)
;
UnmapBufferMemory
(
header
-
>
indexType
(
)
header
-
>
basePointer
(
)
mappedSizeWithHeader
)
;
}
WasmArrayRawBuffer
*
ArrayBufferObject
:
:
BufferContents
:
:
wasmBuffer
(
)
const
{
MOZ_RELEASE_ASSERT
(
kind_
=
=
WASM
)
;
return
(
WasmArrayRawBuffer
*
)
(
data_
-
sizeof
(
WasmArrayRawBuffer
)
)
;
}
template
<
typename
ObjT
typename
RawbufT
>
static
ArrayBufferObjectMaybeShared
*
CreateSpecificWasmBuffer
(
JSContext
*
cx
const
wasm
:
:
MemoryDesc
&
memory
)
{
bool
useHugeMemory
=
wasm
:
:
IsHugeMemoryEnabled
(
memory
.
indexType
(
)
)
;
Pages
initialPages
=
memory
.
initialPages
(
)
;
Maybe
<
Pages
>
sourceMaxPages
=
memory
.
maximumPages
(
)
;
Pages
clampedMaxPages
=
wasm
:
:
ClampedMaxPages
(
memory
.
indexType
(
)
initialPages
sourceMaxPages
useHugeMemory
)
;
Maybe
<
size_t
>
mappedSize
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
if
(
useHugeMemory
)
{
mappedSize
=
Some
(
wasm
:
:
HugeMappedSize
)
;
}
#
endif
RawbufT
*
buffer
=
RawbufT
:
:
AllocateWasm
(
memory
.
limits
.
indexType
initialPages
clampedMaxPages
sourceMaxPages
mappedSize
)
;
if
(
!
buffer
)
{
if
(
useHugeMemory
)
{
WarnNumberASCII
(
cx
JSMSG_WASM_HUGE_MEMORY_FAILED
)
;
if
(
cx
-
>
isExceptionPending
(
)
)
{
cx
-
>
clearPendingException
(
)
;
}
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
if
(
!
sourceMaxPages
)
{
wasm
:
:
Log
(
cx
"
new
Memory
(
{
initial
=
%
"
PRIu64
"
pages
}
)
failed
"
initialPages
.
value
(
)
)
;
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
uint64_t
cur
=
clampedMaxPages
.
value
(
)
/
2
;
for
(
;
Pages
(
cur
)
>
initialPages
;
cur
/
=
2
)
{
buffer
=
RawbufT
:
:
AllocateWasm
(
memory
.
limits
.
indexType
initialPages
Pages
(
cur
)
sourceMaxPages
mappedSize
)
;
if
(
buffer
)
{
break
;
}
}
if
(
!
buffer
)
{
wasm
:
:
Log
(
cx
"
new
Memory
(
{
initial
=
%
"
PRIu64
"
pages
}
)
failed
"
initialPages
.
value
(
)
)
;
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
for
(
size_t
d
=
cur
/
2
;
d
>
=
1
;
d
/
=
2
)
{
buffer
-
>
tryGrowMaxPagesInPlace
(
Pages
(
d
)
)
;
}
}
Rooted
<
ArrayBufferObjectMaybeShared
*
>
object
(
cx
ObjT
:
:
createFromNewRawBuffer
(
cx
buffer
initialPages
.
byteLength
(
)
)
)
;
if
(
!
object
)
{
return
nullptr
;
}
if
(
wasmReservedBytes
>
WasmReservedBytesStartSyncFullGC
)
{
JS
:
:
PrepareForFullGC
(
cx
)
;
JS
:
:
NonIncrementalGC
(
cx
JS
:
:
GCOptions
:
:
Normal
JS
:
:
GCReason
:
:
TOO_MUCH_WASM_MEMORY
)
;
wasmReservedBytesSinceLast
=
0
;
}
else
if
(
wasmReservedBytes
>
WasmReservedBytesStartTriggering
)
{
wasmReservedBytesSinceLast
+
=
uint64_t
(
buffer
-
>
mappedSize
(
)
)
;
if
(
wasmReservedBytesSinceLast
>
WasmReservedBytesPerTrigger
)
{
(
void
)
cx
-
>
runtime
(
)
-
>
gc
.
triggerGC
(
JS
:
:
GCReason
:
:
TOO_MUCH_WASM_MEMORY
)
;
wasmReservedBytesSinceLast
=
0
;
}
}
else
{
wasmReservedBytesSinceLast
=
0
;
}
if
(
sourceMaxPages
)
{
if
(
useHugeMemory
)
{
wasm
:
:
Log
(
cx
"
new
Memory
(
{
initial
:
%
"
PRIu64
"
pages
maximum
:
%
"
PRIu64
"
pages
}
)
succeeded
"
initialPages
.
value
(
)
sourceMaxPages
-
>
value
(
)
)
;
}
else
{
wasm
:
:
Log
(
cx
"
new
Memory
(
{
initial
:
%
"
PRIu64
"
pages
maximum
:
%
"
PRIu64
"
pages
}
)
succeeded
"
"
with
internal
maximum
of
%
"
PRIu64
"
pages
"
initialPages
.
value
(
)
sourceMaxPages
-
>
value
(
)
object
-
>
wasmClampedMaxPages
(
)
.
value
(
)
)
;
}
}
else
{
wasm
:
:
Log
(
cx
"
new
Memory
(
{
initial
:
%
"
PRIu64
"
pages
}
)
succeeded
"
initialPages
.
value
(
)
)
;
}
return
object
;
}
ArrayBufferObjectMaybeShared
*
js
:
:
CreateWasmBuffer
(
JSContext
*
cx
const
wasm
:
:
MemoryDesc
&
memory
)
{
MOZ_RELEASE_ASSERT
(
memory
.
initialPages
(
)
<
=
wasm
:
:
MaxMemoryPages
(
memory
.
indexType
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
cx
-
>
wasm
(
)
.
haveSignalHandlers
)
;
if
(
memory
.
isShared
(
)
)
{
if
(
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_SHMEM_LINK
)
;
return
nullptr
;
}
return
CreateSpecificWasmBuffer
<
SharedArrayBufferObject
WasmSharedArrayRawBuffer
>
(
cx
memory
)
;
}
return
CreateSpecificWasmBuffer
<
ArrayBufferObject
WasmArrayRawBuffer
>
(
cx
memory
)
;
}
bool
ArrayBufferObject
:
:
prepareForAsmJS
(
)
{
MOZ_ASSERT
(
byteLength
(
)
%
wasm
:
:
PageSize
=
=
0
"
prior
size
checking
should
have
guaranteed
page
-
size
multiple
"
)
;
MOZ_ASSERT
(
byteLength
(
)
>
0
"
prior
size
checking
should
have
excluded
empty
buffers
"
)
;
MOZ_ASSERT
(
!
isResizable
(
)
"
prior
checks
should
have
excluded
resizable
buffers
"
)
;
switch
(
bufferKind
(
)
)
{
case
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
:
case
MALLOCED_UNKNOWN_ARENA
:
case
MAPPED
:
case
EXTERNAL
:
setIsPreparedForAsmJS
(
)
;
return
true
;
case
INLINE_DATA
:
static_assert
(
wasm
:
:
PageSize
>
MaxInlineBytes
"
inline
data
must
be
too
small
to
be
a
page
size
multiple
"
)
;
MOZ_ASSERT_UNREACHABLE
(
"
inline
-
data
buffers
should
be
implicitly
excluded
by
size
checks
"
)
;
return
false
;
case
NO_DATA
:
MOZ_ASSERT_UNREACHABLE
(
"
size
checking
should
have
excluded
detached
or
empty
buffers
"
)
;
return
false
;
case
USER_OWNED
:
case
WASM
:
MOZ_ASSERT
(
!
isPreparedForAsmJS
(
)
)
;
return
false
;
}
MOZ_ASSERT_UNREACHABLE
(
"
non
-
exhaustive
kind
-
handling
switch
?
"
)
;
return
false
;
}
ArrayBufferObject
:
:
BufferContents
ArrayBufferObject
:
:
createMappedContents
(
int
fd
size_t
offset
size_t
length
)
{
void
*
data
=
gc
:
:
AllocateMappedContent
(
fd
offset
length
ARRAY_BUFFER_ALIGNMENT
)
;
return
BufferContents
:
:
createMapped
(
data
)
;
}
uint8_t
*
ArrayBufferObject
:
:
inlineDataPointer
(
)
const
{
return
static_cast
<
uint8_t
*
>
(
fixedData
(
JSCLASS_RESERVED_SLOTS
(
&
class_
)
)
)
;
}
uint8_t
*
ArrayBufferObject
:
:
dataPointer
(
)
const
{
return
static_cast
<
uint8_t
*
>
(
getFixedSlot
(
DATA_SLOT
)
.
toPrivate
(
)
)
;
}
SharedMem
<
uint8_t
*
>
ArrayBufferObject
:
:
dataPointerShared
(
)
const
{
return
SharedMem
<
uint8_t
*
>
:
:
unshared
(
getFixedSlot
(
DATA_SLOT
)
.
toPrivate
(
)
)
;
}
ArrayBufferObject
:
:
FreeInfo
*
ArrayBufferObject
:
:
freeInfo
(
)
const
{
MOZ_ASSERT
(
isExternal
(
)
)
;
return
reinterpret_cast
<
FreeInfo
*
>
(
inlineDataPointer
(
)
)
;
}
void
ArrayBufferObject
:
:
releaseData
(
JS
:
:
GCContext
*
gcx
)
{
switch
(
bufferKind
(
)
)
{
case
INLINE_DATA
:
break
;
case
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
:
case
MALLOCED_UNKNOWN_ARENA
:
gcx
-
>
free_
(
this
dataPointer
(
)
byteLength
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
break
;
case
NO_DATA
:
MOZ_ASSERT
(
dataPointer
(
)
=
=
nullptr
)
;
break
;
case
USER_OWNED
:
break
;
case
MAPPED
:
gc
:
:
DeallocateMappedContent
(
dataPointer
(
)
byteLength
(
)
)
;
gcx
-
>
removeCellMemory
(
this
associatedBytes
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
break
;
case
WASM
:
WasmArrayRawBuffer
:
:
Release
(
dataPointer
(
)
)
;
gcx
-
>
removeCellMemory
(
this
byteLength
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
break
;
case
EXTERNAL
:
MOZ_ASSERT
(
freeInfo
(
)
-
>
freeFunc
)
;
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
freeInfo
(
)
-
>
freeFunc
(
dataPointer
(
)
freeInfo
(
)
-
>
freeUserData
)
;
}
break
;
}
}
void
ArrayBufferObject
:
:
setDataPointer
(
BufferContents
contents
)
{
setFixedSlot
(
DATA_SLOT
PrivateValue
(
contents
.
data
(
)
)
)
;
setFlags
(
(
flags
(
)
&
~
KIND_MASK
)
|
contents
.
kind
(
)
)
;
if
(
isExternal
(
)
)
{
auto
info
=
freeInfo
(
)
;
info
-
>
freeFunc
=
contents
.
freeFunc
(
)
;
info
-
>
freeUserData
=
contents
.
freeUserData
(
)
;
}
}
size_t
ArrayBufferObject
:
:
byteLength
(
)
const
{
return
size_t
(
getFixedSlot
(
BYTE_LENGTH_SLOT
)
.
toPrivate
(
)
)
;
}
inline
size_t
ArrayBufferObject
:
:
associatedBytes
(
)
const
{
if
(
isMalloced
(
)
)
{
return
byteLength
(
)
;
}
if
(
isMapped
(
)
)
{
return
RoundUp
(
byteLength
(
)
js
:
:
gc
:
:
SystemPageSize
(
)
)
;
}
MOZ_CRASH
(
"
Unexpected
buffer
kind
"
)
;
}
void
ArrayBufferObject
:
:
setByteLength
(
size_t
length
)
{
MOZ_ASSERT
(
length
<
=
ArrayBufferObject
:
:
MaxByteLength
)
;
setFixedSlot
(
BYTE_LENGTH_SLOT
PrivateValue
(
length
)
)
;
}
size_t
ArrayBufferObject
:
:
wasmMappedSize
(
)
const
{
if
(
isWasm
(
)
)
{
return
contents
(
)
.
wasmBuffer
(
)
-
>
mappedSize
(
)
;
}
return
byteLength
(
)
;
}
IndexType
ArrayBufferObject
:
:
wasmIndexType
(
)
const
{
if
(
isWasm
(
)
)
{
return
contents
(
)
.
wasmBuffer
(
)
-
>
indexType
(
)
;
}
MOZ_ASSERT
(
isPreparedForAsmJS
(
)
)
;
return
wasm
:
:
IndexType
:
:
I32
;
}
Pages
ArrayBufferObject
:
:
wasmPages
(
)
const
{
if
(
isWasm
(
)
)
{
return
contents
(
)
.
wasmBuffer
(
)
-
>
pages
(
)
;
}
MOZ_ASSERT
(
isPreparedForAsmJS
(
)
)
;
return
Pages
:
:
fromByteLengthExact
(
byteLength
(
)
)
;
}
Pages
ArrayBufferObject
:
:
wasmClampedMaxPages
(
)
const
{
if
(
isWasm
(
)
)
{
return
contents
(
)
.
wasmBuffer
(
)
-
>
clampedMaxPages
(
)
;
}
MOZ_ASSERT
(
isPreparedForAsmJS
(
)
)
;
return
Pages
:
:
fromByteLengthExact
(
byteLength
(
)
)
;
}
Maybe
<
Pages
>
ArrayBufferObject
:
:
wasmSourceMaxPages
(
)
const
{
if
(
isWasm
(
)
)
{
return
contents
(
)
.
wasmBuffer
(
)
-
>
sourceMaxPages
(
)
;
}
MOZ_ASSERT
(
isPreparedForAsmJS
(
)
)
;
return
Some
<
Pages
>
(
Pages
:
:
fromByteLengthExact
(
byteLength
(
)
)
)
;
}
size_t
js
:
:
WasmArrayBufferMappedSize
(
const
ArrayBufferObjectMaybeShared
*
buf
)
{
if
(
buf
-
>
is
<
ArrayBufferObject
>
(
)
)
{
return
buf
-
>
as
<
ArrayBufferObject
>
(
)
.
wasmMappedSize
(
)
;
}
return
buf
-
>
as
<
SharedArrayBufferObject
>
(
)
.
wasmMappedSize
(
)
;
}
IndexType
js
:
:
WasmArrayBufferIndexType
(
const
ArrayBufferObjectMaybeShared
*
buf
)
{
if
(
buf
-
>
is
<
ArrayBufferObject
>
(
)
)
{
return
buf
-
>
as
<
ArrayBufferObject
>
(
)
.
wasmIndexType
(
)
;
}
return
buf
-
>
as
<
SharedArrayBufferObject
>
(
)
.
wasmIndexType
(
)
;
}
Pages
js
:
:
WasmArrayBufferPages
(
const
ArrayBufferObjectMaybeShared
*
buf
)
{
if
(
buf
-
>
is
<
ArrayBufferObject
>
(
)
)
{
return
buf
-
>
as
<
ArrayBufferObject
>
(
)
.
wasmPages
(
)
;
}
return
buf
-
>
as
<
SharedArrayBufferObject
>
(
)
.
volatileWasmPages
(
)
;
}
Pages
js
:
:
WasmArrayBufferClampedMaxPages
(
const
ArrayBufferObjectMaybeShared
*
buf
)
{
if
(
buf
-
>
is
<
ArrayBufferObject
>
(
)
)
{
return
buf
-
>
as
<
ArrayBufferObject
>
(
)
.
wasmClampedMaxPages
(
)
;
}
return
buf
-
>
as
<
SharedArrayBufferObject
>
(
)
.
wasmClampedMaxPages
(
)
;
}
Maybe
<
Pages
>
js
:
:
WasmArrayBufferSourceMaxPages
(
const
ArrayBufferObjectMaybeShared
*
buf
)
{
if
(
buf
-
>
is
<
ArrayBufferObject
>
(
)
)
{
return
buf
-
>
as
<
ArrayBufferObject
>
(
)
.
wasmSourceMaxPages
(
)
;
}
return
Some
(
buf
-
>
as
<
SharedArrayBufferObject
>
(
)
.
wasmSourceMaxPages
(
)
)
;
}
static
void
CheckStealPreconditions
(
Handle
<
ArrayBufferObject
*
>
buffer
JSContext
*
cx
)
{
cx
-
>
check
(
buffer
)
;
MOZ_ASSERT
(
!
buffer
-
>
isDetached
(
)
"
can
'
t
steal
from
a
detached
buffer
"
)
;
MOZ_ASSERT
(
!
buffer
-
>
isPreparedForAsmJS
(
)
"
asm
.
js
-
prepared
buffers
don
'
t
have
detachable
/
stealable
data
"
)
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
wasmGrowToPagesInPlace
(
wasm
:
:
IndexType
t
Pages
newPages
Handle
<
ArrayBufferObject
*
>
oldBuf
JSContext
*
cx
)
{
if
(
oldBuf
-
>
isLengthPinned
(
)
)
{
return
nullptr
;
}
CheckStealPreconditions
(
oldBuf
cx
)
;
MOZ_ASSERT
(
oldBuf
-
>
isWasm
(
)
)
;
if
(
newPages
>
oldBuf
-
>
wasmClampedMaxPages
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
newPages
<
=
wasm
:
:
MaxMemoryPages
(
t
)
&
&
newPages
.
byteLength
(
)
<
=
ArrayBufferObject
:
:
MaxByteLength
)
;
size_t
newSize
=
newPages
.
byteLength
(
)
;
auto
*
newBuf
=
ArrayBufferObject
:
:
createEmpty
(
cx
)
;
if
(
!
newBuf
)
{
cx
-
>
clearPendingException
(
)
;
return
nullptr
;
}
MOZ_ASSERT
(
newBuf
-
>
isNoData
(
)
)
;
if
(
!
oldBuf
-
>
contents
(
)
.
wasmBuffer
(
)
-
>
growToPagesInPlace
(
newPages
)
)
{
return
nullptr
;
}
BufferContents
oldContents
=
oldBuf
-
>
contents
(
)
;
oldBuf
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
RemoveCellMemory
(
oldBuf
oldBuf
-
>
byteLength
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
ArrayBufferObject
:
:
detach
(
cx
oldBuf
)
;
newBuf
-
>
initialize
(
newSize
oldContents
)
;
AddCellMemory
(
newBuf
newSize
MemoryUse
:
:
ArrayBufferContents
)
;
return
newBuf
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
wasmMovingGrowToPages
(
IndexType
t
Pages
newPages
Handle
<
ArrayBufferObject
*
>
oldBuf
JSContext
*
cx
)
{
if
(
oldBuf
-
>
isLengthPinned
(
)
)
{
return
nullptr
;
}
if
(
newPages
>
oldBuf
-
>
wasmClampedMaxPages
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
newPages
<
=
wasm
:
:
MaxMemoryPages
(
t
)
&
&
newPages
.
byteLength
(
)
<
ArrayBufferObject
:
:
MaxByteLength
)
;
size_t
newSize
=
newPages
.
byteLength
(
)
;
if
(
wasm
:
:
ComputeMappedSize
(
newPages
)
<
=
oldBuf
-
>
wasmMappedSize
(
)
|
|
oldBuf
-
>
contents
(
)
.
wasmBuffer
(
)
-
>
extendMappedSize
(
newPages
)
)
{
return
wasmGrowToPagesInPlace
(
t
newPages
oldBuf
cx
)
;
}
Rooted
<
ArrayBufferObject
*
>
newBuf
(
cx
ArrayBufferObject
:
:
createEmpty
(
cx
)
)
;
if
(
!
newBuf
)
{
cx
-
>
clearPendingException
(
)
;
return
nullptr
;
}
Pages
clampedMaxPages
=
wasm
:
:
ClampedMaxPages
(
t
newPages
Nothing
(
)
false
)
;
WasmArrayRawBuffer
*
newRawBuf
=
WasmArrayRawBuffer
:
:
AllocateWasm
(
oldBuf
-
>
wasmIndexType
(
)
newPages
clampedMaxPages
Nothing
(
)
Nothing
(
)
)
;
if
(
!
newRawBuf
)
{
return
nullptr
;
}
AddCellMemory
(
newBuf
newSize
MemoryUse
:
:
ArrayBufferContents
)
;
BufferContents
contents
=
BufferContents
:
:
createWasm
(
newRawBuf
-
>
dataPointer
(
)
)
;
newBuf
-
>
initialize
(
newSize
contents
)
;
memcpy
(
newBuf
-
>
dataPointer
(
)
oldBuf
-
>
dataPointer
(
)
oldBuf
-
>
byteLength
(
)
)
;
ArrayBufferObject
:
:
detach
(
cx
oldBuf
)
;
return
newBuf
;
}
void
ArrayBufferObject
:
:
wasmDiscard
(
Handle
<
ArrayBufferObject
*
>
buf
uint64_t
byteOffset
uint64_t
byteLen
)
{
MOZ_ASSERT
(
buf
-
>
isWasm
(
)
)
;
buf
-
>
contents
(
)
.
wasmBuffer
(
)
-
>
discard
(
byteOffset
byteLen
)
;
}
uint32_t
ArrayBufferObject
:
:
flags
(
)
const
{
return
uint32_t
(
getFixedSlot
(
FLAGS_SLOT
)
.
toInt32
(
)
)
;
}
void
ArrayBufferObject
:
:
setFlags
(
uint32_t
flags
)
{
setFixedSlot
(
FLAGS_SLOT
Int32Value
(
flags
)
)
;
}
static
inline
js
:
:
gc
:
:
AllocKind
GetArrayBufferGCObjectKind
(
size_t
numSlots
)
{
if
(
numSlots
<
=
4
)
{
return
js
:
:
gc
:
:
AllocKind
:
:
ARRAYBUFFER4
;
}
if
(
numSlots
<
=
8
)
{
return
js
:
:
gc
:
:
AllocKind
:
:
ARRAYBUFFER8
;
}
if
(
numSlots
<
=
12
)
{
return
js
:
:
gc
:
:
AllocKind
:
:
ARRAYBUFFER12
;
}
return
js
:
:
gc
:
:
AllocKind
:
:
ARRAYBUFFER16
;
}
static
ArrayBufferObject
*
NewArrayBufferObject
(
JSContext
*
cx
HandleObject
proto_
gc
:
:
AllocKind
allocKind
)
{
MOZ_ASSERT
(
allocKind
=
=
gc
:
:
AllocKind
:
:
ARRAYBUFFER4
|
|
allocKind
=
=
gc
:
:
AllocKind
:
:
ARRAYBUFFER8
|
|
allocKind
=
=
gc
:
:
AllocKind
:
:
ARRAYBUFFER12
|
|
allocKind
=
=
gc
:
:
AllocKind
:
:
ARRAYBUFFER16
)
;
RootedObject
proto
(
cx
proto_
)
;
if
(
!
proto
)
{
proto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_ArrayBuffer
)
;
if
(
!
proto
)
{
return
nullptr
;
}
}
const
JSClass
*
clasp
=
&
ArrayBufferObject
:
:
class_
;
MOZ_ASSERT
(
ClassCanHaveFixedData
(
clasp
)
)
;
constexpr
size_t
nfixed
=
ArrayBufferObject
:
:
RESERVED_SLOTS
;
static_assert
(
nfixed
<
=
NativeObject
:
:
MAX_FIXED_SLOTS
)
;
Rooted
<
SharedShape
*
>
shape
(
cx
SharedShape
:
:
getInitialShape
(
cx
clasp
cx
-
>
realm
(
)
AsTaggedProto
(
proto
)
nfixed
ObjectFlags
(
)
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsBackgroundFinalized
(
allocKind
)
)
;
MOZ_ASSERT
(
!
CanNurseryAllocateFinalizedClass
(
clasp
)
)
;
constexpr
gc
:
:
Heap
heap
=
gc
:
:
Heap
:
:
Tenured
;
return
NativeObject
:
:
create
<
ArrayBufferObject
>
(
cx
allocKind
heap
shape
)
;
}
static
ArrayBufferObject
*
NewArrayBufferObject
(
JSContext
*
cx
)
{
static_assert
(
ArrayBufferObject
:
:
RESERVED_SLOTS
=
=
4
)
;
return
NewArrayBufferObject
(
cx
nullptr
gc
:
:
AllocKind
:
:
ARRAYBUFFER4
)
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
createForContents
(
JSContext
*
cx
size_t
nbytes
BufferContents
contents
)
{
MOZ_ASSERT
(
contents
)
;
MOZ_ASSERT
(
contents
.
kind
(
)
!
=
INLINE_DATA
)
;
MOZ_ASSERT
(
contents
.
kind
(
)
!
=
NO_DATA
)
;
MOZ_ASSERT
(
contents
.
kind
(
)
!
=
WASM
)
;
if
(
!
CheckArrayBufferTooLarge
(
cx
nbytes
)
)
{
return
nullptr
;
}
constexpr
size_t
reservedSlots
=
ArrayBufferObject
:
:
RESERVED_SLOTS
;
size_t
nAllocated
=
0
;
size_t
nslots
=
reservedSlots
;
if
(
contents
.
kind
(
)
=
=
USER_OWNED
)
{
}
else
if
(
contents
.
kind
(
)
=
=
EXTERNAL
)
{
constexpr
size_t
freeInfoSlots
=
HowMany
(
sizeof
(
FreeInfo
)
sizeof
(
Value
)
)
;
static_assert
(
reservedSlots
+
freeInfoSlots
<
=
NativeObject
:
:
MAX_FIXED_SLOTS
"
FreeInfo
must
fit
in
inline
slots
"
)
;
nslots
+
=
freeInfoSlots
;
}
else
{
nAllocated
=
nbytes
;
if
(
contents
.
kind
(
)
=
=
MAPPED
)
{
nAllocated
=
RoundUp
(
nbytes
js
:
:
gc
:
:
SystemPageSize
(
)
)
;
}
else
{
MOZ_ASSERT
(
contents
.
kind
(
)
=
=
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
|
|
contents
.
kind
(
)
=
=
MALLOCED_UNKNOWN_ARENA
"
should
have
handled
all
possible
callers
'
kinds
"
)
;
}
}
gc
:
:
AllocKind
allocKind
=
GetArrayBufferGCObjectKind
(
nslots
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
NewArrayBufferObject
(
cx
nullptr
allocKind
)
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
buffer
)
"
ArrayBufferObject
has
a
finalizer
that
must
be
called
to
not
"
"
leak
in
some
cases
so
it
can
'
t
be
nursery
-
allocated
"
)
;
buffer
-
>
initialize
(
nbytes
contents
)
;
if
(
contents
.
kind
(
)
=
=
MAPPED
|
|
contents
.
kind
(
)
=
=
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
|
|
contents
.
kind
(
)
=
=
MALLOCED_UNKNOWN_ARENA
)
{
AddCellMemory
(
buffer
nAllocated
MemoryUse
:
:
ArrayBufferContents
)
;
}
return
buffer
;
}
template
<
ArrayBufferObject
:
:
FillContents
FillType
>
std
:
:
tuple
<
ArrayBufferObject
*
uint8_t
*
>
ArrayBufferObject
:
:
createBufferAndData
(
JSContext
*
cx
size_t
nbytes
AutoSetNewObjectMetadata
&
JS
:
:
Handle
<
JSObject
*
>
proto
)
{
MOZ_ASSERT
(
nbytes
<
=
ArrayBufferObject
:
:
MaxByteLength
"
caller
must
validate
the
byte
count
it
passes
"
)
;
size_t
nslots
=
ArrayBufferObject
:
:
RESERVED_SLOTS
;
ArrayBufferContents
data
;
if
(
nbytes
<
=
MaxInlineBytes
)
{
int
newSlots
=
HowMany
(
nbytes
sizeof
(
Value
)
)
;
MOZ_ASSERT
(
int
(
nbytes
)
<
=
newSlots
*
int
(
sizeof
(
Value
)
)
)
;
nslots
+
=
newSlots
;
}
else
{
data
=
FillType
=
=
FillContents
:
:
Uninitialized
?
AllocateUninitializedArrayBufferContents
(
cx
nbytes
)
:
AllocateArrayBufferContents
(
cx
nbytes
)
;
if
(
!
data
)
{
return
{
nullptr
nullptr
}
;
}
}
gc
:
:
AllocKind
allocKind
=
GetArrayBufferGCObjectKind
(
nslots
)
;
ArrayBufferObject
*
buffer
=
NewArrayBufferObject
(
cx
proto
allocKind
)
;
if
(
!
buffer
)
{
return
{
nullptr
nullptr
}
;
}
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
buffer
)
"
ArrayBufferObject
has
a
finalizer
that
must
be
called
to
not
"
"
leak
in
some
cases
so
it
can
'
t
be
nursery
-
allocated
"
)
;
uint8_t
*
toFill
;
if
(
data
)
{
toFill
=
data
.
release
(
)
;
buffer
-
>
initialize
(
nbytes
BufferContents
:
:
createMallocedArrayBufferContentsArena
(
toFill
)
)
;
AddCellMemory
(
buffer
nbytes
MemoryUse
:
:
ArrayBufferContents
)
;
}
else
{
auto
contents
=
BufferContents
:
:
createInlineData
(
buffer
-
>
inlineDataPointer
(
)
)
;
buffer
-
>
initialize
(
nbytes
contents
)
;
toFill
=
contents
.
data
(
)
;
if
constexpr
(
FillType
=
=
FillContents
:
:
Zero
)
{
memset
(
toFill
0
nbytes
)
;
}
}
return
{
buffer
toFill
}
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
copy
(
JSContext
*
cx
size_t
newByteLength
JS
:
:
Handle
<
ArrayBufferObject
*
>
source
)
{
MOZ_ASSERT
(
!
source
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
newByteLength
<
=
ArrayBufferObject
:
:
MaxByteLength
"
caller
must
validate
the
byte
count
it
passes
"
)
;
size_t
sourceByteLength
=
source
-
>
byteLength
(
)
;
if
(
newByteLength
>
sourceByteLength
)
{
AutoSetNewObjectMetadata
metadata
(
cx
)
;
auto
[
buffer
toFill
]
=
createBufferAndData
<
FillContents
:
:
Zero
>
(
cx
newByteLength
metadata
nullptr
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
std
:
:
copy_n
(
source
-
>
dataPointer
(
)
sourceByteLength
toFill
)
;
return
buffer
;
}
AutoSetNewObjectMetadata
metadata
(
cx
)
;
auto
[
buffer
toFill
]
=
createBufferAndData
<
FillContents
:
:
Uninitialized
>
(
cx
newByteLength
metadata
nullptr
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
std
:
:
uninitialized_copy_n
(
source
-
>
dataPointer
(
)
newByteLength
toFill
)
;
return
buffer
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
copyAndDetach
(
JSContext
*
cx
size_t
newByteLength
JS
:
:
Handle
<
ArrayBufferObject
*
>
source
)
{
MOZ_ASSERT
(
!
source
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
newByteLength
<
=
ArrayBufferObject
:
:
MaxByteLength
"
caller
must
validate
the
byte
count
it
passes
"
)
;
if
(
newByteLength
>
ArrayBufferObject
:
:
MaxInlineBytes
&
&
source
-
>
isMalloced
(
)
)
{
if
(
newByteLength
=
=
source
-
>
byteLength
(
)
)
{
return
copyAndDetachSteal
(
cx
source
)
;
}
if
(
source
-
>
bufferKind
(
)
=
=
ArrayBufferObject
:
:
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
)
{
return
copyAndDetachRealloc
(
cx
newByteLength
source
)
;
}
}
auto
*
newBuffer
=
ArrayBufferObject
:
:
copy
(
cx
newByteLength
source
)
;
if
(
!
newBuffer
)
{
return
nullptr
;
}
ArrayBufferObject
:
:
detach
(
cx
source
)
;
return
newBuffer
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
copyAndDetachSteal
(
JSContext
*
cx
JS
:
:
Handle
<
ArrayBufferObject
*
>
source
)
{
MOZ_ASSERT
(
!
source
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
source
-
>
isMalloced
(
)
)
;
size_t
byteLength
=
source
-
>
byteLength
(
)
;
MOZ_ASSERT
(
byteLength
>
ArrayBufferObject
:
:
MaxInlineBytes
"
prefer
copying
small
buffers
"
)
;
auto
*
newBuffer
=
ArrayBufferObject
:
:
createEmpty
(
cx
)
;
if
(
!
newBuffer
)
{
return
nullptr
;
}
BufferContents
contents
=
source
-
>
contents
(
)
;
MOZ_ASSERT
(
contents
)
;
MOZ_ASSERT
(
contents
.
kind
(
)
=
=
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
|
|
contents
.
kind
(
)
=
=
MALLOCED_UNKNOWN_ARENA
)
;
source
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
RemoveCellMemory
(
source
byteLength
MemoryUse
:
:
ArrayBufferContents
)
;
ArrayBufferObject
:
:
detach
(
cx
source
)
;
newBuffer
-
>
initialize
(
byteLength
contents
)
;
AddCellMemory
(
newBuffer
byteLength
MemoryUse
:
:
ArrayBufferContents
)
;
return
newBuffer
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
copyAndDetachRealloc
(
JSContext
*
cx
size_t
newByteLength
JS
:
:
Handle
<
ArrayBufferObject
*
>
source
)
{
MOZ_ASSERT
(
!
source
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
source
-
>
bufferKind
(
)
=
=
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
)
;
MOZ_ASSERT
(
newByteLength
>
ArrayBufferObject
:
:
MaxInlineBytes
"
prefer
copying
small
buffers
"
)
;
MOZ_ASSERT
(
newByteLength
<
=
ArrayBufferObject
:
:
MaxByteLength
"
caller
must
validate
the
byte
count
it
passes
"
)
;
size_t
oldByteLength
=
source
-
>
byteLength
(
)
;
MOZ_ASSERT
(
oldByteLength
!
=
newByteLength
"
steal
instead
of
realloc
same
size
buffers
"
)
;
Rooted
<
ArrayBufferObject
*
>
newBuffer
(
cx
ArrayBufferObject
:
:
createEmpty
(
cx
)
)
;
if
(
!
newBuffer
)
{
return
nullptr
;
}
BufferContents
contents
=
source
-
>
contents
(
)
;
MOZ_ASSERT
(
contents
)
;
MOZ_ASSERT
(
contents
.
kind
(
)
=
=
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
)
;
auto
newData
=
ReallocateArrayBufferContents
(
cx
contents
.
data
(
)
oldByteLength
newByteLength
)
;
if
(
!
newData
)
{
return
nullptr
;
}
auto
newContents
=
BufferContents
:
:
createMallocedArrayBufferContentsArena
(
newData
.
release
(
)
)
;
source
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
RemoveCellMemory
(
source
oldByteLength
MemoryUse
:
:
ArrayBufferContents
)
;
ArrayBufferObject
:
:
detach
(
cx
source
)
;
newBuffer
-
>
initialize
(
newByteLength
newContents
)
;
AddCellMemory
(
newBuffer
newByteLength
MemoryUse
:
:
ArrayBufferContents
)
;
if
(
newByteLength
>
oldByteLength
)
{
size_t
count
=
newByteLength
-
oldByteLength
;
std
:
:
uninitialized_fill_n
(
newContents
.
data
(
)
+
oldByteLength
count
0
)
;
}
return
newBuffer
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
createZeroed
(
JSContext
*
cx
size_t
nbytes
HandleObject
proto
)
{
if
(
!
CheckArrayBufferTooLarge
(
cx
nbytes
)
)
{
return
nullptr
;
}
AutoSetNewObjectMetadata
metadata
(
cx
)
;
auto
[
buffer
toFill
]
=
createBufferAndData
<
FillContents
:
:
Zero
>
(
cx
nbytes
metadata
proto
)
;
(
void
)
toFill
;
return
buffer
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
createEmpty
(
JSContext
*
cx
)
{
AutoSetNewObjectMetadata
metadata
(
cx
)
;
ArrayBufferObject
*
obj
=
NewArrayBufferObject
(
cx
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
initialize
(
0
BufferContents
:
:
createNoData
(
)
)
;
return
obj
;
}
ArrayBufferObject
*
ArrayBufferObject
:
:
createFromNewRawBuffer
(
JSContext
*
cx
WasmArrayRawBuffer
*
rawBuffer
size_t
initialSize
)
{
AutoSetNewObjectMetadata
metadata
(
cx
)
;
ArrayBufferObject
*
buffer
=
NewArrayBufferObject
(
cx
)
;
if
(
!
buffer
)
{
WasmArrayRawBuffer
:
:
Release
(
rawBuffer
-
>
dataPointer
(
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
initialSize
=
=
rawBuffer
-
>
byteLength
(
)
)
;
auto
contents
=
BufferContents
:
:
createWasm
(
rawBuffer
-
>
dataPointer
(
)
)
;
buffer
-
>
initialize
(
initialSize
contents
)
;
AddCellMemory
(
buffer
initialSize
MemoryUse
:
:
ArrayBufferContents
)
;
return
buffer
;
}
uint8_t
*
ArrayBufferObject
:
:
stealMallocedContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
{
if
(
buffer
-
>
isLengthPinned
(
)
)
{
return
nullptr
;
}
CheckStealPreconditions
(
buffer
cx
)
;
switch
(
buffer
-
>
bufferKind
(
)
)
{
case
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
:
case
MALLOCED_UNKNOWN_ARENA
:
{
uint8_t
*
stolenData
=
buffer
-
>
dataPointer
(
)
;
MOZ_ASSERT
(
stolenData
)
;
RemoveCellMemory
(
buffer
buffer
-
>
byteLength
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
buffer
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
ArrayBufferObject
:
:
detach
(
cx
buffer
)
;
return
stolenData
;
}
case
INLINE_DATA
:
case
NO_DATA
:
case
USER_OWNED
:
case
MAPPED
:
case
EXTERNAL
:
{
ArrayBufferContents
copiedData
=
NewCopiedBufferContents
(
cx
buffer
)
;
if
(
!
copiedData
)
{
return
nullptr
;
}
ArrayBufferObject
:
:
detach
(
cx
buffer
)
;
return
copiedData
.
release
(
)
;
}
case
WASM
:
MOZ_ASSERT_UNREACHABLE
(
"
wasm
buffers
aren
'
t
stealable
except
by
a
"
"
memory
.
grow
operation
that
shouldn
'
t
call
this
"
"
function
"
)
;
return
nullptr
;
}
MOZ_ASSERT_UNREACHABLE
(
"
garbage
kind
computed
"
)
;
return
nullptr
;
}
ArrayBufferObject
:
:
BufferContents
ArrayBufferObject
:
:
extractStructuredCloneContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
{
if
(
buffer
-
>
isLengthPinned
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ARRAYBUFFER_LENGTH_PINNED
)
;
return
BufferContents
:
:
createFailed
(
)
;
}
CheckStealPreconditions
(
buffer
cx
)
;
BufferContents
contents
=
buffer
-
>
contents
(
)
;
switch
(
contents
.
kind
(
)
)
{
case
INLINE_DATA
:
case
NO_DATA
:
case
USER_OWNED
:
{
ArrayBufferContents
copiedData
=
NewCopiedBufferContents
(
cx
buffer
)
;
if
(
!
copiedData
)
{
return
BufferContents
:
:
createFailed
(
)
;
}
ArrayBufferObject
:
:
detach
(
cx
buffer
)
;
return
BufferContents
:
:
createMallocedArrayBufferContentsArena
(
copiedData
.
release
(
)
)
;
}
case
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
:
case
MALLOCED_UNKNOWN_ARENA
:
case
MAPPED
:
{
MOZ_ASSERT
(
contents
)
;
RemoveCellMemory
(
buffer
buffer
-
>
associatedBytes
(
)
MemoryUse
:
:
ArrayBufferContents
)
;
buffer
-
>
setDataPointer
(
BufferContents
:
:
createNoData
(
)
)
;
ArrayBufferObject
:
:
detach
(
cx
buffer
)
;
return
contents
;
}
case
WASM
:
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_TRANSFER
)
;
return
BufferContents
:
:
createFailed
(
)
;
case
EXTERNAL
:
MOZ_ASSERT_UNREACHABLE
(
"
external
ArrayBuffer
shouldn
'
t
have
passed
the
"
"
structured
-
clone
preflighting
"
)
;
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
garbage
kind
computed
"
)
;
return
BufferContents
:
:
createFailed
(
)
;
}
bool
ArrayBufferObject
:
:
ensureNonInline
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
{
if
(
buffer
-
>
isDetached
(
)
|
|
buffer
-
>
isPreparedForAsmJS
(
)
)
{
return
true
;
}
if
(
buffer
-
>
isLengthPinned
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ARRAYBUFFER_LENGTH_PINNED
)
;
return
false
;
}
BufferContents
inlineContents
=
buffer
-
>
contents
(
)
;
if
(
inlineContents
.
kind
(
)
!
=
INLINE_DATA
)
{
return
true
;
}
size_t
nbytes
=
buffer
-
>
byteLength
(
)
;
ArrayBufferContents
copy
=
NewCopiedBufferContents
(
cx
buffer
)
;
if
(
!
copy
)
{
return
false
;
}
BufferContents
outOfLineContents
=
BufferContents
:
:
createMallocedArrayBufferContentsArena
(
copy
.
release
(
)
)
;
buffer
-
>
setDataPointer
(
outOfLineContents
)
;
AddCellMemory
(
buffer
nbytes
MemoryUse
:
:
ArrayBufferContents
)
;
if
(
!
buffer
-
>
firstView
(
)
)
{
return
true
;
}
buffer
-
>
firstView
(
)
-
>
as
<
ArrayBufferViewObject
>
(
)
.
notifyBufferMoved
(
inlineContents
.
data
(
)
outOfLineContents
.
data
(
)
)
;
auto
&
innerViews
=
ObjectRealm
:
:
get
(
buffer
)
.
innerViews
.
get
(
)
;
if
(
InnerViewTable
:
:
ViewVector
*
views
=
innerViews
.
maybeViewsUnbarriered
(
buffer
)
)
{
for
(
JSObject
*
view
:
*
views
)
{
view
-
>
as
<
ArrayBufferViewObject
>
(
)
.
notifyBufferMoved
(
inlineContents
.
data
(
)
outOfLineContents
.
data
(
)
)
;
}
}
return
true
;
}
void
ArrayBufferObject
:
:
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
{
auto
&
buffer
=
obj
-
>
as
<
ArrayBufferObject
>
(
)
;
switch
(
buffer
.
bufferKind
(
)
)
{
case
INLINE_DATA
:
break
;
case
MALLOCED_ARRAYBUFFER_CONTENTS_ARENA
:
case
MALLOCED_UNKNOWN_ARENA
:
if
(
buffer
.
isPreparedForAsmJS
(
)
)
{
info
-
>
objectsMallocHeapElementsAsmJS
+
=
mallocSizeOf
(
buffer
.
dataPointer
(
)
)
;
}
else
{
info
-
>
objectsMallocHeapElementsNormal
+
=
mallocSizeOf
(
buffer
.
dataPointer
(
)
)
;
}
break
;
case
NO_DATA
:
MOZ_ASSERT
(
buffer
.
dataPointer
(
)
=
=
nullptr
)
;
break
;
case
USER_OWNED
:
break
;
case
EXTERNAL
:
break
;
case
MAPPED
:
info
-
>
objectsNonHeapElementsNormal
+
=
buffer
.
byteLength
(
)
;
break
;
case
WASM
:
if
(
!
buffer
.
isDetached
(
)
)
{
info
-
>
objectsNonHeapElementsWasm
+
=
buffer
.
byteLength
(
)
;
if
(
runtimeSizes
)
{
MOZ_ASSERT
(
buffer
.
wasmMappedSize
(
)
>
=
buffer
.
byteLength
(
)
)
;
runtimeSizes
-
>
wasmGuardPages
+
=
buffer
.
wasmMappedSize
(
)
-
buffer
.
byteLength
(
)
;
}
}
break
;
}
}
void
ArrayBufferObject
:
:
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
obj
-
>
as
<
ArrayBufferObject
>
(
)
.
releaseData
(
gcx
)
;
}
void
ArrayBufferObject
:
:
copyData
(
ArrayBufferObject
*
toBuffer
size_t
toIndex
ArrayBufferObject
*
fromBuffer
size_t
fromIndex
size_t
count
)
{
MOZ_ASSERT
(
!
toBuffer
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
count
)
;
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
toIndex
+
count
)
;
MOZ_ASSERT
(
!
fromBuffer
-
>
isDetached
(
)
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
+
count
)
;
memcpy
(
toBuffer
-
>
dataPointer
(
)
+
toIndex
fromBuffer
-
>
dataPointer
(
)
+
fromIndex
count
)
;
}
size_t
ArrayBufferObject
:
:
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
{
ArrayBufferObject
&
dst
=
obj
-
>
as
<
ArrayBufferObject
>
(
)
;
const
ArrayBufferObject
&
src
=
old
-
>
as
<
ArrayBufferObject
>
(
)
;
MOZ_ASSERT
(
!
obj
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
.
isInside
(
src
.
dataPointer
(
)
)
)
;
if
(
src
.
hasInlineData
(
)
)
{
dst
.
setFixedSlot
(
DATA_SLOT
PrivateValue
(
dst
.
inlineDataPointer
(
)
)
)
;
}
return
0
;
}
JSObject
*
ArrayBufferObject
:
:
firstView
(
)
{
return
getFixedSlot
(
FIRST_VIEW_SLOT
)
.
isObject
(
)
?
&
getFixedSlot
(
FIRST_VIEW_SLOT
)
.
toObject
(
)
:
nullptr
;
}
void
ArrayBufferObject
:
:
setFirstView
(
ArrayBufferViewObject
*
view
)
{
setFixedSlot
(
FIRST_VIEW_SLOT
ObjectOrNullValue
(
view
)
)
;
}
bool
ArrayBufferObject
:
:
addView
(
JSContext
*
cx
ArrayBufferViewObject
*
view
)
{
if
(
!
firstView
(
)
)
{
setFirstView
(
view
)
;
return
true
;
}
return
ObjectRealm
:
:
get
(
this
)
.
innerViews
.
get
(
)
.
addView
(
cx
this
view
)
;
}
inline
bool
InnerViewTable
:
:
Views
:
:
empty
(
)
{
return
views
.
empty
(
)
;
}
inline
bool
InnerViewTable
:
:
Views
:
:
hasNurseryViews
(
)
{
return
firstNurseryView
<
views
.
length
(
)
;
}
bool
InnerViewTable
:
:
Views
:
:
addView
(
ArrayBufferViewObject
*
view
)
{
if
(
!
views
.
append
(
view
)
)
{
return
false
;
}
if
(
!
gc
:
:
IsInsideNursery
(
view
)
)
{
if
(
firstNurseryView
!
=
views
.
length
(
)
-
1
)
{
std
:
:
swap
(
views
[
firstNurseryView
]
views
.
back
(
)
)
;
}
firstNurseryView
+
+
;
}
check
(
)
;
return
true
;
}
bool
InnerViewTable
:
:
Views
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
return
traceWeak
(
trc
firstNurseryView
)
;
}
bool
InnerViewTable
:
:
Views
:
:
traceWeak
(
JSTracer
*
trc
size_t
startIndex
)
{
size_t
index
=
startIndex
;
bool
sawNurseryView
=
false
;
views
.
mutableEraseIf
(
[
&
]
(
auto
&
view
)
{
if
(
!
JS
:
:
GCPolicy
<
ViewVector
:
:
ElementType
>
:
:
traceWeak
(
trc
&
view
)
)
{
return
true
;
}
if
(
!
sawNurseryView
&
&
gc
:
:
IsInsideNursery
(
view
)
)
{
sawNurseryView
=
true
;
firstNurseryView
=
index
;
}
index
+
+
;
return
false
;
}
startIndex
)
;
if
(
!
sawNurseryView
)
{
firstNurseryView
=
views
.
length
(
)
;
}
check
(
)
;
return
!
views
.
empty
(
)
;
}
inline
void
InnerViewTable
:
:
Views
:
:
check
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
firstNurseryView
<
=
views
.
length
(
)
)
;
if
(
views
.
length
(
)
<
100
)
{
for
(
size_t
i
=
0
;
i
<
views
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
gc
:
:
IsInsideNursery
(
views
[
i
]
)
=
=
(
i
>
=
firstNurseryView
)
)
;
}
}
#
endif
}
bool
InnerViewTable
:
:
addView
(
JSContext
*
cx
ArrayBufferObject
*
buffer
ArrayBufferViewObject
*
view
)
{
MOZ_ASSERT
(
buffer
-
>
firstView
(
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
buffer
)
)
;
auto
ptr
=
map
.
lookupForAdd
(
buffer
)
;
if
(
!
ptr
&
&
!
map
.
add
(
ptr
buffer
Views
(
cx
-
>
zone
(
)
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
Views
&
views
=
ptr
-
>
value
(
)
;
bool
isNurseryView
=
gc
:
:
IsInsideNursery
(
view
)
;
bool
hadNurseryViews
=
views
.
hasNurseryViews
(
)
;
if
(
!
views
.
addView
(
view
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
isNurseryView
&
&
!
hadNurseryViews
&
&
nurseryKeysValid
)
{
#
ifdef
DEBUG
if
(
nurseryKeys
.
length
(
)
<
100
)
{
for
(
auto
*
key
:
nurseryKeys
)
{
MOZ_ASSERT
(
key
!
=
buffer
)
;
}
}
#
endif
if
(
!
nurseryKeys
.
append
(
buffer
)
)
{
nurseryKeysValid
=
false
;
}
}
return
true
;
}
InnerViewTable
:
:
ViewVector
*
InnerViewTable
:
:
maybeViewsUnbarriered
(
ArrayBufferObject
*
buffer
)
{
auto
ptr
=
map
.
lookup
(
buffer
)
;
if
(
ptr
)
{
return
&
ptr
-
>
value
(
)
.
views
;
}
return
nullptr
;
}
void
InnerViewTable
:
:
removeViews
(
ArrayBufferObject
*
buffer
)
{
auto
ptr
=
map
.
lookup
(
buffer
)
;
MOZ_ASSERT
(
ptr
)
;
map
.
remove
(
ptr
)
;
}
bool
InnerViewTable
:
:
traceWeak
(
JSTracer
*
trc
)
{
return
map
.
traceWeak
(
trc
)
;
}
void
InnerViewTable
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
needsSweepAfterMinorGC
(
)
)
;
if
(
nurseryKeysValid
)
{
for
(
size_t
i
=
0
;
i
<
nurseryKeys
.
length
(
)
;
i
+
+
)
{
ArrayBufferObject
*
buffer
=
nurseryKeys
[
i
]
;
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
buffer
)
)
;
auto
ptr
=
map
.
lookup
(
buffer
)
;
if
(
ptr
&
&
!
ptr
-
>
value
(
)
.
sweepAfterMinorGC
(
trc
)
)
{
map
.
remove
(
ptr
)
;
}
}
}
else
{
for
(
ArrayBufferViewMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
e
.
front
(
)
.
key
(
)
)
)
;
if
(
!
e
.
front
(
)
.
value
(
)
.
sweepAfterMinorGC
(
trc
)
)
{
e
.
removeFront
(
)
;
}
}
}
nurseryKeys
.
clear
(
)
;
nurseryKeysValid
=
true
;
}
size_t
InnerViewTable
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
vectorSize
=
0
;
for
(
auto
r
=
map
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
vectorSize
+
=
r
.
front
(
)
.
value
(
)
.
views
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
vectorSize
+
map
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
+
nurseryKeys
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
ArrayBufferObjectMaybeShared
>
(
)
const
{
return
is
<
ArrayBufferObject
>
(
)
|
|
is
<
SharedArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
size_t
JS
:
:
GetArrayBufferByteLength
(
JSObject
*
obj
)
{
ArrayBufferObject
*
aobj
=
obj
-
>
maybeUnwrapAs
<
ArrayBufferObject
>
(
)
;
return
aobj
?
aobj
-
>
byteLength
(
)
:
0
;
}
JS_PUBLIC_API
uint8_t
*
JS
:
:
GetArrayBufferData
(
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
{
ArrayBufferObject
*
aobj
=
obj
-
>
maybeUnwrapIf
<
ArrayBufferObject
>
(
)
;
if
(
!
aobj
)
{
return
nullptr
;
}
*
isSharedMemory
=
false
;
return
aobj
-
>
dataPointer
(
)
;
}
static
ArrayBufferObject
*
UnwrapOrReportArrayBuffer
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
maybeArrayBuffer
)
{
JSObject
*
obj
=
CheckedUnwrapStatic
(
maybeArrayBuffer
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
if
(
!
obj
-
>
is
<
ArrayBufferObject
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ARRAYBUFFER_REQUIRED
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
ArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
DetachArrayBuffer
(
JSContext
*
cx
HandleObject
obj
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
)
;
Rooted
<
ArrayBufferObject
*
>
unwrappedBuffer
(
cx
UnwrapOrReportArrayBuffer
(
cx
obj
)
)
;
if
(
!
unwrappedBuffer
)
{
return
false
;
}
if
(
unwrappedBuffer
-
>
hasDefinedDetachKey
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_TRANSFER
)
;
return
false
;
}
if
(
unwrappedBuffer
-
>
isLengthPinned
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ARRAYBUFFER_LENGTH_PINNED
)
;
return
false
;
}
AutoRealm
ar
(
cx
unwrappedBuffer
)
;
ArrayBufferObject
:
:
detach
(
cx
unwrappedBuffer
)
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
HasDefinedArrayBufferDetachKey
(
JSContext
*
cx
HandleObject
obj
bool
*
isDefined
)
{
Rooted
<
ArrayBufferObject
*
>
unwrappedBuffer
(
cx
UnwrapOrReportArrayBuffer
(
cx
obj
)
)
;
if
(
!
unwrappedBuffer
)
{
return
false
;
}
*
isDefined
=
unwrappedBuffer
-
>
hasDefinedDetachKey
(
)
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
IsDetachedArrayBufferObject
(
JSObject
*
obj
)
{
ArrayBufferObject
*
aobj
=
obj
-
>
maybeUnwrapIf
<
ArrayBufferObject
>
(
)
;
if
(
!
aobj
)
{
return
false
;
}
return
aobj
-
>
isDetached
(
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewArrayBuffer
(
JSContext
*
cx
size_t
nbytes
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
return
ArrayBufferObject
:
:
createZeroed
(
cx
nbytes
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewArrayBufferWithContents
(
JSContext
*
cx
size_t
nbytes
mozilla
:
:
UniquePtr
<
void
JS
:
:
FreePolicy
>
contents
)
{
auto
*
result
=
NewArrayBufferWithContents
(
cx
nbytes
contents
.
get
(
)
JS
:
:
NewArrayBufferOutOfMemory
:
:
CallerMustFreeMemory
)
;
if
(
result
)
{
(
void
)
contents
.
release
(
)
;
}
return
result
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewArrayBufferWithContents
(
JSContext
*
cx
size_t
nbytes
void
*
data
NewArrayBufferOutOfMemory
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT_IF
(
!
data
nbytes
=
=
0
)
;
if
(
!
data
)
{
return
ArrayBufferObject
:
:
createZeroed
(
cx
0
)
;
}
using
BufferContents
=
ArrayBufferObject
:
:
BufferContents
;
BufferContents
contents
=
BufferContents
:
:
createMallocedUnknownArena
(
data
)
;
return
ArrayBufferObject
:
:
createForContents
(
cx
nbytes
contents
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
CopyArrayBuffer
(
JSContext
*
cx
Handle
<
JSObject
*
>
arrayBuffer
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
arrayBuffer
!
=
nullptr
)
;
Rooted
<
ArrayBufferObject
*
>
unwrappedSource
(
cx
UnwrapOrReportArrayBuffer
(
cx
arrayBuffer
)
)
;
if
(
!
unwrappedSource
)
{
return
nullptr
;
}
if
(
unwrappedSource
-
>
isDetached
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
return
ArrayBufferObject
:
:
copy
(
cx
unwrappedSource
-
>
byteLength
(
)
unwrappedSource
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewExternalArrayBuffer
(
JSContext
*
cx
size_t
nbytes
mozilla
:
:
UniquePtr
<
void
JS
:
:
BufferContentsDeleter
>
contents
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
contents
)
;
using
BufferContents
=
ArrayBufferObject
:
:
BufferContents
;
BufferContents
bufferContents
=
BufferContents
:
:
createExternal
(
contents
.
get
(
)
contents
.
get_deleter
(
)
.
freeFunc
(
)
contents
.
get_deleter
(
)
.
userData
(
)
)
;
auto
*
result
=
ArrayBufferObject
:
:
createForContents
(
cx
nbytes
bufferContents
)
;
if
(
result
)
{
(
void
)
contents
.
release
(
)
;
}
return
result
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewArrayBufferWithUserOwnedContents
(
JSContext
*
cx
size_t
nbytes
void
*
data
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
data
)
;
using
BufferContents
=
ArrayBufferObject
:
:
BufferContents
;
BufferContents
contents
=
BufferContents
:
:
createUserOwned
(
data
)
;
return
ArrayBufferObject
:
:
createForContents
(
cx
nbytes
contents
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsArrayBufferObject
(
JSObject
*
obj
)
{
return
obj
-
>
canUnwrapAs
<
ArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
ArrayBufferHasData
(
JSObject
*
obj
)
{
return
!
obj
-
>
unwrapAs
<
ArrayBufferObject
>
(
)
.
isDetached
(
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
UnwrapArrayBuffer
(
JSObject
*
obj
)
{
return
obj
-
>
maybeUnwrapIf
<
ArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
UnwrapSharedArrayBuffer
(
JSObject
*
obj
)
{
return
obj
-
>
maybeUnwrapIf
<
SharedArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
void
*
JS
:
:
StealArrayBufferContents
(
JSContext
*
cx
HandleObject
obj
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
)
;
Rooted
<
ArrayBufferObject
*
>
unwrappedBuffer
(
cx
UnwrapOrReportArrayBuffer
(
cx
obj
)
)
;
if
(
!
unwrappedBuffer
)
{
return
nullptr
;
}
if
(
unwrappedBuffer
-
>
isDetached
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
if
(
unwrappedBuffer
-
>
hasDefinedDetachKey
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_TRANSFER
)
;
return
nullptr
;
}
AutoRealm
ar
(
cx
unwrappedBuffer
)
;
return
ArrayBufferObject
:
:
stealMallocedContents
(
cx
unwrappedBuffer
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewMappedArrayBufferWithContents
(
JSContext
*
cx
size_t
nbytes
void
*
data
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
data
)
;
using
BufferContents
=
ArrayBufferObject
:
:
BufferContents
;
BufferContents
contents
=
BufferContents
:
:
createMapped
(
data
)
;
return
ArrayBufferObject
:
:
createForContents
(
cx
nbytes
contents
)
;
}
JS_PUBLIC_API
void
*
JS
:
:
CreateMappedArrayBufferContents
(
int
fd
size_t
offset
size_t
length
)
{
return
ArrayBufferObject
:
:
createMappedContents
(
fd
offset
length
)
.
data
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
ReleaseMappedArrayBufferContents
(
void
*
contents
size_t
length
)
{
gc
:
:
DeallocateMappedContent
(
contents
length
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsMappedArrayBufferObject
(
JSObject
*
obj
)
{
ArrayBufferObject
*
aobj
=
obj
-
>
maybeUnwrapIf
<
ArrayBufferObject
>
(
)
;
if
(
!
aobj
)
{
return
false
;
}
return
aobj
-
>
isMapped
(
)
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
GetObjectAsArrayBuffer
(
JSObject
*
obj
size_t
*
length
uint8_t
*
*
data
)
{
ArrayBufferObject
*
aobj
=
obj
-
>
maybeUnwrapIf
<
ArrayBufferObject
>
(
)
;
if
(
!
aobj
)
{
return
nullptr
;
}
*
length
=
aobj
-
>
byteLength
(
)
;
*
data
=
aobj
-
>
dataPointer
(
)
;
return
aobj
;
}
JS_PUBLIC_API
void
JS
:
:
GetArrayBufferLengthAndData
(
JSObject
*
obj
size_t
*
length
bool
*
isSharedMemory
uint8_t
*
*
data
)
{
auto
&
aobj
=
obj
-
>
as
<
ArrayBufferObject
>
(
)
;
*
length
=
aobj
.
byteLength
(
)
;
*
data
=
aobj
.
dataPointer
(
)
;
*
isSharedMemory
=
false
;
}
const
JSClass
*
const
JS
:
:
ArrayBuffer
:
:
UnsharedClass
=
&
ArrayBufferObject
:
:
class_
;
const
JSClass
*
const
JS
:
:
ArrayBuffer
:
:
SharedClass
=
&
SharedArrayBufferObject
:
:
class_
;
JS
:
:
ArrayBuffer
JS
:
:
ArrayBuffer
:
:
create
(
JSContext
*
cx
size_t
nbytes
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
return
JS
:
:
ArrayBuffer
(
ArrayBufferObject
:
:
createZeroed
(
cx
nbytes
)
)
;
}
mozilla
:
:
Span
<
uint8_t
>
JS
:
:
ArrayBuffer
:
:
getData
(
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
nogc
)
{
auto
*
buffer
=
obj
-
>
maybeUnwrapAs
<
ArrayBufferObjectMaybeShared
>
(
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
size_t
length
=
buffer
-
>
byteLength
(
)
;
if
(
buffer
-
>
is
<
SharedArrayBufferObject
>
(
)
)
{
*
isSharedMemory
=
true
;
return
{
buffer
-
>
dataPointerEither
(
)
.
unwrap
(
)
length
}
;
}
*
isSharedMemory
=
false
;
return
{
buffer
-
>
as
<
ArrayBufferObject
>
(
)
.
dataPointer
(
)
length
}
;
}
;
JS
:
:
ArrayBuffer
JS
:
:
ArrayBuffer
:
:
unwrap
(
JSObject
*
maybeWrapped
)
{
if
(
!
maybeWrapped
)
{
return
JS
:
:
ArrayBuffer
(
nullptr
)
;
}
auto
*
ab
=
maybeWrapped
-
>
maybeUnwrapIf
<
ArrayBufferObjectMaybeShared
>
(
)
;
return
fromObject
(
ab
)
;
}
bool
JS
:
:
ArrayBufferCopyData
(
JSContext
*
cx
Handle
<
JSObject
*
>
toBlock
size_t
toIndex
Handle
<
JSObject
*
>
fromBlock
size_t
fromIndex
size_t
count
)
{
Rooted
<
ArrayBufferObjectMaybeShared
*
>
unwrappedToBlock
(
cx
toBlock
-
>
maybeUnwrapIf
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
if
(
!
unwrappedToBlock
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
Rooted
<
ArrayBufferObjectMaybeShared
*
>
unwrappedFromBlock
(
cx
fromBlock
-
>
maybeUnwrapIf
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
if
(
!
unwrappedFromBlock
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
toIndex
+
count
<
toIndex
|
|
fromIndex
+
count
<
fromIndex
|
|
toIndex
+
count
>
unwrappedToBlock
-
>
byteLength
(
)
|
|
fromIndex
+
count
>
unwrappedFromBlock
-
>
byteLength
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_ARRAYBUFFER_COPY_RANGE
)
;
return
false
;
}
if
(
unwrappedToBlock
-
>
is
<
ArrayBufferObject
>
(
)
&
&
unwrappedFromBlock
-
>
is
<
ArrayBufferObject
>
(
)
)
{
Rooted
<
ArrayBufferObject
*
>
toArray
(
cx
&
unwrappedToBlock
-
>
as
<
ArrayBufferObject
>
(
)
)
;
Rooted
<
ArrayBufferObject
*
>
fromArray
(
cx
&
unwrappedFromBlock
-
>
as
<
ArrayBufferObject
>
(
)
)
;
ArrayBufferObject
:
:
copyData
(
toArray
toIndex
fromArray
fromIndex
count
)
;
return
true
;
}
Rooted
<
ArrayBufferObjectMaybeShared
*
>
toArray
(
cx
&
unwrappedToBlock
-
>
as
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
Rooted
<
ArrayBufferObjectMaybeShared
*
>
fromArray
(
cx
&
unwrappedFromBlock
-
>
as
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
SharedArrayBufferObject
:
:
copyData
(
toArray
toIndex
fromArray
fromIndex
count
)
;
return
true
;
}
JSObject
*
JS
:
:
ArrayBufferClone
(
JSContext
*
cx
Handle
<
JSObject
*
>
srcBuffer
size_t
srcByteOffset
size_t
srcLength
)
{
MOZ_ASSERT
(
srcBuffer
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
if
(
IsDetachedArrayBufferObject
(
srcBuffer
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
JS
:
:
RootedObject
targetBuffer
(
cx
JS
:
:
NewArrayBuffer
(
cx
srcLength
)
)
;
if
(
!
targetBuffer
)
{
return
nullptr
;
}
if
(
!
ArrayBufferCopyData
(
cx
targetBuffer
0
srcBuffer
srcByteOffset
srcLength
)
)
{
return
nullptr
;
}
return
targetBuffer
;
}
