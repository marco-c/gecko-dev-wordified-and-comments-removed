#
ifndef
vm_Activation_h
#
define
vm_Activation_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
vm
/
Stack
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JSFunction
;
class
JSObject
;
class
JSScript
;
namespace
JS
{
class
JS_PUBLIC_API
Compartment
;
namespace
dbg
{
class
JS_PUBLIC_API
AutoEntryMonitor
;
}
}
namespace
js
{
class
InterpreterActivation
;
class
InterpreterFrame
;
namespace
jit
{
class
JitActivation
;
class
JitFrameLayout
;
}
class
MOZ_RAII
ActivationEntryMonitor
{
JSContext
*
cx_
;
JS
:
:
dbg
:
:
AutoEntryMonitor
*
entryMonitor_
;
explicit
inline
ActivationEntryMonitor
(
JSContext
*
cx
)
;
ActivationEntryMonitor
(
const
ActivationEntryMonitor
&
other
)
=
delete
;
void
operator
=
(
const
ActivationEntryMonitor
&
other
)
=
delete
;
void
init
(
JSContext
*
cx
jit
:
:
CalleeToken
entryToken
)
;
void
init
(
JSContext
*
cx
InterpreterFrame
*
entryFrame
)
;
JS
:
:
Value
asyncStack
(
JSContext
*
cx
)
;
public
:
inline
ActivationEntryMonitor
(
JSContext
*
cx
InterpreterFrame
*
entryFrame
)
;
inline
ActivationEntryMonitor
(
JSContext
*
cx
jit
:
:
CalleeToken
entryToken
)
;
inline
~
ActivationEntryMonitor
(
)
;
}
;
class
LiveSavedFrameCache
{
public
:
class
FramePtr
{
using
Ptr
=
mozilla
:
:
Variant
<
InterpreterFrame
*
jit
:
:
CommonFrameLayout
*
jit
:
:
RematerializedFrame
*
wasm
:
:
DebugFrame
*
>
;
Ptr
ptr
;
template
<
typename
Frame
>
explicit
FramePtr
(
Frame
ptr
)
:
ptr
(
ptr
)
{
}
struct
HasCachedMatcher
;
struct
SetHasCachedMatcher
;
struct
ClearHasCachedMatcher
;
public
:
static
inline
mozilla
:
:
Maybe
<
FramePtr
>
create
(
const
FrameIter
&
iter
)
;
inline
bool
hasCachedSavedFrame
(
)
const
;
inline
void
setHasCachedSavedFrame
(
)
;
inline
void
clearHasCachedSavedFrame
(
)
;
inline
bool
isInterpreterFrame
(
)
const
{
return
ptr
.
is
<
InterpreterFrame
*
>
(
)
;
}
inline
InterpreterFrame
&
asInterpreterFrame
(
)
const
{
return
*
ptr
.
as
<
InterpreterFrame
*
>
(
)
;
}
inline
bool
isRematerializedFrame
(
)
const
{
return
ptr
.
is
<
jit
:
:
RematerializedFrame
*
>
(
)
;
}
bool
operator
=
=
(
const
FramePtr
&
rhs
)
const
{
return
rhs
.
ptr
=
=
this
-
>
ptr
;
}
bool
operator
!
=
(
const
FramePtr
&
rhs
)
const
{
return
!
(
rhs
=
=
*
this
)
;
}
}
;
private
:
class
Key
{
FramePtr
framePtr
;
public
:
MOZ_IMPLICIT
Key
(
const
FramePtr
&
framePtr
)
:
framePtr
(
framePtr
)
{
}
bool
operator
=
=
(
const
Key
&
rhs
)
const
{
return
rhs
.
framePtr
=
=
this
-
>
framePtr
;
}
bool
operator
!
=
(
const
Key
&
rhs
)
const
{
return
!
(
rhs
=
=
*
this
)
;
}
}
;
struct
Entry
{
const
Key
key
;
const
jsbytecode
*
pc
;
HeapPtr
<
SavedFrame
*
>
savedFrame
;
Entry
(
const
Key
&
key
const
jsbytecode
*
pc
SavedFrame
*
savedFrame
)
:
key
(
key
)
pc
(
pc
)
savedFrame
(
savedFrame
)
{
}
}
;
using
EntryVector
=
Vector
<
Entry
0
SystemAllocPolicy
>
;
EntryVector
*
frames
;
LiveSavedFrameCache
(
const
LiveSavedFrameCache
&
)
=
delete
;
LiveSavedFrameCache
&
operator
=
(
const
LiveSavedFrameCache
&
)
=
delete
;
public
:
explicit
LiveSavedFrameCache
(
)
:
frames
(
nullptr
)
{
}
LiveSavedFrameCache
(
LiveSavedFrameCache
&
&
rhs
)
:
frames
(
rhs
.
frames
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
disallowed
"
)
;
rhs
.
frames
=
nullptr
;
}
~
LiveSavedFrameCache
(
)
{
if
(
frames
)
{
js_delete
(
frames
)
;
frames
=
nullptr
;
}
}
bool
initialized
(
)
const
{
return
!
!
frames
;
}
bool
init
(
JSContext
*
cx
)
{
frames
=
js_new
<
EntryVector
>
(
)
;
if
(
!
frames
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
trace
(
JSTracer
*
trc
)
;
void
find
(
JSContext
*
cx
FramePtr
&
framePtr
const
jsbytecode
*
pc
MutableHandleSavedFrame
frame
)
const
;
void
findWithoutInvalidation
(
const
FramePtr
&
framePtr
MutableHandleSavedFrame
frame
)
const
;
bool
insert
(
JSContext
*
cx
FramePtr
&
framePtr
const
jsbytecode
*
pc
HandleSavedFrame
savedFrame
)
;
void
clear
(
)
{
if
(
frames
)
frames
-
>
clear
(
)
;
}
}
;
static_assert
(
sizeof
(
LiveSavedFrameCache
)
=
=
sizeof
(
uintptr_t
)
"
Every
js
:
:
Activation
has
a
LiveSavedFrameCache
so
we
need
to
be
pretty
"
"
careful
"
"
about
avoiding
bloat
.
If
you
'
re
adding
members
to
LiveSavedFrameCache
"
"
maybe
you
"
"
should
consider
figuring
out
a
way
to
make
js
:
:
Activation
have
a
"
"
LiveSavedFrameCache
*
instead
of
a
Rooted
<
LiveSavedFrameCache
>
.
"
)
;
class
Activation
{
protected
:
JSContext
*
cx_
;
JS
:
:
Compartment
*
compartment_
;
Activation
*
prev_
;
Activation
*
prevProfiling_
;
size_t
hideScriptedCallerCount_
;
JS
:
:
Rooted
<
LiveSavedFrameCache
>
frameCache_
;
JS
:
:
Rooted
<
SavedFrame
*
>
asyncStack_
;
const
char
*
asyncCause_
;
bool
asyncCallIsExplicit_
;
enum
Kind
{
Interpreter
Jit
}
;
Kind
kind_
;
inline
Activation
(
JSContext
*
cx
Kind
kind
)
;
inline
~
Activation
(
)
;
public
:
JSContext
*
cx
(
)
const
{
return
cx_
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
compartment_
;
}
Activation
*
prev
(
)
const
{
return
prev_
;
}
Activation
*
prevProfiling
(
)
const
{
return
prevProfiling_
;
}
inline
Activation
*
mostRecentProfiling
(
)
;
bool
isInterpreter
(
)
const
{
return
kind_
=
=
Interpreter
;
}
bool
isJit
(
)
const
{
return
kind_
=
=
Jit
;
}
inline
bool
hasWasmExitFP
(
)
const
;
inline
bool
isProfiling
(
)
const
;
void
registerProfiling
(
)
;
void
unregisterProfiling
(
)
;
InterpreterActivation
*
asInterpreter
(
)
const
{
MOZ_ASSERT
(
isInterpreter
(
)
)
;
return
(
InterpreterActivation
*
)
this
;
}
jit
:
:
JitActivation
*
asJit
(
)
const
{
MOZ_ASSERT
(
isJit
(
)
)
;
return
(
jit
:
:
JitActivation
*
)
this
;
}
void
hideScriptedCaller
(
)
{
hideScriptedCallerCount_
+
+
;
}
void
unhideScriptedCaller
(
)
{
MOZ_ASSERT
(
hideScriptedCallerCount_
>
0
)
;
hideScriptedCallerCount_
-
-
;
}
bool
scriptedCallerIsHidden
(
)
const
{
return
hideScriptedCallerCount_
>
0
;
}
static
size_t
offsetOfPrev
(
)
{
return
offsetof
(
Activation
prev_
)
;
}
static
size_t
offsetOfPrevProfiling
(
)
{
return
offsetof
(
Activation
prevProfiling_
)
;
}
SavedFrame
*
asyncStack
(
)
{
return
asyncStack_
;
}
const
char
*
asyncCause
(
)
const
{
return
asyncCause_
;
}
bool
asyncCallIsExplicit
(
)
const
{
return
asyncCallIsExplicit_
;
}
inline
LiveSavedFrameCache
*
getLiveSavedFrameCache
(
JSContext
*
cx
)
;
void
clearLiveSavedFrameCache
(
)
{
frameCache_
.
get
(
)
.
clear
(
)
;
}
private
:
Activation
(
const
Activation
&
other
)
=
delete
;
void
operator
=
(
const
Activation
&
other
)
=
delete
;
}
;
constexpr
jsbytecode
EnableInterruptsPseudoOpcode
=
-
1
;
static_assert
(
EnableInterruptsPseudoOpcode
>
=
JSOP_LIMIT
"
EnableInterruptsPseudoOpcode
must
be
greater
than
any
opcode
"
)
;
static_assert
(
EnableInterruptsPseudoOpcode
=
=
jsbytecode
(
-
1
)
"
EnableInterruptsPseudoOpcode
must
be
the
maximum
jsbytecode
value
"
)
;
class
InterpreterFrameIterator
;
class
RunState
;
class
InterpreterActivation
:
public
Activation
{
friend
class
js
:
:
InterpreterFrameIterator
;
InterpreterRegs
regs_
;
InterpreterFrame
*
entryFrame_
;
size_t
opMask_
;
#
ifdef
DEBUG
size_t
oldFrameCount_
;
#
endif
public
:
inline
InterpreterActivation
(
RunState
&
state
JSContext
*
cx
InterpreterFrame
*
entryFrame
)
;
inline
~
InterpreterActivation
(
)
;
inline
bool
pushInlineFrame
(
const
JS
:
:
CallArgs
&
args
JS
:
:
Handle
<
JSScript
*
>
script
MaybeConstruct
constructing
)
;
inline
void
popInlineFrame
(
InterpreterFrame
*
frame
)
;
inline
bool
resumeGeneratorFrame
(
JS
:
:
Handle
<
JSFunction
*
>
callee
JS
:
:
Handle
<
JSObject
*
>
envChain
)
;
InterpreterFrame
*
current
(
)
const
{
return
regs_
.
fp
(
)
;
}
InterpreterRegs
&
regs
(
)
{
return
regs_
;
}
InterpreterFrame
*
entryFrame
(
)
const
{
return
entryFrame_
;
}
size_t
opMask
(
)
const
{
return
opMask_
;
}
bool
isProfiling
(
)
const
{
return
false
;
}
void
enableInterruptsIfRunning
(
JSScript
*
script
)
{
if
(
regs_
.
fp
(
)
-
>
script
(
)
=
=
script
)
{
enableInterruptsUnconditionally
(
)
;
}
}
void
enableInterruptsUnconditionally
(
)
{
opMask_
=
EnableInterruptsPseudoOpcode
;
}
void
clearInterruptsMask
(
)
{
opMask_
=
0
;
}
}
;
class
ActivationIterator
{
protected
:
Activation
*
activation_
;
public
:
explicit
ActivationIterator
(
JSContext
*
cx
)
;
ActivationIterator
&
operator
+
+
(
)
;
Activation
*
operator
-
>
(
)
const
{
return
activation_
;
}
Activation
*
activation
(
)
const
{
return
activation_
;
}
bool
done
(
)
const
{
return
activation_
=
=
nullptr
;
}
}
;
}
#
endif
