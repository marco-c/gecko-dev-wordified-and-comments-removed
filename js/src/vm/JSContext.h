#
ifndef
vm_JSContext_h
#
define
vm_JSContext_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
ds
/
TraceableFifo
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
irregexp
/
RegExpTypes
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Interrupt
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
util
/
StructuredSpewer
.
h
"
#
include
"
vm
/
Activation
.
h
"
#
include
"
vm
/
ErrorReporting
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
wasm
/
WasmContext
.
h
"
struct
JS_PUBLIC_API
JSContext
;
struct
DtoaState
;
namespace
js
{
class
AutoAllocInAtomsZone
;
class
AutoMaybeLeaveAtomsZone
;
class
AutoRealm
;
namespace
frontend
{
class
WellKnownParserAtoms
;
}
namespace
jit
{
class
ICScript
;
class
JitActivation
;
class
JitContext
;
class
DebugModeOSRVolatileJitFrameIter
;
}
namespace
gc
{
class
AutoSuppressNurseryCellAlloc
;
}
class
MOZ_RAII
AutoCycleDetector
{
public
:
using
Vector
=
GCVector
<
JSObject
*
8
>
;
AutoCycleDetector
(
JSContext
*
cx
HandleObject
objArg
)
:
cx
(
cx
)
obj
(
cx
objArg
)
cyclic
(
true
)
{
}
~
AutoCycleDetector
(
)
;
bool
init
(
)
;
bool
foundCycle
(
)
{
return
cyclic
;
}
private
:
JSContext
*
cx
;
RootedObject
obj
;
bool
cyclic
;
}
;
struct
AutoResolving
;
struct
OffThreadFrontendErrors
;
class
InternalJobQueue
:
public
JS
:
:
JobQueue
{
public
:
explicit
InternalJobQueue
(
JSContext
*
cx
)
:
queue
(
cx
SystemAllocPolicy
(
)
)
draining_
(
false
)
interrupted_
(
false
)
{
}
~
InternalJobQueue
(
)
=
default
;
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
override
;
bool
enqueuePromiseJob
(
JSContext
*
cx
JS
:
:
HandleObject
promise
JS
:
:
HandleObject
job
JS
:
:
HandleObject
allocationSite
JS
:
:
HandleObject
incumbentGlobal
)
override
;
void
runJobs
(
JSContext
*
cx
)
override
;
bool
empty
(
)
const
override
;
void
interrupt
(
)
{
interrupted_
=
true
;
}
JSObject
*
maybeFront
(
)
const
;
#
ifdef
DEBUG
JSObject
*
copyJobs
(
JSContext
*
cx
)
;
#
endif
private
:
using
Queue
=
js
:
:
TraceableFifo
<
JSObject
*
0
SystemAllocPolicy
>
;
JS
:
:
PersistentRooted
<
Queue
>
queue
;
bool
draining_
;
bool
interrupted_
;
class
SavedQueue
;
js
:
:
UniquePtr
<
JobQueue
:
:
SavedJobQueue
>
saveJobQueue
(
JSContext
*
)
override
;
}
;
class
AutoLockScriptData
;
extern
MOZ_THREAD_LOCAL
(
JSContext
*
)
TlsContext
;
enum
class
ContextKind
{
Uninitialized
MainThread
HelperThread
}
;
#
ifdef
DEBUG
JSContext
*
MaybeGetJSContext
(
)
;
bool
CurrentThreadIsParseThread
(
)
;
#
endif
enum
class
InterruptReason
:
uint32_t
{
GC
=
1
<
<
0
AttachIonCompilations
=
1
<
<
1
CallbackUrgent
=
1
<
<
2
CallbackCanWait
=
1
<
<
3
}
;
enum
class
ShouldCaptureStack
{
Maybe
Always
}
;
}
struct
JS_PUBLIC_API
JSContext
:
public
JS
:
:
RootingContext
public
js
:
:
MallocProvider
<
JSContext
>
{
JSContext
(
JSRuntime
*
runtime
const
JS
:
:
ContextOptions
&
options
)
;
~
JSContext
(
)
;
bool
init
(
js
:
:
ContextKind
kind
)
;
private
:
js
:
:
UnprotectedData
<
JSRuntime
*
>
runtime_
;
js
:
:
WriteOnceData
<
js
:
:
ContextKind
>
kind_
;
friend
class
js
:
:
gc
:
:
AutoSuppressNurseryCellAlloc
;
js
:
:
ContextData
<
size_t
>
nurserySuppressions_
;
js
:
:
ContextData
<
JS
:
:
ContextOptions
>
options_
;
js
:
:
ThreadId
currentThread_
;
js
:
:
OffThreadFrontendErrors
*
errors_
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
ReleaseAcquire
>
freeUnusedMemory
;
js
:
:
ContextData
<
bool
>
measuringExecutionTime_
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
ReleaseAcquire
>
isExecuting_
;
public
:
void
setRuntime
(
JSRuntime
*
rt
)
;
void
setHelperThread
(
const
JS
:
:
ContextOptions
&
options
const
js
:
:
AutoLockHelperThreadState
&
locked
)
;
void
clearHelperThread
(
const
js
:
:
AutoLockHelperThreadState
&
locked
)
;
bool
contextAvailable
(
js
:
:
AutoLockHelperThreadState
&
locked
)
{
MOZ_ASSERT
(
kind_
=
=
js
:
:
ContextKind
:
:
HelperThread
)
;
return
currentThread_
=
=
js
:
:
ThreadId
(
)
;
}
void
setFreeUnusedMemory
(
bool
shouldFree
)
{
freeUnusedMemory
=
shouldFree
;
}
bool
shouldFreeUnusedMemory
(
)
const
{
return
kind_
=
=
js
:
:
ContextKind
:
:
HelperThread
&
&
freeUnusedMemory
;
}
bool
isMeasuringExecutionTime
(
)
const
{
return
measuringExecutionTime_
;
}
void
setIsMeasuringExecutionTime
(
bool
value
)
{
measuringExecutionTime_
=
value
;
}
const
mozilla
:
:
Atomic
<
bool
mozilla
:
:
ReleaseAcquire
>
&
isExecutingRef
(
)
const
{
return
isExecuting_
;
}
void
setIsExecuting
(
bool
value
)
{
isExecuting_
=
value
;
}
#
ifdef
DEBUG
bool
isInitialized
(
)
const
{
return
kind_
!
=
js
:
:
ContextKind
:
:
Uninitialized
;
}
#
endif
bool
isMainThreadContext
(
)
const
{
return
kind_
=
=
js
:
:
ContextKind
:
:
MainThread
;
}
bool
isHelperThreadContext
(
)
const
{
return
kind_
=
=
js
:
:
ContextKind
:
:
HelperThread
;
}
template
<
typename
T
>
bool
isInsideCurrentZone
(
T
thing
)
const
{
return
thing
-
>
zoneFromAnyThread
(
)
=
=
zone_
;
}
template
<
typename
T
>
inline
bool
isInsideCurrentCompartment
(
T
thing
)
const
{
return
thing
-
>
compartment
(
)
=
=
compartment
(
)
;
}
void
onOutOfMemory
(
)
;
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
{
if
(
isHelperThreadContext
(
)
)
{
addPendingOutOfMemory
(
)
;
return
nullptr
;
}
return
runtime_
-
>
onOutOfMemory
(
allocFunc
arena
nbytes
reallocPtr
this
)
;
}
void
onOverRecursed
(
)
;
void
recoverFromOutOfMemory
(
)
;
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
this
)
;
}
JSAtomState
&
names
(
)
{
return
*
runtime_
-
>
commonNames
;
}
js
:
:
StaticStrings
&
staticStrings
(
)
{
return
*
runtime_
-
>
staticStrings
;
}
bool
permanentAtomsPopulated
(
)
{
return
runtime_
-
>
permanentAtomsPopulated
(
)
;
}
const
js
:
:
FrozenAtomSet
&
permanentAtoms
(
)
{
return
*
runtime_
-
>
permanentAtoms
(
)
;
}
js
:
:
WellKnownSymbols
&
wellKnownSymbols
(
)
{
return
*
runtime_
-
>
wellKnownSymbols
;
}
js
:
:
PropertyName
*
emptyString
(
)
{
return
runtime_
-
>
emptyString
;
}
JS
:
:
GCContext
*
gcContext
(
)
{
return
runtime_
-
>
gcContext
(
)
;
}
JS
:
:
StackKind
stackKindForCurrentPrincipal
(
)
;
JS
:
:
NativeStackLimit
stackLimitForCurrentPrincipal
(
)
;
JS
:
:
NativeStackLimit
stackLimit
(
JS
:
:
StackKind
kind
)
{
MOZ_ASSERT
(
isMainThreadContext
(
)
)
;
return
nativeStackLimit
[
kind
]
;
}
JS
:
:
NativeStackLimit
stackLimitForJitCode
(
JS
:
:
StackKind
kind
)
;
size_t
gcSystemPageSize
(
)
{
return
js
:
:
gc
:
:
SystemPageSize
(
)
;
}
private
:
inline
void
setRealm
(
JS
:
:
Realm
*
realm
)
;
inline
void
enterRealm
(
JS
:
:
Realm
*
realm
)
;
inline
void
enterAtomsZone
(
)
;
inline
void
leaveAtomsZone
(
JS
:
:
Realm
*
oldRealm
)
;
inline
void
setZone
(
js
:
:
Zone
*
zone
)
;
friend
class
js
:
:
AutoAllocInAtomsZone
;
friend
class
js
:
:
AutoMaybeLeaveAtomsZone
;
friend
class
js
:
:
AutoRealm
;
public
:
inline
void
enterRealmOf
(
JSObject
*
target
)
;
inline
void
enterRealmOf
(
JSScript
*
target
)
;
inline
void
enterRealmOf
(
js
:
:
Shape
*
target
)
;
inline
void
enterNullRealm
(
)
;
inline
void
setRealmForJitExceptionHandler
(
JS
:
:
Realm
*
realm
)
;
inline
void
leaveRealm
(
JS
:
:
Realm
*
oldRealm
)
;
void
setOffThreadFrontendErrors
(
js
:
:
OffThreadFrontendErrors
*
errors
)
{
errors_
=
errors
;
}
js
:
:
OffThreadFrontendErrors
*
offThreadFrontendErrors
(
)
const
{
return
errors_
;
}
bool
isNurseryAllocSuppressed
(
)
const
{
return
nurserySuppressions_
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
realm_
?
JS
:
:
GetCompartmentForRealm
(
realm_
)
:
nullptr
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
realm_
;
}
#
ifdef
DEBUG
bool
inAtomsZone
(
)
const
;
#
endif
JS
:
:
Zone
*
zone
(
)
const
{
MOZ_ASSERT_IF
(
!
realm
(
)
&
&
zone_
inAtomsZone
(
)
)
;
MOZ_ASSERT_IF
(
realm
(
)
js
:
:
GetRealmZone
(
realm
(
)
)
=
=
zone_
)
;
return
zoneRaw
(
)
;
}
JS
:
:
Zone
*
zoneRaw
(
)
const
{
return
zone_
;
}
static
size_t
offsetOfZone
(
)
{
return
offsetof
(
JSContext
zone_
)
;
}
inline
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
global
(
)
const
;
js
:
:
AtomsTable
&
atoms
(
)
{
return
runtime_
-
>
atoms
(
)
;
}
const
JS
:
:
Zone
*
atomsZone
(
)
{
return
runtime_
-
>
atomsZone
(
)
;
}
js
:
:
SymbolRegistry
&
symbolRegistry
(
)
{
return
runtime_
-
>
symbolRegistry
(
)
;
}
js
:
:
SharedImmutableScriptDataTable
&
scriptDataTable
(
js
:
:
AutoLockScriptData
&
lock
)
{
return
runtime_
-
>
scriptDataTable
(
lock
)
;
}
js
:
:
gc
:
:
AtomMarkingRuntime
&
atomMarking
(
)
{
return
runtime_
-
>
gc
.
atomMarking
;
}
void
markAtom
(
JSAtom
*
atom
)
{
atomMarking
(
)
.
markAtom
(
this
atom
)
;
}
void
markAtom
(
JS
:
:
Symbol
*
symbol
)
{
atomMarking
(
)
.
markAtom
(
this
symbol
)
;
}
void
markId
(
jsid
id
)
{
atomMarking
(
)
.
markId
(
this
id
)
;
}
void
markAtomValue
(
const
js
:
:
Value
&
value
)
{
atomMarking
(
)
.
markAtomValue
(
this
value
)
;
}
js
:
:
Metrics
metrics
(
)
{
return
js
:
:
Metrics
(
runtime_
)
;
}
void
addPendingOverRecursed
(
)
;
void
addPendingOutOfMemory
(
)
;
JSRuntime
*
runtime
(
)
{
return
runtime_
;
}
const
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
static
size_t
offsetOfRealm
(
)
{
return
offsetof
(
JSContext
realm_
)
;
}
friend
class
JS
:
:
AutoSaveExceptionState
;
friend
class
js
:
:
jit
:
:
DebugModeOSRVolatileJitFrameIter
;
friend
void
js
:
:
ReportOutOfMemory
(
JSContext
*
)
;
friend
void
js
:
:
ReportOverRecursed
(
JSContext
*
)
;
friend
void
js
:
:
ReportOversizedAllocation
(
JSContext
*
const
unsigned
)
;
public
:
inline
JS
:
:
Result
<
>
boolToResult
(
bool
ok
)
;
template
<
typename
V
typename
E
>
bool
resultToBool
(
const
JS
:
:
Result
<
V
E
>
&
result
)
{
return
result
.
isOk
(
)
;
}
template
<
typename
V
typename
E
>
V
*
resultToPtr
(
JS
:
:
Result
<
V
*
E
>
&
result
)
{
return
result
.
isOk
(
)
?
result
.
unwrap
(
)
:
nullptr
;
}
mozilla
:
:
GenericErrorResult
<
JS
:
:
OOM
>
alreadyReportedOOM
(
)
;
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
>
alreadyReportedError
(
)
;
js
:
:
ContextData
<
js
:
:
jit
:
:
JitActivation
*
>
jitActivation
;
js
:
:
ContextData
<
js
:
:
irregexp
:
:
Isolate
*
>
isolate
;
js
:
:
ContextData
<
js
:
:
Activation
*
>
activation_
;
js
:
:
Activation
*
volatile
profilingActivation_
;
public
:
js
:
:
Activation
*
activation
(
)
const
{
return
activation_
;
}
static
size_t
offsetOfActivation
(
)
{
return
offsetof
(
JSContext
activation_
)
;
}
js
:
:
Activation
*
profilingActivation
(
)
const
{
return
profilingActivation_
;
}
static
size_t
offsetOfProfilingActivation
(
)
{
return
offsetof
(
JSContext
profilingActivation_
)
;
}
static
size_t
offsetOfJitActivation
(
)
{
return
offsetof
(
JSContext
jitActivation
)
;
}
#
ifdef
DEBUG
static
size_t
offsetOfInUnsafeCallWithABI
(
)
{
return
offsetof
(
JSContext
inUnsafeCallWithABI
)
;
}
#
endif
static
size_t
offsetOfInlinedICScript
(
)
{
return
offsetof
(
JSContext
inlinedICScript_
)
;
}
public
:
js
:
:
InterpreterStack
&
interpreterStack
(
)
{
return
runtime
(
)
-
>
interpreterStack
(
)
;
}
private
:
mozilla
:
:
Maybe
<
JS
:
:
NativeStackBase
>
nativeStackBase_
;
public
:
JS
:
:
NativeStackBase
nativeStackBase
(
)
const
{
MOZ_ASSERT
(
isMainThreadContext
(
)
)
;
return
*
nativeStackBase_
;
}
public
:
js
:
:
ContextData
<
JS
:
:
dbg
:
:
AutoEntryMonitor
*
>
entryMonitor
;
js
:
:
ContextData
<
js
:
:
EnterDebuggeeNoExecute
*
>
noExecuteDebuggerTop
;
#
ifdef
DEBUG
js
:
:
ContextData
<
uint32_t
>
inUnsafeCallWithABI
;
js
:
:
ContextData
<
bool
>
hasAutoUnsafeCallWithABI
;
#
endif
#
ifdef
JS_SIMULATOR
private
:
js
:
:
ContextData
<
js
:
:
jit
:
:
Simulator
*
>
simulator_
;
public
:
js
:
:
jit
:
:
Simulator
*
simulator
(
)
const
;
JS
:
:
NativeStackLimit
*
addressOfSimulatorStackLimit
(
)
;
#
endif
public
:
js
:
:
ContextData
<
DtoaState
*
>
dtoaState
;
js
:
:
ContextData
<
int32_t
>
suppressGC
;
#
ifdef
DEBUG
js
:
:
ContextData
<
size_t
>
noNurseryAllocationCheck
;
js
:
:
ContextData
<
uintptr_t
>
disableStrictProxyCheckingCount
;
bool
isNurseryAllocAllowed
(
)
{
return
noNurseryAllocationCheck
=
=
0
;
}
void
disallowNurseryAlloc
(
)
{
+
+
noNurseryAllocationCheck
;
}
void
allowNurseryAlloc
(
)
{
MOZ_ASSERT
(
!
isNurseryAllocAllowed
(
)
)
;
-
-
noNurseryAllocationCheck
;
}
bool
isStrictProxyCheckingEnabled
(
)
{
return
disableStrictProxyCheckingCount
=
=
0
;
}
void
disableStrictProxyChecking
(
)
{
+
+
disableStrictProxyCheckingCount
;
}
void
enableStrictProxyChecking
(
)
{
MOZ_ASSERT
(
disableStrictProxyCheckingCount
>
0
)
;
-
-
disableStrictProxyCheckingCount
;
}
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
js
:
:
ContextData
<
bool
>
runningOOMTest
;
#
endif
js
:
:
ContextData
<
int
>
inUnsafeRegion
;
js
:
:
ContextData
<
unsigned
>
generationalDisabled
;
js
:
:
ContextData
<
unsigned
>
compactingDisabledCount
;
private
:
js
:
:
ContextData
<
js
:
:
frontend
:
:
NameCollectionPool
>
frontendCollectionPool_
;
public
:
js
:
:
frontend
:
:
NameCollectionPool
&
frontendCollectionPool
(
)
{
return
frontendCollectionPool_
.
ref
(
)
;
}
void
verifyIsSafeToGC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
inUnsafeRegion
"
[
AutoAssertNoGC
]
possible
GC
in
GC
-
unsafe
region
"
)
;
}
private
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
suppressProfilerSampling
;
public
:
bool
isProfilerSamplingEnabled
(
)
const
{
return
!
suppressProfilerSampling
;
}
void
disableProfilerSampling
(
)
{
suppressProfilerSampling
=
true
;
}
void
enableProfilerSampling
(
)
{
suppressProfilerSampling
=
false
;
}
private
:
js
:
:
wasm
:
:
Context
wasm_
;
public
:
js
:
:
wasm
:
:
Context
&
wasm
(
)
{
return
wasm_
;
}
static
const
size_t
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
=
4
*
1024
;
private
:
js
:
:
ContextData
<
js
:
:
LifoAlloc
>
tempLifoAlloc_
;
public
:
js
:
:
LifoAlloc
&
tempLifoAlloc
(
)
{
return
tempLifoAlloc_
.
ref
(
)
;
}
const
js
:
:
LifoAlloc
&
tempLifoAlloc
(
)
const
{
return
tempLifoAlloc_
.
ref
(
)
;
}
js
:
:
LifoAlloc
&
tempLifoAllocNoCheck
(
)
{
return
tempLifoAlloc_
.
refNoCheck
(
)
;
}
js
:
:
ContextData
<
uint32_t
>
debuggerMutations
;
js
:
:
ContextData
<
js
:
:
UniquePtr
<
js
:
:
jit
:
:
PcScriptCache
>
>
ionPcScriptCache
;
private
:
js
:
:
ContextData
<
JS
:
:
ExceptionStatus
>
status
;
js
:
:
ContextData
<
JS
:
:
PersistentRooted
<
JS
:
:
Value
>
>
unwrappedException_
;
js
:
:
ContextData
<
JS
:
:
PersistentRooted
<
js
:
:
SavedFrame
*
>
>
unwrappedExceptionStack_
;
JS
:
:
Value
&
unwrappedException
(
)
{
if
(
!
unwrappedException_
.
ref
(
)
.
initialized
(
)
)
{
unwrappedException_
.
ref
(
)
.
init
(
this
)
;
}
return
unwrappedException_
.
ref
(
)
.
get
(
)
;
}
js
:
:
SavedFrame
*
&
unwrappedExceptionStack
(
)
{
if
(
!
unwrappedExceptionStack_
.
ref
(
)
.
initialized
(
)
)
{
unwrappedExceptionStack_
.
ref
(
)
.
init
(
this
)
;
}
return
unwrappedExceptionStack_
.
ref
(
)
.
get
(
)
;
}
#
ifdef
DEBUG
js
:
:
ContextData
<
bool
>
hadNondeterministicException_
;
public
:
bool
hadNondeterministicException
(
)
const
{
return
hadNondeterministicException_
|
|
js
:
:
oom
:
:
simulator
.
isThreadSimulatingAny
(
)
;
}
#
endif
public
:
js
:
:
ContextData
<
int32_t
>
reportGranularity
;
js
:
:
ContextData
<
js
:
:
AutoResolving
*
>
resolvingList
;
#
ifdef
DEBUG
js
:
:
ContextData
<
js
:
:
AutoEnterPolicy
*
>
enteredPolicy
;
#
endif
js
:
:
ContextData
<
bool
>
generatingError
;
private
:
js
:
:
ContextData
<
js
:
:
AutoCycleDetector
:
:
Vector
>
cycleDetectorVector_
;
public
:
js
:
:
AutoCycleDetector
:
:
Vector
&
cycleDetectorVector
(
)
{
return
cycleDetectorVector_
.
ref
(
)
;
}
const
js
:
:
AutoCycleDetector
:
:
Vector
&
cycleDetectorVector
(
)
const
{
return
cycleDetectorVector_
.
ref
(
)
;
}
private
:
js
:
:
ContextData
<
JS
:
:
PersistentRooted
<
JSFunction
*
>
>
watchtowerTestingCallback_
;
public
:
JSFunction
*
&
watchtowerTestingCallbackRef
(
)
{
if
(
!
watchtowerTestingCallback_
.
ref
(
)
.
initialized
(
)
)
{
watchtowerTestingCallback_
.
ref
(
)
.
init
(
this
)
;
}
return
watchtowerTestingCallback_
.
ref
(
)
.
get
(
)
;
}
js
:
:
UnprotectedData
<
void
*
>
data
;
void
initJitStackLimit
(
)
;
void
resetJitStackLimit
(
)
;
public
:
JS
:
:
ContextOptions
&
options
(
)
{
return
options_
.
ref
(
)
;
}
bool
runtimeMatches
(
JSRuntime
*
rt
)
const
{
return
runtime_
=
=
rt
;
}
private
:
js
:
:
ContextData
<
JS
:
:
PersistentRooted
<
js
:
:
SavedFrame
*
>
>
asyncStackForNewActivations_
;
public
:
js
:
:
SavedFrame
*
&
asyncStackForNewActivations
(
)
{
if
(
!
asyncStackForNewActivations_
.
ref
(
)
.
initialized
(
)
)
{
asyncStackForNewActivations_
.
ref
(
)
.
init
(
this
)
;
}
return
asyncStackForNewActivations_
.
ref
(
)
.
get
(
)
;
}
js
:
:
ContextData
<
const
char
*
>
asyncCauseForNewActivations
;
js
:
:
ContextData
<
bool
>
asyncCallIsExplicit
;
bool
currentlyRunningInInterpreter
(
)
const
{
return
activation
(
)
-
>
isInterpreter
(
)
;
}
bool
currentlyRunningInJit
(
)
const
{
return
activation
(
)
-
>
isJit
(
)
;
}
js
:
:
InterpreterFrame
*
interpreterFrame
(
)
const
{
return
activation
(
)
-
>
asInterpreter
(
)
-
>
current
(
)
;
}
js
:
:
InterpreterRegs
&
interpreterRegs
(
)
const
{
return
activation
(
)
-
>
asInterpreter
(
)
-
>
regs
(
)
;
}
enum
class
AllowCrossRealm
{
DontAllow
=
false
Allow
=
true
}
;
inline
JSScript
*
currentScript
(
jsbytecode
*
*
pc
=
nullptr
AllowCrossRealm
allowCrossRealm
=
AllowCrossRealm
:
:
DontAllow
)
const
;
inline
js
:
:
Nursery
&
nursery
(
)
;
inline
void
minorGC
(
JS
:
:
GCReason
reason
)
;
public
:
bool
isExceptionPending
(
)
const
{
return
JS
:
:
IsCatchableExceptionStatus
(
status
)
;
}
[
[
nodiscard
]
]
bool
getPendingException
(
JS
:
:
MutableHandleValue
rval
)
;
js
:
:
SavedFrame
*
getPendingExceptionStack
(
)
;
bool
isThrowingDebuggeeWouldRun
(
)
;
bool
isClosingGenerator
(
)
;
void
setPendingException
(
JS
:
:
HandleValue
v
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
stack
)
;
void
setPendingException
(
JS
:
:
HandleValue
v
js
:
:
ShouldCaptureStack
captureStack
)
;
void
clearPendingException
(
)
{
status
=
JS
:
:
ExceptionStatus
:
:
None
;
unwrappedException
(
)
.
setUndefined
(
)
;
unwrappedExceptionStack
(
)
=
nullptr
;
}
bool
isThrowingOutOfMemory
(
)
const
{
return
status
=
=
JS
:
:
ExceptionStatus
:
:
OutOfMemory
;
}
bool
isThrowingOverRecursed
(
)
const
{
return
status
=
=
JS
:
:
ExceptionStatus
:
:
OverRecursed
;
}
bool
isPropagatingForcedReturn
(
)
const
{
return
status
=
=
JS
:
:
ExceptionStatus
:
:
ForcedReturn
;
}
void
setPropagatingForcedReturn
(
)
{
MOZ_ASSERT
(
status
=
=
JS
:
:
ExceptionStatus
:
:
None
)
;
status
=
JS
:
:
ExceptionStatus
:
:
ForcedReturn
;
}
void
clearPropagatingForcedReturn
(
)
{
MOZ_ASSERT
(
status
=
=
JS
:
:
ExceptionStatus
:
:
ForcedReturn
)
;
status
=
JS
:
:
ExceptionStatus
:
:
None
;
}
inline
bool
runningWithTrustedPrincipals
(
)
;
bool
isRuntimeCodeGenEnabled
(
JS
:
:
RuntimeCode
kind
js
:
:
HandleString
code
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
trace
(
JSTracer
*
trc
)
;
inline
js
:
:
RuntimeCaches
&
caches
(
)
;
public
:
using
InterruptCallbackVector
=
js
:
:
Vector
<
JSInterruptCallback
2
js
:
:
SystemAllocPolicy
>
;
private
:
js
:
:
ContextData
<
InterruptCallbackVector
>
interruptCallbacks_
;
public
:
InterruptCallbackVector
&
interruptCallbacks
(
)
{
return
interruptCallbacks_
.
ref
(
)
;
}
js
:
:
ContextData
<
bool
>
interruptCallbackDisabled
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interruptBits_
;
void
requestInterrupt
(
js
:
:
InterruptReason
reason
)
;
bool
handleInterrupt
(
)
;
MOZ_ALWAYS_INLINE
bool
hasAnyPendingInterrupt
(
)
const
{
static_assert
(
sizeof
(
interruptBits_
)
=
=
sizeof
(
uint32_t
)
"
Assumed
by
JIT
callers
"
)
;
return
interruptBits_
!
=
0
;
}
bool
hasPendingInterrupt
(
js
:
:
InterruptReason
reason
)
const
{
return
interruptBits_
&
uint32_t
(
reason
)
;
}
js
:
:
ContextData
<
js
:
:
jit
:
:
ICScript
*
>
inlinedICScript_
;
public
:
void
*
addressOfInterruptBits
(
)
{
return
&
interruptBits_
;
}
void
*
addressOfJitStackLimit
(
)
{
MOZ_ASSERT
(
isMainThreadContext
(
)
)
;
return
&
jitStackLimit
;
}
void
*
addressOfJitStackLimitNoInterrupt
(
)
{
MOZ_ASSERT
(
isMainThreadContext
(
)
)
;
return
&
jitStackLimitNoInterrupt
;
}
void
*
addressOfZone
(
)
{
return
&
zone_
;
}
const
void
*
addressOfRealm
(
)
const
{
return
&
realm_
;
}
void
*
addressOfInlinedICScript
(
)
{
return
&
inlinedICScript_
;
}
js
:
:
FutexThread
fx
;
mozilla
:
:
Atomic
<
JS
:
:
NativeStackLimit
mozilla
:
:
Relaxed
>
jitStackLimit
;
js
:
:
ContextData
<
JS
:
:
NativeStackLimit
>
jitStackLimitNoInterrupt
;
js
:
:
ContextData
<
JS
:
:
JobQueue
*
>
jobQueue
;
js
:
:
ContextData
<
js
:
:
UniquePtr
<
js
:
:
InternalJobQueue
>
>
internalJobQueue
;
js
:
:
ContextData
<
bool
>
canSkipEnqueuingJobs
;
js
:
:
ContextData
<
JS
:
:
PromiseRejectionTrackerCallback
>
promiseRejectionTrackerCallback
;
js
:
:
ContextData
<
void
*
>
promiseRejectionTrackerCallbackData
;
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
;
bool
enqueuePromiseJob
(
JSContext
*
cx
js
:
:
HandleFunction
job
js
:
:
HandleObject
promise
js
:
:
HandleObject
incumbentGlobal
)
;
void
addUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
void
removeUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
private
:
template
<
class
.
.
.
Args
>
inline
void
checkImpl
(
const
Args
&
.
.
.
args
)
;
bool
contextChecksEnabled
(
)
const
{
return
!
RuntimeHeapIsCollecting
(
runtime
(
)
-
>
heapState
(
)
)
;
}
public
:
template
<
class
.
.
.
Args
>
inline
void
check
(
const
Args
&
.
.
.
args
)
;
template
<
class
.
.
.
Args
>
inline
void
releaseCheck
(
const
Args
&
.
.
.
args
)
;
template
<
class
.
.
.
Args
>
MOZ_ALWAYS_INLINE
void
debugOnlyCheck
(
const
Args
&
.
.
.
args
)
;
#
ifdef
JS_STRUCTURED_SPEW
private
:
js
:
:
UnprotectedData
<
js
:
:
StructuredSpewer
>
structuredSpewer_
;
public
:
js
:
:
StructuredSpewer
&
spewer
(
)
{
return
structuredSpewer_
.
ref
(
)
;
}
#
endif
js
:
:
ContextData
<
js
:
:
Debugger
*
>
insideDebuggerEvaluationWithOnNativeCallHook
;
}
;
inline
JS
:
:
Result
<
>
JSContext
:
:
boolToResult
(
bool
ok
)
{
if
(
MOZ_LIKELY
(
ok
)
)
{
MOZ_ASSERT
(
!
isExceptionPending
(
)
)
;
MOZ_ASSERT
(
!
isPropagatingForcedReturn
(
)
)
;
return
JS
:
:
Ok
(
)
;
}
return
JS
:
:
Result
<
>
(
JS
:
:
Error
(
)
)
;
}
inline
JSContext
*
JSRuntime
:
:
mainContextFromOwnThread
(
)
{
MOZ_ASSERT
(
mainContextFromAnyThread
(
)
=
=
js
:
:
TlsContext
.
get
(
)
)
;
return
mainContextFromAnyThread
(
)
;
}
namespace
js
{
struct
MOZ_RAII
AutoResolving
{
public
:
enum
Kind
{
LOOKUP
WATCH
}
;
AutoResolving
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Kind
kind
=
LOOKUP
)
:
context
(
cx
)
object
(
obj
)
id
(
id
)
kind
(
kind
)
link
(
cx
-
>
resolvingList
)
{
MOZ_ASSERT
(
obj
)
;
cx
-
>
resolvingList
=
this
;
}
~
AutoResolving
(
)
{
MOZ_ASSERT
(
context
-
>
resolvingList
=
=
this
)
;
context
-
>
resolvingList
=
link
;
}
bool
alreadyStarted
(
)
const
{
return
link
&
&
alreadyStartedSlow
(
)
;
}
private
:
bool
alreadyStartedSlow
(
)
const
;
JSContext
*
const
context
;
HandleObject
object
;
HandleId
id
;
Kind
const
kind
;
AutoResolving
*
const
link
;
}
;
extern
JSContext
*
NewContext
(
uint32_t
maxBytes
JSRuntime
*
parentRuntime
)
;
extern
void
DestroyContext
(
JSContext
*
cx
)
;
extern
void
ReportUsageErrorASCII
(
JSContext
*
cx
HandleObject
callee
const
char
*
msg
)
;
extern
void
ReportIsNotDefined
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
)
;
extern
void
ReportIsNotDefined
(
JSContext
*
cx
HandleId
id
)
;
extern
void
ReportIsNullOrUndefinedForPropertyAccess
(
JSContext
*
cx
HandleValue
v
int
vIndex
)
;
extern
void
ReportIsNullOrUndefinedForPropertyAccess
(
JSContext
*
cx
HandleValue
v
int
vIndex
HandleId
key
)
;
extern
bool
ReportValueError
(
JSContext
*
cx
const
unsigned
errorNumber
int
spindex
HandleValue
v
HandleString
fallback
const
char
*
arg1
=
nullptr
const
char
*
arg2
=
nullptr
)
;
JSObject
*
CreateErrorNotesArray
(
JSContext
*
cx
JSErrorReport
*
report
)
;
class
MOZ_STACK_CLASS
ExternalValueArray
{
public
:
ExternalValueArray
(
size_t
len
Value
*
vec
)
:
array_
(
vec
)
length_
(
len
)
{
}
Value
*
begin
(
)
{
return
array_
;
}
size_t
length
(
)
{
return
length_
;
}
void
trace
(
JSTracer
*
trc
)
;
private
:
Value
*
array_
;
size_t
length_
;
}
;
class
MOZ_RAII
RootedExternalValueArray
:
public
JS
:
:
Rooted
<
ExternalValueArray
>
{
public
:
RootedExternalValueArray
(
JSContext
*
cx
size_t
len
Value
*
vec
)
:
JS
:
:
Rooted
<
ExternalValueArray
>
(
cx
ExternalValueArray
(
len
vec
)
)
{
}
private
:
}
;
class
AutoAssertNoPendingException
{
#
ifdef
DEBUG
JSContext
*
cx_
;
public
:
explicit
AutoAssertNoPendingException
(
JSContext
*
cxArg
)
:
cx_
(
cxArg
)
{
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
cx_
)
)
;
}
~
AutoAssertNoPendingException
(
)
{
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
cx_
)
)
;
}
#
else
public
:
explicit
AutoAssertNoPendingException
(
JSContext
*
cxArg
)
{
}
#
endif
}
;
class
MOZ_RAII
AutoLockScriptData
{
JSRuntime
*
runtime
;
public
:
explicit
AutoLockScriptData
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
|
|
CurrentThreadIsParseThread
(
)
)
;
runtime
=
rt
;
if
(
runtime
-
>
hasParseTasks
(
)
)
{
runtime
-
>
scriptDataLock
.
lock
(
)
;
}
else
{
MOZ_ASSERT
(
!
runtime
-
>
activeThreadHasScriptDataAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasScriptDataAccess
=
true
;
#
endif
}
}
~
AutoLockScriptData
(
)
{
if
(
runtime
-
>
hasParseTasks
(
)
)
{
runtime
-
>
scriptDataLock
.
unlock
(
)
;
}
else
{
MOZ_ASSERT
(
runtime
-
>
activeThreadHasScriptDataAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasScriptDataAccess
=
false
;
#
endif
}
}
}
;
class
MOZ_RAII
AutoNoteDebuggerEvaluationWithOnNativeCallHook
{
JSContext
*
cx
;
Debugger
*
oldValue
;
public
:
AutoNoteDebuggerEvaluationWithOnNativeCallHook
(
JSContext
*
cx
Debugger
*
dbg
)
:
cx
(
cx
)
oldValue
(
cx
-
>
insideDebuggerEvaluationWithOnNativeCallHook
)
{
cx
-
>
insideDebuggerEvaluationWithOnNativeCallHook
=
dbg
;
}
~
AutoNoteDebuggerEvaluationWithOnNativeCallHook
(
)
{
cx
-
>
insideDebuggerEvaluationWithOnNativeCallHook
=
oldValue
;
}
}
;
enum
UnsafeABIStrictness
{
NoExceptions
AllowPendingExceptions
AllowThrownExceptions
}
;
class
MOZ_RAII
AutoUnsafeCallWithABI
{
#
ifdef
DEBUG
JSContext
*
cx_
;
bool
nested_
;
bool
checkForPendingException_
;
#
endif
JS
:
:
AutoCheckCannotGC
nogc
;
public
:
#
ifdef
DEBUG
explicit
AutoUnsafeCallWithABI
(
UnsafeABIStrictness
strictness
=
UnsafeABIStrictness
:
:
NoExceptions
)
;
~
AutoUnsafeCallWithABI
(
)
;
#
else
explicit
AutoUnsafeCallWithABI
(
UnsafeABIStrictness
unused_
=
UnsafeABIStrictness
:
:
NoExceptions
)
{
}
#
endif
}
;
namespace
gc
{
class
MOZ_RAII
AutoSuppressNurseryCellAlloc
{
JSContext
*
cx_
;
public
:
explicit
AutoSuppressNurseryCellAlloc
(
JSContext
*
cx
)
:
cx_
(
cx
)
{
cx_
-
>
nurserySuppressions_
+
+
;
}
~
AutoSuppressNurseryCellAlloc
(
)
{
cx_
-
>
nurserySuppressions_
-
-
;
}
}
;
}
}
#
define
CHECK_THREAD
(
cx
)
\
MOZ_ASSERT_IF
(
cx
!
cx
-
>
isHelperThreadContext
(
)
&
&
\
js
:
:
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
#
endif
