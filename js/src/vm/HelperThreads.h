#
ifndef
vm_HelperThreads_h
#
define
vm_HelperThreads_h
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jslock
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Mutex
.
h
"
namespace
js
{
class
AutoLockHelperThreadState
;
class
AutoUnlockHelperThreadState
;
struct
HelperThread
;
struct
ParseTask
;
namespace
jit
{
class
IonBuilder
;
}
namespace
wasm
{
class
FuncIR
;
class
FunctionCompileResults
;
class
IonCompileTask
;
typedef
Vector
<
IonCompileTask
*
0
SystemAllocPolicy
>
IonCompileTaskPtrVector
;
}
enum
class
ParseTaskKind
{
Script
Module
}
;
class
GlobalHelperThreadState
{
friend
class
AutoLockHelperThreadState
;
friend
class
AutoUnlockHelperThreadState
;
public
:
size_t
cpuCount
;
size_t
threadCount
;
typedef
Vector
<
jit
:
:
IonBuilder
*
0
SystemAllocPolicy
>
IonBuilderVector
;
typedef
Vector
<
ParseTask
*
0
SystemAllocPolicy
>
ParseTaskVector
;
typedef
Vector
<
SourceCompressionTask
*
0
SystemAllocPolicy
>
SourceCompressionTaskVector
;
typedef
Vector
<
GCHelperState
*
0
SystemAllocPolicy
>
GCHelperStateVector
;
typedef
Vector
<
GCParallelTask
*
0
SystemAllocPolicy
>
GCParallelTaskVector
;
HelperThread
*
threads
;
private
:
IonBuilderVector
ionWorklist_
ionFinishedList_
;
wasm
:
:
IonCompileTaskPtrVector
wasmWorklist_
wasmFinishedList_
;
public
:
mozilla
:
:
Atomic
<
bool
>
wasmCompilationInProgress
;
private
:
ParseTaskVector
parseWorklist_
parseFinishedList_
;
ParseTaskVector
parseWaitingOnGC_
;
SourceCompressionTaskVector
compressionWorklist_
;
GCHelperStateVector
gcHelperWorklist_
;
GCParallelTaskVector
gcParallelWorklist_
;
ParseTask
*
removeFinishedParseTask
(
ParseTaskKind
kind
void
*
token
)
;
public
:
size_t
maxIonCompilationThreads
(
)
const
;
size_t
maxUnpausedIonCompilationThreads
(
)
const
;
size_t
maxWasmCompilationThreads
(
)
const
;
size_t
maxParseThreads
(
)
const
;
size_t
maxCompressionThreads
(
)
const
;
size_t
maxGCHelperThreads
(
)
const
;
size_t
maxGCParallelThreads
(
)
const
;
GlobalHelperThreadState
(
)
;
bool
ensureInitialized
(
)
;
void
finish
(
)
;
void
finishThreads
(
)
;
void
lock
(
)
;
void
unlock
(
)
;
#
ifdef
DEBUG
bool
isLocked
(
)
;
#
endif
enum
CondVar
{
CONSUMER
PRODUCER
PAUSE
}
;
void
wait
(
AutoLockHelperThreadState
&
locked
CondVar
which
mozilla
:
:
TimeDuration
timeout
=
mozilla
:
:
TimeDuration
:
:
Forever
(
)
)
;
void
notifyAll
(
CondVar
which
)
;
void
notifyOne
(
CondVar
which
)
;
template
<
typename
T
>
void
remove
(
T
&
vector
size_t
*
index
)
{
vector
[
(
*
index
)
-
-
]
=
vector
.
back
(
)
;
vector
.
popBack
(
)
;
}
IonBuilderVector
&
ionWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
ionWorklist_
;
}
IonBuilderVector
&
ionFinishedList
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
ionFinishedList_
;
}
wasm
:
:
IonCompileTaskPtrVector
&
wasmWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
wasmWorklist_
;
}
wasm
:
:
IonCompileTaskPtrVector
&
wasmFinishedList
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
wasmFinishedList_
;
}
ParseTaskVector
&
parseWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
parseWorklist_
;
}
ParseTaskVector
&
parseFinishedList
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
parseFinishedList_
;
}
ParseTaskVector
&
parseWaitingOnGC
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
parseWaitingOnGC_
;
}
SourceCompressionTaskVector
&
compressionWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
compressionWorklist_
;
}
GCHelperStateVector
&
gcHelperWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
gcHelperWorklist_
;
}
GCParallelTaskVector
&
gcParallelWorklist
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
gcParallelWorklist_
;
}
bool
canStartWasmCompile
(
)
;
bool
canStartIonCompile
(
)
;
bool
canStartParseTask
(
)
;
bool
canStartCompressionTask
(
)
;
bool
canStartGCHelperTask
(
)
;
bool
canStartGCParallelTask
(
)
;
bool
pendingIonCompileHasSufficientPriority
(
)
;
jit
:
:
IonBuilder
*
highestPriorityPendingIonCompile
(
bool
remove
=
false
)
;
HelperThread
*
lowestPriorityUnpausedIonCompileAtThreshold
(
)
;
HelperThread
*
highestPriorityPausedIonCompile
(
)
;
uint32_t
harvestFailedWasmJobs
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
uint32_t
n
=
numWasmFailedJobs
;
numWasmFailedJobs
=
0
;
return
n
;
}
void
noteWasmFailure
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
numWasmFailedJobs
+
+
;
}
bool
wasmFailed
(
)
{
MOZ_ASSERT
(
isLocked
(
)
)
;
return
bool
(
numWasmFailedJobs
)
;
}
JSScript
*
finishParseTask
(
JSContext
*
cx
ParseTaskKind
kind
void
*
token
)
;
void
cancelParseTask
(
JSContext
*
cx
ParseTaskKind
kind
void
*
token
)
;
void
mergeParseTaskCompartment
(
JSContext
*
cx
ParseTask
*
parseTask
Handle
<
GlobalObject
*
>
global
JSCompartment
*
dest
)
;
private
:
uint32_t
numWasmFailedJobs
;
public
:
JSScript
*
finishScriptParseTask
(
JSContext
*
cx
void
*
token
)
;
JSObject
*
finishModuleParseTask
(
JSContext
*
cx
void
*
token
)
;
bool
compressionInProgress
(
SourceCompressionTask
*
task
)
;
SourceCompressionTask
*
compressionTaskForSource
(
ScriptSource
*
ss
)
;
bool
hasActiveThreads
(
)
;
void
waitForAllThreads
(
)
;
template
<
typename
T
>
bool
checkTaskThreadLimit
(
size_t
maxThreads
)
const
;
private
:
js
:
:
Mutex
helperLock
;
#
ifdef
DEBUG
mozilla
:
:
Atomic
<
PRThread
*
>
lockOwner
;
#
endif
js
:
:
ConditionVariable
consumerWakeup
;
js
:
:
ConditionVariable
producerWakeup
;
js
:
:
ConditionVariable
pauseWakeup
;
js
:
:
ConditionVariable
&
whichWakeup
(
CondVar
which
)
{
switch
(
which
)
{
case
CONSUMER
:
return
consumerWakeup
;
case
PRODUCER
:
return
producerWakeup
;
case
PAUSE
:
return
pauseWakeup
;
default
:
MOZ_CRASH
(
"
Invalid
CondVar
in
|
whichWakeup
|
"
)
;
}
}
}
;
static
inline
GlobalHelperThreadState
&
HelperThreadState
(
)
{
extern
GlobalHelperThreadState
*
gHelperThreadState
;
MOZ_ASSERT
(
gHelperThreadState
)
;
return
*
gHelperThreadState
;
}
struct
HelperThread
{
mozilla
:
:
Maybe
<
PerThreadData
>
threadData
;
PRThread
*
thread
;
bool
terminate
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
pause
;
mozilla
:
:
Maybe
<
mozilla
:
:
Variant
<
jit
:
:
IonBuilder
*
wasm
:
:
IonCompileTask
*
ParseTask
*
SourceCompressionTask
*
GCHelperState
*
GCParallelTask
*
>
>
currentTask
;
bool
idle
(
)
const
{
return
currentTask
.
isNothing
(
)
;
}
jit
:
:
IonBuilder
*
ionBuilder
(
)
{
return
maybeCurrentTaskAs
<
jit
:
:
IonBuilder
*
>
(
)
;
}
wasm
:
:
IonCompileTask
*
wasmTask
(
)
{
return
maybeCurrentTaskAs
<
wasm
:
:
IonCompileTask
*
>
(
)
;
}
ParseTask
*
parseTask
(
)
{
return
maybeCurrentTaskAs
<
ParseTask
*
>
(
)
;
}
SourceCompressionTask
*
compressionTask
(
)
{
return
maybeCurrentTaskAs
<
SourceCompressionTask
*
>
(
)
;
}
GCHelperState
*
gcHelperTask
(
)
{
return
maybeCurrentTaskAs
<
GCHelperState
*
>
(
)
;
}
GCParallelTask
*
gcParallelTask
(
)
{
return
maybeCurrentTaskAs
<
GCParallelTask
*
>
(
)
;
}
void
destroy
(
)
;
static
void
ThreadMain
(
void
*
arg
)
;
void
threadLoop
(
)
;
private
:
template
<
typename
T
>
T
maybeCurrentTaskAs
(
)
{
if
(
currentTask
.
isSome
(
)
&
&
currentTask
-
>
is
<
T
>
(
)
)
return
currentTask
-
>
as
<
T
>
(
)
;
return
nullptr
;
}
void
handleWasmWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleIonWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleParseWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleCompressionWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleGCHelperWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleGCParallelWorkload
(
AutoLockHelperThreadState
&
locked
)
;
}
;
bool
CreateHelperThreadsState
(
)
;
void
DestroyHelperThreadsState
(
)
;
bool
EnsureHelperThreadsInitialized
(
)
;
void
SetFakeCPUCount
(
size_t
count
)
;
void
PauseCurrentHelperThread
(
)
;
bool
StartOffThreadWasmCompile
(
wasm
:
:
IonCompileTask
*
task
)
;
bool
StartOffThreadIonCompile
(
JSContext
*
cx
jit
:
:
IonBuilder
*
builder
)
;
void
CancelOffThreadIonCompile
(
JSCompartment
*
compartment
JSScript
*
script
bool
discardLazyLinkList
=
true
)
;
void
CancelOffThreadParses
(
JSRuntime
*
runtime
)
;
bool
StartOffThreadParseScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadParseModule
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
EnqueuePendingParseTasksAfterGC
(
JSRuntime
*
rt
)
;
struct
AutoEnqueuePendingParseTasksAfterGC
{
const
gc
:
:
GCRuntime
&
gc_
;
explicit
AutoEnqueuePendingParseTasksAfterGC
(
const
gc
:
:
GCRuntime
&
gc
)
:
gc_
(
gc
)
{
}
~
AutoEnqueuePendingParseTasksAfterGC
(
)
;
}
;
bool
StartOffThreadCompression
(
ExclusiveContext
*
cx
SourceCompressionTask
*
task
)
;
class
MOZ_RAII
AutoLockHelperThreadState
:
public
LockGuard
<
Mutex
>
{
using
Base
=
LockGuard
<
Mutex
>
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoLockHelperThreadState
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
:
Base
(
HelperThreadState
(
)
.
helperLock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
DEBUG
HelperThreadState
(
)
.
lockOwner
=
PR_GetCurrentThread
(
)
;
#
endif
}
~
AutoLockHelperThreadState
(
)
{
#
ifdef
DEBUG
HelperThreadState
(
)
.
lockOwner
=
nullptr
;
#
endif
}
}
;
class
MOZ_RAII
AutoUnlockHelperThreadState
{
mozilla
:
:
Maybe
<
UnlockGuard
<
Mutex
>
>
unlocked
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoUnlockHelperThreadState
(
AutoLockHelperThreadState
&
locked
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
DEBUG
HelperThreadState
(
)
.
lockOwner
=
nullptr
;
#
endif
unlocked
.
emplace
(
locked
)
;
}
~
AutoUnlockHelperThreadState
(
)
{
unlocked
.
reset
(
)
;
#
ifdef
DEBUG
HelperThreadState
(
)
.
lockOwner
=
PR_GetCurrentThread
(
)
;
#
endif
}
}
;
struct
ParseTask
{
ParseTaskKind
kind
;
ExclusiveContext
*
cx
;
OwningCompileOptions
options
;
const
char16_t
*
chars
;
size_t
length
;
LifoAlloc
alloc
;
PersistentRootedObject
exclusiveContextGlobal
;
JS
:
:
OffThreadCompileCallback
callback
;
void
*
callbackData
;
PersistentRootedScript
script
;
PersistentRooted
<
ScriptSourceObject
*
>
sourceObject
;
Vector
<
frontend
:
:
CompileError
*
>
errors
;
bool
overRecursed
;
bool
outOfMemory
;
ParseTask
(
ParseTaskKind
kind
ExclusiveContext
*
cx
JSObject
*
exclusiveContextGlobal
JSContext
*
initCx
const
char16_t
*
chars
size_t
length
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
init
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
)
;
void
activate
(
JSRuntime
*
rt
)
;
virtual
void
parse
(
)
=
0
;
bool
finish
(
JSContext
*
cx
)
;
bool
runtimeMatches
(
JSRuntime
*
rt
)
{
return
exclusiveContextGlobal
-
>
runtimeFromAnyThread
(
)
=
=
rt
;
}
virtual
~
ParseTask
(
)
;
}
;
struct
ScriptParseTask
:
public
ParseTask
{
ScriptParseTask
(
ExclusiveContext
*
cx
JSObject
*
exclusiveContextGlobal
JSContext
*
initCx
const
char16_t
*
chars
size_t
length
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
)
override
;
}
;
struct
ModuleParseTask
:
public
ParseTask
{
ModuleParseTask
(
ExclusiveContext
*
cx
JSObject
*
exclusiveContextGlobal
JSContext
*
initCx
const
char16_t
*
chars
size_t
length
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
)
override
;
}
;
extern
bool
OffThreadParsingMustWaitForGC
(
JSRuntime
*
rt
)
;
struct
SourceCompressionTask
{
friend
class
ScriptSource
;
friend
struct
HelperThread
;
HelperThread
*
helperThread
;
private
:
ExclusiveContext
*
cx
;
ScriptSource
*
ss
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
abort_
;
enum
ResultType
{
OOM
Aborted
Success
}
result
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
resultString
;
public
:
explicit
SourceCompressionTask
(
ExclusiveContext
*
cx
)
:
helperThread
(
nullptr
)
cx
(
cx
)
ss
(
nullptr
)
abort_
(
false
)
result
(
OOM
)
{
}
~
SourceCompressionTask
(
)
{
complete
(
)
;
}
ResultType
work
(
)
;
bool
complete
(
)
;
void
abort
(
)
{
abort_
=
true
;
}
bool
active
(
)
const
{
return
!
!
ss
;
}
ScriptSource
*
source
(
)
{
return
ss
;
}
}
;
}
#
endif
