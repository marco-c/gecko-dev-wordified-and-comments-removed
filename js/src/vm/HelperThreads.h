#
ifndef
vm_HelperThreads_h
#
define
vm_HelperThreads_h
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
namespace
mozilla
{
union
Utf8Unit
;
}
namespace
JS
{
class
OffThreadToken
{
}
;
class
ReadOnlyCompileOptions
;
class
Zone
;
template
<
typename
UnitT
>
class
SourceText
;
}
namespace
js
{
class
AutoLockHelperThreadState
;
struct
PromiseHelperTask
;
class
SourceCompressionTask
;
namespace
gc
{
class
GCRuntime
;
}
namespace
jit
{
class
IonCompileTask
;
class
IonFreeTask
;
}
namespace
wasm
{
struct
CompileTask
;
struct
CompileTaskState
;
struct
Tier2GeneratorTask
;
using
UniqueTier2GeneratorTask
=
UniquePtr
<
Tier2GeneratorTask
>
;
}
extern
Mutex
gHelperThreadLock
MOZ_UNANNOTATED
;
class
MOZ_RAII
AutoLockHelperThreadState
:
public
LockGuard
<
Mutex
>
{
using
Base
=
LockGuard
<
Mutex
>
;
public
:
explicit
AutoLockHelperThreadState
(
)
:
Base
(
gHelperThreadLock
)
{
}
}
;
class
MOZ_RAII
AutoUnlockHelperThreadState
:
public
UnlockGuard
<
Mutex
>
{
using
Base
=
UnlockGuard
<
Mutex
>
;
public
:
explicit
AutoUnlockHelperThreadState
(
AutoLockHelperThreadState
&
locked
)
:
Base
(
locked
)
{
}
}
;
bool
CreateHelperThreadsState
(
)
;
void
DestroyHelperThreadsState
(
)
;
bool
EnsureHelperThreadsInitialized
(
)
;
size_t
GetHelperThreadCount
(
)
;
size_t
GetHelperThreadCPUCount
(
)
;
size_t
GetMaxWasmCompilationThreads
(
)
;
bool
SetFakeCPUCount
(
size_t
count
)
;
bool
StartOffThreadWasmCompile
(
wasm
:
:
CompileTask
*
task
wasm
:
:
CompileMode
mode
)
;
size_t
RemovePendingWasmCompileTasks
(
const
wasm
:
:
CompileTaskState
&
taskState
wasm
:
:
CompileMode
mode
const
AutoLockHelperThreadState
&
lock
)
;
void
StartOffThreadWasmTier2Generator
(
wasm
:
:
UniqueTier2GeneratorTask
task
)
;
void
CancelOffThreadWasmTier2Generator
(
)
;
bool
StartOffThreadPromiseHelperTask
(
JSContext
*
cx
UniquePtr
<
PromiseHelperTask
>
task
)
;
bool
StartOffThreadPromiseHelperTask
(
PromiseHelperTask
*
task
)
;
bool
StartOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
bool
StartOffThreadIonFree
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
FinishOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
struct
ZonesInState
{
JSRuntime
*
runtime
;
JS
:
:
shadow
:
:
Zone
:
:
GCState
state
;
}
;
using
CompilationSelector
=
mozilla
:
:
Variant
<
JSScript
*
JS
:
:
Realm
*
JS
:
:
Zone
*
ZonesInState
JSRuntime
*
>
;
void
CancelOffThreadIonCompile
(
const
CompilationSelector
&
selector
)
;
inline
void
CancelOffThreadIonCompile
(
JSScript
*
script
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
script
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JS
:
:
Realm
*
realm
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
realm
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JS
:
:
Zone
*
zone
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
zone
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JSRuntime
*
runtime
JS
:
:
shadow
:
:
Zone
:
:
GCState
state
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
ZonesInState
{
runtime
state
}
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JSRuntime
*
runtime
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
runtime
)
)
;
}
#
ifdef
DEBUG
bool
HasOffThreadIonCompile
(
JS
:
:
Realm
*
realm
)
;
#
endif
bool
CurrentThreadIsParseThread
(
)
;
void
CancelOffThreadParses
(
JSRuntime
*
runtime
)
;
void
CancelOffThreadDelazify
(
JSRuntime
*
runtime
)
;
void
WaitForAllDelazifyTasks
(
JSRuntime
*
rt
)
;
JS
:
:
OffThreadToken
*
StartOffThreadCompileToStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
JS
:
:
OffThreadToken
*
StartOffThreadCompileToStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
JS
:
:
OffThreadToken
*
StartOffThreadCompileModuleToStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
JS
:
:
OffThreadToken
*
StartOffThreadCompileModuleToStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
JS
:
:
OffThreadToken
*
StartOffThreadDecodeStencil
(
JSContext
*
cx
const
JS
:
:
DecodeOptions
&
options
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
JS
:
:
OffThreadToken
*
StartOffThreadDecodeMultiStencils
(
JSContext
*
cx
const
JS
:
:
DecodeOptions
&
options
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
[
[
nodiscard
]
]
bool
StartOffThreadDelazification
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
frontend
:
:
CompilationStencil
&
stencil
)
;
void
WaitForAllHelperThreads
(
)
;
void
WaitForAllHelperThreads
(
AutoLockHelperThreadState
&
lock
)
;
bool
EnqueueOffThreadCompression
(
JSContext
*
cx
UniquePtr
<
SourceCompressionTask
>
task
)
;
void
StartHandlingCompressionsOnGC
(
JSRuntime
*
rt
)
;
void
CancelOffThreadCompressions
(
JSRuntime
*
runtime
)
;
void
AttachFinishedCompressions
(
JSRuntime
*
runtime
AutoLockHelperThreadState
&
lock
)
;
void
SweepPendingCompressions
(
AutoLockHelperThreadState
&
lock
)
;
void
RunPendingSourceCompressions
(
JSRuntime
*
runtime
)
;
bool
IsOffThreadSourceCompressionEnabled
(
)
;
}
#
endif
