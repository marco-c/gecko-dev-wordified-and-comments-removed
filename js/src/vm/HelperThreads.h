#
ifndef
vm_HelperThreads_h
#
define
vm_HelperThreads_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
ds
/
Fifo
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
jit
/
JitContext
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
shadow
/
Zone
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
OffThreadPromiseRuntimeState
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
namespace
JS
{
class
OffThreadToken
{
}
;
}
namespace
js
{
class
AutoLockHelperThreadState
;
class
AutoUnlockHelperThreadState
;
class
CompileError
;
struct
ParseTask
;
struct
PromiseHelperTask
;
struct
HelperThreadTask
{
virtual
void
runTaskLocked
(
AutoLockHelperThreadState
&
locked
)
=
0
;
virtual
ThreadType
threadType
(
)
=
0
;
virtual
~
HelperThreadTask
(
)
=
default
;
}
;
namespace
jit
{
class
IonCompileTask
;
class
IonFreeTask
;
}
namespace
wasm
{
struct
Tier2GeneratorTask
;
}
enum
class
ParseTaskKind
{
Script
Module
ScriptDecode
MultiScriptsDecode
}
;
namespace
wasm
{
struct
CompileTask
;
typedef
Fifo
<
CompileTask
*
0
SystemAllocPolicy
>
CompileTaskPtrFifo
;
struct
Tier2GeneratorTask
:
public
HelperThreadTask
{
virtual
~
Tier2GeneratorTask
(
)
=
default
;
virtual
void
cancel
(
)
=
0
;
}
;
using
UniqueTier2GeneratorTask
=
UniquePtr
<
Tier2GeneratorTask
>
;
typedef
Vector
<
Tier2GeneratorTask
*
0
SystemAllocPolicy
>
Tier2GeneratorTaskPtrVector
;
}
class
GlobalHelperThreadState
{
friend
class
AutoLockHelperThreadState
;
friend
class
AutoUnlockHelperThreadState
;
public
:
static
const
size_t
MaxTier2GeneratorTasks
=
1
;
size_t
cpuCount
;
size_t
threadCount
;
typedef
Vector
<
jit
:
:
IonCompileTask
*
0
SystemAllocPolicy
>
IonCompileTaskVector
;
using
IonFreeTaskVector
=
Vector
<
js
:
:
UniquePtr
<
jit
:
:
IonFreeTask
>
0
SystemAllocPolicy
>
;
typedef
Vector
<
UniquePtr
<
ParseTask
>
0
SystemAllocPolicy
>
ParseTaskVector
;
using
ParseTaskList
=
mozilla
:
:
LinkedList
<
ParseTask
>
;
typedef
Vector
<
UniquePtr
<
SourceCompressionTask
>
0
SystemAllocPolicy
>
SourceCompressionTaskVector
;
using
GCParallelTaskList
=
mozilla
:
:
LinkedList
<
GCParallelTask
>
;
typedef
Vector
<
PromiseHelperTask
*
0
SystemAllocPolicy
>
PromiseHelperTaskVector
;
typedef
Vector
<
JSContext
*
0
SystemAllocPolicy
>
ContextVector
;
using
HelperThreadVector
=
Vector
<
UniquePtr
<
HelperThread
>
0
SystemAllocPolicy
>
;
WriteOnceData
<
JS
:
:
RegisterThreadCallback
>
registerThread
;
WriteOnceData
<
JS
:
:
UnregisterThreadCallback
>
unregisterThread
;
private
:
HelperThreadVector
threads_
;
IonCompileTaskVector
ionWorklist_
ionFinishedList_
;
IonFreeTaskVector
ionFreeList_
;
wasm
:
:
CompileTaskPtrFifo
wasmWorklist_tier1_
;
wasm
:
:
CompileTaskPtrFifo
wasmWorklist_tier2_
;
wasm
:
:
Tier2GeneratorTaskPtrVector
wasmTier2GeneratorWorklist_
;
uint32_t
wasmTier2GeneratorsFinished_
;
PromiseHelperTaskVector
promiseHelperTasks_
;
ParseTaskVector
parseWorklist_
;
ParseTaskList
parseFinishedList_
;
ParseTaskVector
parseWaitingOnGC_
;
SourceCompressionTaskVector
compressionPendingList_
;
SourceCompressionTaskVector
compressionWorklist_
;
SourceCompressionTaskVector
compressionFinishedList_
;
GCParallelTaskList
gcParallelWorklist_
;
size_t
gcParallelThreadCount
;
ContextVector
helperContexts_
;
ParseTask
*
removeFinishedParseTask
(
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
;
public
:
void
addSizeOfIncludingThis
(
JS
:
:
GlobalStats
*
stats
AutoLockHelperThreadState
&
lock
)
const
;
size_t
maxIonCompilationThreads
(
)
const
;
size_t
maxWasmCompilationThreads
(
)
const
;
size_t
maxWasmTier2GeneratorThreads
(
)
const
;
size_t
maxPromiseHelperThreads
(
)
const
;
size_t
maxParseThreads
(
)
const
;
size_t
maxCompressionThreads
(
)
const
;
size_t
maxGCParallelThreads
(
const
AutoLockHelperThreadState
&
lock
)
const
;
GlobalHelperThreadState
(
)
;
HelperThreadVector
&
threads
(
const
AutoLockHelperThreadState
&
lock
)
{
return
threads_
;
}
const
HelperThreadVector
&
threads
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
threads_
;
}
bool
ensureInitialized
(
)
;
bool
ensureThreadCount
(
size_t
count
)
;
void
finish
(
)
;
void
finishThreads
(
)
;
MOZ_MUST_USE
bool
ensureContextList
(
size_t
count
)
;
JSContext
*
getFirstUnusedContext
(
AutoLockHelperThreadState
&
locked
)
;
void
destroyHelperContexts
(
AutoLockHelperThreadState
&
lock
)
;
#
ifdef
DEBUG
bool
isLockedByCurrentThread
(
)
const
;
#
endif
enum
CondVar
{
CONSUMER
PRODUCER
}
;
void
wait
(
AutoLockHelperThreadState
&
locked
CondVar
which
mozilla
:
:
TimeDuration
timeout
=
mozilla
:
:
TimeDuration
:
:
Forever
(
)
)
;
void
notifyAll
(
CondVar
which
const
AutoLockHelperThreadState
&
)
;
void
notifyOne
(
CondVar
which
const
AutoLockHelperThreadState
&
)
;
template
<
typename
T
>
void
remove
(
T
&
vector
size_t
*
index
)
{
if
(
*
index
!
=
vector
.
length
(
)
-
1
)
{
vector
[
*
index
]
=
std
:
:
move
(
vector
.
back
(
)
)
;
}
(
*
index
)
-
-
;
vector
.
popBack
(
)
;
}
IonCompileTaskVector
&
ionWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
ionWorklist_
;
}
IonCompileTaskVector
&
ionFinishedList
(
const
AutoLockHelperThreadState
&
)
{
return
ionFinishedList_
;
}
IonFreeTaskVector
&
ionFreeList
(
const
AutoLockHelperThreadState
&
)
{
return
ionFreeList_
;
}
wasm
:
:
CompileTaskPtrFifo
&
wasmWorklist
(
const
AutoLockHelperThreadState
&
wasm
:
:
CompileMode
m
)
{
switch
(
m
)
{
case
wasm
:
:
CompileMode
:
:
Once
:
case
wasm
:
:
CompileMode
:
:
Tier1
:
return
wasmWorklist_tier1_
;
case
wasm
:
:
CompileMode
:
:
Tier2
:
return
wasmWorklist_tier2_
;
default
:
MOZ_CRASH
(
)
;
}
}
wasm
:
:
Tier2GeneratorTaskPtrVector
&
wasmTier2GeneratorWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
wasmTier2GeneratorWorklist_
;
}
void
incWasmTier2GeneratorsFinished
(
const
AutoLockHelperThreadState
&
)
{
wasmTier2GeneratorsFinished_
+
+
;
}
uint32_t
wasmTier2GeneratorsFinished
(
const
AutoLockHelperThreadState
&
)
const
{
return
wasmTier2GeneratorsFinished_
;
}
PromiseHelperTaskVector
&
promiseHelperTasks
(
const
AutoLockHelperThreadState
&
)
{
return
promiseHelperTasks_
;
}
ParseTaskVector
&
parseWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
parseWorklist_
;
}
ParseTaskList
&
parseFinishedList
(
const
AutoLockHelperThreadState
&
)
{
return
parseFinishedList_
;
}
ParseTaskVector
&
parseWaitingOnGC
(
const
AutoLockHelperThreadState
&
)
{
return
parseWaitingOnGC_
;
}
SourceCompressionTaskVector
&
compressionPendingList
(
const
AutoLockHelperThreadState
&
)
{
return
compressionPendingList_
;
}
SourceCompressionTaskVector
&
compressionWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
compressionWorklist_
;
}
SourceCompressionTaskVector
&
compressionFinishedList
(
const
AutoLockHelperThreadState
&
)
{
return
compressionFinishedList_
;
}
GCParallelTaskList
&
gcParallelWorklist
(
const
AutoLockHelperThreadState
&
)
{
return
gcParallelWorklist_
;
}
void
setGCParallelThreadCount
(
size_t
count
const
AutoLockHelperThreadState
&
)
{
MOZ_ASSERT
(
count
>
=
1
)
;
MOZ_ASSERT
(
count
<
=
threadCount
)
;
gcParallelThreadCount
=
count
;
}
bool
canStartWasmCompile
(
const
AutoLockHelperThreadState
&
lock
wasm
:
:
CompileMode
mode
)
;
bool
canStartWasmTier1Compile
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartWasmTier2Compile
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartWasmTier2Generator
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartPromiseHelperTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartIonCompile
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartIonFreeTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartParseTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartCompressionTask
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
canStartGCParallelTask
(
const
AutoLockHelperThreadState
&
lock
)
;
enum
class
ScheduleCompressionTask
{
GC
API
}
;
void
startHandlingCompressionTasks
(
const
AutoLockHelperThreadState
&
ScheduleCompressionTask
schedule
)
;
jit
:
:
IonCompileTask
*
highestPriorityPendingIonCompile
(
const
AutoLockHelperThreadState
&
lock
)
;
private
:
void
scheduleCompressionTasks
(
const
AutoLockHelperThreadState
&
ScheduleCompressionTask
schedule
)
;
UniquePtr
<
ParseTask
>
finishParseTaskCommon
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
;
JSScript
*
finishSingleParseTask
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
;
bool
generateLCovSources
(
JSContext
*
cx
ParseTask
*
parseTask
)
;
bool
finishMultiParseTask
(
JSContext
*
cx
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
MutableHandle
<
ScriptVector
>
scripts
)
;
void
mergeParseTaskRealm
(
JSContext
*
cx
ParseTask
*
parseTask
JS
:
:
Realm
*
dest
)
;
public
:
void
cancelParseTask
(
JSRuntime
*
rt
ParseTaskKind
kind
JS
:
:
OffThreadToken
*
token
)
;
void
destroyParseTask
(
JSRuntime
*
rt
ParseTask
*
parseTask
)
;
void
trace
(
JSTracer
*
trc
)
;
JSScript
*
finishScriptParseTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
;
JSScript
*
finishScriptDecodeTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
;
bool
finishMultiScriptsDecodeTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
MutableHandle
<
ScriptVector
>
scripts
)
;
JSObject
*
finishModuleParseTask
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
;
bool
hasActiveThreads
(
const
AutoLockHelperThreadState
&
)
;
void
waitForAllThreads
(
)
;
void
waitForAllThreadsLocked
(
AutoLockHelperThreadState
&
)
;
template
<
typename
T
>
bool
checkTaskThreadLimit
(
size_t
maxThreads
bool
isMaster
const
AutoLockHelperThreadState
&
lock
)
const
;
template
<
typename
T
>
bool
checkTaskThreadLimit
(
size_t
maxThreads
const
AutoLockHelperThreadState
&
lock
)
const
{
return
checkTaskThreadLimit
<
T
>
(
maxThreads
false
lock
)
;
}
void
triggerFreeUnusedMemory
(
)
;
private
:
js
:
:
Mutex
helperLock
;
js
:
:
ConditionVariable
consumerWakeup
;
js
:
:
ConditionVariable
producerWakeup
;
js
:
:
ConditionVariable
&
whichWakeup
(
CondVar
which
)
{
switch
(
which
)
{
case
CONSUMER
:
return
consumerWakeup
;
case
PRODUCER
:
return
producerWakeup
;
default
:
MOZ_CRASH
(
"
Invalid
CondVar
in
|
whichWakeup
|
"
)
;
}
}
}
;
static
inline
GlobalHelperThreadState
&
HelperThreadState
(
)
{
extern
GlobalHelperThreadState
*
gHelperThreadState
;
MOZ_ASSERT
(
gHelperThreadState
)
;
return
*
gHelperThreadState
;
}
typedef
mozilla
:
:
Variant
<
jit
:
:
IonCompileTask
*
wasm
:
:
CompileTask
*
wasm
:
:
Tier2GeneratorTask
*
PromiseHelperTask
*
ParseTask
*
SourceCompressionTask
*
GCParallelTask
*
>
HelperTaskUnion
;
class
HelperThread
{
Thread
thread
;
mozilla
:
:
Maybe
<
HelperTaskUnion
>
currentTask
;
ProfilingStack
*
profilingStack
=
nullptr
;
bool
terminate
=
false
;
public
:
HelperThread
(
)
;
MOZ_MUST_USE
bool
init
(
)
;
ThreadId
threadId
(
)
{
return
thread
.
get_id
(
)
;
}
bool
idle
(
)
const
{
return
currentTask
.
isNothing
(
)
;
}
template
<
typename
T
>
bool
hasTask
(
)
const
{
return
!
idle
(
)
&
&
currentTask
-
>
is
<
T
>
(
)
;
}
jit
:
:
IonCompileTask
*
ionCompileTask
(
)
{
return
maybeCurrentTaskAs
<
jit
:
:
IonCompileTask
*
>
(
)
;
}
wasm
:
:
CompileTask
*
wasmTask
(
)
{
return
maybeCurrentTaskAs
<
wasm
:
:
CompileTask
*
>
(
)
;
}
wasm
:
:
Tier2GeneratorTask
*
wasmTier2GeneratorTask
(
)
{
return
maybeCurrentTaskAs
<
wasm
:
:
Tier2GeneratorTask
*
>
(
)
;
}
ParseTask
*
parseTask
(
)
{
return
maybeCurrentTaskAs
<
ParseTask
*
>
(
)
;
}
SourceCompressionTask
*
compressionTask
(
)
{
return
maybeCurrentTaskAs
<
SourceCompressionTask
*
>
(
)
;
}
GCParallelTask
*
gcParallelTask
(
)
{
return
maybeCurrentTaskAs
<
GCParallelTask
*
>
(
)
;
}
void
setTerminate
(
const
AutoLockHelperThreadState
&
lock
)
;
void
join
(
)
;
static
void
ThreadMain
(
void
*
arg
)
;
void
threadLoop
(
)
;
void
ensureRegisteredWithProfiler
(
)
;
void
unregisterWithProfilerIfNeeded
(
)
;
private
:
struct
AutoProfilerLabel
{
AutoProfilerLabel
(
HelperThread
*
helperThread
const
char
*
label
JS
:
:
ProfilingCategoryPair
categoryPair
)
;
~
AutoProfilerLabel
(
)
;
private
:
ProfilingStack
*
profilingStack
;
}
;
struct
TaskSpec
{
using
Selector
=
bool
(
GlobalHelperThreadState
:
:
*
)
(
const
AutoLockHelperThreadState
&
)
;
using
Handler
=
void
(
HelperThread
:
:
*
)
(
AutoLockHelperThreadState
&
)
;
js
:
:
ThreadType
type
;
Selector
canStart
;
Handler
handleWorkload
;
}
;
static
const
TaskSpec
taskSpecs
[
]
;
const
TaskSpec
*
findHighestPriorityTask
(
const
AutoLockHelperThreadState
&
locked
)
;
template
<
typename
T
>
T
maybeCurrentTaskAs
(
)
{
if
(
currentTask
.
isSome
(
)
&
&
currentTask
-
>
is
<
T
>
(
)
)
{
return
currentTask
-
>
as
<
T
>
(
)
;
}
return
nullptr
;
}
void
handleWasmWorkload
(
AutoLockHelperThreadState
&
locked
wasm
:
:
CompileMode
mode
)
;
void
handleWasmTier1Workload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleWasmTier2Workload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleWasmTier2GeneratorWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handlePromiseHelperTaskWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleIonWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleIonFreeWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleParseWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleCompressionWorkload
(
AutoLockHelperThreadState
&
locked
)
;
void
handleGCParallelWorkload
(
AutoLockHelperThreadState
&
locked
)
;
}
;
bool
CreateHelperThreadsState
(
)
;
void
DestroyHelperThreadsState
(
)
;
bool
EnsureHelperThreadsInitialized
(
)
;
bool
SetFakeCPUCount
(
size_t
count
)
;
bool
StartOffThreadWasmCompile
(
wasm
:
:
CompileTask
*
task
wasm
:
:
CompileMode
mode
)
;
void
StartOffThreadWasmTier2Generator
(
wasm
:
:
UniqueTier2GeneratorTask
task
)
;
void
CancelOffThreadWasmTier2Generator
(
)
;
bool
StartOffThreadPromiseHelperTask
(
JSContext
*
cx
UniquePtr
<
PromiseHelperTask
>
task
)
;
bool
StartOffThreadPromiseHelperTask
(
PromiseHelperTask
*
task
)
;
bool
StartOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
bool
StartOffThreadIonFree
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
FinishOffThreadIonCompile
(
jit
:
:
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
struct
ZonesInState
{
JSRuntime
*
runtime
;
JS
:
:
shadow
:
:
Zone
:
:
GCState
state
;
}
;
struct
CompilationsUsingNursery
{
JSRuntime
*
runtime
;
}
;
using
CompilationSelector
=
mozilla
:
:
Variant
<
JSScript
*
JS
:
:
Realm
*
Zone
*
ZonesInState
JSRuntime
*
CompilationsUsingNursery
>
;
void
CancelOffThreadIonCompile
(
const
CompilationSelector
&
selector
)
;
inline
void
CancelOffThreadIonCompile
(
JSScript
*
script
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
script
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JS
:
:
Realm
*
realm
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
realm
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
Zone
*
zone
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
zone
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JSRuntime
*
runtime
JS
:
:
shadow
:
:
Zone
:
:
GCState
state
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
ZonesInState
{
runtime
state
}
)
)
;
}
inline
void
CancelOffThreadIonCompile
(
JSRuntime
*
runtime
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
runtime
)
)
;
}
inline
void
CancelOffThreadIonCompilesUsingNurseryPointers
(
JSRuntime
*
runtime
)
{
CancelOffThreadIonCompile
(
CompilationSelector
(
CompilationsUsingNursery
{
runtime
}
)
)
;
}
#
ifdef
DEBUG
bool
HasOffThreadIonCompile
(
JS
:
:
Realm
*
realm
)
;
#
endif
void
CancelOffThreadParses
(
JSRuntime
*
runtime
)
;
bool
StartOffThreadParseScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadParseScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadParseModule
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadParseModule
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadDecodeScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
bool
StartOffThreadDecodeMultiScripts
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
EnqueuePendingParseTasksAfterGC
(
JSRuntime
*
rt
)
;
struct
AutoEnqueuePendingParseTasksAfterGC
{
const
gc
:
:
GCRuntime
&
gc_
;
explicit
AutoEnqueuePendingParseTasksAfterGC
(
const
gc
:
:
GCRuntime
&
gc
)
:
gc_
(
gc
)
{
}
~
AutoEnqueuePendingParseTasksAfterGC
(
)
;
}
;
bool
EnqueueOffThreadCompression
(
JSContext
*
cx
UniquePtr
<
SourceCompressionTask
>
task
)
;
void
CancelOffThreadCompressions
(
JSRuntime
*
runtime
)
;
void
AttachFinishedCompressions
(
JSRuntime
*
runtime
AutoLockHelperThreadState
&
lock
)
;
void
RunPendingSourceCompressions
(
JSRuntime
*
runtime
)
;
class
MOZ_RAII
AutoLockHelperThreadState
:
public
LockGuard
<
Mutex
>
{
using
Base
=
LockGuard
<
Mutex
>
;
public
:
explicit
AutoLockHelperThreadState
(
)
:
Base
(
HelperThreadState
(
)
.
helperLock
)
{
}
}
;
class
MOZ_RAII
AutoUnlockHelperThreadState
:
public
UnlockGuard
<
Mutex
>
{
using
Base
=
UnlockGuard
<
Mutex
>
;
public
:
explicit
AutoUnlockHelperThreadState
(
AutoLockHelperThreadState
&
locked
)
:
Base
(
locked
)
{
}
}
;
struct
MOZ_RAII
AutoSetHelperThreadContext
{
JSContext
*
cx
;
explicit
AutoSetHelperThreadContext
(
)
;
~
AutoSetHelperThreadContext
(
)
{
AutoLockHelperThreadState
lock
;
cx
-
>
tempLifoAlloc
(
)
.
releaseAll
(
)
;
if
(
cx
-
>
shouldFreeUnusedMemory
(
)
)
{
cx
-
>
tempLifoAlloc
(
)
.
freeAll
(
)
;
cx
-
>
setFreeUnusedMemory
(
false
)
;
}
cx
-
>
clearHelperThread
(
lock
)
;
cx
=
nullptr
;
}
}
;
struct
MOZ_RAII
AutoSetContextRuntime
{
explicit
AutoSetContextRuntime
(
JSRuntime
*
rt
)
{
TlsContext
.
get
(
)
-
>
setRuntime
(
rt
)
;
}
~
AutoSetContextRuntime
(
)
{
TlsContext
.
get
(
)
-
>
setRuntime
(
nullptr
)
;
}
}
;
struct
ParseTask
:
public
mozilla
:
:
LinkedListElement
<
ParseTask
>
public
JS
:
:
OffThreadToken
public
HelperThreadTask
{
ParseTaskKind
kind
;
JS
:
:
OwningCompileOptions
options
;
JSRuntime
*
runtime
=
nullptr
;
JSObject
*
parseGlobal
;
JS
:
:
OffThreadCompileCallback
callback
;
void
*
callbackData
;
GCVector
<
JSScript
*
1
SystemAllocPolicy
>
scripts
;
GCVector
<
ScriptSourceObject
*
1
SystemAllocPolicy
>
sourceObjects
;
UniquePtr
<
frontend
:
:
CompilationInfo
>
compilationInfo_
;
Vector
<
UniquePtr
<
CompileError
>
0
SystemAllocPolicy
>
errors
;
bool
overRecursed
;
bool
outOfMemory
;
ParseTask
(
ParseTaskKind
kind
JSContext
*
cx
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
virtual
~
ParseTask
(
)
;
bool
init
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JSObject
*
global
)
;
void
activate
(
JSRuntime
*
rt
)
;
virtual
void
parse
(
JSContext
*
cx
)
=
0
;
bool
instantiateStencils
(
JSContext
*
cx
)
;
bool
runtimeMatches
(
JSRuntime
*
rt
)
{
return
runtime
=
=
rt
;
}
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
runTaskLocked
(
AutoLockHelperThreadState
&
locked
)
override
;
void
runTask
(
)
;
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_PARSE
;
}
}
;
struct
ScriptDecodeTask
:
public
ParseTask
{
const
JS
:
:
TranscodeRange
range
;
ScriptDecodeTask
(
JSContext
*
cx
const
JS
:
:
TranscodeRange
&
range
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
struct
MultiScriptsDecodeTask
:
public
ParseTask
{
JS
:
:
TranscodeSources
*
sources
;
MultiScriptsDecodeTask
(
JSContext
*
cx
JS
:
:
TranscodeSources
&
sources
JS
:
:
OffThreadCompileCallback
callback
void
*
callbackData
)
;
void
parse
(
JSContext
*
cx
)
override
;
}
;
extern
bool
OffThreadParsingMustWaitForGC
(
JSRuntime
*
rt
)
;
class
SourceCompressionTask
:
public
RunnableTask
{
friend
class
HelperThread
;
friend
class
ScriptSource
;
JSRuntime
*
runtime_
;
uint64_t
majorGCNumber_
;
ScriptSourceHolder
sourceHolder_
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
resultString_
;
public
:
SourceCompressionTask
(
JSRuntime
*
rt
ScriptSource
*
source
)
:
runtime_
(
rt
)
majorGCNumber_
(
rt
-
>
gc
.
majorGCCount
(
)
)
sourceHolder_
(
source
)
{
}
virtual
~
SourceCompressionTask
(
)
=
default
;
bool
runtimeMatches
(
JSRuntime
*
runtime
)
const
{
return
runtime
=
=
runtime_
;
}
bool
shouldStart
(
)
const
{
return
runtime_
-
>
gc
.
majorGCCount
(
)
>
majorGCNumber_
+
1
;
}
bool
shouldCancel
(
)
const
{
return
sourceHolder_
.
get
(
)
-
>
refs
=
=
1
;
}
void
runTask
(
)
override
;
void
runTaskLocked
(
AutoLockHelperThreadState
&
locked
)
;
void
complete
(
)
;
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_COMPRESS
;
}
private
:
struct
PerformTaskWork
;
friend
struct
PerformTaskWork
;
template
<
typename
CharT
>
void
workEncodingSpecific
(
)
;
}
;
struct
PromiseHelperTask
:
OffThreadPromiseTask
public
HelperThreadTask
{
PromiseHelperTask
(
JSContext
*
cx
Handle
<
PromiseObject
*
>
promise
)
:
OffThreadPromiseTask
(
cx
promise
)
{
}
virtual
void
execute
(
)
=
0
;
void
executeAndResolveAndDestroy
(
JSContext
*
cx
)
;
void
runTaskLocked
(
AutoLockHelperThreadState
&
lock
)
override
;
ThreadType
threadType
(
)
override
{
return
THREAD_TYPE_PROMISE_TASK
;
}
}
;
}
#
endif
