#
include
"
vm
/
AsyncFunction
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
bool
GlobalObject
:
:
initAsyncFunction
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
if
(
global
-
>
getReservedSlot
(
ASYNC_FUNCTION_PROTO
)
.
isObject
(
)
)
return
true
;
RootedObject
asyncFunctionProto
(
cx
NewSingletonObjectWithFunctionPrototype
(
cx
global
)
)
;
if
(
!
asyncFunctionProto
)
return
false
;
if
(
!
DefineToStringTag
(
cx
asyncFunctionProto
cx
-
>
names
(
)
.
AsyncFunction
)
)
return
false
;
RootedValue
function
(
cx
global
-
>
getConstructor
(
JSProto_Function
)
)
;
if
(
!
function
.
toObjectOrNull
(
)
)
return
false
;
RootedObject
proto
(
cx
&
function
.
toObject
(
)
)
;
RootedAtom
name
(
cx
cx
-
>
names
(
)
.
AsyncFunction
)
;
RootedObject
asyncFunction
(
cx
NewFunctionWithProto
(
cx
AsyncFunctionConstructor
1
JSFunction
:
:
NATIVE_CTOR
nullptr
name
proto
)
)
;
if
(
!
asyncFunction
)
return
false
;
if
(
!
LinkConstructorAndPrototype
(
cx
asyncFunction
asyncFunctionProto
)
)
return
false
;
global
-
>
setReservedSlot
(
ASYNC_FUNCTION
ObjectValue
(
*
asyncFunction
)
)
;
global
-
>
setReservedSlot
(
ASYNC_FUNCTION_PROTO
ObjectValue
(
*
asyncFunctionProto
)
)
;
return
true
;
}
static
bool
AsyncFunctionStart
(
JSContext
*
cx
HandleValue
generatorVal
MutableHandleValue
rval
)
;
#
define
UNWRAPPED_ASYNC_WRAPPED_SLOT
1
#
define
WRAPPED_ASYNC_UNWRAPPED_SLOT
0
static
bool
WrappedAsyncFunction
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
wrapped
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
unwrappedVal
(
cx
wrapped
-
>
getExtendedSlot
(
WRAPPED_ASYNC_UNWRAPPED_SLOT
)
)
;
RootedFunction
unwrapped
(
cx
&
unwrappedVal
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
RootedValue
thisValue
(
cx
args
.
thisv
(
)
)
;
RootedValue
generatorVal
(
cx
)
;
InvokeArgs
args2
(
cx
)
;
if
(
!
args2
.
init
(
cx
argc
)
)
return
false
;
for
(
size_t
i
=
0
len
=
argc
;
i
<
len
;
i
+
+
)
args2
[
i
]
.
set
(
args
[
i
]
)
;
if
(
Call
(
cx
unwrappedVal
thisValue
args2
&
generatorVal
)
)
{
return
AsyncFunctionStart
(
cx
generatorVal
args
.
rval
(
)
)
;
}
RootedValue
exc
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exc
)
)
return
false
;
RootedObject
rejectPromise
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
exc
)
)
;
if
(
!
rejectPromise
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
rejectPromise
)
;
return
true
;
}
JSObject
*
js
:
:
WrapAsyncFunction
(
JSContext
*
cx
HandleFunction
unwrapped
)
{
MOZ_ASSERT
(
unwrapped
-
>
isStarGenerator
(
)
)
;
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateAsyncFunctionPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
return
nullptr
;
RootedAtom
funName
(
cx
unwrapped
-
>
name
(
)
)
;
uint16_t
length
;
if
(
!
unwrapped
-
>
getLength
(
cx
&
length
)
)
return
nullptr
;
RootedFunction
wrapped
(
cx
NewFunctionWithProto
(
cx
WrappedAsyncFunction
length
JSFunction
:
:
NATIVE_FUN
nullptr
funName
proto
AllocKind
:
:
FUNCTION_EXTENDED
TenuredObject
)
)
;
if
(
!
wrapped
)
return
nullptr
;
unwrapped
-
>
setExtendedSlot
(
UNWRAPPED_ASYNC_WRAPPED_SLOT
ObjectValue
(
*
wrapped
)
)
;
wrapped
-
>
setExtendedSlot
(
WRAPPED_ASYNC_UNWRAPPED_SLOT
ObjectValue
(
*
unwrapped
)
)
;
return
wrapped
;
}
static
bool
AsyncFunctionThrown
(
JSContext
*
cx
MutableHandleValue
rval
)
{
RootedValue
exc
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exc
)
)
return
false
;
RootedObject
rejectPromise
(
cx
PromiseObject
:
:
unforgeableReject
(
cx
exc
)
)
;
if
(
!
rejectPromise
)
return
false
;
rval
.
setObject
(
*
rejectPromise
)
;
return
true
;
}
static
bool
AsyncFunctionReturned
(
JSContext
*
cx
HandleValue
value
MutableHandleValue
rval
)
{
RootedObject
resolveObj
(
cx
PromiseObject
:
:
unforgeableResolve
(
cx
value
)
)
;
if
(
!
resolveObj
)
return
false
;
rval
.
setObject
(
*
resolveObj
)
;
return
true
;
}
enum
class
ResumeKind
{
Normal
Throw
}
;
static
bool
AsyncFunctionResume
(
JSContext
*
cx
HandleValue
generatorVal
ResumeKind
kind
HandleValue
valueOrReason
MutableHandleValue
rval
)
{
HandlePropertyName
funName
=
kind
=
=
ResumeKind
:
:
Normal
?
cx
-
>
names
(
)
.
StarGeneratorNext
:
cx
-
>
names
(
)
.
StarGeneratorThrow
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
valueOrReason
)
;
RootedValue
result
(
cx
)
;
if
(
!
CallSelfHostedFunction
(
cx
funName
generatorVal
args
&
result
)
)
return
AsyncFunctionThrown
(
cx
rval
)
;
RootedObject
resultObj
(
cx
&
result
.
toObject
(
)
)
;
RootedValue
doneVal
(
cx
)
;
RootedValue
value
(
cx
)
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
done
&
doneVal
)
)
return
false
;
if
(
!
GetProperty
(
cx
resultObj
resultObj
cx
-
>
names
(
)
.
value
&
value
)
)
return
false
;
if
(
doneVal
.
toBoolean
(
)
)
return
AsyncFunctionReturned
(
cx
value
rval
)
;
return
AsyncFunctionAwait
(
cx
generatorVal
value
rval
)
;
}
static
bool
AsyncFunctionStart
(
JSContext
*
cx
HandleValue
generatorVal
MutableHandleValue
rval
)
{
return
AsyncFunctionResume
(
cx
generatorVal
ResumeKind
:
:
Normal
UndefinedHandleValue
rval
)
;
}
bool
js
:
:
AsyncFunctionAwaitedFulfilled
(
JSContext
*
cx
HandleValue
value
HandleValue
generatorVal
MutableHandleValue
rval
)
{
return
AsyncFunctionResume
(
cx
generatorVal
ResumeKind
:
:
Normal
value
rval
)
;
}
bool
js
:
:
AsyncFunctionAwaitedRejected
(
JSContext
*
cx
HandleValue
reason
HandleValue
generatorVal
MutableHandleValue
rval
)
{
return
AsyncFunctionResume
(
cx
generatorVal
ResumeKind
:
:
Throw
reason
rval
)
;
}
JSFunction
*
js
:
:
GetWrappedAsyncFunction
(
JSFunction
*
unwrapped
)
{
MOZ_ASSERT
(
unwrapped
-
>
isAsync
(
)
)
;
return
&
unwrapped
-
>
getExtendedSlot
(
UNWRAPPED_ASYNC_WRAPPED_SLOT
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
JSFunction
*
js
:
:
GetUnwrappedAsyncFunction
(
JSFunction
*
wrapped
)
{
MOZ_ASSERT
(
IsWrappedAsyncFunction
(
wrapped
)
)
;
JSFunction
*
unwrapped
=
&
wrapped
-
>
getExtendedSlot
(
WRAPPED_ASYNC_UNWRAPPED_SLOT
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
unwrapped
-
>
isAsync
(
)
)
;
return
unwrapped
;
}
bool
js
:
:
IsWrappedAsyncFunction
(
JSFunction
*
fun
)
{
return
fun
-
>
maybeNative
(
)
=
=
WrappedAsyncFunction
;
}
