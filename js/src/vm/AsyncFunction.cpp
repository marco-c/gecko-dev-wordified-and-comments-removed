#
include
"
vm
/
AsyncFunction
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Modules
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
static
JSObject
*
CreateAsyncFunction
(
JSContext
*
cx
JSProtoKey
key
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateFunctionConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Handle
<
PropertyName
*
>
name
=
cx
-
>
names
(
)
.
AsyncFunction
;
return
NewFunctionWithProto
(
cx
AsyncFunctionConstructor
1
FunctionFlags
:
:
NATIVE_CTOR
nullptr
name
proto
gc
:
:
AllocKind
:
:
FUNCTION
TenuredObject
)
;
}
static
JSObject
*
CreateAsyncFunctionPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
NewTenuredObjectWithFunctionPrototype
(
cx
cx
-
>
global
(
)
)
;
}
static
bool
AsyncFunctionClassFinish
(
JSContext
*
cx
HandleObject
asyncFunction
HandleObject
asyncFunctionProto
)
{
MOZ_ASSERT
(
asyncFunctionProto
-
>
as
<
NativeObject
>
(
)
.
getLastProperty
(
)
.
key
(
)
=
=
NameToId
(
cx
-
>
names
(
)
.
constructor
)
)
;
MOZ_ASSERT
(
!
asyncFunctionProto
-
>
as
<
NativeObject
>
(
)
.
inDictionaryMode
(
)
)
;
RootedValue
asyncFunctionVal
(
cx
ObjectValue
(
*
asyncFunction
)
)
;
if
(
!
DefineDataProperty
(
cx
asyncFunctionProto
cx
-
>
names
(
)
.
constructor
asyncFunctionVal
JSPROP_READONLY
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
asyncFunctionProto
-
>
as
<
NativeObject
>
(
)
.
inDictionaryMode
(
)
)
;
return
DefineToStringTag
(
cx
asyncFunctionProto
cx
-
>
names
(
)
.
AsyncFunction
)
;
}
static
const
ClassSpec
AsyncFunctionClassSpec
=
{
CreateAsyncFunction
CreateAsyncFunctionPrototype
nullptr
nullptr
nullptr
nullptr
AsyncFunctionClassFinish
ClassSpec
:
:
DontDefineConstructor
}
;
const
JSClass
js
:
:
AsyncFunctionClass
=
{
"
AsyncFunction
"
0
JS_NULL_CLASS_OPS
&
AsyncFunctionClassSpec
}
;
enum
class
ResumeKind
{
Normal
Throw
}
;
static
bool
AsyncFunctionResume
(
JSContext
*
cx
Handle
<
AsyncFunctionGeneratorObject
*
>
generator
ResumeKind
kind
HandleValue
valueOrReason
)
{
if
(
generator
-
>
isClosed
(
)
)
{
return
true
;
}
if
(
generator
-
>
isRunning
(
)
)
{
return
true
;
}
Rooted
<
PromiseObject
*
>
resultPromise
(
cx
generator
-
>
promise
(
)
)
;
RootedObject
stack
(
cx
)
;
Maybe
<
JS
:
:
AutoSetAsyncStackForNewCalls
>
asyncStack
;
if
(
JSObject
*
allocationSite
=
resultPromise
-
>
allocationSite
(
)
)
{
stack
=
allocationSite
-
>
as
<
SavedFrame
>
(
)
.
getParent
(
)
;
if
(
stack
)
{
asyncStack
.
emplace
(
cx
stack
"
async
"
JS
:
:
AutoSetAsyncStackForNewCalls
:
:
AsyncCallKind
:
:
EXPLICIT
)
;
}
}
MOZ_ASSERT
(
generator
-
>
isSuspended
(
)
"
non
-
suspended
generator
when
resuming
async
function
"
)
;
Handle
<
PropertyName
*
>
funName
=
kind
=
=
ResumeKind
:
:
Normal
?
cx
-
>
names
(
)
.
AsyncFunctionNext
:
cx
-
>
names
(
)
.
AsyncFunctionThrow
;
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
valueOrReason
)
;
RootedValue
generatorOrValue
(
cx
ObjectValue
(
*
generator
)
)
;
if
(
!
CallSelfHostedFunction
(
cx
funName
generatorOrValue
args
&
generatorOrValue
)
)
{
if
(
!
generator
-
>
isClosed
(
)
)
{
generator
-
>
setClosed
(
)
;
}
if
(
resultPromise
-
>
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
&
&
cx
-
>
isExceptionPending
(
)
)
{
RootedValue
exn
(
cx
)
;
if
(
!
GetAndClearException
(
cx
&
exn
)
)
{
return
false
;
}
return
AsyncFunctionThrown
(
cx
resultPromise
exn
)
;
}
return
false
;
}
MOZ_ASSERT_IF
(
generator
-
>
isClosed
(
)
generatorOrValue
.
isObject
(
)
)
;
MOZ_ASSERT_IF
(
generator
-
>
isClosed
(
)
&
generatorOrValue
.
toObject
(
)
=
=
resultPromise
)
;
MOZ_ASSERT_IF
(
!
generator
-
>
isClosed
(
)
generator
-
>
isAfterAwait
(
)
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
js
:
:
AsyncFunctionAwaitedFulfilled
(
JSContext
*
cx
Handle
<
AsyncFunctionGeneratorObject
*
>
generator
HandleValue
value
)
{
return
AsyncFunctionResume
(
cx
generator
ResumeKind
:
:
Normal
value
)
;
}
[
[
nodiscard
]
]
bool
js
:
:
AsyncFunctionAwaitedRejected
(
JSContext
*
cx
Handle
<
AsyncFunctionGeneratorObject
*
>
generator
HandleValue
reason
)
{
return
AsyncFunctionResume
(
cx
generator
ResumeKind
:
:
Throw
reason
)
;
}
JSObject
*
js
:
:
AsyncFunctionResolve
(
JSContext
*
cx
Handle
<
AsyncFunctionGeneratorObject
*
>
generator
HandleValue
valueOrReason
AsyncFunctionResolveKind
resolveKind
)
{
Rooted
<
PromiseObject
*
>
promise
(
cx
generator
-
>
promise
(
)
)
;
if
(
resolveKind
=
=
AsyncFunctionResolveKind
:
:
Fulfill
)
{
if
(
!
AsyncFunctionReturned
(
cx
promise
valueOrReason
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
AsyncFunctionThrown
(
cx
promise
valueOrReason
)
)
{
return
nullptr
;
}
}
return
promise
;
}
const
JSClass
AsyncFunctionGeneratorObject
:
:
class_
=
{
"
AsyncFunctionGenerator
"
JSCLASS_HAS_RESERVED_SLOTS
(
AsyncFunctionGeneratorObject
:
:
RESERVED_SLOTS
)
&
classOps_
}
;
const
JSClassOps
AsyncFunctionGeneratorObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
CallTraceMethod
<
AbstractGeneratorObject
>
}
;
AsyncFunctionGeneratorObject
*
AsyncFunctionGeneratorObject
:
:
create
(
JSContext
*
cx
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isAsync
(
)
&
&
!
fun
-
>
isGenerator
(
)
)
;
Rooted
<
PromiseObject
*
>
resultPromise
(
cx
CreatePromiseObjectForAsync
(
cx
)
)
;
if
(
!
resultPromise
)
{
return
nullptr
;
}
auto
*
obj
=
NewBuiltinClassInstance
<
AsyncFunctionGeneratorObject
>
(
cx
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
initFixedSlot
(
PROMISE_SLOT
ObjectValue
(
*
resultPromise
)
)
;
obj
-
>
setResumeIndex
(
AbstractGeneratorObject
:
:
RESUME_INDEX_RUNNING
)
;
return
obj
;
}
JSFunction
*
NewHandler
(
JSContext
*
cx
Native
handler
JS
:
:
Handle
<
JSObject
*
>
target
)
{
cx
-
>
check
(
target
)
;
JS
:
:
Handle
<
PropertyName
*
>
funName
=
cx
-
>
names
(
)
.
empty
;
JS
:
:
Rooted
<
JSFunction
*
>
handlerFun
(
cx
NewNativeFunction
(
cx
handler
0
funName
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
GenericObject
)
)
;
if
(
!
handlerFun
)
{
return
nullptr
;
}
handlerFun
-
>
setExtendedSlot
(
FunctionExtended
:
:
MODULE_SLOT
JS
:
:
ObjectValue
(
*
target
)
)
;
return
handlerFun
;
}
static
bool
AsyncModuleExecutionFulfilledHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
&
func
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
Rooted
<
ModuleObject
*
>
module
(
cx
&
func
.
getExtendedSlot
(
FunctionExtended
:
:
MODULE_SLOT
)
.
toObject
(
)
.
as
<
ModuleObject
>
(
)
)
;
AsyncModuleExecutionFulfilled
(
cx
module
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
AsyncModuleExecutionRejectedHandler
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
&
func
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
Rooted
<
ModuleObject
*
>
module
(
cx
&
func
.
getExtendedSlot
(
FunctionExtended
:
:
MODULE_SLOT
)
.
toObject
(
)
.
as
<
ModuleObject
>
(
)
)
;
AsyncModuleExecutionRejected
(
cx
module
args
.
get
(
0
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
AsyncFunctionGeneratorObject
*
AsyncFunctionGeneratorObject
:
:
create
(
JSContext
*
cx
Handle
<
ModuleObject
*
>
module
)
{
MOZ_ASSERT
(
module
-
>
script
(
)
-
>
isAsync
(
)
)
;
Rooted
<
PromiseObject
*
>
resultPromise
(
cx
CreatePromiseObjectForAsync
(
cx
)
)
;
if
(
!
resultPromise
)
{
return
nullptr
;
}
Rooted
<
AsyncFunctionGeneratorObject
*
>
obj
(
cx
NewBuiltinClassInstance
<
AsyncFunctionGeneratorObject
>
(
cx
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
initFixedSlot
(
PROMISE_SLOT
ObjectValue
(
*
resultPromise
)
)
;
RootedObject
onFulfilled
(
cx
NewHandler
(
cx
AsyncModuleExecutionFulfilledHandler
module
)
)
;
if
(
!
onFulfilled
)
{
return
nullptr
;
}
RootedObject
onRejected
(
cx
NewHandler
(
cx
AsyncModuleExecutionRejectedHandler
module
)
)
;
if
(
!
onRejected
)
{
return
nullptr
;
}
if
(
!
JS
:
:
AddPromiseReactionsIgnoringUnhandledRejection
(
cx
resultPromise
onFulfilled
onRejected
)
)
{
return
nullptr
;
}
obj
-
>
setResumeIndex
(
AbstractGeneratorObject
:
:
RESUME_INDEX_RUNNING
)
;
return
obj
;
}
