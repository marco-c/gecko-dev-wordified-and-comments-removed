#
include
"
vm
/
PIC
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
gc
/
GCContext
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
template
<
typename
Category
>
void
PICChain
<
Category
>
:
:
addStub
(
JSObject
*
obj
CatStub
*
stub
)
{
MOZ_ASSERT
(
stub
)
;
MOZ_ASSERT
(
!
stub
-
>
next
(
)
)
;
AddCellMemory
(
obj
sizeof
(
CatStub
)
MemoryUse
:
:
ForOfPICStub
)
;
if
(
!
stubs_
)
{
stubs_
=
stub
;
return
;
}
CatStub
*
cur
=
stubs_
;
while
(
cur
-
>
next
(
)
)
{
cur
=
cur
-
>
next
(
)
;
}
cur
-
>
append
(
stub
)
;
}
bool
js
:
:
ForOfPIC
:
:
Chain
:
:
initialize
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
initialized_
)
;
Rooted
<
NativeObject
*
>
arrayProto
(
cx
GlobalObject
:
:
getOrCreateArrayPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
arrayProto
)
{
return
false
;
}
Rooted
<
NativeObject
*
>
arrayIteratorProto
(
cx
GlobalObject
:
:
getOrCreateArrayIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
arrayIteratorProto
)
{
return
false
;
}
initialized_
=
true
;
arrayProto_
=
arrayProto
;
arrayIteratorProto_
=
arrayIteratorProto
;
disabled_
=
true
;
mozilla
:
:
Maybe
<
PropertyInfo
>
iterProp
=
arrayProto
-
>
lookup
(
cx
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
)
;
if
(
iterProp
.
isNothing
(
)
|
|
!
iterProp
-
>
isDataProperty
(
)
)
{
return
true
;
}
Value
iterator
=
arrayProto
-
>
getSlot
(
iterProp
-
>
slot
(
)
)
;
JSFunction
*
iterFun
;
if
(
!
IsFunctionObject
(
iterator
&
iterFun
)
)
{
return
true
;
}
if
(
!
IsSelfHostedFunctionWithName
(
iterFun
cx
-
>
names
(
)
.
ArrayValues
)
)
{
return
true
;
}
mozilla
:
:
Maybe
<
PropertyInfo
>
nextProp
=
arrayIteratorProto
-
>
lookup
(
cx
cx
-
>
names
(
)
.
next
)
;
if
(
nextProp
.
isNothing
(
)
|
|
!
nextProp
-
>
isDataProperty
(
)
)
{
return
true
;
}
Value
next
=
arrayIteratorProto
-
>
getSlot
(
nextProp
-
>
slot
(
)
)
;
JSFunction
*
nextFun
;
if
(
!
IsFunctionObject
(
next
&
nextFun
)
)
{
return
true
;
}
if
(
!
IsSelfHostedFunctionWithName
(
nextFun
cx
-
>
names
(
)
.
ArrayIteratorNext
)
)
{
return
true
;
}
disabled_
=
false
;
arrayProtoShape_
=
arrayProto
-
>
shape
(
)
;
arrayProtoIteratorSlot_
=
iterProp
-
>
slot
(
)
;
canonicalIteratorFunc_
=
iterator
;
arrayIteratorProtoShape_
=
arrayIteratorProto
-
>
shape
(
)
;
arrayIteratorProtoNextSlot_
=
nextProp
-
>
slot
(
)
;
canonicalNextFunc_
=
next
;
return
true
;
}
bool
js
:
:
ForOfPIC
:
:
Chain
:
:
tryOptimizeArray
(
JSContext
*
cx
Handle
<
ArrayObject
*
>
array
bool
*
optimized
)
{
MOZ_ASSERT
(
optimized
)
;
*
optimized
=
false
;
if
(
!
initialized_
)
{
if
(
!
initialize
(
cx
)
)
{
return
false
;
}
}
else
if
(
!
disabled_
&
&
!
isArrayStateStillSane
(
)
)
{
reset
(
cx
)
;
if
(
!
initialize
(
cx
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
initialized_
)
;
if
(
disabled_
)
{
return
true
;
}
MOZ_ASSERT
(
isArrayStateStillSane
(
)
)
;
if
(
array
-
>
staticPrototype
(
)
!
=
arrayProto_
)
{
return
true
;
}
if
(
hasMatchingStub
(
array
)
)
{
*
optimized
=
true
;
return
true
;
}
if
(
array
-
>
lookup
(
cx
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
)
)
{
return
true
;
}
if
(
numStubs
(
)
>
=
MAX_STUBS
)
{
eraseChain
(
cx
)
;
}
Rooted
<
Shape
*
>
shape
(
cx
array
-
>
shape
(
)
)
;
Stub
*
stub
=
cx
-
>
new_
<
Stub
>
(
shape
)
;
if
(
!
stub
)
{
return
false
;
}
addStub
(
picObject_
stub
)
;
*
optimized
=
true
;
return
true
;
}
bool
js
:
:
ForOfPIC
:
:
Chain
:
:
tryOptimizeArrayIteratorNext
(
JSContext
*
cx
bool
*
optimized
)
{
MOZ_ASSERT
(
optimized
)
;
*
optimized
=
false
;
if
(
!
initialized_
)
{
if
(
!
initialize
(
cx
)
)
{
return
false
;
}
}
else
if
(
!
disabled_
&
&
!
isArrayNextStillSane
(
)
)
{
reset
(
cx
)
;
if
(
!
initialize
(
cx
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
initialized_
)
;
if
(
disabled_
)
{
return
true
;
}
MOZ_ASSERT
(
isArrayNextStillSane
(
)
)
;
*
optimized
=
true
;
return
true
;
}
bool
js
:
:
ForOfPIC
:
:
Chain
:
:
hasMatchingStub
(
ArrayObject
*
obj
)
{
MOZ_ASSERT
(
initialized_
&
&
!
disabled_
)
;
for
(
Stub
*
stub
=
stubs
(
)
;
stub
!
=
nullptr
;
stub
=
stub
-
>
next
(
)
)
{
if
(
stub
-
>
shape
(
)
=
=
obj
-
>
shape
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
js
:
:
ForOfPIC
:
:
Chain
:
:
isArrayStateStillSane
(
)
{
if
(
arrayProto_
-
>
shape
(
)
!
=
arrayProtoShape_
)
{
return
false
;
}
if
(
arrayProto_
-
>
getSlot
(
arrayProtoIteratorSlot_
)
!
=
canonicalIteratorFunc_
)
{
return
false
;
}
return
isArrayNextStillSane
(
)
;
}
void
js
:
:
ForOfPIC
:
:
Chain
:
:
reset
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
disabled_
)
;
eraseChain
(
cx
)
;
arrayProto_
=
nullptr
;
arrayIteratorProto_
=
nullptr
;
arrayProtoShape_
=
nullptr
;
arrayProtoIteratorSlot_
=
-
1
;
canonicalIteratorFunc_
=
UndefinedValue
(
)
;
arrayIteratorProtoShape_
=
nullptr
;
arrayIteratorProtoNextSlot_
=
-
1
;
canonicalNextFunc_
=
UndefinedValue
(
)
;
initialized_
=
false
;
}
void
js
:
:
ForOfPIC
:
:
Chain
:
:
eraseChain
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
disabled_
)
;
freeAllStubs
(
cx
-
>
gcContext
(
)
)
;
}
void
js
:
:
ForOfPIC
:
:
Chain
:
:
trace
(
JSTracer
*
trc
)
{
TraceEdge
(
trc
&
picObject_
"
ForOfPIC
object
"
)
;
if
(
!
initialized_
|
|
disabled_
)
{
return
;
}
TraceEdge
(
trc
&
arrayProto_
"
ForOfPIC
Array
.
prototype
.
"
)
;
TraceEdge
(
trc
&
arrayIteratorProto_
"
ForOfPIC
ArrayIterator
.
prototype
.
"
)
;
TraceEdge
(
trc
&
arrayProtoShape_
"
ForOfPIC
Array
.
prototype
shape
.
"
)
;
TraceEdge
(
trc
&
arrayIteratorProtoShape_
"
ForOfPIC
ArrayIterator
.
prototype
shape
.
"
)
;
TraceEdge
(
trc
&
canonicalIteratorFunc_
"
ForOfPIC
ArrayValues
builtin
.
"
)
;
TraceEdge
(
trc
&
canonicalNextFunc_
"
ForOfPIC
ArrayIterator
.
prototype
.
next
builtin
.
"
)
;
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
if
(
trc
-
>
isMarkingTracer
(
)
)
{
freeAllStubs
(
gcx
)
;
}
}
static
void
ForOfPIC_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
if
(
ForOfPIC
:
:
Chain
*
chain
=
ForOfPIC
:
:
fromJSObject
(
&
obj
-
>
as
<
NativeObject
>
(
)
)
)
{
chain
-
>
finalize
(
gcx
obj
)
;
}
}
void
js
:
:
ForOfPIC
:
:
Chain
:
:
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
freeAllStubs
(
gcx
)
;
gcx
-
>
delete_
(
obj
this
MemoryUse
:
:
ForOfPIC
)
;
}
void
js
:
:
ForOfPIC
:
:
Chain
:
:
freeAllStubs
(
JS
:
:
GCContext
*
gcx
)
{
Stub
*
stub
=
stubs_
;
while
(
stub
)
{
Stub
*
next
=
stub
-
>
next
(
)
;
gcx
-
>
delete_
(
picObject_
stub
MemoryUse
:
:
ForOfPICStub
)
;
stub
=
next
;
}
stubs_
=
nullptr
;
}
static
void
ForOfPIC_traceObject
(
JSTracer
*
trc
JSObject
*
obj
)
{
if
(
ForOfPIC
:
:
Chain
*
chain
=
ForOfPIC
:
:
fromJSObject
(
&
obj
-
>
as
<
NativeObject
>
(
)
)
)
{
chain
-
>
trace
(
trc
)
;
}
}
static
const
JSClassOps
ForOfPICClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ForOfPIC_finalize
nullptr
nullptr
ForOfPIC_traceObject
}
;
const
JSClass
ForOfPICObject
:
:
class_
=
{
"
ForOfPIC
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_BACKGROUND_FINALIZE
&
ForOfPICClassOps
}
;
NativeObject
*
js
:
:
ForOfPIC
:
:
createForOfPICObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
cx
-
>
check
(
global
)
;
ForOfPICObject
*
obj
=
NewTenuredObjectWithGivenProto
<
ForOfPICObject
>
(
cx
nullptr
)
;
if
(
!
obj
)
{
return
nullptr
;
}
ForOfPIC
:
:
Chain
*
chain
=
cx
-
>
new_
<
ForOfPIC
:
:
Chain
>
(
obj
)
;
if
(
!
chain
)
{
return
nullptr
;
}
InitReservedSlot
(
obj
ForOfPICObject
:
:
ChainSlot
chain
MemoryUse
:
:
ForOfPIC
)
;
return
obj
;
}
js
:
:
ForOfPIC
:
:
Chain
*
js
:
:
ForOfPIC
:
:
create
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
cx
-
>
global
(
)
-
>
getForOfPICObject
(
)
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
cx
-
>
global
(
)
)
;
NativeObject
*
obj
=
GlobalObject
:
:
getOrCreateForOfPICObject
(
cx
global
)
;
if
(
!
obj
)
{
return
nullptr
;
}
return
fromJSObject
(
obj
)
;
}
