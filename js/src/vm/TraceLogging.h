#
ifndef
TraceLogging_h
#
define
TraceLogging_h
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
utility
>
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
TraceLoggingGraph
.
h
"
#
include
"
vm
/
TraceLoggingTypes
.
h
"
namespace
js
{
namespace
jit
{
class
CompileRuntime
;
}
class
AutoTraceLog
;
class
TraceLoggerEventPayload
;
class
TraceLoggerThread
;
class
TraceLoggerEvent
{
#
ifdef
JS_TRACE_LOGGING
private
:
class
EventPayloadOrTextId
{
uintptr_t
payload_
;
public
:
EventPayloadOrTextId
(
)
:
payload_
(
0
)
{
}
bool
isEventPayload
(
)
const
{
return
(
payload_
&
1
)
=
=
0
;
}
TraceLoggerEventPayload
*
eventPayload
(
)
const
{
MOZ_ASSERT
(
isEventPayload
(
)
)
;
return
(
TraceLoggerEventPayload
*
)
payload_
;
}
void
setEventPayload
(
TraceLoggerEventPayload
*
payload
)
{
payload_
=
(
uintptr_t
)
payload
;
MOZ_ASSERT
(
(
payload_
&
1
)
=
=
0
)
;
}
bool
isTextId
(
)
const
{
return
(
payload_
&
1
)
=
=
1
;
}
uint32_t
textId
(
)
const
{
MOZ_ASSERT
(
isTextId
(
)
)
;
return
payload_
>
>
1
;
}
void
setTextId
(
TraceLoggerTextId
textId
)
{
static_assert
(
TraceLogger_Last
<
(
UINT32_MAX
>
>
1
)
"
Too
many
predefined
text
ids
.
"
)
;
payload_
=
(
(
(
uint32_t
)
textId
)
<
<
1
)
|
1
;
}
}
;
EventPayloadOrTextId
payload_
;
public
:
TraceLoggerEvent
(
)
:
payload_
(
)
{
}
explicit
TraceLoggerEvent
(
TraceLoggerTextId
textId
)
;
TraceLoggerEvent
(
TraceLoggerTextId
type
JSScript
*
script
)
;
TraceLoggerEvent
(
TraceLoggerTextId
type
const
char
*
filename
uint32_t
line
uint32_t
column
)
;
explicit
TraceLoggerEvent
(
const
char
*
text
)
;
TraceLoggerEvent
(
const
TraceLoggerEvent
&
event
)
;
TraceLoggerEvent
&
operator
=
(
const
TraceLoggerEvent
&
other
)
;
~
TraceLoggerEvent
(
)
;
uint32_t
textId
(
)
const
;
bool
hasTextId
(
)
const
{
return
hasExtPayload
(
)
|
|
payload_
.
isTextId
(
)
;
}
private
:
TraceLoggerEventPayload
*
extPayload
(
)
const
{
MOZ_ASSERT
(
hasExtPayload
(
)
)
;
return
payload_
.
eventPayload
(
)
;
}
bool
hasExtPayload
(
)
const
{
return
payload_
.
isEventPayload
(
)
&
&
!
!
payload_
.
eventPayload
(
)
;
}
#
else
public
:
TraceLoggerEvent
(
)
{
}
explicit
TraceLoggerEvent
(
TraceLoggerTextId
textId
)
{
}
TraceLoggerEvent
(
TraceLoggerTextId
type
JSScript
*
script
)
{
}
TraceLoggerEvent
(
TraceLoggerTextId
type
const
char
*
filename
uint32_t
line
uint32_t
column
)
{
}
explicit
TraceLoggerEvent
(
const
char
*
text
)
{
}
TraceLoggerEvent
(
const
TraceLoggerEvent
&
event
)
{
}
TraceLoggerEvent
&
operator
=
(
const
TraceLoggerEvent
&
other
)
{
return
*
this
;
}
;
~
TraceLoggerEvent
(
)
{
}
uint32_t
textId
(
)
const
{
return
0
;
}
bool
hasTextId
(
)
const
{
return
false
;
}
#
endif
}
;
#
ifdef
DEBUG
bool
CurrentThreadOwnsTraceLoggerThreadStateLock
(
)
;
#
endif
class
TraceLoggerEventPayload
{
uint32_t
textId_
;
UniqueChars
string_
;
mozilla
:
:
Atomic
<
uint32_t
>
uses_
;
mozilla
:
:
Atomic
<
uint32_t
>
pointerCount_
;
public
:
TraceLoggerEventPayload
(
uint32_t
textId
UniqueChars
string
)
:
textId_
(
textId
)
string_
(
std
:
:
move
(
string
)
)
uses_
(
0
)
{
}
~
TraceLoggerEventPayload
(
)
{
MOZ_ASSERT
(
uses_
=
=
0
)
;
}
uint32_t
textId
(
)
{
return
textId_
;
}
const
char
*
string
(
)
{
return
string_
.
get
(
)
;
}
uint32_t
uses
(
)
{
return
uses_
;
}
uint32_t
pointerCount
(
)
{
return
pointerCount_
;
}
void
use
(
)
{
MOZ_ASSERT_IF
(
!
uses_
CurrentThreadOwnsTraceLoggerThreadStateLock
(
)
)
;
uses_
+
+
;
}
void
release
(
)
{
uses_
-
-
;
}
void
incPointerCount
(
)
{
MOZ_ASSERT
(
CurrentThreadOwnsTraceLoggerThreadStateLock
(
)
)
;
pointerCount_
+
+
;
}
void
decPointerCount
(
)
{
MOZ_ASSERT
(
CurrentThreadOwnsTraceLoggerThreadStateLock
(
)
)
;
pointerCount_
-
-
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
string_
.
get
(
)
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
class
TraceLoggerThread
:
public
mozilla
:
:
LinkedListElement
<
TraceLoggerThread
>
{
#
ifdef
JS_TRACE_LOGGING
private
:
uint32_t
enabled_
;
bool
failed
;
UniquePtr
<
TraceLoggerGraph
>
graph
;
ContinuousSpace
<
EventEntry
>
events
;
uint32_t
iteration_
;
#
ifdef
DEBUG
typedef
Vector
<
uint32_t
1
js
:
:
SystemAllocPolicy
>
GraphStack
;
GraphStack
graphStack
;
#
endif
public
:
AutoTraceLog
*
top
;
TraceLoggerThread
(
)
:
enabled_
(
0
)
failed
(
false
)
graph
(
)
iteration_
(
0
)
top
(
nullptr
)
{
}
bool
init
(
)
;
~
TraceLoggerThread
(
)
;
bool
init
(
uint32_t
loggerId
)
;
void
initGraph
(
)
;
bool
enable
(
)
;
bool
enable
(
JSContext
*
cx
)
;
bool
disable
(
bool
force
=
false
const
char
*
=
"
"
)
;
bool
enabled
(
)
{
return
enabled_
>
0
;
}
void
silentFail
(
const
char
*
error
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
bool
fail
(
JSContext
*
cx
const
char
*
error
)
;
public
:
EventEntry
*
getEventsStartingAt
(
uint32_t
*
lastIteration
uint32_t
*
lastSize
size_t
*
num
)
{
EventEntry
*
start
;
if
(
iteration_
=
=
*
lastIteration
)
{
MOZ_ASSERT
(
*
lastSize
<
=
events
.
size
(
)
)
;
*
num
=
events
.
size
(
)
-
*
lastSize
;
start
=
events
.
data
(
)
+
*
lastSize
;
}
else
{
*
num
=
events
.
size
(
)
;
start
=
events
.
data
(
)
;
}
getIterationAndSize
(
lastIteration
lastSize
)
;
return
start
;
}
void
getIterationAndSize
(
uint32_t
*
iteration
uint32_t
*
size
)
const
{
*
iteration
=
iteration_
;
*
size
=
events
.
size
(
)
;
}
void
extractScriptDetails
(
uint32_t
textId
const
char
*
*
filename
size_t
*
filename_len
const
char
*
*
lineno
size_t
*
lineno_len
const
char
*
*
colno
size_t
*
colno_len
)
;
bool
lostEvents
(
uint32_t
lastIteration
uint32_t
lastSize
)
{
if
(
lastIteration
=
=
iteration_
)
{
MOZ_ASSERT
(
lastSize
<
=
events
.
size
(
)
)
;
return
false
;
}
if
(
lastIteration
=
=
iteration_
-
1
&
&
lastSize
=
=
events
.
maxSize
(
)
)
return
false
;
return
true
;
}
private
:
const
char
*
maybeEventText
(
uint32_t
id
)
;
public
:
const
char
*
eventText
(
uint32_t
id
)
{
const
char
*
text
=
maybeEventText
(
id
)
;
MOZ_ASSERT
(
text
)
;
return
text
;
}
;
bool
textIdIsScriptEvent
(
uint32_t
id
)
;
public
:
void
logTimestamp
(
TraceLoggerTextId
id
)
;
void
startEvent
(
TraceLoggerTextId
id
)
;
void
startEvent
(
const
TraceLoggerEvent
&
event
)
;
void
stopEvent
(
TraceLoggerTextId
id
)
;
void
stopEvent
(
const
TraceLoggerEvent
&
event
)
;
void
logTimestamp
(
uint32_t
id
)
;
void
startEvent
(
uint32_t
id
)
;
void
stopEvent
(
uint32_t
id
)
;
private
:
void
stopEvent
(
)
;
void
log
(
uint32_t
id
)
;
public
:
static
unsigned
offsetOfEnabled
(
)
{
return
offsetof
(
TraceLoggerThread
enabled_
)
;
}
#
endif
}
;
class
TraceLoggerThreadState
{
#
ifdef
JS_TRACE_LOGGING
#
ifdef
DEBUG
bool
initialized
;
#
endif
bool
enabledTextIds
[
TraceLogger_Last
]
;
bool
mainThreadEnabled
;
bool
helperThreadEnabled
;
bool
graphEnabled
;
bool
graphFileEnabled
;
bool
spewErrors
;
mozilla
:
:
LinkedList
<
TraceLoggerThread
>
threadLoggers
;
typedef
HashMap
<
const
void
*
TraceLoggerEventPayload
*
PointerHasher
<
const
void
*
>
SystemAllocPolicy
>
PointerHashMap
;
typedef
HashMap
<
uint32_t
TraceLoggerEventPayload
*
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
TextIdHashMap
;
PointerHashMap
pointerMap
;
TextIdHashMap
textIdPayloads
;
uint32_t
nextTextId
;
public
:
uint64_t
startupTime
;
Mutex
lock
;
TraceLoggerThreadState
(
)
:
#
ifdef
DEBUG
initialized
(
false
)
#
endif
mainThreadEnabled
(
false
)
helperThreadEnabled
(
false
)
graphEnabled
(
false
)
graphFileEnabled
(
false
)
spewErrors
(
false
)
nextTextId
(
TraceLogger_Last
)
startupTime
(
0
)
lock
(
js
:
:
mutexid
:
:
TraceLoggerThreadState
)
{
}
bool
init
(
)
;
~
TraceLoggerThreadState
(
)
;
TraceLoggerThread
*
forCurrentThread
(
JSContext
*
cx
)
;
void
destroyLogger
(
TraceLoggerThread
*
logger
)
;
bool
isTextIdEnabled
(
uint32_t
textId
)
{
if
(
textId
<
TraceLogger_Last
)
return
enabledTextIds
[
textId
]
;
return
true
;
}
void
enableTextId
(
JSContext
*
cx
uint32_t
textId
)
;
void
disableTextId
(
JSContext
*
cx
uint32_t
textId
)
;
void
maybeSpewError
(
const
char
*
text
)
{
if
(
spewErrors
)
fprintf
(
stderr
"
%
s
\
n
"
text
)
;
}
const
char
*
maybeEventText
(
uint32_t
id
)
;
void
purgeUnusedPayloads
(
)
;
TraceLoggerEventPayload
*
getOrCreateEventPayload
(
const
char
*
text
)
;
TraceLoggerEventPayload
*
getOrCreateEventPayload
(
JSScript
*
script
)
;
TraceLoggerEventPayload
*
getOrCreateEventPayload
(
const
char
*
filename
uint32_t
lineno
uint32_t
colno
const
void
*
p
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
IsGraphFileEnabled
(
)
{
return
graphFileEnabled
;
}
bool
IsGraphEnabled
(
)
{
return
graphEnabled
;
}
#
endif
}
;
#
ifdef
JS_TRACE_LOGGING
void
DestroyTraceLoggerThreadState
(
)
;
void
DestroyTraceLogger
(
TraceLoggerThread
*
logger
)
;
TraceLoggerThread
*
TraceLoggerForCurrentThread
(
JSContext
*
cx
=
nullptr
)
;
#
else
inline
TraceLoggerThread
*
TraceLoggerForCurrentThread
(
JSContext
*
cx
=
nullptr
)
{
return
nullptr
;
}
;
#
endif
inline
bool
TraceLoggerEnable
(
TraceLoggerThread
*
logger
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
return
logger
-
>
enable
(
)
;
#
endif
return
false
;
}
inline
bool
TraceLoggerEnable
(
TraceLoggerThread
*
logger
JSContext
*
cx
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
return
logger
-
>
enable
(
cx
)
;
#
endif
return
false
;
}
inline
bool
TraceLoggerDisable
(
TraceLoggerThread
*
logger
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
return
logger
-
>
disable
(
)
;
#
endif
return
false
;
}
inline
void
TraceLoggerSilentFail
(
TraceLoggerThread
*
logger
const
char
*
error
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
silentFail
(
error
)
;
#
endif
}
#
ifdef
JS_TRACE_LOGGING
bool
TraceLogTextIdEnabled
(
uint32_t
textId
)
;
void
TraceLogEnableTextId
(
JSContext
*
cx
uint32_t
textId
)
;
void
TraceLogDisableTextId
(
JSContext
*
cx
uint32_t
textId
)
;
#
else
inline
bool
TraceLogTextIdEnabled
(
uint32_t
textId
)
{
return
false
;
}
inline
void
TraceLogEnableTextId
(
JSContext
*
cx
uint32_t
textId
)
{
}
inline
void
TraceLogDisableTextId
(
JSContext
*
cx
uint32_t
textId
)
{
}
#
endif
inline
void
TraceLogTimestamp
(
TraceLoggerThread
*
logger
TraceLoggerTextId
textId
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
logTimestamp
(
textId
)
;
#
endif
}
inline
void
TraceLogStartEvent
(
TraceLoggerThread
*
logger
TraceLoggerTextId
textId
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
startEvent
(
textId
)
;
#
endif
}
inline
void
TraceLogStartEvent
(
TraceLoggerThread
*
logger
const
TraceLoggerEvent
&
event
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
startEvent
(
event
)
;
#
endif
}
inline
void
TraceLogStopEvent
(
TraceLoggerThread
*
logger
TraceLoggerTextId
textId
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
stopEvent
(
textId
)
;
#
endif
}
inline
void
TraceLogStopEvent
(
TraceLoggerThread
*
logger
const
TraceLoggerEvent
&
event
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
stopEvent
(
event
)
;
#
endif
}
inline
void
TraceLogTimestampPrivate
(
TraceLoggerThread
*
logger
uint32_t
id
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
logTimestamp
(
id
)
;
#
endif
}
inline
void
TraceLogStartEventPrivate
(
TraceLoggerThread
*
logger
uint32_t
id
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
startEvent
(
id
)
;
#
endif
}
inline
void
TraceLogStopEventPrivate
(
TraceLoggerThread
*
logger
uint32_t
id
)
{
#
ifdef
JS_TRACE_LOGGING
if
(
logger
)
logger
-
>
stopEvent
(
id
)
;
#
endif
}
size_t
SizeOfTraceLogState
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
class
MOZ_RAII
AutoTraceLog
{
#
ifdef
JS_TRACE_LOGGING
TraceLoggerThread
*
logger
;
union
{
const
TraceLoggerEvent
*
event
;
TraceLoggerTextId
id
;
}
payload
;
bool
isEvent
;
bool
executed
;
AutoTraceLog
*
prev
;
public
:
AutoTraceLog
(
TraceLoggerThread
*
logger
const
TraceLoggerEvent
&
event
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
logger
(
logger
)
isEvent
(
true
)
executed
(
false
)
prev
(
nullptr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
payload
.
event
=
&
event
;
if
(
logger
)
{
logger
-
>
startEvent
(
event
)
;
prev
=
logger
-
>
top
;
logger
-
>
top
=
this
;
}
}
AutoTraceLog
(
TraceLoggerThread
*
logger
TraceLoggerTextId
id
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
logger
(
logger
)
isEvent
(
false
)
executed
(
false
)
prev
(
nullptr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
payload
.
id
=
id
;
if
(
logger
)
{
logger
-
>
startEvent
(
id
)
;
prev
=
logger
-
>
top
;
logger
-
>
top
=
this
;
}
}
~
AutoTraceLog
(
)
{
if
(
logger
)
{
while
(
this
!
=
logger
-
>
top
)
logger
-
>
top
-
>
stop
(
)
;
stop
(
)
;
}
}
private
:
void
stop
(
)
{
if
(
!
executed
)
{
executed
=
true
;
if
(
isEvent
)
logger
-
>
stopEvent
(
*
payload
.
event
)
;
else
logger
-
>
stopEvent
(
payload
.
id
)
;
}
if
(
logger
-
>
top
=
=
this
)
logger
-
>
top
=
prev
;
}
#
else
public
:
AutoTraceLog
(
TraceLoggerThread
*
logger
uint32_t
textId
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
AutoTraceLog
(
TraceLoggerThread
*
logger
const
TraceLoggerEvent
&
event
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
#
endif
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
#
endif
