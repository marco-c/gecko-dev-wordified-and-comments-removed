#
ifndef
vm_CodeCoverage_h
#
define
vm_CodeCoverage_h
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
Printer
.
h
"
namespace
js
{
class
ScriptSourceObject
;
namespace
coverage
{
class
LCovSource
{
public
:
LCovSource
(
LifoAlloc
*
alloc
JS
:
:
UniqueChars
name
)
;
LCovSource
(
LCovSource
&
&
src
)
;
~
LCovSource
(
)
=
default
;
bool
match
(
const
char
*
name
)
const
{
return
strcmp
(
name_
.
get
(
)
name
)
=
=
0
;
}
bool
isComplete
(
)
const
{
return
hasTopLevelScript_
;
}
bool
writeScript
(
JSScript
*
script
)
;
void
exportInto
(
GenericPrinter
&
out
)
;
private
:
bool
writeScriptName
(
LSprinter
&
out
JSScript
*
script
)
;
private
:
JS
:
:
UniqueChars
name_
;
LSprinter
outFN_
;
LSprinter
outFNDA_
;
size_t
numFunctionsFound_
;
size_t
numFunctionsHit_
;
LSprinter
outBRDA_
;
size_t
numBranchesFound_
;
size_t
numBranchesHit_
;
HashMap
<
size_t
uint64_t
DefaultHasher
<
size_t
>
SystemAllocPolicy
>
linesHit_
;
size_t
numLinesInstrumented_
;
size_t
numLinesHit_
;
size_t
maxLineHit_
;
bool
hasTopLevelScript_
:
1
;
}
;
class
LCovRealm
{
public
:
LCovRealm
(
)
;
~
LCovRealm
(
)
;
void
collectCodeCoverageInfo
(
JS
:
:
Realm
*
realm
JSScript
*
topLevel
const
char
*
name
)
;
void
exportInto
(
GenericPrinter
&
out
bool
*
isEmpty
)
const
;
private
:
bool
writeRealmName
(
JS
:
:
Realm
*
realm
)
;
LCovSource
*
lookupOrAdd
(
JS
:
:
Realm
*
realm
const
char
*
name
)
;
private
:
typedef
mozilla
:
:
Vector
<
LCovSource
16
LifoAllocPolicy
<
Fallible
>
>
LCovSourceVector
;
LifoAlloc
alloc_
;
LSprinter
outTN_
;
LCovSourceVector
*
sources_
;
}
;
class
LCovRuntime
{
public
:
LCovRuntime
(
)
;
~
LCovRuntime
(
)
;
void
init
(
)
;
bool
isEnabled
(
)
const
{
static
bool
isEnabled_
=
[
]
(
)
{
const
char
*
outDir
=
getenv
(
"
JS_CODE_COVERAGE_OUTPUT_DIR
"
)
;
return
outDir
&
&
*
outDir
!
=
0
;
}
;
return
isEnabled_
;
}
void
writeLCovResult
(
LCovRealm
&
realm
)
;
private
:
void
maybeReopenAfterFork
(
)
;
bool
fillWithFilename
(
char
*
name
size_t
length
)
;
void
finishFile
(
)
;
private
:
Fprinter
out_
;
uint32_t
pid_
;
bool
isEmpty_
;
}
;
}
}
#
endif
