#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
utility
>
#
include
"
jsfriendapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
BytecodeCompilation
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
CompleteFile
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
mozilla
:
:
Utf8Unit
;
using
JS
:
:
CompileOptions
;
using
JS
:
:
HandleObject
;
using
JS
:
:
ReadOnlyCompileOptions
;
using
JS
:
:
SourceOwnership
;
using
JS
:
:
SourceText
;
using
JS
:
:
UniqueTwoByteChars
;
using
JS
:
:
UTF8Chars
;
using
JS
:
:
UTF8CharsToNewTwoByteCharsZ
;
using
namespace
js
;
JS_PUBLIC_API
void
JS
:
:
detail
:
:
ReportSourceTooLong
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SOURCE_TOO_LONG
)
;
}
template
<
typename
Unit
>
static
JSScript
*
CompileSourceBuffer
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
Unit
>
&
srcBuf
)
{
ScopeKind
scopeKind
=
options
.
nonSyntacticScope
?
ScopeKind
:
:
NonSyntactic
:
ScopeKind
:
:
Global
;
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
frontend
:
:
GlobalScriptInfo
info
(
cx
options
scopeKind
)
;
return
frontend
:
:
CompileGlobalScript
(
info
srcBuf
)
;
}
static
JSScript
*
CompileUtf8
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char
*
bytes
size_t
length
)
{
auto
chars
=
UniqueTwoByteChars
(
UTF8CharsToNewTwoByteCharsZ
(
cx
UTF8Chars
(
bytes
length
)
&
length
)
.
get
(
)
)
;
if
(
!
chars
)
{
return
nullptr
;
}
SourceText
<
char16_t
>
source
;
if
(
!
source
.
init
(
cx
std
:
:
move
(
chars
)
length
)
)
{
return
nullptr
;
}
return
CompileSourceBuffer
(
cx
options
source
)
;
}
static
JSScript
*
CompileUtf8DontInflate
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char
*
bytes
size_t
length
)
{
SourceText
<
Utf8Unit
>
source
;
if
(
!
source
.
init
(
cx
bytes
length
SourceOwnership
:
:
Borrowed
)
)
{
return
nullptr
;
}
return
CompileSourceBuffer
(
cx
options
source
)
;
}
JSScript
*
JS
:
:
Compile
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
char16_t
>
&
srcBuf
)
{
return
CompileSourceBuffer
(
cx
options
srcBuf
)
;
}
JSScript
*
JS
:
:
CompileDontInflate
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
Utf8Unit
>
&
srcBuf
)
{
return
CompileSourceBuffer
(
cx
options
srcBuf
)
;
}
JSScript
*
JS
:
:
CompileUtf8
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char
*
bytes
size_t
length
)
{
return
:
:
CompileUtf8
(
cx
options
bytes
length
)
;
}
JSScript
*
JS
:
:
CompileUtf8DontInflate
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char
*
bytes
size_t
length
)
{
return
:
:
CompileUtf8DontInflate
(
cx
options
bytes
length
)
;
}
JSScript
*
JS
:
:
CompileUtf8File
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
FILE
*
file
)
{
FileContents
buffer
(
cx
)
;
if
(
!
ReadCompleteFile
(
cx
file
buffer
)
)
{
return
nullptr
;
}
return
:
:
CompileUtf8
(
cx
options
reinterpret_cast
<
const
char
*
>
(
buffer
.
begin
(
)
)
buffer
.
length
(
)
)
;
}
JSScript
*
JS
:
:
CompileUtf8FileDontInflate
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
FILE
*
file
)
{
FileContents
buffer
(
cx
)
;
if
(
!
ReadCompleteFile
(
cx
file
buffer
)
)
{
return
nullptr
;
}
return
:
:
CompileUtf8DontInflate
(
cx
options
reinterpret_cast
<
const
char
*
>
(
buffer
.
begin
(
)
)
buffer
.
length
(
)
)
;
}
JSScript
*
JS
:
:
CompileUtf8Path
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
optionsArg
const
char
*
filename
)
{
AutoFile
file
;
if
(
!
file
.
open
(
cx
filename
)
)
{
return
nullptr
;
}
CompileOptions
options
(
cx
optionsArg
)
;
options
.
setFileAndLine
(
filename
1
)
;
return
CompileUtf8File
(
cx
options
file
.
fp
(
)
)
;
}
JSScript
*
JS
:
:
CompileForNonSyntacticScope
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
optionsArg
SourceText
<
char16_t
>
&
srcBuf
)
{
CompileOptions
options
(
cx
optionsArg
)
;
options
.
setNonSyntacticScope
(
true
)
;
return
CompileSourceBuffer
(
cx
options
srcBuf
)
;
}
JSScript
*
JS
:
:
CompileUtf8ForNonSyntacticScope
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
optionsArg
const
char
*
bytes
size_t
length
)
{
CompileOptions
options
(
cx
optionsArg
)
;
options
.
setNonSyntacticScope
(
true
)
;
return
:
:
CompileUtf8
(
cx
options
bytes
length
)
;
}
JS_PUBLIC_API
bool
JS_Utf8BufferIsCompilableUnit
(
JSContext
*
cx
HandleObject
obj
const
char
*
utf8
size_t
length
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
)
;
cx
-
>
clearPendingException
(
)
;
JS
:
:
UniqueTwoByteChars
chars
{
UTF8CharsToNewTwoByteCharsZ
(
cx
UTF8Chars
(
utf8
length
)
&
length
)
.
get
(
)
}
;
if
(
!
chars
)
{
return
true
;
}
bool
result
=
true
;
using
frontend
:
:
CreateScriptSourceObject
;
using
frontend
:
:
FullParseHandler
;
using
frontend
:
:
ParseGoal
;
using
frontend
:
:
Parser
;
using
frontend
:
:
UsedNameTracker
;
CompileOptions
options
(
cx
)
;
UsedNameTracker
usedNames
(
cx
)
;
Rooted
<
ScriptSourceObject
*
>
sourceObject
(
cx
)
;
sourceObject
=
CreateScriptSourceObject
(
cx
options
mozilla
:
:
Nothing
(
)
)
;
if
(
!
sourceObject
)
{
return
false
;
}
JS
:
:
AutoSuppressWarningReporter
suppressWarnings
(
cx
)
;
Parser
<
FullParseHandler
char16_t
>
parser
(
cx
cx
-
>
tempLifoAlloc
(
)
options
chars
.
get
(
)
length
true
usedNames
nullptr
nullptr
sourceObject
ParseGoal
:
:
Script
)
;
if
(
!
parser
.
checkOptions
(
)
|
|
!
parser
.
parse
(
)
)
{
if
(
parser
.
isUnexpectedEOF
(
)
)
{
result
=
false
;
}
cx
-
>
clearPendingException
(
)
;
}
return
result
;
}
class
FunctionCompiler
{
private
:
JSContext
*
const
cx_
;
RootedAtom
nameAtom_
;
StringBuffer
funStr_
;
uint32_t
parameterListEnd_
=
0
;
bool
nameIsIdentifier_
=
true
;
public
:
explicit
FunctionCompiler
(
JSContext
*
cx
)
:
cx_
(
cx
)
nameAtom_
(
cx
)
funStr_
(
cx
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
}
MOZ_MUST_USE
bool
init
(
const
char
*
name
unsigned
nargs
const
char
*
const
*
argnames
)
{
if
(
!
funStr_
.
ensureTwoByteChars
(
)
)
{
return
false
;
}
if
(
!
funStr_
.
append
(
"
function
"
)
)
{
return
false
;
}
if
(
name
)
{
size_t
nameLen
=
strlen
(
name
)
;
nameAtom_
=
Atomize
(
cx_
name
nameLen
)
;
if
(
!
nameAtom_
)
{
return
false
;
}
nameIsIdentifier_
=
js
:
:
frontend
:
:
IsIdentifier
(
reinterpret_cast
<
const
Latin1Char
*
>
(
name
)
nameLen
)
;
if
(
nameIsIdentifier_
)
{
if
(
!
funStr_
.
append
(
nameAtom_
)
)
{
return
false
;
}
}
}
if
(
!
funStr_
.
append
(
"
(
"
)
)
{
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
nargs
;
i
+
+
)
{
if
(
i
!
=
0
)
{
if
(
!
funStr_
.
append
(
"
"
)
)
{
return
false
;
}
}
if
(
!
funStr_
.
append
(
argnames
[
i
]
strlen
(
argnames
[
i
]
)
)
)
{
return
false
;
}
}
parameterListEnd_
=
funStr_
.
length
(
)
;
MOZ_ASSERT
(
FunctionConstructorMedialSigils
[
0
]
=
=
'
)
'
)
;
return
funStr_
.
append
(
FunctionConstructorMedialSigils
)
;
}
template
<
typename
Unit
>
inline
MOZ_MUST_USE
bool
addFunctionBody
(
const
SourceText
<
Unit
>
&
srcBuf
)
{
return
funStr_
.
append
(
srcBuf
.
get
(
)
srcBuf
.
length
(
)
)
;
}
JSFunction
*
finish
(
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
options
)
{
if
(
!
funStr_
.
append
(
FunctionConstructorFinalBrace
)
)
{
return
nullptr
;
}
size_t
newLen
=
funStr_
.
length
(
)
;
UniqueTwoByteChars
stolen
(
funStr_
.
stealChars
(
)
)
;
if
(
!
stolen
)
{
return
nullptr
;
}
SourceText
<
char16_t
>
newSrcBuf
;
if
(
!
newSrcBuf
.
init
(
cx_
std
:
:
move
(
stolen
)
newLen
)
)
{
return
nullptr
;
}
RootedObject
enclosingEnv
(
cx_
)
;
RootedScope
enclosingScope
(
cx_
)
;
if
(
!
CreateNonSyntacticEnvironmentChain
(
cx_
envChain
&
enclosingEnv
&
enclosingScope
)
)
{
return
nullptr
;
}
cx_
-
>
check
(
enclosingEnv
)
;
RootedFunction
fun
(
cx_
NewScriptedFunction
(
cx_
0
JSFunction
:
:
INTERPRETED_NORMAL
nameIsIdentifier_
?
HandleAtom
(
nameAtom_
)
:
nullptr
nullptr
gc
:
:
AllocKind
:
:
FUNCTION
TenuredObject
enclosingEnv
)
)
;
if
(
!
fun
)
{
return
nullptr
;
}
MOZ_ASSERT_IF
(
!
IsGlobalLexicalEnvironment
(
enclosingEnv
)
enclosingScope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
if
(
!
js
:
:
frontend
:
:
CompileStandaloneFunction
(
cx_
&
fun
options
newSrcBuf
mozilla
:
:
Some
(
parameterListEnd_
)
enclosingScope
)
)
{
return
nullptr
;
}
if
(
!
nameIsIdentifier_
)
{
fun
-
>
setAtom
(
nameAtom_
)
;
}
return
fun
;
}
}
;
JS_PUBLIC_API
JSFunction
*
JS
:
:
CompileFunction
(
JSContext
*
cx
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
options
const
char
*
name
unsigned
nargs
const
char
*
const
*
argnames
SourceText
<
char16_t
>
&
srcBuf
)
{
FunctionCompiler
compiler
(
cx
)
;
if
(
!
compiler
.
init
(
name
nargs
argnames
)
|
|
!
compiler
.
addFunctionBody
(
srcBuf
)
)
{
return
nullptr
;
}
return
compiler
.
finish
(
envChain
options
)
;
}
JS_PUBLIC_API
JSFunction
*
JS
:
:
CompileFunction
(
JSContext
*
cx
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
options
const
char
*
name
unsigned
nargs
const
char
*
const
*
argnames
SourceText
<
Utf8Unit
>
&
srcBuf
)
{
FunctionCompiler
compiler
(
cx
)
;
if
(
!
compiler
.
init
(
name
nargs
argnames
)
|
|
!
compiler
.
addFunctionBody
(
srcBuf
)
)
{
return
nullptr
;
}
return
compiler
.
finish
(
envChain
options
)
;
}
JS_PUBLIC_API
JSFunction
*
JS
:
:
CompileFunctionUtf8
(
JSContext
*
cx
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
options
const
char
*
name
unsigned
nargs
const
char
*
const
*
argnames
const
char
*
bytes
size_t
length
)
{
SourceText
<
Utf8Unit
>
srcBuf
;
if
(
!
srcBuf
.
init
(
cx
bytes
length
SourceOwnership
:
:
Borrowed
)
)
{
return
nullptr
;
}
return
CompileFunction
(
cx
envChain
options
name
nargs
argnames
srcBuf
)
;
}
JS_PUBLIC_API
bool
JS
:
:
InitScriptSourceElement
(
JSContext
*
cx
HandleScript
script
HandleObject
element
HandleString
elementAttrName
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
RootedScriptSourceObject
sso
(
cx
&
script
-
>
sourceObject
(
)
-
>
as
<
ScriptSourceObject
>
(
)
)
;
return
ScriptSourceObject
:
:
initElementProperties
(
cx
sso
element
elementAttrName
)
;
}
JS_PUBLIC_API
void
JS
:
:
ExposeScriptToDebugger
(
JSContext
*
cx
HandleScript
script
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
MOZ_ASSERT
(
script
-
>
hideScriptFromDebugger
(
)
)
;
script
-
>
clearHideScriptFromDebugger
(
)
;
Debugger
:
:
onNewScript
(
cx
script
)
;
}
MOZ_NEVER_INLINE
static
bool
ExecuteScript
(
JSContext
*
cx
HandleObject
scope
HandleScript
script
Value
*
rval
)
{
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
scope
script
)
;
MOZ_ASSERT_IF
(
!
IsGlobalLexicalEnvironment
(
scope
)
script
-
>
hasNonSyntacticScope
(
)
)
;
return
Execute
(
cx
script
*
scope
rval
)
;
}
static
bool
ExecuteScript
(
JSContext
*
cx
HandleObjectVector
envChain
HandleScript
scriptArg
Value
*
rval
)
{
RootedObject
env
(
cx
)
;
RootedScope
dummy
(
cx
)
;
if
(
!
CreateNonSyntacticEnvironmentChain
(
cx
envChain
&
env
&
dummy
)
)
{
return
false
;
}
RootedScript
script
(
cx
scriptArg
)
;
if
(
!
script
-
>
hasNonSyntacticScope
(
)
&
&
!
IsGlobalLexicalEnvironment
(
env
)
)
{
script
=
CloneGlobalScript
(
cx
ScopeKind
:
:
NonSyntactic
script
)
;
if
(
!
script
)
{
return
false
;
}
js
:
:
Debugger
:
:
onNewScript
(
cx
script
)
;
}
return
ExecuteScript
(
cx
env
script
rval
)
;
}
MOZ_NEVER_INLINE
JS_PUBLIC_API
bool
JS_ExecuteScript
(
JSContext
*
cx
HandleScript
scriptArg
MutableHandleValue
rval
)
{
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
return
ExecuteScript
(
cx
globalLexical
scriptArg
rval
.
address
(
)
)
;
}
MOZ_NEVER_INLINE
JS_PUBLIC_API
bool
JS_ExecuteScript
(
JSContext
*
cx
HandleScript
scriptArg
)
{
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
return
ExecuteScript
(
cx
globalLexical
scriptArg
nullptr
)
;
}
MOZ_NEVER_INLINE
JS_PUBLIC_API
bool
JS_ExecuteScript
(
JSContext
*
cx
HandleObjectVector
envChain
HandleScript
scriptArg
MutableHandleValue
rval
)
{
return
ExecuteScript
(
cx
envChain
scriptArg
rval
.
address
(
)
)
;
}
MOZ_NEVER_INLINE
JS_PUBLIC_API
bool
JS_ExecuteScript
(
JSContext
*
cx
HandleObjectVector
envChain
HandleScript
scriptArg
)
{
return
ExecuteScript
(
cx
envChain
scriptArg
nullptr
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CloneAndExecuteScript
(
JSContext
*
cx
HandleScript
scriptArg
JS
:
:
MutableHandleValue
rval
)
{
CHECK_THREAD
(
cx
)
;
RootedScript
script
(
cx
scriptArg
)
;
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
if
(
script
-
>
realm
(
)
!
=
cx
-
>
realm
(
)
)
{
script
=
CloneGlobalScript
(
cx
ScopeKind
:
:
Global
script
)
;
if
(
!
script
)
{
return
false
;
}
js
:
:
Debugger
:
:
onNewScript
(
cx
script
)
;
}
return
ExecuteScript
(
cx
globalLexical
script
rval
.
address
(
)
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CloneAndExecuteScript
(
JSContext
*
cx
JS
:
:
HandleObjectVector
envChain
HandleScript
scriptArg
JS
:
:
MutableHandleValue
rval
)
{
CHECK_THREAD
(
cx
)
;
RootedScript
script
(
cx
scriptArg
)
;
if
(
script
-
>
realm
(
)
!
=
cx
-
>
realm
(
)
)
{
script
=
CloneGlobalScript
(
cx
ScopeKind
:
:
NonSyntactic
script
)
;
if
(
!
script
)
{
return
false
;
}
js
:
:
Debugger
:
:
onNewScript
(
cx
script
)
;
}
return
ExecuteScript
(
cx
envChain
script
rval
.
address
(
)
)
;
}
template
<
typename
Unit
>
static
bool
Evaluate
(
JSContext
*
cx
ScopeKind
scopeKind
HandleObject
env
const
ReadOnlyCompileOptions
&
optionsArg
SourceText
<
Unit
>
&
srcBuf
MutableHandleValue
rval
)
{
CompileOptions
options
(
cx
optionsArg
)
;
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
env
)
;
MOZ_ASSERT_IF
(
!
IsGlobalLexicalEnvironment
(
env
)
scopeKind
=
=
ScopeKind
:
:
NonSyntactic
)
;
options
.
setIsRunOnce
(
true
)
;
RootedScript
script
(
cx
)
;
{
frontend
:
:
GlobalScriptInfo
info
(
cx
options
scopeKind
)
;
script
=
frontend
:
:
CompileGlobalScript
(
info
srcBuf
)
;
if
(
!
script
)
{
return
false
;
}
}
return
Execute
(
cx
script
*
env
options
.
noScriptRval
?
nullptr
:
rval
.
address
(
)
)
;
}
static
bool
Evaluate
(
JSContext
*
cx
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
optionsArg
SourceText
<
char16_t
>
&
srcBuf
MutableHandleValue
rval
)
{
RootedObject
env
(
cx
)
;
RootedScope
scope
(
cx
)
;
if
(
!
CreateNonSyntacticEnvironmentChain
(
cx
envChain
&
env
&
scope
)
)
{
return
false
;
}
return
:
:
Evaluate
(
cx
scope
-
>
kind
(
)
env
optionsArg
srcBuf
rval
)
;
}
extern
JS_PUBLIC_API
bool
JS
:
:
EvaluateUtf8
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
char
*
bytes
size_t
length
MutableHandle
<
Value
>
rval
)
{
SourceText
<
Utf8Unit
>
srcBuf
;
if
(
!
srcBuf
.
init
(
cx
bytes
length
SourceOwnership
:
:
Borrowed
)
)
{
return
false
;
}
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
return
:
:
Evaluate
(
cx
ScopeKind
:
:
Global
globalLexical
options
srcBuf
rval
)
;
}
JS_PUBLIC_API
bool
JS
:
:
Evaluate
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
optionsArg
SourceText
<
char16_t
>
&
srcBuf
MutableHandleValue
rval
)
{
RootedObject
globalLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
return
:
:
Evaluate
(
cx
ScopeKind
:
:
Global
globalLexical
optionsArg
srcBuf
rval
)
;
}
JS_PUBLIC_API
bool
JS
:
:
Evaluate
(
JSContext
*
cx
HandleObjectVector
envChain
const
ReadOnlyCompileOptions
&
optionsArg
SourceText
<
char16_t
>
&
srcBuf
MutableHandleValue
rval
)
{
return
:
:
Evaluate
(
cx
envChain
optionsArg
srcBuf
rval
)
;
}
JS_PUBLIC_API
bool
JS
:
:
EvaluateUtf8Path
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
optionsArg
const
char
*
filename
MutableHandleValue
rval
)
{
FileContents
buffer
(
cx
)
;
{
AutoFile
file
;
if
(
!
file
.
open
(
cx
filename
)
|
|
!
file
.
readAll
(
cx
buffer
)
)
{
return
false
;
}
}
CompileOptions
options
(
cx
optionsArg
)
;
options
.
setFileAndLine
(
filename
1
)
;
auto
contents
=
reinterpret_cast
<
const
char
*
>
(
buffer
.
begin
(
)
)
;
size_t
length
=
buffer
.
length
(
)
;
auto
chars
=
UniqueTwoByteChars
(
UTF8CharsToNewTwoByteCharsZ
(
cx
UTF8Chars
(
contents
length
)
&
length
)
.
get
(
)
)
;
if
(
!
chars
)
{
return
false
;
}
SourceText
<
char16_t
>
srcBuf
;
if
(
!
srcBuf
.
init
(
cx
std
:
:
move
(
chars
)
length
)
)
{
return
false
;
}
return
Evaluate
(
cx
options
srcBuf
rval
)
;
}
