#
ifndef
vm_Iteration_h
#
define
vm_Iteration_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
ArrayObject
;
class
PlainObject
;
class
PropertyIteratorObject
;
struct
PropertyIndex
{
private
:
uint32_t
asBits_
;
public
:
enum
class
Kind
:
uint32_t
{
DynamicSlot
FixedSlot
Element
Invalid
}
;
PropertyIndex
(
Kind
kind
uint32_t
index
)
:
asBits_
(
encode
(
kind
index
)
)
{
}
static
PropertyIndex
Invalid
(
)
{
return
PropertyIndex
(
Kind
:
:
Invalid
0
)
;
}
static
PropertyIndex
ForElement
(
uint32_t
index
)
{
return
PropertyIndex
(
Kind
:
:
Element
index
)
;
}
static
PropertyIndex
ForSlot
(
NativeObject
*
obj
uint32_t
index
)
{
if
(
index
<
obj
-
>
numFixedSlots
(
)
)
{
return
PropertyIndex
(
Kind
:
:
FixedSlot
index
)
;
}
else
{
return
PropertyIndex
(
Kind
:
:
DynamicSlot
index
-
obj
-
>
numFixedSlots
(
)
)
;
}
}
static
constexpr
uint32_t
KindBits
=
2
;
static
constexpr
uint32_t
IndexBits
=
32
-
KindBits
;
static
constexpr
uint32_t
IndexLimit
=
1
<
<
IndexBits
;
static
constexpr
uint32_t
IndexMask
=
(
1
<
<
IndexBits
)
-
1
;
static
constexpr
uint32_t
KindShift
=
IndexBits
;
static_assert
(
NativeObject
:
:
MAX_FIXED_SLOTS
<
IndexLimit
)
;
static_assert
(
NativeObject
:
:
MAX_SLOTS_COUNT
<
IndexLimit
)
;
static_assert
(
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
<
IndexLimit
)
;
private
:
uint32_t
encode
(
Kind
kind
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
IndexLimit
)
;
return
(
uint32_t
(
kind
)
<
<
KindShift
)
|
index
;
}
public
:
Kind
kind
(
)
const
{
return
Kind
(
asBits_
>
>
KindShift
)
;
}
uint32_t
index
(
)
const
{
return
asBits_
&
IndexMask
;
}
}
;
using
PropertyIndexVector
=
js
:
:
Vector
<
PropertyIndex
8
js
:
:
TempAllocPolicy
>
;
struct
NativeIterator
;
class
NativeIteratorListNode
{
protected
:
NativeIteratorListNode
*
prev_
=
nullptr
;
NativeIteratorListNode
*
next_
=
nullptr
;
public
:
NativeIteratorListNode
*
prev
(
)
{
return
prev_
;
}
NativeIteratorListNode
*
next
(
)
{
return
next_
;
}
void
setPrev
(
NativeIteratorListNode
*
prev
)
{
prev_
=
prev
;
}
void
setNext
(
NativeIteratorListNode
*
next
)
{
next_
=
next
;
}
static
constexpr
size_t
offsetOfNext
(
)
{
return
offsetof
(
NativeIteratorListNode
next_
)
;
}
static
constexpr
size_t
offsetOfPrev
(
)
{
return
offsetof
(
NativeIteratorListNode
prev_
)
;
}
private
:
NativeIterator
*
asNativeIterator
(
)
{
return
reinterpret_cast
<
NativeIterator
*
>
(
this
)
;
}
friend
class
NativeIteratorListIter
;
}
;
class
NativeIteratorListHead
:
public
NativeIteratorListNode
{
private
:
NativeIteratorListHead
(
)
{
prev_
=
next_
=
this
;
}
friend
class
JS
:
:
Compartment
;
}
;
class
NativeIteratorListIter
{
private
:
NativeIteratorListHead
*
head_
;
NativeIteratorListNode
*
curr_
;
public
:
explicit
NativeIteratorListIter
(
NativeIteratorListHead
*
head
)
:
head_
(
head
)
curr_
(
head
-
>
next
(
)
)
{
}
bool
done
(
)
const
{
return
curr_
=
=
head_
;
}
NativeIterator
*
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
NativeIterator
*
result
=
curr_
-
>
asNativeIterator
(
)
;
curr_
=
curr_
-
>
next
(
)
;
return
result
;
}
}
;
enum
class
NativeIteratorIndices
:
uint32_t
{
Unavailable
=
0
AvailableOnRequest
=
1
Disabled
=
2
Valid
=
3
}
;
struct
NativeIterator
:
public
NativeIteratorListNode
{
private
:
GCPtr
<
JSObject
*
>
objectBeingIterated_
=
{
}
;
const
GCPtr
<
JSObject
*
>
iterObj_
=
{
}
;
GCPtr
<
Shape
*
>
*
shapesEnd_
;
GCPtr
<
JSLinearString
*
>
*
propertyCursor_
;
GCPtr
<
JSLinearString
*
>
*
propertiesEnd_
;
HashNumber
shapesHash_
;
public
:
struct
Flags
{
static
constexpr
uint32_t
Initialized
=
0x1
;
static
constexpr
uint32_t
Active
=
0x2
;
static
constexpr
uint32_t
HasUnvisitedPropertyDeletion
=
0x4
;
static
constexpr
uint32_t
IsEmptyIteratorSingleton
=
0x8
;
static
constexpr
uint32_t
NotReusable
=
Active
|
HasUnvisitedPropertyDeletion
;
}
;
private
:
static
constexpr
uint32_t
FlagsBits
=
4
;
static
constexpr
uint32_t
IndicesBits
=
2
;
static
constexpr
uint32_t
FlagsMask
=
(
1
<
<
FlagsBits
)
-
1
;
static
constexpr
uint32_t
PropCountShift
=
IndicesBits
+
FlagsBits
;
static
constexpr
uint32_t
PropCountBits
=
32
-
PropCountShift
;
public
:
static
constexpr
uint32_t
IndicesShift
=
FlagsBits
;
static
constexpr
uint32_t
IndicesMask
=
(
(
1
<
<
IndicesBits
)
-
1
)
<
<
IndicesShift
;
static
constexpr
uint32_t
PropCountLimit
=
1
<
<
PropCountBits
;
private
:
uint32_t
flagsAndCount_
=
0
;
#
ifdef
DEBUG
bool
maybeHasIndexedPropertiesFromProto_
=
false
;
#
endif
public
:
NativeIterator
(
JSContext
*
cx
Handle
<
PropertyIteratorObject
*
>
propIter
Handle
<
JSObject
*
>
objBeingIterated
HandleIdVector
props
bool
supportsIndices
PropertyIndexVector
*
indices
uint32_t
numShapes
bool
*
hadError
)
;
JSObject
*
objectBeingIterated
(
)
const
{
return
objectBeingIterated_
;
}
void
initObjectBeingIterated
(
JSObject
&
obj
)
{
MOZ_ASSERT
(
!
objectBeingIterated_
)
;
objectBeingIterated_
.
init
(
&
obj
)
;
}
void
clearObjectBeingIterated
(
)
{
MOZ_ASSERT
(
objectBeingIterated_
)
;
objectBeingIterated_
=
nullptr
;
}
GCPtr
<
Shape
*
>
*
shapesBegin
(
)
const
{
static_assert
(
alignof
(
GCPtr
<
Shape
*
>
)
<
=
alignof
(
NativeIterator
)
"
NativeIterator
must
be
aligned
to
begin
storing
"
"
GCPtr
<
Shape
*
>
s
immediately
after
it
with
no
required
padding
"
)
;
const
NativeIterator
*
immediatelyAfter
=
this
+
1
;
auto
*
afterNonConst
=
const_cast
<
NativeIterator
*
>
(
immediatelyAfter
)
;
return
reinterpret_cast
<
GCPtr
<
Shape
*
>
*
>
(
afterNonConst
)
;
}
GCPtr
<
Shape
*
>
*
shapesEnd
(
)
const
{
return
shapesEnd_
;
}
uint32_t
shapeCount
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
shapesBegin
(
)
shapesEnd
(
)
)
;
}
GCPtr
<
JSLinearString
*
>
*
propertiesBegin
(
)
const
{
static_assert
(
alignof
(
GCPtr
<
Shape
*
>
)
>
=
alignof
(
GCPtr
<
JSLinearString
*
>
)
"
GCPtr
<
JSLinearString
*
>
s
for
properties
must
be
able
to
appear
"
"
directly
after
any
GCPtr
<
Shape
*
>
s
after
this
NativeIterator
"
"
with
no
padding
space
required
for
correct
alignment
"
)
;
static_assert
(
alignof
(
NativeIterator
)
>
=
alignof
(
GCPtr
<
JSLinearString
*
>
)
"
GCPtr
<
JSLinearString
*
>
s
for
properties
must
be
able
to
appear
"
"
directly
after
this
NativeIterator
when
no
GCPtr
<
Shape
*
>
s
are
"
"
present
with
no
padding
space
required
for
correct
"
"
alignment
"
)
;
MOZ_ASSERT
(
isInitialized
(
)
"
NativeIterator
must
be
initialized
or
else
|
shapesEnd_
|
"
"
isn
'
t
necessarily
the
start
of
properties
and
instead
"
"
|
propertyCursor_
|
is
"
)
;
return
reinterpret_cast
<
GCPtr
<
JSLinearString
*
>
*
>
(
shapesEnd_
)
;
}
GCPtr
<
JSLinearString
*
>
*
propertiesEnd
(
)
const
{
return
propertiesEnd_
;
}
GCPtr
<
JSLinearString
*
>
*
nextProperty
(
)
const
{
return
propertyCursor_
;
}
PropertyIndex
*
indicesBegin
(
)
const
{
static_assert
(
alignof
(
GCPtr
<
JSLinearString
*
>
)
>
=
alignof
(
PropertyIndex
)
)
;
return
reinterpret_cast
<
PropertyIndex
*
>
(
propertiesEnd_
)
;
}
PropertyIndex
*
indicesEnd
(
)
const
{
MOZ_ASSERT
(
indicesState
(
)
=
=
NativeIteratorIndices
:
:
Valid
)
;
return
indicesBegin
(
)
+
numKeys
(
)
*
sizeof
(
PropertyIndex
)
;
}
MOZ_ALWAYS_INLINE
JS
:
:
Value
nextIteratedValueAndAdvance
(
)
{
if
(
propertyCursor_
>
=
propertiesEnd_
)
{
MOZ_ASSERT
(
propertyCursor_
=
=
propertiesEnd_
)
;
return
JS
:
:
MagicValue
(
JS_NO_ITER_VALUE
)
;
}
JSLinearString
*
str
=
*
propertyCursor_
;
incCursor
(
)
;
return
JS
:
:
StringValue
(
str
)
;
}
void
resetPropertyCursorForReuse
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertyCursor_
=
propertiesBegin
(
)
;
}
bool
previousPropertyWas
(
JS
:
:
Handle
<
JSLinearString
*
>
str
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
propertyCursor_
>
propertiesBegin
(
)
&
&
propertyCursor_
[
-
1
]
=
=
str
;
}
size_t
numKeys
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
propertiesBegin
(
)
propertiesEnd
(
)
)
;
}
void
trimLastProperty
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertiesEnd_
-
-
;
*
propertiesEnd_
=
nullptr
;
disableIndices
(
)
;
}
JSObject
*
iterObj
(
)
const
{
return
iterObj_
;
}
void
incCursor
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertyCursor_
+
+
;
}
HashNumber
shapesHash
(
)
const
{
return
shapesHash_
;
}
bool
isInitialized
(
)
const
{
return
flags
(
)
&
Flags
:
:
Initialized
;
}
size_t
allocationSize
(
)
const
;
#
ifdef
DEBUG
void
setMaybeHasIndexedPropertiesFromProto
(
)
{
maybeHasIndexedPropertiesFromProto_
=
true
;
}
bool
maybeHasIndexedPropertiesFromProto
(
)
const
{
return
maybeHasIndexedPropertiesFromProto_
;
}
#
endif
private
:
uint32_t
flags
(
)
const
{
return
flagsAndCount_
&
FlagsMask
;
}
NativeIteratorIndices
indicesState
(
)
const
{
return
NativeIteratorIndices
(
(
flagsAndCount_
&
IndicesMask
)
>
>
IndicesShift
)
;
}
uint32_t
initialPropertyCount
(
)
const
{
return
flagsAndCount_
>
>
PropCountShift
;
}
static
uint32_t
initialFlagsAndCount
(
uint32_t
count
)
{
MOZ_ASSERT
(
count
<
PropCountLimit
)
;
return
count
<
<
PropCountShift
;
}
void
setFlags
(
uint32_t
flags
)
{
MOZ_ASSERT
(
(
flags
&
~
FlagsMask
)
=
=
0
)
;
flagsAndCount_
=
(
flagsAndCount_
&
~
FlagsMask
)
|
flags
;
}
void
setIndicesState
(
NativeIteratorIndices
indices
)
{
uint32_t
indicesBits
=
uint32_t
(
indices
)
<
<
IndicesShift
;
flagsAndCount_
=
(
flagsAndCount_
&
~
IndicesMask
)
|
indicesBits
;
}
bool
indicesAllocated
(
)
const
{
return
indicesState
(
)
>
=
NativeIteratorIndices
:
:
Disabled
;
}
void
markInitialized
(
)
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
setFlags
(
Flags
:
:
Initialized
)
;
}
bool
isUnlinked
(
)
const
{
return
!
prev_
&
&
!
next_
;
}
public
:
bool
isEmptyIteratorSingleton
(
)
const
{
bool
res
=
flags
(
)
&
Flags
:
:
IsEmptyIteratorSingleton
;
MOZ_ASSERT_IF
(
res
flags
(
)
=
=
(
Flags
:
:
Initialized
|
Flags
:
:
IsEmptyIteratorSingleton
)
)
;
MOZ_ASSERT_IF
(
res
!
objectBeingIterated_
)
;
MOZ_ASSERT_IF
(
res
initialPropertyCount
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
res
shapeCount
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
res
isUnlinked
(
)
)
;
return
res
;
}
void
markEmptyIteratorSingleton
(
)
{
flagsAndCount_
|
=
Flags
:
:
IsEmptyIteratorSingleton
;
MOZ_ASSERT
(
isEmptyIteratorSingleton
(
)
)
;
}
bool
isActive
(
)
const
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
flags
(
)
&
Flags
:
:
Active
;
}
void
markActive
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
|
=
Flags
:
:
Active
;
}
void
markInactive
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
&
=
~
Flags
:
:
Active
;
}
bool
isReusable
(
)
const
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
flags
(
)
=
=
Flags
:
:
Initialized
;
}
void
markHasUnvisitedPropertyDeletion
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
|
=
Flags
:
:
HasUnvisitedPropertyDeletion
;
}
bool
hasValidIndices
(
)
const
{
return
indicesState
(
)
=
=
NativeIteratorIndices
:
:
Valid
;
}
bool
indicesAvailableOnRequest
(
)
const
{
return
indicesState
(
)
=
=
NativeIteratorIndices
:
:
AvailableOnRequest
;
}
bool
mayHavePrototypeProperties
(
)
{
return
!
hasValidIndices
(
)
&
&
!
indicesAvailableOnRequest
(
)
;
}
void
disableIndices
(
)
{
if
(
indicesState
(
)
=
=
NativeIteratorIndices
:
:
Valid
)
{
setIndicesState
(
NativeIteratorIndices
:
:
Disabled
)
;
}
}
void
link
(
NativeIteratorListNode
*
other
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
MOZ_ASSERT
(
isUnlinked
(
)
)
;
setNext
(
other
)
;
setPrev
(
other
-
>
prev
(
)
)
;
other
-
>
prev
(
)
-
>
setNext
(
this
)
;
other
-
>
setPrev
(
this
)
;
}
void
unlink
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
next
(
)
-
>
setPrev
(
prev
(
)
)
;
prev
(
)
-
>
setNext
(
next
(
)
)
;
setNext
(
nullptr
)
;
setPrev
(
nullptr
)
;
}
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
size_t
offsetOfObjectBeingIterated
(
)
{
return
offsetof
(
NativeIterator
objectBeingIterated_
)
;
}
static
constexpr
size_t
offsetOfShapesEnd
(
)
{
return
offsetof
(
NativeIterator
shapesEnd_
)
;
}
static
constexpr
size_t
offsetOfPropertyCursor
(
)
{
return
offsetof
(
NativeIterator
propertyCursor_
)
;
}
static
constexpr
size_t
offsetOfPropertiesEnd
(
)
{
return
offsetof
(
NativeIterator
propertiesEnd_
)
;
}
static
constexpr
size_t
offsetOfFlagsAndCount
(
)
{
return
offsetof
(
NativeIterator
flagsAndCount_
)
;
}
static
constexpr
size_t
offsetOfFirstShape
(
)
{
return
sizeof
(
NativeIterator
)
;
}
}
;
class
PropertyIteratorObject
:
public
NativeObject
{
static
const
JSClassOps
classOps_
;
enum
{
IteratorSlot
SlotCount
}
;
public
:
static
const
JSClass
class_
;
NativeIterator
*
getNativeIterator
(
)
const
{
return
maybePtrFromReservedSlot
<
NativeIterator
>
(
IteratorSlot
)
;
}
void
initNativeIterator
(
js
:
:
NativeIterator
*
ni
)
{
initReservedSlot
(
IteratorSlot
PrivateValue
(
ni
)
)
;
}
size_t
sizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
static
size_t
offsetOfIteratorSlot
(
)
{
return
getFixedSlotOffset
(
IteratorSlot
)
;
}
private
:
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
}
;
class
ArrayIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
ArrayIteratorObject
*
NewArrayIteratorTemplate
(
JSContext
*
cx
)
;
ArrayIteratorObject
*
NewArrayIterator
(
JSContext
*
cx
)
;
class
StringIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
StringIteratorObject
*
NewStringIteratorTemplate
(
JSContext
*
cx
)
;
StringIteratorObject
*
NewStringIterator
(
JSContext
*
cx
)
;
class
RegExpStringIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
RegExpStringIteratorObject
*
NewRegExpStringIteratorTemplate
(
JSContext
*
cx
)
;
RegExpStringIteratorObject
*
NewRegExpStringIterator
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
EnumerateProperties
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
props
)
;
PropertyIteratorObject
*
LookupInIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
LookupInShapeIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
GetIterator
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
GetIteratorWithIndices
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
ValueToIterator
(
JSContext
*
cx
HandleValue
vp
)
;
void
CloseIterator
(
JSObject
*
obj
)
;
bool
IteratorCloseForException
(
JSContext
*
cx
HandleObject
obj
)
;
void
UnwindIteratorForUncatchableException
(
JSObject
*
obj
)
;
extern
bool
SuppressDeletedProperty
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
extern
bool
SuppressDeletedElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
)
;
#
ifdef
DEBUG
extern
void
AssertDenseElementsNotIterated
(
NativeObject
*
obj
)
;
#
else
inline
void
AssertDenseElementsNotIterated
(
NativeObject
*
obj
)
{
}
#
endif
inline
Value
IteratorMore
(
JSObject
*
iterobj
)
{
NativeIterator
*
ni
=
iterobj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
;
return
ni
-
>
nextIteratedValueAndAdvance
(
)
;
}
extern
PlainObject
*
CreateIterResultObject
(
JSContext
*
cx
HandleValue
value
bool
done
)
;
class
IteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
}
;
class
WrapForValidIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
IteratorSlot
NextMethodSlot
SlotCount
}
;
static_assert
(
IteratorSlot
=
=
WRAP_FOR_VALID_ITERATOR_ITERATOR_SLOT
"
IteratedSlot
must
match
self
-
hosting
define
for
iterator
object
slot
.
"
)
;
static_assert
(
NextMethodSlot
=
=
WRAP_FOR_VALID_ITERATOR_NEXT_METHOD_SLOT
"
NextMethodSlot
must
match
self
-
hosting
define
for
next
method
slot
.
"
)
;
}
;
WrapForValidIteratorObject
*
NewWrapForValidIterator
(
JSContext
*
cx
)
;
class
IteratorHelperObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
GeneratorSlot
SlotCount
}
;
static_assert
(
GeneratorSlot
=
=
ITERATOR_HELPER_GENERATOR_SLOT
"
GeneratorSlot
must
match
self
-
hosting
define
for
generator
"
"
object
slot
.
"
)
;
}
;
IteratorHelperObject
*
NewIteratorHelper
(
JSContext
*
cx
)
;
bool
IterableToArray
(
JSContext
*
cx
HandleValue
iterable
MutableHandle
<
ArrayObject
*
>
array
)
;
}
#
endif
