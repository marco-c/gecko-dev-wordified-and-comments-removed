#
ifndef
vm_Iteration_h
#
define
vm_Iteration_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
ReceiverGuard
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
define
JSITER_ACTIVE
0x1000
#
define
JSITER_UNREUSABLE
0x2000
namespace
js
{
class
PropertyIteratorObject
;
struct
NativeIterator
{
private
:
GCPtrObject
objectBeingIterated_
=
{
}
;
JSObject
*
iterObj_
=
nullptr
;
HeapReceiverGuard
*
guardsEnd_
;
public
:
GCPtrFlatString
*
propertyCursor_
;
GCPtrFlatString
*
propertiesEnd_
;
uint32_t
guard_key
=
0
;
uint32_t
flags
=
0
;
private
:
NativeIterator
*
next_
=
nullptr
;
NativeIterator
*
prev_
=
nullptr
;
public
:
NativeIterator
(
JSContext
*
cx
Handle
<
PropertyIteratorObject
*
>
propIter
Handle
<
JSObject
*
>
objBeingIterated
const
AutoIdVector
&
props
uint32_t
numGuards
uint32_t
guardKey
bool
*
hadError
)
;
NativeIterator
(
)
;
JSObject
&
objectBeingIterated
(
)
const
{
return
*
objectBeingIterated_
;
}
void
changeObjectBeingIterated
(
JSObject
&
obj
)
{
objectBeingIterated_
=
&
obj
;
}
HeapReceiverGuard
*
guardsBegin
(
)
const
{
static_assert
(
alignof
(
HeapReceiverGuard
)
<
=
alignof
(
NativeIterator
)
"
NativeIterator
must
be
aligned
to
begin
storing
"
"
HeapReceiverGuards
immediately
after
it
with
no
"
"
required
padding
"
)
;
const
NativeIterator
*
immediatelyAfter
=
this
+
1
;
auto
*
afterNonConst
=
const_cast
<
NativeIterator
*
>
(
immediatelyAfter
)
;
return
reinterpret_cast
<
HeapReceiverGuard
*
>
(
afterNonConst
)
;
}
HeapReceiverGuard
*
guardsEnd
(
)
const
{
return
guardsEnd_
;
}
uint32_t
guardCount
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
guardsBegin
(
)
guardsEnd
(
)
)
;
}
GCPtrFlatString
*
propertiesBegin
(
)
const
{
static_assert
(
alignof
(
HeapReceiverGuard
)
>
=
alignof
(
GCPtrFlatString
)
"
GCPtrFlatStrings
for
properties
must
be
able
to
appear
"
"
directly
after
any
HeapReceiverGuards
after
this
"
"
NativeIterator
with
no
padding
space
required
for
"
"
correct
alignment
"
)
;
static_assert
(
alignof
(
NativeIterator
)
>
=
alignof
(
GCPtrFlatString
)
"
GCPtrFlatStrings
for
properties
must
be
able
to
appear
"
"
directly
after
this
NativeIterator
when
no
"
"
HeapReceiverGuards
are
present
with
no
padding
space
"
"
required
for
correct
alignment
"
)
;
return
reinterpret_cast
<
GCPtrFlatString
*
>
(
guardsEnd_
)
;
}
GCPtrFlatString
*
propertiesEnd
(
)
const
{
return
propertiesEnd_
;
}
size_t
numKeys
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
propertiesBegin
(
)
propertiesEnd
(
)
)
;
}
JSObject
*
iterObj
(
)
const
{
return
iterObj_
;
}
GCPtrFlatString
*
currentProperty
(
)
const
{
MOZ_ASSERT
(
propertyCursor_
<
propertiesEnd
(
)
)
;
return
propertyCursor_
;
}
NativeIterator
*
next
(
)
{
return
next_
;
}
void
incCursor
(
)
{
propertyCursor_
+
+
;
}
void
link
(
NativeIterator
*
other
)
{
MOZ_ASSERT
(
!
next_
&
&
!
prev_
)
;
this
-
>
next_
=
other
;
this
-
>
prev_
=
other
-
>
prev_
;
other
-
>
prev_
-
>
next_
=
this
;
other
-
>
prev_
=
this
;
}
void
unlink
(
)
{
next_
-
>
prev_
=
prev_
;
prev_
-
>
next_
=
next_
;
next_
=
nullptr
;
prev_
=
nullptr
;
}
static
NativeIterator
*
allocateSentinel
(
JSContext
*
maybecx
)
;
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
size_t
offsetOfObjectBeingIterated
(
)
{
return
offsetof
(
NativeIterator
objectBeingIterated_
)
;
}
static
constexpr
size_t
offsetOfGuardsEnd
(
)
{
return
offsetof
(
NativeIterator
guardsEnd_
)
;
}
static
constexpr
size_t
offsetOfPropertyCursor
(
)
{
return
offsetof
(
NativeIterator
propertyCursor_
)
;
}
static
constexpr
size_t
offsetOfPropertiesEnd
(
)
{
return
offsetof
(
NativeIterator
propertiesEnd_
)
;
}
static
constexpr
size_t
offsetOfNext
(
)
{
return
offsetof
(
NativeIterator
next_
)
;
}
static
constexpr
size_t
offsetOfPrev
(
)
{
return
offsetof
(
NativeIterator
prev_
)
;
}
}
;
class
PropertyIteratorObject
:
public
NativeObject
{
static
const
ClassOps
classOps_
;
public
:
static
const
Class
class_
;
NativeIterator
*
getNativeIterator
(
)
const
{
return
static_cast
<
js
:
:
NativeIterator
*
>
(
getPrivate
(
)
)
;
}
void
setNativeIterator
(
js
:
:
NativeIterator
*
ni
)
{
setPrivate
(
ni
)
;
}
size_t
sizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
}
;
class
ArrayIteratorObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
}
;
ArrayIteratorObject
*
NewArrayIteratorObject
(
JSContext
*
cx
NewObjectKind
newKind
=
GenericObject
)
;
class
StringIteratorObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
}
;
StringIteratorObject
*
NewStringIteratorObject
(
JSContext
*
cx
NewObjectKind
newKind
=
GenericObject
)
;
JSObject
*
GetIterator
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
LookupInIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
;
JSObject
*
EnumeratedIdVectorToIterator
(
JSContext
*
cx
HandleObject
obj
AutoIdVector
&
props
)
;
JSObject
*
NewEmptyPropertyIterator
(
JSContext
*
cx
)
;
JSObject
*
ValueToIterator
(
JSContext
*
cx
HandleValue
vp
)
;
void
CloseIterator
(
JSObject
*
obj
)
;
bool
IteratorCloseForException
(
JSContext
*
cx
HandleObject
obj
)
;
void
UnwindIteratorForUncatchableException
(
JSObject
*
obj
)
;
extern
bool
SuppressDeletedProperty
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
extern
bool
SuppressDeletedElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
)
;
extern
bool
IteratorMore
(
JSContext
*
cx
HandleObject
iterobj
MutableHandleValue
rval
)
;
extern
JSObject
*
CreateIterResultObject
(
JSContext
*
cx
HandleValue
value
bool
done
)
;
bool
IsPropertyIterator
(
HandleValue
v
)
;
enum
class
IteratorKind
{
Sync
Async
}
;
}
#
endif
