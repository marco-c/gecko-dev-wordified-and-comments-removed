#
ifndef
vm_Iteration_h
#
define
vm_Iteration_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
ReceiverGuard
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
define
JSITER_ACTIVE
0x1000
#
define
JSITER_UNREUSABLE
0x2000
namespace
js
{
class
PropertyIteratorObject
;
struct
NativeIterator
{
GCPtrObject
obj
=
{
}
;
JSObject
*
iterObj_
=
nullptr
;
GCPtrFlatString
*
props_cursor
;
GCPtrFlatString
*
props_end
;
uint32_t
guard_length
=
0
;
uint32_t
guard_key
=
0
;
uint32_t
flags
=
0
;
private
:
NativeIterator
*
next_
=
nullptr
;
NativeIterator
*
prev_
=
nullptr
;
public
:
NativeIterator
(
JSContext
*
cx
Handle
<
PropertyIteratorObject
*
>
propIter
Handle
<
JSObject
*
>
objBeingIterated
const
AutoIdVector
&
props
uint32_t
numGuards
uint32_t
guardKey
bool
*
hadError
)
;
NativeIterator
(
)
;
GCPtrFlatString
*
begin
(
)
const
{
static_assert
(
alignof
(
NativeIterator
)
>
=
alignof
(
GCPtrFlatString
)
"
GCPtrFlatStrings
for
properties
must
be
able
to
appear
"
"
directly
after
NativeIterator
with
no
padding
space
"
"
required
for
correct
alignment
"
)
;
const
NativeIterator
*
immediatelyAfter
=
this
+
1
;
auto
*
afterNonConst
=
const_cast
<
NativeIterator
*
>
(
immediatelyAfter
)
;
return
reinterpret_cast
<
GCPtrFlatString
*
>
(
afterNonConst
)
;
}
GCPtrFlatString
*
end
(
)
const
{
return
props_end
;
}
HeapReceiverGuard
*
guardArray
(
)
const
{
static_assert
(
alignof
(
ReceiverGuard
)
=
=
alignof
(
GCPtrFlatString
)
"
the
end
of
all
properties
must
be
exactly
aligned
"
"
adequate
to
begin
storing
ReceiverGuards
else
the
"
"
full
tacked
-
on
memory
won
'
t
be
enough
to
store
all
"
"
properties
/
guards
"
)
;
return
reinterpret_cast
<
HeapReceiverGuard
*
>
(
props_end
)
;
}
size_t
numKeys
(
)
const
{
return
end
(
)
-
begin
(
)
;
}
JSObject
*
iterObj
(
)
const
{
return
iterObj_
;
}
GCPtrFlatString
*
current
(
)
const
{
MOZ_ASSERT
(
props_cursor
<
props_end
)
;
return
props_cursor
;
}
NativeIterator
*
next
(
)
{
return
next_
;
}
static
inline
size_t
offsetOfNext
(
)
{
return
offsetof
(
NativeIterator
next_
)
;
}
static
inline
size_t
offsetOfPrev
(
)
{
return
offsetof
(
NativeIterator
prev_
)
;
}
void
incCursor
(
)
{
props_cursor
=
props_cursor
+
1
;
}
void
link
(
NativeIterator
*
other
)
{
MOZ_ASSERT
(
!
next_
&
&
!
prev_
)
;
this
-
>
next_
=
other
;
this
-
>
prev_
=
other
-
>
prev_
;
other
-
>
prev_
-
>
next_
=
this
;
other
-
>
prev_
=
this
;
}
void
unlink
(
)
{
next_
-
>
prev_
=
prev_
;
prev_
-
>
next_
=
next_
;
next_
=
nullptr
;
prev_
=
nullptr
;
}
static
NativeIterator
*
allocateSentinel
(
JSContext
*
maybecx
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
class
PropertyIteratorObject
:
public
NativeObject
{
static
const
ClassOps
classOps_
;
public
:
static
const
Class
class_
;
NativeIterator
*
getNativeIterator
(
)
const
{
return
static_cast
<
js
:
:
NativeIterator
*
>
(
getPrivate
(
)
)
;
}
void
setNativeIterator
(
js
:
:
NativeIterator
*
ni
)
{
setPrivate
(
ni
)
;
}
size_t
sizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
}
;
class
ArrayIteratorObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
}
;
ArrayIteratorObject
*
NewArrayIteratorObject
(
JSContext
*
cx
NewObjectKind
newKind
=
GenericObject
)
;
class
StringIteratorObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
}
;
StringIteratorObject
*
NewStringIteratorObject
(
JSContext
*
cx
NewObjectKind
newKind
=
GenericObject
)
;
JSObject
*
GetIterator
(
JSContext
*
cx
HandleObject
obj
)
;
PropertyIteratorObject
*
LookupInIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
;
JSObject
*
EnumeratedIdVectorToIterator
(
JSContext
*
cx
HandleObject
obj
AutoIdVector
&
props
)
;
JSObject
*
NewEmptyPropertyIterator
(
JSContext
*
cx
)
;
JSObject
*
ValueToIterator
(
JSContext
*
cx
HandleValue
vp
)
;
void
CloseIterator
(
JSObject
*
obj
)
;
bool
IteratorCloseForException
(
JSContext
*
cx
HandleObject
obj
)
;
void
UnwindIteratorForUncatchableException
(
JSObject
*
obj
)
;
extern
bool
SuppressDeletedProperty
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
extern
bool
SuppressDeletedElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
)
;
extern
bool
IteratorMore
(
JSContext
*
cx
HandleObject
iterobj
MutableHandleValue
rval
)
;
extern
JSObject
*
CreateIterResultObject
(
JSContext
*
cx
HandleValue
value
bool
done
)
;
bool
IsPropertyIterator
(
HandleValue
v
)
;
enum
class
IteratorKind
{
Sync
Async
}
;
}
#
endif
