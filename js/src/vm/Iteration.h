#
ifndef
vm_Iteration_h
#
define
vm_Iteration_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
class
PlainObject
;
class
PropertyIteratorObject
;
struct
NativeIterator
{
private
:
GCPtrObject
objectBeingIterated_
=
{
}
;
const
GCPtrObject
iterObj_
=
{
}
;
GCPtr
<
Shape
*
>
*
shapesEnd_
;
GCPtrLinearString
*
propertyCursor_
;
GCPtrLinearString
*
propertiesEnd_
;
HashNumber
shapesHash_
;
public
:
struct
Flags
{
static
constexpr
uint32_t
Initialized
=
0x1
;
static
constexpr
uint32_t
Active
=
0x2
;
static
constexpr
uint32_t
HasUnvisitedPropertyDeletion
=
0x4
;
static
constexpr
uint32_t
NotReusable
=
Active
|
HasUnvisitedPropertyDeletion
;
}
;
private
:
static
constexpr
uint32_t
FlagsBits
=
3
;
static
constexpr
uint32_t
FlagsMask
=
(
1
<
<
FlagsBits
)
-
1
;
public
:
static
constexpr
uint32_t
PropCountLimit
=
1
<
<
(
32
-
FlagsBits
)
;
private
:
NativeIterator
*
next_
=
nullptr
;
NativeIterator
*
prev_
=
nullptr
;
uint32_t
flagsAndCount_
=
0
;
#
ifdef
DEBUG
bool
maybeHasIndexedPropertiesFromProto_
=
false
;
#
endif
public
:
NativeIterator
(
JSContext
*
cx
Handle
<
PropertyIteratorObject
*
>
propIter
Handle
<
JSObject
*
>
objBeingIterated
HandleIdVector
props
uint32_t
numShapes
HashNumber
shapesHash
bool
*
hadError
)
;
NativeIterator
(
)
;
JSObject
*
objectBeingIterated
(
)
const
{
return
objectBeingIterated_
;
}
void
changeObjectBeingIterated
(
JSObject
&
obj
)
{
objectBeingIterated_
=
&
obj
;
}
GCPtr
<
Shape
*
>
*
shapesBegin
(
)
const
{
static_assert
(
alignof
(
GCPtr
<
Shape
*
>
)
<
=
alignof
(
NativeIterator
)
"
NativeIterator
must
be
aligned
to
begin
storing
"
"
GCPtr
<
Shape
*
>
s
immediately
after
it
with
no
required
padding
"
)
;
const
NativeIterator
*
immediatelyAfter
=
this
+
1
;
auto
*
afterNonConst
=
const_cast
<
NativeIterator
*
>
(
immediatelyAfter
)
;
return
reinterpret_cast
<
GCPtr
<
Shape
*
>
*
>
(
afterNonConst
)
;
}
GCPtr
<
Shape
*
>
*
shapesEnd
(
)
const
{
return
shapesEnd_
;
}
uint32_t
shapeCount
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
shapesBegin
(
)
shapesEnd
(
)
)
;
}
GCPtrLinearString
*
propertiesBegin
(
)
const
{
static_assert
(
alignof
(
GCPtr
<
Shape
*
>
)
>
=
alignof
(
GCPtrLinearString
)
"
GCPtrLinearStrings
for
properties
must
be
able
to
appear
"
"
directly
after
any
GCPtr
<
Shape
*
>
s
after
this
NativeIterator
"
"
with
no
padding
space
required
for
correct
alignment
"
)
;
static_assert
(
alignof
(
NativeIterator
)
>
=
alignof
(
GCPtrLinearString
)
"
GCPtrLinearStrings
for
properties
must
be
able
to
appear
"
"
directly
after
this
NativeIterator
when
no
GCPtr
<
Shape
*
>
s
are
"
"
present
with
no
padding
space
required
for
correct
"
"
alignment
"
)
;
MOZ_ASSERT
(
isInitialized
(
)
"
NativeIterator
must
be
initialized
or
else
|
shapesEnd_
|
"
"
isn
'
t
necessarily
the
start
of
properties
and
instead
"
"
|
propertyCursor_
|
is
"
)
;
return
reinterpret_cast
<
GCPtrLinearString
*
>
(
shapesEnd_
)
;
}
GCPtrLinearString
*
propertiesEnd
(
)
const
{
return
propertiesEnd_
;
}
GCPtrLinearString
*
nextProperty
(
)
const
{
return
propertyCursor_
;
}
MOZ_ALWAYS_INLINE
JS
:
:
Value
nextIteratedValueAndAdvance
(
)
{
if
(
propertyCursor_
>
=
propertiesEnd_
)
{
MOZ_ASSERT
(
propertyCursor_
=
=
propertiesEnd_
)
;
return
JS
:
:
MagicValue
(
JS_NO_ITER_VALUE
)
;
}
JSLinearString
*
str
=
*
propertyCursor_
;
incCursor
(
)
;
return
JS
:
:
StringValue
(
str
)
;
}
void
resetPropertyCursorForReuse
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertyCursor_
=
propertiesBegin
(
)
;
}
bool
previousPropertyWas
(
JS
:
:
Handle
<
JSLinearString
*
>
str
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
propertyCursor_
>
propertiesBegin
(
)
&
&
propertyCursor_
[
-
1
]
=
=
str
;
}
size_t
numKeys
(
)
const
{
return
mozilla
:
:
PointerRangeSize
(
propertiesBegin
(
)
propertiesEnd
(
)
)
;
}
void
trimLastProperty
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertiesEnd_
-
-
;
*
propertiesEnd_
=
nullptr
;
}
JSObject
*
iterObj
(
)
const
{
return
iterObj_
;
}
GCPtrLinearString
*
currentProperty
(
)
const
{
MOZ_ASSERT
(
propertyCursor_
<
propertiesEnd
(
)
)
;
return
propertyCursor_
;
}
NativeIterator
*
next
(
)
{
return
next_
;
}
void
incCursor
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
propertyCursor_
+
+
;
}
HashNumber
shapesHash
(
)
const
{
return
shapesHash_
;
}
bool
isInitialized
(
)
const
{
return
flags
(
)
&
Flags
:
:
Initialized
;
}
size_t
allocationSize
(
)
const
;
#
ifdef
DEBUG
void
setMaybeHasIndexedPropertiesFromProto
(
)
{
maybeHasIndexedPropertiesFromProto_
=
true
;
}
bool
maybeHasIndexedPropertiesFromProto
(
)
const
{
return
maybeHasIndexedPropertiesFromProto_
;
}
#
endif
private
:
uint32_t
flags
(
)
const
{
return
flagsAndCount_
&
FlagsMask
;
}
uint32_t
initialPropertyCount
(
)
const
{
return
flagsAndCount_
>
>
FlagsBits
;
}
static
uint32_t
initialFlagsAndCount
(
uint32_t
count
)
{
MOZ_ASSERT
(
count
<
PropCountLimit
)
;
return
count
<
<
FlagsBits
;
}
void
setFlags
(
uint32_t
flags
)
{
MOZ_ASSERT
(
(
flags
&
~
FlagsMask
)
=
=
0
)
;
flagsAndCount_
=
(
initialPropertyCount
(
)
<
<
FlagsBits
)
|
flags
;
}
void
markInitialized
(
)
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
setFlags
(
Flags
:
:
Initialized
)
;
}
bool
isUnlinked
(
)
const
{
return
!
prev_
&
&
!
next_
;
}
public
:
bool
isEmptyIteratorSingleton
(
)
const
{
bool
res
=
objectBeingIterated
(
)
=
=
nullptr
;
MOZ_ASSERT_IF
(
res
flags
(
)
=
=
Flags
:
:
Initialized
)
;
MOZ_ASSERT_IF
(
res
initialPropertyCount
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
res
shapeCount
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
res
isUnlinked
(
)
)
;
return
res
;
}
bool
isActive
(
)
const
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
flags
(
)
&
Flags
:
:
Active
;
}
void
markActive
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
|
=
Flags
:
:
Active
;
}
void
markInactive
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
&
=
~
Flags
:
:
Active
;
}
bool
isReusable
(
)
const
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
return
flags
(
)
=
=
Flags
:
:
Initialized
;
}
void
markHasUnvisitedPropertyDeletion
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
flagsAndCount_
|
=
Flags
:
:
HasUnvisitedPropertyDeletion
;
}
void
link
(
NativeIterator
*
other
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
MOZ_ASSERT
(
isUnlinked
(
)
)
;
this
-
>
next_
=
other
;
this
-
>
prev_
=
other
-
>
prev_
;
other
-
>
prev_
-
>
next_
=
this
;
other
-
>
prev_
=
this
;
}
void
unlink
(
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MOZ_ASSERT
(
!
isEmptyIteratorSingleton
(
)
)
;
next_
-
>
prev_
=
prev_
;
prev_
-
>
next_
=
next_
;
next_
=
nullptr
;
prev_
=
nullptr
;
}
static
NativeIterator
*
allocateSentinel
(
JSContext
*
cx
)
;
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
size_t
offsetOfObjectBeingIterated
(
)
{
return
offsetof
(
NativeIterator
objectBeingIterated_
)
;
}
static
constexpr
size_t
offsetOfShapesEnd
(
)
{
return
offsetof
(
NativeIterator
shapesEnd_
)
;
}
static
constexpr
size_t
offsetOfPropertyCursor
(
)
{
return
offsetof
(
NativeIterator
propertyCursor_
)
;
}
static
constexpr
size_t
offsetOfPropertiesEnd
(
)
{
return
offsetof
(
NativeIterator
propertiesEnd_
)
;
}
static
constexpr
size_t
offsetOfFlagsAndCount
(
)
{
return
offsetof
(
NativeIterator
flagsAndCount_
)
;
}
static
constexpr
size_t
offsetOfNext
(
)
{
return
offsetof
(
NativeIterator
next_
)
;
}
static
constexpr
size_t
offsetOfPrev
(
)
{
return
offsetof
(
NativeIterator
prev_
)
;
}
}
;
class
PropertyIteratorObject
:
public
NativeObject
{
static
const
JSClassOps
classOps_
;
enum
{
IteratorSlot
SlotCount
}
;
public
:
static
const
JSClass
class_
;
NativeIterator
*
getNativeIterator
(
)
const
{
return
maybePtrFromReservedSlot
<
NativeIterator
>
(
IteratorSlot
)
;
}
void
initNativeIterator
(
js
:
:
NativeIterator
*
ni
)
{
initReservedSlot
(
IteratorSlot
PrivateValue
(
ni
)
)
;
}
size_t
sizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
static
size_t
offsetOfIteratorSlot
(
)
{
return
getFixedSlotOffset
(
IteratorSlot
)
;
}
private
:
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
}
;
class
ArrayIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
ArrayIteratorObject
*
NewArrayIteratorTemplate
(
JSContext
*
cx
)
;
ArrayIteratorObject
*
NewArrayIterator
(
JSContext
*
cx
)
;
class
StringIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
StringIteratorObject
*
NewStringIteratorTemplate
(
JSContext
*
cx
)
;
StringIteratorObject
*
NewStringIterator
(
JSContext
*
cx
)
;
class
RegExpStringIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
}
;
RegExpStringIteratorObject
*
NewRegExpStringIteratorTemplate
(
JSContext
*
cx
)
;
RegExpStringIteratorObject
*
NewRegExpStringIterator
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
EnumerateProperties
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
props
)
;
PropertyIteratorObject
*
LookupInIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
;
JSObject
*
ValueToIterator
(
JSContext
*
cx
HandleValue
vp
)
;
void
CloseIterator
(
JSObject
*
obj
)
;
bool
IteratorCloseForException
(
JSContext
*
cx
HandleObject
obj
)
;
void
UnwindIteratorForUncatchableException
(
JSObject
*
obj
)
;
extern
bool
SuppressDeletedProperty
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
extern
bool
SuppressDeletedElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
)
;
#
ifdef
DEBUG
extern
void
AssertDenseElementsNotIterated
(
NativeObject
*
obj
)
;
#
else
inline
void
AssertDenseElementsNotIterated
(
NativeObject
*
obj
)
{
}
#
endif
inline
Value
IteratorMore
(
JSObject
*
iterobj
)
{
NativeIterator
*
ni
=
iterobj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
;
return
ni
-
>
nextIteratedValueAndAdvance
(
)
;
}
extern
PlainObject
*
CreateIterResultObject
(
JSContext
*
cx
HandleValue
value
bool
done
)
;
class
IteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
}
;
class
WrapForValidIteratorObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
IteratedSlot
SlotCount
}
;
static_assert
(
IteratedSlot
=
=
ITERATED_SLOT
"
IteratedSlot
must
match
self
-
hosting
define
for
iterated
object
slot
.
"
)
;
}
;
WrapForValidIteratorObject
*
NewWrapForValidIterator
(
JSContext
*
cx
)
;
class
IteratorHelperObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
GeneratorSlot
SlotCount
}
;
static_assert
(
GeneratorSlot
=
=
ITERATOR_HELPER_GENERATOR_SLOT
"
GeneratorSlot
must
match
self
-
hosting
define
for
generator
"
"
object
slot
.
"
)
;
}
;
IteratorHelperObject
*
NewIteratorHelper
(
JSContext
*
cx
)
;
}
#
endif
