#
ifndef
vm_OffThreadPromiseRuntimeState_h
#
define
vm_OffThreadPromiseRuntimeState_h
#
include
<
stddef
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
ds
/
Fifo
.
h
"
#
include
"
ds
/
PriorityQueue
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
struct
JS_PUBLIC_API
JSContext
;
struct
JS_PUBLIC_API
JSRuntime
;
namespace
js
{
class
AutoLockHelperThreadState
;
class
OffThreadPromiseRuntimeState
;
class
OffThreadPromiseTask
:
public
JS
:
:
Dispatchable
{
friend
class
OffThreadPromiseRuntimeState
;
JSRuntime
*
runtime_
;
JS
:
:
PersistentRooted
<
PromiseObject
*
>
promise_
;
bool
registered_
;
bool
cancellable_
;
void
operator
=
(
const
OffThreadPromiseTask
&
)
=
delete
;
OffThreadPromiseTask
(
const
OffThreadPromiseTask
&
)
=
delete
;
void
unregister
(
OffThreadPromiseRuntimeState
&
state
)
;
protected
:
OffThreadPromiseTask
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
)
;
virtual
bool
resolve
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
)
{
MOZ_CRASH
(
"
Tasks
should
override
resolve
"
)
;
}
;
void
run
(
JSContext
*
cx
MaybeShuttingDown
maybeShuttingDown
)
final
;
void
transferToRuntime
(
)
final
;
virtual
void
prepareForCancel
(
)
{
MOZ_CRASH
(
"
Undispatched
tasks
should
override
prepareForCancel
"
)
;
}
public
:
~
OffThreadPromiseTask
(
)
override
;
static
void
DestroyUndispatchedTask
(
OffThreadPromiseTask
*
task
)
;
JSRuntime
*
runtime
(
)
{
return
runtime_
;
}
bool
init
(
JSContext
*
cx
)
;
bool
init
(
JSContext
*
cx
const
AutoLockHelperThreadState
&
lock
)
;
bool
initCancellable
(
JSContext
*
cx
)
;
bool
initCancellable
(
JSContext
*
cx
const
AutoLockHelperThreadState
&
lock
)
;
void
dispatchResolveAndDestroy
(
)
;
void
dispatchResolveAndDestroy
(
const
AutoLockHelperThreadState
&
lock
)
;
static
void
DispatchResolveAndDestroy
(
js
:
:
UniquePtr
<
OffThreadPromiseTask
>
&
&
task
)
;
static
void
DispatchResolveAndDestroy
(
js
:
:
UniquePtr
<
OffThreadPromiseTask
>
&
&
task
const
AutoLockHelperThreadState
&
lock
)
;
}
;
using
OffThreadPromiseTaskSet
=
HashSet
<
OffThreadPromiseTask
*
DefaultHasher
<
OffThreadPromiseTask
*
>
SystemAllocPolicy
>
;
using
DispatchableFifo
=
Fifo
<
js
:
:
UniquePtr
<
JS
:
:
Dispatchable
>
0
SystemAllocPolicy
>
;
class
OffThreadPromiseRuntimeState
{
friend
class
OffThreadPromiseTask
;
JS
:
:
DispatchToEventLoopCallback
dispatchToEventLoopCallback_
;
void
*
dispatchToEventLoopClosure_
;
HelperThreadLockData
<
OffThreadPromiseTaskSet
>
live_
;
HelperThreadLockData
<
ConditionVariable
>
allFailed_
;
HelperThreadLockData
<
size_t
>
numFailed_
;
HelperThreadLockData
<
size_t
>
numCancellable_
;
HelperThreadLockData
<
DispatchableFifo
>
internalDispatchQueue_
;
HelperThreadLockData
<
ConditionVariable
>
internalDispatchQueueAppended_
;
HelperThreadLockData
<
bool
>
internalDispatchQueueClosed_
;
OffThreadPromiseTaskSet
&
live
(
)
{
return
live_
.
ref
(
)
;
}
ConditionVariable
&
allFailed
(
)
{
return
allFailed_
.
ref
(
)
;
}
DispatchableFifo
&
internalDispatchQueue
(
)
{
return
internalDispatchQueue_
.
ref
(
)
;
}
ConditionVariable
&
internalDispatchQueueAppended
(
)
{
return
internalDispatchQueueAppended_
.
ref
(
)
;
}
static
bool
internalDispatchToEventLoop
(
void
*
js
:
:
UniquePtr
<
JS
:
:
Dispatchable
>
&
&
)
;
bool
usingInternalDispatchQueue
(
)
const
;
void
operator
=
(
const
OffThreadPromiseRuntimeState
&
)
=
delete
;
OffThreadPromiseRuntimeState
(
const
OffThreadPromiseRuntimeState
&
)
=
delete
;
public
:
OffThreadPromiseRuntimeState
(
)
;
~
OffThreadPromiseRuntimeState
(
)
;
void
init
(
JS
:
:
DispatchToEventLoopCallback
callback
void
*
closure
)
;
void
initInternalDispatchQueue
(
)
;
bool
initialized
(
)
const
;
void
internalDrain
(
JSContext
*
cx
)
;
bool
internalHasPending
(
)
;
bool
internalHasPending
(
AutoLockHelperThreadState
&
lock
)
;
void
stealFailedTask
(
JS
:
:
Dispatchable
*
dispatchable
)
;
void
shutdown
(
JSContext
*
cx
)
;
}
;
}
#
endif
