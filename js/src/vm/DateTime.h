#
ifndef
vm_DateTime_h
#
define
vm_DateTime_h
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
stdint
.
h
>
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
if
JS_HAS_INTL_API
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
TimeZone
.
h
"
#
endif
namespace
js
{
constexpr
double
HoursPerDay
=
24
;
constexpr
double
MinutesPerHour
=
60
;
constexpr
double
SecondsPerMinute
=
60
;
constexpr
double
msPerSecond
=
1000
;
constexpr
double
msPerMinute
=
msPerSecond
*
SecondsPerMinute
;
constexpr
double
msPerHour
=
msPerMinute
*
MinutesPerHour
;
constexpr
double
msPerDay
=
msPerHour
*
HoursPerDay
;
constexpr
unsigned
SecondsPerHour
=
60
*
60
;
constexpr
unsigned
SecondsPerDay
=
SecondsPerHour
*
24
;
constexpr
double
StartOfTime
=
-
8
.
64e15
;
constexpr
double
EndOfTime
=
8
.
64e15
;
extern
bool
InitDateTimeState
(
)
;
extern
void
FinishDateTimeState
(
)
;
enum
class
ResetTimeZoneMode
:
bool
{
DontResetIfOffsetUnchanged
ResetEvenIfOffsetUnchanged
}
;
extern
void
ResetTimeZoneInternal
(
ResetTimeZoneMode
mode
)
;
class
DateTimeInfo
{
static
ExclusiveData
<
DateTimeInfo
>
*
instance
;
friend
class
ExclusiveData
<
DateTimeInfo
>
;
friend
bool
InitDateTimeState
(
)
;
friend
void
FinishDateTimeState
(
)
;
DateTimeInfo
(
)
;
~
DateTimeInfo
(
)
;
static
auto
acquireLockWithValidTimeZone
(
)
{
auto
guard
=
instance
-
>
lock
(
)
;
if
(
guard
-
>
timeZoneStatus_
!
=
TimeZoneStatus
:
:
Valid
)
{
guard
-
>
updateTimeZone
(
)
;
}
return
guard
;
}
public
:
static
int32_t
getDSTOffsetMilliseconds
(
int64_t
utcMilliseconds
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
internalGetDSTOffsetMilliseconds
(
utcMilliseconds
)
;
}
static
int32_t
utcToLocalStandardOffsetSeconds
(
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
utcToLocalStandardOffsetSeconds_
;
}
#
if
JS_HAS_INTL_API
enum
class
TimeZoneOffset
{
UTC
Local
}
;
static
int32_t
getOffsetMilliseconds
(
int64_t
milliseconds
TimeZoneOffset
offset
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
internalGetOffsetMilliseconds
(
milliseconds
offset
)
;
}
static
bool
timeZoneDisplayName
(
char16_t
*
buf
size_t
buflen
int64_t
utcMilliseconds
const
char
*
locale
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
internalTimeZoneDisplayName
(
buf
buflen
utcMilliseconds
locale
)
;
}
template
<
typename
B
>
static
mozilla
:
:
intl
:
:
ICUResult
timeZoneId
(
B
&
buffer
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
timeZone
(
)
-
>
GetId
(
buffer
)
;
}
static
mozilla
:
:
Result
<
int32_t
mozilla
:
:
intl
:
:
ICUError
>
getRawOffsetMs
(
)
{
auto
guard
=
acquireLockWithValidTimeZone
(
)
;
return
guard
-
>
timeZone
(
)
-
>
GetRawOffsetMs
(
)
;
}
#
else
static
int32_t
localTZA
(
)
{
return
utcToLocalStandardOffsetSeconds
(
)
*
msPerSecond
;
}
#
endif
private
:
friend
void
js
:
:
ResetTimeZoneInternal
(
ResetTimeZoneMode
)
;
static
void
resetTimeZone
(
ResetTimeZoneMode
mode
)
{
auto
guard
=
instance
-
>
lock
(
)
;
guard
-
>
internalResetTimeZone
(
mode
)
;
}
struct
RangeCache
{
int64_t
startSeconds
endSeconds
;
int64_t
oldStartSeconds
oldEndSeconds
;
int32_t
offsetMilliseconds
;
int32_t
oldOffsetMilliseconds
;
void
reset
(
)
;
void
sanityCheck
(
)
;
}
;
enum
class
TimeZoneStatus
:
uint8_t
{
Valid
NeedsUpdate
UpdateIfChanged
}
;
TimeZoneStatus
timeZoneStatus_
;
int32_t
utcToLocalStandardOffsetSeconds_
;
RangeCache
dstRange_
;
#
if
JS_HAS_INTL_API
static
constexpr
int64_t
MinTimeT
=
static_cast
<
int64_t
>
(
StartOfTime
/
msPerSecond
)
;
static
constexpr
int64_t
MaxTimeT
=
static_cast
<
int64_t
>
(
EndOfTime
/
msPerSecond
)
;
RangeCache
utcRange_
;
RangeCache
localRange_
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
intl
:
:
TimeZone
>
timeZone_
;
JS
:
:
UniqueChars
locale_
;
JS
:
:
UniqueTwoByteChars
standardName_
;
JS
:
:
UniqueTwoByteChars
daylightSavingsName_
;
#
else
static
constexpr
int64_t
MinTimeT
=
0
;
static
constexpr
int64_t
MaxTimeT
=
2145830400
;
#
endif
static
constexpr
int64_t
RangeExpansionAmount
=
30
*
SecondsPerDay
;
void
internalResetTimeZone
(
ResetTimeZoneMode
mode
)
;
void
updateTimeZone
(
)
;
void
internalResyncICUDefaultTimeZone
(
)
;
int64_t
toClampedSeconds
(
int64_t
milliseconds
)
;
using
ComputeFn
=
int32_t
(
DateTimeInfo
:
:
*
)
(
int64_t
)
;
int32_t
getOrComputeValue
(
RangeCache
&
range
int64_t
seconds
ComputeFn
compute
)
;
int32_t
computeDSTOffsetMilliseconds
(
int64_t
utcSeconds
)
;
int32_t
internalGetDSTOffsetMilliseconds
(
int64_t
utcMilliseconds
)
;
#
if
JS_HAS_INTL_API
int32_t
computeUTCOffsetMilliseconds
(
int64_t
localSeconds
)
;
int32_t
computeLocalOffsetMilliseconds
(
int64_t
utcSeconds
)
;
int32_t
internalGetOffsetMilliseconds
(
int64_t
milliseconds
TimeZoneOffset
offset
)
;
bool
internalTimeZoneDisplayName
(
char16_t
*
buf
size_t
buflen
int64_t
utcMilliseconds
const
char
*
locale
)
;
mozilla
:
:
intl
:
:
TimeZone
*
timeZone
(
)
;
#
endif
}
;
}
#
endif
