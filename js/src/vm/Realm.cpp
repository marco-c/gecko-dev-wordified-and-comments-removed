#
include
"
vm
/
Realm
-
inl
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jsfriendapi
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
jit
/
JitRealm
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
vm
/
JSAtom
-
inl
.
h
"
#
include
"
vm
/
JSFunction
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
PodArrayZero
;
Compartment
:
:
Compartment
(
Zone
*
zone
)
:
zone_
(
zone
)
runtime_
(
zone
-
>
runtimeFromAnyThread
(
)
)
{
}
ObjectRealm
:
:
ObjectRealm
(
JS
:
:
Zone
*
zone
)
:
innerViews
(
zone
)
{
}
ObjectRealm
:
:
~
ObjectRealm
(
)
{
MOZ_ASSERT
(
enumerators
=
=
iteratorSentinel_
.
get
(
)
)
;
}
Realm
:
:
Realm
(
Compartment
*
comp
const
JS
:
:
RealmOptions
&
options
)
:
JS
:
:
shadow
:
:
Realm
(
comp
)
zone_
(
comp
-
>
zone
(
)
)
runtime_
(
comp
-
>
runtimeFromMainThread
(
)
)
creationOptions_
(
options
.
creationOptions
(
)
)
behaviors_
(
options
.
behaviors
(
)
)
global_
(
nullptr
)
objects_
(
zone_
)
randomKeyGenerator_
(
runtime_
-
>
forkRandomKeyGenerator
(
)
)
wasm
(
runtime_
)
performanceMonitoring
(
runtime_
)
{
MOZ_ASSERT_IF
(
creationOptions_
.
mergeable
(
)
creationOptions_
.
invisibleToDebugger
(
)
)
;
runtime_
-
>
numRealms
+
+
;
}
Realm
:
:
~
Realm
(
)
{
MOZ_ASSERT
(
!
hasBeenEnteredIgnoringJit
(
)
)
;
JSRuntime
*
rt
=
runtimeFromMainThread
(
)
;
if
(
rt
-
>
lcovOutput
(
)
.
isEnabled
(
)
)
rt
-
>
lcovOutput
(
)
.
writeLCovResult
(
lcovOutput
)
;
#
ifdef
DEBUG
if
(
!
runtime_
-
>
gc
.
shutdownCollectedEverything
(
)
)
objectGroups_
.
unboxedLayouts
.
clear
(
)
;
#
endif
MOZ_ASSERT
(
runtime_
-
>
numRealms
>
0
)
;
runtime_
-
>
numRealms
-
-
;
}
bool
Compartment
:
:
init
(
JSContext
*
cx
)
{
if
(
!
crossCompartmentWrappers
.
init
(
0
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
ObjectRealm
:
:
init
(
JSContext
*
cx
)
{
if
(
!
iteratorCache
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
NativeIteratorSentinel
sentinel
(
NativeIterator
:
:
allocateSentinel
(
cx
)
)
;
if
(
!
sentinel
)
return
false
;
iteratorSentinel_
=
std
:
:
move
(
sentinel
)
;
enumerators
=
iteratorSentinel_
.
get
(
)
;
return
true
;
}
bool
Realm
:
:
init
(
JSContext
*
cx
)
{
JS
:
:
ResetTimeZone
(
)
;
if
(
!
objects_
.
init
(
cx
)
)
return
false
;
if
(
!
savedStacks_
.
init
(
)
|
|
!
varNames_
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
jit
:
:
JitRuntime
*
JSRuntime
:
:
createJitRuntime
(
JSContext
*
cx
)
{
AutoLockForExclusiveAccess
atomsLock
(
cx
)
;
MOZ_ASSERT
(
!
jitRuntime_
)
;
if
(
!
CanLikelyAllocateMoreExecutableMemory
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
jit
:
:
JitRuntime
*
jrt
=
cx
-
>
new_
<
jit
:
:
JitRuntime
>
(
)
;
if
(
!
jrt
)
return
nullptr
;
jitRuntime_
=
jrt
;
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
jitRuntime_
-
>
initialize
(
cx
atomsLock
)
)
{
noOOM
.
crash
(
"
OOM
in
createJitRuntime
"
)
;
}
return
jitRuntime_
;
}
bool
Realm
:
:
ensureJitRealmExists
(
JSContext
*
cx
)
{
using
namespace
js
:
:
jit
;
if
(
jitRealm_
)
return
true
;
if
(
!
zone
(
)
-
>
getJitZone
(
cx
)
)
return
false
;
UniquePtr
<
JitRealm
>
jitRealm
=
cx
-
>
make_unique
<
JitRealm
>
(
)
;
if
(
!
jitRealm
)
return
false
;
if
(
!
jitRealm
-
>
initialize
(
cx
)
)
return
false
;
jitRealm_
=
std
:
:
move
(
jitRealm
)
;
return
true
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
js
:
:
DtoaCache
:
:
checkCacheAfterMovingGC
(
)
{
MOZ_ASSERT
(
!
s
|
|
!
IsForwarded
(
s
)
)
;
}
namespace
{
struct
CheckGCThingAfterMovingGCFunctor
{
template
<
class
T
>
void
operator
(
)
(
T
*
t
)
{
CheckGCThingAfterMovingGC
(
*
t
)
;
}
}
;
}
void
Compartment
:
:
checkWrapperMapAfterMovingGC
(
)
{
for
(
WrapperMap
:
:
Enum
e
(
crossCompartmentWrappers
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
e
.
front
(
)
.
mutableKey
(
)
.
applyToWrapped
(
CheckGCThingAfterMovingGCFunctor
(
)
)
;
e
.
front
(
)
.
mutableKey
(
)
.
applyToDebugger
(
CheckGCThingAfterMovingGCFunctor
(
)
)
;
WrapperMap
:
:
Ptr
ptr
=
crossCompartmentWrappers
.
lookup
(
e
.
front
(
)
.
key
(
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
bool
Compartment
:
:
putWrapper
(
JSContext
*
cx
const
CrossCompartmentKey
&
wrapped
const
js
:
:
Value
&
wrapper
)
{
MOZ_ASSERT
(
wrapped
.
is
<
JSString
*
>
(
)
=
=
wrapper
.
isString
(
)
)
;
MOZ_ASSERT_IF
(
!
wrapped
.
is
<
JSString
*
>
(
)
wrapper
.
isObject
(
)
)
;
if
(
!
crossCompartmentWrappers
.
put
(
wrapped
wrapper
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
static
JSString
*
CopyStringPure
(
JSContext
*
cx
JSString
*
str
)
{
size_t
len
=
str
-
>
length
(
)
;
JSString
*
copy
;
if
(
str
-
>
isLinear
(
)
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyN
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
len
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyNDontDeflate
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
len
)
;
}
if
(
copy
)
return
copy
;
AutoStableStringChars
chars
(
cx
)
;
if
(
!
chars
.
init
(
cx
str
)
)
return
nullptr
;
return
chars
.
isLatin1
(
)
?
NewStringCopyN
<
CanGC
>
(
cx
chars
.
latin1Range
(
)
.
begin
(
)
.
get
(
)
len
)
:
NewStringCopyNDontDeflate
<
CanGC
>
(
cx
chars
.
twoByteRange
(
)
.
begin
(
)
.
get
(
)
len
)
;
}
if
(
str
-
>
hasLatin1Chars
(
)
)
{
ScopedJSFreePtr
<
Latin1Char
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyLatin1CharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewString
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
ScopedJSFreePtr
<
char16_t
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyTwoByteCharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewStringDontDeflate
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleString
strp
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
JSString
*
str
=
strp
;
if
(
str
-
>
zoneFromAnyThread
(
)
=
=
zone
(
)
)
return
true
;
if
(
str
-
>
isAtom
(
)
)
{
cx
-
>
markAtom
(
&
str
-
>
asAtom
(
)
)
;
return
true
;
}
RootedValue
key
(
cx
StringValue
(
str
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
strp
.
set
(
p
-
>
value
(
)
.
get
(
)
.
toString
(
)
)
;
return
true
;
}
JSString
*
copy
=
CopyStringPure
(
cx
str
)
;
if
(
!
copy
)
return
false
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
StringValue
(
copy
)
)
)
return
false
;
strp
.
set
(
copy
)
;
return
true
;
}
#
ifdef
ENABLE_BIGINT
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleBigInt
bi
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
bi
-
>
zone
(
)
=
=
cx
-
>
zone
(
)
)
return
true
;
BigInt
*
copy
=
BigInt
:
:
copy
(
cx
bi
)
;
if
(
!
copy
)
return
false
;
bi
.
set
(
copy
)
;
return
true
;
}
#
endif
bool
Compartment
:
:
getNonWrapperObjectForCurrentCompartment
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
global
(
)
)
;
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
cx
-
>
global
(
)
)
)
;
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
&
obj
-
>
global
(
)
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
obj
.
set
(
ToWindowProxyIfWindow
(
obj
)
)
;
return
true
;
}
RootedObject
objectPassedToWrap
(
cx
obj
)
;
obj
.
set
(
UncheckedUnwrap
(
obj
true
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
auto
preWrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
preWrap
;
if
(
!
CheckSystemRecursionLimit
(
cx
)
)
return
false
;
if
(
preWrap
)
{
preWrap
(
cx
cx
-
>
global
(
)
obj
objectPassedToWrap
obj
)
;
if
(
!
obj
)
return
false
;
}
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
bool
Compartment
:
:
getOrCreateWrapper
(
JSContext
*
cx
HandleObject
existing
MutableHandleObject
obj
)
{
RootedValue
key
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
obj
.
set
(
&
p
-
>
value
(
)
.
get
(
)
.
toObject
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
return
true
;
}
ExposeObjectToActiveJS
(
obj
)
;
auto
wrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
wrap
;
RootedObject
wrapper
(
cx
wrap
(
cx
existing
obj
)
)
;
if
(
!
wrapper
)
return
false
;
MOZ_ASSERT
(
Wrapper
:
:
wrappedObject
(
wrapper
)
=
=
&
key
.
get
(
)
.
toObject
(
)
)
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
ObjectValue
(
*
wrapper
)
)
)
{
if
(
wrapper
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
NukeCrossCompartmentWrapper
(
cx
wrapper
)
;
return
false
;
}
obj
.
set
(
wrapper
)
;
return
true
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
!
obj
)
return
true
;
AutoDisableProxyCheck
adpc
;
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
obj
)
)
return
false
;
if
(
obj
-
>
compartment
(
)
!
=
this
)
{
if
(
!
getOrCreateWrapper
(
cx
nullptr
obj
)
)
return
false
;
}
ExposeObjectToActiveJS
(
obj
)
;
return
true
;
}
bool
Compartment
:
:
rewrap
(
JSContext
*
cx
MutableHandleObject
obj
HandleObject
existingArg
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
existingArg
)
;
MOZ_ASSERT
(
existingArg
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
IsDeadProxyObject
(
existingArg
)
)
;
AutoDisableProxyCheck
adpc
;
RootedObject
existing
(
cx
existingArg
)
;
if
(
existing
-
>
hasStaticPrototype
(
)
|
|
existing
-
>
isCallable
(
)
|
|
obj
-
>
isCallable
(
)
)
{
existing
.
set
(
nullptr
)
;
}
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
obj
)
)
return
false
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
return
true
;
return
getOrCreateWrapper
(
cx
existing
obj
)
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
PropertyDescriptor
>
desc
)
{
if
(
!
wrap
(
cx
desc
.
object
(
)
)
)
return
false
;
if
(
desc
.
hasGetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
getterObject
(
)
)
)
return
false
;
}
if
(
desc
.
hasSetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
setterObject
(
)
)
)
return
false
;
}
return
wrap
(
cx
desc
.
value
(
)
)
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
vec
)
{
for
(
size_t
i
=
0
;
i
<
vec
.
length
(
)
;
+
+
i
)
{
if
(
!
wrap
(
cx
vec
[
i
]
)
)
return
false
;
}
return
true
;
}
LexicalEnvironmentObject
*
ObjectRealm
:
:
getOrCreateNonSyntacticLexicalEnvironment
(
JSContext
*
cx
HandleObject
enclosing
)
{
MOZ_ASSERT
(
&
ObjectRealm
:
:
get
(
enclosing
)
=
=
this
)
;
if
(
!
nonSyntacticLexicalEnvironments_
)
{
auto
map
=
cx
-
>
make_unique
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
map
|
|
!
map
-
>
init
(
)
)
return
nullptr
;
nonSyntacticLexicalEnvironments_
=
std
:
:
move
(
map
)
;
}
RootedObject
key
(
cx
enclosing
)
;
if
(
enclosing
-
>
is
<
WithEnvironmentObject
>
(
)
)
{
MOZ_ASSERT
(
!
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
isSyntactic
(
)
)
;
key
=
&
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
object
(
)
;
}
RootedObject
lexicalEnv
(
cx
nonSyntacticLexicalEnvironments_
-
>
lookup
(
key
)
)
;
if
(
!
lexicalEnv
)
{
MOZ_ASSERT
(
key
-
>
is
<
NonSyntacticVariablesObject
>
(
)
|
|
!
key
-
>
is
<
EnvironmentObject
>
(
)
)
;
lexicalEnv
=
LexicalEnvironmentObject
:
:
createNonSyntactic
(
cx
enclosing
key
)
;
if
(
!
lexicalEnv
)
return
nullptr
;
if
(
!
nonSyntacticLexicalEnvironments_
-
>
add
(
cx
key
lexicalEnv
)
)
return
nullptr
;
}
return
&
lexicalEnv
-
>
as
<
LexicalEnvironmentObject
>
(
)
;
}
LexicalEnvironmentObject
*
ObjectRealm
:
:
getNonSyntacticLexicalEnvironment
(
JSObject
*
enclosing
)
const
{
MOZ_ASSERT
(
&
ObjectRealm
:
:
get
(
enclosing
)
=
=
this
)
;
if
(
!
nonSyntacticLexicalEnvironments_
)
return
nullptr
;
JSObject
*
key
=
enclosing
;
if
(
enclosing
-
>
is
<
WithEnvironmentObject
>
(
)
)
{
MOZ_ASSERT
(
!
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
isSyntactic
(
)
)
;
key
=
&
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
object
(
)
;
}
JSObject
*
lexicalEnv
=
nonSyntacticLexicalEnvironments_
-
>
lookup
(
key
)
;
if
(
!
lexicalEnv
)
return
nullptr
;
return
&
lexicalEnv
-
>
as
<
LexicalEnvironmentObject
>
(
)
;
}
bool
Realm
:
:
addToVarNames
(
JSContext
*
cx
JS
:
:
Handle
<
JSAtom
*
>
name
)
{
MOZ_ASSERT
(
name
)
;
if
(
varNames_
.
put
(
name
)
)
return
true
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
void
Compartment
:
:
traceOutgoingCrossCompartmentWrappers
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
JS
:
:
CurrentThreadIsHeapMajorCollecting
(
)
)
;
MOZ_ASSERT
(
!
zone
(
)
-
>
isCollectingFromAnyThread
(
)
|
|
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
NonStringWrapperEnum
e
(
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
e
.
front
(
)
.
key
(
)
.
is
<
JSObject
*
>
(
)
)
{
Value
v
=
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
;
ProxyObject
*
wrapper
=
&
v
.
toObject
(
)
.
as
<
ProxyObject
>
(
)
;
ProxyObject
:
:
traceEdgeToTarget
(
trc
wrapper
)
;
}
}
}
void
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
)
{
gcstats
:
:
AutoPhase
ap
(
trc
-
>
runtime
(
)
-
>
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_CCWS
)
;
MOZ_ASSERT
(
JS
:
:
CurrentThreadIsHeapMajorCollecting
(
)
)
;
for
(
CompartmentsIter
c
(
trc
-
>
runtime
(
)
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
!
c
-
>
zone
(
)
-
>
isCollecting
(
)
)
c
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
Debugger
:
:
traceIncomingCrossCompartmentEdges
(
trc
)
;
}
void
Realm
:
:
traceGlobal
(
JSTracer
*
trc
)
{
savedStacks_
.
trace
(
trc
)
;
if
(
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
varNames_
.
trace
(
trc
)
;
}
void
ObjectRealm
:
:
trace
(
JSTracer
*
trc
)
{
if
(
lazyArrayBuffers
)
lazyArrayBuffers
-
>
trace
(
trc
)
;
if
(
objectMetadataTable
)
objectMetadataTable
-
>
trace
(
trc
)
;
if
(
nonSyntacticLexicalEnvironments_
)
nonSyntacticLexicalEnvironments_
-
>
trace
(
trc
)
;
}
void
Realm
:
:
traceRoots
(
JSTracer
*
trc
js
:
:
gc
:
:
GCRuntime
:
:
TraceOrMarkRuntime
traceOrMark
)
{
if
(
objectMetadataState_
.
is
<
PendingMetadata
>
(
)
)
{
TraceRoot
(
trc
&
objectMetadataState_
.
as
<
PendingMetadata
>
(
)
"
on
-
stack
object
pending
metadata
"
)
;
}
if
(
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
{
if
(
shouldTraceGlobal
(
)
&
&
global_
.
unbarrieredGet
(
)
)
TraceRoot
(
trc
global_
.
unsafeUnbarrieredForTracing
(
)
"
on
-
stack
compartment
global
"
)
;
}
if
(
traceOrMark
=
=
js
:
:
gc
:
:
GCRuntime
:
:
MarkRuntime
&
&
!
zone
(
)
-
>
isCollectingFromAnyThread
(
)
)
return
;
if
(
debugEnvs_
)
debugEnvs_
-
>
trace
(
trc
)
;
objects_
.
trace
(
trc
)
;
if
(
scriptCountsMap
&
&
trc
-
>
runtime
(
)
-
>
profilingScripts
&
&
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
{
MOZ_ASSERT_IF
(
!
trc
-
>
runtime
(
)
-
>
isBeingDestroyed
(
)
collectCoverage
(
)
)
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
const_cast
<
JSScript
*
>
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
script
-
>
hasScriptCounts
(
)
)
;
TraceRoot
(
trc
&
script
"
profilingScripts
"
)
;
MOZ_ASSERT
(
script
=
=
r
.
front
(
)
.
key
(
)
"
const_cast
is
only
a
work
-
around
"
)
;
}
}
}
void
ObjectRealm
:
:
finishRoots
(
)
{
if
(
lazyArrayBuffers
)
lazyArrayBuffers
-
>
clear
(
)
;
if
(
objectMetadataTable
)
objectMetadataTable
-
>
clear
(
)
;
if
(
nonSyntacticLexicalEnvironments_
)
nonSyntacticLexicalEnvironments_
-
>
clear
(
)
;
}
void
Realm
:
:
finishRoots
(
)
{
if
(
debugEnvs_
)
debugEnvs_
-
>
finish
(
)
;
objects_
.
finishRoots
(
)
;
clearScriptCounts
(
)
;
clearScriptNames
(
)
;
}
void
ObjectRealm
:
:
sweepAfterMinorGC
(
)
{
InnerViewTable
&
table
=
innerViews
.
get
(
)
;
if
(
table
.
needsSweepAfterMinorGC
(
)
)
table
.
sweepAfterMinorGC
(
)
;
}
void
Realm
:
:
sweepAfterMinorGC
(
)
{
globalWriteBarriered
=
0
;
dtoaCache
.
purge
(
)
;
objects_
.
sweepAfterMinorGC
(
)
;
}
void
Compartment
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
crossCompartmentWrappers
.
sweepAfterMinorGC
(
trc
)
;
for
(
RealmsInCompartmentIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
r
-
>
sweepAfterMinorGC
(
)
;
}
void
Realm
:
:
sweepSavedStacks
(
)
{
savedStacks_
.
sweep
(
)
;
}
void
Realm
:
:
sweepGlobalObject
(
)
{
if
(
global_
&
&
IsAboutToBeFinalized
(
&
global_
)
)
global_
.
set
(
nullptr
)
;
}
void
Realm
:
:
sweepSelfHostingScriptSource
(
)
{
if
(
selfHostingScriptSource
.
unbarrieredGet
(
)
&
&
IsAboutToBeFinalized
(
&
selfHostingScriptSource
)
)
{
selfHostingScriptSource
.
set
(
nullptr
)
;
}
}
void
Realm
:
:
sweepJitRealm
(
)
{
if
(
jitRealm_
)
jitRealm_
-
>
sweep
(
this
)
;
}
void
Realm
:
:
sweepRegExps
(
)
{
regExps
.
sweep
(
)
;
}
void
Realm
:
:
sweepDebugEnvironments
(
)
{
if
(
debugEnvs_
)
debugEnvs_
-
>
sweep
(
)
;
}
void
ObjectRealm
:
:
sweepNativeIterators
(
)
{
NativeIterator
*
ni
=
enumerators
-
>
next
(
)
;
while
(
ni
!
=
enumerators
)
{
JSObject
*
iterObj
=
ni
-
>
iterObj
(
)
;
NativeIterator
*
next
=
ni
-
>
next
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
iterObj
)
)
ni
-
>
unlink
(
)
;
MOZ_ASSERT_IF
(
ni
-
>
objectBeingIterated
(
)
&
ObjectRealm
:
:
get
(
ni
-
>
objectBeingIterated
(
)
)
=
=
this
)
;
ni
=
next
;
}
}
void
Realm
:
:
sweepObjectRealm
(
)
{
objects_
.
sweepNativeIterators
(
)
;
}
void
Compartment
:
:
sweepCrossCompartmentWrappers
(
)
{
crossCompartmentWrappers
.
sweep
(
)
;
}
void
Realm
:
:
sweepVarNames
(
)
{
varNames_
.
sweep
(
)
;
}
namespace
{
struct
TraceRootFunctor
{
JSTracer
*
trc
;
const
char
*
name
;
TraceRootFunctor
(
JSTracer
*
trc
const
char
*
name
)
:
trc
(
trc
)
name
(
name
)
{
}
template
<
class
T
>
void
operator
(
)
(
T
*
t
)
{
return
TraceRoot
(
trc
t
name
)
;
}
}
;
struct
NeedsSweepUnbarrieredFunctor
{
template
<
class
T
>
bool
operator
(
)
(
T
*
t
)
const
{
return
IsAboutToBeFinalizedUnbarriered
(
t
)
;
}
}
;
}
void
CrossCompartmentKey
:
:
trace
(
JSTracer
*
trc
)
{
applyToWrapped
(
TraceRootFunctor
(
trc
"
CrossCompartmentKey
:
:
wrapped
"
)
)
;
applyToDebugger
(
TraceRootFunctor
(
trc
"
CrossCompartmentKey
:
:
debugger
"
)
)
;
}
bool
CrossCompartmentKey
:
:
needsSweep
(
)
{
return
applyToWrapped
(
NeedsSweepUnbarrieredFunctor
(
)
)
|
|
applyToDebugger
(
NeedsSweepUnbarrieredFunctor
(
)
)
;
}
void
Realm
:
:
sweepTemplateObjects
(
)
{
if
(
mappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
mappedArgumentsTemplate_
)
)
mappedArgumentsTemplate_
.
set
(
nullptr
)
;
if
(
unmappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
unmappedArgumentsTemplate_
)
)
unmappedArgumentsTemplate_
.
set
(
nullptr
)
;
if
(
iterResultTemplate_
&
&
IsAboutToBeFinalized
(
&
iterResultTemplate_
)
)
iterResultTemplate_
.
set
(
nullptr
)
;
}
void
Compartment
:
:
fixupCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
CompartmentsIter
comp
(
trc
-
>
runtime
(
)
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
sweepCrossCompartmentWrappers
(
)
;
comp
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
}
void
Realm
:
:
fixupAfterMovingGC
(
)
{
purge
(
)
;
fixupGlobal
(
)
;
objectGroups_
.
fixupTablesAfterMovingGC
(
)
;
fixupScriptMapsAfterMovingGC
(
)
;
}
void
Compartment
:
:
fixupAfterMovingGC
(
)
{
MOZ_ASSERT
(
zone
(
)
-
>
isGCCompacting
(
)
)
;
for
(
RealmsInCompartmentIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
r
-
>
fixupAfterMovingGC
(
)
;
sweepCrossCompartmentWrappers
(
)
;
}
void
Realm
:
:
fixupGlobal
(
)
{
GlobalObject
*
global
=
*
global_
.
unsafeGet
(
)
;
if
(
global
)
global_
.
set
(
MaybeForwarded
(
global
)
)
;
}
void
Realm
:
:
fixupScriptMapsAfterMovingGC
(
)
{
if
(
scriptCountsMap
)
{
for
(
ScriptCountsMap
:
:
Enum
e
(
*
scriptCountsMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
!
IsAboutToBeFinalizedUnbarriered
(
&
script
)
&
&
script
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
script
)
;
}
}
if
(
scriptNameMap
)
{
for
(
ScriptNameMap
:
:
Enum
e
(
*
scriptNameMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
!
IsAboutToBeFinalizedUnbarriered
(
&
script
)
&
&
script
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
script
)
;
}
}
if
(
debugScriptMap
)
{
for
(
DebugScriptMap
:
:
Enum
e
(
*
debugScriptMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
!
IsAboutToBeFinalizedUnbarriered
(
&
script
)
&
&
script
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
script
)
;
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Realm
:
:
checkScriptMapsAfterMovingGC
(
)
{
if
(
scriptCountsMap
)
{
for
(
auto
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
realm
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptCountsMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
if
(
scriptNameMap
)
{
for
(
auto
r
=
scriptNameMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
realm
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptNameMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
if
(
debugScriptMap
)
{
for
(
auto
r
=
debugScriptMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
realm
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
DebugScript
*
ds
=
r
.
front
(
)
.
value
(
)
.
get
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ds
-
>
numSites
;
i
+
+
)
{
BreakpointSite
*
site
=
ds
-
>
breakpoints
[
i
]
;
if
(
site
&
&
site
-
>
type
(
)
=
=
BreakpointSite
:
:
Type
:
:
JS
)
CheckGCThingAfterMovingGC
(
site
-
>
asJS
(
)
-
>
script
)
;
}
auto
ptr
=
debugScriptMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
}
#
endif
void
Realm
:
:
purge
(
)
{
dtoaCache
.
purge
(
)
;
newProxyCache
.
purge
(
)
;
objectGroups_
.
purge
(
)
;
objects_
.
iteratorCache
.
clearAndShrink
(
)
;
arraySpeciesLookup
.
purge
(
)
;
}
void
Realm
:
:
clearTables
(
)
{
global_
.
set
(
nullptr
)
;
compartment
(
)
-
>
assertNoCrossCompartmentWrappers
(
)
;
MOZ_ASSERT
(
!
jitRealm_
)
;
MOZ_ASSERT
(
!
debugEnvs_
)
;
MOZ_ASSERT
(
objects_
.
enumerators
-
>
next
(
)
=
=
objects_
.
enumerators
)
;
objectGroups_
.
clearTables
(
)
;
if
(
savedStacks_
.
initialized
(
)
)
savedStacks_
.
clear
(
)
;
if
(
varNames_
.
initialized
(
)
)
varNames_
.
clear
(
)
;
}
void
Realm
:
:
setAllocationMetadataBuilder
(
const
js
:
:
AllocationMetadataBuilder
*
builder
)
{
ReleaseAllJITCode
(
runtime_
-
>
defaultFreeOp
(
)
)
;
allocationMetadataBuilder_
=
builder
;
}
void
Realm
:
:
forgetAllocationMetadataBuilder
(
)
{
CancelOffThreadIonCompile
(
this
)
;
allocationMetadataBuilder_
=
nullptr
;
}
void
Realm
:
:
setNewObjectMetadata
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
obj
-
>
realm
(
)
=
=
this
)
;
assertSameCompartment
(
cx
compartment
(
)
obj
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
JSObject
*
metadata
=
allocationMetadataBuilder_
-
>
build
(
cx
obj
oomUnsafe
)
)
{
MOZ_ASSERT
(
metadata
-
>
realm
(
)
=
=
obj
-
>
realm
(
)
)
;
assertSameCompartment
(
cx
metadata
)
;
if
(
!
objects_
.
objectMetadataTable
)
{
auto
table
=
cx
-
>
make_unique
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
table
|
|
!
table
-
>
init
(
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
objects_
.
objectMetadataTable
=
std
:
:
move
(
table
)
;
}
if
(
!
objects_
.
objectMetadataTable
-
>
add
(
cx
obj
metadata
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
}
}
static
bool
AddInnerLazyFunctionsFromScript
(
JSScript
*
script
AutoObjectVector
&
lazyFunctions
)
{
if
(
!
script
-
>
hasObjects
(
)
)
return
true
;
ObjectArray
*
objects
=
script
-
>
objects
(
)
;
for
(
size_t
i
=
0
;
i
<
objects
-
>
length
;
i
+
+
)
{
JSObject
*
obj
=
objects
-
>
vector
[
i
]
;
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
as
<
JSFunction
>
(
)
.
isInterpretedLazy
(
)
)
{
if
(
!
lazyFunctions
.
append
(
obj
)
)
return
false
;
}
}
return
true
;
}
static
bool
AddLazyFunctionsForRealm
(
JSContext
*
cx
AutoObjectVector
&
lazyFunctions
AllocKind
kind
)
{
for
(
auto
i
=
cx
-
>
zone
(
)
-
>
cellIter
<
JSObject
>
(
kind
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSFunction
*
fun
=
&
i
-
>
as
<
JSFunction
>
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
fun
)
|
|
fun
-
>
realm
(
)
!
=
cx
-
>
realm
(
)
)
{
continue
;
}
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
LazyScript
*
lazy
=
fun
-
>
lazyScriptOrNull
(
)
;
if
(
lazy
&
&
!
lazy
-
>
isEnclosingScriptLazy
(
)
&
&
!
lazy
-
>
hasUncompletedEnclosingScript
(
)
)
{
if
(
!
lazyFunctions
.
append
(
fun
)
)
return
false
;
}
}
}
return
true
;
}
static
bool
CreateLazyScriptsForRealm
(
JSContext
*
cx
)
{
AutoObjectVector
lazyFunctions
(
cx
)
;
if
(
!
AddLazyFunctionsForRealm
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION
)
)
return
false
;
if
(
!
AddLazyFunctionsForRealm
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION_EXTENDED
)
)
return
false
;
RootedFunction
fun
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
lazyFunctions
.
length
(
)
;
i
+
+
)
{
fun
=
&
lazyFunctions
[
i
]
-
>
as
<
JSFunction
>
(
)
;
if
(
!
fun
-
>
isInterpretedLazy
(
)
)
continue
;
bool
lazyScriptHadNoScript
=
!
fun
-
>
lazyScript
(
)
-
>
maybeScript
(
)
;
JSScript
*
script
=
JSFunction
:
:
getOrCreateScript
(
cx
fun
)
;
if
(
!
script
)
return
false
;
if
(
lazyScriptHadNoScript
&
&
!
AddInnerLazyFunctionsFromScript
(
script
lazyFunctions
)
)
return
false
;
}
return
true
;
}
bool
Realm
:
:
ensureDelazifyScriptsForDebugger
(
JSContext
*
cx
)
{
AutoRealmUnchecked
ar
(
cx
this
)
;
if
(
needsDelazificationForDebugger
(
)
&
&
!
CreateLazyScriptsForRealm
(
cx
)
)
return
false
;
debugModeBits_
&
=
~
DebuggerNeedsDelazification
;
return
true
;
}
void
Realm
:
:
updateDebuggerObservesFlag
(
unsigned
flag
)
{
MOZ_ASSERT
(
isDebuggee
(
)
)
;
MOZ_ASSERT
(
flag
=
=
DebuggerObservesAllExecution
|
|
flag
=
=
DebuggerObservesCoverage
|
|
flag
=
=
DebuggerObservesAsmJS
|
|
flag
=
=
DebuggerObservesBinarySource
)
;
GlobalObject
*
global
=
zone
(
)
-
>
runtimeFromMainThread
(
)
-
>
gc
.
isForegroundSweeping
(
)
?
unsafeUnbarrieredMaybeGlobal
(
)
:
maybeGlobal
(
)
;
const
GlobalObject
:
:
DebuggerVector
*
v
=
global
-
>
getDebuggers
(
)
;
for
(
auto
p
=
v
-
>
begin
(
)
;
p
!
=
v
-
>
end
(
)
;
p
+
+
)
{
Debugger
*
dbg
=
*
p
;
if
(
flag
=
=
DebuggerObservesAllExecution
?
dbg
-
>
observesAllExecution
(
)
:
flag
=
=
DebuggerObservesCoverage
?
dbg
-
>
observesCoverage
(
)
:
flag
=
=
DebuggerObservesAsmJS
?
dbg
-
>
observesAsmJS
(
)
:
dbg
-
>
observesBinarySource
(
)
)
{
debugModeBits_
|
=
flag
;
return
;
}
}
debugModeBits_
&
=
~
flag
;
}
void
Realm
:
:
unsetIsDebuggee
(
)
{
if
(
isDebuggee
(
)
)
{
debugModeBits_
&
=
~
DebuggerObservesMask
;
DebugEnvironments
:
:
onRealmUnsetIsDebuggee
(
this
)
;
}
}
void
Realm
:
:
updateDebuggerObservesCoverage
(
)
{
bool
previousState
=
debuggerObservesCoverage
(
)
;
updateDebuggerObservesFlag
(
DebuggerObservesCoverage
)
;
if
(
previousState
=
=
debuggerObservesCoverage
(
)
)
return
;
if
(
debuggerObservesCoverage
(
)
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
for
(
ActivationIterator
iter
(
cx
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
iter
-
>
isInterpreter
(
)
)
iter
-
>
asInterpreter
(
)
-
>
enableInterruptsUnconditionally
(
)
;
}
return
;
}
if
(
collectCoverage
(
)
)
return
;
clearScriptCounts
(
)
;
clearScriptNames
(
)
;
}
bool
Realm
:
:
collectCoverage
(
)
const
{
return
collectCoverageForPGO
(
)
|
|
collectCoverageForDebug
(
)
;
}
bool
Realm
:
:
collectCoverageForPGO
(
)
const
{
return
!
JitOptions
.
disablePgo
;
}
bool
Realm
:
:
collectCoverageForDebug
(
)
const
{
return
debuggerObservesCoverage
(
)
|
|
runtimeFromAnyThread
(
)
-
>
profilingScripts
|
|
runtimeFromAnyThread
(
)
-
>
lcovOutput
(
)
.
isEnabled
(
)
;
}
void
Realm
:
:
clearScriptCounts
(
)
{
if
(
!
scriptCountsMap
)
return
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
r
.
front
(
)
.
key
(
)
-
>
clearHasScriptCounts
(
)
;
scriptCountsMap
.
reset
(
)
;
}
void
Realm
:
:
clearScriptNames
(
)
{
scriptNameMap
.
reset
(
)
;
}
void
Realm
:
:
clearBreakpointsIn
(
FreeOp
*
fop
js
:
:
Debugger
*
dbg
HandleObject
handler
)
{
for
(
auto
script
=
zone
(
)
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
script
-
>
realm
(
)
=
=
this
&
&
script
-
>
hasAnyBreakpointsOrStepMode
(
)
)
script
-
>
clearBreakpointsIn
(
fop
dbg
handler
)
;
}
}
void
Compartment
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
compartmentObjects
size_t
*
crossCompartmentWrappersTables
size_t
*
compartmentsPrivateData
)
{
*
compartmentObjects
+
=
mallocSizeOf
(
this
)
;
*
crossCompartmentWrappersTables
+
=
crossCompartmentWrappers
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
auto
callback
=
runtime_
-
>
sizeOfIncludingThisCompartmentCallback
)
*
compartmentsPrivateData
+
=
callback
(
mallocSizeOf
this
)
;
}
void
ObjectRealm
:
:
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
innerViewsArg
size_t
*
lazyArrayBuffersArg
size_t
*
objectMetadataTablesArg
size_t
*
nonSyntacticLexicalEnvironmentsArg
)
{
*
innerViewsArg
+
=
innerViews
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
lazyArrayBuffers
)
*
lazyArrayBuffersArg
+
=
lazyArrayBuffers
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
objectMetadataTable
)
*
objectMetadataTablesArg
+
=
objectMetadataTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
auto
&
map
=
nonSyntacticLexicalEnvironments_
)
*
nonSyntacticLexicalEnvironmentsArg
+
=
map
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
void
Realm
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
tiAllocationSiteTables
size_t
*
tiArrayTypeTables
size_t
*
tiObjectTypeTables
size_t
*
realmObject
size_t
*
realmTables
size_t
*
innerViewsArg
size_t
*
lazyArrayBuffersArg
size_t
*
objectMetadataTablesArg
size_t
*
savedStacksSet
size_t
*
varNamesSet
size_t
*
nonSyntacticLexicalEnvironmentsArg
size_t
*
jitRealm
size_t
*
scriptCountsMapArg
)
{
*
realmObject
+
=
mallocSizeOf
(
this
)
;
objectGroups_
.
addSizeOfExcludingThis
(
mallocSizeOf
tiAllocationSiteTables
tiArrayTypeTables
tiObjectTypeTables
realmTables
)
;
wasm
.
addSizeOfExcludingThis
(
mallocSizeOf
realmTables
)
;
objects_
.
addSizeOfExcludingThis
(
mallocSizeOf
innerViewsArg
lazyArrayBuffersArg
objectMetadataTablesArg
nonSyntacticLexicalEnvironmentsArg
)
;
*
savedStacksSet
+
=
savedStacks_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
varNamesSet
+
=
varNames_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
jitRealm_
)
*
jitRealm
+
=
jitRealm_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
scriptCountsMap
)
{
*
scriptCountsMapArg
+
=
scriptCountsMap
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
auto
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
*
scriptCountsMapArg
+
=
r
.
front
(
)
.
value
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
mozilla
:
:
HashCodeScrambler
Realm
:
:
randomHashCodeScrambler
(
)
{
return
mozilla
:
:
HashCodeScrambler
(
randomKeyGenerator_
.
next
(
)
randomKeyGenerator_
.
next
(
)
)
;
}
AutoSetNewObjectMetadata
:
:
AutoSetNewObjectMetadata
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
CustomAutoRooter
(
cx
)
cx_
(
cx
-
>
helperThread
(
)
?
nullptr
:
cx
)
prevState_
(
cx
-
>
realm
(
)
-
>
objectMetadataState_
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
cx_
)
cx_
-
>
realm
(
)
-
>
objectMetadataState_
=
NewObjectMetadataState
(
DelayMetadata
(
)
)
;
}
AutoSetNewObjectMetadata
:
:
~
AutoSetNewObjectMetadata
(
)
{
if
(
!
cx_
)
return
;
if
(
!
cx_
-
>
isExceptionPending
(
)
&
&
cx_
-
>
realm
(
)
-
>
hasObjectPendingMetadata
(
)
)
{
AutoSuppressGC
autoSuppressGC
(
cx_
)
;
JSObject
*
obj
=
cx_
-
>
realm
(
)
-
>
objectMetadataState_
.
as
<
PendingMetadata
>
(
)
;
cx_
-
>
realm
(
)
-
>
objectMetadataState_
=
prevState_
;
obj
=
SetNewObjectMetadata
(
cx_
obj
)
;
}
else
{
cx_
-
>
realm
(
)
-
>
objectMetadataState_
=
prevState_
;
}
}
JS_PUBLIC_API
(
void
)
gc
:
:
TraceRealm
(
JSTracer
*
trc
JS
:
:
Realm
*
realm
const
char
*
name
)
{
realm
-
>
traceGlobal
(
trc
)
;
}
JS_PUBLIC_API
(
bool
)
gc
:
:
RealmNeedsSweep
(
JS
:
:
Realm
*
realm
)
{
return
realm
-
>
globalIsAboutToBeFinalized
(
)
;
}
JS_PUBLIC_API
(
JS
:
:
Realm
*
)
JS
:
:
GetCurrentRealmOrNull
(
JSContext
*
cx
)
{
return
cx
-
>
realm
(
)
;
}
JS_PUBLIC_API
(
JS
:
:
Realm
*
)
JS
:
:
GetObjectRealmOrNull
(
JSObject
*
obj
)
{
return
IsCrossCompartmentWrapper
(
obj
)
?
nullptr
:
obj
-
>
realm
(
)
;
}
JS_PUBLIC_API
(
void
*
)
JS
:
:
GetRealmPrivate
(
JS
:
:
Realm
*
realm
)
{
return
realm
-
>
realmPrivate
(
)
;
}
JS_PUBLIC_API
(
void
)
JS
:
:
SetRealmPrivate
(
JS
:
:
Realm
*
realm
void
*
data
)
{
realm
-
>
setRealmPrivate
(
data
)
;
}
JS_PUBLIC_API
(
void
)
JS
:
:
SetDestroyRealmCallback
(
JSContext
*
cx
JS
:
:
DestroyRealmCallback
callback
)
{
cx
-
>
runtime
(
)
-
>
destroyRealmCallback
=
callback
;
}
JS_PUBLIC_API
(
void
)
JS
:
:
SetRealmNameCallback
(
JSContext
*
cx
JS
:
:
RealmNameCallback
callback
)
{
cx
-
>
runtime
(
)
-
>
realmNameCallback
=
callback
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmGlobalOrNull
(
Handle
<
JS
:
:
Realm
*
>
realm
)
{
return
realm
-
>
maybeGlobal
(
)
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmObjectPrototype
(
JSContext
*
cx
)
{
CHECK_REQUEST
(
cx
)
;
return
GlobalObject
:
:
getOrCreateObjectPrototype
(
cx
cx
-
>
global
(
)
)
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmFunctionPrototype
(
JSContext
*
cx
)
{
CHECK_REQUEST
(
cx
)
;
return
GlobalObject
:
:
getOrCreateFunctionPrototype
(
cx
cx
-
>
global
(
)
)
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmArrayPrototype
(
JSContext
*
cx
)
{
CHECK_REQUEST
(
cx
)
;
return
GlobalObject
:
:
getOrCreateArrayPrototype
(
cx
cx
-
>
global
(
)
)
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmErrorPrototype
(
JSContext
*
cx
)
{
CHECK_REQUEST
(
cx
)
;
return
GlobalObject
:
:
getOrCreateCustomErrorPrototype
(
cx
cx
-
>
global
(
)
JSEXN_ERR
)
;
}
JS_PUBLIC_API
(
JSObject
*
)
JS
:
:
GetRealmIteratorPrototype
(
JSContext
*
cx
)
{
CHECK_REQUEST
(
cx
)
;
return
GlobalObject
:
:
getOrCreateIteratorPrototype
(
cx
cx
-
>
global
(
)
)
;
}
