#
ifndef
vm_Stopwatch_h
#
define
vm_Stopwatch_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
jsapi
.
h
"
namespace
js
{
struct
PerformanceGroupHolder
{
const
PerformanceGroupVector
*
getGroups
(
JSContext
*
)
;
explicit
PerformanceGroupHolder
(
JSRuntime
*
runtime
)
:
runtime_
(
runtime
)
initialized_
(
false
)
{
}
~
PerformanceGroupHolder
(
)
;
void
unlink
(
)
;
private
:
JSRuntime
*
runtime_
;
bool
initialized_
;
PerformanceGroupVector
groups_
;
}
;
struct
PerformanceMonitoring
{
uint64_t
iteration
(
)
{
return
iteration_
;
}
explicit
PerformanceMonitoring
(
JSRuntime
*
runtime
)
:
totalCPOWTime
(
0
)
stopwatchStartCallback
(
nullptr
)
stopwatchStartClosure
(
nullptr
)
stopwatchCommitCallback
(
nullptr
)
stopwatchCommitClosure
(
nullptr
)
getGroupsCallback
(
nullptr
)
getGroupsClosure
(
nullptr
)
isMonitoringJank_
(
false
)
isMonitoringCPOW_
(
false
)
iteration_
(
0
)
startedAtIteration_
(
0
)
highestTimestampCounter_
(
0
)
{
}
void
reset
(
)
;
void
start
(
)
;
bool
commit
(
)
;
void
dispose
(
JSRuntime
*
rtx
)
;
bool
setIsMonitoringJank
(
bool
value
)
{
if
(
isMonitoringJank_
!
=
value
)
reset
(
)
;
isMonitoringJank_
=
value
;
return
true
;
}
bool
isMonitoringJank
(
)
const
{
return
isMonitoringJank_
;
}
bool
addRecentGroup
(
PerformanceGroup
*
group
)
;
bool
setIsMonitoringCPOW
(
bool
value
)
{
if
(
isMonitoringCPOW_
!
=
value
)
reset
(
)
;
isMonitoringCPOW_
=
value
;
return
true
;
}
bool
isMonitoringCPOW
(
)
const
{
return
isMonitoringCPOW_
;
}
void
setStopwatchStartCallback
(
js
:
:
StopwatchStartCallback
cb
void
*
closure
)
{
stopwatchStartCallback
=
cb
;
stopwatchStartClosure
=
closure
;
}
void
setStopwatchCommitCallback
(
js
:
:
StopwatchCommitCallback
cb
void
*
closure
)
{
stopwatchCommitCallback
=
cb
;
stopwatchCommitClosure
=
closure
;
}
void
setGetGroupsCallback
(
js
:
:
GetGroupsCallback
cb
void
*
closure
)
{
getGroupsCallback
=
cb
;
getGroupsClosure
=
closure
;
}
uint64_t
totalCPOWTime
;
uint64_t
monotonicReadTimestampCounter
(
)
;
struct
TestCpuRescheduling
{
uint64_t
stayed
;
uint64_t
moved
;
TestCpuRescheduling
(
)
:
stayed
(
0
)
moved
(
0
)
{
}
}
;
TestCpuRescheduling
testCpuRescheduling
;
private
:
PerformanceMonitoring
(
const
PerformanceMonitoring
&
)
=
delete
;
PerformanceMonitoring
&
operator
=
(
const
PerformanceMonitoring
&
)
=
delete
;
private
:
friend
struct
PerformanceGroupHolder
;
js
:
:
StopwatchStartCallback
stopwatchStartCallback
;
void
*
stopwatchStartClosure
;
js
:
:
StopwatchCommitCallback
stopwatchCommitCallback
;
void
*
stopwatchCommitClosure
;
js
:
:
GetGroupsCallback
getGroupsCallback
;
void
*
getGroupsClosure
;
bool
isMonitoringJank_
;
bool
isMonitoringCPOW_
;
uint64_t
iteration_
;
uint64_t
startedAtIteration_
;
PerformanceGroupVector
recentGroups_
;
uint64_t
highestTimestampCounter_
;
}
;
#
if
WINVER
>
=
0x0600
struct
cpuid_t
{
WORD
group_
;
BYTE
number_
;
cpuid_t
(
WORD
group
BYTE
number
)
:
group_
(
group
)
number_
(
number
)
{
}
cpuid_t
(
)
:
group_
(
0
)
number_
(
0
)
{
}
}
;
#
else
typedef
struct
{
}
cpuid_t
;
#
endif
class
AutoStopwatch
final
{
JSContext
*
const
cx_
;
uint64_t
iteration_
;
bool
isMonitoringJank_
;
bool
isMonitoringCPOW_
;
uint64_t
cyclesStart_
;
uint64_t
CPOWTimeStart_
;
cpuid_t
cpuStart_
;
PerformanceGroupVector
groups_
;
public
:
explicit
AutoStopwatch
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoStopwatch
(
)
;
private
:
void
inline
enter
(
)
;
bool
inline
exit
(
)
;
PerformanceGroup
*
acquireGroup
(
PerformanceGroup
*
group
)
;
void
releaseGroup
(
PerformanceGroup
*
group
)
;
bool
addToGroups
(
uint64_t
cyclesDelta
uint64_t
CPOWTimeDelta
)
;
bool
addToGroup
(
JSRuntime
*
runtime
uint64_t
cyclesDelta
uint64_t
CPOWTimeDelta
PerformanceGroup
*
group
)
;
void
updateTelemetry
(
const
cpuid_t
&
a
const
cpuid_t
&
b
)
;
uint64_t
inline
getDelta
(
const
uint64_t
end
const
uint64_t
start
)
const
;
uint64_t
inline
getCycles
(
JSRuntime
*
)
const
;
cpuid_t
inline
getCPU
(
)
const
;
bool
inline
isSameCPU
(
const
cpuid_t
&
a
const
cpuid_t
&
b
)
const
;
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
}
;
}
#
endif
