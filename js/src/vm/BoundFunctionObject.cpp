#
include
"
vm
/
BoundFunctionObject
.
h
"
#
include
<
string_view
>
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
JSFunction
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
template
<
typename
Args
>
static
MOZ_ALWAYS_INLINE
void
FillArguments
(
Args
&
args
BoundFunctionObject
*
bound
size_t
numBoundArgs
const
CallArgs
&
callArgs
)
{
MOZ_ASSERT
(
args
.
length
(
)
=
=
numBoundArgs
+
callArgs
.
length
(
)
)
;
if
(
numBoundArgs
<
=
BoundFunctionObject
:
:
MaxInlineBoundArgs
)
{
for
(
size_t
i
=
0
;
i
<
numBoundArgs
;
i
+
+
)
{
args
[
i
]
.
set
(
bound
-
>
getInlineBoundArg
(
i
)
)
;
}
}
else
{
ArrayObject
*
boundArgs
=
bound
-
>
getBoundArgsArray
(
)
;
for
(
size_t
i
=
0
;
i
<
numBoundArgs
;
i
+
+
)
{
args
[
i
]
.
set
(
boundArgs
-
>
getDenseElement
(
i
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
callArgs
.
length
(
)
;
i
+
+
)
{
args
[
numBoundArgs
+
i
]
.
set
(
callArgs
[
i
]
)
;
}
}
bool
BoundFunctionObject
:
:
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
BoundFunctionObject
*
>
bound
(
cx
&
args
.
callee
(
)
.
as
<
BoundFunctionObject
>
(
)
)
;
Rooted
<
Value
>
target
(
cx
bound
-
>
getTargetVal
(
)
)
;
Rooted
<
Value
>
boundThis
(
cx
bound
-
>
getBoundThis
(
)
)
;
size_t
numBoundArgs
=
bound
-
>
numBoundArgs
(
)
;
InvokeArgs
args2
(
cx
)
;
if
(
!
args2
.
init
(
cx
uint64_t
(
numBoundArgs
)
+
args
.
length
(
)
)
)
{
return
false
;
}
FillArguments
(
args2
bound
numBoundArgs
args
)
;
return
Call
(
cx
target
boundThis
args2
args
.
rval
(
)
)
;
}
bool
BoundFunctionObject
:
:
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
BoundFunctionObject
*
>
bound
(
cx
&
args
.
callee
(
)
.
as
<
BoundFunctionObject
>
(
)
)
;
MOZ_ASSERT
(
bound
-
>
isConstructor
(
)
"
shouldn
'
t
have
called
this
hook
if
not
a
constructor
"
)
;
Rooted
<
Value
>
target
(
cx
bound
-
>
getTargetVal
(
)
)
;
MOZ_ASSERT
(
IsConstructor
(
target
)
)
;
size_t
numBoundArgs
=
bound
-
>
numBoundArgs
(
)
;
ConstructArgs
args2
(
cx
)
;
if
(
!
args2
.
init
(
cx
uint64_t
(
numBoundArgs
)
+
args
.
length
(
)
)
)
{
return
false
;
}
FillArguments
(
args2
bound
numBoundArgs
args
)
;
Rooted
<
Value
>
newTarget
(
cx
args
.
newTarget
(
)
)
;
if
(
newTarget
=
=
ObjectValue
(
*
bound
)
)
{
newTarget
=
target
;
}
Rooted
<
JSObject
*
>
res
(
cx
)
;
if
(
!
Construct
(
cx
target
args2
newTarget
&
res
)
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
res
)
;
return
true
;
}
JSString
*
BoundFunctionObject
:
:
funToString
(
JSContext
*
cx
Handle
<
JSObject
*
>
obj
bool
isToSource
)
{
if
(
isToSource
)
{
static
constexpr
std
:
:
string_view
nativeCodeBound
=
"
function
bound
(
)
{
\
n
[
native
code
]
\
n
}
"
;
return
NewStringCopy
<
CanGC
>
(
cx
nativeCodeBound
)
;
}
static
constexpr
std
:
:
string_view
nativeCode
=
"
function
(
)
{
\
n
[
native
code
]
\
n
}
"
;
return
NewStringCopy
<
CanGC
>
(
cx
nativeCode
)
;
}
SharedShape
*
BoundFunctionObject
:
:
assignInitialShape
(
JSContext
*
cx
Handle
<
BoundFunctionObject
*
>
obj
)
{
MOZ_ASSERT
(
obj
-
>
empty
(
)
)
;
constexpr
PropertyFlags
propFlags
=
{
PropertyFlag
:
:
Configurable
}
;
if
(
!
NativeObject
:
:
addPropertyInReservedSlot
(
cx
obj
cx
-
>
names
(
)
.
length
LengthSlot
propFlags
)
)
{
return
nullptr
;
}
if
(
!
NativeObject
:
:
addPropertyInReservedSlot
(
cx
obj
cx
-
>
names
(
)
.
name
NameSlot
propFlags
)
)
{
return
nullptr
;
}
return
obj
-
>
sharedShape
(
)
;
}
static
MOZ_ALWAYS_INLINE
JSAtom
*
AppendBoundFunctionPrefix
(
JSContext
*
cx
JSString
*
str
)
{
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
"
bound
"
)
|
|
!
sb
.
append
(
str
)
)
{
return
nullptr
;
}
return
sb
.
finishAtom
(
)
;
}
bool
BoundFunctionObject
:
:
functionBind
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
MOZ_UNLIKELY
(
!
IsCallable
(
args
.
thisv
(
)
)
)
)
{
ReportIncompatibleMethod
(
cx
args
&
FunctionClass
)
;
return
false
;
}
size_t
numBoundArgs
=
args
.
length
(
)
>
0
?
args
.
length
(
)
-
1
:
0
;
if
(
MOZ_UNLIKELY
(
numBoundArgs
>
ARGS_LENGTH_MAX
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TOO_MANY_ARGUMENTS
)
;
return
false
;
}
Rooted
<
JSObject
*
>
target
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
GetPrototype
(
cx
target
&
proto
)
)
{
return
false
;
}
Rooted
<
BoundFunctionObject
*
>
bound
(
cx
NewObjectWithGivenProto
<
BoundFunctionObject
>
(
cx
proto
)
)
;
if
(
!
bound
)
{
return
false
;
}
if
(
!
SharedShape
:
:
ensureInitialCustomShape
<
BoundFunctionObject
>
(
cx
bound
)
)
{
return
false
;
}
MOZ_ASSERT
(
bound
-
>
lookupPure
(
cx
-
>
names
(
)
.
length
)
-
>
slot
(
)
=
=
LengthSlot
)
;
MOZ_ASSERT
(
bound
-
>
lookupPure
(
cx
-
>
names
(
)
.
name
)
-
>
slot
(
)
=
=
NameSlot
)
;
bound
-
>
initFlags
(
numBoundArgs
target
-
>
isConstructor
(
)
)
;
bound
-
>
initReservedSlot
(
TargetSlot
ObjectValue
(
*
target
)
)
;
bound
-
>
initReservedSlot
(
BoundThisSlot
args
.
get
(
0
)
)
;
if
(
numBoundArgs
<
=
MaxInlineBoundArgs
)
{
for
(
size_t
i
=
0
;
i
<
numBoundArgs
;
i
+
+
)
{
bound
-
>
initReservedSlot
(
BoundArg0Slot
+
i
args
[
i
+
1
]
)
;
}
}
else
{
ArrayObject
*
arr
=
NewDenseCopiedArray
(
cx
numBoundArgs
args
.
array
(
)
+
1
)
;
if
(
!
arr
)
{
return
false
;
}
bound
-
>
initReservedSlot
(
BoundArg0Slot
ObjectValue
(
*
arr
)
)
;
}
double
length
=
0
.
0
;
bool
hasLength
;
Rooted
<
PropertyKey
>
key
(
cx
NameToId
(
cx
-
>
names
(
)
.
length
)
)
;
if
(
!
HasOwnProperty
(
cx
target
key
&
hasLength
)
)
{
return
false
;
}
if
(
hasLength
)
{
Rooted
<
Value
>
targetLength
(
cx
)
;
if
(
!
GetProperty
(
cx
target
target
key
&
targetLength
)
)
{
return
false
;
}
if
(
targetLength
.
isNumber
(
)
)
{
length
=
std
:
:
max
(
0
.
0
JS
:
:
ToInteger
(
targetLength
.
toNumber
(
)
)
-
double
(
numBoundArgs
)
)
;
}
}
bound
-
>
initLength
(
length
)
;
Rooted
<
Value
>
targetName
(
cx
)
;
if
(
!
GetProperty
(
cx
target
target
cx
-
>
names
(
)
.
name
&
targetName
)
)
{
return
false
;
}
JSAtom
*
name
;
if
(
targetName
.
isString
(
)
)
{
name
=
AppendBoundFunctionPrefix
(
cx
targetName
.
toString
(
)
)
;
if
(
!
name
)
{
return
false
;
}
}
else
{
name
=
cx
-
>
names
(
)
.
boundWithSpace
;
}
bound
-
>
initName
(
name
)
;
args
.
rval
(
)
.
setObject
(
*
bound
)
;
return
true
;
}
static
const
JSClassOps
classOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
BoundFunctionObject
:
:
call
BoundFunctionObject
:
:
construct
nullptr
}
;
static
const
ObjectOps
objOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
BoundFunctionObject
:
:
funToString
}
;
const
JSClass
BoundFunctionObject
:
:
class_
=
{
"
BoundFunctionObject
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_BoundFunction
)
|
JSCLASS_HAS_RESERVED_SLOTS
(
BoundFunctionObject
:
:
SlotCount
)
&
classOps
JS_NULL_CLASS_SPEC
JS_NULL_CLASS_EXT
&
objOps
}
;
