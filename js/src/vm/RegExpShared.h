#
ifndef
vm_RegExpShared_h
#
define
vm_RegExpShared_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
Vector
.
h
"
#
ifdef
ENABLE_NEW_REGEXP
#
include
"
new
-
regexp
/
RegExpTypes
.
h
"
#
endif
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
namespace
js
{
class
ArrayObject
;
class
RegExpRealm
;
class
RegExpShared
;
class
RegExpStatics
;
class
VectorMatchPairs
;
using
RootedRegExpShared
=
JS
:
:
Rooted
<
RegExpShared
*
>
;
using
HandleRegExpShared
=
JS
:
:
Handle
<
RegExpShared
*
>
;
using
MutableHandleRegExpShared
=
JS
:
:
MutableHandle
<
RegExpShared
*
>
;
enum
RegExpRunStatus
:
int32_t
{
RegExpRunStatus_Error
=
-
1
RegExpRunStatus_Success
=
1
RegExpRunStatus_Success_NotFound
=
0
}
;
struct
RegExpByteCodeHeader
{
uint32_t
length
;
uint32_t
numRegisters
;
}
;
class
RegExpShared
:
public
gc
:
:
TenuredCell
{
public
:
enum
ForceByteCodeEnum
{
DontForceByteCode
ForceByteCode
}
;
enum
class
Kind
{
Unparsed
Atom
RegExp
}
;
#
ifdef
ENABLE_NEW_REGEXP
using
ByteCode
=
js
:
:
irregexp
:
:
ByteArrayData
;
using
JitCodeTable
=
js
:
:
irregexp
:
:
ByteArray
;
#
else
using
ByteCode
=
uint8_t
;
using
JitCodeTable
=
UniquePtr
<
uint8_t
[
]
JS
:
:
FreePolicy
>
;
#
endif
using
JitCodeTables
=
Vector
<
JitCodeTable
0
SystemAllocPolicy
>
;
private
:
friend
class
RegExpStatics
;
friend
class
RegExpZone
;
struct
RegExpCompilation
{
WeakHeapPtr
<
jit
:
:
JitCode
*
>
jitCode
;
ByteCode
*
byteCode
=
nullptr
;
bool
compiled
(
ForceByteCodeEnum
force
=
DontForceByteCode
)
const
{
return
byteCode
|
|
(
force
=
=
DontForceByteCode
&
&
jitCode
)
;
}
size_t
byteCodeLength
(
)
const
{
MOZ_ASSERT
(
byteCode
)
;
#
ifdef
ENABLE_NEW_REGEXP
return
byteCode
-
>
length
;
#
else
auto
header
=
reinterpret_cast
<
RegExpByteCodeHeader
*
>
(
byteCode
)
;
return
header
-
>
length
;
#
endif
}
}
;
using
HeaderWithAtom
=
gc
:
:
CellHeaderWithTenuredGCPointer
<
JSAtom
>
;
HeaderWithAtom
headerAndSource
;
RegExpCompilation
compilationArray
[
2
]
;
uint32_t
pairCount_
;
JS
:
:
RegExpFlags
flags
;
#
ifdef
ENABLE_NEW_REGEXP
RegExpShared
:
:
Kind
kind_
=
Kind
:
:
Unparsed
;
GCPtrAtom
patternAtom_
;
uint32_t
maxRegisters_
=
0
;
#
else
bool
canStringMatch
=
false
;
#
endif
static
int
CompilationIndex
(
bool
latin1
)
{
return
latin1
?
0
:
1
;
}
JitCodeTables
tables
;
RegExpShared
(
JSAtom
*
source
JS
:
:
RegExpFlags
flags
)
;
static
bool
compile
(
JSContext
*
cx
MutableHandleRegExpShared
res
HandleLinearString
input
ForceByteCodeEnum
force
)
;
static
bool
compile
(
JSContext
*
cx
MutableHandleRegExpShared
res
HandleAtom
pattern
HandleLinearString
input
ForceByteCodeEnum
force
)
;
static
bool
compileIfNecessary
(
JSContext
*
cx
MutableHandleRegExpShared
res
HandleLinearString
input
ForceByteCodeEnum
force
)
;
const
RegExpCompilation
&
compilation
(
bool
latin1
)
const
{
return
compilationArray
[
CompilationIndex
(
latin1
)
]
;
}
RegExpCompilation
&
compilation
(
bool
latin1
)
{
return
compilationArray
[
CompilationIndex
(
latin1
)
]
;
}
public
:
~
RegExpShared
(
)
=
delete
;
static
RegExpRunStatus
executeAtom
(
JSContext
*
cx
MutableHandleRegExpShared
re
HandleLinearString
input
size_t
start
VectorMatchPairs
*
matches
)
;
static
RegExpRunStatus
execute
(
JSContext
*
cx
MutableHandleRegExpShared
res
HandleLinearString
input
size_t
searchIndex
VectorMatchPairs
*
matches
)
;
bool
addTable
(
JitCodeTable
table
)
{
return
tables
.
append
(
std
:
:
move
(
table
)
)
;
}
size_t
pairCount
(
)
const
{
#
ifdef
ENABLE_NEW_REGEXP
MOZ_ASSERT
(
kind
(
)
!
=
Kind
:
:
Unparsed
)
;
#
else
MOZ_ASSERT
(
isCompiled
(
)
)
;
#
endif
return
pairCount_
;
}
#
ifdef
ENABLE_NEW_REGEXP
RegExpShared
:
:
Kind
kind
(
)
const
{
return
kind_
;
}
void
useAtomMatch
(
HandleAtom
pattern
)
;
void
useRegExpMatch
(
size_t
parenCount
)
;
void
setByteCode
(
ByteCode
*
code
bool
latin1
)
{
compilation
(
latin1
)
.
byteCode
=
code
;
}
ByteCode
*
getByteCode
(
bool
latin1
)
const
{
return
compilation
(
latin1
)
.
byteCode
;
}
uint32_t
getMaxRegisters
(
)
const
{
return
maxRegisters_
;
}
void
updateMaxRegisters
(
uint32_t
numRegisters
)
{
maxRegisters_
=
std
:
:
max
(
maxRegisters_
numRegisters
)
;
}
#
endif
JSAtom
*
getSource
(
)
const
{
return
headerAndSource
.
ptr
(
)
;
}
#
ifdef
ENABLE_NEW_REGEXP
JSAtom
*
patternAtom
(
)
const
{
return
patternAtom_
;
}
#
else
JSAtom
*
patternAtom
(
)
const
{
return
getSource
(
)
;
}
#
endif
JS
:
:
RegExpFlags
getFlags
(
)
const
{
return
flags
;
}
bool
global
(
)
const
{
return
flags
.
global
(
)
;
}
bool
ignoreCase
(
)
const
{
return
flags
.
ignoreCase
(
)
;
}
bool
multiline
(
)
const
{
return
flags
.
multiline
(
)
;
}
bool
dotAll
(
)
const
{
return
flags
.
dotAll
(
)
;
}
bool
unicode
(
)
const
{
return
flags
.
unicode
(
)
;
}
bool
sticky
(
)
const
{
return
flags
.
sticky
(
)
;
}
bool
isCompiled
(
bool
latin1
ForceByteCodeEnum
force
=
DontForceByteCode
)
const
{
return
compilation
(
latin1
)
.
compiled
(
force
)
;
}
bool
isCompiled
(
)
const
{
return
isCompiled
(
true
)
|
|
isCompiled
(
false
)
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
void
discardJitCode
(
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
static
size_t
offsetOfSource
(
)
{
return
offsetof
(
RegExpShared
headerAndSource
)
+
HeaderWithAtom
:
:
offsetOfPtr
(
)
;
}
static
size_t
offsetOfFlags
(
)
{
return
offsetof
(
RegExpShared
flags
)
;
}
static
size_t
offsetOfPairCount
(
)
{
return
offsetof
(
RegExpShared
pairCount_
)
;
}
static
size_t
offsetOfJitCode
(
bool
latin1
)
{
return
offsetof
(
RegExpShared
compilationArray
)
+
(
CompilationIndex
(
latin1
)
*
sizeof
(
RegExpCompilation
)
)
+
offsetof
(
RegExpCompilation
jitCode
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
#
ifdef
DEBUG
static
bool
dumpBytecode
(
JSContext
*
cx
MutableHandleRegExpShared
res
HandleLinearString
input
)
;
#
endif
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
RegExpShared
;
const
gc
:
:
CellHeader
&
cellHeader
(
)
const
{
return
headerAndSource
;
}
}
;
class
RegExpZone
{
struct
Key
{
JSAtom
*
atom
=
nullptr
;
JS
:
:
RegExpFlags
flags
=
JS
:
:
RegExpFlag
:
:
NoFlags
;
Key
(
)
=
default
;
Key
(
JSAtom
*
atom
JS
:
:
RegExpFlags
flags
)
:
atom
(
atom
)
flags
(
flags
)
{
}
MOZ_IMPLICIT
Key
(
const
WeakHeapPtr
<
RegExpShared
*
>
&
shared
)
:
atom
(
shared
.
unbarrieredGet
(
)
-
>
getSource
(
)
)
flags
(
shared
.
unbarrieredGet
(
)
-
>
getFlags
(
)
)
{
}
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
HashNumber
hash
=
DefaultHasher
<
JSAtom
*
>
:
:
hash
(
l
.
atom
)
;
return
mozilla
:
:
AddToHash
(
hash
l
.
flags
.
value
(
)
)
;
}
static
bool
match
(
Key
l
Key
r
)
{
return
l
.
atom
=
=
r
.
atom
&
&
l
.
flags
=
=
r
.
flags
;
}
}
;
using
Set
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
RegExpShared
*
>
Key
ZoneAllocPolicy
>
>
;
Set
set_
;
public
:
explicit
RegExpZone
(
Zone
*
zone
)
;
~
RegExpZone
(
)
{
MOZ_ASSERT
(
set_
.
empty
(
)
)
;
}
bool
empty
(
)
const
{
return
set_
.
empty
(
)
;
}
RegExpShared
*
maybeGet
(
JSAtom
*
source
JS
:
:
RegExpFlags
flags
)
const
{
Set
:
:
Ptr
p
=
set_
.
lookup
(
Key
(
source
flags
)
)
;
return
p
?
*
p
:
nullptr
;
}
RegExpShared
*
get
(
JSContext
*
cx
HandleAtom
source
JS
:
:
RegExpFlags
flags
)
;
#
ifdef
DEBUG
void
clear
(
)
{
set_
.
clear
(
)
;
}
#
endif
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
}
;
class
RegExpRealm
{
WeakHeapPtr
<
ArrayObject
*
>
matchResultTemplateObject_
;
WeakHeapPtr
<
Shape
*
>
optimizableRegExpPrototypeShape_
;
WeakHeapPtr
<
Shape
*
>
optimizableRegExpInstanceShape_
;
ArrayObject
*
createMatchResultTemplateObject
(
JSContext
*
cx
)
;
public
:
explicit
RegExpRealm
(
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
static
const
size_t
MatchResultObjectIndexSlot
=
0
;
static
const
size_t
MatchResultObjectInputSlot
=
1
;
ArrayObject
*
getOrCreateMatchResultTemplateObject
(
JSContext
*
cx
)
{
if
(
matchResultTemplateObject_
)
{
return
matchResultTemplateObject_
;
}
return
createMatchResultTemplateObject
(
cx
)
;
}
Shape
*
getOptimizableRegExpPrototypeShape
(
)
{
return
optimizableRegExpPrototypeShape_
;
}
void
setOptimizableRegExpPrototypeShape
(
Shape
*
shape
)
{
optimizableRegExpPrototypeShape_
=
shape
;
}
Shape
*
getOptimizableRegExpInstanceShape
(
)
{
return
optimizableRegExpInstanceShape_
;
}
void
setOptimizableRegExpInstanceShape
(
Shape
*
shape
)
{
optimizableRegExpInstanceShape_
=
shape
;
}
static
size_t
offsetOfOptimizableRegExpPrototypeShape
(
)
{
return
offsetof
(
RegExpRealm
optimizableRegExpPrototypeShape_
)
;
}
static
size_t
offsetOfOptimizableRegExpInstanceShape
(
)
{
return
offsetof
(
RegExpRealm
optimizableRegExpInstanceShape_
)
;
}
}
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
RegExpShared
>
:
TracerConcrete
<
js
:
:
RegExpShared
>
{
protected
:
explicit
Concrete
(
js
:
:
RegExpShared
*
ptr
)
:
TracerConcrete
<
js
:
:
RegExpShared
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
RegExpShared
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Other
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
