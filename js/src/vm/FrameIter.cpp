#
include
"
vm
/
FrameIter
-
inl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Principals
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
vm
/
Activation
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
wasm
/
WasmFrameIter
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
jit
/
JSJitFrameIter
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
namespace
JS
{
class
JS_PUBLIC_API
Realm
;
}
namespace
js
{
class
ArgumentsObject
;
}
using
JS
:
:
Realm
;
using
JS
:
:
Rooted
;
using
JS
:
:
Value
;
using
js
:
:
AbstractFramePtr
;
using
js
:
:
ArgumentsObject
;
using
js
:
:
CallObject
;
using
js
:
:
FrameIter
;
using
js
:
:
JitFrameIter
;
using
js
:
:
NonBuiltinFrameIter
;
using
js
:
:
NonBuiltinScriptFrameIter
;
using
js
:
:
OnlyJSJitFrameIter
;
using
js
:
:
ScriptSource
;
using
js
:
:
jit
:
:
JSJitFrameIter
;
JitFrameIter
:
:
JitFrameIter
(
const
JitFrameIter
&
another
)
{
*
this
=
another
;
}
JitFrameIter
&
JitFrameIter
:
:
operator
=
(
const
JitFrameIter
&
another
)
{
MOZ_ASSERT
(
this
!
=
&
another
)
;
act_
=
another
.
act_
;
mustUnwindActivation_
=
another
.
mustUnwindActivation_
;
if
(
isSome
(
)
)
{
iter_
.
destroy
(
)
;
}
if
(
!
another
.
isSome
(
)
)
{
return
*
this
;
}
if
(
another
.
isJSJit
(
)
)
{
iter_
.
construct
<
jit
:
:
JSJitFrameIter
>
(
another
.
asJSJit
(
)
)
;
}
else
{
MOZ_ASSERT
(
another
.
isWasm
(
)
)
;
iter_
.
construct
<
wasm
:
:
WasmFrameIter
>
(
another
.
asWasm
(
)
)
;
}
return
*
this
;
}
JitFrameIter
:
:
JitFrameIter
(
jit
:
:
JitActivation
*
act
bool
mustUnwindActivation
)
{
act_
=
act
;
mustUnwindActivation_
=
mustUnwindActivation
;
MOZ_ASSERT
(
act
-
>
hasExitFP
(
)
"
packedExitFP
is
used
to
determine
if
JSJit
or
wasm
"
)
;
if
(
act
-
>
hasJSExitFP
(
)
)
{
iter_
.
construct
<
jit
:
:
JSJitFrameIter
>
(
act
)
;
}
else
{
MOZ_ASSERT
(
act
-
>
hasWasmExitFP
(
)
)
;
iter_
.
construct
<
wasm
:
:
WasmFrameIter
>
(
act
)
;
}
settle
(
)
;
}
void
JitFrameIter
:
:
skipNonScriptedJSFrames
(
)
{
if
(
isJSJit
(
)
)
{
jit
:
:
JSJitFrameIter
&
frames
=
asJSJit
(
)
;
while
(
!
frames
.
isScripted
(
)
&
&
!
frames
.
done
(
)
)
{
+
+
frames
;
}
settle
(
)
;
}
}
bool
JitFrameIter
:
:
isSelfHostedIgnoringInlining
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
isWasm
(
)
)
{
return
false
;
}
return
asJSJit
(
)
.
script
(
)
-
>
selfHosted
(
)
;
}
JS
:
:
Realm
*
JitFrameIter
:
:
realm
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
isWasm
(
)
)
{
return
asWasm
(
)
.
instance
(
)
-
>
realm
(
)
;
}
return
asJSJit
(
)
.
script
(
)
-
>
realm
(
)
;
}
uint8_t
*
JitFrameIter
:
:
resumePCinCurrentFrame
(
)
const
{
if
(
isWasm
(
)
)
{
return
asWasm
(
)
.
resumePCinCurrentFrame
(
)
;
}
return
asJSJit
(
)
.
resumePCinCurrentFrame
(
)
;
}
bool
JitFrameIter
:
:
done
(
)
const
{
if
(
!
isSome
(
)
)
{
return
true
;
}
if
(
isJSJit
(
)
)
{
return
asJSJit
(
)
.
done
(
)
;
}
if
(
isWasm
(
)
)
{
return
asWasm
(
)
.
done
(
)
;
}
MOZ_CRASH
(
"
unhandled
case
"
)
;
}
void
JitFrameIter
:
:
settle
(
)
{
if
(
isJSJit
(
)
)
{
const
jit
:
:
JSJitFrameIter
&
jitFrame
=
asJSJit
(
)
;
if
(
jitFrame
.
type
(
)
!
=
jit
:
:
FrameType
:
:
WasmToJSJit
)
{
return
;
}
wasm
:
:
Frame
*
prevFP
=
(
wasm
:
:
Frame
*
)
jitFrame
.
prevFp
(
)
;
if
(
mustUnwindActivation_
)
{
act_
-
>
setWasmExitFP
(
prevFP
)
;
}
iter_
.
destroy
(
)
;
iter_
.
construct
<
wasm
:
:
WasmFrameIter
>
(
act_
prevFP
)
;
MOZ_ASSERT
(
!
asWasm
(
)
.
done
(
)
)
;
return
;
}
if
(
isWasm
(
)
)
{
const
wasm
:
:
WasmFrameIter
&
wasmFrame
=
asWasm
(
)
;
if
(
!
wasmFrame
.
hasUnwoundJitFrame
(
)
)
{
return
;
}
MOZ_ASSERT
(
wasmFrame
.
done
(
)
)
;
uint8_t
*
prevFP
=
wasmFrame
.
unwoundCallerFP
(
)
;
jit
:
:
FrameType
prevFrameType
=
wasmFrame
.
unwoundJitFrameType
(
)
;
if
(
mustUnwindActivation_
)
{
act_
-
>
setJSExitFP
(
prevFP
)
;
}
iter_
.
destroy
(
)
;
iter_
.
construct
<
jit
:
:
JSJitFrameIter
>
(
act_
prevFrameType
prevFP
)
;
MOZ_ASSERT
(
!
asJSJit
(
)
.
done
(
)
)
;
return
;
}
}
void
JitFrameIter
:
:
operator
+
+
(
)
{
MOZ_ASSERT
(
isSome
(
)
)
;
if
(
isJSJit
(
)
)
{
const
jit
:
:
JSJitFrameIter
&
jitFrame
=
asJSJit
(
)
;
jit
:
:
JitFrameLayout
*
prevFrame
=
nullptr
;
if
(
mustUnwindActivation_
&
&
jitFrame
.
isScripted
(
)
)
{
prevFrame
=
jitFrame
.
jsFrame
(
)
;
}
+
+
asJSJit
(
)
;
if
(
prevFrame
)
{
EnsureUnwoundJitExitFrame
(
act_
prevFrame
)
;
}
}
else
if
(
isWasm
(
)
)
{
+
+
asWasm
(
)
;
}
else
{
MOZ_CRASH
(
"
unhandled
case
"
)
;
}
settle
(
)
;
}
OnlyJSJitFrameIter
:
:
OnlyJSJitFrameIter
(
jit
:
:
JitActivation
*
act
)
:
JitFrameIter
(
act
)
{
settle
(
)
;
}
OnlyJSJitFrameIter
:
:
OnlyJSJitFrameIter
(
const
ActivationIterator
&
iter
)
:
OnlyJSJitFrameIter
(
iter
-
>
asJit
(
)
)
{
}
void
FrameIter
:
:
popActivation
(
)
{
+
+
data_
.
activations_
;
settleOnActivation
(
)
;
}
bool
FrameIter
:
:
principalsSubsumeFrame
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
data_
.
principals_
)
{
return
true
;
}
JSSubsumesOp
subsumes
=
data_
.
cx_
-
>
runtime
(
)
-
>
securityCallbacks
-
>
subsumes
;
if
(
!
subsumes
)
{
return
true
;
}
JS
:
:
AutoSuppressGCAnalysis
nogc
;
return
subsumes
(
data_
.
principals_
realm
(
)
-
>
principals
(
)
)
;
}
void
FrameIter
:
:
popInterpreterFrame
(
)
{
MOZ_ASSERT
(
data_
.
state_
=
=
INTERP
)
;
+
+
data_
.
interpFrames_
;
if
(
data_
.
interpFrames_
.
done
(
)
)
{
popActivation
(
)
;
}
else
{
data_
.
pc_
=
data_
.
interpFrames_
.
pc
(
)
;
}
}
void
FrameIter
:
:
settleOnActivation
(
)
{
MOZ_ASSERT
(
!
data_
.
cx_
-
>
inUnsafeCallWithABI
)
;
while
(
true
)
{
if
(
data_
.
activations_
.
done
(
)
)
{
data_
.
state_
=
DONE
;
return
;
}
Activation
*
activation
=
data_
.
activations_
.
activation
(
)
;
if
(
activation
-
>
isJit
(
)
)
{
data_
.
jitFrames_
=
JitFrameIter
(
activation
-
>
asJit
(
)
)
;
data_
.
jitFrames_
.
skipNonScriptedJSFrames
(
)
;
if
(
data_
.
jitFrames_
.
done
(
)
)
{
+
+
data_
.
activations_
;
continue
;
}
data_
.
state_
=
JIT
;
nextJitFrame
(
)
;
return
;
}
MOZ_ASSERT
(
activation
-
>
isInterpreter
(
)
)
;
InterpreterActivation
*
interpAct
=
activation
-
>
asInterpreter
(
)
;
data_
.
interpFrames_
=
InterpreterFrameIterator
(
interpAct
)
;
if
(
data_
.
interpFrames_
.
frame
(
)
-
>
runningInJit
(
)
)
{
+
+
data_
.
interpFrames_
;
if
(
data_
.
interpFrames_
.
done
(
)
)
{
+
+
data_
.
activations_
;
continue
;
}
}
MOZ_ASSERT
(
!
data_
.
interpFrames_
.
frame
(
)
-
>
runningInJit
(
)
)
;
data_
.
pc_
=
data_
.
interpFrames_
.
pc
(
)
;
data_
.
state_
=
INTERP
;
return
;
}
}
FrameIter
:
:
Data
:
:
Data
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
:
cx_
(
cx
)
debuggerEvalOption_
(
debuggerEvalOption
)
principals_
(
principals
)
state_
(
DONE
)
pc_
(
nullptr
)
interpFrames_
(
nullptr
)
activations_
(
cx
)
ionInlineFrameNo_
(
0
)
{
}
FrameIter
:
:
Data
:
:
Data
(
const
FrameIter
:
:
Data
&
other
)
=
default
;
FrameIter
:
:
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
)
:
data_
(
cx
debuggerEvalOption
nullptr
)
ionInlineFrames_
(
cx
(
js
:
:
jit
:
:
JSJitFrameIter
*
)
nullptr
)
{
settleOnActivation
(
)
;
MOZ_ASSERT_IF
(
!
done
(
)
principalsSubsumeFrame
(
)
)
;
}
FrameIter
:
:
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
:
data_
(
cx
debuggerEvalOption
principals
)
ionInlineFrames_
(
cx
(
js
:
:
jit
:
:
JSJitFrameIter
*
)
nullptr
)
{
settleOnActivation
(
)
;
if
(
!
done
(
)
&
&
!
principalsSubsumeFrame
(
)
)
{
+
+
*
this
;
}
}
FrameIter
:
:
FrameIter
(
const
FrameIter
&
other
)
:
data_
(
other
.
data_
)
ionInlineFrames_
(
other
.
data_
.
cx_
isIonScripted
(
)
?
&
other
.
ionInlineFrames_
:
nullptr
)
{
}
FrameIter
:
:
FrameIter
(
const
Data
&
data
)
:
data_
(
data
)
ionInlineFrames_
(
data
.
cx_
isIonScripted
(
)
?
&
jsJitFrame
(
)
:
nullptr
)
{
MOZ_ASSERT
(
data
.
cx_
)
;
if
(
isIonScripted
(
)
)
{
while
(
ionInlineFrames_
.
frameNo
(
)
!
=
data
.
ionInlineFrameNo_
)
{
+
+
ionInlineFrames_
;
}
}
}
void
FrameIter
:
:
nextJitFrame
(
)
{
MOZ_ASSERT
(
data_
.
jitFrames_
.
isSome
(
)
)
;
if
(
isJSJit
(
)
)
{
if
(
jsJitFrame
(
)
.
isIonScripted
(
)
)
{
ionInlineFrames_
.
resetOn
(
&
jsJitFrame
(
)
)
;
data_
.
pc_
=
ionInlineFrames_
.
pc
(
)
;
}
else
{
MOZ_ASSERT
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
;
jsJitFrame
(
)
.
baselineScriptAndPc
(
nullptr
&
data_
.
pc_
)
;
}
return
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
data_
.
pc_
=
nullptr
;
}
void
FrameIter
:
:
popJitFrame
(
)
{
MOZ_ASSERT
(
data_
.
state_
=
=
JIT
)
;
MOZ_ASSERT
(
data_
.
jitFrames_
.
isSome
(
)
)
;
if
(
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isIonScripted
(
)
&
&
ionInlineFrames_
.
more
(
)
)
{
+
+
ionInlineFrames_
;
data_
.
pc_
=
ionInlineFrames_
.
pc
(
)
;
return
;
}
+
+
data_
.
jitFrames_
;
data_
.
jitFrames_
.
skipNonScriptedJSFrames
(
)
;
if
(
!
data_
.
jitFrames_
.
done
(
)
)
{
nextJitFrame
(
)
;
}
else
{
data_
.
jitFrames_
.
reset
(
)
;
popActivation
(
)
;
}
}
FrameIter
&
FrameIter
:
:
operator
+
+
(
)
{
while
(
true
)
{
switch
(
data_
.
state_
)
{
case
DONE
:
MOZ_CRASH
(
"
Unexpected
state
"
)
;
case
INTERP
:
if
(
interpFrame
(
)
-
>
isDebuggerEvalFrame
(
)
&
&
data_
.
debuggerEvalOption_
=
=
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
{
AbstractFramePtr
eifPrev
=
interpFrame
(
)
-
>
evalInFramePrev
(
)
;
popInterpreterFrame
(
)
;
while
(
!
hasUsableAbstractFramePtr
(
)
|
|
abstractFramePtr
(
)
!
=
eifPrev
)
{
if
(
data_
.
state_
=
=
JIT
)
{
popJitFrame
(
)
;
}
else
{
popInterpreterFrame
(
)
;
}
}
break
;
}
popInterpreterFrame
(
)
;
break
;
case
JIT
:
popJitFrame
(
)
;
break
;
}
if
(
done
(
)
|
|
principalsSubsumeFrame
(
)
)
{
break
;
}
}
return
*
this
;
}
FrameIter
:
:
Data
*
FrameIter
:
:
copyData
(
)
const
{
Data
*
data
=
data_
.
cx_
-
>
new_
<
Data
>
(
data_
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
(
data
&
&
isIonScripted
(
)
)
{
data
-
>
ionInlineFrameNo_
=
ionInlineFrames_
.
frameNo
(
)
;
}
return
data
;
}
void
*
FrameIter
:
:
rawFramePtr
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
return
nullptr
;
case
INTERP
:
return
interpFrame
(
)
;
case
JIT
:
if
(
isJSJit
(
)
)
{
return
jsJitFrame
(
)
.
fp
(
)
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
return
nullptr
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
JS
:
:
Compartment
*
FrameIter
:
:
compartment
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
return
data_
.
activations_
-
>
compartment
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
Realm
*
FrameIter
:
:
realm
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
hasScript
(
)
)
{
return
script
(
)
-
>
realm
(
)
;
}
return
wasmInstance
(
)
-
>
realm
(
)
;
}
bool
FrameIter
:
:
isEvalFrame
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
return
interpFrame
(
)
-
>
isEvalFrame
(
)
;
case
JIT
:
if
(
isJSJit
(
)
)
{
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
isEvalFrame
(
)
;
}
MOZ_ASSERT
(
!
script
(
)
-
>
isForEval
(
)
)
;
return
false
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
return
false
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
isModuleFrame
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
hasScript
(
)
)
{
return
script
(
)
-
>
isModule
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
isFunctionFrame
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
return
interpFrame
(
)
-
>
isFunctionFrame
(
)
;
case
JIT
:
if
(
isJSJit
(
)
)
{
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
isFunctionFrame
(
)
;
}
return
script
(
)
-
>
isFunction
(
)
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
return
false
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
JSAtom
*
FrameIter
:
:
maybeFunctionDisplayAtom
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
if
(
isWasm
(
)
)
{
return
wasmFrame
(
)
.
functionDisplayAtom
(
)
;
}
if
(
isFunctionFrame
(
)
)
{
return
calleeTemplate
(
)
-
>
displayAtom
(
)
;
}
return
nullptr
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
ScriptSource
*
FrameIter
:
:
scriptSource
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
return
script
(
)
-
>
scriptSource
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
const
char
*
FrameIter
:
:
filename
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
if
(
isWasm
(
)
)
{
return
wasmFrame
(
)
.
filename
(
)
;
}
return
script
(
)
-
>
filename
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
const
char16_t
*
FrameIter
:
:
displayURL
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
if
(
isWasm
(
)
)
{
return
wasmFrame
(
)
.
displayURL
(
)
;
}
ScriptSource
*
ss
=
script
(
)
-
>
scriptSource
(
)
;
return
ss
-
>
hasDisplayURL
(
)
?
ss
-
>
displayURL
(
)
:
nullptr
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
unsigned
FrameIter
:
:
computeLine
(
JS
:
:
TaggedColumnNumberZeroOrigin
*
column
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
if
(
isWasm
(
)
)
{
return
wasmFrame
(
)
.
computeLine
(
column
)
;
}
unsigned
columnNumber
;
unsigned
lineNumber
=
PCToLineNumber
(
script
(
)
pc
(
)
&
columnNumber
)
;
if
(
column
)
{
*
column
=
JS
:
:
TaggedColumnNumberZeroOrigin
(
JS
:
:
LimitedColumnNumberZeroOrigin
(
columnNumber
)
)
;
}
return
lineNumber
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
mutedErrors
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
case
JIT
:
if
(
isWasm
(
)
)
{
return
wasmFrame
(
)
.
mutedErrors
(
)
;
}
return
script
(
)
-
>
mutedErrors
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
isConstructing
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
MOZ_ASSERT
(
isJSJit
(
)
)
;
if
(
jsJitFrame
(
)
.
isIonScripted
(
)
)
{
return
ionInlineFrames_
.
isConstructing
(
)
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
;
return
jsJitFrame
(
)
.
isConstructing
(
)
;
case
INTERP
:
return
interpFrame
(
)
-
>
isConstructing
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
ensureHasRematerializedFrame
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
isIon
(
)
)
;
return
!
!
activation
(
)
-
>
asJit
(
)
-
>
getRematerializedFrame
(
cx
jsJitFrame
(
)
)
;
}
bool
FrameIter
:
:
hasUsableAbstractFramePtr
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
return
false
;
case
JIT
:
if
(
isJSJit
(
)
)
{
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
isIonScripted
(
)
)
;
return
!
!
activation
(
)
-
>
asJit
(
)
-
>
lookupRematerializedFrame
(
jsJitFrame
(
)
.
fp
(
)
ionInlineFrames_
.
frameNo
(
)
)
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
debugEnabled
(
)
;
case
INTERP
:
return
true
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
AbstractFramePtr
FrameIter
:
:
abstractFramePtr
(
)
const
{
MOZ_ASSERT
(
hasUsableAbstractFramePtr
(
)
)
;
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
{
if
(
isJSJit
(
)
)
{
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
jsJitFrame
(
)
.
baselineFrame
(
)
;
}
MOZ_ASSERT
(
isIonScripted
(
)
)
;
return
activation
(
)
-
>
asJit
(
)
-
>
lookupRematerializedFrame
(
jsJitFrame
(
)
.
fp
(
)
ionInlineFrames_
.
frameNo
(
)
)
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
MOZ_ASSERT
(
wasmFrame
(
)
.
debugEnabled
(
)
)
;
return
wasmFrame
(
)
.
debugFrame
(
)
;
}
case
INTERP
:
MOZ_ASSERT
(
interpFrame
(
)
)
;
return
AbstractFramePtr
(
interpFrame
(
)
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
void
FrameIter
:
:
updatePcQuadratic
(
)
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
{
InterpreterFrame
*
frame
=
interpFrame
(
)
;
InterpreterActivation
*
activation
=
data_
.
activations_
-
>
asInterpreter
(
)
;
data_
.
interpFrames_
=
InterpreterFrameIterator
(
activation
)
;
while
(
data_
.
interpFrames_
.
frame
(
)
!
=
frame
)
{
+
+
data_
.
interpFrames_
;
}
MOZ_ASSERT
(
data_
.
interpFrames_
.
frame
(
)
=
=
frame
)
;
data_
.
pc_
=
data_
.
interpFrames_
.
pc
(
)
;
return
;
}
case
JIT
:
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
jit
:
:
BaselineFrame
*
frame
=
jsJitFrame
(
)
.
baselineFrame
(
)
;
jit
:
:
JitActivation
*
activation
=
data_
.
activations_
-
>
asJit
(
)
;
data_
.
activations_
=
ActivationIterator
(
data_
.
cx_
)
;
while
(
data_
.
activations_
.
activation
(
)
!
=
activation
)
{
+
+
data_
.
activations_
;
}
data_
.
jitFrames_
=
JitFrameIter
(
data_
.
activations_
-
>
asJit
(
)
)
;
while
(
!
isJSJit
(
)
|
|
!
jsJitFrame
(
)
.
isBaselineJS
(
)
|
|
jsJitFrame
(
)
.
baselineFrame
(
)
!
=
frame
)
{
+
+
data_
.
jitFrames_
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
baselineFrame
(
)
=
=
frame
)
;
jsJitFrame
(
)
.
baselineScriptAndPc
(
nullptr
&
data_
.
pc_
)
;
return
;
}
break
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
void
FrameIter
:
:
wasmUpdateBytecodeOffset
(
)
{
MOZ_RELEASE_ASSERT
(
isWasm
(
)
"
Unexpected
state
"
)
;
wasm
:
:
DebugFrame
*
frame
=
wasmFrame
(
)
.
debugFrame
(
)
;
data_
.
jitFrames_
=
JitFrameIter
(
data_
.
activations_
-
>
asJit
(
)
)
;
while
(
wasmFrame
(
)
.
debugFrame
(
)
!
=
frame
)
{
+
+
data_
.
jitFrames_
;
}
MOZ_ASSERT
(
wasmFrame
(
)
.
debugFrame
(
)
=
=
frame
)
;
}
JSFunction
*
FrameIter
:
:
calleeTemplate
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
return
&
interpFrame
(
)
-
>
callee
(
)
;
case
JIT
:
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
jsJitFrame
(
)
.
callee
(
)
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
isIonScripted
(
)
)
;
return
ionInlineFrames_
.
calleeTemplate
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
JSFunction
*
FrameIter
:
:
callee
(
JSContext
*
cx
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
return
calleeTemplate
(
)
;
case
JIT
:
if
(
isIonScripted
(
)
)
{
jit
:
:
MaybeReadFallback
recover
(
cx
activation
(
)
-
>
asJit
(
)
&
jsJitFrame
(
)
)
;
return
ionInlineFrames_
.
callee
(
recover
)
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
;
return
calleeTemplate
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
matchCallee
(
JSContext
*
cx
JS
:
:
Handle
<
JSFunction
*
>
fun
)
const
{
Rooted
<
JSFunction
*
>
currentCallee
(
cx
calleeTemplate
(
)
)
;
if
(
currentCallee
-
>
nargs
(
)
!
=
fun
-
>
nargs
(
)
)
{
return
false
;
}
if
(
currentCallee
-
>
flags
(
)
.
stableAcrossClones
(
)
!
=
fun
-
>
flags
(
)
.
stableAcrossClones
(
)
)
{
return
false
;
}
if
(
currentCallee
-
>
hasBaseScript
(
)
)
{
if
(
currentCallee
-
>
baseScript
(
)
!
=
fun
-
>
baseScript
(
)
)
{
return
false
;
}
}
return
callee
(
cx
)
=
=
fun
;
}
unsigned
FrameIter
:
:
numActualArgs
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
INTERP
:
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
return
interpFrame
(
)
-
>
numActualArgs
(
)
;
case
JIT
:
if
(
isIonScripted
(
)
)
{
return
ionInlineFrames_
.
numActualArgs
(
)
;
}
MOZ_ASSERT
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
;
return
jsJitFrame
(
)
.
numActualArgs
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
unsigned
FrameIter
:
:
numFormalArgs
(
)
const
{
return
script
(
)
-
>
function
(
)
-
>
nargs
(
)
;
}
Value
FrameIter
:
:
unaliasedActual
(
unsigned
i
MaybeCheckAliasing
checkAliasing
)
const
{
return
abstractFramePtr
(
)
.
unaliasedActual
(
i
checkAliasing
)
;
}
JSObject
*
FrameIter
:
:
environmentChain
(
JSContext
*
cx
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
if
(
isJSJit
(
)
)
{
if
(
isIonScripted
(
)
)
{
jit
:
:
MaybeReadFallback
recover
(
cx
activation
(
)
-
>
asJit
(
)
&
jsJitFrame
(
)
)
;
return
ionInlineFrames_
.
environmentChain
(
recover
)
;
}
return
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
environmentChain
(
)
;
}
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
debugFrame
(
)
-
>
environmentChain
(
)
;
case
INTERP
:
return
interpFrame
(
)
-
>
environmentChain
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
bool
FrameIter
:
:
hasInitialEnvironment
(
JSContext
*
cx
)
const
{
if
(
hasUsableAbstractFramePtr
(
)
)
{
return
abstractFramePtr
(
)
.
hasInitialEnvironment
(
)
;
}
if
(
isWasm
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
isJSJit
(
)
)
;
MOZ_ASSERT
(
isIonScripted
(
)
)
;
bool
hasInitialEnv
=
false
;
jit
:
:
MaybeReadFallback
recover
(
cx
activation
(
)
-
>
asJit
(
)
&
jsJitFrame
(
)
)
;
ionInlineFrames_
.
environmentChain
(
recover
&
hasInitialEnv
)
;
return
hasInitialEnv
;
}
CallObject
&
FrameIter
:
:
callObj
(
JSContext
*
cx
)
const
{
MOZ_ASSERT
(
calleeTemplate
(
)
-
>
needsCallObject
(
)
)
;
MOZ_ASSERT
(
hasInitialEnvironment
(
cx
)
)
;
JSObject
*
pobj
=
environmentChain
(
cx
)
;
while
(
!
pobj
-
>
is
<
CallObject
>
(
)
)
{
pobj
=
pobj
-
>
enclosingEnvironment
(
)
;
}
return
pobj
-
>
as
<
CallObject
>
(
)
;
}
bool
FrameIter
:
:
hasArgsObj
(
)
const
{
return
abstractFramePtr
(
)
.
hasArgsObj
(
)
;
}
ArgumentsObject
&
FrameIter
:
:
argsObj
(
)
const
{
MOZ_ASSERT
(
hasArgsObj
(
)
)
;
return
abstractFramePtr
(
)
.
argsObj
(
)
;
}
Value
FrameIter
:
:
thisArgument
(
JSContext
*
cx
)
const
{
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
if
(
isIonScripted
(
)
)
{
jit
:
:
MaybeReadFallback
recover
(
cx
activation
(
)
-
>
asJit
(
)
&
jsJitFrame
(
)
)
;
return
ionInlineFrames_
.
thisArgument
(
recover
)
;
}
return
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
thisArgument
(
)
;
case
INTERP
:
return
interpFrame
(
)
-
>
thisArgument
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
Value
FrameIter
:
:
returnValue
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
return
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
returnValue
(
)
;
}
break
;
case
INTERP
:
return
interpFrame
(
)
-
>
returnValue
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
void
FrameIter
:
:
setReturnValue
(
const
Value
&
v
)
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
if
(
jsJitFrame
(
)
.
isBaselineJS
(
)
)
{
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
setReturnValue
(
v
)
;
return
;
}
break
;
case
INTERP
:
interpFrame
(
)
-
>
setReturnValue
(
v
)
;
return
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
size_t
FrameIter
:
:
numFrameSlots
(
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
{
if
(
isIonScripted
(
)
)
{
return
ionInlineFrames_
.
snapshotIterator
(
)
.
numAllocations
(
)
-
ionInlineFrames_
.
script
(
)
-
>
nfixed
(
)
;
}
uint32_t
numValueSlots
=
jsJitFrame
(
)
.
baselineFrameNumValueSlots
(
)
;
return
numValueSlots
-
jsJitFrame
(
)
.
script
(
)
-
>
nfixed
(
)
;
}
case
INTERP
:
MOZ_ASSERT
(
data_
.
interpFrames_
.
sp
(
)
>
=
interpFrame
(
)
-
>
base
(
)
)
;
return
data_
.
interpFrames_
.
sp
(
)
-
interpFrame
(
)
-
>
base
(
)
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
Value
FrameIter
:
:
frameSlotValue
(
size_t
index
)
const
{
switch
(
data_
.
state_
)
{
case
DONE
:
break
;
case
JIT
:
if
(
isIonScripted
(
)
)
{
jit
:
:
SnapshotIterator
si
(
ionInlineFrames_
.
snapshotIterator
(
)
)
;
index
+
=
ionInlineFrames_
.
script
(
)
-
>
nfixed
(
)
;
return
si
.
maybeReadAllocByIndex
(
index
)
;
}
index
+
=
jsJitFrame
(
)
.
script
(
)
-
>
nfixed
(
)
;
return
*
jsJitFrame
(
)
.
baselineFrame
(
)
-
>
valueSlot
(
index
)
;
case
INTERP
:
return
interpFrame
(
)
-
>
base
(
)
[
index
]
;
}
MOZ_CRASH
(
"
Unexpected
state
"
)
;
}
#
ifdef
DEBUG
bool
js
:
:
SelfHostedFramesVisible
(
)
{
static
bool
checked
=
false
;
static
bool
visible
=
false
;
if
(
!
checked
)
{
checked
=
true
;
char
*
env
=
getenv
(
"
MOZ_SHOW_ALL_JS_FRAMES
"
)
;
visible
=
!
!
env
;
}
return
visible
;
}
#
endif
void
NonBuiltinFrameIter
:
:
settle
(
)
{
if
(
!
SelfHostedFramesVisible
(
)
)
{
while
(
!
done
(
)
&
&
hasScript
(
)
&
&
script
(
)
-
>
selfHosted
(
)
)
{
FrameIter
:
:
operator
+
+
(
)
;
}
}
}
void
NonBuiltinScriptFrameIter
:
:
settle
(
)
{
if
(
!
SelfHostedFramesVisible
(
)
)
{
while
(
!
done
(
)
&
&
script
(
)
-
>
selfHosted
(
)
)
{
ScriptFrameIter
:
:
operator
+
+
(
)
;
}
}
}
bool
FrameIter
:
:
inPrologue
(
)
const
{
if
(
pc
(
)
<
script
(
)
-
>
main
(
)
)
{
return
true
;
}
if
(
pc
(
)
=
=
script
(
)
-
>
code
(
)
&
&
isBaseline
(
)
&
&
jsJitFrame
(
)
.
baselineFrameNumValueSlots
(
)
<
script
(
)
-
>
nfixed
(
)
)
{
return
true
;
}
return
false
;
}
