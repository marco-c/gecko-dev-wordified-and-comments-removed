#
ifndef
vm_ObjectGroup_h
#
define
vm_ObjectGroup_h
#
include
"
js
/
shadow
/
ObjectGroup
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
ds
/
IdValuePair
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
namespace
js
{
class
TypeDescr
;
class
ObjectGroupRealm
;
class
PlainObject
;
namespace
gc
{
void
MergeRealms
(
JS
:
:
Realm
*
source
JS
:
:
Realm
*
target
)
;
}
enum
NewObjectKind
{
GenericObject
SingletonObject
TenuredObject
}
;
enum
:
uint32_t
{
OBJECT_FLAG_SINGLETON
=
0x2
}
;
using
ObjectGroupFlags
=
uint32_t
;
class
ObjectGroup
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
const
JSClass
>
{
public
:
const
JSClass
*
clasp
(
)
const
{
return
headerPtr
(
)
;
}
private
:
GCPtr
<
TaggedProto
>
proto_
;
JS
:
:
Realm
*
realm_
;
ObjectGroupFlags
flags_
;
TypeDescr
*
typeDescr_
=
nullptr
;
private
:
static
inline
uint32_t
offsetOfClasp
(
)
{
return
offsetOfHeaderPtr
(
)
;
}
static
inline
uint32_t
offsetOfProto
(
)
{
return
offsetof
(
ObjectGroup
proto_
)
;
}
static
inline
uint32_t
offsetOfRealm
(
)
{
return
offsetof
(
ObjectGroup
realm_
)
;
}
static
inline
uint32_t
offsetOfFlags
(
)
{
return
offsetof
(
ObjectGroup
flags_
)
;
}
friend
class
gc
:
:
GCRuntime
;
friend
class
js
:
:
jit
:
:
MacroAssembler
;
public
:
bool
hasDynamicPrototype
(
)
const
{
return
proto_
.
isDynamic
(
)
;
}
const
GCPtr
<
TaggedProto
>
&
proto
(
)
const
{
return
proto_
;
}
GCPtr
<
TaggedProto
>
&
proto
(
)
{
return
proto_
;
}
void
setProto
(
TaggedProto
proto
)
;
void
setProtoUnchecked
(
TaggedProto
proto
)
;
bool
hasUncacheableProto
(
)
const
{
MOZ_ASSERT
(
!
hasDynamicPrototype
(
)
)
;
return
singleton
(
)
;
}
bool
singleton
(
)
const
{
return
flags
(
)
&
OBJECT_FLAG_SINGLETON
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
JS
:
:
GetCompartmentForRealm
(
realm_
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
realm_
;
}
private
:
ObjectGroupFlags
flags
(
)
const
{
return
flags_
;
}
public
:
TypeDescr
*
maybeTypeDescr
(
)
{
return
typeDescr_
;
}
TypeDescr
&
typeDescr
(
)
{
MOZ_ASSERT
(
typeDescr_
)
;
return
*
typeDescr_
;
}
void
setTypeDescr
(
TypeDescr
*
descr
)
{
typeDescr_
=
descr
;
}
public
:
inline
ObjectGroup
(
const
JSClass
*
clasp
TaggedProto
proto
JS
:
:
Realm
*
realm
ObjectGroupFlags
initialFlags
)
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JSFreeOp
*
fop
)
{
}
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
ObjectGroup
;
static
void
staticAsserts
(
)
{
static_assert
(
offsetof
(
ObjectGroup
proto_
)
=
=
offsetof
(
JS
:
:
shadow
:
:
ObjectGroup
proto
)
)
;
}
static
ObjectGroup
*
defaultNewGroup
(
JSContext
*
cx
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
=
nullptr
)
;
}
;
class
ObjectGroupRealm
{
private
:
class
NewTable
;
private
:
NewTable
*
defaultNewTable
=
nullptr
;
class
DefaultNewGroupCache
{
ObjectGroup
*
group_
;
JSObject
*
associated_
;
public
:
DefaultNewGroupCache
(
)
:
associated_
(
nullptr
)
{
purge
(
)
;
}
void
purge
(
)
{
group_
=
nullptr
;
}
void
put
(
ObjectGroup
*
group
JSObject
*
associated
)
{
group_
=
group
;
associated_
=
associated
;
}
MOZ_ALWAYS_INLINE
ObjectGroup
*
lookup
(
const
JSClass
*
clasp
TaggedProto
proto
JSObject
*
associated
)
;
}
defaultNewGroupCache
=
{
}
;
private
:
friend
class
ObjectGroup
;
public
:
struct
NewEntry
;
ObjectGroupRealm
(
)
=
default
;
~
ObjectGroupRealm
(
)
;
ObjectGroupRealm
(
ObjectGroupRealm
&
)
=
delete
;
void
operator
=
(
ObjectGroupRealm
&
)
=
delete
;
static
ObjectGroupRealm
&
get
(
const
ObjectGroup
*
group
)
;
static
ObjectGroupRealm
&
getForNewObject
(
JSContext
*
cx
)
;
void
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
realmTables
)
;
void
clearTables
(
)
;
void
purge
(
)
{
defaultNewGroupCache
.
purge
(
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkTablesAfterMovingGC
(
)
{
checkNewTableAfterMovingGC
(
defaultNewTable
)
;
}
#
endif
void
fixupTablesAfterMovingGC
(
)
{
fixupNewTableAfterMovingGC
(
defaultNewTable
)
;
}
private
:
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkNewTableAfterMovingGC
(
NewTable
*
table
)
;
#
endif
void
fixupNewTableAfterMovingGC
(
NewTable
*
table
)
;
}
;
PlainObject
*
NewPlainObjectWithProperties
(
JSContext
*
cx
IdValuePair
*
properties
size_t
nproperties
NewObjectKind
newKind
)
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
ObjectGroup
>
:
TracerConcrete
<
js
:
:
ObjectGroup
>
{
protected
:
explicit
Concrete
(
js
:
:
ObjectGroup
*
ptr
)
:
TracerConcrete
<
js
:
:
ObjectGroup
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
ObjectGroup
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
