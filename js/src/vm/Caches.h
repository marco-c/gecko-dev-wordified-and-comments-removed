#
ifndef
vm_Caches_h
#
define
vm_Caches_h
#
include
<
iterator
>
#
include
<
new
>
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
struct
GSNCache
{
typedef
HashMap
<
jsbytecode
*
const
SrcNote
*
PointerHasher
<
jsbytecode
*
>
SystemAllocPolicy
>
Map
;
jsbytecode
*
code
;
Map
map
;
GSNCache
(
)
:
code
(
nullptr
)
{
}
void
purge
(
)
;
}
;
struct
EvalCacheEntry
{
JSLinearString
*
str
;
JSScript
*
script
;
JSScript
*
callerScript
;
jsbytecode
*
pc
;
bool
needsSweep
(
)
{
return
!
str
-
>
isTenured
(
)
;
}
}
;
struct
EvalCacheLookup
{
explicit
EvalCacheLookup
(
JSContext
*
cx
)
:
str
(
cx
)
callerScript
(
cx
)
{
}
RootedLinearString
str
;
RootedScript
callerScript
;
MOZ_INIT_OUTSIDE_CTOR
jsbytecode
*
pc
;
}
;
struct
EvalCacheHashPolicy
{
using
Lookup
=
EvalCacheLookup
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
EvalCacheEntry
&
entry
const
EvalCacheLookup
&
l
)
;
}
;
typedef
GCHashSet
<
EvalCacheEntry
EvalCacheHashPolicy
SystemAllocPolicy
>
EvalCache
;
class
StringToAtomCache
{
using
Map
=
HashMap
<
JSLinearString
*
JSAtom
*
PointerHasher
<
JSLinearString
*
>
SystemAllocPolicy
>
;
Map
map_
;
public
:
static
constexpr
size_t
MinStringLength
=
30
;
JSAtom
*
lookup
(
JSLinearString
*
s
)
{
MOZ_ASSERT
(
!
s
-
>
isAtom
(
)
)
;
if
(
!
s
-
>
inStringToAtomCache
(
)
)
{
MOZ_ASSERT
(
!
map_
.
lookup
(
s
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
s
-
>
length
(
)
>
=
MinStringLength
)
;
auto
p
=
map_
.
lookup
(
s
)
;
JSAtom
*
atom
=
p
?
p
-
>
value
(
)
:
nullptr
;
MOZ_ASSERT_IF
(
atom
EqualStrings
(
s
atom
)
)
;
return
atom
;
}
void
maybePut
(
JSLinearString
*
s
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
s
-
>
isAtom
(
)
)
;
if
(
s
-
>
length
(
)
<
MinStringLength
)
{
return
;
}
if
(
!
map_
.
putNew
(
s
atom
)
)
{
return
;
}
s
-
>
setInStringToAtomCache
(
)
;
}
void
purge
(
)
{
map_
.
clearAndCompact
(
)
;
}
}
;
class
RuntimeCaches
{
public
:
js
:
:
GSNCache
gsnCache
;
js
:
:
UncompressedSourceCache
uncompressedSourceCache
;
js
:
:
EvalCache
evalCache
;
js
:
:
StringToAtomCache
stringToAtomCache
;
void
purgeForMinorGC
(
JSRuntime
*
rt
)
{
evalCache
.
sweep
(
)
;
}
void
purgeForCompaction
(
)
{
evalCache
.
clear
(
)
;
stringToAtomCache
.
purge
(
)
;
}
void
purge
(
)
{
purgeForCompaction
(
)
;
gsnCache
.
purge
(
)
;
uncompressedSourceCache
.
purge
(
)
;
}
}
;
}
#
endif
