#
ifndef
vm_Caches_h
#
define
vm_Caches_h
#
include
<
iterator
>
#
include
<
new
>
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
struct
GSNCache
{
typedef
HashMap
<
jsbytecode
*
const
SrcNote
*
PointerHasher
<
jsbytecode
*
>
SystemAllocPolicy
>
Map
;
jsbytecode
*
code
;
Map
map
;
GSNCache
(
)
:
code
(
nullptr
)
{
}
void
purge
(
)
;
}
;
struct
EvalCacheEntry
{
JSLinearString
*
str
;
JSScript
*
script
;
JSScript
*
callerScript
;
jsbytecode
*
pc
;
bool
needsSweep
(
)
{
return
!
str
-
>
isTenured
(
)
;
}
}
;
struct
EvalCacheLookup
{
explicit
EvalCacheLookup
(
JSContext
*
cx
)
:
str
(
cx
)
callerScript
(
cx
)
{
}
RootedLinearString
str
;
RootedScript
callerScript
;
MOZ_INIT_OUTSIDE_CTOR
jsbytecode
*
pc
;
}
;
struct
EvalCacheHashPolicy
{
using
Lookup
=
EvalCacheLookup
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
EvalCacheEntry
&
entry
const
EvalCacheLookup
&
l
)
;
}
;
typedef
GCHashSet
<
EvalCacheEntry
EvalCacheHashPolicy
SystemAllocPolicy
>
EvalCache
;
class
NewObjectCache
{
static
const
unsigned
MAX_OBJ_SIZE
=
4
*
sizeof
(
void
*
)
+
16
*
sizeof
(
Value
)
;
static
void
staticAsserts
(
)
{
static_assert
(
NewObjectCache
:
:
MAX_OBJ_SIZE
=
=
sizeof
(
JSObject_Slots16
)
)
;
static_assert
(
gc
:
:
AllocKind
:
:
OBJECT_LAST
=
=
gc
:
:
AllocKind
:
:
OBJECT16_BACKGROUND
)
;
}
struct
Entry
{
const
JSClass
*
clasp
;
JSObject
*
key
;
gc
:
:
AllocKind
kind
;
uint32_t
nbytes
;
char
templateObject
[
MAX_OBJ_SIZE
]
;
}
;
using
EntryArray
=
Entry
[
41
]
;
EntryArray
entries
;
public
:
using
EntryIndex
=
int
;
NewObjectCache
(
)
:
entries
{
}
{
}
void
purge
(
)
{
new
(
&
entries
)
EntryArray
{
}
;
}
void
clearNurseryObjects
(
JSRuntime
*
rt
)
;
inline
bool
lookupProto
(
const
JSClass
*
clasp
JSObject
*
proto
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
;
inline
bool
lookupGlobal
(
const
JSClass
*
clasp
js
:
:
GlobalObject
*
global
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
;
inline
NativeObject
*
newObjectFromHit
(
JSContext
*
cx
EntryIndex
entry
js
:
:
gc
:
:
InitialHeap
heap
)
;
void
fillProto
(
EntryIndex
entry
const
JSClass
*
clasp
js
:
:
TaggedProto
proto
gc
:
:
AllocKind
kind
NativeObject
*
obj
)
;
inline
void
fillGlobal
(
EntryIndex
entry
const
JSClass
*
clasp
js
:
:
GlobalObject
*
global
gc
:
:
AllocKind
kind
NativeObject
*
obj
)
;
void
invalidateEntriesForShape
(
Shape
*
shape
JSObject
*
proto
)
;
private
:
EntryIndex
makeIndex
(
const
JSClass
*
clasp
gc
:
:
Cell
*
key
gc
:
:
AllocKind
kind
)
{
uintptr_t
hash
=
(
uintptr_t
(
clasp
)
^
uintptr_t
(
key
)
)
+
size_t
(
kind
)
;
return
hash
%
std
:
:
size
(
entries
)
;
}
bool
lookup
(
const
JSClass
*
clasp
JSObject
*
key
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
{
*
pentry
=
makeIndex
(
clasp
key
kind
)
;
Entry
*
entry
=
&
entries
[
*
pentry
]
;
return
entry
-
>
clasp
=
=
clasp
&
&
entry
-
>
key
=
=
key
;
}
void
fill
(
EntryIndex
entry_
const
JSClass
*
clasp
JSObject
*
key
gc
:
:
AllocKind
kind
NativeObject
*
obj
)
{
MOZ_ASSERT
(
unsigned
(
entry_
)
<
std
:
:
size
(
entries
)
)
;
MOZ_ASSERT
(
entry_
=
=
makeIndex
(
clasp
key
kind
)
)
;
Entry
*
entry
=
&
entries
[
entry_
]
;
MOZ_ASSERT
(
!
obj
-
>
hasDynamicSlots
(
)
)
;
MOZ_ASSERT
(
obj
-
>
hasEmptyElements
(
)
|
|
obj
-
>
is
<
ArrayObject
>
(
)
)
;
entry
-
>
clasp
=
clasp
;
entry
-
>
key
=
key
;
entry
-
>
kind
=
kind
;
entry
-
>
nbytes
=
gc
:
:
Arena
:
:
thingSize
(
kind
)
;
js_memcpy
(
&
entry
-
>
templateObject
obj
entry
-
>
nbytes
)
;
}
static
void
copyCachedToObject
(
NativeObject
*
dst
NativeObject
*
src
gc
:
:
AllocKind
kind
)
{
js_memcpy
(
dst
src
gc
:
:
Arena
:
:
thingSize
(
kind
)
)
;
dst
-
>
initGroup
(
src
-
>
group
(
)
)
;
dst
-
>
initShape
(
src
-
>
shape
(
)
)
;
}
}
;
class
StringToAtomCache
{
using
Map
=
HashMap
<
JSLinearString
*
JSAtom
*
PointerHasher
<
JSLinearString
*
>
SystemAllocPolicy
>
;
Map
map_
;
public
:
static
constexpr
size_t
MinStringLength
=
30
;
JSAtom
*
lookup
(
JSLinearString
*
s
)
{
MOZ_ASSERT
(
!
s
-
>
isAtom
(
)
)
;
if
(
!
s
-
>
inStringToAtomCache
(
)
)
{
MOZ_ASSERT
(
!
map_
.
lookup
(
s
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
s
-
>
length
(
)
>
=
MinStringLength
)
;
auto
p
=
map_
.
lookup
(
s
)
;
JSAtom
*
atom
=
p
?
p
-
>
value
(
)
:
nullptr
;
MOZ_ASSERT_IF
(
atom
EqualStrings
(
s
atom
)
)
;
return
atom
;
}
void
maybePut
(
JSLinearString
*
s
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
s
-
>
isAtom
(
)
)
;
if
(
s
-
>
length
(
)
<
MinStringLength
)
{
return
;
}
if
(
!
map_
.
putNew
(
s
atom
)
)
{
return
;
}
s
-
>
setInStringToAtomCache
(
)
;
}
void
purge
(
)
{
map_
.
clearAndCompact
(
)
;
}
}
;
class
RuntimeCaches
{
public
:
js
:
:
GSNCache
gsnCache
;
js
:
:
NewObjectCache
newObjectCache
;
js
:
:
UncompressedSourceCache
uncompressedSourceCache
;
js
:
:
EvalCache
evalCache
;
js
:
:
StringToAtomCache
stringToAtomCache
;
void
purgeForMinorGC
(
JSRuntime
*
rt
)
{
newObjectCache
.
clearNurseryObjects
(
rt
)
;
evalCache
.
sweep
(
)
;
}
void
purgeForCompaction
(
)
{
newObjectCache
.
purge
(
)
;
evalCache
.
clear
(
)
;
stringToAtomCache
.
purge
(
)
;
}
void
purge
(
)
{
purgeForCompaction
(
)
;
gsnCache
.
purge
(
)
;
uncompressedSourceCache
.
purge
(
)
;
}
}
;
}
#
endif
