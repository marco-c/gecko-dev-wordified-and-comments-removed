#
ifndef
vm_Stack_h
#
define
vm_Stack_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
ifdef
CHECK_OSIPOINT_REGISTERS
#
include
"
jit
/
Registers
.
h
"
#
endif
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
wasm
/
WasmFrameIter
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
namespace
JS
{
namespace
dbg
{
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wattributes
"
#
endif
class
JS_PUBLIC_API
(
AutoEntryMonitor
)
;
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
pop
#
endif
}
}
namespace
js
{
class
InterpreterRegs
;
class
CallObject
;
class
FrameIter
;
class
EnvironmentObject
;
class
ScriptFrameIter
;
class
GeckoProfilerRuntime
;
class
InterpreterFrame
;
class
LexicalEnvironmentObject
;
class
EnvironmentIter
;
class
EnvironmentCoordinate
;
class
SavedFrame
;
namespace
jit
{
class
CommonFrameLayout
;
}
namespace
wasm
{
class
DebugFrame
;
class
Instance
;
}
enum
MaybeCheckAliasing
{
CHECK_ALIASING
=
true
DONT_CHECK_ALIASING
=
false
}
;
enum
MaybeCheckTDZ
{
CheckTDZ
=
true
DontCheckTDZ
=
false
}
;
namespace
jit
{
class
BaselineFrame
;
class
RematerializedFrame
;
}
class
AbstractFramePtr
{
friend
class
FrameIter
;
uintptr_t
ptr_
;
enum
{
Tag_InterpreterFrame
=
0x1
Tag_BaselineFrame
=
0x2
Tag_RematerializedFrame
=
0x3
Tag_WasmDebugFrame
=
0x4
TagMask
=
0x7
}
;
public
:
AbstractFramePtr
(
)
:
ptr_
(
0
)
{
}
MOZ_IMPLICIT
AbstractFramePtr
(
InterpreterFrame
*
fp
)
:
ptr_
(
fp
?
uintptr_t
(
fp
)
|
Tag_InterpreterFrame
:
0
)
{
MOZ_ASSERT_IF
(
fp
asInterpreterFrame
(
)
=
=
fp
)
;
}
MOZ_IMPLICIT
AbstractFramePtr
(
jit
:
:
BaselineFrame
*
fp
)
:
ptr_
(
fp
?
uintptr_t
(
fp
)
|
Tag_BaselineFrame
:
0
)
{
MOZ_ASSERT_IF
(
fp
asBaselineFrame
(
)
=
=
fp
)
;
}
MOZ_IMPLICIT
AbstractFramePtr
(
jit
:
:
RematerializedFrame
*
fp
)
:
ptr_
(
fp
?
uintptr_t
(
fp
)
|
Tag_RematerializedFrame
:
0
)
{
MOZ_ASSERT_IF
(
fp
asRematerializedFrame
(
)
=
=
fp
)
;
}
MOZ_IMPLICIT
AbstractFramePtr
(
wasm
:
:
DebugFrame
*
fp
)
:
ptr_
(
fp
?
uintptr_t
(
fp
)
|
Tag_WasmDebugFrame
:
0
)
{
static_assert
(
wasm
:
:
DebugFrame
:
:
Alignment
>
=
TagMask
"
aligned
"
)
;
MOZ_ASSERT_IF
(
fp
asWasmDebugFrame
(
)
=
=
fp
)
;
}
static
AbstractFramePtr
FromRaw
(
void
*
raw
)
{
AbstractFramePtr
frame
;
frame
.
ptr_
=
uintptr_t
(
raw
)
;
return
frame
;
}
bool
isInterpreterFrame
(
)
const
{
return
(
ptr_
&
TagMask
)
=
=
Tag_InterpreterFrame
;
}
InterpreterFrame
*
asInterpreterFrame
(
)
const
{
MOZ_ASSERT
(
isInterpreterFrame
(
)
)
;
InterpreterFrame
*
res
=
(
InterpreterFrame
*
)
(
ptr_
&
~
TagMask
)
;
MOZ_ASSERT
(
res
)
;
return
res
;
}
bool
isBaselineFrame
(
)
const
{
return
(
ptr_
&
TagMask
)
=
=
Tag_BaselineFrame
;
}
jit
:
:
BaselineFrame
*
asBaselineFrame
(
)
const
{
MOZ_ASSERT
(
isBaselineFrame
(
)
)
;
jit
:
:
BaselineFrame
*
res
=
(
jit
:
:
BaselineFrame
*
)
(
ptr_
&
~
TagMask
)
;
MOZ_ASSERT
(
res
)
;
return
res
;
}
bool
isRematerializedFrame
(
)
const
{
return
(
ptr_
&
TagMask
)
=
=
Tag_RematerializedFrame
;
}
jit
:
:
RematerializedFrame
*
asRematerializedFrame
(
)
const
{
MOZ_ASSERT
(
isRematerializedFrame
(
)
)
;
jit
:
:
RematerializedFrame
*
res
=
(
jit
:
:
RematerializedFrame
*
)
(
ptr_
&
~
TagMask
)
;
MOZ_ASSERT
(
res
)
;
return
res
;
}
bool
isWasmDebugFrame
(
)
const
{
return
(
ptr_
&
TagMask
)
=
=
Tag_WasmDebugFrame
;
}
wasm
:
:
DebugFrame
*
asWasmDebugFrame
(
)
const
{
MOZ_ASSERT
(
isWasmDebugFrame
(
)
)
;
wasm
:
:
DebugFrame
*
res
=
(
wasm
:
:
DebugFrame
*
)
(
ptr_
&
~
TagMask
)
;
MOZ_ASSERT
(
res
)
;
return
res
;
}
void
*
raw
(
)
const
{
return
reinterpret_cast
<
void
*
>
(
ptr_
)
;
}
bool
operator
=
=
(
const
AbstractFramePtr
&
other
)
const
{
return
ptr_
=
=
other
.
ptr_
;
}
bool
operator
!
=
(
const
AbstractFramePtr
&
other
)
const
{
return
ptr_
!
=
other
.
ptr_
;
}
explicit
operator
bool
(
)
const
{
return
!
!
ptr_
;
}
inline
JSObject
*
environmentChain
(
)
const
;
inline
CallObject
&
callObj
(
)
const
;
inline
bool
initFunctionEnvironmentObjects
(
JSContext
*
cx
)
;
inline
bool
pushVarEnvironment
(
JSContext
*
cx
HandleScope
scope
)
;
template
<
typename
SpecificEnvironment
>
inline
void
pushOnEnvironmentChain
(
SpecificEnvironment
&
env
)
;
template
<
typename
SpecificEnvironment
>
inline
void
popOffEnvironmentChain
(
)
;
inline
JS
:
:
Realm
*
realm
(
)
const
;
inline
bool
hasInitialEnvironment
(
)
const
;
inline
bool
isGlobalFrame
(
)
const
;
inline
bool
isModuleFrame
(
)
const
;
inline
bool
isEvalFrame
(
)
const
;
inline
bool
isDebuggerEvalFrame
(
)
const
;
inline
bool
hasScript
(
)
const
;
inline
JSScript
*
script
(
)
const
;
inline
wasm
:
:
Instance
*
wasmInstance
(
)
const
;
inline
GlobalObject
*
global
(
)
const
;
inline
JSFunction
*
callee
(
)
const
;
inline
Value
calleev
(
)
const
;
inline
Value
&
thisArgument
(
)
const
;
inline
bool
isConstructing
(
)
const
;
inline
Value
newTarget
(
)
const
;
inline
bool
debuggerNeedsCheckPrimitiveReturn
(
)
const
;
inline
bool
isFunctionFrame
(
)
const
;
inline
bool
isNonStrictDirectEvalFrame
(
)
const
;
inline
bool
isStrictEvalFrame
(
)
const
;
inline
unsigned
numActualArgs
(
)
const
;
inline
unsigned
numFormalArgs
(
)
const
;
inline
Value
*
argv
(
)
const
;
inline
bool
hasArgs
(
)
const
;
inline
bool
hasArgsObj
(
)
const
;
inline
ArgumentsObject
&
argsObj
(
)
const
;
inline
void
initArgsObj
(
ArgumentsObject
&
argsobj
)
const
;
inline
Value
&
unaliasedLocal
(
uint32_t
i
)
;
inline
Value
&
unaliasedFormal
(
unsigned
i
MaybeCheckAliasing
checkAliasing
=
CHECK_ALIASING
)
;
inline
Value
&
unaliasedActual
(
unsigned
i
MaybeCheckAliasing
checkAliasing
=
CHECK_ALIASING
)
;
template
<
class
Op
>
inline
void
unaliasedForEachActual
(
JSContext
*
cx
Op
op
)
;
inline
bool
prevUpToDate
(
)
const
;
inline
void
setPrevUpToDate
(
)
const
;
inline
void
unsetPrevUpToDate
(
)
const
;
inline
bool
isDebuggee
(
)
const
;
inline
void
setIsDebuggee
(
)
;
inline
void
unsetIsDebuggee
(
)
;
inline
HandleValue
returnValue
(
)
const
;
inline
void
setReturnValue
(
const
Value
&
rval
)
const
;
friend
void
GDBTestInitAbstractFramePtr
(
AbstractFramePtr
&
InterpreterFrame
*
)
;
friend
void
GDBTestInitAbstractFramePtr
(
AbstractFramePtr
&
jit
:
:
BaselineFrame
*
)
;
friend
void
GDBTestInitAbstractFramePtr
(
AbstractFramePtr
&
jit
:
:
RematerializedFrame
*
)
;
friend
void
GDBTestInitAbstractFramePtr
(
AbstractFramePtr
&
frame
wasm
:
:
DebugFrame
*
ptr
)
;
}
;
class
NullFramePtr
:
public
AbstractFramePtr
{
public
:
NullFramePtr
(
)
:
AbstractFramePtr
(
)
{
}
}
;
enum
MaybeConstruct
{
NO_CONSTRUCT
=
false
CONSTRUCT
=
true
}
;
class
InterpreterFrame
{
enum
Flags
:
uint32_t
{
CONSTRUCTING
=
0x1
RESUMED_GENERATOR
=
0x2
HAS_INITIAL_ENV
=
0x4
HAS_ARGS_OBJ
=
0x8
HAS_RVAL
=
0x10
PREV_UP_TO_DATE
=
0x20
DEBUGGEE
=
0x40
HAS_PUSHED_PROF_FRAME
=
0x80
RUNNING_IN_JIT
=
0x100
HAS_CACHED_SAVED_FRAME
=
0x200
}
;
mutable
uint32_t
flags_
;
uint32_t
nactual_
;
JSScript
*
script_
;
JSObject
*
envChain_
;
Value
rval_
;
ArgumentsObject
*
argsObj_
;
InterpreterFrame
*
prev_
;
jsbytecode
*
prevpc_
;
Value
*
prevsp_
;
void
*
unused
;
AbstractFramePtr
evalInFramePrev_
;
Value
*
argv_
;
LifoAlloc
:
:
Mark
mark_
;
static
void
staticAsserts
(
)
{
JS_STATIC_ASSERT
(
offsetof
(
InterpreterFrame
rval_
)
%
sizeof
(
Value
)
=
=
0
)
;
JS_STATIC_ASSERT
(
sizeof
(
InterpreterFrame
)
%
sizeof
(
Value
)
=
=
0
)
;
}
Value
*
slots
(
)
const
{
return
(
Value
*
)
(
this
+
1
)
;
}
Value
*
base
(
)
const
{
return
slots
(
)
+
script
(
)
-
>
nfixed
(
)
;
}
friend
class
FrameIter
;
friend
class
InterpreterRegs
;
friend
class
InterpreterStack
;
friend
class
jit
:
:
BaselineFrame
;
void
initCallFrame
(
InterpreterFrame
*
prev
jsbytecode
*
prevpc
Value
*
prevsp
JSFunction
&
callee
JSScript
*
script
Value
*
argv
uint32_t
nactual
MaybeConstruct
constructing
)
;
void
initExecuteFrame
(
JSContext
*
cx
HandleScript
script
AbstractFramePtr
prev
const
Value
&
newTargetValue
HandleObject
envChain
)
;
public
:
bool
prologue
(
JSContext
*
cx
)
;
void
epilogue
(
JSContext
*
cx
jsbytecode
*
pc
)
;
bool
checkReturn
(
JSContext
*
cx
HandleValue
thisv
)
;
bool
initFunctionEnvironmentObjects
(
JSContext
*
cx
)
;
void
initLocals
(
)
;
bool
isGlobalFrame
(
)
const
{
return
script_
-
>
isGlobalCode
(
)
;
}
bool
isModuleFrame
(
)
const
{
return
script_
-
>
module
(
)
;
}
bool
isEvalFrame
(
)
const
{
return
script_
-
>
isForEval
(
)
;
}
bool
isFunctionFrame
(
)
const
{
return
script_
-
>
functionNonDelazifying
(
)
;
}
inline
bool
isStrictEvalFrame
(
)
const
{
return
isEvalFrame
(
)
&
&
script
(
)
-
>
strict
(
)
;
}
bool
isNonStrictEvalFrame
(
)
const
{
return
isEvalFrame
(
)
&
&
!
script
(
)
-
>
strict
(
)
;
}
bool
isNonGlobalEvalFrame
(
)
const
;
bool
isNonStrictDirectEvalFrame
(
)
const
{
return
isNonStrictEvalFrame
(
)
&
&
isNonGlobalEvalFrame
(
)
;
}
InterpreterFrame
*
prev
(
)
const
{
return
prev_
;
}
AbstractFramePtr
evalInFramePrev
(
)
const
{
MOZ_ASSERT
(
isEvalFrame
(
)
)
;
return
evalInFramePrev_
;
}
inline
Value
&
unaliasedLocal
(
uint32_t
i
)
;
bool
hasArgs
(
)
const
{
return
isFunctionFrame
(
)
;
}
inline
Value
&
unaliasedFormal
(
unsigned
i
MaybeCheckAliasing
=
CHECK_ALIASING
)
;
inline
Value
&
unaliasedActual
(
unsigned
i
MaybeCheckAliasing
=
CHECK_ALIASING
)
;
template
<
class
Op
>
inline
void
unaliasedForEachActual
(
Op
op
)
;
unsigned
numFormalArgs
(
)
const
{
MOZ_ASSERT
(
hasArgs
(
)
)
;
return
callee
(
)
.
nargs
(
)
;
}
unsigned
numActualArgs
(
)
const
{
MOZ_ASSERT
(
hasArgs
(
)
)
;
return
nactual_
;
}
Value
*
argv
(
)
const
{
MOZ_ASSERT
(
hasArgs
(
)
)
;
return
argv_
;
}
ArgumentsObject
&
argsObj
(
)
const
;
void
initArgsObj
(
ArgumentsObject
&
argsobj
)
;
ArrayObject
*
createRestParameter
(
JSContext
*
cx
)
;
inline
HandleObject
environmentChain
(
)
const
;
inline
EnvironmentObject
&
aliasedEnvironment
(
EnvironmentCoordinate
ec
)
const
;
inline
GlobalObject
&
global
(
)
const
;
inline
CallObject
&
callObj
(
)
const
;
inline
JSObject
&
varObj
(
)
const
;
inline
LexicalEnvironmentObject
&
extensibleLexicalEnvironment
(
)
const
;
template
<
typename
SpecificEnvironment
>
inline
void
pushOnEnvironmentChain
(
SpecificEnvironment
&
env
)
;
template
<
typename
SpecificEnvironment
>
inline
void
popOffEnvironmentChain
(
)
;
inline
void
replaceInnermostEnvironment
(
EnvironmentObject
&
env
)
;
bool
pushVarEnvironment
(
JSContext
*
cx
HandleScope
scope
)
;
bool
pushLexicalEnvironment
(
JSContext
*
cx
Handle
<
LexicalScope
*
>
scope
)
;
bool
freshenLexicalEnvironment
(
JSContext
*
cx
)
;
bool
recreateLexicalEnvironment
(
JSContext
*
cx
)
;
JSScript
*
script
(
)
const
{
return
script_
;
}
jsbytecode
*
prevpc
(
)
{
MOZ_ASSERT
(
prev_
)
;
return
prevpc_
;
}
Value
*
prevsp
(
)
{
MOZ_ASSERT
(
prev_
)
;
return
prevsp_
;
}
Value
&
thisArgument
(
)
const
{
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
return
argv
(
)
[
-
1
]
;
}
JSFunction
&
callee
(
)
const
{
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
return
calleev
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
const
Value
&
calleev
(
)
const
{
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
return
argv
(
)
[
-
2
]
;
}
Value
newTarget
(
)
const
{
if
(
isEvalFrame
(
)
)
return
(
(
Value
*
)
this
)
[
-
1
]
;
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
if
(
callee
(
)
.
isArrow
(
)
)
return
callee
(
)
.
getExtendedSlot
(
FunctionExtended
:
:
ARROW_NEWTARGET_SLOT
)
;
if
(
isConstructing
(
)
)
{
unsigned
pushedArgs
=
Max
(
numFormalArgs
(
)
numActualArgs
(
)
)
;
return
argv
(
)
[
pushedArgs
]
;
}
return
UndefinedValue
(
)
;
}
bool
hasPushedGeckoProfilerFrame
(
)
{
return
!
!
(
flags_
&
HAS_PUSHED_PROF_FRAME
)
;
}
void
setPushedGeckoProfilerFrame
(
)
{
flags_
|
=
HAS_PUSHED_PROF_FRAME
;
}
void
unsetPushedGeckoProfilerFrame
(
)
{
flags_
&
=
~
HAS_PUSHED_PROF_FRAME
;
}
bool
hasReturnValue
(
)
const
{
return
flags_
&
HAS_RVAL
;
}
MutableHandleValue
returnValue
(
)
{
if
(
!
hasReturnValue
(
)
)
rval_
.
setUndefined
(
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
rval_
)
;
}
void
markReturnValue
(
)
{
flags_
|
=
HAS_RVAL
;
}
void
setReturnValue
(
const
Value
&
v
)
{
rval_
=
v
;
markReturnValue
(
)
;
}
void
clearReturnValue
(
)
{
rval_
.
setUndefined
(
)
;
markReturnValue
(
)
;
}
void
resumeGeneratorFrame
(
JSObject
*
envChain
)
{
MOZ_ASSERT
(
script
(
)
-
>
isGenerator
(
)
|
|
script
(
)
-
>
isAsync
(
)
)
;
MOZ_ASSERT
(
isFunctionFrame
(
)
)
;
flags_
|
=
HAS_INITIAL_ENV
;
envChain_
=
envChain
;
}
bool
isConstructing
(
)
const
{
return
!
!
(
flags_
&
CONSTRUCTING
)
;
}
void
setResumedGenerator
(
)
{
flags_
|
=
RESUMED_GENERATOR
;
}
bool
isResumedGenerator
(
)
const
{
return
!
!
(
flags_
&
RESUMED_GENERATOR
)
;
}
inline
bool
hasInitialEnvironment
(
)
const
;
bool
hasInitialEnvironmentUnchecked
(
)
const
{
return
flags_
&
HAS_INITIAL_ENV
;
}
bool
hasArgsObj
(
)
const
{
MOZ_ASSERT
(
script
(
)
-
>
needsArgsObj
(
)
)
;
return
flags_
&
HAS_ARGS_OBJ
;
}
bool
isDebuggerEvalFrame
(
)
const
{
return
isEvalFrame
(
)
&
&
!
!
evalInFramePrev_
;
}
bool
prevUpToDate
(
)
const
{
return
!
!
(
flags_
&
PREV_UP_TO_DATE
)
;
}
void
setPrevUpToDate
(
)
{
flags_
|
=
PREV_UP_TO_DATE
;
}
void
unsetPrevUpToDate
(
)
{
flags_
&
=
~
PREV_UP_TO_DATE
;
}
bool
isDebuggee
(
)
const
{
return
!
!
(
flags_
&
DEBUGGEE
)
;
}
void
setIsDebuggee
(
)
{
flags_
|
=
DEBUGGEE
;
}
inline
void
unsetIsDebuggee
(
)
;
bool
hasCachedSavedFrame
(
)
const
{
return
flags_
&
HAS_CACHED_SAVED_FRAME
;
}
void
setHasCachedSavedFrame
(
)
{
flags_
|
=
HAS_CACHED_SAVED_FRAME
;
}
void
clearHasCachedSavedFrame
(
)
{
flags_
&
=
~
HAS_CACHED_SAVED_FRAME
;
}
public
:
void
trace
(
JSTracer
*
trc
Value
*
sp
jsbytecode
*
pc
)
;
void
traceValues
(
JSTracer
*
trc
unsigned
start
unsigned
end
)
;
bool
runningInJit
(
)
const
{
return
!
!
(
flags_
&
RUNNING_IN_JIT
)
;
}
void
setRunningInJit
(
)
{
flags_
|
=
RUNNING_IN_JIT
;
}
void
clearRunningInJit
(
)
{
flags_
&
=
~
RUNNING_IN_JIT
;
}
}
;
class
InterpreterRegs
{
public
:
Value
*
sp
;
jsbytecode
*
pc
;
private
:
InterpreterFrame
*
fp_
;
public
:
InterpreterFrame
*
fp
(
)
const
{
return
fp_
;
}
unsigned
stackDepth
(
)
const
{
MOZ_ASSERT
(
sp
>
=
fp_
-
>
base
(
)
)
;
return
sp
-
fp_
-
>
base
(
)
;
}
Value
*
spForStackDepth
(
unsigned
depth
)
const
{
MOZ_ASSERT
(
fp_
-
>
script
(
)
-
>
nfixed
(
)
+
depth
<
=
fp_
-
>
script
(
)
-
>
nslots
(
)
)
;
return
fp_
-
>
base
(
)
+
depth
;
}
void
rebaseFromTo
(
const
InterpreterRegs
&
from
InterpreterFrame
&
to
)
{
fp_
=
&
to
;
sp
=
to
.
slots
(
)
+
(
from
.
sp
-
from
.
fp_
-
>
slots
(
)
)
;
pc
=
from
.
pc
;
MOZ_ASSERT
(
fp_
)
;
}
void
popInlineFrame
(
)
{
pc
=
fp_
-
>
prevpc
(
)
;
unsigned
spForNewTarget
=
fp_
-
>
isResumedGenerator
(
)
?
0
:
fp_
-
>
isConstructing
(
)
;
sp
=
fp_
-
>
prevsp
(
)
-
fp_
-
>
numActualArgs
(
)
-
1
-
spForNewTarget
;
fp_
=
fp_
-
>
prev
(
)
;
MOZ_ASSERT
(
fp_
)
;
}
void
prepareToRun
(
InterpreterFrame
&
fp
JSScript
*
script
)
{
pc
=
script
-
>
code
(
)
;
sp
=
fp
.
slots
(
)
+
script
-
>
nfixed
(
)
;
fp_
=
&
fp
;
}
void
setToEndOfScript
(
)
;
MutableHandleValue
stackHandleAt
(
int
i
)
{
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
sp
[
i
]
)
;
}
HandleValue
stackHandleAt
(
int
i
)
const
{
return
HandleValue
:
:
fromMarkedLocation
(
&
sp
[
i
]
)
;
}
friend
void
GDBTestInitInterpreterRegs
(
InterpreterRegs
&
js
:
:
InterpreterFrame
*
JS
:
:
Value
*
uint8_t
*
)
;
}
;
class
InterpreterStack
{
friend
class
InterpreterActivation
;
static
const
size_t
DEFAULT_CHUNK_SIZE
=
4
*
1024
;
LifoAlloc
allocator_
;
static
const
size_t
MAX_FRAMES
=
50
*
1000
;
static
const
size_t
MAX_FRAMES_TRUSTED
=
MAX_FRAMES
+
1000
;
size_t
frameCount_
;
inline
uint8_t
*
allocateFrame
(
JSContext
*
cx
size_t
size
)
;
inline
InterpreterFrame
*
getCallFrame
(
JSContext
*
cx
const
CallArgs
&
args
HandleScript
script
MaybeConstruct
constructing
Value
*
*
pargv
)
;
void
releaseFrame
(
InterpreterFrame
*
fp
)
{
frameCount_
-
-
;
allocator_
.
release
(
fp
-
>
mark_
)
;
}
public
:
InterpreterStack
(
)
:
allocator_
(
DEFAULT_CHUNK_SIZE
)
frameCount_
(
0
)
{
}
~
InterpreterStack
(
)
{
MOZ_ASSERT
(
frameCount_
=
=
0
)
;
}
InterpreterFrame
*
pushExecuteFrame
(
JSContext
*
cx
HandleScript
script
const
Value
&
newTargetValue
HandleObject
envChain
AbstractFramePtr
evalInFrame
)
;
InterpreterFrame
*
pushInvokeFrame
(
JSContext
*
cx
const
CallArgs
&
args
MaybeConstruct
constructing
)
;
bool
pushInlineFrame
(
JSContext
*
cx
InterpreterRegs
&
regs
const
CallArgs
&
args
HandleScript
script
MaybeConstruct
constructing
)
;
void
popInlineFrame
(
InterpreterRegs
&
regs
)
;
bool
resumeGeneratorCallFrame
(
JSContext
*
cx
InterpreterRegs
&
regs
HandleFunction
callee
HandleObject
envChain
)
;
inline
void
purge
(
JSRuntime
*
rt
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
allocator_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
void
TraceInterpreterActivations
(
JSContext
*
cx
JSTracer
*
trc
)
;
class
AnyInvokeArgs
:
public
JS
:
:
CallArgs
{
}
;
class
AnyConstructArgs
:
public
JS
:
:
CallArgs
{
void
setCallee
(
const
Value
&
v
)
=
delete
;
void
setThis
(
const
Value
&
v
)
=
delete
;
MutableHandleValue
newTarget
(
)
const
=
delete
;
MutableHandleValue
rval
(
)
const
=
delete
;
}
;
namespace
detail
{
template
<
MaybeConstruct
Construct
>
class
GenericArgsBase
:
public
mozilla
:
:
Conditional
<
Construct
AnyConstructArgs
AnyInvokeArgs
>
:
:
Type
{
protected
:
AutoValueVector
v_
;
explicit
GenericArgsBase
(
JSContext
*
cx
)
:
v_
(
cx
)
{
}
public
:
bool
init
(
JSContext
*
cx
unsigned
argc
)
{
if
(
argc
>
ARGS_LENGTH_MAX
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TOO_MANY_ARGUMENTS
)
;
return
false
;
}
size_t
len
=
2
+
argc
+
uint32_t
(
Construct
)
;
MOZ_ASSERT
(
len
>
argc
)
;
if
(
!
v_
.
resize
(
len
)
)
return
false
;
*
static_cast
<
JS
:
:
CallArgs
*
>
(
this
)
=
CallArgsFromVp
(
argc
v_
.
begin
(
)
)
;
this
-
>
constructing_
=
Construct
;
if
(
Construct
)
this
-
>
CallArgs
:
:
setThis
(
MagicValue
(
JS_IS_CONSTRUCTING
)
)
;
return
true
;
}
}
;
template
<
MaybeConstruct
Construct
size_t
N
>
class
FixedArgsBase
:
public
mozilla
:
:
Conditional
<
Construct
AnyConstructArgs
AnyInvokeArgs
>
:
:
Type
{
static_assert
(
N
<
=
ARGS_LENGTH_MAX
"
o
/
~
too
many
args
o
/
~
"
)
;
protected
:
JS
:
:
AutoValueArray
<
2
+
N
+
uint32_t
(
Construct
)
>
v_
;
explicit
FixedArgsBase
(
JSContext
*
cx
)
:
v_
(
cx
)
{
*
static_cast
<
JS
:
:
CallArgs
*
>
(
this
)
=
CallArgsFromVp
(
N
v_
.
begin
(
)
)
;
this
-
>
constructing_
=
Construct
;
if
(
Construct
)
this
-
>
CallArgs
:
:
setThis
(
MagicValue
(
JS_IS_CONSTRUCTING
)
)
;
}
}
;
}
class
InvokeArgs
:
public
detail
:
:
GenericArgsBase
<
NO_CONSTRUCT
>
{
using
Base
=
detail
:
:
GenericArgsBase
<
NO_CONSTRUCT
>
;
public
:
explicit
InvokeArgs
(
JSContext
*
cx
)
:
Base
(
cx
)
{
}
}
;
class
InvokeArgsMaybeIgnoresReturnValue
:
public
detail
:
:
GenericArgsBase
<
NO_CONSTRUCT
>
{
using
Base
=
detail
:
:
GenericArgsBase
<
NO_CONSTRUCT
>
;
public
:
explicit
InvokeArgsMaybeIgnoresReturnValue
(
JSContext
*
cx
bool
ignoresReturnValue
)
:
Base
(
cx
)
{
this
-
>
ignoresReturnValue_
=
ignoresReturnValue
;
}
}
;
template
<
size_t
N
>
class
FixedInvokeArgs
:
public
detail
:
:
FixedArgsBase
<
NO_CONSTRUCT
N
>
{
using
Base
=
detail
:
:
FixedArgsBase
<
NO_CONSTRUCT
N
>
;
public
:
explicit
FixedInvokeArgs
(
JSContext
*
cx
)
:
Base
(
cx
)
{
}
}
;
class
ConstructArgs
:
public
detail
:
:
GenericArgsBase
<
CONSTRUCT
>
{
using
Base
=
detail
:
:
GenericArgsBase
<
CONSTRUCT
>
;
public
:
explicit
ConstructArgs
(
JSContext
*
cx
)
:
Base
(
cx
)
{
}
}
;
template
<
size_t
N
>
class
FixedConstructArgs
:
public
detail
:
:
FixedArgsBase
<
CONSTRUCT
N
>
{
using
Base
=
detail
:
:
FixedArgsBase
<
CONSTRUCT
N
>
;
public
:
explicit
FixedConstructArgs
(
JSContext
*
cx
)
:
Base
(
cx
)
{
}
}
;
template
<
class
Args
class
Arraylike
>
inline
bool
FillArgumentsFromArraylike
(
JSContext
*
cx
Args
&
args
const
Arraylike
&
arraylike
)
{
uint32_t
len
=
arraylike
.
length
(
)
;
if
(
!
args
.
init
(
cx
len
)
)
return
false
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
args
[
i
]
.
set
(
arraylike
[
i
]
)
;
return
true
;
}
}
namespace
mozilla
{
template
<
>
struct
DefaultHasher
<
js
:
:
AbstractFramePtr
>
{
typedef
js
:
:
AbstractFramePtr
Lookup
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
key
)
{
return
mozilla
:
:
HashGeneric
(
key
.
raw
(
)
)
;
}
static
bool
match
(
const
js
:
:
AbstractFramePtr
&
k
const
Lookup
&
l
)
{
return
k
=
=
l
;
}
}
;
}
namespace
js
{
class
LiveSavedFrameCache
{
public
:
class
FramePtr
{
using
Ptr
=
mozilla
:
:
Variant
<
InterpreterFrame
*
jit
:
:
CommonFrameLayout
*
jit
:
:
RematerializedFrame
*
wasm
:
:
DebugFrame
*
>
;
Ptr
ptr
;
template
<
typename
Frame
>
explicit
FramePtr
(
Frame
ptr
)
:
ptr
(
ptr
)
{
}
struct
HasCachedMatcher
;
struct
SetHasCachedMatcher
;
struct
ClearHasCachedMatcher
;
public
:
static
inline
mozilla
:
:
Maybe
<
FramePtr
>
create
(
const
FrameIter
&
iter
)
;
static
inline
FramePtr
create
(
AbstractFramePtr
abstractFramePtr
)
;
inline
bool
hasCachedSavedFrame
(
)
const
;
inline
void
setHasCachedSavedFrame
(
)
;
inline
void
clearHasCachedSavedFrame
(
)
;
inline
bool
isInterpreterFrame
(
)
const
{
return
ptr
.
is
<
InterpreterFrame
*
>
(
)
;
}
inline
InterpreterFrame
&
asInterpreterFrame
(
)
const
{
return
*
ptr
.
as
<
InterpreterFrame
*
>
(
)
;
}
bool
operator
=
=
(
const
FramePtr
&
rhs
)
const
{
return
rhs
.
ptr
=
=
this
-
>
ptr
;
}
bool
operator
!
=
(
const
FramePtr
&
rhs
)
const
{
return
!
(
rhs
=
=
*
this
)
;
}
}
;
private
:
class
Key
{
FramePtr
framePtr
;
public
:
MOZ_IMPLICIT
Key
(
const
FramePtr
&
framePtr
)
:
framePtr
(
framePtr
)
{
}
bool
operator
=
=
(
const
Key
&
rhs
)
const
{
return
rhs
.
framePtr
=
=
this
-
>
framePtr
;
}
bool
operator
!
=
(
const
Key
&
rhs
)
const
{
return
!
(
rhs
=
=
*
this
)
;
}
}
;
struct
Entry
{
const
Key
key
;
const
jsbytecode
*
pc
;
HeapPtr
<
SavedFrame
*
>
savedFrame
;
Entry
(
const
Key
&
key
const
jsbytecode
*
pc
SavedFrame
*
savedFrame
)
:
key
(
key
)
pc
(
pc
)
savedFrame
(
savedFrame
)
{
}
}
;
using
EntryVector
=
Vector
<
Entry
0
SystemAllocPolicy
>
;
EntryVector
*
frames
;
LiveSavedFrameCache
(
const
LiveSavedFrameCache
&
)
=
delete
;
LiveSavedFrameCache
&
operator
=
(
const
LiveSavedFrameCache
&
)
=
delete
;
public
:
explicit
LiveSavedFrameCache
(
)
:
frames
(
nullptr
)
{
}
LiveSavedFrameCache
(
LiveSavedFrameCache
&
&
rhs
)
:
frames
(
rhs
.
frames
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
disallowed
"
)
;
rhs
.
frames
=
nullptr
;
}
~
LiveSavedFrameCache
(
)
{
if
(
frames
)
{
js_delete
(
frames
)
;
frames
=
nullptr
;
}
}
bool
initialized
(
)
const
{
return
!
!
frames
;
}
bool
init
(
JSContext
*
cx
)
{
frames
=
js_new
<
EntryVector
>
(
)
;
if
(
!
frames
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
trace
(
JSTracer
*
trc
)
;
void
find
(
JSContext
*
cx
FramePtr
&
framePtr
const
jsbytecode
*
pc
MutableHandleSavedFrame
frame
)
const
;
void
findWithoutInvalidation
(
const
FramePtr
&
framePtr
MutableHandleSavedFrame
frame
)
const
;
bool
insert
(
JSContext
*
cx
FramePtr
&
framePtr
const
jsbytecode
*
pc
HandleSavedFrame
savedFrame
)
;
void
clear
(
)
{
if
(
frames
)
frames
-
>
clear
(
)
;
}
}
;
static_assert
(
sizeof
(
LiveSavedFrameCache
)
=
=
sizeof
(
uintptr_t
)
"
Every
js
:
:
Activation
has
a
LiveSavedFrameCache
so
we
need
to
be
pretty
careful
"
"
about
avoiding
bloat
.
If
you
'
re
adding
members
to
LiveSavedFrameCache
maybe
you
"
"
should
consider
figuring
out
a
way
to
make
js
:
:
Activation
have
a
"
"
LiveSavedFrameCache
*
instead
of
a
Rooted
<
LiveSavedFrameCache
>
.
"
)
;
class
InterpreterActivation
;
namespace
jit
{
class
JitActivation
;
}
class
MOZ_RAII
ActivationEntryMonitor
{
JSContext
*
cx_
;
JS
:
:
dbg
:
:
AutoEntryMonitor
*
entryMonitor_
;
explicit
ActivationEntryMonitor
(
JSContext
*
cx
)
;
ActivationEntryMonitor
(
const
ActivationEntryMonitor
&
other
)
=
delete
;
void
operator
=
(
const
ActivationEntryMonitor
&
other
)
=
delete
;
Value
asyncStack
(
JSContext
*
cx
)
;
public
:
ActivationEntryMonitor
(
JSContext
*
cx
InterpreterFrame
*
entryFrame
)
;
ActivationEntryMonitor
(
JSContext
*
cx
jit
:
:
CalleeToken
entryToken
)
;
inline
~
ActivationEntryMonitor
(
)
;
}
;
class
Activation
{
protected
:
JSContext
*
cx_
;
JS
:
:
Compartment
*
compartment_
;
Activation
*
prev_
;
Activation
*
prevProfiling_
;
size_t
hideScriptedCallerCount_
;
Rooted
<
LiveSavedFrameCache
>
frameCache_
;
Rooted
<
SavedFrame
*
>
asyncStack_
;
const
char
*
asyncCause_
;
bool
asyncCallIsExplicit_
;
enum
Kind
{
Interpreter
Jit
}
;
Kind
kind_
;
inline
Activation
(
JSContext
*
cx
Kind
kind
)
;
inline
~
Activation
(
)
;
public
:
JSContext
*
cx
(
)
const
{
return
cx_
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
compartment_
;
}
Activation
*
prev
(
)
const
{
return
prev_
;
}
Activation
*
prevProfiling
(
)
const
{
return
prevProfiling_
;
}
inline
Activation
*
mostRecentProfiling
(
)
;
bool
isInterpreter
(
)
const
{
return
kind_
=
=
Interpreter
;
}
bool
isJit
(
)
const
{
return
kind_
=
=
Jit
;
}
inline
bool
hasWasmExitFP
(
)
const
;
inline
bool
isProfiling
(
)
const
;
void
registerProfiling
(
)
;
void
unregisterProfiling
(
)
;
InterpreterActivation
*
asInterpreter
(
)
const
{
MOZ_ASSERT
(
isInterpreter
(
)
)
;
return
(
InterpreterActivation
*
)
this
;
}
jit
:
:
JitActivation
*
asJit
(
)
const
{
MOZ_ASSERT
(
isJit
(
)
)
;
return
(
jit
:
:
JitActivation
*
)
this
;
}
void
hideScriptedCaller
(
)
{
hideScriptedCallerCount_
+
+
;
}
void
unhideScriptedCaller
(
)
{
MOZ_ASSERT
(
hideScriptedCallerCount_
>
0
)
;
hideScriptedCallerCount_
-
-
;
}
bool
scriptedCallerIsHidden
(
)
const
{
return
hideScriptedCallerCount_
>
0
;
}
static
size_t
offsetOfPrev
(
)
{
return
offsetof
(
Activation
prev_
)
;
}
static
size_t
offsetOfPrevProfiling
(
)
{
return
offsetof
(
Activation
prevProfiling_
)
;
}
SavedFrame
*
asyncStack
(
)
{
return
asyncStack_
;
}
const
char
*
asyncCause
(
)
const
{
return
asyncCause_
;
}
bool
asyncCallIsExplicit
(
)
const
{
return
asyncCallIsExplicit_
;
}
inline
LiveSavedFrameCache
*
getLiveSavedFrameCache
(
JSContext
*
cx
)
;
void
clearLiveSavedFrameCache
(
)
{
frameCache_
.
get
(
)
.
clear
(
)
;
}
private
:
Activation
(
const
Activation
&
other
)
=
delete
;
void
operator
=
(
const
Activation
&
other
)
=
delete
;
}
;
static
const
jsbytecode
EnableInterruptsPseudoOpcode
=
-
1
;
static_assert
(
EnableInterruptsPseudoOpcode
>
=
JSOP_LIMIT
"
EnableInterruptsPseudoOpcode
must
be
greater
than
any
opcode
"
)
;
static_assert
(
EnableInterruptsPseudoOpcode
=
=
jsbytecode
(
-
1
)
"
EnableInterruptsPseudoOpcode
must
be
the
maximum
jsbytecode
value
"
)
;
class
InterpreterFrameIterator
;
class
RunState
;
class
InterpreterActivation
:
public
Activation
{
friend
class
js
:
:
InterpreterFrameIterator
;
InterpreterRegs
regs_
;
InterpreterFrame
*
entryFrame_
;
size_t
opMask_
;
#
ifdef
DEBUG
size_t
oldFrameCount_
;
#
endif
public
:
inline
InterpreterActivation
(
RunState
&
state
JSContext
*
cx
InterpreterFrame
*
entryFrame
)
;
inline
~
InterpreterActivation
(
)
;
inline
bool
pushInlineFrame
(
const
CallArgs
&
args
HandleScript
script
MaybeConstruct
constructing
)
;
inline
void
popInlineFrame
(
InterpreterFrame
*
frame
)
;
inline
bool
resumeGeneratorFrame
(
HandleFunction
callee
HandleObject
envChain
)
;
InterpreterFrame
*
current
(
)
const
{
return
regs_
.
fp
(
)
;
}
InterpreterRegs
&
regs
(
)
{
return
regs_
;
}
InterpreterFrame
*
entryFrame
(
)
const
{
return
entryFrame_
;
}
size_t
opMask
(
)
const
{
return
opMask_
;
}
bool
isProfiling
(
)
const
{
return
false
;
}
void
enableInterruptsIfRunning
(
JSScript
*
script
)
{
if
(
regs_
.
fp
(
)
-
>
script
(
)
=
=
script
)
enableInterruptsUnconditionally
(
)
;
}
void
enableInterruptsUnconditionally
(
)
{
opMask_
=
EnableInterruptsPseudoOpcode
;
}
void
clearInterruptsMask
(
)
{
opMask_
=
0
;
}
}
;
class
ActivationIterator
{
protected
:
Activation
*
activation_
;
public
:
explicit
ActivationIterator
(
JSContext
*
cx
)
;
ActivationIterator
&
operator
+
+
(
)
;
Activation
*
operator
-
>
(
)
const
{
return
activation_
;
}
Activation
*
activation
(
)
const
{
return
activation_
;
}
bool
done
(
)
const
{
return
activation_
=
=
nullptr
;
}
}
;
namespace
jit
{
class
BailoutFrameInfo
;
class
JitActivation
:
public
Activation
{
public
:
static
const
uintptr_t
ExitFpWasmBit
=
0x1
;
private
:
uint8_t
*
packedExitFP_
;
uint32_t
encodedWasmExitReason_
;
JitActivation
*
prevJitActivation_
;
typedef
GCVector
<
RematerializedFrame
*
>
RematerializedFrameVector
;
typedef
HashMap
<
uint8_t
*
RematerializedFrameVector
>
RematerializedFrameTable
;
js
:
:
UniquePtr
<
RematerializedFrameTable
>
rematerializedFrames_
;
typedef
Vector
<
RInstructionResults
1
>
IonRecoveryMap
;
IonRecoveryMap
ionRecovery_
;
BailoutFrameInfo
*
bailoutData_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
lastProfilingFrame_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
lastProfilingCallSite_
;
static_assert
(
sizeof
(
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
Relaxed
>
)
=
=
sizeof
(
void
*
)
"
Atomic
should
have
same
memory
format
as
underlying
type
.
"
)
;
mozilla
:
:
Maybe
<
wasm
:
:
TrapData
>
wasmTrapData_
;
void
clearRematerializedFrames
(
)
;
#
ifdef
CHECK_OSIPOINT_REGISTERS
protected
:
uint32_t
checkRegs_
=
0
;
RegisterDump
regs_
;
#
endif
public
:
explicit
JitActivation
(
JSContext
*
cx
)
;
~
JitActivation
(
)
;
bool
isProfiling
(
)
const
{
return
true
;
}
JitActivation
*
prevJitActivation
(
)
const
{
return
prevJitActivation_
;
}
static
size_t
offsetOfPrevJitActivation
(
)
{
return
offsetof
(
JitActivation
prevJitActivation_
)
;
}
bool
hasExitFP
(
)
const
{
return
!
!
packedExitFP_
;
}
uint8_t
*
jsOrWasmExitFP
(
)
const
{
return
(
uint8_t
*
)
(
uintptr_t
(
packedExitFP_
)
&
~
ExitFpWasmBit
)
;
}
static
size_t
offsetOfPackedExitFP
(
)
{
return
offsetof
(
JitActivation
packedExitFP_
)
;
}
bool
hasJSExitFP
(
)
const
{
return
!
(
uintptr_t
(
packedExitFP_
)
&
ExitFpWasmBit
)
;
}
uint8_t
*
jsExitFP
(
)
const
{
MOZ_ASSERT
(
hasJSExitFP
(
)
)
;
return
packedExitFP_
;
}
void
setJSExitFP
(
uint8_t
*
fp
)
{
packedExitFP_
=
fp
;
}
#
ifdef
CHECK_OSIPOINT_REGISTERS
void
setCheckRegs
(
bool
check
)
{
checkRegs_
=
check
;
}
static
size_t
offsetOfCheckRegs
(
)
{
return
offsetof
(
JitActivation
checkRegs_
)
;
}
static
size_t
offsetOfRegs
(
)
{
return
offsetof
(
JitActivation
regs_
)
;
}
#
endif
RematerializedFrame
*
getRematerializedFrame
(
JSContext
*
cx
const
JSJitFrameIter
&
iter
size_t
inlineDepth
=
0
)
;
RematerializedFrame
*
lookupRematerializedFrame
(
uint8_t
*
top
size_t
inlineDepth
=
0
)
;
void
removeRematerializedFramesFromDebugger
(
JSContext
*
cx
uint8_t
*
top
)
;
bool
hasRematerializedFrame
(
uint8_t
*
top
size_t
inlineDepth
=
0
)
{
return
!
!
lookupRematerializedFrame
(
top
inlineDepth
)
;
}
void
removeRematerializedFrame
(
uint8_t
*
top
)
;
void
traceRematerializedFrames
(
JSTracer
*
trc
)
;
bool
registerIonFrameRecovery
(
RInstructionResults
&
&
results
)
;
RInstructionResults
*
maybeIonFrameRecovery
(
JitFrameLayout
*
fp
)
;
void
removeIonFrameRecovery
(
JitFrameLayout
*
fp
)
;
void
traceIonRecovery
(
JSTracer
*
trc
)
;
const
BailoutFrameInfo
*
bailoutData
(
)
const
{
return
bailoutData_
;
}
void
setBailoutData
(
BailoutFrameInfo
*
bailoutData
)
;
void
cleanBailoutData
(
)
;
static
size_t
offsetOfLastProfilingFrame
(
)
{
return
offsetof
(
JitActivation
lastProfilingFrame_
)
;
}
void
*
lastProfilingFrame
(
)
{
return
lastProfilingFrame_
;
}
void
setLastProfilingFrame
(
void
*
ptr
)
{
lastProfilingFrame_
=
ptr
;
}
static
size_t
offsetOfLastProfilingCallSite
(
)
{
return
offsetof
(
JitActivation
lastProfilingCallSite_
)
;
}
void
*
lastProfilingCallSite
(
)
{
return
lastProfilingCallSite_
;
}
void
setLastProfilingCallSite
(
void
*
ptr
)
{
lastProfilingCallSite_
=
ptr
;
}
bool
hasWasmExitFP
(
)
const
{
return
uintptr_t
(
packedExitFP_
)
&
ExitFpWasmBit
;
}
wasm
:
:
Frame
*
wasmExitFP
(
)
const
{
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
return
(
wasm
:
:
Frame
*
)
(
uintptr_t
(
packedExitFP_
)
&
~
ExitFpWasmBit
)
;
}
void
setWasmExitFP
(
const
wasm
:
:
Frame
*
fp
)
{
if
(
fp
)
{
MOZ_ASSERT
(
!
(
uintptr_t
(
fp
)
&
ExitFpWasmBit
)
)
;
packedExitFP_
=
(
uint8_t
*
)
(
uintptr_t
(
fp
)
|
ExitFpWasmBit
)
;
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
}
else
{
packedExitFP_
=
nullptr
;
}
}
wasm
:
:
ExitReason
wasmExitReason
(
)
const
{
MOZ_ASSERT
(
hasWasmExitFP
(
)
)
;
return
wasm
:
:
ExitReason
:
:
Decode
(
encodedWasmExitReason_
)
;
}
static
size_t
offsetOfEncodedWasmExitReason
(
)
{
return
offsetof
(
JitActivation
encodedWasmExitReason_
)
;
}
void
startWasmTrap
(
wasm
:
:
Trap
trap
uint32_t
bytecodeOffset
const
wasm
:
:
RegisterState
&
state
)
;
void
finishWasmTrap
(
)
;
bool
isWasmTrapping
(
)
const
{
return
!
!
wasmTrapData_
;
}
const
wasm
:
:
TrapData
&
wasmTrapData
(
)
{
return
*
wasmTrapData_
;
}
}
;
class
JitActivationIterator
:
public
ActivationIterator
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
activation_
-
>
isJit
(
)
)
ActivationIterator
:
:
operator
+
+
(
)
;
}
public
:
explicit
JitActivationIterator
(
JSContext
*
cx
)
:
ActivationIterator
(
cx
)
{
settle
(
)
;
}
JitActivationIterator
&
operator
+
+
(
)
{
ActivationIterator
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
}
inline
bool
Activation
:
:
hasWasmExitFP
(
)
const
{
return
isJit
(
)
&
&
asJit
(
)
-
>
hasWasmExitFP
(
)
;
}
class
InterpreterFrameIterator
{
InterpreterActivation
*
activation_
;
InterpreterFrame
*
fp_
;
jsbytecode
*
pc_
;
Value
*
sp_
;
public
:
explicit
InterpreterFrameIterator
(
InterpreterActivation
*
activation
)
:
activation_
(
activation
)
fp_
(
nullptr
)
pc_
(
nullptr
)
sp_
(
nullptr
)
{
if
(
activation
)
{
fp_
=
activation
-
>
current
(
)
;
pc_
=
activation
-
>
regs
(
)
.
pc
;
sp_
=
activation
-
>
regs
(
)
.
sp
;
}
}
InterpreterFrame
*
frame
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
fp_
;
}
jsbytecode
*
pc
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
pc_
;
}
Value
*
sp
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
sp_
;
}
InterpreterFrameIterator
&
operator
+
+
(
)
;
bool
done
(
)
const
{
return
fp_
=
=
nullptr
;
}
}
;
class
JitFrameIter
{
protected
:
jit
:
:
JitActivation
*
act_
;
mozilla
:
:
MaybeOneOf
<
jit
:
:
JSJitFrameIter
wasm
:
:
WasmFrameIter
>
iter_
;
bool
mustUnwindActivation_
;
void
settle
(
)
;
public
:
JitFrameIter
(
)
:
act_
(
nullptr
)
iter_
(
)
mustUnwindActivation_
(
false
)
{
}
explicit
JitFrameIter
(
jit
:
:
JitActivation
*
activation
bool
mustUnwindActivation
=
false
)
;
explicit
JitFrameIter
(
const
JitFrameIter
&
another
)
;
JitFrameIter
&
operator
=
(
const
JitFrameIter
&
another
)
;
bool
isSome
(
)
const
{
return
!
iter_
.
empty
(
)
;
}
void
reset
(
)
{
MOZ_ASSERT
(
isSome
(
)
)
;
iter_
.
destroy
(
)
;
}
bool
isJSJit
(
)
const
{
return
isSome
(
)
&
&
iter_
.
constructed
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
jit
:
:
JSJitFrameIter
&
asJSJit
(
)
{
return
iter_
.
ref
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
const
jit
:
:
JSJitFrameIter
&
asJSJit
(
)
const
{
return
iter_
.
ref
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
bool
isWasm
(
)
const
{
return
isSome
(
)
&
&
iter_
.
constructed
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
wasm
:
:
WasmFrameIter
&
asWasm
(
)
{
return
iter_
.
ref
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
const
wasm
:
:
WasmFrameIter
&
asWasm
(
)
const
{
return
iter_
.
ref
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
const
jit
:
:
JitActivation
*
activation
(
)
const
{
return
act_
;
}
bool
done
(
)
const
;
void
operator
+
+
(
)
;
JS
:
:
Realm
*
realm
(
)
const
;
void
skipNonScriptedJSFrames
(
)
;
bool
isSelfHostedIgnoringInlining
(
)
const
;
}
;
class
OnlyJSJitFrameIter
:
public
JitFrameIter
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
isJSJit
(
)
)
JitFrameIter
:
:
operator
+
+
(
)
;
}
public
:
explicit
OnlyJSJitFrameIter
(
jit
:
:
JitActivation
*
act
)
;
explicit
OnlyJSJitFrameIter
(
JSContext
*
cx
)
;
explicit
OnlyJSJitFrameIter
(
const
ActivationIterator
&
cx
)
;
void
operator
+
+
(
)
{
JitFrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
}
const
jit
:
:
JSJitFrameIter
&
frame
(
)
const
{
return
asJSJit
(
)
;
}
}
;
class
FrameIter
{
public
:
enum
DebuggerEvalOption
{
FOLLOW_DEBUGGER_EVAL_PREV_LINK
IGNORE_DEBUGGER_EVAL_PREV_LINK
}
;
enum
State
{
DONE
INTERP
JIT
}
;
struct
Data
{
JSContext
*
cx_
;
DebuggerEvalOption
debuggerEvalOption_
;
JSPrincipals
*
principals_
;
State
state_
;
jsbytecode
*
pc_
;
InterpreterFrameIterator
interpFrames_
;
ActivationIterator
activations_
;
JitFrameIter
jitFrames_
;
unsigned
ionInlineFrameNo_
;
Data
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
;
Data
(
const
Data
&
other
)
;
}
;
explicit
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
=
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
;
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
JSPrincipals
*
)
;
FrameIter
(
const
FrameIter
&
iter
)
;
MOZ_IMPLICIT
FrameIter
(
const
Data
&
data
)
;
MOZ_IMPLICIT
FrameIter
(
AbstractFramePtr
frame
)
;
bool
done
(
)
const
{
return
data_
.
state_
=
=
DONE
;
}
FrameIter
&
operator
+
+
(
)
;
JS
:
:
Realm
*
realm
(
)
const
;
JS
:
:
Compartment
*
compartment
(
)
const
;
Activation
*
activation
(
)
const
{
return
data_
.
activations_
.
activation
(
)
;
}
bool
isInterp
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
INTERP
;
}
bool
isJSJit
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
JIT
&
&
data_
.
jitFrames_
.
isJSJit
(
)
;
}
bool
isWasm
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
JIT
&
&
data_
.
jitFrames_
.
isWasm
(
)
;
}
inline
bool
isIon
(
)
const
;
inline
bool
isBaseline
(
)
const
;
inline
bool
isPhysicalJitFrame
(
)
const
;
bool
isEvalFrame
(
)
const
;
bool
isFunctionFrame
(
)
const
;
bool
hasArgs
(
)
const
{
return
isFunctionFrame
(
)
;
}
ScriptSource
*
scriptSource
(
)
const
;
const
char
*
filename
(
)
const
;
const
char16_t
*
displayURL
(
)
const
;
unsigned
computeLine
(
uint32_t
*
column
=
nullptr
)
const
;
JSAtom
*
maybeFunctionDisplayAtom
(
)
const
;
bool
mutedErrors
(
)
const
;
bool
hasScript
(
)
const
{
return
!
isWasm
(
)
;
}
inline
bool
wasmDebugEnabled
(
)
const
;
inline
wasm
:
:
Instance
*
wasmInstance
(
)
const
;
inline
uint32_t
wasmFuncIndex
(
)
const
;
inline
unsigned
wasmBytecodeOffset
(
)
const
;
void
wasmUpdateBytecodeOffset
(
)
;
inline
JSScript
*
script
(
)
const
;
bool
isConstructing
(
)
const
;
jsbytecode
*
pc
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
pc_
;
}
void
updatePcQuadratic
(
)
;
JSFunction
*
calleeTemplate
(
)
const
;
JSFunction
*
callee
(
JSContext
*
cx
)
const
;
JSFunction
*
maybeCallee
(
JSContext
*
cx
)
const
{
return
isFunctionFrame
(
)
?
callee
(
cx
)
:
nullptr
;
}
bool
matchCallee
(
JSContext
*
cx
HandleFunction
fun
)
const
;
unsigned
numActualArgs
(
)
const
;
unsigned
numFormalArgs
(
)
const
;
Value
unaliasedActual
(
unsigned
i
MaybeCheckAliasing
=
CHECK_ALIASING
)
const
;
template
<
class
Op
>
inline
void
unaliasedForEachActual
(
JSContext
*
cx
Op
op
)
;
JSObject
*
environmentChain
(
JSContext
*
cx
)
const
;
CallObject
&
callObj
(
JSContext
*
cx
)
const
;
bool
hasArgsObj
(
)
const
;
ArgumentsObject
&
argsObj
(
)
const
;
Value
thisArgument
(
JSContext
*
cx
)
const
;
Value
newTarget
(
)
const
;
Value
returnValue
(
)
const
;
void
setReturnValue
(
const
Value
&
v
)
;
size_t
numFrameSlots
(
)
const
;
Value
frameSlotValue
(
size_t
index
)
const
;
bool
ensureHasRematerializedFrame
(
JSContext
*
cx
)
;
bool
hasUsableAbstractFramePtr
(
)
const
;
AbstractFramePtr
abstractFramePtr
(
)
const
;
Data
*
copyData
(
)
const
;
inline
InterpreterFrame
*
interpFrame
(
)
const
;
inline
jit
:
:
CommonFrameLayout
*
physicalJitFrame
(
)
const
;
void
*
rawFramePtr
(
)
const
;
private
:
Data
data_
;
jit
:
:
InlineFrameIterator
ionInlineFrames_
;
const
jit
:
:
JSJitFrameIter
&
jsJitFrame
(
)
const
{
return
data_
.
jitFrames_
.
asJSJit
(
)
;
}
const
wasm
:
:
WasmFrameIter
&
wasmFrame
(
)
const
{
return
data_
.
jitFrames_
.
asWasm
(
)
;
}
jit
:
:
JSJitFrameIter
&
jsJitFrame
(
)
{
return
data_
.
jitFrames_
.
asJSJit
(
)
;
}
wasm
:
:
WasmFrameIter
&
wasmFrame
(
)
{
return
data_
.
jitFrames_
.
asWasm
(
)
;
}
bool
isIonScripted
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isIonScripted
(
)
;
}
bool
principalsSubsumeFrame
(
)
const
;
void
popActivation
(
)
;
void
popInterpreterFrame
(
)
;
void
nextJitFrame
(
)
;
void
popJitFrame
(
)
;
void
settleOnActivation
(
)
;
}
;
class
ScriptFrameIter
:
public
FrameIter
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
hasScript
(
)
)
FrameIter
:
:
operator
+
+
(
)
;
}
public
:
explicit
ScriptFrameIter
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
=
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
FrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
ScriptFrameIter
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
prin
)
:
FrameIter
(
cx
debuggerEvalOption
prin
)
{
settle
(
)
;
}
ScriptFrameIter
(
const
ScriptFrameIter
&
iter
)
:
FrameIter
(
iter
)
{
settle
(
)
;
}
explicit
ScriptFrameIter
(
const
FrameIter
:
:
Data
&
data
)
:
FrameIter
(
data
)
{
settle
(
)
;
}
explicit
ScriptFrameIter
(
AbstractFramePtr
frame
)
:
FrameIter
(
frame
)
{
settle
(
)
;
}
ScriptFrameIter
&
operator
+
+
(
)
{
FrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
#
ifdef
DEBUG
bool
SelfHostedFramesVisible
(
)
;
#
else
static
inline
bool
SelfHostedFramesVisible
(
)
{
return
false
;
}
#
endif
class
NonBuiltinFrameIter
:
public
FrameIter
{
void
settle
(
)
;
public
:
explicit
NonBuiltinFrameIter
(
JSContext
*
cx
FrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
=
FrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
FrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
NonBuiltinFrameIter
(
JSContext
*
cx
FrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
:
FrameIter
(
cx
debuggerEvalOption
principals
)
{
settle
(
)
;
}
NonBuiltinFrameIter
(
JSContext
*
cx
JSPrincipals
*
principals
)
:
FrameIter
(
cx
FrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
principals
)
{
settle
(
)
;
}
explicit
NonBuiltinFrameIter
(
const
FrameIter
:
:
Data
&
data
)
:
FrameIter
(
data
)
{
}
NonBuiltinFrameIter
&
operator
+
+
(
)
{
FrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
class
NonBuiltinScriptFrameIter
:
public
ScriptFrameIter
{
void
settle
(
)
;
public
:
explicit
NonBuiltinScriptFrameIter
(
JSContext
*
cx
ScriptFrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
=
ScriptFrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
ScriptFrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
NonBuiltinScriptFrameIter
(
JSContext
*
cx
ScriptFrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
:
ScriptFrameIter
(
cx
debuggerEvalOption
principals
)
{
settle
(
)
;
}
explicit
NonBuiltinScriptFrameIter
(
const
ScriptFrameIter
:
:
Data
&
data
)
:
ScriptFrameIter
(
data
)
{
}
NonBuiltinScriptFrameIter
&
operator
+
+
(
)
{
ScriptFrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
class
AllFramesIter
:
public
FrameIter
{
public
:
explicit
AllFramesIter
(
JSContext
*
cx
)
:
FrameIter
(
cx
ScriptFrameIter
:
:
IGNORE_DEBUGGER_EVAL_PREV_LINK
)
{
}
}
;
class
AllScriptFramesIter
:
public
ScriptFrameIter
{
public
:
explicit
AllScriptFramesIter
(
JSContext
*
cx
)
:
ScriptFrameIter
(
cx
ScriptFrameIter
:
:
IGNORE_DEBUGGER_EVAL_PREV_LINK
)
{
}
}
;
inline
JSScript
*
FrameIter
:
:
script
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
hasScript
(
)
)
;
if
(
data_
.
state_
=
=
INTERP
)
return
interpFrame
(
)
-
>
script
(
)
;
if
(
jsJitFrame
(
)
.
isIonJS
(
)
)
return
ionInlineFrames_
.
script
(
)
;
return
jsJitFrame
(
)
.
script
(
)
;
}
inline
bool
FrameIter
:
:
wasmDebugEnabled
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
debugEnabled
(
)
;
}
inline
wasm
:
:
Instance
*
FrameIter
:
:
wasmInstance
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
instance
(
)
;
}
inline
unsigned
FrameIter
:
:
wasmBytecodeOffset
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
lineOrBytecode
(
)
;
}
inline
uint32_t
FrameIter
:
:
wasmFuncIndex
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
funcIndex
(
)
;
}
inline
bool
FrameIter
:
:
isIon
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isIonJS
(
)
;
}
inline
bool
FrameIter
:
:
isBaseline
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isBaselineJS
(
)
;
}
inline
InterpreterFrame
*
FrameIter
:
:
interpFrame
(
)
const
{
MOZ_ASSERT
(
data_
.
state_
=
=
INTERP
)
;
return
data_
.
interpFrames_
.
frame
(
)
;
}
inline
bool
FrameIter
:
:
isPhysicalJitFrame
(
)
const
{
if
(
!
isJSJit
(
)
)
return
false
;
auto
&
jitFrame
=
jsJitFrame
(
)
;
if
(
jitFrame
.
isBaselineJS
(
)
)
return
true
;
if
(
jitFrame
.
isIonScripted
(
)
)
{
return
ionInlineFrames_
.
frameNo
(
)
=
=
0
;
}
return
false
;
}
inline
jit
:
:
CommonFrameLayout
*
FrameIter
:
:
physicalJitFrame
(
)
const
{
MOZ_ASSERT
(
isPhysicalJitFrame
(
)
)
;
return
jsJitFrame
(
)
.
current
(
)
;
}
}
#
endif
