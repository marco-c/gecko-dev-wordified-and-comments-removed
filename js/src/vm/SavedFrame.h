#
ifndef
vm_SavedFrame_h
#
define
vm_SavedFrame_h
#
include
"
js
/
UbiNode
.
h
"
namespace
js
{
class
SavedFrame
:
public
NativeObject
{
friend
class
SavedStacks
;
public
:
static
const
Class
class_
;
static
const
JSPropertySpec
protoAccessors
[
]
;
static
const
JSFunctionSpec
protoFunctions
[
]
;
static
const
JSFunctionSpec
staticFunctions
[
]
;
static
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
sourceProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
lineProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
columnProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
functionDisplayNameProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
asyncCauseProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
asyncParentProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
parentProperty
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
toStringMethod
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
JSAtom
*
getSource
(
)
;
uint32_t
getLine
(
)
;
uint32_t
getColumn
(
)
;
JSAtom
*
getFunctionDisplayName
(
)
;
JSAtom
*
getAsyncCause
(
)
;
SavedFrame
*
getParent
(
)
;
JSPrincipals
*
getPrincipals
(
)
;
bool
isSelfHosted
(
)
;
static
bool
isSavedFrameAndNotProto
(
JSObject
&
obj
)
{
return
obj
.
is
<
SavedFrame
>
(
)
&
&
!
obj
.
as
<
SavedFrame
>
(
)
.
getReservedSlot
(
JSSLOT_SOURCE
)
.
isNull
(
)
;
}
struct
Lookup
;
struct
HashPolicy
;
typedef
HashSet
<
js
:
:
ReadBarriered
<
SavedFrame
*
>
HashPolicy
SystemAllocPolicy
>
Set
;
class
AutoLookupVector
;
class
MOZ_STACK_CLASS
HandleLookup
{
friend
class
AutoLookupVector
;
Lookup
&
lookup
;
explicit
HandleLookup
(
Lookup
&
lookup
)
:
lookup
(
lookup
)
{
}
public
:
inline
Lookup
&
get
(
)
{
return
lookup
;
}
inline
Lookup
*
operator
-
>
(
)
{
return
&
lookup
;
}
}
;
private
:
static
bool
finishSavedFrameInit
(
JSContext
*
cx
HandleObject
ctor
HandleObject
proto
)
;
void
initFromLookup
(
HandleLookup
lookup
)
;
enum
{
JSSLOT_SOURCE
JSSLOT_LINE
JSSLOT_COLUMN
JSSLOT_FUNCTIONDISPLAYNAME
JSSLOT_ASYNCCAUSE
JSSLOT_PARENT
JSSLOT_PRINCIPALS
JSSLOT_COUNT
}
;
static
bool
checkThis
(
JSContext
*
cx
CallArgs
&
args
const
char
*
fnName
MutableHandleObject
frame
)
;
}
;
struct
SavedFrame
:
:
HashPolicy
{
typedef
SavedFrame
:
:
Lookup
Lookup
;
typedef
PointerHasher
<
SavedFrame
*
3
>
SavedFramePtrHasher
;
typedef
PointerHasher
<
JSPrincipals
*
3
>
JSPrincipalsPtrHasher
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
;
static
bool
match
(
SavedFrame
*
existing
const
Lookup
&
lookup
)
;
typedef
ReadBarriered
<
SavedFrame
*
>
Key
;
static
void
rekey
(
Key
&
key
const
Key
&
newKey
)
;
}
;
inline
void
AssertObjectIsSavedFrameOrWrapper
(
JSContext
*
cx
HandleObject
stack
)
;
struct
ReconstructedSavedFramePrincipals
:
public
JSPrincipals
{
explicit
ReconstructedSavedFramePrincipals
(
)
:
JSPrincipals
(
)
{
MOZ_ASSERT
(
is
(
this
)
)
;
this
-
>
refcount
=
1
;
}
static
ReconstructedSavedFramePrincipals
IsSystem
;
static
ReconstructedSavedFramePrincipals
IsNotSystem
;
static
bool
is
(
JSPrincipals
*
p
)
{
return
p
=
=
&
IsSystem
|
|
p
=
=
&
IsNotSystem
;
}
static
JSPrincipals
*
getSingleton
(
JS
:
:
ubi
:
:
StackFrame
&
f
)
{
return
f
.
isSystem
(
)
?
&
IsSystem
:
&
IsNotSystem
;
}
}
;
}
namespace
JS
{
namespace
ubi
{
using
js
:
:
SavedFrame
;
template
<
>
class
ConcreteStackFrame
<
SavedFrame
>
:
public
BaseStackFrame
{
explicit
ConcreteStackFrame
(
SavedFrame
*
ptr
)
:
BaseStackFrame
(
ptr
)
{
}
SavedFrame
&
get
(
)
const
{
return
*
static_cast
<
SavedFrame
*
>
(
ptr
)
;
}
public
:
static
void
construct
(
void
*
storage
SavedFrame
*
ptr
)
{
new
(
storage
)
ConcreteStackFrame
(
ptr
)
;
}
StackFrame
parent
(
)
const
override
{
return
get
(
)
.
getParent
(
)
;
}
uint32_t
line
(
)
const
override
{
return
get
(
)
.
getLine
(
)
;
}
uint32_t
column
(
)
const
override
{
return
get
(
)
.
getColumn
(
)
;
}
AtomOrTwoByteChars
source
(
)
const
override
{
auto
source
=
get
(
)
.
getSource
(
)
;
return
AtomOrTwoByteChars
(
source
)
;
}
AtomOrTwoByteChars
functionDisplayName
(
)
const
override
{
auto
name
=
get
(
)
.
getFunctionDisplayName
(
)
;
return
AtomOrTwoByteChars
(
name
)
;
}
void
trace
(
JSTracer
*
trc
)
override
{
JSObject
*
prev
=
&
get
(
)
;
JSObject
*
next
=
prev
;
js
:
:
TraceRoot
(
trc
&
next
"
ConcreteStackFrame
<
SavedFrame
>
:
:
ptr
"
)
;
if
(
next
!
=
prev
)
ptr
=
next
;
}
bool
isSelfHosted
(
)
const
override
{
return
get
(
)
.
isSelfHosted
(
)
;
}
bool
isSystem
(
)
const
override
;
bool
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
outSavedFrameStack
)
const
override
;
}
;
}
}
#
endif
