#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsexn
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
BigInt
.
h
"
#
include
"
builtin
/
MapObject
.
h
"
#
include
"
builtin
/
Object
.
h
"
#
include
"
builtin
/
String
.
h
"
#
include
"
builtin
/
Symbol
.
h
"
#
include
"
builtin
/
WeakSetObject
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
DumpFunctions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
Prefs
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
PropertyDescriptor
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
util
/
WindowsWrapper
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
ArrayBufferViewObject
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
DateObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JSAtomUtils
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSONPrinter
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
vm
/
Watchtower
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
ifdef
ENABLE_RECORD_TUPLE
#
include
"
builtin
/
RecordObject
.
h
"
#
include
"
builtin
/
TupleObject
.
h
"
#
include
"
vm
/
RecordType
.
h
"
#
include
"
vm
/
TupleType
.
h
"
#
endif
#
include
"
wasm
/
WasmGcObject
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
#
include
"
vm
/
BooleanObject
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
JSAtomUtils
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
NumberObject
-
inl
.
h
"
#
include
"
vm
/
ObjectFlags
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
#
include
"
vm
/
TypedArrayObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
void
js
:
:
ReportNotObject
(
JSContext
*
cx
JSErrNum
err
int
spindex
HandleValue
v
)
{
MOZ_ASSERT
(
!
v
.
isObject
(
)
)
;
ReportValueError
(
cx
err
spindex
v
nullptr
)
;
}
void
js
:
:
ReportNotObject
(
JSContext
*
cx
JSErrNum
err
HandleValue
v
)
{
ReportNotObject
(
cx
err
JSDVG_SEARCH_STACK
v
)
;
}
void
js
:
:
ReportNotObject
(
JSContext
*
cx
const
Value
&
v
)
{
RootedValue
value
(
cx
v
)
;
ReportNotObject
(
cx
JSMSG_OBJECT_REQUIRED
value
)
;
}
void
js
:
:
ReportNotObjectArg
(
JSContext
*
cx
const
char
*
nth
const
char
*
fun
HandleValue
v
)
{
MOZ_ASSERT
(
!
v
.
isObject
(
)
)
;
UniqueChars
bytes
;
if
(
const
char
*
chars
=
ValueToSourceForError
(
cx
v
bytes
)
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED_ARG
nth
fun
chars
)
;
}
}
JS_PUBLIC_API
const
char
*
JS
:
:
InformalValueTypeName
(
const
Value
&
v
)
{
switch
(
v
.
type
(
)
)
{
case
ValueType
:
:
Double
:
case
ValueType
:
:
Int32
:
return
"
number
"
;
case
ValueType
:
:
Boolean
:
return
"
boolean
"
;
case
ValueType
:
:
Undefined
:
return
"
undefined
"
;
case
ValueType
:
:
Null
:
return
"
null
"
;
case
ValueType
:
:
String
:
return
"
string
"
;
case
ValueType
:
:
Symbol
:
return
"
symbol
"
;
case
ValueType
:
:
BigInt
:
return
"
bigint
"
;
case
ValueType
:
:
Object
:
#
ifdef
ENABLE_RECORD_TUPLE
case
ValueType
:
:
ExtendedPrimitive
:
#
endif
return
v
.
getObjectPayload
(
)
.
getClass
(
)
-
>
name
;
case
ValueType
:
:
Magic
:
return
"
magic
"
;
case
ValueType
:
:
PrivateGCThing
:
break
;
}
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
JS_PUBLIC_API
bool
JS
:
:
FromPropertyDescriptor
(
JSContext
*
cx
Handle
<
Maybe
<
PropertyDescriptor
>
>
desc_
MutableHandleValue
vp
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
desc_
)
;
if
(
desc_
.
isNothing
(
)
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
Rooted
<
PropertyDescriptor
>
desc
(
cx
*
desc_
)
;
return
FromPropertyDescriptorToObject
(
cx
desc
vp
)
;
}
bool
js
:
:
FromPropertyDescriptorToObject
(
JSContext
*
cx
Handle
<
PropertyDescriptor
>
desc
MutableHandleValue
vp
)
{
RootedObject
obj
(
cx
NewPlainObject
(
cx
)
)
;
if
(
!
obj
)
{
return
false
;
}
const
JSAtomState
&
names
=
cx
-
>
names
(
)
;
if
(
desc
.
hasValue
(
)
)
{
if
(
!
DefineDataProperty
(
cx
obj
names
.
value
desc
.
value
(
)
)
)
{
return
false
;
}
}
RootedValue
v
(
cx
)
;
if
(
desc
.
hasWritable
(
)
)
{
v
.
setBoolean
(
desc
.
writable
(
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
names
.
writable
v
)
)
{
return
false
;
}
}
if
(
desc
.
hasGetter
(
)
)
{
if
(
JSObject
*
get
=
desc
.
getter
(
)
)
{
v
.
setObject
(
*
get
)
;
}
else
{
v
.
setUndefined
(
)
;
}
if
(
!
DefineDataProperty
(
cx
obj
names
.
get
v
)
)
{
return
false
;
}
}
if
(
desc
.
hasSetter
(
)
)
{
if
(
JSObject
*
set
=
desc
.
setter
(
)
)
{
v
.
setObject
(
*
set
)
;
}
else
{
v
.
setUndefined
(
)
;
}
if
(
!
DefineDataProperty
(
cx
obj
names
.
set
v
)
)
{
return
false
;
}
}
if
(
desc
.
hasEnumerable
(
)
)
{
v
.
setBoolean
(
desc
.
enumerable
(
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
names
.
enumerable
v
)
)
{
return
false
;
}
}
if
(
desc
.
hasConfigurable
(
)
)
{
v
.
setBoolean
(
desc
.
configurable
(
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
names
.
configurable
v
)
)
{
return
false
;
}
}
vp
.
setObject
(
*
obj
)
;
return
true
;
}
bool
js
:
:
GetFirstArgumentAsObject
(
JSContext
*
cx
const
CallArgs
&
args
const
char
*
method
MutableHandleObject
objp
)
{
if
(
!
args
.
requireAtLeast
(
cx
method
1
)
)
{
return
false
;
}
HandleValue
v
=
args
[
0
]
;
if
(
!
v
.
isObject
(
)
)
{
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
v
nullptr
)
;
if
(
!
bytes
)
{
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_UNEXPECTED_TYPE
bytes
.
get
(
)
"
not
an
object
"
)
;
return
false
;
}
objp
.
set
(
&
v
.
toObject
(
)
)
;
return
true
;
}
static
bool
GetPropertyIfPresent
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleValue
vp
bool
*
foundp
)
{
if
(
!
HasProperty
(
cx
obj
id
foundp
)
)
{
return
false
;
}
if
(
!
*
foundp
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
return
GetProperty
(
cx
obj
obj
id
vp
)
;
}
bool
js
:
:
Throw
(
JSContext
*
cx
HandleId
id
unsigned
errorNumber
const
char
*
details
)
{
MOZ_ASSERT
(
js_ErrorFormatString
[
errorNumber
]
.
argCount
=
=
(
details
?
2
:
1
)
)
;
MOZ_ASSERT_IF
(
details
JS
:
:
StringIsASCII
(
details
)
)
;
UniqueChars
bytes
=
IdToPrintableUTF8
(
cx
id
IdToPrintableBehavior
:
:
IdIsPropertyKey
)
;
if
(
!
bytes
)
{
return
false
;
}
if
(
details
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
errorNumber
bytes
.
get
(
)
details
)
;
}
else
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
errorNumber
bytes
.
get
(
)
)
;
}
return
false
;
}
static
Result
<
>
CheckCallable
(
JSContext
*
cx
JSObject
*
obj
const
char
*
fieldName
)
{
if
(
obj
&
&
!
obj
-
>
isCallable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_GET_SET_FIELD
fieldName
)
;
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
bool
js
:
:
ToPropertyDescriptor
(
JSContext
*
cx
HandleValue
descval
bool
checkAccessors
MutableHandle
<
PropertyDescriptor
>
desc_
)
{
RootedObject
obj
(
cx
RequireObject
(
cx
JSMSG_OBJECT_REQUIRED_PROP_DESC
descval
)
)
;
if
(
!
obj
)
{
return
false
;
}
Rooted
<
PropertyDescriptor
>
desc
(
cx
PropertyDescriptor
:
:
Empty
(
)
)
;
RootedId
id
(
cx
)
;
RootedValue
v
(
cx
)
;
id
=
NameToId
(
cx
-
>
names
(
)
.
enumerable
)
;
bool
hasEnumerable
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasEnumerable
)
)
{
return
false
;
}
if
(
hasEnumerable
)
{
desc
.
setEnumerable
(
ToBoolean
(
v
)
)
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
configurable
)
;
bool
hasConfigurable
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasConfigurable
)
)
{
return
false
;
}
if
(
hasConfigurable
)
{
desc
.
setConfigurable
(
ToBoolean
(
v
)
)
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
value
)
;
bool
hasValue
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasValue
)
)
{
return
false
;
}
if
(
hasValue
)
{
desc
.
setValue
(
v
)
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
writable
)
;
bool
hasWritable
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasWritable
)
)
{
return
false
;
}
if
(
hasWritable
)
{
desc
.
setWritable
(
ToBoolean
(
v
)
)
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
get
)
;
bool
hasGet
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasGet
)
)
{
return
false
;
}
RootedObject
getter
(
cx
)
;
if
(
hasGet
)
{
if
(
v
.
isObject
(
)
)
{
if
(
checkAccessors
)
{
JS_TRY_OR_RETURN_FALSE
(
cx
CheckCallable
(
cx
&
v
.
toObject
(
)
"
getter
"
)
)
;
}
getter
=
&
v
.
toObject
(
)
;
}
else
if
(
v
.
isUndefined
(
)
)
{
getter
=
nullptr
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_GET_SET_FIELD
"
getter
"
)
;
return
false
;
}
}
id
=
NameToId
(
cx
-
>
names
(
)
.
set
)
;
bool
hasSet
=
false
;
if
(
!
GetPropertyIfPresent
(
cx
obj
id
&
v
&
hasSet
)
)
{
return
false
;
}
RootedObject
setter
(
cx
)
;
if
(
hasSet
)
{
if
(
v
.
isObject
(
)
)
{
if
(
checkAccessors
)
{
JS_TRY_OR_RETURN_FALSE
(
cx
CheckCallable
(
cx
&
v
.
toObject
(
)
"
setter
"
)
)
;
}
setter
=
&
v
.
toObject
(
)
;
}
else
if
(
v
.
isUndefined
(
)
)
{
setter
=
nullptr
;
}
else
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_GET_SET_FIELD
"
setter
"
)
;
return
false
;
}
}
if
(
hasGet
|
|
hasSet
)
{
if
(
hasValue
|
|
hasWritable
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INVALID_DESCRIPTOR
)
;
return
false
;
}
if
(
hasGet
)
{
desc
.
setGetter
(
getter
)
;
}
if
(
hasSet
)
{
desc
.
setSetter
(
setter
)
;
}
}
desc
.
assertValid
(
)
;
desc_
.
set
(
desc
)
;
return
true
;
}
Result
<
>
js
:
:
CheckPropertyDescriptorAccessors
(
JSContext
*
cx
Handle
<
PropertyDescriptor
>
desc
)
{
if
(
desc
.
hasGetter
(
)
)
{
MOZ_TRY
(
CheckCallable
(
cx
desc
.
getter
(
)
"
getter
"
)
)
;
}
if
(
desc
.
hasSetter
(
)
)
{
MOZ_TRY
(
CheckCallable
(
cx
desc
.
setter
(
)
"
setter
"
)
)
;
}
return
Ok
(
)
;
}
void
js
:
:
CompletePropertyDescriptor
(
MutableHandle
<
PropertyDescriptor
>
desc
)
{
desc
.
assertValid
(
)
;
if
(
desc
.
isGenericDescriptor
(
)
|
|
desc
.
isDataDescriptor
(
)
)
{
if
(
!
desc
.
hasValue
(
)
)
{
desc
.
setValue
(
UndefinedHandleValue
)
;
}
if
(
!
desc
.
hasWritable
(
)
)
{
desc
.
setWritable
(
false
)
;
}
}
else
{
if
(
!
desc
.
hasGetter
(
)
)
{
desc
.
setGetter
(
nullptr
)
;
}
if
(
!
desc
.
hasSetter
(
)
)
{
desc
.
setSetter
(
nullptr
)
;
}
}
if
(
!
desc
.
hasEnumerable
(
)
)
{
desc
.
setEnumerable
(
false
)
;
}
if
(
!
desc
.
hasConfigurable
(
)
)
{
desc
.
setConfigurable
(
false
)
;
}
desc
.
assertComplete
(
)
;
}
bool
js
:
:
ReadPropertyDescriptors
(
JSContext
*
cx
HandleObject
props
bool
checkAccessors
MutableHandleIdVector
ids
MutableHandle
<
PropertyDescriptorVector
>
descs
)
{
if
(
!
GetPropertyKeys
(
cx
props
JSITER_OWNONLY
|
JSITER_SYMBOLS
ids
)
)
{
return
false
;
}
RootedId
id
(
cx
)
;
for
(
size_t
i
=
0
len
=
ids
.
length
(
)
;
i
<
len
;
i
+
+
)
{
id
=
ids
[
i
]
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
RootedValue
v
(
cx
)
;
if
(
!
GetProperty
(
cx
props
props
id
&
v
)
|
|
!
ToPropertyDescriptor
(
cx
v
checkAccessors
&
desc
)
|
|
!
descs
.
append
(
desc
)
)
{
return
false
;
}
}
return
true
;
}
bool
js
:
:
SetIntegrityLevel
(
JSContext
*
cx
HandleObject
obj
IntegrityLevel
level
)
{
cx
-
>
check
(
obj
)
;
if
(
!
PreventExtensions
(
cx
obj
)
)
{
return
false
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
&
&
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
shape
(
)
-
>
propMapLength
(
)
>
0
)
{
if
(
!
NativeObject
:
:
freezeOrSealProperties
(
cx
nobj
level
)
)
{
return
false
;
}
}
if
(
level
=
=
IntegrityLevel
:
:
Frozen
&
&
obj
-
>
is
<
ArrayObject
>
(
)
)
{
obj
-
>
as
<
ArrayObject
>
(
)
.
setNonWritableLength
(
cx
)
;
}
}
else
{
RootedIdVector
keys
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
JSITER_HIDDEN
|
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
keys
)
)
{
return
false
;
}
RootedId
id
(
cx
)
;
Rooted
<
PropertyDescriptor
>
desc
(
cx
PropertyDescriptor
:
:
Empty
(
)
)
;
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
id
=
keys
[
i
]
;
if
(
level
=
=
IntegrityLevel
:
:
Sealed
)
{
desc
.
setConfigurable
(
false
)
;
}
else
{
Rooted
<
Maybe
<
PropertyDescriptor
>
>
currentDesc
(
cx
)
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
currentDesc
)
)
{
return
false
;
}
if
(
currentDesc
.
isNothing
(
)
)
{
continue
;
}
desc
=
PropertyDescriptor
:
:
Empty
(
)
;
if
(
currentDesc
-
>
isAccessorDescriptor
(
)
)
{
desc
.
setConfigurable
(
false
)
;
}
else
{
desc
.
setConfigurable
(
false
)
;
desc
.
setWritable
(
false
)
;
}
}
if
(
!
DefineProperty
(
cx
obj
id
desc
)
)
{
return
false
;
}
}
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
if
(
!
ObjectElements
:
:
FreezeOrSeal
(
cx
obj
.
as
<
NativeObject
>
(
)
level
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ResolveLazyProperties
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
)
{
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
JSEnumerateOp
enumerate
=
clasp
-
>
getEnumerate
(
)
)
{
if
(
!
enumerate
(
cx
obj
)
)
{
return
false
;
}
}
if
(
clasp
-
>
getNewEnumerate
(
)
&
&
clasp
-
>
getResolve
(
)
)
{
RootedIdVector
properties
(
cx
)
;
if
(
!
clasp
-
>
getNewEnumerate
(
)
(
cx
obj
&
properties
false
)
)
{
return
false
;
}
RootedId
id
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
properties
.
length
(
)
;
i
+
+
)
{
id
=
properties
[
i
]
;
bool
found
;
if
(
!
HasOwnProperty
(
cx
obj
id
&
found
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
js
:
:
TestIntegrityLevel
(
JSContext
*
cx
HandleObject
obj
IntegrityLevel
level
bool
*
result
)
{
bool
status
;
if
(
!
IsExtensible
(
cx
obj
&
status
)
)
{
return
false
;
}
if
(
status
)
{
*
result
=
false
;
return
true
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
!
ResolveLazyProperties
(
cx
nobj
)
)
{
return
false
;
}
if
(
nobj
-
>
is
<
TypedArrayObject
>
(
)
&
&
nobj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
.
valueOr
(
0
)
>
0
)
{
*
result
=
false
;
return
true
;
}
bool
hasDenseElements
=
false
;
for
(
size_t
i
=
0
;
i
<
nobj
-
>
getDenseInitializedLength
(
)
;
i
+
+
)
{
if
(
nobj
-
>
containsDenseElement
(
i
)
)
{
hasDenseElements
=
true
;
break
;
}
}
if
(
hasDenseElements
)
{
if
(
!
nobj
-
>
denseElementsAreSealed
(
)
)
{
*
result
=
false
;
return
true
;
}
if
(
level
=
=
IntegrityLevel
:
:
Frozen
&
&
!
nobj
-
>
denseElementsAreFrozen
(
)
)
{
*
result
=
false
;
return
true
;
}
}
for
(
ShapePropertyIter
<
NoGC
>
iter
(
nobj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
if
(
iter
-
>
configurable
(
)
|
|
(
level
=
=
IntegrityLevel
:
:
Frozen
&
&
iter
-
>
isDataDescriptor
(
)
&
&
iter
-
>
writable
(
)
)
)
{
if
(
iter
-
>
key
(
)
.
isPrivateName
(
)
)
{
continue
;
}
*
result
=
false
;
return
true
;
}
}
}
else
{
RootedIdVector
props
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
JSITER_HIDDEN
|
JSITER_OWNONLY
|
JSITER_SYMBOLS
&
props
)
)
{
return
false
;
}
RootedId
id
(
cx
)
;
Rooted
<
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
for
(
size_t
i
=
0
len
=
props
.
length
(
)
;
i
<
len
;
i
+
+
)
{
id
=
props
[
i
]
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
)
{
return
false
;
}
if
(
desc
.
isNothing
(
)
)
{
continue
;
}
if
(
desc
-
>
configurable
(
)
|
|
(
level
=
=
IntegrityLevel
:
:
Frozen
&
&
desc
-
>
isDataDescriptor
(
)
&
&
desc
-
>
writable
(
)
)
)
{
MOZ_ASSERT
(
!
id
.
isPrivateName
(
)
)
;
*
result
=
false
;
return
true
;
}
}
}
*
result
=
true
;
return
true
;
}
static
MOZ_ALWAYS_INLINE
NativeObject
*
NewObject
(
JSContext
*
cx
const
JSClass
*
clasp
Handle
<
TaggedProto
>
proto
gc
:
:
AllocKind
kind
NewObjectKind
newKind
ObjectFlags
objFlags
)
{
MOZ_ASSERT
(
clasp
-
>
isNativeObject
(
)
)
;
MOZ_ASSERT
(
clasp
!
=
&
ArrayObject
:
:
class_
)
;
MOZ_ASSERT
(
clasp
!
=
&
PlainObject
:
:
class_
)
;
MOZ_ASSERT
(
!
clasp
-
>
isJSFunction
(
)
)
;
MOZ_ASSERT
(
!
ClassCanHaveFixedData
(
clasp
)
)
;
size_t
nfixed
=
GetGCKindSlots
(
kind
)
;
if
(
CanChangeToBackgroundAllocKind
(
kind
clasp
)
)
{
kind
=
ForegroundToBackgroundAllocKind
(
kind
)
;
}
Rooted
<
SharedShape
*
>
shape
(
cx
SharedShape
:
:
getInitialShape
(
cx
clasp
cx
-
>
realm
(
)
proto
nfixed
objFlags
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
gc
:
:
Heap
heap
=
GetInitialHeap
(
newKind
clasp
)
;
NativeObject
*
obj
=
NativeObject
:
:
create
(
cx
kind
heap
shape
)
;
if
(
!
obj
)
{
return
nullptr
;
}
probes
:
:
CreateObject
(
cx
obj
)
;
return
obj
;
}
NativeObject
*
js
:
:
NewObjectWithGivenTaggedProto
(
JSContext
*
cx
const
JSClass
*
clasp
Handle
<
TaggedProto
>
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
ObjectFlags
objFlags
)
{
return
NewObject
(
cx
clasp
proto
allocKind
newKind
objFlags
)
;
}
NativeObject
*
js
:
:
NewObjectWithClassProto
(
JSContext
*
cx
const
JSClass
*
clasp
HandleObject
protoArg
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
ObjectFlags
objFlags
)
{
if
(
protoArg
)
{
return
NewObjectWithGivenTaggedProto
(
cx
clasp
AsTaggedProto
(
protoArg
)
allocKind
newKind
objFlags
)
;
}
JSProtoKey
protoKey
=
JSCLASS_CACHED_PROTO_KEY
(
clasp
)
;
if
(
protoKey
=
=
JSProto_Null
)
{
protoKey
=
JSProto_Object
;
}
JSObject
*
proto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
protoKey
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Rooted
<
TaggedProto
>
taggedProto
(
cx
TaggedProto
(
proto
)
)
;
return
NewObject
(
cx
clasp
taggedProto
allocKind
newKind
objFlags
)
;
}
bool
js
:
:
GetPrototypeFromConstructor
(
JSContext
*
cx
HandleObject
newTarget
JSProtoKey
intrinsicDefaultProto
MutableHandleObject
proto
)
{
RootedValue
protov
(
cx
)
;
if
(
!
GetProperty
(
cx
newTarget
newTarget
cx
-
>
names
(
)
.
prototype
&
protov
)
)
{
return
false
;
}
if
(
protov
.
isObject
(
)
)
{
proto
.
set
(
&
protov
.
toObject
(
)
)
;
}
else
if
(
newTarget
-
>
is
<
JSFunction
>
(
)
&
&
newTarget
-
>
as
<
JSFunction
>
(
)
.
realm
(
)
=
=
cx
-
>
realm
(
)
)
{
proto
.
set
(
nullptr
)
;
}
else
if
(
intrinsicDefaultProto
=
=
JSProto_Null
)
{
proto
.
set
(
nullptr
)
;
}
else
{
Realm
*
realm
=
JS
:
:
GetFunctionRealm
(
cx
newTarget
)
;
if
(
!
realm
)
{
return
false
;
}
{
Maybe
<
AutoRealm
>
ar
;
if
(
cx
-
>
realm
(
)
!
=
realm
)
{
ar
.
emplace
(
cx
realm
-
>
maybeGlobal
(
)
)
;
}
proto
.
set
(
GlobalObject
:
:
getOrCreatePrototype
(
cx
intrinsicDefaultProto
)
)
;
}
if
(
!
proto
)
{
return
false
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
proto
)
)
{
return
false
;
}
}
return
true
;
}
bool
JSObject
:
:
nonNativeSetProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
return
obj
-
>
getOpsSetProperty
(
)
(
cx
obj
id
v
receiver
result
)
;
}
bool
JSObject
:
:
nonNativeSetElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
RootedId
id
(
cx
)
;
if
(
!
IndexToId
(
cx
index
&
id
)
)
{
return
false
;
}
return
nonNativeSetProperty
(
cx
obj
id
v
receiver
result
)
;
}
static
bool
CopyPropertyFrom
(
JSContext
*
cx
HandleId
id
HandleObject
target
HandleObject
obj
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
cx
-
>
check
(
obj
id
)
;
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
if
(
!
GetOwnPropertyDescriptor
(
cx
obj
id
&
desc
)
)
{
return
false
;
}
MOZ_ASSERT
(
desc
.
isSome
(
)
)
;
JSAutoRealm
ar
(
cx
target
)
;
cx
-
>
markId
(
id
)
;
RootedId
wrappedId
(
cx
id
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
desc
)
)
{
return
false
;
}
Rooted
<
PropertyDescriptor
>
desc_
(
cx
*
desc
)
;
return
DefineProperty
(
cx
target
wrappedId
desc_
)
;
}
JS_PUBLIC_API
bool
JS_CopyOwnPropertiesAndPrivateFields
(
JSContext
*
cx
HandleObject
target
HandleObject
obj
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
obj
)
)
;
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
JSAutoRealm
ar
(
cx
obj
)
;
RootedIdVector
props
(
cx
)
;
if
(
!
GetPropertyKeys
(
cx
obj
JSITER_PRIVATE
|
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
&
props
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
props
.
length
(
)
;
+
+
i
)
{
if
(
!
CopyPropertyFrom
(
cx
props
[
i
]
target
obj
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
InitializePropertiesFromCompatibleNativeObject
(
JSContext
*
cx
Handle
<
NativeObject
*
>
dst
Handle
<
NativeObject
*
>
src
)
{
cx
-
>
check
(
src
dst
)
;
MOZ_ASSERT
(
src
-
>
getClass
(
)
=
=
dst
-
>
getClass
(
)
)
;
MOZ_ASSERT
(
dst
-
>
shape
(
)
-
>
objectFlags
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
src
-
>
numFixedSlots
(
)
=
=
dst
-
>
numFixedSlots
(
)
)
;
MOZ_ASSERT
(
!
src
-
>
inDictionaryMode
(
)
)
;
MOZ_ASSERT
(
!
dst
-
>
inDictionaryMode
(
)
)
;
if
(
!
dst
-
>
ensureElements
(
cx
src
-
>
getDenseInitializedLength
(
)
)
)
{
return
false
;
}
uint32_t
initialized
=
src
-
>
getDenseInitializedLength
(
)
;
for
(
uint32_t
i
=
0
;
i
<
initialized
;
+
+
i
)
{
dst
-
>
setDenseInitializedLength
(
i
+
1
)
;
dst
-
>
initDenseElement
(
i
src
-
>
getDenseElement
(
i
)
)
;
}
if
(
!
src
-
>
sharedShape
(
)
-
>
propMap
(
)
)
{
return
true
;
}
Rooted
<
SharedShape
*
>
shape
(
cx
)
;
if
(
src
-
>
staticPrototype
(
)
=
=
dst
-
>
staticPrototype
(
)
)
{
shape
=
src
-
>
sharedShape
(
)
;
}
else
{
SharedShape
*
srcShape
=
src
-
>
sharedShape
(
)
;
ObjectFlags
objFlags
;
objFlags
=
CopyPropMapObjectFlags
(
objFlags
srcShape
-
>
objectFlags
(
)
)
;
Rooted
<
SharedPropMap
*
>
map
(
cx
srcShape
-
>
propMap
(
)
)
;
uint32_t
mapLength
=
srcShape
-
>
propMapLength
(
)
;
shape
=
SharedShape
:
:
getPropMapShape
(
cx
dst
-
>
shape
(
)
-
>
base
(
)
dst
-
>
numFixedSlots
(
)
map
mapLength
objFlags
)
;
if
(
!
shape
)
{
return
false
;
}
}
uint32_t
oldSpan
=
dst
-
>
sharedShape
(
)
-
>
slotSpan
(
)
;
uint32_t
newSpan
=
shape
-
>
slotSpan
(
)
;
if
(
!
dst
-
>
setShapeAndAddNewSlots
(
cx
shape
oldSpan
newSpan
)
)
{
return
false
;
}
for
(
size_t
i
=
JSCLASS_RESERVED_SLOTS
(
src
-
>
getClass
(
)
)
;
i
<
newSpan
;
i
+
+
)
{
dst
-
>
setSlot
(
i
src
-
>
getSlot
(
i
)
)
;
}
return
true
;
}
JS_PUBLIC_API
bool
JS_InitializePropertiesFromCompatibleNativeObject
(
JSContext
*
cx
HandleObject
dst
HandleObject
src
)
{
return
InitializePropertiesFromCompatibleNativeObject
(
cx
dst
.
as
<
NativeObject
>
(
)
src
.
as
<
NativeObject
>
(
)
)
;
}
bool
js
:
:
ObjectMayBeSwapped
(
const
JSObject
*
obj
)
{
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
clasp
-
>
isGlobal
(
)
)
{
return
false
;
}
return
clasp
-
>
isProxyObject
(
)
|
|
clasp
-
>
isDOMClass
(
)
;
}
bool
NativeObject
:
:
prepareForSwap
(
JSContext
*
cx
MutableHandleValueVector
slotValuesOut
)
{
MOZ_ASSERT
(
slotValuesOut
.
empty
(
)
)
;
for
(
size_t
i
=
0
;
i
<
slotSpan
(
)
;
i
+
+
)
{
if
(
!
slotValuesOut
.
append
(
getSlot
(
i
)
)
)
{
return
false
;
}
}
if
(
hasDynamicSlots
(
)
)
{
ObjectSlots
*
slotsHeader
=
getSlotsHeader
(
)
;
size_t
size
=
ObjectSlots
:
:
allocSize
(
slotsHeader
-
>
capacity
(
)
)
;
RemoveCellMemory
(
this
size
MemoryUse
:
:
ObjectSlots
)
;
if
(
!
cx
-
>
nursery
(
)
.
isInside
(
slotsHeader
)
)
{
if
(
!
isTenured
(
)
)
{
cx
-
>
nursery
(
)
.
removeMallocedBuffer
(
slotsHeader
size
)
;
}
js_free
(
slotsHeader
)
;
}
setEmptyDynamicSlots
(
0
)
;
}
if
(
hasDynamicElements
(
)
)
{
ObjectElements
*
elements
=
getElementsHeader
(
)
;
void
*
allocatedElements
=
getUnshiftedElementsHeader
(
)
;
size_t
count
=
elements
-
>
numAllocatedElements
(
)
;
size_t
size
=
count
*
sizeof
(
HeapSlot
)
;
if
(
isTenured
(
)
)
{
RemoveCellMemory
(
this
size
MemoryUse
:
:
ObjectElements
)
;
}
else
if
(
cx
-
>
nursery
(
)
.
isInside
(
allocatedElements
)
)
{
ObjectElements
*
newElements
=
reinterpret_cast
<
ObjectElements
*
>
(
js_pod_malloc
<
HeapSlot
>
(
count
)
)
;
if
(
!
newElements
)
{
return
false
;
}
memmove
(
newElements
elements
size
)
;
elements_
=
newElements
-
>
elements
(
)
;
}
else
{
cx
-
>
nursery
(
)
.
removeMallocedBuffer
(
allocatedElements
size
)
;
}
MOZ_ASSERT
(
hasDynamicElements
(
)
)
;
}
return
true
;
}
bool
NativeObject
:
:
fixupAfterSwap
(
JSContext
*
cx
Handle
<
NativeObject
*
>
obj
gc
:
:
AllocKind
kind
HandleValueVector
slotValues
)
{
MOZ_ASSERT_IF
(
!
obj
-
>
inDictionaryMode
(
)
obj
-
>
slotSpan
(
)
=
=
slotValues
.
length
(
)
)
;
size_t
nfixed
=
gc
:
:
GetGCKindSlots
(
kind
)
;
if
(
nfixed
!
=
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
)
{
if
(
!
NativeObject
:
:
changeNumFixedSlotsAfterSwap
(
cx
obj
nfixed
)
)
{
return
false
;
}
MOZ_ASSERT
(
obj
-
>
shape
(
)
-
>
numFixedSlots
(
)
=
=
nfixed
)
;
}
uint32_t
oldDictionarySlotSpan
=
obj
-
>
inDictionaryMode
(
)
?
slotValues
.
length
(
)
:
0
;
MOZ_ASSERT
(
!
obj
-
>
hasUniqueId
(
)
)
;
size_t
ndynamic
=
calculateDynamicSlots
(
nfixed
slotValues
.
length
(
)
obj
-
>
getClass
(
)
)
;
size_t
currentSlots
=
obj
-
>
getSlotsHeader
(
)
-
>
capacity
(
)
;
MOZ_ASSERT
(
ndynamic
>
=
currentSlots
)
;
if
(
ndynamic
>
currentSlots
)
{
if
(
!
obj
-
>
growSlots
(
cx
currentSlots
ndynamic
)
)
{
return
false
;
}
}
if
(
obj
-
>
inDictionaryMode
(
)
)
{
obj
-
>
setDictionaryModeSlotSpan
(
oldDictionarySlotSpan
)
;
}
for
(
size_t
i
=
0
len
=
slotValues
.
length
(
)
;
i
<
len
;
i
+
+
)
{
obj
-
>
initSlotUnchecked
(
i
slotValues
[
i
]
)
;
}
if
(
obj
-
>
hasDynamicElements
(
)
)
{
ObjectElements
*
elements
=
obj
-
>
getElementsHeader
(
)
;
void
*
allocatedElements
=
obj
-
>
getUnshiftedElementsHeader
(
)
;
MOZ_ASSERT
(
!
cx
-
>
nursery
(
)
.
isInside
(
allocatedElements
)
)
;
size_t
size
=
elements
-
>
numAllocatedElements
(
)
*
sizeof
(
HeapSlot
)
;
if
(
obj
-
>
isTenured
(
)
)
{
AddCellMemory
(
obj
size
MemoryUse
:
:
ObjectElements
)
;
}
else
if
(
!
cx
-
>
nursery
(
)
.
registerMallocedBuffer
(
allocatedElements
size
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
ProxyObject
:
:
prepareForSwap
(
JSContext
*
cx
MutableHandleValueVector
valuesOut
)
{
MOZ_ASSERT
(
valuesOut
.
empty
(
)
)
;
gc
:
:
StoreBuffer
&
sb
=
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
(
)
;
if
(
!
valuesOut
.
reserve
(
2
+
numReservedSlots
(
)
)
)
{
return
false
;
}
js
:
:
detail
:
:
ProxyValueArray
*
valArray
=
data
.
values
(
)
;
sb
.
unputValue
(
&
valArray
-
>
expandoSlot
)
;
sb
.
unputValue
(
&
valArray
-
>
privateSlot
)
;
valuesOut
.
infallibleAppend
(
valArray
-
>
expandoSlot
)
;
valuesOut
.
infallibleAppend
(
valArray
-
>
privateSlot
)
;
for
(
size_t
i
=
0
;
i
<
numReservedSlots
(
)
;
i
+
+
)
{
sb
.
unputValue
(
&
valArray
-
>
reservedSlots
.
slots
[
i
]
)
;
valuesOut
.
infallibleAppend
(
valArray
-
>
reservedSlots
.
slots
[
i
]
)
;
}
if
(
isTenured
(
)
&
&
!
usingInlineValueArray
(
)
)
{
size_t
count
=
detail
:
:
ProxyValueArray
:
:
allocCount
(
numReservedSlots
(
)
)
;
RemoveCellMemory
(
this
count
*
sizeof
(
Value
)
MemoryUse
:
:
ProxyExternalValueArray
)
;
js_free
(
valArray
)
;
data
.
reservedSlots
=
nullptr
;
}
return
true
;
}
bool
ProxyObject
:
:
fixupAfterSwap
(
JSContext
*
cx
const
HandleValueVector
values
)
{
MOZ_ASSERT
(
getClass
(
)
-
>
isProxyObject
(
)
)
;
size_t
nreserved
=
numReservedSlots
(
)
;
MOZ_ASSERT
(
values
.
length
(
)
=
=
2
+
nreserved
)
;
size_t
count
=
detail
:
:
ProxyValueArray
:
:
allocCount
(
nreserved
)
;
auto
*
allocation
=
js_pod_malloc
<
JS
:
:
Value
>
(
count
)
;
if
(
!
allocation
)
{
return
false
;
}
size_t
size
=
count
*
sizeof
(
Value
)
;
if
(
isTenured
(
)
)
{
AddCellMemory
(
&
asTenured
(
)
size
MemoryUse
:
:
ProxyExternalValueArray
)
;
}
else
if
(
!
cx
-
>
nursery
(
)
.
registerMallocedBuffer
(
allocation
size
)
)
{
js_free
(
allocation
)
;
return
false
;
}
auto
*
valArray
=
reinterpret_cast
<
js
:
:
detail
:
:
ProxyValueArray
*
>
(
allocation
)
;
valArray
-
>
expandoSlot
=
values
[
0
]
;
valArray
-
>
privateSlot
=
values
[
1
]
;
for
(
size_t
i
=
0
;
i
<
nreserved
;
i
+
+
)
{
valArray
-
>
reservedSlots
.
slots
[
i
]
=
values
[
i
+
2
]
;
}
data
.
reservedSlots
=
&
valArray
-
>
reservedSlots
;
MOZ_ASSERT
(
!
usingInlineValueArray
(
)
)
;
return
true
;
}
static
gc
:
:
AllocKind
SwappableObjectAllocKind
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
ObjectMayBeSwapped
(
obj
)
)
;
if
(
obj
-
>
isTenured
(
)
)
{
return
obj
-
>
asTenured
(
)
.
getAllocKind
(
)
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
obj
-
>
as
<
NativeObject
>
(
)
.
allocKindForTenure
(
)
;
}
return
obj
-
>
as
<
ProxyObject
>
(
)
.
allocKindForTenure
(
)
;
}
void
JSObject
:
:
swap
(
JSContext
*
cx
HandleObject
a
HandleObject
b
AutoEnterOOMUnsafeRegion
&
oomUnsafe
)
{
MOZ_ASSERT
(
a
-
>
isBackgroundFinalized
(
)
=
=
b
-
>
isBackgroundFinalized
(
)
)
;
MOZ_ASSERT
(
a
-
>
compartment
(
)
=
=
b
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
a
-
>
compartment
(
)
)
;
MOZ_RELEASE_ASSERT
(
js
:
:
ObjectMayBeSwapped
(
a
)
)
;
MOZ_RELEASE_ASSERT
(
js
:
:
ObjectMayBeSwapped
(
b
)
)
;
if
(
!
Watchtower
:
:
watchObjectSwap
(
cx
a
b
)
)
{
oomUnsafe
.
crash
(
"
watchObjectSwap
"
)
;
}
gc
:
:
StoreBuffer
&
storeBuffer
=
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
(
)
;
if
(
a
-
>
isTenured
(
)
)
{
storeBuffer
.
putWholeCell
(
a
)
;
}
if
(
b
-
>
isTenured
(
)
)
{
storeBuffer
.
putWholeCell
(
b
)
;
}
if
(
a
-
>
isTenured
(
)
|
|
b
-
>
isTenured
(
)
)
{
if
(
a
-
>
zone
(
)
-
>
wasGCStarted
(
)
)
{
storeBuffer
.
setMayHavePointersToDeadCells
(
)
;
}
}
unsigned
r
=
NotifyGCPreSwap
(
a
b
)
;
ProxyObject
*
pa
=
a
-
>
is
<
ProxyObject
>
(
)
?
&
a
-
>
as
<
ProxyObject
>
(
)
:
nullptr
;
ProxyObject
*
pb
=
b
-
>
is
<
ProxyObject
>
(
)
?
&
b
-
>
as
<
ProxyObject
>
(
)
:
nullptr
;
bool
aIsProxyWithInlineValues
=
pa
&
&
pa
-
>
usingInlineValueArray
(
)
;
bool
bIsProxyWithInlineValues
=
pb
&
&
pb
-
>
usingInlineValueArray
(
)
;
bool
aIsUsedAsPrototype
=
a
-
>
isUsedAsPrototype
(
)
;
bool
bIsUsedAsPrototype
=
b
-
>
isUsedAsPrototype
(
)
;
Zone
*
zone
=
a
-
>
zone
(
)
;
uint64_t
aid
=
0
;
uint64_t
bid
=
0
;
(
void
)
gc
:
:
MaybeGetUniqueId
(
a
&
aid
)
;
(
void
)
gc
:
:
MaybeGetUniqueId
(
b
&
bid
)
;
NativeObject
*
na
=
a
-
>
is
<
NativeObject
>
(
)
?
&
a
-
>
as
<
NativeObject
>
(
)
:
nullptr
;
NativeObject
*
nb
=
b
-
>
is
<
NativeObject
>
(
)
?
&
b
-
>
as
<
NativeObject
>
(
)
:
nullptr
;
if
(
(
aid
|
|
bid
)
&
&
(
na
|
|
nb
)
)
{
if
(
!
gc
:
:
GetOrCreateUniqueId
(
a
&
aid
)
|
|
!
gc
:
:
GetOrCreateUniqueId
(
b
&
bid
)
)
{
oomUnsafe
.
crash
(
"
Failed
to
create
unique
ID
during
swap
"
)
;
}
if
(
pa
&
&
aid
)
{
gc
:
:
RemoveUniqueId
(
a
)
;
}
if
(
pb
&
&
bid
)
{
gc
:
:
RemoveUniqueId
(
b
)
;
}
}
gc
:
:
AllocKind
ka
=
SwappableObjectAllocKind
(
a
)
;
gc
:
:
AllocKind
kb
=
SwappableObjectAllocKind
(
b
)
;
size_t
sa
=
gc
:
:
Arena
:
:
thingSize
(
ka
)
;
size_t
sb
=
gc
:
:
Arena
:
:
thingSize
(
kb
)
;
if
(
sa
=
=
sb
&
&
a
-
>
isTenured
(
)
=
=
b
-
>
isTenured
(
)
)
{
zone
-
>
swapCellMemory
(
a
b
MemoryUse
:
:
ObjectSlots
)
;
size_t
size
=
sa
;
char
tmp
[
sizeof
(
JSObject_Slots16
)
]
;
MOZ_ASSERT
(
size
<
=
sizeof
(
tmp
)
)
;
js_memcpy
(
tmp
a
size
)
;
js_memcpy
(
a
b
size
)
;
js_memcpy
(
b
tmp
size
)
;
zone
-
>
swapCellMemory
(
a
b
MemoryUse
:
:
ObjectElements
)
;
zone
-
>
swapCellMemory
(
a
b
MemoryUse
:
:
ProxyExternalValueArray
)
;
if
(
aIsProxyWithInlineValues
)
{
b
-
>
as
<
ProxyObject
>
(
)
.
setInlineValueArray
(
)
;
}
if
(
bIsProxyWithInlineValues
)
{
a
-
>
as
<
ProxyObject
>
(
)
.
setInlineValueArray
(
)
;
}
}
else
{
gc
:
:
AutoSuppressGC
suppress
(
cx
)
;
RootedValueVector
avals
(
cx
)
;
RootedValueVector
bvals
(
cx
)
;
if
(
na
&
&
!
na
-
>
prepareForSwap
(
cx
&
avals
)
)
{
oomUnsafe
.
crash
(
"
NativeObject
:
:
prepareForSwap
"
)
;
}
if
(
nb
&
&
!
nb
-
>
prepareForSwap
(
cx
&
bvals
)
)
{
oomUnsafe
.
crash
(
"
NativeObject
:
:
prepareForSwap
"
)
;
}
if
(
pa
&
&
!
pa
-
>
prepareForSwap
(
cx
&
avals
)
)
{
oomUnsafe
.
crash
(
"
ProxyObject
:
:
prepareForSwap
"
)
;
}
if
(
pb
&
&
!
pb
-
>
prepareForSwap
(
cx
&
bvals
)
)
{
oomUnsafe
.
crash
(
"
ProxyObject
:
:
prepareForSwap
"
)
;
}
char
tmp
[
sizeof
(
JSObject_Slots0
)
]
;
js_memcpy
(
&
tmp
a
sizeof
tmp
)
;
js_memcpy
(
a
b
sizeof
tmp
)
;
js_memcpy
(
b
&
tmp
sizeof
tmp
)
;
if
(
na
&
&
!
NativeObject
:
:
fixupAfterSwap
(
cx
b
.
as
<
NativeObject
>
(
)
kb
avals
)
)
{
oomUnsafe
.
crash
(
"
NativeObject
:
:
fixupAfterSwap
"
)
;
}
if
(
nb
&
&
!
NativeObject
:
:
fixupAfterSwap
(
cx
a
.
as
<
NativeObject
>
(
)
ka
bvals
)
)
{
oomUnsafe
.
crash
(
"
NativeObject
:
:
fixupAfterSwap
"
)
;
}
if
(
pa
&
&
!
b
-
>
as
<
ProxyObject
>
(
)
.
fixupAfterSwap
(
cx
avals
)
)
{
oomUnsafe
.
crash
(
"
ProxyObject
:
:
fixupAfterSwap
"
)
;
}
if
(
pb
&
&
!
a
-
>
as
<
ProxyObject
>
(
)
.
fixupAfterSwap
(
cx
bvals
)
)
{
oomUnsafe
.
crash
(
"
ProxyObject
:
:
fixupAfterSwap
"
)
;
}
}
if
(
(
aid
|
|
bid
)
&
&
(
na
|
|
nb
)
)
{
if
(
(
aid
&
&
!
gc
:
:
SetOrUpdateUniqueId
(
cx
a
aid
)
)
|
|
(
bid
&
&
!
gc
:
:
SetOrUpdateUniqueId
(
cx
b
bid
)
)
)
{
oomUnsafe
.
crash
(
"
Failed
to
set
unique
ID
after
swap
"
)
;
}
}
MOZ_ASSERT_IF
(
aid
gc
:
:
GetUniqueIdInfallible
(
a
)
=
=
aid
)
;
MOZ_ASSERT_IF
(
bid
gc
:
:
GetUniqueIdInfallible
(
b
)
=
=
bid
)
;
if
(
aIsUsedAsPrototype
)
{
if
(
!
JSObject
:
:
setIsUsedAsPrototype
(
cx
a
)
)
{
oomUnsafe
.
crash
(
"
setIsUsedAsPrototype
"
)
;
}
}
if
(
bIsUsedAsPrototype
)
{
if
(
!
JSObject
:
:
setIsUsedAsPrototype
(
cx
b
)
)
{
oomUnsafe
.
crash
(
"
setIsUsedAsPrototype
"
)
;
}
}
PreWriteBarrier
(
zone
a
.
get
(
)
[
]
(
JSTracer
*
trc
JSObject
*
obj
)
{
obj
-
>
traceChildren
(
trc
)
;
}
)
;
PreWriteBarrier
(
zone
b
.
get
(
)
[
]
(
JSTracer
*
trc
JSObject
*
obj
)
{
obj
-
>
traceChildren
(
trc
)
;
}
)
;
NotifyGCPostSwap
(
a
b
r
)
;
}
static
NativeObject
*
DefineConstructorAndPrototype
(
JSContext
*
cx
HandleObject
obj
Handle
<
JSAtom
*
>
atom
HandleObject
protoProto
const
JSClass
*
clasp
Native
constructor
unsigned
nargs
const
JSPropertySpec
*
ps
const
JSFunctionSpec
*
fs
const
JSPropertySpec
*
static_ps
const
JSFunctionSpec
*
static_fs
NativeObject
*
*
ctorp
)
{
Rooted
<
NativeObject
*
>
proto
(
cx
GlobalObject
:
:
createBlankPrototypeInheriting
(
cx
clasp
protoProto
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Rooted
<
NativeObject
*
>
ctor
(
cx
)
;
if
(
!
constructor
)
{
ctor
=
proto
;
}
else
{
ctor
=
NewNativeConstructor
(
cx
constructor
nargs
atom
)
;
if
(
!
ctor
)
{
return
nullptr
;
}
if
(
!
LinkConstructorAndPrototype
(
cx
ctor
proto
)
)
{
return
nullptr
;
}
}
if
(
!
DefinePropertiesAndFunctions
(
cx
proto
ps
fs
)
|
|
(
ctor
!
=
proto
&
&
!
DefinePropertiesAndFunctions
(
cx
ctor
static_ps
static_fs
)
)
)
{
return
nullptr
;
}
RootedId
id
(
cx
AtomToId
(
atom
)
)
;
RootedValue
value
(
cx
ObjectValue
(
*
ctor
)
)
;
if
(
!
DefineDataProperty
(
cx
obj
id
value
0
)
)
{
return
nullptr
;
}
if
(
ctorp
)
{
*
ctorp
=
ctor
;
}
return
proto
;
}
NativeObject
*
js
:
:
InitClass
(
JSContext
*
cx
HandleObject
obj
const
JSClass
*
protoClass
HandleObject
protoProto_
const
char
*
name
Native
constructor
unsigned
nargs
const
JSPropertySpec
*
ps
const
JSFunctionSpec
*
fs
const
JSPropertySpec
*
static_ps
const
JSFunctionSpec
*
static_fs
NativeObject
*
*
ctorp
)
{
Rooted
<
JSAtom
*
>
atom
(
cx
Atomize
(
cx
name
strlen
(
name
)
)
)
;
if
(
!
atom
)
{
return
nullptr
;
}
RootedObject
protoProto
(
cx
protoProto_
)
;
if
(
!
protoProto
)
{
protoProto
=
&
cx
-
>
global
(
)
-
>
getObjectPrototype
(
)
;
}
if
(
!
protoClass
)
{
protoClass
=
&
PlainObject
:
:
class_
;
}
return
DefineConstructorAndPrototype
(
cx
obj
atom
protoProto
protoClass
constructor
nargs
ps
fs
static_ps
static_fs
ctorp
)
;
}
bool
js
:
:
GetObjectFromIncumbentGlobal
(
JSContext
*
cx
MutableHandleObject
obj
)
{
Rooted
<
GlobalObject
*
>
globalObj
(
cx
cx
-
>
runtime
(
)
-
>
getIncumbentGlobal
(
cx
)
)
;
if
(
!
globalObj
)
{
obj
.
set
(
nullptr
)
;
return
true
;
}
obj
.
set
(
&
globalObj
-
>
getObjectPrototype
(
)
)
;
if
(
obj
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
obj
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsStandardPrototype
(
JSObject
*
obj
JSProtoKey
key
)
{
return
obj
-
>
nonCCWGlobal
(
)
.
maybeGetPrototype
(
key
)
=
=
obj
;
}
JSProtoKey
JS
:
:
IdentifyStandardInstance
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
JSProtoKey
key
=
StandardProtoKeyOrNull
(
obj
)
;
if
(
key
!
=
JSProto_Null
&
&
!
IsStandardPrototype
(
obj
key
)
)
{
return
key
;
}
return
JSProto_Null
;
}
JSProtoKey
JS
:
:
IdentifyStandardPrototype
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
JSProtoKey
key
=
StandardProtoKeyOrNull
(
obj
)
;
if
(
key
!
=
JSProto_Null
&
&
IsStandardPrototype
(
obj
key
)
)
{
return
key
;
}
return
JSProto_Null
;
}
JSProtoKey
JS
:
:
IdentifyStandardInstanceOrPrototype
(
JSObject
*
obj
)
{
return
StandardProtoKeyOrNull
(
obj
)
;
}
JSProtoKey
JS
:
:
IdentifyStandardConstructor
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
|
|
!
(
obj
-
>
as
<
JSFunction
>
(
)
.
flags
(
)
.
isNativeConstructor
(
)
)
)
{
return
JSProto_Null
;
}
static_assert
(
JSProto_Null
=
=
0
"
Loop
below
can
start
at
1
to
skip
JSProto_Null
"
)
;
GlobalObject
&
global
=
obj
-
>
as
<
JSFunction
>
(
)
.
global
(
)
;
for
(
size_t
k
=
1
;
k
<
JSProto_LIMIT
;
+
+
k
)
{
JSProtoKey
key
=
static_cast
<
JSProtoKey
>
(
k
)
;
if
(
global
.
maybeGetConstructor
(
key
)
=
=
obj
)
{
return
key
;
}
}
return
JSProto_Null
;
}
bool
js
:
:
LookupProperty
(
JSContext
*
cx
HandleObject
obj
js
:
:
HandleId
id
MutableHandleObject
objp
PropertyResult
*
propp
)
{
if
(
LookupPropertyOp
op
=
obj
-
>
getOpsLookupProperty
(
)
)
{
return
op
(
cx
obj
id
objp
propp
)
;
}
return
NativeLookupPropertyInline
<
CanGC
>
(
cx
obj
.
as
<
NativeObject
>
(
)
id
objp
propp
)
;
}
bool
js
:
:
LookupName
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
HandleObject
envChain
MutableHandleObject
objp
MutableHandleObject
pobjp
PropertyResult
*
propp
)
{
RootedId
id
(
cx
NameToId
(
name
)
)
;
for
(
RootedObject
env
(
cx
envChain
)
;
env
;
env
=
env
-
>
enclosingEnvironment
(
)
)
{
if
(
!
LookupProperty
(
cx
env
id
pobjp
propp
)
)
{
return
false
;
}
if
(
propp
-
>
isFound
(
)
)
{
objp
.
set
(
env
)
;
return
true
;
}
}
objp
.
set
(
nullptr
)
;
pobjp
.
set
(
nullptr
)
;
propp
-
>
setNotFound
(
)
;
return
true
;
}
bool
js
:
:
LookupNameNoGC
(
JSContext
*
cx
PropertyName
*
name
JSObject
*
envChain
JSObject
*
*
objp
NativeObject
*
*
pobjp
PropertyResult
*
propp
)
{
AutoAssertNoPendingException
nogc
(
cx
)
;
MOZ_ASSERT
(
!
*
objp
&
&
!
*
pobjp
&
&
propp
-
>
isNotFound
(
)
)
;
for
(
JSObject
*
env
=
envChain
;
env
;
env
=
env
-
>
enclosingEnvironment
(
)
)
{
if
(
env
-
>
getOpsLookupProperty
(
)
)
{
return
false
;
}
if
(
!
NativeLookupPropertyInline
<
NoGC
>
(
cx
&
env
-
>
as
<
NativeObject
>
(
)
NameToId
(
name
)
pobjp
propp
)
)
{
return
false
;
}
if
(
propp
-
>
isFound
(
)
)
{
*
objp
=
env
;
return
true
;
}
}
return
true
;
}
bool
js
:
:
LookupNameWithGlobalDefault
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
HandleObject
envChain
MutableHandleObject
objp
)
{
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
pobj
(
cx
)
;
PropertyResult
prop
;
RootedObject
env
(
cx
envChain
)
;
for
(
;
!
env
-
>
is
<
GlobalObject
>
(
)
;
env
=
env
-
>
enclosingEnvironment
(
)
)
{
if
(
!
LookupProperty
(
cx
env
id
&
pobj
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isFound
(
)
)
{
break
;
}
}
objp
.
set
(
env
)
;
return
true
;
}
bool
js
:
:
LookupNameUnqualified
(
JSContext
*
cx
Handle
<
PropertyName
*
>
name
HandleObject
envChain
MutableHandleObject
objp
)
{
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
pobj
(
cx
)
;
PropertyResult
prop
;
RootedObject
env
(
cx
envChain
)
;
for
(
;
!
env
-
>
isUnqualifiedVarObj
(
)
;
env
=
env
-
>
enclosingEnvironment
(
)
)
{
if
(
!
LookupProperty
(
cx
env
id
&
pobj
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isFound
(
)
)
{
break
;
}
}
if
(
pobj
=
=
env
)
{
bool
isTDZ
=
false
;
if
(
prop
.
isFound
(
)
&
&
name
!
=
cx
-
>
names
(
)
.
dot_this_
)
{
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
{
RootedValue
v
(
cx
)
;
Rooted
<
DebugEnvironmentProxy
*
>
envProxy
(
cx
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
)
;
if
(
!
DebugEnvironmentProxy
:
:
getMaybeSentinelValue
(
cx
envProxy
id
&
v
)
)
{
return
false
;
}
isTDZ
=
IsUninitializedLexical
(
v
)
;
}
else
{
isTDZ
=
IsUninitializedLexicalSlot
(
env
prop
)
;
}
}
if
(
isTDZ
)
{
env
=
RuntimeLexicalErrorObject
:
:
create
(
cx
env
JSMSG_UNINITIALIZED_LEXICAL
)
;
if
(
!
env
)
{
return
false
;
}
}
else
if
(
env
-
>
is
<
LexicalEnvironmentObject
>
(
)
&
&
!
prop
.
propertyInfo
(
)
.
writable
(
)
)
{
if
(
!
(
env
-
>
is
<
BlockLexicalEnvironmentObject
>
(
)
&
&
env
-
>
as
<
BlockLexicalEnvironmentObject
>
(
)
.
scope
(
)
.
kind
(
)
=
=
ScopeKind
:
:
NamedLambda
)
)
{
MOZ_ASSERT
(
name
!
=
cx
-
>
names
(
)
.
dot_this_
)
;
env
=
RuntimeLexicalErrorObject
:
:
create
(
cx
env
JSMSG_BAD_CONST_ASSIGN
)
;
if
(
!
env
)
{
return
false
;
}
}
}
}
objp
.
set
(
env
)
;
return
true
;
}
bool
js
:
:
HasOwnProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
result
)
{
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
Proxy
:
:
hasOwn
(
cx
obj
id
result
)
;
}
if
(
GetOwnPropertyOp
op
=
obj
-
>
getOpsGetOwnPropertyDescriptor
(
)
)
{
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
if
(
!
op
(
cx
obj
id
&
desc
)
)
{
return
false
;
}
*
result
=
desc
.
isSome
(
)
;
return
true
;
}
PropertyResult
prop
;
if
(
!
NativeLookupOwnProperty
<
CanGC
>
(
cx
obj
.
as
<
NativeObject
>
(
)
id
&
prop
)
)
{
return
false
;
}
*
result
=
prop
.
isFound
(
)
;
return
true
;
}
bool
js
:
:
LookupPropertyPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
NativeObject
*
*
objp
PropertyResult
*
propp
)
{
if
(
obj
-
>
getOpsLookupProperty
(
)
)
{
return
false
;
}
return
NativeLookupPropertyInline
<
NoGC
LookupResolveMode
:
:
CheckMayResolve
>
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
id
objp
propp
)
;
}
bool
js
:
:
LookupOwnPropertyPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
PropertyResult
*
propp
)
{
if
(
obj
-
>
getOpsLookupProperty
(
)
)
{
return
false
;
}
return
NativeLookupOwnPropertyInline
<
NoGC
LookupResolveMode
:
:
CheckMayResolve
>
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
id
propp
)
;
}
static
inline
bool
NativeGetPureInline
(
NativeObject
*
pobj
jsid
id
PropertyResult
prop
Value
*
vp
JSContext
*
cx
)
{
if
(
prop
.
isDenseElement
(
)
)
{
*
vp
=
pobj
-
>
getDenseElement
(
prop
.
denseElementIndex
(
)
)
;
return
true
;
}
if
(
prop
.
isTypedArrayElement
(
)
)
{
size_t
idx
=
prop
.
typedArrayElementIndex
(
)
;
return
pobj
-
>
as
<
TypedArrayObject
>
(
)
.
getElement
<
NoGC
>
(
cx
idx
vp
)
;
}
PropertyInfo
propInfo
=
prop
.
propertyInfo
(
)
;
if
(
!
propInfo
.
isDataProperty
(
)
)
{
return
false
;
}
*
vp
=
pobj
-
>
getSlot
(
propInfo
.
slot
(
)
)
;
MOZ_ASSERT
(
!
vp
-
>
isMagic
(
)
)
;
return
true
;
}
bool
js
:
:
GetPropertyPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
Value
*
vp
)
{
NativeObject
*
pobj
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
pobj
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
vp
-
>
setUndefined
(
)
;
return
true
;
}
return
NativeGetPureInline
(
pobj
id
prop
vp
cx
)
;
}
bool
js
:
:
GetOwnPropertyPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
Value
*
vp
bool
*
found
)
{
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
*
found
=
false
;
vp
-
>
setUndefined
(
)
;
return
true
;
}
*
found
=
true
;
return
obj
-
>
is
<
NativeObject
>
(
)
&
&
NativeGetPureInline
(
&
obj
-
>
as
<
NativeObject
>
(
)
id
prop
vp
cx
)
;
}
static
inline
bool
NativeGetGetterPureInline
(
NativeObject
*
holder
PropertyResult
prop
JSFunction
*
*
fp
)
{
MOZ_ASSERT
(
prop
.
isNativeProperty
(
)
)
;
PropertyInfo
propInfo
=
prop
.
propertyInfo
(
)
;
if
(
holder
-
>
hasGetter
(
propInfo
)
)
{
JSObject
*
getter
=
holder
-
>
getGetter
(
propInfo
)
;
if
(
getter
-
>
is
<
JSFunction
>
(
)
)
{
*
fp
=
&
getter
-
>
as
<
JSFunction
>
(
)
;
return
true
;
}
}
*
fp
=
nullptr
;
return
true
;
}
bool
js
:
:
GetGetterPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
JSFunction
*
*
fp
)
{
NativeObject
*
pobj
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
pobj
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
*
fp
=
nullptr
;
return
true
;
}
return
prop
.
isNativeProperty
(
)
&
&
NativeGetGetterPureInline
(
pobj
prop
fp
)
;
}
bool
js
:
:
GetOwnGetterPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
JSFunction
*
*
fp
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
*
fp
=
nullptr
;
return
true
;
}
return
prop
.
isNativeProperty
(
)
&
&
NativeGetGetterPureInline
(
&
obj
-
>
as
<
NativeObject
>
(
)
prop
fp
)
;
}
bool
js
:
:
GetOwnNativeGetterPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
JSNative
*
native
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
*
native
=
nullptr
;
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
if
(
!
prop
.
isNativeProperty
(
)
)
{
return
true
;
}
PropertyInfo
propInfo
=
prop
.
propertyInfo
(
)
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
hasGetter
(
propInfo
)
)
{
return
true
;
}
JSObject
*
getterObj
=
nobj
-
>
getGetter
(
propInfo
)
;
if
(
!
getterObj
-
>
is
<
JSFunction
>
(
)
)
{
return
true
;
}
JSFunction
*
getter
=
&
getterObj
-
>
as
<
JSFunction
>
(
)
;
if
(
!
getter
-
>
isNativeFun
(
)
)
{
return
true
;
}
*
native
=
getter
-
>
native
(
)
;
return
true
;
}
bool
js
:
:
HasOwnDataPropertyPure
(
JSContext
*
cx
JSObject
*
obj
jsid
id
bool
*
result
)
{
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
*
result
=
prop
.
isNativeProperty
(
)
&
&
prop
.
propertyInfo
(
)
.
isDataProperty
(
)
;
return
true
;
}
bool
js
:
:
GetPrototypeIfOrdinary
(
JSContext
*
cx
HandleObject
obj
bool
*
isOrdinary
MutableHandleObject
protop
)
{
if
(
obj
-
>
is
<
js
:
:
ProxyObject
>
(
)
)
{
return
js
:
:
Proxy
:
:
getPrototypeIfOrdinary
(
cx
obj
isOrdinary
protop
)
;
}
*
isOrdinary
=
true
;
protop
.
set
(
obj
-
>
staticPrototype
(
)
)
;
return
true
;
}
bool
js
:
:
SetPrototype
(
JSContext
*
cx
HandleObject
obj
HandleObject
proto
JS
:
:
ObjectOpResult
&
result
)
{
if
(
obj
-
>
hasDynamicPrototype
(
)
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
return
Proxy
:
:
setPrototype
(
cx
obj
proto
result
)
;
}
if
(
proto
=
=
obj
-
>
staticPrototype
(
)
)
{
return
result
.
succeed
(
)
;
}
if
(
obj
-
>
staticPrototypeIsImmutable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_SET_PROTO
)
;
}
if
(
obj
-
>
is
<
WasmGcObject
>
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_SET_PROTO
)
;
}
bool
extensible
;
if
(
!
IsExtensible
(
cx
obj
&
extensible
)
)
{
return
false
;
}
if
(
!
extensible
)
{
return
result
.
fail
(
JSMSG_CANT_SET_PROTO
)
;
}
RootedObject
objMaybeWindowProxy
(
cx
ToWindowProxyIfWindow
(
obj
)
)
;
RootedObject
obj2
(
cx
proto
)
;
while
(
obj2
)
{
MOZ_ASSERT
(
!
IsWindow
(
obj2
)
)
;
if
(
obj2
=
=
objMaybeWindowProxy
)
{
return
result
.
fail
(
JSMSG_CANT_SET_PROTO_CYCLE
)
;
}
bool
isOrdinary
;
if
(
!
GetPrototypeIfOrdinary
(
cx
obj2
&
isOrdinary
&
obj2
)
)
{
return
false
;
}
if
(
!
isOrdinary
)
{
break
;
}
}
Rooted
<
TaggedProto
>
taggedProto
(
cx
TaggedProto
(
proto
)
)
;
if
(
!
JSObject
:
:
setProtoUnchecked
(
cx
obj
taggedProto
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
bool
js
:
:
SetPrototype
(
JSContext
*
cx
HandleObject
obj
HandleObject
proto
)
{
ObjectOpResult
result
;
return
SetPrototype
(
cx
obj
proto
result
)
&
&
result
.
checkStrict
(
cx
obj
)
;
}
bool
js
:
:
PreventExtensions
(
JSContext
*
cx
HandleObject
obj
ObjectOpResult
&
result
)
{
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
js
:
:
Proxy
:
:
preventExtensions
(
cx
obj
result
)
;
}
if
(
obj
-
>
is
<
WasmGcObject
>
(
)
)
{
return
result
.
failCantPreventExtensions
(
)
;
}
if
(
!
obj
-
>
nonProxyIsExtensible
(
)
)
{
MOZ_ASSERT_IF
(
obj
-
>
is
<
NativeObject
>
(
)
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
=
=
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseCapacity
(
)
)
;
return
result
.
succeed
(
)
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
Handle
<
NativeObject
*
>
nobj
=
obj
.
as
<
NativeObject
>
(
)
;
if
(
!
ResolveLazyProperties
(
cx
nobj
)
)
{
return
false
;
}
ObjectElements
:
:
PrepareForPreventExtensions
(
cx
nobj
)
;
}
if
(
!
JSObject
:
:
setFlag
(
cx
obj
ObjectFlag
:
:
NotExtensible
)
)
{
return
false
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
ObjectElements
:
:
PreventExtensions
(
&
obj
-
>
as
<
NativeObject
>
(
)
)
;
}
return
result
.
succeed
(
)
;
}
bool
js
:
:
PreventExtensions
(
JSContext
*
cx
HandleObject
obj
)
{
ObjectOpResult
result
;
return
PreventExtensions
(
cx
obj
result
)
&
&
result
.
checkStrict
(
cx
obj
)
;
}
bool
js
:
:
GetOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
Maybe
<
PropertyDescriptor
>
>
desc
)
{
if
(
GetOwnPropertyOp
op
=
obj
-
>
getOpsGetOwnPropertyDescriptor
(
)
)
{
bool
ok
=
op
(
cx
obj
id
desc
)
;
if
(
ok
&
&
desc
.
isSome
(
)
)
{
desc
-
>
assertComplete
(
)
;
}
return
ok
;
}
return
NativeGetOwnPropertyDescriptor
(
cx
obj
.
as
<
NativeObject
>
(
)
id
desc
)
;
}
bool
js
:
:
DefineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
)
{
ObjectOpResult
result
;
return
DefineProperty
(
cx
obj
id
desc
result
)
&
&
result
.
checkStrict
(
cx
obj
id
)
;
}
bool
js
:
:
DefineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
{
desc
.
assertValid
(
)
;
if
(
DefinePropertyOp
op
=
obj
-
>
getOpsDefineProperty
(
)
)
{
return
op
(
cx
obj
id
desc
result
)
;
}
return
NativeDefineProperty
(
cx
obj
.
as
<
NativeObject
>
(
)
id
desc
result
)
;
}
bool
js
:
:
DefineAccessorProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleObject
getter
HandleObject
setter
unsigned
attrs
ObjectOpResult
&
result
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
PropertyDescriptor
:
:
Accessor
(
getter
?
mozilla
:
:
Some
(
getter
)
:
mozilla
:
:
Nothing
(
)
setter
?
mozilla
:
:
Some
(
setter
)
:
mozilla
:
:
Nothing
(
)
attrs
)
)
;
if
(
DefinePropertyOp
op
=
obj
-
>
getOpsDefineProperty
(
)
)
{
return
op
(
cx
obj
id
desc
result
)
;
}
return
NativeDefineProperty
(
cx
obj
.
as
<
NativeObject
>
(
)
id
desc
result
)
;
}
bool
js
:
:
DefineDataProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
value
unsigned
attrs
ObjectOpResult
&
result
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
PropertyDescriptor
:
:
Data
(
value
attrs
)
)
;
if
(
DefinePropertyOp
op
=
obj
-
>
getOpsDefineProperty
(
)
)
{
return
op
(
cx
obj
id
desc
result
)
;
}
return
NativeDefineProperty
(
cx
obj
.
as
<
NativeObject
>
(
)
id
desc
result
)
;
}
bool
js
:
:
DefineAccessorProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleObject
getter
HandleObject
setter
unsigned
attrs
)
{
ObjectOpResult
result
;
if
(
!
DefineAccessorProperty
(
cx
obj
id
getter
setter
attrs
result
)
)
{
return
false
;
}
if
(
!
result
)
{
result
.
reportError
(
cx
obj
id
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
DefineDataProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
value
unsigned
attrs
)
{
ObjectOpResult
result
;
if
(
!
DefineDataProperty
(
cx
obj
id
value
attrs
result
)
)
{
return
false
;
}
if
(
!
result
)
{
result
.
reportError
(
cx
obj
id
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
DefineDataProperty
(
JSContext
*
cx
HandleObject
obj
PropertyName
*
name
HandleValue
value
unsigned
attrs
)
{
RootedId
id
(
cx
NameToId
(
name
)
)
;
return
DefineDataProperty
(
cx
obj
id
value
attrs
)
;
}
bool
js
:
:
DefineDataElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
HandleValue
value
unsigned
attrs
)
{
RootedId
id
(
cx
)
;
if
(
!
IndexToId
(
cx
index
&
id
)
)
{
return
false
;
}
return
DefineDataProperty
(
cx
obj
id
value
attrs
)
;
}
bool
js
:
:
SetImmutablePrototype
(
JSContext
*
cx
HandleObject
obj
bool
*
succeeded
)
{
if
(
obj
-
>
hasDynamicPrototype
(
)
)
{
return
Proxy
:
:
setImmutablePrototype
(
cx
obj
succeeded
)
;
}
if
(
!
JSObject
:
:
setFlag
(
cx
obj
ObjectFlag
:
:
ImmutablePrototype
)
)
{
return
false
;
}
*
succeeded
=
true
;
return
true
;
}
bool
js
:
:
GetPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
MutableHandleObject
holder
)
{
RootedObject
pobj
(
cx
)
;
for
(
pobj
=
obj
;
pobj
;
)
{
if
(
!
GetOwnPropertyDescriptor
(
cx
pobj
id
desc
)
)
{
return
false
;
}
if
(
desc
.
isSome
(
)
)
{
holder
.
set
(
pobj
)
;
return
true
;
}
if
(
!
GetPrototype
(
cx
pobj
&
pobj
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
desc
.
isNothing
(
)
)
;
holder
.
set
(
nullptr
)
;
return
true
;
}
extern
bool
PropertySpecNameToId
(
JSContext
*
cx
JSPropertySpec
:
:
Name
name
MutableHandleId
id
)
;
JS_PUBLIC_API
bool
js
:
:
ShouldIgnorePropertyDefinition
(
JSContext
*
cx
JSProtoKey
key
jsid
id
)
{
if
(
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getToSourceEnabled
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
toSource
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
uneval
)
)
)
{
return
true
;
}
if
(
key
=
=
JSProto_FinalizationRegistry
&
&
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getWeakRefsEnabled
(
)
=
=
JS
:
:
WeakRefSpecifier
:
:
EnabledWithoutCleanupSome
&
&
id
=
=
NameToId
(
cx
-
>
names
(
)
.
cleanupSome
)
)
{
return
true
;
}
if
(
key
=
=
JSProto_Function
&
&
!
JS
:
:
Prefs
:
:
array_grouping
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
groupBy
)
)
)
{
return
true
;
}
#
ifdef
NIGHTLY_BUILD
if
(
key
=
=
JSProto_Set
&
&
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getNewSetMethodsEnabled
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
union_
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
difference
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
intersection
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
isSubsetOf
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
isSupersetOf
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
isDisjointFrom
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
symmetricDifference
)
)
)
{
return
true
;
}
#
endif
#
ifdef
NIGHTLY_BUILD
if
(
key
=
=
JSProto_ArrayBuffer
&
&
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getArrayBufferTransferEnabled
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
transfer
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
transferToFixedLength
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
detached
)
)
)
{
return
true
;
}
if
(
key
=
=
JSProto_ArrayBuffer
&
&
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getArrayBufferResizableEnabled
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
maxByteLength
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
resizable
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
resize
)
)
)
{
return
true
;
}
if
(
key
=
=
JSProto_SharedArrayBuffer
&
&
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedArrayBufferGrowableEnabled
(
)
&
&
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
maxByteLength
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
growable
)
|
|
id
=
=
NameToId
(
cx
-
>
names
(
)
.
grow
)
)
)
{
return
true
;
}
#
endif
return
false
;
}
static
bool
DefineFunctionFromSpec
(
JSContext
*
cx
HandleObject
obj
const
JSFunctionSpec
*
fs
)
{
RootedId
id
(
cx
)
;
if
(
!
PropertySpecNameToId
(
cx
fs
-
>
name
&
id
)
)
{
return
false
;
}
if
(
ShouldIgnorePropertyDefinition
(
cx
StandardProtoKeyOrNull
(
obj
)
id
)
)
{
return
true
;
}
JSFunction
*
fun
=
NewFunctionFromSpec
(
cx
fs
id
)
;
if
(
!
fun
)
{
return
false
;
}
RootedValue
funVal
(
cx
ObjectValue
(
*
fun
)
)
;
return
DefineDataProperty
(
cx
obj
id
funVal
fs
-
>
flags
&
~
JSFUN_FLAGS_MASK
)
;
}
bool
js
:
:
DefineFunctions
(
JSContext
*
cx
HandleObject
obj
const
JSFunctionSpec
*
fs
)
{
for
(
;
fs
-
>
name
;
fs
+
+
)
{
if
(
!
DefineFunctionFromSpec
(
cx
obj
fs
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
MaybeCallMethod
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleValue
vp
)
{
if
(
!
GetProperty
(
cx
obj
obj
id
vp
)
)
{
return
false
;
}
if
(
!
IsCallable
(
vp
)
)
{
vp
.
setObject
(
*
obj
)
;
return
true
;
}
return
js
:
:
Call
(
cx
vp
obj
vp
)
;
}
static
bool
ReportCantConvert
(
JSContext
*
cx
unsigned
errorNumber
HandleObject
obj
JSType
hint
)
{
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
RootedString
str
(
cx
)
;
if
(
hint
=
=
JSTYPE_STRING
)
{
str
=
JS_AtomizeString
(
cx
clasp
-
>
name
)
;
if
(
!
str
)
{
return
false
;
}
}
else
{
str
=
nullptr
;
}
RootedValue
val
(
cx
ObjectValue
(
*
obj
)
)
;
ReportValueError
(
cx
errorNumber
JSDVG_SEARCH_STACK
val
str
hint
=
=
JSTYPE_UNDEFINED
?
"
primitive
type
"
:
hint
=
=
JSTYPE_STRING
?
"
string
"
:
"
number
"
)
;
return
false
;
}
bool
JS
:
:
OrdinaryToPrimitive
(
JSContext
*
cx
HandleObject
obj
JSType
hint
MutableHandleValue
vp
)
{
MOZ_ASSERT
(
hint
=
=
JSTYPE_NUMBER
|
|
hint
=
=
JSTYPE_STRING
|
|
hint
=
=
JSTYPE_UNDEFINED
)
;
Rooted
<
jsid
>
id
(
cx
)
;
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
hint
=
=
JSTYPE_STRING
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
toString
)
;
bool
calledToString
=
false
;
if
(
clasp
=
=
&
StringObject
:
:
class_
)
{
StringObject
*
nobj
=
&
obj
-
>
as
<
StringObject
>
(
)
;
if
(
HasNativeMethodPure
(
nobj
cx
-
>
names
(
)
.
toString
str_toString
cx
)
)
{
vp
.
setString
(
nobj
-
>
unbox
(
)
)
;
return
true
;
}
}
else
if
(
clasp
=
=
&
PlainObject
:
:
class_
)
{
JSFunction
*
fun
;
if
(
GetPropertyPure
(
cx
obj
id
vp
.
address
(
)
)
&
&
IsFunctionObject
(
vp
&
fun
)
)
{
if
(
fun
-
>
maybeNative
(
)
=
=
obj_toString
&
&
!
MaybeHasInterestingSymbolProperty
(
cx
obj
cx
-
>
wellKnownSymbols
(
)
.
toStringTag
)
)
{
vp
.
setString
(
cx
-
>
names
(
)
.
object_Object_
)
;
return
true
;
}
if
(
!
js
:
:
Call
(
cx
vp
obj
vp
)
)
{
return
false
;
}
calledToString
=
true
;
}
}
if
(
!
calledToString
)
{
if
(
!
MaybeCallMethod
(
cx
obj
id
vp
)
)
{
return
false
;
}
}
if
(
vp
.
isPrimitive
(
)
)
{
return
true
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
valueOf
)
;
if
(
!
MaybeCallMethod
(
cx
obj
id
vp
)
)
{
return
false
;
}
if
(
vp
.
isPrimitive
(
)
)
{
return
true
;
}
}
else
{
id
=
NameToId
(
cx
-
>
names
(
)
.
valueOf
)
;
if
(
clasp
=
=
&
StringObject
:
:
class_
)
{
StringObject
*
nobj
=
&
obj
-
>
as
<
StringObject
>
(
)
;
if
(
HasNativeMethodPure
(
nobj
cx
-
>
names
(
)
.
valueOf
str_toString
cx
)
)
{
vp
.
setString
(
nobj
-
>
unbox
(
)
)
;
return
true
;
}
}
else
if
(
clasp
=
=
&
NumberObject
:
:
class_
)
{
NumberObject
*
nobj
=
&
obj
-
>
as
<
NumberObject
>
(
)
;
if
(
HasNativeMethodPure
(
nobj
cx
-
>
names
(
)
.
valueOf
num_valueOf
cx
)
)
{
vp
.
setNumber
(
nobj
-
>
unbox
(
)
)
;
return
true
;
}
}
if
(
!
MaybeCallMethod
(
cx
obj
id
vp
)
)
{
return
false
;
}
if
(
vp
.
isPrimitive
(
)
)
{
return
true
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
toString
)
;
if
(
!
MaybeCallMethod
(
cx
obj
id
vp
)
)
{
return
false
;
}
if
(
vp
.
isPrimitive
(
)
)
{
return
true
;
}
}
return
ReportCantConvert
(
cx
JSMSG_CANT_CONVERT_TO
obj
hint
)
;
}
bool
js
:
:
ToPrimitiveSlow
(
JSContext
*
cx
JSType
preferredType
MutableHandleValue
vp
)
{
MOZ_ASSERT
(
preferredType
=
=
JSTYPE_UNDEFINED
|
|
preferredType
=
=
JSTYPE_STRING
|
|
preferredType
=
=
JSTYPE_NUMBER
)
;
RootedObject
obj
(
cx
&
vp
.
toObject
(
)
)
;
RootedValue
method
(
cx
)
;
if
(
!
GetInterestingSymbolProperty
(
cx
obj
cx
-
>
wellKnownSymbols
(
)
.
toPrimitive
&
method
)
)
{
return
false
;
}
if
(
!
method
.
isNullOrUndefined
(
)
)
{
if
(
!
IsCallable
(
method
)
)
{
return
ReportCantConvert
(
cx
JSMSG_TOPRIMITIVE_NOT_CALLABLE
obj
preferredType
)
;
}
RootedValue
arg0
(
cx
StringValue
(
preferredType
=
=
JSTYPE_STRING
?
cx
-
>
names
(
)
.
string
:
preferredType
=
=
JSTYPE_NUMBER
?
cx
-
>
names
(
)
.
number
:
cx
-
>
names
(
)
.
default_
)
)
;
if
(
!
js
:
:
Call
(
cx
method
vp
arg0
vp
)
)
{
return
false
;
}
if
(
vp
.
isObject
(
)
)
{
return
ReportCantConvert
(
cx
JSMSG_TOPRIMITIVE_RETURNED_OBJECT
obj
preferredType
)
;
}
return
true
;
}
return
OrdinaryToPrimitive
(
cx
obj
preferredType
vp
)
;
}
bool
js
:
:
ToPropertyKeySlow
(
JSContext
*
cx
HandleValue
argument
MutableHandleId
result
)
{
MOZ_ASSERT
(
argument
.
isObject
(
)
)
;
RootedValue
key
(
cx
argument
)
;
if
(
!
ToPrimitiveSlow
(
cx
JSTYPE_STRING
&
key
)
)
{
return
false
;
}
return
PrimitiveValueToId
<
CanGC
>
(
cx
key
result
)
;
}
bool
js
:
:
IsPrototypeOf
(
JSContext
*
cx
HandleObject
protoObj
JSObject
*
obj
bool
*
result
)
{
RootedObject
obj2
(
cx
obj
)
;
for
(
;
;
)
{
if
(
!
CheckForInterrupt
(
cx
)
)
{
return
false
;
}
if
(
!
GetPrototype
(
cx
obj2
&
obj2
)
)
{
return
false
;
}
if
(
!
obj2
)
{
*
result
=
false
;
return
true
;
}
if
(
obj2
=
=
protoObj
)
{
*
result
=
true
;
return
true
;
}
}
}
JSObject
*
js
:
:
PrimitiveToObject
(
JSContext
*
cx
const
Value
&
v
)
{
MOZ_ASSERT
(
v
.
isPrimitive
(
)
)
;
switch
(
v
.
type
(
)
)
{
case
ValueType
:
:
String
:
{
Rooted
<
JSString
*
>
str
(
cx
v
.
toString
(
)
)
;
return
StringObject
:
:
create
(
cx
str
)
;
}
case
ValueType
:
:
Double
:
case
ValueType
:
:
Int32
:
return
NumberObject
:
:
create
(
cx
v
.
toNumber
(
)
)
;
case
ValueType
:
:
Boolean
:
return
BooleanObject
:
:
create
(
cx
v
.
toBoolean
(
)
)
;
case
ValueType
:
:
Symbol
:
{
RootedSymbol
symbol
(
cx
v
.
toSymbol
(
)
)
;
return
SymbolObject
:
:
create
(
cx
symbol
)
;
}
case
ValueType
:
:
BigInt
:
{
RootedBigInt
bigInt
(
cx
v
.
toBigInt
(
)
)
;
return
BigIntObject
:
:
create
(
cx
bigInt
)
;
}
#
ifdef
ENABLE_RECORD_TUPLE
case
ValueType
:
:
ExtendedPrimitive
:
{
JSObject
&
obj
=
v
.
toExtendedPrimitive
(
)
;
if
(
obj
.
is
<
RecordType
>
(
)
)
{
Rooted
<
RecordType
*
>
rec
(
cx
&
obj
.
as
<
RecordType
>
(
)
)
;
return
RecordObject
:
:
create
(
cx
rec
)
;
}
if
(
obj
.
is
<
TupleType
>
(
)
)
{
Rooted
<
TupleType
*
>
tuple
(
cx
&
obj
.
as
<
TupleType
>
(
)
)
;
return
TupleObject
:
:
create
(
cx
tuple
)
;
}
MOZ_CRASH
(
"
Unexpected
ExtendedPrimitive
type
.
"
)
;
}
#
endif
case
ValueType
:
:
Undefined
:
case
ValueType
:
:
Null
:
case
ValueType
:
:
Magic
:
case
ValueType
:
:
PrivateGCThing
:
case
ValueType
:
:
Object
:
break
;
}
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
JSProtoKey
js
:
:
PrimitiveToProtoKey
(
JSContext
*
cx
const
Value
&
v
)
{
MOZ_ASSERT
(
v
.
isPrimitive
(
)
)
;
switch
(
v
.
type
(
)
)
{
case
ValueType
:
:
String
:
return
JSProto_String
;
case
ValueType
:
:
Double
:
case
ValueType
:
:
Int32
:
return
JSProto_Number
;
case
ValueType
:
:
Boolean
:
return
JSProto_Boolean
;
case
ValueType
:
:
Symbol
:
return
JSProto_Symbol
;
case
ValueType
:
:
BigInt
:
return
JSProto_BigInt
;
#
ifdef
ENABLE_RECORD_TUPLE
case
ValueType
:
:
ExtendedPrimitive
:
if
(
v
.
toExtendedPrimitive
(
)
.
is
<
TupleType
>
(
)
)
{
return
JSProto_Tuple
;
}
if
(
v
.
toExtendedPrimitive
(
)
.
is
<
RecordType
>
(
)
)
{
return
JSProto_Null
;
}
MOZ_CRASH
(
"
Unsupported
ExtendedPrimitive
"
)
;
#
endif
case
ValueType
:
:
Undefined
:
case
ValueType
:
:
Null
:
case
ValueType
:
:
Magic
:
case
ValueType
:
:
PrivateGCThing
:
case
ValueType
:
:
Object
:
break
;
}
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
JSObject
*
js
:
:
ToObjectSlow
(
JSContext
*
cx
JS
:
:
HandleValue
val
bool
reportScanStack
)
{
MOZ_ASSERT
(
!
val
.
isMagic
(
)
)
;
MOZ_ASSERT
(
!
val
.
isObject
(
)
)
;
if
(
val
.
isNullOrUndefined
(
)
)
{
ReportIsNullOrUndefinedForPropertyAccess
(
cx
val
reportScanStack
?
JSDVG_SEARCH_STACK
:
JSDVG_IGNORE_STACK
)
;
return
nullptr
;
}
return
PrimitiveToObject
(
cx
val
)
;
}
JSObject
*
js
:
:
ToObjectSlowForPropertyAccess
(
JSContext
*
cx
JS
:
:
HandleValue
val
int
valIndex
HandleId
key
)
{
MOZ_ASSERT
(
!
val
.
isMagic
(
)
)
;
MOZ_ASSERT
(
!
val
.
isObject
(
)
)
;
if
(
val
.
isNullOrUndefined
(
)
)
{
ReportIsNullOrUndefinedForPropertyAccess
(
cx
val
valIndex
key
)
;
return
nullptr
;
}
return
PrimitiveToObject
(
cx
val
)
;
}
JSObject
*
js
:
:
ToObjectSlowForPropertyAccess
(
JSContext
*
cx
JS
:
:
HandleValue
val
int
valIndex
Handle
<
PropertyName
*
>
key
)
{
MOZ_ASSERT
(
!
val
.
isMagic
(
)
)
;
MOZ_ASSERT
(
!
val
.
isObject
(
)
)
;
if
(
val
.
isNullOrUndefined
(
)
)
{
RootedId
keyId
(
cx
NameToId
(
key
)
)
;
ReportIsNullOrUndefinedForPropertyAccess
(
cx
val
valIndex
keyId
)
;
return
nullptr
;
}
return
PrimitiveToObject
(
cx
val
)
;
}
JSObject
*
js
:
:
ToObjectSlowForPropertyAccess
(
JSContext
*
cx
JS
:
:
HandleValue
val
int
valIndex
HandleValue
keyValue
)
{
MOZ_ASSERT
(
!
val
.
isMagic
(
)
)
;
MOZ_ASSERT
(
!
val
.
isObject
(
)
)
;
if
(
val
.
isNullOrUndefined
(
)
)
{
RootedId
key
(
cx
)
;
if
(
keyValue
.
isPrimitive
(
)
)
{
if
(
!
PrimitiveValueToId
<
CanGC
>
(
cx
keyValue
&
key
)
)
{
return
nullptr
;
}
ReportIsNullOrUndefinedForPropertyAccess
(
cx
val
valIndex
key
)
;
}
else
{
ReportIsNullOrUndefinedForPropertyAccess
(
cx
val
valIndex
)
;
}
return
nullptr
;
}
return
PrimitiveToObject
(
cx
val
)
;
}
JSObject
*
js
:
:
GetThisObject
(
JSObject
*
obj
)
{
if
(
obj
-
>
is
<
GlobalObject
>
(
)
)
{
return
ToWindowProxyIfWindow
(
obj
)
;
}
MOZ_ASSERT
(
obj
-
>
is
<
NonSyntacticVariablesObject
>
(
)
|
|
!
obj
-
>
is
<
EnvironmentObject
>
(
)
)
;
return
obj
;
}
JSObject
*
js
:
:
GetThisObjectOfLexical
(
JSObject
*
env
)
{
return
env
-
>
as
<
ExtensibleLexicalEnvironmentObject
>
(
)
.
thisObject
(
)
;
}
JSObject
*
js
:
:
GetThisObjectOfWith
(
JSObject
*
env
)
{
MOZ_ASSERT
(
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
;
return
GetThisObject
(
env
-
>
as
<
WithEnvironmentObject
>
(
)
.
withThis
(
)
)
;
}
class
GetObjectSlotNameFunctor
:
public
JS
:
:
TracingContext
:
:
Functor
{
JSObject
*
obj
;
public
:
explicit
GetObjectSlotNameFunctor
(
JSObject
*
ctx
)
:
obj
(
ctx
)
{
}
virtual
void
operator
(
)
(
JS
:
:
TracingContext
*
trc
char
*
buf
size_t
bufsize
)
override
;
}
;
void
GetObjectSlotNameFunctor
:
:
operator
(
)
(
JS
:
:
TracingContext
*
tcx
char
*
buf
size_t
bufsize
)
{
MOZ_ASSERT
(
tcx
-
>
index
(
)
!
=
JS
:
:
TracingContext
:
:
InvalidIndex
)
;
uint32_t
slot
=
uint32_t
(
tcx
-
>
index
(
)
)
;
Maybe
<
PropertyKey
>
key
;
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
NativeShape
*
shape
=
obj
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
shape
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
if
(
iter
-
>
hasSlot
(
)
&
&
iter
-
>
slot
(
)
=
=
slot
)
{
key
.
emplace
(
iter
-
>
key
(
)
)
;
break
;
}
}
}
if
(
key
.
isNothing
(
)
)
{
do
{
const
char
*
slotname
=
nullptr
;
const
char
*
pattern
=
nullptr
;
if
(
obj
-
>
is
<
GlobalObject
>
(
)
)
{
pattern
=
"
CLASS_OBJECT
(
%
s
)
"
;
if
(
false
)
{
;
}
#
define
TEST_SLOT_MATCHES_PROTOTYPE
(
name
clasp
)
\
else
if
(
(
JSProto_
#
#
name
)
=
=
slot
)
{
\
slotname
=
#
name
;
\
}
JS_FOR_EACH_PROTOTYPE
(
TEST_SLOT_MATCHES_PROTOTYPE
)
#
undef
TEST_SLOT_MATCHES_PROTOTYPE
}
else
{
pattern
=
"
%
s
"
;
if
(
obj
-
>
is
<
EnvironmentObject
>
(
)
)
{
if
(
slot
=
=
EnvironmentObject
:
:
enclosingEnvironmentSlot
(
)
)
{
slotname
=
"
enclosing_environment
"
;
}
else
if
(
obj
-
>
is
<
CallObject
>
(
)
)
{
if
(
slot
=
=
CallObject
:
:
calleeSlot
(
)
)
{
slotname
=
"
callee_slot
"
;
}
}
else
if
(
obj
-
>
is
<
WithEnvironmentObject
>
(
)
)
{
if
(
slot
=
=
WithEnvironmentObject
:
:
objectSlot
(
)
)
{
slotname
=
"
with_object
"
;
}
else
if
(
slot
=
=
WithEnvironmentObject
:
:
thisSlot
(
)
)
{
slotname
=
"
with_this
"
;
}
}
}
}
if
(
slotname
)
{
snprintf
(
buf
bufsize
pattern
slotname
)
;
}
else
{
snprintf
(
buf
bufsize
"
*
*
UNKNOWN
SLOT
%
"
PRIu32
"
*
*
"
slot
)
;
}
}
while
(
false
)
;
}
else
{
if
(
key
-
>
isInt
(
)
)
{
snprintf
(
buf
bufsize
"
%
"
PRId32
key
-
>
toInt
(
)
)
;
}
else
if
(
key
-
>
isAtom
(
)
)
{
PutEscapedString
(
buf
bufsize
key
-
>
toAtom
(
)
0
)
;
}
else
if
(
key
-
>
isSymbol
(
)
)
{
snprintf
(
buf
bufsize
"
*
*
SYMBOL
KEY
*
*
"
)
;
}
else
{
snprintf
(
buf
bufsize
"
*
*
FINALIZED
ATOM
KEY
*
*
"
)
;
}
}
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
namespace
js
{
JS_PUBLIC_API
void
DumpValue
(
const
JS
:
:
Value
&
val
js
:
:
GenericPrinter
&
out
)
;
JS_PUBLIC_API
void
DumpId
(
jsid
id
js
:
:
GenericPrinter
&
out
)
;
JS_PUBLIC_API
void
DumpInterpreterFrame
(
JSContext
*
cx
js
:
:
GenericPrinter
&
out
InterpreterFrame
*
start
=
nullptr
)
;
}
JS_PUBLIC_API
void
js
:
:
DumpValue
(
const
Value
&
val
js
:
:
GenericPrinter
&
out
)
{
val
.
dump
(
out
)
;
}
JS_PUBLIC_API
void
js
:
:
DumpId
(
jsid
id
js
:
:
GenericPrinter
&
out
)
{
out
.
printf
(
"
jsid
%
p
=
"
(
void
*
)
id
.
asRawBits
(
)
)
;
id
.
dump
(
out
)
;
}
bool
JSObject
:
:
hasSameRealmAs
(
JSContext
*
cx
)
const
{
return
nonCCWRealm
(
)
=
=
cx
-
>
realm
(
)
;
}
bool
JSObject
:
:
uninlinedIsProxyObject
(
)
const
{
return
is
<
ProxyObject
>
(
)
;
}
bool
JSObject
:
:
uninlinedNonProxyIsExtensible
(
)
const
{
return
nonProxyIsExtensible
(
)
;
}
void
JSObject
:
:
dump
(
)
const
{
js
:
:
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
void
JSObject
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
const
{
js
:
:
JSONPrinter
json
(
out
)
;
dump
(
json
)
;
out
.
put
(
"
\
n
"
)
;
}
void
JSObject
:
:
dump
(
js
:
:
JSONPrinter
&
json
)
const
{
json
.
beginObject
(
)
;
dumpFields
(
json
)
;
json
.
endObject
(
)
;
}
#
define
FOR_EACH_CLASS
(
M
)
\
M
(
ArrayBufferViewObject
)
\
M
(
ArrayBufferObject
)
\
M
(
JSFunction
)
\
M
(
PromiseObject
)
\
M
(
RegExpObject
)
static
void
DumpOwnFields
(
const
JSObject
*
obj
js
:
:
JSONPrinter
&
json
)
{
#
define
CALL
(
CLASS
)
\
if
(
obj
-
>
is
<
CLASS
>
(
)
)
{
\
obj
-
>
as
<
CLASS
>
(
)
.
dumpOwnFields
(
json
)
;
\
return
;
\
}
FOR_EACH_CLASS
(
CALL
)
#
undef
CALL
}
static
void
DumpOwnStringContent
(
const
JSObject
*
obj
js
:
:
GenericPrinter
&
out
)
{
#
define
CALL
(
CLASS
)
\
if
(
obj
-
>
is
<
CLASS
>
(
)
)
{
\
out
.
put
(
"
"
)
;
\
obj
-
>
as
<
CLASS
>
(
)
.
dumpOwnStringContent
(
out
)
;
\
return
;
\
}
FOR_EACH_CLASS
(
CALL
)
#
undef
CALL
}
#
undef
FOR_EACH_CLASS
void
JSObject
:
:
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
{
json
.
formatProperty
(
"
address
"
"
(
JSObject
*
)
0x
%
p
"
this
)
;
if
(
IsCrossCompartmentWrapper
(
this
)
)
{
json
.
formatProperty
(
"
compartment
"
"
(
JS
:
:
Compartment
*
)
0x
%
p
"
compartment
(
)
)
;
}
else
{
JSObject
*
globalObj
=
&
nonCCWGlobal
(
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
"
nonCCWGlobal
"
)
;
globalObj
-
>
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
}
const
JSClass
*
clasp
=
getClass
(
)
;
json
.
formatProperty
(
"
clasp
"
"
<
%
s
(
JSClass
*
)
0x
%
p
>
"
clasp
-
>
name
clasp
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
"
shape
"
)
;
shape
(
)
-
>
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
json
.
beginObjectProperty
(
"
shape
.
base
"
)
;
shape
(
)
-
>
base
(
)
-
>
dumpFields
(
json
)
;
json
.
endObject
(
)
;
if
(
IsProxy
(
this
)
)
{
const
js
:
:
BaseProxyHandler
*
handler
=
GetProxyHandler
(
this
)
;
if
(
IsDeadProxyObject
(
this
)
)
{
json
.
formatProperty
(
"
handler
"
"
(
js
:
:
DeadObjectProxy
*
)
0x
%
p
"
handler
)
;
}
else
if
(
IsCrossCompartmentWrapper
(
this
)
)
{
json
.
formatProperty
(
"
handler
"
"
(
js
:
:
CrossCompartmentWrapper
*
)
0x
%
p
"
handler
)
;
}
else
{
json
.
formatProperty
(
"
handler
"
"
(
js
:
:
BaseProxyHandler
*
)
0x
%
p
"
handler
)
;
}
Value
priv
=
GetProxyPrivate
(
this
)
;
if
(
!
priv
.
isUndefined
(
)
)
{
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
"
private
"
)
;
priv
.
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
}
Value
expando
=
GetProxyExpando
(
this
)
;
if
(
!
expando
.
isNull
(
)
)
{
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
"
expando
"
)
;
expando
.
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
}
if
(
is
<
DebugEnvironmentProxy
>
(
)
)
{
json
.
boolProperty
(
"
isQualifiedVarObj
"
isQualifiedVarObj
(
)
)
;
json
.
boolProperty
(
"
isUnqualifiedVarObj
"
isUnqualifiedVarObj
(
)
)
;
}
}
DumpOwnFields
(
this
json
)
;
if
(
is
<
NativeObject
>
(
)
)
{
const
auto
*
nobj
=
&
as
<
NativeObject
>
(
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
"
elementsHeader
"
)
;
nobj
-
>
getElementsHeader
(
)
-
>
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
uint32_t
reserved
=
JSCLASS_RESERVED_SLOTS
(
clasp
)
;
if
(
reserved
)
{
char
name
[
256
]
;
json
.
beginObjectProperty
(
"
reservedSlots
"
)
;
for
(
uint32_t
i
=
0
;
i
<
reserved
;
i
+
+
)
{
SprintfLiteral
(
name
"
%
u
"
i
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
name
)
;
nobj
-
>
getSlot
(
i
)
.
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
}
json
.
endObject
(
)
;
}
json
.
beginObjectProperty
(
"
properties
"
)
;
if
(
PropMap
*
map
=
nobj
-
>
shape
(
)
-
>
propMap
(
)
)
{
Vector
<
PropMap
*
8
SystemAllocPolicy
>
maps
;
while
(
true
)
{
if
(
!
maps
.
append
(
map
)
)
{
json
.
property
(
"
error
"
"
*
oom
in
JSObject
:
:
dumpFields
*
"
)
;
break
;
}
if
(
!
map
-
>
hasPrevious
(
)
)
{
break
;
}
map
=
map
-
>
asLinked
(
)
-
>
previous
(
)
;
}
for
(
size_t
i
=
maps
.
length
(
)
;
i
>
0
;
i
-
-
)
{
size_t
index
=
i
-
1
;
PropMap
*
map
=
maps
[
index
]
;
uint32_t
len
=
(
index
=
=
0
)
?
shape
(
)
-
>
asNative
(
)
.
propMapLength
(
)
:
PropMap
:
:
Capacity
;
for
(
uint32_t
j
=
0
;
j
<
len
;
j
+
+
)
{
if
(
!
map
-
>
hasKey
(
j
)
)
{
MOZ_ASSERT
(
map
-
>
isDictionary
(
)
)
;
continue
;
}
map
-
>
dumpPropertyNameAt
(
json
j
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginString
(
)
;
PropertyInfoWithKey
prop
=
map
-
>
getPropertyInfoWithKey
(
j
)
;
if
(
prop
.
isDataProperty
(
)
)
{
nobj
-
>
getSlot
(
prop
.
slot
(
)
)
.
dumpStringContent
(
out
)
;
out
.
put
(
"
"
)
;
}
else
if
(
prop
.
isAccessorProperty
(
)
)
{
out
.
printf
(
"
getter
=
0x
%
p
setter
=
0x
%
p
"
nobj
-
>
getGetter
(
prop
)
nobj
-
>
getSetter
(
prop
)
)
;
out
.
put
(
"
"
)
;
}
out
.
put
(
"
(
"
)
;
map
-
>
dumpDescriptorStringContentAt
(
out
j
)
;
out
.
put
(
"
)
"
)
;
json
.
endString
(
)
;
}
}
}
json
.
endObject
(
)
;
uint32_t
slots
=
nobj
-
>
getDenseInitializedLength
(
)
;
if
(
slots
)
{
char
name
[
64
]
;
json
.
beginObjectProperty
(
"
elements
"
)
;
for
(
uint32_t
i
=
0
;
i
<
slots
;
i
+
+
)
{
SprintfLiteral
(
name
"
%
u
"
i
)
;
js
:
:
GenericPrinter
&
out
=
json
.
beginStringProperty
(
name
)
;
nobj
-
>
getDenseElement
(
i
)
.
dumpStringContent
(
out
)
;
json
.
endStringProperty
(
)
;
}
json
.
endObject
(
)
;
}
}
}
void
JSObject
:
:
dumpStringContent
(
js
:
:
GenericPrinter
&
out
)
const
{
out
.
printf
(
"
<
%
s
"
getClass
(
)
-
>
name
)
;
DumpOwnStringContent
(
this
out
)
;
out
.
printf
(
"
(
JSObject
*
)
0x
%
p
>
"
this
)
;
}
static
void
MaybeDumpScope
(
Scope
*
scope
js
:
:
GenericPrinter
&
out
)
{
if
(
scope
)
{
out
.
printf
(
"
scope
:
%
s
\
n
"
ScopeKindString
(
scope
-
>
kind
(
)
)
)
;
for
(
BindingIter
bi
(
scope
)
;
bi
;
bi
+
+
)
{
out
.
put
(
"
"
)
;
StringValue
(
bi
.
name
(
)
)
.
dump
(
out
)
;
}
}
}
static
void
MaybeDumpValue
(
const
char
*
name
const
Value
&
v
js
:
:
GenericPrinter
&
out
)
{
if
(
!
v
.
isNull
(
)
)
{
out
.
printf
(
"
%
s
:
"
name
)
;
v
.
dump
(
out
)
;
}
}
JS_PUBLIC_API
void
js
:
:
DumpInterpreterFrame
(
JSContext
*
cx
js
:
:
GenericPrinter
&
out
InterpreterFrame
*
start
)
{
ScriptFrameIter
i
(
cx
)
;
if
(
!
start
)
{
if
(
i
.
done
(
)
)
{
out
.
printf
(
"
no
stack
for
cx
=
%
p
\
n
"
(
void
*
)
cx
)
;
return
;
}
}
else
{
while
(
!
i
.
done
(
)
&
&
!
i
.
isJSJit
(
)
&
&
i
.
interpFrame
(
)
!
=
start
)
{
+
+
i
;
}
if
(
i
.
done
(
)
)
{
out
.
printf
(
"
fp
=
%
p
not
found
in
cx
=
%
p
\
n
"
(
void
*
)
start
(
void
*
)
cx
)
;
return
;
}
}
for
(
;
!
i
.
done
(
)
;
+
+
i
)
{
if
(
i
.
isJSJit
(
)
)
{
out
.
put
(
"
JIT
frame
\
n
"
)
;
}
else
{
out
.
printf
(
"
InterpreterFrame
at
%
p
\
n
"
(
void
*
)
i
.
interpFrame
(
)
)
;
}
if
(
i
.
isFunctionFrame
(
)
)
{
out
.
put
(
"
callee
fun
:
"
)
;
RootedValue
v
(
cx
)
;
JSObject
*
fun
=
i
.
callee
(
cx
)
;
v
.
setObject
(
*
fun
)
;
v
.
get
(
)
.
dump
(
out
)
;
}
else
{
out
.
put
(
"
global
or
eval
frame
no
callee
\
n
"
)
;
}
out
.
printf
(
"
file
%
s
line
%
u
\
n
"
i
.
script
(
)
-
>
filename
(
)
i
.
script
(
)
-
>
lineno
(
)
)
;
if
(
jsbytecode
*
pc
=
i
.
pc
(
)
)
{
out
.
printf
(
"
pc
=
%
p
\
n
"
pc
)
;
out
.
printf
(
"
current
op
:
%
s
\
n
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MaybeDumpScope
(
i
.
script
(
)
-
>
lookupScope
(
pc
)
out
)
;
}
if
(
i
.
isFunctionFrame
(
)
)
{
MaybeDumpValue
(
"
this
"
i
.
thisArgument
(
cx
)
out
)
;
}
if
(
!
i
.
isJSJit
(
)
)
{
out
.
put
(
"
rval
:
"
)
;
i
.
interpFrame
(
)
-
>
returnValue
(
)
.
get
(
)
.
dump
(
out
)
;
}
out
.
put
(
"
flags
:
"
)
;
if
(
i
.
isConstructing
(
)
)
{
out
.
put
(
"
constructing
"
)
;
}
if
(
!
i
.
isJSJit
(
)
&
&
i
.
interpFrame
(
)
-
>
isDebuggerEvalFrame
(
)
)
{
out
.
put
(
"
debugger
eval
"
)
;
}
if
(
i
.
isEvalFrame
(
)
)
{
out
.
put
(
"
eval
"
)
;
}
out
.
putChar
(
'
\
n
'
)
;
out
.
printf
(
"
envChain
:
(
JSObject
*
)
%
p
\
n
"
(
void
*
)
i
.
environmentChain
(
cx
)
)
;
out
.
putChar
(
'
\
n
'
)
;
}
}
#
endif
JS_PUBLIC_API
void
js
:
:
DumpBacktrace
(
JSContext
*
cx
FILE
*
fp
)
{
Fprinter
out
(
fp
)
;
js
:
:
DumpBacktrace
(
cx
out
)
;
}
JS_PUBLIC_API
void
js
:
:
DumpBacktrace
(
JSContext
*
cx
js
:
:
GenericPrinter
&
out
)
{
size_t
depth
=
0
;
for
(
AllFramesIter
i
(
cx
)
;
!
i
.
done
(
)
;
+
+
i
+
+
depth
)
{
const
char
*
filename
;
unsigned
line
;
if
(
i
.
hasScript
(
)
)
{
filename
=
JS_GetScriptFilename
(
i
.
script
(
)
)
;
line
=
PCToLineNumber
(
i
.
script
(
)
i
.
pc
(
)
)
;
}
else
{
filename
=
i
.
filename
(
)
;
line
=
i
.
computeLine
(
)
;
}
char
frameType
=
i
.
isInterp
(
)
?
'
i
'
:
i
.
isBaseline
(
)
?
'
b
'
:
i
.
isIon
(
)
?
'
I
'
:
i
.
isWasm
(
)
?
'
W
'
:
'
?
'
;
out
.
printf
(
"
#
%
zu
%
14p
%
c
%
s
:
%
u
"
depth
i
.
rawFramePtr
(
)
frameType
filename
line
)
;
if
(
i
.
hasScript
(
)
)
{
out
.
printf
(
"
(
%
p
%
zu
)
\
n
"
i
.
script
(
)
i
.
script
(
)
-
>
pcToOffset
(
i
.
pc
(
)
)
)
;
}
else
{
out
.
printf
(
"
(
%
p
)
\
n
"
i
.
pc
(
)
)
;
}
}
}
JS_PUBLIC_API
void
js
:
:
DumpBacktrace
(
JSContext
*
cx
)
{
DumpBacktrace
(
cx
stdout
)
;
}
bool
JSObject
:
:
isBackgroundFinalized
(
)
const
{
if
(
isTenured
(
)
)
{
return
js
:
:
gc
:
:
IsBackgroundFinalized
(
asTenured
(
)
.
getAllocKind
(
)
)
;
}
js
:
:
Nursery
&
nursery
=
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
return
js
:
:
gc
:
:
IsBackgroundFinalized
(
allocKindForTenure
(
nursery
)
)
;
}
js
:
:
gc
:
:
AllocKind
JSObject
:
:
allocKindForTenure
(
const
js
:
:
Nursery
&
nursery
)
const
{
using
namespace
js
:
:
gc
;
MOZ_ASSERT
(
IsInsideNursery
(
this
)
)
;
if
(
canHaveFixedElements
(
)
)
{
const
NativeObject
&
nobj
=
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
nobj
.
numFixedSlots
(
)
=
=
0
)
;
if
(
!
nursery
.
isInside
(
nobj
.
getUnshiftedElementsHeader
(
)
)
)
{
return
gc
:
:
AllocKind
:
:
OBJECT0_BACKGROUND
;
}
size_t
nelements
=
nobj
.
getDenseCapacity
(
)
;
return
ForegroundToBackgroundAllocKind
(
GetGCArrayKind
(
nelements
)
)
;
}
if
(
is
<
JSFunction
>
(
)
)
{
return
as
<
JSFunction
>
(
)
.
getAllocKind
(
)
;
}
if
(
is
<
FixedLengthTypedArrayObject
>
(
)
&
&
!
as
<
FixedLengthTypedArrayObject
>
(
)
.
hasBuffer
(
)
)
{
gc
:
:
AllocKind
allocKind
;
if
(
as
<
FixedLengthTypedArrayObject
>
(
)
.
hasInlineElements
(
)
)
{
size_t
nbytes
=
as
<
FixedLengthTypedArrayObject
>
(
)
.
byteLength
(
)
;
allocKind
=
FixedLengthTypedArrayObject
:
:
AllocKindForLazyBuffer
(
nbytes
)
;
}
else
{
allocKind
=
GetGCObjectKind
(
getClass
(
)
)
;
}
return
ForegroundToBackgroundAllocKind
(
allocKind
)
;
}
if
(
is
<
ProxyObject
>
(
)
)
{
return
as
<
ProxyObject
>
(
)
.
allocKindForTenure
(
)
;
}
if
(
is
<
WasmStructObject
>
(
)
)
{
const
wasm
:
:
TypeDef
*
typeDef
=
&
as
<
WasmStructObject
>
(
)
.
typeDef
(
)
;
return
WasmStructObject
:
:
allocKindForTypeDef
(
typeDef
)
;
}
if
(
is
<
WasmArrayObject
>
(
)
)
{
return
WasmArrayObject
:
:
allocKind
(
)
;
}
return
as
<
NativeObject
>
(
)
.
allocKindForTenure
(
)
;
}
void
JSObject
:
:
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
{
if
(
is
<
NativeObject
>
(
)
&
&
as
<
NativeObject
>
(
)
.
hasDynamicSlots
(
)
)
{
info
-
>
objectsMallocHeapSlots
+
=
mallocSizeOf
(
as
<
NativeObject
>
(
)
.
getSlotsHeader
(
)
)
;
}
if
(
is
<
NativeObject
>
(
)
&
&
as
<
NativeObject
>
(
)
.
hasDynamicElements
(
)
)
{
void
*
allocatedElements
=
as
<
NativeObject
>
(
)
.
getUnshiftedElementsHeader
(
)
;
info
-
>
objectsMallocHeapElementsNormal
+
=
mallocSizeOf
(
allocatedElements
)
;
}
if
(
is
<
JSFunction
>
(
)
|
|
is
<
PlainObject
>
(
)
|
|
is
<
ArrayObject
>
(
)
|
|
is
<
CallObject
>
(
)
|
|
is
<
RegExpObject
>
(
)
|
|
is
<
ProxyObject
>
(
)
)
{
}
else
if
(
is
<
ArgumentsObject
>
(
)
)
{
info
-
>
objectsMallocHeapMisc
+
=
as
<
ArgumentsObject
>
(
)
.
sizeOfMisc
(
mallocSizeOf
)
;
}
else
if
(
is
<
MapObject
>
(
)
)
{
info
-
>
objectsMallocHeapMisc
+
=
as
<
MapObject
>
(
)
.
sizeOfData
(
mallocSizeOf
)
;
}
else
if
(
is
<
SetObject
>
(
)
)
{
info
-
>
objectsMallocHeapMisc
+
=
as
<
SetObject
>
(
)
.
sizeOfData
(
mallocSizeOf
)
;
}
else
if
(
is
<
PropertyIteratorObject
>
(
)
)
{
info
-
>
objectsMallocHeapMisc
+
=
as
<
PropertyIteratorObject
>
(
)
.
sizeOfMisc
(
mallocSizeOf
)
;
}
else
if
(
is
<
ArrayBufferObject
>
(
)
)
{
ArrayBufferObject
:
:
addSizeOfExcludingThis
(
this
mallocSizeOf
info
runtimeSizes
)
;
}
else
if
(
is
<
SharedArrayBufferObject
>
(
)
)
{
SharedArrayBufferObject
:
:
addSizeOfExcludingThis
(
this
mallocSizeOf
info
runtimeSizes
)
;
}
else
if
(
is
<
GlobalObject
>
(
)
)
{
as
<
GlobalObject
>
(
)
.
addSizeOfData
(
mallocSizeOf
info
)
;
}
else
if
(
is
<
WeakCollectionObject
>
(
)
)
{
info
-
>
objectsMallocHeapMisc
+
=
as
<
WeakCollectionObject
>
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
ifdef
JS_HAS_CTYPES
else
{
info
-
>
objectsMallocHeapMisc
+
=
ctypes
:
:
SizeOfDataIfCDataObject
(
mallocSizeOf
const_cast
<
JSObject
*
>
(
this
)
)
;
}
#
endif
}
size_t
JSObject
:
:
sizeOfIncludingThisInNursery
(
)
const
{
MOZ_ASSERT
(
!
isTenured
(
)
)
;
const
Nursery
&
nursery
=
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
size_t
size
=
gc
:
:
Arena
:
:
thingSize
(
allocKindForTenure
(
nursery
)
)
;
if
(
is
<
NativeObject
>
(
)
)
{
const
NativeObject
&
native
=
as
<
NativeObject
>
(
)
;
size
+
=
native
.
numDynamicSlots
(
)
*
sizeof
(
Value
)
;
if
(
native
.
hasDynamicElements
(
)
)
{
js
:
:
ObjectElements
&
elements
=
*
native
.
getElementsHeader
(
)
;
size
+
=
(
elements
.
capacity
+
elements
.
numShiftedElements
(
)
)
*
sizeof
(
HeapSlot
)
;
}
if
(
is
<
ArgumentsObject
>
(
)
)
{
size
+
=
as
<
ArgumentsObject
>
(
)
.
sizeOfData
(
)
;
}
}
return
size
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
JSObject
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
JSObject
&
obj
=
get
(
)
;
if
(
!
obj
.
isTenured
(
)
)
{
return
obj
.
sizeOfIncludingThisInNursery
(
)
;
}
JS
:
:
ClassInfo
info
;
obj
.
addSizeOfExcludingThis
(
mallocSizeOf
&
info
nullptr
)
;
return
obj
.
tenuredSizeOfThis
(
)
+
info
.
sizeOfAllThings
(
)
;
}
const
char16_t
JS
:
:
ubi
:
:
Concrete
<
JSObject
>
:
:
concreteTypeName
[
]
=
u
"
JSObject
"
;
void
JSObject
:
:
traceChildren
(
JSTracer
*
trc
)
{
TraceCellHeaderEdge
(
trc
this
"
shape
"
)
;
Shape
*
objShape
=
shape
(
)
;
if
(
objShape
-
>
isNative
(
)
)
{
NativeObject
*
nobj
=
&
as
<
NativeObject
>
(
)
;
{
GetObjectSlotNameFunctor
func
(
nobj
)
;
JS
:
:
AutoTracingDetails
ctx
(
trc
func
)
;
JS
:
:
AutoTracingIndex
index
(
trc
)
;
const
uint32_t
nslots
=
nobj
-
>
slotSpan
(
)
;
for
(
uint32_t
i
=
0
;
i
<
nslots
;
+
+
i
)
{
TraceEdge
(
trc
&
nobj
-
>
getSlotRef
(
i
)
"
object
slot
"
)
;
+
+
index
;
}
MOZ_ASSERT
(
nslots
=
=
nobj
-
>
slotSpan
(
)
)
;
}
TraceRange
(
trc
nobj
-
>
getDenseInitializedLength
(
)
static_cast
<
HeapSlot
*
>
(
nobj
-
>
getDenseElements
(
)
)
"
objectElements
"
)
;
}
const
JSClass
*
clasp
=
objShape
-
>
getObjectClass
(
)
;
if
(
clasp
-
>
hasTrace
(
)
)
{
clasp
-
>
doTrace
(
trc
this
)
;
}
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
SpeciesConstructor
(
JSContext
*
cx
HandleObject
obj
HandleObject
defaultCtor
bool
(
*
isDefaultSpecies
)
(
JSContext
*
JSFunction
*
)
)
{
RootedValue
ctor
(
cx
)
;
bool
ctorGetSucceeded
=
GetPropertyPure
(
cx
obj
NameToId
(
cx
-
>
names
(
)
.
constructor
)
ctor
.
address
(
)
)
;
if
(
ctorGetSucceeded
&
&
ctor
.
isObject
(
)
&
&
&
ctor
.
toObject
(
)
=
=
defaultCtor
)
{
jsid
speciesId
=
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
species
)
;
JSFunction
*
getter
;
if
(
GetGetterPure
(
cx
defaultCtor
speciesId
&
getter
)
&
&
getter
&
&
isDefaultSpecies
(
cx
getter
)
)
{
return
defaultCtor
;
}
}
if
(
!
ctorGetSucceeded
&
&
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
constructor
&
ctor
)
)
{
return
nullptr
;
}
if
(
ctor
.
isUndefined
(
)
)
{
return
defaultCtor
;
}
if
(
!
ctor
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_OBJECT_REQUIRED
"
object
'
s
'
constructor
'
property
"
)
;
return
nullptr
;
}
RootedObject
ctorObj
(
cx
&
ctor
.
toObject
(
)
)
;
RootedValue
s
(
cx
)
;
RootedId
speciesId
(
cx
PropertyKey
:
:
Symbol
(
cx
-
>
wellKnownSymbols
(
)
.
species
)
)
;
if
(
!
GetProperty
(
cx
ctorObj
ctor
speciesId
&
s
)
)
{
return
nullptr
;
}
if
(
s
.
isNullOrUndefined
(
)
)
{
return
defaultCtor
;
}
if
(
IsConstructor
(
s
)
)
{
return
&
s
.
toObject
(
)
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_CONSTRUCTOR
"
[
Symbol
.
species
]
property
of
object
'
s
constructor
"
)
;
return
nullptr
;
}
[
[
nodiscard
]
]
JSObject
*
js
:
:
SpeciesConstructor
(
JSContext
*
cx
HandleObject
obj
JSProtoKey
ctorKey
bool
(
*
isDefaultSpecies
)
(
JSContext
*
JSFunction
*
)
)
{
RootedObject
defaultCtor
(
cx
GlobalObject
:
:
getOrCreateConstructor
(
cx
ctorKey
)
)
;
if
(
!
defaultCtor
)
{
return
nullptr
;
}
return
SpeciesConstructor
(
cx
obj
defaultCtor
isDefaultSpecies
)
;
}
bool
js
:
:
Unbox
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
vp
)
{
if
(
MOZ_UNLIKELY
(
obj
-
>
is
<
ProxyObject
>
(
)
)
)
{
return
Proxy
:
:
boxedValue_unbox
(
cx
obj
vp
)
;
}
if
(
obj
-
>
is
<
BooleanObject
>
(
)
)
{
vp
.
setBoolean
(
obj
-
>
as
<
BooleanObject
>
(
)
.
unbox
(
)
)
;
}
else
if
(
obj
-
>
is
<
NumberObject
>
(
)
)
{
vp
.
setNumber
(
obj
-
>
as
<
NumberObject
>
(
)
.
unbox
(
)
)
;
}
else
if
(
obj
-
>
is
<
StringObject
>
(
)
)
{
vp
.
setString
(
obj
-
>
as
<
StringObject
>
(
)
.
unbox
(
)
)
;
}
else
if
(
obj
-
>
is
<
DateObject
>
(
)
)
{
vp
.
set
(
obj
-
>
as
<
DateObject
>
(
)
.
UTCTime
(
)
)
;
}
else
if
(
obj
-
>
is
<
SymbolObject
>
(
)
)
{
vp
.
setSymbol
(
obj
-
>
as
<
SymbolObject
>
(
)
.
unbox
(
)
)
;
}
else
if
(
obj
-
>
is
<
BigIntObject
>
(
)
)
{
vp
.
setBigInt
(
obj
-
>
as
<
BigIntObject
>
(
)
.
unbox
(
)
)
;
#
ifdef
ENABLE_RECORD_TUPLE
}
else
if
(
obj
-
>
is
<
RecordObject
>
(
)
)
{
vp
.
setExtendedPrimitive
(
*
obj
-
>
as
<
RecordObject
>
(
)
.
unbox
(
)
)
;
}
else
if
(
obj
-
>
is
<
TupleObject
>
(
)
)
{
vp
.
setExtendedPrimitive
(
obj
-
>
as
<
TupleObject
>
(
)
.
unbox
(
)
)
;
#
endif
}
else
{
vp
.
setUndefined
(
)
;
}
return
true
;
}
#
ifdef
DEBUG
void
js
:
:
AssertJSClassInvariants
(
const
JSClass
*
clasp
)
{
MOZ_ASSERT
(
JS
:
:
StringIsASCII
(
clasp
-
>
name
)
)
;
if
(
clasp
-
>
isNativeObject
(
)
&
&
clasp
!
=
&
WithEnvironmentObject
:
:
class_
&
&
clasp
!
=
&
ModuleEnvironmentObject
:
:
class_
&
&
clasp
!
=
&
RuntimeLexicalErrorObject
:
:
class_
)
{
MOZ_ASSERT
(
!
clasp
-
>
getOpsLookupProperty
(
)
)
;
MOZ_ASSERT_IF
(
clasp
!
=
&
MappedArgumentsObject
:
:
class_
!
clasp
-
>
getOpsDefineProperty
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
getOpsHasProperty
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
getOpsGetProperty
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
getOpsSetProperty
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
getOpsGetOwnPropertyDescriptor
(
)
)
;
MOZ_ASSERT
(
!
clasp
-
>
getOpsDeleteProperty
(
)
)
;
}
}
void
JSObject
:
:
debugCheckNewObject
(
Shape
*
shape
js
:
:
gc
:
:
AllocKind
allocKind
js
:
:
gc
:
:
Heap
heap
)
{
const
JSClass
*
clasp
=
shape
-
>
getObjectClass
(
)
;
if
(
!
ClassCanHaveFixedData
(
clasp
)
)
{
NativeShape
*
nshape
=
&
shape
-
>
asNative
(
)
;
if
(
clasp
=
=
&
ArrayObject
:
:
class_
)
{
MOZ_ASSERT
(
nshape
-
>
numFixedSlots
(
)
=
=
0
)
;
}
else
{
MOZ_ASSERT
(
gc
:
:
GetGCKindSlots
(
allocKind
)
=
=
nshape
-
>
numFixedSlots
(
)
)
;
}
}
MOZ_ASSERT
(
!
CanChangeToBackgroundAllocKind
(
allocKind
clasp
)
)
;
static
const
uint32_t
FinalizeMask
=
JSCLASS_FOREGROUND_FINALIZE
|
JSCLASS_BACKGROUND_FINALIZE
;
uint32_t
flags
=
clasp
-
>
flags
;
uint32_t
finalizeFlags
=
flags
&
FinalizeMask
;
if
(
clasp
-
>
hasFinalize
(
)
&
&
!
clasp
-
>
isProxyObject
(
)
)
{
MOZ_ASSERT
(
finalizeFlags
=
=
JSCLASS_FOREGROUND_FINALIZE
|
|
finalizeFlags
=
=
JSCLASS_BACKGROUND_FINALIZE
)
;
MOZ_ASSERT
(
(
finalizeFlags
=
=
JSCLASS_BACKGROUND_FINALIZE
)
=
=
IsBackgroundFinalized
(
allocKind
)
)
;
}
else
{
MOZ_ASSERT
(
finalizeFlags
=
=
0
)
;
}
MOZ_ASSERT_IF
(
clasp
-
>
hasFinalize
(
)
heap
=
=
gc
:
:
Heap
:
:
Tenured
|
|
CanNurseryAllocateFinalizedClass
(
clasp
)
|
|
clasp
-
>
isProxyObject
(
)
)
;
MOZ_ASSERT
(
!
shape
-
>
isDictionary
(
)
)
;
MOZ_ASSERT
(
!
shape
-
>
realm
(
)
-
>
hasObjectPendingMetadata
(
)
)
;
if
(
!
clasp
-
>
isNativeObject
(
)
)
{
MOZ_ASSERT_IF
(
!
clasp
-
>
isProxyObject
(
)
JSCLASS_RESERVED_SLOTS
(
clasp
)
=
=
0
)
;
}
}
#
endif
