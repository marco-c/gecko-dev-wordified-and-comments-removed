#
ifndef
vm_ReceiverGuard_h
#
define
vm_ReceiverGuard_h
#
include
"
vm
/
Shape
.
h
"
namespace
js
{
class
HeapReceiverGuard
;
class
ReceiverGuard
{
ObjectGroup
*
group_
;
Shape
*
shape_
;
void
MOZ_ALWAYS_INLINE
assertInvariants
(
)
{
MOZ_ASSERT_IF
(
group_
|
|
shape_
!
!
group_
!
=
!
!
shape_
)
;
}
public
:
ReceiverGuard
(
)
:
group_
(
nullptr
)
shape_
(
nullptr
)
{
}
inline
MOZ_IMPLICIT
ReceiverGuard
(
const
HeapReceiverGuard
&
guard
)
;
explicit
MOZ_ALWAYS_INLINE
ReceiverGuard
(
JSObject
*
obj
)
;
MOZ_ALWAYS_INLINE
ReceiverGuard
(
ObjectGroup
*
group
Shape
*
shape
)
;
bool
operator
=
=
(
const
ReceiverGuard
&
other
)
const
{
return
group_
=
=
other
.
group_
&
&
shape_
=
=
other
.
shape_
;
}
bool
operator
!
=
(
const
ReceiverGuard
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
uintptr_t
hash
(
)
const
{
return
(
uintptr_t
(
group_
)
>
>
3
)
^
(
uintptr_t
(
shape_
)
>
>
3
)
;
}
void
setShape
(
Shape
*
shape
)
{
shape_
=
shape
;
assertInvariants
(
)
;
}
void
setGroup
(
ObjectGroup
*
group
)
{
group_
=
group
;
assertInvariants
(
)
;
}
Shape
*
getShape
(
)
const
{
return
shape_
;
}
ObjectGroup
*
getGroup
(
)
const
{
return
group_
;
}
}
;
class
HeapReceiverGuard
{
friend
class
ReceiverGuard
;
const
GCPtrObjectGroup
group_
;
const
GCPtrShape
shape_
;
public
:
explicit
HeapReceiverGuard
(
const
ReceiverGuard
&
guard
)
:
group_
(
guard
.
getGroup
(
)
)
shape_
(
guard
.
getShape
(
)
)
{
}
void
trace
(
JSTracer
*
trc
)
;
}
;
inline
ReceiverGuard
:
:
ReceiverGuard
(
const
HeapReceiverGuard
&
guard
)
:
group_
(
guard
.
group_
)
shape_
(
guard
.
shape_
)
{
assertInvariants
(
)
;
}
}
#
endif
