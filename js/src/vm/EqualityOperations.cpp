#
include
"
vm
/
EqualityOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
Equality
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
ifdef
ENABLE_BIGINT
#
include
"
vm
/
BigIntType
.
h
"
#
endif
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
builtin
/
Boolean
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
static
bool
EqualGivenSameType
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
equal
)
{
MOZ_ASSERT
(
JS
:
:
SameType
(
lval
rval
)
)
;
if
(
lval
.
isString
(
)
)
{
return
js
:
:
EqualStrings
(
cx
lval
.
toString
(
)
rval
.
toString
(
)
equal
)
;
}
if
(
lval
.
isDouble
(
)
)
{
*
equal
=
(
lval
.
toDouble
(
)
=
=
rval
.
toDouble
(
)
)
;
return
true
;
}
#
ifdef
ENABLE_BIGINT
if
(
lval
.
isBigInt
(
)
)
{
*
equal
=
JS
:
:
BigInt
:
:
equal
(
lval
.
toBigInt
(
)
rval
.
toBigInt
(
)
)
;
return
true
;
}
#
endif
if
(
lval
.
isGCThing
(
)
)
{
*
equal
=
(
lval
.
toGCThing
(
)
=
=
rval
.
toGCThing
(
)
)
;
return
true
;
}
*
equal
=
lval
.
get
(
)
.
payloadAsRawUint32
(
)
=
=
rval
.
get
(
)
.
payloadAsRawUint32
(
)
;
MOZ_ASSERT_IF
(
lval
.
isUndefined
(
)
|
|
lval
.
isNull
(
)
*
equal
)
;
return
true
;
}
static
bool
LooselyEqualBooleanAndOther
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
result
)
{
MOZ_ASSERT
(
!
rval
.
isBoolean
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
lvalue
(
cx
JS
:
:
Int32Value
(
lval
.
toBoolean
(
)
?
1
:
0
)
)
;
if
(
rval
.
isNumber
(
)
)
{
*
result
=
(
lvalue
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
rval
.
isString
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
rval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
lvalue
.
toNumber
(
)
=
=
num
)
;
return
true
;
}
return
js
:
:
LooselyEqual
(
cx
lvalue
rval
result
)
;
}
bool
js
:
:
LooselyEqual
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
result
)
{
if
(
JS
:
:
SameType
(
lval
rval
)
)
{
return
EqualGivenSameType
(
cx
lval
rval
result
)
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isNumber
(
)
)
{
*
result
=
(
lval
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
lval
.
isNullOrUndefined
(
)
)
{
*
result
=
rval
.
isNullOrUndefined
(
)
|
|
(
rval
.
isObject
(
)
&
&
EmulatesUndefined
(
&
rval
.
toObject
(
)
)
)
;
return
true
;
}
if
(
rval
.
isNullOrUndefined
(
)
)
{
MOZ_ASSERT
(
!
lval
.
isNullOrUndefined
(
)
)
;
*
result
=
lval
.
isObject
(
)
&
&
EmulatesUndefined
(
&
lval
.
toObject
(
)
)
;
return
true
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isString
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
rval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
lval
.
toNumber
(
)
=
=
num
)
;
return
true
;
}
if
(
lval
.
isString
(
)
&
&
rval
.
isNumber
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
lval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
num
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
lval
.
isBoolean
(
)
)
{
return
LooselyEqualBooleanAndOther
(
cx
lval
rval
result
)
;
}
if
(
rval
.
isBoolean
(
)
)
{
return
LooselyEqualBooleanAndOther
(
cx
rval
lval
result
)
;
}
if
(
(
lval
.
isString
(
)
|
|
lval
.
isNumber
(
)
|
|
lval
.
isSymbol
(
)
)
&
&
rval
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rvalue
(
cx
rval
)
;
if
(
!
ToPrimitive
(
cx
&
rvalue
)
)
{
return
false
;
}
return
js
:
:
LooselyEqual
(
cx
lval
rvalue
result
)
;
}
if
(
lval
.
isObject
(
)
&
&
(
rval
.
isString
(
)
|
|
rval
.
isNumber
(
)
|
|
rval
.
isSymbol
(
)
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
lvalue
(
cx
lval
)
;
if
(
!
ToPrimitive
(
cx
&
lvalue
)
)
{
return
false
;
}
return
js
:
:
LooselyEqual
(
cx
lvalue
rval
result
)
;
}
#
ifdef
ENABLE_BIGINT
if
(
lval
.
isBigInt
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
BigInt
*
>
lbi
(
cx
lval
.
toBigInt
(
)
)
;
bool
tmpResult
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tmpResult
JS
:
:
BigInt
:
:
looselyEqual
(
cx
lbi
rval
)
)
;
*
result
=
tmpResult
;
return
true
;
}
if
(
rval
.
isBigInt
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
BigInt
*
>
rbi
(
cx
rval
.
toBigInt
(
)
)
;
bool
tmpResult
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tmpResult
JS
:
:
BigInt
:
:
looselyEqual
(
cx
rbi
lval
)
)
;
*
result
=
tmpResult
;
return
true
;
}
#
endif
*
result
=
false
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
LooselyEqual
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
equal
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
equal
)
;
return
js
:
:
LooselyEqual
(
cx
value1
value2
equal
)
;
}
bool
js
:
:
StrictlyEqual
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
equal
)
{
if
(
SameType
(
lval
rval
)
)
{
return
EqualGivenSameType
(
cx
lval
rval
equal
)
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isNumber
(
)
)
{
*
equal
=
(
lval
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
*
equal
=
false
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
StrictlyEqual
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
equal
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
equal
)
;
return
js
:
:
StrictlyEqual
(
cx
value1
value2
equal
)
;
}
static
inline
bool
IsNegativeZero
(
const
JS
:
:
Value
&
v
)
{
return
v
.
isDouble
(
)
&
&
mozilla
:
:
IsNegativeZero
(
v
.
toDouble
(
)
)
;
}
static
inline
bool
IsNaN
(
const
JS
:
:
Value
&
v
)
{
return
v
.
isDouble
(
)
&
&
mozilla
:
:
IsNaN
(
v
.
toDouble
(
)
)
;
}
bool
js
:
:
SameValue
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v1
JS
:
:
Handle
<
JS
:
:
Value
>
v2
bool
*
same
)
{
if
(
IsNegativeZero
(
v1
)
)
{
*
same
=
IsNegativeZero
(
v2
)
;
return
true
;
}
if
(
IsNegativeZero
(
v2
)
)
{
*
same
=
false
;
return
true
;
}
if
(
IsNaN
(
v1
)
&
&
IsNaN
(
v2
)
)
{
*
same
=
true
;
return
true
;
}
return
js
:
:
StrictlyEqual
(
cx
v1
v2
same
)
;
}
JS_PUBLIC_API
bool
JS
:
:
SameValue
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
same
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
same
)
;
return
js
:
:
SameValue
(
cx
value1
value2
same
)
;
}
