#
include
"
vm
/
EqualityOperations
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
Context
.
h
"
#
include
"
js
/
Equality
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
ifdef
ENABLE_RECORD_TUPLE
#
include
"
vm
/
RecordType
.
h
"
#
include
"
vm
/
TupleType
.
h
"
#
endif
#
include
"
builtin
/
Boolean
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
static
bool
EqualGivenSameType
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
equal
)
{
MOZ_ASSERT
(
JS
:
:
SameType
(
lval
rval
)
)
;
if
(
lval
.
isString
(
)
)
{
return
js
:
:
EqualStrings
(
cx
lval
.
toString
(
)
rval
.
toString
(
)
equal
)
;
}
if
(
lval
.
isDouble
(
)
)
{
*
equal
=
(
lval
.
toDouble
(
)
=
=
rval
.
toDouble
(
)
)
;
return
true
;
}
if
(
lval
.
isBigInt
(
)
)
{
*
equal
=
JS
:
:
BigInt
:
:
equal
(
lval
.
toBigInt
(
)
rval
.
toBigInt
(
)
)
;
return
true
;
}
#
ifdef
ENABLE_RECORD_TUPLE
if
(
lval
.
isExtendedPrimitive
(
)
)
{
JSObject
*
lobj
=
&
lval
.
toExtendedPrimitive
(
)
;
JSObject
*
robj
=
&
rval
.
toExtendedPrimitive
(
)
;
if
(
lobj
-
>
getClass
(
)
!
=
robj
-
>
getClass
(
)
)
{
*
equal
=
false
;
return
true
;
}
if
(
lobj
-
>
is
<
js
:
:
RecordType
>
(
)
)
{
return
js
:
:
RecordType
:
:
sameValueZero
(
cx
&
lobj
-
>
as
<
js
:
:
RecordType
>
(
)
&
robj
-
>
as
<
js
:
:
RecordType
>
(
)
equal
)
;
}
if
(
lobj
-
>
is
<
js
:
:
TupleType
>
(
)
)
{
return
js
:
:
TupleType
:
:
sameValueZero
(
cx
&
lobj
-
>
as
<
js
:
:
TupleType
>
(
)
&
robj
-
>
as
<
js
:
:
TupleType
>
(
)
equal
)
;
}
MOZ_CRASH
(
"
Unknown
ExtendedPrimitive
type
"
)
;
}
#
endif
MOZ_ASSERT
(
CanUseBitwiseCompareForStrictlyEqual
(
lval
)
|
|
lval
.
isInt32
(
)
)
;
*
equal
=
(
lval
.
asRawBits
(
)
=
=
rval
.
asRawBits
(
)
)
;
MOZ_ASSERT_IF
(
lval
.
isUndefined
(
)
|
|
lval
.
isNull
(
)
*
equal
)
;
return
true
;
}
static
bool
LooselyEqualBooleanAndOther
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
result
)
{
MOZ_ASSERT
(
!
rval
.
isBoolean
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
lvalue
(
cx
JS
:
:
Int32Value
(
lval
.
toBoolean
(
)
?
1
:
0
)
)
;
if
(
rval
.
isNumber
(
)
)
{
*
result
=
(
lvalue
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
rval
.
isString
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
rval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
lvalue
.
toNumber
(
)
=
=
num
)
;
return
true
;
}
return
js
:
:
LooselyEqual
(
cx
lvalue
rval
result
)
;
}
bool
js
:
:
LooselyEqual
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
result
)
{
if
(
JS
:
:
SameType
(
lval
rval
)
)
{
return
EqualGivenSameType
(
cx
lval
rval
result
)
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isNumber
(
)
)
{
*
result
=
(
lval
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
lval
.
isNullOrUndefined
(
)
)
{
*
result
=
rval
.
isNullOrUndefined
(
)
|
|
(
rval
.
isObject
(
)
&
&
EmulatesUndefined
(
&
rval
.
toObject
(
)
)
)
;
return
true
;
}
if
(
rval
.
isNullOrUndefined
(
)
)
{
MOZ_ASSERT
(
!
lval
.
isNullOrUndefined
(
)
)
;
*
result
=
lval
.
isObject
(
)
&
&
EmulatesUndefined
(
&
lval
.
toObject
(
)
)
;
return
true
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isString
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
rval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
lval
.
toNumber
(
)
=
=
num
)
;
return
true
;
}
if
(
lval
.
isString
(
)
&
&
rval
.
isNumber
(
)
)
{
double
num
;
if
(
!
StringToNumber
(
cx
lval
.
toString
(
)
&
num
)
)
{
return
false
;
}
*
result
=
(
num
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
if
(
lval
.
isBoolean
(
)
)
{
return
LooselyEqualBooleanAndOther
(
cx
lval
rval
result
)
;
}
if
(
rval
.
isBoolean
(
)
)
{
return
LooselyEqualBooleanAndOther
(
cx
rval
lval
result
)
;
}
if
(
(
lval
.
isString
(
)
|
|
lval
.
isNumber
(
)
|
|
lval
.
isSymbol
(
)
)
&
&
rval
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rvalue
(
cx
rval
)
;
if
(
!
ToPrimitive
(
cx
&
rvalue
)
)
{
return
false
;
}
return
js
:
:
LooselyEqual
(
cx
lval
rvalue
result
)
;
}
if
(
lval
.
isObject
(
)
&
&
(
rval
.
isString
(
)
|
|
rval
.
isNumber
(
)
|
|
rval
.
isSymbol
(
)
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
lvalue
(
cx
lval
)
;
if
(
!
ToPrimitive
(
cx
&
lvalue
)
)
{
return
false
;
}
return
js
:
:
LooselyEqual
(
cx
lvalue
rval
result
)
;
}
if
(
lval
.
isBigInt
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
BigInt
*
>
lbi
(
cx
lval
.
toBigInt
(
)
)
;
bool
tmpResult
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tmpResult
JS
:
:
BigInt
:
:
looselyEqual
(
cx
lbi
rval
)
)
;
*
result
=
tmpResult
;
return
true
;
}
if
(
rval
.
isBigInt
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
BigInt
*
>
rbi
(
cx
rval
.
toBigInt
(
)
)
;
bool
tmpResult
;
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
tmpResult
JS
:
:
BigInt
:
:
looselyEqual
(
cx
rbi
lval
)
)
;
*
result
=
tmpResult
;
return
true
;
}
*
result
=
false
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
LooselyEqual
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
equal
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
equal
)
;
return
js
:
:
LooselyEqual
(
cx
value1
value2
equal
)
;
}
bool
js
:
:
StrictlyEqual
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
lval
JS
:
:
Handle
<
JS
:
:
Value
>
rval
bool
*
equal
)
{
if
(
SameType
(
lval
rval
)
)
{
return
EqualGivenSameType
(
cx
lval
rval
equal
)
;
}
if
(
lval
.
isNumber
(
)
&
&
rval
.
isNumber
(
)
)
{
*
equal
=
(
lval
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
)
;
return
true
;
}
*
equal
=
false
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
StrictlyEqual
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
equal
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
equal
)
;
return
js
:
:
StrictlyEqual
(
cx
value1
value2
equal
)
;
}
static
inline
bool
IsNegativeZero
(
const
JS
:
:
Value
&
v
)
{
return
v
.
isDouble
(
)
&
&
mozilla
:
:
IsNegativeZero
(
v
.
toDouble
(
)
)
;
}
static
inline
bool
IsNaN
(
const
JS
:
:
Value
&
v
)
{
return
v
.
isDouble
(
)
&
&
mozilla
:
:
IsNaN
(
v
.
toDouble
(
)
)
;
}
bool
js
:
:
SameValue
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v1
JS
:
:
Handle
<
JS
:
:
Value
>
v2
bool
*
same
)
{
if
(
IsNegativeZero
(
v1
)
)
{
*
same
=
IsNegativeZero
(
v2
)
;
return
true
;
}
if
(
IsNegativeZero
(
v2
)
)
{
*
same
=
false
;
return
true
;
}
#
ifdef
ENABLE_RECORD_TUPLE
if
(
v1
.
isExtendedPrimitive
(
)
)
{
JSObject
*
lobj
=
&
v1
.
toExtendedPrimitive
(
)
;
JSObject
*
robj
=
&
v2
.
toExtendedPrimitive
(
)
;
if
(
lobj
-
>
getClass
(
)
!
=
robj
-
>
getClass
(
)
)
{
*
same
=
false
;
return
true
;
}
if
(
lobj
-
>
is
<
js
:
:
RecordType
>
(
)
)
{
return
js
:
:
RecordType
:
:
sameValue
(
cx
&
lobj
-
>
as
<
js
:
:
RecordType
>
(
)
&
robj
-
>
as
<
js
:
:
RecordType
>
(
)
same
)
;
}
if
(
lobj
-
>
is
<
js
:
:
TupleType
>
(
)
)
{
return
js
:
:
TupleType
:
:
sameValue
(
cx
&
lobj
-
>
as
<
js
:
:
TupleType
>
(
)
&
robj
-
>
as
<
js
:
:
TupleType
>
(
)
same
)
;
}
MOZ_CRASH
(
"
Unknown
ExtendedPrimitive
type
"
)
;
}
#
endif
return
js
:
:
SameValueZero
(
cx
v1
v2
same
)
;
}
#
ifdef
ENABLE_RECORD_TUPLE
bool
js
:
:
SameValueZeroLinear
(
const
JS
:
:
Value
&
lval
const
JS
:
:
Value
&
rval
)
{
if
(
lval
.
isNumber
(
)
&
&
rval
.
isNumber
(
)
)
{
return
IsNaN
(
lval
)
?
IsNaN
(
rval
)
:
lval
.
toNumber
(
)
=
=
rval
.
toNumber
(
)
;
}
if
(
lval
.
type
(
)
!
=
rval
.
type
(
)
)
{
return
false
;
}
switch
(
lval
.
type
(
)
)
{
case
ValueType
:
:
Double
:
return
IsNaN
(
lval
)
?
IsNaN
(
rval
)
:
lval
.
toDouble
(
)
=
=
rval
.
toDouble
(
)
;
case
ValueType
:
:
BigInt
:
return
BigInt
:
:
equal
(
lval
.
toBigInt
(
)
rval
.
toBigInt
(
)
)
;
case
ValueType
:
:
String
:
MOZ_ASSERT
(
lval
.
toString
(
)
-
>
isLinear
(
)
&
&
rval
.
toString
(
)
-
>
isLinear
(
)
)
;
return
EqualStrings
(
&
lval
.
toString
(
)
-
>
asLinear
(
)
&
rval
.
toString
(
)
-
>
asLinear
(
)
)
;
case
ValueType
:
:
ExtendedPrimitive
:
{
JSObject
&
lobj
=
lval
.
toExtendedPrimitive
(
)
;
JSObject
&
robj
=
rval
.
toExtendedPrimitive
(
)
;
if
(
lobj
.
getClass
(
)
!
=
robj
.
getClass
(
)
)
{
return
false
;
}
if
(
lobj
.
is
<
RecordType
>
(
)
)
{
return
RecordType
:
:
sameValueZero
(
&
lobj
.
as
<
RecordType
>
(
)
&
robj
.
as
<
RecordType
>
(
)
)
;
}
MOZ_ASSERT
(
lobj
.
is
<
TupleType
>
(
)
)
;
return
TupleType
:
:
sameValueZero
(
&
lobj
.
as
<
TupleType
>
(
)
&
robj
.
as
<
TupleType
>
(
)
)
;
}
default
:
MOZ_ASSERT
(
CanUseBitwiseCompareForStrictlyEqual
(
lval
)
)
;
return
lval
.
asRawBits
(
)
=
=
rval
.
asRawBits
(
)
;
}
}
#
endif
JS_PUBLIC_API
bool
JS
:
:
SameValue
(
JSContext
*
cx
Handle
<
Value
>
value1
Handle
<
Value
>
value2
bool
*
same
)
{
js
:
:
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
value1
value2
)
;
MOZ_ASSERT
(
same
)
;
return
js
:
:
SameValue
(
cx
value1
value2
same
)
;
}
bool
js
:
:
SameValueZero
(
JSContext
*
cx
Handle
<
Value
>
v1
Handle
<
Value
>
v2
bool
*
same
)
{
if
(
IsNaN
(
v1
)
&
&
IsNaN
(
v2
)
)
{
*
same
=
true
;
return
true
;
}
return
js
:
:
StrictlyEqual
(
cx
v1
v2
same
)
;
}
