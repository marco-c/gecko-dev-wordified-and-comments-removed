#
include
"
vm
/
OffThreadPromiseRuntimeState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
JS
:
:
Handle
;
using
js
:
:
OffThreadPromiseRuntimeState
;
using
js
:
:
OffThreadPromiseTask
;
OffThreadPromiseTask
:
:
OffThreadPromiseTask
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
)
:
runtime_
(
cx
-
>
runtime
(
)
)
promise_
(
cx
promise
)
registered_
(
false
)
{
MOZ_ASSERT
(
runtime_
=
=
promise_
-
>
zone
(
)
-
>
runtimeFromMainThread
(
)
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
offThreadPromiseState
.
ref
(
)
.
initialized
(
)
)
;
}
OffThreadPromiseTask
:
:
~
OffThreadPromiseTask
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
if
(
registered_
)
{
unregister
(
state
)
;
}
}
bool
OffThreadPromiseTask
:
:
init
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
=
=
runtime_
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
if
(
!
state
.
live_
.
putNew
(
this
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
registered_
=
true
;
return
true
;
}
void
OffThreadPromiseTask
:
:
unregister
(
OffThreadPromiseRuntimeState
&
state
)
{
MOZ_ASSERT
(
registered_
)
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
state
.
live_
.
remove
(
this
)
;
registered_
=
false
;
}
void
OffThreadPromiseTask
:
:
run
(
JSContext
*
cx
MaybeShuttingDown
maybeShuttingDown
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
=
=
runtime_
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
MOZ_ASSERT
(
registered_
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
unregister
(
state
)
;
if
(
maybeShuttingDown
=
=
JS
:
:
Dispatchable
:
:
NotShuttingDown
)
{
AutoRealm
ar
(
cx
promise_
)
;
if
(
!
resolve
(
cx
promise_
)
)
{
cx
-
>
clearPendingException
(
)
;
}
}
js_delete
(
this
)
;
}
void
OffThreadPromiseTask
:
:
dispatchResolveAndDestroy
(
)
{
MOZ_ASSERT
(
registered_
)
;
OffThreadPromiseRuntimeState
&
state
=
runtime_
-
>
offThreadPromiseState
.
ref
(
)
;
MOZ_ASSERT
(
state
.
initialized
(
)
)
;
MOZ_ASSERT
(
(
LockGuard
<
Mutex
>
(
state
.
mutex_
)
state
.
live_
.
has
(
this
)
)
)
;
if
(
state
.
dispatchToEventLoopCallback_
(
state
.
dispatchToEventLoopClosure_
this
)
)
{
return
;
}
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
state
.
numCanceled_
+
+
;
if
(
state
.
numCanceled_
=
=
state
.
live_
.
count
(
)
)
{
state
.
allCanceled_
.
notify_one
(
)
;
}
}
OffThreadPromiseRuntimeState
:
:
OffThreadPromiseRuntimeState
(
)
:
dispatchToEventLoopCallback_
(
nullptr
)
dispatchToEventLoopClosure_
(
nullptr
)
mutex_
(
mutexid
:
:
OffThreadPromiseState
)
numCanceled_
(
0
)
internalDispatchQueueClosed_
(
false
)
{
}
OffThreadPromiseRuntimeState
:
:
~
OffThreadPromiseRuntimeState
(
)
{
MOZ_ASSERT
(
live_
.
empty
(
)
)
;
MOZ_ASSERT
(
numCanceled_
=
=
0
)
;
MOZ_ASSERT
(
internalDispatchQueue_
.
empty
(
)
)
;
MOZ_ASSERT
(
!
initialized
(
)
)
;
}
void
OffThreadPromiseRuntimeState
:
:
init
(
JS
:
:
DispatchToEventLoopCallback
callback
void
*
closure
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
dispatchToEventLoopCallback_
=
callback
;
dispatchToEventLoopClosure_
=
closure
;
MOZ_ASSERT
(
initialized
(
)
)
;
}
bool
OffThreadPromiseRuntimeState
:
:
internalDispatchToEventLoop
(
void
*
closure
JS
:
:
Dispatchable
*
d
)
{
OffThreadPromiseRuntimeState
&
state
=
*
reinterpret_cast
<
OffThreadPromiseRuntimeState
*
>
(
closure
)
;
MOZ_ASSERT
(
state
.
usingInternalDispatchQueue
(
)
)
;
LockGuard
<
Mutex
>
lock
(
state
.
mutex_
)
;
if
(
state
.
internalDispatchQueueClosed_
)
{
return
false
;
}
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
state
.
internalDispatchQueue_
.
pushBack
(
d
)
)
{
noOOM
.
crash
(
"
internalDispatchToEventLoop
"
)
;
}
state
.
internalDispatchQueueAppended_
.
notify_one
(
)
;
return
true
;
}
bool
OffThreadPromiseRuntimeState
:
:
usingInternalDispatchQueue
(
)
const
{
return
dispatchToEventLoopCallback_
=
=
internalDispatchToEventLoop
;
}
void
OffThreadPromiseRuntimeState
:
:
initInternalDispatchQueue
(
)
{
init
(
internalDispatchToEventLoop
this
)
;
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
}
bool
OffThreadPromiseRuntimeState
:
:
initialized
(
)
const
{
return
!
!
dispatchToEventLoopCallback_
;
}
void
OffThreadPromiseRuntimeState
:
:
internalDrain
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
MOZ_ASSERT
(
!
internalDispatchQueueClosed_
)
;
for
(
;
;
)
{
JS
:
:
Dispatchable
*
d
;
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
MOZ_ASSERT_IF
(
!
internalDispatchQueue_
.
empty
(
)
!
live_
.
empty
(
)
)
;
if
(
live_
.
empty
(
)
)
{
return
;
}
while
(
internalDispatchQueue_
.
empty
(
)
)
{
internalDispatchQueueAppended_
.
wait
(
lock
)
;
}
d
=
internalDispatchQueue_
.
popCopyFront
(
)
;
}
d
-
>
run
(
cx
JS
:
:
Dispatchable
:
:
NotShuttingDown
)
;
}
}
bool
OffThreadPromiseRuntimeState
:
:
internalHasPending
(
)
{
MOZ_ASSERT
(
usingInternalDispatchQueue
(
)
)
;
MOZ_ASSERT
(
!
internalDispatchQueueClosed_
)
;
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
MOZ_ASSERT_IF
(
!
internalDispatchQueue_
.
empty
(
)
!
live_
.
empty
(
)
)
;
return
!
live_
.
empty
(
)
;
}
void
OffThreadPromiseRuntimeState
:
:
shutdown
(
JSContext
*
cx
)
{
if
(
!
initialized
(
)
)
{
return
;
}
if
(
usingInternalDispatchQueue
(
)
)
{
DispatchableFifo
dispatchQueue
;
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
std
:
:
swap
(
dispatchQueue
internalDispatchQueue_
)
;
MOZ_ASSERT
(
internalDispatchQueue_
.
empty
(
)
)
;
internalDispatchQueueClosed_
=
true
;
}
for
(
JS
:
:
Dispatchable
*
d
:
dispatchQueue
)
{
d
-
>
run
(
cx
JS
:
:
Dispatchable
:
:
ShuttingDown
)
;
}
}
{
LockGuard
<
Mutex
>
lock
(
mutex_
)
;
while
(
live_
.
count
(
)
!
=
numCanceled_
)
{
MOZ_ASSERT
(
numCanceled_
<
live_
.
count
(
)
)
;
allCanceled_
.
wait
(
lock
)
;
}
}
for
(
OffThreadPromiseTaskSet
:
:
Range
r
=
live_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
OffThreadPromiseTask
*
task
=
r
.
front
(
)
;
MOZ_ASSERT
(
task
-
>
registered_
)
;
task
-
>
registered_
=
false
;
js_delete
(
task
)
;
}
live_
.
clear
(
)
;
numCanceled_
=
0
;
dispatchToEventLoopCallback_
=
nullptr
;
MOZ_ASSERT
(
!
initialized
(
)
)
;
}
