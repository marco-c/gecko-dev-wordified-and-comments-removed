#
ifndef
vm_MatchPairs_h
#
define
vm_MatchPairs_h
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
struct
MatchPair
final
{
int32_t
start
;
int32_t
limit
;
static
constexpr
int32_t
NoMatch
=
-
1
;
MatchPair
(
)
:
start
(
NoMatch
)
limit
(
NoMatch
)
{
}
MatchPair
(
int32_t
start
int32_t
limit
)
:
start
(
start
)
limit
(
limit
)
{
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
!
isUndefined
(
)
)
;
return
limit
-
start
;
}
bool
isUndefined
(
)
const
{
return
start
<
0
;
}
inline
bool
check
(
)
const
{
MOZ_ASSERT
(
limit
>
=
start
)
;
MOZ_ASSERT_IF
(
start
<
0
start
=
=
NoMatch
)
;
MOZ_ASSERT_IF
(
limit
<
0
limit
=
=
NoMatch
)
;
return
true
;
}
static
constexpr
int32_t
offsetOfStart
(
)
{
return
int32_t
(
offsetof
(
MatchPair
start
)
)
;
}
static
constexpr
int32_t
offsetOfLimit
(
)
{
return
int32_t
(
offsetof
(
MatchPair
limit
)
)
;
}
}
;
class
MatchPairs
{
protected
:
uint32_t
pairCount_
;
MatchPair
*
pairs_
;
protected
:
MatchPairs
(
)
:
pairCount_
(
0
)
pairs_
(
nullptr
)
{
}
protected
:
friend
class
RegExpShared
;
friend
class
RegExpStatics
;
void
forgetArray
(
)
{
pairs_
=
nullptr
;
}
public
:
void
checkAgainst
(
size_t
inputLength
)
{
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
pairCount_
;
i
+
+
)
{
const
MatchPair
&
p
=
(
*
this
)
[
i
]
;
MOZ_ASSERT
(
p
.
check
(
)
)
;
if
(
p
.
isUndefined
(
)
)
{
continue
;
}
MOZ_ASSERT
(
size_t
(
p
.
limit
)
<
=
inputLength
)
;
}
#
endif
}
bool
empty
(
)
const
{
return
pairCount_
=
=
0
;
}
size_t
pairCount
(
)
const
{
MOZ_ASSERT
(
pairCount_
>
0
)
;
return
pairCount_
;
}
static
constexpr
int32_t
offsetOfPairs
(
)
{
return
int32_t
(
offsetof
(
MatchPairs
pairs_
)
)
;
}
static
constexpr
int32_t
offsetOfPairCount
(
)
{
return
int32_t
(
offsetof
(
MatchPairs
pairCount_
)
)
;
}
int32_t
*
pairsRaw
(
)
{
return
reinterpret_cast
<
int32_t
*
>
(
pairs_
)
;
}
public
:
size_t
length
(
)
const
{
return
pairCount_
;
}
const
MatchPair
&
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
pairCount_
)
;
return
pairs_
[
i
]
;
}
MatchPair
&
operator
[
]
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
pairCount_
)
;
return
pairs_
[
i
]
;
}
}
;
class
VectorMatchPairs
:
public
MatchPairs
{
Vector
<
MatchPair
10
SystemAllocPolicy
>
vec_
;
protected
:
friend
class
RegExpShared
;
friend
class
RegExpStatics
;
bool
allocOrExpandArray
(
size_t
pairCount
)
;
bool
initArrayFrom
(
VectorMatchPairs
&
copyFrom
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
vec_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
}
#
endif
