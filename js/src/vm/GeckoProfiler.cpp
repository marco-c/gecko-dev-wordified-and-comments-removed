#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
JitcodeMap
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
include
"
jit
/
PerfSpewer
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
vm
/
FrameIter
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
jit
/
JSJitFrameIter
-
inl
.
h
"
using
namespace
js
;
GeckoProfilerThread
:
:
GeckoProfilerThread
(
)
:
profilingStack_
(
nullptr
)
profilingStackIfEnabled_
(
nullptr
)
{
}
GeckoProfilerRuntime
:
:
GeckoProfilerRuntime
(
JSRuntime
*
rt
)
:
rt
(
rt
)
slowAssertions
(
false
)
enabled_
(
false
)
eventMarker_
(
nullptr
)
{
MOZ_ASSERT
(
rt
!
=
nullptr
)
;
}
void
GeckoProfilerThread
:
:
setProfilingStack
(
ProfilingStack
*
profilingStack
bool
enabled
)
{
profilingStack_
=
profilingStack
;
profilingStackIfEnabled_
=
enabled
?
profilingStack
:
nullptr
;
}
void
GeckoProfilerRuntime
:
:
setEventMarker
(
void
(
*
fn
)
(
mozilla
:
:
MarkerCategory
const
char
*
const
char
*
)
)
{
eventMarker_
=
fn
;
}
void
GeckoProfilerRuntime
:
:
setIntervalMarker
(
void
(
*
fn
)
(
mozilla
:
:
MarkerCategory
const
char
*
mozilla
:
:
TimeStamp
const
char
*
)
)
{
intervalMarker_
=
fn
;
}
static
jit
:
:
JitFrameLayout
*
GetTopProfilingJitFrame
(
jit
:
:
JitActivation
*
act
)
{
if
(
!
act
-
>
hasExitFP
(
)
)
{
return
nullptr
;
}
OnlyJSJitFrameIter
iter
(
act
)
;
if
(
iter
.
done
(
)
)
{
return
nullptr
;
}
jit
:
:
JSJitProfilingFrameIterator
jitIter
(
(
jit
:
:
CommonFrameLayout
*
)
iter
.
frame
(
)
.
fp
(
)
)
;
if
(
jitIter
.
done
(
)
)
{
return
nullptr
;
}
return
jitIter
.
framePtr
(
)
;
}
void
GeckoProfilerRuntime
:
:
enable
(
bool
enabled
)
{
JSContext
*
cx
=
rt
-
>
mainContextFromAnyThread
(
)
;
MOZ_ASSERT
(
cx
-
>
geckoProfiler
(
)
.
infraInstalled
(
)
)
;
if
(
enabled_
=
=
enabled
)
{
return
;
}
ReleaseAllJITCode
(
rt
-
>
gcContext
(
)
)
;
if
(
rt
-
>
hasJitRuntime
(
)
&
&
rt
-
>
jitRuntime
(
)
-
>
hasJitcodeGlobalTable
(
)
)
{
rt
-
>
jitRuntime
(
)
-
>
getJitcodeGlobalTable
(
)
-
>
setAllEntriesAsExpired
(
)
;
}
rt
-
>
setProfilerSampleBufferRangeStart
(
0
)
;
if
(
cx
-
>
jitActivation
)
{
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
nullptr
)
;
cx
-
>
jitActivation
-
>
setLastProfilingCallSite
(
nullptr
)
;
}
enabled_
=
enabled
;
jit
:
:
ToggleBaselineProfiling
(
cx
enabled
)
;
if
(
cx
-
>
jitActivation
)
{
if
(
enabled
)
{
jit
:
:
JitActivation
*
jitActivation
=
cx
-
>
jitActivation
;
while
(
jitActivation
)
{
auto
*
lastProfilingFrame
=
GetTopProfilingJitFrame
(
jitActivation
)
;
jitActivation
-
>
setLastProfilingFrame
(
lastProfilingFrame
)
;
jitActivation
-
>
setLastProfilingCallSite
(
nullptr
)
;
jitActivation
=
jitActivation
-
>
prevJitActivation
(
)
;
}
}
else
{
jit
:
:
JitActivation
*
jitActivation
=
cx
-
>
jitActivation
;
while
(
jitActivation
)
{
jitActivation
-
>
setLastProfilingFrame
(
nullptr
)
;
jitActivation
-
>
setLastProfilingCallSite
(
nullptr
)
;
jitActivation
=
jitActivation
-
>
prevJitActivation
(
)
;
}
}
}
for
(
RealmsIter
r
(
rt
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
wasm
.
ensureProfilingLabels
(
enabled
)
;
}
#
ifdef
JS_STRUCTURED_SPEW
if
(
enabled
)
{
cx
-
>
spewer
(
)
.
enableSpewing
(
)
;
}
else
{
cx
-
>
spewer
(
)
.
disableSpewing
(
)
;
}
#
endif
}
const
char
*
GeckoProfilerRuntime
:
:
profileString
(
JSContext
*
cx
BaseScript
*
script
)
{
ProfileStringMap
:
:
AddPtr
s
=
strings
(
)
.
lookupForAdd
(
script
)
;
if
(
!
s
)
{
UniqueChars
str
=
allocProfileString
(
cx
script
)
;
if
(
!
str
)
{
return
nullptr
;
}
MOZ_ASSERT
(
script
-
>
hasBytecode
(
)
)
;
if
(
!
strings
(
)
.
add
(
s
script
std
:
:
move
(
str
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
return
s
-
>
value
(
)
.
get
(
)
;
}
void
GeckoProfilerRuntime
:
:
onScriptFinalized
(
BaseScript
*
script
)
{
if
(
ProfileStringMap
:
:
Ptr
entry
=
strings
(
)
.
lookup
(
script
)
)
{
strings
(
)
.
remove
(
entry
)
;
}
}
void
GeckoProfilerRuntime
:
:
markEvent
(
const
char
*
event
const
char
*
details
JS
:
:
ProfilingCategoryPair
jsPair
)
{
MOZ_ASSERT
(
enabled
(
)
)
;
if
(
eventMarker_
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
mozilla
:
:
MarkerCategory
category
(
static_cast
<
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
>
(
jsPair
)
)
;
eventMarker_
(
category
event
details
)
;
}
}
void
GeckoProfilerRuntime
:
:
markInterval
(
const
char
*
event
mozilla
:
:
TimeStamp
start
const
char
*
details
JS
:
:
ProfilingCategoryPair
jsPair
)
{
MOZ_ASSERT
(
enabled
(
)
)
;
if
(
intervalMarker_
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
mozilla
:
:
MarkerCategory
category
(
static_cast
<
mozilla
:
:
baseprofiler
:
:
ProfilingCategoryPair
>
(
jsPair
)
)
;
intervalMarker_
(
category
event
start
details
)
;
}
}
bool
GeckoProfilerThread
:
:
enter
(
JSContext
*
cx
JSScript
*
script
)
{
const
char
*
dynamicString
=
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
profileString
(
cx
script
)
;
if
(
dynamicString
=
=
nullptr
)
{
return
false
;
}
#
ifdef
DEBUG
uint32_t
sp
=
profilingStack_
-
>
stackPointer
;
if
(
sp
>
0
&
&
sp
-
1
<
profilingStack_
-
>
stackCapacity
(
)
)
{
size_t
start
=
(
sp
>
4
)
?
sp
-
4
:
0
;
for
(
size_t
i
=
start
;
i
<
sp
-
1
;
i
+
+
)
{
MOZ_ASSERT_IF
(
profilingStack_
-
>
frames
[
i
]
.
isJsFrame
(
)
profilingStack_
-
>
frames
[
i
]
.
pc
(
)
)
;
}
}
#
endif
profilingStack_
-
>
pushJsFrame
(
"
"
dynamicString
script
script
-
>
code
(
)
script
-
>
realm
(
)
-
>
creationOptions
(
)
.
profilerRealmID
(
)
)
;
return
true
;
}
void
GeckoProfilerThread
:
:
exit
(
JSContext
*
cx
JSScript
*
script
)
{
profilingStack_
-
>
pop
(
)
;
#
ifdef
DEBUG
uint32_t
sp
=
profilingStack_
-
>
stackPointer
;
if
(
sp
<
profilingStack_
-
>
stackCapacity
(
)
)
{
JSRuntime
*
rt
=
script
-
>
runtimeFromMainThread
(
)
;
const
char
*
dynamicString
=
rt
-
>
geckoProfiler
(
)
.
profileString
(
cx
script
)
;
MOZ_ASSERT
(
dynamicString
)
;
if
(
!
profilingStack_
-
>
frames
[
sp
]
.
isJsFrame
(
)
)
{
fprintf
(
stderr
"
-
-
-
ABOUT
TO
FAIL
ASSERTION
-
-
-
\
n
"
)
;
fprintf
(
stderr
"
frames
=
%
p
size
=
%
u
/
%
u
\
n
"
(
void
*
)
profilingStack_
-
>
frames
uint32_t
(
profilingStack_
-
>
stackPointer
)
profilingStack_
-
>
stackCapacity
(
)
)
;
for
(
int32_t
i
=
sp
;
i
>
=
0
;
i
-
-
)
{
ProfilingStackFrame
&
frame
=
profilingStack_
-
>
frames
[
i
]
;
if
(
frame
.
isJsFrame
(
)
)
{
fprintf
(
stderr
"
[
%
d
]
JS
%
s
\
n
"
i
frame
.
dynamicString
(
)
)
;
}
else
{
fprintf
(
stderr
"
[
%
d
]
Label
%
s
\
n
"
i
frame
.
dynamicString
(
)
)
;
}
}
}
ProfilingStackFrame
&
frame
=
profilingStack_
-
>
frames
[
sp
]
;
MOZ_ASSERT
(
frame
.
isJsFrame
(
)
)
;
MOZ_ASSERT
(
frame
.
script
(
)
=
=
script
)
;
MOZ_ASSERT
(
strcmp
(
(
const
char
*
)
frame
.
dynamicString
(
)
dynamicString
)
=
=
0
)
;
}
#
endif
}
UniqueChars
GeckoProfilerRuntime
:
:
allocProfileString
(
JSContext
*
cx
BaseScript
*
script
)
{
JSAtom
*
name
=
nullptr
;
size_t
nameLength
=
0
;
JSFunction
*
func
=
script
-
>
function
(
)
;
if
(
func
&
&
func
-
>
fullDisplayAtom
(
)
)
{
name
=
func
-
>
fullDisplayAtom
(
)
;
nameLength
=
JS
:
:
GetDeflatedUTF8StringLength
(
name
)
;
}
constexpr
size_t
MaxFilenameLength
=
200
;
const
char
*
filenameStr
=
script
-
>
filename
(
)
?
script
-
>
filename
(
)
:
"
(
null
)
"
;
size_t
filenameLength
=
js_strnlen
(
filenameStr
MaxFilenameLength
)
;
bool
hasLineAndColumn
=
false
;
size_t
lineAndColumnLength
=
0
;
char
lineAndColumnStr
[
30
]
;
if
(
name
|
|
script
-
>
isFunction
(
)
|
|
script
-
>
isForEval
(
)
)
{
lineAndColumnLength
=
SprintfLiteral
(
lineAndColumnStr
"
%
u
:
%
u
"
script
-
>
lineno
(
)
script
-
>
column
(
)
.
oneOriginValue
(
)
)
;
hasLineAndColumn
=
true
;
}
size_t
fullLength
=
0
;
if
(
name
)
{
MOZ_ASSERT
(
hasLineAndColumn
)
;
fullLength
=
nameLength
+
2
+
filenameLength
+
1
+
lineAndColumnLength
+
1
;
}
else
if
(
hasLineAndColumn
)
{
fullLength
=
filenameLength
+
1
+
lineAndColumnLength
;
}
else
{
fullLength
=
filenameLength
;
}
UniqueChars
str
(
cx
-
>
pod_malloc
<
char
>
(
fullLength
+
1
)
)
;
if
(
!
str
)
{
return
nullptr
;
}
size_t
cur
=
0
;
if
(
name
)
{
mozilla
:
:
DebugOnly
<
size_t
>
written
=
JS
:
:
DeflateStringToUTF8Buffer
(
name
mozilla
:
:
Span
(
str
.
get
(
)
+
cur
nameLength
)
)
;
MOZ_ASSERT
(
written
=
=
nameLength
)
;
cur
+
=
nameLength
;
str
[
cur
+
+
]
=
'
'
;
str
[
cur
+
+
]
=
'
(
'
;
}
memcpy
(
str
.
get
(
)
+
cur
filenameStr
filenameLength
)
;
cur
+
=
filenameLength
;
if
(
hasLineAndColumn
)
{
str
[
cur
+
+
]
=
'
:
'
;
memcpy
(
str
.
get
(
)
+
cur
lineAndColumnStr
lineAndColumnLength
)
;
cur
+
=
lineAndColumnLength
;
}
if
(
name
)
{
str
[
cur
+
+
]
=
'
)
'
;
}
MOZ_ASSERT
(
cur
=
=
fullLength
)
;
str
[
cur
]
=
0
;
return
str
;
}
void
GeckoProfilerThread
:
:
trace
(
JSTracer
*
trc
)
{
if
(
profilingStack_
)
{
size_t
size
=
profilingStack_
-
>
stackSize
(
)
;
for
(
size_t
i
=
0
;
i
<
size
;
i
+
+
)
{
profilingStack_
-
>
frames
[
i
]
.
trace
(
trc
)
;
}
}
}
void
GeckoProfilerRuntime
:
:
fixupStringsMapAfterMovingGC
(
)
{
for
(
ProfileStringMap
:
:
Enum
e
(
strings
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
BaseScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
IsForwarded
(
script
)
)
{
script
=
Forwarded
(
script
)
;
e
.
rekeyFront
(
script
)
;
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
GeckoProfilerRuntime
:
:
checkStringsMapAfterMovingGC
(
)
{
CheckTableAfterMovingGC
(
strings
(
)
[
]
(
const
auto
&
entry
)
{
BaseScript
*
script
=
entry
.
key
(
)
;
CheckGCThingAfterMovingGC
(
script
)
;
return
script
;
}
)
;
}
#
endif
void
ProfilingStackFrame
:
:
trace
(
JSTracer
*
trc
)
{
if
(
isJsFrame
(
)
)
{
JSScript
*
s
=
rawScript
(
)
;
TraceNullableRoot
(
trc
&
s
"
ProfilingStackFrame
script
"
)
;
spOrScript
=
s
;
}
}
GeckoProfilerBaselineOSRMarker
:
:
GeckoProfilerBaselineOSRMarker
(
JSContext
*
cx
bool
hasProfilerFrame
)
:
profiler
(
&
cx
-
>
geckoProfiler
(
)
)
{
if
(
!
hasProfilerFrame
|
|
!
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
profiler
=
nullptr
;
return
;
}
uint32_t
sp
=
profiler
-
>
profilingStack_
-
>
stackPointer
;
if
(
sp
>
=
profiler
-
>
profilingStack_
-
>
stackCapacity
(
)
)
{
profiler
=
nullptr
;
return
;
}
spBefore_
=
sp
;
if
(
sp
=
=
0
)
{
return
;
}
ProfilingStackFrame
&
frame
=
profiler
-
>
profilingStack_
-
>
frames
[
sp
-
1
]
;
MOZ_ASSERT
(
!
frame
.
isOSRFrame
(
)
)
;
frame
.
setIsOSRFrame
(
true
)
;
}
GeckoProfilerBaselineOSRMarker
:
:
~
GeckoProfilerBaselineOSRMarker
(
)
{
if
(
profiler
=
=
nullptr
)
{
return
;
}
uint32_t
sp
=
profiler
-
>
stackPointer
(
)
;
MOZ_ASSERT
(
spBefore_
=
=
sp
)
;
if
(
sp
=
=
0
)
{
return
;
}
ProfilingStackFrame
&
frame
=
profiler
-
>
stack
(
)
[
sp
-
1
]
;
MOZ_ASSERT
(
frame
.
isOSRFrame
(
)
)
;
frame
.
setIsOSRFrame
(
false
)
;
}
JS_PUBLIC_API
JSScript
*
ProfilingStackFrame
:
:
script
(
)
const
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
auto
*
script
=
reinterpret_cast
<
JSScript
*
>
(
spOrScript
.
operator
void
*
(
)
)
;
if
(
!
script
)
{
return
nullptr
;
}
JSContext
*
cx
=
script
-
>
runtimeFromAnyThread
(
)
-
>
mainContextFromAnyThread
(
)
;
if
(
!
cx
-
>
isProfilerSamplingEnabled
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
IsForwarded
(
script
)
)
;
return
script
;
}
JS_PUBLIC_API
JSFunction
*
ProfilingStackFrame
:
:
function
(
)
const
{
JSScript
*
script
=
this
-
>
script
(
)
;
return
script
?
script
-
>
function
(
)
:
nullptr
;
}
JS_PUBLIC_API
jsbytecode
*
ProfilingStackFrame
:
:
pc
(
)
const
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
if
(
pcOffsetIfJS_
=
=
NullPCOffset
)
{
return
nullptr
;
}
JSScript
*
script
=
this
-
>
script
(
)
;
return
script
?
script
-
>
offsetToPC
(
pcOffsetIfJS_
)
:
nullptr
;
}
int32_t
ProfilingStackFrame
:
:
pcToOffset
(
JSScript
*
aScript
jsbytecode
*
aPc
)
{
return
aPc
?
aScript
-
>
pcToOffset
(
aPc
)
:
NullPCOffset
;
}
void
ProfilingStackFrame
:
:
setPC
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
JSScript
*
script
=
this
-
>
script
(
)
;
MOZ_ASSERT
(
script
)
;
pcOffsetIfJS_
=
pcToOffset
(
script
pc
)
;
}
JS_PUBLIC_API
void
js
:
:
SetContextProfilingStack
(
JSContext
*
cx
ProfilingStack
*
profilingStack
)
{
cx
-
>
geckoProfiler
(
)
.
setProfilingStack
(
profilingStack
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
;
}
JS_PUBLIC_API
void
js
:
:
EnableContextProfilingStack
(
JSContext
*
cx
bool
enabled
)
{
cx
-
>
geckoProfiler
(
)
.
enable
(
enabled
)
;
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enable
(
enabled
)
;
}
JS_PUBLIC_API
void
js
:
:
RegisterContextProfilingEventMarker
(
JSContext
*
cx
void
(
*
mark
)
(
mozilla
:
:
MarkerCategory
const
char
*
const
char
*
)
void
(
*
interval
)
(
mozilla
:
:
MarkerCategory
const
char
*
mozilla
:
:
TimeStamp
const
char
*
)
)
{
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
;
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
setEventMarker
(
mark
)
;
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
setIntervalMarker
(
interval
)
;
}
AutoSuppressProfilerSampling
:
:
AutoSuppressProfilerSampling
(
JSContext
*
cx
)
:
cx_
(
cx
)
previouslyEnabled_
(
cx
-
>
isProfilerSamplingEnabled
(
)
)
{
if
(
previouslyEnabled_
)
{
cx_
-
>
disableProfilerSampling
(
)
;
}
}
AutoSuppressProfilerSampling
:
:
~
AutoSuppressProfilerSampling
(
)
{
if
(
previouslyEnabled_
)
{
cx_
-
>
enableProfilerSampling
(
)
;
}
}
namespace
JS
{
#
define
SUBCATEGORY_ENUMS_BEGIN_CATEGORY
(
name
labelAsString
color
)
\
enum
class
ProfilingSubcategory_
#
#
name
:
uint32_t
{
#
define
SUBCATEGORY_ENUMS_SUBCATEGORY
(
category
name
labelAsString
)
\
name
#
define
SUBCATEGORY_ENUMS_END_CATEGORY
\
}
;
MOZ_PROFILING_CATEGORY_LIST
(
SUBCATEGORY_ENUMS_BEGIN_CATEGORY
SUBCATEGORY_ENUMS_SUBCATEGORY
SUBCATEGORY_ENUMS_END_CATEGORY
)
#
undef
SUBCATEGORY_ENUMS_BEGIN_CATEGORY
#
undef
SUBCATEGORY_ENUMS_SUBCATEGORY
#
undef
SUBCATEGORY_ENUMS_END_CATEGORY
#
define
CATEGORY_INFO_BEGIN_CATEGORY
(
name
labelAsString
color
)
#
define
CATEGORY_INFO_SUBCATEGORY
(
category
name
labelAsString
)
\
{
ProfilingCategory
:
:
category
\
uint32_t
(
ProfilingSubcategory_
#
#
category
:
:
name
)
labelAsString
}
#
define
CATEGORY_INFO_END_CATEGORY
const
ProfilingCategoryPairInfo
sProfilingCategoryPairInfo
[
]
=
{
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_INFO_BEGIN_CATEGORY
CATEGORY_INFO_SUBCATEGORY
CATEGORY_INFO_END_CATEGORY
)
}
;
#
undef
CATEGORY_INFO_BEGIN_CATEGORY
#
undef
CATEGORY_INFO_SUBCATEGORY
#
undef
CATEGORY_INFO_END_CATEGORY
JS_PUBLIC_API
const
ProfilingCategoryPairInfo
&
GetProfilingCategoryPairInfo
(
ProfilingCategoryPair
aCategoryPair
)
{
static_assert
(
std
:
:
size
(
sProfilingCategoryPairInfo
)
=
=
uint32_t
(
ProfilingCategoryPair
:
:
COUNT
)
"
sProfilingCategoryPairInfo
and
ProfilingCategory
need
to
have
the
"
"
same
order
and
the
same
length
"
)
;
uint32_t
categoryPairIndex
=
uint32_t
(
aCategoryPair
)
;
MOZ_RELEASE_ASSERT
(
categoryPairIndex
<
=
uint32_t
(
ProfilingCategoryPair
:
:
LAST
)
)
;
return
sProfilingCategoryPairInfo
[
categoryPairIndex
]
;
}
}
