#
ifndef
vm_Scope_h
#
define
vm_Scope_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
Xdr
.
h
"
namespace
js
{
class
ModuleObject
;
enum
class
BindingKind
:
uint8_t
{
Import
FormalParameter
Var
Let
Const
NamedLambdaCallee
}
;
static
inline
bool
BindingKindIsLexical
(
BindingKind
kind
)
{
return
kind
=
=
BindingKind
:
:
Let
|
|
kind
=
=
BindingKind
:
:
Const
;
}
enum
class
ScopeKind
:
uint8_t
{
Function
FunctionBodyVar
ParameterExpressionVar
Lexical
SimpleCatch
Catch
NamedLambda
StrictNamedLambda
With
Eval
StrictEval
Global
NonSyntactic
Module
}
;
static
inline
bool
ScopeKindIsCatch
(
ScopeKind
kind
)
{
return
kind
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind
=
=
ScopeKind
:
:
Catch
;
}
const
char
*
BindingKindString
(
BindingKind
kind
)
;
const
char
*
ScopeKindString
(
ScopeKind
kind
)
;
class
BindingName
{
uintptr_t
bits_
;
static
const
uintptr_t
ClosedOverFlag
=
0x1
;
static
const
uintptr_t
FlagMask
=
0x1
;
public
:
BindingName
(
)
:
bits_
(
0
)
{
}
BindingName
(
JSAtom
*
name
bool
closedOver
)
:
bits_
(
uintptr_t
(
name
)
|
(
closedOver
?
ClosedOverFlag
:
0x0
)
)
{
}
JSAtom
*
name
(
)
const
{
return
reinterpret_cast
<
JSAtom
*
>
(
bits_
&
~
FlagMask
)
;
}
bool
closedOver
(
)
const
{
return
bits_
&
ClosedOverFlag
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
BindingLocation
{
public
:
enum
class
Kind
{
Global
Argument
Frame
Environment
Import
NamedLambdaCallee
}
;
private
:
Kind
kind_
;
uint32_t
slot_
;
BindingLocation
(
Kind
kind
uint32_t
slot
)
:
kind_
(
kind
)
slot_
(
slot
)
{
}
public
:
static
BindingLocation
Global
(
)
{
return
BindingLocation
(
Kind
:
:
Global
UINT32_MAX
)
;
}
static
BindingLocation
Argument
(
uint16_t
slot
)
{
return
BindingLocation
(
Kind
:
:
Argument
slot
)
;
}
static
BindingLocation
Frame
(
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
LOCALNO_LIMIT
)
;
return
BindingLocation
(
Kind
:
:
Frame
slot
)
;
}
static
BindingLocation
Environment
(
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
ENVCOORD_SLOT_LIMIT
)
;
return
BindingLocation
(
Kind
:
:
Environment
slot
)
;
}
static
BindingLocation
Import
(
)
{
return
BindingLocation
(
Kind
:
:
Import
UINT32_MAX
)
;
}
static
BindingLocation
NamedLambdaCallee
(
)
{
return
BindingLocation
(
Kind
:
:
NamedLambdaCallee
UINT32_MAX
)
;
}
bool
operator
=
=
(
const
BindingLocation
&
other
)
const
{
return
kind_
=
=
other
.
kind_
&
&
slot_
=
=
other
.
slot_
;
}
bool
operator
!
=
(
const
BindingLocation
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Frame
|
|
kind_
=
=
Kind
:
:
Environment
)
;
return
slot_
;
}
uint16_t
argumentSlot
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Argument
)
;
return
mozilla
:
:
AssertedCast
<
uint16_t
>
(
slot_
)
;
}
}
;
class
Scope
:
public
js
:
:
gc
:
:
TenuredCell
{
friend
class
GCMarker
;
ScopeKind
kind_
;
GCPtrScope
enclosing_
;
GCPtrShape
environmentShape_
;
protected
:
uintptr_t
data_
;
Scope
(
ScopeKind
kind
Scope
*
enclosing
Shape
*
environmentShape
)
:
kind_
(
kind
)
enclosing_
(
enclosing
)
environmentShape_
(
environmentShape
)
data_
(
0
)
{
}
static
Scope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
)
;
template
<
typename
T
typename
D
>
static
Scope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
mozilla
:
:
UniquePtr
<
T
D
>
data
)
;
template
<
typename
ConcreteScope
XDRMode
mode
>
static
bool
XDRSizedBindingNames
(
XDRState
<
mode
>
*
xdr
Handle
<
ConcreteScope
*
>
scope
MutableHandle
<
typename
ConcreteScope
:
:
Data
*
>
data
)
;
Shape
*
maybeCloneEnvironmentShape
(
JSContext
*
cx
)
;
template
<
typename
T
typename
D
>
void
initData
(
mozilla
:
:
UniquePtr
<
T
D
>
data
)
{
MOZ_ASSERT
(
!
data_
)
;
data_
=
reinterpret_cast
<
uintptr_t
>
(
data
.
release
(
)
)
;
}
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Scope
;
template
<
typename
T
>
bool
is
(
)
const
{
return
kind_
=
=
T
:
:
classScopeKind_
;
}
template
<
typename
T
>
T
&
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
T
*
>
(
this
)
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
ScopeKind
kind
(
)
const
{
return
kind_
;
}
Scope
*
enclosing
(
)
const
{
return
enclosing_
;
}
Shape
*
environmentShape
(
)
const
{
return
environmentShape_
;
}
bool
hasEnvironment
(
)
const
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
With
:
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
true
;
default
:
return
environmentShape_
!
=
nullptr
;
}
}
uint32_t
chainLength
(
)
const
;
uint32_t
environmentChainLength
(
)
const
;
template
<
typename
T
>
bool
hasOnChain
(
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
is
<
T
>
(
)
)
return
true
;
}
return
false
;
}
bool
hasOnChain
(
ScopeKind
kind
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
kind
(
)
=
=
kind
)
return
true
;
}
return
false
;
}
static
Scope
*
clone
(
JSContext
*
cx
HandleScope
scope
HandleScope
enclosing
)
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
FreeOp
*
fop
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
dump
(
)
;
}
;
class
LexicalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
BindingIter
;
public
:
struct
Data
{
uint32_t
constStart
;
uint32_t
length
;
uint32_t
nextFrameSlot
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
LexicalScope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
bool
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
protected
:
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
static
uint32_t
nextFrameSlot
(
Scope
*
start
)
;
public
:
uint32_t
firstFrameSlot
(
)
const
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
nextFrameSlot
;
}
static
Shape
*
getEmptyExtensibleEnvironmentShape
(
ExclusiveContext
*
cx
)
;
}
;
template
<
>
inline
bool
Scope
:
:
is
<
LexicalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Lexical
|
|
kind_
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind_
=
=
ScopeKind
:
:
Catch
|
|
kind_
=
=
ScopeKind
:
:
NamedLambda
|
|
kind_
=
=
ScopeKind
:
:
StrictNamedLambda
;
}
class
FunctionScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
BindingIter
;
friend
class
PositionalFormalParameterIter
;
friend
class
Scope
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Function
;
public
:
struct
Data
{
GCPtrFunction
canonicalFunction
;
bool
hasParameterExprs
;
uint16_t
nonPositionalFormalStart
;
uint16_t
varStart
;
uint32_t
length
;
uint32_t
nextFrameSlot
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
FunctionScope
*
create
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
bool
hasParameterExprs
bool
needsEnvironment
HandleFunction
fun
HandleScope
enclosing
)
;
static
FunctionScope
*
clone
(
JSContext
*
cx
Handle
<
FunctionScope
*
>
scope
HandleFunction
fun
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
bool
XDR
(
XDRState
<
mode
>
*
xdr
HandleFunction
fun
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
UniquePtr
<
Data
>
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
bool
hasParameterExprs
MutableHandleShape
envShape
)
;
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
nextFrameSlot
;
}
JSFunction
*
canonicalFunction
(
)
const
{
return
data
(
)
.
canonicalFunction
;
}
JSScript
*
script
(
)
const
;
bool
hasParameterExprs
(
)
const
{
return
data
(
)
.
hasParameterExprs
;
}
uint32_t
numPositionalFormalParameters
(
)
const
{
return
data
(
)
.
nonPositionalFormalStart
;
}
static
Shape
*
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
bool
hasParameterExprs
)
;
}
;
class
VarScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
BindingIter
;
friend
class
Scope
;
public
:
struct
Data
{
uint32_t
length
;
uint32_t
nextFrameSlot
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
VarScope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
bool
needsEnvironment
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
bool
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
UniquePtr
<
Data
>
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
uint32_t
firstFrameSlot
MutableHandleShape
envShape
)
;
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
public
:
uint32_t
firstFrameSlot
(
)
const
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
nextFrameSlot
;
}
static
Shape
*
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
;
}
;
template
<
>
inline
bool
Scope
:
:
is
<
VarScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
FunctionBodyVar
|
|
kind_
=
=
ScopeKind
:
:
ParameterExpressionVar
;
}
class
GlobalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
BindingIter
;
public
:
struct
Data
{
uint32_t
letStart
;
uint32_t
constStart
;
uint32_t
length
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
GlobalScope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
)
;
static
GlobalScope
*
createEmpty
(
ExclusiveContext
*
cx
ScopeKind
kind
)
{
return
create
(
cx
kind
nullptr
)
;
}
static
GlobalScope
*
clone
(
JSContext
*
cx
Handle
<
GlobalScope
*
>
scope
ScopeKind
kind
)
;
template
<
XDRMode
mode
>
static
bool
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
MutableHandleScope
scope
)
;
private
:
static
UniquePtr
<
Data
>
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
)
;
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
public
:
bool
isSyntactic
(
)
const
{
return
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
length
>
0
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
GlobalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Global
|
|
kind_
=
=
ScopeKind
:
:
NonSyntactic
;
}
class
WithScope
:
public
Scope
{
friend
class
Scope
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
With
;
public
:
static
WithScope
*
create
(
ExclusiveContext
*
cx
HandleScope
enclosing
)
;
}
;
class
EvalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
BindingIter
;
public
:
struct
Data
{
uint32_t
length
;
uint32_t
nextFrameSlot
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
EvalScope
*
create
(
ExclusiveContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
bool
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
UniquePtr
<
Data
>
copyData
(
ExclusiveContext
*
cx
ScopeKind
scopeKind
Handle
<
Data
*
>
data
MutableHandleShape
envShape
)
;
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
public
:
static
Scope
*
nearestVarScopeForDirectEval
(
Scope
*
scope
)
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
nextFrameSlot
;
}
bool
strict
(
)
const
{
return
kind
(
)
=
=
ScopeKind
:
:
StrictEval
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
length
>
0
;
}
bool
isNonGlobal
(
)
const
{
if
(
strict
(
)
)
return
true
;
return
!
nearestVarScopeForDirectEval
(
enclosing
(
)
)
-
>
is
<
GlobalScope
>
(
)
;
}
static
Shape
*
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
;
}
;
template
<
>
inline
bool
Scope
:
:
is
<
EvalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Eval
|
|
kind_
=
=
ScopeKind
:
:
StrictEval
;
}
class
ModuleScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
BindingIter
;
friend
class
Scope
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Module
;
public
:
struct
Data
{
GCPtr
<
ModuleObject
*
>
module
;
uint32_t
varStart
;
uint32_t
letStart
;
uint32_t
constStart
;
uint32_t
length
;
uint32_t
nextFrameSlot
;
BindingName
names
[
1
]
;
void
trace
(
JSTracer
*
trc
)
;
}
;
static
size_t
sizeOfData
(
uint32_t
length
)
{
return
sizeof
(
Data
)
+
(
length
?
length
-
1
:
0
)
*
sizeof
(
BindingName
)
;
}
static
ModuleScope
*
create
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
Handle
<
ModuleObject
*
>
module
HandleScope
enclosing
)
;
private
:
static
UniquePtr
<
Data
>
copyData
(
ExclusiveContext
*
cx
Handle
<
Data
*
>
data
MutableHandleShape
envShape
)
;
Data
&
data
(
)
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
const
Data
&
data
(
)
const
{
return
*
reinterpret_cast
<
Data
*
>
(
data_
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
nextFrameSlot
;
}
ModuleObject
*
module
(
)
const
{
return
data
(
)
.
module
;
}
JSScript
*
script
(
)
const
;
static
Shape
*
getEmptyEnvironmentShape
(
ExclusiveContext
*
cx
)
;
}
;
class
BindingIter
{
protected
:
uint32_t
positionalFormalStart_
;
uint32_t
nonPositionalFormalStart_
;
uint32_t
varStart_
;
uint32_t
letStart_
;
uint32_t
constStart_
;
uint32_t
length_
;
uint32_t
index_
;
enum
Flags
:
uint8_t
{
CannotHaveSlots
=
0
CanHaveArgumentSlots
=
1
<
<
0
CanHaveFrameSlots
=
1
<
<
1
CanHaveEnvironmentSlots
=
1
<
<
2
HasFormalParameterExprs
=
1
<
<
3
IgnoreDestructuredFormalParameters
=
1
<
<
4
IsNamedLambda
=
1
<
<
5
}
;
static
const
uint8_t
CanHaveSlotsMask
=
0x7
;
uint8_t
flags_
;
uint16_t
argumentSlot_
;
uint32_t
frameSlot_
;
uint32_t
environmentSlot_
;
BindingName
*
names_
;
void
init
(
uint32_t
positionalFormalStart
uint32_t
nonPositionalFormalStart
uint32_t
varStart
uint32_t
letStart
uint32_t
constStart
uint8_t
flags
uint32_t
firstFrameSlot
uint32_t
firstEnvironmentSlot
BindingName
*
names
uint32_t
length
)
{
positionalFormalStart_
=
positionalFormalStart
;
nonPositionalFormalStart_
=
nonPositionalFormalStart
;
varStart_
=
varStart
;
letStart_
=
letStart
;
constStart_
=
constStart
;
length_
=
length
;
index_
=
0
;
flags_
=
flags
;
argumentSlot_
=
0
;
frameSlot_
=
firstFrameSlot
;
environmentSlot_
=
firstEnvironmentSlot
;
names_
=
names
;
settle
(
)
;
}
void
init
(
LexicalScope
:
:
Data
&
data
uint32_t
firstFrameSlot
uint8_t
flags
)
;
void
init
(
FunctionScope
:
:
Data
&
data
uint8_t
flags
)
;
void
init
(
VarScope
:
:
Data
&
data
uint32_t
firstFrameSlot
)
;
void
init
(
GlobalScope
:
:
Data
&
data
)
;
void
init
(
EvalScope
:
:
Data
&
data
bool
strict
)
;
void
init
(
ModuleScope
:
:
Data
&
data
)
;
bool
hasFormalParameterExprs
(
)
const
{
return
flags_
&
HasFormalParameterExprs
;
}
bool
ignoreDestructuredFormalParameters
(
)
const
{
return
flags_
&
IgnoreDestructuredFormalParameters
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
&
IsNamedLambda
;
}
void
increment
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
flags_
&
CanHaveSlotsMask
)
{
if
(
canHaveArgumentSlots
(
)
)
{
if
(
index_
<
nonPositionalFormalStart_
)
{
MOZ_ASSERT
(
index_
>
=
positionalFormalStart_
)
;
argumentSlot_
+
+
;
}
}
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
kind
(
)
!
=
BindingKind
:
:
Import
)
;
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
environmentSlot_
+
+
;
}
else
if
(
canHaveFrameSlots
(
)
)
{
if
(
index_
>
=
nonPositionalFormalStart_
|
|
(
hasFormalParameterExprs
(
)
&
&
name
(
)
)
)
frameSlot_
+
+
;
}
}
index_
+
+
;
}
void
settle
(
)
{
if
(
ignoreDestructuredFormalParameters
(
)
)
{
while
(
!
done
(
)
&
&
!
name
(
)
)
increment
(
)
;
}
}
public
:
explicit
BindingIter
(
Scope
*
scope
)
;
explicit
BindingIter
(
JSScript
*
script
)
;
BindingIter
(
LexicalScope
:
:
Data
&
data
uint32_t
firstFrameSlot
bool
isNamedLambda
)
{
init
(
data
firstFrameSlot
isNamedLambda
?
IsNamedLambda
:
0
)
;
}
BindingIter
(
FunctionScope
:
:
Data
&
data
bool
hasParameterExprs
)
{
init
(
data
IgnoreDestructuredFormalParameters
|
(
hasParameterExprs
?
HasFormalParameterExprs
:
0
)
)
;
}
BindingIter
(
VarScope
:
:
Data
&
data
uint32_t
firstFrameSlot
)
{
init
(
data
firstFrameSlot
)
;
}
explicit
BindingIter
(
GlobalScope
:
:
Data
&
data
)
{
init
(
data
)
;
}
explicit
BindingIter
(
ModuleScope
:
:
Data
&
data
)
{
init
(
data
)
;
}
BindingIter
(
EvalScope
:
:
Data
&
data
bool
strict
)
{
init
(
data
strict
)
;
}
explicit
BindingIter
(
const
BindingIter
&
bi
)
=
default
;
bool
done
(
)
const
{
return
index_
=
=
length_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
increment
(
)
;
settle
(
)
;
}
bool
isLast
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
index_
+
1
=
=
length_
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
flags_
&
CanHaveArgumentSlots
;
}
bool
canHaveFrameSlots
(
)
const
{
return
flags_
&
CanHaveFrameSlots
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
flags_
&
CanHaveEnvironmentSlots
;
}
JSAtom
*
name
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
name
(
)
;
}
bool
closedOver
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
(
flags_
&
CanHaveSlotsMask
)
)
return
BindingLocation
:
:
Global
(
)
;
if
(
index_
<
positionalFormalStart_
)
return
BindingLocation
:
:
Import
(
)
;
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
BindingLocation
:
:
Environment
(
environmentSlot_
)
;
}
if
(
index_
<
nonPositionalFormalStart_
&
&
canHaveArgumentSlots
(
)
)
return
BindingLocation
:
:
Argument
(
argumentSlot_
)
;
if
(
canHaveFrameSlots
(
)
)
return
BindingLocation
:
:
Frame
(
frameSlot_
)
;
MOZ_ASSERT
(
isNamedLambda
(
)
)
;
return
BindingLocation
:
:
NamedLambdaCallee
(
)
;
}
BindingKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
index_
<
positionalFormalStart_
)
return
BindingKind
:
:
Import
;
if
(
index_
<
varStart_
)
{
if
(
hasFormalParameterExprs
(
)
)
return
BindingKind
:
:
Let
;
return
BindingKind
:
:
FormalParameter
;
}
if
(
index_
<
letStart_
)
return
BindingKind
:
:
Var
;
if
(
index_
<
constStart_
)
return
BindingKind
:
:
Let
;
if
(
isNamedLambda
(
)
)
return
BindingKind
:
:
NamedLambdaCallee
;
return
BindingKind
:
:
Const
;
}
bool
hasArgumentSlot
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
hasFormalParameterExprs
(
)
)
return
false
;
return
index_
>
=
positionalFormalStart_
&
&
index_
<
nonPositionalFormalStart_
;
}
uint16_t
argumentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveArgumentSlots
(
)
)
;
return
mozilla
:
:
AssertedCast
<
uint16_t
>
(
index_
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
MOZ_ASSERT
(
canHaveFrameSlots
(
)
)
;
return
frameSlot_
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
environmentSlot_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
void
DumpBindings
(
JSContext
*
cx
Scope
*
scope
)
;
JSAtom
*
FrameSlotName
(
JSScript
*
script
jsbytecode
*
pc
)
;
class
PositionalFormalParameterIter
:
public
BindingIter
{
void
settle
(
)
{
if
(
index_
>
=
nonPositionalFormalStart_
)
index_
=
length_
;
}
public
:
explicit
PositionalFormalParameterIter
(
JSScript
*
script
)
;
void
operator
+
+
(
int
)
{
BindingIter
:
:
operator
+
+
(
1
)
;
settle
(
)
;
}
bool
isDestructured
(
)
const
{
return
!
name
(
)
;
}
}
;
class
MOZ_STACK_CLASS
ScopeIter
{
Scope
*
scope_
;
public
:
explicit
ScopeIter
(
Scope
*
scope
)
:
scope_
(
scope
)
{
}
explicit
ScopeIter
(
JSScript
*
script
)
;
explicit
ScopeIter
(
const
ScopeIter
&
si
)
:
scope_
(
si
.
scope_
)
{
}
bool
done
(
)
const
{
return
!
scope_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
scope_
=
scope_
-
>
enclosing
(
)
;
}
Scope
*
scope
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
;
}
ScopeKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
-
>
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
scope
(
)
-
>
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
;
void
trace
(
JSTracer
*
trc
)
{
if
(
scope_
)
TraceRoot
(
trc
&
scope_
"
scope
iter
scope
"
)
;
}
}
;
template
<
typename
Outer
>
class
BindingIterOperations
{
const
BindingIter
&
iter
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
bool
isLast
(
)
const
{
return
iter
(
)
.
isLast
(
)
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
iter
(
)
.
canHaveArgumentSlots
(
)
;
}
bool
canHaveFrameSlots
(
)
const
{
return
iter
(
)
.
canHaveFrameSlots
(
)
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
iter
(
)
.
canHaveEnvironmentSlots
(
)
;
}
JSAtom
*
name
(
)
const
{
return
iter
(
)
.
name
(
)
;
}
bool
closedOver
(
)
const
{
return
iter
(
)
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
return
iter
(
)
.
location
(
)
;
}
BindingKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
bool
hasArgumentSlot
(
)
const
{
return
iter
(
)
.
hasArgumentSlot
(
)
;
}
uint16_t
argumentSlot
(
)
const
{
return
iter
(
)
.
argumentSlot
(
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
return
iter
(
)
.
nextFrameSlot
(
)
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
return
iter
(
)
.
nextEnvironmentSlot
(
)
;
}
}
;
template
<
typename
Outer
>
class
MutableBindingIterOperations
:
public
BindingIterOperations
<
Outer
>
{
BindingIter
&
iter
(
)
{
return
static_cast
<
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
template
<
typename
Outer
>
class
ScopeIterOperations
{
const
ScopeIter
&
iter
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
Scope
*
scope
(
)
const
{
return
iter
(
)
.
scope
(
)
;
}
ScopeKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
iter
(
)
.
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
{
return
iter
(
)
.
hasSyntacticEnvironment
(
)
;
}
}
;
template
<
typename
Outer
>
class
MutableScopeIterOperations
:
public
ScopeIterOperations
<
Outer
>
{
ScopeIter
&
iter
(
)
{
return
static_cast
<
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
#
define
SPECIALIZE_ROOTING_CONTAINERS
(
Iter
BaseIter
)
\
template
<
>
\
class
RootedBase
<
Iter
>
\
:
public
Mutable
#
#
BaseIter
#
#
Operations
<
JS
:
:
Rooted
<
Iter
>
>
\
{
}
;
\
\
template
<
>
\
class
MutableHandleBase
<
Iter
>
\
:
public
Mutable
#
#
BaseIter
#
#
Operations
<
JS
:
:
MutableHandle
<
Iter
>
>
\
{
}
;
\
\
template
<
>
\
class
HandleBase
<
Iter
>
\
:
public
BaseIter
#
#
Operations
<
JS
:
:
Handle
<
Iter
>
>
\
{
}
;
\
\
template
<
>
\
class
PersistentRootedBase
<
Iter
>
\
:
public
Mutable
#
#
BaseIter
#
#
Operations
<
JS
:
:
PersistentRooted
<
Iter
>
>
\
{
}
SPECIALIZE_ROOTING_CONTAINERS
(
BindingIter
BindingIter
)
;
SPECIALIZE_ROOTING_CONTAINERS
(
PositionalFormalParameterIter
BindingIter
)
;
SPECIALIZE_ROOTING_CONTAINERS
(
ScopeIter
ScopeIter
)
;
#
undef
SPECIALIZE_ROOTING_CONTAINERS
template
<
typename
Outer
>
struct
ScopeCastOperation
{
template
<
class
U
>
JS
:
:
Handle
<
U
*
>
as
(
)
const
{
const
Outer
&
self
=
*
static_cast
<
const
Outer
*
>
(
this
)
;
MOZ_ASSERT_IF
(
self
self
-
>
template
is
<
U
>
(
)
)
;
return
Handle
<
U
*
>
:
:
fromMarkedLocation
(
reinterpret_cast
<
U
*
const
*
>
(
self
.
address
(
)
)
)
;
}
}
;
template
<
>
class
RootedBase
<
Scope
*
>
:
public
ScopeCastOperation
<
JS
:
:
Rooted
<
Scope
*
>
>
{
}
;
template
<
>
class
HandleBase
<
Scope
*
>
:
public
ScopeCastOperation
<
JS
:
:
Handle
<
Scope
*
>
>
{
}
;
template
<
>
class
MutableHandleBase
<
Scope
*
>
:
public
ScopeCastOperation
<
JS
:
:
MutableHandle
<
Scope
*
>
>
{
}
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
ScopeKind
>
:
public
IgnoreGCPolicy
<
js
:
:
ScopeKind
>
{
}
;
template
<
typename
T
>
struct
ScopeDataGCPolicy
{
static
T
initial
(
)
{
return
nullptr
;
}
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
if
(
*
vp
)
(
*
vp
)
-
>
trace
(
trc
)
;
}
}
;
#
define
DEFINE_SCOPE_DATA_GCPOLICY
(
Data
)
\
template
<
>
\
struct
MapTypeToRootKind
<
Data
*
>
{
\
static
const
RootKind
kind
=
RootKind
:
:
Traceable
;
\
}
;
\
template
<
>
\
struct
GCPolicy
<
Data
*
>
:
public
ScopeDataGCPolicy
<
Data
*
>
\
{
}
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
LexicalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
FunctionScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
VarScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
GlobalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
EvalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
ModuleScope
:
:
Data
)
;
#
undef
DEFINE_SCOPE_DATA_GCPOLICY
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
Scope
>
:
TracerConcrete
<
js
:
:
Scope
>
{
protected
:
explicit
Concrete
(
js
:
:
Scope
*
ptr
)
:
TracerConcrete
<
js
:
:
Scope
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
Scope
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
