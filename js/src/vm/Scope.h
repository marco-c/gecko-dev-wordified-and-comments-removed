#
ifndef
vm_Scope_h
#
define
vm_Scope_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
class
JSAtom
;
class
JSFunction
;
class
JSScript
;
class
JSTracer
;
struct
JSContext
;
namespace
JS
{
class
Zone
;
}
namespace
js
{
class
GenericPrinter
;
namespace
frontend
{
struct
CompilationAtomCache
;
class
ScopeStencil
;
struct
ScopeStencilRef
;
}
template
<
typename
NameT
>
class
AbstractBaseScopeData
;
template
<
typename
NameT
>
class
BaseAbstractBindingIter
;
template
<
typename
NameT
>
class
AbstractBindingIter
;
using
BindingIter
=
AbstractBindingIter
<
JSAtom
>
;
class
AbstractScopePtr
;
static
inline
bool
ScopeKindIsCatch
(
ScopeKind
kind
)
{
return
kind
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind
=
=
ScopeKind
:
:
Catch
;
}
static
inline
bool
ScopeKindIsInBody
(
ScopeKind
kind
)
{
return
kind
=
=
ScopeKind
:
:
Lexical
|
|
kind
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind
=
=
ScopeKind
:
:
Catch
|
|
kind
=
=
ScopeKind
:
:
With
|
|
kind
=
=
ScopeKind
:
:
FunctionLexical
|
|
kind
=
=
ScopeKind
:
:
FunctionBodyVar
|
|
kind
=
=
ScopeKind
:
:
ClassBody
;
}
const
char
*
BindingKindString
(
BindingKind
kind
)
;
const
char
*
ScopeKindString
(
ScopeKind
kind
)
;
template
<
typename
NameT
>
class
AbstractBindingName
;
template
<
>
class
AbstractBindingName
<
JSAtom
>
{
public
:
using
NameT
=
JSAtom
;
using
NamePointerT
=
NameT
*
;
private
:
uintptr_t
bits_
;
static
constexpr
uintptr_t
ClosedOverFlag
=
0x1
;
static
constexpr
uintptr_t
TopLevelFunctionFlag
=
0x2
;
static
constexpr
uintptr_t
FlagMask
=
0x3
;
public
:
AbstractBindingName
(
)
:
bits_
(
0
)
{
}
AbstractBindingName
(
NameT
*
name
bool
closedOver
bool
isTopLevelFunction
=
false
)
:
bits_
(
uintptr_t
(
name
)
|
(
closedOver
?
ClosedOverFlag
:
0x0
)
|
(
isTopLevelFunction
?
TopLevelFunctionFlag
:
0x0
)
)
{
}
NamePointerT
name
(
)
const
{
return
reinterpret_cast
<
NameT
*
>
(
bits_
&
~
FlagMask
)
;
}
bool
closedOver
(
)
const
{
return
bits_
&
ClosedOverFlag
;
}
private
:
friend
class
BaseAbstractBindingIter
<
NameT
>
;
bool
isTopLevelFunction
(
)
const
{
return
bits_
&
TopLevelFunctionFlag
;
}
public
:
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
class
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
{
uint32_t
bits_
;
using
TaggedParserAtomIndex
=
frontend
:
:
TaggedParserAtomIndex
;
public
:
using
NameT
=
TaggedParserAtomIndex
;
using
NamePointerT
=
NameT
;
private
:
static
constexpr
size_t
TaggedIndexBit
=
TaggedParserAtomIndex
:
:
IndexBit
+
2
;
static
constexpr
size_t
FlagShift
=
TaggedIndexBit
;
static
constexpr
size_t
FlagBit
=
2
;
static
constexpr
uint32_t
FlagMask
=
BitMask
(
FlagBit
)
<
<
FlagShift
;
static
constexpr
uint32_t
ClosedOverFlag
=
1
<
<
FlagShift
;
static
constexpr
uint32_t
TopLevelFunctionFlag
=
2
<
<
FlagShift
;
public
:
AbstractBindingName
(
)
:
bits_
(
TaggedParserAtomIndex
:
:
NullTag
)
{
static_assert
(
(
TaggedParserAtomIndex
:
:
NullTag
&
FlagMask
)
=
=
0
)
;
static_assert
(
(
TaggedParserAtomIndex
:
:
ParserAtomIndexTag
&
FlagMask
)
=
=
0
)
;
static_assert
(
(
TaggedParserAtomIndex
:
:
WellKnownTag
&
FlagMask
)
=
=
0
)
;
}
AbstractBindingName
(
TaggedParserAtomIndex
name
bool
closedOver
bool
isTopLevelFunction
=
false
)
:
bits_
(
name
.
rawData
(
)
|
(
closedOver
?
ClosedOverFlag
:
0x0
)
|
(
isTopLevelFunction
?
TopLevelFunctionFlag
:
0x0
)
)
{
}
public
:
NamePointerT
name
(
)
const
{
return
TaggedParserAtomIndex
:
:
fromRaw
(
bits_
&
~
FlagMask
)
;
}
bool
closedOver
(
)
const
{
return
bits_
&
ClosedOverFlag
;
}
AbstractBindingName
<
JSAtom
>
copyWithNewAtom
(
JSAtom
*
newName
)
const
{
return
AbstractBindingName
<
JSAtom
>
(
newName
closedOver
(
)
isTopLevelFunction
(
)
)
;
}
void
updateNameAfterStencilMerge
(
TaggedParserAtomIndex
name
)
{
bits_
=
(
bits_
&
FlagMask
)
|
name
.
rawData
(
)
;
}
private
:
friend
class
BaseAbstractBindingIter
<
TaggedParserAtomIndex
>
;
friend
class
frontend
:
:
ScopeStencil
;
bool
isTopLevelFunction
(
)
const
{
return
bits_
&
TopLevelFunctionFlag
;
}
}
;
using
BindingName
=
AbstractBindingName
<
JSAtom
>
;
const
size_t
ScopeDataAlignBytes
=
size_t
(
1
)
<
<
gc
:
:
CellFlagBitsReservedForGC
;
template
<
typename
NameT
>
class
AbstractBaseScopeData
{
public
:
using
NameType
=
NameT
;
uint32_t
length
=
0
;
}
;
template
<
typename
ScopeDataT
>
static
inline
void
AssertDerivedScopeData
(
)
{
static_assert
(
!
std
:
:
is_same_v
<
ScopeDataT
AbstractBaseScopeData
<
typename
ScopeDataT
:
:
NameType
>
>
"
ScopeDataT
shouldn
'
t
be
AbstractBaseScopeData
"
)
;
static_assert
(
std
:
:
is_base_of_v
<
AbstractBaseScopeData
<
typename
ScopeDataT
:
:
NameType
>
ScopeDataT
>
"
ScopeDataT
should
be
subclass
of
AbstractBaseScopeData
"
)
;
}
template
<
typename
ScopeDataT
>
static
inline
size_t
GetOffsetOfScopeDataTrailingNames
(
)
{
AssertDerivedScopeData
<
ScopeDataT
>
(
)
;
return
sizeof
(
ScopeDataT
)
;
}
template
<
typename
ScopeDataT
>
static
inline
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
*
GetScopeDataTrailingNamesPointer
(
ScopeDataT
*
data
)
{
AssertDerivedScopeData
<
ScopeDataT
>
(
)
;
return
reinterpret_cast
<
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
*
>
(
data
+
1
)
;
}
template
<
typename
ScopeDataT
>
static
inline
const
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
*
GetScopeDataTrailingNamesPointer
(
const
ScopeDataT
*
data
)
{
AssertDerivedScopeData
<
ScopeDataT
>
(
)
;
return
reinterpret_cast
<
const
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
*
>
(
data
+
1
)
;
}
template
<
typename
ScopeDataT
>
static
inline
mozilla
:
:
Span
<
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
>
GetScopeDataTrailingNames
(
ScopeDataT
*
data
)
{
return
mozilla
:
:
Span
(
GetScopeDataTrailingNamesPointer
(
data
)
data
-
>
length
)
;
}
template
<
typename
ScopeDataT
>
static
inline
mozilla
:
:
Span
<
const
AbstractBindingName
<
typename
ScopeDataT
:
:
NameType
>
>
GetScopeDataTrailingNames
(
const
ScopeDataT
*
data
)
{
return
mozilla
:
:
Span
(
GetScopeDataTrailingNamesPointer
(
data
)
data
-
>
length
)
;
}
using
BaseScopeData
=
AbstractBaseScopeData
<
JSAtom
>
;
inline
void
PoisonNames
(
AbstractBindingName
<
JSAtom
>
*
data
uint32_t
length
)
{
AlwaysPoison
(
data
JS_SCOPE_DATA_TRAILING_NAMES_PATTERN
sizeof
(
AbstractBindingName
<
JSAtom
>
)
*
length
MemCheckKind
:
:
MakeUndefined
)
;
}
inline
void
PoisonNames
(
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
*
data
uint32_t
length
)
{
std
:
:
fill_n
(
data
length
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
(
)
)
;
}
template
<
typename
ScopeDataT
>
static
inline
void
PoisonNames
(
ScopeDataT
*
data
uint32_t
length
)
{
if
(
length
)
{
PoisonNames
(
GetScopeDataTrailingNamesPointer
(
data
)
length
)
;
}
}
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
Scope
*
Wrapper
>
{
public
:
template
<
class
U
>
JS
:
:
Handle
<
U
*
>
as
(
)
const
{
const
Wrapper
&
self
=
*
static_cast
<
const
Wrapper
*
>
(
this
)
;
MOZ_ASSERT_IF
(
self
self
-
>
template
is
<
U
>
(
)
)
;
return
Handle
<
U
*
>
:
:
fromMarkedLocation
(
reinterpret_cast
<
U
*
const
*
>
(
self
.
address
(
)
)
)
;
}
}
;
class
Scope
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
BaseScopeData
>
{
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
friend
class
js
:
:
AbstractBindingIter
<
JSAtom
>
;
protected
:
BaseScopeData
*
rawData
(
)
{
return
headerPtr
(
)
;
}
const
BaseScopeData
*
rawData
(
)
const
{
return
headerPtr
(
)
;
}
const
ScopeKind
kind_
;
const
HeapPtr
<
Shape
*
>
environmentShape_
;
HeapPtr
<
Scope
*
>
enclosingScope_
;
Scope
(
ScopeKind
kind
Scope
*
enclosing
Shape
*
environmentShape
)
:
TenuredCellWithNonGCPointer
(
nullptr
)
kind_
(
kind
)
environmentShape_
(
environmentShape
)
enclosingScope_
(
enclosing
)
{
}
static
Scope
*
create
(
JSContext
*
cx
ScopeKind
kind
HandleScope
enclosing
Handle
<
Shape
*
>
envShape
)
;
template
<
typename
ConcreteScope
>
void
initData
(
MutableHandle
<
UniquePtr
<
typename
ConcreteScope
:
:
RuntimeData
>
>
data
)
;
template
<
typename
F
>
void
applyScopeDataTyped
(
F
&
&
f
)
;
static
void
updateEnvShapeIfRequired
(
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
bool
needsEnvironment
)
;
public
:
template
<
typename
ConcreteScope
>
static
ConcreteScope
*
create
(
JSContext
*
cx
ScopeKind
kind
HandleScope
enclosing
Handle
<
Shape
*
>
envShape
MutableHandle
<
UniquePtr
<
typename
ConcreteScope
:
:
RuntimeData
>
>
data
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Scope
;
template
<
typename
T
>
bool
is
(
)
const
{
return
kind_
=
=
T
:
:
classScopeKind_
;
}
template
<
typename
T
>
T
&
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
T
*
>
(
this
)
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
ScopeKind
kind
(
)
const
{
return
kind_
;
}
bool
isNamedLambda
(
)
const
{
return
kind
(
)
=
=
ScopeKind
:
:
NamedLambda
|
|
kind
(
)
=
=
ScopeKind
:
:
StrictNamedLambda
;
}
Shape
*
environmentShape
(
)
const
{
return
environmentShape_
;
}
Scope
*
enclosing
(
)
const
{
return
enclosingScope_
;
}
static
bool
hasEnvironment
(
ScopeKind
kind
bool
hasEnvironmentShape
=
false
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
With
:
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
true
;
default
:
return
hasEnvironmentShape
;
}
}
bool
hasEnvironment
(
)
const
{
return
hasEnvironment
(
kind_
!
!
environmentShape
(
)
)
;
}
uint32_t
firstFrameSlot
(
)
const
;
uint32_t
chainLength
(
)
const
;
uint32_t
environmentChainLength
(
)
const
;
template
<
typename
T
>
bool
hasOnChain
(
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
is
<
T
>
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
hasOnChain
(
ScopeKind
kind
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
kind
(
)
=
=
kind
)
{
return
true
;
}
}
return
false
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
dump
(
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
static
bool
dumpForDisassemble
(
JSContext
*
cx
JS
:
:
Handle
<
Scope
*
>
scope
GenericPrinter
&
out
const
char
*
indent
)
;
#
endif
}
;
template
<
class
DataT
>
inline
size_t
SizeOfScopeData
(
uint32_t
length
)
{
using
BindingT
=
AbstractBindingName
<
typename
DataT
:
:
NameType
>
;
return
GetOffsetOfScopeDataTrailingNames
<
DataT
>
(
)
+
length
*
sizeof
(
BindingT
)
;
}
template
<
typename
ScopeT
typename
AtomT
>
using
AbstractScopeData
=
typename
ScopeT
:
:
template
AbstractData
<
AtomT
>
;
template
<
typename
SlotInfo
>
struct
alignas
(
alignof
(
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
)
)
ParserScopeData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
explicit
ParserScopeData
(
size_t
length
)
{
PoisonNames
(
this
length
)
;
}
ParserScopeData
(
)
=
delete
;
}
;
static_assert
(
alignof
(
BindingName
)
<
=
ScopeDataAlignBytes
)
;
template
<
typename
SlotInfo
>
struct
alignas
(
ScopeDataAlignBytes
)
RuntimeScopeData
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
explicit
RuntimeScopeData
(
size_t
length
)
{
PoisonNames
(
this
length
)
;
}
RuntimeScopeData
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
class
LexicalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
constStart
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
private
:
static
void
prepareForScopeCreation
(
ScopeKind
kind
uint32_t
firstFrameSlot
LexicalScope
:
:
ParserData
*
data
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
static
uint32_t
nextFrameSlot
(
Scope
*
scope
)
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
static
Shape
*
getEmptyExtensibleEnvironmentShape
(
JSContext
*
cx
)
;
}
;
template
<
>
inline
bool
Scope
:
:
is
<
LexicalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Lexical
|
|
kind_
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind_
=
=
ScopeKind
:
:
Catch
|
|
kind_
=
=
ScopeKind
:
:
NamedLambda
|
|
kind_
=
=
ScopeKind
:
:
StrictNamedLambda
|
|
kind_
=
=
ScopeKind
:
:
FunctionLexical
;
}
class
ClassBodyScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
ClassBody
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
privateMethodStart
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
private
:
static
void
prepareForScopeCreation
(
ScopeKind
kind
uint32_t
firstFrameSlot
ClassBodyScope
:
:
ParserData
*
data
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
static
uint32_t
nextFrameSlot
(
Scope
*
scope
)
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
static
Shape
*
getEmptyExtensibleEnvironmentShape
(
JSContext
*
cx
)
;
}
;
class
FunctionScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
PositionalFormalParameterIter
;
friend
class
Scope
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Function
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
flags
=
0
;
static
constexpr
uint32_t
HasParameterExprsFlag
=
1
;
uint16_t
nonPositionalFormalStart
=
0
;
uint16_t
varStart
=
0
;
bool
hasParameterExprs
(
)
const
{
return
flags
&
HasParameterExprsFlag
;
}
void
setHasParameterExprs
(
)
{
flags
|
=
HasParameterExprsFlag
;
}
}
;
struct
alignas
(
ScopeDataAlignBytes
)
RuntimeData
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
HeapPtr
<
JSFunction
*
>
canonicalFunction
=
{
}
;
explicit
RuntimeData
(
size_t
length
)
{
PoisonNames
(
this
length
)
;
}
RuntimeData
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
static
void
prepareForScopeCreation
(
FunctionScope
:
:
ParserData
*
data
bool
hasParameterExprs
bool
needsEnvironment
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
private
:
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
JSFunction
*
canonicalFunction
(
)
const
{
return
data
(
)
.
canonicalFunction
;
}
void
initCanonicalFunction
(
JSFunction
*
fun
)
{
data
(
)
.
canonicalFunction
.
init
(
fun
)
;
}
JSScript
*
script
(
)
const
;
bool
hasParameterExprs
(
)
const
{
return
data
(
)
.
slotInfo
.
hasParameterExprs
(
)
;
}
uint32_t
numPositionalFormalParameters
(
)
const
{
return
data
(
)
.
slotInfo
.
nonPositionalFormalStart
;
}
static
bool
isSpecialName
(
JSContext
*
cx
frontend
:
:
TaggedParserAtomIndex
name
)
;
}
;
class
VarScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
private
:
static
void
prepareForScopeCreation
(
ScopeKind
kind
VarScope
:
:
ParserData
*
data
uint32_t
firstFrameSlot
bool
needsEnvironment
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
VarScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
FunctionBodyVar
;
}
class
GlobalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
public
:
struct
SlotInfo
{
uint32_t
letStart
=
0
;
uint32_t
constStart
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
static
GlobalScope
*
createEmpty
(
JSContext
*
cx
ScopeKind
kind
)
;
private
:
static
GlobalScope
*
createWithData
(
JSContext
*
cx
ScopeKind
kind
MutableHandle
<
UniquePtr
<
RuntimeData
>
>
data
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
bool
isSyntactic
(
)
const
{
return
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
length
>
0
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
GlobalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Global
|
|
kind_
=
=
ScopeKind
:
:
NonSyntactic
;
}
class
WithScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
With
;
public
:
static
WithScope
*
create
(
JSContext
*
cx
HandleScope
enclosing
)
;
}
;
class
EvalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
private
:
static
void
prepareForScopeCreation
(
ScopeKind
scopeKind
EvalScope
:
:
ParserData
*
data
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
static
Scope
*
nearestVarScopeForDirectEval
(
Scope
*
scope
)
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
bool
strict
(
)
const
{
return
kind
(
)
=
=
ScopeKind
:
:
StrictEval
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
length
>
0
;
}
bool
isNonGlobal
(
)
const
{
if
(
strict
(
)
)
{
return
true
;
}
return
!
nearestVarScopeForDirectEval
(
enclosing
(
)
)
-
>
is
<
GlobalScope
>
(
)
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
EvalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Eval
|
|
kind_
=
=
ScopeKind
:
:
StrictEval
;
}
class
ModuleScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
AbstractScopePtr
;
friend
class
frontend
:
:
ScopeStencil
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Module
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
varStart
=
0
;
uint32_t
letStart
=
0
;
uint32_t
constStart
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
RuntimeData
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
HeapPtr
<
ModuleObject
*
>
module
=
{
}
;
explicit
RuntimeData
(
size_t
length
)
;
RuntimeData
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
private
:
static
void
prepareForScopeCreation
(
ModuleScope
:
:
ParserData
*
data
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
)
;
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
ModuleObject
*
module
(
)
const
{
return
data
(
)
.
module
;
}
void
initModule
(
ModuleObject
*
mod
)
{
return
data
(
)
.
module
.
init
(
mod
)
;
}
static
const
size_t
EnclosingEnvironmentChainLength
=
1
;
}
;
class
WasmInstanceScope
:
public
Scope
{
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
GCMarker
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
WasmInstance
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
globalsStart
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
RuntimeData
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
HeapPtr
<
WasmInstanceObject
*
>
instance
=
{
}
;
explicit
RuntimeData
(
size_t
length
)
;
RuntimeData
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
static
WasmInstanceScope
*
create
(
JSContext
*
cx
WasmInstanceObject
*
instance
)
;
private
:
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
public
:
WasmInstanceObject
*
instance
(
)
const
{
return
data
(
)
.
instance
;
}
uint32_t
memoriesStart
(
)
const
{
return
0
;
}
uint32_t
globalsStart
(
)
const
{
return
data
(
)
.
slotInfo
.
globalsStart
;
}
uint32_t
namesCount
(
)
const
{
return
data
(
)
.
length
;
}
}
;
class
WasmFunctionScope
:
public
Scope
{
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
GCMarker
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
WasmFunction
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
}
;
using
RuntimeData
=
RuntimeScopeData
<
SlotInfo
>
;
using
ParserData
=
ParserScopeData
<
SlotInfo
>
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
RuntimeData
ParserData
>
;
static
WasmFunctionScope
*
create
(
JSContext
*
cx
HandleScope
enclosing
uint32_t
funcIndex
)
;
private
:
RuntimeData
&
data
(
)
{
return
*
static_cast
<
RuntimeData
*
>
(
rawData
(
)
)
;
}
const
RuntimeData
&
data
(
)
const
{
return
*
static_cast
<
const
RuntimeData
*
>
(
rawData
(
)
)
;
}
}
;
template
<
typename
F
>
void
Scope
:
:
applyScopeDataTyped
(
F
&
&
f
)
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
{
f
(
&
as
<
FunctionScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
FunctionBodyVar
:
f
(
&
as
<
VarScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
f
(
&
as
<
LexicalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
ClassBody
:
f
(
&
as
<
ClassBodyScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
With
:
break
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
f
(
&
as
<
EvalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
f
(
&
as
<
GlobalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Module
:
f
(
&
as
<
ModuleScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
WasmInstance
:
f
(
&
as
<
WasmInstanceScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
WasmFunction
:
f
(
&
as
<
WasmFunctionScope
>
(
)
.
data
(
)
)
;
break
;
}
}
}
template
<
typename
NameT
>
class
BaseAbstractBindingIter
{
protected
:
MOZ_INIT_OUTSIDE_CTOR
uint32_t
positionalFormalStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
nonPositionalFormalStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
varStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
letStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
constStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
syntheticStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
privateMethodStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
length_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
index_
;
enum
Flags
:
uint8_t
{
CannotHaveSlots
=
0
CanHaveArgumentSlots
=
1
<
<
0
CanHaveFrameSlots
=
1
<
<
1
CanHaveEnvironmentSlots
=
1
<
<
2
HasFormalParameterExprs
=
1
<
<
3
IgnoreDestructuredFormalParameters
=
1
<
<
4
IsNamedLambda
=
1
<
<
5
}
;
static
const
uint8_t
CanHaveSlotsMask
=
0x7
;
MOZ_INIT_OUTSIDE_CTOR
uint8_t
flags_
;
MOZ_INIT_OUTSIDE_CTOR
uint16_t
argumentSlot_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
frameSlot_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
environmentSlot_
;
MOZ_INIT_OUTSIDE_CTOR
AbstractBindingName
<
NameT
>
*
names_
;
void
init
(
uint32_t
positionalFormalStart
uint32_t
nonPositionalFormalStart
uint32_t
varStart
uint32_t
letStart
uint32_t
constStart
uint32_t
syntheticStart
uint32_t
privateMethodStart
uint8_t
flags
uint32_t
firstFrameSlot
uint32_t
firstEnvironmentSlot
mozilla
:
:
Span
<
AbstractBindingName
<
NameT
>
>
names
)
{
positionalFormalStart_
=
positionalFormalStart
;
nonPositionalFormalStart_
=
nonPositionalFormalStart
;
varStart_
=
varStart
;
letStart_
=
letStart
;
constStart_
=
constStart
;
syntheticStart_
=
syntheticStart
;
privateMethodStart_
=
privateMethodStart
;
length_
=
names
.
size
(
)
;
index_
=
0
;
flags_
=
flags
;
argumentSlot_
=
0
;
frameSlot_
=
firstFrameSlot
;
environmentSlot_
=
firstEnvironmentSlot
;
names_
=
names
.
data
(
)
;
settle
(
)
;
}
void
init
(
LexicalScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
uint8_t
flags
)
;
void
init
(
ClassBodyScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
;
void
init
(
FunctionScope
:
:
AbstractData
<
NameT
>
&
data
uint8_t
flags
)
;
void
init
(
VarScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
;
void
init
(
GlobalScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
EvalScope
:
:
AbstractData
<
NameT
>
&
data
bool
strict
)
;
void
init
(
ModuleScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
WasmInstanceScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
WasmFunctionScope
:
:
AbstractData
<
NameT
>
&
data
)
;
bool
hasFormalParameterExprs
(
)
const
{
return
flags_
&
HasFormalParameterExprs
;
}
bool
ignoreDestructuredFormalParameters
(
)
const
{
return
flags_
&
IgnoreDestructuredFormalParameters
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
&
IsNamedLambda
;
}
void
increment
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
flags_
&
CanHaveSlotsMask
)
{
if
(
canHaveArgumentSlots
(
)
)
{
if
(
index_
<
nonPositionalFormalStart_
)
{
MOZ_ASSERT
(
index_
>
=
positionalFormalStart_
)
;
argumentSlot_
+
+
;
}
}
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
kind
(
)
!
=
BindingKind
:
:
Import
)
;
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
environmentSlot_
+
+
;
}
else
if
(
canHaveFrameSlots
(
)
)
{
if
(
index_
>
=
nonPositionalFormalStart_
|
|
(
hasFormalParameterExprs
(
)
&
&
name
(
)
)
)
{
frameSlot_
+
+
;
}
}
}
index_
+
+
;
}
void
settle
(
)
{
if
(
ignoreDestructuredFormalParameters
(
)
)
{
while
(
!
done
(
)
&
&
!
name
(
)
)
{
increment
(
)
;
}
}
}
BaseAbstractBindingIter
(
)
=
default
;
public
:
BaseAbstractBindingIter
(
LexicalScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
bool
isNamedLambda
)
{
init
(
data
firstFrameSlot
isNamedLambda
?
IsNamedLambda
:
0
)
;
}
BaseAbstractBindingIter
(
ClassBodyScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
{
init
(
data
firstFrameSlot
)
;
}
BaseAbstractBindingIter
(
FunctionScope
:
:
AbstractData
<
NameT
>
&
data
bool
hasParameterExprs
)
{
init
(
data
IgnoreDestructuredFormalParameters
|
(
hasParameterExprs
?
HasFormalParameterExprs
:
0
)
)
;
}
BaseAbstractBindingIter
(
VarScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
{
init
(
data
firstFrameSlot
)
;
}
explicit
BaseAbstractBindingIter
(
GlobalScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
explicit
BaseAbstractBindingIter
(
ModuleScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
explicit
BaseAbstractBindingIter
(
WasmFunctionScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
BaseAbstractBindingIter
(
EvalScope
:
:
AbstractData
<
NameT
>
&
data
bool
strict
)
{
init
(
data
strict
)
;
}
MOZ_IMPLICIT
BaseAbstractBindingIter
(
const
BaseAbstractBindingIter
<
NameT
>
&
bi
)
=
default
;
bool
done
(
)
const
{
return
index_
=
=
length_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
increment
(
)
;
settle
(
)
;
}
bool
isLast
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
index_
+
1
=
=
length_
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
flags_
&
CanHaveArgumentSlots
;
}
bool
canHaveFrameSlots
(
)
const
{
return
flags_
&
CanHaveFrameSlots
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
flags_
&
CanHaveEnvironmentSlots
;
}
typename
AbstractBindingName
<
NameT
>
:
:
NamePointerT
name
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
name
(
)
;
}
bool
closedOver
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
(
flags_
&
CanHaveSlotsMask
)
)
{
return
BindingLocation
:
:
Global
(
)
;
}
if
(
index_
<
positionalFormalStart_
)
{
return
BindingLocation
:
:
Import
(
)
;
}
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
BindingLocation
:
:
Environment
(
environmentSlot_
)
;
}
if
(
index_
<
nonPositionalFormalStart_
&
&
canHaveArgumentSlots
(
)
)
{
return
BindingLocation
:
:
Argument
(
argumentSlot_
)
;
}
if
(
canHaveFrameSlots
(
)
)
{
return
BindingLocation
:
:
Frame
(
frameSlot_
)
;
}
MOZ_ASSERT
(
isNamedLambda
(
)
)
;
return
BindingLocation
:
:
NamedLambdaCallee
(
)
;
}
BindingKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
index_
<
positionalFormalStart_
)
{
return
BindingKind
:
:
Import
;
}
if
(
index_
<
varStart_
)
{
if
(
hasFormalParameterExprs
(
)
)
{
return
BindingKind
:
:
Let
;
}
return
BindingKind
:
:
FormalParameter
;
}
if
(
index_
<
letStart_
)
{
return
BindingKind
:
:
Var
;
}
if
(
index_
<
constStart_
)
{
return
BindingKind
:
:
Let
;
}
if
(
index_
<
syntheticStart_
)
{
return
isNamedLambda
(
)
?
BindingKind
:
:
NamedLambdaCallee
:
BindingKind
:
:
Const
;
}
if
(
index_
<
privateMethodStart_
)
{
return
BindingKind
:
:
Synthetic
;
}
return
BindingKind
:
:
PrivateMethod
;
}
js
:
:
frontend
:
:
NameLocation
nameLocation
(
)
const
{
using
js
:
:
frontend
:
:
NameLocation
;
BindingKind
bindKind
=
kind
(
)
;
BindingLocation
bl
=
location
(
)
;
switch
(
bl
.
kind
(
)
)
{
case
BindingLocation
:
:
Kind
:
:
Global
:
return
NameLocation
:
:
Global
(
bindKind
)
;
case
BindingLocation
:
:
Kind
:
:
Argument
:
return
NameLocation
:
:
ArgumentSlot
(
bl
.
argumentSlot
(
)
)
;
case
BindingLocation
:
:
Kind
:
:
Frame
:
return
NameLocation
:
:
FrameSlot
(
bindKind
bl
.
slot
(
)
)
;
case
BindingLocation
:
:
Kind
:
:
Environment
:
return
NameLocation
:
:
EnvironmentCoordinate
(
bindKind
0
bl
.
slot
(
)
)
;
case
BindingLocation
:
:
Kind
:
:
Import
:
return
NameLocation
:
:
Import
(
)
;
case
BindingLocation
:
:
Kind
:
:
NamedLambdaCallee
:
return
NameLocation
:
:
NamedLambdaCallee
(
)
;
}
MOZ_CRASH
(
"
Bad
BindingKind
"
)
;
}
bool
isTopLevelFunction
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
bool
result
=
names_
[
index_
]
.
isTopLevelFunction
(
)
;
MOZ_ASSERT_IF
(
result
kind
(
)
=
=
BindingKind
:
:
Var
)
;
return
result
;
}
bool
hasArgumentSlot
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
hasFormalParameterExprs
(
)
)
{
return
false
;
}
return
index_
>
=
positionalFormalStart_
&
&
index_
<
nonPositionalFormalStart_
;
}
uint16_t
argumentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveArgumentSlots
(
)
)
;
return
mozilla
:
:
AssertedCast
<
uint16_t
>
(
index_
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
MOZ_ASSERT
(
canHaveFrameSlots
(
)
)
;
return
frameSlot_
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
environmentSlot_
;
}
}
;
template
<
typename
NameT
>
class
AbstractBindingIter
;
template
<
>
class
AbstractBindingIter
<
JSAtom
>
:
public
BaseAbstractBindingIter
<
JSAtom
>
{
using
Base
=
BaseAbstractBindingIter
<
JSAtom
>
;
public
:
AbstractBindingIter
(
ScopeKind
kind
BaseScopeData
*
data
uint32_t
firstFrameSlot
)
;
explicit
AbstractBindingIter
(
Scope
*
scope
)
;
explicit
AbstractBindingIter
(
JSScript
*
script
)
;
using
Base
:
:
Base
;
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
class
AbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
:
public
BaseAbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
{
using
Base
=
BaseAbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
;
public
:
explicit
AbstractBindingIter
(
const
frontend
:
:
ScopeStencilRef
&
ref
)
;
using
Base
:
:
Base
;
}
;
void
DumpBindings
(
JSContext
*
cx
Scope
*
scope
)
;
JSAtom
*
FrameSlotName
(
JSScript
*
script
jsbytecode
*
pc
)
;
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
const
JSClass
*
cls
uint32_t
numSlots
ObjectFlags
objectFlags
)
;
template
<
class
T
>
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
)
{
return
EmptyEnvironmentShape
(
cx
&
T
:
:
class_
T
:
:
RESERVED_SLOTS
T
:
:
OBJECT_FLAGS
)
;
}
class
PositionalFormalParameterIter
:
public
BindingIter
{
void
settle
(
)
{
if
(
index_
>
=
nonPositionalFormalStart_
)
{
index_
=
length_
;
}
}
public
:
explicit
PositionalFormalParameterIter
(
Scope
*
scope
)
;
explicit
PositionalFormalParameterIter
(
JSScript
*
script
)
;
void
operator
+
+
(
int
)
{
BindingIter
:
:
operator
+
+
(
1
)
;
settle
(
)
;
}
bool
isDestructured
(
)
const
{
return
!
name
(
)
;
}
}
;
class
MOZ_STACK_CLASS
ScopeIter
{
Scope
*
scope_
;
public
:
explicit
ScopeIter
(
Scope
*
scope
)
:
scope_
(
scope
)
{
}
explicit
ScopeIter
(
JSScript
*
script
)
;
explicit
ScopeIter
(
const
ScopeIter
&
si
)
=
default
;
bool
done
(
)
const
{
return
!
scope_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
scope_
=
scope_
-
>
enclosing
(
)
;
}
Scope
*
scope
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
;
}
ScopeKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
-
>
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
scope
(
)
-
>
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
;
void
trace
(
JSTracer
*
trc
)
{
if
(
scope_
)
{
TraceRoot
(
trc
&
scope_
"
scope
iter
scope
"
)
;
}
}
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
BindingIter
Wrapper
>
{
const
BindingIter
&
iter
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
bool
isLast
(
)
const
{
return
iter
(
)
.
isLast
(
)
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
iter
(
)
.
canHaveArgumentSlots
(
)
;
}
bool
canHaveFrameSlots
(
)
const
{
return
iter
(
)
.
canHaveFrameSlots
(
)
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
iter
(
)
.
canHaveEnvironmentSlots
(
)
;
}
JSAtom
*
name
(
)
const
{
return
iter
(
)
.
name
(
)
;
}
bool
closedOver
(
)
const
{
return
iter
(
)
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
return
iter
(
)
.
location
(
)
;
}
BindingKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
bool
isTopLevelFunction
(
)
const
{
return
iter
(
)
.
isTopLevelFunction
(
)
;
}
bool
hasArgumentSlot
(
)
const
{
return
iter
(
)
.
hasArgumentSlot
(
)
;
}
uint16_t
argumentSlot
(
)
const
{
return
iter
(
)
.
argumentSlot
(
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
return
iter
(
)
.
nextFrameSlot
(
)
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
return
iter
(
)
.
nextEnvironmentSlot
(
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
BindingIter
Wrapper
>
:
public
WrappedPtrOperations
<
BindingIter
Wrapper
>
{
BindingIter
&
iter
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
ScopeIter
Wrapper
>
{
const
ScopeIter
&
iter
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
Scope
*
scope
(
)
const
{
return
iter
(
)
.
scope
(
)
;
}
ScopeKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
iter
(
)
.
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
{
return
iter
(
)
.
hasSyntacticEnvironment
(
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
ScopeIter
Wrapper
>
:
public
WrappedPtrOperations
<
ScopeIter
Wrapper
>
{
ScopeIter
&
iter
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
Shape
*
CreateEnvironmentShape
(
JSContext
*
cx
BindingIter
&
bi
const
JSClass
*
cls
uint32_t
numSlots
ObjectFlags
objectFlags
)
;
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
const
JSClass
*
cls
uint32_t
numSlots
ObjectFlags
objectFlags
)
;
static
inline
size_t
GetOffsetOfParserScopeDataTrailingNames
(
ScopeKind
kind
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
Function
:
return
GetOffsetOfScopeDataTrailingNames
<
FunctionScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
FunctionBodyVar
:
return
GetOffsetOfScopeDataTrailingNames
<
VarScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
return
GetOffsetOfScopeDataTrailingNames
<
LexicalScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
ClassBody
:
return
GetOffsetOfScopeDataTrailingNames
<
ClassBodyScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
return
GetOffsetOfScopeDataTrailingNames
<
EvalScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
GetOffsetOfScopeDataTrailingNames
<
GlobalScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
Module
:
return
GetOffsetOfScopeDataTrailingNames
<
ModuleScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
WasmInstance
:
return
GetOffsetOfScopeDataTrailingNames
<
WasmInstanceScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
WasmFunction
:
return
GetOffsetOfScopeDataTrailingNames
<
WasmFunctionScope
:
:
ParserData
>
(
)
;
case
ScopeKind
:
:
With
:
default
:
MOZ_CRASH
(
"
Unexpected
ScopeKind
"
)
;
}
return
0
;
}
inline
size_t
SizeOfParserScopeData
(
ScopeKind
kind
uint32_t
length
)
{
return
GetOffsetOfParserScopeDataTrailingNames
(
kind
)
+
sizeof
(
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
)
*
length
;
}
inline
mozilla
:
:
Span
<
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
>
GetParserScopeDataTrailingNames
(
ScopeKind
kind
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
*
data
)
{
return
mozilla
:
:
Span
(
reinterpret_cast
<
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
*
>
(
uintptr_t
(
data
)
+
GetOffsetOfParserScopeDataTrailingNames
(
kind
)
)
data
-
>
length
)
;
}
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
ScopeKind
>
:
public
IgnoreGCPolicy
<
js
:
:
ScopeKind
>
{
}
;
template
<
typename
T
>
struct
ScopeDataGCPolicy
:
public
NonGCPointerPolicy
<
T
>
{
}
;
#
define
DEFINE_SCOPE_DATA_GCPOLICY
(
Data
)
\
template
<
>
\
struct
MapTypeToRootKind
<
Data
*
>
{
\
static
const
RootKind
kind
=
RootKind
:
:
Traceable
;
\
}
;
\
template
<
>
\
struct
GCPolicy
<
Data
*
>
:
public
ScopeDataGCPolicy
<
Data
*
>
{
}
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
LexicalScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
ClassBodyScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
FunctionScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
VarScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
GlobalScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
EvalScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
ModuleScope
:
:
RuntimeData
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
WasmFunctionScope
:
:
RuntimeData
)
;
#
undef
DEFINE_SCOPE_DATA_GCPOLICY
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
Scope
>
:
TracerConcrete
<
js
:
:
Scope
>
{
protected
:
explicit
Concrete
(
js
:
:
Scope
*
ptr
)
:
TracerConcrete
<
js
:
:
Scope
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
Scope
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
