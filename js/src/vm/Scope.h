#
ifndef
vm_Scope_h
#
define
vm_Scope_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
MaybeRooted
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
Xdr
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
class
JSAtom
;
class
JSFreeOp
;
class
JSFunction
;
class
JSScript
;
class
JSTracer
;
struct
JSContext
;
namespace
JS
{
class
Zone
;
}
namespace
js
{
class
GenericPrinter
;
namespace
frontend
{
struct
CompilationAtomCache
;
class
ScopeStencil
;
class
ParserAtom
;
}
template
<
typename
NameT
>
class
AbstractBaseScopeData
;
template
<
typename
NameT
>
class
BaseAbstractBindingIter
;
template
<
typename
NameT
>
class
AbstractBindingIter
;
using
BindingIter
=
AbstractBindingIter
<
JSAtom
>
;
class
AbstractScopePtr
;
static
inline
bool
ScopeKindIsCatch
(
ScopeKind
kind
)
{
return
kind
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind
=
=
ScopeKind
:
:
Catch
;
}
static
inline
bool
ScopeKindIsInBody
(
ScopeKind
kind
)
{
return
kind
=
=
ScopeKind
:
:
Lexical
|
|
kind
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind
=
=
ScopeKind
:
:
Catch
|
|
kind
=
=
ScopeKind
:
:
With
|
|
kind
=
=
ScopeKind
:
:
FunctionLexical
|
|
kind
=
=
ScopeKind
:
:
FunctionBodyVar
|
|
kind
=
=
ScopeKind
:
:
ClassBody
;
}
const
char
*
BindingKindString
(
BindingKind
kind
)
;
const
char
*
ScopeKindString
(
ScopeKind
kind
)
;
template
<
typename
NameT
>
class
AbstractBindingName
;
template
<
>
class
AbstractBindingName
<
JSAtom
>
{
public
:
using
NameT
=
JSAtom
;
using
NamePointerT
=
NameT
*
;
private
:
uintptr_t
bits_
;
static
constexpr
uintptr_t
ClosedOverFlag
=
0x1
;
static
constexpr
uintptr_t
TopLevelFunctionFlag
=
0x2
;
static
constexpr
uintptr_t
FlagMask
=
0x3
;
public
:
AbstractBindingName
(
)
:
bits_
(
0
)
{
}
AbstractBindingName
(
NameT
*
name
bool
closedOver
bool
isTopLevelFunction
=
false
)
:
bits_
(
uintptr_t
(
name
)
|
(
closedOver
?
ClosedOverFlag
:
0x0
)
|
(
isTopLevelFunction
?
TopLevelFunctionFlag
:
0x0
)
)
{
}
private
:
AbstractBindingName
(
NameT
*
name
uint8_t
flags
)
:
bits_
(
uintptr_t
(
name
)
|
flags
)
{
static_assert
(
FlagMask
<
alignof
(
NameT
)
"
Flags
should
fit
into
unused
low
bits
of
atom
repr
"
)
;
MOZ_ASSERT
(
(
flags
&
FlagMask
)
=
=
flags
)
;
}
public
:
static
AbstractBindingName
<
NameT
>
fromXDR
(
NameT
*
name
uint8_t
flags
)
{
return
AbstractBindingName
<
NameT
>
(
name
flags
)
;
}
uint8_t
flagsForXDR
(
)
const
{
return
static_cast
<
uint8_t
>
(
bits_
&
FlagMask
)
;
}
NamePointerT
name
(
)
const
{
return
reinterpret_cast
<
NameT
*
>
(
bits_
&
~
FlagMask
)
;
}
bool
closedOver
(
)
const
{
return
bits_
&
ClosedOverFlag
;
}
private
:
friend
class
BaseAbstractBindingIter
<
NameT
>
;
bool
isTopLevelFunction
(
)
const
{
return
bits_
&
TopLevelFunctionFlag
;
}
public
:
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
class
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
{
uint32_t
bits_
;
using
TaggedParserAtomIndex
=
frontend
:
:
TaggedParserAtomIndex
;
public
:
using
NameT
=
TaggedParserAtomIndex
;
using
NamePointerT
=
NameT
;
private
:
static
constexpr
size_t
TaggedIndexBit
=
TaggedParserAtomIndex
:
:
IndexBit
+
2
;
static
constexpr
size_t
FlagShift
=
TaggedIndexBit
;
static
constexpr
size_t
FlagBit
=
2
;
static
constexpr
uint32_t
FlagMask
=
BitMask
(
FlagBit
)
<
<
FlagShift
;
static
constexpr
uint32_t
ClosedOverFlag
=
1
<
<
FlagShift
;
static
constexpr
uint32_t
TopLevelFunctionFlag
=
2
<
<
FlagShift
;
public
:
AbstractBindingName
(
)
:
bits_
(
TaggedParserAtomIndex
:
:
NullTag
)
{
static_assert
(
(
TaggedParserAtomIndex
:
:
NullTag
&
FlagMask
)
=
=
0
)
;
static_assert
(
(
TaggedParserAtomIndex
:
:
ParserAtomIndexTag
&
FlagMask
)
=
=
0
)
;
static_assert
(
(
TaggedParserAtomIndex
:
:
WellKnownTag
&
FlagMask
)
=
=
0
)
;
}
AbstractBindingName
(
TaggedParserAtomIndex
name
bool
closedOver
bool
isTopLevelFunction
=
false
)
:
bits_
(
*
name
.
rawData
(
)
|
(
closedOver
?
ClosedOverFlag
:
0x0
)
|
(
isTopLevelFunction
?
TopLevelFunctionFlag
:
0x0
)
)
{
}
public
:
uint32_t
*
rawData
(
)
{
return
&
bits_
;
}
NamePointerT
name
(
)
const
{
return
TaggedParserAtomIndex
:
:
fromRaw
(
bits_
&
~
FlagMask
)
;
}
bool
closedOver
(
)
const
{
return
bits_
&
ClosedOverFlag
;
}
AbstractBindingName
<
JSAtom
>
copyWithNewAtom
(
JSAtom
*
newName
)
const
{
return
AbstractBindingName
<
JSAtom
>
(
newName
closedOver
(
)
isTopLevelFunction
(
)
)
;
}
private
:
friend
class
BaseAbstractBindingIter
<
TaggedParserAtomIndex
>
;
friend
class
frontend
:
:
ScopeStencil
;
bool
isTopLevelFunction
(
)
const
{
return
bits_
&
TopLevelFunctionFlag
;
}
}
;
using
BindingName
=
AbstractBindingName
<
JSAtom
>
;
const
size_t
ScopeDataAlignBytes
=
size_t
(
1
)
<
<
gc
:
:
CellFlagBitsReservedForGC
;
template
<
typename
NameT
>
class
AbstractBaseScopeData
{
public
:
using
NameType
=
NameT
;
}
;
using
BaseScopeData
=
AbstractBaseScopeData
<
JSAtom
>
;
inline
void
PoisonNames
(
AbstractBindingName
<
JSAtom
>
*
data
size_t
nameCount
)
{
AlwaysPoison
(
data
JS_SCOPE_DATA_TRAILING_NAMES_PATTERN
sizeof
(
AbstractBindingName
<
JSAtom
>
)
*
nameCount
MemCheckKind
:
:
MakeUndefined
)
;
}
inline
void
PoisonNames
(
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
*
data
size_t
nameCount
)
{
std
:
:
fill_n
(
data
nameCount
AbstractBindingName
<
frontend
:
:
TaggedParserAtomIndex
>
(
)
)
;
}
template
<
typename
NameT
>
class
AbstractTrailingNamesArray
{
using
BindingNameT
=
AbstractBindingName
<
NameT
>
;
private
:
alignas
(
BindingNameT
)
unsigned
char
data_
[
sizeof
(
BindingNameT
)
]
;
private
:
void
*
ptr
(
)
{
return
data_
;
}
public
:
AbstractTrailingNamesArray
(
)
=
delete
;
explicit
AbstractTrailingNamesArray
(
size_t
nameCount
)
{
if
(
nameCount
)
{
PoisonNames
(
reinterpret_cast
<
BindingNameT
*
>
(
&
data_
)
nameCount
)
;
}
}
BindingNameT
*
start
(
)
{
return
reinterpret_cast
<
BindingNameT
*
>
(
ptr
(
)
)
;
}
BindingNameT
&
get
(
size_t
i
)
{
return
start
(
)
[
i
]
;
}
BindingNameT
&
operator
[
]
(
size_t
i
)
{
return
get
(
i
)
;
}
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
Scope
*
Wrapper
>
{
public
:
template
<
class
U
>
JS
:
:
Handle
<
U
*
>
as
(
)
const
{
const
Wrapper
&
self
=
*
static_cast
<
const
Wrapper
*
>
(
this
)
;
MOZ_ASSERT_IF
(
self
self
-
>
template
is
<
U
>
(
)
)
;
return
Handle
<
U
*
>
:
:
fromMarkedLocation
(
reinterpret_cast
<
U
*
const
*
>
(
self
.
address
(
)
)
)
;
}
}
;
class
Scope
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
BaseScopeData
>
{
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
friend
class
js
:
:
AbstractBindingIter
<
JSAtom
>
;
protected
:
BaseScopeData
*
rawData
(
)
{
return
headerPtr
(
)
;
}
const
BaseScopeData
*
rawData
(
)
const
{
return
headerPtr
(
)
;
}
const
ScopeKind
kind_
;
const
HeapPtr
<
Shape
*
>
environmentShape_
;
HeapPtr
<
Scope
*
>
enclosingScope_
;
Scope
(
ScopeKind
kind
Scope
*
enclosing
Shape
*
environmentShape
)
:
TenuredCellWithNonGCPointer
(
nullptr
)
kind_
(
kind
)
environmentShape_
(
environmentShape
)
enclosingScope_
(
enclosing
)
{
}
static
Scope
*
create
(
JSContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
)
;
template
<
typename
ConcreteScope
XDRMode
mode
>
static
XDRResult
XDRSizedBindingNames
(
XDRState
<
mode
>
*
xdr
Handle
<
ConcreteScope
*
>
scope
MutableHandle
<
typename
ConcreteScope
:
:
Data
*
>
data
)
;
Shape
*
maybeCloneEnvironmentShape
(
JSContext
*
cx
)
;
template
<
typename
ConcreteScope
>
void
initData
(
MutableHandle
<
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
>
data
)
;
template
<
typename
F
>
void
applyScopeDataTyped
(
F
&
&
f
)
;
template
<
typename
EnvironmentT
>
static
bool
updateEnvShapeIfRequired
(
JSContext
*
cx
MutableHandleShape
shape
bool
needsEnvironment
)
;
template
<
typename
EnvironmentT
>
static
bool
updateEnvShapeIfRequired
(
JSContext
*
cx
mozilla
:
:
Maybe
<
uint32_t
>
*
envShape
bool
needsEnvironment
)
;
public
:
template
<
typename
ConcreteScope
>
static
ConcreteScope
*
create
(
JSContext
*
cx
ScopeKind
kind
HandleScope
enclosing
HandleShape
envShape
MutableHandle
<
UniquePtr
<
typename
ConcreteScope
:
:
Data
>
>
data
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Scope
;
template
<
typename
T
>
bool
is
(
)
const
{
return
kind_
=
=
T
:
:
classScopeKind_
;
}
template
<
typename
T
>
T
&
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
T
*
>
(
this
)
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
ScopeKind
kind
(
)
const
{
return
kind_
;
}
Shape
*
environmentShape
(
)
const
{
return
environmentShape_
;
}
Scope
*
enclosing
(
)
const
{
return
enclosingScope_
;
}
static
bool
hasEnvironment
(
ScopeKind
kind
bool
environmentShape
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
With
:
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
true
;
default
:
return
environmentShape
;
}
}
bool
hasEnvironment
(
)
const
{
return
hasEnvironment
(
kind_
environmentShape
(
)
)
;
}
uint32_t
firstFrameSlot
(
)
const
;
uint32_t
chainLength
(
)
const
;
uint32_t
environmentChainLength
(
)
const
;
template
<
typename
T
>
bool
hasOnChain
(
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
is
<
T
>
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
hasOnChain
(
ScopeKind
kind
)
const
{
for
(
const
Scope
*
it
=
this
;
it
;
it
=
it
-
>
enclosing
(
)
)
{
if
(
it
-
>
kind
(
)
=
=
kind
)
{
return
true
;
}
}
return
false
;
}
static
Scope
*
clone
(
JSContext
*
cx
HandleScope
scope
HandleScope
enclosing
)
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
dump
(
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
static
bool
dumpForDisassemble
(
JSContext
*
cx
JS
:
:
Handle
<
Scope
*
>
scope
GenericPrinter
&
out
const
char
*
indent
)
;
#
endif
}
;
template
<
class
Data
>
inline
size_t
SizeOfScopeData
(
uint32_t
numBindings
)
{
return
sizeof
(
Data
)
+
(
(
numBindings
?
numBindings
-
1
:
0
)
*
sizeof
(
AbstractBindingName
<
typename
Data
:
:
NameType
>
)
)
;
}
template
<
typename
ScopeT
typename
AtomT
>
using
AbstractScopeData
=
typename
ScopeT
:
:
template
AbstractData
<
AtomT
>
;
template
<
typename
ScopeT
typename
AtomT
>
using
MaybeRootedScopeData
=
std
:
:
conditional_t
<
std
:
:
is_same_v
<
AtomT
JSAtom
>
MaybeRooted
<
UniquePtr
<
typename
ScopeT
:
:
Data
>
AllowGC
:
:
CanGC
>
MaybeRooted
<
AbstractScopeData
<
ScopeT
AtomT
>
*
AllowGC
:
:
NoGC
>
>
;
class
LexicalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
constStart
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
LexicalScope
*
createWithData
(
JSContext
*
cx
ScopeKind
kind
MutableHandle
<
UniquePtr
<
Data
>
>
data
uint32_t
firstFrameSlot
HandleScope
enclosing
)
;
template
<
typename
AtomT
typename
ShapeT
>
static
bool
prepareForScopeCreation
(
JSContext
*
cx
ScopeKind
kind
uint32_t
firstFrameSlot
typename
MaybeRootedScopeData
<
LexicalScope
AtomT
>
:
:
MutableHandleType
data
ShapeT
envShape
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
static
uint32_t
nextFrameSlot
(
const
AbstractScopePtr
&
scope
)
;
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
static
Shape
*
getEmptyExtensibleEnvironmentShape
(
JSContext
*
cx
)
;
}
;
template
<
>
inline
bool
Scope
:
:
is
<
LexicalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Lexical
|
|
kind_
=
=
ScopeKind
:
:
SimpleCatch
|
|
kind_
=
=
ScopeKind
:
:
Catch
|
|
kind_
=
=
ScopeKind
:
:
NamedLambda
|
|
kind_
=
=
ScopeKind
:
:
StrictNamedLambda
|
|
kind_
=
=
ScopeKind
:
:
FunctionLexical
|
|
kind_
=
=
ScopeKind
:
:
ClassBody
;
}
class
FunctionScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
PositionalFormalParameterIter
;
friend
class
Scope
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Function
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
flags
=
0
;
static
constexpr
uint32_t
HasParameterExprsFlag
=
1
;
uint16_t
nonPositionalFormalStart
=
0
;
uint16_t
varStart
=
0
;
uint32_t
length
=
0
;
bool
hasParameterExprs
(
)
const
{
return
flags
&
HasParameterExprsFlag
;
}
void
setHasParameterExprs
(
)
{
flags
|
=
HasParameterExprsFlag
;
}
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
HeapPtr
<
JSFunction
*
>
canonicalFunction
=
{
}
;
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
template
<
typename
AtomT
typename
ShapeT
>
static
bool
prepareForScopeCreation
(
JSContext
*
cx
typename
MaybeRootedScopeData
<
FunctionScope
AtomT
>
:
:
MutableHandleType
data
bool
hasParameterExprs
bool
needsEnvironment
HandleFunction
fun
ShapeT
envShape
)
;
static
FunctionScope
*
clone
(
JSContext
*
cx
Handle
<
FunctionScope
*
>
scope
HandleFunction
fun
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
HandleFunction
fun
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
FunctionScope
*
createWithData
(
JSContext
*
cx
MutableHandle
<
UniquePtr
<
Data
>
>
data
bool
hasParameterExprs
bool
needsEnvironment
HandleFunction
fun
HandleScope
enclosing
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
JSFunction
*
canonicalFunction
(
)
const
{
return
data
(
)
.
canonicalFunction
;
}
JSScript
*
script
(
)
const
;
bool
hasParameterExprs
(
)
const
{
return
data
(
)
.
slotInfo
.
hasParameterExprs
(
)
;
}
uint32_t
numPositionalFormalParameters
(
)
const
{
return
data
(
)
.
slotInfo
.
nonPositionalFormalStart
;
}
static
bool
isSpecialName
(
JSContext
*
cx
JSAtom
*
name
)
;
static
bool
isSpecialName
(
JSContext
*
cx
frontend
:
:
TaggedParserAtomIndex
name
)
;
}
;
class
VarScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
VarScope
*
createWithData
(
JSContext
*
cx
ScopeKind
kind
MutableHandle
<
UniquePtr
<
Data
>
>
data
uint32_t
firstFrameSlot
bool
needsEnvironment
HandleScope
enclosing
)
;
template
<
typename
AtomT
typename
ShapeT
>
static
bool
prepareForScopeCreation
(
JSContext
*
cx
ScopeKind
kind
typename
MaybeRootedScopeData
<
VarScope
AtomT
>
:
:
MutableHandleType
data
uint32_t
firstFrameSlot
bool
needsEnvironment
ShapeT
envShape
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
VarScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
FunctionBodyVar
;
}
class
GlobalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
public
:
struct
SlotInfo
{
uint32_t
letStart
=
0
;
uint32_t
constStart
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
static
GlobalScope
*
create
(
JSContext
*
cx
ScopeKind
kind
Handle
<
Data
*
>
data
)
;
static
GlobalScope
*
createEmpty
(
JSContext
*
cx
ScopeKind
kind
)
{
return
create
(
cx
kind
nullptr
)
;
}
static
GlobalScope
*
clone
(
JSContext
*
cx
Handle
<
GlobalScope
*
>
scope
ScopeKind
kind
)
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
MutableHandleScope
scope
)
;
private
:
static
GlobalScope
*
createWithData
(
JSContext
*
cx
ScopeKind
kind
MutableHandle
<
UniquePtr
<
Data
>
>
data
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
bool
isSyntactic
(
)
const
{
return
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
slotInfo
.
length
>
0
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
GlobalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Global
|
|
kind_
=
=
ScopeKind
:
:
NonSyntactic
;
}
class
WithScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
With
;
public
:
static
WithScope
*
create
(
JSContext
*
cx
HandleScope
enclosing
)
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosing
MutableHandleScope
scope
)
;
}
;
class
EvalScope
:
public
Scope
{
friend
class
Scope
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
GCMarker
;
friend
class
frontend
:
:
ScopeStencil
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
ScopeKind
kind
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
EvalScope
*
createWithData
(
JSContext
*
cx
ScopeKind
kind
MutableHandle
<
UniquePtr
<
Data
>
>
data
HandleScope
enclosing
)
;
template
<
typename
AtomT
typename
ShapeT
>
static
bool
prepareForScopeCreation
(
JSContext
*
cx
ScopeKind
scopeKind
typename
MaybeRootedScopeData
<
EvalScope
AtomT
>
:
:
MutableHandleType
data
ShapeT
envShape
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
static
Scope
*
nearestVarScopeForDirectEval
(
Scope
*
scope
)
;
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
bool
strict
(
)
const
{
return
kind
(
)
=
=
ScopeKind
:
:
StrictEval
;
}
bool
hasBindings
(
)
const
{
return
data
(
)
.
slotInfo
.
length
>
0
;
}
bool
isNonGlobal
(
)
const
{
if
(
strict
(
)
)
{
return
true
;
}
return
!
nearestVarScopeForDirectEval
(
enclosing
(
)
)
-
>
is
<
GlobalScope
>
(
)
;
}
}
;
template
<
>
inline
bool
Scope
:
:
is
<
EvalScope
>
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Eval
|
|
kind_
=
=
ScopeKind
:
:
StrictEval
;
}
class
ModuleScope
:
public
Scope
{
friend
class
GCMarker
;
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
AbstractScopePtr
;
friend
class
frontend
:
:
ScopeStencil
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
Module
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
varStart
=
0
;
uint32_t
letStart
=
0
;
uint32_t
constStart
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
HeapPtr
<
ModuleObject
*
>
module
=
{
}
;
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
;
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
template
<
XDRMode
mode
>
static
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
HandleModuleObject
module
HandleScope
enclosing
MutableHandleScope
scope
)
;
private
:
static
ModuleScope
*
createWithData
(
JSContext
*
cx
MutableHandle
<
UniquePtr
<
Data
>
>
data
Handle
<
ModuleObject
*
>
module
HandleScope
enclosing
)
;
template
<
typename
AtomT
typename
ShapeT
>
static
bool
prepareForScopeCreation
(
JSContext
*
cx
typename
MaybeRootedScopeData
<
ModuleScope
AtomT
>
:
:
MutableHandleType
data
HandleModuleObject
module
ShapeT
envShape
)
;
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
uint32_t
nextFrameSlot
(
)
const
{
return
data
(
)
.
slotInfo
.
nextFrameSlot
;
}
ModuleObject
*
module
(
)
const
{
return
data
(
)
.
module
;
}
static
const
size_t
EnclosingEnvironmentChainLength
=
1
;
}
;
class
WasmInstanceScope
:
public
Scope
{
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
GCMarker
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
WasmInstance
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
globalsStart
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
HeapPtr
<
WasmInstanceObject
*
>
instance
=
{
}
;
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
;
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
static
WasmInstanceScope
*
create
(
JSContext
*
cx
WasmInstanceObject
*
instance
)
;
private
:
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
public
:
WasmInstanceObject
*
instance
(
)
const
{
return
data
(
)
.
instance
;
}
uint32_t
memoriesStart
(
)
const
{
return
0
;
}
uint32_t
globalsStart
(
)
const
{
return
data
(
)
.
slotInfo
.
globalsStart
;
}
uint32_t
namesCount
(
)
const
{
return
data
(
)
.
slotInfo
.
length
;
}
}
;
class
WasmFunctionScope
:
public
Scope
{
friend
class
AbstractBindingIter
<
JSAtom
>
;
friend
class
Scope
;
friend
class
GCMarker
;
friend
class
AbstractScopePtr
;
static
const
ScopeKind
classScopeKind_
=
ScopeKind
:
:
WasmFunction
;
public
:
struct
SlotInfo
{
uint32_t
nextFrameSlot
=
0
;
uint32_t
length
=
0
;
}
;
struct
alignas
(
ScopeDataAlignBytes
)
Data
:
public
AbstractBaseScopeData
<
JSAtom
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
JSAtom
>
trailingNames
;
explicit
Data
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
Data
(
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
ParserData
:
public
AbstractBaseScopeData
<
frontend
:
:
TaggedParserAtomIndex
>
{
SlotInfo
slotInfo
;
AbstractTrailingNamesArray
<
frontend
:
:
TaggedParserAtomIndex
>
trailingNames
;
explicit
ParserData
(
size_t
nameCount
)
:
trailingNames
(
nameCount
)
{
}
ParserData
(
)
=
delete
;
}
;
template
<
typename
NameT
>
using
AbstractData
=
typename
std
:
:
conditional_t
<
std
:
:
is_same
<
NameT
JSAtom
>
:
:
value
Data
ParserData
>
;
static
WasmFunctionScope
*
create
(
JSContext
*
cx
HandleScope
enclosing
uint32_t
funcIndex
)
;
private
:
Data
&
data
(
)
{
return
*
static_cast
<
Data
*
>
(
rawData
(
)
)
;
}
const
Data
&
data
(
)
const
{
return
*
static_cast
<
const
Data
*
>
(
rawData
(
)
)
;
}
}
;
template
<
typename
F
>
void
Scope
:
:
applyScopeDataTyped
(
F
&
&
f
)
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
{
f
(
&
as
<
FunctionScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
FunctionBodyVar
:
f
(
&
as
<
VarScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
f
(
&
as
<
LexicalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
With
:
break
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
f
(
&
as
<
EvalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
f
(
&
as
<
GlobalScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
Module
:
f
(
&
as
<
ModuleScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
WasmInstance
:
f
(
&
as
<
WasmInstanceScope
>
(
)
.
data
(
)
)
;
break
;
case
ScopeKind
:
:
WasmFunction
:
f
(
&
as
<
WasmFunctionScope
>
(
)
.
data
(
)
)
;
break
;
}
}
}
template
<
typename
NameT
>
class
BaseAbstractBindingIter
{
protected
:
MOZ_INIT_OUTSIDE_CTOR
uint32_t
positionalFormalStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
nonPositionalFormalStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
varStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
letStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
constStart_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
length_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
index_
;
enum
Flags
:
uint8_t
{
CannotHaveSlots
=
0
CanHaveArgumentSlots
=
1
<
<
0
CanHaveFrameSlots
=
1
<
<
1
CanHaveEnvironmentSlots
=
1
<
<
2
HasFormalParameterExprs
=
1
<
<
3
IgnoreDestructuredFormalParameters
=
1
<
<
4
IsNamedLambda
=
1
<
<
5
}
;
static
const
uint8_t
CanHaveSlotsMask
=
0x7
;
MOZ_INIT_OUTSIDE_CTOR
uint8_t
flags_
;
MOZ_INIT_OUTSIDE_CTOR
uint16_t
argumentSlot_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
frameSlot_
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
environmentSlot_
;
MOZ_INIT_OUTSIDE_CTOR
AbstractBindingName
<
NameT
>
*
names_
;
void
init
(
uint32_t
positionalFormalStart
uint32_t
nonPositionalFormalStart
uint32_t
varStart
uint32_t
letStart
uint32_t
constStart
uint8_t
flags
uint32_t
firstFrameSlot
uint32_t
firstEnvironmentSlot
AbstractBindingName
<
NameT
>
*
names
uint32_t
length
)
{
positionalFormalStart_
=
positionalFormalStart
;
nonPositionalFormalStart_
=
nonPositionalFormalStart
;
varStart_
=
varStart
;
letStart_
=
letStart
;
constStart_
=
constStart
;
length_
=
length
;
index_
=
0
;
flags_
=
flags
;
argumentSlot_
=
0
;
frameSlot_
=
firstFrameSlot
;
environmentSlot_
=
firstEnvironmentSlot
;
names_
=
names
;
settle
(
)
;
}
void
init
(
LexicalScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
uint8_t
flags
)
;
void
init
(
FunctionScope
:
:
AbstractData
<
NameT
>
&
data
uint8_t
flags
)
;
void
init
(
VarScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
;
void
init
(
GlobalScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
EvalScope
:
:
AbstractData
<
NameT
>
&
data
bool
strict
)
;
void
init
(
ModuleScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
WasmInstanceScope
:
:
AbstractData
<
NameT
>
&
data
)
;
void
init
(
WasmFunctionScope
:
:
AbstractData
<
NameT
>
&
data
)
;
bool
hasFormalParameterExprs
(
)
const
{
return
flags_
&
HasFormalParameterExprs
;
}
bool
ignoreDestructuredFormalParameters
(
)
const
{
return
flags_
&
IgnoreDestructuredFormalParameters
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
&
IsNamedLambda
;
}
void
increment
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
flags_
&
CanHaveSlotsMask
)
{
if
(
canHaveArgumentSlots
(
)
)
{
if
(
index_
<
nonPositionalFormalStart_
)
{
MOZ_ASSERT
(
index_
>
=
positionalFormalStart_
)
;
argumentSlot_
+
+
;
}
}
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
kind
(
)
!
=
BindingKind
:
:
Import
)
;
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
environmentSlot_
+
+
;
}
else
if
(
canHaveFrameSlots
(
)
)
{
if
(
index_
>
=
nonPositionalFormalStart_
|
|
(
hasFormalParameterExprs
(
)
&
&
name
(
)
)
)
{
frameSlot_
+
+
;
}
}
}
index_
+
+
;
}
void
settle
(
)
{
if
(
ignoreDestructuredFormalParameters
(
)
)
{
while
(
!
done
(
)
&
&
!
name
(
)
)
{
increment
(
)
;
}
}
}
BaseAbstractBindingIter
(
)
=
default
;
public
:
BaseAbstractBindingIter
(
LexicalScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
bool
isNamedLambda
)
{
init
(
data
firstFrameSlot
isNamedLambda
?
IsNamedLambda
:
0
)
;
}
BaseAbstractBindingIter
(
FunctionScope
:
:
AbstractData
<
NameT
>
&
data
bool
hasParameterExprs
)
{
init
(
data
IgnoreDestructuredFormalParameters
|
(
hasParameterExprs
?
HasFormalParameterExprs
:
0
)
)
;
}
BaseAbstractBindingIter
(
VarScope
:
:
AbstractData
<
NameT
>
&
data
uint32_t
firstFrameSlot
)
{
init
(
data
firstFrameSlot
)
;
}
explicit
BaseAbstractBindingIter
(
GlobalScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
explicit
BaseAbstractBindingIter
(
ModuleScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
explicit
BaseAbstractBindingIter
(
WasmFunctionScope
:
:
AbstractData
<
NameT
>
&
data
)
{
init
(
data
)
;
}
BaseAbstractBindingIter
(
EvalScope
:
:
AbstractData
<
NameT
>
&
data
bool
strict
)
{
init
(
data
strict
)
;
}
MOZ_IMPLICIT
BaseAbstractBindingIter
(
const
BaseAbstractBindingIter
<
NameT
>
&
bi
)
=
default
;
bool
done
(
)
const
{
return
index_
=
=
length_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
increment
(
)
;
settle
(
)
;
}
bool
isLast
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
index_
+
1
=
=
length_
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
flags_
&
CanHaveArgumentSlots
;
}
bool
canHaveFrameSlots
(
)
const
{
return
flags_
&
CanHaveFrameSlots
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
flags_
&
CanHaveEnvironmentSlots
;
}
typename
AbstractBindingName
<
NameT
>
:
:
NamePointerT
name
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
name
(
)
;
}
bool
closedOver
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
names_
[
index_
]
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
(
flags_
&
CanHaveSlotsMask
)
)
{
return
BindingLocation
:
:
Global
(
)
;
}
if
(
index_
<
positionalFormalStart_
)
{
return
BindingLocation
:
:
Import
(
)
;
}
if
(
closedOver
(
)
)
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
BindingLocation
:
:
Environment
(
environmentSlot_
)
;
}
if
(
index_
<
nonPositionalFormalStart_
&
&
canHaveArgumentSlots
(
)
)
{
return
BindingLocation
:
:
Argument
(
argumentSlot_
)
;
}
if
(
canHaveFrameSlots
(
)
)
{
return
BindingLocation
:
:
Frame
(
frameSlot_
)
;
}
MOZ_ASSERT
(
isNamedLambda
(
)
)
;
return
BindingLocation
:
:
NamedLambdaCallee
(
)
;
}
BindingKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
index_
<
positionalFormalStart_
)
{
return
BindingKind
:
:
Import
;
}
if
(
index_
<
varStart_
)
{
if
(
hasFormalParameterExprs
(
)
)
{
return
BindingKind
:
:
Let
;
}
return
BindingKind
:
:
FormalParameter
;
}
if
(
index_
<
letStart_
)
{
return
BindingKind
:
:
Var
;
}
if
(
index_
<
constStart_
)
{
return
BindingKind
:
:
Let
;
}
if
(
isNamedLambda
(
)
)
{
return
BindingKind
:
:
NamedLambdaCallee
;
}
return
BindingKind
:
:
Const
;
}
bool
isTopLevelFunction
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
bool
result
=
names_
[
index_
]
.
isTopLevelFunction
(
)
;
MOZ_ASSERT_IF
(
result
kind
(
)
=
=
BindingKind
:
:
Var
)
;
return
result
;
}
bool
hasArgumentSlot
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
hasFormalParameterExprs
(
)
)
{
return
false
;
}
return
index_
>
=
positionalFormalStart_
&
&
index_
<
nonPositionalFormalStart_
;
}
uint16_t
argumentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveArgumentSlots
(
)
)
;
return
mozilla
:
:
AssertedCast
<
uint16_t
>
(
index_
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
MOZ_ASSERT
(
canHaveFrameSlots
(
)
)
;
return
frameSlot_
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
MOZ_ASSERT
(
canHaveEnvironmentSlots
(
)
)
;
return
environmentSlot_
;
}
}
;
template
<
typename
NameT
>
class
AbstractBindingIter
;
template
<
>
class
AbstractBindingIter
<
JSAtom
>
:
public
BaseAbstractBindingIter
<
JSAtom
>
{
using
Base
=
BaseAbstractBindingIter
<
JSAtom
>
;
public
:
AbstractBindingIter
<
JSAtom
>
(
ScopeKind
kind
BaseScopeData
*
data
uint32_t
firstFrameSlot
)
;
explicit
AbstractBindingIter
<
JSAtom
>
(
Scope
*
scope
)
;
explicit
AbstractBindingIter
<
JSAtom
>
(
JSScript
*
script
)
;
using
Base
:
:
Base
;
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
class
AbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
:
public
BaseAbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
{
using
Base
=
BaseAbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
;
public
:
using
Base
:
:
Base
;
}
;
void
DumpBindings
(
JSContext
*
cx
Scope
*
scope
)
;
JSAtom
*
FrameSlotName
(
JSScript
*
script
jsbytecode
*
pc
)
;
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
const
JSClass
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
;
template
<
class
T
>
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
)
{
return
EmptyEnvironmentShape
(
cx
&
T
:
:
class_
T
:
:
RESERVED_SLOTS
T
:
:
BASESHAPE_FLAGS
)
;
}
class
PositionalFormalParameterIter
:
public
BindingIter
{
void
settle
(
)
{
if
(
index_
>
=
nonPositionalFormalStart_
)
{
index_
=
length_
;
}
}
public
:
explicit
PositionalFormalParameterIter
(
Scope
*
scope
)
;
explicit
PositionalFormalParameterIter
(
JSScript
*
script
)
;
void
operator
+
+
(
int
)
{
BindingIter
:
:
operator
+
+
(
1
)
;
settle
(
)
;
}
bool
isDestructured
(
)
const
{
return
!
name
(
)
;
}
}
;
class
MOZ_STACK_CLASS
ScopeIter
{
Scope
*
scope_
;
public
:
explicit
ScopeIter
(
Scope
*
scope
)
:
scope_
(
scope
)
{
}
explicit
ScopeIter
(
JSScript
*
script
)
;
explicit
ScopeIter
(
const
ScopeIter
&
si
)
=
default
;
bool
done
(
)
const
{
return
!
scope_
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
scope_
=
scope_
-
>
enclosing
(
)
;
}
Scope
*
scope
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
;
}
ScopeKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
-
>
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
scope
(
)
-
>
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
;
void
trace
(
JSTracer
*
trc
)
{
if
(
scope_
)
{
TraceRoot
(
trc
&
scope_
"
scope
iter
scope
"
)
;
}
}
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
BindingIter
Wrapper
>
{
const
BindingIter
&
iter
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
bool
isLast
(
)
const
{
return
iter
(
)
.
isLast
(
)
;
}
bool
canHaveArgumentSlots
(
)
const
{
return
iter
(
)
.
canHaveArgumentSlots
(
)
;
}
bool
canHaveFrameSlots
(
)
const
{
return
iter
(
)
.
canHaveFrameSlots
(
)
;
}
bool
canHaveEnvironmentSlots
(
)
const
{
return
iter
(
)
.
canHaveEnvironmentSlots
(
)
;
}
JSAtom
*
name
(
)
const
{
return
iter
(
)
.
name
(
)
;
}
bool
closedOver
(
)
const
{
return
iter
(
)
.
closedOver
(
)
;
}
BindingLocation
location
(
)
const
{
return
iter
(
)
.
location
(
)
;
}
BindingKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
bool
isTopLevelFunction
(
)
const
{
return
iter
(
)
.
isTopLevelFunction
(
)
;
}
bool
hasArgumentSlot
(
)
const
{
return
iter
(
)
.
hasArgumentSlot
(
)
;
}
uint16_t
argumentSlot
(
)
const
{
return
iter
(
)
.
argumentSlot
(
)
;
}
uint32_t
nextFrameSlot
(
)
const
{
return
iter
(
)
.
nextFrameSlot
(
)
;
}
uint32_t
nextEnvironmentSlot
(
)
const
{
return
iter
(
)
.
nextEnvironmentSlot
(
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
BindingIter
Wrapper
>
:
public
WrappedPtrOperations
<
BindingIter
Wrapper
>
{
BindingIter
&
iter
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
template
<
typename
Wrapper
>
class
WrappedPtrOperations
<
ScopeIter
Wrapper
>
{
const
ScopeIter
&
iter
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
done
(
)
const
{
return
iter
(
)
.
done
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
Scope
*
scope
(
)
const
{
return
iter
(
)
.
scope
(
)
;
}
ScopeKind
kind
(
)
const
{
return
iter
(
)
.
kind
(
)
;
}
Shape
*
environmentShape
(
)
const
{
return
iter
(
)
.
environmentShape
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
{
return
iter
(
)
.
hasSyntacticEnvironment
(
)
;
}
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
ScopeIter
Wrapper
>
:
public
WrappedPtrOperations
<
ScopeIter
Wrapper
>
{
ScopeIter
&
iter
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
operator
+
+
(
int
)
{
iter
(
)
.
operator
+
+
(
1
)
;
}
}
;
Shape
*
CreateEnvironmentShape
(
JSContext
*
cx
BindingIter
&
bi
const
JSClass
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
;
Shape
*
CreateEnvironmentShape
(
JSContext
*
cx
frontend
:
:
CompilationAtomCache
&
atomCache
AbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
&
bi
const
JSClass
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
;
Shape
*
EmptyEnvironmentShape
(
JSContext
*
cx
const
JSClass
*
cls
uint32_t
numSlots
uint32_t
baseShapeFlags
)
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
ScopeKind
>
:
public
IgnoreGCPolicy
<
js
:
:
ScopeKind
>
{
}
;
template
<
typename
T
>
struct
ScopeDataGCPolicy
:
public
NonGCPointerPolicy
<
T
>
{
}
;
#
define
DEFINE_SCOPE_DATA_GCPOLICY
(
Data
)
\
template
<
>
\
struct
MapTypeToRootKind
<
Data
*
>
{
\
static
const
RootKind
kind
=
RootKind
:
:
Traceable
;
\
}
;
\
template
<
>
\
struct
GCPolicy
<
Data
*
>
:
public
ScopeDataGCPolicy
<
Data
*
>
{
}
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
LexicalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
FunctionScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
VarScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
GlobalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
EvalScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
ModuleScope
:
:
Data
)
;
DEFINE_SCOPE_DATA_GCPOLICY
(
js
:
:
WasmFunctionScope
:
:
Data
)
;
#
undef
DEFINE_SCOPE_DATA_GCPOLICY
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
Scope
>
:
TracerConcrete
<
js
:
:
Scope
>
{
protected
:
explicit
Concrete
(
js
:
:
Scope
*
ptr
)
:
TracerConcrete
<
js
:
:
Scope
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
Scope
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
