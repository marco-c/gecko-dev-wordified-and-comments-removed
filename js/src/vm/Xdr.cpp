#
include
"
vm
/
Xdr
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
algorithm
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jsapi
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
js
/
BuildId
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
using
namespace
js
;
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
Utf8Unit
;
#
ifdef
DEBUG
bool
XDRCoderBase
:
:
validateResultCode
(
JSContext
*
cx
JS
:
:
TranscodeResult
code
)
const
{
if
(
cx
-
>
isHelperThreadContext
(
)
)
{
return
true
;
}
return
cx
-
>
isExceptionPending
(
)
=
=
bool
(
code
=
=
JS
:
:
TranscodeResult_Throw
)
;
}
#
endif
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
char
*
chars
size_t
nchars
)
{
return
codeBytes
(
chars
nchars
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
Latin1Char
*
chars
size_t
nchars
)
{
static_assert
(
sizeof
(
Latin1Char
)
=
=
1
"
Latin1Char
must
be
1
byte
for
nchars
below
to
be
the
"
"
proper
count
of
bytes
"
)
;
static_assert
(
std
:
:
is_same_v
<
Latin1Char
unsigned
char
>
"
Latin1Char
must
be
unsigned
char
to
C
+
+
-
safely
reinterpret
"
"
the
bytes
generically
copied
below
as
Latin1Char
"
)
;
return
codeBytes
(
chars
nchars
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
Utf8Unit
*
units
size_t
count
)
{
if
(
count
=
=
0
)
{
return
Ok
(
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
uint8_t
*
ptr
=
buf
-
>
write
(
count
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
std
:
:
transform
(
units
units
+
count
ptr
[
]
(
const
Utf8Unit
&
unit
)
{
return
unit
.
toUint8
(
)
;
}
)
;
}
else
{
const
uint8_t
*
ptr
=
buf
-
>
read
(
count
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Failure_BadDecode
)
;
}
std
:
:
transform
(
ptr
ptr
+
count
units
[
]
(
const
uint8_t
&
value
)
{
return
Utf8Unit
(
value
)
;
}
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
char16_t
*
chars
size_t
nchars
)
{
if
(
nchars
=
=
0
)
{
return
Ok
(
)
;
}
size_t
nbytes
=
nchars
*
sizeof
(
char16_t
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
uint8_t
*
ptr
=
buf
-
>
write
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapToLittleEndian
(
ptr
chars
nchars
)
;
}
else
{
const
uint8_t
*
ptr
=
buf
-
>
read
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Failure_BadDecode
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapFromLittleEndian
(
chars
ptr
nchars
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
typename
CharT
>
static
XDRResult
XDRCodeCharsZ
(
XDRState
<
mode
>
*
xdr
XDRTranscodeString
<
CharT
>
&
buffer
)
{
MOZ_ASSERT_IF
(
mode
=
=
XDR_ENCODE
!
buffer
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
mode
=
=
XDR_DECODE
buffer
.
empty
(
)
)
;
using
OwnedString
=
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
;
OwnedString
owned
;
static_assert
(
JSString
:
:
MAX_LENGTH
<
=
INT32_MAX
"
String
length
must
fit
in
int32_t
"
)
;
uint32_t
length
=
0
;
CharT
*
chars
=
nullptr
;
if
(
mode
=
=
XDR_ENCODE
)
{
chars
=
const_cast
<
CharT
*
>
(
buffer
.
template
ref
<
const
CharT
*
>
(
)
)
;
size_t
lengthSizeT
=
std
:
:
char_traits
<
CharT
>
:
:
length
(
chars
)
;
if
(
lengthSizeT
>
JSString
:
:
MAX_LENGTH
)
{
ReportAllocationOverflow
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
length
=
static_cast
<
uint32_t
>
(
lengthSizeT
)
;
}
MOZ_TRY
(
xdr
-
>
codeUint32
(
&
length
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
owned
=
xdr
-
>
cx
(
)
-
>
template
make_pod_array
<
CharT
>
(
length
+
1
)
;
if
(
!
owned
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
chars
=
owned
.
get
(
)
;
}
MOZ_TRY
(
xdr
-
>
codeChars
(
chars
length
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
owned
[
length
]
=
'
\
0
'
;
buffer
.
template
construct
<
OwnedString
>
(
std
:
:
move
(
owned
)
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeCharsZ
(
XDRTranscodeString
<
char
>
&
buffer
)
{
return
XDRCodeCharsZ
(
this
buffer
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeCharsZ
(
XDRTranscodeString
<
char16_t
>
&
buffer
)
{
return
XDRCodeCharsZ
(
this
buffer
)
;
}
JS_PUBLIC_API
bool
JS
:
:
GetScriptTranscodingBuildId
(
JS
:
:
BuildIdCharVector
*
buildId
)
{
MOZ_ASSERT
(
buildId
-
>
empty
(
)
)
;
MOZ_ASSERT
(
GetBuildId
)
;
if
(
!
GetBuildId
(
buildId
)
)
{
return
false
;
}
if
(
!
buildId
-
>
reserve
(
buildId
-
>
length
(
)
+
5
)
)
{
return
false
;
}
buildId
-
>
infallibleAppend
(
'
-
'
)
;
static_assert
(
sizeof
(
uintptr_t
)
=
=
4
|
|
sizeof
(
uintptr_t
)
=
=
8
)
;
buildId
-
>
infallibleAppend
(
sizeof
(
uintptr_t
)
=
=
4
?
'
4
'
:
'
8
'
)
;
buildId
-
>
infallibleAppend
(
MOZ_LITTLE_ENDIAN
(
)
?
'
l
'
:
'
b
'
)
;
buildId
-
>
infallibleAppend
(
IsTypeInferenceEnabled
(
)
?
'
1
'
:
'
0
'
)
;
buildId
-
>
infallibleAppend
(
js
:
:
UseOffThreadParseGlobal
(
)
?
'
1
'
:
'
0
'
)
;
return
true
;
}
template
<
XDRMode
mode
>
static
XDRResult
VersionCheck
(
XDRState
<
mode
>
*
xdr
)
{
JS
:
:
BuildIdCharVector
buildId
;
if
(
!
JS
:
:
GetScriptTranscodingBuildId
(
&
buildId
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_ASSERT
(
!
buildId
.
empty
(
)
)
;
uint32_t
buildIdLength
;
if
(
mode
=
=
XDR_ENCODE
)
{
buildIdLength
=
buildId
.
length
(
)
;
}
MOZ_TRY
(
xdr
-
>
codeUint32
(
&
buildIdLength
)
)
;
if
(
mode
=
=
XDR_DECODE
&
&
buildIdLength
!
=
buildId
.
length
(
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Failure_BadBuildId
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
MOZ_TRY
(
xdr
-
>
codeBytes
(
buildId
.
begin
(
)
buildIdLength
)
)
;
}
else
{
JS
:
:
BuildIdCharVector
decodedBuildId
;
if
(
!
decodedBuildId
.
resize
(
buildIdLength
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_TRY
(
xdr
-
>
codeBytes
(
decodedBuildId
.
begin
(
)
buildIdLength
)
)
;
if
(
!
ArrayEqual
(
decodedBuildId
.
begin
(
)
buildId
.
begin
(
)
buildIdLength
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Failure_BadBuildId
)
;
}
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeModuleObject
(
MutableHandleModuleObject
modp
)
{
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
if
(
mode
=
=
XDR_DECODE
)
{
modp
.
set
(
nullptr
)
;
}
else
{
MOZ_ASSERT
(
modp
-
>
status
(
)
<
MODULE_STATUS_LINKING
)
;
}
MOZ_TRY
(
XDRModuleObject
(
this
modp
)
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
XDRAtomCount
(
XDRState
<
mode
>
*
xdr
uint32_t
*
atomCount
)
{
return
xdr
-
>
codeUint32
(
atomCount
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
AtomTable
(
XDRState
<
mode
>
*
xdr
)
{
uint8_t
atomHeader
=
false
;
if
(
mode
=
=
XDR_ENCODE
)
{
if
(
xdr
-
>
hasAtomMap
(
)
)
{
atomHeader
=
true
;
}
}
MOZ_TRY
(
xdr
-
>
codeUint8
(
&
atomHeader
)
)
;
if
(
atomHeader
&
&
mode
=
=
XDR_DECODE
)
{
uint32_t
atomCount
;
MOZ_TRY
(
XDRAtomCount
(
xdr
&
atomCount
)
)
;
MOZ_ASSERT
(
!
xdr
-
>
hasAtomTable
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
atomCount
;
i
+
+
)
{
RootedAtom
atom
(
xdr
-
>
cx
(
)
)
;
MOZ_TRY
(
XDRAtom
(
xdr
&
atom
)
)
;
if
(
!
xdr
-
>
atomTable
(
)
.
append
(
atom
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
}
xdr
-
>
finishAtomTable
(
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
ParserAtomTable
(
XDRState
<
mode
>
*
xdr
)
{
if
(
mode
=
=
XDR_ENCODE
)
{
return
Ok
(
)
;
}
uint32_t
atomCount
;
MOZ_TRY
(
XDRAtomCount
(
xdr
&
atomCount
)
)
;
MOZ_ASSERT
(
!
xdr
-
>
hasAtomTable
(
)
)
;
if
(
!
xdr
-
>
parserAtomTable
(
)
.
reserve
(
atomCount
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
for
(
uint32_t
i
=
0
;
i
<
atomCount
;
i
+
+
)
{
const
frontend
:
:
ParserAtom
*
atom
=
nullptr
;
MOZ_TRY
(
XDRParserAtomData
(
xdr
&
atom
)
)
;
if
(
!
xdr
-
>
parserAtomTable
(
)
.
append
(
atom
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
}
xdr
-
>
finishAtomTable
(
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
XDRChunkCount
(
XDRState
<
mode
>
*
xdr
uint32_t
*
sliceCount
)
{
return
xdr
-
>
codeUint32
(
sliceCount
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeFunction
(
MutableHandleFunction
funp
HandleScriptSourceObject
sourceObject
)
{
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
(
)
)
;
TraceLoggerTextId
event
=
mode
=
=
XDR_DECODE
?
TraceLogger_DecodeFunction
:
TraceLogger_EncodeFunction
;
AutoTraceLog
tl
(
logger
event
)
;
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
auto
guard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
funp
.
set
(
nullptr
)
;
}
)
;
RootedScope
scope
(
cx
(
)
&
cx
(
)
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
MOZ_ASSERT
(
!
sourceObject
)
;
funp
.
set
(
nullptr
)
;
}
else
if
(
getTreeKey
(
funp
)
!
=
AutoXDRTree
:
:
noKey
)
{
MOZ_ASSERT
(
sourceObject
)
;
scope
=
funp
-
>
enclosingScope
(
)
;
}
else
{
MOZ_ASSERT
(
!
sourceObject
)
;
MOZ_ASSERT
(
funp
-
>
enclosingScope
(
)
-
>
is
<
GlobalScope
>
(
)
)
;
}
MOZ_TRY
(
VersionCheck
(
this
)
)
;
MOZ_TRY
(
XDRInterpretedFunction
(
this
scope
sourceObject
funp
)
)
;
guard
.
release
(
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeScript
(
MutableHandleScript
scriptp
)
{
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
(
)
)
;
TraceLoggerTextId
event
=
mode
=
=
XDR_DECODE
?
TraceLogger_DecodeScript
:
TraceLogger_EncodeScript
;
AutoTraceLog
tl
(
logger
event
)
;
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
auto
guard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
scriptp
.
set
(
nullptr
)
;
}
)
;
AutoXDRTree
scriptTree
(
this
getTopLevelTreeKey
(
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
scriptp
.
set
(
nullptr
)
;
}
else
{
MOZ_ASSERT
(
!
scriptp
-
>
enclosingScope
(
)
)
;
}
bool
useHeader
=
this
-
>
hasAtomMap
(
)
;
if
(
useHeader
)
{
switchToHeaderBuf
(
)
;
}
MOZ_TRY
(
VersionCheck
(
this
)
)
;
MOZ_TRY
(
AtomTable
(
this
)
)
;
if
(
useHeader
)
{
switchToMainBuf
(
)
;
}
MOZ_ASSERT
(
isMainBuf
(
)
)
;
MOZ_TRY
(
XDRScript
(
this
nullptr
nullptr
nullptr
scriptp
)
)
;
guard
.
release
(
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeStencil
(
frontend
:
:
CompilationInfo
&
compilationInfo
)
{
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
if
(
mode
=
=
XDR_ENCODE
)
{
switchToHeaderBuf
(
)
;
}
MOZ_TRY
(
VersionCheck
(
this
)
)
;
if
(
hasOptions
(
)
)
{
MOZ_ASSERT
(
&
options
(
)
=
=
&
compilationInfo
.
input
.
options
)
;
}
MOZ_TRY
(
XDRCompilationInput
(
this
compilationInfo
.
input
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
MOZ_TRY
(
XDRChunkCount
(
this
&
nchunks
(
)
)
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
switchToAtomBuf
(
)
;
}
MOZ_TRY
(
ParserAtomTable
(
this
)
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
switchToMainBuf
(
)
;
}
MOZ_ASSERT
(
isMainBuf
(
)
)
;
MOZ_TRY
(
XDRCompilationStencil
(
this
compilationInfo
.
stencil
)
)
;
MOZ_TRY
(
finishChunk
(
)
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeFunctionStencil
(
frontend
:
:
CompilationStencil
&
stencil
)
{
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
bool
isAlreadyCoded
=
false
;
MOZ_TRY_VAR
(
isAlreadyCoded
checkAlreadyCoded
(
stencil
)
)
;
if
(
isAlreadyCoded
)
{
return
Ok
(
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
switchToAtomBuf
(
)
;
}
MOZ_TRY
(
ParserAtomTable
(
this
)
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
switchToMainBuf
(
)
;
}
MOZ_TRY
(
XDRCompilationStencil
(
this
stencil
)
)
;
MOZ_TRY
(
finishChunk
(
)
)
;
return
Ok
(
)
;
}
template
class
js
:
:
XDRState
<
XDR_ENCODE
>
;
template
class
js
:
:
XDRState
<
XDR_DECODE
>
;
AutoXDRTree
:
:
AutoXDRTree
(
XDRCoderBase
*
xdr
AutoXDRTree
:
:
Key
key
)
:
key_
(
key
)
parent_
(
this
)
xdr_
(
xdr
)
{
if
(
key_
!
=
AutoXDRTree
:
:
noKey
)
{
xdr
-
>
createOrReplaceSubTree
(
this
)
;
}
}
AutoXDRTree
:
:
~
AutoXDRTree
(
)
{
if
(
key_
!
=
AutoXDRTree
:
:
noKey
)
{
xdr_
-
>
endSubTree
(
)
;
}
}
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
noKey
;
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
noSubTree
;
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
topLevel
;
class
XDRIncrementalEncoder
:
:
DepthFirstSliceIterator
{
public
:
DepthFirstSliceIterator
(
JSContext
*
cx
const
SlicesTree
&
tree
)
:
stack_
(
cx
)
tree_
(
tree
)
{
}
template
<
typename
SliceFun
>
bool
iterate
(
SliceFun
&
&
f
)
{
MOZ_ASSERT
(
stack_
.
empty
(
)
)
;
if
(
!
appendChildrenForKey
(
AutoXDRTree
:
:
topLevel
)
)
{
return
false
;
}
while
(
!
done
(
)
)
{
SlicesNode
:
:
ConstRange
&
iter
=
next
(
)
;
Slice
slice
=
iter
.
popCopyFront
(
)
;
MOZ_ASSERT_IF
(
slice
.
child
=
=
AutoXDRTree
:
:
noSubTree
iter
.
empty
(
)
)
;
if
(
iter
.
empty
(
)
)
{
pop
(
)
;
}
if
(
!
f
(
slice
)
)
{
return
false
;
}
if
(
slice
.
child
=
=
AutoXDRTree
:
:
noSubTree
)
{
continue
;
}
if
(
!
appendChildrenForKey
(
slice
.
child
)
)
{
return
false
;
}
}
return
true
;
}
private
:
bool
done
(
)
const
{
return
stack_
.
empty
(
)
;
}
SlicesNode
:
:
ConstRange
&
next
(
)
{
return
stack_
.
back
(
)
;
}
void
pop
(
)
{
stack_
.
popBack
(
)
;
}
MOZ_MUST_USE
bool
appendChildrenForKey
(
AutoXDRTree
:
:
Key
key
)
{
MOZ_ASSERT
(
key
!
=
AutoXDRTree
:
:
noSubTree
)
;
SlicesTree
:
:
Ptr
p
=
tree_
.
lookup
(
key
)
;
MOZ_ASSERT
(
p
)
;
return
stack_
.
append
(
(
(
const
SlicesNode
&
)
p
-
>
value
(
)
)
.
all
(
)
)
;
}
Vector
<
SlicesNode
:
:
ConstRange
>
stack_
;
const
SlicesTree
&
tree_
;
}
;
AutoXDRTree
:
:
Key
XDRIncrementalEncoder
:
:
getTopLevelTreeKey
(
)
const
{
return
AutoXDRTree
:
:
topLevel
;
}
AutoXDRTree
:
:
Key
XDRIncrementalEncoder
:
:
getTreeKey
(
JSFunction
*
fun
)
const
{
if
(
fun
-
>
hasBaseScript
(
)
)
{
static_assert
(
sizeof
(
fun
-
>
baseScript
(
)
-
>
sourceStart
(
)
)
=
=
4
&
&
sizeof
(
fun
-
>
baseScript
(
)
-
>
sourceEnd
(
)
)
=
=
4
"
AutoXDRTree
key
requires
BaseScript
positions
to
be
uint32
"
)
;
return
uint64_t
(
fun
-
>
baseScript
(
)
-
>
sourceStart
(
)
)
<
<
32
|
fun
-
>
baseScript
(
)
-
>
sourceEnd
(
)
;
}
return
AutoXDRTree
:
:
noKey
;
}
void
XDRIncrementalEncoder
:
:
createOrReplaceSubTree
(
AutoXDRTree
*
child
)
{
AutoXDRTree
*
parent
=
scope_
;
child
-
>
parent_
=
parent
;
scope_
=
child
;
if
(
oom_
)
{
return
;
}
size_t
cursor
=
buf
-
>
cursor
(
)
;
if
(
parent
)
{
Slice
&
last
=
node_
-
>
back
(
)
;
last
.
sliceLength
=
cursor
-
last
.
sliceBegin
;
last
.
child
=
child
-
>
key_
;
MOZ_ASSERT_IF
(
uint32_t
(
parent
-
>
key_
)
!
=
0
uint32_t
(
parent
-
>
key_
>
>
32
)
<
=
uint32_t
(
child
-
>
key_
>
>
32
)
&
&
uint32_t
(
child
-
>
key_
)
<
=
uint32_t
(
parent
-
>
key_
)
)
;
}
SlicesTree
:
:
AddPtr
p
=
tree_
.
lookupForAdd
(
child
-
>
key_
)
;
SlicesNode
tmp
;
if
(
!
p
)
{
if
(
!
tree_
.
add
(
p
child
-
>
key_
std
:
:
move
(
tmp
)
)
)
{
oom_
=
true
;
return
;
}
}
else
{
p
-
>
value
(
)
=
std
:
:
move
(
tmp
)
;
}
node_
=
&
p
-
>
value
(
)
;
if
(
!
node_
-
>
append
(
Slice
{
cursor
0
AutoXDRTree
:
:
noSubTree
}
)
)
{
MOZ_CRASH
(
"
SlicesNode
have
a
reserved
space
of
1
.
"
)
;
}
}
void
XDRIncrementalEncoder
:
:
endSubTree
(
)
{
AutoXDRTree
*
child
=
scope_
;
AutoXDRTree
*
parent
=
child
-
>
parent_
;
scope_
=
parent
;
if
(
oom_
)
{
return
;
}
size_t
cursor
=
buf
-
>
cursor
(
)
;
Slice
&
last
=
node_
-
>
back
(
)
;
last
.
sliceLength
=
cursor
-
last
.
sliceBegin
;
MOZ_ASSERT
(
last
.
child
=
=
AutoXDRTree
:
:
noSubTree
)
;
if
(
!
parent
)
{
node_
=
nullptr
;
return
;
}
SlicesTree
:
:
Ptr
p
=
tree_
.
lookup
(
parent
-
>
key_
)
;
node_
=
&
p
-
>
value
(
)
;
if
(
!
node_
-
>
append
(
Slice
{
cursor
0
AutoXDRTree
:
:
noSubTree
}
)
)
{
oom_
=
true
;
return
;
}
}
XDRResult
XDRIncrementalEncoder
:
:
linearize
(
JS
:
:
TranscodeBuffer
&
buffer
)
{
if
(
oom_
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_ASSERT
(
scope_
=
=
nullptr
)
;
switchToHeaderBuf
(
)
;
MOZ_TRY
(
XDRAtomCount
(
this
&
natoms_
)
)
;
switchToMainBuf
(
)
;
DepthFirstSliceIterator
dfs
(
cx
(
)
tree_
)
;
size_t
totalLength
=
buffer
.
length
(
)
+
header_
.
length
(
)
+
atoms_
.
length
(
)
;
auto
sliceCounter
=
[
&
]
(
const
Slice
&
slice
)
-
>
bool
{
totalLength
+
=
slice
.
sliceLength
;
return
true
;
}
;
if
(
!
dfs
.
iterate
(
sliceCounter
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
;
if
(
!
buffer
.
reserve
(
totalLength
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
buffer
.
infallibleAppend
(
header_
.
begin
(
)
header_
.
length
(
)
)
;
buffer
.
infallibleAppend
(
atoms_
.
begin
(
)
atoms_
.
length
(
)
)
;
auto
sliceCopier
=
[
&
]
(
const
Slice
&
slice
)
-
>
bool
{
MOZ_ASSERT
(
slice
.
sliceBegin
<
=
slices_
.
length
(
)
)
;
MOZ_ASSERT
(
slice
.
sliceBegin
+
slice
.
sliceLength
<
=
slices_
.
length
(
)
)
;
buffer
.
infallibleAppend
(
slices_
.
begin
(
)
+
slice
.
sliceBegin
slice
.
sliceLength
)
;
return
true
;
}
;
if
(
!
dfs
.
iterate
(
sliceCopier
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
tree_
.
clearAndCompact
(
)
;
slices_
.
clearAndFree
(
)
;
return
Ok
(
)
;
}
XDRResult
XDRIncrementalStencilEncoder
:
:
finishChunk
(
)
{
switchToFinishedChunkBuf
(
)
;
MOZ_TRY
(
XDRAtomCount
(
this
&
natoms_
)
)
;
MOZ_TRY
(
codeBytes
(
atoms_
.
begin
(
)
atoms_
.
length
(
)
)
)
;
MOZ_TRY
(
codeBytes
(
slices_
.
begin
(
)
slices_
.
length
(
)
)
)
;
switchToMainBuf
(
)
;
natoms_
=
0
;
atoms_
.
clear
(
)
;
atomBuf_
.
cursor_
=
0
;
slices_
.
clear
(
)
;
mainBuf
.
cursor_
=
0
;
parserAtomMap_
.
clear
(
)
;
return
Ok
(
)
;
}
XDRResult
XDRIncrementalStencilEncoder
:
:
linearize
(
JS
:
:
TranscodeBuffer
&
buffer
)
{
switchToHeaderBuf
(
)
;
uint32_t
nchunks
=
encodedFunctions_
.
count
(
)
+
1
;
MOZ_TRY
(
XDRChunkCount
(
this
&
nchunks
)
)
;
switchToMainBuf
(
)
;
size_t
totalLength
=
buffer
.
length
(
)
+
header_
.
length
(
)
+
finishedChunk_
.
length
(
)
;
if
(
!
buffer
.
reserve
(
totalLength
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
buffer
.
infallibleAppend
(
header_
.
begin
(
)
header_
.
length
(
)
)
;
buffer
.
infallibleAppend
(
finishedChunk_
.
begin
(
)
finishedChunk_
.
length
(
)
)
;
return
Ok
(
)
;
}
void
XDRDecoder
:
:
trace
(
JSTracer
*
trc
)
{
atomTable_
.
trace
(
trc
)
;
}
void
XDRIncrementalEncoder
:
:
trace
(
JSTracer
*
trc
)
{
atomMap_
.
trace
(
trc
)
;
}
XDRResult
XDRStencilDecoder
:
:
codeStencils
(
frontend
:
:
CompilationInfoVector
&
compilationInfos
)
{
MOZ_ASSERT
(
compilationInfos
.
delazifications
.
length
(
)
=
=
0
)
;
frontend
:
:
ParserAtomsTable
parserAtoms
(
cx
(
)
-
>
runtime
(
)
compilationInfos
.
initial
.
stencil
.
alloc
compilationInfos
.
initial
.
stencil
.
parserAtomData
)
;
parserAtoms_
=
&
parserAtoms
;
stencilAlloc_
=
&
compilationInfos
.
initial
.
stencil
.
alloc
;
MOZ_TRY
(
codeStencil
(
compilationInfos
.
initial
)
)
;
if
(
!
compilationInfos
.
delazifications
.
reserve
(
nchunks_
-
1
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
for
(
size_t
i
=
1
;
i
<
nchunks_
;
i
+
+
)
{
compilationInfos
.
delazifications
.
infallibleEmplaceBack
(
cx
(
)
compilationInfos
.
initial
.
input
.
options
)
;
auto
&
funInfo
=
compilationInfos
.
delazifications
[
i
-
1
]
;
parserAtomTable_
.
clear
(
)
;
hasFinishedAtomTable_
=
false
;
frontend
:
:
ParserAtomsTable
parserAtoms
(
cx
(
)
-
>
runtime
(
)
funInfo
.
stencil
.
alloc
funInfo
.
stencil
.
parserAtomData
)
;
parserAtoms_
=
&
parserAtoms
;
stencilAlloc_
=
&
funInfo
.
stencil
.
alloc
;
MOZ_TRY
(
codeFunctionStencil
(
funInfo
.
stencil
)
)
;
}
return
Ok
(
)
;
}
XDRResult
XDRIncrementalStencilEncoder
:
:
codeStencils
(
frontend
:
:
CompilationInfoVector
&
compilationInfos
)
{
MOZ_ASSERT
(
encodedFunctions_
.
count
(
)
=
=
0
)
;
MOZ_TRY
(
codeStencil
(
compilationInfos
.
initial
)
)
;
for
(
auto
&
delazification
:
compilationInfos
.
delazifications
)
{
MOZ_TRY
(
codeFunctionStencil
(
delazification
.
stencil
)
)
;
}
return
Ok
(
)
;
}
XDRIncrementalStencilEncoder
:
:
FunctionKey
XDRIncrementalStencilEncoder
:
:
toFunctionKey
(
const
SourceExtent
&
extent
)
{
return
(
FunctionKey
)
extent
.
sourceStart
<
<
32
|
extent
.
sourceEnd
;
}
XDRResultT
<
bool
>
XDRIncrementalStencilEncoder
:
:
checkAlreadyCoded
(
const
frontend
:
:
CompilationStencil
&
stencil
)
{
auto
key
=
toFunctionKey
(
stencil
.
scriptData
[
frontend
:
:
CompilationInfo
:
:
TopLevelIndex
]
.
extent
)
;
auto
p
=
encodedFunctions_
.
lookupForAdd
(
key
)
;
if
(
p
)
{
return
true
;
}
if
(
!
encodedFunctions_
.
add
(
p
key
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
<
bool
>
(
JS
:
:
TranscodeResult_Throw
)
;
}
return
false
;
}
