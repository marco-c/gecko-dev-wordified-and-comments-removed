#
include
"
vm
/
Xdr
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
StencilXdr
.
h
"
#
include
"
js
/
BuildId
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
StringType
.
h
"
using
namespace
js
;
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
Utf8Unit
;
#
ifdef
DEBUG
bool
XDRCoderBase
:
:
validateResultCode
(
JSContext
*
cx
JS
:
:
TranscodeResult
code
)
const
{
if
(
cx
-
>
isHelperThreadContext
(
)
)
{
return
true
;
}
return
cx
-
>
isExceptionPending
(
)
=
=
bool
(
code
=
=
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
#
endif
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
char
*
chars
size_t
nchars
)
{
return
codeBytes
(
chars
nchars
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
Latin1Char
*
chars
size_t
nchars
)
{
static_assert
(
sizeof
(
Latin1Char
)
=
=
1
"
Latin1Char
must
be
1
byte
for
nchars
below
to
be
the
"
"
proper
count
of
bytes
"
)
;
static_assert
(
std
:
:
is_same_v
<
Latin1Char
unsigned
char
>
"
Latin1Char
must
be
unsigned
char
to
C
+
+
-
safely
reinterpret
"
"
the
bytes
generically
copied
below
as
Latin1Char
"
)
;
return
codeBytes
(
chars
nchars
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
Utf8Unit
*
units
size_t
count
)
{
if
(
count
=
=
0
)
{
return
Ok
(
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
uint8_t
*
ptr
=
buf
-
>
write
(
count
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
std
:
:
transform
(
units
units
+
count
ptr
[
]
(
const
Utf8Unit
&
unit
)
{
return
unit
.
toUint8
(
)
;
}
)
;
}
else
{
const
uint8_t
*
ptr
=
buf
-
>
read
(
count
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult
:
:
Failure_BadDecode
)
;
}
std
:
:
transform
(
ptr
ptr
+
count
units
[
]
(
const
uint8_t
&
value
)
{
return
Utf8Unit
(
value
)
;
}
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
char16_t
*
chars
size_t
nchars
)
{
if
(
nchars
=
=
0
)
{
return
Ok
(
)
;
}
size_t
nbytes
=
nchars
*
sizeof
(
char16_t
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
uint8_t
*
ptr
=
buf
-
>
write
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapToLittleEndian
(
ptr
chars
nchars
)
;
}
else
{
const
uint8_t
*
ptr
=
buf
-
>
read
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult
:
:
Failure_BadDecode
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapFromLittleEndian
(
chars
ptr
nchars
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
typename
CharT
>
static
XDRResult
XDRCodeCharsZ
(
XDRState
<
mode
>
*
xdr
XDRTranscodeString
<
CharT
>
&
buffer
)
{
MOZ_ASSERT_IF
(
mode
=
=
XDR_ENCODE
!
buffer
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
mode
=
=
XDR_DECODE
buffer
.
empty
(
)
)
;
using
OwnedString
=
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
;
OwnedString
owned
;
static_assert
(
JSString
:
:
MAX_LENGTH
<
=
INT32_MAX
"
String
length
must
fit
in
int32_t
"
)
;
uint32_t
length
=
0
;
CharT
*
chars
=
nullptr
;
if
(
mode
=
=
XDR_ENCODE
)
{
chars
=
const_cast
<
CharT
*
>
(
buffer
.
template
ref
<
const
CharT
*
>
(
)
)
;
size_t
lengthSizeT
=
std
:
:
char_traits
<
CharT
>
:
:
length
(
chars
)
;
if
(
lengthSizeT
>
JSString
:
:
MAX_LENGTH
)
{
ReportAllocationOverflow
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
length
=
static_cast
<
uint32_t
>
(
lengthSizeT
)
;
}
MOZ_TRY
(
xdr
-
>
codeUint32
(
&
length
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
owned
=
xdr
-
>
cx
(
)
-
>
template
make_pod_array
<
CharT
>
(
length
+
1
)
;
if
(
!
owned
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
chars
=
owned
.
get
(
)
;
}
MOZ_TRY
(
xdr
-
>
codeChars
(
chars
length
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
owned
[
length
]
=
'
\
0
'
;
buffer
.
template
construct
<
OwnedString
>
(
std
:
:
move
(
owned
)
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeCharsZ
(
XDRTranscodeString
<
char
>
&
buffer
)
{
return
XDRCodeCharsZ
(
this
buffer
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeCharsZ
(
XDRTranscodeString
<
char16_t
>
&
buffer
)
{
return
XDRCodeCharsZ
(
this
buffer
)
;
}
JS_PUBLIC_API
bool
JS
:
:
GetScriptTranscodingBuildId
(
JS
:
:
BuildIdCharVector
*
buildId
)
{
MOZ_ASSERT
(
buildId
-
>
empty
(
)
)
;
MOZ_ASSERT
(
GetBuildId
)
;
if
(
!
GetBuildId
(
buildId
)
)
{
return
false
;
}
if
(
!
buildId
-
>
reserve
(
buildId
-
>
length
(
)
+
4
)
)
{
return
false
;
}
buildId
-
>
infallibleAppend
(
'
-
'
)
;
static_assert
(
sizeof
(
uintptr_t
)
=
=
4
|
|
sizeof
(
uintptr_t
)
=
=
8
)
;
buildId
-
>
infallibleAppend
(
sizeof
(
uintptr_t
)
=
=
4
?
'
4
'
:
'
8
'
)
;
buildId
-
>
infallibleAppend
(
MOZ_LITTLE_ENDIAN
(
)
?
'
l
'
:
'
b
'
)
;
return
true
;
}
template
<
XDRMode
mode
>
static
XDRResult
VersionCheck
(
XDRState
<
mode
>
*
xdr
)
{
JS
:
:
BuildIdCharVector
buildId
;
if
(
!
JS
:
:
GetScriptTranscodingBuildId
(
&
buildId
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
MOZ_ASSERT
(
!
buildId
.
empty
(
)
)
;
uint32_t
buildIdLength
;
if
(
mode
=
=
XDR_ENCODE
)
{
buildIdLength
=
buildId
.
length
(
)
;
}
MOZ_TRY
(
xdr
-
>
codeUint32
(
&
buildIdLength
)
)
;
if
(
mode
=
=
XDR_DECODE
&
&
buildIdLength
!
=
buildId
.
length
(
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Failure_BadBuildId
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
MOZ_TRY
(
xdr
-
>
codeBytes
(
buildId
.
begin
(
)
buildIdLength
)
)
;
}
else
{
JS
:
:
BuildIdCharVector
decodedBuildId
;
if
(
!
decodedBuildId
.
resize
(
buildIdLength
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
MOZ_TRY
(
xdr
-
>
codeBytes
(
decodedBuildId
.
begin
(
)
buildIdLength
)
)
;
if
(
!
ArrayEqual
(
decodedBuildId
.
begin
(
)
buildId
.
begin
(
)
buildIdLength
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult
:
:
Failure_BadBuildId
)
;
}
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
XDRStencilHeader
(
XDRState
<
mode
>
*
xdr
const
JS
:
:
ReadOnlyCompileOptions
*
maybeOptions
RefPtr
<
ScriptSource
>
&
source
)
{
MOZ_TRY
(
VersionCheck
(
xdr
)
)
;
MOZ_TRY
(
ScriptSource
:
:
XDR
(
xdr
maybeOptions
source
)
)
;
return
Ok
(
)
;
}
template
class
js
:
:
XDRState
<
XDR_ENCODE
>
;
template
class
js
:
:
XDRState
<
XDR_DECODE
>
;
XDRResult
XDRStencilEncoder
:
:
codeStencil
(
const
RefPtr
<
ScriptSource
>
&
source
const
frontend
:
:
CompilationStencil
&
stencil
)
{
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
MOZ_TRY
(
frontend
:
:
StencilXDR
:
:
checkCompilationStencil
(
this
stencil
)
)
;
MOZ_TRY
(
XDRStencilHeader
(
this
nullptr
const_cast
<
RefPtr
<
ScriptSource
>
&
>
(
source
)
)
)
;
MOZ_TRY
(
frontend
:
:
StencilXDR
:
:
codeCompilationStencil
(
this
const_cast
<
frontend
:
:
CompilationStencil
&
>
(
stencil
)
)
)
;
return
Ok
(
)
;
}
XDRResult
XDRStencilEncoder
:
:
codeStencil
(
const
frontend
:
:
CompilationStencil
&
stencil
)
{
return
codeStencil
(
stencil
.
source
stencil
)
;
}
XDRIncrementalStencilEncoder
:
:
~
XDRIncrementalStencilEncoder
(
)
{
if
(
merger_
)
{
js_delete
(
merger_
)
;
}
}
XDRResult
XDRIncrementalStencilEncoder
:
:
setInitial
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
UniquePtr
<
frontend
:
:
ExtensibleCompilationStencil
>
&
&
initial
)
{
MOZ_TRY
(
frontend
:
:
StencilXDR
:
:
checkCompilationStencil
(
*
initial
)
)
;
merger_
=
cx
-
>
new_
<
frontend
:
:
CompilationStencilMerger
>
(
)
;
if
(
!
merger_
)
{
return
mozilla
:
:
Err
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
if
(
!
merger_
-
>
setInitial
(
cx
std
:
:
forward
<
UniquePtr
<
frontend
:
:
ExtensibleCompilationStencil
>
>
(
initial
)
)
)
{
return
mozilla
:
:
Err
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
return
Ok
(
)
;
}
XDRResult
XDRIncrementalStencilEncoder
:
:
addDelazification
(
JSContext
*
cx
const
frontend
:
:
CompilationStencil
&
delazification
)
{
if
(
!
merger_
-
>
addDelazification
(
cx
delazification
)
)
{
return
mozilla
:
:
Err
(
JS
:
:
TranscodeResult
:
:
Throw
)
;
}
return
Ok
(
)
;
}
XDRResult
XDRIncrementalStencilEncoder
:
:
linearize
(
JSContext
*
cx
JS
:
:
TranscodeBuffer
&
buffer
ScriptSource
*
ss
)
{
XDRStencilEncoder
encoder
(
cx
buffer
)
;
RefPtr
<
ScriptSource
>
source
(
ss
)
;
{
frontend
:
:
BorrowingCompilationStencil
borrowingStencil
(
merger_
-
>
getResult
(
)
)
;
MOZ_TRY
(
encoder
.
codeStencil
(
source
borrowingStencil
)
)
;
}
return
Ok
(
)
;
}
XDRResult
XDRStencilDecoder
:
:
codeStencil
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
frontend
:
:
CompilationStencil
&
stencil
)
{
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
auto
resetOptions
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
options_
=
nullptr
;
}
)
;
options_
=
&
options
;
MOZ_TRY
(
XDRStencilHeader
(
this
options_
stencil
.
source
)
)
;
MOZ_TRY
(
frontend
:
:
StencilXDR
:
:
codeCompilationStencil
(
this
stencil
)
)
;
return
Ok
(
)
;
}
