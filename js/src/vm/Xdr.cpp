#
include
"
vm
/
Xdr
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
using
namespace
js
;
using
mozilla
:
:
ArrayEqual
;
template
<
XDRMode
mode
>
LifoAlloc
&
XDRState
<
mode
>
:
:
lifoAlloc
(
)
const
{
return
buf
.
cx
(
)
-
>
tempLifoAlloc
(
)
;
}
#
ifdef
DEBUG
bool
XDRCoderBase
:
:
validateResultCode
(
JSContext
*
cx
JS
:
:
TranscodeResult
code
)
const
{
if
(
cx
-
>
helperThread
(
)
)
{
return
true
;
}
return
cx
-
>
isExceptionPending
(
)
=
=
bool
(
code
=
=
JS
:
:
TranscodeResult_Throw
)
;
}
#
endif
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
const
Latin1Char
*
chars
size_t
nchars
)
{
static_assert
(
sizeof
(
Latin1Char
)
=
=
sizeof
(
uint8_t
)
"
Latin1Char
must
fit
in
1
byte
"
)
;
MOZ_ASSERT
(
mode
=
=
XDR_ENCODE
)
;
if
(
nchars
=
=
0
)
{
return
Ok
(
)
;
}
uint8_t
*
ptr
=
buf
.
write
(
nchars
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
mozilla
:
:
PodCopy
(
ptr
chars
nchars
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeChars
(
char16_t
*
chars
size_t
nchars
)
{
if
(
nchars
=
=
0
)
{
return
Ok
(
)
;
}
size_t
nbytes
=
nchars
*
sizeof
(
char16_t
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
uint8_t
*
ptr
=
buf
.
write
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapToLittleEndian
(
ptr
chars
nchars
)
;
}
else
{
const
uint8_t
*
ptr
=
buf
.
read
(
nbytes
)
;
if
(
!
ptr
)
{
return
fail
(
JS
:
:
TranscodeResult_Failure_BadDecode
)
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapFromLittleEndian
(
chars
ptr
nchars
)
;
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
static
XDRResult
VersionCheck
(
XDRState
<
mode
>
*
xdr
)
{
JS
:
:
BuildIdCharVector
buildId
;
MOZ_ASSERT
(
GetBuildId
)
;
if
(
!
GetBuildId
(
&
buildId
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_ASSERT
(
!
buildId
.
empty
(
)
)
;
uint32_t
buildIdLength
;
if
(
mode
=
=
XDR_ENCODE
)
{
buildIdLength
=
buildId
.
length
(
)
;
}
MOZ_TRY
(
xdr
-
>
codeUint32
(
&
buildIdLength
)
)
;
if
(
mode
=
=
XDR_DECODE
&
&
buildIdLength
!
=
buildId
.
length
(
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Failure_BadBuildId
)
;
}
if
(
mode
=
=
XDR_ENCODE
)
{
MOZ_TRY
(
xdr
-
>
codeBytes
(
buildId
.
begin
(
)
buildIdLength
)
)
;
}
else
{
JS
:
:
BuildIdCharVector
decodedBuildId
;
if
(
!
decodedBuildId
.
resize
(
buildIdLength
)
)
{
ReportOutOfMemory
(
xdr
-
>
cx
(
)
)
;
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_TRY
(
xdr
-
>
codeBytes
(
decodedBuildId
.
begin
(
)
buildIdLength
)
)
;
if
(
!
ArrayEqual
(
decodedBuildId
.
begin
(
)
buildId
.
begin
(
)
buildIdLength
)
)
{
return
xdr
-
>
fail
(
JS
:
:
TranscodeResult_Failure_BadBuildId
)
;
}
}
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeFunction
(
MutableHandleFunction
funp
HandleScriptSourceObject
sourceObject
)
{
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
(
)
)
;
TraceLoggerTextId
event
=
mode
=
=
XDR_DECODE
?
TraceLogger_DecodeFunction
:
TraceLogger_EncodeFunction
;
AutoTraceLog
tl
(
logger
event
)
;
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
auto
guard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
funp
.
set
(
nullptr
)
;
}
)
;
RootedScope
scope
(
cx
(
)
&
cx
(
)
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
MOZ_ASSERT
(
!
sourceObject
)
;
funp
.
set
(
nullptr
)
;
}
else
if
(
getTreeKey
(
funp
)
!
=
AutoXDRTree
:
:
noKey
)
{
MOZ_ASSERT
(
sourceObject
)
;
scope
=
funp
-
>
nonLazyScript
(
)
-
>
enclosingScope
(
)
;
}
else
{
MOZ_ASSERT
(
!
sourceObject
)
;
MOZ_ASSERT
(
funp
-
>
nonLazyScript
(
)
-
>
enclosingScope
(
)
-
>
is
<
GlobalScope
>
(
)
)
;
}
MOZ_TRY
(
VersionCheck
(
this
)
)
;
MOZ_TRY
(
XDRInterpretedFunction
(
this
scope
sourceObject
funp
)
)
;
guard
.
release
(
)
;
return
Ok
(
)
;
}
template
<
XDRMode
mode
>
XDRResult
XDRState
<
mode
>
:
:
codeScript
(
MutableHandleScript
scriptp
)
{
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
(
)
)
;
TraceLoggerTextId
event
=
mode
=
=
XDR_DECODE
?
TraceLogger_DecodeScript
:
TraceLogger_EncodeScript
;
AutoTraceLog
tl
(
logger
event
)
;
#
ifdef
DEBUG
auto
sanityCheck
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
validateResultCode
(
cx
(
)
resultCode
(
)
)
)
;
}
)
;
#
endif
auto
guard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
scriptp
.
set
(
nullptr
)
;
}
)
;
MOZ_TRY
(
codeAlign
(
sizeof
(
js
:
:
XDRAlignment
)
)
)
;
AutoXDRTree
scriptTree
(
this
getTopLevelTreeKey
(
)
)
;
if
(
mode
=
=
XDR_DECODE
)
{
scriptp
.
set
(
nullptr
)
;
}
else
{
MOZ_ASSERT
(
!
scriptp
-
>
enclosingScope
(
)
)
;
}
MOZ_TRY
(
VersionCheck
(
this
)
)
;
MOZ_TRY
(
XDRScript
(
this
nullptr
nullptr
nullptr
scriptp
)
)
;
MOZ_TRY
(
codeAlign
(
sizeof
(
js
:
:
XDRAlignment
)
)
)
;
guard
.
release
(
)
;
return
Ok
(
)
;
}
template
class
js
:
:
XDRState
<
XDR_ENCODE
>
;
template
class
js
:
:
XDRState
<
XDR_DECODE
>
;
AutoXDRTree
:
:
AutoXDRTree
(
XDRCoderBase
*
xdr
AutoXDRTree
:
:
Key
key
)
:
key_
(
key
)
parent_
(
this
)
xdr_
(
xdr
)
{
MOZ_ASSERT
(
xdr
-
>
isAligned
(
sizeof
(
js
:
:
XDRAlignment
)
)
)
;
if
(
key_
!
=
AutoXDRTree
:
:
noKey
)
{
xdr
-
>
createOrReplaceSubTree
(
this
)
;
}
}
AutoXDRTree
:
:
~
AutoXDRTree
(
)
{
MOZ_ASSERT_IF
(
xdr_
-
>
resultCode
(
)
=
=
JS
:
:
TranscodeResult_Ok
xdr_
-
>
isAligned
(
sizeof
(
js
:
:
XDRAlignment
)
)
)
;
if
(
key_
!
=
AutoXDRTree
:
:
noKey
)
{
xdr_
-
>
endSubTree
(
)
;
}
}
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
noKey
;
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
noSubTree
;
constexpr
AutoXDRTree
:
:
Key
AutoXDRTree
:
:
topLevel
;
AutoXDRTree
:
:
Key
XDRIncrementalEncoder
:
:
getTopLevelTreeKey
(
)
const
{
return
AutoXDRTree
:
:
topLevel
;
}
AutoXDRTree
:
:
Key
XDRIncrementalEncoder
:
:
getTreeKey
(
JSFunction
*
fun
)
const
{
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
static_assert
(
sizeof
(
fun
-
>
lazyScript
(
)
-
>
sourceStart
(
)
)
=
=
4
|
|
sizeof
(
fun
-
>
lazyScript
(
)
-
>
sourceEnd
(
)
)
=
=
4
"
AutoXDRTree
key
requires
LazyScripts
positions
to
be
uint32
"
)
;
return
uint64_t
(
fun
-
>
lazyScript
(
)
-
>
sourceStart
(
)
)
<
<
32
|
fun
-
>
lazyScript
(
)
-
>
sourceEnd
(
)
;
}
if
(
fun
-
>
isInterpreted
(
)
)
{
static_assert
(
sizeof
(
fun
-
>
nonLazyScript
(
)
-
>
sourceStart
(
)
)
=
=
4
|
|
sizeof
(
fun
-
>
nonLazyScript
(
)
-
>
sourceEnd
(
)
)
=
=
4
"
AutoXDRTree
key
requires
JSScripts
positions
to
be
uint32
"
)
;
return
uint64_t
(
fun
-
>
nonLazyScript
(
)
-
>
sourceStart
(
)
)
<
<
32
|
fun
-
>
nonLazyScript
(
)
-
>
sourceEnd
(
)
;
}
return
AutoXDRTree
:
:
noKey
;
}
void
XDRIncrementalEncoder
:
:
createOrReplaceSubTree
(
AutoXDRTree
*
child
)
{
AutoXDRTree
*
parent
=
scope_
;
child
-
>
parent_
=
parent
;
scope_
=
child
;
if
(
oom_
)
{
return
;
}
size_t
cursor
=
buf
.
cursor
(
)
;
if
(
parent
)
{
Slice
&
last
=
node_
-
>
back
(
)
;
last
.
sliceLength
=
cursor
-
last
.
sliceBegin
;
last
.
child
=
child
-
>
key_
;
MOZ_ASSERT_IF
(
uint32_t
(
parent
-
>
key_
)
!
=
0
uint32_t
(
parent
-
>
key_
>
>
32
)
<
=
uint32_t
(
child
-
>
key_
>
>
32
)
&
&
uint32_t
(
child
-
>
key_
)
<
=
uint32_t
(
parent
-
>
key_
)
)
;
}
SlicesTree
:
:
AddPtr
p
=
tree_
.
lookupForAdd
(
child
-
>
key_
)
;
SlicesNode
tmp
;
if
(
!
p
)
{
if
(
!
tree_
.
add
(
p
child
-
>
key_
std
:
:
move
(
tmp
)
)
)
{
oom_
=
true
;
return
;
}
}
else
{
p
-
>
value
(
)
=
std
:
:
move
(
tmp
)
;
}
node_
=
&
p
-
>
value
(
)
;
if
(
!
node_
-
>
append
(
Slice
{
cursor
0
AutoXDRTree
:
:
noSubTree
}
)
)
{
MOZ_CRASH
(
"
SlicesNode
have
a
reserved
space
of
1
.
"
)
;
}
}
void
XDRIncrementalEncoder
:
:
endSubTree
(
)
{
AutoXDRTree
*
child
=
scope_
;
AutoXDRTree
*
parent
=
child
-
>
parent_
;
scope_
=
parent
;
if
(
oom_
)
{
return
;
}
size_t
cursor
=
buf
.
cursor
(
)
;
Slice
&
last
=
node_
-
>
back
(
)
;
last
.
sliceLength
=
cursor
-
last
.
sliceBegin
;
MOZ_ASSERT
(
last
.
child
=
=
AutoXDRTree
:
:
noSubTree
)
;
if
(
!
parent
)
{
node_
=
nullptr
;
return
;
}
SlicesTree
:
:
Ptr
p
=
tree_
.
lookup
(
parent
-
>
key_
)
;
node_
=
&
p
-
>
value
(
)
;
if
(
!
node_
-
>
append
(
Slice
{
cursor
0
AutoXDRTree
:
:
noSubTree
}
)
)
{
oom_
=
true
;
return
;
}
}
XDRResult
XDRIncrementalEncoder
:
:
linearize
(
JS
:
:
TranscodeBuffer
&
buffer
)
{
if
(
oom_
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
MOZ_ASSERT
(
scope_
=
=
nullptr
)
;
size_t
alignLen
=
sizeof
(
js
:
:
XDRAlignment
)
;
if
(
buffer
.
length
(
)
%
alignLen
)
{
alignLen
=
ComputeByteAlignment
(
buffer
.
length
(
)
alignLen
)
;
if
(
!
buffer
.
appendN
(
0
alignLen
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
}
Vector
<
SlicesNode
:
:
ConstRange
>
depthFirst
(
cx
(
)
)
;
SlicesTree
:
:
Ptr
p
=
tree_
.
lookup
(
AutoXDRTree
:
:
topLevel
)
;
MOZ_ASSERT
(
p
)
;
if
(
!
depthFirst
.
append
(
(
(
const
SlicesNode
&
)
p
-
>
value
(
)
)
.
all
(
)
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
while
(
!
depthFirst
.
empty
(
)
)
{
SlicesNode
:
:
ConstRange
&
iter
=
depthFirst
.
back
(
)
;
Slice
slice
=
iter
.
popCopyFront
(
)
;
MOZ_ASSERT_IF
(
slice
.
child
=
=
AutoXDRTree
:
:
noSubTree
iter
.
empty
(
)
)
;
if
(
iter
.
empty
(
)
)
{
depthFirst
.
popBack
(
)
;
}
MOZ_ASSERT
(
slice
.
sliceBegin
<
=
slices_
.
length
(
)
)
;
MOZ_ASSERT
(
slice
.
sliceBegin
+
slice
.
sliceLength
<
=
slices_
.
length
(
)
)
;
MOZ_ASSERT
(
buffer
.
length
(
)
%
sizeof
(
XDRAlignment
)
=
=
0
)
;
MOZ_ASSERT
(
slice
.
sliceLength
%
sizeof
(
XDRAlignment
)
=
=
0
)
;
if
(
!
buffer
.
append
(
slices_
.
begin
(
)
+
slice
.
sliceBegin
slice
.
sliceLength
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
if
(
slice
.
child
=
=
AutoXDRTree
:
:
noSubTree
)
{
continue
;
}
SlicesTree
:
:
Ptr
p
=
tree_
.
lookup
(
slice
.
child
)
;
MOZ_ASSERT
(
p
)
;
if
(
!
depthFirst
.
append
(
(
(
const
SlicesNode
&
)
p
-
>
value
(
)
)
.
all
(
)
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
return
fail
(
JS
:
:
TranscodeResult_Throw
)
;
}
}
tree_
.
clearAndCompact
(
)
;
slices_
.
clearAndFree
(
)
;
return
Ok
(
)
;
}
