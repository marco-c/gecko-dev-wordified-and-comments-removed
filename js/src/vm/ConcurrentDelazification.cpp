#
include
"
vm
/
ConcurrentDelazification
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
frontend
/
ScopeBindingCache
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
vm
/
JSContext
.
h
"
using
namespace
js
;
bool
DelazifyStrategy
:
:
add
(
FrontendContext
*
fc
const
InitialStencilAndDelazifications
&
stencils
const
frontend
:
:
CompilationStencil
&
stencil
ScriptIndex
index
)
{
using
namespace
js
:
:
frontend
;
ScriptStencilRef
scriptRef
{
stencils
stencil
index
}
;
MOZ_ASSERT
(
!
scriptRef
.
scriptData
(
)
.
isGhost
(
)
)
;
MOZ_ASSERT
(
scriptRef
.
scriptData
(
)
.
hasSharedData
(
)
)
;
size_t
offset
=
scriptRef
.
scriptData
(
)
.
gcThingsOffset
.
index
;
size_t
length
=
scriptRef
.
scriptData
(
)
.
gcThingsLength
;
auto
gcThingData
=
stencil
.
gcThingData
.
Subspan
(
offset
length
)
;
for
(
TaggedScriptThingIndex
index
:
mozilla
:
:
Reversed
(
gcThingData
)
)
{
if
(
!
index
.
isFunction
(
)
)
{
continue
;
}
ScriptIndex
innerScriptIndex
=
index
.
toFunction
(
)
;
ScriptStencilRef
innerScriptRef
{
stencils
stencil
innerScriptIndex
}
;
if
(
innerScriptRef
.
scriptData
(
)
.
isGhost
(
)
|
|
!
innerScriptRef
.
scriptData
(
)
.
functionFlags
.
isInterpreted
(
)
)
{
continue
;
}
if
(
innerScriptRef
.
scriptData
(
)
.
hasSharedData
(
)
)
{
if
(
!
add
(
fc
stencils
stencil
innerScriptIndex
)
)
{
return
false
;
}
continue
;
}
if
(
!
insert
(
innerScriptIndex
innerScriptRef
)
)
{
ReportOutOfMemory
(
fc
)
;
return
false
;
}
}
return
true
;
}
DelazifyStrategy
:
:
ScriptIndex
LargeFirstDelazification
:
:
next
(
)
{
std
:
:
swap
(
heap
.
back
(
)
heap
[
0
]
)
;
ScriptIndex
result
=
heap
.
popCopy
(
)
.
second
;
size_t
len
=
heap
.
length
(
)
;
size_t
i
=
1
;
while
(
true
)
{
size_t
n
=
2
*
i
;
size_t
largest
;
if
(
n
+
1
<
=
len
&
&
heap
[
(
n
+
1
)
-
1
]
.
first
>
heap
[
n
-
1
]
.
first
)
{
largest
=
n
+
1
;
}
else
if
(
n
<
=
len
)
{
largest
=
n
;
}
else
{
break
;
}
if
(
heap
[
i
-
1
]
.
first
<
heap
[
largest
-
1
]
.
first
)
{
std
:
:
swap
(
heap
[
i
-
1
]
heap
[
largest
-
1
]
)
;
i
=
largest
;
}
else
{
break
;
}
}
return
result
;
}
bool
LargeFirstDelazification
:
:
insert
(
ScriptIndex
index
frontend
:
:
ScriptStencilRef
&
ref
)
{
const
frontend
:
:
ScriptStencilExtra
&
extra
=
ref
.
scriptExtra
(
)
;
SourceSize
size
=
extra
.
extent
.
sourceEnd
-
extra
.
extent
.
sourceStart
;
if
(
!
heap
.
append
(
std
:
:
pair
(
size
index
)
)
)
{
return
false
;
}
size_t
i
=
heap
.
length
(
)
;
while
(
i
>
1
)
{
if
(
heap
[
i
-
1
]
.
first
<
=
heap
[
(
i
/
2
)
-
1
]
.
first
)
{
return
true
;
}
std
:
:
swap
(
heap
[
i
-
1
]
heap
[
(
i
/
2
)
-
1
]
)
;
i
/
=
2
;
}
return
true
;
}
bool
DelazificationContext
:
:
init
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
frontend
:
:
InitialStencilAndDelazifications
*
stencils
)
{
using
namespace
js
:
:
frontend
;
stencils_
=
stencils
;
const
CompilationStencil
&
stencil
=
*
stencils
-
>
getInitial
(
)
;
auto
initial
=
fc_
.
getAllocator
(
)
-
>
make_unique
<
ExtensibleCompilationStencil
>
(
options
stencil
.
source
)
;
if
(
!
initial
|
|
!
initial
-
>
cloneFrom
(
&
fc_
stencil
)
)
{
return
false
;
}
if
(
!
fc_
.
allocateOwnedPool
(
)
)
{
return
false
;
}
if
(
!
merger_
.
setInitial
(
&
fc_
std
:
:
move
(
initial
)
)
)
{
return
false
;
}
switch
(
options
.
eagerDelazificationStrategy
(
)
)
{
case
JS
:
:
DelazificationOption
:
:
OnDemandOnly
:
MOZ_CRASH
(
"
OnDemandOnly
should
not
create
a
DelazificationContext
.
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
CheckConcurrentWithOnDemand
:
case
JS
:
:
DelazificationOption
:
:
ConcurrentDepthFirst
:
strategy_
=
fc_
.
getAllocator
(
)
-
>
make_unique
<
DepthFirstDelazification
>
(
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ConcurrentLargeFirst
:
strategy_
=
fc_
.
getAllocator
(
)
-
>
make_unique
<
LargeFirstDelazification
>
(
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
:
MOZ_CRASH
(
"
ParseEverythingEagerly
should
not
create
a
DelazificationContext
"
)
;
break
;
}
if
(
!
strategy_
)
{
return
false
;
}
BorrowingCompilationStencil
borrow
(
merger_
.
getResult
(
)
)
;
ScriptIndex
topLevel
{
0
}
;
return
strategy_
-
>
add
(
&
fc_
*
stencils
borrow
topLevel
)
;
}
bool
DelazificationContext
:
:
delazify
(
)
{
fc_
.
setStackQuota
(
stackQuota_
)
;
auto
purgePool
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
fc_
.
nameCollectionPool
(
)
.
purge
(
)
;
}
)
;
using
namespace
js
:
:
frontend
;
StencilScopeBindingCache
scopeCache
(
merger_
)
;
LifoAlloc
tempLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
js
:
:
BackgroundMallocArena
)
;
while
(
!
strategy_
-
>
done
(
)
)
{
if
(
isInterrupted_
)
{
isInterrupted_
=
false
;
break
;
}
const
CompilationStencil
*
innerStencil
;
ScriptIndex
scriptIndex
=
strategy_
-
>
next
(
)
;
{
BorrowingCompilationStencil
borrow
(
merger_
.
getResult
(
)
)
;
DelazifyFailureReason
failureReason
;
innerStencil
=
DelazifyCanonicalScriptedFunction
(
&
fc_
tempLifoAlloc
initialPrefableOptions_
&
scopeCache
borrow
scriptIndex
stencils_
.
get
(
)
&
failureReason
)
;
if
(
!
innerStencil
)
{
if
(
failureReason
=
=
DelazifyFailureReason
:
:
Compressed
)
{
strategy_
-
>
clear
(
)
;
return
true
;
}
strategy_
-
>
clear
(
)
;
return
false
;
}
}
if
(
!
merger_
.
addDelazification
(
&
fc_
*
innerStencil
)
)
{
strategy_
-
>
clear
(
)
;
return
false
;
}
{
BorrowingCompilationStencil
borrow
(
merger_
.
getResult
(
)
)
;
if
(
!
strategy_
-
>
add
(
&
fc_
*
stencils_
borrow
scriptIndex
)
)
{
strategy_
-
>
clear
(
)
;
return
false
;
}
}
}
return
true
;
}
bool
DelazificationContext
:
:
done
(
)
const
{
if
(
!
strategy_
)
{
return
true
;
}
return
strategy_
-
>
done
(
)
;
}
size_t
DelazificationContext
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
mergerSize
=
merger_
.
getResult
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
mergerSize
;
}
