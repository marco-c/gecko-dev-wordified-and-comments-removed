#
include
"
vm
/
ConcurrentDelazification
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
frontend
/
ScopeBindingCache
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
vm
/
JSContext
.
h
"
using
namespace
js
;
template
<
typename
T
>
void
const_swap
(
T
&
a
T
&
b
)
{
alignas
(
T
)
unsigned
char
buffer
[
sizeof
(
T
)
]
;
T
*
temp
=
new
(
buffer
)
T
(
std
:
:
move
(
a
)
)
;
a
.
~
T
(
)
;
new
(
&
a
)
T
(
std
:
:
move
(
b
)
)
;
b
.
~
T
(
)
;
new
(
&
b
)
T
(
std
:
:
move
(
*
temp
)
)
;
temp
-
>
~
T
(
)
;
}
bool
DelazifyStrategy
:
:
add
(
FrontendContext
*
fc
ScriptStencilRef
&
ref
)
{
using
namespace
js
:
:
frontend
;
MOZ_ASSERT
(
!
ref
.
scriptDataFromEnclosing
(
)
.
isGhost
(
)
)
;
MOZ_ASSERT
(
ref
.
context
(
)
-
>
scriptData
[
0
]
.
hasSharedData
(
)
)
;
auto
gcThingData
=
ref
.
gcThingsFromInitial
(
)
;
for
(
TaggedScriptThingIndex
index
:
mozilla
:
:
Reversed
(
gcThingData
)
)
{
if
(
!
index
.
isFunction
(
)
)
{
continue
;
}
ScriptIndex
innerIndex
=
index
.
toFunction
(
)
;
ScriptStencilRef
innerRef
{
ref
.
stencils_
innerIndex
}
;
MOZ_ASSERT
(
innerRef
.
enclosingScript
(
)
.
scriptIndex_
=
=
ref
.
scriptIndex_
)
;
const
ScriptStencil
&
innerScriptData
=
innerRef
.
scriptDataFromEnclosing
(
)
;
if
(
innerScriptData
.
isGhost
(
)
|
|
!
innerScriptData
.
functionFlags
.
isInterpreted
(
)
|
|
!
innerScriptData
.
wasEmittedByEnclosingScript
(
)
)
{
continue
;
}
if
(
innerScriptData
.
hasSharedData
(
)
)
{
if
(
!
add
(
fc
innerRef
)
)
{
return
false
;
}
continue
;
}
if
(
!
insert
(
innerRef
)
)
{
ReportOutOfMemory
(
fc
)
;
return
false
;
}
}
return
true
;
}
frontend
:
:
ScriptStencilRef
LargeFirstDelazification
:
:
next
(
)
{
const_swap
(
heap
.
back
(
)
heap
[
0
]
)
;
ScriptStencilRef
result
=
heap
.
popCopy
(
)
.
second
;
size_t
len
=
heap
.
length
(
)
;
size_t
i
=
1
;
while
(
true
)
{
size_t
n
=
2
*
i
;
size_t
largest
;
if
(
n
+
1
<
=
len
&
&
heap
[
(
n
+
1
)
-
1
]
.
first
>
heap
[
n
-
1
]
.
first
)
{
largest
=
n
+
1
;
}
else
if
(
n
<
=
len
)
{
largest
=
n
;
}
else
{
break
;
}
if
(
heap
[
i
-
1
]
.
first
<
heap
[
largest
-
1
]
.
first
)
{
const_swap
(
heap
[
i
-
1
]
heap
[
largest
-
1
]
)
;
i
=
largest
;
}
else
{
break
;
}
}
return
result
;
}
bool
LargeFirstDelazification
:
:
insert
(
frontend
:
:
ScriptStencilRef
&
ref
)
{
const
frontend
:
:
ScriptStencilExtra
&
extra
=
ref
.
scriptExtra
(
)
;
SourceSize
size
=
extra
.
extent
.
sourceEnd
-
extra
.
extent
.
sourceStart
;
if
(
!
heap
.
append
(
std
:
:
pair
(
size
ref
)
)
)
{
return
false
;
}
size_t
i
=
heap
.
length
(
)
;
while
(
i
>
1
)
{
if
(
heap
[
i
-
1
]
.
first
<
=
heap
[
(
i
/
2
)
-
1
]
.
first
)
{
return
true
;
}
const_swap
(
heap
[
i
-
1
]
heap
[
(
i
/
2
)
-
1
]
)
;
i
/
=
2
;
}
return
true
;
}
bool
DelazificationContext
:
:
init
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
frontend
:
:
InitialStencilAndDelazifications
*
stencils
)
{
using
namespace
js
:
:
frontend
;
stencils_
=
stencils
;
if
(
!
fc_
.
allocateOwnedPool
(
)
)
{
return
false
;
}
auto
indexesGuard
=
stencils
-
>
ensureRelativeIndexes
(
&
fc_
)
;
if
(
!
indexesGuard
)
{
return
false
;
}
indexesGuard_
.
emplace
(
std
:
:
move
(
indexesGuard
)
)
;
switch
(
options
.
eagerDelazificationStrategy
(
)
)
{
case
JS
:
:
DelazificationOption
:
:
OnDemandOnly
:
MOZ_CRASH
(
"
OnDemandOnly
should
not
create
a
DelazificationContext
.
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
CheckConcurrentWithOnDemand
:
case
JS
:
:
DelazificationOption
:
:
ConcurrentDepthFirst
:
strategy_
=
fc_
.
getAllocator
(
)
-
>
make_unique
<
DepthFirstDelazification
>
(
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ConcurrentLargeFirst
:
strategy_
=
fc_
.
getAllocator
(
)
-
>
make_unique
<
LargeFirstDelazification
>
(
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
:
MOZ_CRASH
(
"
ParseEverythingEagerly
should
not
create
a
DelazificationContext
"
)
;
break
;
}
if
(
!
strategy_
)
{
return
false
;
}
ScriptStencilRef
topLevel
{
*
stencils_
ScriptIndex
{
0
}
}
;
return
strategy_
-
>
add
(
&
fc_
topLevel
)
;
}
bool
DelazificationContext
:
:
delazify
(
)
{
fc_
.
setStackQuota
(
stackQuota_
)
;
auto
purgePool
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
fc_
.
nameCollectionPool
(
)
.
purge
(
)
;
}
)
;
using
namespace
js
:
:
frontend
;
StencilScopeBindingCache
scopeCache
(
*
stencils_
)
;
LifoAlloc
tempLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
js
:
:
BackgroundMallocArena
)
;
while
(
!
strategy_
-
>
done
(
)
)
{
if
(
isInterrupted_
)
{
isInterrupted_
=
false
;
break
;
}
const
CompilationStencil
*
innerStencil
=
nullptr
;
ScriptStencilRef
scriptRef
=
strategy_
-
>
next
(
)
;
{
DelazifyFailureReason
failureReason
;
innerStencil
=
DelazifyCanonicalScriptedFunction
(
&
fc_
tempLifoAlloc
initialPrefableOptions_
&
scopeCache
scriptRef
.
scriptIndex_
stencils_
.
get
(
)
&
failureReason
)
;
if
(
!
innerStencil
)
{
if
(
failureReason
=
=
DelazifyFailureReason
:
:
Compressed
)
{
strategy_
-
>
clear
(
)
;
return
true
;
}
strategy_
-
>
clear
(
)
;
return
false
;
}
}
if
(
!
strategy_
-
>
add
(
&
fc_
scriptRef
)
)
{
strategy_
-
>
clear
(
)
;
return
false
;
}
}
return
true
;
}
bool
DelazificationContext
:
:
done
(
)
const
{
if
(
!
strategy_
)
{
return
true
;
}
return
strategy_
-
>
done
(
)
;
}
size_t
DelazificationContext
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
stencils_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
size
;
}
