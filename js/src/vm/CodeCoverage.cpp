#
include
"
vm
/
CodeCoverage
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
<
stdio
.
h
>
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
jscompartment
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Time
.
h
"
namespace
js
{
namespace
coverage
{
LCovSource
:
:
LCovSource
(
LifoAlloc
*
alloc
JSObject
*
sso
)
:
source_
(
sso
)
outSF_
(
alloc
)
outFN_
(
alloc
)
outFNDA_
(
alloc
)
numFunctionsFound_
(
0
)
numFunctionsHit_
(
0
)
outBRDA_
(
alloc
)
numBranchesFound_
(
0
)
numBranchesHit_
(
0
)
outDA_
(
alloc
)
numLinesInstrumented_
(
0
)
numLinesHit_
(
0
)
hasFilename_
(
false
)
hasScripts_
(
false
)
{
}
void
LCovSource
:
:
exportInto
(
GenericPrinter
&
out
)
const
{
if
(
!
hasFilename_
|
|
!
hasScripts_
)
return
;
outSF_
.
exportInto
(
out
)
;
outFN_
.
exportInto
(
out
)
;
outFNDA_
.
exportInto
(
out
)
;
out
.
printf
(
"
FNF
:
%
d
\
n
"
numFunctionsFound_
)
;
out
.
printf
(
"
FNH
:
%
d
\
n
"
numFunctionsHit_
)
;
outBRDA_
.
exportInto
(
out
)
;
out
.
printf
(
"
BRF
:
%
d
\
n
"
numBranchesFound_
)
;
out
.
printf
(
"
BRH
:
%
d
\
n
"
numBranchesHit_
)
;
outDA_
.
exportInto
(
out
)
;
out
.
printf
(
"
LF
:
%
d
\
n
"
numLinesInstrumented_
)
;
out
.
printf
(
"
LH
:
%
d
\
n
"
numLinesHit_
)
;
out
.
put
(
"
end_of_record
\
n
"
)
;
}
bool
LCovSource
:
:
writeTopLevelScript
(
JSScript
*
script
)
{
MOZ_ASSERT
(
script
-
>
isTopLevel
(
)
)
;
Vector
<
JSScript
*
8
SystemAllocPolicy
>
queue
;
if
(
!
queue
.
append
(
script
)
)
return
false
;
do
{
script
=
queue
.
popCopy
(
)
;
if
(
!
writeScript
(
script
)
)
return
false
;
if
(
!
script
-
>
hasObjects
(
)
)
continue
;
size_t
idx
=
script
-
>
objects
(
)
-
>
length
;
while
(
idx
-
-
)
{
JSObject
*
obj
=
script
-
>
getObject
(
idx
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
continue
;
JSFunction
&
fun
=
obj
-
>
as
<
JSFunction
>
(
)
;
if
(
!
fun
.
isInterpreted
(
)
)
continue
;
MOZ_ASSERT
(
!
fun
.
isInterpretedLazy
(
)
)
;
JSScript
*
child
=
fun
.
nonLazyScript
(
)
;
if
(
child
-
>
sourceObject
(
)
!
=
source_
)
continue
;
if
(
!
queue
.
append
(
fun
.
nonLazyScript
(
)
)
)
return
false
;
}
}
while
(
!
queue
.
empty
(
)
)
;
if
(
outFN_
.
hadOutOfMemory
(
)
|
|
outFNDA_
.
hadOutOfMemory
(
)
|
|
outBRDA_
.
hadOutOfMemory
(
)
|
|
outDA_
.
hadOutOfMemory
(
)
)
{
return
false
;
}
hasScripts_
=
true
;
return
true
;
}
bool
LCovSource
:
:
writeSourceFilename
(
ScriptSourceObject
*
sso
)
{
outSF_
.
printf
(
"
SF
:
%
s
\
n
"
sso
-
>
source
(
)
-
>
filename
(
)
)
;
if
(
outSF_
.
hadOutOfMemory
(
)
)
return
false
;
hasFilename_
=
true
;
return
true
;
}
bool
LCovSource
:
:
writeScriptName
(
LSprinter
&
out
JSScript
*
script
)
{
JSFunction
*
fun
=
script
-
>
functionNonDelazifying
(
)
;
if
(
fun
&
&
fun
-
>
displayAtom
(
)
)
return
EscapedStringPrinter
(
out
fun
-
>
displayAtom
(
)
0
)
;
out
.
printf
(
"
top
-
level
"
)
;
return
true
;
}
bool
LCovSource
:
:
writeScript
(
JSScript
*
script
)
{
numFunctionsFound_
+
+
;
outFN_
.
printf
(
"
FN
:
%
d
"
script
-
>
lineno
(
)
)
;
if
(
!
writeScriptName
(
outFN_
script
)
)
return
false
;
outFN_
.
put
(
"
\
n
"
1
)
;
uint64_t
hits
=
0
;
ScriptCounts
*
sc
=
nullptr
;
if
(
script
-
>
hasScriptCounts
(
)
)
{
sc
=
&
script
-
>
getScriptCounts
(
)
;
numFunctionsHit_
+
+
;
const
PCCounts
*
counts
=
sc
-
>
maybeGetPCCounts
(
script
-
>
pcToOffset
(
script
-
>
main
(
)
)
)
;
outFNDA_
.
printf
(
"
FNDA
:
%
"
PRIu64
"
"
counts
-
>
numExec
(
)
)
;
if
(
!
writeScriptName
(
outFNDA_
script
)
)
return
false
;
outFNDA_
.
put
(
"
\
n
"
1
)
;
hits
=
1
;
}
jsbytecode
*
snpc
=
script
-
>
code
(
)
;
jssrcnote
*
sn
=
script
-
>
notes
(
)
;
if
(
!
SN_IS_TERMINATOR
(
sn
)
)
snpc
+
=
SN_DELTA
(
sn
)
;
size_t
lineno
=
script
-
>
lineno
(
)
;
jsbytecode
*
end
=
script
-
>
codeEnd
(
)
;
size_t
branchId
=
0
;
for
(
jsbytecode
*
pc
=
script
-
>
code
(
)
;
pc
!
=
end
;
pc
=
GetNextPc
(
pc
)
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
bool
jump
=
IsJumpOpcode
(
op
)
;
bool
fallsthrough
=
BytecodeFallsThrough
(
op
)
&
&
op
!
=
JSOP_GOSUB
;
if
(
sc
)
{
const
PCCounts
*
counts
=
sc
-
>
maybeGetPCCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
if
(
counts
)
hits
=
counts
-
>
numExec
(
)
;
}
if
(
snpc
<
=
pc
)
{
size_t
oldLine
=
lineno
;
while
(
!
SN_IS_TERMINATOR
(
sn
)
&
&
snpc
<
=
pc
)
{
SrcNoteType
type
=
(
SrcNoteType
)
SN_TYPE
(
sn
)
;
if
(
type
=
=
SRC_SETLINE
)
lineno
=
size_t
(
GetSrcNoteOffset
(
sn
0
)
)
;
else
if
(
type
=
=
SRC_NEWLINE
)
lineno
+
+
;
sn
=
SN_NEXT
(
sn
)
;
snpc
+
=
SN_DELTA
(
sn
)
;
}
if
(
oldLine
!
=
lineno
&
&
fallsthrough
)
{
outDA_
.
printf
(
"
DA
:
%
d
%
"
PRIu64
"
\
n
"
lineno
hits
)
;
numLinesInstrumented_
+
+
;
if
(
hits
)
numLinesHit_
+
+
;
}
}
if
(
sc
)
{
const
PCCounts
*
counts
=
sc
-
>
maybeGetThrowCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
if
(
counts
)
hits
-
=
counts
-
>
numExec
(
)
;
}
if
(
jump
&
&
fallsthrough
)
{
jsbytecode
*
fallthroughTarget
=
GetNextPc
(
pc
)
;
uint64_t
fallthroughHits
=
0
;
if
(
sc
)
{
const
PCCounts
*
counts
=
sc
-
>
maybeGetPCCounts
(
script
-
>
pcToOffset
(
fallthroughTarget
)
)
;
if
(
counts
)
fallthroughHits
=
counts
-
>
numExec
(
)
;
}
uint64_t
taken
=
hits
-
fallthroughHits
;
outBRDA_
.
printf
(
"
BRDA
:
%
d
%
d
0
"
lineno
branchId
)
;
if
(
taken
)
outBRDA_
.
printf
(
"
%
d
\
n
"
taken
)
;
else
outBRDA_
.
put
(
"
-
\
n
"
2
)
;
outBRDA_
.
printf
(
"
BRDA
:
%
d
%
d
1
"
lineno
branchId
)
;
if
(
fallthroughHits
)
outBRDA_
.
printf
(
"
%
d
\
n
"
fallthroughHits
)
;
else
outBRDA_
.
put
(
"
-
\
n
"
2
)
;
numBranchesFound_
+
=
2
;
if
(
hits
)
numBranchesHit_
+
=
!
!
taken
+
!
!
fallthroughHits
;
branchId
+
+
;
}
}
return
true
;
}
LCovCompartment
:
:
LCovCompartment
(
)
:
alloc_
(
4096
)
outTN_
(
&
alloc_
)
sources_
(
nullptr
)
{
MOZ_ASSERT
(
alloc_
.
isEmpty
(
)
)
;
}
void
LCovCompartment
:
:
collectCodeCoverageInfo
(
JSCompartment
*
comp
JSObject
*
sso
JSScript
*
topLevel
)
{
if
(
outTN_
.
hadOutOfMemory
(
)
)
return
;
if
(
!
sources_
)
return
;
LCovSource
*
source
=
lookupOrAdd
(
comp
sso
)
;
if
(
!
source
)
return
;
if
(
!
source
-
>
writeTopLevelScript
(
topLevel
)
)
{
outTN_
.
reportOutOfMemory
(
)
;
return
;
}
}
void
LCovCompartment
:
:
collectSourceFile
(
JSCompartment
*
comp
ScriptSourceObject
*
sso
)
{
if
(
!
sso
-
>
source
(
)
-
>
filename
(
)
)
return
;
if
(
outTN_
.
hadOutOfMemory
(
)
)
return
;
LCovSource
*
source
=
lookupOrAdd
(
comp
sso
)
;
if
(
!
source
)
return
;
if
(
!
source
-
>
writeSourceFilename
(
sso
)
)
{
outTN_
.
reportOutOfMemory
(
)
;
return
;
}
}
LCovSource
*
LCovCompartment
:
:
lookupOrAdd
(
JSCompartment
*
comp
JSObject
*
sso
)
{
if
(
!
sources_
)
{
if
(
!
writeCompartmentName
(
comp
)
)
return
nullptr
;
LCovSourceVector
*
raw
=
alloc_
.
pod_malloc
<
LCovSourceVector
>
(
)
;
if
(
!
raw
)
{
outTN_
.
reportOutOfMemory
(
)
;
return
nullptr
;
}
sources_
=
new
(
raw
)
LCovSourceVector
(
alloc_
)
;
}
else
{
for
(
LCovSource
&
source
:
*
sources_
)
{
if
(
source
.
match
(
sso
)
)
return
&
source
;
}
}
if
(
!
sources_
-
>
append
(
Move
(
LCovSource
(
&
alloc_
sso
)
)
)
)
{
outTN_
.
reportOutOfMemory
(
)
;
return
nullptr
;
}
return
&
sources_
-
>
back
(
)
;
}
void
LCovCompartment
:
:
exportInto
(
GenericPrinter
&
out
)
const
{
if
(
!
sources_
|
|
outTN_
.
hadOutOfMemory
(
)
)
return
;
outTN_
.
exportInto
(
out
)
;
for
(
const
LCovSource
&
sc
:
*
sources_
)
sc
.
exportInto
(
out
)
;
}
bool
LCovCompartment
:
:
writeCompartmentName
(
JSCompartment
*
comp
)
{
JSRuntime
*
rt
=
comp
-
>
runtimeFromMainThread
(
)
;
outTN_
.
put
(
"
TN
:
"
)
;
if
(
rt
-
>
compartmentNameCallback
)
{
char
name
[
1024
]
;
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
(
*
rt
-
>
compartmentNameCallback
)
(
rt
comp
name
sizeof
(
name
)
)
;
}
for
(
char
*
s
=
name
;
s
<
name
+
sizeof
(
name
)
&
&
*
s
;
s
+
+
)
{
if
(
(
'
a
'
<
=
*
s
&
&
*
s
<
=
'
z
'
)
|
|
(
'
A
'
<
=
*
s
&
&
*
s
<
=
'
Z
'
)
|
|
(
'
0
'
<
=
*
s
&
&
*
s
<
=
'
9
'
)
)
{
outTN_
.
put
(
s
1
)
;
continue
;
}
outTN_
.
printf
(
"
_
%
p
"
(
void
*
)
size_t
(
*
s
)
)
;
}
outTN_
.
put
(
"
\
n
"
1
)
;
}
else
{
outTN_
.
printf
(
"
Compartment_
%
p
%
p
\
n
"
(
void
*
)
size_t
(
'
_
'
)
comp
)
;
}
return
!
outTN_
.
hadOutOfMemory
(
)
;
}
LCovRuntime
:
:
LCovRuntime
(
)
:
out_
(
)
#
if
defined
(
XP_WIN
)
pid_
(
GetCurrentProcessId
(
)
)
#
else
pid_
(
getpid
(
)
)
#
endif
{
}
LCovRuntime
:
:
~
LCovRuntime
(
)
{
if
(
out_
.
isInitialized
(
)
)
out_
.
finish
(
)
;
}
void
LCovRuntime
:
:
init
(
)
{
const
char
*
outDir
=
getenv
(
"
JS_CODE_COVERAGE_OUTPUT_DIR
"
)
;
if
(
!
outDir
|
|
*
outDir
=
=
0
)
return
;
int64_t
timestamp
=
static_cast
<
double
>
(
PRMJ_Now
(
)
)
/
PRMJ_USEC_PER_SEC
;
static
mozilla
:
:
Atomic
<
size_t
>
globalRuntimeId
(
0
)
;
size_t
rid
=
globalRuntimeId
+
+
;
char
name
[
1024
]
;
size_t
len
=
JS_snprintf
(
name
sizeof
(
name
)
"
%
s
/
%
"
PRId64
"
-
%
d
-
%
d
.
info
"
outDir
timestamp
size_t
(
pid_
)
rid
)
;
if
(
sizeof
(
name
)
<
len
)
{
fprintf
(
stderr
"
Warning
:
LCovRuntime
:
:
init
:
Cannot
serialize
file
name
.
"
)
;
return
;
}
if
(
!
out_
.
init
(
name
)
)
fprintf
(
stderr
"
Warning
:
LCovRuntime
:
:
init
:
Cannot
open
file
named
'
%
s
'
.
"
name
)
;
}
void
LCovRuntime
:
:
writeLCovResult
(
LCovCompartment
&
comp
)
{
if
(
!
out_
.
isInitialized
(
)
)
return
;
#
if
defined
(
XP_WIN
)
size_t
p
=
GetCurrentProcessId
(
)
;
#
else
size_t
p
=
getpid
(
)
;
#
endif
if
(
pid_
!
=
p
)
{
pid_
=
p
;
out_
.
finish
(
)
;
init
(
)
;
if
(
!
out_
.
isInitialized
(
)
)
return
;
}
comp
.
exportInto
(
out_
)
;
out_
.
flush
(
)
;
}
}
}
