#
include
"
vm
/
PromiseLookup
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
builtin
/
Promise
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
ProtoKey
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
JS
:
:
ObjectValue
;
using
JS
:
:
Value
;
using
js
:
:
NativeObject
;
JSFunction
*
js
:
:
PromiseLookup
:
:
getPromiseConstructor
(
JSContext
*
cx
)
{
const
Value
&
val
=
cx
-
>
global
(
)
-
>
getConstructor
(
JSProto_Promise
)
;
return
val
.
isObject
(
)
?
&
val
.
toObject
(
)
.
as
<
JSFunction
>
(
)
:
nullptr
;
}
NativeObject
*
js
:
:
PromiseLookup
:
:
getPromisePrototype
(
JSContext
*
cx
)
{
const
Value
&
val
=
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_Promise
)
;
return
val
.
isObject
(
)
?
&
val
.
toObject
(
)
.
as
<
NativeObject
>
(
)
:
nullptr
;
}
bool
js
:
:
PromiseLookup
:
:
isDataPropertyNative
(
JSContext
*
cx
NativeObject
*
obj
uint32_t
slot
JSNative
native
)
{
JSFunction
*
fun
;
if
(
!
IsFunctionObject
(
obj
-
>
getSlot
(
slot
)
&
fun
)
)
{
return
false
;
}
return
fun
-
>
maybeNative
(
)
=
=
native
&
&
fun
-
>
realm
(
)
=
=
cx
-
>
realm
(
)
;
}
bool
js
:
:
PromiseLookup
:
:
isAccessorPropertyNative
(
JSContext
*
cx
NativeObject
*
holder
Shape
*
shape
JSNative
native
)
{
JSObject
*
getter
=
holder
-
>
getGetter
(
shape
)
;
return
getter
&
&
IsNativeFunction
(
getter
native
)
&
&
getter
-
>
as
<
JSFunction
>
(
)
.
realm
(
)
=
=
cx
-
>
realm
(
)
;
}
void
js
:
:
PromiseLookup
:
:
initialize
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Uninitialized
)
;
NativeObject
*
promiseProto
=
getPromisePrototype
(
cx
)
;
if
(
!
promiseProto
)
{
return
;
}
JSFunction
*
promiseCtor
=
getPromiseConstructor
(
cx
)
;
MOZ_ASSERT
(
promiseCtor
"
The
Promise
constructor
is
initialized
iff
Promise
.
prototype
is
"
"
initialized
"
)
;
state_
=
State
:
:
Disabled
;
Shape
*
ctorShape
=
promiseProto
-
>
lookup
(
cx
cx
-
>
names
(
)
.
constructor
)
;
if
(
!
ctorShape
|
|
!
ctorShape
-
>
isDataProperty
(
)
)
{
return
;
}
JSFunction
*
ctorFun
;
if
(
!
IsFunctionObject
(
promiseProto
-
>
getSlot
(
ctorShape
-
>
slot
(
)
)
&
ctorFun
)
)
{
return
;
}
if
(
ctorFun
!
=
promiseCtor
)
{
return
;
}
Shape
*
thenShape
=
promiseProto
-
>
lookup
(
cx
cx
-
>
names
(
)
.
then
)
;
if
(
!
thenShape
|
|
!
thenShape
-
>
isDataProperty
(
)
)
{
return
;
}
if
(
!
isDataPropertyNative
(
cx
promiseProto
thenShape
-
>
slot
(
)
Promise_then
)
)
{
return
;
}
Shape
*
speciesShape
=
promiseCtor
-
>
lookup
(
cx
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
species
)
)
;
if
(
!
speciesShape
|
|
!
promiseCtor
-
>
hasGetter
(
speciesShape
)
)
{
return
;
}
if
(
!
isAccessorPropertyNative
(
cx
promiseCtor
speciesShape
Promise_static_species
)
)
{
return
;
}
Shape
*
resolveShape
=
promiseCtor
-
>
lookup
(
cx
cx
-
>
names
(
)
.
resolve
)
;
if
(
!
resolveShape
|
|
!
resolveShape
-
>
isDataProperty
(
)
)
{
return
;
}
if
(
!
isDataPropertyNative
(
cx
promiseCtor
resolveShape
-
>
slot
(
)
Promise_static_resolve
)
)
{
return
;
}
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
promiseCtor
-
>
lastProperty
(
)
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
speciesShape
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsInsideNursery
(
promiseProto
-
>
lastProperty
(
)
)
)
;
state_
=
State
:
:
Initialized
;
promiseConstructorShape_
=
promiseCtor
-
>
lastProperty
(
)
;
promiseSpeciesShape_
=
speciesShape
;
promiseProtoShape_
=
promiseProto
-
>
lastProperty
(
)
;
promiseResolveSlot_
=
resolveShape
-
>
slot
(
)
;
promiseProtoConstructorSlot_
=
ctorShape
-
>
slot
(
)
;
promiseProtoThenSlot_
=
thenShape
-
>
slot
(
)
;
}
void
js
:
:
PromiseLookup
:
:
reset
(
)
{
AlwaysPoison
(
this
JS_RESET_VALUE_PATTERN
sizeof
(
*
this
)
MemCheckKind
:
:
MakeUndefined
)
;
state_
=
State
:
:
Uninitialized
;
}
bool
js
:
:
PromiseLookup
:
:
isPromiseStateStillSane
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Initialized
)
;
NativeObject
*
promiseProto
=
getPromisePrototype
(
cx
)
;
MOZ_ASSERT
(
promiseProto
)
;
NativeObject
*
promiseCtor
=
getPromiseConstructor
(
cx
)
;
MOZ_ASSERT
(
promiseCtor
)
;
if
(
promiseProto
-
>
lastProperty
(
)
!
=
promiseProtoShape_
)
{
return
false
;
}
if
(
promiseCtor
-
>
lastProperty
(
)
!
=
promiseConstructorShape_
)
{
return
false
;
}
if
(
promiseProto
-
>
getSlot
(
promiseProtoConstructorSlot_
)
!
=
ObjectValue
(
*
promiseCtor
)
)
{
return
false
;
}
if
(
!
isDataPropertyNative
(
cx
promiseProto
promiseProtoThenSlot_
Promise_then
)
)
{
return
false
;
}
if
(
!
isAccessorPropertyNative
(
cx
promiseCtor
promiseSpeciesShape_
Promise_static_species
)
)
{
return
false
;
}
if
(
!
isDataPropertyNative
(
cx
promiseCtor
promiseResolveSlot_
Promise_static_resolve
)
)
{
return
false
;
}
return
true
;
}
bool
js
:
:
PromiseLookup
:
:
ensureInitialized
(
JSContext
*
cx
Reinitialize
reinitialize
)
{
if
(
state_
=
=
State
:
:
Uninitialized
)
{
initialize
(
cx
)
;
}
else
if
(
state_
=
=
State
:
:
Initialized
)
{
if
(
reinitialize
=
=
Reinitialize
:
:
Allowed
)
{
if
(
!
isPromiseStateStillSane
(
cx
)
)
{
reset
(
)
;
initialize
(
cx
)
;
}
}
else
{
MOZ_ASSERT
(
isPromiseStateStillSane
(
cx
)
)
;
}
}
if
(
state_
!
=
State
:
:
Initialized
)
{
return
false
;
}
MOZ_ASSERT
(
isPromiseStateStillSane
(
cx
)
)
;
return
true
;
}
bool
js
:
:
PromiseLookup
:
:
isDefaultPromiseState
(
JSContext
*
cx
)
{
return
ensureInitialized
(
cx
Reinitialize
:
:
Allowed
)
;
}
bool
js
:
:
PromiseLookup
:
:
hasDefaultProtoAndNoShadowedProperties
(
JSContext
*
cx
PromiseObject
*
promise
)
{
if
(
promise
-
>
staticPrototype
(
)
!
=
getPromisePrototype
(
cx
)
)
{
return
false
;
}
return
promise
-
>
lastProperty
(
)
-
>
isEmptyShape
(
)
;
}
bool
js
:
:
PromiseLookup
:
:
isDefaultInstance
(
JSContext
*
cx
PromiseObject
*
promise
Reinitialize
reinitialize
)
{
if
(
!
ensureInitialized
(
cx
reinitialize
)
)
{
return
false
;
}
return
hasDefaultProtoAndNoShadowedProperties
(
cx
promise
)
;
}
