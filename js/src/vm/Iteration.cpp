#
include
"
vm
/
Iteration
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
algorithm
>
#
include
<
new
>
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
ifdef
ENABLE_RECORD_TUPLE
#
include
"
builtin
/
RecordObject
.
h
"
#
include
"
builtin
/
TupleObject
.
h
"
#
endif
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
PlainObject
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
#
include
"
vm
/
StringType
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
PodCopy
;
using
RootedPropertyIteratorObject
=
Rooted
<
PropertyIteratorObject
*
>
;
static
const
gc
:
:
AllocKind
ITERATOR_FINALIZE_KIND
=
gc
:
:
AllocKind
:
:
OBJECT2_BACKGROUND
;
void
NativeIterator
:
:
trace
(
JSTracer
*
trc
)
{
TraceNullableEdge
(
trc
&
objectBeingIterated_
"
objectBeingIterated_
"
)
;
TraceNullableEdge
(
trc
&
iterObj_
"
iterObj
"
)
;
std
:
:
for_each
(
shapesBegin
(
)
shapesEnd
(
)
[
trc
]
(
GCPtr
<
Shape
*
>
&
shape
)
{
TraceEdge
(
trc
&
shape
"
iterator_shape
"
)
;
}
)
;
GCPtr
<
JSLinearString
*
>
*
begin
=
MOZ_LIKELY
(
isInitialized
(
)
)
?
propertiesBegin
(
)
:
propertyCursor_
;
std
:
:
for_each
(
begin
propertiesEnd
(
)
[
trc
]
(
GCPtr
<
JSLinearString
*
>
&
prop
)
{
TraceEdge
(
trc
&
prop
"
prop
"
)
;
}
)
;
}
using
PropertyKeySet
=
GCHashSet
<
PropertyKey
DefaultHasher
<
PropertyKey
>
>
;
template
<
bool
CheckForDuplicates
>
static
inline
bool
Enumerate
(
JSContext
*
cx
HandleObject
pobj
jsid
id
bool
enumerable
unsigned
flags
MutableHandle
<
PropertyKeySet
>
visited
MutableHandleIdVector
props
)
{
if
(
CheckForDuplicates
)
{
PropertyKeySet
:
:
AddPtr
p
=
visited
.
lookupForAdd
(
id
)
;
if
(
MOZ_UNLIKELY
(
!
!
p
)
)
{
return
true
;
}
if
(
pobj
-
>
is
<
ProxyObject
>
(
)
|
|
pobj
-
>
staticPrototype
(
)
|
|
pobj
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
)
{
if
(
!
visited
.
add
(
p
id
)
)
{
return
false
;
}
}
}
if
(
!
enumerable
&
&
!
(
flags
&
JSITER_HIDDEN
)
)
{
return
true
;
}
if
(
id
.
isSymbol
(
)
)
{
if
(
!
(
flags
&
JSITER_SYMBOLS
)
)
{
return
true
;
}
if
(
!
(
flags
&
JSITER_PRIVATE
)
&
&
id
.
isPrivateName
(
)
)
{
return
true
;
}
}
else
{
if
(
(
flags
&
JSITER_SYMBOLSONLY
)
)
{
return
true
;
}
}
return
props
.
append
(
id
)
;
}
static
bool
EnumerateExtraProperties
(
JSContext
*
cx
HandleObject
obj
unsigned
flags
MutableHandle
<
PropertyKeySet
>
visited
MutableHandleIdVector
props
)
{
MOZ_ASSERT
(
obj
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
)
;
RootedIdVector
properties
(
cx
)
;
bool
enumerableOnly
=
!
(
flags
&
JSITER_HIDDEN
)
;
if
(
!
obj
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
(
cx
obj
&
properties
enumerableOnly
)
)
{
return
false
;
}
RootedId
id
(
cx
)
;
for
(
size_t
n
=
0
;
n
<
properties
.
length
(
)
;
n
+
+
)
{
id
=
properties
[
n
]
;
bool
enumerable
=
true
;
if
(
!
Enumerate
<
true
>
(
cx
obj
id
enumerable
flags
visited
props
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
SortComparatorIntegerIds
(
jsid
a
jsid
b
bool
*
lessOrEqualp
)
{
uint32_t
indexA
indexB
;
MOZ_ALWAYS_TRUE
(
IdIsIndex
(
a
&
indexA
)
)
;
MOZ_ALWAYS_TRUE
(
IdIsIndex
(
b
&
indexB
)
)
;
*
lessOrEqualp
=
(
indexA
<
=
indexB
)
;
return
true
;
}
template
<
bool
CheckForDuplicates
>
static
bool
EnumerateNativeProperties
(
JSContext
*
cx
Handle
<
NativeObject
*
>
pobj
unsigned
flags
MutableHandle
<
PropertyKeySet
>
visited
MutableHandleIdVector
props
)
{
const
bool
iterShapeProperties
=
CheckForDuplicates
|
|
(
flags
&
JSITER_HIDDEN
)
|
|
pobj
-
>
hasEnumerableProperty
(
)
;
bool
enumerateSymbols
;
if
(
flags
&
JSITER_SYMBOLSONLY
)
{
if
(
!
iterShapeProperties
)
{
return
true
;
}
enumerateSymbols
=
true
;
}
else
{
size_t
firstElemIndex
=
props
.
length
(
)
;
size_t
initlen
=
pobj
-
>
getDenseInitializedLength
(
)
;
const
Value
*
vp
=
pobj
-
>
getDenseElements
(
)
;
bool
hasHoles
=
false
;
for
(
size_t
i
=
0
;
i
<
initlen
;
+
+
i
+
+
vp
)
{
if
(
vp
-
>
isMagic
(
JS_ELEMENTS_HOLE
)
)
{
hasHoles
=
true
;
}
else
{
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
PropertyKey
:
:
Int
(
i
)
true
flags
visited
props
)
)
{
return
false
;
}
}
}
if
(
pobj
-
>
is
<
TypedArrayObject
>
(
)
)
{
size_t
len
=
pobj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
;
static_assert
(
PropertyKey
:
:
IntMax
=
=
INT32_MAX
)
;
if
(
len
>
INT32_MAX
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
PropertyKey
:
:
Int
(
i
)
true
flags
visited
props
)
)
{
return
false
;
}
}
}
#
ifdef
ENABLE_RECORD_TUPLE
else
{
Rooted
<
RecordType
*
>
rec
(
cx
)
;
if
(
RecordObject
:
:
maybeUnbox
(
pobj
&
rec
)
)
{
Rooted
<
ArrayObject
*
>
keys
(
cx
rec
-
>
keys
(
)
)
;
RootedId
id
(
cx
)
;
RootedString
key
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
keys
-
>
length
(
)
;
i
+
+
)
{
key
.
set
(
keys
-
>
getDenseElement
(
i
)
.
toString
(
)
)
;
if
(
!
JS_StringToId
(
cx
key
&
id
)
)
{
return
false
;
}
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
id
true
flags
visited
props
)
)
{
return
false
;
}
}
return
true
;
}
else
{
mozilla
:
:
Maybe
<
TupleType
&
>
tup
=
TupleObject
:
:
maybeUnbox
(
pobj
)
;
if
(
tup
)
{
uint32_t
len
=
(
*
tup
)
.
length
(
)
;
RootedId
id
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
JS_IndexToId
(
cx
i
&
id
)
)
{
return
false
;
}
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
id
true
flags
visited
props
)
)
{
return
false
;
}
}
return
true
;
}
}
}
#
endif
if
(
!
iterShapeProperties
)
{
return
true
;
}
bool
isIndexed
=
pobj
-
>
isIndexed
(
)
;
if
(
isIndexed
)
{
if
(
!
hasHoles
)
{
firstElemIndex
=
props
.
length
(
)
;
}
for
(
ShapePropertyIter
<
NoGC
>
iter
(
pobj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
jsid
id
=
iter
-
>
key
(
)
;
uint32_t
dummy
;
if
(
IdIsIndex
(
id
&
dummy
)
)
{
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
id
iter
-
>
enumerable
(
)
flags
visited
props
)
)
{
return
false
;
}
}
}
MOZ_ASSERT
(
firstElemIndex
<
=
props
.
length
(
)
)
;
jsid
*
ids
=
props
.
begin
(
)
+
firstElemIndex
;
size_t
n
=
props
.
length
(
)
-
firstElemIndex
;
RootedIdVector
tmp
(
cx
)
;
if
(
!
tmp
.
resize
(
n
)
)
{
return
false
;
}
PodCopy
(
tmp
.
begin
(
)
ids
n
)
;
if
(
!
MergeSort
(
ids
n
tmp
.
begin
(
)
SortComparatorIntegerIds
)
)
{
return
false
;
}
}
size_t
initialLength
=
props
.
length
(
)
;
bool
symbolsFound
=
false
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
pobj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
jsid
id
=
iter
-
>
key
(
)
;
if
(
id
.
isSymbol
(
)
)
{
symbolsFound
=
true
;
continue
;
}
uint32_t
dummy
;
if
(
isIndexed
&
&
IdIsIndex
(
id
&
dummy
)
)
{
continue
;
}
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
id
iter
-
>
enumerable
(
)
flags
visited
props
)
)
{
return
false
;
}
}
std
:
:
reverse
(
props
.
begin
(
)
+
initialLength
props
.
end
(
)
)
;
enumerateSymbols
=
symbolsFound
&
&
(
flags
&
JSITER_SYMBOLS
)
;
}
if
(
enumerateSymbols
)
{
MOZ_ASSERT
(
iterShapeProperties
)
;
size_t
initialLength
=
props
.
length
(
)
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
pobj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
jsid
id
=
iter
-
>
key
(
)
;
if
(
id
.
isSymbol
(
)
)
{
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
id
iter
-
>
enumerable
(
)
flags
visited
props
)
)
{
return
false
;
}
}
}
std
:
:
reverse
(
props
.
begin
(
)
+
initialLength
props
.
end
(
)
)
;
}
return
true
;
}
static
bool
EnumerateNativeProperties
(
JSContext
*
cx
Handle
<
NativeObject
*
>
pobj
unsigned
flags
MutableHandle
<
PropertyKeySet
>
visited
MutableHandleIdVector
props
bool
checkForDuplicates
)
{
if
(
checkForDuplicates
)
{
return
EnumerateNativeProperties
<
true
>
(
cx
pobj
flags
visited
props
)
;
}
return
EnumerateNativeProperties
<
false
>
(
cx
pobj
flags
visited
props
)
;
}
template
<
bool
CheckForDuplicates
>
static
bool
EnumerateProxyProperties
(
JSContext
*
cx
HandleObject
pobj
unsigned
flags
MutableHandle
<
PropertyKeySet
>
visited
MutableHandleIdVector
props
)
{
MOZ_ASSERT
(
pobj
-
>
is
<
ProxyObject
>
(
)
)
;
RootedIdVector
proxyProps
(
cx
)
;
if
(
flags
&
JSITER_HIDDEN
|
|
flags
&
JSITER_SYMBOLS
)
{
if
(
!
Proxy
:
:
ownPropertyKeys
(
cx
pobj
&
proxyProps
)
)
{
return
false
;
}
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
for
(
size_t
n
=
0
len
=
proxyProps
.
length
(
)
;
n
<
len
;
n
+
+
)
{
bool
enumerable
=
false
;
if
(
!
(
flags
&
JSITER_HIDDEN
)
)
{
if
(
!
Proxy
:
:
getOwnPropertyDescriptor
(
cx
pobj
proxyProps
[
n
]
&
desc
)
)
{
return
false
;
}
enumerable
=
desc
.
isSome
(
)
&
&
desc
-
>
enumerable
(
)
;
}
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
proxyProps
[
n
]
enumerable
flags
visited
props
)
)
{
return
false
;
}
}
return
true
;
}
if
(
!
Proxy
:
:
getOwnEnumerablePropertyKeys
(
cx
pobj
&
proxyProps
)
)
{
return
false
;
}
for
(
size_t
n
=
0
len
=
proxyProps
.
length
(
)
;
n
<
len
;
n
+
+
)
{
if
(
!
Enumerate
<
CheckForDuplicates
>
(
cx
pobj
proxyProps
[
n
]
true
flags
visited
props
)
)
{
return
false
;
}
}
return
true
;
}
#
ifdef
DEBUG
struct
SortComparatorIds
{
JSContext
*
const
cx
;
explicit
SortComparatorIds
(
JSContext
*
cx
)
:
cx
(
cx
)
{
}
bool
operator
(
)
(
jsid
aArg
jsid
bArg
bool
*
lessOrEqualp
)
{
RootedId
a
(
cx
aArg
)
;
RootedId
b
(
cx
bArg
)
;
if
(
a
=
=
b
)
{
*
lessOrEqualp
=
true
;
return
true
;
}
enum
class
KeyType
{
Void
Int
String
Symbol
}
;
auto
keyType
=
[
]
(
PropertyKey
key
)
{
if
(
key
.
isString
(
)
)
{
return
KeyType
:
:
String
;
}
if
(
key
.
isInt
(
)
)
{
return
KeyType
:
:
Int
;
}
if
(
key
.
isSymbol
(
)
)
{
return
KeyType
:
:
Symbol
;
}
MOZ_ASSERT
(
key
.
isVoid
(
)
)
;
return
KeyType
:
:
Void
;
}
;
if
(
keyType
(
a
)
!
=
keyType
(
b
)
)
{
*
lessOrEqualp
=
(
keyType
(
a
)
<
=
keyType
(
b
)
)
;
return
true
;
}
if
(
a
.
isInt
(
)
)
{
*
lessOrEqualp
=
(
a
.
toInt
(
)
<
=
b
.
toInt
(
)
)
;
return
true
;
}
RootedString
astr
(
cx
)
bstr
(
cx
)
;
if
(
a
.
isSymbol
(
)
)
{
MOZ_ASSERT
(
b
.
isSymbol
(
)
)
;
JS
:
:
SymbolCode
ca
=
a
.
toSymbol
(
)
-
>
code
(
)
;
JS
:
:
SymbolCode
cb
=
b
.
toSymbol
(
)
-
>
code
(
)
;
if
(
ca
!
=
cb
)
{
*
lessOrEqualp
=
uint32_t
(
ca
)
<
=
uint32_t
(
cb
)
;
return
true
;
}
MOZ_ASSERT
(
ca
=
=
JS
:
:
SymbolCode
:
:
PrivateNameSymbol
|
|
ca
=
=
JS
:
:
SymbolCode
:
:
InSymbolRegistry
|
|
ca
=
=
JS
:
:
SymbolCode
:
:
UniqueSymbol
)
;
astr
=
a
.
toSymbol
(
)
-
>
description
(
)
;
bstr
=
b
.
toSymbol
(
)
-
>
description
(
)
;
if
(
!
astr
|
|
!
bstr
)
{
*
lessOrEqualp
=
!
astr
;
return
true
;
}
}
else
{
astr
=
IdToString
(
cx
a
)
;
if
(
!
astr
)
{
return
false
;
}
bstr
=
IdToString
(
cx
b
)
;
if
(
!
bstr
)
{
return
false
;
}
}
int32_t
result
;
if
(
!
CompareStrings
(
cx
astr
bstr
&
result
)
)
{
return
false
;
}
*
lessOrEqualp
=
(
result
<
=
0
)
;
return
true
;
}
}
;
#
endif
static
void
AssertNoEnumerableProperties
(
NativeObject
*
obj
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
obj
-
>
hasEnumerableProperty
(
)
)
;
static
constexpr
size_t
MaxPropsToCheck
=
5
;
size_t
count
=
0
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
obj
-
>
shape
(
)
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
MOZ_ASSERT
(
!
iter
-
>
enumerable
(
)
)
;
if
(
+
+
count
>
MaxPropsToCheck
)
{
break
;
}
}
#
endif
}
static
bool
ClassCanHaveExtraEnumeratedProperties
(
const
JSClass
*
clasp
)
{
return
IsTypedArrayClass
(
clasp
)
|
|
clasp
-
>
getNewEnumerate
(
)
|
|
clasp
-
>
getEnumerate
(
)
;
}
static
bool
ProtoMayHaveEnumerableProperties
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
true
;
}
JSObject
*
proto
=
obj
-
>
as
<
NativeObject
>
(
)
.
staticPrototype
(
)
;
while
(
proto
)
{
if
(
!
proto
-
>
is
<
NativeObject
>
(
)
)
{
return
true
;
}
NativeObject
*
nproto
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
if
(
nproto
-
>
hasEnumerableProperty
(
)
|
|
nproto
-
>
getDenseInitializedLength
(
)
>
0
|
|
ClassCanHaveExtraEnumeratedProperties
(
nproto
-
>
getClass
(
)
)
)
{
return
true
;
}
AssertNoEnumerableProperties
(
nproto
)
;
proto
=
nproto
-
>
staticPrototype
(
)
;
}
return
false
;
}
static
bool
Snapshot
(
JSContext
*
cx
HandleObject
pobj_
unsigned
flags
MutableHandleIdVector
props
)
{
Rooted
<
PropertyKeySet
>
visited
(
cx
PropertyKeySet
(
cx
)
)
;
RootedObject
pobj
(
cx
pobj_
)
;
if
(
!
(
flags
&
JSITER_HIDDEN
)
&
&
!
(
flags
&
JSITER_OWNONLY
)
&
&
!
ProtoMayHaveEnumerableProperties
(
pobj
)
)
{
flags
|
=
JSITER_OWNONLY
;
}
bool
checkForDuplicates
=
!
(
flags
&
JSITER_OWNONLY
)
;
do
{
if
(
pobj
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
)
{
if
(
!
EnumerateExtraProperties
(
cx
pobj
flags
&
visited
props
)
)
{
return
false
;
}
if
(
pobj
-
>
is
<
NativeObject
>
(
)
)
{
if
(
!
EnumerateNativeProperties
(
cx
pobj
.
as
<
NativeObject
>
(
)
flags
&
visited
props
true
)
)
{
return
false
;
}
}
}
else
if
(
pobj
-
>
is
<
NativeObject
>
(
)
)
{
if
(
JSEnumerateOp
enumerate
=
pobj
-
>
getClass
(
)
-
>
getEnumerate
(
)
)
{
if
(
!
enumerate
(
cx
pobj
.
as
<
NativeObject
>
(
)
)
)
{
return
false
;
}
}
if
(
!
EnumerateNativeProperties
(
cx
pobj
.
as
<
NativeObject
>
(
)
flags
&
visited
props
checkForDuplicates
)
)
{
return
false
;
}
}
else
if
(
pobj
-
>
is
<
ProxyObject
>
(
)
)
{
if
(
checkForDuplicates
)
{
if
(
!
EnumerateProxyProperties
<
true
>
(
cx
pobj
flags
&
visited
props
)
)
{
return
false
;
}
}
else
{
if
(
!
EnumerateProxyProperties
<
false
>
(
cx
pobj
flags
&
visited
props
)
)
{
return
false
;
}
}
}
else
{
MOZ_CRASH
(
"
non
-
native
objects
must
have
an
enumerate
op
"
)
;
}
if
(
flags
&
JSITER_OWNONLY
)
{
break
;
}
if
(
!
GetPrototype
(
cx
pobj
&
pobj
)
)
{
return
false
;
}
if
(
!
CheckForInterrupt
(
cx
)
)
{
return
false
;
}
}
while
(
pobj
!
=
nullptr
)
;
#
ifdef
DEBUG
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
jsid
*
ids
=
props
.
begin
(
)
;
size_t
n
=
props
.
length
(
)
;
RootedIdVector
tmp
(
cx
)
;
if
(
!
tmp
.
resize
(
n
)
)
{
return
false
;
}
PodCopy
(
tmp
.
begin
(
)
ids
n
)
;
if
(
!
MergeSort
(
ids
n
tmp
.
begin
(
)
SortComparatorIds
(
cx
)
)
)
{
return
false
;
}
}
#
endif
return
true
;
}
JS_PUBLIC_API
bool
js
:
:
GetPropertyKeys
(
JSContext
*
cx
HandleObject
obj
unsigned
flags
MutableHandleIdVector
props
)
{
return
Snapshot
(
cx
obj
flags
&
(
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
|
JSITER_SYMBOLSONLY
|
JSITER_PRIVATE
)
props
)
;
}
static
inline
void
RegisterEnumerator
(
NativeIterator
*
ni
)
{
MOZ_ASSERT
(
ni
-
>
objectBeingIterated
(
)
)
;
ObjectRealm
&
realm
=
ObjectRealm
:
:
get
(
ni
-
>
objectBeingIterated
(
)
)
;
ni
-
>
link
(
realm
.
enumerators
)
;
MOZ_ASSERT
(
!
ni
-
>
isActive
(
)
)
;
ni
-
>
markActive
(
)
;
}
static
PropertyIteratorObject
*
NewPropertyIteratorObject
(
JSContext
*
cx
)
{
const
JSClass
*
clasp
=
&
PropertyIteratorObject
:
:
class_
;
Rooted
<
Shape
*
>
shape
(
cx
SharedShape
:
:
getInitialShape
(
cx
clasp
cx
-
>
realm
(
)
TaggedProto
(
nullptr
)
ITERATOR_FINALIZE_KIND
)
)
;
if
(
!
shape
)
{
return
nullptr
;
}
JSObject
*
obj
=
NativeObject
:
:
create
(
cx
ITERATOR_FINALIZE_KIND
GetInitialHeap
(
GenericObject
clasp
)
shape
)
;
if
(
!
obj
)
{
return
nullptr
;
}
PropertyIteratorObject
*
res
=
&
obj
-
>
as
<
PropertyIteratorObject
>
(
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
res
)
)
;
return
res
;
}
static
inline
size_t
NumTrailingWords
(
size_t
propertyCount
size_t
shapeCount
)
{
static_assert
(
sizeof
(
GCPtr
<
JSLinearString
*
>
)
=
=
sizeof
(
uintptr_t
)
)
;
static_assert
(
sizeof
(
GCPtr
<
Shape
*
>
)
=
=
sizeof
(
uintptr_t
)
)
;
return
propertyCount
+
shapeCount
;
}
static
inline
size_t
AllocationSize
(
size_t
propertyCount
size_t
shapeCount
)
{
return
sizeof
(
NativeIterator
)
+
(
NumTrailingWords
(
propertyCount
shapeCount
)
*
sizeof
(
uintptr_t
)
)
;
}
static
PropertyIteratorObject
*
CreatePropertyIterator
(
JSContext
*
cx
Handle
<
JSObject
*
>
objBeingIterated
HandleIdVector
props
uint32_t
numShapes
HashNumber
shapesHash
)
{
if
(
props
.
length
(
)
>
NativeIterator
:
:
PropCountLimit
)
{
ReportAllocationOverflow
(
cx
)
;
return
nullptr
;
}
Rooted
<
PropertyIteratorObject
*
>
propIter
(
cx
NewPropertyIteratorObject
(
cx
)
)
;
if
(
!
propIter
)
{
return
nullptr
;
}
void
*
mem
=
cx
-
>
pod_malloc_with_extra
<
NativeIterator
uintptr_t
>
(
NumTrailingWords
(
props
.
length
(
)
numShapes
)
)
;
if
(
!
mem
)
{
return
nullptr
;
}
bool
hadError
=
false
;
new
(
mem
)
NativeIterator
(
cx
propIter
objBeingIterated
props
numShapes
shapesHash
&
hadError
)
;
if
(
hadError
)
{
return
nullptr
;
}
return
propIter
;
}
NativeIterator
:
:
NativeIterator
(
)
{
AlwaysPoison
(
static_cast
<
void
*
>
(
this
)
JS_NEW_NATIVE_ITERATOR_PATTERN
sizeof
(
*
this
)
MemCheckKind
:
:
MakeUndefined
)
;
prev_
=
next_
=
this
;
}
NativeIterator
*
NativeIterator
:
:
allocateSentinel
(
JSContext
*
cx
)
{
NativeIterator
*
ni
=
js_new
<
NativeIterator
>
(
)
;
if
(
!
ni
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
ni
;
}
static
HashNumber
HashIteratorShape
(
Shape
*
shape
)
{
return
DefaultHasher
<
Shape
*
>
:
:
hash
(
shape
)
;
}
NativeIterator
:
:
NativeIterator
(
JSContext
*
cx
Handle
<
PropertyIteratorObject
*
>
propIter
Handle
<
JSObject
*
>
objBeingIterated
HandleIdVector
props
uint32_t
numShapes
HashNumber
shapesHash
bool
*
hadError
)
:
objectBeingIterated_
(
objBeingIterated
)
iterObj_
(
propIter
)
shapesEnd_
(
shapesBegin
(
)
)
propertyCursor_
(
reinterpret_cast
<
GCPtr
<
JSLinearString
*
>
*
>
(
shapesBegin
(
)
+
numShapes
)
)
propertiesEnd_
(
propertyCursor_
)
shapesHash_
(
shapesHash
)
flagsAndCount_
(
initialFlagsAndCount
(
props
.
length
(
)
)
)
{
MOZ_ASSERT_IF
(
numShapes
>
0
objBeingIterated
&
&
objBeingIterated
-
>
is
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
!
*
hadError
)
;
propIter
-
>
initNativeIterator
(
this
)
;
size_t
nbytes
=
AllocationSize
(
props
.
length
(
)
numShapes
)
;
AddCellMemory
(
propIter
nbytes
MemoryUse
:
:
NativeIterator
)
;
if
(
numShapes
>
0
)
{
JSObject
*
pobj
=
objBeingIterated
;
#
ifdef
DEBUG
uint32_t
i
=
0
;
#
endif
HashNumber
shapesHash
=
0
;
do
{
MOZ_ASSERT
(
pobj
-
>
is
<
NativeObject
>
(
)
)
;
Shape
*
shape
=
pobj
-
>
shape
(
)
;
new
(
shapesEnd_
)
GCPtr
<
Shape
*
>
(
shape
)
;
shapesEnd_
+
+
;
#
ifdef
DEBUG
i
+
+
;
#
endif
shapesHash
=
mozilla
:
:
AddToHash
(
shapesHash
HashIteratorShape
(
shape
)
)
;
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
while
(
pobj
)
;
shapesHash_
=
shapesHash
;
MOZ_ASSERT
(
i
=
=
numShapes
)
;
}
MOZ_ASSERT
(
static_cast
<
void
*
>
(
shapesEnd_
)
=
=
propertyCursor_
)
;
for
(
size_t
i
=
0
len
=
props
.
length
(
)
;
i
<
len
;
i
+
+
)
{
JSLinearString
*
str
=
IdToString
(
cx
props
[
i
]
)
;
if
(
!
str
)
{
*
hadError
=
true
;
return
;
}
new
(
propertiesEnd_
)
GCPtr
<
JSLinearString
*
>
(
str
)
;
propertiesEnd_
+
+
;
}
markInitialized
(
)
;
MOZ_ASSERT
(
!
*
hadError
)
;
}
inline
size_t
NativeIterator
:
:
allocationSize
(
)
const
{
size_t
numShapes
=
shapesEnd
(
)
-
shapesBegin
(
)
;
return
AllocationSize
(
initialPropertyCount
(
)
numShapes
)
;
}
bool
IteratorHashPolicy
:
:
match
(
PropertyIteratorObject
*
obj
const
Lookup
&
lookup
)
{
NativeIterator
*
ni
=
obj
-
>
getNativeIterator
(
)
;
if
(
ni
-
>
shapesHash
(
)
!
=
lookup
.
shapesHash
|
|
ni
-
>
shapeCount
(
)
!
=
lookup
.
numShapes
)
{
return
false
;
}
return
ArrayEqual
(
reinterpret_cast
<
Shape
*
*
>
(
ni
-
>
shapesBegin
(
)
)
lookup
.
shapes
ni
-
>
shapeCount
(
)
)
;
}
static
inline
bool
CanCompareIterableObjectToCache
(
JSObject
*
obj
)
{
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
=
=
0
;
}
return
false
;
}
static
MOZ_ALWAYS_INLINE
PropertyIteratorObject
*
LookupInIteratorCache
(
JSContext
*
cx
JSObject
*
obj
uint32_t
*
numShapes
)
{
MOZ_ASSERT
(
*
numShapes
=
=
0
)
;
Vector
<
Shape
*
8
>
shapes
(
cx
)
;
HashNumber
shapesHash
=
0
;
JSObject
*
pobj
=
obj
;
do
{
if
(
!
CanCompareIterableObjectToCache
(
pobj
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
pobj
-
>
is
<
NativeObject
>
(
)
)
;
Shape
*
shape
=
pobj
-
>
shape
(
)
;
shapesHash
=
mozilla
:
:
AddToHash
(
shapesHash
HashIteratorShape
(
shape
)
)
;
if
(
MOZ_UNLIKELY
(
!
shapes
.
append
(
shape
)
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
nullptr
;
}
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
while
(
pobj
)
;
MOZ_ASSERT
(
!
shapes
.
empty
(
)
)
;
*
numShapes
=
shapes
.
length
(
)
;
IteratorHashPolicy
:
:
Lookup
lookup
(
shapes
.
begin
(
)
shapes
.
length
(
)
shapesHash
)
;
auto
p
=
ObjectRealm
:
:
get
(
obj
)
.
iteratorCache
.
lookup
(
lookup
)
;
if
(
!
p
)
{
return
nullptr
;
}
PropertyIteratorObject
*
iterobj
=
*
p
;
MOZ_ASSERT
(
iterobj
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
NativeIterator
*
ni
=
iterobj
-
>
getNativeIterator
(
)
;
if
(
!
ni
-
>
isReusable
(
)
)
{
return
nullptr
;
}
return
iterobj
;
}
static
bool
CanStoreInIteratorCache
(
JSObject
*
obj
)
{
do
{
MOZ_ASSERT
(
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
=
=
0
)
;
if
(
MOZ_UNLIKELY
(
ClassCanHaveExtraEnumeratedProperties
(
obj
-
>
getClass
(
)
)
)
)
{
return
false
;
}
obj
=
obj
-
>
staticPrototype
(
)
;
}
while
(
obj
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
StoreInIteratorCache
(
JSContext
*
cx
JSObject
*
obj
PropertyIteratorObject
*
iterobj
)
{
MOZ_ASSERT
(
CanStoreInIteratorCache
(
obj
)
)
;
NativeIterator
*
ni
=
iterobj
-
>
getNativeIterator
(
)
;
MOZ_ASSERT
(
ni
-
>
shapeCount
(
)
>
0
)
;
IteratorHashPolicy
:
:
Lookup
lookup
(
reinterpret_cast
<
Shape
*
*
>
(
ni
-
>
shapesBegin
(
)
)
ni
-
>
shapeCount
(
)
ni
-
>
shapesHash
(
)
)
;
ObjectRealm
:
:
IteratorCache
&
cache
=
ObjectRealm
:
:
get
(
obj
)
.
iteratorCache
;
bool
ok
;
auto
p
=
cache
.
lookupForAdd
(
lookup
)
;
if
(
MOZ_LIKELY
(
!
p
)
)
{
ok
=
cache
.
add
(
p
iterobj
)
;
}
else
{
cache
.
remove
(
p
)
;
ok
=
cache
.
relookupOrAdd
(
p
lookup
iterobj
)
;
}
if
(
!
ok
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
EnumerateProperties
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
props
)
{
MOZ_ASSERT
(
props
.
empty
(
)
)
;
if
(
MOZ_UNLIKELY
(
obj
-
>
is
<
ProxyObject
>
(
)
)
)
{
return
Proxy
:
:
enumerate
(
cx
obj
props
)
;
}
return
Snapshot
(
cx
obj
0
props
)
;
}
static
JSObject
*
GetIterator
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
PropertyIteratorObject
>
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
"
We
may
end
up
allocating
shapes
in
the
wrong
zone
!
"
)
;
uint32_t
numShapes
=
0
;
if
(
PropertyIteratorObject
*
iterobj
=
LookupInIteratorCache
(
cx
obj
&
numShapes
)
)
{
NativeIterator
*
ni
=
iterobj
-
>
getNativeIterator
(
)
;
ni
-
>
initObjectBeingIterated
(
*
obj
)
;
RegisterEnumerator
(
ni
)
;
return
iterobj
;
}
if
(
numShapes
>
0
&
&
!
CanStoreInIteratorCache
(
obj
)
)
{
numShapes
=
0
;
}
RootedIdVector
keys
(
cx
)
;
if
(
!
EnumerateProperties
(
cx
obj
&
keys
)
)
{
return
nullptr
;
}
if
(
obj
-
>
is
<
NativeObject
>
(
)
&
&
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
>
0
)
{
obj
-
>
as
<
NativeObject
>
(
)
.
markDenseElementsMaybeInIteration
(
)
;
}
PropertyIteratorObject
*
iterobj
=
CreatePropertyIterator
(
cx
obj
keys
numShapes
0
)
;
if
(
!
iterobj
)
{
return
nullptr
;
}
RegisterEnumerator
(
iterobj
-
>
getNativeIterator
(
)
)
;
cx
-
>
check
(
iterobj
)
;
#
ifdef
DEBUG
if
(
obj
-
>
is
<
NativeObject
>
(
)
)
{
if
(
PrototypeMayHaveIndexedProperties
(
&
obj
-
>
as
<
NativeObject
>
(
)
)
)
{
iterobj
-
>
getNativeIterator
(
)
-
>
setMaybeHasIndexedPropertiesFromProto
(
)
;
}
}
#
endif
if
(
numShapes
>
0
)
{
if
(
!
StoreInIteratorCache
(
cx
obj
iterobj
)
)
{
return
nullptr
;
}
}
return
iterobj
;
}
PropertyIteratorObject
*
js
:
:
LookupInIteratorCache
(
JSContext
*
cx
HandleObject
obj
)
{
uint32_t
numShapes
=
0
;
return
LookupInIteratorCache
(
cx
obj
&
numShapes
)
;
}
PlainObject
*
js
:
:
CreateIterResultObject
(
JSContext
*
cx
HandleValue
value
bool
done
)
{
Rooted
<
PlainObject
*
>
templateObject
(
cx
GlobalObject
:
:
getOrCreateIterResultTemplateObject
(
cx
)
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
PlainObject
*
resultObj
=
PlainObject
:
:
createWithTemplate
(
cx
templateObject
)
;
if
(
!
resultObj
)
{
return
nullptr
;
}
resultObj
-
>
setSlot
(
GlobalObject
:
:
IterResultObjectValueSlot
value
)
;
resultObj
-
>
setSlot
(
GlobalObject
:
:
IterResultObjectDoneSlot
done
?
TrueHandleValue
:
FalseHandleValue
)
;
return
resultObj
;
}
PlainObject
*
GlobalObject
:
:
getOrCreateIterResultTemplateObject
(
JSContext
*
cx
)
{
HeapPtr
<
PlainObject
*
>
&
obj
=
cx
-
>
global
(
)
-
>
data
(
)
.
iterResultTemplate
;
if
(
obj
)
{
return
obj
;
}
PlainObject
*
templateObj
=
createIterResultTemplateObject
(
cx
WithObjectPrototype
:
:
Yes
)
;
obj
.
init
(
templateObj
)
;
return
obj
;
}
PlainObject
*
GlobalObject
:
:
getOrCreateIterResultWithoutPrototypeTemplateObject
(
JSContext
*
cx
)
{
HeapPtr
<
PlainObject
*
>
&
obj
=
cx
-
>
global
(
)
-
>
data
(
)
.
iterResultWithoutPrototypeTemplate
;
if
(
obj
)
{
return
obj
;
}
PlainObject
*
templateObj
=
createIterResultTemplateObject
(
cx
WithObjectPrototype
:
:
No
)
;
obj
.
init
(
templateObj
)
;
return
obj
;
}
PlainObject
*
GlobalObject
:
:
createIterResultTemplateObject
(
JSContext
*
cx
WithObjectPrototype
withProto
)
{
Rooted
<
PlainObject
*
>
templateObject
(
cx
withProto
=
=
WithObjectPrototype
:
:
Yes
?
NewPlainObject
(
cx
TenuredObject
)
:
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
if
(
!
NativeDefineDataProperty
(
cx
templateObject
cx
-
>
names
(
)
.
value
UndefinedHandleValue
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
if
(
!
NativeDefineDataProperty
(
cx
templateObject
cx
-
>
names
(
)
.
done
TrueHandleValue
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
#
ifdef
DEBUG
ShapePropertyIter
<
NoGC
>
iter
(
templateObject
-
>
shape
(
)
)
;
MOZ_ASSERT
(
iter
-
>
slot
(
)
=
=
GlobalObject
:
:
IterResultObjectDoneSlot
&
&
iter
-
>
key
(
)
=
=
NameToId
(
cx
-
>
names
(
)
.
done
)
)
;
iter
+
+
;
MOZ_ASSERT
(
iter
-
>
slot
(
)
=
=
GlobalObject
:
:
IterResultObjectValueSlot
&
&
iter
-
>
key
(
)
=
=
NameToId
(
cx
-
>
names
(
)
.
value
)
)
;
#
endif
return
templateObject
;
}
size_t
PropertyIteratorObject
:
:
sizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
getNativeIterator
(
)
)
;
}
void
PropertyIteratorObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
if
(
NativeIterator
*
ni
=
obj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
)
{
ni
-
>
trace
(
trc
)
;
}
}
void
PropertyIteratorObject
:
:
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
if
(
NativeIterator
*
ni
=
obj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
)
{
gcx
-
>
free_
(
obj
ni
ni
-
>
allocationSize
(
)
MemoryUse
:
:
NativeIterator
)
;
}
}
const
JSClassOps
PropertyIteratorObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
finalize
nullptr
nullptr
trace
}
;
const
JSClass
PropertyIteratorObject
:
:
class_
=
{
"
Iterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_BACKGROUND_FINALIZE
&
PropertyIteratorObject
:
:
classOps_
}
;
static
const
JSClass
ArrayIteratorPrototypeClass
=
{
"
Array
Iterator
"
0
}
;
enum
{
ArrayIteratorSlotIteratedObject
ArrayIteratorSlotNextIndex
ArrayIteratorSlotItemKind
ArrayIteratorSlotCount
}
;
const
JSClass
ArrayIteratorObject
:
:
class_
=
{
"
Array
Iterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
ArrayIteratorSlotCount
)
}
;
ArrayIteratorObject
*
js
:
:
NewArrayIteratorTemplate
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateArrayIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewTenuredObjectWithGivenProto
<
ArrayIteratorObject
>
(
cx
proto
)
;
}
ArrayIteratorObject
*
js
:
:
NewArrayIterator
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateArrayIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
<
ArrayIteratorObject
>
(
cx
proto
)
;
}
static
const
JSFunctionSpec
array_iterator_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
next
"
"
ArrayIteratorNext
"
0
0
)
JS_FS_END
}
;
static
const
JSClass
StringIteratorPrototypeClass
=
{
"
String
Iterator
"
0
}
;
enum
{
StringIteratorSlotIteratedObject
StringIteratorSlotNextIndex
StringIteratorSlotCount
}
;
const
JSClass
StringIteratorObject
:
:
class_
=
{
"
String
Iterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
StringIteratorSlotCount
)
}
;
static
const
JSFunctionSpec
string_iterator_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
next
"
"
StringIteratorNext
"
0
0
)
JS_FS_END
}
;
StringIteratorObject
*
js
:
:
NewStringIteratorTemplate
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateStringIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewTenuredObjectWithGivenProto
<
StringIteratorObject
>
(
cx
proto
)
;
}
StringIteratorObject
*
js
:
:
NewStringIterator
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateStringIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
<
StringIteratorObject
>
(
cx
proto
)
;
}
static
const
JSClass
RegExpStringIteratorPrototypeClass
=
{
"
RegExp
String
Iterator
"
0
}
;
enum
{
RegExpStringIteratorSlotRegExp
RegExpStringIteratorSlotString
RegExpStringIteratorSlotSource
RegExpStringIteratorSlotFlags
RegExpStringIteratorSlotLastIndex
RegExpStringIteratorSlotCount
}
;
static_assert
(
RegExpStringIteratorSlotRegExp
=
=
REGEXP_STRING_ITERATOR_REGEXP_SLOT
"
RegExpStringIteratorSlotRegExp
must
match
self
-
hosting
define
"
"
for
regexp
slot
.
"
)
;
static_assert
(
RegExpStringIteratorSlotString
=
=
REGEXP_STRING_ITERATOR_STRING_SLOT
"
RegExpStringIteratorSlotString
must
match
self
-
hosting
define
"
"
for
string
slot
.
"
)
;
static_assert
(
RegExpStringIteratorSlotSource
=
=
REGEXP_STRING_ITERATOR_SOURCE_SLOT
"
RegExpStringIteratorSlotString
must
match
self
-
hosting
define
"
"
for
source
slot
.
"
)
;
static_assert
(
RegExpStringIteratorSlotFlags
=
=
REGEXP_STRING_ITERATOR_FLAGS_SLOT
"
RegExpStringIteratorSlotFlags
must
match
self
-
hosting
define
"
"
for
flags
slot
.
"
)
;
static_assert
(
RegExpStringIteratorSlotLastIndex
=
=
REGEXP_STRING_ITERATOR_LASTINDEX_SLOT
"
RegExpStringIteratorSlotLastIndex
must
match
self
-
hosting
"
"
define
for
lastIndex
slot
.
"
)
;
const
JSClass
RegExpStringIteratorObject
:
:
class_
=
{
"
RegExp
String
Iterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
RegExpStringIteratorSlotCount
)
}
;
static
const
JSFunctionSpec
regexp_string_iterator_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
next
"
"
RegExpStringIteratorNext
"
0
0
)
JS_FS_END
}
;
RegExpStringIteratorObject
*
js
:
:
NewRegExpStringIteratorTemplate
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateRegExpStringIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewTenuredObjectWithGivenProto
<
RegExpStringIteratorObject
>
(
cx
proto
)
;
}
RegExpStringIteratorObject
*
js
:
:
NewRegExpStringIterator
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateRegExpStringIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
<
RegExpStringIteratorObject
>
(
cx
proto
)
;
}
PropertyIteratorObject
*
GlobalObject
:
:
getOrCreateEmptyIterator
(
JSContext
*
cx
)
{
if
(
!
cx
-
>
global
(
)
-
>
data
(
)
.
emptyIterator
)
{
RootedIdVector
props
(
cx
)
;
PropertyIteratorObject
*
iter
=
CreatePropertyIterator
(
cx
nullptr
props
0
0
)
;
if
(
!
iter
)
{
return
nullptr
;
}
iter
-
>
getNativeIterator
(
)
-
>
markEmptyIteratorSingleton
(
)
;
cx
-
>
global
(
)
-
>
data
(
)
.
emptyIterator
.
init
(
iter
)
;
}
return
cx
-
>
global
(
)
-
>
data
(
)
.
emptyIterator
;
}
JSObject
*
js
:
:
ValueToIterator
(
JSContext
*
cx
HandleValue
vp
)
{
RootedObject
obj
(
cx
)
;
if
(
vp
.
isObject
(
)
)
{
obj
=
&
vp
.
toObject
(
)
;
}
else
if
(
vp
.
isNullOrUndefined
(
)
)
{
return
GlobalObject
:
:
getOrCreateEmptyIterator
(
cx
)
;
}
else
{
obj
=
ToObject
(
cx
vp
)
;
if
(
!
obj
)
{
return
nullptr
;
}
}
return
GetIterator
(
cx
obj
)
;
}
void
js
:
:
CloseIterator
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
PropertyIteratorObject
>
(
)
)
{
return
;
}
NativeIterator
*
ni
=
obj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
;
if
(
ni
-
>
isEmptyIteratorSingleton
(
)
)
{
return
;
}
ni
-
>
unlink
(
)
;
MOZ_ASSERT
(
ni
-
>
isActive
(
)
)
;
ni
-
>
markInactive
(
)
;
ni
-
>
clearObjectBeingIterated
(
)
;
ni
-
>
resetPropertyCursorForReuse
(
)
;
}
bool
js
:
:
IteratorCloseForException
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
isExceptionPending
(
)
)
;
bool
isClosingGenerator
=
cx
-
>
isClosingGenerator
(
)
;
JS
:
:
AutoSaveExceptionState
savedExc
(
cx
)
;
RootedValue
returnMethod
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
return_
&
returnMethod
)
)
{
return
false
;
}
if
(
returnMethod
.
isNullOrUndefined
(
)
)
{
return
true
;
}
if
(
!
IsCallable
(
returnMethod
)
)
{
return
ReportIsNotFunction
(
cx
returnMethod
)
;
}
RootedValue
rval
(
cx
)
;
bool
ok
=
Call
(
cx
returnMethod
obj
&
rval
)
;
if
(
isClosingGenerator
)
{
if
(
!
ok
)
{
return
false
;
}
if
(
!
rval
.
isObject
(
)
)
{
return
ThrowCheckIsObject
(
cx
CheckIsObjectKind
:
:
IteratorReturn
)
;
}
}
else
{
savedExc
.
restore
(
)
;
}
return
true
;
}
void
js
:
:
UnwindIteratorForUncatchableException
(
JSObject
*
obj
)
{
if
(
obj
-
>
is
<
PropertyIteratorObject
>
(
)
)
{
NativeIterator
*
ni
=
obj
-
>
as
<
PropertyIteratorObject
>
(
)
.
getNativeIterator
(
)
;
if
(
ni
-
>
isEmptyIteratorSingleton
(
)
)
{
return
;
}
ni
-
>
unlink
(
)
;
}
}
static
bool
SuppressDeletedProperty
(
JSContext
*
cx
NativeIterator
*
ni
HandleObject
obj
Handle
<
JSLinearString
*
>
str
)
{
if
(
ni
-
>
objectBeingIterated
(
)
!
=
obj
)
{
return
true
;
}
if
(
ni
-
>
previousPropertyWas
(
str
)
)
{
return
true
;
}
while
(
true
)
{
bool
restart
=
false
;
GCPtr
<
JSLinearString
*
>
*
const
cursor
=
ni
-
>
nextProperty
(
)
;
GCPtr
<
JSLinearString
*
>
*
const
end
=
ni
-
>
propertiesEnd
(
)
;
for
(
GCPtr
<
JSLinearString
*
>
*
idp
=
cursor
;
idp
<
end
;
+
+
idp
)
{
if
(
(
*
idp
)
-
>
isAtom
(
)
&
&
str
-
>
isAtom
(
)
)
{
if
(
*
idp
!
=
str
)
{
continue
;
}
}
else
{
if
(
!
EqualStrings
(
*
idp
str
)
)
{
continue
;
}
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototype
(
cx
obj
&
proto
)
)
{
return
false
;
}
if
(
proto
)
{
RootedId
id
(
cx
)
;
RootedValue
idv
(
cx
StringValue
(
*
idp
)
)
;
if
(
!
PrimitiveValueToId
<
CanGC
>
(
cx
idv
&
id
)
)
{
return
false
;
}
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
GetPropertyDescriptor
(
cx
proto
id
&
desc
&
holder
)
)
{
return
false
;
}
if
(
desc
.
isSome
(
)
&
&
desc
-
>
enumerable
(
)
)
{
continue
;
}
}
if
(
end
!
=
ni
-
>
propertiesEnd
(
)
|
|
cursor
!
=
ni
-
>
nextProperty
(
)
)
{
restart
=
true
;
break
;
}
if
(
idp
=
=
cursor
)
{
ni
-
>
incCursor
(
)
;
}
else
{
for
(
GCPtr
<
JSLinearString
*
>
*
p
=
idp
;
p
+
1
!
=
end
;
p
+
+
)
{
*
p
=
*
(
p
+
1
)
;
}
ni
-
>
trimLastProperty
(
)
;
}
ni
-
>
markHasUnvisitedPropertyDeletion
(
)
;
return
true
;
}
if
(
!
restart
)
{
return
true
;
}
}
}
static
bool
SuppressDeletedPropertyHelper
(
JSContext
*
cx
HandleObject
obj
Handle
<
JSLinearString
*
>
str
)
{
NativeIterator
*
enumeratorList
=
ObjectRealm
:
:
get
(
obj
)
.
enumerators
;
NativeIterator
*
ni
=
enumeratorList
-
>
next
(
)
;
while
(
ni
!
=
enumeratorList
)
{
if
(
!
SuppressDeletedProperty
(
cx
ni
obj
str
)
)
{
return
false
;
}
ni
=
ni
-
>
next
(
)
;
}
return
true
;
}
bool
js
:
:
SuppressDeletedProperty
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
{
if
(
MOZ_LIKELY
(
!
ObjectRealm
:
:
get
(
obj
)
.
objectMaybeInIteration
(
obj
)
)
)
{
return
true
;
}
if
(
id
.
isSymbol
(
)
)
{
return
true
;
}
Rooted
<
JSLinearString
*
>
str
(
cx
IdToString
(
cx
id
)
)
;
if
(
!
str
)
{
return
false
;
}
return
SuppressDeletedPropertyHelper
(
cx
obj
str
)
;
}
bool
js
:
:
SuppressDeletedElement
(
JSContext
*
cx
HandleObject
obj
uint32_t
index
)
{
if
(
MOZ_LIKELY
(
!
ObjectRealm
:
:
get
(
obj
)
.
objectMaybeInIteration
(
obj
)
)
)
{
return
true
;
}
RootedId
id
(
cx
)
;
if
(
!
IndexToId
(
cx
index
&
id
)
)
{
return
false
;
}
Rooted
<
JSLinearString
*
>
str
(
cx
IdToString
(
cx
id
)
)
;
if
(
!
str
)
{
return
false
;
}
return
SuppressDeletedPropertyHelper
(
cx
obj
str
)
;
}
#
ifdef
DEBUG
void
js
:
:
AssertDenseElementsNotIterated
(
NativeObject
*
obj
)
{
static
constexpr
uint32_t
MaxPropsToCheck
=
10
;
uint32_t
propsChecked
=
0
;
NativeIterator
*
enumeratorList
=
ObjectRealm
:
:
get
(
obj
)
.
enumerators
;
NativeIterator
*
ni
=
enumeratorList
-
>
next
(
)
;
while
(
ni
!
=
enumeratorList
)
{
if
(
ni
-
>
objectBeingIterated
(
)
=
=
obj
&
&
!
ni
-
>
maybeHasIndexedPropertiesFromProto
(
)
)
{
for
(
GCPtr
<
JSLinearString
*
>
*
idp
=
ni
-
>
nextProperty
(
)
;
idp
<
ni
-
>
propertiesEnd
(
)
;
+
+
idp
)
{
uint32_t
index
;
if
(
idp
-
>
get
(
)
-
>
isIndex
(
&
index
)
)
{
MOZ_ASSERT
(
!
obj
-
>
containsDenseElement
(
index
)
)
;
}
if
(
+
+
propsChecked
>
MaxPropsToCheck
)
{
return
;
}
}
}
ni
=
ni
-
>
next
(
)
;
}
}
#
endif
static
const
JSFunctionSpec
iterator_methods
[
]
=
{
JS_SELF_HOSTED_SYM_FN
(
iterator
"
IteratorIdentity
"
0
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
iterator_static_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
from
"
"
IteratorFrom
"
1
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
iterator_methods_with_helpers
[
]
=
{
JS_SELF_HOSTED_FN
(
"
map
"
"
IteratorMap
"
1
0
)
JS_SELF_HOSTED_FN
(
"
filter
"
"
IteratorFilter
"
1
0
)
JS_SELF_HOSTED_FN
(
"
take
"
"
IteratorTake
"
1
0
)
JS_SELF_HOSTED_FN
(
"
drop
"
"
IteratorDrop
"
1
0
)
JS_SELF_HOSTED_FN
(
"
asIndexedPairs
"
"
IteratorAsIndexedPairs
"
0
0
)
JS_SELF_HOSTED_FN
(
"
flatMap
"
"
IteratorFlatMap
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reduce
"
"
IteratorReduce
"
1
0
)
JS_SELF_HOSTED_FN
(
"
toArray
"
"
IteratorToArray
"
0
0
)
JS_SELF_HOSTED_FN
(
"
forEach
"
"
IteratorForEach
"
1
0
)
JS_SELF_HOSTED_FN
(
"
some
"
"
IteratorSome
"
1
0
)
JS_SELF_HOSTED_FN
(
"
every
"
"
IteratorEvery
"
1
0
)
JS_SELF_HOSTED_FN
(
"
find
"
"
IteratorFind
"
1
0
)
JS_SELF_HOSTED_SYM_FN
(
iterator
"
IteratorIdentity
"
0
0
)
JS_FS_END
}
;
bool
GlobalObject
:
:
initIteratorProto
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
if
(
global
-
>
hasBuiltinProto
(
ProtoKind
:
:
IteratorProto
)
)
{
return
true
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototype
<
PlainObject
>
(
cx
global
)
)
;
if
(
!
proto
)
{
return
false
;
}
global
-
>
initBuiltinProto
(
ProtoKind
:
:
IteratorProto
proto
)
;
if
(
!
DefinePropertiesAndFunctions
(
cx
proto
nullptr
iterator_methods
)
)
{
return
false
;
}
return
true
;
}
template
<
GlobalObject
:
:
ProtoKind
Kind
const
JSClass
*
ProtoClass
const
JSFunctionSpec
*
Methods
>
bool
GlobalObject
:
:
initObjectIteratorProto
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
Handle
<
JSAtom
*
>
tag
)
{
if
(
global
-
>
hasBuiltinProto
(
Kind
)
)
{
return
true
;
}
RootedObject
iteratorProto
(
cx
GlobalObject
:
:
getOrCreateIteratorPrototype
(
cx
global
)
)
;
if
(
!
iteratorProto
)
{
return
false
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
createBlankPrototypeInheriting
(
cx
ProtoClass
iteratorProto
)
)
;
if
(
!
proto
|
|
!
DefinePropertiesAndFunctions
(
cx
proto
nullptr
Methods
)
|
|
(
tag
&
&
!
DefineToStringTag
(
cx
proto
tag
)
)
)
{
return
false
;
}
global
-
>
initBuiltinProto
(
Kind
proto
)
;
return
true
;
}
NativeObject
*
GlobalObject
:
:
getOrCreateArrayIteratorPrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
return
MaybeNativeObject
(
getOrCreateBuiltinProto
(
cx
global
ProtoKind
:
:
ArrayIteratorProto
cx
-
>
names
(
)
.
ArrayIterator
.
toHandle
(
)
initObjectIteratorProto
<
ProtoKind
:
:
ArrayIteratorProto
&
ArrayIteratorPrototypeClass
array_iterator_methods
>
)
)
;
}
JSObject
*
GlobalObject
:
:
getOrCreateStringIteratorPrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
return
getOrCreateBuiltinProto
(
cx
global
ProtoKind
:
:
StringIteratorProto
cx
-
>
names
(
)
.
StringIterator
.
toHandle
(
)
initObjectIteratorProto
<
ProtoKind
:
:
StringIteratorProto
&
StringIteratorPrototypeClass
string_iterator_methods
>
)
;
}
JSObject
*
GlobalObject
:
:
getOrCreateRegExpStringIteratorPrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
return
getOrCreateBuiltinProto
(
cx
global
ProtoKind
:
:
RegExpStringIteratorProto
cx
-
>
names
(
)
.
RegExpStringIterator
.
toHandle
(
)
initObjectIteratorProto
<
ProtoKind
:
:
RegExpStringIteratorProto
&
RegExpStringIteratorPrototypeClass
regexp_string_iterator_methods
>
)
;
}
static
bool
IteratorConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
js_Iterator_str
)
)
{
return
false
;
}
if
(
args
.
callee
(
)
=
=
args
.
newTarget
(
)
.
toObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BOGUS_CONSTRUCTOR
js_Iterator_str
)
;
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Iterator
&
proto
)
)
{
return
false
;
}
JSObject
*
obj
=
NewObjectWithClassProto
<
IteratorObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
const
ClassSpec
IteratorObjectClassSpec
=
{
GenericCreateConstructor
<
IteratorConstructor
0
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
IteratorObject
>
iterator_static_methods
nullptr
iterator_methods_with_helpers
nullptr
nullptr
}
;
const
JSClass
IteratorObject
:
:
class_
=
{
js_Iterator_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Iterator
)
JS_NULL_CLASS_OPS
&
IteratorObjectClassSpec
}
;
const
JSClass
IteratorObject
:
:
protoClass_
=
{
"
Iterator
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Iterator
)
JS_NULL_CLASS_OPS
&
IteratorObjectClassSpec
}
;
static
const
JSFunctionSpec
wrap_for_valid_iterator_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
next
"
"
WrapForValidIteratorNext
"
1
0
)
JS_SELF_HOSTED_FN
(
"
return
"
"
WrapForValidIteratorReturn
"
1
0
)
JS_SELF_HOSTED_FN
(
"
throw
"
"
WrapForValidIteratorThrow
"
1
0
)
JS_FS_END
}
;
static
const
JSClass
WrapForValidIteratorPrototypeClass
=
{
"
Wrap
For
Valid
Iterator
"
0
}
;
const
JSClass
WrapForValidIteratorObject
:
:
class_
=
{
"
Wrap
For
Valid
Iterator
"
JSCLASS_HAS_RESERVED_SLOTS
(
WrapForValidIteratorObject
:
:
SlotCount
)
}
;
NativeObject
*
GlobalObject
:
:
getOrCreateWrapForValidIteratorPrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
return
MaybeNativeObject
(
getOrCreateBuiltinProto
(
cx
global
ProtoKind
:
:
WrapForValidIteratorProto
Handle
<
JSAtom
*
>
(
nullptr
)
initObjectIteratorProto
<
ProtoKind
:
:
WrapForValidIteratorProto
&
WrapForValidIteratorPrototypeClass
wrap_for_valid_iterator_methods
>
)
)
;
}
WrapForValidIteratorObject
*
js
:
:
NewWrapForValidIterator
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateWrapForValidIteratorPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
<
WrapForValidIteratorObject
>
(
cx
proto
)
;
}
static
const
JSFunctionSpec
iterator_helper_methods
[
]
=
{
JS_SELF_HOSTED_FN
(
"
next
"
"
IteratorHelperNext
"
1
0
)
JS_SELF_HOSTED_FN
(
"
return
"
"
IteratorHelperReturn
"
1
0
)
JS_SELF_HOSTED_FN
(
"
throw
"
"
IteratorHelperThrow
"
1
0
)
JS_FS_END
}
;
static
const
JSClass
IteratorHelperPrototypeClass
=
{
"
Iterator
Helper
"
0
}
;
const
JSClass
IteratorHelperObject
:
:
class_
=
{
"
Iterator
Helper
"
JSCLASS_HAS_RESERVED_SLOTS
(
IteratorHelperObject
:
:
SlotCount
)
}
;
NativeObject
*
GlobalObject
:
:
getOrCreateIteratorHelperPrototype
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
return
MaybeNativeObject
(
getOrCreateBuiltinProto
(
cx
global
ProtoKind
:
:
IteratorHelperProto
Handle
<
JSAtom
*
>
(
nullptr
)
initObjectIteratorProto
<
ProtoKind
:
:
IteratorHelperProto
&
IteratorHelperPrototypeClass
iterator_helper_methods
>
)
)
;
}
IteratorHelperObject
*
js
:
:
NewIteratorHelper
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreateIteratorHelperPrototype
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
return
NewObjectWithGivenProto
<
IteratorHelperObject
>
(
cx
proto
)
;
}
bool
js
:
:
IterableToArray
(
JSContext
*
cx
HandleValue
iterable
MutableHandle
<
ArrayObject
*
>
array
)
{
JS
:
:
ForOfIterator
iterator
(
cx
)
;
if
(
!
iterator
.
init
(
iterable
JS
:
:
ForOfIterator
:
:
ThrowOnNonIterable
)
)
{
return
false
;
}
array
.
set
(
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
array
)
{
return
false
;
}
RootedValue
nextValue
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iterator
.
next
(
&
nextValue
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
NewbornArrayPush
(
cx
array
nextValue
)
)
{
return
false
;
}
}
return
true
;
}
