#
ifndef
vm_ScopeObject_h
#
define
vm_ScopeObject_h
#
include
"
jscntxt
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
jsweakmap
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
ProxyObject
.
h
"
namespace
js
{
namespace
frontend
{
struct
Definition
;
class
FunctionBox
;
class
ModuleBox
;
}
class
StaticWithScope
;
class
StaticEvalScope
;
class
StaticNonSyntacticScope
;
class
ModuleObject
;
typedef
Handle
<
ModuleObject
*
>
HandleModuleObject
;
class
StaticScope
:
public
NativeObject
{
public
:
static
const
uint32_t
ENCLOSING_SCOPE_SLOT
=
0
;
static
const
unsigned
RESERVED_SLOTS
=
ENCLOSING_SCOPE_SLOT
+
1
;
inline
JSObject
*
enclosingScope
(
)
const
{
return
getFixedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObjectOrNull
(
)
;
}
void
initEnclosingScope
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
getReservedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
isUndefined
(
)
)
;
setReservedSlot
(
ENCLOSING_SCOPE_SLOT
ObjectOrNullValue
(
obj
)
)
;
}
void
setEnclosingScope
(
HandleObject
obj
)
;
}
;
class
NestedStaticScope
:
public
StaticScope
{
public
:
inline
NestedStaticScope
*
enclosingNestedScope
(
)
const
;
void
initEnclosingScopeFromParser
(
JSObject
*
prev
)
{
setReservedSlot
(
ENCLOSING_SCOPE_SLOT
ObjectOrNullValue
(
prev
)
)
;
}
void
resetEnclosingScopeFromParser
(
)
{
setReservedSlot
(
ENCLOSING_SCOPE_SLOT
UndefinedValue
(
)
)
;
}
}
;
class
StaticBlockScope
:
public
NestedStaticScope
{
static
const
unsigned
LOCAL_OFFSET_SLOT
=
NestedStaticScope
:
:
RESERVED_SLOTS
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
LOCAL_OFFSET_SLOT
+
1
;
uint32_t
numVariables
(
)
const
{
return
propertyCount
(
)
;
}
private
:
const
Value
&
slotValue
(
unsigned
i
)
{
return
getSlotRef
(
RESERVED_SLOTS
+
i
)
;
}
void
setSlotValue
(
unsigned
i
const
Value
&
v
)
{
setSlot
(
RESERVED_SLOTS
+
i
v
)
;
}
public
:
static
StaticBlockScope
*
create
(
ExclusiveContext
*
cx
)
;
bool
isExtensible
(
)
const
;
JSObject
*
enclosingStaticScope
(
)
const
{
return
getFixedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObjectOrNull
(
)
;
}
uint32_t
shapeToIndex
(
const
Shape
&
shape
)
{
uint32_t
slot
=
shape
.
slot
(
)
;
MOZ_ASSERT
(
slot
-
RESERVED_SLOTS
<
numVariables
(
)
)
;
return
slot
-
RESERVED_SLOTS
;
}
inline
StaticBlockScope
*
enclosingBlock
(
)
const
;
uint32_t
localOffset
(
)
{
return
getReservedSlot
(
LOCAL_OFFSET_SLOT
)
.
toPrivateUint32
(
)
;
}
uint32_t
blockIndexToLocalIndex
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
numVariables
(
)
)
;
return
getReservedSlot
(
LOCAL_OFFSET_SLOT
)
.
toPrivateUint32
(
)
+
index
;
}
uint32_t
blockIndexToSlot
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
numVariables
(
)
)
;
return
RESERVED_SLOTS
+
index
;
}
uint32_t
localIndexToSlot
(
uint32_t
local
)
{
MOZ_ASSERT
(
local
>
=
localOffset
(
)
)
;
return
blockIndexToSlot
(
local
-
localOffset
(
)
)
;
}
bool
isAliased
(
unsigned
i
)
{
return
slotValue
(
i
)
.
isTrue
(
)
;
}
Shape
*
lookupAliasedName
(
PropertyName
*
name
)
;
bool
needsClone
(
)
{
return
numVariables
(
)
>
0
&
&
!
getSlot
(
RESERVED_SLOTS
)
.
isFalse
(
)
;
}
bool
isGlobal
(
)
const
{
return
!
enclosingStaticScope
(
)
;
}
bool
isSyntactic
(
)
const
{
return
!
isExtensible
(
)
|
|
isGlobal
(
)
;
}
void
setAliased
(
unsigned
i
bool
aliased
)
{
MOZ_ASSERT_IF
(
i
>
0
slotValue
(
i
-
1
)
.
isBoolean
(
)
)
;
setSlotValue
(
i
BooleanValue
(
aliased
)
)
;
if
(
aliased
&
&
!
needsClone
(
)
)
{
setSlotValue
(
0
MagicValue
(
JS_BLOCK_NEEDS_CLONE
)
)
;
MOZ_ASSERT
(
needsClone
(
)
)
;
}
}
void
setLocalOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
getReservedSlot
(
LOCAL_OFFSET_SLOT
)
.
isUndefined
(
)
)
;
initReservedSlot
(
LOCAL_OFFSET_SLOT
PrivateUint32Value
(
offset
)
)
;
}
void
setDefinitionParseNode
(
unsigned
i
frontend
:
:
Definition
*
def
)
{
MOZ_ASSERT
(
slotValue
(
i
)
.
isUndefined
(
)
)
;
setSlotValue
(
i
PrivateValue
(
def
)
)
;
}
void
updateDefinitionParseNode
(
unsigned
i
frontend
:
:
Definition
*
oldDef
frontend
:
:
Definition
*
newDef
)
{
MOZ_ASSERT
(
definitionParseNode
(
i
)
=
=
oldDef
)
;
setSlotValue
(
i
PrivateValue
(
newDef
)
)
;
}
frontend
:
:
Definition
*
definitionParseNode
(
unsigned
i
)
{
Value
v
=
slotValue
(
i
)
;
return
reinterpret_cast
<
frontend
:
:
Definition
*
>
(
v
.
toPrivate
(
)
)
;
}
bool
makeNonExtensible
(
ExclusiveContext
*
cx
)
;
static
const
unsigned
LOCAL_INDEX_LIMIT
=
JS_BIT
(
16
)
;
static
Shape
*
addVar
(
ExclusiveContext
*
cx
Handle
<
StaticBlockScope
*
>
block
HandleId
id
bool
constant
unsigned
index
bool
*
redeclared
)
;
}
;
class
StaticWithScope
:
public
NestedStaticScope
{
public
:
static
const
Class
class_
;
static
StaticWithScope
*
create
(
ExclusiveContext
*
cx
)
;
}
;
template
<
XDRMode
mode
>
bool
XDRStaticWithScope
(
XDRState
<
mode
>
*
xdr
HandleObject
enclosingScope
MutableHandle
<
StaticWithScope
*
>
objp
)
;
class
StaticEvalScope
:
public
StaticScope
{
static
const
uint32_t
STRICT_SLOT
=
StaticScope
:
:
RESERVED_SLOTS
;
static
const
unsigned
RESERVED_SLOTS
=
STRICT_SLOT
+
1
;
public
:
static
const
Class
class_
;
static
StaticEvalScope
*
create
(
JSContext
*
cx
HandleObject
enclosing
)
;
JSObject
*
enclosingScopeForStaticScopeIter
(
)
{
return
getReservedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObjectOrNull
(
)
;
}
void
setStrict
(
)
{
setReservedSlot
(
STRICT_SLOT
BooleanValue
(
true
)
)
;
}
bool
isStrict
(
)
const
{
return
getReservedSlot
(
STRICT_SLOT
)
.
isTrue
(
)
;
}
inline
bool
isNonGlobal
(
)
const
;
}
;
class
StaticNonSyntacticScope
:
public
StaticScope
{
public
:
static
const
unsigned
RESERVED_SLOTS
=
StaticScope
:
:
RESERVED_SLOTS
;
static
const
Class
class_
;
static
StaticNonSyntacticScope
*
create
(
JSContext
*
cx
HandleObject
enclosing
)
;
JSObject
*
enclosingScopeForStaticScopeIter
(
)
{
return
getReservedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObjectOrNull
(
)
;
}
}
;
template
<
AllowGC
allowGC
>
class
StaticScopeIter
{
typename
MaybeRooted
<
JSObject
*
allowGC
>
:
:
RootType
obj
;
bool
onNamedLambda
;
static
bool
IsStaticScope
(
JSObject
*
obj
)
{
return
obj
-
>
is
<
StaticBlockScope
>
(
)
|
|
obj
-
>
is
<
StaticWithScope
>
(
)
|
|
obj
-
>
is
<
StaticEvalScope
>
(
)
|
|
obj
-
>
is
<
StaticNonSyntacticScope
>
(
)
|
|
obj
-
>
is
<
JSFunction
>
(
)
|
|
obj
-
>
is
<
ModuleObject
>
(
)
;
}
public
:
StaticScopeIter
(
ExclusiveContext
*
cx
JSObject
*
obj
)
:
obj
(
cx
obj
)
onNamedLambda
(
false
)
{
static_assert
(
allowGC
=
=
CanGC
"
the
context
-
accepting
constructor
should
only
be
used
"
"
in
CanGC
code
"
)
;
MOZ_ASSERT_IF
(
obj
IsStaticScope
(
obj
)
)
;
}
StaticScopeIter
(
ExclusiveContext
*
cx
const
StaticScopeIter
<
CanGC
>
&
ssi
)
:
obj
(
cx
ssi
.
obj
)
onNamedLambda
(
ssi
.
onNamedLambda
)
{
JS_STATIC_ASSERT
(
allowGC
=
=
CanGC
)
;
}
explicit
StaticScopeIter
(
JSObject
*
obj
)
:
obj
(
(
ExclusiveContext
*
)
nullptr
obj
)
onNamedLambda
(
false
)
{
static_assert
(
allowGC
=
=
NoGC
"
the
constructor
not
taking
a
context
should
only
be
"
"
used
in
NoGC
code
"
)
;
MOZ_ASSERT_IF
(
obj
IsStaticScope
(
obj
)
)
;
}
explicit
StaticScopeIter
(
const
StaticScopeIter
<
NoGC
>
&
ssi
)
:
obj
(
(
ExclusiveContext
*
)
nullptr
ssi
.
obj
)
onNamedLambda
(
ssi
.
onNamedLambda
)
{
static_assert
(
allowGC
=
=
NoGC
"
the
constructor
not
taking
a
context
should
only
be
"
"
used
in
NoGC
code
"
)
;
}
bool
done
(
)
const
{
return
!
obj
;
}
void
operator
+
+
(
int
)
;
JSObject
*
staticScope
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
obj
;
}
bool
hasSyntacticDynamicScopeObject
(
)
const
;
Shape
*
scopeShape
(
)
const
;
enum
Type
{
Module
Function
Block
With
NamedLambda
Eval
NonSyntactic
}
;
Type
type
(
)
const
;
StaticBlockScope
&
block
(
)
const
;
StaticWithScope
&
staticWith
(
)
const
;
StaticEvalScope
&
eval
(
)
const
;
StaticNonSyntacticScope
&
nonSyntactic
(
)
const
;
JSScript
*
funScript
(
)
const
;
JSFunction
&
fun
(
)
const
;
frontend
:
:
FunctionBox
*
maybeFunctionBox
(
)
const
;
JSScript
*
moduleScript
(
)
const
;
ModuleObject
&
module
(
)
const
;
}
;
class
ScopeCoordinate
{
uint32_t
hops_
;
uint32_t
slot_
;
static_assert
(
SCOPECOORD_HOPS_BITS
<
=
32
"
We
have
enough
bits
below
"
)
;
static_assert
(
SCOPECOORD_SLOT_BITS
<
=
32
"
We
have
enough
bits
below
"
)
;
public
:
explicit
inline
ScopeCoordinate
(
jsbytecode
*
pc
)
:
hops_
(
GET_SCOPECOORD_HOPS
(
pc
)
)
slot_
(
GET_SCOPECOORD_SLOT
(
pc
+
SCOPECOORD_HOPS_LEN
)
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_SCOPECOORD
)
;
}
inline
ScopeCoordinate
(
)
{
}
void
setHops
(
uint32_t
hops
)
{
MOZ_ASSERT
(
hops
<
SCOPECOORD_HOPS_LIMIT
)
;
hops_
=
hops
;
}
void
setSlot
(
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
SCOPECOORD_SLOT_LIMIT
)
;
slot_
=
slot
;
}
uint32_t
hops
(
)
const
{
MOZ_ASSERT
(
hops_
<
SCOPECOORD_HOPS_LIMIT
)
;
return
hops_
;
}
uint32_t
slot
(
)
const
{
MOZ_ASSERT
(
slot_
<
SCOPECOORD_SLOT_LIMIT
)
;
return
slot_
;
}
bool
operator
=
=
(
const
ScopeCoordinate
&
rhs
)
const
{
return
hops
(
)
=
=
rhs
.
hops
(
)
&
&
slot
(
)
=
=
rhs
.
slot
(
)
;
}
}
;
extern
Shape
*
ScopeCoordinateToStaticScopeShape
(
JSScript
*
script
jsbytecode
*
pc
)
;
extern
PropertyName
*
ScopeCoordinateName
(
ScopeCoordinateNameCache
&
cache
JSScript
*
script
jsbytecode
*
pc
)
;
extern
JSScript
*
ScopeCoordinateFunctionScript
(
JSScript
*
script
jsbytecode
*
pc
)
;
class
ScopeObject
:
public
NativeObject
{
protected
:
static
const
uint32_t
SCOPE_CHAIN_SLOT
=
0
;
public
:
inline
JSObject
&
enclosingScope
(
)
const
{
return
getFixedSlot
(
SCOPE_CHAIN_SLOT
)
.
toObject
(
)
;
}
void
setEnclosingScope
(
HandleObject
obj
)
;
inline
const
Value
&
aliasedVar
(
ScopeCoordinate
sc
)
;
inline
void
setAliasedVar
(
JSContext
*
cx
ScopeCoordinate
sc
PropertyName
*
name
const
Value
&
v
)
;
static
size_t
offsetOfEnclosingScope
(
)
{
return
getFixedSlotOffset
(
SCOPE_CHAIN_SLOT
)
;
}
static
size_t
enclosingScopeSlot
(
)
{
return
SCOPE_CHAIN_SLOT
;
}
}
;
class
LexicalScopeBase
:
public
ScopeObject
{
protected
:
inline
void
initRemainingSlotsToUninitializedLexicals
(
uint32_t
begin
)
;
inline
void
initAliasedLexicalsToThrowOnTouch
(
JSScript
*
script
)
;
public
:
const
Value
&
aliasedVar
(
AliasedFormalIter
fi
)
{
return
getSlot
(
fi
.
scopeSlot
(
)
)
;
}
inline
void
setAliasedVar
(
JSContext
*
cx
AliasedFormalIter
fi
PropertyName
*
name
const
Value
&
v
)
;
const
Value
&
aliasedVarFromArguments
(
const
Value
&
argsValue
)
{
return
getSlot
(
ArgumentsObject
:
:
SlotFromMagicScopeSlotValue
(
argsValue
)
)
;
}
inline
void
setAliasedVarFromArguments
(
JSContext
*
cx
const
Value
&
argsValue
jsid
id
const
Value
&
v
)
;
}
;
class
CallObject
:
public
LexicalScopeBase
{
protected
:
static
const
uint32_t
CALLEE_SLOT
=
1
;
static
CallObject
*
create
(
JSContext
*
cx
HandleScript
script
HandleObject
enclosing
HandleFunction
callee
)
;
public
:
static
const
Class
class_
;
static
CallObject
*
create
(
JSContext
*
cx
HandleShape
shape
HandleObjectGroup
group
uint32_t
lexicalBegin
)
;
static
CallObject
*
createSingleton
(
JSContext
*
cx
HandleShape
shape
uint32_t
lexicalBegin
)
;
static
CallObject
*
createTemplateObject
(
JSContext
*
cx
HandleScript
script
gc
:
:
InitialHeap
heap
)
;
static
const
uint32_t
RESERVED_SLOTS
=
2
;
static
CallObject
*
createForFunction
(
JSContext
*
cx
HandleObject
enclosing
HandleFunction
callee
)
;
static
CallObject
*
createForFunction
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
CallObject
*
createForStrictEval
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
CallObject
*
createHollowForDebug
(
JSContext
*
cx
HandleFunction
callee
)
;
bool
isForEval
(
)
const
{
if
(
is
<
ModuleEnvironmentObject
>
(
)
)
return
false
;
MOZ_ASSERT
(
getFixedSlot
(
CALLEE_SLOT
)
.
isObjectOrNull
(
)
)
;
MOZ_ASSERT_IF
(
getFixedSlot
(
CALLEE_SLOT
)
.
isObject
(
)
getFixedSlot
(
CALLEE_SLOT
)
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
return
getFixedSlot
(
CALLEE_SLOT
)
.
isNull
(
)
;
}
JSFunction
&
callee
(
)
const
{
MOZ_ASSERT
(
!
is
<
ModuleEnvironmentObject
>
(
)
)
;
return
getFixedSlot
(
CALLEE_SLOT
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
static
size_t
offsetOfCallee
(
)
{
return
getFixedSlotOffset
(
CALLEE_SLOT
)
;
}
static
size_t
calleeSlot
(
)
{
return
CALLEE_SLOT
;
}
}
;
class
ModuleEnvironmentObject
:
public
LexicalScopeBase
{
static
const
uint32_t
MODULE_SLOT
=
1
;
public
:
static
const
Class
class_
;
static
const
uint32_t
RESERVED_SLOTS
=
2
;
static
ModuleEnvironmentObject
*
create
(
ExclusiveContext
*
cx
HandleModuleObject
module
)
;
ModuleObject
&
module
(
)
;
IndirectBindingMap
&
importBindings
(
)
;
bool
createImportBinding
(
JSContext
*
cx
HandleAtom
importName
HandleModuleObject
module
HandleAtom
exportName
)
;
bool
hasImportBinding
(
HandlePropertyName
name
)
;
bool
lookupImport
(
jsid
name
ModuleEnvironmentObject
*
*
envOut
Shape
*
*
shapeOut
)
;
private
:
static
bool
lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
MutableHandleShape
propp
)
;
static
bool
hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
static
bool
getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
static
bool
setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
JS
:
:
ObjectOpResult
&
result
)
;
static
bool
getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
;
static
bool
deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
static
bool
enumerate
(
JSContext
*
cx
HandleObject
obj
AutoIdVector
&
properties
bool
enumerableOnly
)
;
}
;
typedef
Rooted
<
ModuleEnvironmentObject
*
>
RootedModuleEnvironmentObject
;
typedef
Handle
<
ModuleEnvironmentObject
*
>
HandleModuleEnvironmentObject
;
typedef
MutableHandle
<
ModuleEnvironmentObject
*
>
MutableHandleModuleEnvironmentObject
;
class
DeclEnvObject
:
public
ScopeObject
{
static
const
uint32_t
LAMBDA_SLOT
=
1
;
public
:
static
const
uint32_t
RESERVED_SLOTS
=
2
;
static
const
Class
class_
;
static
DeclEnvObject
*
createTemplateObject
(
JSContext
*
cx
HandleFunction
fun
NewObjectKind
newKind
)
;
static
DeclEnvObject
*
create
(
JSContext
*
cx
HandleObject
enclosing
HandleFunction
callee
)
;
static
inline
size_t
lambdaSlot
(
)
{
return
LAMBDA_SLOT
;
}
}
;
class
NonSyntacticVariablesObject
:
public
ScopeObject
{
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
Class
class_
;
static
NonSyntacticVariablesObject
*
create
(
JSContext
*
cx
Handle
<
ClonedBlockObject
*
>
globalLexical
)
;
}
;
class
NestedScopeObject
:
public
ScopeObject
{
public
:
inline
NestedStaticScope
*
staticScope
(
)
{
return
&
getProto
(
)
-
>
as
<
NestedStaticScope
>
(
)
;
}
void
initEnclosingScope
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
getReservedSlot
(
SCOPE_CHAIN_SLOT
)
.
isUndefined
(
)
)
;
setReservedSlot
(
SCOPE_CHAIN_SLOT
ObjectOrNullValue
(
obj
)
)
;
}
}
;
class
DynamicWithObject
:
public
NestedScopeObject
{
static
const
unsigned
OBJECT_SLOT
=
1
;
static
const
unsigned
THIS_SLOT
=
2
;
static
const
unsigned
KIND_SLOT
=
3
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
4
;
static
const
Class
class_
;
enum
WithKind
{
SyntacticWith
NonSyntacticWith
}
;
static
DynamicWithObject
*
create
(
JSContext
*
cx
HandleObject
object
HandleObject
enclosing
HandleObject
staticWith
WithKind
kind
=
SyntacticWith
)
;
StaticWithScope
&
staticWith
(
)
const
{
return
getProto
(
)
-
>
as
<
StaticWithScope
>
(
)
;
}
JSObject
&
object
(
)
const
{
return
getReservedSlot
(
OBJECT_SLOT
)
.
toObject
(
)
;
}
JSObject
*
withThis
(
)
const
{
return
&
getReservedSlot
(
THIS_SLOT
)
.
toObject
(
)
;
}
bool
isSyntactic
(
)
const
{
return
getReservedSlot
(
KIND_SLOT
)
.
toInt32
(
)
=
=
SyntacticWith
;
}
static
inline
size_t
objectSlot
(
)
{
return
OBJECT_SLOT
;
}
static
inline
size_t
thisSlot
(
)
{
return
THIS_SLOT
;
}
}
;
class
ClonedBlockObject
:
public
NestedScopeObject
{
static
const
unsigned
THIS_VALUE_SLOT
=
1
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
2
;
static
const
Class
class_
;
private
:
static
ClonedBlockObject
*
create
(
JSContext
*
cx
Handle
<
StaticBlockScope
*
>
block
HandleObject
enclosing
)
;
public
:
static
ClonedBlockObject
*
create
(
JSContext
*
cx
Handle
<
StaticBlockScope
*
>
block
AbstractFramePtr
frame
)
;
static
ClonedBlockObject
*
createGlobal
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
ClonedBlockObject
*
createNonSyntactic
(
JSContext
*
cx
HandleObject
enclosingStatic
HandleObject
enclosingScope
)
;
static
ClonedBlockObject
*
createHollowForDebug
(
JSContext
*
cx
Handle
<
StaticBlockScope
*
>
block
)
;
uint32_t
numVariables
(
)
const
{
return
propertyCount
(
)
;
}
bool
isExtensible
(
)
const
;
private
:
const
Value
&
slotValue
(
unsigned
i
)
{
return
getSlotRef
(
RESERVED_SLOTS
+
i
)
;
}
void
setSlotValue
(
unsigned
i
const
Value
&
v
)
{
setSlot
(
RESERVED_SLOTS
+
i
v
)
;
}
public
:
StaticBlockScope
&
staticBlock
(
)
const
{
return
getProto
(
)
-
>
as
<
StaticBlockScope
>
(
)
;
}
const
Value
&
var
(
unsigned
i
MaybeCheckAliasing
checkAliasing
=
CHECK_ALIASING
)
{
MOZ_ASSERT_IF
(
checkAliasing
staticBlock
(
)
.
isAliased
(
i
)
)
;
return
slotValue
(
i
)
;
}
void
setVar
(
unsigned
i
const
Value
&
v
MaybeCheckAliasing
checkAliasing
=
CHECK_ALIASING
)
{
MOZ_ASSERT_IF
(
checkAliasing
staticBlock
(
)
.
isAliased
(
i
)
)
;
setSlotValue
(
i
v
)
;
}
bool
isGlobal
(
)
const
{
MOZ_ASSERT_IF
(
staticBlock
(
)
.
isGlobal
(
)
enclosingScope
(
)
.
is
<
GlobalObject
>
(
)
)
;
return
enclosingScope
(
)
.
is
<
GlobalObject
>
(
)
;
}
GlobalObject
&
global
(
)
const
{
MOZ_ASSERT
(
isGlobal
(
)
)
;
return
enclosingScope
(
)
.
as
<
GlobalObject
>
(
)
;
}
bool
isSyntactic
(
)
const
{
return
!
isExtensible
(
)
|
|
isGlobal
(
)
;
}
void
copyUnaliasedValues
(
AbstractFramePtr
frame
)
;
static
ClonedBlockObject
*
clone
(
JSContext
*
cx
Handle
<
ClonedBlockObject
*
>
block
)
;
Value
thisValue
(
)
const
;
}
;
class
RuntimeLexicalErrorObject
:
public
ScopeObject
{
static
const
unsigned
ERROR_SLOT
=
1
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
2
;
static
const
Class
class_
;
static
RuntimeLexicalErrorObject
*
create
(
JSContext
*
cx
HandleObject
enclosing
unsigned
errorNumber
)
;
unsigned
errorNumber
(
)
{
return
getReservedSlot
(
ERROR_SLOT
)
.
toInt32
(
)
;
}
}
;
template
<
XDRMode
mode
>
bool
XDRStaticBlockScope
(
XDRState
<
mode
>
*
xdr
HandleObject
enclosingScope
MutableHandle
<
StaticBlockScope
*
>
objp
)
;
extern
JSObject
*
CloneNestedScopeObject
(
JSContext
*
cx
HandleObject
enclosingScope
Handle
<
NestedStaticScope
*
>
src
)
;
class
MOZ_RAII
ScopeIter
{
StaticScopeIter
<
CanGC
>
ssi_
;
RootedObject
scope_
;
AbstractFramePtr
frame_
;
void
incrementStaticScopeIter
(
)
;
void
settle
(
)
;
ScopeIter
(
const
ScopeIter
&
si
)
=
delete
;
public
:
ScopeIter
(
JSContext
*
cx
const
ScopeIter
&
si
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
ScopeIter
(
JSContext
*
cx
JSObject
*
scope
JSObject
*
staticScope
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
ScopeIter
(
JSContext
*
cx
AbstractFramePtr
frame
jsbytecode
*
pc
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
inline
bool
done
(
)
const
;
ScopeIter
&
operator
+
+
(
)
;
inline
JSObject
&
enclosingScope
(
)
const
;
enum
Type
{
Module
Call
Block
With
Eval
NonSyntactic
}
;
Type
type
(
)
const
;
inline
bool
hasNonSyntacticScopeObject
(
)
const
;
inline
bool
hasSyntacticScopeObject
(
)
const
;
inline
bool
hasAnyScopeObject
(
)
const
;
inline
bool
canHaveSyntacticScopeObject
(
)
const
;
ScopeObject
&
scope
(
)
const
;
JSObject
*
maybeStaticScope
(
)
const
;
StaticBlockScope
&
staticBlock
(
)
const
{
return
ssi_
.
block
(
)
;
}
StaticWithScope
&
staticWith
(
)
const
{
return
ssi_
.
staticWith
(
)
;
}
StaticEvalScope
&
staticEval
(
)
const
{
return
ssi_
.
eval
(
)
;
}
StaticNonSyntacticScope
&
staticNonSyntactic
(
)
const
{
return
ssi_
.
nonSyntactic
(
)
;
}
JSFunction
&
fun
(
)
const
{
return
ssi_
.
fun
(
)
;
}
ModuleObject
&
module
(
)
const
{
return
ssi_
.
module
(
)
;
}
bool
withinInitialFrame
(
)
const
{
return
!
!
frame_
;
}
AbstractFramePtr
initialFrame
(
)
const
{
MOZ_ASSERT
(
withinInitialFrame
(
)
)
;
return
frame_
;
}
AbstractFramePtr
maybeInitialFrame
(
)
const
{
return
frame_
;
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MissingScopeKey
{
friend
class
LiveScopeVal
;
AbstractFramePtr
frame_
;
JSObject
*
staticScope_
;
public
:
explicit
MissingScopeKey
(
const
ScopeIter
&
si
)
:
frame_
(
si
.
maybeInitialFrame
(
)
)
staticScope_
(
si
.
maybeStaticScope
(
)
)
{
}
AbstractFramePtr
frame
(
)
const
{
return
frame_
;
}
JSObject
*
staticScope
(
)
const
{
return
staticScope_
;
}
void
updateStaticScope
(
JSObject
*
obj
)
{
staticScope_
=
obj
;
}
void
updateFrame
(
AbstractFramePtr
frame
)
{
frame_
=
frame
;
}
typedef
MissingScopeKey
Lookup
;
static
HashNumber
hash
(
MissingScopeKey
sk
)
;
static
bool
match
(
MissingScopeKey
sk1
MissingScopeKey
sk2
)
;
bool
operator
!
=
(
const
MissingScopeKey
&
other
)
const
{
return
frame_
!
=
other
.
frame_
|
|
staticScope_
!
=
other
.
staticScope_
;
}
static
void
rekey
(
MissingScopeKey
&
k
const
MissingScopeKey
&
newKey
)
{
k
=
newKey
;
}
}
;
class
LiveScopeVal
{
friend
class
DebugScopes
;
friend
class
MissingScopeKey
;
AbstractFramePtr
frame_
;
RelocatablePtrObject
staticScope_
;
static
void
staticAsserts
(
)
;
public
:
explicit
LiveScopeVal
(
const
ScopeIter
&
si
)
:
frame_
(
si
.
initialFrame
(
)
)
staticScope_
(
si
.
maybeStaticScope
(
)
)
{
}
AbstractFramePtr
frame
(
)
const
{
return
frame_
;
}
JSObject
*
staticScope
(
)
const
{
return
staticScope_
;
}
void
updateFrame
(
AbstractFramePtr
frame
)
{
frame_
=
frame
;
}
bool
needsSweep
(
)
;
}
;
extern
JSObject
*
GetDebugScopeForFunction
(
JSContext
*
cx
HandleFunction
fun
)
;
extern
JSObject
*
GetDebugScopeForFrame
(
JSContext
*
cx
AbstractFramePtr
frame
jsbytecode
*
pc
)
;
extern
JSObject
*
GetDebugScopeForGlobalLexicalScope
(
JSContext
*
cx
)
;
class
DebugScopeObject
:
public
ProxyObject
{
static
const
unsigned
ENCLOSING_EXTRA
=
0
;
static
const
unsigned
SNAPSHOT_EXTRA
=
1
;
public
:
static
DebugScopeObject
*
create
(
JSContext
*
cx
ScopeObject
&
scope
HandleObject
enclosing
)
;
ScopeObject
&
scope
(
)
const
;
JSObject
&
enclosingScope
(
)
const
;
ArrayObject
*
maybeSnapshot
(
)
const
;
void
initSnapshot
(
ArrayObject
&
snapshot
)
;
bool
isForDeclarative
(
)
const
;
bool
getMaybeSentinelValue
(
JSContext
*
cx
HandleId
id
MutableHandleValue
vp
)
;
bool
isFunctionScopeWithThis
(
)
;
bool
isOptimizedOut
(
)
const
;
}
;
class
DebugScopes
{
ObjectWeakMap
proxiedScopes
;
typedef
HashMap
<
MissingScopeKey
ReadBarrieredDebugScopeObject
MissingScopeKey
RuntimeAllocPolicy
>
MissingScopeMap
;
MissingScopeMap
missingScopes
;
typedef
GCHashMap
<
ReadBarriered
<
ScopeObject
*
>
LiveScopeVal
MovableCellHasher
<
ReadBarriered
<
ScopeObject
*
>
>
RuntimeAllocPolicy
>
LiveScopeMap
;
LiveScopeMap
liveScopes
;
static
MOZ_ALWAYS_INLINE
void
liveScopesPostWriteBarrier
(
JSRuntime
*
rt
LiveScopeMap
*
map
ScopeObject
*
key
)
;
public
:
explicit
DebugScopes
(
JSContext
*
c
)
;
~
DebugScopes
(
)
;
private
:
bool
init
(
)
;
static
DebugScopes
*
ensureCompartmentData
(
JSContext
*
cx
)
;
public
:
void
mark
(
JSTracer
*
trc
)
;
void
sweep
(
JSRuntime
*
rt
)
;
#
ifdef
JS_GC_ZEAL
void
checkHashTablesAfterMovingGC
(
JSRuntime
*
rt
)
;
#
endif
static
DebugScopeObject
*
hasDebugScope
(
JSContext
*
cx
ScopeObject
&
scope
)
;
static
bool
addDebugScope
(
JSContext
*
cx
ScopeObject
&
scope
DebugScopeObject
&
debugScope
)
;
static
DebugScopeObject
*
hasDebugScope
(
JSContext
*
cx
const
ScopeIter
&
si
)
;
static
bool
addDebugScope
(
JSContext
*
cx
const
ScopeIter
&
si
DebugScopeObject
&
debugScope
)
;
static
bool
updateLiveScopes
(
JSContext
*
cx
)
;
static
LiveScopeVal
*
hasLiveScope
(
ScopeObject
&
scope
)
;
static
void
unsetPrevUpToDateUntil
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
void
forwardLiveFrame
(
JSContext
*
cx
AbstractFramePtr
from
AbstractFramePtr
to
)
;
static
void
onPopCall
(
AbstractFramePtr
frame
JSContext
*
cx
)
;
static
void
onPopBlock
(
JSContext
*
cx
const
ScopeIter
&
si
)
;
static
void
onPopBlock
(
JSContext
*
cx
AbstractFramePtr
frame
jsbytecode
*
pc
)
;
static
void
onPopWith
(
AbstractFramePtr
frame
)
;
static
void
onPopStrictEvalScope
(
AbstractFramePtr
frame
)
;
static
void
onCompartmentUnsetIsDebuggee
(
JSCompartment
*
c
)
;
}
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
StaticBlockScope
>
(
)
const
{
return
hasClass
(
&
js
:
:
ClonedBlockObject
:
:
class_
)
&
&
!
getProto
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
NestedStaticScope
>
(
)
const
{
return
is
<
js
:
:
StaticBlockScope
>
(
)
|
|
is
<
js
:
:
StaticWithScope
>
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
StaticScope
>
(
)
const
{
return
is
<
js
:
:
NestedStaticScope
>
(
)
|
|
is
<
js
:
:
StaticEvalScope
>
(
)
|
|
is
<
js
:
:
StaticNonSyntacticScope
>
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
ClonedBlockObject
>
(
)
const
{
return
hasClass
(
&
js
:
:
ClonedBlockObject
:
:
class_
)
&
&
!
!
getProto
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
NestedScopeObject
>
(
)
const
{
return
is
<
js
:
:
ClonedBlockObject
>
(
)
|
|
is
<
js
:
:
DynamicWithObject
>
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
LexicalScopeBase
>
(
)
const
{
return
is
<
js
:
:
CallObject
>
(
)
|
|
is
<
js
:
:
ModuleEnvironmentObject
>
(
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
ScopeObject
>
(
)
const
{
return
is
<
js
:
:
LexicalScopeBase
>
(
)
|
|
is
<
js
:
:
DeclEnvObject
>
(
)
|
|
is
<
js
:
:
NestedScopeObject
>
(
)
|
|
is
<
js
:
:
RuntimeLexicalErrorObject
>
(
)
|
|
is
<
js
:
:
NonSyntacticVariablesObject
>
(
)
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
DebugScopeObject
>
(
)
const
;
namespace
js
{
inline
bool
IsSyntacticScope
(
JSObject
*
scope
)
{
if
(
!
scope
-
>
is
<
ScopeObject
>
(
)
)
return
false
;
if
(
scope
-
>
is
<
DynamicWithObject
>
(
)
)
return
scope
-
>
as
<
DynamicWithObject
>
(
)
.
isSyntactic
(
)
;
if
(
scope
-
>
is
<
ClonedBlockObject
>
(
)
)
return
scope
-
>
as
<
ClonedBlockObject
>
(
)
.
isSyntactic
(
)
;
if
(
scope
-
>
is
<
NonSyntacticVariablesObject
>
(
)
)
return
false
;
return
true
;
}
inline
bool
IsStaticGlobalLexicalScope
(
JSObject
*
scope
)
{
return
scope
-
>
is
<
StaticBlockScope
>
(
)
&
&
scope
-
>
as
<
StaticBlockScope
>
(
)
.
isGlobal
(
)
;
}
inline
bool
IsExtensibleLexicalScope
(
JSObject
*
scope
)
{
return
scope
-
>
is
<
ClonedBlockObject
>
(
)
&
&
scope
-
>
as
<
ClonedBlockObject
>
(
)
.
isExtensible
(
)
;
}
inline
bool
IsGlobalLexicalScope
(
JSObject
*
scope
)
{
return
scope
-
>
is
<
ClonedBlockObject
>
(
)
&
&
scope
-
>
as
<
ClonedBlockObject
>
(
)
.
isGlobal
(
)
;
}
inline
NestedStaticScope
*
NestedStaticScope
:
:
enclosingNestedScope
(
)
const
{
JSObject
*
obj
=
getReservedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObjectOrNull
(
)
;
return
obj
&
&
obj
-
>
is
<
NestedStaticScope
>
(
)
?
&
obj
-
>
as
<
NestedStaticScope
>
(
)
:
nullptr
;
}
inline
bool
StaticEvalScope
:
:
isNonGlobal
(
)
const
{
if
(
isStrict
(
)
)
return
true
;
return
!
IsStaticGlobalLexicalScope
(
&
getReservedSlot
(
ENCLOSING_SCOPE_SLOT
)
.
toObject
(
)
)
;
}
inline
const
Value
&
ScopeObject
:
:
aliasedVar
(
ScopeCoordinate
sc
)
{
MOZ_ASSERT
(
is
<
LexicalScopeBase
>
(
)
|
|
is
<
ClonedBlockObject
>
(
)
)
;
return
getSlot
(
sc
.
slot
(
)
)
;
}
inline
bool
ScopeIter
:
:
done
(
)
const
{
return
ssi_
.
done
(
)
;
}
inline
bool
ScopeIter
:
:
hasSyntacticScopeObject
(
)
const
{
return
ssi_
.
hasSyntacticDynamicScopeObject
(
)
;
}
inline
bool
ScopeIter
:
:
hasNonSyntacticScopeObject
(
)
const
{
if
(
ssi_
.
type
(
)
=
=
StaticScopeIter
<
CanGC
>
:
:
NonSyntactic
)
{
MOZ_ASSERT_IF
(
scope_
-
>
is
<
DynamicWithObject
>
(
)
!
scope_
-
>
as
<
DynamicWithObject
>
(
)
.
isSyntactic
(
)
)
;
return
scope_
-
>
is
<
ScopeObject
>
(
)
&
&
!
IsSyntacticScope
(
scope_
)
;
}
return
false
;
}
inline
bool
ScopeIter
:
:
hasAnyScopeObject
(
)
const
{
return
hasSyntacticScopeObject
(
)
|
|
hasNonSyntacticScopeObject
(
)
;
}
inline
bool
ScopeIter
:
:
canHaveSyntacticScopeObject
(
)
const
{
if
(
ssi_
.
done
(
)
)
return
false
;
switch
(
type
(
)
)
{
case
Module
:
case
Call
:
case
Block
:
case
With
:
return
true
;
case
Eval
:
return
staticEval
(
)
.
isStrict
(
)
;
case
NonSyntactic
:
return
false
;
}
return
false
;
}
inline
JSObject
&
ScopeIter
:
:
enclosingScope
(
)
const
{
MOZ_ASSERT
(
done
(
)
)
;
MOZ_ASSERT
(
!
IsSyntacticScope
(
scope_
)
)
;
return
*
scope_
;
}
extern
bool
CreateScopeObjectsForScopeChain
(
JSContext
*
cx
AutoObjectVector
&
scopeChain
HandleObject
dynamicTerminatingScope
MutableHandleObject
dynamicScopeObj
)
;
bool
HasNonSyntacticStaticScopeChain
(
JSObject
*
staticScope
)
;
uint32_t
StaticScopeChainLength
(
JSObject
*
staticScope
)
;
ModuleEnvironmentObject
*
GetModuleEnvironmentForScript
(
JSScript
*
script
)
;
bool
GetThisValueForDebuggerMaybeOptimizedOut
(
JSContext
*
cx
AbstractFramePtr
frame
MutableHandleValue
res
)
;
bool
CheckVarNameConflict
(
JSContext
*
cx
Handle
<
ClonedBlockObject
*
>
lexicalScope
HandlePropertyName
name
)
;
bool
CheckLexicalNameConflict
(
JSContext
*
cx
Handle
<
ClonedBlockObject
*
>
lexicalScope
HandleObject
varObj
HandlePropertyName
name
)
;
bool
CheckGlobalDeclarationConflicts
(
JSContext
*
cx
HandleScript
script
Handle
<
ClonedBlockObject
*
>
lexicalScope
HandleObject
varObj
)
;
bool
CheckEvalDeclarationConflicts
(
JSContext
*
cx
HandleScript
script
HandleObject
scopeChain
HandleObject
varObj
)
;
#
ifdef
DEBUG
void
DumpStaticScopeChain
(
JSScript
*
script
)
;
void
DumpStaticScopeChain
(
JSObject
*
staticScope
)
;
bool
AnalyzeEntrainedVariables
(
JSContext
*
cx
HandleScript
script
)
;
#
endif
}
#
endif
