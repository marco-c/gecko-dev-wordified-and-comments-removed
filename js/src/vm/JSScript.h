#
ifndef
vm_JSScript_h
#
define
vm_JSScript_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
Time
.
h
"
namespace
JS
{
struct
ScriptSourceInfo
;
}
namespace
js
{
namespace
jit
{
struct
BaselineScript
;
struct
IonScriptCounts
;
}
#
define
ION_DISABLED_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x1
)
#
define
ION_COMPILING_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x2
)
#
define
ION_PENDING_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x3
)
#
define
BASELINE_DISABLED_SCRIPT
(
(
js
:
:
jit
:
:
BaselineScript
*
)
0x1
)
class
BreakpointSite
;
class
Debugger
;
class
LazyScript
;
class
ModuleObject
;
class
RegExpObject
;
class
SourceCompressionTask
;
class
Shape
;
namespace
frontend
{
struct
BytecodeEmitter
;
class
FunctionBox
;
class
ModuleSharedContext
;
}
namespace
detail
{
bool
CopyScript
(
JSContext
*
cx
HandleScript
src
HandleScript
dst
MutableHandle
<
GCVector
<
Scope
*
>
>
scopes
)
;
}
}
enum
JSTryNoteKind
{
JSTRY_CATCH
JSTRY_FINALLY
JSTRY_FOR_IN
JSTRY_FOR_OF
JSTRY_LOOP
JSTRY_FOR_OF_ITERCLOSE
JSTRY_DESTRUCTURING_ITERCLOSE
}
;
struct
JSTryNote
{
uint8_t
kind
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
}
;
namespace
js
{
struct
ScopeNote
{
static
const
uint32_t
NoScopeIndex
=
UINT32_MAX
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
uint32_t
index
;
uint32_t
start
;
uint32_t
length
;
uint32_t
parent
;
}
;
struct
ConstArray
{
js
:
:
GCPtrValue
*
vector
;
uint32_t
length
;
}
;
struct
ObjectArray
{
js
:
:
GCPtrObject
*
vector
;
uint32_t
length
;
}
;
struct
ScopeArray
{
js
:
:
GCPtrScope
*
vector
;
uint32_t
length
;
}
;
struct
TryNoteArray
{
JSTryNote
*
vector
;
uint32_t
length
;
}
;
struct
ScopeNoteArray
{
ScopeNote
*
vector
;
uint32_t
length
;
}
;
class
YieldAndAwaitOffsetArray
{
friend
bool
detail
:
:
CopyScript
(
JSContext
*
cx
HandleScript
src
HandleScript
dst
MutableHandle
<
GCVector
<
Scope
*
>
>
scopes
)
;
uint32_t
*
vector_
;
uint32_t
length_
;
public
:
void
init
(
uint32_t
*
vector
uint32_t
length
)
{
vector_
=
vector
;
length_
=
length
;
}
uint32_t
&
operator
[
]
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
length_
)
;
return
vector_
[
index
]
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
}
;
class
ScriptCounts
{
public
:
typedef
mozilla
:
:
Vector
<
PCCounts
0
SystemAllocPolicy
>
PCCountsVector
;
inline
ScriptCounts
(
)
;
inline
explicit
ScriptCounts
(
PCCountsVector
&
&
jumpTargets
)
;
inline
ScriptCounts
(
ScriptCounts
&
&
src
)
;
inline
~
ScriptCounts
(
)
;
inline
ScriptCounts
&
operator
=
(
ScriptCounts
&
&
src
)
;
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
const
;
PCCounts
*
getImmediatePrecedingPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetThrowCounts
(
size_t
offset
)
const
;
const
PCCounts
*
getImmediatePrecedingThrowCounts
(
size_t
offset
)
const
;
PCCounts
*
getThrowCounts
(
size_t
offset
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
friend
class
:
:
JSScript
;
friend
struct
ScriptAndCounts
;
PCCountsVector
pcCounts_
;
PCCountsVector
throwCounts_
;
jit
:
:
IonScriptCounts
*
ionCounts_
;
}
;
using
UniqueScriptCounts
=
js
:
:
UniquePtr
<
ScriptCounts
>
;
using
ScriptCountsMap
=
HashMap
<
JSScript
*
UniqueScriptCounts
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
using
ScriptNameMap
=
HashMap
<
JSScript
*
JS
:
:
UniqueChars
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
class
DebugScript
{
friend
class
:
:
JSScript
;
friend
class
JS
:
:
Realm
;
uint32_t
stepMode
;
uint32_t
numSites
;
BreakpointSite
*
breakpoints
[
1
]
;
}
;
using
UniqueDebugScript
=
js
:
:
UniquePtr
<
DebugScript
JS
:
:
FreePolicy
>
;
using
DebugScriptMap
=
HashMap
<
JSScript
*
UniqueDebugScript
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
class
ScriptSource
;
struct
ScriptSourceChunk
{
ScriptSource
*
ss
;
uint32_t
chunk
;
ScriptSourceChunk
(
)
:
ss
(
nullptr
)
chunk
(
0
)
{
}
ScriptSourceChunk
(
ScriptSource
*
ss
uint32_t
chunk
)
:
ss
(
ss
)
chunk
(
chunk
)
{
MOZ_ASSERT
(
valid
(
)
)
;
;
}
bool
valid
(
)
const
{
return
ss
!
=
nullptr
;
}
bool
operator
=
=
(
const
ScriptSourceChunk
&
other
)
const
{
return
ss
=
=
other
.
ss
&
&
chunk
=
=
other
.
chunk
;
}
}
;
struct
ScriptSourceChunkHasher
{
using
Lookup
=
ScriptSourceChunk
;
static
HashNumber
hash
(
const
ScriptSourceChunk
&
ssc
)
{
return
mozilla
:
:
AddToHash
(
DefaultHasher
<
ScriptSource
*
>
:
:
hash
(
ssc
.
ss
)
ssc
.
chunk
)
;
}
static
bool
match
(
const
ScriptSourceChunk
&
c1
const
ScriptSourceChunk
&
c2
)
{
return
c1
=
=
c2
;
}
}
;
class
UncompressedSourceCache
{
typedef
HashMap
<
ScriptSourceChunk
UniqueTwoByteChars
ScriptSourceChunkHasher
SystemAllocPolicy
>
Map
;
public
:
class
AutoHoldEntry
{
UncompressedSourceCache
*
cache_
;
ScriptSourceChunk
sourceChunk_
;
UniqueTwoByteChars
charsToFree_
;
public
:
explicit
AutoHoldEntry
(
)
;
~
AutoHoldEntry
(
)
;
void
holdChars
(
UniqueTwoByteChars
chars
)
;
private
:
void
holdEntry
(
UncompressedSourceCache
*
cache
const
ScriptSourceChunk
&
sourceChunk
)
;
void
deferDelete
(
UniqueTwoByteChars
chars
)
;
const
ScriptSourceChunk
&
sourceChunk
(
)
const
{
return
sourceChunk_
;
}
friend
class
UncompressedSourceCache
;
}
;
private
:
UniquePtr
<
Map
>
map_
;
AutoHoldEntry
*
holder_
;
public
:
UncompressedSourceCache
(
)
:
holder_
(
nullptr
)
{
}
const
char16_t
*
lookup
(
const
ScriptSourceChunk
&
ssc
AutoHoldEntry
&
asp
)
;
bool
put
(
const
ScriptSourceChunk
&
ssc
UniqueTwoByteChars
chars
AutoHoldEntry
&
asp
)
;
void
purge
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
void
holdEntry
(
AutoHoldEntry
&
holder
const
ScriptSourceChunk
&
ssc
)
;
void
releaseEntry
(
AutoHoldEntry
&
holder
)
;
}
;
class
ScriptSource
{
friend
class
SourceCompressionTask
;
public
:
class
PinnedChars
{
PinnedChars
*
*
stack_
;
PinnedChars
*
prev_
;
ScriptSource
*
source_
;
const
char16_t
*
chars_
;
public
:
PinnedChars
(
JSContext
*
cx
ScriptSource
*
source
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
begin
size_t
len
)
;
~
PinnedChars
(
)
;
const
char16_t
*
get
(
)
const
{
return
chars_
;
}
}
;
private
:
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
refs
;
struct
Missing
{
}
;
struct
Uncompressed
{
SharedImmutableTwoByteString
string
;
explicit
Uncompressed
(
SharedImmutableTwoByteString
&
&
str
)
:
string
(
std
:
:
move
(
str
)
)
{
}
}
;
struct
Compressed
{
SharedImmutableString
raw
;
size_t
uncompressedLength
;
Compressed
(
SharedImmutableString
&
&
raw
size_t
uncompressedLength
)
:
raw
(
std
:
:
move
(
raw
)
)
uncompressedLength
(
uncompressedLength
)
{
}
}
;
using
SourceType
=
mozilla
:
:
Variant
<
Missing
Uncompressed
Compressed
>
;
SourceType
data
;
PinnedChars
*
pinnedCharsStack_
;
mozilla
:
:
Maybe
<
Compressed
>
pendingCompressed_
;
UniqueChars
filename_
;
UniqueTwoByteChars
displayURL_
;
UniqueTwoByteChars
sourceMapURL_
;
bool
mutedErrors_
;
uint32_t
introductionOffset_
;
uint32_t
parameterListEnd_
;
UniqueChars
introducerFilename_
;
const
char
*
introductionType_
;
UniquePtr
<
XDRIncrementalEncoder
>
xdrEncoder_
;
mozilla
:
:
TimeStamp
parseEnded_
;
bool
sourceRetrievable_
:
1
;
bool
hasIntroductionOffset_
:
1
;
bool
containsAsmJS_
:
1
;
const
char16_t
*
chunkChars
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
chunk
)
;
const
char16_t
*
chars
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
asp
size_t
begin
size_t
len
)
;
void
movePendingCompressedSource
(
)
;
public
:
static
const
size_t
SourceDeflateLimit
=
100
;
explicit
ScriptSource
(
)
:
refs
(
0
)
data
(
SourceType
(
Missing
(
)
)
)
pinnedCharsStack_
(
nullptr
)
filename_
(
nullptr
)
displayURL_
(
nullptr
)
sourceMapURL_
(
nullptr
)
mutedErrors_
(
false
)
introductionOffset_
(
0
)
parameterListEnd_
(
0
)
introducerFilename_
(
nullptr
)
introductionType_
(
nullptr
)
xdrEncoder_
(
nullptr
)
sourceRetrievable_
(
false
)
hasIntroductionOffset_
(
false
)
containsAsmJS_
(
false
)
{
}
~
ScriptSource
(
)
{
MOZ_ASSERT
(
refs
=
=
0
)
;
}
void
incref
(
)
{
refs
+
+
;
}
void
decref
(
)
{
MOZ_ASSERT
(
refs
!
=
0
)
;
if
(
-
-
refs
=
=
0
)
js_delete
(
this
)
;
}
MOZ_MUST_USE
bool
initFromOptions
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
mozilla
:
:
Maybe
<
uint32_t
>
&
parameterListEnd
=
mozilla
:
:
Nothing
(
)
)
;
MOZ_MUST_USE
bool
setSourceCopy
(
JSContext
*
cx
JS
:
:
SourceBufferHolder
&
srcBuf
)
;
void
setSourceRetrievable
(
)
{
sourceRetrievable_
=
true
;
}
bool
sourceRetrievable
(
)
const
{
return
sourceRetrievable_
;
}
bool
hasSourceData
(
)
const
{
return
!
data
.
is
<
Missing
>
(
)
;
}
bool
hasUncompressedSource
(
)
const
{
return
data
.
is
<
Uncompressed
>
(
)
;
}
bool
hasCompressedSource
(
)
const
{
return
data
.
is
<
Compressed
>
(
)
;
}
size_t
length
(
)
const
{
struct
LengthMatcher
{
size_t
match
(
const
Uncompressed
&
u
)
{
return
u
.
string
.
length
(
)
;
}
size_t
match
(
const
Compressed
&
c
)
{
return
c
.
uncompressedLength
;
}
size_t
match
(
const
Missing
&
m
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
source
"
)
;
return
0
;
}
}
;
MOZ_ASSERT
(
hasSourceData
(
)
)
;
return
data
.
match
(
LengthMatcher
(
)
)
;
}
JSFlatString
*
substring
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
JSFlatString
*
substringDontDeflate
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
MOZ_MUST_USE
bool
appendSubstring
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
size_t
start
size_t
stop
)
;
bool
isFunctionBody
(
)
{
return
parameterListEnd_
!
=
0
;
}
JSFlatString
*
functionBodyString
(
JSContext
*
cx
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ScriptSourceInfo
*
info
)
const
;
MOZ_MUST_USE
bool
setSource
(
JSContext
*
cx
UniqueTwoByteChars
&
&
source
size_t
length
)
;
void
setSource
(
SharedImmutableTwoByteString
&
&
string
)
;
MOZ_MUST_USE
bool
tryCompressOffThread
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
setCompressedSource
(
JSContext
*
cx
UniqueChars
&
&
raw
size_t
rawLength
size_t
sourceLength
)
;
void
setCompressedSource
(
SharedImmutableString
&
&
raw
size_t
sourceLength
)
;
template
<
XDRMode
mode
>
MOZ_MUST_USE
XDRResult
performXDR
(
XDRState
<
mode
>
*
xdr
)
;
MOZ_MUST_USE
bool
setFilename
(
JSContext
*
cx
const
char
*
filename
)
;
const
char
*
introducerFilename
(
)
const
{
return
introducerFilename_
?
introducerFilename_
.
get
(
)
:
filename_
.
get
(
)
;
}
bool
hasIntroductionType
(
)
const
{
return
introductionType_
;
}
const
char
*
introductionType
(
)
const
{
MOZ_ASSERT
(
hasIntroductionType
(
)
)
;
return
introductionType_
;
}
const
char
*
filename
(
)
const
{
return
filename_
.
get
(
)
;
}
MOZ_MUST_USE
bool
setDisplayURL
(
JSContext
*
cx
const
char16_t
*
displayURL
)
;
bool
hasDisplayURL
(
)
const
{
return
displayURL_
!
=
nullptr
;
}
const
char16_t
*
displayURL
(
)
{
MOZ_ASSERT
(
hasDisplayURL
(
)
)
;
return
displayURL_
.
get
(
)
;
}
MOZ_MUST_USE
bool
setSourceMapURL
(
JSContext
*
cx
const
char16_t
*
sourceMapURL
)
;
bool
hasSourceMapURL
(
)
const
{
return
sourceMapURL_
!
=
nullptr
;
}
const
char16_t
*
sourceMapURL
(
)
{
MOZ_ASSERT
(
hasSourceMapURL
(
)
)
;
return
sourceMapURL_
.
get
(
)
;
}
bool
mutedErrors
(
)
const
{
return
mutedErrors_
;
}
bool
hasIntroductionOffset
(
)
const
{
return
hasIntroductionOffset_
;
}
uint32_t
introductionOffset
(
)
const
{
MOZ_ASSERT
(
hasIntroductionOffset
(
)
)
;
return
introductionOffset_
;
}
void
setIntroductionOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
hasIntroductionOffset
(
)
)
;
MOZ_ASSERT
(
offset
<
=
(
uint32_t
)
INT32_MAX
)
;
introductionOffset_
=
offset
;
hasIntroductionOffset_
=
true
;
}
bool
containsAsmJS
(
)
const
{
return
containsAsmJS_
;
}
void
setContainsAsmJS
(
)
{
containsAsmJS_
=
true
;
}
bool
hasEncoder
(
)
const
{
return
bool
(
xdrEncoder_
)
;
}
bool
xdrEncodeTopLevel
(
JSContext
*
cx
HandleScript
script
)
;
bool
xdrEncodeFunction
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
)
;
bool
xdrFinalizeEncoder
(
JS
:
:
TranscodeBuffer
&
buffer
)
;
const
mozilla
:
:
TimeStamp
parseEnded
(
)
const
{
return
parseEnded_
;
}
void
recordParseEnded
(
)
{
MOZ_ASSERT
(
parseEnded_
.
IsNull
(
)
)
;
parseEnded_
=
ReallyNow
(
)
;
}
}
;
class
ScriptSourceHolder
{
ScriptSource
*
ss
;
public
:
ScriptSourceHolder
(
)
:
ss
(
nullptr
)
{
}
explicit
ScriptSourceHolder
(
ScriptSource
*
ss
)
:
ss
(
ss
)
{
ss
-
>
incref
(
)
;
}
~
ScriptSourceHolder
(
)
{
if
(
ss
)
ss
-
>
decref
(
)
;
}
void
reset
(
ScriptSource
*
newss
)
{
if
(
newss
)
newss
-
>
incref
(
)
;
if
(
ss
)
ss
-
>
decref
(
)
;
ss
=
newss
;
}
ScriptSource
*
get
(
)
const
{
return
ss
;
}
}
;
class
ScriptSourceObject
:
public
NativeObject
{
static
const
ClassOps
classOps_
;
public
:
static
const
Class
class_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
static
ScriptSourceObject
*
create
(
JSContext
*
cx
ScriptSource
*
source
)
;
static
bool
initFromOptions
(
JSContext
*
cx
HandleScriptSourceObject
source
const
ReadOnlyCompileOptions
&
options
)
;
static
bool
initElementProperties
(
JSContext
*
cx
HandleScriptSourceObject
source
HandleObject
element
HandleString
elementAttrName
)
;
ScriptSource
*
source
(
)
const
{
return
static_cast
<
ScriptSource
*
>
(
getReservedSlot
(
SOURCE_SLOT
)
.
toPrivate
(
)
)
;
}
JSObject
*
element
(
)
const
{
return
getReservedSlot
(
ELEMENT_SLOT
)
.
toObjectOrNull
(
)
;
}
const
Value
&
elementAttributeName
(
)
const
{
MOZ_ASSERT
(
!
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
.
isMagic
(
)
)
;
return
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
;
}
JSScript
*
introductionScript
(
)
const
{
Value
value
=
getReservedSlot
(
INTRODUCTION_SCRIPT_SLOT
)
;
if
(
value
.
isUndefined
(
)
)
return
nullptr
;
return
value
.
toGCThing
(
)
-
>
as
<
JSScript
>
(
)
;
}
private
:
static
const
uint32_t
SOURCE_SLOT
=
0
;
static
const
uint32_t
ELEMENT_SLOT
=
1
;
static
const
uint32_t
ELEMENT_PROPERTY_SLOT
=
2
;
static
const
uint32_t
INTRODUCTION_SCRIPT_SLOT
=
3
;
static
const
uint32_t
RESERVED_SLOTS
=
4
;
}
;
enum
class
GeneratorKind
:
bool
{
NotGenerator
Generator
}
;
enum
class
FunctionAsyncKind
:
bool
{
SyncFunction
AsyncFunction
}
;
template
<
XDRMode
mode
>
XDRResult
XDRScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleFunction
fun
MutableHandleScript
scriptp
)
;
template
<
XDRMode
mode
>
XDRResult
XDRLazyScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleFunction
fun
MutableHandle
<
LazyScript
*
>
lazy
)
;
template
<
XDRMode
mode
>
XDRResult
XDRScriptConst
(
XDRState
<
mode
>
*
xdr
MutableHandleValue
vp
)
;
class
SharedScriptData
{
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
refCount_
;
uint32_t
natoms_
;
uint32_t
codeLength_
;
uint32_t
noteLength_
;
uintptr_t
data_
[
1
]
;
public
:
static
SharedScriptData
*
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
srcnotesLength
uint32_t
natoms
)
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
incRefCount
(
)
{
refCount_
+
+
;
}
void
decRefCount
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
uint32_t
remain
=
-
-
refCount_
;
if
(
remain
=
=
0
)
js_free
(
this
)
;
}
size_t
dataLength
(
)
const
{
return
(
natoms_
*
sizeof
(
GCPtrAtom
)
)
+
codeLength_
+
noteLength_
;
}
const
uint8_t
*
data
(
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
data_
)
;
}
uint8_t
*
data
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
data_
)
;
}
uint32_t
natoms
(
)
const
{
return
natoms_
;
}
GCPtrAtom
*
atoms
(
)
{
if
(
!
natoms_
)
return
nullptr
;
return
reinterpret_cast
<
GCPtrAtom
*
>
(
data
(
)
)
;
}
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
reinterpret_cast
<
jsbytecode
*
>
(
data
(
)
+
natoms_
*
sizeof
(
GCPtrAtom
)
)
;
}
uint32_t
numNotes
(
)
const
{
return
noteLength_
;
}
jssrcnote
*
notes
(
)
{
return
reinterpret_cast
<
jssrcnote
*
>
(
data
(
)
+
natoms_
*
sizeof
(
GCPtrAtom
)
+
codeLength_
)
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
private
:
SharedScriptData
(
)
=
delete
;
SharedScriptData
(
const
SharedScriptData
&
)
=
delete
;
SharedScriptData
&
operator
=
(
const
SharedScriptData
&
)
=
delete
;
}
;
struct
ScriptBytecodeHasher
{
class
Lookup
{
friend
struct
ScriptBytecodeHasher
;
SharedScriptData
*
scriptData
;
HashNumber
hash
;
public
:
explicit
Lookup
(
SharedScriptData
*
data
)
;
~
Lookup
(
)
;
}
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
l
.
hash
;
}
static
bool
match
(
SharedScriptData
*
entry
const
Lookup
&
lookup
)
{
const
SharedScriptData
*
data
=
lookup
.
scriptData
;
if
(
entry
-
>
natoms
(
)
!
=
data
-
>
natoms
(
)
)
return
false
;
if
(
entry
-
>
codeLength
(
)
!
=
data
-
>
codeLength
(
)
)
return
false
;
if
(
entry
-
>
numNotes
(
)
!
=
data
-
>
numNotes
(
)
)
return
false
;
return
mozilla
:
:
ArrayEqual
<
uint8_t
>
(
entry
-
>
data
(
)
data
-
>
data
(
)
data
-
>
dataLength
(
)
)
;
}
}
;
class
AutoLockScriptData
;
using
ScriptDataTable
=
HashSet
<
SharedScriptData
*
ScriptBytecodeHasher
SystemAllocPolicy
>
;
extern
void
SweepScriptData
(
JSRuntime
*
rt
)
;
extern
void
FreeScriptData
(
JSRuntime
*
rt
)
;
}
class
JSScript
:
public
js
:
:
gc
:
:
TenuredCell
{
private
:
uint8_t
*
jitCodeRaw_
=
nullptr
;
uint8_t
*
jitCodeSkipArgCheck_
=
nullptr
;
js
:
:
SharedScriptData
*
scriptData_
=
nullptr
;
public
:
uint8_t
*
data
=
nullptr
;
JS
:
:
Realm
*
realm_
=
nullptr
;
private
:
js
:
:
TypeScript
*
types_
=
nullptr
;
js
:
:
GCPtrObject
sourceObject_
=
{
}
;
js
:
:
jit
:
:
IonScript
*
ion
=
nullptr
;
js
:
:
jit
:
:
BaselineScript
*
baseline
=
nullptr
;
js
:
:
LazyScript
*
lazyScript
=
nullptr
;
uint32_t
dataSize_
=
0
;
uint32_t
lineno_
=
0
;
uint32_t
column_
=
0
;
uint32_t
mainOffset_
=
0
;
uint32_t
nfixed_
=
0
;
uint32_t
nslots_
=
0
;
uint32_t
bodyScopeIndex_
=
0
;
uint32_t
sourceStart_
=
0
;
uint32_t
sourceEnd_
=
0
;
uint32_t
toStringStart_
=
0
;
uint32_t
toStringEnd_
=
0
;
#
ifdef
MOZ_VTUNE
uint32_t
vtuneMethodId_
=
0
;
#
endif
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
warmUpCount
=
{
}
;
uint16_t
warmUpResetCount
=
0
;
uint16_t
funLength_
=
0
;
uint16_t
nTypeSets_
=
0
;
public
:
enum
ArrayKind
{
CONSTS
OBJECTS
TRYNOTES
SCOPENOTES
ARRAY_KIND_BITS
}
;
private
:
struct
BitFields
{
uint8_t
hasArrayBits_
:
ARRAY_KIND_BITS
;
bool
noScriptRval_
:
1
;
bool
strict_
:
1
;
bool
explicitUseStrict_
:
1
;
bool
hasNonSyntacticScope_
:
1
;
bool
selfHosted_
:
1
;
bool
bindingsAccessedDynamically_
:
1
;
bool
funHasExtensibleScope_
:
1
;
bool
funHasAnyAliasedFormal_
:
1
;
bool
warnedAboutUndefinedProp_
:
1
;
bool
hasSingletons_
:
1
;
bool
treatAsRunOnce_
:
1
;
bool
hasRunOnce_
:
1
;
bool
hasBeenCloned_
:
1
;
bool
isActiveEval_
:
1
;
bool
isCachedEval_
:
1
;
bool
isLikelyConstructorWrapper_
:
1
;
bool
failedBoundsCheck_
:
1
;
bool
failedShapeGuard_
:
1
;
bool
hadFrequentBailouts_
:
1
;
bool
hadOverflowBailout_
:
1
;
bool
uninlineable_
:
1
;
bool
invalidatedIdempotentCache_
:
1
;
bool
failedLexicalCheck_
:
1
;
bool
hasScriptCounts_
:
1
;
bool
hasDebugScript_
:
1
;
bool
hasFreezeConstraints_
:
1
;
bool
argsHasVarBinding_
:
1
;
bool
needsArgsAnalysis_
:
1
;
bool
needsArgsObj_
:
1
;
bool
functionHasThisBinding_
:
1
;
bool
functionHasExtraBodyVarScope_
:
1
;
bool
hasMappedArgsObj_
:
1
;
bool
typesGeneration_
:
1
;
bool
doNotRelazify_
:
1
;
bool
hasInnerFunctions_
:
1
;
bool
needsHomeObject_
:
1
;
bool
isDerivedClassConstructor_
:
1
;
bool
isDefaultClassConstructor_
:
1
;
bool
isGenerator_
:
1
;
bool
isAsync_
:
1
;
bool
hasRest_
:
1
;
bool
hideScriptFromDebugger_
:
1
;
}
bitFields_
;
private
:
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
XDRScript
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScope
enclosingScope
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleFunction
fun
js
:
:
MutableHandleScript
scriptp
)
;
friend
bool
js
:
:
detail
:
:
CopyScript
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
private
:
JSScript
(
JS
:
:
Realm
*
realm
uint8_t
*
stubEntry
const
JS
:
:
ReadOnlyCompileOptions
&
options
js
:
:
HandleObject
sourceObject
uint32_t
bufStart
uint32_t
bufEnd
uint32_t
toStringStart
uint32_t
toStringend
)
;
static
JSScript
*
createInitialized
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
js
:
:
HandleObject
sourceObject
uint32_t
bufStart
uint32_t
bufEnd
uint32_t
toStringStart
uint32_t
toStringEnd
)
;
public
:
static
JSScript
*
Create
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
js
:
:
HandleObject
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
)
;
static
bool
partiallyInit
(
JSContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
uint32_t
nscopes
uint32_t
nconsts
uint32_t
nobjects
uint32_t
ntrynotes
uint32_t
nscopenotes
uint32_t
nyieldoffsets
uint32_t
nTypeSets
)
;
private
:
static
void
initFromFunctionBox
(
js
:
:
HandleScript
script
js
:
:
frontend
:
:
FunctionBox
*
funbox
)
;
static
void
initFromModuleContext
(
js
:
:
HandleScript
script
)
;
public
:
static
bool
fullyInitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
)
;
static
bool
initFunctionPrototype
(
JSContext
*
cx
js
:
:
HandleScript
script
JS
:
:
HandleFunction
functionProto
)
;
#
ifdef
DEBUG
private
:
void
assertValidJumpTargets
(
)
const
;
#
endif
public
:
inline
JSPrincipals
*
principals
(
)
;
JS
:
:
Compartment
*
compartment
(
)
const
{
return
JS
:
:
GetCompartmentForRealm
(
realm_
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
realm_
;
}
js
:
:
SharedScriptData
*
scriptData
(
)
{
return
scriptData_
;
}
jsbytecode
*
code
(
)
const
{
if
(
!
scriptData_
)
return
nullptr
;
return
scriptData_
-
>
code
(
)
;
}
bool
isUncompleted
(
)
const
{
return
!
code
(
)
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
codeLength
(
)
;
}
jsbytecode
*
codeEnd
(
)
const
{
return
code
(
)
+
length
(
)
;
}
jsbytecode
*
lastPC
(
)
const
{
jsbytecode
*
pc
=
codeEnd
(
)
-
js
:
:
JSOP_RETRVAL_LENGTH
;
MOZ_ASSERT
(
*
pc
=
=
JSOP_RETRVAL
)
;
return
pc
;
}
bool
containsPC
(
const
jsbytecode
*
pc
)
const
{
return
pc
>
=
code
(
)
&
&
pc
<
codeEnd
(
)
;
}
size_t
pcToOffset
(
const
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
return
size_t
(
pc
-
code
(
)
)
;
}
jsbytecode
*
offsetToPC
(
size_t
offset
)
const
{
MOZ_ASSERT
(
offset
<
length
(
)
)
;
return
code
(
)
+
offset
;
}
size_t
mainOffset
(
)
const
{
return
mainOffset_
;
}
uint32_t
lineno
(
)
const
{
return
lineno_
;
}
uint32_t
column
(
)
const
{
return
column_
;
}
void
setColumn
(
size_t
column
)
{
column_
=
column
;
}
size_t
nfixed
(
)
const
{
return
nfixed_
;
}
size_t
numAlwaysLiveFixedSlots
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
return
0
;
}
size_t
calculateLiveFixed
(
jsbytecode
*
pc
)
;
size_t
nslots
(
)
const
{
return
nslots_
;
}
unsigned
numArgs
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
numPositionalFormalParameters
(
)
;
return
0
;
}
inline
js
:
:
Shape
*
initialEnvironmentShape
(
)
const
;
bool
functionHasParameterExprs
(
)
const
{
js
:
:
Scope
*
scope
=
bodyScope
(
)
;
if
(
!
scope
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
false
;
return
scope
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
hasParameterExprs
(
)
;
}
size_t
nTypeSets
(
)
const
{
return
nTypeSets_
;
}
size_t
funLength
(
)
const
{
return
funLength_
;
}
static
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
JSScript
funLength_
)
;
}
uint32_t
sourceStart
(
)
const
{
return
sourceStart_
;
}
uint32_t
sourceEnd
(
)
const
{
return
sourceEnd_
;
}
uint32_t
sourceLength
(
)
const
{
return
sourceEnd_
-
sourceStart_
;
}
uint32_t
toStringStart
(
)
const
{
return
toStringStart_
;
}
uint32_t
toStringEnd
(
)
const
{
return
toStringEnd_
;
}
bool
noScriptRval
(
)
const
{
return
bitFields_
.
noScriptRval_
;
}
bool
strict
(
)
const
{
return
bitFields_
.
strict_
;
}
bool
explicitUseStrict
(
)
const
{
return
bitFields_
.
explicitUseStrict_
;
}
bool
hasNonSyntacticScope
(
)
const
{
return
bitFields_
.
hasNonSyntacticScope_
;
}
bool
selfHosted
(
)
const
{
return
bitFields_
.
selfHosted_
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
bitFields_
.
bindingsAccessedDynamically_
;
}
bool
funHasExtensibleScope
(
)
const
{
return
bitFields_
.
funHasExtensibleScope_
;
}
bool
funHasAnyAliasedFormal
(
)
const
{
return
bitFields_
.
funHasAnyAliasedFormal_
;
}
bool
hasSingletons
(
)
const
{
return
bitFields_
.
hasSingletons_
;
}
bool
treatAsRunOnce
(
)
const
{
return
bitFields_
.
treatAsRunOnce_
;
}
bool
hasRunOnce
(
)
const
{
return
bitFields_
.
hasRunOnce_
;
}
bool
hasBeenCloned
(
)
const
{
return
bitFields_
.
hasBeenCloned_
;
}
void
setTreatAsRunOnce
(
)
{
bitFields_
.
treatAsRunOnce_
=
true
;
}
void
setHasRunOnce
(
)
{
bitFields_
.
hasRunOnce_
=
true
;
}
void
setHasBeenCloned
(
)
{
bitFields_
.
hasBeenCloned_
=
true
;
}
bool
isActiveEval
(
)
const
{
return
bitFields_
.
isActiveEval_
;
}
bool
isCachedEval
(
)
const
{
return
bitFields_
.
isCachedEval_
;
}
void
cacheForEval
(
)
{
MOZ_ASSERT
(
isActiveEval
(
)
)
;
MOZ_ASSERT
(
!
isCachedEval
(
)
)
;
bitFields_
.
isActiveEval_
=
false
;
bitFields_
.
isCachedEval_
=
true
;
bitFields_
.
hasRunOnce_
=
false
;
}
void
uncacheForEval
(
)
{
MOZ_ASSERT
(
isCachedEval
(
)
)
;
MOZ_ASSERT
(
!
isActiveEval
(
)
)
;
bitFields_
.
isCachedEval_
=
false
;
bitFields_
.
isActiveEval_
=
true
;
}
void
setActiveEval
(
)
{
bitFields_
.
isActiveEval_
=
true
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
bitFields_
.
isLikelyConstructorWrapper_
;
}
void
setLikelyConstructorWrapper
(
)
{
bitFields_
.
isLikelyConstructorWrapper_
=
true
;
}
bool
failedBoundsCheck
(
)
const
{
return
bitFields_
.
failedBoundsCheck_
;
}
bool
failedShapeGuard
(
)
const
{
return
bitFields_
.
failedShapeGuard_
;
}
bool
hadFrequentBailouts
(
)
const
{
return
bitFields_
.
hadFrequentBailouts_
;
}
bool
hadOverflowBailout
(
)
const
{
return
bitFields_
.
hadOverflowBailout_
;
}
bool
uninlineable
(
)
const
{
return
bitFields_
.
uninlineable_
;
}
bool
invalidatedIdempotentCache
(
)
const
{
return
bitFields_
.
invalidatedIdempotentCache_
;
}
bool
failedLexicalCheck
(
)
const
{
return
bitFields_
.
failedLexicalCheck_
;
}
bool
isDefaultClassConstructor
(
)
const
{
return
bitFields_
.
isDefaultClassConstructor_
;
}
void
setFailedBoundsCheck
(
)
{
bitFields_
.
failedBoundsCheck_
=
true
;
}
void
setFailedShapeGuard
(
)
{
bitFields_
.
failedShapeGuard_
=
true
;
}
void
setHadFrequentBailouts
(
)
{
bitFields_
.
hadFrequentBailouts_
=
true
;
}
void
setHadOverflowBailout
(
)
{
bitFields_
.
hadOverflowBailout_
=
true
;
}
void
setUninlineable
(
)
{
bitFields_
.
uninlineable_
=
true
;
}
void
setInvalidatedIdempotentCache
(
)
{
bitFields_
.
invalidatedIdempotentCache_
=
true
;
}
void
setFailedLexicalCheck
(
)
{
bitFields_
.
failedLexicalCheck_
=
true
;
}
void
setIsDefaultClassConstructor
(
)
{
bitFields_
.
isDefaultClassConstructor_
=
true
;
}
bool
hasScriptCounts
(
)
const
{
return
bitFields_
.
hasScriptCounts_
;
}
bool
hasScriptName
(
)
;
bool
hasFreezeConstraints
(
)
const
{
return
bitFields_
.
hasFreezeConstraints_
;
}
void
setHasFreezeConstraints
(
)
{
bitFields_
.
hasFreezeConstraints_
=
true
;
}
bool
warnedAboutUndefinedProp
(
)
const
{
return
bitFields_
.
warnedAboutUndefinedProp_
;
}
void
setWarnedAboutUndefinedProp
(
)
{
bitFields_
.
warnedAboutUndefinedProp_
=
true
;
}
bool
argumentsHasVarBinding
(
)
const
{
return
bitFields_
.
argsHasVarBinding_
;
}
void
setArgumentsHasVarBinding
(
)
;
bool
argumentsAliasesFormals
(
)
const
{
return
argumentsHasVarBinding
(
)
&
&
hasMappedArgsObj
(
)
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
return
bitFields_
.
isGenerator_
?
js
:
:
GeneratorKind
:
:
Generator
:
js
:
:
GeneratorKind
:
:
NotGenerator
;
}
bool
isGenerator
(
)
const
{
return
bitFields_
.
isGenerator_
;
}
void
setGeneratorKind
(
js
:
:
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
bitFields_
.
isGenerator_
=
kind
=
=
js
:
:
GeneratorKind
:
:
Generator
;
}
js
:
:
FunctionAsyncKind
asyncKind
(
)
const
{
return
bitFields_
.
isAsync_
?
js
:
:
FunctionAsyncKind
:
:
AsyncFunction
:
js
:
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
isAsync
(
)
const
{
return
bitFields_
.
isAsync_
;
}
void
setAsyncKind
(
js
:
:
FunctionAsyncKind
kind
)
{
bitFields_
.
isAsync_
=
kind
=
=
js
:
:
FunctionAsyncKind
:
:
AsyncFunction
;
}
bool
hasRest
(
)
const
{
return
bitFields_
.
hasRest_
;
}
void
setHasRest
(
)
{
bitFields_
.
hasRest_
=
true
;
}
bool
hideScriptFromDebugger
(
)
const
{
return
bitFields_
.
hideScriptFromDebugger_
;
}
void
clearHideScriptFromDebugger
(
)
{
bitFields_
.
hideScriptFromDebugger_
=
false
;
}
void
setNeedsHomeObject
(
)
{
bitFields_
.
needsHomeObject_
=
true
;
}
bool
needsHomeObject
(
)
const
{
return
bitFields_
.
needsHomeObject_
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
bitFields_
.
isDerivedClassConstructor_
;
}
bool
analyzedArgsUsage
(
)
const
{
return
!
bitFields_
.
needsArgsAnalysis_
;
}
inline
bool
ensureHasAnalyzedArgsUsage
(
JSContext
*
cx
)
;
bool
needsArgsObj
(
)
const
{
MOZ_ASSERT
(
analyzedArgsUsage
(
)
)
;
return
bitFields_
.
needsArgsObj_
;
}
void
setNeedsArgsObj
(
bool
needsArgsObj
)
;
static
bool
argumentsOptimizationFailed
(
JSContext
*
cx
js
:
:
HandleScript
script
)
;
bool
hasMappedArgsObj
(
)
const
{
return
bitFields_
.
hasMappedArgsObj_
;
}
bool
functionHasThisBinding
(
)
const
{
return
bitFields_
.
functionHasThisBinding_
;
}
bool
argsObjAliasesFormals
(
)
const
{
return
needsArgsObj
(
)
&
&
hasMappedArgsObj
(
)
;
}
uint32_t
typesGeneration
(
)
const
{
return
(
uint32_t
)
bitFields_
.
typesGeneration_
;
}
void
setTypesGeneration
(
uint32_t
generation
)
{
MOZ_ASSERT
(
generation
<
=
1
)
;
bitFields_
.
typesGeneration_
=
(
bool
)
generation
;
}
void
setDoNotRelazify
(
bool
b
)
{
bitFields_
.
doNotRelazify_
=
b
;
}
void
setHasInnerFunctions
(
bool
b
)
{
bitFields_
.
hasInnerFunctions_
=
b
;
}
bool
hasInnerFunctions
(
)
const
{
return
bitFields_
.
hasInnerFunctions_
;
}
bool
hasAnyIonScript
(
)
const
{
return
hasIonScript
(
)
;
}
bool
hasIonScript
(
)
const
{
bool
res
=
ion
&
&
ion
!
=
ION_DISABLED_SCRIPT
&
&
ion
!
=
ION_COMPILING_SCRIPT
&
&
ion
!
=
ION_PENDING_SCRIPT
;
MOZ_ASSERT_IF
(
res
baseline
)
;
return
res
;
}
bool
canIonCompile
(
)
const
{
return
ion
!
=
ION_DISABLED_SCRIPT
;
}
bool
isIonCompilingOffThread
(
)
const
{
return
ion
=
=
ION_COMPILING_SCRIPT
;
}
js
:
:
jit
:
:
IonScript
*
ionScript
(
)
const
{
MOZ_ASSERT
(
hasIonScript
(
)
)
;
return
ion
;
}
js
:
:
jit
:
:
IonScript
*
maybeIonScript
(
)
const
{
return
ion
;
}
js
:
:
jit
:
:
IonScript
*
const
*
addressOfIonScript
(
)
const
{
return
&
ion
;
}
void
setIonScript
(
JSRuntime
*
rt
js
:
:
jit
:
:
IonScript
*
ionScript
)
;
bool
hasBaselineScript
(
)
const
{
bool
res
=
baseline
&
&
baseline
!
=
BASELINE_DISABLED_SCRIPT
;
MOZ_ASSERT_IF
(
!
res
!
ion
|
|
ion
=
=
ION_DISABLED_SCRIPT
)
;
return
res
;
}
bool
canBaselineCompile
(
)
const
{
return
baseline
!
=
BASELINE_DISABLED_SCRIPT
;
}
js
:
:
jit
:
:
BaselineScript
*
baselineScript
(
)
const
{
MOZ_ASSERT
(
hasBaselineScript
(
)
)
;
return
baseline
;
}
inline
void
setBaselineScript
(
JSRuntime
*
rt
js
:
:
jit
:
:
BaselineScript
*
baselineScript
)
;
void
updateJitCodeRaw
(
JSRuntime
*
rt
)
;
static
size_t
offsetOfBaselineScript
(
)
{
return
offsetof
(
JSScript
baseline
)
;
}
static
size_t
offsetOfIonScript
(
)
{
return
offsetof
(
JSScript
ion
)
;
}
static
constexpr
size_t
offsetOfJitCodeRaw
(
)
{
return
offsetof
(
JSScript
jitCodeRaw_
)
;
}
static
constexpr
size_t
offsetOfJitCodeSkipArgCheck
(
)
{
return
offsetof
(
JSScript
jitCodeSkipArgCheck_
)
;
}
uint8_t
*
jitCodeRaw
(
)
const
{
return
jitCodeRaw_
;
}
bool
isRelazifiable
(
)
const
{
return
(
selfHosted
(
)
|
|
lazyScript
)
&
&
!
bitFields_
.
hasInnerFunctions_
&
&
!
types_
&
&
!
isGenerator
(
)
&
&
!
isAsync
(
)
&
&
!
isDefaultClassConstructor
(
)
&
&
!
hasBaselineScript
(
)
&
&
!
hasAnyIonScript
(
)
&
&
!
bitFields_
.
doNotRelazify_
;
}
void
setLazyScript
(
js
:
:
LazyScript
*
lazy
)
{
lazyScript
=
lazy
;
}
js
:
:
LazyScript
*
maybeLazyScript
(
)
{
return
lazyScript
;
}
inline
JSFunction
*
functionDelazifying
(
)
const
;
JSFunction
*
functionNonDelazifying
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
return
nullptr
;
}
inline
void
ensureNonLazyCanonicalFunction
(
)
;
js
:
:
ModuleObject
*
module
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
module
(
)
;
return
nullptr
;
}
bool
isGlobalOrEvalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
|
|
bodyScope
(
)
-
>
is
<
js
:
:
EvalScope
>
(
)
;
}
bool
isGlobalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
;
}
bool
mayReadFrameArgsDirectly
(
)
;
static
JSFlatString
*
sourceData
(
JSContext
*
cx
JS
:
:
HandleScript
script
)
;
MOZ_MUST_USE
bool
appendSourceDataForToString
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
)
;
static
bool
loadSource
(
JSContext
*
cx
js
:
:
ScriptSource
*
ss
bool
*
worked
)
;
void
setSourceObject
(
JSObject
*
object
)
;
JSObject
*
sourceObject
(
)
const
{
return
sourceObject_
;
}
js
:
:
ScriptSourceObject
&
scriptSourceUnwrap
(
)
const
;
js
:
:
ScriptSource
*
scriptSource
(
)
const
;
js
:
:
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
void
setDefaultClassConstructorSpan
(
JSObject
*
sourceObject
uint32_t
start
uint32_t
end
unsigned
line
unsigned
column
)
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
const
char
*
maybeForwardedFilename
(
)
const
{
return
maybeForwardedScriptSource
(
)
-
>
filename
(
)
;
}
#
ifdef
MOZ_VTUNE
uint32_t
vtuneMethodID
(
)
const
{
return
vtuneMethodId_
;
}
#
endif
public
:
bool
isForEval
(
)
const
{
MOZ_ASSERT_IF
(
isCachedEval
(
)
|
|
isActiveEval
(
)
bodyScope
(
)
-
>
is
<
js
:
:
EvalScope
>
(
)
)
;
return
isCachedEval
(
)
|
|
isActiveEval
(
)
;
}
bool
isDirectEvalInFunction
(
)
const
{
if
(
!
isForEval
(
)
)
return
false
;
return
bodyScope
(
)
-
>
hasOnChain
(
js
:
:
ScopeKind
:
:
Function
)
;
}
bool
isTopLevel
(
)
const
{
return
code
(
)
&
&
!
functionNonDelazifying
(
)
;
}
inline
bool
ensureHasTypes
(
JSContext
*
cx
js
:
:
AutoKeepTypeScripts
&
)
;
inline
js
:
:
TypeScript
*
types
(
const
js
:
:
AutoSweepTypeScript
&
sweep
)
;
inline
bool
typesNeedsSweep
(
)
const
;
void
sweepTypes
(
const
js
:
:
AutoSweepTypeScript
&
sweep
js
:
:
AutoClearTypeInferenceStateOnOOM
*
oom
)
;
inline
js
:
:
GlobalObject
&
global
(
)
const
;
js
:
:
GlobalObject
&
uninlinedGlobal
(
)
const
;
uint32_t
bodyScopeIndex
(
)
const
{
return
bodyScopeIndex_
;
}
js
:
:
Scope
*
bodyScope
(
)
const
{
return
getScope
(
bodyScopeIndex_
)
;
}
js
:
:
Scope
*
outermostScope
(
)
const
{
size_t
index
=
0
;
return
getScope
(
index
)
;
}
bool
functionHasExtraBodyVarScope
(
)
const
{
MOZ_ASSERT_IF
(
bitFields_
.
functionHasExtraBodyVarScope_
functionHasParameterExprs
(
)
)
;
return
bitFields_
.
functionHasExtraBodyVarScope_
;
}
js
:
:
VarScope
*
functionExtraBodyVarScope
(
)
const
{
MOZ_ASSERT
(
functionHasExtraBodyVarScope
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
scopes
(
)
-
>
length
;
i
+
+
)
{
js
:
:
Scope
*
scope
=
getScope
(
i
)
;
if
(
scope
-
>
kind
(
)
=
=
js
:
:
ScopeKind
:
:
FunctionBodyVar
)
return
&
scope
-
>
as
<
js
:
:
VarScope
>
(
)
;
}
MOZ_CRASH
(
"
Function
extra
body
var
scope
not
found
"
)
;
}
bool
needsBodyEnvironment
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
scopes
(
)
-
>
length
;
i
+
+
)
{
js
:
:
Scope
*
scope
=
getScope
(
i
)
;
if
(
ScopeKindIsInBody
(
scope
-
>
kind
(
)
)
&
&
scope
-
>
hasEnvironment
(
)
)
return
true
;
}
return
false
;
}
inline
js
:
:
LexicalScope
*
maybeNamedLambdaScope
(
)
const
;
js
:
:
Scope
*
enclosingScope
(
)
const
{
return
outermostScope
(
)
-
>
enclosing
(
)
;
}
private
:
bool
makeTypes
(
JSContext
*
cx
)
;
bool
createScriptData
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
srcnotesLength
uint32_t
natoms
)
;
bool
shareScriptData
(
JSContext
*
cx
)
;
void
freeScriptData
(
)
;
void
setScriptData
(
js
:
:
SharedScriptData
*
data
)
;
public
:
uint32_t
getWarmUpCount
(
)
const
{
return
warmUpCount
;
}
uint32_t
incWarmUpCounter
(
uint32_t
amount
=
1
)
{
return
warmUpCount
+
=
amount
;
}
uint32_t
*
addressOfWarmUpCounter
(
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
&
warmUpCount
)
;
}
static
size_t
offsetOfWarmUpCounter
(
)
{
return
offsetof
(
JSScript
warmUpCount
)
;
}
void
resetWarmUpCounter
(
)
{
incWarmUpResetCounter
(
)
;
warmUpCount
=
0
;
}
uint16_t
getWarmUpResetCount
(
)
const
{
return
warmUpResetCount
;
}
uint16_t
incWarmUpResetCounter
(
uint16_t
amount
=
1
)
{
return
warmUpResetCount
+
=
amount
;
}
void
resetWarmUpResetCounter
(
)
{
warmUpResetCount
=
0
;
}
public
:
bool
initScriptCounts
(
JSContext
*
cx
)
;
bool
initScriptName
(
JSContext
*
cx
)
;
js
:
:
ScriptCounts
&
getScriptCounts
(
)
;
const
char
*
getScriptName
(
)
;
js
:
:
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
;
const
js
:
:
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
;
js
:
:
PCCounts
*
getThrowCounts
(
jsbytecode
*
pc
)
;
uint64_t
getHitCount
(
jsbytecode
*
pc
)
;
void
incHitCount
(
jsbytecode
*
pc
)
;
void
addIonCounts
(
js
:
:
jit
:
:
IonScriptCounts
*
ionCounts
)
;
js
:
:
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
;
void
releaseScriptCounts
(
js
:
:
ScriptCounts
*
counts
)
;
void
destroyScriptCounts
(
)
;
void
destroyScriptName
(
)
;
void
clearHasScriptCounts
(
)
;
jsbytecode
*
main
(
)
const
{
return
code
(
)
+
mainOffset
(
)
;
}
size_t
computedSizeOfData
(
)
const
;
size_t
sizeOfData
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfTypeScript
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
bool
hasArray
(
ArrayKind
kind
)
const
{
return
bitFields_
.
hasArrayBits_
&
(
1
<
<
kind
)
;
}
void
setHasArray
(
ArrayKind
kind
)
{
bitFields_
.
hasArrayBits_
|
=
(
1
<
<
kind
)
;
}
void
cloneHasArray
(
JSScript
*
script
)
{
bitFields_
.
hasArrayBits_
=
script
-
>
bitFields_
.
hasArrayBits_
;
}
bool
hasConsts
(
)
const
{
return
hasArray
(
CONSTS
)
;
}
bool
hasObjects
(
)
const
{
return
hasArray
(
OBJECTS
)
;
}
bool
hasTrynotes
(
)
const
{
return
hasArray
(
TRYNOTES
)
;
}
bool
hasScopeNotes
(
)
const
{
return
hasArray
(
SCOPENOTES
)
;
}
bool
hasYieldAndAwaitOffsets
(
)
const
{
return
isGenerator
(
)
|
|
isAsync
(
)
;
}
#
define
OFF
(
fooOff
hasFoo
t
)
(
fooOff
(
)
+
(
hasFoo
(
)
?
sizeof
(
t
)
:
0
)
)
size_t
scopesOffset
(
)
const
{
return
0
;
}
size_t
constsOffset
(
)
const
{
return
scopesOffset
(
)
+
sizeof
(
js
:
:
ScopeArray
)
;
}
size_t
objectsOffset
(
)
const
{
return
OFF
(
constsOffset
hasConsts
js
:
:
ConstArray
)
;
}
size_t
trynotesOffset
(
)
const
{
return
OFF
(
objectsOffset
hasObjects
js
:
:
ObjectArray
)
;
}
size_t
scopeNotesOffset
(
)
const
{
return
OFF
(
trynotesOffset
hasTrynotes
js
:
:
TryNoteArray
)
;
}
size_t
yieldAndAwaitOffsetsOffset
(
)
const
{
return
OFF
(
scopeNotesOffset
hasScopeNotes
js
:
:
ScopeNoteArray
)
;
}
#
undef
OFF
size_t
dataSize
(
)
const
{
return
dataSize_
;
}
js
:
:
ConstArray
*
consts
(
)
{
MOZ_ASSERT
(
hasConsts
(
)
)
;
return
reinterpret_cast
<
js
:
:
ConstArray
*
>
(
data
+
constsOffset
(
)
)
;
}
js
:
:
ObjectArray
*
objects
(
)
{
MOZ_ASSERT
(
hasObjects
(
)
)
;
return
reinterpret_cast
<
js
:
:
ObjectArray
*
>
(
data
+
objectsOffset
(
)
)
;
}
js
:
:
ScopeArray
*
scopes
(
)
const
{
return
reinterpret_cast
<
js
:
:
ScopeArray
*
>
(
data
+
scopesOffset
(
)
)
;
}
js
:
:
TryNoteArray
*
trynotes
(
)
const
{
MOZ_ASSERT
(
hasTrynotes
(
)
)
;
return
reinterpret_cast
<
js
:
:
TryNoteArray
*
>
(
data
+
trynotesOffset
(
)
)
;
}
js
:
:
ScopeNoteArray
*
scopeNotes
(
)
{
MOZ_ASSERT
(
hasScopeNotes
(
)
)
;
return
reinterpret_cast
<
js
:
:
ScopeNoteArray
*
>
(
data
+
scopeNotesOffset
(
)
)
;
}
js
:
:
YieldAndAwaitOffsetArray
&
yieldAndAwaitOffsets
(
)
{
MOZ_ASSERT
(
hasYieldAndAwaitOffsets
(
)
)
;
return
*
reinterpret_cast
<
js
:
:
YieldAndAwaitOffsetArray
*
>
(
data
+
yieldAndAwaitOffsetsOffset
(
)
)
;
}
bool
hasLoops
(
)
;
uint32_t
numNotes
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
numNotes
(
)
;
}
jssrcnote
*
notes
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
notes
(
)
;
}
size_t
natoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
natoms
(
)
;
}
js
:
:
GCPtrAtom
*
atoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
atoms
(
)
;
}
js
:
:
GCPtrAtom
&
getAtom
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
natoms
(
)
)
;
return
atoms
(
)
[
index
]
;
}
js
:
:
GCPtrAtom
&
getAtom
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
(
JSOp
)
*
pc
)
=
=
JOF_ATOM
)
;
return
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
PropertyName
*
getName
(
size_t
index
)
{
return
getAtom
(
index
)
-
>
asPropertyName
(
)
;
}
js
:
:
PropertyName
*
getName
(
jsbytecode
*
pc
)
const
{
return
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
}
JSObject
*
getObject
(
size_t
index
)
{
js
:
:
ObjectArray
*
arr
=
objects
(
)
;
MOZ_ASSERT
(
index
<
arr
-
>
length
)
;
MOZ_ASSERT
(
arr
-
>
vector
[
index
]
-
>
isTenured
(
)
)
;
return
arr
-
>
vector
[
index
]
;
}
JSObject
*
getObject
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
return
getObject
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
getScope
(
size_t
index
)
const
{
js
:
:
ScopeArray
*
array
=
scopes
(
)
;
MOZ_ASSERT
(
index
<
array
-
>
length
)
;
return
array
-
>
vector
[
index
]
;
}
js
:
:
Scope
*
getScope
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_SCOPE
"
Did
you
mean
to
use
lookupScope
(
pc
)
?
"
)
;
return
getScope
(
GET_UINT32_INDEX
(
pc
)
)
;
}
inline
JSFunction
*
getFunction
(
size_t
index
)
;
JSFunction
*
function
(
)
const
{
if
(
functionNonDelazifying
(
)
)
return
functionNonDelazifying
(
)
;
return
nullptr
;
}
inline
js
:
:
RegExpObject
*
getRegExp
(
size_t
index
)
;
inline
js
:
:
RegExpObject
*
getRegExp
(
jsbytecode
*
pc
)
;
const
js
:
:
Value
&
getConst
(
size_t
index
)
{
js
:
:
ConstArray
*
arr
=
consts
(
)
;
MOZ_ASSERT
(
index
<
arr
-
>
length
)
;
return
arr
-
>
vector
[
index
]
;
}
js
:
:
Scope
*
lookupScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
)
{
return
innermostScope
(
main
(
)
)
;
}
bool
isEmpty
(
)
const
{
if
(
length
(
)
>
3
)
return
false
;
jsbytecode
*
pc
=
code
(
)
;
if
(
noScriptRval
(
)
&
&
JSOp
(
*
pc
)
=
=
JSOP_FALSE
)
+
+
pc
;
return
JSOp
(
*
pc
)
=
=
JSOP_RETRVAL
;
}
bool
formalIsAliased
(
unsigned
argSlot
)
;
bool
formalLivesInArgumentsObject
(
unsigned
argSlot
)
;
private
:
void
setNewStepMode
(
js
:
:
FreeOp
*
fop
uint32_t
newValue
)
;
bool
ensureHasDebugScript
(
JSContext
*
cx
)
;
js
:
:
DebugScript
*
debugScript
(
)
;
js
:
:
DebugScript
*
releaseDebugScript
(
)
;
void
destroyDebugScript
(
js
:
:
FreeOp
*
fop
)
;
public
:
bool
hasBreakpointsAt
(
jsbytecode
*
pc
)
;
bool
hasAnyBreakpointsOrStepMode
(
)
{
return
bitFields_
.
hasDebugScript_
;
}
inline
bool
isDebuggee
(
)
const
;
js
:
:
BreakpointSite
*
getBreakpointSite
(
jsbytecode
*
pc
)
{
return
bitFields_
.
hasDebugScript_
?
debugScript
(
)
-
>
breakpoints
[
pcToOffset
(
pc
)
]
:
nullptr
;
}
js
:
:
BreakpointSite
*
getOrCreateBreakpointSite
(
JSContext
*
cx
jsbytecode
*
pc
)
;
void
destroyBreakpointSite
(
js
:
:
FreeOp
*
fop
jsbytecode
*
pc
)
;
void
clearBreakpointsIn
(
js
:
:
FreeOp
*
fop
js
:
:
Debugger
*
dbg
JSObject
*
handler
)
;
bool
incrementStepModeCount
(
JSContext
*
cx
)
;
void
decrementStepModeCount
(
js
:
:
FreeOp
*
fop
)
;
bool
stepModeEnabled
(
)
{
return
bitFields_
.
hasDebugScript_
&
&
!
!
debugScript
(
)
-
>
stepMode
;
}
#
ifdef
DEBUG
uint32_t
stepModeCount
(
)
{
return
bitFields_
.
hasDebugScript_
?
debugScript
(
)
-
>
stepMode
:
0
;
}
#
endif
void
setTopLevelPrivate
(
void
*
value
)
;
void
*
maybeTopLevelPrivate
(
)
const
;
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Script
;
void
traceChildren
(
JSTracer
*
trc
)
;
class
AutoDelazify
;
friend
class
AutoDelazify
;
class
AutoDelazify
{
JS
:
:
RootedScript
script_
;
JSContext
*
cx_
;
bool
oldDoNotRelazify_
;
public
:
explicit
AutoDelazify
(
JSContext
*
cx
JS
:
:
HandleFunction
fun
=
nullptr
)
:
script_
(
cx
)
cx_
(
cx
)
oldDoNotRelazify_
(
false
)
{
holdScript
(
fun
)
;
}
~
AutoDelazify
(
)
{
dropScript
(
)
;
}
void
operator
=
(
JS
:
:
HandleFunction
fun
)
{
dropScript
(
)
;
holdScript
(
fun
)
;
}
operator
JS
:
:
HandleScript
(
)
const
{
return
script_
;
}
explicit
operator
bool
(
)
const
{
return
script_
;
}
private
:
void
holdScript
(
JS
:
:
HandleFunction
fun
)
;
void
dropScript
(
)
;
}
;
inline
bool
trackRecordReplayProgress
(
)
const
;
}
;
static_assert
(
sizeof
(
JSScript
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
Size
of
JSScript
must
be
an
integral
multiple
of
js
:
:
gc
:
:
CellAlignBytes
"
)
;
namespace
js
{
class
LazyScript
:
public
gc
:
:
TenuredCell
{
private
:
WeakRef
<
JSScript
*
>
script_
;
GCPtrFunction
function_
;
GCPtr
<
TenuredCell
*
>
enclosingLazyScriptOrScope_
;
GCPtrObject
sourceObject_
;
void
*
table_
;
private
:
static
const
uint32_t
NumClosedOverBindingsBits
=
20
;
static
const
uint32_t
NumInnerFunctionsBits
=
20
;
struct
PackedView
{
uint32_t
shouldDeclareArguments
:
1
;
uint32_t
hasThisBinding
:
1
;
uint32_t
isAsync
:
1
;
uint32_t
numClosedOverBindings
:
NumClosedOverBindingsBits
;
uint32_t
numInnerFunctions
:
NumInnerFunctionsBits
;
uint32_t
isGenerator
:
1
;
uint32_t
strict
:
1
;
uint32_t
bindingsAccessedDynamically
:
1
;
uint32_t
hasDebuggerStatement
:
1
;
uint32_t
hasDirectEval
:
1
;
uint32_t
isLikelyConstructorWrapper
:
1
;
uint32_t
hasBeenCloned
:
1
;
uint32_t
treatAsRunOnce
:
1
;
uint32_t
isDerivedClassConstructor
:
1
;
uint32_t
needsHomeObject
:
1
;
uint32_t
hasRest
:
1
;
uint32_t
parseGoal
:
1
;
}
;
union
{
PackedView
p_
;
uint64_t
packedFields_
;
}
;
uint32_t
sourceStart_
;
uint32_t
sourceEnd_
;
uint32_t
toStringStart_
;
uint32_t
toStringEnd_
;
uint32_t
lineno_
;
uint32_t
column_
;
LazyScript
(
JSFunction
*
fun
ScriptSourceObject
&
sourceObject
void
*
table
uint64_t
packedFields
uint32_t
begin
uint32_t
end
uint32_t
toStringStart
uint32_t
lineno
uint32_t
column
)
;
static
LazyScript
*
CreateRaw
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
uint64_t
packedData
uint32_t
begin
uint32_t
end
uint32_t
toStringStart
uint32_t
lineno
uint32_t
column
)
;
public
:
static
const
uint32_t
NumClosedOverBindingsLimit
=
1
<
<
NumClosedOverBindingsBits
;
static
const
uint32_t
NumInnerFunctionsLimit
=
1
<
<
NumInnerFunctionsBits
;
static
LazyScript
*
Create
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
const
frontend
:
:
AtomVector
&
closedOverBindings
Handle
<
GCVector
<
JSFunction
*
8
>
>
innerFunctions
uint32_t
begin
uint32_t
end
uint32_t
toStringStart
uint32_t
lineno
uint32_t
column
frontend
:
:
ParseGoal
parseGoal
)
;
static
LazyScript
*
CreateForXDR
(
JSContext
*
cx
HandleFunction
fun
HandleScript
script
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
uint64_t
packedData
uint32_t
begin
uint32_t
end
uint32_t
toStringStart
uint32_t
lineno
uint32_t
column
)
;
void
initRuntimeFields
(
uint64_t
packedFields
)
;
static
inline
JSFunction
*
functionDelazifying
(
JSContext
*
cx
Handle
<
LazyScript
*
>
)
;
JSFunction
*
functionNonDelazifying
(
)
const
{
return
function_
;
}
JS
:
:
Compartment
*
compartment
(
)
const
;
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
Realm
*
realm
(
)
const
;
void
initScript
(
JSScript
*
script
)
;
JSScript
*
maybeScript
(
)
{
return
script_
;
}
const
JSScript
*
maybeScriptUnbarriered
(
)
const
{
return
script_
.
unbarrieredGet
(
)
;
}
bool
hasScript
(
)
const
{
return
bool
(
script_
)
;
}
bool
hasEnclosingScope
(
)
const
{
return
enclosingLazyScriptOrScope_
&
&
enclosingLazyScriptOrScope_
-
>
is
<
Scope
>
(
)
;
}
bool
hasEnclosingLazyScript
(
)
const
{
return
enclosingLazyScriptOrScope_
&
&
enclosingLazyScriptOrScope_
-
>
is
<
LazyScript
>
(
)
;
}
LazyScript
*
enclosingLazyScript
(
)
const
{
MOZ_ASSERT
(
hasEnclosingLazyScript
(
)
)
;
return
enclosingLazyScriptOrScope_
-
>
as
<
LazyScript
>
(
)
;
}
void
setEnclosingLazyScript
(
LazyScript
*
enclosingLazyScript
)
;
Scope
*
enclosingScope
(
)
const
{
MOZ_ASSERT
(
hasEnclosingScope
(
)
)
;
return
enclosingLazyScriptOrScope_
-
>
as
<
Scope
>
(
)
;
}
void
setEnclosingScope
(
Scope
*
enclosingScope
)
;
bool
hasNonSyntacticScope
(
)
const
{
return
enclosingScope
(
)
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
;
}
ScriptSourceObject
&
sourceObject
(
)
const
;
ScriptSource
*
scriptSource
(
)
const
{
return
sourceObject
(
)
.
source
(
)
;
}
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
uint32_t
numClosedOverBindings
(
)
const
{
return
p_
.
numClosedOverBindings
;
}
JSAtom
*
*
closedOverBindings
(
)
{
return
(
JSAtom
*
*
)
table_
;
}
uint32_t
numInnerFunctions
(
)
const
{
return
p_
.
numInnerFunctions
;
}
GCPtrFunction
*
innerFunctions
(
)
{
return
(
GCPtrFunction
*
)
&
closedOverBindings
(
)
[
numClosedOverBindings
(
)
]
;
}
GeneratorKind
generatorKind
(
)
const
{
return
p_
.
isGenerator
?
GeneratorKind
:
:
Generator
:
GeneratorKind
:
:
NotGenerator
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
=
=
GeneratorKind
:
:
Generator
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
p_
.
isGenerator
=
kind
=
=
GeneratorKind
:
:
Generator
;
}
FunctionAsyncKind
asyncKind
(
)
const
{
return
p_
.
isAsync
?
FunctionAsyncKind
:
:
AsyncFunction
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
isAsync
(
)
const
{
return
p_
.
isAsync
;
}
void
setAsyncKind
(
FunctionAsyncKind
kind
)
{
p_
.
isAsync
=
kind
=
=
FunctionAsyncKind
:
:
AsyncFunction
;
}
bool
hasRest
(
)
const
{
return
p_
.
hasRest
;
}
void
setHasRest
(
)
{
p_
.
hasRest
=
true
;
}
frontend
:
:
ParseGoal
parseGoal
(
)
const
{
return
frontend
:
:
ParseGoal
(
p_
.
parseGoal
)
;
}
bool
strict
(
)
const
{
return
p_
.
strict
;
}
void
setStrict
(
)
{
p_
.
strict
=
true
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
p_
.
bindingsAccessedDynamically
;
}
void
setBindingsAccessedDynamically
(
)
{
p_
.
bindingsAccessedDynamically
=
true
;
}
bool
hasDebuggerStatement
(
)
const
{
return
p_
.
hasDebuggerStatement
;
}
void
setHasDebuggerStatement
(
)
{
p_
.
hasDebuggerStatement
=
true
;
}
bool
hasDirectEval
(
)
const
{
return
p_
.
hasDirectEval
;
}
void
setHasDirectEval
(
)
{
p_
.
hasDirectEval
=
true
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
p_
.
isLikelyConstructorWrapper
;
}
void
setLikelyConstructorWrapper
(
)
{
p_
.
isLikelyConstructorWrapper
=
true
;
}
bool
hasBeenCloned
(
)
const
{
return
p_
.
hasBeenCloned
;
}
void
setHasBeenCloned
(
)
{
p_
.
hasBeenCloned
=
true
;
}
bool
treatAsRunOnce
(
)
const
{
return
p_
.
treatAsRunOnce
;
}
void
setTreatAsRunOnce
(
)
{
p_
.
treatAsRunOnce
=
true
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
p_
.
isDerivedClassConstructor
;
}
void
setIsDerivedClassConstructor
(
)
{
p_
.
isDerivedClassConstructor
=
true
;
}
bool
needsHomeObject
(
)
const
{
return
p_
.
needsHomeObject
;
}
void
setNeedsHomeObject
(
)
{
p_
.
needsHomeObject
=
true
;
}
bool
shouldDeclareArguments
(
)
const
{
return
p_
.
shouldDeclareArguments
;
}
void
setShouldDeclareArguments
(
)
{
p_
.
shouldDeclareArguments
=
true
;
}
bool
hasThisBinding
(
)
const
{
return
p_
.
hasThisBinding
;
}
void
setHasThisBinding
(
)
{
p_
.
hasThisBinding
=
true
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
uint32_t
sourceStart
(
)
const
{
return
sourceStart_
;
}
uint32_t
sourceEnd
(
)
const
{
return
sourceEnd_
;
}
uint32_t
sourceLength
(
)
const
{
return
sourceEnd_
-
sourceStart_
;
}
uint32_t
toStringStart
(
)
const
{
return
toStringStart_
;
}
uint32_t
toStringEnd
(
)
const
{
return
toStringEnd_
;
}
uint32_t
lineno
(
)
const
{
return
lineno_
;
}
uint32_t
column
(
)
const
{
return
column_
;
}
void
setToStringEnd
(
uint32_t
toStringEnd
)
{
MOZ_ASSERT
(
toStringStart_
<
=
toStringEnd
)
;
MOZ_ASSERT
(
toStringEnd_
>
=
sourceEnd_
)
;
toStringEnd_
=
toStringEnd
;
}
bool
enclosingScriptHasEverBeenCompiled
(
)
const
{
return
hasEnclosingScope
(
)
;
}
friend
class
GCMarker
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
LazyScript
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
table_
)
;
}
uint64_t
packedFields
(
)
const
{
return
packedFields_
;
}
}
;
static_assert
(
sizeof
(
LazyScript
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
Size
of
LazyScript
must
be
an
integral
multiple
of
js
:
:
gc
:
:
CellAlignBytes
"
)
;
struct
ScriptAndCounts
{
JSScript
*
script
;
ScriptCounts
scriptCounts
;
inline
explicit
ScriptAndCounts
(
JSScript
*
script
)
;
inline
ScriptAndCounts
(
ScriptAndCounts
&
&
sac
)
;
const
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetPCCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
const
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetThrowCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
const
{
return
scriptCounts
.
ionCounts_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
script
"
ScriptAndCounts
:
:
script
"
)
;
}
}
;
extern
char
*
FormatIntroducedFilename
(
JSContext
*
cx
const
char
*
filename
unsigned
lineno
const
char
*
introducer
)
;
struct
GSNCache
;
jssrcnote
*
GetSrcNote
(
GSNCache
&
cache
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jssrcnote
*
GetSrcNote
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jsbytecode
*
LineNumberToPC
(
JSScript
*
script
unsigned
lineno
)
;
extern
JS_FRIEND_API
(
unsigned
)
GetScriptLineExtent
(
JSScript
*
script
)
;
}
namespace
js
{
extern
unsigned
PCToLineNumber
(
JSScript
*
script
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
unsigned
PCToLineNumber
(
unsigned
startLine
jssrcnote
*
notes
jsbytecode
*
code
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
void
DescribeScriptedCallerForCompilation
(
JSContext
*
cx
MutableHandleScript
maybeScript
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
extern
void
DescribeScriptedCallerForDirectEval
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
JSScript
*
CloneScriptIntoFunction
(
JSContext
*
cx
HandleScope
enclosingScope
HandleFunction
fun
HandleScript
src
)
;
JSScript
*
CloneGlobalScript
(
JSContext
*
cx
ScopeKind
scopeKind
HandleScript
src
)
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
LazyScript
>
:
TracerConcrete
<
js
:
:
LazyScript
>
{
protected
:
explicit
Concrete
(
js
:
:
LazyScript
*
ptr
)
:
TracerConcrete
<
js
:
:
LazyScript
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
LazyScript
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char
*
scriptFilename
(
)
const
final
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
