#
ifndef
vm_JSScript_h
#
define
vm_JSScript_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
StructuredSpewer
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
Time
.
h
"
namespace
JS
{
struct
ScriptSourceInfo
;
template
<
typename
UnitT
>
class
SourceText
;
}
namespace
js
{
namespace
coverage
{
class
LCovSource
;
}
namespace
jit
{
class
AutoKeepJitScripts
;
struct
BaselineScript
;
struct
IonScriptCounts
;
class
JitScript
;
}
class
AutoSweepJitScript
;
class
GCParallelTask
;
class
LazyScript
;
class
ModuleObject
;
class
RegExpObject
;
class
ScriptSourceHolder
;
class
SourceCompressionTask
;
class
Shape
;
class
DebugAPI
;
class
DebugScript
;
namespace
frontend
{
struct
BytecodeEmitter
;
class
FunctionBox
;
class
ModuleSharedContext
;
}
namespace
gc
{
void
SweepLazyScripts
(
GCParallelTask
*
task
)
;
}
namespace
detail
{
JSScript
*
CopyScript
(
JSContext
*
cx
HandleScript
src
HandleObject
functionOrGlobal
HandleScriptSourceObject
sourceObject
MutableHandle
<
GCVector
<
Scope
*
>
>
scopes
)
;
}
}
enum
JSTryNoteKind
{
JSTRY_CATCH
JSTRY_FINALLY
JSTRY_FOR_IN
JSTRY_DESTRUCTURING
JSTRY_FOR_OF
JSTRY_FOR_OF_ITERCLOSE
JSTRY_LOOP
}
;
struct
JSTryNote
{
uint32_t
kind
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
template
<
js
:
:
XDRMode
mode
>
js
:
:
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
)
;
}
;
namespace
js
{
struct
ScopeNote
{
static
const
uint32_t
NoScopeIndex
=
UINT32_MAX
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
uint32_t
index
;
uint32_t
start
;
uint32_t
length
;
uint32_t
parent
;
template
<
js
:
:
XDRMode
mode
>
js
:
:
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
)
;
}
;
class
ScriptCounts
{
public
:
typedef
mozilla
:
:
Vector
<
PCCounts
0
SystemAllocPolicy
>
PCCountsVector
;
inline
ScriptCounts
(
)
;
inline
explicit
ScriptCounts
(
PCCountsVector
&
&
jumpTargets
)
;
inline
ScriptCounts
(
ScriptCounts
&
&
src
)
;
inline
~
ScriptCounts
(
)
;
inline
ScriptCounts
&
operator
=
(
ScriptCounts
&
&
src
)
;
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
const
;
PCCounts
*
getImmediatePrecedingPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetThrowCounts
(
size_t
offset
)
const
;
const
PCCounts
*
getImmediatePrecedingThrowCounts
(
size_t
offset
)
const
;
PCCounts
*
getThrowCounts
(
size_t
offset
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
friend
class
:
:
JSScript
;
friend
struct
ScriptAndCounts
;
PCCountsVector
pcCounts_
;
PCCountsVector
throwCounts_
;
jit
:
:
IonScriptCounts
*
ionCounts_
;
}
;
using
UniqueScriptCounts
=
js
:
:
UniquePtr
<
ScriptCounts
>
;
using
ScriptCountsMap
=
HashMap
<
JSScript
*
UniqueScriptCounts
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
using
ScriptLCovMap
=
HashMap
<
JSScript
*
coverage
:
:
LCovSource
*
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
#
ifdef
MOZ_VTUNE
using
ScriptVTuneIdMap
=
HashMap
<
JSScript
*
uint32_t
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
#
endif
using
UniqueDebugScript
=
js
:
:
UniquePtr
<
DebugScript
JS
:
:
FreePolicy
>
;
using
DebugScriptMap
=
HashMap
<
JSScript
*
UniqueDebugScript
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
;
class
ScriptSource
;
struct
ScriptSourceChunk
{
ScriptSource
*
ss
=
nullptr
;
uint32_t
chunk
=
0
;
ScriptSourceChunk
(
)
=
default
;
ScriptSourceChunk
(
ScriptSource
*
ss
uint32_t
chunk
)
:
ss
(
ss
)
chunk
(
chunk
)
{
MOZ_ASSERT
(
valid
(
)
)
;
}
bool
valid
(
)
const
{
return
ss
!
=
nullptr
;
}
bool
operator
=
=
(
const
ScriptSourceChunk
&
other
)
const
{
return
ss
=
=
other
.
ss
&
&
chunk
=
=
other
.
chunk
;
}
}
;
struct
ScriptSourceChunkHasher
{
using
Lookup
=
ScriptSourceChunk
;
static
HashNumber
hash
(
const
ScriptSourceChunk
&
ssc
)
{
return
mozilla
:
:
AddToHash
(
DefaultHasher
<
ScriptSource
*
>
:
:
hash
(
ssc
.
ss
)
ssc
.
chunk
)
;
}
static
bool
match
(
const
ScriptSourceChunk
&
c1
const
ScriptSourceChunk
&
c2
)
{
return
c1
=
=
c2
;
}
}
;
template
<
typename
Unit
>
using
EntryUnits
=
mozilla
:
:
UniquePtr
<
Unit
[
]
JS
:
:
FreePolicy
>
;
using
SourceData
=
mozilla
:
:
UniquePtr
<
void
JS
:
:
FreePolicy
>
;
template
<
typename
Unit
>
inline
SourceData
ToSourceData
(
EntryUnits
<
Unit
>
chars
)
{
static_assert
(
std
:
:
is_same
<
SourceData
:
:
DeleterType
typename
EntryUnits
<
Unit
>
:
:
DeleterType
>
:
:
value
"
EntryUnits
and
SourceData
must
share
the
same
deleter
"
"
type
that
need
not
know
the
type
of
the
data
being
freed
"
"
for
the
upcast
below
to
be
safe
"
)
;
return
SourceData
(
chars
.
release
(
)
)
;
}
class
UncompressedSourceCache
{
using
Map
=
HashMap
<
ScriptSourceChunk
SourceData
ScriptSourceChunkHasher
SystemAllocPolicy
>
;
public
:
class
AutoHoldEntry
{
UncompressedSourceCache
*
cache_
=
nullptr
;
ScriptSourceChunk
sourceChunk_
=
{
}
;
SourceData
data_
=
nullptr
;
public
:
explicit
AutoHoldEntry
(
)
=
default
;
~
AutoHoldEntry
(
)
{
if
(
cache_
)
{
MOZ_ASSERT
(
sourceChunk_
.
valid
(
)
)
;
cache_
-
>
releaseEntry
(
*
this
)
;
}
}
template
<
typename
Unit
>
void
holdUnits
(
EntryUnits
<
Unit
>
units
)
{
MOZ_ASSERT
(
!
cache_
)
;
MOZ_ASSERT
(
!
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
data_
=
ToSourceData
(
std
:
:
move
(
units
)
)
;
}
private
:
void
holdEntry
(
UncompressedSourceCache
*
cache
const
ScriptSourceChunk
&
sourceChunk
)
{
MOZ_ASSERT
(
!
cache_
)
;
MOZ_ASSERT
(
!
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
cache_
=
cache
;
sourceChunk_
=
sourceChunk
;
}
void
deferDelete
(
SourceData
data
)
{
MOZ_ASSERT
(
cache_
)
;
MOZ_ASSERT
(
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
cache_
=
nullptr
;
sourceChunk_
=
ScriptSourceChunk
(
)
;
data_
=
std
:
:
move
(
data
)
;
}
const
ScriptSourceChunk
&
sourceChunk
(
)
const
{
return
sourceChunk_
;
}
friend
class
UncompressedSourceCache
;
}
;
private
:
UniquePtr
<
Map
>
map_
=
nullptr
;
AutoHoldEntry
*
holder_
=
nullptr
;
public
:
UncompressedSourceCache
(
)
=
default
;
template
<
typename
Unit
>
const
Unit
*
lookup
(
const
ScriptSourceChunk
&
ssc
AutoHoldEntry
&
asp
)
;
bool
put
(
const
ScriptSourceChunk
&
ssc
SourceData
data
AutoHoldEntry
&
asp
)
;
void
purge
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
void
holdEntry
(
AutoHoldEntry
&
holder
const
ScriptSourceChunk
&
ssc
)
;
void
releaseEntry
(
AutoHoldEntry
&
holder
)
;
}
;
template
<
typename
Unit
>
struct
SourceTypeTraits
;
template
<
>
struct
SourceTypeTraits
<
mozilla
:
:
Utf8Unit
>
{
using
CharT
=
char
;
using
SharedImmutableString
=
js
:
:
SharedImmutableString
;
static
const
mozilla
:
:
Utf8Unit
*
units
(
const
SharedImmutableString
&
string
)
{
return
reinterpret_cast
<
const
mozilla
:
:
Utf8Unit
*
>
(
string
.
chars
(
)
)
;
}
static
char
*
toString
(
const
mozilla
:
:
Utf8Unit
*
units
)
{
auto
asUnsigned
=
const_cast
<
unsigned
char
*
>
(
mozilla
:
:
Utf8AsUnsignedChars
(
units
)
)
;
return
reinterpret_cast
<
char
*
>
(
asUnsigned
)
;
}
static
UniqueChars
toCacheable
(
EntryUnits
<
mozilla
:
:
Utf8Unit
>
str
)
{
char
*
chars
=
toString
(
str
.
release
(
)
)
;
return
UniqueChars
(
chars
)
;
}
}
;
template
<
>
struct
SourceTypeTraits
<
char16_t
>
{
using
CharT
=
char16_t
;
using
SharedImmutableString
=
js
:
:
SharedImmutableTwoByteString
;
static
const
char16_t
*
units
(
const
SharedImmutableString
&
string
)
{
return
string
.
chars
(
)
;
}
static
char16_t
*
toString
(
const
char16_t
*
units
)
{
return
const_cast
<
char16_t
*
>
(
units
)
;
}
static
UniqueTwoByteChars
toCacheable
(
EntryUnits
<
char16_t
>
str
)
{
return
UniqueTwoByteChars
(
std
:
:
move
(
str
)
)
;
}
}
;
extern
MOZ_MUST_USE
bool
SynchronouslyCompressSource
(
JSContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
)
;
enum
class
SourceRetrievable
{
Yes
No
}
;
class
ScriptSource
{
friend
class
SourceCompressionTask
;
friend
bool
SynchronouslyCompressSource
(
JSContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
)
;
private
:
class
PinnedUnitsBase
{
protected
:
PinnedUnitsBase
*
*
stack_
=
nullptr
;
PinnedUnitsBase
*
prev_
=
nullptr
;
ScriptSource
*
source_
;
explicit
PinnedUnitsBase
(
ScriptSource
*
source
)
:
source_
(
source
)
{
}
}
;
public
:
template
<
typename
Unit
>
class
PinnedUnits
:
public
PinnedUnitsBase
{
const
Unit
*
units_
;
public
:
PinnedUnits
(
JSContext
*
cx
ScriptSource
*
source
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
begin
size_t
len
)
;
~
PinnedUnits
(
)
;
const
Unit
*
get
(
)
const
{
return
units_
;
}
const
typename
SourceTypeTraits
<
Unit
>
:
:
CharT
*
asChars
(
)
const
{
return
SourceTypeTraits
<
Unit
>
:
:
toString
(
get
(
)
)
;
}
}
;
private
:
struct
Missing
{
}
;
template
<
typename
Unit
>
struct
Retrievable
{
}
;
template
<
typename
Unit
>
class
UncompressedData
{
typename
SourceTypeTraits
<
Unit
>
:
:
SharedImmutableString
string_
;
public
:
explicit
UncompressedData
(
typename
SourceTypeTraits
<
Unit
>
:
:
SharedImmutableString
str
)
:
string_
(
std
:
:
move
(
str
)
)
{
}
const
Unit
*
units
(
)
const
{
return
SourceTypeTraits
<
Unit
>
:
:
units
(
string_
)
;
}
size_t
length
(
)
const
{
return
string_
.
length
(
)
;
}
}
;
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
class
Uncompressed
:
public
UncompressedData
<
Unit
>
{
using
Base
=
UncompressedData
<
Unit
>
;
public
:
using
Base
:
:
Base
;
}
;
template
<
typename
Unit
>
struct
CompressedData
{
SharedImmutableString
raw
;
size_t
uncompressedLength
;
CompressedData
(
SharedImmutableString
raw
size_t
uncompressedLength
)
:
raw
(
std
:
:
move
(
raw
)
)
uncompressedLength
(
uncompressedLength
)
{
}
}
;
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
struct
Compressed
:
public
CompressedData
<
Unit
>
{
using
Base
=
CompressedData
<
Unit
>
;
public
:
using
Base
:
:
Base
;
}
;
struct
BinAST
{
SharedImmutableString
string
;
UniquePtr
<
frontend
:
:
BinASTSourceMetadata
>
metadata
;
BinAST
(
SharedImmutableString
&
&
str
UniquePtr
<
frontend
:
:
BinASTSourceMetadata
>
metadata
)
:
string
(
std
:
:
move
(
str
)
)
metadata
(
std
:
:
move
(
metadata
)
)
{
}
}
;
using
SourceType
=
mozilla
:
:
Variant
<
Compressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
Yes
>
Uncompressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
Yes
>
Compressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
No
>
Uncompressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
No
>
Compressed
<
char16_t
SourceRetrievable
:
:
Yes
>
Uncompressed
<
char16_t
SourceRetrievable
:
:
Yes
>
Compressed
<
char16_t
SourceRetrievable
:
:
No
>
Uncompressed
<
char16_t
SourceRetrievable
:
:
No
>
Retrievable
<
mozilla
:
:
Utf8Unit
>
Retrievable
<
char16_t
>
Missing
BinAST
>
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
refs
=
{
}
;
uint32_t
id_
=
0
;
SourceType
data
=
SourceType
(
Missing
(
)
)
;
PinnedUnitsBase
*
pinnedUnitsStack_
=
nullptr
;
mozilla
:
:
MaybeOneOf
<
CompressedData
<
mozilla
:
:
Utf8Unit
>
CompressedData
<
char16_t
>
>
pendingCompressed_
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
filename_
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
introducerFilename_
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
displayURL_
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
sourceMapURL_
;
UniquePtr
<
XDRIncrementalEncoder
>
xdrEncoder_
=
nullptr
;
mozilla
:
:
TimeStamp
parseStarted_
;
mozilla
:
:
TimeStamp
emitStarted_
;
mozilla
:
:
TimeStamp
parseEnded_
;
const
char
*
introductionType_
=
nullptr
;
mozilla
:
:
Maybe
<
uint32_t
>
introductionOffset_
;
uint32_t
parameterListEnd_
=
0
;
uint32_t
startLine_
=
0
;
bool
mutedErrors_
=
false
;
bool
containsAsmJS_
=
false
;
static
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
idCount_
;
template
<
typename
Unit
>
const
Unit
*
chunkUnits
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
chunk
)
;
template
<
typename
Unit
>
const
Unit
*
units
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
asp
size_t
begin
size_t
len
)
;
public
:
static
const
size_t
SourceDeflateLimit
=
100
;
explicit
ScriptSource
(
)
:
id_
(
+
+
idCount_
)
{
}
void
finalizeGCData
(
)
;
~
ScriptSource
(
)
;
void
incref
(
)
{
refs
+
+
;
}
void
decref
(
)
{
MOZ_ASSERT
(
refs
!
=
0
)
;
if
(
-
-
refs
=
=
0
)
{
js_delete
(
this
)
;
}
}
MOZ_MUST_USE
bool
initFromOptions
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
mozilla
:
:
Maybe
<
uint32_t
>
&
parameterListEnd
=
mozilla
:
:
Nothing
(
)
)
;
static
constexpr
size_t
MinimumCompressibleLength
=
256
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreateStringZ
(
JSContext
*
cx
UniqueChars
&
&
str
)
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreateStringZ
(
JSContext
*
cx
UniqueTwoByteChars
&
&
str
)
;
private
:
class
LoadSourceMatcher
;
public
:
static
bool
loadSource
(
JSContext
*
cx
ScriptSource
*
ss
bool
*
loaded
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
assignSource
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Unit
>
&
srcBuf
)
;
bool
hasSourceText
(
)
const
{
return
hasUncompressedSource
(
)
|
|
hasCompressedSource
(
)
;
}
bool
hasBinASTSource
(
)
const
{
return
data
.
is
<
BinAST
>
(
)
;
}
void
setBinASTSourceMetadata
(
frontend
:
:
BinASTSourceMetadata
*
metadata
)
{
MOZ_ASSERT
(
hasBinASTSource
(
)
)
;
data
.
as
<
BinAST
>
(
)
.
metadata
.
reset
(
metadata
)
;
}
frontend
:
:
BinASTSourceMetadata
*
binASTSourceMetadata
(
)
const
{
MOZ_ASSERT
(
hasBinASTSource
(
)
)
;
return
data
.
as
<
BinAST
>
(
)
.
metadata
.
get
(
)
;
}
private
:
template
<
typename
Unit
>
struct
UncompressedDataMatcher
{
template
<
SourceRetrievable
CanRetrieve
>
const
UncompressedData
<
Unit
>
*
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
u
)
{
return
&
u
;
}
template
<
typename
T
>
const
UncompressedData
<
Unit
>
*
operator
(
)
(
const
T
&
)
{
MOZ_CRASH
(
"
attempting
to
access
uncompressed
data
in
a
ScriptSource
not
"
"
containing
it
"
)
;
return
nullptr
;
}
}
;
public
:
template
<
typename
Unit
>
const
UncompressedData
<
Unit
>
*
uncompressedData
(
)
{
return
data
.
match
(
UncompressedDataMatcher
<
Unit
>
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
CompressedDataMatcher
{
template
<
SourceRetrievable
CanRetrieve
>
const
CompressedData
<
Unit
>
*
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
c
)
{
return
&
c
;
}
template
<
typename
T
>
const
CompressedData
<
Unit
>
*
operator
(
)
(
const
T
&
)
{
MOZ_CRASH
(
"
attempting
to
access
compressed
data
in
a
ScriptSource
not
"
"
containing
it
"
)
;
return
nullptr
;
}
}
;
public
:
template
<
typename
Unit
>
const
CompressedData
<
Unit
>
*
compressedData
(
)
{
return
data
.
match
(
CompressedDataMatcher
<
Unit
>
(
)
)
;
}
private
:
struct
BinASTDataMatcher
{
void
*
operator
(
)
(
const
BinAST
&
b
)
{
return
const_cast
<
char
*
>
(
b
.
string
.
chars
(
)
)
;
}
void
notBinAST
(
)
{
MOZ_CRASH
(
"
ScriptSource
isn
'
t
backed
by
BinAST
data
"
)
;
}
template
<
typename
T
>
void
*
operator
(
)
(
const
T
&
)
{
notBinAST
(
)
;
return
nullptr
;
}
}
;
public
:
void
*
binASTData
(
)
{
return
data
.
match
(
BinASTDataMatcher
(
)
)
;
}
private
:
struct
HasUncompressedSource
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
false
;
}
template
<
typename
Unit
>
bool
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
BinAST
&
)
{
return
false
;
}
bool
operator
(
)
(
const
Missing
&
)
{
return
false
;
}
}
;
public
:
bool
hasUncompressedSource
(
)
const
{
return
data
.
match
(
HasUncompressedSource
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
IsUncompressed
{
template
<
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
isUncompressed
(
)
const
{
return
data
.
match
(
IsUncompressed
<
Unit
>
(
)
)
;
}
private
:
struct
HasCompressedSource
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
bool
hasCompressedSource
(
)
const
{
return
data
.
match
(
HasCompressedSource
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
IsCompressed
{
template
<
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
isCompressed
(
)
const
{
return
data
.
match
(
IsCompressed
<
Unit
>
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
SourceTypeMatcher
{
template
<
template
<
typename
C
SourceRetrievable
R
>
class
Data
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Data
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
template
<
typename
C
SourceRetrievable
R
>
class
Data
typename
NotUnit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Data
<
NotUnit
CanRetrieve
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
source
type
only
applies
where
actual
text
is
available
"
)
;
return
false
;
}
template
<
typename
NotUnit
>
bool
operator
(
)
(
const
Retrievable
<
NotUnit
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
BinAST
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
ask
source
type
of
BinAST
data
"
)
;
return
false
;
}
bool
operator
(
)
(
const
Missing
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
ask
source
type
when
missing
"
)
;
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
hasSourceType
(
)
const
{
return
data
.
match
(
SourceTypeMatcher
<
Unit
>
(
)
)
;
}
private
:
struct
UncompressedLengthMatcher
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
size_t
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
u
)
{
return
u
.
length
(
)
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
size_t
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
u
)
{
return
u
.
uncompressedLength
;
}
template
<
typename
Unit
>
size_t
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
-
but
-
retrievable
source
"
)
;
return
0
;
}
size_t
operator
(
)
(
const
BinAST
&
b
)
{
return
b
.
string
.
length
(
)
;
}
size_t
operator
(
)
(
const
Missing
&
m
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
source
"
)
;
return
0
;
}
}
;
public
:
size_t
length
(
)
const
{
MOZ_ASSERT
(
hasSourceText
(
)
|
|
hasBinASTSource
(
)
)
;
return
data
.
match
(
UncompressedLengthMatcher
(
)
)
;
}
JSLinearString
*
substring
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
JSLinearString
*
substringDontDeflate
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
MOZ_MUST_USE
bool
appendSubstring
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
size_t
start
size_t
stop
)
;
bool
isFunctionBody
(
)
{
return
parameterListEnd_
!
=
0
;
}
JSLinearString
*
functionBodyString
(
JSContext
*
cx
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ScriptSourceInfo
*
info
)
const
;
private
:
template
<
typename
Unit
>
MOZ_MUST_USE
bool
setUncompressedSourceHelper
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
SourceRetrievable
retrievable
)
;
public
:
template
<
typename
Unit
>
MOZ_MUST_USE
bool
initializeUnretrievableUncompressedSource
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
setRetrievedSource
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
)
;
MOZ_MUST_USE
bool
tryCompressOffThread
(
JSContext
*
cx
)
;
template
<
typename
Unit
>
void
triggerConvertToCompressedSource
(
SharedImmutableString
compressed
size_t
sourceLength
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
initializeWithUnretrievableCompressedSource
(
JSContext
*
cx
UniqueChars
&
&
raw
size_t
rawLength
size_t
sourceLength
)
;
#
if
defined
(
JS_BUILD_BINAST
)
MOZ_MUST_USE
bool
setBinASTSourceCopy
(
JSContext
*
cx
const
uint8_t
*
buf
size_t
len
)
;
const
uint8_t
*
binASTSource
(
)
;
#
endif
private
:
void
performTaskWork
(
SourceCompressionTask
*
task
)
;
struct
TriggerConvertToCompressedSourceFromTask
{
ScriptSource
*
const
source_
;
SharedImmutableString
&
compressed_
;
TriggerConvertToCompressedSourceFromTask
(
ScriptSource
*
source
SharedImmutableString
&
compressed
)
:
source_
(
source
)
compressed_
(
compressed
)
{
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
void
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
source_
-
>
triggerConvertToCompressedSource
<
Unit
>
(
std
:
:
move
(
compressed_
)
source_
-
>
length
(
)
)
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
void
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
MOZ_CRASH
(
"
can
'
t
set
compressed
source
when
source
is
already
compressed
-
-
"
"
ScriptSource
:
:
tryCompressOffThread
shouldn
'
t
have
queued
up
this
"
"
task
?
"
)
;
}
template
<
typename
Unit
>
void
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
shouldn
'
t
compressing
unloaded
-
but
-
retrievable
source
"
)
;
}
void
operator
(
)
(
const
BinAST
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
set
compressed
source
for
BinAST
data
"
)
;
}
void
operator
(
)
(
const
Missing
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
set
compressed
source
for
missing
source
-
-
"
"
ScriptSource
:
:
tryCompressOffThread
shouldn
'
t
have
queued
up
this
"
"
task
?
"
)
;
}
}
;
template
<
typename
Unit
>
void
convertToCompressedSource
(
SharedImmutableString
compressed
size_t
uncompressedLength
)
;
template
<
typename
Unit
>
void
performDelayedConvertToCompressedSource
(
)
;
void
triggerConvertToCompressedSourceFromTask
(
SharedImmutableString
compressed
)
;
private
:
template
<
XDRMode
mode
>
MOZ_MUST_USE
XDRResult
xdrUnretrievableUncompressedSource
(
XDRState
<
mode
>
*
xdr
uint8_t
sourceCharSize
uint32_t
uncompressedLength
)
;
public
:
const
char
*
filename
(
)
const
{
return
filename_
?
filename_
.
ref
(
)
.
chars
(
)
:
nullptr
;
}
MOZ_MUST_USE
bool
setFilename
(
JSContext
*
cx
const
char
*
filename
)
;
MOZ_MUST_USE
bool
setFilename
(
JSContext
*
cx
UniqueChars
&
&
filename
)
;
const
char
*
introducerFilename
(
)
const
{
return
introducerFilename_
?
introducerFilename_
.
ref
(
)
.
chars
(
)
:
filename
(
)
;
}
MOZ_MUST_USE
bool
setIntroducerFilename
(
JSContext
*
cx
const
char
*
filename
)
;
MOZ_MUST_USE
bool
setIntroducerFilename
(
JSContext
*
cx
UniqueChars
&
&
filename
)
;
bool
hasIntroductionType
(
)
const
{
return
introductionType_
;
}
const
char
*
introductionType
(
)
const
{
MOZ_ASSERT
(
hasIntroductionType
(
)
)
;
return
introductionType_
;
}
uint32_t
id
(
)
const
{
return
id_
;
}
MOZ_MUST_USE
bool
setDisplayURL
(
JSContext
*
cx
const
char16_t
*
url
)
;
MOZ_MUST_USE
bool
setDisplayURL
(
JSContext
*
cx
UniqueTwoByteChars
&
&
url
)
;
bool
hasDisplayURL
(
)
const
{
return
displayURL_
.
isSome
(
)
;
}
const
char16_t
*
displayURL
(
)
{
return
displayURL_
.
ref
(
)
.
chars
(
)
;
}
MOZ_MUST_USE
bool
setSourceMapURL
(
JSContext
*
cx
const
char16_t
*
url
)
;
MOZ_MUST_USE
bool
setSourceMapURL
(
JSContext
*
cx
UniqueTwoByteChars
&
&
url
)
;
bool
hasSourceMapURL
(
)
const
{
return
sourceMapURL_
.
isSome
(
)
;
}
const
char16_t
*
sourceMapURL
(
)
{
return
sourceMapURL_
.
ref
(
)
.
chars
(
)
;
}
bool
mutedErrors
(
)
const
{
return
mutedErrors_
;
}
uint32_t
startLine
(
)
const
{
return
startLine_
;
}
bool
hasIntroductionOffset
(
)
const
{
return
introductionOffset_
.
isSome
(
)
;
}
uint32_t
introductionOffset
(
)
const
{
return
introductionOffset_
.
value
(
)
;
}
void
setIntroductionOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
hasIntroductionOffset
(
)
)
;
MOZ_ASSERT
(
offset
<
=
(
uint32_t
)
INT32_MAX
)
;
introductionOffset_
.
emplace
(
offset
)
;
}
bool
containsAsmJS
(
)
const
{
return
containsAsmJS_
;
}
void
setContainsAsmJS
(
)
{
containsAsmJS_
=
true
;
}
bool
hasEncoder
(
)
const
{
return
bool
(
xdrEncoder_
)
;
}
bool
xdrEncodeTopLevel
(
JSContext
*
cx
HandleScript
script
)
;
bool
xdrEncodeFunction
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
)
;
bool
xdrFinalizeEncoder
(
JS
:
:
TranscodeBuffer
&
buffer
)
;
const
mozilla
:
:
TimeStamp
parseEnded
(
)
const
{
return
parseEnded_
;
}
const
mozilla
:
:
TimeDuration
parseTime
(
)
const
{
return
emitStarted_
-
parseStarted_
;
}
const
mozilla
:
:
TimeDuration
emitTime
(
)
const
{
return
parseEnded_
-
emitStarted_
;
}
void
recordParseStarted
(
)
{
MOZ_ASSERT
(
parseStarted_
.
IsNull
(
)
)
;
parseStarted_
=
ReallyNow
(
)
;
}
void
recordEmitStarted
(
)
{
MOZ_ASSERT
(
emitStarted_
.
IsNull
(
)
)
;
emitStarted_
=
ReallyNow
(
)
;
}
void
recordParseEnded
(
)
{
MOZ_ASSERT
(
parseEnded_
.
IsNull
(
)
)
;
parseEnded_
=
ReallyNow
(
)
;
}
private
:
template
<
typename
Unit
template
<
typename
U
SourceRetrievable
CanRetrieve
>
class
Data
XDRMode
mode
>
static
void
codeRetrievable
(
ScriptSource
*
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
codeUncompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
codeCompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
codeBinASTData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
void
codeRetrievableData
(
ScriptSource
*
ss
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
xdrData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
public
:
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
const
mozilla
:
:
Maybe
<
JS
:
:
CompileOptions
>
&
options
MutableHandle
<
ScriptSourceHolder
>
ss
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ScriptSourceHolder
{
ScriptSource
*
ss
;
public
:
ScriptSourceHolder
(
)
:
ss
(
nullptr
)
{
}
explicit
ScriptSourceHolder
(
ScriptSource
*
ss
)
:
ss
(
ss
)
{
ss
-
>
incref
(
)
;
}
~
ScriptSourceHolder
(
)
{
if
(
ss
)
{
ss
-
>
decref
(
)
;
}
}
void
reset
(
ScriptSource
*
newss
)
{
if
(
newss
)
{
newss
-
>
incref
(
)
;
}
if
(
ss
)
{
ss
-
>
decref
(
)
;
}
ss
=
newss
;
}
ScriptSource
*
get
(
)
const
{
return
ss
;
}
void
trace
(
JSTracer
*
trc
)
{
ss
-
>
trace
(
trc
)
;
}
}
;
class
ScriptSourceObject
:
public
NativeObject
{
static
const
JSClassOps
classOps_
;
static
ScriptSourceObject
*
createInternal
(
JSContext
*
cx
ScriptSource
*
source
HandleObject
canonical
)
;
bool
isCanonical
(
)
const
{
return
&
getReservedSlot
(
CANONICAL_SLOT
)
.
toObject
(
)
=
=
this
;
}
ScriptSourceObject
*
unwrappedCanonical
(
)
const
;
public
:
static
const
JSClass
class_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
ScriptSourceObject
*
create
(
JSContext
*
cx
ScriptSource
*
source
)
;
static
ScriptSourceObject
*
clone
(
JSContext
*
cx
HandleScriptSourceObject
sso
)
;
static
bool
initFromOptions
(
JSContext
*
cx
HandleScriptSourceObject
source
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
static
bool
initElementProperties
(
JSContext
*
cx
HandleScriptSourceObject
source
HandleObject
element
HandleString
elementAttrName
)
;
bool
hasSource
(
)
const
{
return
!
getReservedSlot
(
SOURCE_SLOT
)
.
isUndefined
(
)
;
}
ScriptSource
*
source
(
)
const
{
return
static_cast
<
ScriptSource
*
>
(
getReservedSlot
(
SOURCE_SLOT
)
.
toPrivate
(
)
)
;
}
JSObject
*
unwrappedElement
(
)
const
{
return
unwrappedCanonical
(
)
-
>
getReservedSlot
(
ELEMENT_SLOT
)
.
toObjectOrNull
(
)
;
}
const
Value
&
unwrappedElementAttributeName
(
)
const
{
const
Value
&
v
=
unwrappedCanonical
(
)
-
>
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
;
MOZ_ASSERT
(
!
v
.
isMagic
(
)
)
;
return
v
;
}
JSScript
*
unwrappedIntroductionScript
(
)
const
{
Value
value
=
unwrappedCanonical
(
)
-
>
getReservedSlot
(
INTRODUCTION_SCRIPT_SLOT
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
value
.
toGCThing
(
)
-
>
as
<
JSScript
>
(
)
;
}
void
setPrivate
(
JSRuntime
*
rt
const
Value
&
value
)
;
Value
canonicalPrivate
(
)
const
{
Value
value
=
getReservedSlot
(
PRIVATE_SLOT
)
;
MOZ_ASSERT_IF
(
!
isCanonical
(
)
value
.
isUndefined
(
)
)
;
return
value
;
}
private
:
enum
{
SOURCE_SLOT
=
0
CANONICAL_SLOT
ELEMENT_SLOT
ELEMENT_PROPERTY_SLOT
INTRODUCTION_SCRIPT_SLOT
PRIVATE_SLOT
RESERVED_SLOTS
}
;
}
;
enum
class
GeneratorKind
:
bool
{
NotGenerator
Generator
}
;
enum
class
FunctionAsyncKind
:
bool
{
SyncFunction
AsyncFunction
}
;
class
BaseScript
:
public
gc
:
:
TenuredCell
{
protected
:
uint8_t
*
jitCodeRaw_
=
nullptr
;
const
GCPtrObject
functionOrGlobal_
;
GCPtr
<
ScriptSourceObject
*
>
sourceObject_
=
{
}
;
uint32_t
sourceStart_
=
0
;
uint32_t
sourceEnd_
=
0
;
uint32_t
toStringStart_
=
0
;
uint32_t
toStringEnd_
=
0
;
uint32_t
lineno_
=
0
;
uint32_t
column_
=
0
;
uint32_t
immutableFlags_
=
0
;
uint32_t
mutableFlags_
=
0
;
BaseScript
(
uint8_t
*
stubEntry
JSObject
*
functionOrGlobal
ScriptSourceObject
*
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
)
:
jitCodeRaw_
(
stubEntry
)
functionOrGlobal_
(
functionOrGlobal
)
sourceObject_
(
sourceObject
)
sourceStart_
(
sourceStart
)
sourceEnd_
(
sourceEnd
)
toStringStart_
(
toStringStart
)
toStringEnd_
(
toStringEnd
)
{
MOZ_ASSERT
(
functionOrGlobal
-
>
compartment
(
)
=
=
sourceObject
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
toStringStart
<
=
sourceStart
)
;
MOZ_ASSERT
(
sourceStart
<
=
sourceEnd
)
;
MOZ_ASSERT
(
sourceEnd
<
=
toStringEnd
)
;
}
public
:
enum
class
ImmutableFlags
:
uint32_t
{
NoScriptRval
=
1
<
<
0
Strict
=
1
<
<
1
HasNonSyntacticScope
=
1
<
<
3
SelfHosted
=
1
<
<
4
BindingsAccessedDynamically
=
1
<
<
5
FunHasExtensibleScope
=
1
<
<
6
HasCallSiteObj
=
1
<
<
7
FunctionHasThisBinding
=
1
<
<
9
FunctionHasExtraBodyVarScope
=
1
<
<
10
HasMappedArgsObj
=
1
<
<
11
HasInnerFunctions
=
1
<
<
12
NeedsHomeObject
=
1
<
<
13
IsDerivedClassConstructor
=
1
<
<
14
IsDefaultClassConstructor
=
1
<
<
15
TreatAsRunOnce
=
1
<
<
16
IsLikelyConstructorWrapper
=
1
<
<
17
IsGenerator
=
1
<
<
18
IsAsync
=
1
<
<
19
HasRest
=
1
<
<
20
ArgumentsHasVarBinding
=
1
<
<
21
IsForEval
=
1
<
<
22
IsModule
=
1
<
<
23
NeedsFunctionEnvironmentObjects
=
1
<
<
24
ShouldDeclareArguments
=
1
<
<
25
IsFunction
=
1
<
<
26
HasDirectEval
=
1
<
<
27
}
;
enum
class
MutableFlags
:
uint32_t
{
WarmupResets_MASK
=
0xFF
WarnedAboutUndefinedProp
=
1
<
<
8
HasRunOnce
=
1
<
<
9
HasBeenCloned
=
1
<
<
10
TrackRecordReplayProgress
=
1
<
<
11
HasScriptCounts
=
1
<
<
12
HasDebugScript
=
1
<
<
13
DoNotRelazify
=
1
<
<
14
FailedBoundsCheck
=
1
<
<
15
FailedShapeGuard
=
1
<
<
16
HadFrequentBailouts
=
1
<
<
17
HadOverflowBailout
=
1
<
<
18
BaselineDisabled
=
1
<
<
19
IonDisabled
=
1
<
<
20
Uninlineable
=
1
<
<
21
InvalidatedIdempotentCache
=
1
<
<
22
FailedLexicalCheck
=
1
<
<
23
NeedsArgsAnalysis
=
1
<
<
24
NeedsArgsObj
=
1
<
<
25
HideScriptFromDebugger
=
1
<
<
26
SpewEnabled
=
1
<
<
27
WrappedByDebugger
=
1
<
<
28
}
;
uint8_t
*
jitCodeRaw
(
)
const
{
return
jitCodeRaw_
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
functionOrGlobal_
-
>
nonCCWRealm
(
)
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
functionOrGlobal_
-
>
compartment
(
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
ScriptSourceObject
*
sourceObject
(
)
const
{
return
sourceObject_
;
}
ScriptSource
*
scriptSource
(
)
const
{
return
sourceObject
(
)
-
>
source
(
)
;
}
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
const
char
*
maybeForwardedFilename
(
)
const
{
return
maybeForwardedScriptSource
(
)
-
>
filename
(
)
;
}
uint32_t
sourceStart
(
)
const
{
return
sourceStart_
;
}
uint32_t
sourceEnd
(
)
const
{
return
sourceEnd_
;
}
uint32_t
sourceLength
(
)
const
{
return
sourceEnd_
-
sourceStart_
;
}
uint32_t
toStringStart
(
)
const
{
return
toStringStart_
;
}
uint32_t
toStringEnd
(
)
const
{
return
toStringEnd_
;
}
void
setToStringEnd
(
uint32_t
toStringEnd
)
{
MOZ_ASSERT
(
toStringStart_
<
=
toStringEnd
)
;
MOZ_ASSERT
(
toStringEnd_
>
=
sourceEnd_
)
;
toStringEnd_
=
toStringEnd
;
}
uint32_t
lineno
(
)
const
{
return
lineno_
;
}
uint32_t
column
(
)
const
{
return
column_
;
}
MOZ_MUST_USE
bool
hasFlag
(
ImmutableFlags
flag
)
const
{
return
immutableFlags_
&
uint32_t
(
flag
)
;
}
uint32_t
immutableFlags
(
)
const
{
return
immutableFlags_
;
}
protected
:
void
setFlag
(
ImmutableFlags
flag
)
{
immutableFlags_
|
=
uint32_t
(
flag
)
;
}
void
setFlag
(
ImmutableFlags
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
void
clearFlag
(
ImmutableFlags
flag
)
{
immutableFlags_
&
=
~
uint32_t
(
flag
)
;
}
public
:
MOZ_MUST_USE
bool
hasFlag
(
MutableFlags
flag
)
const
{
return
mutableFlags_
&
uint32_t
(
flag
)
;
}
void
setFlag
(
MutableFlags
flag
)
{
mutableFlags_
|
=
uint32_t
(
flag
)
;
}
void
setFlag
(
MutableFlags
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
void
clearFlag
(
MutableFlags
flag
)
{
mutableFlags_
&
=
~
uint32_t
(
flag
)
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
#
define
FLAG_GETTER
(
enumName
enumEntry
lowerName
)
\
public
:
\
bool
lowerName
(
)
const
{
return
hasFlag
(
enumName
:
:
enumEntry
)
;
}
#
define
FLAG_GETTER_SETTER
(
enumName
enumEntry
setterLevel
lowerName
name
)
\
setterLevel
:
\
void
set
#
#
name
(
)
{
setFlag
(
enumName
:
:
enumEntry
)
;
}
\
void
set
#
#
name
(
bool
b
)
{
setFlag
(
enumName
:
:
enumEntry
b
)
;
}
\
void
clear
#
#
name
(
)
{
clearFlag
(
enumName
:
:
enumEntry
)
;
}
\
\
public
:
\
bool
lowerName
(
)
const
{
return
hasFlag
(
enumName
:
:
enumEntry
)
;
}
#
define
IMMUTABLE_FLAG_GETTER
(
lowerName
name
)
\
FLAG_GETTER
(
ImmutableFlags
name
lowerName
)
#
define
IMMUTABLE_FLAG_GETTER_SETTER
(
lowerName
name
)
\
FLAG_GETTER_SETTER
(
ImmutableFlags
name
protected
lowerName
name
)
#
define
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
lowerName
name
)
\
FLAG_GETTER_SETTER
(
ImmutableFlags
name
public
lowerName
name
)
#
define
IMMUTABLE_FLAG_GETTER_SETTER_CUSTOM_PUBLIC
(
enumName
lowerName
name
)
\
FLAG_GETTER_SETTER
(
ImmutableFlags
enumName
public
lowerName
name
)
#
define
MUTABLE_FLAG_GETTER
(
lowerName
name
)
\
FLAG_GETTER
(
MutableFlags
name
lowerName
)
#
define
MUTABLE_FLAG_GETTER_SETTER
(
lowerName
name
)
\
FLAG_GETTER_SETTER
(
MutableFlags
name
public
lowerName
name
)
IMMUTABLE_FLAG_GETTER
(
noScriptRval
NoScriptRval
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
strict
Strict
)
IMMUTABLE_FLAG_GETTER
(
hasNonSyntacticScope
HasNonSyntacticScope
)
IMMUTABLE_FLAG_GETTER
(
selfHosted
SelfHosted
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
bindingsAccessedDynamically
BindingsAccessedDynamically
)
IMMUTABLE_FLAG_GETTER
(
funHasExtensibleScope
FunHasExtensibleScope
)
IMMUTABLE_FLAG_GETTER
(
hasCallSiteObj
HasCallSiteObj
)
IMMUTABLE_FLAG_GETTER_SETTER
(
functionHasThisBinding
FunctionHasThisBinding
)
IMMUTABLE_FLAG_GETTER_SETTER_CUSTOM_PUBLIC
(
FunctionHasThisBinding
hasThisBinding
HasThisBinding
)
IMMUTABLE_FLAG_GETTER_SETTER
(
hasMappedArgsObj
HasMappedArgsObj
)
IMMUTABLE_FLAG_GETTER_SETTER
(
hasInnerFunctions
HasInnerFunctions
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
needsHomeObject
NeedsHomeObject
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
isDerivedClassConstructor
IsDerivedClassConstructor
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
isDefaultClassConstructor
IsDefaultClassConstructor
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
treatAsRunOnce
TreatAsRunOnce
)
IMMUTABLE_FLAG_GETTER_SETTER
(
isLikelyConstructorWrapper
IsLikelyConstructorWrapper
)
IMMUTABLE_FLAG_GETTER_SETTER_CUSTOM_PUBLIC
(
IsLikelyConstructorWrapper
likelyConstructorWrapper
LikelyConstructorWrapper
)
IMMUTABLE_FLAG_GETTER
(
isGenerator
IsGenerator
)
IMMUTABLE_FLAG_GETTER
(
isAsync
IsAsync
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
hasRest
HasRest
)
IMMUTABLE_FLAG_GETTER
(
argumentsHasVarBinding
ArgumentsHasVarBinding
)
IMMUTABLE_FLAG_GETTER_SETTER
(
needsFunctionEnvironmentObjects
NeedsFunctionEnvironmentObjects
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
shouldDeclareArguments
ShouldDeclareArguments
)
IMMUTABLE_FLAG_GETTER
(
isFunction
IsFunction
)
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
(
hasDirectEval
HasDirectEval
)
MUTABLE_FLAG_GETTER_SETTER
(
warnedAboutUndefinedProp
WarnedAboutUndefinedProp
)
MUTABLE_FLAG_GETTER_SETTER
(
hasRunOnce
HasRunOnce
)
MUTABLE_FLAG_GETTER_SETTER
(
hasBeenCloned
HasBeenCloned
)
MUTABLE_FLAG_GETTER_SETTER
(
trackRecordReplayProgress
TrackRecordReplayProgress
)
MUTABLE_FLAG_GETTER
(
hasScriptCounts
HasScriptCounts
)
MUTABLE_FLAG_GETTER_SETTER
(
hasDebugScript
HasDebugScript
)
MUTABLE_FLAG_GETTER_SETTER
(
doNotRelazify
DoNotRelazify
)
MUTABLE_FLAG_GETTER_SETTER
(
failedBoundsCheck
FailedBoundsCheck
)
MUTABLE_FLAG_GETTER_SETTER
(
failedShapeGuard
FailedShapeGuard
)
MUTABLE_FLAG_GETTER_SETTER
(
hadFrequentBailouts
HadFrequentBailouts
)
MUTABLE_FLAG_GETTER_SETTER
(
hadOverflowBailout
HadOverflowBailout
)
MUTABLE_FLAG_GETTER_SETTER
(
uninlineable
Uninlineable
)
MUTABLE_FLAG_GETTER_SETTER
(
invalidatedIdempotentCache
InvalidatedIdempotentCache
)
MUTABLE_FLAG_GETTER_SETTER
(
failedLexicalCheck
FailedLexicalCheck
)
MUTABLE_FLAG_GETTER_SETTER
(
needsArgsAnalysis
NeedsArgsAnalysis
)
MUTABLE_FLAG_GETTER_SETTER
(
hideScriptFromDebugger
HideScriptFromDebugger
)
MUTABLE_FLAG_GETTER_SETTER
(
spewEnabled
SpewEnabled
)
#
undef
IMMUTABLE_FLAG_GETTER
#
undef
IMMUTABLE_FLAG_GETTER_SETTER
#
undef
IMMUTABLE_FLAG_GETTER_SETTER_PUBLIC
#
undef
IMMUTABLE_FLAG_GETTER_SETTER_CUSTOM_PUBLIC
#
undef
MUTABLE_FLAG_GETTER
#
undef
MUTABLE_FLAG_GETTER_SETTER
#
undef
FLAG_GETTER
#
undef
FLAG_GETTER_SETTER
GeneratorKind
generatorKind
(
)
const
{
return
isGenerator
(
)
?
GeneratorKind
:
:
Generator
:
GeneratorKind
:
:
NotGenerator
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
if
(
kind
=
=
GeneratorKind
:
:
Generator
)
{
setFlag
(
ImmutableFlags
:
:
IsGenerator
)
;
}
}
FunctionAsyncKind
asyncKind
(
)
const
{
return
isAsync
(
)
?
FunctionAsyncKind
:
:
AsyncFunction
:
FunctionAsyncKind
:
:
SyncFunction
;
}
void
setAsyncKind
(
FunctionAsyncKind
kind
)
{
if
(
kind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
{
setFlag
(
ImmutableFlags
:
:
IsAsync
)
;
}
}
static
constexpr
size_t
offsetOfJitCodeRaw
(
)
{
return
offsetof
(
BaseScript
jitCodeRaw_
)
;
}
static
size_t
offsetOfImmutableFlags
(
)
{
return
offsetof
(
BaseScript
immutableFlags_
)
;
}
static
constexpr
size_t
offsetOfMutableFlags
(
)
{
return
offsetof
(
BaseScript
mutableFlags_
)
;
}
}
;
struct
FieldInitializers
{
#
ifdef
DEBUG
bool
valid
;
#
endif
size_t
numFieldInitializers
;
explicit
FieldInitializers
(
size_t
numFieldInitializers
)
:
#
ifdef
DEBUG
valid
(
true
)
#
endif
numFieldInitializers
(
numFieldInitializers
)
{
}
static
FieldInitializers
Invalid
(
)
{
return
FieldInitializers
(
)
;
}
private
:
FieldInitializers
(
)
:
#
ifdef
DEBUG
valid
(
false
)
#
endif
numFieldInitializers
(
0
)
{
}
}
;
template
<
XDRMode
mode
>
XDRResult
XDRScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleFunction
fun
MutableHandleScript
scriptp
)
;
template
<
XDRMode
mode
>
XDRResult
XDRLazyScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleFunction
fun
MutableHandle
<
LazyScript
*
>
lazy
)
;
template
<
XDRMode
mode
>
XDRResult
XDRScriptConst
(
XDRState
<
mode
>
*
xdr
MutableHandleValue
vp
)
;
class
alignas
(
uintptr_t
)
PrivateScriptData
final
{
uint32_t
ngcthings
=
0
;
js
:
:
FieldInitializers
fieldInitializers_
=
js
:
:
FieldInitializers
:
:
Invalid
(
)
;
template
<
typename
T
>
T
*
offsetToPointer
(
size_t
offset
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
uintptr_t
elem
=
base
+
offset
;
return
reinterpret_cast
<
T
*
>
(
elem
)
;
}
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
static
size_t
AllocationSize
(
uint32_t
ngcthings
)
;
explicit
PrivateScriptData
(
uint32_t
ngcthings
)
;
public
:
static
constexpr
size_t
offsetOfGCThings
(
)
{
return
sizeof
(
PrivateScriptData
)
;
}
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
gcthings
(
)
{
size_t
offset
=
offsetOfGCThings
(
)
;
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
JS
:
:
GCCellPtr
>
(
offset
)
ngcthings
)
;
}
void
setFieldInitializers
(
FieldInitializers
fieldInitializers
)
{
fieldInitializers_
=
fieldInitializers
;
}
const
FieldInitializers
&
getFieldInitializers
(
)
{
return
fieldInitializers_
;
}
static
PrivateScriptData
*
new_
(
JSContext
*
cx
uint32_t
ngcthings
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleScope
scriptEnclosingScope
js
:
:
HandleFunction
fun
)
;
static
bool
Clone
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
static
bool
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
allocationSize
(
)
const
;
PrivateScriptData
(
const
PrivateScriptData
&
)
=
delete
;
PrivateScriptData
&
operator
=
(
const
PrivateScriptData
&
)
=
delete
;
}
;
class
alignas
(
uint32_t
)
ImmutableScriptData
final
{
using
Offset
=
uint32_t
;
Offset
optArrayOffset_
=
0
;
uint32_t
codeLength_
=
0
;
uint32_t
mainOffset
=
0
;
uint32_t
nfixed
=
0
;
uint32_t
nslots
=
0
;
uint32_t
bodyScopeIndex
=
0
;
uint32_t
numICEntries
=
0
;
uint16_t
funLength
=
0
;
uint16_t
numBytecodeTypeSets
=
0
;
struct
Flags
{
uint8_t
resumeOffsetsEndIndex
:
2
;
uint8_t
scopeNotesEndIndex
:
2
;
uint8_t
tryNotesEndIndex
:
2
;
uint8_t
_unused
:
2
;
}
;
static_assert
(
sizeof
(
Flags
)
=
=
sizeof
(
uint8_t
)
"
Structure
packing
is
broken
"
)
;
friend
class
:
:
JSScript
;
private
:
size_t
flagOffset
(
)
const
{
return
offsetOfCode
(
)
-
sizeof
(
Flags
)
;
}
size_t
codeOffset
(
)
const
{
return
offsetOfCode
(
)
;
}
size_t
noteOffset
(
)
const
{
return
offsetOfCode
(
)
+
codeLength_
;
}
size_t
optionalOffsetsOffset
(
)
const
{
unsigned
numOffsets
=
flags
(
)
.
tryNotesEndIndex
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
scopeNotesEndIndex
)
;
MOZ_ASSERT
(
numOffsets
>
=
flags
(
)
.
resumeOffsetsEndIndex
)
;
return
optArrayOffset_
-
(
numOffsets
*
sizeof
(
Offset
)
)
;
}
size_t
resumeOffsetsOffset
(
)
const
{
return
optArrayOffset_
;
}
size_t
scopeNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
resumeOffsetsEndIndex
)
;
}
size_t
tryNotesOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
scopeNotesEndIndex
)
;
}
size_t
endOffset
(
)
const
{
return
getOptionalOffset
(
flags
(
)
.
tryNotesEndIndex
)
;
}
static
size_t
AllocationSize
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
template
<
typename
T
>
T
*
offsetToPointer
(
size_t
offset
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
return
reinterpret_cast
<
T
*
>
(
base
+
offset
)
;
}
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
void
initOptionalArrays
(
size_t
*
cursor
Flags
*
flags
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
ImmutableScriptData
(
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
void
setOptionalOffset
(
int
index
Offset
offset
)
{
MOZ_ASSERT
(
index
>
0
)
;
MOZ_ASSERT
(
offset
!
=
optArrayOffset_
"
Do
not
store
implicit
offset
"
)
;
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
=
offset
;
}
Offset
getOptionalOffset
(
int
index
)
const
{
if
(
index
=
=
0
)
{
return
optArrayOffset_
;
}
ImmutableScriptData
*
this_
=
const_cast
<
ImmutableScriptData
*
>
(
this
)
;
return
this_
-
>
offsetToPointer
<
Offset
>
(
optArrayOffset_
)
[
-
index
]
;
}
public
:
static
ImmutableScriptData
*
new_
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
static
constexpr
size_t
CodeNoteAlign
=
sizeof
(
uint32_t
)
;
static
uint32_t
ComputeNotePadding
(
uint32_t
codeLength
uint32_t
noteLength
)
{
uint32_t
flagLength
=
sizeof
(
Flags
)
;
uint32_t
nullLength
=
CodeNoteAlign
-
(
flagLength
+
codeLength
+
noteLength
)
%
CodeNoteAlign
;
MOZ_ASSERT
(
nullLength
>
=
1
)
;
return
nullLength
;
}
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
(
)
const
{
size_t
allocSize
=
endOffset
(
)
;
return
mozilla
:
:
MakeSpan
(
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
allocSize
)
;
}
Flags
&
flagsRef
(
)
{
return
*
offsetToPointer
<
Flags
>
(
flagOffset
(
)
)
;
}
const
Flags
&
flags
(
)
const
{
return
const_cast
<
ImmutableScriptData
*
>
(
this
)
-
>
flagsRef
(
)
;
}
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
offsetToPointer
<
jsbytecode
>
(
codeOffset
(
)
)
;
}
uint32_t
noteLength
(
)
const
{
return
optionalOffsetsOffset
(
)
-
noteOffset
(
)
;
}
jssrcnote
*
notes
(
)
{
return
offsetToPointer
<
jssrcnote
>
(
noteOffset
(
)
)
;
}
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
uint32_t
>
(
resumeOffsetsOffset
(
)
)
offsetToPointer
<
uint32_t
>
(
scopeNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
ScopeNote
>
(
scopeNotesOffset
(
)
)
offsetToPointer
<
ScopeNote
>
(
tryNotesOffset
(
)
)
)
;
}
mozilla
:
:
Span
<
JSTryNote
>
tryNotes
(
)
{
return
mozilla
:
:
MakeSpan
(
offsetToPointer
<
JSTryNote
>
(
tryNotesOffset
(
)
)
offsetToPointer
<
JSTryNote
>
(
endOffset
(
)
)
)
;
}
static
constexpr
size_t
offsetOfCode
(
)
{
return
sizeof
(
ImmutableScriptData
)
+
sizeof
(
Flags
)
;
}
static
constexpr
size_t
offsetOfResumeOffsetsOffset
(
)
{
return
offsetof
(
ImmutableScriptData
optArrayOffset_
)
;
}
static
constexpr
size_t
offsetOfNfixed
(
)
{
return
offsetof
(
ImmutableScriptData
nfixed
)
;
}
static
constexpr
size_t
offsetOfNslots
(
)
{
return
offsetof
(
ImmutableScriptData
nslots
)
;
}
static
constexpr
size_t
offsetOfFunLength
(
)
{
return
offsetof
(
ImmutableScriptData
funLength
)
;
}
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
static
bool
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
uint32_t
nslots
)
;
ImmutableScriptData
(
const
ImmutableScriptData
&
)
=
delete
;
ImmutableScriptData
&
operator
=
(
const
ImmutableScriptData
&
)
=
delete
;
}
;
struct
RuntimeScriptDataHasher
;
class
RuntimeScriptData
final
{
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
refCount_
=
{
}
;
uint32_t
natoms_
=
0
;
js
:
:
UniquePtr
<
ImmutableScriptData
>
isd_
=
nullptr
;
friend
class
:
:
JSScript
;
friend
class
js
:
:
ImmutableScriptData
;
friend
struct
js
:
:
RuntimeScriptDataHasher
;
private
:
size_t
atomOffset
(
)
const
{
return
offsetOfAtoms
(
)
;
}
static
size_t
AllocationSize
(
uint32_t
natoms
)
;
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
explicit
RuntimeScriptData
(
uint32_t
natoms
)
;
public
:
static
RuntimeScriptData
*
new_
(
JSContext
*
cx
uint32_t
natoms
)
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
AddRef
(
)
{
refCount_
+
+
;
}
void
Release
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
uint32_t
remain
=
-
-
refCount_
;
if
(
remain
=
=
0
)
{
isd_
=
nullptr
;
js_free
(
this
)
;
}
}
uint32_t
natoms
(
)
const
{
return
natoms_
;
}
GCPtrAtom
*
atoms
(
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
return
reinterpret_cast
<
GCPtrAtom
*
>
(
base
+
atomOffset
(
)
)
;
}
mozilla
:
:
Span
<
const
GCPtrAtom
>
atomsSpan
(
)
const
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
const
GCPtrAtom
*
p
=
reinterpret_cast
<
const
GCPtrAtom
*
>
(
base
+
atomOffset
(
)
)
;
return
mozilla
:
:
MakeSpan
(
p
natoms_
)
;
}
static
constexpr
size_t
offsetOfAtoms
(
)
{
return
sizeof
(
RuntimeScriptData
)
;
}
static
constexpr
size_t
offsetOfISD
(
)
{
return
offsetof
(
RuntimeScriptData
isd_
)
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
void
markForCrossZone
(
JSContext
*
cx
)
;
static
bool
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
uint32_t
nslots
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
mallocSizeOf
(
isd_
.
get
(
)
)
;
}
RuntimeScriptData
(
const
RuntimeScriptData
&
)
=
delete
;
RuntimeScriptData
&
operator
=
(
const
RuntimeScriptData
&
)
=
delete
;
}
;
struct
RuntimeScriptDataHasher
{
using
Lookup
=
RefPtr
<
RuntimeScriptData
>
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
=
l
-
>
isd_
-
>
immutableData
(
)
;
HashNumber
h
=
mozilla
:
:
HashBytes
(
immutableData
.
data
(
)
immutableData
.
size
(
)
)
;
return
mozilla
:
:
AddToHash
(
h
mozilla
:
:
HashBytes
(
l
-
>
atoms
(
)
l
-
>
natoms
(
)
*
sizeof
(
GCPtrAtom
)
)
)
;
}
static
bool
match
(
RuntimeScriptData
*
entry
const
Lookup
&
lookup
)
{
return
(
entry
-
>
atomsSpan
(
)
=
=
lookup
-
>
atomsSpan
(
)
)
&
&
(
entry
-
>
isd_
-
>
immutableData
(
)
=
=
lookup
-
>
isd_
-
>
immutableData
(
)
)
;
}
}
;
class
AutoLockScriptData
;
using
RuntimeScriptDataTable
=
HashSet
<
RuntimeScriptData
*
RuntimeScriptDataHasher
SystemAllocPolicy
>
;
extern
void
SweepScriptData
(
JSRuntime
*
rt
)
;
class
ScriptWarmUpData
{
static
constexpr
uintptr_t
NumTagBits
=
2
;
static
constexpr
uint32_t
MaxWarmUpCount
=
UINT32_MAX
>
>
NumTagBits
;
public
:
static
constexpr
uintptr_t
TagMask
=
(
1
<
<
NumTagBits
)
-
1
;
static
constexpr
uintptr_t
JitScriptTag
=
0
;
static
constexpr
uintptr_t
WarmUpCountTag
=
1
;
private
:
uintptr_t
data_
=
0
|
WarmUpCountTag
;
void
setWarmUpCount
(
uint32_t
count
)
{
if
(
count
>
MaxWarmUpCount
)
{
count
=
MaxWarmUpCount
;
}
data_
=
(
uintptr_t
(
count
)
<
<
NumTagBits
)
|
WarmUpCountTag
;
}
public
:
void
trace
(
JSTracer
*
trc
)
;
bool
isWarmUpCount
(
)
const
{
return
(
data_
&
TagMask
)
=
=
WarmUpCountTag
;
}
bool
isJitScript
(
)
const
{
return
(
data_
&
TagMask
)
=
=
JitScriptTag
;
}
uint32_t
toWarmUpCount
(
)
const
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
return
data_
>
>
NumTagBits
;
}
void
resetWarmUpCount
(
uint32_t
count
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
setWarmUpCount
(
count
)
;
}
void
incWarmUpCount
(
uint32_t
amount
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
data_
+
=
uintptr_t
(
amount
)
<
<
NumTagBits
;
}
jit
:
:
JitScript
*
toJitScript
(
)
const
{
MOZ_ASSERT
(
isJitScript
(
)
)
;
static_assert
(
JitScriptTag
=
=
0
"
Code
depends
on
JitScriptTag
being
zero
"
)
;
return
reinterpret_cast
<
jit
:
:
JitScript
*
>
(
data_
)
;
}
void
setJitScript
(
jit
:
:
JitScript
*
jitScript
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
MOZ_ASSERT
(
(
uintptr_t
(
jitScript
)
&
TagMask
)
=
=
0
)
;
data_
=
uintptr_t
(
jitScript
)
|
JitScriptTag
;
}
void
clearJitScript
(
)
{
MOZ_ASSERT
(
isJitScript
(
)
)
;
setWarmUpCount
(
0
)
;
}
}
;
static_assert
(
sizeof
(
ScriptWarmUpData
)
=
=
sizeof
(
uintptr_t
)
"
JIT
code
depends
on
ScriptWarmUpData
being
pointer
-
sized
"
)
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
PrivateScriptData
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
PrivateScriptData
>
{
}
;
}
class
JSScript
:
public
js
:
:
BaseScript
{
private
:
RefPtr
<
js
:
:
RuntimeScriptData
>
scriptData_
=
{
}
;
js
:
:
PrivateScriptData
*
data_
=
nullptr
;
private
:
js
:
:
ScriptWarmUpData
warmUpData_
=
{
}
;
js
:
:
LazyScript
*
lazyScript
=
nullptr
;
private
:
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
XDRScript
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScope
enclosingScope
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleFunction
fun
js
:
:
MutableHandleScript
scriptp
)
;
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
RuntimeScriptData
:
:
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
ImmutableScriptData
:
:
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
friend
bool
js
:
:
RuntimeScriptData
:
:
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
uint32_t
nslot
)
;
friend
bool
js
:
:
ImmutableScriptData
:
:
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
uint32_t
nslot
)
;
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
PrivateScriptData
:
:
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleScope
scriptEnclosingScope
js
:
:
HandleFunction
fun
)
;
friend
bool
js
:
:
PrivateScriptData
:
:
Clone
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
friend
bool
js
:
:
PrivateScriptData
:
:
InitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
)
;
friend
JSScript
*
js
:
:
detail
:
:
CopyScript
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleObject
functionOrGlobal
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
private
:
JSScript
(
js
:
:
HandleObject
functionOrGlobal
uint8_t
*
stubEntry
js
:
:
HandleScriptSourceObject
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringend
)
;
static
JSScript
*
New
(
JSContext
*
cx
js
:
:
HandleObject
functionOrGlobal
js
:
:
HandleScriptSourceObject
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
)
;
public
:
static
JSScript
*
Create
(
JSContext
*
cx
js
:
:
HandleObject
functionOrGlobal
const
JS
:
:
ReadOnlyCompileOptions
&
options
js
:
:
HandleScriptSourceObject
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
)
;
static
JSScript
*
CreateFromLazy
(
JSContext
*
cx
js
:
:
Handle
<
js
:
:
LazyScript
*
>
lazy
)
;
static
bool
createPrivateScriptData
(
JSContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
uint32_t
ngcthings
)
;
private
:
void
initFromFunctionBox
(
js
:
:
frontend
:
:
FunctionBox
*
funbox
)
;
public
:
static
bool
fullyInitFromEmitter
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
)
;
#
ifdef
DEBUG
private
:
void
assertValidJumpTargets
(
)
const
;
public
:
#
endif
public
:
inline
JSPrincipals
*
principals
(
)
;
js
:
:
RuntimeScriptData
*
scriptData
(
)
{
return
scriptData_
;
}
js
:
:
ImmutableScriptData
*
immutableScriptData
(
)
const
{
return
scriptData_
-
>
isd_
.
get
(
)
;
}
jsbytecode
*
code
(
)
const
{
if
(
!
scriptData_
)
{
return
nullptr
;
}
return
immutableScriptData
(
)
-
>
code
(
)
;
}
bool
hasForceInterpreterOp
(
)
const
{
MOZ_ASSERT
(
length
(
)
>
=
1
)
;
return
JSOp
(
*
code
(
)
)
=
=
JSOP_FORCEINTERPRETER
;
}
js
:
:
AllBytecodesIterable
allLocations
(
)
{
return
js
:
:
AllBytecodesIterable
(
this
)
;
}
js
:
:
BytecodeLocation
location
(
)
{
return
js
:
:
BytecodeLocation
(
this
code
(
)
)
;
}
bool
isUncompleted
(
)
const
{
return
!
code
(
)
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
immutableScriptData
(
)
-
>
codeLength
(
)
;
}
jsbytecode
*
codeEnd
(
)
const
{
return
code
(
)
+
length
(
)
;
}
jsbytecode
*
lastPC
(
)
const
{
jsbytecode
*
pc
=
codeEnd
(
)
-
js
:
:
JSOP_RETRVAL_LENGTH
;
MOZ_ASSERT
(
*
pc
=
=
JSOP_RETRVAL
)
;
return
pc
;
}
bool
containsPC
(
const
jsbytecode
*
pc
)
const
{
return
pc
>
=
code
(
)
&
&
pc
<
codeEnd
(
)
;
}
bool
contains
(
const
js
:
:
BytecodeLocation
&
loc
)
const
{
return
containsPC
(
loc
.
toRawBytecode
(
)
)
;
}
size_t
pcToOffset
(
const
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
return
size_t
(
pc
-
code
(
)
)
;
}
jsbytecode
*
offsetToPC
(
size_t
offset
)
const
{
MOZ_ASSERT
(
offset
<
length
(
)
)
;
return
code
(
)
+
offset
;
}
size_t
mainOffset
(
)
const
{
return
immutableScriptData
(
)
-
>
mainOffset
;
}
size_t
nfixed
(
)
const
{
return
immutableScriptData
(
)
-
>
nfixed
;
}
size_t
numAlwaysLiveFixedSlots
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
}
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
}
return
0
;
}
size_t
calculateLiveFixed
(
jsbytecode
*
pc
)
;
size_t
nslots
(
)
const
{
return
immutableScriptData
(
)
-
>
nslots
;
}
unsigned
numArgs
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
numPositionalFormalParameters
(
)
;
}
return
0
;
}
inline
js
:
:
Shape
*
initialEnvironmentShape
(
)
const
;
bool
functionHasParameterExprs
(
)
const
{
js
:
:
Scope
*
scope
=
bodyScope
(
)
;
if
(
!
scope
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
false
;
}
return
scope
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
hasParameterExprs
(
)
;
}
static
constexpr
size_t
MaxBytecodeTypeSets
=
UINT16_MAX
;
static_assert
(
sizeof
(
js
:
:
ImmutableScriptData
:
:
numBytecodeTypeSets
)
=
=
2
"
MaxBytecodeTypeSets
must
match
sizeof
(
numBytecodeTypeSets
)
"
)
;
size_t
numBytecodeTypeSets
(
)
const
{
return
immutableScriptData
(
)
-
>
numBytecodeTypeSets
;
}
size_t
numICEntries
(
)
const
{
return
immutableScriptData
(
)
-
>
numICEntries
;
}
size_t
funLength
(
)
const
{
return
immutableScriptData
(
)
-
>
funLength
;
}
void
cacheForEval
(
)
{
MOZ_ASSERT
(
isForEval
(
)
)
;
clearFlag
(
MutableFlags
:
:
HasRunOnce
)
;
}
void
setArgumentsHasVarBinding
(
)
;
bool
argumentsAliasesFormals
(
)
const
{
return
argumentsHasVarBinding
(
)
&
&
hasMappedArgsObj
(
)
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
return
isGenerator
(
)
?
js
:
:
GeneratorKind
:
:
Generator
:
js
:
:
GeneratorKind
:
:
NotGenerator
;
}
js
:
:
FunctionAsyncKind
asyncKind
(
)
const
{
return
isAsync
(
)
?
js
:
:
FunctionAsyncKind
:
:
AsyncFunction
:
js
:
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
analyzedArgsUsage
(
)
const
{
return
!
hasFlag
(
MutableFlags
:
:
NeedsArgsAnalysis
)
;
}
inline
bool
ensureHasAnalyzedArgsUsage
(
JSContext
*
cx
)
;
bool
needsArgsObj
(
)
const
{
MOZ_ASSERT
(
analyzedArgsUsage
(
)
)
;
return
hasFlag
(
MutableFlags
:
:
NeedsArgsObj
)
;
}
void
setNeedsArgsObj
(
bool
needsArgsObj
)
;
static
void
argumentsOptimizationFailed
(
JSContext
*
cx
js
:
:
HandleScript
script
)
;
void
setFieldInitializers
(
js
:
:
FieldInitializers
fieldInitializers
)
{
MOZ_ASSERT
(
data_
)
;
data_
-
>
setFieldInitializers
(
fieldInitializers
)
;
}
const
js
:
:
FieldInitializers
&
getFieldInitializers
(
)
const
{
MOZ_ASSERT
(
data_
)
;
return
data_
-
>
getFieldInitializers
(
)
;
}
bool
argsObjAliasesFormals
(
)
const
{
return
needsArgsObj
(
)
&
&
hasMappedArgsObj
(
)
;
}
static
constexpr
size_t
offsetOfScriptData
(
)
{
return
offsetof
(
JSScript
scriptData_
)
;
}
static
constexpr
size_t
offsetOfPrivateScriptData
(
)
{
return
offsetof
(
JSScript
data_
)
;
}
static
constexpr
size_t
offsetOfWarmUpData
(
)
{
return
offsetof
(
JSScript
warmUpData_
)
;
}
void
updateJitCodeRaw
(
JSRuntime
*
rt
)
;
bool
isRelazifiableIgnoringJitCode
(
)
const
{
return
(
selfHosted
(
)
|
|
lazyScript
)
&
&
!
hasInnerFunctions
(
)
&
&
!
isGenerator
(
)
&
&
!
isAsync
(
)
&
&
!
isDefaultClassConstructor
(
)
&
&
!
doNotRelazify
(
)
&
&
!
hasCallSiteObj
(
)
;
}
bool
isRelazifiable
(
)
const
{
return
isRelazifiableIgnoringJitCode
(
)
&
&
!
hasJitScript
(
)
;
}
void
setLazyScript
(
js
:
:
LazyScript
*
lazy
)
{
lazyScript
=
lazy
;
}
js
:
:
LazyScript
*
maybeLazyScript
(
)
{
return
lazyScript
;
}
JSFunction
*
function
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
}
return
nullptr
;
}
bool
isModule
(
)
const
{
MOZ_ASSERT
(
hasFlag
(
ImmutableFlags
:
:
IsModule
)
=
=
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
;
return
hasFlag
(
ImmutableFlags
:
:
IsModule
)
;
}
js
:
:
ModuleObject
*
module
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
module
(
)
;
}
return
nullptr
;
}
bool
isGlobalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
;
}
bool
mayReadFrameArgsDirectly
(
)
;
static
JSLinearString
*
sourceData
(
JSContext
*
cx
JS
:
:
HandleScript
script
)
;
MOZ_MUST_USE
bool
appendSourceDataForToString
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
)
;
void
setDefaultClassConstructorSpan
(
js
:
:
ScriptSourceObject
*
sourceObject
uint32_t
start
uint32_t
end
unsigned
line
unsigned
column
)
;
#
ifdef
MOZ_VTUNE
uint32_t
vtuneMethodID
(
)
;
#
endif
public
:
bool
isForEval
(
)
const
{
MOZ_ASSERT
(
hasFlag
(
ImmutableFlags
:
:
IsForEval
)
=
=
bodyScope
(
)
-
>
is
<
js
:
:
EvalScope
>
(
)
)
;
return
hasFlag
(
ImmutableFlags
:
:
IsForEval
)
;
}
bool
isDirectEvalInFunction
(
)
const
{
if
(
!
isForEval
(
)
)
{
return
false
;
}
return
bodyScope
(
)
-
>
hasOnChain
(
js
:
:
ScopeKind
:
:
Function
)
;
}
bool
isTopLevel
(
)
{
return
code
(
)
&
&
!
isFunction
(
)
;
}
inline
bool
ensureHasJitScript
(
JSContext
*
cx
js
:
:
jit
:
:
AutoKeepJitScripts
&
)
;
bool
hasJitScript
(
)
const
{
return
warmUpData_
.
isJitScript
(
)
;
}
js
:
:
jit
:
:
JitScript
*
jitScript
(
)
const
{
MOZ_ASSERT
(
hasJitScript
(
)
)
;
return
warmUpData_
.
toJitScript
(
)
;
}
js
:
:
jit
:
:
JitScript
*
maybeJitScript
(
)
const
{
return
hasJitScript
(
)
?
jitScript
(
)
:
nullptr
;
}
void
maybeReleaseJitScript
(
JSFreeOp
*
fop
)
;
void
releaseJitScript
(
JSFreeOp
*
fop
)
;
void
releaseJitScriptOnFinalize
(
JSFreeOp
*
fop
)
;
inline
bool
hasBaselineScript
(
)
const
;
inline
bool
hasIonScript
(
)
const
;
inline
js
:
:
jit
:
:
BaselineScript
*
baselineScript
(
)
const
;
inline
js
:
:
jit
:
:
IonScript
*
ionScript
(
)
const
;
inline
bool
isIonCompilingOffThread
(
)
const
;
inline
bool
canIonCompile
(
)
const
;
inline
void
disableIon
(
)
;
inline
bool
canBaselineCompile
(
)
const
;
inline
void
disableBaselineCompile
(
)
;
inline
js
:
:
GlobalObject
&
global
(
)
const
;
inline
bool
hasGlobal
(
const
js
:
:
GlobalObject
*
global
)
const
;
js
:
:
GlobalObject
&
uninlinedGlobal
(
)
const
;
uint32_t
bodyScopeIndex
(
)
const
{
return
immutableScriptData
(
)
-
>
bodyScopeIndex
;
}
js
:
:
Scope
*
bodyScope
(
)
const
{
return
getScope
(
bodyScopeIndex
(
)
)
;
}
js
:
:
Scope
*
outermostScope
(
)
const
{
size_t
index
=
0
;
return
getScope
(
index
)
;
}
bool
functionHasExtraBodyVarScope
(
)
const
{
bool
res
=
hasFlag
(
ImmutableFlags
:
:
FunctionHasExtraBodyVarScope
)
;
MOZ_ASSERT_IF
(
res
functionHasParameterExprs
(
)
)
;
return
res
;
}
js
:
:
VarScope
*
functionExtraBodyVarScope
(
)
const
{
MOZ_ASSERT
(
functionHasExtraBodyVarScope
(
)
)
;
for
(
JS
:
:
GCCellPtr
gcThing
:
gcthings
(
)
)
{
if
(
!
gcThing
.
is
<
js
:
:
Scope
>
(
)
)
{
continue
;
}
js
:
:
Scope
*
scope
=
&
gcThing
.
as
<
js
:
:
Scope
>
(
)
;
if
(
scope
-
>
kind
(
)
=
=
js
:
:
ScopeKind
:
:
FunctionBodyVar
)
{
return
&
scope
-
>
as
<
js
:
:
VarScope
>
(
)
;
}
}
MOZ_CRASH
(
"
Function
extra
body
var
scope
not
found
"
)
;
}
bool
needsBodyEnvironment
(
)
const
{
for
(
JS
:
:
GCCellPtr
gcThing
:
gcthings
(
)
)
{
if
(
!
gcThing
.
is
<
js
:
:
Scope
>
(
)
)
{
continue
;
}
js
:
:
Scope
*
scope
=
&
gcThing
.
as
<
js
:
:
Scope
>
(
)
;
if
(
ScopeKindIsInBody
(
scope
-
>
kind
(
)
)
&
&
scope
-
>
hasEnvironment
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
js
:
:
LexicalScope
*
maybeNamedLambdaScope
(
)
const
;
js
:
:
Scope
*
enclosingScope
(
)
const
{
return
outermostScope
(
)
-
>
enclosing
(
)
;
}
private
:
bool
createJitScript
(
JSContext
*
cx
)
;
bool
createScriptData
(
JSContext
*
cx
uint32_t
natoms
)
;
bool
createImmutableScriptData
(
JSContext
*
cx
uint32_t
codeLength
uint32_t
noteLength
uint32_t
numResumeOffsets
uint32_t
numScopeNotes
uint32_t
numTryNotes
)
;
bool
shareScriptData
(
JSContext
*
cx
)
;
void
freeScriptData
(
)
;
public
:
inline
uint32_t
getWarmUpCount
(
)
const
;
inline
void
incWarmUpCounter
(
uint32_t
amount
=
1
)
;
inline
void
resetWarmUpCounterForGC
(
)
;
void
resetWarmUpCounterToDelayIonCompilation
(
)
;
unsigned
getWarmUpResetCount
(
)
const
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
return
mutableFlags_
&
MASK
;
}
void
incWarmUpResetCounter
(
)
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
uint32_t
newCount
=
getWarmUpResetCount
(
)
+
1
;
if
(
newCount
<
=
MASK
)
{
mutableFlags_
&
=
~
MASK
;
mutableFlags_
|
=
newCount
;
}
}
void
resetWarmUpResetCounter
(
)
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
mutableFlags_
&
=
~
MASK
;
}
public
:
bool
initScriptCounts
(
JSContext
*
cx
)
;
js
:
:
ScriptCounts
&
getScriptCounts
(
)
;
js
:
:
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
;
const
js
:
:
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
;
js
:
:
PCCounts
*
getThrowCounts
(
jsbytecode
*
pc
)
;
uint64_t
getHitCount
(
jsbytecode
*
pc
)
;
void
incHitCount
(
jsbytecode
*
pc
)
;
void
addIonCounts
(
js
:
:
jit
:
:
IonScriptCounts
*
ionCounts
)
;
js
:
:
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
;
void
releaseScriptCounts
(
js
:
:
ScriptCounts
*
counts
)
;
void
destroyScriptCounts
(
)
;
void
clearHasScriptCounts
(
)
;
void
resetScriptCounts
(
)
;
jsbytecode
*
main
(
)
const
{
return
code
(
)
+
mainOffset
(
)
;
}
js
:
:
BytecodeLocation
mainLocation
(
)
const
{
return
js
:
:
BytecodeLocation
(
this
main
(
)
)
;
}
js
:
:
BytecodeLocation
endLocation
(
)
const
{
return
js
:
:
BytecodeLocation
(
this
codeEnd
(
)
)
;
}
js
:
:
BytecodeLocation
offsetToLocation
(
uint32_t
offset
)
const
{
return
js
:
:
BytecodeLocation
(
this
offsetToPC
(
offset
)
)
;
}
size_t
computedSizeOfData
(
)
const
;
size_t
sizeOfData
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
addSizeOfJitScript
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
sizeOfJitScript
size_t
*
sizeOfBaselineFallbackStubs
)
const
;
mozilla
:
:
Span
<
const
JS
:
:
GCCellPtr
>
gcthings
(
)
const
{
return
data_
-
>
gcthings
(
)
;
}
mozilla
:
:
Span
<
const
JSTryNote
>
trynotes
(
)
const
{
return
immutableScriptData
(
)
-
>
tryNotes
(
)
;
}
mozilla
:
:
Span
<
const
js
:
:
ScopeNote
>
scopeNotes
(
)
const
{
return
immutableScriptData
(
)
-
>
scopeNotes
(
)
;
}
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
(
)
const
{
return
immutableScriptData
(
)
-
>
resumeOffsets
(
)
;
}
uint32_t
tableSwitchCaseOffset
(
jsbytecode
*
pc
uint32_t
caseIndex
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
MOZ_ASSERT
(
*
pc
=
=
JSOP_TABLESWITCH
)
;
uint32_t
firstResumeIndex
=
GET_RESUMEINDEX
(
pc
+
3
*
JUMP_OFFSET_LEN
)
;
return
resumeOffsets
(
)
[
firstResumeIndex
+
caseIndex
]
;
}
jsbytecode
*
tableSwitchCasePC
(
jsbytecode
*
pc
uint32_t
caseIndex
)
const
{
return
offsetToPC
(
tableSwitchCaseOffset
(
pc
caseIndex
)
)
;
}
bool
hasLoops
(
)
;
uint32_t
numNotes
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
immutableScriptData
(
)
-
>
noteLength
(
)
;
}
jssrcnote
*
notes
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
immutableScriptData
(
)
-
>
notes
(
)
;
}
size_t
natoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
natoms
(
)
;
}
js
:
:
GCPtrAtom
*
atoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
atoms
(
)
;
}
js
:
:
GCPtrAtom
&
getAtom
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
natoms
(
)
)
;
return
atoms
(
)
[
index
]
;
}
js
:
:
GCPtrAtom
&
getAtom
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
(
JSOp
)
*
pc
)
=
=
JOF_ATOM
)
;
return
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
PropertyName
*
getName
(
size_t
index
)
{
return
getAtom
(
index
)
-
>
asPropertyName
(
)
;
}
js
:
:
PropertyName
*
getName
(
jsbytecode
*
pc
)
const
{
return
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
}
JSObject
*
getObject
(
size_t
index
)
{
MOZ_ASSERT
(
gcthings
(
)
[
index
]
.
asCell
(
)
-
>
isTenured
(
)
)
;
return
&
gcthings
(
)
[
index
]
.
as
<
JSObject
>
(
)
;
}
JSObject
*
getObject
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
return
getObject
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
getScope
(
size_t
index
)
const
{
return
&
gcthings
(
)
[
index
]
.
as
<
js
:
:
Scope
>
(
)
;
}
js
:
:
Scope
*
getScope
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_SCOPE
"
Did
you
mean
to
use
lookupScope
(
pc
)
?
"
)
;
return
getScope
(
GET_UINT32_INDEX
(
pc
)
)
;
}
inline
JSFunction
*
getFunction
(
size_t
index
)
;
inline
JSFunction
*
getFunction
(
jsbytecode
*
pc
)
;
inline
js
:
:
RegExpObject
*
getRegExp
(
size_t
index
)
;
inline
js
:
:
RegExpObject
*
getRegExp
(
jsbytecode
*
pc
)
;
js
:
:
BigInt
*
getBigInt
(
size_t
index
)
{
return
&
gcthings
(
)
[
index
]
.
as
<
js
:
:
BigInt
>
(
)
;
}
js
:
:
BigInt
*
getBigInt
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_BIGINT
)
;
return
getBigInt
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
lookupScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
)
{
return
innermostScope
(
main
(
)
)
;
}
bool
isEmpty
(
)
const
{
if
(
length
(
)
>
3
)
{
return
false
;
}
jsbytecode
*
pc
=
code
(
)
;
if
(
noScriptRval
(
)
&
&
JSOp
(
*
pc
)
=
=
JSOP_FALSE
)
{
+
+
pc
;
}
return
JSOp
(
*
pc
)
=
=
JSOP_RETRVAL
;
}
bool
formalIsAliased
(
unsigned
argSlot
)
;
bool
formalLivesInArgumentsObject
(
unsigned
argSlot
)
;
inline
bool
isDebuggee
(
)
const
;
void
finalize
(
JSFreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Script
;
void
traceChildren
(
JSTracer
*
trc
)
;
class
AutoDelazify
;
friend
class
AutoDelazify
;
class
AutoDelazify
{
JS
:
:
RootedScript
script_
;
JSContext
*
cx_
;
bool
oldDoNotRelazify_
;
public
:
explicit
AutoDelazify
(
JSContext
*
cx
JS
:
:
HandleFunction
fun
=
nullptr
)
:
script_
(
cx
)
cx_
(
cx
)
oldDoNotRelazify_
(
false
)
{
holdScript
(
fun
)
;
}
~
AutoDelazify
(
)
{
dropScript
(
)
;
}
void
operator
=
(
JS
:
:
HandleFunction
fun
)
{
dropScript
(
)
;
holdScript
(
fun
)
;
}
operator
JS
:
:
HandleScript
(
)
const
{
return
script_
;
}
explicit
operator
bool
(
)
const
{
return
script_
;
}
private
:
void
holdScript
(
JS
:
:
HandleFunction
fun
)
;
void
dropScript
(
)
;
}
;
}
;
static_assert
(
sizeof
(
JSScript
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
Size
of
JSScript
must
be
an
integral
multiple
of
js
:
:
gc
:
:
CellAlignBytes
"
)
;
namespace
js
{
class
alignas
(
uintptr_t
)
LazyScriptData
final
{
private
:
uint32_t
numClosedOverBindings_
=
0
;
uint32_t
numInnerFunctions_
=
0
;
FieldInitializers
fieldInitializers_
=
FieldInitializers
:
:
Invalid
(
)
;
static
size_t
AllocationSize
(
uint32_t
numClosedOverBindings
uint32_t
numInnerFunctions
)
;
size_t
allocationSize
(
)
const
;
template
<
typename
T
>
T
*
offsetToPointer
(
size_t
offset
)
{
uintptr_t
base
=
reinterpret_cast
<
uintptr_t
>
(
this
)
;
return
reinterpret_cast
<
T
*
>
(
base
+
offset
)
;
}
template
<
typename
T
>
void
initElements
(
size_t
offset
size_t
length
)
;
LazyScriptData
(
uint32_t
numClosedOverBindings
uint32_t
numInnerFunctions
)
;
public
:
static
LazyScriptData
*
new_
(
JSContext
*
cx
uint32_t
numClosedOverBindings
uint32_t
numInnerFunctions
)
;
friend
class
LazyScript
;
mozilla
:
:
Span
<
GCPtrAtom
>
closedOverBindings
(
)
;
mozilla
:
:
Span
<
GCPtrFunction
>
innerFunctions
(
)
;
void
trace
(
JSTracer
*
trc
)
;
LazyScriptData
(
const
LazyScriptData
&
)
=
delete
;
LazyScriptData
&
operator
=
(
const
LazyScriptData
&
)
=
delete
;
}
;
class
LazyScript
:
public
BaseScript
{
WeakHeapPtrScript
script_
;
friend
void
js
:
:
gc
:
:
SweepLazyScripts
(
GCParallelTask
*
task
)
;
GCPtr
<
TenuredCell
*
>
enclosingLazyScriptOrScope_
;
LazyScriptData
*
lazyData_
;
static
const
uint32_t
NumClosedOverBindingsBits
=
20
;
static
const
uint32_t
NumInnerFunctionsBits
=
20
;
LazyScript
(
JSFunction
*
fun
uint8_t
*
stubEntry
ScriptSourceObject
&
sourceObject
LazyScriptData
*
data
uint32_t
immutableFlags
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
)
;
static
LazyScript
*
CreateRaw
(
JSContext
*
cx
uint32_t
numClosedOverBindings
uint32_t
numInnerFunctions
HandleFunction
fun
HandleScriptSourceObject
sourceObject
uint32_t
immutableFlags
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
)
;
public
:
static
const
uint32_t
NumClosedOverBindingsLimit
=
1
<
<
NumClosedOverBindingsBits
;
static
const
uint32_t
NumInnerFunctionsLimit
=
1
<
<
NumInnerFunctionsBits
;
static
LazyScript
*
Create
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
const
frontend
:
:
AtomVector
&
closedOverBindings
const
frontend
:
:
FunctionBoxVector
&
innerFunctionBoxes
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
frontend
:
:
ParseGoal
parseGoal
)
;
static
LazyScript
*
CreateForXDR
(
JSContext
*
cx
uint32_t
numClosedOverBindings
uint32_t
numInnerFunctions
HandleFunction
fun
HandleScript
script
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
uint32_t
immutableFlags
uint32_t
sourceStart
uint32_t
sourceEnd
uint32_t
toStringStart
uint32_t
toStringEnd
uint32_t
lineno
uint32_t
column
)
;
JSFunction
*
function
(
)
const
{
return
&
functionOrGlobal_
-
>
as
<
JSFunction
>
(
)
;
}
bool
canRelazify
(
)
const
{
return
!
hasInnerFunctions
(
)
&
&
!
hasDirectEval
(
)
;
}
void
initScript
(
JSScript
*
script
)
;
JSScript
*
maybeScript
(
)
{
return
script_
;
}
const
JSScript
*
maybeScriptUnbarriered
(
)
const
{
return
script_
.
unbarrieredGet
(
)
;
}
bool
hasScript
(
)
const
{
return
bool
(
script_
)
;
}
bool
hasEnclosingScope
(
)
const
{
return
enclosingLazyScriptOrScope_
&
&
enclosingLazyScriptOrScope_
-
>
is
<
Scope
>
(
)
;
}
bool
hasEnclosingLazyScript
(
)
const
{
return
enclosingLazyScriptOrScope_
&
&
enclosingLazyScriptOrScope_
-
>
is
<
LazyScript
>
(
)
;
}
LazyScript
*
enclosingLazyScript
(
)
const
{
MOZ_ASSERT
(
hasEnclosingLazyScript
(
)
)
;
return
enclosingLazyScriptOrScope_
-
>
as
<
LazyScript
>
(
)
;
}
void
setEnclosingLazyScript
(
LazyScript
*
enclosingLazyScript
)
;
Scope
*
enclosingScope
(
)
const
{
MOZ_ASSERT
(
hasEnclosingScope
(
)
)
;
return
enclosingLazyScriptOrScope_
-
>
as
<
Scope
>
(
)
;
}
void
setEnclosingScope
(
Scope
*
enclosingScope
)
;
bool
hasNonSyntacticScope
(
)
const
{
return
enclosingScope
(
)
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
;
}
mozilla
:
:
Span
<
GCPtrAtom
>
closedOverBindings
(
)
{
return
lazyData_
?
lazyData_
-
>
closedOverBindings
(
)
:
mozilla
:
:
Span
<
GCPtrAtom
>
(
)
;
}
uint32_t
numClosedOverBindings
(
)
const
{
return
lazyData_
?
lazyData_
-
>
closedOverBindings
(
)
.
size
(
)
:
0
;
}
;
mozilla
:
:
Span
<
GCPtrFunction
>
innerFunctions
(
)
{
return
lazyData_
?
lazyData_
-
>
innerFunctions
(
)
:
mozilla
:
:
Span
<
GCPtrFunction
>
(
)
;
}
uint32_t
numInnerFunctions
(
)
const
{
return
lazyData_
?
lazyData_
-
>
innerFunctions
(
)
.
size
(
)
:
0
;
}
frontend
:
:
ParseGoal
parseGoal
(
)
const
{
if
(
hasFlag
(
ImmutableFlags
:
:
IsModule
)
)
{
return
frontend
:
:
ParseGoal
:
:
Module
;
}
return
frontend
:
:
ParseGoal
:
:
Script
;
}
bool
isBinAST
(
)
const
{
return
scriptSource
(
)
-
>
hasBinASTSource
(
)
;
}
bool
isWrappedByDebugger
(
)
const
{
return
hasFlag
(
MutableFlags
:
:
WrappedByDebugger
)
;
}
void
setWrappedByDebugger
(
)
{
setFlag
(
MutableFlags
:
:
WrappedByDebugger
)
;
}
void
setFieldInitializers
(
FieldInitializers
fieldInitializers
)
{
MOZ_ASSERT
(
lazyData_
)
;
lazyData_
-
>
fieldInitializers_
=
fieldInitializers
;
}
const
FieldInitializers
&
getFieldInitializers
(
)
const
{
MOZ_ASSERT
(
lazyData_
)
;
return
lazyData_
-
>
fieldInitializers_
;
}
bool
enclosingScriptHasEverBeenCompiled
(
)
const
{
return
hasEnclosingScope
(
)
;
}
friend
class
GCMarker
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
LazyScript
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
lazyData_
)
;
}
}
;
static_assert
(
sizeof
(
LazyScript
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
Size
of
LazyScript
must
be
an
integral
multiple
of
"
"
js
:
:
gc
:
:
CellAlignBytes
"
)
;
struct
ScriptAndCounts
{
JSScript
*
script
;
ScriptCounts
scriptCounts
;
inline
explicit
ScriptAndCounts
(
JSScript
*
script
)
;
inline
ScriptAndCounts
(
ScriptAndCounts
&
&
sac
)
;
const
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetPCCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
const
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetThrowCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
const
{
return
scriptCounts
.
ionCounts_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
script
"
ScriptAndCounts
:
:
script
"
)
;
}
}
;
extern
JS
:
:
UniqueChars
FormatIntroducedFilename
(
JSContext
*
cx
const
char
*
filename
unsigned
lineno
const
char
*
introducer
)
;
struct
GSNCache
;
jssrcnote
*
GetSrcNote
(
GSNCache
&
cache
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jssrcnote
*
GetSrcNote
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jsbytecode
*
LineNumberToPC
(
JSScript
*
script
unsigned
lineno
)
;
extern
JS_FRIEND_API
unsigned
GetScriptLineExtent
(
JSScript
*
script
)
;
}
namespace
js
{
extern
unsigned
PCToLineNumber
(
JSScript
*
script
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
unsigned
PCToLineNumber
(
unsigned
startLine
jssrcnote
*
notes
jsbytecode
*
code
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
void
DescribeScriptedCallerForCompilation
(
JSContext
*
cx
MutableHandleScript
maybeScript
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
extern
void
DescribeScriptedCallerForDirectEval
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
JSScript
*
CloneScriptIntoFunction
(
JSContext
*
cx
HandleScope
enclosingScope
HandleFunction
fun
HandleScript
src
Handle
<
ScriptSourceObject
*
>
sourceObject
)
;
JSScript
*
CloneGlobalScript
(
JSContext
*
cx
ScopeKind
scopeKind
HandleScript
src
)
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
LazyScript
>
:
TracerConcrete
<
js
:
:
LazyScript
>
{
protected
:
explicit
Concrete
(
js
:
:
LazyScript
*
ptr
)
:
TracerConcrete
<
js
:
:
LazyScript
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
LazyScript
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char
*
scriptFilename
(
)
const
final
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
