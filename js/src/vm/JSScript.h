#
ifndef
vm_JSScript_h
#
define
vm_JSScript_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
StructuredSpewer
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
Time
.
h
"
namespace
JS
{
struct
ScriptSourceInfo
;
template
<
typename
UnitT
>
class
SourceText
;
}
namespace
js
{
namespace
coverage
{
class
LCovSource
;
}
namespace
jit
{
class
AutoKeepJitScripts
;
class
BaselineScript
;
struct
IonScriptCounts
;
class
JitScript
;
}
class
ModuleObject
;
class
RegExpObject
;
class
ScriptSourceHolder
;
class
SourceCompressionTask
;
class
Shape
;
class
DebugScript
;
namespace
frontend
{
struct
CompilationInfo
;
class
ScriptStencil
;
}
class
ScriptCounts
{
public
:
typedef
mozilla
:
:
Vector
<
PCCounts
0
SystemAllocPolicy
>
PCCountsVector
;
inline
ScriptCounts
(
)
;
inline
explicit
ScriptCounts
(
PCCountsVector
&
&
jumpTargets
)
;
inline
ScriptCounts
(
ScriptCounts
&
&
src
)
;
inline
~
ScriptCounts
(
)
;
inline
ScriptCounts
&
operator
=
(
ScriptCounts
&
&
src
)
;
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
const
;
PCCounts
*
getImmediatePrecedingPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetThrowCounts
(
size_t
offset
)
const
;
const
PCCounts
*
getImmediatePrecedingThrowCounts
(
size_t
offset
)
const
;
PCCounts
*
getThrowCounts
(
size_t
offset
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
friend
class
:
:
JSScript
;
friend
struct
ScriptAndCounts
;
PCCountsVector
pcCounts_
;
PCCountsVector
throwCounts_
;
jit
:
:
IonScriptCounts
*
ionCounts_
;
}
;
using
UniqueScriptCounts
=
js
:
:
UniquePtr
<
ScriptCounts
>
;
using
ScriptCountsMap
=
HashMap
<
BaseScript
*
UniqueScriptCounts
DefaultHasher
<
BaseScript
*
>
SystemAllocPolicy
>
;
using
ScriptLCovEntry
=
mozilla
:
:
Tuple
<
coverage
:
:
LCovSource
*
const
char
*
>
;
using
ScriptLCovMap
=
HashMap
<
BaseScript
*
ScriptLCovEntry
DefaultHasher
<
BaseScript
*
>
SystemAllocPolicy
>
;
#
ifdef
MOZ_VTUNE
using
ScriptVTuneIdMap
=
HashMap
<
BaseScript
*
uint32_t
DefaultHasher
<
BaseScript
*
>
SystemAllocPolicy
>
;
#
endif
using
UniqueDebugScript
=
js
:
:
UniquePtr
<
DebugScript
JS
:
:
FreePolicy
>
;
using
DebugScriptMap
=
HashMap
<
BaseScript
*
UniqueDebugScript
DefaultHasher
<
BaseScript
*
>
SystemAllocPolicy
>
;
class
ScriptSource
;
struct
ScriptSourceChunk
{
ScriptSource
*
ss
=
nullptr
;
uint32_t
chunk
=
0
;
ScriptSourceChunk
(
)
=
default
;
ScriptSourceChunk
(
ScriptSource
*
ss
uint32_t
chunk
)
:
ss
(
ss
)
chunk
(
chunk
)
{
MOZ_ASSERT
(
valid
(
)
)
;
}
bool
valid
(
)
const
{
return
ss
!
=
nullptr
;
}
bool
operator
=
=
(
const
ScriptSourceChunk
&
other
)
const
{
return
ss
=
=
other
.
ss
&
&
chunk
=
=
other
.
chunk
;
}
}
;
struct
ScriptSourceChunkHasher
{
using
Lookup
=
ScriptSourceChunk
;
static
HashNumber
hash
(
const
ScriptSourceChunk
&
ssc
)
{
return
mozilla
:
:
AddToHash
(
DefaultHasher
<
ScriptSource
*
>
:
:
hash
(
ssc
.
ss
)
ssc
.
chunk
)
;
}
static
bool
match
(
const
ScriptSourceChunk
&
c1
const
ScriptSourceChunk
&
c2
)
{
return
c1
=
=
c2
;
}
}
;
template
<
typename
Unit
>
using
EntryUnits
=
mozilla
:
:
UniquePtr
<
Unit
[
]
JS
:
:
FreePolicy
>
;
using
SourceData
=
mozilla
:
:
UniquePtr
<
void
JS
:
:
FreePolicy
>
;
template
<
typename
Unit
>
inline
SourceData
ToSourceData
(
EntryUnits
<
Unit
>
chars
)
{
static_assert
(
std
:
:
is_same_v
<
SourceData
:
:
DeleterType
typename
EntryUnits
<
Unit
>
:
:
DeleterType
>
"
EntryUnits
and
SourceData
must
share
the
same
deleter
"
"
type
that
need
not
know
the
type
of
the
data
being
freed
"
"
for
the
upcast
below
to
be
safe
"
)
;
return
SourceData
(
chars
.
release
(
)
)
;
}
class
UncompressedSourceCache
{
using
Map
=
HashMap
<
ScriptSourceChunk
SourceData
ScriptSourceChunkHasher
SystemAllocPolicy
>
;
public
:
class
AutoHoldEntry
{
UncompressedSourceCache
*
cache_
=
nullptr
;
ScriptSourceChunk
sourceChunk_
=
{
}
;
SourceData
data_
=
nullptr
;
public
:
explicit
AutoHoldEntry
(
)
=
default
;
~
AutoHoldEntry
(
)
{
if
(
cache_
)
{
MOZ_ASSERT
(
sourceChunk_
.
valid
(
)
)
;
cache_
-
>
releaseEntry
(
*
this
)
;
}
}
template
<
typename
Unit
>
void
holdUnits
(
EntryUnits
<
Unit
>
units
)
{
MOZ_ASSERT
(
!
cache_
)
;
MOZ_ASSERT
(
!
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
data_
=
ToSourceData
(
std
:
:
move
(
units
)
)
;
}
private
:
void
holdEntry
(
UncompressedSourceCache
*
cache
const
ScriptSourceChunk
&
sourceChunk
)
{
MOZ_ASSERT
(
!
cache_
)
;
MOZ_ASSERT
(
!
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
cache_
=
cache
;
sourceChunk_
=
sourceChunk
;
}
void
deferDelete
(
SourceData
data
)
{
MOZ_ASSERT
(
cache_
)
;
MOZ_ASSERT
(
sourceChunk_
.
valid
(
)
)
;
MOZ_ASSERT
(
!
data_
)
;
cache_
=
nullptr
;
sourceChunk_
=
ScriptSourceChunk
(
)
;
data_
=
std
:
:
move
(
data
)
;
}
const
ScriptSourceChunk
&
sourceChunk
(
)
const
{
return
sourceChunk_
;
}
friend
class
UncompressedSourceCache
;
}
;
private
:
UniquePtr
<
Map
>
map_
=
nullptr
;
AutoHoldEntry
*
holder_
=
nullptr
;
public
:
UncompressedSourceCache
(
)
=
default
;
template
<
typename
Unit
>
const
Unit
*
lookup
(
const
ScriptSourceChunk
&
ssc
AutoHoldEntry
&
asp
)
;
bool
put
(
const
ScriptSourceChunk
&
ssc
SourceData
data
AutoHoldEntry
&
asp
)
;
void
purge
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
void
holdEntry
(
AutoHoldEntry
&
holder
const
ScriptSourceChunk
&
ssc
)
;
void
releaseEntry
(
AutoHoldEntry
&
holder
)
;
}
;
template
<
typename
Unit
>
struct
SourceTypeTraits
;
template
<
>
struct
SourceTypeTraits
<
mozilla
:
:
Utf8Unit
>
{
using
CharT
=
char
;
using
SharedImmutableString
=
js
:
:
SharedImmutableString
;
static
const
mozilla
:
:
Utf8Unit
*
units
(
const
SharedImmutableString
&
string
)
{
return
reinterpret_cast
<
const
mozilla
:
:
Utf8Unit
*
>
(
string
.
chars
(
)
)
;
}
static
char
*
toString
(
const
mozilla
:
:
Utf8Unit
*
units
)
{
auto
asUnsigned
=
const_cast
<
unsigned
char
*
>
(
mozilla
:
:
Utf8AsUnsignedChars
(
units
)
)
;
return
reinterpret_cast
<
char
*
>
(
asUnsigned
)
;
}
static
UniqueChars
toCacheable
(
EntryUnits
<
mozilla
:
:
Utf8Unit
>
str
)
{
char
*
chars
=
toString
(
str
.
release
(
)
)
;
return
UniqueChars
(
chars
)
;
}
}
;
template
<
>
struct
SourceTypeTraits
<
char16_t
>
{
using
CharT
=
char16_t
;
using
SharedImmutableString
=
js
:
:
SharedImmutableTwoByteString
;
static
const
char16_t
*
units
(
const
SharedImmutableString
&
string
)
{
return
string
.
chars
(
)
;
}
static
char16_t
*
toString
(
const
char16_t
*
units
)
{
return
const_cast
<
char16_t
*
>
(
units
)
;
}
static
UniqueTwoByteChars
toCacheable
(
EntryUnits
<
char16_t
>
str
)
{
return
UniqueTwoByteChars
(
std
:
:
move
(
str
)
)
;
}
}
;
extern
MOZ_MUST_USE
bool
SynchronouslyCompressSource
(
JSContext
*
cx
JS
:
:
Handle
<
BaseScript
*
>
script
)
;
enum
class
SourceRetrievable
{
Yes
No
}
;
class
ScriptSource
{
friend
class
SourceCompressionTask
;
friend
bool
SynchronouslyCompressSource
(
JSContext
*
cx
JS
:
:
Handle
<
BaseScript
*
>
script
)
;
private
:
class
PinnedUnitsBase
{
protected
:
PinnedUnitsBase
*
*
stack_
=
nullptr
;
PinnedUnitsBase
*
prev_
=
nullptr
;
ScriptSource
*
source_
;
explicit
PinnedUnitsBase
(
ScriptSource
*
source
)
:
source_
(
source
)
{
}
}
;
public
:
template
<
typename
Unit
>
class
PinnedUnits
:
public
PinnedUnitsBase
{
const
Unit
*
units_
;
public
:
PinnedUnits
(
JSContext
*
cx
ScriptSource
*
source
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
begin
size_t
len
)
;
~
PinnedUnits
(
)
;
const
Unit
*
get
(
)
const
{
return
units_
;
}
const
typename
SourceTypeTraits
<
Unit
>
:
:
CharT
*
asChars
(
)
const
{
return
SourceTypeTraits
<
Unit
>
:
:
toString
(
get
(
)
)
;
}
}
;
private
:
struct
Missing
{
}
;
template
<
typename
Unit
>
struct
Retrievable
{
}
;
template
<
typename
Unit
>
class
UncompressedData
{
typename
SourceTypeTraits
<
Unit
>
:
:
SharedImmutableString
string_
;
public
:
explicit
UncompressedData
(
typename
SourceTypeTraits
<
Unit
>
:
:
SharedImmutableString
str
)
:
string_
(
std
:
:
move
(
str
)
)
{
}
const
Unit
*
units
(
)
const
{
return
SourceTypeTraits
<
Unit
>
:
:
units
(
string_
)
;
}
size_t
length
(
)
const
{
return
string_
.
length
(
)
;
}
}
;
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
class
Uncompressed
:
public
UncompressedData
<
Unit
>
{
using
Base
=
UncompressedData
<
Unit
>
;
public
:
using
Base
:
:
Base
;
}
;
template
<
typename
Unit
>
struct
CompressedData
{
SharedImmutableString
raw
;
size_t
uncompressedLength
;
CompressedData
(
SharedImmutableString
raw
size_t
uncompressedLength
)
:
raw
(
std
:
:
move
(
raw
)
)
uncompressedLength
(
uncompressedLength
)
{
}
}
;
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
struct
Compressed
:
public
CompressedData
<
Unit
>
{
using
Base
=
CompressedData
<
Unit
>
;
public
:
using
Base
:
:
Base
;
}
;
using
SourceType
=
mozilla
:
:
Variant
<
Compressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
Yes
>
Uncompressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
Yes
>
Compressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
No
>
Uncompressed
<
mozilla
:
:
Utf8Unit
SourceRetrievable
:
:
No
>
Compressed
<
char16_t
SourceRetrievable
:
:
Yes
>
Uncompressed
<
char16_t
SourceRetrievable
:
:
Yes
>
Compressed
<
char16_t
SourceRetrievable
:
:
No
>
Uncompressed
<
char16_t
SourceRetrievable
:
:
No
>
Retrievable
<
mozilla
:
:
Utf8Unit
>
Retrievable
<
char16_t
>
Missing
>
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
refs
=
{
}
;
uint32_t
id_
=
0
;
SourceType
data
=
SourceType
(
Missing
(
)
)
;
PinnedUnitsBase
*
pinnedUnitsStack_
=
nullptr
;
mozilla
:
:
MaybeOneOf
<
CompressedData
<
mozilla
:
:
Utf8Unit
>
CompressedData
<
char16_t
>
>
pendingCompressed_
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
filename_
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
introducerFilename_
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
displayURL_
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
sourceMapURL_
;
UniquePtr
<
XDRIncrementalEncoder
>
xdrEncoder_
=
nullptr
;
const
char
*
introductionType_
=
nullptr
;
mozilla
:
:
Maybe
<
uint32_t
>
introductionOffset_
;
uint32_t
parameterListEnd_
=
0
;
uint32_t
startLine_
=
0
;
bool
mutedErrors_
=
false
;
bool
containsAsmJS_
=
false
;
static
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
>
idCount_
;
template
<
typename
Unit
>
const
Unit
*
chunkUnits
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
chunk
)
;
template
<
typename
Unit
>
const
Unit
*
units
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
asp
size_t
begin
size_t
len
)
;
public
:
static
const
size_t
SourceDeflateLimit
=
100
;
explicit
ScriptSource
(
)
:
id_
(
+
+
idCount_
)
{
}
void
finalizeGCData
(
)
;
~
ScriptSource
(
)
;
void
incref
(
)
{
refs
+
+
;
}
void
decref
(
)
{
MOZ_ASSERT
(
refs
!
=
0
)
;
if
(
-
-
refs
=
=
0
)
{
js_delete
(
this
)
;
}
}
MOZ_MUST_USE
bool
initFromOptions
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
static
constexpr
size_t
MinimumCompressibleLength
=
256
;
mozilla
:
:
Maybe
<
SharedImmutableString
>
getOrCreateStringZ
(
JSContext
*
cx
UniqueChars
&
&
str
)
;
mozilla
:
:
Maybe
<
SharedImmutableTwoByteString
>
getOrCreateStringZ
(
JSContext
*
cx
UniqueTwoByteChars
&
&
str
)
;
private
:
class
LoadSourceMatcher
;
public
:
static
bool
loadSource
(
JSContext
*
cx
ScriptSource
*
ss
bool
*
loaded
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
assignSource
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Unit
>
&
srcBuf
)
;
bool
hasSourceText
(
)
const
{
return
hasUncompressedSource
(
)
|
|
hasCompressedSource
(
)
;
}
private
:
template
<
typename
Unit
>
struct
UncompressedDataMatcher
{
template
<
SourceRetrievable
CanRetrieve
>
const
UncompressedData
<
Unit
>
*
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
u
)
{
return
&
u
;
}
template
<
typename
T
>
const
UncompressedData
<
Unit
>
*
operator
(
)
(
const
T
&
)
{
MOZ_CRASH
(
"
attempting
to
access
uncompressed
data
in
a
ScriptSource
not
"
"
containing
it
"
)
;
return
nullptr
;
}
}
;
public
:
template
<
typename
Unit
>
const
UncompressedData
<
Unit
>
*
uncompressedData
(
)
{
return
data
.
match
(
UncompressedDataMatcher
<
Unit
>
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
CompressedDataMatcher
{
template
<
SourceRetrievable
CanRetrieve
>
const
CompressedData
<
Unit
>
*
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
c
)
{
return
&
c
;
}
template
<
typename
T
>
const
CompressedData
<
Unit
>
*
operator
(
)
(
const
T
&
)
{
MOZ_CRASH
(
"
attempting
to
access
compressed
data
in
a
ScriptSource
not
"
"
containing
it
"
)
;
return
nullptr
;
}
}
;
public
:
template
<
typename
Unit
>
const
CompressedData
<
Unit
>
*
compressedData
(
)
{
return
data
.
match
(
CompressedDataMatcher
<
Unit
>
(
)
)
;
}
private
:
struct
HasUncompressedSource
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
false
;
}
template
<
typename
Unit
>
bool
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
Missing
&
)
{
return
false
;
}
}
;
public
:
bool
hasUncompressedSource
(
)
const
{
return
data
.
match
(
HasUncompressedSource
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
IsUncompressed
{
template
<
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
isUncompressed
(
)
const
{
return
data
.
match
(
IsUncompressed
<
Unit
>
(
)
)
;
}
private
:
struct
HasCompressedSource
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
bool
hasCompressedSource
(
)
const
{
return
data
.
match
(
HasCompressedSource
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
IsCompressed
{
template
<
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
)
{
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
isCompressed
(
)
const
{
return
data
.
match
(
IsCompressed
<
Unit
>
(
)
)
;
}
private
:
template
<
typename
Unit
>
struct
SourceTypeMatcher
{
template
<
template
<
typename
C
SourceRetrievable
R
>
class
Data
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Data
<
Unit
CanRetrieve
>
&
)
{
return
true
;
}
template
<
template
<
typename
C
SourceRetrievable
R
>
class
Data
typename
NotUnit
SourceRetrievable
CanRetrieve
>
bool
operator
(
)
(
const
Data
<
NotUnit
CanRetrieve
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
source
type
only
applies
where
actual
text
is
available
"
)
;
return
false
;
}
template
<
typename
NotUnit
>
bool
operator
(
)
(
const
Retrievable
<
NotUnit
>
&
)
{
return
false
;
}
bool
operator
(
)
(
const
Missing
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
ask
source
type
when
missing
"
)
;
return
false
;
}
}
;
public
:
template
<
typename
Unit
>
bool
hasSourceType
(
)
const
{
return
data
.
match
(
SourceTypeMatcher
<
Unit
>
(
)
)
;
}
private
:
struct
UncompressedLengthMatcher
{
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
size_t
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
u
)
{
return
u
.
length
(
)
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
size_t
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
u
)
{
return
u
.
uncompressedLength
;
}
template
<
typename
Unit
>
size_t
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
-
but
-
retrievable
source
"
)
;
return
0
;
}
size_t
operator
(
)
(
const
Missing
&
m
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
source
"
)
;
return
0
;
}
}
;
public
:
size_t
length
(
)
const
{
MOZ_ASSERT
(
hasSourceText
(
)
)
;
return
data
.
match
(
UncompressedLengthMatcher
(
)
)
;
}
JSLinearString
*
substring
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
JSLinearString
*
substringDontDeflate
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
MOZ_MUST_USE
bool
appendSubstring
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
size_t
start
size_t
stop
)
;
void
setParameterListEnd
(
uint32_t
parameterListEnd
)
{
parameterListEnd_
=
parameterListEnd
;
}
bool
isFunctionBody
(
)
{
return
parameterListEnd_
!
=
0
;
}
JSLinearString
*
functionBodyString
(
JSContext
*
cx
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ScriptSourceInfo
*
info
)
const
;
private
:
template
<
typename
Unit
>
MOZ_MUST_USE
bool
setUncompressedSourceHelper
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
SourceRetrievable
retrievable
)
;
public
:
template
<
typename
Unit
>
MOZ_MUST_USE
bool
initializeUnretrievableUncompressedSource
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
setRetrievedSource
(
JSContext
*
cx
EntryUnits
<
Unit
>
&
&
source
size_t
length
)
;
MOZ_MUST_USE
bool
tryCompressOffThread
(
JSContext
*
cx
)
;
template
<
typename
Unit
>
void
triggerConvertToCompressedSource
(
SharedImmutableString
compressed
size_t
sourceLength
)
;
template
<
typename
Unit
>
MOZ_MUST_USE
bool
initializeWithUnretrievableCompressedSource
(
JSContext
*
cx
UniqueChars
&
&
raw
size_t
rawLength
size_t
sourceLength
)
;
private
:
void
performTaskWork
(
SourceCompressionTask
*
task
)
;
struct
TriggerConvertToCompressedSourceFromTask
{
ScriptSource
*
const
source_
;
SharedImmutableString
&
compressed_
;
TriggerConvertToCompressedSourceFromTask
(
ScriptSource
*
source
SharedImmutableString
&
compressed
)
:
source_
(
source
)
compressed_
(
compressed
)
{
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
void
operator
(
)
(
const
Uncompressed
<
Unit
CanRetrieve
>
&
)
{
source_
-
>
triggerConvertToCompressedSource
<
Unit
>
(
std
:
:
move
(
compressed_
)
source_
-
>
length
(
)
)
;
}
template
<
typename
Unit
SourceRetrievable
CanRetrieve
>
void
operator
(
)
(
const
Compressed
<
Unit
CanRetrieve
>
&
)
{
MOZ_CRASH
(
"
can
'
t
set
compressed
source
when
source
is
already
compressed
-
-
"
"
ScriptSource
:
:
tryCompressOffThread
shouldn
'
t
have
queued
up
this
"
"
task
?
"
)
;
}
template
<
typename
Unit
>
void
operator
(
)
(
const
Retrievable
<
Unit
>
&
)
{
MOZ_CRASH
(
"
shouldn
'
t
compressing
unloaded
-
but
-
retrievable
source
"
)
;
}
void
operator
(
)
(
const
Missing
&
)
{
MOZ_CRASH
(
"
doesn
'
t
make
sense
to
set
compressed
source
for
missing
source
-
-
"
"
ScriptSource
:
:
tryCompressOffThread
shouldn
'
t
have
queued
up
this
"
"
task
?
"
)
;
}
}
;
template
<
typename
Unit
>
void
convertToCompressedSource
(
SharedImmutableString
compressed
size_t
uncompressedLength
)
;
template
<
typename
Unit
>
void
performDelayedConvertToCompressedSource
(
)
;
void
triggerConvertToCompressedSourceFromTask
(
SharedImmutableString
compressed
)
;
private
:
template
<
XDRMode
mode
>
MOZ_MUST_USE
XDRResult
xdrUnretrievableUncompressedSource
(
XDRState
<
mode
>
*
xdr
uint8_t
sourceCharSize
uint32_t
uncompressedLength
)
;
public
:
const
char
*
filename
(
)
const
{
return
filename_
?
filename_
.
ref
(
)
.
chars
(
)
:
nullptr
;
}
MOZ_MUST_USE
bool
setFilename
(
JSContext
*
cx
const
char
*
filename
)
;
MOZ_MUST_USE
bool
setFilename
(
JSContext
*
cx
UniqueChars
&
&
filename
)
;
const
char
*
introducerFilename
(
)
const
{
return
introducerFilename_
?
introducerFilename_
.
ref
(
)
.
chars
(
)
:
filename
(
)
;
}
MOZ_MUST_USE
bool
setIntroducerFilename
(
JSContext
*
cx
const
char
*
filename
)
;
MOZ_MUST_USE
bool
setIntroducerFilename
(
JSContext
*
cx
UniqueChars
&
&
filename
)
;
bool
hasIntroductionType
(
)
const
{
return
introductionType_
;
}
const
char
*
introductionType
(
)
const
{
MOZ_ASSERT
(
hasIntroductionType
(
)
)
;
return
introductionType_
;
}
uint32_t
id
(
)
const
{
return
id_
;
}
MOZ_MUST_USE
bool
setDisplayURL
(
JSContext
*
cx
const
char16_t
*
url
)
;
MOZ_MUST_USE
bool
setDisplayURL
(
JSContext
*
cx
UniqueTwoByteChars
&
&
url
)
;
bool
hasDisplayURL
(
)
const
{
return
displayURL_
.
isSome
(
)
;
}
const
char16_t
*
displayURL
(
)
{
return
displayURL_
.
ref
(
)
.
chars
(
)
;
}
MOZ_MUST_USE
bool
setSourceMapURL
(
JSContext
*
cx
const
char16_t
*
url
)
;
MOZ_MUST_USE
bool
setSourceMapURL
(
JSContext
*
cx
UniqueTwoByteChars
&
&
url
)
;
bool
hasSourceMapURL
(
)
const
{
return
sourceMapURL_
.
isSome
(
)
;
}
const
char16_t
*
sourceMapURL
(
)
{
return
sourceMapURL_
.
ref
(
)
.
chars
(
)
;
}
bool
mutedErrors
(
)
const
{
return
mutedErrors_
;
}
uint32_t
startLine
(
)
const
{
return
startLine_
;
}
bool
hasIntroductionOffset
(
)
const
{
return
introductionOffset_
.
isSome
(
)
;
}
uint32_t
introductionOffset
(
)
const
{
return
introductionOffset_
.
value
(
)
;
}
void
setIntroductionOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
hasIntroductionOffset
(
)
)
;
MOZ_ASSERT
(
offset
<
=
(
uint32_t
)
INT32_MAX
)
;
introductionOffset_
.
emplace
(
offset
)
;
}
bool
containsAsmJS
(
)
const
{
return
containsAsmJS_
;
}
void
setContainsAsmJS
(
)
{
containsAsmJS_
=
true
;
}
bool
hasEncoder
(
)
const
{
return
bool
(
xdrEncoder_
)
;
}
bool
xdrEncodeTopLevel
(
JSContext
*
cx
HandleScript
script
)
;
bool
xdrEncodeFunction
(
JSContext
*
cx
HandleFunction
fun
HandleScriptSourceObject
sourceObject
)
;
bool
xdrFinalizeEncoder
(
JS
:
:
TranscodeBuffer
&
buffer
)
;
private
:
template
<
typename
Unit
template
<
typename
U
SourceRetrievable
CanRetrieve
>
class
Data
XDRMode
mode
>
static
void
codeRetrievable
(
ScriptSource
*
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
codeUncompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
codeCompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
void
codeRetrievableData
(
ScriptSource
*
ss
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
xdrData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
public
:
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
XDRState
<
mode
>
*
xdr
const
mozilla
:
:
Maybe
<
JS
:
:
CompileOptions
>
&
options
MutableHandle
<
ScriptSourceHolder
>
ss
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ScriptSourceHolder
{
ScriptSource
*
ss
;
public
:
ScriptSourceHolder
(
)
:
ss
(
nullptr
)
{
}
explicit
ScriptSourceHolder
(
ScriptSource
*
ss
)
:
ss
(
ss
)
{
ss
-
>
incref
(
)
;
}
~
ScriptSourceHolder
(
)
{
if
(
ss
)
{
ss
-
>
decref
(
)
;
}
}
void
reset
(
ScriptSource
*
newss
)
{
if
(
newss
)
{
newss
-
>
incref
(
)
;
}
if
(
ss
)
{
ss
-
>
decref
(
)
;
}
ss
=
newss
;
}
ScriptSource
*
get
(
)
const
{
return
ss
;
}
void
trace
(
JSTracer
*
trc
)
{
if
(
ss
)
{
ss
-
>
trace
(
trc
)
;
}
}
}
;
class
ScriptSourceObject
:
public
NativeObject
{
static
const
JSClassOps
classOps_
;
static
ScriptSourceObject
*
createInternal
(
JSContext
*
cx
ScriptSource
*
source
HandleObject
canonical
)
;
bool
isCanonical
(
)
const
{
return
&
getReservedSlot
(
CANONICAL_SLOT
)
.
toObject
(
)
=
=
this
;
}
ScriptSourceObject
*
unwrappedCanonical
(
)
const
;
public
:
static
const
JSClass
class_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
ScriptSourceObject
*
create
(
JSContext
*
cx
ScriptSource
*
source
)
;
static
ScriptSourceObject
*
clone
(
JSContext
*
cx
HandleScriptSourceObject
sso
)
;
static
bool
initFromOptions
(
JSContext
*
cx
HandleScriptSourceObject
source
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
static
bool
initElementProperties
(
JSContext
*
cx
HandleScriptSourceObject
source
HandleString
elementAttrName
)
;
bool
hasSource
(
)
const
{
return
!
getReservedSlot
(
SOURCE_SLOT
)
.
isUndefined
(
)
;
}
ScriptSource
*
source
(
)
const
{
return
static_cast
<
ScriptSource
*
>
(
getReservedSlot
(
SOURCE_SLOT
)
.
toPrivate
(
)
)
;
}
JSObject
*
unwrappedElement
(
JSContext
*
cx
)
const
;
const
Value
&
unwrappedElementAttributeName
(
)
const
{
const
Value
&
v
=
unwrappedCanonical
(
)
-
>
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
;
MOZ_ASSERT
(
!
v
.
isMagic
(
)
)
;
return
v
;
}
BaseScript
*
unwrappedIntroductionScript
(
)
const
{
Value
value
=
unwrappedCanonical
(
)
-
>
getReservedSlot
(
INTRODUCTION_SCRIPT_SLOT
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
value
.
toGCThing
(
)
-
>
as
<
BaseScript
>
(
)
;
}
void
setPrivate
(
JSRuntime
*
rt
const
Value
&
value
)
;
Value
canonicalPrivate
(
)
const
{
Value
value
=
getReservedSlot
(
PRIVATE_SLOT
)
;
MOZ_ASSERT_IF
(
!
isCanonical
(
)
value
.
isUndefined
(
)
)
;
return
value
;
}
private
:
enum
{
SOURCE_SLOT
=
0
CANONICAL_SLOT
ELEMENT_PROPERTY_SLOT
INTRODUCTION_SCRIPT_SLOT
PRIVATE_SLOT
RESERVED_SLOTS
}
;
}
;
class
ScriptWarmUpData
{
uintptr_t
data_
=
ResetState
(
)
;
private
:
static
constexpr
uintptr_t
NumTagBits
=
2
;
static
constexpr
uint32_t
MaxWarmUpCount
=
UINT32_MAX
>
>
NumTagBits
;
public
:
static
constexpr
uintptr_t
TagMask
=
(
1
<
<
NumTagBits
)
-
1
;
static
constexpr
uintptr_t
JitScriptTag
=
0
;
static
constexpr
uintptr_t
EnclosingScriptTag
=
1
;
static
constexpr
uintptr_t
EnclosingScopeTag
=
2
;
static
constexpr
uintptr_t
WarmUpCountTag
=
3
;
private
:
constexpr
uintptr_t
ResetState
(
)
{
return
0
|
WarmUpCountTag
;
}
template
<
uintptr_t
Tag
>
inline
void
setTaggedPtr
(
void
*
ptr
)
{
static_assert
(
Tag
<
=
TagMask
"
Tag
must
fit
in
TagMask
"
)
;
MOZ_ASSERT
(
(
uintptr_t
(
ptr
)
&
TagMask
)
=
=
0
)
;
data_
=
uintptr_t
(
ptr
)
|
Tag
;
}
template
<
typename
T
uintptr_t
Tag
>
inline
T
getTaggedPtr
(
)
const
{
static_assert
(
Tag
<
=
TagMask
"
Tag
must
fit
in
TagMask
"
)
;
MOZ_ASSERT
(
(
data_
&
TagMask
)
=
=
Tag
)
;
return
reinterpret_cast
<
T
>
(
data_
&
~
TagMask
)
;
}
void
setWarmUpCount
(
uint32_t
count
)
{
if
(
count
>
MaxWarmUpCount
)
{
count
=
MaxWarmUpCount
;
}
data_
=
(
uintptr_t
(
count
)
<
<
NumTagBits
)
|
WarmUpCountTag
;
}
public
:
void
trace
(
JSTracer
*
trc
)
;
bool
isEnclosingScript
(
)
const
{
return
(
data_
&
TagMask
)
=
=
EnclosingScriptTag
;
}
bool
isEnclosingScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
EnclosingScopeTag
;
}
bool
isWarmUpCount
(
)
const
{
return
(
data_
&
TagMask
)
=
=
WarmUpCountTag
;
}
bool
isJitScript
(
)
const
{
return
(
data_
&
TagMask
)
=
=
JitScriptTag
;
}
BaseScript
*
toEnclosingScript
(
)
const
{
return
getTaggedPtr
<
BaseScript
*
EnclosingScriptTag
>
(
)
;
}
inline
void
initEnclosingScript
(
BaseScript
*
enclosingScript
)
;
inline
void
clearEnclosingScript
(
)
;
Scope
*
toEnclosingScope
(
)
const
{
return
getTaggedPtr
<
Scope
*
EnclosingScopeTag
>
(
)
;
}
inline
void
initEnclosingScope
(
Scope
*
enclosingScope
)
;
inline
void
clearEnclosingScope
(
)
;
uint32_t
toWarmUpCount
(
)
const
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
return
data_
>
>
NumTagBits
;
}
void
resetWarmUpCount
(
uint32_t
count
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
setWarmUpCount
(
count
)
;
}
void
incWarmUpCount
(
uint32_t
amount
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
data_
+
=
uintptr_t
(
amount
)
<
<
NumTagBits
;
}
jit
:
:
JitScript
*
toJitScript
(
)
const
{
return
getTaggedPtr
<
jit
:
:
JitScript
*
JitScriptTag
>
(
)
;
}
void
initJitScript
(
jit
:
:
JitScript
*
jitScript
)
{
MOZ_ASSERT
(
isWarmUpCount
(
)
)
;
setTaggedPtr
<
JitScriptTag
>
(
jitScript
)
;
}
void
clearJitScript
(
)
{
MOZ_ASSERT
(
isJitScript
(
)
)
;
data_
=
ResetState
(
)
;
}
}
JS_HAZ_GC_POINTER
;
static_assert
(
sizeof
(
ScriptWarmUpData
)
=
=
sizeof
(
uintptr_t
)
"
JIT
code
depends
on
ScriptWarmUpData
being
pointer
-
sized
"
)
;
struct
MemberInitializers
{
static
constexpr
uint32_t
MaxInitializers
=
INT32_MAX
;
#
ifdef
DEBUG
bool
valid
=
false
;
#
endif
uint32_t
numMemberInitializers
=
0
;
explicit
MemberInitializers
(
uint32_t
numMemberInitializers
)
:
#
ifdef
DEBUG
valid
(
true
)
#
endif
numMemberInitializers
(
numMemberInitializers
)
{
}
static
MemberInitializers
Invalid
(
)
{
return
MemberInitializers
(
)
;
}
private
:
MemberInitializers
(
)
=
default
;
}
;
class
alignas
(
uintptr_t
)
PrivateScriptData
final
:
public
TrailingArray
{
private
:
uint32_t
ngcthings
=
0
;
js
:
:
MemberInitializers
memberInitializers_
=
js
:
:
MemberInitializers
:
:
Invalid
(
)
;
private
:
Offset
gcThingsOffset
(
)
{
return
offsetOfGCThings
(
)
;
}
Offset
endOffset
(
)
const
{
uintptr_t
size
=
ngcthings
*
sizeof
(
JS
:
:
GCCellPtr
)
;
return
offsetOfGCThings
(
)
+
size
;
}
explicit
PrivateScriptData
(
uint32_t
ngcthings
)
;
public
:
static
constexpr
size_t
offsetOfGCThings
(
)
{
return
sizeof
(
PrivateScriptData
)
;
}
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
gcthings
(
)
{
Offset
offset
=
offsetOfGCThings
(
)
;
return
mozilla
:
:
Span
{
offsetToPointer
<
JS
:
:
GCCellPtr
>
(
offset
)
ngcthings
}
;
}
void
setMemberInitializers
(
MemberInitializers
memberInitializers
)
{
MOZ_ASSERT
(
memberInitializers_
.
valid
=
=
false
"
Only
init
MemberInitializers
once
"
)
;
memberInitializers_
=
memberInitializers
;
}
const
MemberInitializers
&
getMemberInitializers
(
)
{
return
memberInitializers_
;
}
static
PrivateScriptData
*
new_
(
JSContext
*
cx
uint32_t
ngcthings
)
;
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleScope
scriptEnclosingScope
js
:
:
HandleObject
funOrMod
)
;
static
bool
Clone
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
static
bool
InitFromStencil
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
CompilationInfo
&
compilationInfo
const
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
allocationSize
(
)
const
;
PrivateScriptData
(
const
PrivateScriptData
&
)
=
delete
;
PrivateScriptData
&
operator
=
(
const
PrivateScriptData
&
)
=
delete
;
}
;
class
RuntimeScriptData
{
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
>
refCount_
=
{
}
;
js
:
:
UniquePtr
<
ImmutableScriptData
>
isd_
=
nullptr
;
friend
class
:
:
JSScript
;
public
:
RuntimeScriptData
(
)
=
default
;
struct
Hasher
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
AddRef
(
)
{
refCount_
+
+
;
}
void
Release
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
uint32_t
remain
=
-
-
refCount_
;
if
(
remain
=
=
0
)
{
isd_
=
nullptr
;
js_free
(
this
)
;
}
}
static
constexpr
size_t
offsetOfISD
(
)
{
return
offsetof
(
RuntimeScriptData
isd_
)
;
}
template
<
XDRMode
mode
>
static
MOZ_MUST_USE
XDRResult
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
static
bool
InitFromStencil
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
mallocSizeOf
(
isd_
.
get
(
)
)
;
}
RuntimeScriptData
(
const
RuntimeScriptData
&
)
=
delete
;
RuntimeScriptData
&
operator
=
(
const
RuntimeScriptData
&
)
=
delete
;
}
;
struct
RuntimeScriptData
:
:
Hasher
{
using
Lookup
=
RefPtr
<
RuntimeScriptData
>
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
mozilla
:
:
Span
<
const
uint8_t
>
immutableData
=
l
-
>
isd_
-
>
immutableData
(
)
;
return
mozilla
:
:
HashBytes
(
immutableData
.
data
(
)
immutableData
.
size
(
)
)
;
}
static
bool
match
(
RuntimeScriptData
*
entry
const
Lookup
&
lookup
)
{
return
(
entry
-
>
isd_
-
>
immutableData
(
)
=
=
lookup
-
>
isd_
-
>
immutableData
(
)
)
;
}
}
;
using
RuntimeScriptDataTable
=
HashSet
<
RuntimeScriptData
*
RuntimeScriptData
:
:
Hasher
SystemAllocPolicy
>
;
class
BaseScript
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
uint8_t
>
{
public
:
using
ImmutableFlags
=
ImmutableScriptFlagsEnum
;
using
MutableFlags
=
MutableScriptFlagsEnum
;
public
:
uint8_t
*
jitCodeRaw
(
)
const
{
return
headerPtr
(
)
;
}
protected
:
const
GCPtrObject
functionOrGlobal_
=
{
}
;
const
GCPtr
<
ScriptSourceObject
*
>
sourceObject_
=
{
}
;
SourceExtent
extent_
=
{
}
;
ImmutableScriptFlags
immutableFlags_
=
{
}
;
MutableScriptFlags
mutableFlags_
=
{
}
;
PrivateScriptData
*
data_
=
nullptr
;
RefPtr
<
js
:
:
RuntimeScriptData
>
sharedData_
=
{
}
;
ScriptWarmUpData
warmUpData_
=
{
}
;
BaseScript
(
uint8_t
*
stubEntry
JSObject
*
functionOrGlobal
ScriptSourceObject
*
sourceObject
SourceExtent
extent
uint32_t
immutableFlags
)
:
TenuredCellWithNonGCPointer
(
stubEntry
)
functionOrGlobal_
(
functionOrGlobal
)
sourceObject_
(
sourceObject
)
extent_
(
extent
)
immutableFlags_
(
immutableFlags
)
{
MOZ_ASSERT
(
functionOrGlobal
-
>
compartment
(
)
=
=
sourceObject
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
extent_
.
toStringStart
<
=
extent_
.
sourceStart
)
;
MOZ_ASSERT
(
extent_
.
sourceStart
<
=
extent_
.
sourceEnd
)
;
MOZ_ASSERT
(
extent_
.
sourceEnd
<
=
extent_
.
toStringEnd
)
;
}
void
setJitCodeRaw
(
uint8_t
*
code
)
{
setHeaderPtr
(
code
)
;
}
public
:
static
BaseScript
*
New
(
JSContext
*
cx
js
:
:
HandleObject
functionOrGlobal
js
:
:
HandleScriptSourceObject
sourceObject
const
js
:
:
SourceExtent
&
extent
uint32_t
immutableFlags
)
;
static
BaseScript
*
CreateRawLazy
(
JSContext
*
cx
uint32_t
ngcthings
HandleFunction
fun
HandleScriptSourceObject
sourceObject
const
SourceExtent
&
extent
uint32_t
immutableFlags
)
;
bool
isUsingInterpreterTrampoline
(
JSRuntime
*
rt
)
const
;
JSFunction
*
function
(
)
const
{
if
(
functionOrGlobal_
-
>
is
<
JSFunction
>
(
)
)
{
return
&
functionOrGlobal_
-
>
as
<
JSFunction
>
(
)
;
}
return
nullptr
;
}
JS
:
:
Realm
*
realm
(
)
const
{
return
functionOrGlobal_
-
>
nonCCWRealm
(
)
;
}
JS
:
:
Compartment
*
compartment
(
)
const
{
return
functionOrGlobal_
-
>
compartment
(
)
;
}
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
inline
JSPrincipals
*
principals
(
)
const
;
ScriptSourceObject
*
sourceObject
(
)
const
{
return
sourceObject_
;
}
ScriptSource
*
scriptSource
(
)
const
{
return
sourceObject
(
)
-
>
source
(
)
;
}
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
const
char
*
maybeForwardedFilename
(
)
const
{
return
maybeForwardedScriptSource
(
)
-
>
filename
(
)
;
}
uint32_t
sourceStart
(
)
const
{
return
extent_
.
sourceStart
;
}
uint32_t
sourceEnd
(
)
const
{
return
extent_
.
sourceEnd
;
}
uint32_t
sourceLength
(
)
const
{
return
extent_
.
sourceEnd
-
extent_
.
sourceStart
;
}
uint32_t
toStringStart
(
)
const
{
return
extent_
.
toStringStart
;
}
uint32_t
toStringEnd
(
)
const
{
return
extent_
.
toStringEnd
;
}
SourceExtent
extent
(
)
const
{
return
extent_
;
}
MOZ_MUST_USE
bool
appendSourceDataForToString
(
JSContext
*
cx
js
:
:
StringBuffer
&
buf
)
;
void
setToStringEnd
(
uint32_t
toStringEnd
)
{
MOZ_ASSERT
(
extent_
.
toStringStart
<
=
toStringEnd
)
;
MOZ_ASSERT
(
extent_
.
toStringEnd
>
=
extent_
.
sourceEnd
)
;
extent_
.
toStringEnd
=
toStringEnd
;
}
uint32_t
lineno
(
)
const
{
return
extent_
.
lineno
;
}
uint32_t
column
(
)
const
{
return
extent_
.
column
;
}
public
:
ImmutableScriptFlags
immutableFlags
(
)
const
{
return
immutableFlags_
;
}
void
resetImmutableFlags
(
ImmutableScriptFlags
flags
)
{
immutableFlags_
=
flags
;
}
MOZ_MUST_USE
bool
hasFlag
(
ImmutableFlags
flag
)
const
{
return
immutableFlags_
.
hasFlag
(
flag
)
;
}
void
setFlag
(
ImmutableFlags
flag
bool
b
=
true
)
{
immutableFlags_
.
setFlag
(
flag
b
)
;
}
void
clearFlag
(
ImmutableFlags
flag
)
{
immutableFlags_
.
clearFlag
(
flag
)
;
}
MOZ_MUST_USE
bool
hasFlag
(
MutableFlags
flag
)
const
{
return
mutableFlags_
.
hasFlag
(
flag
)
;
}
void
setFlag
(
MutableFlags
flag
bool
b
=
true
)
{
mutableFlags_
.
setFlag
(
flag
b
)
;
}
void
clearFlag
(
MutableFlags
flag
)
{
mutableFlags_
.
clearFlag
(
flag
)
;
}
#
define
FLAG_GETTER
(
enumName
enumEntry
lowerName
)
\
public
:
\
bool
lowerName
(
)
const
{
return
hasFlag
(
enumName
:
:
enumEntry
)
;
}
#
define
FLAG_GETTER_SETTER
(
enumName
enumEntry
lowerName
name
)
\
public
:
\
bool
lowerName
(
)
const
{
return
hasFlag
(
enumName
:
:
enumEntry
)
;
}
\
void
set
#
#
name
(
)
{
setFlag
(
enumName
:
:
enumEntry
)
;
}
\
void
set
#
#
name
(
bool
b
)
{
setFlag
(
enumName
:
:
enumEntry
b
)
;
}
\
void
clear
#
#
name
(
)
{
clearFlag
(
enumName
:
:
enumEntry
)
;
}
#
define
IMMUTABLE_FLAG_GETTER
(
lowerName
name
)
\
FLAG_GETTER
(
ImmutableFlags
name
lowerName
)
#
define
MUTABLE_FLAG_GETTER_SETTER
(
lowerName
name
)
\
FLAG_GETTER_SETTER
(
MutableFlags
name
lowerName
name
)
IMMUTABLE_FLAG_GETTER
(
isForEval
IsForEval
)
IMMUTABLE_FLAG_GETTER
(
isModule
IsModule
)
IMMUTABLE_FLAG_GETTER
(
isFunction
IsFunction
)
IMMUTABLE_FLAG_GETTER
(
selfHosted
SelfHosted
)
IMMUTABLE_FLAG_GETTER
(
forceStrict
ForceStrict
)
IMMUTABLE_FLAG_GETTER
(
hasNonSyntacticScope
HasNonSyntacticScope
)
IMMUTABLE_FLAG_GETTER
(
noScriptRval
NoScriptRval
)
IMMUTABLE_FLAG_GETTER
(
strict
Strict
)
IMMUTABLE_FLAG_GETTER
(
hasModuleGoal
HasModuleGoal
)
IMMUTABLE_FLAG_GETTER
(
hasInnerFunctions
HasInnerFunctions
)
IMMUTABLE_FLAG_GETTER
(
hasDirectEval
HasDirectEval
)
IMMUTABLE_FLAG_GETTER
(
bindingsAccessedDynamically
BindingsAccessedDynamically
)
IMMUTABLE_FLAG_GETTER
(
hasCallSiteObj
HasCallSiteObj
)
IMMUTABLE_FLAG_GETTER
(
isAsync
IsAsync
)
IMMUTABLE_FLAG_GETTER
(
isGenerator
IsGenerator
)
IMMUTABLE_FLAG_GETTER
(
funHasExtensibleScope
FunHasExtensibleScope
)
IMMUTABLE_FLAG_GETTER
(
functionHasThisBinding
FunctionHasThisBinding
)
IMMUTABLE_FLAG_GETTER
(
needsHomeObject
NeedsHomeObject
)
IMMUTABLE_FLAG_GETTER
(
isDerivedClassConstructor
IsDerivedClassConstructor
)
IMMUTABLE_FLAG_GETTER
(
isFieldInitializer
IsFieldInitializer
)
IMMUTABLE_FLAG_GETTER
(
hasRest
HasRest
)
IMMUTABLE_FLAG_GETTER
(
needsFunctionEnvironmentObjects
NeedsFunctionEnvironmentObjects
)
IMMUTABLE_FLAG_GETTER
(
shouldDeclareArguments
ShouldDeclareArguments
)
IMMUTABLE_FLAG_GETTER
(
argumentsHasVarBinding
ArgumentsHasVarBinding
)
IMMUTABLE_FLAG_GETTER
(
alwaysNeedsArgsObj
AlwaysNeedsArgsObj
)
IMMUTABLE_FLAG_GETTER
(
hasMappedArgsObj
HasMappedArgsObj
)
IMMUTABLE_FLAG_GETTER
(
isLikelyConstructorWrapper
IsLikelyConstructorWrapper
)
MUTABLE_FLAG_GETTER_SETTER
(
hasRunOnce
HasRunOnce
)
MUTABLE_FLAG_GETTER_SETTER
(
hasBeenCloned
HasBeenCloned
)
MUTABLE_FLAG_GETTER_SETTER
(
hasScriptCounts
HasScriptCounts
)
MUTABLE_FLAG_GETTER_SETTER
(
hasDebugScript
HasDebugScript
)
MUTABLE_FLAG_GETTER_SETTER
(
needsArgsAnalysis
NeedsArgsAnalysis
)
MUTABLE_FLAG_GETTER_SETTER
(
allowRelazify
AllowRelazify
)
MUTABLE_FLAG_GETTER_SETTER
(
spewEnabled
SpewEnabled
)
MUTABLE_FLAG_GETTER_SETTER
(
failedBoundsCheck
FailedBoundsCheck
)
MUTABLE_FLAG_GETTER_SETTER
(
failedShapeGuard
FailedShapeGuard
)
MUTABLE_FLAG_GETTER_SETTER
(
hadFrequentBailouts
HadFrequentBailouts
)
MUTABLE_FLAG_GETTER_SETTER
(
hadOverflowBailout
HadOverflowBailout
)
MUTABLE_FLAG_GETTER_SETTER
(
uninlineable
Uninlineable
)
MUTABLE_FLAG_GETTER_SETTER
(
invalidatedIdempotentCache
InvalidatedIdempotentCache
)
MUTABLE_FLAG_GETTER_SETTER
(
failedLexicalCheck
FailedLexicalCheck
)
#
undef
IMMUTABLE_FLAG_GETTER
#
undef
MUTABLE_FLAG_GETTER_SETTER
#
undef
FLAG_GETTER
#
undef
FLAG_GETTER_SETTER
bool
treatAsRunOnce
(
)
const
{
MOZ_ASSERT
(
!
hasEnclosingScript
(
)
"
TreatAsRunOnce
is
undefined
if
enclosing
script
is
lazy
"
)
;
return
hasFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
)
;
}
void
initTreatAsRunOnce
(
bool
flag
)
{
MOZ_ASSERT
(
!
hasBytecode
(
)
"
TreatAsRunOnce
can
only
be
updated
on
lazy
scripts
"
)
;
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
flag
)
;
}
GeneratorKind
generatorKind
(
)
const
{
return
isGenerator
(
)
?
GeneratorKind
:
:
Generator
:
GeneratorKind
:
:
NotGenerator
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
if
(
kind
=
=
GeneratorKind
:
:
Generator
)
{
setFlag
(
ImmutableFlags
:
:
IsGenerator
)
;
}
}
FunctionAsyncKind
asyncKind
(
)
const
{
return
isAsync
(
)
?
FunctionAsyncKind
:
:
AsyncFunction
:
FunctionAsyncKind
:
:
SyncFunction
;
}
void
setAsyncKind
(
FunctionAsyncKind
kind
)
{
if
(
kind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
{
setFlag
(
ImmutableFlags
:
:
IsAsync
)
;
}
}
frontend
:
:
ParseGoal
parseGoal
(
)
const
{
return
hasModuleGoal
(
)
?
frontend
:
:
ParseGoal
:
:
Module
:
frontend
:
:
ParseGoal
:
:
Script
;
}
bool
hasEnclosingScript
(
)
const
{
return
warmUpData_
.
isEnclosingScript
(
)
;
}
BaseScript
*
enclosingScript
(
)
const
{
return
warmUpData_
.
toEnclosingScript
(
)
;
}
void
setEnclosingScript
(
BaseScript
*
enclosingScript
)
;
bool
isReadyForDelazification
(
)
const
{
return
warmUpData_
.
isEnclosingScope
(
)
;
}
Scope
*
enclosingScope
(
)
const
{
MOZ_ASSERT
(
!
warmUpData_
.
isEnclosingScript
(
)
"
Enclosing
scope
is
not
computed
yet
"
)
;
if
(
warmUpData_
.
isEnclosingScope
(
)
)
{
return
warmUpData_
.
toEnclosingScope
(
)
;
}
MOZ_ASSERT
(
data_
"
Script
doesn
'
t
seem
to
be
compiled
"
)
;
return
gcthings
(
)
[
js
:
:
GCThingIndex
:
:
outermostScopeIndex
(
)
]
.
as
<
Scope
>
(
)
.
enclosing
(
)
;
}
void
setEnclosingScope
(
Scope
*
enclosingScope
)
;
Scope
*
releaseEnclosingScope
(
)
;
bool
hasJitScript
(
)
const
{
return
warmUpData_
.
isJitScript
(
)
;
}
jit
:
:
JitScript
*
jitScript
(
)
const
{
MOZ_ASSERT
(
hasJitScript
(
)
)
;
return
warmUpData_
.
toJitScript
(
)
;
}
jit
:
:
JitScript
*
maybeJitScript
(
)
const
{
return
hasJitScript
(
)
?
jitScript
(
)
:
nullptr
;
}
inline
bool
hasBaselineScript
(
)
const
;
inline
bool
hasIonScript
(
)
const
;
bool
hasPrivateScriptData
(
)
const
{
return
data_
!
=
nullptr
;
}
void
swapData
(
UniquePtr
<
PrivateScriptData
>
&
other
)
;
mozilla
:
:
Span
<
const
JS
:
:
GCCellPtr
>
gcthings
(
)
const
{
return
data_
?
data_
-
>
gcthings
(
)
:
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
(
)
;
}
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
gcthingsForInit
(
)
{
MOZ_ASSERT
(
!
hasBytecode
(
)
)
;
return
data_
?
data_
-
>
gcthings
(
)
:
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
(
)
;
}
void
setMemberInitializers
(
MemberInitializers
memberInitializers
)
{
MOZ_ASSERT
(
data_
)
;
data_
-
>
setMemberInitializers
(
memberInitializers
)
;
}
const
MemberInitializers
&
getMemberInitializers
(
)
const
{
MOZ_ASSERT
(
data_
)
;
return
data_
-
>
getMemberInitializers
(
)
;
}
RuntimeScriptData
*
sharedData
(
)
const
{
return
sharedData_
;
}
void
initSharedData
(
RuntimeScriptData
*
data
)
{
MOZ_ASSERT
(
sharedData_
=
=
nullptr
)
;
sharedData_
=
data
;
}
void
freeSharedData
(
)
{
sharedData_
=
nullptr
;
}
bool
hasBytecode
(
)
const
{
if
(
sharedData_
)
{
MOZ_ASSERT
(
data_
)
;
MOZ_ASSERT
(
warmUpData_
.
isWarmUpCount
(
)
|
|
warmUpData_
.
isJitScript
(
)
)
;
return
true
;
}
return
false
;
}
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Script
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
data_
)
;
}
inline
JSScript
*
asJSScript
(
)
;
template
<
XDRMode
mode
>
static
XDRResult
XDRLazyScriptData
(
XDRState
<
mode
>
*
xdr
HandleScriptSourceObject
sourceObject
Handle
<
BaseScript
*
>
lazy
bool
hasFieldInitializer
)
;
static
constexpr
size_t
offsetOfJitCodeRaw
(
)
{
return
offsetOfHeaderPtr
(
)
;
}
static
constexpr
size_t
offsetOfPrivateData
(
)
{
return
offsetof
(
BaseScript
data_
)
;
}
static
constexpr
size_t
offsetOfSharedData
(
)
{
return
offsetof
(
BaseScript
sharedData_
)
;
}
static
size_t
offsetOfImmutableFlags
(
)
{
static_assert
(
sizeof
(
ImmutableScriptFlags
)
=
=
sizeof
(
uint32_t
)
)
;
return
offsetof
(
BaseScript
immutableFlags_
)
;
}
static
constexpr
size_t
offsetOfMutableFlags
(
)
{
static_assert
(
sizeof
(
MutableScriptFlags
)
=
=
sizeof
(
uint32_t
)
)
;
return
offsetof
(
BaseScript
mutableFlags_
)
;
}
static
constexpr
size_t
offsetOfWarmUpData
(
)
{
return
offsetof
(
BaseScript
warmUpData_
)
;
}
}
;
template
<
XDRMode
mode
>
XDRResult
XDRScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleObject
funOrMod
MutableHandleScript
scriptp
)
;
template
<
XDRMode
mode
>
XDRResult
XDRLazyScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSourceObject
sourceObject
HandleFunction
fun
MutableHandle
<
BaseScript
*
>
lazy
)
;
template
<
XDRMode
mode
>
XDRResult
XDRSourceExtent
(
XDRState
<
mode
>
*
xdr
SourceExtent
*
extent
)
;
template
<
XDRMode
mode
>
XDRResult
XDRScriptConst
(
XDRState
<
mode
>
*
xdr
MutableHandleValue
vp
)
;
extern
void
SweepScriptData
(
JSRuntime
*
rt
)
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
PrivateScriptData
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
PrivateScriptData
>
{
}
;
}
class
JSScript
:
public
js
:
:
BaseScript
{
private
:
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
XDRScript
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScope
enclosingScope
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleObject
funOrMod
js
:
:
MutableHandleScript
scriptp
)
;
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
RuntimeScriptData
:
:
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
)
;
friend
bool
js
:
:
RuntimeScriptData
:
:
InitFromStencil
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
)
;
template
<
js
:
:
XDRMode
mode
>
friend
js
:
:
XDRResult
js
:
:
PrivateScriptData
:
:
XDR
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScript
script
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
HandleScope
scriptEnclosingScope
js
:
:
HandleObject
funOrMod
)
;
friend
bool
js
:
:
PrivateScriptData
:
:
Clone
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
friend
bool
js
:
:
PrivateScriptData
:
:
InitFromStencil
(
JSContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
CompilationInfo
&
compilationInfo
const
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
)
;
private
:
using
js
:
:
BaseScript
:
:
BaseScript
;
public
:
static
JSScript
*
Create
(
JSContext
*
cx
js
:
:
HandleObject
functionOrGlobal
js
:
:
HandleScriptSourceObject
sourceObject
js
:
:
SourceExtent
extent
js
:
:
ImmutableScriptFlags
flags
)
;
static
JSScript
*
CastFromLazy
(
js
:
:
BaseScript
*
lazy
)
{
return
static_cast
<
JSScript
*
>
(
lazy
)
;
}
static
bool
createPrivateScriptData
(
JSContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
uint32_t
ngcthings
)
;
public
:
static
bool
fullyInitFromStencil
(
JSContext
*
cx
js
:
:
frontend
:
:
CompilationInfo
&
compilationInfo
js
:
:
HandleScript
script
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
js
:
:
HandleFunction
function
)
;
static
JSScript
*
fromStencil
(
JSContext
*
cx
js
:
:
frontend
:
:
CompilationInfo
&
compilationInfo
js
:
:
frontend
:
:
ScriptStencil
&
scriptStencil
js
:
:
HandleFunction
function
)
;
#
ifdef
DEBUG
private
:
void
assertValidJumpTargets
(
)
const
;
#
endif
public
:
js
:
:
ImmutableScriptData
*
immutableScriptData
(
)
const
{
return
sharedData_
-
>
isd_
.
get
(
)
;
}
jsbytecode
*
code
(
)
const
{
if
(
!
sharedData_
)
{
return
nullptr
;
}
return
immutableScriptData
(
)
-
>
code
(
)
;
}
bool
hasForceInterpreterOp
(
)
const
{
MOZ_ASSERT
(
length
(
)
>
=
1
)
;
return
JSOp
(
*
code
(
)
)
=
=
JSOp
:
:
ForceInterpreter
;
}
js
:
:
AllBytecodesIterable
allLocations
(
)
{
return
js
:
:
AllBytecodesIterable
(
this
)
;
}
js
:
:
BytecodeLocation
location
(
)
{
return
js
:
:
BytecodeLocation
(
this
code
(
)
)
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
sharedData_
)
;
return
immutableScriptData
(
)
-
>
codeLength
(
)
;
}
jsbytecode
*
codeEnd
(
)
const
{
return
code
(
)
+
length
(
)
;
}
jsbytecode
*
lastPC
(
)
const
{
jsbytecode
*
pc
=
codeEnd
(
)
-
js
:
:
JSOpLength_RetRval
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
RetRval
)
;
return
pc
;
}
template
<
size_t
ArgBytes
=
0
>
bool
containsPC
(
const
jsbytecode
*
pc
)
const
{
MOZ_ASSERT_IF
(
ArgBytes
js
:
:
GetBytecodeLength
(
pc
)
=
=
sizeof
(
jsbytecode
)
+
ArgBytes
)
;
const
jsbytecode
*
lastByte
=
pc
+
ArgBytes
;
return
pc
>
=
code
(
)
&
&
lastByte
<
codeEnd
(
)
;
}
template
<
typename
ArgType
>
bool
containsPC
(
const
jsbytecode
*
pc
)
const
{
return
containsPC
<
sizeof
(
ArgType
)
>
(
pc
)
;
}
bool
contains
(
const
js
:
:
BytecodeLocation
&
loc
)
const
{
return
containsPC
(
loc
.
toRawBytecode
(
)
)
;
}
size_t
pcToOffset
(
const
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
return
size_t
(
pc
-
code
(
)
)
;
}
jsbytecode
*
offsetToPC
(
size_t
offset
)
const
{
MOZ_ASSERT
(
offset
<
length
(
)
)
;
return
code
(
)
+
offset
;
}
size_t
mainOffset
(
)
const
{
return
immutableScriptData
(
)
-
>
mainOffset
;
}
size_t
nfixed
(
)
const
{
return
immutableScriptData
(
)
-
>
nfixed
;
}
size_t
numAlwaysLiveFixedSlots
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
}
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
}
return
0
;
}
size_t
calculateLiveFixed
(
jsbytecode
*
pc
)
;
size_t
nslots
(
)
const
{
return
immutableScriptData
(
)
-
>
nslots
;
}
unsigned
numArgs
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
numPositionalFormalParameters
(
)
;
}
return
0
;
}
inline
js
:
:
Shape
*
initialEnvironmentShape
(
)
const
;
bool
functionHasParameterExprs
(
)
const
{
js
:
:
Scope
*
scope
=
bodyScope
(
)
;
if
(
!
scope
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
{
return
false
;
}
return
scope
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
hasParameterExprs
(
)
;
}
bool
functionAllowsParameterRedeclaration
(
)
const
{
return
hasMappedArgsObj
(
)
;
}
static
constexpr
size_t
MaxBytecodeTypeSets
=
UINT16_MAX
;
static_assert
(
sizeof
(
js
:
:
ImmutableScriptData
:
:
numBytecodeTypeSets
)
=
=
2
"
MaxBytecodeTypeSets
must
match
sizeof
(
numBytecodeTypeSets
)
"
)
;
size_t
numBytecodeTypeSets
(
)
const
{
return
immutableScriptData
(
)
-
>
numBytecodeTypeSets
;
}
size_t
numICEntries
(
)
const
{
return
immutableScriptData
(
)
-
>
numICEntries
;
}
size_t
funLength
(
)
const
{
return
immutableScriptData
(
)
-
>
funLength
;
}
void
cacheForEval
(
)
{
MOZ_ASSERT
(
isForEval
(
)
)
;
clearFlag
(
MutableFlags
:
:
HasRunOnce
)
;
}
bool
argumentsAliasesFormals
(
)
const
{
return
argumentsHasVarBinding
(
)
&
&
hasMappedArgsObj
(
)
;
}
inline
bool
ensureHasAnalyzedArgsUsage
(
JSContext
*
cx
)
;
bool
needsArgsObj
(
)
const
{
MOZ_ASSERT
(
!
needsArgsAnalysis
(
)
)
;
return
hasFlag
(
MutableFlags
:
:
NeedsArgsObj
)
;
}
void
setNeedsArgsObj
(
bool
needsArgsObj
)
;
static
void
argumentsOptimizationFailed
(
JSContext
*
cx
js
:
:
HandleScript
script
)
;
void
resetArgsUsageAnalysis
(
)
;
bool
argsObjAliasesFormals
(
)
const
{
return
needsArgsObj
(
)
&
&
hasMappedArgsObj
(
)
;
}
void
updateJitCodeRaw
(
JSRuntime
*
rt
)
;
bool
isRelazifiable
(
)
const
{
return
!
hasInnerFunctions
(
)
&
&
!
hasDirectEval
(
)
&
&
!
isGenerator
(
)
&
&
!
isAsync
(
)
&
&
!
hasCallSiteObj
(
)
;
}
js
:
:
ModuleObject
*
module
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
{
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
module
(
)
;
}
return
nullptr
;
}
bool
isGlobalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
;
}
bool
mayReadFrameArgsDirectly
(
)
;
static
JSLinearString
*
sourceData
(
JSContext
*
cx
JS
:
:
HandleScript
script
)
;
void
setDefaultClassConstructorSpan
(
uint32_t
start
uint32_t
end
unsigned
line
unsigned
column
)
;
#
ifdef
MOZ_VTUNE
uint32_t
vtuneMethodID
(
)
;
#
endif
public
:
bool
isDirectEvalInFunction
(
)
const
{
if
(
!
isForEval
(
)
)
{
return
false
;
}
return
bodyScope
(
)
-
>
hasOnChain
(
js
:
:
ScopeKind
:
:
Function
)
;
}
bool
isTopLevel
(
)
{
return
code
(
)
&
&
!
isFunction
(
)
;
}
inline
bool
ensureHasJitScript
(
JSContext
*
cx
js
:
:
jit
:
:
AutoKeepJitScripts
&
)
;
void
maybeReleaseJitScript
(
JSFreeOp
*
fop
)
;
void
releaseJitScript
(
JSFreeOp
*
fop
)
;
void
releaseJitScriptOnFinalize
(
JSFreeOp
*
fop
)
;
inline
js
:
:
jit
:
:
BaselineScript
*
baselineScript
(
)
const
;
inline
js
:
:
jit
:
:
IonScript
*
ionScript
(
)
const
;
inline
bool
isIonCompilingOffThread
(
)
const
;
inline
bool
canIonCompile
(
)
const
;
inline
void
disableIon
(
)
;
inline
bool
canBaselineCompile
(
)
const
;
inline
void
disableBaselineCompile
(
)
;
inline
js
:
:
GlobalObject
&
global
(
)
const
;
inline
bool
hasGlobal
(
const
js
:
:
GlobalObject
*
global
)
const
;
js
:
:
GlobalObject
&
uninlinedGlobal
(
)
const
;
js
:
:
GCThingIndex
bodyScopeIndex
(
)
const
{
return
immutableScriptData
(
)
-
>
bodyScopeIndex
;
}
js
:
:
Scope
*
bodyScope
(
)
const
{
return
getScope
(
bodyScopeIndex
(
)
)
;
}
js
:
:
Scope
*
outermostScope
(
)
const
{
return
getScope
(
js
:
:
GCThingIndex
:
:
outermostScopeIndex
(
)
)
;
}
bool
functionHasExtraBodyVarScope
(
)
const
{
bool
res
=
hasFlag
(
ImmutableFlags
:
:
FunctionHasExtraBodyVarScope
)
;
MOZ_ASSERT_IF
(
res
functionHasParameterExprs
(
)
)
;
return
res
;
}
js
:
:
VarScope
*
functionExtraBodyVarScope
(
)
const
{
MOZ_ASSERT
(
functionHasExtraBodyVarScope
(
)
)
;
for
(
JS
:
:
GCCellPtr
gcThing
:
gcthings
(
)
)
{
if
(
!
gcThing
.
is
<
js
:
:
Scope
>
(
)
)
{
continue
;
}
js
:
:
Scope
*
scope
=
&
gcThing
.
as
<
js
:
:
Scope
>
(
)
;
if
(
scope
-
>
kind
(
)
=
=
js
:
:
ScopeKind
:
:
FunctionBodyVar
)
{
return
&
scope
-
>
as
<
js
:
:
VarScope
>
(
)
;
}
}
MOZ_CRASH
(
"
Function
extra
body
var
scope
not
found
"
)
;
}
bool
needsBodyEnvironment
(
)
const
{
for
(
JS
:
:
GCCellPtr
gcThing
:
gcthings
(
)
)
{
if
(
!
gcThing
.
is
<
js
:
:
Scope
>
(
)
)
{
continue
;
}
js
:
:
Scope
*
scope
=
&
gcThing
.
as
<
js
:
:
Scope
>
(
)
;
if
(
ScopeKindIsInBody
(
scope
-
>
kind
(
)
)
&
&
scope
-
>
hasEnvironment
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
js
:
:
LexicalScope
*
maybeNamedLambdaScope
(
)
const
;
void
relazify
(
JSRuntime
*
rt
)
;
private
:
bool
createJitScript
(
JSContext
*
cx
)
;
bool
createScriptData
(
JSContext
*
cx
)
;
void
initImmutableScriptData
(
js
:
:
UniquePtr
<
js
:
:
ImmutableScriptData
>
&
&
data
)
{
MOZ_ASSERT
(
!
sharedData_
-
>
isd_
)
;
sharedData_
-
>
isd_
=
std
:
:
move
(
data
)
;
}
bool
shareScriptData
(
JSContext
*
cx
)
;
public
:
inline
uint32_t
getWarmUpCount
(
)
const
;
inline
void
incWarmUpCounter
(
uint32_t
amount
=
1
)
;
inline
void
resetWarmUpCounterForGC
(
)
;
void
resetWarmUpCounterToDelayIonCompilation
(
)
;
unsigned
getWarmUpResetCount
(
)
const
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
return
mutableFlags_
&
MASK
;
}
void
incWarmUpResetCounter
(
)
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
uint32_t
newCount
=
getWarmUpResetCount
(
)
+
1
;
if
(
newCount
<
=
MASK
)
{
mutableFlags_
&
=
~
MASK
;
mutableFlags_
|
=
newCount
;
}
}
void
resetWarmUpResetCounter
(
)
{
constexpr
uint32_t
MASK
=
uint32_t
(
MutableFlags
:
:
WarmupResets_MASK
)
;
mutableFlags_
&
=
~
MASK
;
}
public
:
bool
initScriptCounts
(
JSContext
*
cx
)
;
js
:
:
ScriptCounts
&
getScriptCounts
(
)
;
js
:
:
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
;
const
js
:
:
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
;
js
:
:
PCCounts
*
getThrowCounts
(
jsbytecode
*
pc
)
;
uint64_t
getHitCount
(
jsbytecode
*
pc
)
;
void
incHitCount
(
jsbytecode
*
pc
)
;
void
addIonCounts
(
js
:
:
jit
:
:
IonScriptCounts
*
ionCounts
)
;
js
:
:
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
;
void
releaseScriptCounts
(
js
:
:
ScriptCounts
*
counts
)
;
void
destroyScriptCounts
(
)
;
void
resetScriptCounts
(
)
;
jsbytecode
*
main
(
)
const
{
return
code
(
)
+
mainOffset
(
)
;
}
js
:
:
BytecodeLocation
mainLocation
(
)
const
{
return
js
:
:
BytecodeLocation
(
this
main
(
)
)
;
}
js
:
:
BytecodeLocation
endLocation
(
)
const
{
return
js
:
:
BytecodeLocation
(
this
codeEnd
(
)
)
;
}
js
:
:
BytecodeLocation
offsetToLocation
(
uint32_t
offset
)
const
{
return
js
:
:
BytecodeLocation
(
this
offsetToPC
(
offset
)
)
;
}
void
addSizeOfJitScript
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
sizeOfJitScript
size_t
*
sizeOfBaselineFallbackStubs
)
const
;
mozilla
:
:
Span
<
const
js
:
:
TryNote
>
trynotes
(
)
const
{
return
immutableScriptData
(
)
-
>
tryNotes
(
)
;
}
mozilla
:
:
Span
<
const
js
:
:
ScopeNote
>
scopeNotes
(
)
const
{
return
immutableScriptData
(
)
-
>
scopeNotes
(
)
;
}
mozilla
:
:
Span
<
const
uint32_t
>
resumeOffsets
(
)
const
{
return
immutableScriptData
(
)
-
>
resumeOffsets
(
)
;
}
uint32_t
tableSwitchCaseOffset
(
jsbytecode
*
pc
uint32_t
caseIndex
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
TableSwitch
)
;
uint32_t
firstResumeIndex
=
GET_RESUMEINDEX
(
pc
+
3
*
JUMP_OFFSET_LEN
)
;
return
resumeOffsets
(
)
[
firstResumeIndex
+
caseIndex
]
;
}
jsbytecode
*
tableSwitchCasePC
(
jsbytecode
*
pc
uint32_t
caseIndex
)
const
{
return
offsetToPC
(
tableSwitchCaseOffset
(
pc
caseIndex
)
)
;
}
bool
hasLoops
(
)
;
uint32_t
numNotes
(
)
const
{
MOZ_ASSERT
(
sharedData_
)
;
return
immutableScriptData
(
)
-
>
noteLength
(
)
;
}
js
:
:
SrcNote
*
notes
(
)
const
{
MOZ_ASSERT
(
sharedData_
)
;
return
immutableScriptData
(
)
-
>
notes
(
)
;
}
JSAtom
*
getAtom
(
js
:
:
GCThingIndex
index
)
const
{
return
&
gcthings
(
)
[
index
]
.
as
<
JSString
>
(
)
.
asAtom
(
)
;
}
JSAtom
*
getAtom
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
<
js
:
:
GCThingIndex
>
(
pc
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
(
JSOp
)
*
pc
)
=
=
JOF_ATOM
)
;
return
getAtom
(
GET_GCTHING_INDEX
(
pc
)
)
;
}
js
:
:
PropertyName
*
getName
(
js
:
:
GCThingIndex
index
)
{
return
getAtom
(
index
)
-
>
asPropertyName
(
)
;
}
js
:
:
PropertyName
*
getName
(
jsbytecode
*
pc
)
const
{
return
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
}
JSObject
*
getObject
(
js
:
:
GCThingIndex
index
)
const
{
MOZ_ASSERT
(
gcthings
(
)
[
index
]
.
asCell
(
)
-
>
isTenured
(
)
)
;
return
&
gcthings
(
)
[
index
]
.
as
<
JSObject
>
(
)
;
}
JSObject
*
getObject
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
<
js
:
:
GCThingIndex
>
(
pc
)
)
;
return
getObject
(
GET_GCTHING_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
getScope
(
js
:
:
GCThingIndex
index
)
const
{
return
&
gcthings
(
)
[
index
]
.
as
<
js
:
:
Scope
>
(
)
;
}
js
:
:
Scope
*
getScope
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
<
js
:
:
GCThingIndex
>
(
pc
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_SCOPE
"
Did
you
mean
to
use
lookupScope
(
pc
)
?
"
)
;
return
getScope
(
GET_GCTHING_INDEX
(
pc
)
)
;
}
inline
JSFunction
*
getFunction
(
js
:
:
GCThingIndex
index
)
const
;
inline
JSFunction
*
getFunction
(
jsbytecode
*
pc
)
const
;
inline
js
:
:
RegExpObject
*
getRegExp
(
js
:
:
GCThingIndex
index
)
const
;
inline
js
:
:
RegExpObject
*
getRegExp
(
jsbytecode
*
pc
)
const
;
js
:
:
BigInt
*
getBigInt
(
js
:
:
GCThingIndex
index
)
const
{
MOZ_ASSERT
(
gcthings
(
)
[
index
]
.
asCell
(
)
-
>
isTenured
(
)
)
;
return
&
gcthings
(
)
[
index
]
.
as
<
js
:
:
BigInt
>
(
)
;
}
js
:
:
BigInt
*
getBigInt
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
<
js
:
:
GCThingIndex
>
(
pc
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_BIGINT
)
;
return
getBigInt
(
GET_GCTHING_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
lookupScope
(
jsbytecode
*
pc
)
const
;
js
:
:
Scope
*
innermostScope
(
jsbytecode
*
pc
)
const
;
js
:
:
Scope
*
innermostScope
(
)
const
{
return
innermostScope
(
main
(
)
)
;
}
bool
isEmpty
(
)
const
{
if
(
length
(
)
>
3
)
{
return
false
;
}
jsbytecode
*
pc
=
code
(
)
;
if
(
noScriptRval
(
)
&
&
JSOp
(
*
pc
)
=
=
JSOp
:
:
False
)
{
+
+
pc
;
}
return
JSOp
(
*
pc
)
=
=
JSOp
:
:
RetRval
;
}
bool
formalIsAliased
(
unsigned
argSlot
)
;
bool
formalLivesInArgumentsObject
(
unsigned
argSlot
)
;
inline
bool
isDebuggee
(
)
const
;
class
AutoDelazify
;
friend
class
AutoDelazify
;
class
AutoDelazify
{
JS
:
:
RootedScript
script_
;
JSContext
*
cx_
;
bool
oldAllowRelazify_
=
false
;
public
:
explicit
AutoDelazify
(
JSContext
*
cx
JS
:
:
HandleFunction
fun
=
nullptr
)
:
script_
(
cx
)
cx_
(
cx
)
{
holdScript
(
fun
)
;
}
~
AutoDelazify
(
)
{
dropScript
(
)
;
}
void
operator
=
(
JS
:
:
HandleFunction
fun
)
{
dropScript
(
)
;
holdScript
(
fun
)
;
}
operator
JS
:
:
HandleScript
(
)
const
{
return
script_
;
}
explicit
operator
bool
(
)
const
{
return
script_
;
}
private
:
void
holdScript
(
JS
:
:
HandleFunction
fun
)
;
void
dropScript
(
)
;
}
;
}
;
namespace
js
{
struct
ScriptAndCounts
{
JSScript
*
script
;
ScriptCounts
scriptCounts
;
inline
explicit
ScriptAndCounts
(
JSScript
*
script
)
;
inline
ScriptAndCounts
(
ScriptAndCounts
&
&
sac
)
;
const
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetPCCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
const
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetThrowCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
const
{
return
scriptCounts
.
ionCounts_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
script
"
ScriptAndCounts
:
:
script
"
)
;
}
}
;
extern
JS
:
:
UniqueChars
FormatIntroducedFilename
(
JSContext
*
cx
const
char
*
filename
unsigned
lineno
const
char
*
introducer
)
;
struct
GSNCache
;
const
js
:
:
SrcNote
*
GetSrcNote
(
GSNCache
&
cache
JSScript
*
script
jsbytecode
*
pc
)
;
extern
const
js
:
:
SrcNote
*
GetSrcNote
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jsbytecode
*
LineNumberToPC
(
JSScript
*
script
unsigned
lineno
)
;
extern
JS_FRIEND_API
unsigned
GetScriptLineExtent
(
JSScript
*
script
)
;
}
namespace
js
{
extern
unsigned
PCToLineNumber
(
JSScript
*
script
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
unsigned
PCToLineNumber
(
unsigned
startLine
SrcNote
*
notes
jsbytecode
*
code
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
void
DescribeScriptedCallerForCompilation
(
JSContext
*
cx
MutableHandleScript
maybeScript
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
extern
void
DescribeScriptedCallerForDirectEval
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
)
;
JSScript
*
CloneScriptIntoFunction
(
JSContext
*
cx
HandleScope
enclosingScope
HandleFunction
fun
HandleScript
src
Handle
<
ScriptSourceObject
*
>
sourceObject
)
;
JSScript
*
CloneGlobalScript
(
JSContext
*
cx
ScopeKind
scopeKind
HandleScript
src
)
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
JSScript
>
:
public
Concrete
<
js
:
:
BaseScript
>
{
}
;
}
}
#
endif
