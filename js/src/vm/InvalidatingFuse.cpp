#
include
"
vm
/
InvalidatingFuse
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Logging
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
js
:
:
DependentScriptSet
:
:
DependentScriptSet
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
:
associatedFuse
(
fuse
)
weakScripts
(
cx
-
>
runtime
(
)
)
{
}
bool
js
:
:
InvalidatingRuntimeFuse
:
:
addFuseDependency
(
JSContext
*
cx
const
jit
:
:
IonScriptKey
&
ionScript
)
{
MOZ_ASSERT
(
ionScript
.
script
(
)
-
>
zone
(
)
=
=
cx
-
>
zone
(
)
)
;
auto
*
scriptSet
=
cx
-
>
zone
(
)
-
>
fuseDependencies
.
getOrCreateDependentScriptSet
(
cx
this
)
;
if
(
!
scriptSet
)
{
return
false
;
}
return
scriptSet
-
>
addScriptForFuse
(
this
ionScript
)
;
}
void
js
:
:
InvalidatingRuntimeFuse
:
:
popFuse
(
JSContext
*
cx
)
{
GuardFuse
:
:
popFuse
(
cx
)
;
JS_LOG
(
fuseInvalidation
Verbose
"
Invalidating
fuse
popping
:
%
s
"
name
(
)
)
;
for
(
AllZonesIter
z
(
cx
-
>
runtime
(
)
)
;
!
z
.
done
(
)
;
z
.
next
(
)
)
{
for
(
auto
&
fd
:
z
.
get
(
)
-
>
fuseDependencies
)
{
fd
.
invalidateForFuse
(
cx
this
)
;
}
}
}
void
js
:
:
DependentScriptSet
:
:
invalidateForFuse
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
{
if
(
associatedFuse
!
=
fuse
)
{
return
;
}
jit
:
:
InvalidateAndClearScriptSet
(
cx
weakScripts
"
fuse
"
)
;
}
void
js
:
:
jit
:
:
InvalidateAndClearScriptSet
(
JSContext
*
cx
WeakScriptCache
&
scripts
const
char
*
reason
)
{
WeakScriptSet
localScripts
=
scripts
.
stealContents
(
)
;
MOZ_ASSERT
(
scripts
.
empty
(
)
)
;
for
(
auto
r
=
localScripts
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
get
(
)
;
if
(
script
-
>
hasIonScript
(
)
)
{
JitSpew
(
jit
:
:
JitSpew_IonInvalidate
"
Invalidating
ion
script
%
p
for
%
s
"
script
-
>
ionScript
(
)
reason
)
;
JS_LOG
(
fuseInvalidation
Debug
"
Invalidating
ion
script
%
s
:
%
d
for
reason
%
s
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
reason
)
;
js
:
:
jit
:
:
Invalidate
(
cx
script
)
;
}
}
}
bool
js
:
:
DependentScriptSet
:
:
addScriptForFuse
(
InvalidatingFuse
*
fuse
const
jit
:
:
IonScriptKey
&
ionScript
)
{
MOZ_ASSERT
(
fuse
=
=
associatedFuse
)
;
return
jit
:
:
AddScriptToSet
(
weakScripts
ionScript
)
;
}
js
:
:
DependentScriptSet
*
js
:
:
DependentScriptGroup
:
:
getOrCreateDependentScriptSet
(
JSContext
*
cx
js
:
:
InvalidatingFuse
*
fuse
)
{
for
(
auto
&
dss
:
dependencies
)
{
if
(
dss
.
associatedFuse
=
=
fuse
)
{
return
&
dss
;
}
}
if
(
!
dependencies
.
emplaceBack
(
cx
fuse
)
)
{
return
nullptr
;
}
auto
&
dss
=
dependencies
.
back
(
)
;
MOZ_ASSERT
(
dss
.
associatedFuse
=
=
fuse
)
;
return
&
dss
;
}
bool
js
:
:
jit
:
:
AddScriptToSet
(
WeakScriptCache
&
scripts
const
IonScriptKey
&
ionScript
)
{
js
:
:
jit
:
:
WeakScriptSet
:
:
AddPtr
p
=
scripts
.
lookupForAdd
(
ionScript
.
script
(
)
)
;
if
(
!
p
)
{
if
(
!
scripts
.
add
(
p
ionScript
.
script
(
)
)
)
{
return
false
;
}
}
return
true
;
}
void
js
:
:
jit
:
:
RemoveFromScriptSet
(
WeakScriptCache
&
scripts
JSScript
*
script
)
{
js
:
:
jit
:
:
WeakScriptSet
:
:
Ptr
p
=
scripts
.
lookup
(
script
)
;
if
(
p
)
{
scripts
.
remove
(
p
)
;
}
}
