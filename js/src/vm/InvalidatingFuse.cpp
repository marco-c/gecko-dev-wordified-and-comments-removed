#
include
"
vm
/
InvalidatingFuse
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Logging
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
js
:
:
FuseDependentIonScriptSet
:
:
FuseDependentIonScriptSet
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
:
associatedFuse
(
fuse
)
ionScripts
(
cx
-
>
runtime
(
)
)
{
}
bool
js
:
:
InvalidatingRuntimeFuse
:
:
addFuseDependency
(
JSContext
*
cx
const
jit
:
:
IonScriptKey
&
ionScript
)
{
MOZ_ASSERT
(
ionScript
.
script
(
)
-
>
zone
(
)
=
=
cx
-
>
zone
(
)
)
;
auto
*
scriptSet
=
cx
-
>
zone
(
)
-
>
fuseDependencies
.
getOrCreateDependentScriptSet
(
cx
this
)
;
if
(
!
scriptSet
)
{
return
false
;
}
return
scriptSet
-
>
addScriptForFuse
(
this
ionScript
)
;
}
void
js
:
:
InvalidatingRuntimeFuse
:
:
popFuse
(
JSContext
*
cx
)
{
if
(
!
intact
(
)
)
{
return
;
}
GuardFuse
:
:
popFuse
(
cx
)
;
JS_LOG
(
fuseInvalidation
Verbose
"
Invalidating
fuse
popping
:
%
s
"
name
(
)
)
;
for
(
AllZonesIter
z
(
cx
-
>
runtime
(
)
)
;
!
z
.
done
(
)
;
z
.
next
(
)
)
{
for
(
auto
&
fd
:
z
.
get
(
)
-
>
fuseDependencies
)
{
fd
.
invalidateForFuse
(
cx
this
)
;
}
}
}
void
js
:
:
FuseDependentIonScriptSet
:
:
invalidateForFuse
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
{
if
(
associatedFuse
!
=
fuse
)
{
return
;
}
ionScripts
.
get
(
)
.
invalidateAndClear
(
cx
"
fuse
"
)
;
}
void
js
:
:
jit
:
:
DependentIonScriptSet
:
:
invalidateAndClear
(
JSContext
*
cx
const
char
*
reason
)
{
for
(
const
auto
&
ionScriptKey
:
ionScripts_
)
{
IonScript
*
ionScript
=
ionScriptKey
.
maybeIonScriptToInvalidate
(
)
;
if
(
ionScript
)
{
JSScript
*
script
=
ionScriptKey
.
script
(
)
;
JitSpew
(
jit
:
:
JitSpew_IonInvalidate
"
Invalidating
ion
script
%
p
for
%
s
"
ionScript
reason
)
;
JS_LOG
(
fuseInvalidation
Debug
"
Invalidating
ion
script
%
s
:
%
d
for
reason
%
s
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
reason
)
;
}
}
js
:
:
jit
:
:
Invalidate
(
cx
ionScripts_
)
;
ionScripts_
.
clearAndFree
(
)
;
}
bool
js
:
:
FuseDependentIonScriptSet
:
:
addScriptForFuse
(
InvalidatingFuse
*
fuse
const
jit
:
:
IonScriptKey
&
ionScript
)
{
MOZ_ASSERT
(
fuse
=
=
associatedFuse
)
;
return
ionScripts
.
get
(
)
.
addToSet
(
ionScript
)
;
}
js
:
:
FuseDependentIonScriptSet
*
js
:
:
DependentIonScriptGroup
:
:
getOrCreateDependentScriptSet
(
JSContext
*
cx
js
:
:
InvalidatingFuse
*
fuse
)
{
for
(
auto
&
dss
:
dependencies
)
{
if
(
dss
.
associatedFuse
=
=
fuse
)
{
return
&
dss
;
}
}
if
(
!
dependencies
.
emplaceBack
(
cx
fuse
)
)
{
return
nullptr
;
}
auto
&
dss
=
dependencies
.
back
(
)
;
MOZ_ASSERT
(
dss
.
associatedFuse
=
=
fuse
)
;
return
&
dss
;
}
bool
js
:
:
jit
:
:
DependentIonScriptSet
:
:
addToSet
(
const
IonScriptKey
&
ionScript
)
{
MOZ_ASSERT
(
lengthAfterLastCompaction_
<
=
ionScripts_
.
length
(
)
)
;
if
(
!
ionScripts_
.
empty
(
)
&
&
ionScripts_
.
back
(
)
=
=
ionScript
)
{
return
true
;
}
#
ifdef
DEBUG
size_t
numToCheck
=
std
:
:
min
<
size_t
>
(
ionScripts_
.
length
(
)
8
)
;
for
(
size_t
i
=
0
;
i
<
numToCheck
;
i
+
+
)
{
MOZ_ASSERT
(
ionScripts_
[
ionScripts_
.
length
(
)
-
1
-
i
]
!
=
ionScript
)
;
}
#
endif
if
(
ionScripts_
.
length
(
)
/
2
>
lengthAfterLastCompaction_
)
{
ionScripts_
.
eraseIf
(
[
]
(
const
IonScriptKey
&
ionScript
)
{
return
ionScript
.
maybeIonScriptToInvalidate
(
)
=
=
nullptr
;
}
)
;
lengthAfterLastCompaction_
=
ionScripts_
.
length
(
)
;
}
return
ionScripts_
.
append
(
ionScript
)
;
}
