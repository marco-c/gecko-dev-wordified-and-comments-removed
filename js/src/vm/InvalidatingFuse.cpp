#
include
"
vm
/
InvalidatingFuse
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
js
:
:
DependentScriptSet
:
:
DependentScriptSet
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
:
associatedFuse
(
fuse
)
weakScripts
(
cx
-
>
runtime
(
)
)
{
}
bool
js
:
:
InvalidatingRuntimeFuse
:
:
addFuseDependency
(
JSContext
*
cx
Handle
<
JSScript
*
>
script
)
{
auto
*
zone
=
script
-
>
zone
(
)
;
DependentScriptSet
*
dss
=
zone
-
>
fuseDependencies
.
getOrCreateDependentScriptSet
(
cx
this
)
;
if
(
!
dss
)
{
return
false
;
}
return
dss
-
>
addScriptForFuse
(
this
script
)
;
}
void
js
:
:
InvalidatingRuntimeFuse
:
:
popFuse
(
JSContext
*
cx
)
{
GuardFuse
:
:
popFuse
(
cx
)
;
for
(
AllZonesIter
z
(
cx
-
>
runtime
(
)
)
;
!
z
.
done
(
)
;
z
.
next
(
)
)
{
for
(
auto
&
fd
:
z
.
get
(
)
-
>
fuseDependencies
)
{
fd
.
invalidateForFuse
(
cx
this
)
;
}
}
}
void
js
:
:
DependentScriptSet
:
:
invalidateForFuse
(
JSContext
*
cx
InvalidatingFuse
*
fuse
)
{
if
(
associatedFuse
!
=
fuse
)
{
return
;
}
for
(
auto
r
=
weakScripts
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
get
(
)
;
if
(
script
-
>
hasIonScript
(
)
)
{
JitSpew
(
jit
:
:
JitSpew_IonInvalidate
"
Invalidating
ion
script
%
p
"
script
-
>
ionScript
(
)
)
;
js
:
:
jit
:
:
Invalidate
(
cx
script
)
;
}
}
weakScripts
.
clear
(
)
;
}
bool
js
:
:
DependentScriptSet
:
:
addScriptForFuse
(
InvalidatingFuse
*
fuse
Handle
<
JSScript
*
>
script
)
{
MOZ_ASSERT
(
fuse
=
=
associatedFuse
)
;
WeakScriptSet
:
:
AddPtr
p
=
weakScripts
.
lookupForAdd
(
script
)
;
if
(
!
p
)
{
if
(
!
weakScripts
.
add
(
p
script
)
)
{
return
false
;
}
}
return
true
;
}
js
:
:
DependentScriptSet
*
DependentScriptGroup
:
:
getOrCreateDependentScriptSet
(
JSContext
*
cx
js
:
:
InvalidatingFuse
*
fuse
)
{
for
(
auto
&
dss
:
dependencies
)
{
if
(
dss
.
associatedFuse
=
=
fuse
)
{
return
&
dss
;
}
}
if
(
!
dependencies
.
emplaceBack
(
cx
fuse
)
)
{
return
nullptr
;
}
auto
&
dss
=
dependencies
.
back
(
)
;
MOZ_ASSERT
(
dss
.
associatedFuse
=
=
fuse
)
;
return
&
dss
;
}
