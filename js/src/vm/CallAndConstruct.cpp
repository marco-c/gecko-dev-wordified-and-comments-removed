#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
Context
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
ValueArray
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
JS_PUBLIC_API
bool
JS
:
:
IsCallable
(
JSObject
*
obj
)
{
return
obj
-
>
isCallable
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsConstructor
(
JSObject
*
obj
)
{
return
obj
-
>
isConstructor
(
)
;
}
JS_PUBLIC_API
bool
JS_CallFunctionValue
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
JS
:
:
Value
>
fval
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
fval
args
)
;
js
:
:
InvokeArgs
iargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
iargs
args
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
thisv
(
cx
JS
:
:
ObjectOrNullValue
(
obj
)
)
;
return
js
:
:
Call
(
cx
fval
thisv
iargs
rval
)
;
}
JS_PUBLIC_API
bool
JS_CallFunction
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
JSFunction
*
>
fun
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
fun
args
)
;
js
:
:
InvokeArgs
iargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
iargs
args
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
fval
(
cx
JS
:
:
ObjectValue
(
*
fun
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
thisv
(
cx
JS
:
:
ObjectOrNullValue
(
obj
)
)
;
return
js
:
:
Call
(
cx
fval
thisv
iargs
rval
)
;
}
JS_PUBLIC_API
bool
JS_CallFunctionName
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
char
*
name
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
obj
args
)
;
JSAtom
*
atom
=
Atomize
(
cx
name
strlen
(
name
)
)
;
if
(
!
atom
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
fval
(
cx
)
;
JS
:
:
Rooted
<
jsid
>
id
(
cx
AtomToId
(
atom
)
)
;
if
(
!
GetProperty
(
cx
obj
obj
id
&
fval
)
)
{
return
false
;
}
js
:
:
InvokeArgs
iargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
iargs
args
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
thisv
(
cx
JS
:
:
ObjectOrNullValue
(
obj
)
)
;
return
js
:
:
Call
(
cx
fval
thisv
iargs
rval
)
;
}
JS_PUBLIC_API
bool
JS
:
:
Call
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
thisv
JS
:
:
Handle
<
JS
:
:
Value
>
fval
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
thisv
fval
args
)
;
js
:
:
InvokeArgs
iargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
iargs
args
)
)
{
return
false
;
}
return
js
:
:
Call
(
cx
fval
thisv
iargs
rval
)
;
}
JS_PUBLIC_API
bool
JS
:
:
Construct
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
fval
JS
:
:
Handle
<
JSObject
*
>
newTarget
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JSObject
*
>
objp
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
fval
newTarget
args
)
;
if
(
!
js
:
:
IsConstructor
(
fval
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_IGNORE_STACK
fval
nullptr
)
;
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
newTargetVal
(
cx
JS
:
:
ObjectValue
(
*
newTarget
)
)
;
if
(
!
js
:
:
IsConstructor
(
newTargetVal
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_IGNORE_STACK
newTargetVal
nullptr
)
;
return
false
;
}
js
:
:
ConstructArgs
cargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
cargs
args
)
)
{
return
false
;
}
return
js
:
:
Construct
(
cx
fval
cargs
newTargetVal
objp
)
;
}
JS_PUBLIC_API
bool
JS
:
:
Construct
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
fval
const
JS
:
:
HandleValueArray
&
args
JS
:
:
MutableHandle
<
JSObject
*
>
objp
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
cx
-
>
check
(
fval
args
)
;
if
(
!
js
:
:
IsConstructor
(
fval
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_IGNORE_STACK
fval
nullptr
)
;
return
false
;
}
js
:
:
ConstructArgs
cargs
(
cx
)
;
if
(
!
FillArgumentsFromArraylike
(
cx
cargs
args
)
)
{
return
false
;
}
return
js
:
:
Construct
(
cx
fval
cargs
fval
objp
)
;
}
