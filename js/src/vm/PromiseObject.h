#
ifndef
vm_PromiseObject_h
#
define
vm_PromiseObject_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
class
JS_PUBLIC_API
JSObject
;
namespace
js
{
class
SavedFrame
;
enum
PromiseSlots
{
PromiseSlot_Flags
=
0
PromiseSlot_ReactionsOrResult
PromiseSlot_RejectFunction
PromiseSlot_DebugInfo
PromiseSlots
}
;
#
define
PROMISE_FLAG_RESOLVED
0x1
#
define
PROMISE_FLAG_FULFILLED
0x2
#
define
PROMISE_FLAG_HANDLED
0x4
#
define
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS
0x08
#
define
PROMISE_FLAG_DEFAULT_RESOLVING_FUNCTIONS_ALREADY_RESOLVED
0x10
#
define
PROMISE_FLAG_ASYNC
0x20
#
define
PROMISE_FLAG_REQUIRES_USER_INTERACTION_HANDLING
0x40
#
define
PROMISE_FLAG_HAD_USER_INTERACTION_UPON_CREATION
0x80
struct
PromiseReactionRecordBuilder
;
class
PromiseObject
:
public
NativeObject
{
public
:
static
const
unsigned
RESERVED_SLOTS
=
PromiseSlots
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
PromiseObject
*
create
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
executor
JS
:
:
Handle
<
JSObject
*
>
proto
=
nullptr
bool
needsWrapping
=
false
)
;
static
PromiseObject
*
createSkippingExecutor
(
JSContext
*
cx
)
;
static
PromiseObject
*
unforgeableReject
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
static
JSObject
*
unforgeableResolve
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
static
PromiseObject
*
unforgeableResolveWithNonPromise
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
value
)
;
int32_t
flags
(
)
{
return
getFixedSlot
(
PromiseSlot_Flags
)
.
toInt32
(
)
;
}
void
setHandled
(
)
{
setFixedSlot
(
PromiseSlot_Flags
JS
:
:
Int32Value
(
flags
(
)
|
PROMISE_FLAG_HANDLED
)
)
;
}
JS
:
:
PromiseState
state
(
)
{
int32_t
flags
=
this
-
>
flags
(
)
;
if
(
!
(
flags
&
PROMISE_FLAG_RESOLVED
)
)
{
MOZ_ASSERT
(
!
(
flags
&
PROMISE_FLAG_FULFILLED
)
)
;
return
JS
:
:
PromiseState
:
:
Pending
;
}
if
(
flags
&
PROMISE_FLAG_FULFILLED
)
{
return
JS
:
:
PromiseState
:
:
Fulfilled
;
}
return
JS
:
:
PromiseState
:
:
Rejected
;
}
JS
:
:
Value
reactions
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
JS
:
:
Value
value
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
JS
:
:
Value
reason
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
JS
:
:
Value
valueOrReason
(
)
{
MOZ_ASSERT
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
getFixedSlot
(
PromiseSlot_ReactionsOrResult
)
;
}
[
[
nodiscard
]
]
static
bool
resolve
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
JS
:
:
Value
>
resolutionValue
)
;
[
[
nodiscard
]
]
static
bool
reject
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
JS
:
:
Value
>
rejectionValue
)
;
static
void
onSettled
(
JSContext
*
cx
JS
:
:
Handle
<
PromiseObject
*
>
promise
JS
:
:
Handle
<
js
:
:
SavedFrame
*
>
rejectionStack
)
;
double
allocationTime
(
)
;
double
resolutionTime
(
)
;
JSObject
*
allocationSite
(
)
;
JSObject
*
resolutionSite
(
)
;
double
lifetime
(
)
;
double
timeToResolution
(
)
{
MOZ_ASSERT
(
state
(
)
!
=
JS
:
:
PromiseState
:
:
Pending
)
;
return
resolutionTime
(
)
-
allocationTime
(
)
;
}
[
[
nodiscard
]
]
bool
dependentPromises
(
JSContext
*
cx
JS
:
:
MutableHandle
<
GCVector
<
Value
>
>
values
)
;
uint64_t
getID
(
)
;
[
[
nodiscard
]
]
bool
forEachReactionRecord
(
JSContext
*
cx
PromiseReactionRecordBuilder
&
builder
)
;
bool
isUnhandled
(
)
{
MOZ_ASSERT
(
state
(
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
return
!
(
flags
(
)
&
PROMISE_FLAG_HANDLED
)
;
}
bool
requiresUserInteractionHandling
(
)
{
return
(
flags
(
)
&
PROMISE_FLAG_REQUIRES_USER_INTERACTION_HANDLING
)
;
}
void
setRequiresUserInteractionHandling
(
bool
state
)
;
bool
hadUserInteractionUponCreation
(
)
{
return
(
flags
(
)
&
PROMISE_FLAG_HAD_USER_INTERACTION_UPON_CREATION
)
;
}
void
setHadUserInteractionUponCreation
(
bool
state
)
;
void
copyUserInteractionFlagsFrom
(
PromiseObject
&
rhs
)
;
}
;
inline
PromiseObject
*
PromiseResolvedWithUndefined
(
JSContext
*
cx
)
{
return
PromiseObject
:
:
unforgeableResolveWithNonPromise
(
cx
JS
:
:
UndefinedHandleValue
)
;
}
}
#
endif
