#
ifndef
vm_Caches_inl_h
#
define
vm_Caches_inl_h
#
include
"
vm
/
Caches
.
h
"
#
include
<
iterator
>
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
vm
/
Probes
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
namespace
js
{
inline
bool
NewObjectCache
:
:
lookupProto
(
const
JSClass
*
clasp
JSObject
*
proto
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
{
MOZ_ASSERT
(
!
proto
-
>
is
<
GlobalObject
>
(
)
)
;
return
lookup
(
clasp
proto
kind
pentry
)
;
}
inline
bool
NewObjectCache
:
:
lookupGlobal
(
const
JSClass
*
clasp
GlobalObject
*
global
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
{
return
lookup
(
clasp
global
kind
pentry
)
;
}
inline
void
NewObjectCache
:
:
fillGlobal
(
EntryIndex
entry
const
JSClass
*
clasp
GlobalObject
*
global
gc
:
:
AllocKind
kind
NativeObject
*
obj
)
{
return
fill
(
entry
clasp
global
kind
obj
)
;
}
inline
NativeObject
*
NewObjectCache
:
:
newObjectFromHit
(
JSContext
*
cx
EntryIndex
entryIndex
gc
:
:
InitialHeap
heap
)
{
MOZ_ASSERT
(
unsigned
(
entryIndex
)
<
std
:
:
size
(
entries
)
)
;
Entry
*
entry
=
&
entries
[
entryIndex
]
;
NativeObject
*
templateObj
=
reinterpret_cast
<
NativeObject
*
>
(
&
entry
-
>
templateObject
)
;
ObjectGroup
*
group
=
templateObj
-
>
group
(
)
;
if
(
group
-
>
realm
(
)
!
=
cx
-
>
realm
(
)
)
{
return
nullptr
;
}
if
(
cx
-
>
runtime
(
)
-
>
gc
.
upcomingZealousGC
(
)
)
{
return
nullptr
;
}
const
JSClass
*
clasp
=
templateObj
-
>
getClass
(
)
;
NativeObject
*
obj
=
static_cast
<
NativeObject
*
>
(
AllocateObject
<
NoGC
>
(
cx
entry
-
>
kind
0
heap
clasp
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
copyCachedToObject
(
obj
templateObj
entry
-
>
kind
)
;
if
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
{
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
cx
obj
)
;
}
else
{
obj
=
static_cast
<
NativeObject
*
>
(
SetNewObjectMetadata
(
cx
obj
)
)
;
}
probes
:
:
CreateObject
(
cx
obj
)
;
gc
:
:
gcprobes
:
:
CreateObject
(
obj
)
;
return
obj
;
}
}
#
endif
