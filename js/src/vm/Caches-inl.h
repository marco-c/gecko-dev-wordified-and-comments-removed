#
ifndef
vm_Caches_inl_h
#
define
vm_Caches_inl_h
#
include
"
vm
/
Caches
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
GCTrace
.
h
"
#
include
"
vm
/
Probes
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
namespace
js
{
inline
bool
NewObjectCache
:
:
lookupProto
(
const
Class
*
clasp
JSObject
*
proto
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
{
MOZ_ASSERT
(
!
proto
-
>
is
<
GlobalObject
>
(
)
)
;
return
lookup
(
clasp
proto
kind
pentry
)
;
}
inline
bool
NewObjectCache
:
:
lookupGlobal
(
const
Class
*
clasp
GlobalObject
*
global
gc
:
:
AllocKind
kind
EntryIndex
*
pentry
)
{
return
lookup
(
clasp
global
kind
pentry
)
;
}
inline
void
NewObjectCache
:
:
fillGlobal
(
EntryIndex
entry
const
Class
*
clasp
GlobalObject
*
global
gc
:
:
AllocKind
kind
NativeObject
*
obj
)
{
return
fill
(
entry
clasp
global
kind
obj
)
;
}
inline
NativeObject
*
NewObjectCache
:
:
newObjectFromHit
(
JSContext
*
cx
EntryIndex
entryIndex
gc
:
:
InitialHeap
heap
)
{
MOZ_ASSERT
(
unsigned
(
entryIndex
)
<
mozilla
:
:
ArrayLength
(
entries
)
)
;
Entry
*
entry
=
&
entries
[
entryIndex
]
;
NativeObject
*
templateObj
=
reinterpret_cast
<
NativeObject
*
>
(
&
entry
-
>
templateObject
)
;
ObjectGroup
*
group
=
templateObj
-
>
group_
;
MOZ_ASSERT
(
!
group
-
>
hasUnanalyzedPreliminaryObjects
(
)
)
;
{
AutoSweepObjectGroup
sweepGroup
(
group
)
;
if
(
group
-
>
shouldPreTenure
(
sweepGroup
)
)
heap
=
gc
:
:
TenuredHeap
;
}
if
(
cx
-
>
runtime
(
)
-
>
gc
.
upcomingZealousGC
(
)
)
return
nullptr
;
NativeObject
*
obj
=
static_cast
<
NativeObject
*
>
(
Allocate
<
JSObject
NoGC
>
(
cx
entry
-
>
kind
0
heap
group
-
>
clasp
(
)
)
)
;
if
(
!
obj
)
return
nullptr
;
copyCachedToObject
(
obj
templateObj
entry
-
>
kind
)
;
if
(
group
-
>
clasp
(
)
-
>
shouldDelayMetadataBuilder
(
)
)
cx
-
>
realm
(
)
-
>
setObjectPendingMetadata
(
cx
obj
)
;
else
obj
=
static_cast
<
NativeObject
*
>
(
SetNewObjectMetadata
(
cx
obj
)
)
;
probes
:
:
CreateObject
(
cx
obj
)
;
gc
:
:
gcTracer
.
traceCreateObject
(
obj
)
;
return
obj
;
}
}
#
endif
