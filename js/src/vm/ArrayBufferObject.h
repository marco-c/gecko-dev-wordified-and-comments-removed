#
ifndef
vm_ArrayBufferObject_h
#
define
vm_ArrayBufferObject_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
tuple
>
#
include
"
builtin
/
TypedArrayConstants
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
namespace
js
{
class
ArrayBufferViewObject
;
class
WasmArrayRawBuffer
;
void
*
MapBufferMemory
(
size_t
mappedSize
size_t
initialCommittedSize
)
;
bool
CommitBufferMemory
(
void
*
dataEnd
size_t
delta
)
;
bool
ExtendBufferMapping
(
void
*
dataStart
size_t
mappedSize
size_t
newMappedSize
)
;
void
UnmapBufferMemory
(
void
*
dataStart
size_t
mappedSize
)
;
int32_t
LiveMappedBufferCount
(
)
;
class
ArrayBufferObjectMaybeShared
;
mozilla
:
:
Maybe
<
uint64_t
>
WasmArrayBufferMaxSize
(
const
ArrayBufferObjectMaybeShared
*
buf
)
;
size_t
WasmArrayBufferMappedSize
(
const
ArrayBufferObjectMaybeShared
*
buf
)
;
class
BufferSize
{
size_t
size_
=
0
;
public
:
explicit
BufferSize
(
size_t
size
)
:
size_
(
size
)
{
}
size_t
get
(
)
const
{
return
size_
;
}
}
;
class
ArrayBufferObjectMaybeShared
:
public
NativeObject
{
public
:
inline
BufferSize
byteLength
(
)
const
;
inline
bool
isDetached
(
)
const
;
inline
SharedMem
<
uint8_t
*
>
dataPointerEither
(
)
;
mozilla
:
:
Maybe
<
uint64_t
>
wasmMaxSize
(
)
const
{
return
WasmArrayBufferMaxSize
(
this
)
;
}
size_t
wasmMappedSize
(
)
const
{
return
WasmArrayBufferMappedSize
(
this
)
;
}
inline
bool
isPreparedForAsmJS
(
)
const
;
inline
bool
isWasm
(
)
const
;
}
;
using
RootedArrayBufferObjectMaybeShared
=
Rooted
<
ArrayBufferObjectMaybeShared
*
>
;
using
HandleArrayBufferObjectMaybeShared
=
Handle
<
ArrayBufferObjectMaybeShared
*
>
;
using
MutableHandleArrayBufferObjectMaybeShared
=
MutableHandle
<
ArrayBufferObjectMaybeShared
*
>
;
class
ArrayBufferObject
:
public
ArrayBufferObjectMaybeShared
{
static
bool
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
public
:
static
const
uint8_t
DATA_SLOT
=
0
;
static
const
uint8_t
BYTE_LENGTH_SLOT
=
1
;
static
const
uint8_t
FIRST_VIEW_SLOT
=
2
;
static
const
uint8_t
FLAGS_SLOT
=
3
;
static
const
uint8_t
RESERVED_SLOTS
=
4
;
static
const
size_t
ARRAY_BUFFER_ALIGNMENT
=
8
;
static_assert
(
FLAGS_SLOT
=
=
JS_ARRAYBUFFER_FLAGS_SLOT
"
self
-
hosted
code
with
burned
-
in
constants
must
get
the
"
"
right
flags
slot
"
)
;
static
bool
supportLargeBuffers
;
static
constexpr
size_t
MaxByteLengthForSmallBuffer
=
INT32_MAX
;
static
size_t
maxBufferByteLength
(
)
{
#
ifdef
JS_64BIT
if
(
supportLargeBuffers
)
{
return
size_t
(
8
)
*
1024
*
1024
*
1024
;
}
#
endif
return
MaxByteLengthForSmallBuffer
;
}
static
constexpr
size_t
MaxInlineBytes
=
(
NativeObject
:
:
MAX_FIXED_SLOTS
-
RESERVED_SLOTS
)
*
sizeof
(
JS
:
:
Value
)
;
public
:
enum
BufferKind
{
INLINE_DATA
=
0b000
MALLOCED
=
0b001
NO_DATA
=
0b010
USER_OWNED
=
0b011
WASM
=
0b100
MAPPED
=
0b101
EXTERNAL
=
0b110
BAD1
=
0b111
KIND_MASK
=
0b111
}
;
public
:
enum
ArrayBufferFlags
{
BUFFER_KIND_MASK
=
BufferKind
:
:
KIND_MASK
DETACHED
=
0b1000
TYPED_OBJECT_VIEWS
=
0b1
'
0000
FOR_ASMJS
=
0b10
'
0000
}
;
static_assert
(
JS_ARRAYBUFFER_DETACHED_FLAG
=
=
DETACHED
"
self
-
hosted
code
with
burned
-
in
constants
must
use
the
"
"
correct
DETACHED
bit
value
"
)
;
protected
:
enum
class
FillContents
{
Zero
Uninitialized
}
;
template
<
FillContents
FillType
>
static
std
:
:
tuple
<
ArrayBufferObject
*
uint8_t
*
>
createBufferAndData
(
JSContext
*
cx
BufferSize
nbytes
AutoSetNewObjectMetadata
&
JS
:
:
Handle
<
JSObject
*
>
proto
=
nullptr
)
;
public
:
class
BufferContents
{
uint8_t
*
data_
;
BufferKind
kind_
;
JS
:
:
BufferContentsFreeFunc
free_
;
void
*
freeUserData_
;
friend
class
ArrayBufferObject
;
BufferContents
(
uint8_t
*
data
BufferKind
kind
JS
:
:
BufferContentsFreeFunc
freeFunc
=
nullptr
void
*
freeUserData
=
nullptr
)
:
data_
(
data
)
kind_
(
kind
)
free_
(
freeFunc
)
freeUserData_
(
freeUserData
)
{
MOZ_ASSERT
(
(
kind_
&
~
KIND_MASK
)
=
=
0
)
;
MOZ_ASSERT_IF
(
free_
|
|
freeUserData_
kind_
=
=
EXTERNAL
)
;
}
public
:
static
BufferContents
createInlineData
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
INLINE_DATA
)
;
}
static
BufferContents
createMalloced
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
MALLOCED
)
;
}
static
BufferContents
createNoData
(
)
{
return
BufferContents
(
nullptr
NO_DATA
)
;
}
static
BufferContents
createUserOwned
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
USER_OWNED
)
;
}
static
BufferContents
createWasm
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
WASM
)
;
}
static
BufferContents
createMapped
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
MAPPED
)
;
}
static
BufferContents
createExternal
(
void
*
data
JS
:
:
BufferContentsFreeFunc
freeFunc
void
*
freeUserData
=
nullptr
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
EXTERNAL
freeFunc
freeUserData
)
;
}
static
BufferContents
createFailed
(
)
{
return
BufferContents
(
nullptr
MALLOCED
)
;
}
uint8_t
*
data
(
)
const
{
return
data_
;
}
BufferKind
kind
(
)
const
{
return
kind_
;
}
JS
:
:
BufferContentsFreeFunc
freeFunc
(
)
const
{
return
free_
;
}
void
*
freeUserData
(
)
const
{
return
freeUserData_
;
}
explicit
operator
bool
(
)
const
{
return
data_
!
=
nullptr
;
}
WasmArrayRawBuffer
*
wasmBuffer
(
)
const
;
}
;
static
const
JSClass
class_
;
static
const
JSClass
protoClass_
;
static
bool
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
fun_isView
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
isOriginalByteLengthGetter
(
Native
native
)
{
return
native
=
=
byteLengthGetter
;
}
static
ArrayBufferObject
*
createForContents
(
JSContext
*
cx
BufferSize
nbytes
BufferContents
contents
)
;
static
ArrayBufferObject
*
copy
(
JSContext
*
cx
JS
:
:
Handle
<
ArrayBufferObject
*
>
unwrappedArrayBuffer
)
;
static
ArrayBufferObject
*
createZeroed
(
JSContext
*
cx
BufferSize
nbytes
HandleObject
proto
=
nullptr
)
;
static
ArrayBufferObject
*
createForTypedObject
(
JSContext
*
cx
BufferSize
nbytes
)
;
static
ArrayBufferObject
*
createEmpty
(
JSContext
*
cx
)
;
static
ArrayBufferObject
*
createFromNewRawBuffer
(
JSContext
*
cx
WasmArrayRawBuffer
*
buffer
BufferSize
initialSize
)
;
static
void
copyData
(
Handle
<
ArrayBufferObject
*
>
toBuffer
size_t
toIndex
Handle
<
ArrayBufferObject
*
>
fromBuffer
size_t
fromIndex
size_t
count
)
;
static
size_t
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
;
static
uint8_t
*
stealMallocedContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
;
static
BufferContents
extractStructuredCloneContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
;
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
)
;
JSObject
*
firstView
(
)
;
bool
addView
(
JSContext
*
cx
ArrayBufferViewObject
*
view
)
;
static
void
detach
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
)
;
static
constexpr
size_t
offsetOfByteLengthSlot
(
)
{
return
getFixedSlotOffset
(
BYTE_LENGTH_SLOT
)
;
}
static
constexpr
size_t
offsetOfFlagsSlot
(
)
{
return
getFixedSlotOffset
(
FLAGS_SLOT
)
;
}
private
:
void
setFirstView
(
ArrayBufferViewObject
*
view
)
;
uint8_t
*
inlineDataPointer
(
)
const
;
struct
FreeInfo
{
JS
:
:
BufferContentsFreeFunc
freeFunc
;
void
*
freeUserData
;
}
;
FreeInfo
*
freeInfo
(
)
const
;
public
:
uint8_t
*
dataPointer
(
)
const
;
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
;
BufferSize
byteLength
(
)
const
;
BufferContents
contents
(
)
const
{
if
(
isExternal
(
)
)
{
return
BufferContents
(
dataPointer
(
)
EXTERNAL
freeInfo
(
)
-
>
freeFunc
freeInfo
(
)
-
>
freeUserData
)
;
}
return
BufferContents
(
dataPointer
(
)
bufferKind
(
)
)
;
}
bool
hasInlineData
(
)
const
{
return
dataPointer
(
)
=
=
inlineDataPointer
(
)
;
}
void
releaseData
(
JSFreeOp
*
fop
)
;
BufferKind
bufferKind
(
)
const
{
return
BufferKind
(
flags
(
)
&
BUFFER_KIND_MASK
)
;
}
bool
isInlineData
(
)
const
{
return
bufferKind
(
)
=
=
INLINE_DATA
;
}
bool
isMalloced
(
)
const
{
return
bufferKind
(
)
=
=
MALLOCED
;
}
bool
isNoData
(
)
const
{
return
bufferKind
(
)
=
=
NO_DATA
;
}
bool
hasUserOwnedData
(
)
const
{
return
bufferKind
(
)
=
=
USER_OWNED
;
}
bool
isWasm
(
)
const
{
return
bufferKind
(
)
=
=
WASM
;
}
bool
isMapped
(
)
const
{
return
bufferKind
(
)
=
=
MAPPED
;
}
bool
isExternal
(
)
const
{
return
bufferKind
(
)
=
=
EXTERNAL
;
}
bool
isDetached
(
)
const
{
return
flags
(
)
&
DETACHED
;
}
bool
isPreparedForAsmJS
(
)
const
{
return
flags
(
)
&
FOR_ASMJS
;
}
[
[
nodiscard
]
]
bool
prepareForAsmJS
(
)
;
size_t
wasmMappedSize
(
)
const
;
mozilla
:
:
Maybe
<
uint64_t
>
wasmMaxSize
(
)
const
;
[
[
nodiscard
]
]
static
bool
wasmGrowToSizeInPlace
(
BufferSize
newSize
Handle
<
ArrayBufferObject
*
>
oldBuf
MutableHandle
<
ArrayBufferObject
*
>
newBuf
JSContext
*
cx
)
;
[
[
nodiscard
]
]
static
bool
wasmMovingGrowToSize
(
BufferSize
newSize
Handle
<
ArrayBufferObject
*
>
oldBuf
MutableHandle
<
ArrayBufferObject
*
>
newBuf
JSContext
*
cx
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
BufferContents
createMappedContents
(
int
fd
size_t
offset
size_t
length
)
;
bool
hasTypedObjectViews
(
)
const
{
return
flags
(
)
&
TYPED_OBJECT_VIEWS
;
}
protected
:
void
setDataPointer
(
BufferContents
contents
)
;
void
setByteLength
(
BufferSize
length
)
;
size_t
associatedBytes
(
)
const
;
uint32_t
flags
(
)
const
;
void
setFlags
(
uint32_t
flags
)
;
void
setHasTypedObjectViews
(
)
{
setFlags
(
flags
(
)
|
TYPED_OBJECT_VIEWS
)
;
}
void
setIsDetached
(
)
{
setFlags
(
flags
(
)
|
DETACHED
)
;
}
void
setIsPreparedForAsmJS
(
)
{
MOZ_ASSERT
(
!
isWasm
(
)
)
;
MOZ_ASSERT
(
!
hasUserOwnedData
(
)
)
;
MOZ_ASSERT
(
!
isInlineData
(
)
)
;
MOZ_ASSERT
(
isMalloced
(
)
|
|
isMapped
(
)
|
|
isExternal
(
)
)
;
setFlags
(
flags
(
)
|
FOR_ASMJS
)
;
}
void
initialize
(
BufferSize
byteLength
BufferContents
contents
)
{
setByteLength
(
byteLength
)
;
setFlags
(
0
)
;
setFirstView
(
nullptr
)
;
setDataPointer
(
contents
)
;
}
void
*
initializeToInlineData
(
size_t
byteLength
)
{
void
*
data
=
inlineDataPointer
(
)
;
initialize
(
BufferSize
(
byteLength
)
BufferContents
:
:
createInlineData
(
data
)
)
;
return
data
;
}
}
;
using
RootedArrayBufferObject
=
Rooted
<
ArrayBufferObject
*
>
;
using
HandleArrayBufferObject
=
Handle
<
ArrayBufferObject
*
>
;
using
MutableHandleArrayBufferObject
=
MutableHandle
<
ArrayBufferObject
*
>
;
bool
CreateWasmBuffer
(
JSContext
*
cx
wasm
:
:
MemoryKind
memKind
const
wasm
:
:
Limits
&
memory
MutableHandleArrayBufferObjectMaybeShared
buffer
)
;
class
InnerViewTable
{
public
:
typedef
Vector
<
JSObject
*
1
ZoneAllocPolicy
>
ViewVector
;
friend
class
ArrayBufferObject
;
private
:
struct
MapGCPolicy
{
static
bool
needsSweep
(
JSObject
*
*
key
ViewVector
*
value
)
{
return
InnerViewTable
:
:
sweepEntry
(
key
*
value
)
;
}
}
;
using
Map
=
GCHashMap
<
JSObject
*
ViewVector
MovableCellHasher
<
JSObject
*
>
ZoneAllocPolicy
MapGCPolicy
>
;
Map
map
;
Vector
<
JSObject
*
0
SystemAllocPolicy
>
nurseryKeys
;
bool
nurseryKeysValid
;
static
bool
sweepEntry
(
JSObject
*
*
pkey
ViewVector
&
views
)
;
bool
addView
(
JSContext
*
cx
ArrayBufferObject
*
buffer
JSObject
*
view
)
;
ViewVector
*
maybeViewsUnbarriered
(
ArrayBufferObject
*
obj
)
;
void
removeViews
(
ArrayBufferObject
*
obj
)
;
public
:
explicit
InnerViewTable
(
Zone
*
zone
)
:
map
(
zone
)
nurseryKeysValid
(
true
)
{
}
void
sweep
(
)
;
void
sweepAfterMinorGC
(
)
;
bool
needsSweep
(
)
const
{
return
map
.
needsSweep
(
)
;
}
bool
needsSweepAfterMinorGC
(
)
const
{
return
!
nurseryKeys
.
empty
(
)
|
|
!
nurseryKeysValid
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
InnerViewTable
Wrapper
>
:
public
WrappedPtrOperations
<
InnerViewTable
Wrapper
>
{
InnerViewTable
&
table
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
table
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
class
WasmArrayRawBuffer
{
mozilla
:
:
Maybe
<
uint64_t
>
maxSize_
;
size_t
mappedSize_
;
BufferSize
length_
;
protected
:
WasmArrayRawBuffer
(
uint8_t
*
buffer
const
mozilla
:
:
Maybe
<
uint64_t
>
&
maxSize
size_t
mappedSize
BufferSize
length
)
:
maxSize_
(
maxSize
)
mappedSize_
(
mappedSize
)
length_
(
length
)
{
MOZ_ASSERT
(
buffer
=
=
dataPointer
(
)
)
;
}
public
:
static
WasmArrayRawBuffer
*
Allocate
(
BufferSize
numBytes
const
mozilla
:
:
Maybe
<
uint64_t
>
&
maxSize
const
mozilla
:
:
Maybe
<
size_t
>
&
mappedSize
)
;
static
void
Release
(
void
*
mem
)
;
uint8_t
*
dataPointer
(
)
{
uint8_t
*
ptr
=
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
return
ptr
+
sizeof
(
WasmArrayRawBuffer
)
;
}
static
const
WasmArrayRawBuffer
*
fromDataPtr
(
const
uint8_t
*
dataPtr
)
{
return
reinterpret_cast
<
const
WasmArrayRawBuffer
*
>
(
dataPtr
-
sizeof
(
WasmArrayRawBuffer
)
)
;
}
uint8_t
*
basePointer
(
)
{
return
dataPointer
(
)
-
gc
:
:
SystemPageSize
(
)
;
}
size_t
mappedSize
(
)
const
{
return
mappedSize_
;
}
mozilla
:
:
Maybe
<
uint64_t
>
maxSize
(
)
const
{
return
maxSize_
;
}
BufferSize
byteLength
(
)
const
{
return
length_
;
}
[
[
nodiscard
]
]
bool
growToSizeInPlace
(
BufferSize
oldSize
BufferSize
newSize
)
;
[
[
nodiscard
]
]
bool
extendMappedSize
(
uint64_t
maxSize
)
;
void
tryGrowMaxSizeInPlace
(
uint64_t
deltaMaxSize
)
;
}
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
ArrayBufferObjectMaybeShared
>
(
)
const
;
#
endif
