#
ifndef
vm_ArrayBufferObject_h
#
define
vm_ArrayBufferObject_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
builtin
/
TypedObjectConstants
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
typedef
struct
JSProperty
JSProperty
;
namespace
js
{
class
ArrayBufferViewObject
;
class
WasmArrayRawBuffer
;
void
*
MapBufferMemory
(
size_t
mappedSize
size_t
initialCommittedSize
)
;
bool
CommitBufferMemory
(
void
*
dataEnd
uint32_t
delta
)
;
#
ifndef
WASM_HUGE_MEMORY
bool
ExtendBufferMapping
(
void
*
dataStart
size_t
mappedSize
size_t
newMappedSize
)
;
#
endif
void
UnmapBufferMemory
(
void
*
dataStart
size_t
mappedSize
)
;
int32_t
LiveMappedBufferCount
(
)
;
class
ArrayBufferObjectMaybeShared
;
mozilla
:
:
Maybe
<
uint32_t
>
WasmArrayBufferMaxSize
(
const
ArrayBufferObjectMaybeShared
*
buf
)
;
size_t
WasmArrayBufferMappedSize
(
const
ArrayBufferObjectMaybeShared
*
buf
)
;
class
ArrayBufferObjectMaybeShared
:
public
NativeObject
{
public
:
inline
uint32_t
byteLength
(
)
;
inline
bool
isDetached
(
)
const
;
inline
SharedMem
<
uint8_t
*
>
dataPointerEither
(
)
;
mozilla
:
:
Maybe
<
uint32_t
>
wasmMaxSize
(
)
const
{
return
WasmArrayBufferMaxSize
(
this
)
;
}
size_t
wasmMappedSize
(
)
const
{
return
WasmArrayBufferMappedSize
(
this
)
;
}
#
ifndef
WASM_HUGE_MEMORY
uint32_t
wasmBoundsCheckLimit
(
)
const
;
#
endif
inline
bool
isPreparedForAsmJS
(
)
const
;
inline
bool
isWasm
(
)
const
;
}
;
typedef
Rooted
<
ArrayBufferObjectMaybeShared
*
>
RootedArrayBufferObjectMaybeShared
;
typedef
Handle
<
ArrayBufferObjectMaybeShared
*
>
HandleArrayBufferObjectMaybeShared
;
typedef
MutableHandle
<
ArrayBufferObjectMaybeShared
*
>
MutableHandleArrayBufferObjectMaybeShared
;
class
ArrayBufferObject
:
public
ArrayBufferObjectMaybeShared
{
static
bool
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
fun_slice_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
public
:
static
const
uint8_t
DATA_SLOT
=
0
;
static
const
uint8_t
BYTE_LENGTH_SLOT
=
1
;
static
const
uint8_t
FIRST_VIEW_SLOT
=
2
;
static
const
uint8_t
FLAGS_SLOT
=
3
;
static
const
uint8_t
RESERVED_SLOTS
=
4
;
static
const
size_t
ARRAY_BUFFER_ALIGNMENT
=
8
;
static_assert
(
FLAGS_SLOT
=
=
JS_ARRAYBUFFER_FLAGS_SLOT
"
self
-
hosted
code
with
burned
-
in
constants
must
get
the
"
"
right
flags
slot
"
)
;
static
const
size_t
MaxBufferByteLength
=
INT32_MAX
;
public
:
enum
OwnsState
{
DoesntOwnData
=
0
OwnsData
=
1
}
;
enum
BufferKind
{
PLAIN
=
0
WASM
=
1
MAPPED
=
2
EXTERNAL
=
3
KIND_MASK
=
0x3
}
;
protected
:
enum
ArrayBufferFlags
{
BUFFER_KIND_MASK
=
BufferKind
:
:
KIND_MASK
DETACHED
=
0x4
OWNS_DATA
=
0x8
FOR_INLINE_TYPED_OBJECT
=
0x10
TYPED_OBJECT_VIEWS
=
0x20
FOR_ASMJS
=
0x40
}
;
static_assert
(
JS_ARRAYBUFFER_DETACHED_FLAG
=
=
DETACHED
"
self
-
hosted
code
with
burned
-
in
constants
must
use
the
"
"
correct
DETACHED
bit
value
"
)
;
public
:
class
BufferContents
{
uint8_t
*
data_
;
BufferKind
kind_
;
JS
:
:
BufferContentsRefFunc
ref_
;
JS
:
:
BufferContentsRefFunc
unref_
;
void
*
refUserData_
;
friend
class
ArrayBufferObject
;
BufferContents
(
uint8_t
*
data
BufferKind
kind
JS
:
:
BufferContentsRefFunc
ref
=
nullptr
JS
:
:
BufferContentsRefFunc
unref
=
nullptr
void
*
refUserData
=
nullptr
)
:
data_
(
data
)
kind_
(
kind
)
ref_
(
ref
)
unref_
(
unref
)
refUserData_
(
refUserData
)
{
MOZ_ASSERT
(
(
kind_
&
~
KIND_MASK
)
=
=
0
)
;
MOZ_ASSERT_IF
(
ref_
|
|
unref_
|
|
refUserData_
kind_
=
=
EXTERNAL
)
;
}
public
:
template
<
BufferKind
Kind
>
static
BufferContents
create
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
Kind
)
;
}
static
BufferContents
createPlain
(
void
*
data
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
PLAIN
)
;
}
static
BufferContents
createExternal
(
void
*
data
JS
:
:
BufferContentsRefFunc
ref
JS
:
:
BufferContentsRefFunc
unref
void
*
refUserData
=
nullptr
)
{
return
BufferContents
(
static_cast
<
uint8_t
*
>
(
data
)
EXTERNAL
ref
unref
refUserData
)
;
}
uint8_t
*
data
(
)
const
{
return
data_
;
}
BufferKind
kind
(
)
const
{
return
kind_
;
}
JS
:
:
BufferContentsRefFunc
refFunc
(
)
const
{
return
ref_
;
}
JS
:
:
BufferContentsRefFunc
unrefFunc
(
)
const
{
return
unref_
;
}
void
*
refUserData
(
)
const
{
return
refUserData_
;
}
explicit
operator
bool
(
)
const
{
return
data_
!
=
nullptr
;
}
WasmArrayRawBuffer
*
wasmBuffer
(
)
const
;
}
;
static
const
Class
class_
;
static
const
Class
protoClass_
;
static
bool
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
fun_slice
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
fun_isView
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
fun_species
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
ArrayBufferObject
*
create
(
JSContext
*
cx
uint32_t
nbytes
BufferContents
contents
OwnsState
ownsState
=
OwnsData
HandleObject
proto
=
nullptr
NewObjectKind
newKind
=
GenericObject
)
;
static
ArrayBufferObject
*
create
(
JSContext
*
cx
uint32_t
nbytes
HandleObject
proto
=
nullptr
)
;
static
ArrayBufferObject
*
createEmpty
(
JSContext
*
cx
)
;
static
ArrayBufferObject
*
createFromNewRawBuffer
(
JSContext
*
cx
WasmArrayRawBuffer
*
buffer
uint32_t
initialSize
)
;
static
void
copyData
(
Handle
<
ArrayBufferObject
*
>
toBuffer
uint32_t
toIndex
Handle
<
ArrayBufferObject
*
>
fromBuffer
uint32_t
fromIndex
uint32_t
count
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
size_t
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
;
static
BufferContents
externalizeContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
bool
hasStealableContents
)
;
static
BufferContents
stealContents
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
bool
hasStealableContents
)
;
bool
hasStealableContents
(
)
const
{
return
ownsData
(
)
&
&
!
isPreparedForAsmJS
(
)
&
&
!
isWasm
(
)
;
}
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
)
;
ArrayBufferViewObject
*
firstView
(
)
;
bool
addView
(
JSContext
*
cx
JSObject
*
view
)
;
void
setNewData
(
FreeOp
*
fop
BufferContents
newContents
OwnsState
ownsState
)
;
void
changeContents
(
JSContext
*
cx
BufferContents
newContents
OwnsState
ownsState
)
;
static
void
detach
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
BufferContents
newContents
)
;
private
:
void
changeViewContents
(
JSContext
*
cx
ArrayBufferViewObject
*
view
uint8_t
*
oldDataPointer
BufferContents
newContents
)
;
void
setFirstView
(
ArrayBufferViewObject
*
view
)
;
uint8_t
*
inlineDataPointer
(
)
const
;
struct
RefcountInfo
{
JS
:
:
BufferContentsRefFunc
ref
;
JS
:
:
BufferContentsRefFunc
unref
;
void
*
refUserData
;
}
;
RefcountInfo
*
refcountInfo
(
)
const
;
public
:
uint8_t
*
dataPointer
(
)
const
;
SharedMem
<
uint8_t
*
>
dataPointerShared
(
)
const
;
uint32_t
byteLength
(
)
const
;
BufferContents
contents
(
)
const
{
if
(
isExternal
(
)
)
{
return
BufferContents
(
dataPointer
(
)
EXTERNAL
refcountInfo
(
)
-
>
ref
refcountInfo
(
)
-
>
unref
refcountInfo
(
)
-
>
refUserData
)
;
}
return
BufferContents
(
dataPointer
(
)
bufferKind
(
)
)
;
}
bool
hasInlineData
(
)
const
{
return
dataPointer
(
)
=
=
inlineDataPointer
(
)
;
}
void
releaseData
(
FreeOp
*
fop
)
;
bool
hasData
(
)
const
{
return
getClass
(
)
=
=
&
class_
;
}
BufferKind
bufferKind
(
)
const
{
return
BufferKind
(
flags
(
)
&
BUFFER_KIND_MASK
)
;
}
bool
isPlain
(
)
const
{
return
bufferKind
(
)
=
=
PLAIN
;
}
bool
isWasm
(
)
const
{
return
bufferKind
(
)
=
=
WASM
;
}
bool
isMapped
(
)
const
{
return
bufferKind
(
)
=
=
MAPPED
;
}
bool
isExternal
(
)
const
{
return
bufferKind
(
)
=
=
EXTERNAL
;
}
bool
isDetached
(
)
const
{
return
flags
(
)
&
DETACHED
;
}
bool
isPreparedForAsmJS
(
)
const
{
return
flags
(
)
&
FOR_ASMJS
;
}
static
MOZ_MUST_USE
bool
prepareForAsmJS
(
JSContext
*
cx
Handle
<
ArrayBufferObject
*
>
buffer
bool
needGuard
)
;
size_t
wasmMappedSize
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
wasmMaxSize
(
)
const
;
static
MOZ_MUST_USE
bool
wasmGrowToSizeInPlace
(
uint32_t
newSize
Handle
<
ArrayBufferObject
*
>
oldBuf
MutableHandle
<
ArrayBufferObject
*
>
newBuf
JSContext
*
cx
)
;
#
ifndef
WASM_HUGE_MEMORY
static
MOZ_MUST_USE
bool
wasmMovingGrowToSize
(
uint32_t
newSize
Handle
<
ArrayBufferObject
*
>
oldBuf
MutableHandle
<
ArrayBufferObject
*
>
newBuf
JSContext
*
cx
)
;
uint32_t
wasmBoundsCheckLimit
(
)
const
;
#
endif
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
static
BufferContents
createMappedContents
(
int
fd
size_t
offset
size_t
length
)
;
static
size_t
offsetOfFlagsSlot
(
)
{
return
getFixedSlotOffset
(
FLAGS_SLOT
)
;
}
static
size_t
offsetOfDataSlot
(
)
{
return
getFixedSlotOffset
(
DATA_SLOT
)
;
}
void
setForInlineTypedObject
(
)
{
setFlags
(
flags
(
)
|
FOR_INLINE_TYPED_OBJECT
)
;
}
void
setHasTypedObjectViews
(
)
{
setFlags
(
flags
(
)
|
TYPED_OBJECT_VIEWS
)
;
}
bool
forInlineTypedObject
(
)
const
{
return
flags
(
)
&
FOR_INLINE_TYPED_OBJECT
;
}
protected
:
void
setDataPointer
(
BufferContents
contents
OwnsState
ownsState
)
;
void
setByteLength
(
uint32_t
length
)
;
uint32_t
flags
(
)
const
;
void
setFlags
(
uint32_t
flags
)
;
bool
ownsData
(
)
const
{
return
flags
(
)
&
OWNS_DATA
;
}
void
setOwnsData
(
OwnsState
owns
)
{
setFlags
(
owns
?
(
flags
(
)
|
OWNS_DATA
)
:
(
flags
(
)
&
~
OWNS_DATA
)
)
;
}
bool
hasTypedObjectViews
(
)
const
{
return
flags
(
)
&
TYPED_OBJECT_VIEWS
;
}
void
setIsDetached
(
)
{
setFlags
(
flags
(
)
|
DETACHED
)
;
}
void
setIsPreparedForAsmJS
(
)
{
setFlags
(
flags
(
)
|
FOR_ASMJS
)
;
}
void
initialize
(
size_t
byteLength
BufferContents
contents
OwnsState
ownsState
)
{
setByteLength
(
byteLength
)
;
setFlags
(
0
)
;
setFirstView
(
nullptr
)
;
setDataPointer
(
contents
ownsState
)
;
}
}
;
typedef
Rooted
<
ArrayBufferObject
*
>
RootedArrayBufferObject
;
typedef
Handle
<
ArrayBufferObject
*
>
HandleArrayBufferObject
;
typedef
MutableHandle
<
ArrayBufferObject
*
>
MutableHandleArrayBufferObject
;
bool
CreateWasmBuffer
(
JSContext
*
cx
const
wasm
:
:
Limits
&
memory
MutableHandleArrayBufferObjectMaybeShared
buffer
)
;
class
ArrayBufferViewObject
:
public
NativeObject
{
public
:
static
ArrayBufferObjectMaybeShared
*
bufferObject
(
JSContext
*
cx
Handle
<
ArrayBufferViewObject
*
>
obj
)
;
void
notifyBufferDetached
(
JSContext
*
cx
void
*
newData
)
;
#
ifdef
DEBUG
bool
isSharedMemory
(
)
;
#
endif
uint8_t
*
dataPointerUnshared
(
const
JS
:
:
AutoRequireNoGC
&
)
;
void
setDataPointerUnshared
(
uint8_t
*
data
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
}
;
bool
ToClampedIndex
(
JSContext
*
cx
HandleValue
v
uint32_t
length
uint32_t
*
out
)
;
bool
IsArrayBuffer
(
HandleValue
v
)
;
bool
IsArrayBuffer
(
HandleObject
obj
)
;
bool
IsArrayBuffer
(
JSObject
*
obj
)
;
ArrayBufferObject
&
AsArrayBuffer
(
HandleObject
obj
)
;
ArrayBufferObject
&
AsArrayBuffer
(
JSObject
*
obj
)
;
bool
IsArrayBufferMaybeShared
(
HandleValue
v
)
;
bool
IsArrayBufferMaybeShared
(
HandleObject
obj
)
;
bool
IsArrayBufferMaybeShared
(
JSObject
*
obj
)
;
ArrayBufferObjectMaybeShared
&
AsArrayBufferMaybeShared
(
HandleObject
obj
)
;
ArrayBufferObjectMaybeShared
&
AsArrayBufferMaybeShared
(
JSObject
*
obj
)
;
extern
uint32_t
JS_FASTCALL
ClampDoubleToUint8
(
const
double
x
)
;
struct
uint8_clamped
{
uint8_t
val
;
uint8_clamped
(
)
:
val
{
'
\
0
'
}
{
}
uint8_clamped
(
const
uint8_clamped
&
other
)
:
val
(
other
.
val
)
{
}
explicit
uint8_clamped
(
uint8_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
uint16_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
uint32_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
int8_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
int16_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
int32_t
x
)
{
*
this
=
x
;
}
explicit
uint8_clamped
(
double
x
)
{
*
this
=
x
;
}
uint8_clamped
&
operator
=
(
const
uint8_clamped
&
x
)
{
val
=
x
.
val
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
uint8_t
x
)
{
val
=
x
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
uint16_t
x
)
{
val
=
(
x
>
255
)
?
255
:
uint8_t
(
x
)
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
uint32_t
x
)
{
val
=
(
x
>
255
)
?
255
:
uint8_t
(
x
)
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
int8_t
x
)
{
val
=
(
x
>
=
0
)
?
uint8_t
(
x
)
:
0
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
int16_t
x
)
{
val
=
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
int32_t
x
)
{
val
=
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
return
*
this
;
}
uint8_clamped
&
operator
=
(
const
double
x
)
{
val
=
uint8_t
(
ClampDoubleToUint8
(
x
)
)
;
return
*
this
;
}
operator
uint8_t
(
)
const
{
return
val
;
}
void
staticAsserts
(
)
{
static_assert
(
sizeof
(
uint8_clamped
)
=
=
1
"
uint8_clamped
must
be
layout
-
compatible
with
uint8_t
"
)
;
}
}
;
template
<
typename
T
>
inline
bool
TypeIsFloatingPoint
(
)
{
return
false
;
}
template
<
>
inline
bool
TypeIsFloatingPoint
<
float
>
(
)
{
return
true
;
}
template
<
>
inline
bool
TypeIsFloatingPoint
<
double
>
(
)
{
return
true
;
}
template
<
typename
T
>
inline
bool
TypeIsUnsigned
(
)
{
return
false
;
}
template
<
>
inline
bool
TypeIsUnsigned
<
uint8_t
>
(
)
{
return
true
;
}
template
<
>
inline
bool
TypeIsUnsigned
<
uint16_t
>
(
)
{
return
true
;
}
template
<
>
inline
bool
TypeIsUnsigned
<
uint32_t
>
(
)
{
return
true
;
}
class
InnerViewTable
{
public
:
typedef
Vector
<
ArrayBufferViewObject
*
1
SystemAllocPolicy
>
ViewVector
;
friend
class
ArrayBufferObject
;
private
:
struct
MapGCPolicy
{
static
bool
needsSweep
(
JSObject
*
*
key
ViewVector
*
value
)
{
return
InnerViewTable
:
:
sweepEntry
(
key
*
value
)
;
}
}
;
typedef
GCHashMap
<
JSObject
*
ViewVector
MovableCellHasher
<
JSObject
*
>
SystemAllocPolicy
MapGCPolicy
>
Map
;
Map
map
;
Vector
<
JSObject
*
0
SystemAllocPolicy
>
nurseryKeys
;
bool
nurseryKeysValid
;
static
bool
sweepEntry
(
JSObject
*
*
pkey
ViewVector
&
views
)
;
bool
addView
(
JSContext
*
cx
ArrayBufferObject
*
obj
ArrayBufferViewObject
*
view
)
;
ViewVector
*
maybeViewsUnbarriered
(
ArrayBufferObject
*
obj
)
;
void
removeViews
(
ArrayBufferObject
*
obj
)
;
public
:
InnerViewTable
(
)
:
nurseryKeysValid
(
true
)
{
}
void
sweep
(
)
;
void
sweepAfterMinorGC
(
)
;
bool
needsSweep
(
)
const
{
return
map
.
needsSweep
(
)
;
}
bool
needsSweepAfterMinorGC
(
)
const
{
return
!
nurseryKeys
.
empty
(
)
|
|
!
nurseryKeysValid
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
}
;
template
<
typename
Wrapper
>
class
MutableWrappedPtrOperations
<
InnerViewTable
Wrapper
>
:
public
WrappedPtrOperations
<
InnerViewTable
Wrapper
>
{
InnerViewTable
&
table
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
table
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
ArrayBufferViewObject
>
(
)
const
;
template
<
>
bool
JSObject
:
:
is
<
js
:
:
ArrayBufferObjectMaybeShared
>
(
)
const
;
#
endif
