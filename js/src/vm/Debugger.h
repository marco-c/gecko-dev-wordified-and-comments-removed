#
ifndef
vm_Debugger_h
#
define
vm_Debugger_h
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
jsclist
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsweakmap
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
asmjs
/
WasmModule
.
h
"
#
include
"
ds
/
TraceableFifo
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
enum
JSTrapStatus
{
JSTRAP_ERROR
JSTRAP_CONTINUE
JSTRAP_RETURN
JSTRAP_THROW
JSTRAP_LIMIT
}
;
namespace
js
{
class
Breakpoint
;
class
DebuggerMemory
;
typedef
HashSet
<
ReadBarrieredGlobalObject
MovableCellHasher
<
ReadBarrieredGlobalObject
>
RuntimeAllocPolicy
>
WeakGlobalObjectSet
;
template
<
class
UnbarrieredKey
bool
InvisibleKeysOk
=
false
>
class
DebuggerWeakMap
:
private
WeakMap
<
RelocatablePtr
<
UnbarrieredKey
>
RelocatablePtrObject
MovableCellHasher
<
RelocatablePtr
<
UnbarrieredKey
>
>
>
{
private
:
typedef
RelocatablePtr
<
UnbarrieredKey
>
Key
;
typedef
RelocatablePtrObject
Value
;
typedef
HashMap
<
JS
:
:
Zone
*
uintptr_t
DefaultHasher
<
JS
:
:
Zone
*
>
RuntimeAllocPolicy
>
CountMap
;
CountMap
zoneCounts
;
JSCompartment
*
compartment
;
public
:
typedef
WeakMap
<
Key
Value
MovableCellHasher
<
Key
>
>
Base
;
explicit
DebuggerWeakMap
(
JSContext
*
cx
)
:
Base
(
cx
)
zoneCounts
(
cx
-
>
runtime
(
)
)
compartment
(
cx
-
>
compartment
(
)
)
{
}
public
:
typedef
typename
Base
:
:
Entry
Entry
;
typedef
typename
Base
:
:
Ptr
Ptr
;
typedef
typename
Base
:
:
AddPtr
AddPtr
;
typedef
typename
Base
:
:
Range
Range
;
typedef
typename
Base
:
:
Enum
Enum
;
typedef
typename
Base
:
:
Lookup
Lookup
;
using
Base
:
:
lookupForAdd
;
using
Base
:
:
all
;
using
Base
:
:
trace
;
bool
init
(
uint32_t
len
=
16
)
{
return
Base
:
:
init
(
len
)
&
&
zoneCounts
.
init
(
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
relookupOrAdd
(
AddPtr
&
p
const
KeyInput
&
k
const
ValueInput
&
v
)
{
MOZ_ASSERT
(
v
-
>
compartment
(
)
=
=
this
-
>
compartment
)
;
MOZ_ASSERT
(
!
k
-
>
compartment
(
)
-
>
creationOptions
(
)
.
mergeable
(
)
)
;
MOZ_ASSERT_IF
(
!
InvisibleKeysOk
!
k
-
>
compartment
(
)
-
>
creationOptions
(
)
.
invisibleToDebugger
(
)
)
;
MOZ_ASSERT
(
!
Base
:
:
has
(
k
)
)
;
if
(
!
incZoneCount
(
k
-
>
zone
(
)
)
)
return
false
;
bool
ok
=
Base
:
:
relookupOrAdd
(
p
k
v
)
;
if
(
!
ok
)
decZoneCount
(
k
-
>
zone
(
)
)
;
return
ok
;
}
void
remove
(
const
Lookup
&
l
)
{
MOZ_ASSERT
(
Base
:
:
has
(
l
)
)
;
Base
:
:
remove
(
l
)
;
decZoneCount
(
l
-
>
zone
(
)
)
;
}
public
:
template
<
void
(
traceValueEdges
)
(
JSTracer
*
JSObject
*
)
>
void
markCrossCompartmentEdges
(
JSTracer
*
tracer
)
{
for
(
Enum
e
(
*
static_cast
<
Base
*
>
(
this
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
traceValueEdges
(
tracer
e
.
front
(
)
.
value
(
)
)
;
Key
key
=
e
.
front
(
)
.
key
(
)
;
TraceEdge
(
tracer
&
key
"
Debugger
WeakMap
key
"
)
;
if
(
key
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
key
)
;
key
.
unsafeSet
(
nullptr
)
;
}
}
bool
hasKeyInZone
(
JS
:
:
Zone
*
zone
)
{
CountMap
:
:
Ptr
p
=
zoneCounts
.
lookup
(
zone
)
;
MOZ_ASSERT_IF
(
p
.
found
(
)
p
-
>
value
(
)
>
0
)
;
return
p
.
found
(
)
;
}
private
:
void
sweep
(
)
{
for
(
Enum
e
(
*
static_cast
<
Base
*
>
(
this
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
gc
:
:
IsAboutToBeFinalized
(
&
e
.
front
(
)
.
mutableKey
(
)
)
)
{
decZoneCount
(
e
.
front
(
)
.
key
(
)
-
>
zone
(
)
)
;
e
.
removeFront
(
)
;
}
}
Base
:
:
assertEntriesNotAboutToBeFinalized
(
)
;
}
bool
incZoneCount
(
JS
:
:
Zone
*
zone
)
{
CountMap
:
:
Ptr
p
=
zoneCounts
.
lookupWithDefault
(
zone
0
)
;
if
(
!
p
)
return
false
;
+
+
p
-
>
value
(
)
;
return
true
;
}
void
decZoneCount
(
JS
:
:
Zone
*
zone
)
{
CountMap
:
:
Ptr
p
=
zoneCounts
.
lookup
(
zone
)
;
MOZ_ASSERT
(
p
)
;
MOZ_ASSERT
(
p
-
>
value
(
)
>
0
)
;
-
-
p
-
>
value
(
)
;
if
(
p
-
>
value
(
)
=
=
0
)
zoneCounts
.
remove
(
zone
)
;
}
}
;
class
LeaveDebuggeeNoExecute
;
class
AutoSuppressDebuggeeNoExecuteChecks
{
EnterDebuggeeNoExecute
*
*
stack_
;
EnterDebuggeeNoExecute
*
prev_
;
public
:
explicit
AutoSuppressDebuggeeNoExecuteChecks
(
JSContext
*
cx
)
{
stack_
=
&
cx
-
>
runtime
(
)
-
>
noExecuteDebuggerTop
;
prev_
=
*
stack_
;
*
stack_
=
nullptr
;
}
~
AutoSuppressDebuggeeNoExecuteChecks
(
)
{
MOZ_ASSERT
(
!
*
stack_
)
;
*
stack_
=
prev_
;
}
}
;
typedef
JSObject
Env
;
typedef
mozilla
:
:
Variant
<
JSScript
*
WasmModuleObject
*
>
DebuggerScriptReferent
;
typedef
mozilla
:
:
Variant
<
ScriptSourceObject
*
WasmModuleObject
*
>
DebuggerSourceReferent
;
class
Debugger
:
private
mozilla
:
:
LinkedListElement
<
Debugger
>
{
friend
class
Breakpoint
;
friend
class
DebuggerMemory
;
friend
class
SavedStacks
;
friend
class
mozilla
:
:
LinkedListElement
<
Debugger
>
;
friend
class
mozilla
:
:
LinkedList
<
Debugger
>
;
friend
bool
(
:
:
JS_DefineDebuggerObject
)
(
JSContext
*
cx
JS
:
:
HandleObject
obj
)
;
friend
bool
(
:
:
JS
:
:
dbg
:
:
IsDebugger
)
(
JSObject
&
)
;
friend
bool
(
:
:
JS
:
:
dbg
:
:
GetDebuggeeGlobals
)
(
JSContext
*
JSObject
&
AutoObjectVector
&
)
;
friend
void
JS
:
:
dbg
:
:
onNewPromise
(
JSContext
*
cx
HandleObject
promise
)
;
friend
void
JS
:
:
dbg
:
:
onPromiseSettled
(
JSContext
*
cx
HandleObject
promise
)
;
friend
bool
JS
:
:
dbg
:
:
FireOnGarbageCollectionHook
(
JSContext
*
cx
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Ptr
&
&
data
)
;
public
:
enum
Hook
{
OnDebuggerStatement
OnExceptionUnwind
OnNewScript
OnEnterFrame
OnNewGlobalObject
OnNewPromise
OnPromiseSettled
OnGarbageCollection
HookCount
}
;
enum
{
JSSLOT_DEBUG_PROTO_START
JSSLOT_DEBUG_FRAME_PROTO
=
JSSLOT_DEBUG_PROTO_START
JSSLOT_DEBUG_ENV_PROTO
JSSLOT_DEBUG_OBJECT_PROTO
JSSLOT_DEBUG_SCRIPT_PROTO
JSSLOT_DEBUG_SOURCE_PROTO
JSSLOT_DEBUG_MEMORY_PROTO
JSSLOT_DEBUG_PROTO_STOP
JSSLOT_DEBUG_HOOK_START
=
JSSLOT_DEBUG_PROTO_STOP
JSSLOT_DEBUG_HOOK_STOP
=
JSSLOT_DEBUG_HOOK_START
+
HookCount
JSSLOT_DEBUG_MEMORY_INSTANCE
=
JSSLOT_DEBUG_HOOK_STOP
JSSLOT_DEBUG_COUNT
}
;
class
ExecutionObservableSet
{
public
:
typedef
HashSet
<
Zone
*
>
:
:
Range
ZoneRange
;
virtual
Zone
*
singleZone
(
)
const
{
return
nullptr
;
}
virtual
JSScript
*
singleScriptForZoneInvalidation
(
)
const
{
return
nullptr
;
}
virtual
const
HashSet
<
Zone
*
>
*
zones
(
)
const
{
return
nullptr
;
}
virtual
bool
shouldRecompileOrInvalidate
(
JSScript
*
script
)
const
=
0
;
virtual
bool
shouldMarkAsDebuggee
(
ScriptFrameIter
&
iter
)
const
=
0
;
}
;
enum
IsObserving
{
NotObserving
=
0
Observing
=
1
}
;
bool
isDebuggeeUnbarriered
(
const
JSCompartment
*
compartment
)
const
;
bool
observedGC
(
uint64_t
majorGCNumber
)
const
{
return
observedGCs
.
has
(
majorGCNumber
)
;
}
bool
debuggeeIsBeingCollected
(
uint64_t
majorGCNumber
)
{
return
observedGCs
.
put
(
majorGCNumber
)
;
}
bool
isEnabled
(
)
const
{
return
enabled
;
}
static
SavedFrame
*
getObjectAllocationSite
(
JSObject
&
obj
)
;
struct
AllocationsLogEntry
{
AllocationsLogEntry
(
HandleObject
frame
double
when
const
char
*
className
HandleAtom
ctorName
size_t
size
bool
inNursery
)
:
frame
(
frame
)
when
(
when
)
className
(
className
)
ctorName
(
ctorName
)
size
(
size
)
inNursery
(
inNursery
)
{
MOZ_ASSERT_IF
(
frame
UncheckedUnwrap
(
frame
)
-
>
is
<
SavedFrame
>
(
)
)
;
}
;
RelocatablePtrObject
frame
;
double
when
;
const
char
*
className
;
RelocatablePtrAtom
ctorName
;
size_t
size
;
bool
inNursery
;
void
trace
(
JSTracer
*
trc
)
{
TraceNullableEdge
(
trc
&
frame
"
Debugger
:
:
AllocationsLogEntry
:
:
frame
"
)
;
TraceNullableEdge
(
trc
&
ctorName
"
Debugger
:
:
AllocationsLogEntry
:
:
ctorName
"
)
;
}
}
;
static
void
readBarrier
(
Debugger
*
dbg
)
{
InternalBarrierMethods
<
JSObject
*
>
:
:
readBarrier
(
dbg
-
>
object
)
;
}
static
void
writeBarrierPost
(
Debugger
*
*
vp
Debugger
*
prev
Debugger
*
next
)
{
}
private
:
GCPtrNativeObject
object
;
WeakGlobalObjectSet
debuggees
;
JS
:
:
ZoneSet
debuggeeZones
;
js
:
:
GCPtrObject
uncaughtExceptionHook
;
bool
enabled
;
bool
allowUnobservedAsmJS
;
bool
collectCoverageInfo
;
JSCList
breakpoints
;
using
GCNumberSet
=
HashSet
<
uint64_t
DefaultHasher
<
uint64_t
>
RuntimeAllocPolicy
>
;
GCNumberSet
observedGCs
;
using
AllocationsLog
=
js
:
:
TraceableFifo
<
AllocationsLogEntry
>
;
AllocationsLog
allocationsLog
;
bool
trackingAllocationSites
;
double
allocationSamplingProbability
;
size_t
maxAllocationsLogLength
;
bool
allocationsLogOverflowed
;
static
const
size_t
DEFAULT_MAX_LOG_LENGTH
=
5000
;
bool
appendAllocationSite
(
JSContext
*
cx
HandleObject
obj
HandleSavedFrame
frame
double
when
)
;
void
recomputeDebuggeeZoneSet
(
)
;
static
bool
cannotTrackAllocations
(
const
GlobalObject
&
global
)
;
static
bool
isObservedByDebuggerTrackingAllocations
(
const
GlobalObject
&
global
)
;
static
bool
addAllocationsTracking
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
debuggee
)
;
static
void
removeAllocationsTracking
(
GlobalObject
&
global
)
;
bool
addAllocationsTrackingForAllDebuggees
(
JSContext
*
cx
)
;
void
removeAllocationsTrackingForAllDebuggees
(
)
;
JSCList
onNewGlobalObjectWatchersLink
;
typedef
HashMap
<
AbstractFramePtr
RelocatablePtrNativeObject
DefaultHasher
<
AbstractFramePtr
>
RuntimeAllocPolicy
>
FrameMap
;
FrameMap
frames
;
typedef
DebuggerWeakMap
<
JSScript
*
>
ScriptWeakMap
;
ScriptWeakMap
scripts
;
typedef
DebuggerWeakMap
<
JSObject
*
true
>
SourceWeakMap
;
SourceWeakMap
sources
;
typedef
DebuggerWeakMap
<
JSObject
*
>
ObjectWeakMap
;
ObjectWeakMap
objects
;
ObjectWeakMap
environments
;
typedef
DebuggerWeakMap
<
WasmModuleObject
*
>
WasmModuleWeakMap
;
WasmModuleWeakMap
wasmModuleScripts
;
WasmModuleWeakMap
wasmModuleSources
;
#
ifdef
NIGHTLY_BUILD
uint32_t
traceLoggerLastDrainedSize
;
uint32_t
traceLoggerLastDrainedIteration
;
#
endif
uint32_t
traceLoggerScriptedCallsLastDrainedSize
;
uint32_t
traceLoggerScriptedCallsLastDrainedIteration
;
class
ScriptQuery
;
class
ObjectQuery
;
bool
addDebuggeeGlobal
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
obj
)
;
void
removeDebuggeeGlobal
(
FreeOp
*
fop
GlobalObject
*
global
WeakGlobalObjectSet
:
:
Enum
*
debugEnum
)
;
JSTrapStatus
handleUncaughtException
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
bool
callHook
)
;
JSTrapStatus
handleUncaughtException
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
MutableHandleValue
vp
bool
callHook
const
mozilla
:
:
Maybe
<
HandleValue
>
&
thisVForCheck
=
mozilla
:
:
Nothing
(
)
AbstractFramePtr
frame
=
NullFramePtr
(
)
)
;
JSTrapStatus
handleUncaughtExceptionHelper
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
MutableHandleValue
*
vp
bool
callHook
const
mozilla
:
:
Maybe
<
HandleValue
>
&
thisVForCheck
AbstractFramePtr
frame
)
;
JSTrapStatus
parseResumptionValue
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
bool
OK
const
Value
&
rv
AbstractFramePtr
frame
jsbytecode
*
pc
MutableHandleValue
vp
bool
callHook
=
true
)
;
JSTrapStatus
parseResumptionValue
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
bool
OK
const
Value
&
rv
const
Value
&
thisVForCheck
AbstractFramePtr
frame
MutableHandleValue
vp
bool
callHook
=
true
)
;
JSTrapStatus
parseResumptionValueHelper
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
bool
ok
const
Value
&
rv
const
mozilla
:
:
Maybe
<
HandleValue
>
&
thisVForCheck
AbstractFramePtr
frame
MutableHandleValue
vp
bool
callHook
)
;
GlobalObject
*
unwrapDebuggeeArgument
(
JSContext
*
cx
const
Value
&
v
)
;
static
void
traceObject
(
JSTracer
*
trc
JSObject
*
obj
)
;
void
trace
(
JSTracer
*
trc
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
void
markCrossCompartmentEdges
(
JSTracer
*
tracer
)
;
static
const
ClassOps
classOps_
;
static
const
Class
class_
;
static
bool
getHookImpl
(
JSContext
*
cx
CallArgs
&
args
Debugger
&
dbg
Hook
which
)
;
static
bool
setHookImpl
(
JSContext
*
cx
CallArgs
&
args
Debugger
&
dbg
Hook
which
)
;
static
Debugger
*
fromThisValue
(
JSContext
*
cx
const
CallArgs
&
ca
const
char
*
fnname
)
;
static
bool
getEnabled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setEnabled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnDebuggerStatement
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnDebuggerStatement
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnExceptionUnwind
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnExceptionUnwind
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnNewScript
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnNewScript
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnEnterFrame
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnEnterFrame
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnNewGlobalObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnNewGlobalObject
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnNewPromise
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnNewPromise
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getOnPromiseSettled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setOnPromiseSettled
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getUncaughtExceptionHook
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setUncaughtExceptionHook
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getAllowUnobservedAsmJS
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setAllowUnobservedAsmJS
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getCollectCoverageInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setCollectCoverageInfo
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getMemory
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
addDebuggee
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
addAllGlobalsAsDebuggees
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
removeDebuggee
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
removeAllDebuggees
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
hasDebuggee
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getDebuggees
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getNewestFrame
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
clearAllBreakpoints
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
findScripts
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
findObjects
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
findAllGlobals
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
makeGlobalObjectReference
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setupTraceLoggerScriptCalls
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
drainTraceLoggerScriptCalls
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
startTraceLogger
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
endTraceLogger
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
isCompilableUnit
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
#
ifdef
NIGHTLY_BUILD
static
bool
setupTraceLogger
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
drainTraceLogger
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
#
endif
static
bool
adoptDebuggeeValue
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
void
removeFromFrameMapsAndClearBreakpointsIn
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
bool
updateExecutionObservabilityOfFrames
(
JSContext
*
cx
const
ExecutionObservableSet
&
obs
IsObserving
observing
)
;
static
bool
updateExecutionObservabilityOfScripts
(
JSContext
*
cx
const
ExecutionObservableSet
&
obs
IsObserving
observing
)
;
static
bool
updateExecutionObservability
(
JSContext
*
cx
ExecutionObservableSet
&
obs
IsObserving
observing
)
;
template
<
typename
FrameFn
>
static
void
forEachDebuggerFrame
(
AbstractFramePtr
frame
FrameFn
fn
)
;
using
DebuggerFrameVector
=
GCVector
<
NativeObject
*
>
;
static
bool
getDebuggerFrames
(
AbstractFramePtr
frame
MutableHandle
<
DebuggerFrameVector
>
frames
)
;
public
:
static
bool
ensureExecutionObservabilityOfOsrFrame
(
JSContext
*
cx
InterpreterFrame
*
frame
)
;
static
bool
ensureExecutionObservabilityOfScript
(
JSContext
*
cx
JSScript
*
script
)
;
IsObserving
observesAllExecution
(
)
const
;
IsObserving
observesAsmJS
(
)
const
;
IsObserving
observesCoverage
(
)
const
;
private
:
static
bool
ensureExecutionObservabilityOfFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
bool
ensureExecutionObservabilityOfCompartment
(
JSContext
*
cx
JSCompartment
*
comp
)
;
static
bool
hookObservesAllExecution
(
Hook
which
)
;
bool
updateObservesAllExecutionOnDebuggees
(
JSContext
*
cx
IsObserving
observing
)
;
bool
updateObservesCoverageOnDebuggees
(
JSContext
*
cx
IsObserving
observing
)
;
void
updateObservesAsmJSOnDebuggees
(
IsObserving
observing
)
;
JSObject
*
getHook
(
Hook
hook
)
const
;
bool
hasAnyLiveHooks
(
)
const
;
static
bool
slowPathCheckNoExecute
(
JSContext
*
cx
HandleScript
script
)
;
static
JSTrapStatus
slowPathOnEnterFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
bool
slowPathOnLeaveFrame
(
JSContext
*
cx
AbstractFramePtr
frame
jsbytecode
*
pc
bool
ok
)
;
static
JSTrapStatus
slowPathOnDebuggerStatement
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
JSTrapStatus
slowPathOnExceptionUnwind
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
void
slowPathOnNewScript
(
JSContext
*
cx
HandleScript
script
)
;
static
void
slowPathOnNewWasmModule
(
JSContext
*
cx
Handle
<
WasmModuleObject
*
>
wasmModule
)
;
static
void
slowPathOnNewGlobalObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
bool
slowPathOnLogAllocationSite
(
JSContext
*
cx
HandleObject
obj
HandleSavedFrame
frame
double
when
GlobalObject
:
:
DebuggerVector
&
dbgs
)
;
static
void
slowPathPromiseHook
(
JSContext
*
cx
Hook
hook
HandleObject
promise
)
;
template
<
typename
HookIsEnabledFun
typename
FireHookFun
>
static
JSTrapStatus
dispatchHook
(
JSContext
*
cx
HookIsEnabledFun
hookIsEnabled
FireHookFun
fireHook
)
;
JSTrapStatus
fireDebuggerStatement
(
JSContext
*
cx
MutableHandleValue
vp
)
;
JSTrapStatus
fireExceptionUnwind
(
JSContext
*
cx
MutableHandleValue
vp
)
;
JSTrapStatus
fireEnterFrame
(
JSContext
*
cx
AbstractFramePtr
frame
MutableHandleValue
vp
)
;
JSTrapStatus
fireNewGlobalObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
MutableHandleValue
vp
)
;
JSTrapStatus
firePromiseHook
(
JSContext
*
cx
Hook
hook
HandleObject
promise
MutableHandleValue
vp
)
;
NativeObject
*
newVariantWrapper
(
JSContext
*
cx
Handle
<
DebuggerScriptReferent
>
referent
)
{
return
newDebuggerScript
(
cx
referent
)
;
}
NativeObject
*
newVariantWrapper
(
JSContext
*
cx
Handle
<
DebuggerSourceReferent
>
referent
)
{
return
newDebuggerSource
(
cx
referent
)
;
}
template
<
typename
ReferentVariant
typename
Referent
typename
Map
>
JSObject
*
wrapVariantReferent
(
JSContext
*
cx
Map
&
map
Handle
<
CrossCompartmentKey
>
key
Handle
<
ReferentVariant
>
referent
)
;
JSObject
*
wrapVariantReferent
(
JSContext
*
cx
Handle
<
DebuggerScriptReferent
>
referent
)
;
JSObject
*
wrapVariantReferent
(
JSContext
*
cx
Handle
<
DebuggerSourceReferent
>
referent
)
;
NativeObject
*
newDebuggerScript
(
JSContext
*
cx
Handle
<
DebuggerScriptReferent
>
referent
)
;
NativeObject
*
newDebuggerSource
(
JSContext
*
cx
Handle
<
DebuggerSourceReferent
>
referent
)
;
void
fireNewScript
(
JSContext
*
cx
Handle
<
DebuggerScriptReferent
>
scriptReferent
)
;
void
fireOnGarbageCollectionHook
(
JSContext
*
cx
const
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Ptr
&
gcData
)
;
bool
getScriptFrameWithIter
(
JSContext
*
cx
AbstractFramePtr
frame
const
ScriptFrameIter
*
maybeIter
MutableHandleValue
vp
)
;
inline
Breakpoint
*
firstBreakpoint
(
)
const
;
static
inline
Debugger
*
fromOnNewGlobalObjectWatchersLink
(
JSCList
*
link
)
;
static
bool
replaceFrameGuts
(
JSContext
*
cx
AbstractFramePtr
from
AbstractFramePtr
to
ScriptFrameIter
&
iter
)
;
public
:
Debugger
(
JSContext
*
cx
NativeObject
*
dbg
)
;
~
Debugger
(
)
;
bool
init
(
JSContext
*
cx
)
;
inline
const
js
:
:
GCPtrNativeObject
&
toJSObject
(
)
const
;
inline
js
:
:
GCPtrNativeObject
&
toJSObjectRef
(
)
;
static
inline
Debugger
*
fromJSObject
(
const
JSObject
*
obj
)
;
static
Debugger
*
fromChildJSObject
(
JSObject
*
obj
)
;
bool
hasMemory
(
)
const
;
DebuggerMemory
&
memory
(
)
const
;
WeakGlobalObjectSet
:
:
Range
allDebuggees
(
)
const
{
return
debuggees
.
all
(
)
;
}
static
void
markIncomingCrossCompartmentEdges
(
JSTracer
*
tracer
)
;
static
bool
markAllIteratively
(
GCMarker
*
trc
)
;
static
void
markAll
(
JSTracer
*
trc
)
;
static
void
sweepAll
(
FreeOp
*
fop
)
;
static
void
detachAllDebuggersFromGlobal
(
FreeOp
*
fop
GlobalObject
*
global
)
;
static
void
findZoneEdges
(
JS
:
:
Zone
*
v
gc
:
:
ZoneComponentFinder
&
finder
)
;
static
inline
bool
checkNoExecute
(
JSContext
*
cx
HandleScript
script
)
;
static
inline
JSTrapStatus
onEnterFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
inline
JSTrapStatus
onDebuggerStatement
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
inline
JSTrapStatus
onExceptionUnwind
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
inline
bool
onLeaveFrame
(
JSContext
*
cx
AbstractFramePtr
frame
jsbytecode
*
pc
bool
ok
)
;
static
inline
void
onNewScript
(
JSContext
*
cx
HandleScript
script
)
;
static
inline
void
onNewWasmModule
(
JSContext
*
cx
Handle
<
WasmModuleObject
*
>
wasmModule
)
;
static
inline
void
onNewGlobalObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
;
static
inline
bool
onLogAllocationSite
(
JSContext
*
cx
JSObject
*
obj
HandleSavedFrame
frame
double
when
)
;
static
JSTrapStatus
onTrap
(
JSContext
*
cx
MutableHandleValue
vp
)
;
static
JSTrapStatus
onSingleStep
(
JSContext
*
cx
MutableHandleValue
vp
)
;
static
bool
handleBaselineOsr
(
JSContext
*
cx
InterpreterFrame
*
from
jit
:
:
BaselineFrame
*
to
)
;
static
bool
handleIonBailout
(
JSContext
*
cx
jit
:
:
RematerializedFrame
*
from
jit
:
:
BaselineFrame
*
to
)
;
static
void
handleUnrecoverableIonBailoutError
(
JSContext
*
cx
jit
:
:
RematerializedFrame
*
frame
)
;
static
void
propagateForcedReturn
(
JSContext
*
cx
AbstractFramePtr
frame
HandleValue
rval
)
;
static
bool
hasLiveHook
(
GlobalObject
*
global
Hook
which
)
;
static
bool
inFrameMaps
(
AbstractFramePtr
frame
)
;
inline
bool
observesEnterFrame
(
)
const
;
inline
bool
observesNewScript
(
)
const
;
inline
bool
observesNewGlobalObject
(
)
const
;
inline
bool
observesGlobal
(
GlobalObject
*
global
)
const
;
bool
observesFrame
(
AbstractFramePtr
frame
)
const
;
bool
observesFrame
(
const
ScriptFrameIter
&
iter
)
const
;
bool
observesScript
(
JSScript
*
script
)
const
;
bool
wrapEnvironment
(
JSContext
*
cx
Handle
<
Env
*
>
env
MutableHandleValue
vp
)
;
bool
wrapDebuggeeValue
(
JSContext
*
cx
MutableHandleValue
vp
)
;
bool
unwrapDebuggeeValue
(
JSContext
*
cx
MutableHandleValue
vp
)
;
bool
unwrapDebuggeeObject
(
JSContext
*
cx
MutableHandleObject
obj
)
;
bool
unwrapPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
MutableHandle
<
PropertyDescriptor
>
desc
)
;
bool
getScriptFrame
(
JSContext
*
cx
AbstractFramePtr
frame
MutableHandleValue
vp
)
{
return
getScriptFrameWithIter
(
cx
frame
nullptr
vp
)
;
}
bool
getScriptFrame
(
JSContext
*
cx
const
ScriptFrameIter
&
iter
MutableHandleValue
vp
)
{
return
getScriptFrameWithIter
(
cx
iter
.
abstractFramePtr
(
)
&
iter
vp
)
;
}
static
void
resultToCompletion
(
JSContext
*
cx
bool
ok
const
Value
&
rv
JSTrapStatus
*
status
MutableHandleValue
value
)
;
bool
newCompletionValue
(
JSContext
*
cx
JSTrapStatus
status
Value
value
MutableHandleValue
result
)
;
bool
receiveCompletionValue
(
mozilla
:
:
Maybe
<
AutoCompartment
>
&
ac
bool
ok
HandleValue
val
MutableHandleValue
vp
)
;
JSObject
*
wrapScript
(
JSContext
*
cx
HandleScript
script
)
;
JSObject
*
wrapWasmScript
(
JSContext
*
cx
Handle
<
WasmModuleObject
*
>
wasmModule
)
;
JSObject
*
wrapSource
(
JSContext
*
cx
js
:
:
HandleScriptSource
source
)
;
JSObject
*
wrapWasmSource
(
JSContext
*
cx
Handle
<
WasmModuleObject
*
>
wasmModule
)
;
private
:
Debugger
(
const
Debugger
&
)
=
delete
;
Debugger
&
operator
=
(
const
Debugger
&
)
=
delete
;
}
;
class
DebuggerObject
:
public
NativeObject
{
public
:
static
const
Class
class_
;
static
NativeObject
*
initClass
(
JSContext
*
cx
HandleObject
obj
HandleObject
debugCtor
)
;
static
DebuggerObject
*
create
(
JSContext
*
cx
HandleObject
proto
HandleObject
obj
HandleNativeObject
debugger
)
;
static
bool
isExtensible
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
bool
&
result
)
;
static
bool
isSealed
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
bool
&
result
)
;
static
bool
isFrozen
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
bool
&
result
)
;
static
bool
getOwnPropertyNames
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
MutableHandle
<
IdVector
>
result
)
;
static
bool
getOwnPropertySymbols
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
MutableHandle
<
IdVector
>
result
)
;
static
bool
getOwnPropertyDescriptor
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
;
static
bool
preventExtensions
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
)
;
static
bool
seal
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
)
;
static
bool
freeze
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
)
;
static
bool
defineProperty
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
HandleId
id
Handle
<
PropertyDescriptor
>
desc
)
;
static
bool
defineProperties
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
Handle
<
IdVector
>
ids
Handle
<
PropertyDescriptorVector
>
descs
)
;
static
bool
deleteProperty
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
HandleId
id
ObjectOpResult
&
result
)
;
static
bool
call
(
JSContext
*
cx
Handle
<
DebuggerObject
*
>
object
HandleValue
thisv
Handle
<
ValueVector
>
args
MutableHandleValue
result
)
;
private
:
enum
{
OWNER_SLOT
}
;
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSPropertySpec
properties_
[
]
;
#
ifdef
SPIDERMONKEY_PROMISE
static
const
JSPropertySpec
promiseProperties_
[
]
;
#
endif
static
const
JSFunctionSpec
methods_
[
]
;
JSObject
*
referent
(
)
const
{
JSObject
*
obj
=
(
JSObject
*
)
getPrivate
(
)
;
MOZ_ASSERT
(
obj
)
;
return
obj
;
}
Debugger
*
owner
(
)
const
;
}
;
class
BreakpointSite
{
friend
class
Breakpoint
;
friend
struct
:
:
JSCompartment
;
friend
class
:
:
JSScript
;
friend
class
Debugger
;
public
:
JSScript
*
script
;
jsbytecode
*
const
pc
;
private
:
JSCList
breakpoints
;
size_t
enabledCount
;
void
recompile
(
FreeOp
*
fop
)
;
public
:
BreakpointSite
(
JSScript
*
script
jsbytecode
*
pc
)
;
Breakpoint
*
firstBreakpoint
(
)
const
;
bool
hasBreakpoint
(
Breakpoint
*
bp
)
;
void
inc
(
FreeOp
*
fop
)
;
void
dec
(
FreeOp
*
fop
)
;
void
destroyIfEmpty
(
FreeOp
*
fop
)
;
}
;
class
Breakpoint
{
friend
struct
:
:
JSCompartment
;
friend
class
Debugger
;
public
:
Debugger
*
const
debugger
;
BreakpointSite
*
const
site
;
private
:
js
:
:
PreBarrieredObject
handler
;
JSCList
debuggerLinks
;
JSCList
siteLinks
;
public
:
static
Breakpoint
*
fromDebuggerLinks
(
JSCList
*
links
)
;
static
Breakpoint
*
fromSiteLinks
(
JSCList
*
links
)
;
Breakpoint
(
Debugger
*
debugger
BreakpointSite
*
site
JSObject
*
handler
)
;
void
destroy
(
FreeOp
*
fop
)
;
Breakpoint
*
nextInDebugger
(
)
;
Breakpoint
*
nextInSite
(
)
;
const
PreBarrieredObject
&
getHandler
(
)
const
{
return
handler
;
}
PreBarrieredObject
&
getHandlerRef
(
)
{
return
handler
;
}
}
;
Breakpoint
*
Debugger
:
:
firstBreakpoint
(
)
const
{
if
(
JS_CLIST_IS_EMPTY
(
&
breakpoints
)
)
return
nullptr
;
return
Breakpoint
:
:
fromDebuggerLinks
(
JS_NEXT_LINK
(
&
breakpoints
)
)
;
}
Debugger
*
Debugger
:
:
fromOnNewGlobalObjectWatchersLink
(
JSCList
*
link
)
{
char
*
p
=
reinterpret_cast
<
char
*
>
(
link
)
;
return
reinterpret_cast
<
Debugger
*
>
(
p
-
offsetof
(
Debugger
onNewGlobalObjectWatchersLink
)
)
;
}
const
js
:
:
GCPtrNativeObject
&
Debugger
:
:
toJSObject
(
)
const
{
MOZ_ASSERT
(
object
)
;
return
object
;
}
js
:
:
GCPtrNativeObject
&
Debugger
:
:
toJSObjectRef
(
)
{
MOZ_ASSERT
(
object
)
;
return
object
;
}
bool
Debugger
:
:
observesEnterFrame
(
)
const
{
return
enabled
&
&
getHook
(
OnEnterFrame
)
;
}
bool
Debugger
:
:
observesNewScript
(
)
const
{
return
enabled
&
&
getHook
(
OnNewScript
)
;
}
bool
Debugger
:
:
observesNewGlobalObject
(
)
const
{
return
enabled
&
&
getHook
(
OnNewGlobalObject
)
;
}
bool
Debugger
:
:
observesGlobal
(
GlobalObject
*
global
)
const
{
ReadBarriered
<
GlobalObject
*
>
debuggee
(
global
)
;
return
debuggees
.
has
(
debuggee
)
;
}
void
Debugger
:
:
onNewScript
(
JSContext
*
cx
HandleScript
script
)
{
MOZ_ASSERT_IF
(
!
script
-
>
compartment
(
)
-
>
creationOptions
(
)
.
invisibleToDebugger
(
)
&
&
!
script
-
>
selfHosted
(
)
script
-
>
compartment
(
)
-
>
firedOnNewGlobalObject
)
;
if
(
script
-
>
compartment
(
)
-
>
isDebuggee
(
)
)
slowPathOnNewScript
(
cx
script
)
;
}
void
Debugger
:
:
onNewGlobalObject
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
)
{
MOZ_ASSERT
(
!
global
-
>
compartment
(
)
-
>
firedOnNewGlobalObject
)
;
#
ifdef
DEBUG
global
-
>
compartment
(
)
-
>
firedOnNewGlobalObject
=
true
;
#
endif
if
(
!
JS_CLIST_IS_EMPTY
(
&
cx
-
>
runtime
(
)
-
>
onNewGlobalObjectWatchers
)
)
Debugger
:
:
slowPathOnNewGlobalObject
(
cx
global
)
;
}
bool
Debugger
:
:
onLogAllocationSite
(
JSContext
*
cx
JSObject
*
obj
HandleSavedFrame
frame
double
when
)
{
GlobalObject
:
:
DebuggerVector
*
dbgs
=
cx
-
>
global
(
)
-
>
getDebuggers
(
)
;
if
(
!
dbgs
|
|
dbgs
-
>
empty
(
)
)
return
true
;
RootedObject
hobj
(
cx
obj
)
;
return
Debugger
:
:
slowPathOnLogAllocationSite
(
cx
hobj
frame
when
*
dbgs
)
;
}
bool
ReportObjectRequired
(
JSContext
*
cx
)
;
}
#
endif
