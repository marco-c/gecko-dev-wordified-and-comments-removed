#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
MaybeRooted
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
EqualityOperations
.
h
"
#
include
"
vm
/
GetterSetter
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
vm
/
ArrayObject
-
inl
.
h
"
#
include
"
vm
/
BytecodeLocation
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
AutoCheckCannotGC
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
RoundUpPow2
;
struct
EmptyObjectElements
{
const
ObjectElements
emptyElementsHeader
;
const
Value
val
;
public
:
constexpr
EmptyObjectElements
(
)
:
emptyElementsHeader
(
0
0
)
val
(
UndefinedValue
(
)
)
{
}
explicit
constexpr
EmptyObjectElements
(
ObjectElements
:
:
SharedMemory
shmem
)
:
emptyElementsHeader
(
0
0
shmem
)
val
(
UndefinedValue
(
)
)
{
}
}
;
static
constexpr
EmptyObjectElements
emptyElementsHeader
;
HeapSlot
*
const
js
:
:
emptyObjectElements
=
reinterpret_cast
<
HeapSlot
*
>
(
uintptr_t
(
&
emptyElementsHeader
)
+
sizeof
(
ObjectElements
)
)
;
static
constexpr
EmptyObjectElements
emptyElementsHeaderShared
(
ObjectElements
:
:
SharedMemory
:
:
IsShared
)
;
HeapSlot
*
const
js
:
:
emptyObjectElementsShared
=
reinterpret_cast
<
HeapSlot
*
>
(
uintptr_t
(
&
emptyElementsHeaderShared
)
+
sizeof
(
ObjectElements
)
)
;
struct
EmptyObjectSlots
:
public
ObjectSlots
{
explicit
constexpr
EmptyObjectSlots
(
size_t
dictionarySlotSpan
)
:
ObjectSlots
(
0
dictionarySlotSpan
)
{
}
}
;
static
constexpr
EmptyObjectSlots
emptyObjectSlotsHeaders
[
17
]
=
{
EmptyObjectSlots
(
0
)
EmptyObjectSlots
(
1
)
EmptyObjectSlots
(
2
)
EmptyObjectSlots
(
3
)
EmptyObjectSlots
(
4
)
EmptyObjectSlots
(
5
)
EmptyObjectSlots
(
6
)
EmptyObjectSlots
(
7
)
EmptyObjectSlots
(
8
)
EmptyObjectSlots
(
9
)
EmptyObjectSlots
(
10
)
EmptyObjectSlots
(
11
)
EmptyObjectSlots
(
12
)
EmptyObjectSlots
(
13
)
EmptyObjectSlots
(
14
)
EmptyObjectSlots
(
15
)
EmptyObjectSlots
(
16
)
}
;
static_assert
(
std
:
:
size
(
emptyObjectSlotsHeaders
)
=
=
NativeObject
:
:
MAX_FIXED_SLOTS
+
1
)
;
HeapSlot
*
const
js
:
:
emptyObjectSlotsForDictionaryObject
[
17
]
=
{
emptyObjectSlotsHeaders
[
0
]
.
slots
(
)
emptyObjectSlotsHeaders
[
1
]
.
slots
(
)
emptyObjectSlotsHeaders
[
2
]
.
slots
(
)
emptyObjectSlotsHeaders
[
3
]
.
slots
(
)
emptyObjectSlotsHeaders
[
4
]
.
slots
(
)
emptyObjectSlotsHeaders
[
5
]
.
slots
(
)
emptyObjectSlotsHeaders
[
6
]
.
slots
(
)
emptyObjectSlotsHeaders
[
7
]
.
slots
(
)
emptyObjectSlotsHeaders
[
8
]
.
slots
(
)
emptyObjectSlotsHeaders
[
9
]
.
slots
(
)
emptyObjectSlotsHeaders
[
10
]
.
slots
(
)
emptyObjectSlotsHeaders
[
11
]
.
slots
(
)
emptyObjectSlotsHeaders
[
12
]
.
slots
(
)
emptyObjectSlotsHeaders
[
13
]
.
slots
(
)
emptyObjectSlotsHeaders
[
14
]
.
slots
(
)
emptyObjectSlotsHeaders
[
15
]
.
slots
(
)
emptyObjectSlotsHeaders
[
16
]
.
slots
(
)
}
;
static_assert
(
std
:
:
size
(
emptyObjectSlotsForDictionaryObject
)
=
=
NativeObject
:
:
MAX_FIXED_SLOTS
+
1
)
;
HeapSlot
*
const
js
:
:
emptyObjectSlots
=
emptyObjectSlotsForDictionaryObject
[
0
]
;
#
ifdef
DEBUG
bool
NativeObject
:
:
canHaveNonEmptyElements
(
)
{
return
!
this
-
>
is
<
TypedArrayObject
>
(
)
;
}
#
endif
void
ObjectElements
:
:
PrepareForPreventExtensions
(
JSContext
*
cx
NativeObject
*
obj
)
{
if
(
!
obj
-
>
hasEmptyElements
(
)
)
{
obj
-
>
shrinkCapacityToInitializedLength
(
cx
)
;
}
MOZ_ASSERT
(
obj
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
=
=
0
)
;
}
void
ObjectElements
:
:
PreventExtensions
(
NativeObject
*
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
isExtensible
(
)
)
;
MOZ_ASSERT
(
obj
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
=
=
0
)
;
MOZ_ASSERT
(
obj
-
>
getDenseInitializedLength
(
)
=
=
obj
-
>
getDenseCapacity
(
)
)
;
if
(
!
obj
-
>
hasEmptyElements
(
)
)
{
obj
-
>
getElementsHeader
(
)
-
>
setNotExtensible
(
)
;
}
}
bool
ObjectElements
:
:
FreezeOrSeal
(
JSContext
*
cx
HandleNativeObject
obj
IntegrityLevel
level
)
{
MOZ_ASSERT_IF
(
level
=
=
IntegrityLevel
:
:
Frozen
&
&
obj
-
>
is
<
ArrayObject
>
(
)
!
obj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
isExtensible
(
)
)
;
MOZ_ASSERT
(
obj
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
=
=
0
)
;
if
(
obj
-
>
hasEmptyElements
(
)
|
|
obj
-
>
denseElementsAreFrozen
(
)
)
{
return
true
;
}
if
(
level
=
=
IntegrityLevel
:
:
Frozen
)
{
if
(
!
JSObject
:
:
setFlag
(
cx
obj
ObjectFlag
:
:
FrozenElements
JSObject
:
:
GENERATE_SHAPE
)
)
{
return
false
;
}
}
if
(
!
obj
-
>
denseElementsAreSealed
(
)
)
{
obj
-
>
getElementsHeader
(
)
-
>
seal
(
)
;
}
if
(
level
=
=
IntegrityLevel
:
:
Frozen
)
{
obj
-
>
getElementsHeader
(
)
-
>
freeze
(
)
;
}
return
true
;
}
#
ifdef
DEBUG
static
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
gShapeConsistencyChecksEnabled
(
false
)
;
void
js
:
:
NativeObject
:
:
enableShapeConsistencyChecks
(
)
{
gShapeConsistencyChecksEnabled
=
true
;
}
void
js
:
:
NativeObject
:
:
checkShapeConsistency
(
)
{
if
(
!
gShapeConsistencyChecksEnabled
)
{
return
;
}
MOZ_ASSERT
(
is
<
NativeObject
>
(
)
)
;
Shape
*
shape
=
lastProperty
(
)
;
Shape
*
prev
=
nullptr
;
AutoCheckCannotGC
nogc
;
if
(
inDictionaryMode
(
)
)
{
if
(
ShapeTable
*
table
=
shape
-
>
maybeTable
(
nogc
)
)
{
for
(
uint32_t
fslot
=
table
-
>
freeList
(
)
;
fslot
!
=
SHAPE_INVALID_SLOT
;
fslot
=
getSlot
(
fslot
)
.
toPrivateUint32
(
)
)
{
MOZ_ASSERT
(
fslot
<
slotSpan
(
)
)
;
}
while
(
shape
-
>
parent
)
{
MOZ_ASSERT_IF
(
lastProperty
(
)
!
=
shape
!
shape
-
>
hasTable
(
)
)
;
ShapeTable
:
:
Entry
&
entry
=
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
shape
-
>
propid
(
)
nogc
)
;
MOZ_ASSERT
(
entry
.
shape
(
)
=
=
shape
)
;
shape
=
shape
-
>
parent
;
}
}
shape
=
lastProperty
(
)
;
while
(
shape
)
{
MOZ_ASSERT_IF
(
!
shape
-
>
isEmptyShape
(
)
&
&
shape
-
>
hasSlot
(
)
shape
-
>
slot
(
)
<
slotSpan
(
)
)
;
if
(
!
prev
)
{
MOZ_ASSERT
(
lastProperty
(
)
=
=
shape
)
;
MOZ_ASSERT
(
shape
-
>
dictNext
.
toObject
(
)
=
=
this
)
;
}
else
{
MOZ_ASSERT
(
shape
-
>
dictNext
.
toShape
(
)
=
=
prev
)
;
}
prev
=
shape
;
shape
=
shape
-
>
parent
;
}
}
else
{
while
(
shape
-
>
parent
)
{
if
(
ShapeTable
*
table
=
shape
-
>
maybeTable
(
nogc
)
)
{
MOZ_ASSERT
(
shape
-
>
parent
)
;
for
(
Shape
:
:
Range
<
NoGC
>
r
(
shape
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
ShapeTable
:
:
Entry
&
entry
=
table
-
>
search
<
MaybeAdding
:
:
NotAdding
>
(
r
.
front
(
)
.
propid
(
)
nogc
)
;
MOZ_ASSERT
(
entry
.
shape
(
)
=
=
&
r
.
front
(
)
)
;
}
}
if
(
prev
)
{
MOZ_ASSERT_IF
(
shape
-
>
hasSlot
(
)
prev
-
>
maybeSlot
(
)
>
=
shape
-
>
maybeSlot
(
)
)
;
shape
-
>
children
.
checkHasChild
(
prev
)
;
}
prev
=
shape
;
shape
=
shape
-
>
parent
;
}
}
}
#
endif
void
js
:
:
NativeObject
:
:
initializeSlotRange
(
uint32_t
start
uint32_t
end
)
{
HeapSlot
*
fixedStart
;
HeapSlot
*
fixedEnd
;
HeapSlot
*
slotsStart
;
HeapSlot
*
slotsEnd
;
getSlotRangeUnchecked
(
start
end
&
fixedStart
&
fixedEnd
&
slotsStart
&
slotsEnd
)
;
uint32_t
offset
=
start
;
for
(
HeapSlot
*
sp
=
fixedStart
;
sp
<
fixedEnd
;
sp
+
+
)
{
sp
-
>
init
(
this
HeapSlot
:
:
Slot
offset
+
+
UndefinedValue
(
)
)
;
}
for
(
HeapSlot
*
sp
=
slotsStart
;
sp
<
slotsEnd
;
sp
+
+
)
{
sp
-
>
init
(
this
HeapSlot
:
:
Slot
offset
+
+
UndefinedValue
(
)
)
;
}
}
void
js
:
:
NativeObject
:
:
initSlots
(
const
Value
*
vector
uint32_t
length
)
{
HeapSlot
*
fixedStart
;
HeapSlot
*
fixedEnd
;
HeapSlot
*
slotsStart
;
HeapSlot
*
slotsEnd
;
getSlotRange
(
0
length
&
fixedStart
&
fixedEnd
&
slotsStart
&
slotsEnd
)
;
uint32_t
offset
=
0
;
for
(
HeapSlot
*
sp
=
fixedStart
;
sp
<
fixedEnd
;
sp
+
+
)
{
sp
-
>
init
(
this
HeapSlot
:
:
Slot
offset
+
+
*
vector
+
+
)
;
}
for
(
HeapSlot
*
sp
=
slotsStart
;
sp
<
slotsEnd
;
sp
+
+
)
{
sp
-
>
init
(
this
HeapSlot
:
:
Slot
offset
+
+
*
vector
+
+
)
;
}
}
#
ifdef
DEBUG
bool
js
:
:
NativeObject
:
:
slotInRange
(
uint32_t
slot
SentinelAllowed
sentinel
)
const
{
MOZ_ASSERT
(
!
gc
:
:
IsForwarded
(
lastProperty
(
)
)
)
;
uint32_t
capacity
=
numFixedSlots
(
)
+
numDynamicSlots
(
)
;
if
(
sentinel
=
=
SENTINEL_ALLOWED
)
{
return
slot
<
=
capacity
;
}
return
slot
<
capacity
;
}
bool
js
:
:
NativeObject
:
:
slotIsFixed
(
uint32_t
slot
)
const
{
return
slot
<
numFixedSlotsMaybeForwarded
(
)
;
}
bool
js
:
:
NativeObject
:
:
isNumFixedSlots
(
uint32_t
nfixed
)
const
{
return
nfixed
=
=
numFixedSlotsMaybeForwarded
(
)
;
}
#
endif
mozilla
:
:
Maybe
<
ShapeProperty
>
js
:
:
NativeObject
:
:
lookup
(
JSContext
*
cx
jsid
id
)
{
MOZ_ASSERT
(
is
<
NativeObject
>
(
)
)
;
Shape
*
shape
=
Shape
:
:
search
(
cx
lastProperty
(
)
id
)
;
return
shape
?
mozilla
:
:
Some
(
ShapeProperty
(
shape
)
)
:
mozilla
:
:
Nothing
(
)
;
}
mozilla
:
:
Maybe
<
ShapeProperty
>
js
:
:
NativeObject
:
:
lookupPure
(
jsid
id
)
{
MOZ_ASSERT
(
is
<
NativeObject
>
(
)
)
;
Shape
*
shape
=
Shape
:
:
searchNoHashify
(
lastProperty
(
)
id
)
;
return
shape
?
mozilla
:
:
Some
(
ShapeProperty
(
shape
)
)
:
mozilla
:
:
Nothing
(
)
;
}
bool
NativeObject
:
:
ensureSlotsForDictionaryObject
(
JSContext
*
cx
uint32_t
span
)
{
MOZ_ASSERT
(
inDictionaryMode
(
)
)
;
size_t
oldSpan
=
dictionaryModeSlotSpan
(
)
;
if
(
oldSpan
=
=
span
)
{
return
true
;
}
if
(
!
updateSlotsForSpan
(
cx
oldSpan
span
)
)
{
return
false
;
}
setDictionaryModeSlotSpan
(
span
)
;
return
true
;
}
bool
NativeObject
:
:
growSlots
(
JSContext
*
cx
uint32_t
oldCapacity
uint32_t
newCapacity
)
{
MOZ_ASSERT
(
newCapacity
>
oldCapacity
)
;
MOZ_ASSERT_IF
(
!
is
<
ArrayObject
>
(
)
newCapacity
>
=
SLOT_CAPACITY_MIN
)
;
NativeObject
:
:
slotsSizeMustNotOverflow
(
)
;
MOZ_ASSERT
(
newCapacity
<
=
MAX_SLOTS_COUNT
)
;
if
(
!
hasDynamicSlots
(
)
)
{
return
allocateSlots
(
cx
newCapacity
)
;
}
uint32_t
newAllocated
=
ObjectSlots
:
:
allocCount
(
newCapacity
)
;
uint32_t
dictionarySpan
=
getSlotsHeader
(
)
-
>
dictionarySlotSpan
(
)
;
uint32_t
oldAllocated
=
ObjectSlots
:
:
allocCount
(
oldCapacity
)
;
ObjectSlots
*
oldHeaderSlots
=
ObjectSlots
:
:
fromSlots
(
slots_
)
;
MOZ_ASSERT
(
oldHeaderSlots
-
>
capacity
(
)
=
=
oldCapacity
)
;
HeapSlot
*
allocation
=
ReallocateObjectBuffer
<
HeapSlot
>
(
cx
this
reinterpret_cast
<
HeapSlot
*
>
(
oldHeaderSlots
)
oldAllocated
newAllocated
)
;
if
(
!
allocation
)
{
return
false
;
}
auto
*
newHeaderSlots
=
new
(
allocation
)
ObjectSlots
(
newCapacity
dictionarySpan
)
;
slots_
=
newHeaderSlots
-
>
slots
(
)
;
Debug_SetSlotRangeToCrashOnTouch
(
slots_
+
oldCapacity
newCapacity
-
oldCapacity
)
;
RemoveCellMemory
(
this
ObjectSlots
:
:
allocSize
(
oldCapacity
)
MemoryUse
:
:
ObjectSlots
)
;
AddCellMemory
(
this
ObjectSlots
:
:
allocSize
(
newCapacity
)
MemoryUse
:
:
ObjectSlots
)
;
MOZ_ASSERT
(
hasDynamicSlots
(
)
)
;
return
true
;
}
bool
NativeObject
:
:
allocateSlots
(
JSContext
*
cx
uint32_t
newCapacity
)
{
MOZ_ASSERT
(
!
hasDynamicSlots
(
)
)
;
uint32_t
newAllocated
=
ObjectSlots
:
:
allocCount
(
newCapacity
)
;
uint32_t
dictionarySpan
=
getSlotsHeader
(
)
-
>
dictionarySlotSpan
(
)
;
HeapSlot
*
allocation
=
AllocateObjectBuffer
<
HeapSlot
>
(
cx
this
newAllocated
)
;
if
(
!
allocation
)
{
return
false
;
}
auto
*
newHeaderSlots
=
new
(
allocation
)
ObjectSlots
(
newCapacity
dictionarySpan
)
;
slots_
=
newHeaderSlots
-
>
slots
(
)
;
Debug_SetSlotRangeToCrashOnTouch
(
slots_
newCapacity
)
;
AddCellMemory
(
this
ObjectSlots
:
:
allocSize
(
newCapacity
)
MemoryUse
:
:
ObjectSlots
)
;
MOZ_ASSERT
(
hasDynamicSlots
(
)
)
;
return
true
;
}
bool
NativeObject
:
:
growSlotsPure
(
JSContext
*
cx
NativeObject
*
obj
uint32_t
newCapacity
)
{
AutoUnsafeCallWithABI
unsafe
;
if
(
!
obj
-
>
growSlots
(
cx
obj
-
>
numDynamicSlots
(
)
newCapacity
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
false
;
}
return
true
;
}
bool
NativeObject
:
:
addDenseElementPure
(
JSContext
*
cx
NativeObject
*
obj
)
{
AutoUnsafeCallWithABI
unsafe
;
MOZ_ASSERT
(
obj
-
>
getDenseInitializedLength
(
)
=
=
obj
-
>
getDenseCapacity
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isExtensible
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
isIndexed
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
;
MOZ_ASSERT_IF
(
obj
-
>
is
<
ArrayObject
>
(
)
obj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
;
uint32_t
oldCapacity
=
obj
-
>
getDenseCapacity
(
)
;
if
(
MOZ_UNLIKELY
(
!
obj
-
>
growElements
(
cx
oldCapacity
+
1
)
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
false
;
}
MOZ_ASSERT
(
obj
-
>
getDenseCapacity
(
)
>
oldCapacity
)
;
MOZ_ASSERT
(
obj
-
>
getDenseCapacity
(
)
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
return
true
;
}
static
inline
void
FreeSlots
(
JSContext
*
cx
NativeObject
*
obj
ObjectSlots
*
slots
size_t
nbytes
)
{
if
(
cx
-
>
isHelperThreadContext
(
)
)
{
js_free
(
slots
)
;
}
else
if
(
obj
-
>
isTenured
(
)
)
{
MOZ_ASSERT
(
!
cx
-
>
nursery
(
)
.
isInside
(
slots
)
)
;
js_free
(
slots
)
;
}
else
{
cx
-
>
nursery
(
)
.
freeBuffer
(
slots
nbytes
)
;
}
}
void
NativeObject
:
:
shrinkSlots
(
JSContext
*
cx
uint32_t
oldCapacity
uint32_t
newCapacity
)
{
MOZ_ASSERT
(
newCapacity
<
oldCapacity
)
;
MOZ_ASSERT
(
oldCapacity
=
=
getSlotsHeader
(
)
-
>
capacity
(
)
)
;
uint32_t
dictionarySpan
=
getSlotsHeader
(
)
-
>
dictionarySlotSpan
(
)
;
ObjectSlots
*
oldHeaderSlots
=
ObjectSlots
:
:
fromSlots
(
slots_
)
;
MOZ_ASSERT
(
oldHeaderSlots
-
>
capacity
(
)
=
=
oldCapacity
)
;
uint32_t
oldAllocated
=
ObjectSlots
:
:
allocCount
(
oldCapacity
)
;
if
(
newCapacity
=
=
0
)
{
size_t
nbytes
=
ObjectSlots
:
:
allocSize
(
oldCapacity
)
;
RemoveCellMemory
(
this
nbytes
MemoryUse
:
:
ObjectSlots
)
;
FreeSlots
(
cx
this
oldHeaderSlots
nbytes
)
;
setEmptyDynamicSlots
(
dictionarySpan
)
;
return
;
}
MOZ_ASSERT_IF
(
!
is
<
ArrayObject
>
(
)
newCapacity
>
=
SLOT_CAPACITY_MIN
)
;
uint32_t
newAllocated
=
ObjectSlots
:
:
allocCount
(
newCapacity
)
;
HeapSlot
*
allocation
=
ReallocateObjectBuffer
<
HeapSlot
>
(
cx
this
reinterpret_cast
<
HeapSlot
*
>
(
oldHeaderSlots
)
oldAllocated
newAllocated
)
;
if
(
!
allocation
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
allocation
=
reinterpret_cast
<
HeapSlot
*
>
(
getSlotsHeader
(
)
)
;
}
RemoveCellMemory
(
this
ObjectSlots
:
:
allocSize
(
oldCapacity
)
MemoryUse
:
:
ObjectSlots
)
;
AddCellMemory
(
this
ObjectSlots
:
:
allocSize
(
newCapacity
)
MemoryUse
:
:
ObjectSlots
)
;
auto
*
newHeaderSlots
=
new
(
allocation
)
ObjectSlots
(
newCapacity
dictionarySpan
)
;
slots_
=
newHeaderSlots
-
>
slots
(
)
;
}
bool
NativeObject
:
:
willBeSparseElements
(
uint32_t
requiredCapacity
uint32_t
newElementsHint
)
{
MOZ_ASSERT
(
is
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
requiredCapacity
>
MIN_SPARSE_INDEX
)
;
uint32_t
cap
=
getDenseCapacity
(
)
;
MOZ_ASSERT
(
requiredCapacity
>
=
cap
)
;
if
(
requiredCapacity
>
MAX_DENSE_ELEMENTS_COUNT
)
{
return
true
;
}
uint32_t
minimalDenseCount
=
requiredCapacity
/
SPARSE_DENSITY_RATIO
;
if
(
newElementsHint
>
=
minimalDenseCount
)
{
return
false
;
}
minimalDenseCount
-
=
newElementsHint
;
if
(
minimalDenseCount
>
cap
)
{
return
true
;
}
uint32_t
len
=
getDenseInitializedLength
(
)
;
const
Value
*
elems
=
getDenseElements
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
elems
[
i
]
.
isMagic
(
JS_ELEMENTS_HOLE
)
&
&
!
-
-
minimalDenseCount
)
{
return
false
;
}
}
return
true
;
}
DenseElementResult
NativeObject
:
:
maybeDensifySparseElements
(
JSContext
*
cx
HandleNativeObject
obj
)
{
if
(
!
obj
-
>
inDictionaryMode
(
)
)
{
return
DenseElementResult
:
:
Incomplete
;
}
uint32_t
slotSpan
=
obj
-
>
slotSpan
(
)
;
if
(
slotSpan
!
=
RoundUpPow2
(
slotSpan
)
)
{
return
DenseElementResult
:
:
Incomplete
;
}
if
(
!
obj
-
>
isExtensible
(
)
)
{
return
DenseElementResult
:
:
Incomplete
;
}
uint32_t
numDenseElements
=
0
;
uint32_t
newInitializedLength
=
0
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
)
;
while
(
!
shape
-
>
isEmptyShape
(
)
)
{
uint32_t
index
;
if
(
IdIsIndex
(
shape
-
>
propid
(
)
&
index
)
)
{
if
(
shape
-
>
attributes
(
)
=
=
JSPROP_ENUMERATE
)
{
MOZ_ASSERT
(
shape
-
>
isDataProperty
(
)
)
;
numDenseElements
+
+
;
newInitializedLength
=
std
:
:
max
(
newInitializedLength
index
+
1
)
;
}
else
{
return
DenseElementResult
:
:
Incomplete
;
}
}
shape
=
shape
-
>
previous
(
)
;
}
if
(
numDenseElements
*
SPARSE_DENSITY_RATIO
<
newInitializedLength
)
{
return
DenseElementResult
:
:
Incomplete
;
}
if
(
newInitializedLength
>
MAX_DENSE_ELEMENTS_COUNT
)
{
return
DenseElementResult
:
:
Incomplete
;
}
if
(
newInitializedLength
>
obj
-
>
getDenseCapacity
(
)
)
{
if
(
!
obj
-
>
growElements
(
cx
newInitializedLength
)
)
{
return
DenseElementResult
:
:
Failure
;
}
}
obj
-
>
ensureDenseInitializedLength
(
newInitializedLength
0
)
;
if
(
ObjectRealm
:
:
get
(
obj
)
.
objectMaybeInIteration
(
obj
)
)
{
obj
-
>
markDenseElementsMaybeInIteration
(
)
;
}
RootedValue
value
(
cx
)
;
shape
=
obj
-
>
lastProperty
(
)
;
while
(
!
shape
-
>
isEmptyShape
(
)
)
{
jsid
id
=
shape
-
>
propid
(
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
value
=
obj
-
>
getSlot
(
shape
-
>
slot
(
)
)
;
if
(
shape
!
=
obj
-
>
lastProperty
(
)
)
{
shape
=
shape
-
>
previous
(
)
;
if
(
!
NativeObject
:
:
removeProperty
(
cx
obj
id
)
)
{
return
DenseElementResult
:
:
Failure
;
}
}
else
{
if
(
!
NativeObject
:
:
removeProperty
(
cx
obj
id
)
)
{
return
DenseElementResult
:
:
Failure
;
}
shape
=
obj
-
>
lastProperty
(
)
;
}
obj
-
>
setDenseElement
(
index
value
)
;
}
else
{
shape
=
shape
-
>
previous
(
)
;
}
}
if
(
!
NativeObject
:
:
clearFlag
(
cx
obj
ObjectFlag
:
:
Indexed
)
)
{
return
DenseElementResult
:
:
Failure
;
}
return
DenseElementResult
:
:
Success
;
}
void
NativeObject
:
:
moveShiftedElements
(
)
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
ObjectElements
*
header
=
getElementsHeader
(
)
;
uint32_t
numShifted
=
header
-
>
numShiftedElements
(
)
;
MOZ_ASSERT
(
numShifted
>
0
)
;
uint32_t
initLength
=
header
-
>
initializedLength
;
ObjectElements
*
newHeader
=
static_cast
<
ObjectElements
*
>
(
getUnshiftedElementsHeader
(
)
)
;
memmove
(
newHeader
header
sizeof
(
ObjectElements
)
)
;
newHeader
-
>
clearShiftedElements
(
)
;
newHeader
-
>
capacity
+
=
numShifted
;
elements_
=
newHeader
-
>
elements
(
)
;
newHeader
-
>
initializedLength
+
=
numShifted
;
for
(
size_t
i
=
0
;
i
<
numShifted
;
i
+
+
)
{
initDenseElement
(
i
UndefinedValue
(
)
)
;
}
moveDenseElements
(
0
numShifted
initLength
)
;
setDenseInitializedLength
(
initLength
)
;
}
void
NativeObject
:
:
maybeMoveShiftedElements
(
)
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
ObjectElements
*
header
=
getElementsHeader
(
)
;
MOZ_ASSERT
(
header
-
>
numShiftedElements
(
)
>
0
)
;
if
(
header
-
>
capacity
<
header
-
>
numAllocatedElements
(
)
/
3
)
{
moveShiftedElements
(
)
;
}
}
bool
NativeObject
:
:
tryUnshiftDenseElements
(
uint32_t
count
)
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
MOZ_ASSERT
(
count
>
0
)
;
ObjectElements
*
header
=
getElementsHeader
(
)
;
uint32_t
numShifted
=
header
-
>
numShiftedElements
(
)
;
if
(
count
>
numShifted
)
{
if
(
header
-
>
initializedLength
<
=
10
|
|
header
-
>
hasNonwritableArrayLength
(
)
|
|
MOZ_UNLIKELY
(
count
>
ObjectElements
:
:
MaxShiftedElements
)
)
{
return
false
;
}
MOZ_ASSERT
(
header
-
>
capacity
>
=
header
-
>
initializedLength
)
;
uint32_t
unusedCapacity
=
header
-
>
capacity
-
header
-
>
initializedLength
;
uint32_t
toShift
=
count
-
numShifted
;
MOZ_ASSERT
(
toShift
<
=
ObjectElements
:
:
MaxShiftedElements
"
count
<
=
MaxShiftedElements
so
toShift
<
=
MaxShiftedElements
"
)
;
if
(
toShift
>
unusedCapacity
)
{
return
false
;
}
toShift
=
std
:
:
min
(
toShift
+
unusedCapacity
/
2
unusedCapacity
)
;
if
(
numShifted
+
toShift
>
ObjectElements
:
:
MaxShiftedElements
)
{
toShift
=
ObjectElements
:
:
MaxShiftedElements
-
numShifted
;
}
MOZ_ASSERT
(
count
<
=
numShifted
+
toShift
)
;
MOZ_ASSERT
(
numShifted
+
toShift
<
=
ObjectElements
:
:
MaxShiftedElements
)
;
MOZ_ASSERT
(
toShift
<
=
unusedCapacity
)
;
uint32_t
initLen
=
header
-
>
initializedLength
;
setDenseInitializedLength
(
initLen
+
toShift
)
;
for
(
uint32_t
i
=
0
;
i
<
toShift
;
i
+
+
)
{
initDenseElement
(
initLen
+
i
UndefinedValue
(
)
)
;
}
moveDenseElements
(
toShift
0
initLen
)
;
shiftDenseElementsUnchecked
(
toShift
)
;
header
=
getElementsHeader
(
)
;
MOZ_ASSERT
(
header
-
>
numShiftedElements
(
)
=
=
numShifted
+
toShift
)
;
numShifted
=
header
-
>
numShiftedElements
(
)
;
MOZ_ASSERT
(
count
<
=
numShifted
)
;
}
elements_
-
=
count
;
ObjectElements
*
newHeader
=
getElementsHeader
(
)
;
memmove
(
newHeader
header
sizeof
(
ObjectElements
)
)
;
newHeader
-
>
unshiftShiftedElements
(
count
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
initDenseElement
(
i
UndefinedValue
(
)
)
;
}
return
true
;
}
bool
NativeObject
:
:
goodElementsAllocationAmount
(
JSContext
*
cx
uint32_t
reqCapacity
uint32_t
length
uint32_t
*
goodAmount
)
{
if
(
reqCapacity
>
MAX_DENSE_ELEMENTS_COUNT
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
uint32_t
reqAllocated
=
reqCapacity
+
ObjectElements
:
:
VALUES_PER_HEADER
;
const
uint32_t
Mebi
=
1
<
<
20
;
if
(
reqAllocated
<
Mebi
)
{
uint32_t
amount
=
mozilla
:
:
AssertedCast
<
uint32_t
>
(
RoundUpPow2
(
reqAllocated
)
)
;
uint32_t
goodCapacity
=
amount
-
ObjectElements
:
:
VALUES_PER_HEADER
;
if
(
length
>
=
reqCapacity
&
&
goodCapacity
>
(
length
/
3
)
*
2
)
{
amount
=
length
+
ObjectElements
:
:
VALUES_PER_HEADER
;
}
if
(
amount
<
SLOT_CAPACITY_MIN
)
{
amount
=
SLOT_CAPACITY_MIN
;
}
*
goodAmount
=
amount
;
return
true
;
}
static
constexpr
uint32_t
BigBuckets
[
]
=
{
0x100000
0x200000
0x300000
0x400000
0x500000
0x600000
0x700000
0x800000
0x900000
0xb00000
0xd00000
0xf00000
0x1100000
0x1400000
0x1700000
0x1a00000
0x1e00000
0x2200000
0x2700000
0x2c00000
0x3200000
0x3900000
0x4100000
0x4a00000
0x5400000
0x5f00000
0x6b00000
0x7900000
0x8900000
0x9b00000
0xaf00000
0xc500000
0xde00000
0xfa00000
}
;
static_assert
(
BigBuckets
[
std
:
:
size
(
BigBuckets
)
-
1
]
<
=
MAX_DENSE_ELEMENTS_ALLOCATION
)
;
for
(
uint32_t
b
:
BigBuckets
)
{
if
(
b
>
=
reqAllocated
)
{
*
goodAmount
=
b
;
return
true
;
}
}
*
goodAmount
=
MAX_DENSE_ELEMENTS_ALLOCATION
;
return
true
;
}
bool
NativeObject
:
:
growElements
(
JSContext
*
cx
uint32_t
reqCapacity
)
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
MOZ_ASSERT
(
canHaveNonEmptyElements
(
)
)
;
uint32_t
numShifted
=
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
if
(
numShifted
>
0
)
{
static
const
size_t
MaxElementsToMoveEagerly
=
20
;
if
(
getElementsHeader
(
)
-
>
initializedLength
<
=
MaxElementsToMoveEagerly
)
{
moveShiftedElements
(
)
;
}
else
{
maybeMoveShiftedElements
(
)
;
}
if
(
getDenseCapacity
(
)
>
=
reqCapacity
)
{
return
true
;
}
numShifted
=
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
CheckedInt
<
uint32_t
>
checkedReqCapacity
(
reqCapacity
)
;
checkedReqCapacity
+
=
numShifted
;
if
(
MOZ_UNLIKELY
(
!
checkedReqCapacity
.
isValid
(
)
)
)
{
moveShiftedElements
(
)
;
numShifted
=
0
;
}
}
uint32_t
oldCapacity
=
getDenseCapacity
(
)
;
MOZ_ASSERT
(
oldCapacity
<
reqCapacity
)
;
uint32_t
newAllocated
=
0
;
if
(
is
<
ArrayObject
>
(
)
&
&
!
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
{
MOZ_ASSERT
(
reqCapacity
<
=
as
<
ArrayObject
>
(
)
.
length
(
)
)
;
MOZ_ASSERT
(
reqCapacity
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
newAllocated
=
reqCapacity
+
numShifted
+
ObjectElements
:
:
VALUES_PER_HEADER
;
}
else
{
if
(
!
goodElementsAllocationAmount
(
cx
reqCapacity
+
numShifted
getElementsHeader
(
)
-
>
length
&
newAllocated
)
)
{
return
false
;
}
}
uint32_t
newCapacity
=
newAllocated
-
ObjectElements
:
:
VALUES_PER_HEADER
-
numShifted
;
MOZ_ASSERT
(
newCapacity
>
oldCapacity
&
&
newCapacity
>
=
reqCapacity
)
;
MOZ_ASSERT
(
newCapacity
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
uint32_t
initlen
=
getDenseInitializedLength
(
)
;
HeapSlot
*
oldHeaderSlots
=
reinterpret_cast
<
HeapSlot
*
>
(
getUnshiftedElementsHeader
(
)
)
;
HeapSlot
*
newHeaderSlots
;
uint32_t
oldAllocated
=
0
;
if
(
hasDynamicElements
(
)
)
{
MOZ_ASSERT
(
oldCapacity
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
oldAllocated
=
oldCapacity
+
ObjectElements
:
:
VALUES_PER_HEADER
+
numShifted
;
newHeaderSlots
=
ReallocateObjectBuffer
<
HeapSlot
>
(
cx
this
oldHeaderSlots
oldAllocated
newAllocated
)
;
if
(
!
newHeaderSlots
)
{
return
false
;
}
}
else
{
newHeaderSlots
=
AllocateObjectBuffer
<
HeapSlot
>
(
cx
this
newAllocated
)
;
if
(
!
newHeaderSlots
)
{
return
false
;
}
PodCopy
(
newHeaderSlots
oldHeaderSlots
ObjectElements
:
:
VALUES_PER_HEADER
+
initlen
+
numShifted
)
;
}
if
(
oldAllocated
)
{
RemoveCellMemory
(
this
oldAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
}
ObjectElements
*
newheader
=
reinterpret_cast
<
ObjectElements
*
>
(
newHeaderSlots
)
;
elements_
=
newheader
-
>
elements
(
)
+
numShifted
;
getElementsHeader
(
)
-
>
capacity
=
newCapacity
;
Debug_SetSlotRangeToCrashOnTouch
(
elements_
+
initlen
newCapacity
-
initlen
)
;
AddCellMemory
(
this
newAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
return
true
;
}
void
NativeObject
:
:
shrinkElements
(
JSContext
*
cx
uint32_t
reqCapacity
)
{
MOZ_ASSERT
(
canHaveNonEmptyElements
(
)
)
;
MOZ_ASSERT
(
reqCapacity
>
=
getDenseInitializedLength
(
)
)
;
if
(
!
hasDynamicElements
(
)
)
{
return
;
}
uint32_t
numShifted
=
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
if
(
numShifted
>
0
)
{
maybeMoveShiftedElements
(
)
;
numShifted
=
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
}
uint32_t
oldCapacity
=
getDenseCapacity
(
)
;
MOZ_ASSERT
(
reqCapacity
<
oldCapacity
)
;
uint32_t
newAllocated
=
0
;
MOZ_ALWAYS_TRUE
(
goodElementsAllocationAmount
(
cx
reqCapacity
+
numShifted
0
&
newAllocated
)
)
;
MOZ_ASSERT
(
oldCapacity
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
uint32_t
oldAllocated
=
oldCapacity
+
ObjectElements
:
:
VALUES_PER_HEADER
+
numShifted
;
if
(
newAllocated
=
=
oldAllocated
)
{
return
;
}
MOZ_ASSERT
(
newAllocated
>
ObjectElements
:
:
VALUES_PER_HEADER
)
;
uint32_t
newCapacity
=
newAllocated
-
ObjectElements
:
:
VALUES_PER_HEADER
-
numShifted
;
MOZ_ASSERT
(
newCapacity
<
=
MAX_DENSE_ELEMENTS_COUNT
)
;
HeapSlot
*
oldHeaderSlots
=
reinterpret_cast
<
HeapSlot
*
>
(
getUnshiftedElementsHeader
(
)
)
;
HeapSlot
*
newHeaderSlots
=
ReallocateObjectBuffer
<
HeapSlot
>
(
cx
this
oldHeaderSlots
oldAllocated
newAllocated
)
;
if
(
!
newHeaderSlots
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
;
}
RemoveCellMemory
(
this
oldAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
ObjectElements
*
newheader
=
reinterpret_cast
<
ObjectElements
*
>
(
newHeaderSlots
)
;
elements_
=
newheader
-
>
elements
(
)
+
numShifted
;
getElementsHeader
(
)
-
>
capacity
=
newCapacity
;
AddCellMemory
(
this
newAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
}
void
NativeObject
:
:
shrinkCapacityToInitializedLength
(
JSContext
*
cx
)
{
if
(
getElementsHeader
(
)
-
>
numShiftedElements
(
)
>
0
)
{
moveShiftedElements
(
)
;
}
ObjectElements
*
header
=
getElementsHeader
(
)
;
uint32_t
len
=
header
-
>
initializedLength
;
MOZ_ASSERT
(
header
-
>
capacity
>
=
len
)
;
if
(
header
-
>
capacity
=
=
len
)
{
return
;
}
shrinkElements
(
cx
len
)
;
header
=
getElementsHeader
(
)
;
uint32_t
oldAllocated
=
header
-
>
numAllocatedElements
(
)
;
header
-
>
capacity
=
len
;
if
(
!
hasFixedElements
(
)
)
{
uint32_t
newAllocated
=
header
-
>
numAllocatedElements
(
)
;
RemoveCellMemory
(
this
oldAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
AddCellMemory
(
this
newAllocated
*
sizeof
(
HeapSlot
)
MemoryUse
:
:
ObjectElements
)
;
}
}
bool
NativeObject
:
:
allocDictionarySlot
(
JSContext
*
cx
HandleNativeObject
obj
uint32_t
*
slotp
)
{
MOZ_ASSERT
(
obj
-
>
inDictionaryMode
(
)
)
;
uint32_t
slot
=
obj
-
>
slotSpan
(
)
;
MOZ_ASSERT
(
slot
>
=
JSSLOT_FREE
(
obj
-
>
getClass
(
)
)
)
;
{
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
obj
-
>
lastProperty
(
)
-
>
maybeTable
(
nogc
)
)
{
uint32_t
last
=
table
-
>
freeList
(
)
;
if
(
last
!
=
SHAPE_INVALID_SLOT
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
last
<
slot
)
;
uint32_t
next
=
obj
-
>
getSlot
(
last
)
.
toPrivateUint32
(
)
;
MOZ_ASSERT_IF
(
next
!
=
SHAPE_INVALID_SLOT
next
<
slot
)
;
#
endif
*
slotp
=
last
;
const
Value
&
vref
=
obj
-
>
getSlot
(
last
)
;
table
-
>
setFreeList
(
vref
.
toPrivateUint32
(
)
)
;
obj
-
>
setSlot
(
last
UndefinedValue
(
)
)
;
return
true
;
}
}
}
if
(
slot
>
=
SHAPE_MAXIMUM_SLOT
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
*
slotp
=
slot
;
return
obj
-
>
ensureSlotsForDictionaryObject
(
cx
slot
+
1
)
;
}
void
NativeObject
:
:
freeSlot
(
JSContext
*
cx
uint32_t
slot
)
{
MOZ_ASSERT
(
slot
<
slotSpan
(
)
)
;
if
(
inDictionaryMode
(
)
)
{
AutoCheckCannotGC
nogc
;
if
(
ShapeTable
*
table
=
lastProperty
(
)
-
>
ensureTableForDictionary
(
cx
nogc
)
)
{
uint32_t
last
=
table
-
>
freeList
(
)
;
MOZ_ASSERT_IF
(
last
!
=
SHAPE_INVALID_SLOT
last
<
slotSpan
(
)
&
&
last
!
=
slot
)
;
if
(
JSSLOT_FREE
(
getClass
(
)
)
<
=
slot
)
{
MOZ_ASSERT_IF
(
last
!
=
SHAPE_INVALID_SLOT
last
<
slotSpan
(
)
)
;
setSlot
(
slot
PrivateUint32Value
(
last
)
)
;
table
-
>
setFreeList
(
slot
)
;
return
;
}
}
else
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
}
setSlot
(
slot
UndefinedValue
(
)
)
;
}
Shape
*
NativeObject
:
:
addProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandlePropertyName
name
uint32_t
slot
unsigned
attrs
)
{
MOZ_ASSERT
(
!
(
attrs
&
(
JSPROP_GETTER
|
JSPROP_SETTER
)
)
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
return
addProperty
(
cx
obj
id
slot
attrs
)
;
}
template
<
AllowGC
allowGC
>
bool
js
:
:
NativeLookupOwnProperty
(
JSContext
*
cx
typename
MaybeRooted
<
NativeObject
*
allowGC
>
:
:
HandleType
obj
typename
MaybeRooted
<
jsid
allowGC
>
:
:
HandleType
id
PropertyResult
*
propp
)
{
return
NativeLookupOwnPropertyInline
<
allowGC
>
(
cx
obj
id
propp
)
;
}
template
bool
js
:
:
NativeLookupOwnProperty
<
CanGC
>
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
PropertyResult
*
propp
)
;
template
bool
js
:
:
NativeLookupOwnProperty
<
NoGC
>
(
JSContext
*
cx
NativeObject
*
const
&
obj
const
jsid
&
id
PropertyResult
*
propp
)
;
static
bool
CallJSAddPropertyOp
(
JSContext
*
cx
JSAddPropertyOp
op
HandleObject
obj
HandleId
id
HandleValue
v
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
cx
-
>
check
(
obj
id
v
)
;
return
op
(
cx
obj
id
v
)
;
}
static
MOZ_ALWAYS_INLINE
bool
CallAddPropertyHook
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
value
)
{
JSAddPropertyOp
addProperty
=
obj
-
>
getClass
(
)
-
>
getAddProperty
(
)
;
if
(
MOZ_UNLIKELY
(
addProperty
)
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
if
(
!
CallJSAddPropertyOp
(
cx
addProperty
obj
id
value
)
)
{
NativeObject
:
:
removeProperty
(
cx
obj
id
)
;
return
false
;
}
}
return
true
;
}
static
MOZ_ALWAYS_INLINE
bool
CallAddPropertyHookDense
(
JSContext
*
cx
HandleNativeObject
obj
uint32_t
index
HandleValue
value
)
{
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
ArrayObject
*
arr
=
&
obj
-
>
as
<
ArrayObject
>
(
)
;
uint32_t
length
=
arr
-
>
length
(
)
;
if
(
index
>
=
length
)
{
arr
-
>
setLength
(
index
+
1
)
;
}
return
true
;
}
JSAddPropertyOp
addProperty
=
obj
-
>
getClass
(
)
-
>
getAddProperty
(
)
;
if
(
MOZ_UNLIKELY
(
addProperty
)
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
RootedId
id
(
cx
INT_TO_JSID
(
index
)
)
;
if
(
!
CallJSAddPropertyOp
(
cx
addProperty
obj
id
value
)
)
{
obj
-
>
setDenseElementHole
(
index
)
;
return
false
;
}
}
return
true
;
}
static
bool
WouldDefinePastNonwritableLength
(
ArrayObject
*
arr
uint32_t
index
)
{
return
!
arr
-
>
lengthIsWritable
(
)
&
&
index
>
=
arr
-
>
length
(
)
;
}
static
bool
ReshapeForShadowedPropSlow
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
)
{
MOZ_ASSERT
(
obj
-
>
isUsedAsPrototype
(
)
)
;
if
(
JSID_IS_INT
(
id
)
)
{
return
true
;
}
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
while
(
proto
)
{
if
(
!
proto
-
>
is
<
NativeObject
>
(
)
)
{
break
;
}
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
contains
(
cx
id
)
)
{
return
NativeObject
:
:
reshapeForShadowedProp
(
cx
proto
.
as
<
NativeObject
>
(
)
)
;
}
proto
=
proto
-
>
staticPrototype
(
)
;
}
return
true
;
}
static
MOZ_ALWAYS_INLINE
bool
ReshapeForShadowedProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
)
{
if
(
!
obj
-
>
isUsedAsPrototype
(
)
|
|
!
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
true
;
}
return
ReshapeForShadowedPropSlow
(
cx
obj
.
as
<
NativeObject
>
(
)
id
)
;
}
bool
NativeObject
:
:
reshapeForShadowedProp
(
JSContext
*
cx
HandleNativeObject
obj
)
{
return
generateOwnShape
(
cx
obj
)
;
}
static
bool
ChangeProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleObject
getter
HandleObject
setter
unsigned
attrs
PropertyResult
*
existing
)
{
MOZ_ASSERT
(
existing
)
;
Rooted
<
GetterSetter
*
>
gs
(
cx
)
;
if
(
existing
-
>
isNativeProperty
(
)
)
{
ShapeProperty
prop
=
existing
-
>
shapeProperty
(
)
;
if
(
prop
.
isAccessorProperty
(
)
)
{
GetterSetter
*
current
=
obj
-
>
getGetterSetter
(
prop
)
;
if
(
current
-
>
getter
(
)
=
=
getter
&
&
current
-
>
setter
(
)
=
=
setter
)
{
gs
=
current
;
}
}
}
if
(
!
gs
)
{
gs
=
GetterSetter
:
:
create
(
cx
getter
setter
)
;
if
(
!
gs
)
{
return
false
;
}
}
Shape
*
shape
=
NativeObject
:
:
putProperty
(
cx
obj
id
attrs
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setSlot
(
shape
-
>
slot
(
)
PrivateGCThingValue
(
gs
)
)
;
return
true
;
}
enum
class
IsAddOrChange
{
Add
Change
}
;
template
<
IsAddOrChange
AddOrChange
>
static
MOZ_ALWAYS_INLINE
bool
AddOrChangeProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
PropertyResult
*
existing
=
nullptr
)
{
desc
.
assertComplete
(
)
;
#
ifdef
DEBUG
if
constexpr
(
AddOrChange
=
=
IsAddOrChange
:
:
Add
)
{
MOZ_ASSERT
(
existing
=
=
nullptr
)
;
MOZ_ASSERT
(
!
obj
-
>
containsPure
(
id
)
)
;
}
else
{
static_assert
(
AddOrChange
=
=
IsAddOrChange
:
:
Change
)
;
MOZ_ASSERT
(
existing
)
;
MOZ_ASSERT
(
existing
-
>
isNativeProperty
(
)
|
|
existing
-
>
isDenseElement
(
)
)
;
}
#
endif
if
(
!
ReshapeForShadowedProp
(
cx
obj
id
)
)
{
return
false
;
}
if
(
id
.
isInt
(
)
&
&
desc
.
attributes
(
)
=
=
JSPROP_ENUMERATE
&
&
(
AddOrChange
=
=
IsAddOrChange
:
:
Add
|
|
existing
-
>
isDenseElement
(
)
)
)
{
MOZ_ASSERT
(
!
desc
.
isAccessorDescriptor
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
;
uint32_t
index
=
JSID_TO_INT
(
id
)
;
DenseElementResult
edResult
=
obj
-
>
ensureDenseElements
(
cx
index
1
)
;
if
(
edResult
=
=
DenseElementResult
:
:
Failure
)
{
return
false
;
}
if
(
edResult
=
=
DenseElementResult
:
:
Success
)
{
obj
-
>
setDenseElement
(
index
desc
.
value
(
)
)
;
if
(
!
CallAddPropertyHookDense
(
cx
obj
index
desc
.
value
(
)
)
)
{
return
false
;
}
return
true
;
}
}
if
constexpr
(
AddOrChange
=
=
IsAddOrChange
:
:
Add
)
{
if
(
desc
.
isAccessorDescriptor
(
)
)
{
Rooted
<
GetterSetter
*
>
gs
(
cx
GetterSetter
:
:
create
(
cx
desc
.
getterObject
(
)
desc
.
setterObject
(
)
)
)
;
if
(
!
gs
)
{
return
false
;
}
Shape
*
shape
=
NativeObject
:
:
addProperty
(
cx
obj
id
SHAPE_INVALID_SLOT
desc
.
attributes
(
)
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
initSlot
(
shape
-
>
slot
(
)
PrivateGCThingValue
(
gs
)
)
;
}
else
{
Shape
*
shape
=
NativeObject
:
:
addProperty
(
cx
obj
id
SHAPE_INVALID_SLOT
desc
.
attributes
(
)
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
initSlot
(
shape
-
>
slot
(
)
desc
.
value
(
)
)
;
}
}
else
{
if
(
desc
.
isAccessorDescriptor
(
)
)
{
if
(
!
ChangeProperty
(
cx
obj
id
desc
.
getterObject
(
)
desc
.
setterObject
(
)
desc
.
attributes
(
)
existing
)
)
{
return
false
;
}
}
else
{
Shape
*
shape
=
NativeObject
:
:
putProperty
(
cx
obj
id
desc
.
attributes
(
)
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
setSlot
(
shape
-
>
slot
(
)
desc
.
value
(
)
)
;
}
}
if
(
JSID_IS_INT
(
id
)
)
{
uint32_t
index
=
JSID_TO_INT
(
id
)
;
if
constexpr
(
AddOrChange
=
=
IsAddOrChange
:
:
Add
)
{
MOZ_ASSERT
(
!
obj
-
>
containsDenseElement
(
index
)
)
;
}
else
{
obj
-
>
removeDenseElementForSparseIndex
(
index
)
;
}
DenseElementResult
edResult
=
NativeObject
:
:
maybeDensifySparseElements
(
cx
obj
)
;
if
(
edResult
=
=
DenseElementResult
:
:
Failure
)
{
return
false
;
}
if
(
edResult
=
=
DenseElementResult
:
:
Success
)
{
MOZ_ASSERT
(
!
desc
.
isAccessorDescriptor
(
)
)
;
return
CallAddPropertyHookDense
(
cx
obj
index
desc
.
value
(
)
)
;
}
}
return
CallAddPropertyHook
(
cx
obj
id
desc
.
value
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
bool
AddDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
v
)
{
MOZ_ASSERT
(
!
JSID_IS_INT
(
id
)
)
;
if
(
!
ReshapeForShadowedProp
(
cx
obj
id
)
)
{
return
false
;
}
Shape
*
shape
=
NativeObject
:
:
addEnumerableDataProperty
(
cx
obj
id
)
;
if
(
!
shape
)
{
return
false
;
}
obj
-
>
initSlot
(
shape
-
>
slot
(
)
v
)
;
return
CallAddPropertyHook
(
cx
obj
id
v
)
;
}
static
bool
IsConfigurable
(
unsigned
attrs
)
{
return
(
attrs
&
JSPROP_PERMANENT
)
=
=
0
;
}
static
bool
IsEnumerable
(
unsigned
attrs
)
{
return
(
attrs
&
JSPROP_ENUMERATE
)
!
=
0
;
}
static
bool
IsWritable
(
unsigned
attrs
)
{
return
(
attrs
&
JSPROP_READONLY
)
=
=
0
;
}
static
bool
IsAccessorDescriptor
(
unsigned
attrs
)
{
return
(
attrs
&
(
JSPROP_GETTER
|
JSPROP_SETTER
)
)
!
=
0
;
}
static
bool
IsDataDescriptor
(
unsigned
attrs
)
{
MOZ_ASSERT
(
(
attrs
&
(
JSPROP_IGNORE_VALUE
|
JSPROP_IGNORE_READONLY
)
)
=
=
0
)
;
return
!
IsAccessorDescriptor
(
attrs
)
;
}
template
<
AllowGC
allowGC
>
static
MOZ_ALWAYS_INLINE
bool
GetExistingProperty
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
receiver
typename
MaybeRooted
<
NativeObject
*
allowGC
>
:
:
HandleType
obj
typename
MaybeRooted
<
jsid
allowGC
>
:
:
HandleType
id
ShapeProperty
prop
typename
MaybeRooted
<
Value
allowGC
>
:
:
MutableHandleType
vp
)
;
static
bool
GetExistingPropertyValue
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
const
PropertyResult
&
prop
MutableHandleValue
vp
)
{
if
(
prop
.
isDenseElement
(
)
)
{
vp
.
set
(
obj
-
>
getDenseElement
(
prop
.
denseElementIndex
(
)
)
)
;
return
true
;
}
if
(
prop
.
isTypedArrayElement
(
)
)
{
size_t
idx
=
prop
.
typedArrayElementIndex
(
)
;
return
obj
-
>
as
<
TypedArrayObject
>
(
)
.
getElement
<
CanGC
>
(
cx
idx
vp
)
;
}
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
MOZ_ASSERT
(
obj
-
>
containsPure
(
id
prop
.
shapeProperty
(
)
)
)
;
RootedValue
receiver
(
cx
ObjectValue
(
*
obj
)
)
;
return
GetExistingProperty
<
CanGC
>
(
cx
receiver
obj
id
prop
.
shapeProperty
(
)
vp
)
;
}
static
bool
DefinePropertyIsRedundant
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
const
PropertyResult
&
prop
unsigned
shapeAttrs
Handle
<
PropertyDescriptor
>
desc
bool
*
redundant
)
{
*
redundant
=
false
;
if
(
desc
.
hasConfigurable
(
)
&
&
desc
.
configurable
(
)
!
=
IsConfigurable
(
shapeAttrs
)
)
{
return
true
;
}
if
(
desc
.
hasEnumerable
(
)
&
&
desc
.
enumerable
(
)
!
=
IsEnumerable
(
shapeAttrs
)
)
{
return
true
;
}
if
(
desc
.
isDataDescriptor
(
)
)
{
if
(
IsAccessorDescriptor
(
shapeAttrs
)
)
{
return
true
;
}
if
(
desc
.
hasWritable
(
)
&
&
desc
.
writable
(
)
!
=
IsWritable
(
shapeAttrs
)
)
{
return
true
;
}
if
(
desc
.
hasValue
(
)
)
{
RootedValue
currentValue
(
cx
)
;
if
(
prop
.
isNativeProperty
(
)
&
&
prop
.
shapeProperty
(
)
.
isDataProperty
(
)
)
{
currentValue
.
set
(
obj
-
>
getSlot
(
prop
.
shapeProperty
(
)
.
slot
(
)
)
)
;
}
else
{
if
(
!
GetExistingPropertyValue
(
cx
obj
id
prop
&
currentValue
)
)
{
return
false
;
}
}
if
(
desc
.
value
(
)
!
=
currentValue
)
{
return
true
;
}
}
if
(
prop
.
isNativeProperty
(
)
&
&
prop
.
shapeProperty
(
)
.
isCustomDataProperty
(
)
)
{
return
true
;
}
}
else
{
if
(
desc
.
hasGetterObject
(
)
&
&
(
!
(
shapeAttrs
&
JSPROP_GETTER
)
|
|
desc
.
getterObject
(
)
!
=
obj
-
>
getGetter
(
prop
.
shapeProperty
(
)
)
)
)
{
return
true
;
}
if
(
desc
.
hasSetterObject
(
)
&
&
(
!
(
shapeAttrs
&
JSPROP_SETTER
)
|
|
desc
.
setterObject
(
)
!
=
obj
-
>
getSetter
(
prop
.
shapeProperty
(
)
)
)
)
{
return
true
;
}
}
*
redundant
=
true
;
return
true
;
}
bool
js
:
:
NativeDefineProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc_
ObjectOpResult
&
result
)
{
desc_
.
assertValid
(
)
;
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
Rooted
<
ArrayObject
*
>
arr
(
cx
&
obj
-
>
as
<
ArrayObject
>
(
)
)
;
if
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
length
)
)
{
if
(
desc_
.
isAccessorDescriptor
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
return
ArraySetLength
(
cx
arr
id
desc_
.
attributes
(
)
desc_
.
value
(
)
result
)
;
}
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
if
(
WouldDefinePastNonwritableLength
(
arr
index
)
)
{
return
result
.
fail
(
JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH
)
;
}
}
}
else
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
Rooted
<
TypedArrayObject
*
>
tobj
(
cx
&
obj
-
>
as
<
TypedArrayObject
>
(
)
)
;
mozilla
:
:
Maybe
<
uint64_t
>
index
;
if
(
!
ToTypedArrayIndex
(
cx
id
&
index
)
)
{
return
false
;
}
if
(
index
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
return
DefineTypedArrayElement
(
cx
tobj
index
.
value
(
)
desc_
result
)
;
}
}
else
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
)
{
Rooted
<
ArgumentsObject
*
>
argsobj
(
cx
&
obj
-
>
as
<
ArgumentsObject
>
(
)
)
;
if
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
length
)
)
{
if
(
(
desc_
.
attributes
(
)
&
JSPROP_RESOLVING
)
=
=
0
)
{
if
(
!
ArgumentsObject
:
:
reifyLength
(
cx
argsobj
)
)
{
return
false
;
}
}
}
else
if
(
JSID_IS_SYMBOL
(
id
)
&
&
JSID_TO_SYMBOL
(
id
)
=
=
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
{
if
(
(
desc_
.
attributes
(
)
&
JSPROP_RESOLVING
)
=
=
0
)
{
if
(
!
ArgumentsObject
:
:
reifyIterator
(
cx
argsobj
)
)
{
return
false
;
}
}
}
else
if
(
JSID_IS_INT
(
id
)
)
{
if
(
(
desc_
.
attributes
(
)
&
JSPROP_RESOLVING
)
=
=
0
)
{
argsobj
-
>
markElementOverridden
(
)
;
}
}
}
PropertyResult
prop
;
if
(
desc_
.
attributes
(
)
&
JSPROP_RESOLVING
)
{
if
(
!
NativeLookupOwnPropertyNoResolve
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
}
else
{
if
(
!
NativeLookupOwnProperty
<
CanGC
>
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
}
Rooted
<
PropertyDescriptor
>
desc
(
cx
desc_
)
;
if
(
prop
.
isNotFound
(
)
)
{
if
(
!
obj
-
>
isExtensible
(
)
&
&
!
id
.
isPrivateName
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE
)
;
}
CompletePropertyDescriptor
(
&
desc
)
;
if
(
!
AddOrChangeProperty
<
IsAddOrChange
:
:
Add
>
(
cx
obj
id
desc
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
unsigned
shapeAttrs
=
GetPropertyAttributes
(
obj
prop
)
;
bool
redundant
;
if
(
!
DefinePropertyIsRedundant
(
cx
obj
id
prop
shapeAttrs
desc
&
redundant
)
)
{
return
false
;
}
if
(
redundant
)
{
return
result
.
succeed
(
)
;
}
if
(
!
IsConfigurable
(
shapeAttrs
)
)
{
if
(
desc
.
hasConfigurable
(
)
&
&
desc
.
configurable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasEnumerable
(
)
&
&
desc
.
enumerable
(
)
!
=
IsEnumerable
(
shapeAttrs
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
}
if
(
!
desc
.
hasConfigurable
(
)
)
{
desc
.
setConfigurable
(
IsConfigurable
(
shapeAttrs
)
)
;
}
if
(
!
desc
.
hasEnumerable
(
)
)
{
desc
.
setEnumerable
(
IsEnumerable
(
shapeAttrs
)
)
;
}
if
(
desc
.
isGenericDescriptor
(
)
)
{
MOZ_ASSERT
(
!
desc
.
hasValue
(
)
)
;
MOZ_ASSERT
(
!
desc
.
hasWritable
(
)
)
;
MOZ_ASSERT
(
!
desc
.
hasGetterObject
(
)
)
;
MOZ_ASSERT
(
!
desc
.
hasSetterObject
(
)
)
;
if
(
IsDataDescriptor
(
shapeAttrs
)
)
{
RootedValue
currentValue
(
cx
)
;
if
(
!
GetExistingPropertyValue
(
cx
obj
id
prop
&
currentValue
)
)
{
return
false
;
}
desc
.
setValue
(
currentValue
)
;
desc
.
setWritable
(
IsWritable
(
shapeAttrs
)
)
;
}
else
{
ShapeProperty
shapeProp
=
prop
.
shapeProperty
(
)
;
desc
.
setGetterObject
(
obj
-
>
getGetter
(
shapeProp
)
)
;
desc
.
setSetterObject
(
obj
-
>
getSetter
(
shapeProp
)
)
;
}
}
else
if
(
desc
.
isDataDescriptor
(
)
!
=
IsDataDescriptor
(
shapeAttrs
)
)
{
if
(
!
IsConfigurable
(
shapeAttrs
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
CompletePropertyDescriptor
(
&
desc
)
;
}
else
if
(
desc
.
isDataDescriptor
(
)
)
{
bool
frozen
=
!
IsConfigurable
(
shapeAttrs
)
&
&
!
IsWritable
(
shapeAttrs
)
;
if
(
frozen
&
&
desc
.
hasWritable
(
)
&
&
desc
.
writable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
frozen
|
|
!
desc
.
hasValue
(
)
)
{
RootedValue
currentValue
(
cx
)
;
if
(
!
GetExistingPropertyValue
(
cx
obj
id
prop
&
currentValue
)
)
{
return
false
;
}
if
(
!
desc
.
hasValue
(
)
)
{
desc
.
setValue
(
currentValue
)
;
}
else
{
bool
same
;
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
if
(
!
SameValue
(
cx
desc
.
value
(
)
currentValue
&
same
)
)
{
return
false
;
}
if
(
!
same
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
}
}
if
(
frozen
)
{
return
result
.
succeed
(
)
;
}
if
(
!
desc
.
hasWritable
(
)
)
{
desc
.
setWritable
(
IsWritable
(
shapeAttrs
)
)
;
}
}
else
{
ShapeProperty
shapeProp
=
prop
.
shapeProperty
(
)
;
MOZ_ASSERT
(
shapeProp
.
isAccessorProperty
(
)
)
;
MOZ_ASSERT
(
desc
.
isAccessorDescriptor
(
)
)
;
if
(
desc
.
hasSetterObject
(
)
)
{
if
(
!
IsConfigurable
(
shapeAttrs
)
&
&
desc
.
setterObject
(
)
!
=
obj
-
>
getSetter
(
shapeProp
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
}
else
{
desc
.
setSetterObject
(
obj
-
>
getSetter
(
shapeProp
)
)
;
}
if
(
desc
.
hasGetterObject
(
)
)
{
if
(
!
IsConfigurable
(
shapeAttrs
)
&
&
desc
.
getterObject
(
)
!
=
obj
-
>
getGetter
(
shapeProp
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
}
else
{
desc
.
setGetterObject
(
obj
-
>
getGetter
(
shapeProp
)
)
;
}
}
if
(
!
AddOrChangeProperty
<
IsAddOrChange
:
:
Change
>
(
cx
obj
id
desc
&
prop
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
bool
js
:
:
NativeDefineDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
value
unsigned
attrs
ObjectOpResult
&
result
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
desc
.
initFields
(
nullptr
value
attrs
nullptr
nullptr
)
;
return
NativeDefineProperty
(
cx
obj
id
desc
result
)
;
}
bool
js
:
:
NativeDefineAccessorProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleObject
getter
HandleObject
setter
unsigned
attrs
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
desc
.
initFields
(
nullptr
UndefinedHandleValue
attrs
getter
setter
)
;
ObjectOpResult
result
;
if
(
!
NativeDefineProperty
(
cx
obj
id
desc
result
)
)
{
return
false
;
}
if
(
!
result
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
result
.
reportError
(
cx
obj
id
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
NativeDefineDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
value
unsigned
attrs
)
{
ObjectOpResult
result
;
if
(
!
NativeDefineDataProperty
(
cx
obj
id
value
attrs
result
)
)
{
return
false
;
}
if
(
!
result
)
{
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
result
.
reportError
(
cx
obj
id
)
;
return
false
;
}
return
true
;
}
bool
js
:
:
NativeDefineDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
PropertyName
*
name
HandleValue
value
unsigned
attrs
)
{
RootedId
id
(
cx
NameToId
(
name
)
)
;
return
NativeDefineDataProperty
(
cx
obj
id
value
attrs
)
;
}
static
bool
DefineNonexistentProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
v
ObjectOpResult
&
result
)
{
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
MOZ_ASSERT
(
id
!
=
NameToId
(
cx
-
>
names
(
)
.
length
)
)
;
uint32_t
index
;
if
(
IdIsIndex
(
id
&
index
)
)
{
if
(
WouldDefinePastNonwritableLength
(
&
obj
-
>
as
<
ArrayObject
>
(
)
index
)
)
{
return
result
.
fail
(
JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH
)
;
}
}
}
else
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
mozilla
:
:
Maybe
<
uint64_t
>
index
;
if
(
!
ToTypedArrayIndex
(
cx
id
&
index
)
)
{
return
false
;
}
if
(
index
)
{
MOZ_ASSERT
(
index
.
value
(
)
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
;
if
(
!
obj
-
>
as
<
TypedArrayObject
>
(
)
.
convertForSideEffect
(
cx
v
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
}
else
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
)
{
MOZ_ASSERT_IF
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
length
)
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
;
MOZ_ASSERT_IF
(
JSID_IS_SYMBOL
(
id
)
&
&
JSID_TO_SYMBOL
(
id
)
=
=
cx
-
>
wellKnownSymbols
(
)
.
iterator
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenIterator
(
)
)
;
if
(
JSID_IS_INT
(
id
)
)
{
obj
-
>
as
<
ArgumentsObject
>
(
)
.
markElementOverridden
(
)
;
}
}
#
ifdef
DEBUG
PropertyResult
prop
;
if
(
!
NativeLookupOwnPropertyNoResolve
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
MOZ_ASSERT
(
prop
.
isNotFound
(
)
"
didn
'
t
expect
to
find
an
existing
property
"
)
;
#
endif
if
(
!
obj
-
>
isExtensible
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE
)
;
}
if
(
JSID_IS_INT
(
id
)
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
desc
.
setDataDescriptor
(
v
JSPROP_ENUMERATE
)
;
if
(
!
AddOrChangeProperty
<
IsAddOrChange
:
:
Add
>
(
cx
obj
id
desc
)
)
{
return
false
;
}
}
else
{
if
(
!
AddDataProperty
(
cx
obj
id
v
)
)
{
return
false
;
}
}
return
result
.
succeed
(
)
;
}
bool
js
:
:
AddOrUpdateSparseElementHelper
(
JSContext
*
cx
HandleArrayObject
obj
int32_t
int_id
HandleValue
v
bool
strict
)
{
MOZ_ASSERT
(
INT_FITS_IN_JSID
(
int_id
)
)
;
RootedId
id
(
cx
INT_TO_JSID
(
int_id
)
)
;
MOZ_ASSERT
(
int_id
>
=
0
)
;
MOZ_ASSERT
(
uint32_t
(
int_id
)
>
=
obj
-
>
getDenseInitializedLength
(
)
)
;
RootedShape
shape
(
cx
obj
-
>
lastProperty
(
)
-
>
search
(
cx
id
)
)
;
if
(
shape
=
=
nullptr
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
desc
.
setDataDescriptor
(
v
JSPROP_ENUMERATE
)
;
desc
.
assertComplete
(
)
;
return
AddOrChangeProperty
<
IsAddOrChange
:
:
Add
>
(
cx
obj
id
desc
)
;
}
if
(
shape
-
>
writable
(
)
&
&
shape
-
>
isDataProperty
(
)
)
{
obj
-
>
setSlot
(
shape
-
>
slot
(
)
v
)
;
return
true
;
}
RootedValue
receiver
(
cx
ObjectValue
(
*
obj
)
)
;
JS
:
:
ObjectOpResult
result
;
return
SetProperty
(
cx
obj
id
v
receiver
result
)
&
&
result
.
checkStrictModeError
(
cx
obj
id
strict
)
;
}
bool
js
:
:
NativeHasProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
bool
*
foundp
)
{
RootedNativeObject
pobj
(
cx
obj
)
;
PropertyResult
prop
;
for
(
;
;
)
{
if
(
!
NativeLookupOwnPropertyInline
<
CanGC
>
(
cx
pobj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isFound
(
)
)
{
*
foundp
=
true
;
return
true
;
}
JSObject
*
proto
=
pobj
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
prop
.
shouldIgnoreProtoChain
(
)
)
{
*
foundp
=
false
;
return
true
;
}
if
(
!
proto
-
>
is
<
NativeObject
>
(
)
)
{
RootedObject
protoRoot
(
cx
proto
)
;
return
HasProperty
(
cx
protoRoot
id
foundp
)
;
}
pobj
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
bool
js
:
:
NativeGetOwnPropertyDescriptor
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
{
PropertyResult
prop
;
if
(
!
NativeLookupOwnProperty
<
CanGC
>
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
desc
.
object
(
)
.
set
(
nullptr
)
;
return
true
;
}
desc
.
setAttributes
(
GetPropertyAttributes
(
obj
prop
)
)
;
if
(
desc
.
isAccessorDescriptor
(
)
)
{
ShapeProperty
shapeProp
=
prop
.
shapeProperty
(
)
;
if
(
desc
.
hasGetterObject
(
)
)
{
desc
.
setGetterObject
(
obj
-
>
getGetter
(
shapeProp
)
)
;
}
else
{
desc
.
setGetterObject
(
nullptr
)
;
desc
.
attributesRef
(
)
|
=
JSPROP_GETTER
;
}
if
(
desc
.
hasSetterObject
(
)
)
{
desc
.
setSetterObject
(
obj
-
>
getSetter
(
shapeProp
)
)
;
}
else
{
desc
.
setSetterObject
(
nullptr
)
;
desc
.
attributesRef
(
)
|
=
JSPROP_SETTER
;
}
desc
.
value
(
)
.
setUndefined
(
)
;
}
else
{
if
(
prop
.
isDenseElement
(
)
)
{
desc
.
value
(
)
.
set
(
obj
-
>
getDenseElement
(
prop
.
denseElementIndex
(
)
)
)
;
}
else
if
(
prop
.
isTypedArrayElement
(
)
)
{
size_t
idx
=
prop
.
typedArrayElementIndex
(
)
;
if
(
!
obj
-
>
as
<
TypedArrayObject
>
(
)
.
getElement
<
CanGC
>
(
cx
idx
desc
.
value
(
)
)
)
{
return
false
;
}
}
else
{
desc
.
attributesRef
(
)
&
=
~
JSPROP_CUSTOM_DATA_PROP
;
if
(
!
NativeGetExistingProperty
(
cx
obj
obj
id
prop
.
shapeProperty
(
)
desc
.
value
(
)
)
)
{
return
false
;
}
}
}
desc
.
object
(
)
.
set
(
obj
)
;
desc
.
assertComplete
(
)
;
return
true
;
}
static
bool
GetCustomDataProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleValue
vp
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
cx
-
>
check
(
obj
id
vp
)
;
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
clasp
=
=
&
ArrayObject
:
:
class_
)
{
if
(
!
ArrayLengthGetter
(
cx
obj
id
vp
)
)
{
return
false
;
}
}
else
if
(
clasp
=
=
&
MappedArgumentsObject
:
:
class_
)
{
if
(
!
MappedArgGetter
(
cx
obj
id
vp
)
)
{
return
false
;
}
}
else
{
MOZ_RELEASE_ASSERT
(
clasp
=
=
&
UnmappedArgumentsObject
:
:
class_
)
;
if
(
!
UnmappedArgGetter
(
cx
obj
id
vp
)
)
{
return
false
;
}
}
cx
-
>
check
(
vp
)
;
return
true
;
}
static
inline
bool
CallGetter
(
JSContext
*
cx
HandleNativeObject
obj
HandleValue
receiver
HandleId
id
ShapeProperty
prop
MutableHandleValue
vp
)
{
MOZ_ASSERT
(
!
prop
.
isDataProperty
(
)
)
;
if
(
prop
.
isAccessorProperty
(
)
)
{
RootedValue
getter
(
cx
obj
-
>
getGetterValue
(
prop
)
)
;
return
js
:
:
CallGetter
(
cx
receiver
getter
vp
)
;
}
MOZ_ASSERT
(
prop
.
isCustomDataProperty
(
)
)
;
return
GetCustomDataProperty
(
cx
obj
id
vp
)
;
}
template
<
AllowGC
allowGC
>
static
MOZ_ALWAYS_INLINE
bool
GetExistingProperty
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
receiver
typename
MaybeRooted
<
NativeObject
*
allowGC
>
:
:
HandleType
obj
typename
MaybeRooted
<
jsid
allowGC
>
:
:
HandleType
id
ShapeProperty
prop
typename
MaybeRooted
<
Value
allowGC
>
:
:
MutableHandleType
vp
)
{
if
(
prop
.
isDataProperty
(
)
)
{
vp
.
set
(
obj
-
>
getSlot
(
prop
.
slot
(
)
)
)
;
return
true
;
}
vp
.
setUndefined
(
)
;
if
(
!
prop
.
isCustomDataProperty
(
)
&
&
!
obj
-
>
hasGetter
(
prop
)
)
{
return
true
;
}
if
constexpr
(
!
allowGC
)
{
return
false
;
}
else
{
return
CallGetter
(
cx
obj
receiver
id
prop
vp
)
;
}
}
bool
js
:
:
NativeGetExistingProperty
(
JSContext
*
cx
HandleObject
receiver
HandleNativeObject
obj
HandleId
id
ShapeProperty
prop
MutableHandleValue
vp
)
{
RootedValue
receiverValue
(
cx
ObjectValue
(
*
receiver
)
)
;
return
GetExistingProperty
<
CanGC
>
(
cx
receiverValue
obj
id
prop
vp
)
;
}
enum
IsNameLookup
{
NotNameLookup
=
false
NameLookup
=
true
}
;
static
bool
GetNonexistentProperty
(
JSContext
*
cx
HandleId
id
IsNameLookup
nameLookup
MutableHandleValue
vp
)
{
vp
.
setUndefined
(
)
;
if
(
nameLookup
)
{
ReportIsNotDefined
(
cx
id
)
;
return
false
;
}
return
true
;
}
bool
GetNonexistentProperty
(
JSContext
*
cx
const
jsid
&
id
IsNameLookup
nameLookup
FakeMutableHandle
<
Value
>
vp
)
{
return
false
;
}
static
inline
bool
GeneralizedGetProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
receiver
IsNameLookup
nameLookup
MutableHandleValue
vp
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
if
(
nameLookup
)
{
bool
found
;
if
(
!
HasProperty
(
cx
obj
id
&
found
)
)
{
return
false
;
}
if
(
!
found
)
{
ReportIsNotDefined
(
cx
id
)
;
return
false
;
}
}
return
GetProperty
(
cx
obj
receiver
id
vp
)
;
}
static
inline
bool
GeneralizedGetProperty
(
JSContext
*
cx
JSObject
*
obj
jsid
id
const
Value
&
receiver
IsNameLookup
nameLookup
FakeMutableHandle
<
Value
>
vp
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
checkDontReport
(
cx
)
)
{
return
false
;
}
if
(
nameLookup
)
{
return
false
;
}
return
GetPropertyNoGC
(
cx
obj
receiver
id
vp
.
address
(
)
)
;
}
bool
js
:
:
GetSparseElementHelper
(
JSContext
*
cx
HandleArrayObject
obj
int32_t
int_id
MutableHandleValue
result
)
{
MOZ_ASSERT
(
obj
-
>
hasStaticPrototype
(
)
)
;
MOZ_ASSERT_IF
(
obj
-
>
staticPrototype
(
)
!
=
nullptr
!
ObjectMayHaveExtraIndexedProperties
(
obj
-
>
staticPrototype
(
)
)
)
;
MOZ_ASSERT
(
INT_FITS_IN_JSID
(
int_id
)
)
;
RootedId
id
(
cx
INT_TO_JSID
(
int_id
)
)
;
Shape
*
rawShape
=
obj
-
>
lastProperty
(
)
-
>
search
(
cx
id
)
;
if
(
!
rawShape
)
{
result
.
setUndefined
(
)
;
return
true
;
}
RootedValue
receiver
(
cx
ObjectValue
(
*
obj
)
)
;
RootedShape
shape
(
cx
rawShape
)
;
return
GetExistingProperty
<
CanGC
>
(
cx
receiver
obj
id
ShapeProperty
(
shape
)
result
)
;
}
template
<
AllowGC
allowGC
>
static
MOZ_ALWAYS_INLINE
bool
NativeGetPropertyInline
(
JSContext
*
cx
typename
MaybeRooted
<
NativeObject
*
allowGC
>
:
:
HandleType
obj
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
receiver
typename
MaybeRooted
<
jsid
allowGC
>
:
:
HandleType
id
IsNameLookup
nameLookup
typename
MaybeRooted
<
Value
allowGC
>
:
:
MutableHandleType
vp
)
{
typename
MaybeRooted
<
NativeObject
*
allowGC
>
:
:
RootType
pobj
(
cx
obj
)
;
PropertyResult
prop
;
for
(
;
;
)
{
if
(
!
NativeLookupOwnPropertyInline
<
allowGC
>
(
cx
pobj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isFound
(
)
)
{
if
(
prop
.
isDenseElement
(
)
)
{
vp
.
set
(
pobj
-
>
getDenseElement
(
prop
.
denseElementIndex
(
)
)
)
;
return
true
;
}
if
(
prop
.
isTypedArrayElement
(
)
)
{
size_t
idx
=
prop
.
typedArrayElementIndex
(
)
;
auto
*
tarr
=
&
pobj
-
>
template
as
<
TypedArrayObject
>
(
)
;
return
tarr
-
>
template
getElement
<
allowGC
>
(
cx
idx
vp
)
;
}
return
GetExistingProperty
<
allowGC
>
(
cx
receiver
pobj
id
prop
.
shapeProperty
(
)
vp
)
;
}
JSObject
*
proto
=
pobj
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
prop
.
shouldIgnoreProtoChain
(
)
)
{
return
GetNonexistentProperty
(
cx
id
nameLookup
vp
)
;
}
if
(
proto
-
>
getOpsGetProperty
(
)
)
{
RootedObject
protoRoot
(
cx
proto
)
;
return
GeneralizedGetProperty
(
cx
protoRoot
id
receiver
nameLookup
vp
)
;
}
pobj
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
bool
js
:
:
NativeGetProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
{
return
NativeGetPropertyInline
<
CanGC
>
(
cx
obj
receiver
id
NotNameLookup
vp
)
;
}
bool
js
:
:
NativeGetPropertyNoGC
(
JSContext
*
cx
NativeObject
*
obj
const
Value
&
receiver
jsid
id
Value
*
vp
)
{
AutoAssertNoPendingException
noexc
(
cx
)
;
return
NativeGetPropertyInline
<
NoGC
>
(
cx
obj
receiver
id
NotNameLookup
vp
)
;
}
bool
js
:
:
NativeGetElement
(
JSContext
*
cx
HandleNativeObject
obj
HandleValue
receiver
int32_t
index
MutableHandleValue
vp
)
{
RootedId
id
(
cx
)
;
if
(
MOZ_LIKELY
(
index
>
=
0
)
)
{
if
(
!
IndexToId
(
cx
index
&
id
)
)
{
return
false
;
}
}
else
{
RootedValue
indexVal
(
cx
Int32Value
(
index
)
)
;
if
(
!
PrimitiveValueToId
<
CanGC
>
(
cx
indexVal
&
id
)
)
{
return
false
;
}
}
return
NativeGetProperty
(
cx
obj
receiver
id
vp
)
;
}
bool
js
:
:
GetNameBoundInEnvironment
(
JSContext
*
cx
HandleObject
envArg
HandleId
id
MutableHandleValue
vp
)
{
RootedObject
env
(
cx
MaybeUnwrapWithEnvironment
(
envArg
)
)
;
RootedValue
receiver
(
cx
ObjectValue
(
*
env
)
)
;
if
(
env
-
>
getOpsGetProperty
(
)
)
{
return
GeneralizedGetProperty
(
cx
env
id
receiver
NameLookup
vp
)
;
}
return
NativeGetPropertyInline
<
CanGC
>
(
cx
env
.
as
<
NativeObject
>
(
)
receiver
id
NameLookup
vp
)
;
}
static
bool
SetCustomDataProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
ObjectOpResult
&
result
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
cx
-
>
check
(
obj
id
v
)
;
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
clasp
=
=
&
ArrayObject
:
:
class_
)
{
return
ArrayLengthSetter
(
cx
obj
id
v
result
)
;
}
if
(
clasp
=
=
&
MappedArgumentsObject
:
:
class_
)
{
return
MappedArgSetter
(
cx
obj
id
v
result
)
;
}
MOZ_RELEASE_ASSERT
(
clasp
=
=
&
UnmappedArgumentsObject
:
:
class_
)
;
return
UnmappedArgSetter
(
cx
obj
id
v
result
)
;
}
static
bool
MaybeReportUndeclaredVarAssignment
(
JSContext
*
cx
HandleId
id
)
{
{
jsbytecode
*
pc
;
JSScript
*
script
=
cx
-
>
currentScript
(
&
pc
JSContext
:
:
AllowCrossRealm
:
:
Allow
)
;
if
(
!
script
)
{
return
true
;
}
if
(
!
IsStrictSetPC
(
pc
)
)
{
return
true
;
}
}
UniqueChars
bytes
=
IdToPrintableUTF8
(
cx
id
IdToPrintableBehavior
:
:
IdIsIdentifier
)
;
if
(
!
bytes
)
{
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_UNDECLARED_VAR
bytes
.
get
(
)
)
;
return
false
;
}
static
bool
NativeSetExistingDataProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
ShapeProperty
prop
HandleValue
v
ObjectOpResult
&
result
)
{
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
prop
.
isDataDescriptor
(
)
)
;
if
(
prop
.
isDataProperty
(
)
)
{
obj
-
>
setSlot
(
prop
.
slot
(
)
v
)
;
return
result
.
succeed
(
)
;
}
MOZ_ASSERT
(
prop
.
isCustomDataProperty
(
)
)
;
MOZ_ASSERT
(
!
obj
-
>
is
<
WithEnvironmentObject
>
(
)
)
;
return
SetCustomDataProperty
(
cx
obj
id
v
result
)
;
}
bool
js
:
:
SetPropertyByDefining
(
JSContext
*
cx
HandleId
id
HandleValue
v
HandleValue
receiverValue
ObjectOpResult
&
result
)
{
if
(
!
receiverValue
.
isObject
(
)
)
{
return
result
.
fail
(
JSMSG_SET_NON_OBJECT_RECEIVER
)
;
}
RootedObject
receiver
(
cx
&
receiverValue
.
toObject
(
)
)
;
bool
existing
;
{
Rooted
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
(
cx
)
;
if
(
!
GetOwnPropertyDescriptor
(
cx
receiver
id
&
desc
)
)
{
return
false
;
}
existing
=
desc
.
isSome
(
)
;
if
(
existing
)
{
if
(
desc
-
>
isAccessorDescriptor
(
)
)
{
return
result
.
fail
(
JSMSG_OVERWRITING_ACCESSOR
)
;
}
if
(
!
desc
-
>
writable
(
)
)
{
return
result
.
fail
(
JSMSG_READ_ONLY
)
;
}
}
}
if
(
!
ReshapeForShadowedProp
(
cx
receiver
id
)
)
{
return
false
;
}
unsigned
attrs
=
existing
?
JSPROP_IGNORE_ENUMERATE
|
JSPROP_IGNORE_READONLY
|
JSPROP_IGNORE_PERMANENT
:
JSPROP_ENUMERATE
;
return
DefineDataProperty
(
cx
receiver
id
v
attrs
result
)
;
}
bool
js
:
:
SetPropertyOnProto
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
;
RootedObject
proto
(
cx
obj
-
>
staticPrototype
(
)
)
;
if
(
proto
)
{
return
SetProperty
(
cx
proto
id
v
receiver
result
)
;
}
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
template
<
QualifiedBool
IsQualified
>
static
bool
SetNonexistentProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
if
(
!
IsQualified
&
&
receiver
.
isObject
(
)
&
&
receiver
.
toObject
(
)
.
isUnqualifiedVarObj
(
)
)
{
if
(
!
MaybeReportUndeclaredVarAssignment
(
cx
id
)
)
{
return
false
;
}
}
if
(
IsQualified
&
&
receiver
.
isObject
(
)
&
&
obj
=
=
&
receiver
.
toObject
(
)
)
{
#
ifdef
DEBUG
if
(
GetOwnPropertyOp
op
=
obj
-
>
getOpsGetOwnPropertyDescriptor
(
)
)
{
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
if
(
!
op
(
cx
obj
id
&
desc
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
desc
.
object
(
)
)
;
}
#
endif
if
(
DefinePropertyOp
op
=
obj
-
>
getOpsDefineProperty
(
)
)
{
if
(
!
ReshapeForShadowedProp
(
cx
obj
id
)
)
{
return
false
;
}
Rooted
<
PropertyDescriptor
>
desc
(
cx
)
;
desc
.
initFields
(
nullptr
v
JSPROP_ENUMERATE
nullptr
nullptr
)
;
MOZ_ASSERT
(
!
cx
-
>
isHelperThreadContext
(
)
)
;
return
op
(
cx
obj
id
desc
result
)
;
}
return
DefineNonexistentProperty
(
cx
obj
id
v
result
)
;
}
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
static
bool
SetDenseElement
(
JSContext
*
cx
HandleNativeObject
obj
uint32_t
index
HandleValue
v
ObjectOpResult
&
result
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
;
MOZ_ASSERT
(
obj
-
>
containsDenseElement
(
index
)
)
;
obj
-
>
setDenseElement
(
index
v
)
;
return
result
.
succeed
(
)
;
}
static
bool
SetExistingProperty
(
JSContext
*
cx
HandleId
id
HandleValue
v
HandleValue
receiver
HandleNativeObject
pobj
const
PropertyResult
&
prop
ObjectOpResult
&
result
)
{
if
(
prop
.
isDenseElement
(
)
|
|
prop
.
isTypedArrayElement
(
)
)
{
if
(
pobj
-
>
denseElementsAreFrozen
(
)
)
{
return
result
.
fail
(
JSMSG_READ_ONLY
)
;
}
if
(
receiver
.
isObject
(
)
&
&
pobj
=
=
&
receiver
.
toObject
(
)
)
{
if
(
prop
.
isTypedArrayElement
(
)
)
{
Rooted
<
TypedArrayObject
*
>
tobj
(
cx
&
pobj
-
>
as
<
TypedArrayObject
>
(
)
)
;
size_t
idx
=
prop
.
typedArrayElementIndex
(
)
;
return
SetTypedArrayElement
(
cx
tobj
idx
v
result
)
;
}
return
SetDenseElement
(
cx
pobj
prop
.
denseElementIndex
(
)
v
result
)
;
}
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
ShapeProperty
shapeProp
=
prop
.
shapeProperty
(
)
;
if
(
shapeProp
.
isDataDescriptor
(
)
)
{
if
(
!
shapeProp
.
writable
(
)
)
{
return
result
.
fail
(
JSMSG_READ_ONLY
)
;
}
if
(
receiver
.
isObject
(
)
&
&
pobj
=
=
&
receiver
.
toObject
(
)
)
{
return
NativeSetExistingDataProperty
(
cx
pobj
id
shapeProp
v
result
)
;
}
return
SetPropertyByDefining
(
cx
id
v
receiver
result
)
;
}
MOZ_ASSERT
(
shapeProp
.
isAccessorProperty
(
)
)
;
JSObject
*
setterObject
=
pobj
-
>
getSetter
(
shapeProp
)
;
if
(
!
setterObject
)
{
return
result
.
fail
(
JSMSG_GETTER_ONLY
)
;
}
RootedValue
setter
(
cx
ObjectValue
(
*
setterObject
)
)
;
if
(
!
js
:
:
CallSetter
(
cx
receiver
setter
v
)
)
{
return
false
;
}
return
result
.
succeed
(
)
;
}
template
<
QualifiedBool
IsQualified
>
bool
js
:
:
NativeSetProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
PropertyResult
prop
;
RootedNativeObject
pobj
(
cx
obj
)
;
for
(
;
;
)
{
if
(
!
NativeLookupOwnPropertyInline
<
CanGC
>
(
cx
pobj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isFound
(
)
)
{
return
SetExistingProperty
(
cx
id
v
receiver
pobj
prop
result
)
;
}
JSObject
*
proto
=
pobj
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
prop
.
shouldIgnoreProtoChain
(
)
)
{
return
SetNonexistentProperty
<
IsQualified
>
(
cx
obj
id
v
receiver
result
)
;
}
if
(
!
proto
-
>
is
<
NativeObject
>
(
)
)
{
RootedObject
protoRoot
(
cx
proto
)
;
if
(
!
IsQualified
)
{
bool
found
;
if
(
!
HasProperty
(
cx
protoRoot
id
&
found
)
)
{
return
false
;
}
if
(
!
found
)
{
return
SetNonexistentProperty
<
IsQualified
>
(
cx
obj
id
v
receiver
result
)
;
}
}
return
SetProperty
(
cx
protoRoot
id
v
receiver
result
)
;
}
pobj
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
template
bool
js
:
:
NativeSetProperty
<
Qualified
>
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
value
HandleValue
receiver
ObjectOpResult
&
result
)
;
template
bool
js
:
:
NativeSetProperty
<
Unqualified
>
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
HandleValue
value
HandleValue
receiver
ObjectOpResult
&
result
)
;
bool
js
:
:
NativeSetElement
(
JSContext
*
cx
HandleNativeObject
obj
uint32_t
index
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
RootedId
id
(
cx
)
;
if
(
!
IndexToId
(
cx
index
&
id
)
)
{
return
false
;
}
return
NativeSetProperty
<
Qualified
>
(
cx
obj
id
v
receiver
result
)
;
}
static
bool
CallJSDeletePropertyOp
(
JSContext
*
cx
JSDeletePropertyOp
op
HandleObject
receiver
HandleId
id
ObjectOpResult
&
result
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
cx
-
>
check
(
receiver
id
)
;
if
(
op
)
{
return
op
(
cx
receiver
id
result
)
;
}
return
result
.
succeed
(
)
;
}
bool
js
:
:
NativeDeleteProperty
(
JSContext
*
cx
HandleNativeObject
obj
HandleId
id
ObjectOpResult
&
result
)
{
PropertyResult
prop
;
if
(
!
NativeLookupOwnProperty
<
CanGC
>
(
cx
obj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNotFound
(
)
)
{
return
CallJSDeletePropertyOp
(
cx
obj
-
>
getClass
(
)
-
>
getDelProperty
(
)
obj
id
result
)
;
}
if
(
GetPropertyAttributes
(
obj
prop
)
&
JSPROP_PERMANENT
)
{
return
result
.
failCantDelete
(
)
;
}
if
(
prop
.
isTypedArrayElement
(
)
)
{
return
result
.
failCantDelete
(
)
;
}
if
(
!
CallJSDeletePropertyOp
(
cx
obj
-
>
getClass
(
)
-
>
getDelProperty
(
)
obj
id
result
)
)
{
return
false
;
}
if
(
!
result
)
{
return
true
;
}
if
(
prop
.
isDenseElement
(
)
)
{
obj
-
>
setDenseElementHole
(
prop
.
denseElementIndex
(
)
)
;
}
else
{
if
(
!
NativeObject
:
:
removeProperty
(
cx
obj
id
)
)
{
return
false
;
}
}
return
SuppressDeletedProperty
(
cx
obj
id
)
;
}
bool
js
:
:
CopyDataPropertiesNative
(
JSContext
*
cx
HandlePlainObject
target
HandleNativeObject
from
Handle
<
PlainObject
*
>
excludedItems
bool
*
optimized
)
{
MOZ_ASSERT
(
!
target
-
>
isUsedAsPrototype
(
)
"
CopyDataPropertiesNative
should
only
be
called
during
object
literal
"
"
construction
"
"
which
precludes
that
|
target
|
is
the
prototype
of
any
other
object
"
)
;
*
optimized
=
false
;
if
(
from
-
>
getDenseInitializedLength
(
)
>
0
|
|
from
-
>
isIndexed
(
)
|
|
from
-
>
is
<
TypedArrayObject
>
(
)
|
|
from
-
>
getClass
(
)
-
>
getNewEnumerate
(
)
|
|
from
-
>
getClass
(
)
-
>
getEnumerate
(
)
)
{
return
true
;
}
Rooted
<
ShapePropertyVector
>
props
(
cx
ShapePropertyVector
(
cx
)
)
;
RootedShape
fromShape
(
cx
from
-
>
shape
(
)
)
;
for
(
ShapePropertyIter
<
NoGC
>
iter
(
fromShape
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
jsid
id
=
iter
-
>
key
(
)
;
MOZ_ASSERT
(
!
JSID_IS_INT
(
id
)
)
;
if
(
!
iter
-
>
enumerable
(
)
)
{
continue
;
}
if
(
excludedItems
&
&
excludedItems
-
>
contains
(
cx
id
)
)
{
continue
;
}
if
(
!
iter
-
>
isDataProperty
(
)
)
{
return
true
;
}
if
(
!
props
.
append
(
*
iter
)
)
{
return
false
;
}
}
*
optimized
=
true
;
const
bool
targetHadNoOwnProperties
=
target
-
>
empty
(
)
;
RootedId
key
(
cx
)
;
RootedValue
value
(
cx
)
;
for
(
size_t
i
=
props
.
length
(
)
;
i
>
0
;
i
-
-
)
{
ShapePropertyWithKey
prop
=
props
[
i
-
1
]
;
MOZ_ASSERT
(
prop
.
isDataProperty
(
)
)
;
MOZ_ASSERT
(
prop
.
enumerable
(
)
)
;
key
=
prop
.
key
(
)
;
MOZ_ASSERT
(
!
JSID_IS_INT
(
key
)
)
;
MOZ_ASSERT
(
from
-
>
is
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
from
-
>
shape
(
)
=
=
fromShape
)
;
value
=
from
-
>
getSlot
(
prop
.
slot
(
)
)
;
if
(
targetHadNoOwnProperties
)
{
MOZ_ASSERT
(
!
target
-
>
containsPure
(
key
)
"
didn
'
t
expect
to
find
an
existing
property
"
)
;
if
(
!
AddDataPropertyNonPrototype
(
cx
target
key
value
)
)
{
return
false
;
}
}
else
{
if
(
!
NativeDefineDataProperty
(
cx
target
key
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
}
return
true
;
}
