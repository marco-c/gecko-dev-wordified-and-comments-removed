#
include
"
jsapi
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PIC
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
ForOfIterator
;
bool
ForOfIterator
:
:
init
(
HandleValue
iterable
NonIterableBehavior
nonIterableBehavior
)
{
JSContext
*
cx
=
cx_
;
RootedObject
iterableObj
(
cx
ToObject
(
cx
iterable
)
)
;
if
(
!
iterableObj
)
return
false
;
MOZ_ASSERT
(
index
=
=
NOT_ARRAY
)
;
if
(
iterableObj
-
>
is
<
ArrayObject
>
(
)
)
{
ForOfPIC
:
:
Chain
*
stubChain
=
ForOfPIC
:
:
getOrCreate
(
cx
)
;
if
(
!
stubChain
)
return
false
;
bool
optimized
;
if
(
!
stubChain
-
>
tryOptimizeArray
(
cx
iterableObj
.
as
<
ArrayObject
>
(
)
&
optimized
)
)
return
false
;
if
(
optimized
)
{
index
=
0
;
iterator
=
iterableObj
;
nextMethod
.
setUndefined
(
)
;
return
true
;
}
}
MOZ_ASSERT
(
index
=
=
NOT_ARRAY
)
;
RootedValue
callee
(
cx
)
;
RootedId
iteratorId
(
cx
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
)
;
if
(
!
GetProperty
(
cx
iterableObj
iterableObj
iteratorId
&
callee
)
)
return
false
;
if
(
nonIterableBehavior
=
=
AllowNonIterable
&
&
callee
.
isUndefined
(
)
)
return
true
;
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
isCallable
(
)
)
{
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
iterable
nullptr
)
;
if
(
!
bytes
)
return
false
;
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
bytes
.
get
(
)
)
;
return
false
;
}
RootedValue
res
(
cx
)
;
if
(
!
js
:
:
Call
(
cx
callee
iterable
&
res
)
)
return
false
;
if
(
!
res
.
isObject
(
)
)
return
ThrowCheckIsObject
(
cx
CheckIsObjectKind
:
:
GetIterator
)
;
RootedObject
iteratorObj
(
cx
&
res
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
iteratorObj
iteratorObj
cx
-
>
names
(
)
.
next
&
res
)
)
return
false
;
iterator
=
iteratorObj
;
nextMethod
=
res
;
return
true
;
}
inline
bool
ForOfIterator
:
:
nextFromOptimizedArray
(
MutableHandleValue
vp
bool
*
done
)
{
MOZ_ASSERT
(
index
!
=
NOT_ARRAY
)
;
if
(
!
CheckForInterrupt
(
cx_
)
)
return
false
;
ArrayObject
*
arr
=
&
iterator
-
>
as
<
ArrayObject
>
(
)
;
if
(
index
>
=
arr
-
>
length
(
)
)
{
vp
.
setUndefined
(
)
;
*
done
=
true
;
return
true
;
}
*
done
=
false
;
if
(
index
<
arr
-
>
getDenseInitializedLength
(
)
)
{
vp
.
set
(
arr
-
>
getDenseElement
(
index
)
)
;
if
(
!
vp
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
{
+
+
index
;
return
true
;
}
}
return
GetElement
(
cx_
iterator
iterator
index
+
+
vp
)
;
}
bool
ForOfIterator
:
:
next
(
MutableHandleValue
vp
bool
*
done
)
{
MOZ_ASSERT
(
iterator
)
;
if
(
index
!
=
NOT_ARRAY
)
return
nextFromOptimizedArray
(
vp
done
)
;
RootedValue
v
(
cx_
)
;
if
(
!
js
:
:
Call
(
cx_
nextMethod
iterator
&
v
)
)
return
false
;
if
(
!
v
.
isObject
(
)
)
return
ThrowCheckIsObject
(
cx_
CheckIsObjectKind
:
:
IteratorNext
)
;
RootedObject
resultObj
(
cx_
&
v
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx_
resultObj
resultObj
cx_
-
>
names
(
)
.
done
&
v
)
)
return
false
;
*
done
=
ToBoolean
(
v
)
;
if
(
*
done
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
return
GetProperty
(
cx_
resultObj
resultObj
cx_
-
>
names
(
)
.
value
vp
)
;
}
void
ForOfIterator
:
:
closeThrow
(
)
{
MOZ_ASSERT
(
iterator
)
;
RootedValue
completionException
(
cx_
)
;
if
(
cx_
-
>
isExceptionPending
(
)
)
{
if
(
!
GetAndClearException
(
cx_
&
completionException
)
)
completionException
.
setUndefined
(
)
;
}
RootedValue
returnVal
(
cx_
)
;
if
(
!
GetProperty
(
cx_
iterator
iterator
cx_
-
>
names
(
)
.
return_
&
returnVal
)
)
return
;
if
(
returnVal
.
isUndefined
(
)
)
{
cx_
-
>
setPendingException
(
completionException
)
;
return
;
}
if
(
!
returnVal
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx_
GetErrorMessage
nullptr
JSMSG_RETURN_NOT_CALLABLE
)
;
return
;
}
RootedObject
returnObj
(
cx_
&
returnVal
.
toObject
(
)
)
;
if
(
!
returnObj
-
>
isCallable
(
)
)
{
JS_ReportErrorNumberASCII
(
cx_
GetErrorMessage
nullptr
JSMSG_RETURN_NOT_CALLABLE
)
;
return
;
}
RootedValue
innerResultValue
(
cx_
)
;
if
(
!
js
:
:
Call
(
cx_
returnVal
iterator
&
innerResultValue
)
)
{
if
(
cx_
-
>
isExceptionPending
(
)
)
cx_
-
>
clearPendingException
(
)
;
}
cx_
-
>
setPendingException
(
completionException
)
;
}
