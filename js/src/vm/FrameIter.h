#
ifndef
vm_FrameIter_h
#
define
vm_FrameIter_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
jit
/
JSJitFrameIter
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Activation
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
wasm
/
WasmFrameIter
.
h
"
struct
JSPrincipals
;
namespace
JS
{
class
JS_PUBLIC_API
Compartment
;
class
JS_PUBLIC_API
Realm
;
}
namespace
js
{
class
ArgumentsObject
;
class
CallObject
;
namespace
jit
{
class
CommonFrameLayout
;
class
JitActivation
;
}
namespace
wasm
{
class
Instance
;
}
class
InterpreterFrameIterator
{
InterpreterActivation
*
activation_
;
InterpreterFrame
*
fp_
;
jsbytecode
*
pc_
;
JS
:
:
Value
*
sp_
;
public
:
explicit
InterpreterFrameIterator
(
InterpreterActivation
*
activation
)
:
activation_
(
activation
)
fp_
(
nullptr
)
pc_
(
nullptr
)
sp_
(
nullptr
)
{
if
(
activation
)
{
fp_
=
activation
-
>
current
(
)
;
pc_
=
activation
-
>
regs
(
)
.
pc
;
sp_
=
activation
-
>
regs
(
)
.
sp
;
}
}
InterpreterFrame
*
frame
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
fp_
;
}
jsbytecode
*
pc
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
pc_
;
}
JS
:
:
Value
*
sp
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
sp_
;
}
InterpreterFrameIterator
&
operator
+
+
(
)
;
bool
done
(
)
const
{
return
fp_
=
=
nullptr
;
}
}
;
class
JitFrameIter
{
protected
:
jit
:
:
JitActivation
*
act_
=
nullptr
;
mozilla
:
:
MaybeOneOf
<
jit
:
:
JSJitFrameIter
wasm
:
:
WasmFrameIter
>
iter_
=
{
}
;
bool
mustUnwindActivation_
=
false
;
void
settle
(
)
;
public
:
JitFrameIter
(
)
=
default
;
explicit
JitFrameIter
(
jit
:
:
JitActivation
*
activation
bool
mustUnwindActivation
=
false
)
;
explicit
JitFrameIter
(
const
JitFrameIter
&
another
)
;
JitFrameIter
&
operator
=
(
const
JitFrameIter
&
another
)
;
bool
isSome
(
)
const
{
return
!
iter_
.
empty
(
)
;
}
void
reset
(
)
{
MOZ_ASSERT
(
isSome
(
)
)
;
iter_
.
destroy
(
)
;
}
bool
isJSJit
(
)
const
{
return
isSome
(
)
&
&
iter_
.
constructed
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
jit
:
:
JSJitFrameIter
&
asJSJit
(
)
{
return
iter_
.
ref
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
const
jit
:
:
JSJitFrameIter
&
asJSJit
(
)
const
{
return
iter_
.
ref
<
jit
:
:
JSJitFrameIter
>
(
)
;
}
bool
isWasm
(
)
const
{
return
isSome
(
)
&
&
iter_
.
constructed
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
wasm
:
:
WasmFrameIter
&
asWasm
(
)
{
return
iter_
.
ref
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
const
wasm
:
:
WasmFrameIter
&
asWasm
(
)
const
{
return
iter_
.
ref
<
wasm
:
:
WasmFrameIter
>
(
)
;
}
const
jit
:
:
JitActivation
*
activation
(
)
const
{
return
act_
;
}
bool
done
(
)
const
;
void
operator
+
+
(
)
;
JS
:
:
Realm
*
realm
(
)
const
;
uint8_t
*
resumePCinCurrentFrame
(
)
const
;
void
skipNonScriptedJSFrames
(
)
;
bool
isSelfHostedIgnoringInlining
(
)
const
;
}
;
class
OnlyJSJitFrameIter
:
public
JitFrameIter
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
isJSJit
(
)
)
{
JitFrameIter
:
:
operator
+
+
(
)
;
}
}
public
:
explicit
OnlyJSJitFrameIter
(
jit
:
:
JitActivation
*
act
)
;
explicit
OnlyJSJitFrameIter
(
const
ActivationIterator
&
cx
)
;
void
operator
+
+
(
)
{
JitFrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
}
const
jit
:
:
JSJitFrameIter
&
frame
(
)
const
{
return
asJSJit
(
)
;
}
}
;
class
ScriptSource
;
class
FrameIter
{
public
:
enum
DebuggerEvalOption
{
FOLLOW_DEBUGGER_EVAL_PREV_LINK
IGNORE_DEBUGGER_EVAL_PREV_LINK
}
;
enum
State
{
DONE
INTERP
JIT
}
;
struct
Data
{
JSContext
*
cx_
;
DebuggerEvalOption
debuggerEvalOption_
;
JSPrincipals
*
principals_
;
State
state_
;
jsbytecode
*
pc_
;
InterpreterFrameIterator
interpFrames_
;
ActivationIterator
activations_
;
JitFrameIter
jitFrames_
;
unsigned
ionInlineFrameNo_
;
Data
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
;
Data
(
const
Data
&
other
)
;
}
;
explicit
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
=
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
;
FrameIter
(
JSContext
*
cx
DebuggerEvalOption
JSPrincipals
*
)
;
FrameIter
(
const
FrameIter
&
iter
)
;
MOZ_IMPLICIT
FrameIter
(
const
Data
&
data
)
;
MOZ_IMPLICIT
FrameIter
(
AbstractFramePtr
frame
)
;
bool
done
(
)
const
{
return
data_
.
state_
=
=
DONE
;
}
FrameIter
&
operator
+
+
(
)
;
JS
:
:
Realm
*
realm
(
)
const
;
JS
:
:
Compartment
*
compartment
(
)
const
;
Activation
*
activation
(
)
const
{
return
data_
.
activations_
.
activation
(
)
;
}
bool
isInterp
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
INTERP
;
}
bool
isJSJit
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
JIT
&
&
data_
.
jitFrames_
.
isJSJit
(
)
;
}
bool
isWasm
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
state_
=
=
JIT
&
&
data_
.
jitFrames_
.
isWasm
(
)
;
}
inline
bool
isIon
(
)
const
;
inline
bool
isBaseline
(
)
const
;
inline
bool
isPhysicalJitFrame
(
)
const
;
bool
isEvalFrame
(
)
const
;
bool
isModuleFrame
(
)
const
;
bool
isFunctionFrame
(
)
const
;
bool
hasArgs
(
)
const
{
return
isFunctionFrame
(
)
;
}
ScriptSource
*
scriptSource
(
)
const
;
const
char
*
filename
(
)
const
;
const
char16_t
*
displayURL
(
)
const
;
unsigned
computeLine
(
uint32_t
*
column
=
nullptr
)
const
;
JSAtom
*
maybeFunctionDisplayAtom
(
)
const
;
bool
mutedErrors
(
)
const
;
bool
hasScript
(
)
const
{
return
!
isWasm
(
)
;
}
inline
bool
wasmDebugEnabled
(
)
const
;
inline
wasm
:
:
Instance
*
wasmInstance
(
)
const
;
inline
uint32_t
wasmFuncIndex
(
)
const
;
inline
unsigned
wasmBytecodeOffset
(
)
const
;
void
wasmUpdateBytecodeOffset
(
)
;
inline
JSScript
*
script
(
)
const
;
bool
isConstructing
(
)
const
;
jsbytecode
*
pc
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
data_
.
pc_
;
}
void
updatePcQuadratic
(
)
;
JSFunction
*
calleeTemplate
(
)
const
;
JSFunction
*
callee
(
JSContext
*
cx
)
const
;
JSFunction
*
maybeCallee
(
JSContext
*
cx
)
const
{
return
isFunctionFrame
(
)
?
callee
(
cx
)
:
nullptr
;
}
bool
matchCallee
(
JSContext
*
cx
JS
:
:
Handle
<
JSFunction
*
>
fun
)
const
;
unsigned
numActualArgs
(
)
const
;
unsigned
numFormalArgs
(
)
const
;
JS
:
:
Value
unaliasedActual
(
unsigned
i
MaybeCheckAliasing
=
CHECK_ALIASING
)
const
;
template
<
class
Op
>
inline
void
unaliasedForEachActual
(
JSContext
*
cx
Op
op
)
;
JSObject
*
environmentChain
(
JSContext
*
cx
)
const
;
bool
hasInitialEnvironment
(
JSContext
*
cx
)
const
;
CallObject
&
callObj
(
JSContext
*
cx
)
const
;
bool
hasArgsObj
(
)
const
;
ArgumentsObject
&
argsObj
(
)
const
;
JS
:
:
Value
thisArgument
(
JSContext
*
cx
)
const
;
JS
:
:
Value
returnValue
(
)
const
;
void
setReturnValue
(
const
JS
:
:
Value
&
v
)
;
size_t
numFrameSlots
(
)
const
;
JS
:
:
Value
frameSlotValue
(
size_t
index
)
const
;
bool
ensureHasRematerializedFrame
(
JSContext
*
cx
)
;
bool
hasUsableAbstractFramePtr
(
)
const
;
AbstractFramePtr
abstractFramePtr
(
)
const
;
Data
*
copyData
(
)
const
;
inline
InterpreterFrame
*
interpFrame
(
)
const
;
inline
jit
:
:
CommonFrameLayout
*
physicalJitFrame
(
)
const
;
void
*
rawFramePtr
(
)
const
;
private
:
Data
data_
;
jit
:
:
InlineFrameIterator
ionInlineFrames_
;
const
jit
:
:
JSJitFrameIter
&
jsJitFrame
(
)
const
{
return
data_
.
jitFrames_
.
asJSJit
(
)
;
}
const
wasm
:
:
WasmFrameIter
&
wasmFrame
(
)
const
{
return
data_
.
jitFrames_
.
asWasm
(
)
;
}
jit
:
:
JSJitFrameIter
&
jsJitFrame
(
)
{
return
data_
.
jitFrames_
.
asJSJit
(
)
;
}
wasm
:
:
WasmFrameIter
&
wasmFrame
(
)
{
return
data_
.
jitFrames_
.
asWasm
(
)
;
}
bool
isIonScripted
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isIonScripted
(
)
;
}
bool
principalsSubsumeFrame
(
)
const
;
void
popActivation
(
)
;
void
popInterpreterFrame
(
)
;
void
nextJitFrame
(
)
;
void
popJitFrame
(
)
;
void
settleOnActivation
(
)
;
}
;
class
ScriptFrameIter
:
public
FrameIter
{
void
settle
(
)
{
while
(
!
done
(
)
&
&
!
hasScript
(
)
)
{
FrameIter
:
:
operator
+
+
(
)
;
}
}
public
:
explicit
ScriptFrameIter
(
JSContext
*
cx
DebuggerEvalOption
debuggerEvalOption
=
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
FrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
ScriptFrameIter
&
operator
+
+
(
)
{
FrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
#
ifdef
DEBUG
bool
SelfHostedFramesVisible
(
)
;
#
else
static
inline
bool
SelfHostedFramesVisible
(
)
{
return
false
;
}
#
endif
class
NonBuiltinFrameIter
:
public
FrameIter
{
void
settle
(
)
;
public
:
explicit
NonBuiltinFrameIter
(
JSContext
*
cx
FrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
=
FrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
FrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
NonBuiltinFrameIter
(
JSContext
*
cx
FrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
JSPrincipals
*
principals
)
:
FrameIter
(
cx
debuggerEvalOption
principals
)
{
settle
(
)
;
}
NonBuiltinFrameIter
(
JSContext
*
cx
JSPrincipals
*
principals
)
:
FrameIter
(
cx
FrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
principals
)
{
settle
(
)
;
}
NonBuiltinFrameIter
&
operator
+
+
(
)
{
FrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
class
NonBuiltinScriptFrameIter
:
public
ScriptFrameIter
{
void
settle
(
)
;
public
:
explicit
NonBuiltinScriptFrameIter
(
JSContext
*
cx
ScriptFrameIter
:
:
DebuggerEvalOption
debuggerEvalOption
=
ScriptFrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
)
:
ScriptFrameIter
(
cx
debuggerEvalOption
)
{
settle
(
)
;
}
NonBuiltinScriptFrameIter
&
operator
+
+
(
)
{
ScriptFrameIter
:
:
operator
+
+
(
)
;
settle
(
)
;
return
*
this
;
}
}
;
class
AllFramesIter
:
public
FrameIter
{
public
:
explicit
AllFramesIter
(
JSContext
*
cx
)
:
FrameIter
(
cx
ScriptFrameIter
:
:
IGNORE_DEBUGGER_EVAL_PREV_LINK
)
{
}
}
;
class
AllScriptFramesIter
:
public
ScriptFrameIter
{
public
:
explicit
AllScriptFramesIter
(
JSContext
*
cx
)
:
ScriptFrameIter
(
cx
ScriptFrameIter
:
:
IGNORE_DEBUGGER_EVAL_PREV_LINK
)
{
}
}
;
inline
JSScript
*
FrameIter
:
:
script
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
hasScript
(
)
)
;
if
(
data_
.
state_
=
=
INTERP
)
{
return
interpFrame
(
)
-
>
script
(
)
;
}
if
(
jsJitFrame
(
)
.
isIonJS
(
)
)
{
return
ionInlineFrames_
.
script
(
)
;
}
return
jsJitFrame
(
)
.
script
(
)
;
}
inline
bool
FrameIter
:
:
wasmDebugEnabled
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
debugEnabled
(
)
;
}
inline
wasm
:
:
Instance
*
FrameIter
:
:
wasmInstance
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
instance
(
)
;
}
inline
unsigned
FrameIter
:
:
wasmBytecodeOffset
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
lineOrBytecode
(
)
;
}
inline
uint32_t
FrameIter
:
:
wasmFuncIndex
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
isWasm
(
)
)
;
return
wasmFrame
(
)
.
funcIndex
(
)
;
}
inline
bool
FrameIter
:
:
isIon
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isIonJS
(
)
;
}
inline
bool
FrameIter
:
:
isBaseline
(
)
const
{
return
isJSJit
(
)
&
&
jsJitFrame
(
)
.
isBaselineJS
(
)
;
}
inline
InterpreterFrame
*
FrameIter
:
:
interpFrame
(
)
const
{
MOZ_ASSERT
(
data_
.
state_
=
=
INTERP
)
;
return
data_
.
interpFrames_
.
frame
(
)
;
}
inline
bool
FrameIter
:
:
isPhysicalJitFrame
(
)
const
{
if
(
!
isJSJit
(
)
)
{
return
false
;
}
auto
&
jitFrame
=
jsJitFrame
(
)
;
if
(
jitFrame
.
isBaselineJS
(
)
)
{
return
true
;
}
if
(
jitFrame
.
isIonScripted
(
)
)
{
return
ionInlineFrames_
.
frameNo
(
)
=
=
0
;
}
return
false
;
}
inline
jit
:
:
CommonFrameLayout
*
FrameIter
:
:
physicalJitFrame
(
)
const
{
MOZ_ASSERT
(
isPhysicalJitFrame
(
)
)
;
return
jsJitFrame
(
)
.
current
(
)
;
}
}
#
endif
