#
include
"
vm
/
Instrumentation
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
namespace
js
{
RealmInstrumentation
:
:
RealmInstrumentation
(
Zone
*
zone
JSObject
*
callback
JSObject
*
dbgObject
uint32_t
kinds
)
:
callback
(
callback
)
dbgObject
(
dbgObject
)
kinds
(
kinds
)
{
}
void
RealmInstrumentation
:
:
trace
(
JSTracer
*
trc
)
{
TraceEdge
(
trc
&
callback
"
RealmInstrumentation
:
:
callback
"
)
;
TraceEdge
(
trc
&
dbgObject
"
RealmInstrumentation
:
:
dbgObject
"
)
;
}
enum
InstrumentationHolderSlots
{
RealmInstrumentationSlot
ReservedSlotCount
}
;
static
RealmInstrumentation
*
GetInstrumentation
(
JSObject
*
obj
)
{
Value
v
=
JS_GetReservedSlot
(
obj
RealmInstrumentationSlot
)
;
return
static_cast
<
RealmInstrumentation
*
>
(
v
.
toPrivate
(
)
)
;
}
void
RealmInstrumentation
:
:
holderFinalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
obj
)
;
fop
-
>
delete_
(
obj
instrumentation
MemoryUse
:
:
RealmInstrumentation
)
;
}
void
RealmInstrumentation
:
:
holderTrace
(
JSTracer
*
trc
JSObject
*
obj
)
{
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
obj
)
;
instrumentation
-
>
trace
(
trc
)
;
}
static
const
ClassOps
InstrumentationHolderClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
RealmInstrumentation
:
:
holderFinalize
nullptr
nullptr
nullptr
RealmInstrumentation
:
:
holderTrace
}
;
static
const
Class
InstrumentationHolderClass
=
{
"
Instrumentation
Holder
"
JSCLASS_HAS_RESERVED_SLOTS
(
ReservedSlotCount
)
|
JSCLASS_FOREGROUND_FINALIZE
&
InstrumentationHolderClassOps
JS_NULL_CLASS_SPEC
JS_NULL_CLASS_EXT
}
;
static
const
char
*
instrumentationNames
[
]
=
{
#
define
DEFINE_INSTRUMENTATION_STRING
(
_1
String
_2
)
String
FOR_EACH_INSTRUMENTATION_KIND
(
DEFINE_INSTRUMENTATION_STRING
)
#
undef
DEFINE_INSTRUMENTATION_STRING
}
;
static
bool
StringToInstrumentationKind
(
JSContext
*
cx
HandleString
str
InstrumentationKind
*
result
)
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
instrumentationNames
)
;
i
+
+
)
{
bool
match
;
if
(
!
JS_StringEqualsAscii
(
cx
str
instrumentationNames
[
i
]
&
match
)
)
{
return
false
;
}
if
(
match
)
{
*
result
=
(
InstrumentationKind
)
(
1
<
<
i
)
;
return
true
;
}
}
JS_ReportErrorASCII
(
cx
"
Unknown
instrumentation
kind
"
)
;
return
false
;
}
JSAtom
*
RealmInstrumentation
:
:
getInstrumentationKindName
(
JSContext
*
cx
InstrumentationKind
kind
)
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
instrumentationNames
)
;
i
+
+
)
{
if
(
kind
=
=
(
InstrumentationKind
)
(
1
<
<
i
)
)
{
JSString
*
str
=
JS_AtomizeString
(
cx
instrumentationNames
[
i
]
)
;
if
(
!
str
)
{
return
nullptr
;
}
return
&
str
-
>
asAtom
(
)
;
}
}
MOZ_CRASH
(
"
Unexpected
instrumentation
kind
"
)
;
}
bool
RealmInstrumentation
:
:
install
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleObject
callbackArg
HandleObject
dbgObjectArg
Handle
<
StringVector
>
kindStrings
)
{
MOZ_ASSERT
(
global
=
=
cx
-
>
global
(
)
)
;
if
(
global
-
>
getInstrumentationHolder
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Global
already
has
instrumentation
specified
"
)
;
return
false
;
}
RootedObject
callback
(
cx
callbackArg
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
callback
)
)
{
return
false
;
}
RootedObject
dbgObject
(
cx
dbgObjectArg
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
dbgObject
)
)
{
return
false
;
}
uint32_t
kinds
=
0
;
for
(
size_t
i
=
0
;
i
<
kindStrings
.
length
(
)
;
i
+
+
)
{
HandleString
str
=
kindStrings
[
i
]
;
InstrumentationKind
kind
;
if
(
!
StringToInstrumentationKind
(
cx
str
&
kind
)
)
{
return
false
;
}
kinds
|
=
(
uint32_t
)
kind
;
}
Rooted
<
UniquePtr
<
RealmInstrumentation
>
>
instrumentation
(
cx
MakeUnique
<
RealmInstrumentation
>
(
cx
-
>
zone
(
)
callback
dbgObject
kinds
)
)
;
if
(
!
instrumentation
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JSObject
*
holder
=
NewBuiltinClassInstance
(
cx
&
InstrumentationHolderClass
)
;
if
(
!
holder
)
{
return
false
;
}
InitReservedSlot
(
&
holder
-
>
as
<
NativeObject
>
(
)
RealmInstrumentationSlot
instrumentation
.
release
(
)
MemoryUse
:
:
RealmInstrumentation
)
;
global
-
>
setInstrumentationHolder
(
holder
)
;
return
true
;
}
bool
RealmInstrumentation
:
:
setActive
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
Debugger
*
dbg
bool
active
)
{
MOZ_ASSERT
(
global
=
=
cx
-
>
global
(
)
)
;
RootedObject
holder
(
cx
global
-
>
getInstrumentationHolder
(
)
)
;
if
(
!
holder
)
{
JS_ReportErrorASCII
(
cx
"
Global
does
not
have
instrumentation
specified
"
)
;
return
false
;
}
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
if
(
active
!
=
instrumentation
-
>
active
)
{
instrumentation
-
>
active
=
active
;
js
:
:
CancelOffThreadIonCompile
(
cx
-
>
runtime
(
)
)
;
cx
-
>
zone
(
)
-
>
setPreservingCode
(
false
)
;
cx
-
>
zone
(
)
-
>
discardJitCode
(
cx
-
>
runtime
(
)
-
>
defaultFreeOp
(
)
Zone
:
:
KeepBaselineCode
)
;
}
return
true
;
}
bool
RealmInstrumentation
:
:
isActive
(
GlobalObject
*
global
)
{
JSObject
*
holder
=
global
-
>
getInstrumentationHolder
(
)
;
MOZ_ASSERT
(
holder
)
;
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
return
instrumentation
-
>
active
;
}
const
int32_t
*
RealmInstrumentation
:
:
addressOfActive
(
GlobalObject
*
global
)
{
JSObject
*
holder
=
global
-
>
getInstrumentationHolder
(
)
;
MOZ_ASSERT
(
holder
)
;
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
return
&
instrumentation
-
>
active
;
}
JSObject
*
RealmInstrumentation
:
:
getCallback
(
GlobalObject
*
global
)
{
JSObject
*
holder
=
global
-
>
getInstrumentationHolder
(
)
;
MOZ_ASSERT
(
holder
)
;
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
return
instrumentation
-
>
callback
;
}
uint32_t
RealmInstrumentation
:
:
getInstrumentationKinds
(
GlobalObject
*
global
)
{
JSObject
*
holder
=
global
-
>
getInstrumentationHolder
(
)
;
if
(
!
holder
)
{
return
0
;
}
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
return
instrumentation
-
>
kinds
;
}
bool
RealmInstrumentation
:
:
getScriptId
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleScript
script
int32_t
*
id
)
{
MOZ_ASSERT
(
global
=
=
cx
-
>
global
(
)
)
;
RootedObject
holder
(
cx
global
-
>
getInstrumentationHolder
(
)
)
;
RealmInstrumentation
*
instrumentation
=
GetInstrumentation
(
holder
)
;
RootedObject
dbgObject
(
cx
UncheckedUnwrap
(
instrumentation
-
>
dbgObject
)
)
;
AutoRealm
ar
(
cx
dbgObject
)
;
RootedValue
idValue
(
cx
)
;
if
(
!
DebugAPI
:
:
getScriptInstrumentationId
(
cx
dbgObject
script
&
idValue
)
)
{
return
false
;
}
if
(
!
idValue
.
isNumber
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Instrumentation
ID
not
set
for
script
"
)
;
return
false
;
}
*
id
=
idValue
.
toNumber
(
)
;
return
true
;
}
bool
InstrumentationActiveOperation
(
JSContext
*
cx
MutableHandleValue
rv
)
{
rv
.
setBoolean
(
RealmInstrumentation
:
:
isActive
(
cx
-
>
global
(
)
)
)
;
return
true
;
}
JSObject
*
InstrumentationCallbackOperation
(
JSContext
*
cx
)
{
return
RealmInstrumentation
:
:
getCallback
(
cx
-
>
global
(
)
)
;
}
bool
InstrumentationScriptIdOperation
(
JSContext
*
cx
HandleScript
script
MutableHandleValue
rv
)
{
int32_t
id
;
if
(
!
RealmInstrumentation
:
:
getScriptId
(
cx
cx
-
>
global
(
)
script
&
id
)
)
{
return
false
;
}
rv
.
setInt32
(
id
)
;
return
true
;
}
bool
GlobalHasInstrumentation
(
JSObject
*
global
)
{
return
global
-
>
is
<
js
:
:
GlobalObject
>
(
)
&
&
global
-
>
as
<
js
:
:
GlobalObject
>
(
)
.
getInstrumentationHolder
(
)
;
}
}
