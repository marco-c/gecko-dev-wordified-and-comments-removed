#
include
"
vm
/
Stopwatch
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
processthreadsapi
.
h
>
#
include
<
windows
.
h
>
#
endif
#
include
"
jscompartment
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
Runtime
.
h
"
namespace
js
{
bool
PerformanceMonitoring
:
:
addRecentGroup
(
PerformanceGroup
*
group
)
{
if
(
group
-
>
isUsedInThisIteration
(
)
)
return
true
;
group
-
>
setIsUsedInThisIteration
(
true
)
;
return
recentGroups_
.
append
(
group
)
;
}
void
PerformanceMonitoring
:
:
reset
(
)
{
+
+
iteration_
;
recentGroups_
.
clear
(
)
;
highestTimestampCounter_
=
0
;
}
void
PerformanceMonitoring
:
:
start
(
)
{
if
(
!
isMonitoringJank_
)
return
;
if
(
iteration_
=
=
startedAtIteration_
)
{
return
;
}
startedAtIteration_
=
iteration_
;
if
(
stopwatchStartCallback
)
stopwatchStartCallback
(
iteration_
stopwatchStartClosure
)
;
}
bool
PerformanceMonitoring
:
:
commit
(
)
{
#
if
!
defined
(
MOZ_HAVE_RDTSC
)
return
false
;
#
endif
if
(
!
isMonitoringJank_
)
{
return
true
;
}
if
(
startedAtIteration_
!
=
iteration_
)
{
return
true
;
}
GroupVector
recentGroups
;
recentGroups_
.
swap
(
recentGroups
)
;
bool
success
=
true
;
if
(
stopwatchCommitCallback
)
success
=
stopwatchCommitCallback
(
iteration_
recentGroups
stopwatchCommitClosure
)
;
reset
(
)
;
return
success
;
}
uint64_t
PerformanceMonitoring
:
:
monotonicReadTimestampCounter
(
)
{
#
if
defined
(
MOZ_HAVE_RDTSC
)
const
uint64_t
hardware
=
ReadTimestampCounter
(
)
;
if
(
highestTimestampCounter_
<
hardware
)
highestTimestampCounter_
=
hardware
;
return
highestTimestampCounter_
;
#
else
return
0
;
#
endif
}
void
PerformanceMonitoring
:
:
dispose
(
JSRuntime
*
rt
)
{
reset
(
)
;
for
(
CompartmentsIter
c
(
rt
SkipAtoms
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
performanceMonitoring
.
unlink
(
)
;
}
}
PerformanceGroupHolder
:
:
~
PerformanceGroupHolder
(
)
{
unlink
(
)
;
}
void
PerformanceGroupHolder
:
:
unlink
(
)
{
initialized_
=
false
;
groups_
.
clear
(
)
;
}
const
GroupVector
*
PerformanceGroupHolder
:
:
getGroups
(
JSContext
*
cx
)
{
if
(
initialized_
)
return
&
groups_
;
if
(
!
runtime_
-
>
performanceMonitoring
.
getGroupsCallback
)
return
nullptr
;
if
(
!
runtime_
-
>
performanceMonitoring
.
getGroupsCallback
(
cx
groups_
runtime_
-
>
performanceMonitoring
.
getGroupsClosure
)
)
return
nullptr
;
initialized_
=
true
;
return
&
groups_
;
}
AutoStopwatch
:
:
AutoStopwatch
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
cx_
(
cx
)
iteration_
(
0
)
isMonitoringJank_
(
false
)
isMonitoringCPOW_
(
false
)
cyclesStart_
(
0
)
CPOWTimeStart_
(
0
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
JSCompartment
*
compartment
=
cx_
-
>
compartment
(
)
;
if
(
compartment
-
>
scheduledForDestruction
)
return
;
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
iteration_
=
runtime
-
>
performanceMonitoring
.
iteration
(
)
;
const
GroupVector
*
groups
=
compartment
-
>
performanceMonitoring
.
getGroups
(
cx
)
;
if
(
!
groups
)
{
return
;
}
for
(
auto
group
=
groups
-
>
begin
(
)
;
group
<
groups
-
>
end
(
)
;
group
+
+
)
{
auto
acquired
=
acquireGroup
(
*
group
)
;
if
(
acquired
)
{
if
(
!
groups_
.
append
(
acquired
)
)
MOZ_CRASH
(
)
;
}
}
if
(
groups_
.
length
(
)
=
=
0
)
{
return
;
}
runtime
-
>
performanceMonitoring
.
start
(
)
;
enter
(
)
;
}
AutoStopwatch
:
:
~
AutoStopwatch
(
)
{
if
(
groups_
.
length
(
)
=
=
0
)
{
return
;
}
JSCompartment
*
compartment
=
cx_
-
>
compartment
(
)
;
if
(
compartment
-
>
scheduledForDestruction
)
return
;
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
if
(
iteration_
!
=
runtime
-
>
performanceMonitoring
.
iteration
(
)
)
{
return
;
}
mozilla
:
:
Unused
<
<
exit
(
)
;
for
(
auto
group
=
groups_
.
begin
(
)
;
group
<
groups_
.
end
(
)
;
group
+
+
)
releaseGroup
(
*
group
)
;
}
void
AutoStopwatch
:
:
enter
(
)
{
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
if
(
runtime
-
>
performanceMonitoring
.
isMonitoringCPOW
(
)
)
{
CPOWTimeStart_
=
runtime
-
>
performanceMonitoring
.
totalCPOWTime
;
isMonitoringCPOW_
=
true
;
}
if
(
runtime
-
>
performanceMonitoring
.
isMonitoringJank
(
)
)
{
cyclesStart_
=
this
-
>
getCycles
(
runtime
)
;
cpuStart_
=
this
-
>
getCPU
(
)
;
isMonitoringJank_
=
true
;
}
}
bool
AutoStopwatch
:
:
exit
(
)
{
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
uint64_t
cyclesDelta
=
0
;
if
(
isMonitoringJank_
&
&
runtime
-
>
performanceMonitoring
.
isMonitoringJank
(
)
)
{
const
cpuid_t
cpuEnd
=
this
-
>
getCPU
(
)
;
if
(
isSameCPU
(
cpuStart_
cpuEnd
)
)
{
const
uint64_t
cyclesEnd
=
getCycles
(
runtime
)
;
cyclesDelta
=
cyclesEnd
-
cyclesStart_
;
}
#
if
WINVER
>
=
0x600
updateTelemetry
(
cpuStart_
cpuEnd
)
;
#
elif
defined
(
__linux__
)
updateTelemetry
(
cpuStart_
cpuEnd
)
;
#
endif
}
uint64_t
CPOWTimeDelta
=
0
;
if
(
isMonitoringCPOW_
&
&
runtime
-
>
performanceMonitoring
.
isMonitoringCPOW
(
)
)
{
const
uint64_t
CPOWTimeEnd
=
runtime
-
>
performanceMonitoring
.
totalCPOWTime
;
CPOWTimeDelta
=
getDelta
(
CPOWTimeEnd
CPOWTimeStart_
)
;
}
return
addToGroups
(
cyclesDelta
CPOWTimeDelta
)
;
}
void
AutoStopwatch
:
:
updateTelemetry
(
const
cpuid_t
&
cpuStart_
const
cpuid_t
&
cpuEnd
)
{
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
if
(
isSameCPU
(
cpuStart_
cpuEnd
)
)
runtime
-
>
performanceMonitoring
.
testCpuRescheduling
.
stayed
+
=
1
;
else
runtime
-
>
performanceMonitoring
.
testCpuRescheduling
.
moved
+
=
1
;
}
PerformanceGroup
*
AutoStopwatch
:
:
acquireGroup
(
PerformanceGroup
*
group
)
{
MOZ_ASSERT
(
group
)
;
if
(
group
-
>
isAcquired
(
iteration_
)
)
return
nullptr
;
if
(
!
group
-
>
isActive
(
)
)
return
nullptr
;
group
-
>
acquire
(
iteration_
this
)
;
return
group
;
}
void
AutoStopwatch
:
:
releaseGroup
(
PerformanceGroup
*
group
)
{
MOZ_ASSERT
(
group
)
;
group
-
>
release
(
iteration_
this
)
;
}
bool
AutoStopwatch
:
:
addToGroups
(
uint64_t
cyclesDelta
uint64_t
CPOWTimeDelta
)
{
JSRuntime
*
runtime
=
cx_
-
>
runtime
(
)
;
for
(
auto
group
=
groups_
.
begin
(
)
;
group
<
groups_
.
end
(
)
;
+
+
group
)
{
if
(
!
addToGroup
(
runtime
cyclesDelta
CPOWTimeDelta
*
group
)
)
return
false
;
}
return
true
;
}
bool
AutoStopwatch
:
:
addToGroup
(
JSRuntime
*
runtime
uint64_t
cyclesDelta
uint64_t
CPOWTimeDelta
PerformanceGroup
*
group
)
{
MOZ_ASSERT
(
group
)
;
MOZ_ASSERT
(
group
-
>
isAcquired
(
iteration_
this
)
)
;
if
(
!
runtime
-
>
performanceMonitoring
.
addRecentGroup
(
group
)
)
return
false
;
group
-
>
addRecentTicks
(
iteration_
1
)
;
group
-
>
addRecentCycles
(
iteration_
cyclesDelta
)
;
group
-
>
addRecentCPOW
(
iteration_
CPOWTimeDelta
)
;
return
true
;
}
uint64_t
AutoStopwatch
:
:
getDelta
(
const
uint64_t
end
const
uint64_t
start
)
const
{
if
(
start
>
=
end
)
return
0
;
return
end
-
start
;
}
uint64_t
AutoStopwatch
:
:
getCycles
(
JSRuntime
*
runtime
)
const
{
return
runtime
-
>
performanceMonitoring
.
monotonicReadTimestampCounter
(
)
;
}
cpuid_t
inline
AutoStopwatch
:
:
getCPU
(
)
const
{
#
if
defined
(
XP_WIN
)
&
&
WINVER
>
=
_WIN32_WINNT_VISTA
PROCESSOR_NUMBER
proc
;
GetCurrentProcessorNumberEx
(
&
proc
)
;
cpuid_t
result
(
proc
.
Group
proc
.
Number
)
;
return
result
;
#
elif
defined
(
XP_LINUX
)
return
sched_getcpu
(
)
;
#
else
return
{
}
;
#
endif
}
bool
inline
AutoStopwatch
:
:
isSameCPU
(
const
cpuid_t
&
a
const
cpuid_t
&
b
)
const
{
#
if
defined
(
XP_WIN
)
&
&
WINVER
>
=
_WIN32_WINNT_VISTA
return
a
.
group_
=
=
b
.
group_
&
&
a
.
number_
=
=
b
.
number_
;
#
elif
defined
(
XP_LINUX
)
return
a
=
=
b
;
#
else
return
true
;
#
endif
}
PerformanceGroup
:
:
PerformanceGroup
(
)
:
recentCycles_
(
0
)
recentTicks_
(
0
)
recentCPOW_
(
0
)
iteration_
(
0
)
isActive_
(
false
)
isUsedInThisIteration_
(
false
)
owner_
(
nullptr
)
refCount_
(
0
)
{
}
uint64_t
PerformanceGroup
:
:
iteration
(
)
const
{
return
iteration_
;
}
bool
PerformanceGroup
:
:
isAcquired
(
uint64_t
it
)
const
{
return
owner_
!
=
nullptr
&
&
iteration_
=
=
it
;
}
bool
PerformanceGroup
:
:
isAcquired
(
uint64_t
it
const
AutoStopwatch
*
owner
)
const
{
return
owner_
=
=
owner
&
&
iteration_
=
=
it
;
}
void
PerformanceGroup
:
:
acquire
(
uint64_t
it
const
AutoStopwatch
*
owner
)
{
if
(
iteration_
!
=
it
)
{
resetRecentData
(
)
;
}
iteration_
=
it
;
owner_
=
owner
;
}
void
PerformanceGroup
:
:
release
(
uint64_t
it
const
AutoStopwatch
*
owner
)
{
if
(
iteration_
!
=
it
)
return
;
MOZ_ASSERT
(
owner
=
=
owner_
|
|
owner_
=
=
nullptr
)
;
owner_
=
nullptr
;
}
void
PerformanceGroup
:
:
resetRecentData
(
)
{
recentCycles_
=
0
;
recentTicks_
=
0
;
recentCPOW_
=
0
;
isUsedInThisIteration_
=
false
;
}
uint64_t
PerformanceGroup
:
:
recentCycles
(
uint64_t
iteration
)
const
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
return
recentCycles_
;
}
void
PerformanceGroup
:
:
addRecentCycles
(
uint64_t
iteration
uint64_t
cycles
)
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
recentCycles_
+
=
cycles
;
}
uint64_t
PerformanceGroup
:
:
recentTicks
(
uint64_t
iteration
)
const
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
return
recentTicks_
;
}
void
PerformanceGroup
:
:
addRecentTicks
(
uint64_t
iteration
uint64_t
ticks
)
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
recentTicks_
+
=
ticks
;
}
uint64_t
PerformanceGroup
:
:
recentCPOW
(
uint64_t
iteration
)
const
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
return
recentCPOW_
;
}
void
PerformanceGroup
:
:
addRecentCPOW
(
uint64_t
iteration
uint64_t
CPOW
)
{
MOZ_ASSERT
(
iteration
=
=
iteration_
)
;
recentCPOW_
+
=
CPOW
;
}
bool
PerformanceGroup
:
:
isActive
(
)
const
{
return
isActive_
;
}
void
PerformanceGroup
:
:
setIsActive
(
bool
value
)
{
isActive_
=
value
;
}
void
PerformanceGroup
:
:
setIsUsedInThisIteration
(
bool
value
)
{
isUsedInThisIteration_
=
value
;
}
bool
PerformanceGroup
:
:
isUsedInThisIteration
(
)
const
{
return
isUsedInThisIteration_
;
}
void
PerformanceGroup
:
:
AddRef
(
)
{
+
+
refCount_
;
}
void
PerformanceGroup
:
:
Release
(
)
{
MOZ_ASSERT
(
refCount_
>
0
)
;
-
-
refCount_
;
if
(
refCount_
>
0
)
return
;
this
-
>
Delete
(
)
;
}
JS_PUBLIC_API
(
bool
)
SetStopwatchStartCallback
(
JSRuntime
*
rt
StopwatchStartCallback
cb
void
*
closure
)
{
rt
-
>
performanceMonitoring
.
setStopwatchStartCallback
(
cb
closure
)
;
return
true
;
}
JS_PUBLIC_API
(
bool
)
SetStopwatchCommitCallback
(
JSRuntime
*
rt
StopwatchCommitCallback
cb
void
*
closure
)
{
rt
-
>
performanceMonitoring
.
setStopwatchCommitCallback
(
cb
closure
)
;
return
true
;
}
JS_PUBLIC_API
(
bool
)
SetGetPerformanceGroupsCallback
(
JSRuntime
*
rt
GetGroupsCallback
cb
void
*
closure
)
{
rt
-
>
performanceMonitoring
.
setGetGroupsCallback
(
cb
closure
)
;
return
true
;
}
JS_PUBLIC_API
(
bool
)
FlushPerformanceMonitoring
(
JSRuntime
*
rt
)
{
return
rt
-
>
performanceMonitoring
.
commit
(
)
;
}
JS_PUBLIC_API
(
void
)
ResetPerformanceMonitoring
(
JSRuntime
*
rt
)
{
return
rt
-
>
performanceMonitoring
.
reset
(
)
;
}
JS_PUBLIC_API
(
void
)
DisposePerformanceMonitoring
(
JSRuntime
*
rt
)
{
return
rt
-
>
performanceMonitoring
.
dispose
(
rt
)
;
}
JS_PUBLIC_API
(
bool
)
SetStopwatchIsMonitoringJank
(
JSRuntime
*
rt
bool
value
)
{
return
rt
-
>
performanceMonitoring
.
setIsMonitoringJank
(
value
)
;
}
JS_PUBLIC_API
(
bool
)
GetStopwatchIsMonitoringJank
(
JSRuntime
*
rt
)
{
return
rt
-
>
performanceMonitoring
.
isMonitoringJank
(
)
;
}
JS_PUBLIC_API
(
bool
)
SetStopwatchIsMonitoringCPOW
(
JSRuntime
*
rt
bool
value
)
{
return
rt
-
>
performanceMonitoring
.
setIsMonitoringCPOW
(
value
)
;
}
JS_PUBLIC_API
(
bool
)
GetStopwatchIsMonitoringCPOW
(
JSRuntime
*
rt
)
{
return
rt
-
>
performanceMonitoring
.
isMonitoringCPOW
(
)
;
}
JS_PUBLIC_API
(
void
)
GetPerfMonitoringTestCpuRescheduling
(
JSRuntime
*
rt
uint64_t
*
stayed
uint64_t
*
moved
)
{
*
stayed
=
rt
-
>
performanceMonitoring
.
testCpuRescheduling
.
stayed
;
*
moved
=
rt
-
>
performanceMonitoring
.
testCpuRescheduling
.
moved
;
}
JS_PUBLIC_API
(
void
)
AddCPOWPerformanceDelta
(
JSRuntime
*
rt
uint64_t
delta
)
{
rt
-
>
performanceMonitoring
.
totalCPOWTime
+
=
delta
;
}
}
