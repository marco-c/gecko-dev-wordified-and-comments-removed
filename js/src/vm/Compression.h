#
ifndef
vm_Compression_h
#
define
vm_Compression_h
#
include
<
zlib
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
struct
CompressedDataHeader
{
uint32_t
compressedBytes
;
}
;
class
Compressor
{
public
:
static
constexpr
size_t
CHUNK_SIZE
=
64
*
1024
;
private
:
static
constexpr
size_t
MAX_INPUT_SIZE
=
2
*
1024
;
z_stream
zs
;
const
unsigned
char
*
inp
;
size_t
inplen
;
size_t
outbytes
;
bool
initialized
;
bool
finished
;
uint32_t
currentChunkSize
;
js
:
:
Vector
<
uint32_t
8
SystemAllocPolicy
>
chunkOffsets
;
public
:
enum
Status
{
MOREOUTPUT
DONE
CONTINUE
OOM
}
;
Compressor
(
const
unsigned
char
*
inp
size_t
inplen
)
;
~
Compressor
(
)
;
bool
init
(
)
;
void
setOutput
(
unsigned
char
*
out
size_t
outlen
)
;
Status
compressMore
(
)
;
size_t
sizeOfChunkOffsets
(
)
const
{
return
chunkOffsets
.
length
(
)
*
sizeof
(
chunkOffsets
[
0
]
)
;
}
size_t
totalBytesNeeded
(
)
const
;
void
finish
(
char
*
dest
size_t
destBytes
)
;
static
void
toChunkOffset
(
size_t
uncompressedOffset
size_t
*
chunk
size_t
*
chunkOffset
)
{
*
chunk
=
uncompressedOffset
/
CHUNK_SIZE
;
*
chunkOffset
=
uncompressedOffset
%
CHUNK_SIZE
;
}
static
size_t
chunkSize
(
size_t
uncompressedBytes
size_t
chunk
)
{
MOZ_ASSERT
(
uncompressedBytes
>
0
"
must
have
uncompressed
data
to
chunk
"
)
;
size_t
startOfChunkBytes
=
chunk
*
CHUNK_SIZE
;
MOZ_ASSERT
(
startOfChunkBytes
<
uncompressedBytes
"
chunk
must
refer
to
bytes
not
exceeding
"
"
|
uncompressedBytes
|
"
)
;
size_t
remaining
=
uncompressedBytes
-
startOfChunkBytes
;
return
remaining
<
CHUNK_SIZE
?
remaining
:
CHUNK_SIZE
;
}
}
;
bool
DecompressString
(
const
unsigned
char
*
inp
size_t
inplen
unsigned
char
*
out
size_t
outlen
)
;
bool
DecompressStringChunk
(
const
unsigned
char
*
inp
size_t
chunk
unsigned
char
*
out
size_t
outlen
)
;
}
#
endif
