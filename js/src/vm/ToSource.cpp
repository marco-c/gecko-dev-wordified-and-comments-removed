#
include
"
vm
/
ToSource
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
Boolean
.
h
"
#
include
"
builtin
/
Object
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Symbol
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
IsNegativeZero
;
static
JSString
*
StringToSource
(
JSContext
*
cx
JSString
*
str
)
{
UniqueChars
chars
=
QuoteString
(
cx
str
'
"
'
)
;
if
(
!
chars
)
{
return
nullptr
;
}
return
NewStringCopyZ
<
CanGC
>
(
cx
chars
.
get
(
)
)
;
}
static
JSString
*
SymbolToSource
(
JSContext
*
cx
Symbol
*
symbol
)
{
RootedString
desc
(
cx
symbol
-
>
description
(
)
)
;
SymbolCode
code
=
symbol
-
>
code
(
)
;
if
(
symbol
-
>
isWellKnownSymbol
(
)
)
{
return
desc
;
}
JSStringBuilder
buf
(
cx
)
;
if
(
code
=
=
SymbolCode
:
:
PrivateNameSymbol
)
{
MOZ_ASSERT
(
desc
)
;
if
(
!
buf
.
append
(
'
#
'
)
|
|
!
buf
.
append
(
desc
)
)
{
return
nullptr
;
}
}
else
{
MOZ_ASSERT
(
code
=
=
SymbolCode
:
:
InSymbolRegistry
|
|
code
=
=
SymbolCode
:
:
UniqueSymbol
)
;
if
(
code
=
=
SymbolCode
:
:
InSymbolRegistry
?
!
buf
.
append
(
"
Symbol
.
for
(
"
)
:
!
buf
.
append
(
"
Symbol
(
"
)
)
{
return
nullptr
;
}
if
(
desc
)
{
UniqueChars
quoted
=
QuoteString
(
cx
desc
'
"
'
)
;
if
(
!
quoted
|
|
!
buf
.
append
(
quoted
.
get
(
)
strlen
(
quoted
.
get
(
)
)
)
)
{
return
nullptr
;
}
}
if
(
!
buf
.
append
(
'
)
'
)
)
{
return
nullptr
;
}
}
return
buf
.
finishString
(
)
;
}
static
JSString
*
BoxedToSource
(
JSContext
*
cx
HandleObject
obj
const
char
*
constructor
)
{
RootedValue
value
(
cx
)
;
if
(
!
Unbox
(
cx
obj
&
value
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
value
.
isUndefined
(
)
)
;
RootedString
str
(
cx
ValueToSource
(
cx
value
)
)
;
if
(
!
str
)
{
return
nullptr
;
}
JSStringBuilder
buf
(
cx
)
;
if
(
!
buf
.
append
(
"
new
"
)
|
|
!
buf
.
append
(
constructor
strlen
(
constructor
)
)
|
|
!
buf
.
append
(
'
(
'
)
|
|
!
buf
.
append
(
str
)
|
|
!
buf
.
append
(
'
)
'
)
)
{
return
nullptr
;
}
return
buf
.
finishString
(
)
;
}
JSString
*
js
:
:
ValueToSource
(
JSContext
*
cx
HandleValue
v
)
{
if
(
!
CheckRecursionLimit
(
cx
)
)
{
return
nullptr
;
}
cx
-
>
check
(
v
)
;
switch
(
v
.
type
(
)
)
{
case
JS
:
:
ValueType
:
:
Undefined
:
return
cx
-
>
names
(
)
.
void0
;
case
JS
:
:
ValueType
:
:
String
:
return
StringToSource
(
cx
v
.
toString
(
)
)
;
case
JS
:
:
ValueType
:
:
Symbol
:
return
SymbolToSource
(
cx
v
.
toSymbol
(
)
)
;
case
JS
:
:
ValueType
:
:
Null
:
return
cx
-
>
names
(
)
.
null
;
case
JS
:
:
ValueType
:
:
Boolean
:
return
BooleanToString
(
cx
v
.
toBoolean
(
)
)
;
case
JS
:
:
ValueType
:
:
Double
:
if
(
IsNegativeZero
(
v
.
toDouble
(
)
)
)
{
static
const
Latin1Char
negativeZero
[
]
=
{
'
-
'
'
0
'
}
;
return
NewStringCopyN
<
CanGC
>
(
cx
negativeZero
mozilla
:
:
ArrayLength
(
negativeZero
)
)
;
}
[
[
fallthrough
]
]
;
case
JS
:
:
ValueType
:
:
Int32
:
return
ToString
<
CanGC
>
(
cx
v
)
;
case
JS
:
:
ValueType
:
:
BigInt
:
{
RootedString
str
(
cx
ToString
<
CanGC
>
(
cx
v
)
)
;
if
(
!
str
)
{
return
nullptr
;
}
RootedString
n
(
cx
cx
-
>
staticStrings
(
)
.
getUnit
(
'
n
'
)
)
;
return
ConcatStrings
<
CanGC
>
(
cx
str
n
)
;
}
case
JS
:
:
ValueType
:
:
Object
:
{
RootedValue
fval
(
cx
)
;
RootedObject
obj
(
cx
&
v
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
toSource
&
fval
)
)
{
return
nullptr
;
}
if
(
IsCallable
(
fval
)
)
{
RootedValue
v
(
cx
)
;
if
(
!
js
:
:
Call
(
cx
fval
obj
&
v
)
)
{
return
nullptr
;
}
return
ToString
<
CanGC
>
(
cx
v
)
;
}
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
{
return
nullptr
;
}
switch
(
cls
)
{
case
ESClass
:
:
Function
:
return
fun_toStringHelper
(
cx
obj
true
)
;
case
ESClass
:
:
Array
:
return
ArrayToSource
(
cx
obj
)
;
case
ESClass
:
:
Error
:
return
ErrorToSource
(
cx
obj
)
;
case
ESClass
:
:
RegExp
:
{
FixedInvokeArgs
<
0
>
args
(
cx
)
;
RootedValue
rval
(
cx
)
;
if
(
!
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
RegExpToString
v
args
&
rval
)
)
{
return
nullptr
;
}
return
ToString
<
CanGC
>
(
cx
rval
)
;
}
case
ESClass
:
:
Boolean
:
return
BoxedToSource
(
cx
obj
"
Boolean
"
)
;
case
ESClass
:
:
Number
:
return
BoxedToSource
(
cx
obj
"
Number
"
)
;
case
ESClass
:
:
String
:
return
BoxedToSource
(
cx
obj
"
String
"
)
;
case
ESClass
:
:
Date
:
return
BoxedToSource
(
cx
obj
"
Date
"
)
;
default
:
return
ObjectToSource
(
cx
obj
)
;
}
}
case
JS
:
:
ValueType
:
:
PrivateGCThing
:
case
JS
:
:
ValueType
:
:
Magic
:
MOZ_ASSERT_UNREACHABLE
(
"
internal
value
types
shouldn
'
t
leak
into
places
"
"
wanting
source
representations
"
)
;
return
nullptr
;
}
MOZ_ASSERT_UNREACHABLE
(
"
shouldn
'
t
see
an
unrecognized
value
type
"
)
;
return
nullptr
;
}
