#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jsfriendapi
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
friend
/
WindowProxy
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
js
/
WrapperCallbacks
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
proxy
/
DOMProxy
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
ifdef
ENABLE_RECORD_TUPLE
#
include
"
vm
/
RecordTupleShared
.
h
"
#
endif
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
AutoStableStringChars
;
Compartment
:
:
Compartment
(
Zone
*
zone
bool
invisibleToDebugger
)
:
zone_
(
zone
)
runtime_
(
zone
-
>
runtimeFromAnyThread
(
)
)
invisibleToDebugger_
(
invisibleToDebugger
)
crossCompartmentObjectWrappers
(
zone
0
)
realms_
(
zone
)
{
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Compartment
:
:
checkObjectWrappersAfterMovingGC
(
)
{
for
(
ObjectWrapperEnum
e
(
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
key
=
e
.
front
(
)
.
key
(
)
;
CheckGCThingAfterMovingGC
(
key
.
get
(
)
)
;
auto
ptr
=
crossCompartmentObjectWrappers
.
lookup
(
key
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
bool
Compartment
:
:
putWrapper
(
JSContext
*
cx
JSObject
*
wrapped
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
!
js
:
:
IsProxy
(
wrapper
)
|
|
js
:
:
GetProxyHandler
(
wrapper
)
-
>
family
(
)
!
=
js
:
:
GetDOMRemoteProxyHandlerFamily
(
)
)
;
if
(
!
crossCompartmentObjectWrappers
.
put
(
wrapped
wrapper
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
Compartment
:
:
putWrapper
(
JSContext
*
cx
JSString
*
wrapped
JSString
*
wrapper
)
{
if
(
!
zone
(
)
-
>
crossZoneStringWrappers
(
)
.
put
(
wrapped
wrapper
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
Compartment
:
:
removeWrapper
(
js
:
:
ObjectWrapperMap
:
:
Ptr
p
)
{
JSObject
*
key
=
p
-
>
key
(
)
;
JSObject
*
value
=
p
-
>
value
(
)
.
unbarrieredGet
(
)
;
if
(
js
:
:
gc
:
:
detail
:
:
GetDelegate
(
value
)
=
=
key
)
{
key
-
>
zone
(
)
-
>
beforeClearDelegate
(
value
key
)
;
}
crossCompartmentObjectWrappers
.
remove
(
p
)
;
}
JSString
*
js
:
:
CopyStringPure
(
JSContext
*
cx
JSString
*
str
)
{
size_t
len
=
str
-
>
length
(
)
;
JSString
*
copy
;
if
(
str
-
>
isLinear
(
)
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyN
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
len
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyNDontDeflate
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
len
)
;
}
if
(
copy
)
{
return
copy
;
}
AutoStableStringChars
chars
(
cx
)
;
if
(
!
chars
.
init
(
cx
str
)
)
{
return
nullptr
;
}
return
chars
.
isLatin1
(
)
?
NewStringCopyN
<
CanGC
>
(
cx
chars
.
latin1Range
(
)
.
begin
(
)
.
get
(
)
len
)
:
NewStringCopyNDontDeflate
<
CanGC
>
(
cx
chars
.
twoByteRange
(
)
.
begin
(
)
.
get
(
)
len
)
;
}
if
(
str
-
>
hasLatin1Chars
(
)
)
{
UniquePtr
<
Latin1Char
[
]
JS
:
:
FreePolicy
>
copiedChars
=
str
-
>
asRope
(
)
.
copyLatin1Chars
(
cx
js
:
:
StringBufferArena
)
;
if
(
!
copiedChars
)
{
return
nullptr
;
}
return
NewString
<
CanGC
>
(
cx
std
:
:
move
(
copiedChars
)
len
)
;
}
UniqueTwoByteChars
copiedChars
=
str
-
>
asRope
(
)
.
copyTwoByteChars
(
cx
js
:
:
StringBufferArena
)
;
if
(
!
copiedChars
)
{
return
nullptr
;
}
return
NewStringDontDeflate
<
CanGC
>
(
cx
std
:
:
move
(
copiedChars
)
len
)
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleString
strp
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
JSString
*
str
=
strp
;
if
(
str
-
>
zoneFromAnyThread
(
)
=
=
zone
(
)
)
{
return
true
;
}
if
(
str
-
>
isAtom
(
)
)
{
cx
-
>
markAtom
(
&
str
-
>
asAtom
(
)
)
;
return
true
;
}
if
(
StringWrapperMap
:
:
Ptr
p
=
lookupWrapper
(
str
)
)
{
strp
.
set
(
p
-
>
value
(
)
.
get
(
)
)
;
return
true
;
}
JSString
*
copy
=
CopyStringPure
(
cx
str
)
;
if
(
!
copy
)
{
return
false
;
}
if
(
!
putWrapper
(
cx
strp
copy
)
)
{
return
false
;
}
strp
.
set
(
copy
)
;
return
true
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleBigInt
bi
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
bi
-
>
zone
(
)
=
=
cx
-
>
zone
(
)
)
{
return
true
;
}
BigInt
*
copy
=
BigInt
:
:
copy
(
cx
bi
)
;
if
(
!
copy
)
{
return
false
;
}
bi
.
set
(
copy
)
;
return
true
;
}
bool
Compartment
:
:
getNonWrapperObjectForCurrentCompartment
(
JSContext
*
cx
HandleObject
origObj
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
global
(
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
obj
.
set
(
ToWindowProxyIfWindow
(
obj
)
)
;
return
true
;
}
RootedObject
objectPassedToWrap
(
cx
obj
)
;
obj
.
set
(
UncheckedUnwrap
(
obj
true
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
if
(
!
AllowNewWrapper
(
this
obj
)
)
{
obj
.
set
(
NewDeadProxyObject
(
cx
IsCallableFlag
(
obj
-
>
isCallable
(
)
)
IsConstructorFlag
(
obj
-
>
isConstructor
(
)
)
)
)
;
return
!
!
obj
;
}
if
(
IsWindow
(
obj
)
)
{
obj
.
set
(
ToWindowProxyIfWindow
(
obj
)
)
;
obj
.
set
(
UncheckedUnwrap
(
obj
)
)
;
if
(
JS_IsDeadWrapper
(
obj
)
)
{
obj
.
set
(
NewDeadProxyObject
(
cx
obj
)
)
;
return
!
!
obj
;
}
MOZ_ASSERT
(
IsWindowProxy
(
obj
)
|
|
IsDOMRemoteProxyObject
(
obj
)
)
;
ExposeObjectToActiveJS
(
obj
)
;
}
if
(
JS_IsDeadWrapper
(
obj
)
)
{
obj
.
set
(
NewDeadProxyObject
(
cx
obj
)
)
;
return
!
!
obj
;
}
auto
preWrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
preWrap
;
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
checkSystem
(
cx
)
)
{
return
false
;
}
if
(
preWrap
)
{
preWrap
(
cx
cx
-
>
global
(
)
origObj
obj
objectPassedToWrap
obj
)
;
if
(
!
obj
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
bool
Compartment
:
:
getOrCreateWrapper
(
JSContext
*
cx
HandleObject
existing
MutableHandleObject
obj
)
{
if
(
ObjectWrapperMap
:
:
Ptr
p
=
lookupWrapper
(
obj
)
)
{
obj
.
set
(
p
-
>
value
(
)
.
get
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
return
true
;
}
ExposeObjectToActiveJS
(
obj
)
;
auto
wrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
wrap
;
RootedObject
wrapper
(
cx
wrap
(
cx
existing
obj
)
)
;
if
(
!
wrapper
)
{
return
false
;
}
MOZ_ASSERT
(
Wrapper
:
:
wrappedObject
(
wrapper
)
=
=
obj
)
;
if
(
!
putWrapper
(
cx
obj
wrapper
)
)
{
if
(
wrapper
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
{
NukeCrossCompartmentWrapper
(
cx
wrapper
)
;
}
return
false
;
}
obj
.
set
(
wrapper
)
;
return
true
;
}
#
ifdef
ENABLE_RECORD_TUPLE
bool
Compartment
:
:
wrapExtendedPrimitive
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
IsExtendedPrimitive
(
*
obj
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
return
true
;
}
JSObject
*
copy
=
CopyExtendedPrimitive
(
cx
obj
)
;
if
(
!
copy
)
{
return
false
;
}
obj
.
set
(
copy
)
;
return
true
;
}
#
endif
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
!
obj
)
{
return
true
;
}
#
ifdef
ENABLE_RECORD_TUPLE
MOZ_ASSERT
(
!
IsExtendedPrimitive
(
*
obj
)
)
;
#
endif
AutoDisableProxyCheck
adpc
;
JS
:
:
AssertObjectIsNotGray
(
obj
)
;
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
nullptr
obj
)
)
{
return
false
;
}
if
(
obj
-
>
compartment
(
)
!
=
this
)
{
if
(
!
getOrCreateWrapper
(
cx
nullptr
obj
)
)
{
return
false
;
}
}
ExposeObjectToActiveJS
(
obj
)
;
return
true
;
}
bool
Compartment
:
:
rewrap
(
JSContext
*
cx
MutableHandleObject
obj
HandleObject
existingArg
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
existingArg
)
;
MOZ_ASSERT
(
existingArg
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
IsDeadProxyObject
(
existingArg
)
)
;
AutoDisableProxyCheck
adpc
;
RootedObject
existing
(
cx
existingArg
)
;
if
(
existing
-
>
hasStaticPrototype
(
)
|
|
existing
-
>
isCallable
(
)
|
|
obj
-
>
isCallable
(
)
)
{
existing
.
set
(
nullptr
)
;
}
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
existingArg
obj
)
)
{
return
false
;
}
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
return
true
;
}
return
getOrCreateWrapper
(
cx
existing
obj
)
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
{
if
(
desc
.
hasGetter
(
)
)
{
if
(
!
wrap
(
cx
desc
.
getter
(
)
)
)
{
return
false
;
}
}
if
(
desc
.
hasSetter
(
)
)
{
if
(
!
wrap
(
cx
desc
.
setter
(
)
)
)
{
return
false
;
}
}
if
(
desc
.
hasValue
(
)
)
{
if
(
!
wrap
(
cx
desc
.
value
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
{
if
(
desc
.
isNothing
(
)
)
{
return
true
;
}
Rooted
<
PropertyDescriptor
>
desc_
(
cx
*
desc
)
;
if
(
!
wrap
(
cx
&
desc_
)
)
{
return
false
;
}
desc
.
set
(
mozilla
:
:
Some
(
desc_
.
get
(
)
)
)
;
return
true
;
}
bool
Compartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
vec
)
{
for
(
size_t
i
=
0
;
i
<
vec
.
length
(
)
;
+
+
i
)
{
if
(
!
wrap
(
cx
vec
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
static
inline
bool
ShouldTraceWrapper
(
JSObject
*
wrapper
Compartment
:
:
EdgeSelector
whichEdges
)
{
if
(
whichEdges
=
=
Compartment
:
:
AllEdges
)
{
return
true
;
}
bool
isGray
=
wrapper
-
>
isMarkedGray
(
)
;
return
(
whichEdges
=
=
Compartment
:
:
NonGrayEdges
&
&
!
isGray
)
|
|
(
whichEdges
=
=
Compartment
:
:
GrayEdges
&
&
isGray
)
;
}
void
Compartment
:
:
traceWrapperTargetsInCollectedZones
(
JSTracer
*
trc
EdgeSelector
whichEdges
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
MOZ_ASSERT
(
!
zone
(
)
-
>
isCollectingFromAnyThread
(
)
|
|
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
WrappedObjectCompartmentEnum
c
(
this
)
;
!
c
.
empty
(
)
;
c
.
popFront
(
)
)
{
Zone
*
zone
=
c
.
front
(
)
-
>
zone
(
)
;
if
(
!
zone
-
>
isCollectingFromAnyThread
(
)
)
{
continue
;
}
for
(
ObjectWrapperEnum
e
(
this
c
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSObject
*
obj
=
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
;
ProxyObject
*
wrapper
=
&
obj
-
>
as
<
ProxyObject
>
(
)
;
if
(
ShouldTraceWrapper
(
wrapper
whichEdges
)
)
{
ProxyObject
:
:
traceEdgeToTarget
(
trc
wrapper
)
;
}
}
}
}
void
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
EdgeSelector
whichEdges
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
for
(
ZonesIter
zone
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isCollectingFromAnyThread
(
)
)
{
continue
;
}
for
(
CompartmentsInZoneIter
c
(
zone
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
traceWrapperTargetsInCollectedZones
(
trc
whichEdges
)
;
}
}
if
(
whichEdges
!
=
GrayEdges
)
{
DebugAPI
:
:
traceCrossCompartmentEdges
(
trc
)
;
}
}
void
Compartment
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
crossCompartmentObjectWrappers
.
sweepAfterMinorGC
(
trc
)
;
for
(
RealmsInCompartmentIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
sweepAfterMinorGC
(
trc
)
;
}
}
void
Compartment
:
:
traceCrossCompartmentObjectWrapperEdges
(
JSTracer
*
trc
)
{
crossCompartmentObjectWrappers
.
traceWeak
(
trc
)
;
}
void
Compartment
:
:
fixupCrossCompartmentObjectWrappersAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
traceCrossCompartmentObjectWrapperEdges
(
trc
)
;
traceWrapperTargetsInCollectedZones
(
trc
AllEdges
)
;
}
void
Compartment
:
:
fixupAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
zone
(
)
-
>
isGCCompacting
(
)
)
;
for
(
RealmsInCompartmentIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
fixupAfterMovingGC
(
trc
)
;
}
traceCrossCompartmentObjectWrapperEdges
(
trc
)
;
}
void
Compartment
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
compartmentObjects
size_t
*
crossCompartmentWrappersTables
size_t
*
compartmentsPrivateData
)
{
*
compartmentObjects
+
=
mallocSizeOf
(
this
)
;
*
crossCompartmentWrappersTables
+
=
crossCompartmentObjectWrappers
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
auto
callback
=
runtime_
-
>
sizeOfIncludingThisCompartmentCallback
)
{
*
compartmentsPrivateData
+
=
callback
(
mallocSizeOf
this
)
;
}
}
GlobalObject
&
Compartment
:
:
firstGlobal
(
)
const
{
for
(
Realm
*
realm
:
realms_
)
{
if
(
!
realm
-
>
hasLiveGlobal
(
)
)
{
continue
;
}
GlobalObject
*
global
=
realm
-
>
maybeGlobal
(
)
;
ExposeObjectToActiveJS
(
global
)
;
return
*
global
;
}
MOZ_CRASH
(
"
If
all
our
globals
are
dead
why
is
someone
expecting
a
global
?
"
)
;
}
JS_PUBLIC_API
JSObject
*
js
:
:
GetFirstGlobalInCompartment
(
JS
:
:
Compartment
*
comp
)
{
return
&
comp
-
>
firstGlobal
(
)
;
}
JS_PUBLIC_API
bool
js
:
:
CompartmentHasLiveGlobal
(
JS
:
:
Compartment
*
comp
)
{
MOZ_ASSERT
(
comp
)
;
for
(
Realm
*
r
:
comp
-
>
realms
(
)
)
{
if
(
r
-
>
hasLiveGlobal
(
)
)
{
return
true
;
}
}
return
false
;
}
