#
ifndef
vm_Unicode_h
#
define
vm_Unicode_h
#
include
"
jspubtd
.
h
"
#
include
"
vm
/
UnicodeNonBMP
.
h
"
namespace
js
{
namespace
unicode
{
extern
const
bool
js_isidstart
[
]
;
extern
const
bool
js_isident
[
]
;
extern
const
bool
js_isspace
[
]
;
namespace
CharFlag
{
const
uint8_t
SPACE
=
1
<
<
0
;
const
uint8_t
UNICODE_ID_START
=
1
<
<
1
;
const
uint8_t
UNICODE_ID_CONTINUE_ONLY
=
1
<
<
2
;
const
uint8_t
UNICODE_ID_CONTINUE
=
UNICODE_ID_START
+
UNICODE_ID_CONTINUE_ONLY
;
}
constexpr
char16_t
NO_BREAK_SPACE
=
0x00A0
;
constexpr
char16_t
MICRO_SIGN
=
0x00B5
;
constexpr
char16_t
LATIN_CAPITAL_LETTER_A_WITH_GRAVE
=
0x00C0
;
constexpr
char16_t
MULTIPLICATION_SIGN
=
0x00D7
;
constexpr
char16_t
LATIN_SMALL_LETTER_SHARP_S
=
0x00DF
;
constexpr
char16_t
LATIN_SMALL_LETTER_A_WITH_GRAVE
=
0x00E0
;
constexpr
char16_t
DIVISION_SIGN
=
0x00F7
;
constexpr
char16_t
LATIN_SMALL_LETTER_Y_WITH_DIAERESIS
=
0x00FF
;
constexpr
char16_t
LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE
=
0x0130
;
constexpr
char16_t
COMBINING_DOT_ABOVE
=
0x0307
;
constexpr
char16_t
GREEK_CAPITAL_LETTER_SIGMA
=
0x03A3
;
constexpr
char16_t
GREEK_SMALL_LETTER_FINAL_SIGMA
=
0x03C2
;
constexpr
char16_t
GREEK_SMALL_LETTER_SIGMA
=
0x03C3
;
constexpr
char16_t
LINE_SEPARATOR
=
0x2028
;
constexpr
char16_t
PARA_SEPARATOR
=
0x2029
;
constexpr
char16_t
BYTE_ORDER_MARK2
=
0xFFFE
;
const
char16_t
LeadSurrogateMin
=
0xD800
;
const
char16_t
LeadSurrogateMax
=
0xDBFF
;
const
char16_t
TrailSurrogateMin
=
0xDC00
;
const
char16_t
TrailSurrogateMax
=
0xDFFF
;
const
uint32_t
UTF16Max
=
0xFFFF
;
const
uint32_t
NonBMPMin
=
0x10000
;
const
uint32_t
NonBMPMax
=
0x10FFFF
;
class
CharacterInfo
{
public
:
uint16_t
upperCase
;
uint16_t
lowerCase
;
uint8_t
flags
;
inline
bool
isSpace
(
)
const
{
return
flags
&
CharFlag
:
:
SPACE
;
}
inline
bool
isUnicodeIDStart
(
)
const
{
return
flags
&
CharFlag
:
:
UNICODE_ID_START
;
}
inline
bool
isUnicodeIDContinue
(
)
const
{
return
flags
&
CharFlag
:
:
UNICODE_ID_CONTINUE
;
}
}
;
extern
const
uint8_t
index1
[
]
;
extern
const
uint8_t
index2
[
]
;
extern
const
CharacterInfo
js_charinfo
[
]
;
inline
const
CharacterInfo
&
CharInfo
(
char16_t
code
)
{
const
size_t
shift
=
6
;
size_t
index
=
index1
[
code
>
>
shift
]
;
index
=
index2
[
(
index
<
<
shift
)
+
(
code
&
(
(
1
<
<
shift
)
-
1
)
)
]
;
return
js_charinfo
[
index
]
;
}
inline
bool
IsIdentifierStart
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
js_isidstart
[
ch
]
;
return
CharInfo
(
ch
)
.
isUnicodeIDStart
(
)
;
}
bool
IsIdentifierStartNonBMP
(
uint32_t
codePoint
)
;
inline
bool
IsIdentifierStart
(
uint32_t
codePoint
)
{
if
(
MOZ_UNLIKELY
(
codePoint
>
UTF16Max
)
)
return
IsIdentifierStartNonBMP
(
codePoint
)
;
return
IsIdentifierStart
(
char16_t
(
codePoint
)
)
;
}
inline
bool
IsIdentifierPart
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
js_isident
[
ch
]
;
return
CharInfo
(
ch
)
.
isUnicodeIDContinue
(
)
;
}
bool
IsIdentifierPartNonBMP
(
uint32_t
codePoint
)
;
inline
bool
IsIdentifierPart
(
uint32_t
codePoint
)
{
if
(
MOZ_UNLIKELY
(
codePoint
>
UTF16Max
)
)
return
IsIdentifierPartNonBMP
(
codePoint
)
;
return
IsIdentifierPart
(
char16_t
(
codePoint
)
)
;
}
inline
bool
IsUnicodeIDStart
(
char16_t
ch
)
{
return
CharInfo
(
ch
)
.
isUnicodeIDStart
(
)
;
}
bool
IsUnicodeIDStartNonBMP
(
uint32_t
codePoint
)
;
inline
bool
IsUnicodeIDStart
(
uint32_t
codePoint
)
{
if
(
MOZ_UNLIKELY
(
codePoint
>
UTF16Max
)
)
return
IsIdentifierStartNonBMP
(
codePoint
)
;
return
IsUnicodeIDStart
(
char16_t
(
codePoint
)
)
;
}
inline
bool
IsSpace
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
js_isspace
[
ch
]
;
if
(
ch
=
=
NO_BREAK_SPACE
)
return
true
;
return
CharInfo
(
ch
)
.
isSpace
(
)
;
}
inline
bool
IsSpaceOrBOM2
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
js_isspace
[
ch
]
;
if
(
ch
=
=
NO_BREAK_SPACE
|
|
ch
=
=
BYTE_ORDER_MARK2
)
return
true
;
return
CharInfo
(
ch
)
.
isSpace
(
)
;
}
inline
char16_t
ToUpperCase
(
char16_t
ch
)
{
if
(
ch
<
128
)
{
if
(
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
)
return
ch
-
(
'
a
'
-
'
A
'
)
;
return
ch
;
}
const
CharacterInfo
&
info
=
CharInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
upperCase
;
}
inline
char16_t
ToLowerCase
(
char16_t
ch
)
{
if
(
ch
<
128
)
{
if
(
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
)
return
ch
+
(
'
a
'
-
'
A
'
)
;
return
ch
;
}
const
CharacterInfo
&
info
=
CharInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
lowerCase
;
}
inline
bool
CanUpperCase
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
;
return
CharInfo
(
ch
)
.
upperCase
!
=
0
;
}
inline
bool
CanUpperCase
(
JS
:
:
Latin1Char
ch
)
{
if
(
MOZ_LIKELY
(
ch
<
128
)
)
return
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
;
bool
canUpper
=
ch
=
=
MICRO_SIGN
|
|
(
(
(
ch
&
~
0x1F
)
=
=
LATIN_SMALL_LETTER_A_WITH_GRAVE
)
&
&
ch
!
=
DIVISION_SIGN
)
;
MOZ_ASSERT
(
canUpper
=
=
CanUpperCase
(
char16_t
(
ch
)
)
)
;
return
canUpper
;
}
inline
bool
CanLowerCase
(
char16_t
ch
)
{
if
(
ch
<
128
)
return
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
;
return
CharInfo
(
ch
)
.
lowerCase
!
=
0
;
}
inline
bool
CanLowerCase
(
JS
:
:
Latin1Char
ch
)
{
if
(
MOZ_LIKELY
(
ch
<
128
)
)
return
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
;
bool
canLower
=
(
(
ch
&
~
0x1F
)
=
=
LATIN_CAPITAL_LETTER_A_WITH_GRAVE
)
&
&
(
(
ch
&
MULTIPLICATION_SIGN
)
!
=
MULTIPLICATION_SIGN
)
;
MOZ_ASSERT
(
canLower
=
=
CanLowerCase
(
char16_t
(
ch
)
)
)
;
return
canLower
;
}
#
define
CHECK_RANGE
(
FROM
TO
LEAD
TRAIL_FROM
TRAIL_TO
DIFF
)
\
if
(
lead
=
=
LEAD
&
&
trail
>
=
TRAIL_FROM
&
&
trail
<
=
TRAIL_TO
)
\
return
true
;
inline
bool
CanUpperCaseNonBMP
(
char16_t
lead
char16_t
trail
)
{
FOR_EACH_NON_BMP_UPPERCASE
(
CHECK_RANGE
)
return
false
;
}
inline
bool
CanLowerCaseNonBMP
(
char16_t
lead
char16_t
trail
)
{
FOR_EACH_NON_BMP_LOWERCASE
(
CHECK_RANGE
)
return
false
;
}
#
undef
CHECK_RANGE
inline
char16_t
ToUpperCaseNonBMPTrail
(
char16_t
lead
char16_t
trail
)
{
#
define
CALC_TRAIL
(
FROM
TO
LEAD
TRAIL_FROM
TRAIL_TO
DIFF
)
\
if
(
lead
=
=
LEAD
&
&
trail
>
=
TRAIL_FROM
&
&
trail
<
=
TRAIL_TO
)
\
return
trail
+
DIFF
;
FOR_EACH_NON_BMP_UPPERCASE
(
CALC_TRAIL
)
#
undef
CALL_TRAIL
return
trail
;
}
inline
char16_t
ToLowerCaseNonBMPTrail
(
char16_t
lead
char16_t
trail
)
{
#
define
CALC_TRAIL
(
FROM
TO
LEAD
TRAIL_FROM
TRAIL_TO
DIFF
)
\
if
(
lead
=
=
LEAD
&
&
trail
>
=
TRAIL_FROM
&
&
trail
<
=
TRAIL_TO
)
\
return
trail
+
DIFF
;
FOR_EACH_NON_BMP_LOWERCASE
(
CALC_TRAIL
)
#
undef
CALL_TRAIL
return
trail
;
}
bool
CanUpperCaseSpecialCasing
(
char16_t
ch
)
;
size_t
LengthUpperCaseSpecialCasing
(
char16_t
ch
)
;
void
AppendUpperCaseSpecialCasing
(
char16_t
ch
char16_t
*
elements
size_t
*
index
)
;
class
CodepointsWithSameUpperCaseInfo
{
public
:
uint16_t
delta1
;
uint16_t
delta2
;
uint16_t
delta3
;
}
;
extern
const
uint8_t
codepoints_with_same_upper_index1
[
]
;
extern
const
uint8_t
codepoints_with_same_upper_index2
[
]
;
extern
const
CodepointsWithSameUpperCaseInfo
js_codepoints_with_same_upper_info
[
]
;
class
CodepointsWithSameUpperCase
{
const
CodepointsWithSameUpperCaseInfo
&
info_
;
const
char16_t
code_
;
static
const
CodepointsWithSameUpperCaseInfo
&
computeInfo
(
char16_t
code
)
{
const
size_t
shift
=
6
;
size_t
index
=
codepoints_with_same_upper_index1
[
code
>
>
shift
]
;
index
=
codepoints_with_same_upper_index2
[
(
index
<
<
shift
)
+
(
code
&
(
(
1
<
<
shift
)
-
1
)
)
]
;
return
js_codepoints_with_same_upper_info
[
index
]
;
}
public
:
explicit
CodepointsWithSameUpperCase
(
char16_t
code
)
:
info_
(
computeInfo
(
code
)
)
code_
(
code
)
{
}
char16_t
other1
(
)
const
{
return
uint16_t
(
code_
)
+
info_
.
delta1
;
}
char16_t
other2
(
)
const
{
return
uint16_t
(
code_
)
+
info_
.
delta2
;
}
char16_t
other3
(
)
const
{
return
uint16_t
(
code_
)
+
info_
.
delta3
;
}
}
;
class
FoldingInfo
{
public
:
uint16_t
folding
;
uint16_t
reverse1
;
uint16_t
reverse2
;
uint16_t
reverse3
;
}
;
extern
const
uint8_t
folding_index1
[
]
;
extern
const
uint8_t
folding_index2
[
]
;
extern
const
FoldingInfo
js_foldinfo
[
]
;
inline
const
FoldingInfo
&
CaseFoldInfo
(
char16_t
code
)
{
const
size_t
shift
=
6
;
size_t
index
=
folding_index1
[
code
>
>
shift
]
;
index
=
folding_index2
[
(
index
<
<
shift
)
+
(
code
&
(
(
1
<
<
shift
)
-
1
)
)
]
;
return
js_foldinfo
[
index
]
;
}
inline
char16_t
FoldCase
(
char16_t
ch
)
{
const
FoldingInfo
&
info
=
CaseFoldInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
folding
;
}
inline
char16_t
ReverseFoldCase1
(
char16_t
ch
)
{
const
FoldingInfo
&
info
=
CaseFoldInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
reverse1
;
}
inline
char16_t
ReverseFoldCase2
(
char16_t
ch
)
{
const
FoldingInfo
&
info
=
CaseFoldInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
reverse2
;
}
inline
char16_t
ReverseFoldCase3
(
char16_t
ch
)
{
const
FoldingInfo
&
info
=
CaseFoldInfo
(
ch
)
;
return
uint16_t
(
ch
)
+
info
.
reverse3
;
}
inline
bool
IsSupplementary
(
uint32_t
codePoint
)
{
return
codePoint
>
=
NonBMPMin
&
&
codePoint
<
=
NonBMPMax
;
}
inline
bool
IsLeadSurrogate
(
uint32_t
codePoint
)
{
return
codePoint
>
=
LeadSurrogateMin
&
&
codePoint
<
=
LeadSurrogateMax
;
}
inline
bool
IsTrailSurrogate
(
uint32_t
codePoint
)
{
return
codePoint
>
=
TrailSurrogateMin
&
&
codePoint
<
=
TrailSurrogateMax
;
}
inline
char16_t
LeadSurrogate
(
uint32_t
codePoint
)
{
MOZ_ASSERT
(
IsSupplementary
(
codePoint
)
)
;
return
char16_t
(
(
codePoint
>
>
10
)
+
(
LeadSurrogateMin
-
(
NonBMPMin
>
>
10
)
)
)
;
}
inline
char16_t
TrailSurrogate
(
uint32_t
codePoint
)
{
MOZ_ASSERT
(
IsSupplementary
(
codePoint
)
)
;
return
char16_t
(
(
codePoint
&
0x3FF
)
|
TrailSurrogateMin
)
;
}
inline
void
UTF16Encode
(
uint32_t
codePoint
char16_t
*
lead
char16_t
*
trail
)
{
MOZ_ASSERT
(
IsSupplementary
(
codePoint
)
)
;
*
lead
=
LeadSurrogate
(
codePoint
)
;
*
trail
=
TrailSurrogate
(
codePoint
)
;
}
inline
void
UTF16Encode
(
uint32_t
codePoint
char16_t
*
elements
unsigned
*
index
)
{
if
(
!
IsSupplementary
(
codePoint
)
)
{
elements
[
(
*
index
)
+
+
]
=
char16_t
(
codePoint
)
;
}
else
{
elements
[
(
*
index
)
+
+
]
=
LeadSurrogate
(
codePoint
)
;
elements
[
(
*
index
)
+
+
]
=
TrailSurrogate
(
codePoint
)
;
}
}
inline
uint32_t
UTF16Decode
(
char16_t
lead
char16_t
trail
)
{
MOZ_ASSERT
(
IsLeadSurrogate
(
lead
)
)
;
MOZ_ASSERT
(
IsTrailSurrogate
(
trail
)
)
;
return
(
lead
<
<
10
)
+
trail
+
(
NonBMPMin
-
(
LeadSurrogateMin
<
<
10
)
-
TrailSurrogateMin
)
;
}
}
}
#
endif
