#
include
"
vm
/
DateTime
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
algorithm
>
#
if
defined
(
XP_WIN
)
#
include
<
cstdlib
>
#
endif
#
include
<
cstring
>
#
include
<
time
.
h
>
#
include
"
jsutil
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
if
ENABLE_INTL_API
&
&
!
MOZ_SYSTEM_ICU
#
include
"
unicode
/
basictz
.
h
"
#
include
"
unicode
/
locid
.
h
"
#
endif
#
if
ENABLE_INTL_API
&
&
(
!
MOZ_SYSTEM_ICU
|
|
defined
(
ICU_TZ_HAS_RECREATE_DEFAULT
)
)
#
include
"
unicode
/
timezone
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
endif
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
static
bool
ComputeLocalTime
(
time_t
local
struct
tm
*
ptm
)
{
#
if
defined
(
_WIN32
)
return
localtime_s
(
ptm
&
local
)
=
=
0
;
#
elif
defined
(
HAVE_LOCALTIME_R
)
return
localtime_r
(
&
local
ptm
)
;
#
else
struct
tm
*
otm
=
localtime
(
&
local
)
;
if
(
!
otm
)
return
false
;
*
ptm
=
*
otm
;
return
true
;
#
endif
}
static
bool
ComputeUTCTime
(
time_t
t
struct
tm
*
ptm
)
{
#
if
defined
(
_WIN32
)
return
gmtime_s
(
ptm
&
t
)
=
=
0
;
#
elif
defined
(
HAVE_GMTIME_R
)
return
gmtime_r
(
&
t
ptm
)
;
#
else
struct
tm
*
otm
=
gmtime
(
&
t
)
;
if
(
!
otm
)
return
false
;
*
ptm
=
*
otm
;
return
true
;
#
endif
}
static
int32_t
UTCToLocalStandardOffsetSeconds
(
)
{
using
js
:
:
SecondsPerDay
;
using
js
:
:
SecondsPerHour
;
using
js
:
:
SecondsPerMinute
;
time_t
currentMaybeWithDST
=
time
(
nullptr
)
;
if
(
currentMaybeWithDST
=
=
time_t
(
-
1
)
)
return
0
;
struct
tm
local
;
if
(
!
ComputeLocalTime
(
currentMaybeWithDST
&
local
)
)
return
0
;
time_t
currentNoDST
;
if
(
local
.
tm_isdst
=
=
0
)
{
currentNoDST
=
currentMaybeWithDST
;
}
else
{
struct
tm
localNoDST
=
local
;
localNoDST
.
tm_isdst
=
0
;
currentNoDST
=
mktime
(
&
localNoDST
)
;
if
(
currentNoDST
=
=
time_t
(
-
1
)
)
return
0
;
}
struct
tm
utc
;
if
(
!
ComputeUTCTime
(
currentNoDST
&
utc
)
)
return
0
;
int
utc_secs
=
utc
.
tm_hour
*
SecondsPerHour
+
utc
.
tm_min
*
SecondsPerMinute
;
int
local_secs
=
local
.
tm_hour
*
SecondsPerHour
+
local
.
tm_min
*
SecondsPerMinute
;
if
(
utc
.
tm_mday
=
=
local
.
tm_mday
)
return
local_secs
-
utc_secs
;
if
(
utc_secs
>
local_secs
)
return
(
SecondsPerDay
+
local_secs
)
-
utc_secs
;
return
local_secs
-
(
utc_secs
+
SecondsPerDay
)
;
}
bool
js
:
:
DateTimeInfo
:
:
internalUpdateTimeZoneAdjustment
(
ResetTimeZoneMode
mode
)
{
utcToLocalStandardOffsetSeconds_
=
UTCToLocalStandardOffsetSeconds
(
)
;
int32_t
newTZA
=
utcToLocalStandardOffsetSeconds_
*
msPerSecond
;
if
(
mode
=
=
ResetTimeZoneMode
:
:
DontResetIfOffsetUnchanged
&
&
newTZA
=
=
localTZA_
)
return
false
;
localTZA_
=
newTZA
;
dstRange_
.
reset
(
)
;
#
if
ENABLE_INTL_API
&
&
!
MOZ_SYSTEM_ICU
utcRange_
.
reset
(
)
;
localRange_
.
reset
(
)
;
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
timeZone_
=
nullptr
;
}
standardName_
=
nullptr
;
daylightSavingsName_
=
nullptr
;
#
endif
return
true
;
}
js
:
:
DateTimeInfo
:
:
DateTimeInfo
(
)
{
internalUpdateTimeZoneAdjustment
(
ResetTimeZoneMode
:
:
ResetEvenIfOffsetUnchaged
)
;
}
js
:
:
DateTimeInfo
:
:
~
DateTimeInfo
(
)
=
default
;
int64_t
js
:
:
DateTimeInfo
:
:
toClampedSeconds
(
int64_t
milliseconds
)
{
int64_t
seconds
=
milliseconds
/
msPerSecond
;
if
(
seconds
>
MaxTimeT
)
{
seconds
=
MaxTimeT
;
}
else
if
(
seconds
<
MinTimeT
)
{
seconds
=
SecondsPerDay
;
}
return
seconds
;
}
int32_t
js
:
:
DateTimeInfo
:
:
computeDSTOffsetMilliseconds
(
int64_t
utcSeconds
)
{
MOZ_ASSERT
(
utcSeconds
>
=
MinTimeT
)
;
MOZ_ASSERT
(
utcSeconds
<
=
MaxTimeT
)
;
#
if
ENABLE_INTL_API
&
&
!
MOZ_SYSTEM_ICU
UDate
date
=
UDate
(
utcSeconds
*
msPerSecond
)
;
constexpr
bool
dateIsLocalTime
=
false
;
int32_t
rawOffset
dstOffset
;
UErrorCode
status
=
U_ZERO_ERROR
;
timeZone
(
)
-
>
getOffset
(
date
dateIsLocalTime
rawOffset
dstOffset
status
)
;
if
(
U_FAILURE
(
status
)
)
return
0
;
return
dstOffset
;
#
else
struct
tm
tm
;
if
(
!
ComputeLocalTime
(
static_cast
<
time_t
>
(
utcSeconds
)
&
tm
)
)
return
0
;
int32_t
dayoff
=
int32_t
(
(
utcSeconds
+
utcToLocalStandardOffsetSeconds_
)
%
SecondsPerDay
)
;
int32_t
tmoff
=
tm
.
tm_sec
+
(
tm
.
tm_min
*
SecondsPerMinute
)
+
(
tm
.
tm_hour
*
SecondsPerHour
)
;
int32_t
diff
=
tmoff
-
dayoff
;
if
(
diff
<
0
)
diff
+
=
SecondsPerDay
;
else
if
(
uint32_t
(
diff
)
>
=
SecondsPerDay
)
diff
-
=
SecondsPerDay
;
return
diff
*
msPerSecond
;
#
endif
}
int32_t
js
:
:
DateTimeInfo
:
:
internalGetDSTOffsetMilliseconds
(
int64_t
utcMilliseconds
)
{
int64_t
utcSeconds
=
toClampedSeconds
(
utcMilliseconds
)
;
return
getOrComputeValue
(
dstRange_
utcSeconds
&
DateTimeInfo
:
:
computeDSTOffsetMilliseconds
)
;
}
int32_t
js
:
:
DateTimeInfo
:
:
getOrComputeValue
(
RangeCache
&
range
int64_t
seconds
ComputeFn
compute
)
{
range
.
sanityCheck
(
)
;
auto
checkSanity
=
mozilla
:
:
MakeScopeExit
(
[
&
range
]
(
)
{
range
.
sanityCheck
(
)
;
}
)
;
MOZ_ASSERT
(
seconds
!
=
INT64_MIN
)
;
if
(
range
.
startSeconds
<
=
seconds
&
&
seconds
<
=
range
.
endSeconds
)
return
range
.
offsetMilliseconds
;
if
(
range
.
oldStartSeconds
<
=
seconds
&
&
seconds
<
=
range
.
oldEndSeconds
)
return
range
.
oldOffsetMilliseconds
;
range
.
oldOffsetMilliseconds
=
range
.
offsetMilliseconds
;
range
.
oldStartSeconds
=
range
.
startSeconds
;
range
.
oldEndSeconds
=
range
.
endSeconds
;
if
(
range
.
startSeconds
<
=
seconds
)
{
int64_t
newEndSeconds
=
Min
(
range
.
endSeconds
+
RangeExpansionAmount
MaxTimeT
)
;
if
(
newEndSeconds
>
=
seconds
)
{
int32_t
endOffsetMilliseconds
=
(
this
-
>
*
compute
)
(
newEndSeconds
)
;
if
(
endOffsetMilliseconds
=
=
range
.
offsetMilliseconds
)
{
range
.
endSeconds
=
newEndSeconds
;
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
if
(
range
.
offsetMilliseconds
=
=
endOffsetMilliseconds
)
{
range
.
startSeconds
=
seconds
;
range
.
endSeconds
=
newEndSeconds
;
}
else
{
range
.
endSeconds
=
seconds
;
}
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
range
.
startSeconds
=
range
.
endSeconds
=
seconds
;
return
range
.
offsetMilliseconds
;
}
int64_t
newStartSeconds
=
Max
<
int64_t
>
(
range
.
startSeconds
-
RangeExpansionAmount
MinTimeT
)
;
if
(
newStartSeconds
<
=
seconds
)
{
int32_t
startOffsetMilliseconds
=
(
this
-
>
*
compute
)
(
newStartSeconds
)
;
if
(
startOffsetMilliseconds
=
=
range
.
offsetMilliseconds
)
{
range
.
startSeconds
=
newStartSeconds
;
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
if
(
range
.
offsetMilliseconds
=
=
startOffsetMilliseconds
)
{
range
.
startSeconds
=
newStartSeconds
;
range
.
endSeconds
=
seconds
;
}
else
{
range
.
startSeconds
=
seconds
;
}
return
range
.
offsetMilliseconds
;
}
range
.
startSeconds
=
range
.
endSeconds
=
seconds
;
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
return
range
.
offsetMilliseconds
;
}
void
js
:
:
DateTimeInfo
:
:
RangeCache
:
:
reset
(
)
{
offsetMilliseconds
=
0
;
startSeconds
=
endSeconds
=
INT64_MIN
;
oldOffsetMilliseconds
=
0
;
oldStartSeconds
=
oldEndSeconds
=
INT64_MIN
;
sanityCheck
(
)
;
}
void
js
:
:
DateTimeInfo
:
:
RangeCache
:
:
sanityCheck
(
)
{
auto
assertRange
=
[
]
(
int64_t
start
int64_t
end
)
{
MOZ_ASSERT
(
start
<
=
end
)
;
MOZ_ASSERT_IF
(
start
=
=
INT64_MIN
end
=
=
INT64_MIN
)
;
MOZ_ASSERT_IF
(
end
=
=
INT64_MIN
start
=
=
INT64_MIN
)
;
MOZ_ASSERT_IF
(
start
!
=
INT64_MIN
start
>
=
MinTimeT
&
&
end
>
=
MinTimeT
)
;
MOZ_ASSERT_IF
(
start
!
=
INT64_MIN
start
<
=
MaxTimeT
&
&
end
<
=
MaxTimeT
)
;
}
;
assertRange
(
startSeconds
endSeconds
)
;
assertRange
(
oldStartSeconds
oldEndSeconds
)
;
}
#
if
ENABLE_INTL_API
&
&
!
MOZ_SYSTEM_ICU
int32_t
js
:
:
DateTimeInfo
:
:
computeUTCOffsetMilliseconds
(
int64_t
localSeconds
)
{
MOZ_ASSERT
(
localSeconds
>
=
MinTimeT
)
;
MOZ_ASSERT
(
localSeconds
<
=
MaxTimeT
)
;
UDate
date
=
UDate
(
localSeconds
*
msPerSecond
)
;
constexpr
int32_t
skippedTime
=
icu
:
:
BasicTimeZone
:
:
kFormer
;
constexpr
int32_t
repeatedTime
=
icu
:
:
BasicTimeZone
:
:
kFormer
;
int32_t
rawOffset
dstOffset
;
UErrorCode
status
=
U_ZERO_ERROR
;
auto
*
basicTz
=
static_cast
<
icu
:
:
BasicTimeZone
*
>
(
timeZone
(
)
)
;
basicTz
-
>
getOffsetFromLocal
(
date
skippedTime
repeatedTime
rawOffset
dstOffset
status
)
;
if
(
U_FAILURE
(
status
)
)
return
0
;
return
rawOffset
+
dstOffset
;
}
int32_t
js
:
:
DateTimeInfo
:
:
computeLocalOffsetMilliseconds
(
int64_t
utcSeconds
)
{
MOZ_ASSERT
(
utcSeconds
>
=
MinTimeT
)
;
MOZ_ASSERT
(
utcSeconds
<
=
MaxTimeT
)
;
UDate
date
=
UDate
(
utcSeconds
*
msPerSecond
)
;
constexpr
bool
dateIsLocalTime
=
false
;
int32_t
rawOffset
dstOffset
;
UErrorCode
status
=
U_ZERO_ERROR
;
timeZone
(
)
-
>
getOffset
(
date
dateIsLocalTime
rawOffset
dstOffset
status
)
;
if
(
U_FAILURE
(
status
)
)
return
0
;
return
rawOffset
+
dstOffset
;
}
int32_t
js
:
:
DateTimeInfo
:
:
internalGetOffsetMilliseconds
(
int64_t
milliseconds
TimeZoneOffset
offset
)
{
int64_t
seconds
=
toClampedSeconds
(
milliseconds
)
;
return
offset
=
=
TimeZoneOffset
:
:
UTC
?
getOrComputeValue
(
localRange_
seconds
&
DateTimeInfo
:
:
computeLocalOffsetMilliseconds
)
:
getOrComputeValue
(
utcRange_
seconds
&
DateTimeInfo
:
:
computeUTCOffsetMilliseconds
)
;
}
bool
js
:
:
DateTimeInfo
:
:
internalTimeZoneDisplayName
(
char16_t
*
buf
size_t
buflen
int64_t
utcMilliseconds
const
char
*
locale
)
{
MOZ_ASSERT
(
buf
!
=
nullptr
)
;
MOZ_ASSERT
(
buflen
>
0
)
;
MOZ_ASSERT
(
locale
!
=
nullptr
)
;
if
(
!
locale_
|
|
std
:
:
strcmp
(
locale_
.
get
(
)
locale
)
!
=
0
)
{
locale_
=
DuplicateString
(
locale
)
;
if
(
!
locale_
)
return
false
;
standardName_
.
reset
(
)
;
daylightSavingsName_
.
reset
(
)
;
}
bool
daylightSavings
=
internalGetDSTOffsetMilliseconds
(
utcMilliseconds
)
!
=
0
;
JS
:
:
UniqueTwoByteChars
&
cachedName
=
daylightSavings
?
daylightSavingsName_
:
standardName_
;
if
(
!
cachedName
)
{
icu
:
:
UnicodeString
displayName
;
timeZone
(
)
-
>
getDisplayName
(
daylightSavings
icu
:
:
TimeZone
:
:
LONG
icu
:
:
Locale
(
locale
)
displayName
)
;
size_t
capacity
=
displayName
.
length
(
)
+
1
;
JS
:
:
UniqueTwoByteChars
displayNameChars
(
js_pod_malloc
<
char16_t
>
(
capacity
)
)
;
if
(
!
displayNameChars
)
return
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
displayName
.
extract
(
displayNameChars
.
get
(
)
capacity
status
)
;
MOZ_ASSERT
(
U_SUCCESS
(
status
)
)
;
MOZ_ASSERT
(
displayNameChars
[
capacity
-
1
]
=
=
'
\
0
'
)
;
cachedName
=
std
:
:
move
(
displayNameChars
)
;
}
size_t
length
=
js_strlen
(
cachedName
.
get
(
)
)
;
if
(
length
<
buflen
)
std
:
:
copy
(
cachedName
.
get
(
)
cachedName
.
get
(
)
+
length
buf
)
;
else
length
=
0
;
buf
[
length
]
=
'
\
0
'
;
return
true
;
}
icu
:
:
TimeZone
*
js
:
:
DateTimeInfo
:
:
timeZone
(
)
{
if
(
!
timeZone_
)
{
js
:
:
ResyncICUDefaultTimeZone
(
)
;
timeZone_
.
reset
(
icu
:
:
TimeZone
:
:
createDefault
(
)
)
;
MOZ_ASSERT
(
timeZone_
)
;
}
return
timeZone_
.
get
(
)
;
}
#
endif
js
:
:
ExclusiveData
<
js
:
:
DateTimeInfo
>
*
js
:
:
DateTimeInfo
:
:
instance
;
js
:
:
ExclusiveData
<
js
:
:
IcuTimeZoneStatus
>
*
js
:
:
IcuTimeZoneState
;
#
if
defined
(
XP_WIN
)
static
bool
IsOlsonCompatibleWindowsTimeZoneId
(
const
char
*
tz
)
;
#
endif
bool
js
:
:
InitDateTimeState
(
)
{
MOZ_ASSERT
(
!
DateTimeInfo
:
:
instance
"
we
should
be
initializing
only
once
"
)
;
DateTimeInfo
:
:
instance
=
js_new
<
ExclusiveData
<
DateTimeInfo
>
>
(
mutexid
:
:
DateTimeInfoMutex
)
;
if
(
!
DateTimeInfo
:
:
instance
)
return
false
;
MOZ_ASSERT
(
!
IcuTimeZoneState
"
we
should
be
initializing
only
once
"
)
;
IcuTimeZoneStatus
initialStatus
=
IcuTimeZoneStatus
:
:
Valid
;
#
if
defined
(
XP_WIN
)
const
char
*
tz
=
std
:
:
getenv
(
"
TZ
"
)
;
if
(
tz
&
&
IsOlsonCompatibleWindowsTimeZoneId
(
tz
)
)
initialStatus
=
IcuTimeZoneStatus
:
:
NeedsUpdate
;
#
endif
IcuTimeZoneState
=
js_new
<
ExclusiveData
<
IcuTimeZoneStatus
>
>
(
mutexid
:
:
IcuTimeZoneStateMutex
initialStatus
)
;
if
(
!
IcuTimeZoneState
)
{
js_delete
(
DateTimeInfo
:
:
instance
)
;
DateTimeInfo
:
:
instance
=
nullptr
;
return
false
;
}
return
true
;
}
void
js
:
:
FinishDateTimeState
(
)
{
js_delete
(
IcuTimeZoneState
)
;
IcuTimeZoneState
=
nullptr
;
js_delete
(
DateTimeInfo
:
:
instance
)
;
DateTimeInfo
:
:
instance
=
nullptr
;
}
void
js
:
:
ResetTimeZoneInternal
(
ResetTimeZoneMode
mode
)
{
bool
needsUpdate
=
js
:
:
DateTimeInfo
:
:
updateTimeZoneAdjustment
(
mode
)
;
#
if
ENABLE_INTL_API
&
&
defined
(
ICU_TZ_HAS_RECREATE_DEFAULT
)
if
(
needsUpdate
)
{
auto
guard
=
js
:
:
IcuTimeZoneState
-
>
lock
(
)
;
guard
.
get
(
)
=
js
:
:
IcuTimeZoneStatus
:
:
NeedsUpdate
;
}
#
else
mozilla
:
:
Unused
<
<
needsUpdate
;
#
endif
}
JS_PUBLIC_API
(
void
)
JS
:
:
ResetTimeZone
(
)
{
js
:
:
ResetTimeZoneInternal
(
js
:
:
ResetTimeZoneMode
:
:
ResetEvenIfOffsetUnchaged
)
;
}
#
if
defined
(
XP_WIN
)
static
bool
IsOlsonCompatibleWindowsTimeZoneId
(
const
char
*
tz
)
{
static
const
char
*
const
allowedIds
[
]
=
{
"
EST5EDT
"
"
CST6CDT
"
"
MST7MDT
"
"
PST8PDT
"
"
GMT
+
0
"
"
GMT
-
0
"
"
GMT0
"
"
UCT
"
"
UTC
"
"
GMT
"
}
;
for
(
const
auto
&
allowedId
:
allowedIds
)
{
if
(
std
:
:
strcmp
(
allowedId
tz
)
=
=
0
)
return
true
;
}
return
false
;
}
#
endif
void
js
:
:
ResyncICUDefaultTimeZone
(
)
{
#
if
ENABLE_INTL_API
&
&
defined
(
ICU_TZ_HAS_RECREATE_DEFAULT
)
auto
guard
=
IcuTimeZoneState
-
>
lock
(
)
;
if
(
guard
.
get
(
)
=
=
IcuTimeZoneStatus
:
:
NeedsUpdate
)
{
bool
recreate
=
true
;
#
if
defined
(
XP_WIN
)
const
char
*
tz
=
std
:
:
getenv
(
"
TZ
"
)
;
if
(
tz
&
&
IsOlsonCompatibleWindowsTimeZoneId
(
tz
)
)
{
icu
:
:
UnicodeString
tzid
(
tz
-
1
US_INV
)
;
mozilla
:
:
UniquePtr
<
icu
:
:
TimeZone
>
newTimeZone
(
icu
:
:
TimeZone
:
:
createTimeZone
(
tzid
)
)
;
MOZ_ASSERT
(
newTimeZone
)
;
if
(
*
newTimeZone
!
=
icu
:
:
TimeZone
:
:
getUnknown
(
)
)
{
icu
:
:
TimeZone
:
:
adoptDefault
(
newTimeZone
.
release
(
)
)
;
recreate
=
false
;
}
}
else
{
}
#
endif
if
(
recreate
)
icu
:
:
TimeZone
:
:
recreateDefault
(
)
;
guard
.
get
(
)
=
IcuTimeZoneStatus
:
:
Valid
;
}
#
endif
}
