#
include
"
vm
/
DateTime
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
cstdlib
>
#
include
<
cstring
>
#
endif
#
include
<
time
.
h
>
#
include
"
jsutil
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
if
ENABLE_INTL_API
#
include
"
unicode
/
timezone
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
unicode
/
unistr
.
h
"
#
endif
#
endif
#
include
"
vm
/
MutexIDs
.
h
"
static
bool
ComputeLocalTime
(
time_t
local
struct
tm
*
ptm
)
{
#
if
defined
(
_WIN32
)
return
localtime_s
(
ptm
&
local
)
=
=
0
;
#
elif
defined
(
HAVE_LOCALTIME_R
)
return
localtime_r
(
&
local
ptm
)
;
#
else
struct
tm
*
otm
=
localtime
(
&
local
)
;
if
(
!
otm
)
return
false
;
*
ptm
=
*
otm
;
return
true
;
#
endif
}
static
bool
ComputeUTCTime
(
time_t
t
struct
tm
*
ptm
)
{
#
if
defined
(
_WIN32
)
return
gmtime_s
(
ptm
&
t
)
=
=
0
;
#
elif
defined
(
HAVE_GMTIME_R
)
return
gmtime_r
(
&
t
ptm
)
;
#
else
struct
tm
*
otm
=
gmtime
(
&
t
)
;
if
(
!
otm
)
return
false
;
*
ptm
=
*
otm
;
return
true
;
#
endif
}
static
int32_t
UTCToLocalStandardOffsetSeconds
(
)
{
using
js
:
:
SecondsPerDay
;
using
js
:
:
SecondsPerHour
;
using
js
:
:
SecondsPerMinute
;
time_t
currentMaybeWithDST
=
time
(
nullptr
)
;
if
(
currentMaybeWithDST
=
=
time_t
(
-
1
)
)
return
0
;
struct
tm
local
;
if
(
!
ComputeLocalTime
(
currentMaybeWithDST
&
local
)
)
return
0
;
time_t
currentNoDST
;
if
(
local
.
tm_isdst
=
=
0
)
{
currentNoDST
=
currentMaybeWithDST
;
}
else
{
struct
tm
localNoDST
=
local
;
localNoDST
.
tm_isdst
=
0
;
currentNoDST
=
mktime
(
&
localNoDST
)
;
if
(
currentNoDST
=
=
time_t
(
-
1
)
)
return
0
;
}
struct
tm
utc
;
if
(
!
ComputeUTCTime
(
currentNoDST
&
utc
)
)
return
0
;
int
utc_secs
=
utc
.
tm_hour
*
SecondsPerHour
+
utc
.
tm_min
*
SecondsPerMinute
;
int
local_secs
=
local
.
tm_hour
*
SecondsPerHour
+
local
.
tm_min
*
SecondsPerMinute
;
if
(
utc
.
tm_mday
=
=
local
.
tm_mday
)
return
local_secs
-
utc_secs
;
if
(
utc_secs
>
local_secs
)
return
(
SecondsPerDay
+
local_secs
)
-
utc_secs
;
return
local_secs
-
(
utc_secs
+
SecondsPerDay
)
;
}
bool
js
:
:
DateTimeInfo
:
:
internalUpdateTimeZoneAdjustment
(
ResetTimeZoneMode
mode
)
{
utcToLocalStandardOffsetSeconds_
=
UTCToLocalStandardOffsetSeconds
(
)
;
int32_t
newTZA
=
utcToLocalStandardOffsetSeconds_
*
msPerSecond
;
if
(
mode
=
=
ResetTimeZoneMode
:
:
DontResetIfOffsetUnchanged
&
&
newTZA
=
=
localTZA_
)
return
false
;
localTZA_
=
newTZA
;
dstRange_
.
reset
(
)
;
return
true
;
}
js
:
:
DateTimeInfo
:
:
DateTimeInfo
(
)
{
internalUpdateTimeZoneAdjustment
(
ResetTimeZoneMode
:
:
ResetEvenIfOffsetUnchaged
)
;
}
int64_t
js
:
:
DateTimeInfo
:
:
toClampedSeconds
(
int64_t
milliseconds
)
{
int64_t
seconds
=
milliseconds
/
msPerSecond
;
if
(
seconds
>
MaxTimeT
)
{
seconds
=
MaxTimeT
;
}
else
if
(
seconds
<
MinTimeT
)
{
seconds
=
SecondsPerDay
;
}
return
seconds
;
}
int32_t
js
:
:
DateTimeInfo
:
:
computeDSTOffsetMilliseconds
(
int64_t
utcSeconds
)
{
MOZ_ASSERT
(
utcSeconds
>
=
MinTimeT
)
;
MOZ_ASSERT
(
utcSeconds
<
=
MaxTimeT
)
;
struct
tm
tm
;
if
(
!
ComputeLocalTime
(
static_cast
<
time_t
>
(
utcSeconds
)
&
tm
)
)
return
0
;
int32_t
dayoff
=
int32_t
(
(
utcSeconds
+
utcToLocalStandardOffsetSeconds_
)
%
SecondsPerDay
)
;
int32_t
tmoff
=
tm
.
tm_sec
+
(
tm
.
tm_min
*
SecondsPerMinute
)
+
(
tm
.
tm_hour
*
SecondsPerHour
)
;
int32_t
diff
=
tmoff
-
dayoff
;
if
(
diff
<
0
)
diff
+
=
SecondsPerDay
;
else
if
(
uint32_t
(
diff
)
>
=
SecondsPerDay
)
diff
-
=
SecondsPerDay
;
return
diff
*
msPerSecond
;
}
int32_t
js
:
:
DateTimeInfo
:
:
internalGetDSTOffsetMilliseconds
(
int64_t
utcMilliseconds
)
{
int64_t
utcSeconds
=
toClampedSeconds
(
utcMilliseconds
)
;
return
getOrComputeValue
(
dstRange_
utcSeconds
&
DateTimeInfo
:
:
computeDSTOffsetMilliseconds
)
;
}
int32_t
js
:
:
DateTimeInfo
:
:
getOrComputeValue
(
RangeCache
&
range
int64_t
seconds
ComputeFn
compute
)
{
range
.
sanityCheck
(
)
;
auto
checkSanity
=
mozilla
:
:
MakeScopeExit
(
[
&
range
]
(
)
{
range
.
sanityCheck
(
)
;
}
)
;
MOZ_ASSERT
(
seconds
!
=
INT64_MIN
)
;
if
(
range
.
startSeconds
<
=
seconds
&
&
seconds
<
=
range
.
endSeconds
)
return
range
.
offsetMilliseconds
;
if
(
range
.
oldStartSeconds
<
=
seconds
&
&
seconds
<
=
range
.
oldEndSeconds
)
return
range
.
oldOffsetMilliseconds
;
range
.
oldOffsetMilliseconds
=
range
.
offsetMilliseconds
;
range
.
oldStartSeconds
=
range
.
startSeconds
;
range
.
oldEndSeconds
=
range
.
endSeconds
;
if
(
range
.
startSeconds
<
=
seconds
)
{
int64_t
newEndSeconds
=
Min
(
range
.
endSeconds
+
RangeExpansionAmount
MaxTimeT
)
;
if
(
newEndSeconds
>
=
seconds
)
{
int32_t
endOffsetMilliseconds
=
(
this
-
>
*
compute
)
(
newEndSeconds
)
;
if
(
endOffsetMilliseconds
=
=
range
.
offsetMilliseconds
)
{
range
.
endSeconds
=
newEndSeconds
;
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
if
(
range
.
offsetMilliseconds
=
=
endOffsetMilliseconds
)
{
range
.
startSeconds
=
seconds
;
range
.
endSeconds
=
newEndSeconds
;
}
else
{
range
.
endSeconds
=
seconds
;
}
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
range
.
startSeconds
=
range
.
endSeconds
=
seconds
;
return
range
.
offsetMilliseconds
;
}
int64_t
newStartSeconds
=
Max
<
int64_t
>
(
range
.
startSeconds
-
RangeExpansionAmount
MinTimeT
)
;
if
(
newStartSeconds
<
=
seconds
)
{
int32_t
startOffsetMilliseconds
=
(
this
-
>
*
compute
)
(
newStartSeconds
)
;
if
(
startOffsetMilliseconds
=
=
range
.
offsetMilliseconds
)
{
range
.
startSeconds
=
newStartSeconds
;
return
range
.
offsetMilliseconds
;
}
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
if
(
range
.
offsetMilliseconds
=
=
startOffsetMilliseconds
)
{
range
.
startSeconds
=
newStartSeconds
;
range
.
endSeconds
=
seconds
;
}
else
{
range
.
startSeconds
=
seconds
;
}
return
range
.
offsetMilliseconds
;
}
range
.
startSeconds
=
range
.
endSeconds
=
seconds
;
range
.
offsetMilliseconds
=
(
this
-
>
*
compute
)
(
seconds
)
;
return
range
.
offsetMilliseconds
;
}
void
js
:
:
DateTimeInfo
:
:
RangeCache
:
:
reset
(
)
{
offsetMilliseconds
=
0
;
startSeconds
=
endSeconds
=
INT64_MIN
;
oldOffsetMilliseconds
=
0
;
oldStartSeconds
=
oldEndSeconds
=
INT64_MIN
;
sanityCheck
(
)
;
}
void
js
:
:
DateTimeInfo
:
:
RangeCache
:
:
sanityCheck
(
)
{
auto
assertRange
=
[
]
(
int64_t
start
int64_t
end
)
{
MOZ_ASSERT
(
start
<
=
end
)
;
MOZ_ASSERT_IF
(
start
=
=
INT64_MIN
end
=
=
INT64_MIN
)
;
MOZ_ASSERT_IF
(
end
=
=
INT64_MIN
start
=
=
INT64_MIN
)
;
MOZ_ASSERT_IF
(
start
!
=
INT64_MIN
start
>
=
MinTimeT
&
&
end
>
=
MinTimeT
)
;
MOZ_ASSERT_IF
(
start
!
=
INT64_MIN
start
<
=
MaxTimeT
&
&
end
<
=
MaxTimeT
)
;
}
;
assertRange
(
startSeconds
endSeconds
)
;
assertRange
(
oldStartSeconds
oldEndSeconds
)
;
}
js
:
:
ExclusiveData
<
js
:
:
DateTimeInfo
>
*
js
:
:
DateTimeInfo
:
:
instance
;
js
:
:
ExclusiveData
<
js
:
:
IcuTimeZoneStatus
>
*
js
:
:
IcuTimeZoneState
;
#
if
defined
(
XP_WIN
)
static
bool
IsOlsonCompatibleWindowsTimeZoneId
(
const
char
*
tz
)
;
#
endif
bool
js
:
:
InitDateTimeState
(
)
{
MOZ_ASSERT
(
!
DateTimeInfo
:
:
instance
"
we
should
be
initializing
only
once
"
)
;
DateTimeInfo
:
:
instance
=
js_new
<
ExclusiveData
<
DateTimeInfo
>
>
(
mutexid
:
:
DateTimeInfoMutex
)
;
if
(
!
DateTimeInfo
:
:
instance
)
return
false
;
MOZ_ASSERT
(
!
IcuTimeZoneState
"
we
should
be
initializing
only
once
"
)
;
IcuTimeZoneStatus
initialStatus
=
IcuTimeZoneStatus
:
:
Valid
;
#
if
defined
(
XP_WIN
)
const
char
*
tz
=
std
:
:
getenv
(
"
TZ
"
)
;
if
(
tz
&
&
IsOlsonCompatibleWindowsTimeZoneId
(
tz
)
)
initialStatus
=
IcuTimeZoneStatus
:
:
NeedsUpdate
;
#
endif
IcuTimeZoneState
=
js_new
<
ExclusiveData
<
IcuTimeZoneStatus
>
>
(
mutexid
:
:
IcuTimeZoneStateMutex
initialStatus
)
;
if
(
!
IcuTimeZoneState
)
{
js_delete
(
DateTimeInfo
:
:
instance
)
;
DateTimeInfo
:
:
instance
=
nullptr
;
return
false
;
}
return
true
;
}
void
js
:
:
FinishDateTimeState
(
)
{
js_delete
(
IcuTimeZoneState
)
;
IcuTimeZoneState
=
nullptr
;
js_delete
(
DateTimeInfo
:
:
instance
)
;
DateTimeInfo
:
:
instance
=
nullptr
;
}
void
js
:
:
ResetTimeZoneInternal
(
ResetTimeZoneMode
mode
)
{
bool
needsUpdate
=
js
:
:
DateTimeInfo
:
:
updateTimeZoneAdjustment
(
mode
)
;
#
if
ENABLE_INTL_API
&
&
defined
(
ICU_TZ_HAS_RECREATE_DEFAULT
)
if
(
needsUpdate
)
{
auto
guard
=
js
:
:
IcuTimeZoneState
-
>
lock
(
)
;
guard
.
get
(
)
=
js
:
:
IcuTimeZoneStatus
:
:
NeedsUpdate
;
}
#
else
mozilla
:
:
Unused
<
<
needsUpdate
;
#
endif
}
JS_PUBLIC_API
(
void
)
JS
:
:
ResetTimeZone
(
)
{
js
:
:
ResetTimeZoneInternal
(
js
:
:
ResetTimeZoneMode
:
:
ResetEvenIfOffsetUnchaged
)
;
}
#
if
defined
(
XP_WIN
)
static
bool
IsOlsonCompatibleWindowsTimeZoneId
(
const
char
*
tz
)
{
static
const
char
*
const
allowedIds
[
]
=
{
"
EST5EDT
"
"
CST6CDT
"
"
MST7MDT
"
"
PST8PDT
"
"
GMT
+
0
"
"
GMT
-
0
"
"
GMT0
"
"
UCT
"
"
UTC
"
"
GMT
"
}
;
for
(
const
auto
&
allowedId
:
allowedIds
)
{
if
(
std
:
:
strcmp
(
allowedId
tz
)
=
=
0
)
return
true
;
}
return
false
;
}
#
endif
void
js
:
:
ResyncICUDefaultTimeZone
(
)
{
#
if
ENABLE_INTL_API
&
&
defined
(
ICU_TZ_HAS_RECREATE_DEFAULT
)
auto
guard
=
IcuTimeZoneState
-
>
lock
(
)
;
if
(
guard
.
get
(
)
=
=
IcuTimeZoneStatus
:
:
NeedsUpdate
)
{
bool
recreate
=
true
;
#
if
defined
(
XP_WIN
)
const
char
*
tz
=
std
:
:
getenv
(
"
TZ
"
)
;
if
(
tz
&
&
IsOlsonCompatibleWindowsTimeZoneId
(
tz
)
)
{
icu
:
:
UnicodeString
tzid
(
tz
-
1
US_INV
)
;
mozilla
:
:
UniquePtr
<
icu
:
:
TimeZone
>
newTimeZone
(
icu
:
:
TimeZone
:
:
createTimeZone
(
tzid
)
)
;
MOZ_ASSERT
(
newTimeZone
)
;
if
(
*
newTimeZone
!
=
icu
:
:
TimeZone
:
:
getUnknown
(
)
)
{
icu
:
:
TimeZone
:
:
adoptDefault
(
newTimeZone
.
release
(
)
)
;
recreate
=
false
;
}
}
else
{
}
#
endif
if
(
recreate
)
icu
:
:
TimeZone
:
:
recreateDefault
(
)
;
guard
.
get
(
)
=
IcuTimeZoneStatus
:
:
Valid
;
}
#
endif
}
