#
ifndef
vm_JSCompartment_h
#
define
vm_JSCompartment_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
<
stddef
.
h
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
NurseryAwareHashMap
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
ReceiverGuard
.
h
"
#
include
"
vm
/
RegExpShared
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
wasm
/
WasmRealm
.
h
"
namespace
js
{
namespace
jit
{
class
JitRealm
;
}
namespace
gc
{
template
<
typename
Node
typename
Derived
>
class
ComponentFinder
;
}
class
AutoRestoreRealmDebugMode
;
class
GlobalObject
;
class
LexicalEnvironmentObject
;
class
MapObject
;
class
ScriptSourceObject
;
class
SetObject
;
struct
NativeIterator
;
class
DtoaCache
{
double
d
;
int
base
;
JSFlatString
*
s
;
public
:
DtoaCache
(
)
:
s
(
nullptr
)
{
}
void
purge
(
)
{
s
=
nullptr
;
}
JSFlatString
*
lookup
(
int
base
double
d
)
{
return
this
-
>
s
&
&
base
=
=
this
-
>
base
&
&
d
=
=
this
-
>
d
?
this
-
>
s
:
nullptr
;
}
void
cache
(
int
base
double
d
JSFlatString
*
s
)
{
this
-
>
base
=
base
;
this
-
>
d
=
d
;
this
-
>
s
=
s
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkCacheAfterMovingGC
(
)
;
#
endif
}
;
class
NewProxyCache
{
struct
Entry
{
ObjectGroup
*
group
;
Shape
*
shape
;
}
;
static
const
size_t
NumEntries
=
4
;
mozilla
:
:
UniquePtr
<
Entry
[
]
JS
:
:
FreePolicy
>
entries_
;
public
:
MOZ_ALWAYS_INLINE
bool
lookup
(
const
Class
*
clasp
TaggedProto
proto
ObjectGroup
*
*
group
Shape
*
*
shape
)
const
{
if
(
!
entries_
)
return
false
;
for
(
size_t
i
=
0
;
i
<
NumEntries
;
i
+
+
)
{
const
Entry
&
entry
=
entries_
[
i
]
;
if
(
entry
.
group
&
&
entry
.
group
-
>
clasp
(
)
=
=
clasp
&
&
entry
.
group
-
>
proto
(
)
=
=
proto
)
{
*
group
=
entry
.
group
;
*
shape
=
entry
.
shape
;
return
true
;
}
}
return
false
;
}
void
add
(
ObjectGroup
*
group
Shape
*
shape
)
{
MOZ_ASSERT
(
group
&
&
shape
)
;
if
(
!
entries_
)
{
entries_
.
reset
(
js_pod_calloc
<
Entry
>
(
NumEntries
)
)
;
if
(
!
entries_
)
return
;
}
else
{
for
(
size_t
i
=
NumEntries
-
1
;
i
>
0
;
i
-
-
)
entries_
[
i
]
=
entries_
[
i
-
1
]
;
}
entries_
[
0
]
.
group
=
group
;
entries_
[
0
]
.
shape
=
shape
;
}
void
purge
(
)
{
entries_
.
reset
(
)
;
}
}
;
class
CrossCompartmentKey
{
public
:
enum
DebuggerObjectKind
:
uint8_t
{
DebuggerSource
DebuggerEnvironment
DebuggerObject
DebuggerWasmScript
DebuggerWasmSource
}
;
using
DebuggerAndObject
=
mozilla
:
:
Tuple
<
NativeObject
*
JSObject
*
DebuggerObjectKind
>
;
using
DebuggerAndScript
=
mozilla
:
:
Tuple
<
NativeObject
*
JSScript
*
>
;
using
WrappedType
=
mozilla
:
:
Variant
<
JSObject
*
JSString
*
DebuggerAndScript
DebuggerAndObject
>
;
explicit
CrossCompartmentKey
(
JSObject
*
obj
)
:
wrapped
(
obj
)
{
MOZ_RELEASE_ASSERT
(
obj
)
;
}
explicit
CrossCompartmentKey
(
JSString
*
str
)
:
wrapped
(
str
)
{
MOZ_RELEASE_ASSERT
(
str
)
;
}
explicit
CrossCompartmentKey
(
const
JS
:
:
Value
&
v
)
:
wrapped
(
v
.
isString
(
)
?
WrappedType
(
v
.
toString
(
)
)
:
WrappedType
(
&
v
.
toObject
(
)
)
)
{
}
explicit
CrossCompartmentKey
(
NativeObject
*
debugger
JSObject
*
obj
DebuggerObjectKind
kind
)
:
wrapped
(
DebuggerAndObject
(
debugger
obj
kind
)
)
{
MOZ_RELEASE_ASSERT
(
debugger
)
;
MOZ_RELEASE_ASSERT
(
obj
)
;
}
explicit
CrossCompartmentKey
(
NativeObject
*
debugger
JSScript
*
script
)
:
wrapped
(
DebuggerAndScript
(
debugger
script
)
)
{
MOZ_RELEASE_ASSERT
(
debugger
)
;
MOZ_RELEASE_ASSERT
(
script
)
;
}
bool
operator
=
=
(
const
CrossCompartmentKey
&
other
)
const
{
return
wrapped
=
=
other
.
wrapped
;
}
bool
operator
!
=
(
const
CrossCompartmentKey
&
other
)
const
{
return
wrapped
!
=
other
.
wrapped
;
}
template
<
typename
T
>
bool
is
(
)
const
{
return
wrapped
.
is
<
T
>
(
)
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
return
wrapped
.
as
<
T
>
(
)
;
}
template
<
typename
F
>
auto
applyToWrapped
(
F
f
)
-
>
decltype
(
f
(
static_cast
<
JSObject
*
*
>
(
nullptr
)
)
)
{
using
ReturnType
=
decltype
(
f
(
static_cast
<
JSObject
*
*
>
(
nullptr
)
)
)
;
struct
WrappedMatcher
{
F
f_
;
explicit
WrappedMatcher
(
F
f
)
:
f_
(
f
)
{
}
ReturnType
match
(
JSObject
*
&
obj
)
{
return
f_
(
&
obj
)
;
}
ReturnType
match
(
JSString
*
&
str
)
{
return
f_
(
&
str
)
;
}
ReturnType
match
(
DebuggerAndScript
&
tpl
)
{
return
f_
(
&
mozilla
:
:
Get
<
1
>
(
tpl
)
)
;
}
ReturnType
match
(
DebuggerAndObject
&
tpl
)
{
return
f_
(
&
mozilla
:
:
Get
<
1
>
(
tpl
)
)
;
}
}
matcher
(
f
)
;
return
wrapped
.
match
(
matcher
)
;
}
template
<
typename
F
>
auto
applyToDebugger
(
F
f
)
-
>
decltype
(
f
(
static_cast
<
NativeObject
*
*
>
(
nullptr
)
)
)
{
using
ReturnType
=
decltype
(
f
(
static_cast
<
NativeObject
*
*
>
(
nullptr
)
)
)
;
struct
DebuggerMatcher
{
F
f_
;
explicit
DebuggerMatcher
(
F
f
)
:
f_
(
f
)
{
}
ReturnType
match
(
JSObject
*
&
obj
)
{
return
ReturnType
(
)
;
}
ReturnType
match
(
JSString
*
&
str
)
{
return
ReturnType
(
)
;
}
ReturnType
match
(
DebuggerAndScript
&
tpl
)
{
return
f_
(
&
mozilla
:
:
Get
<
0
>
(
tpl
)
)
;
}
ReturnType
match
(
DebuggerAndObject
&
tpl
)
{
return
f_
(
&
mozilla
:
:
Get
<
0
>
(
tpl
)
)
;
}
}
matcher
(
f
)
;
return
wrapped
.
match
(
matcher
)
;
}
JS
:
:
Compartment
*
compartment
(
)
{
struct
GetCompartmentFunctor
{
JS
:
:
Compartment
*
operator
(
)
(
JSObject
*
*
tp
)
const
{
return
(
*
tp
)
-
>
compartment
(
)
;
}
JS
:
:
Compartment
*
operator
(
)
(
JSScript
*
*
tp
)
const
{
return
(
*
tp
)
-
>
compartment
(
)
;
}
JS
:
:
Compartment
*
operator
(
)
(
JSString
*
*
tp
)
const
{
return
nullptr
;
}
}
;
return
applyToWrapped
(
GetCompartmentFunctor
(
)
)
;
}
struct
Hasher
:
public
DefaultHasher
<
CrossCompartmentKey
>
{
struct
HashFunctor
{
HashNumber
match
(
JSObject
*
obj
)
{
return
DefaultHasher
<
JSObject
*
>
:
:
hash
(
obj
)
;
}
HashNumber
match
(
JSString
*
str
)
{
return
DefaultHasher
<
JSString
*
>
:
:
hash
(
str
)
;
}
HashNumber
match
(
const
DebuggerAndScript
&
tpl
)
{
return
DefaultHasher
<
NativeObject
*
>
:
:
hash
(
mozilla
:
:
Get
<
0
>
(
tpl
)
)
^
DefaultHasher
<
JSScript
*
>
:
:
hash
(
mozilla
:
:
Get
<
1
>
(
tpl
)
)
;
}
HashNumber
match
(
const
DebuggerAndObject
&
tpl
)
{
return
DefaultHasher
<
NativeObject
*
>
:
:
hash
(
mozilla
:
:
Get
<
0
>
(
tpl
)
)
^
DefaultHasher
<
JSObject
*
>
:
:
hash
(
mozilla
:
:
Get
<
1
>
(
tpl
)
)
^
(
mozilla
:
:
Get
<
2
>
(
tpl
)
<
<
5
)
;
}
}
;
static
HashNumber
hash
(
const
CrossCompartmentKey
&
key
)
{
return
key
.
wrapped
.
match
(
HashFunctor
(
)
)
;
}
static
bool
match
(
const
CrossCompartmentKey
&
l
const
CrossCompartmentKey
&
k
)
{
return
l
.
wrapped
=
=
k
.
wrapped
;
}
}
;
bool
isTenured
(
)
const
{
struct
IsTenuredFunctor
{
using
ReturnType
=
bool
;
ReturnType
operator
(
)
(
JSObject
*
*
tp
)
{
return
!
IsInsideNursery
(
*
tp
)
;
}
ReturnType
operator
(
)
(
JSScript
*
*
tp
)
{
return
true
;
}
ReturnType
operator
(
)
(
JSString
*
*
tp
)
{
return
!
IsInsideNursery
(
*
tp
)
;
}
}
;
return
const_cast
<
CrossCompartmentKey
*
>
(
this
)
-
>
applyToWrapped
(
IsTenuredFunctor
(
)
)
;
}
void
trace
(
JSTracer
*
trc
)
;
bool
needsSweep
(
)
;
private
:
CrossCompartmentKey
(
)
=
delete
;
WrappedType
wrapped
;
}
;
class
WrapperMap
{
static
const
size_t
InitialInnerMapSize
=
4
;
using
InnerMap
=
NurseryAwareHashMap
<
CrossCompartmentKey
JS
:
:
Value
CrossCompartmentKey
:
:
Hasher
SystemAllocPolicy
>
;
using
OuterMap
=
GCHashMap
<
JS
:
:
Compartment
*
InnerMap
DefaultHasher
<
JS
:
:
Compartment
*
>
SystemAllocPolicy
>
;
OuterMap
map
;
public
:
class
Enum
{
public
:
enum
SkipStrings
:
bool
{
WithStrings
=
false
WithoutStrings
=
true
}
;
private
:
Enum
(
const
Enum
&
)
=
delete
;
void
operator
=
(
const
Enum
&
)
=
delete
;
void
goToNext
(
)
{
if
(
outer
.
isNothing
(
)
)
return
;
for
(
;
!
outer
-
>
empty
(
)
;
outer
-
>
popFront
(
)
)
{
JS
:
:
Compartment
*
c
=
outer
-
>
front
(
)
.
key
(
)
;
if
(
!
c
&
&
skipStrings
)
continue
;
if
(
filter
&
&
!
filter
-
>
match
(
c
)
)
continue
;
InnerMap
&
m
=
outer
-
>
front
(
)
.
value
(
)
;
if
(
!
m
.
empty
(
)
)
{
if
(
inner
.
isSome
(
)
)
inner
.
reset
(
)
;
inner
.
emplace
(
m
)
;
outer
-
>
popFront
(
)
;
return
;
}
}
}
mozilla
:
:
Maybe
<
OuterMap
:
:
Enum
>
outer
;
mozilla
:
:
Maybe
<
InnerMap
:
:
Enum
>
inner
;
const
CompartmentFilter
*
filter
;
SkipStrings
skipStrings
;
public
:
explicit
Enum
(
WrapperMap
&
m
SkipStrings
s
=
WithStrings
)
:
filter
(
nullptr
)
skipStrings
(
s
)
{
outer
.
emplace
(
m
.
map
)
;
goToNext
(
)
;
}
Enum
(
WrapperMap
&
m
const
CompartmentFilter
&
f
SkipStrings
s
=
WithStrings
)
:
filter
(
&
f
)
skipStrings
(
s
)
{
outer
.
emplace
(
m
.
map
)
;
goToNext
(
)
;
}
Enum
(
WrapperMap
&
m
JS
:
:
Compartment
*
target
)
{
auto
p
=
m
.
map
.
lookup
(
target
)
;
if
(
p
)
inner
.
emplace
(
p
-
>
value
(
)
)
;
}
bool
empty
(
)
const
{
return
(
outer
.
isNothing
(
)
|
|
outer
-
>
empty
(
)
)
&
&
(
inner
.
isNothing
(
)
|
|
inner
-
>
empty
(
)
)
;
}
InnerMap
:
:
Entry
&
front
(
)
const
{
MOZ_ASSERT
(
inner
.
isSome
(
)
&
&
!
inner
-
>
empty
(
)
)
;
return
inner
-
>
front
(
)
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
if
(
!
inner
-
>
empty
(
)
)
{
inner
-
>
popFront
(
)
;
if
(
!
inner
-
>
empty
(
)
)
return
;
}
goToNext
(
)
;
}
void
removeFront
(
)
{
MOZ_ASSERT
(
inner
.
isSome
(
)
)
;
inner
-
>
removeFront
(
)
;
}
}
;
class
Ptr
:
public
InnerMap
:
:
Ptr
{
friend
class
WrapperMap
;
InnerMap
*
map
;
Ptr
(
)
:
InnerMap
:
:
Ptr
(
)
map
(
nullptr
)
{
}
Ptr
(
const
InnerMap
:
:
Ptr
&
p
InnerMap
&
m
)
:
InnerMap
:
:
Ptr
(
p
)
map
(
&
m
)
{
}
}
;
MOZ_MUST_USE
bool
init
(
uint32_t
len
)
{
return
map
.
init
(
len
)
;
}
bool
empty
(
)
{
if
(
map
.
empty
(
)
)
return
true
;
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
!
e
.
front
(
)
.
value
(
)
.
empty
(
)
)
return
false
;
}
return
true
;
}
Ptr
lookup
(
const
CrossCompartmentKey
&
k
)
const
{
auto
op
=
map
.
lookup
(
const_cast
<
CrossCompartmentKey
&
>
(
k
)
.
compartment
(
)
)
;
if
(
op
)
{
auto
ip
=
op
-
>
value
(
)
.
lookup
(
k
)
;
if
(
ip
)
return
Ptr
(
ip
op
-
>
value
(
)
)
;
}
return
Ptr
(
)
;
}
void
remove
(
Ptr
p
)
{
if
(
p
)
p
.
map
-
>
remove
(
p
)
;
}
MOZ_MUST_USE
bool
put
(
const
CrossCompartmentKey
&
k
const
JS
:
:
Value
&
v
)
{
JS
:
:
Compartment
*
c
=
const_cast
<
CrossCompartmentKey
&
>
(
k
)
.
compartment
(
)
;
MOZ_ASSERT
(
k
.
is
<
JSString
*
>
(
)
=
=
!
c
)
;
auto
p
=
map
.
lookupForAdd
(
c
)
;
if
(
!
p
)
{
InnerMap
m
;
if
(
!
m
.
init
(
InitialInnerMapSize
)
|
|
!
map
.
add
(
p
c
std
:
:
move
(
m
)
)
)
return
false
;
}
return
p
-
>
value
(
)
.
put
(
k
v
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
size
=
map
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
size
+
=
e
.
front
(
)
.
value
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
return
size
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
size
=
map
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
size
+
=
e
.
front
(
)
.
value
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
size
;
}
bool
hasNurseryAllocatedWrapperEntries
(
const
CompartmentFilter
&
f
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JS
:
:
Compartment
*
c
=
e
.
front
(
)
.
key
(
)
;
if
(
c
&
&
!
f
.
match
(
c
)
)
continue
;
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
if
(
m
.
hasNurseryEntries
(
)
)
return
true
;
}
return
false
;
}
void
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
m
.
sweepAfterMinorGC
(
trc
)
;
if
(
m
.
empty
(
)
)
e
.
removeFront
(
)
;
}
}
void
sweep
(
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
m
.
sweep
(
)
;
if
(
m
.
empty
(
)
)
e
.
removeFront
(
)
;
}
}
}
;
struct
ImmediateMetadata
{
}
;
struct
DelayMetadata
{
}
;
using
PendingMetadata
=
JSObject
*
;
using
NewObjectMetadataState
=
mozilla
:
:
Variant
<
ImmediateMetadata
DelayMetadata
PendingMetadata
>
;
class
MOZ_RAII
AutoSetNewObjectMetadata
:
private
JS
:
:
CustomAutoRooter
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
JSContext
*
cx_
;
NewObjectMetadataState
prevState_
;
AutoSetNewObjectMetadata
(
const
AutoSetNewObjectMetadata
&
aOther
)
=
delete
;
void
operator
=
(
const
AutoSetNewObjectMetadata
&
aOther
)
=
delete
;
protected
:
virtual
void
trace
(
JSTracer
*
trc
)
override
{
if
(
prevState_
.
is
<
PendingMetadata
>
(
)
)
{
TraceRoot
(
trc
&
prevState_
.
as
<
PendingMetadata
>
(
)
"
Object
pending
metadata
"
)
;
}
}
public
:
explicit
AutoSetNewObjectMetadata
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoSetNewObjectMetadata
(
)
;
}
;
class
PropertyIteratorObject
;
struct
IteratorHashPolicy
{
struct
Lookup
{
ReceiverGuard
*
guards
;
size_t
numGuards
;
uint32_t
key
;
Lookup
(
ReceiverGuard
*
guards
size_t
numGuards
uint32_t
key
)
:
guards
(
guards
)
numGuards
(
numGuards
)
key
(
key
)
{
MOZ_ASSERT
(
numGuards
>
0
)
;
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
lookup
.
key
;
}
static
bool
match
(
PropertyIteratorObject
*
obj
const
Lookup
&
lookup
)
;
}
;
}
namespace
js
{
class
DebugEnvironments
;
class
ObjectWeakMap
;
class
WeakMapBase
;
}
class
JS
:
:
Compartment
{
JS
:
:
Zone
*
zone_
;
JSRuntime
*
runtime_
;
js
:
:
WrapperMap
crossCompartmentWrappers
;
using
RealmVector
=
js
:
:
Vector
<
JS
:
:
Realm
*
1
js
:
:
SystemAllocPolicy
>
;
RealmVector
realms_
;
public
:
JSObject
*
gcIncomingGrayPointers
=
nullptr
;
void
*
data
=
nullptr
;
struct
{
bool
scheduledForDestruction
=
false
;
bool
maybeAlive
=
true
;
bool
hasEnteredRealm
=
false
;
}
gcState
;
JS
:
:
Zone
*
zone
(
)
{
return
zone_
;
}
const
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
JSRuntime
*
runtimeFromMainThread
(
)
const
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
return
runtime_
;
}
RealmVector
&
realms
(
)
{
return
realms_
;
}
void
assertNoCrossCompartmentWrappers
(
)
{
MOZ_ASSERT
(
crossCompartmentWrappers
.
empty
(
)
)
;
}
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
compartmentObjects
size_t
*
crossCompartmentWrappersTables
size_t
*
compartmentsPrivateData
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkWrapperMapAfterMovingGC
(
)
;
#
endif
private
:
bool
getNonWrapperObjectForCurrentCompartment
(
JSContext
*
cx
js
:
:
MutableHandleObject
obj
)
;
bool
getOrCreateWrapper
(
JSContext
*
cx
js
:
:
HandleObject
existing
js
:
:
MutableHandleObject
obj
)
;
public
:
explicit
Compartment
(
JS
:
:
Zone
*
zone
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
void
destroy
(
js
:
:
FreeOp
*
fop
)
;
MOZ_MUST_USE
inline
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleValue
vp
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
js
:
:
MutableHandleString
strp
)
;
#
ifdef
ENABLE_BIGINT
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
js
:
:
MutableHandle
<
JS
:
:
BigInt
*
>
bi
)
;
#
endif
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleObject
obj
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandle
<
js
:
:
PropertyDescriptor
>
desc
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
GCVector
<
JS
:
:
Value
>
>
vec
)
;
MOZ_MUST_USE
bool
rewrap
(
JSContext
*
cx
JS
:
:
MutableHandleObject
obj
JS
:
:
HandleObject
existing
)
;
MOZ_MUST_USE
bool
putWrapper
(
JSContext
*
cx
const
js
:
:
CrossCompartmentKey
&
wrapped
const
js
:
:
Value
&
wrapper
)
;
js
:
:
WrapperMap
:
:
Ptr
lookupWrapper
(
const
js
:
:
Value
&
wrapped
)
const
{
return
crossCompartmentWrappers
.
lookup
(
js
:
:
CrossCompartmentKey
(
wrapped
)
)
;
}
js
:
:
WrapperMap
:
:
Ptr
lookupWrapper
(
JSObject
*
obj
)
const
{
return
crossCompartmentWrappers
.
lookup
(
js
:
:
CrossCompartmentKey
(
obj
)
)
;
}
void
removeWrapper
(
js
:
:
WrapperMap
:
:
Ptr
p
)
{
crossCompartmentWrappers
.
remove
(
p
)
;
}
bool
hasNurseryAllocatedWrapperEntries
(
const
js
:
:
CompartmentFilter
&
f
)
{
return
crossCompartmentWrappers
.
hasNurseryAllocatedWrapperEntries
(
f
)
;
}
struct
WrapperEnum
:
public
js
:
:
WrapperMap
:
:
Enum
{
explicit
WrapperEnum
(
JS
:
:
Compartment
*
c
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
)
{
}
}
;
struct
NonStringWrapperEnum
:
public
js
:
:
WrapperMap
:
:
Enum
{
explicit
NonStringWrapperEnum
(
JS
:
:
Compartment
*
c
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
WithoutStrings
)
{
}
explicit
NonStringWrapperEnum
(
JS
:
:
Compartment
*
c
const
js
:
:
CompartmentFilter
&
f
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
f
WithoutStrings
)
{
}
explicit
NonStringWrapperEnum
(
JS
:
:
Compartment
*
c
JS
:
:
Compartment
*
target
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
target
)
{
MOZ_ASSERT
(
target
)
;
}
}
;
struct
StringWrapperEnum
:
public
js
:
:
WrapperMap
:
:
Enum
{
explicit
StringWrapperEnum
(
JS
:
:
Compartment
*
c
)
:
js
:
:
WrapperMap
:
:
Enum
(
c
-
>
crossCompartmentWrappers
nullptr
)
{
}
}
;
void
traceOutgoingCrossCompartmentWrappers
(
JSTracer
*
trc
)
;
static
void
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
)
;
void
sweepRealms
(
js
:
:
FreeOp
*
fop
bool
keepAtleastOne
bool
destroyingRuntime
)
;
void
sweepAfterMinorGC
(
JSTracer
*
trc
)
;
void
sweepCrossCompartmentWrappers
(
)
;
static
void
fixupCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
;
void
fixupAfterMovingGC
(
)
;
void
findOutgoingEdges
(
js
:
:
gc
:
:
ZoneComponentFinder
&
finder
)
;
}
;
namespace
js
{
class
ObjectRealm
{
using
NativeIteratorSentinel
=
js
:
:
UniquePtr
<
js
:
:
NativeIterator
JS
:
:
FreePolicy
>
;
NativeIteratorSentinel
iteratorSentinel_
;
js
:
:
UniquePtr
<
js
:
:
ObjectWeakMap
>
nonSyntacticLexicalEnvironments_
;
ObjectRealm
(
const
ObjectRealm
&
)
=
delete
;
void
operator
=
(
const
ObjectRealm
&
)
=
delete
;
public
:
js
:
:
NativeIterator
*
enumerators
=
nullptr
;
JS
:
:
WeakCache
<
js
:
:
InnerViewTable
>
innerViews
;
js
:
:
UniquePtr
<
js
:
:
ObjectWeakMap
>
lazyArrayBuffers
;
js
:
:
UniquePtr
<
js
:
:
ObjectWeakMap
>
objectMetadataTable
;
using
IteratorCache
=
js
:
:
HashSet
<
js
:
:
PropertyIteratorObject
*
js
:
:
IteratorHashPolicy
js
:
:
SystemAllocPolicy
>
;
IteratorCache
iteratorCache
;
static
inline
ObjectRealm
&
get
(
const
JSObject
*
obj
)
;
explicit
ObjectRealm
(
JS
:
:
Zone
*
zone
)
;
~
ObjectRealm
(
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
void
finishRoots
(
)
;
void
trace
(
JSTracer
*
trc
)
;
void
sweepAfterMinorGC
(
)
;
void
sweepNativeIterators
(
)
;
void
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
innerViewsArg
size_t
*
lazyArrayBuffersArg
size_t
*
objectMetadataTablesArg
size_t
*
nonSyntacticLexicalEnvironmentsArg
)
;
MOZ_ALWAYS_INLINE
bool
objectMaybeInIteration
(
JSObject
*
obj
)
;
js
:
:
LexicalEnvironmentObject
*
getOrCreateNonSyntacticLexicalEnvironment
(
JSContext
*
cx
js
:
:
HandleObject
enclosing
)
;
js
:
:
LexicalEnvironmentObject
*
getNonSyntacticLexicalEnvironment
(
JSObject
*
enclosing
)
const
;
}
;
}
class
JS
:
:
Realm
:
public
JS
:
:
shadow
:
:
Realm
{
JS
:
:
Zone
*
zone_
;
JSRuntime
*
runtime_
;
const
JS
:
:
RealmCreationOptions
creationOptions_
;
JS
:
:
RealmBehaviors
behaviors_
;
friend
struct
:
:
JSContext
;
js
:
:
ReadBarrieredGlobalObject
global_
;
js
:
:
ObjectRealm
objects_
;
friend
js
:
:
ObjectRealm
&
js
:
:
ObjectRealm
:
:
get
(
const
JSObject
*
)
;
js
:
:
ObjectGroupRealm
objectGroups_
;
friend
js
:
:
ObjectGroupRealm
&
js
:
:
ObjectGroupRealm
:
:
get
(
js
:
:
ObjectGroup
*
group
)
;
friend
js
:
:
ObjectGroupRealm
&
js
:
:
ObjectGroupRealm
:
:
getForNewObject
(
JSContext
*
cx
)
;
using
VarNamesSet
=
JS
:
:
GCHashSet
<
JSAtom
*
js
:
:
DefaultHasher
<
JSAtom
*
>
js
:
:
SystemAllocPolicy
>
;
VarNamesSet
varNames_
;
friend
class
js
:
:
AutoSetNewObjectMetadata
;
js
:
:
NewObjectMetadataState
objectMetadataState_
{
js
:
:
ImmediateMetadata
(
)
}
;
mozilla
:
:
Maybe
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
randomNumberGenerator_
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
randomKeyGenerator_
;
JSPrincipals
*
principals_
=
nullptr
;
js
:
:
UniquePtr
<
js
:
:
jit
:
:
JitRealm
>
jitRealm_
;
js
:
:
UniquePtr
<
js
:
:
DebugEnvironments
>
debugEnvs_
;
js
:
:
SavedStacks
savedStacks_
;
JS
:
:
RealmStats
*
realmStats_
=
nullptr
;
const
js
:
:
AllocationMetadataBuilder
*
allocationMetadataBuilder_
=
nullptr
;
void
*
realmPrivate_
=
nullptr
;
bool
*
validAccessPtr_
=
nullptr
;
js
:
:
ReadBarriered
<
js
:
:
ArgumentsObject
*
>
mappedArgumentsTemplate_
{
nullptr
}
;
js
:
:
ReadBarriered
<
js
:
:
ArgumentsObject
*
>
unmappedArgumentsTemplate_
{
nullptr
}
;
js
:
:
ReadBarriered
<
js
:
:
NativeObject
*
>
iterResultTemplate_
{
nullptr
}
;
unsigned
enterRealmDepthIgnoringJit_
=
0
;
enum
{
IsDebuggee
=
1
<
<
0
DebuggerObservesAllExecution
=
1
<
<
1
DebuggerObservesAsmJS
=
1
<
<
2
DebuggerObservesCoverage
=
1
<
<
3
DebuggerObservesBinarySource
=
1
<
<
4
DebuggerNeedsDelazification
=
1
<
<
5
}
;
static
const
unsigned
DebuggerObservesMask
=
IsDebuggee
|
DebuggerObservesAllExecution
|
DebuggerObservesCoverage
|
DebuggerObservesAsmJS
|
DebuggerObservesBinarySource
;
unsigned
debugModeBits_
=
0
;
friend
class
js
:
:
AutoRestoreRealmDebugMode
;
bool
isSelfHostingRealm_
=
false
;
bool
marked_
=
true
;
bool
isSystem_
=
false
;
public
:
js
:
:
wasm
:
:
Realm
wasm
;
js
:
:
coverage
:
:
LCovRealm
lcovOutput
;
js
:
:
RegExpRealm
regExps
;
js
:
:
DtoaCache
dtoaCache
;
js
:
:
NewProxyCache
newProxyCache
;
js
:
:
ArraySpeciesLookup
arraySpeciesLookup
;
js
:
:
PerformanceGroupHolder
performanceMonitoring
;
js
:
:
UniquePtr
<
js
:
:
ScriptCountsMap
>
scriptCountsMap
;
js
:
:
UniquePtr
<
js
:
:
ScriptNameMap
>
scriptNameMap
;
js
:
:
UniquePtr
<
js
:
:
DebugScriptMap
>
debugScriptMap
;
js
:
:
ReadBarrieredScriptSourceObject
selfHostingScriptSource
{
nullptr
}
;
int64_t
lastAnimationTime
=
0
;
uint32_t
globalWriteBarriered
=
0
;
uint32_t
warnedAboutStringGenericsMethods
=
0
;
#
ifdef
DEBUG
bool
firedOnNewGlobalObject
=
false
;
#
endif
private
:
void
updateDebuggerObservesFlag
(
unsigned
flag
)
;
Realm
(
const
Realm
&
)
=
delete
;
void
operator
=
(
const
Realm
&
)
=
delete
;
public
:
Realm
(
JS
:
:
Compartment
*
comp
const
JS
:
:
RealmOptions
&
options
)
;
~
Realm
(
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
void
destroy
(
js
:
:
FreeOp
*
fop
)
;
void
clearTables
(
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
tiAllocationSiteTables
size_t
*
tiArrayTypeTables
size_t
*
tiObjectTypeTables
size_t
*
realmObject
size_t
*
realmTables
size_t
*
innerViews
size_t
*
lazyArrayBuffers
size_t
*
objectMetadataTables
size_t
*
savedStacksSet
size_t
*
varNamesSet
size_t
*
nonSyntacticLexicalScopes
size_t
*
jitRealm
size_t
*
scriptCountsMapArg
)
;
JS
:
:
Zone
*
zone
(
)
{
return
zone_
;
}
const
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
JSRuntime
*
runtimeFromMainThread
(
)
const
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
return
runtime_
;
}
const
JS
:
:
RealmCreationOptions
&
creationOptions
(
)
const
{
return
creationOptions_
;
}
JS
:
:
RealmBehaviors
&
behaviors
(
)
{
return
behaviors_
;
}
const
JS
:
:
RealmBehaviors
&
behaviors
(
)
const
{
return
behaviors_
;
}
bool
preserveJitCode
(
)
{
return
creationOptions_
.
preserveJitCode
(
)
;
}
bool
isSelfHostingRealm
(
)
const
{
return
isSelfHostingRealm_
;
}
void
setIsSelfHostingRealm
(
)
{
isSelfHostingRealm_
=
true
;
}
inline
js
:
:
GlobalObject
*
maybeGlobal
(
)
const
;
inline
js
:
:
GlobalObject
*
unsafeUnbarrieredMaybeGlobal
(
)
const
;
inline
bool
globalIsAboutToBeFinalized
(
)
;
inline
void
initGlobal
(
js
:
:
GlobalObject
&
global
)
;
void
traceGlobal
(
JSTracer
*
trc
)
;
void
sweepGlobalObject
(
)
;
void
fixupGlobal
(
)
;
void
traceRoots
(
JSTracer
*
trc
js
:
:
gc
:
:
GCRuntime
:
:
TraceOrMarkRuntime
traceOrMark
)
;
void
finishRoots
(
)
;
void
sweepAfterMinorGC
(
)
;
void
sweepDebugEnvironments
(
)
;
void
sweepObjectRealm
(
)
;
void
sweepRegExps
(
)
;
void
sweepSelfHostingScriptSource
(
)
;
void
sweepTemplateObjects
(
)
;
void
sweepObjectGroups
(
)
{
objectGroups_
.
sweep
(
)
;
}
void
clearScriptCounts
(
)
;
void
clearScriptNames
(
)
;
void
purge
(
)
;
void
fixupAfterMovingGC
(
)
;
void
fixupScriptMapsAfterMovingGC
(
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkObjectGroupTablesAfterMovingGC
(
)
{
objectGroups_
.
checkTablesAfterMovingGC
(
)
;
}
void
checkScriptMapsAfterMovingGC
(
)
;
#
endif
MOZ_MUST_USE
bool
addToVarNames
(
JSContext
*
cx
JS
:
:
Handle
<
JSAtom
*
>
name
)
;
void
sweepVarNames
(
)
;
void
removeFromVarNames
(
JS
:
:
Handle
<
JSAtom
*
>
name
)
{
varNames_
.
remove
(
name
)
;
}
bool
isInVarNames
(
JS
:
:
Handle
<
JSAtom
*
>
name
)
{
return
varNames_
.
has
(
name
)
;
}
void
enter
(
)
{
enterRealmDepthIgnoringJit_
+
+
;
}
void
leave
(
)
{
MOZ_ASSERT
(
enterRealmDepthIgnoringJit_
>
0
)
;
enterRealmDepthIgnoringJit_
-
-
;
}
bool
hasBeenEnteredIgnoringJit
(
)
const
{
return
enterRealmDepthIgnoringJit_
>
0
;
}
bool
shouldTraceGlobal
(
)
const
{
return
hasBeenEnteredIgnoringJit
(
)
;
}
bool
hasAllocationMetadataBuilder
(
)
const
{
return
allocationMetadataBuilder_
;
}
const
js
:
:
AllocationMetadataBuilder
*
getAllocationMetadataBuilder
(
)
const
{
return
allocationMetadataBuilder_
;
}
const
void
*
addressOfMetadataBuilder
(
)
const
{
return
&
allocationMetadataBuilder_
;
}
void
setAllocationMetadataBuilder
(
const
js
:
:
AllocationMetadataBuilder
*
builder
)
;
void
forgetAllocationMetadataBuilder
(
)
;
void
setNewObjectMetadata
(
JSContext
*
cx
JS
:
:
HandleObject
obj
)
;
bool
hasObjectPendingMetadata
(
)
const
{
return
objectMetadataState_
.
is
<
js
:
:
PendingMetadata
>
(
)
;
}
void
setObjectPendingMetadata
(
JSContext
*
cx
JSObject
*
obj
)
{
if
(
!
cx
-
>
helperThread
(
)
)
{
MOZ_ASSERT
(
objectMetadataState_
.
is
<
js
:
:
DelayMetadata
>
(
)
)
;
objectMetadataState_
=
js
:
:
NewObjectMetadataState
(
js
:
:
PendingMetadata
(
obj
)
)
;
}
}
void
*
realmPrivate
(
)
const
{
return
realmPrivate_
;
}
void
setRealmPrivate
(
void
*
p
)
{
realmPrivate_
=
p
;
}
JS
:
:
RealmStats
&
realmStats
(
)
{
MOZ_RELEASE_ASSERT
(
realmStats_
)
;
return
*
realmStats_
;
}
void
nullRealmStats
(
)
{
MOZ_ASSERT
(
realmStats_
)
;
realmStats_
=
nullptr
;
}
void
setRealmStats
(
JS
:
:
RealmStats
*
newStats
)
{
MOZ_ASSERT
(
!
realmStats_
&
&
newStats
)
;
realmStats_
=
newStats
;
}
bool
marked
(
)
const
{
return
marked_
;
}
void
mark
(
)
{
marked_
=
true
;
}
void
unmark
(
)
{
marked_
=
false
;
}
JSPrincipals
*
principals
(
)
{
return
principals_
;
}
void
setPrincipals
(
JSPrincipals
*
principals
)
{
if
(
principals_
=
=
principals
)
return
;
performanceMonitoring
.
unlink
(
)
;
principals_
=
principals
;
}
bool
isSystem
(
)
const
{
return
isSystem_
;
}
void
setIsSystem
(
bool
isSystem
)
{
if
(
isSystem_
=
=
isSystem
)
return
;
performanceMonitoring
.
unlink
(
)
;
isSystem_
=
isSystem
;
}
bool
isProbablySystemCode
(
)
const
{
return
isSystem_
;
}
static
const
size_t
IterResultObjectValueSlot
=
0
;
static
const
size_t
IterResultObjectDoneSlot
=
1
;
js
:
:
NativeObject
*
getOrCreateIterResultTemplateObject
(
JSContext
*
cx
)
;
js
:
:
ArgumentsObject
*
getOrCreateArgumentsTemplateObject
(
JSContext
*
cx
bool
mapped
)
;
js
:
:
ArgumentsObject
*
maybeArgumentsTemplateObject
(
bool
mapped
)
const
;
bool
isDebuggee
(
)
const
{
return
!
!
(
debugModeBits_
&
IsDebuggee
)
;
}
void
setIsDebuggee
(
)
{
debugModeBits_
|
=
IsDebuggee
;
}
void
unsetIsDebuggee
(
)
;
bool
debuggerObservesAllExecution
(
)
const
{
static
const
unsigned
Mask
=
IsDebuggee
|
DebuggerObservesAllExecution
;
return
(
debugModeBits_
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesAllExecution
(
)
{
updateDebuggerObservesFlag
(
DebuggerObservesAllExecution
)
;
}
bool
debuggerObservesAsmJS
(
)
const
{
static
const
unsigned
Mask
=
IsDebuggee
|
DebuggerObservesAsmJS
;
return
(
debugModeBits_
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesAsmJS
(
)
{
updateDebuggerObservesFlag
(
DebuggerObservesAsmJS
)
;
}
bool
debuggerObservesBinarySource
(
)
const
{
static
const
unsigned
Mask
=
IsDebuggee
|
DebuggerObservesBinarySource
;
return
(
debugModeBits_
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesBinarySource
(
)
{
updateDebuggerObservesFlag
(
DebuggerObservesBinarySource
)
;
}
bool
debuggerObservesCoverage
(
)
const
{
static
const
unsigned
Mask
=
DebuggerObservesCoverage
;
return
(
debugModeBits_
&
Mask
)
=
=
Mask
;
}
void
updateDebuggerObservesCoverage
(
)
;
bool
collectCoverage
(
)
const
;
bool
collectCoverageForDebug
(
)
const
;
bool
collectCoverageForPGO
(
)
const
;
bool
needsDelazificationForDebugger
(
)
const
{
return
debugModeBits_
&
DebuggerNeedsDelazification
;
}
void
scheduleDelazificationForDebugger
(
)
{
debugModeBits_
|
=
DebuggerNeedsDelazification
;
}
bool
ensureDelazifyScriptsForDebugger
(
JSContext
*
cx
)
;
void
clearBreakpointsIn
(
js
:
:
FreeOp
*
fop
js
:
:
Debugger
*
dbg
JS
:
:
HandleObject
handler
)
;
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
&
getOrCreateRandomNumberGenerator
(
)
;
const
void
*
addressOfRandomNumberGenerator
(
)
const
{
return
randomNumberGenerator_
.
ptr
(
)
;
}
mozilla
:
:
HashCodeScrambler
randomHashCodeScrambler
(
)
;
bool
isAccessValid
(
)
const
{
return
validAccessPtr_
?
*
validAccessPtr_
:
true
;
}
void
setValidAccessPtr
(
bool
*
accessp
)
{
validAccessPtr_
=
accessp
;
}
bool
ensureJitRealmExists
(
JSContext
*
cx
)
;
void
sweepJitRealm
(
)
;
js
:
:
jit
:
:
JitRealm
*
jitRealm
(
)
{
return
jitRealm_
.
get
(
)
;
}
js
:
:
DebugEnvironments
*
debugEnvs
(
)
{
return
debugEnvs_
.
get
(
)
;
}
js
:
:
UniquePtr
<
js
:
:
DebugEnvironments
>
&
debugEnvsRef
(
)
{
return
debugEnvs_
;
}
js
:
:
SavedStacks
&
savedStacks
(
)
{
return
savedStacks_
;
}
void
chooseAllocationSamplingProbability
(
)
{
savedStacks_
.
chooseSamplingProbability
(
this
)
;
}
void
sweepSavedStacks
(
)
;
static
constexpr
size_t
offsetOfCompartment
(
)
{
return
offsetof
(
JS
:
:
Realm
compartment_
)
;
}
static
constexpr
size_t
offsetOfRegExps
(
)
{
return
offsetof
(
JS
:
:
Realm
regExps
)
;
}
}
;
namespace
js
{
template
<
typename
T
>
inline
void
SetMaybeAliveFlag
(
T
*
thing
)
{
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSObject
*
thing
)
{
thing
-
>
compartment
(
)
-
>
gcState
.
maybeAlive
=
true
;
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSScript
*
thing
)
{
thing
-
>
compartment
(
)
-
>
gcState
.
maybeAlive
=
true
;
}
}
inline
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
JSContext
:
:
global
(
)
const
{
MOZ_ASSERT
(
realm_
"
Caller
needs
to
enter
a
realm
first
"
)
;
return
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
:
:
fromMarkedLocation
(
realm_
-
>
global_
.
unsafeGet
(
)
)
;
}
namespace
js
{
class
MOZ_RAII
AssertRealmUnchanged
{
public
:
explicit
AssertRealmUnchanged
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
cx
(
cx
)
oldRealm
(
cx
-
>
realm
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AssertRealmUnchanged
(
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
oldRealm
)
;
}
protected
:
JSContext
*
const
cx
;
JS
:
:
Realm
*
const
oldRealm
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
AutoRealm
{
JSContext
*
const
cx_
;
JS
:
:
Realm
*
const
origin_
;
public
:
template
<
typename
T
>
inline
AutoRealm
(
JSContext
*
cx
const
T
&
target
)
;
inline
~
AutoRealm
(
)
;
JSContext
*
context
(
)
const
{
return
cx_
;
}
JS
:
:
Realm
*
origin
(
)
const
{
return
origin_
;
}
protected
:
inline
AutoRealm
(
JSContext
*
cx
JS
:
:
Realm
*
target
)
;
private
:
AutoRealm
(
const
AutoRealm
&
)
=
delete
;
AutoRealm
&
operator
=
(
const
AutoRealm
&
)
=
delete
;
}
;
class
MOZ_RAII
AutoAtomsZone
{
JSContext
*
const
cx_
;
JS
:
:
Realm
*
const
origin_
;
const
AutoLockForExclusiveAccess
&
lock_
;
AutoAtomsZone
(
const
AutoAtomsZone
&
)
=
delete
;
AutoAtomsZone
&
operator
=
(
const
AutoAtomsZone
&
)
=
delete
;
public
:
inline
AutoAtomsZone
(
JSContext
*
cx
AutoLockForExclusiveAccess
&
lock
)
;
inline
~
AutoAtomsZone
(
)
;
}
;
class
AutoRealmUnchecked
:
protected
AutoRealm
{
public
:
inline
AutoRealmUnchecked
(
JSContext
*
cx
JS
:
:
Realm
*
target
)
;
}
;
class
ErrorCopier
{
mozilla
:
:
Maybe
<
AutoRealm
>
&
ar
;
public
:
explicit
ErrorCopier
(
mozilla
:
:
Maybe
<
AutoRealm
>
&
ar
)
:
ar
(
ar
)
{
}
~
ErrorCopier
(
)
;
}
;
struct
WrapperValue
{
explicit
WrapperValue
(
const
WrapperMap
:
:
Ptr
&
ptr
)
:
value
(
*
ptr
-
>
value
(
)
.
unsafeGet
(
)
)
{
}
explicit
WrapperValue
(
const
WrapperMap
:
:
Enum
&
e
)
:
value
(
*
e
.
front
(
)
.
value
(
)
.
unsafeGet
(
)
)
{
}
Value
&
get
(
)
{
return
value
;
}
Value
get
(
)
const
{
return
value
;
}
operator
const
Value
&
(
)
const
{
return
value
;
}
JSObject
&
toObject
(
)
const
{
return
value
.
toObject
(
)
;
}
private
:
Value
value
;
}
;
class
MOZ_RAII
AutoWrapperVector
:
public
JS
:
:
GCVector
<
WrapperValue
8
>
private
JS
:
:
AutoGCRooter
{
public
:
explicit
AutoWrapperVector
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
GCVector
<
WrapperValue
8
>
(
cx
)
JS
:
:
AutoGCRooter
(
cx
JS
:
:
AutoGCRooter
:
:
Tag
:
:
WrapperVector
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
friend
void
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoWrapperRooter
:
private
JS
:
:
AutoGCRooter
{
public
:
AutoWrapperRooter
(
JSContext
*
cx
const
WrapperValue
&
v
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
AutoGCRooter
(
cx
JS
:
:
AutoGCRooter
:
:
Tag
:
:
Wrapper
)
value
(
v
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
operator
JSObject
*
(
)
const
{
return
value
.
get
(
)
.
toObjectOrNull
(
)
;
}
friend
void
JS
:
:
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
private
:
WrapperValue
value
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoSuppressAllocationMetadataBuilder
{
JS
:
:
Zone
*
zone
;
bool
saved
;
public
:
explicit
AutoSuppressAllocationMetadataBuilder
(
JSContext
*
cx
)
:
AutoSuppressAllocationMetadataBuilder
(
cx
-
>
realm
(
)
-
>
zone
(
)
)
{
}
explicit
AutoSuppressAllocationMetadataBuilder
(
JS
:
:
Zone
*
zone
)
:
zone
(
zone
)
saved
(
zone
-
>
suppressAllocationMetadataBuilder
)
{
zone
-
>
suppressAllocationMetadataBuilder
=
true
;
}
~
AutoSuppressAllocationMetadataBuilder
(
)
{
zone
-
>
suppressAllocationMetadataBuilder
=
saved
;
}
}
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
CrossCompartmentKey
>
:
public
StructGCPolicy
<
js
:
:
CrossCompartmentKey
>
{
static
bool
isTenured
(
const
js
:
:
CrossCompartmentKey
&
key
)
{
return
key
.
isTenured
(
)
;
}
}
;
}
#
endif
