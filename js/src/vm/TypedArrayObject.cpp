#
include
"
vm
/
TypedArrayObject
-
inl
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
string
.
h
>
#
ifndef
XP_WIN
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
"
jsapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
DataViewObject
.
h
"
#
include
"
builtin
/
TypedObjectConstants
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
Windows
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PIC
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSAtom
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
CanonicalizeNaN
;
using
JS
:
:
ToInt32
;
using
JS
:
:
ToUint32
;
using
mozilla
:
:
CheckedUint32
;
using
mozilla
:
:
IsAsciiDigit
;
bool
TypedArrayObject
:
:
is
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
TypedArrayObject
>
(
)
;
}
bool
TypedArrayObject
:
:
ensureHasBuffer
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
tarray
)
{
if
(
tarray
-
>
hasBuffer
(
)
)
{
return
true
;
}
AutoRealm
ar
(
cx
tarray
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
ArrayBufferObject
:
:
create
(
cx
tarray
-
>
byteLength
(
)
)
)
;
if
(
!
buffer
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
buffer
-
>
addView
(
cx
tarray
)
)
;
memcpy
(
buffer
-
>
dataPointer
(
)
tarray
-
>
dataPointerUnshared
(
)
tarray
-
>
byteLength
(
)
)
;
Nursery
&
nursery
=
cx
-
>
nursery
(
)
;
if
(
tarray
-
>
isTenured
(
)
&
&
!
tarray
-
>
hasInlineElements
(
)
&
&
!
nursery
.
isInside
(
tarray
-
>
elements
(
)
)
)
{
js_free
(
tarray
-
>
elements
(
)
)
;
}
tarray
-
>
setPrivate
(
buffer
-
>
dataPointer
(
)
)
;
tarray
-
>
setFixedSlot
(
TypedArrayObject
:
:
BUFFER_SLOT
ObjectValue
(
*
buffer
)
)
;
MarkObjectStateChange
(
cx
tarray
)
;
return
true
;
}
#
ifdef
DEBUG
void
TypedArrayObject
:
:
assertZeroLengthArrayData
(
)
const
{
if
(
length
(
)
=
=
0
&
&
!
hasBuffer
(
)
)
{
uint8_t
*
end
=
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
MOZ_ASSERT
(
end
[
0
]
=
=
ZeroLengthArrayData
)
;
}
}
#
endif
void
TypedArrayObject
:
:
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
TypedArrayObject
*
curObj
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
if
(
!
curObj
-
>
elementsRaw
(
)
)
{
return
;
}
curObj
-
>
assertZeroLengthArrayData
(
)
;
if
(
curObj
-
>
hasBuffer
(
)
)
{
return
;
}
if
(
!
curObj
-
>
hasInlineElements
(
)
)
{
js_free
(
curObj
-
>
elements
(
)
)
;
}
}
size_t
TypedArrayObject
:
:
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
{
TypedArrayObject
*
newObj
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
const
TypedArrayObject
*
oldObj
=
&
old
-
>
as
<
TypedArrayObject
>
(
)
;
MOZ_ASSERT
(
newObj
-
>
elementsRaw
(
)
=
=
oldObj
-
>
elementsRaw
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
)
;
if
(
oldObj
-
>
hasBuffer
(
)
)
{
return
0
;
}
if
(
!
IsInsideNursery
(
old
)
)
{
if
(
oldObj
-
>
hasInlineElements
(
)
)
{
newObj
-
>
setInlineElements
(
)
;
}
return
0
;
}
void
*
buf
=
oldObj
-
>
elements
(
)
;
if
(
!
buf
)
{
return
0
;
}
Nursery
&
nursery
=
obj
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
if
(
!
nursery
.
isInside
(
buf
)
)
{
nursery
.
removeMallocedBuffer
(
buf
)
;
return
0
;
}
size_t
nbytes
=
oldObj
-
>
byteLength
(
)
;
constexpr
size_t
headerSize
=
dataOffset
(
)
+
sizeof
(
HeapSlot
)
;
gc
:
:
AllocKind
newAllocKind
=
obj
-
>
asTenured
(
)
.
getAllocKind
(
)
;
MOZ_ASSERT_IF
(
nbytes
=
=
0
headerSize
+
sizeof
(
uint8_t
)
<
=
GetGCKindBytes
(
newAllocKind
)
)
;
if
(
headerSize
+
nbytes
<
=
GetGCKindBytes
(
newAllocKind
)
)
{
MOZ_ASSERT
(
oldObj
-
>
hasInlineElements
(
)
)
;
#
ifdef
DEBUG
if
(
nbytes
=
=
0
)
{
uint8_t
*
output
=
newObj
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
output
[
0
]
=
ZeroLengthArrayData
;
}
#
endif
newObj
-
>
setInlineElements
(
)
;
}
else
{
MOZ_ASSERT
(
!
oldObj
-
>
hasInlineElements
(
)
)
;
MOZ_ASSERT
(
(
CheckedUint32
(
nbytes
)
+
sizeof
(
Value
)
)
.
isValid
(
)
"
JS_ROUNDUP
must
not
overflow
"
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
nbytes
=
JS_ROUNDUP
(
nbytes
sizeof
(
Value
)
)
;
void
*
data
=
newObj
-
>
zone
(
)
-
>
pod_malloc
<
uint8_t
>
(
nbytes
js
:
:
ArrayBufferContentsArena
)
;
if
(
!
data
)
{
oomUnsafe
.
crash
(
"
Failed
to
allocate
typed
array
elements
while
tenuring
.
"
)
;
}
MOZ_ASSERT
(
!
nursery
.
isInside
(
data
)
)
;
newObj
-
>
initPrivate
(
data
)
;
}
mozilla
:
:
PodCopy
(
newObj
-
>
elements
(
)
oldObj
-
>
elements
(
)
nbytes
)
;
nursery
.
setForwardingPointerWhileTenuring
(
oldObj
-
>
elements
(
)
newObj
-
>
elements
(
)
nbytes
>
=
sizeof
(
uintptr_t
)
)
;
return
newObj
-
>
hasInlineElements
(
)
?
0
:
nbytes
;
}
bool
TypedArrayObject
:
:
hasInlineElements
(
)
const
{
return
elements
(
)
=
=
this
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
&
&
byteLength
(
)
<
=
TypedArrayObject
:
:
INLINE_BUFFER_LIMIT
;
}
void
TypedArrayObject
:
:
setInlineElements
(
)
{
char
*
dataSlot
=
reinterpret_cast
<
char
*
>
(
this
)
+
this
-
>
dataOffset
(
)
;
*
reinterpret_cast
<
void
*
*
>
(
dataSlot
)
=
this
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
}
uint32_t
JS_FASTCALL
js
:
:
ClampDoubleToUint8
(
const
double
x
)
{
if
(
!
(
x
>
=
0
)
)
{
return
0
;
}
if
(
x
>
255
)
{
return
255
;
}
double
toTruncate
=
x
+
0
.
5
;
uint8_t
y
=
uint8_t
(
toTruncate
)
;
if
(
y
=
=
toTruncate
)
{
return
y
&
~
1
;
}
return
y
;
}
namespace
{
enum
class
SpeciesConstructorOverride
{
None
ArrayBuffer
}
;
enum
class
CreateSingleton
{
No
Yes
}
;
template
<
typename
NativeType
>
class
TypedArrayObjectTemplate
:
public
TypedArrayObject
{
friend
class
TypedArrayObject
;
public
:
static
constexpr
Scalar
:
:
Type
ArrayTypeID
(
)
{
return
TypeIDOfType
<
NativeType
>
:
:
id
;
}
static
constexpr
JSProtoKey
protoKey
(
)
{
return
TypeIDOfType
<
NativeType
>
:
:
protoKey
;
}
static
constexpr
bool
ArrayTypeIsUnsigned
(
)
{
return
TypeIsUnsigned
<
NativeType
>
(
)
;
}
static
constexpr
bool
ArrayTypeIsFloatingPoint
(
)
{
return
TypeIsFloatingPoint
<
NativeType
>
(
)
;
}
static
constexpr
size_t
BYTES_PER_ELEMENT
=
sizeof
(
NativeType
)
;
static
JSObject
*
createPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
typedArrayProto
(
cx
GlobalObject
:
:
getOrCreateTypedArrayPrototype
(
cx
global
)
)
;
if
(
!
typedArrayProto
)
{
return
nullptr
;
}
const
Class
*
clasp
=
TypedArrayObject
:
:
protoClassForType
(
ArrayTypeID
(
)
)
;
return
GlobalObject
:
:
createBlankPrototypeInheriting
(
cx
clasp
typedArrayProto
)
;
}
static
JSObject
*
createConstructor
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedFunction
ctorProto
(
cx
GlobalObject
:
:
getOrCreateTypedArrayConstructor
(
cx
global
)
)
;
if
(
!
ctorProto
)
{
return
nullptr
;
}
JSFunction
*
fun
=
NewFunctionWithProto
(
cx
class_constructor
3
JSFunction
:
:
NATIVE_CTOR
nullptr
ClassName
(
key
cx
)
ctorProto
gc
:
:
AllocKind
:
:
FUNCTION
SingletonObject
)
;
if
(
fun
)
{
fun
-
>
setJitInfo
(
&
jit
:
:
JitInfo_TypedArrayConstructor
)
;
}
return
fun
;
}
static
inline
const
Class
*
instanceClass
(
)
{
return
TypedArrayObject
:
:
classForType
(
ArrayTypeID
(
)
)
;
}
static
bool
is
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
hasClass
(
instanceClass
(
)
)
;
}
static
void
setIndexValue
(
TypedArrayObject
&
tarray
uint32_t
index
double
d
)
{
if
(
ArrayTypeIsFloatingPoint
(
)
)
{
setIndex
(
tarray
index
NativeType
(
d
)
)
;
}
else
if
(
ArrayTypeIsUnsigned
(
)
)
{
MOZ_ASSERT
(
sizeof
(
NativeType
)
<
=
4
)
;
uint32_t
n
=
ToUint32
(
d
)
;
setIndex
(
tarray
index
NativeType
(
n
)
)
;
}
else
if
(
ArrayTypeID
(
)
=
=
Scalar
:
:
Uint8Clamped
)
{
setIndex
(
tarray
index
NativeType
(
d
)
)
;
}
else
{
MOZ_ASSERT
(
sizeof
(
NativeType
)
<
=
4
)
;
int32_t
n
=
ToInt32
(
d
)
;
setIndex
(
tarray
index
NativeType
(
n
)
)
;
}
}
static
TypedArrayObject
*
newBuiltinClassInstance
(
JSContext
*
cx
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
JSObject
*
obj
=
NewBuiltinClassInstance
(
cx
instanceClass
(
)
allocKind
newKind
)
;
return
obj
?
&
obj
-
>
as
<
TypedArrayObject
>
(
)
:
nullptr
;
}
static
TypedArrayObject
*
makeProtoInstance
(
JSContext
*
cx
HandleObject
proto
gc
:
:
AllocKind
allocKind
)
{
MOZ_ASSERT
(
proto
)
;
JSObject
*
obj
=
NewObjectWithGivenProto
(
cx
instanceClass
(
)
proto
allocKind
)
;
return
obj
?
&
obj
-
>
as
<
TypedArrayObject
>
(
)
:
nullptr
;
}
static
TypedArrayObject
*
makeTypedInstance
(
JSContext
*
cx
CreateSingleton
createSingleton
HandleObjectGroup
group
gc
:
:
AllocKind
allocKind
)
{
if
(
createSingleton
=
=
CreateSingleton
:
:
Yes
)
{
MOZ_ASSERT
(
!
group
)
;
return
newBuiltinClassInstance
(
cx
allocKind
SingletonObject
)
;
}
if
(
group
)
{
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
instanceClass
(
)
)
;
NewObjectKind
newKind
=
GenericObject
;
{
AutoSweepObjectGroup
sweep
(
group
)
;
if
(
group
-
>
shouldPreTenure
(
sweep
)
)
{
newKind
=
TenuredObject
;
}
}
return
NewObjectWithGroup
<
TypedArrayObject
>
(
cx
group
allocKind
newKind
)
;
}
jsbytecode
*
pc
;
RootedScript
script
(
cx
cx
-
>
currentScript
(
&
pc
)
)
;
Rooted
<
TypedArrayObject
*
>
obj
(
cx
newBuiltinClassInstance
(
cx
allocKind
GenericObject
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
if
(
script
&
&
!
ObjectGroup
:
:
setAllocationSiteObjectGroup
(
cx
script
pc
obj
false
)
)
{
return
nullptr
;
}
return
obj
;
}
static
TypedArrayObject
*
makeInstance
(
JSContext
*
cx
Handle
<
ArrayBufferObjectMaybeShared
*
>
buffer
CreateSingleton
createSingleton
uint32_t
byteOffset
uint32_t
len
HandleObject
proto
HandleObjectGroup
group
=
nullptr
)
{
MOZ_ASSERT
(
len
<
INT32_MAX
/
BYTES_PER_ELEMENT
)
;
gc
:
:
AllocKind
allocKind
=
buffer
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
len
*
BYTES_PER_ELEMENT
)
;
RootedObject
checkProto
(
cx
)
;
if
(
proto
)
{
checkProto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
protoKey
(
)
)
;
if
(
!
checkProto
)
{
return
nullptr
;
}
}
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
TypedArrayObject
*
>
obj
(
cx
)
;
if
(
proto
&
&
proto
!
=
checkProto
)
{
MOZ_ASSERT
(
!
group
)
;
obj
=
makeProtoInstance
(
cx
proto
allocKind
)
;
}
else
{
obj
=
makeTypedInstance
(
cx
createSingleton
group
allocKind
)
;
}
if
(
!
obj
|
|
!
obj
-
>
init
(
cx
buffer
byteOffset
len
BYTES_PER_ELEMENT
)
)
{
return
nullptr
;
}
return
obj
;
}
static
TypedArrayObject
*
makeTemplateObject
(
JSContext
*
cx
int32_t
len
)
{
MOZ_ASSERT
(
len
>
=
0
)
;
size_t
nbytes
;
MOZ_ALWAYS_TRUE
(
CalculateAllocSize
<
NativeType
>
(
len
&
nbytes
)
)
;
MOZ_ASSERT
(
nbytes
<
TypedArrayObject
:
:
SINGLETON_BYTE_LENGTH
)
;
bool
fitsInline
=
nbytes
<
=
INLINE_BUFFER_LIMIT
;
gc
:
:
AllocKind
allocKind
=
!
fitsInline
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
nbytes
)
;
MOZ_ASSERT
(
allocKind
>
=
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
jsbytecode
*
pc
;
RootedScript
script
(
cx
cx
-
>
currentScript
(
&
pc
)
)
;
Rooted
<
TypedArrayObject
*
>
tarray
(
cx
newBuiltinClassInstance
(
cx
allocKind
TenuredObject
)
)
;
if
(
!
tarray
)
{
return
nullptr
;
}
initTypedArraySlots
(
tarray
len
)
;
tarray
-
>
initPrivate
(
nullptr
)
;
if
(
script
&
&
!
ObjectGroup
:
:
setAllocationSiteObjectGroup
(
cx
script
pc
tarray
false
)
)
{
return
nullptr
;
}
return
tarray
;
}
static
void
initTypedArraySlots
(
TypedArrayObject
*
tarray
int32_t
len
)
{
MOZ_ASSERT
(
len
>
=
0
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
BUFFER_SLOT
NullValue
(
)
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
LENGTH_SLOT
Int32Value
(
len
)
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
BYTEOFFSET_SLOT
Int32Value
(
0
)
)
;
MOZ_ASSERT
(
tarray
-
>
numFixedSlots
(
)
=
=
TypedArrayObject
:
:
DATA_SLOT
)
;
#
ifdef
DEBUG
if
(
len
=
=
0
)
{
uint8_t
*
output
=
tarray
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
output
[
0
]
=
TypedArrayObject
:
:
ZeroLengthArrayData
;
}
#
endif
}
static
void
initTypedArrayData
(
TypedArrayObject
*
tarray
int32_t
len
void
*
buf
gc
:
:
AllocKind
allocKind
)
{
if
(
buf
)
{
tarray
-
>
initPrivate
(
buf
)
;
}
else
{
size_t
nbytes
=
len
*
BYTES_PER_ELEMENT
;
#
ifdef
DEBUG
constexpr
size_t
dataOffset
=
TypedArrayObject
:
:
dataOffset
(
)
;
constexpr
size_t
offset
=
dataOffset
+
sizeof
(
HeapSlot
)
;
MOZ_ASSERT
(
offset
+
nbytes
<
=
GetGCKindBytes
(
allocKind
)
)
;
#
endif
void
*
data
=
tarray
-
>
fixedData
(
FIXED_DATA_START
)
;
tarray
-
>
initPrivate
(
data
)
;
memset
(
data
0
nbytes
)
;
}
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
int32_t
len
)
{
if
(
len
<
0
|
|
uint32_t
(
len
)
>
=
INT32_MAX
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
nullptr
;
}
size_t
nbytes
=
len
*
BYTES_PER_ELEMENT
;
bool
fitsInline
=
nbytes
<
=
INLINE_BUFFER_LIMIT
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
gc
:
:
AllocKind
allocKind
=
!
fitsInline
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
nbytes
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
instanceClass
(
)
)
;
TypedArrayObject
*
obj
=
NewObjectWithGroup
<
TypedArrayObject
>
(
cx
group
allocKind
)
;
if
(
!
obj
)
{
return
nullptr
;
}
initTypedArraySlots
(
obj
len
)
;
void
*
buf
=
nullptr
;
if
(
!
fitsInline
)
{
MOZ_ASSERT
(
len
>
0
)
;
MOZ_ASSERT
(
(
CheckedUint32
(
nbytes
)
+
sizeof
(
Value
)
)
.
isValid
(
)
"
JS_ROUNDUP
must
not
overflow
"
)
;
nbytes
=
JS_ROUNDUP
(
nbytes
sizeof
(
Value
)
)
;
buf
=
cx
-
>
nursery
(
)
.
allocateZeroedBuffer
(
obj
nbytes
js
:
:
ArrayBufferContentsArena
)
;
if
(
!
buf
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
initTypedArrayData
(
obj
len
buf
allocKind
)
;
return
obj
;
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
HandleObject
array
)
{
MOZ_ASSERT
(
!
IsWrapper
(
array
)
)
;
MOZ_ASSERT
(
!
array
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
return
fromArray
(
cx
array
nullptr
group
)
;
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
HandleObject
arrayBuffer
HandleValue
byteOffsetValue
HandleValue
lengthValue
)
{
MOZ_ASSERT
(
!
IsWrapper
(
arrayBuffer
)
)
;
MOZ_ASSERT
(
arrayBuffer
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
uint64_t
byteOffset
length
;
if
(
!
byteOffsetAndLength
(
cx
byteOffsetValue
lengthValue
&
byteOffset
&
length
)
)
{
return
nullptr
;
}
return
fromBufferSameCompartment
(
cx
arrayBuffer
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
byteOffset
length
nullptr
group
)
;
}
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
typed
array
"
)
)
{
return
false
;
}
JSObject
*
obj
=
create
(
cx
args
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
private
:
static
JSObject
*
create
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
isConstructing
(
)
)
;
if
(
args
.
length
(
)
=
=
0
|
|
!
args
[
0
]
.
isObject
(
)
)
{
uint64_t
len
;
if
(
!
ToIndex
(
cx
args
.
get
(
0
)
JSMSG_BAD_ARRAY_LENGTH
&
len
)
)
{
return
nullptr
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
protoKey
(
)
&
proto
)
)
{
return
nullptr
;
}
return
fromLength
(
cx
len
proto
)
;
}
RootedObject
dataObj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
protoKey
(
)
&
proto
)
)
{
return
nullptr
;
}
if
(
!
UncheckedUnwrap
(
dataObj
)
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
return
fromArray
(
cx
dataObj
proto
)
;
}
uint64_t
byteOffset
length
;
if
(
!
byteOffsetAndLength
(
cx
args
.
get
(
1
)
args
.
get
(
2
)
&
byteOffset
&
length
)
)
{
return
nullptr
;
}
if
(
dataObj
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
HandleArrayBufferObjectMaybeShared
buffer
=
dataObj
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
return
fromBufferSameCompartment
(
cx
buffer
byteOffset
length
proto
)
;
}
return
fromBufferWrapped
(
cx
dataObj
byteOffset
length
proto
)
;
}
static
bool
byteOffsetAndLength
(
JSContext
*
cx
HandleValue
byteOffsetValue
HandleValue
lengthValue
uint64_t
*
byteOffset
uint64_t
*
length
)
{
*
byteOffset
=
0
;
if
(
!
byteOffsetValue
.
isUndefined
(
)
)
{
if
(
!
ToIndex
(
cx
byteOffsetValue
byteOffset
)
)
{
return
false
;
}
if
(
*
byteOffset
%
BYTES_PER_ELEMENT
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
}
*
length
=
UINT64_MAX
;
if
(
!
lengthValue
.
isUndefined
(
)
)
{
if
(
!
ToIndex
(
cx
lengthValue
length
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
computeAndCheckLength
(
JSContext
*
cx
HandleArrayBufferObjectMaybeShared
bufferMaybeUnwrapped
uint64_t
byteOffset
uint64_t
lengthIndex
uint32_t
*
length
)
{
MOZ_ASSERT
(
byteOffset
%
BYTES_PER_ELEMENT
=
=
0
)
;
MOZ_ASSERT
(
byteOffset
<
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
;
MOZ_ASSERT_IF
(
lengthIndex
!
=
UINT64_MAX
lengthIndex
<
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
;
if
(
bufferMaybeUnwrapped
-
>
isDetached
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
uint32_t
bufferByteLength
=
bufferMaybeUnwrapped
-
>
byteLength
(
)
;
uint32_t
len
;
if
(
lengthIndex
=
=
UINT64_MAX
)
{
if
(
bufferByteLength
%
BYTES_PER_ELEMENT
!
=
0
|
|
byteOffset
>
bufferByteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
uint32_t
newByteLength
=
bufferByteLength
-
uint32_t
(
byteOffset
)
;
len
=
newByteLength
/
BYTES_PER_ELEMENT
;
}
else
{
uint64_t
newByteLength
=
lengthIndex
*
BYTES_PER_ELEMENT
;
if
(
byteOffset
+
newByteLength
>
bufferByteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
len
=
uint32_t
(
lengthIndex
)
;
}
if
(
len
>
=
INT32_MAX
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
MOZ_ASSERT
(
byteOffset
<
=
UINT32_MAX
)
;
*
length
=
len
;
return
true
;
}
static
TypedArrayObject
*
fromBufferSameCompartment
(
JSContext
*
cx
HandleArrayBufferObjectMaybeShared
buffer
uint64_t
byteOffset
uint64_t
lengthIndex
HandleObject
proto
HandleObjectGroup
group
=
nullptr
)
{
uint32_t
length
;
if
(
!
computeAndCheckLength
(
cx
buffer
byteOffset
lengthIndex
&
length
)
)
{
return
nullptr
;
}
CreateSingleton
createSingleton
=
CreateSingleton
:
:
No
;
if
(
!
group
&
&
length
*
BYTES_PER_ELEMENT
>
=
TypedArrayObject
:
:
SINGLETON_BYTE_LENGTH
)
{
createSingleton
=
CreateSingleton
:
:
Yes
;
}
return
makeInstance
(
cx
buffer
createSingleton
uint32_t
(
byteOffset
)
length
proto
group
)
;
}
static
JSObject
*
fromBufferWrapped
(
JSContext
*
cx
HandleObject
bufobj
uint64_t
byteOffset
uint64_t
lengthIndex
HandleObject
proto
)
{
JSObject
*
unwrapped
=
CheckedUnwrap
(
bufobj
)
;
if
(
!
unwrapped
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
if
(
!
unwrapped
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_BAD_ARGS
)
;
return
nullptr
;
}
RootedArrayBufferObjectMaybeShared
unwrappedBuffer
(
cx
)
;
unwrappedBuffer
=
&
unwrapped
-
>
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
uint32_t
length
;
if
(
!
computeAndCheckLength
(
cx
unwrappedBuffer
byteOffset
lengthIndex
&
length
)
)
{
return
nullptr
;
}
RootedObject
protoRoot
(
cx
proto
)
;
if
(
!
protoRoot
)
{
protoRoot
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
protoKey
(
)
)
;
if
(
!
protoRoot
)
{
return
nullptr
;
}
}
RootedObject
typedArray
(
cx
)
;
{
JSAutoRealm
ar
(
cx
unwrappedBuffer
)
;
RootedObject
wrappedProto
(
cx
protoRoot
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedProto
)
)
{
return
nullptr
;
}
typedArray
=
makeInstance
(
cx
unwrappedBuffer
CreateSingleton
:
:
No
uint32_t
(
byteOffset
)
length
wrappedProto
)
;
if
(
!
typedArray
)
{
return
nullptr
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
typedArray
)
)
{
return
nullptr
;
}
return
typedArray
;
}
public
:
static
JSObject
*
fromBuffer
(
JSContext
*
cx
HandleObject
bufobj
uint32_t
byteOffset
int32_t
lengthInt
)
{
if
(
byteOffset
%
BYTES_PER_ELEMENT
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
nullptr
;
}
uint64_t
lengthIndex
=
lengthInt
>
=
0
?
uint64_t
(
lengthInt
)
:
UINT64_MAX
;
if
(
bufobj
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
HandleArrayBufferObjectMaybeShared
buffer
=
bufobj
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
return
fromBufferSameCompartment
(
cx
buffer
byteOffset
lengthIndex
nullptr
)
;
}
return
fromBufferWrapped
(
cx
bufobj
byteOffset
lengthIndex
nullptr
)
;
}
static
bool
maybeCreateArrayBuffer
(
JSContext
*
cx
uint32_t
count
HandleObject
nonDefaultProto
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
{
if
(
count
>
=
INT32_MAX
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
false
;
}
uint32_t
byteLength
=
count
*
BYTES_PER_ELEMENT
;
MOZ_ASSERT
(
byteLength
<
INT32_MAX
)
;
static_assert
(
INLINE_BUFFER_LIMIT
%
BYTES_PER_ELEMENT
=
=
0
"
ArrayBuffer
inline
storage
shouldn
'
t
waste
any
space
"
)
;
if
(
!
nonDefaultProto
&
&
byteLength
<
=
INLINE_BUFFER_LIMIT
)
{
return
true
;
}
ArrayBufferObject
*
buf
=
ArrayBufferObject
:
:
create
(
cx
byteLength
nonDefaultProto
)
;
if
(
!
buf
)
{
return
false
;
}
buffer
.
set
(
buf
)
;
return
true
;
}
static
JSObject
*
fromLength
(
JSContext
*
cx
uint64_t
nelements
HandleObject
proto
=
nullptr
)
{
if
(
nelements
>
UINT32_MAX
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
nullptr
;
}
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
uint32_t
(
nelements
)
nullptr
&
buffer
)
)
{
return
nullptr
;
}
return
makeInstance
(
cx
buffer
CreateSingleton
:
:
No
0
uint32_t
(
nelements
)
proto
)
;
}
static
bool
AllocateArrayBuffer
(
JSContext
*
cx
HandleObject
ctor
uint32_t
count
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
;
static
TypedArrayObject
*
fromArray
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
=
nullptr
HandleObjectGroup
group
=
nullptr
)
;
static
TypedArrayObject
*
fromTypedArray
(
JSContext
*
cx
HandleObject
other
bool
isWrapped
HandleObject
proto
HandleObjectGroup
group
)
;
static
TypedArrayObject
*
fromObject
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
;
static
const
NativeType
getIndex
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
tarray
-
>
length
(
)
)
;
return
jit
:
:
AtomicOperations
:
:
loadSafeWhenRacy
(
tarray
-
>
dataPointerEither
(
)
.
cast
<
NativeType
*
>
(
)
+
index
)
;
}
static
void
setIndex
(
TypedArrayObject
&
tarray
uint32_t
index
NativeType
val
)
{
MOZ_ASSERT
(
index
<
tarray
.
length
(
)
)
;
jit
:
:
AtomicOperations
:
:
storeSafeWhenRacy
(
tarray
.
dataPointerEither
(
)
.
cast
<
NativeType
*
>
(
)
+
index
val
)
;
}
static
Value
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
;
}
;
#
define
CREATE_TYPE_FOR_TYPED_ARRAY
(
T
N
)
\
typedef
TypedArrayObjectTemplate
<
T
>
N
#
#
Array
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPE_FOR_TYPED_ARRAY
)
#
undef
CREATE_TYPE_FOR_TYPED_ARRAY
}
TypedArrayObject
*
js
:
:
TypedArrayCreateWithTemplate
(
JSContext
*
cx
HandleObject
templateObj
int32_t
len
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
cx
tobj
\
len
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
TypedArrayObject
*
js
:
:
TypedArrayCreateWithTemplate
(
JSContext
*
cx
HandleObject
templateObj
HandleObject
array
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
cx
tobj
\
array
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
TypedArrayObject
*
js
:
:
TypedArrayCreateWithTemplate
(
JSContext
*
cx
HandleObject
templateObj
HandleObject
arrayBuffer
HandleValue
byteOffset
HandleValue
length
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
\
cx
tobj
arrayBuffer
byteOffset
length
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
template
<
typename
T
>
bool
TypedArrayObjectTemplate
<
T
>
:
:
AllocateArrayBuffer
(
JSContext
*
cx
HandleObject
ctor
uint32_t
count
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
{
RootedObject
proto
(
cx
)
;
JSFunction
*
arrayBufferCtor
=
GlobalObject
:
:
getOrCreateArrayBufferConstructor
(
cx
cx
-
>
global
(
)
)
;
if
(
!
arrayBufferCtor
)
{
return
false
;
}
if
(
ctor
!
=
arrayBufferCtor
)
{
if
(
!
GetPrototypeFromConstructor
(
cx
ctor
JSProto_ArrayBuffer
&
proto
)
)
{
return
false
;
}
}
if
(
!
maybeCreateArrayBuffer
(
cx
count
proto
buffer
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsArrayBufferSpecies
(
JSContext
*
cx
JSFunction
*
species
)
{
return
IsSelfHostedFunctionWithName
(
species
cx
-
>
names
(
)
.
ArrayBufferSpecies
)
;
}
static
JSObject
*
GetBufferSpeciesConstructor
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
typedArray
bool
isWrapped
SpeciesConstructorOverride
override
)
{
RootedObject
defaultCtor
(
cx
GlobalObject
:
:
getOrCreateArrayBufferConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
defaultCtor
)
{
return
nullptr
;
}
if
(
override
=
=
SpeciesConstructorOverride
:
:
ArrayBuffer
)
{
return
defaultCtor
;
}
RootedObject
obj
(
cx
typedArray
-
>
bufferEither
(
)
)
;
if
(
!
obj
)
{
MOZ_ASSERT
(
!
isWrapped
)
;
JSObject
*
proto
=
GlobalObject
:
:
getOrCreateArrayBufferPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Value
ctor
;
bool
found
;
if
(
GetOwnPropertyPure
(
cx
proto
NameToId
(
cx
-
>
names
(
)
.
constructor
)
&
ctor
&
found
)
&
&
ctor
.
isObject
(
)
&
&
&
ctor
.
toObject
(
)
=
=
defaultCtor
)
{
jsid
speciesId
=
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
species
)
;
JSFunction
*
getter
;
if
(
GetOwnGetterPure
(
cx
defaultCtor
speciesId
&
getter
)
&
&
getter
&
&
IsArrayBufferSpecies
(
cx
getter
)
)
{
return
defaultCtor
;
}
}
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
typedArray
)
)
{
return
nullptr
;
}
obj
.
set
(
typedArray
-
>
bufferEither
(
)
)
;
}
else
{
if
(
isWrapped
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
obj
)
)
{
return
nullptr
;
}
}
return
SpeciesConstructor
(
cx
obj
defaultCtor
IsArrayBufferSpecies
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromArray
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
{
if
(
other
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
fromTypedArray
(
cx
other
false
proto
group
)
;
}
if
(
other
-
>
is
<
WrapperObject
>
(
)
&
&
UncheckedUnwrap
(
other
)
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
fromTypedArray
(
cx
other
true
proto
group
)
;
}
return
fromObject
(
cx
other
proto
group
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromTypedArray
(
JSContext
*
cx
HandleObject
other
bool
isWrapped
HandleObject
proto
HandleObjectGroup
group
)
{
MOZ_ASSERT_IF
(
!
isWrapped
other
-
>
is
<
TypedArrayObject
>
(
)
)
;
MOZ_ASSERT_IF
(
isWrapped
other
-
>
is
<
WrapperObject
>
(
)
&
&
UncheckedUnwrap
(
other
)
-
>
is
<
TypedArrayObject
>
(
)
)
;
Rooted
<
TypedArrayObject
*
>
srcArray
(
cx
)
;
if
(
!
isWrapped
)
{
srcArray
=
&
other
-
>
as
<
TypedArrayObject
>
(
)
;
}
else
{
srcArray
=
other
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
srcArray
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
if
(
cx
-
>
realm
(
)
!
=
srcArray
-
>
realm
(
)
|
|
isWrapped
)
{
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
srcArray
)
)
{
return
nullptr
;
}
}
if
(
srcArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
uint32_t
elementLength
=
srcArray
-
>
length
(
)
;
bool
isShared
=
srcArray
-
>
isSharedMemory
(
)
;
SpeciesConstructorOverride
override
=
isShared
?
SpeciesConstructorOverride
:
:
ArrayBuffer
:
SpeciesConstructorOverride
:
:
None
;
RootedObject
bufferCtor
(
cx
GetBufferSpeciesConstructor
(
cx
srcArray
isWrapped
override
)
)
;
if
(
!
bufferCtor
)
{
return
nullptr
;
}
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
AllocateArrayBuffer
(
cx
bufferCtor
elementLength
&
buffer
)
)
{
return
nullptr
;
}
if
(
srcArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
CreateSingleton
:
:
No
0
elementLength
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
isShared
)
{
if
(
!
ElementSpecific
<
T
SharedOps
>
:
:
setFromTypedArray
(
obj
srcArray
0
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromTypedArray
(
obj
srcArray
0
)
)
{
return
nullptr
;
}
}
return
obj
;
}
static
MOZ_ALWAYS_INLINE
bool
IsOptimizableInit
(
JSContext
*
cx
HandleObject
iterable
bool
*
optimized
)
{
MOZ_ASSERT
(
!
*
optimized
)
;
if
(
!
IsPackedArray
(
iterable
)
)
{
return
true
;
}
ForOfPIC
:
:
Chain
*
stubChain
=
ForOfPIC
:
:
getOrCreate
(
cx
)
;
if
(
!
stubChain
)
{
return
false
;
}
return
stubChain
-
>
tryOptimizeArray
(
cx
iterable
.
as
<
ArrayObject
>
(
)
optimized
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromObject
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
{
bool
optimized
=
false
;
if
(
!
IsOptimizableInit
(
cx
other
&
optimized
)
)
{
return
nullptr
;
}
if
(
optimized
)
{
HandleArrayObject
array
=
other
.
as
<
ArrayObject
>
(
)
;
uint32_t
len
=
array
-
>
getDenseInitializedLength
(
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
len
nullptr
&
buffer
)
)
{
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
CreateSingleton
:
:
No
0
len
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
initFromIterablePackedArray
(
cx
obj
array
)
)
{
return
nullptr
;
}
return
obj
;
}
RootedValue
callee
(
cx
)
;
RootedId
iteratorId
(
cx
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
)
;
if
(
!
GetProperty
(
cx
other
other
iteratorId
&
callee
)
)
{
return
nullptr
;
}
RootedObject
arrayLike
(
cx
)
;
if
(
!
callee
.
isNullOrUndefined
(
)
)
{
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
isCallable
(
)
)
{
RootedValue
otherVal
(
cx
ObjectValue
(
*
other
)
)
;
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
otherVal
nullptr
)
;
if
(
!
bytes
)
{
return
nullptr
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
bytes
.
get
(
)
)
;
return
nullptr
;
}
FixedInvokeArgs
<
2
>
args2
(
cx
)
;
args2
[
0
]
.
setObject
(
*
other
)
;
args2
[
1
]
.
set
(
callee
)
;
RootedValue
rval
(
cx
)
;
if
(
!
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
IterableToList
UndefinedHandleValue
args2
&
rval
)
)
{
return
nullptr
;
}
arrayLike
=
&
rval
.
toObject
(
)
;
}
else
{
arrayLike
=
other
;
}
uint32_t
len
;
if
(
!
GetLengthProperty
(
cx
arrayLike
&
len
)
)
{
return
nullptr
;
}
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
len
nullptr
&
buffer
)
)
{
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
CreateSingleton
:
:
No
0
len
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromNonTypedArray
(
cx
obj
arrayLike
len
)
)
{
return
nullptr
;
}
return
obj
;
}
bool
TypedArrayConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT
args
.
isConstructing
(
)
?
"
construct
"
:
"
call
"
)
;
return
false
;
}
template
<
typename
T
>
static
bool
GetTemplateObjectForNative
(
JSContext
*
cx
const
CallArgs
&
args
MutableHandleObject
res
)
{
if
(
args
.
length
(
)
=
=
0
)
{
return
true
;
}
HandleValue
arg
=
args
[
0
]
;
if
(
arg
.
isInt32
(
)
)
{
uint32_t
len
=
0
;
if
(
arg
.
toInt32
(
)
>
=
0
)
{
len
=
arg
.
toInt32
(
)
;
}
size_t
nbytes
;
if
(
!
js
:
:
CalculateAllocSize
<
T
>
(
len
&
nbytes
)
)
{
return
true
;
}
if
(
nbytes
>
=
TypedArrayObject
:
:
SINGLETON_BYTE_LENGTH
)
{
return
true
;
}
res
.
set
(
TypedArrayObjectTemplate
<
T
>
:
:
makeTemplateObject
(
cx
len
)
)
;
return
!
!
res
;
}
if
(
arg
.
isObject
(
)
&
&
!
IsWrapper
(
&
arg
.
toObject
(
)
)
)
{
uint32_t
len
=
0
;
res
.
set
(
TypedArrayObjectTemplate
<
T
>
:
:
makeTemplateObject
(
cx
len
)
)
;
return
!
!
res
;
}
return
true
;
}
bool
TypedArrayObject
:
:
GetTemplateObjectForNative
(
JSContext
*
cx
Native
native
const
CallArgs
&
args
MutableHandleObject
res
)
{
MOZ_ASSERT
(
!
res
)
;
#
define
CHECK_TYPED_ARRAY_CONSTRUCTOR
(
T
N
)
\
if
(
native
=
=
&
TypedArrayObjectTemplate
<
T
>
:
:
class_constructor
)
{
\
return
:
:
GetTemplateObjectForNative
<
T
>
(
cx
args
res
)
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
CHECK_TYPED_ARRAY_CONSTRUCTOR
)
#
undef
CHECK_TYPED_ARRAY_CONSTRUCTOR
return
true
;
}
static
bool
TypedArray_lengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
TypedArrayObject
:
:
Getter
<
TypedArrayObject
:
:
lengthValue
>
(
cx
argc
vp
)
;
}
bool
BufferGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
TypedArrayObject
:
:
is
(
args
.
thisv
(
)
)
)
;
Rooted
<
TypedArrayObject
*
>
tarray
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
tarray
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
TypedArrayObject
:
:
bufferValue
(
tarray
)
)
;
return
true
;
}
bool
js
:
:
TypedArray_bufferGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
BufferGetterImpl
>
(
cx
args
)
;
}
static
bool
TypedArray_toStringTagGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
JSObject
*
obj
=
CheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
JSProtoKey
protoKey
=
StandardProtoKeyOrNull
(
obj
)
;
MOZ_ASSERT
(
protoKey
)
;
args
.
rval
(
)
.
setString
(
ClassName
(
protoKey
cx
)
)
;
return
true
;
}
const
JSPropertySpec
TypedArrayObject
:
:
protoAccessors
[
]
=
{
JS_PSG
(
"
length
"
TypedArray_lengthGetter
0
)
JS_PSG
(
"
buffer
"
TypedArray_bufferGetter
0
)
JS_PSG
(
"
byteLength
"
TypedArrayObject
:
:
Getter
<
TypedArrayObject
:
:
byteLengthValue
>
0
)
JS_PSG
(
"
byteOffset
"
TypedArrayObject
:
:
Getter
<
TypedArrayObject
:
:
byteOffsetValue
>
0
)
JS_SYM_GET
(
toStringTag
TypedArray_toStringTagGetter
0
)
JS_PS_END
}
;
template
<
typename
T
>
static
inline
bool
SetFromTypedArray
(
Handle
<
TypedArrayObject
*
>
target
Handle
<
TypedArrayObject
*
>
source
uint32_t
offset
)
{
if
(
target
-
>
isSharedMemory
(
)
|
|
source
-
>
isSharedMemory
(
)
)
{
return
ElementSpecific
<
T
SharedOps
>
:
:
setFromTypedArray
(
target
source
offset
)
;
}
return
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromTypedArray
(
target
source
offset
)
;
}
template
<
typename
T
>
static
inline
bool
SetFromNonTypedArray
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
target
HandleObject
source
uint32_t
len
uint32_t
offset
)
{
MOZ_ASSERT
(
!
source
-
>
is
<
TypedArrayObject
>
(
)
"
use
SetFromTypedArray
"
)
;
if
(
target
-
>
isSharedMemory
(
)
)
{
return
ElementSpecific
<
T
SharedOps
>
:
:
setFromNonTypedArray
(
cx
target
source
len
offset
)
;
}
return
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromNonTypedArray
(
cx
target
source
len
offset
)
;
}
bool
TypedArrayObject
:
:
set_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
TypedArrayObject
:
:
is
(
args
.
thisv
(
)
)
)
;
Rooted
<
TypedArrayObject
*
>
target
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
double
targetOffset
=
0
;
if
(
args
.
length
(
)
>
1
)
{
if
(
!
ToInteger
(
cx
args
[
1
]
&
targetOffset
)
)
{
return
false
;
}
if
(
targetOffset
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
}
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
RootedObject
src
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
src
)
{
return
false
;
}
Rooted
<
TypedArrayObject
*
>
srcTypedArray
(
cx
)
;
{
JSObject
*
obj
=
CheckedUnwrap
(
src
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
srcTypedArray
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
}
}
if
(
srcTypedArray
)
{
if
(
srcTypedArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
uint32_t
targetLength
=
target
-
>
length
(
)
;
if
(
targetOffset
>
targetLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
uint32_t
offset
=
uint32_t
(
targetOffset
)
;
if
(
srcTypedArray
-
>
length
(
)
>
targetLength
-
offset
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
false
;
}
switch
(
target
-
>
type
(
)
)
{
#
define
SET_FROM_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
if
(
!
SetFromTypedArray
<
T
>
(
target
srcTypedArray
offset
)
)
return
false
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
SET_FROM_TYPED_ARRAY
)
#
undef
SET_FROM_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
else
{
uint32_t
targetLength
=
target
-
>
length
(
)
;
uint32_t
srcLength
;
if
(
!
GetLengthProperty
(
cx
src
&
srcLength
)
)
{
return
false
;
}
if
(
targetOffset
>
targetLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
uint32_t
offset
=
uint32_t
(
targetOffset
)
;
if
(
srcLength
>
targetLength
-
offset
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
false
;
}
if
(
srcLength
>
0
)
{
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
RootedValue
v
(
cx
)
;
if
(
!
GetElement
(
cx
src
src
0
&
v
)
)
{
return
false
;
}
double
unused
;
if
(
!
ToNumber
(
cx
v
&
unused
)
)
{
return
false
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
switch
(
target
-
>
type
(
)
)
{
#
define
SET_FROM_NON_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
if
(
!
SetFromNonTypedArray
<
T
>
(
cx
target
src
srcLength
offset
)
)
\
return
false
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
SET_FROM_NON_TYPED_ARRAY
)
#
undef
SET_FROM_NON_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
TypedArrayObject
:
:
set
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
TypedArrayObject
:
:
set_impl
>
(
cx
args
)
;
}
const
JSFunctionSpec
TypedArrayObject
:
:
protoFunctions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
subarray
"
"
TypedArraySubarray
"
2
0
)
#
if
0
JS_SELF_HOSTED_FN
(
"
set
"
"
TypedArraySet
"
2
0
)
#
else
JS_FN
(
"
set
"
TypedArrayObject
:
:
set
1
0
)
#
endif
JS_SELF_HOSTED_FN
(
"
copyWithin
"
"
TypedArrayCopyWithin
"
3
0
)
JS_SELF_HOSTED_FN
(
"
every
"
"
TypedArrayEvery
"
1
0
)
JS_SELF_HOSTED_FN
(
"
fill
"
"
TypedArrayFill
"
3
0
)
JS_SELF_HOSTED_FN
(
"
filter
"
"
TypedArrayFilter
"
1
0
)
JS_SELF_HOSTED_FN
(
"
find
"
"
TypedArrayFind
"
1
0
)
JS_SELF_HOSTED_FN
(
"
findIndex
"
"
TypedArrayFindIndex
"
1
0
)
JS_SELF_HOSTED_FN
(
"
forEach
"
"
TypedArrayForEach
"
1
0
)
JS_SELF_HOSTED_FN
(
"
indexOf
"
"
TypedArrayIndexOf
"
2
0
)
JS_SELF_HOSTED_FN
(
"
join
"
"
TypedArrayJoin
"
1
0
)
JS_SELF_HOSTED_FN
(
"
lastIndexOf
"
"
TypedArrayLastIndexOf
"
1
0
)
JS_SELF_HOSTED_FN
(
"
map
"
"
TypedArrayMap
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reduce
"
"
TypedArrayReduce
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reduceRight
"
"
TypedArrayReduceRight
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reverse
"
"
TypedArrayReverse
"
0
0
)
JS_SELF_HOSTED_FN
(
"
slice
"
"
TypedArraySlice
"
2
0
)
JS_SELF_HOSTED_FN
(
"
some
"
"
TypedArraySome
"
1
0
)
JS_SELF_HOSTED_FN
(
"
sort
"
"
TypedArraySort
"
1
0
)
JS_SELF_HOSTED_FN
(
"
entries
"
"
TypedArrayEntries
"
0
0
)
JS_SELF_HOSTED_FN
(
"
keys
"
"
TypedArrayKeys
"
0
0
)
JS_SELF_HOSTED_FN
(
"
values
"
"
TypedArrayValues
"
0
0
)
JS_SELF_HOSTED_SYM_FN
(
iterator
"
TypedArrayValues
"
0
0
)
JS_SELF_HOSTED_FN
(
"
includes
"
"
TypedArrayIncludes
"
2
0
)
JS_SELF_HOSTED_FN
(
"
toString
"
"
ArrayToString
"
0
0
)
JS_SELF_HOSTED_FN
(
"
toLocaleString
"
"
TypedArrayToLocaleString
"
2
0
)
JS_FS_END
}
;
const
JSFunctionSpec
TypedArrayObject
:
:
staticFunctions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
from
"
"
TypedArrayStaticFrom
"
3
0
)
JS_SELF_HOSTED_FN
(
"
of
"
"
TypedArrayStaticOf
"
0
0
)
JS_FS_END
}
;
const
JSPropertySpec
TypedArrayObject
:
:
staticProperties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
TypedArraySpecies
"
0
)
JS_PS_END
}
;
static
JSObject
*
CreateSharedTypedArrayPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
GlobalObject
:
:
createBlankPrototype
(
cx
cx
-
>
global
(
)
&
TypedArrayObject
:
:
sharedTypedArrayPrototypeClass
)
;
}
static
const
ClassSpec
TypedArrayObjectSharedTypedArrayPrototypeClassSpec
=
{
GenericCreateConstructor
<
TypedArrayConstructor
0
gc
:
:
AllocKind
:
:
FUNCTION
>
CreateSharedTypedArrayPrototype
TypedArrayObject
:
:
staticFunctions
TypedArrayObject
:
:
staticProperties
TypedArrayObject
:
:
protoFunctions
TypedArrayObject
:
:
protoAccessors
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
const
Class
TypedArrayObject
:
:
sharedTypedArrayPrototypeClass
=
{
"
TypedArrayPrototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_TypedArray
)
JS_NULL_CLASS_OPS
&
TypedArrayObjectSharedTypedArrayPrototypeClassSpec
}
;
namespace
{
template
<
typename
NativeType
>
Value
TypedArrayObjectTemplate
<
NativeType
>
:
:
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
static_assert
(
sizeof
(
NativeType
)
<
4
"
this
method
must
only
handle
NativeType
values
that
are
"
"
always
exact
int32_t
values
"
)
;
return
Int32Value
(
getIndex
(
tarray
index
)
)
;
}
template
<
>
Value
TypedArrayObjectTemplate
<
int32_t
>
:
:
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
return
Int32Value
(
getIndex
(
tarray
index
)
)
;
}
template
<
>
Value
TypedArrayObjectTemplate
<
uint32_t
>
:
:
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
uint32_t
val
=
getIndex
(
tarray
index
)
;
return
NumberValue
(
val
)
;
}
template
<
>
Value
TypedArrayObjectTemplate
<
float
>
:
:
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
float
val
=
getIndex
(
tarray
index
)
;
double
dval
=
val
;
return
DoubleValue
(
CanonicalizeNaN
(
dval
)
)
;
}
template
<
>
Value
TypedArrayObjectTemplate
<
double
>
:
:
getIndexValue
(
TypedArrayObject
*
tarray
uint32_t
index
)
{
double
val
=
getIndex
(
tarray
index
)
;
return
DoubleValue
(
CanonicalizeNaN
(
val
)
)
;
}
}
Value
TypedArrayObject
:
:
getElement
(
uint32_t
index
)
{
switch
(
type
(
)
)
{
case
Scalar
:
:
Int8
:
return
Int8Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Uint8
:
return
Uint8Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Int16
:
return
Int16Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Uint16
:
return
Uint16Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Int32
:
return
Int32Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Uint32
:
return
Uint32Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Float32
:
return
Float32Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Float64
:
return
Float64Array
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Uint8Clamped
:
return
Uint8ClampedArray
:
:
getIndexValue
(
this
index
)
;
case
Scalar
:
:
Int64
:
case
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
void
TypedArrayObject
:
:
setElement
(
TypedArrayObject
&
obj
uint32_t
index
double
d
)
{
MOZ_ASSERT
(
index
<
obj
.
length
(
)
)
;
#
ifdef
JS_MORE_DETERMINISTIC
d
=
JS
:
:
CanonicalizeNaN
(
d
)
;
#
endif
switch
(
obj
.
type
(
)
)
{
case
Scalar
:
:
Int8
:
Int8Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Uint8
:
Uint8Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Uint8Clamped
:
Uint8ClampedArray
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Int16
:
Int16Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Uint16
:
Uint16Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Int32
:
Int32Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Uint32
:
Uint32Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Float32
:
Float32Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Float64
:
Float64Array
:
:
setIndexValue
(
obj
index
d
)
;
return
;
case
Scalar
:
:
Int64
:
case
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
void
TypedArrayObject
:
:
getElements
(
Value
*
vp
)
{
uint32_t
length
=
this
-
>
length
(
)
;
MOZ_ASSERT_IF
(
length
>
0
!
hasDetachedBuffer
(
)
)
;
switch
(
type
(
)
)
{
#
define
GET_ELEMENTS
(
T
N
)
\
case
Scalar
:
:
N
:
\
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
+
+
vp
)
\
*
vp
=
N
#
#
Array
:
:
getIndexValue
(
this
i
)
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
GET_ELEMENTS
)
#
undef
GET_ELEMENTS
default
:
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
}
static
const
ClassOps
TypedArrayClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypedArrayObject
:
:
finalize
nullptr
nullptr
nullptr
ArrayBufferViewObject
:
:
trace
}
;
static
const
ClassExtension
TypedArrayClassExtension
=
{
TypedArrayObject
:
:
objectMoved
}
;
static
const
JSPropertySpec
static_prototype_properties
[
Scalar
:
:
MaxTypedArrayViewType
]
[
2
]
=
{
#
define
IMPL_TYPED_ARRAY_PROPERTIES
(
NativeType
Name
)
\
{
JS_INT32_PS
(
"
BYTES_PER_ELEMENT
"
Name
#
#
Array
:
:
BYTES_PER_ELEMENT
\
JSPROP_READONLY
|
JSPROP_PERMANENT
)
\
JS_PS_END
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_PROPERTIES
)
#
undef
IMPL_TYPED_ARRAY_PROPERTIES
}
;
static
const
ClassSpec
TypedArrayObjectClassSpecs
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_CLASS_SPEC
(
NativeType
Name
)
\
{
Name
#
#
Array
:
:
createConstructor
\
Name
#
#
Array
:
:
createPrototype
\
nullptr
\
static_prototype_properties
[
Scalar
:
:
Type
:
:
Name
]
\
nullptr
\
static_prototype_properties
[
Scalar
:
:
Type
:
:
Name
]
\
nullptr
\
JSProto_TypedArray
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_CLASS_SPEC
)
#
undef
IMPL_TYPED_ARRAY_CLASS_SPEC
}
;
const
Class
TypedArrayObject
:
:
classes
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_CLASS
(
NativeType
Name
)
\
{
#
Name
"
Array
"
\
JSCLASS_HAS_RESERVED_SLOTS
(
TypedArrayObject
:
:
RESERVED_SLOTS
)
|
\
JSCLASS_HAS_PRIVATE
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
Name
#
#
Array
)
|
\
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_SKIP_NURSERY_FINALIZE
|
\
JSCLASS_BACKGROUND_FINALIZE
\
&
TypedArrayClassOps
&
TypedArrayObjectClassSpecs
[
Scalar
:
:
Type
:
:
Name
]
\
&
TypedArrayClassExtension
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_CLASS
)
#
undef
IMPL_TYPED_ARRAY_CLASS
}
;
const
Class
TypedArrayObject
:
:
protoClasses
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_PROTO_CLASS
(
NativeType
Name
)
\
{
#
Name
"
ArrayPrototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
Name
#
#
Array
)
\
JS_NULL_CLASS_OPS
&
TypedArrayObjectClassSpecs
[
Scalar
:
:
Type
:
:
Name
]
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_PROTO_CLASS
)
#
undef
IMPL_TYPED_ARRAY_PROTO_CLASS
}
;
bool
TypedArrayObject
:
:
isOriginalLengthGetter
(
Native
native
)
{
return
native
=
=
TypedArray_lengthGetter
;
}
bool
js
:
:
IsTypedArrayConstructor
(
const
JSObject
*
obj
)
{
#
define
CHECK_TYPED_ARRAY_CONSTRUCTOR
(
T
N
)
\
if
(
IsNativeFunction
(
obj
N
#
#
Array
:
:
class_constructor
)
)
{
\
return
true
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
CHECK_TYPED_ARRAY_CONSTRUCTOR
)
#
undef
CHECK_TYPED_ARRAY_CONSTRUCTOR
return
false
;
}
bool
js
:
:
IsTypedArrayConstructor
(
HandleValue
v
uint32_t
type
)
{
switch
(
type
)
{
case
Scalar
:
:
Int8
:
return
IsNativeFunction
(
v
Int8Array
:
:
class_constructor
)
;
case
Scalar
:
:
Uint8
:
return
IsNativeFunction
(
v
Uint8Array
:
:
class_constructor
)
;
case
Scalar
:
:
Int16
:
return
IsNativeFunction
(
v
Int16Array
:
:
class_constructor
)
;
case
Scalar
:
:
Uint16
:
return
IsNativeFunction
(
v
Uint16Array
:
:
class_constructor
)
;
case
Scalar
:
:
Int32
:
return
IsNativeFunction
(
v
Int32Array
:
:
class_constructor
)
;
case
Scalar
:
:
Uint32
:
return
IsNativeFunction
(
v
Uint32Array
:
:
class_constructor
)
;
case
Scalar
:
:
Float32
:
return
IsNativeFunction
(
v
Float32Array
:
:
class_constructor
)
;
case
Scalar
:
:
Float64
:
return
IsNativeFunction
(
v
Float64Array
:
:
class_constructor
)
;
case
Scalar
:
:
Uint8Clamped
:
return
IsNativeFunction
(
v
Uint8ClampedArray
:
:
class_constructor
)
;
case
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
unexpected
typed
array
type
"
)
;
}
bool
js
:
:
IsBufferSource
(
JSObject
*
object
SharedMem
<
uint8_t
*
>
*
dataPointer
size_t
*
byteLength
)
{
if
(
object
-
>
is
<
TypedArrayObject
>
(
)
)
{
TypedArrayObject
&
view
=
object
-
>
as
<
TypedArrayObject
>
(
)
;
*
dataPointer
=
view
.
dataPointerEither
(
)
.
cast
<
uint8_t
*
>
(
)
;
*
byteLength
=
view
.
byteLength
(
)
;
return
true
;
}
if
(
object
-
>
is
<
DataViewObject
>
(
)
)
{
DataViewObject
&
view
=
object
-
>
as
<
DataViewObject
>
(
)
;
*
dataPointer
=
view
.
dataPointerEither
(
)
.
cast
<
uint8_t
*
>
(
)
;
*
byteLength
=
view
.
byteLength
(
)
;
return
true
;
}
if
(
object
-
>
is
<
ArrayBufferObject
>
(
)
)
{
ArrayBufferObject
&
buffer
=
object
-
>
as
<
ArrayBufferObject
>
(
)
;
*
dataPointer
=
buffer
.
dataPointerShared
(
)
;
*
byteLength
=
buffer
.
byteLength
(
)
;
return
true
;
}
if
(
object
-
>
is
<
SharedArrayBufferObject
>
(
)
)
{
SharedArrayBufferObject
&
buffer
=
object
-
>
as
<
SharedArrayBufferObject
>
(
)
;
*
dataPointer
=
buffer
.
dataPointerShared
(
)
;
*
byteLength
=
buffer
.
byteLength
(
)
;
return
true
;
}
return
false
;
}
template
<
typename
CharT
>
bool
js
:
:
StringIsTypedArrayIndex
(
const
CharT
*
s
size_t
length
uint64_t
*
indexp
)
{
const
CharT
*
end
=
s
+
length
;
if
(
s
=
=
end
)
{
return
false
;
}
bool
negative
=
false
;
if
(
*
s
=
=
'
-
'
)
{
negative
=
true
;
if
(
+
+
s
=
=
end
)
{
return
false
;
}
}
if
(
!
IsAsciiDigit
(
*
s
)
)
{
return
false
;
}
uint64_t
index
=
0
;
uint32_t
digit
=
JS7_UNDEC
(
*
s
+
+
)
;
if
(
digit
=
=
0
&
&
s
!
=
end
)
{
return
false
;
}
index
=
digit
;
for
(
;
s
<
end
;
s
+
+
)
{
if
(
!
IsAsciiDigit
(
*
s
)
)
{
return
false
;
}
digit
=
JS7_UNDEC
(
*
s
)
;
if
(
(
UINT64_MAX
-
digit
)
/
10
<
index
)
{
index
=
UINT64_MAX
;
}
else
{
index
=
10
*
index
+
digit
;
}
}
if
(
negative
)
{
*
indexp
=
UINT64_MAX
;
}
else
{
*
indexp
=
index
;
}
return
true
;
}
template
bool
js
:
:
StringIsTypedArrayIndex
(
const
char16_t
*
s
size_t
length
uint64_t
*
indexp
)
;
template
bool
js
:
:
StringIsTypedArrayIndex
(
const
Latin1Char
*
s
size_t
length
uint64_t
*
indexp
)
;
bool
js
:
:
DefineTypedArrayElement
(
JSContext
*
cx
HandleObject
obj
uint64_t
index
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
{
MOZ_ASSERT
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
;
uint32_t
length
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
;
if
(
index
>
=
length
)
{
if
(
obj
-
>
as
<
TypedArrayObject
>
(
)
.
hasDetachedBuffer
(
)
)
{
return
result
.
failSoft
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
return
result
.
failSoft
(
JSMSG_BAD_INDEX
)
;
}
if
(
desc
.
isAccessorDescriptor
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasConfigurable
(
)
&
&
desc
.
configurable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasEnumerable
(
)
&
&
!
desc
.
enumerable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasWritable
(
)
&
&
!
desc
.
writable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasValue
(
)
)
{
double
numValue
;
if
(
!
ToNumber
(
cx
desc
.
value
(
)
&
numValue
)
)
{
return
false
;
}
if
(
obj
-
>
as
<
TypedArrayObject
>
(
)
.
hasDetachedBuffer
(
)
)
{
return
result
.
fail
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
TypedArrayObject
:
:
setElement
(
obj
-
>
as
<
TypedArrayObject
>
(
)
index
numValue
)
;
}
return
result
.
succeed
(
)
;
}
template
<
typename
NativeType
>
struct
ExternalTypeOf
{
using
Type
=
NativeType
;
}
;
template
<
>
struct
ExternalTypeOf
<
uint8_clamped
>
{
using
Type
=
uint8_t
;
}
;
#
define
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
(
NativeType
Name
)
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
Array
(
JSContext
*
cx
\
uint32_t
nelements
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromLength
(
cx
nelements
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayFromArray
(
JSContext
*
cx
\
HandleObject
other
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromArray
(
cx
other
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayWithBuffer
(
\
JSContext
*
cx
HandleObject
arrayBuffer
uint32_t
byteOffset
\
int32_t
length
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromBuffer
(
\
cx
arrayBuffer
byteOffset
length
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
js
:
:
Unwrap
#
#
Name
#
#
Array
(
JSObject
*
obj
)
{
\
obj
=
obj
-
>
maybeUnwrapIf
<
TypedArrayObject
>
(
)
;
\
if
(
!
obj
)
{
\
return
nullptr
;
\
}
\
const
Class
*
clasp
=
obj
-
>
getClass
(
)
;
\
if
(
clasp
!
=
TypedArrayObjectTemplate
<
NativeType
>
:
:
instanceClass
(
)
)
{
\
return
nullptr
;
\
}
\
return
obj
;
\
}
\
\
JS_FRIEND_API
bool
JS_Is
#
#
Name
#
#
Array
(
JSObject
*
obj
)
{
\
return
js
:
:
Unwrap
#
#
Name
#
#
Array
(
obj
)
!
=
nullptr
;
\
}
\
\
const
js
:
:
Class
*
const
js
:
:
detail
:
:
Name
#
#
ArrayClassPtr
=
\
&
js
:
:
TypedArrayObject
:
:
classes
\
[
TypedArrayObjectTemplate
<
NativeType
>
:
:
ArrayTypeID
(
)
]
;
\
\
JS_FRIEND_API
JSObject
*
JS_GetObjectAs
#
#
Name
#
#
Array
(
\
JSObject
*
obj
uint32_t
*
length
bool
*
isShared
\
ExternalTypeOf
<
NativeType
>
:
:
Type
*
*
data
)
{
\
obj
=
js
:
:
Unwrap
#
#
Name
#
#
Array
(
obj
)
;
\
if
(
!
obj
)
{
\
return
nullptr
;
\
}
\
TypedArrayObject
*
tarr
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
\
*
length
=
tarr
-
>
length
(
)
;
\
*
isShared
=
tarr
-
>
isSharedMemory
(
)
;
\
*
data
=
static_cast
<
ExternalTypeOf
<
NativeType
>
:
:
Type
*
>
(
\
tarr
-
>
dataPointerEither
(
)
.
unwrap
(
\
/
*
safe
-
caller
sees
isShared
flag
*
/
)
)
;
\
return
obj
;
\
}
\
\
JS_FRIEND_API
ExternalTypeOf
<
NativeType
>
:
:
Type
*
JS_Get
#
#
Name
#
#
ArrayData
(
\
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
{
\
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
\
if
(
!
tarr
)
{
\
return
nullptr
;
\
}
\
MOZ_ASSERT
(
tarr
-
>
type
(
)
=
=
TypeIDOfType
<
NativeType
>
:
:
id
)
;
\
*
isSharedMemory
=
tarr
-
>
isSharedMemory
(
)
;
\
return
static_cast
<
ExternalTypeOf
<
NativeType
>
:
:
Type
*
>
(
\
tarr
-
>
dataPointerEither
(
)
.
unwrap
(
/
*
safe
-
caller
sees
isShared
*
/
)
)
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
)
#
undef
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
JS_FRIEND_API
bool
JS_IsTypedArrayObject
(
JSObject
*
obj
)
{
return
obj
-
>
canUnwrapAs
<
TypedArrayObject
>
(
)
;
}
JS_FRIEND_API
uint32_t
JS_GetTypedArrayLength
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
length
(
)
;
}
JS_FRIEND_API
uint32_t
JS_GetTypedArrayByteOffset
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
byteOffset
(
)
;
}
JS_FRIEND_API
uint32_t
JS_GetTypedArrayByteLength
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
byteLength
(
)
;
}
JS_FRIEND_API
bool
JS_GetTypedArraySharedness
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
false
;
}
return
tarr
-
>
isSharedMemory
(
)
;
}
JS_FRIEND_API
js
:
:
Scalar
:
:
Type
JS_GetArrayBufferViewType
(
JSObject
*
obj
)
{
ArrayBufferViewObject
*
view
=
obj
-
>
maybeUnwrapAs
<
ArrayBufferViewObject
>
(
)
;
if
(
!
view
)
{
return
Scalar
:
:
MaxTypedArrayViewType
;
}
if
(
view
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
view
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
;
}
if
(
view
-
>
is
<
DataViewObject
>
(
)
)
{
return
Scalar
:
:
MaxTypedArrayViewType
;
}
MOZ_CRASH
(
"
invalid
ArrayBufferView
type
"
)
;
}
