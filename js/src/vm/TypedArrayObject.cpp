#
include
"
vm
/
TypedArrayObject
-
inl
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
string
>
#
include
<
string
.
h
>
#
ifndef
XP_WIN
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
"
jsapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Array
.
h
"
#
include
"
builtin
/
DataViewObject
.
h
"
#
include
"
builtin
/
TypedArrayConstants
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
MaybeRooted
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
util
/
Windows
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PIC
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
vm
/
Uint8Clamped
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSAtom
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
CanonicalizeNaN
;
using
JS
:
:
ToInt32
;
using
JS
:
:
ToUint32
;
using
mozilla
:
:
IsAsciiDigit
;
bool
TypedArrayObject
:
:
convertForSideEffect
(
JSContext
*
cx
HandleValue
v
)
const
{
switch
(
type
(
)
)
{
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
{
return
ToBigInt
(
cx
v
)
!
=
nullptr
;
}
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
case
Scalar
:
:
Float32
:
case
Scalar
:
:
Float64
:
case
Scalar
:
:
Uint8Clamped
:
{
double
ignore
;
return
ToNumber
(
cx
v
&
ignore
)
;
}
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
scalar
type
"
)
;
return
false
;
}
bool
TypedArrayObject
:
:
is
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
TypedArrayObject
>
(
)
;
}
bool
TypedArrayObject
:
:
ensureHasBuffer
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
tarray
)
{
if
(
tarray
-
>
hasBuffer
(
)
)
{
return
true
;
}
size_t
byteLength
=
tarray
-
>
byteLength
(
)
.
get
(
)
;
AutoRealm
ar
(
cx
tarray
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
ArrayBufferObject
:
:
createZeroed
(
cx
tarray
-
>
byteLength
(
)
)
)
;
if
(
!
buffer
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
buffer
-
>
addView
(
cx
tarray
)
)
;
memcpy
(
buffer
-
>
dataPointer
(
)
tarray
-
>
dataPointerUnshared
(
)
byteLength
)
;
size_t
nbytes
=
RoundUp
(
byteLength
sizeof
(
Value
)
)
;
Nursery
&
nursery
=
cx
-
>
nursery
(
)
;
if
(
tarray
-
>
isTenured
(
)
&
&
!
tarray
-
>
hasInlineElements
(
)
&
&
!
nursery
.
isInside
(
tarray
-
>
elements
(
)
)
)
{
js_free
(
tarray
-
>
elements
(
)
)
;
RemoveCellMemory
(
tarray
nbytes
MemoryUse
:
:
TypedArrayElements
)
;
}
tarray
-
>
setPrivate
(
buffer
-
>
dataPointer
(
)
)
;
tarray
-
>
setFixedSlot
(
TypedArrayObject
:
:
BUFFER_SLOT
ObjectValue
(
*
buffer
)
)
;
return
true
;
}
#
ifdef
DEBUG
void
TypedArrayObject
:
:
assertZeroLengthArrayData
(
)
const
{
if
(
length
(
)
.
get
(
)
=
=
0
&
&
!
hasBuffer
(
)
)
{
uint8_t
*
end
=
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
MOZ_ASSERT
(
end
[
0
]
=
=
ZeroLengthArrayData
)
;
}
}
#
endif
void
TypedArrayObject
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
TypedArrayObject
*
curObj
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
if
(
!
curObj
-
>
elementsRaw
(
)
)
{
return
;
}
curObj
-
>
assertZeroLengthArrayData
(
)
;
if
(
curObj
-
>
hasBuffer
(
)
)
{
return
;
}
if
(
!
curObj
-
>
hasInlineElements
(
)
)
{
size_t
nbytes
=
RoundUp
(
curObj
-
>
byteLength
(
)
.
get
(
)
sizeof
(
Value
)
)
;
fop
-
>
free_
(
obj
curObj
-
>
elements
(
)
nbytes
MemoryUse
:
:
TypedArrayElements
)
;
}
}
size_t
TypedArrayObject
:
:
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
{
TypedArrayObject
*
newObj
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
const
TypedArrayObject
*
oldObj
=
&
old
-
>
as
<
TypedArrayObject
>
(
)
;
MOZ_ASSERT
(
newObj
-
>
elementsRaw
(
)
=
=
oldObj
-
>
elementsRaw
(
)
)
;
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
)
;
if
(
oldObj
-
>
hasBuffer
(
)
)
{
return
0
;
}
if
(
!
IsInsideNursery
(
old
)
)
{
if
(
oldObj
-
>
hasInlineElements
(
)
)
{
newObj
-
>
setInlineElements
(
)
;
}
return
0
;
}
void
*
buf
=
oldObj
-
>
elements
(
)
;
if
(
!
buf
)
{
return
0
;
}
Nursery
&
nursery
=
obj
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
if
(
!
nursery
.
isInside
(
buf
)
)
{
nursery
.
removeMallocedBufferDuringMinorGC
(
buf
)
;
size_t
nbytes
=
RoundUp
(
newObj
-
>
byteLength
(
)
.
get
(
)
sizeof
(
Value
)
)
;
AddCellMemory
(
newObj
nbytes
MemoryUse
:
:
TypedArrayElements
)
;
return
0
;
}
size_t
nbytes
=
oldObj
-
>
byteLength
(
)
.
get
(
)
;
MOZ_ASSERT
(
nbytes
<
=
Nursery
:
:
MaxNurseryBufferSize
)
;
constexpr
size_t
headerSize
=
dataOffset
(
)
+
sizeof
(
HeapSlot
)
;
gc
:
:
AllocKind
newAllocKind
=
obj
-
>
asTenured
(
)
.
getAllocKind
(
)
;
MOZ_ASSERT_IF
(
nbytes
=
=
0
headerSize
+
sizeof
(
uint8_t
)
<
=
GetGCKindBytes
(
newAllocKind
)
)
;
if
(
headerSize
+
nbytes
<
=
GetGCKindBytes
(
newAllocKind
)
)
{
MOZ_ASSERT
(
oldObj
-
>
hasInlineElements
(
)
)
;
#
ifdef
DEBUG
if
(
nbytes
=
=
0
)
{
uint8_t
*
output
=
newObj
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
output
[
0
]
=
ZeroLengthArrayData
;
}
#
endif
newObj
-
>
setInlineElements
(
)
;
}
else
{
MOZ_ASSERT
(
!
oldObj
-
>
hasInlineElements
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
nbytes
=
RoundUp
(
nbytes
sizeof
(
Value
)
)
;
void
*
data
=
newObj
-
>
zone
(
)
-
>
pod_arena_malloc
<
uint8_t
>
(
js
:
:
ArrayBufferContentsArena
nbytes
)
;
if
(
!
data
)
{
oomUnsafe
.
crash
(
"
Failed
to
allocate
typed
array
elements
while
tenuring
.
"
)
;
}
MOZ_ASSERT
(
!
nursery
.
isInside
(
data
)
)
;
InitObjectPrivate
(
newObj
data
nbytes
MemoryUse
:
:
TypedArrayElements
)
;
}
mozilla
:
:
PodCopy
(
newObj
-
>
elements
(
)
oldObj
-
>
elements
(
)
nbytes
)
;
nursery
.
setForwardingPointerWhileTenuring
(
oldObj
-
>
elements
(
)
newObj
-
>
elements
(
)
nbytes
>
=
sizeof
(
uintptr_t
)
)
;
return
newObj
-
>
hasInlineElements
(
)
?
0
:
nbytes
;
}
bool
TypedArrayObject
:
:
hasInlineElements
(
)
const
{
return
elements
(
)
=
=
this
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
&
&
byteLength
(
)
.
get
(
)
<
=
TypedArrayObject
:
:
INLINE_BUFFER_LIMIT
;
}
void
TypedArrayObject
:
:
setInlineElements
(
)
{
char
*
dataSlot
=
reinterpret_cast
<
char
*
>
(
this
)
+
dataOffset
(
)
;
*
reinterpret_cast
<
void
*
*
>
(
dataSlot
)
=
this
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
}
uint32_t
JS_FASTCALL
js
:
:
ClampDoubleToUint8
(
const
double
x
)
{
if
(
!
(
x
>
=
0
)
)
{
return
0
;
}
if
(
x
>
255
)
{
return
255
;
}
double
toTruncate
=
x
+
0
.
5
;
uint8_t
y
=
uint8_t
(
toTruncate
)
;
if
(
y
=
=
toTruncate
)
{
return
y
&
~
1
;
}
return
y
;
}
namespace
{
enum
class
SpeciesConstructorOverride
{
None
ArrayBuffer
}
;
enum
class
CreateSingleton
{
No
Yes
}
;
template
<
typename
NativeType
>
class
TypedArrayObjectTemplate
:
public
TypedArrayObject
{
friend
class
TypedArrayObject
;
public
:
static
constexpr
Scalar
:
:
Type
ArrayTypeID
(
)
{
return
TypeIDOfType
<
NativeType
>
:
:
id
;
}
static
constexpr
JSProtoKey
protoKey
(
)
{
return
TypeIDOfType
<
NativeType
>
:
:
protoKey
;
}
static
constexpr
bool
ArrayTypeIsUnsigned
(
)
{
return
TypeIsUnsigned
<
NativeType
>
(
)
;
}
static
constexpr
bool
ArrayTypeIsFloatingPoint
(
)
{
return
TypeIsFloatingPoint
<
NativeType
>
(
)
;
}
static
constexpr
size_t
BYTES_PER_ELEMENT
=
sizeof
(
NativeType
)
;
static
JSObject
*
createPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedObject
typedArrayProto
(
cx
GlobalObject
:
:
getOrCreateTypedArrayPrototype
(
cx
global
)
)
;
if
(
!
typedArrayProto
)
{
return
nullptr
;
}
const
JSClass
*
clasp
=
TypedArrayObject
:
:
protoClassForType
(
ArrayTypeID
(
)
)
;
return
GlobalObject
:
:
createBlankPrototypeInheriting
(
cx
clasp
typedArrayProto
)
;
}
static
JSObject
*
createConstructor
(
JSContext
*
cx
JSProtoKey
key
)
{
Handle
<
GlobalObject
*
>
global
=
cx
-
>
global
(
)
;
RootedFunction
ctorProto
(
cx
GlobalObject
:
:
getOrCreateTypedArrayConstructor
(
cx
global
)
)
;
if
(
!
ctorProto
)
{
return
nullptr
;
}
JSFunction
*
fun
=
NewFunctionWithProto
(
cx
class_constructor
3
FunctionFlags
:
:
NATIVE_CTOR
nullptr
ClassName
(
key
cx
)
ctorProto
gc
:
:
AllocKind
:
:
FUNCTION
TenuredObject
)
;
if
(
fun
)
{
fun
-
>
setJitInfo
(
&
jit
:
:
JitInfo_TypedArrayConstructor
)
;
}
return
fun
;
}
static
inline
const
JSClass
*
instanceClass
(
)
{
return
TypedArrayObject
:
:
classForType
(
ArrayTypeID
(
)
)
;
}
static
bool
is
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
hasClass
(
instanceClass
(
)
)
;
}
static
bool
convertValue
(
JSContext
*
cx
HandleValue
v
NativeType
*
result
)
;
static
TypedArrayObject
*
newBuiltinClassInstance
(
JSContext
*
cx
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
JSObject
*
obj
=
NewBuiltinClassInstance
(
cx
instanceClass
(
)
allocKind
newKind
)
;
return
obj
?
&
obj
-
>
as
<
TypedArrayObject
>
(
)
:
nullptr
;
}
static
TypedArrayObject
*
makeProtoInstance
(
JSContext
*
cx
HandleObject
proto
gc
:
:
AllocKind
allocKind
)
{
MOZ_ASSERT
(
proto
)
;
JSObject
*
obj
=
NewObjectWithGivenProto
(
cx
instanceClass
(
)
proto
allocKind
)
;
return
obj
?
&
obj
-
>
as
<
TypedArrayObject
>
(
)
:
nullptr
;
}
static
TypedArrayObject
*
makeTypedInstance
(
JSContext
*
cx
HandleObjectGroup
group
gc
:
:
AllocKind
allocKind
)
{
if
(
group
)
{
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
instanceClass
(
)
)
;
NewObjectKind
newKind
=
GenericObject
;
return
NewObjectWithGroup
<
TypedArrayObject
>
(
cx
group
allocKind
newKind
)
;
}
return
newBuiltinClassInstance
(
cx
allocKind
GenericObject
)
;
}
static
TypedArrayObject
*
makeInstance
(
JSContext
*
cx
Handle
<
ArrayBufferObjectMaybeShared
*
>
buffer
BufferSize
byteOffset
BufferSize
len
HandleObject
proto
HandleObjectGroup
group
=
nullptr
)
{
MOZ_ASSERT
(
len
.
get
(
)
<
=
maxByteLength
(
)
/
BYTES_PER_ELEMENT
)
;
gc
:
:
AllocKind
allocKind
=
buffer
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
len
.
get
(
)
*
BYTES_PER_ELEMENT
)
;
RootedObject
checkProto
(
cx
)
;
if
(
proto
)
{
checkProto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
protoKey
(
)
)
;
if
(
!
checkProto
)
{
return
nullptr
;
}
}
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
TypedArrayObject
*
>
obj
(
cx
)
;
if
(
proto
&
&
proto
!
=
checkProto
)
{
MOZ_ASSERT
(
!
group
)
;
obj
=
makeProtoInstance
(
cx
proto
allocKind
)
;
}
else
{
obj
=
makeTypedInstance
(
cx
group
allocKind
)
;
}
if
(
!
obj
|
|
!
obj
-
>
init
(
cx
buffer
byteOffset
len
BYTES_PER_ELEMENT
)
)
{
return
nullptr
;
}
return
obj
;
}
static
TypedArrayObject
*
makeTemplateObject
(
JSContext
*
cx
int32_t
len
)
{
MOZ_ASSERT
(
len
>
=
0
)
;
size_t
nbytes
;
MOZ_ALWAYS_TRUE
(
CalculateAllocSize
<
NativeType
>
(
len
&
nbytes
)
)
;
bool
fitsInline
=
nbytes
<
=
INLINE_BUFFER_LIMIT
;
gc
:
:
AllocKind
allocKind
=
!
fitsInline
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
nbytes
)
;
MOZ_ASSERT
(
allocKind
>
=
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
TypedArrayObject
*
>
tarray
(
cx
newBuiltinClassInstance
(
cx
allocKind
TenuredObject
)
)
;
if
(
!
tarray
)
{
return
nullptr
;
}
initTypedArraySlots
(
tarray
len
)
;
tarray
-
>
initPrivate
(
nullptr
)
;
return
tarray
;
}
static
void
initTypedArraySlots
(
TypedArrayObject
*
tarray
int32_t
len
)
{
MOZ_ASSERT
(
len
>
=
0
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
BUFFER_SLOT
NullValue
(
)
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
LENGTH_SLOT
PrivateValue
(
len
)
)
;
tarray
-
>
initFixedSlot
(
TypedArrayObject
:
:
BYTEOFFSET_SLOT
PrivateValue
(
size_t
(
0
)
)
)
;
MOZ_ASSERT
(
tarray
-
>
numFixedSlots
(
)
=
=
TypedArrayObject
:
:
DATA_SLOT
)
;
#
ifdef
DEBUG
if
(
len
=
=
0
)
{
uint8_t
*
output
=
tarray
-
>
fixedData
(
TypedArrayObject
:
:
FIXED_DATA_START
)
;
output
[
0
]
=
TypedArrayObject
:
:
ZeroLengthArrayData
;
}
#
endif
}
static
void
initTypedArrayData
(
TypedArrayObject
*
tarray
void
*
buf
size_t
nbytes
gc
:
:
AllocKind
allocKind
)
{
if
(
buf
)
{
InitObjectPrivate
(
tarray
buf
nbytes
MemoryUse
:
:
TypedArrayElements
)
;
}
else
{
#
ifdef
DEBUG
constexpr
size_t
dataOffset
=
ArrayBufferViewObject
:
:
dataOffset
(
)
;
constexpr
size_t
offset
=
dataOffset
+
sizeof
(
HeapSlot
)
;
MOZ_ASSERT
(
offset
+
nbytes
<
=
GetGCKindBytes
(
allocKind
)
)
;
#
endif
void
*
data
=
tarray
-
>
fixedData
(
FIXED_DATA_START
)
;
tarray
-
>
initPrivate
(
data
)
;
memset
(
data
0
nbytes
)
;
}
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
int32_t
len
)
{
if
(
len
<
0
|
|
size_t
(
len
)
>
maxByteLength
(
)
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
nullptr
;
}
size_t
nbytes
=
size_t
(
len
)
*
BYTES_PER_ELEMENT
;
MOZ_ASSERT
(
nbytes
<
=
maxByteLength
(
)
)
;
bool
fitsInline
=
nbytes
<
=
INLINE_BUFFER_LIMIT
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
gc
:
:
AllocKind
allocKind
=
!
fitsInline
?
gc
:
:
GetGCObjectKind
(
instanceClass
(
)
)
:
AllocKindForLazyBuffer
(
nbytes
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
instanceClass
(
)
)
;
TypedArrayObject
*
obj
=
NewObjectWithGroup
<
TypedArrayObject
>
(
cx
group
allocKind
)
;
if
(
!
obj
)
{
return
nullptr
;
}
initTypedArraySlots
(
obj
len
)
;
void
*
buf
=
nullptr
;
if
(
!
fitsInline
)
{
MOZ_ASSERT
(
len
>
0
)
;
nbytes
=
RoundUp
(
nbytes
sizeof
(
Value
)
)
;
buf
=
cx
-
>
nursery
(
)
.
allocateZeroedBuffer
(
obj
nbytes
js
:
:
ArrayBufferContentsArena
)
;
if
(
!
buf
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
initTypedArrayData
(
obj
buf
nbytes
allocKind
)
;
return
obj
;
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
HandleObject
array
)
{
MOZ_ASSERT
(
!
IsWrapper
(
array
)
)
;
MOZ_ASSERT
(
!
array
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
return
fromArray
(
cx
array
nullptr
group
)
;
}
static
TypedArrayObject
*
makeTypedArrayWithTemplate
(
JSContext
*
cx
TypedArrayObject
*
templateObj
HandleObject
arrayBuffer
HandleValue
byteOffsetValue
HandleValue
lengthValue
)
{
MOZ_ASSERT
(
!
IsWrapper
(
arrayBuffer
)
)
;
MOZ_ASSERT
(
arrayBuffer
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
;
RootedObjectGroup
group
(
cx
templateObj
-
>
group
(
)
)
;
uint64_t
byteOffset
length
;
if
(
!
byteOffsetAndLength
(
cx
byteOffsetValue
lengthValue
&
byteOffset
&
length
)
)
{
return
nullptr
;
}
return
fromBufferSameCompartment
(
cx
arrayBuffer
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
byteOffset
length
nullptr
group
)
;
}
static
bool
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
typed
array
"
)
)
{
return
false
;
}
JSObject
*
obj
=
create
(
cx
args
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
private
:
static
JSObject
*
create
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
isConstructing
(
)
)
;
if
(
args
.
length
(
)
=
=
0
|
|
!
args
[
0
]
.
isObject
(
)
)
{
uint64_t
len
;
if
(
!
ToIndex
(
cx
args
.
get
(
0
)
JSMSG_BAD_ARRAY_LENGTH
&
len
)
)
{
return
nullptr
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
protoKey
(
)
&
proto
)
)
{
return
nullptr
;
}
return
fromLength
(
cx
len
proto
)
;
}
RootedObject
dataObj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
protoKey
(
)
&
proto
)
)
{
return
nullptr
;
}
if
(
!
UncheckedUnwrap
(
dataObj
)
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
return
fromArray
(
cx
dataObj
proto
)
;
}
uint64_t
byteOffset
length
;
if
(
!
byteOffsetAndLength
(
cx
args
.
get
(
1
)
args
.
get
(
2
)
&
byteOffset
&
length
)
)
{
return
nullptr
;
}
if
(
dataObj
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
HandleArrayBufferObjectMaybeShared
buffer
=
dataObj
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
return
fromBufferSameCompartment
(
cx
buffer
byteOffset
length
proto
)
;
}
return
fromBufferWrapped
(
cx
dataObj
byteOffset
length
proto
)
;
}
static
bool
byteOffsetAndLength
(
JSContext
*
cx
HandleValue
byteOffsetValue
HandleValue
lengthValue
uint64_t
*
byteOffset
uint64_t
*
length
)
{
*
byteOffset
=
0
;
if
(
!
byteOffsetValue
.
isUndefined
(
)
)
{
if
(
!
ToIndex
(
cx
byteOffsetValue
byteOffset
)
)
{
return
false
;
}
if
(
*
byteOffset
%
BYTES_PER_ELEMENT
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
}
*
length
=
UINT64_MAX
;
if
(
!
lengthValue
.
isUndefined
(
)
)
{
if
(
!
ToIndex
(
cx
lengthValue
length
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
computeAndCheckLength
(
JSContext
*
cx
HandleArrayBufferObjectMaybeShared
bufferMaybeUnwrapped
uint64_t
byteOffset
uint64_t
lengthIndex
BufferSize
*
length
)
{
MOZ_ASSERT
(
byteOffset
%
BYTES_PER_ELEMENT
=
=
0
)
;
MOZ_ASSERT
(
byteOffset
<
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
;
MOZ_ASSERT_IF
(
lengthIndex
!
=
UINT64_MAX
lengthIndex
<
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
;
if
(
bufferMaybeUnwrapped
-
>
isDetached
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
size_t
bufferByteLength
=
bufferMaybeUnwrapped
-
>
byteLength
(
)
.
get
(
)
;
size_t
len
;
if
(
lengthIndex
=
=
UINT64_MAX
)
{
if
(
bufferByteLength
%
BYTES_PER_ELEMENT
!
=
0
|
|
byteOffset
>
bufferByteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
size_t
newByteLength
=
bufferByteLength
-
size_t
(
byteOffset
)
;
len
=
newByteLength
/
BYTES_PER_ELEMENT
;
}
else
{
uint64_t
newByteLength
=
lengthIndex
*
BYTES_PER_ELEMENT
;
if
(
byteOffset
+
newByteLength
>
bufferByteLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
len
=
size_t
(
lengthIndex
)
;
}
if
(
len
>
maxByteLength
(
)
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
false
;
}
MOZ_ASSERT
(
len
<
SIZE_MAX
)
;
*
length
=
BufferSize
(
len
)
;
return
true
;
}
static
TypedArrayObject
*
fromBufferSameCompartment
(
JSContext
*
cx
HandleArrayBufferObjectMaybeShared
buffer
uint64_t
byteOffset
uint64_t
lengthIndex
HandleObject
proto
HandleObjectGroup
group
=
nullptr
)
{
BufferSize
length
(
0
)
;
if
(
!
computeAndCheckLength
(
cx
buffer
byteOffset
lengthIndex
&
length
)
)
{
return
nullptr
;
}
return
makeInstance
(
cx
buffer
BufferSize
(
byteOffset
)
length
proto
group
)
;
}
static
JSObject
*
fromBufferWrapped
(
JSContext
*
cx
HandleObject
bufobj
uint64_t
byteOffset
uint64_t
lengthIndex
HandleObject
proto
)
{
JSObject
*
unwrapped
=
CheckedUnwrapStatic
(
bufobj
)
;
if
(
!
unwrapped
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
if
(
!
unwrapped
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_BAD_ARGS
)
;
return
nullptr
;
}
RootedArrayBufferObjectMaybeShared
unwrappedBuffer
(
cx
)
;
unwrappedBuffer
=
&
unwrapped
-
>
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
BufferSize
length
(
0
)
;
if
(
!
computeAndCheckLength
(
cx
unwrappedBuffer
byteOffset
lengthIndex
&
length
)
)
{
return
nullptr
;
}
RootedObject
protoRoot
(
cx
proto
)
;
if
(
!
protoRoot
)
{
protoRoot
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
protoKey
(
)
)
;
if
(
!
protoRoot
)
{
return
nullptr
;
}
}
RootedObject
typedArray
(
cx
)
;
{
JSAutoRealm
ar
(
cx
unwrappedBuffer
)
;
RootedObject
wrappedProto
(
cx
protoRoot
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
wrappedProto
)
)
{
return
nullptr
;
}
typedArray
=
makeInstance
(
cx
unwrappedBuffer
BufferSize
(
byteOffset
)
length
wrappedProto
)
;
if
(
!
typedArray
)
{
return
nullptr
;
}
}
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
typedArray
)
)
{
return
nullptr
;
}
return
typedArray
;
}
public
:
static
JSObject
*
fromBuffer
(
JSContext
*
cx
HandleObject
bufobj
size_t
byteOffset
int64_t
lengthInt
)
{
if
(
byteOffset
%
BYTES_PER_ELEMENT
!
=
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS
)
;
return
nullptr
;
}
uint64_t
lengthIndex
=
lengthInt
>
=
0
?
uint64_t
(
lengthInt
)
:
UINT64_MAX
;
if
(
bufobj
-
>
is
<
ArrayBufferObjectMaybeShared
>
(
)
)
{
HandleArrayBufferObjectMaybeShared
buffer
=
bufobj
.
as
<
ArrayBufferObjectMaybeShared
>
(
)
;
return
fromBufferSameCompartment
(
cx
buffer
byteOffset
lengthIndex
nullptr
)
;
}
return
fromBufferWrapped
(
cx
bufobj
byteOffset
lengthIndex
nullptr
)
;
}
static
bool
maybeCreateArrayBuffer
(
JSContext
*
cx
uint64_t
count
HandleObject
nonDefaultProto
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
{
if
(
count
>
maxByteLength
(
)
/
BYTES_PER_ELEMENT
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_ARRAY_LENGTH
)
;
return
false
;
}
BufferSize
byteLength
=
BufferSize
(
count
*
BYTES_PER_ELEMENT
)
;
MOZ_ASSERT
(
byteLength
.
get
(
)
<
=
maxByteLength
(
)
)
;
static_assert
(
INLINE_BUFFER_LIMIT
%
BYTES_PER_ELEMENT
=
=
0
"
ArrayBuffer
inline
storage
shouldn
'
t
waste
any
space
"
)
;
if
(
!
nonDefaultProto
&
&
byteLength
.
get
(
)
<
=
INLINE_BUFFER_LIMIT
)
{
return
true
;
}
ArrayBufferObject
*
buf
=
ArrayBufferObject
:
:
createZeroed
(
cx
byteLength
nonDefaultProto
)
;
if
(
!
buf
)
{
return
false
;
}
buffer
.
set
(
buf
)
;
return
true
;
}
static
JSObject
*
fromLength
(
JSContext
*
cx
uint64_t
nelements
HandleObject
proto
=
nullptr
)
{
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
nelements
nullptr
&
buffer
)
)
{
return
nullptr
;
}
return
makeInstance
(
cx
buffer
BufferSize
(
0
)
BufferSize
(
nelements
)
proto
)
;
}
static
bool
AllocateArrayBuffer
(
JSContext
*
cx
HandleObject
ctor
BufferSize
count
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
;
static
TypedArrayObject
*
fromArray
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
=
nullptr
HandleObjectGroup
group
=
nullptr
)
;
static
TypedArrayObject
*
fromTypedArray
(
JSContext
*
cx
HandleObject
other
bool
isWrapped
HandleObject
proto
HandleObjectGroup
group
)
;
static
TypedArrayObject
*
fromObject
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
;
static
const
NativeType
getIndex
(
TypedArrayObject
*
tarray
size_t
index
)
{
MOZ_ASSERT
(
index
<
tarray
-
>
length
(
)
.
get
(
)
)
;
return
jit
:
:
AtomicOperations
:
:
loadSafeWhenRacy
(
tarray
-
>
dataPointerEither
(
)
.
cast
<
NativeType
*
>
(
)
+
index
)
;
}
static
void
setIndex
(
TypedArrayObject
&
tarray
size_t
index
NativeType
val
)
{
MOZ_ASSERT
(
index
<
tarray
.
length
(
)
.
get
(
)
)
;
jit
:
:
AtomicOperations
:
:
storeSafeWhenRacy
(
tarray
.
dataPointerEither
(
)
.
cast
<
NativeType
*
>
(
)
+
index
val
)
;
}
static
bool
getElement
(
JSContext
*
cx
TypedArrayObject
*
tarray
size_t
index
MutableHandleValue
val
)
;
static
bool
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
;
static
bool
setElement
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
obj
uint64_t
index
HandleValue
v
ObjectOpResult
&
result
)
;
}
;
template
<
typename
NativeType
>
bool
TypedArrayObjectTemplate
<
NativeType
>
:
:
convertValue
(
JSContext
*
cx
HandleValue
v
NativeType
*
result
)
{
double
d
;
if
(
!
ToNumber
(
cx
v
&
d
)
)
{
return
false
;
}
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
d
=
JS
:
:
CanonicalizeNaN
(
d
)
;
}
if
constexpr
(
ArrayTypeIsFloatingPoint
(
)
)
{
*
result
=
NativeType
(
d
)
;
}
else
if
constexpr
(
ArrayTypeIsUnsigned
(
)
)
{
static_assert
(
sizeof
(
NativeType
)
<
=
4
)
;
uint32_t
n
=
ToUint32
(
d
)
;
*
result
=
NativeType
(
n
)
;
}
else
if
constexpr
(
ArrayTypeID
(
)
=
=
Scalar
:
:
Uint8Clamped
)
{
*
result
=
NativeType
(
d
)
;
}
else
{
static_assert
(
sizeof
(
NativeType
)
<
=
4
)
;
int32_t
n
=
ToInt32
(
d
)
;
*
result
=
NativeType
(
n
)
;
}
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
int64_t
>
:
:
convertValue
(
JSContext
*
cx
HandleValue
v
int64_t
*
result
)
{
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
*
result
ToBigInt64
(
cx
v
)
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
uint64_t
>
:
:
convertValue
(
JSContext
*
cx
HandleValue
v
uint64_t
*
result
)
{
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
*
result
ToBigUint64
(
cx
v
)
)
;
return
true
;
}
template
<
typename
NativeType
>
bool
TypedArrayObjectTemplate
<
NativeType
>
:
:
setElement
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
obj
uint64_t
index
HandleValue
v
ObjectOpResult
&
result
)
{
MOZ_ASSERT
(
!
obj
-
>
hasDetachedBuffer
(
)
)
;
MOZ_ASSERT
(
index
<
obj
-
>
length
(
)
.
get
(
)
)
;
NativeType
nativeValue
;
if
(
!
convertValue
(
cx
v
&
nativeValue
)
)
{
return
false
;
}
if
(
index
<
obj
-
>
length
(
)
.
get
(
)
)
{
MOZ_ASSERT
(
!
obj
-
>
hasDetachedBuffer
(
)
"
detaching
an
array
buffer
sets
the
length
to
zero
"
)
;
TypedArrayObjectTemplate
<
NativeType
>
:
:
setIndex
(
*
obj
index
nativeValue
)
;
}
return
result
.
succeed
(
)
;
}
#
define
CREATE_TYPE_FOR_TYPED_ARRAY
(
T
N
)
\
typedef
TypedArrayObjectTemplate
<
T
>
N
#
#
Array
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPE_FOR_TYPED_ARRAY
)
#
undef
CREATE_TYPE_FOR_TYPED_ARRAY
}
TypedArrayObject
*
js
:
:
NewTypedArrayWithTemplateAndLength
(
JSContext
*
cx
HandleObject
templateObj
int32_t
len
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
cx
tobj
\
len
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
TypedArrayObject
*
js
:
:
NewTypedArrayWithTemplateAndArray
(
JSContext
*
cx
HandleObject
templateObj
HandleObject
array
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
cx
tobj
\
array
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
TypedArrayObject
*
js
:
:
NewTypedArrayWithTemplateAndBuffer
(
JSContext
*
cx
HandleObject
templateObj
HandleObject
arrayBuffer
HandleValue
byteOffset
HandleValue
length
)
{
MOZ_ASSERT
(
templateObj
-
>
is
<
TypedArrayObject
>
(
)
)
;
TypedArrayObject
*
tobj
=
&
templateObj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
CREATE_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
makeTypedArrayWithTemplate
(
\
cx
tobj
arrayBuffer
byteOffset
length
)
;
JS_FOR_EACH_TYPED_ARRAY
(
CREATE_TYPED_ARRAY
)
#
undef
CREATE_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
template
<
typename
T
>
bool
TypedArrayObjectTemplate
<
T
>
:
:
AllocateArrayBuffer
(
JSContext
*
cx
HandleObject
ctor
BufferSize
count
MutableHandle
<
ArrayBufferObject
*
>
buffer
)
{
RootedObject
proto
(
cx
)
;
JSObject
*
arrayBufferCtor
=
GlobalObject
:
:
getOrCreateArrayBufferConstructor
(
cx
cx
-
>
global
(
)
)
;
if
(
!
arrayBufferCtor
)
{
return
false
;
}
if
(
ctor
!
=
arrayBufferCtor
)
{
if
(
!
GetPrototypeFromConstructor
(
cx
ctor
JSProto_ArrayBuffer
&
proto
)
)
{
return
false
;
}
}
if
(
!
maybeCreateArrayBuffer
(
cx
count
.
get
(
)
proto
buffer
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsArrayBufferSpecies
(
JSContext
*
cx
JSFunction
*
species
)
{
return
IsSelfHostedFunctionWithName
(
species
cx
-
>
names
(
)
.
ArrayBufferSpecies
)
;
}
static
JSObject
*
GetBufferSpeciesConstructor
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
typedArray
bool
isWrapped
SpeciesConstructorOverride
override
)
{
RootedObject
defaultCtor
(
cx
GlobalObject
:
:
getOrCreateArrayBufferConstructor
(
cx
cx
-
>
global
(
)
)
)
;
if
(
!
defaultCtor
)
{
return
nullptr
;
}
if
(
override
=
=
SpeciesConstructorOverride
:
:
ArrayBuffer
)
{
return
defaultCtor
;
}
RootedObject
obj
(
cx
typedArray
-
>
bufferEither
(
)
)
;
if
(
!
obj
)
{
MOZ_ASSERT
(
!
isWrapped
)
;
JSObject
*
proto
=
GlobalObject
:
:
getOrCreateArrayBufferPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
{
return
nullptr
;
}
Value
ctor
;
bool
found
;
if
(
GetOwnPropertyPure
(
cx
proto
NameToId
(
cx
-
>
names
(
)
.
constructor
)
&
ctor
&
found
)
&
&
ctor
.
isObject
(
)
&
&
&
ctor
.
toObject
(
)
=
=
defaultCtor
)
{
jsid
speciesId
=
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
species
)
;
JSFunction
*
getter
;
if
(
GetOwnGetterPure
(
cx
defaultCtor
speciesId
&
getter
)
&
&
getter
&
&
IsArrayBufferSpecies
(
cx
getter
)
)
{
return
defaultCtor
;
}
}
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
typedArray
)
)
{
return
nullptr
;
}
obj
.
set
(
typedArray
-
>
bufferEither
(
)
)
;
}
else
{
if
(
isWrapped
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
obj
)
)
{
return
nullptr
;
}
}
return
SpeciesConstructor
(
cx
obj
defaultCtor
IsArrayBufferSpecies
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromArray
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
{
if
(
other
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
fromTypedArray
(
cx
other
false
proto
group
)
;
}
if
(
other
-
>
is
<
WrapperObject
>
(
)
&
&
UncheckedUnwrap
(
other
)
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
fromTypedArray
(
cx
other
true
proto
group
)
;
}
return
fromObject
(
cx
other
proto
group
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromTypedArray
(
JSContext
*
cx
HandleObject
other
bool
isWrapped
HandleObject
proto
HandleObjectGroup
group
)
{
MOZ_ASSERT_IF
(
!
isWrapped
other
-
>
is
<
TypedArrayObject
>
(
)
)
;
MOZ_ASSERT_IF
(
isWrapped
other
-
>
is
<
WrapperObject
>
(
)
&
&
UncheckedUnwrap
(
other
)
-
>
is
<
TypedArrayObject
>
(
)
)
;
Rooted
<
TypedArrayObject
*
>
srcArray
(
cx
)
;
if
(
!
isWrapped
)
{
srcArray
=
&
other
-
>
as
<
TypedArrayObject
>
(
)
;
}
else
{
srcArray
=
other
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
srcArray
)
{
ReportAccessDenied
(
cx
)
;
return
nullptr
;
}
}
if
(
cx
-
>
realm
(
)
!
=
srcArray
-
>
realm
(
)
|
|
isWrapped
)
{
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
srcArray
)
)
{
return
nullptr
;
}
}
if
(
srcArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
BufferSize
elementLength
=
srcArray
-
>
length
(
)
;
bool
isShared
=
srcArray
-
>
isSharedMemory
(
)
;
SpeciesConstructorOverride
override
=
isShared
?
SpeciesConstructorOverride
:
:
ArrayBuffer
:
SpeciesConstructorOverride
:
:
None
;
RootedObject
bufferCtor
(
cx
GetBufferSpeciesConstructor
(
cx
srcArray
isWrapped
override
)
)
;
if
(
!
bufferCtor
)
{
return
nullptr
;
}
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
AllocateArrayBuffer
(
cx
bufferCtor
elementLength
&
buffer
)
)
{
return
nullptr
;
}
if
(
srcArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
nullptr
;
}
if
(
Scalar
:
:
isBigIntType
(
ArrayTypeID
(
)
)
!
=
Scalar
:
:
isBigIntType
(
srcArray
-
>
type
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_NOT_COMPATIBLE
srcArray
-
>
getClass
(
)
-
>
name
TypedArrayObject
:
:
classes
[
ArrayTypeID
(
)
]
.
name
)
;
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
BufferSize
(
0
)
elementLength
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
isShared
)
{
if
(
!
ElementSpecific
<
T
SharedOps
>
:
:
setFromTypedArray
(
obj
srcArray
0
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromTypedArray
(
obj
srcArray
0
)
)
{
return
nullptr
;
}
}
return
obj
;
}
static
MOZ_ALWAYS_INLINE
bool
IsOptimizableInit
(
JSContext
*
cx
HandleObject
iterable
bool
*
optimized
)
{
MOZ_ASSERT
(
!
*
optimized
)
;
if
(
!
IsPackedArray
(
iterable
)
)
{
return
true
;
}
ForOfPIC
:
:
Chain
*
stubChain
=
ForOfPIC
:
:
getOrCreate
(
cx
)
;
if
(
!
stubChain
)
{
return
false
;
}
return
stubChain
-
>
tryOptimizeArray
(
cx
iterable
.
as
<
ArrayObject
>
(
)
optimized
)
;
}
template
<
typename
T
>
TypedArrayObject
*
TypedArrayObjectTemplate
<
T
>
:
:
fromObject
(
JSContext
*
cx
HandleObject
other
HandleObject
proto
HandleObjectGroup
group
)
{
bool
optimized
=
false
;
if
(
!
IsOptimizableInit
(
cx
other
&
optimized
)
)
{
return
nullptr
;
}
if
(
optimized
)
{
HandleArrayObject
array
=
other
.
as
<
ArrayObject
>
(
)
;
size_t
len
=
array
-
>
getDenseInitializedLength
(
)
;
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
len
nullptr
&
buffer
)
)
{
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
BufferSize
(
0
)
BufferSize
(
len
)
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
initFromIterablePackedArray
(
cx
obj
array
)
)
{
return
nullptr
;
}
return
obj
;
}
RootedValue
callee
(
cx
)
;
RootedId
iteratorId
(
cx
SYMBOL_TO_JSID
(
cx
-
>
wellKnownSymbols
(
)
.
iterator
)
)
;
if
(
!
GetProperty
(
cx
other
other
iteratorId
&
callee
)
)
{
return
nullptr
;
}
RootedObject
arrayLike
(
cx
)
;
if
(
!
callee
.
isNullOrUndefined
(
)
)
{
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
isCallable
(
)
)
{
RootedValue
otherVal
(
cx
ObjectValue
(
*
other
)
)
;
UniqueChars
bytes
=
DecompileValueGenerator
(
cx
JSDVG_SEARCH_STACK
otherVal
nullptr
)
;
if
(
!
bytes
)
{
return
nullptr
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_ITERABLE
bytes
.
get
(
)
)
;
return
nullptr
;
}
FixedInvokeArgs
<
2
>
args2
(
cx
)
;
args2
[
0
]
.
setObject
(
*
other
)
;
args2
[
1
]
.
set
(
callee
)
;
RootedValue
rval
(
cx
)
;
if
(
!
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
IterableToList
UndefinedHandleValue
args2
&
rval
)
)
{
return
nullptr
;
}
arrayLike
=
&
rval
.
toObject
(
)
;
}
else
{
arrayLike
=
other
;
}
uint32_t
len
;
if
(
!
GetLengthProperty
(
cx
arrayLike
&
len
)
)
{
return
nullptr
;
}
Rooted
<
ArrayBufferObject
*
>
buffer
(
cx
)
;
if
(
!
maybeCreateArrayBuffer
(
cx
len
nullptr
&
buffer
)
)
{
return
nullptr
;
}
Rooted
<
TypedArrayObject
*
>
obj
(
cx
makeInstance
(
cx
buffer
BufferSize
(
0
)
BufferSize
(
len
)
proto
group
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
obj
-
>
isSharedMemory
(
)
)
;
if
(
!
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromNonTypedArray
(
cx
obj
arrayLike
len
)
)
{
return
nullptr
;
}
return
obj
;
}
bool
TypedArrayConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT
args
.
isConstructing
(
)
?
"
construct
"
:
"
call
"
)
;
return
false
;
}
template
<
typename
T
>
static
bool
GetTemplateObjectForNative
(
JSContext
*
cx
const
JS
:
:
HandleValueArray
args
MutableHandleObject
res
)
{
if
(
args
.
length
(
)
=
=
0
)
{
return
true
;
}
HandleValue
arg
=
args
[
0
]
;
if
(
arg
.
isInt32
(
)
)
{
uint32_t
len
=
0
;
if
(
arg
.
toInt32
(
)
>
=
0
)
{
len
=
arg
.
toInt32
(
)
;
}
size_t
nbytes
;
if
(
!
js
:
:
CalculateAllocSize
<
T
>
(
len
&
nbytes
)
)
{
return
true
;
}
res
.
set
(
TypedArrayObjectTemplate
<
T
>
:
:
makeTemplateObject
(
cx
len
)
)
;
return
!
!
res
;
}
if
(
arg
.
isObject
(
)
&
&
!
IsWrapper
(
&
arg
.
toObject
(
)
)
)
{
uint32_t
len
=
0
;
res
.
set
(
TypedArrayObjectTemplate
<
T
>
:
:
makeTemplateObject
(
cx
len
)
)
;
return
!
!
res
;
}
return
true
;
}
bool
TypedArrayObject
:
:
GetTemplateObjectForNative
(
JSContext
*
cx
Native
native
const
JS
:
:
HandleValueArray
args
MutableHandleObject
res
)
{
MOZ_ASSERT
(
!
res
)
;
#
define
CHECK_TYPED_ARRAY_CONSTRUCTOR
(
T
N
)
\
if
(
native
=
=
&
TypedArrayObjectTemplate
<
T
>
:
:
class_constructor
)
{
\
return
:
:
GetTemplateObjectForNative
<
T
>
(
cx
args
res
)
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
CHECK_TYPED_ARRAY_CONSTRUCTOR
)
#
undef
CHECK_TYPED_ARRAY_CONSTRUCTOR
return
true
;
}
static
bool
LengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
tarr
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
;
args
.
rval
(
)
.
set
(
tarr
-
>
lengthValue
(
)
)
;
return
true
;
}
static
bool
TypedArray_lengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
LengthGetterImpl
>
(
cx
args
)
;
}
static
bool
ByteOffsetGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
tarr
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
;
args
.
rval
(
)
.
set
(
tarr
-
>
byteOffsetValue
(
)
)
;
return
true
;
}
static
bool
TypedArray_byteOffsetGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
ByteOffsetGetterImpl
>
(
cx
args
)
;
}
static
bool
ByteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
auto
*
tarr
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
;
args
.
rval
(
)
.
set
(
tarr
-
>
byteLengthValue
(
)
)
;
return
true
;
}
static
bool
TypedArray_byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
ByteLengthGetterImpl
>
(
cx
args
)
;
}
static
bool
BufferGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
TypedArrayObject
:
:
is
(
args
.
thisv
(
)
)
)
;
Rooted
<
TypedArrayObject
*
>
tarray
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
if
(
!
TypedArrayObject
:
:
ensureHasBuffer
(
cx
tarray
)
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
tarray
-
>
bufferValue
(
)
)
;
return
true
;
}
bool
js
:
:
TypedArray_bufferGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
BufferGetterImpl
>
(
cx
args
)
;
}
static
bool
TypedArray_toStringTagGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
JSObject
*
obj
=
CheckedUnwrapStatic
(
&
args
.
thisv
(
)
.
toObject
(
)
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
JSProtoKey
protoKey
=
StandardProtoKeyOrNull
(
obj
)
;
MOZ_ASSERT
(
protoKey
)
;
args
.
rval
(
)
.
setString
(
ClassName
(
protoKey
cx
)
)
;
return
true
;
}
const
JSPropertySpec
TypedArrayObject
:
:
protoAccessors
[
]
=
{
JS_PSG
(
"
length
"
TypedArray_lengthGetter
0
)
JS_PSG
(
"
buffer
"
TypedArray_bufferGetter
0
)
JS_PSG
(
"
byteLength
"
TypedArray_byteLengthGetter
0
)
JS_PSG
(
"
byteOffset
"
TypedArray_byteOffsetGetter
0
)
JS_SYM_GET
(
toStringTag
TypedArray_toStringTagGetter
0
)
JS_PS_END
}
;
template
<
typename
T
>
static
inline
bool
SetFromTypedArray
(
Handle
<
TypedArrayObject
*
>
target
Handle
<
TypedArrayObject
*
>
source
size_t
offset
)
{
if
(
target
-
>
isSharedMemory
(
)
|
|
source
-
>
isSharedMemory
(
)
)
{
return
ElementSpecific
<
T
SharedOps
>
:
:
setFromTypedArray
(
target
source
offset
)
;
}
return
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromTypedArray
(
target
source
offset
)
;
}
template
<
typename
T
>
static
inline
bool
SetFromNonTypedArray
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
target
HandleObject
source
size_t
len
size_t
offset
)
{
MOZ_ASSERT
(
!
source
-
>
is
<
TypedArrayObject
>
(
)
"
use
SetFromTypedArray
"
)
;
if
(
target
-
>
isSharedMemory
(
)
)
{
return
ElementSpecific
<
T
SharedOps
>
:
:
setFromNonTypedArray
(
cx
target
source
len
offset
)
;
}
return
ElementSpecific
<
T
UnsharedOps
>
:
:
setFromNonTypedArray
(
cx
target
source
len
offset
)
;
}
bool
TypedArrayObject
:
:
set_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
TypedArrayObject
:
:
is
(
args
.
thisv
(
)
)
)
;
Rooted
<
TypedArrayObject
*
>
target
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
double
targetOffset
=
0
;
if
(
args
.
length
(
)
>
1
)
{
if
(
!
ToInteger
(
cx
args
[
1
]
&
targetOffset
)
)
{
return
false
;
}
if
(
targetOffset
<
0
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
}
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
RootedObject
src
(
cx
ToObject
(
cx
args
.
get
(
0
)
)
)
;
if
(
!
src
)
{
return
false
;
}
Rooted
<
TypedArrayObject
*
>
srcTypedArray
(
cx
)
;
{
JSObject
*
obj
=
CheckedUnwrapStatic
(
src
)
;
if
(
!
obj
)
{
ReportAccessDenied
(
cx
)
;
return
false
;
}
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
srcTypedArray
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
}
}
if
(
srcTypedArray
)
{
if
(
srcTypedArray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
size_t
targetLength
=
target
-
>
length
(
)
.
get
(
)
;
if
(
targetOffset
>
targetLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
size_t
offset
=
size_t
(
targetOffset
)
;
if
(
srcTypedArray
-
>
length
(
)
.
get
(
)
>
targetLength
-
offset
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SOURCE_ARRAY_TOO_LONG
)
;
return
false
;
}
if
(
Scalar
:
:
isBigIntType
(
target
-
>
type
(
)
)
!
=
Scalar
:
:
isBigIntType
(
srcTypedArray
-
>
type
(
)
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_NOT_COMPATIBLE
srcTypedArray
-
>
getClass
(
)
-
>
name
target
-
>
getClass
(
)
-
>
name
)
;
return
false
;
}
switch
(
target
-
>
type
(
)
)
{
#
define
SET_FROM_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
if
(
!
SetFromTypedArray
<
T
>
(
target
srcTypedArray
offset
)
)
return
false
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
SET_FROM_TYPED_ARRAY
)
#
undef
SET_FROM_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
}
else
{
size_t
targetLength
=
target
-
>
length
(
)
.
get
(
)
;
uint32_t
srcLength
;
if
(
!
GetLengthProperty
(
cx
src
&
srcLength
)
)
{
return
false
;
}
if
(
targetOffset
>
targetLength
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_INDEX
)
;
return
false
;
}
size_t
offset
=
size_t
(
targetOffset
)
;
if
(
srcLength
>
targetLength
-
offset
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SOURCE_ARRAY_TOO_LONG
)
;
return
false
;
}
if
(
srcLength
>
0
)
{
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
RootedValue
v
(
cx
)
;
if
(
!
GetElement
(
cx
src
src
0
&
v
)
)
{
return
false
;
}
if
(
!
target
-
>
convertForSideEffect
(
cx
v
)
)
{
return
false
;
}
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
switch
(
target
-
>
type
(
)
)
{
#
define
SET_FROM_NON_TYPED_ARRAY
(
T
N
)
\
case
Scalar
:
:
N
:
\
if
(
!
SetFromNonTypedArray
<
T
>
(
cx
target
src
srcLength
offset
)
)
\
return
false
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
SET_FROM_NON_TYPED_ARRAY
)
#
undef
SET_FROM_NON_TYPED_ARRAY
default
:
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
if
(
target
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
TypedArrayObject
:
:
set
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
TypedArrayObject
:
:
set_impl
>
(
cx
args
)
;
}
bool
TypedArrayObject
:
:
copyWithin_impl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
TypedArrayObject
:
:
is
(
args
.
thisv
(
)
)
)
;
Rooted
<
TypedArrayObject
*
>
tarray
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
TypedArrayObject
>
(
)
)
;
if
(
tarray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
size_t
len
=
tarray
-
>
length
(
)
.
get
(
)
;
double
relativeTarget
;
if
(
!
ToInteger
(
cx
args
.
get
(
0
)
&
relativeTarget
)
)
{
return
false
;
}
uint64_t
to
;
if
(
relativeTarget
<
0
)
{
to
=
std
:
:
max
(
len
+
relativeTarget
0
.
0
)
;
}
else
{
to
=
std
:
:
min
(
relativeTarget
double
(
len
)
)
;
}
double
relativeStart
;
if
(
!
ToInteger
(
cx
args
.
get
(
1
)
&
relativeStart
)
)
{
return
false
;
}
uint64_t
from
;
if
(
relativeStart
<
0
)
{
from
=
std
:
:
max
(
len
+
relativeStart
0
.
0
)
;
}
else
{
from
=
std
:
:
min
(
relativeStart
double
(
len
)
)
;
}
double
relativeEnd
;
if
(
!
args
.
hasDefined
(
2
)
)
{
relativeEnd
=
len
;
}
else
{
if
(
!
ToInteger
(
cx
args
[
2
]
&
relativeEnd
)
)
{
return
false
;
}
}
uint64_t
final_
;
if
(
relativeEnd
<
0
)
{
final_
=
std
:
:
max
(
len
+
relativeEnd
0
.
0
)
;
}
else
{
final_
=
std
:
:
min
(
relativeEnd
double
(
len
)
)
;
}
MOZ_ASSERT
(
to
<
=
len
)
;
uint64_t
count
;
if
(
from
<
=
final_
)
{
count
=
std
:
:
min
(
final_
-
from
len
-
to
)
;
}
else
{
count
=
0
;
}
if
(
count
=
=
0
)
{
args
.
rval
(
)
.
setObject
(
*
tarray
)
;
return
true
;
}
if
(
tarray
-
>
hasDetachedBuffer
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TYPED_ARRAY_DETACHED
)
;
return
false
;
}
const
size_t
ElementShift
=
TypedArrayShift
(
tarray
-
>
type
(
)
)
;
MOZ_ASSERT
(
(
SIZE_MAX
>
>
ElementShift
)
>
to
)
;
size_t
byteDest
=
to
<
<
ElementShift
;
MOZ_ASSERT
(
(
SIZE_MAX
>
>
ElementShift
)
>
from
)
;
size_t
byteSrc
=
from
<
<
ElementShift
;
MOZ_ASSERT
(
(
SIZE_MAX
>
>
ElementShift
)
>
=
count
)
;
size_t
byteSize
=
count
<
<
ElementShift
;
#
ifdef
DEBUG
{
size_t
viewByteLength
=
tarray
-
>
byteLength
(
)
.
get
(
)
;
MOZ_ASSERT
(
byteSize
<
=
viewByteLength
)
;
MOZ_ASSERT
(
byteDest
<
viewByteLength
)
;
MOZ_ASSERT
(
byteSrc
<
viewByteLength
)
;
MOZ_ASSERT
(
byteDest
<
=
viewByteLength
-
byteSize
)
;
MOZ_ASSERT
(
byteSrc
<
=
viewByteLength
-
byteSize
)
;
}
#
endif
SharedMem
<
uint8_t
*
>
data
=
tarray
-
>
dataPointerEither
(
)
.
cast
<
uint8_t
*
>
(
)
;
if
(
tarray
-
>
isSharedMemory
(
)
)
{
jit
:
:
AtomicOperations
:
:
memmoveSafeWhenRacy
(
data
+
byteDest
data
+
byteSrc
byteSize
)
;
}
else
{
memmove
(
data
.
unwrapUnshared
(
)
+
byteDest
data
.
unwrapUnshared
(
)
+
byteSrc
byteSize
)
;
}
args
.
rval
(
)
.
setObject
(
*
tarray
)
;
return
true
;
}
bool
TypedArrayObject
:
:
copyWithin
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
TypedArrayObject
:
:
is
TypedArrayObject
:
:
copyWithin_impl
>
(
cx
args
)
;
}
const
JSFunctionSpec
TypedArrayObject
:
:
protoFunctions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
subarray
"
"
TypedArraySubarray
"
2
0
)
JS_FN
(
"
set
"
TypedArrayObject
:
:
set
1
0
)
JS_FN
(
"
copyWithin
"
TypedArrayObject
:
:
copyWithin
2
0
)
JS_SELF_HOSTED_FN
(
"
every
"
"
TypedArrayEvery
"
1
0
)
JS_SELF_HOSTED_FN
(
"
fill
"
"
TypedArrayFill
"
3
0
)
JS_SELF_HOSTED_FN
(
"
filter
"
"
TypedArrayFilter
"
1
0
)
JS_SELF_HOSTED_FN
(
"
find
"
"
TypedArrayFind
"
1
0
)
JS_SELF_HOSTED_FN
(
"
findIndex
"
"
TypedArrayFindIndex
"
1
0
)
JS_SELF_HOSTED_FN
(
"
forEach
"
"
TypedArrayForEach
"
1
0
)
JS_SELF_HOSTED_FN
(
"
indexOf
"
"
TypedArrayIndexOf
"
2
0
)
JS_SELF_HOSTED_FN
(
"
join
"
"
TypedArrayJoin
"
1
0
)
JS_SELF_HOSTED_FN
(
"
lastIndexOf
"
"
TypedArrayLastIndexOf
"
1
0
)
JS_SELF_HOSTED_FN
(
"
map
"
"
TypedArrayMap
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reduce
"
"
TypedArrayReduce
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reduceRight
"
"
TypedArrayReduceRight
"
1
0
)
JS_SELF_HOSTED_FN
(
"
reverse
"
"
TypedArrayReverse
"
0
0
)
JS_SELF_HOSTED_FN
(
"
slice
"
"
TypedArraySlice
"
2
0
)
JS_SELF_HOSTED_FN
(
"
some
"
"
TypedArraySome
"
1
0
)
JS_SELF_HOSTED_FN
(
"
sort
"
"
TypedArraySort
"
1
0
)
JS_SELF_HOSTED_FN
(
"
entries
"
"
TypedArrayEntries
"
0
0
)
JS_SELF_HOSTED_FN
(
"
keys
"
"
TypedArrayKeys
"
0
0
)
JS_SELF_HOSTED_FN
(
"
values
"
"
TypedArrayValues
"
0
0
)
JS_SELF_HOSTED_SYM_FN
(
iterator
"
TypedArrayValues
"
0
0
)
JS_SELF_HOSTED_FN
(
"
includes
"
"
TypedArrayIncludes
"
2
0
)
JS_SELF_HOSTED_FN
(
"
toString
"
"
ArrayToString
"
0
0
)
JS_SELF_HOSTED_FN
(
"
toLocaleString
"
"
TypedArrayToLocaleString
"
2
0
)
#
ifdef
NIGHTLY_BUILD
JS_SELF_HOSTED_FN
(
"
at
"
"
TypedArrayAt
"
1
0
)
#
endif
JS_FS_END
}
;
const
JSFunctionSpec
TypedArrayObject
:
:
staticFunctions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
from
"
"
TypedArrayStaticFrom
"
3
0
)
JS_SELF_HOSTED_FN
(
"
of
"
"
TypedArrayStaticOf
"
0
0
)
JS_FS_END
}
;
const
JSPropertySpec
TypedArrayObject
:
:
staticProperties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
TypedArraySpecies
"
0
)
JS_PS_END
}
;
static
JSObject
*
CreateSharedTypedArrayPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
GlobalObject
:
:
createBlankPrototype
(
cx
cx
-
>
global
(
)
&
TypedArrayObject
:
:
sharedTypedArrayPrototypeClass
)
;
}
static
const
ClassSpec
TypedArrayObjectSharedTypedArrayPrototypeClassSpec
=
{
GenericCreateConstructor
<
TypedArrayConstructor
0
gc
:
:
AllocKind
:
:
FUNCTION
>
CreateSharedTypedArrayPrototype
TypedArrayObject
:
:
staticFunctions
TypedArrayObject
:
:
staticProperties
TypedArrayObject
:
:
protoFunctions
TypedArrayObject
:
:
protoAccessors
nullptr
ClassSpec
:
:
DontDefineConstructor
}
;
const
JSClass
TypedArrayObject
:
:
sharedTypedArrayPrototypeClass
=
{
"
TypedArrayPrototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_TypedArray
)
JS_NULL_CLASS_OPS
&
TypedArrayObjectSharedTypedArrayPrototypeClassSpec
}
;
namespace
{
template
<
typename
NativeType
>
bool
TypedArrayObjectTemplate
<
NativeType
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
static_assert
(
sizeof
(
NativeType
)
<
4
"
this
method
must
only
handle
NativeType
values
that
are
"
"
always
exact
int32_t
values
"
)
;
*
vp
=
Int32Value
(
getIndex
(
tarray
index
)
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
int32_t
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
*
vp
=
Int32Value
(
getIndex
(
tarray
index
)
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
uint32_t
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
uint32_t
val
=
getIndex
(
tarray
index
)
;
*
vp
=
NumberValue
(
val
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
float
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
float
val
=
getIndex
(
tarray
index
)
;
double
dval
=
val
;
*
vp
=
JS
:
:
CanonicalizedDoubleValue
(
dval
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
double
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
double
val
=
getIndex
(
tarray
index
)
;
*
vp
=
JS
:
:
CanonicalizedDoubleValue
(
val
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
int64_t
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
return
false
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
uint64_t
>
:
:
getElementPure
(
TypedArrayObject
*
tarray
size_t
index
Value
*
vp
)
{
return
false
;
}
}
namespace
{
template
<
typename
NativeType
>
bool
TypedArrayObjectTemplate
<
NativeType
>
:
:
getElement
(
JSContext
*
cx
TypedArrayObject
*
tarray
size_t
index
MutableHandleValue
val
)
{
MOZ_ALWAYS_TRUE
(
getElementPure
(
tarray
index
val
.
address
(
)
)
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
int64_t
>
:
:
getElement
(
JSContext
*
cx
TypedArrayObject
*
tarray
size_t
index
MutableHandleValue
val
)
{
int64_t
n
=
getIndex
(
tarray
index
)
;
BigInt
*
res
=
BigInt
:
:
createFromInt64
(
cx
n
)
;
if
(
!
res
)
{
return
false
;
}
val
.
setBigInt
(
res
)
;
return
true
;
}
template
<
>
bool
TypedArrayObjectTemplate
<
uint64_t
>
:
:
getElement
(
JSContext
*
cx
TypedArrayObject
*
tarray
size_t
index
MutableHandleValue
val
)
{
uint64_t
n
=
getIndex
(
tarray
index
)
;
BigInt
*
res
=
BigInt
:
:
createFromUint64
(
cx
n
)
;
if
(
!
res
)
{
return
false
;
}
val
.
setBigInt
(
res
)
;
return
true
;
}
}
namespace
js
{
template
<
>
bool
TypedArrayObject
:
:
getElement
<
CanGC
>
(
JSContext
*
cx
size_t
index
MutableHandleValue
val
)
{
switch
(
type
(
)
)
{
#
define
GET_ELEMENT
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
N
#
#
Array
:
:
getElement
(
cx
this
index
val
)
;
JS_FOR_EACH_TYPED_ARRAY
(
GET_ELEMENT
)
#
undef
GET_ELEMENT
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
template
<
>
bool
TypedArrayObject
:
:
getElement
<
NoGC
>
(
JSContext
*
cx
size_t
index
typename
MaybeRooted
<
Value
NoGC
>
:
:
MutableHandleType
vp
)
{
return
getElementPure
(
index
vp
.
address
(
)
)
;
}
}
bool
TypedArrayObject
:
:
getElementPure
(
size_t
index
Value
*
vp
)
{
switch
(
type
(
)
)
{
#
define
GET_ELEMENT_PURE
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
N
#
#
Array
:
:
getElementPure
(
this
index
vp
)
;
JS_FOR_EACH_TYPED_ARRAY
(
GET_ELEMENT_PURE
)
#
undef
GET_ELEMENT
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
bool
TypedArrayObject
:
:
getElements
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
tarray
Value
*
vp
)
{
size_t
length
=
tarray
-
>
length
(
)
.
get
(
)
;
MOZ_ASSERT_IF
(
length
>
0
!
tarray
-
>
hasDetachedBuffer
(
)
)
;
switch
(
tarray
-
>
type
(
)
)
{
#
define
GET_ELEMENTS
(
T
N
)
\
case
Scalar
:
:
N
:
\
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
+
+
vp
)
{
\
if
(
!
N
#
#
Array
:
:
getElement
(
cx
tarray
i
\
MutableHandleValue
:
:
fromMarkedLocation
(
vp
)
)
)
{
\
return
false
;
\
}
\
}
\
return
true
;
JS_FOR_EACH_TYPED_ARRAY
(
GET_ELEMENTS
)
#
undef
GET_ELEMENTS
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unknown
TypedArray
type
"
)
;
}
static
const
JSClassOps
TypedArrayClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
TypedArrayObject
:
:
finalize
nullptr
nullptr
nullptr
ArrayBufferViewObject
:
:
trace
}
;
static
const
ClassExtension
TypedArrayClassExtension
=
{
TypedArrayObject
:
:
objectMoved
}
;
static
const
JSPropertySpec
static_prototype_properties
[
Scalar
:
:
MaxTypedArrayViewType
]
[
2
]
=
{
#
define
IMPL_TYPED_ARRAY_PROPERTIES
(
NativeType
Name
)
\
{
JS_INT32_PS
(
"
BYTES_PER_ELEMENT
"
Name
#
#
Array
:
:
BYTES_PER_ELEMENT
\
JSPROP_READONLY
|
JSPROP_PERMANENT
)
\
JS_PS_END
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_PROPERTIES
)
#
undef
IMPL_TYPED_ARRAY_PROPERTIES
}
;
static
const
ClassSpec
TypedArrayObjectClassSpecs
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_CLASS_SPEC
(
NativeType
Name
)
\
{
Name
#
#
Array
:
:
createConstructor
\
Name
#
#
Array
:
:
createPrototype
\
nullptr
\
static_prototype_properties
[
Scalar
:
:
Type
:
:
Name
]
\
nullptr
\
static_prototype_properties
[
Scalar
:
:
Type
:
:
Name
]
\
nullptr
\
JSProto_TypedArray
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_CLASS_SPEC
)
#
undef
IMPL_TYPED_ARRAY_CLASS_SPEC
}
;
const
JSClass
TypedArrayObject
:
:
classes
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_CLASS
(
NativeType
Name
)
\
{
#
Name
"
Array
"
\
JSCLASS_HAS_RESERVED_SLOTS
(
TypedArrayObject
:
:
RESERVED_SLOTS
)
|
\
JSCLASS_HAS_PRIVATE
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
Name
#
#
Array
)
|
\
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_SKIP_NURSERY_FINALIZE
|
\
JSCLASS_BACKGROUND_FINALIZE
\
&
TypedArrayClassOps
&
TypedArrayObjectClassSpecs
[
Scalar
:
:
Type
:
:
Name
]
\
&
TypedArrayClassExtension
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_CLASS
)
#
undef
IMPL_TYPED_ARRAY_CLASS
}
;
const
JSClass
TypedArrayObject
:
:
protoClasses
[
Scalar
:
:
MaxTypedArrayViewType
]
=
{
#
define
IMPL_TYPED_ARRAY_PROTO_CLASS
(
NativeType
Name
)
\
{
#
Name
"
Array
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_
#
#
Name
#
#
Array
)
\
JS_NULL_CLASS_OPS
&
TypedArrayObjectClassSpecs
[
Scalar
:
:
Type
:
:
Name
]
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_PROTO_CLASS
)
#
undef
IMPL_TYPED_ARRAY_PROTO_CLASS
}
;
bool
TypedArrayObject
:
:
isOriginalLengthGetter
(
Native
native
)
{
return
native
=
=
TypedArray_lengthGetter
;
}
bool
TypedArrayObject
:
:
isOriginalByteOffsetGetter
(
Native
native
)
{
return
native
=
=
TypedArray_byteOffsetGetter
;
}
bool
js
:
:
IsTypedArrayConstructor
(
const
JSObject
*
obj
)
{
#
define
CHECK_TYPED_ARRAY_CONSTRUCTOR
(
T
N
)
\
if
(
IsNativeFunction
(
obj
N
#
#
Array
:
:
class_constructor
)
)
{
\
return
true
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
CHECK_TYPED_ARRAY_CONSTRUCTOR
)
#
undef
CHECK_TYPED_ARRAY_CONSTRUCTOR
return
false
;
}
bool
js
:
:
IsTypedArrayConstructor
(
HandleValue
v
Scalar
:
:
Type
type
)
{
return
IsNativeFunction
(
v
TypedArrayConstructorNative
(
type
)
)
;
}
JSNative
js
:
:
TypedArrayConstructorNative
(
Scalar
:
:
Type
type
)
{
#
define
TYPED_ARRAY_CONSTRUCTOR_NATIVE
(
T
N
)
\
if
(
type
=
=
Scalar
:
:
N
)
{
\
return
N
#
#
Array
:
:
class_constructor
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
TYPED_ARRAY_CONSTRUCTOR_NATIVE
)
#
undef
TYPED_ARRAY_CONSTRUCTOR_NATIVE
MOZ_CRASH
(
"
unexpected
typed
array
type
"
)
;
}
bool
js
:
:
IsBufferSource
(
JSObject
*
object
SharedMem
<
uint8_t
*
>
*
dataPointer
size_t
*
byteLength
)
{
if
(
object
-
>
is
<
TypedArrayObject
>
(
)
)
{
TypedArrayObject
&
view
=
object
-
>
as
<
TypedArrayObject
>
(
)
;
*
dataPointer
=
view
.
dataPointerEither
(
)
.
cast
<
uint8_t
*
>
(
)
;
*
byteLength
=
view
.
byteLength
(
)
.
get
(
)
;
return
true
;
}
if
(
object
-
>
is
<
DataViewObject
>
(
)
)
{
DataViewObject
&
view
=
object
-
>
as
<
DataViewObject
>
(
)
;
*
dataPointer
=
view
.
dataPointerEither
(
)
.
cast
<
uint8_t
*
>
(
)
;
*
byteLength
=
view
.
byteLength
(
)
.
get
(
)
;
return
true
;
}
if
(
object
-
>
is
<
ArrayBufferObject
>
(
)
)
{
ArrayBufferObject
&
buffer
=
object
-
>
as
<
ArrayBufferObject
>
(
)
;
*
dataPointer
=
buffer
.
dataPointerShared
(
)
;
*
byteLength
=
buffer
.
byteLength
(
)
.
get
(
)
;
return
true
;
}
if
(
object
-
>
is
<
SharedArrayBufferObject
>
(
)
)
{
SharedArrayBufferObject
&
buffer
=
object
-
>
as
<
SharedArrayBufferObject
>
(
)
;
*
dataPointer
=
buffer
.
dataPointerShared
(
)
;
*
byteLength
=
buffer
.
byteLength
(
)
.
get
(
)
;
return
true
;
}
return
false
;
}
template
<
typename
CharT
>
struct
CompareStringInfinityOrNaN
;
template
<
>
struct
CompareStringInfinityOrNaN
<
Latin1Char
>
{
using
CharTraitT
=
char
;
static
const
char
Infinity
[
]
;
static
const
char
NaN
[
]
;
}
;
template
<
>
struct
CompareStringInfinityOrNaN
<
char16_t
>
{
using
CharTraitT
=
char16_t
;
static
const
char16_t
Infinity
[
]
;
static
const
char16_t
NaN
[
]
;
}
;
const
char
CompareStringInfinityOrNaN
<
Latin1Char
>
:
:
Infinity
[
]
=
"
Infinity
"
;
const
char
CompareStringInfinityOrNaN
<
Latin1Char
>
:
:
NaN
[
]
=
"
NaN
"
;
const
char16_t
CompareStringInfinityOrNaN
<
char16_t
>
:
:
Infinity
[
]
=
u
"
Infinity
"
;
const
char16_t
CompareStringInfinityOrNaN
<
char16_t
>
:
:
NaN
[
]
=
u
"
NaN
"
;
template
<
typename
CharT
>
static
inline
bool
StringIsInfinity
(
mozilla
:
:
Range
<
const
CharT
>
s
)
{
using
CharTraitT
=
typename
CompareStringInfinityOrNaN
<
CharT
>
:
:
CharTraitT
;
constexpr
auto
Infinity
=
CompareStringInfinityOrNaN
<
CharT
>
:
:
Infinity
;
size_t
length
=
std
:
:
char_traits
<
CharTraitT
>
:
:
length
(
Infinity
)
;
return
s
.
length
(
)
=
=
length
&
&
!
std
:
:
char_traits
<
CharTraitT
>
:
:
compare
(
reinterpret_cast
<
const
CharTraitT
*
>
(
s
.
begin
(
)
.
get
(
)
)
Infinity
length
)
;
}
template
<
typename
CharT
>
static
inline
bool
StringIsNaN
(
mozilla
:
:
Range
<
const
CharT
>
s
)
{
using
CharTraitT
=
typename
CompareStringInfinityOrNaN
<
CharT
>
:
:
CharTraitT
;
constexpr
auto
NaN
=
CompareStringInfinityOrNaN
<
CharT
>
:
:
NaN
;
size_t
length
=
std
:
:
char_traits
<
CharTraitT
>
:
:
length
(
NaN
)
;
return
s
.
length
(
)
=
=
length
&
&
!
std
:
:
char_traits
<
CharTraitT
>
:
:
compare
(
reinterpret_cast
<
const
CharTraitT
*
>
(
s
.
begin
(
)
.
get
(
)
)
NaN
length
)
;
}
template
<
typename
CharT
>
static
JS
:
:
Result
<
mozilla
:
:
Maybe
<
uint64_t
>
>
StringIsTypedArrayIndexSlow
(
JSContext
*
cx
mozilla
:
:
Range
<
const
CharT
>
s
)
{
using
ResultType
=
decltype
(
StringIsTypedArrayIndexSlow
(
cx
s
)
)
;
const
mozilla
:
:
RangedPtr
<
const
CharT
>
start
=
s
.
begin
(
)
;
const
mozilla
:
:
RangedPtr
<
const
CharT
>
end
=
s
.
end
(
)
;
const
CharT
*
actualEnd
;
double
result
;
if
(
!
js_strtod
(
cx
start
.
get
(
)
end
.
get
(
)
&
actualEnd
&
result
)
)
{
return
cx
-
>
alreadyReportedOOM
(
)
;
}
if
(
actualEnd
!
=
end
.
get
(
)
)
{
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
ToCStringBuf
cbuf
;
const
char
*
cstr
=
js
:
:
NumberToCString
(
cx
&
cbuf
result
)
;
if
(
!
cstr
)
{
return
ReportOutOfMemoryResult
(
cx
)
;
}
if
(
s
.
length
(
)
!
=
strlen
(
cstr
)
|
|
!
EqualChars
(
start
.
get
(
)
cstr
s
.
length
(
)
)
)
{
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
if
(
result
<
0
|
|
!
IsInteger
(
result
)
)
{
return
mozilla
:
:
Some
(
UINT64_MAX
)
;
}
if
(
result
>
=
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
{
return
mozilla
:
:
Some
(
UINT64_MAX
)
;
}
return
mozilla
:
:
Some
(
uint64_t
(
result
)
)
;
}
template
<
typename
CharT
>
JS
:
:
Result
<
mozilla
:
:
Maybe
<
uint64_t
>
>
js
:
:
StringIsTypedArrayIndex
(
JSContext
*
cx
mozilla
:
:
Range
<
const
CharT
>
s
)
{
using
ResultType
=
decltype
(
StringIsTypedArrayIndex
(
cx
s
)
)
;
mozilla
:
:
RangedPtr
<
const
CharT
>
cp
=
s
.
begin
(
)
;
const
mozilla
:
:
RangedPtr
<
const
CharT
>
end
=
s
.
end
(
)
;
MOZ_ASSERT
(
cp
<
end
"
caller
must
check
for
empty
strings
"
)
;
bool
negative
=
false
;
if
(
*
cp
=
=
'
-
'
)
{
negative
=
true
;
if
(
+
+
cp
=
=
end
)
{
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
}
if
(
!
IsAsciiDigit
(
*
cp
)
)
{
if
(
(
!
negative
&
&
StringIsNaN
<
CharT
>
(
{
cp
end
}
)
)
|
|
StringIsInfinity
<
CharT
>
(
{
cp
end
}
)
)
{
return
mozilla
:
:
Some
(
UINT64_MAX
)
;
}
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
uint32_t
digit
=
AsciiDigitToNumber
(
*
cp
+
+
)
;
if
(
digit
=
=
0
&
&
cp
!
=
end
)
{
if
(
*
cp
=
=
'
.
'
)
{
return
StringIsTypedArrayIndexSlow
(
cx
s
)
;
}
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
uint64_t
index
=
digit
;
for
(
;
cp
<
end
;
cp
+
+
)
{
if
(
!
IsAsciiDigit
(
*
cp
)
)
{
if
(
*
cp
=
=
'
.
'
|
|
*
cp
=
=
'
e
'
)
{
return
StringIsTypedArrayIndexSlow
(
cx
s
)
;
}
return
ResultType
(
mozilla
:
:
Nothing
(
)
)
;
}
digit
=
AsciiDigitToNumber
(
*
cp
)
;
static_assert
(
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
<
(
UINT64_MAX
-
10
)
/
10
"
2
^
53
is
way
below
UINT64_MAX
so
|
10
*
index
+
digit
|
can
'
t
overflow
"
)
;
index
=
10
*
index
+
digit
;
if
(
index
>
=
uint64_t
(
DOUBLE_INTEGRAL_PRECISION_LIMIT
)
)
{
return
StringIsTypedArrayIndexSlow
(
cx
s
)
;
}
}
if
(
negative
)
{
return
mozilla
:
:
Some
(
UINT64_MAX
)
;
}
return
mozilla
:
:
Some
(
index
)
;
}
template
JS
:
:
Result
<
mozilla
:
:
Maybe
<
uint64_t
>
>
js
:
:
StringIsTypedArrayIndex
(
JSContext
*
cx
mozilla
:
:
Range
<
const
char16_t
>
s
)
;
template
JS
:
:
Result
<
mozilla
:
:
Maybe
<
uint64_t
>
>
js
:
:
StringIsTypedArrayIndex
(
JSContext
*
cx
mozilla
:
:
Range
<
const
Latin1Char
>
s
)
;
bool
js
:
:
SetTypedArrayElement
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
obj
uint64_t
index
HandleValue
v
ObjectOpResult
&
result
)
{
TypedArrayObject
*
tobj
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
switch
(
tobj
-
>
type
(
)
)
{
#
define
SET_TYPED_ARRAY_ELEMENT
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
setElement
(
cx
obj
index
v
result
)
;
JS_FOR_EACH_TYPED_ARRAY
(
SET_TYPED_ARRAY_ELEMENT
)
#
undef
SET_TYPED_ARRAY_ELEMENT
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
bool
js
:
:
DefineTypedArrayElement
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
obj
uint64_t
index
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
{
if
(
index
>
=
obj
-
>
length
(
)
.
get
(
)
)
{
if
(
obj
-
>
hasDetachedBuffer
(
)
)
{
return
result
.
fail
(
JSMSG_TYPED_ARRAY_DETACHED
)
;
}
return
result
.
fail
(
JSMSG_DEFINE_BAD_INDEX
)
;
}
if
(
desc
.
isAccessorDescriptor
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasConfigurable
(
)
&
&
!
desc
.
configurable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasEnumerable
(
)
&
&
!
desc
.
enumerable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasWritable
(
)
&
&
!
desc
.
writable
(
)
)
{
return
result
.
fail
(
JSMSG_CANT_REDEFINE_PROP
)
;
}
if
(
desc
.
hasValue
(
)
)
{
switch
(
obj
-
>
type
(
)
)
{
#
define
DEFINE_TYPED_ARRAY_ELEMENT
(
T
N
)
\
case
Scalar
:
:
N
:
\
return
TypedArrayObjectTemplate
<
T
>
:
:
setElement
(
cx
obj
index
\
desc
.
value
(
)
result
)
;
JS_FOR_EACH_TYPED_ARRAY
(
DEFINE_TYPED_ARRAY_ELEMENT
)
#
undef
DEFINE_TYPED_ARRAY_ELEMENT
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
case
Scalar
:
:
Simd128
:
break
;
}
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
return
result
.
succeed
(
)
;
}
template
<
typename
NativeType
>
struct
ExternalTypeOf
{
using
Type
=
NativeType
;
}
;
template
<
>
struct
ExternalTypeOf
<
uint8_clamped
>
{
using
Type
=
uint8_t
;
}
;
#
define
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
(
NativeType
Name
)
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
Array
(
JSContext
*
cx
\
size_t
nelements
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromLength
(
cx
nelements
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayFromArray
(
JSContext
*
cx
\
HandleObject
other
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromArray
(
cx
other
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayWithBuffer
(
\
JSContext
*
cx
HandleObject
arrayBuffer
size_t
byteOffset
\
int64_t
length
)
{
\
return
TypedArrayObjectTemplate
<
NativeType
>
:
:
fromBuffer
(
\
cx
arrayBuffer
byteOffset
length
)
;
\
}
\
\
JS_FRIEND_API
JSObject
*
js
:
:
Unwrap
#
#
Name
#
#
Array
(
JSObject
*
obj
)
{
\
obj
=
obj
-
>
maybeUnwrapIf
<
TypedArrayObject
>
(
)
;
\
if
(
!
obj
)
{
\
return
nullptr
;
\
}
\
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
\
if
(
clasp
!
=
TypedArrayObjectTemplate
<
NativeType
>
:
:
instanceClass
(
)
)
{
\
return
nullptr
;
\
}
\
return
obj
;
\
}
\
\
JS_FRIEND_API
bool
JS_Is
#
#
Name
#
#
Array
(
JSObject
*
obj
)
{
\
return
js
:
:
Unwrap
#
#
Name
#
#
Array
(
obj
)
!
=
nullptr
;
\
}
\
\
const
JSClass
*
const
js
:
:
detail
:
:
Name
#
#
ArrayClassPtr
=
\
&
js
:
:
TypedArrayObject
:
:
classes
\
[
TypedArrayObjectTemplate
<
NativeType
>
:
:
ArrayTypeID
(
)
]
;
\
\
JS_FRIEND_API
JSObject
*
JS_GetObjectAs
#
#
Name
#
#
Array
(
\
JSObject
*
obj
size_t
*
length
bool
*
isShared
\
ExternalTypeOf
<
NativeType
>
:
:
Type
*
*
data
)
{
\
obj
=
js
:
:
Unwrap
#
#
Name
#
#
Array
(
obj
)
;
\
if
(
!
obj
)
{
\
return
nullptr
;
\
}
\
TypedArrayObject
*
tarr
=
&
obj
-
>
as
<
TypedArrayObject
>
(
)
;
\
*
length
=
tarr
-
>
length
(
)
.
get
(
)
;
\
*
isShared
=
tarr
-
>
isSharedMemory
(
)
;
\
*
data
=
static_cast
<
ExternalTypeOf
<
NativeType
>
:
:
Type
*
>
(
\
tarr
-
>
dataPointerEither
(
)
.
unwrap
(
\
/
*
safe
-
caller
sees
isShared
flag
*
/
)
)
;
\
return
obj
;
\
}
\
\
JS_FRIEND_API
ExternalTypeOf
<
NativeType
>
:
:
Type
*
JS_Get
#
#
Name
#
#
ArrayData
(
\
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
{
\
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
\
if
(
!
tarr
)
{
\
return
nullptr
;
\
}
\
MOZ_ASSERT
(
tarr
-
>
type
(
)
=
=
TypeIDOfType
<
NativeType
>
:
:
id
)
;
\
*
isSharedMemory
=
tarr
-
>
isSharedMemory
(
)
;
\
return
static_cast
<
ExternalTypeOf
<
NativeType
>
:
:
Type
*
>
(
\
tarr
-
>
dataPointerEither
(
)
.
unwrap
(
/
*
safe
-
caller
sees
isShared
*
/
)
)
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
)
#
undef
IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS
JS_FRIEND_API
bool
JS_IsTypedArrayObject
(
JSObject
*
obj
)
{
return
obj
-
>
canUnwrapAs
<
TypedArrayObject
>
(
)
;
}
JS_FRIEND_API
uint32_t
JS_GetTypedArrayLength
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
length
(
)
.
deprecatedGetUint32
(
)
;
}
JS_FRIEND_API
size_t
JS_GetTypedArrayByteOffset
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
byteOffset
(
)
.
get
(
)
;
}
JS_FRIEND_API
size_t
JS_GetTypedArrayByteLength
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
0
;
}
return
tarr
-
>
byteLength
(
)
.
get
(
)
;
}
JS_FRIEND_API
bool
JS_GetTypedArraySharedness
(
JSObject
*
obj
)
{
TypedArrayObject
*
tarr
=
obj
-
>
maybeUnwrapAs
<
TypedArrayObject
>
(
)
;
if
(
!
tarr
)
{
return
false
;
}
return
tarr
-
>
isSharedMemory
(
)
;
}
JS_FRIEND_API
js
:
:
Scalar
:
:
Type
JS_GetArrayBufferViewType
(
JSObject
*
obj
)
{
ArrayBufferViewObject
*
view
=
obj
-
>
maybeUnwrapAs
<
ArrayBufferViewObject
>
(
)
;
if
(
!
view
)
{
return
Scalar
:
:
MaxTypedArrayViewType
;
}
if
(
view
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
view
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
;
}
if
(
view
-
>
is
<
DataViewObject
>
(
)
)
{
return
Scalar
:
:
MaxTypedArrayViewType
;
}
MOZ_CRASH
(
"
invalid
ArrayBufferView
type
"
)
;
}
JS_FRIEND_API
size_t
JS_MaxMovableTypedArraySize
(
)
{
return
TypedArrayObject
:
:
INLINE_BUFFER_LIMIT
;
}
