#
ifndef
vm_Compartment_h
#
define
vm_Compartment_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
NurseryAwareHashMap
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
class
ObjectWrapperMap
{
static
const
size_t
InitialInnerMapSize
=
4
;
using
InnerMap
=
NurseryAwareHashMap
<
JSObject
*
JSObject
*
DefaultHasher
<
JSObject
*
>
ZoneAllocPolicy
>
;
using
OuterMap
=
GCHashMap
<
JS
:
:
Compartment
*
InnerMap
DefaultHasher
<
JS
:
:
Compartment
*
>
ZoneAllocPolicy
>
;
OuterMap
map
;
Zone
*
zone
;
public
:
class
Enum
{
Enum
(
const
Enum
&
)
=
delete
;
void
operator
=
(
const
Enum
&
)
=
delete
;
void
goToNext
(
)
{
if
(
outer
.
isNothing
(
)
)
{
return
;
}
for
(
;
!
outer
-
>
empty
(
)
;
outer
-
>
popFront
(
)
)
{
JS
:
:
Compartment
*
c
=
outer
-
>
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
c
)
;
if
(
filter
&
&
!
filter
-
>
match
(
c
)
)
{
continue
;
}
InnerMap
&
m
=
outer
-
>
front
(
)
.
value
(
)
;
if
(
!
m
.
empty
(
)
)
{
if
(
inner
.
isSome
(
)
)
{
inner
.
reset
(
)
;
}
inner
.
emplace
(
m
)
;
outer
-
>
popFront
(
)
;
return
;
}
}
}
mozilla
:
:
Maybe
<
OuterMap
:
:
Enum
>
outer
;
mozilla
:
:
Maybe
<
InnerMap
:
:
Enum
>
inner
;
const
CompartmentFilter
*
filter
;
public
:
explicit
Enum
(
ObjectWrapperMap
&
m
)
:
filter
(
nullptr
)
{
outer
.
emplace
(
m
.
map
)
;
goToNext
(
)
;
}
Enum
(
ObjectWrapperMap
&
m
const
CompartmentFilter
&
f
)
:
filter
(
&
f
)
{
outer
.
emplace
(
m
.
map
)
;
goToNext
(
)
;
}
Enum
(
ObjectWrapperMap
&
m
JS
:
:
Compartment
*
target
)
{
auto
p
=
m
.
map
.
lookup
(
target
)
;
if
(
p
)
{
inner
.
emplace
(
p
-
>
value
(
)
)
;
}
}
bool
empty
(
)
const
{
return
(
outer
.
isNothing
(
)
|
|
outer
-
>
empty
(
)
)
&
&
(
inner
.
isNothing
(
)
|
|
inner
-
>
empty
(
)
)
;
}
InnerMap
:
:
Entry
&
front
(
)
const
{
MOZ_ASSERT
(
inner
.
isSome
(
)
&
&
!
inner
-
>
empty
(
)
)
;
return
inner
-
>
front
(
)
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
if
(
!
inner
-
>
empty
(
)
)
{
inner
-
>
popFront
(
)
;
if
(
!
inner
-
>
empty
(
)
)
{
return
;
}
}
goToNext
(
)
;
}
void
removeFront
(
)
{
MOZ_ASSERT
(
inner
.
isSome
(
)
)
;
inner
-
>
removeFront
(
)
;
}
}
;
class
Ptr
:
public
InnerMap
:
:
Ptr
{
friend
class
ObjectWrapperMap
;
InnerMap
*
map
;
Ptr
(
)
:
InnerMap
:
:
Ptr
(
)
map
(
nullptr
)
{
}
Ptr
(
const
InnerMap
:
:
Ptr
&
p
InnerMap
&
m
)
:
InnerMap
:
:
Ptr
(
p
)
map
(
&
m
)
{
}
}
;
class
WrappedCompartmentEnum
{
OuterMap
:
:
Enum
iter
;
void
settle
(
)
{
while
(
!
iter
.
empty
(
)
&
&
iter
.
front
(
)
.
value
(
)
.
empty
(
)
)
{
iter
.
popFront
(
)
;
}
}
public
:
explicit
WrappedCompartmentEnum
(
ObjectWrapperMap
&
map
)
:
iter
(
map
.
map
)
{
settle
(
)
;
}
bool
empty
(
)
const
{
return
iter
.
empty
(
)
;
}
JS
:
:
Compartment
*
front
(
)
const
{
return
iter
.
front
(
)
.
key
(
)
;
}
operator
JS
:
:
Compartment
*
(
)
const
{
return
front
(
)
;
}
void
popFront
(
)
{
iter
.
popFront
(
)
;
settle
(
)
;
}
}
;
explicit
ObjectWrapperMap
(
Zone
*
zone
)
:
map
(
zone
)
zone
(
zone
)
{
}
ObjectWrapperMap
(
Zone
*
zone
size_t
aLen
)
:
map
(
zone
aLen
)
zone
(
zone
)
{
}
bool
empty
(
)
{
if
(
map
.
empty
(
)
)
{
return
true
;
}
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
!
e
.
front
(
)
.
value
(
)
.
empty
(
)
)
{
return
false
;
}
}
return
true
;
}
Ptr
lookup
(
JSObject
*
obj
)
const
{
auto
op
=
map
.
lookup
(
obj
-
>
compartment
(
)
)
;
if
(
op
)
{
auto
ip
=
op
-
>
value
(
)
.
lookup
(
obj
)
;
if
(
ip
)
{
return
Ptr
(
ip
op
-
>
value
(
)
)
;
}
}
return
Ptr
(
)
;
}
void
remove
(
Ptr
p
)
{
if
(
p
)
{
p
.
map
-
>
remove
(
p
)
;
}
}
MOZ_MUST_USE
bool
put
(
JSObject
*
key
JSObject
*
value
)
{
JS
:
:
Compartment
*
comp
=
key
-
>
compartment
(
)
;
auto
ptr
=
map
.
lookupForAdd
(
comp
)
;
if
(
!
ptr
)
{
InnerMap
m
(
zone
InitialInnerMapSize
)
;
if
(
!
map
.
add
(
ptr
comp
std
:
:
move
(
m
)
)
)
{
return
false
;
}
}
return
ptr
-
>
value
(
)
.
put
(
key
value
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
size
=
map
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
size
+
=
e
.
front
(
)
.
value
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
size
=
map
.
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
size
+
=
e
.
front
(
)
.
value
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
bool
hasNurseryAllocatedWrapperEntries
(
const
CompartmentFilter
&
f
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JS
:
:
Compartment
*
c
=
e
.
front
(
)
.
key
(
)
;
if
(
c
&
&
!
f
.
match
(
c
)
)
{
continue
;
}
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
if
(
m
.
hasNurseryEntries
(
)
)
{
return
true
;
}
}
return
false
;
}
void
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
m
.
sweepAfterMinorGC
(
trc
)
;
if
(
m
.
empty
(
)
)
{
e
.
removeFront
(
)
;
}
}
}
void
sweep
(
)
{
for
(
OuterMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
InnerMap
&
m
=
e
.
front
(
)
.
value
(
)
;
m
.
sweep
(
)
;
if
(
m
.
empty
(
)
)
{
e
.
removeFront
(
)
;
}
}
}
}
;
using
StringWrapperMap
=
NurseryAwareHashMap
<
JSString
*
JSString
*
DefaultHasher
<
JSString
*
>
ZoneAllocPolicy
>
;
}
class
JS
:
:
Compartment
{
JS
:
:
Zone
*
zone_
;
JSRuntime
*
runtime_
;
bool
invisibleToDebugger_
;
js
:
:
ObjectWrapperMap
crossCompartmentObjectWrappers
;
using
RealmVector
=
js
:
:
Vector
<
JS
:
:
Realm
*
1
js
:
:
ZoneAllocPolicy
>
;
RealmVector
realms_
;
public
:
JSObject
*
gcIncomingGrayPointers
=
nullptr
;
void
*
data
=
nullptr
;
struct
{
bool
scheduledForDestruction
=
false
;
bool
maybeAlive
=
true
;
bool
hasEnteredRealm
=
false
;
}
gcState
;
bool
nukedOutgoingWrappers
=
false
;
JS
:
:
Zone
*
zone
(
)
{
return
zone_
;
}
const
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
JSRuntime
*
runtimeFromMainThread
(
)
const
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
return
runtime_
;
}
bool
invisibleToDebugger
(
)
const
{
return
invisibleToDebugger_
;
}
RealmVector
&
realms
(
)
{
return
realms_
;
}
js
:
:
GlobalObject
&
firstGlobal
(
)
const
;
js
:
:
GlobalObject
&
globalForNewCCW
(
)
const
{
return
firstGlobal
(
)
;
}
void
assertNoCrossCompartmentWrappers
(
)
{
MOZ_ASSERT
(
crossCompartmentObjectWrappers
.
empty
(
)
)
;
}
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
compartmentObjects
size_t
*
crossCompartmentWrappersTables
size_t
*
compartmentsPrivateData
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkObjectWrappersAfterMovingGC
(
)
;
#
endif
private
:
bool
getNonWrapperObjectForCurrentCompartment
(
JSContext
*
cx
js
:
:
HandleObject
origObj
js
:
:
MutableHandleObject
obj
)
;
bool
getOrCreateWrapper
(
JSContext
*
cx
js
:
:
HandleObject
existing
js
:
:
MutableHandleObject
obj
)
;
public
:
explicit
Compartment
(
JS
:
:
Zone
*
zone
bool
invisibleToDebugger
)
;
void
destroy
(
JSFreeOp
*
fop
)
;
MOZ_MUST_USE
inline
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleValue
vp
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
js
:
:
MutableHandleString
strp
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
js
:
:
MutableHandle
<
JS
:
:
BigInt
*
>
bi
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandleObject
obj
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
;
MOZ_MUST_USE
bool
wrap
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
GCVector
<
JS
:
:
Value
>
>
vec
)
;
MOZ_MUST_USE
bool
rewrap
(
JSContext
*
cx
JS
:
:
MutableHandleObject
obj
JS
:
:
HandleObject
existing
)
;
MOZ_MUST_USE
bool
putWrapper
(
JSContext
*
cx
JSObject
*
wrapped
JSObject
*
wrapper
)
;
MOZ_MUST_USE
bool
putWrapper
(
JSContext
*
cx
JSString
*
wrapped
JSString
*
wrapper
)
;
js
:
:
ObjectWrapperMap
:
:
Ptr
lookupWrapper
(
JSObject
*
obj
)
const
{
return
crossCompartmentObjectWrappers
.
lookup
(
obj
)
;
}
inline
js
:
:
StringWrapperMap
:
:
Ptr
lookupWrapper
(
JSString
*
str
)
const
;
void
removeWrapper
(
js
:
:
ObjectWrapperMap
:
:
Ptr
p
)
{
crossCompartmentObjectWrappers
.
remove
(
p
)
;
}
bool
hasNurseryAllocatedObjectWrapperEntries
(
const
js
:
:
CompartmentFilter
&
f
)
{
return
crossCompartmentObjectWrappers
.
hasNurseryAllocatedWrapperEntries
(
f
)
;
}
struct
ObjectWrapperEnum
:
public
js
:
:
ObjectWrapperMap
:
:
Enum
{
explicit
ObjectWrapperEnum
(
Compartment
*
c
)
:
js
:
:
ObjectWrapperMap
:
:
Enum
(
c
-
>
crossCompartmentObjectWrappers
)
{
}
explicit
ObjectWrapperEnum
(
Compartment
*
c
const
js
:
:
CompartmentFilter
&
f
)
:
js
:
:
ObjectWrapperMap
:
:
Enum
(
c
-
>
crossCompartmentObjectWrappers
f
)
{
}
explicit
ObjectWrapperEnum
(
Compartment
*
c
Compartment
*
target
)
:
js
:
:
ObjectWrapperMap
:
:
Enum
(
c
-
>
crossCompartmentObjectWrappers
target
)
{
MOZ_ASSERT
(
target
)
;
}
}
;
struct
WrappedObjectCompartmentEnum
:
public
js
:
:
ObjectWrapperMap
:
:
WrappedCompartmentEnum
{
explicit
WrappedObjectCompartmentEnum
(
Compartment
*
c
)
:
js
:
:
ObjectWrapperMap
:
:
WrappedCompartmentEnum
(
c
-
>
crossCompartmentObjectWrappers
)
{
}
}
;
enum
EdgeSelector
{
AllEdges
NonGrayEdges
GrayEdges
}
;
void
traceWrapperTargetsInCollectedZones
(
JSTracer
*
trc
EdgeSelector
whichEdges
)
;
static
void
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
EdgeSelector
whichEdges
)
;
void
sweepRealms
(
JSFreeOp
*
fop
bool
keepAtleastOne
bool
destroyingRuntime
)
;
void
sweepAfterMinorGC
(
JSTracer
*
trc
)
;
void
sweepCrossCompartmentObjectWrappers
(
)
;
void
fixupCrossCompartmentObjectWrappersAfterMovingGC
(
JSTracer
*
trc
)
;
void
fixupAfterMovingGC
(
JSTracer
*
trc
)
;
MOZ_MUST_USE
bool
findSweepGroupEdges
(
)
;
}
;
namespace
js
{
template
<
typename
T
>
inline
void
SetMaybeAliveFlag
(
T
*
thing
)
{
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSObject
*
thing
)
{
thing
-
>
compartment
(
)
-
>
gcState
.
maybeAlive
=
true
;
}
template
<
>
inline
void
SetMaybeAliveFlag
(
JSScript
*
thing
)
{
thing
-
>
compartment
(
)
-
>
gcState
.
maybeAlive
=
true
;
}
struct
WrapperValue
{
explicit
WrapperValue
(
const
ObjectWrapperMap
:
:
Ptr
&
ptr
)
:
value
(
*
ptr
-
>
value
(
)
.
unsafeGet
(
)
)
{
}
explicit
WrapperValue
(
const
ObjectWrapperMap
:
:
Enum
&
e
)
:
value
(
*
e
.
front
(
)
.
value
(
)
.
unsafeGet
(
)
)
{
}
JSObject
*
&
get
(
)
{
return
value
;
}
JSObject
*
get
(
)
const
{
return
value
;
}
operator
JSObject
*
(
)
const
{
return
value
;
}
private
:
JSObject
*
value
;
}
;
class
MOZ_RAII
AutoWrapperVector
:
public
JS
:
:
GCVector
<
WrapperValue
8
>
private
JS
:
:
AutoGCRooter
{
public
:
explicit
AutoWrapperVector
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
GCVector
<
WrapperValue
8
>
(
cx
)
JS
:
:
AutoGCRooter
(
cx
JS
:
:
AutoGCRooter
:
:
Tag
:
:
WrapperVector
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
friend
void
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoWrapperRooter
:
private
JS
:
:
AutoGCRooter
{
public
:
AutoWrapperRooter
(
JSContext
*
cx
const
WrapperValue
&
v
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
AutoGCRooter
(
cx
JS
:
:
AutoGCRooter
:
:
Tag
:
:
Wrapper
)
value
(
v
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
operator
JSObject
*
(
)
const
{
return
value
;
}
friend
void
JS
:
:
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
private
:
WrapperValue
value
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
#
endif
