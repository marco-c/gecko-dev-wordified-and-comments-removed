#
include
"
vm
/
SharedArrayObject
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
static
uint64_t
SharedArrayMappedSize
(
uint32_t
allocSize
)
{
MOZ_RELEASE_ASSERT
(
sizeof
(
SharedArrayRawBuffer
)
<
gc
:
:
SystemPageSize
(
)
)
;
#
ifdef
WASM_HUGE_MEMORY
return
wasm
:
:
HugeMappedSize
+
gc
:
:
SystemPageSize
(
)
;
#
else
return
allocSize
+
wasm
:
:
GuardSize
;
#
endif
}
static
uint32_t
SharedArrayAllocSize
(
uint32_t
length
)
{
return
AlignBytes
(
length
+
gc
:
:
SystemPageSize
(
)
gc
:
:
SystemPageSize
(
)
)
;
}
SharedArrayRawBuffer
*
SharedArrayRawBuffer
:
:
New
(
JSContext
*
cx
uint32_t
length
)
{
MOZ_ASSERT
(
length
!
=
(
uint32_t
)
-
1
)
;
uint32_t
allocSize
=
SharedArrayAllocSize
(
length
)
;
if
(
allocSize
<
=
length
)
return
nullptr
;
bool
preparedForAsmJS
=
jit
:
:
JitOptions
.
asmJSAtomicsEnable
&
&
IsValidAsmJSHeapLength
(
length
)
;
void
*
p
=
nullptr
;
if
(
preparedForAsmJS
)
p
=
MapBufferMemory
(
SharedArrayMappedSize
(
allocSize
)
allocSize
)
;
else
p
=
MapBufferMemory
(
allocSize
allocSize
)
;
if
(
!
p
)
return
nullptr
;
uint8_t
*
buffer
=
reinterpret_cast
<
uint8_t
*
>
(
p
)
+
gc
:
:
SystemPageSize
(
)
;
uint8_t
*
base
=
buffer
-
sizeof
(
SharedArrayRawBuffer
)
;
SharedArrayRawBuffer
*
rawbuf
=
new
(
base
)
SharedArrayRawBuffer
(
buffer
length
preparedForAsmJS
)
;
MOZ_ASSERT
(
rawbuf
-
>
length
=
=
length
)
;
return
rawbuf
;
}
bool
SharedArrayRawBuffer
:
:
addReference
(
)
{
MOZ_RELEASE_ASSERT
(
this
-
>
refcount_
>
0
)
;
for
(
;
;
)
{
uint32_t
old_refcount
=
this
-
>
refcount_
;
uint32_t
new_refcount
=
old_refcount
+
1
;
if
(
new_refcount
=
=
0
)
return
false
;
if
(
this
-
>
refcount_
.
compareExchange
(
old_refcount
new_refcount
)
)
return
true
;
}
}
void
SharedArrayRawBuffer
:
:
dropReference
(
)
{
MOZ_RELEASE_ASSERT
(
this
-
>
refcount_
>
0
)
;
uint32_t
refcount
=
-
-
this
-
>
refcount_
;
if
(
refcount
)
return
;
SharedMem
<
uint8_t
*
>
p
=
this
-
>
dataPointerShared
(
)
-
gc
:
:
SystemPageSize
(
)
;
MOZ_ASSERT
(
p
.
asValue
(
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
uint8_t
*
address
=
p
.
unwrap
(
)
;
uint32_t
allocSize
=
SharedArrayAllocSize
(
this
-
>
length
)
;
if
(
this
-
>
preparedForAsmJS
)
UnmapBufferMemory
(
address
SharedArrayMappedSize
(
allocSize
)
)
;
else
UnmapBufferMemory
(
address
allocSize
)
;
}
MOZ_ALWAYS_INLINE
bool
SharedArrayBufferObject
:
:
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsSharedArrayBuffer
(
args
.
thisv
(
)
)
)
;
args
.
rval
(
)
.
setInt32
(
args
.
thisv
(
)
.
toObject
(
)
.
as
<
SharedArrayBufferObject
>
(
)
.
byteLength
(
)
)
;
return
true
;
}
bool
SharedArrayBufferObject
:
:
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsSharedArrayBuffer
byteLengthGetterImpl
>
(
cx
args
)
;
}
bool
SharedArrayBufferObject
:
:
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
SharedArrayBuffer
"
)
)
return
false
;
uint64_t
byteLength
;
if
(
!
ToIndex
(
cx
args
.
get
(
0
)
&
byteLength
)
)
return
false
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
&
proto
)
)
return
false
;
if
(
byteLength
>
INT32_MAX
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHARED_ARRAY_BAD_LENGTH
)
;
return
false
;
}
JSObject
*
bufobj
=
New
(
cx
uint32_t
(
byteLength
)
proto
)
;
if
(
!
bufobj
)
return
false
;
args
.
rval
(
)
.
setObject
(
*
bufobj
)
;
return
true
;
}
SharedArrayBufferObject
*
SharedArrayBufferObject
:
:
New
(
JSContext
*
cx
uint32_t
length
HandleObject
proto
)
{
SharedArrayRawBuffer
*
buffer
=
SharedArrayRawBuffer
:
:
New
(
cx
length
)
;
if
(
!
buffer
)
return
nullptr
;
return
New
(
cx
buffer
proto
)
;
}
SharedArrayBufferObject
*
SharedArrayBufferObject
:
:
New
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
HandleObject
proto
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
SharedArrayBufferObject
*
>
obj
(
cx
NewObjectWithClassProto
<
SharedArrayBufferObject
>
(
cx
proto
)
)
;
if
(
!
obj
)
return
nullptr
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
&
class_
)
;
obj
-
>
acceptRawBuffer
(
buffer
)
;
return
obj
;
}
void
SharedArrayBufferObject
:
:
acceptRawBuffer
(
SharedArrayRawBuffer
*
buffer
)
{
setReservedSlot
(
RAWBUF_SLOT
PrivateValue
(
buffer
)
)
;
}
void
SharedArrayBufferObject
:
:
dropRawBuffer
(
)
{
setReservedSlot
(
RAWBUF_SLOT
UndefinedValue
(
)
)
;
}
SharedArrayRawBuffer
*
SharedArrayBufferObject
:
:
rawBufferObject
(
)
const
{
Value
v
=
getReservedSlot
(
RAWBUF_SLOT
)
;
MOZ_ASSERT
(
!
v
.
isUndefined
(
)
)
;
return
reinterpret_cast
<
SharedArrayRawBuffer
*
>
(
v
.
toPrivate
(
)
)
;
}
void
SharedArrayBufferObject
:
:
Finalize
(
FreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
maybeOnHelperThread
(
)
)
;
SharedArrayBufferObject
&
buf
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
Value
v
=
buf
.
getReservedSlot
(
RAWBUF_SLOT
)
;
if
(
!
v
.
isUndefined
(
)
)
{
buf
.
rawBufferObject
(
)
-
>
dropReference
(
)
;
buf
.
dropRawBuffer
(
)
;
}
}
void
SharedArrayBufferObject
:
:
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
)
{
const
SharedArrayBufferObject
&
buf
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
info
-
>
objectsNonHeapElementsShared
+
=
buf
.
byteLength
(
)
/
buf
.
rawBufferObject
(
)
-
>
refcount
(
)
;
}
void
SharedArrayBufferObject
:
:
copyData
(
Handle
<
SharedArrayBufferObject
*
>
toBuffer
uint32_t
toIndex
Handle
<
SharedArrayBufferObject
*
>
fromBuffer
uint32_t
fromIndex
uint32_t
count
)
{
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
count
)
;
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
toIndex
+
count
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
+
count
)
;
jit
:
:
AtomicOperations
:
:
memcpySafeWhenRacy
(
toBuffer
-
>
dataPointerShared
(
)
+
toIndex
fromBuffer
-
>
dataPointerShared
(
)
+
fromIndex
count
)
;
}
static
JSObject
*
CreateSharedArrayBufferPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
return
GlobalObject
:
:
createBlankPrototype
(
cx
cx
-
>
global
(
)
&
SharedArrayBufferObject
:
:
protoClass_
)
;
}
static
const
ClassOps
SharedArrayBufferObjectClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
SharedArrayBufferObject
:
:
Finalize
nullptr
nullptr
nullptr
nullptr
}
;
static
const
JSFunctionSpec
static_functions
[
]
=
{
JS_FS_END
}
;
static
const
JSPropertySpec
static_properties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
SharedArrayBufferSpecies
"
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
prototype_functions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
slice
"
"
SharedArrayBufferSlice
"
2
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
prototype_properties
[
]
=
{
JS_PSG
(
"
byteLength
"
SharedArrayBufferObject
:
:
byteLengthGetter
0
)
JS_STRING_SYM_PS
(
toStringTag
"
SharedArrayBuffer
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
ClassSpec
SharedArrayBufferObjectClassSpec
=
{
GenericCreateConstructor
<
SharedArrayBufferObject
:
:
class_constructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
CreateSharedArrayBufferPrototype
static_functions
static_properties
prototype_functions
prototype_properties
}
;
const
Class
SharedArrayBufferObject
:
:
class_
=
{
"
SharedArrayBuffer
"
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_HAS_RESERVED_SLOTS
(
SharedArrayBufferObject
:
:
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_SharedArrayBuffer
)
|
JSCLASS_BACKGROUND_FINALIZE
&
SharedArrayBufferObjectClassOps
&
SharedArrayBufferObjectClassSpec
JS_NULL_CLASS_EXT
}
;
const
Class
SharedArrayBufferObject
:
:
protoClass_
=
{
"
SharedArrayBufferPrototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_SharedArrayBuffer
)
JS_NULL_CLASS_OPS
&
SharedArrayBufferObjectClassSpec
}
;
bool
js
:
:
IsSharedArrayBuffer
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
SharedArrayBufferObject
>
(
)
;
}
bool
js
:
:
IsSharedArrayBuffer
(
HandleObject
o
)
{
return
o
-
>
is
<
SharedArrayBufferObject
>
(
)
;
}
bool
js
:
:
IsSharedArrayBuffer
(
JSObject
*
o
)
{
return
o
-
>
is
<
SharedArrayBufferObject
>
(
)
;
}
SharedArrayBufferObject
&
js
:
:
AsSharedArrayBuffer
(
HandleObject
obj
)
{
MOZ_ASSERT
(
IsSharedArrayBuffer
(
obj
)
)
;
return
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
}
JS_FRIEND_API
(
uint32_t
)
JS_GetSharedArrayBufferByteLength
(
JSObject
*
obj
)
{
obj
=
CheckedUnwrap
(
obj
)
;
return
obj
?
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
byteLength
(
)
:
0
;
}
JS_FRIEND_API
(
void
)
js
:
:
GetSharedArrayBufferLengthAndData
(
JSObject
*
obj
uint32_t
*
length
bool
*
isSharedMemory
uint8_t
*
*
data
)
{
MOZ_ASSERT
(
obj
-
>
is
<
SharedArrayBufferObject
>
(
)
)
;
*
length
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
byteLength
(
)
;
*
data
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
dataPointerShared
(
)
.
unwrap
(
)
;
*
isSharedMemory
=
true
;
}
JS_FRIEND_API
(
JSObject
*
)
JS_NewSharedArrayBuffer
(
JSContext
*
cx
uint32_t
nbytes
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
;
MOZ_ASSERT
(
nbytes
<
=
INT32_MAX
)
;
return
SharedArrayBufferObject
:
:
New
(
cx
nbytes
nullptr
)
;
}
JS_FRIEND_API
(
bool
)
JS_IsSharedArrayBufferObject
(
JSObject
*
obj
)
{
obj
=
CheckedUnwrap
(
obj
)
;
return
obj
?
obj
-
>
is
<
SharedArrayBufferObject
>
(
)
:
false
;
}
JS_FRIEND_API
(
uint8_t
*
)
JS_GetSharedArrayBufferData
(
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
{
obj
=
CheckedUnwrap
(
obj
)
;
if
(
!
obj
)
return
nullptr
;
*
isSharedMemory
=
true
;
return
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
dataPointerShared
(
)
.
unwrap
(
)
;
}
