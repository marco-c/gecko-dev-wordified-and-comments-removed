#
include
"
vm
/
SharedArrayObject
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
SharedArrayBuffer
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
js
:
:
wasm
:
:
Pages
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
namespace
js
;
static
size_t
SharedArrayAccessibleSize
(
size_t
length
)
{
return
AlignBytes
(
length
gc
:
:
SystemPageSize
(
)
)
;
}
static
size_t
SharedArrayMappedSize
(
size_t
length
)
{
return
SharedArrayAccessibleSize
(
length
)
+
gc
:
:
SystemPageSize
(
)
;
}
SharedArrayRawBuffer
*
SharedArrayRawBuffer
:
:
AllocateInternal
(
wasm
:
:
IndexType
wasmIndexType
size_t
length
const
Maybe
<
wasm
:
:
Pages
>
&
wasmClampedMaxPages
const
Maybe
<
wasm
:
:
Pages
>
&
wasmSourceMaxPages
const
Maybe
<
size_t
>
&
wasmMappedSize
)
{
MOZ_RELEASE_ASSERT
(
length
<
=
ArrayBufferObject
:
:
maxBufferByteLength
(
)
)
;
size_t
accessibleSize
=
SharedArrayAccessibleSize
(
length
)
;
if
(
accessibleSize
<
length
)
{
return
nullptr
;
}
bool
preparedForWasm
=
wasmClampedMaxPages
.
isSome
(
)
;
size_t
computedMappedSize
;
if
(
preparedForWasm
)
{
computedMappedSize
=
wasmMappedSize
.
isSome
(
)
?
*
wasmMappedSize
:
wasm
:
:
ComputeMappedSize
(
*
wasmClampedMaxPages
)
;
}
else
{
MOZ_ASSERT
(
wasmMappedSize
.
isNothing
(
)
)
;
computedMappedSize
=
accessibleSize
;
}
MOZ_ASSERT
(
accessibleSize
<
=
computedMappedSize
)
;
uint64_t
mappedSizeWithHeader
=
computedMappedSize
+
gc
:
:
SystemPageSize
(
)
;
uint64_t
accessibleSizeWithHeader
=
accessibleSize
+
gc
:
:
SystemPageSize
(
)
;
void
*
p
=
MapBufferMemory
(
mappedSizeWithHeader
accessibleSizeWithHeader
)
;
if
(
!
p
)
{
return
nullptr
;
}
uint8_t
*
buffer
=
reinterpret_cast
<
uint8_t
*
>
(
p
)
+
gc
:
:
SystemPageSize
(
)
;
uint8_t
*
base
=
buffer
-
sizeof
(
SharedArrayRawBuffer
)
;
SharedArrayRawBuffer
*
rawbuf
=
new
(
base
)
SharedArrayRawBuffer
(
wasmIndexType
buffer
length
wasmClampedMaxPages
.
valueOr
(
Pages
(
0
)
)
wasmSourceMaxPages
.
valueOr
(
Pages
(
0
)
)
computedMappedSize
preparedForWasm
)
;
MOZ_ASSERT
(
rawbuf
-
>
length_
=
=
length
)
;
return
rawbuf
;
}
SharedArrayRawBuffer
*
SharedArrayRawBuffer
:
:
Allocate
(
size_t
length
)
{
return
SharedArrayRawBuffer
:
:
AllocateInternal
(
wasm
:
:
IndexType
:
:
I32
length
Nothing
(
)
Nothing
(
)
Nothing
(
)
)
;
}
SharedArrayRawBuffer
*
SharedArrayRawBuffer
:
:
AllocateWasm
(
wasm
:
:
IndexType
indexType
Pages
initialPages
wasm
:
:
Pages
clampedMaxPages
const
mozilla
:
:
Maybe
<
wasm
:
:
Pages
>
&
sourceMaxPages
const
mozilla
:
:
Maybe
<
size_t
>
&
mappedSize
)
{
MOZ_ASSERT
(
initialPages
.
hasByteLength
(
)
)
;
size_t
length
=
initialPages
.
byteLength
(
)
;
return
SharedArrayRawBuffer
:
:
AllocateInternal
(
indexType
length
Some
(
clampedMaxPages
)
sourceMaxPages
mappedSize
)
;
}
void
SharedArrayRawBuffer
:
:
tryGrowMaxPagesInPlace
(
Pages
deltaMaxPages
)
{
Pages
newMaxPages
=
wasmClampedMaxPages_
;
DebugOnly
<
bool
>
valid
=
newMaxPages
.
checkedIncrement
(
deltaMaxPages
)
;
MOZ_ASSERT
(
valid
)
;
MOZ_ASSERT
(
newMaxPages
<
=
wasmSourceMaxPages_
)
;
size_t
newMappedSize
=
wasm
:
:
ComputeMappedSize
(
newMaxPages
)
;
MOZ_ASSERT
(
mappedSize_
<
=
newMappedSize
)
;
if
(
mappedSize_
=
=
newMappedSize
)
{
return
;
}
if
(
!
ExtendBufferMapping
(
basePointer
(
)
mappedSize_
newMappedSize
)
)
{
return
;
}
mappedSize_
=
newMappedSize
;
wasmClampedMaxPages_
=
newMaxPages
;
}
bool
SharedArrayRawBuffer
:
:
wasmGrowToPagesInPlace
(
const
Lock
&
wasm
:
:
Pages
newPages
)
{
if
(
newPages
>
wasmClampedMaxPages_
)
{
return
false
;
}
MOZ_ASSERT
(
newPages
<
=
wasm
:
:
MaxMemoryPages
(
)
&
&
newPages
.
byteLength
(
)
<
ArrayBufferObject
:
:
maxBufferByteLength
(
)
)
;
size_t
newLength
=
newPages
.
byteLength
(
)
;
MOZ_ASSERT
(
newLength
>
=
length_
)
;
if
(
newLength
=
=
length_
)
{
return
true
;
}
size_t
delta
=
newLength
-
length_
;
MOZ_ASSERT
(
delta
%
wasm
:
:
PageSize
=
=
0
)
;
uint8_t
*
dataEnd
=
dataPointerShared
(
)
.
unwrap
(
)
+
length_
;
MOZ_ASSERT
(
uintptr_t
(
dataEnd
)
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
if
(
!
CommitBufferMemory
(
dataEnd
delta
)
)
{
return
false
;
}
length_
=
newLength
;
return
true
;
}
bool
SharedArrayRawBuffer
:
:
addReference
(
)
{
MOZ_RELEASE_ASSERT
(
refcount_
>
0
)
;
for
(
;
;
)
{
uint32_t
old_refcount
=
refcount_
;
uint32_t
new_refcount
=
old_refcount
+
1
;
if
(
new_refcount
=
=
0
)
{
return
false
;
}
if
(
refcount_
.
compareExchange
(
old_refcount
new_refcount
)
)
{
return
true
;
}
}
}
void
SharedArrayRawBuffer
:
:
dropReference
(
)
{
MOZ_RELEASE_ASSERT
(
refcount_
>
0
)
;
uint32_t
new_refcount
=
-
-
refcount_
;
if
(
new_refcount
)
{
return
;
}
size_t
mappedSizeWithHeader
=
mappedSize_
+
gc
:
:
SystemPageSize
(
)
;
UnmapBufferMemory
(
basePointer
(
)
mappedSizeWithHeader
)
;
}
static
bool
IsSharedArrayBuffer
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
SharedArrayBufferObject
>
(
)
;
}
MOZ_ALWAYS_INLINE
bool
SharedArrayBufferObject
:
:
byteLengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsSharedArrayBuffer
(
args
.
thisv
(
)
)
)
;
auto
*
buffer
=
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
SharedArrayBufferObject
>
(
)
;
args
.
rval
(
)
.
setNumber
(
buffer
-
>
byteLength
(
)
)
;
return
true
;
}
bool
SharedArrayBufferObject
:
:
byteLengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsSharedArrayBuffer
byteLengthGetterImpl
>
(
cx
args
)
;
}
bool
SharedArrayBufferObject
:
:
class_constructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
ThrowIfNotConstructing
(
cx
args
"
SharedArrayBuffer
"
)
)
{
return
false
;
}
uint64_t
byteLength
;
if
(
!
ToIndex
(
cx
args
.
get
(
0
)
&
byteLength
)
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_SharedArrayBuffer
&
proto
)
)
{
return
false
;
}
if
(
byteLength
>
ArrayBufferObject
:
:
maxBufferByteLength
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHARED_ARRAY_BAD_LENGTH
)
;
return
false
;
}
JSObject
*
bufobj
=
New
(
cx
byteLength
proto
)
;
if
(
!
bufobj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
bufobj
)
;
return
true
;
}
SharedArrayBufferObject
*
SharedArrayBufferObject
:
:
New
(
JSContext
*
cx
size_t
length
HandleObject
proto
)
{
SharedArrayRawBuffer
*
buffer
=
SharedArrayRawBuffer
:
:
Allocate
(
length
)
;
if
(
!
buffer
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
SharedArrayBufferObject
*
obj
=
New
(
cx
buffer
length
proto
)
;
if
(
!
obj
)
{
buffer
-
>
dropReference
(
)
;
return
nullptr
;
}
return
obj
;
}
SharedArrayBufferObject
*
SharedArrayBufferObject
:
:
New
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
size_t
length
HandleObject
proto
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
Rooted
<
SharedArrayBufferObject
*
>
obj
(
cx
NewObjectWithClassProto
<
SharedArrayBufferObject
>
(
cx
proto
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
&
class_
)
;
cx
-
>
runtime
(
)
-
>
incSABCount
(
)
;
if
(
!
obj
-
>
acceptRawBuffer
(
buffer
length
)
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
obj
;
}
bool
SharedArrayBufferObject
:
:
acceptRawBuffer
(
SharedArrayRawBuffer
*
buffer
size_t
length
)
{
if
(
!
zone
(
)
-
>
addSharedMemory
(
buffer
SharedArrayMappedSize
(
length
)
MemoryUse
:
:
SharedArrayRawBuffer
)
)
{
return
false
;
}
setFixedSlot
(
RAWBUF_SLOT
PrivateValue
(
buffer
)
)
;
setFixedSlot
(
LENGTH_SLOT
PrivateValue
(
length
)
)
;
return
true
;
}
void
SharedArrayBufferObject
:
:
dropRawBuffer
(
)
{
size_t
size
=
SharedArrayMappedSize
(
byteLength
(
)
)
;
zoneFromAnyThread
(
)
-
>
removeSharedMemory
(
rawBufferObject
(
)
size
MemoryUse
:
:
SharedArrayRawBuffer
)
;
setFixedSlot
(
RAWBUF_SLOT
UndefinedValue
(
)
)
;
}
SharedArrayRawBuffer
*
SharedArrayBufferObject
:
:
rawBufferObject
(
)
const
{
Value
v
=
getFixedSlot
(
RAWBUF_SLOT
)
;
MOZ_ASSERT
(
!
v
.
isUndefined
(
)
)
;
return
reinterpret_cast
<
SharedArrayRawBuffer
*
>
(
v
.
toPrivate
(
)
)
;
}
void
SharedArrayBufferObject
:
:
Finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
{
MOZ_ASSERT
(
fop
-
>
onMainThread
(
)
)
;
fop
-
>
runtime
(
)
-
>
decSABCount
(
)
;
SharedArrayBufferObject
&
buf
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
Value
v
=
buf
.
getFixedSlot
(
RAWBUF_SLOT
)
;
if
(
!
v
.
isUndefined
(
)
)
{
buf
.
rawBufferObject
(
)
-
>
dropReference
(
)
;
buf
.
dropRawBuffer
(
)
;
}
}
void
SharedArrayBufferObject
:
:
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
{
const
SharedArrayBufferObject
&
buf
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
;
size_t
owned
=
buf
.
byteLength
(
)
/
buf
.
rawBufferObject
(
)
-
>
refcount
(
)
;
if
(
buf
.
isWasm
(
)
)
{
info
-
>
objectsNonHeapElementsWasmShared
+
=
owned
;
if
(
runtimeSizes
)
{
size_t
ownedGuardPages
=
(
buf
.
wasmMappedSize
(
)
-
buf
.
byteLength
(
)
)
/
buf
.
rawBufferObject
(
)
-
>
refcount
(
)
;
runtimeSizes
-
>
wasmGuardPages
+
=
ownedGuardPages
;
}
}
else
{
info
-
>
objectsNonHeapElementsShared
+
=
owned
;
}
}
void
SharedArrayBufferObject
:
:
copyData
(
Handle
<
SharedArrayBufferObject
*
>
toBuffer
size_t
toIndex
Handle
<
SharedArrayBufferObject
*
>
fromBuffer
size_t
fromIndex
size_t
count
)
{
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
count
)
;
MOZ_ASSERT
(
toBuffer
-
>
byteLength
(
)
>
=
toIndex
+
count
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
)
;
MOZ_ASSERT
(
fromBuffer
-
>
byteLength
(
)
>
=
fromIndex
+
count
)
;
jit
:
:
AtomicOperations
:
:
memcpySafeWhenRacy
(
toBuffer
-
>
dataPointerShared
(
)
+
toIndex
fromBuffer
-
>
dataPointerShared
(
)
+
fromIndex
count
)
;
}
SharedArrayBufferObject
*
SharedArrayBufferObject
:
:
createFromNewRawBuffer
(
JSContext
*
cx
SharedArrayRawBuffer
*
buffer
size_t
initialSize
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
SharedArrayBufferObject
*
obj
=
NewBuiltinClassInstance
<
SharedArrayBufferObject
>
(
cx
)
;
if
(
!
obj
)
{
buffer
-
>
dropReference
(
)
;
return
nullptr
;
}
cx
-
>
runtime
(
)
-
>
incSABCount
(
)
;
if
(
!
obj
-
>
acceptRawBuffer
(
buffer
initialSize
)
)
{
buffer
-
>
dropReference
(
)
;
return
nullptr
;
}
return
obj
;
}
static
const
JSClassOps
SharedArrayBufferObjectClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
SharedArrayBufferObject
:
:
Finalize
nullptr
nullptr
nullptr
nullptr
}
;
static
const
JSFunctionSpec
sharedarrray_functions
[
]
=
{
JS_FS_END
}
;
static
const
JSPropertySpec
sharedarrray_properties
[
]
=
{
JS_SELF_HOSTED_SYM_GET
(
species
"
SharedArrayBufferSpecies
"
0
)
JS_PS_END
}
;
static
const
JSFunctionSpec
sharedarray_proto_functions
[
]
=
{
JS_SELF_HOSTED_FN
(
"
slice
"
"
SharedArrayBufferSlice
"
2
0
)
JS_FS_END
}
;
static
const
JSPropertySpec
sharedarray_proto_properties
[
]
=
{
JS_PSG
(
"
byteLength
"
SharedArrayBufferObject
:
:
byteLengthGetter
0
)
JS_STRING_SYM_PS
(
toStringTag
"
SharedArrayBuffer
"
JSPROP_READONLY
)
JS_PS_END
}
;
static
const
ClassSpec
SharedArrayBufferObjectClassSpec
=
{
GenericCreateConstructor
<
SharedArrayBufferObject
:
:
class_constructor
1
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
SharedArrayBufferObject
>
sharedarrray_functions
sharedarrray_properties
sharedarray_proto_functions
sharedarray_proto_properties
}
;
const
JSClass
SharedArrayBufferObject
:
:
class_
=
{
"
SharedArrayBuffer
"
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_HAS_RESERVED_SLOTS
(
SharedArrayBufferObject
:
:
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_SharedArrayBuffer
)
|
JSCLASS_FOREGROUND_FINALIZE
&
SharedArrayBufferObjectClassOps
&
SharedArrayBufferObjectClassSpec
JS_NULL_CLASS_EXT
}
;
const
JSClass
SharedArrayBufferObject
:
:
protoClass_
=
{
"
SharedArrayBuffer
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_SharedArrayBuffer
)
JS_NULL_CLASS_OPS
&
SharedArrayBufferObjectClassSpec
}
;
JS_PUBLIC_API
size_t
JS
:
:
GetSharedArrayBufferByteLength
(
JSObject
*
obj
)
{
auto
*
aobj
=
obj
-
>
maybeUnwrapAs
<
SharedArrayBufferObject
>
(
)
;
return
aobj
?
aobj
-
>
byteLength
(
)
:
0
;
}
JS_PUBLIC_API
void
JS
:
:
GetSharedArrayBufferLengthAndData
(
JSObject
*
obj
size_t
*
length
bool
*
isSharedMemory
uint8_t
*
*
data
)
{
MOZ_ASSERT
(
obj
-
>
is
<
SharedArrayBufferObject
>
(
)
)
;
*
length
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
byteLength
(
)
;
*
data
=
obj
-
>
as
<
SharedArrayBufferObject
>
(
)
.
dataPointerShared
(
)
.
unwrap
(
)
;
*
isSharedMemory
=
true
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewSharedArrayBuffer
(
JSContext
*
cx
size_t
nbytes
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
;
if
(
nbytes
>
ArrayBufferObject
:
:
maxBufferByteLength
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SHARED_ARRAY_BAD_LENGTH
)
;
return
nullptr
;
}
return
SharedArrayBufferObject
:
:
New
(
cx
nbytes
nullptr
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsSharedArrayBufferObject
(
JSObject
*
obj
)
{
return
obj
-
>
canUnwrapAs
<
SharedArrayBufferObject
>
(
)
;
}
JS_PUBLIC_API
uint8_t
*
JS
:
:
GetSharedArrayBufferData
(
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
{
auto
*
aobj
=
obj
-
>
maybeUnwrapAs
<
SharedArrayBufferObject
>
(
)
;
if
(
!
aobj
)
{
return
nullptr
;
}
*
isSharedMemory
=
true
;
return
aobj
-
>
dataPointerShared
(
)
.
unwrap
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
ContainsSharedArrayBuffer
(
JSContext
*
cx
)
{
return
cx
-
>
runtime
(
)
-
>
hasLiveSABs
(
)
;
}
