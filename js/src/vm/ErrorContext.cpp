#
include
"
vm
/
ErrorContext
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
namespace
js
;
void
ErrorAllocator
:
:
reportAllocationOverflow
(
)
{
context_
-
>
onAllocationOverflow
(
)
;
}
void
*
ErrorAllocator
:
:
onOutOfMemory
(
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
)
{
return
context_
-
>
onOutOfMemory
(
allocFunc
arena
nbytes
reallocPtr
)
;
}
MainThreadErrorContext
:
:
MainThreadErrorContext
(
JSContext
*
cx
)
:
cx_
(
cx
)
{
}
void
*
MainThreadErrorContext
:
:
onOutOfMemory
(
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
)
{
return
cx_
-
>
onOutOfMemory
(
allocFunc
arena
nbytes
reallocPtr
)
;
}
void
MainThreadErrorContext
:
:
onAllocationOverflow
(
)
{
return
cx_
-
>
reportAllocationOverflow
(
)
;
}
void
MainThreadErrorContext
:
:
onOverRecursed
(
)
{
cx_
-
>
onOverRecursed
(
)
;
}
const
JSErrorFormatString
*
MainThreadErrorContext
:
:
gcSafeCallback
(
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
)
{
gc
:
:
AutoSuppressGC
suppressGC
(
cx_
)
;
return
callback
(
userRef
errorNumber
)
;
}
void
MainThreadErrorContext
:
:
reportError
(
CompileError
*
err
)
{
if
(
MOZ_UNLIKELY
(
!
cx_
-
>
runtime
(
)
-
>
hasInitializedSelfHosting
(
)
)
)
{
selfHosting_ErrorReporter
(
err
)
;
return
;
}
err
-
>
throwError
(
cx_
)
;
}
void
MainThreadErrorContext
:
:
reportWarning
(
CompileError
*
err
)
{
err
-
>
throwError
(
cx_
)
;
}
bool
MainThreadErrorContext
:
:
hadOutOfMemory
(
)
const
{
return
cx_
-
>
offThreadFrontendErrors
(
)
-
>
outOfMemory
;
}
bool
MainThreadErrorContext
:
:
hadOverRecursed
(
)
const
{
return
cx_
-
>
offThreadFrontendErrors
(
)
-
>
overRecursed
;
}
bool
MainThreadErrorContext
:
:
hadErrors
(
)
const
{
return
hadOutOfMemory
(
)
|
|
hadOverRecursed
(
)
|
|
!
cx_
-
>
offThreadFrontendErrors
(
)
-
>
errors
.
empty
(
)
;
}
void
*
OffThreadErrorContext
:
:
onOutOfMemory
(
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
)
{
addPendingOutOfMemory
(
)
;
return
nullptr
;
}
void
OffThreadErrorContext
:
:
onAllocationOverflow
(
)
{
}
void
OffThreadErrorContext
:
:
onOverRecursed
(
)
{
errors_
.
overRecursed
=
true
;
}
const
JSErrorFormatString
*
OffThreadErrorContext
:
:
gcSafeCallback
(
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
)
{
return
callback
(
userRef
errorNumber
)
;
}
void
OffThreadErrorContext
:
:
reportError
(
CompileError
*
err
)
{
auto
errorPtr
=
getAllocator
(
)
-
>
make_unique
<
CompileError
>
(
std
:
:
move
(
*
err
)
)
;
if
(
!
errorPtr
)
{
return
;
}
if
(
!
errors_
.
errors
.
append
(
std
:
:
move
(
errorPtr
)
)
)
{
ReportOutOfMemory
(
)
;
return
;
}
}
void
OffThreadErrorContext
:
:
reportWarning
(
CompileError
*
err
)
{
reportError
(
err
)
;
}
void
OffThreadErrorContext
:
:
ReportOutOfMemory
(
)
{
if
(
SupportDifferentialTesting
(
)
)
{
fprintf
(
stderr
"
ReportOutOfMemory
called
\
n
"
)
;
}
addPendingOutOfMemory
(
)
;
}
void
OffThreadErrorContext
:
:
addPendingOutOfMemory
(
)
{
errors_
.
outOfMemory
=
true
;
}
void
OffThreadErrorContext
:
:
linkWithJSContext
(
JSContext
*
cx
)
{
if
(
cx
)
{
cx
-
>
setOffThreadFrontendErrors
(
&
errors_
)
;
}
}
