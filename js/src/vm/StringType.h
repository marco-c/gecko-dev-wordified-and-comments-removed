#
ifndef
vm_StringType_h
#
define
vm_StringType_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StringBuffer
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
string_view
>
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
MaybeRooted
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
RelocationOverlay
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
shadow
/
String
.
h
"
#
include
"
js
/
String
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Text
.
h
"
class
JSDependentString
;
class
JSExtensibleString
;
class
JSExternalString
;
class
JSInlineString
;
class
JSRope
;
namespace
JS
{
class
JS_PUBLIC_API
AutoStableStringChars
;
}
namespace
js
{
class
ArrayObject
;
class
JS_PUBLIC_API
GenericPrinter
;
class
JSONPrinter
;
class
PropertyName
;
class
StringBuilder
;
namespace
frontend
{
class
ParserAtomsTable
;
class
TaggedParserAtomIndex
;
class
WellKnownParserAtoms
;
struct
CompilationAtomCache
;
}
namespace
jit
{
class
MacroAssembler
;
}
static
const
size_t
UINT32_CHAR_BUFFER_LENGTH
=
sizeof
(
"
4294967295
"
)
-
1
;
const
uint32_t
MAX_ARRAY_INDEX
=
4294967294u
;
template
<
typename
CharT
>
bool
CheckStringIsIndex
(
const
CharT
*
s
size_t
length
uint32_t
*
indexp
)
;
}
class
JSString
:
public
js
:
:
gc
:
:
CellWithLengthAndFlags
{
protected
:
using
Base
=
js
:
:
gc
:
:
CellWithLengthAndFlags
;
static
const
size_t
NUM_INLINE_CHARS_LATIN1
=
2
*
sizeof
(
void
*
)
/
sizeof
(
JS
:
:
Latin1Char
)
;
static
const
size_t
NUM_INLINE_CHARS_TWO_BYTE
=
2
*
sizeof
(
void
*
)
/
sizeof
(
char16_t
)
;
public
:
MOZ_ALWAYS_INLINE
size_t
length
(
)
const
{
return
headerLengthField
(
)
;
}
MOZ_ALWAYS_INLINE
uint32_t
flags
(
)
const
{
return
headerFlagsField
(
)
;
}
template
<
typename
CharT
>
class
OwnedChars
{
public
:
enum
class
Kind
{
Uninitialized
Nursery
Malloc
StringBuffer
}
;
private
:
mozilla
:
:
Span
<
CharT
>
chars_
;
Kind
kind_
=
Kind
:
:
Uninitialized
;
public
:
OwnedChars
(
)
=
default
;
OwnedChars
(
CharT
*
chars
size_t
length
Kind
kind
)
;
OwnedChars
(
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
&
&
chars
size_t
length
)
;
OwnedChars
(
RefPtr
<
mozilla
:
:
StringBuffer
>
&
&
buffer
size_t
length
)
;
OwnedChars
(
OwnedChars
&
&
)
;
OwnedChars
(
const
OwnedChars
&
)
=
delete
;
~
OwnedChars
(
)
{
reset
(
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT_IF
(
kind_
!
=
Kind
:
:
Uninitialized
!
chars_
.
empty
(
)
)
;
return
kind_
!
=
Kind
:
:
Uninitialized
;
}
mozilla
:
:
Span
<
CharT
>
span
(
)
const
{
MOZ_ASSERT
(
kind_
!
=
Kind
:
:
Uninitialized
)
;
return
chars_
;
}
CharT
*
data
(
)
const
{
MOZ_ASSERT
(
kind_
!
=
Kind
:
:
Uninitialized
)
;
return
chars_
.
data
(
)
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
kind_
!
=
Kind
:
:
Uninitialized
)
;
return
chars_
.
Length
(
)
;
}
size_t
size
(
)
const
{
return
length
(
)
*
sizeof
(
CharT
)
;
}
bool
isMalloced
(
)
const
{
return
kind_
=
=
Kind
:
:
Malloc
;
}
bool
hasStringBuffer
(
)
const
{
return
kind_
=
=
Kind
:
:
StringBuffer
;
}
inline
CharT
*
release
(
)
;
inline
void
reset
(
)
;
inline
void
ensureNonNursery
(
)
;
void
trace
(
JSTracer
*
trc
)
{
ensureNonNursery
(
)
;
}
}
;
protected
:
struct
Data
{
union
{
union
{
JS
:
:
Latin1Char
inlineStorageLatin1
[
NUM_INLINE_CHARS_LATIN1
]
;
char16_t
inlineStorageTwoByte
[
NUM_INLINE_CHARS_TWO_BYTE
]
;
}
;
struct
{
union
{
const
JS
:
:
Latin1Char
*
nonInlineCharsLatin1
;
const
char16_t
*
nonInlineCharsTwoByte
;
JSString
*
left
;
JSRope
*
parent
;
}
u2
;
union
{
JSLinearString
*
base
;
JSAtom
*
atom
;
JSString
*
right
;
size_t
capacity
;
const
JSExternalStringCallbacks
*
externalCallbacks
;
}
u3
;
}
s
;
}
;
}
d
;
public
:
static_assert
(
js
:
:
gc
:
:
CellFlagBitsReservedForGC
<
=
3
"
JSString
:
:
flags
must
reserve
enough
bits
for
Cell
"
)
;
static
const
uint32_t
ATOM_BIT
=
js
:
:
Bit
(
3
)
;
static
const
uint32_t
LINEAR_BIT
=
js
:
:
Bit
(
4
)
;
static
const
uint32_t
DEPENDENT_BIT
=
js
:
:
Bit
(
5
)
;
static
const
uint32_t
INLINE_CHARS_BIT
=
js
:
:
Bit
(
6
)
;
static
const
uint32_t
ATOM_REF_BIT
=
js
:
:
Bit
(
9
)
;
static
const
uint32_t
LINEAR_IS_EXTENSIBLE_BIT
=
js
:
:
Bit
(
7
)
;
static
const
uint32_t
INLINE_IS_FAT_BIT
=
js
:
:
Bit
(
7
)
;
static
const
uint32_t
LINEAR_IS_EXTERNAL_BIT
=
js
:
:
Bit
(
8
)
;
static
const
uint32_t
ATOM_IS_PERMANENT_BIT
=
js
:
:
Bit
(
8
)
;
static
const
uint32_t
EXTENSIBLE_FLAGS
=
LINEAR_BIT
|
LINEAR_IS_EXTENSIBLE_BIT
;
static
const
uint32_t
EXTERNAL_FLAGS
=
LINEAR_BIT
|
LINEAR_IS_EXTERNAL_BIT
;
static
const
uint32_t
FAT_INLINE_MASK
=
INLINE_CHARS_BIT
|
INLINE_IS_FAT_BIT
;
static
const
uint32_t
INIT_THIN_INLINE_FLAGS
=
LINEAR_BIT
|
INLINE_CHARS_BIT
;
static
const
uint32_t
INIT_FAT_INLINE_FLAGS
=
LINEAR_BIT
|
FAT_INLINE_MASK
;
static
const
uint32_t
INIT_ROPE_FLAGS
=
0
;
static
const
uint32_t
INIT_LINEAR_FLAGS
=
LINEAR_BIT
;
static
const
uint32_t
INIT_DEPENDENT_FLAGS
=
LINEAR_BIT
|
DEPENDENT_BIT
;
static
const
uint32_t
INIT_ATOM_REF_FLAGS
=
INIT_DEPENDENT_FLAGS
|
ATOM_REF_BIT
;
static
const
uint32_t
TYPE_FLAGS_MASK
=
js
:
:
BitMask
(
10
)
-
js
:
:
BitMask
(
3
)
;
static_assert
(
(
TYPE_FLAGS_MASK
&
js
:
:
gc
:
:
HeaderWord
:
:
RESERVED_MASK
)
=
=
0
"
GC
reserved
bits
must
not
be
used
for
Strings
"
)
;
static
const
uint32_t
ATOM_IS_INDEX_BIT
=
js
:
:
Bit
(
9
)
;
static
const
uint32_t
LATIN1_CHARS_BIT
=
js
:
:
Bit
(
10
)
;
static
const
uint32_t
INDEX_VALUE_BIT
=
js
:
:
Bit
(
11
)
;
static
const
uint32_t
INDEX_VALUE_SHIFT
=
16
;
static
const
uint32_t
HAS_STRING_BUFFER_BIT
=
js
:
:
Bit
(
12
)
;
static
const
uint32_t
NON_DEDUP_BIT
=
js
:
:
Bit
(
15
)
;
static
const
uint32_t
IN_STRING_TO_ATOM_CACHE
=
js
:
:
Bit
(
13
)
;
static
const
uint32_t
FLATTEN_VISIT_RIGHT
=
js
:
:
Bit
(
14
)
;
static
const
uint32_t
FLATTEN_FINISH_NODE
=
js
:
:
Bit
(
15
)
;
static
const
uint32_t
FLATTEN_MASK
=
FLATTEN_VISIT_RIGHT
|
FLATTEN_FINISH_NODE
;
static
const
uint32_t
DEPENDED_ON_BIT
=
FLATTEN_VISIT_RIGHT
;
static
const
uint32_t
PINNED_ATOM_BIT
=
js
:
:
Bit
(
15
)
;
static
const
uint32_t
PERMANENT_ATOM_MASK
=
ATOM_BIT
|
PINNED_ATOM_BIT
|
ATOM_IS_PERMANENT_BIT
;
static
const
uint32_t
MAX_LENGTH
=
JS
:
:
MaxStringLength
;
static
const
JS
:
:
Latin1Char
MAX_LATIN1_CHAR
=
0xff
;
static
constexpr
size_t
MIN_BYTES_FOR_BUFFER
=
514
;
static
inline
bool
validateLength
(
JSContext
*
maybecx
size_t
length
)
;
template
<
js
:
:
AllowGC
allowGC
>
static
inline
bool
validateLengthInternal
(
JSContext
*
maybecx
size_t
length
)
;
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetOfHeaderFlags
(
)
;
}
static
constexpr
size_t
offsetOfLength
(
)
{
return
offsetOfHeaderLength
(
)
;
}
bool
sameLengthAndFlags
(
const
JSString
&
other
)
const
{
return
length
(
)
=
=
other
.
length
(
)
&
&
flags
(
)
=
=
other
.
flags
(
)
;
}
static
void
staticAsserts
(
)
{
static_assert
(
JSString
:
:
MAX_LENGTH
<
UINT32_MAX
"
Length
must
fit
in
32
bits
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
+
NUM_INLINE_CHARS_LATIN1
*
sizeof
(
char
)
)
"
Inline
Latin1
chars
must
fit
in
a
JSString
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
+
NUM_INLINE_CHARS_TWO_BYTE
*
sizeof
(
char16_t
)
)
"
Inline
char16_t
chars
must
fit
in
a
JSString
"
)
;
using
JS
:
:
shadow
:
:
String
;
static_assert
(
JSString
:
:
offsetOfRawHeaderFlagsField
(
)
=
=
offsetof
(
String
flags_
)
"
shadow
:
:
String
flags
offset
must
match
JSString
"
)
;
#
if
JS_BITS_PER_WORD
=
=
32
static_assert
(
JSString
:
:
offsetOfLength
(
)
=
=
offsetof
(
String
length_
)
"
shadow
:
:
String
length
offset
must
match
JSString
"
)
;
#
endif
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
=
=
offsetof
(
String
nonInlineCharsLatin1
)
"
shadow
:
:
String
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
String
nonInlineCharsTwoByte
)
"
shadow
:
:
String
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u3
.
externalCallbacks
)
=
=
offsetof
(
String
externalCallbacks
)
"
shadow
:
:
String
externalCallbacks
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
=
=
offsetof
(
String
inlineStorageLatin1
)
"
shadow
:
:
String
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
=
=
offsetof
(
String
inlineStorageTwoByte
)
"
shadow
:
:
String
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
ATOM_BIT
=
=
String
:
:
ATOM_BIT
"
shadow
:
:
String
:
:
ATOM_BIT
must
match
JSString
:
:
ATOM_BIT
"
)
;
static_assert
(
LINEAR_BIT
=
=
String
:
:
LINEAR_BIT
"
shadow
:
:
String
:
:
LINEAR_BIT
must
match
JSString
:
:
LINEAR_BIT
"
)
;
static_assert
(
INLINE_CHARS_BIT
=
=
String
:
:
INLINE_CHARS_BIT
"
shadow
:
:
String
:
:
INLINE_CHARS_BIT
must
match
"
"
JSString
:
:
INLINE_CHARS_BIT
"
)
;
static_assert
(
LATIN1_CHARS_BIT
=
=
String
:
:
LATIN1_CHARS_BIT
"
shadow
:
:
String
:
:
LATIN1_CHARS_BIT
must
match
"
"
JSString
:
:
LATIN1_CHARS_BIT
"
)
;
static_assert
(
TYPE_FLAGS_MASK
=
=
String
:
:
TYPE_FLAGS_MASK
"
shadow
:
:
String
:
:
TYPE_FLAGS_MASK
must
match
JSString
:
:
TYPE_FLAGS_MASK
"
)
;
static_assert
(
EXTERNAL_FLAGS
=
=
String
:
:
EXTERNAL_FLAGS
"
shadow
:
:
String
:
:
EXTERNAL_FLAGS
must
match
JSString
:
:
EXTERNAL_FLAGS
"
)
;
}
friend
class
JSRope
;
friend
class
js
:
:
gc
:
:
RelocationOverlay
;
protected
:
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
void
setNonInlineChars
(
const
CharT
*
chars
bool
usesStringBuffer
)
;
template
<
typename
CharT
>
static
MOZ_ALWAYS_INLINE
void
checkStringCharsArena
(
const
CharT
*
chars
bool
usesStringBuffer
)
{
#
ifdef
MOZ_DEBUG
if
(
!
usesStringBuffer
)
{
js
:
:
AssertJSStringBufferInCorrectArena
(
chars
)
;
}
#
endif
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
nonInlineCharsRaw
(
)
const
;
public
:
MOZ_ALWAYS_INLINE
bool
empty
(
)
const
{
return
length
(
)
=
=
0
;
}
inline
bool
getChar
(
JSContext
*
cx
size_t
index
char16_t
*
code
)
;
inline
bool
getCodePoint
(
JSContext
*
cx
size_t
index
char32_t
*
codePoint
)
;
bool
hasLatin1Chars
(
)
const
{
return
flags
(
)
&
LATIN1_CHARS_BIT
;
}
bool
hasTwoByteChars
(
)
const
{
return
!
(
flags
(
)
&
LATIN1_CHARS_BIT
)
;
}
bool
hasIndexValue
(
)
const
{
return
flags
(
)
&
INDEX_VALUE_BIT
;
}
uint32_t
getIndexValue
(
)
const
{
MOZ_ASSERT
(
hasIndexValue
(
)
)
;
MOZ_ASSERT
(
isLinear
(
)
)
;
return
flags
(
)
>
>
INDEX_VALUE_SHIFT
;
}
bool
isDependedOn
(
)
const
{
bool
result
=
flags
(
)
&
DEPENDED_ON_BIT
;
MOZ_ASSERT_IF
(
result
!
isRope
(
)
&
&
!
isAtom
(
)
)
;
return
result
;
}
bool
assertIsValidBase
(
)
const
{
return
isAtom
(
)
|
|
isDependedOn
(
)
;
}
void
setDependedOn
(
)
{
MOZ_ASSERT
(
!
isRope
(
)
)
;
if
(
isAtom
(
)
)
{
return
;
}
setFlagBit
(
DEPENDED_ON_BIT
)
;
}
inline
size_t
allocSize
(
)
const
;
inline
JSLinearString
*
ensureLinear
(
JSContext
*
cx
)
;
MOZ_ALWAYS_INLINE
bool
isRope
(
)
const
{
return
!
(
flags
(
)
&
LINEAR_BIT
)
;
}
MOZ_ALWAYS_INLINE
JSRope
&
asRope
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
return
*
(
JSRope
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isLinear
(
)
const
{
return
flags
(
)
&
LINEAR_BIT
;
}
MOZ_ALWAYS_INLINE
JSLinearString
&
asLinear
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
*
(
JSLinearString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isDependent
(
)
const
{
return
flags
(
)
&
DEPENDENT_BIT
;
}
MOZ_ALWAYS_INLINE
bool
isAtomRef
(
)
const
{
return
(
flags
(
)
&
ATOM_REF_BIT
)
&
&
!
(
flags
(
)
&
ATOM_BIT
)
;
}
MOZ_ALWAYS_INLINE
JSDependentString
&
asDependent
(
)
const
{
MOZ_ASSERT
(
isDependent
(
)
)
;
return
*
(
JSDependentString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isExtensible
(
)
const
{
return
(
flags
(
)
&
TYPE_FLAGS_MASK
)
=
=
EXTENSIBLE_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExtensibleString
&
asExtensible
(
)
const
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
return
*
(
JSExtensibleString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isInline
(
)
const
{
return
flags
(
)
&
INLINE_CHARS_BIT
;
}
MOZ_ALWAYS_INLINE
JSInlineString
&
asInline
(
)
const
{
MOZ_ASSERT
(
isInline
(
)
)
;
return
*
(
JSInlineString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isFatInline
(
)
const
{
return
(
flags
(
)
&
FAT_INLINE_MASK
)
=
=
FAT_INLINE_MASK
;
}
bool
isExternal
(
)
const
{
return
(
flags
(
)
&
TYPE_FLAGS_MASK
)
=
=
EXTERNAL_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExternalString
&
asExternal
(
)
const
{
MOZ_ASSERT
(
isExternal
(
)
)
;
return
*
(
JSExternalString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isAtom
(
)
const
{
return
flags
(
)
&
ATOM_BIT
;
}
MOZ_ALWAYS_INLINE
bool
isPermanentAtom
(
)
const
{
return
(
flags
(
)
&
PERMANENT_ATOM_MASK
)
=
=
PERMANENT_ATOM_MASK
;
}
MOZ_ALWAYS_INLINE
JSAtom
&
asAtom
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
)
;
return
*
(
JSAtom
*
)
this
;
}
MOZ_ALWAYS_INLINE
void
setNonDeduplicatable
(
)
{
MOZ_ASSERT
(
isLinear
(
)
)
;
MOZ_ASSERT
(
!
isAtom
(
)
)
;
setFlagBit
(
NON_DEDUP_BIT
)
;
}
MOZ_ALWAYS_INLINE
void
clearBitsOnTenure
(
)
{
MOZ_ASSERT
(
!
isAtom
(
)
)
;
clearFlagBit
(
NON_DEDUP_BIT
|
IN_STRING_TO_ATOM_CACHE
)
;
}
MOZ_ALWAYS_INLINE
bool
isDeduplicatable
(
)
const
{
MOZ_ASSERT
(
isLinear
(
)
)
;
MOZ_ASSERT
(
!
isAtom
(
)
)
;
return
!
(
flags
(
)
&
NON_DEDUP_BIT
)
;
}
void
setInStringToAtomCache
(
)
{
MOZ_ASSERT
(
!
isAtom
(
)
)
;
setFlagBit
(
IN_STRING_TO_ATOM_CACHE
)
;
}
bool
inStringToAtomCache
(
)
const
{
return
flags
(
)
&
IN_STRING_TO_ATOM_CACHE
;
}
static
bool
fillWithRepresentatives
(
JSContext
*
cx
JS
:
:
Handle
<
js
:
:
ArrayObject
*
>
array
)
;
inline
bool
hasBase
(
)
const
{
return
isDependent
(
)
;
}
inline
JSLinearString
*
base
(
)
const
;
inline
JSAtom
*
atom
(
)
const
;
inline
JSLinearString
*
nurseryBaseOrRelocOverlay
(
)
const
;
inline
bool
canOwnDependentChars
(
)
const
;
inline
void
setBase
(
JSLinearString
*
newBase
)
;
bool
tryReplaceWithAtomRef
(
JSAtom
*
atom
)
;
void
traceBase
(
JSTracer
*
trc
)
;
inline
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
bool
hasOutOfLineChars
(
)
const
{
return
isLinear
(
)
&
&
!
isInline
(
)
&
&
!
isDependent
(
)
&
&
!
isExternal
(
)
;
}
inline
bool
ownsMallocedChars
(
)
const
;
bool
hasStringBuffer
(
)
const
{
MOZ_ASSERT_IF
(
flags
(
)
&
HAS_STRING_BUFFER_BIT
isLinear
(
)
&
&
!
isInline
(
)
&
&
!
isDependent
(
)
&
&
!
isExternal
(
)
&
&
!
isExtensible
(
)
)
;
return
flags
(
)
&
HAS_STRING_BUFFER_BIT
;
}
mozilla
:
:
Maybe
<
std
:
:
tuple
<
size_t
size_t
>
>
encodeUTF8Partial
(
const
JS
:
:
AutoRequireNoGC
&
nogc
mozilla
:
:
Span
<
char
>
buffer
)
const
;
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfNonInlineChars
(
)
{
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
"
nonInlineCharsTwoByte
and
nonInlineCharsLatin1
must
have
same
offset
"
)
;
return
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
;
}
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
String
;
JS
:
:
Zone
*
zone
(
)
const
{
if
(
isTenured
(
)
)
{
if
(
isPermanentAtom
(
)
)
{
return
zoneFromAnyThread
(
)
;
}
return
asTenured
(
)
.
zone
(
)
;
}
return
nurseryZone
(
)
;
}
void
setLengthAndFlags
(
uint32_t
len
uint32_t
flags
)
{
setHeaderLengthAndFlags
(
len
flags
)
;
}
void
setFlagBit
(
uint32_t
flag
)
{
setHeaderFlagBit
(
flag
)
;
}
void
clearFlagBit
(
uint32_t
flag
)
{
clearHeaderFlagBit
(
flag
)
;
}
void
fixupAfterMovingGC
(
)
{
}
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
using
js
:
:
gc
:
:
AllocKind
;
AllocKind
kind
;
if
(
isAtom
(
)
)
{
if
(
isFatInline
(
)
)
{
kind
=
AllocKind
:
:
FAT_INLINE_ATOM
;
}
else
{
kind
=
AllocKind
:
:
ATOM
;
}
}
else
if
(
isFatInline
(
)
)
{
kind
=
AllocKind
:
:
FAT_INLINE_STRING
;
}
else
if
(
isExternal
(
)
)
{
kind
=
AllocKind
:
:
EXTERNAL_STRING
;
}
else
{
kind
=
AllocKind
:
:
STRING
;
}
MOZ_ASSERT_IF
(
isTenured
(
)
kind
=
=
asTenured
(
)
.
getAllocKind
(
)
)
;
return
kind
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpCommonFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpCharsFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpStringContent
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dumpPropertyName
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dumpChars
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dumpCharsSingleQuote
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dumpCharsNoQuote
(
js
:
:
GenericPrinter
&
out
)
const
;
template
<
typename
CharT
>
static
void
dumpCharsNoQuote
(
const
CharT
*
s
size_t
len
js
:
:
GenericPrinter
&
out
)
;
void
dumpRepresentation
(
)
const
;
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
)
const
;
void
dumpRepresentation
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
bool
equals
(
const
char
*
s
)
;
#
endif
void
traceChildren
(
JSTracer
*
trc
)
;
inline
void
traceBaseAndRecordOldRoot
(
JSTracer
*
trc
)
;
bool
isPermanentAndMayBeShared
(
)
const
{
return
isPermanentAtom
(
)
;
}
static
void
addCellAddressToStoreBuffer
(
js
:
:
gc
:
:
StoreBuffer
*
buffer
js
:
:
gc
:
:
Cell
*
*
cellp
)
{
buffer
-
>
putCell
(
reinterpret_cast
<
JSString
*
*
>
(
cellp
)
)
;
}
static
void
removeCellAddressFromStoreBuffer
(
js
:
:
gc
:
:
StoreBuffer
*
buffer
js
:
:
gc
:
:
Cell
*
*
cellp
)
{
buffer
-
>
unputCell
(
reinterpret_cast
<
JSString
*
*
>
(
cellp
)
)
;
}
private
:
JSString
(
const
JSString
&
other
)
=
delete
;
void
operator
=
(
const
JSString
&
other
)
=
delete
;
protected
:
JSString
(
)
=
default
;
}
;
namespace
js
{
template
<
typename
Wrapper
typename
CharT
>
class
WrappedPtrOperations
<
JSString
:
:
OwnedChars
<
CharT
>
Wrapper
>
{
const
JSString
:
:
OwnedChars
<
CharT
>
&
get
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
explicit
operator
bool
(
)
const
{
return
!
!
get
(
)
;
}
mozilla
:
:
Span
<
CharT
>
span
(
)
const
{
return
get
(
)
.
span
(
)
;
}
CharT
*
data
(
)
const
{
return
get
(
)
.
data
(
)
;
}
size_t
length
(
)
const
{
return
get
(
)
.
length
(
)
;
}
size_t
size
(
)
const
{
return
get
(
)
.
size
(
)
;
}
bool
isMalloced
(
)
const
{
return
get
(
)
.
isMalloced
(
)
;
}
bool
hasStringBuffer
(
)
const
{
return
get
(
)
.
hasStringBuffer
(
)
;
}
}
;
template
<
typename
Wrapper
typename
CharT
>
class
MutableWrappedPtrOperations
<
JSString
:
:
OwnedChars
<
CharT
>
Wrapper
>
:
public
WrappedPtrOperations
<
JSString
:
:
OwnedChars
<
CharT
>
Wrapper
>
{
JSString
:
:
OwnedChars
<
CharT
>
&
get
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
CharT
*
release
(
)
{
return
get
(
)
.
release
(
)
;
}
void
reset
(
)
{
get
(
)
.
reset
(
)
;
}
void
ensureNonNursery
(
)
{
get
(
)
.
ensureNonNursery
(
)
;
}
}
;
}
class
JSRope
:
public
JSString
{
friend
class
js
:
:
gc
:
:
CellAllocator
;
template
<
typename
CharT
>
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
copyCharsInternal
(
JSContext
*
cx
arena_id_t
destArenaId
)
const
;
enum
UsingBarrier
:
bool
{
NoBarrier
=
false
WithIncrementalBarrier
=
true
}
;
friend
class
JSString
;
JSLinearString
*
flatten
(
JSContext
*
maybecx
)
;
JSLinearString
*
flattenInternal
(
)
;
template
<
UsingBarrier
usingBarrier
>
JSLinearString
*
flattenInternal
(
)
;
template
<
UsingBarrier
usingBarrier
typename
CharT
>
static
JSLinearString
*
flattenInternal
(
JSRope
*
root
)
;
template
<
UsingBarrier
usingBarrier
>
static
void
ropeBarrierDuringFlattening
(
JSRope
*
rope
)
;
JSRope
(
JSString
*
left
JSString
*
right
size_t
length
)
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSRope
*
new_
(
JSContext
*
cx
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
left
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
right
size_t
length
js
:
:
gc
:
:
Heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
js
:
:
UniquePtr
<
JS
:
:
Latin1Char
[
]
JS
:
:
FreePolicy
>
copyLatin1Chars
(
JSContext
*
maybecx
arena_id_t
destArenaId
)
const
;
JS
:
:
UniqueTwoByteChars
copyTwoByteChars
(
JSContext
*
maybecx
arena_id_t
destArenaId
)
const
;
template
<
typename
CharT
>
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
copyChars
(
JSContext
*
maybecx
arena_id_t
destArenaId
)
const
;
[
[
nodiscard
]
]
bool
hash
(
uint32_t
*
outhHash
)
const
;
bool
isBeingFlattened
(
)
const
{
return
flags
(
)
&
FLATTEN_MASK
;
}
JSString
*
leftChild
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
MOZ_ASSERT
(
!
isBeingFlattened
(
)
)
;
return
d
.
s
.
u2
.
left
;
}
JSString
*
rightChild
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
return
d
.
s
.
u3
.
right
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfLeft
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u2
.
left
)
;
}
static
size_t
offsetOfRight
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u3
.
right
)
;
}
}
;
static_assert
(
sizeof
(
JSRope
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSLinearString
:
public
JSString
{
friend
class
JSString
;
friend
class
JS
:
:
AutoStableStringChars
;
friend
class
js
:
:
gc
:
:
TenuringTracer
;
friend
class
js
:
:
gc
:
:
CellAllocator
;
friend
class
JSDependentString
;
JSLinearString
*
ensureLinear
(
JSContext
*
cx
)
=
delete
;
bool
isLinear
(
)
const
=
delete
;
JSLinearString
&
asLinear
(
)
const
=
delete
;
JSLinearString
(
const
char16_t
*
chars
size_t
length
bool
hasBuffer
)
;
JSLinearString
(
const
JS
:
:
Latin1Char
*
chars
size_t
length
bool
hasBuffer
)
;
template
<
typename
CharT
>
explicit
inline
JSLinearString
(
JS
:
:
MutableHandle
<
OwnedChars
<
CharT
>
>
chars
)
;
protected
:
JSLinearString
(
)
=
default
;
MOZ_ALWAYS_INLINE
void
*
nonInlineCharsRaw
(
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
static_assert
(
offsetof
(
JSLinearString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
JSLinearString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
"
nonInlineCharsTwoByte
and
nonInlineCharsLatin1
must
have
same
offset
"
)
;
return
(
void
*
)
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
rawLatin1Chars
(
)
const
;
MOZ_ALWAYS_INLINE
const
char16_t
*
rawTwoByteChars
(
)
const
;
public
:
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
static
inline
JSLinearString
*
new_
(
JSContext
*
cx
JS
:
:
MutableHandle
<
OwnedChars
<
CharT
>
>
chars
js
:
:
gc
:
:
Heap
heap
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
static
inline
JSLinearString
*
newValidLength
(
JSContext
*
cx
JS
:
:
MutableHandle
<
OwnedChars
<
CharT
>
>
chars
js
:
:
gc
:
:
Heap
heap
)
;
JSExtensibleString
&
makeExtensible
(
size_t
capacity
)
;
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
;
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
nonInlineLatin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
nonInlineTwoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
;
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
latin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawLatin1Chars
(
)
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
twoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawTwoByteChars
(
)
;
}
mozilla
:
:
Range
<
const
JS
:
:
Latin1Char
>
latin1Range
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
mozilla
:
:
Range
<
const
JS
:
:
Latin1Char
>
(
latin1Chars
(
nogc
)
length
(
)
)
;
}
mozilla
:
:
Range
<
const
char16_t
>
twoByteRange
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
mozilla
:
:
Range
<
const
char16_t
>
(
twoByteChars
(
nogc
)
length
(
)
)
;
}
MOZ_ALWAYS_INLINE
char16_t
latin1OrTwoByteChar
(
size_t
index
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
index
<
length
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
return
hasLatin1Chars
(
)
?
latin1Chars
(
nogc
)
[
index
]
:
twoByteChars
(
nogc
)
[
index
]
;
}
bool
isIndexSlow
(
uint32_t
*
indexp
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
size_t
len
=
length
(
)
;
if
(
len
=
=
0
|
|
len
>
js
:
:
UINT32_CHAR_BUFFER_LENGTH
)
{
return
false
;
}
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
hasLatin1Chars
(
)
)
{
const
JS
:
:
Latin1Char
*
s
=
latin1Chars
(
nogc
)
;
return
mozilla
:
:
IsAsciiDigit
(
*
s
)
&
&
js
:
:
CheckStringIsIndex
(
s
len
indexp
)
;
}
const
char16_t
*
s
=
twoByteChars
(
nogc
)
;
return
mozilla
:
:
IsAsciiDigit
(
*
s
)
&
&
js
:
:
CheckStringIsIndex
(
s
len
indexp
)
;
}
inline
bool
isIndex
(
uint32_t
*
indexp
)
const
;
inline
bool
hasMovableChars
(
)
const
;
void
maybeInitializeIndexValue
(
uint32_t
index
bool
allowAtom
=
false
)
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT_IF
(
hasIndexValue
(
)
getIndexValue
(
)
=
=
index
)
;
MOZ_ASSERT_IF
(
!
allowAtom
!
isAtom
(
)
)
;
if
(
hasIndexValue
(
)
|
|
index
>
UINT16_MAX
)
{
return
;
}
mozilla
:
:
DebugOnly
<
uint32_t
>
containedIndex
;
MOZ_ASSERT
(
isIndexSlow
(
&
containedIndex
)
)
;
MOZ_ASSERT
(
index
=
=
containedIndex
)
;
setFlagBit
(
(
index
<
<
INDEX_VALUE_SHIFT
)
|
INDEX_VALUE_BIT
)
;
MOZ_ASSERT
(
getIndexValue
(
)
=
=
index
)
;
}
mozilla
:
:
StringBuffer
*
stringBuffer
(
)
const
{
MOZ_ASSERT
(
hasStringBuffer
(
)
)
;
auto
*
chars
=
nonInlineCharsRaw
(
)
;
return
mozilla
:
:
StringBuffer
:
:
FromData
(
const_cast
<
void
*
>
(
chars
)
)
;
}
inline
js
:
:
PropertyName
*
toPropertyName
(
JSContext
*
cx
)
;
template
<
typename
CharT
>
inline
size_t
maybeMallocCharsOnPromotion
(
js
:
:
Nursery
*
nursery
)
;
inline
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
inline
size_t
allocSize
(
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
inline
void
disownCharsBecauseError
(
)
;
}
;
static_assert
(
sizeof
(
JSLinearString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSDependentString
:
public
JSLinearString
{
friend
class
JSString
;
friend
class
js
:
:
gc
:
:
CellAllocator
;
JSDependentString
(
JSLinearString
*
base
size_t
start
size_t
length
)
;
JSDependentString
(
)
=
default
;
bool
isDependent
(
)
const
=
delete
;
JSDependentString
&
asDependent
(
)
const
=
delete
;
MOZ_ALWAYS_INLINE
size_t
baseOffset
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isDependent
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
size_t
offset
;
if
(
hasTwoByteChars
(
)
)
{
offset
=
twoByteChars
(
nogc
)
-
base
(
)
-
>
twoByteChars
(
nogc
)
;
}
else
{
offset
=
latin1Chars
(
nogc
)
-
base
(
)
-
>
latin1Chars
(
nogc
)
;
}
MOZ_ASSERT
(
offset
<
base
(
)
-
>
length
(
)
)
;
return
offset
;
}
public
:
static
inline
JSLinearString
*
new_
(
JSContext
*
cx
JSLinearString
*
base
size_t
start
size_t
length
js
:
:
gc
:
:
Heap
heap
)
;
template
<
typename
T
>
void
relocateBaseAndChars
(
JSLinearString
*
base
T
chars
size_t
offset
)
{
MOZ_ASSERT
(
base
-
>
assertIsValidBase
(
)
)
;
bool
usesStringBuffer
=
base
-
>
hasStringBuffer
(
)
;
setNonInlineChars
(
chars
+
offset
usesStringBuffer
)
;
setBase
(
base
)
;
}
inline
JSLinearString
*
rootBaseDuringMinorGC
(
)
;
template
<
typename
CharT
>
inline
void
updatePromotedBaseImpl
(
)
;
inline
void
updatePromotedBase
(
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
inline
static
size_t
offsetOfBase
(
)
{
return
offsetof
(
JSDependentString
d
.
s
.
u3
.
base
)
;
}
}
;
static_assert
(
sizeof
(
JSDependentString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSAtomRefString
:
public
JSDependentString
{
friend
class
JSString
;
friend
class
js
:
:
gc
:
:
CellAllocator
;
friend
class
js
:
:
jit
:
:
MacroAssembler
;
public
:
inline
static
size_t
offsetOfAtom
(
)
{
return
offsetof
(
JSAtomRefString
d
.
s
.
u3
.
atom
)
;
}
}
;
static_assert
(
sizeof
(
JSAtomRefString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSExtensibleString
:
public
JSLinearString
{
bool
isExtensible
(
)
const
=
delete
;
JSExtensibleString
&
asExtensible
(
)
const
=
delete
;
public
:
MOZ_ALWAYS_INLINE
size_t
capacity
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isExtensible
(
)
)
;
return
d
.
s
.
u3
.
capacity
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSExtensibleString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSInlineString
:
public
JSLinearString
{
public
:
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
latin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isInline
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
inlineStorageLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
twoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isInline
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
inlineStorageTwoByte
;
}
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfInlineStorage
(
)
{
return
offsetof
(
JSInlineString
d
.
inlineStorageTwoByte
)
;
}
}
;
static_assert
(
sizeof
(
JSInlineString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSThinInlineString
:
public
JSInlineString
{
friend
class
js
:
:
gc
:
:
CellAllocator
;
explicit
JSThinInlineString
(
size_t
length
JS
:
:
Latin1Char
*
*
chars
)
;
explicit
JSThinInlineString
(
size_t
length
char16_t
*
*
chars
)
;
JSThinInlineString
(
)
=
default
;
public
:
static
constexpr
size_t
InlineBytes
=
NUM_INLINE_CHARS_LATIN1
;
static
const
size_t
MAX_LENGTH_LATIN1
=
NUM_INLINE_CHARS_LATIN1
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
NUM_INLINE_CHARS_TWO_BYTE
;
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSThinInlineString
*
new_
(
JSContext
*
cx
js
:
:
gc
:
:
Heap
heap
)
;
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
}
;
static_assert
(
sizeof
(
JSThinInlineString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSFatInlineString
:
public
JSInlineString
{
friend
class
js
:
:
gc
:
:
CellAllocator
;
static
const
size_t
INLINE_EXTENSION_CHARS_LATIN1
=
24
-
NUM_INLINE_CHARS_LATIN1
;
static
const
size_t
INLINE_EXTENSION_CHARS_TWO_BYTE
=
12
-
NUM_INLINE_CHARS_TWO_BYTE
;
explicit
JSFatInlineString
(
size_t
length
JS
:
:
Latin1Char
*
*
chars
)
;
explicit
JSFatInlineString
(
size_t
length
char16_t
*
*
chars
)
;
JSFatInlineString
(
)
=
default
;
protected
:
union
{
char
inlineStorageExtensionLatin1
[
INLINE_EXTENSION_CHARS_LATIN1
]
;
char16_t
inlineStorageExtensionTwoByte
[
INLINE_EXTENSION_CHARS_TWO_BYTE
]
;
}
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSFatInlineString
*
new_
(
JSContext
*
cx
js
:
:
gc
:
:
Heap
heap
)
;
static
const
size_t
MAX_LENGTH_LATIN1
=
JSString
:
:
NUM_INLINE_CHARS_LATIN1
+
INLINE_EXTENSION_CHARS_LATIN1
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
JSString
:
:
NUM_INLINE_CHARS_TWO_BYTE
+
INLINE_EXTENSION_CHARS_TWO_BYTE
;
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
MOZ_ALWAYS_INLINE
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
}
;
static_assert
(
sizeof
(
JSFatInlineString
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
shouldn
'
t
waste
space
up
to
the
next
cell
"
"
boundary
"
)
;
class
JSExternalString
:
public
JSLinearString
{
friend
class
js
:
:
gc
:
:
CellAllocator
;
JSExternalString
(
const
JS
:
:
Latin1Char
*
chars
size_t
length
const
JSExternalStringCallbacks
*
callbacks
)
;
JSExternalString
(
const
char16_t
*
chars
size_t
length
const
JSExternalStringCallbacks
*
callbacks
)
;
bool
isExternal
(
)
const
=
delete
;
JSExternalString
&
asExternal
(
)
const
=
delete
;
template
<
typename
CharT
>
static
inline
JSExternalString
*
newImpl
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
const
JSExternalStringCallbacks
*
callbacks
)
;
public
:
static
inline
JSExternalString
*
new_
(
JSContext
*
cx
const
JS
:
:
Latin1Char
*
chars
size_t
length
const
JSExternalStringCallbacks
*
callbacks
)
;
static
inline
JSExternalString
*
new_
(
JSContext
*
cx
const
char16_t
*
chars
size_t
length
const
JSExternalStringCallbacks
*
callbacks
)
;
const
JSExternalStringCallbacks
*
callbacks
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isExternal
(
)
)
;
return
d
.
s
.
u3
.
externalCallbacks
;
}
const
JS
:
:
Latin1Char
*
latin1Chars
(
)
const
{
return
rawLatin1Chars
(
)
;
}
const
char16_t
*
twoByteChars
(
)
const
{
return
rawTwoByteChars
(
)
;
}
inline
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dumpOwnRepresentationFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSExternalString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSAtom
:
public
JSLinearString
{
bool
isAtom
(
)
const
=
delete
;
JSAtom
&
asAtom
(
)
const
=
delete
;
public
:
template
<
typename
CharT
>
static
inline
JSAtom
*
newValidLength
(
JSContext
*
cx
OwnedChars
<
CharT
>
&
chars
js
:
:
HashNumber
hash
)
;
inline
js
:
:
PropertyName
*
asPropertyName
(
)
;
MOZ_ALWAYS_INLINE
bool
isPermanent
(
)
const
{
return
JSString
:
:
isPermanentAtom
(
)
;
}
MOZ_ALWAYS_INLINE
void
makePermanent
(
)
{
MOZ_ASSERT
(
JSString
:
:
isAtom
(
)
)
;
setFlagBit
(
PERMANENT_ATOM_MASK
)
;
}
MOZ_ALWAYS_INLINE
bool
isIndex
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isAtom
(
)
)
;
mozilla
:
:
DebugOnly
<
uint32_t
>
index
;
MOZ_ASSERT
(
!
!
(
flags
(
)
&
ATOM_IS_INDEX_BIT
)
=
=
isIndexSlow
(
&
index
)
)
;
return
flags
(
)
&
ATOM_IS_INDEX_BIT
;
}
MOZ_ALWAYS_INLINE
bool
isIndex
(
uint32_t
*
index
)
const
{
MOZ_ASSERT
(
JSString
:
:
isAtom
(
)
)
;
if
(
!
isIndex
(
)
)
{
return
false
;
}
*
index
=
hasIndexValue
(
)
?
getIndexValue
(
)
:
getIndexSlow
(
)
;
return
true
;
}
uint32_t
getIndexSlow
(
)
const
;
void
setIsIndex
(
uint32_t
index
)
{
MOZ_ASSERT
(
JSString
:
:
isAtom
(
)
)
;
setFlagBit
(
ATOM_IS_INDEX_BIT
)
;
maybeInitializeIndexValue
(
index
true
)
;
}
MOZ_ALWAYS_INLINE
bool
isPinned
(
)
const
{
return
flags
(
)
&
PINNED_ATOM_BIT
;
}
void
setPinned
(
)
{
MOZ_ASSERT
(
!
isPinned
(
)
)
;
setFlagBit
(
PINNED_ATOM_BIT
)
;
}
inline
js
:
:
HashNumber
hash
(
)
const
;
inline
void
initHash
(
js
:
:
HashNumber
hash
)
;
template
<
typename
CharT
>
static
bool
lengthFitsInline
(
size_t
length
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_CACHEIR_SPEW
)
void
dump
(
js
:
:
GenericPrinter
&
out
)
;
void
dump
(
)
;
#
endif
}
;
namespace
js
{
class
NormalAtom
:
public
JSAtom
{
friend
class
gc
:
:
CellAllocator
;
protected
:
static
constexpr
size_t
ExtensionBytes
=
js
:
:
gc
:
:
CellAlignBytes
-
sizeof
(
js
:
:
HashNumber
)
;
char
inlineStorage_
[
ExtensionBytes
]
;
HashNumber
hash_
;
explicit
NormalAtom
(
js
:
:
HashNumber
hash
)
:
hash_
(
hash
)
{
}
template
<
typename
CharT
>
NormalAtom
(
const
OwnedChars
<
CharT
>
&
chars
js
:
:
HashNumber
hash
)
;
public
:
HashNumber
hash
(
)
const
{
return
hash_
;
}
void
initHash
(
HashNumber
hash
)
{
hash_
=
hash
;
}
static
constexpr
size_t
offsetOfHash
(
)
{
return
offsetof
(
NormalAtom
hash_
)
;
}
}
;
static_assert
(
sizeof
(
NormalAtom
)
=
=
js
:
:
RoundUp
(
sizeof
(
JSString
)
+
sizeof
(
js
:
:
HashNumber
)
js
:
:
gc
:
:
CellAlignBytes
)
"
NormalAtom
must
have
size
of
a
string
+
HashNumber
"
"
aligned
to
gc
:
:
CellAlignBytes
"
)
;
class
ThinInlineAtom
:
public
NormalAtom
{
friend
class
gc
:
:
CellAllocator
;
public
:
static
constexpr
size_t
MAX_LENGTH_LATIN1
=
NUM_INLINE_CHARS_LATIN1
+
ExtensionBytes
/
sizeof
(
JS
:
:
Latin1Char
)
;
static
constexpr
size_t
MAX_LENGTH_TWO_BYTE
=
NUM_INLINE_CHARS_TWO_BYTE
+
ExtensionBytes
/
sizeof
(
char16_t
)
;
#
ifdef
JS_64BIT
static
constexpr
bool
EverInstantiated
=
false
;
#
else
static
constexpr
bool
EverInstantiated
=
true
;
#
endif
protected
:
#
ifdef
JS_64BIT
ThinInlineAtom
(
size_t
length
JS
:
:
Latin1Char
*
*
chars
js
:
:
HashNumber
hash
)
=
delete
;
ThinInlineAtom
(
size_t
length
char16_t
*
*
chars
js
:
:
HashNumber
hash
)
=
delete
;
#
else
ThinInlineAtom
(
size_t
length
JS
:
:
Latin1Char
*
*
chars
js
:
:
HashNumber
hash
)
;
ThinInlineAtom
(
size_t
length
char16_t
*
*
chars
js
:
:
HashNumber
hash
)
;
#
endif
public
:
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
{
if
constexpr
(
sizeof
(
CharT
)
=
=
sizeof
(
JS
:
:
Latin1Char
)
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
else
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
}
}
;
class
FatInlineAtom
:
public
JSAtom
{
friend
class
gc
:
:
CellAllocator
;
static
constexpr
size_t
InlineBytes
=
sizeof
(
JSFatInlineString
)
-
sizeof
(
JSString
:
:
Base
)
-
sizeof
(
js
:
:
HashNumber
)
;
static
constexpr
size_t
ExtensionBytes
=
InlineBytes
-
JSThinInlineString
:
:
InlineBytes
;
public
:
static
constexpr
size_t
MAX_LENGTH_LATIN1
=
InlineBytes
/
sizeof
(
JS
:
:
Latin1Char
)
;
static
constexpr
size_t
MAX_LENGTH_TWO_BYTE
=
InlineBytes
/
sizeof
(
char16_t
)
;
protected
:
char
inlineStorage_
[
ExtensionBytes
]
;
HashNumber
hash_
;
explicit
FatInlineAtom
(
size_t
length
JS
:
:
Latin1Char
*
*
chars
js
:
:
HashNumber
hash
)
;
explicit
FatInlineAtom
(
size_t
length
char16_t
*
*
chars
js
:
:
HashNumber
hash
)
;
public
:
HashNumber
hash
(
)
const
{
return
hash_
;
}
void
initHash
(
HashNumber
hash
)
{
hash_
=
hash
;
}
inline
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
static
constexpr
size_t
offsetOfHash
(
)
{
static_assert
(
sizeof
(
FatInlineAtom
)
=
=
js
:
:
RoundUp
(
sizeof
(
JSThinInlineString
)
+
FatInlineAtom
:
:
ExtensionBytes
+
sizeof
(
HashNumber
)
gc
:
:
CellAlignBytes
)
"
FatInlineAtom
must
have
size
of
a
thin
inline
string
+
"
"
extension
bytes
if
any
+
HashNumber
"
"
aligned
to
gc
:
:
CellAlignBytes
"
)
;
return
offsetof
(
FatInlineAtom
hash_
)
;
}
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
{
return
length
*
sizeof
(
CharT
)
<
=
InlineBytes
;
}
}
;
static_assert
(
sizeof
(
FatInlineAtom
)
=
=
sizeof
(
JSFatInlineString
)
"
FatInlineAtom
must
be
the
same
size
as
a
fat
inline
string
"
)
;
template
<
size_t
Size
=
16
>
class
StringSegmentRange
{
using
StackVector
=
JS
:
:
GCVector
<
JSString
*
Size
>
;
Rooted
<
StackVector
>
stack
;
Rooted
<
JSLinearString
*
>
cur
;
bool
settle
(
JSString
*
str
)
{
while
(
str
-
>
isRope
(
)
)
{
JSRope
&
rope
=
str
-
>
asRope
(
)
;
if
(
!
stack
.
append
(
rope
.
rightChild
(
)
)
)
{
return
false
;
}
str
=
rope
.
leftChild
(
)
;
}
cur
=
&
str
-
>
asLinear
(
)
;
return
true
;
}
public
:
explicit
StringSegmentRange
(
JSContext
*
cx
)
:
stack
(
cx
StackVector
(
cx
)
)
cur
(
cx
)
{
}
[
[
nodiscard
]
]
bool
init
(
JSString
*
str
)
{
MOZ_ASSERT
(
stack
.
empty
(
)
)
;
return
settle
(
str
)
;
}
bool
empty
(
)
const
{
return
cur
=
=
nullptr
;
}
JSLinearString
*
front
(
)
const
{
MOZ_ASSERT
(
!
cur
-
>
isRope
(
)
)
;
return
cur
;
}
[
[
nodiscard
]
]
bool
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
if
(
stack
.
empty
(
)
)
{
cur
=
nullptr
;
return
true
;
}
return
settle
(
stack
.
popCopy
(
)
)
;
}
}
;
}
inline
js
:
:
HashNumber
JSAtom
:
:
hash
(
)
const
{
if
(
isFatInline
(
)
)
{
return
static_cast
<
const
js
:
:
FatInlineAtom
*
>
(
this
)
-
>
hash
(
)
;
}
return
static_cast
<
const
js
:
:
NormalAtom
*
>
(
this
)
-
>
hash
(
)
;
}
inline
void
JSAtom
:
:
initHash
(
js
:
:
HashNumber
hash
)
{
if
(
isFatInline
(
)
)
{
return
static_cast
<
js
:
:
FatInlineAtom
*
>
(
this
)
-
>
initHash
(
hash
)
;
}
return
static_cast
<
js
:
:
NormalAtom
*
>
(
this
)
-
>
initHash
(
hash
)
;
}
namespace
js
{
class
PropertyName
:
public
JSAtom
{
private
:
PropertyName
*
asPropertyName
(
)
=
delete
;
}
;
static_assert
(
sizeof
(
PropertyName
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
static
MOZ_ALWAYS_INLINE
jsid
NameToId
(
PropertyName
*
name
)
{
return
JS
:
:
PropertyKey
:
:
NonIntAtom
(
name
)
;
}
using
PropertyNameVector
=
JS
:
:
GCVector
<
PropertyName
*
>
;
template
<
typename
CharT
>
void
CopyChars
(
CharT
*
dest
const
JSLinearString
&
str
)
;
static
inline
UniqueChars
StringToNewUTF8CharsZ
(
JSContext
*
cx
JSString
&
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
JSLinearString
*
linear
=
str
.
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
nullptr
;
}
return
UniqueChars
(
linear
-
>
hasLatin1Chars
(
)
?
JS
:
:
CharsToNewUTF8CharsZ
(
cx
linear
-
>
latin1Range
(
nogc
)
)
.
c_str
(
)
:
JS
:
:
CharsToNewUTF8CharsZ
(
cx
linear
-
>
twoByteRange
(
nogc
)
)
.
c_str
(
)
)
;
}
template
<
typename
CharT
>
extern
JSString
:
:
OwnedChars
<
CharT
>
AllocAtomCharsValidLength
(
JSContext
*
cx
size_t
length
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSLinearString
*
NewString
(
JSContext
*
cx
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
chars
size_t
length
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSLinearString
*
NewStringDontDeflate
(
JSContext
*
cx
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
chars
size_t
length
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
extern
JSLinearString
*
NewDependentString
(
JSContext
*
cx
JSString
*
base
size_t
start
size_t
length
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
extern
JSLinearString
*
NewLatin1StringZ
(
JSContext
*
cx
UniqueChars
chars
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSLinearString
*
NewStringCopyN
(
JSContext
*
cx
const
CharT
*
s
size_t
n
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
template
<
js
:
:
AllowGC
allowGC
>
inline
JSLinearString
*
NewStringCopyN
(
JSContext
*
cx
const
char
*
s
size_t
n
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
reinterpret_cast
<
const
Latin1Char
*
>
(
s
)
n
heap
)
;
}
template
<
typename
CharT
>
extern
JSAtom
*
NewAtomCopyNMaybeDeflateValidLength
(
JSContext
*
cx
const
CharT
*
s
size_t
n
js
:
:
HashNumber
hash
)
;
template
<
typename
CharT
>
extern
JSAtom
*
NewAtomCopyNDontDeflateValidLength
(
JSContext
*
cx
const
CharT
*
s
size_t
n
js
:
:
HashNumber
hash
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
inline
JSLinearString
*
NewStringCopy
(
JSContext
*
cx
mozilla
:
:
Span
<
const
CharT
>
s
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
.
data
(
)
s
.
size
(
)
heap
)
;
}
template
<
js
:
:
AllowGC
allowGC
typename
CharT
typename
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
CharT
unsigned
char
>
>
*
=
nullptr
>
inline
JSLinearString
*
NewStringCopy
(
JSContext
*
cx
std
:
:
basic_string_view
<
CharT
>
s
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
.
data
(
)
s
.
size
(
)
heap
)
;
}
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSLinearString
*
NewStringCopyNDontDeflate
(
JSContext
*
cx
const
CharT
*
s
size_t
n
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSLinearString
*
NewStringCopyNDontDeflateNonStaticValidLength
(
JSContext
*
cx
const
CharT
*
s
size_t
n
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
template
<
js
:
:
AllowGC
allowGC
>
inline
JSLinearString
*
NewStringCopyZ
(
JSContext
*
cx
const
char16_t
*
s
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
js_strlen
(
s
)
heap
)
;
}
template
<
js
:
:
AllowGC
allowGC
>
inline
JSLinearString
*
NewStringCopyZ
(
JSContext
*
cx
const
char
*
s
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
strlen
(
s
)
heap
)
;
}
extern
JSLinearString
*
NewStringCopyUTF8N
(
JSContext
*
cx
const
JS
:
:
UTF8Chars
&
utf8
JS
:
:
SmallestEncoding
encoding
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
extern
JSLinearString
*
NewStringCopyUTF8N
(
JSContext
*
cx
const
JS
:
:
UTF8Chars
&
utf8
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
inline
JSLinearString
*
NewStringCopyUTF8Z
(
JSContext
*
cx
const
JS
:
:
ConstUTF8CharsZ
utf8
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
{
return
NewStringCopyUTF8N
(
cx
JS
:
:
UTF8Chars
(
utf8
.
c_str
(
)
strlen
(
utf8
.
c_str
(
)
)
)
heap
)
;
}
template
<
typename
CharT
>
JSString
*
NewMaybeExternalString
(
JSContext
*
cx
const
CharT
*
s
size_t
n
const
JSExternalStringCallbacks
*
callbacks
bool
*
allocatedExternal
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
static_assert
(
sizeof
(
HashNumber
)
=
=
4
)
;
template
<
AllowGC
allowGC
>
extern
JSString
*
ConcatStrings
(
JSContext
*
cx
typename
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
left
typename
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
right
js
:
:
gc
:
:
Heap
heap
=
js
:
:
gc
:
:
Heap
:
:
Default
)
;
extern
bool
EqualStrings
(
JSContext
*
cx
JSString
*
str1
JSString
*
str2
bool
*
result
)
;
extern
bool
EqualStrings
(
JSContext
*
cx
JSLinearString
*
str1
JSLinearString
*
str2
bool
*
result
)
=
delete
;
extern
bool
EqualStrings
(
const
JSLinearString
*
str1
const
JSLinearString
*
str2
)
;
extern
bool
EqualChars
(
const
JSLinearString
*
str1
const
JSLinearString
*
str2
)
;
extern
int32_t
CompareChars
(
const
char16_t
*
s1
size_t
len1
const
JSLinearString
*
s2
)
;
extern
bool
CompareStrings
(
JSContext
*
cx
JSString
*
str1
JSString
*
str2
int32_t
*
result
)
;
extern
int32_t
CompareStrings
(
const
JSLinearString
*
str1
const
JSLinearString
*
str2
)
;
extern
bool
StringIsAscii
(
const
JSLinearString
*
str
)
;
extern
bool
StringEqualsAscii
(
const
JSLinearString
*
str
const
char
*
asciiBytes
)
;
extern
bool
StringEqualsAscii
(
const
JSLinearString
*
str
const
char
*
asciiBytes
size_t
length
)
;
template
<
size_t
N
>
bool
StringEqualsLiteral
(
const
JSLinearString
*
str
const
char
(
&
asciiBytes
)
[
N
]
)
{
MOZ_ASSERT
(
asciiBytes
[
N
-
1
]
=
=
'
\
0
'
)
;
return
StringEqualsAscii
(
str
asciiBytes
N
-
1
)
;
}
extern
int
StringFindPattern
(
const
JSLinearString
*
text
const
JSLinearString
*
pat
size_t
start
)
;
extern
bool
HasSubstringAt
(
const
JSLinearString
*
text
const
JSLinearString
*
pat
size_t
start
)
;
JSString
*
SubstringKernel
(
JSContext
*
cx
HandleString
str
int32_t
beginInt
int32_t
lengthInt
)
;
inline
js
:
:
HashNumber
HashStringChars
(
const
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
size_t
len
=
str
-
>
length
(
)
;
return
str
-
>
hasLatin1Chars
(
)
?
mozilla
:
:
HashString
(
str
-
>
latin1Chars
(
nogc
)
len
)
:
mozilla
:
:
HashString
(
str
-
>
twoByteChars
(
nogc
)
len
)
;
}
UniqueChars
EncodeAscii
(
JSContext
*
cx
JSString
*
str
)
;
UniqueChars
EncodeLatin1
(
JSContext
*
cx
JSString
*
str
)
;
enum
class
IdToPrintableBehavior
:
bool
{
IdIsIdentifier
IdIsPropertyKey
}
;
extern
UniqueChars
IdToPrintableUTF8
(
JSContext
*
cx
HandleId
id
IdToPrintableBehavior
behavior
)
;
template
<
AllowGC
allowGC
>
extern
JSString
*
ToStringSlow
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
arg
)
;
template
<
AllowGC
allowGC
>
static
MOZ_ALWAYS_INLINE
JSString
*
ToString
(
JSContext
*
cx
JS
:
:
HandleValue
v
)
{
if
(
v
.
isString
(
)
)
{
return
v
.
toString
(
)
;
}
return
ToStringSlow
<
allowGC
>
(
cx
v
)
;
}
inline
bool
ValueToStringBuilder
(
JSContext
*
cx
const
Value
&
v
StringBuilder
&
sb
)
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
getChar
(
JSContext
*
cx
size_t
index
char16_t
*
code
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
JSString
*
str
;
if
(
isRope
(
)
)
{
JSRope
*
rope
=
&
asRope
(
)
;
if
(
uint32_t
(
index
)
<
rope
-
>
leftChild
(
)
-
>
length
(
)
)
{
str
=
rope
-
>
leftChild
(
)
;
}
else
{
str
=
rope
-
>
rightChild
(
)
;
index
-
=
rope
-
>
leftChild
(
)
-
>
length
(
)
;
}
}
else
{
str
=
this
;
}
if
(
!
str
-
>
ensureLinear
(
cx
)
)
{
return
false
;
}
*
code
=
str
-
>
asLinear
(
)
.
latin1OrTwoByteChar
(
index
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
getCodePoint
(
JSContext
*
cx
size_t
index
char32_t
*
code
)
{
size_t
size
=
length
(
)
;
MOZ_ASSERT
(
index
<
size
)
;
char16_t
first
;
if
(
!
getChar
(
cx
index
&
first
)
)
{
return
false
;
}
if
(
!
js
:
:
unicode
:
:
IsLeadSurrogate
(
first
)
|
|
index
+
1
=
=
size
)
{
*
code
=
first
;
return
true
;
}
char16_t
second
;
if
(
!
getChar
(
cx
index
+
1
&
second
)
)
{
return
false
;
}
if
(
!
js
:
:
unicode
:
:
IsTrailSurrogate
(
second
)
)
{
*
code
=
first
;
return
true
;
}
*
code
=
js
:
:
unicode
:
:
UTF16Decode
(
first
second
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
JSLinearString
*
JSString
:
:
ensureLinear
(
JSContext
*
cx
)
{
return
isLinear
(
)
?
&
asLinear
(
)
:
asRope
(
)
.
flatten
(
cx
)
;
}
inline
JSLinearString
*
JSString
:
:
base
(
)
const
{
MOZ_ASSERT
(
hasBase
(
)
)
;
MOZ_ASSERT_IF
(
!
isAtomRef
(
)
!
d
.
s
.
u3
.
base
-
>
isInline
(
)
)
;
MOZ_ASSERT
(
d
.
s
.
u3
.
base
-
>
assertIsValidBase
(
)
)
;
if
(
isAtomRef
(
)
)
{
return
static_cast
<
JSLinearString
*
>
(
d
.
s
.
u3
.
atom
)
;
}
return
d
.
s
.
u3
.
base
;
}
inline
JSAtom
*
JSString
:
:
atom
(
)
const
{
MOZ_ASSERT
(
isAtomRef
(
)
)
;
return
d
.
s
.
u3
.
atom
;
}
inline
JSLinearString
*
JSString
:
:
nurseryBaseOrRelocOverlay
(
)
const
{
MOZ_ASSERT
(
hasBase
(
)
)
;
return
d
.
s
.
u3
.
base
;
}
inline
bool
JSString
:
:
canOwnDependentChars
(
)
const
{
return
isLinear
(
)
&
&
!
isInline
(
)
&
&
!
hasBase
(
)
;
}
inline
void
JSString
:
:
setBase
(
JSLinearString
*
newBase
)
{
MOZ_ASSERT
(
hasBase
(
)
)
;
MOZ_ASSERT
(
!
newBase
-
>
isInline
(
)
)
;
d
.
s
.
u3
.
base
=
newBase
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
nonInlineTwoByteChars
(
nogc
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
nonInlineLatin1Chars
(
nogc
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawTwoByteChars
(
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawLatin1Chars
(
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
js
:
:
UniquePtr
<
JS
:
:
Latin1Char
[
]
JS
:
:
FreePolicy
>
JSRope
:
:
copyChars
<
JS
:
:
Latin1Char
>
(
JSContext
*
maybecx
arena_id_t
destArenaId
)
const
{
return
copyLatin1Chars
(
maybecx
destArenaId
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
JS
:
:
UniqueTwoByteChars
JSRope
:
:
copyChars
<
char16_t
>
(
JSContext
*
maybecx
arena_id_t
destArenaId
)
const
{
return
copyTwoByteChars
(
maybecx
destArenaId
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSThinInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSThinInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSFatInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
static_assert
(
(
INLINE_EXTENSION_CHARS_LATIN1
*
sizeof
(
char
)
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
'
Latin1
characters
don
'
t
exactly
"
"
fill
subsequent
cells
and
thus
are
wasteful
"
)
;
static_assert
(
MAX_LENGTH_LATIN1
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageLatin1
)
)
/
sizeof
(
char
)
"
MAX_LENGTH_LATIN1
must
be
one
less
than
inline
Latin1
"
"
storage
count
"
)
;
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSFatInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
static_assert
(
(
INLINE_EXTENSION_CHARS_TWO_BYTE
*
sizeof
(
char16_t
)
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
'
char16_t
characters
don
'
t
exactly
"
"
fill
subsequent
cells
and
thus
are
wasteful
"
)
;
static_assert
(
MAX_LENGTH_TWO_BYTE
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageTwoByte
)
)
/
sizeof
(
char16_t
)
"
MAX_LENGTH_TWO_BYTE
must
be
one
less
than
inline
"
"
char16_t
storage
count
"
)
;
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
JSFatInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
JSFatInlineString
:
:
lengthFits
<
char16_t
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
js
:
:
ThinInlineAtom
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
js
:
:
ThinInlineAtom
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
js
:
:
FatInlineAtom
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
js
:
:
FatInlineAtom
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSAtom
:
:
lengthFitsInline
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
js
:
:
FatInlineAtom
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSAtom
:
:
lengthFitsInline
<
char16_t
>
(
size_t
length
)
{
return
js
:
:
FatInlineAtom
:
:
lengthFits
<
char16_t
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
void
JSString
:
:
setNonInlineChars
(
const
char16_t
*
chars
bool
usesStringBuffer
)
{
if
(
!
(
isAtomRef
(
)
&
&
atom
(
)
-
>
isInline
(
)
)
)
{
checkStringCharsArena
(
chars
usesStringBuffer
)
;
}
d
.
s
.
u2
.
nonInlineCharsTwoByte
=
chars
;
}
template
<
>
MOZ_ALWAYS_INLINE
void
JSString
:
:
setNonInlineChars
(
const
JS
:
:
Latin1Char
*
chars
bool
usesStringBuffer
)
{
if
(
!
(
isAtomRef
(
)
&
&
atom
(
)
-
>
isInline
(
)
)
)
{
checkStringCharsArena
(
chars
usesStringBuffer
)
;
}
d
.
s
.
u2
.
nonInlineCharsLatin1
=
chars
;
}
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
rawLatin1Chars
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
isInline
(
)
?
d
.
inlineStorageLatin1
:
d
.
s
.
u2
.
nonInlineCharsLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
rawTwoByteChars
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
isInline
(
)
?
d
.
inlineStorageTwoByte
:
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
inline
js
:
:
PropertyName
*
JSAtom
:
:
asPropertyName
(
)
{
MOZ_ASSERT
(
!
isIndex
(
)
)
;
return
static_cast
<
js
:
:
PropertyName
*
>
(
this
)
;
}
inline
bool
JSLinearString
:
:
isIndex
(
uint32_t
*
indexp
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
if
(
isAtom
(
)
)
{
return
asAtom
(
)
.
isIndex
(
indexp
)
;
}
if
(
JSString
:
:
hasIndexValue
(
)
)
{
*
indexp
=
getIndexValue
(
)
;
return
true
;
}
return
isIndexSlow
(
indexp
)
;
}
namespace
js
{
namespace
gc
{
template
<
>
inline
JSString
*
Cell
:
:
as
<
JSString
>
(
)
{
MOZ_ASSERT
(
is
<
JSString
>
(
)
)
;
return
reinterpret_cast
<
JSString
*
>
(
this
)
;
}
template
<
>
inline
JSString
*
TenuredCell
:
:
as
<
JSString
>
(
)
{
MOZ_ASSERT
(
is
<
JSString
>
(
)
)
;
return
reinterpret_cast
<
JSString
*
>
(
this
)
;
}
class
StringRelocationOverlay
:
public
RelocationOverlay
{
union
{
const
JS
:
:
Latin1Char
*
nurseryCharsLatin1
;
const
char16_t
*
nurseryCharsTwoByte
;
JSLinearString
*
nurseryBaseOrRelocOverlay
;
}
;
public
:
explicit
StringRelocationOverlay
(
Cell
*
dst
)
:
RelocationOverlay
(
dst
)
{
static_assert
(
sizeof
(
JSString
)
>
=
sizeof
(
StringRelocationOverlay
)
)
;
}
static
const
StringRelocationOverlay
*
fromCell
(
const
Cell
*
cell
)
{
return
static_cast
<
const
StringRelocationOverlay
*
>
(
cell
)
;
}
static
StringRelocationOverlay
*
fromCell
(
Cell
*
cell
)
{
return
static_cast
<
StringRelocationOverlay
*
>
(
cell
)
;
}
void
setNext
(
StringRelocationOverlay
*
next
)
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
next_
=
next
;
}
StringRelocationOverlay
*
next
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
(
StringRelocationOverlay
*
)
next_
;
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
savedNurseryChars
(
)
const
;
const
MOZ_ALWAYS_INLINE
JS
:
:
Latin1Char
*
savedNurseryCharsLatin1
(
)
const
{
MOZ_ASSERT
(
!
forwardingAddress
(
)
-
>
as
<
JSString
>
(
)
-
>
hasBase
(
)
)
;
return
nurseryCharsLatin1
;
}
const
MOZ_ALWAYS_INLINE
char16_t
*
savedNurseryCharsTwoByte
(
)
const
{
MOZ_ASSERT
(
!
forwardingAddress
(
)
-
>
as
<
JSString
>
(
)
-
>
hasBase
(
)
)
;
return
nurseryCharsTwoByte
;
}
JSLinearString
*
savedNurseryBaseOrRelocOverlay
(
)
const
{
MOZ_ASSERT
(
forwardingAddress
(
)
-
>
as
<
JSString
>
(
)
-
>
hasBase
(
)
)
;
return
nurseryBaseOrRelocOverlay
;
}
inline
static
StringRelocationOverlay
*
forwardCell
(
JSString
*
src
Cell
*
dst
)
{
MOZ_ASSERT
(
!
src
-
>
isForwarded
(
)
)
;
MOZ_ASSERT
(
!
dst
-
>
isForwarded
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
StringRelocationOverlay
*
overlay
;
if
(
src
-
>
hasBase
(
)
)
{
auto
nurseryBaseOrRelocOverlay
=
src
-
>
nurseryBaseOrRelocOverlay
(
)
;
overlay
=
new
(
src
)
StringRelocationOverlay
(
dst
)
;
overlay
-
>
nurseryBaseOrRelocOverlay
=
nurseryBaseOrRelocOverlay
;
}
else
if
(
src
-
>
canOwnDependentChars
(
)
)
{
if
(
src
-
>
hasTwoByteChars
(
)
)
{
auto
nurseryCharsTwoByte
=
src
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
;
overlay
=
new
(
src
)
StringRelocationOverlay
(
dst
)
;
overlay
-
>
nurseryCharsTwoByte
=
nurseryCharsTwoByte
;
}
else
{
auto
nurseryCharsLatin1
=
src
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
;
overlay
=
new
(
src
)
StringRelocationOverlay
(
dst
)
;
overlay
-
>
nurseryCharsLatin1
=
nurseryCharsLatin1
;
}
}
else
{
overlay
=
new
(
src
)
StringRelocationOverlay
(
dst
)
;
}
return
overlay
;
}
}
;
template
<
>
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
StringRelocationOverlay
:
:
savedNurseryChars
(
)
const
{
return
savedNurseryCharsLatin1
(
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
char16_t
*
StringRelocationOverlay
:
:
savedNurseryChars
(
)
const
{
return
savedNurseryCharsTwoByte
(
)
;
}
}
}
#
endif
