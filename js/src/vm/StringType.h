#
ifndef
vm_StringType_h
#
define
vm_StringType_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
builtin
/
String
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
Printer
.
h
"
class
JSDependentString
;
class
JSExtensibleString
;
class
JSExternalString
;
class
JSInlineString
;
class
JSRope
;
namespace
js
{
class
AutoStableStringChars
;
class
StaticStrings
;
class
PropertyName
;
static
const
size_t
UINT32_CHAR_BUFFER_LENGTH
=
sizeof
(
"
4294967295
"
)
-
1
;
}
class
JSString
:
public
js
:
:
gc
:
:
Cell
{
protected
:
static
const
size_t
NUM_INLINE_CHARS_LATIN1
=
2
*
sizeof
(
void
*
)
/
sizeof
(
JS
:
:
Latin1Char
)
;
static
const
size_t
NUM_INLINE_CHARS_TWO_BYTE
=
2
*
sizeof
(
void
*
)
/
sizeof
(
char16_t
)
;
struct
Data
{
union
{
struct
{
uint32_t
flags
;
uint32_t
length
;
}
;
uintptr_t
flattenData
;
}
u1
;
union
{
union
{
JS
:
:
Latin1Char
inlineStorageLatin1
[
NUM_INLINE_CHARS_LATIN1
]
;
char16_t
inlineStorageTwoByte
[
NUM_INLINE_CHARS_TWO_BYTE
]
;
}
;
struct
{
union
{
const
JS
:
:
Latin1Char
*
nonInlineCharsLatin1
;
const
char16_t
*
nonInlineCharsTwoByte
;
JSString
*
left
;
}
u2
;
union
{
JSLinearString
*
base
;
JSString
*
right
;
size_t
capacity
;
const
JSStringFinalizer
*
externalFinalizer
;
}
u3
;
}
s
;
}
;
}
d
;
public
:
static
const
uint32_t
NON_ATOM_BIT
=
JS_BIT
(
0
)
;
static
const
uint32_t
LINEAR_BIT
=
JS_BIT
(
1
)
;
static
const
uint32_t
HAS_BASE_BIT
=
JS_BIT
(
2
)
;
static
const
uint32_t
INLINE_CHARS_BIT
=
JS_BIT
(
3
)
;
static
const
uint32_t
DEPENDENT_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
HAS_BASE_BIT
;
static
const
uint32_t
UNDEPENDED_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
HAS_BASE_BIT
|
JS_BIT
(
4
)
;
static
const
uint32_t
EXTENSIBLE_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
JS_BIT
(
4
)
;
static
const
uint32_t
EXTERNAL_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
JS_BIT
(
5
)
;
static
const
uint32_t
FAT_INLINE_MASK
=
INLINE_CHARS_BIT
|
JS_BIT
(
4
)
;
static
const
uint32_t
PERMANENT_ATOM_MASK
=
NON_ATOM_BIT
|
JS_BIT
(
5
)
;
static
const
uint32_t
PERMANENT_ATOM_FLAGS
=
JS_BIT
(
5
)
;
static
const
uint32_t
INIT_THIN_INLINE_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
INLINE_CHARS_BIT
;
static
const
uint32_t
INIT_FAT_INLINE_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
|
FAT_INLINE_MASK
;
static
const
uint32_t
INIT_ROPE_FLAGS
=
NON_ATOM_BIT
;
static
const
uint32_t
INIT_FLAT_FLAGS
=
NON_ATOM_BIT
|
LINEAR_BIT
;
static
const
uint32_t
TYPE_FLAGS_MASK
=
JS_BIT
(
6
)
-
1
;
static
const
uint32_t
LATIN1_CHARS_BIT
=
JS_BIT
(
6
)
;
static
const
uint32_t
INDEX_VALUE_BIT
=
JS_BIT
(
7
)
;
static
const
uint32_t
INDEX_VALUE_SHIFT
=
16
;
static
const
uint32_t
PINNED_ATOM_BIT
=
JS_BIT
(
8
)
;
static
const
uint32_t
MAX_LENGTH
=
js
:
:
MaxStringLength
;
static
const
JS
:
:
Latin1Char
MAX_LATIN1_CHAR
=
0xff
;
static
inline
bool
validateLength
(
JSContext
*
maybecx
size_t
length
)
;
static
void
staticAsserts
(
)
{
static_assert
(
JSString
:
:
MAX_LENGTH
<
UINT32_MAX
"
Length
must
fit
in
32
bits
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
+
NUM_INLINE_CHARS_LATIN1
*
sizeof
(
char
)
)
"
Inline
Latin1
chars
must
fit
in
a
JSString
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
+
NUM_INLINE_CHARS_TWO_BYTE
*
sizeof
(
char16_t
)
)
"
Inline
char16_t
chars
must
fit
in
a
JSString
"
)
;
using
JS
:
:
shadow
:
:
String
;
static_assert
(
offsetof
(
JSString
d
.
u1
.
length
)
=
=
offsetof
(
String
length
)
"
shadow
:
:
String
length
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
u1
.
flags
)
=
=
offsetof
(
String
flags
)
"
shadow
:
:
String
flags
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
=
=
offsetof
(
String
nonInlineCharsLatin1
)
"
shadow
:
:
String
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
String
nonInlineCharsTwoByte
)
"
shadow
:
:
String
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u3
.
externalFinalizer
)
=
=
offsetof
(
String
externalFinalizer
)
"
shadow
:
:
String
externalFinalizer
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
=
=
offsetof
(
String
inlineStorageLatin1
)
"
shadow
:
:
String
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
=
=
offsetof
(
String
inlineStorageTwoByte
)
"
shadow
:
:
String
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
NON_ATOM_BIT
=
=
String
:
:
NON_ATOM_BIT
"
shadow
:
:
String
:
:
NON_ATOM_BIT
must
match
JSString
:
:
NON_ATOM_BIT
"
)
;
static_assert
(
LINEAR_BIT
=
=
String
:
:
LINEAR_BIT
"
shadow
:
:
String
:
:
LINEAR_BIT
must
match
JSString
:
:
LINEAR_BIT
"
)
;
static_assert
(
INLINE_CHARS_BIT
=
=
String
:
:
INLINE_CHARS_BIT
"
shadow
:
:
String
:
:
INLINE_CHARS_BIT
must
match
JSString
:
:
INLINE_CHARS_BIT
"
)
;
static_assert
(
LATIN1_CHARS_BIT
=
=
String
:
:
LATIN1_CHARS_BIT
"
shadow
:
:
String
:
:
LATIN1_CHARS_BIT
must
match
JSString
:
:
LATIN1_CHARS_BIT
"
)
;
static_assert
(
TYPE_FLAGS_MASK
=
=
String
:
:
TYPE_FLAGS_MASK
"
shadow
:
:
String
:
:
TYPE_FLAGS_MASK
must
match
JSString
:
:
TYPE_FLAGS_MASK
"
)
;
static_assert
(
EXTERNAL_FLAGS
=
=
String
:
:
EXTERNAL_FLAGS
"
shadow
:
:
String
:
:
EXTERNAL_FLAGS
must
match
JSString
:
:
EXTERNAL_FLAGS
"
)
;
}
friend
class
JSRope
;
friend
class
js
:
:
gc
:
:
RelocationOverlay
;
protected
:
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
void
setNonInlineChars
(
const
CharT
*
chars
)
;
public
:
MOZ_ALWAYS_INLINE
size_t
length
(
)
const
{
return
d
.
u1
.
length
;
}
MOZ_ALWAYS_INLINE
bool
empty
(
)
const
{
return
d
.
u1
.
length
=
=
0
;
}
inline
bool
getChar
(
JSContext
*
cx
size_t
index
char16_t
*
code
)
;
bool
hasLatin1Chars
(
)
const
{
return
d
.
u1
.
flags
&
LATIN1_CHARS_BIT
;
}
bool
hasTwoByteChars
(
)
const
{
return
!
(
d
.
u1
.
flags
&
LATIN1_CHARS_BIT
)
;
}
bool
hasIndexValue
(
)
const
{
return
d
.
u1
.
flags
&
INDEX_VALUE_BIT
;
}
uint32_t
getIndexValue
(
)
const
{
MOZ_ASSERT
(
hasIndexValue
(
)
)
;
MOZ_ASSERT
(
isFlat
(
)
)
;
return
d
.
u1
.
flags
>
>
INDEX_VALUE_SHIFT
;
}
inline
JSLinearString
*
ensureLinear
(
JSContext
*
cx
)
;
JSFlatString
*
ensureFlat
(
JSContext
*
cx
)
;
static
bool
ensureLinear
(
JSContext
*
cx
JSString
*
str
)
{
return
str
-
>
ensureLinear
(
cx
)
!
=
nullptr
;
}
MOZ_ALWAYS_INLINE
bool
isRope
(
)
const
{
return
!
(
d
.
u1
.
flags
&
LINEAR_BIT
)
;
}
MOZ_ALWAYS_INLINE
JSRope
&
asRope
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
return
*
(
JSRope
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isLinear
(
)
const
{
return
d
.
u1
.
flags
&
LINEAR_BIT
;
}
MOZ_ALWAYS_INLINE
JSLinearString
&
asLinear
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
*
(
JSLinearString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isDependent
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
DEPENDENT_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSDependentString
&
asDependent
(
)
const
{
MOZ_ASSERT
(
isDependent
(
)
)
;
return
*
(
JSDependentString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isFlat
(
)
const
{
return
isLinear
(
)
&
&
!
isDependent
(
)
&
&
!
isExternal
(
)
;
}
MOZ_ALWAYS_INLINE
JSFlatString
&
asFlat
(
)
const
{
MOZ_ASSERT
(
isFlat
(
)
)
;
return
*
(
JSFlatString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isExtensible
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
EXTENSIBLE_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExtensibleString
&
asExtensible
(
)
const
{
MOZ_ASSERT
(
isExtensible
(
)
)
;
return
*
(
JSExtensibleString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isInline
(
)
const
{
return
d
.
u1
.
flags
&
INLINE_CHARS_BIT
;
}
MOZ_ALWAYS_INLINE
JSInlineString
&
asInline
(
)
const
{
MOZ_ASSERT
(
isInline
(
)
)
;
return
*
(
JSInlineString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isFatInline
(
)
const
{
return
(
d
.
u1
.
flags
&
FAT_INLINE_MASK
)
=
=
FAT_INLINE_MASK
;
}
bool
isExternal
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
EXTERNAL_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExternalString
&
asExternal
(
)
const
{
MOZ_ASSERT
(
isExternal
(
)
)
;
return
*
(
JSExternalString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isUndepended
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
UNDEPENDED_FLAGS
;
}
MOZ_ALWAYS_INLINE
bool
isAtom
(
)
const
{
return
!
(
d
.
u1
.
flags
&
NON_ATOM_BIT
)
;
}
MOZ_ALWAYS_INLINE
bool
isPermanentAtom
(
)
const
{
return
(
d
.
u1
.
flags
&
PERMANENT_ATOM_MASK
)
=
=
PERMANENT_ATOM_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSAtom
&
asAtom
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
)
;
return
*
(
JSAtom
*
)
this
;
}
MOZ_ALWAYS_INLINE
static
bool
nurseryCellIsString
(
js
:
:
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
!
cell
-
>
isTenured
(
)
)
;
return
!
static_cast
<
JSString
*
>
(
cell
)
-
>
isAtom
(
)
;
}
static
bool
fillWithRepresentatives
(
JSContext
*
cx
js
:
:
HandleArrayObject
array
)
;
inline
bool
hasBase
(
)
const
{
return
d
.
u1
.
flags
&
HAS_BASE_BIT
;
}
inline
JSLinearString
*
base
(
)
const
;
void
traceBase
(
JSTracer
*
trc
)
;
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
static
size_t
offsetOfLength
(
)
{
return
offsetof
(
JSString
d
.
u1
.
length
)
;
}
static
size_t
offsetOfFlags
(
)
{
return
offsetof
(
JSString
d
.
u1
.
flags
)
;
}
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfNonInlineChars
(
)
{
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
"
nonInlineCharsTwoByte
and
nonInlineCharsLatin1
must
have
same
offset
"
)
;
return
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
;
}
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
String
;
JS
:
:
Zone
*
zone
(
)
const
{
if
(
isTenured
(
)
)
{
if
(
isPermanentAtom
(
)
)
return
zoneFromAnyThread
(
)
;
return
asTenured
(
)
.
zone
(
)
;
}
return
js
:
:
Nursery
:
:
getStringZone
(
this
)
;
}
JS
:
:
Zone
*
zoneFromAnyThread
(
)
const
{
if
(
isTenured
(
)
)
return
asTenured
(
)
.
zoneFromAnyThread
(
)
;
return
js
:
:
Nursery
:
:
getStringZone
(
this
)
;
}
void
fixupAfterMovingGC
(
)
{
}
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
using
js
:
:
gc
:
:
AllocKind
;
AllocKind
kind
;
if
(
isAtom
(
)
)
if
(
isFatInline
(
)
)
kind
=
AllocKind
:
:
FAT_INLINE_ATOM
;
else
kind
=
AllocKind
:
:
ATOM
;
else
if
(
isFatInline
(
)
)
kind
=
AllocKind
:
:
FAT_INLINE_STRING
;
else
if
(
isExternal
(
)
)
kind
=
AllocKind
:
:
EXTERNAL_STRING
;
else
kind
=
AllocKind
:
:
STRING
;
#
if
DEBUG
if
(
isTenured
(
)
)
{
AllocKind
tenuredKind
=
asTenured
(
)
.
getAllocKind
(
)
;
MOZ_ASSERT
(
kind
=
=
tenuredKind
|
|
(
tenuredKind
=
=
AllocKind
:
:
EXTERNAL_STRING
&
&
kind
=
=
AllocKind
:
:
STRING
)
)
;
}
#
endif
return
kind
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
js
:
:
GenericPrinter
&
out
)
;
void
dumpNoNewline
(
js
:
:
GenericPrinter
&
out
)
;
void
dumpCharsNoNewline
(
js
:
:
GenericPrinter
&
out
)
;
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
void
dumpRepresentationHeader
(
js
:
:
GenericPrinter
&
out
const
char
*
subclass
)
const
;
template
<
typename
CharT
>
static
void
dumpChars
(
const
CharT
*
s
size_t
len
js
:
:
GenericPrinter
&
out
)
;
bool
equals
(
const
char
*
s
)
;
#
endif
void
traceChildren
(
JSTracer
*
trc
)
;
static
MOZ_ALWAYS_INLINE
void
readBarrier
(
JSString
*
thing
)
{
if
(
thing
-
>
isPermanentAtom
(
)
|
|
js
:
:
gc
:
:
IsInsideNursery
(
thing
)
)
return
;
js
:
:
gc
:
:
TenuredCell
:
:
readBarrier
(
&
thing
-
>
asTenured
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
void
writeBarrierPre
(
JSString
*
thing
)
{
if
(
!
thing
|
|
thing
-
>
isPermanentAtom
(
)
|
|
js
:
:
gc
:
:
IsInsideNursery
(
thing
)
)
return
;
js
:
:
gc
:
:
TenuredCell
:
:
writeBarrierPre
(
&
thing
-
>
asTenured
(
)
)
;
}
static
void
addCellAddressToStoreBuffer
(
js
:
:
gc
:
:
StoreBuffer
*
buffer
js
:
:
gc
:
:
Cell
*
*
cellp
)
{
buffer
-
>
putCell
(
cellp
)
;
}
static
void
removeCellAddressFromStoreBuffer
(
js
:
:
gc
:
:
StoreBuffer
*
buffer
js
:
:
gc
:
:
Cell
*
*
cellp
)
{
buffer
-
>
unputCell
(
cellp
)
;
}
static
void
writeBarrierPost
(
void
*
cellp
JSString
*
prev
JSString
*
next
)
{
MOZ_ASSERT
(
cellp
)
;
js
:
:
gc
:
:
StoreBuffer
*
buffer
;
if
(
next
&
&
(
buffer
=
next
-
>
storeBuffer
(
)
)
)
{
if
(
prev
&
&
prev
-
>
storeBuffer
(
)
)
return
;
buffer
-
>
putCell
(
static_cast
<
js
:
:
gc
:
:
Cell
*
*
>
(
cellp
)
)
;
return
;
}
if
(
prev
&
&
(
buffer
=
prev
-
>
storeBuffer
(
)
)
)
buffer
-
>
unputCell
(
static_cast
<
js
:
:
gc
:
:
Cell
*
*
>
(
cellp
)
)
;
}
private
:
JSString
(
)
=
delete
;
JSString
(
const
JSString
&
other
)
=
delete
;
void
operator
=
(
const
JSString
&
other
)
=
delete
;
}
;
class
JSRope
:
public
JSString
{
template
<
typename
CharT
>
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
copyCharsInternal
(
JSContext
*
cx
bool
nullTerminate
)
const
;
enum
UsingBarrier
{
WithIncrementalBarrier
NoBarrier
}
;
template
<
UsingBarrier
b
typename
CharT
>
JSFlatString
*
flattenInternal
(
JSContext
*
cx
)
;
template
<
UsingBarrier
b
>
JSFlatString
*
flattenInternal
(
JSContext
*
cx
)
;
friend
class
JSString
;
JSFlatString
*
flatten
(
JSContext
*
cx
)
;
void
init
(
JSContext
*
cx
JSString
*
left
JSString
*
right
size_t
length
)
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSRope
*
new_
(
JSContext
*
cx
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
left
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
right
size_t
length
js
:
:
gc
:
:
InitialHeap
=
js
:
:
gc
:
:
DefaultHeap
)
;
js
:
:
UniquePtr
<
JS
:
:
Latin1Char
[
]
JS
:
:
FreePolicy
>
copyLatin1Chars
(
JSContext
*
maybecx
)
const
;
JS
:
:
UniqueTwoByteChars
copyTwoByteChars
(
JSContext
*
maybecx
)
const
;
js
:
:
UniquePtr
<
JS
:
:
Latin1Char
[
]
JS
:
:
FreePolicy
>
copyLatin1CharsZ
(
JSContext
*
maybecx
)
const
;
JS
:
:
UniqueTwoByteChars
copyTwoByteCharsZ
(
JSContext
*
maybecx
)
const
;
template
<
typename
CharT
>
js
:
:
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
copyChars
(
JSContext
*
maybecx
)
const
;
MOZ_MUST_USE
bool
hash
(
uint32_t
*
outhHash
)
const
;
JSString
*
leftChild
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
return
d
.
s
.
u2
.
left
;
}
JSString
*
rightChild
(
)
const
{
MOZ_ASSERT
(
isRope
(
)
)
;
return
d
.
s
.
u3
.
right
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfLeft
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u2
.
left
)
;
}
static
size_t
offsetOfRight
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u3
.
right
)
;
}
}
;
static_assert
(
sizeof
(
JSRope
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSLinearString
:
public
JSString
{
friend
class
JSString
;
friend
class
js
:
:
AutoStableStringChars
;
friend
class
js
:
:
TenuringTracer
;
JSLinearString
*
ensureLinear
(
JSContext
*
cx
)
=
delete
;
bool
isLinear
(
)
const
=
delete
;
JSLinearString
&
asLinear
(
)
const
=
delete
;
protected
:
MOZ_ALWAYS_INLINE
void
*
nonInlineCharsRaw
(
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
static_assert
(
offsetof
(
JSLinearString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
JSLinearString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
"
nonInlineCharsTwoByte
and
nonInlineCharsLatin1
must
have
same
offset
"
)
;
return
(
void
*
)
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
rawLatin1Chars
(
)
const
;
MOZ_ALWAYS_INLINE
const
char16_t
*
rawTwoByteChars
(
)
const
;
public
:
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
;
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
nonInlineLatin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
nonInlineTwoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
!
isInline
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
CharT
*
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
;
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
latin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawLatin1Chars
(
)
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
twoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawTwoByteChars
(
)
;
}
mozilla
:
:
Range
<
const
JS
:
:
Latin1Char
>
latin1Range
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
mozilla
:
:
Range
<
const
JS
:
:
Latin1Char
>
(
latin1Chars
(
nogc
)
length
(
)
)
;
}
mozilla
:
:
Range
<
const
char16_t
>
twoByteRange
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
mozilla
:
:
Range
<
const
char16_t
>
(
twoByteChars
(
nogc
)
length
(
)
)
;
}
MOZ_ALWAYS_INLINE
char16_t
latin1OrTwoByteChar
(
size_t
index
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
index
<
length
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
return
hasLatin1Chars
(
)
?
latin1Chars
(
nogc
)
[
index
]
:
twoByteChars
(
nogc
)
[
index
]
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentationChars
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSLinearString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSDependentString
:
public
JSLinearString
{
friend
class
JSString
;
JSFlatString
*
undepend
(
JSContext
*
cx
)
;
template
<
typename
CharT
>
JSFlatString
*
undependInternal
(
JSContext
*
cx
)
;
void
init
(
JSContext
*
cx
JSLinearString
*
base
size_t
start
size_t
length
)
;
bool
isDependent
(
)
const
=
delete
;
JSDependentString
&
asDependent
(
)
const
=
delete
;
MOZ_ALWAYS_INLINE
mozilla
:
:
Maybe
<
size_t
>
baseOffset
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isDependent
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
MOZ_UNLIKELY
(
base
(
)
-
>
isUndepended
(
)
)
)
return
mozilla
:
:
Nothing
(
)
;
size_t
offset
;
if
(
hasTwoByteChars
(
)
)
offset
=
twoByteChars
(
nogc
)
-
base
(
)
-
>
twoByteChars
(
nogc
)
;
else
offset
=
latin1Chars
(
nogc
)
-
base
(
)
-
>
latin1Chars
(
nogc
)
;
MOZ_ASSERT
(
offset
<
base
(
)
-
>
length
(
)
)
;
return
mozilla
:
:
Some
(
offset
)
;
}
public
:
static
inline
JSLinearString
*
new_
(
JSContext
*
cx
JSLinearString
*
base
size_t
start
size_t
length
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
inline
static
size_t
offsetOfBase
(
)
{
return
offsetof
(
JSDependentString
d
.
s
.
u3
.
base
)
;
}
}
;
static_assert
(
sizeof
(
JSDependentString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSFlatString
:
public
JSLinearString
{
JSFlatString
*
ensureFlat
(
JSContext
*
cx
)
=
delete
;
bool
isFlat
(
)
const
=
delete
;
JSFlatString
&
asFlat
(
)
const
=
delete
;
template
<
typename
CharT
>
static
bool
isIndexSlow
(
const
CharT
*
s
size_t
length
uint32_t
*
indexp
)
;
void
init
(
const
char16_t
*
chars
size_t
length
)
;
void
init
(
const
JS
:
:
Latin1Char
*
chars
size_t
length
)
;
public
:
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
static
inline
JSFlatString
*
new_
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
)
;
inline
bool
isIndexSlow
(
uint32_t
*
indexp
)
const
{
MOZ_ASSERT
(
JSString
:
:
isFlat
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
hasLatin1Chars
(
)
)
{
const
JS
:
:
Latin1Char
*
s
=
latin1Chars
(
nogc
)
;
return
mozilla
:
:
IsAsciiDigit
(
*
s
)
&
&
isIndexSlow
(
s
length
(
)
indexp
)
;
}
const
char16_t
*
s
=
twoByteChars
(
nogc
)
;
return
mozilla
:
:
IsAsciiDigit
(
*
s
)
&
&
isIndexSlow
(
s
length
(
)
indexp
)
;
}
inline
bool
isIndex
(
uint32_t
*
indexp
)
const
{
MOZ_ASSERT
(
JSString
:
:
isFlat
(
)
)
;
if
(
JSString
:
:
hasIndexValue
(
)
)
{
*
indexp
=
getIndexValue
(
)
;
return
true
;
}
return
isIndexSlow
(
indexp
)
;
}
inline
void
maybeInitializeIndex
(
uint32_t
index
bool
allowAtom
=
false
)
{
MOZ_ASSERT
(
JSString
:
:
isFlat
(
)
)
;
MOZ_ASSERT_IF
(
hasIndexValue
(
)
getIndexValue
(
)
=
=
index
)
;
MOZ_ASSERT_IF
(
!
allowAtom
!
isAtom
(
)
)
;
if
(
hasIndexValue
(
)
|
|
index
>
UINT16_MAX
)
return
;
mozilla
:
:
DebugOnly
<
uint32_t
>
containedIndex
;
MOZ_ASSERT
(
isIndexSlow
(
&
containedIndex
)
)
;
MOZ_ASSERT
(
index
=
=
containedIndex
)
;
d
.
u1
.
flags
|
=
(
index
<
<
INDEX_VALUE_SHIFT
)
|
INDEX_VALUE_BIT
;
}
inline
js
:
:
PropertyName
*
toPropertyName
(
JSContext
*
cx
)
;
MOZ_ALWAYS_INLINE
JSAtom
*
morphAtomizedStringIntoAtom
(
js
:
:
HashNumber
hash
)
;
MOZ_ALWAYS_INLINE
JSAtom
*
morphAtomizedStringIntoPermanentAtom
(
js
:
:
HashNumber
hash
)
;
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSFlatString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSExtensibleString
:
public
JSFlatString
{
bool
isExtensible
(
)
const
=
delete
;
JSExtensibleString
&
asExtensible
(
)
const
=
delete
;
public
:
MOZ_ALWAYS_INLINE
size_t
capacity
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isExtensible
(
)
)
;
return
d
.
s
.
u3
.
capacity
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSExtensibleString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSInlineString
:
public
JSFlatString
{
public
:
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
latin1Chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isInline
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
inlineStorageLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
twoByteChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
JSString
:
:
isInline
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
inlineStorageTwoByte
;
}
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
private
:
friend
class
js
:
:
jit
:
:
MacroAssembler
;
static
size_t
offsetOfInlineStorage
(
)
{
return
offsetof
(
JSInlineString
d
.
inlineStorageTwoByte
)
;
}
}
;
static_assert
(
sizeof
(
JSInlineString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSThinInlineString
:
public
JSInlineString
{
public
:
static
const
size_t
MAX_LENGTH_LATIN1
=
NUM_INLINE_CHARS_LATIN1
-
1
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
NUM_INLINE_CHARS_TWO_BYTE
-
1
;
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSThinInlineString
*
new_
(
JSContext
*
cx
)
;
template
<
typename
CharT
>
inline
CharT
*
init
(
size_t
length
)
;
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
}
;
static_assert
(
sizeof
(
JSThinInlineString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSFatInlineString
:
public
JSInlineString
{
static
const
size_t
INLINE_EXTENSION_CHARS_LATIN1
=
24
-
NUM_INLINE_CHARS_LATIN1
;
static
const
size_t
INLINE_EXTENSION_CHARS_TWO_BYTE
=
12
-
NUM_INLINE_CHARS_TWO_BYTE
;
protected
:
union
{
char
inlineStorageExtensionLatin1
[
INLINE_EXTENSION_CHARS_LATIN1
]
;
char16_t
inlineStorageExtensionTwoByte
[
INLINE_EXTENSION_CHARS_TWO_BYTE
]
;
}
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSFatInlineString
*
new_
(
JSContext
*
cx
)
;
static
const
size_t
MAX_LENGTH_LATIN1
=
JSString
:
:
NUM_INLINE_CHARS_LATIN1
+
INLINE_EXTENSION_CHARS_LATIN1
-
1
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
JSString
:
:
NUM_INLINE_CHARS_TWO_BYTE
+
INLINE_EXTENSION_CHARS_TWO_BYTE
-
1
;
template
<
typename
CharT
>
inline
CharT
*
init
(
size_t
length
)
;
template
<
typename
CharT
>
static
bool
lengthFits
(
size_t
length
)
;
MOZ_ALWAYS_INLINE
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
}
;
static_assert
(
sizeof
(
JSFatInlineString
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
shouldn
'
t
waste
space
up
to
the
next
cell
"
"
boundary
"
)
;
class
JSExternalString
:
public
JSLinearString
{
void
init
(
const
char16_t
*
chars
size_t
length
const
JSStringFinalizer
*
fin
)
;
bool
isExternal
(
)
const
=
delete
;
JSExternalString
&
asExternal
(
)
const
=
delete
;
public
:
static
inline
JSExternalString
*
new_
(
JSContext
*
cx
const
char16_t
*
chars
size_t
length
const
JSStringFinalizer
*
fin
)
;
const
JSStringFinalizer
*
externalFinalizer
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isExternal
(
)
)
;
return
d
.
s
.
u3
.
externalFinalizer
;
}
const
char16_t
*
twoByteChars
(
)
const
{
return
rawTwoByteChars
(
)
;
}
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
JSFlatString
*
ensureFlat
(
JSContext
*
cx
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpRepresentation
(
js
:
:
GenericPrinter
&
out
int
indent
)
const
;
#
endif
}
;
static_assert
(
sizeof
(
JSExternalString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSUndependedString
:
public
JSFlatString
{
}
;
static_assert
(
sizeof
(
JSUndependedString
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
class
JSAtom
:
public
JSFlatString
{
bool
isAtom
(
)
const
=
delete
;
JSAtom
&
asAtom
(
)
const
=
delete
;
public
:
inline
js
:
:
PropertyName
*
asPropertyName
(
)
;
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
MOZ_ALWAYS_INLINE
bool
isPermanent
(
)
const
{
return
JSString
:
:
isPermanentAtom
(
)
;
}
MOZ_ALWAYS_INLINE
void
morphIntoPermanentAtom
(
)
{
MOZ_ASSERT
(
static_cast
<
JSString
*
>
(
this
)
-
>
isAtom
(
)
)
;
d
.
u1
.
flags
|
=
PERMANENT_ATOM_FLAGS
|
PINNED_ATOM_BIT
;
}
MOZ_ALWAYS_INLINE
bool
isPinned
(
)
const
{
return
d
.
u1
.
flags
&
PINNED_ATOM_BIT
;
}
MOZ_ALWAYS_INLINE
void
setPinned
(
)
{
MOZ_ASSERT
(
static_cast
<
JSString
*
>
(
this
)
-
>
isAtom
(
)
)
;
MOZ_ASSERT
(
!
isPinned
(
)
)
;
d
.
u1
.
flags
|
=
PINNED_ATOM_BIT
;
}
inline
js
:
:
HashNumber
hash
(
)
const
;
inline
void
initHash
(
js
:
:
HashNumber
hash
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
js
:
:
GenericPrinter
&
out
)
;
void
dump
(
)
;
#
endif
}
;
static_assert
(
sizeof
(
JSAtom
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
namespace
js
{
class
NormalAtom
:
public
JSAtom
{
protected
:
HashNumber
hash_
;
public
:
HashNumber
hash
(
)
const
{
return
hash_
;
}
void
initHash
(
HashNumber
hash
)
{
hash_
=
hash
;
}
}
;
static_assert
(
sizeof
(
NormalAtom
)
=
=
sizeof
(
JSString
)
+
sizeof
(
uint64_t
)
"
NormalAtom
must
have
size
of
a
string
+
HashNumber
"
"
aligned
to
gc
:
:
CellAlignBytes
"
)
;
class
FatInlineAtom
:
public
JSAtom
{
protected
:
char
inlineStorage_
[
sizeof
(
JSFatInlineString
)
-
sizeof
(
JSString
)
]
;
HashNumber
hash_
;
public
:
HashNumber
hash
(
)
const
{
return
hash_
;
}
void
initHash
(
HashNumber
hash
)
{
hash_
=
hash
;
}
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
}
;
static_assert
(
sizeof
(
FatInlineAtom
)
=
=
sizeof
(
JSFatInlineString
)
+
sizeof
(
uint64_t
)
"
FatInlineAtom
must
have
size
of
a
fat
inline
string
+
HashNumber
"
"
aligned
to
gc
:
:
CellAlignBytes
"
)
;
}
inline
js
:
:
HashNumber
JSAtom
:
:
hash
(
)
const
{
if
(
isFatInline
(
)
)
return
static_cast
<
const
js
:
:
FatInlineAtom
*
>
(
this
)
-
>
hash
(
)
;
return
static_cast
<
const
js
:
:
NormalAtom
*
>
(
this
)
-
>
hash
(
)
;
}
inline
void
JSAtom
:
:
initHash
(
js
:
:
HashNumber
hash
)
{
if
(
isFatInline
(
)
)
return
static_cast
<
js
:
:
FatInlineAtom
*
>
(
this
)
-
>
initHash
(
hash
)
;
return
static_cast
<
js
:
:
NormalAtom
*
>
(
this
)
-
>
initHash
(
hash
)
;
}
MOZ_ALWAYS_INLINE
JSAtom
*
JSFlatString
:
:
morphAtomizedStringIntoAtom
(
js
:
:
HashNumber
hash
)
{
MOZ_ASSERT
(
!
isAtom
(
)
)
;
d
.
u1
.
flags
&
=
~
NON_ATOM_BIT
;
JSAtom
*
atom
=
&
asAtom
(
)
;
atom
-
>
initHash
(
hash
)
;
return
atom
;
}
MOZ_ALWAYS_INLINE
JSAtom
*
JSFlatString
:
:
morphAtomizedStringIntoPermanentAtom
(
js
:
:
HashNumber
hash
)
{
MOZ_ASSERT
(
!
isAtom
(
)
)
;
d
.
u1
.
flags
|
=
PERMANENT_ATOM_FLAGS
|
PINNED_ATOM_BIT
;
d
.
u1
.
flags
&
=
~
NON_ATOM_BIT
;
JSAtom
*
atom
=
&
asAtom
(
)
;
atom
-
>
initHash
(
hash
)
;
return
atom
;
}
namespace
js
{
class
StaticStrings
{
private
:
static
const
size_t
SMALL_CHAR_LIMIT
=
128U
;
static
const
size_t
NUM_SMALL_CHARS
=
64U
;
JSAtom
*
length2StaticTable
[
NUM_SMALL_CHARS
*
NUM_SMALL_CHARS
]
=
{
}
;
public
:
static
const
size_t
UNIT_STATIC_LIMIT
=
256U
;
JSAtom
*
unitStaticTable
[
UNIT_STATIC_LIMIT
]
=
{
}
;
static
const
size_t
INT_STATIC_LIMIT
=
256U
;
JSAtom
*
intStaticTable
[
INT_STATIC_LIMIT
]
=
{
}
;
StaticStrings
(
)
=
default
;
bool
init
(
JSContext
*
cx
)
;
void
trace
(
JSTracer
*
trc
)
;
static
bool
hasUint
(
uint32_t
u
)
{
return
u
<
INT_STATIC_LIMIT
;
}
JSAtom
*
getUint
(
uint32_t
u
)
{
MOZ_ASSERT
(
hasUint
(
u
)
)
;
return
intStaticTable
[
u
]
;
}
static
bool
hasInt
(
int32_t
i
)
{
return
uint32_t
(
i
)
<
INT_STATIC_LIMIT
;
}
JSAtom
*
getInt
(
int32_t
i
)
{
MOZ_ASSERT
(
hasInt
(
i
)
)
;
return
getUint
(
uint32_t
(
i
)
)
;
}
static
bool
hasUnit
(
char16_t
c
)
{
return
c
<
UNIT_STATIC_LIMIT
;
}
JSAtom
*
getUnit
(
char16_t
c
)
{
MOZ_ASSERT
(
hasUnit
(
c
)
)
;
return
unitStaticTable
[
c
]
;
}
inline
JSLinearString
*
getUnitStringForElement
(
JSContext
*
cx
JSString
*
str
size_t
index
)
;
template
<
typename
CharT
>
static
bool
isStatic
(
const
CharT
*
chars
size_t
len
)
;
static
bool
isStatic
(
JSAtom
*
atom
)
;
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
JSAtom
*
lookup
(
const
CharT
*
chars
size_t
length
)
{
switch
(
length
)
{
case
1
:
{
char16_t
c
=
chars
[
0
]
;
if
(
c
<
UNIT_STATIC_LIMIT
)
return
getUnit
(
c
)
;
return
nullptr
;
}
case
2
:
if
(
fitsInSmallChar
(
chars
[
0
]
)
&
&
fitsInSmallChar
(
chars
[
1
]
)
)
return
getLength2
(
chars
[
0
]
chars
[
1
]
)
;
return
nullptr
;
case
3
:
static_assert
(
INT_STATIC_LIMIT
<
=
999
"
static
int
strings
assumed
below
to
be
at
most
"
"
three
digits
"
)
;
if
(
'
1
'
<
=
chars
[
0
]
&
&
chars
[
0
]
<
=
'
9
'
&
&
'
0
'
<
=
chars
[
1
]
&
&
chars
[
1
]
<
=
'
9
'
&
&
'
0
'
<
=
chars
[
2
]
&
&
chars
[
2
]
<
=
'
9
'
)
{
int
i
=
(
chars
[
0
]
-
'
0
'
)
*
100
+
(
chars
[
1
]
-
'
0
'
)
*
10
+
(
chars
[
2
]
-
'
0
'
)
;
if
(
unsigned
(
i
)
<
INT_STATIC_LIMIT
)
return
getInt
(
i
)
;
}
return
nullptr
;
}
return
nullptr
;
}
private
:
typedef
uint8_t
SmallChar
;
static
const
SmallChar
INVALID_SMALL_CHAR
=
-
1
;
static
bool
fitsInSmallChar
(
char16_t
c
)
{
return
c
<
SMALL_CHAR_LIMIT
&
&
toSmallChar
[
c
]
!
=
INVALID_SMALL_CHAR
;
}
static
const
SmallChar
toSmallChar
[
]
;
MOZ_ALWAYS_INLINE
JSAtom
*
getLength2
(
char16_t
c1
char16_t
c2
)
{
MOZ_ASSERT
(
fitsInSmallChar
(
c1
)
)
;
MOZ_ASSERT
(
fitsInSmallChar
(
c2
)
)
;
size_t
index
=
(
size_t
(
toSmallChar
[
c1
]
)
<
<
6
)
+
toSmallChar
[
c2
]
;
return
length2StaticTable
[
index
]
;
}
JSAtom
*
getLength2
(
uint32_t
u
)
{
MOZ_ASSERT
(
u
<
100
)
;
return
getLength2
(
'
0
'
+
u
/
10
'
0
'
+
u
%
10
)
;
}
}
;
class
PropertyName
:
public
JSAtom
{
private
:
PropertyName
*
asPropertyName
(
)
=
delete
;
}
;
static_assert
(
sizeof
(
PropertyName
)
=
=
sizeof
(
JSString
)
"
string
subclasses
must
be
binary
-
compatible
with
JSString
"
)
;
static
MOZ_ALWAYS_INLINE
jsid
NameToId
(
PropertyName
*
name
)
{
return
NON_INTEGER_ATOM_TO_JSID
(
name
)
;
}
using
PropertyNameVector
=
JS
:
:
GCVector
<
PropertyName
*
>
;
template
<
typename
CharT
>
void
CopyChars
(
CharT
*
dest
const
JSLinearString
&
str
)
;
static
inline
UniqueChars
StringToNewUTF8CharsZ
(
JSContext
*
maybecx
JSString
&
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
JSLinearString
*
linear
=
str
.
ensureLinear
(
maybecx
)
;
if
(
!
linear
)
return
nullptr
;
return
UniqueChars
(
linear
-
>
hasLatin1Chars
(
)
?
JS
:
:
CharsToNewUTF8CharsZ
(
maybecx
linear
-
>
latin1Range
(
nogc
)
)
.
c_str
(
)
:
JS
:
:
CharsToNewUTF8CharsZ
(
maybecx
linear
-
>
twoByteRange
(
nogc
)
)
.
c_str
(
)
)
;
}
template
<
typename
CharT
>
extern
JSFlatString
*
NewString
(
JSContext
*
cx
CharT
*
chars
size_t
length
)
;
template
<
typename
CharT
>
extern
JSFlatString
*
NewStringDontDeflate
(
JSContext
*
cx
CharT
*
chars
size_t
length
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSFlatString
*
NewString
(
JSContext
*
cx
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
chars
size_t
length
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSFlatString
*
NewStringDontDeflate
(
JSContext
*
cx
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
chars
size_t
length
)
;
extern
JSLinearString
*
NewDependentString
(
JSContext
*
cx
JSString
*
base
size_t
start
size_t
length
)
;
extern
JSFlatString
*
NewLatin1StringZ
(
JSContext
*
cx
UniqueChars
chars
)
;
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSFlatString
*
NewStringCopyN
(
JSContext
*
cx
const
CharT
*
s
size_t
n
)
;
template
<
js
:
:
AllowGC
allowGC
>
inline
JSFlatString
*
NewStringCopyN
(
JSContext
*
cx
const
char
*
s
size_t
n
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
reinterpret_cast
<
const
Latin1Char
*
>
(
s
)
n
)
;
}
template
<
js
:
:
AllowGC
allowGC
typename
CharT
>
extern
JSFlatString
*
NewStringCopyNDontDeflate
(
JSContext
*
cx
const
CharT
*
s
size_t
n
)
;
template
<
js
:
:
AllowGC
allowGC
>
inline
JSFlatString
*
NewStringCopyZ
(
JSContext
*
cx
const
char16_t
*
s
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
js_strlen
(
s
)
)
;
}
template
<
js
:
:
AllowGC
allowGC
>
inline
JSFlatString
*
NewStringCopyZ
(
JSContext
*
cx
const
char
*
s
)
{
return
NewStringCopyN
<
allowGC
>
(
cx
s
strlen
(
s
)
)
;
}
template
<
js
:
:
AllowGC
allowGC
>
extern
JSFlatString
*
NewStringCopyUTF8N
(
JSContext
*
cx
const
JS
:
:
UTF8Chars
utf8
)
;
template
<
js
:
:
AllowGC
allowGC
>
inline
JSFlatString
*
NewStringCopyUTF8Z
(
JSContext
*
cx
const
JS
:
:
ConstUTF8CharsZ
utf8
)
{
return
NewStringCopyUTF8N
<
allowGC
>
(
cx
JS
:
:
UTF8Chars
(
utf8
.
c_str
(
)
strlen
(
utf8
.
c_str
(
)
)
)
)
;
}
JSString
*
NewMaybeExternalString
(
JSContext
*
cx
const
char16_t
*
s
size_t
n
const
JSStringFinalizer
*
fin
bool
*
allocatedExternal
)
;
JS_STATIC_ASSERT
(
sizeof
(
HashNumber
)
=
=
4
)
;
template
<
AllowGC
allowGC
>
extern
JSString
*
ConcatStrings
(
JSContext
*
cx
typename
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
left
typename
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
right
)
;
extern
bool
EqualStrings
(
JSContext
*
cx
JSString
*
str1
JSString
*
str2
bool
*
result
)
;
extern
bool
EqualStrings
(
JSContext
*
cx
JSLinearString
*
str1
JSLinearString
*
str2
bool
*
result
)
=
delete
;
extern
bool
EqualStrings
(
JSLinearString
*
str1
JSLinearString
*
str2
)
;
extern
bool
EqualChars
(
JSLinearString
*
str1
JSLinearString
*
str2
)
;
extern
int32_t
CompareChars
(
const
char16_t
*
s1
size_t
len1
JSLinearString
*
s2
)
;
extern
bool
CompareStrings
(
JSContext
*
cx
JSString
*
str1
JSString
*
str2
int32_t
*
result
)
;
extern
int32_t
CompareAtoms
(
JSAtom
*
atom1
JSAtom
*
atom2
)
;
extern
bool
StringEqualsAscii
(
JSLinearString
*
str
const
char
*
asciiBytes
)
;
extern
int
StringFindPattern
(
JSLinearString
*
text
JSLinearString
*
pat
size_t
start
)
;
extern
bool
HasSubstringAt
(
JSLinearString
*
text
JSLinearString
*
pat
size_t
start
)
;
JSString
*
SubstringKernel
(
JSContext
*
cx
HandleString
str
int32_t
beginInt
int32_t
lengthInt
)
;
UniqueChars
EncodeLatin1
(
JSContext
*
cx
JSString
*
str
)
;
extern
const
char
*
ValueToPrintableLatin1
(
JSContext
*
cx
const
Value
&
JSAutoByteString
*
bytes
bool
asSource
=
false
)
;
extern
const
char
*
ValueToPrintableUTF8
(
JSContext
*
cx
const
Value
&
JSAutoByteString
*
bytes
bool
asSource
=
false
)
;
template
<
AllowGC
allowGC
>
extern
JSString
*
ToStringSlow
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
arg
)
;
template
<
AllowGC
allowGC
>
static
MOZ_ALWAYS_INLINE
JSString
*
ToString
(
JSContext
*
cx
JS
:
:
HandleValue
v
)
{
if
(
v
.
isString
(
)
)
return
v
.
toString
(
)
;
return
ToStringSlow
<
allowGC
>
(
cx
v
)
;
}
inline
bool
ValueToStringBuffer
(
JSContext
*
cx
const
Value
&
v
StringBuffer
&
sb
)
;
extern
JSString
*
ValueToSource
(
JSContext
*
cx
HandleValue
v
)
;
extern
JSString
*
StringToSource
(
JSContext
*
cx
JSString
*
str
)
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
getChar
(
JSContext
*
cx
size_t
index
char16_t
*
code
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
JSString
*
str
;
if
(
isRope
(
)
)
{
JSRope
*
rope
=
&
asRope
(
)
;
if
(
uint32_t
(
index
)
<
rope
-
>
leftChild
(
)
-
>
length
(
)
)
{
str
=
rope
-
>
leftChild
(
)
;
}
else
{
str
=
rope
-
>
rightChild
(
)
;
index
-
=
rope
-
>
leftChild
(
)
-
>
length
(
)
;
}
}
else
{
str
=
this
;
}
if
(
!
str
-
>
ensureLinear
(
cx
)
)
return
false
;
*
code
=
str
-
>
asLinear
(
)
.
latin1OrTwoByteChar
(
index
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
JSLinearString
*
JSString
:
:
ensureLinear
(
JSContext
*
cx
)
{
return
isLinear
(
)
?
&
asLinear
(
)
:
asRope
(
)
.
flatten
(
cx
)
;
}
inline
JSLinearString
*
JSString
:
:
base
(
)
const
{
MOZ_ASSERT
(
hasBase
(
)
)
;
MOZ_ASSERT
(
!
d
.
s
.
u3
.
base
-
>
isInline
(
)
)
;
return
d
.
s
.
u3
.
base
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
nonInlineTwoByteChars
(
nogc
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
nonInlineChars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
nonInlineLatin1Chars
(
nogc
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawTwoByteChars
(
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
chars
(
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
return
rawLatin1Chars
(
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
js
:
:
UniquePtr
<
JS
:
:
Latin1Char
[
]
JS
:
:
FreePolicy
>
JSRope
:
:
copyChars
<
JS
:
:
Latin1Char
>
(
JSContext
*
maybecx
)
const
{
return
copyLatin1Chars
(
maybecx
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
JS
:
:
UniqueTwoByteChars
JSRope
:
:
copyChars
<
char16_t
>
(
JSContext
*
maybecx
)
const
{
return
copyTwoByteChars
(
maybecx
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSThinInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSThinInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSFatInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
static_assert
(
(
INLINE_EXTENSION_CHARS_LATIN1
*
sizeof
(
char
)
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
'
Latin1
characters
don
'
t
exactly
"
"
fill
subsequent
cells
and
thus
are
wasteful
"
)
;
static_assert
(
MAX_LENGTH_LATIN1
+
1
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageLatin1
)
)
/
sizeof
(
char
)
"
MAX_LENGTH_LATIN1
must
be
one
less
than
inline
Latin1
"
"
storage
count
"
)
;
return
length
<
=
MAX_LENGTH_LATIN1
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSFatInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
static_assert
(
(
INLINE_EXTENSION_CHARS_TWO_BYTE
*
sizeof
(
char16_t
)
)
%
js
:
:
gc
:
:
CellAlignBytes
=
=
0
"
fat
inline
strings
'
char16_t
characters
don
'
t
exactly
"
"
fill
subsequent
cells
and
thus
are
wasteful
"
)
;
static_assert
(
MAX_LENGTH_TWO_BYTE
+
1
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageTwoByte
)
)
/
sizeof
(
char16_t
)
"
MAX_LENGTH_TWO_BYTE
must
be
one
less
than
inline
"
"
char16_t
storage
count
"
)
;
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
size_t
length
)
{
return
JSFatInlineString
:
:
lengthFits
<
JS
:
:
Latin1Char
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
bool
JSInlineString
:
:
lengthFits
<
char16_t
>
(
size_t
length
)
{
return
JSFatInlineString
:
:
lengthFits
<
char16_t
>
(
length
)
;
}
template
<
>
MOZ_ALWAYS_INLINE
void
JSString
:
:
setNonInlineChars
(
const
char16_t
*
chars
)
{
d
.
s
.
u2
.
nonInlineCharsTwoByte
=
chars
;
}
template
<
>
MOZ_ALWAYS_INLINE
void
JSString
:
:
setNonInlineChars
(
const
JS
:
:
Latin1Char
*
chars
)
{
d
.
s
.
u2
.
nonInlineCharsLatin1
=
chars
;
}
MOZ_ALWAYS_INLINE
const
JS
:
:
Latin1Char
*
JSLinearString
:
:
rawLatin1Chars
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
hasLatin1Chars
(
)
)
;
return
isInline
(
)
?
d
.
inlineStorageLatin1
:
d
.
s
.
u2
.
nonInlineCharsLatin1
;
}
MOZ_ALWAYS_INLINE
const
char16_t
*
JSLinearString
:
:
rawTwoByteChars
(
)
const
{
MOZ_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
MOZ_ASSERT
(
hasTwoByteChars
(
)
)
;
return
isInline
(
)
?
d
.
inlineStorageTwoByte
:
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
inline
js
:
:
PropertyName
*
JSAtom
:
:
asPropertyName
(
)
{
#
ifdef
DEBUG
uint32_t
dummy
;
MOZ_ASSERT
(
!
isIndex
(
&
dummy
)
)
;
#
endif
return
static_cast
<
js
:
:
PropertyName
*
>
(
this
)
;
}
namespace
js
{
namespace
gc
{
template
<
>
inline
JSString
*
Cell
:
:
as
<
JSString
>
(
)
{
MOZ_ASSERT
(
is
<
JSString
>
(
)
)
;
return
reinterpret_cast
<
JSString
*
>
(
this
)
;
}
template
<
>
inline
JSString
*
TenuredCell
:
:
as
<
JSString
>
(
)
{
MOZ_ASSERT
(
is
<
JSString
>
(
)
)
;
return
reinterpret_cast
<
JSString
*
>
(
this
)
;
}
}
}
#
endif
