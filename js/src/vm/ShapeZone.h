#
ifndef
vm_ShapeZone_h
#
define
vm_ShapeZone_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
SweepingAPI
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
vm
/
PropertyKey
.
h
"
#
include
"
vm
/
PropMap
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
namespace
js
{
struct
BaseShapeHasher
{
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
)
:
clasp
(
clasp
)
realm
(
realm
)
proto
(
proto
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
StableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
clasp
lookup
.
realm
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
BaseShape
*
>
&
key
const
Lookup
&
lookup
)
{
return
key
.
unbarrieredGet
(
)
-
>
clasp
(
)
=
=
lookup
.
clasp
&
&
key
.
unbarrieredGet
(
)
-
>
realm
(
)
=
=
lookup
.
realm
&
&
key
.
unbarrieredGet
(
)
-
>
proto
(
)
=
=
lookup
.
proto
;
}
}
;
using
BaseShapeSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
BaseShape
*
>
BaseShapeHasher
SystemAllocPolicy
>
>
;
struct
InitialPropMapHasher
{
struct
Lookup
{
PropertyKey
key
;
PropertyInfo
prop
;
Lookup
(
PropertyKey
key
PropertyInfo
prop
)
:
key
(
key
)
prop
(
prop
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
HashPropertyKey
(
lookup
.
key
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
prop
.
toRaw
(
)
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
SharedPropMap
*
>
&
key
const
Lookup
&
lookup
)
{
const
SharedPropMap
*
map
=
key
.
unbarrieredGet
(
)
;
return
map
-
>
matchProperty
(
0
lookup
.
key
lookup
.
prop
)
;
}
}
;
using
InitialPropMapSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
SharedPropMap
*
>
InitialPropMapHasher
SystemAllocPolicy
>
>
;
struct
ShapeBaseHasher
{
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
ObjectFlags
objectFlags
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
const
TaggedProto
&
proto
ObjectFlags
objectFlags
)
:
clasp
(
clasp
)
realm
(
realm
)
proto
(
proto
)
objectFlags
(
objectFlags
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
StableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
clasp
lookup
.
realm
lookup
.
objectFlags
.
toRaw
(
)
)
;
}
static
bool
match
(
const
Shape
*
shape
const
Lookup
&
lookup
)
{
return
lookup
.
clasp
=
=
shape
-
>
getObjectClass
(
)
&
&
lookup
.
realm
=
=
shape
-
>
realm
(
)
&
&
lookup
.
proto
=
=
shape
-
>
proto
(
)
&
&
lookup
.
objectFlags
=
=
shape
-
>
objectFlags
(
)
;
}
}
;
struct
InitialShapeHasher
{
struct
Lookup
:
public
ShapeBaseHasher
:
:
Lookup
{
uint32_t
nfixed
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
const
TaggedProto
&
proto
uint32_t
nfixed
ObjectFlags
objectFlags
)
:
ShapeBaseHasher
:
:
Lookup
(
clasp
realm
proto
objectFlags
)
nfixed
(
nfixed
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
ShapeBaseHasher
:
:
hash
(
lookup
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
nfixed
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
SharedShape
*
>
&
key
const
Lookup
&
lookup
)
{
const
SharedShape
*
shape
=
key
.
unbarrieredGet
(
)
;
return
ShapeBaseHasher
:
:
match
(
shape
lookup
)
&
&
lookup
.
nfixed
=
=
shape
-
>
numFixedSlots
(
)
;
}
}
;
using
InitialShapeSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
SharedShape
*
>
InitialShapeHasher
SystemAllocPolicy
>
>
;
struct
PropMapShapeHasher
{
struct
Lookup
{
BaseShape
*
base
;
SharedPropMap
*
map
;
uint32_t
mapLength
;
uint32_t
nfixed
;
ObjectFlags
objectFlags
;
Lookup
(
BaseShape
*
base
uint32_t
nfixed
SharedPropMap
*
map
uint32_t
mapLength
ObjectFlags
objectFlags
)
:
base
(
base
)
map
(
map
)
mapLength
(
mapLength
)
nfixed
(
nfixed
)
objectFlags
(
objectFlags
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
mozilla
:
:
HashGeneric
(
lookup
.
base
lookup
.
map
lookup
.
mapLength
lookup
.
nfixed
lookup
.
objectFlags
.
toRaw
(
)
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
SharedShape
*
>
&
key
const
Lookup
&
lookup
)
{
const
SharedShape
*
shape
=
key
.
unbarrieredGet
(
)
;
return
lookup
.
base
=
=
shape
-
>
base
(
)
&
&
lookup
.
nfixed
=
=
shape
-
>
numFixedSlots
(
)
&
&
lookup
.
map
=
=
shape
-
>
propMap
(
)
&
&
lookup
.
mapLength
=
=
shape
-
>
propMapLength
(
)
&
&
lookup
.
objectFlags
=
=
shape
-
>
objectFlags
(
)
;
}
static
void
rekey
(
WeakHeapPtr
<
SharedShape
*
>
&
k
const
WeakHeapPtr
<
SharedShape
*
>
&
newKey
)
{
k
=
newKey
;
}
}
;
using
PropMapShapeSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
SharedShape
*
>
PropMapShapeHasher
SystemAllocPolicy
>
>
;
struct
ProxyShapeHasher
:
public
ShapeBaseHasher
{
static
bool
match
(
const
WeakHeapPtr
<
ProxyShape
*
>
&
key
const
Lookup
&
lookup
)
{
const
ProxyShape
*
shape
=
key
.
unbarrieredGet
(
)
;
return
ShapeBaseHasher
:
:
match
(
shape
lookup
)
;
}
}
;
using
ProxyShapeSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
ProxyShape
*
>
ProxyShapeHasher
SystemAllocPolicy
>
>
;
struct
WasmGCShapeHasher
:
public
ShapeBaseHasher
{
struct
Lookup
:
public
ShapeBaseHasher
:
:
Lookup
{
const
wasm
:
:
RecGroup
*
recGroup
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
const
TaggedProto
&
proto
const
wasm
:
:
RecGroup
*
recGroup
ObjectFlags
objectFlags
)
:
ShapeBaseHasher
:
:
Lookup
(
clasp
realm
proto
objectFlags
)
recGroup
(
recGroup
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
ShapeBaseHasher
:
:
hash
(
lookup
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
lookup
.
recGroup
)
;
return
hash
;
}
static
bool
match
(
const
WeakHeapPtr
<
WasmGCShape
*
>
&
key
const
Lookup
&
lookup
)
{
const
WasmGCShape
*
shape
=
key
.
unbarrieredGet
(
)
;
return
ShapeBaseHasher
:
:
match
(
shape
lookup
)
&
&
shape
-
>
recGroup
(
)
=
=
lookup
.
recGroup
;
}
}
;
using
WasmGCShapeSet
=
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
WasmGCShape
*
>
WasmGCShapeHasher
SystemAllocPolicy
>
>
;
struct
ShapeZone
{
BaseShapeSet
baseShapes
;
InitialPropMapSet
initialPropMaps
;
InitialShapeSet
initialShapes
;
PropMapShapeSet
propMapShapes
;
ProxyShapeSet
proxyShapes
;
WasmGCShapeSet
wasmGCShapes
;
using
ShapeWithCacheVector
=
js
:
:
Vector
<
js
:
:
Shape
*
0
js
:
:
SystemAllocPolicy
>
;
ShapeWithCacheVector
shapesWithCache
;
explicit
ShapeZone
(
Zone
*
zone
)
;
void
purgeShapeCaches
(
JS
:
:
GCContext
*
gcx
)
;
void
addSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
initialPropMapTable
size_t
*
shapeTables
)
;
void
fixupPropMapShapeTableAfterMovingGC
(
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkTablesAfterMovingGC
(
)
;
#
endif
}
;
}
#
endif
