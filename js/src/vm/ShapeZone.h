#
ifndef
vm_ShapeZone_h
#
define
vm_ShapeZone_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
vm
/
PropertyKey
.
h
"
#
include
"
vm
/
PropMap
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
namespace
js
{
class
PropertyTree
{
friend
class
:
:
JSFunction
;
#
ifdef
DEBUG
JS
:
:
Zone
*
zone_
;
#
endif
bool
insertChild
(
JSContext
*
cx
Shape
*
parent
Shape
*
child
)
;
PropertyTree
(
)
;
public
:
enum
{
MAX_HEIGHT
=
512
MAX_HEIGHT_WITH_ELEMENTS_ACCESS
=
128
}
;
explicit
PropertyTree
(
JS
:
:
Zone
*
zone
)
#
ifdef
DEBUG
:
zone_
(
zone
)
#
endif
{
}
MOZ_ALWAYS_INLINE
Shape
*
inlinedGetChild
(
JSContext
*
cx
Shape
*
parent
JS
:
:
Handle
<
StackShape
>
childSpec
)
;
Shape
*
getChild
(
JSContext
*
cx
Shape
*
parent
JS
:
:
Handle
<
StackShape
>
child
)
;
}
;
struct
BaseShapeHasher
{
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
TaggedProto
proto
)
:
clasp
(
clasp
)
realm
(
realm
)
proto
(
proto
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
clasp
lookup
.
realm
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
BaseShape
*
>
&
key
const
Lookup
&
lookup
)
{
return
key
.
unbarrieredGet
(
)
-
>
clasp
(
)
=
=
lookup
.
clasp
&
&
key
.
unbarrieredGet
(
)
-
>
realm
(
)
=
=
lookup
.
realm
&
&
key
.
unbarrieredGet
(
)
-
>
proto
(
)
=
=
lookup
.
proto
;
}
}
;
using
BaseShapeSet
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
BaseShape
*
>
BaseShapeHasher
SystemAllocPolicy
>
>
;
struct
InitialPropMapHasher
{
struct
Lookup
{
PropertyKey
key
;
PropertyInfo
prop
;
Lookup
(
PropertyKey
key
PropertyInfo
prop
)
:
key
(
key
)
prop
(
prop
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
HashPropertyKey
(
lookup
.
key
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
prop
.
toRaw
(
)
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
SharedPropMap
*
>
&
key
const
Lookup
&
lookup
)
{
const
SharedPropMap
*
map
=
key
.
unbarrieredGet
(
)
;
return
map
-
>
matchProperty
(
0
lookup
.
key
lookup
.
prop
)
;
}
}
;
using
InitialPropMapSet
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
SharedPropMap
*
>
InitialPropMapHasher
SystemAllocPolicy
>
>
;
struct
InitialShapeHasher
{
struct
Lookup
{
const
JSClass
*
clasp
;
JS
:
:
Realm
*
realm
;
TaggedProto
proto
;
uint32_t
nfixed
;
ObjectFlags
objectFlags
;
Lookup
(
const
JSClass
*
clasp
JS
:
:
Realm
*
realm
const
TaggedProto
&
proto
uint32_t
nfixed
ObjectFlags
objectFlags
)
:
clasp
(
clasp
)
realm
(
realm
)
proto
(
proto
)
nfixed
(
nfixed
)
objectFlags
(
objectFlags
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
HashNumber
hash
=
MovableCellHasher
<
TaggedProto
>
:
:
hash
(
lookup
.
proto
)
;
return
mozilla
:
:
AddToHash
(
hash
lookup
.
clasp
lookup
.
realm
lookup
.
nfixed
lookup
.
objectFlags
.
toRaw
(
)
)
;
}
static
bool
match
(
const
WeakHeapPtr
<
Shape
*
>
&
key
const
Lookup
&
lookup
)
{
const
Shape
*
shape
=
key
.
unbarrieredGet
(
)
;
return
lookup
.
clasp
=
=
shape
-
>
getObjectClass
(
)
&
&
lookup
.
realm
=
=
shape
-
>
realm
(
)
&
&
lookup
.
proto
=
=
shape
-
>
proto
(
)
&
&
lookup
.
nfixed
=
=
shape
-
>
numFixedSlots
(
)
&
&
lookup
.
objectFlags
=
=
shape
-
>
objectFlags
(
)
;
}
}
;
using
InitialShapeSet
=
JS
:
:
WeakCache
<
JS
:
:
GCHashSet
<
WeakHeapPtr
<
Shape
*
>
InitialShapeHasher
SystemAllocPolicy
>
>
;
struct
ShapeZone
{
PropertyTree
propertyTree
;
BaseShapeSet
baseShapes
;
InitialPropMapSet
initialPropMaps
;
InitialShapeSet
initialShapes
;
explicit
ShapeZone
(
Zone
*
zone
)
;
void
clearTables
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkTablesAfterMovingGC
(
)
;
#
endif
}
;
}
#
endif
