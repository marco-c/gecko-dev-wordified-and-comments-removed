#
ifndef
vm_FunctionFlags_h
#
define
vm_FunctionFlags_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
class
JS_PUBLIC_API
JSAtom
;
namespace
js
{
class
FunctionFlags
{
public
:
enum
FunctionKind
:
uint8_t
{
NormalFunction
=
0
Arrow
Method
ClassConstructor
Getter
Setter
AsmJS
Wasm
FunctionKindLimit
}
;
enum
Flags
:
uint16_t
{
FUNCTION_KIND_SHIFT
=
0
FUNCTION_KIND_MASK
=
0x0007
EXTENDED
=
1
<
<
3
SELF_HOSTED
=
1
<
<
4
BASESCRIPT
=
1
<
<
5
SELFHOSTLAZY
=
1
<
<
6
CONSTRUCTOR
=
1
<
<
7
LAMBDA
=
1
<
<
9
WASM_JIT_ENTRY
=
1
<
<
10
HAS_INFERRED_NAME
=
1
<
<
11
HAS_GUESSED_ATOM
=
1
<
<
12
RESOLVED_NAME
=
1
<
<
13
RESOLVED_LENGTH
=
1
<
<
14
GHOST_FUNCTION
=
1
<
<
15
NORMAL_KIND
=
NormalFunction
<
<
FUNCTION_KIND_SHIFT
ASMJS_KIND
=
AsmJS
<
<
FUNCTION_KIND_SHIFT
WASM_KIND
=
Wasm
<
<
FUNCTION_KIND_SHIFT
ARROW_KIND
=
Arrow
<
<
FUNCTION_KIND_SHIFT
METHOD_KIND
=
Method
<
<
FUNCTION_KIND_SHIFT
CLASSCONSTRUCTOR_KIND
=
ClassConstructor
<
<
FUNCTION_KIND_SHIFT
GETTER_KIND
=
Getter
<
<
FUNCTION_KIND_SHIFT
SETTER_KIND
=
Setter
<
<
FUNCTION_KIND_SHIFT
NATIVE_FUN
=
NORMAL_KIND
NATIVE_CTOR
=
CONSTRUCTOR
|
NORMAL_KIND
ASMJS_CTOR
=
CONSTRUCTOR
|
ASMJS_KIND
ASMJS_LAMBDA_CTOR
=
CONSTRUCTOR
|
LAMBDA
|
ASMJS_KIND
WASM
=
WASM_KIND
INTERPRETED_NORMAL
=
BASESCRIPT
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_CLASS_CTOR
=
BASESCRIPT
|
CONSTRUCTOR
|
CLASSCONSTRUCTOR_KIND
INTERPRETED_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
NORMAL_KIND
INTERPRETED_LAMBDA
=
BASESCRIPT
|
LAMBDA
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_LAMBDA_ARROW
=
BASESCRIPT
|
LAMBDA
|
ARROW_KIND
INTERPRETED_LAMBDA_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
LAMBDA
|
NORMAL_KIND
INTERPRETED_GETTER
=
BASESCRIPT
|
GETTER_KIND
INTERPRETED_SETTER
=
BASESCRIPT
|
SETTER_KIND
INTERPRETED_METHOD
=
BASESCRIPT
|
METHOD_KIND
MUTABLE_FLAGS
=
RESOLVED_NAME
|
RESOLVED_LENGTH
STABLE_ACROSS_CLONES
=
CONSTRUCTOR
|
LAMBDA
|
SELF_HOSTED
|
FUNCTION_KIND_MASK
|
GHOST_FUNCTION
}
;
uint16_t
flags_
;
public
:
FunctionFlags
(
)
:
flags_
(
)
{
static_assert
(
sizeof
(
FunctionFlags
)
=
=
sizeof
(
flags_
)
"
No
extra
members
allowed
is
it
'
ll
grow
JSFunction
"
)
;
static_assert
(
offsetof
(
FunctionFlags
flags_
)
=
=
0
"
Required
for
JIT
flag
access
"
)
;
}
explicit
FunctionFlags
(
uint16_t
flags
)
:
flags_
(
flags
)
{
}
MOZ_IMPLICIT
FunctionFlags
(
Flags
f
)
:
flags_
(
f
)
{
}
static_assert
(
(
(
FunctionKindLimit
-
1
)
<
<
FUNCTION_KIND_SHIFT
)
<
=
FUNCTION_KIND_MASK
"
FunctionKind
doesn
'
t
fit
into
flags_
"
)
;
uint16_t
toRaw
(
)
const
{
return
flags_
;
}
uint16_t
stableAcrossClones
(
)
const
{
return
flags_
&
STABLE_ACROSS_CLONES
;
}
bool
hasFlags
(
uint16_t
flags
)
const
{
return
flags_
&
flags
;
}
FunctionFlags
&
setFlags
(
uint16_t
flags
)
{
flags_
|
=
flags
;
return
*
this
;
}
FunctionFlags
&
clearFlags
(
uint16_t
flags
)
{
flags_
&
=
~
flags
;
return
*
this
;
}
FunctionFlags
&
setFlags
(
uint16_t
flags
bool
set
)
{
if
(
set
)
{
setFlags
(
flags
)
;
}
else
{
clearFlags
(
flags
)
;
}
return
*
this
;
}
FunctionKind
kind
(
)
const
{
return
static_cast
<
FunctionKind
>
(
(
flags_
&
FUNCTION_KIND_MASK
)
>
>
FUNCTION_KIND_SHIFT
)
;
}
#
ifdef
DEBUG
void
assertFunctionKindIntegrity
(
)
{
switch
(
kind
(
)
)
{
case
FunctionKind
:
:
NormalFunction
:
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
Arrow
:
MOZ_ASSERT
(
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
hasFlags
(
LAMBDA
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
Method
:
MOZ_ASSERT
(
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
LAMBDA
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
ClassConstructor
:
MOZ_ASSERT
(
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
)
;
MOZ_ASSERT
(
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
LAMBDA
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
Getter
:
MOZ_ASSERT
(
!
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
LAMBDA
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
Setter
:
MOZ_ASSERT
(
!
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
LAMBDA
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
AsmJS
:
MOZ_ASSERT
(
!
hasFlags
(
BASESCRIPT
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
SELFHOSTLAZY
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
WASM_JIT_ENTRY
)
)
;
break
;
case
FunctionKind
:
:
Wasm
:
MOZ_ASSERT
(
!
hasFlags
(
BASESCRIPT
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
SELFHOSTLAZY
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
CONSTRUCTOR
)
)
;
MOZ_ASSERT
(
!
hasFlags
(
LAMBDA
)
)
;
break
;
default
:
break
;
}
}
#
endif
bool
isInterpreted
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isNativeFun
(
)
const
{
return
!
isInterpreted
(
)
;
}
bool
isConstructor
(
)
const
{
return
hasFlags
(
CONSTRUCTOR
)
;
}
bool
isNonBuiltinConstructor
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
&
&
hasFlags
(
CONSTRUCTOR
)
&
&
!
hasFlags
(
SELF_HOSTED
)
;
}
bool
isAsmJSNative
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
AsmJS
isNativeFun
(
)
)
;
return
kind
(
)
=
=
AsmJS
;
}
bool
isWasm
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
Wasm
isNativeFun
(
)
)
;
return
kind
(
)
=
=
Wasm
;
}
bool
isWasmWithJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
hasFlags
(
WASM_JIT_ENTRY
)
isWasm
(
)
)
;
return
hasFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isNativeWithoutJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
!
hasJitEntry
(
)
isNativeFun
(
)
)
;
return
!
hasJitEntry
(
)
;
}
bool
isBuiltinNative
(
)
const
{
return
isNativeFun
(
)
&
&
!
isAsmJSNative
(
)
&
&
!
isWasm
(
)
;
}
bool
hasJitEntry
(
)
const
{
return
hasBaseScript
(
)
|
|
hasSelfHostedLazyScript
(
)
|
|
isWasmWithJitEntry
(
)
;
}
bool
hasInferredName
(
)
const
{
return
hasFlags
(
HAS_INFERRED_NAME
)
;
}
bool
hasGuessedAtom
(
)
const
{
return
hasFlags
(
HAS_GUESSED_ATOM
)
;
}
bool
isLambda
(
)
const
{
return
hasFlags
(
LAMBDA
)
;
}
bool
isNamedLambda
(
bool
hasName
)
const
{
return
hasName
&
&
isLambda
(
)
&
&
!
hasInferredName
(
)
&
&
!
hasGuessedAtom
(
)
;
}
bool
hasBaseScript
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
;
}
bool
hasSelfHostedLazyScript
(
)
const
{
return
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isArrow
(
)
const
{
return
kind
(
)
=
=
Arrow
;
}
bool
isMethod
(
)
const
{
return
kind
(
)
=
=
Method
|
|
kind
(
)
=
=
ClassConstructor
;
}
bool
isClassConstructor
(
)
const
{
return
kind
(
)
=
=
ClassConstructor
;
}
bool
isGetter
(
)
const
{
return
kind
(
)
=
=
Getter
;
}
bool
isSetter
(
)
const
{
return
kind
(
)
=
=
Setter
;
}
bool
allowSuperProperty
(
)
const
{
return
isMethod
(
)
|
|
isGetter
(
)
|
|
isSetter
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
hasFlags
(
RESOLVED_LENGTH
)
;
}
bool
hasResolvedName
(
)
const
{
return
hasFlags
(
RESOLVED_NAME
)
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
hasFlags
(
SELF_HOSTED
)
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
!
isNativeFun
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
isNativeFun
(
)
;
}
FunctionFlags
&
setKind
(
FunctionKind
kind
)
{
this
-
>
flags_
&
=
~
FUNCTION_KIND_MASK
;
this
-
>
flags_
|
=
static_cast
<
uint16_t
>
(
kind
)
<
<
FUNCTION_KIND_SHIFT
;
return
*
this
;
}
FunctionFlags
&
setIsConstructor
(
)
{
MOZ_ASSERT
(
!
isConstructor
(
)
)
;
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
return
setFlags
(
CONSTRUCTOR
)
;
}
FunctionFlags
&
setIsSelfHostedBuiltin
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
MOZ_ASSERT
(
!
isSelfHostedBuiltin
(
)
)
;
setFlags
(
SELF_HOSTED
)
;
return
clearFlags
(
CONSTRUCTOR
)
;
}
FunctionFlags
&
setIsIntrinsic
(
)
{
MOZ_ASSERT
(
isNativeFun
(
)
)
;
MOZ_ASSERT
(
!
isIntrinsic
(
)
)
;
return
setFlags
(
SELF_HOSTED
)
;
}
FunctionFlags
&
setResolvedLength
(
)
{
return
setFlags
(
RESOLVED_LENGTH
)
;
}
FunctionFlags
&
setResolvedName
(
)
{
return
setFlags
(
RESOLVED_NAME
)
;
}
FunctionFlags
&
setInferredName
(
)
{
return
setFlags
(
HAS_INFERRED_NAME
)
;
}
FunctionFlags
&
setGuessedAtom
(
)
{
return
setFlags
(
HAS_GUESSED_ATOM
)
;
}
FunctionFlags
&
setSelfHostedLazy
(
)
{
return
setFlags
(
SELFHOSTLAZY
)
;
}
FunctionFlags
&
clearSelfHostedLazy
(
)
{
return
clearFlags
(
SELFHOSTLAZY
)
;
}
FunctionFlags
&
setBaseScript
(
)
{
return
setFlags
(
BASESCRIPT
)
;
}
FunctionFlags
&
clearBaseScript
(
)
{
return
clearFlags
(
BASESCRIPT
)
;
}
FunctionFlags
&
setWasmJitEntry
(
)
{
return
setFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isExtended
(
)
const
{
return
hasFlags
(
EXTENDED
)
;
}
FunctionFlags
&
setIsExtended
(
)
{
return
setFlags
(
EXTENDED
)
;
}
bool
isNativeConstructor
(
)
const
{
return
hasFlags
(
NATIVE_CTOR
)
;
}
FunctionFlags
&
setIsGhost
(
)
{
return
setFlags
(
GHOST_FUNCTION
)
;
}
bool
isGhost
(
)
const
{
return
hasFlags
(
GHOST_FUNCTION
)
;
}
static
uint16_t
HasJitEntryFlags
(
bool
isConstructing
)
{
uint16_t
flags
=
BASESCRIPT
|
SELFHOSTLAZY
;
if
(
!
isConstructing
)
{
flags
|
=
WASM_JIT_ENTRY
;
}
return
flags
;
}
static
FunctionFlags
clearMutableflags
(
FunctionFlags
flags
)
{
return
FunctionFlags
(
flags
.
toRaw
(
)
&
~
FunctionFlags
:
:
MUTABLE_FLAGS
)
;
}
}
;
}
#
endif
