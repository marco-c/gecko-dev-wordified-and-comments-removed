#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jspubtd
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Runtime
.
h
"
using
namespace
js
;
using
mozilla
:
:
Utf8Unit
;
using
JS
:
:
ReadOnlyCompileOptions
;
enum
class
OffThread
{
Compile
Decode
}
;
template
<
typename
OptionT
>
static
bool
CanDoOffThread
(
JSContext
*
cx
const
OptionT
&
options
size_t
length
)
{
static
const
size_t
TINY_LENGTH
=
5
*
1000
;
if
(
!
options
.
forceAsync
)
{
if
(
length
<
TINY_LENGTH
)
{
return
false
;
}
}
return
cx
-
>
runtime
(
)
-
>
canUseParallelParsing
(
)
&
&
CanUseExtraThreads
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CanCompileOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
{
return
CanDoOffThread
(
cx
options
length
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileModuleToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileModuleToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileModuleToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileModuleToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeStencilOffThread
(
JSContext
*
cx
const
DecodeOptions
&
options
const
TranscodeBuffer
&
buffer
size_t
cursor
OffThreadCompileCallback
callback
void
*
callbackData
)
{
JS
:
:
TranscodeRange
range
(
buffer
.
begin
(
)
+
cursor
buffer
.
length
(
)
-
cursor
)
;
MOZ_ASSERT
(
CanDecodeOffThread
(
cx
options
range
.
length
(
)
)
)
;
return
StartOffThreadDecodeStencil
(
cx
options
range
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeStencilOffThread
(
JSContext
*
cx
const
DecodeOptions
&
options
const
TranscodeRange
&
range
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanDecodeOffThread
(
cx
options
range
.
length
(
)
)
)
;
return
StartOffThreadDecodeStencil
(
cx
options
range
callback
callbackData
)
;
}
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
FinishOffThreadStencil
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
HelperThreadState
(
)
.
finishStencilTask
(
cx
token
storage
)
;
return
stencil
.
forget
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
CancelOffThreadToken
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
HelperThreadState
(
)
.
cancelParseTask
(
cx
-
>
runtime
(
)
token
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CanDecodeOffThread
(
JSContext
*
cx
const
DecodeOptions
&
options
size_t
length
)
{
return
CanDoOffThread
(
cx
options
length
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeMultiStencilsOffThread
(
JSContext
*
cx
const
DecodeOptions
&
options
TranscodeSources
&
sources
OffThreadCompileCallback
callback
void
*
callbackData
)
{
#
ifdef
DEBUG
size_t
length
=
0
;
for
(
auto
&
source
:
sources
)
{
length
+
=
source
.
range
.
length
(
)
;
}
MOZ_ASSERT
(
CanDecodeOffThread
(
cx
options
length
)
)
;
#
endif
return
StartOffThreadDecodeMultiStencils
(
cx
options
sources
callback
callbackData
)
;
}
JS_PUBLIC_API
bool
JS
:
:
FinishDecodeMultiStencilsOffThread
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
mozilla
:
:
Vector
<
RefPtr
<
JS
:
:
Stencil
>
>
*
stencils
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
return
HelperThreadState
(
)
.
finishMultiStencilsDecodeTask
(
cx
token
stencils
)
;
}
