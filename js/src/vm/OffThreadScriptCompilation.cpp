#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jspubtd
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Runtime
.
h
"
using
namespace
js
;
using
mozilla
:
:
Utf8Unit
;
using
JS
:
:
ReadOnlyCompileOptions
;
enum
class
OffThread
{
Compile
Decode
}
;
static
bool
CanDoOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
{
static
const
size_t
TINY_LENGTH
=
5
*
1000
;
if
(
!
options
.
forceAsync
)
{
if
(
length
<
TINY_LENGTH
)
{
return
false
;
}
}
return
cx
-
>
runtime
(
)
-
>
canUseParallelParsing
(
)
&
&
CanUseExtraThreads
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CanCompileOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
{
return
CanDoOffThread
(
cx
options
length
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileModuleToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileModuleToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
CompileModuleToStencilOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
srcBuf
.
length
(
)
)
)
;
return
StartOffThreadCompileModuleToStencil
(
cx
options
srcBuf
callback
callbackData
)
;
}
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
FinishCompileToStencilOffThread
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
HelperThreadState
(
)
.
finishCompileToStencilTask
(
cx
token
storage
)
;
return
stencil
.
forget
(
)
;
}
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
FinishCompileModuleToStencilOffThread
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
JS
:
:
InstantiationStorage
*
storage
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
HelperThreadState
(
)
.
finishCompileModuleToStencilTask
(
cx
token
storage
)
;
return
stencil
.
forget
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
CancelCompileToStencilOffThread
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
HelperThreadState
(
)
.
cancelParseTask
(
cx
-
>
runtime
(
)
ParseTaskKind
:
:
ScriptStencil
token
)
;
}
JS_PUBLIC_API
void
JS
:
:
CancelCompileModuleToStencilOffThread
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
HelperThreadState
(
)
.
cancelParseTask
(
cx
-
>
runtime
(
)
ParseTaskKind
:
:
ModuleStencil
token
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CanDecodeOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
{
return
CanDoOffThread
(
cx
options
length
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeOffThreadScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
mozilla
:
:
Vector
<
uint8_t
>
&
buffer
size_t
cursor
OffThreadCompileCallback
callback
void
*
callbackData
)
{
JS
:
:
TranscodeRange
range
(
buffer
.
begin
(
)
+
cursor
buffer
.
length
(
)
-
cursor
)
;
MOZ_ASSERT
(
CanDecodeOffThread
(
cx
options
range
.
length
(
)
)
)
;
return
StartOffThreadDecodeScript
(
cx
options
range
callback
callbackData
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeOffThreadScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
mozilla
:
:
Range
<
uint8_t
>
&
range
OffThreadCompileCallback
callback
void
*
callbackData
)
{
MOZ_ASSERT
(
CanDecodeOffThread
(
cx
options
range
.
length
(
)
)
)
;
return
StartOffThreadDecodeScript
(
cx
options
range
callback
callbackData
)
;
}
JS_PUBLIC_API
JSScript
*
JS
:
:
FinishOffThreadScriptDecoder
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
return
HelperThreadState
(
)
.
finishScriptDecodeTask
(
cx
token
)
;
}
JS_PUBLIC_API
void
JS
:
:
CancelOffThreadScriptDecoder
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
HelperThreadState
(
)
.
cancelParseTask
(
cx
-
>
runtime
(
)
ParseTaskKind
:
:
ScriptDecode
token
)
;
}
JS_PUBLIC_API
JS
:
:
OffThreadToken
*
JS
:
:
DecodeMultiOffThreadStencils
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
TranscodeSources
&
sources
OffThreadCompileCallback
callback
void
*
callbackData
)
{
#
ifdef
DEBUG
size_t
length
=
0
;
for
(
auto
&
source
:
sources
)
{
length
+
=
source
.
range
.
length
(
)
;
}
MOZ_ASSERT
(
CanCompileOffThread
(
cx
options
length
)
)
;
#
endif
return
StartOffThreadDecodeMultiStencils
(
cx
options
sources
callback
callbackData
)
;
}
JS_PUBLIC_API
bool
JS
:
:
FinishMultiOffThreadStencilDecoder
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
mozilla
:
:
Vector
<
RefPtr
<
JS
:
:
Stencil
>
>
*
stencils
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
return
HelperThreadState
(
)
.
finishMultiStencilsDecodeTask
(
cx
token
stencils
)
;
}
JS_PUBLIC_API
void
JS
:
:
CancelMultiOffThreadScriptsDecoder
(
JSContext
*
cx
JS
:
:
OffThreadToken
*
token
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
cx
-
>
runtime
(
)
)
)
;
HelperThreadState
(
)
.
cancelParseTask
(
cx
-
>
runtime
(
)
ParseTaskKind
:
:
MultiStencilsDecode
token
)
;
}
