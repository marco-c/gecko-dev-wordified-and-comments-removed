#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
proxy
/
ScriptedProxyHandler
.
h
"
#
include
"
jsobjinlines
.
h
"
using
namespace
js
;
ProxyObject
*
ProxyObject
:
:
New
(
JSContext
*
cx
const
BaseProxyHandler
*
handler
HandleValue
priv
TaggedProto
proto_
const
ProxyOptions
&
options
)
{
Rooted
<
TaggedProto
>
proto
(
cx
proto_
)
;
const
Class
*
clasp
=
options
.
clasp
(
)
;
MOZ_ASSERT
(
isValidProxyClass
(
clasp
)
)
;
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
compartment
(
)
=
=
proto
.
toObject
(
)
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
clasp
-
>
hasFinalize
(
)
)
;
if
(
proto
.
isObject
(
)
&
&
!
options
.
singleton
(
)
&
&
!
clasp
-
>
isDOMClass
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setNewGroupUnknown
(
cx
clasp
protoObj
)
)
return
nullptr
;
}
NewObjectKind
newKind
=
NurseryAllocatedProxy
;
if
(
options
.
singleton
(
)
)
{
MOZ_ASSERT
(
priv
.
isNull
(
)
|
|
(
priv
.
isGCThing
(
)
&
&
priv
.
toGCThing
(
)
-
>
isTenured
(
)
)
)
;
newKind
=
SingletonObject
;
}
else
if
(
(
priv
.
isGCThing
(
)
&
&
priv
.
toGCThing
(
)
-
>
isTenured
(
)
)
|
|
!
handler
-
>
canNurseryAllocate
(
)
|
|
!
handler
-
>
finalizeInBackground
(
priv
)
)
{
newKind
=
TenuredObject
;
}
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
clasp
)
;
if
(
handler
-
>
finalizeInBackground
(
priv
)
)
allocKind
=
GetBackgroundAllocKind
(
allocKind
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
ProxyObject
*
proxy
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
proxy
create
(
cx
clasp
proto
allocKind
newKind
)
)
;
new
(
proxy
-
>
data
.
values
)
detail
:
:
ProxyValueArray
;
proxy
-
>
data
.
handler
=
handler
;
proxy
-
>
setCrossCompartmentPrivate
(
priv
)
;
if
(
newKind
!
=
SingletonObject
&
&
!
clasp
-
>
isDOMClass
(
)
)
MarkObjectGroupUnknownProperties
(
cx
proxy
-
>
group
(
)
)
;
return
proxy
;
}
gc
:
:
AllocKind
ProxyObject
:
:
allocKindForTenure
(
)
const
{
gc
:
:
AllocKind
allocKind
=
gc
:
:
GetGCObjectKind
(
group
(
)
-
>
clasp
(
)
)
;
if
(
data
.
handler
-
>
finalizeInBackground
(
const_cast
<
ProxyObject
*
>
(
this
)
-
>
private_
(
)
)
)
allocKind
=
GetBackgroundAllocKind
(
allocKind
)
;
return
allocKind
;
}
size_t
ProxyObject
:
:
objectMovedDuringMinorGC
(
TenuringTracer
*
trc
JSObject
*
dst
JSObject
*
src
)
{
ProxyObject
&
psrc
=
src
-
>
as
<
ProxyObject
>
(
)
;
ProxyObject
&
pdst
=
dst
-
>
as
<
ProxyObject
>
(
)
;
if
(
dst
-
>
zone
(
)
-
>
group
(
)
-
>
nursery
(
)
.
isInside
(
psrc
.
data
.
values
)
)
pdst
.
data
.
values
=
js_new
<
detail
:
:
ProxyValueArray
>
(
*
psrc
.
data
.
values
)
;
else
dst
-
>
zone
(
)
-
>
group
(
)
-
>
nursery
(
)
.
removeMallocedBuffer
(
psrc
.
data
.
values
)
;
return
sizeof
(
detail
:
:
ProxyValueArray
)
;
}
void
ProxyObject
:
:
setCrossCompartmentPrivate
(
const
Value
&
priv
)
{
*
slotOfPrivate
(
)
=
priv
;
}
void
ProxyObject
:
:
setSameCompartmentPrivate
(
const
Value
&
priv
)
{
MOZ_ASSERT
(
IsObjectValueInCompartment
(
priv
compartment
(
)
)
)
;
*
slotOfPrivate
(
)
=
priv
;
}
void
ProxyObject
:
:
nuke
(
)
{
uint32_t
callable
=
handler
(
)
-
>
isCallable
(
this
)
?
ScriptedProxyHandler
:
:
IS_CALLABLE
:
0
;
uint32_t
constructor
=
handler
(
)
-
>
isConstructor
(
this
)
?
ScriptedProxyHandler
:
:
IS_CONSTRUCTOR
:
0
;
setExtra
(
ScriptedProxyHandler
:
:
IS_CALLCONSTRUCT_EXTRA
PrivateUint32Value
(
callable
|
constructor
)
)
;
setSameCompartmentPrivate
(
NullValue
(
)
)
;
setHandler
(
&
DeadObjectProxy
:
:
singleton
)
;
}
JS
:
:
Result
<
ProxyObject
*
JS
:
:
OOM
&
>
ProxyObject
:
:
create
(
JSContext
*
cx
const
Class
*
clasp
Handle
<
TaggedProto
>
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
MOZ_ASSERT
(
clasp
-
>
isProxy
(
)
)
;
JSCompartment
*
comp
=
cx
-
>
compartment
(
)
;
RootedObjectGroup
group
(
cx
)
;
RootedShape
shape
(
cx
)
;
if
(
!
comp
-
>
newProxyCache
.
lookup
(
clasp
proto
group
.
address
(
)
shape
.
address
(
)
)
)
{
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx
clasp
proto
nullptr
)
;
if
(
!
group
)
return
cx
-
>
alreadyReportedOOM
(
)
;
shape
=
EmptyShape
:
:
getInitialShape
(
cx
clasp
proto
0
)
;
if
(
!
shape
)
return
cx
-
>
alreadyReportedOOM
(
)
;
comp
-
>
newProxyCache
.
add
(
group
shape
)
;
}
gc
:
:
InitialHeap
heap
=
GetInitialHeap
(
newKind
clasp
)
;
debugCheckNewObject
(
group
shape
allocKind
heap
)
;
static_assert
(
sizeof
(
js
:
:
detail
:
:
ProxyValueArray
)
%
sizeof
(
js
:
:
HeapSlot
)
=
=
0
"
ProxyValueArray
must
be
a
multiple
of
HeapSlot
"
)
;
static
const
size_t
NumDynamicSlots
=
sizeof
(
js
:
:
detail
:
:
ProxyValueArray
)
/
sizeof
(
HeapSlot
)
;
JSObject
*
obj
=
js
:
:
Allocate
<
JSObject
>
(
cx
allocKind
NumDynamicSlots
heap
clasp
)
;
if
(
!
obj
)
return
cx
-
>
alreadyReportedOOM
(
)
;
ProxyObject
*
pobj
=
static_cast
<
ProxyObject
*
>
(
obj
)
;
pobj
-
>
group_
.
init
(
group
)
;
pobj
-
>
initShape
(
shape
)
;
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
compartment
(
)
-
>
setObjectPendingMetadata
(
cx
pobj
)
;
js
:
:
gc
:
:
TraceCreateObject
(
pobj
)
;
if
(
newKind
=
=
SingletonObject
)
{
Rooted
<
ProxyObject
*
>
pobjRoot
(
cx
pobj
)
;
if
(
!
JSObject
:
:
setSingleton
(
cx
pobjRoot
)
)
return
cx
-
>
alreadyReportedOOM
(
)
;
pobj
=
pobjRoot
;
}
return
pobj
;
}
JS_FRIEND_API
(
void
)
js
:
:
SetValueInProxy
(
Value
*
slot
const
Value
&
value
)
{
*
reinterpret_cast
<
GCPtrValue
*
>
(
slot
)
=
value
;
}
