#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
jsobjinlines
.
h
"
using
namespace
js
;
static
gc
:
:
AllocKind
GetProxyGCObjectKind
(
const
BaseProxyHandler
*
handler
const
Value
&
priv
)
{
static_assert
(
sizeof
(
js
:
:
detail
:
:
ProxyValueArray
)
%
sizeof
(
js
:
:
HeapSlot
)
=
=
0
"
ProxyValueArray
must
be
a
multiple
of
HeapSlot
"
)
;
uint32_t
nslots
=
sizeof
(
js
:
:
detail
:
:
ProxyValueArray
)
/
sizeof
(
HeapSlot
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
nslots
)
;
if
(
handler
-
>
finalizeInBackground
(
priv
)
)
kind
=
GetBackgroundAllocKind
(
kind
)
;
return
kind
;
}
ProxyObject
*
ProxyObject
:
:
New
(
JSContext
*
cx
const
BaseProxyHandler
*
handler
HandleValue
priv
TaggedProto
proto_
const
ProxyOptions
&
options
)
{
Rooted
<
TaggedProto
>
proto
(
cx
proto_
)
;
const
Class
*
clasp
=
options
.
clasp
(
)
;
MOZ_ASSERT
(
isValidProxyClass
(
clasp
)
)
;
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
MOZ_ASSERT_IF
(
proto
.
isObject
(
)
cx
-
>
compartment
(
)
=
=
proto
.
toObject
(
)
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
clasp
-
>
hasFinalize
(
)
)
;
if
(
proto
.
isObject
(
)
&
&
!
options
.
singleton
(
)
&
&
!
clasp
-
>
isDOMClass
(
)
)
{
RootedObject
protoObj
(
cx
proto
.
toObject
(
)
)
;
if
(
!
JSObject
:
:
setNewGroupUnknown
(
cx
clasp
protoObj
)
)
return
nullptr
;
}
NewObjectKind
newKind
=
NurseryAllocatedProxy
;
if
(
options
.
singleton
(
)
)
{
MOZ_ASSERT
(
priv
.
isNull
(
)
|
|
(
priv
.
isGCThing
(
)
&
&
priv
.
toGCThing
(
)
-
>
isTenured
(
)
)
)
;
newKind
=
SingletonObject
;
}
else
if
(
(
priv
.
isGCThing
(
)
&
&
priv
.
toGCThing
(
)
-
>
isTenured
(
)
)
|
|
!
handler
-
>
canNurseryAllocate
(
)
|
|
!
handler
-
>
finalizeInBackground
(
priv
)
)
{
newKind
=
TenuredObject
;
}
gc
:
:
AllocKind
allocKind
=
GetProxyGCObjectKind
(
handler
priv
)
;
AutoSetNewObjectMetadata
metadata
(
cx
)
;
ProxyObject
*
proxy
;
JS_TRY_VAR_OR_RETURN_NULL
(
cx
proxy
create
(
cx
clasp
proto
allocKind
newKind
)
)
;
proxy
-
>
setInlineValueArray
(
)
;
new
(
proxy
-
>
data
.
values
)
detail
:
:
ProxyValueArray
;
proxy
-
>
data
.
handler
=
handler
;
proxy
-
>
setCrossCompartmentPrivate
(
priv
)
;
if
(
newKind
!
=
SingletonObject
&
&
!
clasp
-
>
isDOMClass
(
)
)
MarkObjectGroupUnknownProperties
(
cx
proxy
-
>
group
(
)
)
;
return
proxy
;
}
gc
:
:
AllocKind
ProxyObject
:
:
allocKindForTenure
(
)
const
{
MOZ_ASSERT
(
usingInlineValueArray
(
)
)
;
Value
priv
=
const_cast
<
ProxyObject
*
>
(
this
)
-
>
private_
(
)
;
return
GetProxyGCObjectKind
(
data
.
handler
priv
)
;
}
void
ProxyObject
:
:
setCrossCompartmentPrivate
(
const
Value
&
priv
)
{
*
slotOfPrivate
(
)
=
priv
;
}
void
ProxyObject
:
:
setSameCompartmentPrivate
(
const
Value
&
priv
)
{
MOZ_ASSERT
(
IsObjectValueInCompartment
(
priv
compartment
(
)
)
)
;
*
slotOfPrivate
(
)
=
priv
;
}
void
ProxyObject
:
:
nuke
(
)
{
uint32_t
callable
=
handler
(
)
-
>
isCallable
(
this
)
;
uint32_t
constructor
=
handler
(
)
-
>
isConstructor
(
this
)
;
setSameCompartmentPrivate
(
NullValue
(
)
)
;
if
(
callable
)
{
if
(
constructor
)
setHandler
(
DeadObjectProxy
<
DeadProxyIsCallableIsConstructor
>
:
:
singleton
(
)
)
;
else
setHandler
(
DeadObjectProxy
<
DeadProxyIsCallableNotConstructor
>
:
:
singleton
(
)
)
;
}
else
{
if
(
constructor
)
setHandler
(
DeadObjectProxy
<
DeadProxyNotCallableIsConstructor
>
:
:
singleton
(
)
)
;
else
setHandler
(
DeadObjectProxy
<
DeadProxyNotCallableNotConstructor
>
:
:
singleton
(
)
)
;
}
}
JS
:
:
Result
<
ProxyObject
*
JS
:
:
OOM
&
>
ProxyObject
:
:
create
(
JSContext
*
cx
const
Class
*
clasp
Handle
<
TaggedProto
>
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
MOZ_ASSERT
(
clasp
-
>
isProxy
(
)
)
;
JSCompartment
*
comp
=
cx
-
>
compartment
(
)
;
RootedObjectGroup
group
(
cx
)
;
RootedShape
shape
(
cx
)
;
if
(
!
comp
-
>
newProxyCache
.
lookup
(
clasp
proto
group
.
address
(
)
shape
.
address
(
)
)
)
{
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx
clasp
proto
nullptr
)
;
if
(
!
group
)
return
cx
-
>
alreadyReportedOOM
(
)
;
shape
=
EmptyShape
:
:
getInitialShape
(
cx
clasp
proto
0
)
;
if
(
!
shape
)
return
cx
-
>
alreadyReportedOOM
(
)
;
comp
-
>
newProxyCache
.
add
(
group
shape
)
;
}
gc
:
:
InitialHeap
heap
=
GetInitialHeap
(
newKind
clasp
)
;
debugCheckNewObject
(
group
shape
allocKind
heap
)
;
JSObject
*
obj
=
js
:
:
Allocate
<
JSObject
>
(
cx
allocKind
0
heap
clasp
)
;
if
(
!
obj
)
return
cx
-
>
alreadyReportedOOM
(
)
;
ProxyObject
*
pobj
=
static_cast
<
ProxyObject
*
>
(
obj
)
;
pobj
-
>
group_
.
init
(
group
)
;
pobj
-
>
initShape
(
shape
)
;
MOZ_ASSERT
(
clasp
-
>
shouldDelayMetadataBuilder
(
)
)
;
cx
-
>
compartment
(
)
-
>
setObjectPendingMetadata
(
cx
pobj
)
;
js
:
:
gc
:
:
TraceCreateObject
(
pobj
)
;
if
(
newKind
=
=
SingletonObject
)
{
Rooted
<
ProxyObject
*
>
pobjRoot
(
cx
pobj
)
;
if
(
!
JSObject
:
:
setSingleton
(
cx
pobjRoot
)
)
return
cx
-
>
alreadyReportedOOM
(
)
;
pobj
=
pobjRoot
;
}
return
pobj
;
}
bool
ProxyObject
:
:
initExternalValueArrayAfterSwap
(
JSContext
*
cx
const
detail
:
:
ProxyValueArray
&
src
)
{
MOZ_ASSERT
(
getClass
(
)
-
>
isProxy
(
)
)
;
auto
*
values
=
cx
-
>
zone
(
)
-
>
new_
<
detail
:
:
ProxyValueArray
>
(
src
)
;
if
(
!
values
)
return
false
;
data
.
values
=
values
;
return
true
;
}
JS_FRIEND_API
(
void
)
js
:
:
SetValueInProxy
(
Value
*
slot
const
Value
&
value
)
{
*
reinterpret_cast
<
GCPtrValue
*
>
(
slot
)
=
value
;
}
