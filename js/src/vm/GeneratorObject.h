#
ifndef
vm_GeneratorObject_h
#
define
vm_GeneratorObject_h
#
include
"
js
/
Class
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
GeneratorResumeKind
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
frontend
{
class
ParserAtom
;
}
extern
const
JSClass
GeneratorFunctionClass
;
class
AbstractGeneratorObject
:
public
NativeObject
{
public
:
static
const
int32_t
RESUME_INDEX_RUNNING
=
INT32_MAX
;
enum
{
CALLEE_SLOT
=
0
ENV_CHAIN_SLOT
ARGS_OBJ_SLOT
STACK_STORAGE_SLOT
RESUME_INDEX_SLOT
RESERVED_SLOTS
}
;
static
constexpr
uint32_t
FixedSlotLimit
=
256
;
private
:
static
JSObject
*
createModuleGenerator
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
public
:
static
JSObject
*
createFromFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
static
AbstractGeneratorObject
*
create
(
JSContext
*
cx
HandleFunction
callee
HandleScript
script
HandleObject
environmentChain
Handle
<
ArgumentsObject
*
>
argsObject
)
;
static
bool
resume
(
JSContext
*
cx
InterpreterActivation
&
activation
Handle
<
AbstractGeneratorObject
*
>
genObj
HandleValue
arg
HandleValue
resumeKind
)
;
static
bool
suspend
(
JSContext
*
cx
HandleObject
obj
AbstractFramePtr
frame
jsbytecode
*
pc
unsigned
nvalues
)
;
static
void
finalSuspend
(
HandleObject
obj
)
;
JSFunction
&
callee
(
)
const
{
return
getFixedSlot
(
CALLEE_SLOT
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
}
void
setCallee
(
JSFunction
&
callee
)
{
setFixedSlot
(
CALLEE_SLOT
ObjectValue
(
callee
)
)
;
}
JSObject
&
environmentChain
(
)
const
{
return
getFixedSlot
(
ENV_CHAIN_SLOT
)
.
toObject
(
)
;
}
void
setEnvironmentChain
(
JSObject
&
envChain
)
{
setFixedSlot
(
ENV_CHAIN_SLOT
ObjectValue
(
envChain
)
)
;
}
bool
hasArgsObj
(
)
const
{
return
getFixedSlot
(
ARGS_OBJ_SLOT
)
.
isObject
(
)
;
}
ArgumentsObject
&
argsObj
(
)
const
{
return
getFixedSlot
(
ARGS_OBJ_SLOT
)
.
toObject
(
)
.
as
<
ArgumentsObject
>
(
)
;
}
void
setArgsObj
(
ArgumentsObject
&
argsObj
)
{
setFixedSlot
(
ARGS_OBJ_SLOT
ObjectValue
(
argsObj
)
)
;
}
bool
hasStackStorage
(
)
const
{
return
getFixedSlot
(
STACK_STORAGE_SLOT
)
.
isObject
(
)
;
}
bool
isStackStorageEmpty
(
)
const
{
return
stackStorage
(
)
.
getDenseInitializedLength
(
)
=
=
0
;
}
ArrayObject
&
stackStorage
(
)
const
{
return
getFixedSlot
(
STACK_STORAGE_SLOT
)
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
}
void
setStackStorage
(
ArrayObject
&
stackStorage
)
{
setFixedSlot
(
STACK_STORAGE_SLOT
ObjectValue
(
stackStorage
)
)
;
}
bool
isBeforeInitialYield
(
)
const
{
return
getFixedSlot
(
RESUME_INDEX_SLOT
)
.
isUndefined
(
)
;
}
bool
isRunning
(
)
const
{
return
getFixedSlot
(
RESUME_INDEX_SLOT
)
=
=
Int32Value
(
RESUME_INDEX_RUNNING
)
;
}
bool
isSuspended
(
)
const
{
Value
resumeIndex
=
getFixedSlot
(
RESUME_INDEX_SLOT
)
;
return
resumeIndex
.
isInt32
(
)
&
&
resumeIndex
.
toInt32
(
)
<
RESUME_INDEX_RUNNING
;
}
void
setRunning
(
)
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
setFixedSlot
(
RESUME_INDEX_SLOT
Int32Value
(
RESUME_INDEX_RUNNING
)
)
;
}
void
setResumeIndex
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitialYield
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
Yield
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
Await
)
;
MOZ_ASSERT_IF
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitialYield
getFixedSlot
(
RESUME_INDEX_SLOT
)
.
isUndefined
(
)
)
;
MOZ_ASSERT_IF
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
InitialYield
isRunning
(
)
)
;
uint32_t
resumeIndex
=
GET_UINT24
(
pc
)
;
MOZ_ASSERT
(
resumeIndex
<
uint32_t
(
RESUME_INDEX_RUNNING
)
)
;
setFixedSlot
(
RESUME_INDEX_SLOT
Int32Value
(
resumeIndex
)
)
;
MOZ_ASSERT
(
isSuspended
(
)
)
;
}
void
setResumeIndex
(
int32_t
resumeIndex
)
{
setFixedSlot
(
RESUME_INDEX_SLOT
Int32Value
(
resumeIndex
)
)
;
}
uint32_t
resumeIndex
(
)
const
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
return
getFixedSlot
(
RESUME_INDEX_SLOT
)
.
toInt32
(
)
;
}
bool
isClosed
(
)
const
{
return
getFixedSlot
(
CALLEE_SLOT
)
.
isNull
(
)
;
}
void
setClosed
(
)
{
setFixedSlot
(
CALLEE_SLOT
NullValue
(
)
)
;
setFixedSlot
(
ENV_CHAIN_SLOT
NullValue
(
)
)
;
setFixedSlot
(
ARGS_OBJ_SLOT
NullValue
(
)
)
;
setFixedSlot
(
STACK_STORAGE_SLOT
NullValue
(
)
)
;
setFixedSlot
(
RESUME_INDEX_SLOT
NullValue
(
)
)
;
}
bool
isAfterYield
(
)
;
bool
isAfterAwait
(
)
;
private
:
bool
isAfterYieldOrAwait
(
JSOp
op
)
;
public
:
void
trace
(
JSTracer
*
trc
)
;
static
size_t
offsetOfCalleeSlot
(
)
{
return
getFixedSlotOffset
(
CALLEE_SLOT
)
;
}
static
size_t
offsetOfEnvironmentChainSlot
(
)
{
return
getFixedSlotOffset
(
ENV_CHAIN_SLOT
)
;
}
static
size_t
offsetOfArgsObjSlot
(
)
{
return
getFixedSlotOffset
(
ARGS_OBJ_SLOT
)
;
}
static
size_t
offsetOfResumeIndexSlot
(
)
{
return
getFixedSlotOffset
(
RESUME_INDEX_SLOT
)
;
}
static
size_t
offsetOfStackStorageSlot
(
)
{
return
getFixedSlotOffset
(
STACK_STORAGE_SLOT
)
;
}
static
size_t
calleeSlot
(
)
{
return
CALLEE_SLOT
;
}
static
size_t
envChainSlot
(
)
{
return
ENV_CHAIN_SLOT
;
}
static
size_t
argsObjectSlot
(
)
{
return
ARGS_OBJ_SLOT
;
}
static
size_t
stackStorageSlot
(
)
{
return
STACK_STORAGE_SLOT
;
}
static
size_t
resumeIndexSlot
(
)
{
return
RESUME_INDEX_SLOT
;
}
#
ifdef
DEBUG
void
dump
(
)
const
;
#
endif
}
;
class
GeneratorObject
:
public
AbstractGeneratorObject
{
public
:
enum
{
RESERVED_SLOTS
=
AbstractGeneratorObject
:
:
RESERVED_SLOTS
}
;
static
const
JSClass
class_
;
static
const
JSClassOps
classOps_
;
static
GeneratorObject
*
create
(
JSContext
*
cx
HandleFunction
fun
)
;
}
;
bool
GeneratorThrowOrReturn
(
JSContext
*
cx
AbstractFramePtr
frame
Handle
<
AbstractGeneratorObject
*
>
obj
HandleValue
val
GeneratorResumeKind
resumeKind
)
;
AbstractGeneratorObject
*
GetGeneratorObjectForFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
inline
GeneratorResumeKind
IntToResumeKind
(
int32_t
value
)
{
MOZ_ASSERT
(
uint32_t
(
value
)
<
=
uint32_t
(
GeneratorResumeKind
:
:
Return
)
)
;
return
static_cast
<
GeneratorResumeKind
>
(
value
)
;
}
inline
GeneratorResumeKind
ResumeKindFromPC
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
ResumeKind
)
;
return
IntToResumeKind
(
GET_UINT8
(
pc
)
)
;
}
GeneratorResumeKind
ParserAtomToResumeKind
(
JSContext
*
cx
const
frontend
:
:
ParserAtom
*
atom
)
;
JSAtom
*
ResumeKindToAtom
(
JSContext
*
cx
GeneratorResumeKind
kind
)
;
}
template
<
>
bool
JSObject
:
:
is
<
js
:
:
AbstractGeneratorObject
>
(
)
const
;
#
endif
