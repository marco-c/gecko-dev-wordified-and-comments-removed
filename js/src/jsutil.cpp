#
include
"
jsutil
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
<
stdio
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
Windows
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
namespace
js
{
mozilla
:
:
Atomic
<
AutoEnterOOMUnsafeRegion
*
>
AutoEnterOOMUnsafeRegion
:
:
owner_
;
namespace
oom
{
JS_PUBLIC_DATA
(
FailureSimulator
)
simulator
;
static
MOZ_THREAD_LOCAL
(
uint32_t
)
threadType
;
bool
InitThreadType
(
)
{
return
threadType
.
init
(
)
;
}
void
SetThreadType
(
ThreadType
type
)
{
threadType
.
set
(
type
)
;
}
uint32_t
GetThreadType
(
void
)
{
return
threadType
.
get
(
)
;
}
static
inline
bool
IsHelperThreadType
(
uint32_t
thread
)
{
return
thread
!
=
THREAD_TYPE_NONE
&
&
thread
!
=
THREAD_TYPE_MAIN
;
}
void
FailureSimulator
:
:
simulateFailureAfter
(
Kind
kind
uint64_t
checks
uint32_t
thread
bool
always
)
{
Maybe
<
AutoLockHelperThreadState
>
lock
;
if
(
IsHelperThreadType
(
targetThread_
)
|
|
IsHelperThreadType
(
thread
)
)
{
lock
.
emplace
(
)
;
HelperThreadState
(
)
.
waitForAllThreadsLocked
(
lock
.
ref
(
)
)
;
}
MOZ_ASSERT
(
counter_
+
checks
>
counter_
)
;
MOZ_ASSERT
(
thread
>
js
:
:
THREAD_TYPE_NONE
&
&
thread
<
js
:
:
THREAD_TYPE_MAX
)
;
targetThread_
=
thread
;
maxChecks_
=
counter_
+
checks
;
failAlways_
=
always
;
kind_
=
kind
;
}
void
FailureSimulator
:
:
reset
(
)
{
Maybe
<
AutoLockHelperThreadState
>
lock
;
if
(
IsHelperThreadType
(
targetThread_
)
)
{
lock
.
emplace
(
)
;
HelperThreadState
(
)
.
waitForAllThreadsLocked
(
lock
.
ref
(
)
)
;
}
targetThread_
=
THREAD_TYPE_NONE
;
maxChecks_
=
UINT64_MAX
;
failAlways_
=
false
;
kind_
=
Kind
:
:
Nothing
;
}
}
}
#
endif
bool
js
:
:
gDisablePoisoning
=
false
;
JS_PUBLIC_DATA
(
arena_id_t
)
js
:
:
MallocArena
;
JS_PUBLIC_DATA
(
arena_id_t
)
js
:
:
ArrayBufferContentsArena
;
void
js
:
:
InitMallocAllocator
(
)
{
MallocArena
=
moz_create_arena
(
)
;
ArrayBufferContentsArena
=
moz_create_arena
(
)
;
}
void
js
:
:
ShutDownMallocAllocator
(
)
{
}
JS_PUBLIC_API
(
void
)
JS_Assert
(
const
char
*
s
const
char
*
file
int
ln
)
{
MOZ_ReportAssertionFailure
(
s
file
ln
)
;
MOZ_CRASH
(
)
;
}
#
ifdef
__linux__
#
include
<
malloc
.
h
>
#
include
<
stdlib
.
h
>
namespace
js
{
extern
MOZ_COLD
void
AllTheNonBasicVanillaNewAllocations
(
)
{
intptr_t
p
=
intptr_t
(
malloc
(
16
)
)
+
intptr_t
(
calloc
(
1
16
)
)
+
intptr_t
(
realloc
(
nullptr
16
)
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
[
16
]
)
+
intptr_t
(
memalign
(
16
16
)
)
+
intptr_t
(
strdup
(
"
dummy
"
)
)
;
printf
(
"
%
u
\
n
"
uint32_t
(
p
)
)
;
free
(
(
int
*
)
p
)
;
MOZ_CRASH
(
)
;
}
}
#
endif
