#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
<
stdio
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
util
/
Windows
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
using
namespace
js
;
using
mozilla
:
:
Maybe
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
namespace
js
{
mozilla
:
:
Atomic
<
AutoEnterOOMUnsafeRegion
*
>
AutoEnterOOMUnsafeRegion
:
:
owner_
;
namespace
oom
{
JS_PUBLIC_DATA
FailureSimulator
simulator
;
static
MOZ_THREAD_LOCAL
(
uint32_t
)
threadType
;
bool
InitThreadType
(
)
{
return
threadType
.
init
(
)
;
}
void
SetThreadType
(
ThreadType
type
)
{
threadType
.
set
(
type
)
;
}
uint32_t
GetThreadType
(
void
)
{
return
threadType
.
get
(
)
;
}
static
inline
bool
IsHelperThreadType
(
uint32_t
thread
)
{
return
thread
!
=
THREAD_TYPE_NONE
&
&
thread
!
=
THREAD_TYPE_MAIN
;
}
void
FailureSimulator
:
:
simulateFailureAfter
(
Kind
kind
uint64_t
checks
uint32_t
thread
bool
always
)
{
Maybe
<
AutoLockHelperThreadState
>
lock
;
if
(
IsHelperThreadType
(
targetThread_
)
|
|
IsHelperThreadType
(
thread
)
)
{
lock
.
emplace
(
)
;
HelperThreadState
(
)
.
waitForAllThreadsLocked
(
lock
.
ref
(
)
)
;
}
MOZ_ASSERT
(
counter_
+
checks
>
counter_
)
;
MOZ_ASSERT
(
thread
>
js
:
:
THREAD_TYPE_NONE
&
&
thread
<
js
:
:
THREAD_TYPE_MAX
)
;
targetThread_
=
thread
;
maxChecks_
=
counter_
+
checks
;
failAlways_
=
always
;
kind_
=
kind
;
}
void
FailureSimulator
:
:
reset
(
)
{
Maybe
<
AutoLockHelperThreadState
>
lock
;
if
(
IsHelperThreadType
(
targetThread_
)
)
{
lock
.
emplace
(
)
;
HelperThreadState
(
)
.
waitForAllThreadsLocked
(
lock
.
ref
(
)
)
;
}
targetThread_
=
THREAD_TYPE_NONE
;
maxChecks_
=
UINT64_MAX
;
failAlways_
=
false
;
kind_
=
Kind
:
:
Nothing
;
}
}
}
#
endif
#
if
defined
(
FUZZING
)
namespace
js
{
namespace
oom
{
JS_PUBLIC_DATA
size_t
largeAllocLimit
=
0
;
void
InitLargeAllocLimit
(
)
{
char
*
limitStr
=
getenv
(
"
MOZ_FUZZ_LARGE_ALLOC_LIMIT
"
)
;
if
(
limitStr
)
{
largeAllocLimit
=
atoll
(
limitStr
)
;
}
}
}
}
#
endif
bool
js
:
:
gDisablePoisoning
=
false
;
JS_PUBLIC_DATA
arena_id_t
js
:
:
MallocArena
;
JS_PUBLIC_DATA
arena_id_t
js
:
:
ArrayBufferContentsArena
;
JS_PUBLIC_DATA
arena_id_t
js
:
:
StringBufferArena
;
void
js
:
:
InitMallocAllocator
(
)
{
MallocArena
=
moz_create_arena
(
)
;
arena_params_t
params
;
params
.
mFlags
|
=
ARENA_FLAG_RANDOMIZE_SMALL
;
ArrayBufferContentsArena
=
moz_create_arena_with_params
(
&
params
)
;
StringBufferArena
=
moz_create_arena_with_params
(
&
params
)
;
}
void
js
:
:
ShutDownMallocAllocator
(
)
{
}
#
ifdef
MOZ_DEBUG
extern
void
js
:
:
AssertJSStringBufferInCorrectArena
(
const
void
*
ptr
)
{
#
if
defined
(
MOZ_MEMORY
)
&
&
defined
(
MOZ_DEBUG
)
if
(
ptr
)
{
jemalloc_ptr_info_t
ptrInfo
{
}
;
jemalloc_ptr_info
(
ptr
&
ptrInfo
)
;
MOZ_ASSERT
(
ptrInfo
.
tag
!
=
TagUnknown
)
;
MOZ_ASSERT
(
ptrInfo
.
arenaId
=
=
js
:
:
StringBufferArena
)
;
}
#
endif
}
#
endif
JS_PUBLIC_API
void
JS_Assert
(
const
char
*
s
const
char
*
file
int
ln
)
{
MOZ_ReportAssertionFailure
(
s
file
ln
)
;
MOZ_CRASH
(
)
;
}
#
ifdef
__linux__
#
include
<
malloc
.
h
>
#
include
<
stdlib
.
h
>
namespace
js
{
extern
MOZ_COLD
void
AllTheNonBasicVanillaNewAllocations
(
)
{
intptr_t
p
=
intptr_t
(
malloc
(
16
)
)
+
intptr_t
(
calloc
(
1
16
)
)
+
intptr_t
(
realloc
(
nullptr
16
)
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
)
+
intptr_t
(
new
char
[
16
]
)
+
intptr_t
(
memalign
(
16
16
)
)
+
intptr_t
(
strdup
(
"
dummy
"
)
)
;
printf
(
"
%
u
\
n
"
uint32_t
(
p
)
)
;
free
(
(
int
*
)
p
)
;
MOZ_CRASH
(
)
;
}
}
#
endif
