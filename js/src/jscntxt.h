#
ifndef
jscntxt_h
#
define
jscntxt_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
ErrorReporting
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4100
)
/
*
Silence
unreferenced
formal
parameter
warnings
*
/
#
endif
struct
DtoaState
;
namespace
js
{
class
AutoCompartment
;
namespace
jit
{
class
JitContext
;
class
DebugModeOSRVolatileJitFrameIter
;
}
typedef
HashSet
<
Shape
*
>
ShapeSet
;
class
MOZ_RAII
AutoCycleDetector
{
public
:
using
Vector
=
GCVector
<
JSObject
*
8
>
;
AutoCycleDetector
(
JSContext
*
cx
HandleObject
objArg
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
cx
(
cx
)
obj
(
cx
objArg
)
cyclic
(
true
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCycleDetector
(
)
;
bool
init
(
)
;
bool
foundCycle
(
)
{
return
cyclic
;
}
private
:
JSContext
*
cx
;
RootedObject
obj
;
bool
cyclic
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
struct
AutoResolving
;
struct
HelperThread
;
using
JobQueue
=
GCVector
<
JSObject
*
0
SystemAllocPolicy
>
;
class
AutoLockForExclusiveAccess
;
class
AutoLockScriptData
;
void
ReportOverRecursed
(
JSContext
*
cx
unsigned
errorNumber
)
;
extern
MOZ_THREAD_LOCAL
(
JSContext
*
)
TlsContext
;
enum
class
ContextKind
{
Cooperative
Background
}
;
}
struct
JSContext
:
public
JS
:
:
RootingContext
public
js
:
:
MallocProvider
<
JSContext
>
{
JSContext
(
JSRuntime
*
runtime
const
JS
:
:
ContextOptions
&
options
)
;
~
JSContext
(
)
;
bool
init
(
js
:
:
ContextKind
kind
)
;
private
:
js
:
:
UnprotectedData
<
JSRuntime
*
>
runtime_
;
js
:
:
WriteOnceData
<
js
:
:
ContextKind
>
kind_
;
js
:
:
WriteOnceData
<
size_t
>
threadNative_
;
js
:
:
ThreadLocalData
<
js
:
:
HelperThread
*
>
helperThread_
;
js
:
:
ThreadLocalData
<
JS
:
:
ContextOptions
>
options_
;
js
:
:
ThreadLocalData
<
js
:
:
gc
:
:
ArenaLists
*
>
arenas_
;
public
:
void
setRuntime
(
JSRuntime
*
rt
)
;
bool
isCooperativelyScheduled
(
)
const
{
return
kind_
=
=
js
:
:
ContextKind
:
:
Cooperative
;
}
size_t
threadNative
(
)
const
{
return
threadNative_
;
}
inline
js
:
:
gc
:
:
ArenaLists
*
arenas
(
)
const
{
return
arenas_
;
}
template
<
typename
T
>
bool
isInsideCurrentZone
(
T
thing
)
const
{
return
thing
-
>
zoneFromAnyThread
(
)
=
=
zone_
;
}
template
<
typename
T
>
inline
bool
isInsideCurrentCompartment
(
T
thing
)
const
{
return
thing
-
>
compartment
(
)
=
=
compartment_
;
}
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
{
if
(
helperThread
(
)
)
{
addPendingOutOfMemory
(
)
;
return
nullptr
;
}
return
runtime_
-
>
onOutOfMemory
(
allocFunc
nbytes
reallocPtr
this
)
;
}
void
recoverFromOutOfMemory
(
)
;
void
updateMallocCounter
(
size_t
nbytes
)
;
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
this
)
;
}
JSAtomState
&
names
(
)
{
return
*
runtime_
-
>
commonNames
;
}
js
:
:
StaticStrings
&
staticStrings
(
)
{
return
*
runtime_
-
>
staticStrings
;
}
js
:
:
SharedImmutableStringsCache
&
sharedImmutableStrings
(
)
{
return
runtime_
-
>
sharedImmutableStrings
(
)
;
}
bool
isPermanentAtomsInitialized
(
)
{
return
!
!
runtime_
-
>
permanentAtoms
;
}
js
:
:
FrozenAtomSet
&
permanentAtoms
(
)
{
return
*
runtime_
-
>
permanentAtoms
;
}
js
:
:
WellKnownSymbols
&
wellKnownSymbols
(
)
{
return
*
runtime_
-
>
wellKnownSymbols
;
}
JS
:
:
BuildIdOp
buildIdOp
(
)
{
return
runtime_
-
>
buildIdOp
;
}
const
JS
:
:
AsmJSCacheOps
&
asmJSCacheOps
(
)
{
return
runtime_
-
>
asmJSCacheOps
;
}
js
:
:
PropertyName
*
emptyString
(
)
{
return
runtime_
-
>
emptyString
;
}
js
:
:
FreeOp
*
defaultFreeOp
(
)
{
return
runtime_
-
>
defaultFreeOp
(
)
;
}
void
*
stackLimitAddress
(
JS
:
:
StackKind
kind
)
{
return
&
nativeStackLimit
[
kind
]
;
}
void
*
stackLimitAddressForJitCode
(
JS
:
:
StackKind
kind
)
;
uintptr_t
stackLimit
(
JS
:
:
StackKind
kind
)
{
return
nativeStackLimit
[
kind
]
;
}
uintptr_t
stackLimitForJitCode
(
JS
:
:
StackKind
kind
)
;
size_t
gcSystemPageSize
(
)
{
return
js
:
:
gc
:
:
SystemPageSize
(
)
;
}
bool
jitSupportsFloatingPoint
(
)
const
{
return
runtime_
-
>
jitSupportsFloatingPoint
;
}
bool
jitSupportsUnalignedAccesses
(
)
const
{
return
runtime_
-
>
jitSupportsUnalignedAccesses
;
}
bool
jitSupportsSimd
(
)
const
{
return
runtime_
-
>
jitSupportsSimd
;
}
bool
lcovEnabled
(
)
const
{
return
runtime_
-
>
lcovOutput
(
)
.
isEnabled
(
)
;
}
protected
:
js
:
:
ThreadLocalData
<
unsigned
>
enterCompartmentDepth_
;
inline
void
setCompartment
(
JSCompartment
*
comp
const
js
:
:
AutoLockForExclusiveAccess
*
maybeLock
=
nullptr
)
;
public
:
bool
hasEnteredCompartment
(
)
const
{
return
enterCompartmentDepth_
>
0
;
}
#
ifdef
DEBUG
unsigned
getEnterCompartmentDepth
(
)
const
{
return
enterCompartmentDepth_
;
}
#
endif
private
:
inline
void
enterNonAtomsCompartment
(
JSCompartment
*
c
)
;
inline
void
enterAtomsCompartment
(
JSCompartment
*
c
const
js
:
:
AutoLockForExclusiveAccess
&
lock
)
;
friend
class
js
:
:
AutoCompartment
;
public
:
template
<
typename
T
>
inline
void
enterCompartmentOf
(
const
T
&
target
)
;
inline
void
enterNullCompartment
(
)
;
inline
void
leaveCompartment
(
JSCompartment
*
oldCompartment
const
js
:
:
AutoLockForExclusiveAccess
*
maybeLock
=
nullptr
)
;
inline
void
enterZoneGroup
(
js
:
:
ZoneGroup
*
group
)
;
inline
void
leaveZoneGroup
(
js
:
:
ZoneGroup
*
group
)
;
void
setHelperThread
(
js
:
:
HelperThread
*
helperThread
)
;
js
:
:
HelperThread
*
helperThread
(
)
const
{
return
helperThread_
;
}
JSCompartment
*
compartment
(
)
const
{
return
compartment_
;
}
JS
:
:
Zone
*
zone
(
)
const
{
MOZ_ASSERT_IF
(
!
compartment
(
)
!
zone_
)
;
MOZ_ASSERT_IF
(
compartment
(
)
js
:
:
GetCompartmentZone
(
compartment
(
)
)
=
=
zone_
)
;
return
zoneRaw
(
)
;
}
JS
:
:
Zone
*
zoneRaw
(
)
const
{
return
zone_
;
}
static
size_t
offsetOfZone
(
)
{
return
offsetof
(
JSContext
zone_
)
;
}
inline
js
:
:
LifoAlloc
&
typeLifoAlloc
(
)
;
inline
js
:
:
Handle
<
js
:
:
GlobalObject
*
>
global
(
)
const
;
js
:
:
AtomSet
&
atoms
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
runtime_
-
>
atoms
(
lock
)
;
}
JSCompartment
*
atomsCompartment
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
runtime_
-
>
atomsCompartment
(
lock
)
;
}
js
:
:
SymbolRegistry
&
symbolRegistry
(
js
:
:
AutoLockForExclusiveAccess
&
lock
)
{
return
runtime_
-
>
symbolRegistry
(
lock
)
;
}
js
:
:
ScriptDataTable
&
scriptDataTable
(
js
:
:
AutoLockScriptData
&
lock
)
{
return
runtime_
-
>
scriptDataTable
(
lock
)
;
}
js
:
:
gc
:
:
AtomMarkingRuntime
&
atomMarking
(
)
{
return
runtime_
-
>
gc
.
atomMarking
;
}
void
markAtom
(
JSAtom
*
atom
)
{
atomMarking
(
)
.
markAtom
(
this
atom
)
;
}
void
markAtom
(
JS
:
:
Symbol
*
symbol
)
{
atomMarking
(
)
.
markAtom
(
this
symbol
)
;
}
void
markId
(
jsid
id
)
{
atomMarking
(
)
.
markId
(
this
id
)
;
}
void
markAtomValue
(
const
js
:
:
Value
&
value
)
{
atomMarking
(
)
.
markAtomValue
(
this
value
)
;
}
bool
addPendingCompileError
(
js
:
:
CompileError
*
*
err
)
;
void
addPendingOverRecursed
(
)
;
void
addPendingOutOfMemory
(
)
;
JSRuntime
*
runtime
(
)
{
return
runtime_
;
}
const
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
static
size_t
offsetOfCompartment
(
)
{
return
offsetof
(
JSContext
compartment_
)
;
}
friend
class
JS
:
:
AutoSaveExceptionState
;
friend
class
js
:
:
jit
:
:
DebugModeOSRVolatileJitFrameIter
;
friend
void
js
:
:
ReportOverRecursed
(
JSContext
*
unsigned
errorNumber
)
;
void
yieldToEmbedding
(
)
{
(
*
yieldCallback_
)
(
this
)
;
}
void
setYieldCallback
(
js
:
:
YieldCallback
callback
)
{
yieldCallback_
=
callback
;
}
private
:
static
JS
:
:
Error
reportedError
;
static
JS
:
:
OOM
reportedOOM
;
js
:
:
ThreadLocalData
<
js
:
:
YieldCallback
>
yieldCallback_
;
public
:
inline
JS
:
:
Result
<
>
boolToResult
(
bool
ok
)
;
template
<
typename
V
typename
E
>
bool
resultToBool
(
const
JS
:
:
Result
<
V
E
>
&
result
)
{
return
result
.
isOk
(
)
;
}
template
<
typename
V
typename
E
>
V
*
resultToPtr
(
const
JS
:
:
Result
<
V
*
E
>
&
result
)
{
return
result
.
isOk
(
)
?
result
.
unwrap
(
)
:
nullptr
;
}
mozilla
:
:
GenericErrorResult
<
JS
:
:
OOM
&
>
alreadyReportedOOM
(
)
;
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
alreadyReportedError
(
)
;
js
:
:
ThreadLocalData
<
js
:
:
jit
:
:
JitActivation
*
>
jitActivation
;
js
:
:
ThreadLocalData
<
js
:
:
irregexp
:
:
RegExpStack
>
regexpStack
;
js
:
:
ThreadLocalData
<
js
:
:
Activation
*
>
activation_
;
js
:
:
Activation
*
volatile
profilingActivation_
;
public
:
js
:
:
Activation
*
activation
(
)
const
{
return
activation_
;
}
static
size_t
offsetOfActivation
(
)
{
return
offsetof
(
JSContext
activation_
)
;
}
js
:
:
Activation
*
profilingActivation
(
)
const
{
return
profilingActivation_
;
}
static
size_t
offsetOfProfilingActivation
(
)
{
return
offsetof
(
JSContext
profilingActivation_
)
;
}
static
size_t
offsetOfJitActivation
(
)
{
return
offsetof
(
JSContext
jitActivation
)
;
}
#
ifdef
DEBUG
static
size_t
offsetOfInUnsafeCallWithABI
(
)
{
return
offsetof
(
JSContext
inUnsafeCallWithABI
)
;
}
#
endif
private
:
js
:
:
ThreadLocalData
<
js
:
:
InterpreterStack
>
interpreterStack_
;
public
:
js
:
:
InterpreterStack
&
interpreterStack
(
)
{
return
interpreterStack_
.
ref
(
)
;
}
const
uintptr_t
nativeStackBase
;
js
:
:
ThreadLocalData
<
size_t
>
nativeStackQuota
[
JS
:
:
StackKindCount
]
;
public
:
js
:
:
ThreadLocalData
<
JS
:
:
dbg
:
:
AutoEntryMonitor
*
>
entryMonitor
;
js
:
:
ThreadLocalData
<
js
:
:
EnterDebuggeeNoExecute
*
>
noExecuteDebuggerTop
;
js
:
:
ThreadLocalData
<
js
:
:
ActivityCallback
>
activityCallback
;
js
:
:
ThreadLocalData
<
void
*
>
activityCallbackArg
;
void
triggerActivityCallback
(
bool
active
)
;
js
:
:
ThreadLocalData
<
unsigned
>
requestDepth
;
#
ifdef
DEBUG
js
:
:
ThreadLocalData
<
unsigned
>
checkRequestDepth
;
js
:
:
ThreadLocalData
<
uint32_t
>
inUnsafeCallWithABI
;
js
:
:
ThreadLocalData
<
bool
>
hasAutoUnsafeCallWithABI
;
#
endif
#
ifdef
JS_SIMULATOR
private
:
js
:
:
ThreadLocalData
<
js
:
:
jit
:
:
Simulator
*
>
simulator_
;
public
:
js
:
:
jit
:
:
Simulator
*
simulator
(
)
const
;
uintptr_t
*
addressOfSimulatorStackLimit
(
)
;
#
endif
#
ifdef
JS_TRACE_LOGGING
js
:
:
ThreadLocalData
<
js
:
:
TraceLoggerThread
*
>
traceLogger
;
#
endif
private
:
js
:
:
ThreadLocalData
<
js
:
:
jit
:
:
AutoFlushICache
*
>
autoFlushICache_
;
public
:
js
:
:
jit
:
:
AutoFlushICache
*
autoFlushICache
(
)
const
;
void
setAutoFlushICache
(
js
:
:
jit
:
:
AutoFlushICache
*
afc
)
;
js
:
:
ThreadLocalData
<
DtoaState
*
>
dtoaState
;
js
:
:
ThreadLocalData
<
JS
:
:
HeapState
>
heapState
;
js
:
:
ThreadLocalData
<
int32_t
>
suppressGC
;
#
ifdef
DEBUG
js
:
:
ThreadLocalData
<
bool
>
ionCompiling
;
js
:
:
ThreadLocalData
<
bool
>
ionCompilingSafeForMinorGC
;
js
:
:
ThreadLocalData
<
bool
>
performingGC
;
js
:
:
ThreadLocalData
<
bool
>
gcSweeping
;
js
:
:
ThreadLocalData
<
bool
>
gcHelperStateThread
;
js
:
:
ThreadLocalData
<
size_t
>
noGCOrAllocationCheck
;
js
:
:
ThreadLocalData
<
size_t
>
noNurseryAllocationCheck
;
js
:
:
ThreadLocalData
<
uintptr_t
>
disableStrictProxyCheckingCount
;
bool
isAllocAllowed
(
)
{
return
noGCOrAllocationCheck
=
=
0
;
}
void
disallowAlloc
(
)
{
+
+
noGCOrAllocationCheck
;
}
void
allowAlloc
(
)
{
MOZ_ASSERT
(
!
isAllocAllowed
(
)
)
;
-
-
noGCOrAllocationCheck
;
}
bool
isNurseryAllocAllowed
(
)
{
return
noNurseryAllocationCheck
=
=
0
;
}
void
disallowNurseryAlloc
(
)
{
+
+
noNurseryAllocationCheck
;
}
void
allowNurseryAlloc
(
)
{
MOZ_ASSERT
(
!
isNurseryAllocAllowed
(
)
)
;
-
-
noNurseryAllocationCheck
;
}
bool
isStrictProxyCheckingEnabled
(
)
{
return
disableStrictProxyCheckingCount
=
=
0
;
}
void
disableStrictProxyChecking
(
)
{
+
+
disableStrictProxyCheckingCount
;
}
void
enableStrictProxyChecking
(
)
{
MOZ_ASSERT
(
disableStrictProxyCheckingCount
>
0
)
;
-
-
disableStrictProxyCheckingCount
;
}
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
js
:
:
ThreadLocalData
<
bool
>
runningOOMTest
;
#
endif
js
:
:
ThreadLocalData
<
unsigned
>
enableAccessValidation
;
js
:
:
ThreadLocalData
<
int
>
inUnsafeRegion
;
js
:
:
ThreadLocalData
<
unsigned
>
generationalDisabled
;
js
:
:
ThreadLocalData
<
unsigned
>
compactingDisabledCount
;
js
:
:
ThreadLocalData
<
unsigned
>
keepAtoms
;
bool
canCollectAtoms
(
)
const
{
return
!
keepAtoms
&
&
!
runtime
(
)
-
>
hasHelperThreadZones
(
)
;
}
private
:
js
:
:
ThreadLocalData
<
js
:
:
frontend
:
:
NameCollectionPool
>
frontendCollectionPool_
;
public
:
js
:
:
frontend
:
:
NameCollectionPool
&
frontendCollectionPool
(
)
{
return
frontendCollectionPool_
.
ref
(
)
;
}
void
verifyIsSafeToGC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
inUnsafeRegion
"
[
AutoAssertNoGC
]
possible
GC
in
GC
-
unsafe
region
"
)
;
}
private
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
suppressProfilerSampling
;
public
:
bool
isProfilerSamplingEnabled
(
)
const
{
return
!
suppressProfilerSampling
;
}
void
disableProfilerSampling
(
)
{
suppressProfilerSampling
=
true
;
}
void
enableProfilerSampling
(
)
{
suppressProfilerSampling
=
false
;
}
private
:
js
:
:
UnprotectedData
<
js
:
:
GeckoProfilerThread
>
geckoProfiler_
;
public
:
js
:
:
GeckoProfilerThread
&
geckoProfiler
(
)
{
return
geckoProfiler_
.
ref
(
)
;
}
#
if
defined
(
XP_DARWIN
)
js
:
:
wasm
:
:
MachExceptionHandler
wasmMachExceptionHandler
;
#
endif
static
const
size_t
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
=
4
*
1024
;
private
:
js
:
:
ThreadLocalData
<
js
:
:
LifoAlloc
>
tempLifoAlloc_
;
public
:
js
:
:
LifoAlloc
&
tempLifoAlloc
(
)
{
return
tempLifoAlloc_
.
ref
(
)
;
}
const
js
:
:
LifoAlloc
&
tempLifoAlloc
(
)
const
{
return
tempLifoAlloc_
.
ref
(
)
;
}
js
:
:
ThreadLocalData
<
uint32_t
>
debuggerMutations
;
js
:
:
ThreadLocalData
<
js
:
:
jit
:
:
PcScriptCache
*
>
ionPcScriptCache
;
private
:
js
:
:
ThreadLocalData
<
bool
>
throwing
;
js
:
:
ThreadLocalData
<
JS
:
:
PersistentRooted
<
JS
:
:
Value
>
>
unwrappedException_
;
JS
:
:
Value
&
unwrappedException
(
)
{
if
(
!
unwrappedException_
.
ref
(
)
.
initialized
(
)
)
unwrappedException_
.
ref
(
)
.
init
(
this
)
;
return
unwrappedException_
.
ref
(
)
.
get
(
)
;
}
js
:
:
ThreadLocalData
<
bool
>
overRecursed_
;
js
:
:
ThreadLocalData
<
bool
>
propagatingForcedReturn_
;
js
:
:
ThreadLocalData
<
js
:
:
jit
:
:
DebugModeOSRVolatileJitFrameIter
*
>
liveVolatileJitFrameIter_
;
public
:
js
:
:
ThreadLocalData
<
int32_t
>
reportGranularity
;
js
:
:
ThreadLocalData
<
js
:
:
AutoResolving
*
>
resolvingList
;
#
ifdef
DEBUG
js
:
:
ThreadLocalData
<
js
:
:
AutoEnterPolicy
*
>
enteredPolicy
;
#
endif
js
:
:
ThreadLocalData
<
bool
>
generatingError
;
private
:
js
:
:
ThreadLocalData
<
js
:
:
AutoCycleDetector
:
:
Vector
>
cycleDetectorVector_
;
public
:
js
:
:
AutoCycleDetector
:
:
Vector
&
cycleDetectorVector
(
)
{
return
cycleDetectorVector_
.
ref
(
)
;
}
const
js
:
:
AutoCycleDetector
:
:
Vector
&
cycleDetectorVector
(
)
const
{
return
cycleDetectorVector_
.
ref
(
)
;
}
js
:
:
UnprotectedData
<
void
*
>
data
;
void
initJitStackLimit
(
)
;
void
resetJitStackLimit
(
)
;
public
:
JS
:
:
ContextOptions
&
options
(
)
{
return
options_
.
ref
(
)
;
}
bool
runtimeMatches
(
JSRuntime
*
rt
)
const
{
return
runtime_
=
=
rt
;
}
js
:
:
ThreadLocalData
<
unsigned
>
outstandingRequests
;
js
:
:
ThreadLocalData
<
bool
>
jitIsBroken
;
void
updateJITEnabled
(
)
;
private
:
js
:
:
ThreadLocalData
<
JS
:
:
PersistentRooted
<
js
:
:
SavedFrame
*
>
>
asyncStackForNewActivations_
;
public
:
js
:
:
SavedFrame
*
&
asyncStackForNewActivations
(
)
{
if
(
!
asyncStackForNewActivations_
.
ref
(
)
.
initialized
(
)
)
asyncStackForNewActivations_
.
ref
(
)
.
init
(
this
)
;
return
asyncStackForNewActivations_
.
ref
(
)
.
get
(
)
;
}
js
:
:
ThreadLocalData
<
const
char
*
>
asyncCauseForNewActivations
;
js
:
:
ThreadLocalData
<
bool
>
asyncCallIsExplicit
;
bool
currentlyRunningInInterpreter
(
)
const
{
return
activation
(
)
-
>
isInterpreter
(
)
;
}
bool
currentlyRunningInJit
(
)
const
{
return
activation
(
)
-
>
isJit
(
)
;
}
js
:
:
InterpreterFrame
*
interpreterFrame
(
)
const
{
return
activation
(
)
-
>
asInterpreter
(
)
-
>
current
(
)
;
}
js
:
:
InterpreterRegs
&
interpreterRegs
(
)
const
{
return
activation
(
)
-
>
asInterpreter
(
)
-
>
regs
(
)
;
}
enum
MaybeAllowCrossCompartment
{
DONT_ALLOW_CROSS_COMPARTMENT
=
false
ALLOW_CROSS_COMPARTMENT
=
true
}
;
inline
JSScript
*
currentScript
(
jsbytecode
*
*
pc
=
nullptr
MaybeAllowCrossCompartment
=
DONT_ALLOW_CROSS_COMPARTMENT
)
const
;
inline
js
:
:
Nursery
&
nursery
(
)
;
inline
void
minorGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
public
:
bool
isExceptionPending
(
)
const
{
return
throwing
;
}
MOZ_MUST_USE
bool
getPendingException
(
JS
:
:
MutableHandleValue
rval
)
;
bool
isThrowingOutOfMemory
(
)
;
bool
isThrowingDebuggeeWouldRun
(
)
;
bool
isClosingGenerator
(
)
;
void
setPendingException
(
const
js
:
:
Value
&
v
)
;
void
clearPendingException
(
)
{
throwing
=
false
;
overRecursed_
=
false
;
unwrappedException
(
)
.
setUndefined
(
)
;
}
bool
isThrowingOverRecursed
(
)
const
{
return
throwing
&
&
overRecursed_
;
}
bool
isPropagatingForcedReturn
(
)
const
{
return
propagatingForcedReturn_
;
}
void
setPropagatingForcedReturn
(
)
{
propagatingForcedReturn_
=
true
;
}
void
clearPropagatingForcedReturn
(
)
{
propagatingForcedReturn_
=
false
;
}
inline
bool
runningWithTrustedPrincipals
(
)
;
JS_FRIEND_API
(
size_t
)
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
trace
(
JSTracer
*
trc
)
;
inline
js
:
:
RuntimeCaches
&
caches
(
)
;
private
:
JS_FRIEND_API
(
void
)
checkMallocGCPressure
(
void
*
p
)
;
public
:
using
InterruptCallbackVector
=
js
:
:
Vector
<
JSInterruptCallback
2
js
:
:
SystemAllocPolicy
>
;
private
:
js
:
:
ThreadLocalData
<
InterruptCallbackVector
>
interruptCallbacks_
;
public
:
InterruptCallbackVector
&
interruptCallbacks
(
)
{
return
interruptCallbacks_
.
ref
(
)
;
}
js
:
:
ThreadLocalData
<
bool
>
interruptCallbackDisabled
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interruptRegExpJit_
;
enum
InterruptMode
{
RequestInterruptUrgent
RequestInterruptCanWait
}
;
void
requestInterrupt
(
InterruptMode
mode
)
;
bool
handleInterrupt
(
)
;
MOZ_ALWAYS_INLINE
bool
hasPendingInterrupt
(
)
const
{
static_assert
(
sizeof
(
interrupt_
)
=
=
sizeof
(
uint32_t
)
"
Assumed
by
JIT
callers
"
)
;
return
interrupt_
;
}
private
:
mozilla
:
:
Atomic
<
bool
>
handlingJitInterrupt_
;
public
:
bool
startHandlingJitInterrupt
(
)
{
return
handlingJitInterrupt_
.
compareExchange
(
false
true
)
;
}
void
finishHandlingJitInterrupt
(
)
{
MOZ_ASSERT
(
handlingJitInterrupt_
)
;
handlingJitInterrupt_
=
false
;
}
bool
handlingJitInterrupt
(
)
const
{
return
handlingJitInterrupt_
;
}
js
:
:
FutexThread
fx
;
js
:
:
ThreadLocalData
<
uint8_t
*
>
osrTempData_
;
uint8_t
*
allocateOsrTempData
(
size_t
size
)
;
void
freeOsrTempData
(
)
;
js
:
:
ThreadLocalData
<
js
:
:
Value
>
ionReturnOverride_
;
bool
hasIonReturnOverride
(
)
const
{
return
!
ionReturnOverride_
.
ref
(
)
.
isMagic
(
JS_ARG_POISON
)
;
}
js
:
:
Value
takeIonReturnOverride
(
)
{
js
:
:
Value
v
=
ionReturnOverride_
;
ionReturnOverride_
=
js
:
:
MagicValue
(
JS_ARG_POISON
)
;
return
v
;
}
void
setIonReturnOverride
(
const
js
:
:
Value
&
v
)
{
MOZ_ASSERT
(
!
hasIonReturnOverride
(
)
)
;
MOZ_ASSERT
(
!
v
.
isMagic
(
)
)
;
ionReturnOverride_
=
v
;
}
mozilla
:
:
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
jitStackLimit
;
js
:
:
ThreadLocalData
<
uintptr_t
>
jitStackLimitNoInterrupt
;
js
:
:
ThreadLocalData
<
JSGetIncumbentGlobalCallback
>
getIncumbentGlobalCallback
;
js
:
:
ThreadLocalData
<
JSEnqueuePromiseJobCallback
>
enqueuePromiseJobCallback
;
js
:
:
ThreadLocalData
<
void
*
>
enqueuePromiseJobCallbackData
;
js
:
:
ThreadLocalData
<
JS
:
:
PersistentRooted
<
js
:
:
JobQueue
>
*
>
jobQueue
;
js
:
:
ThreadLocalData
<
bool
>
drainingJobQueue
;
js
:
:
ThreadLocalData
<
bool
>
stopDrainingJobQueue
;
js
:
:
ThreadLocalData
<
JSPromiseRejectionTrackerCallback
>
promiseRejectionTrackerCallback
;
js
:
:
ThreadLocalData
<
void
*
>
promiseRejectionTrackerCallbackData
;
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
;
bool
enqueuePromiseJob
(
JSContext
*
cx
js
:
:
HandleFunction
job
js
:
:
HandleObject
promise
js
:
:
HandleObject
incumbentGlobal
)
;
void
addUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
void
removeUnhandledRejectedPromise
(
JSContext
*
cx
js
:
:
HandleObject
promise
)
;
}
;
inline
JS
:
:
Result
<
>
JSContext
:
:
boolToResult
(
bool
ok
)
{
if
(
MOZ_LIKELY
(
ok
)
)
{
MOZ_ASSERT
(
!
isExceptionPending
(
)
)
;
MOZ_ASSERT
(
!
isPropagatingForcedReturn
(
)
)
;
return
JS
:
:
Ok
(
)
;
}
return
JS
:
:
Result
<
>
(
reportedError
)
;
}
inline
JSContext
*
JSRuntime
:
:
activeContextFromOwnThread
(
)
{
MOZ_ASSERT
(
activeContext
(
)
=
=
js
:
:
TlsContext
.
get
(
)
)
;
return
activeContext
(
)
;
}
namespace
js
{
struct
MOZ_RAII
AutoResolving
{
public
:
enum
Kind
{
LOOKUP
WATCH
}
;
AutoResolving
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Kind
kind
=
LOOKUP
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
context
(
cx
)
object
(
obj
)
id
(
id
)
kind
(
kind
)
link
(
cx
-
>
resolvingList
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
obj
)
;
cx
-
>
resolvingList
=
this
;
}
~
AutoResolving
(
)
{
MOZ_ASSERT
(
context
-
>
resolvingList
=
=
this
)
;
context
-
>
resolvingList
=
link
;
}
bool
alreadyStarted
(
)
const
{
return
link
&
&
alreadyStartedSlow
(
)
;
}
private
:
bool
alreadyStartedSlow
(
)
const
;
JSContext
*
const
context
;
HandleObject
object
;
HandleId
id
;
Kind
const
kind
;
AutoResolving
*
const
link
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
extern
JSContext
*
NewContext
(
uint32_t
maxBytes
uint32_t
maxNurseryBytes
JSRuntime
*
parentRuntime
)
;
extern
JSContext
*
NewCooperativeContext
(
JSContext
*
siblingContext
)
;
extern
void
YieldCooperativeContext
(
JSContext
*
cx
)
;
extern
void
ResumeCooperativeContext
(
JSContext
*
cx
)
;
extern
void
DestroyContext
(
JSContext
*
cx
)
;
enum
ErrorArgumentsType
{
ArgumentsAreUnicode
ArgumentsAreASCII
ArgumentsAreLatin1
ArgumentsAreUTF8
}
;
JSFunction
*
SelfHostedFunction
(
JSContext
*
cx
HandlePropertyName
propName
)
;
#
ifdef
va_start
extern
bool
ReportErrorVA
(
JSContext
*
cx
unsigned
flags
const
char
*
format
ErrorArgumentsType
argumentsType
va_list
ap
)
MOZ_FORMAT_PRINTF
(
3
0
)
;
extern
bool
ReportErrorNumberVA
(
JSContext
*
cx
unsigned
flags
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
ErrorArgumentsType
argumentsType
va_list
ap
)
;
extern
bool
ReportErrorNumberUCArray
(
JSContext
*
cx
unsigned
flags
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
const
char16_t
*
*
args
)
;
#
endif
extern
bool
ExpandErrorArgumentsVA
(
JSContext
*
cx
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
const
char16_t
*
*
messageArgs
ErrorArgumentsType
argumentsType
JSErrorReport
*
reportp
va_list
ap
)
;
extern
bool
ExpandErrorArgumentsVA
(
JSContext
*
cx
JSErrorCallback
callback
void
*
userRef
const
unsigned
errorNumber
const
char16_t
*
*
messageArgs
ErrorArgumentsType
argumentsType
JSErrorNotes
:
:
Note
*
notep
va_list
ap
)
;
extern
void
ReportUsageErrorASCII
(
JSContext
*
cx
HandleObject
callee
const
char
*
msg
)
;
extern
bool
PrintError
(
JSContext
*
cx
FILE
*
file
JS
:
:
ConstUTF8CharsZ
toStringResult
JSErrorReport
*
report
bool
reportWarnings
)
;
extern
bool
ReportIsNotDefined
(
JSContext
*
cx
HandlePropertyName
name
)
;
extern
bool
ReportIsNotDefined
(
JSContext
*
cx
HandleId
id
)
;
extern
bool
ReportIsNullOrUndefined
(
JSContext
*
cx
int
spindex
HandleValue
v
HandleString
fallback
)
;
extern
void
ReportMissingArg
(
JSContext
*
cx
js
:
:
HandleValue
v
unsigned
arg
)
;
extern
bool
ReportValueErrorFlags
(
JSContext
*
cx
unsigned
flags
const
unsigned
errorNumber
int
spindex
HandleValue
v
HandleString
fallback
const
char
*
arg1
const
char
*
arg2
)
;
#
define
ReportValueError
(
cx
errorNumber
spindex
v
fallback
)
\
(
(
void
)
ReportValueErrorFlags
(
cx
JSREPORT_ERROR
errorNumber
\
spindex
v
fallback
nullptr
nullptr
)
)
#
define
ReportValueError2
(
cx
errorNumber
spindex
v
fallback
arg1
)
\
(
(
void
)
ReportValueErrorFlags
(
cx
JSREPORT_ERROR
errorNumber
\
spindex
v
fallback
arg1
nullptr
)
)
#
define
ReportValueError3
(
cx
errorNumber
spindex
v
fallback
arg1
arg2
)
\
(
(
void
)
ReportValueErrorFlags
(
cx
JSREPORT_ERROR
errorNumber
\
spindex
v
fallback
arg1
arg2
)
)
JSObject
*
CreateErrorNotesArray
(
JSContext
*
cx
JSErrorReport
*
report
)
;
}
extern
const
JSErrorFormatString
js_ErrorFormatString
[
JSErr_Limit
]
;
namespace
js
{
class
MOZ_RAII
AutoArrayRooter
:
private
JS
:
:
AutoGCRooter
{
public
:
AutoArrayRooter
(
JSContext
*
cx
size_t
len
Value
*
vec
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
AutoGCRooter
(
cx
len
)
array
(
vec
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
tag_
>
=
0
)
;
}
void
changeLength
(
size_t
newLength
)
{
tag_
=
ptrdiff_t
(
newLength
)
;
MOZ_ASSERT
(
tag_
>
=
0
)
;
}
void
changeArray
(
Value
*
newArray
size_t
newLength
)
{
changeLength
(
newLength
)
;
array
=
newArray
;
}
Value
*
start
(
)
{
return
array
;
}
size_t
length
(
)
{
MOZ_ASSERT
(
tag_
>
=
0
)
;
return
size_t
(
tag_
)
;
}
MutableHandleValue
handleAt
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
size_t
(
tag_
)
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
array
[
i
]
)
;
}
HandleValue
handleAt
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
size_t
(
tag_
)
)
;
return
HandleValue
:
:
fromMarkedLocation
(
&
array
[
i
]
)
;
}
MutableHandleValue
operator
[
]
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
size_t
(
tag_
)
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
array
[
i
]
)
;
}
HandleValue
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
size_t
(
tag_
)
)
;
return
HandleValue
:
:
fromMarkedLocation
(
&
array
[
i
]
)
;
}
friend
void
JS
:
:
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
;
private
:
Value
*
array
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
AutoAssertNoException
{
#
ifdef
DEBUG
JSContext
*
cx
;
bool
hadException
;
#
endif
public
:
explicit
AutoAssertNoException
(
JSContext
*
cx
)
#
ifdef
DEBUG
:
cx
(
cx
)
hadException
(
cx
-
>
isExceptionPending
(
)
)
#
endif
{
}
~
AutoAssertNoException
(
)
{
MOZ_ASSERT_IF
(
!
hadException
!
cx
-
>
isExceptionPending
(
)
)
;
}
}
;
class
MOZ_RAII
AutoLockForExclusiveAccess
{
JSRuntime
*
runtime
;
void
init
(
JSRuntime
*
rt
)
{
runtime
=
rt
;
if
(
runtime
-
>
hasHelperThreadZones
(
)
)
{
runtime
-
>
exclusiveAccessLock
.
lock
(
)
;
}
else
{
MOZ_ASSERT
(
!
runtime
-
>
activeThreadHasExclusiveAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasExclusiveAccess
=
true
;
#
endif
}
}
public
:
explicit
AutoLockForExclusiveAccess
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
init
(
cx
-
>
runtime
(
)
)
;
}
explicit
AutoLockForExclusiveAccess
(
JSRuntime
*
rt
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
init
(
rt
)
;
}
~
AutoLockForExclusiveAccess
(
)
{
if
(
runtime
-
>
hasHelperThreadZones
(
)
)
{
runtime
-
>
exclusiveAccessLock
.
unlock
(
)
;
}
else
{
MOZ_ASSERT
(
runtime
-
>
activeThreadHasExclusiveAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasExclusiveAccess
=
false
;
#
endif
}
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoLockScriptData
{
JSRuntime
*
runtime
;
public
:
explicit
AutoLockScriptData
(
JSRuntime
*
rt
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
runtime
=
rt
;
if
(
runtime
-
>
hasHelperThreadZones
(
)
)
{
runtime
-
>
scriptDataLock
.
lock
(
)
;
}
else
{
MOZ_ASSERT
(
!
runtime
-
>
activeThreadHasScriptDataAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasScriptDataAccess
=
true
;
#
endif
}
}
~
AutoLockScriptData
(
)
{
if
(
runtime
-
>
hasHelperThreadZones
(
)
)
{
runtime
-
>
scriptDataLock
.
unlock
(
)
;
}
else
{
MOZ_ASSERT
(
runtime
-
>
activeThreadHasScriptDataAccess
)
;
#
ifdef
DEBUG
runtime
-
>
activeThreadHasScriptDataAccess
=
false
;
#
endif
}
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoKeepAtoms
{
JSContext
*
cx
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoKeepAtoms
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
cx
(
cx
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
cx
-
>
keepAtoms
+
+
;
}
~
AutoKeepAtoms
(
)
{
MOZ_ASSERT
(
cx
-
>
keepAtoms
)
;
cx
-
>
keepAtoms
-
-
;
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
cx
-
>
helperThread
(
)
)
{
if
(
rt
-
>
gc
.
fullGCForAtomsRequested
(
)
&
&
cx
-
>
canCollectAtoms
(
)
)
rt
-
>
gc
.
triggerFullGCForAtoms
(
cx
)
;
}
}
}
;
class
MOZ_RAII
AutoEnterIonCompilation
{
public
:
explicit
AutoEnterIonCompilation
(
bool
safeForMinorGC
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
DEBUG
JSContext
*
cx
=
TlsContext
.
get
(
)
;
MOZ_ASSERT
(
!
cx
-
>
ionCompiling
)
;
MOZ_ASSERT
(
!
cx
-
>
ionCompilingSafeForMinorGC
)
;
cx
-
>
ionCompiling
=
true
;
cx
-
>
ionCompilingSafeForMinorGC
=
safeForMinorGC
;
#
endif
}
~
AutoEnterIonCompilation
(
)
{
#
ifdef
DEBUG
JSContext
*
cx
=
TlsContext
.
get
(
)
;
MOZ_ASSERT
(
cx
-
>
ionCompiling
)
;
cx
-
>
ionCompiling
=
false
;
cx
-
>
ionCompilingSafeForMinorGC
=
false
;
#
endif
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoUnsafeCallWithABI
{
#
ifdef
DEBUG
JSContext
*
cx_
;
bool
nested_
;
#
endif
JS
:
:
AutoCheckCannotGC
nogc
;
public
:
#
ifdef
DEBUG
AutoUnsafeCallWithABI
(
)
;
~
AutoUnsafeCallWithABI
(
)
;
#
endif
}
;
namespace
gc
{
struct
MOZ_RAII
AutoSetThreadIsPerformingGC
{
#
ifdef
DEBUG
AutoSetThreadIsPerformingGC
(
)
:
cx
(
TlsContext
.
get
(
)
)
{
MOZ_ASSERT
(
!
cx
-
>
performingGC
)
;
cx
-
>
performingGC
=
true
;
}
~
AutoSetThreadIsPerformingGC
(
)
{
MOZ_ASSERT
(
cx
-
>
performingGC
)
;
cx
-
>
performingGC
=
false
;
}
private
:
JSContext
*
cx
;
#
else
AutoSetThreadIsPerformingGC
(
)
{
}
#
endif
}
;
struct
MOZ_RAII
AutoSetThreadIsSweeping
{
#
ifdef
DEBUG
AutoSetThreadIsSweeping
(
)
:
cx
(
TlsContext
.
get
(
)
)
{
MOZ_ASSERT
(
!
cx
-
>
gcSweeping
)
;
cx
-
>
gcSweeping
=
true
;
}
~
AutoSetThreadIsSweeping
(
)
{
MOZ_ASSERT
(
cx
-
>
gcSweeping
)
;
cx
-
>
gcSweeping
=
false
;
}
private
:
JSContext
*
cx
;
#
else
AutoSetThreadIsSweeping
(
)
{
}
#
endif
}
;
}
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
#
endif
