#
ifndef
jsexn_h
#
define
jsexn_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
extern
const
JSErrorFormatString
js_ErrorFormatString
[
JSErr_Limit
]
;
namespace
js
{
class
ErrorObject
;
UniquePtr
<
JSErrorNotes
:
:
Note
>
CopyErrorNote
(
JSContext
*
cx
JSErrorNotes
:
:
Note
*
note
)
;
UniquePtr
<
JSErrorReport
>
CopyErrorReport
(
JSContext
*
cx
JSErrorReport
*
report
)
;
static
const
size_t
MAX_REPORTED_STACK_DEPTH
=
1u
<
<
7
;
bool
CaptureStack
(
JSContext
*
cx
MutableHandleObject
stack
)
;
JSString
*
ComputeStackString
(
JSContext
*
cx
)
;
extern
bool
ErrorToException
(
JSContext
*
cx
JSErrorReport
*
reportp
JSErrorCallback
callback
void
*
userRef
)
;
extern
JSErrorReport
*
ErrorFromException
(
JSContext
*
cx
HandleObject
obj
)
;
extern
JSObject
*
CopyErrorObject
(
JSContext
*
cx
JS
:
:
Handle
<
ErrorObject
*
>
errobj
)
;
static_assert
(
JSEXN_ERR
=
=
0
&
&
JSProto_Error
+
int
(
JSEXN_INTERNALERR
)
=
=
JSProto_InternalError
&
&
JSProto_Error
+
int
(
JSEXN_AGGREGATEERR
)
=
=
JSProto_AggregateError
&
&
JSProto_Error
+
int
(
JSEXN_EVALERR
)
=
=
JSProto_EvalError
&
&
JSProto_Error
+
int
(
JSEXN_RANGEERR
)
=
=
JSProto_RangeError
&
&
JSProto_Error
+
int
(
JSEXN_REFERENCEERR
)
=
=
JSProto_ReferenceError
&
&
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
JSProto_Error
+
int
(
JSEXN_SUPPRESSEDERR
)
=
=
JSProto_SuppressedError
&
&
#
endif
JSProto_Error
+
int
(
JSEXN_SYNTAXERR
)
=
=
JSProto_SyntaxError
&
&
JSProto_Error
+
int
(
JSEXN_TYPEERR
)
=
=
JSProto_TypeError
&
&
JSProto_Error
+
int
(
JSEXN_URIERR
)
=
=
JSProto_URIError
&
&
JSProto_Error
+
int
(
JSEXN_DEBUGGEEWOULDRUN
)
=
=
JSProto_DebuggeeWouldRun
&
&
JSProto_Error
+
int
(
JSEXN_WASMCOMPILEERROR
)
=
=
JSProto_CompileError
&
&
JSProto_Error
+
int
(
JSEXN_WASMLINKERROR
)
=
=
JSProto_LinkError
&
&
JSProto_Error
+
int
(
JSEXN_WASMRUNTIMEERROR
)
=
=
JSProto_RuntimeError
&
&
#
ifdef
ENABLE_WASM_JSPI
JSProto_Error
+
int
(
JSEXN_WASMSUSPENDERROR
)
=
=
JSProto_SuspendError
&
&
JSEXN_WASMSUSPENDERROR
+
1
=
=
JSEXN_WARN
&
&
#
else
JSEXN_WASMRUNTIMEERROR
+
1
=
=
JSEXN_WARN
&
&
#
endif
JSEXN_WARN
+
1
=
=
JSEXN_NOTE
&
&
JSEXN_NOTE
+
1
=
=
JSEXN_LIMIT
"
GetExceptionProtoKey
and
ExnTypeFromProtoKey
require
that
"
"
each
corresponding
JSExnType
and
JSProtoKey
value
be
separated
"
"
by
the
same
constant
value
"
)
;
static
inline
constexpr
JSProtoKey
GetExceptionProtoKey
(
JSExnType
exn
)
{
MOZ_ASSERT
(
JSEXN_ERR
<
=
exn
)
;
MOZ_ASSERT
(
exn
<
JSEXN_WARN
)
;
return
JSProtoKey
(
JSProto_Error
+
int
(
exn
)
)
;
}
static
inline
JSExnType
ExnTypeFromProtoKey
(
JSProtoKey
key
)
{
JSExnType
type
=
static_cast
<
JSExnType
>
(
key
-
JSProto_Error
)
;
MOZ_ASSERT
(
type
>
=
JSEXN_ERR
)
;
MOZ_ASSERT
(
type
<
JSEXN_ERROR_LIMIT
)
;
return
type
;
}
static
inline
bool
IsErrorProtoKey
(
JSProtoKey
key
)
{
int
type
=
key
-
JSProto_Error
;
return
type
>
=
JSEXN_ERR
&
&
type
<
JSEXN_ERROR_LIMIT
;
}
class
AutoClearPendingException
{
JSContext
*
cx
;
public
:
explicit
AutoClearPendingException
(
JSContext
*
cxArg
)
:
cx
(
cxArg
)
{
}
~
AutoClearPendingException
(
)
{
JS_ClearPendingException
(
cx
)
;
}
}
;
extern
const
char
*
ValueToSourceForError
(
JSContext
*
cx
HandleValue
val
JS
:
:
UniqueChars
&
bytes
)
;
bool
GetInternalError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
;
bool
GetTypeError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
;
bool
GetAggregateError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
;
}
#
endif
