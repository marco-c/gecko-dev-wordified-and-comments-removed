import
gdb
import
gdb
.
types
import
struct
import
mozilla
.
prettyprinters
from
mozilla
.
prettyprinters
import
pretty_printer
mozilla
.
prettyprinters
.
clear_module_printers
(
__name__
)
class
Box
(
object
)
:
    
def
__init__
(
self
asBits
jtc
)
:
        
self
.
asBits
=
asBits
        
self
.
jtc
=
jtc
        
if
self
.
asBits
<
0
:
            
self
.
asBits
=
self
.
asBits
+
(
1
<
<
64
)
    
def
tag
(
self
)
:
raise
NotImplementedError
    
def
as_uint32
(
self
)
:
raise
NotImplementedError
    
def
as_double
(
self
)
:
raise
NotImplementedError
    
def
as_address
(
self
)
:
raise
NotImplementedError
class
Punbox
(
Box
)
:
    
TAG_SHIFT
=
47
    
PAYLOAD_MASK
=
(
1
<
<
TAG_SHIFT
)
-
1
    
TAG_MAX_NON_DOUBLE
=
0xe
    
DOUBLE_ADJUST
=
0x0007FFFFFFFFFFFF
    
def
tag
(
self
)
:
        
tag
=
int
(
self
.
asBits
>
>
Punbox
.
TAG_SHIFT
)
        
if
tag
>
Punbox
.
TAG_MAX_NON_DOUBLE
:
            
return
self
.
jtc
.
DOUBLE
        
else
:
            
return
self
.
jtc
.
tagMap
[
tag
]
    
def
as_double
(
self
)
:
        
packed
=
struct
.
pack
(
"
q
"
self
.
asBits
-
Punbox
.
DOUBLE_ADJUST
)
        
(
unpacked
)
=
struct
.
unpack
(
"
d
"
packed
)
        
return
unpacked
    
def
as_uint32
(
self
)
:
return
int
(
self
.
asBits
&
(
(
1
<
<
32
)
-
1
)
)
    
def
as_address
(
self
)
:
return
gdb
.
Value
(
self
.
asBits
&
Punbox
.
PAYLOAD_MASK
)
class
Nunbox
(
Box
)
:
    
TAG_SHIFT
=
32
    
TAG_CLEAR
=
0xffff0000
    
PAYLOAD_MASK
=
0xffffffff
    
TAG_TYPE_MASK
=
0x0000000f
    
def
tag
(
self
)
:
        
tag
=
self
.
asBits
>
>
Nunbox
.
TAG_SHIFT
        
if
tag
<
Nunbox
.
TAG_CLEAR
:
            
return
self
.
jtc
.
DOUBLE
        
return
tag
&
Nunbox
.
TAG_TYPE_MASK
    
def
as_double
(
self
)
:
        
packed
=
struct
.
pack
(
"
q
"
self
.
asBits
)
        
(
unpacked
)
=
struct
.
unpack
(
"
d
"
packed
)
        
return
unpacked
    
def
as_uint32
(
self
)
:
return
int
(
self
.
asBits
&
Nunbox
.
PAYLOAD_MASK
)
    
def
as_address
(
self
)
:
return
gdb
.
Value
(
self
.
asBits
&
Nunbox
.
PAYLOAD_MASK
)
class
JSValueTypeCache
(
object
)
:
    
def
__init__
(
self
cache
)
:
        
d
=
gdb
.
types
.
make_enum_dict
(
gdb
.
lookup_type
(
'
JSValueType
'
)
)
        
def
getter
(
enum_dict
prefix
)
:
            
def
get
(
key
)
:
                
val
=
enum_dict
.
get
(
key
)
                
if
val
is
not
None
:
                    
return
val
                
return
enum_dict
[
prefix
+
key
]
            
return
get
        
getType
=
getter
(
d
'
JSValueType
:
:
'
)
        
self
.
DOUBLE
=
getType
(
'
JSVAL_TYPE_DOUBLE
'
)
        
self
.
INT32
=
getType
(
'
JSVAL_TYPE_INT32
'
)
        
self
.
UNDEFINED
=
getType
(
'
JSVAL_TYPE_UNDEFINED
'
)
        
self
.
BOOLEAN
=
getType
(
'
JSVAL_TYPE_BOOLEAN
'
)
        
self
.
MAGIC
=
getType
(
'
JSVAL_TYPE_MAGIC
'
)
        
self
.
STRING
=
getType
(
'
JSVAL_TYPE_STRING
'
)
        
self
.
SYMBOL
=
getType
(
'
JSVAL_TYPE_SYMBOL
'
)
        
self
.
BIGINT
=
getType
(
'
JSVAL_TYPE_BIGINT
'
)
        
self
.
NULL
=
getType
(
'
JSVAL_TYPE_NULL
'
)
        
self
.
OBJECT
=
getType
(
'
JSVAL_TYPE_OBJECT
'
)
        
d
=
gdb
.
types
.
make_enum_dict
(
gdb
.
lookup_type
(
'
JSWhyMagic
'
)
)
        
self
.
magic_names
=
list
(
range
(
max
(
d
.
values
(
)
)
+
1
)
)
        
for
(
k
v
)
in
d
.
items
(
)
:
            
self
.
magic_names
[
v
]
=
k
        
if
cache
.
void_ptr_t
.
sizeof
=
=
4
:
            
self
.
boxer
=
Nunbox
        
else
:
            
self
.
boxer
=
Punbox
            
d2
=
gdb
.
types
.
make_enum_dict
(
gdb
.
lookup_type
(
'
JSValueTag
'
)
)
            
getTag
=
getter
(
d2
'
JSValueTag
:
:
'
)
            
self
.
tagMap
=
{
}
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_INT32
'
)
]
=
self
.
INT32
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_UNDEFINED
'
)
]
=
self
.
UNDEFINED
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_BOOLEAN
'
)
]
=
self
.
BOOLEAN
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_MAGIC
'
)
]
=
self
.
MAGIC
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_STRING
'
)
]
=
self
.
STRING
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_SYMBOL
'
)
]
=
self
.
SYMBOL
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_BIGINT
'
)
]
=
self
.
BIGINT
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_NULL
'
)
]
=
self
.
NULL
            
self
.
tagMap
[
getTag
(
'
JSVAL_TAG_OBJECT
'
)
]
=
self
.
OBJECT
pretty_printer
(
'
JS
:
:
Value
'
)
class
JSValue
(
object
)
:
    
def
__init__
(
self
value
cache
)
:
        
self
.
cache
=
cache
        
if
not
cache
.
mod_JS_Value
:
            
cache
.
mod_JS_Value
=
JSValueTypeCache
(
cache
)
        
self
.
jtc
=
cache
.
mod_JS_Value
        
self
.
value
=
value
        
self
.
box
=
self
.
jtc
.
boxer
(
value
[
'
asBits_
'
]
self
.
jtc
)
    
def
to_string
(
self
)
:
        
tag
=
self
.
box
.
tag
(
)
        
if
tag
=
=
self
.
jtc
.
UNDEFINED
:
            
return
'
JS
:
:
UndefinedValue
(
)
'
        
if
tag
=
=
self
.
jtc
.
NULL
:
            
return
'
JS
:
:
NullValue
(
)
'
        
if
tag
=
=
self
.
jtc
.
BOOLEAN
:
            
return
'
JS
:
:
BooleanValue
(
%
s
)
'
%
str
(
self
.
box
.
as_uint32
(
)
!
=
0
)
.
lower
(
)
        
if
tag
=
=
self
.
jtc
.
MAGIC
:
            
value
=
self
.
box
.
as_uint32
(
)
            
if
0
<
=
value
and
value
<
len
(
self
.
jtc
.
magic_names
)
:
                
return
'
JS
:
:
MagicValue
(
%
s
)
'
%
(
self
.
jtc
.
magic_names
[
value
]
)
            
else
:
                
return
'
JS
:
:
MagicValue
(
%
d
)
'
%
(
value
)
        
if
tag
=
=
self
.
jtc
.
INT32
:
            
value
=
self
.
box
.
as_uint32
(
)
            
signbit
=
1
<
<
31
            
value
=
(
value
^
signbit
)
-
signbit
            
return
'
JS
:
:
Int32Value
(
%
s
)
'
%
value
        
if
tag
=
=
self
.
jtc
.
DOUBLE
:
            
return
'
JS
:
:
DoubleValue
(
%
s
)
'
%
self
.
box
.
as_double
(
)
        
if
tag
=
=
self
.
jtc
.
STRING
:
            
value
=
self
.
box
.
as_address
(
)
.
cast
(
self
.
cache
.
JSString_ptr_t
)
        
elif
tag
=
=
self
.
jtc
.
OBJECT
:
            
value
=
self
.
box
.
as_address
(
)
.
cast
(
self
.
cache
.
JSObject_ptr_t
)
        
elif
tag
=
=
self
.
jtc
.
SYMBOL
:
            
value
=
self
.
box
.
as_address
(
)
.
cast
(
self
.
cache
.
JSSymbol_ptr_t
)
        
elif
tag
=
=
self
.
jtc
.
BIGINT
:
            
return
'
JS
:
:
BigIntValue
(
)
'
        
else
:
            
value
=
'
unrecognized
!
'
        
return
'
JS
:
:
Value
(
%
s
)
'
%
(
value
)
