#
include
"
new
-
regexp
/
regexp
-
compiler
.
h
"
#
include
"
new
-
regexp
/
regexp
.
h
"
#
ifdef
V8_INTL_SUPPORT
#
include
"
new
-
regexp
/
special
-
case
.
h
"
#
endif
#
ifdef
V8_INTL_SUPPORT
#
include
"
unicode
/
locid
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
endif
namespace
v8
{
namespace
internal
{
using
namespace
regexp_compiler_constants
;
RegExpNode
*
RegExpAtom
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
ZoneList
<
TextElement
>
*
elms
=
new
(
compiler
-
>
zone
(
)
)
ZoneList
<
TextElement
>
(
1
compiler
-
>
zone
(
)
)
;
elms
-
>
Add
(
TextElement
:
:
Atom
(
this
)
compiler
-
>
zone
(
)
)
;
return
new
(
compiler
-
>
zone
(
)
)
TextNode
(
elms
compiler
-
>
read_backward
(
)
on_success
)
;
}
RegExpNode
*
RegExpText
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
return
new
(
compiler
-
>
zone
(
)
)
TextNode
(
elements
(
)
compiler
-
>
read_backward
(
)
on_success
)
;
}
static
bool
CompareInverseRanges
(
ZoneList
<
CharacterRange
>
*
ranges
const
int
*
special_class
int
length
)
{
length
-
-
;
DCHECK_EQ
(
kRangeEndMarker
special_class
[
length
]
)
;
DCHECK_NE
(
0
ranges
-
>
length
(
)
)
;
DCHECK_NE
(
0
length
)
;
DCHECK_NE
(
0
special_class
[
0
]
)
;
if
(
ranges
-
>
length
(
)
!
=
(
length
>
>
1
)
+
1
)
{
return
false
;
}
CharacterRange
range
=
ranges
-
>
at
(
0
)
;
if
(
range
.
from
(
)
!
=
0
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
length
;
i
+
=
2
)
{
if
(
special_class
[
i
]
!
=
(
range
.
to
(
)
+
1
)
)
{
return
false
;
}
range
=
ranges
-
>
at
(
(
i
>
>
1
)
+
1
)
;
if
(
special_class
[
i
+
1
]
!
=
range
.
from
(
)
)
{
return
false
;
}
}
if
(
range
.
to
(
)
!
=
String
:
:
kMaxCodePoint
)
{
return
false
;
}
return
true
;
}
static
bool
CompareRanges
(
ZoneList
<
CharacterRange
>
*
ranges
const
int
*
special_class
int
length
)
{
length
-
-
;
DCHECK_EQ
(
kRangeEndMarker
special_class
[
length
]
)
;
if
(
ranges
-
>
length
(
)
*
2
!
=
length
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
length
;
i
+
=
2
)
{
CharacterRange
range
=
ranges
-
>
at
(
i
>
>
1
)
;
if
(
range
.
from
(
)
!
=
special_class
[
i
]
|
|
range
.
to
(
)
!
=
special_class
[
i
+
1
]
-
1
)
{
return
false
;
}
}
return
true
;
}
bool
RegExpCharacterClass
:
:
is_standard
(
Zone
*
zone
)
{
if
(
is_negated
(
)
)
{
return
false
;
}
if
(
set_
.
is_standard
(
)
)
{
return
true
;
}
if
(
CompareRanges
(
set_
.
ranges
(
zone
)
kSpaceRanges
kSpaceRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
s
'
)
;
return
true
;
}
if
(
CompareInverseRanges
(
set_
.
ranges
(
zone
)
kSpaceRanges
kSpaceRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
S
'
)
;
return
true
;
}
if
(
CompareInverseRanges
(
set_
.
ranges
(
zone
)
kLineTerminatorRanges
kLineTerminatorRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
.
'
)
;
return
true
;
}
if
(
CompareRanges
(
set_
.
ranges
(
zone
)
kLineTerminatorRanges
kLineTerminatorRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
n
'
)
;
return
true
;
}
if
(
CompareRanges
(
set_
.
ranges
(
zone
)
kWordRanges
kWordRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
w
'
)
;
return
true
;
}
if
(
CompareInverseRanges
(
set_
.
ranges
(
zone
)
kWordRanges
kWordRangeCount
)
)
{
set_
.
set_standard_set_type
(
'
W
'
)
;
return
true
;
}
return
false
;
}
UnicodeRangeSplitter
:
:
UnicodeRangeSplitter
(
ZoneList
<
CharacterRange
>
*
base
)
{
for
(
int
i
=
0
;
i
<
base
-
>
length
(
)
;
i
+
+
)
AddRange
(
base
-
>
at
(
i
)
)
;
}
void
UnicodeRangeSplitter
:
:
AddRange
(
CharacterRange
range
)
{
static
constexpr
uc32
kBmp1Start
=
0
;
static
constexpr
uc32
kBmp1End
=
kLeadSurrogateStart
-
1
;
static
constexpr
uc32
kBmp2Start
=
kTrailSurrogateEnd
+
1
;
static
constexpr
uc32
kBmp2End
=
kNonBmpStart
-
1
;
STATIC_ASSERT
(
kBmp1Start
=
=
0
)
;
STATIC_ASSERT
(
kBmp1Start
<
kBmp1End
)
;
STATIC_ASSERT
(
kBmp1End
+
1
=
=
kLeadSurrogateStart
)
;
STATIC_ASSERT
(
kLeadSurrogateStart
<
kLeadSurrogateEnd
)
;
STATIC_ASSERT
(
kLeadSurrogateEnd
+
1
=
=
kTrailSurrogateStart
)
;
STATIC_ASSERT
(
kTrailSurrogateStart
<
kTrailSurrogateEnd
)
;
STATIC_ASSERT
(
kTrailSurrogateEnd
+
1
=
=
kBmp2Start
)
;
STATIC_ASSERT
(
kBmp2Start
<
kBmp2End
)
;
STATIC_ASSERT
(
kBmp2End
+
1
=
=
kNonBmpStart
)
;
STATIC_ASSERT
(
kNonBmpStart
<
kNonBmpEnd
)
;
static
constexpr
uc32
kStarts
[
]
=
{
kBmp1Start
kLeadSurrogateStart
kTrailSurrogateStart
kBmp2Start
kNonBmpStart
}
;
static
constexpr
uc32
kEnds
[
]
=
{
kBmp1End
kLeadSurrogateEnd
kTrailSurrogateEnd
kBmp2End
kNonBmpEnd
}
;
CharacterRangeVector
*
const
kTargets
[
]
=
{
&
bmp_
&
lead_surrogates_
&
trail_surrogates_
&
bmp_
&
non_bmp_
}
;
static
constexpr
int
kCount
=
arraysize
(
kStarts
)
;
STATIC_ASSERT
(
kCount
=
=
arraysize
(
kEnds
)
)
;
STATIC_ASSERT
(
kCount
=
=
arraysize
(
kTargets
)
)
;
for
(
int
i
=
0
;
i
<
kCount
;
i
+
+
)
{
if
(
kStarts
[
i
]
>
range
.
to
(
)
)
break
;
const
uc32
from
=
std
:
:
max
(
kStarts
[
i
]
range
.
from
(
)
)
;
const
uc32
to
=
std
:
:
min
(
kEnds
[
i
]
range
.
to
(
)
)
;
if
(
from
>
to
)
continue
;
kTargets
[
i
]
-
>
emplace_back
(
CharacterRange
:
:
Range
(
from
to
)
)
;
}
}
namespace
{
ZoneList
<
CharacterRange
>
*
ToCanonicalZoneList
(
const
UnicodeRangeSplitter
:
:
CharacterRangeVector
*
v
Zone
*
zone
)
{
if
(
v
-
>
empty
(
)
)
return
nullptr
;
ZoneList
<
CharacterRange
>
*
result
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
static_cast
<
int
>
(
v
-
>
size
(
)
)
zone
)
;
for
(
size_t
i
=
0
;
i
<
v
-
>
size
(
)
;
i
+
+
)
{
result
-
>
Add
(
v
-
>
at
(
i
)
zone
)
;
}
CharacterRange
:
:
Canonicalize
(
result
)
;
return
result
;
}
void
AddBmpCharacters
(
RegExpCompiler
*
compiler
ChoiceNode
*
result
RegExpNode
*
on_success
UnicodeRangeSplitter
*
splitter
)
{
ZoneList
<
CharacterRange
>
*
bmp
=
ToCanonicalZoneList
(
splitter
-
>
bmp
(
)
compiler
-
>
zone
(
)
)
;
if
(
bmp
=
=
nullptr
)
return
;
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
result
-
>
AddAlternative
(
GuardedAlternative
(
TextNode
:
:
CreateForCharacterRanges
(
compiler
-
>
zone
(
)
bmp
compiler
-
>
read_backward
(
)
on_success
default_flags
)
)
)
;
}
void
AddNonBmpSurrogatePairs
(
RegExpCompiler
*
compiler
ChoiceNode
*
result
RegExpNode
*
on_success
UnicodeRangeSplitter
*
splitter
)
{
ZoneList
<
CharacterRange
>
*
non_bmp
=
ToCanonicalZoneList
(
splitter
-
>
non_bmp
(
)
compiler
-
>
zone
(
)
)
;
if
(
non_bmp
=
=
nullptr
)
return
;
DCHECK
(
!
compiler
-
>
one_byte
(
)
)
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
CharacterRange
:
:
Canonicalize
(
non_bmp
)
;
for
(
int
i
=
0
;
i
<
non_bmp
-
>
length
(
)
;
i
+
+
)
{
uc32
from
=
non_bmp
-
>
at
(
i
)
.
from
(
)
;
uc32
to
=
non_bmp
-
>
at
(
i
)
.
to
(
)
;
uc16
from_l
=
unibrow
:
:
Utf16
:
:
LeadSurrogate
(
from
)
;
uc16
from_t
=
unibrow
:
:
Utf16
:
:
TrailSurrogate
(
from
)
;
uc16
to_l
=
unibrow
:
:
Utf16
:
:
LeadSurrogate
(
to
)
;
uc16
to_t
=
unibrow
:
:
Utf16
:
:
TrailSurrogate
(
to
)
;
if
(
from_l
=
=
to_l
)
{
result
-
>
AddAlternative
(
GuardedAlternative
(
TextNode
:
:
CreateForSurrogatePair
(
zone
CharacterRange
:
:
Singleton
(
from_l
)
CharacterRange
:
:
Range
(
from_t
to_t
)
compiler
-
>
read_backward
(
)
on_success
default_flags
)
)
)
;
}
else
{
if
(
from_t
!
=
kTrailSurrogateStart
)
{
result
-
>
AddAlternative
(
GuardedAlternative
(
TextNode
:
:
CreateForSurrogatePair
(
zone
CharacterRange
:
:
Singleton
(
from_l
)
CharacterRange
:
:
Range
(
from_t
kTrailSurrogateEnd
)
compiler
-
>
read_backward
(
)
on_success
default_flags
)
)
)
;
from_l
+
+
;
}
if
(
to_t
!
=
kTrailSurrogateEnd
)
{
result
-
>
AddAlternative
(
GuardedAlternative
(
TextNode
:
:
CreateForSurrogatePair
(
zone
CharacterRange
:
:
Singleton
(
to_l
)
CharacterRange
:
:
Range
(
kTrailSurrogateStart
to_t
)
compiler
-
>
read_backward
(
)
on_success
default_flags
)
)
)
;
to_l
-
-
;
}
if
(
from_l
<
=
to_l
)
{
result
-
>
AddAlternative
(
GuardedAlternative
(
TextNode
:
:
CreateForSurrogatePair
(
zone
CharacterRange
:
:
Range
(
from_l
to_l
)
CharacterRange
:
:
Range
(
kTrailSurrogateStart
kTrailSurrogateEnd
)
compiler
-
>
read_backward
(
)
on_success
default_flags
)
)
)
;
}
}
}
}
RegExpNode
*
NegativeLookaroundAgainstReadDirectionAndMatch
(
RegExpCompiler
*
compiler
ZoneList
<
CharacterRange
>
*
lookbehind
ZoneList
<
CharacterRange
>
*
match
RegExpNode
*
on_success
bool
read_backward
JSRegExp
:
:
Flags
flags
)
{
Zone
*
zone
=
compiler
-
>
zone
(
)
;
RegExpNode
*
match_node
=
TextNode
:
:
CreateForCharacterRanges
(
zone
match
read_backward
on_success
flags
)
;
int
stack_register
=
compiler
-
>
UnicodeLookaroundStackRegister
(
)
;
int
position_register
=
compiler
-
>
UnicodeLookaroundPositionRegister
(
)
;
RegExpLookaround
:
:
Builder
lookaround
(
false
match_node
stack_register
position_register
)
;
RegExpNode
*
negative_match
=
TextNode
:
:
CreateForCharacterRanges
(
zone
lookbehind
!
read_backward
lookaround
.
on_match_success
(
)
flags
)
;
return
lookaround
.
ForMatch
(
negative_match
)
;
}
RegExpNode
*
MatchAndNegativeLookaroundInReadDirection
(
RegExpCompiler
*
compiler
ZoneList
<
CharacterRange
>
*
match
ZoneList
<
CharacterRange
>
*
lookahead
RegExpNode
*
on_success
bool
read_backward
JSRegExp
:
:
Flags
flags
)
{
Zone
*
zone
=
compiler
-
>
zone
(
)
;
int
stack_register
=
compiler
-
>
UnicodeLookaroundStackRegister
(
)
;
int
position_register
=
compiler
-
>
UnicodeLookaroundPositionRegister
(
)
;
RegExpLookaround
:
:
Builder
lookaround
(
false
on_success
stack_register
position_register
)
;
RegExpNode
*
negative_match
=
TextNode
:
:
CreateForCharacterRanges
(
zone
lookahead
read_backward
lookaround
.
on_match_success
(
)
flags
)
;
return
TextNode
:
:
CreateForCharacterRanges
(
zone
match
read_backward
lookaround
.
ForMatch
(
negative_match
)
flags
)
;
}
void
AddLoneLeadSurrogates
(
RegExpCompiler
*
compiler
ChoiceNode
*
result
RegExpNode
*
on_success
UnicodeRangeSplitter
*
splitter
)
{
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
ZoneList
<
CharacterRange
>
*
lead_surrogates
=
ToCanonicalZoneList
(
splitter
-
>
lead_surrogates
(
)
compiler
-
>
zone
(
)
)
;
if
(
lead_surrogates
=
=
nullptr
)
return
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
CharacterRange
>
*
trail_surrogates
=
CharacterRange
:
:
List
(
zone
CharacterRange
:
:
Range
(
kTrailSurrogateStart
kTrailSurrogateEnd
)
)
;
RegExpNode
*
match
;
if
(
compiler
-
>
read_backward
(
)
)
{
match
=
NegativeLookaroundAgainstReadDirectionAndMatch
(
compiler
trail_surrogates
lead_surrogates
on_success
true
default_flags
)
;
}
else
{
match
=
MatchAndNegativeLookaroundInReadDirection
(
compiler
lead_surrogates
trail_surrogates
on_success
false
default_flags
)
;
}
result
-
>
AddAlternative
(
GuardedAlternative
(
match
)
)
;
}
void
AddLoneTrailSurrogates
(
RegExpCompiler
*
compiler
ChoiceNode
*
result
RegExpNode
*
on_success
UnicodeRangeSplitter
*
splitter
)
{
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
ZoneList
<
CharacterRange
>
*
trail_surrogates
=
ToCanonicalZoneList
(
splitter
-
>
trail_surrogates
(
)
compiler
-
>
zone
(
)
)
;
if
(
trail_surrogates
=
=
nullptr
)
return
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
CharacterRange
>
*
lead_surrogates
=
CharacterRange
:
:
List
(
zone
CharacterRange
:
:
Range
(
kLeadSurrogateStart
kLeadSurrogateEnd
)
)
;
RegExpNode
*
match
;
if
(
compiler
-
>
read_backward
(
)
)
{
match
=
MatchAndNegativeLookaroundInReadDirection
(
compiler
trail_surrogates
lead_surrogates
on_success
true
default_flags
)
;
}
else
{
match
=
NegativeLookaroundAgainstReadDirectionAndMatch
(
compiler
lead_surrogates
trail_surrogates
on_success
false
default_flags
)
;
}
result
-
>
AddAlternative
(
GuardedAlternative
(
match
)
)
;
}
RegExpNode
*
UnanchoredAdvance
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
DCHECK
(
!
compiler
-
>
read_backward
(
)
)
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
CharacterRange
>
*
range
=
CharacterRange
:
:
List
(
zone
CharacterRange
:
:
Range
(
0
String
:
:
kMaxUtf16CodeUnit
)
)
;
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
return
TextNode
:
:
CreateForCharacterRanges
(
zone
range
false
on_success
default_flags
)
;
}
void
AddUnicodeCaseEquivalents
(
ZoneList
<
CharacterRange
>
*
ranges
Zone
*
zone
)
{
#
ifdef
V8_INTL_SUPPORT
DCHECK
(
CharacterRange
:
:
IsCanonical
(
ranges
)
)
;
if
(
ranges
-
>
length
(
)
=
=
1
&
&
ranges
-
>
at
(
0
)
.
IsEverything
(
kNonBmpEnd
)
)
return
;
icu
:
:
UnicodeSet
set
;
for
(
int
i
=
0
;
i
<
ranges
-
>
length
(
)
;
i
+
+
)
{
set
.
add
(
ranges
-
>
at
(
i
)
.
from
(
)
ranges
-
>
at
(
i
)
.
to
(
)
)
;
}
ranges
-
>
Clear
(
)
;
set
.
closeOver
(
USET_CASE_INSENSITIVE
)
;
set
.
removeAllStrings
(
)
;
for
(
int
i
=
0
;
i
<
set
.
getRangeCount
(
)
;
i
+
+
)
{
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
set
.
getRangeStart
(
i
)
set
.
getRangeEnd
(
i
)
)
zone
)
;
}
CharacterRange
:
:
Canonicalize
(
ranges
)
;
#
endif
}
}
RegExpNode
*
RegExpCharacterClass
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
set_
.
Canonicalize
(
)
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
CharacterRange
>
*
ranges
=
this
-
>
ranges
(
zone
)
;
if
(
NeedsUnicodeCaseEquivalents
(
flags_
)
)
{
AddUnicodeCaseEquivalents
(
ranges
zone
)
;
}
if
(
IsUnicode
(
flags_
)
&
&
!
compiler
-
>
one_byte
(
)
&
&
!
contains_split_surrogate
(
)
)
{
if
(
is_negated
(
)
)
{
ZoneList
<
CharacterRange
>
*
negated
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
CharacterRange
:
:
Negate
(
ranges
negated
zone
)
;
ranges
=
negated
;
}
if
(
ranges
-
>
length
(
)
=
=
0
)
{
JSRegExp
:
:
Flags
default_flags
;
RegExpCharacterClass
*
fail
=
new
(
zone
)
RegExpCharacterClass
(
zone
ranges
default_flags
)
;
return
new
(
zone
)
TextNode
(
fail
compiler
-
>
read_backward
(
)
on_success
)
;
}
if
(
standard_type
(
)
=
=
'
*
'
)
{
return
UnanchoredAdvance
(
compiler
on_success
)
;
}
else
{
ChoiceNode
*
result
=
new
(
zone
)
ChoiceNode
(
2
zone
)
;
UnicodeRangeSplitter
splitter
(
ranges
)
;
AddBmpCharacters
(
compiler
result
on_success
&
splitter
)
;
AddNonBmpSurrogatePairs
(
compiler
result
on_success
&
splitter
)
;
AddLoneLeadSurrogates
(
compiler
result
on_success
&
splitter
)
;
AddLoneTrailSurrogates
(
compiler
result
on_success
&
splitter
)
;
static
constexpr
int
kMaxRangesToInline
=
32
;
if
(
ranges
-
>
length
(
)
>
kMaxRangesToInline
)
result
-
>
SetDoNotInline
(
)
;
return
result
;
}
}
else
{
return
new
(
zone
)
TextNode
(
this
compiler
-
>
read_backward
(
)
on_success
)
;
}
}
int
CompareFirstChar
(
RegExpTree
*
const
*
a
RegExpTree
*
const
*
b
)
{
RegExpAtom
*
atom1
=
(
*
a
)
-
>
AsAtom
(
)
;
RegExpAtom
*
atom2
=
(
*
b
)
-
>
AsAtom
(
)
;
uc16
character1
=
atom1
-
>
data
(
)
.
at
(
0
)
;
uc16
character2
=
atom2
-
>
data
(
)
.
at
(
0
)
;
if
(
character1
<
character2
)
return
-
1
;
if
(
character1
>
character2
)
return
1
;
return
0
;
}
#
ifdef
V8_INTL_SUPPORT
int
CompareFirstCharCaseInsensitve
(
RegExpTree
*
const
*
a
RegExpTree
*
const
*
b
)
{
RegExpAtom
*
atom1
=
(
*
a
)
-
>
AsAtom
(
)
;
RegExpAtom
*
atom2
=
(
*
b
)
-
>
AsAtom
(
)
;
icu
:
:
UnicodeString
character1
(
atom1
-
>
data
(
)
.
at
(
0
)
)
;
return
character1
.
caseCompare
(
atom2
-
>
data
(
)
.
at
(
0
)
U_FOLD_CASE_DEFAULT
)
;
}
#
else
static
unibrow
:
:
uchar
Canonical
(
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
canonicalize
unibrow
:
:
uchar
c
)
{
unibrow
:
:
uchar
chars
[
unibrow
:
:
Ecma262Canonicalize
:
:
kMaxWidth
]
;
int
length
=
canonicalize
-
>
get
(
c
'
\
0
'
chars
)
;
DCHECK_LE
(
length
1
)
;
unibrow
:
:
uchar
canonical
=
c
;
if
(
length
=
=
1
)
canonical
=
chars
[
0
]
;
return
canonical
;
}
int
CompareFirstCharCaseIndependent
(
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
canonicalize
RegExpTree
*
const
*
a
RegExpTree
*
const
*
b
)
{
RegExpAtom
*
atom1
=
(
*
a
)
-
>
AsAtom
(
)
;
RegExpAtom
*
atom2
=
(
*
b
)
-
>
AsAtom
(
)
;
unibrow
:
:
uchar
character1
=
atom1
-
>
data
(
)
.
at
(
0
)
;
unibrow
:
:
uchar
character2
=
atom2
-
>
data
(
)
.
at
(
0
)
;
if
(
character1
=
=
character2
)
return
0
;
if
(
character1
>
=
'
a
'
|
|
character2
>
=
'
a
'
)
{
character1
=
Canonical
(
canonicalize
character1
)
;
character2
=
Canonical
(
canonicalize
character2
)
;
}
return
static_cast
<
int
>
(
character1
)
-
static_cast
<
int
>
(
character2
)
;
}
#
endif
bool
RegExpDisjunction
:
:
SortConsecutiveAtoms
(
RegExpCompiler
*
compiler
)
{
ZoneList
<
RegExpTree
*
>
*
alternatives
=
this
-
>
alternatives
(
)
;
int
length
=
alternatives
-
>
length
(
)
;
bool
found_consecutive_atoms
=
false
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
while
(
i
<
length
)
{
RegExpTree
*
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
alternative
-
>
IsAtom
(
)
)
break
;
i
+
+
;
}
if
(
i
=
=
length
)
break
;
int
first_atom
=
i
;
JSRegExp
:
:
Flags
flags
=
alternatives
-
>
at
(
i
)
-
>
AsAtom
(
)
-
>
flags
(
)
;
i
+
+
;
while
(
i
<
length
)
{
RegExpTree
*
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
!
alternative
-
>
IsAtom
(
)
)
break
;
if
(
alternative
-
>
AsAtom
(
)
-
>
flags
(
)
!
=
flags
)
break
;
i
+
+
;
}
DCHECK_LT
(
first_atom
alternatives
-
>
length
(
)
)
;
DCHECK_LE
(
i
alternatives
-
>
length
(
)
)
;
DCHECK_LE
(
first_atom
i
)
;
if
(
IgnoreCase
(
flags
)
)
{
#
ifdef
V8_INTL_SUPPORT
alternatives
-
>
StableSort
(
CompareFirstCharCaseInsensitve
first_atom
i
-
first_atom
)
;
#
else
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
canonicalize
=
compiler
-
>
isolate
(
)
-
>
regexp_macro_assembler_canonicalize
(
)
;
auto
compare_closure
=
[
canonicalize
]
(
RegExpTree
*
const
*
a
RegExpTree
*
const
*
b
)
{
return
CompareFirstCharCaseIndependent
(
canonicalize
a
b
)
;
}
;
alternatives
-
>
StableSort
(
compare_closure
first_atom
i
-
first_atom
)
;
#
endif
}
else
{
alternatives
-
>
StableSort
(
CompareFirstChar
first_atom
i
-
first_atom
)
;
}
if
(
i
-
first_atom
>
1
)
found_consecutive_atoms
=
true
;
}
return
found_consecutive_atoms
;
}
void
RegExpDisjunction
:
:
RationalizeConsecutiveAtoms
(
RegExpCompiler
*
compiler
)
{
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
RegExpTree
*
>
*
alternatives
=
this
-
>
alternatives
(
)
;
int
length
=
alternatives
-
>
length
(
)
;
int
write_posn
=
0
;
int
i
=
0
;
while
(
i
<
length
)
{
RegExpTree
*
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
!
alternative
-
>
IsAtom
(
)
)
{
alternatives
-
>
at
(
write_posn
+
+
)
=
alternatives
-
>
at
(
i
)
;
i
+
+
;
continue
;
}
RegExpAtom
*
const
atom
=
alternative
-
>
AsAtom
(
)
;
JSRegExp
:
:
Flags
flags
=
atom
-
>
flags
(
)
;
#
ifdef
V8_INTL_SUPPORT
icu
:
:
UnicodeString
common_prefix
(
atom
-
>
data
(
)
.
at
(
0
)
)
;
#
else
unibrow
:
:
uchar
common_prefix
=
atom
-
>
data
(
)
.
at
(
0
)
;
#
endif
int
first_with_prefix
=
i
;
int
prefix_length
=
atom
-
>
length
(
)
;
i
+
+
;
while
(
i
<
length
)
{
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
!
alternative
-
>
IsAtom
(
)
)
break
;
RegExpAtom
*
const
atom
=
alternative
-
>
AsAtom
(
)
;
if
(
atom
-
>
flags
(
)
!
=
flags
)
break
;
#
ifdef
V8_INTL_SUPPORT
icu
:
:
UnicodeString
new_prefix
(
atom
-
>
data
(
)
.
at
(
0
)
)
;
if
(
new_prefix
!
=
common_prefix
)
{
if
(
!
IgnoreCase
(
flags
)
)
break
;
if
(
common_prefix
.
caseCompare
(
new_prefix
U_FOLD_CASE_DEFAULT
)
!
=
0
)
break
;
}
#
else
unibrow
:
:
uchar
new_prefix
=
atom
-
>
data
(
)
.
at
(
0
)
;
if
(
new_prefix
!
=
common_prefix
)
{
if
(
!
IgnoreCase
(
flags
)
)
break
;
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
canonicalize
=
compiler
-
>
isolate
(
)
-
>
regexp_macro_assembler_canonicalize
(
)
;
new_prefix
=
Canonical
(
canonicalize
new_prefix
)
;
common_prefix
=
Canonical
(
canonicalize
common_prefix
)
;
if
(
new_prefix
!
=
common_prefix
)
break
;
}
#
endif
prefix_length
=
Min
(
prefix_length
atom
-
>
length
(
)
)
;
i
+
+
;
}
if
(
i
>
first_with_prefix
+
2
)
{
int
run_length
=
i
-
first_with_prefix
;
RegExpAtom
*
const
atom
=
alternatives
-
>
at
(
first_with_prefix
)
-
>
AsAtom
(
)
;
for
(
int
j
=
1
;
j
<
run_length
&
&
prefix_length
>
1
;
j
+
+
)
{
RegExpAtom
*
old_atom
=
alternatives
-
>
at
(
j
+
first_with_prefix
)
-
>
AsAtom
(
)
;
for
(
int
k
=
1
;
k
<
prefix_length
;
k
+
+
)
{
if
(
atom
-
>
data
(
)
.
at
(
k
)
!
=
old_atom
-
>
data
(
)
.
at
(
k
)
)
{
prefix_length
=
k
;
break
;
}
}
}
RegExpAtom
*
prefix
=
new
(
zone
)
RegExpAtom
(
atom
-
>
data
(
)
.
SubVector
(
0
prefix_length
)
flags
)
;
ZoneList
<
RegExpTree
*
>
*
pair
=
new
(
zone
)
ZoneList
<
RegExpTree
*
>
(
2
zone
)
;
pair
-
>
Add
(
prefix
zone
)
;
ZoneList
<
RegExpTree
*
>
*
suffixes
=
new
(
zone
)
ZoneList
<
RegExpTree
*
>
(
run_length
zone
)
;
for
(
int
j
=
0
;
j
<
run_length
;
j
+
+
)
{
RegExpAtom
*
old_atom
=
alternatives
-
>
at
(
j
+
first_with_prefix
)
-
>
AsAtom
(
)
;
int
len
=
old_atom
-
>
length
(
)
;
if
(
len
=
=
prefix_length
)
{
suffixes
-
>
Add
(
new
(
zone
)
RegExpEmpty
(
)
zone
)
;
}
else
{
RegExpTree
*
suffix
=
new
(
zone
)
RegExpAtom
(
old_atom
-
>
data
(
)
.
SubVector
(
prefix_length
old_atom
-
>
length
(
)
)
flags
)
;
suffixes
-
>
Add
(
suffix
zone
)
;
}
}
pair
-
>
Add
(
new
(
zone
)
RegExpDisjunction
(
suffixes
)
zone
)
;
alternatives
-
>
at
(
write_posn
+
+
)
=
new
(
zone
)
RegExpAlternative
(
pair
)
;
}
else
{
for
(
int
j
=
first_with_prefix
;
j
<
i
;
j
+
+
)
{
alternatives
-
>
at
(
write_posn
+
+
)
=
alternatives
-
>
at
(
j
)
;
}
}
}
alternatives
-
>
Rewind
(
write_posn
)
;
}
void
RegExpDisjunction
:
:
FixSingleCharacterDisjunctions
(
RegExpCompiler
*
compiler
)
{
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
RegExpTree
*
>
*
alternatives
=
this
-
>
alternatives
(
)
;
int
length
=
alternatives
-
>
length
(
)
;
int
write_posn
=
0
;
int
i
=
0
;
while
(
i
<
length
)
{
RegExpTree
*
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
!
alternative
-
>
IsAtom
(
)
)
{
alternatives
-
>
at
(
write_posn
+
+
)
=
alternatives
-
>
at
(
i
)
;
i
+
+
;
continue
;
}
RegExpAtom
*
const
atom
=
alternative
-
>
AsAtom
(
)
;
if
(
atom
-
>
length
(
)
!
=
1
)
{
alternatives
-
>
at
(
write_posn
+
+
)
=
alternatives
-
>
at
(
i
)
;
i
+
+
;
continue
;
}
JSRegExp
:
:
Flags
flags
=
atom
-
>
flags
(
)
;
DCHECK_IMPLIES
(
IsUnicode
(
flags
)
!
unibrow
:
:
Utf16
:
:
IsLeadSurrogate
(
atom
-
>
data
(
)
.
at
(
0
)
)
)
;
bool
contains_trail_surrogate
=
unibrow
:
:
Utf16
:
:
IsTrailSurrogate
(
atom
-
>
data
(
)
.
at
(
0
)
)
;
int
first_in_run
=
i
;
i
+
+
;
while
(
i
<
length
)
{
alternative
=
alternatives
-
>
at
(
i
)
;
if
(
!
alternative
-
>
IsAtom
(
)
)
break
;
RegExpAtom
*
const
atom
=
alternative
-
>
AsAtom
(
)
;
if
(
atom
-
>
length
(
)
!
=
1
)
break
;
if
(
atom
-
>
flags
(
)
!
=
flags
)
break
;
DCHECK_IMPLIES
(
IsUnicode
(
flags
)
!
unibrow
:
:
Utf16
:
:
IsLeadSurrogate
(
atom
-
>
data
(
)
.
at
(
0
)
)
)
;
contains_trail_surrogate
|
=
unibrow
:
:
Utf16
:
:
IsTrailSurrogate
(
atom
-
>
data
(
)
.
at
(
0
)
)
;
i
+
+
;
}
if
(
i
>
first_in_run
+
1
)
{
int
run_length
=
i
-
first_in_run
;
ZoneList
<
CharacterRange
>
*
ranges
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
for
(
int
j
=
0
;
j
<
run_length
;
j
+
+
)
{
RegExpAtom
*
old_atom
=
alternatives
-
>
at
(
j
+
first_in_run
)
-
>
AsAtom
(
)
;
DCHECK_EQ
(
old_atom
-
>
length
(
)
1
)
;
ranges
-
>
Add
(
CharacterRange
:
:
Singleton
(
old_atom
-
>
data
(
)
.
at
(
0
)
)
zone
)
;
}
RegExpCharacterClass
:
:
CharacterClassFlags
character_class_flags
;
if
(
IsUnicode
(
flags
)
&
&
contains_trail_surrogate
)
{
character_class_flags
=
RegExpCharacterClass
:
:
CONTAINS_SPLIT_SURROGATE
;
}
alternatives
-
>
at
(
write_posn
+
+
)
=
new
(
zone
)
RegExpCharacterClass
(
zone
ranges
flags
character_class_flags
)
;
}
else
{
for
(
int
j
=
first_in_run
;
j
<
i
;
j
+
+
)
{
alternatives
-
>
at
(
write_posn
+
+
)
=
alternatives
-
>
at
(
j
)
;
}
}
}
alternatives
-
>
Rewind
(
write_posn
)
;
}
RegExpNode
*
RegExpDisjunction
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
ZoneList
<
RegExpTree
*
>
*
alternatives
=
this
-
>
alternatives
(
)
;
if
(
alternatives
-
>
length
(
)
>
2
)
{
bool
found_consecutive_atoms
=
SortConsecutiveAtoms
(
compiler
)
;
if
(
found_consecutive_atoms
)
RationalizeConsecutiveAtoms
(
compiler
)
;
FixSingleCharacterDisjunctions
(
compiler
)
;
if
(
alternatives
-
>
length
(
)
=
=
1
)
{
return
alternatives
-
>
at
(
0
)
-
>
ToNode
(
compiler
on_success
)
;
}
}
int
length
=
alternatives
-
>
length
(
)
;
ChoiceNode
*
result
=
new
(
compiler
-
>
zone
(
)
)
ChoiceNode
(
length
compiler
-
>
zone
(
)
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
GuardedAlternative
alternative
(
alternatives
-
>
at
(
i
)
-
>
ToNode
(
compiler
on_success
)
)
;
result
-
>
AddAlternative
(
alternative
)
;
}
return
result
;
}
RegExpNode
*
RegExpQuantifier
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
return
ToNode
(
min
(
)
max
(
)
is_greedy
(
)
body
(
)
compiler
on_success
)
;
}
namespace
{
RegExpNode
*
BoundaryAssertionAsLookaround
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
RegExpAssertion
:
:
AssertionType
type
JSRegExp
:
:
Flags
flags
)
{
DCHECK
(
NeedsUnicodeCaseEquivalents
(
flags
)
)
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
ZoneList
<
CharacterRange
>
*
word_range
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
CharacterRange
:
:
AddClassEscape
(
'
w
'
word_range
true
zone
)
;
int
stack_register
=
compiler
-
>
UnicodeLookaroundStackRegister
(
)
;
int
position_register
=
compiler
-
>
UnicodeLookaroundPositionRegister
(
)
;
ChoiceNode
*
result
=
new
(
zone
)
ChoiceNode
(
2
zone
)
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
bool
lookbehind_for_word
=
i
=
=
0
;
bool
lookahead_for_word
=
(
type
=
=
RegExpAssertion
:
:
BOUNDARY
)
^
lookbehind_for_word
;
RegExpLookaround
:
:
Builder
lookbehind
(
lookbehind_for_word
on_success
stack_register
position_register
)
;
RegExpNode
*
backward
=
TextNode
:
:
CreateForCharacterRanges
(
zone
word_range
true
lookbehind
.
on_match_success
(
)
flags
)
;
RegExpLookaround
:
:
Builder
lookahead
(
lookahead_for_word
lookbehind
.
ForMatch
(
backward
)
stack_register
position_register
)
;
RegExpNode
*
forward
=
TextNode
:
:
CreateForCharacterRanges
(
zone
word_range
false
lookahead
.
on_match_success
(
)
flags
)
;
result
-
>
AddAlternative
(
GuardedAlternative
(
lookahead
.
ForMatch
(
forward
)
)
)
;
}
return
result
;
}
}
RegExpNode
*
RegExpAssertion
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
NodeInfo
info
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
switch
(
assertion_type
(
)
)
{
case
START_OF_LINE
:
return
AssertionNode
:
:
AfterNewline
(
on_success
)
;
case
START_OF_INPUT
:
return
AssertionNode
:
:
AtStart
(
on_success
)
;
case
BOUNDARY
:
return
NeedsUnicodeCaseEquivalents
(
flags_
)
?
BoundaryAssertionAsLookaround
(
compiler
on_success
BOUNDARY
flags_
)
:
AssertionNode
:
:
AtBoundary
(
on_success
)
;
case
NON_BOUNDARY
:
return
NeedsUnicodeCaseEquivalents
(
flags_
)
?
BoundaryAssertionAsLookaround
(
compiler
on_success
NON_BOUNDARY
flags_
)
:
AssertionNode
:
:
AtNonBoundary
(
on_success
)
;
case
END_OF_INPUT
:
return
AssertionNode
:
:
AtEnd
(
on_success
)
;
case
END_OF_LINE
:
{
int
stack_pointer_register
=
compiler
-
>
AllocateRegister
(
)
;
int
position_register
=
compiler
-
>
AllocateRegister
(
)
;
ChoiceNode
*
result
=
new
(
zone
)
ChoiceNode
(
2
zone
)
;
ZoneList
<
CharacterRange
>
*
newline_ranges
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
3
zone
)
;
CharacterRange
:
:
AddClassEscape
(
'
n
'
newline_ranges
false
zone
)
;
JSRegExp
:
:
Flags
default_flags
=
JSRegExp
:
:
Flags
(
)
;
RegExpCharacterClass
*
newline_atom
=
new
(
zone
)
RegExpCharacterClass
(
'
n
'
default_flags
)
;
TextNode
*
newline_matcher
=
new
(
zone
)
TextNode
(
newline_atom
false
ActionNode
:
:
PositiveSubmatchSuccess
(
stack_pointer_register
position_register
0
-
1
on_success
)
)
;
RegExpNode
*
end_of_line
=
ActionNode
:
:
BeginSubmatch
(
stack_pointer_register
position_register
newline_matcher
)
;
GuardedAlternative
eol_alternative
(
end_of_line
)
;
result
-
>
AddAlternative
(
eol_alternative
)
;
GuardedAlternative
end_alternative
(
AssertionNode
:
:
AtEnd
(
on_success
)
)
;
result
-
>
AddAlternative
(
end_alternative
)
;
return
result
;
}
default
:
UNREACHABLE
(
)
;
}
return
on_success
;
}
RegExpNode
*
RegExpBackReference
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
return
new
(
compiler
-
>
zone
(
)
)
BackReferenceNode
(
RegExpCapture
:
:
StartRegister
(
index
(
)
)
RegExpCapture
:
:
EndRegister
(
index
(
)
)
flags_
compiler
-
>
read_backward
(
)
on_success
)
;
}
RegExpNode
*
RegExpEmpty
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
return
on_success
;
}
RegExpLookaround
:
:
Builder
:
:
Builder
(
bool
is_positive
RegExpNode
*
on_success
int
stack_pointer_register
int
position_register
int
capture_register_count
int
capture_register_start
)
:
is_positive_
(
is_positive
)
on_success_
(
on_success
)
stack_pointer_register_
(
stack_pointer_register
)
position_register_
(
position_register
)
{
if
(
is_positive_
)
{
on_match_success_
=
ActionNode
:
:
PositiveSubmatchSuccess
(
stack_pointer_register
position_register
capture_register_count
capture_register_start
on_success_
)
;
}
else
{
Zone
*
zone
=
on_success_
-
>
zone
(
)
;
on_match_success_
=
new
(
zone
)
NegativeSubmatchSuccess
(
stack_pointer_register
position_register
capture_register_count
capture_register_start
zone
)
;
}
}
RegExpNode
*
RegExpLookaround
:
:
Builder
:
:
ForMatch
(
RegExpNode
*
match
)
{
if
(
is_positive_
)
{
return
ActionNode
:
:
BeginSubmatch
(
stack_pointer_register_
position_register_
match
)
;
}
else
{
Zone
*
zone
=
on_success_
-
>
zone
(
)
;
ChoiceNode
*
choice_node
=
new
(
zone
)
NegativeLookaroundChoiceNode
(
GuardedAlternative
(
match
)
GuardedAlternative
(
on_success_
)
zone
)
;
return
ActionNode
:
:
BeginSubmatch
(
stack_pointer_register_
position_register_
choice_node
)
;
}
}
RegExpNode
*
RegExpLookaround
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
int
stack_pointer_register
=
compiler
-
>
AllocateRegister
(
)
;
int
position_register
=
compiler
-
>
AllocateRegister
(
)
;
const
int
registers_per_capture
=
2
;
const
int
register_of_first_capture
=
2
;
int
register_count
=
capture_count_
*
registers_per_capture
;
int
register_start
=
register_of_first_capture
+
capture_from_
*
registers_per_capture
;
RegExpNode
*
result
;
bool
was_reading_backward
=
compiler
-
>
read_backward
(
)
;
compiler
-
>
set_read_backward
(
type
(
)
=
=
LOOKBEHIND
)
;
Builder
builder
(
is_positive
(
)
on_success
stack_pointer_register
position_register
register_count
register_start
)
;
RegExpNode
*
match
=
body_
-
>
ToNode
(
compiler
builder
.
on_match_success
(
)
)
;
result
=
builder
.
ForMatch
(
match
)
;
compiler
-
>
set_read_backward
(
was_reading_backward
)
;
return
result
;
}
RegExpNode
*
RegExpCapture
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
return
ToNode
(
body
(
)
index
(
)
compiler
on_success
)
;
}
RegExpNode
*
RegExpCapture
:
:
ToNode
(
RegExpTree
*
body
int
index
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
DCHECK_NOT_NULL
(
body
)
;
int
start_reg
=
RegExpCapture
:
:
StartRegister
(
index
)
;
int
end_reg
=
RegExpCapture
:
:
EndRegister
(
index
)
;
if
(
compiler
-
>
read_backward
(
)
)
std
:
:
swap
(
start_reg
end_reg
)
;
RegExpNode
*
store_end
=
ActionNode
:
:
StorePosition
(
end_reg
true
on_success
)
;
RegExpNode
*
body_node
=
body
-
>
ToNode
(
compiler
store_end
)
;
return
ActionNode
:
:
StorePosition
(
start_reg
true
body_node
)
;
}
namespace
{
class
AssertionSequenceRewriter
final
{
public
:
static
void
MaybeRewrite
(
ZoneList
<
RegExpTree
*
>
*
terms
Zone
*
zone
)
{
AssertionSequenceRewriter
rewriter
(
terms
zone
)
;
static
constexpr
int
kNoIndex
=
-
1
;
int
from
=
kNoIndex
;
for
(
int
i
=
0
;
i
<
terms
-
>
length
(
)
;
i
+
+
)
{
RegExpTree
*
t
=
terms
-
>
at
(
i
)
;
if
(
from
=
=
kNoIndex
&
&
t
-
>
IsAssertion
(
)
)
{
from
=
i
;
}
else
if
(
from
!
=
kNoIndex
&
&
!
t
-
>
IsAssertion
(
)
)
{
if
(
i
-
from
>
1
)
rewriter
.
Rewrite
(
from
i
)
;
from
=
kNoIndex
;
}
}
if
(
from
!
=
kNoIndex
&
&
terms
-
>
length
(
)
-
from
>
1
)
{
rewriter
.
Rewrite
(
from
terms
-
>
length
(
)
)
;
}
}
void
Rewrite
(
int
from
int
to
)
{
DCHECK_GT
(
to
from
+
1
)
;
uint32_t
seen_assertions
=
0
;
STATIC_ASSERT
(
RegExpAssertion
:
:
LAST_TYPE
<
kUInt32Size
*
kBitsPerByte
)
;
JSRegExp
:
:
Flags
flags
=
terms_
-
>
at
(
from
)
-
>
AsAssertion
(
)
-
>
flags
(
)
;
bool
saw_mismatched_flags
=
false
;
for
(
int
i
=
from
;
i
<
to
;
i
+
+
)
{
RegExpAssertion
*
t
=
terms_
-
>
at
(
i
)
-
>
AsAssertion
(
)
;
if
(
t
-
>
flags
(
)
!
=
flags
)
saw_mismatched_flags
=
true
;
const
uint32_t
bit
=
1
<
<
t
-
>
assertion_type
(
)
;
if
(
(
seen_assertions
&
bit
)
&
&
!
saw_mismatched_flags
)
{
terms_
-
>
Set
(
i
new
(
zone_
)
RegExpEmpty
(
)
)
;
}
seen_assertions
|
=
bit
;
}
const
uint32_t
always_fails_mask
=
1
<
<
RegExpAssertion
:
:
BOUNDARY
|
1
<
<
RegExpAssertion
:
:
NON_BOUNDARY
;
if
(
(
seen_assertions
&
always_fails_mask
)
=
=
always_fails_mask
)
{
ReplaceSequenceWithFailure
(
from
to
)
;
}
}
void
ReplaceSequenceWithFailure
(
int
from
int
to
)
{
ZoneList
<
CharacterRange
>
*
ranges
=
new
(
zone_
)
ZoneList
<
CharacterRange
>
(
0
zone_
)
;
RegExpCharacterClass
*
cc
=
new
(
zone_
)
RegExpCharacterClass
(
zone_
ranges
JSRegExp
:
:
Flags
(
)
)
;
terms_
-
>
Set
(
from
cc
)
;
RegExpEmpty
*
empty
=
new
(
zone_
)
RegExpEmpty
(
)
;
for
(
int
i
=
from
+
1
;
i
<
to
;
i
+
+
)
terms_
-
>
Set
(
i
empty
)
;
}
private
:
AssertionSequenceRewriter
(
ZoneList
<
RegExpTree
*
>
*
terms
Zone
*
zone
)
:
zone_
(
zone
)
terms_
(
terms
)
{
}
Zone
*
zone_
;
ZoneList
<
RegExpTree
*
>
*
terms_
;
}
;
}
RegExpNode
*
RegExpAlternative
:
:
ToNode
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
)
{
ZoneList
<
RegExpTree
*
>
*
children
=
nodes
(
)
;
AssertionSequenceRewriter
:
:
MaybeRewrite
(
children
compiler
-
>
zone
(
)
)
;
RegExpNode
*
current
=
on_success
;
if
(
compiler
-
>
read_backward
(
)
)
{
for
(
int
i
=
0
;
i
<
children
-
>
length
(
)
;
i
+
+
)
{
current
=
children
-
>
at
(
i
)
-
>
ToNode
(
compiler
current
)
;
}
}
else
{
for
(
int
i
=
children
-
>
length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
current
=
children
-
>
at
(
i
)
-
>
ToNode
(
compiler
current
)
;
}
}
return
current
;
}
static
void
AddClass
(
const
int
*
elmv
int
elmc
ZoneList
<
CharacterRange
>
*
ranges
Zone
*
zone
)
{
elmc
-
-
;
DCHECK_EQ
(
kRangeEndMarker
elmv
[
elmc
]
)
;
for
(
int
i
=
0
;
i
<
elmc
;
i
+
=
2
)
{
DCHECK
(
elmv
[
i
]
<
elmv
[
i
+
1
]
)
;
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
elmv
[
i
]
elmv
[
i
+
1
]
-
1
)
zone
)
;
}
}
static
void
AddClassNegated
(
const
int
*
elmv
int
elmc
ZoneList
<
CharacterRange
>
*
ranges
Zone
*
zone
)
{
elmc
-
-
;
DCHECK_EQ
(
kRangeEndMarker
elmv
[
elmc
]
)
;
DCHECK_NE
(
0x0000
elmv
[
0
]
)
;
DCHECK_NE
(
String
:
:
kMaxCodePoint
elmv
[
elmc
-
1
]
)
;
uc16
last
=
0x0000
;
for
(
int
i
=
0
;
i
<
elmc
;
i
+
=
2
)
{
DCHECK
(
last
<
=
elmv
[
i
]
-
1
)
;
DCHECK
(
elmv
[
i
]
<
elmv
[
i
+
1
]
)
;
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
last
elmv
[
i
]
-
1
)
zone
)
;
last
=
elmv
[
i
+
1
]
;
}
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
last
String
:
:
kMaxCodePoint
)
zone
)
;
}
void
CharacterRange
:
:
AddClassEscape
(
char
type
ZoneList
<
CharacterRange
>
*
ranges
bool
add_unicode_case_equivalents
Zone
*
zone
)
{
if
(
add_unicode_case_equivalents
&
&
(
type
=
=
'
w
'
|
|
type
=
=
'
W
'
)
)
{
ZoneList
<
CharacterRange
>
*
new_ranges
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
AddClass
(
kWordRanges
kWordRangeCount
new_ranges
zone
)
;
AddUnicodeCaseEquivalents
(
new_ranges
zone
)
;
if
(
type
=
=
'
W
'
)
{
ZoneList
<
CharacterRange
>
*
negated
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
CharacterRange
:
:
Negate
(
new_ranges
negated
zone
)
;
new_ranges
=
negated
;
}
ranges
-
>
AddAll
(
*
new_ranges
zone
)
;
return
;
}
AddClassEscape
(
type
ranges
zone
)
;
}
void
CharacterRange
:
:
AddClassEscape
(
char
type
ZoneList
<
CharacterRange
>
*
ranges
Zone
*
zone
)
{
switch
(
type
)
{
case
'
s
'
:
AddClass
(
kSpaceRanges
kSpaceRangeCount
ranges
zone
)
;
break
;
case
'
S
'
:
AddClassNegated
(
kSpaceRanges
kSpaceRangeCount
ranges
zone
)
;
break
;
case
'
w
'
:
AddClass
(
kWordRanges
kWordRangeCount
ranges
zone
)
;
break
;
case
'
W
'
:
AddClassNegated
(
kWordRanges
kWordRangeCount
ranges
zone
)
;
break
;
case
'
d
'
:
AddClass
(
kDigitRanges
kDigitRangeCount
ranges
zone
)
;
break
;
case
'
D
'
:
AddClassNegated
(
kDigitRanges
kDigitRangeCount
ranges
zone
)
;
break
;
case
'
.
'
:
AddClassNegated
(
kLineTerminatorRanges
kLineTerminatorRangeCount
ranges
zone
)
;
break
;
case
'
*
'
:
ranges
-
>
Add
(
CharacterRange
:
:
Everything
(
)
zone
)
;
break
;
case
'
n
'
:
AddClass
(
kLineTerminatorRanges
kLineTerminatorRangeCount
ranges
zone
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
Vector
<
const
int
>
CharacterRange
:
:
GetWordBounds
(
)
{
return
Vector
<
const
int
>
(
kWordRanges
kWordRangeCount
-
1
)
;
}
void
CharacterRange
:
:
AddCaseEquivalents
(
Isolate
*
isolate
Zone
*
zone
ZoneList
<
CharacterRange
>
*
ranges
bool
is_one_byte
)
{
CharacterRange
:
:
Canonicalize
(
ranges
)
;
int
range_count
=
ranges
-
>
length
(
)
;
#
ifdef
V8_INTL_SUPPORT
icu
:
:
UnicodeSet
others
;
for
(
int
i
=
0
;
i
<
range_count
;
i
+
+
)
{
CharacterRange
range
=
ranges
-
>
at
(
i
)
;
uc32
from
=
range
.
from
(
)
;
if
(
from
>
String
:
:
kMaxUtf16CodeUnit
)
continue
;
uc32
to
=
Min
(
range
.
to
(
)
String
:
:
kMaxUtf16CodeUnit
)
;
if
(
from
>
=
kLeadSurrogateStart
&
&
to
<
=
kTrailSurrogateEnd
)
continue
;
if
(
is_one_byte
&
&
!
RangeContainsLatin1Equivalents
(
range
)
)
{
if
(
from
>
String
:
:
kMaxOneByteCharCode
)
continue
;
if
(
to
>
String
:
:
kMaxOneByteCharCode
)
to
=
String
:
:
kMaxOneByteCharCode
;
}
others
.
add
(
from
to
)
;
}
icu
:
:
UnicodeSet
already_added
(
others
)
;
others
.
removeAll
(
RegExpCaseFolding
:
:
IgnoreSet
(
)
)
;
others
.
closeOver
(
USET_CASE_INSENSITIVE
)
;
others
.
removeAll
(
RegExpCaseFolding
:
:
IgnoreSet
(
)
)
;
others
.
removeAll
(
already_added
)
;
for
(
int32_t
i
=
0
;
i
<
others
.
getRangeCount
(
)
;
i
+
+
)
{
UChar32
from
=
others
.
getRangeStart
(
i
)
;
UChar32
to
=
others
.
getRangeEnd
(
i
)
;
if
(
from
=
=
to
)
{
ranges
-
>
Add
(
CharacterRange
:
:
Singleton
(
from
)
zone
)
;
}
else
{
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
from
to
)
zone
)
;
}
}
#
else
for
(
int
i
=
0
;
i
<
range_count
;
i
+
+
)
{
CharacterRange
range
=
ranges
-
>
at
(
i
)
;
uc32
bottom
=
range
.
from
(
)
;
if
(
bottom
>
String
:
:
kMaxUtf16CodeUnit
)
continue
;
uc32
top
=
Min
(
range
.
to
(
)
String
:
:
kMaxUtf16CodeUnit
)
;
if
(
bottom
>
=
kLeadSurrogateStart
&
&
top
<
=
kTrailSurrogateEnd
)
continue
;
if
(
is_one_byte
&
&
!
RangeContainsLatin1Equivalents
(
range
)
)
{
if
(
bottom
>
String
:
:
kMaxOneByteCharCode
)
continue
;
if
(
top
>
String
:
:
kMaxOneByteCharCode
)
top
=
String
:
:
kMaxOneByteCharCode
;
}
unibrow
:
:
uchar
chars
[
unibrow
:
:
Ecma262UnCanonicalize
:
:
kMaxWidth
]
;
if
(
top
=
=
bottom
)
{
int
length
=
isolate
-
>
jsregexp_uncanonicalize
(
)
-
>
get
(
bottom
'
\
0
'
chars
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
uc32
chr
=
chars
[
i
]
;
if
(
chr
!
=
bottom
)
{
ranges
-
>
Add
(
CharacterRange
:
:
Singleton
(
chars
[
i
]
)
zone
)
;
}
}
}
else
{
unibrow
:
:
uchar
equivalents
[
unibrow
:
:
Ecma262UnCanonicalize
:
:
kMaxWidth
]
;
int
pos
=
bottom
;
while
(
pos
<
=
top
)
{
int
length
=
isolate
-
>
jsregexp_canonrange
(
)
-
>
get
(
pos
'
\
0
'
equivalents
)
;
uc32
block_end
;
if
(
length
=
=
0
)
{
block_end
=
pos
;
}
else
{
DCHECK_EQ
(
1
length
)
;
block_end
=
equivalents
[
0
]
;
}
int
end
=
(
block_end
>
top
)
?
top
:
block_end
;
length
=
isolate
-
>
jsregexp_uncanonicalize
(
)
-
>
get
(
block_end
'
\
0
'
equivalents
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
uc32
c
=
equivalents
[
i
]
;
uc32
range_from
=
c
-
(
block_end
-
pos
)
;
uc32
range_to
=
c
-
(
block_end
-
end
)
;
if
(
!
(
bottom
<
=
range_from
&
&
range_to
<
=
top
)
)
{
ranges
-
>
Add
(
CharacterRange
:
:
Range
(
range_from
range_to
)
zone
)
;
}
}
pos
=
end
+
1
;
}
}
}
#
endif
}
bool
CharacterRange
:
:
IsCanonical
(
ZoneList
<
CharacterRange
>
*
ranges
)
{
DCHECK_NOT_NULL
(
ranges
)
;
int
n
=
ranges
-
>
length
(
)
;
if
(
n
<
=
1
)
return
true
;
int
max
=
ranges
-
>
at
(
0
)
.
to
(
)
;
for
(
int
i
=
1
;
i
<
n
;
i
+
+
)
{
CharacterRange
next_range
=
ranges
-
>
at
(
i
)
;
if
(
next_range
.
from
(
)
<
=
max
+
1
)
return
false
;
max
=
next_range
.
to
(
)
;
}
return
true
;
}
ZoneList
<
CharacterRange
>
*
CharacterSet
:
:
ranges
(
Zone
*
zone
)
{
if
(
ranges_
=
=
nullptr
)
{
ranges_
=
new
(
zone
)
ZoneList
<
CharacterRange
>
(
2
zone
)
;
CharacterRange
:
:
AddClassEscape
(
standard_set_type_
ranges_
false
zone
)
;
}
return
ranges_
;
}
static
void
MoveRanges
(
ZoneList
<
CharacterRange
>
*
list
int
from
int
to
int
count
)
{
if
(
from
<
to
)
{
for
(
int
i
=
count
-
1
;
i
>
=
0
;
i
-
-
)
{
list
-
>
at
(
to
+
i
)
=
list
-
>
at
(
from
+
i
)
;
}
}
else
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
list
-
>
at
(
to
+
i
)
=
list
-
>
at
(
from
+
i
)
;
}
}
}
static
int
InsertRangeInCanonicalList
(
ZoneList
<
CharacterRange
>
*
list
int
count
CharacterRange
insert
)
{
uc32
from
=
insert
.
from
(
)
;
uc32
to
=
insert
.
to
(
)
;
int
start_pos
=
0
;
int
end_pos
=
count
;
for
(
int
i
=
count
-
1
;
i
>
=
0
;
i
-
-
)
{
CharacterRange
current
=
list
-
>
at
(
i
)
;
if
(
current
.
from
(
)
>
to
+
1
)
{
end_pos
=
i
;
}
else
if
(
current
.
to
(
)
+
1
<
from
)
{
start_pos
=
i
+
1
;
break
;
}
}
if
(
start_pos
=
=
end_pos
)
{
if
(
start_pos
<
count
)
{
MoveRanges
(
list
start_pos
start_pos
+
1
count
-
start_pos
)
;
}
list
-
>
at
(
start_pos
)
=
insert
;
return
count
+
1
;
}
if
(
start_pos
+
1
=
=
end_pos
)
{
CharacterRange
to_replace
=
list
-
>
at
(
start_pos
)
;
int
new_from
=
Min
(
to_replace
.
from
(
)
from
)
;
int
new_to
=
Max
(
to_replace
.
to
(
)
to
)
;
list
-
>
at
(
start_pos
)
=
CharacterRange
:
:
Range
(
new_from
new_to
)
;
return
count
;
}
int
new_from
=
Min
(
list
-
>
at
(
start_pos
)
.
from
(
)
from
)
;
int
new_to
=
Max
(
list
-
>
at
(
end_pos
-
1
)
.
to
(
)
to
)
;
if
(
end_pos
<
count
)
{
MoveRanges
(
list
end_pos
start_pos
+
1
count
-
end_pos
)
;
}
list
-
>
at
(
start_pos
)
=
CharacterRange
:
:
Range
(
new_from
new_to
)
;
return
count
-
(
end_pos
-
start_pos
)
+
1
;
}
void
CharacterSet
:
:
Canonicalize
(
)
{
if
(
ranges_
=
=
nullptr
)
return
;
CharacterRange
:
:
Canonicalize
(
ranges_
)
;
}
void
CharacterRange
:
:
Canonicalize
(
ZoneList
<
CharacterRange
>
*
character_ranges
)
{
if
(
character_ranges
-
>
length
(
)
<
=
1
)
return
;
int
n
=
character_ranges
-
>
length
(
)
;
int
max
=
character_ranges
-
>
at
(
0
)
.
to
(
)
;
int
i
=
1
;
while
(
i
<
n
)
{
CharacterRange
current
=
character_ranges
-
>
at
(
i
)
;
if
(
current
.
from
(
)
<
=
max
+
1
)
{
break
;
}
max
=
current
.
to
(
)
;
i
+
+
;
}
if
(
i
=
=
n
)
return
;
int
read
=
i
;
int
num_canonical
=
i
;
do
{
num_canonical
=
InsertRangeInCanonicalList
(
character_ranges
num_canonical
character_ranges
-
>
at
(
read
)
)
;
read
+
+
;
}
while
(
read
<
n
)
;
character_ranges
-
>
Rewind
(
num_canonical
)
;
DCHECK
(
CharacterRange
:
:
IsCanonical
(
character_ranges
)
)
;
}
void
CharacterRange
:
:
Negate
(
ZoneList
<
CharacterRange
>
*
ranges
ZoneList
<
CharacterRange
>
*
negated_ranges
Zone
*
zone
)
{
DCHECK
(
CharacterRange
:
:
IsCanonical
(
ranges
)
)
;
DCHECK_EQ
(
0
negated_ranges
-
>
length
(
)
)
;
int
range_count
=
ranges
-
>
length
(
)
;
uc32
from
=
0
;
int
i
=
0
;
if
(
range_count
>
0
&
&
ranges
-
>
at
(
0
)
.
from
(
)
=
=
0
)
{
from
=
ranges
-
>
at
(
0
)
.
to
(
)
+
1
;
i
=
1
;
}
while
(
i
<
range_count
)
{
CharacterRange
range
=
ranges
-
>
at
(
i
)
;
negated_ranges
-
>
Add
(
CharacterRange
:
:
Range
(
from
range
.
from
(
)
-
1
)
zone
)
;
from
=
range
.
to
(
)
+
1
;
i
+
+
;
}
if
(
from
<
String
:
:
kMaxCodePoint
)
{
negated_ranges
-
>
Add
(
CharacterRange
:
:
Range
(
from
String
:
:
kMaxCodePoint
)
zone
)
;
}
}
class
RegExpExpansionLimiter
{
public
:
static
const
int
kMaxExpansionFactor
=
6
;
RegExpExpansionLimiter
(
RegExpCompiler
*
compiler
int
factor
)
:
compiler_
(
compiler
)
saved_expansion_factor_
(
compiler
-
>
current_expansion_factor
(
)
)
ok_to_expand_
(
saved_expansion_factor_
<
=
kMaxExpansionFactor
)
{
DCHECK_LT
(
0
factor
)
;
if
(
ok_to_expand_
)
{
if
(
factor
>
kMaxExpansionFactor
)
{
ok_to_expand_
=
false
;
compiler
-
>
set_current_expansion_factor
(
kMaxExpansionFactor
+
1
)
;
}
else
{
int
new_factor
=
saved_expansion_factor_
*
factor
;
ok_to_expand_
=
(
new_factor
<
=
kMaxExpansionFactor
)
;
compiler
-
>
set_current_expansion_factor
(
new_factor
)
;
}
}
}
~
RegExpExpansionLimiter
(
)
{
compiler_
-
>
set_current_expansion_factor
(
saved_expansion_factor_
)
;
}
bool
ok_to_expand
(
)
{
return
ok_to_expand_
;
}
private
:
RegExpCompiler
*
compiler_
;
int
saved_expansion_factor_
;
bool
ok_to_expand_
;
DISALLOW_IMPLICIT_CONSTRUCTORS
(
RegExpExpansionLimiter
)
;
}
;
RegExpNode
*
RegExpQuantifier
:
:
ToNode
(
int
min
int
max
bool
is_greedy
RegExpTree
*
body
RegExpCompiler
*
compiler
RegExpNode
*
on_success
bool
not_at_start
)
{
static
const
int
kMaxUnrolledMinMatches
=
3
;
static
const
int
kMaxUnrolledMaxMatches
=
3
;
if
(
max
=
=
0
)
return
on_success
;
bool
body_can_be_empty
=
(
body
-
>
min_match
(
)
=
=
0
)
;
int
body_start_reg
=
RegExpCompiler
:
:
kNoRegister
;
Interval
capture_registers
=
body
-
>
CaptureRegisters
(
)
;
bool
needs_capture_clearing
=
!
capture_registers
.
is_empty
(
)
;
Zone
*
zone
=
compiler
-
>
zone
(
)
;
if
(
body_can_be_empty
)
{
body_start_reg
=
compiler
-
>
AllocateRegister
(
)
;
}
else
if
(
compiler
-
>
optimize
(
)
&
&
!
needs_capture_clearing
)
{
{
RegExpExpansionLimiter
limiter
(
compiler
min
+
(
(
max
!
=
min
)
?
1
:
0
)
)
;
if
(
min
>
0
&
&
min
<
=
kMaxUnrolledMinMatches
&
&
limiter
.
ok_to_expand
(
)
)
{
int
new_max
=
(
max
=
=
kInfinity
)
?
max
:
max
-
min
;
RegExpNode
*
answer
=
ToNode
(
0
new_max
is_greedy
body
compiler
on_success
true
)
;
for
(
int
i
=
0
;
i
<
min
;
i
+
+
)
{
answer
=
body
-
>
ToNode
(
compiler
answer
)
;
}
return
answer
;
}
}
if
(
max
<
=
kMaxUnrolledMaxMatches
&
&
min
=
=
0
)
{
DCHECK_LT
(
0
max
)
;
RegExpExpansionLimiter
limiter
(
compiler
max
)
;
if
(
limiter
.
ok_to_expand
(
)
)
{
RegExpNode
*
answer
=
on_success
;
for
(
int
i
=
0
;
i
<
max
;
i
+
+
)
{
ChoiceNode
*
alternation
=
new
(
zone
)
ChoiceNode
(
2
zone
)
;
if
(
is_greedy
)
{
alternation
-
>
AddAlternative
(
GuardedAlternative
(
body
-
>
ToNode
(
compiler
answer
)
)
)
;
alternation
-
>
AddAlternative
(
GuardedAlternative
(
on_success
)
)
;
}
else
{
alternation
-
>
AddAlternative
(
GuardedAlternative
(
on_success
)
)
;
alternation
-
>
AddAlternative
(
GuardedAlternative
(
body
-
>
ToNode
(
compiler
answer
)
)
)
;
}
answer
=
alternation
;
if
(
not_at_start
&
&
!
compiler
-
>
read_backward
(
)
)
{
alternation
-
>
set_not_at_start
(
)
;
}
}
return
answer
;
}
}
}
bool
has_min
=
min
>
0
;
bool
has_max
=
max
<
RegExpTree
:
:
kInfinity
;
bool
needs_counter
=
has_min
|
|
has_max
;
int
reg_ctr
=
needs_counter
?
compiler
-
>
AllocateRegister
(
)
:
RegExpCompiler
:
:
kNoRegister
;
LoopChoiceNode
*
center
=
new
(
zone
)
LoopChoiceNode
(
body
-
>
min_match
(
)
=
=
0
compiler
-
>
read_backward
(
)
min
zone
)
;
if
(
not_at_start
&
&
!
compiler
-
>
read_backward
(
)
)
center
-
>
set_not_at_start
(
)
;
RegExpNode
*
loop_return
=
needs_counter
?
static_cast
<
RegExpNode
*
>
(
ActionNode
:
:
IncrementRegister
(
reg_ctr
center
)
)
:
static_cast
<
RegExpNode
*
>
(
center
)
;
if
(
body_can_be_empty
)
{
loop_return
=
ActionNode
:
:
EmptyMatchCheck
(
body_start_reg
reg_ctr
min
loop_return
)
;
}
RegExpNode
*
body_node
=
body
-
>
ToNode
(
compiler
loop_return
)
;
if
(
body_can_be_empty
)
{
body_node
=
ActionNode
:
:
StorePosition
(
body_start_reg
false
body_node
)
;
}
if
(
needs_capture_clearing
)
{
body_node
=
ActionNode
:
:
ClearCaptures
(
capture_registers
body_node
)
;
}
GuardedAlternative
body_alt
(
body_node
)
;
if
(
has_max
)
{
Guard
*
body_guard
=
new
(
zone
)
Guard
(
reg_ctr
Guard
:
:
LT
max
)
;
body_alt
.
AddGuard
(
body_guard
zone
)
;
}
GuardedAlternative
rest_alt
(
on_success
)
;
if
(
has_min
)
{
Guard
*
rest_guard
=
new
(
compiler
-
>
zone
(
)
)
Guard
(
reg_ctr
Guard
:
:
GEQ
min
)
;
rest_alt
.
AddGuard
(
rest_guard
zone
)
;
}
if
(
is_greedy
)
{
center
-
>
AddLoopAlternative
(
body_alt
)
;
center
-
>
AddContinueAlternative
(
rest_alt
)
;
}
else
{
center
-
>
AddContinueAlternative
(
rest_alt
)
;
center
-
>
AddLoopAlternative
(
body_alt
)
;
}
if
(
needs_counter
)
{
return
ActionNode
:
:
SetRegisterForLoop
(
reg_ctr
0
center
)
;
}
else
{
return
center
;
}
}
}
}
