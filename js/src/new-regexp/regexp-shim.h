#
ifndef
RegexpShim_h
#
define
RegexpShim_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
algorithm
>
#
include
"
js
/
Value
.
h
"
#
include
"
new
-
regexp
/
util
/
vector
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
v8
{
namespace
internal
{
class
Isolate
;
}
}
#
define
V8_WARN_UNUSED_RESULT
MOZ_MUST_USE
#
define
V8_EXPORT_PRIVATE
MOZ_EXPORT
#
define
V8_FALLTHROUGH
MOZ_FALLTHROUGH
#
define
FATAL
(
x
)
MOZ_CRASH
(
x
)
#
define
UNREACHABLE
(
)
MOZ_CRASH
(
"
unreachable
code
"
)
#
define
UNIMPLEMENTED
(
)
MOZ_CRASH
(
"
unimplemented
code
"
)
#
define
STATIC_ASSERT
(
exp
)
static_assert
(
exp
#
exp
)
#
define
DCHECK
MOZ_ASSERT
#
define
DCHECK_EQ
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
=
=
(
rhs
)
)
#
define
DCHECK_NE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
!
=
(
rhs
)
)
#
define
DCHECK_GT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
(
rhs
)
)
#
define
DCHECK_GE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
=
(
rhs
)
)
#
define
DCHECK_LT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
(
rhs
)
)
#
define
DCHECK_LE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
=
(
rhs
)
)
#
define
DCHECK_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
=
=
nullptr
)
#
define
DCHECK_NOT_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
!
=
nullptr
)
#
define
DCHECK_IMPLIES
(
lhs
rhs
)
MOZ_ASSERT_IF
(
lhs
rhs
)
#
define
CHECK
MOZ_RELEASE_ASSERT
template
<
class
T
>
static
constexpr
inline
T
Min
(
T
t1
T
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
class
T
>
static
constexpr
inline
T
Max
(
T
t1
T
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
#
define
MemCopy
memcpy
#
ifdef
_MSC_VER
#
define
V8PRIxPTRDIFF
"
Ix
"
#
define
V8PRIdPTRDIFF
"
Id
"
#
define
V8PRIuPTRDIFF
"
Iu
"
#
else
#
define
V8PRIxPTRDIFF
"
tx
"
#
define
V8PRIdPTRDIFF
"
td
"
#
define
V8PRIuPTRDIFF
"
tu
"
#
endif
#
define
arraysize
(
array
)
(
sizeof
(
ArraySizeHelper
(
array
)
)
)
template
<
typename
T
size_t
N
>
char
(
&
ArraySizeHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
#
define
DISALLOW_ASSIGN
(
TypeName
)
TypeName
&
operator
=
(
const
TypeName
&
)
=
delete
#
define
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
=
delete
;
\
DISALLOW_ASSIGN
(
TypeName
)
#
define
DISALLOW_IMPLICIT_CONSTRUCTORS
(
TypeName
)
\
TypeName
(
)
=
delete
;
\
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
namespace
v8
{
template
<
typename
T
typename
U
>
constexpr
inline
bool
IsAligned
(
T
value
U
alignment
)
{
return
(
value
&
(
alignment
-
1
)
)
=
=
0
;
}
using
byte
=
uint8_t
;
using
Address
=
uintptr_t
;
static
const
Address
kNullAddress
=
0
;
namespace
base
{
struct
Use
{
template
<
typename
T
>
Use
(
T
&
&
)
{
}
}
;
#
define
USE
(
.
.
.
)
\
do
{
\
:
:
v8
:
:
base
:
:
Use
unused_tmp_array_for_use_macro
[
]
{
__VA_ARGS__
}
;
\
(
void
)
unused_tmp_array_for_use_macro
;
\
}
while
(
false
)
template
<
typename
Dst
typename
Src
>
inline
Dst
saturated_cast
(
Src
value
)
;
template
<
>
inline
uint8_t
saturated_cast
<
uint8_t
int
>
(
int
x
)
{
return
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
}
namespace
bits
{
inline
uint64_t
CountTrailingZeros
(
uint64_t
value
)
{
return
mozilla
:
:
CountTrailingZeroes64
(
value
)
;
}
}
}
namespace
internal
{
#
define
PRINTF_FORMAT
(
x
y
)
MOZ_FORMAT_PRINTF
(
x
y
)
void
PRINTF_FORMAT
(
1
2
)
PrintF
(
const
char
*
format
.
.
.
)
;
void
PRINTF_FORMAT
(
2
3
)
PrintF
(
FILE
*
out
const
char
*
format
.
.
.
)
;
class
AllStatic
{
#
ifdef
DEBUG
public
:
AllStatic
(
)
=
delete
;
#
endif
}
;
constexpr
int32_t
KB
=
1024
;
constexpr
int32_t
MB
=
1024
*
1024
;
#
define
kMaxInt
JSVAL_INT_MAX
#
define
kMinInt
JSVAL_INT_MIN
constexpr
int
kSystemPointerSize
=
sizeof
(
void
*
)
;
constexpr
double
kMaxSafeInteger
=
9007199254740991
.
0
;
using
uc16
=
uint16_t
;
using
uc32
=
int32_t
;
constexpr
int
kBitsPerByte
=
8
;
constexpr
int
kBitsPerByteLog2
=
3
;
constexpr
int
kUInt32Size
=
sizeof
(
uint32_t
)
;
constexpr
int
kInt64Size
=
sizeof
(
int64_t
)
;
constexpr
int
kUC16Size
=
sizeof
(
uc16
)
;
inline
constexpr
bool
IsDecimalDigit
(
uc32
c
)
{
return
c
>
=
'
0
'
&
&
c
<
=
'
9
'
;
}
inline
bool
is_uint24
(
int
val
)
{
return
(
val
&
0x00ffffff
)
=
=
val
;
}
inline
bool
IsIdentifierStart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierStart
(
uint32_t
(
c
)
)
;
}
inline
bool
IsIdentifierPart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierPart
(
uint32_t
(
c
)
)
;
}
struct
AsUC16
{
explicit
AsUC16
(
uint16_t
v
)
:
value
(
v
)
{
}
uint16_t
value
;
}
;
struct
AsUC32
{
explicit
AsUC32
(
int32_t
v
)
:
value
(
v
)
{
}
int32_t
value
;
}
;
class
StdoutStream
:
public
std
:
:
ostream
{
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC16
&
c
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC32
&
c
)
;
using
mozilla
:
:
Maybe
;
template
<
typename
T
>
Maybe
<
T
>
Just
(
const
T
&
value
)
{
return
mozilla
:
:
Some
(
value
)
;
}
template
<
typename
T
>
mozilla
:
:
Nothing
Nothing
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
template
<
typename
lchar
typename
rchar
>
inline
int
CompareCharsUnsigned
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
const
lchar
*
limit
=
lhs
+
chars
;
if
(
sizeof
(
*
lhs
)
=
=
sizeof
(
char
)
&
&
sizeof
(
*
rhs
)
=
=
sizeof
(
char
)
)
{
return
memcmp
(
lhs
rhs
chars
)
;
}
while
(
lhs
<
limit
)
{
int
r
=
static_cast
<
int
>
(
*
lhs
)
-
static_cast
<
int
>
(
*
rhs
)
;
if
(
r
!
=
0
)
return
r
;
+
+
lhs
;
+
+
rhs
;
}
return
0
;
}
template
<
typename
lchar
typename
rchar
>
inline
int
CompareChars
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
DCHECK_LE
(
sizeof
(
lchar
)
2
)
;
DCHECK_LE
(
sizeof
(
rchar
)
2
)
;
if
(
sizeof
(
lchar
)
=
=
1
)
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint16_t
*
>
(
rhs
)
chars
)
;
}
}
else
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint16_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint16_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint16_t
*
>
(
rhs
)
chars
)
;
}
}
}
inline
int
HexValue
(
uc32
c
)
{
c
-
=
'
0
'
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
9
)
return
c
;
c
=
(
c
|
0x20
)
-
(
'
a
'
-
'
0
'
)
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
5
)
return
c
+
10
;
return
-
1
;
}
class
Object
{
public
:
constexpr
Object
(
)
:
value_
(
JS
:
:
Int32Value
(
0
)
)
{
}
constexpr
Object
(
JS
:
:
Value
value
)
:
value_
(
value
)
{
}
operator
JS
:
:
Value
(
)
const
{
return
value_
;
}
inline
bool
IsException
(
Isolate
*
)
const
{
return
!
value_
.
toBoolean
(
)
;
}
Object
(
Address
bits
)
;
Address
ptr
(
)
const
;
protected
:
JS
:
:
Value
value_
;
}
;
class
Smi
:
public
Object
{
public
:
static
Smi
FromInt
(
int32_t
value
)
{
Smi
smi
;
smi
.
value_
=
JS
:
:
Int32Value
(
value
)
;
return
smi
;
}
static
inline
int32_t
ToInt
(
const
Object
object
)
{
return
JS
:
:
Value
(
object
)
.
toInt32
(
)
;
}
}
;
class
HeapObject
:
public
Object
{
public
:
int
Size
(
)
const
;
}
;
class
FixedArray
:
public
HeapObject
{
public
:
inline
void
set
(
uint32_t
index
Object
value
)
{
JS
:
:
Value
(
*
this
)
.
toObject
(
)
.
as
<
js
:
:
NativeObject
>
(
)
.
setDenseElement
(
index
value
)
;
}
}
;
class
ByteArray
:
public
HeapObject
{
public
:
uint8_t
get
(
uint32_t
index
)
;
void
set
(
uint32_t
index
uint8_t
val
)
;
uint32_t
length
(
)
;
byte
*
GetDataStartAddress
(
)
;
byte
*
GetDataEndAddress
(
)
;
static
ByteArray
cast
(
Object
object
)
;
}
;
class
DisallowHeapAllocation
{
public
:
DisallowHeapAllocation
(
)
{
}
operator
const
JS
:
:
AutoAssertNoGC
&
(
)
const
{
return
no_gc_
;
}
private
:
const
JS
:
:
AutoAssertNoGC
no_gc_
;
}
;
class
AllowHeapAllocation
{
public
:
AllowHeapAllocation
(
)
{
}
}
;
class
DisallowJavascriptExecution
{
public
:
DisallowJavascriptExecution
(
Isolate
*
isolate
)
;
private
:
js
:
:
AutoAssertNoContentJS
nojs_
;
}
;
}
}
#
endif
