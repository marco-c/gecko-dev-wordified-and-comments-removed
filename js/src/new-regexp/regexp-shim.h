#
ifndef
RegexpShim_h
#
define
RegexpShim_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
algorithm
>
#
define
V8_WARN_UNUSED_RESULT
MOZ_MUST_USE
#
define
V8_EXPORT_PRIVATE
MOZ_EXPORT
#
define
V8_FALLTHROUGH
MOZ_FALLTHROUGH
#
define
FATAL
(
x
)
MOZ_CRASH
(
x
)
#
define
UNREACHABLE
(
)
MOZ_CRASH
(
"
unreachable
code
"
)
#
define
UNIMPLEMENTED
(
)
MOZ_CRASH
(
"
unimplemented
code
"
)
#
define
STATIC_ASSERT
(
exp
)
static_assert
(
exp
#
exp
)
#
define
DCHECK
MOZ_ASSERT
#
define
DCHECK_EQ
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
=
=
(
rhs
)
)
#
define
DCHECK_NE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
!
=
(
rhs
)
)
#
define
DCHECK_GT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
(
rhs
)
)
#
define
DCHECK_GE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
=
(
rhs
)
)
#
define
DCHECK_LT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
(
rhs
)
)
#
define
DCHECK_LE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
=
(
rhs
)
)
#
define
DCHECK_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
=
=
nullptr
)
#
define
DCHECK_NOT_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
!
=
nullptr
)
#
define
DCHECK_IMPLIES
(
lhs
rhs
)
MOZ_ASSERT_IF
(
lhs
rhs
)
#
define
CHECK
MOZ_RELEASE_ASSERT
template
<
class
T
>
static
constexpr
inline
T
Min
(
T
t1
T
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
class
T
>
static
constexpr
inline
T
Max
(
T
t1
T
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
#
define
MemCopy
memcpy
#
ifdef
_MSC_VER
#
define
V8PRIxPTRDIFF
"
Ix
"
#
define
V8PRIdPTRDIFF
"
Id
"
#
define
V8PRIuPTRDIFF
"
Iu
"
#
else
#
define
V8PRIxPTRDIFF
"
tx
"
#
define
V8PRIdPTRDIFF
"
td
"
#
define
V8PRIuPTRDIFF
"
tu
"
#
endif
#
define
arraysize
(
array
)
(
sizeof
(
ArraySizeHelper
(
array
)
)
)
template
<
typename
T
size_t
N
>
char
(
&
ArraySizeHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
#
define
DISALLOW_ASSIGN
(
TypeName
)
TypeName
&
operator
=
(
const
TypeName
&
)
=
delete
#
define
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
=
delete
;
\
DISALLOW_ASSIGN
(
TypeName
)
#
define
DISALLOW_IMPLICIT_CONSTRUCTORS
(
TypeName
)
\
TypeName
(
)
=
delete
;
\
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
namespace
v8
{
template
<
typename
T
typename
U
>
constexpr
inline
bool
IsAligned
(
T
value
U
alignment
)
{
return
(
value
&
(
alignment
-
1
)
)
=
=
0
;
}
namespace
base
{
struct
Use
{
template
<
typename
T
>
Use
(
T
&
&
)
{
}
}
;
#
define
USE
(
.
.
.
)
\
do
{
\
:
:
v8
:
:
base
:
:
Use
unused_tmp_array_for_use_macro
[
]
{
__VA_ARGS__
}
;
\
(
void
)
unused_tmp_array_for_use_macro
;
\
}
while
(
false
)
template
<
typename
Dst
typename
Src
>
inline
Dst
saturated_cast
(
Src
value
)
;
template
<
>
inline
uint8_t
saturated_cast
<
uint8_t
int
>
(
int
x
)
{
return
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
}
}
}
#
endif
