#
ifndef
RegexpShim_h
#
define
RegexpShim_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
algorithm
>
#
include
"
jit
/
Label
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
new
-
regexp
/
util
/
flags
.
h
"
#
include
"
new
-
regexp
/
util
/
vector
.
h
"
#
include
"
new
-
regexp
/
util
/
zone
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
v8
{
namespace
internal
{
class
Heap
;
class
Isolate
;
class
RegExpMatchInfo
;
class
RegExpStack
;
}
}
#
define
V8_WARN_UNUSED_RESULT
MOZ_MUST_USE
#
define
V8_EXPORT_PRIVATE
MOZ_EXPORT
#
define
V8_FALLTHROUGH
[
[
fallthrough
]
]
#
define
FATAL
(
x
)
MOZ_CRASH
(
x
)
#
define
UNREACHABLE
(
)
MOZ_CRASH
(
"
unreachable
code
"
)
#
define
UNIMPLEMENTED
(
)
MOZ_CRASH
(
"
unimplemented
code
"
)
#
define
STATIC_ASSERT
(
exp
)
static_assert
(
exp
#
exp
)
#
define
DCHECK
MOZ_ASSERT
#
define
DCHECK_EQ
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
=
=
(
rhs
)
)
#
define
DCHECK_NE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
!
=
(
rhs
)
)
#
define
DCHECK_GT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
(
rhs
)
)
#
define
DCHECK_GE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
=
(
rhs
)
)
#
define
DCHECK_LT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
(
rhs
)
)
#
define
DCHECK_LE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
=
(
rhs
)
)
#
define
DCHECK_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
=
=
nullptr
)
#
define
DCHECK_NOT_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
!
=
nullptr
)
#
define
DCHECK_IMPLIES
(
lhs
rhs
)
MOZ_ASSERT_IF
(
lhs
rhs
)
#
define
CHECK
MOZ_RELEASE_ASSERT
template
<
class
T
>
static
constexpr
inline
T
Min
(
T
t1
T
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
class
T
>
static
constexpr
inline
T
Max
(
T
t1
T
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
#
define
MemCopy
memcpy
#
ifdef
_MSC_VER
#
define
V8PRIxPTRDIFF
"
Ix
"
#
define
V8PRIdPTRDIFF
"
Id
"
#
define
V8PRIuPTRDIFF
"
Iu
"
#
else
#
define
V8PRIxPTRDIFF
"
tx
"
#
define
V8PRIdPTRDIFF
"
td
"
#
define
V8PRIuPTRDIFF
"
tu
"
#
endif
#
define
arraysize
(
array
)
(
sizeof
(
ArraySizeHelper
(
array
)
)
)
template
<
typename
T
size_t
N
>
char
(
&
ArraySizeHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
#
define
DISALLOW_ASSIGN
(
TypeName
)
TypeName
&
operator
=
(
const
TypeName
&
)
=
delete
#
define
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
=
delete
;
\
DISALLOW_ASSIGN
(
TypeName
)
#
define
DISALLOW_IMPLICIT_CONSTRUCTORS
(
TypeName
)
\
TypeName
(
)
=
delete
;
\
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
namespace
v8
{
template
<
typename
T
typename
U
>
constexpr
inline
bool
IsAligned
(
T
value
U
alignment
)
{
return
(
value
&
(
alignment
-
1
)
)
=
=
0
;
}
using
byte
=
uint8_t
;
using
Address
=
uintptr_t
;
static
const
Address
kNullAddress
=
0
;
using
uc16
=
char16_t
;
using
uc32
=
int32_t
;
namespace
base
{
struct
Use
{
template
<
typename
T
>
Use
(
T
&
&
)
{
}
}
;
#
define
USE
(
.
.
.
)
\
do
{
\
:
:
v8
:
:
base
:
:
Use
unused_tmp_array_for_use_macro
[
]
{
__VA_ARGS__
}
;
\
(
void
)
unused_tmp_array_for_use_macro
;
\
}
while
(
false
)
template
<
typename
Dst
typename
Src
>
inline
Dst
saturated_cast
(
Src
value
)
;
template
<
>
inline
uint8_t
saturated_cast
<
uint8_t
int
>
(
int
x
)
{
return
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
}
namespace
bits
{
inline
uint64_t
CountTrailingZeros
(
uint64_t
value
)
{
return
mozilla
:
:
CountTrailingZeroes64
(
value
)
;
}
}
}
namespace
unibrow
{
using
uchar
=
unsigned
int
;
class
Latin1
{
public
:
static
const
uc16
kMaxChar
=
0xff
;
static
inline
uc16
TryConvertToLatin1
(
uc16
c
)
{
if
(
c
=
=
0x039C
|
|
c
=
=
0x03BC
)
{
return
0xB5
;
}
if
(
c
=
=
0x0178
)
{
return
0xFF
;
}
return
c
;
}
}
;
class
Utf16
{
public
:
static
inline
bool
IsLeadSurrogate
(
int
code
)
{
return
js
:
:
unicode
:
:
IsLeadSurrogate
(
code
)
;
}
static
inline
bool
IsTrailSurrogate
(
int
code
)
{
return
js
:
:
unicode
:
:
IsTrailSurrogate
(
code
)
;
}
static
inline
uc16
LeadSurrogate
(
uint32_t
char_code
)
{
return
js
:
:
unicode
:
:
LeadSurrogate
(
char_code
)
;
}
static
inline
uc16
TrailSurrogate
(
uint32_t
char_code
)
{
return
js
:
:
unicode
:
:
TrailSurrogate
(
char_code
)
;
}
static
inline
uint32_t
CombineSurrogatePair
(
char16_t
lead
char16_t
trail
)
{
return
js
:
:
unicode
:
:
UTF16Decode
(
lead
trail
)
;
}
static
const
uchar
kMaxNonSurrogateCharCode
=
0xffff
;
}
;
template
<
class
T
int
size
=
256
>
class
Mapping
{
public
:
inline
Mapping
(
)
=
default
;
int
get
(
uchar
c
uchar
n
uchar
*
result
)
;
private
:
friend
class
Test
;
int
CalculateValue
(
uchar
c
uchar
n
uchar
*
result
)
;
struct
CacheEntry
{
inline
CacheEntry
(
)
:
code_point_
(
kNoChar
)
offset_
(
0
)
{
}
inline
CacheEntry
(
uchar
code_point
signed
offset
)
:
code_point_
(
code_point
)
offset_
(
offset
)
{
}
uchar
code_point_
;
signed
offset_
;
static
const
int
kNoChar
=
(
1
<
<
21
)
-
1
;
}
;
static
const
int
kSize
=
size
;
static
const
int
kMask
=
kSize
-
1
;
CacheEntry
entries_
[
kSize
]
;
}
;
struct
Ecma262Canonicalize
{
static
const
int
kMaxWidth
=
1
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
struct
Ecma262UnCanonicalize
{
static
const
int
kMaxWidth
=
1
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
struct
CanonicalizationRange
{
static
const
int
kMaxWidth
=
1
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
}
namespace
internal
{
#
define
PRINTF_FORMAT
(
x
y
)
MOZ_FORMAT_PRINTF
(
x
y
)
void
PRINTF_FORMAT
(
1
2
)
PrintF
(
const
char
*
format
.
.
.
)
;
void
PRINTF_FORMAT
(
2
3
)
PrintF
(
FILE
*
out
const
char
*
format
.
.
.
)
;
class
AllStatic
{
#
ifdef
DEBUG
public
:
AllStatic
(
)
=
delete
;
#
endif
}
;
class
Malloced
{
public
:
static
void
*
operator
new
(
size_t
size
)
{
js
:
:
AutoEnterOOMUnsafeRegion
oomUnsafe
;
void
*
result
=
js_malloc
(
size
)
;
if
(
!
result
)
{
oomUnsafe
.
crash
(
"
Irregexp
Malloced
shim
"
)
;
}
return
result
;
}
static
void
operator
delete
(
void
*
p
)
{
js_free
(
p
)
;
}
}
;
constexpr
int32_t
KB
=
1024
;
constexpr
int32_t
MB
=
1024
*
1024
;
#
define
kMaxInt
JSVAL_INT_MAX
#
define
kMinInt
JSVAL_INT_MIN
constexpr
int
kSystemPointerSize
=
sizeof
(
void
*
)
;
constexpr
double
kMaxSafeInteger
=
9007199254740991
.
0
;
constexpr
int
kBitsPerByte
=
8
;
constexpr
int
kBitsPerByteLog2
=
3
;
constexpr
int
kUInt32Size
=
sizeof
(
uint32_t
)
;
constexpr
int
kInt64Size
=
sizeof
(
int64_t
)
;
constexpr
int
kUC16Size
=
sizeof
(
uc16
)
;
inline
constexpr
bool
IsDecimalDigit
(
uc32
c
)
{
return
c
>
=
'
0
'
&
&
c
<
=
'
9
'
;
}
inline
bool
is_uint24
(
int
val
)
{
return
(
val
&
0x00ffffff
)
=
=
val
;
}
inline
bool
IsIdentifierStart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierStart
(
uint32_t
(
c
)
)
;
}
inline
bool
IsIdentifierPart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierPart
(
uint32_t
(
c
)
)
;
}
struct
AsUC16
{
explicit
AsUC16
(
char16_t
v
)
:
value
(
v
)
{
}
char16_t
value
;
}
;
struct
AsUC32
{
explicit
AsUC32
(
int32_t
v
)
:
value
(
v
)
{
}
int32_t
value
;
}
;
class
StdoutStream
:
public
std
:
:
ostream
{
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC16
&
c
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC32
&
c
)
;
using
mozilla
:
:
Maybe
;
template
<
typename
T
>
Maybe
<
T
>
Just
(
const
T
&
value
)
{
return
mozilla
:
:
Some
(
value
)
;
}
template
<
typename
T
>
mozilla
:
:
Nothing
Nothing
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
template
<
typename
lchar
typename
rchar
>
inline
int
CompareCharsUnsigned
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
const
lchar
*
limit
=
lhs
+
chars
;
if
(
sizeof
(
*
lhs
)
=
=
sizeof
(
char
)
&
&
sizeof
(
*
rhs
)
=
=
sizeof
(
char
)
)
{
return
memcmp
(
lhs
rhs
chars
)
;
}
while
(
lhs
<
limit
)
{
int
r
=
static_cast
<
int
>
(
*
lhs
)
-
static_cast
<
int
>
(
*
rhs
)
;
if
(
r
!
=
0
)
return
r
;
+
+
lhs
;
+
+
rhs
;
}
return
0
;
}
template
<
typename
lchar
typename
rchar
>
inline
int
CompareChars
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
DCHECK_LE
(
sizeof
(
lchar
)
2
)
;
DCHECK_LE
(
sizeof
(
rchar
)
2
)
;
if
(
sizeof
(
lchar
)
=
=
1
)
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
char16_t
*
>
(
rhs
)
chars
)
;
}
}
else
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
char16_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
char16_t
*
>
(
lhs
)
reinterpret_cast
<
const
char16_t
*
>
(
rhs
)
chars
)
;
}
}
}
inline
int
HexValue
(
uc32
c
)
{
c
-
=
'
0
'
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
9
)
return
c
;
c
=
(
c
|
0x20
)
-
(
'
a
'
-
'
0
'
)
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
5
)
return
c
+
10
;
return
-
1
;
}
class
Object
{
public
:
constexpr
Object
(
)
:
value_
(
JS
:
:
Int32Value
(
0
)
)
{
}
constexpr
Object
(
JS
:
:
Value
value
)
:
value_
(
value
)
{
}
operator
JS
:
:
Value
(
)
const
{
return
value_
;
}
inline
bool
IsException
(
Isolate
*
)
const
{
return
!
value_
.
toBoolean
(
)
;
}
protected
:
JS
:
:
Value
value_
;
}
;
class
Smi
:
public
Object
{
public
:
static
Smi
FromInt
(
int32_t
value
)
{
Smi
smi
;
smi
.
value_
=
JS
:
:
Int32Value
(
value
)
;
return
smi
;
}
static
inline
int32_t
ToInt
(
const
Object
object
)
{
return
JS
:
:
Value
(
object
)
.
toInt32
(
)
;
}
}
;
class
HeapObject
:
public
Object
{
public
:
int
Size
(
)
const
;
}
;
class
FixedArray
:
public
HeapObject
{
public
:
inline
void
set
(
uint32_t
index
Object
value
)
{
JS
:
:
Value
(
*
this
)
.
toObject
(
)
.
as
<
js
:
:
NativeObject
>
(
)
.
setDenseElement
(
index
value
)
;
}
}
;
class
ByteArray
:
public
HeapObject
{
public
:
uint8_t
get
(
uint32_t
index
)
;
void
set
(
uint32_t
index
uint8_t
val
)
;
uint32_t
length
(
)
;
byte
*
GetDataStartAddress
(
)
;
byte
*
GetDataEndAddress
(
)
;
static
ByteArray
cast
(
Object
object
)
;
}
;
class
HandleScope
{
public
:
HandleScope
(
Isolate
*
isolate
)
;
}
;
template
<
typename
T
>
class
Handle
{
public
:
Handle
(
)
;
Handle
(
T
object
Isolate
*
isolate
)
;
template
<
typename
S
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
S
*
T
*
>
:
:
value
>
:
:
type
>
Handle
(
Handle
<
S
>
handle
)
;
template
<
typename
S
>
static
const
Handle
<
T
>
cast
(
Handle
<
S
>
that
)
;
T
*
operator
-
>
(
)
const
;
T
operator
*
(
)
const
;
bool
is_null
(
)
const
;
Address
address
(
)
;
private
:
template
<
typename
>
friend
class
Handle
;
template
<
typename
>
friend
class
MaybeHandle
;
}
;
template
<
typename
T
>
class
MaybeHandle
final
{
public
:
MaybeHandle
(
)
=
default
;
template
<
typename
S
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_convertible
<
S
*
T
*
>
:
:
value
>
:
:
type
>
MaybeHandle
(
Handle
<
S
>
handle
)
;
Handle
<
T
>
ToHandleChecked
(
)
const
;
template
<
typename
S
>
bool
ToHandle
(
Handle
<
S
>
*
out
)
const
;
}
;
template
<
typename
T
>
inline
Handle
<
T
>
handle
(
T
object
Isolate
*
isolate
)
{
return
Handle
<
T
>
(
object
isolate
)
;
}
class
DisallowHeapAllocation
{
public
:
DisallowHeapAllocation
(
)
{
}
operator
const
JS
:
:
AutoAssertNoGC
&
(
)
const
{
return
no_gc_
;
}
private
:
const
JS
:
:
AutoAssertNoGC
no_gc_
;
}
;
class
AllowHeapAllocation
{
public
:
AllowHeapAllocation
(
)
{
}
}
;
class
String
:
public
HeapObject
{
private
:
JSString
*
str
(
)
const
{
return
value_
.
toString
(
)
;
}
public
:
operator
JSString
*
(
)
const
{
return
str
(
)
;
}
static
const
int32_t
kMaxOneByteCharCode
=
unibrow
:
:
Latin1
:
:
kMaxChar
;
static
const
uint32_t
kMaxOneByteCharCodeU
=
unibrow
:
:
Latin1
:
:
kMaxChar
;
static
const
int
kMaxUtf16CodeUnit
=
0xffff
;
static
const
uc32
kMaxCodePoint
=
0x10ffff
;
MOZ_ALWAYS_INLINE
int
length
(
)
const
{
return
str
(
)
-
>
length
(
)
;
}
uint16_t
Get
(
uint32_t
index
)
;
bool
IsFlat
(
)
{
return
str
(
)
-
>
isLinear
(
)
;
}
;
bool
IsConsString
(
)
;
bool
IsExternalString
(
)
;
bool
IsExternalOneByteString
(
)
;
bool
IsExternalTwoByteString
(
)
;
bool
IsSeqString
(
)
;
bool
IsSeqOneByteString
(
)
;
bool
IsSeqTwoByteString
(
)
;
bool
IsSlicedString
(
)
;
bool
IsThinString
(
)
;
class
FlatContent
{
public
:
FlatContent
(
JSLinearString
*
string
const
DisallowHeapAllocation
&
no_gc
)
:
string_
(
string
)
no_gc_
(
no_gc
)
{
}
inline
bool
IsOneByte
(
)
const
{
return
string_
-
>
hasLatin1Chars
(
)
;
}
inline
bool
IsTwoByte
(
)
const
{
return
!
string_
-
>
hasLatin1Chars
(
)
;
}
Vector
<
const
uint8_t
>
ToOneByteVector
(
)
const
{
MOZ_ASSERT
(
IsOneByte
(
)
)
;
return
Vector
<
const
uint8_t
>
(
string_
-
>
latin1Chars
(
no_gc_
)
string_
-
>
length
(
)
)
;
}
Vector
<
const
uc16
>
ToUC16Vector
(
)
const
;
private
:
const
JSLinearString
*
string_
;
const
JS
:
:
AutoAssertNoGC
&
no_gc_
;
}
;
FlatContent
GetFlatContent
(
const
DisallowHeapAllocation
&
no_gc
)
{
MOZ_ASSERT
(
IsFlat
(
)
)
;
return
FlatContent
(
&
str
(
)
-
>
asLinear
(
)
no_gc
)
;
}
static
Handle
<
String
>
Flatten
(
Isolate
*
isolate
Handle
<
String
>
string
)
;
inline
static
String
cast
(
Object
object
)
{
String
s
;
s
.
value_
=
JS
:
:
StringValue
(
JS
:
:
Value
(
object
)
.
toString
(
)
)
;
return
s
;
}
inline
static
bool
IsOneByteRepresentationUnderneath
(
String
string
)
{
return
string
.
str
(
)
-
>
hasLatin1Chars
(
)
;
}
inline
bool
IsOneByteRepresentation
(
)
const
{
return
str
(
)
-
>
hasLatin1Chars
(
)
;
}
std
:
:
unique_ptr
<
char
[
]
>
ToCString
(
)
;
template
<
typename
Char
>
Vector
<
const
Char
>
GetCharVector
(
const
DisallowHeapAllocation
&
no_gc
)
;
}
;
class
MOZ_STACK_CLASS
FlatStringReader
{
public
:
FlatStringReader
(
JSAtom
*
string
)
:
string_
(
string
)
{
}
int
length
(
)
{
return
string_
-
>
length
(
)
;
}
inline
char16_t
Get
(
size_t
index
)
{
return
string_
-
>
latin1OrTwoByteChar
(
index
)
;
}
private
:
JSAtom
*
string_
;
JS
:
:
AutoCheckCannotGC
nogc
;
}
;
class
ConsString
:
public
String
{
public
:
String
first
(
)
;
String
second
(
)
;
static
ConsString
cast
(
Object
object
)
;
}
;
class
ExternalOneByteString
:
public
String
{
public
:
const
uint8_t
*
GetChars
(
)
;
static
ExternalOneByteString
cast
(
Object
object
)
;
}
;
class
ExternalTwoByteString
:
public
String
{
public
:
const
uc16
*
GetChars
(
)
;
static
ExternalTwoByteString
cast
(
Object
object
)
;
}
;
class
SeqOneByteString
:
public
String
{
public
:
uint8_t
*
GetChars
(
const
DisallowHeapAllocation
&
no_gc
)
;
static
SeqOneByteString
cast
(
Object
object
)
;
}
;
class
SeqTwoByteString
:
public
String
{
public
:
uc16
*
GetChars
(
const
DisallowHeapAllocation
&
no_gc
)
;
static
SeqTwoByteString
cast
(
Object
object
)
;
static
constexpr
size_t
kMaxCharsSize
=
JSString
:
:
MAX_LENGTH
*
2
;
}
;
class
SlicedString
:
public
String
{
public
:
String
parent
(
)
;
int
offset
(
)
;
static
SlicedString
cast
(
Object
object
)
;
}
;
class
ThinString
:
public
String
{
public
:
String
actual
(
)
;
static
ThinString
cast
(
Object
object
)
;
}
;
class
StringShape
{
public
:
explicit
StringShape
(
const
String
s
)
;
bool
IsCons
(
)
;
bool
IsSliced
(
)
;
bool
IsThin
(
)
;
}
;
class
JSRegExp
:
public
HeapObject
{
public
:
void
TierUpTick
(
)
;
bool
MarkedForTierUp
(
)
const
;
Object
Code
(
bool
is_latin1
)
const
;
Object
Bytecode
(
bool
is_latin1
)
const
;
uint32_t
BacktrackLimit
(
)
const
;
static
JSRegExp
cast
(
Object
object
)
;
enum
Type
{
NOT_COMPILED
ATOM
IRREGEXP
}
;
static
constexpr
int
kMaxCaptures
=
1
<
<
16
;
struct
FlagShiftBit
{
static
constexpr
int
kGlobal
=
0
;
static
constexpr
int
kIgnoreCase
=
1
;
static
constexpr
int
kMultiline
=
2
;
static
constexpr
int
kSticky
=
3
;
static
constexpr
int
kUnicode
=
4
;
static
constexpr
int
kDotAll
=
5
;
static
constexpr
int
kInvalid
=
6
;
}
;
enum
Flag
:
uint8_t
{
kNone
=
0
kGlobal
=
1
<
<
FlagShiftBit
:
:
kGlobal
kIgnoreCase
=
1
<
<
FlagShiftBit
:
:
kIgnoreCase
kMultiline
=
1
<
<
FlagShiftBit
:
:
kMultiline
kSticky
=
1
<
<
FlagShiftBit
:
:
kSticky
kUnicode
=
1
<
<
FlagShiftBit
:
:
kUnicode
kDotAll
=
1
<
<
FlagShiftBit
:
:
kDotAll
kInvalid
=
1
<
<
FlagShiftBit
:
:
kInvalid
}
;
using
Flags
=
base
:
:
Flags
<
Flag
>
;
static
constexpr
int
kFlagCount
=
6
;
static
constexpr
int
kNoBacktrackLimit
=
0
;
}
;
class
Histogram
{
public
:
inline
void
AddSample
(
int
sample
)
{
}
}
;
class
Counters
{
public
:
Histogram
*
regexp_backtracks
(
)
{
return
&
regexp_backtracks_
;
}
private
:
Histogram
regexp_backtracks_
;
}
;
#
define
PROFILE
(
isolate
call
)
\
do
{
\
}
while
(
false
)
;
enum
class
AllocationType
:
uint8_t
{
kYoung
kOld
}
;
using
StackGuard
=
Isolate
;
using
Factory
=
Isolate
;
class
Isolate
{
public
:
RegExpStack
*
regexp_stack
(
)
const
{
return
regexp_stack_
;
}
bool
has_pending_exception
(
)
{
return
cx
(
)
-
>
isExceptionPending
(
)
;
}
void
StackOverflow
(
)
{
js
:
:
ReportOverRecursed
(
cx
(
)
)
;
}
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262UnCanonicalize
>
*
jsregexp_uncanonicalize
(
)
;
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
regexp_macro_assembler_canonicalize
(
)
;
unibrow
:
:
Mapping
<
unibrow
:
:
CanonicalizationRange
>
*
jsregexp_canonrange
(
)
;
void
IncreaseTotalRegexpCodeGenerated
(
int
size
)
{
}
Counters
*
counters
(
)
{
return
&
counters_
;
}
inline
Factory
*
factory
(
)
{
return
this
;
}
Handle
<
ByteArray
>
NewByteArray
(
int
length
AllocationType
allocation
=
AllocationType
:
:
kYoung
)
;
Handle
<
FixedArray
>
NewFixedArray
(
int
length
AllocationType
allocation
=
AllocationType
:
:
kYoung
)
;
template
<
typename
Char
>
Handle
<
String
>
InternalizeString
(
const
Vector
<
const
Char
>
&
str
)
;
inline
StackGuard
*
stack_guard
(
)
{
return
this
;
}
Object
HandleInterrupts
(
)
{
return
Object
(
JS
:
:
BooleanValue
(
cx
(
)
-
>
handleInterrupt
(
)
)
)
;
}
JSContext
*
cx
(
)
const
{
return
cx_
;
}
private
:
JSContext
*
cx_
;
RegExpStack
*
regexp_stack_
;
Counters
counters_
;
}
;
class
StackLimitCheck
{
public
:
StackLimitCheck
(
Isolate
*
isolate
)
:
cx_
(
isolate
-
>
cx
(
)
)
{
}
bool
HasOverflowed
(
)
{
return
!
CheckRecursionLimitDontReport
(
cx_
)
;
}
bool
InterruptRequested
(
)
{
return
cx_
-
>
hasAnyPendingInterrupt
(
)
;
}
bool
JsHasOverflowed
(
)
{
return
!
CheckRecursionLimitConservativeDontReport
(
cx_
)
;
}
private
:
JSContext
*
cx_
;
}
;
class
Code
:
public
HeapObject
{
public
:
uint8_t
*
raw_instruction_start
(
)
{
return
inner
(
)
-
>
raw
(
)
;
}
static
Code
cast
(
Object
object
)
{
Code
c
;
MOZ_ASSERT
(
JS
:
:
Value
(
object
)
.
toGCThing
(
)
-
>
is
<
js
:
:
jit
:
:
JitCode
>
(
)
)
;
c
.
value_
=
JS
:
:
PrivateGCThingValue
(
JS
:
:
Value
(
object
)
.
toGCThing
(
)
)
;
return
c
;
}
private
:
js
:
:
jit
:
:
JitCode
*
inner
(
)
{
return
value_
.
toGCThing
(
)
-
>
as
<
js
:
:
jit
:
:
JitCode
>
(
)
;
}
}
;
enum
class
MessageTemplate
{
kStackOverflow
}
;
class
MessageFormatter
{
public
:
static
const
char
*
TemplateString
(
MessageTemplate
index
)
{
switch
(
index
)
{
case
MessageTemplate
:
:
kStackOverflow
:
return
"
too
much
recursion
"
;
}
}
}
;
class
Label
{
public
:
Label
(
)
:
inner_
(
js
:
:
jit
:
:
Label
(
)
)
{
}
operator
js
:
:
jit
:
:
Label
*
(
)
{
return
&
inner_
;
}
void
Unuse
(
)
{
inner_
.
reset
(
)
;
}
bool
is_linked
(
)
{
return
inner_
.
used
(
)
;
}
bool
is_bound
(
)
{
return
inner_
.
bound
(
)
;
}
bool
is_unused
(
)
{
return
!
inner_
.
used
(
)
&
&
!
inner_
.
bound
(
)
;
}
int
pos
(
)
{
return
inner_
.
offset
(
)
;
}
void
link_to
(
int
pos
)
{
inner_
.
use
(
pos
)
;
}
void
bind_to
(
int
pos
)
{
inner_
.
bind
(
pos
)
;
}
private
:
js
:
:
jit
:
:
Label
inner_
;
}
;
extern
bool
FLAG_correctness_fuzzer_suppressions
;
extern
bool
FLAG_enable_regexp_unaligned_accesses
;
extern
bool
FLAG_harmony_regexp_sequence
;
extern
bool
FLAG_regexp_interpret_all
;
extern
bool
FLAG_regexp_mode_modifiers
;
extern
bool
FLAG_regexp_optimization
;
extern
bool
FLAG_regexp_peephole_optimization
;
extern
bool
FLAG_regexp_possessive_quantifier
;
extern
bool
FLAG_regexp_tier_up
;
extern
bool
FLAG_trace_regexp_assembler
;
extern
bool
FLAG_trace_regexp_bytecodes
;
extern
bool
FLAG_trace_regexp_parser
;
extern
bool
FLAG_trace_regexp_peephole_optimization
;
}
}
#
endif
