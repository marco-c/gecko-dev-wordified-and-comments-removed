#
ifndef
V8_REGEXP_REGEXP_H_
#
define
V8_REGEXP_REGEXP_H_
#
include
"
src
/
objects
/
js
-
regexp
.
h
"
namespace
v8
{
namespace
internal
{
class
RegExpNode
;
class
RegExpTree
;
enum
class
RegExpCompilationTarget
:
int
{
kBytecode
kNative
}
;
struct
RegExpCompileData
{
RegExpTree
*
tree
=
nullptr
;
RegExpNode
*
node
=
nullptr
;
Object
code
;
bool
simple
=
true
;
bool
contains_anchor
=
false
;
Handle
<
FixedArray
>
capture_name_map
;
Handle
<
String
>
error
;
int
capture_count
=
0
;
int
register_count
=
0
;
RegExpCompilationTarget
compilation_target
;
}
;
class
RegExp
final
:
public
AllStatic
{
public
:
static
bool
CanGenerateBytecode
(
)
{
return
FLAG_regexp_interpret_all
|
|
FLAG_regexp_tier_up
;
}
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
Compile
(
Isolate
*
isolate
Handle
<
JSRegExp
>
re
Handle
<
String
>
pattern
JSRegExp
:
:
Flags
flags
uint32_t
backtrack_limit
)
;
enum
CallOrigin
:
int
{
kFromRuntime
=
0
kFromJs
=
1
}
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
Exec
(
Isolate
*
isolate
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
index
Handle
<
RegExpMatchInfo
>
last_match_info
)
;
static
constexpr
int
kInternalRegExpFailure
=
0
;
static
constexpr
int
kInternalRegExpSuccess
=
1
;
static
constexpr
int
kInternalRegExpException
=
-
1
;
static
constexpr
int
kInternalRegExpRetry
=
-
2
;
enum
IrregexpResult
:
int32_t
{
RE_FAILURE
=
kInternalRegExpFailure
RE_SUCCESS
=
kInternalRegExpSuccess
RE_EXCEPTION
=
kInternalRegExpException
}
;
static
int
IrregexpPrepare
(
Isolate
*
isolate
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
)
;
static
Handle
<
RegExpMatchInfo
>
SetLastMatchInfo
(
Isolate
*
isolate
Handle
<
RegExpMatchInfo
>
last_match_info
Handle
<
String
>
subject
int
capture_count
int32_t
*
match
)
;
V8_EXPORT_PRIVATE
static
bool
CompileForTesting
(
Isolate
*
isolate
Zone
*
zone
RegExpCompileData
*
input
JSRegExp
:
:
Flags
flags
Handle
<
String
>
pattern
Handle
<
String
>
sample_subject
bool
is_one_byte
)
;
V8_EXPORT_PRIVATE
static
void
DotPrintForTesting
(
const
char
*
label
RegExpNode
*
node
)
;
static
const
int
kRegExpTooLargeToOptimize
=
20
*
KB
;
}
;
class
RegExpGlobalCache
final
{
public
:
RegExpGlobalCache
(
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
Isolate
*
isolate
)
;
~
RegExpGlobalCache
(
)
;
int32_t
*
FetchNext
(
)
;
int32_t
*
LastSuccessfulMatch
(
)
;
bool
HasException
(
)
{
return
num_matches_
<
0
;
}
private
:
int
AdvanceZeroLength
(
int
last_index
)
;
int
num_matches_
;
int
max_matches_
;
int
current_match_index_
;
int
registers_per_match_
;
int32_t
*
register_array_
;
int
register_array_size_
;
Handle
<
JSRegExp
>
regexp_
;
Handle
<
String
>
subject_
;
Isolate
*
isolate_
;
}
;
class
RegExpResultsCache
final
:
public
AllStatic
{
public
:
enum
ResultsCacheType
{
REGEXP_MULTIPLE_INDICES
STRING_SPLIT_SUBSTRINGS
}
;
static
Object
Lookup
(
Heap
*
heap
String
key_string
Object
key_pattern
FixedArray
*
last_match_out
ResultsCacheType
type
)
;
static
void
Enter
(
Isolate
*
isolate
Handle
<
String
>
key_string
Handle
<
Object
>
key_pattern
Handle
<
FixedArray
>
value_array
Handle
<
FixedArray
>
last_match_cache
ResultsCacheType
type
)
;
static
void
Clear
(
FixedArray
cache
)
;
static
constexpr
int
kRegExpResultsCacheSize
=
0x100
;
private
:
static
constexpr
int
kStringOffset
=
0
;
static
constexpr
int
kPatternOffset
=
1
;
static
constexpr
int
kArrayOffset
=
2
;
static
constexpr
int
kLastMatchOffset
=
3
;
static
constexpr
int
kArrayEntriesPerCacheEntry
=
4
;
}
;
}
}
#
endif
