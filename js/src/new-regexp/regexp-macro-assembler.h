#
ifndef
V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
#
define
V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
#
include
"
src
/
codegen
/
label
.
h
"
#
include
"
src
/
regexp
/
regexp
-
ast
.
h
"
#
include
"
src
/
regexp
/
regexp
.
h
"
namespace
v8
{
namespace
internal
{
static
const
uc32
kLeadSurrogateStart
=
0xd800
;
static
const
uc32
kLeadSurrogateEnd
=
0xdbff
;
static
const
uc32
kTrailSurrogateStart
=
0xdc00
;
static
const
uc32
kTrailSurrogateEnd
=
0xdfff
;
static
const
uc32
kNonBmpStart
=
0x10000
;
static
const
uc32
kNonBmpEnd
=
0x10ffff
;
struct
DisjunctDecisionRow
{
RegExpCharacterClass
cc
;
Label
*
on_match
;
}
;
class
RegExpMacroAssembler
{
public
:
static
const
int
kMaxRegister
=
(
1
<
<
16
)
-
1
;
static
const
int
kMaxCPOffset
=
(
1
<
<
15
)
-
1
;
static
const
int
kMinCPOffset
=
-
(
1
<
<
15
)
;
static
const
int
kTableSizeBits
=
7
;
static
const
int
kTableSize
=
1
<
<
kTableSizeBits
;
static
const
int
kTableMask
=
kTableSize
-
1
;
static
constexpr
int
kUseCharactersValue
=
-
1
;
enum
IrregexpImplementation
{
kIA32Implementation
kARMImplementation
kARM64Implementation
kMIPSImplementation
kS390Implementation
kPPCImplementation
kX64Implementation
kX87Implementation
kBytecodeImplementation
}
;
enum
StackCheckFlag
{
kNoStackLimitCheck
=
false
kCheckStackLimit
=
true
}
;
RegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
;
virtual
~
RegExpMacroAssembler
(
)
;
virtual
void
AbortedCodeGeneration
(
)
{
}
virtual
int
stack_limit_slack
(
)
=
0
;
virtual
bool
CanReadUnaligned
(
)
=
0
;
virtual
void
AdvanceCurrentPosition
(
int
by
)
=
0
;
virtual
void
AdvanceRegister
(
int
reg
int
by
)
=
0
;
virtual
void
Backtrack
(
)
=
0
;
virtual
void
Bind
(
Label
*
label
)
=
0
;
virtual
void
CheckCharacter
(
unsigned
c
Label
*
on_equal
)
=
0
;
virtual
void
CheckCharacterAfterAnd
(
unsigned
c
unsigned
and_with
Label
*
on_equal
)
=
0
;
virtual
void
CheckCharacterGT
(
uc16
limit
Label
*
on_greater
)
=
0
;
virtual
void
CheckCharacterLT
(
uc16
limit
Label
*
on_less
)
=
0
;
virtual
void
CheckGreedyLoop
(
Label
*
on_tos_equals_current_position
)
=
0
;
virtual
void
CheckAtStart
(
int
cp_offset
Label
*
on_at_start
)
=
0
;
virtual
void
CheckNotAtStart
(
int
cp_offset
Label
*
on_not_at_start
)
=
0
;
virtual
void
CheckNotBackReference
(
int
start_reg
bool
read_backward
Label
*
on_no_match
)
=
0
;
virtual
void
CheckNotBackReferenceIgnoreCase
(
int
start_reg
bool
read_backward
bool
unicode
Label
*
on_no_match
)
=
0
;
virtual
void
CheckNotCharacter
(
unsigned
c
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckNotCharacterAfterAnd
(
unsigned
c
unsigned
and_with
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckNotCharacterAfterMinusAnd
(
uc16
c
uc16
minus
uc16
and_with
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckCharacterInRange
(
uc16
from
uc16
to
Label
*
on_in_range
)
=
0
;
virtual
void
CheckCharacterNotInRange
(
uc16
from
uc16
to
Label
*
on_not_in_range
)
=
0
;
virtual
void
CheckBitInTable
(
Handle
<
ByteArray
>
table
Label
*
on_bit_set
)
=
0
;
virtual
void
CheckPosition
(
int
cp_offset
Label
*
on_outside_input
)
;
virtual
bool
CheckSpecialCharacterClass
(
uc16
type
Label
*
on_no_match
)
;
virtual
void
Fail
(
)
=
0
;
virtual
Handle
<
HeapObject
>
GetCode
(
Handle
<
String
>
source
)
=
0
;
virtual
void
GoTo
(
Label
*
label
)
=
0
;
virtual
void
IfRegisterGE
(
int
reg
int
comparand
Label
*
if_ge
)
=
0
;
virtual
void
IfRegisterLT
(
int
reg
int
comparand
Label
*
if_lt
)
=
0
;
virtual
void
IfRegisterEqPos
(
int
reg
Label
*
if_eq
)
=
0
;
virtual
IrregexpImplementation
Implementation
(
)
=
0
;
V8_EXPORT_PRIVATE
void
LoadCurrentCharacter
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
=
true
int
characters
=
1
int
eats_at_least
=
kUseCharactersValue
)
;
virtual
void
LoadCurrentCharacterImpl
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
int
characters
int
eats_at_least
)
=
0
;
virtual
void
PopCurrentPosition
(
)
=
0
;
virtual
void
PopRegister
(
int
register_index
)
=
0
;
virtual
void
PushBacktrack
(
Label
*
label
)
=
0
;
virtual
void
PushCurrentPosition
(
)
=
0
;
virtual
void
PushRegister
(
int
register_index
StackCheckFlag
check_stack_limit
)
=
0
;
virtual
void
ReadCurrentPositionFromRegister
(
int
reg
)
=
0
;
virtual
void
ReadStackPointerFromRegister
(
int
reg
)
=
0
;
virtual
void
SetCurrentPositionFromEnd
(
int
by
)
=
0
;
virtual
void
SetRegister
(
int
register_index
int
to
)
=
0
;
virtual
bool
Succeed
(
)
=
0
;
virtual
void
WriteCurrentPositionToRegister
(
int
reg
int
cp_offset
)
=
0
;
virtual
void
ClearRegisters
(
int
reg_from
int
reg_to
)
=
0
;
virtual
void
WriteStackPointerToRegister
(
int
reg
)
=
0
;
static
int
CaseInsensitiveCompareUC16
(
Address
byte_offset1
Address
byte_offset2
size_t
byte_length
Isolate
*
isolate
)
;
void
CheckNotInSurrogatePair
(
int
cp_offset
Label
*
on_failure
)
;
void
set_slow_safe
(
bool
ssc
)
{
slow_safe_compiler_
=
ssc
;
}
bool
slow_safe
(
)
{
return
slow_safe_compiler_
;
}
void
set_backtrack_limit
(
uint32_t
backtrack_limit
)
{
backtrack_limit_
=
backtrack_limit
;
}
enum
GlobalMode
{
NOT_GLOBAL
GLOBAL_NO_ZERO_LENGTH_CHECK
GLOBAL
GLOBAL_UNICODE
}
;
inline
void
set_global_mode
(
GlobalMode
mode
)
{
global_mode_
=
mode
;
}
inline
bool
global
(
)
{
return
global_mode_
!
=
NOT_GLOBAL
;
}
inline
bool
global_with_zero_length_check
(
)
{
return
global_mode_
=
=
GLOBAL
|
|
global_mode_
=
=
GLOBAL_UNICODE
;
}
inline
bool
global_unicode
(
)
{
return
global_mode_
=
=
GLOBAL_UNICODE
;
}
Isolate
*
isolate
(
)
const
{
return
isolate_
;
}
Zone
*
zone
(
)
const
{
return
zone_
;
}
protected
:
bool
has_backtrack_limit
(
)
const
{
return
backtrack_limit_
!
=
JSRegExp
:
:
kNoBacktrackLimit
;
}
uint32_t
backtrack_limit
(
)
const
{
return
backtrack_limit_
;
}
private
:
bool
slow_safe_compiler_
;
uint32_t
backtrack_limit_
=
JSRegExp
:
:
kNoBacktrackLimit
;
GlobalMode
global_mode_
;
Isolate
*
isolate_
;
Zone
*
zone_
;
}
;
class
NativeRegExpMacroAssembler
:
public
RegExpMacroAssembler
{
public
:
enum
Mode
{
LATIN1
=
1
UC16
=
2
}
;
enum
Result
{
FAILURE
=
RegExp
:
:
kInternalRegExpFailure
SUCCESS
=
RegExp
:
:
kInternalRegExpSuccess
EXCEPTION
=
RegExp
:
:
kInternalRegExpException
RETRY
=
RegExp
:
:
kInternalRegExpRetry
}
;
NativeRegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
;
~
NativeRegExpMacroAssembler
(
)
override
;
bool
CanReadUnaligned
(
)
override
;
static
int
Match
(
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
*
offsets_vector
int
offsets_vector_length
int
previous_index
Isolate
*
isolate
)
;
static
Address
GrowStack
(
Address
stack_pointer
Address
*
stack_top
Isolate
*
isolate
)
;
static
const
byte
*
StringCharacterPosition
(
String
subject
int
start_index
const
DisallowHeapAllocation
&
no_gc
)
;
static
int
CheckStackGuardState
(
Isolate
*
isolate
int
start_index
RegExp
:
:
CallOrigin
call_origin
Address
*
return_address
Code
re_code
Address
*
subject
const
byte
*
*
input_start
const
byte
*
*
input_end
)
;
static
const
byte
word_character_map
[
256
]
;
static
Address
word_character_map_address
(
)
{
return
reinterpret_cast
<
Address
>
(
&
word_character_map
[
0
]
)
;
}
V8_EXPORT_PRIVATE
static
int
Execute
(
String
input
int
start_offset
const
byte
*
input_start
const
byte
*
input_end
int
*
output
int
output_size
Isolate
*
isolate
JSRegExp
regexp
)
;
}
;
}
}
#
endif
