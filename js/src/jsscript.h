#
ifndef
jsscript_h
#
define
jsscript_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
namespace
JS
{
struct
ScriptSourceInfo
;
}
namespace
js
{
namespace
jit
{
struct
BaselineScript
;
struct
IonScriptCounts
;
}
#
define
ION_DISABLED_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x1
)
#
define
ION_COMPILING_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x2
)
#
define
ION_PENDING_SCRIPT
(
(
js
:
:
jit
:
:
IonScript
*
)
0x3
)
#
define
BASELINE_DISABLED_SCRIPT
(
(
js
:
:
jit
:
:
BaselineScript
*
)
0x1
)
class
BreakpointSite
;
class
Debugger
;
class
LazyScript
;
class
ModuleObject
;
class
RegExpObject
;
struct
SourceCompressionTask
;
class
Shape
;
namespace
frontend
{
struct
BytecodeEmitter
;
class
FunctionBox
;
class
ModuleSharedContext
;
}
namespace
detail
{
bool
CopyScript
(
JSContext
*
cx
HandleScript
src
HandleScript
dst
MutableHandle
<
GCVector
<
Scope
*
>
>
scopes
)
;
}
}
enum
JSTryNoteKind
{
JSTRY_CATCH
JSTRY_FINALLY
JSTRY_FOR_IN
JSTRY_FOR_OF
JSTRY_LOOP
}
;
struct
JSTryNote
{
uint8_t
kind
;
uint32_t
stackDepth
;
uint32_t
start
;
uint32_t
length
;
}
;
namespace
js
{
struct
ScopeNote
{
static
const
uint32_t
NoScopeIndex
=
UINT32_MAX
;
static
const
uint32_t
NoScopeNoteIndex
=
UINT32_MAX
;
uint32_t
index
;
uint32_t
start
;
uint32_t
length
;
uint32_t
parent
;
}
;
struct
ConstArray
{
js
:
:
GCPtrValue
*
vector
;
uint32_t
length
;
}
;
struct
ObjectArray
{
js
:
:
GCPtrObject
*
vector
;
uint32_t
length
;
}
;
struct
ScopeArray
{
js
:
:
GCPtrScope
*
vector
;
uint32_t
length
;
}
;
struct
TryNoteArray
{
JSTryNote
*
vector
;
uint32_t
length
;
}
;
struct
ScopeNoteArray
{
ScopeNote
*
vector
;
uint32_t
length
;
}
;
class
YieldOffsetArray
{
friend
bool
detail
:
:
CopyScript
(
JSContext
*
cx
HandleScript
src
HandleScript
dst
MutableHandle
<
GCVector
<
Scope
*
>
>
scopes
)
;
uint32_t
*
vector_
;
uint32_t
length_
;
public
:
void
init
(
uint32_t
*
vector
uint32_t
length
)
{
vector_
=
vector
;
length_
=
length
;
}
uint32_t
&
operator
[
]
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
length_
)
;
return
vector_
[
index
]
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
}
;
class
ScriptCounts
{
public
:
typedef
mozilla
:
:
Vector
<
PCCounts
0
SystemAllocPolicy
>
PCCountsVector
;
inline
ScriptCounts
(
)
;
inline
explicit
ScriptCounts
(
PCCountsVector
&
&
jumpTargets
)
;
inline
ScriptCounts
(
ScriptCounts
&
&
src
)
;
inline
~
ScriptCounts
(
)
;
inline
ScriptCounts
&
operator
=
(
ScriptCounts
&
&
src
)
;
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetPCCounts
(
size_t
offset
)
const
;
PCCounts
*
getImmediatePrecedingPCCounts
(
size_t
offset
)
;
const
PCCounts
*
maybeGetThrowCounts
(
size_t
offset
)
const
;
const
PCCounts
*
getImmediatePrecedingThrowCounts
(
size_t
offset
)
const
;
PCCounts
*
getThrowCounts
(
size_t
offset
)
;
private
:
friend
class
:
:
JSScript
;
friend
struct
ScriptAndCounts
;
PCCountsVector
pcCounts_
;
PCCountsVector
throwCounts_
;
jit
:
:
IonScriptCounts
*
ionCounts_
;
}
;
typedef
HashMap
<
JSScript
*
ScriptCounts
*
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
ScriptCountsMap
;
class
DebugScript
{
friend
class
:
:
JSScript
;
friend
struct
:
:
JSCompartment
;
uint32_t
stepMode
;
uint32_t
numSites
;
BreakpointSite
*
breakpoints
[
1
]
;
}
;
typedef
HashMap
<
JSScript
*
DebugScript
*
DefaultHasher
<
JSScript
*
>
SystemAllocPolicy
>
DebugScriptMap
;
class
ScriptSource
;
struct
ScriptSourceChunk
{
ScriptSource
*
ss
;
uint32_t
chunk
;
ScriptSourceChunk
(
)
:
ss
(
nullptr
)
chunk
(
0
)
{
}
ScriptSourceChunk
(
ScriptSource
*
ss
uint32_t
chunk
)
:
ss
(
ss
)
chunk
(
chunk
)
{
MOZ_ASSERT
(
valid
(
)
)
;
;
}
bool
valid
(
)
const
{
return
ss
!
=
nullptr
;
}
bool
operator
=
=
(
const
ScriptSourceChunk
&
other
)
const
{
return
ss
=
=
other
.
ss
&
&
chunk
=
=
other
.
chunk
;
}
}
;
struct
ScriptSourceChunkHasher
{
using
Lookup
=
ScriptSourceChunk
;
static
HashNumber
hash
(
const
ScriptSourceChunk
&
ssc
)
{
return
mozilla
:
:
AddToHash
(
DefaultHasher
<
ScriptSource
*
>
:
:
hash
(
ssc
.
ss
)
ssc
.
chunk
)
;
}
static
bool
match
(
const
ScriptSourceChunk
&
c1
const
ScriptSourceChunk
&
c2
)
{
return
c1
=
=
c2
;
}
}
;
class
UncompressedSourceCache
{
typedef
HashMap
<
ScriptSourceChunk
UniqueTwoByteChars
ScriptSourceChunkHasher
SystemAllocPolicy
>
Map
;
public
:
class
AutoHoldEntry
{
UncompressedSourceCache
*
cache_
;
ScriptSourceChunk
sourceChunk_
;
UniqueTwoByteChars
charsToFree_
;
public
:
explicit
AutoHoldEntry
(
)
;
~
AutoHoldEntry
(
)
;
void
holdChars
(
UniqueTwoByteChars
chars
)
;
private
:
void
holdEntry
(
UncompressedSourceCache
*
cache
const
ScriptSourceChunk
&
sourceChunk
)
;
void
deferDelete
(
UniqueTwoByteChars
chars
)
;
const
ScriptSourceChunk
&
sourceChunk
(
)
const
{
return
sourceChunk_
;
}
friend
class
UncompressedSourceCache
;
}
;
private
:
UniquePtr
<
Map
>
map_
;
AutoHoldEntry
*
holder_
;
public
:
UncompressedSourceCache
(
)
:
holder_
(
nullptr
)
{
}
const
char16_t
*
lookup
(
const
ScriptSourceChunk
&
ssc
AutoHoldEntry
&
asp
)
;
bool
put
(
const
ScriptSourceChunk
&
ssc
UniqueTwoByteChars
chars
AutoHoldEntry
&
asp
)
;
void
purge
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
void
holdEntry
(
AutoHoldEntry
&
holder
const
ScriptSourceChunk
&
ssc
)
;
void
releaseEntry
(
AutoHoldEntry
&
holder
)
;
}
;
class
ScriptSource
{
friend
struct
SourceCompressionTask
;
uint32_t
refs
;
struct
Missing
{
}
;
struct
Uncompressed
{
SharedImmutableTwoByteString
string
;
explicit
Uncompressed
(
SharedImmutableTwoByteString
&
&
str
)
:
string
(
mozilla
:
:
Move
(
str
)
)
{
}
}
;
struct
Compressed
{
SharedImmutableString
raw
;
size_t
uncompressedLength
;
Compressed
(
SharedImmutableString
&
&
raw
size_t
uncompressedLength
)
:
raw
(
mozilla
:
:
Move
(
raw
)
)
uncompressedLength
(
uncompressedLength
)
{
}
}
;
using
SourceType
=
mozilla
:
:
Variant
<
Missing
Uncompressed
Compressed
>
;
SourceType
data
;
UniqueChars
filename_
;
UniqueTwoByteChars
displayURL_
;
UniqueTwoByteChars
sourceMapURL_
;
bool
mutedErrors_
;
uint32_t
introductionOffset_
;
UniqueChars
introducerFilename_
;
const
char
*
introductionType_
;
bool
sourceRetrievable_
:
1
;
bool
argumentsNotIncluded_
:
1
;
bool
hasIntroductionOffset_
:
1
;
const
char16_t
*
chunkChars
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
holder
size_t
chunk
)
;
public
:
explicit
ScriptSource
(
)
:
refs
(
0
)
data
(
SourceType
(
Missing
(
)
)
)
filename_
(
nullptr
)
displayURL_
(
nullptr
)
sourceMapURL_
(
nullptr
)
mutedErrors_
(
false
)
introductionOffset_
(
0
)
introducerFilename_
(
nullptr
)
introductionType_
(
nullptr
)
sourceRetrievable_
(
false
)
argumentsNotIncluded_
(
false
)
hasIntroductionOffset_
(
false
)
{
}
~
ScriptSource
(
)
{
MOZ_ASSERT
(
refs
=
=
0
)
;
}
void
incref
(
)
{
refs
+
+
;
}
void
decref
(
)
{
MOZ_ASSERT
(
refs
!
=
0
)
;
if
(
-
-
refs
=
=
0
)
js_delete
(
this
)
;
}
bool
initFromOptions
(
ExclusiveContext
*
cx
const
ReadOnlyCompileOptions
&
options
)
;
bool
setSourceCopy
(
ExclusiveContext
*
cx
JS
:
:
SourceBufferHolder
&
srcBuf
bool
argumentsNotIncluded
SourceCompressionTask
*
tok
)
;
void
setSourceRetrievable
(
)
{
sourceRetrievable_
=
true
;
}
bool
sourceRetrievable
(
)
const
{
return
sourceRetrievable_
;
}
bool
hasSourceData
(
)
const
{
return
!
data
.
is
<
Missing
>
(
)
;
}
bool
hasCompressedSource
(
)
const
{
return
data
.
is
<
Compressed
>
(
)
;
}
size_t
length
(
)
const
{
struct
LengthMatcher
{
size_t
match
(
const
Uncompressed
&
u
)
{
return
u
.
string
.
length
(
)
;
}
size_t
match
(
const
Compressed
&
c
)
{
return
c
.
uncompressedLength
;
}
size_t
match
(
const
Missing
&
m
)
{
MOZ_CRASH
(
"
ScriptSource
:
:
length
on
a
missing
source
"
)
;
return
0
;
}
}
;
MOZ_ASSERT
(
hasSourceData
(
)
)
;
return
data
.
match
(
LengthMatcher
(
)
)
;
}
bool
argumentsNotIncluded
(
)
const
{
MOZ_ASSERT
(
hasSourceData
(
)
)
;
return
argumentsNotIncluded_
;
}
const
char16_t
*
chars
(
JSContext
*
cx
UncompressedSourceCache
:
:
AutoHoldEntry
&
asp
size_t
begin
size_t
len
)
;
JSFlatString
*
substring
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
JSFlatString
*
substringDontDeflate
(
JSContext
*
cx
size_t
start
size_t
stop
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ScriptSourceInfo
*
info
)
const
;
MOZ_MUST_USE
bool
setSource
(
ExclusiveContext
*
cx
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
&
&
source
size_t
length
)
;
void
setSource
(
SharedImmutableTwoByteString
&
&
string
)
;
MOZ_MUST_USE
bool
setCompressedSource
(
ExclusiveContext
*
cx
mozilla
:
:
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
&
&
raw
size_t
rawLength
size_t
sourceLength
)
;
void
setCompressedSource
(
SharedImmutableString
&
&
raw
size_t
sourceLength
)
;
template
<
XDRMode
mode
>
bool
performXDR
(
XDRState
<
mode
>
*
xdr
)
;
bool
setFilename
(
ExclusiveContext
*
cx
const
char
*
filename
)
;
const
char
*
introducerFilename
(
)
const
{
return
introducerFilename_
?
introducerFilename_
.
get
(
)
:
filename_
.
get
(
)
;
}
bool
hasIntroductionType
(
)
const
{
return
introductionType_
;
}
const
char
*
introductionType
(
)
const
{
MOZ_ASSERT
(
hasIntroductionType
(
)
)
;
return
introductionType_
;
}
const
char
*
filename
(
)
const
{
return
filename_
.
get
(
)
;
}
bool
setDisplayURL
(
ExclusiveContext
*
cx
const
char16_t
*
displayURL
)
;
bool
hasDisplayURL
(
)
const
{
return
displayURL_
!
=
nullptr
;
}
const
char16_t
*
displayURL
(
)
{
MOZ_ASSERT
(
hasDisplayURL
(
)
)
;
return
displayURL_
.
get
(
)
;
}
bool
setSourceMapURL
(
ExclusiveContext
*
cx
const
char16_t
*
sourceMapURL
)
;
bool
hasSourceMapURL
(
)
const
{
return
sourceMapURL_
!
=
nullptr
;
}
const
char16_t
*
sourceMapURL
(
)
{
MOZ_ASSERT
(
hasSourceMapURL
(
)
)
;
return
sourceMapURL_
.
get
(
)
;
}
bool
mutedErrors
(
)
const
{
return
mutedErrors_
;
}
bool
hasIntroductionOffset
(
)
const
{
return
hasIntroductionOffset_
;
}
uint32_t
introductionOffset
(
)
const
{
MOZ_ASSERT
(
hasIntroductionOffset
(
)
)
;
return
introductionOffset_
;
}
void
setIntroductionOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
hasIntroductionOffset
(
)
)
;
MOZ_ASSERT
(
offset
<
=
(
uint32_t
)
INT32_MAX
)
;
introductionOffset_
=
offset
;
hasIntroductionOffset_
=
true
;
}
}
;
class
ScriptSourceHolder
{
ScriptSource
*
ss
;
public
:
ScriptSourceHolder
(
)
:
ss
(
nullptr
)
{
}
explicit
ScriptSourceHolder
(
ScriptSource
*
ss
)
:
ss
(
ss
)
{
ss
-
>
incref
(
)
;
}
~
ScriptSourceHolder
(
)
{
if
(
ss
)
ss
-
>
decref
(
)
;
}
void
reset
(
ScriptSource
*
newss
)
{
if
(
ss
)
ss
-
>
decref
(
)
;
ss
=
newss
;
ss
-
>
incref
(
)
;
}
ScriptSource
*
get
(
)
const
{
return
ss
;
}
}
;
class
ScriptSourceObject
:
public
NativeObject
{
static
const
ClassOps
classOps_
;
public
:
static
const
Class
class_
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
void
finalize
(
FreeOp
*
fop
JSObject
*
obj
)
;
static
ScriptSourceObject
*
create
(
ExclusiveContext
*
cx
ScriptSource
*
source
)
;
static
bool
initFromOptions
(
JSContext
*
cx
HandleScriptSource
source
const
ReadOnlyCompileOptions
&
options
)
;
ScriptSource
*
source
(
)
const
{
return
static_cast
<
ScriptSource
*
>
(
getReservedSlot
(
SOURCE_SLOT
)
.
toPrivate
(
)
)
;
}
JSObject
*
element
(
)
const
{
return
getReservedSlot
(
ELEMENT_SLOT
)
.
toObjectOrNull
(
)
;
}
const
Value
&
elementAttributeName
(
)
const
{
MOZ_ASSERT
(
!
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
.
isMagic
(
)
)
;
return
getReservedSlot
(
ELEMENT_PROPERTY_SLOT
)
;
}
JSScript
*
introductionScript
(
)
const
{
if
(
getReservedSlot
(
INTRODUCTION_SCRIPT_SLOT
)
.
isUndefined
(
)
)
return
nullptr
;
void
*
untyped
=
getReservedSlot
(
INTRODUCTION_SCRIPT_SLOT
)
.
toPrivate
(
)
;
MOZ_ASSERT
(
untyped
)
;
return
static_cast
<
JSScript
*
>
(
untyped
)
;
}
private
:
static
const
uint32_t
SOURCE_SLOT
=
0
;
static
const
uint32_t
ELEMENT_SLOT
=
1
;
static
const
uint32_t
ELEMENT_PROPERTY_SLOT
=
2
;
static
const
uint32_t
INTRODUCTION_SCRIPT_SLOT
=
3
;
static
const
uint32_t
RESERVED_SLOTS
=
4
;
}
;
enum
GeneratorKind
{
NotGenerator
LegacyGenerator
StarGenerator
}
;
static
inline
unsigned
GeneratorKindAsBits
(
GeneratorKind
generatorKind
)
{
return
static_cast
<
unsigned
>
(
generatorKind
)
;
}
static
inline
GeneratorKind
GeneratorKindFromBits
(
unsigned
val
)
{
MOZ_ASSERT
(
val
<
=
StarGenerator
)
;
return
static_cast
<
GeneratorKind
>
(
val
)
;
}
template
<
XDRMode
mode
>
bool
XDRScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScript
enclosingScript
HandleFunction
fun
MutableHandleScript
scriptp
)
;
template
<
XDRMode
mode
>
bool
XDRLazyScript
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScript
enclosingScript
HandleFunction
fun
MutableHandle
<
LazyScript
*
>
lazy
)
;
template
<
XDRMode
mode
>
bool
XDRScriptConst
(
XDRState
<
mode
>
*
xdr
MutableHandleValue
vp
)
;
class
SharedScriptData
{
mozilla
:
:
Atomic
<
uint32_t
>
refCount_
;
uint32_t
dataLength_
;
uint32_t
natoms_
;
uint32_t
codeLength_
;
uintptr_t
data_
[
1
]
;
public
:
static
SharedScriptData
*
new_
(
ExclusiveContext
*
cx
uint32_t
codeLength
uint32_t
srcnotesLength
uint32_t
natoms
)
;
uint32_t
refCount
(
)
const
{
return
refCount_
;
}
void
incRefCount
(
)
{
refCount_
+
+
;
}
void
decRefCount
(
)
{
MOZ_ASSERT
(
refCount_
!
=
0
)
;
refCount_
-
-
;
if
(
refCount_
=
=
0
)
js_free
(
this
)
;
}
uint32_t
dataLength
(
)
const
{
return
dataLength_
;
}
uint8_t
*
data
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
data_
)
;
}
uint32_t
natoms
(
)
const
{
return
natoms_
;
}
GCPtrAtom
*
atoms
(
)
{
if
(
!
natoms_
)
return
nullptr
;
return
reinterpret_cast
<
GCPtrAtom
*
>
(
data
(
)
)
;
}
uint32_t
codeLength
(
)
const
{
return
codeLength_
;
}
jsbytecode
*
code
(
)
{
return
reinterpret_cast
<
jsbytecode
*
>
(
data
(
)
+
natoms_
*
sizeof
(
GCPtrAtom
)
)
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
private
:
SharedScriptData
(
)
=
delete
;
SharedScriptData
(
const
SharedScriptData
&
)
=
delete
;
SharedScriptData
&
operator
=
(
const
SharedScriptData
&
)
=
delete
;
}
;
struct
ScriptBytecodeHasher
{
struct
Lookup
{
const
uint8_t
*
data
;
uint32_t
length
;
explicit
Lookup
(
SharedScriptData
*
ssd
)
:
data
(
ssd
-
>
data
(
)
)
length
(
ssd
-
>
dataLength
(
)
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
mozilla
:
:
HashBytes
(
l
.
data
l
.
length
)
;
}
static
bool
match
(
SharedScriptData
*
entry
const
Lookup
&
lookup
)
{
if
(
entry
-
>
dataLength
(
)
!
=
lookup
.
length
)
return
false
;
return
mozilla
:
:
PodEqual
<
uint8_t
>
(
entry
-
>
data
(
)
lookup
.
data
lookup
.
length
)
;
}
}
;
typedef
HashSet
<
SharedScriptData
*
ScriptBytecodeHasher
SystemAllocPolicy
>
ScriptDataTable
;
extern
void
SweepScriptData
(
JSRuntime
*
rt
AutoLockForExclusiveAccess
&
lock
)
;
extern
void
FreeScriptData
(
JSRuntime
*
rt
AutoLockForExclusiveAccess
&
lock
)
;
}
class
JSScript
:
public
js
:
:
gc
:
:
TenuredCell
{
template
<
js
:
:
XDRMode
mode
>
friend
bool
js
:
:
XDRScript
(
js
:
:
XDRState
<
mode
>
*
xdr
js
:
:
HandleScope
enclosingScope
js
:
:
HandleScript
enclosingScript
js
:
:
HandleFunction
fun
js
:
:
MutableHandleScript
scriptp
)
;
friend
bool
js
:
:
detail
:
:
CopyScript
(
JSContext
*
cx
js
:
:
HandleScript
src
js
:
:
HandleScript
dst
js
:
:
MutableHandle
<
JS
:
:
GCVector
<
js
:
:
Scope
*
>
>
scopes
)
;
private
:
js
:
:
SharedScriptData
*
scriptData_
;
public
:
uint8_t
*
data
;
JSCompartment
*
compartment_
;
private
:
js
:
:
TypeScript
*
types_
;
js
:
:
GCPtrObject
sourceObject_
;
js
:
:
jit
:
:
IonScript
*
ion
;
js
:
:
jit
:
:
BaselineScript
*
baseline
;
js
:
:
LazyScript
*
lazyScript
;
uint8_t
*
baselineOrIonRaw
;
uint8_t
*
baselineOrIonSkipArgCheck
;
uint32_t
dataSize_
;
uint32_t
lineno_
;
uint32_t
column_
;
uint32_t
mainOffset_
;
uint32_t
nfixed_
;
uint32_t
nslots_
;
uint32_t
bodyScopeIndex_
;
uint32_t
sourceStart_
;
uint32_t
sourceEnd_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
warmUpCount
;
uint16_t
warmUpResetCount
;
uint16_t
version
;
uint16_t
funLength_
;
uint16_t
nTypeSets_
;
public
:
enum
ArrayKind
{
CONSTS
OBJECTS
TRYNOTES
SCOPENOTES
ARRAY_KIND_BITS
}
;
private
:
uint8_t
hasArrayBits
:
ARRAY_KIND_BITS
;
uint8_t
generatorKindBits_
:
2
;
bool
noScriptRval_
:
1
;
bool
strict_
:
1
;
bool
explicitUseStrict_
:
1
;
bool
hasNonSyntacticScope_
:
1
;
bool
selfHosted_
:
1
;
bool
bindingsAccessedDynamically_
:
1
;
bool
funHasExtensibleScope_
:
1
;
bool
funHasAnyAliasedFormal_
:
1
;
bool
warnedAboutUndefinedProp_
:
1
;
bool
hasSingletons_
:
1
;
bool
treatAsRunOnce_
:
1
;
bool
hasRunOnce_
:
1
;
bool
hasBeenCloned_
:
1
;
bool
isActiveEval_
:
1
;
bool
isCachedEval_
:
1
;
bool
isLikelyConstructorWrapper_
:
1
;
bool
failedBoundsCheck_
:
1
;
bool
failedShapeGuard_
:
1
;
bool
hadFrequentBailouts_
:
1
;
bool
hadOverflowBailout_
:
1
;
bool
uninlineable_
:
1
;
bool
invalidatedIdempotentCache_
:
1
;
bool
failedLexicalCheck_
:
1
;
bool
isGeneratorExp_
:
1
;
bool
hasScriptCounts_
:
1
;
bool
hasDebugScript_
:
1
;
bool
hasFreezeConstraints_
:
1
;
bool
argsHasVarBinding_
:
1
;
bool
needsArgsAnalysis_
:
1
;
bool
needsArgsObj_
:
1
;
bool
functionHasThisBinding_
:
1
;
bool
functionHasExtraBodyVarScope_
:
1
;
bool
hasMappedArgsObj_
:
1
;
bool
typesGeneration_
:
1
;
bool
doNotRelazify_
:
1
;
bool
hasInnerFunctions_
:
1
;
bool
needsHomeObject_
:
1
;
bool
isDerivedClassConstructor_
:
1
;
bool
isDefaultClassConstructor_
:
1
;
protected
:
#
if
JS_BITS_PER_WORD
=
=
32
#
endif
public
:
static
JSScript
*
Create
(
js
:
:
ExclusiveContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
js
:
:
HandleObject
sourceObject
uint32_t
sourceStart
uint32_t
sourceEnd
)
;
void
initCompartment
(
js
:
:
ExclusiveContext
*
cx
)
;
static
bool
partiallyInit
(
js
:
:
ExclusiveContext
*
cx
JS
:
:
Handle
<
JSScript
*
>
script
uint32_t
nscopes
uint32_t
nconsts
uint32_t
nobjects
uint32_t
ntrynotes
uint32_t
nscopenotes
uint32_t
nyieldoffsets
uint32_t
nTypeSets
)
;
private
:
static
void
initFromFunctionBox
(
js
:
:
ExclusiveContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
FunctionBox
*
funbox
)
;
static
void
initFromModuleContext
(
js
:
:
ExclusiveContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
ModuleSharedContext
*
modulesc
)
;
public
:
static
bool
fullyInitFromEmitter
(
js
:
:
ExclusiveContext
*
cx
js
:
:
HandleScript
script
js
:
:
frontend
:
:
BytecodeEmitter
*
bce
)
;
static
bool
initFunctionPrototype
(
js
:
:
ExclusiveContext
*
cx
js
:
:
HandleScript
script
JS
:
:
HandleFunction
functionProto
)
;
#
ifdef
DEBUG
private
:
void
assertValidJumpTargets
(
)
const
;
#
endif
public
:
inline
JSPrincipals
*
principals
(
)
;
JSCompartment
*
compartment
(
)
const
{
return
compartment_
;
}
JSCompartment
*
maybeCompartment
(
)
const
{
return
compartment
(
)
;
}
void
setVersion
(
JSVersion
v
)
{
version
=
v
;
}
js
:
:
SharedScriptData
*
scriptData
(
)
{
return
scriptData_
;
}
jsbytecode
*
code
(
)
const
{
if
(
!
scriptData_
)
return
nullptr
;
return
scriptData_
-
>
code
(
)
;
}
size_t
length
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
codeLength
(
)
;
}
jsbytecode
*
codeEnd
(
)
const
{
return
code
(
)
+
length
(
)
;
}
jsbytecode
*
lastPC
(
)
const
{
jsbytecode
*
pc
=
codeEnd
(
)
-
js
:
:
JSOP_RETRVAL_LENGTH
;
MOZ_ASSERT
(
*
pc
=
=
JSOP_RETRVAL
)
;
return
pc
;
}
bool
containsPC
(
const
jsbytecode
*
pc
)
const
{
return
pc
>
=
code
(
)
&
&
pc
<
codeEnd
(
)
;
}
size_t
pcToOffset
(
const
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
)
;
return
size_t
(
pc
-
code
(
)
)
;
}
jsbytecode
*
offsetToPC
(
size_t
offset
)
const
{
MOZ_ASSERT
(
offset
<
length
(
)
)
;
return
code
(
)
+
offset
;
}
size_t
mainOffset
(
)
const
{
return
mainOffset_
;
}
size_t
lineno
(
)
const
{
return
lineno_
;
}
size_t
column
(
)
const
{
return
column_
;
}
void
setColumn
(
size_t
column
)
{
column_
=
column
;
}
size_t
nfixed
(
)
const
{
return
nfixed_
;
}
size_t
numAlwaysLiveFixedSlots
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
return
0
;
}
size_t
calculateLiveFixed
(
jsbytecode
*
pc
)
;
size_t
nslots
(
)
const
{
return
nslots_
;
}
unsigned
numArgs
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
numPositionalFormalParameters
(
)
;
return
0
;
}
inline
js
:
:
Shape
*
initialEnvironmentShape
(
)
const
;
bool
functionHasParameterExprs
(
)
const
{
js
:
:
Scope
*
scope
=
bodyScope
(
)
;
if
(
!
scope
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
false
;
return
scope
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
hasParameterExprs
(
)
;
}
size_t
nTypeSets
(
)
const
{
return
nTypeSets_
;
}
size_t
funLength
(
)
const
{
return
funLength_
;
}
size_t
sourceStart
(
)
const
{
return
sourceStart_
;
}
size_t
sourceEnd
(
)
const
{
return
sourceEnd_
;
}
bool
noScriptRval
(
)
const
{
return
noScriptRval_
;
}
bool
strict
(
)
const
{
return
strict_
;
}
bool
explicitUseStrict
(
)
const
{
return
explicitUseStrict_
;
}
bool
hasNonSyntacticScope
(
)
const
{
return
hasNonSyntacticScope_
;
}
bool
selfHosted
(
)
const
{
return
selfHosted_
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
bindingsAccessedDynamically_
;
}
bool
funHasExtensibleScope
(
)
const
{
return
funHasExtensibleScope_
;
}
bool
funHasAnyAliasedFormal
(
)
const
{
return
funHasAnyAliasedFormal_
;
}
bool
hasSingletons
(
)
const
{
return
hasSingletons_
;
}
bool
treatAsRunOnce
(
)
const
{
return
treatAsRunOnce_
;
}
bool
hasRunOnce
(
)
const
{
return
hasRunOnce_
;
}
bool
hasBeenCloned
(
)
const
{
return
hasBeenCloned_
;
}
void
setTreatAsRunOnce
(
)
{
treatAsRunOnce_
=
true
;
}
void
setHasRunOnce
(
)
{
hasRunOnce_
=
true
;
}
void
setHasBeenCloned
(
)
{
hasBeenCloned_
=
true
;
}
bool
isActiveEval
(
)
const
{
return
isActiveEval_
;
}
bool
isCachedEval
(
)
const
{
return
isCachedEval_
;
}
void
cacheForEval
(
)
{
MOZ_ASSERT
(
isActiveEval
(
)
&
&
!
isCachedEval
(
)
)
;
isActiveEval_
=
false
;
isCachedEval_
=
true
;
hasRunOnce_
=
false
;
}
void
uncacheForEval
(
)
{
MOZ_ASSERT
(
isCachedEval
(
)
&
&
!
isActiveEval
(
)
)
;
isCachedEval_
=
false
;
isActiveEval_
=
true
;
}
void
setActiveEval
(
)
{
isActiveEval_
=
true
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
isLikelyConstructorWrapper_
;
}
void
setLikelyConstructorWrapper
(
)
{
isLikelyConstructorWrapper_
=
true
;
}
bool
isGeneratorExp
(
)
const
{
return
isGeneratorExp_
;
}
bool
failedBoundsCheck
(
)
const
{
return
failedBoundsCheck_
;
}
bool
failedShapeGuard
(
)
const
{
return
failedShapeGuard_
;
}
bool
hadFrequentBailouts
(
)
const
{
return
hadFrequentBailouts_
;
}
bool
hadOverflowBailout
(
)
const
{
return
hadOverflowBailout_
;
}
bool
uninlineable
(
)
const
{
return
uninlineable_
;
}
bool
invalidatedIdempotentCache
(
)
const
{
return
invalidatedIdempotentCache_
;
}
bool
failedLexicalCheck
(
)
const
{
return
failedLexicalCheck_
;
}
bool
isDefaultClassConstructor
(
)
const
{
return
isDefaultClassConstructor_
;
}
void
setFailedBoundsCheck
(
)
{
failedBoundsCheck_
=
true
;
}
void
setFailedShapeGuard
(
)
{
failedShapeGuard_
=
true
;
}
void
setHadFrequentBailouts
(
)
{
hadFrequentBailouts_
=
true
;
}
void
setHadOverflowBailout
(
)
{
hadOverflowBailout_
=
true
;
}
void
setUninlineable
(
)
{
uninlineable_
=
true
;
}
void
setInvalidatedIdempotentCache
(
)
{
invalidatedIdempotentCache_
=
true
;
}
void
setFailedLexicalCheck
(
)
{
failedLexicalCheck_
=
true
;
}
void
setIsDefaultClassConstructor
(
)
{
isDefaultClassConstructor_
=
true
;
}
bool
hasScriptCounts
(
)
const
{
return
hasScriptCounts_
;
}
bool
hasFreezeConstraints
(
)
const
{
return
hasFreezeConstraints_
;
}
void
setHasFreezeConstraints
(
)
{
hasFreezeConstraints_
=
true
;
}
bool
warnedAboutUndefinedProp
(
)
const
{
return
warnedAboutUndefinedProp_
;
}
void
setWarnedAboutUndefinedProp
(
)
{
warnedAboutUndefinedProp_
=
true
;
}
bool
argumentsHasVarBinding
(
)
const
{
return
argsHasVarBinding_
;
}
void
setArgumentsHasVarBinding
(
)
;
bool
argumentsAliasesFormals
(
)
const
{
return
argumentsHasVarBinding
(
)
&
&
hasMappedArgsObj
(
)
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
return
js
:
:
GeneratorKindFromBits
(
generatorKindBits_
)
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
js
:
:
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
StarGenerator
;
}
void
setGeneratorKind
(
js
:
:
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
generatorKindBits_
=
GeneratorKindAsBits
(
kind
)
;
}
void
setNeedsHomeObject
(
)
{
needsHomeObject_
=
true
;
}
bool
needsHomeObject
(
)
const
{
return
needsHomeObject_
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
isDerivedClassConstructor_
;
}
bool
analyzedArgsUsage
(
)
const
{
return
!
needsArgsAnalysis_
;
}
inline
bool
ensureHasAnalyzedArgsUsage
(
JSContext
*
cx
)
;
bool
needsArgsObj
(
)
const
{
MOZ_ASSERT
(
analyzedArgsUsage
(
)
)
;
return
needsArgsObj_
;
}
void
setNeedsArgsObj
(
bool
needsArgsObj
)
;
static
bool
argumentsOptimizationFailed
(
JSContext
*
cx
js
:
:
HandleScript
script
)
;
bool
hasMappedArgsObj
(
)
const
{
return
hasMappedArgsObj_
;
}
bool
functionHasThisBinding
(
)
const
{
return
functionHasThisBinding_
;
}
bool
argsObjAliasesFormals
(
)
const
{
return
needsArgsObj
(
)
&
&
hasMappedArgsObj
(
)
;
}
uint32_t
typesGeneration
(
)
const
{
return
(
uint32_t
)
typesGeneration_
;
}
void
setTypesGeneration
(
uint32_t
generation
)
{
MOZ_ASSERT
(
generation
<
=
1
)
;
typesGeneration_
=
(
bool
)
generation
;
}
void
setDoNotRelazify
(
bool
b
)
{
doNotRelazify_
=
b
;
}
void
setHasInnerFunctions
(
bool
b
)
{
hasInnerFunctions_
=
b
;
}
bool
hasInnerFunctions
(
)
const
{
return
hasInnerFunctions_
;
}
bool
hasAnyIonScript
(
)
const
{
return
hasIonScript
(
)
;
}
bool
hasIonScript
(
)
const
{
bool
res
=
ion
&
&
ion
!
=
ION_DISABLED_SCRIPT
&
&
ion
!
=
ION_COMPILING_SCRIPT
&
&
ion
!
=
ION_PENDING_SCRIPT
;
MOZ_ASSERT_IF
(
res
baseline
)
;
return
res
;
}
bool
canIonCompile
(
)
const
{
return
ion
!
=
ION_DISABLED_SCRIPT
;
}
bool
isIonCompilingOffThread
(
)
const
{
return
ion
=
=
ION_COMPILING_SCRIPT
;
}
js
:
:
jit
:
:
IonScript
*
ionScript
(
)
const
{
MOZ_ASSERT
(
hasIonScript
(
)
)
;
return
ion
;
}
js
:
:
jit
:
:
IonScript
*
maybeIonScript
(
)
const
{
return
ion
;
}
js
:
:
jit
:
:
IonScript
*
const
*
addressOfIonScript
(
)
const
{
return
&
ion
;
}
void
setIonScript
(
JSRuntime
*
maybeRuntime
js
:
:
jit
:
:
IonScript
*
ionScript
)
;
bool
hasBaselineScript
(
)
const
{
bool
res
=
baseline
&
&
baseline
!
=
BASELINE_DISABLED_SCRIPT
;
MOZ_ASSERT_IF
(
!
res
!
ion
|
|
ion
=
=
ION_DISABLED_SCRIPT
)
;
return
res
;
}
bool
canBaselineCompile
(
)
const
{
return
baseline
!
=
BASELINE_DISABLED_SCRIPT
;
}
js
:
:
jit
:
:
BaselineScript
*
baselineScript
(
)
const
{
MOZ_ASSERT
(
hasBaselineScript
(
)
)
;
return
baseline
;
}
inline
void
setBaselineScript
(
JSRuntime
*
maybeRuntime
js
:
:
jit
:
:
BaselineScript
*
baselineScript
)
;
void
updateBaselineOrIonRaw
(
JSRuntime
*
maybeRuntime
)
;
static
size_t
offsetOfBaselineScript
(
)
{
return
offsetof
(
JSScript
baseline
)
;
}
static
size_t
offsetOfIonScript
(
)
{
return
offsetof
(
JSScript
ion
)
;
}
static
size_t
offsetOfBaselineOrIonRaw
(
)
{
return
offsetof
(
JSScript
baselineOrIonRaw
)
;
}
uint8_t
*
baselineOrIonRawPointer
(
)
const
{
return
baselineOrIonRaw
;
}
static
size_t
offsetOfBaselineOrIonSkipArgCheck
(
)
{
return
offsetof
(
JSScript
baselineOrIonSkipArgCheck
)
;
}
bool
isRelazifiable
(
)
const
{
return
(
selfHosted
(
)
|
|
lazyScript
)
&
&
!
hasInnerFunctions_
&
&
!
types_
&
&
!
isGenerator
(
)
&
&
!
hasBaselineScript
(
)
&
&
!
hasAnyIonScript
(
)
&
&
!
doNotRelazify_
;
}
void
setLazyScript
(
js
:
:
LazyScript
*
lazy
)
{
lazyScript
=
lazy
;
}
js
:
:
LazyScript
*
maybeLazyScript
(
)
{
return
lazyScript
;
}
inline
JSFunction
*
functionDelazifying
(
)
const
;
JSFunction
*
functionNonDelazifying
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
FunctionScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
return
nullptr
;
}
inline
void
ensureNonLazyCanonicalFunction
(
JSContext
*
cx
)
;
js
:
:
ModuleObject
*
module
(
)
const
{
if
(
bodyScope
(
)
-
>
is
<
js
:
:
ModuleScope
>
(
)
)
return
bodyScope
(
)
-
>
as
<
js
:
:
ModuleScope
>
(
)
.
module
(
)
;
return
nullptr
;
}
bool
isGlobalOrEvalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
|
|
bodyScope
(
)
-
>
is
<
js
:
:
EvalScope
>
(
)
;
}
bool
isGlobalCode
(
)
const
{
return
bodyScope
(
)
-
>
is
<
js
:
:
GlobalScope
>
(
)
;
}
bool
mayReadFrameArgsDirectly
(
)
;
JSFlatString
*
sourceData
(
JSContext
*
cx
)
;
static
bool
loadSource
(
JSContext
*
cx
js
:
:
ScriptSource
*
ss
bool
*
worked
)
;
void
setSourceObject
(
JSObject
*
object
)
;
JSObject
*
sourceObject
(
)
const
{
return
sourceObject_
;
}
js
:
:
ScriptSourceObject
&
scriptSourceUnwrap
(
)
const
;
js
:
:
ScriptSource
*
scriptSource
(
)
const
;
js
:
:
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
const
char
*
maybeForwardedFilename
(
)
const
{
return
maybeForwardedScriptSource
(
)
-
>
filename
(
)
;
}
public
:
bool
isForEval
(
)
const
{
MOZ_ASSERT_IF
(
isCachedEval
(
)
|
|
isActiveEval
(
)
bodyScope
(
)
-
>
is
<
js
:
:
EvalScope
>
(
)
)
;
return
isCachedEval
(
)
|
|
isActiveEval
(
)
;
}
bool
isDirectEvalInFunction
(
)
const
{
if
(
!
isForEval
(
)
)
return
false
;
return
bodyScope
(
)
-
>
hasOnChain
(
js
:
:
ScopeKind
:
:
Function
)
;
}
bool
isTopLevel
(
)
{
return
code
(
)
&
&
!
functionNonDelazifying
(
)
;
}
inline
bool
ensureHasTypes
(
JSContext
*
cx
)
;
inline
js
:
:
TypeScript
*
types
(
)
;
void
maybeSweepTypes
(
js
:
:
AutoClearTypeInferenceStateOnOOM
*
oom
)
;
inline
js
:
:
GlobalObject
&
global
(
)
const
;
js
:
:
GlobalObject
&
uninlinedGlobal
(
)
const
;
uint32_t
bodyScopeIndex
(
)
const
{
return
bodyScopeIndex_
;
}
js
:
:
Scope
*
bodyScope
(
)
const
{
return
getScope
(
bodyScopeIndex_
)
;
}
js
:
:
Scope
*
outermostScope
(
)
const
{
size_t
index
=
0
;
return
getScope
(
index
)
;
}
bool
functionHasExtraBodyVarScope
(
)
const
{
MOZ_ASSERT_IF
(
functionHasExtraBodyVarScope_
functionHasParameterExprs
(
)
)
;
return
functionHasExtraBodyVarScope_
;
}
js
:
:
VarScope
*
functionExtraBodyVarScope
(
)
const
{
MOZ_ASSERT
(
functionHasExtraBodyVarScope
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
scopes
(
)
-
>
length
;
i
+
+
)
{
js
:
:
Scope
*
scope
=
getScope
(
i
)
;
if
(
scope
-
>
kind
(
)
=
=
js
:
:
ScopeKind
:
:
FunctionBodyVar
)
return
&
scope
-
>
as
<
js
:
:
VarScope
>
(
)
;
}
MOZ_CRASH
(
"
Function
extra
body
var
scope
not
found
"
)
;
}
inline
js
:
:
LexicalScope
*
maybeNamedLambdaScope
(
)
const
;
js
:
:
Scope
*
enclosingScope
(
)
const
{
return
outermostScope
(
)
-
>
enclosing
(
)
;
}
private
:
bool
makeTypes
(
JSContext
*
cx
)
;
bool
createScriptData
(
js
:
:
ExclusiveContext
*
cx
uint32_t
codeLength
uint32_t
srcnotesLength
uint32_t
natoms
)
;
bool
shareScriptData
(
js
:
:
ExclusiveContext
*
cx
)
;
void
freeScriptData
(
)
;
void
setScriptData
(
js
:
:
SharedScriptData
*
data
)
;
public
:
uint32_t
getWarmUpCount
(
)
const
{
return
warmUpCount
;
}
uint32_t
incWarmUpCounter
(
uint32_t
amount
=
1
)
{
return
warmUpCount
+
=
amount
;
}
uint32_t
*
addressOfWarmUpCounter
(
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
&
warmUpCount
)
;
}
static
size_t
offsetOfWarmUpCounter
(
)
{
return
offsetof
(
JSScript
warmUpCount
)
;
}
void
resetWarmUpCounter
(
)
{
incWarmUpResetCounter
(
)
;
warmUpCount
=
0
;
}
uint16_t
getWarmUpResetCount
(
)
const
{
return
warmUpResetCount
;
}
uint16_t
incWarmUpResetCounter
(
uint16_t
amount
=
1
)
{
return
warmUpResetCount
+
=
amount
;
}
void
resetWarmUpResetCounter
(
)
{
warmUpResetCount
=
0
;
}
public
:
bool
initScriptCounts
(
JSContext
*
cx
)
;
js
:
:
ScriptCounts
&
getScriptCounts
(
)
;
js
:
:
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
;
const
js
:
:
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
;
js
:
:
PCCounts
*
getThrowCounts
(
jsbytecode
*
pc
)
;
uint64_t
getHitCount
(
jsbytecode
*
pc
)
;
void
incHitCount
(
jsbytecode
*
pc
)
;
void
addIonCounts
(
js
:
:
jit
:
:
IonScriptCounts
*
ionCounts
)
;
js
:
:
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
;
void
releaseScriptCounts
(
js
:
:
ScriptCounts
*
counts
)
;
void
destroyScriptCounts
(
js
:
:
FreeOp
*
fop
)
;
void
takeOverScriptCountsMapEntry
(
js
:
:
ScriptCounts
*
entryValue
)
;
jsbytecode
*
main
(
)
const
{
return
code
(
)
+
mainOffset
(
)
;
}
size_t
computedSizeOfData
(
)
const
;
size_t
sizeOfData
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfTypeScript
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
uint32_t
numNotes
(
)
;
jssrcnote
*
notes
(
)
{
return
(
jssrcnote
*
)
(
code
(
)
+
length
(
)
)
;
}
bool
hasArray
(
ArrayKind
kind
)
const
{
return
hasArrayBits
&
(
1
<
<
kind
)
;
}
void
setHasArray
(
ArrayKind
kind
)
{
hasArrayBits
|
=
(
1
<
<
kind
)
;
}
void
cloneHasArray
(
JSScript
*
script
)
{
hasArrayBits
=
script
-
>
hasArrayBits
;
}
bool
hasConsts
(
)
const
{
return
hasArray
(
CONSTS
)
;
}
bool
hasObjects
(
)
const
{
return
hasArray
(
OBJECTS
)
;
}
bool
hasTrynotes
(
)
const
{
return
hasArray
(
TRYNOTES
)
;
}
bool
hasScopeNotes
(
)
const
{
return
hasArray
(
SCOPENOTES
)
;
}
bool
hasYieldOffsets
(
)
const
{
return
isGenerator
(
)
;
}
#
define
OFF
(
fooOff
hasFoo
t
)
(
fooOff
(
)
+
(
hasFoo
(
)
?
sizeof
(
t
)
:
0
)
)
size_t
scopesOffset
(
)
const
{
return
0
;
}
size_t
constsOffset
(
)
const
{
return
scopesOffset
(
)
+
sizeof
(
js
:
:
ScopeArray
)
;
}
size_t
objectsOffset
(
)
const
{
return
OFF
(
constsOffset
hasConsts
js
:
:
ConstArray
)
;
}
size_t
trynotesOffset
(
)
const
{
return
OFF
(
objectsOffset
hasObjects
js
:
:
ObjectArray
)
;
}
size_t
scopeNotesOffset
(
)
const
{
return
OFF
(
trynotesOffset
hasTrynotes
js
:
:
TryNoteArray
)
;
}
size_t
yieldOffsetsOffset
(
)
const
{
return
OFF
(
scopeNotesOffset
hasScopeNotes
js
:
:
ScopeNoteArray
)
;
}
#
undef
OFF
size_t
dataSize
(
)
const
{
return
dataSize_
;
}
js
:
:
ConstArray
*
consts
(
)
{
MOZ_ASSERT
(
hasConsts
(
)
)
;
return
reinterpret_cast
<
js
:
:
ConstArray
*
>
(
data
+
constsOffset
(
)
)
;
}
js
:
:
ObjectArray
*
objects
(
)
{
MOZ_ASSERT
(
hasObjects
(
)
)
;
return
reinterpret_cast
<
js
:
:
ObjectArray
*
>
(
data
+
objectsOffset
(
)
)
;
}
js
:
:
ScopeArray
*
scopes
(
)
const
{
return
reinterpret_cast
<
js
:
:
ScopeArray
*
>
(
data
+
scopesOffset
(
)
)
;
}
js
:
:
TryNoteArray
*
trynotes
(
)
const
{
MOZ_ASSERT
(
hasTrynotes
(
)
)
;
return
reinterpret_cast
<
js
:
:
TryNoteArray
*
>
(
data
+
trynotesOffset
(
)
)
;
}
js
:
:
ScopeNoteArray
*
scopeNotes
(
)
{
MOZ_ASSERT
(
hasScopeNotes
(
)
)
;
return
reinterpret_cast
<
js
:
:
ScopeNoteArray
*
>
(
data
+
scopeNotesOffset
(
)
)
;
}
js
:
:
YieldOffsetArray
&
yieldOffsets
(
)
{
MOZ_ASSERT
(
hasYieldOffsets
(
)
)
;
return
*
reinterpret_cast
<
js
:
:
YieldOffsetArray
*
>
(
data
+
yieldOffsetsOffset
(
)
)
;
}
bool
hasLoops
(
)
;
size_t
natoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
natoms
(
)
;
}
js
:
:
GCPtrAtom
*
atoms
(
)
const
{
MOZ_ASSERT
(
scriptData_
)
;
return
scriptData_
-
>
atoms
(
)
;
}
js
:
:
GCPtrAtom
&
getAtom
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
natoms
(
)
)
;
return
atoms
(
)
[
index
]
;
}
js
:
:
GCPtrAtom
&
getAtom
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
return
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
PropertyName
*
getName
(
size_t
index
)
{
return
getAtom
(
index
)
-
>
asPropertyName
(
)
;
}
js
:
:
PropertyName
*
getName
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
return
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
-
>
asPropertyName
(
)
;
}
JSObject
*
getObject
(
size_t
index
)
{
js
:
:
ObjectArray
*
arr
=
objects
(
)
;
MOZ_ASSERT
(
index
<
arr
-
>
length
)
;
MOZ_ASSERT
(
arr
-
>
vector
[
index
]
-
>
isTenured
(
)
)
;
return
arr
-
>
vector
[
index
]
;
}
JSObject
*
getObject
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
return
getObject
(
GET_UINT32_INDEX
(
pc
)
)
;
}
js
:
:
Scope
*
getScope
(
size_t
index
)
const
{
js
:
:
ScopeArray
*
array
=
scopes
(
)
;
MOZ_ASSERT
(
index
<
array
-
>
length
)
;
return
array
-
>
vector
[
index
]
;
}
js
:
:
Scope
*
getScope
(
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
containsPC
(
pc
)
&
&
containsPC
(
pc
+
sizeof
(
uint32_t
)
)
)
;
MOZ_ASSERT
(
js
:
:
JOF_OPTYPE
(
JSOp
(
*
pc
)
)
=
=
JOF_SCOPE
"
Did
you
mean
to
use
lookupScope
(
pc
)
?
"
)
;
return
getScope
(
GET_UINT32_INDEX
(
pc
)
)
;
}
JSVersion
getVersion
(
)
const
{
return
JSVersion
(
version
)
;
}
inline
JSFunction
*
getFunction
(
size_t
index
)
;
JSFunction
*
function
(
)
const
{
if
(
functionNonDelazifying
(
)
)
return
functionNonDelazifying
(
)
;
return
nullptr
;
}
inline
js
:
:
RegExpObject
*
getRegExp
(
size_t
index
)
;
inline
js
:
:
RegExpObject
*
getRegExp
(
jsbytecode
*
pc
)
;
const
js
:
:
Value
&
getConst
(
size_t
index
)
{
js
:
:
ConstArray
*
arr
=
consts
(
)
;
MOZ_ASSERT
(
index
<
arr
-
>
length
)
;
return
arr
-
>
vector
[
index
]
;
}
js
:
:
Scope
*
lookupScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
jsbytecode
*
pc
)
;
js
:
:
Scope
*
innermostScope
(
)
{
return
innermostScope
(
main
(
)
)
;
}
bool
isEmpty
(
)
const
{
if
(
length
(
)
>
3
)
return
false
;
jsbytecode
*
pc
=
code
(
)
;
if
(
noScriptRval
(
)
&
&
JSOp
(
*
pc
)
=
=
JSOP_FALSE
)
+
+
pc
;
return
JSOp
(
*
pc
)
=
=
JSOP_RETRVAL
;
}
bool
formalIsAliased
(
unsigned
argSlot
)
;
bool
formalLivesInArgumentsObject
(
unsigned
argSlot
)
;
private
:
void
setNewStepMode
(
js
:
:
FreeOp
*
fop
uint32_t
newValue
)
;
bool
ensureHasDebugScript
(
JSContext
*
cx
)
;
js
:
:
DebugScript
*
debugScript
(
)
;
js
:
:
DebugScript
*
releaseDebugScript
(
)
;
void
destroyDebugScript
(
js
:
:
FreeOp
*
fop
)
;
public
:
bool
hasBreakpointsAt
(
jsbytecode
*
pc
)
;
bool
hasAnyBreakpointsOrStepMode
(
)
{
return
hasDebugScript_
;
}
inline
bool
isDebuggee
(
)
const
;
js
:
:
BreakpointSite
*
getBreakpointSite
(
jsbytecode
*
pc
)
{
return
hasDebugScript_
?
debugScript
(
)
-
>
breakpoints
[
pcToOffset
(
pc
)
]
:
nullptr
;
}
js
:
:
BreakpointSite
*
getOrCreateBreakpointSite
(
JSContext
*
cx
jsbytecode
*
pc
)
;
void
destroyBreakpointSite
(
js
:
:
FreeOp
*
fop
jsbytecode
*
pc
)
;
void
clearBreakpointsIn
(
js
:
:
FreeOp
*
fop
js
:
:
Debugger
*
dbg
JSObject
*
handler
)
;
bool
incrementStepModeCount
(
JSContext
*
cx
)
;
void
decrementStepModeCount
(
js
:
:
FreeOp
*
fop
)
;
bool
stepModeEnabled
(
)
{
return
hasDebugScript_
&
&
!
!
debugScript
(
)
-
>
stepMode
;
}
#
ifdef
DEBUG
uint32_t
stepModeCount
(
)
{
return
hasDebugScript_
?
debugScript
(
)
-
>
stepMode
:
0
;
}
#
endif
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
Script
;
void
traceChildren
(
JSTracer
*
trc
)
;
class
AutoDelazify
;
friend
class
AutoDelazify
;
class
AutoDelazify
{
JS
:
:
RootedScript
script_
;
JSContext
*
cx_
;
bool
oldDoNotRelazify_
;
public
:
explicit
AutoDelazify
(
JSContext
*
cx
JS
:
:
HandleFunction
fun
=
nullptr
)
:
script_
(
cx
)
cx_
(
cx
)
{
holdScript
(
fun
)
;
}
~
AutoDelazify
(
)
{
dropScript
(
)
;
}
void
operator
=
(
JS
:
:
HandleFunction
fun
)
{
dropScript
(
)
;
holdScript
(
fun
)
;
}
operator
JS
:
:
HandleScript
(
)
const
{
return
script_
;
}
explicit
operator
bool
(
)
const
{
return
script_
;
}
private
:
void
holdScript
(
JS
:
:
HandleFunction
fun
)
;
void
dropScript
(
)
;
}
;
}
;
static_assert
(
sizeof
(
JSScript
)
%
js
:
:
gc
:
:
CellSize
=
=
0
"
Size
of
JSScript
must
be
an
integral
multiple
of
js
:
:
gc
:
:
CellSize
"
)
;
namespace
js
{
class
LazyScript
:
public
gc
:
:
TenuredCell
{
private
:
WeakRef
<
JSScript
*
>
script_
;
GCPtrFunction
function_
;
GCPtrScope
enclosingScope_
;
GCPtrObject
sourceObject_
;
void
*
table_
;
protected
:
#
if
JS_BITS_PER_WORD
=
=
32
uint32_t
padding
;
#
endif
private
:
struct
PackedView
{
uint32_t
version
:
8
;
uint32_t
shouldDeclareArguments
:
1
;
uint32_t
hasThisBinding
:
1
;
uint32_t
numClosedOverBindings
:
22
;
uint32_t
numInnerFunctions
:
20
;
uint32_t
generatorKindBits
:
2
;
uint32_t
strict
:
1
;
uint32_t
bindingsAccessedDynamically
:
1
;
uint32_t
hasDebuggerStatement
:
1
;
uint32_t
hasDirectEval
:
1
;
uint32_t
isLikelyConstructorWrapper
:
1
;
uint32_t
hasBeenCloned
:
1
;
uint32_t
treatAsRunOnce
:
1
;
uint32_t
isDerivedClassConstructor
:
1
;
uint32_t
needsHomeObject
:
1
;
}
;
union
{
PackedView
p_
;
uint64_t
packedFields_
;
}
;
uint32_t
begin_
;
uint32_t
end_
;
uint32_t
lineno_
;
uint32_t
column_
;
LazyScript
(
JSFunction
*
fun
void
*
table
uint64_t
packedFields
uint32_t
begin
uint32_t
end
uint32_t
lineno
uint32_t
column
)
;
static
LazyScript
*
CreateRaw
(
ExclusiveContext
*
cx
HandleFunction
fun
uint64_t
packedData
uint32_t
begin
uint32_t
end
uint32_t
lineno
uint32_t
column
)
;
public
:
static
const
uint32_t
NumClosedOverBindingsLimit
=
1
<
<
22
;
static
const
uint32_t
NumInnerFunctionsLimit
=
1
<
<
20
;
static
LazyScript
*
Create
(
ExclusiveContext
*
cx
HandleFunction
fun
const
frontend
:
:
AtomVector
&
closedOverBindings
Handle
<
GCVector
<
JSFunction
*
8
>
>
innerFunctions
JSVersion
version
uint32_t
begin
uint32_t
end
uint32_t
lineno
uint32_t
column
)
;
static
LazyScript
*
Create
(
ExclusiveContext
*
cx
HandleFunction
fun
HandleScript
script
HandleScope
enclosingScope
HandleScript
enclosingScript
uint64_t
packedData
uint32_t
begin
uint32_t
end
uint32_t
lineno
uint32_t
column
)
;
void
initRuntimeFields
(
uint64_t
packedFields
)
;
inline
JSFunction
*
functionDelazifying
(
JSContext
*
cx
)
const
;
JSFunction
*
functionNonDelazifying
(
)
const
{
return
function_
;
}
void
initScript
(
JSScript
*
script
)
;
void
resetScript
(
)
;
JSScript
*
maybeScript
(
)
{
return
script_
;
}
const
JSScript
*
maybeScriptUnbarriered
(
)
const
{
return
script_
.
unbarrieredGet
(
)
;
}
bool
hasScript
(
)
const
{
return
bool
(
script_
)
;
}
Scope
*
enclosingScope
(
)
const
{
return
enclosingScope_
;
}
ScriptSourceObject
*
sourceObject
(
)
const
;
ScriptSource
*
scriptSource
(
)
const
{
return
sourceObject
(
)
-
>
source
(
)
;
}
ScriptSource
*
maybeForwardedScriptSource
(
)
const
;
bool
mutedErrors
(
)
const
{
return
scriptSource
(
)
-
>
mutedErrors
(
)
;
}
JSVersion
version
(
)
const
{
JS_STATIC_ASSERT
(
JSVERSION_UNKNOWN
=
=
-
1
)
;
return
(
p_
.
version
=
=
JS_BIT
(
8
)
-
1
)
?
JSVERSION_UNKNOWN
:
JSVersion
(
p_
.
version
)
;
}
void
setEnclosingScopeAndSource
(
Scope
*
enclosingScope
ScriptSourceObject
*
sourceObject
)
;
uint32_t
numClosedOverBindings
(
)
const
{
return
p_
.
numClosedOverBindings
;
}
JSAtom
*
*
closedOverBindings
(
)
{
return
(
JSAtom
*
*
)
table_
;
}
uint32_t
numInnerFunctions
(
)
const
{
return
p_
.
numInnerFunctions
;
}
GCPtrFunction
*
innerFunctions
(
)
{
return
(
GCPtrFunction
*
)
&
closedOverBindings
(
)
[
numClosedOverBindings
(
)
]
;
}
GeneratorKind
generatorKind
(
)
const
{
return
GeneratorKindFromBits
(
p_
.
generatorKindBits
)
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
StarGenerator
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
MOZ_ASSERT
(
kind
!
=
LegacyGenerator
)
;
p_
.
generatorKindBits
=
GeneratorKindAsBits
(
kind
)
;
}
bool
strict
(
)
const
{
return
p_
.
strict
;
}
void
setStrict
(
)
{
p_
.
strict
=
true
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
p_
.
bindingsAccessedDynamically
;
}
void
setBindingsAccessedDynamically
(
)
{
p_
.
bindingsAccessedDynamically
=
true
;
}
bool
hasDebuggerStatement
(
)
const
{
return
p_
.
hasDebuggerStatement
;
}
void
setHasDebuggerStatement
(
)
{
p_
.
hasDebuggerStatement
=
true
;
}
bool
hasDirectEval
(
)
const
{
return
p_
.
hasDirectEval
;
}
void
setHasDirectEval
(
)
{
p_
.
hasDirectEval
=
true
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
p_
.
isLikelyConstructorWrapper
;
}
void
setLikelyConstructorWrapper
(
)
{
p_
.
isLikelyConstructorWrapper
=
true
;
}
bool
hasBeenCloned
(
)
const
{
return
p_
.
hasBeenCloned
;
}
void
setHasBeenCloned
(
)
{
p_
.
hasBeenCloned
=
true
;
}
bool
treatAsRunOnce
(
)
const
{
return
p_
.
treatAsRunOnce
;
}
void
setTreatAsRunOnce
(
)
{
p_
.
treatAsRunOnce
=
true
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
p_
.
isDerivedClassConstructor
;
}
void
setIsDerivedClassConstructor
(
)
{
p_
.
isDerivedClassConstructor
=
true
;
}
bool
needsHomeObject
(
)
const
{
return
p_
.
needsHomeObject
;
}
void
setNeedsHomeObject
(
)
{
p_
.
needsHomeObject
=
true
;
}
bool
shouldDeclareArguments
(
)
const
{
return
p_
.
shouldDeclareArguments
;
}
void
setShouldDeclareArguments
(
)
{
p_
.
shouldDeclareArguments
=
true
;
}
bool
hasThisBinding
(
)
const
{
return
p_
.
hasThisBinding
;
}
void
setHasThisBinding
(
)
{
p_
.
hasThisBinding
=
true
;
}
const
char
*
filename
(
)
const
{
return
scriptSource
(
)
-
>
filename
(
)
;
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
uint32_t
lineno
(
)
const
{
return
lineno_
;
}
uint32_t
column
(
)
const
{
return
column_
;
}
bool
hasUncompiledEnclosingScript
(
)
const
;
friend
class
GCMarker
;
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
LazyScript
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
table_
)
;
}
uint64_t
packedFields
(
)
const
{
return
packedFields_
;
}
}
;
JS_STATIC_ASSERT
(
sizeof
(
LazyScript
)
%
js
:
:
gc
:
:
CellSize
=
=
0
)
;
struct
ScriptAndCounts
{
JSScript
*
script
;
ScriptCounts
scriptCounts
;
inline
explicit
ScriptAndCounts
(
JSScript
*
script
)
;
inline
ScriptAndCounts
(
ScriptAndCounts
&
&
sac
)
;
const
PCCounts
*
maybeGetPCCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetPCCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
const
PCCounts
*
maybeGetThrowCounts
(
jsbytecode
*
pc
)
const
{
return
scriptCounts
.
maybeGetThrowCounts
(
script
-
>
pcToOffset
(
pc
)
)
;
}
jit
:
:
IonScriptCounts
*
getIonCounts
(
)
const
{
return
scriptCounts
.
ionCounts_
;
}
void
trace
(
JSTracer
*
trc
)
{
TraceRoot
(
trc
&
script
"
ScriptAndCounts
:
:
script
"
)
;
}
}
;
struct
GSNCache
;
jssrcnote
*
GetSrcNote
(
GSNCache
&
cache
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jssrcnote
*
GetSrcNote
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
extern
jsbytecode
*
LineNumberToPC
(
JSScript
*
script
unsigned
lineno
)
;
extern
JS_FRIEND_API
(
unsigned
)
GetScriptLineExtent
(
JSScript
*
script
)
;
}
namespace
js
{
extern
unsigned
PCToLineNumber
(
JSScript
*
script
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
extern
unsigned
PCToLineNumber
(
unsigned
startLine
jssrcnote
*
notes
jsbytecode
*
code
jsbytecode
*
pc
unsigned
*
columnp
=
nullptr
)
;
enum
LineOption
{
CALLED_FROM_JSOP_EVAL
NOT_CALLED_FROM_JSOP_EVAL
}
;
extern
void
DescribeScriptedCallerForCompilation
(
JSContext
*
cx
MutableHandleScript
maybeScript
const
char
*
*
file
unsigned
*
linenop
uint32_t
*
pcOffset
bool
*
mutedErrors
LineOption
opt
=
NOT_CALLED_FROM_JSOP_EVAL
)
;
JSScript
*
CloneScriptIntoFunction
(
JSContext
*
cx
HandleScope
enclosingScope
HandleFunction
fun
HandleScript
src
)
;
JSScript
*
CloneGlobalScript
(
JSContext
*
cx
ScopeKind
scopeKind
HandleScript
src
)
;
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
LazyScript
>
:
TracerConcrete
<
js
:
:
LazyScript
>
{
protected
:
explicit
Concrete
(
js
:
:
LazyScript
*
ptr
)
:
TracerConcrete
<
js
:
:
LazyScript
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
LazyScript
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
const
char
*
scriptFilename
(
)
const
final
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
