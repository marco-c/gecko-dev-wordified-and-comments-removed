#
ifndef
jit_x64_LIR_x64_h
#
define
jit_x64_LIR_x64_h
namespace
js
{
namespace
jit
{
class
LUnboxBase
:
public
LInstructionHelper
<
1
1
0
>
{
public
:
LUnboxBase
(
LNode
:
:
Opcode
op
const
LAllocation
&
input
)
:
LInstructionHelper
<
1
1
0
>
(
op
)
{
setOperand
(
0
input
)
;
}
static
const
size_t
Input
=
0
;
MUnbox
*
mir
(
)
const
{
return
mir_
-
>
toUnbox
(
)
;
}
}
;
class
LUnbox
:
public
LUnboxBase
{
public
:
LIR_HEADER
(
Unbox
)
explicit
LUnbox
(
const
LAllocation
&
input
)
:
LUnboxBase
(
classOpcode
input
)
{
}
const
char
*
extraName
(
)
const
{
return
StringFromMIRType
(
mir
(
)
-
>
type
(
)
)
;
}
}
;
class
LUnboxFloatingPoint
:
public
LUnboxBase
{
MIRType
type_
;
public
:
LIR_HEADER
(
UnboxFloatingPoint
)
LUnboxFloatingPoint
(
const
LAllocation
&
input
MIRType
type
)
:
LUnboxBase
(
classOpcode
input
)
type_
(
type
)
{
}
MIRType
type
(
)
const
{
return
type_
;
}
const
char
*
extraName
(
)
const
{
return
StringFromMIRType
(
type_
)
;
}
}
;
class
LWasmUint32ToDouble
:
public
LInstructionHelper
<
1
1
0
>
{
public
:
LIR_HEADER
(
WasmUint32ToDouble
)
explicit
LWasmUint32ToDouble
(
const
LAllocation
&
input
)
:
LInstructionHelper
(
classOpcode
)
{
setOperand
(
0
input
)
;
}
}
;
class
LWasmUint32ToFloat32
:
public
LInstructionHelper
<
1
1
0
>
{
public
:
LIR_HEADER
(
WasmUint32ToFloat32
)
explicit
LWasmUint32ToFloat32
(
const
LAllocation
&
input
)
:
LInstructionHelper
(
classOpcode
)
{
setOperand
(
0
input
)
;
}
}
;
class
LDivOrModI64
:
public
LBinaryMath
<
1
>
{
public
:
LIR_HEADER
(
DivOrModI64
)
LDivOrModI64
(
const
LAllocation
&
lhs
const
LAllocation
&
rhs
const
LDefinition
&
temp
)
:
LBinaryMath
(
classOpcode
)
{
setOperand
(
0
lhs
)
;
setOperand
(
1
rhs
)
;
setTemp
(
0
temp
)
;
}
const
LDefinition
*
remainder
(
)
{
return
getTemp
(
0
)
;
}
MBinaryArithInstruction
*
mir
(
)
const
{
MOZ_ASSERT
(
mir_
-
>
isDiv
(
)
|
|
mir_
-
>
isMod
(
)
)
;
return
static_cast
<
MBinaryArithInstruction
*
>
(
mir_
)
;
}
bool
canBeDivideByZero
(
)
const
{
if
(
mir_
-
>
isMod
(
)
)
return
mir_
-
>
toMod
(
)
-
>
canBeDivideByZero
(
)
;
return
mir_
-
>
toDiv
(
)
-
>
canBeDivideByZero
(
)
;
}
bool
canBeNegativeOverflow
(
)
const
{
if
(
mir_
-
>
isMod
(
)
)
return
mir_
-
>
toMod
(
)
-
>
canBeNegativeDividend
(
)
;
return
mir_
-
>
toDiv
(
)
-
>
canBeNegativeOverflow
(
)
;
}
wasm
:
:
BytecodeOffset
bytecodeOffset
(
)
const
{
MOZ_ASSERT
(
mir_
-
>
isDiv
(
)
|
|
mir_
-
>
isMod
(
)
)
;
if
(
mir_
-
>
isMod
(
)
)
return
mir_
-
>
toMod
(
)
-
>
bytecodeOffset
(
)
;
return
mir_
-
>
toDiv
(
)
-
>
bytecodeOffset
(
)
;
}
}
;
class
LUDivOrModI64
:
public
LBinaryMath
<
1
>
{
public
:
LIR_HEADER
(
UDivOrModI64
)
;
LUDivOrModI64
(
const
LAllocation
&
lhs
const
LAllocation
&
rhs
const
LDefinition
&
temp
)
:
LBinaryMath
(
classOpcode
)
{
setOperand
(
0
lhs
)
;
setOperand
(
1
rhs
)
;
setTemp
(
0
temp
)
;
}
const
LDefinition
*
remainder
(
)
{
return
getTemp
(
0
)
;
}
const
char
*
extraName
(
)
const
{
return
mir
(
)
-
>
isTruncated
(
)
?
"
Truncated
"
:
nullptr
;
}
MBinaryArithInstruction
*
mir
(
)
const
{
MOZ_ASSERT
(
mir_
-
>
isDiv
(
)
|
|
mir_
-
>
isMod
(
)
)
;
return
static_cast
<
MBinaryArithInstruction
*
>
(
mir_
)
;
}
bool
canBeDivideByZero
(
)
const
{
if
(
mir_
-
>
isMod
(
)
)
return
mir_
-
>
toMod
(
)
-
>
canBeDivideByZero
(
)
;
return
mir_
-
>
toDiv
(
)
-
>
canBeDivideByZero
(
)
;
}
wasm
:
:
BytecodeOffset
bytecodeOffset
(
)
const
{
MOZ_ASSERT
(
mir_
-
>
isDiv
(
)
|
|
mir_
-
>
isMod
(
)
)
;
if
(
mir_
-
>
isMod
(
)
)
return
mir_
-
>
toMod
(
)
-
>
bytecodeOffset
(
)
;
return
mir_
-
>
toDiv
(
)
-
>
bytecodeOffset
(
)
;
}
}
;
class
LWasmTruncateToInt64
:
public
LInstructionHelper
<
1
1
1
>
{
public
:
LIR_HEADER
(
WasmTruncateToInt64
)
;
LWasmTruncateToInt64
(
const
LAllocation
&
in
const
LDefinition
&
temp
)
:
LInstructionHelper
(
classOpcode
)
{
setOperand
(
0
in
)
;
setTemp
(
0
temp
)
;
}
MWasmTruncateToInt64
*
mir
(
)
const
{
return
mir_
-
>
toWasmTruncateToInt64
(
)
;
}
const
LDefinition
*
temp
(
)
{
return
getTemp
(
0
)
;
}
}
;
}
}
#
endif
