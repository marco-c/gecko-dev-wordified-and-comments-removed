#
include
"
jit
/
x86
/
MacroAssembler
-
x86
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
jit
/
Bailouts
.
h
"
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
MoveEmitter
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
MOZ_ALIGNED_DECL
(
static
const
uint64_t
16
)
TO_DOUBLE
[
4
]
=
{
0x4530000043300000LL
0x0LL
0x4330000000000000LL
0x4530000000000000LL
}
;
static
const
double
TO_DOUBLE_HIGH_SCALE
=
0x100000000
;
void
MacroAssemblerX86
:
:
convertUInt64ToDouble
(
Register64
src
Register
temp
FloatRegister
dest
)
{
if
(
!
HasSSE3
(
)
)
{
convertUInt32ToDouble
(
src
.
high
dest
)
;
movePtr
(
ImmPtr
(
&
TO_DOUBLE_HIGH_SCALE
)
temp
)
;
loadDouble
(
Address
(
temp
0
)
ScratchDoubleReg
)
;
asMasm
(
)
.
mulDouble
(
ScratchDoubleReg
dest
)
;
convertUInt32ToDouble
(
src
.
low
ScratchDoubleReg
)
;
asMasm
(
)
.
addDouble
(
ScratchDoubleReg
dest
)
;
return
;
}
MOZ_ASSERT
(
dest
.
size
(
)
=
=
8
)
;
FloatRegister
dest128
=
FloatRegister
(
dest
.
encoding
(
)
FloatRegisters
:
:
Simd128
)
;
vmovd
(
src
.
low
dest128
)
;
vmovd
(
src
.
high
ScratchSimd128Reg
)
;
vpunpckldq
(
ScratchSimd128Reg
dest128
dest128
)
;
movePtr
(
ImmPtr
(
TO_DOUBLE
)
temp
)
;
vpunpckldq
(
Operand
(
temp
0
)
dest128
dest128
)
;
vsubpd
(
Operand
(
temp
sizeof
(
uint64_t
)
*
2
)
dest128
dest128
)
;
vhaddpd
(
dest128
dest128
)
;
}
void
MacroAssemblerX86
:
:
loadConstantDouble
(
double
d
FloatRegister
dest
)
{
if
(
maybeInlineDouble
(
d
dest
)
)
return
;
Double
*
dbl
=
getDouble
(
d
)
;
if
(
!
dbl
)
return
;
masm
.
vmovsd_mr
(
nullptr
dest
.
encoding
(
)
)
;
propagateOOM
(
dbl
-
>
uses
.
append
(
CodeOffset
(
masm
.
size
(
)
)
)
)
;
}
void
MacroAssemblerX86
:
:
loadConstantFloat32
(
float
f
FloatRegister
dest
)
{
if
(
maybeInlineFloat
(
f
dest
)
)
return
;
Float
*
flt
=
getFloat
(
f
)
;
if
(
!
flt
)
return
;
masm
.
vmovss_mr
(
nullptr
dest
.
encoding
(
)
)
;
propagateOOM
(
flt
-
>
uses
.
append
(
CodeOffset
(
masm
.
size
(
)
)
)
)
;
}
void
MacroAssemblerX86
:
:
loadConstantSimd128Int
(
const
SimdConstant
&
v
FloatRegister
dest
)
{
if
(
maybeInlineSimd128Int
(
v
dest
)
)
return
;
SimdData
*
i4
=
getSimdData
(
v
)
;
if
(
!
i4
)
return
;
masm
.
vmovdqa_mr
(
nullptr
dest
.
encoding
(
)
)
;
propagateOOM
(
i4
-
>
uses
.
append
(
CodeOffset
(
masm
.
size
(
)
)
)
)
;
}
void
MacroAssemblerX86
:
:
loadConstantSimd128Float
(
const
SimdConstant
&
v
FloatRegister
dest
)
{
if
(
maybeInlineSimd128Float
(
v
dest
)
)
return
;
SimdData
*
f4
=
getSimdData
(
v
)
;
if
(
!
f4
)
return
;
masm
.
vmovaps_mr
(
nullptr
dest
.
encoding
(
)
)
;
propagateOOM
(
f4
-
>
uses
.
append
(
CodeOffset
(
masm
.
size
(
)
)
)
)
;
}
void
MacroAssemblerX86
:
:
finish
(
)
{
if
(
!
doubles_
.
empty
(
)
)
masm
.
haltingAlign
(
sizeof
(
double
)
)
;
for
(
const
Double
&
d
:
doubles_
)
{
CodeOffset
cst
(
masm
.
currentOffset
(
)
)
;
for
(
CodeOffset
use
:
d
.
uses
)
addCodeLabel
(
CodeLabel
(
use
cst
)
)
;
masm
.
doubleConstant
(
d
.
value
)
;
if
(
!
enoughMemory_
)
return
;
}
if
(
!
floats_
.
empty
(
)
)
masm
.
haltingAlign
(
sizeof
(
float
)
)
;
for
(
const
Float
&
f
:
floats_
)
{
CodeOffset
cst
(
masm
.
currentOffset
(
)
)
;
for
(
CodeOffset
use
:
f
.
uses
)
addCodeLabel
(
CodeLabel
(
use
cst
)
)
;
masm
.
floatConstant
(
f
.
value
)
;
if
(
!
enoughMemory_
)
return
;
}
if
(
!
simds_
.
empty
(
)
)
masm
.
haltingAlign
(
SimdMemoryAlignment
)
;
for
(
const
SimdData
&
v
:
simds_
)
{
CodeOffset
cst
(
masm
.
currentOffset
(
)
)
;
for
(
CodeOffset
use
:
v
.
uses
)
addCodeLabel
(
CodeLabel
(
use
cst
)
)
;
masm
.
simd128Constant
(
v
.
value
.
bytes
(
)
)
;
if
(
!
enoughMemory_
)
return
;
}
}
void
MacroAssemblerX86
:
:
handleFailureWithHandlerTail
(
void
*
handler
)
{
subl
(
Imm32
(
sizeof
(
ResumeFromException
)
)
esp
)
;
movl
(
esp
eax
)
;
asMasm
(
)
.
setupUnalignedABICall
(
ecx
)
;
asMasm
(
)
.
passABIArg
(
eax
)
;
asMasm
(
)
.
callWithABI
(
handler
)
;
Label
entryFrame
;
Label
catch_
;
Label
finally
;
Label
return_
;
Label
bailout
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
kind
)
)
eax
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
eax
Imm32
(
ResumeFromException
:
:
RESUME_ENTRY_FRAME
)
&
entryFrame
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
eax
Imm32
(
ResumeFromException
:
:
RESUME_CATCH
)
&
catch_
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
eax
Imm32
(
ResumeFromException
:
:
RESUME_FINALLY
)
&
finally
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
eax
Imm32
(
ResumeFromException
:
:
RESUME_FORCED_RETURN
)
&
return_
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
eax
Imm32
(
ResumeFromException
:
:
RESUME_BAILOUT
)
&
bailout
)
;
breakpoint
(
)
;
bind
(
&
entryFrame
)
;
moveValue
(
MagicValue
(
JS_ION_ERROR
)
JSReturnOperand
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
stackPointer
)
)
esp
)
;
ret
(
)
;
bind
(
&
catch_
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
target
)
)
eax
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
framePointer
)
)
ebp
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
stackPointer
)
)
esp
)
;
jmp
(
Operand
(
eax
)
)
;
bind
(
&
finally
)
;
ValueOperand
exception
=
ValueOperand
(
ecx
edx
)
;
loadValue
(
Address
(
esp
offsetof
(
ResumeFromException
exception
)
)
exception
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
target
)
)
eax
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
framePointer
)
)
ebp
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
stackPointer
)
)
esp
)
;
pushValue
(
BooleanValue
(
true
)
)
;
pushValue
(
exception
)
;
jmp
(
Operand
(
eax
)
)
;
bind
(
&
return_
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
framePointer
)
)
ebp
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
stackPointer
)
)
esp
)
;
loadValue
(
Address
(
ebp
BaselineFrame
:
:
reverseOffsetOfReturnValue
(
)
)
JSReturnOperand
)
;
movl
(
ebp
esp
)
;
pop
(
ebp
)
;
{
Label
skipProfilingInstrumentation
;
AbsoluteAddress
addressOfEnabled
(
GetJitContext
(
)
-
>
runtime
-
>
spsProfiler
(
)
.
addressOfEnabled
(
)
)
;
asMasm
(
)
.
branch32
(
Assembler
:
:
Equal
addressOfEnabled
Imm32
(
0
)
&
skipProfilingInstrumentation
)
;
profilerExitFrame
(
)
;
bind
(
&
skipProfilingInstrumentation
)
;
}
ret
(
)
;
bind
(
&
bailout
)
;
loadPtr
(
Address
(
esp
offsetof
(
ResumeFromException
bailoutInfo
)
)
ecx
)
;
movl
(
Imm32
(
BAILOUT_RETURN_OK
)
eax
)
;
jmp
(
Operand
(
esp
offsetof
(
ResumeFromException
target
)
)
)
;
}
void
MacroAssemblerX86
:
:
profilerEnterFrame
(
Register
framePtr
Register
scratch
)
{
AbsoluteAddress
activation
(
GetJitContext
(
)
-
>
runtime
-
>
addressOfProfilingActivation
(
)
)
;
loadPtr
(
activation
scratch
)
;
storePtr
(
framePtr
Address
(
scratch
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
)
;
storePtr
(
ImmPtr
(
nullptr
)
Address
(
scratch
JitActivation
:
:
offsetOfLastProfilingCallSite
(
)
)
)
;
}
void
MacroAssemblerX86
:
:
profilerExitFrame
(
)
{
jmp
(
GetJitContext
(
)
-
>
runtime
-
>
jitRuntime
(
)
-
>
getProfilerExitFrameTail
(
)
)
;
}
MacroAssembler
&
MacroAssemblerX86
:
:
asMasm
(
)
{
return
*
static_cast
<
MacroAssembler
*
>
(
this
)
;
}
const
MacroAssembler
&
MacroAssemblerX86
:
:
asMasm
(
)
const
{
return
*
static_cast
<
const
MacroAssembler
*
>
(
this
)
;
}
void
MacroAssembler
:
:
reserveStack
(
uint32_t
amount
)
{
if
(
amount
)
{
uint32_t
amountLeft
=
amount
;
while
(
amountLeft
>
4096
)
{
subl
(
Imm32
(
4096
)
StackPointer
)
;
store32
(
Imm32
(
0
)
Address
(
StackPointer
0
)
)
;
amountLeft
-
=
4096
;
}
subl
(
Imm32
(
amountLeft
)
StackPointer
)
;
}
framePushed_
+
=
amount
;
}
void
MacroAssembler
:
:
setupUnalignedABICall
(
Register
scratch
)
{
setupABICall
(
)
;
dynamicAlignment_
=
true
;
movl
(
esp
scratch
)
;
andl
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
esp
)
;
push
(
scratch
)
;
}
void
MacroAssembler
:
:
callWithABIPre
(
uint32_t
*
stackAdjust
bool
callFromAsmJS
)
{
MOZ_ASSERT
(
inCall_
)
;
uint32_t
stackForCall
=
abiArgs_
.
stackBytesConsumedSoFar
(
)
;
if
(
dynamicAlignment_
)
{
stackForCall
+
=
ComputeByteAlignment
(
stackForCall
+
sizeof
(
intptr_t
)
ABIStackAlignment
)
;
}
else
{
uint32_t
alignmentAtPrologue
=
callFromAsmJS
?
sizeof
(
AsmJSFrame
)
:
0
;
stackForCall
+
=
ComputeByteAlignment
(
stackForCall
+
framePushed
(
)
+
alignmentAtPrologue
ABIStackAlignment
)
;
}
*
stackAdjust
=
stackForCall
;
reserveStack
(
stackForCall
)
;
{
enoughMemory_
&
=
moveResolver_
.
resolve
(
)
;
if
(
!
enoughMemory_
)
return
;
MoveEmitter
emitter
(
*
this
)
;
emitter
.
emit
(
moveResolver_
)
;
emitter
.
finish
(
)
;
}
assertStackAlignment
(
ABIStackAlignment
)
;
}
void
MacroAssembler
:
:
callWithABIPost
(
uint32_t
stackAdjust
MoveOp
:
:
Type
result
)
{
freeStack
(
stackAdjust
)
;
if
(
result
=
=
MoveOp
:
:
DOUBLE
)
{
reserveStack
(
sizeof
(
double
)
)
;
fstp
(
Operand
(
esp
0
)
)
;
loadDouble
(
Operand
(
esp
0
)
ReturnDoubleReg
)
;
freeStack
(
sizeof
(
double
)
)
;
}
else
if
(
result
=
=
MoveOp
:
:
FLOAT32
)
{
reserveStack
(
sizeof
(
float
)
)
;
fstp32
(
Operand
(
esp
0
)
)
;
loadFloat32
(
Operand
(
esp
0
)
ReturnFloat32Reg
)
;
freeStack
(
sizeof
(
float
)
)
;
}
if
(
dynamicAlignment_
)
pop
(
esp
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
inCall_
)
;
inCall_
=
false
;
#
endif
}
void
MacroAssembler
:
:
callWithABINoProfiler
(
Register
fun
MoveOp
:
:
Type
result
)
{
uint32_t
stackAdjust
;
callWithABIPre
(
&
stackAdjust
)
;
call
(
fun
)
;
callWithABIPost
(
stackAdjust
result
)
;
}
void
MacroAssembler
:
:
callWithABINoProfiler
(
const
Address
&
fun
MoveOp
:
:
Type
result
)
{
uint32_t
stackAdjust
;
callWithABIPre
(
&
stackAdjust
)
;
call
(
fun
)
;
callWithABIPost
(
stackAdjust
result
)
;
}
void
MacroAssembler
:
:
branchPtrInNurseryChunk
(
Condition
cond
Register
ptr
Register
temp
Label
*
label
)
{
MOZ_ASSERT
(
temp
!
=
InvalidReg
)
;
MOZ_ASSERT
(
ptr
!
=
temp
)
;
movePtr
(
ptr
temp
)
;
branchPtrInNurseryChunkImpl
(
cond
temp
label
)
;
}
void
MacroAssembler
:
:
branchPtrInNurseryChunk
(
Condition
cond
const
Address
&
address
Register
temp
Label
*
label
)
{
MOZ_ASSERT
(
temp
!
=
InvalidReg
)
;
loadPtr
(
address
temp
)
;
branchPtrInNurseryChunkImpl
(
cond
temp
label
)
;
}
void
MacroAssembler
:
:
branchPtrInNurseryChunkImpl
(
Condition
cond
Register
ptr
Label
*
label
)
{
MOZ_ASSERT
(
cond
=
=
Assembler
:
:
Equal
|
|
cond
=
=
Assembler
:
:
NotEqual
)
;
orPtr
(
Imm32
(
gc
:
:
ChunkMask
)
ptr
)
;
branch32
(
cond
Address
(
ptr
gc
:
:
ChunkLocationOffsetFromLastByte
)
Imm32
(
int32_t
(
gc
:
:
ChunkLocation
:
:
Nursery
)
)
label
)
;
}
void
MacroAssembler
:
:
branchValueIsNurseryObject
(
Condition
cond
const
Address
&
address
Register
temp
Label
*
label
)
{
MOZ_ASSERT
(
cond
=
=
Assembler
:
:
Equal
|
|
cond
=
=
Assembler
:
:
NotEqual
)
;
Label
done
;
branchTestObject
(
Assembler
:
:
NotEqual
address
cond
=
=
Assembler
:
:
Equal
?
&
done
:
label
)
;
branchPtrInNurseryChunk
(
cond
address
temp
label
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
branchValueIsNurseryObject
(
Condition
cond
ValueOperand
value
Register
temp
Label
*
label
)
{
MOZ_ASSERT
(
cond
=
=
Assembler
:
:
Equal
|
|
cond
=
=
Assembler
:
:
NotEqual
)
;
Label
done
;
branchTestObject
(
Assembler
:
:
NotEqual
value
cond
=
=
Assembler
:
:
Equal
?
&
done
:
label
)
;
branchPtrInNurseryChunk
(
cond
value
.
payloadReg
(
)
temp
label
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
branchTestValue
(
Condition
cond
const
ValueOperand
&
lhs
const
Value
&
rhs
Label
*
label
)
{
MOZ_ASSERT
(
cond
=
=
Equal
|
|
cond
=
=
NotEqual
)
;
jsval_layout
jv
=
JSVAL_TO_IMPL
(
rhs
)
;
if
(
rhs
.
isMarkable
(
)
)
cmpPtr
(
lhs
.
payloadReg
(
)
ImmGCPtr
(
reinterpret_cast
<
gc
:
:
Cell
*
>
(
rhs
.
toGCThing
(
)
)
)
)
;
else
cmpPtr
(
lhs
.
payloadReg
(
)
ImmWord
(
jv
.
s
.
payload
.
i32
)
)
;
if
(
cond
=
=
Equal
)
{
Label
done
;
j
(
NotEqual
&
done
)
;
{
cmp32
(
lhs
.
typeReg
(
)
Imm32
(
jv
.
s
.
tag
)
)
;
j
(
Equal
label
)
;
}
bind
(
&
done
)
;
}
else
{
j
(
NotEqual
label
)
;
cmp32
(
lhs
.
typeReg
(
)
Imm32
(
jv
.
s
.
tag
)
)
;
j
(
NotEqual
label
)
;
}
}
template
<
typename
T
>
void
MacroAssembler
:
:
storeUnboxedValue
(
ConstantOrRegister
value
MIRType
valueType
const
T
&
dest
MIRType
slotType
)
{
if
(
valueType
=
=
MIRType
:
:
Double
)
{
storeDouble
(
value
.
reg
(
)
.
typedReg
(
)
.
fpu
(
)
dest
)
;
return
;
}
if
(
valueType
!
=
slotType
)
storeTypeTag
(
ImmType
(
ValueTypeFromMIRType
(
valueType
)
)
Operand
(
dest
)
)
;
if
(
value
.
constant
(
)
)
storePayload
(
value
.
value
(
)
Operand
(
dest
)
)
;
else
storePayload
(
value
.
reg
(
)
.
typedReg
(
)
.
gpr
(
)
Operand
(
dest
)
)
;
}
template
void
MacroAssembler
:
:
storeUnboxedValue
(
ConstantOrRegister
value
MIRType
valueType
const
Address
&
dest
MIRType
slotType
)
;
template
void
MacroAssembler
:
:
storeUnboxedValue
(
ConstantOrRegister
value
MIRType
valueType
const
BaseIndex
&
dest
MIRType
slotType
)
;
void
MacroAssembler
:
:
wasmTruncateDoubleToUInt32
(
FloatRegister
input
Register
output
Label
*
oolEntry
)
{
Label
done
;
vcvttsd2si
(
input
output
)
;
branch32
(
Assembler
:
:
Condition
:
:
NotSigned
output
Imm32
(
0
)
&
done
)
;
loadConstantDouble
(
double
(
int32_t
(
0x80000000
)
)
ScratchDoubleReg
)
;
addDouble
(
input
ScratchDoubleReg
)
;
vcvttsd2si
(
ScratchDoubleReg
output
)
;
branch32
(
Assembler
:
:
Condition
:
:
Signed
output
Imm32
(
0
)
oolEntry
)
;
or32
(
Imm32
(
0x80000000
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
wasmTruncateFloat32ToUInt32
(
FloatRegister
input
Register
output
Label
*
oolEntry
)
{
Label
done
;
vcvttss2si
(
input
output
)
;
branch32
(
Assembler
:
:
Condition
:
:
NotSigned
output
Imm32
(
0
)
&
done
)
;
loadConstantFloat32
(
float
(
int32_t
(
0x80000000
)
)
ScratchFloat32Reg
)
;
addFloat32
(
input
ScratchFloat32Reg
)
;
vcvttss2si
(
ScratchFloat32Reg
output
)
;
branch32
(
Assembler
:
:
Condition
:
:
Signed
output
Imm32
(
0
)
oolEntry
)
;
or32
(
Imm32
(
0x80000000
)
output
)
;
bind
(
&
done
)
;
}
