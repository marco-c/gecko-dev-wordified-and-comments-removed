#
ifndef
jit_x86_SharedICHelpers_x86_h
#
define
jit_x86_SharedICHelpers_x86_h
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
namespace
js
{
namespace
jit
{
static
const
size_t
ICStackValueOffset
=
sizeof
(
void
*
)
;
inline
void
EmitRestoreTailCallReg
(
MacroAssembler
&
masm
)
{
masm
.
Pop
(
ICTailCallReg
)
;
}
inline
void
EmitRepushTailCallReg
(
MacroAssembler
&
masm
)
{
masm
.
Push
(
ICTailCallReg
)
;
}
inline
void
EmitCallIC
(
CodeOffset
*
patchOffset
MacroAssembler
&
masm
)
{
CodeOffset
offset
=
masm
.
movWithPatch
(
ImmWord
(
-
1
)
ICStubReg
)
;
*
patchOffset
=
offset
;
masm
.
loadPtr
(
Address
(
ICStubReg
(
int32_t
)
ICEntry
:
:
offsetOfFirstStub
(
)
)
ICStubReg
)
;
masm
.
call
(
Address
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
)
;
}
inline
void
EmitEnterTypeMonitorIC
(
MacroAssembler
&
masm
size_t
monitorStubOffset
=
ICMonitoredStub
:
:
offsetOfFirstMonitorStub
(
)
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
(
int32_t
)
monitorStubOffset
)
ICStubReg
)
;
masm
.
jmp
(
Operand
(
ICStubReg
(
int32_t
)
ICStub
:
:
offsetOfStubCode
(
)
)
)
;
}
inline
void
EmitReturnFromIC
(
MacroAssembler
&
masm
)
{
masm
.
ret
(
)
;
}
inline
void
EmitChangeICReturnAddress
(
MacroAssembler
&
masm
Register
reg
)
{
masm
.
storePtr
(
reg
Address
(
StackPointer
0
)
)
;
}
inline
void
EmitBaselineTailCallVM
(
JitCode
*
target
MacroAssembler
&
masm
uint32_t
argSize
)
{
masm
.
movl
(
BaselineFrameReg
eax
)
;
masm
.
addl
(
Imm32
(
BaselineFrame
:
:
FramePointerOffset
)
eax
)
;
masm
.
subl
(
BaselineStackReg
eax
)
;
masm
.
movl
(
eax
ebx
)
;
masm
.
subl
(
Imm32
(
argSize
)
ebx
)
;
masm
.
store32
(
ebx
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFrameSize
(
)
)
)
;
masm
.
makeFrameDescriptor
(
eax
JitFrame_BaselineJS
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
eax
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
jmp
(
target
)
;
}
inline
void
EmitIonTailCallVM
(
JitCode
*
target
MacroAssembler
&
masm
uint32_t
stackSize
)
{
masm
.
loadPtr
(
Address
(
esp
stackSize
)
eax
)
;
masm
.
shrl
(
Imm32
(
FRAMESIZE_SHIFT
)
eax
)
;
masm
.
addl
(
Imm32
(
stackSize
+
JitStubFrameLayout
:
:
Size
(
)
-
sizeof
(
intptr_t
)
)
eax
)
;
masm
.
makeFrameDescriptor
(
eax
JitFrame_IonJS
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
eax
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
jmp
(
target
)
;
}
inline
void
EmitBaselineCreateStubFrameDescriptor
(
MacroAssembler
&
masm
Register
reg
uint32_t
headerSize
)
{
masm
.
movl
(
BaselineFrameReg
reg
)
;
masm
.
addl
(
Imm32
(
sizeof
(
void
*
)
*
2
)
reg
)
;
masm
.
subl
(
BaselineStackReg
reg
)
;
masm
.
makeFrameDescriptor
(
reg
JitFrame_BaselineStub
headerSize
)
;
}
inline
void
EmitBaselineCallVM
(
JitCode
*
target
MacroAssembler
&
masm
)
{
EmitBaselineCreateStubFrameDescriptor
(
masm
eax
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
eax
)
;
masm
.
call
(
target
)
;
}
inline
void
EmitIonCallVM
(
JitCode
*
target
size_t
stackSlots
MacroAssembler
&
masm
)
{
uint32_t
framePushed
=
masm
.
framePushed
(
)
-
sizeof
(
void
*
)
;
uint32_t
descriptor
=
MakeFrameDescriptor
(
framePushed
JitFrame_IonStub
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
Imm32
(
descriptor
)
)
;
masm
.
call
(
target
)
;
size_t
framePop
=
sizeof
(
ExitFrameLayout
)
-
sizeof
(
void
*
)
;
masm
.
implicitPop
(
stackSlots
*
sizeof
(
void
*
)
+
framePop
)
;
}
static
const
uint32_t
STUB_FRAME_SIZE
=
4
*
sizeof
(
void
*
)
;
static
const
uint32_t
STUB_FRAME_SAVED_STUB_OFFSET
=
sizeof
(
void
*
)
;
inline
void
EmitBaselineEnterStubFrame
(
MacroAssembler
&
masm
Register
scratch
)
{
static_assert
(
BaselineFrame
:
:
FramePointerOffset
=
=
sizeof
(
void
*
)
"
FramePointerOffset
must
be
the
same
as
the
return
address
size
"
)
;
masm
.
movl
(
BaselineFrameReg
scratch
)
;
masm
.
subl
(
BaselineStackReg
scratch
)
;
masm
.
store32
(
scratch
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFrameSize
(
)
)
)
;
masm
.
Push
(
Operand
(
BaselineStackReg
0
)
)
;
masm
.
makeFrameDescriptor
(
scratch
JitFrame_BaselineJS
BaselineStubFrameLayout
:
:
Size
(
)
)
;
masm
.
storePtr
(
scratch
Address
(
BaselineStackReg
sizeof
(
uintptr_t
)
)
)
;
masm
.
Push
(
ICStubReg
)
;
masm
.
Push
(
BaselineFrameReg
)
;
masm
.
mov
(
BaselineStackReg
BaselineFrameReg
)
;
}
inline
void
EmitBaselineLeaveStubFrame
(
MacroAssembler
&
masm
bool
calledIntoIon
=
false
)
{
if
(
calledIntoIon
)
{
Register
scratch
=
ICStubReg
;
masm
.
Pop
(
scratch
)
;
masm
.
shrl
(
Imm32
(
FRAMESIZE_SHIFT
)
scratch
)
;
masm
.
addl
(
scratch
BaselineStackReg
)
;
}
else
{
masm
.
mov
(
BaselineFrameReg
BaselineStackReg
)
;
}
masm
.
Pop
(
BaselineFrameReg
)
;
masm
.
Pop
(
ICStubReg
)
;
masm
.
Pop
(
Operand
(
BaselineStackReg
0
)
)
;
}
inline
void
EmitStowICValues
(
MacroAssembler
&
masm
int
values
)
{
MOZ_ASSERT
(
values
>
=
0
&
&
values
<
=
2
)
;
switch
(
values
)
{
case
1
:
masm
.
pop
(
ICTailCallReg
)
;
masm
.
Push
(
R0
)
;
masm
.
push
(
ICTailCallReg
)
;
break
;
case
2
:
masm
.
pop
(
ICTailCallReg
)
;
masm
.
Push
(
R0
)
;
masm
.
Push
(
R1
)
;
masm
.
push
(
ICTailCallReg
)
;
break
;
}
}
inline
void
EmitUnstowICValues
(
MacroAssembler
&
masm
int
values
bool
discard
=
false
)
{
MOZ_ASSERT
(
values
>
=
0
&
&
values
<
=
2
)
;
switch
(
values
)
{
case
1
:
masm
.
pop
(
ICTailCallReg
)
;
if
(
discard
)
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
BaselineStackReg
)
;
else
masm
.
popValue
(
R0
)
;
masm
.
push
(
ICTailCallReg
)
;
break
;
case
2
:
masm
.
pop
(
ICTailCallReg
)
;
if
(
discard
)
{
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
*
2
)
BaselineStackReg
)
;
}
else
{
masm
.
popValue
(
R1
)
;
masm
.
popValue
(
R0
)
;
}
masm
.
push
(
ICTailCallReg
)
;
break
;
}
masm
.
adjustFrame
(
-
values
*
sizeof
(
Value
)
)
;
}
inline
void
EmitCallTypeUpdateIC
(
MacroAssembler
&
masm
JitCode
*
code
uint32_t
objectOffset
)
{
masm
.
push
(
ICStubReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
(
int32_t
)
ICUpdatedStub
:
:
offsetOfFirstUpdateStub
(
)
)
ICStubReg
)
;
masm
.
call
(
Address
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
)
;
masm
.
pop
(
ICStubReg
)
;
Label
success
;
masm
.
cmp32
(
R1
.
scratchReg
(
)
Imm32
(
1
)
)
;
masm
.
j
(
Assembler
:
:
Equal
&
success
)
;
EmitBaselineEnterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
masm
.
loadValue
(
Address
(
BaselineStackReg
STUB_FRAME_SIZE
+
objectOffset
)
R1
)
;
masm
.
Push
(
R0
)
;
masm
.
Push
(
R1
)
;
masm
.
Push
(
ICStubReg
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
R0
.
scratchReg
(
)
)
;
masm
.
pushBaselineFramePtr
(
R0
.
scratchReg
(
)
R0
.
scratchReg
(
)
)
;
EmitBaselineCallVM
(
code
masm
)
;
EmitBaselineLeaveStubFrame
(
masm
)
;
masm
.
bind
(
&
success
)
;
}
template
<
typename
AddrType
>
inline
void
EmitPreBarrier
(
MacroAssembler
&
masm
const
AddrType
&
addr
MIRType
type
)
{
masm
.
patchableCallPreBarrier
(
addr
type
)
;
}
inline
void
EmitStubGuardFailure
(
MacroAssembler
&
masm
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICStub
:
:
offsetOfNext
(
)
)
ICStubReg
)
;
masm
.
jmp
(
Operand
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
)
;
}
}
}
#
endif
