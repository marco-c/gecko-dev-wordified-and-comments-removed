#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jit
/
BaselineCompiler
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
IonControlFlow
.
h
"
#
include
"
jit
/
JitCommon
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsopcodeinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
mozilla
:
:
BinarySearchIf
;
using
mozilla
:
:
DebugOnly
;
using
namespace
js
;
using
namespace
js
:
:
jit
;
PCMappingSlotInfo
:
:
SlotLocation
PCMappingSlotInfo
:
:
ToSlotLocation
(
const
StackValue
*
stackVal
)
{
if
(
stackVal
-
>
kind
(
)
=
=
StackValue
:
:
Register
)
{
if
(
stackVal
-
>
reg
(
)
=
=
R0
)
return
SlotInR0
;
MOZ_ASSERT
(
stackVal
-
>
reg
(
)
=
=
R1
)
;
return
SlotInR1
;
}
MOZ_ASSERT
(
stackVal
-
>
kind
(
)
!
=
StackValue
:
:
Stack
)
;
return
SlotIgnore
;
}
void
ICStubSpace
:
:
freeAllAfterMinorGC
(
Zone
*
zone
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
MOZ_ASSERT
(
allocator_
.
isEmpty
(
)
)
;
else
zone
-
>
runtimeFromActiveCooperatingThread
(
)
-
>
gc
.
freeAllLifoBlocksAfterMinorGC
(
&
allocator_
)
;
}
BaselineScript
:
:
BaselineScript
(
uint32_t
prologueOffset
uint32_t
epilogueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
uint32_t
postDebugPrologueOffset
)
:
method_
(
nullptr
)
templateEnv_
(
nullptr
)
fallbackStubSpace_
(
)
dependentWasmImports_
(
nullptr
)
prologueOffset_
(
prologueOffset
)
epilogueOffset_
(
epilogueOffset
)
profilerEnterToggleOffset_
(
profilerEnterToggleOffset
)
profilerExitToggleOffset_
(
profilerExitToggleOffset
)
#
ifdef
JS_TRACE_LOGGING
#
ifdef
DEBUG
traceLoggerScriptsEnabled_
(
false
)
traceLoggerEngineEnabled_
(
false
)
#
endif
traceLoggerScriptEvent_
(
)
#
endif
postDebugPrologueOffset_
(
postDebugPrologueOffset
)
flags_
(
0
)
inlinedBytecodeLength_
(
0
)
maxInliningDepth_
(
UINT8_MAX
)
pendingBuilder_
(
nullptr
)
controlFlowGraph_
(
nullptr
)
{
}
static
const
unsigned
BASELINE_MAX_ARGS_LENGTH
=
20000
;
static
bool
CheckFrame
(
InterpreterFrame
*
fp
)
{
if
(
fp
-
>
isDebuggerEvalFrame
(
)
)
{
JitSpew
(
JitSpew_BaselineAbort
"
debugger
frame
"
)
;
return
false
;
}
if
(
fp
-
>
isFunctionFrame
(
)
&
&
fp
-
>
numActualArgs
(
)
>
BASELINE_MAX_ARGS_LENGTH
)
{
JitSpew
(
JitSpew_BaselineAbort
"
Too
many
arguments
(
%
u
)
"
fp
-
>
numActualArgs
(
)
)
;
return
false
;
}
return
true
;
}
static
JitExecStatus
EnterBaseline
(
JSContext
*
cx
EnterJitData
&
data
)
{
if
(
data
.
osrFrame
)
{
uint8_t
spDummy
;
uint32_t
extra
=
BaselineFrame
:
:
Size
(
)
+
(
data
.
osrNumStackValues
*
sizeof
(
Value
)
)
;
uint8_t
*
checkSp
=
(
&
spDummy
)
-
extra
;
if
(
!
CheckRecursionLimitWithStackPointer
(
cx
checkSp
)
)
return
JitExec_Aborted
;
}
else
{
if
(
!
CheckRecursionLimit
(
cx
)
)
return
JitExec_Aborted
;
}
#
ifdef
DEBUG
mozilla
:
:
Maybe
<
JS
:
:
AutoAssertNoGC
>
nogc
;
nogc
.
emplace
(
cx
)
;
#
endif
MOZ_ASSERT
(
jit
:
:
IsBaselineEnabled
(
cx
)
)
;
MOZ_ASSERT_IF
(
data
.
osrFrame
CheckFrame
(
data
.
osrFrame
)
)
;
EnterJitCode
enter
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
enterBaseline
(
)
;
bool
constructingLegacyGen
=
data
.
constructing
&
&
CalleeTokenToFunction
(
data
.
calleeToken
)
-
>
isLegacyGenerator
(
)
;
MOZ_ASSERT_IF
(
data
.
constructing
&
&
!
constructingLegacyGen
data
.
maxArgv
[
0
]
.
isObject
(
)
|
|
data
.
maxArgv
[
0
]
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
;
data
.
result
.
setInt32
(
data
.
numActualArgs
)
;
{
AssertCompartmentUnchanged
pcc
(
cx
)
;
ActivationEntryMonitor
entryMonitor
(
cx
data
.
calleeToken
)
;
JitActivation
activation
(
cx
)
;
if
(
data
.
osrFrame
)
data
.
osrFrame
-
>
setRunningInJit
(
)
;
#
ifdef
DEBUG
nogc
.
reset
(
)
;
#
endif
CALL_GENERATED_CODE
(
enter
data
.
jitcode
data
.
maxArgc
data
.
maxArgv
data
.
osrFrame
data
.
calleeToken
data
.
envChain
.
get
(
)
data
.
osrNumStackValues
data
.
result
.
address
(
)
)
;
if
(
data
.
osrFrame
)
data
.
osrFrame
-
>
clearRunningInJit
(
)
;
}
MOZ_ASSERT
(
!
cx
-
>
hasIonReturnOverride
(
)
)
;
if
(
!
data
.
result
.
isMagic
(
)
&
&
data
.
constructing
&
&
data
.
result
.
isPrimitive
(
)
&
&
!
constructingLegacyGen
)
{
MOZ_ASSERT
(
data
.
maxArgv
[
0
]
.
isObject
(
)
)
;
data
.
result
=
data
.
maxArgv
[
0
]
;
}
cx
-
>
freeOsrTempData
(
)
;
MOZ_ASSERT_IF
(
data
.
result
.
isMagic
(
)
data
.
result
.
isMagic
(
JS_ION_ERROR
)
)
;
return
data
.
result
.
isMagic
(
)
?
JitExec_Error
:
JitExec_Ok
;
}
JitExecStatus
jit
:
:
EnterBaselineMethod
(
JSContext
*
cx
RunState
&
state
)
{
BaselineScript
*
baseline
=
state
.
script
(
)
-
>
baselineScript
(
)
;
EnterJitData
data
(
cx
)
;
data
.
jitcode
=
baseline
-
>
method
(
)
-
>
raw
(
)
;
Rooted
<
GCVector
<
Value
>
>
vals
(
cx
GCVector
<
Value
>
(
cx
)
)
;
if
(
!
SetEnterJitData
(
cx
data
state
&
vals
)
)
return
JitExec_Error
;
JitExecStatus
status
=
EnterBaseline
(
cx
data
)
;
if
(
status
!
=
JitExec_Ok
)
return
status
;
state
.
setReturnValue
(
data
.
result
)
;
return
JitExec_Ok
;
}
JitExecStatus
jit
:
:
EnterBaselineAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOP_LOOPENTRY
)
;
BaselineScript
*
baseline
=
fp
-
>
script
(
)
-
>
baselineScript
(
)
;
EnterJitData
data
(
cx
)
;
data
.
jitcode
=
baseline
-
>
nativeCodeForPC
(
fp
-
>
script
(
)
pc
)
;
if
(
fp
-
>
isDebuggee
(
)
)
{
MOZ_RELEASE_ASSERT
(
baseline
-
>
hasDebugInstrumentation
(
)
)
;
data
.
jitcode
+
=
MacroAssembler
:
:
ToggledCallSize
(
data
.
jitcode
)
;
}
data
.
osrFrame
=
fp
;
data
.
osrNumStackValues
=
fp
-
>
script
(
)
-
>
nfixed
(
)
+
cx
-
>
interpreterRegs
(
)
.
stackDepth
(
)
;
AutoValueVector
vals
(
cx
)
;
RootedValue
thisv
(
cx
)
;
if
(
fp
-
>
isFunctionFrame
(
)
)
{
data
.
constructing
=
fp
-
>
isConstructing
(
)
;
data
.
numActualArgs
=
fp
-
>
numActualArgs
(
)
;
data
.
maxArgc
=
Max
(
fp
-
>
numActualArgs
(
)
fp
-
>
numFormalArgs
(
)
)
+
1
;
data
.
maxArgv
=
fp
-
>
argv
(
)
-
1
;
data
.
envChain
=
nullptr
;
data
.
calleeToken
=
CalleeToToken
(
&
fp
-
>
callee
(
)
data
.
constructing
)
;
}
else
{
thisv
.
setUndefined
(
)
;
data
.
constructing
=
false
;
data
.
numActualArgs
=
0
;
data
.
maxArgc
=
1
;
data
.
maxArgv
=
thisv
.
address
(
)
;
data
.
envChain
=
fp
-
>
environmentChain
(
)
;
data
.
calleeToken
=
CalleeToToken
(
fp
-
>
script
(
)
)
;
if
(
fp
-
>
isEvalFrame
(
)
)
{
if
(
!
vals
.
reserve
(
2
)
)
return
JitExec_Aborted
;
vals
.
infallibleAppend
(
thisv
)
;
if
(
fp
-
>
script
(
)
-
>
isDirectEvalInFunction
(
)
)
vals
.
infallibleAppend
(
fp
-
>
newTarget
(
)
)
;
else
vals
.
infallibleAppend
(
NullValue
(
)
)
;
data
.
maxArgc
=
2
;
data
.
maxArgv
=
vals
.
begin
(
)
;
}
}
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
)
;
TraceLogStopEvent
(
logger
TraceLogger_Interpreter
)
;
TraceLogStartEvent
(
logger
TraceLogger_Baseline
)
;
JitExecStatus
status
=
EnterBaseline
(
cx
data
)
;
if
(
status
!
=
JitExec_Ok
)
return
status
;
fp
-
>
setReturnValue
(
data
.
result
)
;
return
JitExec_Ok
;
}
MethodStatus
jit
:
:
BaselineCompile
(
JSContext
*
cx
JSScript
*
script
bool
forceDebugInstrumentation
)
{
MOZ_ASSERT
(
!
script
-
>
hasBaselineScript
(
)
)
;
MOZ_ASSERT
(
script
-
>
canBaselineCompile
(
)
)
;
MOZ_ASSERT
(
IsBaselineEnabled
(
cx
)
)
;
script
-
>
ensureNonLazyCanonicalFunction
(
)
;
LifoAlloc
alloc
(
TempAllocator
:
:
PreferredLifoChunkSize
)
;
TempAllocator
*
temp
=
alloc
.
new_
<
TempAllocator
>
(
&
alloc
)
;
if
(
!
temp
)
{
ReportOutOfMemory
(
cx
)
;
return
Method_Error
;
}
JitContext
jctx
(
cx
temp
)
;
BaselineCompiler
compiler
(
cx
*
temp
script
)
;
if
(
!
compiler
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
Method_Error
;
}
if
(
forceDebugInstrumentation
)
compiler
.
setCompileDebugInstrumentation
(
)
;
MethodStatus
status
=
compiler
.
compile
(
)
;
MOZ_ASSERT_IF
(
status
=
=
Method_Compiled
script
-
>
hasBaselineScript
(
)
)
;
MOZ_ASSERT_IF
(
status
!
=
Method_Compiled
!
script
-
>
hasBaselineScript
(
)
)
;
if
(
status
=
=
Method_CantCompile
)
script
-
>
setBaselineScript
(
cx
-
>
runtime
(
)
BASELINE_DISABLED_SCRIPT
)
;
return
status
;
}
static
MethodStatus
CanEnterBaselineJIT
(
JSContext
*
cx
HandleScript
script
InterpreterFrame
*
osrFrame
)
{
MOZ_ASSERT
(
jit
:
:
IsBaselineEnabled
(
cx
)
)
;
if
(
!
script
-
>
canBaselineCompile
(
)
)
return
Method_Skipped
;
if
(
script
-
>
length
(
)
>
BaselineScript
:
:
MAX_JSSCRIPT_LENGTH
)
return
Method_CantCompile
;
if
(
script
-
>
nslots
(
)
>
BaselineScript
:
:
MAX_JSSCRIPT_SLOTS
)
return
Method_CantCompile
;
if
(
script
-
>
hasBaselineScript
(
)
)
return
Method_Compiled
;
if
(
!
CanLikelyAllocateMoreExecutableMemory
(
)
)
return
Method_Skipped
;
if
(
!
cx
-
>
compartment
(
)
-
>
ensureJitCompartmentExists
(
cx
)
)
return
Method_Error
;
if
(
script
-
>
incWarmUpCounter
(
)
<
=
JitOptions
.
baselineWarmUpThreshold
)
return
Method_Skipped
;
return
BaselineCompile
(
cx
script
osrFrame
&
&
osrFrame
-
>
isDebuggee
(
)
)
;
}
MethodStatus
jit
:
:
CanEnterBaselineAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
bool
newType
)
{
if
(
!
CheckFrame
(
fp
)
)
return
Method_CantCompile
;
if
(
fp
-
>
isDebuggee
(
)
&
&
!
Debugger
:
:
ensureExecutionObservabilityOfOsrFrame
(
cx
fp
)
)
return
Method_Error
;
RootedScript
script
(
cx
fp
-
>
script
(
)
)
;
return
CanEnterBaselineJIT
(
cx
script
fp
)
;
}
MethodStatus
jit
:
:
CanEnterBaselineMethod
(
JSContext
*
cx
RunState
&
state
)
{
if
(
state
.
isInvoke
(
)
)
{
InvokeState
&
invoke
=
*
state
.
asInvoke
(
)
;
if
(
invoke
.
args
(
)
.
length
(
)
>
BASELINE_MAX_ARGS_LENGTH
)
{
JitSpew
(
JitSpew_BaselineAbort
"
Too
many
arguments
(
%
u
)
"
invoke
.
args
(
)
.
length
(
)
)
;
return
Method_CantCompile
;
}
if
(
!
state
.
maybeCreateThisForConstructor
(
cx
)
)
{
if
(
cx
-
>
isThrowingOutOfMemory
(
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
Method_Skipped
;
}
return
Method_Error
;
}
}
else
{
if
(
state
.
asExecute
(
)
-
>
isDebuggerEval
(
)
)
{
JitSpew
(
JitSpew_BaselineAbort
"
debugger
frame
"
)
;
return
Method_CantCompile
;
}
}
RootedScript
script
(
cx
state
.
script
(
)
)
;
return
CanEnterBaselineJIT
(
cx
script
nullptr
)
;
}
;
BaselineScript
*
BaselineScript
:
:
New
(
JSScript
*
jsscript
uint32_t
prologueOffset
uint32_t
epilogueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
uint32_t
postDebugPrologueOffset
size_t
icEntries
size_t
pcMappingIndexEntries
size_t
pcMappingSize
size_t
bytecodeTypeMapEntries
size_t
yieldEntries
size_t
traceLoggerToggleOffsetEntries
)
{
static
const
unsigned
DataAlignment
=
sizeof
(
uintptr_t
)
;
size_t
icEntriesSize
=
icEntries
*
sizeof
(
BaselineICEntry
)
;
size_t
pcMappingIndexEntriesSize
=
pcMappingIndexEntries
*
sizeof
(
PCMappingIndexEntry
)
;
size_t
bytecodeTypeMapSize
=
bytecodeTypeMapEntries
*
sizeof
(
uint32_t
)
;
size_t
yieldEntriesSize
=
yieldEntries
*
sizeof
(
uintptr_t
)
;
size_t
tlEntriesSize
=
traceLoggerToggleOffsetEntries
*
sizeof
(
uint32_t
)
;
size_t
paddedICEntriesSize
=
AlignBytes
(
icEntriesSize
DataAlignment
)
;
size_t
paddedPCMappingIndexEntriesSize
=
AlignBytes
(
pcMappingIndexEntriesSize
DataAlignment
)
;
size_t
paddedPCMappingSize
=
AlignBytes
(
pcMappingSize
DataAlignment
)
;
size_t
paddedBytecodeTypesMapSize
=
AlignBytes
(
bytecodeTypeMapSize
DataAlignment
)
;
size_t
paddedYieldEntriesSize
=
AlignBytes
(
yieldEntriesSize
DataAlignment
)
;
size_t
paddedTLEntriesSize
=
AlignBytes
(
tlEntriesSize
DataAlignment
)
;
size_t
allocBytes
=
paddedICEntriesSize
+
paddedPCMappingIndexEntriesSize
+
paddedPCMappingSize
+
paddedBytecodeTypesMapSize
+
paddedYieldEntriesSize
+
paddedTLEntriesSize
;
BaselineScript
*
script
=
jsscript
-
>
zone
(
)
-
>
pod_malloc_with_extra
<
BaselineScript
uint8_t
>
(
allocBytes
)
;
if
(
!
script
)
return
nullptr
;
new
(
script
)
BaselineScript
(
prologueOffset
epilogueOffset
profilerEnterToggleOffset
profilerExitToggleOffset
postDebugPrologueOffset
)
;
size_t
offsetCursor
=
sizeof
(
BaselineScript
)
;
MOZ_ASSERT
(
offsetCursor
=
=
AlignBytes
(
sizeof
(
BaselineScript
)
DataAlignment
)
)
;
script
-
>
icEntriesOffset_
=
offsetCursor
;
script
-
>
icEntries_
=
icEntries
;
offsetCursor
+
=
paddedICEntriesSize
;
script
-
>
pcMappingIndexOffset_
=
offsetCursor
;
script
-
>
pcMappingIndexEntries_
=
pcMappingIndexEntries
;
offsetCursor
+
=
paddedPCMappingIndexEntriesSize
;
script
-
>
pcMappingOffset_
=
offsetCursor
;
script
-
>
pcMappingSize_
=
pcMappingSize
;
offsetCursor
+
=
paddedPCMappingSize
;
script
-
>
bytecodeTypeMapOffset_
=
bytecodeTypeMapEntries
?
offsetCursor
:
0
;
offsetCursor
+
=
paddedBytecodeTypesMapSize
;
script
-
>
yieldEntriesOffset_
=
yieldEntries
?
offsetCursor
:
0
;
offsetCursor
+
=
paddedYieldEntriesSize
;
script
-
>
traceLoggerToggleOffsetsOffset_
=
tlEntriesSize
?
offsetCursor
:
0
;
script
-
>
numTraceLoggerToggleOffsets_
=
traceLoggerToggleOffsetEntries
;
offsetCursor
+
=
paddedTLEntriesSize
;
MOZ_ASSERT
(
offsetCursor
=
=
sizeof
(
BaselineScript
)
+
allocBytes
)
;
return
script
;
}
void
BaselineScript
:
:
trace
(
JSTracer
*
trc
)
{
TraceEdge
(
trc
&
method_
"
baseline
-
method
"
)
;
TraceNullableEdge
(
trc
&
templateEnv_
"
baseline
-
template
-
environment
"
)
;
for
(
size_t
i
=
0
;
i
<
numICEntries
(
)
;
i
+
+
)
{
BaselineICEntry
&
ent
=
icEntry
(
i
)
;
ent
.
trace
(
trc
)
;
}
}
void
BaselineScript
:
:
writeBarrierPre
(
Zone
*
zone
BaselineScript
*
script
)
{
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
script
-
>
trace
(
zone
-
>
barrierTracer
(
)
)
;
}
void
BaselineScript
:
:
Trace
(
JSTracer
*
trc
BaselineScript
*
script
)
{
script
-
>
trace
(
trc
)
;
}
void
BaselineScript
:
:
Destroy
(
FreeOp
*
fop
BaselineScript
*
script
)
{
MOZ_ASSERT
(
!
script
-
>
hasPendingIonBuilder
(
)
)
;
script
-
>
unlinkDependentWasmImports
(
fop
)
;
script
-
>
fallbackStubSpace_
.
freeAllAfterMinorGC
(
script
-
>
method
(
)
-
>
zone
(
)
)
;
fop
-
>
delete_
(
script
)
;
}
void
JS
:
:
DeletePolicy
<
js
:
:
jit
:
:
BaselineScript
>
:
:
operator
(
)
(
const
js
:
:
jit
:
:
BaselineScript
*
script
)
{
BaselineScript
:
:
Destroy
(
rt_
-
>
defaultFreeOp
(
)
const_cast
<
BaselineScript
*
>
(
script
)
)
;
}
void
BaselineScript
:
:
clearDependentWasmImports
(
)
{
if
(
dependentWasmImports_
)
{
for
(
DependentWasmImport
&
dep
:
*
dependentWasmImports_
)
dep
.
instance
-
>
deoptimizeImportExit
(
dep
.
importIndex
)
;
dependentWasmImports_
-
>
clear
(
)
;
}
}
void
BaselineScript
:
:
unlinkDependentWasmImports
(
FreeOp
*
fop
)
{
clearDependentWasmImports
(
)
;
if
(
dependentWasmImports_
)
{
fop
-
>
delete_
(
dependentWasmImports_
)
;
dependentWasmImports_
=
nullptr
;
}
}
bool
BaselineScript
:
:
addDependentWasmImport
(
JSContext
*
cx
wasm
:
:
Instance
&
instance
uint32_t
idx
)
{
if
(
!
dependentWasmImports_
)
{
dependentWasmImports_
=
cx
-
>
new_
<
Vector
<
DependentWasmImport
>
>
(
cx
)
;
if
(
!
dependentWasmImports_
)
return
false
;
}
return
dependentWasmImports_
-
>
emplaceBack
(
instance
idx
)
;
}
void
BaselineScript
:
:
removeDependentWasmImport
(
wasm
:
:
Instance
&
instance
uint32_t
idx
)
{
if
(
!
dependentWasmImports_
)
return
;
for
(
DependentWasmImport
&
dep
:
*
dependentWasmImports_
)
{
if
(
dep
.
instance
=
=
&
instance
&
&
dep
.
importIndex
=
=
idx
)
{
dependentWasmImports_
-
>
erase
(
&
dep
)
;
break
;
}
}
}
BaselineICEntry
&
BaselineScript
:
:
icEntry
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numICEntries
(
)
)
;
return
icEntryList
(
)
[
index
]
;
}
PCMappingIndexEntry
&
BaselineScript
:
:
pcMappingIndexEntry
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numPCMappingIndexEntries
(
)
)
;
return
pcMappingIndexEntryList
(
)
[
index
]
;
}
CompactBufferReader
BaselineScript
:
:
pcMappingReader
(
size_t
indexEntry
)
{
PCMappingIndexEntry
&
entry
=
pcMappingIndexEntry
(
indexEntry
)
;
uint8_t
*
dataStart
=
pcMappingData
(
)
+
entry
.
bufferOffset
;
uint8_t
*
dataEnd
=
(
indexEntry
=
=
numPCMappingIndexEntries
(
)
-
1
)
?
pcMappingData
(
)
+
pcMappingSize_
:
pcMappingData
(
)
+
pcMappingIndexEntry
(
indexEntry
+
1
)
.
bufferOffset
;
return
CompactBufferReader
(
dataStart
dataEnd
)
;
}
struct
ICEntries
{
BaselineScript
*
const
baseline_
;
explicit
ICEntries
(
BaselineScript
*
baseline
)
:
baseline_
(
baseline
)
{
}
BaselineICEntry
&
operator
[
]
(
size_t
index
)
const
{
return
baseline_
-
>
icEntry
(
index
)
;
}
}
;
BaselineICEntry
&
BaselineScript
:
:
icEntryFromReturnOffset
(
CodeOffset
returnOffset
)
{
size_t
loc
;
#
ifdef
DEBUG
bool
found
=
#
endif
BinarySearchIf
(
ICEntries
(
this
)
0
numICEntries
(
)
[
&
returnOffset
]
(
BaselineICEntry
&
entry
)
{
size_t
roffset
=
returnOffset
.
offset
(
)
;
size_t
entryRoffset
=
entry
.
returnOffset
(
)
.
offset
(
)
;
if
(
roffset
<
entryRoffset
)
return
-
1
;
if
(
entryRoffset
<
roffset
)
return
1
;
return
0
;
}
&
loc
)
;
MOZ_ASSERT
(
found
)
;
MOZ_ASSERT
(
loc
<
numICEntries
(
)
)
;
MOZ_ASSERT
(
icEntry
(
loc
)
.
returnOffset
(
)
.
offset
(
)
=
=
returnOffset
.
offset
(
)
)
;
return
icEntry
(
loc
)
;
}
static
inline
size_t
ComputeBinarySearchMid
(
BaselineScript
*
baseline
uint32_t
pcOffset
)
{
size_t
loc
;
BinarySearchIf
(
ICEntries
(
baseline
)
0
baseline
-
>
numICEntries
(
)
[
pcOffset
]
(
BaselineICEntry
&
entry
)
{
uint32_t
entryOffset
=
entry
.
pcOffset
(
)
;
if
(
pcOffset
<
entryOffset
)
return
-
1
;
if
(
entryOffset
<
pcOffset
)
return
1
;
return
0
;
}
&
loc
)
;
return
loc
;
}
uint8_t
*
BaselineScript
:
:
returnAddressForIC
(
const
BaselineICEntry
&
ent
)
{
return
method
(
)
-
>
raw
(
)
+
ent
.
returnOffset
(
)
.
offset
(
)
;
}
BaselineICEntry
&
BaselineScript
:
:
icEntryFromPCOffset
(
uint32_t
pcOffset
)
{
size_t
mid
=
ComputeBinarySearchMid
(
this
pcOffset
)
;
for
(
size_t
i
=
mid
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
pcOffset
;
i
-
-
)
{
if
(
icEntry
(
i
)
.
isForOp
(
)
)
return
icEntry
(
i
)
;
}
for
(
size_t
i
=
mid
+
1
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
pcOffset
;
i
+
+
)
{
if
(
icEntry
(
i
)
.
isForOp
(
)
)
return
icEntry
(
i
)
;
}
MOZ_CRASH
(
"
Invalid
PC
offset
for
IC
entry
.
"
)
;
}
BaselineICEntry
&
BaselineScript
:
:
icEntryFromPCOffset
(
uint32_t
pcOffset
BaselineICEntry
*
prevLookedUpEntry
)
{
if
(
prevLookedUpEntry
&
&
pcOffset
>
=
prevLookedUpEntry
-
>
pcOffset
(
)
&
&
(
pcOffset
-
prevLookedUpEntry
-
>
pcOffset
(
)
)
<
=
10
)
{
BaselineICEntry
*
firstEntry
=
&
icEntry
(
0
)
;
BaselineICEntry
*
lastEntry
=
&
icEntry
(
numICEntries
(
)
-
1
)
;
BaselineICEntry
*
curEntry
=
prevLookedUpEntry
;
while
(
curEntry
>
=
firstEntry
&
&
curEntry
<
=
lastEntry
)
{
if
(
curEntry
-
>
pcOffset
(
)
=
=
pcOffset
&
&
curEntry
-
>
isForOp
(
)
)
break
;
curEntry
+
+
;
}
MOZ_ASSERT
(
curEntry
-
>
pcOffset
(
)
=
=
pcOffset
&
&
curEntry
-
>
isForOp
(
)
)
;
return
*
curEntry
;
}
return
icEntryFromPCOffset
(
pcOffset
)
;
}
BaselineICEntry
&
BaselineScript
:
:
callVMEntryFromPCOffset
(
uint32_t
pcOffset
)
{
size_t
mid
=
ComputeBinarySearchMid
(
this
pcOffset
)
;
for
(
size_t
i
=
mid
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
pcOffset
;
i
-
-
)
{
if
(
icEntry
(
i
)
.
kind
(
)
=
=
ICEntry
:
:
Kind_CallVM
)
return
icEntry
(
i
)
;
}
for
(
size_t
i
=
mid
+
1
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
pcOffset
;
i
+
+
)
{
if
(
icEntry
(
i
)
.
kind
(
)
=
=
ICEntry
:
:
Kind_CallVM
)
return
icEntry
(
i
)
;
}
MOZ_CRASH
(
"
Invalid
PC
offset
for
callVM
entry
.
"
)
;
}
BaselineICEntry
&
BaselineScript
:
:
stackCheckICEntry
(
bool
earlyCheck
)
{
ICEntry
:
:
Kind
kind
=
earlyCheck
?
ICEntry
:
:
Kind_EarlyStackCheck
:
ICEntry
:
:
Kind_StackCheck
;
for
(
size_t
i
=
0
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
0
;
i
+
+
)
{
if
(
icEntry
(
i
)
.
kind
(
)
=
=
kind
)
return
icEntry
(
i
)
;
}
MOZ_CRASH
(
"
No
stack
check
ICEntry
found
.
"
)
;
}
BaselineICEntry
&
BaselineScript
:
:
warmupCountICEntry
(
)
{
for
(
size_t
i
=
0
;
i
<
numICEntries
(
)
&
&
icEntry
(
i
)
.
pcOffset
(
)
=
=
0
;
i
+
+
)
{
if
(
icEntry
(
i
)
.
kind
(
)
=
=
ICEntry
:
:
Kind_WarmupCounter
)
return
icEntry
(
i
)
;
}
MOZ_CRASH
(
"
No
warmup
count
ICEntry
found
.
"
)
;
}
BaselineICEntry
&
BaselineScript
:
:
icEntryFromReturnAddress
(
uint8_t
*
returnAddr
)
{
MOZ_ASSERT
(
returnAddr
>
method_
-
>
raw
(
)
)
;
MOZ_ASSERT
(
returnAddr
<
method_
-
>
raw
(
)
+
method_
-
>
instructionsSize
(
)
)
;
CodeOffset
offset
(
returnAddr
-
method_
-
>
raw
(
)
)
;
return
icEntryFromReturnOffset
(
offset
)
;
}
void
BaselineScript
:
:
copyYieldEntries
(
JSScript
*
script
Vector
<
uint32_t
>
&
yieldOffsets
)
{
uint8_t
*
*
entries
=
yieldEntryList
(
)
;
for
(
size_t
i
=
0
;
i
<
yieldOffsets
.
length
(
)
;
i
+
+
)
{
uint32_t
offset
=
yieldOffsets
[
i
]
;
entries
[
i
]
=
nativeCodeForPC
(
script
script
-
>
offsetToPC
(
offset
)
)
;
}
}
void
BaselineScript
:
:
copyICEntries
(
JSScript
*
script
const
BaselineICEntry
*
entries
MacroAssembler
&
masm
)
{
for
(
uint32_t
i
=
0
;
i
<
numICEntries
(
)
;
i
+
+
)
{
BaselineICEntry
&
realEntry
=
icEntry
(
i
)
;
realEntry
=
entries
[
i
]
;
if
(
!
realEntry
.
hasStub
(
)
)
{
continue
;
}
if
(
realEntry
.
firstStub
(
)
-
>
isFallback
(
)
)
realEntry
.
firstStub
(
)
-
>
toFallbackStub
(
)
-
>
fixupICEntry
(
&
realEntry
)
;
if
(
realEntry
.
firstStub
(
)
-
>
isTypeMonitor_Fallback
(
)
)
{
ICTypeMonitor_Fallback
*
stub
=
realEntry
.
firstStub
(
)
-
>
toTypeMonitor_Fallback
(
)
;
stub
-
>
fixupICEntry
(
&
realEntry
)
;
}
if
(
realEntry
.
firstStub
(
)
-
>
isTableSwitch
(
)
)
{
ICTableSwitch
*
stub
=
realEntry
.
firstStub
(
)
-
>
toTableSwitch
(
)
;
stub
-
>
fixupJumpTable
(
script
this
)
;
}
}
}
void
BaselineScript
:
:
adoptFallbackStubs
(
FallbackICStubSpace
*
stubSpace
)
{
fallbackStubSpace_
.
adoptFrom
(
stubSpace
)
;
}
void
BaselineScript
:
:
copyPCMappingEntries
(
const
CompactBufferWriter
&
entries
)
{
MOZ_ASSERT
(
entries
.
length
(
)
>
0
)
;
MOZ_ASSERT
(
entries
.
length
(
)
=
=
pcMappingSize_
)
;
memcpy
(
pcMappingData
(
)
entries
.
buffer
(
)
entries
.
length
(
)
)
;
}
void
BaselineScript
:
:
copyPCMappingIndexEntries
(
const
PCMappingIndexEntry
*
entries
)
{
for
(
uint32_t
i
=
0
;
i
<
numPCMappingIndexEntries
(
)
;
i
+
+
)
pcMappingIndexEntry
(
i
)
=
entries
[
i
]
;
}
uint8_t
*
BaselineScript
:
:
nativeCodeForPC
(
JSScript
*
script
jsbytecode
*
pc
PCMappingSlotInfo
*
slotInfo
)
{
MOZ_ASSERT_IF
(
script
-
>
hasBaselineScript
(
)
script
-
>
baselineScript
(
)
=
=
this
)
;
uint32_t
pcOffset
=
script
-
>
pcToOffset
(
pc
)
;
uint32_t
i
=
1
;
for
(
;
i
<
numPCMappingIndexEntries
(
)
;
i
+
+
)
{
if
(
pcMappingIndexEntry
(
i
)
.
pcOffset
>
pcOffset
)
break
;
}
MOZ_ASSERT
(
i
>
0
)
;
i
-
-
;
PCMappingIndexEntry
&
entry
=
pcMappingIndexEntry
(
i
)
;
MOZ_ASSERT
(
pcOffset
>
=
entry
.
pcOffset
)
;
CompactBufferReader
reader
(
pcMappingReader
(
i
)
)
;
jsbytecode
*
curPC
=
script
-
>
offsetToPC
(
entry
.
pcOffset
)
;
uint32_t
nativeOffset
=
entry
.
nativeOffset
;
MOZ_ASSERT
(
script
-
>
containsPC
(
curPC
)
)
;
MOZ_ASSERT
(
curPC
<
=
pc
)
;
while
(
reader
.
more
(
)
)
{
uint8_t
b
=
reader
.
readByte
(
)
;
if
(
b
&
0x80
)
nativeOffset
+
=
reader
.
readUnsigned
(
)
;
if
(
curPC
=
=
pc
)
{
if
(
slotInfo
)
*
slotInfo
=
PCMappingSlotInfo
(
b
&
~
0x80
)
;
return
method_
-
>
raw
(
)
+
nativeOffset
;
}
curPC
+
=
GetBytecodeLength
(
curPC
)
;
}
MOZ_CRASH
(
"
No
native
code
for
this
pc
"
)
;
}
jsbytecode
*
BaselineScript
:
:
approximatePcForNativeAddress
(
JSScript
*
script
uint8_t
*
nativeAddress
)
{
MOZ_ASSERT
(
script
-
>
baselineScript
(
)
=
=
this
)
;
MOZ_ASSERT
(
nativeAddress
>
=
method_
-
>
raw
(
)
)
;
MOZ_ASSERT
(
nativeAddress
<
method_
-
>
raw
(
)
+
method_
-
>
instructionsSize
(
)
)
;
uint32_t
nativeOffset
=
nativeAddress
-
method_
-
>
raw
(
)
;
MOZ_ASSERT
(
nativeOffset
<
method_
-
>
instructionsSize
(
)
)
;
uint32_t
i
=
1
;
for
(
;
i
<
numPCMappingIndexEntries
(
)
;
i
+
+
)
{
if
(
pcMappingIndexEntry
(
i
)
.
nativeOffset
>
nativeOffset
)
break
;
}
MOZ_ASSERT
(
i
>
0
)
;
i
-
-
;
PCMappingIndexEntry
&
entry
=
pcMappingIndexEntry
(
i
)
;
CompactBufferReader
reader
(
pcMappingReader
(
i
)
)
;
jsbytecode
*
curPC
=
script
-
>
offsetToPC
(
entry
.
pcOffset
)
;
uint32_t
curNativeOffset
=
entry
.
nativeOffset
;
MOZ_ASSERT
(
script
-
>
containsPC
(
curPC
)
)
;
if
(
curNativeOffset
>
nativeOffset
)
return
script
-
>
code
(
)
;
jsbytecode
*
lastPC
=
curPC
;
while
(
true
)
{
uint8_t
b
=
reader
.
readByte
(
)
;
if
(
b
&
0x80
)
curNativeOffset
+
=
reader
.
readUnsigned
(
)
;
if
(
curNativeOffset
>
nativeOffset
)
return
lastPC
;
if
(
!
reader
.
more
(
)
)
return
curPC
;
lastPC
=
curPC
;
curPC
+
=
GetBytecodeLength
(
curPC
)
;
}
}
void
BaselineScript
:
:
toggleDebugTraps
(
JSScript
*
script
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
script
-
>
baselineScript
(
)
=
=
this
)
;
if
(
!
hasDebugInstrumentation
(
)
)
return
;
SrcNoteLineScanner
scanner
(
script
-
>
notes
(
)
script
-
>
lineno
(
)
)
;
AutoWritableJitCode
awjc
(
method
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numPCMappingIndexEntries
(
)
;
i
+
+
)
{
PCMappingIndexEntry
&
entry
=
pcMappingIndexEntry
(
i
)
;
CompactBufferReader
reader
(
pcMappingReader
(
i
)
)
;
jsbytecode
*
curPC
=
script
-
>
offsetToPC
(
entry
.
pcOffset
)
;
uint32_t
nativeOffset
=
entry
.
nativeOffset
;
MOZ_ASSERT
(
script
-
>
containsPC
(
curPC
)
)
;
while
(
reader
.
more
(
)
)
{
uint8_t
b
=
reader
.
readByte
(
)
;
if
(
b
&
0x80
)
nativeOffset
+
=
reader
.
readUnsigned
(
)
;
scanner
.
advanceTo
(
script
-
>
pcToOffset
(
curPC
)
)
;
if
(
!
pc
|
|
pc
=
=
curPC
)
{
bool
enabled
=
(
script
-
>
stepModeEnabled
(
)
&
&
scanner
.
isLineHeader
(
)
)
|
|
script
-
>
hasBreakpointsAt
(
curPC
)
;
CodeLocationLabel
label
(
method
(
)
CodeOffset
(
nativeOffset
)
)
;
Assembler
:
:
ToggleCall
(
label
enabled
)
;
}
curPC
+
=
GetBytecodeLength
(
curPC
)
;
}
}
}
#
ifdef
JS_TRACE_LOGGING
void
BaselineScript
:
:
initTraceLogger
(
JSRuntime
*
runtime
JSScript
*
script
const
Vector
<
CodeOffset
>
&
offsets
)
{
#
ifdef
DEBUG
traceLoggerScriptsEnabled_
=
TraceLogTextIdEnabled
(
TraceLogger_Scripts
)
;
traceLoggerEngineEnabled_
=
TraceLogTextIdEnabled
(
TraceLogger_Engine
)
;
#
endif
MOZ_ASSERT
(
offsets
.
length
(
)
=
=
numTraceLoggerToggleOffsets_
)
;
for
(
size_t
i
=
0
;
i
<
offsets
.
length
(
)
;
i
+
+
)
traceLoggerToggleOffsets
(
)
[
i
]
=
offsets
[
i
]
.
offset
(
)
;
if
(
TraceLogTextIdEnabled
(
TraceLogger_Engine
)
|
|
TraceLogTextIdEnabled
(
TraceLogger_Scripts
)
)
{
traceLoggerScriptEvent_
=
TraceLoggerEvent
(
TraceLogger_Scripts
script
)
;
for
(
size_t
i
=
0
;
i
<
numTraceLoggerToggleOffsets_
;
i
+
+
)
{
CodeLocationLabel
label
(
method_
CodeOffset
(
traceLoggerToggleOffsets
(
)
[
i
]
)
)
;
Assembler
:
:
ToggleToCmp
(
label
)
;
}
}
}
void
BaselineScript
:
:
toggleTraceLoggerScripts
(
JSRuntime
*
runtime
JSScript
*
script
bool
enable
)
{
DebugOnly
<
bool
>
engineEnabled
=
TraceLogTextIdEnabled
(
TraceLogger_Engine
)
;
MOZ_ASSERT
(
enable
=
=
!
traceLoggerScriptsEnabled_
)
;
MOZ_ASSERT
(
engineEnabled
=
=
traceLoggerEngineEnabled_
)
;
if
(
enable
&
&
!
traceLoggerScriptEvent_
.
hasPayload
(
)
)
traceLoggerScriptEvent_
=
TraceLoggerEvent
(
TraceLogger_Scripts
script
)
;
AutoWritableJitCode
awjc
(
method
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numTraceLoggerToggleOffsets_
;
i
+
+
)
{
CodeLocationLabel
label
(
method_
CodeOffset
(
traceLoggerToggleOffsets
(
)
[
i
]
)
)
;
if
(
enable
)
Assembler
:
:
ToggleToCmp
(
label
)
;
else
Assembler
:
:
ToggleToJmp
(
label
)
;
}
#
if
DEBUG
traceLoggerScriptsEnabled_
=
enable
;
#
endif
}
void
BaselineScript
:
:
toggleTraceLoggerEngine
(
bool
enable
)
{
DebugOnly
<
bool
>
scriptsEnabled
=
TraceLogTextIdEnabled
(
TraceLogger_Scripts
)
;
MOZ_ASSERT
(
enable
=
=
!
traceLoggerEngineEnabled_
)
;
MOZ_ASSERT
(
scriptsEnabled
=
=
traceLoggerScriptsEnabled_
)
;
AutoWritableJitCode
awjc
(
method
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numTraceLoggerToggleOffsets_
;
i
+
+
)
{
CodeLocationLabel
label
(
method_
CodeOffset
(
traceLoggerToggleOffsets
(
)
[
i
]
)
)
;
if
(
enable
)
Assembler
:
:
ToggleToCmp
(
label
)
;
else
Assembler
:
:
ToggleToJmp
(
label
)
;
}
#
if
DEBUG
traceLoggerEngineEnabled_
=
enable
;
#
endif
}
#
endif
void
BaselineScript
:
:
toggleProfilerInstrumentation
(
bool
enable
)
{
if
(
enable
=
=
isProfilerInstrumentationOn
(
)
)
return
;
JitSpew
(
JitSpew_BaselineIC
"
toggling
profiling
%
s
for
BaselineScript
%
p
"
enable
?
"
on
"
:
"
off
"
this
)
;
CodeLocationLabel
enterToggleLocation
(
method_
CodeOffset
(
profilerEnterToggleOffset_
)
)
;
CodeLocationLabel
exitToggleLocation
(
method_
CodeOffset
(
profilerExitToggleOffset_
)
)
;
if
(
enable
)
{
Assembler
:
:
ToggleToCmp
(
enterToggleLocation
)
;
Assembler
:
:
ToggleToCmp
(
exitToggleLocation
)
;
flags_
|
=
uint32_t
(
PROFILER_INSTRUMENTATION_ON
)
;
}
else
{
Assembler
:
:
ToggleToJmp
(
enterToggleLocation
)
;
Assembler
:
:
ToggleToJmp
(
exitToggleLocation
)
;
flags_
&
=
~
uint32_t
(
PROFILER_INSTRUMENTATION_ON
)
;
}
}
void
BaselineScript
:
:
purgeOptimizedStubs
(
Zone
*
zone
)
{
JitSpew
(
JitSpew_BaselineIC
"
Purging
optimized
stubs
"
)
;
for
(
size_t
i
=
0
;
i
<
numICEntries
(
)
;
i
+
+
)
{
BaselineICEntry
&
entry
=
icEntry
(
i
)
;
if
(
!
entry
.
hasStub
(
)
)
continue
;
ICStub
*
lastStub
=
entry
.
firstStub
(
)
;
while
(
lastStub
-
>
next
(
)
)
lastStub
=
lastStub
-
>
next
(
)
;
if
(
lastStub
-
>
isFallback
(
)
)
{
ICStub
*
stub
=
entry
.
firstStub
(
)
;
ICStub
*
prev
=
nullptr
;
while
(
stub
-
>
next
(
)
)
{
if
(
!
stub
-
>
allocatedInFallbackSpace
(
)
)
{
lastStub
-
>
toFallbackStub
(
)
-
>
unlinkStub
(
zone
prev
stub
)
;
stub
=
stub
-
>
next
(
)
;
continue
;
}
prev
=
stub
;
stub
=
stub
-
>
next
(
)
;
}
if
(
lastStub
-
>
isMonitoredFallback
(
)
)
{
ICTypeMonitor_Fallback
*
lastMonStub
=
lastStub
-
>
toMonitoredFallbackStub
(
)
-
>
fallbackMonitorStub
(
)
;
lastMonStub
-
>
resetMonitorStubChain
(
zone
)
;
}
}
else
if
(
lastStub
-
>
isTypeMonitor_Fallback
(
)
)
{
lastStub
-
>
toTypeMonitor_Fallback
(
)
-
>
resetMonitorStubChain
(
zone
)
;
}
else
{
MOZ_ASSERT
(
lastStub
-
>
isTableSwitch
(
)
)
;
}
}
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
numICEntries
(
)
;
i
+
+
)
{
BaselineICEntry
&
entry
=
icEntry
(
i
)
;
if
(
!
entry
.
hasStub
(
)
)
continue
;
ICStub
*
stub
=
entry
.
firstStub
(
)
;
while
(
stub
-
>
next
(
)
)
{
MOZ_ASSERT
(
stub
-
>
allocatedInFallbackSpace
(
)
)
;
stub
=
stub
-
>
next
(
)
;
}
}
#
endif
}
void
jit
:
:
FinishDiscardBaselineScript
(
FreeOp
*
fop
JSScript
*
script
)
{
if
(
!
script
-
>
hasBaselineScript
(
)
)
return
;
if
(
script
-
>
baselineScript
(
)
-
>
active
(
)
)
{
script
-
>
baselineScript
(
)
-
>
purgeOptimizedStubs
(
script
-
>
zone
(
)
)
;
script
-
>
baselineScript
(
)
-
>
resetActive
(
)
;
script
-
>
baselineScript
(
)
-
>
clearIonCompiledOrInlined
(
)
;
return
;
}
BaselineScript
*
baseline
=
script
-
>
baselineScript
(
)
;
script
-
>
setBaselineScript
(
nullptr
nullptr
)
;
BaselineScript
:
:
Destroy
(
fop
baseline
)
;
}
void
jit
:
:
AddSizeOfBaselineData
(
JSScript
*
script
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
size_t
*
fallbackStubs
)
{
if
(
script
-
>
hasBaselineScript
(
)
)
script
-
>
baselineScript
(
)
-
>
addSizeOfIncludingThis
(
mallocSizeOf
data
fallbackStubs
)
;
}
void
jit
:
:
ToggleBaselineProfiling
(
JSRuntime
*
runtime
bool
enable
)
{
JitRuntime
*
jrt
=
runtime
-
>
jitRuntime
(
)
;
if
(
!
jrt
)
return
;
for
(
ZonesIter
zone
(
runtime
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
script
=
zone
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
!
script
-
>
hasBaselineScript
(
)
)
continue
;
AutoWritableJitCode
awjc
(
script
-
>
baselineScript
(
)
-
>
method
(
)
)
;
script
-
>
baselineScript
(
)
-
>
toggleProfilerInstrumentation
(
enable
)
;
}
}
}
#
ifdef
JS_TRACE_LOGGING
void
jit
:
:
ToggleBaselineTraceLoggerScripts
(
JSRuntime
*
runtime
bool
enable
)
{
for
(
ZonesIter
zone
(
runtime
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
script
=
zone
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
!
script
-
>
hasBaselineScript
(
)
)
continue
;
script
-
>
baselineScript
(
)
-
>
toggleTraceLoggerScripts
(
runtime
script
enable
)
;
}
}
}
void
jit
:
:
ToggleBaselineTraceLoggerEngine
(
JSRuntime
*
runtime
bool
enable
)
{
for
(
ZonesIter
zone
(
runtime
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
script
=
zone
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
!
script
-
>
hasBaselineScript
(
)
)
continue
;
script
-
>
baselineScript
(
)
-
>
toggleTraceLoggerEngine
(
enable
)
;
}
}
}
#
endif
static
void
MarkActiveBaselineScripts
(
JSContext
*
cx
const
JitActivationIterator
&
activation
)
{
for
(
jit
:
:
JitFrameIterator
iter
(
activation
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
switch
(
iter
.
type
(
)
)
{
case
JitFrame_BaselineJS
:
iter
.
script
(
)
-
>
baselineScript
(
)
-
>
setActive
(
)
;
break
;
case
JitFrame_Exit
:
if
(
iter
.
exitFrame
(
)
-
>
is
<
LazyLinkExitFrameLayout
>
(
)
)
{
LazyLinkExitFrameLayout
*
ll
=
iter
.
exitFrame
(
)
-
>
as
<
LazyLinkExitFrameLayout
>
(
)
;
ScriptFromCalleeToken
(
ll
-
>
jsFrame
(
)
-
>
calleeToken
(
)
)
-
>
baselineScript
(
)
-
>
setActive
(
)
;
}
break
;
case
JitFrame_Bailout
:
case
JitFrame_IonJS
:
{
iter
.
script
(
)
-
>
baselineScript
(
)
-
>
setActive
(
)
;
for
(
InlineFrameIterator
inlineIter
(
cx
&
iter
)
;
inlineIter
.
more
(
)
;
+
+
inlineIter
)
inlineIter
.
script
(
)
-
>
baselineScript
(
)
-
>
setActive
(
)
;
break
;
}
default
:
;
}
}
}
void
jit
:
:
MarkActiveBaselineScripts
(
Zone
*
zone
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
return
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
for
(
JitActivationIterator
iter
(
cx
zone
-
>
group
(
)
-
>
ownerContext
(
)
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
iter
-
>
compartment
(
)
-
>
zone
(
)
=
=
zone
)
MarkActiveBaselineScripts
(
cx
iter
)
;
}
}
