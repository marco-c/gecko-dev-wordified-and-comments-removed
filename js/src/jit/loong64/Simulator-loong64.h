#
ifndef
jit_loong64_Simulator_loong64_h
#
define
jit_loong64_Simulator_loong64_h
#
ifdef
JS_SIMULATOR_LOONG64
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
namespace
js
{
namespace
jit
{
class
JitActivation
;
class
Simulator
;
class
Redirection
;
class
CachePage
;
class
AutoLockSimulator
;
typedef
void
(
*
SingleStepCallback
)
(
void
*
arg
Simulator
*
sim
void
*
pc
)
;
const
intptr_t
kPointerAlignment
=
8
;
const
intptr_t
kPointerAlignmentMask
=
kPointerAlignment
-
1
;
const
intptr_t
kDoubleAlignment
=
8
;
const
intptr_t
kDoubleAlignmentMask
=
kDoubleAlignment
-
1
;
const
int
kNumRegisters
=
32
;
const
int
kPCRegister
=
32
;
const
int
kNumFPURegisters
=
32
;
const
int
kFCSRRegister
=
0
;
const
int
kInvalidFPUControlRegister
=
-
1
;
const
uint32_t
kFPUInvalidResult
=
static_cast
<
uint32_t
>
(
1
<
<
31
)
-
1
;
const
int32_t
kFPUInvalidResultNegative
=
static_cast
<
int32_t
>
(
1u
<
<
31
)
;
const
uint64_t
kFPU64InvalidResult
=
static_cast
<
uint64_t
>
(
static_cast
<
uint64_t
>
(
1
)
<
<
63
)
-
1
;
const
int64_t
kFPU64InvalidResultNegative
=
static_cast
<
int64_t
>
(
static_cast
<
uint64_t
>
(
1
)
<
<
63
)
;
const
uint32_t
kFPURoundingModeShift
=
8
;
const
uint32_t
kFPURoundingModeMask
=
0b11
<
<
kFPURoundingModeShift
;
enum
FPURoundingMode
{
RN
=
0b00
<
<
kFPURoundingModeShift
RZ
=
0b01
<
<
kFPURoundingModeShift
RP
=
0b10
<
<
kFPURoundingModeShift
RM
=
0b11
<
<
kFPURoundingModeShift
kRoundToNearest
=
RN
kRoundToZero
=
RZ
kRoundToPlusInf
=
RP
kRoundToMinusInf
=
RM
mode_round
=
RN
mode_ceil
=
RP
mode_floor
=
RM
mode_trunc
=
RZ
}
;
const
uint32_t
kFCSRInexactFlagBit
=
16
;
const
uint32_t
kFCSRUnderflowFlagBit
=
17
;
const
uint32_t
kFCSROverflowFlagBit
=
18
;
const
uint32_t
kFCSRDivideByZeroFlagBit
=
19
;
const
uint32_t
kFCSRInvalidOpFlagBit
=
20
;
const
uint32_t
kFCSRInexactCauseBit
=
24
;
const
uint32_t
kFCSRUnderflowCauseBit
=
25
;
const
uint32_t
kFCSROverflowCauseBit
=
26
;
const
uint32_t
kFCSRDivideByZeroCauseBit
=
27
;
const
uint32_t
kFCSRInvalidOpCauseBit
=
28
;
const
uint32_t
kFCSRInexactFlagMask
=
1
<
<
kFCSRInexactFlagBit
;
const
uint32_t
kFCSRUnderflowFlagMask
=
1
<
<
kFCSRUnderflowFlagBit
;
const
uint32_t
kFCSROverflowFlagMask
=
1
<
<
kFCSROverflowFlagBit
;
const
uint32_t
kFCSRDivideByZeroFlagMask
=
1
<
<
kFCSRDivideByZeroFlagBit
;
const
uint32_t
kFCSRInvalidOpFlagMask
=
1
<
<
kFCSRInvalidOpFlagBit
;
const
uint32_t
kFCSRFlagMask
=
kFCSRInexactFlagMask
|
kFCSRUnderflowFlagMask
|
kFCSROverflowFlagMask
|
kFCSRDivideByZeroFlagMask
|
kFCSRInvalidOpFlagMask
;
const
uint32_t
kFCSRExceptionFlagMask
=
kFCSRFlagMask
^
kFCSRInexactFlagMask
;
const
uint32_t
kMaxWatchpointCode
=
31
;
const
uint32_t
kMaxStopCode
=
127
;
const
uint32_t
kWasmTrapCode
=
6
;
typedef
uint32_t
Instr
;
class
SimInstruction
;
class
Simulator
{
friend
class
loong64Debugger
;
public
:
enum
Register
{
no_reg
=
-
1
zero_reg
=
0
ra
gp
sp
a0
a1
a2
a3
a4
a5
a6
a7
t0
t1
t2
t3
t4
t5
t6
t7
t8
tp
fp
s0
s1
s2
s3
s4
s5
s6
s7
s8
pc
kNumSimuRegisters
v0
=
a0
v1
=
a1
}
;
enum
CFRegister
{
fcc0
fcc1
fcc2
fcc3
fcc4
fcc5
fcc6
fcc7
kNumCFRegisters
}
;
enum
FPURegister
{
f0
f1
f2
f3
f4
f5
f6
f7
f8
f9
f10
f11
f12
f13
f14
f15
f16
f17
f18
f19
f20
f21
f22
f23
f24
f25
f26
f27
f28
f29
f30
f31
kNumFPURegisters
}
;
static
Simulator
*
Create
(
)
;
static
void
Destroy
(
Simulator
*
simulator
)
;
Simulator
(
)
;
~
Simulator
(
)
;
static
Simulator
*
Current
(
)
;
static
inline
uintptr_t
StackLimit
(
)
{
return
Simulator
:
:
Current
(
)
-
>
stackLimit
(
)
;
}
uintptr_t
*
addressOfStackLimit
(
)
;
void
setRegister
(
int
reg
int64_t
value
)
;
int64_t
getRegister
(
int
reg
)
const
;
void
setFpuRegister
(
int
fpureg
int64_t
value
)
;
void
setFpuRegisterWord
(
int
fpureg
int32_t
value
)
;
void
setFpuRegisterHiWord
(
int
fpureg
int32_t
value
)
;
void
setFpuRegisterFloat
(
int
fpureg
float
value
)
;
void
setFpuRegisterDouble
(
int
fpureg
double
value
)
;
void
setFpuRegisterWordInvalidResult
(
float
original
float
rounded
int
fpureg
)
;
void
setFpuRegisterWordInvalidResult
(
double
original
double
rounded
int
fpureg
)
;
void
setFpuRegisterInvalidResult
(
float
original
float
rounded
int
fpureg
)
;
void
setFpuRegisterInvalidResult
(
double
original
double
rounded
int
fpureg
)
;
void
setFpuRegisterInvalidResult64
(
float
original
float
rounded
int
fpureg
)
;
void
setFpuRegisterInvalidResult64
(
double
original
double
rounded
int
fpureg
)
;
int64_t
getFpuRegister
(
int
fpureg
)
const
;
int32_t
getFpuRegisterWord
(
int
fpureg
)
const
;
int32_t
getFpuRegisterSignedWord
(
int
fpureg
)
const
;
int32_t
getFpuRegisterHiWord
(
int
fpureg
)
const
;
float
getFpuRegisterFloat
(
int
fpureg
)
const
;
double
getFpuRegisterDouble
(
int
fpureg
)
const
;
void
setCFRegister
(
int
cfreg
bool
value
)
;
bool
getCFRegister
(
int
cfreg
)
const
;
void
set_fcsr_rounding_mode
(
FPURoundingMode
mode
)
;
void
setFCSRBit
(
uint32_t
cc
bool
value
)
;
bool
testFCSRBit
(
uint32_t
cc
)
;
unsigned
int
getFCSRRoundingMode
(
)
;
template
<
typename
T
>
bool
setFCSRRoundError
(
double
original
double
rounded
)
;
bool
setFCSRRound64Error
(
float
original
float
rounded
)
;
template
<
typename
T
>
void
roundAccordingToFCSR
(
T
toRound
T
*
rounded
int32_t
*
rounded_int
)
;
template
<
typename
T
>
void
round64AccordingToFCSR
(
T
toRound
T
*
rounded
int64_t
*
rounded_int
)
;
void
set_pc
(
int64_t
value
)
;
int64_t
get_pc
(
)
const
;
template
<
typename
T
>
T
get_pc_as
(
)
const
{
return
reinterpret_cast
<
T
>
(
get_pc
(
)
)
;
}
void
enable_single_stepping
(
SingleStepCallback
cb
void
*
arg
)
;
void
disable_single_stepping
(
)
;
uintptr_t
stackLimit
(
)
const
;
bool
overRecursed
(
uintptr_t
newsp
=
0
)
const
;
bool
overRecursedWithExtra
(
uint32_t
extra
)
const
;
template
<
bool
enableStopSimAt
>
void
execute
(
)
;
int64_t
call
(
uint8_t
*
entry
int
argument_count
.
.
.
)
;
uintptr_t
pushAddress
(
uintptr_t
address
)
;
uintptr_t
popAddress
(
)
;
void
setLastDebuggerInput
(
char
*
input
)
;
char
*
lastDebuggerInput
(
)
{
return
lastDebuggerInput_
;
}
bool
has_bad_pc
(
)
const
;
private
:
enum
SpecialValues
{
bad_ra
=
-
1
end_sim_pc
=
-
2
Unpredictable
=
0xbadbeaf
}
;
bool
init
(
)
;
void
format
(
SimInstruction
*
instr
const
char
*
format
)
;
inline
uint8_t
readBU
(
uint64_t
addr
)
;
inline
int8_t
readB
(
uint64_t
addr
)
;
inline
void
writeB
(
uint64_t
addr
uint8_t
value
)
;
inline
void
writeB
(
uint64_t
addr
int8_t
value
)
;
inline
uint16_t
readHU
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
int16_t
readH
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
void
writeH
(
uint64_t
addr
uint16_t
value
SimInstruction
*
instr
)
;
inline
void
writeH
(
uint64_t
addr
int16_t
value
SimInstruction
*
instr
)
;
inline
uint32_t
readWU
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
int32_t
readW
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
void
writeW
(
uint64_t
addr
uint32_t
value
SimInstruction
*
instr
)
;
inline
void
writeW
(
uint64_t
addr
int32_t
value
SimInstruction
*
instr
)
;
inline
int64_t
readDW
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
void
writeDW
(
uint64_t
addr
int64_t
value
SimInstruction
*
instr
)
;
inline
double
readD
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
void
writeD
(
uint64_t
addr
double
value
SimInstruction
*
instr
)
;
inline
int32_t
loadLinkedW
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
int
storeConditionalW
(
uint64_t
addr
int32_t
value
SimInstruction
*
instr
)
;
inline
int64_t
loadLinkedD
(
uint64_t
addr
SimInstruction
*
instr
)
;
inline
int
storeConditionalD
(
uint64_t
addr
int64_t
value
SimInstruction
*
instr
)
;
void
decodeTypeOp6
(
SimInstruction
*
instr
)
;
void
decodeTypeOp7
(
SimInstruction
*
instr
)
;
void
decodeTypeOp8
(
SimInstruction
*
instr
)
;
void
decodeTypeOp10
(
SimInstruction
*
instr
)
;
void
decodeTypeOp11
(
SimInstruction
*
instr
)
;
void
decodeTypeOp12
(
SimInstruction
*
instr
)
;
void
decodeTypeOp14
(
SimInstruction
*
instr
)
;
void
decodeTypeOp15
(
SimInstruction
*
instr
)
;
void
decodeTypeOp16
(
SimInstruction
*
instr
)
;
void
decodeTypeOp17
(
SimInstruction
*
instr
)
;
void
decodeTypeOp22
(
SimInstruction
*
instr
)
;
void
decodeTypeOp24
(
SimInstruction
*
instr
)
;
inline
int32_t
rj_reg
(
SimInstruction
*
instr
)
const
;
inline
int64_t
rj
(
SimInstruction
*
instr
)
const
;
inline
uint64_t
rj_u
(
SimInstruction
*
instr
)
const
;
inline
int32_t
rk_reg
(
SimInstruction
*
instr
)
const
;
inline
int64_t
rk
(
SimInstruction
*
instr
)
const
;
inline
uint64_t
rk_u
(
SimInstruction
*
instr
)
const
;
inline
int32_t
rd_reg
(
SimInstruction
*
instr
)
const
;
inline
int64_t
rd
(
SimInstruction
*
instr
)
const
;
inline
uint64_t
rd_u
(
SimInstruction
*
instr
)
const
;
inline
int32_t
fa_reg
(
SimInstruction
*
instr
)
const
;
inline
float
fa_float
(
SimInstruction
*
instr
)
const
;
inline
double
fa_double
(
SimInstruction
*
instr
)
const
;
inline
int32_t
fj_reg
(
SimInstruction
*
instr
)
const
;
inline
float
fj_float
(
SimInstruction
*
instr
)
const
;
inline
double
fj_double
(
SimInstruction
*
instr
)
const
;
inline
int32_t
fk_reg
(
SimInstruction
*
instr
)
const
;
inline
float
fk_float
(
SimInstruction
*
instr
)
const
;
inline
double
fk_double
(
SimInstruction
*
instr
)
const
;
inline
int32_t
fd_reg
(
SimInstruction
*
instr
)
const
;
inline
float
fd_float
(
SimInstruction
*
instr
)
const
;
inline
double
fd_double
(
SimInstruction
*
instr
)
const
;
inline
int32_t
cj_reg
(
SimInstruction
*
instr
)
const
;
inline
bool
cj
(
SimInstruction
*
instr
)
const
;
inline
int32_t
cd_reg
(
SimInstruction
*
instr
)
const
;
inline
bool
cd
(
SimInstruction
*
instr
)
const
;
inline
int32_t
ca_reg
(
SimInstruction
*
instr
)
const
;
inline
bool
ca
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
sa2
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
sa3
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
ui5
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
ui6
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
lsbw
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
msbw
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
lsbd
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
msbd
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
cond
(
SimInstruction
*
instr
)
const
;
inline
int32_t
si12
(
SimInstruction
*
instr
)
const
;
inline
uint32_t
ui12
(
SimInstruction
*
instr
)
const
;
inline
int32_t
si14
(
SimInstruction
*
instr
)
const
;
inline
int32_t
si16
(
SimInstruction
*
instr
)
const
;
inline
int32_t
si20
(
SimInstruction
*
instr
)
const
;
void
softwareInterrupt
(
SimInstruction
*
instr
)
;
bool
isWatchpoint
(
uint32_t
code
)
;
void
printWatchpoint
(
uint32_t
code
)
;
void
handleStop
(
uint32_t
code
SimInstruction
*
instr
)
;
bool
isStopInstruction
(
SimInstruction
*
instr
)
;
bool
isEnabledStop
(
uint32_t
code
)
;
void
enableStop
(
uint32_t
code
)
;
void
disableStop
(
uint32_t
code
)
;
void
increaseStopCounter
(
uint32_t
code
)
;
void
printStopInfo
(
uint32_t
code
)
;
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
(
)
;
bool
MOZ_ALWAYS_INLINE
handleWasmSegFault
(
uint64_t
addr
unsigned
numBytes
)
{
if
(
MOZ_LIKELY
(
!
js
:
:
wasm
:
:
CodeExists
)
)
{
return
false
;
}
uint8_t
*
newPC
;
if
(
!
js
:
:
wasm
:
:
MemoryAccessTraps
(
registerState
(
)
(
uint8_t
*
)
addr
numBytes
&
newPC
)
)
{
return
false
;
}
LLBit_
=
false
;
set_pc
(
int64_t
(
newPC
)
)
;
return
true
;
}
void
instructionDecode
(
SimInstruction
*
instr
)
;
public
:
static
int64_t
StopSimAt
;
static
void
*
RedirectNativeFunction
(
void
*
nativeFunction
ABIFunctionType
type
)
;
private
:
enum
Exception
{
kNone
kIntegerOverflow
kIntegerUnderflow
kDivideByZero
kNumExceptions
}
;
int16_t
exceptions
[
kNumExceptions
]
;
void
signalExceptions
(
)
;
void
setCallResultDouble
(
double
result
)
;
void
setCallResultFloat
(
float
result
)
;
void
setCallResult
(
int64_t
res
)
;
void
setCallResult
(
__int128
res
)
;
void
callInternal
(
uint8_t
*
entry
)
;
int64_t
registers_
[
kNumSimuRegisters
]
;
int64_t
FPUregisters_
[
kNumFPURegisters
]
;
bool
CFregisters_
[
kNumCFRegisters
]
;
uint32_t
FCSR_
;
bool
LLBit_
;
uintptr_t
LLAddr_
;
int64_t
lastLLValue_
;
char
*
stack_
;
uintptr_t
stackLimit_
;
bool
pc_modified_
;
int64_t
icount_
;
int64_t
break_count_
;
char
*
lastDebuggerInput_
;
SimInstruction
*
break_pc_
;
Instr
break_instr_
;
bool
single_stepping_
;
SingleStepCallback
single_step_callback_
;
void
*
single_step_callback_arg_
;
static
const
uint32_t
kNumOfWatchedStops
=
256
;
static
const
uint32_t
kStopDisabledBit
=
1U
<
<
31
;
struct
StopCountAndDesc
{
uint32_t
count_
;
char
*
desc_
;
}
;
StopCountAndDesc
watchedStops_
[
kNumOfWatchedStops
]
;
}
;
class
SimulatorProcess
{
friend
class
Redirection
;
friend
class
AutoLockSimulatorCache
;
private
:
struct
ICacheHasher
{
typedef
void
*
Key
;
typedef
void
*
Lookup
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
;
}
;
public
:
typedef
HashMap
<
void
*
CachePage
*
ICacheHasher
SystemAllocPolicy
>
ICacheMap
;
static
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
>
ICacheCheckingDisableCount
;
static
void
FlushICache
(
void
*
start
size_t
size
)
;
static
void
checkICacheLocked
(
SimInstruction
*
instr
)
;
static
bool
initialize
(
)
{
singleton_
=
js_new
<
SimulatorProcess
>
(
)
;
return
singleton_
;
}
static
void
destroy
(
)
{
js_delete
(
singleton_
)
;
singleton_
=
nullptr
;
}
SimulatorProcess
(
)
;
~
SimulatorProcess
(
)
;
private
:
static
SimulatorProcess
*
singleton_
;
Mutex
cacheLock_
;
Redirection
*
redirection_
;
ICacheMap
icache_
;
public
:
static
ICacheMap
&
icache
(
)
{
singleton_
-
>
cacheLock_
.
assertOwnedByCurrentThread
(
)
;
return
singleton_
-
>
icache_
;
}
static
Redirection
*
redirection
(
)
{
singleton_
-
>
cacheLock_
.
assertOwnedByCurrentThread
(
)
;
return
singleton_
-
>
redirection_
;
}
static
void
setRedirection
(
js
:
:
jit
:
:
Redirection
*
redirection
)
{
singleton_
-
>
cacheLock_
.
assertOwnedByCurrentThread
(
)
;
singleton_
-
>
redirection_
=
redirection
;
}
}
;
}
}
#
endif
#
endif
