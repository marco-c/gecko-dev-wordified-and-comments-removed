#
include
"
jit
/
ShapeList
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
vm
/
List
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
const
JSClass
ShapeListObject
:
:
class_
=
{
"
JIT
ShapeList
"
0
&
classOps_
}
;
const
JSClassOps
ShapeListObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ShapeListObject
:
:
trace
}
;
ShapeListObject
*
ShapeListObject
:
:
create
(
JSContext
*
cx
)
{
NativeObject
*
obj
=
NewTenuredObjectWithGivenProto
(
cx
&
class_
nullptr
)
;
if
(
!
obj
)
{
return
nullptr
;
}
if
(
!
cx
-
>
zone
(
)
-
>
registerObjectWithWeakPointers
(
obj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
ShapeListObject
>
(
)
;
}
Shape
*
ShapeListObject
:
:
get
(
uint32_t
index
)
const
{
Shape
*
shape
=
getUnbarriered
(
index
)
;
gc
:
:
ReadBarrier
(
shape
)
;
return
shape
;
}
Shape
*
ShapeListObject
:
:
getUnbarriered
(
uint32_t
index
)
const
{
Value
value
=
ListObject
:
:
get
(
index
)
;
return
static_cast
<
Shape
*
>
(
value
.
toPrivate
(
)
)
;
}
void
ShapeListObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
if
(
trc
-
>
traceWeakEdges
(
)
)
{
obj
-
>
as
<
ShapeListObject
>
(
)
.
traceWeak
(
trc
)
;
}
}
bool
ShapeListObject
:
:
traceWeak
(
JSTracer
*
trc
)
{
uint32_t
length
=
getDenseInitializedLength
(
)
;
if
(
length
=
=
0
)
{
return
false
;
}
const
HeapSlot
*
src
=
elements_
;
const
HeapSlot
*
end
=
src
+
length
;
HeapSlot
*
dst
=
elements_
;
while
(
src
!
=
end
)
{
Shape
*
shape
=
static_cast
<
Shape
*
>
(
src
-
>
toPrivate
(
)
)
;
MOZ_ASSERT
(
shape
-
>
is
<
Shape
>
(
)
)
;
if
(
TraceManuallyBarrieredWeakEdge
(
trc
&
shape
"
ShapeListObject
shape
"
)
)
{
dst
-
>
unbarrieredSet
(
PrivateValue
(
shape
)
)
;
dst
+
+
;
}
src
+
+
;
}
MOZ_ASSERT
(
dst
<
=
end
)
;
uint32_t
newLength
=
dst
-
elements_
;
setDenseInitializedLength
(
newLength
)
;
if
(
length
!
=
newLength
)
{
JitSpew
(
JitSpew_StubFolding
"
Cleared
%
u
/
%
u
shapes
from
%
p
"
length
-
newLength
length
this
)
;
}
return
length
!
=
0
;
}
