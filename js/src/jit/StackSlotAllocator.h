#
ifndef
jit_StackSlotAllocator_h
#
define
jit_StackSlotAllocator_h
#
include
"
jit
/
LIR
.
h
"
#
include
"
jit
/
Registers
.
h
"
namespace
js
{
namespace
jit
{
class
StackSlotAllocator
{
js
:
:
Vector
<
uint32_t
4
SystemAllocPolicy
>
normalSlots
;
js
:
:
Vector
<
uint32_t
4
SystemAllocPolicy
>
doubleSlots
;
uint32_t
height_
;
void
addAvailableSlot
(
uint32_t
index
)
{
(
void
)
normalSlots
.
append
(
index
)
;
}
void
addAvailableDoubleSlot
(
uint32_t
index
)
{
(
void
)
doubleSlots
.
append
(
index
)
;
}
uint32_t
allocateQuadSlot
(
)
{
if
(
height_
%
8
!
=
0
)
{
addAvailableSlot
(
height_
+
=
4
)
;
}
if
(
height_
%
16
!
=
0
)
{
addAvailableDoubleSlot
(
height_
+
=
8
)
;
}
return
height_
+
=
16
;
}
uint32_t
allocateDoubleSlot
(
)
{
if
(
!
doubleSlots
.
empty
(
)
)
{
return
doubleSlots
.
popCopy
(
)
;
}
if
(
height_
%
8
!
=
0
)
{
addAvailableSlot
(
height_
+
=
4
)
;
}
return
height_
+
=
8
;
}
uint32_t
allocateSlot
(
)
{
if
(
!
normalSlots
.
empty
(
)
)
{
return
normalSlots
.
popCopy
(
)
;
}
if
(
!
doubleSlots
.
empty
(
)
)
{
uint32_t
index
=
doubleSlots
.
popCopy
(
)
;
addAvailableSlot
(
index
-
4
)
;
return
index
;
}
return
height_
+
=
4
;
}
public
:
StackSlotAllocator
(
)
:
height_
(
0
)
{
}
void
allocateStackArea
(
LStackArea
*
alloc
)
{
uint32_t
size
=
alloc
-
>
size
(
)
;
MOZ_ASSERT
(
size
%
4
=
=
0
)
;
switch
(
alloc
-
>
alignment
(
)
)
{
case
8
:
if
(
(
height_
+
size
)
%
8
!
=
0
)
{
addAvailableSlot
(
height_
+
=
4
)
;
}
break
;
default
:
MOZ_CRASH
(
"
unexpected
stack
results
area
alignment
"
)
;
}
MOZ_ASSERT
(
(
height_
+
size
)
%
alloc
-
>
alignment
(
)
=
=
0
)
;
height_
+
=
size
;
alloc
-
>
setBase
(
height_
)
;
}
uint32_t
allocateSlot
(
LStackSlot
:
:
Width
width
)
{
switch
(
width
)
{
case
LStackSlot
:
:
Word
:
return
allocateSlot
(
)
;
case
LStackSlot
:
:
DoubleWord
:
return
allocateDoubleSlot
(
)
;
case
LStackSlot
:
:
QuadWord
:
return
allocateQuadSlot
(
)
;
}
MOZ_CRASH
(
"
Unknown
slot
width
"
)
;
}
uint32_t
stackHeight
(
)
const
{
return
height_
;
}
}
;
}
}
#
endif
