#
include
"
jit
/
ScalarReplacement
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
jit
/
IonAnalysis
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
MIR
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
jit
/
WarpBuilderShared
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
namespace
js
{
namespace
jit
{
template
<
typename
MemoryView
>
class
EmulateStateOf
{
private
:
using
BlockState
=
typename
MemoryView
:
:
BlockState
;
MIRGenerator
*
mir_
;
MIRGraph
&
graph_
;
Vector
<
BlockState
*
8
SystemAllocPolicy
>
states_
;
public
:
EmulateStateOf
(
MIRGenerator
*
mir
MIRGraph
&
graph
)
:
mir_
(
mir
)
graph_
(
graph
)
{
}
bool
run
(
MemoryView
&
view
)
;
}
;
template
<
typename
MemoryView
>
bool
EmulateStateOf
<
MemoryView
>
:
:
run
(
MemoryView
&
view
)
{
if
(
!
states_
.
appendN
(
nullptr
graph_
.
numBlocks
(
)
)
)
{
return
false
;
}
MBasicBlock
*
startBlock
=
view
.
startingBlock
(
)
;
if
(
!
view
.
initStartingState
(
&
states_
[
startBlock
-
>
id
(
)
]
)
)
{
return
false
;
}
for
(
ReversePostorderIterator
block
=
graph_
.
rpoBegin
(
startBlock
)
;
block
!
=
graph_
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
mir_
-
>
shouldCancel
(
MemoryView
:
:
phaseName
)
)
{
return
false
;
}
BlockState
*
state
=
states_
[
block
-
>
id
(
)
]
;
if
(
!
state
)
{
continue
;
}
view
.
setEntryBlockState
(
state
)
;
for
(
MNodeIterator
iter
(
*
block
)
;
iter
;
)
{
MNode
*
ins
=
*
iter
+
+
;
if
(
ins
-
>
isDefinition
(
)
)
{
MDefinition
*
def
=
ins
-
>
toDefinition
(
)
;
switch
(
def
-
>
op
(
)
)
{
#
define
MIR_OP
(
op
)
\
case
MDefinition
:
:
Opcode
:
:
op
:
\
view
.
visit
#
#
op
(
def
-
>
to
#
#
op
(
)
)
;
\
break
;
MIR_OPCODE_LIST
(
MIR_OP
)
#
undef
MIR_OP
}
}
else
{
view
.
visitResumePoint
(
ins
-
>
toResumePoint
(
)
)
;
}
if
(
view
.
oom
(
)
)
{
return
false
;
}
}
for
(
size_t
s
=
0
;
s
<
block
-
>
numSuccessors
(
)
;
s
+
+
)
{
MBasicBlock
*
succ
=
block
-
>
getSuccessor
(
s
)
;
if
(
!
view
.
mergeIntoSuccessorState
(
*
block
succ
&
states_
[
succ
-
>
id
(
)
]
)
)
{
return
false
;
}
}
}
states_
.
clear
(
)
;
return
true
;
}
static
bool
IsObjectEscaped
(
MInstruction
*
ins
JSObject
*
objDefault
=
nullptr
)
;
static
bool
IsLambdaEscaped
(
MInstruction
*
lambda
JSObject
*
obj
)
{
MOZ_ASSERT
(
lambda
-
>
isLambda
(
)
|
|
lambda
-
>
isLambdaArrow
(
)
|
|
lambda
-
>
isFunctionWithProto
(
)
)
;
JitSpewDef
(
JitSpew_Escape
"
Check
lambda
\
n
"
lambda
)
;
JitSpewIndent
spewIndent
(
JitSpew_Escape
)
;
for
(
MUseIterator
i
(
lambda
-
>
usesBegin
(
)
)
;
i
!
=
lambda
-
>
usesEnd
(
)
;
i
+
+
)
{
MNode
*
consumer
=
(
*
i
)
-
>
consumer
(
)
;
if
(
!
consumer
-
>
isDefinition
(
)
)
{
if
(
!
consumer
-
>
toResumePoint
(
)
-
>
isRecoverableOperand
(
*
i
)
)
{
JitSpew
(
JitSpew_Escape
"
Observable
lambda
cannot
be
recovered
"
)
;
return
true
;
}
continue
;
}
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
if
(
!
def
-
>
isFunctionEnvironment
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
def
)
;
return
true
;
}
if
(
IsObjectEscaped
(
def
-
>
toInstruction
(
)
obj
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
}
JitSpew
(
JitSpew_Escape
"
Lambda
is
not
escaped
"
)
;
return
false
;
}
static
inline
bool
IsOptimizableObjectInstruction
(
MInstruction
*
ins
)
{
return
ins
-
>
isNewObject
(
)
|
|
ins
-
>
isCreateThisWithTemplate
(
)
|
|
ins
-
>
isNewCallObject
(
)
|
|
ins
-
>
isNewIterator
(
)
;
}
static
bool
IsObjectEscaped
(
MInstruction
*
ins
JSObject
*
objDefault
)
{
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MOZ_ASSERT
(
IsOptimizableObjectInstruction
(
ins
)
|
|
ins
-
>
isGuardShape
(
)
|
|
ins
-
>
isFunctionEnvironment
(
)
)
;
JitSpewDef
(
JitSpew_Escape
"
Check
object
\
n
"
ins
)
;
JitSpewIndent
spewIndent
(
JitSpew_Escape
)
;
JSObject
*
obj
=
objDefault
;
if
(
!
obj
)
{
obj
=
MObjectState
:
:
templateObjectOf
(
ins
)
;
}
if
(
!
obj
)
{
JitSpew
(
JitSpew_Escape
"
No
template
object
defined
.
"
)
;
return
true
;
}
for
(
MUseIterator
i
(
ins
-
>
usesBegin
(
)
)
;
i
!
=
ins
-
>
usesEnd
(
)
;
i
+
+
)
{
MNode
*
consumer
=
(
*
i
)
-
>
consumer
(
)
;
if
(
!
consumer
-
>
isDefinition
(
)
)
{
if
(
!
consumer
-
>
toResumePoint
(
)
-
>
isRecoverableOperand
(
*
i
)
)
{
JitSpew
(
JitSpew_Escape
"
Observable
object
cannot
be
recovered
"
)
;
return
true
;
}
continue
;
}
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
switch
(
def
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
StoreFixedSlot
:
case
MDefinition
:
:
Opcode
:
:
LoadFixedSlot
:
if
(
def
-
>
indexOf
(
*
i
)
=
=
0
)
{
break
;
}
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
def
)
;
return
true
;
case
MDefinition
:
:
Opcode
:
:
PostWriteBarrier
:
break
;
case
MDefinition
:
:
Opcode
:
:
Slots
:
{
#
ifdef
DEBUG
MSlots
*
ins
=
def
-
>
toSlots
(
)
;
MOZ_ASSERT
(
ins
-
>
object
(
)
!
=
0
)
;
for
(
MUseIterator
i
(
ins
-
>
usesBegin
(
)
)
;
i
!
=
ins
-
>
usesEnd
(
)
;
i
+
+
)
{
MDefinition
*
def
=
(
*
i
)
-
>
consumer
(
)
-
>
toDefinition
(
)
;
MOZ_ASSERT
(
def
-
>
op
(
)
=
=
MDefinition
:
:
Opcode
:
:
StoreDynamicSlot
|
|
def
-
>
op
(
)
=
=
MDefinition
:
:
Opcode
:
:
LoadDynamicSlot
)
;
}
#
endif
break
;
}
case
MDefinition
:
:
Opcode
:
:
GuardShape
:
{
MGuardShape
*
guard
=
def
-
>
toGuardShape
(
)
;
MOZ_ASSERT
(
!
ins
-
>
isGuardShape
(
)
)
;
if
(
obj
-
>
shape
(
)
!
=
guard
-
>
shape
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
non
-
matching
guard
shape
\
n
"
guard
)
;
return
true
;
}
if
(
IsObjectEscaped
(
def
-
>
toInstruction
(
)
obj
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
Lambda
:
case
MDefinition
:
:
Opcode
:
:
LambdaArrow
:
case
MDefinition
:
:
Opcode
:
:
FunctionWithProto
:
{
if
(
IsLambdaEscaped
(
def
-
>
toInstruction
(
)
obj
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
AssertRecoveredOnBailout
:
break
;
default
:
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
def
)
;
return
true
;
}
}
JitSpew
(
JitSpew_Escape
"
Object
is
not
escaped
"
)
;
return
false
;
}
class
ObjectMemoryView
:
public
MDefinitionVisitorDefaultNoop
{
public
:
using
BlockState
=
MObjectState
;
static
const
char
phaseName
[
]
;
private
:
TempAllocator
&
alloc_
;
MConstant
*
undefinedVal_
;
MInstruction
*
obj_
;
MBasicBlock
*
startBlock_
;
BlockState
*
state_
;
const
MResumePoint
*
lastResumePoint_
;
bool
oom_
;
public
:
ObjectMemoryView
(
TempAllocator
&
alloc
MInstruction
*
obj
)
;
MBasicBlock
*
startingBlock
(
)
;
bool
initStartingState
(
BlockState
*
*
pState
)
;
void
setEntryBlockState
(
BlockState
*
state
)
;
bool
mergeIntoSuccessorState
(
MBasicBlock
*
curr
MBasicBlock
*
succ
BlockState
*
*
pSuccState
)
;
#
ifdef
DEBUG
void
assertSuccess
(
)
;
#
else
void
assertSuccess
(
)
{
}
#
endif
bool
oom
(
)
const
{
return
oom_
;
}
public
:
void
visitResumePoint
(
MResumePoint
*
rp
)
;
void
visitObjectState
(
MObjectState
*
ins
)
;
void
visitStoreFixedSlot
(
MStoreFixedSlot
*
ins
)
;
void
visitLoadFixedSlot
(
MLoadFixedSlot
*
ins
)
;
void
visitPostWriteBarrier
(
MPostWriteBarrier
*
ins
)
;
void
visitStoreDynamicSlot
(
MStoreDynamicSlot
*
ins
)
;
void
visitLoadDynamicSlot
(
MLoadDynamicSlot
*
ins
)
;
void
visitGuardShape
(
MGuardShape
*
ins
)
;
void
visitFunctionEnvironment
(
MFunctionEnvironment
*
ins
)
;
void
visitLambda
(
MLambda
*
ins
)
;
void
visitLambdaArrow
(
MLambdaArrow
*
ins
)
;
void
visitFunctionWithProto
(
MFunctionWithProto
*
ins
)
;
private
:
void
visitObjectGuard
(
MInstruction
*
ins
MDefinition
*
operand
)
;
}
;
const
char
ObjectMemoryView
:
:
phaseName
[
]
=
"
Scalar
Replacement
of
Object
"
;
ObjectMemoryView
:
:
ObjectMemoryView
(
TempAllocator
&
alloc
MInstruction
*
obj
)
:
alloc_
(
alloc
)
undefinedVal_
(
nullptr
)
obj_
(
obj
)
startBlock_
(
obj
-
>
block
(
)
)
state_
(
nullptr
)
lastResumePoint_
(
nullptr
)
oom_
(
false
)
{
obj_
-
>
setIncompleteObject
(
)
;
obj_
-
>
setImplicitlyUsedUnchecked
(
)
;
}
MBasicBlock
*
ObjectMemoryView
:
:
startingBlock
(
)
{
return
startBlock_
;
}
bool
ObjectMemoryView
:
:
initStartingState
(
BlockState
*
*
pState
)
{
undefinedVal_
=
MConstant
:
:
New
(
alloc_
UndefinedValue
(
)
)
;
startBlock_
-
>
insertBefore
(
obj_
undefinedVal_
)
;
BlockState
*
state
=
BlockState
:
:
New
(
alloc_
obj_
)
;
if
(
!
state
)
{
return
false
;
}
startBlock_
-
>
insertAfter
(
obj_
state
)
;
if
(
!
state
-
>
initFromTemplateObject
(
alloc_
undefinedVal_
)
)
{
return
false
;
}
state
-
>
setInWorklist
(
)
;
*
pState
=
state
;
return
true
;
}
void
ObjectMemoryView
:
:
setEntryBlockState
(
BlockState
*
state
)
{
state_
=
state
;
}
bool
ObjectMemoryView
:
:
mergeIntoSuccessorState
(
MBasicBlock
*
curr
MBasicBlock
*
succ
BlockState
*
*
pSuccState
)
{
BlockState
*
succState
=
*
pSuccState
;
if
(
!
succState
)
{
if
(
!
startBlock_
-
>
dominates
(
succ
)
)
{
return
true
;
}
if
(
succ
-
>
numPredecessors
(
)
<
=
1
|
|
!
state_
-
>
numSlots
(
)
)
{
*
pSuccState
=
state_
;
return
true
;
}
succState
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
succState
)
{
return
false
;
}
size_t
numPreds
=
succ
-
>
numPredecessors
(
)
;
for
(
size_t
slot
=
0
;
slot
<
state_
-
>
numSlots
(
)
;
slot
+
+
)
{
MPhi
*
phi
=
MPhi
:
:
New
(
alloc_
.
fallible
(
)
)
;
if
(
!
phi
|
|
!
phi
-
>
reserveLength
(
numPreds
)
)
{
return
false
;
}
for
(
size_t
p
=
0
;
p
<
numPreds
;
p
+
+
)
{
phi
-
>
addInput
(
undefinedVal_
)
;
}
succ
-
>
addPhi
(
phi
)
;
succState
-
>
setSlot
(
slot
phi
)
;
}
succ
-
>
insertBefore
(
succ
-
>
safeInsertTop
(
)
succState
)
;
*
pSuccState
=
succState
;
}
MOZ_ASSERT_IF
(
succ
=
=
startBlock_
startBlock_
-
>
isLoopHeader
(
)
)
;
if
(
succ
-
>
numPredecessors
(
)
>
1
&
&
succState
-
>
numSlots
(
)
&
&
succ
!
=
startBlock_
)
{
size_t
currIndex
;
MOZ_ASSERT
(
!
succ
-
>
phisEmpty
(
)
)
;
if
(
curr
-
>
successorWithPhis
(
)
)
{
MOZ_ASSERT
(
curr
-
>
successorWithPhis
(
)
=
=
succ
)
;
currIndex
=
curr
-
>
positionInPhiSuccessor
(
)
;
}
else
{
currIndex
=
succ
-
>
indexForPredecessor
(
curr
)
;
curr
-
>
setSuccessorWithPhis
(
succ
currIndex
)
;
}
MOZ_ASSERT
(
succ
-
>
getPredecessor
(
currIndex
)
=
=
curr
)
;
for
(
size_t
slot
=
0
;
slot
<
state_
-
>
numSlots
(
)
;
slot
+
+
)
{
MPhi
*
phi
=
succState
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
phi
-
>
replaceOperand
(
currIndex
state_
-
>
getSlot
(
slot
)
)
;
}
}
return
true
;
}
#
ifdef
DEBUG
void
ObjectMemoryView
:
:
assertSuccess
(
)
{
for
(
MUseIterator
i
(
obj_
-
>
usesBegin
(
)
)
;
i
!
=
obj_
-
>
usesEnd
(
)
;
i
+
+
)
{
MNode
*
ins
=
(
*
i
)
-
>
consumer
(
)
;
MDefinition
*
def
=
nullptr
;
if
(
ins
-
>
isResumePoint
(
)
|
|
(
def
=
ins
-
>
toDefinition
(
)
)
-
>
isRecoveredOnBailout
(
)
)
{
MOZ_ASSERT
(
obj_
-
>
isIncompleteObject
(
)
)
;
continue
;
}
MOZ_ASSERT
(
def
-
>
isSlots
(
)
|
|
def
-
>
isLambda
(
)
|
|
def
-
>
isLambdaArrow
(
)
|
|
def
-
>
isFunctionWithProto
(
)
)
;
MOZ_ASSERT
(
!
def
-
>
hasDefUses
(
)
)
;
}
}
#
endif
void
ObjectMemoryView
:
:
visitResumePoint
(
MResumePoint
*
rp
)
{
if
(
!
state_
-
>
isInWorklist
(
)
)
{
rp
-
>
addStore
(
alloc_
state_
lastResumePoint_
)
;
lastResumePoint_
=
rp
;
}
}
void
ObjectMemoryView
:
:
visitObjectState
(
MObjectState
*
ins
)
{
if
(
ins
-
>
isInWorklist
(
)
)
{
ins
-
>
setNotInWorklist
(
)
;
}
}
void
ObjectMemoryView
:
:
visitStoreFixedSlot
(
MStoreFixedSlot
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
obj_
)
{
return
;
}
if
(
state_
-
>
hasFixedSlot
(
ins
-
>
slot
(
)
)
)
{
state_
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
state_
)
{
oom_
=
true
;
return
;
}
state_
-
>
setFixedSlot
(
ins
-
>
slot
(
)
ins
-
>
value
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
-
>
toInstruction
(
)
state_
)
;
}
else
{
MBail
*
bailout
=
MBail
:
:
New
(
alloc_
BailoutKind
:
:
Inevitable
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
bailout
)
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitLoadFixedSlot
(
MLoadFixedSlot
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
obj_
)
{
return
;
}
if
(
state_
-
>
hasFixedSlot
(
ins
-
>
slot
(
)
)
)
{
ins
-
>
replaceAllUsesWith
(
state_
-
>
getFixedSlot
(
ins
-
>
slot
(
)
)
)
;
}
else
{
MBail
*
bailout
=
MBail
:
:
New
(
alloc_
BailoutKind
:
:
Inevitable
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
bailout
)
;
ins
-
>
replaceAllUsesWith
(
undefinedVal_
)
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitPostWriteBarrier
(
MPostWriteBarrier
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
obj_
)
{
return
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitStoreDynamicSlot
(
MStoreDynamicSlot
*
ins
)
{
MSlots
*
slots
=
ins
-
>
slots
(
)
-
>
toSlots
(
)
;
if
(
slots
-
>
object
(
)
!
=
obj_
)
{
MOZ_ASSERT
(
!
slots
-
>
object
(
)
-
>
isGuardShape
(
)
|
|
slots
-
>
object
(
)
-
>
toGuardShape
(
)
-
>
object
(
)
!
=
obj_
)
;
return
;
}
if
(
state_
-
>
hasDynamicSlot
(
ins
-
>
slot
(
)
)
)
{
state_
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
state_
)
{
oom_
=
true
;
return
;
}
state_
-
>
setDynamicSlot
(
ins
-
>
slot
(
)
ins
-
>
value
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
-
>
toInstruction
(
)
state_
)
;
}
else
{
MBail
*
bailout
=
MBail
:
:
New
(
alloc_
BailoutKind
:
:
Inevitable
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
bailout
)
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitLoadDynamicSlot
(
MLoadDynamicSlot
*
ins
)
{
MSlots
*
slots
=
ins
-
>
slots
(
)
-
>
toSlots
(
)
;
if
(
slots
-
>
object
(
)
!
=
obj_
)
{
MOZ_ASSERT
(
!
slots
-
>
object
(
)
-
>
isGuardShape
(
)
|
|
slots
-
>
object
(
)
-
>
toGuardShape
(
)
-
>
object
(
)
!
=
obj_
)
;
return
;
}
if
(
state_
-
>
hasDynamicSlot
(
ins
-
>
slot
(
)
)
)
{
ins
-
>
replaceAllUsesWith
(
state_
-
>
getDynamicSlot
(
ins
-
>
slot
(
)
)
)
;
}
else
{
MBail
*
bailout
=
MBail
:
:
New
(
alloc_
BailoutKind
:
:
Inevitable
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
bailout
)
;
ins
-
>
replaceAllUsesWith
(
undefinedVal_
)
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitObjectGuard
(
MInstruction
*
ins
MDefinition
*
operand
)
{
MOZ_ASSERT
(
ins
-
>
numOperands
(
)
=
=
1
)
;
MOZ_ASSERT
(
ins
-
>
getOperand
(
0
)
=
=
operand
)
;
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
if
(
operand
!
=
obj_
)
{
return
;
}
ins
-
>
replaceAllUsesWith
(
obj_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitGuardShape
(
MGuardShape
*
ins
)
{
visitObjectGuard
(
ins
ins
-
>
object
(
)
)
;
}
void
ObjectMemoryView
:
:
visitFunctionEnvironment
(
MFunctionEnvironment
*
ins
)
{
MDefinition
*
input
=
ins
-
>
input
(
)
;
if
(
input
-
>
isLambda
(
)
)
{
if
(
input
-
>
toLambda
(
)
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
}
else
if
(
input
-
>
isLambdaArrow
(
)
)
{
if
(
input
-
>
toLambdaArrow
(
)
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
}
else
if
(
input
-
>
isFunctionWithProto
(
)
)
{
if
(
input
-
>
toFunctionWithProto
(
)
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
}
else
{
return
;
}
ins
-
>
replaceAllUsesWith
(
obj_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ObjectMemoryView
:
:
visitLambda
(
MLambda
*
ins
)
{
if
(
ins
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
ins
-
>
setIncompleteObject
(
)
;
}
void
ObjectMemoryView
:
:
visitLambdaArrow
(
MLambdaArrow
*
ins
)
{
if
(
ins
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
ins
-
>
setIncompleteObject
(
)
;
}
void
ObjectMemoryView
:
:
visitFunctionWithProto
(
MFunctionWithProto
*
ins
)
{
if
(
ins
-
>
environmentChain
(
)
!
=
obj_
)
{
return
;
}
ins
-
>
setIncompleteObject
(
)
;
}
static
bool
IndexOf
(
MDefinition
*
ins
int32_t
*
res
)
{
MOZ_ASSERT
(
ins
-
>
isLoadElement
(
)
|
|
ins
-
>
isStoreElement
(
)
)
;
MDefinition
*
indexDef
=
ins
-
>
getOperand
(
1
)
;
if
(
indexDef
-
>
isSpectreMaskIndex
(
)
)
{
indexDef
=
indexDef
-
>
toSpectreMaskIndex
(
)
-
>
index
(
)
;
}
if
(
indexDef
-
>
isBoundsCheck
(
)
)
{
indexDef
=
indexDef
-
>
toBoundsCheck
(
)
-
>
index
(
)
;
}
if
(
indexDef
-
>
isToNumberInt32
(
)
)
{
indexDef
=
indexDef
-
>
toToNumberInt32
(
)
-
>
getOperand
(
0
)
;
}
MConstant
*
indexDefConst
=
indexDef
-
>
maybeConstantValue
(
)
;
if
(
!
indexDefConst
|
|
indexDefConst
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
false
;
}
*
res
=
indexDefConst
-
>
toInt32
(
)
;
return
true
;
}
static
bool
IsElementEscaped
(
MDefinition
*
def
uint32_t
arraySize
)
{
MOZ_ASSERT
(
def
-
>
isElements
(
)
)
;
JitSpewDef
(
JitSpew_Escape
"
Check
elements
\
n
"
def
)
;
JitSpewIndent
spewIndent
(
JitSpew_Escape
)
;
for
(
MUseIterator
i
(
def
-
>
usesBegin
(
)
)
;
i
!
=
def
-
>
usesEnd
(
)
;
i
+
+
)
{
MDefinition
*
access
=
(
*
i
)
-
>
consumer
(
)
-
>
toDefinition
(
)
;
switch
(
access
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
LoadElement
:
{
MOZ_ASSERT
(
access
-
>
toLoadElement
(
)
-
>
elements
(
)
=
=
def
)
;
int32_t
index
;
if
(
!
IndexOf
(
access
&
index
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
load
element
with
a
non
-
trivial
index
\
n
"
access
)
;
return
true
;
}
if
(
index
<
0
|
|
arraySize
<
=
uint32_t
(
index
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
load
element
with
an
out
-
of
-
bound
index
\
n
"
access
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
StoreElement
:
{
MStoreElement
*
storeElem
=
access
-
>
toStoreElement
(
)
;
MOZ_ASSERT
(
storeElem
-
>
elements
(
)
=
=
def
)
;
if
(
storeElem
-
>
needsHoleCheck
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
store
element
with
a
hole
check
\
n
"
storeElem
)
;
return
true
;
}
int32_t
index
;
if
(
!
IndexOf
(
storeElem
&
index
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
store
element
with
a
non
-
trivial
index
\
n
"
storeElem
)
;
return
true
;
}
if
(
index
<
0
|
|
arraySize
<
=
uint32_t
(
index
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
store
element
with
an
out
-
of
-
bound
index
\
n
"
storeElem
)
;
return
true
;
}
MOZ_ASSERT
(
storeElem
-
>
value
(
)
-
>
type
(
)
!
=
MIRType
:
:
MagicHole
)
;
break
;
}
case
MDefinition
:
:
Opcode
:
:
SetInitializedLength
:
MOZ_ASSERT
(
access
-
>
toSetInitializedLength
(
)
-
>
elements
(
)
=
=
def
)
;
break
;
case
MDefinition
:
:
Opcode
:
:
InitializedLength
:
MOZ_ASSERT
(
access
-
>
toInitializedLength
(
)
-
>
elements
(
)
=
=
def
)
;
break
;
case
MDefinition
:
:
Opcode
:
:
ArrayLength
:
MOZ_ASSERT
(
access
-
>
toArrayLength
(
)
-
>
elements
(
)
=
=
def
)
;
break
;
default
:
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
access
)
;
return
true
;
}
}
JitSpew
(
JitSpew_Escape
"
Elements
is
not
escaped
"
)
;
return
false
;
}
static
inline
bool
IsOptimizableArrayInstruction
(
MInstruction
*
ins
)
{
return
ins
-
>
isNewArray
(
)
;
}
static
bool
IsArrayEscaped
(
MInstruction
*
ins
MInstruction
*
newArray
)
{
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MOZ_ASSERT
(
IsOptimizableArrayInstruction
(
newArray
)
)
;
JitSpewDef
(
JitSpew_Escape
"
Check
array
\
n
"
ins
)
;
JitSpewIndent
spewIndent
(
JitSpew_Escape
)
;
JSObject
*
templateObject
=
newArray
-
>
toNewArray
(
)
-
>
templateObject
(
)
;
if
(
!
templateObject
)
{
JitSpew
(
JitSpew_Escape
"
No
template
object
defined
.
"
)
;
return
true
;
}
uint32_t
length
=
newArray
-
>
toNewArray
(
)
-
>
length
(
)
;
if
(
length
>
=
16
)
{
JitSpew
(
JitSpew_Escape
"
Array
has
too
many
elements
"
)
;
return
true
;
}
for
(
MUseIterator
i
(
ins
-
>
usesBegin
(
)
)
;
i
!
=
ins
-
>
usesEnd
(
)
;
i
+
+
)
{
MNode
*
consumer
=
(
*
i
)
-
>
consumer
(
)
;
if
(
!
consumer
-
>
isDefinition
(
)
)
{
if
(
!
consumer
-
>
toResumePoint
(
)
-
>
isRecoverableOperand
(
*
i
)
)
{
JitSpew
(
JitSpew_Escape
"
Observable
array
cannot
be
recovered
"
)
;
return
true
;
}
continue
;
}
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
switch
(
def
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
Elements
:
{
MElements
*
elem
=
def
-
>
toElements
(
)
;
MOZ_ASSERT
(
elem
-
>
object
(
)
=
=
ins
)
;
if
(
IsElementEscaped
(
elem
length
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
elem
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
GuardShape
:
{
MGuardShape
*
guard
=
def
-
>
toGuardShape
(
)
;
if
(
templateObject
-
>
shape
(
)
!
=
guard
-
>
shape
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
non
-
matching
guard
shape
\
n
"
guard
)
;
return
true
;
}
if
(
IsArrayEscaped
(
guard
newArray
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
GuardToClass
:
{
MGuardToClass
*
guard
=
def
-
>
toGuardToClass
(
)
;
if
(
templateObject
-
>
getClass
(
)
!
=
guard
-
>
getClass
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
non
-
matching
class
guard
\
n
"
guard
)
;
return
true
;
}
if
(
IsArrayEscaped
(
guard
newArray
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
Unbox
:
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
JitSpewDef
(
JitSpew_Escape
"
has
an
invalid
unbox
\
n
"
def
)
;
return
true
;
}
if
(
IsArrayEscaped
(
def
-
>
toInstruction
(
)
newArray
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
PostWriteBarrier
:
case
MDefinition
:
:
Opcode
:
:
PostWriteElementBarrier
:
break
;
case
MDefinition
:
:
Opcode
:
:
AssertRecoveredOnBailout
:
break
;
default
:
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
def
)
;
return
true
;
}
}
JitSpew
(
JitSpew_Escape
"
Array
is
not
escaped
"
)
;
return
false
;
}
class
ArrayMemoryView
:
public
MDefinitionVisitorDefaultNoop
{
public
:
using
BlockState
=
MArrayState
;
static
const
char
*
phaseName
;
private
:
TempAllocator
&
alloc_
;
MConstant
*
undefinedVal_
;
MConstant
*
length_
;
MInstruction
*
arr_
;
MBasicBlock
*
startBlock_
;
BlockState
*
state_
;
const
MResumePoint
*
lastResumePoint_
;
bool
oom_
;
public
:
ArrayMemoryView
(
TempAllocator
&
alloc
MInstruction
*
arr
)
;
MBasicBlock
*
startingBlock
(
)
;
bool
initStartingState
(
BlockState
*
*
pState
)
;
void
setEntryBlockState
(
BlockState
*
state
)
;
bool
mergeIntoSuccessorState
(
MBasicBlock
*
curr
MBasicBlock
*
succ
BlockState
*
*
pSuccState
)
;
#
ifdef
DEBUG
void
assertSuccess
(
)
;
#
else
void
assertSuccess
(
)
{
}
#
endif
bool
oom
(
)
const
{
return
oom_
;
}
private
:
bool
isArrayStateElements
(
MDefinition
*
elements
)
;
void
discardInstruction
(
MInstruction
*
ins
MDefinition
*
elements
)
;
public
:
void
visitResumePoint
(
MResumePoint
*
rp
)
;
void
visitArrayState
(
MArrayState
*
ins
)
;
void
visitStoreElement
(
MStoreElement
*
ins
)
;
void
visitLoadElement
(
MLoadElement
*
ins
)
;
void
visitSetInitializedLength
(
MSetInitializedLength
*
ins
)
;
void
visitInitializedLength
(
MInitializedLength
*
ins
)
;
void
visitArrayLength
(
MArrayLength
*
ins
)
;
void
visitPostWriteBarrier
(
MPostWriteBarrier
*
ins
)
;
void
visitPostWriteElementBarrier
(
MPostWriteElementBarrier
*
ins
)
;
void
visitGuardShape
(
MGuardShape
*
ins
)
;
void
visitGuardToClass
(
MGuardToClass
*
ins
)
;
void
visitUnbox
(
MUnbox
*
ins
)
;
}
;
const
char
*
ArrayMemoryView
:
:
phaseName
=
"
Scalar
Replacement
of
Array
"
;
ArrayMemoryView
:
:
ArrayMemoryView
(
TempAllocator
&
alloc
MInstruction
*
arr
)
:
alloc_
(
alloc
)
undefinedVal_
(
nullptr
)
length_
(
nullptr
)
arr_
(
arr
)
startBlock_
(
arr
-
>
block
(
)
)
state_
(
nullptr
)
lastResumePoint_
(
nullptr
)
oom_
(
false
)
{
arr_
-
>
setIncompleteObject
(
)
;
arr_
-
>
setImplicitlyUsedUnchecked
(
)
;
}
MBasicBlock
*
ArrayMemoryView
:
:
startingBlock
(
)
{
return
startBlock_
;
}
bool
ArrayMemoryView
:
:
initStartingState
(
BlockState
*
*
pState
)
{
undefinedVal_
=
MConstant
:
:
New
(
alloc_
UndefinedValue
(
)
)
;
MConstant
*
initLength
=
MConstant
:
:
New
(
alloc_
Int32Value
(
0
)
)
;
arr_
-
>
block
(
)
-
>
insertBefore
(
arr_
undefinedVal_
)
;
arr_
-
>
block
(
)
-
>
insertBefore
(
arr_
initLength
)
;
BlockState
*
state
=
BlockState
:
:
New
(
alloc_
arr_
initLength
)
;
if
(
!
state
)
{
return
false
;
}
startBlock_
-
>
insertAfter
(
arr_
state
)
;
if
(
!
state
-
>
initFromTemplateObject
(
alloc_
undefinedVal_
)
)
{
return
false
;
}
state
-
>
setInWorklist
(
)
;
*
pState
=
state
;
return
true
;
}
void
ArrayMemoryView
:
:
setEntryBlockState
(
BlockState
*
state
)
{
state_
=
state
;
}
bool
ArrayMemoryView
:
:
mergeIntoSuccessorState
(
MBasicBlock
*
curr
MBasicBlock
*
succ
BlockState
*
*
pSuccState
)
{
BlockState
*
succState
=
*
pSuccState
;
if
(
!
succState
)
{
if
(
!
startBlock_
-
>
dominates
(
succ
)
)
{
return
true
;
}
if
(
succ
-
>
numPredecessors
(
)
<
=
1
|
|
!
state_
-
>
numElements
(
)
)
{
*
pSuccState
=
state_
;
return
true
;
}
succState
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
succState
)
{
return
false
;
}
size_t
numPreds
=
succ
-
>
numPredecessors
(
)
;
for
(
size_t
index
=
0
;
index
<
state_
-
>
numElements
(
)
;
index
+
+
)
{
MPhi
*
phi
=
MPhi
:
:
New
(
alloc_
.
fallible
(
)
)
;
if
(
!
phi
|
|
!
phi
-
>
reserveLength
(
numPreds
)
)
{
return
false
;
}
for
(
size_t
p
=
0
;
p
<
numPreds
;
p
+
+
)
{
phi
-
>
addInput
(
undefinedVal_
)
;
}
succ
-
>
addPhi
(
phi
)
;
succState
-
>
setElement
(
index
phi
)
;
}
succ
-
>
insertBefore
(
succ
-
>
safeInsertTop
(
)
succState
)
;
*
pSuccState
=
succState
;
}
MOZ_ASSERT_IF
(
succ
=
=
startBlock_
startBlock_
-
>
isLoopHeader
(
)
)
;
if
(
succ
-
>
numPredecessors
(
)
>
1
&
&
succState
-
>
numElements
(
)
&
&
succ
!
=
startBlock_
)
{
size_t
currIndex
;
MOZ_ASSERT
(
!
succ
-
>
phisEmpty
(
)
)
;
if
(
curr
-
>
successorWithPhis
(
)
)
{
MOZ_ASSERT
(
curr
-
>
successorWithPhis
(
)
=
=
succ
)
;
currIndex
=
curr
-
>
positionInPhiSuccessor
(
)
;
}
else
{
currIndex
=
succ
-
>
indexForPredecessor
(
curr
)
;
curr
-
>
setSuccessorWithPhis
(
succ
currIndex
)
;
}
MOZ_ASSERT
(
succ
-
>
getPredecessor
(
currIndex
)
=
=
curr
)
;
for
(
size_t
index
=
0
;
index
<
state_
-
>
numElements
(
)
;
index
+
+
)
{
MPhi
*
phi
=
succState
-
>
getElement
(
index
)
-
>
toPhi
(
)
;
phi
-
>
replaceOperand
(
currIndex
state_
-
>
getElement
(
index
)
)
;
}
}
return
true
;
}
#
ifdef
DEBUG
void
ArrayMemoryView
:
:
assertSuccess
(
)
{
MOZ_ASSERT
(
!
arr_
-
>
hasLiveDefUses
(
)
)
;
}
#
endif
void
ArrayMemoryView
:
:
visitResumePoint
(
MResumePoint
*
rp
)
{
if
(
!
state_
-
>
isInWorklist
(
)
)
{
rp
-
>
addStore
(
alloc_
state_
lastResumePoint_
)
;
lastResumePoint_
=
rp
;
}
}
void
ArrayMemoryView
:
:
visitArrayState
(
MArrayState
*
ins
)
{
if
(
ins
-
>
isInWorklist
(
)
)
{
ins
-
>
setNotInWorklist
(
)
;
}
}
bool
ArrayMemoryView
:
:
isArrayStateElements
(
MDefinition
*
elements
)
{
return
elements
-
>
isElements
(
)
&
&
elements
-
>
toElements
(
)
-
>
object
(
)
=
=
arr_
;
}
void
ArrayMemoryView
:
:
discardInstruction
(
MInstruction
*
ins
MDefinition
*
elements
)
{
MOZ_ASSERT
(
elements
-
>
isElements
(
)
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
if
(
!
elements
-
>
hasLiveDefUses
(
)
)
{
elements
-
>
block
(
)
-
>
discard
(
elements
-
>
toInstruction
(
)
)
;
}
}
void
ArrayMemoryView
:
:
visitStoreElement
(
MStoreElement
*
ins
)
{
MDefinition
*
elements
=
ins
-
>
elements
(
)
;
if
(
!
isArrayStateElements
(
elements
)
)
{
return
;
}
int32_t
index
;
MOZ_ALWAYS_TRUE
(
IndexOf
(
ins
&
index
)
)
;
state_
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
state_
)
{
oom_
=
true
;
return
;
}
state_
-
>
setElement
(
index
ins
-
>
value
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
state_
)
;
discardInstruction
(
ins
elements
)
;
}
void
ArrayMemoryView
:
:
visitLoadElement
(
MLoadElement
*
ins
)
{
MDefinition
*
elements
=
ins
-
>
elements
(
)
;
if
(
!
isArrayStateElements
(
elements
)
)
{
return
;
}
int32_t
index
;
MOZ_ALWAYS_TRUE
(
IndexOf
(
ins
&
index
)
)
;
MDefinition
*
element
=
state_
-
>
getElement
(
index
)
;
MOZ_ASSERT
(
element
-
>
type
(
)
!
=
MIRType
:
:
MagicHole
)
;
ins
-
>
replaceAllUsesWith
(
element
)
;
discardInstruction
(
ins
elements
)
;
}
void
ArrayMemoryView
:
:
visitSetInitializedLength
(
MSetInitializedLength
*
ins
)
{
MDefinition
*
elements
=
ins
-
>
elements
(
)
;
if
(
!
isArrayStateElements
(
elements
)
)
{
return
;
}
state_
=
BlockState
:
:
Copy
(
alloc_
state_
)
;
if
(
!
state_
)
{
oom_
=
true
;
return
;
}
int32_t
initLengthValue
=
ins
-
>
index
(
)
-
>
maybeConstantValue
(
)
-
>
toInt32
(
)
+
1
;
MConstant
*
initLength
=
MConstant
:
:
New
(
alloc_
Int32Value
(
initLengthValue
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
initLength
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
state_
)
;
state_
-
>
setInitializedLength
(
initLength
)
;
discardInstruction
(
ins
elements
)
;
}
void
ArrayMemoryView
:
:
visitInitializedLength
(
MInitializedLength
*
ins
)
{
MDefinition
*
elements
=
ins
-
>
elements
(
)
;
if
(
!
isArrayStateElements
(
elements
)
)
{
return
;
}
ins
-
>
replaceAllUsesWith
(
state_
-
>
initializedLength
(
)
)
;
discardInstruction
(
ins
elements
)
;
}
void
ArrayMemoryView
:
:
visitArrayLength
(
MArrayLength
*
ins
)
{
MDefinition
*
elements
=
ins
-
>
elements
(
)
;
if
(
!
isArrayStateElements
(
elements
)
)
{
return
;
}
if
(
!
length_
)
{
length_
=
MConstant
:
:
New
(
alloc_
Int32Value
(
state_
-
>
numElements
(
)
)
)
;
arr_
-
>
block
(
)
-
>
insertBefore
(
arr_
length_
)
;
}
ins
-
>
replaceAllUsesWith
(
length_
)
;
discardInstruction
(
ins
elements
)
;
}
void
ArrayMemoryView
:
:
visitPostWriteBarrier
(
MPostWriteBarrier
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
arr_
)
{
return
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArrayMemoryView
:
:
visitPostWriteElementBarrier
(
MPostWriteElementBarrier
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
arr_
)
{
return
;
}
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArrayMemoryView
:
:
visitGuardShape
(
MGuardShape
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
arr_
)
{
return
;
}
ins
-
>
replaceAllUsesWith
(
arr_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArrayMemoryView
:
:
visitGuardToClass
(
MGuardToClass
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
arr_
)
{
return
;
}
ins
-
>
replaceAllUsesWith
(
arr_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArrayMemoryView
:
:
visitUnbox
(
MUnbox
*
ins
)
{
if
(
ins
-
>
getOperand
(
0
)
!
=
arr_
)
{
return
;
}
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
ins
-
>
replaceAllUsesWith
(
arr_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
static
inline
bool
IsOptimizableArgumentsInstruction
(
MInstruction
*
ins
)
{
return
ins
-
>
isCreateArgumentsObject
(
)
|
|
ins
-
>
isCreateInlinedArgumentsObject
(
)
;
}
class
ArgumentsReplacer
:
public
MDefinitionVisitorDefaultNoop
{
private
:
MIRGenerator
*
mir_
;
MIRGraph
&
graph_
;
MInstruction
*
args_
;
TempAllocator
&
alloc
(
)
{
return
graph_
.
alloc
(
)
;
}
bool
isInlinedArguments
(
)
const
{
return
args_
-
>
isCreateInlinedArgumentsObject
(
)
;
}
void
visitGuardToClass
(
MGuardToClass
*
ins
)
;
void
visitGuardArgumentsObjectFlags
(
MGuardArgumentsObjectFlags
*
ins
)
;
void
visitUnbox
(
MUnbox
*
ins
)
;
void
visitGetArgumentsObjectArg
(
MGetArgumentsObjectArg
*
ins
)
;
void
visitLoadArgumentsObjectArg
(
MLoadArgumentsObjectArg
*
ins
)
;
void
visitArgumentsObjectLength
(
MArgumentsObjectLength
*
ins
)
;
void
visitApplyArgsObj
(
MApplyArgsObj
*
ins
)
;
void
visitLoadFixedSlot
(
MLoadFixedSlot
*
ins
)
;
public
:
ArgumentsReplacer
(
MIRGenerator
*
mir
MIRGraph
&
graph
MInstruction
*
args
)
:
mir_
(
mir
)
graph_
(
graph
)
args_
(
args
)
{
MOZ_ASSERT
(
IsOptimizableArgumentsInstruction
(
args_
)
)
;
}
bool
escapes
(
MInstruction
*
ins
bool
guardedForMapped
=
false
)
;
bool
run
(
)
;
void
assertSuccess
(
)
;
}
;
bool
ArgumentsReplacer
:
:
escapes
(
MInstruction
*
ins
bool
guardedForMapped
)
{
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
JitSpewDef
(
JitSpew_Escape
"
Check
arguments
object
\
n
"
ins
)
;
JitSpewIndent
spewIndent
(
JitSpew_Escape
)
;
for
(
MUseIterator
i
(
ins
-
>
usesBegin
(
)
)
;
i
!
=
ins
-
>
usesEnd
(
)
;
i
+
+
)
{
MNode
*
consumer
=
(
*
i
)
-
>
consumer
(
)
;
if
(
consumer
-
>
isResumePoint
(
)
)
{
if
(
!
consumer
-
>
toResumePoint
(
)
-
>
isRecoverableOperand
(
*
i
)
)
{
JitSpew
(
JitSpew_Escape
"
Observable
args
object
cannot
be
recovered
"
)
;
return
true
;
}
continue
;
}
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
switch
(
def
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
GuardToClass
:
{
MGuardToClass
*
guard
=
def
-
>
toGuardToClass
(
)
;
if
(
!
guard
-
>
isArgumentsObjectClass
(
)
)
{
JitSpewDef
(
JitSpew_Escape
"
has
a
non
-
matching
class
guard
\
n
"
guard
)
;
return
true
;
}
bool
isMapped
=
guard
-
>
getClass
(
)
=
=
&
MappedArgumentsObject
:
:
class_
;
if
(
escapes
(
guard
isMapped
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
GuardArgumentsObjectFlags
:
{
if
(
escapes
(
def
-
>
toInstruction
(
)
guardedForMapped
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
Unbox
:
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
JitSpewDef
(
JitSpew_Escape
"
has
an
invalid
unbox
\
n
"
def
)
;
return
true
;
}
if
(
escapes
(
def
-
>
toInstruction
(
)
)
)
{
JitSpewDef
(
JitSpew_Escape
"
is
indirectly
escaped
by
\
n
"
def
)
;
return
true
;
}
break
;
}
case
MDefinition
:
:
Opcode
:
:
LoadFixedSlot
:
{
MLoadFixedSlot
*
load
=
def
-
>
toLoadFixedSlot
(
)
;
if
(
load
-
>
slot
(
)
=
=
ArgumentsObject
:
:
CALLEE_SLOT
)
{
MOZ_ASSERT
(
guardedForMapped
)
;
continue
;
}
JitSpew
(
JitSpew_Escape
"
is
escaped
by
unsupported
LoadFixedSlot
\
n
"
)
;
return
true
;
}
case
MDefinition
:
:
Opcode
:
:
ArgumentsObjectLength
:
case
MDefinition
:
:
Opcode
:
:
GetArgumentsObjectArg
:
case
MDefinition
:
:
Opcode
:
:
ApplyArgsObj
:
case
MDefinition
:
:
Opcode
:
:
LoadArgumentsObjectArg
:
break
;
case
MDefinition
:
:
Opcode
:
:
AssertRecoveredOnBailout
:
break
;
default
:
JitSpewDef
(
JitSpew_Escape
"
is
escaped
by
\
n
"
def
)
;
return
true
;
}
}
JitSpew
(
JitSpew_Escape
"
ArgumentsObject
is
not
escaped
"
)
;
return
false
;
}
bool
ArgumentsReplacer
:
:
run
(
)
{
MBasicBlock
*
startBlock
=
args_
-
>
block
(
)
;
for
(
ReversePostorderIterator
block
=
graph_
.
rpoBegin
(
startBlock
)
;
block
!
=
graph_
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
mir_
-
>
shouldCancel
(
"
Scalar
replacement
of
Arguments
Object
"
)
)
{
return
false
;
}
for
(
MNodeIterator
iter
(
*
block
)
;
iter
;
)
{
MNode
*
ins
=
*
iter
+
+
;
if
(
ins
-
>
isDefinition
(
)
)
{
MDefinition
*
def
=
ins
-
>
toDefinition
(
)
;
switch
(
def
-
>
op
(
)
)
{
#
define
MIR_OP
(
op
)
\
case
MDefinition
:
:
Opcode
:
:
op
:
\
visit
#
#
op
(
def
-
>
to
#
#
op
(
)
)
;
\
break
;
MIR_OPCODE_LIST
(
MIR_OP
)
#
undef
MIR_OP
}
}
}
}
assertSuccess
(
)
;
return
true
;
}
void
ArgumentsReplacer
:
:
assertSuccess
(
)
{
MOZ_ASSERT
(
args_
-
>
canRecoverOnBailout
(
)
)
;
MOZ_ASSERT
(
!
args_
-
>
hasLiveDefUses
(
)
)
;
}
void
ArgumentsReplacer
:
:
visitGuardToClass
(
MGuardToClass
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
args_
)
{
return
;
}
MOZ_ASSERT
(
ins
-
>
isArgumentsObjectClass
(
)
)
;
ins
-
>
replaceAllUsesWith
(
args_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitGuardArgumentsObjectFlags
(
MGuardArgumentsObjectFlags
*
ins
)
{
if
(
ins
-
>
getArgsObject
(
)
!
=
args_
)
{
return
;
}
#
ifdef
DEBUG
uint32_t
supportedBits
=
ArgumentsObject
:
:
LENGTH_OVERRIDDEN_BIT
|
ArgumentsObject
:
:
ITERATOR_OVERRIDDEN_BIT
|
ArgumentsObject
:
:
ELEMENT_OVERRIDDEN_BIT
|
ArgumentsObject
:
:
CALLEE_OVERRIDDEN_BIT
|
ArgumentsObject
:
:
FORWARDED_ARGUMENTS_BIT
;
MOZ_ASSERT
(
(
ins
-
>
flags
(
)
&
~
supportedBits
)
=
=
0
)
;
MOZ_ASSERT_IF
(
ins
-
>
flags
(
)
&
ArgumentsObject
:
:
FORWARDED_ARGUMENTS_BIT
!
args_
-
>
block
(
)
-
>
info
(
)
.
anyFormalIsAliased
(
)
)
;
#
endif
ins
-
>
replaceAllUsesWith
(
args_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitUnbox
(
MUnbox
*
ins
)
{
if
(
ins
-
>
getOperand
(
0
)
!
=
args_
)
{
return
;
}
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
ins
-
>
replaceAllUsesWith
(
args_
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitGetArgumentsObjectArg
(
MGetArgumentsObjectArg
*
ins
)
{
if
(
ins
-
>
getArgsObject
(
)
!
=
args_
)
{
return
;
}
MDefinition
*
getArg
;
if
(
isInlinedArguments
(
)
)
{
auto
*
actualArgs
=
args_
-
>
toCreateInlinedArgumentsObject
(
)
;
if
(
ins
-
>
argno
(
)
<
actualArgs
-
>
numActuals
(
)
)
{
getArg
=
actualArgs
-
>
getArg
(
ins
-
>
argno
(
)
)
;
}
else
{
auto
*
undef
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
undef
)
;
getArg
=
undef
;
}
}
else
{
auto
*
index
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
ins
-
>
argno
(
)
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
index
)
;
auto
*
loadArg
=
MGetFrameArgument
:
:
New
(
alloc
(
)
index
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
loadArg
)
;
getArg
=
loadArg
;
}
ins
-
>
replaceAllUsesWith
(
getArg
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitLoadArgumentsObjectArg
(
MLoadArgumentsObjectArg
*
ins
)
{
if
(
ins
-
>
getArgsObject
(
)
!
=
args_
)
{
return
;
}
MDefinition
*
index
=
ins
-
>
index
(
)
;
MInstruction
*
loadArg
;
if
(
isInlinedArguments
(
)
)
{
auto
*
actualArgs
=
args_
-
>
toCreateInlinedArgumentsObject
(
)
;
auto
*
length
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
actualArgs
-
>
numActuals
(
)
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
length
)
;
MInstruction
*
check
=
MBoundsCheck
:
:
New
(
alloc
(
)
index
length
)
;
check
-
>
setBailoutKind
(
ins
-
>
bailoutKind
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
check
)
;
loadArg
=
MGetInlinedArgument
:
:
New
(
alloc
(
)
check
actualArgs
)
;
}
else
{
auto
*
length
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
length
)
;
MInstruction
*
check
=
MBoundsCheck
:
:
New
(
alloc
(
)
index
length
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
check
)
;
check
-
>
setBailoutKind
(
ins
-
>
bailoutKind
(
)
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
check
=
MSpectreMaskIndex
:
:
New
(
alloc
(
)
check
length
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
check
)
;
}
loadArg
=
MGetFrameArgument
:
:
New
(
alloc
(
)
check
)
;
}
ins
-
>
block
(
)
-
>
insertBefore
(
ins
loadArg
)
;
ins
-
>
replaceAllUsesWith
(
loadArg
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitArgumentsObjectLength
(
MArgumentsObjectLength
*
ins
)
{
if
(
ins
-
>
getArgsObject
(
)
!
=
args_
)
{
return
;
}
MInstruction
*
length
;
if
(
isInlinedArguments
(
)
)
{
uint32_t
argc
=
args_
-
>
toCreateInlinedArgumentsObject
(
)
-
>
numActuals
(
)
;
length
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
argc
)
)
;
}
else
{
length
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
}
ins
-
>
block
(
)
-
>
insertBefore
(
ins
length
)
;
ins
-
>
replaceAllUsesWith
(
length
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitApplyArgsObj
(
MApplyArgsObj
*
ins
)
{
if
(
ins
-
>
getArgsObj
(
)
!
=
args_
)
{
return
;
}
MInstruction
*
newIns
;
if
(
isInlinedArguments
(
)
)
{
auto
*
actualArgs
=
args_
-
>
toCreateInlinedArgumentsObject
(
)
;
CallInfo
callInfo
(
alloc
(
)
false
ins
-
>
ignoresReturnValue
(
)
)
;
callInfo
.
initForApplyInlinedArgs
(
ins
-
>
getFunction
(
)
ins
-
>
getThis
(
)
actualArgs
-
>
numActuals
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
actualArgs
-
>
numActuals
(
)
;
i
+
+
)
{
callInfo
.
initArg
(
i
actualArgs
-
>
getArg
(
i
)
)
;
}
auto
addUndefined
=
[
this
&
ins
]
(
)
-
>
MConstant
*
{
MConstant
*
undef
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
undef
)
;
return
undef
;
}
;
bool
needsThisCheck
=
false
;
bool
isDOMCall
=
false
;
auto
*
call
=
MakeCall
(
alloc
(
)
addUndefined
callInfo
needsThisCheck
ins
-
>
getSingleTarget
(
)
isDOMCall
)
;
if
(
!
ins
-
>
maybeCrossRealm
(
)
)
{
call
-
>
setNotCrossRealm
(
)
;
}
newIns
=
call
;
}
else
{
auto
*
numArgs
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
numArgs
)
;
auto
*
apply
=
MApplyArgs
:
:
New
(
alloc
(
)
ins
-
>
getSingleTarget
(
)
ins
-
>
getFunction
(
)
numArgs
ins
-
>
getThis
(
)
)
;
if
(
!
ins
-
>
maybeCrossRealm
(
)
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
if
(
ins
-
>
ignoresReturnValue
(
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
newIns
=
apply
;
}
ins
-
>
block
(
)
-
>
insertBefore
(
ins
newIns
)
;
ins
-
>
replaceAllUsesWith
(
newIns
)
;
newIns
-
>
stealResumePoint
(
ins
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
void
ArgumentsReplacer
:
:
visitLoadFixedSlot
(
MLoadFixedSlot
*
ins
)
{
if
(
ins
-
>
object
(
)
!
=
args_
)
{
return
;
}
MOZ_ASSERT
(
ins
-
>
slot
(
)
=
=
ArgumentsObject
:
:
CALLEE_SLOT
)
;
MDefinition
*
replacement
;
if
(
isInlinedArguments
(
)
)
{
replacement
=
args_
-
>
toCreateInlinedArgumentsObject
(
)
-
>
getCallee
(
)
;
}
else
{
auto
*
callee
=
MCallee
:
:
New
(
alloc
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
callee
)
;
replacement
=
callee
;
}
ins
-
>
replaceAllUsesWith
(
replacement
)
;
ins
-
>
block
(
)
-
>
discard
(
ins
)
;
}
bool
ScalarReplacement
(
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_Escape
"
Begin
(
ScalarReplacement
)
"
)
;
EmulateStateOf
<
ObjectMemoryView
>
replaceObject
(
mir
graph
)
;
EmulateStateOf
<
ArrayMemoryView
>
replaceArray
(
mir
graph
)
;
bool
addedPhi
=
false
;
bool
shouldReplaceArguments
=
JitOptions
.
scalarReplaceArguments
&
&
!
graph
.
osrBlock
(
)
;
for
(
ReversePostorderIterator
block
=
graph
.
rpoBegin
(
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Scalar
Replacement
(
main
loop
)
"
)
)
{
return
false
;
}
for
(
MInstructionIterator
ins
=
block
-
>
begin
(
)
;
ins
!
=
block
-
>
end
(
)
;
ins
+
+
)
{
if
(
IsOptimizableObjectInstruction
(
*
ins
)
&
&
!
IsObjectEscaped
(
*
ins
)
)
{
ObjectMemoryView
view
(
graph
.
alloc
(
)
*
ins
)
;
if
(
!
replaceObject
.
run
(
view
)
)
{
return
false
;
}
view
.
assertSuccess
(
)
;
addedPhi
=
true
;
continue
;
}
if
(
IsOptimizableArrayInstruction
(
*
ins
)
&
&
!
IsArrayEscaped
(
*
ins
*
ins
)
)
{
ArrayMemoryView
view
(
graph
.
alloc
(
)
*
ins
)
;
if
(
!
replaceArray
.
run
(
view
)
)
{
return
false
;
}
view
.
assertSuccess
(
)
;
addedPhi
=
true
;
continue
;
}
if
(
shouldReplaceArguments
&
&
IsOptimizableArgumentsInstruction
(
*
ins
)
)
{
ArgumentsReplacer
replacer
(
mir
graph
*
ins
)
;
if
(
replacer
.
escapes
(
*
ins
)
)
{
continue
;
}
if
(
!
replacer
.
run
(
)
)
{
return
false
;
}
continue
;
}
}
}
if
(
addedPhi
)
{
AssertExtendedGraphCoherency
(
graph
)
;
if
(
!
EliminatePhis
(
mir
graph
ConservativeObservability
)
)
{
return
false
;
}
}
return
true
;
}
}
}
