#
include
"
jit
/
CacheIR
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
CacheIRSpewer
.
h
"
#
include
"
jit
/
IonCaches
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
const
char
*
js
:
:
jit
:
:
CacheKindNames
[
]
=
{
#
define
DEFINE_KIND
(
kind
)
#
kind
CACHE_IR_KINDS
(
DEFINE_KIND
)
#
undef
DEFINE_KIND
}
;
IRGenerator
:
:
IRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
CacheKind
cacheKind
ICState
:
:
Mode
mode
)
:
writer
(
cx
)
cx_
(
cx
)
script_
(
script
)
pc_
(
pc
)
cacheKind_
(
cacheKind
)
mode_
(
mode
)
{
}
GetPropIRGenerator
:
:
GetPropIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
CacheKind
cacheKind
ICState
:
:
Mode
mode
bool
*
isTemporarilyUnoptimizable
HandleValue
val
HandleValue
idVal
CanAttachGetter
canAttachGetter
)
:
IRGenerator
(
cx
script
pc
cacheKind
mode
)
val_
(
val
)
idVal_
(
idVal
)
isTemporarilyUnoptimizable_
(
isTemporarilyUnoptimizable
)
canAttachGetter_
(
canAttachGetter
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
{
}
static
void
EmitLoadSlotResult
(
CacheIRWriter
&
writer
ObjOperandId
holderOp
NativeObject
*
holder
Shape
*
shape
)
{
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadFixedSlotResult
(
holderOp
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
holderOp
dynamicSlotOffset
)
;
}
}
enum
class
ProxyStubType
{
None
DOMExpando
DOMShadowed
DOMUnshadowed
Generic
}
;
static
ProxyStubType
GetProxyStubType
(
JSContext
*
cx
HandleObject
obj
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
ProxyStubType
:
:
None
;
if
(
!
IsCacheableDOMProxy
(
obj
)
)
return
ProxyStubType
:
:
Generic
;
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
{
cx
-
>
clearPendingException
(
)
;
return
ProxyStubType
:
:
None
;
}
if
(
DOMProxyIsShadowing
(
shadows
)
)
{
if
(
shadows
=
=
ShadowsViaDirectExpando
|
|
shadows
=
=
ShadowsViaIndirectExpando
)
return
ProxyStubType
:
:
DOMExpando
;
return
ProxyStubType
:
:
DOMShadowed
;
}
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
return
ProxyStubType
:
:
DOMUnshadowed
;
}
bool
GetPropIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
{
MOZ_ASSERT
(
getElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
val_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
nameOrSymbol
)
{
if
(
tryAttachObjectLength
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachNative
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachUnboxed
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachUnboxedExpando
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachTypedObject
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachModuleNamespace
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachWindowProxy
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachCrossCompartmentWrapper
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachFunction
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachProxy
(
obj
objId
id
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
if
(
tryAttachProxyElement
(
obj
objId
)
)
return
true
;
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
getElemKeyValueId
(
)
&
index
&
indexId
)
)
{
if
(
tryAttachTypedElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachDenseElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachDenseElementHole
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachUnboxedArrayElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachArgumentsObjectArg
(
obj
objId
index
indexId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
trackNotAttached
(
)
;
return
false
;
}
if
(
nameOrSymbol
)
{
if
(
tryAttachPrimitive
(
valId
id
)
)
return
true
;
if
(
tryAttachStringLength
(
valId
id
)
)
return
true
;
if
(
tryAttachMagicArgumentsName
(
valId
id
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
if
(
idVal_
.
isInt32
(
)
)
{
ValOperandId
indexId
=
getElemKeyValueId
(
)
;
if
(
tryAttachStringChar
(
valId
indexId
)
)
return
true
;
if
(
tryAttachMagicArgument
(
valId
indexId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
trackNotAttached
(
)
;
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachIdempotentStub
(
)
{
MOZ_ASSERT
(
idempotent
(
)
)
;
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
RootedId
id
(
cx_
NameToId
(
idVal_
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
tryAttachNative
(
obj
objId
id
)
)
return
true
;
if
(
GetProxyStubType
(
cx_
obj
id
)
=
=
ProxyStubType
:
:
DOMUnshadowed
)
return
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
;
return
false
;
}
static
bool
IsCacheableNoProperty
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
jsid
id
jsbytecode
*
pc
)
{
if
(
shape
)
return
false
;
MOZ_ASSERT
(
!
holder
)
;
if
(
!
pc
)
{
return
false
;
}
if
(
*
pc
=
=
JSOP_GETBOUNDNAME
|
|
cx
-
>
compartment
(
)
-
>
behaviors
(
)
.
extraWarnings
(
cx
)
)
return
false
;
return
CheckHasNoSuchProperty
(
cx
obj
id
)
;
}
enum
NativeGetPropCacheability
{
CanAttachNone
CanAttachReadSlot
CanAttachCallGetter
}
;
static
NativeGetPropCacheability
CanAttachNativeGetProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
jsbytecode
*
pc
CanAttachGetter
canAttachGetter
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
JSObject
*
baseHolder
=
nullptr
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
baseHolder
&
prop
)
)
return
CanAttachNone
;
MOZ_ASSERT
(
!
holder
)
;
if
(
baseHolder
)
{
if
(
!
baseHolder
-
>
isNative
(
)
)
return
CanAttachNone
;
holder
.
set
(
&
baseHolder
-
>
as
<
NativeObject
>
(
)
)
;
}
shape
.
set
(
prop
.
maybeShape
(
)
)
;
if
(
IsCacheableGetPropReadSlotForIonOrCacheIR
(
obj
holder
prop
)
)
return
CanAttachReadSlot
;
if
(
!
pc
)
return
CanAttachNone
;
if
(
IsCacheableNoProperty
(
cx
obj
holder
shape
id
pc
)
)
return
CanAttachReadSlot
;
if
(
canAttachGetter
=
=
CanAttachGetter
:
:
No
)
return
CanAttachNone
;
if
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
isTemporarilyUnoptimizable
)
)
return
CanAttachCallGetter
;
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
return
CanAttachCallGetter
;
return
CanAttachNone
;
}
static
void
GeneratePrototypeGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
)
{
MOZ_ASSERT
(
obj
!
=
holder
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
pobj
)
return
;
while
(
pobj
!
=
holder
)
{
if
(
pobj
-
>
hasUncacheableProto
(
)
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
isSingleton
(
)
)
{
writer
.
guardProto
(
protoId
pobj
-
>
staticPrototype
(
)
)
;
}
else
{
writer
.
guardGroup
(
protoId
pobj
-
>
group
(
)
)
;
}
}
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
}
static
void
GeneratePrototypeHoleGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
while
(
pobj
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
hasUncacheableProto
(
)
&
&
!
pobj
-
>
isSingleton
(
)
)
writer
.
guardGroup
(
protoId
pobj
-
>
group
(
)
)
;
writer
.
guardShape
(
protoId
pobj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
guardNoDenseElements
(
protoId
)
;
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
}
static
void
TestMatchingReceiver
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
Maybe
<
ObjOperandId
>
*
expandoId
)
{
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
{
expandoId
-
>
emplace
(
writer
.
guardAndLoadUnboxedExpando
(
objId
)
)
;
writer
.
guardShape
(
expandoId
-
>
ref
(
)
expando
-
>
lastProperty
(
)
)
;
}
else
{
writer
.
guardNoUnboxedExpando
(
objId
)
;
}
}
else
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
|
|
obj
-
>
is
<
TypedObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
}
else
{
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
MOZ_ASSERT
(
shape
)
;
writer
.
guardShape
(
objId
shape
)
;
}
}
static
void
EmitReadSlotGuard
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
Maybe
<
ObjOperandId
>
*
holderId
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
objId
&
expandoId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
if
(
holder
)
{
holderId
-
>
emplace
(
writer
.
loadObject
(
holder
)
)
;
writer
.
guardShape
(
holderId
-
>
ref
(
)
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
else
{
JSObject
*
proto
=
obj
-
>
taggedProto
(
)
.
toObjectOrNull
(
)
;
ObjOperandId
lastObjId
=
objId
;
while
(
proto
)
{
ObjOperandId
protoId
=
writer
.
loadProto
(
lastObjId
)
;
writer
.
guardShape
(
protoId
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
proto
=
proto
-
>
staticPrototype
(
)
;
lastObjId
=
protoId
;
}
}
}
else
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holderId
-
>
emplace
(
*
expandoId
)
;
}
else
{
holderId
-
>
emplace
(
objId
)
;
}
}
static
void
EmitReadSlotResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
holderId
;
EmitReadSlotGuard
(
writer
obj
holder
objId
&
holderId
)
;
if
(
obj
=
=
holder
&
&
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
holder
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
holder
)
{
MOZ_ASSERT
(
holderId
-
>
valid
(
)
)
;
EmitLoadSlotResult
(
writer
*
holderId
&
holder
-
>
as
<
NativeObject
>
(
)
shape
)
;
}
else
{
MOZ_ASSERT
(
holderId
.
isNothing
(
)
)
;
writer
.
loadUndefinedResult
(
)
;
}
}
static
void
EmitReadSlotReturn
(
CacheIRWriter
&
writer
JSObject
*
JSObject
*
holder
Shape
*
shape
bool
wrapResult
=
false
)
{
if
(
holder
)
{
MOZ_ASSERT
(
shape
)
;
if
(
wrapResult
)
writer
.
wrapResult
(
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
}
static
void
EmitCallGetterResultNoGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
writer
.
callNativeGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
return
;
}
MOZ_ASSERT
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
writer
.
callScriptedGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
}
static
void
EmitCallGetterResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ICState
:
:
Mode
mode
)
{
if
(
mode
=
=
ICState
:
:
Mode
:
:
Specialized
|
|
IsWindow
(
obj
)
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
objId
&
expandoId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
}
else
{
writer
.
guardHasGetterSetter
(
objId
shape
)
;
}
EmitCallGetterResultNoGuards
(
writer
obj
holder
shape
objId
)
;
}
void
GetPropIRGenerator
:
:
attachMegamorphicNativeSlot
(
ObjOperandId
objId
jsid
id
bool
handleMissing
)
{
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
)
{
writer
.
megamorphicLoadSlotResult
(
objId
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
handleMissing
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
writer
.
megamorphicLoadSlotByValueResult
(
objId
getElemKeyValueId
(
)
handleMissing
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
handleMissing
?
"
MegamorphicMissingNativeSlot
"
:
"
MegamorphicNativeSlot
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachNative
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
obj
id
&
holder
&
shape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
MOZ_ASSERT_IF
(
idempotent
(
)
type
=
=
CanAttachNone
|
|
(
type
=
=
CanAttachReadSlot
&
&
holder
)
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
false
;
case
CanAttachReadSlot
:
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
attachMegamorphicNativeSlot
(
objId
id
holder
=
=
nullptr
)
;
return
true
;
}
maybeEmitIdGuard
(
id
)
;
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
obj
=
=
holder
)
{
if
(
IsPreliminaryObject
(
obj
)
)
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
else
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
EmitReadSlotResult
(
writer
obj
holder
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
holder
shape
)
;
trackAttached
(
"
NativeSlot
"
)
;
return
true
;
case
CanAttachCallGetter
:
maybeEmitIdGuard
(
id
)
;
EmitCallGetterResult
(
writer
obj
holder
shape
objId
mode_
)
;
trackAttached
(
"
NativeGetter
"
)
;
return
true
;
}
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsWindowProxy
(
obj
)
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
return
false
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
cx_
-
>
runtime
(
)
-
>
maybeWindowProxyClass
(
)
)
;
MOZ_ASSERT
(
ToWindowIfWindowProxy
(
obj
)
=
=
cx_
-
>
global
(
)
)
;
HandleObject
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
windowObj
id
&
holder
&
shape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
false
;
case
CanAttachReadSlot
:
{
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadObject
(
windowObj
)
;
EmitReadSlotResult
(
writer
windowObj
holder
shape
windowObjId
)
;
EmitReadSlotReturn
(
writer
windowObj
holder
shape
)
;
trackAttached
(
"
WindowProxySlot
"
)
;
return
true
;
}
case
CanAttachCallGetter
:
{
if
(
!
IsCacheableGetPropCallNative
(
windowObj
holder
shape
)
)
return
false
;
JSFunction
*
callee
=
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
!
callee
-
>
jitInfo
(
)
|
|
callee
-
>
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadObject
(
windowObj
)
;
EmitCallGetterResult
(
writer
windowObj
holder
shape
windowObjId
mode_
)
;
trackAttached
(
"
WindowProxyGetter
"
)
;
return
true
;
}
}
MOZ_CRASH
(
"
Unreachable
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachCrossCompartmentWrapper
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsWrapper
(
obj
)
|
|
Wrapper
:
:
wrapperHandler
(
obj
)
!
=
&
CrossCompartmentWrapper
:
:
singleton
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
return
false
;
RootedObject
unwrapped
(
cx_
Wrapper
:
:
wrappedObject
(
obj
)
)
;
MOZ_ASSERT
(
unwrapped
=
=
UnwrapOneChecked
(
obj
)
)
;
if
(
unwrapped
-
>
compartment
(
)
-
>
zone
(
)
!
=
cx_
-
>
compartment
(
)
-
>
zone
(
)
)
return
false
;
RootedObject
wrappedGlobal
(
cx_
&
obj
-
>
global
(
)
)
;
if
(
!
cx_
-
>
compartment
(
)
-
>
wrap
(
cx_
&
wrappedGlobal
)
)
return
false
;
AutoCompartment
ac
(
cx_
unwrapped
)
;
bool
isWindowProxy
=
IsWindowProxy
(
unwrapped
)
;
if
(
isWindowProxy
)
{
MOZ_ASSERT
(
ToWindowIfWindowProxy
(
unwrapped
)
=
=
unwrapped
-
>
compartment
(
)
-
>
maybeGlobal
(
)
)
;
unwrapped
=
cx_
-
>
global
(
)
;
MOZ_ASSERT
(
unwrapped
)
;
}
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
unwrapped
id
&
holder
&
shape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
if
(
canCache
!
=
CanAttachReadSlot
)
return
false
;
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
unwrapped
=
=
holder
)
{
if
(
IsPreliminaryObject
(
unwrapped
)
)
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
else
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
guardIsCrossCompartmentWrapper
(
objId
)
;
ObjOperandId
wrapperTargetId
=
writer
.
loadWrapperTarget
(
objId
)
;
writer
.
guardCompartment
(
wrapperTargetId
wrappedGlobal
unwrapped
-
>
compartment
(
)
)
;
ObjOperandId
unwrappedId
=
wrapperTargetId
;
if
(
isWindowProxy
)
{
writer
.
guardClass
(
wrapperTargetId
GuardClassKind
:
:
WindowProxy
)
;
unwrappedId
=
writer
.
loadWrapperTarget
(
wrapperTargetId
)
;
}
EmitReadSlotResult
(
writer
unwrapped
holder
shape
unwrappedId
)
;
EmitReadSlotReturn
(
writer
unwrapped
holder
shape
true
)
;
trackAttached
(
"
CCWSlot
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
bool
handleDOMProxies
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
if
(
!
handleDOMProxies
)
{
writer
.
guardNotDOMProxy
(
objId
)
;
}
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
|
|
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
{
maybeEmitIdGuard
(
id
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
writer
.
callProxyGetByValueResult
(
objId
getElemKeyValueId
(
)
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
GenericProxy
"
)
;
return
true
;
}
ObjOperandId
IRGenerator
:
:
guardDOMProxyExpandoObjectAndShape
(
JSObject
*
obj
ObjOperandId
objId
const
Value
&
expandoVal
JSObject
*
expandoObj
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
ValOperandId
expandoValId
;
if
(
expandoVal
.
isObject
(
)
)
expandoValId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
else
expandoValId
=
writer
.
loadDOMExpandoValueIgnoreGeneration
(
objId
)
;
ObjOperandId
expandoObjId
=
writer
.
guardIsObject
(
expandoValId
)
;
writer
.
guardShape
(
expandoObjId
expandoObj
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
)
;
return
expandoObjId
;
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedValue
expandoVal
(
cx_
GetProxyPrivate
(
obj
)
)
;
RootedObject
expandoObj
(
cx_
)
;
if
(
expandoVal
.
isObject
(
)
)
{
expandoObj
=
&
expandoVal
.
toObject
(
)
;
}
else
{
MOZ_ASSERT
(
!
expandoVal
.
isUndefined
(
)
"
How
did
a
missing
expando
manage
to
shadow
things
?
"
)
;
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
expandoAndGeneration
)
;
expandoObj
=
&
expandoAndGeneration
-
>
expando
.
toObject
(
)
;
}
RootedNativeObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
expandoObj
id
&
holder
&
propShape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
if
(
canCache
!
=
CanAttachReadSlot
&
&
canCache
!
=
CanAttachCallGetter
)
return
false
;
if
(
!
holder
)
return
false
;
MOZ_ASSERT
(
holder
=
=
expandoObj
)
;
maybeEmitIdGuard
(
id
)
;
ObjOperandId
expandoObjId
=
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
expandoObjId
&
expandoObj
-
>
as
<
NativeObject
>
(
)
propShape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachCallGetter
)
;
EmitCallGetterResultNoGuards
(
writer
expandoObj
expandoObj
propShape
objId
)
;
}
trackAttached
(
"
DOMProxyExpando
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DOMProxyShadowed
"
)
;
return
true
;
}
static
void
CheckDOMProxyExpandoDoesNotShadow
(
CacheIRWriter
&
writer
JSObject
*
obj
jsid
id
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Value
expandoVal
=
GetProxyPrivate
(
obj
)
;
ValOperandId
expandoId
;
if
(
!
expandoVal
.
isObject
(
)
&
&
!
expandoVal
.
isUndefined
(
)
)
{
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
expandoId
=
writer
.
loadDOMExpandoValueGuardGeneration
(
objId
expandoAndGeneration
)
;
expandoVal
=
expandoAndGeneration
-
>
expando
;
}
else
{
expandoId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
}
if
(
expandoVal
.
isUndefined
(
)
)
{
writer
.
guardType
(
expandoId
JSVAL_TYPE_UNDEFINED
)
;
}
else
if
(
expandoVal
.
isObject
(
)
)
{
NativeObject
&
expandoObj
=
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
!
expandoObj
.
containsPure
(
id
)
)
;
writer
.
guardDOMExpandoMissingOrGuardShape
(
expandoId
expandoObj
.
lastProperty
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Invalid
expando
value
"
)
;
}
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
checkObj
(
cx_
obj
-
>
staticPrototype
(
)
)
;
if
(
!
checkObj
)
return
false
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
checkObj
id
&
holder
&
shape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
MOZ_ASSERT_IF
(
idempotent
(
)
canCache
=
=
CanAttachNone
|
|
(
canCache
=
=
CanAttachReadSlot
&
&
holder
)
)
;
if
(
canCache
=
=
CanAttachNone
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
if
(
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachCallGetter
)
;
EmitCallGetterResultNoGuards
(
writer
checkObj
holder
shape
objId
)
;
}
}
else
{
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
}
trackAttached
(
"
DOMProxyUnshadowed
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
ProxyStubType
type
=
GetProxyStubType
(
cx_
obj
id
)
;
if
(
type
=
=
ProxyStubType
:
:
None
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
return
tryAttachGenericProxy
(
obj
objId
id
true
)
;
switch
(
type
)
{
case
ProxyStubType
:
:
None
:
break
;
case
ProxyStubType
:
:
DOMExpando
:
if
(
tryAttachDOMProxyExpando
(
obj
objId
id
)
)
return
true
;
if
(
*
isTemporarilyUnoptimizable_
)
{
return
false
;
}
MOZ_FALLTHROUGH
;
case
ProxyStubType
:
:
DOMShadowed
:
return
tryAttachDOMProxyShadowed
(
obj
objId
id
)
;
case
ProxyStubType
:
:
DOMUnshadowed
:
if
(
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
)
return
true
;
if
(
*
isTemporarilyUnoptimizable_
)
{
return
false
;
}
return
tryAttachGenericProxy
(
obj
objId
id
true
)
;
case
ProxyStubType
:
:
Generic
:
return
tryAttachGenericProxy
(
obj
objId
id
false
)
;
}
MOZ_CRASH
(
"
Unexpected
ProxyStubType
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
!
property
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
writer
.
loadUnboxedPropertyResult
(
objId
property
-
>
type
UnboxedPlainObject
:
:
offsetOfData
(
)
+
property
-
>
offset
)
;
if
(
property
-
>
type
=
=
JSVAL_TYPE_OBJECT
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
trackAttached
(
"
Unboxed
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxedExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
!
expando
)
return
false
;
Shape
*
shape
=
expando
-
>
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
EmitReadSlotResult
(
writer
obj
obj
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
obj
shape
)
;
trackAttached
(
"
UnboxedExpando
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachTypedObject
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
|
|
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
|
|
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
{
return
false
;
}
TypedObject
*
typedObj
=
&
obj
-
>
as
<
TypedObject
>
(
)
;
if
(
!
typedObj
-
>
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
return
false
;
StructTypeDescr
*
structDescr
=
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
return
false
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
return
false
;
Shape
*
shape
=
typedObj
-
>
maybeShape
(
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
shape
-
>
getObjectClass
(
)
)
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
uint32_t
typeDescr
=
SimpleTypeDescrKey
(
&
fieldDescr
-
>
as
<
SimpleTypeDescr
>
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
shape
)
;
writer
.
loadTypedObjectResult
(
objId
fieldOffset
layout
typeDescr
)
;
bool
monitorLoad
=
false
;
if
(
SimpleTypeDescrKeyIsScalar
(
typeDescr
)
)
{
Scalar
:
:
Type
type
=
ScalarTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
=
=
Scalar
:
:
Uint32
;
}
else
{
ReferenceTypeDescr
:
:
Type
type
=
ReferenceTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
!
=
ReferenceTypeDescr
:
:
TYPE_STRING
;
}
if
(
monitorLoad
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObject
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachObjectLength
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
return
false
;
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
if
(
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
loadInt32ArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ArrayLength
"
)
;
return
true
;
}
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
{
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnboxedArray
)
;
writer
.
loadUnboxedArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
UnboxedArrayLength
"
)
;
return
true
;
}
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
&
&
!
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
{
maybeEmitIdGuard
(
id
)
;
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ArgumentsObjectLength
"
)
;
return
true
;
}
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachFunction
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
return
false
;
JSObject
*
holder
=
nullptr
;
PropertyResult
prop
;
if
(
LookupPropertyPure
(
cx_
obj
id
&
holder
&
prop
)
)
return
false
;
JSFunction
*
fun
=
&
obj
-
>
as
<
JSFunction
>
(
)
;
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
if
(
fun
-
>
hasResolvedLength
(
)
)
return
false
;
if
(
fun
-
>
isInterpretedLazy
(
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
JSFunction
)
;
writer
.
loadFunctionLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
FunctionLength
"
)
;
return
true
;
}
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachModuleNamespace
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ModuleNamespaceObject
>
(
)
)
return
false
;
Rooted
<
ModuleNamespaceObject
*
>
ns
(
cx_
&
obj
-
>
as
<
ModuleNamespaceObject
>
(
)
)
;
RootedModuleEnvironmentObject
env
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
id
env
.
address
(
)
shape
.
address
(
)
)
)
return
false
;
if
(
env
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
env
shape
-
>
propid
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardSpecificObject
(
objId
ns
)
;
ObjOperandId
envId
=
writer
.
loadObject
(
env
)
;
EmitLoadSlotResult
(
writer
envId
env
shape
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ModuleNamespace
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
HandleId
id
)
{
JSValueType
primitiveType
;
RootedNativeObject
proto
(
cx_
)
;
if
(
val_
.
isString
(
)
)
{
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
return
false
;
}
primitiveType
=
JSVAL_TYPE_STRING
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_String
)
)
;
}
else
if
(
val_
.
isNumber
(
)
)
{
primitiveType
=
JSVAL_TYPE_DOUBLE
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Number
)
)
;
}
else
if
(
val_
.
isBoolean
(
)
)
{
primitiveType
=
JSVAL_TYPE_BOOLEAN
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Boolean
)
)
;
}
else
if
(
val_
.
isSymbol
(
)
)
{
primitiveType
=
JSVAL_TYPE_SYMBOL
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Symbol
)
)
;
}
else
{
MOZ_ASSERT
(
val_
.
isNullOrUndefined
(
)
|
|
val_
.
isMagic
(
)
)
;
return
false
;
}
if
(
!
proto
)
return
false
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
proto
id
&
holder
&
shape
pc_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
if
(
type
!
=
CanAttachReadSlot
)
return
false
;
if
(
holder
)
{
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
}
writer
.
guardType
(
valId
primitiveType
)
;
maybeEmitIdGuard
(
id
)
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
EmitReadSlotResult
(
writer
proto
holder
shape
protoId
)
;
EmitReadSlotReturn
(
writer
proto
holder
shape
)
;
trackAttached
(
"
Primitive
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachStringLength
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isString
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
return
false
;
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
loadStringLengthResult
(
strId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StringLength
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachStringChar
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isString
(
)
)
return
false
;
int32_t
index
=
idVal_
.
toInt32
(
)
;
if
(
index
<
0
)
return
false
;
JSString
*
str
=
val_
.
toString
(
)
;
if
(
size_t
(
index
)
>
=
str
-
>
length
(
)
)
return
false
;
if
(
str
-
>
isRope
(
)
)
{
JSRope
*
rope
=
&
str
-
>
asRope
(
)
;
if
(
size_t
(
index
)
>
=
rope
-
>
leftChild
(
)
-
>
length
(
)
)
return
false
;
str
=
rope
-
>
leftChild
(
)
;
}
if
(
!
str
-
>
isLinear
(
)
|
|
str
-
>
asLinear
(
)
.
latin1OrTwoByteChar
(
index
)
>
=
StaticStrings
:
:
UNIT_STATIC_LIMIT
)
{
return
false
;
}
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
Int32OperandId
int32IndexId
=
writer
.
guardIsInt32Index
(
indexId
)
;
writer
.
loadStringCharResult
(
strId
int32IndexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StringChar
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachMagicArgumentsName
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
return
false
;
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
&
&
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
writer
.
loadFrameNumActualArgsResult
(
)
;
writer
.
returnFromIC
(
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
;
writer
.
loadFrameCalleeResult
(
)
;
writer
.
typeMonitorResult
(
)
;
}
trackAttached
(
"
MagicArgumentsName
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachMagicArgument
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
return
false
;
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
Int32OperandId
int32IndexId
=
writer
.
guardIsInt32Index
(
indexId
)
;
writer
.
loadFrameArgumentResult
(
int32IndexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
MagicArgument
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachArgumentsObjectArg
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
ArgumentsObject
>
(
)
|
|
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenElement
(
)
)
return
false
;
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectArgResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ArgumentsObjectArg
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDenseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
loadDenseElementResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DenseElement
"
)
;
return
true
;
}
static
bool
CanAttachDenseElementHole
(
JSObject
*
obj
bool
ownProp
)
{
do
{
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
if
(
ClassCanHaveExtraProperties
(
obj
-
>
getClass
(
)
)
)
return
false
;
if
(
ownProp
)
return
true
;
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
break
;
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
!
=
0
)
return
false
;
obj
=
proto
;
}
while
(
true
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDenseElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
if
(
!
CanAttachDenseElementHole
(
obj
false
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
GeneratePrototypeHoleGuards
(
writer
obj
objId
)
;
writer
.
loadDenseElementHoleResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DenseElementHole
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxedArrayElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
if
(
index
>
=
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
initializedLength
(
)
)
return
false
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
JSValueType
elementType
=
obj
-
>
group
(
)
-
>
unboxedLayoutDontCheckGeneration
(
)
.
elementType
(
)
;
writer
.
loadUnboxedArrayElementResult
(
objId
indexId
elementType
)
;
if
(
elementType
=
=
JSVAL_TYPE_OBJECT
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
trackAttached
(
"
UnboxedArrayElement
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachTypedElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
TypedThingRequiresFloatingPoint
(
obj
)
)
return
false
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
return
false
;
if
(
IsPrimitiveArrayTypedObject
(
obj
)
&
&
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
false
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
layout
!
=
Layout_TypedArray
)
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
obj
-
>
as
<
ShapedObject
>
(
)
.
shape
(
)
)
;
writer
.
loadTypedElementResult
(
objId
indexId
layout
TypedThingElementType
(
obj
)
)
;
if
(
TypedThingElementType
(
obj
)
=
=
Scalar
:
:
Type
:
:
Uint32
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedElement
"
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachProxyElement
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
false
;
writer
.
guardIsProxy
(
objId
)
;
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
writer
.
callProxyGetByValueResult
(
objId
getElemKeyValueId
(
)
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ProxyElement
"
)
;
return
true
;
}
void
GetPropIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
val_
)
;
sp
.
valueProperty
(
guard
"
property
"
idVal_
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
GetPropIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
val_
)
;
sp
.
valueProperty
(
guard
"
property
"
idVal_
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
IRGenerator
:
:
emitIdGuard
(
ValOperandId
valId
jsid
id
)
{
if
(
JSID_IS_SYMBOL
(
id
)
)
{
SymbolOperandId
symId
=
writer
.
guardIsSymbol
(
valId
)
;
writer
.
guardSpecificSymbol
(
symId
JSID_TO_SYMBOL
(
id
)
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
)
)
;
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
writer
.
guardSpecificAtom
(
strId
JSID_TO_ATOM
(
id
)
)
;
}
}
void
GetPropIRGenerator
:
:
maybeEmitIdGuard
(
jsid
id
)
{
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
)
{
MOZ_ASSERT
(
&
idVal_
.
toString
(
)
-
>
asAtom
(
)
=
=
JSID_TO_ATOM
(
id
)
)
;
return
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
emitIdGuard
(
getElemKeyValueId
(
)
id
)
;
}
void
SetPropIRGenerator
:
:
maybeEmitIdGuard
(
jsid
id
)
{
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
MOZ_ASSERT
(
&
idVal_
.
toString
(
)
-
>
asAtom
(
)
=
=
JSID_TO_ATOM
(
id
)
)
;
return
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
emitIdGuard
(
setElemKeyValueId
(
)
id
)
;
}
GetNameIRGenerator
:
:
GetNameIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleObject
env
HandlePropertyName
name
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
GetName
mode
)
env_
(
env
)
name_
(
name
)
{
}
bool
GetNameIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetName
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ObjOperandId
envId
(
writer
.
setInputOperandId
(
0
)
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
if
(
tryAttachGlobalNameValue
(
envId
id
)
)
return
true
;
if
(
tryAttachGlobalNameGetter
(
envId
id
)
)
return
true
;
if
(
tryAttachEnvironmentName
(
envId
id
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
bool
CanAttachGlobalName
(
JSContext
*
cx
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
)
{
RootedNativeObject
current
(
cx
globalLexical
)
;
while
(
true
)
{
shape
.
set
(
current
-
>
lookup
(
cx
id
)
)
;
if
(
shape
)
break
;
if
(
current
=
=
globalLexical
)
{
current
=
&
globalLexical
-
>
global
(
)
;
}
else
{
if
(
!
current
-
>
staticPrototypeIsImmutable
(
)
)
return
false
;
JSObject
*
proto
=
current
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
!
proto
-
>
is
<
NativeObject
>
(
)
)
return
false
;
current
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
holder
.
set
(
current
)
;
return
true
;
}
bool
GetNameIRGenerator
:
:
tryAttachGlobalNameValue
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
return
false
;
if
(
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
false
;
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
holder
=
=
globalLexical
)
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
objId
dynamicSlotOffset
)
;
}
else
{
if
(
!
IsCacheableGetPropReadSlotForIonOrCacheIR
(
&
globalLexical
-
>
global
(
)
holder
PropertyResult
(
shape
)
)
)
return
false
;
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
ObjOperandId
holderId
=
globalId
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
GlobalNameValue
"
)
;
return
true
;
}
bool
GetNameIRGenerator
:
:
tryAttachGlobalNameGetter
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
return
false
;
if
(
holder
=
=
globalLexical
)
return
false
;
if
(
!
IsCacheableGetPropCallNative
(
&
globalLexical
-
>
global
(
)
holder
shape
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitCallGetterResultNoGuards
(
writer
&
globalLexical
-
>
global
(
)
holder
shape
globalId
)
;
trackAttached
(
"
GlobalNameGetter
"
)
;
return
true
;
}
static
bool
NeedEnvironmentShapeGuard
(
JSObject
*
envObj
)
{
if
(
!
envObj
-
>
is
<
CallObject
>
(
)
)
return
true
;
CallObject
*
callObj
=
&
envObj
-
>
as
<
CallObject
>
(
)
;
JSFunction
*
fun
=
&
callObj
-
>
callee
(
)
;
if
(
!
fun
-
>
hasScript
(
)
|
|
fun
-
>
nonLazyScript
(
)
-
>
funHasExtensibleScope
(
)
)
return
true
;
return
false
;
}
bool
GetNameIRGenerator
:
:
tryAttachEnvironmentName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
RootedObject
env
(
cx_
env_
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
while
(
env
)
{
if
(
env
-
>
is
<
GlobalObject
>
(
)
)
{
shape
=
env
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
break
;
return
false
;
}
if
(
!
env
-
>
is
<
EnvironmentObject
>
(
)
|
|
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
return
false
;
MOZ_ASSERT
(
!
env
-
>
hasUncacheableProto
(
)
)
;
shape
=
env
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
break
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
holder
=
&
env
-
>
as
<
NativeObject
>
(
)
;
if
(
!
IsCacheableGetPropReadSlotForIonOrCacheIR
(
holder
holder
PropertyResult
(
shape
)
)
)
return
false
;
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
return
false
;
ObjOperandId
lastObjId
=
objId
;
env
=
env_
;
while
(
env
)
{
if
(
NeedEnvironmentShapeGuard
(
env
)
)
writer
.
guardShape
(
lastObjId
env
-
>
maybeShape
(
)
)
;
if
(
env
=
=
holder
)
break
;
lastObjId
=
writer
.
loadEnclosingEnvironment
(
lastObjId
)
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadEnvironmentFixedSlotResult
(
lastObjId
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadEnvironmentDynamicSlotResult
(
lastObjId
dynamicSlotOffset
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
EnvironmentName
"
)
;
return
true
;
}
void
GetNameIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
StringValue
(
name_
)
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
GetNameIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
StringValue
(
name_
)
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
BindNameIRGenerator
:
:
BindNameIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleObject
env
HandlePropertyName
name
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
BindName
mode
)
env_
(
env
)
name_
(
name
)
{
}
bool
BindNameIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
BindName
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ObjOperandId
envId
(
writer
.
setInputOperandId
(
0
)
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
if
(
tryAttachGlobalName
(
envId
id
)
)
return
true
;
if
(
tryAttachEnvironmentName
(
envId
id
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
bool
BindNameIRGenerator
:
:
tryAttachGlobalName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
JSObject
*
result
=
nullptr
;
if
(
Shape
*
shape
=
globalLexical
-
>
lookup
(
cx_
id
)
)
{
if
(
globalLexical
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
|
|
!
shape
-
>
writable
(
)
)
return
false
;
result
=
globalLexical
;
}
else
{
result
=
&
globalLexical
-
>
global
(
)
;
}
if
(
result
=
=
globalLexical
)
{
writer
.
loadObjectResult
(
objId
)
;
}
else
{
Shape
*
shape
=
result
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
shape
-
>
configurable
(
)
)
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
loadObjectResult
(
globalId
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GlobalName
"
)
;
return
true
;
}
bool
BindNameIRGenerator
:
:
tryAttachEnvironmentName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
RootedObject
env
(
cx_
env_
)
;
RootedShape
shape
(
cx_
)
;
while
(
true
)
{
if
(
!
env
-
>
is
<
GlobalObject
>
(
)
&
&
!
env
-
>
is
<
EnvironmentObject
>
(
)
)
return
false
;
if
(
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
return
false
;
MOZ_ASSERT
(
!
env
-
>
hasUncacheableProto
(
)
)
;
if
(
env
-
>
isUnqualifiedVarObj
(
)
)
break
;
shape
=
env
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
break
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
RootedNativeObject
holder
(
cx_
&
env
-
>
as
<
NativeObject
>
(
)
)
;
if
(
shape
&
&
holder
-
>
is
<
EnvironmentObject
>
(
)
&
&
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
|
|
!
shape
-
>
writable
(
)
)
)
{
return
false
;
}
ObjOperandId
lastObjId
=
objId
;
env
=
env_
;
while
(
env
)
{
if
(
NeedEnvironmentShapeGuard
(
env
)
&
&
!
env
-
>
is
<
GlobalObject
>
(
)
)
writer
.
guardShape
(
lastObjId
env
-
>
maybeShape
(
)
)
;
if
(
env
=
=
holder
)
break
;
lastObjId
=
writer
.
loadEnclosingEnvironment
(
lastObjId
)
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
writer
.
loadObjectResult
(
lastObjId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
EnvironmentName
"
)
;
return
true
;
}
void
BindNameIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
StringValue
(
name_
)
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
BindNameIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
StringValue
(
name_
)
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
InIRGenerator
:
:
InIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
key
HandleObject
obj
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
In
mode
)
key_
(
key
)
obj_
(
obj
)
{
}
bool
InIRGenerator
:
:
tryAttachDenseIn
(
uint32_t
index
Int32OperandId
indexId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
loadDenseElementExistsResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DenseIn
"
)
;
return
true
;
}
bool
InIRGenerator
:
:
tryAttachDenseInHole
(
uint32_t
index
Int32OperandId
indexId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
if
(
!
CanAttachDenseElementHole
(
obj
false
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
GeneratePrototypeHoleGuards
(
writer
obj
objId
)
;
writer
.
loadDenseElementHoleExistsResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DenseInHole
"
)
;
return
true
;
}
bool
InIRGenerator
:
:
tryAttachNativeIn
(
HandleId
key
ValOperandId
keyId
HandleObject
obj
ObjOperandId
objId
)
{
PropertyResult
prop
;
JSObject
*
holder
;
if
(
!
LookupPropertyPure
(
cx_
obj
key
&
holder
&
prop
)
)
return
false
;
if
(
!
prop
.
isNativeProperty
(
)
)
return
false
;
Maybe
<
ObjOperandId
>
holderId
;
emitIdGuard
(
keyId
key
)
;
EmitReadSlotGuard
(
writer
obj
holder
objId
&
holderId
)
;
writer
.
loadBooleanResult
(
true
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NativeIn
"
)
;
return
true
;
}
bool
InIRGenerator
:
:
tryAttachNativeInDoesNotExist
(
HandleId
key
ValOperandId
keyId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
CheckHasNoSuchProperty
(
cx_
obj
key
)
)
return
false
;
Maybe
<
ObjOperandId
>
holderId
;
emitIdGuard
(
keyId
key
)
;
EmitReadSlotGuard
(
writer
obj
nullptr
objId
&
holderId
)
;
writer
.
loadBooleanResult
(
false
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NativeInDoesNotExist
"
)
;
return
true
;
}
bool
InIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
In
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
keyId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
1
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
key_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
nameOrSymbol
)
{
if
(
tryAttachNativeIn
(
id
keyId
obj_
objId
)
)
return
true
;
if
(
tryAttachNativeInDoesNotExist
(
id
keyId
obj_
objId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
key_
keyId
&
index
&
indexId
)
)
{
if
(
tryAttachDenseIn
(
index
indexId
obj_
objId
)
)
return
true
;
if
(
tryAttachDenseInHole
(
index
indexId
obj_
objId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
trackNotAttached
(
)
;
return
false
;
}
void
InIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
obj_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
key_
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
InIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
ObjectValue
(
*
obj_
)
)
;
sp
.
valueProperty
(
guard
"
property
"
key_
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
HasOwnIRGenerator
:
:
HasOwnIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
key
HandleValue
value
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
HasOwn
mode
)
key_
(
key
)
val_
(
value
)
{
}
bool
HasOwnIRGenerator
:
:
tryAttachNativeHasOwn
(
HandleId
key
ValOperandId
keyId
HandleObject
obj
ObjOperandId
objId
)
{
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx_
obj
key
&
prop
)
)
return
false
;
if
(
!
prop
.
isFound
(
)
)
return
false
;
if
(
!
obj
-
>
isNative
(
)
&
&
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
writer
.
megamorphicHasOwnResult
(
objId
keyId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicHasOwn
"
)
;
return
true
;
}
Maybe
<
ObjOperandId
>
expandoId
;
emitIdGuard
(
keyId
key
)
;
TestMatchingReceiver
(
writer
obj
objId
&
expandoId
)
;
writer
.
loadBooleanResult
(
true
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NativeHasOwn
"
)
;
return
true
;
}
bool
HasOwnIRGenerator
:
:
tryAttachNativeHasOwnDoesNotExist
(
HandleId
key
ValOperandId
keyId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
CheckHasNoSuchOwnProperty
(
cx_
obj
key
)
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
writer
.
megamorphicHasOwnResult
(
objId
keyId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicHasOwn
"
)
;
return
true
;
}
Maybe
<
ObjOperandId
>
expandoId
;
emitIdGuard
(
keyId
key
)
;
TestMatchingReceiver
(
writer
obj
objId
&
expandoId
)
;
writer
.
loadBooleanResult
(
false
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NativeHasOwnDoesNotExist
"
)
;
return
true
;
}
bool
HasOwnIRGenerator
:
:
tryAttachProxyElement
(
ValOperandId
keyId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
false
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
callProxyHasOwnResult
(
objId
keyId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ProxyHasOwn
"
)
;
return
true
;
}
bool
HasOwnIRGenerator
:
:
tryAttachDenseHasOwn
(
uint32_t
index
Int32OperandId
indexId
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
loadDenseElementExistsResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DenseHasOwn
"
)
;
return
true
;
}
bool
HasOwnIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
keyId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
1
)
)
;
if
(
!
val_
.
isObject
(
)
)
{
trackNotAttached
(
)
;
return
false
;
}
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
tryAttachProxyElement
(
keyId
obj
objId
)
)
return
true
;
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
key_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
nameOrSymbol
)
{
if
(
tryAttachNativeHasOwn
(
id
keyId
obj
objId
)
)
return
true
;
if
(
tryAttachNativeHasOwnDoesNotExist
(
id
keyId
obj
objId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
key_
keyId
&
index
&
indexId
)
)
{
if
(
tryAttachDenseHasOwn
(
index
indexId
obj
objId
)
)
return
true
;
trackNotAttached
(
)
;
return
false
;
}
trackNotAttached
(
)
;
return
false
;
}
void
HasOwnIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
val_
)
;
sp
.
valueProperty
(
guard
"
property
"
key_
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
HasOwnIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
val_
)
;
sp
.
valueProperty
(
guard
"
property
"
key_
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
bool
IRGenerator
:
:
maybeGuardInt32Index
(
const
Value
&
index
ValOperandId
indexId
uint32_t
*
int32Index
Int32OperandId
*
int32IndexId
)
{
if
(
index
.
isNumber
(
)
)
{
int32_t
indexSigned
;
if
(
index
.
isInt32
(
)
)
{
indexSigned
=
index
.
toInt32
(
)
;
}
else
{
if
(
!
mozilla
:
:
NumberEqualsInt32
(
index
.
toDouble
(
)
&
indexSigned
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
}
if
(
indexSigned
<
0
)
return
false
;
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardIsInt32Index
(
indexId
)
;
return
true
;
}
if
(
index
.
isString
(
)
)
{
int32_t
indexSigned
=
GetIndexFromString
(
index
.
toString
(
)
)
;
if
(
indexSigned
<
0
)
return
false
;
StringOperandId
strId
=
writer
.
guardIsString
(
indexId
)
;
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardAndGetIndexFromString
(
strId
)
;
return
true
;
}
return
false
;
}
SetPropIRGenerator
:
:
SetPropIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
CacheKind
cacheKind
ICState
:
:
Mode
mode
bool
*
isTemporarilyUnoptimizable
HandleValue
lhsVal
HandleValue
idVal
HandleValue
rhsVal
bool
needsTypeBarrier
bool
maybeHasExtraIndexedProps
)
:
IRGenerator
(
cx
script
pc
cacheKind
mode
)
lhsVal_
(
lhsVal
)
idVal_
(
idVal
)
rhsVal_
(
rhsVal
)
isTemporarilyUnoptimizable_
(
isTemporarilyUnoptimizable
)
typeCheckInfo_
(
cx
needsTypeBarrier
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
attachedTypedArrayOOBStub_
(
false
)
maybeHasExtraIndexedProps_
(
maybeHasExtraIndexedProps
)
{
}
bool
SetPropIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
objValId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsValId
;
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
1
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
setElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
2
)
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
lhsVal_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
lhsVal_
.
toObject
(
)
)
;
if
(
obj
-
>
watched
(
)
)
return
false
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
objValId
)
;
if
(
nameOrSymbol
)
{
if
(
tryAttachNativeSetSlot
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachUnboxedExpandoSetSlot
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachUnboxedProperty
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachTypedObjectProperty
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachSetArrayLength
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
if
(
tryAttachSetter
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachWindowProxy
(
obj
objId
id
rhsValId
)
)
return
true
;
if
(
tryAttachProxy
(
obj
objId
id
rhsValId
)
)
return
true
;
}
return
false
;
}
if
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
if
(
tryAttachProxyElement
(
obj
objId
rhsValId
)
)
return
true
;
}
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
setElemKeyValueId
(
)
&
index
&
indexId
)
)
{
if
(
tryAttachSetDenseElement
(
obj
objId
index
indexId
rhsValId
)
)
return
true
;
if
(
tryAttachSetDenseElementHole
(
obj
objId
index
indexId
rhsValId
)
)
return
true
;
if
(
tryAttachSetUnboxedArrayElement
(
obj
objId
index
indexId
rhsValId
)
)
return
true
;
if
(
tryAttachSetUnboxedArrayElementHole
(
obj
objId
index
indexId
rhsValId
)
)
return
true
;
if
(
tryAttachSetTypedElement
(
obj
objId
index
indexId
rhsValId
)
)
return
true
;
return
false
;
}
return
false
;
}
return
false
;
}
static
void
EmitStoreSlotAndReturn
(
CacheIRWriter
&
writer
ObjOperandId
objId
NativeObject
*
nobj
Shape
*
shape
ValOperandId
rhsId
)
{
if
(
nobj
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
size_t
offset
=
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
;
writer
.
storeFixedSlot
(
objId
offset
rhsId
)
;
}
else
{
size_t
offset
=
nobj
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
storeDynamicSlot
(
objId
offset
rhsId
)
;
}
writer
.
returnFromIC
(
)
;
}
static
Shape
*
LookupShapeForSetSlot
(
NativeObject
*
obj
jsid
id
)
{
Shape
*
shape
=
obj
-
>
lookupPure
(
id
)
;
if
(
shape
&
&
shape
-
>
hasSlot
(
)
&
&
shape
-
>
hasDefaultSetter
(
)
&
&
shape
-
>
writable
(
)
)
return
shape
;
return
nullptr
;
}
static
bool
CanAttachNativeSetSlot
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
isTemporarilyUnoptimizable
MutableHandleShape
propShape
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
propShape
.
set
(
LookupShapeForSetSlot
(
&
obj
-
>
as
<
NativeObject
>
(
)
id
)
)
;
if
(
!
propShape
)
return
false
;
ObjectGroup
*
group
=
JSObject
:
:
getGroup
(
cx
obj
)
;
if
(
!
group
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
false
;
}
EnsureTrackPropertyTypes
(
cx
obj
id
)
;
if
(
!
PropertyHasBeenMarkedNonConstant
(
obj
id
)
)
{
*
isTemporarilyUnoptimizable
=
true
;
return
false
;
}
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachNativeSetSlot
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
RootedShape
propShape
(
cx_
)
;
if
(
!
CanAttachNativeSetSlot
(
cx_
obj
id
isTemporarilyUnoptimizable_
&
propShape
)
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
&
&
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
writer
.
megamorphicStoreSlot
(
objId
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
rhsId
typeCheckInfo_
.
needsTypeBarrier
(
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicNativeSlot
"
)
;
return
true
;
}
maybeEmitIdGuard
(
id
)
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
writer
.
guardGroup
(
objId
nobj
-
>
group
(
)
)
;
writer
.
guardShape
(
objId
nobj
-
>
lastProperty
(
)
)
;
if
(
IsPreliminaryObject
(
obj
)
)
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
else
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
objId
nobj
propShape
rhsId
)
;
trackAttached
(
"
NativeSlot
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachUnboxedExpandoSetSlot
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
!
expando
)
return
false
;
Shape
*
propShape
=
LookupShapeForSetSlot
(
expando
id
)
;
if
(
!
propShape
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
ObjOperandId
expandoId
=
writer
.
guardAndLoadUnboxedExpando
(
objId
)
;
writer
.
guardShape
(
expandoId
expando
-
>
lastProperty
(
)
)
;
typeCheckInfo_
.
set
(
obj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
expandoId
expando
propShape
rhsId
)
;
trackAttached
(
"
UnboxedExpando
"
)
;
return
true
;
}
static
void
EmitGuardUnboxedPropertyType
(
CacheIRWriter
&
writer
JSValueType
propType
ValOperandId
valId
)
{
if
(
propType
=
=
JSVAL_TYPE_OBJECT
)
{
writer
.
guardIsObjectOrNull
(
valId
)
;
}
else
{
writer
.
guardType
(
valId
propType
)
;
}
}
bool
SetPropIRGenerator
:
:
tryAttachUnboxedProperty
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
|
|
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
!
property
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
EmitGuardUnboxedPropertyType
(
writer
property
-
>
type
rhsId
)
;
writer
.
storeUnboxedProperty
(
objId
property
-
>
type
UnboxedPlainObject
:
:
offsetOfData
(
)
+
property
-
>
offset
rhsId
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
obj
-
>
group
(
)
id
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
trackAttached
(
"
Unboxed
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachTypedObjectProperty
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
|
|
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
if
(
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
false
;
if
(
!
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
return
false
;
StructTypeDescr
*
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
return
false
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
return
false
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
obj
-
>
as
<
TypedObject
>
(
)
.
shape
(
)
)
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
obj
-
>
group
(
)
id
)
;
if
(
fieldDescr
-
>
is
<
ScalarTypeDescr
>
(
)
)
{
Scalar
:
:
Type
type
=
fieldDescr
-
>
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
writer
.
storeTypedObjectScalarProperty
(
objId
fieldOffset
layout
type
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObject
"
)
;
return
true
;
}
ReferenceTypeDescr
:
:
Type
type
=
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
switch
(
type
)
{
case
ReferenceTypeDescr
:
:
TYPE_ANY
:
break
;
case
ReferenceTypeDescr
:
:
TYPE_OBJECT
:
writer
.
guardIsObjectOrNull
(
rhsId
)
;
break
;
case
ReferenceTypeDescr
:
:
TYPE_STRING
:
writer
.
guardType
(
rhsId
JSVAL_TYPE_STRING
)
;
break
;
}
writer
.
storeTypedObjectReferenceProperty
(
objId
fieldOffset
layout
type
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObject
"
)
;
return
true
;
}
void
SetPropIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
lhsVal_
)
;
sp
.
valueProperty
(
guard
"
property
"
idVal_
)
;
sp
.
valueProperty
(
guard
"
value
"
rhsVal_
)
;
sp
.
attached
(
guard
name
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
void
SetPropIRGenerator
:
:
trackNotAttached
(
)
{
#
ifdef
JS_CACHEIR_SPEW
CacheIRSpewer
&
sp
=
CacheIRSpewer
:
:
singleton
(
)
;
if
(
sp
.
enabled
(
)
)
{
LockGuard
<
Mutex
>
guard
(
sp
.
lock
(
)
)
;
sp
.
beginCache
(
guard
*
this
)
;
sp
.
valueProperty
(
guard
"
base
"
lhsVal_
)
;
sp
.
valueProperty
(
guard
"
property
"
idVal_
)
;
sp
.
valueProperty
(
guard
"
value
"
rhsVal_
)
;
sp
.
endCache
(
guard
)
;
}
#
endif
}
static
bool
CanAttachSetter
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
HandleId
id
MutableHandleObject
holder
MutableHandleShape
propShape
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc
)
)
)
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
holder
.
address
(
)
&
prop
)
)
return
false
;
if
(
prop
.
isNonNativeProperty
(
)
)
return
false
;
propShape
.
set
(
prop
.
maybeShape
(
)
)
;
if
(
!
IsCacheableSetPropCallScripted
(
obj
holder
propShape
isTemporarilyUnoptimizable
)
&
&
!
IsCacheableSetPropCallNative
(
obj
holder
propShape
)
)
{
return
false
;
}
return
true
;
}
static
void
EmitCallSetterNoGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ValOperandId
rhsId
)
{
if
(
IsCacheableSetPropCallNative
(
obj
holder
shape
)
)
{
JSFunction
*
target
=
&
shape
-
>
setterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
writer
.
callNativeSetter
(
objId
target
rhsId
)
;
writer
.
returnFromIC
(
)
;
return
;
}
MOZ_ASSERT
(
IsCacheableSetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
setterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
writer
.
callScriptedSetter
(
objId
target
rhsId
)
;
writer
.
returnFromIC
(
)
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetter
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
RootedObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
if
(
!
CanAttachSetter
(
cx_
pc_
obj
id
&
holder
&
propShape
isTemporarilyUnoptimizable_
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
|
|
IsWindow
(
obj
)
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
objId
&
expandoId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
}
else
{
writer
.
guardHasGetterSetter
(
objId
propShape
)
;
}
EmitCallSetterNoGuards
(
writer
obj
holder
propShape
objId
rhsId
)
;
trackAttached
(
"
Setter
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetArrayLength
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
|
|
!
obj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
{
return
false
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
callSetArrayLength
(
objId
IsStrictSetPC
(
pc_
)
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
SetArrayLength
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetDenseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
containsDenseElement
(
index
)
|
|
nobj
-
>
getElementsHeader
(
)
-
>
isFrozen
(
)
)
return
false
;
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
writer
.
guardGroup
(
objId
nobj
-
>
group
(
)
)
;
writer
.
guardShape
(
objId
nobj
-
>
shape
(
)
)
;
writer
.
storeDenseElement
(
objId
indexId
rhsId
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
"
SetDenseElement
"
)
;
return
true
;
}
static
bool
CanAttachAddElement
(
JSObject
*
obj
bool
isInit
)
{
do
{
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
const
Class
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
(
clasp
!
=
&
ArrayObject
:
:
class_
&
&
clasp
!
=
&
UnboxedArrayObject
:
:
class_
)
&
&
(
clasp
-
>
getAddProperty
(
)
|
|
clasp
-
>
getResolve
(
)
|
|
clasp
-
>
getOpsLookupProperty
(
)
|
|
clasp
-
>
getSetProperty
(
)
|
|
clasp
-
>
getOpsSetProperty
(
)
)
)
{
return
false
;
}
if
(
isInit
)
break
;
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
break
;
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
obj
=
proto
;
}
while
(
true
)
;
return
true
;
}
static
void
ShapeGuardProtoChain
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
while
(
true
)
{
bool
guardProto
=
obj
-
>
hasUncacheableProto
(
)
&
&
!
obj
-
>
isSingleton
(
)
;
obj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
obj
)
return
;
objId
=
writer
.
loadProto
(
objId
)
;
if
(
guardProto
)
writer
.
guardSpecificObject
(
objId
obj
)
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
)
;
}
}
bool
SetPropIRGenerator
:
:
tryAttachSetDenseElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
isNative
(
)
|
|
rhsVal_
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
return
false
;
JSOp
op
=
JSOp
(
*
pc_
)
;
MOZ_ASSERT
(
IsPropertySetOp
(
op
)
|
|
IsPropertyInitOp
(
op
)
)
;
if
(
op
=
=
JSOP_INITHIDDENELEM
)
return
false
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
nonProxyIsExtensible
(
)
)
return
false
;
MOZ_ASSERT
(
!
nobj
-
>
getElementsHeader
(
)
-
>
isFrozen
(
)
"
Extensible
objects
should
not
have
frozen
elements
"
)
;
uint32_t
initLength
=
nobj
-
>
getDenseInitializedLength
(
)
;
bool
isAdd
=
index
=
=
initLength
;
bool
isHoleInBounds
=
index
<
initLength
&
&
!
nobj
-
>
containsDenseElement
(
index
)
;
if
(
!
isAdd
&
&
!
isHoleInBounds
)
return
false
;
if
(
isAdd
&
&
nobj
-
>
is
<
ArrayObject
>
(
)
&
&
!
nobj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
return
false
;
if
(
nobj
-
>
is
<
TypedArrayObject
>
(
)
)
return
false
;
if
(
!
CanAttachAddElement
(
nobj
IsPropertyInitOp
(
op
)
)
)
return
false
;
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
writer
.
guardGroup
(
objId
nobj
-
>
group
(
)
)
;
writer
.
guardShape
(
objId
nobj
-
>
shape
(
)
)
;
if
(
IsPropertySetOp
(
op
)
&
&
maybeHasExtraIndexedProps_
)
ShapeGuardProtoChain
(
writer
obj
objId
)
;
writer
.
storeDenseElementHole
(
objId
indexId
rhsId
isAdd
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
isAdd
?
"
AddDenseElement
"
:
"
StoreDenseElementHole
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetUnboxedArrayElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
if
(
index
>
=
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
initializedLength
(
)
)
return
false
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
JSValueType
elementType
=
obj
-
>
group
(
)
-
>
unboxedLayoutDontCheckGeneration
(
)
.
elementType
(
)
;
EmitGuardUnboxedPropertyType
(
writer
elementType
rhsId
)
;
writer
.
storeUnboxedArrayElement
(
objId
indexId
rhsId
elementType
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
obj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
"
SetUnboxedArrayElement
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetTypedElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
return
false
;
if
(
!
rhsVal_
.
isNumber
(
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
TypedThingRequiresFloatingPoint
(
obj
)
)
return
false
;
bool
handleOutOfBounds
=
false
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
handleOutOfBounds
=
(
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
;
}
else
{
if
(
index
>
=
obj
-
>
as
<
TypedObject
>
(
)
.
length
(
)
)
return
false
;
if
(
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
false
;
}
Scalar
:
:
Type
elementType
=
TypedThingElementType
(
obj
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
obj
-
>
as
<
ShapedObject
>
(
)
.
shape
(
)
)
;
writer
.
storeTypedElement
(
objId
indexId
rhsId
layout
elementType
handleOutOfBounds
)
;
writer
.
returnFromIC
(
)
;
if
(
handleOutOfBounds
)
attachedTypedArrayOOBStub_
=
true
;
trackAttached
(
handleOutOfBounds
?
"
SetTypedElementOOB
"
:
"
SetTypedElement
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachSetUnboxedArrayElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
|
|
rhsVal_
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
JSOp
op
=
JSOp
(
*
pc_
)
;
MOZ_ASSERT
(
IsPropertySetOp
(
op
)
|
|
IsPropertyInitOp
(
op
)
)
;
if
(
op
=
=
JSOP_INITHIDDENELEM
)
return
false
;
UnboxedArrayObject
*
aobj
=
&
obj
-
>
as
<
UnboxedArrayObject
>
(
)
;
if
(
index
!
=
aobj
-
>
initializedLength
(
)
|
|
index
>
=
aobj
-
>
capacity
(
)
)
return
false
;
if
(
!
CanAttachAddElement
(
aobj
IsPropertyInitOp
(
op
)
)
)
return
false
;
writer
.
guardGroup
(
objId
aobj
-
>
group
(
)
)
;
JSValueType
elementType
=
aobj
-
>
group
(
)
-
>
unboxedLayoutDontCheckGeneration
(
)
.
elementType
(
)
;
EmitGuardUnboxedPropertyType
(
writer
elementType
rhsId
)
;
if
(
IsPropertySetOp
(
op
)
)
ShapeGuardProtoChain
(
writer
aobj
objId
)
;
writer
.
storeUnboxedArrayElementHole
(
objId
indexId
rhsId
elementType
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
aobj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
"
StoreUnboxedArrayElementHole
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
bool
handleDOMProxies
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
if
(
!
handleDOMProxies
)
{
writer
.
guardNotDOMProxy
(
objId
)
;
}
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
|
|
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
{
maybeEmitIdGuard
(
id
)
;
writer
.
callProxySet
(
objId
id
rhsId
IsStrictSetPC
(
pc_
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
writer
.
callProxySetByValue
(
objId
setElemKeyValueId
(
)
rhsId
IsStrictSetPC
(
pc_
)
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GenericProxy
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
writer
.
callProxySet
(
objId
id
rhsId
IsStrictSetPC
(
pc_
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DOMProxyShadowed
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
proto
(
cx_
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
return
false
;
RootedObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
if
(
!
CanAttachSetter
(
cx_
pc_
proto
id
&
holder
&
propShape
isTemporarilyUnoptimizable_
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
EmitCallSetterNoGuards
(
writer
proto
holder
propShape
objId
rhsId
)
;
trackAttached
(
"
DOMProxyUnshadowed
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachDOMProxyExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedValue
expandoVal
(
cx_
GetProxyPrivate
(
obj
)
)
;
RootedObject
expandoObj
(
cx_
)
;
if
(
expandoVal
.
isObject
(
)
)
{
expandoObj
=
&
expandoVal
.
toObject
(
)
;
}
else
{
MOZ_ASSERT
(
!
expandoVal
.
isUndefined
(
)
"
How
did
a
missing
expando
manage
to
shadow
things
?
"
)
;
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
expandoAndGeneration
)
;
expandoObj
=
&
expandoAndGeneration
-
>
expando
.
toObject
(
)
;
}
RootedShape
propShape
(
cx_
)
;
if
(
CanAttachNativeSetSlot
(
cx_
expandoObj
id
isTemporarilyUnoptimizable_
&
propShape
)
)
{
maybeEmitIdGuard
(
id
)
;
ObjOperandId
expandoObjId
=
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
NativeObject
*
nativeExpandoObj
=
&
expandoObj
-
>
as
<
NativeObject
>
(
)
;
writer
.
guardGroup
(
expandoObjId
nativeExpandoObj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
nativeExpandoObj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
expandoObjId
nativeExpandoObj
propShape
rhsId
)
;
trackAttached
(
"
DOMProxyExpandoSlot
"
)
;
return
true
;
}
RootedObject
holder
(
cx_
)
;
if
(
CanAttachSetter
(
cx_
pc_
expandoObj
id
&
holder
&
propShape
isTemporarilyUnoptimizable_
)
)
{
maybeEmitIdGuard
(
id
)
;
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
MOZ_ASSERT
(
holder
=
=
expandoObj
)
;
EmitCallSetterNoGuards
(
writer
expandoObj
expandoObj
propShape
objId
rhsId
)
;
trackAttached
(
"
DOMProxyExpandoSetter
"
)
;
return
true
;
}
return
false
;
}
bool
SetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
ProxyStubType
type
=
GetProxyStubType
(
cx_
obj
id
)
;
if
(
type
=
=
ProxyStubType
:
:
None
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
true
)
;
switch
(
type
)
{
case
ProxyStubType
:
:
None
:
break
;
case
ProxyStubType
:
:
DOMExpando
:
if
(
tryAttachDOMProxyExpando
(
obj
objId
id
rhsId
)
)
return
true
;
if
(
*
isTemporarilyUnoptimizable_
)
{
return
false
;
}
MOZ_FALLTHROUGH
;
case
ProxyStubType
:
:
DOMShadowed
:
return
tryAttachDOMProxyShadowed
(
obj
objId
id
rhsId
)
;
case
ProxyStubType
:
:
DOMUnshadowed
:
if
(
tryAttachDOMProxyUnshadowed
(
obj
objId
id
rhsId
)
)
return
true
;
if
(
*
isTemporarilyUnoptimizable_
)
{
return
false
;
}
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
true
)
;
case
ProxyStubType
:
:
Generic
:
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
false
)
;
}
MOZ_CRASH
(
"
Unexpected
ProxyStubType
"
)
;
}
bool
SetPropIRGenerator
:
:
tryAttachProxyElement
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
false
;
writer
.
guardIsProxy
(
objId
)
;
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
writer
.
callProxySetByValue
(
objId
setElemKeyValueId
(
)
rhsId
IsStrictSetPC
(
pc_
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ProxyElement
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
IsWindowProxy
(
obj
)
)
return
false
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
return
false
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
cx_
-
>
runtime
(
)
-
>
maybeWindowProxyClass
(
)
)
;
MOZ_ASSERT
(
ToWindowIfWindowProxy
(
obj
)
=
=
cx_
-
>
global
(
)
)
;
Handle
<
GlobalObject
*
>
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
propShape
(
cx_
)
;
if
(
!
CanAttachNativeSetSlot
(
cx_
windowObj
id
isTemporarilyUnoptimizable_
&
propShape
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadObject
(
windowObj
)
;
writer
.
guardShape
(
windowObjId
windowObj
-
>
lastProperty
(
)
)
;
writer
.
guardGroup
(
windowObjId
windowObj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
windowObj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
windowObjId
windowObj
propShape
rhsId
)
;
trackAttached
(
"
WindowProxySlot
"
)
;
return
true
;
}
bool
SetPropIRGenerator
:
:
tryAttachAddSlotStub
(
HandleObjectGroup
oldGroup
HandleShape
oldShape
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
objValId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsValId
;
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
1
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
setElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
2
)
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
!
lhsVal_
.
isObject
(
)
|
|
!
nameOrSymbol
)
return
false
;
RootedObject
obj
(
cx_
&
lhsVal_
.
toObject
(
)
)
;
if
(
obj
-
>
watched
(
)
)
return
false
;
PropertyResult
prop
;
JSObject
*
holder
;
if
(
!
LookupPropertyPure
(
cx_
obj
id
&
holder
&
prop
)
)
return
false
;
if
(
obj
!
=
holder
)
return
false
;
Shape
*
propShape
=
nullptr
;
NativeObject
*
holderOrExpando
=
nullptr
;
if
(
obj
-
>
isNative
(
)
)
{
propShape
=
prop
.
shape
(
)
;
holderOrExpando
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
}
else
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
!
expando
)
return
false
;
propShape
=
expando
-
>
lookupPure
(
id
)
;
if
(
!
propShape
)
return
false
;
holderOrExpando
=
expando
;
}
MOZ_ASSERT
(
propShape
)
;
if
(
holderOrExpando
-
>
lastProperty
(
)
!
=
propShape
)
return
false
;
if
(
!
obj
-
>
nonProxyIsExtensible
(
)
|
|
propShape
-
>
previous
(
)
!
=
oldShape
)
return
false
;
if
(
propShape
-
>
inDictionary
(
)
|
|
!
propShape
-
>
hasSlot
(
)
|
|
!
propShape
-
>
hasDefaultSetter
(
)
|
|
!
propShape
-
>
writable
(
)
)
{
return
false
;
}
if
(
ClassMayResolveId
(
cx_
-
>
names
(
)
obj
-
>
getClass
(
)
id
obj
)
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
prototype
)
|
|
!
oldGroup
-
>
maybeInterpretedFunction
(
)
|
|
!
obj
-
>
as
<
JSFunction
>
(
)
.
needsPrototypeProperty
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
propShape
-
>
configurable
(
)
)
;
MOZ_ASSERT
(
!
propShape
-
>
enumerable
(
)
)
;
}
DebugOnly
<
uint32_t
>
index
;
MOZ_ASSERT_IF
(
obj
-
>
is
<
ArrayObject
>
(
)
!
IdIsIndex
(
id
&
index
)
)
;
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
&
&
obj
-
>
getClass
(
)
-
>
getAddProperty
(
)
)
return
false
;
for
(
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
proto
;
proto
=
proto
-
>
staticPrototype
(
)
)
{
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
Shape
*
protoShape
=
proto
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
protoShape
&
&
!
protoShape
-
>
hasDefaultSetter
(
)
)
return
false
;
if
(
ClassMayResolveId
(
cx_
-
>
names
(
)
proto
-
>
getClass
(
)
id
proto
)
&
&
!
proto
-
>
is
<
JSFunction
>
(
)
)
{
return
false
;
}
}
ObjOperandId
objId
=
writer
.
guardIsObject
(
objValId
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
oldGroup
)
;
if
(
oldGroup
-
>
newScript
(
)
&
&
!
oldGroup
-
>
newScript
(
)
-
>
analyzed
(
)
)
{
writer
.
guardGroupHasUnanalyzedNewScript
(
oldGroup
)
;
MOZ_ASSERT
(
IsPreliminaryObject
(
obj
)
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
}
else
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
ObjOperandId
holderId
=
objId
;
if
(
!
obj
-
>
isNative
(
)
)
{
MOZ_ASSERT
(
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
;
holderId
=
writer
.
guardAndLoadUnboxedExpando
(
objId
)
;
}
writer
.
guardShape
(
holderId
oldShape
)
;
ShapeGuardProtoChain
(
writer
obj
objId
)
;
ObjectGroup
*
newGroup
=
obj
-
>
group
(
)
;
bool
changeGroup
=
oldGroup
!
=
newGroup
;
MOZ_ASSERT_IF
(
changeGroup
obj
-
>
is
<
PlainObject
>
(
)
)
;
if
(
holderOrExpando
-
>
isFixedSlot
(
propShape
-
>
slot
(
)
)
)
{
size_t
offset
=
NativeObject
:
:
getFixedSlotOffset
(
propShape
-
>
slot
(
)
)
;
writer
.
addAndStoreFixedSlot
(
holderId
offset
rhsValId
propShape
changeGroup
newGroup
)
;
trackAttached
(
"
AddSlot
"
)
;
}
else
{
size_t
offset
=
holderOrExpando
-
>
dynamicSlotIndex
(
propShape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
uint32_t
numOldSlots
=
NativeObject
:
:
dynamicSlotsCount
(
oldShape
)
;
uint32_t
numNewSlots
=
NativeObject
:
:
dynamicSlotsCount
(
propShape
)
;
if
(
numOldSlots
=
=
numNewSlots
)
{
writer
.
addAndStoreDynamicSlot
(
holderId
offset
rhsValId
propShape
changeGroup
newGroup
)
;
trackAttached
(
"
AddSlot
"
)
;
}
else
{
MOZ_ASSERT
(
numNewSlots
>
numOldSlots
)
;
writer
.
allocateAndStoreDynamicSlot
(
holderId
offset
rhsValId
propShape
changeGroup
newGroup
numNewSlots
)
;
trackAttached
(
"
AllocateSlot
"
)
;
}
}
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
oldGroup
id
)
;
return
true
;
}
TypeOfIRGenerator
:
:
TypeOfIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
value
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
TypeOf
mode
)
val_
(
value
)
{
}
bool
TypeOfIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
TypeOf
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
tryAttachPrimitive
(
valId
)
)
return
true
;
MOZ_ALWAYS_TRUE
(
tryAttachObject
(
valId
)
)
;
return
true
;
}
bool
TypeOfIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
)
{
if
(
!
val_
.
isPrimitive
(
)
)
return
false
;
writer
.
guardType
(
valId
val_
.
isNumber
(
)
?
JSVAL_TYPE_DOUBLE
:
val_
.
extractNonDoubleType
(
)
)
;
writer
.
loadStringResult
(
TypeName
(
js
:
:
TypeOfValue
(
val_
)
cx_
-
>
names
(
)
)
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
TypeOfIRGenerator
:
:
tryAttachObject
(
ValOperandId
valId
)
{
if
(
!
val_
.
isObject
(
)
)
return
false
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
writer
.
loadTypeOfObjectResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
