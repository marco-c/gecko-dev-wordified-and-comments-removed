#
include
"
jit
/
CacheIR
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
IonCaches
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
Maybe
;
IRGenerator
:
:
IRGenerator
(
JSContext
*
cx
jsbytecode
*
pc
CacheKind
cacheKind
)
:
writer
(
cx
)
cx_
(
cx
)
pc_
(
pc
)
cacheKind_
(
cacheKind
)
{
}
GetPropIRGenerator
:
:
GetPropIRGenerator
(
JSContext
*
cx
jsbytecode
*
pc
CacheKind
cacheKind
ICStubEngine
engine
bool
*
isTemporarilyUnoptimizable
HandleValue
val
HandleValue
idVal
CanAttachGetter
canAttachGetter
)
:
IRGenerator
(
cx
pc
cacheKind
)
val_
(
val
)
idVal_
(
idVal
)
engine_
(
engine
)
isTemporarilyUnoptimizable_
(
isTemporarilyUnoptimizable
)
canAttachGetter_
(
canAttachGetter
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
{
}
static
void
EmitLoadSlotResult
(
CacheIRWriter
&
writer
ObjOperandId
holderOp
NativeObject
*
holder
Shape
*
shape
)
{
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadFixedSlotResult
(
holderOp
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
holderOp
dynamicSlotOffset
)
;
}
}
enum
class
ProxyStubType
{
None
DOMShadowed
DOMUnshadowed
Generic
}
;
static
ProxyStubType
GetProxyStubType
(
JSContext
*
cx
HandleObject
obj
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
ProxyStubType
:
:
None
;
if
(
!
IsCacheableDOMProxy
(
obj
)
)
return
ProxyStubType
:
:
Generic
;
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
{
cx
-
>
clearPendingException
(
)
;
return
ProxyStubType
:
:
None
;
}
if
(
DOMProxyIsShadowing
(
shadows
)
)
return
ProxyStubType
:
:
DOMShadowed
;
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
return
ProxyStubType
:
:
DOMUnshadowed
;
}
bool
GetPropIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
{
MOZ_ASSERT
(
getElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
val_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
nameOrSymbol
)
{
if
(
tryAttachObjectLength
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachNative
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachUnboxed
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachUnboxedExpando
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachTypedObject
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachModuleNamespace
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachWindowProxy
(
obj
objId
id
)
)
return
true
;
if
(
tryAttachProxy
(
obj
objId
id
)
)
return
true
;
return
false
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
getElemKeyValueId
(
)
&
index
&
indexId
)
)
{
if
(
tryAttachTypedElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachDenseElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachDenseElementHole
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachUnboxedArrayElement
(
obj
objId
index
indexId
)
)
return
true
;
if
(
tryAttachArgumentsObjectArg
(
obj
objId
index
indexId
)
)
return
true
;
}
return
false
;
}
if
(
nameOrSymbol
)
{
if
(
tryAttachPrimitive
(
valId
id
)
)
return
true
;
if
(
tryAttachStringLength
(
valId
id
)
)
return
true
;
if
(
tryAttachMagicArgumentsName
(
valId
id
)
)
return
true
;
return
false
;
}
if
(
idVal_
.
isInt32
(
)
)
{
ValOperandId
indexId
=
getElemKeyValueId
(
)
;
if
(
tryAttachStringChar
(
valId
indexId
)
)
return
true
;
if
(
tryAttachMagicArgument
(
valId
indexId
)
)
return
true
;
return
false
;
}
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachIdempotentStub
(
)
{
MOZ_ASSERT
(
idempotent
(
)
)
;
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
RootedId
id
(
cx_
NameToId
(
idVal_
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
tryAttachNative
(
obj
objId
id
)
)
return
true
;
if
(
GetProxyStubType
(
cx_
obj
id
)
=
=
ProxyStubType
:
:
DOMUnshadowed
)
return
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
;
return
false
;
}
static
bool
IsCacheableNoProperty
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
jsid
id
jsbytecode
*
pc
)
{
if
(
shape
)
return
false
;
MOZ_ASSERT
(
!
holder
)
;
if
(
!
pc
)
{
return
false
;
}
if
(
*
pc
=
=
JSOP_GETXPROP
)
return
false
;
return
CheckHasNoSuchProperty
(
cx
obj
id
)
;
}
enum
NativeGetPropCacheability
{
CanAttachNone
CanAttachReadSlot
CanAttachCallGetter
}
;
static
NativeGetPropCacheability
CanAttachNativeGetProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
jsbytecode
*
pc
ICStubEngine
engine
CanAttachGetter
canAttachGetter
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
JSObject
*
baseHolder
=
nullptr
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
baseHolder
shape
.
address
(
)
)
)
return
CanAttachNone
;
MOZ_ASSERT
(
!
holder
)
;
if
(
baseHolder
)
{
if
(
!
baseHolder
-
>
isNative
(
)
)
return
CanAttachNone
;
holder
.
set
(
&
baseHolder
-
>
as
<
NativeObject
>
(
)
)
;
}
if
(
IsCacheableGetPropReadSlotForIonOrCacheIR
(
obj
holder
shape
)
)
return
CanAttachReadSlot
;
if
(
!
pc
)
return
CanAttachNone
;
if
(
IsCacheableNoProperty
(
cx
obj
holder
shape
id
pc
)
)
return
CanAttachReadSlot
;
if
(
canAttachGetter
=
=
CanAttachGetter
:
:
No
)
return
CanAttachNone
;
if
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
isTemporarilyUnoptimizable
)
)
{
if
(
engine
!
=
ICStubEngine
:
:
IonSharedIC
)
return
CanAttachCallGetter
;
}
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
return
CanAttachCallGetter
;
return
CanAttachNone
;
}
static
void
GeneratePrototypeGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
)
{
MOZ_ASSERT
(
obj
!
=
holder
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
pobj
)
return
;
while
(
pobj
!
=
holder
)
{
if
(
pobj
-
>
hasUncacheableProto
(
)
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
isSingleton
(
)
)
{
writer
.
guardProto
(
protoId
pobj
-
>
staticPrototype
(
)
)
;
}
else
{
writer
.
guardGroup
(
protoId
pobj
-
>
group
(
)
)
;
}
}
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
}
static
void
TestMatchingReceiver
(
CacheIRWriter
&
writer
JSObject
*
obj
Shape
*
shape
ObjOperandId
objId
Maybe
<
ObjOperandId
>
*
expandoId
)
{
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
{
expandoId
-
>
emplace
(
writer
.
guardAndLoadUnboxedExpando
(
objId
)
)
;
writer
.
guardShape
(
expandoId
-
>
ref
(
)
expando
-
>
lastProperty
(
)
)
;
}
else
{
writer
.
guardNoUnboxedExpando
(
objId
)
;
}
}
else
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
|
|
obj
-
>
is
<
TypedObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
}
else
{
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
MOZ_ASSERT
(
shape
)
;
writer
.
guardShape
(
objId
shape
)
;
}
}
static
void
EmitReadSlotResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
shape
objId
&
expandoId
)
;
ObjOperandId
holderId
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
if
(
holder
)
{
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
else
{
JSObject
*
proto
=
obj
-
>
taggedProto
(
)
.
toObjectOrNull
(
)
;
ObjOperandId
lastObjId
=
objId
;
while
(
proto
)
{
ObjOperandId
protoId
=
writer
.
loadProto
(
lastObjId
)
;
writer
.
guardShape
(
protoId
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
proto
=
proto
-
>
staticPrototype
(
)
;
lastObjId
=
protoId
;
}
}
}
else
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holder
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
holderId
=
*
expandoId
;
}
else
{
holderId
=
objId
;
}
if
(
holder
)
{
MOZ_ASSERT
(
holderId
.
valid
(
)
)
;
EmitLoadSlotResult
(
writer
holderId
&
holder
-
>
as
<
NativeObject
>
(
)
shape
)
;
}
else
{
MOZ_ASSERT
(
!
holderId
.
valid
(
)
)
;
writer
.
loadUndefinedResult
(
)
;
}
}
static
void
EmitReadSlotReturn
(
CacheIRWriter
&
writer
JSObject
*
JSObject
*
holder
Shape
*
shape
)
{
if
(
holder
)
{
MOZ_ASSERT
(
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
}
static
void
EmitCallGetterResultNoGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
writer
.
callNativeGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
return
;
}
MOZ_ASSERT
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
writer
.
callScriptedGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
}
static
void
EmitCallGetterResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
shape
objId
&
expandoId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
EmitCallGetterResultNoGuards
(
writer
obj
holder
shape
objId
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachNative
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
obj
id
&
holder
&
shape
pc_
engine_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
MOZ_ASSERT_IF
(
idempotent
(
)
type
=
=
CanAttachNone
|
|
(
type
=
=
CanAttachReadSlot
&
&
holder
)
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
false
;
case
CanAttachReadSlot
:
maybeEmitIdGuard
(
id
)
;
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
obj
=
=
holder
)
{
if
(
IsPreliminaryObject
(
obj
)
)
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
else
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
EmitReadSlotResult
(
writer
obj
holder
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
holder
shape
)
;
return
true
;
case
CanAttachCallGetter
:
maybeEmitIdGuard
(
id
)
;
EmitCallGetterResult
(
writer
obj
holder
shape
objId
)
;
return
true
;
}
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsWindowProxy
(
obj
)
)
return
false
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
cx_
-
>
maybeWindowProxyClass
(
)
)
;
MOZ_ASSERT
(
ToWindowIfWindowProxy
(
obj
)
=
=
cx_
-
>
global
(
)
)
;
HandleObject
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
windowObj
id
&
holder
&
shape
pc_
engine_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
if
(
type
!
=
CanAttachCallGetter
|
|
!
IsCacheableGetPropCallNative
(
windowObj
holder
shape
)
)
{
return
false
;
}
JSFunction
*
callee
=
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
!
callee
-
>
jitInfo
(
)
|
|
callee
-
>
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadObject
(
windowObj
)
;
EmitCallGetterResult
(
writer
windowObj
holder
shape
windowObjId
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
guardNotDOMProxy
(
objId
)
;
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
)
{
writer
.
callProxyGetResult
(
objId
id
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
writer
.
callProxyGetByValueResult
(
objId
getElemKeyValueId
(
)
)
;
}
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
static
void
CheckDOMProxyExpandoDoesNotShadow
(
CacheIRWriter
&
writer
JSObject
*
obj
jsid
id
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Value
expandoVal
=
GetProxyExtra
(
obj
GetDOMProxyExpandoSlot
(
)
)
;
ValOperandId
expandoId
;
if
(
!
expandoVal
.
isObject
(
)
&
&
!
expandoVal
.
isUndefined
(
)
)
{
ExpandoAndGeneration
*
expandoAndGeneration
=
(
ExpandoAndGeneration
*
)
expandoVal
.
toPrivate
(
)
;
expandoId
=
writer
.
guardDOMExpandoGeneration
(
objId
expandoAndGeneration
expandoAndGeneration
-
>
generation
)
;
expandoVal
=
expandoAndGeneration
-
>
expando
;
}
else
{
expandoId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
}
if
(
expandoVal
.
isUndefined
(
)
)
{
writer
.
guardType
(
expandoId
JSVAL_TYPE_UNDEFINED
)
;
}
else
if
(
expandoVal
.
isObject
(
)
)
{
NativeObject
&
expandoObj
=
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
!
expandoObj
.
containsPure
(
id
)
)
;
writer
.
guardDOMExpandoObject
(
expandoId
expandoObj
.
lastProperty
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Invalid
expando
value
"
)
;
}
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
checkObj
(
cx_
obj
-
>
staticPrototype
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
checkObj
id
&
holder
&
shape
pc_
engine_
canAttachGetter_
isTemporarilyUnoptimizable_
)
;
MOZ_ASSERT_IF
(
idempotent
(
)
canCache
=
=
CanAttachNone
|
|
(
canCache
=
=
CanAttachReadSlot
&
&
holder
)
)
;
if
(
canCache
=
=
CanAttachNone
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
if
(
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachCallGetter
)
;
EmitCallGetterResultNoGuards
(
writer
checkObj
holder
shape
objId
)
;
}
}
else
{
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
}
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
switch
(
GetProxyStubType
(
cx_
obj
id
)
)
{
case
ProxyStubType
:
:
None
:
return
false
;
case
ProxyStubType
:
:
DOMShadowed
:
return
tryAttachDOMProxyShadowed
(
obj
objId
id
)
;
case
ProxyStubType
:
:
DOMUnshadowed
:
return
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
;
case
ProxyStubType
:
:
Generic
:
return
tryAttachGenericProxy
(
obj
objId
id
)
;
}
MOZ_CRASH
(
"
Unexpected
ProxyStubType
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
!
property
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
writer
.
loadUnboxedPropertyResult
(
objId
property
-
>
type
UnboxedPlainObject
:
:
offsetOfData
(
)
+
property
-
>
offset
)
;
if
(
property
-
>
type
=
=
JSVAL_TYPE_OBJECT
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxedExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
!
expando
)
return
false
;
Shape
*
shape
=
expando
-
>
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
EmitReadSlotResult
(
writer
obj
obj
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
obj
shape
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachTypedObject
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
|
|
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
|
|
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
{
return
false
;
}
TypedObject
*
typedObj
=
&
obj
-
>
as
<
TypedObject
>
(
)
;
if
(
!
typedObj
-
>
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
return
false
;
StructTypeDescr
*
structDescr
=
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
return
false
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
return
false
;
Shape
*
shape
=
typedObj
-
>
maybeShape
(
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
shape
-
>
getObjectClass
(
)
)
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
uint32_t
typeDescr
=
SimpleTypeDescrKey
(
&
fieldDescr
-
>
as
<
SimpleTypeDescr
>
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
shape
)
;
writer
.
loadTypedObjectResult
(
objId
fieldOffset
layout
typeDescr
)
;
bool
monitorLoad
=
false
;
if
(
SimpleTypeDescrKeyIsScalar
(
typeDescr
)
)
{
Scalar
:
:
Type
type
=
ScalarTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
=
=
Scalar
:
:
Uint32
;
}
else
{
ReferenceTypeDescr
:
:
Type
type
=
ReferenceTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
!
=
ReferenceTypeDescr
:
:
TYPE_STRING
;
}
if
(
monitorLoad
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachObjectLength
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
return
false
;
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
if
(
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
loadInt32ArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
{
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnboxedArray
)
;
writer
.
loadUnboxedArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
&
&
!
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
{
maybeEmitIdGuard
(
id
)
;
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachModuleNamespace
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ModuleNamespaceObject
>
(
)
)
return
false
;
Rooted
<
ModuleNamespaceObject
*
>
ns
(
cx_
&
obj
-
>
as
<
ModuleNamespaceObject
>
(
)
)
;
RootedModuleEnvironmentObject
env
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
id
env
.
address
(
)
shape
.
address
(
)
)
)
return
false
;
if
(
env
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
env
shape
-
>
propid
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardSpecificObject
(
objId
ns
)
;
ObjOperandId
envId
=
writer
.
loadObject
(
env
)
;
EmitLoadSlotResult
(
writer
envId
env
shape
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
HandleId
id
)
{
JSValueType
primitiveType
;
RootedNativeObject
proto
(
cx_
)
;
if
(
val_
.
isString
(
)
)
{
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
return
false
;
}
primitiveType
=
JSVAL_TYPE_STRING
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_String
)
)
;
}
else
if
(
val_
.
isNumber
(
)
)
{
primitiveType
=
JSVAL_TYPE_DOUBLE
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Number
)
)
;
}
else
if
(
val_
.
isBoolean
(
)
)
{
primitiveType
=
JSVAL_TYPE_BOOLEAN
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Boolean
)
)
;
}
else
if
(
val_
.
isSymbol
(
)
)
{
primitiveType
=
JSVAL_TYPE_SYMBOL
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Symbol
)
)
;
}
else
{
MOZ_ASSERT
(
val_
.
isNullOrUndefined
(
)
|
|
val_
.
isMagic
(
)
)
;
return
false
;
}
if
(
!
proto
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
proto
id
)
;
Shape
*
shape
=
proto
-
>
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
writer
.
guardType
(
valId
primitiveType
)
;
maybeEmitIdGuard
(
id
)
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
writer
.
guardShape
(
protoId
proto
-
>
lastProperty
(
)
)
;
EmitLoadSlotResult
(
writer
protoId
proto
shape
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachStringLength
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isString
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
return
false
;
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
loadStringLengthResult
(
strId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachStringChar
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isString
(
)
)
return
false
;
JSString
*
str
=
val_
.
toString
(
)
;
int32_t
index
=
idVal_
.
toInt32
(
)
;
if
(
size_t
(
index
)
>
=
str
-
>
length
(
)
|
|
!
str
-
>
isLinear
(
)
|
|
str
-
>
asLinear
(
)
.
latin1OrTwoByteChar
(
index
)
>
=
StaticStrings
:
:
UNIT_STATIC_LIMIT
)
{
return
false
;
}
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
Int32OperandId
int32IndexId
=
writer
.
guardIsInt32
(
indexId
)
;
writer
.
loadStringCharResult
(
strId
int32IndexId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachMagicArgumentsName
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
return
false
;
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
&
&
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
return
false
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
writer
.
loadFrameNumActualArgsResult
(
)
;
writer
.
returnFromIC
(
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
;
writer
.
loadFrameCalleeResult
(
)
;
writer
.
typeMonitorResult
(
)
;
}
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachMagicArgument
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
return
false
;
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
Int32OperandId
int32IndexId
=
writer
.
guardIsInt32
(
indexId
)
;
writer
.
loadFrameArgumentResult
(
int32IndexId
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachArgumentsObjectArg
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
ArgumentsObject
>
(
)
|
|
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenElement
(
)
)
return
false
;
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectArgResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDenseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
loadDenseElementResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
static
bool
CanAttachDenseElementHole
(
JSObject
*
obj
)
{
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
=
=
0
)
return
false
;
do
{
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
if
(
ClassCanHaveExtraProperties
(
obj
-
>
getClass
(
)
)
)
return
false
;
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
break
;
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
!
=
0
)
return
false
;
obj
=
proto
;
}
while
(
true
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDenseElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
|
|
!
CanAttachDenseElementHole
(
obj
)
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
while
(
pobj
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
hasUncacheableProto
(
)
&
&
!
pobj
-
>
isSingleton
(
)
)
writer
.
guardGroup
(
protoId
pobj
-
>
group
(
)
)
;
writer
.
guardShape
(
protoId
pobj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
guardNoDenseElements
(
protoId
)
;
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
writer
.
loadDenseElementHoleResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxedArrayElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
if
(
index
>
=
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
initializedLength
(
)
)
return
false
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
JSValueType
elementType
=
obj
-
>
group
(
)
-
>
unboxedLayoutDontCheckGeneration
(
)
.
elementType
(
)
;
writer
.
loadUnboxedArrayElementResult
(
objId
indexId
elementType
)
;
if
(
elementType
=
=
JSVAL_TYPE_OBJECT
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachTypedElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
TypedThingRequiresFloatingPoint
(
obj
)
)
return
false
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
return
false
;
if
(
IsPrimitiveArrayTypedObject
(
obj
)
&
&
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
false
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
layout
!
=
Layout_TypedArray
)
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
obj
-
>
as
<
ShapedObject
>
(
)
.
shape
(
)
)
;
writer
.
loadTypedElementResult
(
objId
indexId
layout
TypedThingElementType
(
obj
)
)
;
if
(
TypedThingElementType
(
obj
)
=
=
Scalar
:
:
Type
:
:
Uint32
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
return
true
;
}
void
GetPropIRGenerator
:
:
maybeEmitIdGuard
(
jsid
id
)
{
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
)
{
MOZ_ASSERT
(
&
idVal_
.
toString
(
)
-
>
asAtom
(
)
=
=
JSID_TO_ATOM
(
id
)
)
;
return
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
ValOperandId
valId
=
getElemKeyValueId
(
)
;
if
(
JSID_IS_SYMBOL
(
id
)
)
{
SymbolOperandId
symId
=
writer
.
guardIsSymbol
(
valId
)
;
writer
.
guardSpecificSymbol
(
symId
JSID_TO_SYMBOL
(
id
)
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
)
)
;
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
writer
.
guardSpecificAtom
(
strId
JSID_TO_ATOM
(
id
)
)
;
}
}
GetNameIRGenerator
:
:
GetNameIRGenerator
(
JSContext
*
cx
jsbytecode
*
pc
HandleScript
script
HandleObject
env
HandlePropertyName
name
)
:
IRGenerator
(
cx
pc
CacheKind
:
:
GetName
)
script_
(
script
)
env_
(
env
)
name_
(
name
)
{
}
bool
GetNameIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetName
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ObjOperandId
envId
(
writer
.
setInputOperandId
(
0
)
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
if
(
tryAttachGlobalNameValue
(
envId
id
)
)
return
true
;
if
(
tryAttachGlobalNameGetter
(
envId
id
)
)
return
true
;
if
(
tryAttachEnvironmentName
(
envId
id
)
)
return
true
;
return
false
;
}
bool
CanAttachGlobalName
(
JSContext
*
cx
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
)
{
RootedNativeObject
current
(
cx
globalLexical
)
;
while
(
true
)
{
shape
.
set
(
current
-
>
lookup
(
cx
id
)
)
;
if
(
shape
)
break
;
if
(
current
=
=
globalLexical
)
{
current
=
&
globalLexical
-
>
global
(
)
;
}
else
{
if
(
!
current
-
>
staticPrototypeIsImmutable
(
)
)
return
false
;
JSObject
*
proto
=
current
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
!
proto
-
>
is
<
NativeObject
>
(
)
)
return
false
;
current
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
holder
.
set
(
current
)
;
return
true
;
}
bool
GetNameIRGenerator
:
:
tryAttachGlobalNameValue
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
return
false
;
if
(
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
false
;
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
holder
=
=
globalLexical
)
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
objId
dynamicSlotOffset
)
;
}
else
{
if
(
!
IsCacheableGetPropReadSlotForIonOrCacheIR
(
&
globalLexical
-
>
global
(
)
holder
shape
)
)
return
false
;
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
ObjOperandId
holderId
=
globalId
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
}
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetNameIRGenerator
:
:
tryAttachGlobalNameGetter
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
return
false
;
if
(
holder
=
=
globalLexical
)
return
false
;
if
(
!
IsCacheableGetPropCallNative
(
&
globalLexical
-
>
global
(
)
holder
shape
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitCallGetterResultNoGuards
(
writer
&
globalLexical
-
>
global
(
)
holder
shape
globalId
)
;
return
true
;
}
bool
GetNameIRGenerator
:
:
tryAttachEnvironmentName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
return
false
;
RootedObject
env
(
cx_
env_
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
while
(
env
)
{
if
(
env
-
>
is
<
GlobalObject
>
(
)
)
{
shape
=
env
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
break
;
return
false
;
}
if
(
!
env
-
>
is
<
EnvironmentObject
>
(
)
|
|
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
return
false
;
MOZ_ASSERT
(
!
env
-
>
hasUncacheableProto
(
)
)
;
shape
=
env
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
break
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
holder
=
&
env
-
>
as
<
NativeObject
>
(
)
;
if
(
!
IsCacheableGetPropReadSlotForIonOrCacheIR
(
holder
holder
shape
)
)
return
false
;
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
return
false
;
ObjOperandId
lastObjId
=
objId
;
env
=
env_
;
while
(
env
)
{
if
(
env
=
=
holder
)
{
writer
.
guardShape
(
lastObjId
holder
-
>
maybeShape
(
)
)
;
break
;
}
writer
.
guardShape
(
lastObjId
env
-
>
maybeShape
(
)
)
;
lastObjId
=
writer
.
loadEnclosingEnvironment
(
lastObjId
)
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadEnvironmentFixedSlotResult
(
lastObjId
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadEnvironmentDynamicSlotResult
(
lastObjId
dynamicSlotOffset
)
;
}
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
IRGenerator
:
:
maybeGuardInt32Index
(
const
Value
&
index
ValOperandId
indexId
uint32_t
*
int32Index
Int32OperandId
*
int32IndexId
)
{
if
(
index
.
isNumber
(
)
)
{
int32_t
indexSigned
;
if
(
index
.
isInt32
(
)
)
{
indexSigned
=
index
.
toInt32
(
)
;
}
else
{
if
(
!
mozilla
:
:
NumberIsInt32
(
index
.
toDouble
(
)
&
indexSigned
)
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
}
if
(
indexSigned
<
0
)
return
false
;
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardIsInt32
(
indexId
)
;
return
true
;
}
if
(
index
.
isString
(
)
)
{
int32_t
indexSigned
=
GetIndexFromString
(
index
.
toString
(
)
)
;
if
(
indexSigned
<
0
)
return
false
;
StringOperandId
strId
=
writer
.
guardIsString
(
indexId
)
;
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardAndGetIndexFromString
(
strId
)
;
return
true
;
}
return
false
;
}
