#
include
"
jit
/
CacheIR
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
IonCaches
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
Maybe
;
GetPropIRGenerator
:
:
GetPropIRGenerator
(
JSContext
*
cx
jsbytecode
*
pc
ICStubEngine
engine
bool
*
isTemporarilyUnoptimizable
HandleValue
val
HandlePropertyName
name
MutableHandleValue
res
)
:
writer
(
cx
)
cx_
(
cx
)
pc_
(
pc
)
val_
(
val
)
name_
(
name
)
res_
(
res
)
engine_
(
engine
)
isTemporarilyUnoptimizable_
(
isTemporarilyUnoptimizable
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
{
}
static
void
EmitLoadSlotResult
(
CacheIRWriter
&
writer
ObjOperandId
holderOp
NativeObject
*
holder
Shape
*
shape
)
{
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadFixedSlotResult
(
holderOp
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
holderOp
dynamicSlotOffset
)
;
}
}
bool
GetPropIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
val_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardIsObject
(
valId
)
;
if
(
tryAttachObjectLength
(
obj
objId
)
)
return
true
;
if
(
tryAttachNative
(
obj
objId
)
)
return
true
;
if
(
tryAttachUnboxed
(
obj
objId
)
)
return
true
;
if
(
tryAttachUnboxedExpando
(
obj
objId
)
)
return
true
;
if
(
tryAttachTypedObject
(
obj
objId
)
)
return
true
;
if
(
tryAttachModuleNamespace
(
obj
objId
)
)
return
true
;
if
(
tryAttachWindowProxy
(
obj
objId
)
)
return
true
;
if
(
tryAttachProxy
(
obj
objId
)
)
return
true
;
return
false
;
}
if
(
tryAttachPrimitive
(
valId
)
)
return
true
;
if
(
tryAttachStringLength
(
valId
)
)
return
true
;
return
false
;
}
static
bool
IsCacheableNoProperty
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
jsid
id
jsbytecode
*
pc
)
{
if
(
shape
)
return
false
;
MOZ_ASSERT
(
!
holder
)
;
if
(
*
pc
=
=
JSOP_GETXPROP
)
return
false
;
return
CheckHasNoSuchProperty
(
cx
obj
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
}
enum
NativeGetPropCacheability
{
CanAttachNone
CanAttachReadSlot
CanAttachCallGetter
}
;
static
NativeGetPropCacheability
CanAttachNativeGetProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
jsbytecode
*
pc
ICStubEngine
engine
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
JSObject
*
baseHolder
=
nullptr
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
baseHolder
shape
.
address
(
)
)
)
return
CanAttachNone
;
MOZ_ASSERT
(
!
holder
)
;
if
(
baseHolder
)
{
if
(
!
baseHolder
-
>
isNative
(
)
)
return
CanAttachNone
;
holder
.
set
(
&
baseHolder
-
>
as
<
NativeObject
>
(
)
)
;
}
if
(
IsCacheableGetPropReadSlotForIonOrCacheIR
(
obj
holder
shape
)
|
|
IsCacheableNoProperty
(
cx
obj
holder
shape
id
pc
)
)
{
return
CanAttachReadSlot
;
}
if
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
isTemporarilyUnoptimizable
)
)
{
if
(
engine
=
=
ICStubEngine
:
:
Baseline
)
return
CanAttachCallGetter
;
}
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
return
CanAttachCallGetter
;
return
CanAttachNone
;
}
static
void
GeneratePrototypeGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
)
{
MOZ_ASSERT
(
obj
!
=
holder
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
pobj
)
return
;
while
(
pobj
!
=
holder
)
{
if
(
pobj
-
>
hasUncacheableProto
(
)
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
isSingleton
(
)
)
{
writer
.
guardProto
(
protoId
pobj
-
>
staticPrototype
(
)
)
;
}
else
{
writer
.
guardGroup
(
protoId
pobj
-
>
group
(
)
)
;
}
}
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
}
static
void
TestMatchingReceiver
(
CacheIRWriter
&
writer
JSObject
*
obj
Shape
*
shape
ObjOperandId
objId
Maybe
<
ObjOperandId
>
*
expandoId
)
{
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
{
expandoId
-
>
emplace
(
writer
.
guardAndLoadUnboxedExpando
(
objId
)
)
;
writer
.
guardShape
(
expandoId
-
>
ref
(
)
expando
-
>
lastProperty
(
)
)
;
}
else
{
writer
.
guardNoUnboxedExpando
(
objId
)
;
}
}
else
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
|
|
obj
-
>
is
<
TypedObject
>
(
)
)
{
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
}
else
{
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
MOZ_ASSERT
(
shape
)
;
writer
.
guardShape
(
objId
shape
)
;
}
}
static
void
EmitReadSlotResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
shape
objId
&
expandoId
)
;
ObjOperandId
holderId
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
if
(
holder
)
{
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
else
{
JSObject
*
proto
=
obj
-
>
taggedProto
(
)
.
toObjectOrNull
(
)
;
ObjOperandId
lastObjId
=
objId
;
while
(
proto
)
{
ObjOperandId
protoId
=
writer
.
loadProto
(
lastObjId
)
;
writer
.
guardShape
(
protoId
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
proto
=
proto
-
>
staticPrototype
(
)
;
lastObjId
=
protoId
;
}
}
}
else
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holder
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
holderId
=
*
expandoId
;
}
else
{
holderId
=
objId
;
}
if
(
holder
)
{
MOZ_ASSERT
(
holderId
.
valid
(
)
)
;
EmitLoadSlotResult
(
writer
holderId
&
holder
-
>
as
<
NativeObject
>
(
)
shape
)
;
}
else
{
MOZ_ASSERT
(
!
holderId
.
valid
(
)
)
;
writer
.
loadUndefinedResult
(
)
;
}
}
static
void
EmitReadSlotReturn
(
CacheIRWriter
&
writer
JSObject
*
JSObject
*
holder
Shape
*
shape
)
{
if
(
holder
)
{
MOZ_ASSERT
(
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
}
static
void
EmitCallGetterResultNoGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
writer
.
callNativeGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
return
;
}
MOZ_ASSERT
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
writer
.
callScriptedGetterResult
(
objId
target
)
;
writer
.
typeMonitorResult
(
)
;
}
static
void
EmitCallGetterResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
expandoId
;
TestMatchingReceiver
(
writer
obj
shape
objId
&
expandoId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
EmitCallGetterResultNoGuards
(
writer
obj
holder
shape
objId
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachNative
(
HandleObject
obj
ObjOperandId
objId
)
{
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
obj
id
&
holder
&
shape
pc_
engine_
isTemporarilyUnoptimizable_
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
false
;
case
CanAttachReadSlot
:
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
NameToId
(
name_
)
)
;
if
(
obj
=
=
holder
)
{
if
(
IsPreliminaryObject
(
obj
)
)
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
else
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
EmitReadSlotResult
(
writer
obj
holder
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
holder
shape
)
;
return
true
;
case
CanAttachCallGetter
:
EmitCallGetterResult
(
writer
obj
holder
shape
objId
)
;
return
true
;
}
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
IsWindowProxy
(
obj
)
)
return
false
;
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
cx_
-
>
maybeWindowProxyClass
(
)
)
;
MOZ_ASSERT
(
ToWindowIfWindowProxy
(
obj
)
=
=
cx_
-
>
global
(
)
)
;
HandleObject
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
windowObj
id
&
holder
&
shape
pc_
engine_
isTemporarilyUnoptimizable_
)
;
if
(
type
!
=
CanAttachCallGetter
|
|
!
IsCacheableGetPropCallNative
(
windowObj
holder
shape
)
)
{
return
false
;
}
JSFunction
*
callee
=
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
!
callee
-
>
jitInfo
(
)
|
|
callee
-
>
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
return
false
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadObject
(
windowObj
)
;
EmitCallGetterResult
(
writer
windowObj
holder
shape
windowObjId
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
guardNotDOMProxy
(
objId
)
;
writer
.
callProxyGetResult
(
objId
NameToId
(
name_
)
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
writer
.
callProxyGetResult
(
objId
NameToId
(
name_
)
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
static
void
CheckDOMProxyExpandoDoesNotShadow
(
CacheIRWriter
&
writer
JSObject
*
obj
jsid
id
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Value
expandoVal
=
GetProxyExtra
(
obj
GetDOMProxyExpandoSlot
(
)
)
;
ValOperandId
expandoId
;
if
(
!
expandoVal
.
isObject
(
)
&
&
!
expandoVal
.
isUndefined
(
)
)
{
ExpandoAndGeneration
*
expandoAndGeneration
=
(
ExpandoAndGeneration
*
)
expandoVal
.
toPrivate
(
)
;
expandoId
=
writer
.
guardDOMExpandoGeneration
(
objId
expandoAndGeneration
expandoAndGeneration
-
>
generation
)
;
expandoVal
=
expandoAndGeneration
-
>
expando
;
}
else
{
expandoId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
}
if
(
expandoVal
.
isUndefined
(
)
)
{
writer
.
guardType
(
expandoId
JSVAL_TYPE_UNDEFINED
)
;
}
else
if
(
expandoVal
.
isObject
(
)
)
{
NativeObject
&
expandoObj
=
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
!
expandoObj
.
containsPure
(
id
)
)
;
writer
.
guardDOMExpandoObject
(
expandoId
expandoObj
.
lastProperty
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Invalid
expando
value
"
)
;
}
}
bool
GetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
checkObj
(
cx_
obj
-
>
staticPrototype
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
checkObj
id
&
holder
&
shape
pc_
engine_
isTemporarilyUnoptimizable_
)
;
if
(
canCache
=
=
CanAttachNone
)
return
false
;
writer
.
guardShape
(
objId
obj
-
>
maybeShape
(
)
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
if
(
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachCallGetter
)
;
EmitCallGetterResultNoGuards
(
writer
checkObj
holder
shape
objId
)
;
}
}
else
{
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
}
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
false
;
if
(
IsCacheableDOMProxy
(
obj
)
)
{
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx_
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
{
cx_
-
>
clearPendingException
(
)
;
return
false
;
}
if
(
DOMProxyIsShadowing
(
shadows
)
)
return
tryAttachDOMProxyShadowed
(
obj
objId
)
;
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
return
tryAttachDOMProxyUnshadowed
(
obj
objId
)
;
}
return
tryAttachGenericProxy
(
obj
objId
)
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxed
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
name_
)
;
if
(
!
property
)
return
false
;
if
(
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
writer
.
guardGroup
(
objId
obj
-
>
group
(
)
)
;
writer
.
loadUnboxedPropertyResult
(
objId
property
-
>
type
UnboxedPlainObject
:
:
offsetOfData
(
)
+
property
-
>
offset
)
;
if
(
property
-
>
type
=
=
JSVAL_TYPE_OBJECT
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachUnboxedExpando
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
!
expando
)
return
false
;
Shape
*
shape
=
expando
-
>
lookup
(
cx_
NameToId
(
name_
)
)
;
if
(
!
shape
|
|
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
false
;
EmitReadSlotResult
(
writer
obj
obj
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
obj
shape
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachTypedObject
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
|
|
!
cx_
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
|
|
cx_
-
>
compartment
(
)
-
>
detachedTypedObjects
)
{
return
false
;
}
TypedObject
*
typedObj
=
&
obj
-
>
as
<
TypedObject
>
(
)
;
if
(
!
typedObj
-
>
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
return
false
;
StructTypeDescr
*
structDescr
=
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
NameToId
(
name_
)
&
fieldIndex
)
)
return
false
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
return
false
;
Shape
*
shape
=
typedObj
-
>
maybeShape
(
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
shape
-
>
getObjectClass
(
)
)
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
uint32_t
typeDescr
=
SimpleTypeDescrKey
(
&
fieldDescr
-
>
as
<
SimpleTypeDescr
>
(
)
)
;
writer
.
guardNoDetachedTypedObjects
(
)
;
writer
.
guardShape
(
objId
shape
)
;
writer
.
loadTypedObjectResult
(
objId
fieldOffset
layout
typeDescr
)
;
bool
monitorLoad
=
false
;
if
(
SimpleTypeDescrKeyIsScalar
(
typeDescr
)
)
{
Scalar
:
:
Type
type
=
ScalarTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
=
=
Scalar
:
:
Uint32
;
}
else
{
ReferenceTypeDescr
:
:
Type
type
=
ReferenceTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
!
=
ReferenceTypeDescr
:
:
TYPE_STRING
;
}
if
(
monitorLoad
)
writer
.
typeMonitorResult
(
)
;
else
writer
.
returnFromIC
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachObjectLength
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
name_
!
=
cx_
-
>
names
(
)
.
length
)
return
false
;
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
if
(
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
return
false
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
loadInt32ArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnboxedArray
)
;
writer
.
loadUnboxedArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
&
&
!
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
{
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
return
false
;
}
bool
GetPropIRGenerator
:
:
tryAttachModuleNamespace
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
ModuleNamespaceObject
>
(
)
)
return
false
;
Rooted
<
ModuleNamespaceObject
*
>
ns
(
cx_
&
obj
-
>
as
<
ModuleNamespaceObject
>
(
)
)
;
RootedModuleEnvironmentObject
env
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
NameToId
(
name_
)
env
.
address
(
)
shape
.
address
(
)
)
)
return
false
;
if
(
env
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
return
false
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
env
shape
-
>
propid
(
)
)
;
writer
.
guardSpecificObject
(
objId
ns
)
;
ObjOperandId
envId
=
writer
.
loadObject
(
env
)
;
EmitLoadSlotResult
(
writer
envId
env
shape
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
)
{
JSValueType
primitiveType
;
RootedNativeObject
proto
(
cx_
)
;
if
(
val_
.
isString
(
)
)
{
if
(
name_
=
=
cx_
-
>
names
(
)
.
length
)
{
return
false
;
}
primitiveType
=
JSVAL_TYPE_STRING
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_String
)
)
;
}
else
if
(
val_
.
isNumber
(
)
)
{
primitiveType
=
JSVAL_TYPE_DOUBLE
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Number
)
)
;
}
else
if
(
val_
.
isBoolean
(
)
)
{
primitiveType
=
JSVAL_TYPE_BOOLEAN
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Boolean
)
)
;
}
else
if
(
val_
.
isSymbol
(
)
)
{
primitiveType
=
JSVAL_TYPE_SYMBOL
;
proto
=
MaybeNativeObject
(
GetBuiltinPrototypePure
(
cx_
-
>
global
(
)
JSProto_Symbol
)
)
;
}
else
{
MOZ_ASSERT
(
val_
.
isNullOrUndefined
(
)
|
|
val_
.
isMagic
(
)
)
;
return
false
;
}
if
(
!
proto
)
return
false
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
if
(
IsIonEnabled
(
cx_
)
)
EnsureTrackPropertyTypes
(
cx_
proto
id
)
;
Shape
*
shape
=
proto
-
>
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
writer
.
guardType
(
valId
primitiveType
)
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
writer
.
guardShape
(
protoId
proto
-
>
lastProperty
(
)
)
;
EmitLoadSlotResult
(
writer
protoId
proto
shape
)
;
writer
.
typeMonitorResult
(
)
;
return
true
;
}
bool
GetPropIRGenerator
:
:
tryAttachStringLength
(
ValOperandId
valId
)
{
if
(
!
val_
.
isString
(
)
|
|
name_
!
=
cx_
-
>
names
(
)
.
length
)
return
false
;
StringOperandId
strId
=
writer
.
guardIsString
(
valId
)
;
writer
.
loadStringLengthResult
(
strId
)
;
writer
.
returnFromIC
(
)
;
return
true
;
}
