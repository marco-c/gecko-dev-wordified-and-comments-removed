#
include
"
jit
/
CacheIR
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jit
/
BaselineCacheIRCompiler
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
CacheIRSpewer
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
#
include
"
vm
/
TypeInference
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
const
char
*
const
js
:
:
jit
:
:
CacheKindNames
[
]
=
{
#
define
DEFINE_KIND
(
kind
)
#
kind
CACHE_IR_KINDS
(
DEFINE_KIND
)
#
undef
DEFINE_KIND
}
;
const
char
*
const
js
:
:
jit
:
:
CacheIrOpNames
[
]
=
{
#
define
OPNAME
(
op
.
.
.
)
#
op
CACHE_IR_OPS
(
OPNAME
)
#
undef
OPNAME
}
;
namespace
js
:
:
jit
:
:
CacheIROpFormat
{
static
constexpr
uint32_t
CacheIRArgLength
(
ArgType
arg
)
{
switch
(
arg
)
{
case
None
:
return
0
;
case
Id
:
return
sizeof
(
uint8_t
)
;
case
Field
:
return
sizeof
(
uint8_t
)
;
case
Byte
:
return
sizeof
(
uint8_t
)
;
case
Int32
:
case
UInt32
:
return
sizeof
(
uint32_t
)
;
case
Word
:
return
sizeof
(
uintptr_t
)
;
}
}
template
<
typename
.
.
.
Args
>
static
constexpr
uint32_t
CacheIRArgsLength
(
Args
.
.
.
args
)
{
return
(
CacheIRArgLength
(
args
)
+
.
.
.
)
;
}
const
uint32_t
ArgLengths
[
]
=
{
#
define
ARGLENGTH
(
op
.
.
.
)
CacheIRArgsLength
(
__VA_ARGS__
)
CACHE_IR_OPS
(
ARGLENGTH
)
#
undef
ARGLENGTH
}
;
}
void
CacheIRWriter
:
:
assertSameCompartment
(
JSObject
*
obj
)
{
cx_
-
>
debugOnlyCheck
(
obj
)
;
}
StubField
CacheIRWriter
:
:
readStubFieldForIon
(
uint32_t
offset
StubField
:
:
Type
type
)
const
{
size_t
index
=
0
;
size_t
currentOffset
=
0
;
if
(
lastOffset_
<
offset
)
{
currentOffset
=
lastOffset_
;
index
=
lastIndex_
;
}
while
(
currentOffset
!
=
offset
)
{
currentOffset
+
=
StubField
:
:
sizeInBytes
(
stubFields_
[
index
]
.
type
(
)
)
;
index
+
+
;
MOZ_ASSERT
(
index
<
stubFields_
.
length
(
)
)
;
}
MOZ_ASSERT
(
stubFields_
[
index
]
.
type
(
)
=
=
type
)
;
lastOffset_
=
currentOffset
;
lastIndex_
=
index
;
return
stubFields_
[
index
]
;
}
IRGenerator
:
:
IRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
CacheKind
cacheKind
ICState
:
:
Mode
mode
)
:
writer
(
cx
)
cx_
(
cx
)
script_
(
script
)
pc_
(
pc
)
cacheKind_
(
cacheKind
)
mode_
(
mode
)
{
}
GetPropIRGenerator
:
:
GetPropIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
CacheKind
cacheKind
HandleValue
val
HandleValue
idVal
HandleValue
receiver
GetPropertyResultFlags
resultFlags
)
:
IRGenerator
(
cx
script
pc
cacheKind
mode
)
val_
(
val
)
idVal_
(
idVal
)
receiver_
(
receiver
)
resultFlags_
(
resultFlags
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
{
}
static
void
EmitLoadSlotResult
(
CacheIRWriter
&
writer
ObjOperandId
holderOp
NativeObject
*
holder
Shape
*
shape
)
{
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadFixedSlotResult
(
holderOp
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
holderOp
dynamicSlotOffset
)
;
}
}
enum
class
ProxyStubType
{
None
DOMExpando
DOMShadowed
DOMUnshadowed
Generic
}
;
static
ProxyStubType
GetProxyStubType
(
JSContext
*
cx
HandleObject
obj
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
ProxyStubType
:
:
None
;
}
if
(
!
IsCacheableDOMProxy
(
obj
)
)
{
return
ProxyStubType
:
:
Generic
;
}
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
{
cx
-
>
clearPendingException
(
)
;
return
ProxyStubType
:
:
None
;
}
if
(
DOMProxyIsShadowing
(
shadows
)
)
{
if
(
shadows
=
=
ShadowsViaDirectExpando
|
|
shadows
=
=
ShadowsViaIndirectExpando
)
{
return
ProxyStubType
:
:
DOMExpando
;
}
return
ProxyStubType
:
:
DOMShadowed
;
}
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
return
ProxyStubType
:
:
DOMUnshadowed
;
}
static
bool
ValueToNameOrSymbolId
(
JSContext
*
cx
HandleValue
idval
MutableHandleId
id
bool
*
nameOrSymbol
)
{
*
nameOrSymbol
=
false
;
if
(
!
idval
.
isString
(
)
&
&
!
idval
.
isSymbol
(
)
)
{
return
true
;
}
if
(
!
ValueToId
<
CanGC
>
(
cx
idval
id
)
)
{
return
false
;
}
if
(
!
JSID_IS_STRING
(
id
)
&
&
!
JSID_IS_SYMBOL
(
id
)
)
{
id
.
set
(
JSID_VOID
)
;
return
true
;
}
uint32_t
dummy
;
if
(
JSID_IS_STRING
(
id
)
&
&
JSID_TO_ATOM
(
id
)
-
>
isIndex
(
&
dummy
)
)
{
id
.
set
(
JSID_VOID
)
;
return
true
;
}
*
nameOrSymbol
=
true
;
return
true
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
if
(
isSuper
(
)
&
&
!
receiver_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
cacheKind_
!
=
CacheKind
:
:
GetProp
)
{
MOZ_ASSERT_IF
(
cacheKind_
=
=
CacheKind
:
:
GetPropSuper
getSuperReceiverValueId
(
)
.
id
(
)
=
=
1
)
;
MOZ_ASSERT_IF
(
cacheKind_
!
=
CacheKind
:
:
GetPropSuper
getElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
}
if
(
cacheKind_
=
=
CacheKind
:
:
GetElemSuper
)
{
MOZ_ASSERT
(
getSuperReceiverValueId
(
)
.
id
(
)
=
=
2
)
;
writer
.
setInputOperandId
(
2
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
val_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
if
(
nameOrSymbol
)
{
TRY_ATTACH
(
tryAttachObjectLength
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachNative
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachTypedObject
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachModuleNamespace
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachWindowProxy
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachCrossCompartmentWrapper
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachXrayCrossCompartmentWrapper
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachFunction
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachProxy
(
obj
objId
id
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
|
|
cacheKind_
=
=
CacheKind
:
:
GetElemSuper
)
;
TRY_ATTACH
(
tryAttachProxyElement
(
obj
objId
)
)
;
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
getElemKeyValueId
(
)
&
index
&
indexId
)
)
{
TRY_ATTACH
(
tryAttachTypedElement
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachDenseElement
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachDenseElementHole
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachSparseElement
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachArgumentsObjectArg
(
obj
objId
indexId
)
)
;
TRY_ATTACH
(
tryAttachGenericElement
(
obj
objId
index
indexId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
TRY_ATTACH
(
tryAttachTypedArrayNonInt32Index
(
obj
objId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
nameOrSymbol
)
{
TRY_ATTACH
(
tryAttachPrimitive
(
valId
id
)
)
;
TRY_ATTACH
(
tryAttachStringLength
(
valId
id
)
)
;
TRY_ATTACH
(
tryAttachMagicArgumentsName
(
valId
id
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
idVal_
.
isInt32
(
)
)
{
ValOperandId
indexId
=
getElemKeyValueId
(
)
;
TRY_ATTACH
(
tryAttachStringChar
(
valId
indexId
)
)
;
TRY_ATTACH
(
tryAttachMagicArgument
(
valId
indexId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachIdempotentStub
(
)
{
MOZ_ASSERT
(
idempotent
(
)
)
;
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
RootedId
id
(
cx_
NameToId
(
idVal_
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
TRY_ATTACH
(
tryAttachNative
(
obj
objId
id
)
)
;
TRY_ATTACH
(
tryAttachObjectLength
(
obj
objId
id
)
)
;
if
(
GetProxyStubType
(
cx_
obj
id
)
=
=
ProxyStubType
:
:
DOMUnshadowed
)
{
return
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
;
}
return
AttachDecision
:
:
NoAction
;
}
static
bool
IsCacheableProtoChain
(
JSObject
*
obj
JSObject
*
holder
)
{
while
(
obj
!
=
holder
)
{
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
!
proto
-
>
isNative
(
)
)
{
return
false
;
}
obj
=
proto
;
}
return
true
;
}
static
bool
IsCacheableGetPropReadSlot
(
JSObject
*
obj
JSObject
*
holder
PropertyResult
prop
)
{
if
(
!
prop
|
|
!
IsCacheableProtoChain
(
obj
holder
)
)
{
return
false
;
}
Shape
*
shape
=
prop
.
shape
(
)
;
if
(
!
shape
-
>
isDataProperty
(
)
)
{
return
false
;
}
return
true
;
}
enum
NativeGetPropCacheability
{
CanAttachNone
CanAttachReadSlot
CanAttachNativeGetter
CanAttachScriptedGetter
CanAttachTemporarilyUnoptimizable
}
;
static
NativeGetPropCacheability
IsCacheableGetPropCall
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChain
(
obj
holder
)
)
{
return
CanAttachNone
;
}
if
(
!
shape
-
>
hasGetterValue
(
)
|
|
!
shape
-
>
getterValue
(
)
.
isObject
(
)
)
{
return
CanAttachNone
;
}
if
(
!
shape
-
>
getterValue
(
)
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
CanAttachNone
;
}
JSFunction
&
getter
=
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
getter
.
isClassConstructor
(
)
)
{
return
CanAttachNone
;
}
if
(
IsWindow
(
obj
)
)
{
if
(
!
getter
.
hasJitInfo
(
)
|
|
getter
.
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
{
return
CanAttachNone
;
}
}
if
(
getter
.
isBuiltinNative
(
)
)
{
return
CanAttachNativeGetter
;
}
if
(
getter
.
hasBytecode
(
)
|
|
getter
.
isNativeWithJitEntry
(
)
)
{
return
CanAttachScriptedGetter
;
}
if
(
getter
.
isInterpreted
(
)
)
{
return
CanAttachTemporarilyUnoptimizable
;
}
return
CanAttachNone
;
}
static
bool
CheckHasNoSuchOwnProperty
(
JSContext
*
cx
JSObject
*
obj
jsid
id
)
{
if
(
obj
-
>
isNative
(
)
)
{
if
(
ClassMayResolveId
(
cx
-
>
names
(
)
obj
-
>
getClass
(
)
id
obj
)
)
{
return
false
;
}
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
contains
(
cx
id
)
)
{
return
false
;
}
}
else
if
(
obj
-
>
is
<
TypedObject
>
(
)
)
{
if
(
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
hasProperty
(
cx
-
>
names
(
)
id
)
)
{
return
false
;
}
}
else
{
return
false
;
}
return
true
;
}
static
bool
CheckHasNoSuchProperty
(
JSContext
*
cx
JSObject
*
obj
jsid
id
)
{
JSObject
*
curObj
=
obj
;
do
{
if
(
!
CheckHasNoSuchOwnProperty
(
cx
curObj
id
)
)
{
return
false
;
}
if
(
!
curObj
-
>
isNative
(
)
)
{
if
(
curObj
!
=
obj
)
{
return
false
;
}
}
curObj
=
curObj
-
>
staticPrototype
(
)
;
}
while
(
curObj
)
;
return
true
;
}
static
bool
IsPreliminaryObject
(
JSObject
*
obj
)
{
if
(
obj
-
>
isSingleton
(
)
)
{
return
false
;
}
AutoSweepObjectGroup
sweep
(
obj
-
>
group
(
)
)
;
TypeNewScript
*
newScript
=
obj
-
>
group
(
)
-
>
newScript
(
sweep
)
;
if
(
newScript
&
&
!
newScript
-
>
analyzed
(
)
)
{
return
true
;
}
if
(
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
sweep
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsCacheableNoProperty
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
jsid
id
jsbytecode
*
pc
GetPropertyResultFlags
resultFlags
)
{
if
(
shape
)
{
return
false
;
}
MOZ_ASSERT
(
!
holder
)
;
if
(
!
pc
&
&
!
(
resultFlags
&
GetPropertyResultFlags
:
:
AllowUndefined
)
)
{
return
false
;
}
if
(
pc
&
&
JSOp
(
*
pc
)
=
=
JSOp
:
:
GetBoundName
)
{
return
false
;
}
return
CheckHasNoSuchProperty
(
cx
obj
id
)
;
}
static
NativeGetPropCacheability
CanAttachNativeGetProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
jsbytecode
*
pc
GetPropertyResultFlags
resultFlags
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
JSObject
*
baseHolder
=
nullptr
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
baseHolder
&
prop
)
)
{
return
CanAttachNone
;
}
MOZ_ASSERT
(
!
holder
)
;
if
(
baseHolder
)
{
if
(
!
baseHolder
-
>
isNative
(
)
)
{
return
CanAttachNone
;
}
holder
.
set
(
&
baseHolder
-
>
as
<
NativeObject
>
(
)
)
;
}
shape
.
set
(
prop
.
maybeShape
(
)
)
;
if
(
IsCacheableGetPropReadSlot
(
obj
holder
prop
)
)
{
return
CanAttachReadSlot
;
}
if
(
IsCacheableNoProperty
(
cx
obj
holder
shape
id
pc
resultFlags
)
)
{
return
CanAttachReadSlot
;
}
if
(
pc
&
&
(
resultFlags
&
GetPropertyResultFlags
:
:
Monitored
)
)
{
return
IsCacheableGetPropCall
(
obj
holder
shape
)
;
}
return
CanAttachNone
;
}
static
void
GuardGroupProto
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
ObjectGroup
*
group
=
obj
-
>
groupRaw
(
)
;
if
(
group
-
>
hasUncacheableProto
(
)
)
{
writer
.
guardProto
(
objId
obj
-
>
staticPrototype
(
)
)
;
}
else
{
writer
.
guardGroupForProto
(
objId
group
)
;
}
}
static
void
TestMatchingReceiver
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
if
(
obj
-
>
is
<
TypedObject
>
(
)
)
{
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
}
else
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
{
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
ProxyObject
>
(
)
.
shape
(
)
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
writer
.
guardShapeForOwnProperties
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
}
static
void
TestMatchingNativeReceiver
(
CacheIRWriter
&
writer
NativeObject
*
obj
ObjOperandId
objId
)
{
writer
.
guardShapeForOwnProperties
(
objId
obj
-
>
lastProperty
(
)
)
;
}
static
void
TestMatchingProxyReceiver
(
CacheIRWriter
&
writer
ProxyObject
*
obj
ObjOperandId
objId
)
{
writer
.
guardShapeForClass
(
objId
obj
-
>
shape
(
)
)
;
}
static
void
GeneratePrototypeGuardsForReceiver
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
GuardGroupProto
(
writer
obj
objId
)
;
}
#
ifdef
DEBUG
if
(
obj
-
>
is
<
TypedObject
>
(
)
)
{
MOZ_ASSERT
(
!
obj
-
>
group
(
)
-
>
hasUncacheableProto
(
)
)
;
}
else
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
{
MOZ_ASSERT
(
!
obj
-
>
hasUncacheableProto
(
)
)
;
}
#
endif
}
static
bool
ProtoChainSupportsTeleporting
(
JSObject
*
obj
JSObject
*
holder
)
{
MOZ_ASSERT
(
obj
-
>
isDelegate
(
)
)
;
for
(
JSObject
*
tmp
=
obj
;
tmp
!
=
holder
;
tmp
=
tmp
-
>
staticPrototype
(
)
)
{
if
(
tmp
-
>
hasUncacheableProto
(
)
)
{
return
false
;
}
}
return
!
holder
-
>
hasUncacheableProto
(
)
;
}
static
void
GeneratePrototypeGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
)
{
MOZ_ASSERT
(
holder
)
;
MOZ_ASSERT
(
obj
!
=
holder
)
;
JSObject
*
pobj
=
obj
;
if
(
!
obj
-
>
isDelegate
(
)
)
{
GeneratePrototypeGuardsForReceiver
(
writer
obj
objId
)
;
pobj
=
obj
-
>
staticPrototype
(
)
;
}
MOZ_ASSERT
(
pobj
-
>
isDelegate
(
)
)
;
if
(
ProtoChainSupportsTeleporting
(
pobj
holder
)
)
{
return
;
}
if
(
pobj
=
=
holder
)
{
return
;
}
MOZ_ASSERT
(
pobj
=
=
obj
|
|
pobj
=
=
obj
-
>
staticPrototype
(
)
)
;
ObjOperandId
protoId
=
(
pobj
=
=
obj
)
?
objId
:
writer
.
loadProto
(
objId
)
;
while
(
pobj
!
=
holder
)
{
pobj
=
pobj
-
>
staticPrototype
(
)
;
protoId
=
writer
.
loadProto
(
protoId
)
;
writer
.
guardSpecificObject
(
protoId
pobj
)
;
}
}
static
void
GeneratePrototypeHoleGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
bool
alwaysGuardFirstProto
)
{
if
(
alwaysGuardFirstProto
|
|
obj
-
>
hasUncacheableProto
(
)
)
{
GuardGroupProto
(
writer
obj
objId
)
;
}
JSObject
*
pobj
=
obj
-
>
staticPrototype
(
)
;
while
(
pobj
)
{
ObjOperandId
protoId
=
writer
.
loadObject
(
pobj
)
;
if
(
pobj
-
>
hasUncacheableProto
(
)
)
{
GuardGroupProto
(
writer
pobj
protoId
)
;
}
writer
.
guardShape
(
protoId
pobj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
writer
.
guardNoDenseElements
(
protoId
)
;
pobj
=
pobj
-
>
staticPrototype
(
)
;
}
}
static
void
TestMatchingHolder
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
writer
.
guardShapeForOwnProperties
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
}
static
bool
UncacheableProtoOnChain
(
JSObject
*
obj
)
{
while
(
true
)
{
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
return
true
;
}
obj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
obj
)
{
return
false
;
}
}
}
static
void
ShapeGuardProtoChain
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
)
{
while
(
true
)
{
bool
guardProto
=
obj
-
>
hasUncacheableProto
(
)
;
obj
=
obj
-
>
staticPrototype
(
)
;
if
(
!
obj
&
&
!
guardProto
)
{
return
;
}
objId
=
writer
.
loadProto
(
objId
)
;
if
(
guardProto
)
{
writer
.
guardSpecificObject
(
objId
obj
)
;
}
if
(
!
obj
)
{
return
;
}
writer
.
guardShape
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
)
;
}
}
static
void
ShapeGuardProtoChainForCrossCompartmentHolder
(
CacheIRWriter
&
writer
JSObject
*
obj
ObjOperandId
objId
JSObject
*
holder
Maybe
<
ObjOperandId
>
*
holderId
)
{
MOZ_ASSERT
(
obj
!
=
holder
)
;
MOZ_ASSERT
(
holder
)
;
while
(
true
)
{
obj
=
obj
-
>
staticPrototype
(
)
;
MOZ_ASSERT
(
obj
)
;
objId
=
writer
.
loadProto
(
objId
)
;
if
(
obj
=
=
holder
)
{
TestMatchingHolder
(
writer
obj
objId
)
;
holderId
-
>
emplace
(
objId
)
;
return
;
}
else
{
writer
.
guardShapeForOwnProperties
(
objId
obj
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
)
;
}
}
}
enum
class
SlotReadType
{
Normal
CrossCompartment
}
;
template
<
SlotReadType
MaybeCrossCompartment
=
SlotReadType
:
:
Normal
>
static
void
EmitReadSlotGuard
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
ObjOperandId
objId
Maybe
<
ObjOperandId
>
*
holderId
)
{
TestMatchingReceiver
(
writer
obj
objId
)
;
if
(
obj
!
=
holder
)
{
if
(
holder
)
{
if
(
MaybeCrossCompartment
=
=
SlotReadType
:
:
CrossCompartment
)
{
ShapeGuardProtoChainForCrossCompartmentHolder
(
writer
obj
objId
holder
holderId
)
;
}
else
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
holderId
-
>
emplace
(
writer
.
loadObject
(
holder
)
)
;
TestMatchingHolder
(
writer
holder
holderId
-
>
ref
(
)
)
;
}
}
else
{
ShapeGuardProtoChain
(
writer
obj
objId
)
;
}
}
else
{
holderId
-
>
emplace
(
objId
)
;
}
}
template
<
SlotReadType
MaybeCrossCompartment
=
SlotReadType
:
:
Normal
>
static
void
EmitReadSlotResult
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
)
{
Maybe
<
ObjOperandId
>
holderId
;
EmitReadSlotGuard
<
MaybeCrossCompartment
>
(
writer
obj
holder
objId
&
holderId
)
;
if
(
holder
)
{
MOZ_ASSERT
(
holderId
-
>
valid
(
)
)
;
EmitLoadSlotResult
(
writer
*
holderId
&
holder
-
>
as
<
NativeObject
>
(
)
shape
)
;
}
else
{
MOZ_ASSERT
(
holderId
.
isNothing
(
)
)
;
writer
.
loadUndefinedResult
(
)
;
}
}
static
void
EmitReadSlotReturn
(
CacheIRWriter
&
writer
JSObject
*
JSObject
*
holder
Shape
*
shape
bool
wrapResult
=
false
)
{
if
(
holder
)
{
MOZ_ASSERT
(
shape
)
;
if
(
wrapResult
)
{
writer
.
wrapResult
(
)
;
}
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
}
static
void
EmitCallGetterResultNoGuards
(
JSContext
*
cx
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
receiverId
)
{
switch
(
IsCacheableGetPropCall
(
obj
holder
shape
)
)
{
case
CanAttachNativeGetter
:
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isBuiltinNative
(
)
)
;
writer
.
callNativeGetterResult
(
receiverId
target
)
;
writer
.
typeMonitorResult
(
)
;
break
;
}
case
CanAttachScriptedGetter
:
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJitEntry
(
)
)
;
bool
sameRealm
=
cx
-
>
realm
(
)
=
=
target
-
>
realm
(
)
;
writer
.
callScriptedGetterResult
(
receiverId
target
sameRealm
)
;
writer
.
typeMonitorResult
(
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
attach
getter
"
)
;
break
;
}
}
static
void
EmitCallGetterResultGuards
(
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ICState
:
:
Mode
mode
)
{
if
(
mode
=
=
ICState
:
:
Mode
:
:
Specialized
|
|
IsWindow
(
obj
)
)
{
TestMatchingReceiver
(
writer
obj
objId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
TestMatchingHolder
(
writer
holder
holderId
)
;
}
}
else
{
writer
.
guardHasGetterSetter
(
objId
shape
)
;
}
}
static
void
EmitCallGetterResult
(
JSContext
*
cx
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ObjOperandId
receiverId
ICState
:
:
Mode
mode
)
{
EmitCallGetterResultGuards
(
writer
obj
holder
shape
objId
mode
)
;
EmitCallGetterResultNoGuards
(
cx
writer
obj
holder
shape
receiverId
)
;
}
static
void
EmitCallGetterResult
(
JSContext
*
cx
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ICState
:
:
Mode
mode
)
{
EmitCallGetterResult
(
cx
writer
obj
holder
shape
objId
objId
mode
)
;
}
static
void
EmitCallGetterByValueResult
(
JSContext
*
cx
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ValOperandId
receiverId
ICState
:
:
Mode
mode
)
{
EmitCallGetterResultGuards
(
writer
obj
holder
shape
objId
mode
)
;
switch
(
IsCacheableGetPropCall
(
obj
holder
shape
)
)
{
case
CanAttachNativeGetter
:
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isBuiltinNative
(
)
)
;
writer
.
callNativeGetterByValueResult
(
receiverId
target
)
;
writer
.
typeMonitorResult
(
)
;
break
;
}
case
CanAttachScriptedGetter
:
{
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJitEntry
(
)
)
;
bool
sameRealm
=
cx
-
>
realm
(
)
=
=
target
-
>
realm
(
)
;
writer
.
callScriptedGetterByValueResult
(
receiverId
target
sameRealm
)
;
writer
.
typeMonitorResult
(
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
attach
getter
"
)
;
break
;
}
}
void
GetPropIRGenerator
:
:
attachMegamorphicNativeSlot
(
ObjOperandId
objId
jsid
id
bool
handleMissing
)
{
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
|
|
cacheKind_
=
=
CacheKind
:
:
GetPropSuper
)
{
writer
.
megamorphicLoadSlotResult
(
objId
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
handleMissing
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
|
|
cacheKind_
=
=
CacheKind
:
:
GetElemSuper
)
;
writer
.
megamorphicLoadSlotByValueResult
(
objId
getElemKeyValueId
(
)
handleMissing
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
handleMissing
?
"
MegamorphicMissingNativeSlot
"
:
"
MegamorphicNativeSlot
"
)
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachNative
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
obj
id
&
holder
&
shape
pc_
resultFlags_
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
AttachDecision
:
:
NoAction
;
case
CanAttachTemporarilyUnoptimizable
:
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
case
CanAttachReadSlot
:
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
attachMegamorphicNativeSlot
(
objId
id
holder
=
=
nullptr
)
;
return
AttachDecision
:
:
Attach
;
}
maybeEmitIdGuard
(
id
)
;
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
IsPreliminaryObject
(
obj
)
)
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
}
else
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
EmitReadSlotResult
(
writer
obj
holder
shape
objId
)
;
EmitReadSlotReturn
(
writer
obj
holder
shape
)
;
trackAttached
(
"
NativeSlot
"
)
;
return
AttachDecision
:
:
Attach
;
case
CanAttachScriptedGetter
:
case
CanAttachNativeGetter
:
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
ObjOperandId
receiverId
=
isSuper
(
)
?
writer
.
guardToObject
(
getSuperReceiverValueId
(
)
)
:
objId
;
maybeEmitIdGuard
(
id
)
;
EmitCallGetterResult
(
cx_
writer
obj
holder
shape
objId
receiverId
mode_
)
;
trackAttached
(
"
NativeGetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
}
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
bool
js
:
:
jit
:
:
IsWindowProxyForScriptGlobal
(
JSScript
*
script
JSObject
*
obj
)
{
if
(
!
IsWindowProxy
(
obj
)
)
{
return
false
;
}
MOZ_ASSERT
(
obj
-
>
getClass
(
)
=
=
script
-
>
runtimeFromMainThread
(
)
-
>
maybeWindowProxyClass
(
)
)
;
JSObject
*
window
=
ToWindowIfWindowProxy
(
obj
)
;
MOZ_ASSERT
(
window
=
=
&
obj
-
>
nonCCWGlobal
(
)
)
;
MOZ_ASSERT
(
script
-
>
compartment
(
)
=
=
obj
-
>
compartment
(
)
)
;
return
window
=
=
&
script
-
>
global
(
)
;
}
static
ObjOperandId
GuardAndLoadWindowProxyWindow
(
CacheIRWriter
&
writer
ObjOperandId
objId
GlobalObject
*
windowObj
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
WindowProxy
)
;
ObjOperandId
windowObjId
=
writer
.
loadWrapperTarget
(
objId
)
;
writer
.
guardSpecificObject
(
windowObjId
windowObj
)
;
return
windowObjId
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsWindowProxyForScriptGlobal
(
script_
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
AttachDecision
:
:
NoAction
;
}
Handle
<
GlobalObject
*
>
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
windowObj
id
&
holder
&
shape
pc_
resultFlags_
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
AttachDecision
:
:
NoAction
;
case
CanAttachReadSlot
:
{
maybeEmitIdGuard
(
id
)
;
ObjOperandId
windowObjId
=
GuardAndLoadWindowProxyWindow
(
writer
objId
windowObj
)
;
EmitReadSlotResult
(
writer
windowObj
holder
shape
windowObjId
)
;
EmitReadSlotReturn
(
writer
windowObj
holder
shape
)
;
trackAttached
(
"
WindowProxySlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
case
CanAttachNativeGetter
:
{
JSFunction
*
callee
=
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
!
callee
-
>
hasJitInfo
(
)
|
|
callee
-
>
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
isSuper
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
ObjOperandId
windowObjId
=
GuardAndLoadWindowProxyWindow
(
writer
objId
windowObj
)
;
EmitCallGetterResult
(
cx_
writer
windowObj
holder
shape
windowObjId
mode_
)
;
trackAttached
(
"
WindowProxyGetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
case
CanAttachScriptedGetter
:
case
CanAttachTemporarilyUnoptimizable
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
possible
for
window
proxies
"
)
;
}
MOZ_CRASH
(
"
Unreachable
"
)
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachCrossCompartmentWrapper
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsWrapper
(
obj
)
|
|
Wrapper
:
:
wrapperHandler
(
obj
)
!
=
&
CrossCompartmentWrapper
:
:
singleton
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
unwrapped
(
cx_
Wrapper
:
:
wrappedObject
(
obj
)
)
;
MOZ_ASSERT
(
unwrapped
=
=
UnwrapOneCheckedStatic
(
obj
)
)
;
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
unwrapped
)
"
CCWs
must
not
wrap
other
CCWs
"
)
;
if
(
unwrapped
-
>
compartment
(
)
-
>
zone
(
)
!
=
cx_
-
>
compartment
(
)
-
>
zone
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
wrappedTargetGlobal
(
cx_
&
unwrapped
-
>
nonCCWGlobal
(
)
)
;
if
(
!
cx_
-
>
compartment
(
)
-
>
wrap
(
cx_
&
wrappedTargetGlobal
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
{
AutoRealm
ar
(
cx_
unwrapped
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
unwrapped
id
&
holder
&
shape
pc_
resultFlags_
)
;
if
(
canCache
=
=
CanAttachTemporarilyUnoptimizable
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
if
(
canCache
!
=
CanAttachReadSlot
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
holder
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
if
(
unwrapped
=
=
holder
)
{
if
(
IsPreliminaryObject
(
unwrapped
)
)
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
}
else
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
}
}
else
{
if
(
UncacheableProtoOnChain
(
unwrapped
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
guardHasProxyHandler
(
objId
Wrapper
:
:
wrapperHandler
(
obj
)
)
;
ObjOperandId
wrapperTargetId
=
writer
.
loadWrapperTarget
(
objId
)
;
writer
.
guardCompartment
(
wrapperTargetId
wrappedTargetGlobal
unwrapped
-
>
compartment
(
)
)
;
ObjOperandId
unwrappedId
=
wrapperTargetId
;
EmitReadSlotResult
<
SlotReadType
:
:
CrossCompartment
>
(
writer
unwrapped
holder
shape
unwrappedId
)
;
EmitReadSlotReturn
(
writer
unwrapped
holder
shape
true
)
;
trackAttached
(
"
CCWSlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
bool
GetXrayExpandoShapeWrapper
(
JSContext
*
cx
HandleObject
xray
MutableHandleObject
wrapper
)
{
Value
v
=
GetProxyReservedSlot
(
xray
GetXrayJitInfo
(
)
-
>
xrayHolderSlot
)
;
if
(
v
.
isObject
(
)
)
{
NativeObject
*
holder
=
&
v
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
v
=
holder
-
>
getFixedSlot
(
GetXrayJitInfo
(
)
-
>
holderExpandoSlot
)
;
if
(
v
.
isObject
(
)
)
{
RootedNativeObject
expando
(
cx
&
UncheckedUnwrap
(
&
v
.
toObject
(
)
)
-
>
as
<
NativeObject
>
(
)
)
;
wrapper
.
set
(
NewWrapperWithObjectShape
(
cx
expando
)
)
;
return
wrapper
!
=
nullptr
;
}
}
wrapper
.
set
(
nullptr
)
;
return
true
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachXrayCrossCompartmentWrapper
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsProxy
(
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
XrayJitInfo
*
info
=
GetXrayJitInfo
(
)
;
if
(
!
info
|
|
!
info
-
>
isCrossCompartmentXray
(
GetProxyHandler
(
obj
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
info
-
>
compartmentHasExclusiveExpandos
(
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
target
(
cx_
UncheckedUnwrap
(
obj
)
)
;
RootedObject
expandoShapeWrapper
(
cx_
)
;
if
(
!
GetXrayExpandoShapeWrapper
(
cx_
obj
&
expandoShapeWrapper
)
)
{
cx_
-
>
recoverFromOutOfMemory
(
)
;
return
AttachDecision
:
:
NoAction
;
}
Rooted
<
PropertyDescriptor
>
desc
(
cx_
)
;
RootedObject
holder
(
cx_
obj
)
;
RootedObjectVector
prototypes
(
cx_
)
;
RootedObjectVector
prototypeExpandoShapeWrappers
(
cx_
)
;
while
(
true
)
{
if
(
!
GetOwnPropertyDescriptor
(
cx_
holder
id
&
desc
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
desc
.
object
(
)
)
{
break
;
}
if
(
!
GetPrototype
(
cx_
holder
&
holder
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
!
holder
|
|
!
IsProxy
(
holder
)
|
|
!
info
-
>
isCrossCompartmentXray
(
GetProxyHandler
(
holder
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
prototypeExpandoShapeWrapper
(
cx_
)
;
if
(
!
GetXrayExpandoShapeWrapper
(
cx_
holder
&
prototypeExpandoShapeWrapper
)
|
|
!
prototypes
.
append
(
holder
)
|
|
!
prototypeExpandoShapeWrappers
.
append
(
prototypeExpandoShapeWrapper
)
)
{
cx_
-
>
recoverFromOutOfMemory
(
)
;
return
AttachDecision
:
:
NoAction
;
}
}
if
(
!
desc
.
isAccessorDescriptor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
getter
(
cx_
desc
.
getterObject
(
)
)
;
if
(
!
getter
|
|
!
getter
-
>
is
<
JSFunction
>
(
)
|
|
!
getter
-
>
as
<
JSFunction
>
(
)
.
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardIsProxy
(
objId
)
;
writer
.
guardHasProxyHandler
(
objId
GetProxyHandler
(
obj
)
)
;
ObjOperandId
wrapperTargetId
=
writer
.
loadWrapperTarget
(
objId
)
;
writer
.
guardAnyClass
(
wrapperTargetId
target
-
>
getClass
(
)
)
;
writer
.
guardXrayExpandoShapeAndDefaultProto
(
objId
!
!
expandoShapeWrapper
expandoShapeWrapper
)
;
for
(
size_t
i
=
0
;
i
<
prototypes
.
length
(
)
;
i
+
+
)
{
JSObject
*
proto
=
prototypes
[
i
]
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
JSObject
*
protoShapeWrapper
=
prototypeExpandoShapeWrappers
[
i
]
;
writer
.
guardXrayExpandoShapeAndDefaultProto
(
protoId
!
!
protoShapeWrapper
protoShapeWrapper
)
;
}
writer
.
callNativeGetterResult
(
objId
&
getter
-
>
as
<
JSFunction
>
(
)
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
XrayGetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
bool
handleDOMProxies
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
if
(
!
handleDOMProxies
)
{
writer
.
guardNotDOMProxy
(
objId
)
;
}
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
|
|
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
{
MOZ_ASSERT
(
!
isSuper
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
MOZ_ASSERT
(
!
isSuper
(
)
)
;
writer
.
callProxyGetByValueResult
(
objId
getElemKeyValueId
(
)
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
GenericProxy
"
)
;
return
AttachDecision
:
:
Attach
;
}
ObjOperandId
IRGenerator
:
:
guardDOMProxyExpandoObjectAndShape
(
JSObject
*
obj
ObjOperandId
objId
const
Value
&
expandoVal
JSObject
*
expandoObj
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
TestMatchingProxyReceiver
(
writer
&
obj
-
>
as
<
ProxyObject
>
(
)
objId
)
;
ValOperandId
expandoValId
;
if
(
expandoVal
.
isObject
(
)
)
{
expandoValId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
}
else
{
expandoValId
=
writer
.
loadDOMExpandoValueIgnoreGeneration
(
objId
)
;
}
ObjOperandId
expandoObjId
=
writer
.
guardToObject
(
expandoValId
)
;
TestMatchingHolder
(
writer
expandoObj
expandoObjId
)
;
return
expandoObjId
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachDOMProxyExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedValue
expandoVal
(
cx_
GetProxyPrivate
(
obj
)
)
;
RootedObject
expandoObj
(
cx_
)
;
if
(
expandoVal
.
isObject
(
)
)
{
expandoObj
=
&
expandoVal
.
toObject
(
)
;
}
else
{
MOZ_ASSERT
(
!
expandoVal
.
isUndefined
(
)
"
How
did
a
missing
expando
manage
to
shadow
things
?
"
)
;
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
expandoAndGeneration
)
;
expandoObj
=
&
expandoAndGeneration
-
>
expando
.
toObject
(
)
;
}
RootedNativeObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
expandoObj
id
&
holder
&
propShape
pc_
resultFlags_
)
;
if
(
canCache
=
=
CanAttachNone
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
canCache
=
=
CanAttachTemporarilyUnoptimizable
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
if
(
!
holder
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
holder
=
=
expandoObj
)
;
maybeEmitIdGuard
(
id
)
;
ObjOperandId
expandoObjId
=
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
expandoObjId
&
expandoObj
-
>
as
<
NativeObject
>
(
)
propShape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachNativeGetter
|
|
canCache
=
=
CanAttachScriptedGetter
)
;
EmitCallGetterResultNoGuards
(
cx_
writer
expandoObj
expandoObj
propShape
objId
)
;
}
trackAttached
(
"
DOMProxyExpando
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
!
isSuper
(
)
)
;
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
maybeEmitIdGuard
(
id
)
;
TestMatchingProxyReceiver
(
writer
&
obj
-
>
as
<
ProxyObject
>
(
)
objId
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DOMProxyShadowed
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
void
CheckDOMProxyExpandoDoesNotShadow
(
CacheIRWriter
&
writer
JSObject
*
obj
jsid
id
ObjOperandId
objId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Value
expandoVal
=
GetProxyPrivate
(
obj
)
;
ValOperandId
expandoId
;
if
(
!
expandoVal
.
isObject
(
)
&
&
!
expandoVal
.
isUndefined
(
)
)
{
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
uint64_t
generation
=
expandoAndGeneration
-
>
generation
;
expandoId
=
writer
.
loadDOMExpandoValueGuardGeneration
(
objId
expandoAndGeneration
generation
)
;
expandoVal
=
expandoAndGeneration
-
>
expando
;
}
else
{
expandoId
=
writer
.
loadDOMExpandoValue
(
objId
)
;
}
if
(
expandoVal
.
isUndefined
(
)
)
{
writer
.
guardType
(
expandoId
ValueType
:
:
Undefined
)
;
}
else
if
(
expandoVal
.
isObject
(
)
)
{
NativeObject
&
expandoObj
=
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
!
expandoObj
.
containsPure
(
id
)
)
;
writer
.
guardDOMExpandoMissingOrGuardShape
(
expandoId
expandoObj
.
lastProperty
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Invalid
expando
value
"
)
;
}
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
checkObj
(
cx_
obj
-
>
staticPrototype
(
)
)
;
if
(
!
checkObj
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx_
checkObj
id
&
holder
&
shape
pc_
resultFlags_
)
;
if
(
canCache
=
=
CanAttachNone
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
canCache
=
=
CanAttachTemporarilyUnoptimizable
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
maybeEmitIdGuard
(
id
)
;
TestMatchingProxyReceiver
(
writer
&
obj
-
>
as
<
ProxyObject
>
(
)
objId
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
if
(
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
TestMatchingHolder
(
writer
holder
holderId
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
writer
.
typeMonitorResult
(
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachNativeGetter
|
|
canCache
=
=
CanAttachScriptedGetter
)
;
MOZ_ASSERT
(
!
isSuper
(
)
)
;
EmitCallGetterResultNoGuards
(
cx_
writer
checkObj
holder
shape
objId
)
;
}
}
else
{
MOZ_ASSERT
(
!
isSuper
(
)
)
;
writer
.
callProxyGetResult
(
objId
id
)
;
writer
.
typeMonitorResult
(
)
;
}
trackAttached
(
"
DOMProxyUnshadowed
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
ProxyStubType
type
=
GetProxyStubType
(
cx_
obj
id
)
;
if
(
type
=
=
ProxyStubType
:
:
None
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
isSuper
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
tryAttachGenericProxy
(
obj
objId
id
true
)
;
}
switch
(
type
)
{
case
ProxyStubType
:
:
None
:
break
;
case
ProxyStubType
:
:
DOMExpando
:
TRY_ATTACH
(
tryAttachDOMProxyExpando
(
obj
objId
id
)
)
;
[
[
fallthrough
]
]
;
case
ProxyStubType
:
:
DOMShadowed
:
return
tryAttachDOMProxyShadowed
(
obj
objId
id
)
;
case
ProxyStubType
:
:
DOMUnshadowed
:
TRY_ATTACH
(
tryAttachDOMProxyUnshadowed
(
obj
objId
id
)
)
;
return
tryAttachGenericProxy
(
obj
objId
id
true
)
;
case
ProxyStubType
:
:
Generic
:
return
tryAttachGenericProxy
(
obj
objId
id
false
)
;
}
MOZ_CRASH
(
"
Unexpected
ProxyStubType
"
)
;
}
static
TypedThingLayout
GetTypedThingLayout
(
const
JSClass
*
clasp
)
{
if
(
IsTypedArrayClass
(
clasp
)
)
{
return
Layout_TypedArray
;
}
if
(
IsOutlineTypedObjectClass
(
clasp
)
)
{
return
Layout_OutlineTypedObject
;
}
if
(
IsInlineTypedObjectClass
(
clasp
)
)
{
return
Layout_InlineTypedObject
;
}
MOZ_CRASH
(
"
Bad
object
class
"
)
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachTypedObject
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypedObject
*
typedObj
=
&
obj
-
>
as
<
TypedObject
>
(
)
;
if
(
!
typedObj
-
>
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
StructTypeDescr
*
structDescr
=
&
typedObj
-
>
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
uint32_t
typeDescr
=
SimpleTypeDescrKey
(
&
fieldDescr
-
>
as
<
SimpleTypeDescr
>
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
writer
.
loadTypedObjectResult
(
objId
layout
typeDescr
fieldOffset
)
;
bool
monitorLoad
=
false
;
if
(
SimpleTypeDescrKeyIsScalar
(
typeDescr
)
)
{
Scalar
:
:
Type
type
=
ScalarTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
=
=
Scalar
:
:
Uint32
;
}
else
{
ReferenceType
type
=
ReferenceTypeFromSimpleTypeDescrKey
(
typeDescr
)
;
monitorLoad
=
type
!
=
ReferenceType
:
:
TYPE_STRING
;
}
if
(
monitorLoad
)
{
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
trackAttached
(
"
TypedObject
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachObjectLength
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
(
resultFlags_
&
GetPropertyResultFlags
:
:
AllowInt32
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
obj
-
>
is
<
ArrayObject
>
(
)
)
{
if
(
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
loadInt32ArrayLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ArrayLength
"
)
;
return
AttachDecision
:
:
Attach
;
}
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
&
&
!
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
{
maybeEmitIdGuard
(
id
)
;
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ArgumentsObjectLength
"
)
;
return
AttachDecision
:
:
Attach
;
}
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachFunction
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
JSObject
*
holder
=
nullptr
;
PropertyResult
prop
;
if
(
LookupPropertyPure
(
cx_
obj
id
&
holder
&
prop
)
)
{
return
AttachDecision
:
:
NoAction
;
}
JSFunction
*
fun
=
&
obj
-
>
as
<
JSFunction
>
(
)
;
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
if
(
fun
-
>
hasResolvedLength
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
fun
-
>
hasBytecode
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
JSFunction
)
;
writer
.
loadFunctionLengthResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
FunctionLength
"
)
;
return
AttachDecision
:
:
Attach
;
}
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachModuleNamespace
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
)
{
if
(
!
obj
-
>
is
<
ModuleNamespaceObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Rooted
<
ModuleNamespaceObject
*
>
ns
(
cx_
&
obj
-
>
as
<
ModuleNamespaceObject
>
(
)
)
;
RootedModuleEnvironmentObject
env
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
id
env
.
address
(
)
shape
.
address
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
env
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
IsIonEnabled
(
cx_
)
)
{
EnsureTrackPropertyTypes
(
cx_
env
shape
-
>
propid
(
)
)
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardSpecificObject
(
objId
ns
)
;
ObjOperandId
envId
=
writer
.
loadObject
(
env
)
;
EmitLoadSlotResult
(
writer
envId
env
shape
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ModuleNamespace
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
HandleId
id
)
{
MOZ_ASSERT
(
!
isSuper
(
)
"
SuperBase
is
guaranteed
to
be
an
object
"
)
;
JSProtoKey
protoKey
;
switch
(
val_
.
type
(
)
)
{
case
ValueType
:
:
String
:
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
return
AttachDecision
:
:
NoAction
;
}
protoKey
=
JSProto_String
;
break
;
case
ValueType
:
:
Int32
:
case
ValueType
:
:
Double
:
protoKey
=
JSProto_Number
;
break
;
case
ValueType
:
:
Boolean
:
protoKey
=
JSProto_Boolean
;
break
;
case
ValueType
:
:
Symbol
:
protoKey
=
JSProto_Symbol
;
break
;
case
ValueType
:
:
BigInt
:
protoKey
=
JSProto_BigInt
;
break
;
case
ValueType
:
:
Null
:
case
ValueType
:
:
Undefined
:
case
ValueType
:
:
Magic
:
return
AttachDecision
:
:
NoAction
;
case
ValueType
:
:
Object
:
case
ValueType
:
:
PrivateGCThing
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
RootedObject
proto
(
cx_
cx_
-
>
global
(
)
-
>
maybeGetPrototype
(
protoKey
)
)
;
if
(
!
proto
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx_
proto
id
&
holder
&
shape
pc_
resultFlags_
)
;
switch
(
type
)
{
case
CanAttachNone
:
return
AttachDecision
:
:
NoAction
;
case
CanAttachTemporarilyUnoptimizable
:
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
case
CanAttachReadSlot
:
{
if
(
holder
)
{
if
(
IsIonEnabled
(
cx_
)
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
}
}
if
(
val_
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
valId
)
;
}
else
{
writer
.
guardType
(
valId
val_
.
type
(
)
)
;
}
maybeEmitIdGuard
(
id
)
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
EmitReadSlotResult
(
writer
proto
holder
shape
protoId
)
;
EmitReadSlotReturn
(
writer
proto
holder
shape
)
;
trackAttached
(
"
PrimitiveSlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
case
CanAttachScriptedGetter
:
case
CanAttachNativeGetter
:
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
if
(
val_
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
valId
)
;
}
else
{
writer
.
guardType
(
valId
val_
.
type
(
)
)
;
}
maybeEmitIdGuard
(
id
)
;
ObjOperandId
protoId
=
writer
.
loadObject
(
proto
)
;
EmitCallGetterByValueResult
(
cx_
writer
proto
holder
shape
protoId
valId
mode_
)
;
trackAttached
(
"
PrimitiveGetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
}
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachStringLength
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isString
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
return
AttachDecision
:
:
NoAction
;
}
StringOperandId
strId
=
writer
.
guardToString
(
valId
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
loadStringLengthResult
(
strId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StringLength
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachStringChar
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
int32_t
index
=
idVal_
.
toInt32
(
)
;
if
(
index
<
0
)
{
return
AttachDecision
:
:
NoAction
;
}
JSString
*
str
=
val_
.
toString
(
)
;
if
(
size_t
(
index
)
>
=
str
-
>
length
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
str
-
>
isRope
(
)
)
{
JSRope
*
rope
=
&
str
-
>
asRope
(
)
;
if
(
size_t
(
index
)
>
=
rope
-
>
leftChild
(
)
-
>
length
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
str
=
rope
-
>
leftChild
(
)
;
}
if
(
!
str
-
>
isLinear
(
)
|
|
str
-
>
asLinear
(
)
.
latin1OrTwoByteChar
(
index
)
>
=
StaticStrings
:
:
UNIT_STATIC_LIMIT
)
{
return
AttachDecision
:
:
NoAction
;
}
StringOperandId
strId
=
writer
.
guardToString
(
valId
)
;
Int32OperandId
int32IndexId
=
writer
.
guardToInt32Index
(
indexId
)
;
writer
.
loadStringCharResult
(
strId
int32IndexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StringChar
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachMagicArgumentsName
(
ValOperandId
valId
HandleId
id
)
{
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
&
&
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
if
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
)
{
writer
.
loadFrameNumActualArgsResult
(
)
;
writer
.
returnFromIC
(
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
callee
)
)
;
writer
.
loadFrameCalleeResult
(
)
;
writer
.
typeMonitorResult
(
)
;
}
trackAttached
(
"
MagicArgumentsName
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachMagicArgument
(
ValOperandId
valId
ValOperandId
indexId
)
{
MOZ_ASSERT
(
idVal_
.
isInt32
(
)
)
;
if
(
!
val_
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardMagicValue
(
valId
JS_OPTIMIZED_ARGUMENTS
)
;
writer
.
guardFrameHasNoArgumentsObject
(
)
;
Int32OperandId
int32IndexId
=
writer
.
guardToInt32Index
(
indexId
)
;
writer
.
loadFrameArgumentResult
(
int32IndexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
MagicArgument
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachArgumentsObjectArg
(
HandleObject
obj
ObjOperandId
objId
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
ArgumentsObject
>
(
)
|
|
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenElement
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
(
resultFlags_
&
GetPropertyResultFlags
:
:
Monitored
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
{
writer
.
guardClass
(
objId
GuardClassKind
:
:
MappedArguments
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
UnmappedArguments
)
;
}
writer
.
loadArgumentsObjectArgResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ArgumentsObjectArg
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachDenseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
containsDenseElement
(
index
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
writer
.
loadDenseElementResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DenseElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
bool
CanAttachDenseElementHole
(
NativeObject
*
obj
bool
ownProp
bool
allowIndexedReceiver
=
false
)
{
do
{
if
(
!
allowIndexedReceiver
&
&
obj
-
>
isIndexed
(
)
)
{
return
false
;
}
allowIndexedReceiver
=
false
;
if
(
ClassCanHaveExtraProperties
(
obj
-
>
getClass
(
)
)
)
{
return
false
;
}
if
(
ownProp
)
{
return
true
;
}
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
{
break
;
}
if
(
!
proto
-
>
isNative
(
)
)
{
return
false
;
}
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
!
=
0
)
{
return
false
;
}
obj
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
while
(
true
)
;
return
true
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachDenseElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
containsDenseElement
(
index
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
CanAttachDenseElementHole
(
nobj
false
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
GeneratePrototypeHoleGuards
(
writer
nobj
objId
false
)
;
writer
.
loadDenseElementHoleResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
DenseElementHole
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachSparseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
index
>
INT_MAX
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
index
<
nobj
-
>
getDenseInitializedLength
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
nobj
-
>
is
<
ArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
(
nobj
-
>
staticPrototype
(
)
!
=
nullptr
)
&
&
ObjectMayHaveExtraIndexedProperties
(
nobj
-
>
staticPrototype
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
guardIndexGreaterThanDenseInitLength
(
objId
indexId
)
;
writer
.
guardIndexIsNonNegative
(
indexId
)
;
GeneratePrototypeHoleGuards
(
writer
nobj
objId
true
)
;
writer
.
callGetSparseElementResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
GetSparseElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
bool
IsPrimitiveArrayTypedObject
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
{
return
false
;
}
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
is
<
ArrayTypeDescr
>
(
)
&
&
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
is
<
ScalarTypeDescr
>
(
)
;
}
static
Scalar
:
:
Type
PrimitiveArrayTypedObjectType
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsPrimitiveArrayTypedObject
(
obj
)
)
;
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
}
static
Scalar
:
:
Type
TypedThingElementType
(
JSObject
*
obj
)
{
return
obj
-
>
is
<
TypedArrayObject
>
(
)
?
obj
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
:
PrimitiveArrayTypedObjectType
(
obj
)
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachTypedElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
IsPrimitiveArrayTypedObject
(
obj
)
)
{
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
}
else
{
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
}
writer
.
loadTypedElementResult
(
objId
indexId
layout
TypedThingElementType
(
obj
)
false
)
;
if
(
TypedThingElementType
(
obj
)
=
=
Scalar
:
:
Type
:
:
Uint32
)
{
writer
.
typeMonitorResult
(
)
;
}
else
{
writer
.
returnFromIC
(
)
;
}
trackAttached
(
"
TypedElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachTypedArrayNonInt32Index
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
idVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
keyId
=
getElemKeyValueId
(
)
;
Int32OperandId
indexId
=
writer
.
guardToTypedArrayIndex
(
keyId
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
writer
.
loadTypedElementResult
(
objId
indexId
layout
TypedThingElementType
(
obj
)
true
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
TypedArrayNonInt32Index
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachGenericElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
writer
.
guardIsNativeObject
(
objId
)
;
}
else
{
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
}
writer
.
guardIndexGreaterThanDenseInitLength
(
objId
indexId
)
;
writer
.
callNativeGetElementResult
(
objId
indexId
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
?
"
GenericElementMegamorphic
"
:
"
GenericElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetPropIRGenerator
:
:
tryAttachProxyElement
(
HandleObject
obj
ObjOperandId
objId
)
{
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
isSuper
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardIsProxy
(
objId
)
;
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
)
;
MOZ_ASSERT
(
!
isSuper
(
)
)
;
writer
.
callProxyGetByValueResult
(
objId
getElemKeyValueId
(
)
)
;
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
ProxyElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
GetPropIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
base
"
val_
)
;
sp
.
valueProperty
(
"
property
"
idVal_
)
;
}
#
endif
}
void
IRGenerator
:
:
emitIdGuard
(
ValOperandId
valId
jsid
id
)
{
if
(
JSID_IS_SYMBOL
(
id
)
)
{
SymbolOperandId
symId
=
writer
.
guardToSymbol
(
valId
)
;
writer
.
guardSpecificSymbol
(
symId
JSID_TO_SYMBOL
(
id
)
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_ATOM
(
id
)
)
;
StringOperandId
strId
=
writer
.
guardToString
(
valId
)
;
writer
.
guardSpecificAtom
(
strId
JSID_TO_ATOM
(
id
)
)
;
}
}
void
GetPropIRGenerator
:
:
maybeEmitIdGuard
(
jsid
id
)
{
if
(
cacheKind_
=
=
CacheKind
:
:
GetProp
|
|
cacheKind_
=
=
CacheKind
:
:
GetPropSuper
)
{
MOZ_ASSERT
(
&
idVal_
.
toString
(
)
-
>
asAtom
(
)
=
=
JSID_TO_ATOM
(
id
)
)
;
return
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetElem
|
|
cacheKind_
=
=
CacheKind
:
:
GetElemSuper
)
;
emitIdGuard
(
getElemKeyValueId
(
)
id
)
;
}
void
SetPropIRGenerator
:
:
maybeEmitIdGuard
(
jsid
id
)
{
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
MOZ_ASSERT
(
&
idVal_
.
toString
(
)
-
>
asAtom
(
)
=
=
JSID_TO_ATOM
(
id
)
)
;
return
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
emitIdGuard
(
setElemKeyValueId
(
)
id
)
;
}
GetNameIRGenerator
:
:
GetNameIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleObject
env
HandlePropertyName
name
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
GetName
mode
)
env_
(
env
)
name_
(
name
)
{
}
AttachDecision
GetNameIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetName
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ObjOperandId
envId
(
writer
.
setInputOperandId
(
0
)
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
TRY_ATTACH
(
tryAttachGlobalNameValue
(
envId
id
)
)
;
TRY_ATTACH
(
tryAttachGlobalNameGetter
(
envId
id
)
)
;
TRY_ATTACH
(
tryAttachEnvironmentName
(
envId
id
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
bool
CanAttachGlobalName
(
JSContext
*
cx
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
)
{
RootedNativeObject
current
(
cx
globalLexical
)
;
while
(
true
)
{
shape
.
set
(
current
-
>
lookup
(
cx
id
)
)
;
if
(
shape
)
{
break
;
}
if
(
current
=
=
globalLexical
)
{
current
=
&
globalLexical
-
>
global
(
)
;
}
else
{
if
(
!
current
-
>
staticPrototypeIsImmutable
(
)
)
{
return
false
;
}
JSObject
*
proto
=
current
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
!
proto
-
>
is
<
NativeObject
>
(
)
)
{
return
false
;
}
current
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
holder
.
set
(
current
)
;
return
true
;
}
AttachDecision
GetNameIRGenerator
:
:
tryAttachGlobalNameValue
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
shape
-
>
isDataProperty
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
IsIonEnabled
(
cx_
)
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
}
if
(
holder
=
=
globalLexical
)
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadDynamicSlotResult
(
objId
dynamicSlotOffset
)
;
}
else
{
if
(
!
IsCacheableGetPropReadSlot
(
&
globalLexical
-
>
global
(
)
holder
PropertyResult
(
shape
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
ObjOperandId
holderId
=
globalId
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitLoadSlotResult
(
writer
holderId
holder
shape
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
GlobalNameValue
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
GetNameIRGenerator
:
:
tryAttachGlobalNameGetter
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedNativeObject
holder
(
cx_
)
;
RootedShape
shape
(
cx_
)
;
if
(
!
CanAttachGlobalName
(
cx_
globalLexical
id
&
holder
&
shape
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
holder
=
=
globalLexical
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
IsCacheableGetPropCall
(
&
globalLexical
-
>
global
(
)
holder
shape
)
!
=
CanAttachNativeGetter
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
IsIonEnabled
(
cx_
)
)
{
EnsureTrackPropertyTypes
(
cx_
holder
id
)
;
}
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
guardShape
(
globalId
globalLexical
-
>
global
(
)
.
lastProperty
(
)
)
;
if
(
holder
!
=
&
globalLexical
-
>
global
(
)
)
{
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
writer
.
guardShape
(
holderId
holder
-
>
lastProperty
(
)
)
;
}
EmitCallGetterResultNoGuards
(
cx_
writer
&
globalLexical
-
>
global
(
)
holder
shape
globalId
)
;
trackAttached
(
"
GlobalNameGetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
bool
NeedEnvironmentShapeGuard
(
JSObject
*
envObj
)
{
if
(
!
envObj
-
>
is
<
CallObject
>
(
)
)
{
return
true
;
}
CallObject
*
callObj
=
&
envObj
-
>
as
<
CallObject
>
(
)
;
JSFunction
*
fun
=
&
callObj
-
>
callee
(
)
;
if
(
!
fun
-
>
hasBaseScript
(
)
|
|
fun
-
>
baseScript
(
)
-
>
funHasExtensibleScope
(
)
)
{
return
true
;
}
return
false
;
}
AttachDecision
GetNameIRGenerator
:
:
tryAttachEnvironmentName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
env
(
cx_
env_
)
;
RootedShape
shape
(
cx_
)
;
RootedNativeObject
holder
(
cx_
)
;
while
(
env
)
{
if
(
env
-
>
is
<
GlobalObject
>
(
)
)
{
shape
=
env
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
{
break
;
}
return
AttachDecision
:
:
NoAction
;
}
if
(
!
env
-
>
is
<
EnvironmentObject
>
(
)
|
|
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
!
env
-
>
hasUncacheableProto
(
)
)
;
shape
=
env
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
{
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
holder
=
&
env
-
>
as
<
NativeObject
>
(
)
;
if
(
!
IsCacheableGetPropReadSlot
(
holder
holder
PropertyResult
(
shape
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ObjOperandId
lastObjId
=
objId
;
env
=
env_
;
while
(
env
)
{
if
(
NeedEnvironmentShapeGuard
(
env
)
)
{
writer
.
guardShape
(
lastObjId
env
-
>
shape
(
)
)
;
}
if
(
env
=
=
holder
)
{
break
;
}
lastObjId
=
writer
.
loadEnclosingEnvironment
(
lastObjId
)
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
writer
.
loadEnvironmentFixedSlotResult
(
lastObjId
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
}
else
{
size_t
dynamicSlotOffset
=
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
loadEnvironmentDynamicSlotResult
(
lastObjId
dynamicSlotOffset
)
;
}
writer
.
typeMonitorResult
(
)
;
trackAttached
(
"
EnvironmentName
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
GetNameIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
"
property
"
StringValue
(
name_
)
)
;
}
#
endif
}
BindNameIRGenerator
:
:
BindNameIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleObject
env
HandlePropertyName
name
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
BindName
mode
)
env_
(
env
)
name_
(
name
)
{
}
AttachDecision
BindNameIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
BindName
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ObjOperandId
envId
(
writer
.
setInputOperandId
(
0
)
)
;
RootedId
id
(
cx_
NameToId
(
name_
)
)
;
TRY_ATTACH
(
tryAttachGlobalName
(
envId
id
)
)
;
TRY_ATTACH
(
tryAttachEnvironmentName
(
envId
id
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
BindNameIRGenerator
:
:
tryAttachGlobalName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
!
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Handle
<
LexicalEnvironmentObject
*
>
globalLexical
=
env_
.
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
JSObject
*
result
=
nullptr
;
if
(
Shape
*
shape
=
globalLexical
-
>
lookup
(
cx_
id
)
)
{
if
(
globalLexical
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
|
|
!
shape
-
>
writable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
result
=
globalLexical
;
}
else
{
result
=
&
globalLexical
-
>
global
(
)
;
}
if
(
result
=
=
globalLexical
)
{
writer
.
loadObjectResult
(
objId
)
;
}
else
{
Shape
*
shape
=
result
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
!
shape
|
|
shape
-
>
configurable
(
)
)
{
writer
.
guardShape
(
objId
globalLexical
-
>
lastProperty
(
)
)
;
}
ObjOperandId
globalId
=
writer
.
loadEnclosingEnvironment
(
objId
)
;
writer
.
loadObjectResult
(
globalId
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GlobalName
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BindNameIRGenerator
:
:
tryAttachEnvironmentName
(
ObjOperandId
objId
HandleId
id
)
{
if
(
IsGlobalOp
(
JSOp
(
*
pc_
)
)
|
|
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
env
(
cx_
env_
)
;
RootedShape
shape
(
cx_
)
;
while
(
true
)
{
if
(
!
env
-
>
is
<
GlobalObject
>
(
)
&
&
!
env
-
>
is
<
EnvironmentObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
env
-
>
is
<
WithEnvironmentObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
!
env
-
>
hasUncacheableProto
(
)
)
;
if
(
env
-
>
isUnqualifiedVarObj
(
)
)
{
break
;
}
shape
=
env
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
shape
)
{
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
RootedNativeObject
holder
(
cx_
&
env
-
>
as
<
NativeObject
>
(
)
)
;
if
(
shape
&
&
holder
-
>
is
<
EnvironmentObject
>
(
)
&
&
(
holder
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
)
|
|
!
shape
-
>
writable
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ObjOperandId
lastObjId
=
objId
;
env
=
env_
;
while
(
env
)
{
if
(
NeedEnvironmentShapeGuard
(
env
)
&
&
!
env
-
>
is
<
GlobalObject
>
(
)
)
{
writer
.
guardShape
(
lastObjId
env
-
>
shape
(
)
)
;
}
if
(
env
=
=
holder
)
{
break
;
}
lastObjId
=
writer
.
loadEnclosingEnvironment
(
lastObjId
)
;
env
=
env
-
>
enclosingEnvironment
(
)
;
}
writer
.
loadObjectResult
(
lastObjId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
EnvironmentName
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
BindNameIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
base
"
ObjectValue
(
*
env_
)
)
;
sp
.
valueProperty
(
"
property
"
StringValue
(
name_
)
)
;
}
#
endif
}
HasPropIRGenerator
:
:
HasPropIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
CacheKind
cacheKind
HandleValue
idVal
HandleValue
val
)
:
IRGenerator
(
cx
script
pc
cacheKind
mode
)
val_
(
val
)
idVal_
(
idVal
)
{
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachDense
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
containsDenseElement
(
index
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
writer
.
loadDenseElementExistsResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DenseHasProp
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachDenseHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
nobj
-
>
containsDenseElement
(
index
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
CanAttachDenseElementHole
(
nobj
hasOwn
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
if
(
!
hasOwn
)
{
GeneratePrototypeHoleGuards
(
writer
nobj
objId
false
)
;
}
writer
.
loadDenseElementHoleExistsResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DenseHasPropHole
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachSparse
(
HandleObject
obj
ObjOperandId
objId
Int32OperandId
indexId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
obj
-
>
as
<
NativeObject
>
(
)
.
isIndexed
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
CanAttachDenseElementHole
(
&
obj
-
>
as
<
NativeObject
>
(
)
hasOwn
true
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardIsNativeObject
(
objId
)
;
if
(
!
hasOwn
)
{
GeneratePrototypeHoleGuards
(
writer
obj
objId
true
)
;
}
writer
.
callObjectHasSparseElementResult
(
objId
indexId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Sparse
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachNamedProp
(
HandleObject
obj
ObjOperandId
objId
HandleId
key
ValOperandId
keyId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
JSObject
*
holder
=
nullptr
;
PropertyResult
prop
;
if
(
hasOwn
)
{
if
(
!
LookupOwnPropertyPure
(
cx_
obj
key
&
prop
)
)
{
return
AttachDecision
:
:
NoAction
;
}
holder
=
obj
;
}
else
{
if
(
!
LookupPropertyPure
(
cx_
obj
key
&
holder
&
prop
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
if
(
!
prop
)
{
return
AttachDecision
:
:
NoAction
;
}
TRY_ATTACH
(
tryAttachMegamorphic
(
objId
keyId
)
)
;
TRY_ATTACH
(
tryAttachNative
(
obj
objId
key
keyId
prop
holder
)
)
;
TRY_ATTACH
(
tryAttachTypedObject
(
obj
objId
key
keyId
)
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachMegamorphic
(
ObjOperandId
objId
ValOperandId
keyId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
if
(
mode_
!
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
megamorphicHasPropResult
(
objId
keyId
hasOwn
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicHasProp
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachNative
(
JSObject
*
obj
ObjOperandId
objId
jsid
key
ValOperandId
keyId
PropertyResult
prop
JSObject
*
holder
)
{
if
(
!
prop
.
isNativeProperty
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
IsCacheableProtoChain
(
obj
holder
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Maybe
<
ObjOperandId
>
tempId
;
emitIdGuard
(
keyId
key
)
;
EmitReadSlotGuard
(
writer
obj
holder
objId
&
tempId
)
;
writer
.
loadBooleanResult
(
true
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NativeHasProp
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachTypedArray
(
HandleObject
obj
ObjOperandId
objId
Int32OperandId
indexId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
IsPrimitiveArrayTypedObject
(
obj
)
)
{
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
}
else
{
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
}
writer
.
loadTypedElementExistsResult
(
objId
indexId
layout
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedArrayObject
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachTypedArrayNonInt32Index
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
keyId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
idVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
indexId
=
writer
.
guardToTypedArrayIndex
(
keyId
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
writer
.
loadTypedElementExistsResult
(
objId
indexId
layout
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedArrayObjectNonInt32Index
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachTypedObject
(
JSObject
*
obj
ObjOperandId
objId
jsid
key
ValOperandId
keyId
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
hasProperty
(
cx_
-
>
names
(
)
key
)
)
{
return
AttachDecision
:
:
NoAction
;
}
emitIdGuard
(
keyId
key
)
;
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
writer
.
loadBooleanResult
(
true
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObjectHasProp
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachSlotDoesNotExist
(
JSObject
*
obj
ObjOperandId
objId
jsid
key
ValOperandId
keyId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
emitIdGuard
(
keyId
key
)
;
if
(
hasOwn
)
{
TestMatchingReceiver
(
writer
obj
objId
)
;
}
else
{
Maybe
<
ObjOperandId
>
tempId
;
EmitReadSlotGuard
(
writer
obj
nullptr
objId
&
tempId
)
;
}
writer
.
loadBooleanResult
(
false
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DoesNotExist
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachDoesNotExist
(
HandleObject
obj
ObjOperandId
objId
HandleId
key
ValOperandId
keyId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
if
(
hasOwn
)
{
if
(
!
CheckHasNoSuchOwnProperty
(
cx_
obj
key
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
else
{
if
(
!
CheckHasNoSuchProperty
(
cx_
obj
key
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
TRY_ATTACH
(
tryAttachMegamorphic
(
objId
keyId
)
)
;
TRY_ATTACH
(
tryAttachSlotDoesNotExist
(
obj
objId
key
keyId
)
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachProxyElement
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
keyId
)
{
bool
hasOwn
=
(
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardIsProxy
(
objId
)
;
writer
.
callProxyHasPropResult
(
objId
keyId
hasOwn
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ProxyHasProp
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
HasPropIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
In
|
|
cacheKind_
=
=
CacheKind
:
:
HasOwn
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
keyId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
1
)
)
;
if
(
!
val_
.
isObject
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
TRY_ATTACH
(
tryAttachProxyElement
(
obj
objId
keyId
)
)
;
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
nameOrSymbol
)
{
TRY_ATTACH
(
tryAttachNamedProp
(
obj
objId
id
keyId
)
)
;
TRY_ATTACH
(
tryAttachDoesNotExist
(
obj
objId
id
keyId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
keyId
&
index
&
indexId
)
)
{
TRY_ATTACH
(
tryAttachDense
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachDenseHole
(
obj
objId
index
indexId
)
)
;
TRY_ATTACH
(
tryAttachTypedArray
(
obj
objId
indexId
)
)
;
TRY_ATTACH
(
tryAttachSparse
(
obj
objId
indexId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
TRY_ATTACH
(
tryAttachTypedArrayNonInt32Index
(
obj
objId
keyId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
void
HasPropIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
base
"
val_
)
;
sp
.
valueProperty
(
"
property
"
idVal_
)
;
}
#
endif
}
bool
IRGenerator
:
:
maybeGuardInt32Index
(
const
Value
&
index
ValOperandId
indexId
uint32_t
*
int32Index
Int32OperandId
*
int32IndexId
)
{
if
(
index
.
isNumber
(
)
)
{
int32_t
indexSigned
;
if
(
index
.
isInt32
(
)
)
{
indexSigned
=
index
.
toInt32
(
)
;
}
else
{
if
(
!
mozilla
:
:
NumberEqualsInt32
(
index
.
toDouble
(
)
&
indexSigned
)
)
{
return
false
;
}
}
if
(
indexSigned
<
0
)
{
return
false
;
}
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardToInt32Index
(
indexId
)
;
return
true
;
}
if
(
index
.
isString
(
)
)
{
int32_t
indexSigned
=
GetIndexFromString
(
index
.
toString
(
)
)
;
if
(
indexSigned
<
0
)
{
return
false
;
}
StringOperandId
strId
=
writer
.
guardToString
(
indexId
)
;
*
int32Index
=
uint32_t
(
indexSigned
)
;
*
int32IndexId
=
writer
.
guardAndGetIndexFromString
(
strId
)
;
return
true
;
}
return
false
;
}
SetPropIRGenerator
:
:
SetPropIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
CacheKind
cacheKind
ICState
:
:
Mode
mode
HandleValue
lhsVal
HandleValue
idVal
HandleValue
rhsVal
bool
needsTypeBarrier
bool
maybeHasExtraIndexedProps
)
:
IRGenerator
(
cx
script
pc
cacheKind
mode
)
lhsVal_
(
lhsVal
)
idVal_
(
idVal
)
rhsVal_
(
rhsVal
)
typeCheckInfo_
(
cx
needsTypeBarrier
)
preliminaryObjectAction_
(
PreliminaryObjectAction
:
:
None
)
attachedTypedArrayOOBStub_
(
false
)
maybeHasExtraIndexedProps_
(
maybeHasExtraIndexedProps
)
{
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
objValId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsValId
;
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
1
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
setElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
2
)
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
lhsVal_
.
isObject
(
)
)
{
RootedObject
obj
(
cx_
&
lhsVal_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
objValId
)
;
if
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
TRY_ATTACH
(
tryAttachMegamorphicSetElement
(
obj
objId
rhsValId
)
)
;
}
if
(
nameOrSymbol
)
{
TRY_ATTACH
(
tryAttachNativeSetSlot
(
obj
objId
id
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachTypedObjectProperty
(
obj
objId
id
rhsValId
)
)
;
if
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
TRY_ATTACH
(
tryAttachSetArrayLength
(
obj
objId
id
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachSetter
(
obj
objId
id
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachWindowProxy
(
obj
objId
id
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachProxy
(
obj
objId
id
rhsValId
)
)
;
}
if
(
canAttachAddSlotStub
(
obj
id
)
)
{
deferType_
=
DeferType
:
:
AddSlot
;
return
AttachDecision
:
:
Deferred
;
}
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
if
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
TRY_ATTACH
(
tryAttachProxyElement
(
obj
objId
rhsValId
)
)
;
}
uint32_t
index
;
Int32OperandId
indexId
;
if
(
maybeGuardInt32Index
(
idVal_
setElemKeyValueId
(
)
&
index
&
indexId
)
)
{
TRY_ATTACH
(
tryAttachSetDenseElement
(
obj
objId
index
indexId
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachSetDenseElementHole
(
obj
objId
index
indexId
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachSetTypedElement
(
obj
objId
index
indexId
rhsValId
)
)
;
TRY_ATTACH
(
tryAttachAddOrUpdateSparseElement
(
obj
objId
index
indexId
rhsValId
)
)
;
return
AttachDecision
:
:
NoAction
;
}
TRY_ATTACH
(
tryAttachSetTypedArrayElementNonInt32Index
(
obj
objId
rhsValId
)
)
;
}
return
AttachDecision
:
:
NoAction
;
}
static
void
EmitStoreSlotAndReturn
(
CacheIRWriter
&
writer
ObjOperandId
objId
NativeObject
*
nobj
Shape
*
shape
ValOperandId
rhsId
)
{
if
(
nobj
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
size_t
offset
=
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
;
writer
.
storeFixedSlot
(
objId
offset
rhsId
)
;
}
else
{
size_t
offset
=
nobj
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
writer
.
storeDynamicSlot
(
objId
offset
rhsId
)
;
}
writer
.
returnFromIC
(
)
;
}
static
Shape
*
LookupShapeForSetSlot
(
JSOp
op
NativeObject
*
obj
jsid
id
)
{
Shape
*
shape
=
obj
-
>
lookupPure
(
id
)
;
if
(
!
shape
|
|
!
shape
-
>
isDataProperty
(
)
|
|
!
shape
-
>
writable
(
)
)
{
return
nullptr
;
}
if
(
IsPropertyInitOp
(
op
)
&
&
(
!
shape
-
>
configurable
(
)
|
|
!
shape
-
>
enumerable
(
)
)
)
{
return
nullptr
;
}
return
shape
;
}
static
bool
CanAttachNativeSetSlot
(
JSContext
*
cx
JSOp
op
HandleObject
obj
HandleId
id
bool
*
isTemporarilyUnoptimizable
MutableHandleShape
propShape
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
false
;
}
propShape
.
set
(
LookupShapeForSetSlot
(
op
&
obj
-
>
as
<
NativeObject
>
(
)
id
)
)
;
if
(
!
propShape
)
{
return
false
;
}
ObjectGroup
*
group
=
JSObject
:
:
getGroup
(
cx
obj
)
;
if
(
!
group
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
return
false
;
}
EnsureTrackPropertyTypes
(
cx
obj
id
)
;
if
(
!
PropertyHasBeenMarkedNonConstant
(
obj
id
)
)
{
*
isTemporarilyUnoptimizable
=
true
;
return
false
;
}
return
true
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachNativeSetSlot
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
RootedShape
propShape
(
cx_
)
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
CanAttachNativeSetSlot
(
cx_
JSOp
(
*
pc_
)
obj
id
&
isTemporarilyUnoptimizable
&
propShape
)
)
{
return
isTemporarilyUnoptimizable
?
AttachDecision
:
:
TemporarilyUnoptimizable
:
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
&
&
cacheKind_
=
=
CacheKind
:
:
SetProp
&
&
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
{
writer
.
megamorphicStoreSlot
(
objId
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
rhsId
typeCheckInfo_
.
needsTypeBarrier
(
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicNativeSlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
maybeEmitIdGuard
(
id
)
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
{
writer
.
guardGroupForTypeBarrier
(
objId
nobj
-
>
group
(
)
)
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
if
(
IsPreliminaryObject
(
obj
)
)
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
}
else
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
objId
nobj
propShape
rhsId
)
;
trackAttached
(
"
NativeSlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
OperandId
SetPropIRGenerator
:
:
emitNumericGuard
(
ValOperandId
valId
Scalar
:
:
Type
type
)
{
switch
(
type
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
return
writer
.
guardToInt32ModUint32
(
valId
)
;
case
Scalar
:
:
Float32
:
case
Scalar
:
:
Float64
:
return
writer
.
guardIsNumber
(
valId
)
;
case
Scalar
:
:
Uint8Clamped
:
return
writer
.
guardToUint8Clamped
(
valId
)
;
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
return
writer
.
guardToBigInt
(
valId
)
;
case
Scalar
:
:
MaxTypedArrayViewType
:
case
Scalar
:
:
Int64
:
break
;
}
MOZ_CRASH
(
"
Unsupported
TypedArray
type
"
)
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachTypedObjectProperty
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
StructTypeDescr
*
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
{
return
AttachDecision
:
:
NoAction
;
}
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
fieldDescr
-
>
is
<
ReferenceTypeDescr
>
(
)
&
&
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
=
=
ReferenceType
:
:
TYPE_WASM_ANYREF
)
{
return
AttachDecision
:
:
NoAction
;
}
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
obj
-
>
group
(
)
id
)
;
if
(
fieldDescr
-
>
is
<
ScalarTypeDescr
>
(
)
)
{
Scalar
:
:
Type
type
=
fieldDescr
-
>
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
OperandId
rhsValId
=
emitNumericGuard
(
rhsId
type
)
;
writer
.
storeTypedObjectScalarProperty
(
objId
fieldOffset
layout
type
rhsValId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObject
"
)
;
return
AttachDecision
:
:
Attach
;
}
ReferenceType
type
=
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
switch
(
type
)
{
case
ReferenceType
:
:
TYPE_ANY
:
break
;
case
ReferenceType
:
:
TYPE_OBJECT
:
writer
.
guardIsObjectOrNull
(
rhsId
)
;
break
;
case
ReferenceType
:
:
TYPE_STRING
:
writer
.
guardType
(
rhsId
ValueType
:
:
String
)
;
break
;
case
ReferenceType
:
:
TYPE_WASM_ANYREF
:
MOZ_CRASH
(
)
;
}
writer
.
storeTypedObjectReferenceProperty
(
objId
fieldOffset
layout
type
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
TypedObject
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
SetPropIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
opcodeProperty
(
"
op
"
JSOp
(
*
pc_
)
)
;
sp
.
valueProperty
(
"
base
"
lhsVal_
)
;
sp
.
valueProperty
(
"
property
"
idVal_
)
;
sp
.
valueProperty
(
"
value
"
rhsVal_
)
;
}
#
endif
}
static
bool
IsCacheableSetPropCallNative
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChain
(
obj
holder
)
)
{
return
false
;
}
if
(
!
shape
-
>
hasSetterValue
(
)
)
{
return
false
;
}
if
(
!
shape
-
>
setterObject
(
)
|
|
!
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
)
{
return
false
;
}
JSFunction
&
setter
=
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
if
(
!
setter
.
isBuiltinNative
(
)
)
{
return
false
;
}
if
(
setter
.
isClassConstructor
(
)
)
{
return
false
;
}
if
(
setter
.
hasJitInfo
(
)
&
&
!
setter
.
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
{
return
true
;
}
return
!
IsWindow
(
obj
)
;
}
static
bool
IsCacheableSetPropCallScripted
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
*
isTemporarilyUnoptimizable
=
nullptr
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChain
(
obj
holder
)
)
{
return
false
;
}
if
(
IsWindow
(
obj
)
)
{
return
false
;
}
if
(
!
shape
-
>
hasSetterValue
(
)
)
{
return
false
;
}
if
(
!
shape
-
>
setterObject
(
)
|
|
!
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
)
{
return
false
;
}
JSFunction
&
setter
=
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
if
(
setter
.
isBuiltinNative
(
)
)
{
return
false
;
}
if
(
setter
.
isNativeWithJitEntry
(
)
)
{
return
true
;
}
if
(
!
setter
.
hasBytecode
(
)
)
{
if
(
isTemporarilyUnoptimizable
)
{
*
isTemporarilyUnoptimizable
=
true
;
}
return
false
;
}
if
(
setter
.
isClassConstructor
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
CanAttachSetter
(
JSContext
*
cx
jsbytecode
*
pc
HandleObject
obj
HandleId
id
MutableHandleObject
holder
MutableHandleShape
propShape
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc
)
)
)
;
PropertyResult
prop
;
if
(
!
LookupPropertyPure
(
cx
obj
id
holder
.
address
(
)
&
prop
)
)
{
return
false
;
}
if
(
prop
.
isNonNativeProperty
(
)
)
{
return
false
;
}
propShape
.
set
(
prop
.
maybeShape
(
)
)
;
if
(
!
IsCacheableSetPropCallScripted
(
obj
holder
propShape
isTemporarilyUnoptimizable
)
&
&
!
IsCacheableSetPropCallNative
(
obj
holder
propShape
)
)
{
return
false
;
}
return
true
;
}
static
void
EmitCallSetterNoGuards
(
JSContext
*
cx
CacheIRWriter
&
writer
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
ObjOperandId
objId
ValOperandId
rhsId
)
{
if
(
IsCacheableSetPropCallNative
(
obj
holder
shape
)
)
{
JSFunction
*
target
=
&
shape
-
>
setterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isBuiltinNative
(
)
)
;
writer
.
callNativeSetter
(
objId
target
rhsId
)
;
writer
.
returnFromIC
(
)
;
return
;
}
MOZ_ASSERT
(
IsCacheableSetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
setterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
hasJitEntry
(
)
)
;
bool
sameRealm
=
cx
-
>
realm
(
)
=
=
target
-
>
realm
(
)
;
writer
.
callScriptedSetter
(
objId
target
rhsId
sameRealm
)
;
writer
.
returnFromIC
(
)
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetter
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
RootedObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
CanAttachSetter
(
cx_
pc_
obj
id
&
holder
&
propShape
&
isTemporarilyUnoptimizable
)
)
{
return
isTemporarilyUnoptimizable
?
AttachDecision
:
:
TemporarilyUnoptimizable
:
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
|
|
IsWindow
(
obj
)
)
{
TestMatchingReceiver
(
writer
obj
objId
)
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
TestMatchingHolder
(
writer
holder
holderId
)
;
}
}
else
{
writer
.
guardHasGetterSetter
(
objId
propShape
)
;
}
EmitCallSetterNoGuards
(
cx_
writer
obj
holder
propShape
objId
rhsId
)
;
trackAttached
(
"
Setter
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetArrayLength
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
|
|
!
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
length
)
|
|
!
obj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
callSetArrayLength
(
objId
IsStrictSetPC
(
pc_
)
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
SetArrayLength
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetDenseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
containsDenseElement
(
index
)
|
|
nobj
-
>
getElementsHeader
(
)
-
>
isFrozen
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
IsPropertyInitOp
(
JSOp
(
*
pc_
)
)
&
&
!
nobj
-
>
isExtensible
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
{
writer
.
guardGroupForTypeBarrier
(
objId
nobj
-
>
group
(
)
)
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
writer
.
storeDenseElement
(
objId
indexId
rhsId
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
"
SetDenseElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
static
bool
CanAttachAddElement
(
NativeObject
*
obj
bool
isInit
)
{
do
{
if
(
obj
-
>
isIndexed
(
)
)
{
return
false
;
}
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
if
(
clasp
!
=
&
ArrayObject
:
:
class_
&
&
(
clasp
-
>
getAddProperty
(
)
|
|
clasp
-
>
getResolve
(
)
|
|
clasp
-
>
getOpsLookupProperty
(
)
|
|
clasp
-
>
getOpsSetProperty
(
)
)
)
{
return
false
;
}
if
(
isInit
)
{
break
;
}
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
{
break
;
}
if
(
!
proto
-
>
isNative
(
)
)
{
return
false
;
}
NativeObject
*
nproto
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nproto
-
>
isExtensible
(
)
&
&
nproto
-
>
getDenseInitializedLength
(
)
>
0
)
{
return
false
;
}
obj
=
nproto
;
}
while
(
true
)
;
return
true
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetDenseElementHole
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
isNative
(
)
|
|
rhsVal_
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
{
return
AttachDecision
:
:
NoAction
;
}
JSOp
op
=
JSOp
(
*
pc_
)
;
MOZ_ASSERT
(
IsPropertySetOp
(
op
)
|
|
IsPropertyInitOp
(
op
)
)
;
if
(
op
=
=
JSOp
:
:
InitHiddenElem
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
isExtensible
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
!
nobj
-
>
getElementsHeader
(
)
-
>
isFrozen
(
)
"
Extensible
objects
should
not
have
frozen
elements
"
)
;
uint32_t
initLength
=
nobj
-
>
getDenseInitializedLength
(
)
;
bool
isAdd
=
index
=
=
initLength
;
bool
isHoleInBounds
=
index
<
initLength
&
&
!
nobj
-
>
containsDenseElement
(
index
)
;
if
(
!
isAdd
&
&
!
isHoleInBounds
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
isAdd
&
&
nobj
-
>
is
<
ArrayObject
>
(
)
&
&
!
nobj
-
>
as
<
ArrayObject
>
(
)
.
lengthIsWritable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
nobj
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
CanAttachAddElement
(
nobj
IsPropertyInitOp
(
op
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
{
writer
.
guardGroupForTypeBarrier
(
objId
nobj
-
>
group
(
)
)
;
}
TestMatchingNativeReceiver
(
writer
nobj
objId
)
;
if
(
IsPropertySetOp
(
op
)
&
&
maybeHasExtraIndexedProps_
)
{
ShapeGuardProtoChain
(
writer
obj
objId
)
;
}
writer
.
storeDenseElementHole
(
objId
indexId
rhsId
isAdd
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
nobj
-
>
group
(
)
JSID_VOID
)
;
trackAttached
(
isAdd
?
"
AddDenseElement
"
:
"
StoreDenseElementHole
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachAddOrUpdateSparseElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
JSOp
op
=
JSOp
(
*
pc_
)
;
MOZ_ASSERT
(
IsPropertySetOp
(
op
)
|
|
IsPropertyInitOp
(
op
)
)
;
if
(
op
!
=
JSOp
:
:
SetElem
&
&
op
!
=
JSOp
:
:
StrictSetElem
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
if
(
!
nobj
-
>
isExtensible
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
index
>
INT_MAX
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
index
<
nobj
-
>
getDenseInitializedLength
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
nobj
-
>
is
<
ArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ArrayObject
*
aobj
=
&
nobj
-
>
as
<
ArrayObject
>
(
)
;
bool
isAdd
=
(
index
>
=
aobj
-
>
length
(
)
)
;
if
(
isAdd
&
&
!
aobj
-
>
lengthIsWritable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
(
aobj
-
>
staticPrototype
(
)
!
=
nullptr
)
&
&
ObjectMayHaveExtraIndexedProperties
(
aobj
-
>
staticPrototype
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardClass
(
objId
GuardClassKind
:
:
Array
)
;
writer
.
guardIndexGreaterThanDenseInitLength
(
objId
indexId
)
;
writer
.
guardIsExtensible
(
objId
)
;
writer
.
guardIndexIsNonNegative
(
indexId
)
;
GuardGroupProto
(
writer
obj
objId
)
;
ShapeGuardProtoChain
(
writer
obj
objId
)
;
writer
.
guardIndexIsValidUpdateOrAdd
(
objId
indexId
)
;
writer
.
callAddOrUpdateSparseElementHelper
(
objId
indexId
rhsId
op
=
=
JSOp
:
:
StrictSetElem
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
AddOrUpdateSparseElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetTypedElement
(
HandleObject
obj
ObjOperandId
objId
uint32_t
index
Int32OperandId
indexId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
IsPrimitiveArrayTypedObject
(
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
bool
handleOutOfBounds
=
false
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
handleOutOfBounds
=
(
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
;
}
else
{
if
(
index
>
=
obj
-
>
as
<
TypedObject
>
(
)
.
length
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
Scalar
:
:
Type
elementType
=
TypedThingElementType
(
obj
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
Scalar
:
:
isBigIntType
(
elementType
)
)
{
if
(
!
rhsVal_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
else
{
if
(
!
rhsVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
if
(
IsPrimitiveArrayTypedObject
(
obj
)
)
{
writer
.
guardGroupForLayout
(
objId
obj
-
>
group
(
)
)
;
}
else
{
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
}
OperandId
rhsValId
=
emitNumericGuard
(
rhsId
elementType
)
;
writer
.
storeTypedElement
(
objId
layout
elementType
indexId
rhsValId
handleOutOfBounds
)
;
writer
.
returnFromIC
(
)
;
if
(
handleOutOfBounds
)
{
attachedTypedArrayOOBStub_
=
true
;
}
trackAttached
(
handleOutOfBounds
?
"
SetTypedElementOOB
"
:
"
SetTypedElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachSetTypedArrayElementNonInt32Index
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
rhsId
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
idVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Scalar
:
:
Type
elementType
=
TypedThingElementType
(
obj
)
;
TypedThingLayout
layout
=
GetTypedThingLayout
(
obj
-
>
getClass
(
)
)
;
if
(
Scalar
:
:
isBigIntType
(
elementType
)
)
{
if
(
!
rhsVal_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
else
{
if
(
!
rhsVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
}
ValOperandId
keyId
=
setElemKeyValueId
(
)
;
Int32OperandId
indexId
=
writer
.
guardToTypedArrayIndex
(
keyId
)
;
writer
.
guardShapeForClass
(
objId
obj
-
>
as
<
TypedArrayObject
>
(
)
.
shape
(
)
)
;
OperandId
rhsValId
=
emitNumericGuard
(
rhsId
elementType
)
;
bool
handleOutOfBounds
=
true
;
writer
.
storeTypedElement
(
objId
layout
elementType
indexId
rhsValId
handleOutOfBounds
)
;
writer
.
returnFromIC
(
)
;
attachedTypedArrayOOBStub_
=
true
;
trackAttached
(
"
SetTypedElementNonInt32Index
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachGenericProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
bool
handleDOMProxies
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
writer
.
guardIsProxy
(
objId
)
;
if
(
!
handleDOMProxies
)
{
writer
.
guardNotDOMProxy
(
objId
)
;
}
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
|
|
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
{
maybeEmitIdGuard
(
id
)
;
writer
.
callProxySet
(
objId
id
rhsId
IsStrictSetPC
(
pc_
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
;
writer
.
callProxySetByValue
(
objId
setElemKeyValueId
(
)
rhsId
IsStrictSetPC
(
pc_
)
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GenericProxy
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachDOMProxyShadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
maybeEmitIdGuard
(
id
)
;
TestMatchingProxyReceiver
(
writer
&
obj
-
>
as
<
ProxyObject
>
(
)
objId
)
;
writer
.
callProxySet
(
objId
id
rhsId
IsStrictSetPC
(
pc_
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
DOMProxyShadowed
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachDOMProxyUnshadowed
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
proto
(
cx_
obj
-
>
staticPrototype
(
)
)
;
if
(
!
proto
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
holder
(
cx_
)
;
RootedShape
propShape
(
cx_
)
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
CanAttachSetter
(
cx_
pc_
proto
id
&
holder
&
propShape
&
isTemporarilyUnoptimizable
)
)
{
return
isTemporarilyUnoptimizable
?
AttachDecision
:
:
TemporarilyUnoptimizable
:
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
TestMatchingProxyReceiver
(
writer
&
obj
-
>
as
<
ProxyObject
>
(
)
objId
)
;
CheckDOMProxyExpandoDoesNotShadow
(
writer
obj
id
objId
)
;
GeneratePrototypeGuards
(
writer
obj
holder
objId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
holder
)
;
TestMatchingHolder
(
writer
holder
holderId
)
;
EmitCallSetterNoGuards
(
cx_
writer
proto
holder
propShape
objId
rhsId
)
;
trackAttached
(
"
DOMProxyUnshadowed
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachDOMProxyExpando
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedValue
expandoVal
(
cx_
GetProxyPrivate
(
obj
)
)
;
RootedObject
expandoObj
(
cx_
)
;
if
(
expandoVal
.
isObject
(
)
)
{
expandoObj
=
&
expandoVal
.
toObject
(
)
;
}
else
{
MOZ_ASSERT
(
!
expandoVal
.
isUndefined
(
)
"
How
did
a
missing
expando
manage
to
shadow
things
?
"
)
;
auto
expandoAndGeneration
=
static_cast
<
ExpandoAndGeneration
*
>
(
expandoVal
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
expandoAndGeneration
)
;
expandoObj
=
&
expandoAndGeneration
-
>
expando
.
toObject
(
)
;
}
bool
isTemporarilyUnoptimizable
=
false
;
RootedShape
propShape
(
cx_
)
;
if
(
CanAttachNativeSetSlot
(
cx_
JSOp
(
*
pc_
)
expandoObj
id
&
isTemporarilyUnoptimizable
&
propShape
)
)
{
maybeEmitIdGuard
(
id
)
;
ObjOperandId
expandoObjId
=
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
NativeObject
*
nativeExpandoObj
=
&
expandoObj
-
>
as
<
NativeObject
>
(
)
;
writer
.
guardGroupForTypeBarrier
(
expandoObjId
nativeExpandoObj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
nativeExpandoObj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
expandoObjId
nativeExpandoObj
propShape
rhsId
)
;
trackAttached
(
"
DOMProxyExpandoSlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
RootedObject
holder
(
cx_
)
;
if
(
CanAttachSetter
(
cx_
pc_
expandoObj
id
&
holder
&
propShape
&
isTemporarilyUnoptimizable
)
)
{
maybeEmitIdGuard
(
id
)
;
guardDOMProxyExpandoObjectAndShape
(
obj
objId
expandoVal
expandoObj
)
;
MOZ_ASSERT
(
holder
=
=
expandoObj
)
;
EmitCallSetterNoGuards
(
cx_
writer
expandoObj
expandoObj
propShape
objId
rhsId
)
;
trackAttached
(
"
DOMProxyExpandoSetter
"
)
;
return
AttachDecision
:
:
Attach
;
}
return
isTemporarilyUnoptimizable
?
AttachDecision
:
:
TemporarilyUnoptimizable
:
AttachDecision
:
:
NoAction
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
ProxyStubType
type
=
GetProxyStubType
(
cx_
obj
id
)
;
if
(
type
=
=
ProxyStubType
:
:
None
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
true
)
;
}
switch
(
type
)
{
case
ProxyStubType
:
:
None
:
break
;
case
ProxyStubType
:
:
DOMExpando
:
TRY_ATTACH
(
tryAttachDOMProxyExpando
(
obj
objId
id
rhsId
)
)
;
[
[
fallthrough
]
]
;
case
ProxyStubType
:
:
DOMShadowed
:
return
tryAttachDOMProxyShadowed
(
obj
objId
id
rhsId
)
;
case
ProxyStubType
:
:
DOMUnshadowed
:
TRY_ATTACH
(
tryAttachDOMProxyUnshadowed
(
obj
objId
id
rhsId
)
)
;
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
true
)
;
case
ProxyStubType
:
:
Generic
:
return
tryAttachGenericProxy
(
obj
objId
id
rhsId
false
)
;
}
MOZ_CRASH
(
"
Unexpected
ProxyStubType
"
)
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachProxyElement
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardIsProxy
(
objId
)
;
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
writer
.
callProxySetByValue
(
objId
setElemKeyValueId
(
)
rhsId
IsStrictSetPC
(
pc_
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ProxyElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachMegamorphicSetElement
(
HandleObject
obj
ObjOperandId
objId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsPropertySetOp
(
JSOp
(
*
pc_
)
)
)
;
if
(
mode_
!
=
ICState
:
:
Mode
:
:
Megamorphic
|
|
cacheKind_
!
=
CacheKind
:
:
SetElem
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
writer
.
megamorphicSetElement
(
objId
setElemKeyValueId
(
)
rhsId
IsStrictSetPC
(
pc_
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
MegamorphicSetElement
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachWindowProxy
(
HandleObject
obj
ObjOperandId
objId
HandleId
id
ValOperandId
rhsId
)
{
if
(
!
IsWindowProxyForScriptGlobal
(
script_
obj
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
AttachDecision
:
:
NoAction
;
}
Handle
<
GlobalObject
*
>
windowObj
=
cx_
-
>
global
(
)
;
RootedShape
propShape
(
cx_
)
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
CanAttachNativeSetSlot
(
cx_
JSOp
(
*
pc_
)
windowObj
id
&
isTemporarilyUnoptimizable
&
propShape
)
)
{
return
isTemporarilyUnoptimizable
?
AttachDecision
:
:
TemporarilyUnoptimizable
:
AttachDecision
:
:
NoAction
;
}
maybeEmitIdGuard
(
id
)
;
ObjOperandId
windowObjId
=
GuardAndLoadWindowProxyWindow
(
writer
objId
windowObj
)
;
writer
.
guardShape
(
windowObjId
windowObj
-
>
lastProperty
(
)
)
;
writer
.
guardGroupForTypeBarrier
(
windowObjId
windowObj
-
>
group
(
)
)
;
typeCheckInfo_
.
set
(
windowObj
-
>
group
(
)
id
)
;
EmitStoreSlotAndReturn
(
writer
windowObjId
windowObj
propShape
rhsId
)
;
trackAttached
(
"
WindowProxySlot
"
)
;
return
AttachDecision
:
:
Attach
;
}
bool
SetPropIRGenerator
:
:
canAttachAddSlotStub
(
HandleObject
obj
HandleId
id
)
{
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
JSID_IS_ATOM
(
id
cx_
-
>
names
(
)
.
prototype
)
)
{
MOZ_ASSERT
(
ClassMayResolveId
(
cx_
-
>
names
(
)
obj
-
>
getClass
(
)
id
obj
)
)
;
JSFunction
*
fun
=
&
obj
-
>
as
<
JSFunction
>
(
)
;
if
(
!
obj
-
>
group
(
)
-
>
maybeInterpretedFunction
(
)
|
|
!
fun
-
>
needsPrototypeProperty
(
)
)
{
return
false
;
}
if
(
fun
-
>
lookupPure
(
id
)
)
{
return
false
;
}
}
else
{
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx_
obj
id
&
prop
)
)
{
return
false
;
}
if
(
prop
)
{
return
false
;
}
}
if
(
!
obj
-
>
nonProxyIsExtensible
(
)
)
{
return
false
;
}
DebugOnly
<
uint32_t
>
index
;
MOZ_ASSERT_IF
(
obj
-
>
is
<
ArrayObject
>
(
)
!
IdIsIndex
(
id
&
index
)
)
;
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
&
&
obj
-
>
getClass
(
)
-
>
getAddProperty
(
)
)
{
return
false
;
}
for
(
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
proto
;
proto
=
proto
-
>
staticPrototype
(
)
)
{
if
(
!
proto
-
>
isNative
(
)
)
{
return
false
;
}
Shape
*
protoShape
=
proto
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx_
id
)
;
if
(
protoShape
&
&
!
protoShape
-
>
isDataDescriptor
(
)
)
{
return
false
;
}
if
(
ClassMayResolveId
(
cx_
-
>
names
(
)
proto
-
>
getClass
(
)
id
proto
)
&
&
!
proto
-
>
is
<
JSFunction
>
(
)
)
{
return
false
;
}
}
return
true
;
}
AttachDecision
SetPropIRGenerator
:
:
tryAttachAddSlotStub
(
HandleObjectGroup
oldGroup
HandleShape
oldShape
)
{
ValOperandId
objValId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsValId
;
if
(
cacheKind_
=
=
CacheKind
:
:
SetProp
)
{
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
1
)
)
;
}
else
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
SetElem
)
;
MOZ_ASSERT
(
setElemKeyValueId
(
)
.
id
(
)
=
=
1
)
;
writer
.
setInputOperandId
(
1
)
;
rhsValId
=
ValOperandId
(
writer
.
setInputOperandId
(
2
)
)
;
}
RootedId
id
(
cx_
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx_
idVal_
&
id
&
nameOrSymbol
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
!
lhsVal_
.
isObject
(
)
|
|
!
nameOrSymbol
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
obj
(
cx_
&
lhsVal_
.
toObject
(
)
)
;
PropertyResult
prop
;
if
(
!
LookupOwnPropertyPure
(
cx_
obj
id
&
prop
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
prop
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
obj
-
>
isNative
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Shape
*
propShape
=
prop
.
shape
(
)
;
NativeObject
*
holder
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
propShape
)
;
MOZ_RELEASE_ASSERT
(
holder
-
>
lastProperty
(
)
=
=
propShape
)
;
if
(
propShape
-
>
previous
(
)
!
=
oldShape
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
propShape
-
>
inDictionary
(
)
|
|
!
propShape
-
>
isDataProperty
(
)
|
|
!
propShape
-
>
writable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ObjOperandId
objId
=
writer
.
guardToObject
(
objValId
)
;
maybeEmitIdGuard
(
id
)
;
writer
.
guardGroup
(
objId
oldGroup
)
;
AutoSweepObjectGroup
sweep
(
oldGroup
)
;
if
(
oldGroup
-
>
newScript
(
sweep
)
&
&
!
oldGroup
-
>
newScript
(
sweep
)
-
>
analyzed
(
)
)
{
writer
.
guardGroupHasUnanalyzedNewScript
(
oldGroup
)
;
MOZ_ASSERT
(
IsPreliminaryObject
(
obj
)
)
;
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
NotePreliminary
;
}
else
{
preliminaryObjectAction_
=
PreliminaryObjectAction
:
:
Unlink
;
}
ObjOperandId
holderId
=
objId
;
writer
.
guardShape
(
holderId
oldShape
)
;
ShapeGuardProtoChain
(
writer
obj
objId
)
;
ObjectGroup
*
newGroup
=
obj
-
>
group
(
)
;
bool
changeGroup
=
oldGroup
!
=
newGroup
;
MOZ_ASSERT_IF
(
changeGroup
obj
-
>
is
<
PlainObject
>
(
)
)
;
if
(
holder
-
>
isFixedSlot
(
propShape
-
>
slot
(
)
)
)
{
size_t
offset
=
NativeObject
:
:
getFixedSlotOffset
(
propShape
-
>
slot
(
)
)
;
writer
.
addAndStoreFixedSlot
(
holderId
offset
rhsValId
changeGroup
newGroup
propShape
)
;
trackAttached
(
"
AddSlot
"
)
;
}
else
{
size_t
offset
=
holder
-
>
dynamicSlotIndex
(
propShape
-
>
slot
(
)
)
*
sizeof
(
Value
)
;
uint32_t
numOldSlots
=
NativeObject
:
:
dynamicSlotsCount
(
oldShape
)
;
uint32_t
numNewSlots
=
NativeObject
:
:
dynamicSlotsCount
(
propShape
)
;
if
(
numOldSlots
=
=
numNewSlots
)
{
writer
.
addAndStoreDynamicSlot
(
holderId
offset
rhsValId
changeGroup
newGroup
propShape
)
;
trackAttached
(
"
AddSlot
"
)
;
}
else
{
MOZ_ASSERT
(
numNewSlots
>
numOldSlots
)
;
writer
.
allocateAndStoreDynamicSlot
(
holderId
offset
rhsValId
changeGroup
newGroup
propShape
numNewSlots
)
;
trackAttached
(
"
AllocateSlot
"
)
;
}
}
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
oldGroup
id
)
;
return
AttachDecision
:
:
Attach
;
}
InstanceOfIRGenerator
:
:
InstanceOfIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
lhs
HandleObject
rhs
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
InstanceOf
mode
)
lhsVal_
(
lhs
)
rhsObj_
(
rhs
)
{
}
AttachDecision
InstanceOfIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
InstanceOf
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
if
(
!
rhsObj_
-
>
is
<
JSFunction
>
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
HandleFunction
fun
=
rhsObj_
.
as
<
JSFunction
>
(
)
;
if
(
fun
-
>
isBoundFunction
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
PropertyResult
hasInstanceProp
;
JSObject
*
hasInstanceHolder
=
nullptr
;
jsid
hasInstanceID
=
SYMBOL_TO_JSID
(
cx_
-
>
wellKnownSymbols
(
)
.
hasInstance
)
;
if
(
!
LookupPropertyPure
(
cx_
fun
hasInstanceID
&
hasInstanceHolder
&
hasInstanceProp
)
|
|
!
hasInstanceProp
.
isFound
(
)
|
|
hasInstanceProp
.
isNonNativeProperty
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
Value
funProto
=
cx_
-
>
global
(
)
-
>
getPrototype
(
JSProto_Function
)
;
if
(
hasInstanceHolder
!
=
&
funProto
.
toObject
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
hasInstanceProp
.
shape
(
)
-
>
isDataProperty
(
)
)
;
MOZ_ASSERT
(
!
hasInstanceProp
.
shape
(
)
-
>
configurable
(
)
)
;
MOZ_ASSERT
(
!
hasInstanceProp
.
shape
(
)
-
>
writable
(
)
)
;
if
(
!
IsCacheableProtoChain
(
fun
hasInstanceHolder
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
Shape
*
shape
=
fun
-
>
lookupPure
(
cx_
-
>
names
(
)
.
prototype
)
;
if
(
!
shape
|
|
!
shape
-
>
isDataProperty
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
uint32_t
slot
=
shape
-
>
slot
(
)
;
MOZ_ASSERT
(
fun
-
>
numFixedSlots
(
)
=
=
0
"
Stub
code
relies
on
this
"
)
;
if
(
!
fun
-
>
getSlot
(
slot
)
.
isObject
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
JSObject
*
prototypeObject
=
&
fun
-
>
getSlot
(
slot
)
.
toObject
(
)
;
ValOperandId
lhs
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhs
(
writer
.
setInputOperandId
(
1
)
)
;
ObjOperandId
rhsId
=
writer
.
guardToObject
(
rhs
)
;
writer
.
guardShape
(
rhsId
fun
-
>
lastProperty
(
)
)
;
if
(
hasInstanceHolder
!
=
fun
)
{
GeneratePrototypeGuards
(
writer
fun
hasInstanceHolder
rhsId
)
;
ObjOperandId
holderId
=
writer
.
loadObject
(
hasInstanceHolder
)
;
TestMatchingHolder
(
writer
hasInstanceHolder
holderId
)
;
}
ObjOperandId
protoId
=
writer
.
loadObject
(
prototypeObject
)
;
writer
.
guardFunctionPrototype
(
rhsId
protoId
slot
)
;
writer
.
loadInstanceOfObjectResult
(
lhs
protoId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
InstanceOf
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
InstanceOfIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
lhs
"
lhsVal_
)
;
sp
.
valueProperty
(
"
rhs
"
ObjectValue
(
*
rhsObj_
)
)
;
}
#
else
mozilla
:
:
Unused
<
<
lhsVal_
;
#
endif
}
TypeOfIRGenerator
:
:
TypeOfIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
value
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
TypeOf
mode
)
val_
(
value
)
{
}
void
TypeOfIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
val
"
val_
)
;
}
#
endif
}
AttachDecision
TypeOfIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
TypeOf
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
TRY_ATTACH
(
tryAttachPrimitive
(
valId
)
)
;
TRY_ATTACH
(
tryAttachObject
(
valId
)
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
attach
TypeOf
"
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
TypeOfIRGenerator
:
:
tryAttachPrimitive
(
ValOperandId
valId
)
{
if
(
!
val_
.
isPrimitive
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
val_
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
valId
)
;
}
else
{
writer
.
guardType
(
valId
val_
.
type
(
)
)
;
}
writer
.
loadStringResult
(
TypeName
(
js
:
:
TypeOfValue
(
val_
)
cx_
-
>
names
(
)
)
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Primitive
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
TypeOfIRGenerator
:
:
tryAttachObject
(
ValOperandId
valId
)
{
if
(
!
val_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
writer
.
loadTypeOfObjectResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Object
"
)
;
return
AttachDecision
:
:
Attach
;
}
GetIteratorIRGenerator
:
:
GetIteratorIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
value
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
GetIterator
mode
)
val_
(
value
)
{
}
AttachDecision
GetIteratorIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
GetIterator
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
if
(
mode_
=
=
ICState
:
:
Mode
:
:
Megamorphic
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
if
(
!
val_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
obj
(
cx_
&
val_
.
toObject
(
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
TRY_ATTACH
(
tryAttachNativeIterator
(
objId
obj
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
GetIteratorIRGenerator
:
:
tryAttachNativeIterator
(
ObjOperandId
objId
HandleObject
obj
)
{
MOZ_ASSERT
(
JSOp
(
*
pc_
)
=
=
JSOp
:
:
Iter
)
;
PropertyIteratorObject
*
iterobj
=
LookupInIteratorCache
(
cx_
obj
)
;
if
(
!
iterobj
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
obj
-
>
isNative
(
)
)
;
TestMatchingNativeReceiver
(
writer
&
obj
-
>
as
<
NativeObject
>
(
)
objId
)
;
writer
.
guardNoDenseElements
(
objId
)
;
GeneratePrototypeHoleGuards
(
writer
obj
objId
false
)
;
ObjOperandId
iterId
=
writer
.
guardAndGetIterator
(
objId
iterobj
&
ObjectRealm
:
:
get
(
obj
)
.
enumerators
)
;
writer
.
loadObjectResult
(
iterId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GetIterator
"
)
;
return
AttachDecision
:
:
Attach
;
}
void
GetIteratorIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
val
"
val_
)
;
}
#
endif
}
CallIRGenerator
:
:
CallIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
JSOp
op
ICState
:
:
Mode
mode
uint32_t
argc
HandleValue
callee
HandleValue
thisval
HandleValue
newTarget
HandleValueArray
args
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
Call
mode
)
op_
(
op
)
argc_
(
argc
)
callee_
(
callee
)
thisval_
(
thisval
)
newTarget_
(
newTarget
)
args_
(
args
)
typeCheckInfo_
(
cx
true
)
cacheIRStubKind_
(
BaselineCacheIRStubKind
:
:
Regular
)
{
}
AttachDecision
CallIRGenerator
:
:
tryAttachArrayPush
(
)
{
if
(
argc_
!
=
1
|
|
!
thisval_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
thisobj
(
cx_
&
thisval_
.
toObject
(
)
)
;
if
(
!
thisobj
-
>
is
<
ArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
thisobj
-
>
hasLazyGroup
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedArrayObject
thisarray
(
cx_
&
thisobj
-
>
as
<
ArrayObject
>
(
)
)
;
if
(
!
CanAttachAddElement
(
thisarray
false
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
thisarray
-
>
lengthIsWritable
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
thisarray
-
>
isExtensible
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
!
thisarray
-
>
getElementsHeader
(
)
-
>
isFrozen
(
)
"
Extensible
arrays
should
not
have
frozen
elements
"
)
;
MOZ_ASSERT
(
thisarray
-
>
lengthIsWritable
(
)
)
;
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
writer
.
guardSpecificInt32Immediate
(
argcId
1
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
Callee
argc_
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
writer
.
guardSpecificNativeFunction
(
calleeObjId
js
:
:
array_push
)
;
ValOperandId
thisValId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
This
argc_
)
;
ObjOperandId
thisObjId
=
writer
.
guardToObject
(
thisValId
)
;
MOZ_ASSERT_IF
(
IsTypeInferenceEnabled
(
)
typeCheckInfo_
.
needsTypeBarrier
(
)
)
;
if
(
typeCheckInfo_
.
needsTypeBarrier
(
)
)
{
writer
.
guardGroupForTypeBarrier
(
thisObjId
thisobj
-
>
group
(
)
)
;
}
TestMatchingNativeReceiver
(
writer
thisarray
thisObjId
)
;
ShapeGuardProtoChain
(
writer
thisobj
thisObjId
)
;
ValOperandId
argId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
Arg0
argc_
)
;
writer
.
arrayPush
(
thisObjId
argId
)
;
writer
.
returnFromIC
(
)
;
typeCheckInfo_
.
set
(
thisobj
-
>
group
(
)
JSID_VOID
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Updated
;
trackAttached
(
"
ArrayPush
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachArrayJoin
(
)
{
if
(
argc_
>
1
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
thisval_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
thisobj
(
cx_
&
thisval_
.
toObject
(
)
)
;
if
(
!
thisobj
-
>
is
<
ArrayObject
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedArrayObject
thisarray
(
cx_
&
thisobj
-
>
as
<
ArrayObject
>
(
)
)
;
if
(
thisarray
-
>
length
(
)
>
1
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
thisarray
-
>
getDenseInitializedLength
(
)
!
=
thisarray
-
>
length
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
thisarray
-
>
length
(
)
=
=
1
&
&
!
thisarray
-
>
getDenseElement
(
0
)
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
Callee
argc_
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
writer
.
guardSpecificNativeFunction
(
calleeObjId
js
:
:
array_join
)
;
if
(
argc_
=
=
1
)
{
ValOperandId
argValId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
Arg0
argc_
)
;
writer
.
guardToString
(
argValId
)
;
}
ValOperandId
thisValId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
This
argc_
)
;
ObjOperandId
thisObjId
=
writer
.
guardToObject
(
thisValId
)
;
writer
.
guardClass
(
thisObjId
GuardClassKind
:
:
Array
)
;
writer
.
arrayJoinResult
(
thisObjId
)
;
writer
.
returnFromIC
(
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Regular
;
trackAttached
(
"
ArrayJoin
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachIsSuspendedGenerator
(
)
{
MOZ_ASSERT
(
argc_
=
=
1
)
;
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
valId
=
writer
.
loadArgumentFixedSlot
(
ArgumentKind
:
:
Arg0
argc_
)
;
writer
.
callIsSuspendedGeneratorResult
(
valId
)
;
writer
.
returnFromIC
(
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Regular
;
trackAttached
(
"
IsSuspendedGenerator
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachFunCall
(
HandleFunction
calleeFunc
)
{
MOZ_ASSERT
(
calleeFunc
-
>
isNative
(
)
)
;
if
(
calleeFunc
-
>
native
(
)
!
=
fun_call
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
thisval_
.
isObject
(
)
|
|
!
thisval_
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedFunction
target
(
cx_
&
thisval_
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
bool
isScripted
=
target
-
>
isInterpreted
(
)
|
|
target
-
>
isNativeWithJitEntry
(
)
;
MOZ_ASSERT_IF
(
!
isScripted
target
-
>
isNative
(
)
)
;
if
(
target
-
>
isClassConstructor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
Callee
argcId
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
writer
.
guardSpecificNativeFunction
(
calleeObjId
fun_call
)
;
ValOperandId
thisValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
This
argcId
)
;
ObjOperandId
thisObjId
=
writer
.
guardToObject
(
thisValId
)
;
writer
.
guardClass
(
thisObjId
GuardClassKind
:
:
JSFunction
)
;
writer
.
guardNotClassConstructor
(
thisObjId
)
;
CallFlags
targetFlags
(
CallFlags
:
:
FunCall
)
;
if
(
isScripted
)
{
writer
.
guardFunctionHasJitEntry
(
thisObjId
false
)
;
writer
.
callScriptedFunction
(
thisObjId
argcId
targetFlags
)
;
}
else
{
writer
.
guardFunctionIsNative
(
thisObjId
)
;
writer
.
callAnyNativeFunction
(
thisObjId
argcId
targetFlags
)
;
}
writer
.
typeMonitorResult
(
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Monitored
;
if
(
isScripted
)
{
trackAttached
(
"
Scripted
fun_call
"
)
;
}
else
{
trackAttached
(
"
Native
fun_call
"
)
;
}
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachFunApply
(
HandleFunction
calleeFunc
)
{
MOZ_ASSERT
(
calleeFunc
-
>
isNative
(
)
)
;
if
(
calleeFunc
-
>
native
(
)
!
=
fun_apply
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
argc_
!
=
2
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
thisval_
.
isObject
(
)
|
|
!
thisval_
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedFunction
target
(
cx_
&
thisval_
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
bool
isScripted
=
target
-
>
isInterpreted
(
)
|
|
target
-
>
isNativeWithJitEntry
(
)
;
MOZ_ASSERT_IF
(
!
isScripted
target
-
>
isNative
(
)
)
;
if
(
target
-
>
isClassConstructor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
CallFlags
:
:
ArgFormat
format
=
CallFlags
:
:
Standard
;
if
(
args_
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
!
script_
-
>
needsArgsObj
(
)
)
{
format
=
CallFlags
:
:
FunApplyArgs
;
}
else
if
(
args_
[
1
]
.
isObject
(
)
&
&
args_
[
1
]
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
&
&
args_
[
1
]
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
.
length
(
)
<
=
CacheIRCompiler
:
:
MAX_ARGS_ARRAY_LENGTH
)
{
format
=
CallFlags
:
:
FunApplyArray
;
}
else
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
Callee
argcId
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
writer
.
guardSpecificNativeFunction
(
calleeObjId
fun_apply
)
;
ValOperandId
thisValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
This
argcId
)
;
ObjOperandId
thisObjId
=
writer
.
guardToObject
(
thisValId
)
;
writer
.
guardClass
(
thisObjId
GuardClassKind
:
:
JSFunction
)
;
writer
.
guardNotClassConstructor
(
thisObjId
)
;
CallFlags
targetFlags
(
format
)
;
writer
.
guardFunApply
(
argcId
targetFlags
)
;
if
(
isScripted
)
{
writer
.
guardFunctionHasJitEntry
(
thisObjId
false
)
;
writer
.
callScriptedFunction
(
thisObjId
argcId
targetFlags
)
;
}
else
{
writer
.
guardFunctionIsNative
(
thisObjId
)
;
writer
.
callAnyNativeFunction
(
thisObjId
argcId
targetFlags
)
;
}
writer
.
typeMonitorResult
(
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Monitored
;
if
(
isScripted
)
{
trackAttached
(
"
Scripted
fun_apply
"
)
;
}
else
{
trackAttached
(
"
Native
fun_apply
"
)
;
}
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachSpecialCaseCallNative
(
HandleFunction
callee
)
{
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
op_
!
=
JSOp
:
:
Call
&
&
op_
!
=
JSOp
:
:
CallIgnoresRv
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
callee
-
>
native
(
)
=
=
js
:
:
array_push
)
{
return
tryAttachArrayPush
(
)
;
}
if
(
callee
-
>
native
(
)
=
=
js
:
:
array_join
)
{
return
tryAttachArrayJoin
(
)
;
}
if
(
callee
-
>
native
(
)
=
=
intrinsic_IsSuspendedGenerator
)
{
return
tryAttachIsSuspendedGenerator
(
)
;
}
return
AttachDecision
:
:
NoAction
;
}
bool
CallIRGenerator
:
:
getTemplateObjectForScripted
(
HandleFunction
calleeFunc
MutableHandleObject
result
bool
*
skipAttach
)
{
MOZ_ASSERT
(
!
*
skipAttach
)
;
if
(
calleeFunc
-
>
constructorNeedsUninitializedThis
(
)
)
{
return
true
;
}
bool
isSuper
=
op_
=
=
JSOp
:
:
SuperCall
|
|
op_
=
=
JSOp
:
:
SpreadSuperCall
;
if
(
isSuper
)
{
return
true
;
}
RootedValue
protov
(
cx_
)
;
RootedObject
newTarget
(
cx_
&
newTarget_
.
toObject
(
)
)
;
if
(
!
GetPropertyPure
(
cx_
newTarget
NameToId
(
cx_
-
>
names
(
)
.
prototype
)
protov
.
address
(
)
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
*
skipAttach
=
true
;
return
true
;
}
if
(
protov
.
isObject
(
)
)
{
AutoRealm
ar
(
cx_
calleeFunc
)
;
TaggedProto
proto
(
&
protov
.
toObject
(
)
)
;
ObjectGroup
*
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx_
&
PlainObject
:
:
class_
proto
newTarget
)
;
if
(
!
group
)
{
return
false
;
}
AutoSweepObjectGroup
sweep
(
group
)
;
if
(
group
-
>
newScript
(
sweep
)
&
&
!
group
-
>
newScript
(
sweep
)
-
>
analyzed
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
*
skipAttach
=
true
;
return
true
;
}
}
JSObject
*
thisObject
=
CreateThisForFunction
(
cx_
calleeFunc
newTarget
TenuredObject
)
;
if
(
!
thisObject
)
{
return
false
;
}
MOZ_ASSERT
(
thisObject
-
>
nonCCWRealm
(
)
=
=
calleeFunc
-
>
realm
(
)
)
;
if
(
thisObject
-
>
is
<
PlainObject
>
(
)
)
{
result
.
set
(
thisObject
)
;
}
return
true
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachCallScripted
(
HandleFunction
calleeFunc
)
{
if
(
op_
=
=
JSOp
:
:
FunApply
)
{
return
AttachDecision
:
:
NoAction
;
}
bool
isSpecialized
=
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
;
bool
isConstructing
=
IsConstructPC
(
pc_
)
;
bool
isSpread
=
IsSpreadPC
(
pc_
)
;
bool
isSameRealm
=
isSpecialized
&
&
cx_
-
>
realm
(
)
=
=
calleeFunc
-
>
realm
(
)
;
CallFlags
flags
(
isConstructing
isSpread
isSameRealm
)
;
if
(
isConstructing
&
&
!
calleeFunc
-
>
isConstructor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
isConstructing
&
&
calleeFunc
-
>
isClassConstructor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
calleeFunc
-
>
hasJitEntry
(
)
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
if
(
isConstructing
&
&
!
calleeFunc
-
>
hasJitScript
(
)
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
if
(
IsIonEnabled
(
cx_
)
)
{
EnsureTrackPropertyTypes
(
cx_
calleeFunc
NameToId
(
cx_
-
>
names
(
)
.
prototype
)
)
;
}
RootedObject
templateObj
(
cx_
)
;
bool
skipAttach
=
false
;
if
(
isConstructing
&
&
isSpecialized
&
&
!
getTemplateObjectForScripted
(
calleeFunc
&
templateObj
&
skipAttach
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
skipAttach
)
{
return
AttachDecision
:
:
TemporarilyUnoptimizable
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
Callee
argcId
flags
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
if
(
isSpecialized
)
{
writer
.
guardSpecificFunction
(
calleeObjId
calleeFunc
)
;
}
else
{
writer
.
guardClass
(
calleeObjId
GuardClassKind
:
:
JSFunction
)
;
writer
.
guardFunctionHasJitEntry
(
calleeObjId
isConstructing
)
;
if
(
isConstructing
)
{
writer
.
guardFunctionIsConstructor
(
calleeObjId
)
;
}
else
{
writer
.
guardNotClassConstructor
(
calleeObjId
)
;
}
}
writer
.
callScriptedFunction
(
calleeObjId
argcId
flags
)
;
writer
.
typeMonitorResult
(
)
;
if
(
templateObj
)
{
MOZ_ASSERT
(
isSpecialized
)
;
writer
.
metaScriptedTemplateObject
(
calleeFunc
templateObj
)
;
}
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Monitored
;
if
(
isSpecialized
)
{
trackAttached
(
"
Call
scripted
func
"
)
;
}
else
{
trackAttached
(
"
Call
any
scripted
func
"
)
;
}
return
AttachDecision
:
:
Attach
;
}
bool
CallIRGenerator
:
:
getTemplateObjectForNative
(
HandleFunction
calleeFunc
MutableHandleObject
res
)
{
AutoRealm
ar
(
cx_
calleeFunc
)
;
bool
isSuper
=
op_
=
=
JSOp
:
:
SuperCall
|
|
op_
=
=
JSOp
:
:
SpreadSuperCall
;
if
(
isSuper
)
{
return
true
;
}
if
(
!
calleeFunc
-
>
hasJitInfo
(
)
|
|
calleeFunc
-
>
jitInfo
(
)
-
>
type
(
)
!
=
JSJitInfo
:
:
InlinableNative
)
{
return
true
;
}
switch
(
calleeFunc
-
>
jitInfo
(
)
-
>
inlinableNative
)
{
case
InlinableNative
:
:
Array
:
{
size_t
count
=
0
;
if
(
args_
.
length
(
)
!
=
1
)
{
count
=
args_
.
length
(
)
;
}
else
if
(
args_
.
length
(
)
=
=
1
&
&
args_
[
0
]
.
isInt32
(
)
&
&
args_
[
0
]
.
toInt32
(
)
>
=
0
)
{
count
=
args_
[
0
]
.
toInt32
(
)
;
}
if
(
count
>
ArrayObject
:
:
EagerAllocationMaxLength
)
{
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx_
count
TenuredObject
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
ArraySlice
:
{
if
(
!
thisval_
.
isObject
(
)
)
{
return
true
;
}
RootedObject
obj
(
cx_
&
thisval_
.
toObject
(
)
)
;
if
(
obj
-
>
isSingleton
(
)
)
{
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayTryReuseGroup
(
cx_
obj
0
TenuredObject
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
String
:
{
RootedString
emptyString
(
cx_
cx_
-
>
runtime
(
)
-
>
emptyString
)
;
res
.
set
(
StringObject
:
:
create
(
cx_
emptyString
nullptr
TenuredObject
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
ObjectCreate
:
{
if
(
args_
.
length
(
)
!
=
1
|
|
!
args_
[
0
]
.
isObjectOrNull
(
)
)
{
return
true
;
}
RootedObject
proto
(
cx_
args_
[
0
]
.
toObjectOrNull
(
)
)
;
res
.
set
(
ObjectCreateImpl
(
cx_
proto
TenuredObject
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
IntrinsicNewArrayIterator
:
{
res
.
set
(
NewArrayIteratorTemplate
(
cx_
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
IntrinsicNewStringIterator
:
{
res
.
set
(
NewStringIteratorTemplate
(
cx_
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
IntrinsicNewRegExpStringIterator
:
{
res
.
set
(
NewRegExpStringIteratorTemplate
(
cx_
)
)
;
return
!
!
res
;
}
case
InlinableNative
:
:
TypedArrayConstructor
:
{
return
TypedArrayObject
:
:
GetTemplateObjectForNative
(
cx_
calleeFunc
-
>
native
(
)
args_
res
)
;
}
default
:
return
true
;
}
}
AttachDecision
CallIRGenerator
:
:
tryAttachCallNative
(
HandleFunction
calleeFunc
)
{
MOZ_ASSERT
(
calleeFunc
-
>
isNative
(
)
)
;
bool
isSpecialized
=
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
;
bool
isSpread
=
IsSpreadPC
(
pc_
)
;
bool
isSameRealm
=
isSpecialized
&
&
cx_
-
>
realm
(
)
=
=
calleeFunc
-
>
realm
(
)
;
bool
isConstructing
=
IsConstructPC
(
pc_
)
;
CallFlags
flags
(
isConstructing
isSpread
isSameRealm
)
;
if
(
isConstructing
&
&
!
calleeFunc
-
>
isConstructor
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
isSpecialized
)
{
TRY_ATTACH
(
tryAttachSpecialCaseCallNative
(
calleeFunc
)
)
;
}
RootedObject
templateObj
(
cx_
)
;
if
(
isSpecialized
&
&
!
getTemplateObjectForNative
(
calleeFunc
&
templateObj
)
)
{
cx_
-
>
clearPendingException
(
)
;
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
Callee
argcId
flags
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
if
(
isSpecialized
)
{
writer
.
guardSpecificFunction
(
calleeObjId
calleeFunc
)
;
writer
.
callNativeFunction
(
calleeObjId
argcId
op_
calleeFunc
flags
)
;
}
else
{
writer
.
guardClass
(
calleeObjId
GuardClassKind
:
:
JSFunction
)
;
writer
.
guardFunctionIsNative
(
calleeObjId
)
;
if
(
isConstructing
)
{
writer
.
guardFunctionIsConstructor
(
calleeObjId
)
;
}
else
{
writer
.
guardNotClassConstructor
(
calleeObjId
)
;
}
writer
.
callAnyNativeFunction
(
calleeObjId
argcId
flags
)
;
}
writer
.
typeMonitorResult
(
)
;
if
(
templateObj
)
{
MOZ_ASSERT
(
isSpecialized
)
;
writer
.
metaNativeTemplateObject
(
calleeFunc
templateObj
)
;
}
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Monitored
;
if
(
isSpecialized
)
{
trackAttached
(
"
Call
native
func
"
)
;
}
else
{
trackAttached
(
"
Call
any
native
func
"
)
;
}
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachCallHook
(
HandleObject
calleeObj
)
{
if
(
op_
=
=
JSOp
:
:
FunApply
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
mode_
!
=
ICState
:
:
Mode
:
:
Specialized
)
{
return
AttachDecision
:
:
NoAction
;
}
bool
isSpread
=
IsSpreadPC
(
pc_
)
;
bool
isConstructing
=
IsConstructPC
(
pc_
)
;
CallFlags
flags
(
isConstructing
isSpread
)
;
JSNative
hook
=
isConstructing
?
calleeObj
-
>
constructHook
(
)
:
calleeObj
-
>
callHook
(
)
;
if
(
!
hook
)
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
argcId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
calleeValId
=
writer
.
loadArgumentDynamicSlot
(
ArgumentKind
:
:
Callee
argcId
flags
)
;
ObjOperandId
calleeObjId
=
writer
.
guardToObject
(
calleeValId
)
;
writer
.
guardAnyClass
(
calleeObjId
calleeObj
-
>
getClass
(
)
)
;
writer
.
callClassHook
(
calleeObjId
argcId
hook
flags
)
;
writer
.
typeMonitorResult
(
)
;
cacheIRStubKind_
=
BaselineCacheIRStubKind
:
:
Monitored
;
trackAttached
(
"
Call
native
func
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
switch
(
op_
)
{
case
JSOp
:
:
Call
:
case
JSOp
:
:
CallIgnoresRv
:
case
JSOp
:
:
CallIter
:
case
JSOp
:
:
SpreadCall
:
case
JSOp
:
:
New
:
case
JSOp
:
:
SpreadNew
:
case
JSOp
:
:
SuperCall
:
case
JSOp
:
:
SpreadSuperCall
:
case
JSOp
:
:
FunCall
:
case
JSOp
:
:
FunApply
:
break
;
default
:
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
mode_
!
=
ICState
:
:
Mode
:
:
Generic
)
;
if
(
!
callee_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
RootedObject
calleeObj
(
cx_
&
callee_
.
toObject
(
)
)
;
if
(
!
calleeObj
-
>
is
<
JSFunction
>
(
)
)
{
return
tryAttachCallHook
(
calleeObj
)
;
}
RootedFunction
calleeFunc
(
cx_
&
calleeObj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
calleeFunc
-
>
isInterpreted
(
)
|
|
calleeFunc
-
>
isNativeWithJitEntry
(
)
)
{
return
tryAttachCallScripted
(
calleeFunc
)
;
}
if
(
calleeFunc
-
>
isNative
(
)
)
{
if
(
op_
=
=
JSOp
:
:
FunCall
)
{
return
tryAttachFunCall
(
calleeFunc
)
;
}
if
(
op_
=
=
JSOp
:
:
FunApply
)
{
return
tryAttachFunApply
(
calleeFunc
)
;
}
return
tryAttachCallNative
(
calleeFunc
)
;
}
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
CallIRGenerator
:
:
tryAttachDeferredStub
(
HandleValue
result
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
MOZ_ASSERT
(
op_
=
=
JSOp
:
:
Call
|
|
op_
=
=
JSOp
:
:
CallIgnoresRv
)
;
MOZ_ASSERT
(
mode_
=
=
ICState
:
:
Mode
:
:
Specialized
)
;
MOZ_ASSERT_UNREACHABLE
(
"
No
deferred
functions
currently
exist
"
)
;
return
AttachDecision
:
:
NoAction
;
}
void
CallIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
callee
"
callee_
)
;
sp
.
valueProperty
(
"
thisval
"
thisval_
)
;
sp
.
valueProperty
(
"
argc
"
Int32Value
(
argc_
)
)
;
}
#
endif
}
static
const
JSClass
shapeContainerClass
=
{
"
ShapeContainer
"
JSCLASS_HAS_RESERVED_SLOTS
(
1
)
}
;
static
const
size_t
SHAPE_CONTAINER_SLOT
=
0
;
JSObject
*
jit
:
:
NewWrapperWithObjectShape
(
JSContext
*
cx
HandleNativeObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
!
=
obj
-
>
compartment
(
)
)
;
RootedObject
wrapper
(
cx
)
;
{
AutoRealm
ar
(
cx
obj
)
;
wrapper
=
NewBuiltinClassInstance
(
cx
&
shapeContainerClass
)
;
if
(
!
obj
)
{
return
nullptr
;
}
wrapper
-
>
as
<
NativeObject
>
(
)
.
setSlot
(
SHAPE_CONTAINER_SLOT
PrivateGCThingValue
(
obj
-
>
lastProperty
(
)
)
)
;
}
if
(
!
JS_WrapObject
(
cx
&
wrapper
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsWrapper
(
wrapper
)
)
;
return
wrapper
;
}
void
jit
:
:
LoadShapeWrapperContents
(
MacroAssembler
&
masm
Register
obj
Register
dst
Label
*
failure
)
{
masm
.
loadPtr
(
Address
(
obj
ProxyObject
:
:
offsetOfReservedSlots
(
)
)
dst
)
;
Address
privateAddr
(
dst
js
:
:
detail
:
:
ProxyReservedSlots
:
:
offsetOfPrivateSlot
(
)
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
privateAddr
failure
)
;
masm
.
unboxObject
(
privateAddr
dst
)
;
masm
.
unboxNonDouble
(
Address
(
dst
NativeObject
:
:
getFixedSlotOffset
(
SHAPE_CONTAINER_SLOT
)
)
dst
JSVAL_TYPE_PRIVATE_GCTHING
)
;
}
CompareIRGenerator
:
:
CompareIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
JSOp
op
HandleValue
lhsVal
HandleValue
rhsVal
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
Compare
mode
)
op_
(
op
)
lhsVal_
(
lhsVal
)
rhsVal_
(
rhsVal
)
{
}
AttachDecision
CompareIRGenerator
:
:
tryAttachString
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
lhsVal_
.
isString
(
)
|
|
!
rhsVal_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
StringOperandId
lhsStrId
=
writer
.
guardToString
(
lhsId
)
;
StringOperandId
rhsStrId
=
writer
.
guardToString
(
rhsId
)
;
writer
.
compareStringResult
(
op_
lhsStrId
rhsStrId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
String
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachObject
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
)
;
if
(
!
lhsVal_
.
isObject
(
)
|
|
!
rhsVal_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ObjOperandId
lhsObjId
=
writer
.
guardToObject
(
lhsId
)
;
ObjOperandId
rhsObjId
=
writer
.
guardToObject
(
rhsId
)
;
writer
.
compareObjectResult
(
op_
lhsObjId
rhsObjId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Object
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachSymbol
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
)
;
if
(
!
lhsVal_
.
isSymbol
(
)
|
|
!
rhsVal_
.
isSymbol
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
SymbolOperandId
lhsSymId
=
writer
.
guardToSymbol
(
lhsId
)
;
SymbolOperandId
rhsSymId
=
writer
.
guardToSymbol
(
rhsId
)
;
writer
.
compareSymbolResult
(
op_
lhsSymId
rhsSymId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Symbol
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachStrictDifferentTypes
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
)
;
if
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
SameType
(
lhsVal_
rhsVal_
)
|
|
(
lhsVal_
.
isNumber
(
)
&
&
rhsVal_
.
isNumber
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValueTagOperandId
lhsTypeId
=
writer
.
loadValueTag
(
lhsId
)
;
ValueTagOperandId
rhsTypeId
=
writer
.
loadValueTag
(
rhsId
)
;
writer
.
guardTagNotEqual
(
lhsTypeId
rhsTypeId
)
;
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
StrictNe
?
true
:
false
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StrictDifferentTypes
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachInt32
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
(
!
lhsVal_
.
isInt32
(
)
&
&
!
lhsVal_
.
isBoolean
(
)
)
|
|
(
!
rhsVal_
.
isInt32
(
)
&
&
!
rhsVal_
.
isBoolean
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
Int32OperandId
lhsIntId
=
lhsVal_
.
isBoolean
(
)
?
writer
.
guardToBoolean
(
lhsId
)
:
writer
.
guardToInt32
(
lhsId
)
;
Int32OperandId
rhsIntId
=
rhsVal_
.
isBoolean
(
)
?
writer
.
guardToBoolean
(
rhsId
)
:
writer
.
guardToInt32
(
rhsId
)
;
MOZ_ASSERT_IF
(
op_
=
=
JSOp
:
:
StrictEq
|
|
op_
=
=
JSOp
:
:
StrictNe
lhsVal_
.
isInt32
(
)
=
=
rhsVal_
.
isInt32
(
)
)
;
writer
.
compareInt32Result
(
op_
lhsIntId
rhsIntId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
lhsVal_
.
isBoolean
(
)
?
"
Boolean
"
:
"
Int32
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachNumber
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
lhsVal_
.
isNumber
(
)
|
|
!
rhsVal_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
NumberOperandId
lhs
=
writer
.
guardIsNumber
(
lhsId
)
;
NumberOperandId
rhs
=
writer
.
guardIsNumber
(
rhsId
)
;
writer
.
compareDoubleResult
(
op_
lhs
rhs
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
Number
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachBigInt
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
lhsVal_
.
isBigInt
(
)
|
|
!
rhsVal_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
BigIntOperandId
lhs
=
writer
.
guardToBigInt
(
lhsId
)
;
BigIntOperandId
rhs
=
writer
.
guardToBigInt
(
rhsId
)
;
writer
.
compareBigIntResult
(
op_
lhs
rhs
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BigInt
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachObjectUndefined
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isNullOrUndefined
(
)
&
&
rhsVal_
.
isObject
(
)
)
&
&
!
(
rhsVal_
.
isNullOrUndefined
(
)
&
&
lhsVal_
.
isObject
(
)
)
)
return
AttachDecision
:
:
NoAction
;
if
(
op_
!
=
JSOp
:
:
Eq
&
&
op_
!
=
JSOp
:
:
Ne
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
obj
=
rhsVal_
.
isObject
(
)
?
rhsId
:
lhsId
;
ValOperandId
undefOrNull
=
rhsVal_
.
isObject
(
)
?
lhsId
:
rhsId
;
writer
.
guardIsNullOrUndefined
(
undefOrNull
)
;
ObjOperandId
objOperand
=
writer
.
guardToObject
(
obj
)
;
writer
.
compareObjectUndefinedNullResult
(
op_
objOperand
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ObjectUndefined
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachNumberUndefined
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isUndefined
(
)
&
&
rhsVal_
.
isNumber
(
)
)
&
&
!
(
rhsVal_
.
isUndefined
(
)
&
&
lhsVal_
.
isNumber
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
lhsVal_
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
lhsId
)
;
}
else
{
writer
.
guardIsUndefined
(
lhsId
)
;
}
if
(
rhsVal_
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
rhsId
)
;
}
else
{
writer
.
guardIsUndefined
(
rhsId
)
;
}
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
Ne
|
|
op_
=
=
JSOp
:
:
StrictNe
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NumberUndefined
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachPrimitiveUndefined
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
)
;
auto
isPrimitive
=
[
]
(
HandleValue
x
)
{
return
x
.
isString
(
)
|
|
x
.
isSymbol
(
)
|
|
x
.
isBoolean
(
)
|
|
x
.
isNumber
(
)
|
|
x
.
isBigInt
(
)
;
}
;
if
(
!
(
lhsVal_
.
isNullOrUndefined
(
)
&
&
isPrimitive
(
rhsVal_
)
)
&
&
!
(
rhsVal_
.
isNullOrUndefined
(
)
&
&
isPrimitive
(
lhsVal_
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
auto
guardPrimitive
=
[
&
]
(
HandleValue
v
ValOperandId
id
)
{
if
(
v
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
id
)
;
return
;
}
switch
(
v
.
extractNonDoubleType
(
)
)
{
case
JSVAL_TYPE_BOOLEAN
:
writer
.
guardToBoolean
(
id
)
;
return
;
case
JSVAL_TYPE_SYMBOL
:
writer
.
guardToSymbol
(
id
)
;
return
;
case
JSVAL_TYPE_BIGINT
:
writer
.
guardToBigInt
(
id
)
;
return
;
case
JSVAL_TYPE_STRING
:
writer
.
guardToString
(
id
)
;
return
;
default
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
return
;
}
}
;
isPrimitive
(
lhsVal_
)
?
guardPrimitive
(
lhsVal_
lhsId
)
:
writer
.
guardIsNullOrUndefined
(
lhsId
)
;
isPrimitive
(
rhsVal_
)
?
guardPrimitive
(
rhsVal_
rhsId
)
:
writer
.
guardIsNullOrUndefined
(
rhsId
)
;
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
Ne
|
|
op_
=
=
JSOp
:
:
StrictNe
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
PrimitiveUndefined
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachNullUndefined
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
lhsVal_
.
isNullOrUndefined
(
)
|
|
!
rhsVal_
.
isNullOrUndefined
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
op_
=
=
JSOp
:
:
Eq
|
|
op_
=
=
JSOp
:
:
Ne
)
{
writer
.
guardIsNullOrUndefined
(
lhsId
)
;
writer
.
guardIsNullOrUndefined
(
rhsId
)
;
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
Eq
)
;
trackAttached
(
"
SloppyNullUndefined
"
)
;
}
else
{
MOZ_ASSERT
(
lhsVal_
.
isNull
(
)
=
=
rhsVal_
.
isNull
(
)
)
;
lhsVal_
.
isNull
(
)
?
writer
.
guardIsNull
(
lhsId
)
:
writer
.
guardIsUndefined
(
lhsId
)
;
rhsVal_
.
isNull
(
)
?
writer
.
guardIsNull
(
rhsId
)
:
writer
.
guardIsUndefined
(
rhsId
)
;
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
StrictEq
)
;
trackAttached
(
"
StrictNullUndefinedEquality
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachStringNumber
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isString
(
)
&
&
rhsVal_
.
isNumber
(
)
)
&
&
!
(
rhsVal_
.
isString
(
)
&
&
lhsVal_
.
isNumber
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
;
auto
createGuards
=
[
&
]
(
HandleValue
v
ValOperandId
vId
)
{
if
(
v
.
isString
(
)
)
{
StringOperandId
strId
=
writer
.
guardToString
(
vId
)
;
return
writer
.
guardAndGetNumberFromString
(
strId
)
;
}
MOZ_ASSERT
(
v
.
isNumber
(
)
)
;
NumberOperandId
numId
=
writer
.
guardIsNumber
(
vId
)
;
return
numId
;
}
;
NumberOperandId
lhsGuardedId
=
createGuards
(
lhsVal_
lhsId
)
;
NumberOperandId
rhsGuardedId
=
createGuards
(
rhsVal_
rhsId
)
;
writer
.
compareDoubleResult
(
op_
lhsGuardedId
rhsGuardedId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
StringNumber
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachPrimitiveSymbol
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
)
;
auto
isPrimitive
=
[
]
(
HandleValue
x
)
{
return
x
.
isString
(
)
|
|
x
.
isBoolean
(
)
|
|
x
.
isNumber
(
)
|
|
x
.
isBigInt
(
)
;
}
;
if
(
!
(
lhsVal_
.
isSymbol
(
)
&
&
isPrimitive
(
rhsVal_
)
)
&
&
!
(
rhsVal_
.
isSymbol
(
)
&
&
isPrimitive
(
lhsVal_
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
auto
guardPrimitive
=
[
&
]
(
HandleValue
v
ValOperandId
id
)
{
MOZ_ASSERT
(
isPrimitive
(
v
)
)
;
if
(
v
.
isNumber
(
)
)
{
writer
.
guardIsNumber
(
id
)
;
return
;
}
switch
(
v
.
extractNonDoubleType
(
)
)
{
case
JSVAL_TYPE_STRING
:
writer
.
guardToString
(
id
)
;
return
;
case
JSVAL_TYPE_BOOLEAN
:
writer
.
guardToBoolean
(
id
)
;
return
;
case
JSVAL_TYPE_BIGINT
:
writer
.
guardToBigInt
(
id
)
;
return
;
default
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
return
;
}
}
;
if
(
lhsVal_
.
isSymbol
(
)
)
{
writer
.
guardToSymbol
(
lhsId
)
;
guardPrimitive
(
rhsVal_
rhsId
)
;
}
else
{
guardPrimitive
(
lhsVal_
lhsId
)
;
writer
.
guardToSymbol
(
rhsId
)
;
}
writer
.
loadBooleanResult
(
op_
=
=
JSOp
:
:
Ne
|
|
op_
=
=
JSOp
:
:
StrictNe
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
PrimitiveSymbol
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachBoolStringOrNumber
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isBoolean
(
)
&
&
(
rhsVal_
.
isString
(
)
|
|
rhsVal_
.
isNumber
(
)
)
)
&
&
!
(
rhsVal_
.
isBoolean
(
)
&
&
(
lhsVal_
.
isString
(
)
|
|
lhsVal_
.
isNumber
(
)
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
;
MOZ_ASSERT
(
!
lhsVal_
.
isInt32
(
)
&
&
!
rhsVal_
.
isInt32
(
)
)
;
auto
createGuards
=
[
&
]
(
HandleValue
v
ValOperandId
vId
)
{
if
(
v
.
isBoolean
(
)
)
{
Int32OperandId
boolId
=
writer
.
guardToBoolean
(
vId
)
;
return
writer
.
guardAndGetNumberFromBoolean
(
boolId
)
;
}
if
(
v
.
isString
(
)
)
{
StringOperandId
strId
=
writer
.
guardToString
(
vId
)
;
return
writer
.
guardAndGetNumberFromString
(
strId
)
;
}
MOZ_ASSERT
(
v
.
isNumber
(
)
)
;
return
writer
.
guardIsNumber
(
vId
)
;
}
;
NumberOperandId
lhsGuardedId
=
createGuards
(
lhsVal_
lhsId
)
;
NumberOperandId
rhsGuardedId
=
createGuards
(
rhsVal_
rhsId
)
;
writer
.
compareDoubleResult
(
op_
lhsGuardedId
rhsGuardedId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BoolStringOrNumber
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachBigIntInt32
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isBigInt
(
)
&
&
(
rhsVal_
.
isInt32
(
)
|
|
rhsVal_
.
isBoolean
(
)
)
)
&
&
!
(
rhsVal_
.
isBigInt
(
)
&
&
(
lhsVal_
.
isInt32
(
)
|
|
lhsVal_
.
isBoolean
(
)
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
;
auto
createGuards
=
[
&
]
(
HandleValue
v
ValOperandId
vId
)
{
if
(
v
.
isBoolean
(
)
)
{
return
writer
.
guardToBoolean
(
vId
)
;
}
MOZ_ASSERT
(
v
.
isInt32
(
)
)
;
return
writer
.
guardToInt32
(
vId
)
;
}
;
if
(
lhsVal_
.
isBigInt
(
)
)
{
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
lhsId
)
;
Int32OperandId
intId
=
createGuards
(
rhsVal_
rhsId
)
;
writer
.
compareBigIntInt32Result
(
op_
bigIntId
intId
)
;
}
else
{
Int32OperandId
intId
=
createGuards
(
lhsVal_
lhsId
)
;
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
rhsId
)
;
writer
.
compareInt32BigIntResult
(
op_
intId
bigIntId
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BigIntInt32
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachBigIntNumber
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isBigInt
(
)
&
&
rhsVal_
.
isNumber
(
)
)
&
&
!
(
rhsVal_
.
isBigInt
(
)
&
&
lhsVal_
.
isNumber
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
;
if
(
lhsVal_
.
isBigInt
(
)
)
{
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
lhsId
)
;
NumberOperandId
numId
=
writer
.
guardIsNumber
(
rhsId
)
;
writer
.
compareBigIntNumberResult
(
op_
bigIntId
numId
)
;
}
else
{
NumberOperandId
numId
=
writer
.
guardIsNumber
(
lhsId
)
;
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
rhsId
)
;
writer
.
compareNumberBigIntResult
(
op_
numId
bigIntId
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BigIntNumber
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachBigIntString
(
ValOperandId
lhsId
ValOperandId
rhsId
)
{
if
(
!
(
lhsVal_
.
isBigInt
(
)
&
&
rhsVal_
.
isString
(
)
)
&
&
!
(
rhsVal_
.
isBigInt
(
)
&
&
lhsVal_
.
isString
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
StrictEq
&
&
op_
!
=
JSOp
:
:
StrictNe
)
;
if
(
lhsVal_
.
isBigInt
(
)
)
{
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
lhsId
)
;
StringOperandId
strId
=
writer
.
guardToString
(
rhsId
)
;
writer
.
compareBigIntStringResult
(
op_
bigIntId
strId
)
;
}
else
{
StringOperandId
strId
=
writer
.
guardToString
(
lhsId
)
;
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
rhsId
)
;
writer
.
compareStringBigIntResult
(
op_
strId
bigIntId
)
;
}
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BigIntString
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
CompareIRGenerator
:
:
tryAttachStub
(
)
{
MOZ_ASSERT
(
cacheKind_
=
=
CacheKind
:
:
Compare
)
;
MOZ_ASSERT
(
IsEqualityOp
(
op_
)
|
|
IsRelationalOp
(
op_
)
)
;
AutoAssertNoPendingException
aanpe
(
cx_
)
;
constexpr
uint8_t
lhsIndex
=
0
;
constexpr
uint8_t
rhsIndex
=
1
;
static_assert
(
lhsIndex
=
=
0
&
&
rhsIndex
=
=
1
"
Indexes
relied
upon
by
baseline
inspector
"
)
;
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
lhsIndex
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
rhsIndex
)
)
;
if
(
IsEqualityOp
(
op_
)
)
{
TRY_ATTACH
(
tryAttachObject
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachSymbol
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachObjectUndefined
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachStrictDifferentTypes
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachPrimitiveUndefined
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachNullUndefined
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachPrimitiveSymbol
(
lhsId
rhsId
)
)
;
}
TRY_ATTACH
(
tryAttachNumberUndefined
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachInt32
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachNumber
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachBigInt
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachString
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachStringNumber
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachBoolStringOrNumber
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachBigIntInt32
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachBigIntNumber
(
lhsId
rhsId
)
)
;
TRY_ATTACH
(
tryAttachBigIntString
(
lhsId
rhsId
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
void
CompareIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
lhs
"
lhsVal_
)
;
sp
.
valueProperty
(
"
rhs
"
rhsVal_
)
;
sp
.
opcodeProperty
(
"
op
"
op_
)
;
}
#
endif
}
ToBoolIRGenerator
:
:
ToBoolIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
val
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
ToBool
mode
)
val_
(
val
)
{
}
void
ToBoolIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
val
"
val_
)
;
}
#
endif
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
TRY_ATTACH
(
tryAttachInt32
(
)
)
;
TRY_ATTACH
(
tryAttachDouble
(
)
)
;
TRY_ATTACH
(
tryAttachString
(
)
)
;
TRY_ATTACH
(
tryAttachNullOrUndefined
(
)
)
;
TRY_ATTACH
(
tryAttachObject
(
)
)
;
TRY_ATTACH
(
tryAttachSymbol
(
)
)
;
TRY_ATTACH
(
tryAttachBigInt
(
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachInt32
(
)
{
if
(
!
val_
.
isInt32
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
writer
.
guardType
(
valId
ValueType
:
:
Int32
)
;
writer
.
loadInt32TruthyResult
(
valId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolInt32
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachDouble
(
)
{
if
(
!
val_
.
isDouble
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
writer
.
guardType
(
valId
ValueType
:
:
Double
)
;
writer
.
loadDoubleTruthyResult
(
valId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolDouble
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachSymbol
(
)
{
if
(
!
val_
.
isSymbol
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
writer
.
guardType
(
valId
ValueType
:
:
Symbol
)
;
writer
.
loadBooleanResult
(
true
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolSymbol
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachString
(
)
{
if
(
!
val_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
StringOperandId
strId
=
writer
.
guardToString
(
valId
)
;
writer
.
loadStringTruthyResult
(
strId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolString
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachNullOrUndefined
(
)
{
if
(
!
val_
.
isNullOrUndefined
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
writer
.
guardIsNullOrUndefined
(
valId
)
;
writer
.
loadBooleanResult
(
false
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolNullOrUndefined
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachObject
(
)
{
if
(
!
val_
.
isObject
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
ObjOperandId
objId
=
writer
.
guardToObject
(
valId
)
;
writer
.
loadObjectTruthyResult
(
objId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolObject
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
ToBoolIRGenerator
:
:
tryAttachBigInt
(
)
{
if
(
!
val_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
valId
)
;
writer
.
loadBigIntTruthyResult
(
bigIntId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
ToBoolBigInt
"
)
;
return
AttachDecision
:
:
Attach
;
}
GetIntrinsicIRGenerator
:
:
GetIntrinsicIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
HandleValue
val
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
GetIntrinsic
mode
)
val_
(
val
)
{
}
void
GetIntrinsicIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
val
"
val_
)
;
}
#
endif
}
AttachDecision
GetIntrinsicIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
writer
.
loadValueResult
(
val_
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
GetIntrinsic
"
)
;
return
AttachDecision
:
:
Attach
;
}
UnaryArithIRGenerator
:
:
UnaryArithIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
JSOp
op
HandleValue
val
HandleValue
res
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
UnaryArith
mode
)
op_
(
op
)
val_
(
val
)
res_
(
res
)
{
}
void
UnaryArithIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
valueProperty
(
"
val
"
val_
)
;
sp
.
valueProperty
(
"
res
"
res_
)
;
}
#
endif
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
TRY_ATTACH
(
tryAttachInt32
(
)
)
;
TRY_ATTACH
(
tryAttachNumber
(
)
)
;
TRY_ATTACH
(
tryAttachBigInt
(
)
)
;
TRY_ATTACH
(
tryAttachStringInt32
(
)
)
;
TRY_ATTACH
(
tryAttachStringNumber
(
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachInt32
(
)
{
if
(
!
val_
.
isInt32
(
)
|
|
!
res_
.
isInt32
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
Int32OperandId
intId
=
writer
.
guardToInt32
(
valId
)
;
switch
(
op_
)
{
case
JSOp
:
:
BitNot
:
writer
.
int32NotResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
Int32Not
"
)
;
break
;
case
JSOp
:
:
Pos
:
writer
.
loadInt32Result
(
intId
)
;
trackAttached
(
"
UnaryArith
.
Int32Pos
"
)
;
break
;
case
JSOp
:
:
Neg
:
writer
.
int32NegationResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
Int32Neg
"
)
;
break
;
case
JSOp
:
:
Inc
:
writer
.
int32IncResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
Int32Inc
"
)
;
break
;
case
JSOp
:
:
Dec
:
writer
.
int32DecResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
Int32Dec
"
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
OP
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachNumber
(
)
{
if
(
!
val_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
res_
.
isNumber
(
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
NumberOperandId
numId
=
writer
.
guardIsNumber
(
valId
)
;
Int32OperandId
truncatedId
;
switch
(
op_
)
{
case
JSOp
:
:
BitNot
:
truncatedId
=
writer
.
truncateDoubleToUInt32
(
numId
)
;
writer
.
int32NotResult
(
truncatedId
)
;
trackAttached
(
"
UnaryArith
.
DoubleNot
"
)
;
break
;
case
JSOp
:
:
Pos
:
writer
.
loadDoubleResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
DoublePos
"
)
;
break
;
case
JSOp
:
:
Neg
:
writer
.
doubleNegationResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
DoubleNeg
"
)
;
break
;
case
JSOp
:
:
Inc
:
writer
.
doubleIncResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
DoubleInc
"
)
;
break
;
case
JSOp
:
:
Dec
:
writer
.
doubleDecResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
DoubleDec
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
OP
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachBigInt
(
)
{
if
(
!
val_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
res_
.
isBigInt
(
)
)
;
MOZ_ASSERT
(
op_
!
=
JSOp
:
:
Pos
"
Applying
the
unary
+
operator
on
BigInt
values
throws
an
error
"
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
BigIntOperandId
bigIntId
=
writer
.
guardToBigInt
(
valId
)
;
switch
(
op_
)
{
case
JSOp
:
:
BitNot
:
writer
.
bigIntNotResult
(
bigIntId
)
;
trackAttached
(
"
UnaryArith
.
BigIntNot
"
)
;
break
;
case
JSOp
:
:
Neg
:
writer
.
bigIntNegationResult
(
bigIntId
)
;
trackAttached
(
"
UnaryArith
.
BigIntNeg
"
)
;
break
;
case
JSOp
:
:
Inc
:
writer
.
bigIntIncResult
(
bigIntId
)
;
trackAttached
(
"
UnaryArith
.
BigIntInc
"
)
;
break
;
case
JSOp
:
:
Dec
:
writer
.
bigIntDecResult
(
bigIntId
)
;
trackAttached
(
"
UnaryArith
.
BigIntDec
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
OP
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachStringInt32
(
)
{
if
(
!
val_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
res_
.
isNumber
(
)
)
;
if
(
!
res_
.
isInt32
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
StringOperandId
stringId
=
writer
.
guardToString
(
valId
)
;
Int32OperandId
intId
=
writer
.
guardAndGetInt32FromString
(
stringId
)
;
switch
(
op_
)
{
case
JSOp
:
:
BitNot
:
writer
.
int32NotResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
StringInt32Not
"
)
;
break
;
case
JSOp
:
:
Pos
:
writer
.
loadInt32Result
(
intId
)
;
trackAttached
(
"
UnaryArith
.
StringInt32Pos
"
)
;
break
;
case
JSOp
:
:
Neg
:
writer
.
int32NegationResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
StringInt32Neg
"
)
;
break
;
case
JSOp
:
:
Inc
:
writer
.
int32IncResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
StringInt32Inc
"
)
;
break
;
case
JSOp
:
:
Dec
:
writer
.
int32DecResult
(
intId
)
;
trackAttached
(
"
UnaryArith
.
StringInt32Dec
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
OP
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
UnaryArithIRGenerator
:
:
tryAttachStringNumber
(
)
{
if
(
!
val_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT
(
res_
.
isNumber
(
)
)
;
ValOperandId
valId
(
writer
.
setInputOperandId
(
0
)
)
;
StringOperandId
stringId
=
writer
.
guardToString
(
valId
)
;
NumberOperandId
numId
=
writer
.
guardAndGetNumberFromString
(
stringId
)
;
Int32OperandId
truncatedId
;
switch
(
op_
)
{
case
JSOp
:
:
BitNot
:
truncatedId
=
writer
.
truncateDoubleToUInt32
(
numId
)
;
writer
.
int32NotResult
(
truncatedId
)
;
trackAttached
(
"
UnaryArith
.
StringNumberNot
"
)
;
break
;
case
JSOp
:
:
Pos
:
writer
.
loadDoubleResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
StringNumberPos
"
)
;
break
;
case
JSOp
:
:
Neg
:
writer
.
doubleNegationResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
StringNumberNeg
"
)
;
break
;
case
JSOp
:
:
Inc
:
writer
.
doubleIncResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
StringNumberInc
"
)
;
break
;
case
JSOp
:
:
Dec
:
writer
.
doubleDecResult
(
numId
)
;
trackAttached
(
"
UnaryArith
.
StringNumberDec
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
OP
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
BinaryArithIRGenerator
:
:
BinaryArithIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
JSOp
op
HandleValue
lhs
HandleValue
rhs
HandleValue
res
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
BinaryArith
mode
)
op_
(
op
)
lhs_
(
lhs
)
rhs_
(
rhs
)
res_
(
res
)
{
}
void
BinaryArithIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
opcodeProperty
(
"
op
"
op_
)
;
sp
.
valueProperty
(
"
rhs
"
rhs_
)
;
sp
.
valueProperty
(
"
lhs
"
lhs_
)
;
}
#
endif
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
TRY_ATTACH
(
tryAttachInt32
(
)
)
;
TRY_ATTACH
(
tryAttachBitwise
(
)
)
;
TRY_ATTACH
(
tryAttachDouble
(
)
)
;
TRY_ATTACH
(
tryAttachStringConcat
(
)
)
;
TRY_ATTACH
(
tryAttachStringObjectConcat
(
)
)
;
TRY_ATTACH
(
tryAttachStringNumberConcat
(
)
)
;
TRY_ATTACH
(
tryAttachStringBooleanConcat
(
)
)
;
TRY_ATTACH
(
tryAttachBigInt
(
)
)
;
TRY_ATTACH
(
tryAttachStringInt32Arith
(
)
)
;
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachBitwise
(
)
{
if
(
op_
!
=
JSOp
:
:
BitOr
&
&
op_
!
=
JSOp
:
:
BitXor
&
&
op_
!
=
JSOp
:
:
BitAnd
&
&
op_
!
=
JSOp
:
:
Lsh
&
&
op_
!
=
JSOp
:
:
Rsh
&
&
op_
!
=
JSOp
:
:
Ursh
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
(
lhs_
.
isNumber
(
)
|
|
lhs_
.
isBoolean
(
)
)
|
|
!
(
rhs_
.
isNumber
(
)
|
|
rhs_
.
isBoolean
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
MOZ_ASSERT_IF
(
op_
!
=
JSOp
:
:
Ursh
res_
.
isInt32
(
)
)
;
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
auto
guardToInt32
=
[
&
]
(
ValOperandId
id
HandleValue
val
)
{
if
(
val
.
isInt32
(
)
)
{
return
writer
.
guardToInt32
(
id
)
;
}
if
(
val
.
isBoolean
(
)
)
{
return
writer
.
guardToBoolean
(
id
)
;
}
MOZ_ASSERT
(
val
.
isDouble
(
)
)
;
writer
.
guardType
(
id
ValueType
:
:
Double
)
;
return
writer
.
truncateDoubleToUInt32
(
id
)
;
}
;
Int32OperandId
lhsIntId
=
guardToInt32
(
lhsId
lhs_
)
;
Int32OperandId
rhsIntId
=
guardToInt32
(
rhsId
rhs_
)
;
switch
(
op_
)
{
case
JSOp
:
:
BitOr
:
writer
.
int32BitOrResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
BitOr
"
)
;
break
;
case
JSOp
:
:
BitXor
:
writer
.
int32BitXorResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
BitXor
"
)
;
break
;
case
JSOp
:
:
BitAnd
:
writer
.
int32BitAndResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
BitAnd
"
)
;
break
;
case
JSOp
:
:
Lsh
:
writer
.
int32LeftShiftResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
LeftShift
"
)
;
break
;
case
JSOp
:
:
Rsh
:
writer
.
int32RightShiftResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
RightShift
"
)
;
break
;
case
JSOp
:
:
Ursh
:
writer
.
int32URightShiftResult
(
lhsIntId
rhsIntId
res_
.
isDouble
(
)
)
;
trackAttached
(
"
BinaryArith
.
Bitwise
.
UnsignedRightShift
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
op
in
tryAttachBitwise
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachDouble
(
)
{
if
(
op_
!
=
JSOp
:
:
Add
&
&
op_
!
=
JSOp
:
:
Sub
&
&
op_
!
=
JSOp
:
:
Mul
&
&
op_
!
=
JSOp
:
:
Div
&
&
op_
!
=
JSOp
:
:
Mod
&
&
op_
!
=
JSOp
:
:
Pow
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
lhs_
.
isNumber
(
)
|
|
!
rhs_
.
isNumber
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
NumberOperandId
lhs
=
writer
.
guardIsNumber
(
lhsId
)
;
NumberOperandId
rhs
=
writer
.
guardIsNumber
(
rhsId
)
;
switch
(
op_
)
{
case
JSOp
:
:
Add
:
writer
.
doubleAddResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Add
"
)
;
break
;
case
JSOp
:
:
Sub
:
writer
.
doubleSubResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Sub
"
)
;
break
;
case
JSOp
:
:
Mul
:
writer
.
doubleMulResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Mul
"
)
;
break
;
case
JSOp
:
:
Div
:
writer
.
doubleDivResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Div
"
)
;
break
;
case
JSOp
:
:
Mod
:
writer
.
doubleModResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Mod
"
)
;
break
;
case
JSOp
:
:
Pow
:
writer
.
doublePowResult
(
lhs
rhs
)
;
trackAttached
(
"
BinaryArith
.
Double
.
Pow
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
Op
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachInt32
(
)
{
if
(
!
(
lhs_
.
isInt32
(
)
|
|
lhs_
.
isBoolean
(
)
)
|
|
!
(
rhs_
.
isInt32
(
)
|
|
rhs_
.
isBoolean
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
res_
.
isInt32
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
op_
!
=
JSOp
:
:
Add
&
&
op_
!
=
JSOp
:
:
Sub
&
&
op_
!
=
JSOp
:
:
Mul
&
&
op_
!
=
JSOp
:
:
Div
&
&
op_
!
=
JSOp
:
:
Mod
&
&
op_
!
=
JSOp
:
:
Pow
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
op_
=
=
JSOp
:
:
Pow
&
&
rhs_
.
isInt32
(
)
&
&
rhs_
.
toInt32
(
)
<
0
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
auto
guardToInt32
=
[
&
]
(
ValOperandId
id
HandleValue
v
)
{
if
(
v
.
isInt32
(
)
)
{
return
writer
.
guardToInt32
(
id
)
;
}
MOZ_ASSERT
(
v
.
isBoolean
(
)
)
;
return
writer
.
guardToBoolean
(
id
)
;
}
;
Int32OperandId
lhsIntId
=
guardToInt32
(
lhsId
lhs_
)
;
Int32OperandId
rhsIntId
=
guardToInt32
(
rhsId
rhs_
)
;
switch
(
op_
)
{
case
JSOp
:
:
Add
:
writer
.
int32AddResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Add
"
)
;
break
;
case
JSOp
:
:
Sub
:
writer
.
int32SubResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Sub
"
)
;
break
;
case
JSOp
:
:
Mul
:
writer
.
int32MulResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Mul
"
)
;
break
;
case
JSOp
:
:
Div
:
writer
.
int32DivResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Div
"
)
;
break
;
case
JSOp
:
:
Mod
:
writer
.
int32ModResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Mod
"
)
;
break
;
case
JSOp
:
:
Pow
:
writer
.
int32PowResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
Int32
.
Pow
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
op
in
tryAttachInt32
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStringNumberConcat
(
)
{
if
(
op_
!
=
JSOp
:
:
Add
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
(
lhs_
.
isString
(
)
&
&
rhs_
.
isNumber
(
)
)
&
&
!
(
lhs_
.
isNumber
(
)
&
&
rhs_
.
isString
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
auto
guardToString
=
[
&
]
(
ValOperandId
id
HandleValue
v
)
{
if
(
v
.
isString
(
)
)
{
return
writer
.
guardToString
(
id
)
;
}
if
(
v
.
isInt32
(
)
)
{
Int32OperandId
intId
=
writer
.
guardToInt32
(
id
)
;
return
writer
.
callInt32ToString
(
intId
)
;
}
MOZ_ASSERT
(
v
.
isNumber
(
)
)
;
NumberOperandId
numId
=
writer
.
guardIsNumber
(
id
)
;
return
writer
.
callNumberToString
(
numId
)
;
}
;
StringOperandId
lhsStrId
=
guardToString
(
lhsId
lhs_
)
;
StringOperandId
rhsStrId
=
guardToString
(
rhsId
rhs_
)
;
writer
.
callStringConcatResult
(
lhsStrId
rhsStrId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BinaryArith
.
StringNumberConcat
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStringBooleanConcat
(
)
{
if
(
op_
!
=
JSOp
:
:
Add
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
(
!
lhs_
.
isString
(
)
|
|
!
rhs_
.
isBoolean
(
)
)
&
&
(
!
lhs_
.
isBoolean
(
)
|
|
!
rhs_
.
isString
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
auto
guardToString
=
[
&
]
(
ValOperandId
id
HandleValue
v
)
{
if
(
v
.
isString
(
)
)
{
return
writer
.
guardToString
(
id
)
;
}
MOZ_ASSERT
(
v
.
isBoolean
(
)
)
;
Int32OperandId
intId
=
writer
.
guardToBoolean
(
id
)
;
return
writer
.
booleanToString
(
intId
)
;
}
;
StringOperandId
lhsStrId
=
guardToString
(
lhsId
lhs_
)
;
StringOperandId
rhsStrId
=
guardToString
(
rhsId
rhs_
)
;
writer
.
callStringConcatResult
(
lhsStrId
rhsStrId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BinaryArith
.
StringBooleanConcat
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStringConcat
(
)
{
if
(
op_
!
=
JSOp
:
:
Add
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
lhs_
.
isString
(
)
|
|
!
rhs_
.
isString
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
StringOperandId
lhsStrId
=
writer
.
guardToString
(
lhsId
)
;
StringOperandId
rhsStrId
=
writer
.
guardToString
(
rhsId
)
;
writer
.
callStringConcatResult
(
lhsStrId
rhsStrId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BinaryArith
.
StringConcat
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStringObjectConcat
(
)
{
if
(
op_
!
=
JSOp
:
:
Add
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
(
lhs_
.
isObject
(
)
&
&
rhs_
.
isString
(
)
)
&
&
!
(
lhs_
.
isString
(
)
&
&
rhs_
.
isObject
(
)
)
)
return
AttachDecision
:
:
NoAction
;
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
if
(
lhs_
.
isString
(
)
)
{
writer
.
guardToString
(
lhsId
)
;
writer
.
guardToObject
(
rhsId
)
;
}
else
{
writer
.
guardToObject
(
lhsId
)
;
writer
.
guardToString
(
rhsId
)
;
}
writer
.
callStringObjectConcatResult
(
lhsId
rhsId
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
BinaryArith
.
StringObjectConcat
"
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachBigInt
(
)
{
if
(
!
lhs_
.
isBigInt
(
)
|
|
!
rhs_
.
isBigInt
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
switch
(
op_
)
{
case
JSOp
:
:
Add
:
case
JSOp
:
:
Sub
:
case
JSOp
:
:
Mul
:
case
JSOp
:
:
Div
:
case
JSOp
:
:
Mod
:
case
JSOp
:
:
Pow
:
break
;
case
JSOp
:
:
BitOr
:
case
JSOp
:
:
BitXor
:
case
JSOp
:
:
BitAnd
:
case
JSOp
:
:
Lsh
:
case
JSOp
:
:
Rsh
:
break
;
default
:
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
BigIntOperandId
lhsBigIntId
=
writer
.
guardToBigInt
(
lhsId
)
;
BigIntOperandId
rhsBigIntId
=
writer
.
guardToBigInt
(
rhsId
)
;
switch
(
op_
)
{
case
JSOp
:
:
Add
:
writer
.
bigIntAddResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Add
"
)
;
break
;
case
JSOp
:
:
Sub
:
writer
.
bigIntSubResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Sub
"
)
;
break
;
case
JSOp
:
:
Mul
:
writer
.
bigIntMulResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Mul
"
)
;
break
;
case
JSOp
:
:
Div
:
writer
.
bigIntDivResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Div
"
)
;
break
;
case
JSOp
:
:
Mod
:
writer
.
bigIntModResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Mod
"
)
;
break
;
case
JSOp
:
:
Pow
:
writer
.
bigIntPowResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
Pow
"
)
;
break
;
case
JSOp
:
:
BitOr
:
writer
.
bigIntBitOrResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
BitOr
"
)
;
break
;
case
JSOp
:
:
BitXor
:
writer
.
bigIntBitXorResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
BitXor
"
)
;
break
;
case
JSOp
:
:
BitAnd
:
writer
.
bigIntBitAndResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
BitAnd
"
)
;
break
;
case
JSOp
:
:
Lsh
:
writer
.
bigIntLeftShiftResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
LeftShift
"
)
;
break
;
case
JSOp
:
:
Rsh
:
writer
.
bigIntRightShiftResult
(
lhsBigIntId
rhsBigIntId
)
;
trackAttached
(
"
BinaryArith
.
BigInt
.
RightShift
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
op
in
tryAttachBigInt
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
AttachDecision
BinaryArithIRGenerator
:
:
tryAttachStringInt32Arith
(
)
{
if
(
!
(
lhs_
.
isInt32
(
)
&
&
rhs_
.
isString
(
)
)
&
&
!
(
lhs_
.
isString
(
)
&
&
rhs_
.
isInt32
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
!
res_
.
isInt32
(
)
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
op_
!
=
JSOp
:
:
Sub
&
&
op_
!
=
JSOp
:
:
Mul
&
&
op_
!
=
JSOp
:
:
Div
&
&
op_
!
=
JSOp
:
:
Mod
&
&
op_
!
=
JSOp
:
:
Pow
)
{
return
AttachDecision
:
:
NoAction
;
}
if
(
op_
=
=
JSOp
:
:
Pow
&
&
(
(
rhs_
.
isInt32
(
)
&
&
rhs_
.
toInt32
(
)
<
0
)
|
|
rhs_
.
isString
(
)
)
)
{
return
AttachDecision
:
:
NoAction
;
}
ValOperandId
lhsId
(
writer
.
setInputOperandId
(
0
)
)
;
ValOperandId
rhsId
(
writer
.
setInputOperandId
(
1
)
)
;
auto
guardToInt32
=
[
&
]
(
ValOperandId
id
HandleValue
v
)
{
if
(
v
.
isInt32
(
)
)
{
return
writer
.
guardToInt32
(
id
)
;
}
MOZ_ASSERT
(
v
.
isString
(
)
)
;
StringOperandId
strId
=
writer
.
guardToString
(
id
)
;
return
writer
.
guardAndGetInt32FromString
(
strId
)
;
}
;
Int32OperandId
lhsIntId
=
guardToInt32
(
lhsId
lhs_
)
;
Int32OperandId
rhsIntId
=
guardToInt32
(
rhsId
rhs_
)
;
switch
(
op_
)
{
case
JSOp
:
:
Sub
:
writer
.
int32SubResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
StringInt32
.
Sub
"
)
;
break
;
case
JSOp
:
:
Mul
:
writer
.
int32MulResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
StringInt32
.
Mul
"
)
;
break
;
case
JSOp
:
:
Div
:
writer
.
int32DivResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
StringInt32
.
Div
"
)
;
break
;
case
JSOp
:
:
Mod
:
writer
.
int32ModResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
StringInt32
.
Mod
"
)
;
break
;
case
JSOp
:
:
Pow
:
writer
.
int32PowResult
(
lhsIntId
rhsIntId
)
;
trackAttached
(
"
BinaryArith
.
StringInt32
.
Pow
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
op
in
tryAttachStringInt32Arith
"
)
;
}
writer
.
returnFromIC
(
)
;
return
AttachDecision
:
:
Attach
;
}
NewObjectIRGenerator
:
:
NewObjectIRGenerator
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICState
:
:
Mode
mode
JSOp
op
HandleObject
templateObj
)
:
IRGenerator
(
cx
script
pc
CacheKind
:
:
NewObject
mode
)
#
ifdef
JS_CACHEIR_SPEW
op_
(
op
)
#
endif
templateObject_
(
templateObj
)
{
MOZ_ASSERT
(
templateObject_
)
;
}
void
NewObjectIRGenerator
:
:
trackAttached
(
const
char
*
name
)
{
#
ifdef
JS_CACHEIR_SPEW
if
(
const
CacheIRSpewer
:
:
Guard
&
sp
=
CacheIRSpewer
:
:
Guard
(
*
this
name
)
)
{
sp
.
opcodeProperty
(
"
op
"
op_
)
;
}
#
endif
}
AttachDecision
NewObjectIRGenerator
:
:
tryAttachStub
(
)
{
AutoAssertNoPendingException
aanpe
(
cx_
)
;
if
(
templateObject_
-
>
as
<
NativeObject
>
(
)
.
hasDynamicSlots
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
AutoSweepObjectGroup
sweep
(
templateObject_
-
>
group
(
)
)
;
if
(
templateObject_
-
>
group
(
)
-
>
shouldPreTenure
(
sweep
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
if
(
cx_
-
>
realm
(
)
-
>
hasAllocationMetadataBuilder
(
)
)
{
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
return
AttachDecision
:
:
NoAction
;
}
writer
.
guardNoAllocationMetadataBuilder
(
)
;
writer
.
guardObjectGroupNotPretenured
(
templateObject_
-
>
group
(
)
)
;
uint64_t
id
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
nextDisambiguationId
(
)
;
uint32_t
idHi
=
id
>
>
32
;
uint32_t
idLo
=
id
&
UINT32_MAX
;
writer
.
loadNewObjectFromTemplateResult
(
templateObject_
idHi
idLo
)
;
writer
.
returnFromIC
(
)
;
trackAttached
(
"
NewObjectWithTemplate
"
)
;
return
AttachDecision
:
:
Attach
;
}
#
ifdef
JS_SIMULATOR
bool
js
:
:
jit
:
:
CallAnyNative
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
calleeObj
(
cx
&
args
.
callee
(
)
)
;
MOZ_ASSERT
(
calleeObj
-
>
is
<
JSFunction
>
(
)
)
;
RootedFunction
calleeFunc
(
cx
&
calleeObj
-
>
as
<
JSFunction
>
(
)
)
;
MOZ_ASSERT
(
calleeFunc
-
>
isNative
(
)
)
;
JSNative
native
=
calleeFunc
-
>
native
(
)
;
return
native
(
cx
args
.
length
(
)
args
.
base
(
)
)
;
}
#
endif
