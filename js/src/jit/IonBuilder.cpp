#
include
"
jit
/
IonBuilder
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
algorithm
>
#
include
"
builtin
/
Eval
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineInspector
.
h
"
#
include
"
jit
/
CacheIR
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
InlineScriptTree
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
IonOptimizationLevels
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
js
/
experimental
/
JitInfo
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
util
/
CheckedArithmetic
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
BuiltinObjectKind
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
Instrumentation
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
RegExpStatics
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
wasm
/
TypedObject
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
jit
/
CompileInfo
-
inl
.
h
"
#
include
"
jit
/
InlineScriptTree
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
vm
/
BytecodeIterator
-
inl
.
h
"
#
include
"
vm
/
BytecodeLocation
-
inl
.
h
"
#
include
"
vm
/
BytecodeUtil
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
ObjectGroup
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
class
jit
:
:
BaselineFrameInspector
{
public
:
TypeSet
:
:
Type
thisType
;
JSObject
*
singletonEnvChain
;
Vector
<
TypeSet
:
:
Type
4
JitAllocPolicy
>
argTypes
;
Vector
<
TypeSet
:
:
Type
4
JitAllocPolicy
>
varTypes
;
explicit
BaselineFrameInspector
(
TempAllocator
*
temp
)
:
thisType
(
TypeSet
:
:
UndefinedType
(
)
)
singletonEnvChain
(
nullptr
)
argTypes
(
*
temp
)
varTypes
(
*
temp
)
{
}
}
;
BaselineFrameInspector
*
jit
:
:
NewBaselineFrameInspector
(
TempAllocator
*
temp
BaselineFrame
*
frame
uint32_t
frameSize
)
{
MOZ_ASSERT
(
frame
)
;
BaselineFrameInspector
*
inspector
=
temp
-
>
lifoAlloc
(
)
-
>
new_
<
BaselineFrameInspector
>
(
temp
)
;
if
(
!
inspector
)
{
return
nullptr
;
}
if
(
frame
-
>
isFunctionFrame
(
)
)
{
inspector
-
>
thisType
=
TypeSet
:
:
GetMaybeUntrackedValueType
(
frame
-
>
thisArgument
(
)
)
;
}
if
(
frame
-
>
environmentChain
(
)
-
>
isSingleton
(
)
)
{
inspector
-
>
singletonEnvChain
=
frame
-
>
environmentChain
(
)
;
}
JSScript
*
script
=
frame
-
>
script
(
)
;
if
(
script
-
>
function
(
)
)
{
if
(
!
inspector
-
>
argTypes
.
reserve
(
frame
-
>
numFormalArgs
(
)
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
frame
-
>
numFormalArgs
(
)
;
i
+
+
)
{
if
(
script
-
>
formalIsAliased
(
i
)
)
{
inspector
-
>
argTypes
.
infallibleAppend
(
TypeSet
:
:
UndefinedType
(
)
)
;
}
else
if
(
!
script
-
>
argsObjAliasesFormals
(
)
)
{
TypeSet
:
:
Type
type
=
TypeSet
:
:
GetMaybeUntrackedValueType
(
frame
-
>
unaliasedFormal
(
i
)
)
;
inspector
-
>
argTypes
.
infallibleAppend
(
type
)
;
}
else
if
(
frame
-
>
hasArgsObj
(
)
)
{
TypeSet
:
:
Type
type
=
TypeSet
:
:
GetMaybeUntrackedValueType
(
frame
-
>
argsObj
(
)
.
arg
(
i
)
)
;
inspector
-
>
argTypes
.
infallibleAppend
(
type
)
;
}
else
{
inspector
-
>
argTypes
.
infallibleAppend
(
TypeSet
:
:
UndefinedType
(
)
)
;
}
}
}
uint32_t
numValueSlots
=
frame
-
>
numValueSlots
(
frameSize
)
;
if
(
!
inspector
-
>
varTypes
.
reserve
(
numValueSlots
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
numValueSlots
;
i
+
+
)
{
TypeSet
:
:
Type
type
=
TypeSet
:
:
GetMaybeUntrackedValueType
(
*
frame
-
>
valueSlot
(
i
)
)
;
inspector
-
>
varTypes
.
infallibleAppend
(
type
)
;
}
return
inspector
;
}
IonBuilder
:
:
IonBuilder
(
JSContext
*
analysisContext
MIRGenerator
&
mirGen
CompileInfo
*
info
CompilerConstraintList
*
constraints
BaselineInspector
*
inspector
BaselineFrameInspector
*
baselineFrame
size_t
inliningDepth
uint32_t
loopDepth
)
:
actionableAbortScript_
(
nullptr
)
actionableAbortPc_
(
nullptr
)
actionableAbortMessage_
(
nullptr
)
analysisContext
(
analysisContext
)
baselineFrame_
(
baselineFrame
)
constraints_
(
constraints
)
mirGen_
(
mirGen
)
tiOracle_
(
this
constraints
)
realm
(
mirGen
.
realm
)
info_
(
info
)
optimizationInfo_
(
&
mirGen
.
optimizationInfo
(
)
)
alloc_
(
&
mirGen
.
alloc
(
)
)
graph_
(
&
mirGen
.
graph
(
)
)
thisTypes
(
nullptr
)
argTypes
(
nullptr
)
typeArray
(
nullptr
)
typeArrayHint
(
0
)
bytecodeTypeMap
(
nullptr
)
loopDepth_
(
loopDepth
)
loopStack_
(
*
alloc_
)
trackedOptimizationSites_
(
*
alloc_
)
abortedPreliminaryGroups_
(
*
alloc_
)
callerResumePoint_
(
nullptr
)
callerBuilder_
(
nullptr
)
iterators_
(
*
alloc_
)
loopHeaders_
(
*
alloc_
)
inspector
(
inspector
)
inliningDepth_
(
inliningDepth
)
inlinedBytecodeLength_
(
0
)
numLoopRestarts_
(
0
)
failedBoundsCheck_
(
info_
-
>
script
(
)
-
>
failedBoundsCheck
(
)
)
failedShapeGuard_
(
info_
-
>
script
(
)
-
>
failedShapeGuard
(
)
)
failedLexicalCheck_
(
info_
-
>
script
(
)
-
>
failedLexicalCheck
(
)
)
#
ifdef
DEBUG
hasLazyArguments_
(
false
)
#
endif
inlineCallInfo_
(
nullptr
)
maybeFallbackFunctionGetter_
(
nullptr
)
{
script_
=
info_
-
>
script
(
)
;
pc
=
script_
-
>
code
(
)
;
MOZ_ASSERT
(
script_
-
>
hasJitScript
(
)
)
;
MOZ_ASSERT_IF
(
!
info_
-
>
isAnalysis
(
)
script_
-
>
hasBaselineScript
(
)
)
;
MOZ_ASSERT
(
!
!
analysisContext
=
=
(
info_
-
>
analysisMode
(
)
=
=
Analysis_DefiniteProperties
)
)
;
MOZ_ASSERT
(
script_
-
>
numBytecodeTypeSets
(
)
<
JSScript
:
:
MaxBytecodeTypeSets
)
;
if
(
!
info_
-
>
isAnalysis
(
)
)
{
script
(
)
-
>
jitScript
(
)
-
>
setIonCompiledOrInlined
(
)
;
}
}
mozilla
:
:
GenericErrorResult
<
AbortReason
>
IonBuilder
:
:
abort
(
AbortReason
r
)
{
auto
res
=
mirGen_
.
abort
(
r
)
;
[
[
maybe_unused
]
]
unsigned
line
column
;
#
ifdef
DEBUG
line
=
PCToLineNumber
(
script
(
)
pc
&
column
)
;
#
else
line
=
script
(
)
-
>
lineno
(
)
;
column
=
script
(
)
-
>
column
(
)
;
#
endif
JitSpew
(
JitSpew_IonAbort
"
aborted
%
s
:
%
u
:
%
u
"
script
(
)
-
>
filename
(
)
line
column
)
;
return
res
;
}
mozilla
:
:
GenericErrorResult
<
AbortReason
>
IonBuilder
:
:
abort
(
AbortReason
r
const
char
*
message
.
.
.
)
{
va_list
ap
;
va_start
(
ap
message
)
;
auto
res
=
mirGen_
.
abortFmt
(
r
message
ap
)
;
va_end
(
ap
)
;
[
[
maybe_unused
]
]
unsigned
line
column
;
#
ifdef
DEBUG
line
=
PCToLineNumber
(
script
(
)
pc
&
column
)
;
#
else
line
=
script
(
)
-
>
lineno
(
)
;
column
=
script
(
)
-
>
column
(
)
;
#
endif
JitSpew
(
JitSpew_IonAbort
"
aborted
%
s
:
%
u
:
%
u
"
script
(
)
-
>
filename
(
)
line
column
)
;
return
res
;
}
IonBuilder
*
IonBuilder
:
:
outermostBuilder
(
)
{
IonBuilder
*
builder
=
this
;
while
(
builder
-
>
callerBuilder_
)
{
builder
=
builder
-
>
callerBuilder_
;
}
return
builder
;
}
void
IonBuilder
:
:
spew
(
const
char
*
message
)
{
#
ifdef
DEBUG
JitSpew
(
JitSpew_IonMIR
"
%
s
%
s
:
%
u
"
message
script
(
)
-
>
filename
(
)
PCToLineNumber
(
script
(
)
pc
)
)
;
#
endif
}
JSFunction
*
IonBuilder
:
:
getSingleCallTarget
(
TemporaryTypeSet
*
calleeTypes
)
{
if
(
!
calleeTypes
)
{
return
nullptr
;
}
TemporaryTypeSet
:
:
ObjectKey
*
key
=
calleeTypes
-
>
maybeSingleObject
(
)
;
if
(
!
key
|
|
key
-
>
clasp
(
)
!
=
&
JSFunction
:
:
class_
)
{
return
nullptr
;
}
if
(
key
-
>
isSingleton
(
)
)
{
return
&
key
-
>
singleton
(
)
-
>
as
<
JSFunction
>
(
)
;
}
if
(
JSFunction
*
fun
=
key
-
>
group
(
)
-
>
maybeInterpretedFunction
(
)
)
{
return
fun
;
}
return
nullptr
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPolyCallTargets
(
TemporaryTypeSet
*
calleeTypes
bool
constructing
InliningTargets
&
targets
uint32_t
maxTargets
)
{
MOZ_ASSERT
(
targets
.
empty
(
)
)
;
if
(
!
calleeTypes
)
{
return
Ok
(
)
;
}
if
(
calleeTypes
-
>
baseFlags
(
)
!
=
0
)
{
return
Ok
(
)
;
}
unsigned
objCount
=
calleeTypes
-
>
getObjectCount
(
)
;
if
(
objCount
=
=
0
|
|
objCount
>
maxTargets
)
{
return
Ok
(
)
;
}
if
(
!
targets
.
reserve
(
objCount
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
for
(
unsigned
i
=
0
;
i
<
objCount
;
i
+
+
)
{
JSObject
*
obj
=
calleeTypes
-
>
getSingleton
(
i
)
;
ObjectGroup
*
group
=
nullptr
;
if
(
obj
)
{
MOZ_ASSERT
(
obj
-
>
isSingleton
(
)
)
;
}
else
{
group
=
calleeTypes
-
>
getGroup
(
i
)
;
if
(
!
group
)
{
continue
;
}
obj
=
group
-
>
maybeInterpretedFunction
(
)
;
if
(
!
obj
)
{
targets
.
clear
(
)
;
return
Ok
(
)
;
}
MOZ_ASSERT
(
!
obj
-
>
isSingleton
(
)
)
;
}
if
(
constructing
?
!
obj
-
>
isConstructor
(
)
:
!
obj
-
>
isCallable
(
)
)
{
targets
.
clear
(
)
;
return
Ok
(
)
;
}
targets
.
infallibleAppend
(
InliningTarget
(
obj
group
)
)
;
}
return
Ok
(
)
;
}
IonBuilder
:
:
InliningDecision
IonBuilder
:
:
DontInline
(
JSScript
*
targetScript
const
char
*
reason
)
{
if
(
targetScript
)
{
JitSpew
(
JitSpew_Inlining
"
Cannot
inline
%
s
:
%
u
:
%
u
%
s
"
targetScript
-
>
filename
(
)
targetScript
-
>
lineno
(
)
targetScript
-
>
column
(
)
reason
)
;
}
else
{
JitSpew
(
JitSpew_Inlining
"
Cannot
inline
:
%
s
"
reason
)
;
}
return
InliningDecision_DontInline
;
}
bool
IonBuilder
:
:
hasCommonInliningPath
(
const
JSScript
*
scriptToInline
)
{
for
(
IonBuilder
*
it
=
this
-
>
callerBuilder_
;
it
;
it
=
it
-
>
callerBuilder_
)
{
if
(
it
-
>
script
(
)
!
=
scriptToInline
)
{
continue
;
}
IonBuilder
*
path
=
it
-
>
callerBuilder_
;
if
(
!
path
|
|
this
-
>
script
(
)
=
=
path
-
>
script
(
)
)
{
return
true
;
}
}
return
false
;
}
IonBuilder
:
:
InliningDecision
IonBuilder
:
:
canInlineTarget
(
JSFunction
*
target
CallInfo
&
callInfo
)
{
if
(
!
optimizationInfo
(
)
.
inlineInterpreted
(
)
)
{
return
InliningDecision_DontInline
;
}
if
(
TraceLogTextIdEnabled
(
TraceLogger_InlinedScripts
)
)
{
return
DontInline
(
nullptr
"
Tracelogging
of
inlined
scripts
is
enabled
"
"
but
Tracelogger
cannot
do
that
yet
.
"
)
;
}
if
(
!
target
-
>
isInterpreted
(
)
)
{
return
DontInline
(
nullptr
"
Non
-
interpreted
target
"
)
;
}
if
(
target
-
>
realm
(
)
!
=
script
(
)
-
>
realm
(
)
)
{
return
DontInline
(
nullptr
"
Cross
-
realm
call
"
)
;
}
if
(
info
(
)
.
analysisMode
(
)
!
=
Analysis_DefiniteProperties
)
{
if
(
callInfo
.
thisArg
(
)
-
>
emptyResultTypeSet
(
)
)
{
return
DontInline
(
nullptr
"
Empty
TypeSet
for
|
this
|
"
)
;
}
for
(
size_t
i
=
0
;
i
<
callInfo
.
argc
(
)
;
i
+
+
)
{
if
(
callInfo
.
getArg
(
i
)
-
>
emptyResultTypeSet
(
)
)
{
return
DontInline
(
nullptr
"
Empty
TypeSet
for
argument
"
)
;
}
}
}
if
(
target
-
>
isInterpreted
(
)
&
&
info
(
)
.
analysisMode
(
)
=
=
Analysis_DefiniteProperties
)
{
RootedFunction
fun
(
analysisContext
target
)
;
RootedScript
script
(
analysisContext
JSFunction
:
:
getOrCreateScript
(
analysisContext
fun
)
)
;
if
(
!
script
)
{
return
InliningDecision_Error
;
}
if
(
CanBaselineInterpretScript
(
script
)
)
{
AutoKeepJitScripts
keepJitScript
(
analysisContext
)
;
if
(
!
script
-
>
ensureHasJitScript
(
analysisContext
keepJitScript
)
)
{
return
InliningDecision_Error
;
}
}
}
if
(
!
target
-
>
hasBytecode
(
)
)
{
return
DontInline
(
nullptr
"
Lazy
script
"
)
;
}
JSScript
*
inlineScript
=
target
-
>
nonLazyScript
(
)
;
if
(
callInfo
.
constructing
(
)
)
{
if
(
!
target
-
>
isConstructor
(
)
)
{
return
DontInline
(
inlineScript
"
Callee
is
not
a
constructor
"
)
;
}
if
(
!
target
-
>
constructorNeedsUninitializedThis
(
)
&
&
callInfo
.
getNewTarget
(
)
!
=
callInfo
.
callee
(
)
)
{
JSFunction
*
newTargetFun
=
getSingleCallTarget
(
callInfo
.
getNewTarget
(
)
-
>
resultTypeSet
(
)
)
;
if
(
!
newTargetFun
)
{
return
DontInline
(
inlineScript
"
Constructing
with
unknown
newTarget
"
)
;
}
if
(
!
newTargetFun
-
>
hasNonConfigurablePrototypeDataProperty
(
)
)
{
return
DontInline
(
inlineScript
"
Constructing
with
effectful
newTarget
.
prototype
"
)
;
}
}
else
{
MOZ_ASSERT
(
target
-
>
constructorNeedsUninitializedThis
(
)
|
|
target
-
>
hasNonConfigurablePrototypeDataProperty
(
)
)
;
}
}
if
(
!
callInfo
.
constructing
(
)
&
&
target
-
>
isClassConstructor
(
)
)
{
return
DontInline
(
inlineScript
"
Not
constructing
class
constructor
"
)
;
}
if
(
!
CanIonInlineScript
(
inlineScript
)
)
{
return
DontInline
(
inlineScript
"
Disabled
Ion
compilation
"
)
;
}
if
(
info
(
)
.
isAnalysis
(
)
)
{
if
(
!
inlineScript
-
>
hasJitScript
(
)
)
{
return
DontInline
(
inlineScript
"
No
JitScript
"
)
;
}
}
else
{
if
(
!
inlineScript
-
>
hasBaselineScript
(
)
)
{
return
DontInline
(
inlineScript
"
No
baseline
jitcode
"
)
;
}
}
if
(
!
isHighestOptimizationLevel
(
)
)
{
OptimizationLevel
level
=
optimizationLevel
(
)
;
if
(
inlineScript
-
>
hasIonScript
(
)
&
&
(
inlineScript
-
>
ionScript
(
)
-
>
isRecompiling
(
)
|
|
inlineScript
-
>
ionScript
(
)
-
>
optimizationLevel
(
)
>
level
)
)
{
return
DontInline
(
inlineScript
"
More
optimized
"
)
;
}
if
(
IonOptimizations
.
levelForScript
(
inlineScript
nullptr
)
>
level
)
{
return
DontInline
(
inlineScript
"
Should
be
more
optimized
"
)
;
}
}
if
(
TooManyFormalArguments
(
target
-
>
nargs
(
)
)
)
{
return
DontInline
(
inlineScript
"
Too
many
args
"
)
;
}
if
(
TooManyFormalArguments
(
callInfo
.
argc
(
)
)
)
{
return
DontInline
(
inlineScript
"
Too
many
actual
args
"
)
;
}
if
(
hasCommonInliningPath
(
inlineScript
)
)
{
return
DontInline
(
inlineScript
"
Common
inlining
path
"
)
;
}
if
(
inlineScript
-
>
uninlineable
(
)
)
{
return
DontInline
(
inlineScript
"
Uninlineable
script
"
)
;
}
if
(
inlineScript
-
>
needsArgsObj
(
)
)
{
return
DontInline
(
inlineScript
"
Script
that
needs
an
arguments
object
"
)
;
}
if
(
inlineScript
-
>
isDebuggee
(
)
)
{
return
DontInline
(
inlineScript
"
Script
is
debuggee
"
)
;
}
return
InliningDecision_Inline
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
analyzeNewLoopTypes
(
MBasicBlock
*
entry
)
{
MOZ_ASSERT
(
!
entry
-
>
isDead
(
)
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
bool
foundEntry
=
false
;
for
(
size_t
i
=
0
;
i
<
loopHeaders_
.
length
(
)
;
i
+
+
)
{
if
(
loopHeaders_
[
i
]
.
pc
=
=
pc
)
{
MBasicBlock
*
oldEntry
=
loopHeaders_
[
i
]
.
header
;
if
(
oldEntry
-
>
isDead
(
)
)
{
loopHeaders_
[
i
]
.
header
=
entry
;
foundEntry
=
true
;
break
;
}
MResumePoint
*
oldEntryRp
=
oldEntry
-
>
entryResumePoint
(
)
;
size_t
stackDepth
=
oldEntryRp
-
>
stackDepth
(
)
;
for
(
size_t
slot
=
0
;
slot
<
stackDepth
;
slot
+
+
)
{
MDefinition
*
oldDef
=
oldEntryRp
-
>
getOperand
(
slot
)
;
if
(
!
oldDef
-
>
isPhi
(
)
)
{
MOZ_ASSERT
(
oldDef
-
>
block
(
)
-
>
id
(
)
<
oldEntry
-
>
id
(
)
)
;
MOZ_ASSERT
(
oldDef
=
=
entry
-
>
getSlot
(
slot
)
)
;
continue
;
}
MPhi
*
oldPhi
=
oldDef
-
>
toPhi
(
)
;
MPhi
*
newPhi
=
entry
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
if
(
!
newPhi
-
>
addBackedgeType
(
alloc
(
)
oldPhi
-
>
type
(
)
oldPhi
-
>
resultTypeSet
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
loopHeaders_
[
i
]
.
header
=
entry
;
return
Ok
(
)
;
}
}
if
(
!
foundEntry
)
{
if
(
!
loopHeaders_
.
append
(
LoopHeader
(
pc
entry
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
BytecodeLocation
start
(
script_
pc
)
;
BytecodeLocation
end
(
script_
script_
-
>
codeEnd
(
)
)
;
Maybe
<
BytecodeLocation
>
last
;
Maybe
<
BytecodeLocation
>
earlier
;
for
(
auto
it
:
BytecodeLocationRange
(
start
end
)
)
{
if
(
IsBackedgeForLoopHead
(
it
.
toRawBytecode
(
)
pc
)
)
{
break
;
}
MOZ_TRY
(
analyzeNewLoopTypesForLocation
(
entry
it
last
earlier
)
)
;
earlier
=
last
;
last
=
mozilla
:
:
Some
(
it
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
analyzeNewLoopTypesForLocation
(
MBasicBlock
*
entry
const
BytecodeLocation
loc
const
Maybe
<
BytecodeLocation
>
&
last_
const
Maybe
<
BytecodeLocation
>
&
earlier
)
{
Maybe
<
BytecodeLocation
>
last
=
last_
;
uint32_t
slot
;
if
(
loc
.
is
(
JSOp
:
:
SetLocal
)
)
{
slot
=
info
(
)
.
localSlot
(
loc
.
local
(
)
)
;
}
else
if
(
loc
.
is
(
JSOp
:
:
SetArg
)
)
{
slot
=
info
(
)
.
argSlotUnchecked
(
loc
.
arg
(
)
)
;
}
else
{
return
Ok
(
)
;
}
if
(
slot
>
=
info
(
)
.
firstStackSlot
(
)
)
{
return
Ok
(
)
;
}
if
(
!
last
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
last
-
>
isValid
(
script_
)
)
;
MPhi
*
phi
=
entry
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
auto
addPhiBackedgeType
=
[
&
]
(
MIRType
type
TemporaryTypeSet
*
typeSet
)
-
>
AbortReasonOr
<
Ok
>
{
if
(
!
phi
-
>
addBackedgeType
(
alloc
(
)
type
typeSet
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
Ok
(
)
;
}
;
if
(
last
-
>
is
(
JSOp
:
:
Pos
)
|
|
last
-
>
is
(
JSOp
:
:
ToNumeric
)
)
{
MOZ_ASSERT
(
earlier
)
;
last
=
earlier
;
}
if
(
last
-
>
opHasTypeSet
(
)
)
{
TemporaryTypeSet
*
typeSet
=
bytecodeTypes
(
last
-
>
toRawBytecode
(
)
)
;
if
(
typeSet
-
>
empty
(
)
)
{
return
Ok
(
)
;
}
return
addPhiBackedgeType
(
typeSet
-
>
getKnownMIRType
(
)
typeSet
)
;
}
if
(
last
-
>
is
(
JSOp
:
:
GetLocal
)
|
|
last
-
>
is
(
JSOp
:
:
GetArg
)
)
{
uint32_t
slot
=
(
last
-
>
is
(
JSOp
:
:
GetLocal
)
)
?
info
(
)
.
localSlot
(
last
-
>
local
(
)
)
:
info
(
)
.
argSlotUnchecked
(
last
-
>
arg
(
)
)
;
if
(
slot
>
=
info
(
)
.
firstStackSlot
(
)
)
{
return
Ok
(
)
;
}
MPhi
*
otherPhi
=
entry
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
if
(
!
otherPhi
-
>
hasBackedgeType
(
)
)
{
return
Ok
(
)
;
}
return
addPhiBackedgeType
(
otherPhi
-
>
type
(
)
otherPhi
-
>
resultTypeSet
(
)
)
;
}
MIRType
type
=
MIRType
:
:
None
;
switch
(
last
-
>
getOp
(
)
)
{
case
JSOp
:
:
Void
:
case
JSOp
:
:
Undefined
:
type
=
MIRType
:
:
Undefined
;
break
;
case
JSOp
:
:
GImplicitThis
:
if
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
type
=
MIRType
:
:
Undefined
;
}
break
;
case
JSOp
:
:
Null
:
type
=
MIRType
:
:
Null
;
break
;
case
JSOp
:
:
Zero
:
case
JSOp
:
:
One
:
case
JSOp
:
:
Int8
:
case
JSOp
:
:
Int32
:
case
JSOp
:
:
Uint16
:
case
JSOp
:
:
Uint24
:
case
JSOp
:
:
ResumeIndex
:
type
=
MIRType
:
:
Int32
;
break
;
case
JSOp
:
:
BitAnd
:
case
JSOp
:
:
BitOr
:
case
JSOp
:
:
BitXor
:
case
JSOp
:
:
BitNot
:
case
JSOp
:
:
Rsh
:
case
JSOp
:
:
Lsh
:
type
=
inspector
-
>
expectedResultType
(
last
-
>
toRawBytecode
(
)
)
;
break
;
case
JSOp
:
:
Ursh
:
type
=
MIRType
:
:
Int32
;
break
;
case
JSOp
:
:
False
:
case
JSOp
:
:
True
:
case
JSOp
:
:
Eq
:
case
JSOp
:
:
Ne
:
case
JSOp
:
:
Lt
:
case
JSOp
:
:
Le
:
case
JSOp
:
:
Gt
:
case
JSOp
:
:
Ge
:
case
JSOp
:
:
Not
:
case
JSOp
:
:
StrictEq
:
case
JSOp
:
:
StrictNe
:
case
JSOp
:
:
In
:
case
JSOp
:
:
Instanceof
:
case
JSOp
:
:
HasOwn
:
type
=
MIRType
:
:
Boolean
;
break
;
case
JSOp
:
:
Double
:
type
=
MIRType
:
:
Double
;
break
;
case
JSOp
:
:
IterNext
:
case
JSOp
:
:
String
:
case
JSOp
:
:
ToString
:
case
JSOp
:
:
Typeof
:
case
JSOp
:
:
TypeofExpr
:
type
=
MIRType
:
:
String
;
break
;
case
JSOp
:
:
Symbol
:
type
=
MIRType
:
:
Symbol
;
break
;
case
JSOp
:
:
Add
:
case
JSOp
:
:
Sub
:
case
JSOp
:
:
Mul
:
case
JSOp
:
:
Div
:
case
JSOp
:
:
Mod
:
case
JSOp
:
:
Neg
:
case
JSOp
:
:
Inc
:
case
JSOp
:
:
Dec
:
type
=
inspector
-
>
expectedResultType
(
last
-
>
toRawBytecode
(
)
)
;
break
;
case
JSOp
:
:
BigInt
:
type
=
MIRType
:
:
BigInt
;
break
;
default
:
break
;
}
if
(
type
=
=
MIRType
:
:
None
)
{
return
Ok
(
)
;
}
return
addPhiBackedgeType
(
type
nullptr
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
init
(
)
{
{
LifoAlloc
:
:
AutoFallibleScope
fallibleAllocator
(
alloc
(
)
.
lifoAlloc
(
)
)
;
if
(
!
JitScript
:
:
FreezeTypeSets
(
constraints
(
)
script
(
)
&
thisTypes
&
argTypes
&
typeArray
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
RootedScript
rootedScript
(
cx
script
(
)
)
;
if
(
!
rootedScript
-
>
jitScript
(
)
-
>
ensureHasCachedIonData
(
cx
rootedScript
)
)
{
return
abort
(
AbortReason
:
:
Error
)
;
}
}
if
(
inlineCallInfo_
)
{
thisTypes
=
inlineCallInfo_
-
>
thisArg
(
)
-
>
resultTypeSet
(
)
;
argTypes
=
nullptr
;
}
bytecodeTypeMap
=
script
(
)
-
>
jitScript
(
)
-
>
bytecodeTypeMap
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
build
(
)
{
#
ifdef
JS_STRUCTURED_SPEW
if
(
!
info
(
)
.
isAnalysis
(
)
)
{
JitSpewBaselineICStats
(
script
(
)
"
To
-
Be
-
Compiled
"
)
;
}
#
endif
MOZ_TRY
(
init
(
)
)
;
if
(
isHighestOptimizationLevel
(
)
)
{
script
(
)
-
>
jitScript
(
)
-
>
resetMaxInliningDepth
(
)
;
}
MBasicBlock
*
entry
;
MOZ_TRY_VAR
(
entry
newBlock
(
info
(
)
.
firstStackSlot
(
)
pc
)
)
;
MOZ_TRY
(
setCurrentAndSpecializePhis
(
entry
)
)
;
#
ifdef
JS_JITSPEW
if
(
info
(
)
.
isAnalysis
(
)
)
{
JitSpew
(
JitSpew_IonScripts
"
Analyzing
script
%
s
:
%
u
:
%
u
(
%
p
)
%
s
"
script
(
)
-
>
filename
(
)
script
(
)
-
>
lineno
(
)
script
(
)
-
>
column
(
)
(
void
*
)
script
(
)
AnalysisModeString
(
info
(
)
.
analysisMode
(
)
)
)
;
}
else
{
JitSpew
(
JitSpew_IonScripts
"
%
sompiling
script
%
s
:
%
u
:
%
u
(
%
p
)
(
warmup
-
counter
=
%
"
PRIu32
"
level
=
%
s
)
"
(
script
(
)
-
>
hasIonScript
(
)
?
"
Rec
"
:
"
C
"
)
script
(
)
-
>
filename
(
)
script
(
)
-
>
lineno
(
)
script
(
)
-
>
column
(
)
(
void
*
)
script
(
)
script
(
)
-
>
getWarmUpCount
(
)
OptimizationLevelString
(
optimizationLevel
(
)
)
)
;
}
#
endif
MOZ_TRY
(
initParameters
(
)
)
;
initLocals
(
)
;
MInstruction
*
env
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
env
)
;
current
-
>
initSlot
(
info
(
)
.
environmentChainSlot
(
)
env
)
;
MInstruction
*
returnValue
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
returnValue
)
;
current
-
>
initSlot
(
info
(
)
.
returnValueSlot
(
)
returnValue
)
;
if
(
info
(
)
.
hasArguments
(
)
)
{
MInstruction
*
argsObj
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
argsObj
)
;
current
-
>
initSlot
(
info
(
)
.
argsObjSlot
(
)
argsObj
)
;
}
current
-
>
add
(
MStart
:
:
New
(
alloc
(
)
)
)
;
MCheckOverRecursed
*
check
=
MCheckOverRecursed
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
check
)
;
MResumePoint
*
entryRpCopy
=
MResumePoint
:
:
Copy
(
alloc
(
)
current
-
>
entryResumePoint
(
)
)
;
if
(
!
entryRpCopy
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
check
-
>
setResumePoint
(
entryRpCopy
)
;
MOZ_TRY
(
rewriteParameters
(
)
)
;
MOZ_TRY
(
initEnvironmentChain
(
)
)
;
if
(
info
(
)
.
needsArgsObj
(
)
)
{
initArgumentsObject
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
endArgSlot
(
)
;
i
+
+
)
{
MInstruction
*
ins
=
current
-
>
getEntrySlot
(
i
)
-
>
toInstruction
(
)
;
if
(
ins
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
continue
;
}
MResumePoint
*
entryRpCopy
=
MResumePoint
:
:
Copy
(
alloc
(
)
current
-
>
entryResumePoint
(
)
)
;
if
(
!
entryRpCopy
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
ins
-
>
setResumePoint
(
entryRpCopy
)
;
}
#
ifdef
DEBUG
if
(
info
(
)
.
hasArguments
(
)
&
&
!
info
(
)
.
argsObjAliasesFormals
(
)
)
{
hasLazyArguments_
=
true
;
}
#
endif
insertRecompileCheck
(
pc
)
;
auto
clearLastPriorResumePoint
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
replaceMaybeFallbackFunctionGetter
(
nullptr
)
;
}
)
;
MOZ_TRY
(
traverseBytecode
(
)
)
;
if
(
isHighestOptimizationLevel
(
)
&
&
inlinedBytecodeLength_
>
script_
-
>
jitScript
(
)
-
>
inlinedBytecodeLength
(
)
)
{
script_
-
>
jitScript
(
)
-
>
setInlinedBytecodeLength
(
inlinedBytecodeLength_
)
;
}
MOZ_TRY
(
maybeAddOsrTypeBarriers
(
)
)
;
if
(
!
MPhi
:
:
markIteratorPhis
(
iterators_
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
info
(
)
.
isAnalysis
(
)
&
&
!
abortedPreliminaryGroups
(
)
.
empty
(
)
)
{
return
abort
(
AbortReason
:
:
PreliminaryObjects
)
;
}
MOZ_ASSERT
(
loopDepth_
=
=
0
)
;
MOZ_ASSERT
(
loopStack_
.
empty
(
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
buildInline
(
IonBuilder
*
callerBuilder
MResumePoint
*
callerResumePoint
CallInfo
&
callInfo
)
{
inlineCallInfo_
=
&
callInfo
;
#
ifdef
JS_STRUCTURED_SPEW
if
(
!
info
(
)
.
isAnalysis
(
)
)
{
JitSpewBaselineICStats
(
script
(
)
"
To
-
Be
-
Inlined
"
)
;
}
#
endif
MOZ_TRY
(
init
(
)
)
;
JitSpew
(
JitSpew_IonScripts
"
Inlining
script
%
s
:
%
u
:
%
u
(
%
p
)
"
script
(
)
-
>
filename
(
)
script
(
)
-
>
lineno
(
)
script
(
)
-
>
column
(
)
(
void
*
)
script
(
)
)
;
callerBuilder_
=
callerBuilder
;
callerResumePoint_
=
callerResumePoint
;
if
(
callerBuilder
-
>
failedBoundsCheck_
)
{
failedBoundsCheck_
=
true
;
}
if
(
callerBuilder
-
>
failedShapeGuard_
)
{
failedShapeGuard_
=
true
;
}
if
(
callerBuilder
-
>
failedLexicalCheck_
)
{
failedLexicalCheck_
=
true
;
}
MBasicBlock
*
entry
;
MOZ_TRY_VAR
(
entry
newBlock
(
info
(
)
.
firstStackSlot
(
)
pc
)
)
;
MOZ_TRY
(
setCurrentAndSpecializePhis
(
entry
)
)
;
current
-
>
setCallerResumePoint
(
callerResumePoint
)
;
MBasicBlock
*
predecessor
=
callerBuilder
-
>
current
;
MOZ_ASSERT
(
predecessor
=
=
callerResumePoint
-
>
block
(
)
)
;
predecessor
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
current
)
)
;
if
(
!
current
-
>
addPredecessorWithoutPhis
(
predecessor
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MInstruction
*
env
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
env
)
;
current
-
>
initSlot
(
info
(
)
.
environmentChainSlot
(
)
env
)
;
MInstruction
*
returnValue
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
returnValue
)
;
current
-
>
initSlot
(
info
(
)
.
returnValueSlot
(
)
returnValue
)
;
if
(
info
(
)
.
hasArguments
(
)
)
{
MInstruction
*
argsObj
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
argsObj
)
;
current
-
>
initSlot
(
info
(
)
.
argsObjSlot
(
)
argsObj
)
;
}
current
-
>
initSlot
(
info
(
)
.
thisSlot
(
)
callInfo
.
thisArg
(
)
)
;
JitSpew
(
JitSpew_Inlining
"
Initializing
%
u
arg
slots
"
info
(
)
.
nargs
(
)
)
;
MOZ_ASSERT
(
!
info
(
)
.
needsArgsObj
(
)
)
;
uint32_t
existing_args
=
std
:
:
min
<
uint32_t
>
(
callInfo
.
argc
(
)
info
(
)
.
nargs
(
)
)
;
for
(
size_t
i
=
0
;
i
<
existing_args
;
+
+
i
)
{
MDefinition
*
arg
=
callInfo
.
getArg
(
i
)
;
current
-
>
initSlot
(
info
(
)
.
argSlot
(
i
)
arg
)
;
}
for
(
size_t
i
=
callInfo
.
argc
(
)
;
i
<
info
(
)
.
nargs
(
)
;
+
+
i
)
{
MConstant
*
arg
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
arg
)
;
current
-
>
initSlot
(
info
(
)
.
argSlot
(
i
)
arg
)
;
}
JitSpew
(
JitSpew_Inlining
"
Initializing
%
u
locals
"
info
(
)
.
nlocals
(
)
)
;
initLocals
(
)
;
JitSpew
(
JitSpew_Inlining
"
Inline
entry
block
MResumePoint
%
p
%
u
stack
slots
"
(
void
*
)
current
-
>
entryResumePoint
(
)
current
-
>
entryResumePoint
(
)
-
>
stackDepth
(
)
)
;
MOZ_ASSERT
(
current
-
>
entryResumePoint
(
)
-
>
stackDepth
(
)
=
=
info
(
)
.
totalSlots
(
)
)
;
#
ifdef
DEBUG
if
(
script_
-
>
argumentsHasVarBinding
(
)
)
{
hasLazyArguments_
=
true
;
}
#
endif
insertRecompileCheck
(
pc
)
;
MOZ_TRY
(
initEnvironmentChain
(
callInfo
.
callee
(
)
)
)
;
auto
clearLastPriorResumePoint
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
replaceMaybeFallbackFunctionGetter
(
nullptr
)
;
}
)
;
MOZ_TRY
(
traverseBytecode
(
)
)
;
MOZ_ASSERT
(
iterators_
.
empty
(
)
"
Iterators
should
be
added
to
outer
builder
"
)
;
if
(
!
info
(
)
.
isAnalysis
(
)
&
&
!
abortedPreliminaryGroups
(
)
.
empty
(
)
)
{
return
abort
(
AbortReason
:
:
PreliminaryObjects
)
;
}
return
Ok
(
)
;
}
void
IonBuilder
:
:
rewriteParameter
(
uint32_t
slotIdx
MDefinition
*
param
)
{
MOZ_ASSERT
(
param
-
>
isParameter
(
)
|
|
param
-
>
isGetArgumentsObjectArg
(
)
)
;
TemporaryTypeSet
*
types
=
param
-
>
resultTypeSet
(
)
;
MDefinition
*
actual
=
ensureDefiniteType
(
param
types
-
>
getKnownMIRType
(
)
)
;
if
(
actual
=
=
param
)
{
return
;
}
current
-
>
rewriteSlot
(
slotIdx
actual
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
rewriteParameters
(
)
{
MOZ_ASSERT
(
info
(
)
.
environmentChainSlot
(
)
=
=
0
)
;
if
(
!
info
(
)
.
funMaybeLazy
(
)
)
{
return
Ok
(
)
;
}
for
(
uint32_t
i
=
info
(
)
.
startArgSlot
(
)
;
i
<
info
(
)
.
endArgSlot
(
)
;
i
+
+
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MDefinition
*
param
=
current
-
>
getSlot
(
i
)
;
rewriteParameter
(
i
param
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initParameters
(
)
{
if
(
!
info
(
)
.
funMaybeLazy
(
)
)
{
return
Ok
(
)
;
}
if
(
thisTypes
-
>
empty
(
)
&
&
baselineFrame_
)
{
TypeSet
:
:
Type
type
=
baselineFrame_
-
>
thisType
;
if
(
type
.
isSingletonUnchecked
(
)
)
{
checkNurseryObject
(
type
.
singleton
(
)
)
;
}
thisTypes
-
>
addType
(
type
alloc_
-
>
lifoAlloc
(
)
)
;
}
MParameter
*
param
=
MParameter
:
:
New
(
alloc
(
)
MParameter
:
:
THIS_SLOT
thisTypes
)
;
current
-
>
add
(
param
)
;
current
-
>
initSlot
(
info
(
)
.
thisSlot
(
)
param
)
;
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nargs
(
)
;
i
+
+
)
{
TemporaryTypeSet
*
types
=
&
argTypes
[
i
]
;
if
(
types
-
>
empty
(
)
&
&
baselineFrame_
&
&
!
script_
-
>
jitScript
(
)
-
>
modifiesArguments
(
)
)
{
TypeSet
:
:
Type
type
=
baselineFrame_
-
>
argTypes
[
i
]
;
if
(
type
.
isSingletonUnchecked
(
)
)
{
checkNurseryObject
(
type
.
singleton
(
)
)
;
}
types
-
>
addType
(
type
alloc_
-
>
lifoAlloc
(
)
)
;
}
param
=
MParameter
:
:
New
(
alloc
(
)
.
fallible
(
)
i
types
)
;
if
(
!
param
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
add
(
param
)
;
current
-
>
initSlot
(
info
(
)
.
argSlotUnchecked
(
i
)
param
)
;
}
return
Ok
(
)
;
}
void
IonBuilder
:
:
initLocals
(
)
{
if
(
info
(
)
.
nlocals
(
)
=
=
0
)
{
return
;
}
MConstant
*
undef
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
undef
)
;
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nlocals
(
)
;
i
+
+
)
{
current
-
>
initSlot
(
info
(
)
.
localSlot
(
i
)
undef
)
;
}
}
bool
IonBuilder
:
:
usesEnvironmentChain
(
)
{
return
script
(
)
-
>
jitScript
(
)
-
>
usesEnvironmentChain
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initEnvironmentChain
(
MDefinition
*
callee
)
{
MInstruction
*
env
=
nullptr
;
if
(
!
info
(
)
.
needsArgsObj
(
)
&
&
!
usesEnvironmentChain
(
)
)
{
return
Ok
(
)
;
}
if
(
JSFunction
*
fun
=
info
(
)
.
funMaybeLazy
(
)
)
{
if
(
!
callee
)
{
MCallee
*
calleeIns
=
MCallee
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
calleeIns
)
;
callee
=
calleeIns
;
}
env
=
MFunctionEnvironment
:
:
New
(
alloc
(
)
callee
)
;
current
-
>
add
(
env
)
;
if
(
fun
-
>
needsSomeEnvironmentObject
(
)
&
&
info
(
)
.
analysisMode
(
)
!
=
Analysis_ArgumentsUsage
)
{
if
(
fun
-
>
needsNamedLambdaEnvironment
(
)
)
{
env
=
createNamedLambdaObject
(
callee
env
)
;
}
if
(
fun
-
>
needsExtraBodyVarEnvironment
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Extra
var
environment
unsupported
"
)
;
}
if
(
fun
-
>
needsCallObject
(
)
)
{
MOZ_TRY_VAR
(
env
createCallObject
(
callee
env
)
)
;
}
}
}
else
if
(
ModuleObject
*
module
=
info
(
)
.
module
(
)
)
{
env
=
constant
(
ObjectValue
(
module
-
>
initialEnvironment
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
!
script
(
)
-
>
isForEval
(
)
)
;
MOZ_ASSERT
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
;
env
=
constant
(
ObjectValue
(
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
)
)
;
}
current
-
>
setEnvironmentChain
(
env
)
;
return
Ok
(
)
;
}
void
IonBuilder
:
:
initArgumentsObject
(
)
{
JitSpew
(
JitSpew_IonMIR
"
%
s
:
%
u
:
%
u
-
Emitting
code
to
initialize
arguments
object
!
block
=
%
p
"
script
(
)
-
>
filename
(
)
script
(
)
-
>
lineno
(
)
script
(
)
-
>
column
(
)
current
)
;
MOZ_ASSERT
(
info
(
)
.
needsArgsObj
(
)
)
;
bool
mapped
=
script
(
)
-
>
hasMappedArgsObj
(
)
;
ArgumentsObject
*
templateObj
=
script
(
)
-
>
realm
(
)
-
>
maybeArgumentsTemplateObject
(
mapped
)
;
MCreateArgumentsObject
*
argsObj
=
MCreateArgumentsObject
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
templateObj
)
;
current
-
>
add
(
argsObj
)
;
current
-
>
setArgumentsObject
(
argsObj
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
addOsrValueTypeBarrier
(
uint32_t
slot
MInstruction
*
*
def_
MIRType
type
TemporaryTypeSet
*
typeSet
)
{
MInstruction
*
&
def
=
*
def_
;
MBasicBlock
*
osrBlock
=
def
-
>
block
(
)
;
def
-
>
setResultType
(
MIRType
:
:
Value
)
;
def
-
>
setResultTypeSet
(
nullptr
)
;
if
(
typeSet
&
&
!
typeSet
-
>
unknown
(
)
)
{
MInstruction
*
barrier
=
MTypeBarrier
:
:
New
(
alloc
(
)
def
typeSet
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
barrier
)
;
osrBlock
-
>
rewriteSlot
(
slot
barrier
)
;
def
=
barrier
;
if
(
type
=
=
MIRType
:
:
Value
)
{
type
=
barrier
-
>
type
(
)
;
}
}
else
if
(
type
=
=
MIRType
:
:
Null
|
|
type
=
=
MIRType
:
:
Undefined
|
|
type
=
=
MIRType
:
:
MagicOptimizedArguments
)
{
TypeSet
:
:
Type
ntype
=
TypeSet
:
:
PrimitiveType
(
type
)
;
LifoAlloc
*
lifoAlloc
=
alloc
(
)
.
lifoAlloc
(
)
;
typeSet
=
lifoAlloc
-
>
new_
<
TemporaryTypeSet
>
(
lifoAlloc
ntype
)
;
if
(
!
typeSet
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MInstruction
*
barrier
=
MTypeBarrier
:
:
New
(
alloc
(
)
def
typeSet
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
barrier
)
;
osrBlock
-
>
rewriteSlot
(
slot
barrier
)
;
def
=
barrier
;
}
switch
(
type
)
{
case
MIRType
:
:
Null
:
case
MIRType
:
:
Undefined
:
case
MIRType
:
:
MagicOptimizedArguments
:
def
-
>
setImplicitlyUsed
(
)
;
break
;
default
:
break
;
}
switch
(
type
)
{
case
MIRType
:
:
Boolean
:
case
MIRType
:
:
Int32
:
case
MIRType
:
:
Double
:
case
MIRType
:
:
String
:
case
MIRType
:
:
Symbol
:
case
MIRType
:
:
BigInt
:
case
MIRType
:
:
Object
:
if
(
type
!
=
def
-
>
type
(
)
)
{
MUnbox
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
def
type
MUnbox
:
:
Fallible
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
unbox
)
;
osrBlock
-
>
rewriteSlot
(
slot
unbox
)
;
def
=
unbox
;
}
break
;
case
MIRType
:
:
Value
:
break
;
case
MIRType
:
:
Null
:
{
MConstant
*
c
=
MConstant
:
:
New
(
alloc
(
)
NullValue
(
)
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
c
)
;
osrBlock
-
>
rewriteSlot
(
slot
c
)
;
def
=
c
;
break
;
}
case
MIRType
:
:
Undefined
:
{
MConstant
*
c
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
c
)
;
osrBlock
-
>
rewriteSlot
(
slot
c
)
;
def
=
c
;
break
;
}
case
MIRType
:
:
MagicOptimizedArguments
:
{
MOZ_ASSERT
(
hasLazyArguments_
)
;
MConstant
*
lazyArg
=
MConstant
:
:
New
(
alloc
(
)
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
)
;
osrBlock
-
>
insertBefore
(
osrBlock
-
>
lastIns
(
)
lazyArg
)
;
osrBlock
-
>
rewriteSlot
(
slot
lazyArg
)
;
def
=
lazyArg
;
break
;
}
default
:
MOZ_CRASH
(
"
Unexpected
type
"
)
;
}
MOZ_ASSERT
(
def
=
=
osrBlock
-
>
getSlot
(
slot
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
maybeAddOsrTypeBarriers
(
)
{
if
(
!
info
(
)
.
osrPc
(
)
)
{
return
Ok
(
)
;
}
MBasicBlock
*
osrBlock
=
graph
(
)
.
osrBlock
(
)
;
MOZ_ASSERT
(
osrBlock
)
;
MBasicBlock
*
preheader
=
osrBlock
-
>
getSuccessor
(
0
)
;
MBasicBlock
*
header
=
preheader
-
>
getSuccessor
(
0
)
;
static
const
size_t
OSR_PHI_POSITION
=
1
;
MOZ_ASSERT
(
preheader
-
>
getPredecessor
(
OSR_PHI_POSITION
)
=
=
osrBlock
)
;
MResumePoint
*
headerRp
=
header
-
>
entryResumePoint
(
)
;
size_t
stackDepth
=
headerRp
-
>
stackDepth
(
)
;
MOZ_ASSERT
(
stackDepth
=
=
osrBlock
-
>
stackDepth
(
)
)
;
for
(
uint32_t
slot
=
info
(
)
.
startArgSlot
(
)
;
slot
<
stackDepth
;
slot
+
+
)
{
if
(
info
(
)
.
isSlotAliased
(
slot
)
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MInstruction
*
def
=
osrBlock
-
>
getSlot
(
slot
)
-
>
toInstruction
(
)
;
MPhi
*
preheaderPhi
=
preheader
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
MPhi
*
headerPhi
=
headerRp
-
>
getOperand
(
slot
)
-
>
toPhi
(
)
;
MIRType
type
=
headerPhi
-
>
type
(
)
;
TemporaryTypeSet
*
typeSet
=
headerPhi
-
>
resultTypeSet
(
)
;
MOZ_TRY
(
addOsrValueTypeBarrier
(
slot
&
def
type
typeSet
)
)
;
preheaderPhi
-
>
replaceOperand
(
OSR_PHI_POSITION
def
)
;
preheaderPhi
-
>
setResultType
(
type
)
;
preheaderPhi
-
>
setResultTypeSet
(
typeSet
)
;
}
return
Ok
(
)
;
}
#
ifdef
DEBUG
class
MOZ_RAII
PoppedValueUseChecker
{
Vector
<
MDefinition
*
4
SystemAllocPolicy
>
popped_
;
Vector
<
size_t
4
SystemAllocPolicy
>
poppedUses_
;
MBasicBlock
*
current_
;
jsbytecode
*
pc_
;
public
:
PoppedValueUseChecker
(
MBasicBlock
*
current
jsbytecode
*
pc
)
:
current_
(
current
)
pc_
(
pc
)
{
}
MOZ_MUST_USE
bool
init
(
)
{
unsigned
nuses
=
GetUseCount
(
pc_
)
;
for
(
unsigned
i
=
0
;
i
<
nuses
;
i
+
+
)
{
MDefinition
*
def
=
current_
-
>
peek
(
-
int32_t
(
i
+
1
)
)
;
if
(
!
popped_
.
append
(
def
)
|
|
!
poppedUses_
.
append
(
def
-
>
defUseCount
(
)
)
)
{
return
false
;
}
}
return
true
;
}
void
checkAfterOp
(
)
{
JSOp
op
=
JSOp
(
*
pc_
)
;
switch
(
op
)
{
case
JSOp
:
:
Pop
:
case
JSOp
:
:
PopN
:
case
JSOp
:
:
DupAt
:
case
JSOp
:
:
Dup
:
case
JSOp
:
:
Dup2
:
case
JSOp
:
:
Pick
:
case
JSOp
:
:
Unpick
:
case
JSOp
:
:
Swap
:
case
JSOp
:
:
SetArg
:
case
JSOp
:
:
SetLocal
:
case
JSOp
:
:
InitLexical
:
case
JSOp
:
:
SetRval
:
case
JSOp
:
:
Void
:
return
;
case
JSOp
:
:
Case
:
case
JSOp
:
:
Default
:
return
;
default
:
break
;
}
for
(
size_t
i
=
0
;
i
<
popped_
.
length
(
)
;
i
+
+
)
{
switch
(
op
)
{
case
JSOp
:
:
Pos
:
case
JSOp
:
:
ToNumeric
:
case
JSOp
:
:
ToPropertyKey
:
case
JSOp
:
:
ToString
:
MOZ_ASSERT
(
i
=
=
0
)
;
if
(
current_
-
>
peek
(
-
1
)
=
=
popped_
[
0
]
)
{
break
;
}
[
[
fallthrough
]
]
;
default
:
MOZ_ASSERT
(
popped_
[
i
]
-
>
isImplicitlyUsed
(
)
|
|
(
op
=
=
JSOp
:
:
EndIter
&
&
i
=
=
0
)
|
|
popped_
[
i
]
-
>
defUseCount
(
)
>
poppedUses_
[
i
]
)
;
break
;
}
}
}
}
;
#
endif
AbortReasonOr
<
Ok
>
IonBuilder
:
:
traverseBytecode
(
)
{
MOZ_TRY
(
startTraversingBlock
(
current
)
)
;
const
jsbytecode
*
const
codeEnd
=
script
(
)
-
>
codeEnd
(
)
;
while
(
true
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
hasTerminatedBlock
(
)
)
{
while
(
!
BytecodeIsJumpTarget
(
JSOp
(
*
pc
)
)
)
{
if
(
!
loopStack_
.
empty
(
)
&
&
IsBackedgeForLoopHead
(
pc
loopStack_
.
back
(
)
.
header
(
)
-
>
pc
(
)
)
)
{
MOZ_ASSERT
(
loopDepth_
>
0
)
;
loopDepth_
-
-
;
loopStack_
.
popBack
(
)
;
}
pc
=
GetNextPc
(
pc
)
;
if
(
pc
=
=
codeEnd
)
{
return
Ok
(
)
;
}
}
}
#
ifdef
DEBUG
PoppedValueUseChecker
useChecker
(
current
pc
)
;
if
(
!
useChecker
.
init
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
#
endif
MOZ_ASSERT
(
script
(
)
-
>
containsPC
(
pc
)
)
;
nextpc
=
GetNextPc
(
pc
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
bool
restarted
=
false
;
MOZ_TRY
(
inspectOpcode
(
op
&
restarted
)
)
;
#
ifdef
DEBUG
if
(
!
restarted
)
{
useChecker
.
checkAfterOp
(
)
;
}
#
endif
if
(
nextpc
=
=
codeEnd
)
{
return
Ok
(
)
;
}
pc
=
nextpc
;
MOZ_ASSERT
(
script
(
)
-
>
containsPC
(
pc
)
)
;
if
(
!
hasTerminatedBlock
(
)
)
{
current
-
>
updateTrackedSite
(
bytecodeSite
(
pc
)
)
;
}
}
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
startTraversingBlock
(
MBasicBlock
*
block
)
{
block
-
>
setLoopDepth
(
loopDepth_
)
;
if
(
block
-
>
pc
(
)
&
&
script
(
)
-
>
hasScriptCounts
(
)
)
{
block
-
>
setHitCount
(
script
(
)
-
>
getHitCount
(
block
-
>
pc
(
)
)
)
;
}
if
(
block
-
>
numPredecessors
(
)
=
=
1
&
&
block
-
>
getPredecessor
(
0
)
-
>
numSuccessors
(
)
=
=
1
&
&
!
block
-
>
getPredecessor
(
0
)
-
>
outerResumePoint
(
)
)
{
graph
(
)
.
removeBlockFromList
(
block
-
>
getPredecessor
(
0
)
)
;
graph
(
)
.
addBlock
(
block
-
>
getPredecessor
(
0
)
)
;
}
MOZ_TRY
(
setCurrentAndSpecializePhis
(
block
)
)
;
graph
(
)
.
addBlock
(
block
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_goto
(
bool
*
restarted
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
Goto
)
;
if
(
IsBackedgePC
(
pc
)
)
{
return
visitBackEdge
(
restarted
)
;
}
jsbytecode
*
target
=
pc
+
GET_JUMP_OFFSET
(
pc
)
;
return
visitGoto
(
target
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
addPendingEdge
(
const
PendingEdge
&
edge
jsbytecode
*
target
)
{
PendingEdgesMap
:
:
AddPtr
p
=
pendingEdges_
.
lookupForAdd
(
target
)
;
if
(
p
)
{
if
(
!
p
-
>
value
(
)
.
append
(
edge
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
Ok
(
)
;
}
PendingEdges
edges
;
static_assert
(
PendingEdges
:
:
InlineLength
>
=
1
"
Appending
one
element
should
be
infallible
"
)
;
MOZ_ALWAYS_TRUE
(
edges
.
append
(
edge
)
)
;
if
(
!
pendingEdges_
.
add
(
p
target
std
:
:
move
(
edges
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitGoto
(
jsbytecode
*
target
)
{
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
nullptr
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewGoto
(
current
)
target
)
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_loophead
(
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
if
(
hasTerminatedBlock
(
)
)
{
return
Ok
(
)
;
}
bool
osr
=
pc
=
=
info
(
)
.
osrPc
(
)
;
if
(
osr
)
{
MBasicBlock
*
preheader
;
MOZ_TRY_VAR
(
preheader
newOsrPreheader
(
current
pc
)
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
preheader
)
)
;
MOZ_TRY
(
setCurrentAndSpecializePhis
(
preheader
)
)
;
}
loopDepth_
+
+
;
MBasicBlock
*
header
;
MOZ_TRY_VAR
(
header
newPendingLoopHeader
(
current
pc
osr
)
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
header
)
)
;
if
(
!
loopStack_
.
emplaceBack
(
header
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_TRY
(
analyzeNewLoopTypes
(
header
)
)
;
MOZ_TRY
(
startTraversingBlock
(
header
)
)
;
return
emitLoopHeadInstructions
(
pc
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitBackEdge
(
bool
*
restarted
)
{
MOZ_ASSERT
(
loopDepth_
>
0
)
;
loopDepth_
-
-
;
MBasicBlock
*
header
=
loopStack_
.
back
(
)
.
header
(
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
header
)
)
;
AbortReason
r
=
header
-
>
setBackedge
(
alloc
(
)
current
)
;
switch
(
r
)
{
case
AbortReason
:
:
NoAbort
:
loopStack_
.
popBack
(
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
case
AbortReason
:
:
Disable
:
*
restarted
=
true
;
MOZ_TRY
(
restartLoop
(
header
)
)
;
return
Ok
(
)
;
default
:
return
abort
(
r
)
;
}
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
emitLoopHeadInstructions
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
MInterruptCheck
*
check
=
MInterruptCheck
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
check
)
;
insertRecompileCheck
(
pc
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
inspectOpcode
(
JSOp
op
bool
*
restarted
)
{
switch
(
op
)
{
case
JSOp
:
:
NopDestructuring
:
case
JSOp
:
:
Lineno
:
case
JSOp
:
:
Nop
:
return
Ok
(
)
;
case
JSOp
:
:
TryDestructuring
:
graph
(
)
.
setHasTryBlock
(
)
;
return
Ok
(
)
;
case
JSOp
:
:
LoopHead
:
return
jsop_loophead
(
)
;
case
JSOp
:
:
Undefined
:
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Try
:
return
visitTry
(
)
;
case
JSOp
:
:
Default
:
current
-
>
pop
(
)
;
return
visitGoto
(
pc
+
GET_JUMP_OFFSET
(
pc
)
)
;
case
JSOp
:
:
Goto
:
return
jsop_goto
(
restarted
)
;
case
JSOp
:
:
IfNe
:
case
JSOp
:
:
IfEq
:
case
JSOp
:
:
And
:
case
JSOp
:
:
Or
:
case
JSOp
:
:
Case
:
return
visitTest
(
op
restarted
)
;
case
JSOp
:
:
Coalesce
:
return
jsop_coalesce
(
)
;
case
JSOp
:
:
Return
:
case
JSOp
:
:
RetRval
:
return
visitReturn
(
op
)
;
case
JSOp
:
:
Throw
:
return
visitThrow
(
)
;
case
JSOp
:
:
JumpTarget
:
return
visitJumpTarget
(
op
)
;
case
JSOp
:
:
TableSwitch
:
return
visitTableSwitch
(
)
;
case
JSOp
:
:
BitNot
:
return
jsop_bitnot
(
)
;
case
JSOp
:
:
BitAnd
:
case
JSOp
:
:
BitOr
:
case
JSOp
:
:
BitXor
:
case
JSOp
:
:
Lsh
:
case
JSOp
:
:
Rsh
:
case
JSOp
:
:
Ursh
:
return
jsop_bitop
(
op
)
;
case
JSOp
:
:
Add
:
case
JSOp
:
:
Sub
:
case
JSOp
:
:
Mul
:
case
JSOp
:
:
Div
:
case
JSOp
:
:
Mod
:
return
jsop_binary_arith
(
op
)
;
case
JSOp
:
:
Pow
:
return
jsop_pow
(
)
;
case
JSOp
:
:
Pos
:
return
jsop_pos
(
)
;
case
JSOp
:
:
ToNumeric
:
return
jsop_tonumeric
(
)
;
case
JSOp
:
:
Neg
:
return
jsop_neg
(
)
;
case
JSOp
:
:
Inc
:
case
JSOp
:
:
Dec
:
return
jsop_inc_or_dec
(
op
)
;
case
JSOp
:
:
ToString
:
return
jsop_tostring
(
)
;
case
JSOp
:
:
DefVar
:
return
jsop_defvar
(
)
;
case
JSOp
:
:
DefLet
:
case
JSOp
:
:
DefConst
:
return
jsop_deflexical
(
)
;
case
JSOp
:
:
DefFun
:
return
jsop_deffun
(
)
;
case
JSOp
:
:
CheckGlobalOrEvalDecl
:
return
jsop_checkGlobalOrEvalDecl
(
)
;
case
JSOp
:
:
Eq
:
case
JSOp
:
:
Ne
:
case
JSOp
:
:
StrictEq
:
case
JSOp
:
:
StrictNe
:
case
JSOp
:
:
Lt
:
case
JSOp
:
:
Le
:
case
JSOp
:
:
Gt
:
case
JSOp
:
:
Ge
:
return
jsop_compare
(
op
)
;
case
JSOp
:
:
Double
:
pushConstant
(
GET_INLINE_VALUE
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
BigInt
:
pushConstant
(
BigIntValue
(
info
(
)
.
getBigInt
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
String
:
pushConstant
(
StringValue
(
info
(
)
.
getAtom
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Symbol
:
{
unsigned
which
=
GET_UINT8
(
pc
)
;
JS
:
:
Symbol
*
sym
=
realm
-
>
runtime
(
)
-
>
wellKnownSymbols
(
)
.
get
(
which
)
;
pushConstant
(
SymbolValue
(
sym
)
)
;
return
Ok
(
)
;
}
case
JSOp
:
:
Zero
:
pushConstant
(
Int32Value
(
0
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
One
:
pushConstant
(
Int32Value
(
1
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Null
:
pushConstant
(
NullValue
(
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Void
:
current
-
>
pop
(
)
;
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Hole
:
pushConstant
(
MagicValue
(
JS_ELEMENTS_HOLE
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
False
:
pushConstant
(
BooleanValue
(
false
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
True
:
pushConstant
(
BooleanValue
(
true
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Arguments
:
return
jsop_arguments
(
)
;
case
JSOp
:
:
Rest
:
return
jsop_rest
(
)
;
case
JSOp
:
:
GetArg
:
return
jsop_getarg
(
GET_ARGNO
(
pc
)
)
;
case
JSOp
:
:
SetArg
:
return
jsop_setarg
(
GET_ARGNO
(
pc
)
)
;
case
JSOp
:
:
GetLocal
:
current
-
>
pushLocal
(
GET_LOCALNO
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
SetLocal
:
current
-
>
setLocal
(
GET_LOCALNO
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
ThrowSetConst
:
return
jsop_throwsetconst
(
)
;
case
JSOp
:
:
CheckLexical
:
case
JSOp
:
:
CheckAliasedLexical
:
return
jsop_checklexical
(
)
;
case
JSOp
:
:
InitLexical
:
current
-
>
setLocal
(
GET_LOCALNO
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
InitGLexical
:
{
MOZ_ASSERT
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
;
MDefinition
*
value
=
current
-
>
pop
(
)
;
current
-
>
push
(
constant
(
ObjectValue
(
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
)
)
)
;
current
-
>
push
(
value
)
;
return
jsop_setprop
(
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
)
;
}
case
JSOp
:
:
InitAliasedLexical
:
return
jsop_setaliasedvar
(
EnvironmentCoordinate
(
pc
)
)
;
case
JSOp
:
:
Uninitialized
:
pushConstant
(
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Pop
:
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
if
(
JSOp
(
pc
[
JSOpLength_Pop
]
)
=
=
JSOp
:
:
Pop
)
{
return
Ok
(
)
;
}
if
(
def
-
>
isConstant
(
)
)
{
return
Ok
(
)
;
}
return
maybeInsertResume
(
)
;
}
case
JSOp
:
:
PopN
:
for
(
uint32_t
i
=
0
n
=
GET_UINT16
(
pc
)
;
i
<
n
;
i
+
+
)
{
current
-
>
pop
(
)
;
}
return
Ok
(
)
;
case
JSOp
:
:
DupAt
:
current
-
>
pushSlot
(
current
-
>
stackDepth
(
)
-
1
-
GET_UINT24
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
NewArray
:
return
jsop_newarray
(
GET_UINT32
(
pc
)
)
;
case
JSOp
:
:
NewArrayCopyOnWrite
:
return
jsop_newarray_copyonwrite
(
)
;
case
JSOp
:
:
NewInit
:
case
JSOp
:
:
NewObject
:
case
JSOp
:
:
NewObjectWithGroup
:
return
jsop_newobject
(
)
;
case
JSOp
:
:
InitElem
:
case
JSOp
:
:
InitHiddenElem
:
case
JSOp
:
:
InitLockedElem
:
return
jsop_initelem
(
)
;
case
JSOp
:
:
InitElemInc
:
return
jsop_initelem_inc
(
)
;
case
JSOp
:
:
InitElemArray
:
return
jsop_initelem_array
(
)
;
case
JSOp
:
:
InitProp
:
case
JSOp
:
:
InitLockedProp
:
case
JSOp
:
:
InitHiddenProp
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_initprop
(
name
)
;
}
case
JSOp
:
:
MutateProto
:
{
return
jsop_mutateproto
(
)
;
}
case
JSOp
:
:
InitPropGetter
:
case
JSOp
:
:
InitHiddenPropGetter
:
case
JSOp
:
:
InitPropSetter
:
case
JSOp
:
:
InitHiddenPropSetter
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_initprop_getter_setter
(
name
)
;
}
case
JSOp
:
:
InitElemGetter
:
case
JSOp
:
:
InitHiddenElemGetter
:
case
JSOp
:
:
InitElemSetter
:
case
JSOp
:
:
InitHiddenElemSetter
:
return
jsop_initelem_getter_setter
(
)
;
case
JSOp
:
:
FunCall
:
return
jsop_funcall
(
GET_ARGC
(
pc
)
)
;
case
JSOp
:
:
FunApply
:
return
jsop_funapply
(
GET_ARGC
(
pc
)
)
;
case
JSOp
:
:
SpreadCall
:
return
jsop_spreadcall
(
)
;
case
JSOp
:
:
SpreadNew
:
case
JSOp
:
:
SpreadSuperCall
:
return
jsop_spreadnew
(
)
;
case
JSOp
:
:
Call
:
case
JSOp
:
:
CallIgnoresRv
:
case
JSOp
:
:
CallIter
:
case
JSOp
:
:
New
:
case
JSOp
:
:
SuperCall
:
MOZ_TRY
(
jsop_call
(
GET_ARGC
(
pc
)
JSOp
(
*
pc
)
=
=
JSOp
:
:
New
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
SuperCall
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallIgnoresRv
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Eval
:
case
JSOp
:
:
StrictEval
:
return
jsop_eval
(
GET_ARGC
(
pc
)
)
;
case
JSOp
:
:
Int8
:
pushConstant
(
Int32Value
(
GET_INT8
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Uint16
:
pushConstant
(
Int32Value
(
GET_UINT16
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
GetGName
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
if
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
return
jsop_getgname
(
name
)
;
}
return
jsop_getname
(
name
)
;
}
case
JSOp
:
:
SetGName
:
case
JSOp
:
:
StrictSetGName
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
JSObject
*
obj
=
nullptr
;
if
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
obj
=
testGlobalLexicalBinding
(
name
)
;
}
if
(
obj
)
{
return
setStaticName
(
obj
name
)
;
}
return
jsop_setprop
(
name
)
;
}
case
JSOp
:
:
GetName
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_getname
(
name
)
;
}
case
JSOp
:
:
GetIntrinsic
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_intrinsic
(
name
)
;
}
case
JSOp
:
:
GetImport
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_getimport
(
name
)
;
}
case
JSOp
:
:
BindGName
:
if
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
if
(
JSObject
*
env
=
testGlobalLexicalBinding
(
info
(
)
.
getName
(
pc
)
)
)
{
pushConstant
(
ObjectValue
(
*
env
)
)
;
return
Ok
(
)
;
}
}
[
[
fallthrough
]
]
;
case
JSOp
:
:
BindName
:
return
jsop_bindname
(
info
(
)
.
getName
(
pc
)
)
;
case
JSOp
:
:
BindVar
:
return
jsop_bindvar
(
)
;
case
JSOp
:
:
Dup
:
current
-
>
pushSlot
(
current
-
>
stackDepth
(
)
-
1
)
;
return
Ok
(
)
;
case
JSOp
:
:
Dup2
:
return
jsop_dup2
(
)
;
case
JSOp
:
:
Swap
:
current
-
>
swapAt
(
-
1
)
;
return
Ok
(
)
;
case
JSOp
:
:
Pick
:
current
-
>
pick
(
-
GET_INT8
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Unpick
:
current
-
>
unpick
(
-
GET_INT8
(
pc
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
GetAliasedVar
:
return
jsop_getaliasedvar
(
EnvironmentCoordinate
(
pc
)
)
;
case
JSOp
:
:
SetAliasedVar
:
return
jsop_setaliasedvar
(
EnvironmentCoordinate
(
pc
)
)
;
case
JSOp
:
:
Uint24
:
case
JSOp
:
:
ResumeIndex
:
pushConstant
(
Int32Value
(
GET_UINT24
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Int32
:
pushConstant
(
Int32Value
(
GET_INT32
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
GetElem
:
case
JSOp
:
:
CallElem
:
MOZ_TRY
(
jsop_getelem
(
)
)
;
if
(
op
=
=
JSOp
:
:
CallElem
)
{
MOZ_TRY
(
improveThisTypesForCall
(
)
)
;
}
return
Ok
(
)
;
case
JSOp
:
:
SetElem
:
case
JSOp
:
:
StrictSetElem
:
return
jsop_setelem
(
)
;
case
JSOp
:
:
Length
:
return
jsop_length
(
)
;
case
JSOp
:
:
Not
:
return
jsop_not
(
)
;
case
JSOp
:
:
FunctionThis
:
return
jsop_functionthis
(
)
;
case
JSOp
:
:
GlobalThis
:
return
jsop_globalthis
(
)
;
case
JSOp
:
:
Callee
:
{
MDefinition
*
callee
=
getCallee
(
)
;
current
-
>
push
(
callee
)
;
return
Ok
(
)
;
}
case
JSOp
:
:
EnvCallee
:
return
jsop_envcallee
(
)
;
case
JSOp
:
:
SuperBase
:
return
jsop_superbase
(
)
;
case
JSOp
:
:
GetPropSuper
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_getprop_super
(
name
)
;
}
case
JSOp
:
:
GetElemSuper
:
return
jsop_getelem_super
(
)
;
case
JSOp
:
:
GetProp
:
case
JSOp
:
:
CallProp
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
MOZ_TRY
(
jsop_getprop
(
name
)
)
;
if
(
op
=
=
JSOp
:
:
CallProp
)
{
MOZ_TRY
(
improveThisTypesForCall
(
)
)
;
}
return
Ok
(
)
;
}
case
JSOp
:
:
SetProp
:
case
JSOp
:
:
StrictSetProp
:
case
JSOp
:
:
SetName
:
case
JSOp
:
:
StrictSetName
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_setprop
(
name
)
;
}
case
JSOp
:
:
DelProp
:
case
JSOp
:
:
StrictDelProp
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_delprop
(
name
)
;
}
case
JSOp
:
:
DelElem
:
case
JSOp
:
:
StrictDelElem
:
return
jsop_delelem
(
)
;
case
JSOp
:
:
RegExp
:
return
jsop_regexp
(
info
(
)
.
getRegExp
(
pc
)
)
;
case
JSOp
:
:
CallSiteObj
:
pushConstant
(
ObjectValue
(
*
info
(
)
.
getObject
(
pc
)
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Object
:
return
jsop_object
(
info
(
)
.
getObject
(
pc
)
)
;
case
JSOp
:
:
ClassConstructor
:
return
jsop_classconstructor
(
)
;
case
JSOp
:
:
DerivedConstructor
:
return
jsop_derivedclassconstructor
(
)
;
case
JSOp
:
:
Typeof
:
case
JSOp
:
:
TypeofExpr
:
return
jsop_typeof
(
)
;
case
JSOp
:
:
ToAsyncIter
:
return
jsop_toasynciter
(
)
;
case
JSOp
:
:
ToPropertyKey
:
return
jsop_topropertykey
(
)
;
case
JSOp
:
:
IterNext
:
return
jsop_iternext
(
)
;
case
JSOp
:
:
Lambda
:
return
jsop_lambda
(
info
(
)
.
getFunction
(
pc
)
)
;
case
JSOp
:
:
LambdaArrow
:
return
jsop_lambda_arrow
(
info
(
)
.
getFunction
(
pc
)
)
;
case
JSOp
:
:
SetFunName
:
return
jsop_setfunname
(
GET_UINT8
(
pc
)
)
;
case
JSOp
:
:
PushLexicalEnv
:
return
jsop_pushlexicalenv
(
GET_GCTHING_INDEX
(
pc
)
)
;
case
JSOp
:
:
PopLexicalEnv
:
current
-
>
setEnvironmentChain
(
walkEnvironmentChain
(
1
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
FreshenLexicalEnv
:
return
jsop_copylexicalenv
(
true
)
;
case
JSOp
:
:
RecreateLexicalEnv
:
return
jsop_copylexicalenv
(
false
)
;
case
JSOp
:
:
Iter
:
return
jsop_iter
(
)
;
case
JSOp
:
:
MoreIter
:
return
jsop_itermore
(
)
;
case
JSOp
:
:
IsNoIter
:
return
jsop_isnoiter
(
)
;
case
JSOp
:
:
EndIter
:
return
jsop_iterend
(
)
;
case
JSOp
:
:
In
:
return
jsop_in
(
)
;
case
JSOp
:
:
HasOwn
:
return
jsop_hasown
(
)
;
case
JSOp
:
:
CheckPrivateField
:
return
jsop_checkprivatefield
(
)
;
case
JSOp
:
:
SetRval
:
MOZ_ASSERT
(
!
script
(
)
-
>
noScriptRval
(
)
)
;
current
-
>
setSlot
(
info
(
)
.
returnValueSlot
(
)
current
-
>
pop
(
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
Instanceof
:
return
jsop_instanceof
(
)
;
case
JSOp
:
:
DebugLeaveLexicalEnv
:
return
Ok
(
)
;
case
JSOp
:
:
Debugger
:
return
jsop_debugger
(
)
;
case
JSOp
:
:
GImplicitThis
:
if
(
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
}
[
[
fallthrough
]
]
;
case
JSOp
:
:
ImplicitThis
:
{
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_implicitthis
(
name
)
;
}
case
JSOp
:
:
NewTarget
:
return
jsop_newtarget
(
)
;
case
JSOp
:
:
CheckIsObj
:
return
jsop_checkisobj
(
GET_UINT8
(
pc
)
)
;
case
JSOp
:
:
CheckObjCoercible
:
return
jsop_checkobjcoercible
(
)
;
case
JSOp
:
:
DebugCheckSelfHosted
:
{
#
ifdef
DEBUG
MDebugCheckSelfHosted
*
check
=
MDebugCheckSelfHosted
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
check
)
;
current
-
>
push
(
check
)
;
MOZ_TRY
(
resumeAfter
(
check
)
)
;
#
endif
return
Ok
(
)
;
}
case
JSOp
:
:
IsConstructing
:
pushConstant
(
MagicValue
(
JS_IS_CONSTRUCTING
)
)
;
return
Ok
(
)
;
case
JSOp
:
:
OptimizeSpreadCall
:
return
jsop_optimize_spreadcall
(
)
;
case
JSOp
:
:
ImportMeta
:
return
jsop_importmeta
(
)
;
case
JSOp
:
:
DynamicImport
:
return
jsop_dynamic_import
(
)
;
case
JSOp
:
:
InstrumentationActive
:
return
jsop_instrumentation_active
(
)
;
case
JSOp
:
:
InstrumentationCallback
:
return
jsop_instrumentation_callback
(
)
;
case
JSOp
:
:
InstrumentationScriptId
:
return
jsop_instrumentation_scriptid
(
)
;
case
JSOp
:
:
CheckClassHeritage
:
return
jsop_checkclassheritage
(
)
;
case
JSOp
:
:
FunWithProto
:
return
jsop_funwithproto
(
info
(
)
.
getFunction
(
pc
)
)
;
case
JSOp
:
:
ObjWithProto
:
return
jsop_objwithproto
(
)
;
case
JSOp
:
:
BuiltinObject
:
return
jsop_builtinobject
(
)
;
case
JSOp
:
:
CheckReturn
:
return
jsop_checkreturn
(
)
;
case
JSOp
:
:
CheckThis
:
return
jsop_checkthis
(
)
;
case
JSOp
:
:
CheckThisReinit
:
return
jsop_checkthisreinit
(
)
;
case
JSOp
:
:
SuperFun
:
return
jsop_superfun
(
)
;
case
JSOp
:
:
InitHomeObject
:
return
jsop_inithomeobject
(
)
;
case
JSOp
:
:
EnterWith
:
case
JSOp
:
:
LeaveWith
:
case
JSOp
:
:
SpreadEval
:
case
JSOp
:
:
StrictSpreadEval
:
case
JSOp
:
:
SetPropSuper
:
case
JSOp
:
:
SetElemSuper
:
case
JSOp
:
:
StrictSetPropSuper
:
case
JSOp
:
:
StrictSetElemSuper
:
case
JSOp
:
:
PushVarEnv
:
case
JSOp
:
:
GetBoundName
:
case
JSOp
:
:
Exception
:
case
JSOp
:
:
IsGenClosing
:
case
JSOp
:
:
InitialYield
:
case
JSOp
:
:
Yield
:
case
JSOp
:
:
FinalYieldRval
:
case
JSOp
:
:
Resume
:
case
JSOp
:
:
ResumeKind
:
case
JSOp
:
:
CheckResumeKind
:
case
JSOp
:
:
AfterYield
:
case
JSOp
:
:
Await
:
case
JSOp
:
:
TrySkipAwait
:
case
JSOp
:
:
Generator
:
case
JSOp
:
:
AsyncAwait
:
case
JSOp
:
:
AsyncResolve
:
case
JSOp
:
:
DelName
:
case
JSOp
:
:
Finally
:
case
JSOp
:
:
GetRval
:
case
JSOp
:
:
Gosub
:
case
JSOp
:
:
Retsub
:
case
JSOp
:
:
SetIntrinsic
:
case
JSOp
:
:
ThrowMsg
:
break
;
case
JSOp
:
:
ForceInterpreter
:
break
;
}
#
ifdef
DEBUG
return
abort
(
AbortReason
:
:
Disable
"
Unsupported
opcode
:
%
s
"
CodeName
(
op
)
)
;
#
else
return
abort
(
AbortReason
:
:
Disable
"
Unsupported
opcode
:
%
d
"
int
(
uint8_t
(
op
)
)
)
;
#
endif
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
restartLoop
(
MBasicBlock
*
header
)
{
AutoTraceLog
logCompile
(
TraceLoggerForCurrentThread
(
)
TraceLogger_IonBuilderRestartLoop
)
;
spew
(
"
New
types
at
loop
header
restarting
loop
body
"
)
;
if
(
JitOptions
.
limitScriptSize
)
{
if
(
+
+
numLoopRestarts_
>
=
MAX_LOOP_RESTARTS
)
{
return
abort
(
AbortReason
:
:
Disable
"
Aborted
while
processing
control
flow
"
)
;
}
}
size_t
stackDepth
=
header
-
>
entryResumePoint
(
)
-
>
stackDepth
(
)
;
for
(
size_t
slot
=
0
;
slot
<
stackDepth
;
slot
+
+
)
{
MDefinition
*
loopDef
=
header
-
>
entryResumePoint
(
)
-
>
getOperand
(
slot
)
;
header
-
>
setSlot
(
slot
loopDef
)
;
}
for
(
MPhiIterator
phi
=
header
-
>
phisBegin
(
)
;
phi
!
=
header
-
>
phisEnd
(
)
;
phi
+
+
)
{
phi
-
>
removeOperand
(
phi
-
>
numOperands
(
)
-
1
)
;
}
replaceMaybeFallbackFunctionGetter
(
nullptr
)
;
if
(
!
graph
(
)
.
removeSuccessorBlocks
(
header
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
graph
(
)
.
removeBlockFromList
(
header
)
;
header
-
>
discardAllInstructions
(
)
;
header
-
>
discardAllResumePoints
(
false
)
;
header
-
>
setStackDepth
(
header
-
>
getPredecessor
(
0
)
-
>
stackDepth
(
)
)
;
loopDepth_
=
header
-
>
loopDepth
(
)
;
setCurrent
(
header
)
;
graph
(
)
.
addBlock
(
current
)
;
jsbytecode
*
loopHead
=
header
-
>
pc
(
)
;
MOZ_ASSERT
(
JSOp
(
*
loopHead
)
=
=
JSOp
:
:
LoopHead
)
;
MOZ_TRY
(
emitLoopHeadInstructions
(
loopHead
)
)
;
nextpc
=
GetNextPc
(
loopHead
)
;
for
(
PendingEdgesMap
:
:
Range
r
=
pendingEdges_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
PendingEdges
&
blocks
=
r
.
front
(
)
.
value
(
)
;
for
(
size_t
i
=
blocks
.
length
(
)
;
i
>
0
;
i
-
-
)
{
PendingEdge
&
block
=
blocks
[
i
-
1
]
;
if
(
block
.
block
(
)
=
=
header
|
|
block
.
block
(
)
-
>
isDead
(
)
)
{
blocks
.
erase
(
&
block
)
;
}
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
replaceTypeSet
(
MDefinition
*
subject
TemporaryTypeSet
*
type
MTest
*
test
)
{
if
(
type
-
>
unknown
(
)
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
!
type
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
;
if
(
subject
-
>
resultTypeSet
(
)
)
{
if
(
subject
-
>
resultTypeSet
(
)
-
>
equals
(
type
)
)
{
return
Ok
(
)
;
}
}
else
{
TemporaryTypeSet
oldTypes
(
alloc_
-
>
lifoAlloc
(
)
subject
-
>
type
(
)
)
;
if
(
oldTypes
.
equals
(
type
)
)
{
return
Ok
(
)
;
}
}
MInstruction
*
replace
=
nullptr
;
MDefinition
*
ins
;
for
(
uint32_t
i
=
0
;
i
<
current
-
>
stackDepth
(
)
;
i
+
+
)
{
ins
=
current
-
>
getSlot
(
i
)
;
if
(
ins
-
>
isFilterTypeSet
(
)
&
&
ins
-
>
getOperand
(
0
)
=
=
subject
&
&
ins
-
>
dependency
(
)
=
=
test
)
{
TemporaryTypeSet
*
intersect
=
TypeSet
:
:
intersectSets
(
ins
-
>
resultTypeSet
(
)
type
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
!
intersect
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
ins
-
>
toFilterTypeSet
(
)
-
>
setResultType
(
intersect
-
>
getKnownMIRType
(
)
)
;
ins
-
>
toFilterTypeSet
(
)
-
>
setResultTypeSet
(
intersect
)
;
if
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Undefined
)
{
current
-
>
setSlot
(
i
constant
(
UndefinedValue
(
)
)
)
;
}
else
if
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Null
)
{
current
-
>
setSlot
(
i
constant
(
NullValue
(
)
)
)
;
}
else
if
(
ins
-
>
type
(
)
=
=
MIRType
:
:
MagicOptimizedArguments
)
{
current
-
>
setSlot
(
i
constant
(
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
)
)
;
}
else
{
MOZ_ASSERT
(
!
IsMagicType
(
ins
-
>
type
(
)
)
)
;
}
continue
;
}
if
(
ins
=
=
subject
)
{
if
(
!
replace
)
{
replace
=
MFilterTypeSet
:
:
New
(
alloc
(
)
subject
type
)
;
current
-
>
add
(
replace
)
;
replace
-
>
setDependency
(
test
)
;
if
(
replace
-
>
type
(
)
=
=
MIRType
:
:
Undefined
)
{
replace
=
constant
(
UndefinedValue
(
)
)
;
}
else
if
(
replace
-
>
type
(
)
=
=
MIRType
:
:
Null
)
{
replace
=
constant
(
NullValue
(
)
)
;
}
else
if
(
replace
-
>
type
(
)
=
=
MIRType
:
:
MagicOptimizedArguments
)
{
replace
=
constant
(
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
)
;
}
else
{
MOZ_ASSERT
(
!
IsMagicType
(
ins
-
>
type
(
)
)
)
;
}
}
current
-
>
setSlot
(
i
replace
)
;
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveTypesAtCompare
(
MCompare
*
ins
bool
trueBranch
MTest
*
test
)
{
if
(
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Undefined
|
|
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Null
)
{
return
improveTypesAtNullOrUndefinedCompare
(
ins
trueBranch
test
)
;
}
if
(
(
ins
-
>
lhs
(
)
-
>
isTypeOf
(
)
|
|
ins
-
>
rhs
(
)
-
>
isTypeOf
(
)
)
&
&
(
ins
-
>
lhs
(
)
-
>
isConstant
(
)
|
|
ins
-
>
rhs
(
)
-
>
isConstant
(
)
)
)
{
return
improveTypesAtTypeOfCompare
(
ins
trueBranch
test
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveTypesAtTypeOfCompare
(
MCompare
*
ins
bool
trueBranch
MTest
*
test
)
{
MTypeOf
*
typeOf
=
ins
-
>
lhs
(
)
-
>
isTypeOf
(
)
?
ins
-
>
lhs
(
)
-
>
toTypeOf
(
)
:
ins
-
>
rhs
(
)
-
>
toTypeOf
(
)
;
MConstant
*
constant
=
ins
-
>
lhs
(
)
-
>
isConstant
(
)
?
ins
-
>
lhs
(
)
-
>
toConstant
(
)
:
ins
-
>
rhs
(
)
-
>
toConstant
(
)
;
if
(
constant
-
>
type
(
)
!
=
MIRType
:
:
String
)
{
return
Ok
(
)
;
}
bool
equal
=
ins
-
>
jsop
(
)
=
=
JSOp
:
:
Eq
|
|
ins
-
>
jsop
(
)
=
=
JSOp
:
:
StrictEq
;
bool
notEqual
=
ins
-
>
jsop
(
)
=
=
JSOp
:
:
Ne
|
|
ins
-
>
jsop
(
)
=
=
JSOp
:
:
StrictNe
;
if
(
notEqual
)
{
trueBranch
=
!
trueBranch
;
}
if
(
!
equal
&
&
!
notEqual
)
{
return
Ok
(
)
;
}
MDefinition
*
subject
=
typeOf
-
>
input
(
)
;
TemporaryTypeSet
*
inputTypes
=
subject
-
>
resultTypeSet
(
)
;
TemporaryTypeSet
tmp
;
if
(
!
inputTypes
)
{
if
(
subject
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
Ok
(
)
;
}
inputTypes
=
&
tmp
;
tmp
.
addType
(
TypeSet
:
:
PrimitiveOrAnyObjectType
(
subject
-
>
type
(
)
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
inputTypes
-
>
unknown
(
)
|
|
inputTypes
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
filter
;
const
JSAtomState
&
names
=
mirGen_
.
runtime
-
>
names
(
)
;
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_UNDEFINED
names
)
)
{
filter
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
typeOf
-
>
inputMaybeCallableOrEmulatesUndefined
(
)
&
&
trueBranch
)
{
filter
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_BOOLEAN
names
)
)
{
filter
.
addType
(
TypeSet
:
:
BooleanType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_NUMBER
names
)
)
{
filter
.
addType
(
TypeSet
:
:
Int32Type
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
filter
.
addType
(
TypeSet
:
:
DoubleType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_STRING
names
)
)
{
filter
.
addType
(
TypeSet
:
:
StringType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_SYMBOL
names
)
)
{
filter
.
addType
(
TypeSet
:
:
SymbolType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_BIGINT
names
)
)
{
filter
.
addType
(
TypeSet
:
:
BigIntType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_OBJECT
names
)
)
{
filter
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
trueBranch
)
{
filter
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_FUNCTION
names
)
)
{
if
(
typeOf
-
>
inputMaybeCallableOrEmulatesUndefined
(
)
&
&
trueBranch
)
{
filter
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
}
else
{
return
Ok
(
)
;
}
TemporaryTypeSet
*
type
;
if
(
trueBranch
)
{
type
=
TypeSet
:
:
intersectSets
(
&
filter
inputTypes
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
{
type
=
TypeSet
:
:
removeSet
(
inputTypes
&
filter
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
!
type
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
replaceTypeSet
(
subject
type
test
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveTypesAtNullOrUndefinedCompare
(
MCompare
*
ins
bool
trueBranch
MTest
*
test
)
{
MOZ_ASSERT
(
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Undefined
|
|
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Null
)
;
bool
altersUndefined
altersNull
;
JSOp
op
=
ins
-
>
jsop
(
)
;
switch
(
op
)
{
case
JSOp
:
:
StrictNe
:
case
JSOp
:
:
StrictEq
:
altersUndefined
=
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Undefined
;
altersNull
=
ins
-
>
compareType
(
)
=
=
MCompare
:
:
Compare_Null
;
break
;
case
JSOp
:
:
Ne
:
case
JSOp
:
:
Eq
:
altersUndefined
=
altersNull
=
true
;
break
;
default
:
MOZ_CRASH
(
"
Relational
compares
not
supported
"
)
;
}
MDefinition
*
subject
=
ins
-
>
lhs
(
)
;
TemporaryTypeSet
*
inputTypes
=
subject
-
>
resultTypeSet
(
)
;
MOZ_ASSERT
(
IsNullOrUndefined
(
ins
-
>
rhs
(
)
-
>
type
(
)
)
)
;
TemporaryTypeSet
tmp
;
if
(
!
inputTypes
)
{
if
(
subject
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
Ok
(
)
;
}
inputTypes
=
&
tmp
;
tmp
.
addType
(
TypeSet
:
:
PrimitiveOrAnyObjectType
(
subject
-
>
type
(
)
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
inputTypes
-
>
unknown
(
)
|
|
inputTypes
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
*
type
;
if
(
(
op
=
=
JSOp
:
:
StrictEq
|
|
op
=
=
JSOp
:
:
Eq
)
^
trueBranch
)
{
TemporaryTypeSet
remove
;
if
(
altersUndefined
)
{
remove
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
altersNull
)
{
remove
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
type
=
TypeSet
:
:
removeSet
(
inputTypes
&
remove
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
{
TemporaryTypeSet
base
;
if
(
altersUndefined
)
{
base
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
inputTypes
-
>
maybeEmulatesUndefined
(
constraints
(
)
)
)
{
base
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
}
if
(
altersNull
)
{
base
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
type
=
TypeSet
:
:
intersectSets
(
&
base
inputTypes
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
!
type
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
replaceTypeSet
(
subject
type
test
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveTypesAtTestSuccessor
(
MTest
*
test
MBasicBlock
*
successor
)
{
MOZ_ASSERT
(
successor
-
>
numPredecessors
(
)
=
=
1
)
;
MOZ_ASSERT
(
test
-
>
block
(
)
=
=
successor
-
>
getPredecessor
(
0
)
)
;
MOZ_ASSERT
(
test
-
>
ifTrue
(
)
=
=
successor
|
|
test
-
>
ifFalse
(
)
=
=
successor
)
;
bool
trueBranch
=
test
-
>
ifTrue
(
)
=
=
successor
;
return
improveTypesAtTest
(
test
-
>
getOperand
(
0
)
trueBranch
test
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveTypesAtTest
(
MDefinition
*
ins
bool
trueBranch
MTest
*
test
)
{
switch
(
ins
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
Not
:
return
improveTypesAtTest
(
ins
-
>
toNot
(
)
-
>
getOperand
(
0
)
!
trueBranch
test
)
;
case
MDefinition
:
:
Opcode
:
:
IsObject
:
{
MDefinition
*
subject
=
ins
-
>
getOperand
(
0
)
;
TemporaryTypeSet
*
oldType
=
subject
-
>
resultTypeSet
(
)
;
TemporaryTypeSet
tmp
;
if
(
!
oldType
)
{
if
(
subject
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
Ok
(
)
;
}
oldType
=
&
tmp
;
tmp
.
addType
(
TypeSet
:
:
PrimitiveOrAnyObjectType
(
subject
-
>
type
(
)
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
oldType
-
>
unknown
(
)
|
|
oldType
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
*
type
=
nullptr
;
if
(
trueBranch
)
{
type
=
oldType
-
>
cloneObjectsOnly
(
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
{
type
=
oldType
-
>
cloneWithoutObjects
(
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
!
type
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
replaceTypeSet
(
subject
type
test
)
;
}
case
MDefinition
:
:
Opcode
:
:
IsNullOrUndefined
:
{
MDefinition
*
subject
=
ins
-
>
getOperand
(
0
)
;
TemporaryTypeSet
*
oldType
=
subject
-
>
resultTypeSet
(
)
;
TemporaryTypeSet
tmp
;
if
(
!
oldType
)
{
if
(
subject
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
Ok
(
)
;
}
oldType
=
&
tmp
;
tmp
.
addType
(
TypeSet
:
:
PrimitiveOrAnyObjectType
(
subject
-
>
type
(
)
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
oldType
-
>
unknown
(
)
|
|
oldType
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
filter
;
filter
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
filter
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
TemporaryTypeSet
*
type
;
if
(
trueBranch
)
{
type
=
TypeSet
:
:
intersectSets
(
&
filter
oldType
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
{
type
=
TypeSet
:
:
removeSet
(
oldType
&
filter
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
!
type
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
replaceTypeSet
(
subject
type
test
)
;
}
case
MDefinition
:
:
Opcode
:
:
Compare
:
return
improveTypesAtCompare
(
ins
-
>
toCompare
(
)
trueBranch
test
)
;
default
:
break
;
}
TemporaryTypeSet
*
oldType
=
ins
-
>
resultTypeSet
(
)
;
TemporaryTypeSet
*
type
;
TemporaryTypeSet
tmp
;
if
(
!
oldType
)
{
if
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
Ok
(
)
;
}
oldType
=
&
tmp
;
tmp
.
addType
(
TypeSet
:
:
PrimitiveOrAnyObjectType
(
ins
-
>
type
(
)
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
oldType
-
>
unknown
(
)
|
|
oldType
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
)
{
return
Ok
(
)
;
}
if
(
trueBranch
)
{
TemporaryTypeSet
remove
;
remove
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
remove
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
type
=
TypeSet
:
:
removeSet
(
oldType
&
remove
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
{
TemporaryTypeSet
base
;
base
.
addType
(
TypeSet
:
:
UndefinedType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
NullType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
BooleanType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
Int32Type
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
DoubleType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
StringType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
base
.
addType
(
TypeSet
:
:
BigIntType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
oldType
-
>
maybeEmulatesUndefined
(
constraints
(
)
)
)
{
base
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
type
=
TypeSet
:
:
intersectSets
(
&
base
oldType
alloc_
-
>
lifoAlloc
(
)
)
;
}
if
(
!
type
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
replaceTypeSet
(
ins
type
test
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_dup2
(
)
{
uint32_t
lhsSlot
=
current
-
>
stackDepth
(
)
-
2
;
uint32_t
rhsSlot
=
current
-
>
stackDepth
(
)
-
1
;
current
-
>
pushSlot
(
lhsSlot
)
;
current
-
>
pushSlot
(
rhsSlot
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitTestBackedge
(
JSOp
op
bool
*
restarted
)
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
IfNe
)
;
MOZ_ASSERT
(
loopDepth_
>
0
)
;
MDefinition
*
ins
=
current
-
>
pop
(
)
;
jsbytecode
*
loopHead
=
pc
+
GET_JUMP_OFFSET
(
pc
)
;
MOZ_ASSERT
(
JSOp
(
*
loopHead
)
=
=
JSOp
:
:
LoopHead
)
;
jsbytecode
*
successorPC
=
GetNextPc
(
pc
)
;
MBasicBlock
*
backedge
;
MOZ_TRY_VAR
(
backedge
newBlock
(
current
loopHead
)
)
;
current
-
>
end
(
newTest
(
ins
backedge
nullptr
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
current
op
)
successorPC
)
)
;
MOZ_TRY
(
startTraversingBlock
(
backedge
)
)
;
return
visitBackEdge
(
restarted
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitTest
(
JSOp
op
bool
*
restarted
)
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
IfEq
|
|
op
=
=
JSOp
:
:
IfNe
|
|
op
=
=
JSOp
:
:
And
|
|
op
=
=
JSOp
:
:
Or
|
|
op
=
=
JSOp
:
:
Case
)
;
if
(
IsBackedgePC
(
pc
)
)
{
return
visitTestBackedge
(
op
restarted
)
;
}
jsbytecode
*
target1
=
GetNextPc
(
pc
)
;
jsbytecode
*
target2
=
pc
+
GET_JUMP_OFFSET
(
pc
)
;
bool
mustKeepCondition
=
(
op
=
=
JSOp
:
:
And
|
|
op
=
=
JSOp
:
:
Or
)
;
MDefinition
*
ins
=
mustKeepCondition
?
current
-
>
peek
(
-
1
)
:
current
-
>
pop
(
)
;
if
(
target1
=
=
target2
)
{
ins
-
>
setImplicitlyUsedUnchecked
(
)
;
return
visitGoto
(
target1
)
;
}
MTest
*
mir
=
newTest
(
ins
nullptr
nullptr
)
;
current
-
>
end
(
mir
)
;
if
(
TestTrueTargetIsJoinPoint
(
op
)
)
{
std
:
:
swap
(
target1
target2
)
;
}
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewTestTrue
(
current
op
)
target1
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
current
op
)
target2
)
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_coalesce
(
)
{
jsbytecode
*
target1
=
GetNextPc
(
pc
)
;
jsbytecode
*
target2
=
pc
+
GET_JUMP_OFFSET
(
pc
)
;
MOZ_ASSERT
(
target2
>
target1
)
;
MDefinition
*
ins
=
current
-
>
peek
(
-
1
)
;
MIsNullOrUndefined
*
isNullOrUndefined
=
MIsNullOrUndefined
:
:
New
(
alloc
(
)
ins
)
;
current
-
>
add
(
isNullOrUndefined
)
;
MTest
*
mir
=
newTest
(
isNullOrUndefined
nullptr
nullptr
)
;
current
-
>
end
(
mir
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewTestTrue
(
current
JSOp
:
:
Coalesce
)
target1
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
current
JSOp
:
:
Coalesce
)
target2
)
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitTry
(
)
{
if
(
script
(
)
-
>
jitScript
(
)
-
>
hasTryFinally
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Try
-
finally
not
supported
"
)
;
}
if
(
isInlineBuilder
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Try
-
catch
during
inlining
"
)
;
}
if
(
info
(
)
.
isAnalysis
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Try
-
catch
during
analysis
"
)
;
}
graph
(
)
.
setHasTryBlock
(
)
;
MBasicBlock
*
tryBlock
;
MOZ_TRY_VAR
(
tryBlock
newBlock
(
current
GetNextPc
(
pc
)
)
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
tryBlock
)
)
;
return
startTraversingBlock
(
tryBlock
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitJumpTarget
(
JSOp
op
)
{
PendingEdgesMap
:
:
Ptr
p
=
pendingEdges_
.
lookup
(
pc
)
;
if
(
!
p
)
{
return
Ok
(
)
;
}
PendingEdges
edges
(
std
:
:
move
(
p
-
>
value
(
)
)
)
;
pendingEdges_
.
remove
(
p
)
;
if
(
edges
.
empty
(
)
)
{
return
Ok
(
)
;
}
MBasicBlock
*
joinBlock
=
nullptr
;
if
(
!
hasTerminatedBlock
(
)
)
{
MOZ_TRY_VAR
(
joinBlock
newBlock
(
current
pc
)
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
joinBlock
)
)
;
setTerminatedBlock
(
)
;
}
auto
addEdge
=
[
&
]
(
MBasicBlock
*
pred
size_t
numToPop
)
-
>
AbortReasonOr
<
Ok
>
{
if
(
joinBlock
)
{
MOZ_ASSERT
(
pred
-
>
stackDepth
(
)
-
numToPop
=
=
joinBlock
-
>
stackDepth
(
)
)
;
if
(
!
joinBlock
-
>
addPredecessorPopN
(
alloc
(
)
pred
numToPop
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
Ok
(
)
;
}
MOZ_TRY_VAR
(
joinBlock
newBlockPopN
(
pred
pc
numToPop
)
)
;
return
Ok
(
)
;
}
;
auto
createEmptyBlockForTest
=
[
&
]
(
MBasicBlock
*
pred
size_t
successor
size_t
numToPop
)
-
>
AbortReasonOr
<
MBasicBlock
*
>
{
MOZ_ASSERT
(
joinBlock
)
;
MBasicBlock
*
emptyBlock
;
MOZ_TRY_VAR
(
emptyBlock
newBlockPopN
(
pred
pc
numToPop
)
)
;
MOZ_ASSERT
(
emptyBlock
-
>
stackDepth
(
)
=
=
joinBlock
-
>
stackDepth
(
)
)
;
MTest
*
test
=
pred
-
>
lastIns
(
)
-
>
toTest
(
)
;
test
-
>
initSuccessor
(
successor
emptyBlock
)
;
MOZ_TRY
(
startTraversingBlock
(
emptyBlock
)
)
;
MOZ_TRY
(
improveTypesAtTestSuccessor
(
test
emptyBlock
)
)
;
emptyBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
joinBlock
)
)
;
setTerminatedBlock
(
)
;
return
emptyBlock
;
}
;
for
(
const
PendingEdge
&
edge
:
edges
)
{
MBasicBlock
*
source
=
edge
.
block
(
)
;
MControlInstruction
*
lastIns
=
source
-
>
lastIns
(
)
;
switch
(
edge
.
kind
(
)
)
{
case
PendingEdge
:
:
Kind
:
:
TestTrue
:
{
const
size_t
numToPop
=
(
edge
.
testOp
(
)
=
=
JSOp
:
:
Case
)
?
1
:
0
;
const
size_t
successor
=
0
;
if
(
joinBlock
&
&
TestTrueTargetIsJoinPoint
(
edge
.
testOp
(
)
)
)
{
MBasicBlock
*
pred
;
MOZ_TRY_VAR
(
pred
createEmptyBlockForTest
(
source
successor
numToPop
)
)
;
MOZ_TRY
(
addEdge
(
pred
0
)
)
;
}
else
{
MOZ_TRY
(
addEdge
(
source
numToPop
)
)
;
lastIns
-
>
toTest
(
)
-
>
initSuccessor
(
successor
joinBlock
)
;
}
continue
;
}
case
PendingEdge
:
:
Kind
:
:
TestFalse
:
{
const
size_t
numToPop
=
0
;
const
size_t
successor
=
1
;
if
(
joinBlock
&
&
!
TestTrueTargetIsJoinPoint
(
edge
.
testOp
(
)
)
)
{
MBasicBlock
*
pred
;
MOZ_TRY_VAR
(
pred
createEmptyBlockForTest
(
source
successor
numToPop
)
)
;
MOZ_TRY
(
addEdge
(
pred
0
)
)
;
}
else
{
MOZ_TRY
(
addEdge
(
source
numToPop
)
)
;
lastIns
-
>
toTest
(
)
-
>
initSuccessor
(
successor
joinBlock
)
;
}
continue
;
}
case
PendingEdge
:
:
Kind
:
:
Goto
:
MOZ_TRY
(
addEdge
(
source
0
)
)
;
lastIns
-
>
toGoto
(
)
-
>
initSuccessor
(
0
joinBlock
)
;
continue
;
}
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
MOZ_ASSERT
(
joinBlock
)
;
MOZ_TRY
(
startTraversingBlock
(
joinBlock
)
)
;
if
(
joinBlock
-
>
numPredecessors
(
)
=
=
1
)
{
MBasicBlock
*
pred
=
joinBlock
-
>
getPredecessor
(
0
)
;
if
(
pred
-
>
lastIns
(
)
-
>
isTest
(
)
)
{
MTest
*
test
=
pred
-
>
lastIns
(
)
-
>
toTest
(
)
;
MOZ_TRY
(
improveTypesAtTestSuccessor
(
test
joinBlock
)
)
;
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitReturn
(
JSOp
op
)
{
MDefinition
*
def
;
switch
(
op
)
{
case
JSOp
:
:
Return
:
def
=
current
-
>
pop
(
)
;
break
;
case
JSOp
:
:
RetRval
:
if
(
script
(
)
-
>
noScriptRval
(
)
)
{
MInstruction
*
ins
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
current
-
>
add
(
ins
)
;
def
=
ins
;
break
;
}
def
=
current
-
>
getSlot
(
info
(
)
.
returnValueSlot
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
unknown
return
op
"
)
;
}
MReturn
*
ret
=
MReturn
:
:
New
(
alloc
(
)
def
)
;
current
-
>
end
(
ret
)
;
if
(
!
graph
(
)
.
addReturn
(
current
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitThrow
(
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
MThrow
*
ins
=
MThrow
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
current
-
>
end
(
MUnreachable
:
:
New
(
alloc
(
)
)
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
visitTableSwitch
(
)
{
jsbytecode
*
defaultpc
=
pc
+
GET_JUMP_OFFSET
(
pc
)
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc
+
JUMP_OFFSET_LEN
*
1
)
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc
+
JUMP_OFFSET_LEN
*
2
)
;
size_t
numCases
=
high
-
low
+
1
;
MDefinition
*
ins
=
current
-
>
pop
(
)
;
MTableSwitch
*
tableswitch
=
MTableSwitch
:
:
New
(
alloc
(
)
ins
low
high
)
;
current
-
>
end
(
tableswitch
)
;
MBasicBlock
*
switchBlock
=
current
;
{
MBasicBlock
*
defaultBlock
;
MOZ_TRY_VAR
(
defaultBlock
newBlock
(
switchBlock
defaultpc
)
)
;
size_t
index
;
if
(
!
tableswitch
-
>
addDefault
(
defaultBlock
&
index
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_ASSERT
(
index
=
=
0
)
;
MOZ_TRY
(
startTraversingBlock
(
defaultBlock
)
)
;
defaultBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
nullptr
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewGoto
(
defaultBlock
)
defaultpc
)
)
;
}
for
(
size_t
i
=
0
;
i
<
numCases
;
i
+
+
)
{
jsbytecode
*
casepc
=
script
(
)
-
>
tableSwitchCasePC
(
pc
i
)
;
MBasicBlock
*
caseBlock
;
MOZ_TRY_VAR
(
caseBlock
newBlock
(
switchBlock
casepc
)
)
;
size_t
index
;
if
(
!
tableswitch
-
>
addSuccessor
(
caseBlock
&
index
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
tableswitch
-
>
addCase
(
index
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_TRY
(
startTraversingBlock
(
caseBlock
)
)
;
MConstant
*
constant
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
low
+
int32_t
(
i
)
)
)
;
caseBlock
-
>
add
(
constant
)
;
for
(
uint32_t
j
=
0
;
j
<
caseBlock
-
>
stackDepth
(
)
;
j
+
+
)
{
if
(
ins
!
=
caseBlock
-
>
getSlot
(
j
)
)
{
continue
;
}
constant
-
>
setDependency
(
ins
)
;
caseBlock
-
>
setSlot
(
j
constant
)
;
}
caseBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
nullptr
)
)
;
MOZ_TRY
(
addPendingEdge
(
PendingEdge
:
:
NewGoto
(
caseBlock
)
casepc
)
)
;
}
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
void
IonBuilder
:
:
pushConstant
(
const
Value
&
v
)
{
current
-
>
push
(
constant
(
v
)
)
;
}
static
inline
bool
SimpleBitOpOperand
(
MDefinition
*
op
)
{
return
op
-
>
definitelyType
(
{
MIRType
:
:
Undefined
MIRType
:
:
Null
MIRType
:
:
Boolean
MIRType
:
:
Int32
MIRType
:
:
Double
MIRType
:
:
Float32
MIRType
:
:
String
}
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
bitnotTrySpecialized
(
bool
*
emitted
MDefinition
*
input
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
SimpleBitOpOperand
(
input
)
)
{
return
Ok
(
)
;
}
MBitNot
*
ins
=
MBitNot
:
:
New
(
alloc
(
)
input
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_bitnot
(
)
{
bool
emitted
=
false
;
MDefinition
*
input
=
current
-
>
pop
(
)
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
bitnotTrySpecialized
(
&
emitted
input
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
arithUnaryBinaryCache
(
JSOp
:
:
BitNot
nullptr
input
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
binaryBitOpTrySpecialized
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
SimpleBitOpOperand
(
left
)
|
|
!
SimpleBitOpOperand
(
right
)
)
{
return
Ok
(
)
;
}
MBinaryBitwiseInstruction
*
ins
;
switch
(
op
)
{
case
JSOp
:
:
BitAnd
:
ins
=
MBitAnd
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Int32
)
;
break
;
case
JSOp
:
:
BitOr
:
ins
=
MBitOr
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Int32
)
;
break
;
case
JSOp
:
:
BitXor
:
ins
=
MBitXor
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Int32
)
;
break
;
case
JSOp
:
:
Lsh
:
ins
=
MLsh
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Int32
)
;
break
;
case
JSOp
:
:
Rsh
:
ins
=
MRsh
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Int32
)
;
break
;
case
JSOp
:
:
Ursh
:
{
MIRType
specialization
=
MIRType
:
:
Int32
;
if
(
inspector
-
>
hasSeenDoubleResult
(
pc
)
)
{
specialization
=
MIRType
:
:
Double
;
}
ins
=
MUrsh
:
:
New
(
alloc
(
)
left
right
specialization
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
bitop
"
)
;
}
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
if
(
ins
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
}
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_bitop
(
JSOp
op
)
{
MDefinition
*
right
=
current
-
>
pop
(
)
;
MDefinition
*
left
=
current
-
>
pop
(
)
;
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
binaryBitOpTrySpecialized
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
arithUnaryBinaryCache
(
op
left
right
)
;
}
MDefinition
:
:
Opcode
BinaryJSOpToMDefinition
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOp
:
:
Add
:
return
MDefinition
:
:
Opcode
:
:
Add
;
case
JSOp
:
:
Sub
:
return
MDefinition
:
:
Opcode
:
:
Sub
;
case
JSOp
:
:
Mul
:
return
MDefinition
:
:
Opcode
:
:
Mul
;
case
JSOp
:
:
Div
:
return
MDefinition
:
:
Opcode
:
:
Div
;
case
JSOp
:
:
Mod
:
return
MDefinition
:
:
Opcode
:
:
Mod
;
default
:
MOZ_CRASH
(
"
unexpected
binary
opcode
"
)
;
}
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
binaryArithTryConcat
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
op
!
=
JSOp
:
:
Add
)
{
return
Ok
(
)
;
}
if
(
left
-
>
type
(
)
!
=
MIRType
:
:
String
&
&
right
-
>
type
(
)
!
=
MIRType
:
:
String
)
{
return
Ok
(
)
;
}
std
:
:
initializer_list
<
MIRType
>
coercibleToString
=
{
MIRType
:
:
Undefined
MIRType
:
:
Null
MIRType
:
:
Boolean
MIRType
:
:
Int32
MIRType
:
:
Double
MIRType
:
:
Float32
MIRType
:
:
String
MIRType
:
:
BigInt
}
;
if
(
right
-
>
type
(
)
!
=
MIRType
:
:
String
&
&
!
right
-
>
definitelyType
(
coercibleToString
)
)
{
return
Ok
(
)
;
}
if
(
left
-
>
type
(
)
!
=
MIRType
:
:
String
&
&
!
left
-
>
definitelyType
(
coercibleToString
)
)
{
return
Ok
(
)
;
}
MConcat
*
ins
=
MConcat
:
:
New
(
alloc
(
)
left
right
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
maybeInsertResume
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
powTrySpecialized
(
bool
*
emitted
MDefinition
*
base
MDefinition
*
power
MIRType
outputType
)
{
MDefinition
*
output
=
nullptr
;
MIRType
baseType
=
base
-
>
type
(
)
;
MIRType
powerType
=
power
-
>
type
(
)
;
if
(
outputType
!
=
MIRType
:
:
Int32
&
&
outputType
!
=
MIRType
:
:
Double
)
{
return
Ok
(
)
;
}
if
(
!
IsNumberType
(
baseType
)
)
{
return
Ok
(
)
;
}
if
(
!
IsNumberType
(
powerType
)
)
{
return
Ok
(
)
;
}
MPow
*
pow
=
MPow
:
:
New
(
alloc
(
)
base
power
MIRType
:
:
Double
)
;
current
-
>
add
(
pow
)
;
output
=
pow
;
if
(
outputType
=
=
MIRType
:
:
Int32
&
&
output
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
auto
*
toInt
=
MToNumberInt32
:
:
New
(
alloc
(
)
output
)
;
current
-
>
add
(
toInt
)
;
output
=
toInt
;
}
if
(
outputType
=
=
MIRType
:
:
Double
&
&
output
-
>
type
(
)
!
=
MIRType
:
:
Double
)
{
MToDouble
*
toDouble
=
MToDouble
:
:
New
(
alloc
(
)
output
)
;
current
-
>
add
(
toDouble
)
;
output
=
toDouble
;
}
current
-
>
push
(
output
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
MIRType
IonBuilder
:
:
binaryArithNumberSpecialization
(
MDefinition
*
left
MDefinition
*
right
)
{
if
(
left
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
right
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
!
inspector
-
>
hasSeenDoubleResult
(
pc
)
)
{
return
MIRType
:
:
Int32
;
}
return
MIRType
:
:
Double
;
}
AbortReasonOr
<
MBinaryArithInstruction
*
>
IonBuilder
:
:
binaryArithEmitSpecialized
(
MDefinition
:
:
Opcode
op
MIRType
specialization
MDefinition
*
left
MDefinition
*
right
)
{
auto
*
ins
=
MBinaryArithInstruction
:
:
New
(
alloc
(
)
op
left
right
specialization
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_ASSERT
(
!
ins
-
>
isEffectful
(
)
)
;
MOZ_TRY
(
maybeInsertResume
(
)
)
;
return
ins
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
binaryArithTrySpecialized
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
SimpleArithOperand
(
left
)
|
|
!
SimpleArithOperand
(
right
)
)
{
return
Ok
(
)
;
}
if
(
!
IsNumberType
(
left
-
>
type
(
)
)
&
&
!
IsNumberType
(
right
-
>
type
(
)
)
)
{
return
Ok
(
)
;
}
MDefinition
:
:
Opcode
defOp
=
BinaryJSOpToMDefinition
(
op
)
;
MIRType
specialization
=
binaryArithNumberSpecialization
(
left
right
)
;
MBinaryArithInstruction
*
ins
;
MOZ_TRY_VAR
(
ins
binaryArithEmitSpecialized
(
defOp
specialization
left
right
)
)
;
if
(
specialization
=
=
MIRType
:
:
Int32
&
&
ins
-
>
constantDoubleResult
(
alloc
(
)
)
)
{
ins
-
>
setSpecialization
(
MIRType
:
:
Double
)
;
}
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
binaryArithTrySpecializedOnBaselineInspector
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MIRType
specialization
=
inspector
-
>
expectedBinaryArithSpecialization
(
pc
)
;
if
(
specialization
=
=
MIRType
:
:
None
)
{
return
Ok
(
)
;
}
MDefinition
:
:
Opcode
defOp
=
BinaryJSOpToMDefinition
(
op
)
;
MOZ_TRY
(
binaryArithEmitSpecialized
(
defOp
specialization
left
right
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
arithUnaryBinaryCache
(
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MInstruction
*
stub
=
nullptr
;
switch
(
JSOp
(
*
pc
)
)
{
case
JSOp
:
:
Pos
:
case
JSOp
:
:
Neg
:
case
JSOp
:
:
BitNot
:
MOZ_ASSERT_IF
(
op
=
=
JSOp
:
:
Mul
left
-
>
maybeConstantValue
(
)
&
&
(
left
-
>
maybeConstantValue
(
)
-
>
toInt32
(
)
=
=
-
1
|
|
left
-
>
maybeConstantValue
(
)
-
>
toInt32
(
)
=
=
1
)
)
;
MOZ_ASSERT_IF
(
op
!
=
JSOp
:
:
Mul
!
left
)
;
stub
=
MUnaryCache
:
:
New
(
alloc
(
)
right
)
;
break
;
case
JSOp
:
:
Add
:
case
JSOp
:
:
Sub
:
case
JSOp
:
:
Mul
:
case
JSOp
:
:
Div
:
case
JSOp
:
:
Mod
:
case
JSOp
:
:
Pow
:
case
JSOp
:
:
BitAnd
:
case
JSOp
:
:
BitOr
:
case
JSOp
:
:
BitXor
:
case
JSOp
:
:
Lsh
:
case
JSOp
:
:
Rsh
:
case
JSOp
:
:
Ursh
:
stub
=
MBinaryCache
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Value
)
;
break
;
default
:
MOZ_CRASH
(
"
unsupported
arith
"
)
;
}
current
-
>
add
(
stub
)
;
current
-
>
push
(
stub
)
;
maybeMarkEmpty
(
stub
)
;
return
resumeAfter
(
stub
)
;
}
MDefinition
*
IonBuilder
:
:
maybeConvertToNumber
(
MDefinition
*
def
)
{
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
String
&
&
def
-
>
isConstant
(
)
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
double
d
;
if
(
StringToNumberPure
(
cx
def
-
>
toConstant
(
)
-
>
toString
(
)
&
d
)
)
{
def
-
>
setImplicitlyUsedUnchecked
(
)
;
return
constant
(
NumberValue
(
d
)
)
;
}
}
return
def
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_binary_arith
(
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
binaryArithTryConcat
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
if
(
op
!
=
JSOp
:
:
Add
)
{
left
=
maybeConvertToNumber
(
left
)
;
right
=
maybeConvertToNumber
(
right
)
;
}
MOZ_TRY
(
binaryArithTrySpecialized
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
binaryArithTrySpecializedOnBaselineInspector
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
arithUnaryBinaryCache
(
op
left
right
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_binary_arith
(
JSOp
op
)
{
MDefinition
*
right
=
current
-
>
pop
(
)
;
MDefinition
*
left
=
current
-
>
pop
(
)
;
return
jsop_binary_arith
(
op
left
right
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_pow
(
)
{
MDefinition
*
exponent
=
current
-
>
pop
(
)
;
MDefinition
*
base
=
current
-
>
pop
(
)
;
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
powTrySpecialized
(
&
emitted
base
exponent
MIRType
:
:
Double
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
arithUnaryBinaryCache
(
JSOp
:
:
Pow
base
exponent
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_pos
(
)
{
if
(
IsNumberType
(
current
-
>
peek
(
-
1
)
-
>
type
(
)
)
)
{
current
-
>
peek
(
-
1
)
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MDefinition
*
value
=
current
-
>
pop
(
)
;
MConstant
*
one
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
1
)
)
;
current
-
>
add
(
one
)
;
return
jsop_binary_arith
(
JSOp
:
:
Mul
one
value
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_neg
(
)
{
MConstant
*
negator
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
-
1
)
)
;
current
-
>
add
(
negator
)
;
MDefinition
*
right
=
current
-
>
pop
(
)
;
return
jsop_binary_arith
(
JSOp
:
:
Mul
negator
right
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_tonumeric
(
)
{
MDefinition
*
peeked
=
current
-
>
peek
(
-
1
)
;
if
(
IsNumericType
(
peeked
-
>
type
(
)
)
)
{
peeked
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
LifoAlloc
*
lifoAlloc
=
alloc
(
)
.
lifoAlloc
(
)
;
TemporaryTypeSet
*
types
=
lifoAlloc
-
>
new_
<
TemporaryTypeSet
>
(
)
;
if
(
!
types
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
types
-
>
addType
(
TypeSet
:
:
Int32Type
(
)
lifoAlloc
)
;
types
-
>
addType
(
TypeSet
:
:
DoubleType
(
)
lifoAlloc
)
;
types
-
>
addType
(
TypeSet
:
:
BigIntType
(
)
lifoAlloc
)
;
if
(
peeked
-
>
type
(
)
=
=
MIRType
:
:
Value
&
&
peeked
-
>
resultTypeSet
(
)
&
&
peeked
-
>
resultTypeSet
(
)
-
>
isSubset
(
types
)
)
{
peeked
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MDefinition
*
popped
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MUnaryCache
:
:
New
(
alloc
(
)
popped
)
;
ins
-
>
setResultTypeSet
(
types
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
MDefinition
*
IonBuilder
:
:
unaryArithConvertToBinary
(
JSOp
op
MDefinition
:
:
Opcode
*
defOp
)
{
switch
(
op
)
{
case
JSOp
:
:
Inc
:
{
*
defOp
=
MDefinition
:
:
Opcode
:
:
Add
;
MConstant
*
right
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
1
)
)
;
current
-
>
add
(
right
)
;
return
right
;
}
case
JSOp
:
:
Dec
:
{
*
defOp
=
MDefinition
:
:
Opcode
:
:
Sub
;
MConstant
*
right
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
1
)
)
;
current
-
>
add
(
right
)
;
return
right
;
}
default
:
MOZ_CRASH
(
"
unexpected
unary
opcode
"
)
;
}
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
unaryArithTrySpecialized
(
bool
*
emitted
JSOp
op
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
IsNumberType
(
value
-
>
type
(
)
)
)
{
return
Ok
(
)
;
}
MDefinition
:
:
Opcode
defOp
;
MDefinition
*
rhs
=
unaryArithConvertToBinary
(
op
&
defOp
)
;
MIRType
specialization
=
binaryArithNumberSpecialization
(
value
rhs
)
;
MOZ_TRY
(
binaryArithEmitSpecialized
(
defOp
specialization
value
rhs
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
unaryArithTrySpecializedOnBaselineInspector
(
bool
*
emitted
JSOp
op
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MIRType
specialization
=
inspector
-
>
expectedBinaryArithSpecialization
(
pc
)
;
if
(
specialization
=
=
MIRType
:
:
None
)
{
return
Ok
(
)
;
}
MDefinition
:
:
Opcode
defOp
;
MDefinition
*
rhs
=
unaryArithConvertToBinary
(
op
&
defOp
)
;
MOZ_TRY
(
binaryArithEmitSpecialized
(
defOp
specialization
value
rhs
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_inc_or_dec
(
JSOp
op
)
{
bool
emitted
=
false
;
MDefinition
*
value
=
current
-
>
pop
(
)
;
MOZ_TRY
(
unaryArithTrySpecialized
(
&
emitted
op
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
unaryArithTrySpecializedOnBaselineInspector
(
&
emitted
op
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MInstruction
*
stub
=
MUnaryCache
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
stub
)
;
current
-
>
push
(
stub
)
;
maybeMarkEmpty
(
stub
)
;
return
resumeAfter
(
stub
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_tostring
(
)
{
if
(
current
-
>
peek
(
-
1
)
-
>
type
(
)
=
=
MIRType
:
:
String
)
{
return
Ok
(
)
;
}
MDefinition
*
value
=
current
-
>
pop
(
)
;
MToString
*
ins
=
MToString
:
:
New
(
alloc
(
)
value
MToString
:
:
SideEffectHandling
:
:
Supported
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
if
(
ins
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
}
return
Ok
(
)
;
}
IonBuilder
:
:
InliningResult
IonBuilder
:
:
inlineScriptedCall
(
CallInfo
&
callInfo
JSFunction
*
target
)
{
MOZ_ASSERT
(
target
-
>
hasBytecode
(
)
)
;
MOZ_ASSERT
(
IsIonInlinableOp
(
JSOp
(
*
pc
)
)
)
;
MBasicBlock
:
:
BackupPoint
backup
(
current
)
;
if
(
!
backup
.
init
(
alloc
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
callInfo
.
setImplicitlyUsedUnchecked
(
)
;
if
(
callInfo
.
constructing
(
)
)
{
MDefinition
*
thisDefn
=
createThis
(
target
callInfo
.
callee
(
)
callInfo
.
getNewTarget
(
)
true
)
;
callInfo
.
setThis
(
thisDefn
)
;
}
if
(
!
callInfo
.
pushCallStack
(
current
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MResumePoint
*
outerResumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
current
pc
MResumePoint
:
:
Outer
)
;
if
(
!
outerResumePoint
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
setOuterResumePoint
(
outerResumePoint
)
;
callInfo
.
popCallStack
(
current
)
;
current
-
>
push
(
callInfo
.
callee
(
)
)
;
JSScript
*
calleeScript
=
target
-
>
nonLazyScript
(
)
;
BaselineInspector
inspector
(
calleeScript
)
;
if
(
callInfo
.
constructing
(
)
&
&
!
callInfo
.
thisArg
(
)
-
>
resultTypeSet
(
)
)
{
AutoSweepJitScript
sweep
(
calleeScript
)
;
StackTypeSet
*
types
=
calleeScript
-
>
jitScript
(
)
-
>
thisTypes
(
sweep
calleeScript
)
;
if
(
!
types
-
>
unknown
(
)
)
{
TemporaryTypeSet
*
clonedTypes
=
types
-
>
clone
(
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
!
clonedTypes
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MTypeBarrier
*
barrier
=
MTypeBarrier
:
:
New
(
alloc
(
)
callInfo
.
thisArg
(
)
clonedTypes
)
;
current
-
>
add
(
barrier
)
;
if
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Undefined
)
{
callInfo
.
setThis
(
constant
(
UndefinedValue
(
)
)
)
;
}
else
if
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Null
)
{
callInfo
.
setThis
(
constant
(
NullValue
(
)
)
)
;
}
else
{
callInfo
.
setThis
(
barrier
)
;
}
}
}
LifoAlloc
*
lifoAlloc
=
alloc_
-
>
lifoAlloc
(
)
;
InlineScriptTree
*
inlineScriptTree
=
info
(
)
.
inlineScriptTree
(
)
-
>
addCallee
(
alloc_
pc
calleeScript
)
;
if
(
!
inlineScriptTree
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
CompileInfo
*
info
=
lifoAlloc
-
>
new_
<
CompileInfo
>
(
mirGen_
.
runtime
calleeScript
target
(
jsbytecode
*
)
nullptr
this
-
>
info
(
)
.
analysisMode
(
)
false
inlineScriptTree
)
;
if
(
!
info
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MIRGraphReturns
returns
(
alloc
(
)
)
;
AutoAccumulateReturns
aar
(
graph
(
)
returns
)
;
IonBuilder
inlineBuilder
(
analysisContext
mirGen_
info
constraints
(
)
&
inspector
nullptr
inliningDepth_
+
1
loopDepth_
)
;
AbortReasonOr
<
Ok
>
result
=
inlineBuilder
.
buildInline
(
this
outerResumePoint
callInfo
)
;
if
(
result
.
isErr
(
)
)
{
if
(
analysisContext
&
&
analysisContext
-
>
isExceptionPending
(
)
)
{
JitSpew
(
JitSpew_IonAbort
"
Inline
builder
raised
exception
.
"
)
;
MOZ_ASSERT
(
result
.
unwrapErr
(
)
=
=
AbortReason
:
:
Error
)
;
return
Err
(
result
.
unwrapErr
(
)
)
;
}
switch
(
result
.
unwrapErr
(
)
)
{
case
AbortReason
:
:
Disable
:
calleeScript
-
>
setUninlineable
(
)
;
if
(
!
JitOptions
.
disableInlineBacktracking
)
{
MBasicBlock
*
block
=
backup
.
restore
(
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
setCurrent
(
block
)
;
return
InliningStatus_NotInlined
;
}
return
abort
(
AbortReason
:
:
Inlining
)
;
case
AbortReason
:
:
PreliminaryObjects
:
{
const
ObjectGroupVector
&
groups
=
inlineBuilder
.
abortedPreliminaryGroups
(
)
;
MOZ_ASSERT
(
!
groups
.
empty
(
)
)
;
for
(
size_t
i
=
0
;
i
<
groups
.
length
(
)
;
i
+
+
)
{
addAbortedPreliminaryGroup
(
groups
[
i
]
)
;
}
return
Err
(
result
.
unwrapErr
(
)
)
;
}
case
AbortReason
:
:
Alloc
:
case
AbortReason
:
:
Inlining
:
case
AbortReason
:
:
Error
:
return
Err
(
result
.
unwrapErr
(
)
)
;
case
AbortReason
:
:
NoAbort
:
MOZ_CRASH
(
"
Abort
with
AbortReason
:
:
NoAbort
"
)
;
return
abort
(
AbortReason
:
:
Error
)
;
}
}
if
(
returns
.
empty
(
)
)
{
calleeScript
-
>
setUninlineable
(
)
;
if
(
!
JitOptions
.
disableInlineBacktracking
)
{
MBasicBlock
*
block
=
backup
.
restore
(
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
setCurrent
(
block
)
;
return
InliningStatus_NotInlined
;
}
return
abort
(
AbortReason
:
:
Inlining
)
;
}
jsbytecode
*
postCall
=
GetNextPc
(
pc
)
;
MBasicBlock
*
returnBlock
;
MOZ_TRY_VAR
(
returnBlock
newBlock
(
current
-
>
stackDepth
(
)
postCall
)
)
;
graph
(
)
.
addBlock
(
returnBlock
)
;
returnBlock
-
>
setCallerResumePoint
(
callerResumePoint_
)
;
returnBlock
-
>
inheritSlots
(
current
)
;
returnBlock
-
>
pop
(
)
;
MDefinition
*
retvalDefn
=
patchInlinedReturns
(
target
callInfo
returns
returnBlock
)
;
if
(
!
retvalDefn
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
returnBlock
-
>
push
(
retvalDefn
)
;
if
(
!
returnBlock
-
>
initEntrySlots
(
alloc
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_TRY
(
setCurrentAndSpecializePhis
(
returnBlock
)
)
;
return
InliningStatus_Inlined
;
}
MDefinition
*
IonBuilder
:
:
patchInlinedReturn
(
JSFunction
*
target
CallInfo
&
callInfo
MBasicBlock
*
exit
MBasicBlock
*
bottom
)
{
MDefinition
*
rdef
=
exit
-
>
lastIns
(
)
-
>
toReturn
(
)
-
>
input
(
)
;
exit
-
>
discardLastIns
(
)
;
if
(
callInfo
.
constructing
(
)
)
{
if
(
target
-
>
isDerivedClassConstructor
(
)
)
{
}
else
if
(
rdef
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
MReturnFromCtor
*
filter
=
MReturnFromCtor
:
:
New
(
alloc
(
)
rdef
callInfo
.
thisArg
(
)
)
;
exit
-
>
add
(
filter
)
;
rdef
=
filter
;
}
else
if
(
rdef
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
rdef
=
callInfo
.
thisArg
(
)
;
}
}
else
if
(
callInfo
.
isSetter
(
)
)
{
rdef
=
callInfo
.
getArg
(
0
)
;
}
if
(
!
callInfo
.
isSetter
(
)
)
{
rdef
=
specializeInlinedReturn
(
rdef
exit
)
;
}
MGoto
*
replacement
=
MGoto
:
:
New
(
alloc
(
)
bottom
)
;
exit
-
>
end
(
replacement
)
;
if
(
!
bottom
-
>
addPredecessorWithoutPhis
(
exit
)
)
{
return
nullptr
;
}
return
rdef
;
}
MDefinition
*
IonBuilder
:
:
specializeInlinedReturn
(
MDefinition
*
rdef
MBasicBlock
*
exit
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
if
(
types
-
>
empty
(
)
|
|
types
-
>
unknown
(
)
)
{
return
rdef
;
}
if
(
rdef
-
>
resultTypeSet
(
)
)
{
if
(
rdef
-
>
resultTypeSet
(
)
-
>
isSubset
(
types
)
)
{
return
rdef
;
}
}
else
{
MIRType
observedType
=
types
-
>
getKnownMIRType
(
)
;
if
(
observedType
=
=
MIRType
:
:
Double
&
&
rdef
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
{
return
rdef
;
}
if
(
observedType
=
=
rdef
-
>
type
(
)
&
&
observedType
!
=
MIRType
:
:
Value
&
&
(
observedType
!
=
MIRType
:
:
Object
|
|
types
-
>
unknownObject
(
)
)
)
{
return
rdef
;
}
}
setCurrent
(
exit
)
;
MTypeBarrier
*
barrier
=
nullptr
;
rdef
=
addTypeBarrier
(
rdef
types
BarrierKind
:
:
TypeSet
&
barrier
)
;
if
(
barrier
)
{
barrier
-
>
setNotMovable
(
)
;
}
return
rdef
;
}
MDefinition
*
IonBuilder
:
:
patchInlinedReturns
(
JSFunction
*
target
CallInfo
&
callInfo
MIRGraphReturns
&
returns
MBasicBlock
*
bottom
)
{
MOZ_ASSERT
(
returns
.
length
(
)
>
0
)
;
if
(
returns
.
length
(
)
=
=
1
)
{
return
patchInlinedReturn
(
target
callInfo
returns
[
0
]
bottom
)
;
}
MPhi
*
phi
=
MPhi
:
:
New
(
alloc
(
)
)
;
if
(
!
phi
-
>
reserveLength
(
returns
.
length
(
)
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
returns
.
length
(
)
;
i
+
+
)
{
MDefinition
*
rdef
=
patchInlinedReturn
(
target
callInfo
returns
[
i
]
bottom
)
;
if
(
!
rdef
)
{
return
nullptr
;
}
phi
-
>
addInput
(
rdef
)
;
}
bottom
-
>
addPhi
(
phi
)
;
return
phi
;
}
IonBuilder
:
:
InliningDecision
IonBuilder
:
:
makeInliningDecision
(
JSObject
*
targetArg
CallInfo
&
callInfo
)
{
if
(
targetArg
=
=
nullptr
)
{
return
InliningDecision_DontInline
;
}
if
(
!
targetArg
-
>
is
<
JSFunction
>
(
)
)
{
return
InliningDecision_Inline
;
}
JSFunction
*
target
=
&
targetArg
-
>
as
<
JSFunction
>
(
)
;
if
(
info
(
)
.
analysisMode
(
)
=
=
Analysis_ArgumentsUsage
)
{
return
InliningDecision_DontInline
;
}
if
(
target
-
>
isNative
(
)
)
{
return
InliningDecision_Inline
;
}
InliningDecision
decision
=
canInlineTarget
(
target
callInfo
)
;
if
(
decision
!
=
InliningDecision_Inline
)
{
return
decision
;
}
JSScript
*
targetScript
=
target
-
>
nonLazyScript
(
)
;
bool
offThread
=
mirGen_
.
options
.
offThreadCompilationAvailable
(
)
;
if
(
targetScript
-
>
length
(
)
>
optimizationInfo
(
)
.
inlineMaxBytecodePerCallSite
(
offThread
)
)
{
return
DontInline
(
targetScript
"
Vetoed
:
callee
excessively
large
"
)
;
}
if
(
targetScript
-
>
getWarmUpCount
(
)
<
optimizationInfo
(
)
.
inliningWarmUpThreshold
(
)
&
&
!
targetScript
-
>
jitScript
(
)
-
>
ionCompiledOrInlined
(
)
&
&
info
(
)
.
analysisMode
(
)
!
=
Analysis_DefiniteProperties
)
{
JitSpew
(
JitSpew_Inlining
"
Cannot
inline
%
s
:
%
u
:
%
u
:
callee
is
insufficiently
hot
.
"
targetScript
-
>
filename
(
)
targetScript
-
>
lineno
(
)
targetScript
-
>
column
(
)
)
;
return
InliningDecision_WarmUpCountTooLow
;
}
uint32_t
inlinedBytecodeLength
=
targetScript
-
>
jitScript
(
)
-
>
inlinedBytecodeLength
(
)
;
if
(
inlinedBytecodeLength
>
optimizationInfo
(
)
.
inlineMaxCalleeInlinedBytecodeLength
(
)
)
{
return
DontInline
(
targetScript
"
Vetoed
:
callee
inlinedBytecodeLength
is
too
big
"
)
;
}
IonBuilder
*
outerBuilder
=
outermostBuilder
(
)
;
size_t
totalBytecodeLength
=
outerBuilder
-
>
inlinedBytecodeLength_
+
targetScript
-
>
length
(
)
;
if
(
totalBytecodeLength
>
optimizationInfo
(
)
.
inlineMaxTotalBytecodeLength
(
)
)
{
return
DontInline
(
targetScript
"
Vetoed
:
exceeding
max
total
bytecode
length
"
)
;
}
uint32_t
maxInlineDepth
;
if
(
JitOptions
.
isSmallFunction
(
targetScript
)
)
{
maxInlineDepth
=
optimizationInfo
(
)
.
smallFunctionMaxInlineDepth
(
)
;
}
else
{
maxInlineDepth
=
optimizationInfo
(
)
.
maxInlineDepth
(
)
;
if
(
script
(
)
-
>
length
(
)
>
=
optimizationInfo
(
)
.
inliningMaxCallerBytecodeLength
(
)
)
{
return
DontInline
(
targetScript
"
Vetoed
:
caller
excessively
large
"
)
;
}
}
JitScript
*
outerJitScript
=
outermostBuilder
(
)
-
>
script
(
)
-
>
jitScript
(
)
;
if
(
inliningDepth_
>
=
maxInlineDepth
)
{
if
(
isHighestOptimizationLevel
(
)
)
{
outerJitScript
-
>
setMaxInliningDepth
(
0
)
;
}
return
DontInline
(
targetScript
"
Vetoed
:
exceeding
allowed
inline
depth
"
)
;
}
if
(
isHighestOptimizationLevel
(
)
&
&
targetScript
-
>
hasLoops
(
)
&
&
inliningDepth_
>
=
targetScript
-
>
jitScript
(
)
-
>
maxInliningDepth
(
)
)
{
return
DontInline
(
targetScript
"
Vetoed
:
exceeding
allowed
script
inline
depth
"
)
;
}
MOZ_ASSERT
(
maxInlineDepth
>
inliningDepth_
)
;
uint32_t
scriptInlineDepth
=
maxInlineDepth
-
inliningDepth_
-
1
;
if
(
scriptInlineDepth
<
outerJitScript
-
>
maxInliningDepth
(
)
&
&
isHighestOptimizationLevel
(
)
)
{
outerJitScript
-
>
setMaxInliningDepth
(
scriptInlineDepth
)
;
}
outerBuilder
-
>
inlinedBytecodeLength_
+
=
targetScript
-
>
length
(
)
;
return
InliningDecision_Inline
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
selectInliningTargets
(
const
InliningTargets
&
targets
CallInfo
&
callInfo
BoolVector
&
choiceSet
uint32_t
*
numInlineable
)
{
*
numInlineable
=
0
;
uint32_t
totalSize
=
0
;
if
(
!
choiceSet
.
reserve
(
targets
.
length
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
info
(
)
.
analysisMode
(
)
=
=
Analysis_DefiniteProperties
&
&
targets
.
length
(
)
>
1
)
{
return
Ok
(
)
;
}
for
(
size_t
i
=
0
;
i
<
targets
.
length
(
)
;
i
+
+
)
{
JSObject
*
target
=
targets
[
i
]
.
target
;
bool
inlineable
;
InliningDecision
decision
=
makeInliningDecision
(
target
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
case
InliningDecision_WarmUpCountTooLow
:
inlineable
=
false
;
break
;
case
InliningDecision_Inline
:
inlineable
=
true
;
break
;
default
:
MOZ_CRASH
(
"
Unhandled
InliningDecision
value
!
"
)
;
}
if
(
target
-
>
is
<
JSFunction
>
(
)
)
{
if
(
inlineable
&
&
target
-
>
as
<
JSFunction
>
(
)
.
isInterpreted
(
)
)
{
totalSize
+
=
target
-
>
as
<
JSFunction
>
(
)
.
nonLazyScript
(
)
-
>
length
(
)
;
bool
offThread
=
mirGen_
.
options
.
offThreadCompilationAvailable
(
)
;
if
(
totalSize
>
optimizationInfo
(
)
.
inlineMaxBytecodePerCallSite
(
offThread
)
)
{
inlineable
=
false
;
}
}
}
else
{
inlineable
=
false
;
}
if
(
inlineable
&
&
targets
[
i
]
.
group
)
{
ObjectGroup
*
group
=
targets
[
i
]
.
group
;
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
group
)
;
if
(
!
key
-
>
hasStableClassAndProto
(
constraints
(
)
)
)
{
inlineable
=
false
;
}
}
choiceSet
.
infallibleAppend
(
inlineable
)
;
if
(
inlineable
)
{
*
numInlineable
+
=
1
;
}
}
MOZ_ASSERT
(
choiceSet
.
length
(
)
=
=
targets
.
length
(
)
)
;
return
Ok
(
)
;
}
static
bool
CanInlineGetPropertyCache
(
MGetPropertyCache
*
cache
MDefinition
*
thisDef
)
{
if
(
cache
-
>
value
(
)
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
false
;
}
if
(
cache
-
>
value
(
)
!
=
thisDef
)
{
return
false
;
}
InlinePropertyTable
*
table
=
cache
-
>
propTable
(
)
;
if
(
!
table
)
{
return
false
;
}
if
(
table
-
>
numEntries
(
)
=
=
0
)
{
return
false
;
}
return
true
;
}
class
WrapMGetPropertyCache
{
MGetPropertyCache
*
cache_
;
private
:
void
discardPriorResumePoint
(
)
{
if
(
!
cache_
)
{
return
;
}
InlinePropertyTable
*
propTable
=
cache_
-
>
propTable
(
)
;
if
(
!
propTable
)
{
return
;
}
MResumePoint
*
rp
=
propTable
-
>
takePriorResumePoint
(
)
;
if
(
!
rp
)
{
return
;
}
cache_
-
>
block
(
)
-
>
discardPreAllocatedResumePoint
(
rp
)
;
}
public
:
explicit
WrapMGetPropertyCache
(
MGetPropertyCache
*
cache
)
:
cache_
(
cache
)
{
}
~
WrapMGetPropertyCache
(
)
{
discardPriorResumePoint
(
)
;
}
MGetPropertyCache
*
get
(
)
{
return
cache_
;
}
MGetPropertyCache
*
operator
-
>
(
)
{
return
get
(
)
;
}
MGetPropertyCache
*
moveableCache
(
bool
hasTypeBarrier
MDefinition
*
thisDef
)
{
if
(
!
hasTypeBarrier
)
{
if
(
cache_
-
>
hasUses
(
)
)
{
return
nullptr
;
}
}
else
{
MOZ_ASSERT
(
cache_
-
>
hasUses
(
)
)
;
if
(
!
cache_
-
>
hasOneUse
(
)
)
{
return
nullptr
;
}
}
if
(
!
CanInlineGetPropertyCache
(
cache_
thisDef
)
)
{
return
nullptr
;
}
MGetPropertyCache
*
ret
=
cache_
;
cache_
=
nullptr
;
return
ret
;
}
}
;
MGetPropertyCache
*
IonBuilder
:
:
getInlineableGetPropertyCache
(
CallInfo
&
callInfo
)
{
if
(
callInfo
.
constructing
(
)
)
{
return
nullptr
;
}
MDefinition
*
thisDef
=
callInfo
.
thisArg
(
)
;
if
(
thisDef
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
nullptr
;
}
MDefinition
*
funcDef
=
callInfo
.
callee
(
)
;
if
(
funcDef
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
nullptr
;
}
if
(
funcDef
-
>
isGetPropertyCache
(
)
)
{
WrapMGetPropertyCache
cache
(
funcDef
-
>
toGetPropertyCache
(
)
)
;
return
cache
.
moveableCache
(
false
thisDef
)
;
}
if
(
funcDef
-
>
isTypeBarrier
(
)
)
{
MTypeBarrier
*
barrier
=
funcDef
-
>
toTypeBarrier
(
)
;
if
(
barrier
-
>
hasUses
(
)
)
{
return
nullptr
;
}
if
(
barrier
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
nullptr
;
}
if
(
!
barrier
-
>
input
(
)
-
>
isGetPropertyCache
(
)
)
{
return
nullptr
;
}
WrapMGetPropertyCache
cache
(
barrier
-
>
input
(
)
-
>
toGetPropertyCache
(
)
)
;
return
cache
.
moveableCache
(
true
thisDef
)
;
}
return
nullptr
;
}
IonBuilder
:
:
InliningResult
IonBuilder
:
:
inlineSingleCall
(
CallInfo
&
callInfo
JSObject
*
targetArg
)
{
InliningStatus
status
;
if
(
!
targetArg
-
>
is
<
JSFunction
>
(
)
)
{
return
InliningStatus_NotInlined
;
}
JSFunction
*
target
=
&
targetArg
-
>
as
<
JSFunction
>
(
)
;
if
(
target
-
>
isNative
(
)
)
{
MOZ_TRY_VAR
(
status
inlineNativeCall
(
callInfo
target
)
)
;
return
status
;
}
return
inlineScriptedCall
(
callInfo
target
)
;
}
IonBuilder
:
:
InliningResult
IonBuilder
:
:
inlineCallsite
(
const
InliningTargets
&
targets
CallInfo
&
callInfo
)
{
if
(
targets
.
empty
(
)
)
{
return
InliningStatus_NotInlined
;
}
WrapMGetPropertyCache
propCache
(
getInlineableGetPropertyCache
(
callInfo
)
)
;
keepFallbackFunctionGetter
(
propCache
.
get
(
)
)
;
if
(
!
propCache
.
get
(
)
&
&
targets
.
length
(
)
=
=
1
)
{
JSObject
*
target
=
targets
[
0
]
.
target
;
InliningDecision
decision
=
makeInliningDecision
(
target
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
return
InliningStatus_NotInlined
;
case
InliningDecision_WarmUpCountTooLow
:
return
InliningStatus_WarmUpCountTooLow
;
case
InliningDecision_Inline
:
break
;
}
callInfo
.
callee
(
)
-
>
setImplicitlyUsedUnchecked
(
)
;
if
(
target
-
>
isSingleton
(
)
)
{
MConstant
*
constFun
=
constant
(
ObjectValue
(
*
target
)
)
;
if
(
callInfo
.
constructing
(
)
&
&
callInfo
.
getNewTarget
(
)
=
=
callInfo
.
callee
(
)
)
{
callInfo
.
setNewTarget
(
constFun
)
;
}
callInfo
.
setCallee
(
constFun
)
;
}
return
inlineSingleCall
(
callInfo
target
)
;
}
BoolVector
choiceSet
(
alloc
(
)
)
;
uint32_t
numInlined
;
MOZ_TRY
(
selectInliningTargets
(
targets
callInfo
choiceSet
&
numInlined
)
)
;
if
(
numInlined
=
=
0
)
{
return
InliningStatus_NotInlined
;
}
MOZ_TRY
(
inlineCalls
(
callInfo
targets
choiceSet
propCache
.
get
(
)
)
)
;
return
InliningStatus_Inlined
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
inlineGenericFallback
(
const
Maybe
<
CallTargets
>
&
targets
CallInfo
&
callInfo
MBasicBlock
*
dispatchBlock
)
{
MBasicBlock
*
fallbackBlock
;
MOZ_TRY_VAR
(
fallbackBlock
newBlock
(
dispatchBlock
pc
)
)
;
graph
(
)
.
addBlock
(
fallbackBlock
)
;
CallInfo
fallbackInfo
(
alloc
(
)
pc
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
)
;
if
(
!
fallbackInfo
.
init
(
callInfo
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
fallbackInfo
.
popCallStack
(
fallbackBlock
)
;
MOZ_TRY
(
setCurrentAndSpecializePhis
(
fallbackBlock
)
)
;
MOZ_TRY
(
makeCall
(
targets
fallbackInfo
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
inlineObjectGroupFallback
(
const
Maybe
<
CallTargets
>
&
targets
CallInfo
&
callInfo
MBasicBlock
*
dispatchBlock
MObjectGroupDispatch
*
dispatch
MGetPropertyCache
*
cache
MBasicBlock
*
*
fallbackTarget
)
{
MOZ_ASSERT
(
callInfo
.
callee
(
)
-
>
isGetPropertyCache
(
)
|
|
callInfo
.
callee
(
)
-
>
isTypeBarrier
(
)
)
;
MOZ_ASSERT
(
dispatch
-
>
numCases
(
)
>
0
)
;
MOZ_ASSERT_IF
(
callInfo
.
callee
(
)
-
>
isGetPropertyCache
(
)
!
cache
-
>
hasUses
(
)
)
;
MOZ_ASSERT_IF
(
callInfo
.
callee
(
)
-
>
isTypeBarrier
(
)
cache
-
>
hasOneUse
(
)
)
;
MOZ_ASSERT
(
cache
-
>
idempotent
(
)
)
;
CallInfo
fallbackInfo
(
alloc
(
)
pc
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
)
;
if
(
!
fallbackInfo
.
init
(
callInfo
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MResumePoint
*
preCallResumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
dispatchBlock
pc
MResumePoint
:
:
ResumeAt
)
;
if
(
!
preCallResumePoint
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
DebugOnly
<
size_t
>
preCallFuncIndex
=
preCallResumePoint
-
>
stackDepth
(
)
-
callInfo
.
numFormals
(
)
;
MOZ_ASSERT
(
preCallResumePoint
-
>
getOperand
(
preCallFuncIndex
)
=
=
fallbackInfo
.
callee
(
)
)
;
MConstant
*
undefined
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
dispatchBlock
-
>
add
(
undefined
)
;
dispatchBlock
-
>
rewriteAtDepth
(
-
int
(
callInfo
.
numFormals
(
)
)
undefined
)
;
MBasicBlock
*
prepBlock
;
MOZ_TRY_VAR
(
prepBlock
newBlock
(
dispatchBlock
pc
)
)
;
graph
(
)
.
addBlock
(
prepBlock
)
;
fallbackInfo
.
popCallStack
(
prepBlock
)
;
InlinePropertyTable
*
propTable
=
cache
-
>
propTable
(
)
;
MResumePoint
*
priorResumePoint
=
propTable
-
>
takePriorResumePoint
(
)
;
MOZ_ASSERT
(
propTable
-
>
pc
(
)
!
=
nullptr
)
;
MOZ_ASSERT
(
priorResumePoint
!
=
nullptr
)
;
MBasicBlock
*
getPropBlock
;
MOZ_TRY_VAR
(
getPropBlock
newBlock
(
prepBlock
propTable
-
>
pc
(
)
priorResumePoint
)
)
;
graph
(
)
.
addBlock
(
getPropBlock
)
;
prepBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
getPropBlock
)
)
;
DebugOnly
<
MDefinition
*
>
checkObject
=
getPropBlock
-
>
pop
(
)
;
MOZ_ASSERT
(
checkObject
=
=
cache
-
>
value
(
)
)
;
if
(
fallbackInfo
.
callee
(
)
-
>
isGetPropertyCache
(
)
)
{
MOZ_ASSERT
(
fallbackInfo
.
callee
(
)
-
>
toGetPropertyCache
(
)
=
=
cache
)
;
getPropBlock
-
>
addFromElsewhere
(
cache
)
;
getPropBlock
-
>
push
(
cache
)
;
}
else
{
MTypeBarrier
*
barrier
=
callInfo
.
callee
(
)
-
>
toTypeBarrier
(
)
;
MOZ_ASSERT
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MOZ_ASSERT
(
barrier
-
>
input
(
)
-
>
isGetPropertyCache
(
)
)
;
MOZ_ASSERT
(
barrier
-
>
input
(
)
-
>
toGetPropertyCache
(
)
=
=
cache
)
;
getPropBlock
-
>
addFromElsewhere
(
cache
)
;
getPropBlock
-
>
addFromElsewhere
(
barrier
)
;
getPropBlock
-
>
push
(
barrier
)
;
}
MBasicBlock
*
preCallBlock
;
MOZ_TRY_VAR
(
preCallBlock
newBlock
(
getPropBlock
pc
preCallResumePoint
)
)
;
graph
(
)
.
addBlock
(
preCallBlock
)
;
getPropBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
preCallBlock
)
)
;
MOZ_TRY
(
inlineGenericFallback
(
targets
fallbackInfo
preCallBlock
)
)
;
preCallBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
current
)
)
;
*
fallbackTarget
=
prepBlock
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
inlineCalls
(
CallInfo
&
callInfo
const
InliningTargets
&
targets
BoolVector
&
choiceSet
MGetPropertyCache
*
maybeCache
)
{
MOZ_ASSERT
(
IsIonInlinableOp
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
choiceSet
.
length
(
)
=
=
targets
.
length
(
)
)
;
MOZ_ASSERT_IF
(
!
maybeCache
targets
.
length
(
)
>
=
2
)
;
MOZ_ASSERT_IF
(
maybeCache
targets
.
length
(
)
>
=
1
)
;
MOZ_ASSERT_IF
(
maybeCache
maybeCache
-
>
value
(
)
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MBasicBlock
*
dispatchBlock
=
current
;
callInfo
.
setImplicitlyUsedUnchecked
(
)
;
if
(
!
callInfo
.
pushCallStack
(
dispatchBlock
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
maybeCache
)
{
InlinePropertyTable
*
propTable
=
maybeCache
-
>
propTable
(
)
;
propTable
-
>
trimToTargets
(
targets
)
;
if
(
propTable
-
>
numEntries
(
)
=
=
0
)
{
maybeCache
=
nullptr
;
}
}
MDispatchInstruction
*
dispatch
;
if
(
maybeCache
)
{
dispatch
=
MObjectGroupDispatch
:
:
New
(
alloc
(
)
maybeCache
-
>
value
(
)
maybeCache
-
>
propTable
(
)
)
;
callInfo
.
callee
(
)
-
>
setImplicitlyUsedUnchecked
(
)
;
}
else
{
dispatch
=
MFunctionDispatch
:
:
New
(
alloc
(
)
callInfo
.
callee
(
)
)
;
}
MOZ_ASSERT
(
dispatchBlock
-
>
stackDepth
(
)
>
=
callInfo
.
numFormals
(
)
)
;
uint32_t
stackDepth
=
dispatchBlock
-
>
stackDepth
(
)
-
callInfo
.
numFormals
(
)
+
1
;
jsbytecode
*
postCall
=
GetNextPc
(
pc
)
;
MBasicBlock
*
returnBlock
;
MOZ_TRY_VAR
(
returnBlock
newBlock
(
stackDepth
postCall
)
)
;
graph
(
)
.
addBlock
(
returnBlock
)
;
returnBlock
-
>
setCallerResumePoint
(
callerResumePoint_
)
;
returnBlock
-
>
inheritSlots
(
dispatchBlock
)
;
callInfo
.
popCallStack
(
returnBlock
)
;
MPhi
*
retPhi
=
MPhi
:
:
New
(
alloc
(
)
)
;
returnBlock
-
>
addPhi
(
retPhi
)
;
returnBlock
-
>
push
(
retPhi
)
;
if
(
!
returnBlock
-
>
initEntrySlots
(
alloc
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
uint32_t
count
=
1
;
for
(
uint32_t
i
=
0
;
i
<
targets
.
length
(
)
;
i
+
+
)
{
if
(
choiceSet
[
i
]
)
{
count
+
+
;
}
}
if
(
!
retPhi
-
>
reserveLength
(
count
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
for
(
uint32_t
i
=
0
;
i
<
targets
.
length
(
)
;
i
+
+
)
{
if
(
!
choiceSet
[
i
]
)
{
continue
;
}
JSFunction
*
target
=
&
targets
[
i
]
.
target
-
>
as
<
JSFunction
>
(
)
;
if
(
maybeCache
&
&
!
maybeCache
-
>
propTable
(
)
-
>
hasFunction
(
target
)
)
{
choiceSet
[
i
]
=
false
;
continue
;
}
MBasicBlock
*
inlineBlock
;
MOZ_TRY_VAR
(
inlineBlock
newBlock
(
dispatchBlock
pc
)
)
;
graph
(
)
.
addBlock
(
inlineBlock
)
;
MInstruction
*
funcDef
;
if
(
target
-
>
isSingleton
(
)
)
{
funcDef
=
MConstant
:
:
New
(
alloc
(
)
ObjectValue
(
*
target
)
constraints
(
)
)
;
}
else
{
funcDef
=
MPolyInlineGuard
:
:
New
(
alloc
(
)
callInfo
.
callee
(
)
)
;
}
funcDef
-
>
setImplicitlyUsedUnchecked
(
)
;
dispatchBlock
-
>
add
(
funcDef
)
;
int
funIndex
=
inlineBlock
-
>
entryResumePoint
(
)
-
>
stackDepth
(
)
-
callInfo
.
numFormals
(
)
;
inlineBlock
-
>
entryResumePoint
(
)
-
>
replaceOperand
(
funIndex
funcDef
)
;
inlineBlock
-
>
rewriteSlot
(
funIndex
funcDef
)
;
CallInfo
inlineInfo
(
alloc
(
)
pc
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
)
;
if
(
!
inlineInfo
.
init
(
callInfo
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
inlineInfo
.
popCallStack
(
inlineBlock
)
;
inlineInfo
.
setCallee
(
funcDef
)
;
if
(
callInfo
.
constructing
(
)
&
&
callInfo
.
getNewTarget
(
)
=
=
callInfo
.
callee
(
)
)
{
inlineInfo
.
setNewTarget
(
funcDef
)
;
}
if
(
maybeCache
)
{
MOZ_ASSERT
(
callInfo
.
thisArg
(
)
=
=
maybeCache
-
>
value
(
)
)
;
TemporaryTypeSet
*
thisTypes
=
maybeCache
-
>
propTable
(
)
-
>
buildTypeSetForFunction
(
alloc
(
)
target
)
;
if
(
!
thisTypes
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MFilterTypeSet
*
filter
=
MFilterTypeSet
:
:
New
(
alloc
(
)
inlineInfo
.
thisArg
(
)
thisTypes
)
;
inlineBlock
-
>
add
(
filter
)
;
inlineInfo
.
setThis
(
filter
)
;
}
MOZ_TRY
(
setCurrentAndSpecializePhis
(
inlineBlock
)
)
;
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineSingleCall
(
inlineInfo
target
)
)
;
if
(
status
=
=
InliningStatus_NotInlined
)
{
MOZ_ASSERT
(
current
=
=
inlineBlock
)
;
graph
(
)
.
removeBlock
(
inlineBlock
)
;
choiceSet
[
i
]
=
false
;
continue
;
}
MBasicBlock
*
inlineReturnBlock
=
current
;
setCurrent
(
dispatchBlock
)
;
if
(
!
dispatch
-
>
addCase
(
target
targets
[
i
]
.
group
inlineBlock
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MDefinition
*
retVal
=
inlineReturnBlock
-
>
peek
(
-
1
)
;
retPhi
-
>
addInput
(
retVal
)
;
inlineReturnBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
returnBlock
)
)
;
if
(
!
returnBlock
-
>
addPredecessorWithoutPhis
(
inlineReturnBlock
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
bool
useFallback
;
if
(
maybeCache
)
{
InlinePropertyTable
*
propTable
=
maybeCache
-
>
propTable
(
)
;
propTable
-
>
trimTo
(
targets
choiceSet
)
;
if
(
propTable
-
>
numEntries
(
)
=
=
0
|
|
!
propTable
-
>
hasPriorResumePoint
(
)
)
{
MOZ_ASSERT_IF
(
propTable
-
>
numEntries
(
)
=
=
0
dispatch
-
>
numCases
(
)
=
=
0
)
;
maybeCache
=
nullptr
;
useFallback
=
true
;
}
else
{
useFallback
=
false
;
TemporaryTypeSet
*
objectTypes
=
maybeCache
-
>
value
(
)
-
>
resultTypeSet
(
)
;
for
(
uint32_t
i
=
0
;
i
<
objectTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
obj
=
objectTypes
-
>
getObject
(
i
)
;
if
(
!
obj
)
{
continue
;
}
if
(
!
obj
-
>
isGroup
(
)
)
{
useFallback
=
true
;
break
;
}
if
(
!
propTable
-
>
hasObjectGroup
(
obj
-
>
group
(
)
)
)
{
useFallback
=
true
;
break
;
}
}
if
(
!
useFallback
)
{
if
(
callInfo
.
callee
(
)
-
>
isGetPropertyCache
(
)
)
{
MOZ_ASSERT
(
callInfo
.
callee
(
)
=
=
maybeCache
)
;
}
else
{
MTypeBarrier
*
barrier
=
callInfo
.
callee
(
)
-
>
toTypeBarrier
(
)
;
MOZ_ASSERT
(
!
barrier
-
>
hasUses
(
)
)
;
MOZ_ASSERT
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MOZ_ASSERT
(
barrier
-
>
input
(
)
-
>
isGetPropertyCache
(
)
)
;
MOZ_ASSERT
(
barrier
-
>
input
(
)
-
>
toGetPropertyCache
(
)
=
=
maybeCache
)
;
barrier
-
>
block
(
)
-
>
discard
(
barrier
)
;
}
MOZ_ASSERT
(
!
maybeCache
-
>
hasUses
(
)
)
;
maybeCache
-
>
block
(
)
-
>
discard
(
maybeCache
)
;
}
}
}
else
{
useFallback
=
dispatch
-
>
numCases
(
)
<
targets
.
length
(
)
;
}
if
(
useFallback
)
{
Maybe
<
CallTargets
>
remainingTargets
;
remainingTargets
.
emplace
(
alloc
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
targets
.
length
(
)
;
i
+
+
)
{
if
(
!
maybeCache
&
&
choiceSet
[
i
]
)
{
continue
;
}
JSObject
*
target
=
targets
[
i
]
.
target
;
if
(
!
target
-
>
is
<
JSFunction
>
(
)
)
{
remainingTargets
=
Nothing
(
)
;
break
;
}
if
(
!
remainingTargets
-
>
append
(
&
target
-
>
as
<
JSFunction
>
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
if
(
maybeCache
)
{
MBasicBlock
*
fallbackTarget
;
MOZ_TRY
(
inlineObjectGroupFallback
(
remainingTargets
callInfo
dispatchBlock
dispatch
-
>
toObjectGroupDispatch
(
)
maybeCache
&
fallbackTarget
)
)
;
dispatch
-
>
addFallback
(
fallbackTarget
)
;
}
else
{
MOZ_TRY
(
inlineGenericFallback
(
remainingTargets
callInfo
dispatchBlock
)
)
;
dispatch
-
>
addFallback
(
current
)
;
}
MBasicBlock
*
fallbackReturnBlock
=
current
;
MDefinition
*
retVal
=
fallbackReturnBlock
-
>
peek
(
-
1
)
;
retPhi
-
>
addInput
(
retVal
)
;
fallbackReturnBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
returnBlock
)
)
;
if
(
!
returnBlock
-
>
addPredecessorWithoutPhis
(
fallbackReturnBlock
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
dispatchBlock
-
>
end
(
dispatch
)
;
MOZ_ASSERT
(
returnBlock
-
>
stackDepth
(
)
=
=
dispatchBlock
-
>
stackDepth
(
)
-
callInfo
.
numFormals
(
)
+
1
)
;
graph
(
)
.
moveBlockToEnd
(
returnBlock
)
;
return
setCurrentAndSpecializePhis
(
returnBlock
)
;
}
MInstruction
*
IonBuilder
:
:
createNamedLambdaObject
(
MDefinition
*
callee
MDefinition
*
env
)
{
LexicalEnvironmentObject
*
templateObj
=
inspector
-
>
templateNamedLambdaObject
(
)
;
MOZ_ASSERT
(
!
templateObj
-
>
hasDynamicSlots
(
)
)
;
MInstruction
*
declEnvObj
=
MNewNamedLambdaObject
:
:
New
(
alloc
(
)
templateObj
)
;
current
-
>
add
(
declEnvObj
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
declEnvObj
NamedLambdaObject
:
:
enclosingEnvironmentSlot
(
)
env
)
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
declEnvObj
NamedLambdaObject
:
:
lambdaSlot
(
)
callee
)
)
;
return
declEnvObj
;
}
AbortReasonOr
<
MInstruction
*
>
IonBuilder
:
:
createCallObject
(
MDefinition
*
callee
MDefinition
*
env
)
{
CallObject
*
templateObj
=
inspector
-
>
templateCallObject
(
)
;
MConstant
*
templateCst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObj
)
;
current
-
>
add
(
templateCst
)
;
MNewCallObject
*
callObj
=
MNewCallObject
:
:
New
(
alloc
(
)
templateCst
)
;
current
-
>
add
(
callObj
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
CallObject
:
:
enclosingEnvironmentSlot
(
)
env
)
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
CallObject
:
:
calleeSlot
(
)
callee
)
)
;
MSlots
*
slots
=
nullptr
;
for
(
PositionalFormalParameterIter
fi
(
script
(
)
)
;
fi
;
fi
+
+
)
{
if
(
!
fi
.
closedOver
(
)
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
unsigned
slot
=
fi
.
location
(
)
.
slot
(
)
;
unsigned
formal
=
fi
.
argumentSlot
(
)
;
unsigned
numFixedSlots
=
templateObj
-
>
numFixedSlots
(
)
;
MDefinition
*
param
;
if
(
script
(
)
-
>
functionHasParameterExprs
(
)
)
{
param
=
constant
(
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
}
else
{
param
=
current
-
>
getSlot
(
info
(
)
.
argSlotUnchecked
(
formal
)
)
;
}
if
(
slot
>
=
numFixedSlots
)
{
if
(
!
slots
)
{
slots
=
MSlots
:
:
New
(
alloc
(
)
callObj
)
;
current
-
>
add
(
slots
)
;
}
current
-
>
add
(
MStoreDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
-
numFixedSlots
param
)
)
;
}
else
{
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
slot
param
)
)
;
}
}
return
AbortReasonOr
<
MInstruction
*
>
(
callObj
)
;
}
MDefinition
*
IonBuilder
:
:
createThisScripted
(
MDefinition
*
callee
MDefinition
*
newTarget
)
{
MInstruction
*
getProto
;
if
(
!
invalidatedIdempotentCache
(
)
)
{
MConstant
*
id
=
constant
(
StringValue
(
names
(
)
.
prototype
)
)
;
MGetPropertyCache
*
getPropCache
=
MGetPropertyCache
:
:
New
(
alloc
(
)
newTarget
id
false
)
;
getPropCache
-
>
setIdempotent
(
)
;
getProto
=
getPropCache
;
}
else
{
MCallGetProperty
*
callGetProp
=
MCallGetProperty
:
:
New
(
alloc
(
)
newTarget
names
(
)
.
prototype
)
;
callGetProp
-
>
setIdempotent
(
)
;
getProto
=
callGetProp
;
}
current
-
>
add
(
getProto
)
;
MCreateThisWithProto
*
createThis
=
MCreateThisWithProto
:
:
New
(
alloc
(
)
callee
newTarget
getProto
)
;
current
-
>
add
(
createThis
)
;
return
createThis
;
}
JSObject
*
IonBuilder
:
:
getSingletonPrototype
(
JSFunction
*
target
)
{
TypeSet
:
:
ObjectKey
*
targetKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
target
)
;
if
(
targetKey
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
jsid
protoid
=
NameToId
(
names
(
)
.
prototype
)
;
HeapTypeSetKey
protoProperty
=
targetKey
-
>
property
(
protoid
)
;
return
protoProperty
.
singleton
(
constraints
(
)
)
;
}
MDefinition
*
IonBuilder
:
:
createThisScriptedSingleton
(
JSFunction
*
target
)
{
if
(
!
target
-
>
hasBytecode
(
)
)
{
return
nullptr
;
}
JSObject
*
proto
=
getSingletonPrototype
(
target
)
;
if
(
!
proto
)
{
return
nullptr
;
}
JSObject
*
templateObject
=
inspector
-
>
getTemplateObject
(
pc
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
if
(
!
templateObject
-
>
is
<
PlainObject
>
(
)
)
{
return
nullptr
;
}
if
(
templateObject
-
>
staticPrototype
(
)
!
=
proto
)
{
return
nullptr
;
}
if
(
templateObject
-
>
nonCCWRealm
(
)
!
=
target
-
>
realm
(
)
)
{
return
nullptr
;
}
TypeSet
:
:
ObjectKey
*
templateObjectKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
templateObject
-
>
group
(
)
)
;
if
(
templateObjectKey
-
>
hasFlags
(
constraints
(
)
OBJECT_FLAG_NEW_SCRIPT_CLEARED
)
)
{
return
nullptr
;
}
JSScript
*
targetScript
=
target
-
>
nonLazyScript
(
)
;
JitScript
*
jitScript
=
targetScript
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
return
nullptr
;
}
AutoSweepJitScript
sweep
(
targetScript
)
;
StackTypeSet
*
thisTypes
=
jitScript
-
>
thisTypes
(
sweep
targetScript
)
;
if
(
!
thisTypes
-
>
hasType
(
TypeSet
:
:
ObjectType
(
templateObject
)
)
)
{
return
nullptr
;
}
MConstant
*
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
MCreateThisWithTemplate
*
createThis
=
MCreateThisWithTemplate
:
:
New
(
alloc
(
)
constraints
(
)
templateConst
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
)
;
current
-
>
add
(
templateConst
)
;
current
-
>
add
(
createThis
)
;
return
createThis
;
}
MDefinition
*
IonBuilder
:
:
createThisScriptedBaseline
(
MDefinition
*
callee
)
{
JSFunction
*
target
=
inspector
-
>
getSingleCallee
(
pc
)
;
if
(
!
target
|
|
!
target
-
>
hasBytecode
(
)
)
{
return
nullptr
;
}
if
(
target
-
>
constructorNeedsUninitializedThis
(
)
)
{
return
nullptr
;
}
JSObject
*
templateObject
=
inspector
-
>
getTemplateObject
(
pc
)
;
if
(
!
templateObject
)
{
return
nullptr
;
}
if
(
!
templateObject
-
>
is
<
PlainObject
>
(
)
)
{
return
nullptr
;
}
if
(
templateObject
-
>
nonCCWRealm
(
)
!
=
target
-
>
realm
(
)
)
{
return
nullptr
;
}
Shape
*
shape
=
target
-
>
lookupPure
(
realm
-
>
runtime
(
)
-
>
names
(
)
.
prototype
)
;
if
(
!
shape
|
|
!
shape
-
>
isDataProperty
(
)
)
{
return
nullptr
;
}
Value
protov
=
target
-
>
getSlot
(
shape
-
>
slot
(
)
)
;
if
(
!
protov
.
isObject
(
)
)
{
return
nullptr
;
}
JSObject
*
proto
=
checkNurseryObject
(
&
protov
.
toObject
(
)
)
;
if
(
proto
!
=
templateObject
-
>
staticPrototype
(
)
)
{
return
nullptr
;
}
TypeSet
:
:
ObjectKey
*
templateObjectKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
templateObject
-
>
group
(
)
)
;
if
(
templateObjectKey
-
>
hasFlags
(
constraints
(
)
OBJECT_FLAG_NEW_SCRIPT_CLEARED
)
)
{
return
nullptr
;
}
JSScript
*
targetScript
=
target
-
>
nonLazyScript
(
)
;
JitScript
*
jitScript
=
targetScript
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
return
nullptr
;
}
AutoSweepJitScript
sweep
(
targetScript
)
;
StackTypeSet
*
thisTypes
=
jitScript
-
>
thisTypes
(
sweep
targetScript
)
;
if
(
!
thisTypes
-
>
hasType
(
TypeSet
:
:
ObjectType
(
templateObject
)
)
)
{
return
nullptr
;
}
callee
=
addShapeGuard
(
callee
target
-
>
lastProperty
(
)
)
;
MOZ_ASSERT
(
shape
-
>
numFixedSlots
(
)
=
=
0
"
Must
be
a
dynamic
slot
"
)
;
MSlots
*
slots
=
MSlots
:
:
New
(
alloc
(
)
callee
)
;
current
-
>
add
(
slots
)
;
MLoadDynamicSlot
*
prototype
=
MLoadDynamicSlot
:
:
New
(
alloc
(
)
slots
shape
-
>
slot
(
)
)
;
current
-
>
add
(
prototype
)
;
MDefinition
*
protoConst
=
constant
(
ObjectValue
(
*
proto
)
)
;
MGuardObjectIdentity
*
guard
=
MGuardObjectIdentity
:
:
New
(
alloc
(
)
prototype
protoConst
false
)
;
current
-
>
add
(
guard
)
;
MConstant
*
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
MCreateThisWithTemplate
*
createThis
=
MCreateThisWithTemplate
:
:
New
(
alloc
(
)
constraints
(
)
templateConst
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
)
;
current
-
>
add
(
templateConst
)
;
current
-
>
add
(
createThis
)
;
return
createThis
;
}
MDefinition
*
IonBuilder
:
:
createThisSlow
(
MDefinition
*
callee
MDefinition
*
newTarget
bool
inlining
)
{
MOZ_ASSERT
(
!
inlining
)
;
MCreateThis
*
createThis
=
MCreateThis
:
:
New
(
alloc
(
)
callee
newTarget
)
;
current
-
>
add
(
createThis
)
;
return
createThis
;
}
MDefinition
*
IonBuilder
:
:
createThis
(
JSFunction
*
target
MDefinition
*
callee
MDefinition
*
newTarget
bool
inlining
)
{
MOZ_ASSERT_IF
(
target
target
-
>
isConstructor
(
)
)
;
MOZ_ASSERT_IF
(
inlining
target
)
;
if
(
!
target
)
{
if
(
callee
=
=
newTarget
)
{
if
(
MDefinition
*
createThis
=
createThisScriptedBaseline
(
callee
)
)
{
return
createThis
;
}
}
return
createThisSlow
(
callee
newTarget
inlining
)
;
}
if
(
target
-
>
isNative
(
)
)
{
MOZ_ASSERT
(
target
-
>
isNativeWithoutJitEntry
(
)
"
Natives
with
JitEntry
are
not
supported
for
constructor
calls
"
)
;
return
constant
(
MagicValue
(
JS_IS_CONSTRUCTING
)
)
;
}
if
(
target
-
>
constructorNeedsUninitializedThis
(
)
)
{
return
constant
(
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
}
if
(
callee
=
=
newTarget
)
{
MOZ_ASSERT_IF
(
inlining
target
-
>
hasNonConfigurablePrototypeDataProperty
(
)
)
;
if
(
MDefinition
*
createThis
=
createThisScriptedSingleton
(
target
)
)
{
return
createThis
;
}
if
(
MDefinition
*
createThis
=
createThisScriptedBaseline
(
callee
)
)
{
return
createThis
;
}
}
JSFunction
*
newTargetFun
=
callee
=
=
newTarget
?
target
:
getSingleCallTarget
(
newTarget
-
>
resultTypeSet
(
)
)
;
if
(
newTargetFun
&
&
newTargetFun
-
>
hasNonConfigurablePrototypeDataProperty
(
)
)
{
return
createThisScripted
(
callee
newTarget
)
;
}
MOZ_ASSERT
(
!
inlining
)
;
return
createThisSlow
(
callee
newTarget
inlining
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_funcall
(
uint32_t
argc
)
{
int
calleeDepth
=
-
(
(
int
)
argc
+
2
)
;
int
funcDepth
=
-
(
(
int
)
argc
+
1
)
;
TemporaryTypeSet
*
calleeTypes
=
current
-
>
peek
(
calleeDepth
)
-
>
resultTypeSet
(
)
;
JSFunction
*
native
=
getSingleCallTarget
(
calleeTypes
)
;
if
(
!
native
|
|
!
native
-
>
isNative
(
)
|
|
native
-
>
native
(
)
!
=
&
fun_call
)
{
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
makeCall
(
native
callInfo
)
;
}
current
-
>
peek
(
calleeDepth
)
-
>
setImplicitlyUsedUnchecked
(
)
;
TemporaryTypeSet
*
funTypes
=
current
-
>
peek
(
funcDepth
)
-
>
resultTypeSet
(
)
;
JSFunction
*
target
=
getSingleCallTarget
(
funTypes
)
;
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
savePriorCallStack
(
current
argc
+
2
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
shimmySlots
(
funcDepth
-
1
)
;
bool
zeroArguments
=
(
argc
=
=
0
)
;
if
(
zeroArguments
)
{
pushConstant
(
UndefinedValue
(
)
)
;
}
else
{
argc
-
=
1
;
}
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
zeroArguments
)
{
InliningDecision
decision
=
makeInliningDecision
(
target
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
case
InliningDecision_WarmUpCountTooLow
:
break
;
case
InliningDecision_Inline
:
{
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineSingleCall
(
callInfo
target
)
)
;
if
(
status
=
=
InliningStatus_Inlined
)
{
return
Ok
(
)
;
}
break
;
}
}
}
return
makeCall
(
target
callInfo
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_funapply
(
uint32_t
argc
)
{
int
calleeDepth
=
-
(
(
int
)
argc
+
2
)
;
TemporaryTypeSet
*
calleeTypes
=
current
-
>
peek
(
calleeDepth
)
-
>
resultTypeSet
(
)
;
JSFunction
*
native
=
getSingleCallTarget
(
calleeTypes
)
;
if
(
argc
!
=
2
|
|
info
(
)
.
analysisMode
(
)
=
=
Analysis_ArgumentsUsage
)
{
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
makeCall
(
native
callInfo
)
;
}
MDefinition
*
argument
=
current
-
>
peek
(
-
1
)
;
if
(
script
(
)
-
>
argumentsHasVarBinding
(
)
&
&
argument
-
>
mightBeType
(
MIRType
:
:
MagicOptimizedArguments
)
&
&
argument
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
return
abort
(
AbortReason
:
:
Disable
"
fun
.
apply
with
MaybeArguments
"
)
;
}
if
(
argument
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
TemporaryTypeSet
*
objTypes
=
argument
-
>
resultTypeSet
(
)
;
if
(
native
&
&
native
-
>
isNative
(
)
&
&
native
-
>
native
(
)
=
=
fun_apply
&
&
objTypes
&
&
objTypes
-
>
getKnownClass
(
constraints
(
)
)
=
=
&
ArrayObject
:
:
class_
&
&
!
objTypes
-
>
hasObjectFlags
(
constraints
(
)
OBJECT_FLAG_LENGTH_OVERFLOW
)
&
&
ElementAccessIsPacked
(
constraints
(
)
argument
)
)
{
return
jsop_funapplyarray
(
argc
)
;
}
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
makeCall
(
native
callInfo
)
;
}
if
(
(
!
native
|
|
!
native
-
>
isNative
(
)
|
|
native
-
>
native
(
)
!
=
fun_apply
)
&
&
info
(
)
.
analysisMode
(
)
!
=
Analysis_DefiniteProperties
)
{
return
abort
(
AbortReason
:
:
Disable
"
fun
.
apply
speculation
failed
"
)
;
}
return
jsop_funapplyarguments
(
argc
)
;
}
static
void
AssertSpreadArgIsArray
(
MDefinition
*
argument
CompilerConstraintList
*
constraints
)
{
#
ifdef
DEBUG
if
(
TemporaryTypeSet
*
objTypes
=
argument
-
>
resultTypeSet
(
)
)
{
if
(
const
JSClass
*
clasp
=
objTypes
-
>
getKnownClass
(
constraints
)
)
{
MOZ_ASSERT
(
clasp
=
=
&
ArrayObject
:
:
class_
)
;
}
}
#
endif
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_spreadcall
(
)
{
MDefinition
*
argArr
=
current
-
>
pop
(
)
;
MDefinition
*
argThis
=
current
-
>
pop
(
)
;
MDefinition
*
argFunc
=
current
-
>
pop
(
)
;
AssertSpreadArgIsArray
(
argArr
constraints
(
)
)
;
TemporaryTypeSet
*
funTypes
=
argFunc
-
>
resultTypeSet
(
)
;
JSFunction
*
target
=
getSingleCallTarget
(
funTypes
)
;
WrappedFunction
*
wrappedTarget
=
target
?
new
(
alloc
(
)
)
WrappedFunction
(
target
)
:
nullptr
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
argArr
)
;
current
-
>
add
(
elements
)
;
MApplyArray
*
apply
=
MApplyArray
:
:
New
(
alloc
(
)
wrappedTarget
argFunc
elements
argThis
)
;
current
-
>
add
(
apply
)
;
current
-
>
push
(
apply
)
;
MOZ_TRY
(
resumeAfter
(
apply
)
)
;
if
(
target
&
&
target
-
>
realm
(
)
=
=
script
(
)
-
>
realm
(
)
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
if
(
BytecodeIsPopped
(
pc
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
apply
types
BarrierKind
:
:
TypeSet
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_spreadnew
(
)
{
MDefinition
*
newTarget
=
current
-
>
pop
(
)
;
MDefinition
*
argArr
=
current
-
>
pop
(
)
;
MDefinition
*
thisValue
=
current
-
>
pop
(
)
;
MDefinition
*
callee
=
current
-
>
pop
(
)
;
AssertSpreadArgIsArray
(
argArr
constraints
(
)
)
;
TemporaryTypeSet
*
funTypes
=
callee
-
>
resultTypeSet
(
)
;
JSFunction
*
target
=
getSingleCallTarget
(
funTypes
)
;
if
(
target
&
&
!
target
-
>
isConstructor
(
)
)
{
target
=
nullptr
;
}
WrappedFunction
*
wrappedTarget
=
target
?
new
(
alloc
(
)
)
WrappedFunction
(
target
)
:
nullptr
;
MDefinition
*
create
=
createThis
(
target
callee
newTarget
false
)
;
thisValue
-
>
setImplicitlyUsedUnchecked
(
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
argArr
)
;
current
-
>
add
(
elements
)
;
auto
*
apply
=
MConstructArray
:
:
New
(
alloc
(
)
wrappedTarget
callee
elements
create
newTarget
)
;
current
-
>
add
(
apply
)
;
current
-
>
push
(
apply
)
;
MOZ_TRY
(
resumeAfter
(
apply
)
)
;
if
(
target
&
&
target
-
>
realm
(
)
=
=
script
(
)
-
>
realm
(
)
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
apply
types
BarrierKind
:
:
TypeSet
)
;
}
bool
IonBuilder
:
:
propertyIsConstantFunction
(
NativeObject
*
nobj
jsid
id
bool
(
*
test
)
(
IonBuilder
*
builder
JSFunction
*
fun
)
)
{
if
(
!
nobj
-
>
isSingleton
(
)
)
{
return
false
;
}
TypeSet
:
:
ObjectKey
*
objKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
nobj
)
;
if
(
analysisContext
)
{
objKey
-
>
ensureTrackedProperty
(
analysisContext
id
)
;
}
if
(
objKey
-
>
unknownProperties
(
)
)
{
return
false
;
}
HeapTypeSetKey
property
=
objKey
-
>
property
(
id
)
;
Value
value
=
UndefinedValue
(
)
;
if
(
!
property
.
constant
(
constraints
(
)
&
value
)
)
{
return
false
;
}
return
value
.
isObject
(
)
&
&
value
.
toObject
(
)
.
is
<
JSFunction
>
(
)
&
&
test
(
this
&
value
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
}
bool
IonBuilder
:
:
ensureArrayPrototypeIteratorNotModified
(
)
{
NativeObject
*
obj
=
script
(
)
-
>
global
(
)
.
maybeGetArrayPrototype
(
)
;
if
(
!
obj
)
{
return
false
;
}
jsid
id
=
SYMBOL_TO_JSID
(
realm
-
>
runtime
(
)
-
>
wellKnownSymbols
(
)
.
iterator
)
;
return
propertyIsConstantFunction
(
obj
id
[
]
(
auto
*
builder
auto
*
fun
)
{
CompileRuntime
*
runtime
=
builder
-
>
mirGen
(
)
.
runtime
;
return
IsSelfHostedFunctionWithName
(
fun
runtime
-
>
names
(
)
.
ArrayValues
)
;
}
)
;
}
bool
IonBuilder
:
:
ensureArrayIteratorPrototypeNextNotModified
(
)
{
NativeObject
*
obj
=
script
(
)
-
>
global
(
)
.
maybeGetArrayIteratorPrototype
(
)
;
if
(
!
obj
)
{
return
false
;
}
jsid
id
=
NameToId
(
mirGen_
.
runtime
-
>
names
(
)
.
next
)
;
return
propertyIsConstantFunction
(
obj
id
[
]
(
auto
*
builder
auto
*
fun
)
{
return
IsSelfHostedFunctionWithName
(
fun
builder
-
>
mirGen
(
)
.
runtime
-
>
names
(
)
.
ArrayIteratorNext
)
;
}
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_optimize_spreadcall
(
)
{
MDefinition
*
arr
=
current
-
>
peek
(
-
1
)
;
bool
result
=
false
;
do
{
TemporaryTypeSet
*
types
=
arr
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
getKnownClass
(
constraints
(
)
)
!
=
&
ArrayObject
:
:
class_
)
{
break
;
}
JSObject
*
proto
;
if
(
!
types
-
>
getCommonPrototype
(
constraints
(
)
&
proto
)
)
{
break
;
}
NativeObject
*
arrayProto
=
script
(
)
-
>
global
(
)
.
maybeGetArrayPrototype
(
)
;
if
(
!
arrayProto
|
|
arrayProto
!
=
proto
)
{
break
;
}
jsid
id
=
SYMBOL_TO_JSID
(
realm
-
>
runtime
(
)
-
>
wellKnownSymbols
(
)
.
iterator
)
;
bool
res
;
MOZ_TRY_VAR
(
res
testNotDefinedProperty
(
arr
id
true
)
)
;
if
(
!
res
)
{
break
;
}
if
(
!
ensureArrayPrototypeIteratorNotModified
(
)
)
{
break
;
}
if
(
!
ensureArrayIteratorPrototypeNextNotModified
(
)
)
{
break
;
}
result
=
true
;
}
while
(
false
)
;
if
(
result
)
{
auto
*
ins
=
MIsPackedArray
:
:
New
(
alloc
(
)
arr
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
auto
*
ins
=
MOptimizeSpreadCallCache
:
:
New
(
alloc
(
)
arr
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_funapplyarray
(
uint32_t
argc
)
{
MOZ_ASSERT
(
argc
=
=
2
)
;
int
funcDepth
=
-
(
(
int
)
argc
+
1
)
;
TemporaryTypeSet
*
funTypes
=
current
-
>
peek
(
funcDepth
)
-
>
resultTypeSet
(
)
;
JSFunction
*
target
=
getSingleCallTarget
(
funTypes
)
;
MDefinition
*
argObj
=
current
-
>
pop
(
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
argObj
)
;
current
-
>
add
(
elements
)
;
MDefinition
*
argThis
=
current
-
>
pop
(
)
;
MDefinition
*
argFunc
=
current
-
>
pop
(
)
;
MDefinition
*
nativeFunc
=
current
-
>
pop
(
)
;
nativeFunc
-
>
setImplicitlyUsedUnchecked
(
)
;
WrappedFunction
*
wrappedTarget
=
target
?
new
(
alloc
(
)
)
WrappedFunction
(
target
)
:
nullptr
;
MApplyArray
*
apply
=
MApplyArray
:
:
New
(
alloc
(
)
wrappedTarget
argFunc
elements
argThis
)
;
current
-
>
add
(
apply
)
;
current
-
>
push
(
apply
)
;
MOZ_TRY
(
resumeAfter
(
apply
)
)
;
if
(
target
&
&
target
-
>
realm
(
)
=
=
script
(
)
-
>
realm
(
)
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
if
(
BytecodeIsPopped
(
pc
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
apply
types
BarrierKind
:
:
TypeSet
)
;
}
bool
CallInfo
:
:
savePriorCallStack
(
MBasicBlock
*
current
size_t
peekDepth
)
{
MOZ_ASSERT
(
priorArgs_
.
empty
(
)
)
;
if
(
!
priorArgs_
.
reserve
(
peekDepth
)
)
{
return
false
;
}
while
(
peekDepth
)
{
priorArgs_
.
infallibleAppend
(
current
-
>
peek
(
0
-
int32_t
(
peekDepth
)
)
)
;
peekDepth
-
-
;
}
return
true
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_funapplyarguments
(
uint32_t
argc
)
{
int
funcDepth
=
-
(
(
int
)
argc
+
1
)
;
TemporaryTypeSet
*
funTypes
=
current
-
>
peek
(
funcDepth
)
-
>
resultTypeSet
(
)
;
JSFunction
*
target
=
getSingleCallTarget
(
funTypes
)
;
if
(
inliningDepth_
=
=
0
&
&
info
(
)
.
analysisMode
(
)
!
=
Analysis_DefiniteProperties
)
{
MDefinition
*
vp
=
current
-
>
pop
(
)
;
vp
-
>
setImplicitlyUsedUnchecked
(
)
;
MDefinition
*
argThis
=
current
-
>
pop
(
)
;
MDefinition
*
argFunc
=
current
-
>
pop
(
)
;
MDefinition
*
nativeFunc
=
current
-
>
pop
(
)
;
nativeFunc
-
>
setImplicitlyUsedUnchecked
(
)
;
MArgumentsLength
*
numArgs
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
numArgs
)
;
WrappedFunction
*
wrappedTarget
=
target
?
new
(
alloc
(
)
)
WrappedFunction
(
target
)
:
nullptr
;
MApplyArgs
*
apply
=
MApplyArgs
:
:
New
(
alloc
(
)
wrappedTarget
argFunc
numArgs
argThis
)
;
current
-
>
add
(
apply
)
;
current
-
>
push
(
apply
)
;
MOZ_TRY
(
resumeAfter
(
apply
)
)
;
if
(
target
&
&
target
-
>
realm
(
)
=
=
script
(
)
-
>
realm
(
)
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
if
(
BytecodeIsPopped
(
pc
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
apply
types
BarrierKind
:
:
TypeSet
)
;
}
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
savePriorCallStack
(
current
4
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MDefinition
*
vp
=
current
-
>
pop
(
)
;
vp
-
>
setImplicitlyUsedUnchecked
(
)
;
if
(
inliningDepth_
)
{
if
(
!
callInfo
.
setArgs
(
inlineCallInfo_
-
>
argv
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
MDefinition
*
argThis
=
current
-
>
pop
(
)
;
callInfo
.
setThis
(
argThis
)
;
MDefinition
*
argFunc
=
current
-
>
pop
(
)
;
callInfo
.
setCallee
(
argFunc
)
;
MDefinition
*
nativeFunc
=
current
-
>
pop
(
)
;
nativeFunc
-
>
setImplicitlyUsedUnchecked
(
)
;
InliningDecision
decision
=
makeInliningDecision
(
target
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
case
InliningDecision_WarmUpCountTooLow
:
break
;
case
InliningDecision_Inline
:
{
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineSingleCall
(
callInfo
target
)
)
;
if
(
status
=
=
InliningStatus_Inlined
)
{
return
Ok
(
)
;
}
}
}
return
makeCall
(
target
callInfo
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_call
(
uint32_t
argc
bool
constructing
bool
ignoresReturnValue
)
{
TemporaryTypeSet
*
observed
=
bytecodeTypes
(
pc
)
;
if
(
observed
-
>
empty
(
)
)
{
if
(
BytecodeFlowsToBitop
(
pc
)
)
{
observed
-
>
addType
(
TypeSet
:
:
Int32Type
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
else
if
(
JSOp
(
*
GetNextPc
(
pc
)
)
=
=
JSOp
:
:
Pos
)
{
observed
-
>
addType
(
TypeSet
:
:
DoubleType
(
)
alloc_
-
>
lifoAlloc
(
)
)
;
}
}
int
calleeDepth
=
-
(
(
int
)
argc
+
2
+
constructing
)
;
InliningTargets
targets
(
alloc
(
)
)
;
TemporaryTypeSet
*
calleeTypes
=
current
-
>
peek
(
calleeDepth
)
-
>
resultTypeSet
(
)
;
if
(
calleeTypes
)
{
MOZ_TRY
(
getPolyCallTargets
(
calleeTypes
constructing
targets
4
)
)
;
}
CallInfo
callInfo
(
alloc
(
)
pc
constructing
ignoresReturnValue
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineCallsite
(
targets
callInfo
)
)
;
if
(
status
=
=
InliningStatus_Inlined
)
{
return
Ok
(
)
;
}
replaceMaybeFallbackFunctionGetter
(
nullptr
)
;
Maybe
<
CallTargets
>
callTargets
;
if
(
!
targets
.
empty
(
)
)
{
callTargets
.
emplace
(
alloc
(
)
)
;
for
(
const
InliningTarget
&
target
:
targets
)
{
if
(
!
target
.
target
-
>
is
<
JSFunction
>
(
)
)
{
callTargets
=
Nothing
(
)
;
break
;
}
if
(
!
callTargets
-
>
append
(
&
target
.
target
-
>
as
<
JSFunction
>
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
}
if
(
status
=
=
InliningStatus_WarmUpCountTooLow
&
&
callTargets
&
&
callTargets
-
>
length
(
)
=
=
1
&
&
isHighestOptimizationLevel
(
)
)
{
JSFunction
*
target
=
callTargets
.
ref
(
)
[
0
]
;
MRecompileCheck
*
check
=
MRecompileCheck
:
:
New
(
alloc
(
)
target
-
>
nonLazyScript
(
)
optimizationInfo
(
)
.
inliningRecompileThreshold
(
)
MRecompileCheck
:
:
RecompileCheckType
:
:
Inlining
)
;
current
-
>
add
(
check
)
;
}
return
makeCall
(
callTargets
callInfo
)
;
}
AbortReasonOr
<
bool
>
IonBuilder
:
:
testShouldDOMCall
(
TypeSet
*
inTypes
JSFunction
*
func
JSJitInfo
:
:
OpType
opType
)
{
if
(
!
func
-
>
isNative
(
)
|
|
!
func
-
>
hasJitInfo
(
)
)
{
return
false
;
}
DOMInstanceClassHasProtoAtDepth
instanceChecker
=
realm
-
>
runtime
(
)
-
>
DOMcallbacks
(
)
-
>
instanceClassMatchesProto
;
const
JSJitInfo
*
jinfo
=
func
-
>
jitInfo
(
)
;
if
(
jinfo
-
>
type
(
)
!
=
opType
)
{
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
inTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
inTypes
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
key
-
>
hasStableClassAndProto
(
constraints
(
)
)
)
{
return
false
;
}
if
(
!
instanceChecker
(
key
-
>
clasp
(
)
jinfo
-
>
protoID
jinfo
-
>
depth
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ArgumentTypesMatch
(
MDefinition
*
def
StackTypeSet
*
calleeTypes
)
{
MOZ_ASSERT
(
calleeTypes
)
;
if
(
calleeTypes
-
>
unknown
(
)
)
{
return
true
;
}
if
(
TypeSet
:
:
IsUntrackedMIRType
(
def
-
>
type
(
)
)
)
{
return
false
;
}
if
(
def
-
>
resultTypeSet
(
)
)
{
MOZ_ASSERT
(
def
-
>
type
(
)
=
=
MIRType
:
:
Value
|
|
def
-
>
mightBeType
(
def
-
>
type
(
)
)
)
;
return
def
-
>
resultTypeSet
(
)
-
>
isSubset
(
calleeTypes
)
;
}
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
return
false
;
}
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
return
calleeTypes
-
>
unknownObject
(
)
;
}
return
calleeTypes
-
>
mightBeMIRType
(
def
-
>
type
(
)
)
;
}
bool
IonBuilder
:
:
testNeedsArgumentCheck
(
JSFunction
*
target
CallInfo
&
callInfo
)
{
if
(
!
target
-
>
hasBytecode
(
)
)
{
return
true
;
}
JSScript
*
targetScript
=
target
-
>
nonLazyScript
(
)
;
JitScript
*
jitScript
=
targetScript
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
return
true
;
}
AutoSweepJitScript
sweep
(
targetScript
)
;
if
(
!
ArgumentTypesMatch
(
callInfo
.
thisArg
(
)
jitScript
-
>
thisTypes
(
sweep
targetScript
)
)
)
{
return
true
;
}
uint32_t
expected_args
=
std
:
:
min
<
uint32_t
>
(
callInfo
.
argc
(
)
target
-
>
nargs
(
)
)
;
for
(
size_t
i
=
0
;
i
<
expected_args
;
i
+
+
)
{
if
(
!
ArgumentTypesMatch
(
callInfo
.
getArg
(
i
)
jitScript
-
>
argTypes
(
sweep
targetScript
i
)
)
)
{
return
true
;
}
}
for
(
size_t
i
=
callInfo
.
argc
(
)
;
i
<
target
-
>
nargs
(
)
;
i
+
+
)
{
StackTypeSet
*
types
=
jitScript
-
>
argTypes
(
sweep
targetScript
i
)
;
if
(
!
types
-
>
mightBeMIRType
(
MIRType
:
:
Undefined
)
)
{
return
true
;
}
}
return
false
;
}
AbortReasonOr
<
MCall
*
>
IonBuilder
:
:
makeCallHelper
(
const
Maybe
<
CallTargets
>
&
targets
CallInfo
&
callInfo
)
{
MOZ_ASSERT_IF
(
targets
!
targets
-
>
empty
(
)
)
;
JSFunction
*
target
=
nullptr
;
if
(
targets
&
&
targets
-
>
length
(
)
=
=
1
)
{
target
=
targets
.
ref
(
)
[
0
]
;
}
bool
isDOMCall
=
false
;
DOMObjectKind
objKind
=
DOMObjectKind
:
:
Unknown
;
if
(
target
&
&
!
callInfo
.
constructing
(
)
)
{
TemporaryTypeSet
*
thisTypes
=
callInfo
.
thisArg
(
)
-
>
resultTypeSet
(
)
;
if
(
thisTypes
&
&
thisTypes
-
>
getKnownMIRType
(
)
=
=
MIRType
:
:
Object
&
&
thisTypes
-
>
isDOMClass
(
constraints
(
)
&
objKind
)
)
{
MOZ_TRY_VAR
(
isDOMCall
testShouldDOMCall
(
thisTypes
target
JSJitInfo
:
:
Method
)
)
;
}
}
bool
needsThisCheck
=
false
;
if
(
callInfo
.
constructing
(
)
)
{
MDefinition
*
create
=
createThis
(
target
callInfo
.
callee
(
)
callInfo
.
getNewTarget
(
)
false
)
;
callInfo
.
thisArg
(
)
-
>
setImplicitlyUsedUnchecked
(
)
;
callInfo
.
setThis
(
create
)
;
needsThisCheck
=
create
-
>
isCreateThis
(
)
;
if
(
needsThisCheck
)
{
target
=
nullptr
;
}
}
uint32_t
targetArgs
=
callInfo
.
argc
(
)
;
if
(
target
&
&
target
-
>
hasJitEntry
(
)
)
{
targetArgs
=
std
:
:
max
<
uint32_t
>
(
target
-
>
nargs
(
)
callInfo
.
argc
(
)
)
;
}
WrappedFunction
*
wrappedTarget
=
target
?
new
(
alloc
(
)
)
WrappedFunction
(
target
)
:
nullptr
;
MCall
*
call
=
MCall
:
:
New
(
alloc
(
)
wrappedTarget
targetArgs
+
1
+
callInfo
.
constructing
(
)
callInfo
.
argc
(
)
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
isDOMCall
objKind
)
;
if
(
!
call
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
callInfo
.
constructing
(
)
)
{
if
(
needsThisCheck
)
{
call
-
>
setNeedsThisCheck
(
)
;
}
call
-
>
addArg
(
targetArgs
+
1
callInfo
.
getNewTarget
(
)
)
;
}
MOZ_ASSERT_IF
(
target
&
&
targetArgs
>
callInfo
.
argc
(
)
target
-
>
hasJitEntry
(
)
)
;
for
(
int
i
=
targetArgs
;
i
>
(
int
)
callInfo
.
argc
(
)
;
i
-
-
)
{
MConstant
*
undef
=
constant
(
UndefinedValue
(
)
)
;
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
call
-
>
addArg
(
i
undef
)
;
}
for
(
int32_t
i
=
callInfo
.
argc
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
call
-
>
addArg
(
i
+
1
callInfo
.
getArg
(
i
)
)
;
}
call
-
>
computeMovable
(
)
;
MDefinition
*
thisArg
=
callInfo
.
thisArg
(
)
;
call
-
>
addArg
(
0
thisArg
)
;
if
(
targets
)
{
call
-
>
disableClassCheck
(
)
;
bool
needArgCheck
=
false
;
bool
maybeCrossRealm
=
false
;
for
(
JSFunction
*
target
:
targets
.
ref
(
)
)
{
if
(
testNeedsArgumentCheck
(
target
callInfo
)
)
{
needArgCheck
=
true
;
}
if
(
target
-
>
realm
(
)
!
=
script
(
)
-
>
realm
(
)
)
{
maybeCrossRealm
=
true
;
}
}
if
(
!
needArgCheck
)
{
call
-
>
disableArgCheck
(
)
;
}
if
(
!
maybeCrossRealm
)
{
call
-
>
setNotCrossRealm
(
)
;
}
}
call
-
>
initCallee
(
callInfo
.
callee
(
)
)
;
current
-
>
add
(
call
)
;
return
call
;
}
static
bool
DOMCallNeedsBarrier
(
const
JSJitInfo
*
jitinfo
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
jitinfo
-
>
type
(
)
!
=
JSJitInfo
:
:
InlinableNative
)
;
if
(
jitinfo
-
>
returnType
(
)
=
=
JSVAL_TYPE_UNKNOWN
)
{
return
true
;
}
if
(
jitinfo
-
>
returnType
(
)
=
=
JSVAL_TYPE_OBJECT
)
{
return
true
;
}
return
MIRTypeFromValueType
(
jitinfo
-
>
returnType
(
)
)
!
=
types
-
>
getKnownMIRType
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
makeCall
(
const
Maybe
<
CallTargets
>
&
targets
CallInfo
&
callInfo
)
{
#
ifdef
DEBUG
if
(
callInfo
.
constructing
(
)
&
&
targets
)
{
for
(
JSFunction
*
target
:
targets
.
ref
(
)
)
{
MOZ_ASSERT
(
target
-
>
isConstructor
(
)
)
;
}
}
#
endif
MCall
*
call
;
MOZ_TRY_VAR
(
call
makeCallHelper
(
targets
callInfo
)
)
;
current
-
>
push
(
call
)
;
if
(
call
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
call
)
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
if
(
call
-
>
isCallDOMNative
(
)
)
{
return
pushDOMTypeBarrier
(
call
types
call
-
>
getSingleTarget
(
)
-
>
rawNativeJSFunction
(
)
)
;
}
return
pushTypeBarrier
(
call
types
BarrierKind
:
:
TypeSet
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
makeCall
(
JSFunction
*
target
CallInfo
&
callInfo
)
{
Maybe
<
CallTargets
>
targets
;
if
(
target
)
{
targets
.
emplace
(
alloc
(
)
)
;
if
(
!
targets
-
>
append
(
target
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
return
makeCall
(
targets
callInfo
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_eval
(
uint32_t
argc
)
{
int
calleeDepth
=
-
(
(
int
)
argc
+
2
)
;
TemporaryTypeSet
*
calleeTypes
=
current
-
>
peek
(
calleeDepth
)
-
>
resultTypeSet
(
)
;
if
(
calleeTypes
&
&
calleeTypes
-
>
empty
(
)
)
{
return
jsop_call
(
argc
false
false
)
;
}
JSFunction
*
target
=
getSingleCallTarget
(
calleeTypes
)
;
if
(
!
target
)
{
return
abort
(
AbortReason
:
:
Disable
"
No
single
callee
for
eval
(
)
"
)
;
}
if
(
script
(
)
-
>
global
(
)
.
valueIsEval
(
ObjectValue
(
*
target
)
)
)
{
if
(
argc
!
=
1
)
{
return
abort
(
AbortReason
:
:
Disable
"
Direct
eval
with
more
than
one
argument
"
)
;
}
if
(
!
info
(
)
.
funMaybeLazy
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Direct
eval
in
global
code
"
)
;
}
if
(
info
(
)
.
funMaybeLazy
(
)
-
>
isArrow
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Direct
eval
from
arrow
function
"
)
;
}
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
callInfo
.
setImplicitlyUsedUnchecked
(
)
;
callInfo
.
callee
(
)
-
>
setImplicitlyUsedUnchecked
(
)
;
MDefinition
*
envChain
=
current
-
>
environmentChain
(
)
;
MDefinition
*
string
=
callInfo
.
getArg
(
0
)
;
if
(
!
string
-
>
mightBeType
(
MIRType
:
:
String
)
)
{
current
-
>
push
(
string
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
string
types
BarrierKind
:
:
TypeSet
)
;
}
MOZ_TRY
(
jsop_newtarget
(
)
)
;
MDefinition
*
newTargetValue
=
current
-
>
pop
(
)
;
if
(
string
-
>
isConcat
(
)
&
&
string
-
>
getOperand
(
1
)
-
>
type
(
)
=
=
MIRType
:
:
String
&
&
string
-
>
getOperand
(
1
)
-
>
maybeConstantValue
(
)
)
{
JSAtom
*
atom
=
&
string
-
>
getOperand
(
1
)
-
>
maybeConstantValue
(
)
-
>
toString
(
)
-
>
asAtom
(
)
;
if
(
StringEqualsLiteral
(
atom
"
(
)
"
)
)
{
MDefinition
*
name
=
string
-
>
getOperand
(
0
)
;
MInstruction
*
dynamicName
=
MGetDynamicName
:
:
New
(
alloc
(
)
envChain
name
)
;
current
-
>
add
(
dynamicName
)
;
current
-
>
push
(
dynamicName
)
;
current
-
>
push
(
constant
(
UndefinedValue
(
)
)
)
;
CallInfo
evalCallInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
evalCallInfo
.
init
(
current
0
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
makeCall
(
nullptr
evalCallInfo
)
;
}
}
MInstruction
*
ins
=
MCallDirectEval
:
:
New
(
alloc
(
)
envChain
string
newTargetValue
pc
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
return
jsop_call
(
argc
false
false
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_compare
(
JSOp
op
)
{
MDefinition
*
right
=
current
-
>
pop
(
)
;
MDefinition
*
left
=
current
-
>
pop
(
)
;
return
jsop_compare
(
op
left
right
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_compare
(
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
compareTrySpecialized
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
compareTryBitwise
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
compareTrySpecializedOnBaselineInspector
(
&
emitted
op
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MOZ_TRY
(
compareTryBinaryStub
(
&
emitted
left
right
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MCompare
*
ins
=
MCompare
:
:
New
(
alloc
(
)
left
right
op
)
;
ins
-
>
cacheOperandMightEmulateUndefined
(
constraints
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
if
(
ins
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
}
return
Ok
(
)
;
}
static
bool
ObjectOrSimplePrimitive
(
MDefinition
*
op
)
{
return
op
-
>
definitelyType
(
{
MIRType
:
:
Undefined
MIRType
:
:
Null
MIRType
:
:
Boolean
MIRType
:
:
Int32
MIRType
:
:
Symbol
MIRType
:
:
Object
}
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
compareTrySpecialized
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MCompare
:
:
CompareType
type
=
MCompare
:
:
determineCompareType
(
op
left
right
)
;
if
(
type
=
=
MCompare
:
:
Compare_Unknown
)
{
return
Ok
(
)
;
}
MCompare
*
ins
=
MCompare
:
:
New
(
alloc
(
)
left
right
op
)
;
ins
-
>
setCompareType
(
type
)
;
ins
-
>
cacheOperandMightEmulateUndefined
(
constraints
(
)
)
;
if
(
type
=
=
MCompare
:
:
Compare_StrictString
&
&
right
-
>
type
(
)
!
=
MIRType
:
:
String
)
{
ins
-
>
swapOperands
(
)
;
}
else
if
(
type
=
=
MCompare
:
:
Compare_Null
&
&
right
-
>
type
(
)
!
=
MIRType
:
:
Null
)
{
ins
-
>
swapOperands
(
)
;
}
else
if
(
type
=
=
MCompare
:
:
Compare_Undefined
&
&
right
-
>
type
(
)
!
=
MIRType
:
:
Undefined
)
{
ins
-
>
swapOperands
(
)
;
}
else
if
(
type
=
=
MCompare
:
:
Compare_Boolean
&
&
right
-
>
type
(
)
!
=
MIRType
:
:
Boolean
)
{
ins
-
>
swapOperands
(
)
;
}
if
(
type
=
=
MCompare
:
:
Compare_UInt32
)
{
ins
-
>
replaceWithUnsignedOperands
(
)
;
}
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_ASSERT
(
!
ins
-
>
isEffectful
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
compareTryBitwise
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
op
!
=
JSOp
:
:
Eq
&
&
op
!
=
JSOp
:
:
Ne
&
&
op
!
=
JSOp
:
:
StrictEq
&
&
op
!
=
JSOp
:
:
StrictNe
)
{
return
Ok
(
)
;
}
if
(
!
ObjectOrSimplePrimitive
(
left
)
|
|
!
ObjectOrSimplePrimitive
(
right
)
)
{
return
Ok
(
)
;
}
if
(
op
=
=
JSOp
:
:
Eq
|
|
op
=
=
JSOp
:
:
Ne
)
{
if
(
left
-
>
maybeEmulatesUndefined
(
constraints
(
)
)
|
|
right
-
>
maybeEmulatesUndefined
(
constraints
(
)
)
)
{
return
Ok
(
)
;
}
if
(
(
left
-
>
mightBeType
(
MIRType
:
:
Undefined
)
&
&
right
-
>
mightBeType
(
MIRType
:
:
Null
)
)
|
|
(
left
-
>
mightBeType
(
MIRType
:
:
Null
)
&
&
right
-
>
mightBeType
(
MIRType
:
:
Undefined
)
)
)
{
return
Ok
(
)
;
}
if
(
(
left
-
>
mightBeType
(
MIRType
:
:
Int32
)
&
&
right
-
>
mightBeType
(
MIRType
:
:
Boolean
)
)
|
|
(
left
-
>
mightBeType
(
MIRType
:
:
Boolean
)
&
&
right
-
>
mightBeType
(
MIRType
:
:
Int32
)
)
)
{
return
Ok
(
)
;
}
bool
simpleLHS
=
left
-
>
mightBeType
(
MIRType
:
:
Boolean
)
|
|
left
-
>
mightBeType
(
MIRType
:
:
Int32
)
|
|
left
-
>
mightBeType
(
MIRType
:
:
Symbol
)
;
bool
simpleRHS
=
right
-
>
mightBeType
(
MIRType
:
:
Boolean
)
|
|
right
-
>
mightBeType
(
MIRType
:
:
Int32
)
|
|
right
-
>
mightBeType
(
MIRType
:
:
Symbol
)
;
if
(
(
left
-
>
mightBeType
(
MIRType
:
:
Object
)
&
&
simpleRHS
)
|
|
(
right
-
>
mightBeType
(
MIRType
:
:
Object
)
&
&
simpleLHS
)
)
{
return
Ok
(
)
;
}
}
MCompare
*
ins
=
MCompare
:
:
New
(
alloc
(
)
left
right
op
)
;
ins
-
>
setCompareType
(
MCompare
:
:
Compare_Bitwise
)
;
ins
-
>
cacheOperandMightEmulateUndefined
(
constraints
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_ASSERT
(
!
ins
-
>
isEffectful
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
compareTrySpecializedOnBaselineInspector
(
bool
*
emitted
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
IsInvokePC
(
pc
)
)
{
return
Ok
(
)
;
}
if
(
op
=
=
JSOp
:
:
StrictEq
|
|
op
=
=
JSOp
:
:
StrictNe
)
{
return
Ok
(
)
;
}
MCompare
:
:
CompareType
type
=
inspector
-
>
expectedCompareType
(
pc
)
;
if
(
type
=
=
MCompare
:
:
Compare_Unknown
)
{
return
Ok
(
)
;
}
MCompare
*
ins
=
MCompare
:
:
New
(
alloc
(
)
left
right
op
)
;
ins
-
>
setCompareType
(
type
)
;
ins
-
>
cacheOperandMightEmulateUndefined
(
constraints
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_ASSERT
(
!
ins
-
>
isEffectful
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
compareTryBinaryStub
(
bool
*
emitted
MDefinition
*
left
MDefinition
*
right
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
JitOptions
.
disableCacheIR
)
{
return
Ok
(
)
;
}
if
(
IsInvokePC
(
pc
)
)
{
return
Ok
(
)
;
}
MBinaryCache
*
stub
=
MBinaryCache
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Boolean
)
;
current
-
>
add
(
stub
)
;
current
-
>
push
(
stub
)
;
MOZ_TRY
(
resumeAfter
(
stub
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
newArrayTryTemplateObject
(
bool
*
emitted
JSObject
*
templateObject
uint32_t
length
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
templateObject
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
length
<
=
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
;
size_t
arraySlots
=
gc
:
:
GetGCKindSlots
(
templateObject
-
>
asTenured
(
)
.
getAllocKind
(
)
)
-
ObjectElements
:
:
VALUES_PER_HEADER
;
if
(
length
>
arraySlots
)
{
return
Ok
(
)
;
}
gc
:
:
InitialHeap
heap
=
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
;
MConstant
*
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
current
-
>
add
(
templateConst
)
;
MNewArray
*
ins
=
MNewArray
:
:
New
(
alloc
(
)
constraints
(
)
length
templateConst
heap
pc
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
newArrayTryVM
(
bool
*
emitted
JSObject
*
templateObject
uint32_t
length
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
;
MConstant
*
templateConst
=
MConstant
:
:
New
(
alloc
(
)
NullValue
(
)
)
;
if
(
templateObject
)
{
heap
=
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
;
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
}
current
-
>
add
(
templateConst
)
;
MNewArray
*
ins
=
MNewArray
:
:
NewVM
(
alloc
(
)
constraints
(
)
length
templateConst
heap
pc
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_newarray
(
uint32_t
length
)
{
JSObject
*
templateObject
=
inspector
-
>
getTemplateObject
(
pc
)
;
MOZ_TRY
(
jsop_newarray
(
templateObject
length
)
)
;
ObjectGroup
*
templateGroup
=
inspector
-
>
getTemplateObjectGroup
(
pc
)
;
if
(
templateGroup
)
{
TemporaryTypeSet
*
types
=
MakeSingletonTypeSet
(
alloc
(
)
constraints
(
)
templateGroup
)
;
current
-
>
peek
(
-
1
)
-
>
setResultTypeSet
(
types
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_newarray
(
JSObject
*
templateObject
uint32_t
length
)
{
bool
emitted
=
false
;
MOZ_TRY
(
newArrayTryTemplateObject
(
&
emitted
templateObject
length
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
newArrayTryVM
(
&
emitted
templateObject
length
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_CRASH
(
"
newarray
should
have
been
emited
"
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_newarray_copyonwrite
(
)
{
ArrayObject
*
templateObject
=
ObjectGroup
:
:
getCopyOnWriteObject
(
script
(
)
pc
)
;
ObjectGroup
*
group
=
templateObject
-
>
group
(
)
;
MOZ_ASSERT_IF
(
info
(
)
.
analysisMode
(
)
!
=
Analysis_ArgumentsUsage
group
-
>
hasAllFlagsDontCheckGeneration
(
OBJECT_FLAG_COPY_ON_WRITE
)
)
;
MConstant
*
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
current
-
>
add
(
templateConst
)
;
MNewArrayCopyOnWrite
*
ins
=
MNewArrayCopyOnWrite
:
:
New
(
alloc
(
)
constraints
(
)
templateConst
group
-
>
initialHeap
(
constraints
(
)
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
newObjectTryTemplateObject
(
bool
*
emitted
JSObject
*
templateObject
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
templateObject
)
{
return
Ok
(
)
;
}
MNewObject
:
:
Mode
mode
;
if
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewObject
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewObjectWithGroup
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewInit
)
{
mode
=
MNewObject
:
:
ObjectLiteral
;
}
else
{
mode
=
MNewObject
:
:
ObjectCreate
;
}
gc
:
:
InitialHeap
heap
=
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
;
MConstant
*
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
current
-
>
add
(
templateConst
)
;
MNewObject
*
ins
=
MNewObject
:
:
New
(
alloc
(
)
constraints
(
)
templateConst
heap
mode
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
newObjectTryVM
(
bool
*
emitted
JSObject
*
templateObject
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewObject
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewObjectWithGroup
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
NewInit
)
;
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
;
MConstant
*
templateConst
=
MConstant
:
:
New
(
alloc
(
)
NullValue
(
)
)
;
if
(
templateObject
)
{
heap
=
templateObject
-
>
group
(
)
-
>
initialHeap
(
constraints
(
)
)
;
templateConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
templateObject
)
;
}
current
-
>
add
(
templateConst
)
;
MNewObject
*
ins
=
MNewObject
:
:
NewVM
(
alloc
(
)
constraints
(
)
templateConst
heap
MNewObject
:
:
ObjectLiteral
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_newobject
(
)
{
bool
emitted
=
false
;
JSObject
*
templateObject
=
inspector
-
>
getTemplateObject
(
pc
)
;
MOZ_TRY
(
newObjectTryTemplateObject
(
&
emitted
templateObject
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
newObjectTryVM
(
&
emitted
templateObject
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_CRASH
(
"
newobject
should
have
been
emited
"
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initelem
(
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElem
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitHiddenElem
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitLockedElem
)
;
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
&
&
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElem
)
{
MOZ_TRY
(
initOrSetElemTryDense
(
&
emitted
obj
id
value
true
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MOZ_TRY
(
initOrSetElemTryCache
(
&
emitted
obj
id
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MInitElem
*
initElem
=
MInitElem
:
:
New
(
alloc
(
)
obj
id
value
)
;
current
-
>
add
(
initElem
)
;
return
resumeAfter
(
initElem
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initelem_inc
(
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
MAdd
*
nextId
=
MAdd
:
:
New
(
alloc
(
)
id
constantInt
(
1
)
MDefinition
:
:
Truncate
)
;
current
-
>
add
(
nextId
)
;
current
-
>
push
(
nextId
)
;
return
initArrayElement
(
obj
id
value
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initArrayElement
(
MDefinition
*
obj
MDefinition
*
id
MDefinition
*
value
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElemArray
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElemInc
)
;
bool
emitted
=
false
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
initArrayElemTryFastPath
(
&
emitted
obj
id
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
initOrSetElemTryDense
(
&
emitted
obj
id
value
true
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MOZ_TRY
(
initOrSetElemTryCache
(
&
emitted
obj
id
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MCallInitElementArray
*
initElem
=
MCallInitElementArray
:
:
New
(
alloc
(
)
obj
id
value
)
;
current
-
>
add
(
initElem
)
;
return
resumeAfter
(
initElem
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initArrayElemTryFastPath
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
id
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElemArray
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
InitElemInc
)
;
if
(
!
obj
-
>
isNewArray
(
)
)
{
return
Ok
(
)
;
}
if
(
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
return
Ok
(
)
;
}
if
(
!
obj
-
>
resultTypeSet
(
)
|
|
obj
-
>
resultTypeSet
(
)
-
>
unknownObject
(
)
|
|
obj
-
>
resultTypeSet
(
)
-
>
getObjectCount
(
)
!
=
1
)
{
return
Ok
(
)
;
}
TypeSet
:
:
ObjectKey
*
initializer
=
obj
-
>
resultTypeSet
(
)
-
>
getObject
(
0
)
;
if
(
value
-
>
type
(
)
=
=
MIRType
:
:
MagicHole
)
{
if
(
!
initializer
-
>
hasFlags
(
constraints
(
)
OBJECT_FLAG_NON_PACKED
)
)
{
return
Ok
(
)
;
}
}
else
if
(
!
initializer
-
>
unknownProperties
(
)
)
{
HeapTypeSetKey
elemTypes
=
initializer
-
>
property
(
JSID_VOID
)
;
if
(
!
TypeSetIncludes
(
elemTypes
.
maybeTypes
(
)
value
-
>
type
(
)
value
-
>
resultTypeSet
(
)
)
)
{
elemTypes
.
freeze
(
constraints
(
)
)
;
return
Ok
(
)
;
}
}
MOZ_TRY
(
initArrayElementFastPath
(
obj
-
>
toNewArray
(
)
id
value
true
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initelem_array
(
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
uint32_t
index
=
GET_UINT32
(
pc
)
;
MOZ_ASSERT
(
index
<
=
INT32_MAX
"
the
bytecode
emitter
must
fail
to
compile
code
that
would
"
"
produce
JSOp
:
:
InitElemArray
with
an
index
exceeding
"
"
int32_t
range
"
)
;
MConstant
*
id
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
index
)
)
;
current
-
>
add
(
id
)
;
return
initArrayElement
(
obj
id
value
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initArrayElementFastPath
(
MNewArray
*
obj
MDefinition
*
id
MDefinition
*
value
bool
addResumePointAndIncrementInitializedLength
)
{
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
if
(
obj
-
>
convertDoubleElements
(
)
)
{
MInstruction
*
valueDouble
=
MToDouble
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
valueDouble
)
;
value
=
valueDouble
;
}
if
(
value
-
>
type
(
)
=
=
MIRType
:
:
MagicHole
)
{
value
-
>
setImplicitlyUsedUnchecked
(
)
;
auto
*
store
=
MStoreHoleValueElement
:
:
New
(
alloc
(
)
elements
id
)
;
current
-
>
add
(
store
)
;
}
else
{
auto
*
store
=
MStoreElement
:
:
New
(
alloc
(
)
elements
id
value
false
)
;
current
-
>
add
(
store
)
;
}
if
(
addResumePointAndIncrementInitializedLength
)
{
MSetInitializedLength
*
initLength
=
MSetInitializedLength
:
:
New
(
alloc
(
)
elements
id
)
;
current
-
>
add
(
initLength
)
;
MOZ_TRY
(
resumeAfter
(
initLength
)
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_mutateproto
(
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
MMutateProto
*
mutate
=
MMutateProto
:
:
New
(
alloc
(
)
obj
value
)
;
current
-
>
add
(
mutate
)
;
return
resumeAfter
(
mutate
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initprop
(
PropertyName
*
name
)
{
bool
useFastPath
=
false
;
MDefinition
*
obj
=
current
-
>
peek
(
-
2
)
;
if
(
obj
-
>
isNewObject
(
)
)
{
if
(
JSObject
*
templateObject
=
obj
-
>
toNewObject
(
)
-
>
templateObject
(
)
)
{
if
(
templateObject
-
>
is
<
PlainObject
>
(
)
)
{
if
(
templateObject
-
>
as
<
PlainObject
>
(
)
.
containsPure
(
name
)
)
{
useFastPath
=
true
;
}
}
}
}
MInstructionReverseIterator
last
=
current
-
>
rbegin
(
)
;
if
(
useFastPath
&
&
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
jsop_setprop
(
name
)
)
;
}
else
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
barrier
=
PropertyWriteNeedsTypeBarrier
(
alloc
(
)
constraints
(
)
current
&
obj
name
&
value
true
)
;
bool
emitted
=
false
;
MOZ_TRY
(
setPropTryCache
(
&
emitted
obj
name
value
barrier
)
)
;
MOZ_ASSERT
(
emitted
=
=
true
)
;
}
current
-
>
pop
(
)
;
current
-
>
push
(
obj
)
;
for
(
MInstructionReverseIterator
riter
=
current
-
>
rbegin
(
)
;
riter
!
=
last
;
riter
+
+
)
{
if
(
MResumePoint
*
resumePoint
=
riter
-
>
resumePoint
(
)
)
{
MOZ_ASSERT
(
resumePoint
-
>
pc
(
)
=
=
pc
)
;
if
(
resumePoint
-
>
mode
(
)
=
=
MResumePoint
:
:
ResumeAfter
)
{
size_t
index
=
resumePoint
-
>
numOperands
(
)
-
1
;
resumePoint
-
>
replaceOperand
(
index
obj
)
;
}
break
;
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initprop_getter_setter
(
PropertyName
*
name
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
MInitPropGetterSetter
*
init
=
MInitPropGetterSetter
:
:
New
(
alloc
(
)
obj
name
value
)
;
current
-
>
add
(
init
)
;
return
resumeAfter
(
init
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_initelem_getter_setter
(
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
MInitElemGetterSetter
*
init
=
MInitElemGetterSetter
:
:
New
(
alloc
(
)
obj
id
value
)
;
current
-
>
add
(
init
)
;
return
resumeAfter
(
init
)
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newBlock
(
size_t
stackDepth
jsbytecode
*
pc
MBasicBlock
*
maybePredecessor
)
{
MOZ_ASSERT_IF
(
maybePredecessor
maybePredecessor
-
>
stackDepth
(
)
=
=
stackDepth
)
;
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
(
)
stackDepth
info
(
)
maybePredecessor
bytecodeSite
(
pc
)
MBasicBlock
:
:
NORMAL
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
block
-
>
setLoopDepth
(
loopDepth_
)
;
return
block
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newBlock
(
MBasicBlock
*
predecessor
jsbytecode
*
pc
MResumePoint
*
priorResumePoint
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
NewWithResumePoint
(
graph
(
)
info
(
)
predecessor
bytecodeSite
(
pc
)
priorResumePoint
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
block
-
>
setLoopDepth
(
loopDepth_
)
;
return
block
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newBlockPopN
(
MBasicBlock
*
predecessor
jsbytecode
*
pc
uint32_t
popped
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
NewPopN
(
graph
(
)
info
(
)
predecessor
bytecodeSite
(
pc
)
MBasicBlock
:
:
NORMAL
popped
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
block
-
>
setLoopDepth
(
loopDepth_
)
;
return
block
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newBlockAfter
(
MBasicBlock
*
at
size_t
stackDepth
jsbytecode
*
pc
MBasicBlock
*
maybePredecessor
)
{
MOZ_ASSERT_IF
(
maybePredecessor
maybePredecessor
-
>
stackDepth
(
)
=
=
stackDepth
)
;
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
(
)
stackDepth
info
(
)
maybePredecessor
bytecodeSite
(
pc
)
MBasicBlock
:
:
NORMAL
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
block
-
>
setLoopDepth
(
loopDepth_
)
;
block
-
>
setHitCount
(
0
)
;
graph
(
)
.
insertBlockAfter
(
at
block
)
;
return
block
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newOsrPreheader
(
MBasicBlock
*
predecessor
jsbytecode
*
loopHead
)
{
MOZ_ASSERT
(
JSOp
(
*
loopHead
)
=
=
JSOp
:
:
LoopHead
)
;
MOZ_ASSERT
(
loopHead
=
=
info
(
)
.
osrPc
(
)
)
;
MBasicBlock
*
osrBlock
;
MOZ_TRY_VAR
(
osrBlock
newBlockAfter
(
*
graph
(
)
.
begin
(
)
predecessor
-
>
stackDepth
(
)
loopHead
)
)
;
MBasicBlock
*
preheader
;
MOZ_TRY_VAR
(
preheader
newBlock
(
predecessor
loopHead
)
)
;
graph
(
)
.
addBlock
(
preheader
)
;
if
(
predecessor
-
>
getHitState
(
)
=
=
MBasicBlock
:
:
HitState
:
:
Count
)
{
preheader
-
>
setHitCount
(
predecessor
-
>
getHitCount
(
)
)
;
}
MOsrEntry
*
entry
=
MOsrEntry
:
:
New
(
alloc
(
)
)
;
osrBlock
-
>
add
(
entry
)
;
{
uint32_t
slot
=
info
(
)
.
environmentChainSlot
(
)
;
MInstruction
*
envv
;
if
(
usesEnvironmentChain
(
)
)
{
envv
=
MOsrEnvironmentChain
:
:
New
(
alloc
(
)
entry
)
;
}
else
{
envv
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
}
osrBlock
-
>
add
(
envv
)
;
osrBlock
-
>
initSlot
(
slot
envv
)
;
}
{
MInstruction
*
returnValue
;
if
(
!
script
(
)
-
>
noScriptRval
(
)
)
{
returnValue
=
MOsrReturnValue
:
:
New
(
alloc
(
)
entry
)
;
}
else
{
returnValue
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
}
osrBlock
-
>
add
(
returnValue
)
;
osrBlock
-
>
initSlot
(
info
(
)
.
returnValueSlot
(
)
returnValue
)
;
}
bool
needsArgsObj
=
info
(
)
.
needsArgsObj
(
)
;
MInstruction
*
argsObj
=
nullptr
;
if
(
info
(
)
.
hasArguments
(
)
)
{
if
(
needsArgsObj
)
{
argsObj
=
MOsrArgumentsObject
:
:
New
(
alloc
(
)
entry
)
;
}
else
{
argsObj
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
}
osrBlock
-
>
add
(
argsObj
)
;
osrBlock
-
>
initSlot
(
info
(
)
.
argsObjSlot
(
)
argsObj
)
;
}
if
(
info
(
)
.
funMaybeLazy
(
)
)
{
MParameter
*
thisv
=
MParameter
:
:
New
(
alloc
(
)
MParameter
:
:
THIS_SLOT
nullptr
)
;
osrBlock
-
>
add
(
thisv
)
;
osrBlock
-
>
initSlot
(
info
(
)
.
thisSlot
(
)
thisv
)
;
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nargs
(
)
;
i
+
+
)
{
uint32_t
slot
=
needsArgsObj
?
info
(
)
.
argSlotUnchecked
(
i
)
:
info
(
)
.
argSlot
(
i
)
;
if
(
needsArgsObj
&
&
info
(
)
.
argsObjAliasesFormals
(
)
)
{
MOZ_ASSERT
(
argsObj
&
&
argsObj
-
>
isOsrArgumentsObject
(
)
)
;
MInstruction
*
osrv
;
if
(
script
(
)
-
>
formalIsAliased
(
i
)
)
{
osrv
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
}
else
{
osrv
=
MGetArgumentsObjectArg
:
:
New
(
alloc
(
)
argsObj
i
)
;
}
osrBlock
-
>
add
(
osrv
)
;
osrBlock
-
>
initSlot
(
slot
osrv
)
;
}
else
{
MParameter
*
arg
=
MParameter
:
:
New
(
alloc
(
)
i
nullptr
)
;
osrBlock
-
>
add
(
arg
)
;
osrBlock
-
>
initSlot
(
slot
arg
)
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nlocals
(
)
;
i
+
+
)
{
uint32_t
slot
=
info
(
)
.
localSlot
(
i
)
;
ptrdiff_t
offset
=
BaselineFrame
:
:
reverseOffsetOfLocal
(
i
)
;
MOsrValue
*
osrv
=
MOsrValue
:
:
New
(
alloc
(
)
.
fallible
(
)
entry
offset
)
;
if
(
!
osrv
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
osrBlock
-
>
add
(
osrv
)
;
osrBlock
-
>
initSlot
(
slot
osrv
)
;
}
uint32_t
numStackSlots
=
preheader
-
>
stackDepth
(
)
-
info
(
)
.
firstStackSlot
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numStackSlots
;
i
+
+
)
{
uint32_t
slot
=
info
(
)
.
stackSlot
(
i
)
;
ptrdiff_t
offset
=
BaselineFrame
:
:
reverseOffsetOfLocal
(
info
(
)
.
nlocals
(
)
+
i
)
;
MOsrValue
*
osrv
=
MOsrValue
:
:
New
(
alloc
(
)
.
fallible
(
)
entry
offset
)
;
if
(
!
osrv
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
osrBlock
-
>
add
(
osrv
)
;
osrBlock
-
>
initSlot
(
slot
osrv
)
;
}
MStart
*
start
=
MStart
:
:
New
(
alloc
(
)
)
;
osrBlock
-
>
add
(
start
)
;
MOZ_TRY
(
resumeAt
(
start
loopHead
)
)
;
if
(
!
osrBlock
-
>
linkOsrValues
(
start
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_ASSERT
(
predecessor
-
>
stackDepth
(
)
=
=
osrBlock
-
>
stackDepth
(
)
)
;
MOZ_ASSERT
(
info
(
)
.
environmentChainSlot
(
)
=
=
0
)
;
for
(
uint32_t
i
=
info
(
)
.
startArgSlot
(
)
;
i
<
osrBlock
-
>
stackDepth
(
)
;
i
+
+
)
{
MDefinition
*
existing
=
current
-
>
getSlot
(
i
)
;
MDefinition
*
def
=
osrBlock
-
>
getSlot
(
i
)
;
MOZ_ASSERT_IF
(
!
needsArgsObj
|
|
!
info
(
)
.
isSlotAliased
(
i
)
def
-
>
type
(
)
=
=
MIRType
:
:
Value
)
;
if
(
info
(
)
.
isSlotAliased
(
i
)
)
{
continue
;
}
def
-
>
setResultType
(
existing
-
>
type
(
)
)
;
def
-
>
setResultTypeSet
(
existing
-
>
resultTypeSet
(
)
)
;
}
osrBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
preheader
)
)
;
if
(
!
preheader
-
>
addPredecessor
(
alloc
(
)
osrBlock
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
graph
(
)
.
setOsrBlock
(
osrBlock
)
;
return
preheader
;
}
AbortReasonOr
<
MBasicBlock
*
>
IonBuilder
:
:
newPendingLoopHeader
(
MBasicBlock
*
predecessor
jsbytecode
*
pc
bool
osr
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
NewPendingLoopHeader
(
graph
(
)
info
(
)
predecessor
bytecodeSite
(
pc
)
)
;
if
(
!
block
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
osr
)
{
MOZ_ASSERT
(
info
(
)
.
firstLocalSlot
(
)
-
info
(
)
.
firstArgSlot
(
)
=
=
baselineFrame_
-
>
argTypes
.
length
(
)
)
;
MOZ_ASSERT
(
block
-
>
stackDepth
(
)
-
info
(
)
.
firstLocalSlot
(
)
=
=
baselineFrame_
-
>
varTypes
.
length
(
)
)
;
for
(
uint32_t
i
=
info
(
)
.
startArgSlot
(
)
;
i
<
block
-
>
stackDepth
(
)
;
i
+
+
)
{
if
(
info
(
)
.
isSlotAliased
(
i
)
)
{
continue
;
}
MPhi
*
phi
=
block
-
>
getSlot
(
i
)
-
>
toPhi
(
)
;
TypeSet
:
:
Type
existingType
=
TypeSet
:
:
UndefinedType
(
)
;
uint32_t
arg
=
i
-
info
(
)
.
firstArgSlot
(
)
;
uint32_t
var
=
i
-
info
(
)
.
firstLocalSlot
(
)
;
if
(
info
(
)
.
funMaybeLazy
(
)
&
&
i
=
=
info
(
)
.
thisSlot
(
)
)
{
existingType
=
baselineFrame_
-
>
thisType
;
}
else
if
(
arg
<
info
(
)
.
nargs
(
)
)
{
existingType
=
baselineFrame_
-
>
argTypes
[
arg
]
;
}
else
{
existingType
=
baselineFrame_
-
>
varTypes
[
var
]
;
}
if
(
existingType
.
isSingletonUnchecked
(
)
)
{
checkNurseryObject
(
existingType
.
singleton
(
)
)
;
}
LifoAlloc
*
lifoAlloc
=
alloc
(
)
.
lifoAlloc
(
)
;
LifoAlloc
:
:
AutoFallibleScope
fallibleAllocator
(
lifoAlloc
)
;
TemporaryTypeSet
*
typeSet
=
lifoAlloc
-
>
new_
<
TemporaryTypeSet
>
(
lifoAlloc
existingType
)
;
if
(
!
typeSet
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MIRType
type
=
typeSet
-
>
getKnownMIRType
(
)
;
if
(
!
phi
-
>
addBackedgeType
(
alloc
(
)
type
typeSet
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
}
MOZ_ASSERT
(
block
-
>
stackDepth
(
)
>
=
info
(
)
.
firstStackSlot
(
)
)
;
bool
emptyStack
=
block
-
>
stackDepth
(
)
=
=
info
(
)
.
firstStackSlot
(
)
;
if
(
!
emptyStack
)
{
for
(
TryNoteIterAllNoGC
tni
(
script
(
)
pc
)
;
!
tni
.
done
(
)
;
+
+
tni
)
{
const
TryNote
&
tn
=
*
*
tni
;
if
(
tn
.
isLoop
(
)
)
{
BytecodeLocation
tnStart
=
script
(
)
-
>
offsetToLocation
(
tn
.
start
)
;
if
(
tnStart
.
toRawBytecode
(
)
!
=
pc
)
{
MOZ_ASSERT
(
tnStart
.
is
(
JSOp
:
:
LoopHead
)
)
;
MOZ_ASSERT
(
tnStart
.
toRawBytecode
(
)
<
pc
)
;
break
;
}
}
switch
(
tn
.
kind
(
)
)
{
case
TryNoteKind
:
:
Destructuring
:
case
TryNoteKind
:
:
ForIn
:
{
MOZ_ASSERT
(
tn
.
stackDepth
>
=
1
)
;
uint32_t
slot
=
info
(
)
.
stackSlot
(
tn
.
stackDepth
-
1
)
;
MPhi
*
phi
=
block
-
>
getSlot
(
slot
)
-
>
toPhi
(
)
;
if
(
!
outermostBuilder
(
)
-
>
iterators_
.
append
(
phi
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
break
;
}
default
:
break
;
}
}
}
return
block
;
}
MTest
*
IonBuilder
:
:
newTest
(
MDefinition
*
ins
MBasicBlock
*
ifTrue
MBasicBlock
*
ifFalse
)
{
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
ins
ifTrue
ifFalse
)
;
test
-
>
cacheOperandMightEmulateUndefined
(
constraints
(
)
)
;
return
test
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
resume
(
MInstruction
*
ins
jsbytecode
*
pc
MResumePoint
:
:
Mode
mode
)
{
MOZ_ASSERT
(
ins
-
>
isEffectful
(
)
|
|
!
ins
-
>
isMovable
(
)
)
;
MResumePoint
*
resumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
ins
-
>
block
(
)
pc
mode
)
;
if
(
!
resumePoint
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
ins
-
>
setResumePoint
(
resumePoint
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
resumeAt
(
MInstruction
*
ins
jsbytecode
*
pc
)
{
return
resume
(
ins
pc
MResumePoint
:
:
ResumeAt
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
resumeAfter
(
MInstruction
*
ins
)
{
return
resume
(
ins
pc
MResumePoint
:
:
ResumeAfter
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
maybeInsertResume
(
)
{
if
(
loopDepth_
=
=
0
)
{
return
Ok
(
)
;
}
MNop
*
ins
=
MNop
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
void
IonBuilder
:
:
maybeMarkEmpty
(
MDefinition
*
ins
)
{
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Value
)
;
for
(
size_t
i
=
0
;
i
<
ins
-
>
numOperands
(
)
;
i
+
+
)
{
if
(
!
ins
-
>
getOperand
(
i
)
-
>
emptyResultTypeSet
(
)
)
{
continue
;
}
TemporaryTypeSet
*
types
=
alloc
(
)
.
lifoAlloc
(
)
-
>
new_
<
TemporaryTypeSet
>
(
)
;
if
(
types
)
{
ins
-
>
setResultTypeSet
(
types
)
;
return
;
}
}
}
static
bool
ClassHasEffectlessLookup
(
const
JSClass
*
clasp
)
{
return
IsTypedObjectClass
(
clasp
)
|
|
(
clasp
-
>
isNative
(
)
&
&
!
clasp
-
>
getOpsLookupProperty
(
)
)
;
}
static
bool
ObjectHasExtraOwnProperty
(
CompileRealm
*
realm
TypeSet
:
:
ObjectKey
*
object
jsid
id
)
{
if
(
object
-
>
isGroup
(
)
&
&
object
-
>
group
(
)
-
>
maybeTypeDescr
(
)
)
{
return
object
-
>
group
(
)
-
>
typeDescr
(
)
.
hasProperty
(
realm
-
>
runtime
(
)
-
>
names
(
)
id
)
;
}
const
JSClass
*
clasp
=
object
-
>
clasp
(
)
;
if
(
clasp
=
=
&
ArrayObject
:
:
class_
)
{
return
JSID_IS_ATOM
(
id
realm
-
>
runtime
(
)
-
>
names
(
)
.
length
)
;
}
JSObject
*
singleton
=
object
-
>
isSingleton
(
)
?
object
-
>
singleton
(
)
:
nullptr
;
return
ClassMayResolveId
(
realm
-
>
runtime
(
)
-
>
names
(
)
clasp
id
singleton
)
;
}
void
IonBuilder
:
:
insertRecompileCheck
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
pc
=
=
script
(
)
-
>
code
(
)
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
OptimizationLevel
curLevel
=
optimizationLevel
(
)
;
if
(
IonOptimizations
.
isLastLevel
(
curLevel
)
|
|
info
(
)
.
isAnalysis
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
JitOptions
.
disableOptimizationLevels
)
;
MRecompileCheck
:
:
RecompileCheckType
type
;
if
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
{
type
=
MRecompileCheck
:
:
RecompileCheckType
:
:
OptimizationLevelOSR
;
}
else
if
(
this
!
=
outermostBuilder
(
)
)
{
type
=
MRecompileCheck
:
:
RecompileCheckType
:
:
OptimizationLevelInlined
;
}
else
{
type
=
MRecompileCheck
:
:
RecompileCheckType
:
:
OptimizationLevel
;
}
OptimizationLevel
nextLevel
=
IonOptimizations
.
nextLevel
(
curLevel
)
;
const
OptimizationInfo
*
info
=
IonOptimizations
.
get
(
nextLevel
)
;
uint32_t
warmUpThreshold
=
info
-
>
recompileWarmUpThreshold
(
script
(
)
pc
)
;
MRecompileCheck
*
check
=
MRecompileCheck
:
:
New
(
alloc
(
)
script
(
)
warmUpThreshold
type
)
;
current
-
>
add
(
check
)
;
}
JSObject
*
IonBuilder
:
:
testSingletonProperty
(
JSObject
*
obj
jsid
id
)
{
while
(
obj
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
nullptr
;
}
if
(
!
ClassHasEffectlessLookup
(
obj
-
>
getClass
(
)
)
)
{
return
nullptr
;
}
TypeSet
:
:
ObjectKey
*
objKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
obj
)
;
if
(
analysisContext
)
{
objKey
-
>
ensureTrackedProperty
(
analysisContext
id
)
;
}
if
(
objKey
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
HeapTypeSetKey
property
=
objKey
-
>
property
(
id
)
;
if
(
property
.
isOwnProperty
(
constraints
(
)
)
)
{
if
(
obj
-
>
isSingleton
(
)
)
{
return
property
.
singleton
(
constraints
(
)
)
;
}
return
nullptr
;
}
if
(
ObjectHasExtraOwnProperty
(
realm
objKey
id
)
)
{
return
nullptr
;
}
obj
=
checkNurseryObject
(
obj
-
>
staticPrototype
(
)
)
;
}
return
nullptr
;
}
JSObject
*
IonBuilder
:
:
testSingletonPropertyTypes
(
MDefinition
*
obj
jsid
id
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
types
&
&
types
-
>
unknownObject
(
)
)
{
return
nullptr
;
}
JSObject
*
objectSingleton
=
types
?
types
-
>
maybeSingleton
(
)
:
nullptr
;
if
(
objectSingleton
)
{
return
testSingletonProperty
(
objectSingleton
id
)
;
}
MIRType
objType
=
obj
-
>
type
(
)
;
if
(
objType
=
=
MIRType
:
:
Value
&
&
types
)
{
objType
=
types
-
>
getKnownMIRType
(
)
;
}
JSProtoKey
key
;
switch
(
objType
)
{
case
MIRType
:
:
String
:
key
=
JSProto_String
;
break
;
case
MIRType
:
:
Symbol
:
key
=
JSProto_Symbol
;
break
;
case
MIRType
:
:
BigInt
:
key
=
JSProto_BigInt
;
break
;
case
MIRType
:
:
Int32
:
case
MIRType
:
:
Double
:
key
=
JSProto_Number
;
break
;
case
MIRType
:
:
Boolean
:
key
=
JSProto_Boolean
;
break
;
case
MIRType
:
:
Object
:
{
if
(
!
types
)
{
return
nullptr
;
}
JSObject
*
singleton
=
nullptr
;
for
(
unsigned
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
nullptr
;
}
if
(
analysisContext
)
{
key
-
>
ensureTrackedProperty
(
analysisContext
id
)
;
}
const
JSClass
*
clasp
=
key
-
>
clasp
(
)
;
if
(
!
ClassHasEffectlessLookup
(
clasp
)
|
|
ObjectHasExtraOwnProperty
(
realm
key
id
)
)
{
return
nullptr
;
}
if
(
key
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
property
.
isOwnProperty
(
constraints
(
)
)
)
{
return
nullptr
;
}
if
(
JSObject
*
proto
=
checkNurseryObject
(
key
-
>
proto
(
)
.
toObjectOrNull
(
)
)
)
{
JSObject
*
thisSingleton
=
testSingletonProperty
(
proto
id
)
;
if
(
!
thisSingleton
)
{
return
nullptr
;
}
if
(
singleton
)
{
if
(
thisSingleton
!
=
singleton
)
{
return
nullptr
;
}
}
else
{
singleton
=
thisSingleton
;
}
}
else
{
return
nullptr
;
}
}
return
singleton
;
}
default
:
return
nullptr
;
}
if
(
JSObject
*
proto
=
script
(
)
-
>
global
(
)
.
maybeGetPrototype
(
key
)
)
{
return
testSingletonProperty
(
proto
id
)
;
}
return
nullptr
;
}
AbortReasonOr
<
bool
>
IonBuilder
:
:
testNotDefinedProperty
(
MDefinition
*
obj
jsid
id
bool
ownProperty
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
|
|
types
-
>
getKnownMIRType
(
)
!
=
MIRType
:
:
Object
)
{
return
false
;
}
for
(
unsigned
i
=
0
count
=
types
-
>
getObjectCount
(
)
;
i
<
count
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
while
(
true
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
key
-
>
hasStableClassAndProto
(
constraints
(
)
)
|
|
key
-
>
unknownProperties
(
)
)
{
return
false
;
}
const
JSClass
*
clasp
=
key
-
>
clasp
(
)
;
if
(
!
ClassHasEffectlessLookup
(
clasp
)
|
|
ObjectHasExtraOwnProperty
(
realm
key
id
)
)
{
return
false
;
}
if
(
key
-
>
isSingleton
(
)
&
&
key
-
>
singleton
(
)
-
>
is
<
NativeObject
>
(
)
&
&
key
-
>
singleton
(
)
-
>
as
<
NativeObject
>
(
)
.
lookupPure
(
id
)
)
{
return
false
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
property
.
isOwnProperty
(
constraints
(
)
)
)
{
return
false
;
}
if
(
ownProperty
)
{
break
;
}
JSObject
*
proto
=
checkNurseryObject
(
key
-
>
proto
(
)
.
toObjectOrNull
(
)
)
;
if
(
!
proto
)
{
break
;
}
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
proto
)
;
}
}
return
true
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
pushTypeBarrier
(
MDefinition
*
def
TemporaryTypeSet
*
observed
BarrierKind
kind
)
{
MOZ_ASSERT
(
def
=
=
current
-
>
peek
(
-
1
)
)
;
MDefinition
*
replace
=
addTypeBarrier
(
current
-
>
pop
(
)
observed
kind
)
;
if
(
!
replace
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
push
(
replace
)
;
return
Ok
(
)
;
}
MDefinition
*
IonBuilder
:
:
addTypeBarrier
(
MDefinition
*
def
TemporaryTypeSet
*
observed
BarrierKind
kind
MTypeBarrier
*
*
pbarrier
)
{
if
(
BytecodeIsPopped
(
pc
)
)
{
return
def
;
}
if
(
kind
=
=
BarrierKind
:
:
NoBarrier
)
{
MDefinition
*
replace
=
ensureDefiniteType
(
def
observed
-
>
getKnownMIRType
(
)
)
;
replace
-
>
setResultTypeSet
(
observed
)
;
return
replace
;
}
if
(
observed
-
>
unknown
(
)
)
{
return
def
;
}
MTypeBarrier
*
barrier
=
MTypeBarrier
:
:
New
(
alloc
(
)
def
observed
kind
)
;
current
-
>
add
(
barrier
)
;
if
(
pbarrier
)
{
*
pbarrier
=
barrier
;
}
if
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Undefined
)
{
return
constant
(
UndefinedValue
(
)
)
;
}
if
(
barrier
-
>
type
(
)
=
=
MIRType
:
:
Null
)
{
return
constant
(
NullValue
(
)
)
;
}
return
barrier
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
pushDOMTypeBarrier
(
MInstruction
*
ins
TemporaryTypeSet
*
observed
JSFunction
*
func
)
{
MOZ_ASSERT
(
func
&
&
func
-
>
isNative
(
)
&
&
func
-
>
hasJitInfo
(
)
)
;
const
JSJitInfo
*
jitinfo
=
func
-
>
jitInfo
(
)
;
bool
barrier
=
DOMCallNeedsBarrier
(
jitinfo
observed
)
;
MDefinition
*
replace
=
ins
;
if
(
jitinfo
-
>
returnType
(
)
!
=
JSVAL_TYPE_DOUBLE
|
|
observed
-
>
getKnownMIRType
(
)
!
=
MIRType
:
:
Int32
)
{
replace
=
ensureDefiniteType
(
ins
MIRTypeFromValueType
(
jitinfo
-
>
returnType
(
)
)
)
;
if
(
replace
!
=
ins
)
{
current
-
>
pop
(
)
;
current
-
>
push
(
replace
)
;
}
}
else
{
MOZ_ASSERT
(
barrier
)
;
}
return
pushTypeBarrier
(
replace
observed
barrier
?
BarrierKind
:
:
TypeSet
:
BarrierKind
:
:
NoBarrier
)
;
}
MDefinition
*
IonBuilder
:
:
ensureDefiniteType
(
MDefinition
*
def
MIRType
definiteType
)
{
MInstruction
*
replace
;
switch
(
definiteType
)
{
case
MIRType
:
:
Undefined
:
def
-
>
setImplicitlyUsedUnchecked
(
)
;
replace
=
MConstant
:
:
New
(
alloc
(
)
UndefinedValue
(
)
)
;
break
;
case
MIRType
:
:
Null
:
def
-
>
setImplicitlyUsedUnchecked
(
)
;
replace
=
MConstant
:
:
New
(
alloc
(
)
NullValue
(
)
)
;
break
;
case
MIRType
:
:
Value
:
return
def
;
default
:
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
definiteType
=
=
MIRType
:
:
Double
)
{
replace
=
MToDouble
:
:
New
(
alloc
(
)
def
)
;
break
;
}
return
def
;
}
replace
=
MUnbox
:
:
New
(
alloc
(
)
def
definiteType
MUnbox
:
:
Infallible
)
;
break
;
}
}
current
-
>
add
(
replace
)
;
return
replace
;
}
static
size_t
NumFixedSlots
(
JSObject
*
object
)
{
gc
:
:
AllocKind
kind
=
object
-
>
asTenured
(
)
.
getAllocKind
(
)
;
return
gc
:
:
GetGCKindSlots
(
kind
object
-
>
getClass
(
)
)
;
}
static
bool
IsUninitializedGlobalLexicalSlot
(
JSObject
*
obj
PropertyName
*
name
)
{
LexicalEnvironmentObject
&
globalLexical
=
obj
-
>
as
<
LexicalEnvironmentObject
>
(
)
;
MOZ_ASSERT
(
globalLexical
.
isGlobal
(
)
)
;
Shape
*
shape
=
globalLexical
.
lookupPure
(
name
)
;
if
(
!
shape
)
{
return
false
;
}
return
globalLexical
.
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getStaticName
(
bool
*
emitted
JSObject
*
staticObject
PropertyName
*
name
MDefinition
*
lexicalCheck
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
jsid
id
=
NameToId
(
name
)
;
bool
isGlobalLexical
=
staticObject
-
>
is
<
LexicalEnvironmentObject
>
(
)
&
&
staticObject
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
isGlobal
(
)
;
MOZ_ASSERT
(
isGlobalLexical
|
|
staticObject
-
>
is
<
GlobalObject
>
(
)
)
;
MOZ_ASSERT
(
staticObject
-
>
isSingleton
(
)
)
;
if
(
lexicalCheck
)
{
return
Ok
(
)
;
}
TypeSet
:
:
ObjectKey
*
staticKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
staticObject
)
;
if
(
analysisContext
)
{
staticKey
-
>
ensureTrackedProperty
(
analysisContext
NameToId
(
name
)
)
;
}
if
(
staticKey
-
>
unknownProperties
(
)
)
{
return
Ok
(
)
;
}
HeapTypeSetKey
property
=
staticKey
-
>
property
(
id
)
;
if
(
!
property
.
maybeTypes
(
)
|
|
!
property
.
maybeTypes
(
)
-
>
definiteProperty
(
)
|
|
property
.
nonData
(
constraints
(
)
)
)
{
return
Ok
(
)
;
}
if
(
isGlobalLexical
&
&
IsUninitializedGlobalLexicalSlot
(
staticObject
name
)
)
{
return
Ok
(
)
;
}
*
emitted
=
true
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
BarrierKind
barrier
=
PropertyReadNeedsTypeBarrier
(
analysisContext
alloc
(
)
constraints
(
)
staticKey
name
types
true
)
;
if
(
barrier
=
=
BarrierKind
:
:
NoBarrier
)
{
JSObject
*
singleton
=
types
-
>
maybeSingleton
(
)
;
if
(
singleton
)
{
if
(
testSingletonProperty
(
staticObject
id
)
=
=
singleton
)
{
pushConstant
(
ObjectValue
(
*
singleton
)
)
;
return
Ok
(
)
;
}
}
Value
constantValue
;
if
(
property
.
constant
(
constraints
(
)
&
constantValue
)
)
{
pushConstant
(
constantValue
)
;
return
Ok
(
)
;
}
}
MOZ_TRY
(
loadStaticSlot
(
staticObject
barrier
types
property
.
maybeTypes
(
)
-
>
definiteSlot
(
)
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
loadStaticSlot
(
JSObject
*
staticObject
BarrierKind
barrier
TemporaryTypeSet
*
types
uint32_t
slot
)
{
if
(
barrier
=
=
BarrierKind
:
:
NoBarrier
)
{
MIRType
knownType
=
types
-
>
getKnownMIRType
(
)
;
if
(
knownType
=
=
MIRType
:
:
Undefined
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
}
if
(
knownType
=
=
MIRType
:
:
Null
)
{
pushConstant
(
NullValue
(
)
)
;
return
Ok
(
)
;
}
}
MInstruction
*
obj
=
constant
(
ObjectValue
(
*
staticObject
)
)
;
MIRType
rvalType
=
types
-
>
getKnownMIRType
(
)
;
if
(
barrier
!
=
BarrierKind
:
:
NoBarrier
)
{
rvalType
=
MIRType
:
:
Value
;
}
return
loadSlot
(
obj
slot
NumFixedSlots
(
staticObject
)
rvalType
barrier
types
)
;
}
bool
IonBuilder
:
:
needsPostBarrier
(
MDefinition
*
value
)
{
CompileZone
*
zone
=
realm
-
>
zone
(
)
;
if
(
value
-
>
mightBeType
(
MIRType
:
:
Object
)
)
{
return
true
;
}
if
(
value
-
>
mightBeType
(
MIRType
:
:
String
)
&
&
zone
-
>
canNurseryAllocateStrings
(
)
)
{
return
true
;
}
if
(
value
-
>
mightBeType
(
MIRType
:
:
BigInt
)
&
&
zone
-
>
canNurseryAllocateBigInts
(
)
)
{
return
true
;
}
return
false
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setStaticName
(
JSObject
*
staticObject
PropertyName
*
name
)
{
jsid
id
=
NameToId
(
name
)
;
bool
isGlobalLexical
=
staticObject
-
>
is
<
LexicalEnvironmentObject
>
(
)
&
&
staticObject
-
>
as
<
LexicalEnvironmentObject
>
(
)
.
isGlobal
(
)
;
MOZ_ASSERT
(
isGlobalLexical
|
|
staticObject
-
>
is
<
GlobalObject
>
(
)
)
;
MDefinition
*
value
=
current
-
>
peek
(
-
1
)
;
TypeSet
:
:
ObjectKey
*
staticKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
staticObject
)
;
if
(
staticKey
-
>
unknownProperties
(
)
)
{
return
jsop_setprop
(
name
)
;
}
HeapTypeSetKey
property
=
staticKey
-
>
property
(
id
)
;
if
(
!
property
.
maybeTypes
(
)
|
|
!
property
.
maybeTypes
(
)
-
>
definiteProperty
(
)
|
|
property
.
nonData
(
constraints
(
)
)
|
|
property
.
nonWritable
(
constraints
(
)
)
)
{
return
jsop_setprop
(
name
)
;
}
if
(
!
CanWriteProperty
(
alloc
(
)
constraints
(
)
property
value
)
)
{
return
jsop_setprop
(
name
)
;
}
if
(
isGlobalLexical
&
&
IsUninitializedGlobalLexicalSlot
(
staticObject
name
)
)
{
return
jsop_setprop
(
name
)
;
}
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MOZ_ASSERT
(
obj
-
>
isConstant
(
)
|
|
obj
-
>
isPhi
(
)
)
;
MOZ_ASSERT_IF
(
obj
-
>
isConstant
(
)
&
obj
-
>
toConstant
(
)
-
>
toObject
(
)
=
=
staticObject
)
;
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
MIRType
slotType
=
MIRType
:
:
None
;
MIRType
knownType
=
property
.
knownMIRType
(
constraints
(
)
)
;
if
(
knownType
!
=
MIRType
:
:
Value
)
{
slotType
=
knownType
;
}
bool
needsPreBarrier
=
property
.
needsBarrier
(
constraints
(
)
)
;
return
storeSlot
(
obj
property
.
maybeTypes
(
)
-
>
definiteSlot
(
)
NumFixedSlots
(
staticObject
)
value
needsPreBarrier
slotType
)
;
}
JSObject
*
IonBuilder
:
:
testGlobalLexicalBinding
(
PropertyName
*
name
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
BindGName
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
GetGName
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
SetGName
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
StrictSetGName
)
;
NativeObject
*
obj
=
&
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
;
TypeSet
:
:
ObjectKey
*
lexicalKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
obj
)
;
jsid
id
=
NameToId
(
name
)
;
if
(
analysisContext
)
{
lexicalKey
-
>
ensureTrackedProperty
(
analysisContext
id
)
;
}
Maybe
<
HeapTypeSetKey
>
lexicalProperty
;
if
(
!
lexicalKey
-
>
unknownProperties
(
)
)
{
lexicalProperty
.
emplace
(
lexicalKey
-
>
property
(
id
)
)
;
}
Shape
*
shape
=
obj
-
>
lookupPure
(
name
)
;
if
(
shape
)
{
if
(
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
GetGName
&
&
!
shape
-
>
writable
(
)
)
|
|
obj
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
{
return
nullptr
;
}
}
else
{
shape
=
script
(
)
-
>
global
(
)
.
lookupPure
(
name
)
;
if
(
!
shape
|
|
shape
-
>
configurable
(
)
)
{
if
(
lexicalProperty
.
isSome
(
)
)
{
MOZ_ALWAYS_FALSE
(
lexicalProperty
-
>
isOwnProperty
(
constraints
(
)
)
)
;
}
else
{
return
nullptr
;
}
}
obj
=
&
script
(
)
-
>
global
(
)
;
}
return
obj
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getgname
(
PropertyName
*
name
)
{
if
(
name
=
=
names
(
)
.
undefined
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
}
if
(
name
=
=
names
(
)
.
NaN
)
{
pushConstant
(
JS
:
:
NaNValue
(
)
)
;
return
Ok
(
)
;
}
if
(
name
=
=
names
(
)
.
Infinity
)
{
pushConstant
(
JS
:
:
InfinityValue
(
)
)
;
return
Ok
(
)
;
}
if
(
JSObject
*
obj
=
testGlobalLexicalBinding
(
name
)
)
{
bool
emitted
=
false
;
MOZ_TRY
(
getStaticName
(
&
emitted
obj
name
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
if
(
!
forceInlineCaches
(
)
&
&
obj
-
>
is
<
GlobalObject
>
(
)
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MDefinition
*
globalObj
=
constant
(
ObjectValue
(
*
obj
)
)
;
MOZ_TRY
(
getPropTryCommonGetter
(
&
emitted
globalObj
NameToId
(
name
)
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
}
return
jsop_getname
(
name
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getname
(
PropertyName
*
name
)
{
MDefinition
*
object
;
if
(
IsGlobalOp
(
JSOp
(
*
pc
)
)
&
&
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
object
=
constant
(
ObjectValue
(
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
)
)
;
}
else
{
object
=
current
-
>
environmentChain
(
)
;
}
MGetNameCache
*
ins
=
MGetNameCache
:
:
New
(
alloc
(
)
object
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_intrinsic
(
PropertyName
*
name
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
Value
vp
=
UndefinedValue
(
)
;
if
(
!
script
(
)
-
>
global
(
)
.
maybeExistingIntrinsicValue
(
name
&
vp
)
)
{
MCallGetIntrinsicValue
*
ins
=
MCallGetIntrinsicValue
:
:
New
(
alloc
(
)
name
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
pushConstant
(
vp
)
;
if
(
!
types
-
>
hasType
(
TypeSet
:
:
GetValueType
(
vp
)
)
)
{
types
-
>
addType
(
TypeSet
:
:
GetValueType
(
vp
)
alloc
(
)
.
lifoAlloc
(
)
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getimport
(
PropertyName
*
name
)
{
ModuleEnvironmentObject
*
env
=
GetModuleEnvironmentForScript
(
script
(
)
)
;
MOZ_ASSERT
(
env
)
;
Shape
*
shape
;
ModuleEnvironmentObject
*
targetEnv
;
MOZ_ALWAYS_TRUE
(
env
-
>
lookupImport
(
NameToId
(
name
)
&
targetEnv
&
shape
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
BarrierKind
barrier
=
BarrierKind
:
:
TypeSet
;
MOZ_TRY
(
loadStaticSlot
(
targetEnv
barrier
types
shape
-
>
slot
(
)
)
)
;
if
(
targetEnv
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
{
MDefinition
*
checked
;
MOZ_TRY_VAR
(
checked
addLexicalCheck
(
current
-
>
pop
(
)
)
)
;
current
-
>
push
(
checked
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_bindname
(
PropertyName
*
name
)
{
MDefinition
*
envChain
;
if
(
IsGlobalOp
(
JSOp
(
*
pc
)
)
&
&
!
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
envChain
=
constant
(
ObjectValue
(
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
)
)
;
}
else
{
envChain
=
current
-
>
environmentChain
(
)
;
}
MBindNameCache
*
ins
=
MBindNameCache
:
:
New
(
alloc
(
)
envChain
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_bindvar
(
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MCallBindVar
*
ins
=
MCallBindVar
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
static
MIRType
GetElemKnownType
(
bool
needsHoleCheck
TemporaryTypeSet
*
types
)
{
MIRType
knownType
=
types
-
>
getKnownMIRType
(
)
;
if
(
knownType
=
=
MIRType
:
:
Undefined
|
|
knownType
=
=
MIRType
:
:
Null
)
{
knownType
=
MIRType
:
:
Value
;
}
if
(
needsHoleCheck
&
&
!
LIRGenerator
:
:
allowTypedElementHoleCheck
(
)
)
{
knownType
=
MIRType
:
:
Value
;
}
return
knownType
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getelem
(
)
{
MDefinition
*
index
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
if
(
info
(
)
.
isAnalysis
(
)
|
|
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
MInstruction
*
ins
=
MCallGetElement
:
:
New
(
alloc
(
)
obj
index
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
bool
emitted
=
false
;
if
(
obj
-
>
mightBeType
(
MIRType
:
:
MagicOptimizedArguments
)
&
&
!
info
(
)
.
isAnalysis
(
)
)
{
MOZ_TRY
(
getElemTryArguments
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryArgumentsInlinedConstant
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryArgumentsInlinedIndex
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
if
(
script
(
)
-
>
argumentsHasVarBinding
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Type
is
not
definitely
lazy
arguments
.
"
)
;
}
}
obj
=
maybeUnboxForPropertyAccess
(
obj
)
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
getElemTryGetProp
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryCallSiteObject
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryDense
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryTypedArray
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getElemTryString
(
&
emitted
obj
index
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
getElemAddCache
(
obj
index
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryGetProp
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MConstant
*
indexConst
=
index
-
>
maybeConstantValue
(
)
;
jsid
id
;
if
(
!
indexConst
|
|
!
ValueToIdPure
(
indexConst
-
>
toJSValue
(
)
&
id
)
)
{
return
Ok
(
)
;
}
if
(
id
!
=
IdToTypeId
(
id
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MOZ_TRY
(
getPropTryConstant
(
emitted
obj
id
types
)
)
;
if
(
*
emitted
)
{
index
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryNotDefined
(
emitted
obj
id
types
)
)
;
if
(
*
emitted
)
{
index
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryCommonGetter
(
emitted
obj
id
types
)
)
;
if
(
*
emitted
)
{
index
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryDense
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
ElementAccessIsDenseNative
(
constraints
(
)
obj
index
)
)
{
return
Ok
(
)
;
}
bool
hasExtraIndexedProperty
;
MOZ_TRY_VAR
(
hasExtraIndexedProperty
ElementAccessHasExtraIndexedProperty
(
this
obj
)
)
;
if
(
hasExtraIndexedProperty
&
&
failedBoundsCheck_
)
{
return
Ok
(
)
;
}
if
(
inspector
-
>
hasSeenNonIntegerIndex
(
pc
)
)
{
return
Ok
(
)
;
}
if
(
inspector
-
>
hasSeenNegativeIndexGetElement
(
pc
)
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
jsop_getelem_dense
(
obj
index
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryTypedArray
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
Scalar
:
:
Type
arrayType
;
if
(
!
ElementAccessIsTypedArray
(
constraints
(
)
obj
index
&
arrayType
)
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
jsop_getelem_typed
(
obj
index
arrayType
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryCallSiteObject
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
obj
-
>
isConstant
(
)
|
|
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
Ok
(
)
;
}
if
(
!
index
-
>
isConstant
(
)
|
|
index
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
Ok
(
)
;
}
JSObject
*
cst
=
&
obj
-
>
toConstant
(
)
-
>
toObject
(
)
;
if
(
!
cst
-
>
is
<
ArrayObject
>
(
)
)
{
return
Ok
(
)
;
}
ArrayObject
*
array
=
&
cst
-
>
as
<
ArrayObject
>
(
)
;
if
(
array
-
>
lengthIsWritable
(
)
|
|
array
-
>
hasEmptyElements
(
)
|
|
!
array
-
>
denseElementsAreFrozen
(
)
)
{
return
Ok
(
)
;
}
int32_t
idx
=
index
-
>
toConstant
(
)
-
>
toInt32
(
)
;
if
(
idx
<
0
|
|
!
array
-
>
containsDenseElement
(
uint32_t
(
idx
)
)
)
{
return
Ok
(
)
;
}
const
Value
&
v
=
array
-
>
getDenseElement
(
uint32_t
(
idx
)
)
;
if
(
!
v
.
isString
(
)
|
|
!
v
.
toString
(
)
-
>
isAtom
(
)
)
{
return
Ok
(
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
index
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
v
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryString
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
String
|
|
!
IsNumberType
(
index
-
>
type
(
)
)
)
{
return
Ok
(
)
;
}
if
(
bytecodeTypes
(
pc
)
-
>
hasType
(
TypeSet
:
:
UndefinedType
(
)
)
)
{
return
Ok
(
)
;
}
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
idInt32
)
;
index
=
idInt32
;
MStringLength
*
length
=
MStringLength
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
length
)
;
index
=
addBoundsCheck
(
index
length
)
;
MCharCodeAt
*
charCode
=
MCharCodeAt
:
:
New
(
alloc
(
)
obj
index
)
;
current
-
>
add
(
charCode
)
;
MFromCharCode
*
result
=
MFromCharCode
:
:
New
(
alloc
(
)
charCode
)
;
current
-
>
add
(
result
)
;
current
-
>
push
(
result
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryArguments
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
inliningDepth_
>
0
)
{
return
Ok
(
)
;
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
!
info
(
)
.
argsObjAliasesFormals
(
)
)
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
MArgumentsLength
*
length
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
length
)
;
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
idInt32
)
;
index
=
idInt32
;
index
=
addBoundsCheck
(
index
length
)
;
auto
*
load
=
MGetFrameArgument
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MOZ_TRY
(
pushTypeBarrier
(
load
types
BarrierKind
:
:
TypeSet
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryArgumentsInlinedConstant
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
inliningDepth_
=
=
0
)
{
return
Ok
(
)
;
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
return
Ok
(
)
;
}
MConstant
*
indexConst
=
index
-
>
maybeConstantValue
(
)
;
if
(
!
indexConst
|
|
indexConst
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
Ok
(
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
MOZ_ASSERT
(
!
info
(
)
.
argsObjAliasesFormals
(
)
)
;
MOZ_ASSERT
(
inliningDepth_
>
0
)
;
int32_t
id
=
indexConst
-
>
toInt32
(
)
;
index
-
>
setImplicitlyUsedUnchecked
(
)
;
if
(
id
<
(
int32_t
)
inlineCallInfo_
-
>
argc
(
)
&
&
id
>
=
0
)
{
current
-
>
push
(
inlineCallInfo_
-
>
getArg
(
id
)
)
;
}
else
{
pushConstant
(
UndefinedValue
(
)
)
;
}
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemTryArgumentsInlinedIndex
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
index
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
inliningDepth_
=
=
0
)
{
return
Ok
(
)
;
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
return
Ok
(
)
;
}
if
(
!
IsNumberType
(
index
-
>
type
(
)
)
)
{
return
Ok
(
)
;
}
if
(
inlineCallInfo_
-
>
argc
(
)
>
10
)
{
return
abort
(
AbortReason
:
:
Disable
"
NYI
get
argument
element
with
too
many
arguments
"
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
MOZ_ASSERT
(
!
info
(
)
.
argsObjAliasesFormals
(
)
)
;
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
idInt32
)
;
index
=
idInt32
;
index
=
addBoundsCheck
(
index
constantInt
(
inlineCallInfo_
-
>
argc
(
)
)
)
;
MInstruction
*
args
=
MArgumentState
:
:
New
(
alloc
(
)
.
fallible
(
)
inlineCallInfo_
-
>
argv
(
)
)
;
if
(
!
args
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
add
(
args
)
;
MInstruction
*
load
=
MLoadElementFromState
:
:
New
(
alloc
(
)
args
index
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getElemAddCache
(
MDefinition
*
obj
MDefinition
*
index
)
{
MGetPropertyCache
*
ins
=
MGetPropertyCache
:
:
New
(
alloc
(
)
obj
index
true
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MOZ_TRY
(
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
)
;
return
Ok
(
)
;
}
TemporaryTypeSet
*
IonBuilder
:
:
computeHeapType
(
const
TemporaryTypeSet
*
objTypes
const
jsid
id
)
{
if
(
objTypes
-
>
unknownObject
(
)
|
|
objTypes
-
>
getObjectCount
(
)
=
=
0
)
{
return
nullptr
;
}
TemporaryTypeSet
*
acc
=
nullptr
;
LifoAlloc
*
lifoAlloc
=
alloc
(
)
.
lifoAlloc
(
)
;
Vector
<
HeapTypeSetKey
4
SystemAllocPolicy
>
properties
;
if
(
!
properties
.
reserve
(
objTypes
-
>
getObjectCount
(
)
)
)
{
return
nullptr
;
}
for
(
unsigned
i
=
0
;
i
<
objTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
objTypes
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
if
(
key
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
HeapTypeSet
*
currentSet
=
property
.
maybeTypes
(
)
;
if
(
!
currentSet
|
|
currentSet
-
>
unknown
(
)
)
{
return
nullptr
;
}
properties
.
infallibleAppend
(
property
)
;
if
(
acc
)
{
acc
=
TypeSet
:
:
unionSets
(
acc
currentSet
lifoAlloc
)
;
}
else
{
TemporaryTypeSet
empty
;
acc
=
TypeSet
:
:
unionSets
(
&
empty
currentSet
lifoAlloc
)
;
}
if
(
!
acc
)
{
return
nullptr
;
}
}
for
(
HeapTypeSetKey
*
i
=
properties
.
begin
(
)
;
i
!
=
properties
.
end
(
)
;
i
+
+
)
{
i
-
>
freeze
(
constraints
(
)
)
;
}
return
acc
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getelem_dense
(
MDefinition
*
obj
MDefinition
*
index
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
MOZ_ASSERT
(
index
-
>
type
(
)
=
=
MIRType
:
:
Int32
|
|
index
-
>
type
(
)
=
=
MIRType
:
:
Double
)
;
BarrierKind
barrier
=
PropertyReadNeedsTypeBarrier
(
analysisContext
alloc
(
)
constraints
(
)
obj
nullptr
types
)
;
bool
needsHoleCheck
=
!
ElementAccessIsPacked
(
constraints
(
)
obj
)
;
bool
readOutOfBounds
=
false
;
if
(
types
-
>
hasType
(
TypeSet
:
:
UndefinedType
(
)
)
)
{
bool
hasExtraIndexedProperty
;
MOZ_TRY_VAR
(
hasExtraIndexedProperty
ElementAccessHasExtraIndexedProperty
(
this
obj
)
)
;
readOutOfBounds
=
!
hasExtraIndexedProperty
;
}
MIRType
knownType
=
MIRType
:
:
Value
;
if
(
barrier
=
=
BarrierKind
:
:
NoBarrier
)
{
knownType
=
GetElemKnownType
(
needsHoleCheck
types
)
;
}
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
idInt32
)
;
index
=
idInt32
;
MInstruction
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
MInstruction
*
initLength
=
initializedLength
(
elements
)
;
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
bool
inBounds
=
!
readOutOfBounds
&
&
!
needsHoleCheck
;
if
(
inBounds
)
{
TemporaryTypeSet
*
heapTypes
=
computeHeapType
(
objTypes
JSID_VOID
)
;
if
(
heapTypes
&
&
heapTypes
-
>
isSubset
(
types
)
)
{
knownType
=
heapTypes
-
>
getKnownMIRType
(
)
;
types
=
heapTypes
;
}
}
bool
loadDouble
=
barrier
=
=
BarrierKind
:
:
NoBarrier
&
&
loopDepth_
&
&
inBounds
&
&
knownType
=
=
MIRType
:
:
Double
&
&
objTypes
&
&
objTypes
-
>
convertDoubleElements
(
constraints
(
)
)
=
=
TemporaryTypeSet
:
:
AlwaysConvertToDoubles
;
if
(
loadDouble
)
{
elements
=
addConvertElementsToDoubles
(
elements
)
;
}
MInstruction
*
load
;
if
(
!
readOutOfBounds
)
{
index
=
addBoundsCheck
(
index
initLength
)
;
load
=
MLoadElement
:
:
New
(
alloc
(
)
elements
index
needsHoleCheck
loadDouble
)
;
current
-
>
add
(
load
)
;
}
else
{
load
=
MLoadElementHole
:
:
New
(
alloc
(
)
elements
index
initLength
needsHoleCheck
)
;
current
-
>
add
(
load
)
;
MOZ_ASSERT
(
knownType
=
=
MIRType
:
:
Value
)
;
}
if
(
knownType
!
=
MIRType
:
:
Value
)
{
load
-
>
setResultType
(
knownType
)
;
load
-
>
setResultTypeSet
(
types
)
;
}
current
-
>
push
(
load
)
;
return
pushTypeBarrier
(
load
types
barrier
)
;
}
MInstruction
*
IonBuilder
:
:
addArrayBufferByteLength
(
MDefinition
*
obj
)
{
auto
*
ins
=
MArrayBufferByteLengthInt32
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
ins
)
;
return
ins
;
}
TypedArrayObject
*
IonBuilder
:
:
tryTypedArrayEmbedConstantElements
(
MDefinition
*
obj
)
{
JSObject
*
object
=
nullptr
;
if
(
MConstant
*
objConst
=
obj
-
>
maybeConstantValue
(
)
)
{
if
(
objConst
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
object
=
&
objConst
-
>
toObject
(
)
;
}
}
else
if
(
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
)
{
object
=
types
-
>
maybeSingleton
(
)
;
}
if
(
!
object
|
|
!
object
-
>
isSingleton
(
)
)
{
return
nullptr
;
}
TypedArrayObject
*
tarr
=
&
object
-
>
as
<
TypedArrayObject
>
(
)
;
MOZ_ASSERT
(
tarr
-
>
hasBuffer
(
)
)
;
MOZ_ASSERT
(
tarr
-
>
byteLength
(
)
>
=
TypedArrayObject
:
:
SINGLETON_BYTE_LENGTH
|
|
tarr
-
>
hasDetachedBuffer
(
)
)
;
MOZ_ASSERT
(
!
tarr
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
.
isInside
(
tarr
-
>
dataPointerEither
(
)
)
)
;
TypeSet
:
:
ObjectKey
*
tarrKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
tarr
)
;
if
(
tarrKey
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
if
(
!
tarr
-
>
isSharedMemory
(
)
)
{
tarrKey
-
>
watchStateChangeForTypedArrayData
(
constraints
(
)
)
;
}
return
tarr
;
}
void
IonBuilder
:
:
addTypedArrayLengthAndData
(
MDefinition
*
obj
BoundsChecking
checking
MDefinition
*
*
index
MInstruction
*
*
length
MInstruction
*
*
elements
)
{
MOZ_ASSERT
(
(
index
!
=
nullptr
)
=
=
(
elements
!
=
nullptr
)
)
;
if
(
TypedArrayObject
*
tarr
=
tryTypedArrayEmbedConstantElements
(
obj
)
)
{
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
int32_t
len
=
AssertedCast
<
int32_t
>
(
tarr
-
>
length
(
)
)
;
*
length
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
len
)
)
;
current
-
>
add
(
*
length
)
;
if
(
index
)
{
if
(
checking
=
=
DoBoundsCheck
)
{
*
index
=
addBoundsCheck
(
*
index
*
length
)
;
}
*
elements
=
MConstantElements
:
:
New
(
alloc
(
)
tarr
-
>
dataPointerEither
(
)
)
;
current
-
>
add
(
*
elements
)
;
}
return
;
}
*
length
=
MArrayBufferViewLength
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
*
length
)
;
if
(
index
)
{
if
(
checking
=
=
DoBoundsCheck
)
{
*
index
=
addBoundsCheck
(
*
index
*
length
)
;
}
*
elements
=
MArrayBufferViewElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
*
elements
)
;
}
}
void
IonBuilder
:
:
addDataViewData
(
MDefinition
*
obj
Scalar
:
:
Type
type
MDefinition
*
*
index
MInstruction
*
*
elements
)
{
MInstruction
*
length
=
MArrayBufferViewLength
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
length
)
;
if
(
size_t
byteSize
=
Scalar
:
:
byteSize
(
type
)
;
byteSize
>
1
)
{
auto
*
byteSizeMinusOne
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
byteSize
-
1
)
)
;
current
-
>
add
(
byteSizeMinusOne
)
;
length
=
MSub
:
:
New
(
alloc
(
)
length
byteSizeMinusOne
MIRType
:
:
Int32
)
;
length
-
>
toSub
(
)
-
>
setTruncateKind
(
MDefinition
:
:
Truncate
)
;
current
-
>
add
(
length
)
;
auto
*
zero
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
0
)
)
;
current
-
>
add
(
zero
)
;
length
=
MMinMax
:
:
New
(
alloc
(
)
length
zero
MIRType
:
:
Int32
true
)
;
current
-
>
add
(
length
)
;
}
*
index
=
addBoundsCheck
(
*
index
length
)
;
*
elements
=
MArrayBufferViewElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
*
elements
)
;
}
MInstruction
*
IonBuilder
:
:
addTypedArrayByteOffset
(
MDefinition
*
obj
)
{
MInstruction
*
byteOffset
;
if
(
TypedArrayObject
*
tarr
=
tryTypedArrayEmbedConstantElements
(
obj
)
)
{
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
int32_t
offset
=
AssertedCast
<
int32_t
>
(
tarr
-
>
byteOffset
(
)
)
;
byteOffset
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
offset
)
)
;
}
else
{
byteOffset
=
MArrayBufferViewByteOffset
:
:
New
(
alloc
(
)
obj
)
;
}
current
-
>
add
(
byteOffset
)
;
return
byteOffset
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getelem_typed
(
MDefinition
*
obj
MDefinition
*
index
Scalar
:
:
Type
arrayType
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
bool
maybeUndefined
=
types
-
>
hasType
(
TypeSet
:
:
UndefinedType
(
)
)
;
bool
allowDouble
=
types
-
>
hasType
(
TypeSet
:
:
DoubleType
(
)
)
;
if
(
!
maybeUndefined
)
{
MInstruction
*
indexInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
indexInt32
)
;
index
=
indexInt32
;
MIRType
knownType
=
MIRTypeForArrayBufferViewRead
(
arrayType
allowDouble
)
;
MInstruction
*
length
;
MInstruction
*
elements
;
addTypedArrayLengthAndData
(
obj
DoBoundsCheck
&
index
&
length
&
elements
)
;
MLoadUnboxedScalar
*
load
=
MLoadUnboxedScalar
:
:
New
(
alloc
(
)
elements
index
arrayType
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
load
-
>
setResultType
(
knownType
)
;
return
Ok
(
)
;
}
else
{
auto
*
indexInt32
=
MTypedArrayIndexToInt32
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
indexInt32
)
;
index
=
indexInt32
;
BarrierKind
barrier
=
BarrierKind
:
:
TypeSet
;
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Uint8Clamped
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
if
(
types
-
>
hasType
(
TypeSet
:
:
Int32Type
(
)
)
)
{
barrier
=
BarrierKind
:
:
NoBarrier
;
}
break
;
case
Scalar
:
:
Float32
:
case
Scalar
:
:
Float64
:
if
(
allowDouble
)
{
barrier
=
BarrierKind
:
:
NoBarrier
;
}
break
;
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
if
(
types
-
>
hasType
(
TypeSet
:
:
BigIntType
(
)
)
)
{
barrier
=
BarrierKind
:
:
NoBarrier
;
}
break
;
default
:
MOZ_CRASH
(
"
Unknown
typed
array
type
"
)
;
}
MLoadTypedArrayElementHole
*
load
=
MLoadTypedArrayElementHole
:
:
New
(
alloc
(
)
obj
index
arrayType
allowDouble
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
return
pushTypeBarrier
(
load
types
barrier
)
;
}
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setelem
(
)
{
bool
emitted
=
false
;
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
index
=
current
-
>
pop
(
)
;
MDefinition
*
object
=
current
-
>
pop
(
)
;
if
(
shouldAbortOnPreliminaryGroups
(
object
)
)
{
MInstruction
*
ins
=
MCallSetElement
:
:
New
(
alloc
(
)
object
index
value
IsStrictSetPC
(
pc
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
return
resumeAfter
(
ins
)
;
}
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
setElemTryTypedArray
(
&
emitted
object
index
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
SetElemICInspector
icInspect
(
inspector
-
>
setElemICInspector
(
pc
)
)
;
bool
writeHole
=
icInspect
.
sawOOBDenseWrite
(
)
;
MOZ_TRY
(
initOrSetElemTryDense
(
&
emitted
object
index
value
writeHole
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
setElemTryArguments
(
&
emitted
object
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
if
(
script
(
)
-
>
argumentsHasVarBinding
(
)
&
&
object
-
>
mightBeType
(
MIRType
:
:
MagicOptimizedArguments
)
&
&
info
(
)
.
analysisMode
(
)
!
=
Analysis_ArgumentsUsage
)
{
return
abort
(
AbortReason
:
:
Disable
"
Type
is
not
definitely
lazy
arguments
.
"
)
;
}
MOZ_TRY
(
initOrSetElemTryCache
(
&
emitted
object
index
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MInstruction
*
ins
=
MCallSetElement
:
:
New
(
alloc
(
)
object
index
value
IsStrictSetPC
(
pc
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setElemTryTypedArray
(
bool
*
emitted
MDefinition
*
object
MDefinition
*
index
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
Scalar
:
:
Type
arrayType
;
if
(
!
ElementAccessIsTypedArray
(
constraints
(
)
object
index
&
arrayType
)
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
jsop_setelem_typed
(
arrayType
object
index
value
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initOrSetElemTryDense
(
bool
*
emitted
MDefinition
*
object
MDefinition
*
index
MDefinition
*
value
bool
writeHole
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
value
-
>
type
(
)
=
=
MIRType
:
:
MagicHole
)
{
return
Ok
(
)
;
}
if
(
!
ElementAccessIsDenseNative
(
constraints
(
)
object
index
)
)
{
return
Ok
(
)
;
}
if
(
PropertyWriteNeedsTypeBarrier
(
alloc
(
)
constraints
(
)
current
&
object
nullptr
&
value
true
)
)
{
return
Ok
(
)
;
}
if
(
!
object
-
>
resultTypeSet
(
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
:
:
DoubleConversion
conversion
=
object
-
>
resultTypeSet
(
)
-
>
convertDoubleElements
(
constraints
(
)
)
;
if
(
conversion
=
=
TemporaryTypeSet
:
:
AmbiguousDoubleConversion
&
&
value
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
Ok
(
)
;
}
bool
hasExtraIndexedProperty
;
MOZ_TRY_VAR
(
hasExtraIndexedProperty
ElementAccessHasExtraIndexedProperty
(
this
object
)
)
;
if
(
hasExtraIndexedProperty
&
&
failedBoundsCheck_
)
{
return
Ok
(
)
;
}
return
initOrSetElemDense
(
conversion
object
index
value
writeHole
emitted
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setElemTryArguments
(
bool
*
emitted
MDefinition
*
object
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
object
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
return
Ok
(
)
;
}
return
abort
(
AbortReason
:
:
Disable
"
NYI
arguments
[
]
=
"
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initOrSetElemTryCache
(
bool
*
emitted
MDefinition
*
object
MDefinition
*
index
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
object
-
>
mightBeType
(
MIRType
:
:
Object
)
)
{
return
Ok
(
)
;
}
if
(
value
-
>
type
(
)
=
=
MIRType
:
:
MagicHole
)
{
return
Ok
(
)
;
}
bool
barrier
=
true
;
if
(
index
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
!
PropertyWriteNeedsTypeBarrier
(
alloc
(
)
constraints
(
)
current
&
object
nullptr
&
value
true
)
)
{
barrier
=
false
;
}
bool
guardHoles
;
MOZ_TRY_VAR
(
guardHoles
ElementAccessHasExtraIndexedProperty
(
this
object
)
)
;
const
JSClass
*
clasp
=
object
-
>
resultTypeSet
(
)
?
object
-
>
resultTypeSet
(
)
-
>
getKnownClass
(
constraints
(
)
)
:
nullptr
;
bool
checkNative
=
!
clasp
|
|
!
clasp
-
>
isNative
(
)
;
object
=
addMaybeCopyElementsForWrite
(
object
checkNative
)
;
bool
strict
=
JSOp
(
*
pc
)
=
=
JSOp
:
:
StrictSetElem
;
MSetPropertyCache
*
ins
=
MSetPropertyCache
:
:
New
(
alloc
(
)
object
index
value
strict
needsPostBarrier
(
value
)
barrier
guardHoles
)
;
current
-
>
add
(
ins
)
;
if
(
!
IsPropertyInitOp
(
JSOp
(
*
pc
)
)
)
{
current
-
>
push
(
value
)
;
}
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
initOrSetElemDense
(
TemporaryTypeSet
:
:
DoubleConversion
conversion
MDefinition
*
obj
MDefinition
*
id
MDefinition
*
value
bool
writeHole
bool
*
emitted
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MIRType
elementType
=
DenseNativeElementType
(
constraints
(
)
obj
)
;
bool
packed
=
ElementAccessIsPacked
(
constraints
(
)
obj
)
;
bool
hasExtraIndexedProperty
;
MOZ_TRY_VAR
(
hasExtraIndexedProperty
ElementAccessHasExtraIndexedProperty
(
this
obj
)
)
;
bool
mayBeNonExtensible
=
ElementAccessMightBeNonExtensible
(
constraints
(
)
obj
)
;
if
(
mayBeNonExtensible
)
{
if
(
hasExtraIndexedProperty
)
{
return
Ok
(
)
;
}
if
(
IsPropertyInitOp
(
JSOp
(
*
pc
)
)
)
{
return
Ok
(
)
;
}
}
*
emitted
=
true
;
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
id
)
;
current
-
>
add
(
idInt32
)
;
id
=
idInt32
;
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteElementBarrier
:
:
New
(
alloc
(
)
obj
value
id
)
)
;
}
obj
=
addMaybeCopyElementsForWrite
(
obj
false
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
MDefinition
*
newValue
=
value
;
switch
(
conversion
)
{
case
TemporaryTypeSet
:
:
AlwaysConvertToDoubles
:
case
TemporaryTypeSet
:
:
MaybeConvertToDoubles
:
{
MInstruction
*
valueDouble
=
MToDouble
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
valueDouble
)
;
newValue
=
valueDouble
;
break
;
}
case
TemporaryTypeSet
:
:
AmbiguousDoubleConversion
:
{
MOZ_ASSERT
(
value
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
MInstruction
*
maybeDouble
=
MMaybeToDoubleElement
:
:
New
(
alloc
(
)
elements
value
)
;
current
-
>
add
(
maybeDouble
)
;
newValue
=
maybeDouble
;
break
;
}
case
TemporaryTypeSet
:
:
DontConvertToDoubles
:
break
;
default
:
MOZ_CRASH
(
"
Unknown
double
conversion
"
)
;
}
MInstruction
*
store
;
MStoreElementCommon
*
common
=
nullptr
;
if
(
writeHole
&
&
!
hasExtraIndexedProperty
&
&
!
mayBeNonExtensible
)
{
MStoreElementHole
*
ins
=
MStoreElementHole
:
:
New
(
alloc
(
)
obj
elements
id
newValue
)
;
store
=
ins
;
common
=
ins
;
current
-
>
add
(
ins
)
;
}
else
if
(
mayBeNonExtensible
)
{
MOZ_ASSERT
(
!
hasExtraIndexedProperty
"
FallibleStoreElement
codegen
assumes
no
extra
indexed
properties
"
)
;
bool
needsHoleCheck
=
!
packed
;
MFallibleStoreElement
*
ins
=
MFallibleStoreElement
:
:
New
(
alloc
(
)
obj
elements
id
newValue
needsHoleCheck
)
;
store
=
ins
;
common
=
ins
;
current
-
>
add
(
ins
)
;
}
else
{
MInstruction
*
initLength
=
initializedLength
(
elements
)
;
id
=
addBoundsCheck
(
id
initLength
)
;
bool
needsHoleCheck
=
!
packed
&
&
hasExtraIndexedProperty
;
MStoreElement
*
ins
=
MStoreElement
:
:
New
(
alloc
(
)
elements
id
newValue
needsHoleCheck
)
;
store
=
ins
;
common
=
ins
;
current
-
>
add
(
store
)
;
}
if
(
!
IsPropertyInitOp
(
JSOp
(
*
pc
)
)
)
{
current
-
>
push
(
value
)
;
}
MOZ_TRY
(
resumeAfter
(
store
)
)
;
if
(
common
)
{
if
(
obj
-
>
resultTypeSet
(
)
-
>
propertyNeedsBarrier
(
constraints
(
)
JSID_VOID
)
)
{
common
-
>
setNeedsBarrier
(
)
;
}
if
(
elementType
!
=
MIRType
:
:
None
&
&
packed
)
{
common
-
>
setElementType
(
elementType
)
;
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setelem_typed
(
Scalar
:
:
Type
arrayType
MDefinition
*
obj
MDefinition
*
id
MDefinition
*
value
)
{
SetElemICInspector
icInspect
(
inspector
-
>
setElemICInspector
(
pc
)
)
;
bool
expectOOB
=
icInspect
.
sawOOBTypedArrayWrite
(
)
;
if
(
expectOOB
)
{
spew
(
"
Emitting
OOB
TypedArray
SetElem
"
)
;
}
MInstruction
*
idInt32
;
if
(
expectOOB
)
{
idInt32
=
MTypedArrayIndexToInt32
:
:
New
(
alloc
(
)
id
)
;
}
else
{
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
id
)
;
}
current
-
>
add
(
idInt32
)
;
id
=
idInt32
;
MInstruction
*
length
;
MInstruction
*
elements
;
BoundsChecking
checking
=
expectOOB
?
SkipBoundsCheck
:
DoBoundsCheck
;
addTypedArrayLengthAndData
(
obj
checking
&
id
&
length
&
elements
)
;
MDefinition
*
toWrite
=
value
;
if
(
arrayType
=
=
Scalar
:
:
Uint8Clamped
)
{
toWrite
=
MClampToUint8
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
toWrite
-
>
toInstruction
(
)
)
;
}
MInstruction
*
ins
;
if
(
expectOOB
)
{
ins
=
MStoreTypedArrayElementHole
:
:
New
(
alloc
(
)
elements
length
id
toWrite
arrayType
)
;
}
else
{
ins
=
MStoreUnboxedScalar
:
:
New
(
alloc
(
)
elements
id
toWrite
arrayType
)
;
}
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_length
(
)
{
if
(
jsop_length_fastPath
(
)
)
{
return
Ok
(
)
;
}
PropertyName
*
name
=
info
(
)
.
getAtom
(
pc
)
-
>
asPropertyName
(
)
;
return
jsop_getprop
(
name
)
;
}
bool
IonBuilder
:
:
jsop_length_fastPath
(
)
{
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
if
(
types
-
>
getKnownMIRType
(
)
!
=
MIRType
:
:
Int32
)
{
return
false
;
}
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
if
(
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
return
false
;
}
if
(
obj
-
>
mightBeType
(
MIRType
:
:
String
)
)
{
if
(
obj
-
>
mightBeType
(
MIRType
:
:
Object
)
)
{
return
false
;
}
current
-
>
pop
(
)
;
MStringLength
*
ins
=
MStringLength
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
if
(
obj
-
>
mightBeType
(
MIRType
:
:
Object
)
)
{
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
if
(
objTypes
&
&
objTypes
-
>
getKnownClass
(
constraints
(
)
)
=
=
&
ArrayObject
:
:
class_
&
&
!
objTypes
-
>
hasObjectFlags
(
constraints
(
)
OBJECT_FLAG_LENGTH_OVERFLOW
)
)
{
current
-
>
pop
(
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
MArrayLength
*
length
=
MArrayLength
:
:
New
(
alloc
(
)
elements
)
;
current
-
>
add
(
length
)
;
current
-
>
push
(
length
)
;
return
true
;
}
}
return
false
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_arguments
(
)
{
if
(
info
(
)
.
needsArgsObj
(
)
)
{
current
-
>
push
(
current
-
>
argumentsObject
(
)
)
;
return
Ok
(
)
;
}
MOZ_ASSERT
(
hasLazyArguments_
)
;
MConstant
*
lazyArg
=
MConstant
:
:
New
(
alloc
(
)
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
)
;
current
-
>
add
(
lazyArg
)
;
current
-
>
push
(
lazyArg
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_newtarget
(
)
{
MOZ_ASSERT
(
info
(
)
.
funMaybeLazy
(
)
)
;
if
(
info
(
)
.
funMaybeLazy
(
)
-
>
isArrow
(
)
)
{
MArrowNewTarget
*
arrowNewTarget
=
MArrowNewTarget
:
:
New
(
alloc
(
)
getCallee
(
)
)
;
current
-
>
add
(
arrowNewTarget
)
;
current
-
>
push
(
arrowNewTarget
)
;
return
Ok
(
)
;
}
if
(
inliningDepth_
=
=
0
)
{
MNewTarget
*
newTarget
=
MNewTarget
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
newTarget
)
;
current
-
>
push
(
newTarget
)
;
return
Ok
(
)
;
}
if
(
!
inlineCallInfo_
-
>
constructing
(
)
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
Ok
(
)
;
}
current
-
>
push
(
inlineCallInfo_
-
>
getNewTarget
(
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_rest
(
)
{
if
(
info
(
)
.
analysisMode
(
)
=
=
Analysis_ArgumentsUsage
)
{
MUnknownValue
*
unknown
=
MUnknownValue
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
unknown
)
;
current
-
>
push
(
unknown
)
;
return
Ok
(
)
;
}
ArrayObject
*
templateObject
=
&
inspector
-
>
getTemplateObject
(
pc
)
-
>
as
<
ArrayObject
>
(
)
;
if
(
inliningDepth_
=
=
0
)
{
MArgumentsLength
*
numActuals
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
numActuals
)
;
MRest
*
rest
=
MRest
:
:
New
(
alloc
(
)
constraints
(
)
numActuals
info
(
)
.
nargs
(
)
-
1
templateObject
)
;
current
-
>
add
(
rest
)
;
current
-
>
push
(
rest
)
;
return
Ok
(
)
;
}
unsigned
numActuals
=
inlineCallInfo_
-
>
argc
(
)
;
unsigned
numFormals
=
info
(
)
.
nargs
(
)
-
1
;
unsigned
numRest
=
numActuals
>
numFormals
?
numActuals
-
numFormals
:
0
;
MOZ_TRY
(
jsop_newarray
(
numRest
)
)
;
if
(
numRest
=
=
0
)
{
return
Ok
(
)
;
}
MDefinition
*
array
=
current
-
>
peek
(
-
1
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
array
)
;
current
-
>
add
(
elements
)
;
MConstant
*
index
=
nullptr
;
for
(
unsigned
i
=
numFormals
;
i
<
numActuals
;
i
+
+
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
index
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
i
-
numFormals
)
)
;
current
-
>
add
(
index
)
;
MDefinition
*
arg
=
inlineCallInfo_
-
>
argv
(
)
[
i
]
;
MStoreElement
*
store
=
MStoreElement
:
:
New
(
alloc
(
)
elements
index
arg
false
)
;
current
-
>
add
(
store
)
;
if
(
needsPostBarrier
(
arg
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
array
arg
)
)
;
}
}
MSetArrayLength
*
length
=
MSetArrayLength
:
:
New
(
alloc
(
)
elements
index
)
;
current
-
>
add
(
length
)
;
MSetInitializedLength
*
initLength
=
MSetInitializedLength
:
:
New
(
alloc
(
)
elements
index
)
;
current
-
>
add
(
initLength
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkisobj
(
uint8_t
kind
)
{
MDefinition
*
toCheck
=
current
-
>
peek
(
-
1
)
;
if
(
toCheck
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
toCheck
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MCheckIsObj
*
check
=
MCheckIsObj
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
kind
)
;
current
-
>
add
(
check
)
;
current
-
>
push
(
check
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkobjcoercible
(
)
{
MDefinition
*
toCheck
=
current
-
>
peek
(
-
1
)
;
if
(
!
toCheck
-
>
mightBeType
(
MIRType
:
:
Undefined
)
&
&
!
toCheck
-
>
mightBeType
(
MIRType
:
:
Null
)
)
{
toCheck
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
MOZ_ASSERT
(
toCheck
-
>
type
(
)
=
=
MIRType
:
:
Value
|
|
toCheck
-
>
type
(
)
=
=
MIRType
:
:
Null
|
|
toCheck
-
>
type
(
)
=
=
MIRType
:
:
Undefined
)
;
MCheckObjCoercible
*
check
=
MCheckObjCoercible
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
check
)
;
current
-
>
push
(
check
)
;
return
resumeAfter
(
check
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkclassheritage
(
)
{
auto
*
ins
=
MCheckClassHeritage
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkthis
(
)
{
auto
*
ins
=
MCheckThis
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkthisreinit
(
)
{
auto
*
ins
=
MCheckThisReinit
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
uint32_t
IonBuilder
:
:
getDefiniteSlot
(
TemporaryTypeSet
*
types
jsid
id
uint32_t
*
pnfixed
)
{
if
(
!
types
|
|
types
-
>
unknownObject
(
)
|
|
!
types
-
>
objectOrSentinel
(
)
)
{
return
UINT32_MAX
;
}
uint32_t
slot
=
UINT32_MAX
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
if
(
key
-
>
unknownProperties
(
)
)
{
return
UINT32_MAX
;
}
if
(
key
-
>
isSingleton
(
)
)
{
return
UINT32_MAX
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
!
property
.
maybeTypes
(
)
|
|
!
property
.
maybeTypes
(
)
-
>
definiteProperty
(
)
|
|
property
.
nonData
(
constraints
(
)
)
)
{
return
UINT32_MAX
;
}
size_t
nfixed
=
NativeObject
:
:
MAX_FIXED_SLOTS
;
uint32_t
propertySlot
=
property
.
maybeTypes
(
)
-
>
definiteSlot
(
)
;
if
(
slot
=
=
UINT32_MAX
)
{
slot
=
propertySlot
;
*
pnfixed
=
nfixed
;
}
else
if
(
slot
!
=
propertySlot
|
|
nfixed
!
=
*
pnfixed
)
{
return
UINT32_MAX
;
}
}
return
slot
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_not
(
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MNot
*
ins
=
MNot
:
:
New
(
alloc
(
)
value
constraints
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_envcallee
(
)
{
uint8_t
numHops
=
GET_UINT8
(
pc
)
;
MDefinition
*
env
=
walkEnvironmentChain
(
numHops
)
;
MInstruction
*
callee
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
env
CallObject
:
:
calleeSlot
(
)
)
;
current
-
>
add
(
callee
)
;
current
-
>
push
(
callee
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_superbase
(
)
{
MDefinition
*
callee
=
current
-
>
pop
(
)
;
auto
*
homeObject
=
MHomeObject
:
:
New
(
alloc
(
)
callee
)
;
current
-
>
add
(
homeObject
)
;
auto
*
superBase
=
MHomeObjectSuperBase
:
:
New
(
alloc
(
)
homeObject
)
;
current
-
>
add
(
superBase
)
;
current
-
>
push
(
superBase
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getprop_super
(
PropertyName
*
name
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MDefinition
*
receiver
=
current
-
>
pop
(
)
;
MConstant
*
id
=
constant
(
StringValue
(
name
)
)
;
auto
*
ins
=
MGetPropSuperCache
:
:
New
(
alloc
(
)
obj
receiver
id
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getelem_super
(
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
receiver
=
current
-
>
pop
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
if
(
mirGen_
.
instrumentedProfiling
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
profiling
functions
with
GETELEM_SUPER
is
disabled
on
x86
"
)
;
}
#
endif
auto
*
ins
=
MGetPropSuperCache
:
:
New
(
alloc
(
)
obj
receiver
id
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
ins
types
BarrierKind
:
:
TypeSet
)
;
}
NativeObject
*
IonBuilder
:
:
commonPrototypeWithGetterSetter
(
TemporaryTypeSet
*
types
jsid
id
bool
isGetter
JSFunction
*
getterOrSetter
bool
*
guardGlobal
)
{
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
{
return
nullptr
;
}
*
guardGlobal
=
false
;
NativeObject
*
foundProto
=
nullptr
;
for
(
unsigned
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
while
(
key
)
{
if
(
key
-
>
unknownProperties
(
)
)
{
return
nullptr
;
}
const
JSClass
*
clasp
=
key
-
>
clasp
(
)
;
if
(
!
ClassHasEffectlessLookup
(
clasp
)
)
{
return
nullptr
;
}
JSObject
*
singleton
=
key
-
>
isSingleton
(
)
?
key
-
>
singleton
(
)
:
nullptr
;
if
(
ObjectHasExtraOwnProperty
(
realm
key
id
)
)
{
if
(
!
singleton
|
|
!
singleton
-
>
is
<
GlobalObject
>
(
)
)
{
return
nullptr
;
}
*
guardGlobal
=
true
;
}
if
(
isGetter
&
&
clasp
-
>
getOpsGetProperty
(
)
)
{
return
nullptr
;
}
if
(
!
isGetter
&
&
clasp
-
>
getOpsSetProperty
(
)
)
{
return
nullptr
;
}
if
(
singleton
)
{
if
(
!
singleton
-
>
is
<
NativeObject
>
(
)
)
{
return
nullptr
;
}
NativeObject
*
singletonNative
=
&
singleton
-
>
as
<
NativeObject
>
(
)
;
if
(
Shape
*
propShape
=
singletonNative
-
>
lookupPure
(
id
)
)
{
Value
getterSetterVal
=
ObjectValue
(
*
getterOrSetter
)
;
if
(
isGetter
)
{
if
(
propShape
-
>
getterOrUndefined
(
)
!
=
getterSetterVal
)
{
return
nullptr
;
}
}
else
{
if
(
propShape
-
>
setterOrUndefined
(
)
!
=
getterSetterVal
)
{
return
nullptr
;
}
}
if
(
!
foundProto
)
{
foundProto
=
singletonNative
;
}
else
if
(
foundProto
!
=
singletonNative
)
{
return
nullptr
;
}
break
;
}
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
TypeSet
*
types
=
property
.
maybeTypes
(
)
)
{
if
(
!
types
-
>
empty
(
)
|
|
types
-
>
nonDataProperty
(
)
)
{
return
nullptr
;
}
}
if
(
singleton
)
{
if
(
CanHaveEmptyPropertyTypesForOwnProperty
(
singleton
)
)
{
MOZ_ASSERT
(
singleton
-
>
is
<
GlobalObject
>
(
)
)
;
*
guardGlobal
=
true
;
}
}
JSObject
*
proto
=
checkNurseryObject
(
key
-
>
proto
(
)
.
toObjectOrNull
(
)
)
;
if
(
foundProto
&
&
proto
=
=
foundProto
)
{
break
;
}
if
(
!
proto
)
{
return
nullptr
;
}
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
proto
)
;
}
}
return
foundProto
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
freezePropertiesForCommonPrototype
(
TemporaryTypeSet
*
types
jsid
id
JSObject
*
foundProto
bool
allowEmptyTypesforGlobal
)
{
for
(
unsigned
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
if
(
types
-
>
getSingleton
(
i
)
=
=
foundProto
)
{
continue
;
}
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
while
(
true
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
MOZ_ALWAYS_TRUE
(
!
property
.
isOwnProperty
(
constraints
(
)
allowEmptyTypesforGlobal
)
)
;
if
(
key
-
>
proto
(
)
=
=
TaggedProto
(
foundProto
)
)
{
break
;
}
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
key
-
>
proto
(
)
.
toObjectOrNull
(
)
)
;
}
}
return
Ok
(
)
;
}
AbortReasonOr
<
bool
>
IonBuilder
:
:
testCommonGetterSetter
(
TemporaryTypeSet
*
types
jsid
id
bool
isGetter
JSFunction
*
getterOrSetter
MDefinition
*
*
guard
Shape
*
globalShape
MDefinition
*
*
globalGuard
)
{
MOZ_ASSERT
(
getterOrSetter
)
;
MOZ_ASSERT_IF
(
globalShape
globalGuard
)
;
bool
guardGlobal
;
NativeObject
*
foundProto
=
commonPrototypeWithGetterSetter
(
types
id
isGetter
getterOrSetter
&
guardGlobal
)
;
if
(
!
foundProto
|
|
(
guardGlobal
&
&
!
globalShape
)
)
{
return
false
;
}
MOZ_TRY
(
freezePropertiesForCommonPrototype
(
types
id
foundProto
guardGlobal
)
)
;
if
(
guardGlobal
)
{
JSObject
*
obj
=
&
script
(
)
-
>
global
(
)
;
MDefinition
*
globalObj
=
constant
(
ObjectValue
(
*
obj
)
)
;
*
globalGuard
=
addShapeGuard
(
globalObj
globalShape
)
;
}
Shape
*
propShape
=
foundProto
-
>
lookupPure
(
id
)
;
MOZ_ASSERT_IF
(
isGetter
propShape
-
>
getterObject
(
)
=
=
getterOrSetter
)
;
MOZ_ASSERT_IF
(
!
isGetter
propShape
-
>
setterObject
(
)
=
=
getterOrSetter
)
;
if
(
propShape
&
&
!
propShape
-
>
configurable
(
)
)
{
return
true
;
}
MInstruction
*
wrapper
=
constant
(
ObjectValue
(
*
foundProto
)
)
;
*
guard
=
addShapeGuard
(
wrapper
foundProto
-
>
lastProperty
(
)
)
;
return
true
;
}
void
IonBuilder
:
:
replaceMaybeFallbackFunctionGetter
(
MGetPropertyCache
*
cache
)
{
WrapMGetPropertyCache
rai
(
maybeFallbackFunctionGetter_
)
;
maybeFallbackFunctionGetter_
=
cache
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
annotateGetPropertyCache
(
MDefinition
*
obj
PropertyName
*
name
MGetPropertyCache
*
getPropCache
TemporaryTypeSet
*
objTypes
TemporaryTypeSet
*
pushedTypes
)
{
if
(
pushedTypes
-
>
unknownObject
(
)
|
|
pushedTypes
-
>
baseFlags
(
)
!
=
0
)
{
return
Ok
(
)
;
}
for
(
unsigned
i
=
0
;
i
<
pushedTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
if
(
pushedTypes
-
>
getGroup
(
i
)
!
=
nullptr
)
{
return
Ok
(
)
;
}
}
if
(
!
objTypes
|
|
objTypes
-
>
baseFlags
(
)
|
|
objTypes
-
>
unknownObject
(
)
)
{
return
Ok
(
)
;
}
unsigned
int
objCount
=
objTypes
-
>
getObjectCount
(
)
;
if
(
objCount
=
=
0
)
{
return
Ok
(
)
;
}
InlinePropertyTable
*
inlinePropTable
=
getPropCache
-
>
initInlinePropertyTable
(
alloc
(
)
pc
)
;
if
(
!
inlinePropTable
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
for
(
unsigned
int
i
=
0
;
i
<
objCount
;
i
+
+
)
{
ObjectGroup
*
group
=
objTypes
-
>
getGroup
(
i
)
;
if
(
!
group
)
{
continue
;
}
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
group
)
;
if
(
key
-
>
unknownProperties
(
)
|
|
!
key
-
>
proto
(
)
.
isObject
(
)
)
{
continue
;
}
JSObject
*
proto
=
checkNurseryObject
(
key
-
>
proto
(
)
.
toObject
(
)
)
;
const
JSClass
*
clasp
=
key
-
>
clasp
(
)
;
if
(
!
ClassHasEffectlessLookup
(
clasp
)
|
|
ObjectHasExtraOwnProperty
(
realm
key
NameToId
(
name
)
)
)
{
continue
;
}
HeapTypeSetKey
ownTypes
=
key
-
>
property
(
NameToId
(
name
)
)
;
if
(
ownTypes
.
isOwnProperty
(
constraints
(
)
)
)
{
continue
;
}
JSObject
*
singleton
=
testSingletonProperty
(
proto
NameToId
(
name
)
)
;
if
(
!
singleton
|
|
!
singleton
-
>
is
<
JSFunction
>
(
)
)
{
continue
;
}
if
(
!
pushedTypes
-
>
hasType
(
TypeSet
:
:
ObjectType
(
singleton
)
)
)
{
continue
;
}
if
(
!
inlinePropTable
-
>
addEntry
(
alloc
(
)
group
&
singleton
-
>
as
<
JSFunction
>
(
)
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
if
(
inlinePropTable
-
>
numEntries
(
)
=
=
0
)
{
getPropCache
-
>
clearInlinePropertyTable
(
)
;
return
Ok
(
)
;
}
#
ifdef
JS_JITSPEW
if
(
inlinePropTable
-
>
numEntries
(
)
>
0
)
{
JitSpew
(
JitSpew_Inlining
"
Annotated
GetPropertyCache
with
%
d
/
%
d
inline
cases
"
(
int
)
inlinePropTable
-
>
numEntries
(
)
(
int
)
objCount
)
;
}
#
endif
if
(
inlinePropTable
-
>
numEntries
(
)
>
0
)
{
current
-
>
push
(
obj
)
;
MResumePoint
*
resumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
current
pc
MResumePoint
:
:
ResumeAt
)
;
if
(
!
resumePoint
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
inlinePropTable
-
>
setPriorResumePoint
(
resumePoint
)
;
replaceMaybeFallbackFunctionGetter
(
getPropCache
)
;
current
-
>
pop
(
)
;
}
return
Ok
(
)
;
}
bool
IonBuilder
:
:
invalidatedIdempotentCache
(
)
{
IonBuilder
*
builder
=
this
;
do
{
if
(
builder
-
>
script
(
)
-
>
invalidatedIdempotentCache
(
)
)
{
return
true
;
}
builder
=
builder
-
>
callerBuilder_
;
}
while
(
builder
)
;
return
false
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
loadSlot
(
MDefinition
*
obj
size_t
slot
size_t
nfixed
MIRType
rvalType
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
if
(
slot
<
nfixed
)
{
MLoadFixedSlot
*
load
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
obj
slot
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
load
-
>
setResultType
(
rvalType
)
;
return
pushTypeBarrier
(
load
types
barrier
)
;
}
MSlots
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
MLoadDynamicSlot
*
load
=
MLoadDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
-
nfixed
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
load
-
>
setResultType
(
rvalType
)
;
return
pushTypeBarrier
(
load
types
barrier
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
loadSlot
(
MDefinition
*
obj
Shape
*
shape
MIRType
rvalType
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
return
loadSlot
(
obj
shape
-
>
slot
(
)
shape
-
>
numFixedSlots
(
)
rvalType
barrier
types
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
storeSlot
(
MDefinition
*
obj
size_t
slot
size_t
nfixed
MDefinition
*
value
bool
needsBarrier
MIRType
slotType
)
{
if
(
slot
<
nfixed
)
{
MStoreFixedSlot
*
store
=
MStoreFixedSlot
:
:
New
(
alloc
(
)
obj
slot
value
)
;
current
-
>
add
(
store
)
;
current
-
>
push
(
value
)
;
if
(
needsBarrier
)
{
store
-
>
setNeedsBarrier
(
)
;
}
return
resumeAfter
(
store
)
;
}
MSlots
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
MStoreDynamicSlot
*
store
=
MStoreDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
-
nfixed
value
)
;
current
-
>
add
(
store
)
;
current
-
>
push
(
value
)
;
if
(
needsBarrier
)
{
store
-
>
setNeedsBarrier
(
)
;
}
if
(
slotType
!
=
MIRType
:
:
None
)
{
store
-
>
setSlotType
(
slotType
)
;
}
return
resumeAfter
(
store
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
storeSlot
(
MDefinition
*
obj
Shape
*
shape
MDefinition
*
value
bool
needsBarrier
MIRType
slotType
)
{
MOZ_ASSERT
(
shape
-
>
writable
(
)
)
;
return
storeSlot
(
obj
shape
-
>
slot
(
)
shape
-
>
numFixedSlots
(
)
value
needsBarrier
slotType
)
;
}
bool
IonBuilder
:
:
shouldAbortOnPreliminaryGroups
(
MDefinition
*
obj
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
{
return
false
;
}
bool
preliminary
=
false
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
if
(
ObjectGroup
*
group
=
key
-
>
maybeGroup
(
)
)
{
if
(
group
-
>
hasUnanalyzedPreliminaryObjects
(
)
)
{
addAbortedPreliminaryGroup
(
group
)
;
preliminary
=
true
;
}
}
}
return
preliminary
;
}
MDefinition
*
IonBuilder
:
:
maybeUnboxForPropertyAccess
(
MDefinition
*
def
)
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
return
def
;
}
MIRType
type
=
inspector
-
>
expectedPropertyAccessInputType
(
pc
)
;
if
(
type
=
=
MIRType
:
:
Value
|
|
!
def
-
>
mightBeType
(
type
)
)
{
return
def
;
}
MUnbox
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
def
type
MUnbox
:
:
Fallible
)
;
current
-
>
add
(
unbox
)
;
if
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallProp
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallElem
)
{
uint32_t
idx
=
current
-
>
stackDepth
(
)
-
1
;
MOZ_ASSERT
(
current
-
>
getSlot
(
idx
)
=
=
def
)
;
current
-
>
setSlot
(
idx
unbox
)
;
}
return
unbox
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getprop
(
PropertyName
*
name
)
{
bool
emitted
=
false
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
if
(
!
info
(
)
.
isAnalysis
(
)
)
{
MOZ_TRY
(
getPropTryArgumentsLength
(
&
emitted
obj
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryArgumentsCallee
(
&
emitted
obj
name
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
obj
=
maybeUnboxForPropertyAccess
(
obj
)
;
BarrierKind
barrier
=
PropertyReadNeedsTypeBarrier
(
analysisContext
alloc
(
)
constraints
(
)
obj
name
types
)
;
if
(
barrier
=
=
BarrierKind
:
:
NoBarrier
)
{
MOZ_TRY
(
getPropTryInferredConstant
(
&
emitted
obj
name
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
if
(
info
(
)
.
isAnalysis
(
)
|
|
types
-
>
empty
(
)
|
|
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
MCallGetProperty
*
call
=
MCallGetProperty
:
:
New
(
alloc
(
)
obj
name
)
;
current
-
>
add
(
call
)
;
if
(
info
(
)
.
isAnalysis
(
)
)
{
MOZ_TRY
(
getPropTryConstant
(
&
emitted
obj
NameToId
(
name
)
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
current
-
>
push
(
call
)
;
MOZ_TRY
(
resumeAfter
(
call
)
)
;
return
pushTypeBarrier
(
call
types
BarrierKind
:
:
TypeSet
)
;
}
MOZ_TRY
(
getPropTryInnerize
(
&
emitted
obj
name
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
getPropTryConstant
(
&
emitted
obj
NameToId
(
name
)
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryNotDefined
(
&
emitted
obj
NameToId
(
name
)
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryDefiniteSlot
(
&
emitted
obj
name
barrier
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryCommonGetter
(
&
emitted
obj
NameToId
(
name
)
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryInlineAccess
(
&
emitted
obj
name
barrier
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryInlineProtoAccess
(
&
emitted
obj
name
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryModuleNamespace
(
&
emitted
obj
name
barrier
types
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
return
getPropAddCache
(
obj
name
barrier
types
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
improveThisTypesForCall
(
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallProp
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallElem
)
;
MDefinition
*
thisDef
=
current
-
>
peek
(
-
2
)
;
MDefinition
*
calleeDef
=
current
-
>
peek
(
-
1
)
;
if
(
thisDef
-
>
type
(
)
!
=
MIRType
:
:
Value
|
|
!
thisDef
-
>
mightBeType
(
MIRType
:
:
Object
)
|
|
!
thisDef
-
>
resultTypeSet
(
)
|
|
!
thisDef
-
>
resultTypeSet
(
)
-
>
objectOrSentinel
(
)
|
|
calleeDef
-
>
isPhi
(
)
)
{
return
Ok
(
)
;
}
TemporaryTypeSet
*
types
=
thisDef
-
>
resultTypeSet
(
)
-
>
cloneObjectsOnly
(
alloc_
-
>
lifoAlloc
(
)
)
;
if
(
!
types
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MFilterTypeSet
*
filter
=
MFilterTypeSet
:
:
New
(
alloc
(
)
thisDef
types
)
;
current
-
>
add
(
filter
)
;
current
-
>
rewriteAtDepth
(
-
2
filter
)
;
filter
-
>
setDependency
(
calleeDef
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
checkIsDefinitelyOptimizedArguments
(
MDefinition
*
obj
bool
*
isOptimizedArgs
)
{
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
MagicOptimizedArguments
)
{
if
(
script
(
)
-
>
argumentsHasVarBinding
(
)
&
&
obj
-
>
mightBeType
(
MIRType
:
:
MagicOptimizedArguments
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Type
is
not
definitely
lazy
arguments
.
"
)
;
}
*
isOptimizedArgs
=
false
;
return
Ok
(
)
;
}
*
isOptimizedArgs
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryInferredConstant
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
objTypes
)
{
return
Ok
(
)
;
}
JSObject
*
singleton
=
objTypes
-
>
maybeSingleton
(
)
;
if
(
!
singleton
)
{
return
Ok
(
)
;
}
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
singleton
)
;
if
(
key
-
>
unknownProperties
(
)
)
{
return
Ok
(
)
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
NameToId
(
name
)
)
;
Value
constantValue
=
UndefinedValue
(
)
;
if
(
property
.
constant
(
constraints
(
)
&
constantValue
)
)
{
spew
(
"
Optimized
constant
property
"
)
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
constantValue
)
;
types
-
>
addType
(
TypeSet
:
:
GetValueType
(
constantValue
)
alloc_
-
>
lifoAlloc
(
)
)
;
*
emitted
=
true
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryArgumentsLength
(
bool
*
emitted
MDefinition
*
obj
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
Length
)
{
return
Ok
(
)
;
}
bool
isOptimizedArgs
=
false
;
MOZ_TRY
(
checkIsDefinitelyOptimizedArguments
(
obj
&
isOptimizedArgs
)
)
;
if
(
!
isOptimizedArgs
)
{
return
Ok
(
)
;
}
*
emitted
=
true
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
if
(
inliningDepth_
=
=
0
)
{
MInstruction
*
ins
=
MArgumentsLength
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
pushConstant
(
Int32Value
(
inlineCallInfo_
-
>
argv
(
)
.
length
(
)
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryArgumentsCallee
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
name
!
=
names
(
)
.
callee
)
{
return
Ok
(
)
;
}
bool
isOptimizedArgs
=
false
;
MOZ_TRY
(
checkIsDefinitelyOptimizedArguments
(
obj
&
isOptimizedArgs
)
)
;
if
(
!
isOptimizedArgs
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
script
(
)
-
>
hasMappedArgsObj
(
)
)
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
current
-
>
push
(
getCallee
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryConstant
(
bool
*
emitted
MDefinition
*
obj
jsid
id
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
types
-
>
mightBeMIRType
(
MIRType
:
:
Object
)
)
{
return
Ok
(
)
;
}
JSObject
*
singleton
=
testSingletonPropertyTypes
(
obj
id
)
;
if
(
!
singleton
)
{
return
Ok
(
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
ObjectValue
(
*
singleton
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryNotDefined
(
bool
*
emitted
MDefinition
*
obj
jsid
id
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
types
-
>
mightBeMIRType
(
MIRType
:
:
Undefined
)
)
{
return
Ok
(
)
;
}
bool
res
;
MOZ_TRY_VAR
(
res
testNotDefinedProperty
(
obj
id
)
)
;
if
(
!
res
)
{
return
Ok
(
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
UndefinedValue
(
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryDefiniteSlot
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
uint32_t
nfixed
;
uint32_t
slot
=
getDefiniteSlot
(
obj
-
>
resultTypeSet
(
)
NameToId
(
name
)
&
nfixed
)
;
if
(
slot
=
=
UINT32_MAX
)
{
return
Ok
(
)
;
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
MGuardObject
*
guard
=
MGuardObject
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
guard
)
;
obj
=
guard
;
}
MInstruction
*
load
;
if
(
slot
<
nfixed
)
{
load
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
obj
slot
)
;
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
load
=
MLoadDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
-
nfixed
)
;
}
if
(
barrier
=
=
BarrierKind
:
:
NoBarrier
)
{
load
-
>
setResultType
(
types
-
>
getKnownMIRType
(
)
)
;
}
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
MOZ_TRY
(
pushTypeBarrier
(
load
types
barrier
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryModuleNamespace
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
objTypes
)
{
return
Ok
(
)
;
}
JSObject
*
singleton
=
objTypes
-
>
maybeSingleton
(
)
;
if
(
!
singleton
)
{
return
Ok
(
)
;
}
if
(
!
singleton
-
>
is
<
ModuleNamespaceObject
>
(
)
)
{
return
Ok
(
)
;
}
ModuleNamespaceObject
*
ns
=
&
singleton
-
>
as
<
ModuleNamespaceObject
>
(
)
;
ModuleEnvironmentObject
*
env
;
Shape
*
shape
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
NameToId
(
name
)
&
env
&
shape
)
)
{
return
Ok
(
)
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
MConstant
*
envConst
=
constant
(
ObjectValue
(
*
env
)
)
;
uint32_t
slot
=
shape
-
>
slot
(
)
;
uint32_t
nfixed
=
env
-
>
numFixedSlots
(
)
;
MIRType
rvalType
=
types
-
>
getKnownMIRType
(
)
;
if
(
barrier
!
=
BarrierKind
:
:
NoBarrier
|
|
IsNullOrUndefined
(
rvalType
)
)
{
rvalType
=
MIRType
:
:
Value
;
}
MOZ_TRY
(
loadSlot
(
envConst
slot
nfixed
rvalType
barrier
types
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
MDefinition
*
IonBuilder
:
:
addShapeGuardsForGetterSetter
(
MDefinition
*
obj
JSObject
*
holder
Shape
*
holderShape
const
BaselineInspector
:
:
ReceiverVector
&
receivers
bool
isOwnProperty
)
{
MOZ_ASSERT
(
isOwnProperty
=
=
!
holder
)
;
MOZ_ASSERT
(
holderShape
)
;
if
(
isOwnProperty
)
{
MOZ_ASSERT
(
receivers
.
empty
(
)
)
;
return
addShapeGuard
(
obj
holderShape
)
;
}
MDefinition
*
holderDef
=
constant
(
ObjectValue
(
*
holder
)
)
;
addShapeGuard
(
holderDef
holderShape
)
;
return
addGuardReceiverPolymorphic
(
obj
receivers
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryCommonGetter
(
bool
*
emitted
MDefinition
*
obj
jsid
id
TemporaryTypeSet
*
types
bool
innerized
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
JSFunction
*
commonGetter
=
nullptr
;
MDefinition
*
guard
=
nullptr
;
MDefinition
*
globalGuard
=
nullptr
;
{
Shape
*
lastProperty
=
nullptr
;
Shape
*
globalShape
=
nullptr
;
JSObject
*
foundProto
=
nullptr
;
bool
isOwnProperty
=
false
;
BaselineInspector
:
:
ReceiverVector
receivers
(
alloc
(
)
)
;
if
(
inspector
-
>
commonGetPropFunction
(
pc
id
innerized
&
foundProto
&
lastProperty
&
commonGetter
&
globalShape
&
isOwnProperty
receivers
)
)
{
bool
canUseTIForGetter
=
false
;
if
(
!
isOwnProperty
)
{
MOZ_TRY_VAR
(
canUseTIForGetter
testCommonGetterSetter
(
objTypes
id
true
commonGetter
&
guard
globalShape
&
globalGuard
)
)
;
}
if
(
!
canUseTIForGetter
)
{
obj
=
addShapeGuardsForGetterSetter
(
obj
foundProto
lastProperty
receivers
isOwnProperty
)
;
if
(
!
obj
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
}
else
if
(
inspector
-
>
megamorphicGetterSetterFunction
(
pc
id
true
&
commonGetter
)
)
{
bool
canUseTIForGetter
=
false
;
MOZ_TRY_VAR
(
canUseTIForGetter
testCommonGetterSetter
(
objTypes
id
true
commonGetter
&
guard
)
)
;
if
(
!
canUseTIForGetter
)
{
return
Ok
(
)
;
}
}
else
{
return
Ok
(
)
;
}
}
DOMObjectKind
objKind
=
DOMObjectKind
:
:
Unknown
;
bool
isDOM
=
objTypes
&
&
objTypes
-
>
isDOMClass
(
constraints
(
)
&
objKind
)
;
if
(
isDOM
)
{
MOZ_TRY_VAR
(
isDOM
testShouldDOMCall
(
objTypes
commonGetter
JSJitInfo
:
:
Getter
)
)
;
}
if
(
isDOM
)
{
const
JSJitInfo
*
jitinfo
=
commonGetter
-
>
jitInfo
(
)
;
if
(
objKind
=
=
DOMObjectKind
:
:
Native
|
|
(
!
jitinfo
-
>
isAlwaysInSlot
&
&
!
jitinfo
-
>
isLazilyCachedInSlot
)
)
{
MInstruction
*
get
;
if
(
jitinfo
-
>
isAlwaysInSlot
)
{
JSObject
*
singleton
=
objTypes
-
>
maybeSingleton
(
)
;
if
(
singleton
&
&
jitinfo
-
>
aliasSet
(
)
=
=
JSJitInfo
:
:
AliasNone
)
{
size_t
slot
=
jitinfo
-
>
slotIndex
;
*
emitted
=
true
;
pushConstant
(
JS
:
:
GetReservedSlot
(
singleton
slot
)
)
;
return
Ok
(
)
;
}
get
=
MGetDOMMember
:
:
New
(
alloc
(
)
jitinfo
obj
guard
globalGuard
)
;
}
else
{
get
=
MGetDOMProperty
:
:
New
(
alloc
(
)
jitinfo
objKind
commonGetter
-
>
realm
(
)
obj
guard
globalGuard
)
;
}
if
(
!
get
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
add
(
get
)
;
current
-
>
push
(
get
)
;
if
(
get
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
get
)
)
;
}
MOZ_TRY
(
pushDOMTypeBarrier
(
get
types
commonGetter
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
MGuardObject
*
guardObj
=
MGuardObject
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
guardObj
)
;
obj
=
guardObj
;
}
if
(
!
current
-
>
ensureHasSlots
(
2
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
push
(
constant
(
ObjectValue
(
*
commonGetter
)
)
)
;
current
-
>
push
(
obj
)
;
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
0
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
commonGetter
-
>
isNative
(
)
)
{
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineNativeGetter
(
callInfo
commonGetter
)
)
;
switch
(
status
)
{
case
InliningStatus_WarmUpCountTooLow
:
case
InliningStatus_NotInlined
:
break
;
case
InliningStatus_Inlined
:
*
emitted
=
true
;
return
Ok
(
)
;
}
}
if
(
commonGetter
-
>
isInterpreted
(
)
)
{
InliningDecision
decision
=
makeInliningDecision
(
commonGetter
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
case
InliningDecision_WarmUpCountTooLow
:
break
;
case
InliningDecision_Inline
:
{
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineScriptedCall
(
callInfo
commonGetter
)
)
;
if
(
status
=
=
InliningStatus_Inlined
)
{
*
emitted
=
true
;
return
Ok
(
)
;
}
break
;
}
}
}
MOZ_TRY
(
makeCall
(
commonGetter
callInfo
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
bool
IonBuilder
:
:
canInlinePropertyOpShapes
(
const
BaselineInspector
:
:
ReceiverVector
&
receivers
)
{
if
(
receivers
.
empty
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
receivers
.
length
(
)
;
i
+
+
)
{
if
(
receivers
[
i
]
.
getShape
(
)
&
&
receivers
[
i
]
.
getShape
(
)
-
>
inDictionary
(
)
)
{
return
false
;
}
}
return
true
;
}
static
Shape
*
PropertyShapesHaveSameSlot
(
const
BaselineInspector
:
:
ReceiverVector
&
receivers
jsid
id
)
{
Shape
*
firstShape
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
receivers
.
length
(
)
;
i
+
+
)
{
if
(
receivers
[
i
]
.
getGroup
(
)
)
{
return
nullptr
;
}
Shape
*
shape
=
receivers
[
i
]
.
getShape
(
)
-
>
searchLinear
(
id
)
;
MOZ_ASSERT
(
shape
)
;
if
(
i
=
=
0
)
{
firstShape
=
shape
;
}
else
if
(
shape
-
>
slot
(
)
!
=
firstShape
-
>
slot
(
)
|
|
shape
-
>
numFixedSlots
(
)
!
=
firstShape
-
>
numFixedSlots
(
)
)
{
return
nullptr
;
}
}
return
firstShape
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryInlineAccess
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
BaselineInspector
:
:
ReceiverVector
receivers
(
alloc
(
)
)
;
if
(
!
inspector
-
>
maybeInfoForPropertyOp
(
pc
receivers
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
canInlinePropertyOpShapes
(
receivers
)
)
{
return
Ok
(
)
;
}
MIRType
rvalType
=
types
-
>
getKnownMIRType
(
)
;
if
(
barrier
!
=
BarrierKind
:
:
NoBarrier
|
|
IsNullOrUndefined
(
rvalType
)
)
{
rvalType
=
MIRType
:
:
Value
;
}
if
(
receivers
.
length
(
)
=
=
1
)
{
if
(
!
receivers
[
0
]
.
getGroup
(
)
)
{
spew
(
"
Inlining
monomorphic
native
GETPROP
"
)
;
obj
=
addShapeGuard
(
obj
receivers
[
0
]
.
getShape
(
)
)
;
Shape
*
shape
=
receivers
[
0
]
.
getShape
(
)
-
>
searchLinear
(
NameToId
(
name
)
)
;
MOZ_ASSERT
(
shape
)
;
MOZ_TRY
(
loadSlot
(
obj
shape
rvalType
barrier
types
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
return
Ok
(
)
;
}
MOZ_ASSERT
(
receivers
.
length
(
)
>
1
)
;
spew
(
"
Inlining
polymorphic
GETPROP
"
)
;
if
(
Shape
*
propShape
=
PropertyShapesHaveSameSlot
(
receivers
NameToId
(
name
)
)
)
{
obj
=
addGuardReceiverPolymorphic
(
obj
receivers
)
;
if
(
!
obj
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MOZ_TRY
(
loadSlot
(
obj
propShape
rvalType
barrier
types
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
MGetPropertyPolymorphic
*
load
=
MGetPropertyPolymorphic
:
:
New
(
alloc
(
)
obj
name
)
;
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
for
(
size_t
i
=
0
;
i
<
receivers
.
length
(
)
;
i
+
+
)
{
Shape
*
propShape
=
nullptr
;
if
(
receivers
[
i
]
.
getShape
(
)
)
{
propShape
=
receivers
[
i
]
.
getShape
(
)
-
>
searchLinear
(
NameToId
(
name
)
)
;
MOZ_ASSERT
(
propShape
)
;
}
if
(
!
load
-
>
addReceiver
(
receivers
[
i
]
propShape
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
if
(
failedShapeGuard_
)
{
load
-
>
setNotMovable
(
)
;
}
load
-
>
setResultType
(
rvalType
)
;
MOZ_TRY
(
pushTypeBarrier
(
load
types
barrier
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryInlineProtoAccess
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
BaselineInspector
:
:
ReceiverVector
receivers
(
alloc
(
)
)
;
JSObject
*
holder
=
nullptr
;
if
(
!
inspector
-
>
maybeInfoForProtoReadSlot
(
pc
receivers
&
holder
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
canInlinePropertyOpShapes
(
receivers
)
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
holder
)
;
holder
=
checkNurseryObject
(
holder
)
;
BarrierKind
barrier
;
MOZ_TRY_VAR
(
barrier
PropertyReadOnPrototypeNeedsTypeBarrier
(
this
obj
name
types
)
)
;
MIRType
rvalType
=
types
-
>
getKnownMIRType
(
)
;
if
(
barrier
!
=
BarrierKind
:
:
NoBarrier
|
|
IsNullOrUndefined
(
rvalType
)
)
{
rvalType
=
MIRType
:
:
Value
;
}
obj
=
addGuardReceiverPolymorphic
(
obj
receivers
)
;
if
(
!
obj
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MInstruction
*
holderDef
=
constant
(
ObjectValue
(
*
holder
)
)
;
Shape
*
holderShape
=
holder
-
>
as
<
NativeObject
>
(
)
.
shape
(
)
;
holderDef
=
addShapeGuard
(
holderDef
holderShape
)
;
Shape
*
propShape
=
holderShape
-
>
searchLinear
(
NameToId
(
name
)
)
;
MOZ_ASSERT
(
propShape
)
;
MOZ_TRY
(
loadSlot
(
holderDef
propShape
rvalType
barrier
types
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropAddCache
(
MDefinition
*
obj
PropertyName
*
name
BarrierKind
barrier
TemporaryTypeSet
*
types
)
{
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
barrier
=
BarrierKind
:
:
TypeSet
;
}
if
(
inspector
-
>
hasSeenAccessedGetter
(
pc
)
)
{
barrier
=
BarrierKind
:
:
TypeSet
;
}
if
(
barrier
!
=
BarrierKind
:
:
TypeSet
)
{
BarrierKind
protoBarrier
;
MOZ_TRY_VAR
(
protoBarrier
PropertyReadOnPrototypeNeedsTypeBarrier
(
this
obj
name
types
)
)
;
if
(
protoBarrier
!
=
BarrierKind
:
:
NoBarrier
)
{
MOZ_ASSERT
(
barrier
<
=
protoBarrier
)
;
barrier
=
protoBarrier
;
}
}
if
(
barrier
!
=
BarrierKind
:
:
TypeSet
&
&
!
types
-
>
unknown
(
)
)
{
MOZ_ASSERT
(
obj
-
>
resultTypeSet
(
)
)
;
switch
(
obj
-
>
resultTypeSet
(
)
-
>
forAllClasses
(
constraints
(
)
IsTypedObjectClass
)
)
{
case
TemporaryTypeSet
:
:
ForAllResult
:
:
ALL_FALSE
:
case
TemporaryTypeSet
:
:
ForAllResult
:
:
EMPTY
:
break
;
case
TemporaryTypeSet
:
:
ForAllResult
:
:
ALL_TRUE
:
case
TemporaryTypeSet
:
:
ForAllResult
:
:
MIXED
:
barrier
=
BarrierKind
:
:
TypeSet
;
break
;
}
}
MConstant
*
id
=
constant
(
StringValue
(
name
)
)
;
MGetPropertyCache
*
load
=
MGetPropertyCache
:
:
New
(
alloc
(
)
obj
id
barrier
=
=
BarrierKind
:
:
TypeSet
)
;
if
(
obj
-
>
type
(
)
=
=
MIRType
:
:
Object
&
&
!
invalidatedIdempotentCache
(
)
)
{
if
(
PropertyReadIsIdempotent
(
constraints
(
)
obj
name
)
)
{
load
-
>
setIdempotent
(
)
;
}
}
if
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
CallProp
&
&
load
-
>
idempotent
(
)
)
{
MOZ_TRY
(
annotateGetPropertyCache
(
obj
name
load
obj
-
>
resultTypeSet
(
)
types
)
)
;
}
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
if
(
load
-
>
isEffectful
(
)
)
{
MOZ_TRY
(
resumeAfter
(
load
)
)
;
}
MIRType
rvalType
=
types
-
>
getKnownMIRType
(
)
;
if
(
barrier
!
=
BarrierKind
:
:
NoBarrier
)
{
rvalType
=
MIRType
:
:
Value
;
}
else
{
load
-
>
setResultTypeSet
(
types
)
;
if
(
IsNullOrUndefined
(
rvalType
)
)
{
rvalType
=
MIRType
:
:
Value
;
}
}
load
-
>
setResultType
(
rvalType
)
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
CallProp
|
|
!
IsNullOrUndefined
(
obj
-
>
type
(
)
)
)
{
MOZ_TRY
(
pushTypeBarrier
(
load
types
barrier
)
)
;
}
return
Ok
(
)
;
}
MDefinition
*
IonBuilder
:
:
tryInnerizeWindow
(
MDefinition
*
obj
)
{
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
obj
;
}
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
)
{
return
obj
;
}
JSObject
*
singleton
=
types
-
>
maybeSingleton
(
)
;
if
(
!
singleton
)
{
return
obj
;
}
if
(
!
IsWindowProxyForScriptGlobal
(
script
(
)
singleton
)
)
{
return
obj
;
}
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
singleton
)
;
if
(
key
-
>
hasFlags
(
constraints
(
)
OBJECT_FLAG_UNKNOWN_PROPERTIES
)
)
{
return
obj
;
}
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
return
constant
(
ObjectValue
(
script
(
)
-
>
global
(
)
)
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
getPropTryInnerize
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
types
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
MDefinition
*
inner
=
tryInnerizeWindow
(
obj
)
;
if
(
inner
=
=
obj
)
{
return
Ok
(
)
;
}
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
getPropTryConstant
(
emitted
inner
NameToId
(
name
)
types
)
)
;
if
(
*
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getStaticName
(
emitted
&
script
(
)
-
>
global
(
)
name
)
)
;
if
(
*
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
getPropTryCommonGetter
(
emitted
inner
NameToId
(
name
)
types
true
)
)
;
if
(
*
emitted
)
{
return
Ok
(
)
;
}
}
BarrierKind
barrier
=
PropertyReadNeedsTypeBarrier
(
analysisContext
alloc
(
)
constraints
(
)
inner
name
types
)
;
MOZ_TRY
(
getPropAddCache
(
inner
name
barrier
types
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setprop
(
PropertyName
*
name
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
emitted
=
false
;
if
(
info
(
)
.
isAnalysis
(
)
|
|
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
bool
strict
=
IsStrictSetPC
(
pc
)
;
MInstruction
*
ins
=
MCallSetProperty
:
:
New
(
alloc
(
)
obj
value
name
strict
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
return
resumeAfter
(
ins
)
;
}
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
setPropTryCommonSetter
(
&
emitted
obj
name
value
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
bool
barrier
=
PropertyWriteNeedsTypeBarrier
(
alloc
(
)
constraints
(
)
current
&
obj
name
&
value
true
)
;
if
(
!
forceInlineCaches
(
)
)
{
MOZ_TRY
(
setPropTryDefiniteSlot
(
&
emitted
obj
name
value
barrier
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
setPropTryInlineAccess
(
&
emitted
obj
name
value
barrier
objTypes
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MOZ_TRY
(
setPropTryCache
(
&
emitted
obj
name
value
barrier
)
)
;
MOZ_ASSERT
(
emitted
=
=
true
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setPropTryCommonSetter
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
MDefinition
*
value
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
TemporaryTypeSet
*
objTypes
=
obj
-
>
resultTypeSet
(
)
;
JSFunction
*
commonSetter
=
nullptr
;
MDefinition
*
guard
=
nullptr
;
{
Shape
*
lastProperty
=
nullptr
;
JSObject
*
foundProto
=
nullptr
;
bool
isOwnProperty
;
BaselineInspector
:
:
ReceiverVector
receivers
(
alloc
(
)
)
;
if
(
inspector
-
>
commonSetPropFunction
(
pc
&
foundProto
&
lastProperty
&
commonSetter
&
isOwnProperty
receivers
)
)
{
bool
canUseTIForSetter
=
false
;
if
(
!
isOwnProperty
)
{
MOZ_TRY_VAR
(
canUseTIForSetter
testCommonGetterSetter
(
objTypes
NameToId
(
name
)
false
commonSetter
&
guard
)
)
;
}
if
(
!
canUseTIForSetter
)
{
obj
=
addShapeGuardsForGetterSetter
(
obj
foundProto
lastProperty
receivers
isOwnProperty
)
;
if
(
!
obj
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
}
else
if
(
inspector
-
>
megamorphicGetterSetterFunction
(
pc
NameToId
(
name
)
false
&
commonSetter
)
)
{
bool
canUseTIForSetter
=
false
;
MOZ_TRY_VAR
(
canUseTIForSetter
testCommonGetterSetter
(
objTypes
NameToId
(
name
)
false
commonSetter
&
guard
)
)
;
if
(
!
canUseTIForSetter
)
{
return
Ok
(
)
;
}
}
else
{
return
Ok
(
)
;
}
}
MOZ_TRY
(
setPropTryCommonDOMSetter
(
emitted
obj
value
commonSetter
objTypes
)
)
;
if
(
*
emitted
)
{
return
Ok
(
)
;
}
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
MGuardObject
*
guardObj
=
MGuardObject
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
guardObj
)
;
obj
=
guardObj
;
}
if
(
!
current
-
>
ensureHasSlots
(
3
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
current
-
>
push
(
constant
(
ObjectValue
(
*
commonSetter
)
)
)
;
current
-
>
push
(
obj
)
;
current
-
>
push
(
value
)
;
CallInfo
callInfo
(
alloc
(
)
pc
false
BytecodeIsPopped
(
pc
)
)
;
if
(
!
callInfo
.
init
(
current
1
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
callInfo
.
markAsSetter
(
)
;
if
(
commonSetter
-
>
isInterpreted
(
)
)
{
InliningDecision
decision
=
makeInliningDecision
(
commonSetter
callInfo
)
;
switch
(
decision
)
{
case
InliningDecision_Error
:
return
abort
(
AbortReason
:
:
Error
)
;
case
InliningDecision_DontInline
:
case
InliningDecision_WarmUpCountTooLow
:
break
;
case
InliningDecision_Inline
:
{
InliningStatus
status
;
MOZ_TRY_VAR
(
status
inlineScriptedCall
(
callInfo
commonSetter
)
)
;
if
(
status
=
=
InliningStatus_Inlined
)
{
*
emitted
=
true
;
return
Ok
(
)
;
}
}
}
}
Maybe
<
CallTargets
>
targets
;
targets
.
emplace
(
alloc
(
)
)
;
if
(
!
targets
-
>
append
(
commonSetter
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
MCall
*
call
;
MOZ_TRY_VAR
(
call
makeCallHelper
(
targets
callInfo
)
)
;
current
-
>
push
(
value
)
;
MOZ_TRY
(
resumeAfter
(
call
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setPropTryCommonDOMSetter
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
value
JSFunction
*
setter
TemporaryTypeSet
*
objTypes
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
DOMObjectKind
objKind
=
DOMObjectKind
:
:
Unknown
;
if
(
!
objTypes
|
|
!
objTypes
-
>
isDOMClass
(
constraints
(
)
&
objKind
)
)
{
return
Ok
(
)
;
}
bool
isDOM
=
false
;
MOZ_TRY_VAR
(
isDOM
testShouldDOMCall
(
objTypes
setter
JSJitInfo
:
:
Setter
)
)
;
if
(
!
isDOM
)
{
return
Ok
(
)
;
}
MOZ_ASSERT
(
setter
-
>
jitInfo
(
)
-
>
type
(
)
=
=
JSJitInfo
:
:
Setter
)
;
MSetDOMProperty
*
set
=
MSetDOMProperty
:
:
New
(
alloc
(
)
setter
-
>
jitInfo
(
)
-
>
setter
objKind
setter
-
>
realm
(
)
obj
value
)
;
current
-
>
add
(
set
)
;
current
-
>
push
(
value
)
;
MOZ_TRY
(
resumeAfter
(
set
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setPropTryDefiniteSlot
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
MDefinition
*
value
bool
barrier
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
barrier
)
{
return
Ok
(
)
;
}
uint32_t
nfixed
;
uint32_t
slot
=
getDefiniteSlot
(
obj
-
>
resultTypeSet
(
)
NameToId
(
name
)
&
nfixed
)
;
if
(
slot
=
=
UINT32_MAX
)
{
return
Ok
(
)
;
}
bool
writeBarrier
=
false
;
for
(
size_t
i
=
0
;
i
<
obj
-
>
resultTypeSet
(
)
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
obj
-
>
resultTypeSet
(
)
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
HeapTypeSetKey
property
=
key
-
>
property
(
NameToId
(
name
)
)
;
if
(
property
.
nonWritable
(
constraints
(
)
)
)
{
return
Ok
(
)
;
}
writeBarrier
|
=
property
.
needsBarrier
(
constraints
(
)
)
;
}
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
MInstruction
*
store
;
if
(
slot
<
nfixed
)
{
store
=
MStoreFixedSlot
:
:
New
(
alloc
(
)
obj
slot
value
)
;
if
(
writeBarrier
)
{
store
-
>
toStoreFixedSlot
(
)
-
>
setNeedsBarrier
(
)
;
}
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
store
=
MStoreDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
-
nfixed
value
)
;
if
(
writeBarrier
)
{
store
-
>
toStoreDynamicSlot
(
)
-
>
setNeedsBarrier
(
)
;
}
}
current
-
>
add
(
store
)
;
current
-
>
push
(
value
)
;
MOZ_TRY
(
resumeAfter
(
store
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setPropTryInlineAccess
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
MDefinition
*
value
bool
barrier
TemporaryTypeSet
*
objTypes
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
barrier
)
{
return
Ok
(
)
;
}
BaselineInspector
:
:
ReceiverVector
receivers
(
alloc
(
)
)
;
if
(
!
inspector
-
>
maybeInfoForPropertyOp
(
pc
receivers
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
canInlinePropertyOpShapes
(
receivers
)
)
{
return
Ok
(
)
;
}
if
(
receivers
.
length
(
)
=
=
1
)
{
if
(
!
receivers
[
0
]
.
getGroup
(
)
)
{
spew
(
"
Inlining
monomorphic
native
SETPROP
"
)
;
obj
=
addShapeGuard
(
obj
receivers
[
0
]
.
getShape
(
)
)
;
Shape
*
shape
=
receivers
[
0
]
.
getShape
(
)
-
>
searchLinear
(
NameToId
(
name
)
)
;
MOZ_ASSERT
(
shape
)
;
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
bool
needsPreBarrier
=
objTypes
-
>
propertyNeedsBarrier
(
constraints
(
)
NameToId
(
name
)
)
;
MOZ_TRY
(
storeSlot
(
obj
shape
value
needsPreBarrier
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
}
MOZ_ASSERT
(
receivers
.
length
(
)
>
1
)
;
spew
(
"
Inlining
polymorphic
SETPROP
"
)
;
if
(
Shape
*
propShape
=
PropertyShapesHaveSameSlot
(
receivers
NameToId
(
name
)
)
)
{
obj
=
addGuardReceiverPolymorphic
(
obj
receivers
)
;
if
(
!
obj
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
bool
needsPreBarrier
=
objTypes
-
>
propertyNeedsBarrier
(
constraints
(
)
NameToId
(
name
)
)
;
MOZ_TRY
(
storeSlot
(
obj
propShape
value
needsPreBarrier
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
if
(
needsPostBarrier
(
value
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
value
)
)
;
}
MSetPropertyPolymorphic
*
ins
=
MSetPropertyPolymorphic
:
:
New
(
alloc
(
)
obj
value
name
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
for
(
size_t
i
=
0
;
i
<
receivers
.
length
(
)
;
i
+
+
)
{
Shape
*
propShape
=
nullptr
;
if
(
receivers
[
i
]
.
getShape
(
)
)
{
propShape
=
receivers
[
i
]
.
getShape
(
)
-
>
searchLinear
(
NameToId
(
name
)
)
;
MOZ_ASSERT
(
propShape
)
;
}
if
(
!
ins
-
>
addReceiver
(
receivers
[
i
]
propShape
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
}
if
(
objTypes
-
>
propertyNeedsBarrier
(
constraints
(
)
NameToId
(
name
)
)
)
{
ins
-
>
setNeedsBarrier
(
)
;
}
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
setPropTryCache
(
bool
*
emitted
MDefinition
*
obj
PropertyName
*
name
MDefinition
*
value
bool
barrier
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
bool
strict
=
IsStrictSetPC
(
pc
)
;
MConstant
*
id
=
constant
(
StringValue
(
name
)
)
;
MSetPropertyCache
*
ins
=
MSetPropertyCache
:
:
New
(
alloc
(
)
obj
id
value
strict
needsPostBarrier
(
value
)
barrier
false
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
value
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_delprop
(
PropertyName
*
name
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
strict
=
JSOp
(
*
pc
)
=
=
JSOp
:
:
StrictDelProp
;
MInstruction
*
ins
=
MDeleteProperty
:
:
New
(
alloc
(
)
obj
name
strict
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_delelem
(
)
{
MDefinition
*
index
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
strict
=
JSOp
(
*
pc
)
=
=
JSOp
:
:
StrictDelElem
;
MDeleteElement
*
ins
=
MDeleteElement
:
:
New
(
alloc
(
)
obj
index
strict
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_regexp
(
RegExpObject
*
reobj
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
reobj
)
)
;
bool
hasShared
=
reobj
-
>
hasShared
(
)
;
MRegExp
*
regexp
=
MRegExp
:
:
New
(
alloc
(
)
constraints
(
)
reobj
hasShared
)
;
current
-
>
add
(
regexp
)
;
current
-
>
push
(
regexp
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_object
(
JSObject
*
obj
)
{
pushConstant
(
ObjectValue
(
*
obj
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_classconstructor
(
)
{
MClassConstructor
*
constructor
=
MClassConstructor
:
:
New
(
alloc
(
)
pc
)
;
current
-
>
add
(
constructor
)
;
current
-
>
push
(
constructor
)
;
return
resumeAfter
(
constructor
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_derivedclassconstructor
(
)
{
MDefinition
*
prototype
=
current
-
>
pop
(
)
;
auto
*
constructor
=
MDerivedClassConstructor
:
:
New
(
alloc
(
)
prototype
pc
)
;
current
-
>
add
(
constructor
)
;
current
-
>
push
(
constructor
)
;
return
resumeAfter
(
constructor
)
;
}
static
LambdaFunctionInfo
LambdaInfoFromFunction
(
JSFunction
*
fun
)
{
return
LambdaFunctionInfo
(
fun
fun
-
>
baseScript
(
)
fun
-
>
flags
(
)
fun
-
>
nargs
(
)
fun
-
>
isSingleton
(
)
ObjectGroup
:
:
useSingletonForClone
(
fun
)
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_lambda
(
JSFunction
*
fun
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isArrow
(
)
)
;
if
(
IsAsmJSModule
(
fun
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
Lambda
is
an
asm
.
js
module
function
"
)
;
}
MConstant
*
cst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
fun
)
;
current
-
>
add
(
cst
)
;
auto
*
ins
=
MLambda
:
:
New
(
alloc
(
)
constraints
(
)
current
-
>
environmentChain
(
)
cst
LambdaInfoFromFunction
(
fun
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_lambda_arrow
(
JSFunction
*
fun
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MOZ_ASSERT
(
fun
-
>
isArrow
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isNative
(
)
)
;
MDefinition
*
newTargetDef
=
current
-
>
pop
(
)
;
MConstant
*
cst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
fun
)
;
current
-
>
add
(
cst
)
;
auto
*
ins
=
MLambdaArrow
:
:
New
(
alloc
(
)
constraints
(
)
current
-
>
environmentChain
(
)
newTargetDef
cst
LambdaInfoFromFunction
(
fun
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_funwithproto
(
JSFunction
*
fun
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isArrow
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isNative
(
)
)
;
MDefinition
*
proto
=
current
-
>
pop
(
)
;
MConstant
*
cst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
fun
)
;
current
-
>
add
(
cst
)
;
auto
*
ins
=
MFunctionWithProto
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
proto
cst
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setfunname
(
uint8_t
prefixKind
)
{
MDefinition
*
name
=
current
-
>
pop
(
)
;
MDefinition
*
fun
=
current
-
>
pop
(
)
;
MOZ_ASSERT
(
fun
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MSetFunName
*
ins
=
MSetFunName
:
:
New
(
alloc
(
)
fun
name
prefixKind
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
fun
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_pushlexicalenv
(
GCThingIndex
index
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
LexicalScope
*
scope
=
&
script
(
)
-
>
getScope
(
index
)
-
>
as
<
LexicalScope
>
(
)
;
MNewLexicalEnvironmentObject
*
ins
=
MNewLexicalEnvironmentObject
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
scope
)
;
current
-
>
add
(
ins
)
;
current
-
>
setEnvironmentChain
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_copylexicalenv
(
bool
copySlots
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MCopyLexicalEnvironmentObject
*
ins
=
MCopyLexicalEnvironmentObject
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
copySlots
)
;
current
-
>
add
(
ins
)
;
current
-
>
setEnvironmentChain
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getarg
(
uint32_t
arg
)
{
if
(
info
(
)
.
argsObjAliasesFormals
(
)
)
{
auto
*
getArg
=
MGetArgumentsObjectArg
:
:
New
(
alloc
(
)
current
-
>
argumentsObject
(
)
arg
)
;
current
-
>
add
(
getArg
)
;
current
-
>
push
(
getArg
)
;
}
else
{
current
-
>
pushArg
(
arg
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setarg
(
uint32_t
arg
)
{
MOZ_ASSERT
(
script
(
)
-
>
jitScript
(
)
-
>
modifiesArguments
(
)
)
;
MDefinition
*
val
=
current
-
>
peek
(
-
1
)
;
if
(
!
info
(
)
.
argumentsAliasesFormals
(
)
)
{
MOZ_ASSERT
(
!
info
(
)
.
argsObjAliasesFormals
(
)
)
;
MOZ_ASSERT_IF
(
!
info
(
)
.
hasArguments
(
)
!
info
(
)
.
needsArgsObj
(
)
)
;
MOZ_ASSERT_IF
(
info
(
)
.
hasArguments
(
)
!
info
(
)
.
hasMappedArgsObj
(
)
)
;
current
-
>
setArg
(
arg
)
;
return
Ok
(
)
;
}
MOZ_ASSERT
(
info
(
)
.
hasArguments
(
)
&
&
info
(
)
.
hasMappedArgsObj
(
)
"
arguments
aliases
formals
when
an
arguments
binding
is
present
"
"
and
the
arguments
object
is
mapped
"
)
;
MOZ_ASSERT_IF
(
info
(
)
.
analysisMode
(
)
=
=
Analysis_ArgumentsUsage
info
(
)
.
needsArgsObj
(
)
)
;
MOZ_ASSERT
(
info
(
)
.
needsArgsObj
(
)
"
unexpected
JSOp
:
:
SetArg
with
lazy
arguments
"
)
;
MOZ_ASSERT
(
info
(
)
.
argsObjAliasesFormals
(
)
"
argsObjAliasesFormals
(
)
is
true
iff
a
mapped
arguments
object
is
used
"
)
;
if
(
needsPostBarrier
(
val
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
current
-
>
argumentsObject
(
)
val
)
)
;
}
auto
*
ins
=
MSetArgumentsObjectArg
:
:
New
(
alloc
(
)
current
-
>
argumentsObject
(
)
arg
val
)
;
current
-
>
add
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_defvar
(
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
DefVar
)
;
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefVar
*
defvar
=
MDefVar
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
)
;
current
-
>
add
(
defvar
)
;
return
resumeAfter
(
defvar
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_deflexical
(
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
DefLet
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
DefConst
)
;
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
MDefLexical
*
defLexical
=
MDefLexical
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
defLexical
)
;
return
resumeAfter
(
defLexical
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_deffun
(
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefFun
*
deffun
=
MDefFun
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
current
-
>
environmentChain
(
)
)
;
current
-
>
add
(
deffun
)
;
return
resumeAfter
(
deffun
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkGlobalOrEvalDecl
(
)
{
MOZ_ASSERT
(
!
script
(
)
-
>
isForEval
(
)
"
Eval
scripts
not
supported
"
)
;
auto
*
redeclCheck
=
MGlobalNameConflictsCheck
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
redeclCheck
)
;
return
resumeAfter
(
redeclCheck
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_throwsetconst
(
)
{
MInstruction
*
lexicalError
=
MThrowRuntimeLexicalError
:
:
New
(
alloc
(
)
JSMSG_BAD_CONST_ASSIGN
)
;
current
-
>
add
(
lexicalError
)
;
MOZ_TRY
(
resumeAfter
(
lexicalError
)
)
;
current
-
>
end
(
MUnreachable
:
:
New
(
alloc
(
)
)
)
;
setTerminatedBlock
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checklexical
(
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
CheckLexical
|
|
op
=
=
JSOp
:
:
CheckAliasedLexical
)
;
MDefinition
*
val
=
current
-
>
peek
(
-
1
)
;
MDefinition
*
lexical
;
MOZ_TRY_VAR
(
lexical
addLexicalCheck
(
val
)
)
;
current
-
>
pop
(
)
;
current
-
>
push
(
lexical
)
;
if
(
op
=
=
JSOp
:
:
CheckLexical
)
{
uint32_t
slot
=
info
(
)
.
localSlot
(
GET_LOCALNO
(
pc
)
)
;
current
-
>
setSlot
(
slot
lexical
)
;
}
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_functionthis
(
)
{
MOZ_ASSERT
(
info
(
)
.
funMaybeLazy
(
)
)
;
MOZ_ASSERT
(
!
info
(
)
.
funMaybeLazy
(
)
-
>
isArrow
(
)
)
;
if
(
script
(
)
-
>
strict
(
)
)
{
current
-
>
pushSlot
(
info
(
)
.
thisSlot
(
)
)
;
return
Ok
(
)
;
}
if
(
thisTypes
&
&
(
thisTypes
-
>
getKnownMIRType
(
)
=
=
MIRType
:
:
Object
|
|
(
thisTypes
-
>
empty
(
)
&
&
baselineFrame_
&
&
baselineFrame_
-
>
thisType
.
isSomeObject
(
)
)
)
)
{
current
-
>
pushSlot
(
info
(
)
.
thisSlot
(
)
)
;
return
Ok
(
)
;
}
if
(
info
(
)
.
isAnalysis
(
)
)
{
current
-
>
pushSlot
(
info
(
)
.
thisSlot
(
)
)
;
return
Ok
(
)
;
}
MDefinition
*
def
=
current
-
>
getSlot
(
info
(
)
.
thisSlot
(
)
)
;
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
current
-
>
push
(
def
)
;
return
Ok
(
)
;
}
if
(
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
JSOp
:
:
FunctionThis
would
need
non
-
syntactic
global
"
)
;
}
LexicalEnvironmentObject
*
globalLexical
=
&
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
;
JSObject
*
globalThis
=
globalLexical
-
>
thisObject
(
)
;
if
(
IsNullOrUndefined
(
def
-
>
type
(
)
)
)
{
pushConstant
(
ObjectValue
(
*
globalThis
)
)
;
return
Ok
(
)
;
}
MBoxNonStrictThis
*
thisObj
=
MBoxNonStrictThis
:
:
New
(
alloc
(
)
def
globalThis
)
;
current
-
>
add
(
thisObj
)
;
current
-
>
push
(
thisObj
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_globalthis
(
)
{
if
(
script
(
)
-
>
hasNonSyntacticScope
(
)
)
{
return
abort
(
AbortReason
:
:
Disable
"
JSOp
:
:
GlobalThis
in
script
with
non
-
syntactic
scope
"
)
;
}
LexicalEnvironmentObject
*
globalLexical
=
&
script
(
)
-
>
global
(
)
.
lexicalEnvironment
(
)
;
pushConstant
(
ObjectValue
(
*
globalLexical
-
>
thisObject
(
)
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_typeof
(
)
{
MDefinition
*
input
=
current
-
>
pop
(
)
;
MTypeOf
*
ins
=
MTypeOf
:
:
New
(
alloc
(
)
input
)
;
ins
-
>
cacheInputMaybeCallableOrEmulatesUndefined
(
constraints
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_toasynciter
(
)
{
MDefinition
*
nextMethod
=
current
-
>
pop
(
)
;
MDefinition
*
iterator
=
current
-
>
pop
(
)
;
MOZ_ASSERT
(
iterator
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
MToAsyncIter
*
ins
=
MToAsyncIter
:
:
New
(
alloc
(
)
iterator
nextMethod
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_topropertykey
(
)
{
MIRType
type
=
current
-
>
peek
(
-
1
)
-
>
type
(
)
;
if
(
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
String
|
|
type
=
=
MIRType
:
:
Symbol
)
{
return
Ok
(
)
;
}
MDefinition
*
index
=
current
-
>
pop
(
)
;
auto
*
ins
=
MToPropertyKeyCache
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_iter
(
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MGetIteratorCache
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_itermore
(
)
{
MDefinition
*
iter
=
current
-
>
peek
(
-
1
)
;
MInstruction
*
ins
=
MIteratorMore
:
:
New
(
alloc
(
)
iter
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_isnoiter
(
)
{
MDefinition
*
def
=
current
-
>
peek
(
-
1
)
;
MOZ_ASSERT
(
def
-
>
isIteratorMore
(
)
)
;
MInstruction
*
ins
=
MIsNoIter
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_iterend
(
)
{
current
-
>
pop
(
)
;
MDefinition
*
iter
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MIteratorEnd
:
:
New
(
alloc
(
)
iter
)
;
current
-
>
add
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_iternext
(
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
MOZ_ASSERT
(
def
-
>
type
(
)
=
=
MIRType
:
:
Value
)
;
MInstruction
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
def
MIRType
:
:
String
MUnbox
:
:
Infallible
)
;
current
-
>
add
(
unbox
)
;
current
-
>
push
(
unbox
)
;
return
Ok
(
)
;
}
MDefinition
*
IonBuilder
:
:
walkEnvironmentChain
(
unsigned
hops
)
{
MDefinition
*
env
=
current
-
>
getSlot
(
info
(
)
.
environmentChainSlot
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
hops
;
i
+
+
)
{
MInstruction
*
ins
=
MEnclosingEnvironment
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
ins
)
;
env
=
ins
;
}
return
env
;
}
MDefinition
*
IonBuilder
:
:
getAliasedVar
(
EnvironmentCoordinate
ec
)
{
MDefinition
*
obj
=
walkEnvironmentChain
(
ec
.
hops
(
)
)
;
MInstruction
*
load
;
if
(
EnvironmentObject
:
:
nonExtensibleIsFixedSlot
(
ec
)
)
{
load
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
obj
ec
.
slot
(
)
)
;
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
uint32_t
slot
=
EnvironmentObject
:
:
nonExtensibleDynamicSlotIndex
(
ec
)
;
load
=
MLoadDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
)
;
}
current
-
>
add
(
load
)
;
return
load
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_getaliasedvar
(
EnvironmentCoordinate
ec
)
{
MDefinition
*
load
=
getAliasedVar
(
ec
)
;
current
-
>
push
(
load
)
;
TemporaryTypeSet
*
types
=
bytecodeTypes
(
pc
)
;
return
pushTypeBarrier
(
load
types
BarrierKind
:
:
TypeSet
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_setaliasedvar
(
EnvironmentCoordinate
ec
)
{
MDefinition
*
rval
=
current
-
>
peek
(
-
1
)
;
MDefinition
*
obj
=
walkEnvironmentChain
(
ec
.
hops
(
)
)
;
if
(
needsPostBarrier
(
rval
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
rval
)
)
;
}
MInstruction
*
store
;
if
(
EnvironmentObject
:
:
nonExtensibleIsFixedSlot
(
ec
)
)
{
store
=
MStoreFixedSlot
:
:
NewBarriered
(
alloc
(
)
obj
ec
.
slot
(
)
rval
)
;
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
uint32_t
slot
=
EnvironmentObject
:
:
nonExtensibleDynamicSlotIndex
(
ec
)
;
store
=
MStoreDynamicSlot
:
:
NewBarriered
(
alloc
(
)
slots
slot
rval
)
;
}
current
-
>
add
(
store
)
;
return
resumeAfter
(
store
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_in
(
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
if
(
!
forceInlineCaches
(
)
)
{
bool
emitted
=
false
;
MOZ_TRY
(
inTryDense
(
&
emitted
obj
id
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
hasTryNotDefined
(
&
emitted
obj
id
false
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
hasTryDefiniteSlotOrUnboxed
(
&
emitted
obj
id
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MInCache
*
ins
=
MInCache
:
:
New
(
alloc
(
)
id
obj
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
inTryDense
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
id
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
shouldAbortOnPreliminaryGroups
(
obj
)
)
{
return
Ok
(
)
;
}
if
(
!
ElementAccessIsDenseNative
(
constraints
(
)
obj
id
)
)
{
return
Ok
(
)
;
}
bool
hasExtraIndexedProperty
;
MOZ_TRY_VAR
(
hasExtraIndexedProperty
ElementAccessHasExtraIndexedProperty
(
this
obj
)
)
;
if
(
hasExtraIndexedProperty
)
{
return
Ok
(
)
;
}
*
emitted
=
true
;
bool
needsHoleCheck
=
!
ElementAccessIsPacked
(
constraints
(
)
obj
)
;
MInstruction
*
idInt32
=
MToNumberInt32
:
:
New
(
alloc
(
)
id
)
;
current
-
>
add
(
idInt32
)
;
id
=
idInt32
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
MInstruction
*
initLength
=
initializedLength
(
elements
)
;
if
(
!
needsHoleCheck
&
&
!
failedBoundsCheck_
)
{
addBoundsCheck
(
idInt32
initLength
)
;
pushConstant
(
BooleanValue
(
true
)
)
;
return
Ok
(
)
;
}
MInArray
*
ins
=
MInArray
:
:
New
(
alloc
(
)
elements
id
initLength
obj
needsHoleCheck
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
hasTryNotDefined
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
id
bool
ownProperty
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
MConstant
*
idConst
=
id
-
>
maybeConstantValue
(
)
;
jsid
propId
;
if
(
!
idConst
|
|
!
ValueToIdPure
(
idConst
-
>
toJSValue
(
)
&
propId
)
)
{
return
Ok
(
)
;
}
if
(
propId
!
=
IdToTypeId
(
propId
)
)
{
return
Ok
(
)
;
}
bool
res
;
MOZ_TRY_VAR
(
res
testNotDefinedProperty
(
obj
propId
ownProperty
)
)
;
if
(
!
res
)
{
return
Ok
(
)
;
}
*
emitted
=
true
;
pushConstant
(
BooleanValue
(
false
)
)
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
id
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
hasTryDefiniteSlotOrUnboxed
(
bool
*
emitted
MDefinition
*
obj
MDefinition
*
id
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
obj
-
>
type
(
)
!
=
MIRType
:
:
Object
)
{
return
Ok
(
)
;
}
MConstant
*
idConst
=
id
-
>
maybeConstantValue
(
)
;
jsid
propId
;
if
(
!
idConst
|
|
!
ValueToIdPure
(
idConst
-
>
toJSValue
(
)
&
propId
)
)
{
return
Ok
(
)
;
}
if
(
propId
!
=
IdToTypeId
(
propId
)
)
{
return
Ok
(
)
;
}
uint32_t
nfixed
;
uint32_t
slot
=
getDefiniteSlot
(
obj
-
>
resultTypeSet
(
)
propId
&
nfixed
)
;
if
(
slot
=
=
UINT32_MAX
)
{
return
Ok
(
)
;
}
*
emitted
=
true
;
pushConstant
(
BooleanValue
(
true
)
)
;
obj
-
>
setImplicitlyUsedUnchecked
(
)
;
id
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_hasown
(
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
if
(
!
forceInlineCaches
(
)
)
{
bool
emitted
=
false
;
MOZ_TRY
(
hasTryNotDefined
(
&
emitted
obj
id
true
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
hasTryDefiniteSlotOrUnboxed
(
&
emitted
obj
id
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
}
MHasOwnCache
*
ins
=
MHasOwnCache
:
:
New
(
alloc
(
)
obj
id
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkprivatefield
(
)
{
MDefinition
*
id
=
current
-
>
peek
(
-
1
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
2
)
;
MCheckPrivateFieldCache
*
ins
=
MCheckPrivateFieldCache
:
:
New
(
alloc
(
)
obj
id
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_TRY
(
resumeAfter
(
ins
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
bool
>
IonBuilder
:
:
hasOnProtoChain
(
TypeSet
:
:
ObjectKey
*
key
JSObject
*
protoObject
bool
*
onProto
)
{
MOZ_ASSERT
(
protoObject
)
;
while
(
true
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
if
(
!
key
-
>
hasStableClassAndProto
(
constraints
(
)
)
|
|
!
key
-
>
clasp
(
)
-
>
isNative
(
)
)
{
return
false
;
}
JSObject
*
proto
=
checkNurseryObject
(
key
-
>
proto
(
)
.
toObjectOrNull
(
)
)
;
if
(
!
proto
)
{
*
onProto
=
false
;
return
true
;
}
if
(
proto
=
=
protoObject
)
{
*
onProto
=
true
;
return
true
;
}
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
proto
)
;
}
MOZ_CRASH
(
"
Unreachable
"
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
tryFoldInstanceOf
(
bool
*
emitted
MDefinition
*
lhs
JSObject
*
protoObject
)
{
MOZ_ASSERT
(
*
emitted
=
=
false
)
;
if
(
!
lhs
-
>
mightBeType
(
MIRType
:
:
Object
)
)
{
lhs
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
BooleanValue
(
false
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
TemporaryTypeSet
*
lhsTypes
=
lhs
-
>
resultTypeSet
(
)
;
if
(
!
lhsTypes
|
|
lhsTypes
-
>
unknownObject
(
)
)
{
return
Ok
(
)
;
}
bool
isFirst
=
true
;
bool
knownIsInstance
=
false
;
for
(
unsigned
i
=
0
;
i
<
lhsTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
lhsTypes
-
>
getObject
(
i
)
;
if
(
!
key
)
{
continue
;
}
bool
checkSucceeded
;
bool
isInstance
;
MOZ_TRY_VAR
(
checkSucceeded
hasOnProtoChain
(
key
protoObject
&
isInstance
)
)
;
if
(
!
checkSucceeded
)
{
return
Ok
(
)
;
}
if
(
isFirst
)
{
knownIsInstance
=
isInstance
;
isFirst
=
false
;
}
else
if
(
knownIsInstance
!
=
isInstance
)
{
return
Ok
(
)
;
}
}
if
(
knownIsInstance
&
&
lhsTypes
-
>
getKnownMIRType
(
)
!
=
MIRType
:
:
Object
)
{
MIsObject
*
isObject
=
MIsObject
:
:
New
(
alloc
(
)
lhs
)
;
current
-
>
add
(
isObject
)
;
current
-
>
push
(
isObject
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
lhs
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
BooleanValue
(
knownIsInstance
)
)
;
*
emitted
=
true
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_instanceof
(
)
{
MDefinition
*
rhs
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
emitted
=
false
;
do
{
TemporaryTypeSet
*
rhsTypes
=
rhs
-
>
resultTypeSet
(
)
;
JSObject
*
rhsObject
=
rhsTypes
?
rhsTypes
-
>
maybeSingleton
(
)
:
nullptr
;
if
(
!
rhsObject
|
|
!
rhsObject
-
>
is
<
JSFunction
>
(
)
|
|
rhsObject
-
>
isBoundFunction
(
)
)
{
break
;
}
if
(
rhsObject
-
>
hasUncacheableProto
(
)
|
|
!
rhsObject
-
>
hasStaticPrototype
(
)
)
{
break
;
}
Value
funProto
=
script
(
)
-
>
global
(
)
.
getPrototype
(
JSProto_Function
)
;
if
(
!
funProto
.
isObject
(
)
|
|
rhsObject
-
>
staticPrototype
(
)
!
=
&
funProto
.
toObject
(
)
)
{
break
;
}
JSFunction
*
fun
=
&
rhsObject
-
>
as
<
JSFunction
>
(
)
;
const
WellKnownSymbols
*
symbols
=
&
realm
-
>
runtime
(
)
-
>
wellKnownSymbols
(
)
;
if
(
!
js
:
:
FunctionHasDefaultHasInstance
(
fun
*
symbols
)
)
{
break
;
}
TypeSet
:
:
ObjectKey
*
rhsKey
=
TypeSet
:
:
ObjectKey
:
:
get
(
rhsObject
)
;
if
(
!
rhsKey
-
>
hasStableClassAndProto
(
constraints
(
)
)
)
{
break
;
}
if
(
rhsKey
-
>
unknownProperties
(
)
)
{
break
;
}
HeapTypeSetKey
hasInstanceObject
=
rhsKey
-
>
property
(
SYMBOL_TO_JSID
(
symbols
-
>
hasInstance
)
)
;
if
(
hasInstanceObject
.
isOwnProperty
(
constraints
(
)
)
)
{
break
;
}
HeapTypeSetKey
protoProperty
=
rhsKey
-
>
property
(
NameToId
(
names
(
)
.
prototype
)
)
;
JSObject
*
protoObject
=
protoProperty
.
singleton
(
constraints
(
)
)
;
if
(
!
protoObject
)
{
break
;
}
rhs
-
>
setImplicitlyUsedUnchecked
(
)
;
MOZ_TRY
(
tryFoldInstanceOf
(
&
emitted
obj
protoObject
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MConstant
*
protoConst
=
constant
(
ObjectValue
(
*
protoObject
)
)
;
MInstanceOf
*
ins
=
MInstanceOf
:
:
New
(
alloc
(
)
obj
protoConst
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
while
(
false
)
;
do
{
Shape
*
shape
;
uint32_t
slot
;
JSObject
*
protoObject
;
if
(
!
inspector
-
>
instanceOfData
(
pc
&
shape
&
slot
&
protoObject
)
)
{
break
;
}
rhs
=
addShapeGuard
(
rhs
shape
)
;
MOZ_ASSERT
(
shape
-
>
numFixedSlots
(
)
=
=
0
"
Must
be
a
dynamic
slot
"
)
;
MSlots
*
slots
=
MSlots
:
:
New
(
alloc
(
)
rhs
)
;
current
-
>
add
(
slots
)
;
MLoadDynamicSlot
*
prototype
=
MLoadDynamicSlot
:
:
New
(
alloc
(
)
slots
slot
)
;
current
-
>
add
(
prototype
)
;
MConstant
*
protoConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
(
)
protoObject
)
;
current
-
>
add
(
protoConst
)
;
MGuardObjectIdentity
*
guard
=
MGuardObjectIdentity
:
:
New
(
alloc
(
)
prototype
protoConst
false
)
;
current
-
>
add
(
guard
)
;
MOZ_TRY
(
tryFoldInstanceOf
(
&
emitted
obj
protoObject
)
)
;
if
(
emitted
)
{
return
Ok
(
)
;
}
MInstanceOf
*
ins
=
MInstanceOf
:
:
New
(
alloc
(
)
obj
protoConst
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
while
(
false
)
;
MInstanceOfCache
*
ins
=
MInstanceOfCache
:
:
New
(
alloc
(
)
obj
rhs
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_debugger
(
)
{
MDebugger
*
debugger
=
MDebugger
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
debugger
)
;
return
resumeAfter
(
debugger
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_implicitthis
(
PropertyName
*
name
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MImplicitThis
*
implicitThis
=
MImplicitThis
:
:
New
(
alloc
(
)
current
-
>
environmentChain
(
)
name
)
;
current
-
>
add
(
implicitThis
)
;
current
-
>
push
(
implicitThis
)
;
return
resumeAfter
(
implicitThis
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_importmeta
(
)
{
if
(
info
(
)
.
analysisMode
(
)
=
=
Analysis_ArgumentsUsage
)
{
MUnknownValue
*
unknown
=
MUnknownValue
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
unknown
)
;
current
-
>
push
(
unknown
)
;
return
Ok
(
)
;
}
ModuleObject
*
module
=
GetModuleObjectForScript
(
script
(
)
)
;
MOZ_ASSERT
(
module
)
;
MModuleMetadata
*
meta
=
MModuleMetadata
:
:
New
(
alloc
(
)
module
)
;
current
-
>
add
(
meta
)
;
current
-
>
push
(
meta
)
;
return
resumeAfter
(
meta
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_dynamic_import
(
)
{
MDefinition
*
specifier
=
current
-
>
pop
(
)
;
MDynamicImport
*
ins
=
MDynamicImport
:
:
New
(
alloc
(
)
specifier
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_instrumentation_active
(
)
{
bool
active
=
RealmInstrumentation
:
:
isActive
(
&
script
(
)
-
>
global
(
)
)
;
pushConstant
(
BooleanValue
(
active
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_instrumentation_callback
(
)
{
JSObject
*
obj
=
RealmInstrumentation
:
:
getCallback
(
&
script
(
)
-
>
global
(
)
)
;
MOZ_ASSERT
(
obj
)
;
pushConstant
(
ObjectValue
(
*
obj
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_instrumentation_scriptid
(
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
int32_t
scriptId
;
RootedScript
script
(
cx
this
-
>
script
(
)
)
;
if
(
!
RealmInstrumentation
:
:
getScriptId
(
cx
cx
-
>
global
(
)
script
&
scriptId
)
)
{
return
abort
(
AbortReason
:
:
Error
)
;
}
pushConstant
(
Int32Value
(
scriptId
)
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_objwithproto
(
)
{
auto
*
ins
=
MObjectWithProto
:
:
New
(
alloc
(
)
current
-
>
pop
(
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_builtinobject
(
)
{
auto
kind
=
BuiltinObjectKind
(
GET_UINT8
(
pc
)
)
;
if
(
JSObject
*
builtin
=
MaybeGetBuiltinObject
(
&
script
(
)
-
>
global
(
)
kind
)
)
{
pushConstant
(
ObjectValue
(
*
builtin
)
)
;
return
Ok
(
)
;
}
auto
*
ins
=
MBuiltinObject
:
:
New
(
alloc
(
)
kind
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_checkreturn
(
)
{
MOZ_ASSERT
(
!
script
(
)
-
>
noScriptRval
(
)
)
;
MDefinition
*
returnValue
=
current
-
>
getSlot
(
info
(
)
.
returnValueSlot
(
)
)
;
MDefinition
*
thisValue
=
current
-
>
pop
(
)
;
if
(
returnValue
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
thisValue
-
>
setImplicitlyUsedUnchecked
(
)
;
return
Ok
(
)
;
}
if
(
returnValue
-
>
type
(
)
=
=
MIRType
:
:
Undefined
&
&
!
thisValue
-
>
mightBeMagicType
(
)
)
{
returnValue
-
>
setImplicitlyUsedUnchecked
(
)
;
thisValue
-
>
setImplicitlyUsedUnchecked
(
)
;
current
-
>
setSlot
(
info
(
)
.
returnValueSlot
(
)
thisValue
)
;
return
Ok
(
)
;
}
auto
*
ins
=
MCheckReturn
:
:
New
(
alloc
(
)
returnValue
thisValue
)
;
current
-
>
add
(
ins
)
;
current
-
>
setSlot
(
info
(
)
.
returnValueSlot
(
)
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_superfun
(
)
{
MDefinition
*
callee
=
current
-
>
pop
(
)
;
do
{
TemporaryTypeSet
*
calleeTypes
=
callee
-
>
resultTypeSet
(
)
;
if
(
!
calleeTypes
)
{
break
;
}
TemporaryTypeSet
:
:
ObjectKey
*
calleeKey
=
calleeTypes
-
>
maybeSingleObject
(
)
;
if
(
!
calleeKey
)
{
break
;
}
JSObject
*
calleeObj
;
if
(
calleeKey
-
>
isSingleton
(
)
)
{
calleeObj
=
calleeKey
-
>
singleton
(
)
;
}
else
{
calleeObj
=
calleeKey
-
>
group
(
)
-
>
maybeInterpretedFunction
(
)
;
}
if
(
!
calleeObj
)
{
break
;
}
if
(
calleeObj
-
>
hasUncacheableProto
(
)
|
|
!
calleeObj
-
>
hasStaticPrototype
(
)
)
{
break
;
}
JSObject
*
proto
=
calleeObj
-
>
staticPrototype
(
)
;
if
(
!
proto
|
|
!
proto
-
>
isConstructor
(
)
)
{
break
;
}
if
(
!
calleeKey
-
>
hasStableClassAndProto
(
constraints
(
)
)
)
{
break
;
}
callee
-
>
setImplicitlyUsedUnchecked
(
)
;
pushConstant
(
ObjectValue
(
*
proto
)
)
;
return
Ok
(
)
;
}
while
(
false
)
;
auto
*
ins
=
MSuperFunction
:
:
New
(
alloc
(
)
callee
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
AbortReasonOr
<
Ok
>
IonBuilder
:
:
jsop_inithomeobject
(
)
{
MDefinition
*
homeObject
=
current
-
>
pop
(
)
;
MDefinition
*
function
=
current
-
>
pop
(
)
;
if
(
needsPostBarrier
(
homeObject
)
)
{
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
function
homeObject
)
)
;
}
auto
*
ins
=
MInitHomeObject
:
:
New
(
alloc
(
)
function
homeObject
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
Ok
(
)
;
}
MInstruction
*
IonBuilder
:
:
addConvertElementsToDoubles
(
MDefinition
*
elements
)
{
MInstruction
*
convert
=
MConvertElementsToDoubles
:
:
New
(
alloc
(
)
elements
)
;
current
-
>
add
(
convert
)
;
return
convert
;
}
MDefinition
*
IonBuilder
:
:
addMaybeCopyElementsForWrite
(
MDefinition
*
object
bool
checkNative
)
{
if
(
!
ElementAccessMightBeCopyOnWrite
(
constraints
(
)
object
)
)
{
return
object
;
}
MInstruction
*
copy
=
MMaybeCopyElementsForWrite
:
:
New
(
alloc
(
)
object
checkNative
)
;
current
-
>
add
(
copy
)
;
return
copy
;
}
MInstruction
*
IonBuilder
:
:
addBoundsCheck
(
MDefinition
*
index
MDefinition
*
length
)
{
MInstruction
*
check
=
MBoundsCheck
:
:
New
(
alloc
(
)
index
length
)
;
current
-
>
add
(
check
)
;
if
(
failedBoundsCheck_
)
{
check
-
>
setNotMovable
(
)
;
}
if
(
JitOptions
.
spectreIndexMasking
)
{
check
=
MSpectreMaskIndex
:
:
New
(
alloc
(
)
check
length
)
;
current
-
>
add
(
check
)
;
}
return
check
;
}
MInstruction
*
IonBuilder
:
:
addShapeGuard
(
MDefinition
*
obj
Shape
*
const
shape
)
{
MGuardShape
*
guard
=
MGuardShape
:
:
New
(
alloc
(
)
obj
shape
)
;
current
-
>
add
(
guard
)
;
if
(
failedShapeGuard_
)
{
guard
-
>
setNotMovable
(
)
;
}
return
guard
;
}
MInstruction
*
IonBuilder
:
:
addGroupGuard
(
MDefinition
*
obj
ObjectGroup
*
group
BailoutKind
bailoutKind
)
{
MGuardObjectGroup
*
guard
=
MGuardObjectGroup
:
:
New
(
alloc
(
)
obj
group
false
bailoutKind
)
;
current
-
>
add
(
guard
)
;
if
(
failedShapeGuard_
)
{
guard
-
>
setNotMovable
(
)
;
}
LifoAlloc
*
lifoAlloc
=
alloc
(
)
.
lifoAlloc
(
)
;
guard
-
>
setResultTypeSet
(
lifoAlloc
-
>
new_
<
TemporaryTypeSet
>
(
lifoAlloc
TypeSet
:
:
ObjectType
(
group
)
)
)
;
return
guard
;
}
MInstruction
*
IonBuilder
:
:
addGuardReceiverPolymorphic
(
MDefinition
*
obj
const
BaselineInspector
:
:
ReceiverVector
&
receivers
)
{
if
(
receivers
.
length
(
)
=
=
1
)
{
if
(
!
receivers
[
0
]
.
getGroup
(
)
)
{
return
addShapeGuard
(
obj
receivers
[
0
]
.
getShape
(
)
)
;
}
}
MGuardReceiverPolymorphic
*
guard
=
MGuardReceiverPolymorphic
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
guard
)
;
if
(
failedShapeGuard_
)
{
guard
-
>
setNotMovable
(
)
;
}
for
(
size_t
i
=
0
;
i
<
receivers
.
length
(
)
;
i
+
+
)
{
if
(
!
guard
-
>
addReceiver
(
receivers
[
i
]
)
)
{
return
nullptr
;
}
}
return
guard
;
}
TemporaryTypeSet
*
IonBuilder
:
:
bytecodeTypes
(
jsbytecode
*
pc
)
{
return
JitScript
:
:
BytecodeTypes
(
script
(
)
pc
bytecodeTypeMap
&
typeArrayHint
typeArray
)
;
}
void
IonBuilder
:
:
checkNurseryCell
(
gc
:
:
Cell
*
cell
)
{
if
(
cell
&
&
IsInsideNursery
(
cell
)
)
{
realm
-
>
zone
(
)
-
>
setMinorGCShouldCancelIonCompilations
(
)
;
mirGen
(
)
.
setNotSafeForMinorGC
(
)
;
}
}
JSObject
*
IonBuilder
:
:
checkNurseryObject
(
JSObject
*
obj
)
{
checkNurseryCell
(
obj
)
;
return
obj
;
}
MConstant
*
IonBuilder
:
:
constant
(
const
Value
&
v
)
{
MOZ_ASSERT
(
!
v
.
isString
(
)
|
|
v
.
toString
(
)
-
>
isAtom
(
)
"
Handle
non
-
atomized
strings
outside
IonBuilder
.
"
)
;
if
(
v
.
isGCThing
(
)
)
{
checkNurseryCell
(
v
.
toGCThing
(
)
)
;
}
MConstant
*
c
=
MConstant
:
:
New
(
alloc
(
)
v
constraints
(
)
)
;
current
-
>
add
(
c
)
;
return
c
;
}
MConstant
*
IonBuilder
:
:
constantInt
(
int32_t
i
)
{
return
constant
(
Int32Value
(
i
)
)
;
}
MInstruction
*
IonBuilder
:
:
initializedLength
(
MDefinition
*
elements
)
{
MInstruction
*
res
=
MInitializedLength
:
:
New
(
alloc
(
)
elements
)
;
current
-
>
add
(
res
)
;
return
res
;
}
MInstruction
*
IonBuilder
:
:
setInitializedLength
(
MDefinition
*
obj
size_t
count
)
{
MOZ_ASSERT
(
count
)
;
MInstruction
*
elements
=
MElements
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
elements
)
;
MInstruction
*
res
=
MSetInitializedLength
:
:
New
(
alloc
(
)
elements
constant
(
Int32Value
(
count
-
1
)
)
)
;
current
-
>
add
(
res
)
;
return
res
;
}
MDefinition
*
IonBuilder
:
:
getCallee
(
)
{
if
(
inliningDepth_
=
=
0
)
{
MInstruction
*
callee
=
MCallee
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
callee
)
;
return
callee
;
}
return
inlineCallInfo_
-
>
callee
(
)
;
}
void
IonBuilder
:
:
addAbortedPreliminaryGroup
(
ObjectGroup
*
group
)
{
for
(
size_t
i
=
0
;
i
<
abortedPreliminaryGroups_
.
length
(
)
;
i
+
+
)
{
if
(
group
=
=
abortedPreliminaryGroups_
[
i
]
)
{
return
;
}
}
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
abortedPreliminaryGroups_
.
append
(
group
)
)
{
oomUnsafe
.
crash
(
"
addAbortedPreliminaryGroup
"
)
;
}
}
AbortReasonOr
<
MDefinition
*
>
IonBuilder
:
:
addLexicalCheck
(
MDefinition
*
input
)
{
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
CheckLexical
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
CheckAliasedLexical
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
GetImport
)
;
if
(
input
-
>
type
(
)
=
=
MIRType
:
:
MagicUninitializedLexical
)
{
input
-
>
setImplicitlyUsedUnchecked
(
)
;
MInstruction
*
lexicalCheck
=
MThrowRuntimeLexicalError
:
:
New
(
alloc
(
)
JSMSG_UNINITIALIZED_LEXICAL
)
;
current
-
>
add
(
lexicalCheck
)
;
MOZ_TRY
(
resumeAfter
(
lexicalCheck
)
)
;
return
constant
(
UndefinedValue
(
)
)
;
}
if
(
input
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
MInstruction
*
lexicalCheck
=
MLexicalCheck
:
:
New
(
alloc
(
)
input
)
;
current
-
>
add
(
lexicalCheck
)
;
if
(
failedLexicalCheck_
)
{
lexicalCheck
-
>
setNotMovableUnchecked
(
)
;
}
return
lexicalCheck
;
}
input
-
>
setImplicitlyUsedUnchecked
(
)
;
return
input
;
}
MDefinition
*
IonBuilder
:
:
convertToBoolean
(
MDefinition
*
input
)
{
MNot
*
resultInverted
=
MNot
:
:
New
(
alloc
(
)
input
constraints
(
)
)
;
current
-
>
add
(
resultInverted
)
;
MNot
*
result
=
MNot
:
:
New
(
alloc
(
)
resultInverted
constraints
(
)
)
;
current
-
>
add
(
result
)
;
return
result
;
}
