#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
jit
/
AtomicOp
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
Bailouts
.
h
"
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JitScript
.
h
"
#
include
"
jit
/
MoveEmitter
.
h
"
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
#
include
"
jit
/
Simulator
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
friend
/
DOMProxy
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
ArrayBufferViewObject
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
#
include
"
jit
/
TemplateObject
-
inl
.
h
"
#
include
"
vm
/
BytecodeUtil
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
JS
:
:
GenericNaN
;
using
JS
:
:
ToInt32
;
using
mozilla
:
:
CheckedInt
;
TrampolinePtr
MacroAssembler
:
:
preBarrierTrampoline
(
MIRType
type
)
{
const
JitRuntime
*
rt
=
runtime
(
)
-
>
jitRuntime
(
)
;
return
rt
-
>
preBarrier
(
type
)
;
}
template
<
typename
S
typename
T
>
static
void
StoreToTypedFloatArray
(
MacroAssembler
&
masm
int
arrayType
const
S
&
value
const
T
&
dest
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Float32
:
masm
.
storeFloat32
(
value
dest
)
;
break
;
case
Scalar
:
:
Float64
:
masm
.
storeDouble
(
value
dest
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
void
MacroAssembler
:
:
storeToTypedFloatArray
(
Scalar
:
:
Type
arrayType
FloatRegister
value
const
BaseIndex
&
dest
)
{
StoreToTypedFloatArray
(
*
this
arrayType
value
dest
)
;
}
void
MacroAssembler
:
:
storeToTypedFloatArray
(
Scalar
:
:
Type
arrayType
FloatRegister
value
const
Address
&
dest
)
{
StoreToTypedFloatArray
(
*
this
arrayType
value
dest
)
;
}
template
<
typename
S
typename
T
>
static
void
StoreToTypedBigIntArray
(
MacroAssembler
&
masm
Scalar
:
:
Type
arrayType
const
S
&
value
const
T
&
dest
)
{
MOZ_ASSERT
(
Scalar
:
:
isBigIntType
(
arrayType
)
)
;
masm
.
store64
(
value
dest
)
;
}
void
MacroAssembler
:
:
storeToTypedBigIntArray
(
Scalar
:
:
Type
arrayType
Register64
value
const
BaseIndex
&
dest
)
{
StoreToTypedBigIntArray
(
*
this
arrayType
value
dest
)
;
}
void
MacroAssembler
:
:
storeToTypedBigIntArray
(
Scalar
:
:
Type
arrayType
Register64
value
const
Address
&
dest
)
{
StoreToTypedBigIntArray
(
*
this
arrayType
value
dest
)
;
}
void
MacroAssembler
:
:
boxUint32
(
Register
source
ValueOperand
dest
Uint32Mode
mode
Label
*
fail
)
{
switch
(
mode
)
{
case
Uint32Mode
:
:
FailOnDouble
:
{
branchTest32
(
Assembler
:
:
Signed
source
source
fail
)
;
tagValue
(
JSVAL_TYPE_INT32
source
dest
)
;
break
;
}
case
Uint32Mode
:
:
ForceDouble
:
{
ScratchDoubleScope
fpscratch
(
*
this
)
;
convertUInt32ToDouble
(
source
fpscratch
)
;
boxDouble
(
fpscratch
dest
fpscratch
)
;
break
;
}
}
}
template
<
typename
T
>
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
T
&
src
AnyRegister
dest
Register
temp
Label
*
fail
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
load8SignExtend
(
src
dest
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Uint8Clamped
:
load8ZeroExtend
(
src
dest
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int16
:
load16SignExtend
(
src
dest
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint16
:
load16ZeroExtend
(
src
dest
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int32
:
load32
(
src
dest
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint32
:
if
(
dest
.
isFloat
(
)
)
{
load32
(
src
temp
)
;
convertUInt32ToDouble
(
temp
dest
.
fpu
(
)
)
;
}
else
{
load32
(
src
dest
.
gpr
(
)
)
;
branchTest32
(
Assembler
:
:
Signed
dest
.
gpr
(
)
dest
.
gpr
(
)
fail
)
;
}
break
;
case
Scalar
:
:
Float32
:
loadFloat32
(
src
dest
.
fpu
(
)
)
;
canonicalizeFloat
(
dest
.
fpu
(
)
)
;
break
;
case
Scalar
:
:
Float64
:
loadDouble
(
src
dest
.
fpu
(
)
)
;
canonicalizeDouble
(
dest
.
fpu
(
)
)
;
break
;
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
template
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
Address
&
src
AnyRegister
dest
Register
temp
Label
*
fail
)
;
template
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
BaseIndex
&
src
AnyRegister
dest
Register
temp
Label
*
fail
)
;
template
<
typename
T
>
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
T
&
src
const
ValueOperand
&
dest
Uint32Mode
uint32Mode
Register
temp
Label
*
fail
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Uint8Clamped
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
loadFromTypedArray
(
arrayType
src
AnyRegister
(
dest
.
scratchReg
(
)
)
InvalidReg
nullptr
)
;
tagValue
(
JSVAL_TYPE_INT32
dest
.
scratchReg
(
)
dest
)
;
break
;
case
Scalar
:
:
Uint32
:
load32
(
src
temp
)
;
boxUint32
(
temp
dest
uint32Mode
fail
)
;
break
;
case
Scalar
:
:
Float32
:
{
ScratchDoubleScope
dscratch
(
*
this
)
;
FloatRegister
fscratch
=
dscratch
.
asSingle
(
)
;
loadFromTypedArray
(
arrayType
src
AnyRegister
(
fscratch
)
dest
.
scratchReg
(
)
nullptr
)
;
convertFloat32ToDouble
(
fscratch
dscratch
)
;
boxDouble
(
dscratch
dest
dscratch
)
;
break
;
}
case
Scalar
:
:
Float64
:
{
ScratchDoubleScope
fpscratch
(
*
this
)
;
loadFromTypedArray
(
arrayType
src
AnyRegister
(
fpscratch
)
dest
.
scratchReg
(
)
nullptr
)
;
boxDouble
(
fpscratch
dest
fpscratch
)
;
break
;
}
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
template
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
Address
&
src
const
ValueOperand
&
dest
Uint32Mode
uint32Mode
Register
temp
Label
*
fail
)
;
template
void
MacroAssembler
:
:
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
BaseIndex
&
src
const
ValueOperand
&
dest
Uint32Mode
uint32Mode
Register
temp
Label
*
fail
)
;
template
<
typename
T
>
void
MacroAssembler
:
:
loadFromTypedBigIntArray
(
Scalar
:
:
Type
arrayType
const
T
&
src
Register
bigInt
Register64
temp
)
{
MOZ_ASSERT
(
Scalar
:
:
isBigIntType
(
arrayType
)
)
;
load64
(
src
temp
)
;
initializeBigInt64
(
arrayType
bigInt
temp
)
;
}
template
void
MacroAssembler
:
:
loadFromTypedBigIntArray
(
Scalar
:
:
Type
arrayType
const
Address
&
src
Register
bigInt
Register64
temp
)
;
template
void
MacroAssembler
:
:
loadFromTypedBigIntArray
(
Scalar
:
:
Type
arrayType
const
BaseIndex
&
src
Register
bigInt
Register64
temp
)
;
void
MacroAssembler
:
:
checkAllocatorState
(
Label
*
fail
)
{
#
ifdef
JS_GC_PROBES
jump
(
fail
)
;
#
endif
#
ifdef
JS_GC_ZEAL
const
uint32_t
*
ptrZealModeBits
=
runtime
(
)
-
>
addressOfGCZealModeBits
(
)
;
branch32
(
Assembler
:
:
NotEqual
AbsoluteAddress
(
ptrZealModeBits
)
Imm32
(
0
)
fail
)
;
#
endif
if
(
realm
(
)
-
>
hasAllocationMetadataBuilder
(
)
)
{
jump
(
fail
)
;
}
}
bool
MacroAssembler
:
:
shouldNurseryAllocate
(
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
initialHeap
)
{
return
IsNurseryAllocable
(
allocKind
)
&
&
initialHeap
!
=
gc
:
:
TenuredHeap
;
}
void
MacroAssembler
:
:
nurseryAllocateObject
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
size_t
nDynamicSlots
Label
*
fail
const
AllocSiteInput
&
allocSite
)
{
MOZ_ASSERT
(
IsNurseryAllocable
(
allocKind
)
)
;
if
(
nDynamicSlots
>
=
Nursery
:
:
MaxNurseryBufferSize
/
sizeof
(
Value
)
)
{
jump
(
fail
)
;
return
;
}
if
(
allocSite
.
is
<
Register
>
(
)
)
{
Register
site
=
allocSite
.
as
<
Register
>
(
)
;
branchTestPtr
(
Assembler
:
:
NonZero
Address
(
site
gc
:
:
AllocSite
:
:
offsetOfScriptAndState
(
)
)
Imm32
(
gc
:
:
AllocSite
:
:
LONG_LIVED_BIT
)
fail
)
;
}
CompileZone
*
zone
=
realm
(
)
-
>
zone
(
)
;
size_t
thingSize
=
gc
:
:
Arena
:
:
thingSize
(
allocKind
)
;
size_t
totalSize
=
thingSize
;
if
(
nDynamicSlots
)
{
totalSize
+
=
ObjectSlots
:
:
allocSize
(
nDynamicSlots
)
;
}
MOZ_ASSERT
(
totalSize
<
INT32_MAX
)
;
MOZ_ASSERT
(
totalSize
%
gc
:
:
CellAlignBytes
=
=
0
)
;
bumpPointerAllocate
(
result
temp
fail
zone
zone
-
>
addressOfNurseryPosition
(
)
zone
-
>
addressOfNurseryCurrentEnd
(
)
JS
:
:
TraceKind
:
:
Object
totalSize
allocSite
)
;
if
(
nDynamicSlots
)
{
store32
(
Imm32
(
nDynamicSlots
)
Address
(
result
thingSize
+
ObjectSlots
:
:
offsetOfCapacity
(
)
)
)
;
store32
(
Imm32
(
0
)
Address
(
result
thingSize
+
ObjectSlots
:
:
offsetOfDictionarySlotSpan
(
)
)
)
;
computeEffectiveAddress
(
Address
(
result
thingSize
+
ObjectSlots
:
:
offsetOfSlots
(
)
)
temp
)
;
storePtr
(
temp
Address
(
result
NativeObject
:
:
offsetOfSlots
(
)
)
)
;
}
}
void
MacroAssembler
:
:
freeListAllocate
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
Label
*
fail
)
{
CompileZone
*
zone
=
realm
(
)
-
>
zone
(
)
;
int
thingSize
=
int
(
gc
:
:
Arena
:
:
thingSize
(
allocKind
)
)
;
Label
fallback
;
Label
success
;
gc
:
:
FreeSpan
*
*
ptrFreeList
=
zone
-
>
addressOfFreeList
(
allocKind
)
;
loadPtr
(
AbsoluteAddress
(
ptrFreeList
)
temp
)
;
load16ZeroExtend
(
Address
(
temp
js
:
:
gc
:
:
FreeSpan
:
:
offsetOfFirst
(
)
)
result
)
;
load16ZeroExtend
(
Address
(
temp
js
:
:
gc
:
:
FreeSpan
:
:
offsetOfLast
(
)
)
temp
)
;
branch32
(
Assembler
:
:
AboveOrEqual
result
temp
&
fallback
)
;
add32
(
Imm32
(
thingSize
)
result
)
;
loadPtr
(
AbsoluteAddress
(
ptrFreeList
)
temp
)
;
store16
(
result
Address
(
temp
js
:
:
gc
:
:
FreeSpan
:
:
offsetOfFirst
(
)
)
)
;
sub32
(
Imm32
(
thingSize
)
result
)
;
addPtr
(
temp
result
)
;
jump
(
&
success
)
;
bind
(
&
fallback
)
;
branchTest32
(
Assembler
:
:
Zero
result
result
fail
)
;
loadPtr
(
AbsoluteAddress
(
ptrFreeList
)
temp
)
;
addPtr
(
temp
result
)
;
Push
(
result
)
;
load32
(
Address
(
result
0
)
result
)
;
store32
(
result
Address
(
temp
js
:
:
gc
:
:
FreeSpan
:
:
offsetOfFirst
(
)
)
)
;
Pop
(
result
)
;
bind
(
&
success
)
;
if
(
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
uint32_t
*
countAddress
=
zone
-
>
addressOfTenuredAllocCount
(
)
;
movePtr
(
ImmPtr
(
countAddress
)
temp
)
;
add32
(
Imm32
(
1
)
Address
(
temp
0
)
)
;
}
}
void
MacroAssembler
:
:
callFreeStub
(
Register
slots
)
{
const
Register
regSlots
=
CallTempReg0
;
push
(
regSlots
)
;
movePtr
(
slots
regSlots
)
;
call
(
runtime
(
)
-
>
jitRuntime
(
)
-
>
freeStub
(
)
)
;
pop
(
regSlots
)
;
}
void
MacroAssembler
:
:
allocateObject
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
uint32_t
nDynamicSlots
gc
:
:
InitialHeap
initialHeap
Label
*
fail
const
AllocSiteInput
&
allocSite
)
{
MOZ_ASSERT
(
gc
:
:
IsObjectAllocKind
(
allocKind
)
)
;
checkAllocatorState
(
fail
)
;
if
(
shouldNurseryAllocate
(
allocKind
initialHeap
)
)
{
MOZ_ASSERT
(
initialHeap
=
=
gc
:
:
DefaultHeap
)
;
return
nurseryAllocateObject
(
result
temp
allocKind
nDynamicSlots
fail
allocSite
)
;
}
if
(
nDynamicSlots
)
{
jump
(
fail
)
;
return
;
}
return
freeListAllocate
(
result
temp
allocKind
fail
)
;
}
void
MacroAssembler
:
:
createGCObject
(
Register
obj
Register
temp
const
TemplateObject
&
templateObj
gc
:
:
InitialHeap
initialHeap
Label
*
fail
bool
initContents
)
{
gc
:
:
AllocKind
allocKind
=
templateObj
.
getAllocKind
(
)
;
MOZ_ASSERT
(
gc
:
:
IsObjectAllocKind
(
allocKind
)
)
;
uint32_t
nDynamicSlots
=
0
;
if
(
templateObj
.
isNativeObject
(
)
)
{
const
TemplateNativeObject
&
ntemplate
=
templateObj
.
asTemplateNativeObject
(
)
;
nDynamicSlots
=
ntemplate
.
numDynamicSlots
(
)
;
}
allocateObject
(
obj
temp
allocKind
nDynamicSlots
initialHeap
fail
)
;
initGCThing
(
obj
temp
templateObj
initContents
)
;
}
void
MacroAssembler
:
:
createPlainGCObject
(
Register
result
Register
shape
Register
temp
Register
temp2
uint32_t
numFixedSlots
uint32_t
numDynamicSlots
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
initialHeap
Label
*
fail
const
AllocSiteInput
&
allocSite
bool
initContents
)
{
MOZ_ASSERT
(
gc
:
:
IsObjectAllocKind
(
allocKind
)
)
;
MOZ_ASSERT
(
shape
!
=
temp
"
shape
can
overlap
with
temp2
but
not
temp
"
)
;
allocateObject
(
result
temp
allocKind
numDynamicSlots
initialHeap
fail
allocSite
)
;
storePtr
(
shape
Address
(
result
JSObject
:
:
offsetOfShape
(
)
)
)
;
if
(
numDynamicSlots
=
=
0
)
{
storePtr
(
ImmPtr
(
emptyObjectSlots
)
Address
(
result
NativeObject
:
:
offsetOfSlots
(
)
)
)
;
}
storePtr
(
ImmPtr
(
emptyObjectElements
)
Address
(
result
NativeObject
:
:
offsetOfElements
(
)
)
)
;
if
(
initContents
)
{
fillSlotsWithUndefined
(
Address
(
result
NativeObject
:
:
getFixedSlotOffset
(
0
)
)
temp
0
numFixedSlots
)
;
}
if
(
numDynamicSlots
>
0
)
{
loadPtr
(
Address
(
result
NativeObject
:
:
offsetOfSlots
(
)
)
temp2
)
;
fillSlotsWithUndefined
(
Address
(
temp2
0
)
temp
0
numDynamicSlots
)
;
}
}
void
MacroAssembler
:
:
createArrayWithFixedElements
(
Register
result
Register
shape
Register
temp
uint32_t
arrayLength
uint32_t
arrayCapacity
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
initialHeap
Label
*
fail
const
AllocSiteInput
&
allocSite
)
{
MOZ_ASSERT
(
gc
:
:
IsObjectAllocKind
(
allocKind
)
)
;
MOZ_ASSERT
(
shape
!
=
temp
"
shape
can
overlap
with
temp2
but
not
temp
"
)
;
MOZ_ASSERT
(
result
!
=
temp
)
;
MOZ_ASSERT
(
arrayCapacity
>
=
arrayLength
)
;
MOZ_ASSERT
(
gc
:
:
GetGCKindSlots
(
allocKind
)
>
=
arrayCapacity
+
ObjectElements
:
:
VALUES_PER_HEADER
)
;
allocateObject
(
result
temp
allocKind
0
initialHeap
fail
allocSite
)
;
storePtr
(
shape
Address
(
result
JSObject
:
:
offsetOfShape
(
)
)
)
;
storePtr
(
ImmPtr
(
emptyObjectSlots
)
Address
(
result
NativeObject
:
:
offsetOfSlots
(
)
)
)
;
computeEffectiveAddress
(
Address
(
result
NativeObject
:
:
offsetOfFixedElements
(
)
)
temp
)
;
storePtr
(
temp
Address
(
result
NativeObject
:
:
offsetOfElements
(
)
)
)
;
store32
(
Imm32
(
ObjectElements
:
:
FIXED
)
Address
(
temp
ObjectElements
:
:
offsetOfFlags
(
)
)
)
;
store32
(
Imm32
(
0
)
Address
(
temp
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
)
;
store32
(
Imm32
(
arrayCapacity
)
Address
(
temp
ObjectElements
:
:
offsetOfCapacity
(
)
)
)
;
store32
(
Imm32
(
arrayLength
)
Address
(
temp
ObjectElements
:
:
offsetOfLength
(
)
)
)
;
}
void
MacroAssembler
:
:
nurseryAllocateString
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
Label
*
fail
)
{
MOZ_ASSERT
(
IsNurseryAllocable
(
allocKind
)
)
;
CompileZone
*
zone
=
realm
(
)
-
>
zone
(
)
;
uint64_t
*
allocStrsPtr
=
&
zone
-
>
zone
(
)
-
>
nurseryAllocatedStrings
.
ref
(
)
;
inc64
(
AbsoluteAddress
(
allocStrsPtr
)
)
;
size_t
thingSize
=
gc
:
:
Arena
:
:
thingSize
(
allocKind
)
;
bumpPointerAllocate
(
result
temp
fail
zone
zone
-
>
addressOfStringNurseryPosition
(
)
zone
-
>
addressOfStringNurseryCurrentEnd
(
)
JS
:
:
TraceKind
:
:
String
thingSize
)
;
}
void
MacroAssembler
:
:
nurseryAllocateBigInt
(
Register
result
Register
temp
Label
*
fail
)
{
MOZ_ASSERT
(
IsNurseryAllocable
(
gc
:
:
AllocKind
:
:
BIGINT
)
)
;
CompileZone
*
zone
=
realm
(
)
-
>
zone
(
)
;
size_t
thingSize
=
gc
:
:
Arena
:
:
thingSize
(
gc
:
:
AllocKind
:
:
BIGINT
)
;
bumpPointerAllocate
(
result
temp
fail
zone
zone
-
>
addressOfBigIntNurseryPosition
(
)
zone
-
>
addressOfBigIntNurseryCurrentEnd
(
)
JS
:
:
TraceKind
:
:
BigInt
thingSize
)
;
}
void
MacroAssembler
:
:
bumpPointerAllocate
(
Register
result
Register
temp
Label
*
fail
CompileZone
*
zone
void
*
posAddr
const
void
*
curEndAddr
JS
:
:
TraceKind
traceKind
uint32_t
size
const
AllocSiteInput
&
allocSite
)
{
MOZ_ASSERT
(
size
>
=
gc
:
:
MinCellSize
)
;
uint32_t
totalSize
=
size
+
Nursery
:
:
nurseryCellHeaderSize
(
)
;
MOZ_ASSERT
(
totalSize
<
INT32_MAX
"
Nursery
allocation
too
large
"
)
;
MOZ_ASSERT
(
totalSize
%
gc
:
:
CellAlignBytes
=
=
0
)
;
movePtr
(
ImmPtr
(
posAddr
)
temp
)
;
loadPtr
(
Address
(
temp
0
)
result
)
;
addPtr
(
Imm32
(
totalSize
)
result
)
;
CheckedInt
<
int32_t
>
endOffset
=
(
CheckedInt
<
uintptr_t
>
(
uintptr_t
(
curEndAddr
)
)
-
CheckedInt
<
uintptr_t
>
(
uintptr_t
(
posAddr
)
)
)
.
toChecked
<
int32_t
>
(
)
;
MOZ_ASSERT
(
endOffset
.
isValid
(
)
"
Position
and
end
pointers
must
be
nearby
"
)
;
branchPtr
(
Assembler
:
:
Below
Address
(
temp
endOffset
.
value
(
)
)
result
fail
)
;
storePtr
(
result
Address
(
temp
0
)
)
;
subPtr
(
Imm32
(
size
)
result
)
;
if
(
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
uint32_t
*
countAddress
=
zone
-
>
addressOfNurseryAllocCount
(
)
;
CheckedInt
<
int32_t
>
counterOffset
=
(
CheckedInt
<
uintptr_t
>
(
uintptr_t
(
countAddress
)
)
-
CheckedInt
<
uintptr_t
>
(
uintptr_t
(
posAddr
)
)
)
.
toChecked
<
int32_t
>
(
)
;
if
(
counterOffset
.
isValid
(
)
)
{
add32
(
Imm32
(
1
)
Address
(
temp
counterOffset
.
value
(
)
)
)
;
}
else
{
movePtr
(
ImmPtr
(
countAddress
)
temp
)
;
add32
(
Imm32
(
1
)
Address
(
temp
0
)
)
;
}
}
if
(
allocSite
.
is
<
gc
:
:
CatchAllAllocSite
>
(
)
)
{
gc
:
:
CatchAllAllocSite
siteKind
=
allocSite
.
as
<
gc
:
:
CatchAllAllocSite
>
(
)
;
storePtr
(
ImmWord
(
zone
-
>
nurseryCellHeader
(
traceKind
siteKind
)
)
Address
(
result
-
js
:
:
Nursery
:
:
nurseryCellHeaderSize
(
)
)
)
;
}
else
{
Register
site
=
allocSite
.
as
<
Register
>
(
)
;
updateAllocSite
(
temp
result
zone
site
)
;
orPtr
(
Imm32
(
int32_t
(
traceKind
)
)
site
)
;
storePtr
(
site
Address
(
result
-
js
:
:
Nursery
:
:
nurseryCellHeaderSize
(
)
)
)
;
}
}
void
MacroAssembler
:
:
updateAllocSite
(
Register
temp
Register
result
CompileZone
*
zone
Register
site
)
{
Label
done
;
add32
(
Imm32
(
1
)
Address
(
site
gc
:
:
AllocSite
:
:
offsetOfNurseryAllocCount
(
)
)
)
;
branchPtr
(
Assembler
:
:
NotEqual
Address
(
site
gc
:
:
AllocSite
:
:
offsetOfNextNurseryAllocated
(
)
)
ImmPtr
(
nullptr
)
&
done
)
;
loadPtr
(
AbsoluteAddress
(
zone
-
>
addressOfNurseryAllocatedSites
(
)
)
temp
)
;
storePtr
(
temp
Address
(
site
gc
:
:
AllocSite
:
:
offsetOfNextNurseryAllocated
(
)
)
)
;
storePtr
(
site
AbsoluteAddress
(
zone
-
>
addressOfNurseryAllocatedSites
(
)
)
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
allocateString
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
{
MOZ_ASSERT
(
allocKind
=
=
gc
:
:
AllocKind
:
:
STRING
|
|
allocKind
=
=
gc
:
:
AllocKind
:
:
FAT_INLINE_STRING
)
;
checkAllocatorState
(
fail
)
;
if
(
shouldNurseryAllocate
(
allocKind
initialHeap
)
)
{
MOZ_ASSERT
(
initialHeap
=
=
gc
:
:
DefaultHeap
)
;
return
nurseryAllocateString
(
result
temp
allocKind
fail
)
;
}
freeListAllocate
(
result
temp
allocKind
fail
)
;
}
void
MacroAssembler
:
:
newGCString
(
Register
result
Register
temp
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
{
allocateString
(
result
temp
js
:
:
gc
:
:
AllocKind
:
:
STRING
initialHeap
fail
)
;
}
void
MacroAssembler
:
:
newGCFatInlineString
(
Register
result
Register
temp
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
{
allocateString
(
result
temp
js
:
:
gc
:
:
AllocKind
:
:
FAT_INLINE_STRING
initialHeap
fail
)
;
}
void
MacroAssembler
:
:
newGCBigInt
(
Register
result
Register
temp
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
{
checkAllocatorState
(
fail
)
;
if
(
shouldNurseryAllocate
(
gc
:
:
AllocKind
:
:
BIGINT
initialHeap
)
)
{
MOZ_ASSERT
(
initialHeap
=
=
gc
:
:
DefaultHeap
)
;
return
nurseryAllocateBigInt
(
result
temp
fail
)
;
}
freeListAllocate
(
result
temp
gc
:
:
AllocKind
:
:
BIGINT
fail
)
;
}
void
MacroAssembler
:
:
copySlotsFromTemplate
(
Register
obj
const
TemplateNativeObject
&
templateObj
uint32_t
start
uint32_t
end
)
{
uint32_t
nfixed
=
std
:
:
min
(
templateObj
.
numFixedSlots
(
)
end
)
;
for
(
unsigned
i
=
start
;
i
<
nfixed
;
i
+
+
)
{
Value
v
;
if
(
templateObj
.
isRegExpObject
(
)
&
&
i
=
=
RegExpObject
:
:
lastIndexSlot
(
)
)
{
v
=
Int32Value
(
0
)
;
}
else
{
v
=
templateObj
.
getSlot
(
i
)
;
}
storeValue
(
v
Address
(
obj
NativeObject
:
:
getFixedSlotOffset
(
i
)
)
)
;
}
}
void
MacroAssembler
:
:
fillSlotsWithConstantValue
(
Address
base
Register
temp
uint32_t
start
uint32_t
end
const
Value
&
v
)
{
MOZ_ASSERT
(
v
.
isUndefined
(
)
|
|
IsUninitializedLexical
(
v
)
)
;
if
(
start
>
=
end
)
{
return
;
}
#
ifdef
JS_NUNBOX32
Address
addr
=
base
;
move32
(
Imm32
(
v
.
toNunboxPayload
(
)
)
temp
)
;
for
(
unsigned
i
=
start
;
i
<
end
;
+
+
i
addr
.
offset
+
=
sizeof
(
GCPtr
<
Value
>
)
)
{
store32
(
temp
ToPayload
(
addr
)
)
;
}
addr
=
base
;
move32
(
Imm32
(
v
.
toNunboxTag
(
)
)
temp
)
;
for
(
unsigned
i
=
start
;
i
<
end
;
+
+
i
addr
.
offset
+
=
sizeof
(
GCPtr
<
Value
>
)
)
{
store32
(
temp
ToType
(
addr
)
)
;
}
#
else
moveValue
(
v
ValueOperand
(
temp
)
)
;
for
(
uint32_t
i
=
start
;
i
<
end
;
+
+
i
base
.
offset
+
=
sizeof
(
GCPtr
<
Value
>
)
)
{
storePtr
(
temp
base
)
;
}
#
endif
}
void
MacroAssembler
:
:
fillSlotsWithUndefined
(
Address
base
Register
temp
uint32_t
start
uint32_t
end
)
{
fillSlotsWithConstantValue
(
base
temp
start
end
UndefinedValue
(
)
)
;
}
void
MacroAssembler
:
:
fillSlotsWithUninitialized
(
Address
base
Register
temp
uint32_t
start
uint32_t
end
)
{
fillSlotsWithConstantValue
(
base
temp
start
end
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
}
static
std
:
:
pair
<
uint32_t
uint32_t
>
FindStartOfUninitializedAndUndefinedSlots
(
const
TemplateNativeObject
&
templateObj
uint32_t
nslots
)
{
MOZ_ASSERT
(
nslots
=
=
templateObj
.
slotSpan
(
)
)
;
MOZ_ASSERT
(
nslots
>
0
)
;
uint32_t
first
=
nslots
;
for
(
;
first
!
=
0
;
-
-
first
)
{
if
(
templateObj
.
getSlot
(
first
-
1
)
!
=
UndefinedValue
(
)
)
{
break
;
}
}
uint32_t
startOfUndefined
=
first
;
if
(
first
!
=
0
&
&
IsUninitializedLexical
(
templateObj
.
getSlot
(
first
-
1
)
)
)
{
for
(
;
first
!
=
0
;
-
-
first
)
{
if
(
!
IsUninitializedLexical
(
templateObj
.
getSlot
(
first
-
1
)
)
)
{
break
;
}
}
}
uint32_t
startOfUninitialized
=
first
;
return
{
startOfUninitialized
startOfUndefined
}
;
}
void
MacroAssembler
:
:
initTypedArraySlots
(
Register
obj
Register
temp
Register
lengthReg
LiveRegisterSet
liveRegs
Label
*
fail
TypedArrayObject
*
templateObj
TypedArrayLength
lengthKind
)
{
MOZ_ASSERT
(
!
templateObj
-
>
hasBuffer
(
)
)
;
constexpr
size_t
dataSlotOffset
=
ArrayBufferViewObject
:
:
dataOffset
(
)
;
constexpr
size_t
dataOffset
=
dataSlotOffset
+
sizeof
(
HeapSlot
)
;
static_assert
(
TypedArrayObject
:
:
FIXED_DATA_START
=
=
TypedArrayObject
:
:
DATA_SLOT
+
1
"
fixed
inline
element
data
assumed
to
begin
after
the
data
slot
"
)
;
static_assert
(
TypedArrayObject
:
:
INLINE_BUFFER_LIMIT
=
=
JSObject
:
:
MAX_BYTE_SIZE
-
dataOffset
"
typed
array
inline
buffer
is
limited
by
the
maximum
object
byte
size
"
)
;
size_t
length
=
templateObj
-
>
length
(
)
;
MOZ_ASSERT
(
length
<
=
INT32_MAX
"
Template
objects
are
only
created
for
int32
lengths
"
)
;
size_t
nbytes
=
length
*
templateObj
-
>
bytesPerElement
(
)
;
if
(
lengthKind
=
=
TypedArrayLength
:
:
Fixed
&
&
nbytes
<
=
TypedArrayObject
:
:
INLINE_BUFFER_LIMIT
)
{
MOZ_ASSERT
(
dataOffset
+
nbytes
<
=
templateObj
-
>
tenuredSizeOfThis
(
)
)
;
computeEffectiveAddress
(
Address
(
obj
dataOffset
)
temp
)
;
storePrivateValue
(
temp
Address
(
obj
dataSlotOffset
)
)
;
static_assert
(
sizeof
(
HeapSlot
)
=
=
8
"
Assumed
8
bytes
alignment
"
)
;
size_t
numZeroPointers
=
(
(
nbytes
+
7
)
&
~
0x7
)
/
sizeof
(
char
*
)
;
for
(
size_t
i
=
0
;
i
<
numZeroPointers
;
i
+
+
)
{
storePtr
(
ImmWord
(
0
)
Address
(
obj
dataOffset
+
i
*
sizeof
(
char
*
)
)
)
;
}
MOZ_ASSERT
(
nbytes
>
0
"
Zero
-
length
TypedArrays
need
ZeroLengthArrayData
"
)
;
}
else
{
if
(
lengthKind
=
=
TypedArrayLength
:
:
Fixed
)
{
move32
(
Imm32
(
length
)
lengthReg
)
;
}
liveRegs
.
addUnchecked
(
temp
)
;
liveRegs
.
addUnchecked
(
obj
)
;
liveRegs
.
addUnchecked
(
lengthReg
)
;
PushRegsInMask
(
liveRegs
)
;
using
Fn
=
void
(
*
)
(
JSContext
*
cx
TypedArrayObject
*
obj
int32_t
count
)
;
setupUnalignedABICall
(
temp
)
;
loadJSContext
(
temp
)
;
passABIArg
(
temp
)
;
passABIArg
(
obj
)
;
passABIArg
(
lengthReg
)
;
callWithABI
<
Fn
AllocateAndInitTypedArrayBuffer
>
(
)
;
PopRegsInMask
(
liveRegs
)
;
branchTestUndefined
(
Assembler
:
:
Equal
Address
(
obj
dataSlotOffset
)
fail
)
;
}
}
void
MacroAssembler
:
:
initGCSlots
(
Register
obj
Register
temp
const
TemplateNativeObject
&
templateObj
)
{
MOZ_ASSERT
(
!
templateObj
.
isArrayObject
(
)
)
;
uint32_t
nslots
=
templateObj
.
slotSpan
(
)
;
if
(
nslots
=
=
0
)
{
return
;
}
uint32_t
nfixed
=
templateObj
.
numUsedFixedSlots
(
)
;
uint32_t
ndynamic
=
templateObj
.
numDynamicSlots
(
)
;
auto
[
startOfUninitialized
startOfUndefined
]
=
FindStartOfUninitializedAndUndefinedSlots
(
templateObj
nslots
)
;
MOZ_ASSERT
(
startOfUninitialized
<
=
nfixed
)
;
MOZ_ASSERT
(
startOfUndefined
>
=
startOfUninitialized
)
;
MOZ_ASSERT_IF
(
!
templateObj
.
isCallObject
(
)
&
&
!
templateObj
.
isBlockLexicalEnvironmentObject
(
)
startOfUninitialized
=
=
startOfUndefined
)
;
copySlotsFromTemplate
(
obj
templateObj
0
startOfUninitialized
)
;
size_t
offset
=
NativeObject
:
:
getFixedSlotOffset
(
startOfUninitialized
)
;
fillSlotsWithUninitialized
(
Address
(
obj
offset
)
temp
startOfUninitialized
std
:
:
min
(
startOfUndefined
nfixed
)
)
;
if
(
startOfUndefined
<
nfixed
)
{
offset
=
NativeObject
:
:
getFixedSlotOffset
(
startOfUndefined
)
;
fillSlotsWithUndefined
(
Address
(
obj
offset
)
temp
startOfUndefined
nfixed
)
;
}
if
(
ndynamic
)
{
push
(
obj
)
;
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfSlots
(
)
)
obj
)
;
if
(
startOfUndefined
>
nfixed
)
{
MOZ_ASSERT
(
startOfUninitialized
!
=
startOfUndefined
)
;
fillSlotsWithUninitialized
(
Address
(
obj
0
)
temp
0
startOfUndefined
-
nfixed
)
;
size_t
offset
=
(
startOfUndefined
-
nfixed
)
*
sizeof
(
Value
)
;
fillSlotsWithUndefined
(
Address
(
obj
offset
)
temp
startOfUndefined
-
nfixed
ndynamic
)
;
}
else
{
fillSlotsWithUndefined
(
Address
(
obj
0
)
temp
0
ndynamic
)
;
}
pop
(
obj
)
;
}
}
void
MacroAssembler
:
:
initGCThing
(
Register
obj
Register
temp
const
TemplateObject
&
templateObj
bool
initContents
)
{
storePtr
(
ImmGCPtr
(
templateObj
.
shape
(
)
)
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
)
;
if
(
templateObj
.
isNativeObject
(
)
)
{
const
TemplateNativeObject
&
ntemplate
=
templateObj
.
asTemplateNativeObject
(
)
;
MOZ_ASSERT
(
!
ntemplate
.
hasDynamicElements
(
)
)
;
if
(
!
ntemplate
.
hasDynamicSlots
(
)
)
{
storePtr
(
ImmPtr
(
emptyObjectSlots
)
Address
(
obj
NativeObject
:
:
offsetOfSlots
(
)
)
)
;
}
if
(
ntemplate
.
isArrayObject
(
)
)
{
MOZ_ASSERT
(
initContents
)
;
int
elementsOffset
=
NativeObject
:
:
offsetOfFixedElements
(
)
;
computeEffectiveAddress
(
Address
(
obj
elementsOffset
)
temp
)
;
storePtr
(
temp
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
)
;
store32
(
Imm32
(
ntemplate
.
getDenseCapacity
(
)
)
Address
(
obj
elementsOffset
+
ObjectElements
:
:
offsetOfCapacity
(
)
)
)
;
store32
(
Imm32
(
ntemplate
.
getDenseInitializedLength
(
)
)
Address
(
obj
elementsOffset
+
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
)
;
store32
(
Imm32
(
ntemplate
.
getArrayLength
(
)
)
Address
(
obj
elementsOffset
+
ObjectElements
:
:
offsetOfLength
(
)
)
)
;
store32
(
Imm32
(
ObjectElements
:
:
FIXED
)
Address
(
obj
elementsOffset
+
ObjectElements
:
:
offsetOfFlags
(
)
)
)
;
}
else
if
(
ntemplate
.
isArgumentsObject
(
)
)
{
MOZ_ASSERT
(
!
initContents
)
;
storePtr
(
ImmPtr
(
emptyObjectElements
)
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
!
ntemplate
.
isSharedMemory
(
)
)
;
MOZ_ASSERT
(
initContents
)
;
storePtr
(
ImmPtr
(
emptyObjectElements
)
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
)
;
initGCSlots
(
obj
temp
ntemplate
)
;
}
}
else
{
MOZ_CRASH
(
"
Unknown
object
"
)
;
}
#
ifdef
JS_GC_PROBES
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
PushRegsInMask
(
save
)
;
regs
.
takeUnchecked
(
obj
)
;
Register
temp2
=
regs
.
takeAnyGeneral
(
)
;
using
Fn
=
void
(
*
)
(
JSObject
*
obj
)
;
setupUnalignedABICall
(
temp2
)
;
passABIArg
(
obj
)
;
callWithABI
<
Fn
TraceCreateObject
>
(
)
;
PopRegsInMask
(
save
)
;
#
endif
}
void
MacroAssembler
:
:
compareStrings
(
JSOp
op
Register
left
Register
right
Register
result
Label
*
fail
)
{
MOZ_ASSERT
(
left
!
=
result
)
;
MOZ_ASSERT
(
right
!
=
result
)
;
MOZ_ASSERT
(
IsEqualityOp
(
op
)
|
|
IsRelationalOp
(
op
)
)
;
Label
notPointerEqual
;
branchPtr
(
Assembler
:
:
NotEqual
left
right
IsEqualityOp
(
op
)
?
&
notPointerEqual
:
fail
)
;
move32
(
Imm32
(
op
=
=
JSOp
:
:
Eq
|
|
op
=
=
JSOp
:
:
StrictEq
|
|
op
=
=
JSOp
:
:
Le
|
|
op
=
=
JSOp
:
:
Ge
)
result
)
;
if
(
IsEqualityOp
(
op
)
)
{
Label
done
;
jump
(
&
done
)
;
bind
(
&
notPointerEqual
)
;
Label
leftIsNotAtom
;
Label
setNotEqualResult
;
Imm32
atomBit
(
JSString
:
:
ATOM_BIT
)
;
branchTest32
(
Assembler
:
:
Zero
Address
(
left
JSString
:
:
offsetOfFlags
(
)
)
atomBit
&
leftIsNotAtom
)
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
right
JSString
:
:
offsetOfFlags
(
)
)
atomBit
&
setNotEqualResult
)
;
bind
(
&
leftIsNotAtom
)
;
loadStringLength
(
left
result
)
;
branch32
(
Assembler
:
:
Equal
Address
(
right
JSString
:
:
offsetOfLength
(
)
)
result
fail
)
;
bind
(
&
setNotEqualResult
)
;
move32
(
Imm32
(
op
=
=
JSOp
:
:
Ne
|
|
op
=
=
JSOp
:
:
StrictNe
)
result
)
;
bind
(
&
done
)
;
}
}
void
MacroAssembler
:
:
loadStringChars
(
Register
str
Register
dest
CharEncoding
encoding
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
if
(
encoding
=
=
CharEncoding
:
:
Latin1
)
{
movePtr
(
ImmWord
(
0
)
dest
)
;
test32MovePtr
(
Assembler
:
:
Zero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
LINEAR_BIT
)
dest
str
)
;
}
else
{
MOZ_ASSERT
(
encoding
=
=
CharEncoding
:
:
TwoByte
)
;
static
constexpr
uint32_t
Mask
=
JSString
:
:
LINEAR_BIT
|
JSString
:
:
LATIN1_CHARS_BIT
;
static_assert
(
Mask
<
1024
"
Mask
should
be
a
small
near
-
null
value
to
ensure
we
"
"
block
speculative
execution
when
it
'
s
used
as
string
"
"
pointer
"
)
;
move32
(
Imm32
(
Mask
)
dest
)
;
and32
(
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
dest
)
;
cmp32MovePtr
(
Assembler
:
:
NotEqual
dest
Imm32
(
JSString
:
:
LINEAR_BIT
)
dest
str
)
;
}
}
computeEffectiveAddress
(
Address
(
str
JSInlineString
:
:
offsetOfInlineStorage
(
)
)
dest
)
;
test32LoadPtr
(
Assembler
:
:
Zero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
INLINE_CHARS_BIT
)
Address
(
str
JSString
:
:
offsetOfNonInlineChars
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
loadNonInlineStringChars
(
Register
str
Register
dest
CharEncoding
encoding
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
static
constexpr
uint32_t
Mask
=
JSString
:
:
LINEAR_BIT
|
JSString
:
:
INLINE_CHARS_BIT
|
JSString
:
:
LATIN1_CHARS_BIT
;
static_assert
(
Mask
<
1024
"
Mask
should
be
a
small
near
-
null
value
to
ensure
we
"
"
block
speculative
execution
when
it
'
s
used
as
string
"
"
pointer
"
)
;
uint32_t
expectedBits
=
JSString
:
:
LINEAR_BIT
;
if
(
encoding
=
=
CharEncoding
:
:
Latin1
)
{
expectedBits
|
=
JSString
:
:
LATIN1_CHARS_BIT
;
}
move32
(
Imm32
(
Mask
)
dest
)
;
and32
(
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
dest
)
;
cmp32MovePtr
(
Assembler
:
:
NotEqual
dest
Imm32
(
expectedBits
)
dest
str
)
;
}
loadPtr
(
Address
(
str
JSString
:
:
offsetOfNonInlineChars
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
storeNonInlineStringChars
(
Register
chars
Register
str
)
{
MOZ_ASSERT
(
chars
!
=
str
)
;
storePtr
(
chars
Address
(
str
JSString
:
:
offsetOfNonInlineChars
(
)
)
)
;
}
void
MacroAssembler
:
:
loadInlineStringCharsForStore
(
Register
str
Register
dest
)
{
computeEffectiveAddress
(
Address
(
str
JSInlineString
:
:
offsetOfInlineStorage
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
loadInlineStringChars
(
Register
str
Register
dest
CharEncoding
encoding
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
loadStringChars
(
str
dest
encoding
)
;
}
else
{
computeEffectiveAddress
(
Address
(
str
JSInlineString
:
:
offsetOfInlineStorage
(
)
)
dest
)
;
}
}
void
MacroAssembler
:
:
loadRopeLeftChild
(
Register
str
Register
dest
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
movePtr
(
ImmWord
(
0
)
dest
)
;
test32LoadPtr
(
Assembler
:
:
Zero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
LINEAR_BIT
)
Address
(
str
JSRope
:
:
offsetOfLeft
(
)
)
dest
)
;
}
else
{
loadPtr
(
Address
(
str
JSRope
:
:
offsetOfLeft
(
)
)
dest
)
;
}
}
void
MacroAssembler
:
:
loadRopeRightChild
(
Register
str
Register
dest
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
movePtr
(
ImmWord
(
0
)
dest
)
;
test32LoadPtr
(
Assembler
:
:
Zero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
LINEAR_BIT
)
Address
(
str
JSRope
:
:
offsetOfRight
(
)
)
dest
)
;
}
else
{
loadPtr
(
Address
(
str
JSRope
:
:
offsetOfRight
(
)
)
dest
)
;
}
}
void
MacroAssembler
:
:
storeRopeChildren
(
Register
left
Register
right
Register
str
)
{
storePtr
(
left
Address
(
str
JSRope
:
:
offsetOfLeft
(
)
)
)
;
storePtr
(
right
Address
(
str
JSRope
:
:
offsetOfRight
(
)
)
)
;
}
void
MacroAssembler
:
:
loadDependentStringBase
(
Register
str
Register
dest
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
if
(
JitOptions
.
spectreStringMitigations
)
{
movePtr
(
ImmWord
(
0
)
dest
)
;
test32MovePtr
(
Assembler
:
:
Zero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
DEPENDENT_BIT
)
dest
str
)
;
}
loadPtr
(
Address
(
str
JSDependentString
:
:
offsetOfBase
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
storeDependentStringBase
(
Register
base
Register
str
)
{
storePtr
(
base
Address
(
str
JSDependentString
:
:
offsetOfBase
(
)
)
)
;
}
void
MacroAssembler
:
:
loadStringChar
(
Register
str
Register
index
Register
output
Register
scratch1
Register
scratch2
Label
*
fail
)
{
MOZ_ASSERT
(
str
!
=
output
)
;
MOZ_ASSERT
(
str
!
=
index
)
;
MOZ_ASSERT
(
index
!
=
output
)
;
MOZ_ASSERT
(
output
!
=
scratch1
)
;
MOZ_ASSERT
(
output
!
=
scratch2
)
;
move32
(
index
scratch1
)
;
movePtr
(
str
output
)
;
Label
notRope
;
branchIfNotRope
(
str
&
notRope
)
;
loadRopeLeftChild
(
str
output
)
;
Label
loadedChild
notInLeft
;
spectreBoundsCheck32
(
scratch1
Address
(
output
JSString
:
:
offsetOfLength
(
)
)
scratch2
&
notInLeft
)
;
jump
(
&
loadedChild
)
;
bind
(
&
notInLeft
)
;
sub32
(
Address
(
output
JSString
:
:
offsetOfLength
(
)
)
scratch1
)
;
loadRopeRightChild
(
str
output
)
;
bind
(
&
loadedChild
)
;
branchIfRope
(
output
fail
)
;
bind
(
&
notRope
)
;
Label
isLatin1
done
;
branchLatin1String
(
output
&
isLatin1
)
;
loadStringChars
(
output
scratch2
CharEncoding
:
:
TwoByte
)
;
loadChar
(
scratch2
scratch1
output
CharEncoding
:
:
TwoByte
)
;
jump
(
&
done
)
;
bind
(
&
isLatin1
)
;
loadStringChars
(
output
scratch2
CharEncoding
:
:
Latin1
)
;
loadChar
(
scratch2
scratch1
output
CharEncoding
:
:
Latin1
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadStringIndexValue
(
Register
str
Register
dest
Label
*
fail
)
{
MOZ_ASSERT
(
str
!
=
dest
)
;
load32
(
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
dest
)
;
branchTest32
(
Assembler
:
:
Zero
dest
Imm32
(
JSString
:
:
INDEX_VALUE_BIT
)
fail
)
;
rshift32
(
Imm32
(
JSString
:
:
INDEX_VALUE_SHIFT
)
dest
)
;
}
void
MacroAssembler
:
:
loadChar
(
Register
chars
Register
index
Register
dest
CharEncoding
encoding
int32_t
offset
)
{
if
(
encoding
=
=
CharEncoding
:
:
Latin1
)
{
loadChar
(
BaseIndex
(
chars
index
TimesOne
offset
)
dest
encoding
)
;
}
else
{
loadChar
(
BaseIndex
(
chars
index
TimesTwo
offset
)
dest
encoding
)
;
}
}
void
MacroAssembler
:
:
addToCharPtr
(
Register
chars
Register
index
CharEncoding
encoding
)
{
if
(
encoding
=
=
CharEncoding
:
:
Latin1
)
{
static_assert
(
sizeof
(
char
)
=
=
1
"
Latin
-
1
string
index
shouldn
'
t
need
scaling
"
)
;
addPtr
(
index
chars
)
;
}
else
{
computeEffectiveAddress
(
BaseIndex
(
chars
index
TimesTwo
)
chars
)
;
}
}
void
MacroAssembler
:
:
loadBigIntDigits
(
Register
bigInt
Register
digits
)
{
MOZ_ASSERT
(
digits
!
=
bigInt
)
;
computeEffectiveAddress
(
Address
(
bigInt
BigInt
:
:
offsetOfInlineDigits
(
)
)
digits
)
;
cmp32LoadPtr
(
Assembler
:
:
Above
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
int32_t
(
BigInt
:
:
inlineDigitsLength
(
)
)
)
Address
(
bigInt
BigInt
:
:
offsetOfHeapDigits
(
)
)
digits
)
;
}
void
MacroAssembler
:
:
loadBigInt64
(
Register
bigInt
Register64
dest
)
{
Label
done
nonZero
;
branchIfBigIntIsNonZero
(
bigInt
&
nonZero
)
;
{
move64
(
Imm64
(
0
)
dest
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
#
ifdef
JS_PUNBOX64
Register
digits
=
dest
.
reg
;
#
else
Register
digits
=
dest
.
high
;
#
endif
loadBigIntDigits
(
bigInt
digits
)
;
#
if
JS_PUNBOX64
load64
(
Address
(
digits
0
)
dest
)
;
#
else
load32
(
Address
(
digits
0
)
dest
.
low
)
;
Label
twoDigits
digitsDone
;
branch32
(
Assembler
:
:
Above
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
1
)
&
twoDigits
)
;
{
move32
(
Imm32
(
0
)
dest
.
high
)
;
jump
(
&
digitsDone
)
;
}
{
bind
(
&
twoDigits
)
;
load32
(
Address
(
digits
sizeof
(
BigInt
:
:
Digit
)
)
dest
.
high
)
;
}
bind
(
&
digitsDone
)
;
#
endif
branchTest32
(
Assembler
:
:
Zero
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
Imm32
(
BigInt
:
:
signBitMask
(
)
)
&
done
)
;
neg64
(
dest
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadFirstBigIntDigitOrZero
(
Register
bigInt
Register
dest
)
{
Label
done
nonZero
;
branchIfBigIntIsNonZero
(
bigInt
&
nonZero
)
;
{
movePtr
(
ImmWord
(
0
)
dest
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
loadBigIntDigits
(
bigInt
dest
)
;
loadPtr
(
Address
(
dest
0
)
dest
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadBigInt
(
Register
bigInt
Register
dest
Label
*
fail
)
{
Label
done
nonZero
;
branchIfBigIntIsNonZero
(
bigInt
&
nonZero
)
;
{
movePtr
(
ImmWord
(
0
)
dest
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
loadBigIntNonZero
(
bigInt
dest
fail
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadBigIntNonZero
(
Register
bigInt
Register
dest
Label
*
fail
)
{
MOZ_ASSERT
(
bigInt
!
=
dest
)
;
#
ifdef
DEBUG
Label
nonZero
;
branchIfBigIntIsNonZero
(
bigInt
&
nonZero
)
;
assumeUnreachable
(
"
Unexpected
zero
BigInt
"
)
;
bind
(
&
nonZero
)
;
#
endif
branch32
(
Assembler
:
:
Above
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
1
)
fail
)
;
static_assert
(
BigInt
:
:
inlineDigitsLength
(
)
>
0
"
Single
digit
BigInts
use
inline
storage
"
)
;
loadPtr
(
Address
(
bigInt
BigInt
:
:
offsetOfInlineDigits
(
)
)
dest
)
;
bigIntDigitToSignedPtr
(
bigInt
dest
fail
)
;
}
void
MacroAssembler
:
:
bigIntDigitToSignedPtr
(
Register
bigInt
Register
digit
Label
*
fail
)
{
branchTestPtr
(
Assembler
:
:
Signed
digit
digit
fail
)
;
Label
nonNegative
;
branchIfBigIntIsNonNegative
(
bigInt
&
nonNegative
)
;
negPtr
(
digit
)
;
bind
(
&
nonNegative
)
;
}
void
MacroAssembler
:
:
loadBigIntAbsolute
(
Register
bigInt
Register
dest
Label
*
fail
)
{
MOZ_ASSERT
(
bigInt
!
=
dest
)
;
branch32
(
Assembler
:
:
Above
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
1
)
fail
)
;
static_assert
(
BigInt
:
:
inlineDigitsLength
(
)
>
0
"
Single
digit
BigInts
use
inline
storage
"
)
;
movePtr
(
ImmWord
(
0
)
dest
)
;
cmp32LoadPtr
(
Assembler
:
:
NotEqual
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfInlineDigits
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
initializeBigInt64
(
Scalar
:
:
Type
type
Register
bigInt
Register64
val
)
{
MOZ_ASSERT
(
Scalar
:
:
isBigIntType
(
type
)
)
;
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
)
;
Label
done
nonZero
;
branch64
(
Assembler
:
:
NotEqual
val
Imm64
(
0
)
&
nonZero
)
;
{
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
if
(
type
=
=
Scalar
:
:
BigInt64
)
{
Label
isPositive
;
branch64
(
Assembler
:
:
GreaterThan
val
Imm64
(
0
)
&
isPositive
)
;
{
store32
(
Imm32
(
BigInt
:
:
signBitMask
(
)
)
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
)
;
neg64
(
val
)
;
}
bind
(
&
isPositive
)
;
}
store32
(
Imm32
(
1
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
=
=
sizeof
(
uintptr_t
)
"
BigInt
Digit
size
matches
uintptr_t
so
there
'
s
a
single
"
"
store
on
64
-
bit
and
up
to
two
stores
on
32
-
bit
"
)
;
#
ifndef
JS_PUNBOX64
Label
singleDigit
;
branchTest32
(
Assembler
:
:
Zero
val
.
high
val
.
high
&
singleDigit
)
;
store32
(
Imm32
(
2
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
bind
(
&
singleDigit
)
;
static_assert
(
BigInt
:
:
inlineDigitsLength
(
)
>
=
2
"
BigInt
inline
storage
can
store
at
least
two
digits
"
)
;
#
endif
store64
(
val
Address
(
bigInt
js
:
:
BigInt
:
:
offsetOfInlineDigits
(
)
)
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
initializeBigInt
(
Register
bigInt
Register
val
)
{
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
)
;
Label
done
nonZero
;
branchTestPtr
(
Assembler
:
:
NonZero
val
val
&
nonZero
)
;
{
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
Label
isPositive
;
branchTestPtr
(
Assembler
:
:
NotSigned
val
val
&
isPositive
)
;
{
store32
(
Imm32
(
BigInt
:
:
signBitMask
(
)
)
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
)
;
negPtr
(
val
)
;
}
bind
(
&
isPositive
)
;
store32
(
Imm32
(
1
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
=
=
sizeof
(
uintptr_t
)
"
BigInt
Digit
size
matches
uintptr_t
"
)
;
storePtr
(
val
Address
(
bigInt
js
:
:
BigInt
:
:
offsetOfInlineDigits
(
)
)
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
initializeBigIntAbsolute
(
Register
bigInt
Register
val
)
{
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
)
;
Label
done
nonZero
;
branchTestPtr
(
Assembler
:
:
NonZero
val
val
&
nonZero
)
;
{
store32
(
Imm32
(
0
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
jump
(
&
done
)
;
}
bind
(
&
nonZero
)
;
store32
(
Imm32
(
1
)
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
)
;
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
=
=
sizeof
(
uintptr_t
)
"
BigInt
Digit
size
matches
uintptr_t
"
)
;
storePtr
(
val
Address
(
bigInt
js
:
:
BigInt
:
:
offsetOfInlineDigits
(
)
)
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
copyBigIntWithInlineDigits
(
Register
src
Register
dest
Register
temp
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
{
branch32
(
Assembler
:
:
Above
Address
(
src
BigInt
:
:
offsetOfLength
(
)
)
Imm32
(
int32_t
(
BigInt
:
:
inlineDigitsLength
(
)
)
)
fail
)
;
newGCBigInt
(
dest
temp
initialHeap
fail
)
;
load32
(
Address
(
src
BigInt
:
:
offsetOfFlags
(
)
)
temp
)
;
and32
(
Imm32
(
BigInt
:
:
signBitMask
(
)
)
temp
)
;
store32
(
temp
Address
(
dest
BigInt
:
:
offsetOfFlags
(
)
)
)
;
load32
(
Address
(
src
BigInt
:
:
offsetOfLength
(
)
)
temp
)
;
store32
(
temp
Address
(
dest
BigInt
:
:
offsetOfLength
(
)
)
)
;
Address
srcDigits
(
src
js
:
:
BigInt
:
:
offsetOfInlineDigits
(
)
)
;
Address
destDigits
(
dest
js
:
:
BigInt
:
:
offsetOfInlineDigits
(
)
)
;
for
(
size_t
i
=
0
;
i
<
BigInt
:
:
inlineDigitsLength
(
)
;
i
+
+
)
{
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
=
=
sizeof
(
uintptr_t
)
"
BigInt
Digit
size
matches
uintptr_t
"
)
;
loadPtr
(
srcDigits
temp
)
;
storePtr
(
temp
destDigits
)
;
srcDigits
=
Address
(
src
srcDigits
.
offset
+
sizeof
(
BigInt
:
:
Digit
)
)
;
destDigits
=
Address
(
dest
destDigits
.
offset
+
sizeof
(
BigInt
:
:
Digit
)
)
;
}
}
void
MacroAssembler
:
:
compareBigIntAndInt32
(
JSOp
op
Register
bigInt
Register
int32
Register
scratch1
Register
scratch2
Label
*
ifTrue
Label
*
ifFalse
)
{
MOZ_ASSERT
(
IsLooseEqualityOp
(
op
)
|
|
IsRelationalOp
(
op
)
)
;
static_assert
(
std
:
:
is_same_v
<
BigInt
:
:
Digit
uintptr_t
>
"
BigInt
digit
can
be
loaded
in
a
pointer
-
sized
register
"
)
;
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
>
=
sizeof
(
uint32_t
)
"
BigInt
digit
stores
at
least
an
uint32
"
)
;
if
(
op
=
=
JSOp
:
:
Eq
|
|
op
=
=
JSOp
:
:
Ne
)
{
Label
*
tooLarge
=
op
=
=
JSOp
:
:
Eq
?
ifFalse
:
ifTrue
;
branch32
(
Assembler
:
:
GreaterThan
Address
(
bigInt
BigInt
:
:
offsetOfDigitLength
(
)
)
Imm32
(
1
)
tooLarge
)
;
}
else
{
Label
doCompare
;
branch32
(
Assembler
:
:
LessThanOrEqual
Address
(
bigInt
BigInt
:
:
offsetOfDigitLength
(
)
)
Imm32
(
1
)
&
doCompare
)
;
if
(
op
=
=
JSOp
:
:
Lt
|
|
op
=
=
JSOp
:
:
Le
)
{
branchIfBigIntIsNegative
(
bigInt
ifTrue
)
;
jump
(
ifFalse
)
;
}
else
{
branchIfBigIntIsNegative
(
bigInt
ifFalse
)
;
jump
(
ifTrue
)
;
}
bind
(
&
doCompare
)
;
}
{
Label
*
greaterThan
;
Label
*
lessThan
;
if
(
op
=
=
JSOp
:
:
Eq
)
{
greaterThan
=
ifFalse
;
lessThan
=
ifFalse
;
}
else
if
(
op
=
=
JSOp
:
:
Ne
)
{
greaterThan
=
ifTrue
;
lessThan
=
ifTrue
;
}
else
if
(
op
=
=
JSOp
:
:
Lt
|
|
op
=
=
JSOp
:
:
Le
)
{
greaterThan
=
ifFalse
;
lessThan
=
ifTrue
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
Gt
|
|
op
=
=
JSOp
:
:
Ge
)
;
greaterThan
=
ifTrue
;
lessThan
=
ifFalse
;
}
loadFirstBigIntDigitOrZero
(
bigInt
scratch1
)
;
move32
(
int32
scratch2
)
;
Label
isNegative
doCompare
;
branchIfBigIntIsNegative
(
bigInt
&
isNegative
)
;
branch32
(
Assembler
:
:
LessThan
int32
Imm32
(
0
)
greaterThan
)
;
jump
(
&
doCompare
)
;
bind
(
&
isNegative
)
;
branch32
(
Assembler
:
:
GreaterThanOrEqual
int32
Imm32
(
0
)
lessThan
)
;
neg32
(
scratch2
)
;
move32ZeroExtendToPtr
(
scratch2
scratch2
)
;
JSOp
reversed
=
ReverseCompareOp
(
op
)
;
if
(
reversed
!
=
op
)
{
branchPtr
(
JSOpToCondition
(
reversed
false
)
scratch1
scratch2
ifTrue
)
;
jump
(
ifFalse
)
;
}
bind
(
&
doCompare
)
;
branchPtr
(
JSOpToCondition
(
op
false
)
scratch1
scratch2
ifTrue
)
;
}
}
void
MacroAssembler
:
:
equalBigInts
(
Register
left
Register
right
Register
temp1
Register
temp2
Register
temp3
Register
temp4
Label
*
notSameSign
Label
*
notSameLength
Label
*
notSameDigit
)
{
MOZ_ASSERT
(
left
!
=
temp1
)
;
MOZ_ASSERT
(
right
!
=
temp1
)
;
MOZ_ASSERT
(
right
!
=
temp2
)
;
load32
(
Address
(
left
BigInt
:
:
offsetOfFlags
(
)
)
temp1
)
;
xor32
(
Address
(
right
BigInt
:
:
offsetOfFlags
(
)
)
temp1
)
;
branchTest32
(
Assembler
:
:
NonZero
temp1
Imm32
(
BigInt
:
:
signBitMask
(
)
)
notSameSign
)
;
load32
(
Address
(
right
BigInt
:
:
offsetOfLength
(
)
)
temp1
)
;
branch32
(
Assembler
:
:
NotEqual
Address
(
left
BigInt
:
:
offsetOfLength
(
)
)
temp1
notSameLength
)
;
loadBigIntDigits
(
left
temp2
)
;
loadBigIntDigits
(
right
temp3
)
;
static_assert
(
sizeof
(
BigInt
:
:
Digit
)
=
=
sizeof
(
void
*
)
"
BigInt
:
:
Digit
is
pointer
sized
"
)
;
computeEffectiveAddress
(
BaseIndex
(
temp2
temp1
ScalePointer
)
temp2
)
;
computeEffectiveAddress
(
BaseIndex
(
temp3
temp1
ScalePointer
)
temp3
)
;
Label
start
loop
;
jump
(
&
start
)
;
bind
(
&
loop
)
;
subPtr
(
Imm32
(
sizeof
(
BigInt
:
:
Digit
)
)
temp2
)
;
subPtr
(
Imm32
(
sizeof
(
BigInt
:
:
Digit
)
)
temp3
)
;
loadPtr
(
Address
(
temp3
0
)
temp4
)
;
branchPtr
(
Assembler
:
:
NotEqual
Address
(
temp2
0
)
temp4
notSameDigit
)
;
bind
(
&
start
)
;
branchSub32
(
Assembler
:
:
NotSigned
Imm32
(
1
)
temp1
&
loop
)
;
}
void
MacroAssembler
:
:
typeOfObject
(
Register
obj
Register
scratch
Label
*
slow
Label
*
isObject
Label
*
isCallable
Label
*
isUndefined
)
{
loadObjClassUnsafe
(
obj
scratch
)
;
branchTestClassIsProxy
(
true
scratch
slow
)
;
branchTestClassIsFunction
(
Assembler
:
:
Equal
scratch
isCallable
)
;
Address
flags
(
scratch
JSClass
:
:
offsetOfFlags
(
)
)
;
branchTest32
(
Assembler
:
:
NonZero
flags
Imm32
(
JSCLASS_EMULATES_UNDEFINED
)
isUndefined
)
;
branchPtr
(
Assembler
:
:
Equal
Address
(
scratch
offsetof
(
JSClass
cOps
)
)
ImmPtr
(
nullptr
)
isObject
)
;
loadPtr
(
Address
(
scratch
offsetof
(
JSClass
cOps
)
)
scratch
)
;
branchPtr
(
Assembler
:
:
Equal
Address
(
scratch
offsetof
(
JSClassOps
call
)
)
ImmPtr
(
nullptr
)
isObject
)
;
jump
(
isCallable
)
;
}
void
MacroAssembler
:
:
isCallableOrConstructor
(
bool
isCallable
Register
obj
Register
output
Label
*
isProxy
)
{
MOZ_ASSERT
(
obj
!
=
output
)
;
Label
notFunction
hasCOps
done
;
loadObjClassUnsafe
(
obj
output
)
;
branchTestClassIsFunction
(
Assembler
:
:
NotEqual
output
&
notFunction
)
;
if
(
isCallable
)
{
move32
(
Imm32
(
1
)
output
)
;
}
else
{
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
uint32_t
(
FunctionFlags
:
:
CONSTRUCTOR
)
)
"
FunctionFlags
:
:
CONSTRUCTOR
has
only
one
bit
set
"
)
;
load32
(
Address
(
obj
JSFunction
:
:
offsetOfFlagsAndArgCount
(
)
)
output
)
;
rshift32
(
Imm32
(
mozilla
:
:
FloorLog2
(
uint32_t
(
FunctionFlags
:
:
CONSTRUCTOR
)
)
)
output
)
;
and32
(
Imm32
(
1
)
output
)
;
}
jump
(
&
done
)
;
bind
(
&
notFunction
)
;
branchTestClassIsProxy
(
true
output
isProxy
)
;
branchPtr
(
Assembler
:
:
NonZero
Address
(
output
offsetof
(
JSClass
cOps
)
)
ImmPtr
(
nullptr
)
&
hasCOps
)
;
move32
(
Imm32
(
0
)
output
)
;
jump
(
&
done
)
;
bind
(
&
hasCOps
)
;
loadPtr
(
Address
(
output
offsetof
(
JSClass
cOps
)
)
output
)
;
size_t
opsOffset
=
isCallable
?
offsetof
(
JSClassOps
call
)
:
offsetof
(
JSClassOps
construct
)
;
cmpPtrSet
(
Assembler
:
:
NonZero
Address
(
output
opsOffset
)
ImmPtr
(
nullptr
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadJSContext
(
Register
dest
)
{
movePtr
(
ImmPtr
(
runtime
(
)
-
>
mainContextPtr
(
)
)
dest
)
;
}
static
const
uint8_t
*
ContextRealmPtr
(
CompileRuntime
*
rt
)
{
return
(
static_cast
<
const
uint8_t
*
>
(
rt
-
>
mainContextPtr
(
)
)
+
JSContext
:
:
offsetOfRealm
(
)
)
;
}
void
MacroAssembler
:
:
switchToRealm
(
Register
realm
)
{
storePtr
(
realm
AbsoluteAddress
(
ContextRealmPtr
(
runtime
(
)
)
)
)
;
}
void
MacroAssembler
:
:
switchToRealm
(
const
void
*
realm
Register
scratch
)
{
MOZ_ASSERT
(
realm
)
;
movePtr
(
ImmPtr
(
realm
)
scratch
)
;
switchToRealm
(
scratch
)
;
}
void
MacroAssembler
:
:
switchToObjectRealm
(
Register
obj
Register
scratch
)
{
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
Shape
:
:
offsetOfBaseShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
BaseShape
:
:
offsetOfRealm
(
)
)
scratch
)
;
switchToRealm
(
scratch
)
;
}
void
MacroAssembler
:
:
switchToBaselineFrameRealm
(
Register
scratch
)
{
Address
envChain
(
FramePointer
BaselineFrame
:
:
reverseOffsetOfEnvironmentChain
(
)
)
;
loadPtr
(
envChain
scratch
)
;
switchToObjectRealm
(
scratch
scratch
)
;
}
void
MacroAssembler
:
:
switchToWasmInstanceRealm
(
Register
scratch1
Register
scratch2
)
{
loadPtr
(
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfCx
(
)
)
scratch1
)
;
loadPtr
(
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfRealm
(
)
)
scratch2
)
;
storePtr
(
scratch2
Address
(
scratch1
JSContext
:
:
offsetOfRealm
(
)
)
)
;
}
void
MacroAssembler
:
:
debugAssertContextRealm
(
const
void
*
realm
Register
scratch
)
{
#
ifdef
DEBUG
Label
ok
;
movePtr
(
ImmPtr
(
realm
)
scratch
)
;
branchPtr
(
Assembler
:
:
Equal
AbsoluteAddress
(
ContextRealmPtr
(
runtime
(
)
)
)
scratch
&
ok
)
;
assumeUnreachable
(
"
Unexpected
context
realm
"
)
;
bind
(
&
ok
)
;
#
endif
}
void
MacroAssembler
:
:
setIsCrossRealmArrayConstructor
(
Register
obj
Register
output
)
{
#
ifdef
DEBUG
Label
notProxy
;
branchTestObjectIsProxy
(
false
obj
output
&
notProxy
)
;
assumeUnreachable
(
"
Unexpected
proxy
in
setIsCrossRealmArrayConstructor
"
)
;
bind
(
&
notProxy
)
;
#
endif
Label
isFalse
done
;
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
output
)
;
loadPtr
(
Address
(
output
Shape
:
:
offsetOfBaseShape
(
)
)
output
)
;
loadPtr
(
Address
(
output
BaseShape
:
:
offsetOfRealm
(
)
)
output
)
;
branchPtr
(
Assembler
:
:
Equal
AbsoluteAddress
(
ContextRealmPtr
(
runtime
(
)
)
)
output
&
isFalse
)
;
branchTestObjIsFunction
(
Assembler
:
:
NotEqual
obj
output
obj
&
isFalse
)
;
branchPtr
(
Assembler
:
:
NotEqual
Address
(
obj
JSFunction
:
:
offsetOfNativeOrEnv
(
)
)
ImmPtr
(
js
:
:
ArrayConstructor
)
&
isFalse
)
;
move32
(
Imm32
(
1
)
output
)
;
jump
(
&
done
)
;
bind
(
&
isFalse
)
;
move32
(
Imm32
(
0
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
setIsDefinitelyTypedArrayConstructor
(
Register
obj
Register
output
)
{
Label
isFalse
isTrue
done
;
branchTestObjIsFunction
(
Assembler
:
:
NotEqual
obj
output
obj
&
isFalse
)
;
loadPtr
(
Address
(
obj
JSFunction
:
:
offsetOfNativeOrEnv
(
)
)
output
)
;
auto
branchIsTypedArrayCtor
=
[
&
]
(
Scalar
:
:
Type
type
)
{
JSNative
constructor
=
TypedArrayConstructorNative
(
type
)
;
branchPtr
(
Assembler
:
:
Equal
output
ImmPtr
(
constructor
)
&
isTrue
)
;
}
;
#
define
TYPED_ARRAY_CONSTRUCTOR_NATIVE
(
_
T
N
)
\
branchIsTypedArrayCtor
(
Scalar
:
:
N
)
;
JS_FOR_EACH_TYPED_ARRAY
(
TYPED_ARRAY_CONSTRUCTOR_NATIVE
)
#
undef
TYPED_ARRAY_CONSTRUCTOR_NATIVE
bind
(
&
isFalse
)
;
move32
(
Imm32
(
0
)
output
)
;
jump
(
&
done
)
;
bind
(
&
isTrue
)
;
move32
(
Imm32
(
1
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadMegamorphicCache
(
Register
dest
)
{
movePtr
(
ImmPtr
(
runtime
(
)
-
>
addressOfMegamorphicCache
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
emitMegamorphicCacheLookup
(
PropertyKey
id
Register
obj
Register
scratch1
Register
scratch2
Register
scratch3
ValueOperand
output
Label
*
fail
Label
*
cacheHit
)
{
Label
cacheMiss
isMissing
dynamicSlot
protoLoopHead
protoLoopTail
;
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch1
)
;
movePtr
(
scratch1
scratch2
)
;
movePtr
(
scratch1
scratch3
)
;
rshiftPtr
(
Imm32
(
MegamorphicCache
:
:
ShapeHashShift1
)
scratch2
)
;
rshiftPtr
(
Imm32
(
MegamorphicCache
:
:
ShapeHashShift2
)
scratch3
)
;
xorPtr
(
scratch3
scratch2
)
;
addPtr
(
Imm32
(
HashAtomOrSymbolPropertyKey
(
id
)
)
scratch2
)
;
constexpr
size_t
cacheSize
=
MegamorphicCache
:
:
NumEntries
;
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
cacheSize
)
)
;
size_t
cacheMask
=
cacheSize
-
1
;
and32
(
Imm32
(
cacheMask
)
scratch2
)
;
loadMegamorphicCache
(
scratch3
)
;
constexpr
size_t
entrySize
=
sizeof
(
MegamorphicCache
:
:
Entry
)
;
static_assert
(
sizeof
(
void
*
)
=
=
4
|
|
entrySize
=
=
24
)
;
if
constexpr
(
sizeof
(
void
*
)
=
=
4
)
{
mul32
(
Imm32
(
entrySize
)
scratch2
)
;
computeEffectiveAddress
(
BaseIndex
(
scratch3
scratch2
TimesOne
MegamorphicCache
:
:
offsetOfEntries
(
)
)
scratch2
)
;
}
else
{
computeEffectiveAddress
(
BaseIndex
(
scratch2
scratch2
TimesTwo
)
scratch2
)
;
computeEffectiveAddress
(
BaseIndex
(
scratch3
scratch2
TimesEight
MegamorphicCache
:
:
offsetOfEntries
(
)
)
scratch2
)
;
}
branchPtr
(
Assembler
:
:
NotEqual
Address
(
scratch2
MegamorphicCache
:
:
Entry
:
:
offsetOfShape
(
)
)
scratch1
&
cacheMiss
)
;
movePropertyKey
(
id
scratch1
)
;
branchPtr
(
Assembler
:
:
NotEqual
Address
(
scratch2
MegamorphicCache
:
:
Entry
:
:
offsetOfKey
(
)
)
scratch1
&
cacheMiss
)
;
load16ZeroExtend
(
Address
(
scratch3
MegamorphicCache
:
:
offsetOfGeneration
(
)
)
scratch3
)
;
load16ZeroExtend
(
Address
(
scratch2
MegamorphicCache
:
:
Entry
:
:
offsetOfGeneration
(
)
)
scratch1
)
;
branch32
(
Assembler
:
:
NotEqual
scratch1
scratch3
&
cacheMiss
)
;
load8ZeroExtend
(
Address
(
scratch2
MegamorphicCache
:
:
Entry
:
:
offsetOfNumHops
(
)
)
scratch3
)
;
branch32
(
Assembler
:
:
Equal
scratch3
Imm32
(
MegamorphicCache
:
:
Entry
:
:
NumHopsForMissingOwnProperty
)
&
cacheMiss
)
;
branch32
(
Assembler
:
:
Equal
scratch3
Imm32
(
MegamorphicCache
:
:
Entry
:
:
NumHopsForMissingProperty
)
&
isMissing
)
;
Register
outputScratch
=
output
.
scratchReg
(
)
;
if
(
!
outputScratch
.
aliases
(
obj
)
)
{
movePtr
(
obj
outputScratch
)
;
}
branchTest32
(
Assembler
:
:
Zero
scratch3
scratch3
&
protoLoopTail
)
;
bind
(
&
protoLoopHead
)
;
loadObjProto
(
outputScratch
outputScratch
)
;
branchSub32
(
Assembler
:
:
NonZero
Imm32
(
1
)
scratch3
&
protoLoopHead
)
;
bind
(
&
protoLoopTail
)
;
loadPtr
(
Address
(
outputScratch
JSObject
:
:
offsetOfShape
(
)
)
scratch1
)
;
load32
(
Address
(
scratch1
Shape
:
:
offsetOfImmutableFlags
(
)
)
scratch1
)
;
and32
(
Imm32
(
Shape
:
:
fixedSlotsMask
(
)
)
scratch1
)
;
rshift32
(
Imm32
(
Shape
:
:
fixedSlotsShift
(
)
)
scratch1
)
;
load16ZeroExtend
(
Address
(
scratch2
MegamorphicCache
:
:
Entry
:
:
offsetOfSlot
(
)
)
scratch3
)
;
branch32
(
Assembler
:
:
GreaterThanOrEqual
scratch3
scratch1
&
dynamicSlot
)
;
static_assert
(
sizeof
(
HeapSlot
)
=
=
8
)
;
loadValue
(
BaseValueIndex
(
outputScratch
scratch3
sizeof
(
NativeObject
)
)
output
)
;
jump
(
cacheHit
)
;
bind
(
&
dynamicSlot
)
;
sub32
(
scratch1
scratch3
)
;
loadPtr
(
Address
(
outputScratch
NativeObject
:
:
offsetOfSlots
(
)
)
outputScratch
)
;
loadValue
(
BaseValueIndex
(
outputScratch
scratch3
0
)
output
)
;
jump
(
cacheHit
)
;
bind
(
&
isMissing
)
;
moveValue
(
UndefinedValue
(
)
output
)
;
jump
(
cacheHit
)
;
bind
(
&
cacheMiss
)
;
}
void
MacroAssembler
:
:
guardNonNegativeIntPtrToInt32
(
Register
reg
Label
*
fail
)
{
#
ifdef
DEBUG
Label
ok
;
branchPtr
(
Assembler
:
:
NotSigned
reg
reg
&
ok
)
;
assumeUnreachable
(
"
Unexpected
negative
value
"
)
;
bind
(
&
ok
)
;
#
endif
#
ifdef
JS_64BIT
branchPtr
(
Assembler
:
:
Above
reg
Imm32
(
INT32_MAX
)
fail
)
;
#
endif
}
void
MacroAssembler
:
:
loadArrayBufferByteLengthIntPtr
(
Register
obj
Register
output
)
{
Address
slotAddr
(
obj
ArrayBufferObject
:
:
offsetOfByteLengthSlot
(
)
)
;
loadPrivate
(
slotAddr
output
)
;
}
void
MacroAssembler
:
:
loadArrayBufferViewByteOffsetIntPtr
(
Register
obj
Register
output
)
{
Address
slotAddr
(
obj
ArrayBufferViewObject
:
:
byteOffsetOffset
(
)
)
;
loadPrivate
(
slotAddr
output
)
;
}
void
MacroAssembler
:
:
loadArrayBufferViewLengthIntPtr
(
Register
obj
Register
output
)
{
Address
slotAddr
(
obj
ArrayBufferViewObject
:
:
lengthOffset
(
)
)
;
loadPrivate
(
slotAddr
output
)
;
}
void
MacroAssembler
:
:
loadDOMExpandoValueGuardGeneration
(
Register
obj
ValueOperand
output
JS
:
:
ExpandoAndGeneration
*
expandoAndGeneration
uint64_t
generation
Label
*
fail
)
{
loadPtr
(
Address
(
obj
ProxyObject
:
:
offsetOfReservedSlots
(
)
)
output
.
scratchReg
(
)
)
;
loadValue
(
Address
(
output
.
scratchReg
(
)
js
:
:
detail
:
:
ProxyReservedSlots
:
:
offsetOfPrivateSlot
(
)
)
output
)
;
branchTestValue
(
Assembler
:
:
NotEqual
output
PrivateValue
(
expandoAndGeneration
)
fail
)
;
Address
generationAddr
(
output
.
payloadOrValueReg
(
)
JS
:
:
ExpandoAndGeneration
:
:
offsetOfGeneration
(
)
)
;
branch64
(
Assembler
:
:
NotEqual
generationAddr
Imm64
(
generation
)
fail
)
;
loadValue
(
Address
(
output
.
payloadOrValueReg
(
)
JS
:
:
ExpandoAndGeneration
:
:
offsetOfExpando
(
)
)
output
)
;
}
void
MacroAssembler
:
:
loadJitActivation
(
Register
dest
)
{
loadJSContext
(
dest
)
;
loadPtr
(
Address
(
dest
offsetof
(
JSContext
activation_
)
)
dest
)
;
}
void
MacroAssembler
:
:
guardSpecificAtom
(
Register
str
JSAtom
*
atom
Register
scratch
const
LiveRegisterSet
&
volatileRegs
Label
*
fail
)
{
Label
done
;
branchPtr
(
Assembler
:
:
Equal
str
ImmGCPtr
(
atom
)
&
done
)
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
ATOM_BIT
)
fail
)
;
branch32
(
Assembler
:
:
NotEqual
Address
(
str
JSString
:
:
offsetOfLength
(
)
)
Imm32
(
atom
-
>
length
(
)
)
fail
)
;
PushRegsInMask
(
volatileRegs
)
;
using
Fn
=
bool
(
*
)
(
JSString
*
str1
JSString
*
str2
)
;
setupUnalignedABICall
(
scratch
)
;
movePtr
(
ImmGCPtr
(
atom
)
scratch
)
;
passABIArg
(
scratch
)
;
passABIArg
(
str
)
;
callWithABI
<
Fn
EqualStringsHelperPure
>
(
)
;
storeCallPointerResult
(
scratch
)
;
MOZ_ASSERT
(
!
volatileRegs
.
has
(
scratch
)
)
;
PopRegsInMask
(
volatileRegs
)
;
branchIfFalseBool
(
scratch
fail
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
guardStringToInt32
(
Register
str
Register
output
Register
scratch
LiveRegisterSet
volatileRegs
Label
*
fail
)
{
Label
vmCall
done
;
loadStringIndexValue
(
str
output
&
vmCall
)
;
jump
(
&
done
)
;
{
bind
(
&
vmCall
)
;
reserveStack
(
sizeof
(
uintptr_t
)
)
;
moveStackPtrTo
(
output
)
;
volatileRegs
.
takeUnchecked
(
scratch
)
;
if
(
output
.
volatile_
(
)
)
{
volatileRegs
.
addUnchecked
(
output
)
;
}
PushRegsInMask
(
volatileRegs
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
cx
JSString
*
str
int32_t
*
result
)
;
setupUnalignedABICall
(
scratch
)
;
loadJSContext
(
scratch
)
;
passABIArg
(
scratch
)
;
passABIArg
(
str
)
;
passABIArg
(
output
)
;
callWithABI
<
Fn
GetInt32FromStringPure
>
(
)
;
storeCallPointerResult
(
scratch
)
;
PopRegsInMask
(
volatileRegs
)
;
Label
ok
;
branchIfTrueBool
(
scratch
&
ok
)
;
{
addToStackPtr
(
Imm32
(
sizeof
(
uintptr_t
)
)
)
;
jump
(
fail
)
;
}
bind
(
&
ok
)
;
load32
(
Address
(
output
0
)
output
)
;
freeStack
(
sizeof
(
uintptr_t
)
)
;
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
generateBailoutTail
(
Register
scratch
Register
bailoutInfo
)
{
Label
bailoutFailed
;
branchIfFalseBool
(
ReturnReg
&
bailoutFailed
)
;
{
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
MOZ_ASSERT_IF
(
!
IsHiddenSP
(
getStackPointer
(
)
)
!
regs
.
has
(
AsRegister
(
getStackPointer
(
)
)
)
)
;
regs
.
take
(
bailoutInfo
)
;
Register
temp
=
regs
.
takeAny
(
)
;
#
ifdef
DEBUG
Label
ok
;
loadPtr
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
incomingStack
)
)
temp
)
;
branchStackPtr
(
Assembler
:
:
Equal
temp
&
ok
)
;
assumeUnreachable
(
"
Unexpected
stack
pointer
value
"
)
;
bind
(
&
ok
)
;
#
endif
Register
copyCur
=
regs
.
takeAny
(
)
;
Register
copyEnd
=
regs
.
takeAny
(
)
;
loadPtr
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
copyStackTop
)
)
copyCur
)
;
loadPtr
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
copyStackBottom
)
)
copyEnd
)
;
{
Label
copyLoop
;
Label
endOfCopy
;
bind
(
&
copyLoop
)
;
branchPtr
(
Assembler
:
:
BelowOrEqual
copyCur
copyEnd
&
endOfCopy
)
;
subPtr
(
Imm32
(
sizeof
(
uintptr_t
)
)
copyCur
)
;
subFromStackPtr
(
Imm32
(
sizeof
(
uintptr_t
)
)
)
;
loadPtr
(
Address
(
copyCur
0
)
temp
)
;
storePtr
(
temp
Address
(
getStackPointer
(
)
0
)
)
;
jump
(
&
copyLoop
)
;
bind
(
&
endOfCopy
)
;
}
loadPtr
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
resumeFramePtr
)
)
FramePointer
)
;
pushFrameDescriptor
(
FrameType
:
:
BaselineJS
)
;
push
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
resumeAddr
)
)
)
;
push
(
FramePointer
)
;
loadJSContext
(
scratch
)
;
enterFakeExitFrame
(
scratch
scratch
ExitFrameType
:
:
Bare
)
;
push
(
Address
(
bailoutInfo
offsetof
(
BaselineBailoutInfo
resumeAddr
)
)
)
;
using
Fn
=
bool
(
*
)
(
BaselineBailoutInfo
*
bailoutInfoArg
)
;
setupUnalignedABICall
(
temp
)
;
passABIArg
(
bailoutInfo
)
;
callWithABI
<
Fn
FinishBailoutToBaseline
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckHasExitFrame
)
;
branchIfFalseBool
(
ReturnReg
exceptionLabel
(
)
)
;
AllocatableGeneralRegisterSet
enterRegs
(
GeneralRegisterSet
:
:
All
(
)
)
;
MOZ_ASSERT
(
!
enterRegs
.
has
(
FramePointer
)
)
;
Register
jitcodeReg
=
enterRegs
.
takeAny
(
)
;
pop
(
jitcodeReg
)
;
addToStackPtr
(
Imm32
(
ExitFrameLayout
:
:
SizeWithFooter
(
)
)
)
;
jump
(
jitcodeReg
)
;
}
bind
(
&
bailoutFailed
)
;
{
loadJSContext
(
scratch
)
;
enterFakeExitFrame
(
scratch
scratch
ExitFrameType
:
:
UnwoundJit
)
;
jump
(
exceptionLabel
(
)
)
;
}
}
void
MacroAssembler
:
:
loadJitCodeRaw
(
Register
func
Register
dest
)
{
static_assert
(
BaseScript
:
:
offsetOfJitCodeRaw
(
)
=
=
SelfHostedLazyScript
:
:
offsetOfJitCodeRaw
(
)
"
SelfHostedLazyScript
and
BaseScript
must
use
same
layout
for
"
"
jitCodeRaw_
"
)
;
loadPrivate
(
Address
(
func
JSFunction
:
:
offsetOfJitInfoOrScript
(
)
)
dest
)
;
loadPtr
(
Address
(
dest
BaseScript
:
:
offsetOfJitCodeRaw
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
loadBaselineJitCodeRaw
(
Register
func
Register
dest
Label
*
failure
)
{
loadPrivate
(
Address
(
func
JSFunction
:
:
offsetOfJitInfoOrScript
(
)
)
dest
)
;
if
(
failure
)
{
branchIfScriptHasNoJitScript
(
dest
failure
)
;
}
loadJitScript
(
dest
dest
)
;
loadPtr
(
Address
(
dest
JitScript
:
:
offsetOfBaselineScript
(
)
)
dest
)
;
if
(
failure
)
{
static_assert
(
BaselineDisabledScript
=
=
0x1
)
;
branchPtr
(
Assembler
:
:
BelowOrEqual
dest
ImmWord
(
BaselineDisabledScript
)
failure
)
;
}
loadPtr
(
Address
(
dest
BaselineScript
:
:
offsetOfMethod
(
)
)
dest
)
;
loadPtr
(
Address
(
dest
JitCode
:
:
offsetOfCode
(
)
)
dest
)
;
}
void
MacroAssembler
:
:
loadBaselineFramePtr
(
Register
framePtr
Register
dest
)
{
if
(
framePtr
!
=
dest
)
{
movePtr
(
framePtr
dest
)
;
}
subPtr
(
Imm32
(
BaselineFrame
:
:
Size
(
)
)
dest
)
;
}
static
const
uint8_t
*
ContextInlinedICScriptPtr
(
CompileRuntime
*
rt
)
{
return
(
static_cast
<
const
uint8_t
*
>
(
rt
-
>
mainContextPtr
(
)
)
+
JSContext
:
:
offsetOfInlinedICScript
(
)
)
;
}
void
MacroAssembler
:
:
storeICScriptInJSContext
(
Register
icScript
)
{
storePtr
(
icScript
AbsoluteAddress
(
ContextInlinedICScriptPtr
(
runtime
(
)
)
)
)
;
}
void
MacroAssembler
:
:
handleFailure
(
)
{
TrampolinePtr
excTail
=
runtime
(
)
-
>
jitRuntime
(
)
-
>
getExceptionTail
(
)
;
jump
(
excTail
)
;
}
void
MacroAssembler
:
:
assumeUnreachable
(
const
char
*
output
)
{
#
ifdef
JS_MASM_VERBOSE
if
(
!
IsCompilingWasm
(
)
)
{
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
PushRegsInMask
(
save
)
;
Register
temp
=
regs
.
takeAnyGeneral
(
)
;
using
Fn
=
void
(
*
)
(
const
char
*
output
)
;
setupUnalignedABICall
(
temp
)
;
movePtr
(
ImmPtr
(
output
)
temp
)
;
passABIArg
(
temp
)
;
callWithABI
<
Fn
AssumeUnreachable
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
PopRegsInMask
(
save
)
;
}
#
endif
breakpoint
(
)
;
}
void
MacroAssembler
:
:
printf
(
const
char
*
output
)
{
#
ifdef
JS_MASM_VERBOSE
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
PushRegsInMask
(
save
)
;
Register
temp
=
regs
.
takeAnyGeneral
(
)
;
using
Fn
=
void
(
*
)
(
const
char
*
output
)
;
setupUnalignedABICall
(
temp
)
;
movePtr
(
ImmPtr
(
output
)
temp
)
;
passABIArg
(
temp
)
;
callWithABI
<
Fn
Printf0
>
(
)
;
PopRegsInMask
(
save
)
;
#
endif
}
void
MacroAssembler
:
:
printf
(
const
char
*
output
Register
value
)
{
#
ifdef
JS_MASM_VERBOSE
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
PushRegsInMask
(
save
)
;
regs
.
takeUnchecked
(
value
)
;
Register
temp
=
regs
.
takeAnyGeneral
(
)
;
using
Fn
=
void
(
*
)
(
const
char
*
output
uintptr_t
value
)
;
setupUnalignedABICall
(
temp
)
;
movePtr
(
ImmPtr
(
output
)
temp
)
;
passABIArg
(
temp
)
;
passABIArg
(
value
)
;
callWithABI
<
Fn
Printf1
>
(
)
;
PopRegsInMask
(
save
)
;
#
endif
}
void
MacroAssembler
:
:
convertInt32ValueToDouble
(
ValueOperand
val
)
{
Label
done
;
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
done
)
;
unboxInt32
(
val
val
.
scratchReg
(
)
)
;
ScratchDoubleScope
fpscratch
(
*
this
)
;
convertInt32ToDouble
(
val
.
scratchReg
(
)
fpscratch
)
;
boxDouble
(
fpscratch
val
fpscratch
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
convertValueToFloatingPoint
(
ValueOperand
value
FloatRegister
output
Label
*
fail
MIRType
outputType
)
{
Label
isDouble
isInt32
isBool
isNull
done
;
{
ScratchTagScope
tag
(
*
this
value
)
;
splitTagForTest
(
value
tag
)
;
branchTestDouble
(
Assembler
:
:
Equal
tag
&
isDouble
)
;
branchTestInt32
(
Assembler
:
:
Equal
tag
&
isInt32
)
;
branchTestBoolean
(
Assembler
:
:
Equal
tag
&
isBool
)
;
branchTestNull
(
Assembler
:
:
Equal
tag
&
isNull
)
;
branchTestUndefined
(
Assembler
:
:
NotEqual
tag
fail
)
;
}
loadConstantFloatingPoint
(
GenericNaN
(
)
float
(
GenericNaN
(
)
)
output
outputType
)
;
jump
(
&
done
)
;
bind
(
&
isNull
)
;
loadConstantFloatingPoint
(
0
.
0
0
.
0f
output
outputType
)
;
jump
(
&
done
)
;
bind
(
&
isBool
)
;
boolValueToFloatingPoint
(
value
output
outputType
)
;
jump
(
&
done
)
;
bind
(
&
isInt32
)
;
int32ValueToFloatingPoint
(
value
output
outputType
)
;
jump
(
&
done
)
;
bind
(
&
isDouble
)
;
if
(
outputType
=
=
MIRType
:
:
Float32
&
&
hasMultiAlias
(
)
)
{
ScratchDoubleScope
tmp
(
*
this
)
;
unboxDouble
(
value
tmp
)
;
convertDoubleToFloat32
(
tmp
output
)
;
}
else
{
FloatRegister
tmp
=
output
.
asDouble
(
)
;
unboxDouble
(
value
tmp
)
;
if
(
outputType
=
=
MIRType
:
:
Float32
)
{
convertDoubleToFloat32
(
tmp
output
)
;
}
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
outOfLineTruncateSlow
(
FloatRegister
src
Register
dest
bool
widenFloatToDouble
bool
compilingWasm
wasm
:
:
BytecodeOffset
callOffset
)
{
if
(
compilingWasm
)
{
Push
(
InstanceReg
)
;
}
int32_t
framePushedAfterInstance
=
framePushed
(
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
|
|
\
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_LOONG64
)
ScratchDoubleScope
fpscratch
(
*
this
)
;
if
(
widenFloatToDouble
)
{
convertFloat32ToDouble
(
src
fpscratch
)
;
src
=
fpscratch
;
}
#
elif
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
FloatRegister
srcSingle
;
if
(
widenFloatToDouble
)
{
MOZ_ASSERT
(
src
.
isSingle
(
)
)
;
srcSingle
=
src
;
src
=
src
.
asDouble
(
)
;
Push
(
srcSingle
)
;
convertFloat32ToDouble
(
srcSingle
src
)
;
}
#
else
MOZ_CRASH
(
"
MacroAssembler
platform
hook
:
outOfLineTruncateSlow
"
)
;
#
endif
MOZ_ASSERT
(
src
.
isDouble
(
)
)
;
if
(
compilingWasm
)
{
int32_t
instanceOffset
=
framePushed
(
)
-
framePushedAfterInstance
;
setupWasmABICall
(
)
;
passABIArg
(
src
MoveOp
:
:
DOUBLE
)
;
callWithABI
(
callOffset
wasm
:
:
SymbolicAddress
:
:
ToInt32
mozilla
:
:
Some
(
instanceOffset
)
)
;
}
else
{
using
Fn
=
int32_t
(
*
)
(
double
)
;
setupUnalignedABICall
(
dest
)
;
passABIArg
(
src
MoveOp
:
:
DOUBLE
)
;
callWithABI
<
Fn
JS
:
:
ToInt32
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
storeCallInt32Result
(
dest
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
|
|
\
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_LOONG64
)
#
elif
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
if
(
widenFloatToDouble
)
{
Pop
(
srcSingle
)
;
}
#
else
MOZ_CRASH
(
"
MacroAssembler
platform
hook
:
outOfLineTruncateSlow
"
)
;
#
endif
if
(
compilingWasm
)
{
Pop
(
InstanceReg
)
;
}
}
void
MacroAssembler
:
:
convertDoubleToInt
(
FloatRegister
src
Register
output
FloatRegister
temp
Label
*
truncateFail
Label
*
fail
IntConversionBehavior
behavior
)
{
switch
(
behavior
)
{
case
IntConversionBehavior
:
:
Normal
:
case
IntConversionBehavior
:
:
NegativeZeroCheck
:
convertDoubleToInt32
(
src
output
fail
behavior
=
=
IntConversionBehavior
:
:
NegativeZeroCheck
)
;
break
;
case
IntConversionBehavior
:
:
Truncate
:
branchTruncateDoubleMaybeModUint32
(
src
output
truncateFail
?
truncateFail
:
fail
)
;
break
;
case
IntConversionBehavior
:
:
TruncateNoWrap
:
branchTruncateDoubleToInt32
(
src
output
truncateFail
?
truncateFail
:
fail
)
;
break
;
case
IntConversionBehavior
:
:
ClampToUint8
:
if
(
src
!
=
temp
)
{
moveDouble
(
src
temp
)
;
}
clampDoubleToUint8
(
temp
output
)
;
break
;
}
}
void
MacroAssembler
:
:
convertValueToInt
(
ValueOperand
value
Label
*
handleStringEntry
Label
*
handleStringRejoin
Label
*
truncateDoubleSlow
Register
stringReg
FloatRegister
temp
Register
output
Label
*
fail
IntConversionBehavior
behavior
IntConversionInputKind
conversion
)
{
Label
done
isInt32
isBool
isDouble
isNull
isString
;
bool
handleStrings
=
(
behavior
=
=
IntConversionBehavior
:
:
Truncate
|
|
behavior
=
=
IntConversionBehavior
:
:
ClampToUint8
)
&
&
handleStringEntry
&
&
handleStringRejoin
;
MOZ_ASSERT_IF
(
handleStrings
conversion
=
=
IntConversionInputKind
:
:
Any
)
;
{
ScratchTagScope
tag
(
*
this
value
)
;
splitTagForTest
(
value
tag
)
;
branchTestInt32
(
Equal
tag
&
isInt32
)
;
if
(
conversion
=
=
IntConversionInputKind
:
:
Any
|
|
conversion
=
=
IntConversionInputKind
:
:
NumbersOrBoolsOnly
)
{
branchTestBoolean
(
Equal
tag
&
isBool
)
;
}
branchTestDouble
(
Equal
tag
&
isDouble
)
;
if
(
conversion
=
=
IntConversionInputKind
:
:
Any
)
{
switch
(
behavior
)
{
case
IntConversionBehavior
:
:
Normal
:
case
IntConversionBehavior
:
:
NegativeZeroCheck
:
branchTestNull
(
Assembler
:
:
NotEqual
tag
fail
)
;
break
;
case
IntConversionBehavior
:
:
Truncate
:
case
IntConversionBehavior
:
:
TruncateNoWrap
:
case
IntConversionBehavior
:
:
ClampToUint8
:
branchTestNull
(
Equal
tag
&
isNull
)
;
if
(
handleStrings
)
{
branchTestString
(
Equal
tag
&
isString
)
;
}
branchTestUndefined
(
Assembler
:
:
NotEqual
tag
fail
)
;
break
;
}
}
else
{
jump
(
fail
)
;
}
}
if
(
conversion
=
=
IntConversionInputKind
:
:
Any
)
{
if
(
isNull
.
used
(
)
)
{
bind
(
&
isNull
)
;
}
mov
(
ImmWord
(
0
)
output
)
;
jump
(
&
done
)
;
}
bool
handleStringIndices
=
handleStrings
&
&
output
!
=
stringReg
;
Label
handleStringIndex
;
if
(
handleStrings
)
{
bind
(
&
isString
)
;
unboxString
(
value
stringReg
)
;
if
(
handleStringIndices
)
{
loadStringIndexValue
(
stringReg
output
handleStringEntry
)
;
jump
(
&
handleStringIndex
)
;
}
else
{
jump
(
handleStringEntry
)
;
}
}
if
(
isDouble
.
used
(
)
|
|
handleStrings
)
{
if
(
isDouble
.
used
(
)
)
{
bind
(
&
isDouble
)
;
unboxDouble
(
value
temp
)
;
}
if
(
handleStrings
)
{
bind
(
handleStringRejoin
)
;
}
convertDoubleToInt
(
temp
output
temp
truncateDoubleSlow
fail
behavior
)
;
jump
(
&
done
)
;
}
if
(
isBool
.
used
(
)
)
{
bind
(
&
isBool
)
;
unboxBoolean
(
value
output
)
;
jump
(
&
done
)
;
}
if
(
isInt32
.
used
(
)
|
|
handleStringIndices
)
{
if
(
isInt32
.
used
(
)
)
{
bind
(
&
isInt32
)
;
unboxInt32
(
value
output
)
;
}
if
(
handleStringIndices
)
{
bind
(
&
handleStringIndex
)
;
}
if
(
behavior
=
=
IntConversionBehavior
:
:
ClampToUint8
)
{
clampIntToUint8
(
output
)
;
}
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
finish
(
)
{
if
(
failureLabel_
.
used
(
)
)
{
bind
(
&
failureLabel_
)
;
handleFailure
(
)
;
}
MacroAssemblerSpecific
:
:
finish
(
)
;
MOZ_RELEASE_ASSERT
(
size
(
)
<
=
MaxCodeBytesPerProcess
"
AssemblerBuffer
should
ensure
we
don
'
t
exceed
MaxCodeBytesPerProcess
"
)
;
if
(
bytesNeeded
(
)
>
MaxCodeBytesPerProcess
)
{
setOOM
(
)
;
}
}
void
MacroAssembler
:
:
link
(
JitCode
*
code
)
{
MOZ_ASSERT
(
!
oom
(
)
)
;
linkProfilerCallSites
(
code
)
;
}
MacroAssembler
:
:
AutoProfilerCallInstrumentation
:
:
AutoProfilerCallInstrumentation
(
MacroAssembler
&
masm
)
{
if
(
!
masm
.
emitProfilingInstrumentation_
)
{
return
;
}
Register
reg
=
CallTempReg0
;
Register
reg2
=
CallTempReg1
;
masm
.
push
(
reg
)
;
masm
.
push
(
reg2
)
;
CodeOffset
label
=
masm
.
movWithPatch
(
ImmWord
(
uintptr_t
(
-
1
)
)
reg
)
;
masm
.
loadJSContext
(
reg2
)
;
masm
.
loadPtr
(
Address
(
reg2
offsetof
(
JSContext
profilingActivation_
)
)
reg2
)
;
masm
.
storePtr
(
reg
Address
(
reg2
JitActivation
:
:
offsetOfLastProfilingCallSite
(
)
)
)
;
masm
.
appendProfilerCallSite
(
label
)
;
masm
.
pop
(
reg2
)
;
masm
.
pop
(
reg
)
;
}
void
MacroAssembler
:
:
linkProfilerCallSites
(
JitCode
*
code
)
{
for
(
size_t
i
=
0
;
i
<
profilerCallSites_
.
length
(
)
;
i
+
+
)
{
CodeOffset
offset
=
profilerCallSites_
[
i
]
;
CodeLocationLabel
location
(
code
offset
)
;
PatchDataWithValueCheck
(
location
ImmPtr
(
location
.
raw
(
)
)
ImmPtr
(
(
void
*
)
-
1
)
)
;
}
}
void
MacroAssembler
:
:
alignJitStackBasedOnNArgs
(
Register
nargs
bool
countIncludesThis
)
{
assertStackAlignment
(
sizeof
(
Value
)
0
)
;
static_assert
(
JitStackValueAlignment
=
=
1
|
|
JitStackValueAlignment
=
=
2
"
JitStackValueAlignment
is
either
1
or
2
.
"
)
;
if
(
JitStackValueAlignment
=
=
1
)
{
return
;
}
static_assert
(
sizeof
(
JitFrameLayout
)
%
JitStackAlignment
=
=
0
"
JitFrameLayout
doesn
'
t
affect
stack
alignment
"
)
;
Assembler
:
:
Condition
condition
=
countIncludesThis
?
Assembler
:
:
NonZero
:
Assembler
:
:
Zero
;
Label
alignmentIsOffset
end
;
branchTestPtr
(
condition
nargs
Imm32
(
1
)
&
alignmentIsOffset
)
;
andToStackPtr
(
Imm32
(
~
(
JitStackAlignment
-
1
)
)
)
;
jump
(
&
end
)
;
bind
(
&
alignmentIsOffset
)
;
branchTestStackPtr
(
Assembler
:
:
NonZero
Imm32
(
JitStackAlignment
-
1
)
&
end
)
;
subFromStackPtr
(
Imm32
(
sizeof
(
Value
)
)
)
;
bind
(
&
end
)
;
}
void
MacroAssembler
:
:
alignJitStackBasedOnNArgs
(
uint32_t
argc
)
{
assertStackAlignment
(
sizeof
(
Value
)
0
)
;
static_assert
(
JitStackValueAlignment
=
=
1
|
|
JitStackValueAlignment
=
=
2
"
JitStackValueAlignment
is
either
1
or
2
.
"
)
;
if
(
JitStackValueAlignment
=
=
1
)
{
return
;
}
uint32_t
nArgs
=
argc
+
1
;
if
(
nArgs
%
2
=
=
0
)
{
andToStackPtr
(
Imm32
(
~
(
JitStackAlignment
-
1
)
)
)
;
}
else
{
Label
end
;
branchTestStackPtr
(
Assembler
:
:
NonZero
Imm32
(
JitStackAlignment
-
1
)
&
end
)
;
subFromStackPtr
(
Imm32
(
sizeof
(
Value
)
)
)
;
bind
(
&
end
)
;
assertStackAlignment
(
JitStackAlignment
sizeof
(
Value
)
)
;
}
}
MacroAssembler
:
:
MacroAssembler
(
TempAllocator
&
alloc
CompileRuntime
*
maybeRuntime
CompileRealm
*
maybeRealm
)
:
maybeRuntime_
(
maybeRuntime
)
maybeRealm_
(
maybeRealm
)
wasmMaxOffsetGuardLimit_
(
0
)
framePushed_
(
0
)
#
ifdef
DEBUG
inCall_
(
false
)
#
endif
dynamicAlignment_
(
false
)
emitProfilingInstrumentation_
(
false
)
{
moveResolver_
.
setAllocator
(
alloc
)
;
}
StackMacroAssembler
:
:
StackMacroAssembler
(
JSContext
*
cx
TempAllocator
&
alloc
)
:
MacroAssembler
(
alloc
CompileRuntime
:
:
get
(
cx
-
>
runtime
(
)
)
CompileRealm
:
:
get
(
cx
-
>
realm
(
)
)
)
{
}
IonHeapMacroAssembler
:
:
IonHeapMacroAssembler
(
TempAllocator
&
alloc
CompileRealm
*
realm
)
:
MacroAssembler
(
alloc
realm
-
>
runtime
(
)
realm
)
{
MOZ_ASSERT
(
CurrentThreadIsIonCompiling
(
)
)
;
}
WasmMacroAssembler
:
:
WasmMacroAssembler
(
TempAllocator
&
alloc
bool
limitedSize
)
:
MacroAssembler
(
alloc
)
{
#
if
defined
(
JS_CODEGEN_ARM64
)
SetStackPointer64
(
sp
)
;
#
endif
if
(
!
limitedSize
)
{
setUnlimitedBuffer
(
)
;
}
}
WasmMacroAssembler
:
:
WasmMacroAssembler
(
TempAllocator
&
alloc
const
wasm
:
:
ModuleEnvironment
&
env
bool
limitedSize
)
:
MacroAssembler
(
alloc
)
{
#
if
defined
(
JS_CODEGEN_ARM64
)
SetStackPointer64
(
sp
)
;
#
endif
setWasmMaxOffsetGuardLimit
(
wasm
:
:
GetMaxOffsetGuardLimit
(
env
.
hugeMemoryEnabled
(
)
)
)
;
if
(
!
limitedSize
)
{
setUnlimitedBuffer
(
)
;
}
}
bool
MacroAssembler
:
:
icBuildOOLFakeExitFrame
(
void
*
fakeReturnAddr
AutoSaveLiveRegisters
&
save
)
{
return
buildOOLFakeExitFrame
(
fakeReturnAddr
)
;
}
#
ifndef
JS_CODEGEN_ARM64
void
MacroAssembler
:
:
subFromStackPtr
(
Register
reg
)
{
subPtr
(
reg
getStackPointer
(
)
)
;
}
#
endif
void
MacroAssembler
:
:
PushRegsInMask
(
LiveGeneralRegisterSet
set
)
{
PushRegsInMask
(
LiveRegisterSet
(
set
.
set
(
)
FloatRegisterSet
(
)
)
)
;
}
void
MacroAssembler
:
:
PopRegsInMask
(
LiveRegisterSet
set
)
{
PopRegsInMaskIgnore
(
set
LiveRegisterSet
(
)
)
;
}
void
MacroAssembler
:
:
PopRegsInMask
(
LiveGeneralRegisterSet
set
)
{
PopRegsInMask
(
LiveRegisterSet
(
set
.
set
(
)
FloatRegisterSet
(
)
)
)
;
}
void
MacroAssembler
:
:
Push
(
PropertyKey
key
Register
scratchReg
)
{
if
(
key
.
isGCThing
(
)
)
{
if
(
key
.
isString
(
)
)
{
JSString
*
str
=
key
.
toString
(
)
;
MOZ_ASSERT
(
(
uintptr_t
(
str
)
&
PropertyKey
:
:
TypeMask
)
=
=
0
)
;
static_assert
(
PropertyKey
:
:
StringTypeTag
=
=
0
"
need
to
orPtr
StringTypeTag
if
it
'
s
not
0
"
)
;
Push
(
ImmGCPtr
(
str
)
)
;
}
else
{
MOZ_ASSERT
(
key
.
isSymbol
(
)
)
;
movePropertyKey
(
key
scratchReg
)
;
Push
(
scratchReg
)
;
}
}
else
{
MOZ_ASSERT
(
key
.
isInt
(
)
)
;
Push
(
ImmWord
(
key
.
asRawBits
(
)
)
)
;
}
}
void
MacroAssembler
:
:
movePropertyKey
(
PropertyKey
key
Register
dest
)
{
if
(
key
.
isGCThing
(
)
)
{
if
(
key
.
isString
(
)
)
{
JSString
*
str
=
key
.
toString
(
)
;
MOZ_ASSERT
(
(
uintptr_t
(
str
)
&
PropertyKey
:
:
TypeMask
)
=
=
0
)
;
static_assert
(
PropertyKey
:
:
StringTypeTag
=
=
0
"
need
to
orPtr
JSID_TYPE_STRING
tag
if
it
'
s
not
0
"
)
;
movePtr
(
ImmGCPtr
(
str
)
dest
)
;
}
else
{
MOZ_ASSERT
(
key
.
isSymbol
(
)
)
;
JS
:
:
Symbol
*
sym
=
key
.
toSymbol
(
)
;
movePtr
(
ImmGCPtr
(
sym
)
dest
)
;
orPtr
(
Imm32
(
PropertyKey
:
:
SymbolTypeTag
)
dest
)
;
}
}
else
{
MOZ_ASSERT
(
key
.
isInt
(
)
)
;
movePtr
(
ImmWord
(
key
.
asRawBits
(
)
)
dest
)
;
}
}
void
MacroAssembler
:
:
Push
(
TypedOrValueRegister
v
)
{
if
(
v
.
hasValue
(
)
)
{
Push
(
v
.
valueReg
(
)
)
;
}
else
if
(
IsFloatingPointType
(
v
.
type
(
)
)
)
{
FloatRegister
reg
=
v
.
typedReg
(
)
.
fpu
(
)
;
if
(
v
.
type
(
)
=
=
MIRType
:
:
Float32
)
{
ScratchDoubleScope
fpscratch
(
*
this
)
;
convertFloat32ToDouble
(
reg
fpscratch
)
;
PushBoxed
(
fpscratch
)
;
}
else
{
PushBoxed
(
reg
)
;
}
}
else
{
Push
(
ValueTypeFromMIRType
(
v
.
type
(
)
)
v
.
typedReg
(
)
.
gpr
(
)
)
;
}
}
void
MacroAssembler
:
:
Push
(
const
ConstantOrRegister
&
v
)
{
if
(
v
.
constant
(
)
)
{
Push
(
v
.
value
(
)
)
;
}
else
{
Push
(
v
.
reg
(
)
)
;
}
}
void
MacroAssembler
:
:
Push
(
const
Address
&
addr
)
{
push
(
addr
)
;
framePushed_
+
=
sizeof
(
uintptr_t
)
;
}
void
MacroAssembler
:
:
Push
(
const
ValueOperand
&
val
)
{
pushValue
(
val
)
;
framePushed_
+
=
sizeof
(
Value
)
;
}
void
MacroAssembler
:
:
Push
(
const
Value
&
val
)
{
pushValue
(
val
)
;
framePushed_
+
=
sizeof
(
Value
)
;
}
void
MacroAssembler
:
:
Push
(
JSValueType
type
Register
reg
)
{
pushValue
(
type
reg
)
;
framePushed_
+
=
sizeof
(
Value
)
;
}
void
MacroAssembler
:
:
Push
(
const
Register64
reg
)
{
#
if
JS_BITS_PER_WORD
=
=
64
Push
(
reg
.
reg
)
;
#
else
MOZ_ASSERT
(
MOZ_LITTLE_ENDIAN
(
)
"
Big
-
endian
not
supported
.
"
)
;
Push
(
reg
.
high
)
;
Push
(
reg
.
low
)
;
#
endif
}
void
MacroAssembler
:
:
PushEmptyRooted
(
VMFunctionData
:
:
RootType
rootType
)
{
switch
(
rootType
)
{
case
VMFunctionData
:
:
RootNone
:
MOZ_CRASH
(
"
Handle
must
have
root
type
"
)
;
case
VMFunctionData
:
:
RootObject
:
case
VMFunctionData
:
:
RootString
:
case
VMFunctionData
:
:
RootCell
:
case
VMFunctionData
:
:
RootBigInt
:
Push
(
ImmPtr
(
nullptr
)
)
;
break
;
case
VMFunctionData
:
:
RootValue
:
Push
(
UndefinedValue
(
)
)
;
break
;
case
VMFunctionData
:
:
RootId
:
Push
(
ImmWord
(
JS
:
:
PropertyKey
:
:
Void
(
)
.
asRawBits
(
)
)
)
;
break
;
}
}
void
MacroAssembler
:
:
popRooted
(
VMFunctionData
:
:
RootType
rootType
Register
cellReg
const
ValueOperand
&
valueReg
)
{
switch
(
rootType
)
{
case
VMFunctionData
:
:
RootNone
:
MOZ_CRASH
(
"
Handle
must
have
root
type
"
)
;
case
VMFunctionData
:
:
RootObject
:
case
VMFunctionData
:
:
RootString
:
case
VMFunctionData
:
:
RootCell
:
case
VMFunctionData
:
:
RootId
:
case
VMFunctionData
:
:
RootBigInt
:
Pop
(
cellReg
)
;
break
;
case
VMFunctionData
:
:
RootValue
:
Pop
(
valueReg
)
;
break
;
}
}
void
MacroAssembler
:
:
adjustStack
(
int
amount
)
{
if
(
amount
>
0
)
{
freeStack
(
amount
)
;
}
else
if
(
amount
<
0
)
{
reserveStack
(
-
amount
)
;
}
}
void
MacroAssembler
:
:
freeStack
(
uint32_t
amount
)
{
MOZ_ASSERT
(
amount
<
=
framePushed_
)
;
if
(
amount
)
{
addToStackPtr
(
Imm32
(
amount
)
)
;
}
framePushed_
-
=
amount
;
}
void
MacroAssembler
:
:
freeStack
(
Register
amount
)
{
addToStackPtr
(
amount
)
;
}
template
<
class
ABIArgGeneratorT
>
void
MacroAssembler
:
:
setupABICallHelper
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
inCall_
)
;
inCall_
=
true
;
#
endif
#
ifdef
JS_SIMULATOR
signature_
=
0
;
#
endif
abiArgs_
=
ABIArgGeneratorT
(
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
#
if
defined
(
JS_SIMULATOR_ARM
)
abiArgs_
.
setUseHardFp
(
UseHardFpABI
(
)
)
;
#
elif
defined
(
JS_CODEGEN_ARM_HARDFP
)
abiArgs_
.
setUseHardFp
(
true
)
;
#
else
abiArgs_
.
setUseHardFp
(
false
)
;
#
endif
#
endif
#
if
defined
(
JS_CODEGEN_MIPS32
)
abiArgs_
.
enforceO32ABI
(
)
;
#
endif
}
void
MacroAssembler
:
:
setupNativeABICall
(
)
{
setupABICallHelper
<
ABIArgGenerator
>
(
)
;
}
void
MacroAssembler
:
:
setupWasmABICall
(
)
{
MOZ_ASSERT
(
IsCompilingWasm
(
)
"
non
-
wasm
should
use
setupAlignedABICall
"
)
;
setupABICallHelper
<
WasmABIArgGenerator
>
(
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
abiArgs_
.
setUseHardFp
(
true
)
;
#
endif
dynamicAlignment_
=
false
;
}
void
MacroAssembler
:
:
setupAlignedABICall
(
)
{
MOZ_ASSERT
(
!
IsCompilingWasm
(
)
"
wasm
should
use
setupWasmABICall
"
)
;
setupNativeABICall
(
)
;
dynamicAlignment_
=
false
;
}
void
MacroAssembler
:
:
passABIArg
(
const
MoveOperand
&
from
MoveOp
:
:
Type
type
)
{
MOZ_ASSERT
(
inCall_
)
;
appendSignatureType
(
type
)
;
ABIArg
arg
;
switch
(
type
)
{
case
MoveOp
:
:
FLOAT32
:
arg
=
abiArgs_
.
next
(
MIRType
:
:
Float32
)
;
break
;
case
MoveOp
:
:
DOUBLE
:
arg
=
abiArgs_
.
next
(
MIRType
:
:
Double
)
;
break
;
case
MoveOp
:
:
GENERAL
:
arg
=
abiArgs_
.
next
(
MIRType
:
:
Pointer
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
argument
type
"
)
;
}
MoveOperand
to
(
*
this
arg
)
;
if
(
from
=
=
to
)
{
return
;
}
if
(
oom
(
)
)
{
return
;
}
propagateOOM
(
moveResolver_
.
addMove
(
from
to
type
)
)
;
}
void
MacroAssembler
:
:
callWithABINoProfiler
(
void
*
fun
MoveOp
:
:
Type
result
CheckUnsafeCallWithABI
check
)
{
appendSignatureType
(
result
)
;
#
ifdef
JS_SIMULATOR
fun
=
Simulator
:
:
RedirectNativeFunction
(
fun
signature
(
)
)
;
#
endif
uint32_t
stackAdjust
;
callWithABIPre
(
&
stackAdjust
)
;
#
ifdef
DEBUG
if
(
check
=
=
CheckUnsafeCallWithABI
:
:
Check
)
{
push
(
ReturnReg
)
;
loadJSContext
(
ReturnReg
)
;
Address
flagAddr
(
ReturnReg
JSContext
:
:
offsetOfInUnsafeCallWithABI
(
)
)
;
store32
(
Imm32
(
1
)
flagAddr
)
;
pop
(
ReturnReg
)
;
}
#
endif
call
(
ImmPtr
(
fun
)
)
;
callWithABIPost
(
stackAdjust
result
)
;
#
ifdef
DEBUG
if
(
check
=
=
CheckUnsafeCallWithABI
:
:
Check
)
{
Label
ok
;
push
(
ReturnReg
)
;
loadJSContext
(
ReturnReg
)
;
Address
flagAddr
(
ReturnReg
JSContext
:
:
offsetOfInUnsafeCallWithABI
(
)
)
;
branch32
(
Assembler
:
:
Equal
flagAddr
Imm32
(
0
)
&
ok
)
;
assumeUnreachable
(
"
callWithABI
:
callee
did
not
use
AutoUnsafeCallWithABI
"
)
;
bind
(
&
ok
)
;
pop
(
ReturnReg
)
;
}
#
endif
}
CodeOffset
MacroAssembler
:
:
callWithABI
(
wasm
:
:
BytecodeOffset
bytecode
wasm
:
:
SymbolicAddress
imm
mozilla
:
:
Maybe
<
int32_t
>
instanceOffset
MoveOp
:
:
Type
result
)
{
MOZ_ASSERT
(
wasm
:
:
NeedsBuiltinThunk
(
imm
)
)
;
uint32_t
stackAdjust
;
callWithABIPre
(
&
stackAdjust
true
)
;
if
(
instanceOffset
)
{
loadPtr
(
Address
(
getStackPointer
(
)
*
instanceOffset
+
stackAdjust
)
InstanceReg
)
;
}
else
{
MOZ_CRASH
(
"
instanceOffset
is
Nothing
only
for
unsupported
abi
calls
.
"
)
;
}
CodeOffset
raOffset
=
call
(
wasm
:
:
CallSiteDesc
(
bytecode
.
offset
(
)
wasm
:
:
CallSite
:
:
Symbolic
)
imm
)
;
callWithABIPost
(
stackAdjust
result
true
)
;
return
raOffset
;
}
void
MacroAssembler
:
:
callDebugWithABI
(
wasm
:
:
SymbolicAddress
imm
MoveOp
:
:
Type
result
)
{
MOZ_ASSERT
(
!
wasm
:
:
NeedsBuiltinThunk
(
imm
)
)
;
uint32_t
stackAdjust
;
callWithABIPre
(
&
stackAdjust
false
)
;
call
(
imm
)
;
callWithABIPost
(
stackAdjust
result
false
)
;
}
void
MacroAssembler
:
:
linkExitFrame
(
Register
cxreg
Register
scratch
)
{
loadPtr
(
Address
(
cxreg
JSContext
:
:
offsetOfActivation
(
)
)
scratch
)
;
storeStackPtr
(
Address
(
scratch
JitActivation
:
:
offsetOfPackedExitFP
(
)
)
)
;
}
void
MacroAssembler
:
:
moveRegPair
(
Register
src0
Register
src1
Register
dst0
Register
dst1
MoveOp
:
:
Type
type
)
{
MoveResolver
&
moves
=
moveResolver
(
)
;
if
(
src0
!
=
dst0
)
{
propagateOOM
(
moves
.
addMove
(
MoveOperand
(
src0
)
MoveOperand
(
dst0
)
type
)
)
;
}
if
(
src1
!
=
dst1
)
{
propagateOOM
(
moves
.
addMove
(
MoveOperand
(
src1
)
MoveOperand
(
dst1
)
type
)
)
;
}
propagateOOM
(
moves
.
resolve
(
)
)
;
if
(
oom
(
)
)
{
return
;
}
MoveEmitter
emitter
(
*
this
)
;
emitter
.
emit
(
moves
)
;
emitter
.
finish
(
)
;
}
void
MacroAssembler
:
:
pow32
(
Register
base
Register
power
Register
dest
Register
temp1
Register
temp2
Label
*
onOver
)
{
move32
(
Imm32
(
1
)
dest
)
;
Label
done
;
branch32
(
Assembler
:
:
Equal
base
Imm32
(
1
)
&
done
)
;
move32
(
base
temp1
)
;
move32
(
power
temp2
)
;
Label
start
;
branchTest32
(
Assembler
:
:
NotSigned
power
power
&
start
)
;
jump
(
onOver
)
;
Label
loop
;
bind
(
&
loop
)
;
branchMul32
(
Assembler
:
:
Overflow
temp1
temp1
onOver
)
;
bind
(
&
start
)
;
Label
even
;
branchTest32
(
Assembler
:
:
Zero
temp2
Imm32
(
1
)
&
even
)
;
branchMul32
(
Assembler
:
:
Overflow
temp1
dest
onOver
)
;
bind
(
&
even
)
;
branchRshift32
(
Assembler
:
:
NonZero
Imm32
(
1
)
temp2
&
loop
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
signInt32
(
Register
input
Register
output
)
{
MOZ_ASSERT
(
input
!
=
output
)
;
Label
done
;
move32
(
input
output
)
;
rshift32Arithmetic
(
Imm32
(
31
)
output
)
;
branch32
(
Assembler
:
:
LessThanOrEqual
input
Imm32
(
0
)
&
done
)
;
move32
(
Imm32
(
1
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
signDouble
(
FloatRegister
input
FloatRegister
output
)
{
MOZ_ASSERT
(
input
!
=
output
)
;
Label
done
zeroOrNaN
negative
;
loadConstantDouble
(
0
.
0
output
)
;
branchDouble
(
Assembler
:
:
DoubleEqualOrUnordered
input
output
&
zeroOrNaN
)
;
branchDouble
(
Assembler
:
:
DoubleLessThan
input
output
&
negative
)
;
loadConstantDouble
(
1
.
0
output
)
;
jump
(
&
done
)
;
bind
(
&
negative
)
;
loadConstantDouble
(
-
1
.
0
output
)
;
jump
(
&
done
)
;
bind
(
&
zeroOrNaN
)
;
moveDouble
(
input
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
signDoubleToInt32
(
FloatRegister
input
Register
output
FloatRegister
temp
Label
*
fail
)
{
MOZ_ASSERT
(
input
!
=
temp
)
;
Label
done
zeroOrNaN
negative
;
loadConstantDouble
(
0
.
0
temp
)
;
branchDouble
(
Assembler
:
:
DoubleEqualOrUnordered
input
temp
&
zeroOrNaN
)
;
branchDouble
(
Assembler
:
:
DoubleLessThan
input
temp
&
negative
)
;
move32
(
Imm32
(
1
)
output
)
;
jump
(
&
done
)
;
bind
(
&
negative
)
;
move32
(
Imm32
(
-
1
)
output
)
;
jump
(
&
done
)
;
bind
(
&
zeroOrNaN
)
;
branchDouble
(
Assembler
:
:
DoubleUnordered
input
input
fail
)
;
loadConstantDouble
(
1
.
0
temp
)
;
divDouble
(
input
temp
)
;
branchDouble
(
Assembler
:
:
DoubleLessThan
temp
input
fail
)
;
move32
(
Imm32
(
0
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
randomDouble
(
Register
rng
FloatRegister
dest
Register64
temp0
Register64
temp1
)
{
using
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
;
static_assert
(
sizeof
(
XorShift128PlusRNG
)
=
=
2
*
sizeof
(
uint64_t
)
"
Code
below
assumes
XorShift128PlusRNG
contains
two
uint64_t
values
"
)
;
Address
state0Addr
(
rng
XorShift128PlusRNG
:
:
offsetOfState0
(
)
)
;
Address
state1Addr
(
rng
XorShift128PlusRNG
:
:
offsetOfState1
(
)
)
;
Register64
s0Reg
=
temp0
;
Register64
s1Reg
=
temp1
;
load64
(
state0Addr
s1Reg
)
;
move64
(
s1Reg
s0Reg
)
;
lshift64
(
Imm32
(
23
)
s1Reg
)
;
xor64
(
s0Reg
s1Reg
)
;
move64
(
s1Reg
s0Reg
)
;
rshift64
(
Imm32
(
17
)
s1Reg
)
;
xor64
(
s0Reg
s1Reg
)
;
load64
(
state1Addr
s0Reg
)
;
store64
(
s0Reg
state0Addr
)
;
xor64
(
s0Reg
s1Reg
)
;
rshift64
(
Imm32
(
26
)
s0Reg
)
;
xor64
(
s0Reg
s1Reg
)
;
store64
(
s1Reg
state1Addr
)
;
load64
(
state0Addr
s0Reg
)
;
add64
(
s0Reg
s1Reg
)
;
static
constexpr
int
MantissaBits
=
mozilla
:
:
FloatingPoint
<
double
>
:
:
kExponentShift
+
1
;
static
constexpr
double
ScaleInv
=
double
(
1
)
/
(
1ULL
<
<
MantissaBits
)
;
and64
(
Imm64
(
(
1ULL
<
<
MantissaBits
)
-
1
)
s1Reg
)
;
convertInt64ToDouble
(
s1Reg
dest
)
;
mulDoublePtr
(
ImmPtr
(
&
ScaleInv
)
s0Reg
.
scratchReg
(
)
dest
)
;
}
void
MacroAssembler
:
:
sameValueDouble
(
FloatRegister
left
FloatRegister
right
FloatRegister
temp
Register
dest
)
{
Label
nonEqual
isSameValue
isNotSameValue
;
branchDouble
(
Assembler
:
:
DoubleNotEqualOrUnordered
left
right
&
nonEqual
)
;
{
loadConstantDouble
(
0
.
0
temp
)
;
branchDouble
(
Assembler
:
:
DoubleNotEqual
left
temp
&
isSameValue
)
;
Label
isNegInf
;
loadConstantDouble
(
1
.
0
temp
)
;
divDouble
(
left
temp
)
;
branchDouble
(
Assembler
:
:
DoubleLessThan
temp
left
&
isNegInf
)
;
{
loadConstantDouble
(
1
.
0
temp
)
;
divDouble
(
right
temp
)
;
branchDouble
(
Assembler
:
:
DoubleGreaterThan
temp
right
&
isSameValue
)
;
jump
(
&
isNotSameValue
)
;
}
bind
(
&
isNegInf
)
;
{
loadConstantDouble
(
1
.
0
temp
)
;
divDouble
(
right
temp
)
;
branchDouble
(
Assembler
:
:
DoubleLessThan
temp
right
&
isSameValue
)
;
jump
(
&
isNotSameValue
)
;
}
}
bind
(
&
nonEqual
)
;
{
branchDouble
(
Assembler
:
:
DoubleOrdered
left
left
&
isNotSameValue
)
;
branchDouble
(
Assembler
:
:
DoubleOrdered
right
right
&
isNotSameValue
)
;
}
Label
done
;
bind
(
&
isSameValue
)
;
move32
(
Imm32
(
1
)
dest
)
;
jump
(
&
done
)
;
bind
(
&
isNotSameValue
)
;
move32
(
Imm32
(
0
)
dest
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
minMaxArrayInt32
(
Register
array
Register
result
Register
temp1
Register
temp2
Register
temp3
bool
isMax
Label
*
fail
)
{
Register
elements
=
temp1
;
loadPtr
(
Address
(
array
NativeObject
:
:
offsetOfElements
(
)
)
elements
)
;
Address
lengthAddr
(
elements
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
load32
(
lengthAddr
temp3
)
;
branchTest32
(
Assembler
:
:
Zero
temp3
temp3
fail
)
;
Register
elementsEnd
=
temp2
;
BaseObjectElementIndex
elementsEndAddr
(
elements
temp3
-
int32_t
(
sizeof
(
Value
)
)
)
;
computeEffectiveAddress
(
elementsEndAddr
elementsEnd
)
;
fallibleUnboxInt32
(
Address
(
elements
0
)
result
fail
)
;
Label
loop
done
;
bind
(
&
loop
)
;
branchPtr
(
Assembler
:
:
Equal
elements
elementsEnd
&
done
)
;
addPtr
(
Imm32
(
sizeof
(
Value
)
)
elements
)
;
fallibleUnboxInt32
(
Address
(
elements
0
)
temp3
fail
)
;
Assembler
:
:
Condition
cond
=
isMax
?
Assembler
:
:
GreaterThan
:
Assembler
:
:
LessThan
;
cmp32Move32
(
cond
temp3
result
temp3
result
)
;
jump
(
&
loop
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
minMaxArrayNumber
(
Register
array
FloatRegister
result
FloatRegister
floatTemp
Register
temp1
Register
temp2
bool
isMax
Label
*
fail
)
{
Register
elements
=
temp1
;
loadPtr
(
Address
(
array
NativeObject
:
:
offsetOfElements
(
)
)
elements
)
;
Label
isEmpty
;
Address
lengthAddr
(
elements
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
load32
(
lengthAddr
temp2
)
;
branchTest32
(
Assembler
:
:
Zero
temp2
temp2
&
isEmpty
)
;
Register
elementsEnd
=
temp2
;
BaseObjectElementIndex
elementsEndAddr
(
elements
temp2
-
int32_t
(
sizeof
(
Value
)
)
)
;
computeEffectiveAddress
(
elementsEndAddr
elementsEnd
)
;
ensureDouble
(
Address
(
elements
0
)
result
fail
)
;
Label
loop
done
;
bind
(
&
loop
)
;
branchPtr
(
Assembler
:
:
Equal
elements
elementsEnd
&
done
)
;
addPtr
(
Imm32
(
sizeof
(
Value
)
)
elements
)
;
ensureDouble
(
Address
(
elements
0
)
floatTemp
fail
)
;
if
(
isMax
)
{
maxDouble
(
floatTemp
result
true
)
;
}
else
{
minDouble
(
floatTemp
result
true
)
;
}
jump
(
&
loop
)
;
bind
(
&
isEmpty
)
;
if
(
isMax
)
{
loadConstantDouble
(
mozilla
:
:
NegativeInfinity
<
double
>
(
)
result
)
;
}
else
{
loadConstantDouble
(
mozilla
:
:
PositiveInfinity
<
double
>
(
)
result
)
;
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
branchIfNotRegExpPrototypeOptimizable
(
Register
proto
Register
temp
Label
*
fail
)
{
loadJSContext
(
temp
)
;
loadPtr
(
Address
(
temp
JSContext
:
:
offsetOfRealm
(
)
)
temp
)
;
size_t
offset
=
Realm
:
:
offsetOfRegExps
(
)
+
RegExpRealm
:
:
offsetOfOptimizableRegExpPrototypeShape
(
)
;
loadPtr
(
Address
(
temp
offset
)
temp
)
;
branchTestObjShapeUnsafe
(
Assembler
:
:
NotEqual
proto
temp
fail
)
;
}
void
MacroAssembler
:
:
branchIfNotRegExpInstanceOptimizable
(
Register
regexp
Register
temp
Label
*
label
)
{
loadJSContext
(
temp
)
;
loadPtr
(
Address
(
temp
JSContext
:
:
offsetOfRealm
(
)
)
temp
)
;
size_t
offset
=
Realm
:
:
offsetOfRegExps
(
)
+
RegExpRealm
:
:
offsetOfOptimizableRegExpInstanceShape
(
)
;
loadPtr
(
Address
(
temp
offset
)
temp
)
;
branchTestObjShapeUnsafe
(
Assembler
:
:
NotEqual
regexp
temp
label
)
;
}
void
MacroAssembler
:
:
loadFunctionLength
(
Register
func
Register
funFlagsAndArgCount
Register
output
Label
*
slowPath
)
{
#
ifdef
DEBUG
{
Label
ok
;
uint32_t
FlagsToCheck
=
FunctionFlags
:
:
SELFHOSTLAZY
|
FunctionFlags
:
:
RESOLVED_LENGTH
;
branchTest32
(
Assembler
:
:
Zero
funFlagsAndArgCount
Imm32
(
FlagsToCheck
)
&
ok
)
;
assumeUnreachable
(
"
The
function
flags
should
already
have
been
checked
.
"
)
;
bind
(
&
ok
)
;
}
#
endif
Label
isInterpreted
isBound
lengthLoaded
;
branchTest32
(
Assembler
:
:
NonZero
funFlagsAndArgCount
Imm32
(
FunctionFlags
:
:
BOUND_FUN
)
&
isBound
)
;
branchTest32
(
Assembler
:
:
NonZero
funFlagsAndArgCount
Imm32
(
FunctionFlags
:
:
BASESCRIPT
)
&
isInterpreted
)
;
{
move32
(
funFlagsAndArgCount
output
)
;
rshift32
(
Imm32
(
JSFunction
:
:
ArgCountShift
)
output
)
;
jump
(
&
lengthLoaded
)
;
}
bind
(
&
isBound
)
;
{
Address
boundLength
(
func
FunctionExtended
:
:
offsetOfBoundFunctionLengthSlot
(
)
)
;
fallibleUnboxInt32
(
boundLength
output
slowPath
)
;
jump
(
&
lengthLoaded
)
;
}
bind
(
&
isInterpreted
)
;
{
loadPrivate
(
Address
(
func
JSFunction
:
:
offsetOfJitInfoOrScript
(
)
)
output
)
;
loadPtr
(
Address
(
output
JSScript
:
:
offsetOfSharedData
(
)
)
output
)
;
branchTestPtr
(
Assembler
:
:
Zero
output
output
slowPath
)
;
loadPtr
(
Address
(
output
SharedImmutableScriptData
:
:
offsetOfISD
(
)
)
output
)
;
load16ZeroExtend
(
Address
(
output
ImmutableScriptData
:
:
offsetOfFunLength
(
)
)
output
)
;
}
bind
(
&
lengthLoaded
)
;
}
void
MacroAssembler
:
:
loadFunctionName
(
Register
func
Register
output
ImmGCPtr
emptyString
Label
*
slowPath
)
{
MOZ_ASSERT
(
func
!
=
output
)
;
load32
(
Address
(
func
JSFunction
:
:
offsetOfFlagsAndArgCount
(
)
)
output
)
;
branchTest32
(
Assembler
:
:
NonZero
output
Imm32
(
FunctionFlags
:
:
RESOLVED_NAME
)
slowPath
)
;
Label
notBoundTarget
loadName
;
branchTest32
(
Assembler
:
:
Zero
output
Imm32
(
FunctionFlags
:
:
BOUND_FUN
)
&
notBoundTarget
)
;
{
branchTest32
(
Assembler
:
:
Zero
output
Imm32
(
FunctionFlags
:
:
HAS_BOUND_FUNCTION_NAME_PREFIX
)
slowPath
)
;
static_assert
(
FunctionFlags
:
:
HAS_BOUND_FUNCTION_NAME_PREFIX
=
=
FunctionFlags
:
:
HAS_GUESSED_ATOM
"
HAS_BOUND_FUNCTION_NAME_PREFIX
is
shared
with
HAS_GUESSED_ATOM
"
)
;
jump
(
&
loadName
)
;
}
bind
(
&
notBoundTarget
)
;
Label
noName
done
;
branchTest32
(
Assembler
:
:
NonZero
output
Imm32
(
FunctionFlags
:
:
HAS_GUESSED_ATOM
)
&
noName
)
;
bind
(
&
loadName
)
;
Address
atomAddr
(
func
JSFunction
:
:
offsetOfAtom
(
)
)
;
branchTestUndefined
(
Assembler
:
:
Equal
atomAddr
&
noName
)
;
unboxString
(
atomAddr
output
)
;
jump
(
&
done
)
;
{
bind
(
&
noName
)
;
movePtr
(
emptyString
output
)
;
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
assertFunctionIsExtended
(
Register
func
)
{
#
ifdef
DEBUG
Label
extended
;
branchTestFunctionFlags
(
func
FunctionFlags
:
:
EXTENDED
Assembler
:
:
NonZero
&
extended
)
;
assumeUnreachable
(
"
Function
is
not
extended
"
)
;
bind
(
&
extended
)
;
#
endif
}
void
MacroAssembler
:
:
branchTestType
(
Condition
cond
Register
tag
JSValueType
type
Label
*
label
)
{
switch
(
type
)
{
case
JSVAL_TYPE_DOUBLE
:
branchTestDouble
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_INT32
:
branchTestInt32
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_BOOLEAN
:
branchTestBoolean
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_UNDEFINED
:
branchTestUndefined
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_NULL
:
branchTestNull
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_MAGIC
:
branchTestMagic
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_STRING
:
branchTestString
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_SYMBOL
:
branchTestSymbol
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_BIGINT
:
branchTestBigInt
(
cond
tag
label
)
;
break
;
case
JSVAL_TYPE_OBJECT
:
branchTestObject
(
cond
tag
label
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
value
type
"
)
;
}
}
void
MacroAssembler
:
:
branchTestObjCompartment
(
Condition
cond
Register
obj
const
Address
&
compartment
Register
scratch
Label
*
label
)
{
MOZ_ASSERT
(
obj
!
=
scratch
)
;
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
Shape
:
:
offsetOfBaseShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
BaseShape
:
:
offsetOfRealm
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
Realm
:
:
offsetOfCompartment
(
)
)
scratch
)
;
branchPtr
(
cond
compartment
scratch
label
)
;
}
void
MacroAssembler
:
:
branchTestObjCompartment
(
Condition
cond
Register
obj
const
JS
:
:
Compartment
*
compartment
Register
scratch
Label
*
label
)
{
MOZ_ASSERT
(
obj
!
=
scratch
)
;
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
Shape
:
:
offsetOfBaseShape
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
BaseShape
:
:
offsetOfRealm
(
)
)
scratch
)
;
loadPtr
(
Address
(
scratch
Realm
:
:
offsetOfCompartment
(
)
)
scratch
)
;
branchPtr
(
cond
scratch
ImmPtr
(
compartment
)
label
)
;
}
void
MacroAssembler
:
:
branchIfNonNativeObj
(
Register
obj
Register
scratch
Label
*
label
)
{
loadObjClassUnsafe
(
obj
scratch
)
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
scratch
JSClass
:
:
offsetOfFlags
(
)
)
Imm32
(
JSClass
:
:
NON_NATIVE
)
label
)
;
}
void
MacroAssembler
:
:
branchIfObjectNotExtensible
(
Register
obj
Register
scratch
Label
*
label
)
{
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch
)
;
static_assert
(
sizeof
(
ObjectFlags
)
=
=
sizeof
(
uint16_t
)
)
;
load16ZeroExtend
(
Address
(
scratch
Shape
:
:
offsetOfObjectFlags
(
)
)
scratch
)
;
branchTest32
(
Assembler
:
:
NonZero
scratch
Imm32
(
uint32_t
(
ObjectFlag
:
:
NotExtensible
)
)
label
)
;
}
void
MacroAssembler
:
:
wasmTrap
(
wasm
:
:
Trap
trap
wasm
:
:
BytecodeOffset
bytecodeOffset
)
{
uint32_t
trapOffset
=
wasmTrapInstruction
(
)
.
offset
(
)
;
MOZ_ASSERT_IF
(
!
oom
(
)
currentOffset
(
)
-
trapOffset
=
=
WasmTrapInstructionLength
)
;
append
(
trap
wasm
:
:
TrapSite
(
trapOffset
bytecodeOffset
)
)
;
}
std
:
:
pair
<
CodeOffset
uint32_t
>
MacroAssembler
:
:
wasmReserveStackChecked
(
uint32_t
amount
wasm
:
:
BytecodeOffset
trapOffset
)
{
if
(
amount
>
MAX_UNCHECKED_LEAF_FRAME_SIZE
)
{
Label
ok
;
Register
scratch
=
ABINonArgReg0
;
moveStackPtrTo
(
scratch
)
;
Label
trap
;
branchPtr
(
Assembler
:
:
Below
scratch
Imm32
(
amount
)
&
trap
)
;
subPtr
(
Imm32
(
amount
)
scratch
)
;
branchPtr
(
Assembler
:
:
Below
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfStackLimit
(
)
)
scratch
&
ok
)
;
bind
(
&
trap
)
;
wasmTrap
(
wasm
:
:
Trap
:
:
StackOverflow
trapOffset
)
;
CodeOffset
trapInsnOffset
=
CodeOffset
(
currentOffset
(
)
)
;
bind
(
&
ok
)
;
reserveStack
(
amount
)
;
return
std
:
:
pair
<
CodeOffset
uint32_t
>
(
trapInsnOffset
0
)
;
}
reserveStack
(
amount
)
;
Label
ok
;
branchStackPtrRhs
(
Assembler
:
:
Below
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfStackLimit
(
)
)
&
ok
)
;
wasmTrap
(
wasm
:
:
Trap
:
:
StackOverflow
trapOffset
)
;
CodeOffset
trapInsnOffset
=
CodeOffset
(
currentOffset
(
)
)
;
bind
(
&
ok
)
;
return
std
:
:
pair
<
CodeOffset
uint32_t
>
(
trapInsnOffset
amount
)
;
}
void
MacroAssembler
:
:
loadWasmGlobalPtr
(
uint32_t
globalDataOffset
Register
dest
)
{
loadPtr
(
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfGlobalArea
(
)
+
globalDataOffset
)
dest
)
;
}
CodeOffset
MacroAssembler
:
:
wasmCallImport
(
const
wasm
:
:
CallSiteDesc
&
desc
const
wasm
:
:
CalleeDesc
&
callee
)
{
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
)
;
uint32_t
globalDataOffset
=
callee
.
importGlobalDataOffset
(
)
;
loadWasmGlobalPtr
(
globalDataOffset
+
offsetof
(
wasm
:
:
FuncImportInstanceData
code
)
ABINonArgReg0
)
;
#
if
!
defined
(
JS_CODEGEN_NONE
)
&
&
!
defined
(
JS_CODEGEN_WASM32
)
static_assert
(
ABINonArgReg0
!
=
InstanceReg
"
by
constraint
"
)
;
#
endif
loadWasmGlobalPtr
(
globalDataOffset
+
offsetof
(
wasm
:
:
FuncImportInstanceData
realm
)
ABINonArgReg1
)
;
loadPtr
(
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfCx
(
)
)
ABINonArgReg2
)
;
storePtr
(
ABINonArgReg1
Address
(
ABINonArgReg2
JSContext
:
:
offsetOfRealm
(
)
)
)
;
loadWasmGlobalPtr
(
globalDataOffset
+
offsetof
(
wasm
:
:
FuncImportInstanceData
instance
)
InstanceReg
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
loadWasmPinnedRegsFromInstance
(
)
;
return
call
(
desc
ABINonArgReg0
)
;
}
CodeOffset
MacroAssembler
:
:
wasmCallBuiltinInstanceMethod
(
const
wasm
:
:
CallSiteDesc
&
desc
const
ABIArg
&
instanceArg
wasm
:
:
SymbolicAddress
builtin
wasm
:
:
FailureMode
failureMode
)
{
MOZ_ASSERT
(
instanceArg
!
=
ABIArg
(
)
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
if
(
instanceArg
.
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
movePtr
(
InstanceReg
instanceArg
.
gpr
(
)
)
;
}
else
if
(
instanceArg
.
kind
(
)
=
=
ABIArg
:
:
Stack
)
{
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
instanceArg
.
offsetFromArgBase
(
)
)
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
abi
passing
style
for
pointer
"
)
;
}
CodeOffset
ret
=
call
(
desc
builtin
)
;
if
(
failureMode
!
=
wasm
:
:
FailureMode
:
:
Infallible
)
{
Label
noTrap
;
switch
(
failureMode
)
{
case
wasm
:
:
FailureMode
:
:
Infallible
:
MOZ_CRASH
(
)
;
case
wasm
:
:
FailureMode
:
:
FailOnNegI32
:
branchTest32
(
Assembler
:
:
NotSigned
ReturnReg
ReturnReg
&
noTrap
)
;
break
;
case
wasm
:
:
FailureMode
:
:
FailOnNullPtr
:
branchTestPtr
(
Assembler
:
:
NonZero
ReturnReg
ReturnReg
&
noTrap
)
;
break
;
case
wasm
:
:
FailureMode
:
:
FailOnInvalidRef
:
branchPtr
(
Assembler
:
:
NotEqual
ReturnReg
ImmWord
(
uintptr_t
(
wasm
:
:
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
)
&
noTrap
)
;
break
;
}
wasmTrap
(
wasm
:
:
Trap
:
:
ThrowReported
wasm
:
:
BytecodeOffset
(
desc
.
lineOrBytecode
(
)
)
)
;
bind
(
&
noTrap
)
;
}
return
ret
;
}
CodeOffset
MacroAssembler
:
:
asmCallIndirect
(
const
wasm
:
:
CallSiteDesc
&
desc
const
wasm
:
:
CalleeDesc
&
callee
)
{
MOZ_ASSERT
(
callee
.
which
(
)
=
=
wasm
:
:
CalleeDesc
:
:
AsmJSTable
)
;
const
Register
scratch
=
WasmTableCallScratchReg0
;
const
Register
index
=
WasmTableCallIndexReg
;
static_assert
(
sizeof
(
wasm
:
:
FunctionTableElem
)
=
=
8
|
|
sizeof
(
wasm
:
:
FunctionTableElem
)
=
=
16
"
elements
of
function
tables
are
two
words
"
)
;
loadWasmGlobalPtr
(
callee
.
tableFunctionBaseGlobalDataOffset
(
)
scratch
)
;
if
(
sizeof
(
wasm
:
:
FunctionTableElem
)
=
=
8
)
{
computeEffectiveAddress
(
BaseIndex
(
scratch
index
TimesEight
)
scratch
)
;
}
else
{
lshift32
(
Imm32
(
4
)
index
)
;
addPtr
(
index
scratch
)
;
}
loadPtr
(
Address
(
scratch
offsetof
(
wasm
:
:
FunctionTableElem
code
)
)
scratch
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
return
call
(
desc
scratch
)
;
}
void
MacroAssembler
:
:
wasmCallIndirect
(
const
wasm
:
:
CallSiteDesc
&
desc
const
wasm
:
:
CalleeDesc
&
callee
Label
*
boundsCheckFailedLabel
Label
*
nullCheckFailedLabel
mozilla
:
:
Maybe
<
uint32_t
>
tableSize
CodeOffset
*
fastCallOffset
CodeOffset
*
slowCallOffset
)
{
static_assert
(
sizeof
(
wasm
:
:
FunctionTableElem
)
=
=
2
*
sizeof
(
void
*
)
"
Exactly
two
pointers
or
index
scaling
won
'
t
work
correctly
"
)
;
MOZ_ASSERT
(
callee
.
which
(
)
=
=
wasm
:
:
CalleeDesc
:
:
WasmTable
)
;
const
int
shift
=
sizeof
(
wasm
:
:
FunctionTableElem
)
=
=
8
?
3
:
4
;
wasm
:
:
BytecodeOffset
trapOffset
(
desc
.
lineOrBytecode
(
)
)
;
const
Register
calleeScratch
=
WasmTableCallScratchReg0
;
const
Register
index
=
WasmTableCallIndexReg
;
if
(
boundsCheckFailedLabel
)
{
if
(
tableSize
.
isSome
(
)
)
{
branch32
(
Assembler
:
:
Condition
:
:
AboveOrEqual
index
Imm32
(
*
tableSize
)
boundsCheckFailedLabel
)
;
}
else
{
branch32
(
Assembler
:
:
Condition
:
:
BelowOrEqual
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfGlobalArea
(
)
+
callee
.
tableLengthGlobalDataOffset
(
)
)
index
boundsCheckFailedLabel
)
;
}
}
const
wasm
:
:
TypeIdDesc
funcTypeId
=
callee
.
wasmTableSigId
(
)
;
switch
(
funcTypeId
.
kind
(
)
)
{
case
wasm
:
:
TypeIdDescKind
:
:
Global
:
loadWasmGlobalPtr
(
funcTypeId
.
globalDataOffset
(
)
WasmTableCallSigReg
)
;
break
;
case
wasm
:
:
TypeIdDescKind
:
:
Immediate
:
move32
(
Imm32
(
funcTypeId
.
immediate
(
)
)
WasmTableCallSigReg
)
;
break
;
case
wasm
:
:
TypeIdDescKind
:
:
None
:
break
;
}
loadWasmGlobalPtr
(
callee
.
tableFunctionBaseGlobalDataOffset
(
)
calleeScratch
)
;
shiftIndex32AndAdd
(
index
shift
calleeScratch
)
;
Label
fastCall
;
Label
done
;
const
Register
newInstanceTemp
=
WasmTableCallScratchReg1
;
loadPtr
(
Address
(
calleeScratch
offsetof
(
wasm
:
:
FunctionTableElem
instance
)
)
newInstanceTemp
)
;
branchPtr
(
Assembler
:
:
Equal
InstanceReg
newInstanceTemp
&
fastCall
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
)
;
movePtr
(
newInstanceTemp
InstanceReg
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
#
ifdef
WASM_HAS_HEAPREG
MOZ_ASSERT
(
nullCheckFailedLabel
=
=
nullptr
)
;
loadWasmPinnedRegsFromInstance
(
mozilla
:
:
Some
(
trapOffset
)
)
;
#
else
MOZ_ASSERT
(
nullCheckFailedLabel
!
=
nullptr
)
;
branchTestPtr
(
Assembler
:
:
Zero
InstanceReg
InstanceReg
nullCheckFailedLabel
)
;
loadWasmPinnedRegsFromInstance
(
)
;
#
endif
switchToWasmInstanceRealm
(
index
WasmTableCallScratchReg1
)
;
loadPtr
(
Address
(
calleeScratch
offsetof
(
wasm
:
:
FunctionTableElem
code
)
)
calleeScratch
)
;
*
slowCallOffset
=
call
(
desc
calleeScratch
)
;
loadPtr
(
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
InstanceReg
)
;
loadWasmPinnedRegsFromInstance
(
)
;
switchToWasmInstanceRealm
(
ABINonArgReturnReg0
ABINonArgReturnReg1
)
;
jump
(
&
done
)
;
bind
(
&
fastCall
)
;
loadPtr
(
Address
(
calleeScratch
offsetof
(
wasm
:
:
FunctionTableElem
code
)
)
calleeScratch
)
;
wasm
:
:
CallSiteDesc
newDesc
(
desc
.
lineOrBytecode
(
)
wasm
:
:
CallSiteDesc
:
:
IndirectFast
)
;
*
fastCallOffset
=
call
(
newDesc
calleeScratch
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
wasmCallRef
(
const
wasm
:
:
CallSiteDesc
&
desc
const
wasm
:
:
CalleeDesc
&
callee
CodeOffset
*
fastCallOffset
CodeOffset
*
slowCallOffset
)
{
MOZ_ASSERT
(
callee
.
which
(
)
=
=
wasm
:
:
CalleeDesc
:
:
FuncRef
)
;
const
Register
calleeScratch
=
WasmCallRefCallScratchReg0
;
const
Register
calleeFnObj
=
WasmCallRefReg
;
Label
fastCall
;
Label
done
;
const
Register
newInstanceTemp
=
WasmCallRefCallScratchReg1
;
size_t
instanceSlotOffset
=
FunctionExtended
:
:
offsetOfExtendedSlot
(
FunctionExtended
:
:
WASM_INSTANCE_SLOT
)
;
loadPtr
(
Address
(
calleeFnObj
instanceSlotOffset
)
newInstanceTemp
)
;
branchPtr
(
Assembler
:
:
Equal
InstanceReg
newInstanceTemp
&
fastCall
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
)
;
movePtr
(
newInstanceTemp
InstanceReg
)
;
storePtr
(
InstanceReg
Address
(
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
loadWasmPinnedRegsFromInstance
(
)
;
switchToWasmInstanceRealm
(
WasmCallRefCallScratchReg0
WasmCallRefCallScratchReg1
)
;
size_t
uncheckedEntrySlotOffset
=
FunctionExtended
:
:
offsetOfExtendedSlot
(
FunctionExtended
:
:
WASM_FUNC_UNCHECKED_ENTRY_SLOT
)
;
loadPtr
(
Address
(
calleeFnObj
uncheckedEntrySlotOffset
)
calleeScratch
)
;
*
slowCallOffset
=
call
(
desc
calleeScratch
)
;
loadPtr
(
Address
(
getStackPointer
(
)
WasmCallerInstanceOffsetBeforeCall
)
InstanceReg
)
;
loadWasmPinnedRegsFromInstance
(
)
;
switchToWasmInstanceRealm
(
ABINonArgReturnReg0
ABINonArgReturnReg1
)
;
jump
(
&
done
)
;
bind
(
&
fastCall
)
;
loadPtr
(
Address
(
calleeFnObj
uncheckedEntrySlotOffset
)
calleeScratch
)
;
wasm
:
:
CallSiteDesc
newDesc
(
desc
.
lineOrBytecode
(
)
wasm
:
:
CallSiteDesc
:
:
FuncRefFast
)
;
*
fastCallOffset
=
call
(
newDesc
calleeScratch
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
nopPatchableToCall
(
const
wasm
:
:
CallSiteDesc
&
desc
)
{
CodeOffset
offset
=
nopPatchableToCall
(
)
;
append
(
desc
offset
)
;
}
void
MacroAssembler
:
:
emitPreBarrierFastPath
(
JSRuntime
*
rt
MIRType
type
Register
temp1
Register
temp2
Register
temp3
Label
*
noBarrier
)
{
MOZ_ASSERT
(
temp1
!
=
PreBarrierReg
)
;
MOZ_ASSERT
(
temp2
!
=
PreBarrierReg
)
;
MOZ_ASSERT
(
temp3
!
=
PreBarrierReg
)
;
if
(
type
=
=
MIRType
:
:
Value
)
{
unboxGCThingForGCBarrier
(
Address
(
PreBarrierReg
0
)
temp1
)
;
}
else
{
MOZ_ASSERT
(
type
=
=
MIRType
:
:
Object
|
|
type
=
=
MIRType
:
:
String
|
|
type
=
=
MIRType
:
:
Shape
)
;
loadPtr
(
Address
(
PreBarrierReg
0
)
temp1
)
;
}
#
ifdef
DEBUG
Label
nonZero
;
branchTestPtr
(
Assembler
:
:
NonZero
temp1
temp1
&
nonZero
)
;
assumeUnreachable
(
"
JIT
pre
-
barrier
:
unexpected
nullptr
"
)
;
bind
(
&
nonZero
)
;
#
endif
movePtr
(
ImmWord
(
~
gc
:
:
ChunkMask
)
temp2
)
;
andPtr
(
temp1
temp2
)
;
if
(
type
=
=
MIRType
:
:
Value
|
|
type
=
=
MIRType
:
:
Object
|
|
type
=
=
MIRType
:
:
String
)
{
branchPtr
(
Assembler
:
:
NotEqual
Address
(
temp2
gc
:
:
ChunkStoreBufferOffset
)
ImmWord
(
0
)
noBarrier
)
;
}
else
{
#
ifdef
DEBUG
Label
isTenured
;
branchPtr
(
Assembler
:
:
Equal
Address
(
temp2
gc
:
:
ChunkStoreBufferOffset
)
ImmWord
(
0
)
&
isTenured
)
;
assumeUnreachable
(
"
JIT
pre
-
barrier
:
unexpected
nursery
pointer
"
)
;
bind
(
&
isTenured
)
;
#
endif
}
static_assert
(
gc
:
:
CellBytesPerMarkBit
=
=
8
"
Calculation
below
relies
on
this
"
)
;
static_assert
(
size_t
(
gc
:
:
ColorBit
:
:
BlackBit
)
=
=
0
"
Calculation
below
relies
on
this
"
)
;
andPtr
(
Imm32
(
gc
:
:
ChunkMask
)
temp1
)
;
rshiftPtr
(
Imm32
(
3
)
temp1
)
;
static_assert
(
gc
:
:
MarkBitmapWordBits
=
=
JS_BITS_PER_WORD
"
Calculation
below
relies
on
this
"
)
;
const
size_t
firstArenaAdjustment
=
gc
:
:
FirstArenaAdjustmentBits
/
CHAR_BIT
;
const
intptr_t
offset
=
intptr_t
(
gc
:
:
ChunkMarkBitmapOffset
)
-
intptr_t
(
firstArenaAdjustment
)
;
movePtr
(
temp1
temp3
)
;
#
if
JS_BITS_PER_WORD
=
=
64
rshiftPtr
(
Imm32
(
6
)
temp1
)
;
loadPtr
(
BaseIndex
(
temp2
temp1
TimesEight
offset
)
temp2
)
;
#
else
rshiftPtr
(
Imm32
(
5
)
temp1
)
;
loadPtr
(
BaseIndex
(
temp2
temp1
TimesFour
offset
)
temp2
)
;
#
endif
andPtr
(
Imm32
(
gc
:
:
MarkBitmapWordBits
-
1
)
temp3
)
;
move32
(
Imm32
(
1
)
temp1
)
;
#
ifdef
JS_CODEGEN_X64
MOZ_ASSERT
(
temp3
=
=
rcx
)
;
shlq_cl
(
temp1
)
;
#
elif
JS_CODEGEN_X86
MOZ_ASSERT
(
temp3
=
=
ecx
)
;
shll_cl
(
temp1
)
;
#
elif
JS_CODEGEN_ARM
ma_lsl
(
temp3
temp1
temp1
)
;
#
elif
JS_CODEGEN_ARM64
Lsl
(
ARMRegister
(
temp1
64
)
ARMRegister
(
temp1
64
)
ARMRegister
(
temp3
64
)
)
;
#
elif
JS_CODEGEN_MIPS32
ma_sll
(
temp1
temp1
temp3
)
;
#
elif
JS_CODEGEN_MIPS64
ma_dsll
(
temp1
temp1
temp3
)
;
#
elif
JS_CODEGEN_LOONG64
as_sll_d
(
temp1
temp1
temp3
)
;
#
elif
JS_CODEGEN_WASM32
MOZ_CRASH
(
)
;
#
elif
JS_CODEGEN_NONE
MOZ_CRASH
(
)
;
#
else
#
error
"
Unknown
architecture
"
#
endif
branchTestPtr
(
Assembler
:
:
NonZero
temp2
temp1
noBarrier
)
;
}
void
MacroAssembler
:
:
atomicIsLockFreeJS
(
Register
value
Register
output
)
{
static_assert
(
AtomicOperations
:
:
isLockfreeJS
(
1
)
)
;
static_assert
(
AtomicOperations
:
:
isLockfreeJS
(
2
)
)
;
static_assert
(
AtomicOperations
:
:
isLockfreeJS
(
4
)
)
;
static_assert
(
AtomicOperations
:
:
isLockfreeJS
(
8
)
)
;
Label
done
;
move32
(
Imm32
(
1
)
output
)
;
branch32
(
Assembler
:
:
Equal
value
Imm32
(
8
)
&
done
)
;
branch32
(
Assembler
:
:
Equal
value
Imm32
(
4
)
&
done
)
;
branch32
(
Assembler
:
:
Equal
value
Imm32
(
2
)
&
done
)
;
branch32
(
Assembler
:
:
Equal
value
Imm32
(
1
)
&
done
)
;
move32
(
Imm32
(
0
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
spectreMaskIndex32
(
Register
index
Register
length
Register
output
)
{
MOZ_ASSERT
(
JitOptions
.
spectreIndexMasking
)
;
MOZ_ASSERT
(
length
!
=
output
)
;
MOZ_ASSERT
(
index
!
=
output
)
;
move32
(
Imm32
(
0
)
output
)
;
cmp32Move32
(
Assembler
:
:
Below
index
length
index
output
)
;
}
void
MacroAssembler
:
:
spectreMaskIndex32
(
Register
index
const
Address
&
length
Register
output
)
{
MOZ_ASSERT
(
JitOptions
.
spectreIndexMasking
)
;
MOZ_ASSERT
(
index
!
=
length
.
base
)
;
MOZ_ASSERT
(
length
.
base
!
=
output
)
;
MOZ_ASSERT
(
index
!
=
output
)
;
move32
(
Imm32
(
0
)
output
)
;
cmp32Move32
(
Assembler
:
:
Below
index
length
index
output
)
;
}
void
MacroAssembler
:
:
spectreMaskIndexPtr
(
Register
index
Register
length
Register
output
)
{
MOZ_ASSERT
(
JitOptions
.
spectreIndexMasking
)
;
MOZ_ASSERT
(
length
!
=
output
)
;
MOZ_ASSERT
(
index
!
=
output
)
;
movePtr
(
ImmWord
(
0
)
output
)
;
cmpPtrMovePtr
(
Assembler
:
:
Below
index
length
index
output
)
;
}
void
MacroAssembler
:
:
spectreMaskIndexPtr
(
Register
index
const
Address
&
length
Register
output
)
{
MOZ_ASSERT
(
JitOptions
.
spectreIndexMasking
)
;
MOZ_ASSERT
(
index
!
=
length
.
base
)
;
MOZ_ASSERT
(
length
.
base
!
=
output
)
;
MOZ_ASSERT
(
index
!
=
output
)
;
movePtr
(
ImmWord
(
0
)
output
)
;
cmpPtrMovePtr
(
Assembler
:
:
Below
index
length
index
output
)
;
}
void
MacroAssembler
:
:
boundsCheck32PowerOfTwo
(
Register
index
uint32_t
length
Label
*
failure
)
{
MOZ_ASSERT
(
mozilla
:
:
IsPowerOfTwo
(
length
)
)
;
branch32
(
Assembler
:
:
AboveOrEqual
index
Imm32
(
length
)
failure
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
and32
(
Imm32
(
length
-
1
)
index
)
;
}
}
void
MacroAssembler
:
:
loadWasmPinnedRegsFromInstance
(
mozilla
:
:
Maybe
<
wasm
:
:
BytecodeOffset
>
trapOffset
)
{
#
ifdef
WASM_HAS_HEAPREG
static_assert
(
wasm
:
:
Instance
:
:
offsetOfMemoryBase
(
)
<
4096
"
We
count
only
on
the
low
page
being
inaccessible
"
)
;
if
(
trapOffset
)
{
append
(
wasm
:
:
Trap
:
:
IndirectCallToNull
wasm
:
:
TrapSite
(
currentOffset
(
)
*
trapOffset
)
)
;
}
loadPtr
(
Address
(
InstanceReg
wasm
:
:
Instance
:
:
offsetOfMemoryBase
(
)
)
HeapReg
)
;
#
else
MOZ_ASSERT
(
!
trapOffset
)
;
#
endif
}
#
ifdef
JS_64BIT
void
MacroAssembler
:
:
debugAssertCanonicalInt32
(
Register
r
)
{
#
ifdef
DEBUG
if
(
!
js
:
:
jit
:
:
JitOptions
.
lessDebugCode
)
{
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM64
)
Label
ok
;
branchPtr
(
Assembler
:
:
BelowOrEqual
r
ImmWord
(
UINT32_MAX
)
&
ok
)
;
breakpoint
(
)
;
bind
(
&
ok
)
;
#
elif
defined
(
JS_CODEGEN_MIPS64
)
|
|
defined
(
JS_CODEGEN_LOONG64
)
Label
ok
;
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
move32SignExtendToPtr
(
r
scratch
)
;
branchPtr
(
Assembler
:
:
Equal
r
scratch
&
ok
)
;
breakpoint
(
)
;
bind
(
&
ok
)
;
#
else
MOZ_CRASH
(
"
IMPLEMENT
ME
"
)
;
#
endif
}
#
endif
}
#
endif
void
MacroAssembler
:
:
memoryBarrierBefore
(
const
Synchronization
&
sync
)
{
memoryBarrier
(
sync
.
barrierBefore
)
;
}
void
MacroAssembler
:
:
memoryBarrierAfter
(
const
Synchronization
&
sync
)
{
memoryBarrier
(
sync
.
barrierAfter
)
;
}
void
MacroAssembler
:
:
debugAssertIsObject
(
const
ValueOperand
&
val
)
{
#
ifdef
DEBUG
Label
ok
;
branchTestObject
(
Assembler
:
:
Equal
val
&
ok
)
;
assumeUnreachable
(
"
Expected
an
object
!
"
)
;
bind
(
&
ok
)
;
#
endif
}
void
MacroAssembler
:
:
debugAssertObjHasFixedSlots
(
Register
obj
Register
scratch
)
{
#
ifdef
DEBUG
Label
hasFixedSlots
;
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfShape
(
)
)
scratch
)
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
scratch
Shape
:
:
offsetOfImmutableFlags
(
)
)
Imm32
(
Shape
:
:
fixedSlotsMask
(
)
)
&
hasFixedSlots
)
;
assumeUnreachable
(
"
Expected
a
fixed
slot
"
)
;
bind
(
&
hasFixedSlots
)
;
#
endif
}
void
MacroAssembler
:
:
debugAssertObjectHasClass
(
Register
obj
Register
scratch
const
JSClass
*
clasp
)
{
#
ifdef
DEBUG
Label
done
;
branchTestObjClassNoSpectreMitigations
(
Assembler
:
:
Equal
obj
clasp
scratch
&
done
)
;
assumeUnreachable
(
"
Class
check
failed
"
)
;
bind
(
&
done
)
;
#
endif
}
void
MacroAssembler
:
:
branchArrayIsNotPacked
(
Register
array
Register
temp1
Register
temp2
Label
*
label
)
{
loadPtr
(
Address
(
array
NativeObject
:
:
offsetOfElements
(
)
)
temp1
)
;
Address
initLength
(
temp1
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
load32
(
Address
(
temp1
ObjectElements
:
:
offsetOfLength
(
)
)
temp2
)
;
branch32
(
Assembler
:
:
NotEqual
initLength
temp2
label
)
;
Address
flags
(
temp1
ObjectElements
:
:
offsetOfFlags
(
)
)
;
branchTest32
(
Assembler
:
:
NonZero
flags
Imm32
(
ObjectElements
:
:
NON_PACKED
)
label
)
;
}
void
MacroAssembler
:
:
setIsPackedArray
(
Register
obj
Register
output
Register
temp
)
{
Label
notPackedArray
;
branchTestObjClass
(
Assembler
:
:
NotEqual
obj
&
ArrayObject
:
:
class_
temp
obj
&
notPackedArray
)
;
branchArrayIsNotPacked
(
obj
temp
output
&
notPackedArray
)
;
Label
done
;
move32
(
Imm32
(
1
)
output
)
;
jump
(
&
done
)
;
bind
(
&
notPackedArray
)
;
move32
(
Imm32
(
0
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
packedArrayPop
(
Register
array
ValueOperand
output
Register
temp1
Register
temp2
Label
*
fail
)
{
loadPtr
(
Address
(
array
NativeObject
:
:
offsetOfElements
(
)
)
temp1
)
;
static
constexpr
uint32_t
UnhandledFlags
=
ObjectElements
:
:
Flags
:
:
NON_PACKED
|
ObjectElements
:
:
Flags
:
:
NONWRITABLE_ARRAY_LENGTH
|
ObjectElements
:
:
Flags
:
:
NOT_EXTENSIBLE
|
ObjectElements
:
:
Flags
:
:
MAYBE_IN_ITERATION
;
Address
flags
(
temp1
ObjectElements
:
:
offsetOfFlags
(
)
)
;
branchTest32
(
Assembler
:
:
NonZero
flags
Imm32
(
UnhandledFlags
)
fail
)
;
Address
lengthAddr
(
temp1
ObjectElements
:
:
offsetOfLength
(
)
)
;
Address
initLengthAddr
(
temp1
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
load32
(
lengthAddr
temp2
)
;
branch32
(
Assembler
:
:
NotEqual
initLengthAddr
temp2
fail
)
;
Label
notEmpty
done
;
branchTest32
(
Assembler
:
:
NonZero
temp2
temp2
&
notEmpty
)
;
{
moveValue
(
UndefinedValue
(
)
output
)
;
jump
(
&
done
)
;
}
bind
(
&
notEmpty
)
;
sub32
(
Imm32
(
1
)
temp2
)
;
BaseObjectElementIndex
elementAddr
(
temp1
temp2
)
;
loadValue
(
elementAddr
output
)
;
EmitPreBarrier
(
*
this
elementAddr
MIRType
:
:
Value
)
;
store32
(
temp2
lengthAddr
)
;
store32
(
temp2
initLengthAddr
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
packedArrayShift
(
Register
array
ValueOperand
output
Register
temp1
Register
temp2
LiveRegisterSet
volatileRegs
Label
*
fail
)
{
loadPtr
(
Address
(
array
NativeObject
:
:
offsetOfElements
(
)
)
temp1
)
;
static
constexpr
uint32_t
UnhandledFlags
=
ObjectElements
:
:
Flags
:
:
NON_PACKED
|
ObjectElements
:
:
Flags
:
:
NONWRITABLE_ARRAY_LENGTH
|
ObjectElements
:
:
Flags
:
:
NOT_EXTENSIBLE
|
ObjectElements
:
:
Flags
:
:
MAYBE_IN_ITERATION
;
Address
flags
(
temp1
ObjectElements
:
:
offsetOfFlags
(
)
)
;
branchTest32
(
Assembler
:
:
NonZero
flags
Imm32
(
UnhandledFlags
)
fail
)
;
Address
lengthAddr
(
temp1
ObjectElements
:
:
offsetOfLength
(
)
)
;
Address
initLengthAddr
(
temp1
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
load32
(
lengthAddr
temp2
)
;
branch32
(
Assembler
:
:
NotEqual
initLengthAddr
temp2
fail
)
;
Label
notEmpty
done
;
branchTest32
(
Assembler
:
:
NonZero
temp2
temp2
&
notEmpty
)
;
{
moveValue
(
UndefinedValue
(
)
output
)
;
jump
(
&
done
)
;
}
bind
(
&
notEmpty
)
;
Address
elementAddr
(
temp1
0
)
;
loadValue
(
elementAddr
output
)
;
{
volatileRegs
.
takeUnchecked
(
temp1
)
;
volatileRegs
.
takeUnchecked
(
temp2
)
;
if
(
output
.
hasVolatileReg
(
)
)
{
volatileRegs
.
addUnchecked
(
output
)
;
}
PushRegsInMask
(
volatileRegs
)
;
using
Fn
=
void
(
*
)
(
ArrayObject
*
arr
)
;
setupUnalignedABICall
(
temp1
)
;
passABIArg
(
array
)
;
callWithABI
<
Fn
ArrayShiftMoveElements
>
(
)
;
PopRegsInMask
(
volatileRegs
)
;
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadArgumentsObjectElement
(
Register
obj
Register
index
ValueOperand
output
Register
temp
Label
*
fail
)
{
Register
temp2
=
output
.
scratchReg
(
)
;
unboxInt32
(
Address
(
obj
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
temp
)
;
branchTest32
(
Assembler
:
:
NonZero
temp
Imm32
(
ArgumentsObject
:
:
ELEMENT_OVERRIDDEN_BIT
)
fail
)
;
rshift32
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
temp
)
;
spectreBoundsCheck32
(
index
temp
temp2
fail
)
;
loadPrivate
(
Address
(
obj
ArgumentsObject
:
:
getDataSlotOffset
(
)
)
temp
)
;
BaseValueIndex
argValue
(
temp
index
ArgumentsData
:
:
offsetOfArgs
(
)
)
;
branchTestMagic
(
Assembler
:
:
Equal
argValue
fail
)
;
loadValue
(
argValue
output
)
;
}
void
MacroAssembler
:
:
loadArgumentsObjectElementHole
(
Register
obj
Register
index
ValueOperand
output
Register
temp
Label
*
fail
)
{
Register
temp2
=
output
.
scratchReg
(
)
;
unboxInt32
(
Address
(
obj
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
temp
)
;
branchTest32
(
Assembler
:
:
NonZero
temp
Imm32
(
ArgumentsObject
:
:
ELEMENT_OVERRIDDEN_BIT
)
fail
)
;
Label
outOfBounds
done
;
rshift32
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
temp
)
;
spectreBoundsCheck32
(
index
temp
temp2
&
outOfBounds
)
;
loadPrivate
(
Address
(
obj
ArgumentsObject
:
:
getDataSlotOffset
(
)
)
temp
)
;
BaseValueIndex
argValue
(
temp
index
ArgumentsData
:
:
offsetOfArgs
(
)
)
;
branchTestMagic
(
Assembler
:
:
Equal
argValue
fail
)
;
loadValue
(
argValue
output
)
;
jump
(
&
done
)
;
bind
(
&
outOfBounds
)
;
branch32
(
Assembler
:
:
LessThan
index
Imm32
(
0
)
fail
)
;
moveValue
(
UndefinedValue
(
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
loadArgumentsObjectElementExists
(
Register
obj
Register
index
Register
output
Register
temp
Label
*
fail
)
{
branch32
(
Assembler
:
:
LessThan
index
Imm32
(
0
)
fail
)
;
unboxInt32
(
Address
(
obj
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
temp
)
;
branchTest32
(
Assembler
:
:
NonZero
temp
Imm32
(
ArgumentsObject
:
:
ELEMENT_OVERRIDDEN_BIT
)
fail
)
;
rshift32
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
temp
)
;
cmp32Set
(
Assembler
:
:
LessThan
index
temp
output
)
;
}
void
MacroAssembler
:
:
loadArgumentsObjectLength
(
Register
obj
Register
output
Label
*
fail
)
{
unboxInt32
(
Address
(
obj
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
output
)
;
branchTest32
(
Assembler
:
:
NonZero
output
Imm32
(
ArgumentsObject
:
:
LENGTH_OVERRIDDEN_BIT
)
fail
)
;
rshift32
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
output
)
;
}
void
MacroAssembler
:
:
branchTestArgumentsObjectFlags
(
Register
obj
Register
temp
uint32_t
flags
Condition
cond
Label
*
label
)
{
MOZ_ASSERT
(
(
flags
&
~
ArgumentsObject
:
:
PACKED_BITS_MASK
)
=
=
0
)
;
unboxInt32
(
Address
(
obj
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
temp
)
;
branchTest32
(
cond
temp
Imm32
(
flags
)
label
)
;
}
static
constexpr
bool
ValidateSizeRange
(
Scalar
:
:
Type
from
Scalar
:
:
Type
to
)
{
for
(
Scalar
:
:
Type
type
=
from
;
type
<
to
;
type
=
Scalar
:
:
Type
(
type
+
1
)
)
{
if
(
TypedArrayElemSize
(
type
)
!
=
TypedArrayElemSize
(
from
)
)
{
return
false
;
}
}
return
true
;
}
void
MacroAssembler
:
:
typedArrayElementSize
(
Register
obj
Register
output
)
{
static_assert
(
Scalar
:
:
Int8
=
=
0
"
Int8
is
the
first
typed
array
class
"
)
;
static_assert
(
(
Scalar
:
:
BigUint64
-
Scalar
:
:
Int8
)
=
=
Scalar
:
:
MaxTypedArrayViewType
-
1
"
BigUint64
is
the
last
typed
array
class
"
)
;
Label
one
two
four
eight
done
;
loadObjClassUnsafe
(
obj
output
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
Int8
Scalar
:
:
Int16
)
"
element
size
is
one
in
[
Int8
Int16
)
"
)
;
branchPtr
(
Assembler
:
:
Below
output
ImmPtr
(
TypedArrayObject
:
:
classForType
(
Scalar
:
:
Int16
)
)
&
one
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
Int16
Scalar
:
:
Int32
)
"
element
size
is
two
in
[
Int16
Int32
)
"
)
;
branchPtr
(
Assembler
:
:
Below
output
ImmPtr
(
TypedArrayObject
:
:
classForType
(
Scalar
:
:
Int32
)
)
&
two
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
Int32
Scalar
:
:
Float64
)
"
element
size
is
four
in
[
Int32
Float64
)
"
)
;
branchPtr
(
Assembler
:
:
Below
output
ImmPtr
(
TypedArrayObject
:
:
classForType
(
Scalar
:
:
Float64
)
)
&
four
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
Float64
Scalar
:
:
Uint8Clamped
)
"
element
size
is
eight
in
[
Float64
Uint8Clamped
)
"
)
;
branchPtr
(
Assembler
:
:
Below
output
ImmPtr
(
TypedArrayObject
:
:
classForType
(
Scalar
:
:
Uint8Clamped
)
)
&
eight
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
Uint8Clamped
Scalar
:
:
BigInt64
)
"
element
size
is
one
in
[
Uint8Clamped
BigInt64
)
"
)
;
branchPtr
(
Assembler
:
:
Below
output
ImmPtr
(
TypedArrayObject
:
:
classForType
(
Scalar
:
:
BigInt64
)
)
&
one
)
;
static_assert
(
ValidateSizeRange
(
Scalar
:
:
BigInt64
Scalar
:
:
MaxTypedArrayViewType
)
"
element
size
is
eight
in
[
BigInt64
MaxTypedArrayViewType
)
"
)
;
bind
(
&
eight
)
;
move32
(
Imm32
(
8
)
output
)
;
jump
(
&
done
)
;
bind
(
&
four
)
;
move32
(
Imm32
(
4
)
output
)
;
jump
(
&
done
)
;
bind
(
&
two
)
;
move32
(
Imm32
(
2
)
output
)
;
jump
(
&
done
)
;
bind
(
&
one
)
;
move32
(
Imm32
(
1
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
branchIfClassIsNotTypedArray
(
Register
clasp
Label
*
notTypedArray
)
{
static_assert
(
Scalar
:
:
Int8
=
=
0
"
Int8
is
the
first
typed
array
class
"
)
;
const
JSClass
*
firstTypedArrayClass
=
TypedArrayObject
:
:
classForType
(
Scalar
:
:
Int8
)
;
static_assert
(
(
Scalar
:
:
BigUint64
-
Scalar
:
:
Int8
)
=
=
Scalar
:
:
MaxTypedArrayViewType
-
1
"
BigUint64
is
the
last
typed
array
class
"
)
;
const
JSClass
*
lastTypedArrayClass
=
TypedArrayObject
:
:
classForType
(
Scalar
:
:
BigUint64
)
;
branchPtr
(
Assembler
:
:
Below
clasp
ImmPtr
(
firstTypedArrayClass
)
notTypedArray
)
;
branchPtr
(
Assembler
:
:
Above
clasp
ImmPtr
(
lastTypedArrayClass
)
notTypedArray
)
;
}
void
MacroAssembler
:
:
branchIfHasDetachedArrayBuffer
(
Register
obj
Register
temp
Label
*
label
)
{
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
temp
)
;
Label
done
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
temp
ObjectElements
:
:
offsetOfFlags
(
)
)
Imm32
(
ObjectElements
:
:
SHARED_MEMORY
)
&
done
)
;
fallibleUnboxObject
(
Address
(
obj
ArrayBufferViewObject
:
:
bufferOffset
(
)
)
temp
&
done
)
;
unboxInt32
(
Address
(
temp
ArrayBufferObject
:
:
offsetOfFlagsSlot
(
)
)
temp
)
;
branchTest32
(
Assembler
:
:
NonZero
temp
Imm32
(
ArrayBufferObject
:
:
DETACHED
)
label
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
branchIfNativeIteratorNotReusable
(
Register
ni
Label
*
notReusable
)
{
Address
flagsAddr
(
ni
NativeIterator
:
:
offsetOfFlagsAndCount
(
)
)
;
#
ifdef
DEBUG
Label
niIsInitialized
;
branchTest32
(
Assembler
:
:
NonZero
flagsAddr
Imm32
(
NativeIterator
:
:
Flags
:
:
Initialized
)
&
niIsInitialized
)
;
assumeUnreachable
(
"
Expected
a
NativeIterator
that
'
s
been
completely
"
"
initialized
"
)
;
bind
(
&
niIsInitialized
)
;
#
endif
branchTest32
(
Assembler
:
:
NonZero
flagsAddr
Imm32
(
NativeIterator
:
:
Flags
:
:
NotReusable
)
notReusable
)
;
}
static
void
LoadNativeIterator
(
MacroAssembler
&
masm
Register
obj
Register
dest
)
{
MOZ_ASSERT
(
obj
!
=
dest
)
;
#
ifdef
DEBUG
Label
ok
;
masm
.
branchTestObjClass
(
Assembler
:
:
Equal
obj
&
PropertyIteratorObject
:
:
class_
dest
obj
&
ok
)
;
masm
.
assumeUnreachable
(
"
Expected
PropertyIteratorObject
!
"
)
;
masm
.
bind
(
&
ok
)
;
#
endif
Address
slotAddr
(
obj
PropertyIteratorObject
:
:
offsetOfIteratorSlot
(
)
)
;
masm
.
loadPrivate
(
slotAddr
dest
)
;
}
void
MacroAssembler
:
:
iteratorMore
(
Register
obj
ValueOperand
output
Register
temp
)
{
Label
done
;
Register
outputScratch
=
output
.
scratchReg
(
)
;
LoadNativeIterator
(
*
this
obj
outputScratch
)
;
Label
iterDone
;
Address
cursorAddr
(
outputScratch
NativeIterator
:
:
offsetOfPropertyCursor
(
)
)
;
Address
cursorEndAddr
(
outputScratch
NativeIterator
:
:
offsetOfPropertiesEnd
(
)
)
;
loadPtr
(
cursorAddr
temp
)
;
branchPtr
(
Assembler
:
:
BelowOrEqual
cursorEndAddr
temp
&
iterDone
)
;
loadPtr
(
Address
(
temp
0
)
temp
)
;
addPtr
(
Imm32
(
sizeof
(
GCPtr
<
JSLinearString
*
>
)
)
cursorAddr
)
;
tagValue
(
JSVAL_TYPE_STRING
temp
output
)
;
jump
(
&
done
)
;
bind
(
&
iterDone
)
;
moveValue
(
MagicValue
(
JS_NO_ITER_VALUE
)
output
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
iteratorClose
(
Register
obj
Register
temp1
Register
temp2
Register
temp3
)
{
LoadNativeIterator
(
*
this
obj
temp1
)
;
Label
done
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
temp1
NativeIterator
:
:
offsetOfFlagsAndCount
(
)
)
Imm32
(
NativeIterator
:
:
Flags
:
:
IsEmptyIteratorSingleton
)
&
done
)
;
and32
(
Imm32
(
~
NativeIterator
:
:
Flags
:
:
Active
)
Address
(
temp1
NativeIterator
:
:
offsetOfFlagsAndCount
(
)
)
)
;
Address
iterObjAddr
(
temp1
NativeIterator
:
:
offsetOfObjectBeingIterated
(
)
)
;
guardedCallPreBarrierAnyZone
(
iterObjAddr
MIRType
:
:
Object
temp2
)
;
storePtr
(
ImmPtr
(
nullptr
)
iterObjAddr
)
;
loadPtr
(
Address
(
temp1
NativeIterator
:
:
offsetOfShapesEnd
(
)
)
temp2
)
;
storePtr
(
temp2
Address
(
temp1
NativeIterator
:
:
offsetOfPropertyCursor
(
)
)
)
;
const
Register
next
=
temp2
;
const
Register
prev
=
temp3
;
loadPtr
(
Address
(
temp1
NativeIterator
:
:
offsetOfNext
(
)
)
next
)
;
loadPtr
(
Address
(
temp1
NativeIterator
:
:
offsetOfPrev
(
)
)
prev
)
;
storePtr
(
prev
Address
(
next
NativeIterator
:
:
offsetOfPrev
(
)
)
)
;
storePtr
(
next
Address
(
prev
NativeIterator
:
:
offsetOfNext
(
)
)
)
;
#
ifdef
DEBUG
storePtr
(
ImmPtr
(
nullptr
)
Address
(
temp1
NativeIterator
:
:
offsetOfNext
(
)
)
)
;
storePtr
(
ImmPtr
(
nullptr
)
Address
(
temp1
NativeIterator
:
:
offsetOfPrev
(
)
)
)
;
#
endif
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
toHashableNonGCThing
(
ValueOperand
value
ValueOperand
result
FloatRegister
tempFloat
)
{
#
ifdef
DEBUG
Label
ok
;
branchTestGCThing
(
Assembler
:
:
NotEqual
value
&
ok
)
;
assumeUnreachable
(
"
Unexpected
GC
thing
"
)
;
bind
(
&
ok
)
;
#
endif
Label
useInput
done
;
branchTestDouble
(
Assembler
:
:
NotEqual
value
&
useInput
)
;
{
Register
int32
=
result
.
scratchReg
(
)
;
unboxDouble
(
value
tempFloat
)
;
Label
canonicalize
;
convertDoubleToInt32
(
tempFloat
int32
&
canonicalize
false
)
;
{
tagValue
(
JSVAL_TYPE_INT32
int32
result
)
;
jump
(
&
done
)
;
}
bind
(
&
canonicalize
)
;
{
branchDouble
(
Assembler
:
:
DoubleOrdered
tempFloat
tempFloat
&
useInput
)
;
moveValue
(
JS
:
:
NaNValue
(
)
result
)
;
jump
(
&
done
)
;
}
}
bind
(
&
useInput
)
;
moveValue
(
value
result
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
toHashableValue
(
ValueOperand
value
ValueOperand
result
FloatRegister
tempFloat
Label
*
atomizeString
Label
*
tagString
)
{
ScratchTagScope
tag
(
*
this
value
)
;
splitTagForTest
(
value
tag
)
;
Label
notString
useInput
done
;
branchTestString
(
Assembler
:
:
NotEqual
tag
&
notString
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
Register
str
=
result
.
scratchReg
(
)
;
unboxString
(
value
str
)
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
ATOM_BIT
)
&
useInput
)
;
jump
(
atomizeString
)
;
bind
(
tagString
)
;
tagValue
(
JSVAL_TYPE_STRING
str
result
)
;
jump
(
&
done
)
;
}
bind
(
&
notString
)
;
branchTestDouble
(
Assembler
:
:
NotEqual
tag
&
useInput
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
Register
int32
=
result
.
scratchReg
(
)
;
unboxDouble
(
value
tempFloat
)
;
Label
canonicalize
;
convertDoubleToInt32
(
tempFloat
int32
&
canonicalize
false
)
;
{
tagValue
(
JSVAL_TYPE_INT32
int32
result
)
;
jump
(
&
done
)
;
}
bind
(
&
canonicalize
)
;
{
branchDouble
(
Assembler
:
:
DoubleOrdered
tempFloat
tempFloat
&
useInput
)
;
moveValue
(
JS
:
:
NaNValue
(
)
result
)
;
jump
(
&
done
)
;
}
}
bind
(
&
useInput
)
;
moveValue
(
value
result
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
scrambleHashCode
(
Register
result
)
{
mul32
(
Imm32
(
mozilla
:
:
kGoldenRatioU32
)
result
)
;
}
void
MacroAssembler
:
:
prepareHashNonGCThing
(
ValueOperand
value
Register
result
Register
temp
)
{
#
ifdef
DEBUG
Label
ok
;
branchTestGCThing
(
Assembler
:
:
NotEqual
value
&
ok
)
;
assumeUnreachable
(
"
Unexpected
GC
thing
"
)
;
bind
(
&
ok
)
;
#
endif
#
ifdef
JS_PUNBOX64
move64To32
(
value
.
toRegister64
(
)
result
)
;
#
else
move32
(
value
.
payloadReg
(
)
result
)
;
#
endif
#
ifdef
JS_PUNBOX64
auto
r64
=
Register64
(
temp
)
;
move64
(
value
.
toRegister64
(
)
r64
)
;
rshift64Arithmetic
(
Imm32
(
32
)
r64
)
;
#
else
#
endif
mul32
(
Imm32
(
mozilla
:
:
kGoldenRatioU32
)
result
)
;
rotateLeft
(
Imm32
(
5
)
result
result
)
;
#
ifdef
JS_PUNBOX64
xor32
(
temp
result
)
;
#
endif
mul32
(
Imm32
(
mozilla
:
:
kGoldenRatioU32
*
mozilla
:
:
kGoldenRatioU32
)
result
)
;
}
void
MacroAssembler
:
:
prepareHashString
(
Register
str
Register
result
Register
temp
)
{
#
ifdef
DEBUG
Label
ok
;
branchTest32
(
Assembler
:
:
NonZero
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
ATOM_BIT
)
&
ok
)
;
assumeUnreachable
(
"
Unexpected
non
-
atom
string
"
)
;
bind
(
&
ok
)
;
#
endif
move32
(
Imm32
(
JSString
:
:
FAT_INLINE_MASK
)
temp
)
;
and32
(
Address
(
str
JSString
:
:
offsetOfFlags
(
)
)
temp
)
;
move32
(
Imm32
(
0
)
result
)
;
cmp32Set
(
Assembler
:
:
Equal
temp
Imm32
(
JSString
:
:
FAT_INLINE_MASK
)
result
)
;
static_assert
(
FatInlineAtom
:
:
offsetOfHash
(
)
>
NormalAtom
:
:
offsetOfHash
(
)
)
;
constexpr
size_t
offsetDiff
=
FatInlineAtom
:
:
offsetOfHash
(
)
-
NormalAtom
:
:
offsetOfHash
(
)
;
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
offsetDiff
)
)
;
uint8_t
shift
=
mozilla
:
:
FloorLog2Size
(
offsetDiff
)
;
if
(
IsShiftInScaleRange
(
shift
)
)
{
load32
(
BaseIndex
(
str
result
ShiftToScale
(
shift
)
NormalAtom
:
:
offsetOfHash
(
)
)
result
)
;
}
else
{
lshift32
(
Imm32
(
shift
)
result
)
;
load32
(
BaseIndex
(
str
result
TimesOne
NormalAtom
:
:
offsetOfHash
(
)
)
result
)
;
}
scrambleHashCode
(
result
)
;
}
void
MacroAssembler
:
:
prepareHashSymbol
(
Register
sym
Register
result
)
{
load32
(
Address
(
sym
JS
:
:
Symbol
:
:
offsetOfHash
(
)
)
result
)
;
scrambleHashCode
(
result
)
;
}
void
MacroAssembler
:
:
prepareHashBigInt
(
Register
bigInt
Register
result
Register
temp1
Register
temp2
Register
temp3
)
{
auto
addU32ToHash
=
[
&
]
(
auto
toAdd
)
{
rotateLeft
(
Imm32
(
5
)
result
result
)
;
xor32
(
toAdd
result
)
;
mul32
(
Imm32
(
mozilla
:
:
kGoldenRatioU32
)
result
)
;
}
;
move32
(
Imm32
(
0
)
result
)
;
load32
(
Address
(
bigInt
BigInt
:
:
offsetOfLength
(
)
)
temp1
)
;
loadBigIntDigits
(
bigInt
temp2
)
;
Label
start
loop
;
jump
(
&
start
)
;
bind
(
&
loop
)
;
{
#
if
defined
(
JS_CODEGEN_MIPS64
)
addU32ToHash
(
Address
(
temp2
0
)
)
;
addU32ToHash
(
Address
(
temp2
sizeof
(
int32_t
)
)
)
;
#
elif
JS_PUNBOX64
loadPtr
(
Address
(
temp2
0
)
temp3
)
;
addU32ToHash
(
temp3
)
;
rshiftPtr
(
Imm32
(
32
)
temp3
)
;
addU32ToHash
(
temp3
)
;
#
else
addU32ToHash
(
Address
(
temp2
0
)
)
;
#
endif
}
addPtr
(
Imm32
(
sizeof
(
BigInt
:
:
Digit
)
)
temp2
)
;
bind
(
&
start
)
;
branchSub32
(
Assembler
:
:
NotSigned
Imm32
(
1
)
temp1
&
loop
)
;
{
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
BigInt
:
:
signBitMask
(
)
)
)
;
load32
(
Address
(
bigInt
BigInt
:
:
offsetOfFlags
(
)
)
temp1
)
;
and32
(
Imm32
(
BigInt
:
:
signBitMask
(
)
)
temp1
)
;
rshift32
(
Imm32
(
mozilla
:
:
FloorLog2
(
BigInt
:
:
signBitMask
(
)
)
)
temp1
)
;
addU32ToHash
(
temp1
)
;
}
scrambleHashCode
(
result
)
;
}
void
MacroAssembler
:
:
prepareHashObject
(
Register
setObj
ValueOperand
value
Register
result
Register
temp1
Register
temp2
Register
temp3
Register
temp4
)
{
#
ifdef
JS_PUNBOX64
static_assert
(
SetObject
:
:
getDataSlotOffset
(
)
=
=
MapObject
:
:
getDataSlotOffset
(
)
)
;
loadPrivate
(
Address
(
setObj
SetObject
:
:
getDataSlotOffset
(
)
)
temp1
)
;
static_assert
(
ValueSet
:
:
offsetOfImplHcsK0
(
)
=
=
ValueMap
:
:
offsetOfImplHcsK0
(
)
)
;
static_assert
(
ValueSet
:
:
offsetOfImplHcsK1
(
)
=
=
ValueMap
:
:
offsetOfImplHcsK1
(
)
)
;
auto
k0
=
Register64
(
temp1
)
;
auto
k1
=
Register64
(
temp2
)
;
load64
(
Address
(
temp1
ValueSet
:
:
offsetOfImplHcsK1
(
)
)
k1
)
;
load64
(
Address
(
temp1
ValueSet
:
:
offsetOfImplHcsK0
(
)
)
k0
)
;
static_assert
(
sizeof
(
mozilla
:
:
HashNumber
)
=
=
4
)
;
move32To64ZeroExtend
(
value
.
valueReg
(
)
Register64
(
result
)
)
;
auto
m
=
Register64
(
result
)
;
auto
v0
=
Register64
(
temp3
)
;
auto
v1
=
Register64
(
temp4
)
;
auto
v2
=
k0
;
auto
v3
=
k1
;
auto
sipRound
=
[
&
]
(
)
{
add64
(
v1
v0
)
;
rotateLeft64
(
Imm32
(
13
)
v1
v1
InvalidReg
)
;
xor64
(
v0
v1
)
;
rotateLeft64
(
Imm32
(
32
)
v0
v0
InvalidReg
)
;
add64
(
v3
v2
)
;
rotateLeft64
(
Imm32
(
16
)
v3
v3
InvalidReg
)
;
xor64
(
v2
v3
)
;
add64
(
v3
v0
)
;
rotateLeft64
(
Imm32
(
21
)
v3
v3
InvalidReg
)
;
xor64
(
v0
v3
)
;
add64
(
v1
v2
)
;
rotateLeft64
(
Imm32
(
17
)
v1
v1
InvalidReg
)
;
xor64
(
v2
v1
)
;
rotateLeft64
(
Imm32
(
32
)
v2
v2
InvalidReg
)
;
}
;
move64
(
Imm64
(
0x736f6d6570736575
)
v0
)
;
xor64
(
k0
v0
)
;
move64
(
Imm64
(
0x646f72616e646f6d
)
v1
)
;
xor64
(
k1
v1
)
;
MOZ_ASSERT
(
v2
=
=
k0
)
;
xor64
(
Imm64
(
0x6c7967656e657261
)
v2
)
;
MOZ_ASSERT
(
v3
=
=
k1
)
;
xor64
(
Imm64
(
0x7465646279746573
)
v3
)
;
xor64
(
m
v3
)
;
sipRound
(
)
;
xor64
(
m
v0
)
;
xor64
(
Imm64
(
0xff
)
v2
)
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
sipRound
(
)
;
}
xor64
(
v1
v0
)
;
xor64
(
v2
v3
)
;
xor64
(
v3
v0
)
;
move64To32
(
v0
result
)
;
scrambleHashCode
(
result
)
;
#
else
MOZ_CRASH
(
"
Not
implemented
"
)
;
#
endif
}
void
MacroAssembler
:
:
prepareHashValue
(
Register
setObj
ValueOperand
value
Register
result
Register
temp1
Register
temp2
Register
temp3
Register
temp4
)
{
Label
isString
isObject
isSymbol
isBigInt
;
{
ScratchTagScope
tag
(
*
this
value
)
;
splitTagForTest
(
value
tag
)
;
branchTestString
(
Assembler
:
:
Equal
tag
&
isString
)
;
branchTestObject
(
Assembler
:
:
Equal
tag
&
isObject
)
;
branchTestSymbol
(
Assembler
:
:
Equal
tag
&
isSymbol
)
;
branchTestBigInt
(
Assembler
:
:
Equal
tag
&
isBigInt
)
;
}
Label
done
;
{
prepareHashNonGCThing
(
value
result
temp1
)
;
jump
(
&
done
)
;
}
bind
(
&
isString
)
;
{
unboxString
(
value
temp1
)
;
prepareHashString
(
temp1
result
temp2
)
;
jump
(
&
done
)
;
}
bind
(
&
isObject
)
;
{
prepareHashObject
(
setObj
value
result
temp1
temp2
temp3
temp4
)
;
jump
(
&
done
)
;
}
bind
(
&
isSymbol
)
;
{
unboxSymbol
(
value
temp1
)
;
prepareHashSymbol
(
temp1
result
)
;
jump
(
&
done
)
;
}
bind
(
&
isBigInt
)
;
{
unboxBigInt
(
value
temp1
)
;
prepareHashBigInt
(
temp1
result
temp2
temp3
temp4
)
;
}
bind
(
&
done
)
;
}
template
<
typename
OrderedHashTable
>
void
MacroAssembler
:
:
orderedHashTableLookup
(
Register
setOrMapObj
ValueOperand
value
Register
hash
Register
entryTemp
Register
temp1
Register
temp2
Register
temp3
Register
temp4
Label
*
found
IsBigInt
isBigInt
)
{
MOZ_ASSERT_IF
(
isBigInt
=
=
IsBigInt
:
:
No
temp3
=
=
InvalidReg
)
;
MOZ_ASSERT_IF
(
isBigInt
=
=
IsBigInt
:
:
No
temp4
=
=
InvalidReg
)
;
#
ifdef
DEBUG
Label
ok
;
if
(
isBigInt
=
=
IsBigInt
:
:
No
)
{
branchTestBigInt
(
Assembler
:
:
NotEqual
value
&
ok
)
;
assumeUnreachable
(
"
Unexpected
BigInt
"
)
;
}
else
if
(
isBigInt
=
=
IsBigInt
:
:
Yes
)
{
branchTestBigInt
(
Assembler
:
:
Equal
value
&
ok
)
;
assumeUnreachable
(
"
Unexpected
non
-
BigInt
"
)
;
}
bind
(
&
ok
)
;
#
endif
#
ifdef
DEBUG
PushRegsInMask
(
LiveRegisterSet
(
RegisterSet
:
:
Volatile
(
)
)
)
;
pushValue
(
value
)
;
moveStackPtrTo
(
temp2
)
;
setupUnalignedABICall
(
temp1
)
;
loadJSContext
(
temp1
)
;
passABIArg
(
temp1
)
;
passABIArg
(
setOrMapObj
)
;
passABIArg
(
temp2
)
;
passABIArg
(
hash
)
;
if
constexpr
(
std
:
:
is_same_v
<
OrderedHashTable
ValueSet
>
)
{
using
Fn
=
void
(
*
)
(
JSContext
*
SetObject
*
const
Value
*
mozilla
:
:
HashNumber
)
;
callWithABI
<
Fn
jit
:
:
AssertSetObjectHash
>
(
)
;
}
else
{
using
Fn
=
void
(
*
)
(
JSContext
*
MapObject
*
const
Value
*
mozilla
:
:
HashNumber
)
;
callWithABI
<
Fn
jit
:
:
AssertMapObjectHash
>
(
)
;
}
popValue
(
value
)
;
PopRegsInMask
(
LiveRegisterSet
(
RegisterSet
:
:
Volatile
(
)
)
)
;
#
endif
static_assert
(
SetObject
:
:
getDataSlotOffset
(
)
=
=
MapObject
:
:
getDataSlotOffset
(
)
)
;
loadPrivate
(
Address
(
setOrMapObj
SetObject
:
:
getDataSlotOffset
(
)
)
temp1
)
;
move32
(
hash
entryTemp
)
;
load32
(
Address
(
temp1
OrderedHashTable
:
:
offsetOfImplHashShift
(
)
)
temp2
)
;
flexibleRshift32
(
temp2
entryTemp
)
;
loadPtr
(
Address
(
temp1
OrderedHashTable
:
:
offsetOfImplHashTable
(
)
)
temp2
)
;
loadPtr
(
BaseIndex
(
temp2
entryTemp
ScalePointer
)
entryTemp
)
;
Label
start
loop
;
jump
(
&
start
)
;
bind
(
&
loop
)
;
{
static_assert
(
OrderedHashTable
:
:
offsetOfImplDataElement
(
)
=
=
0
"
offsetof
(
Data
element
)
is
0
"
)
;
auto
keyAddr
=
Address
(
entryTemp
OrderedHashTable
:
:
offsetOfEntryKey
(
)
)
;
if
(
isBigInt
=
=
IsBigInt
:
:
No
)
{
branch64
(
Assembler
:
:
Equal
keyAddr
value
.
toRegister64
(
)
found
)
;
}
else
{
#
ifdef
JS_PUNBOX64
auto
key
=
ValueOperand
(
temp1
)
;
#
else
auto
key
=
ValueOperand
(
temp1
temp2
)
;
#
endif
loadValue
(
keyAddr
key
)
;
branch64
(
Assembler
:
:
Equal
key
.
toRegister64
(
)
value
.
toRegister64
(
)
found
)
;
Label
next
;
fallibleUnboxBigInt
(
key
temp2
&
next
)
;
if
(
isBigInt
=
=
IsBigInt
:
:
Yes
)
{
unboxBigInt
(
value
temp1
)
;
}
else
{
fallibleUnboxBigInt
(
value
temp1
&
next
)
;
}
equalBigInts
(
temp1
temp2
temp3
temp4
temp1
temp2
&
next
&
next
&
next
)
;
jump
(
found
)
;
bind
(
&
next
)
;
}
}
loadPtr
(
Address
(
entryTemp
OrderedHashTable
:
:
offsetOfImplDataChain
(
)
)
entryTemp
)
;
bind
(
&
start
)
;
branchTestPtr
(
Assembler
:
:
NonZero
entryTemp
entryTemp
&
loop
)
;
}
void
MacroAssembler
:
:
setObjectHas
(
Register
setObj
ValueOperand
value
Register
hash
Register
result
Register
temp1
Register
temp2
Register
temp3
Register
temp4
IsBigInt
isBigInt
)
{
Label
found
;
orderedHashTableLookup
<
ValueSet
>
(
setObj
value
hash
result
temp1
temp2
temp3
temp4
&
found
isBigInt
)
;
Label
done
;
move32
(
Imm32
(
0
)
result
)
;
jump
(
&
done
)
;
bind
(
&
found
)
;
move32
(
Imm32
(
1
)
result
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
mapObjectHas
(
Register
mapObj
ValueOperand
value
Register
hash
Register
result
Register
temp1
Register
temp2
Register
temp3
Register
temp4
IsBigInt
isBigInt
)
{
Label
found
;
orderedHashTableLookup
<
ValueMap
>
(
mapObj
value
hash
result
temp1
temp2
temp3
temp4
&
found
isBigInt
)
;
Label
done
;
move32
(
Imm32
(
0
)
result
)
;
jump
(
&
done
)
;
bind
(
&
found
)
;
move32
(
Imm32
(
1
)
result
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
mapObjectGet
(
Register
mapObj
ValueOperand
value
Register
hash
ValueOperand
result
Register
temp1
Register
temp2
Register
temp3
Register
temp4
Register
temp5
IsBigInt
isBigInt
)
{
Label
found
;
orderedHashTableLookup
<
ValueMap
>
(
mapObj
value
hash
temp1
temp2
temp3
temp4
temp5
&
found
isBigInt
)
;
Label
done
;
moveValue
(
UndefinedValue
(
)
result
)
;
jump
(
&
done
)
;
bind
(
&
found
)
;
loadValue
(
Address
(
temp1
ValueMap
:
:
Entry
:
:
offsetOfValue
(
)
)
result
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
touchFrameValues
(
Register
numStackValues
Register
scratch1
Register
scratch2
)
{
const
size_t
FRAME_TOUCH_INCREMENT
=
2048
;
static_assert
(
FRAME_TOUCH_INCREMENT
<
4096
-
1
"
Frame
increment
is
too
large
"
)
;
moveStackPtrTo
(
scratch2
)
;
mov
(
numStackValues
scratch1
)
;
lshiftPtr
(
Imm32
(
3
)
scratch1
)
;
subPtr
(
scratch1
scratch2
)
;
{
moveStackPtrTo
(
scratch1
)
;
subPtr
(
Imm32
(
FRAME_TOUCH_INCREMENT
)
scratch1
)
;
Label
touchFrameLoop
;
Label
touchFrameLoopEnd
;
bind
(
&
touchFrameLoop
)
;
branchPtr
(
Assembler
:
:
Below
scratch1
scratch2
&
touchFrameLoopEnd
)
;
store32
(
Imm32
(
0
)
Address
(
scratch1
0
)
)
;
subPtr
(
Imm32
(
FRAME_TOUCH_INCREMENT
)
scratch1
)
;
jump
(
&
touchFrameLoop
)
;
bind
(
&
touchFrameLoopEnd
)
;
}
}
namespace
js
{
namespace
jit
{
#
ifdef
DEBUG
template
<
class
RegisterType
>
AutoGenericRegisterScope
<
RegisterType
>
:
:
AutoGenericRegisterScope
(
MacroAssembler
&
masm
RegisterType
reg
)
:
RegisterType
(
reg
)
masm_
(
masm
)
released_
(
false
)
{
masm
.
debugTrackedRegisters_
.
add
(
reg
)
;
}
template
AutoGenericRegisterScope
<
Register
>
:
:
AutoGenericRegisterScope
(
MacroAssembler
&
masm
Register
reg
)
;
template
AutoGenericRegisterScope
<
FloatRegister
>
:
:
AutoGenericRegisterScope
(
MacroAssembler
&
masm
FloatRegister
reg
)
;
#
endif
#
ifdef
DEBUG
template
<
class
RegisterType
>
AutoGenericRegisterScope
<
RegisterType
>
:
:
~
AutoGenericRegisterScope
(
)
{
if
(
!
released_
)
{
release
(
)
;
}
}
template
AutoGenericRegisterScope
<
Register
>
:
:
~
AutoGenericRegisterScope
(
)
;
template
AutoGenericRegisterScope
<
FloatRegister
>
:
:
~
AutoGenericRegisterScope
(
)
;
template
<
class
RegisterType
>
void
AutoGenericRegisterScope
<
RegisterType
>
:
:
release
(
)
{
MOZ_ASSERT
(
!
released_
)
;
released_
=
true
;
const
RegisterType
&
reg
=
*
dynamic_cast
<
RegisterType
*
>
(
this
)
;
masm_
.
debugTrackedRegisters_
.
take
(
reg
)
;
}
template
void
AutoGenericRegisterScope
<
Register
>
:
:
release
(
)
;
template
void
AutoGenericRegisterScope
<
FloatRegister
>
:
:
release
(
)
;
template
<
class
RegisterType
>
void
AutoGenericRegisterScope
<
RegisterType
>
:
:
reacquire
(
)
{
MOZ_ASSERT
(
released_
)
;
released_
=
false
;
const
RegisterType
&
reg
=
*
dynamic_cast
<
RegisterType
*
>
(
this
)
;
masm_
.
debugTrackedRegisters_
.
add
(
reg
)
;
}
template
void
AutoGenericRegisterScope
<
Register
>
:
:
reacquire
(
)
;
template
void
AutoGenericRegisterScope
<
FloatRegister
>
:
:
reacquire
(
)
;
#
endif
}
}
