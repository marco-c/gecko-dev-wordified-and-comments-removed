#
ifndef
VIXL_A64_MOZ_CACHING_DECODER_A64_H_
#
define
VIXL_A64_MOZ_CACHING_DECODER_A64_H_
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
jit
/
arm64
/
vixl
/
Decoder
-
vixl
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
ifdef
DEBUG
#
define
JS_CACHE_SIMULATOR_ARM64
1
#
endif
#
ifdef
JS_CACHE_SIMULATOR_ARM64
namespace
vixl
{
enum
class
InstDecodedKind
:
uint8_t
{
NotDecodedYet
#
define
DECLARE
(
E
)
E
VISITOR_LIST
(
DECLARE
)
#
undef
DECLARE
}
;
class
SinglePageDecodeCache
{
public
:
static
const
uintptr_t
PageSize
=
1
<
<
12
;
static
const
uintptr_t
PageMask
=
PageSize
-
1
;
static
const
uintptr_t
InstSize
=
vixl
:
:
kInstructionSize
;
static
const
uintptr_t
InstMask
=
InstSize
-
1
;
static
const
uintptr_t
InstPerPage
=
PageSize
/
InstSize
;
SinglePageDecodeCache
(
const
Instruction
*
inst
)
:
pageStart_
(
PageStart
(
inst
)
)
{
memset
(
&
decodeCache_
int
(
InstDecodedKind
:
:
NotDecodedYet
)
sizeof
(
decodeCache_
)
)
;
}
static
uintptr_t
PageStart
(
const
Instruction
*
inst
)
{
return
uintptr_t
(
inst
)
&
~
PageMask
;
}
bool
contains
(
const
Instruction
*
inst
)
{
return
pageStart_
=
=
PageStart
(
inst
)
;
}
void
clearDecode
(
const
Instruction
*
inst
)
{
uintptr_t
offset
=
(
uintptr_t
(
inst
)
&
PageMask
)
/
InstSize
;
decodeCache_
[
offset
]
=
InstDecodedKind
:
:
NotDecodedYet
;
}
InstDecodedKind
*
decodePtr
(
const
Instruction
*
inst
)
{
uintptr_t
offset
=
(
uintptr_t
(
inst
)
&
PageMask
)
/
InstSize
;
uint32_t
instValue
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
inst
)
;
instCache_
[
offset
]
=
instValue
;
return
&
decodeCache_
[
offset
]
;
}
InstDecodedKind
decode
(
const
Instruction
*
inst
)
const
{
uintptr_t
offset
=
(
uintptr_t
(
inst
)
&
PageMask
)
/
InstSize
;
InstDecodedKind
val
=
decodeCache_
[
offset
]
;
uint32_t
instValue
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
inst
)
;
MOZ_ASSERT_IF
(
val
!
=
InstDecodedKind
:
:
NotDecodedYet
instCache_
[
offset
]
=
=
instValue
)
;
return
val
;
}
private
:
const
uintptr_t
pageStart_
;
uint32_t
instCache_
[
InstPerPage
]
;
InstDecodedKind
decodeCache_
[
InstPerPage
]
;
}
;
class
CachingDecoderVisitor
:
public
DecoderVisitor
{
public
:
CachingDecoderVisitor
(
)
=
default
;
virtual
~
CachingDecoderVisitor
(
)
{
}
#
define
DECLARE
(
A
)
\
virtual
void
Visit
#
#
A
(
const
Instruction
*
instr
)
{
\
if
(
last_
)
{
\
MOZ_ASSERT
(
*
last_
=
=
InstDecodedKind
:
:
NotDecodedYet
)
;
\
*
last_
=
InstDecodedKind
:
:
A
;
\
last_
=
nullptr
;
\
}
\
}
;
VISITOR_LIST
(
DECLARE
)
#
undef
DECLARE
void
setDecodePtr
(
InstDecodedKind
*
ptr
)
{
last_
=
ptr
;
}
private
:
InstDecodedKind
*
last_
;
}
;
class
CachingDecoder
:
public
Decoder
{
using
ICacheMap
=
mozilla
:
:
HashMap
<
uintptr_t
SinglePageDecodeCache
*
>
;
public
:
CachingDecoder
(
)
:
lastPage_
(
nullptr
)
{
PrependVisitor
(
&
cachingDecoder_
)
;
}
~
CachingDecoder
(
)
{
RemoveVisitor
(
&
cachingDecoder_
)
;
}
void
Decode
(
const
Instruction
*
instr
)
;
void
Decode
(
Instruction
*
instr
)
{
Decode
(
const_cast
<
const
Instruction
*
>
(
instr
)
)
;
}
void
FlushICache
(
void
*
start
size_t
size
)
;
private
:
CachingDecoderVisitor
cachingDecoder_
;
ICacheMap
iCache_
;
SinglePageDecodeCache
*
lastPage_
;
}
;
}
#
endif
#
endif
