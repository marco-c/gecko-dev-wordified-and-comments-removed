#
ifndef
jit_arm64_SharedICHelpers_arm64_h
#
define
jit_arm64_SharedICHelpers_arm64_h
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
namespace
js
{
namespace
jit
{
static
const
size_t
ICStackValueOffset
=
0
;
inline
void
EmitRestoreTailCallReg
(
MacroAssembler
&
masm
)
{
}
inline
void
EmitRepushTailCallReg
(
MacroAssembler
&
masm
)
{
}
inline
void
EmitCallIC
(
CodeOffset
*
patchOffset
MacroAssembler
&
masm
)
{
CodeOffset
offset
=
masm
.
movWithPatch
(
ImmWord
(
-
1
)
ICStubReg
)
;
*
patchOffset
=
offset
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICEntry
:
:
offsetOfFirstStub
(
)
)
ICStubReg
)
;
MOZ_ASSERT
(
R2
=
=
ValueOperand
(
r0
)
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
r0
)
;
masm
.
Blr
(
x0
)
;
}
inline
void
EmitEnterTypeMonitorIC
(
MacroAssembler
&
masm
size_t
monitorStubOffset
=
ICMonitoredStub
:
:
offsetOfFirstMonitorStub
(
)
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
(
uint32_t
)
monitorStubOffset
)
ICStubReg
)
;
MOZ_ASSERT
(
R2
=
=
ValueOperand
(
r0
)
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
r0
)
;
masm
.
Br
(
x0
)
;
}
inline
void
EmitReturnFromIC
(
MacroAssembler
&
masm
)
{
masm
.
abiret
(
)
;
}
inline
void
EmitChangeICReturnAddress
(
MacroAssembler
&
masm
Register
reg
)
{
masm
.
movePtr
(
reg
lr
)
;
}
inline
void
EmitBaselineLeaveStubFrame
(
MacroAssembler
&
masm
bool
calledIntoIon
=
false
)
{
vixl
:
:
UseScratchRegisterScope
temps
(
&
masm
.
asVIXL
(
)
)
;
const
ARMRegister
scratch64
=
temps
.
AcquireX
(
)
;
if
(
calledIntoIon
)
{
masm
.
pop
(
scratch64
.
asUnsized
(
)
)
;
masm
.
Lsr
(
scratch64
scratch64
FRAMESIZE_SHIFT
)
;
masm
.
Add
(
masm
.
GetStackPointer64
(
)
masm
.
GetStackPointer64
(
)
scratch64
)
;
}
else
{
masm
.
Mov
(
masm
.
GetStackPointer64
(
)
BaselineFrameReg64
)
;
}
masm
.
pop
(
BaselineFrameReg
ICStubReg
ICTailCallReg
scratch64
.
asUnsized
(
)
)
;
masm
.
checkStackAlignment
(
)
;
}
inline
void
EmitStowICValues
(
MacroAssembler
&
masm
int
values
)
{
switch
(
values
)
{
case
1
:
masm
.
Push
(
R0
)
;
break
;
case
2
:
masm
.
Push
(
R0
.
valueReg
(
)
)
;
masm
.
Push
(
R1
.
valueReg
(
)
)
;
break
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Expected
1
or
2
values
"
)
;
}
}
template
<
typename
AddrType
>
inline
void
EmitPreBarrier
(
MacroAssembler
&
masm
const
AddrType
&
addr
MIRType
type
)
{
masm
.
push
(
lr
)
;
masm
.
guardedCallPreBarrier
(
addr
type
)
;
masm
.
pop
(
lr
)
;
}
inline
void
EmitStubGuardFailure
(
MacroAssembler
&
masm
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICStub
:
:
offsetOfNext
(
)
)
ICStubReg
)
;
masm
.
jump
(
Address
(
ICStubReg
ICStub
:
:
offsetOfStubCode
(
)
)
)
;
}
}
}
#
endif
