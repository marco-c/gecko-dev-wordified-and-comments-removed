#
ifndef
VIXL_CPU_FEATURES_H
#
define
VIXL_CPU_FEATURES_H
#
include
<
bitset
>
#
include
<
ostream
>
#
include
"
jit
/
arm64
/
vixl
/
Globals
-
vixl
.
h
"
namespace
vixl
{
#
define
VIXL_CPU_FEATURE_LIST
(
V
)
\
V
(
kIDRegisterEmulation
"
ID
register
emulation
"
"
cpuid
"
)
\
\
V
(
kFP
"
FP
"
"
fp
"
)
\
V
(
kNEON
"
NEON
"
"
asimd
"
)
\
V
(
kCRC32
"
CRC32
"
"
crc32
"
)
\
V
(
kDGH
"
DGH
"
"
dgh
"
)
\
/
*
Speculation
control
features
.
*
/
\
V
(
kCSV2
"
CSV2
"
NULL
)
\
V
(
kSCXTNUM
"
SCXTNUM
"
NULL
)
\
V
(
kCSV3
"
CSV3
"
NULL
)
\
V
(
kSB
"
SB
"
"
sb
"
)
\
V
(
kSPECRES
"
SPECRES
"
NULL
)
\
V
(
kSSBS
"
SSBS
"
NULL
)
\
V
(
kSSBSControl
"
SSBS
(
PSTATE
control
)
"
"
ssbs
"
)
\
/
*
Cryptographic
support
instructions
.
*
/
\
V
(
kAES
"
AES
"
"
aes
"
)
\
V
(
kSHA1
"
SHA1
"
"
sha1
"
)
\
V
(
kSHA2
"
SHA2
"
"
sha2
"
)
\
/
*
A
form
of
PMULL
{
2
}
with
a
128
-
bit
(
1Q
)
result
.
*
/
\
V
(
kPmull1Q
"
Pmull1Q
"
"
pmull
"
)
\
/
*
Atomic
operations
on
memory
:
CAS
LDADD
STADD
SWP
etc
.
*
/
\
V
(
kAtomics
"
Atomics
"
"
atomics
"
)
\
/
*
Limited
ordering
regions
:
LDLAR
STLLR
and
their
variants
.
*
/
\
V
(
kLORegions
"
LORegions
"
NULL
)
\
/
*
Rounding
doubling
multiply
add
/
subtract
:
SQRDMLAH
and
SQRDMLSH
.
*
/
\
V
(
kRDM
"
RDM
"
"
asimdrdm
"
)
\
/
*
Scalable
Vector
Extension
.
*
/
\
V
(
kSVE
"
SVE
"
"
sve
"
)
\
V
(
kSVEF64MM
"
SVE
F64MM
"
"
svef64mm
"
)
\
V
(
kSVEF32MM
"
SVE
F32MM
"
"
svef32mm
"
)
\
V
(
kSVEI8MM
"
SVE
I8MM
"
"
svei8imm
"
)
\
V
(
kSVEBF16
"
SVE
BFloat16
"
"
svebf16
"
)
\
/
*
SDOT
and
UDOT
support
(
in
NEON
)
.
*
/
\
V
(
kDotProduct
"
DotProduct
"
"
asimddp
"
)
\
/
*
Int8
matrix
multiplication
(
in
NEON
)
.
*
/
\
V
(
kI8MM
"
NEON
I8MM
"
"
i8mm
"
)
\
/
*
Half
-
precision
(
FP16
)
support
for
FP
and
NEON
respectively
.
*
/
\
V
(
kFPHalf
"
FPHalf
"
"
fphp
"
)
\
V
(
kNEONHalf
"
NEONHalf
"
"
asimdhp
"
)
\
/
*
BFloat16
support
(
in
both
FP
and
NEON
.
)
*
/
\
V
(
kBF16
"
FP
/
NEON
BFloat
16
"
"
bf16
"
)
\
/
*
The
RAS
extension
including
the
ESB
instruction
.
*
/
\
V
(
kRAS
"
RAS
"
NULL
)
\
/
*
Data
cache
clean
to
the
point
of
persistence
:
DC
CVAP
.
*
/
\
V
(
kDCPoP
"
DCPoP
"
"
dcpop
"
)
\
/
*
Data
cache
clean
to
the
point
of
deep
persistence
:
DC
CVADP
.
*
/
\
V
(
kDCCVADP
"
DCCVADP
"
"
dcpodp
"
)
\
/
*
Cryptographic
support
instructions
.
*
/
\
V
(
kSHA3
"
SHA3
"
"
sha3
"
)
\
V
(
kSHA512
"
SHA512
"
"
sha512
"
)
\
V
(
kSM3
"
SM3
"
"
sm3
"
)
\
V
(
kSM4
"
SM4
"
"
sm4
"
)
\
/
*
Pointer
authentication
for
addresses
.
*
/
\
V
(
kPAuth
"
PAuth
"
"
paca
"
)
\
/
*
Pointer
authentication
for
addresses
uses
QARMA
.
*
/
\
V
(
kPAuthQARMA
"
PAuthQARMA
"
NULL
)
\
/
*
Generic
authentication
(
using
the
PACGA
instruction
)
.
*
/
\
V
(
kPAuthGeneric
"
PAuthGeneric
"
"
pacg
"
)
\
/
*
Generic
authentication
uses
QARMA
.
*
/
\
V
(
kPAuthGenericQARMA
"
PAuthGenericQARMA
"
NULL
)
\
/
*
JavaScript
-
style
FP
-
>
integer
conversion
instruction
:
FJCVTZS
.
*
/
\
V
(
kJSCVT
"
JSCVT
"
"
jscvt
"
)
\
/
*
Complex
number
support
for
NEON
:
FCMLA
and
FCADD
.
*
/
\
V
(
kFcma
"
Fcma
"
"
fcma
"
)
\
/
*
RCpc
-
based
model
(
for
weaker
release
consistency
)
:
LDAPR
and
variants
.
*
/
\
V
(
kRCpc
"
RCpc
"
"
lrcpc
"
)
\
V
(
kRCpcImm
"
RCpc
(
imm
)
"
"
ilrcpc
"
)
\
/
*
Flag
manipulation
instructions
:
SETF
{
8
16
}
CFINV
RMIF
.
*
/
\
V
(
kFlagM
"
FlagM
"
"
flagm
"
)
\
/
*
Unaligned
single
-
copy
atomicity
.
*
/
\
V
(
kUSCAT
"
USCAT
"
"
uscat
"
)
\
/
*
FP16
fused
multiply
-
add
or
-
subtract
long
:
FMLAL
{
2
}
FMLSL
{
2
}
.
*
/
\
V
(
kFHM
"
FHM
"
"
asimdfhm
"
)
\
/
*
Data
-
independent
timing
(
for
selected
instructions
)
.
*
/
\
V
(
kDIT
"
DIT
"
"
dit
"
)
\
/
*
Branch
target
identification
.
*
/
\
V
(
kBTI
"
BTI
"
"
bti
"
)
\
/
*
Flag
manipulation
instructions
:
{
AX
XA
}
FLAG
*
/
\
V
(
kAXFlag
"
AXFlag
"
"
flagm2
"
)
\
/
*
Random
number
generation
extension
*
/
\
V
(
kRNG
"
RNG
"
"
rng
"
)
\
/
*
Floating
-
point
round
to
{
32
64
}
-
bit
integer
.
*
/
\
V
(
kFrintToFixedSizedInt
"
Frint
(
bounded
)
"
"
frint
"
)
\
/
*
Memory
Tagging
Extension
.
*
/
\
V
(
kMTEInstructions
"
MTE
(
EL0
instructions
)
"
NULL
)
\
V
(
kMTE
"
MTE
"
NULL
)
\
V
(
kMTE3
"
MTE
(
asymmetric
)
"
"
mte3
"
)
\
/
*
PAuth
extensions
.
*
/
\
V
(
kPAuthEnhancedPAC
"
PAuth
EnhancedPAC
"
NULL
)
\
V
(
kPAuthEnhancedPAC2
"
PAuth
EnhancedPAC2
"
NULL
)
\
V
(
kPAuthFPAC
"
PAuth
FPAC
"
NULL
)
\
V
(
kPAuthFPACCombined
"
PAuth
FPACCombined
"
NULL
)
\
/
*
Scalable
Vector
Extension
2
.
*
/
\
V
(
kSVE2
"
SVE2
"
"
sve2
"
)
\
V
(
kSVESM4
"
SVE
SM4
"
"
svesm4
"
)
\
V
(
kSVESHA3
"
SVE
SHA3
"
"
svesha3
"
)
\
V
(
kSVEBitPerm
"
SVE
BitPerm
"
"
svebitperm
"
)
\
V
(
kSVEAES
"
SVE
AES
"
"
sveaes
"
)
\
V
(
kSVEPmull128
"
SVE
Pmull128
"
"
svepmull
"
)
\
/
*
Alternate
floating
-
point
behavior
*
/
\
V
(
kAFP
"
AFP
"
"
afp
"
)
\
/
*
Enhanced
Counter
Virtualization
*
/
\
V
(
kECV
"
ECV
"
"
ecv
"
)
\
/
*
Increased
precision
of
Reciprocal
Estimate
and
Square
Root
Estimate
*
/
\
V
(
kRPRES
"
RPRES
"
"
rpres
"
)
\
/
*
Memory
operation
instructions
for
memcpy
memset
*
/
\
V
(
kMOPS
"
Memory
ops
"
NULL
)
\
/
*
Scalable
Matrix
Extension
(
SME
)
*
/
\
V
(
kSME
"
SME
"
"
sme
"
)
\
V
(
kSMEi16i64
"
SME
(
i16i64
)
"
"
smei16i64
"
)
\
V
(
kSMEf64f64
"
SME
(
f64f64
)
"
"
smef64f64
"
)
\
V
(
kSMEi8i32
"
SME
(
i8i32
)
"
"
smei8i32
"
)
\
V
(
kSMEf16f32
"
SME
(
f16f32
)
"
"
smef16f32
"
)
\
V
(
kSMEb16f32
"
SME
(
b16f32
)
"
"
smeb16f32
"
)
\
V
(
kSMEf32f32
"
SME
(
f32f32
)
"
"
smef32f32
"
)
\
V
(
kSMEfa64
"
SME
(
fa64
)
"
"
smefa64
"
)
\
/
*
WFET
and
WFIT
instruction
support
*
/
\
V
(
kWFXT
"
WFXT
"
"
wfxt
"
)
\
/
*
Extended
BFloat16
instructions
*
/
\
V
(
kEBF16
"
EBF16
"
"
ebf16
"
)
\
V
(
kSVE_EBF16
"
EBF16
(
SVE
)
"
"
sveebf16
"
)
\
V
(
kCSSC
"
CSSC
"
"
cssc
"
)
\
V
(
kGCS
"
GCS
"
"
gcs
"
)
class
CPUFeaturesConstIterator
;
class
CPUFeatures
{
public
:
enum
Feature
{
kNone
=
-
1
#
define
VIXL_DECLARE_FEATURE
(
SYMBOL
NAME
CPUINFO
)
SYMBOL
VIXL_CPU_FEATURE_LIST
(
VIXL_DECLARE_FEATURE
)
#
undef
VIXL_DECLARE_FEATURE
kNumberOfFeatures
}
;
constexpr
CPUFeatures
(
)
:
features_
{
}
{
}
template
<
typename
T
typename
.
.
.
U
>
CPUFeatures
(
T
first
U
.
.
.
others
)
:
features_
{
}
{
Combine
(
first
others
.
.
.
)
;
}
static
CPUFeatures
All
(
)
;
static
CPUFeatures
None
(
)
{
return
CPUFeatures
(
)
;
}
static
CPUFeatures
AArch64LegacyBaseline
(
)
{
return
CPUFeatures
(
kFP
kNEON
kCRC32
)
;
}
static
CPUFeatures
InferFromIDRegisters
(
)
;
enum
QueryIDRegistersOption
{
kDontQueryIDRegisters
kQueryIDRegistersIfAvailable
}
;
static
CPUFeatures
InferFromOS
(
QueryIDRegistersOption
option
=
kQueryIDRegistersIfAvailable
)
;
void
Combine
(
const
CPUFeatures
&
other
)
;
void
Combine
(
Feature
feature
)
;
template
<
typename
T
typename
.
.
.
U
>
void
Combine
(
T
first
U
.
.
.
others
)
{
Combine
(
first
)
;
Combine
(
others
.
.
.
)
;
}
void
Remove
(
const
CPUFeatures
&
other
)
;
void
Remove
(
Feature
feature0
)
;
template
<
typename
T
typename
.
.
.
U
>
void
Remove
(
T
first
U
.
.
.
others
)
{
Remove
(
first
)
;
Remove
(
others
.
.
.
)
;
}
template
<
typename
.
.
.
T
>
CPUFeatures
With
(
T
.
.
.
others
)
const
{
CPUFeatures
f
(
*
this
)
;
f
.
Combine
(
others
.
.
.
)
;
return
f
;
}
template
<
typename
.
.
.
T
>
CPUFeatures
Without
(
T
.
.
.
others
)
const
{
CPUFeatures
f
(
*
this
)
;
f
.
Remove
(
others
.
.
.
)
;
return
f
;
}
bool
Has
(
const
CPUFeatures
&
other
)
const
;
bool
Has
(
Feature
feature
)
const
;
template
<
typename
T
typename
.
.
.
U
>
bool
Has
(
T
first
U
.
.
.
others
)
const
{
return
Has
(
first
)
&
&
Has
(
others
.
.
.
)
;
}
size_t
Count
(
)
const
;
bool
HasNoFeatures
(
)
const
{
return
Count
(
)
=
=
0
;
}
bool
operator
=
=
(
const
CPUFeatures
&
other
)
const
{
return
Has
(
other
)
&
&
other
.
Has
(
*
this
)
;
}
bool
operator
!
=
(
const
CPUFeatures
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
typedef
CPUFeaturesConstIterator
const_iterator
;
const_iterator
begin
(
)
const
;
const_iterator
end
(
)
const
;
private
:
std
:
:
bitset
<
kNumberOfFeatures
>
features_
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
vixl
:
:
CPUFeatures
&
features
)
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
vixl
:
:
CPUFeatures
:
:
Feature
feature
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
vixl
:
:
CPUFeatures
&
features
)
;
class
CPUFeaturesConstIterator
{
public
:
CPUFeaturesConstIterator
(
const
CPUFeatures
*
cpu_features
=
NULL
CPUFeatures
:
:
Feature
start
=
CPUFeatures
:
:
kNone
)
:
cpu_features_
(
cpu_features
)
feature_
(
start
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
}
bool
operator
=
=
(
const
CPUFeaturesConstIterator
&
other
)
const
;
bool
operator
!
=
(
const
CPUFeaturesConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
CPUFeaturesConstIterator
&
operator
+
+
(
)
;
CPUFeaturesConstIterator
operator
+
+
(
int
)
;
CPUFeatures
:
:
Feature
operator
*
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
feature_
;
}
private
:
const
CPUFeatures
*
cpu_features_
;
CPUFeatures
:
:
Feature
feature_
;
bool
IsValid
(
)
const
{
if
(
cpu_features_
=
=
NULL
)
{
return
feature_
=
=
CPUFeatures
:
:
kNone
;
}
return
cpu_features_
-
>
Has
(
feature_
)
;
}
}
;
class
CPUFeaturesScope
{
public
:
template
<
typename
T
>
explicit
CPUFeaturesScope
(
T
*
cpu_features_wrapper
)
:
cpu_features_
(
cpu_features_wrapper
-
>
GetCPUFeatures
(
)
)
old_features_
(
*
cpu_features_
)
{
}
template
<
typename
T
typename
U
typename
.
.
.
V
>
CPUFeaturesScope
(
T
*
cpu_features_wrapper
U
first
V
.
.
.
features
)
:
cpu_features_
(
cpu_features_wrapper
-
>
GetCPUFeatures
(
)
)
old_features_
(
*
cpu_features_
)
{
cpu_features_
-
>
Combine
(
first
features
.
.
.
)
;
}
~
CPUFeaturesScope
(
)
{
*
cpu_features_
=
old_features_
;
}
CPUFeatures
*
GetCPUFeatures
(
)
const
{
return
cpu_features_
;
}
void
SetCPUFeatures
(
const
CPUFeatures
&
cpu_features
)
{
*
cpu_features_
=
cpu_features
;
}
private
:
CPUFeatures
*
const
cpu_features_
;
const
CPUFeatures
old_features_
;
}
;
}
#
endif
