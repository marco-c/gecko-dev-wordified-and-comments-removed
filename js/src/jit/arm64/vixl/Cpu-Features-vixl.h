#
ifndef
VIXL_CPU_FEATURES_H
#
define
VIXL_CPU_FEATURES_H
#
include
<
ostream
>
#
include
"
jit
/
arm64
/
vixl
/
Globals
-
vixl
.
h
"
namespace
vixl
{
#
define
VIXL_CPU_FEATURE_LIST
(
V
)
\
V
(
kIDRegisterEmulation
"
ID
register
emulation
"
"
cpuid
"
)
\
\
V
(
kFP
"
FP
"
"
fp
"
)
\
V
(
kNEON
"
NEON
"
"
asimd
"
)
\
V
(
kCRC32
"
CRC32
"
"
crc32
"
)
\
/
*
Cryptographic
support
instructions
.
*
/
\
V
(
kAES
"
AES
"
"
aes
"
)
\
V
(
kSHA1
"
SHA1
"
"
sha1
"
)
\
V
(
kSHA2
"
SHA2
"
"
sha2
"
)
\
/
*
A
form
of
PMULL
{
2
}
with
a
128
-
bit
(
1Q
)
result
.
*
/
\
V
(
kPmull1Q
"
Pmull1Q
"
"
pmull
"
)
\
/
*
Atomic
operations
on
memory
:
CAS
LDADD
STADD
SWP
etc
.
*
/
\
V
(
kAtomics
"
Atomics
"
"
atomics
"
)
\
/
*
Limited
ordering
regions
:
LDLAR
STLLR
and
their
variants
.
*
/
\
V
(
kLORegions
"
LORegions
"
NULL
)
\
/
*
Rounding
doubling
multiply
add
/
subtract
:
SQRDMLAH
and
SQRDMLSH
.
*
/
\
V
(
kRDM
"
RDM
"
"
asimdrdm
"
)
\
/
*
Scalable
Vector
Extension
.
*
/
\
V
(
kSVE
"
SVE
"
"
sve
"
)
\
/
*
SDOT
and
UDOT
support
(
in
NEON
)
.
*
/
\
V
(
kDotProduct
"
DotProduct
"
"
asimddp
"
)
\
/
*
Half
-
precision
(
FP16
)
support
for
FP
and
NEON
respectively
.
*
/
\
V
(
kFPHalf
"
FPHalf
"
"
fphp
"
)
\
V
(
kNEONHalf
"
NEONHalf
"
"
asimdhp
"
)
\
/
*
The
RAS
extension
including
the
ESB
instruction
.
*
/
\
V
(
kRAS
"
RAS
"
NULL
)
\
/
*
Data
cache
clean
to
the
point
of
persistence
:
DC
CVAP
.
*
/
\
V
(
kDCPoP
"
DCPoP
"
"
dcpop
"
)
\
/
*
Data
cache
clean
to
the
point
of
deep
persistence
:
DC
CVADP
.
*
/
\
V
(
kDCCVADP
"
DCCVADP
"
NULL
)
\
/
*
Cryptographic
support
instructions
.
*
/
\
V
(
kSHA3
"
SHA3
"
"
sha3
"
)
\
V
(
kSHA512
"
SHA512
"
"
sha512
"
)
\
V
(
kSM3
"
SM3
"
"
sm3
"
)
\
V
(
kSM4
"
SM4
"
"
sm4
"
)
\
/
*
Pointer
authentication
for
addresses
.
*
/
\
V
(
kPAuth
"
PAuth
"
NULL
)
\
/
*
Pointer
authentication
for
addresses
uses
QARMA
.
*
/
\
V
(
kPAuthQARMA
"
PAuthQARMA
"
NULL
)
\
/
*
Generic
authentication
(
using
the
PACGA
instruction
)
.
*
/
\
V
(
kPAuthGeneric
"
PAuthGeneric
"
NULL
)
\
/
*
Generic
authentication
uses
QARMA
.
*
/
\
V
(
kPAuthGenericQARMA
"
PAuthGenericQARMA
"
NULL
)
\
/
*
JavaScript
-
style
FP
-
>
integer
conversion
instruction
:
FJCVTZS
.
*
/
\
V
(
kJSCVT
"
JSCVT
"
"
jscvt
"
)
\
/
*
Complex
number
support
for
NEON
:
FCMLA
and
FCADD
.
*
/
\
V
(
kFcma
"
Fcma
"
"
fcma
"
)
\
/
*
RCpc
-
based
model
(
for
weaker
release
consistency
)
:
LDAPR
and
variants
.
*
/
\
V
(
kRCpc
"
RCpc
"
"
lrcpc
"
)
\
V
(
kRCpcImm
"
RCpc
(
imm
)
"
"
ilrcpc
"
)
\
/
*
Flag
manipulation
instructions
:
SETF
{
8
16
}
CFINV
RMIF
.
*
/
\
V
(
kFlagM
"
FlagM
"
"
flagm
"
)
\
/
*
Unaligned
single
-
copy
atomicity
.
*
/
\
V
(
kUSCAT
"
USCAT
"
"
uscat
"
)
\
/
*
FP16
fused
multiply
-
add
or
-
subtract
long
:
FMLAL
{
2
}
FMLSL
{
2
}
.
*
/
\
V
(
kFHM
"
FHM
"
"
asimdfhm
"
)
\
/
*
Data
-
independent
timing
(
for
selected
instructions
)
.
*
/
\
V
(
kDIT
"
DIT
"
"
dit
"
)
\
/
*
Branch
target
identification
.
*
/
\
V
(
kBTI
"
BTI
"
NULL
)
\
/
*
Flag
manipulation
instructions
:
{
AX
XA
}
FLAG
*
/
\
V
(
kAXFlag
"
AXFlag
"
NULL
)
\
/
*
Random
number
generation
extension
*
/
\
V
(
kRNG
"
RNG
"
NULL
)
\
/
*
Floating
-
point
round
to
{
32
64
}
-
bit
integer
.
*
/
\
V
(
kFrintToFixedSizedInt
"
Frint
(
bounded
)
"
NULL
)
class
CPUFeaturesConstIterator
;
class
CPUFeatures
{
public
:
enum
Feature
{
kNone
=
-
1
#
define
VIXL_DECLARE_FEATURE
(
SYMBOL
NAME
CPUINFO
)
SYMBOL
VIXL_CPU_FEATURE_LIST
(
VIXL_DECLARE_FEATURE
)
#
undef
VIXL_DECLARE_FEATURE
kNumberOfFeatures
}
;
CPUFeatures
(
)
:
features_
(
0
)
{
}
CPUFeatures
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
;
static
CPUFeatures
All
(
)
;
static
CPUFeatures
None
(
)
{
return
CPUFeatures
(
)
;
}
static
CPUFeatures
AArch64LegacyBaseline
(
)
{
return
CPUFeatures
(
kFP
kNEON
kCRC32
)
;
}
static
CPUFeatures
InferFromIDRegisters
(
)
;
enum
QueryIDRegistersOption
{
kDontQueryIDRegisters
kQueryIDRegistersIfAvailable
}
;
static
CPUFeatures
InferFromOS
(
QueryIDRegistersOption
option
=
kQueryIDRegistersIfAvailable
)
;
void
Combine
(
const
CPUFeatures
&
other
)
;
void
Combine
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
;
void
Remove
(
const
CPUFeatures
&
other
)
;
void
Remove
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
;
CPUFeatures
With
(
const
CPUFeatures
&
other
)
const
;
CPUFeatures
With
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
const
;
CPUFeatures
Without
(
const
CPUFeatures
&
other
)
const
;
CPUFeatures
Without
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
const
;
bool
Has
(
const
CPUFeatures
&
other
)
const
;
bool
Has
(
Feature
feature0
Feature
feature1
=
kNone
Feature
feature2
=
kNone
Feature
feature3
=
kNone
)
const
;
size_t
Count
(
)
const
;
bool
HasNoFeatures
(
)
const
{
return
Count
(
)
=
=
0
;
}
bool
operator
=
=
(
const
CPUFeatures
&
other
)
const
{
return
Has
(
other
)
&
&
other
.
Has
(
*
this
)
;
}
bool
operator
!
=
(
const
CPUFeatures
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
typedef
CPUFeaturesConstIterator
const_iterator
;
const_iterator
begin
(
)
const
;
const_iterator
end
(
)
const
;
private
:
uint64_t
features_
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
vixl
:
:
CPUFeatures
&
features
)
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
vixl
:
:
CPUFeatures
:
:
Feature
feature
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
vixl
:
:
CPUFeatures
&
features
)
;
class
CPUFeaturesConstIterator
{
public
:
CPUFeaturesConstIterator
(
const
CPUFeatures
*
cpu_features
=
NULL
CPUFeatures
:
:
Feature
start
=
CPUFeatures
:
:
kNone
)
:
cpu_features_
(
cpu_features
)
feature_
(
start
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
}
bool
operator
=
=
(
const
CPUFeaturesConstIterator
&
other
)
const
;
bool
operator
!
=
(
const
CPUFeaturesConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
CPUFeatures
:
:
Feature
operator
+
+
(
)
;
CPUFeatures
:
:
Feature
operator
+
+
(
int
)
;
CPUFeatures
:
:
Feature
operator
*
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
feature_
;
}
private
:
const
CPUFeatures
*
cpu_features_
;
CPUFeatures
:
:
Feature
feature_
;
bool
IsValid
(
)
const
{
return
(
(
cpu_features_
=
=
NULL
)
&
&
(
feature_
=
=
CPUFeatures
:
:
kNone
)
)
|
|
cpu_features_
-
>
Has
(
feature_
)
;
}
}
;
class
CPUFeaturesScope
{
public
:
template
<
typename
T
>
explicit
CPUFeaturesScope
(
T
*
cpu_features_wrapper
CPUFeatures
:
:
Feature
feature0
=
CPUFeatures
:
:
kNone
CPUFeatures
:
:
Feature
feature1
=
CPUFeatures
:
:
kNone
CPUFeatures
:
:
Feature
feature2
=
CPUFeatures
:
:
kNone
CPUFeatures
:
:
Feature
feature3
=
CPUFeatures
:
:
kNone
)
:
cpu_features_
(
cpu_features_wrapper
-
>
GetCPUFeatures
(
)
)
old_features_
(
*
cpu_features_
)
{
cpu_features_
-
>
Combine
(
feature0
feature1
feature2
feature3
)
;
}
template
<
typename
T
>
CPUFeaturesScope
(
T
*
cpu_features_wrapper
const
CPUFeatures
&
other
)
:
cpu_features_
(
cpu_features_wrapper
-
>
GetCPUFeatures
(
)
)
old_features_
(
*
cpu_features_
)
{
cpu_features_
-
>
Combine
(
other
)
;
}
~
CPUFeaturesScope
(
)
{
*
cpu_features_
=
old_features_
;
}
CPUFeatures
*
GetCPUFeatures
(
)
const
{
return
cpu_features_
;
}
void
SetCPUFeatures
(
const
CPUFeatures
&
cpu_features
)
{
*
cpu_features_
=
cpu_features
;
}
private
:
CPUFeatures
*
const
cpu_features_
;
const
CPUFeatures
old_features_
;
}
;
}
#
endif
