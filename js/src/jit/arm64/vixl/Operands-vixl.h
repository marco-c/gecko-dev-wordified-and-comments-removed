#
ifndef
VIXL_A64_OPERANDS_A64_H_
#
define
VIXL_A64_OPERANDS_A64_H_
#
include
"
jit
/
arm64
/
vixl
/
Instructions
-
vixl
.
h
"
#
include
"
jit
/
arm64
/
vixl
/
Registers
-
vixl
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
namespace
vixl
{
class
CPURegList
{
public
:
explicit
CPURegList
(
CPURegister
reg1
CPURegister
reg2
=
NoCPUReg
CPURegister
reg3
=
NoCPUReg
CPURegister
reg4
=
NoCPUReg
)
:
list_
(
reg1
.
GetBit
(
)
|
reg2
.
GetBit
(
)
|
reg3
.
GetBit
(
)
|
reg4
.
GetBit
(
)
)
size_
(
reg1
.
GetSizeInBits
(
)
)
type_
(
reg1
.
GetType
(
)
)
{
VIXL_ASSERT
(
AreSameSizeAndType
(
reg1
reg2
reg3
reg4
)
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
CPURegList
(
CPURegister
:
:
RegisterType
type
unsigned
size
RegList
list
)
:
list_
(
list
)
size_
(
size
)
type_
(
type
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
}
CPURegList
(
CPURegister
:
:
RegisterType
type
unsigned
size
unsigned
first_reg
unsigned
last_reg
)
:
size_
(
size
)
type_
(
type
)
{
VIXL_ASSERT
(
(
(
type
=
=
CPURegister
:
:
kRegister
)
&
&
(
last_reg
<
kNumberOfRegisters
)
)
|
|
(
(
type
=
=
CPURegister
:
:
kVRegister
)
&
&
(
last_reg
<
kNumberOfVRegisters
)
)
)
;
VIXL_ASSERT
(
last_reg
>
=
first_reg
)
;
list_
=
(
UINT64_C
(
1
)
<
<
(
last_reg
+
1
)
)
-
1
;
list_
&
=
~
(
(
UINT64_C
(
1
)
<
<
first_reg
)
-
1
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
static
CPURegList
Empty
(
CPURegister
:
:
RegisterType
type
unsigned
size
=
CPURegister
:
:
kUnknownSize
)
{
return
CPURegList
(
type
GetDefaultSizeFor
(
type
size
)
0
)
;
}
static
CPURegList
All
(
CPURegister
:
:
RegisterType
type
unsigned
size
=
CPURegister
:
:
kUnknownSize
)
{
unsigned
number_of_registers
=
(
CPURegister
:
:
GetMaxCodeFor
(
type
)
+
1
)
;
RegList
list
=
(
static_cast
<
RegList
>
(
1
)
<
<
number_of_registers
)
-
1
;
if
(
type
=
=
CPURegister
:
:
kRegister
)
{
list
|
=
(
static_cast
<
RegList
>
(
1
)
<
<
kSPRegInternalCode
)
;
}
return
CPURegList
(
type
GetDefaultSizeFor
(
type
size
)
list
)
;
}
CPURegister
:
:
RegisterType
GetType
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
type_
;
}
CPURegister
:
:
RegisterType
type
(
)
const
{
return
GetType
(
)
;
}
CPURegister
:
:
RegisterBank
GetBank
(
)
const
{
return
CPURegister
:
:
GetBankFor
(
GetType
(
)
)
;
}
void
Combine
(
const
CPURegList
&
other
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
other
.
GetType
(
)
=
=
type_
)
;
VIXL_ASSERT
(
other
.
GetRegisterSizeInBits
(
)
=
=
size_
)
;
list_
|
=
other
.
GetList
(
)
;
}
void
Remove
(
const
CPURegList
&
other
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
other
.
GetType
(
)
=
=
type_
)
;
VIXL_ASSERT
(
other
.
GetRegisterSizeInBits
(
)
=
=
size_
)
;
list_
&
=
~
other
.
GetList
(
)
;
}
void
Combine
(
const
CPURegister
&
other
)
{
VIXL_ASSERT
(
other
.
GetType
(
)
=
=
type_
)
;
VIXL_ASSERT
(
other
.
GetSizeInBits
(
)
=
=
size_
)
;
Combine
(
other
.
GetCode
(
)
)
;
}
void
Remove
(
const
CPURegister
&
other
)
{
VIXL_ASSERT
(
other
.
GetType
(
)
=
=
type_
)
;
VIXL_ASSERT
(
other
.
GetSizeInBits
(
)
=
=
size_
)
;
Remove
(
other
.
GetCode
(
)
)
;
}
void
Combine
(
int
code
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
CPURegister
(
code
size_
type_
)
.
IsValid
(
)
)
;
list_
|
=
(
UINT64_C
(
1
)
<
<
code
)
;
}
void
Remove
(
int
code
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
CPURegister
(
code
size_
type_
)
.
IsValid
(
)
)
;
list_
&
=
~
(
UINT64_C
(
1
)
<
<
code
)
;
}
static
CPURegList
Union
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
)
{
VIXL_ASSERT
(
list_1
.
type_
=
=
list_2
.
type_
)
;
VIXL_ASSERT
(
list_1
.
size_
=
=
list_2
.
size_
)
;
return
CPURegList
(
list_1
.
type_
list_1
.
size_
list_1
.
list_
|
list_2
.
list_
)
;
}
static
CPURegList
Union
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
const
CPURegList
&
list_3
)
;
static
CPURegList
Union
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
const
CPURegList
&
list_3
const
CPURegList
&
list_4
)
;
static
CPURegList
Intersection
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
)
{
VIXL_ASSERT
(
list_1
.
type_
=
=
list_2
.
type_
)
;
VIXL_ASSERT
(
list_1
.
size_
=
=
list_2
.
size_
)
;
return
CPURegList
(
list_1
.
type_
list_1
.
size_
list_1
.
list_
&
list_2
.
list_
)
;
}
static
CPURegList
Intersection
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
const
CPURegList
&
list_3
)
;
static
CPURegList
Intersection
(
const
CPURegList
&
list_1
const
CPURegList
&
list_2
const
CPURegList
&
list_3
const
CPURegList
&
list_4
)
;
bool
Overlaps
(
const
CPURegList
&
other
)
const
{
return
(
type_
=
=
other
.
type_
)
&
&
(
(
list_
&
other
.
list_
)
!
=
0
)
;
}
RegList
GetList
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
list_
;
}
RegList
list
(
)
const
{
return
GetList
(
)
;
}
void
SetList
(
RegList
new_list
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
list_
=
new_list
;
}
void
set_list
(
RegList
new_list
)
{
return
SetList
(
new_list
)
;
}
void
RemoveCalleeSaved
(
)
;
CPURegister
PopLowestIndex
(
RegList
mask
=
~
static_cast
<
RegList
>
(
0
)
)
;
CPURegister
PopHighestIndex
(
RegList
mask
=
~
static_cast
<
RegList
>
(
0
)
)
;
static
CPURegList
GetCalleeSaved
(
unsigned
size
=
kXRegSize
)
;
static
CPURegList
GetCalleeSavedV
(
unsigned
size
=
kDRegSize
)
;
static
CPURegList
GetCallerSaved
(
unsigned
size
=
kXRegSize
)
;
static
CPURegList
GetCallerSavedV
(
unsigned
size
=
kDRegSize
)
;
bool
IsEmpty
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
list_
=
=
0
;
}
bool
IncludesAliasOf
(
const
CPURegister
&
other
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
(
GetBank
(
)
=
=
other
.
GetBank
(
)
)
&
&
IncludesAliasOf
(
other
.
GetCode
(
)
)
;
}
bool
IncludesAliasOf
(
int
code
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
(
(
(
static_cast
<
RegList
>
(
1
)
<
<
code
)
&
list_
)
!
=
0
)
;
}
int
GetCount
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
CountSetBits
(
list_
)
;
}
int
Count
(
)
const
{
return
GetCount
(
)
;
}
int
GetRegisterSizeInBits
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
size_
;
}
int
RegisterSizeInBits
(
)
const
{
return
GetRegisterSizeInBits
(
)
;
}
int
GetRegisterSizeInBytes
(
)
const
{
int
size_in_bits
=
GetRegisterSizeInBits
(
)
;
VIXL_ASSERT
(
(
size_in_bits
%
8
)
=
=
0
)
;
return
size_in_bits
/
8
;
}
int
RegisterSizeInBytes
(
)
const
{
return
GetRegisterSizeInBytes
(
)
;
}
unsigned
GetTotalSizeInBytes
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
GetRegisterSizeInBytes
(
)
*
GetCount
(
)
;
}
unsigned
TotalSizeInBytes
(
)
const
{
return
GetTotalSizeInBytes
(
)
;
}
private
:
static
unsigned
GetDefaultSizeFor
(
CPURegister
:
:
RegisterType
type
unsigned
size
)
{
if
(
size
=
=
CPURegister
:
:
kUnknownSize
)
{
if
(
type
=
=
CPURegister
:
:
kRegister
)
size
=
kXRegSize
;
if
(
type
=
=
CPURegister
:
:
kVRegister
)
size
=
kQRegSize
;
}
VIXL_ASSERT
(
CPURegister
(
0
size
type
)
.
IsValid
(
)
)
;
return
size
;
}
RegList
list_
;
int
size_
;
CPURegister
:
:
RegisterType
type_
;
bool
IsValid
(
)
const
;
}
;
extern
const
CPURegList
kCalleeSaved
;
extern
const
CPURegList
kCalleeSavedV
;
extern
const
CPURegList
kCallerSaved
;
extern
const
CPURegList
kCallerSavedV
;
class
IntegerOperand
;
class
Operand
{
public
:
Operand
(
int64_t
immediate
)
;
Operand
(
IntegerOperand
immediate
)
;
Operand
(
Register
reg
Shift
shift
=
LSL
unsigned
shift_amount
=
0
)
;
explicit
Operand
(
Register
reg
Extend
extend
unsigned
shift_amount
=
0
)
;
bool
IsImmediate
(
)
const
;
bool
IsPlainRegister
(
)
const
;
bool
IsShiftedRegister
(
)
const
;
bool
IsExtendedRegister
(
)
const
;
bool
IsZero
(
)
const
;
Operand
ToExtendedRegister
(
)
const
;
int64_t
GetImmediate
(
)
const
{
VIXL_ASSERT
(
IsImmediate
(
)
)
;
return
immediate_
;
}
int64_t
immediate
(
)
const
{
return
GetImmediate
(
)
;
}
int64_t
GetEquivalentImmediate
(
)
const
{
return
IsZero
(
)
?
0
:
GetImmediate
(
)
;
}
Register
GetRegister
(
)
const
{
VIXL_ASSERT
(
IsShiftedRegister
(
)
|
|
IsExtendedRegister
(
)
)
;
return
reg_
;
}
Register
reg
(
)
const
{
return
GetRegister
(
)
;
}
Register
GetBaseRegister
(
)
const
{
return
GetRegister
(
)
;
}
CPURegister
maybeReg
(
)
const
{
if
(
IsShiftedRegister
(
)
|
|
IsExtendedRegister
(
)
)
return
reg_
;
return
NoCPUReg
;
}
Shift
GetShift
(
)
const
{
VIXL_ASSERT
(
IsShiftedRegister
(
)
)
;
return
shift_
;
}
Shift
shift
(
)
const
{
return
GetShift
(
)
;
}
Extend
GetExtend
(
)
const
{
VIXL_ASSERT
(
IsExtendedRegister
(
)
)
;
return
extend_
;
}
Extend
extend
(
)
const
{
return
GetExtend
(
)
;
}
unsigned
GetShiftAmount
(
)
const
{
VIXL_ASSERT
(
IsShiftedRegister
(
)
|
|
IsExtendedRegister
(
)
)
;
return
shift_amount_
;
}
unsigned
shift_amount
(
)
const
{
return
GetShiftAmount
(
)
;
}
private
:
int64_t
immediate_
;
Register
reg_
;
Shift
shift_
;
Extend
extend_
;
unsigned
shift_amount_
;
}
;
class
MemOperand
{
public
:
MemOperand
(
)
;
explicit
MemOperand
(
Register
base
int64_t
offset
=
0
AddrMode
addrmode
=
Offset
)
;
MemOperand
(
Register
base
Register
regoffset
Shift
shift
=
LSL
unsigned
shift_amount
=
0
)
;
MemOperand
(
Register
base
Register
regoffset
Extend
extend
unsigned
shift_amount
=
0
)
;
MemOperand
(
Register
base
const
Operand
&
offset
AddrMode
addrmode
=
Offset
)
;
explicit
MemOperand
(
js
:
:
jit
:
:
Address
addr
)
:
MemOperand
(
IsHiddenSP
(
addr
.
base
)
?
sp
:
Register
(
AsRegister
(
addr
.
base
)
64
)
(
ptrdiff_t
)
addr
.
offset
)
{
}
const
Register
&
GetBaseRegister
(
)
const
{
return
base_
;
}
const
Register
&
base
(
)
const
{
return
base_
;
}
const
Register
&
GetRegisterOffset
(
)
const
{
return
regoffset_
;
}
const
Register
&
regoffset
(
)
const
{
return
regoffset_
;
}
int64_t
GetOffset
(
)
const
{
return
offset_
;
}
int64_t
offset
(
)
const
{
return
offset_
;
}
AddrMode
GetAddrMode
(
)
const
{
return
addrmode_
;
}
AddrMode
addrmode
(
)
const
{
return
addrmode_
;
}
Shift
GetShift
(
)
const
{
return
shift_
;
}
Shift
shift
(
)
const
{
return
shift_
;
}
Extend
GetExtend
(
)
const
{
return
extend_
;
}
Extend
extend
(
)
const
{
return
extend_
;
}
unsigned
GetShiftAmount
(
)
const
{
VIXL_ASSERT
(
(
GetShift
(
)
!
=
NO_SHIFT
)
|
|
(
GetExtend
(
)
!
=
NO_EXTEND
)
)
;
return
shift_amount_
;
}
unsigned
shift_amount
(
)
const
{
return
shift_amount_
;
}
bool
IsPlainRegister
(
)
const
;
bool
IsEquivalentToPlainRegister
(
)
const
;
bool
IsImmediateOffset
(
)
const
;
bool
IsRegisterOffset
(
)
const
;
bool
IsPreIndex
(
)
const
;
bool
IsPostIndex
(
)
const
;
bool
IsImmediatePreIndex
(
)
const
;
bool
IsImmediatePostIndex
(
)
const
;
void
AddOffset
(
int64_t
offset
)
;
bool
IsValid
(
)
const
{
return
base_
.
IsValid
(
)
&
&
(
(
addrmode_
=
=
Offset
)
|
|
(
addrmode_
=
=
PreIndex
)
|
|
(
addrmode_
=
=
PostIndex
)
)
&
&
(
(
shift_
=
=
NO_SHIFT
)
|
|
(
extend_
=
=
NO_EXTEND
)
)
&
&
(
(
offset_
=
=
0
)
|
|
!
regoffset_
.
IsValid
(
)
)
;
}
bool
Equals
(
const
MemOperand
&
other
)
const
{
return
base_
.
Is
(
other
.
base_
)
&
&
regoffset_
.
Is
(
other
.
regoffset_
)
&
&
(
offset_
=
=
other
.
offset_
)
&
&
(
addrmode_
=
=
other
.
addrmode_
)
&
&
(
shift_
=
=
other
.
shift_
)
&
&
(
extend_
=
=
other
.
extend_
)
&
&
(
shift_amount_
=
=
other
.
shift_amount_
)
;
}
private
:
Register
base_
;
Register
regoffset_
;
int64_t
offset_
;
AddrMode
addrmode_
;
Shift
shift_
;
Extend
extend_
;
unsigned
shift_amount_
;
}
;
class
SVEMemOperand
{
public
:
explicit
SVEMemOperand
(
ZRegister
base
uint64_t
offset
=
0
)
:
base_
(
base
)
regoffset_
(
NoReg
)
offset_
(
RawbitsToInt64
(
offset
)
)
mod_
(
NO_SVE_OFFSET_MODIFIER
)
shift_amount_
(
0
)
{
VIXL_ASSERT
(
IsVectorPlusImmediate
(
)
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
explicit
SVEMemOperand
(
Register
base
uint64_t
offset
=
0
SVEOffsetModifier
mod
=
NO_SVE_OFFSET_MODIFIER
)
:
base_
(
base
)
regoffset_
(
NoReg
)
offset_
(
RawbitsToInt64
(
offset
)
)
mod_
(
mod
)
shift_amount_
(
0
)
{
VIXL_ASSERT
(
IsScalarPlusImmediate
(
)
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
SVEMemOperand
(
Register
base
CPURegister
offset
)
:
base_
(
base
)
regoffset_
(
offset
)
offset_
(
0
)
mod_
(
NO_SVE_OFFSET_MODIFIER
)
shift_amount_
(
0
)
{
VIXL_ASSERT
(
IsScalarPlusScalar
(
)
|
|
IsScalarPlusVector
(
)
)
;
if
(
offset
.
IsZero
(
)
)
VIXL_ASSERT
(
IsEquivalentToScalar
(
)
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
template
<
typename
M
>
SVEMemOperand
(
Register
base
ZRegister
offset
M
mod
)
:
base_
(
base
)
regoffset_
(
offset
)
offset_
(
0
)
mod_
(
GetSVEOffsetModifierFor
(
mod
)
)
shift_amount_
(
0
)
{
VIXL_ASSERT
(
mod_
!
=
SVE_LSL
)
;
VIXL_ASSERT
(
IsScalarPlusVector
(
)
)
;
VIXL_ASSERT
(
IsValid
(
)
)
;
}
template
<
typename
M
>
SVEMemOperand
(
Register
base
CPURegister
offset
M
mod
unsigned
shift_amount
)
:
base_
(
base
)
regoffset_
(
offset
)
offset_
(
0
)
mod_
(
GetSVEOffsetModifierFor
(
mod
)
)
shift_amount_
(
shift_amount
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
}
SVEMemOperand
(
ZRegister
base
Register
offset
)
:
base_
(
base
)
regoffset_
(
offset
)
offset_
(
0
)
mod_
(
NO_SVE_OFFSET_MODIFIER
)
shift_amount_
(
0
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
IsVectorPlusScalar
(
)
)
;
}
template
<
typename
M
=
SVEOffsetModifier
>
SVEMemOperand
(
ZRegister
base
ZRegister
offset
M
mod
=
NO_SVE_OFFSET_MODIFIER
unsigned
shift_amount
=
0
)
:
base_
(
base
)
regoffset_
(
offset
)
offset_
(
0
)
mod_
(
GetSVEOffsetModifierFor
(
mod
)
)
shift_amount_
(
shift_amount
)
{
VIXL_ASSERT
(
IsValid
(
)
)
;
VIXL_ASSERT
(
IsVectorPlusVector
(
)
)
;
}
bool
IsPlainScalar
(
)
const
{
return
IsScalarPlusImmediate
(
)
&
&
(
offset_
=
=
0
)
;
}
bool
IsEquivalentToScalar
(
)
const
;
bool
IsPlainRegister
(
)
const
;
bool
IsScalarPlusImmediate
(
)
const
{
return
base_
.
IsX
(
)
&
&
regoffset_
.
IsNone
(
)
&
&
(
(
mod_
=
=
NO_SVE_OFFSET_MODIFIER
)
|
|
IsMulVl
(
)
)
;
}
bool
IsScalarPlusScalar
(
)
const
{
return
base_
.
IsX
(
)
&
&
regoffset_
.
IsX
(
)
&
&
(
(
mod_
=
=
NO_SVE_OFFSET_MODIFIER
)
|
|
(
mod_
=
=
SVE_LSL
)
)
;
}
bool
IsScalarPlusVector
(
)
const
{
return
base_
.
IsX
(
)
&
&
regoffset_
.
IsZRegister
(
)
&
&
(
regoffset_
.
IsLaneSizeS
(
)
|
|
regoffset_
.
IsLaneSizeD
(
)
)
&
&
!
IsMulVl
(
)
;
}
bool
IsVectorPlusImmediate
(
)
const
{
return
base_
.
IsZRegister
(
)
&
&
(
base_
.
IsLaneSizeS
(
)
|
|
base_
.
IsLaneSizeD
(
)
)
&
&
regoffset_
.
IsNone
(
)
&
&
(
mod_
=
=
NO_SVE_OFFSET_MODIFIER
)
;
}
bool
IsVectorPlusScalar
(
)
const
{
return
base_
.
IsZRegister
(
)
&
&
regoffset_
.
IsX
(
)
&
&
(
base_
.
IsLaneSizeS
(
)
|
|
base_
.
IsLaneSizeD
(
)
)
;
}
bool
IsVectorPlusVector
(
)
const
{
return
base_
.
IsZRegister
(
)
&
&
regoffset_
.
IsZRegister
(
)
&
&
(
offset_
=
=
0
)
&
&
AreSameFormat
(
base_
regoffset_
)
&
&
(
base_
.
IsLaneSizeS
(
)
|
|
base_
.
IsLaneSizeD
(
)
)
;
}
bool
IsContiguous
(
)
const
{
return
!
IsScatterGather
(
)
;
}
bool
IsScatterGather
(
)
const
{
return
base_
.
IsZRegister
(
)
|
|
regoffset_
.
IsZRegister
(
)
;
}
Register
GetScalarBase
(
)
const
{
VIXL_ASSERT
(
base_
.
IsX
(
)
)
;
return
Register
(
base_
)
;
}
ZRegister
GetVectorBase
(
)
const
{
VIXL_ASSERT
(
base_
.
IsZRegister
(
)
)
;
VIXL_ASSERT
(
base_
.
HasLaneSize
(
)
)
;
return
ZRegister
(
base_
)
;
}
Register
GetScalarOffset
(
)
const
{
VIXL_ASSERT
(
regoffset_
.
IsRegister
(
)
)
;
return
Register
(
regoffset_
)
;
}
ZRegister
GetVectorOffset
(
)
const
{
VIXL_ASSERT
(
regoffset_
.
IsZRegister
(
)
)
;
VIXL_ASSERT
(
regoffset_
.
HasLaneSize
(
)
)
;
return
ZRegister
(
regoffset_
)
;
}
int64_t
GetImmediateOffset
(
)
const
{
VIXL_ASSERT
(
regoffset_
.
IsNone
(
)
)
;
return
offset_
;
}
SVEOffsetModifier
GetOffsetModifier
(
)
const
{
return
mod_
;
}
unsigned
GetShiftAmount
(
)
const
{
return
shift_amount_
;
}
bool
IsEquivalentToLSL
(
unsigned
amount
)
const
{
if
(
shift_amount_
!
=
amount
)
return
false
;
if
(
amount
=
=
0
)
{
return
(
(
mod_
=
=
SVE_LSL
)
|
|
(
mod_
=
=
NO_SVE_OFFSET_MODIFIER
)
)
;
}
return
mod_
=
=
SVE_LSL
;
}
bool
IsMulVl
(
)
const
{
return
mod_
=
=
SVE_MUL_VL
;
}
bool
IsValid
(
)
const
;
private
:
SVEOffsetModifier
GetSVEOffsetModifierFor
(
Shift
shift
)
{
if
(
shift
=
=
LSL
)
return
SVE_LSL
;
if
(
shift
=
=
NO_SHIFT
)
return
NO_SVE_OFFSET_MODIFIER
;
VIXL_UNIMPLEMENTED
(
)
;
return
NO_SVE_OFFSET_MODIFIER
;
}
SVEOffsetModifier
GetSVEOffsetModifierFor
(
Extend
extend
=
NO_EXTEND
)
{
if
(
extend
=
=
UXTW
)
return
SVE_UXTW
;
if
(
extend
=
=
SXTW
)
return
SVE_SXTW
;
if
(
extend
=
=
NO_EXTEND
)
return
NO_SVE_OFFSET_MODIFIER
;
VIXL_UNIMPLEMENTED
(
)
;
return
NO_SVE_OFFSET_MODIFIER
;
}
SVEOffsetModifier
GetSVEOffsetModifierFor
(
SVEOffsetModifier
mod
)
{
return
mod
;
}
CPURegister
base_
;
CPURegister
regoffset_
;
int64_t
offset_
;
SVEOffsetModifier
mod_
;
unsigned
shift_amount_
;
}
;
class
IntegerOperand
{
public
:
#
define
VIXL_INT_TYPES
(
V
)
\
V
(
char
)
V
(
short
)
V
(
int
)
V
(
long
)
V
(
long
long
)
/
/
NOLINT
(
google
-
runtime
-
int
)
#
define
VIXL_DECL_INT_OVERLOADS
(
T
)
\
IntegerOperand
(
signed
T
immediate
)
/
*
NOLINT
(
runtime
/
explicit
)
*
/
\
:
raw_bits_
(
immediate
)
/
*
Allow
implicit
sign
-
extension
.
*
/
\
is_negative_
(
immediate
<
0
)
{
}
\
IntegerOperand
(
unsigned
T
immediate
)
/
*
NOLINT
(
runtime
/
explicit
)
*
/
\
:
raw_bits_
(
immediate
)
is_negative_
(
false
)
{
}
VIXL_INT_TYPES
(
VIXL_DECL_INT_OVERLOADS
)
#
undef
VIXL_DECL_INT_OVERLOADS
#
undef
VIXL_INT_TYPES
explicit
IntegerOperand
(
const
Operand
&
operand
)
:
raw_bits_
(
operand
.
GetEquivalentImmediate
(
)
)
is_negative_
(
operand
.
GetEquivalentImmediate
(
)
<
0
)
{
}
bool
IsIntN
(
unsigned
n
)
const
{
return
is_negative_
?
vixl
:
:
IsIntN
(
n
RawbitsToInt64
(
raw_bits_
)
)
:
vixl
:
:
IsIntN
(
n
raw_bits_
)
;
}
bool
IsUintN
(
unsigned
n
)
const
{
return
!
is_negative_
&
&
vixl
:
:
IsUintN
(
n
raw_bits_
)
;
}
bool
IsUint8
(
)
const
{
return
IsUintN
(
8
)
;
}
bool
IsUint16
(
)
const
{
return
IsUintN
(
16
)
;
}
bool
IsUint32
(
)
const
{
return
IsUintN
(
32
)
;
}
bool
IsUint64
(
)
const
{
return
IsUintN
(
64
)
;
}
bool
IsInt8
(
)
const
{
return
IsIntN
(
8
)
;
}
bool
IsInt16
(
)
const
{
return
IsIntN
(
16
)
;
}
bool
IsInt32
(
)
const
{
return
IsIntN
(
32
)
;
}
bool
IsInt64
(
)
const
{
return
IsIntN
(
64
)
;
}
bool
FitsInBits
(
unsigned
n
)
const
{
return
is_negative_
?
IsIntN
(
n
)
:
IsUintN
(
n
)
;
}
bool
FitsInLane
(
const
CPURegister
&
zd
)
const
{
return
FitsInBits
(
zd
.
GetLaneSizeInBits
(
)
)
;
}
bool
FitsInSignedLane
(
const
CPURegister
&
zd
)
const
{
return
IsIntN
(
zd
.
GetLaneSizeInBits
(
)
)
;
}
bool
FitsInUnsignedLane
(
const
CPURegister
&
zd
)
const
{
return
IsUintN
(
zd
.
GetLaneSizeInBits
(
)
)
;
}
uint64_t
AsUintN
(
unsigned
n
)
const
{
VIXL_ASSERT
(
FitsInBits
(
n
)
)
;
return
raw_bits_
&
GetUintMask
(
n
)
;
}
uint8_t
AsUint8
(
)
const
{
return
static_cast
<
uint8_t
>
(
AsUintN
(
8
)
)
;
}
uint16_t
AsUint16
(
)
const
{
return
static_cast
<
uint16_t
>
(
AsUintN
(
16
)
)
;
}
uint32_t
AsUint32
(
)
const
{
return
static_cast
<
uint32_t
>
(
AsUintN
(
32
)
)
;
}
uint64_t
AsUint64
(
)
const
{
return
AsUintN
(
64
)
;
}
int64_t
AsIntN
(
unsigned
n
)
const
{
VIXL_ASSERT
(
FitsInBits
(
n
)
)
;
return
ExtractSignedBitfield64
(
n
-
1
0
raw_bits_
)
;
}
int8_t
AsInt8
(
)
const
{
return
static_cast
<
int8_t
>
(
AsIntN
(
8
)
)
;
}
int16_t
AsInt16
(
)
const
{
return
static_cast
<
int16_t
>
(
AsIntN
(
16
)
)
;
}
int32_t
AsInt32
(
)
const
{
return
static_cast
<
int32_t
>
(
AsIntN
(
32
)
)
;
}
int64_t
AsInt64
(
)
const
{
return
AsIntN
(
64
)
;
}
template
<
unsigned
N
unsigned
kShift
typename
T
>
bool
TryEncodeAsShiftedIntNForLane
(
const
CPURegister
&
zd
T
*
imm
)
const
{
VIXL_STATIC_ASSERT
(
std
:
:
numeric_limits
<
T
>
:
:
digits
>
N
)
;
VIXL_ASSERT
(
FitsInLane
(
zd
)
)
;
if
(
(
raw_bits_
&
GetUintMask
(
kShift
)
)
!
=
0
)
return
false
;
IntegerOperand
unshifted
(
*
this
)
;
unshifted
.
ArithmeticShiftRight
(
kShift
)
;
if
(
unshifted
.
IsIntN
(
N
)
)
{
*
imm
=
static_cast
<
T
>
(
unshifted
.
AsIntN
(
N
)
)
;
return
true
;
}
if
(
unshifted
.
IsUintN
(
zd
.
GetLaneSizeInBits
(
)
-
kShift
)
)
{
int64_t
encoded
=
unshifted
.
AsIntN
(
zd
.
GetLaneSizeInBits
(
)
-
kShift
)
;
if
(
vixl
:
:
IsIntN
(
N
encoded
)
)
{
*
imm
=
static_cast
<
T
>
(
encoded
)
;
return
true
;
}
}
return
false
;
}
template
<
unsigned
N
unsigned
kShift
typename
T
typename
S
>
bool
TryEncodeAsShiftedIntNForLane
(
const
CPURegister
&
zd
T
*
imm
S
*
shift
)
const
{
if
(
TryEncodeAsShiftedIntNForLane
<
N
kShift
>
(
zd
imm
)
)
{
*
shift
=
kShift
;
return
true
;
}
return
false
;
}
template
<
unsigned
N
typename
T
>
bool
TryEncodeAsIntNForLane
(
const
CPURegister
&
zd
T
*
imm
)
const
{
return
TryEncodeAsShiftedIntNForLane
<
N
0
>
(
zd
imm
)
;
}
template
<
unsigned
N
unsigned
kShift
typename
T
>
bool
TryEncodeAsShiftedUintNForLane
(
const
CPURegister
&
zd
T
*
imm
)
const
{
VIXL_STATIC_ASSERT
(
std
:
:
numeric_limits
<
T
>
:
:
digits
>
N
)
;
VIXL_ASSERT
(
FitsInLane
(
zd
)
)
;
if
(
is_negative_
)
return
false
;
USE
(
zd
)
;
if
(
(
raw_bits_
&
GetUintMask
(
kShift
)
)
!
=
0
)
return
false
;
if
(
vixl
:
:
IsUintN
(
N
raw_bits_
>
>
kShift
)
)
{
*
imm
=
static_cast
<
T
>
(
raw_bits_
>
>
kShift
)
;
return
true
;
}
return
false
;
}
template
<
unsigned
N
unsigned
kShift
typename
T
typename
S
>
bool
TryEncodeAsShiftedUintNForLane
(
const
CPURegister
&
zd
T
*
imm
S
*
shift
)
const
{
if
(
TryEncodeAsShiftedUintNForLane
<
N
kShift
>
(
zd
imm
)
)
{
*
shift
=
kShift
;
return
true
;
}
return
false
;
}
bool
IsZero
(
)
const
{
return
raw_bits_
=
=
0
;
}
bool
IsNegative
(
)
const
{
return
is_negative_
;
}
bool
IsPositiveOrZero
(
)
const
{
return
!
is_negative_
;
}
uint64_t
GetMagnitude
(
)
const
{
return
is_negative_
?
UnsignedNegate
(
raw_bits_
)
:
raw_bits_
;
}
private
:
void
ArithmeticShiftRight
(
int
shift
)
{
VIXL_ASSERT
(
(
shift
>
=
0
)
&
&
(
shift
<
64
)
)
;
if
(
shift
=
=
0
)
return
;
if
(
is_negative_
)
{
raw_bits_
=
ExtractSignedBitfield64
(
63
shift
raw_bits_
)
;
}
else
{
raw_bits_
>
>
=
shift
;
}
}
uint64_t
raw_bits_
;
bool
is_negative_
;
}
;
class
GenericOperand
{
public
:
GenericOperand
(
)
{
VIXL_ASSERT
(
!
IsValid
(
)
)
;
}
GenericOperand
(
const
CPURegister
&
reg
)
;
GenericOperand
(
const
MemOperand
&
mem_op
size_t
mem_op_size
=
0
)
;
bool
IsValid
(
)
const
{
return
cpu_register_
.
IsValid
(
)
!
=
mem_op_
.
IsValid
(
)
;
}
bool
Equals
(
const
GenericOperand
&
other
)
const
;
bool
IsCPURegister
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
cpu_register_
.
IsValid
(
)
;
}
bool
IsRegister
(
)
const
{
return
IsCPURegister
(
)
&
&
cpu_register_
.
IsRegister
(
)
;
}
bool
IsVRegister
(
)
const
{
return
IsCPURegister
(
)
&
&
cpu_register_
.
IsVRegister
(
)
;
}
bool
IsSameCPURegisterType
(
const
GenericOperand
&
other
)
{
return
IsCPURegister
(
)
&
&
other
.
IsCPURegister
(
)
&
&
GetCPURegister
(
)
.
IsSameType
(
other
.
GetCPURegister
(
)
)
;
}
bool
IsMemOperand
(
)
const
{
VIXL_ASSERT
(
IsValid
(
)
)
;
return
mem_op_
.
IsValid
(
)
;
}
CPURegister
GetCPURegister
(
)
const
{
VIXL_ASSERT
(
IsCPURegister
(
)
)
;
return
cpu_register_
;
}
MemOperand
GetMemOperand
(
)
const
{
VIXL_ASSERT
(
IsMemOperand
(
)
)
;
return
mem_op_
;
}
size_t
GetMemOperandSizeInBytes
(
)
const
{
VIXL_ASSERT
(
IsMemOperand
(
)
)
;
return
mem_op_size_
;
}
size_t
GetSizeInBytes
(
)
const
{
return
IsCPURegister
(
)
?
cpu_register_
.
GetSizeInBytes
(
)
:
GetMemOperandSizeInBytes
(
)
;
}
size_t
GetSizeInBits
(
)
const
{
return
GetSizeInBytes
(
)
*
kBitsPerByte
;
}
private
:
CPURegister
cpu_register_
;
MemOperand
mem_op_
;
size_t
mem_op_size_
;
}
;
}
#
endif
