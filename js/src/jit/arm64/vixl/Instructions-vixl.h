#
ifndef
VIXL_A64_INSTRUCTIONS_A64_H_
#
define
VIXL_A64_INSTRUCTIONS_A64_H_
#
include
"
jit
/
arm64
/
vixl
/
Constants
-
vixl
.
h
"
#
include
"
jit
/
arm64
/
vixl
/
Globals
-
vixl
.
h
"
#
include
"
jit
/
arm64
/
vixl
/
Utils
-
vixl
.
h
"
namespace
vixl
{
typedef
uint32_t
Instr
;
const
unsigned
kInstructionSize
=
4
;
const
unsigned
kInstructionSizeLog2
=
2
;
const
unsigned
kLiteralEntrySize
=
4
;
const
unsigned
kLiteralEntrySizeLog2
=
2
;
const
unsigned
kMaxLoadLiteralRange
=
1
*
MBytes
;
const
unsigned
kPageSize
=
4
*
KBytes
;
const
unsigned
kPageSizeLog2
=
12
;
const
unsigned
kBRegSize
=
8
;
const
unsigned
kBRegSizeLog2
=
3
;
const
unsigned
kBRegSizeInBytes
=
kBRegSize
/
8
;
const
unsigned
kBRegSizeInBytesLog2
=
kBRegSizeLog2
-
3
;
const
unsigned
kHRegSize
=
16
;
const
unsigned
kHRegSizeLog2
=
4
;
const
unsigned
kHRegSizeInBytes
=
kHRegSize
/
8
;
const
unsigned
kHRegSizeInBytesLog2
=
kHRegSizeLog2
-
3
;
const
unsigned
kWRegSize
=
32
;
const
unsigned
kWRegSizeLog2
=
5
;
const
unsigned
kWRegSizeInBytes
=
kWRegSize
/
8
;
const
unsigned
kWRegSizeInBytesLog2
=
kWRegSizeLog2
-
3
;
const
unsigned
kXRegSize
=
64
;
const
unsigned
kXRegSizeLog2
=
6
;
const
unsigned
kXRegSizeInBytes
=
kXRegSize
/
8
;
const
unsigned
kXRegSizeInBytesLog2
=
kXRegSizeLog2
-
3
;
const
unsigned
kSRegSize
=
32
;
const
unsigned
kSRegSizeLog2
=
5
;
const
unsigned
kSRegSizeInBytes
=
kSRegSize
/
8
;
const
unsigned
kSRegSizeInBytesLog2
=
kSRegSizeLog2
-
3
;
const
unsigned
kDRegSize
=
64
;
const
unsigned
kDRegSizeLog2
=
6
;
const
unsigned
kDRegSizeInBytes
=
kDRegSize
/
8
;
const
unsigned
kDRegSizeInBytesLog2
=
kDRegSizeLog2
-
3
;
const
unsigned
kQRegSize
=
128
;
const
unsigned
kQRegSizeLog2
=
7
;
const
unsigned
kQRegSizeInBytes
=
kQRegSize
/
8
;
const
unsigned
kQRegSizeInBytesLog2
=
kQRegSizeLog2
-
3
;
const
uint64_t
kWRegMask
=
UINT64_C
(
0xffffffff
)
;
const
uint64_t
kXRegMask
=
UINT64_C
(
0xffffffffffffffff
)
;
const
uint64_t
kSRegMask
=
UINT64_C
(
0xffffffff
)
;
const
uint64_t
kDRegMask
=
UINT64_C
(
0xffffffffffffffff
)
;
const
uint64_t
kSSignMask
=
UINT64_C
(
0x80000000
)
;
const
uint64_t
kDSignMask
=
UINT64_C
(
0x8000000000000000
)
;
const
uint64_t
kWSignMask
=
UINT64_C
(
0x80000000
)
;
const
uint64_t
kXSignMask
=
UINT64_C
(
0x8000000000000000
)
;
const
uint64_t
kByteMask
=
UINT64_C
(
0xff
)
;
const
uint64_t
kHalfWordMask
=
UINT64_C
(
0xffff
)
;
const
uint64_t
kWordMask
=
UINT64_C
(
0xffffffff
)
;
const
uint64_t
kXMaxUInt
=
UINT64_C
(
0xffffffffffffffff
)
;
const
uint64_t
kWMaxUInt
=
UINT64_C
(
0xffffffff
)
;
const
int64_t
kXMaxInt
=
INT64_C
(
0x7fffffffffffffff
)
;
const
int64_t
kXMinInt
=
INT64_C
(
0x8000000000000000
)
;
const
int32_t
kWMaxInt
=
INT32_C
(
0x7fffffff
)
;
const
int32_t
kWMinInt
=
INT32_C
(
0x80000000
)
;
const
unsigned
kLinkRegCode
=
30
;
const
unsigned
kZeroRegCode
=
31
;
const
unsigned
kSPRegInternalCode
=
63
;
const
unsigned
kRegCodeMask
=
0x1f
;
const
unsigned
kAddressTagOffset
=
56
;
const
unsigned
kAddressTagWidth
=
8
;
const
uint64_t
kAddressTagMask
=
(
(
UINT64_C
(
1
)
<
<
kAddressTagWidth
)
-
1
)
<
<
kAddressTagOffset
;
VIXL_STATIC_ASSERT
(
kAddressTagMask
=
=
UINT64_C
(
0xff00000000000000
)
)
;
unsigned
CalcLSDataSize
(
LoadStoreOp
op
)
;
unsigned
CalcLSPairDataSize
(
LoadStorePairOp
op
)
;
enum
ImmBranchType
{
UnknownBranchType
=
0
CondBranchType
=
1
UncondBranchType
=
2
CompareBranchType
=
3
TestBranchType
=
4
}
;
enum
ImmBranchRangeType
{
TestBranchRangeType
CondBranchRangeType
UncondBranchRangeType
UnknownBranchRangeType
NumShortBranchRangeTypes
=
UncondBranchRangeType
}
;
enum
AddrMode
{
Offset
PreIndex
PostIndex
}
;
enum
Reg31Mode
{
Reg31IsStackPointer
Reg31IsZeroRegister
}
;
class
Instruction
{
public
:
Instr
InstructionBits
(
)
const
{
return
*
(
reinterpret_cast
<
const
Instr
*
>
(
this
)
)
;
}
void
SetInstructionBits
(
Instr
new_instr
)
{
*
(
reinterpret_cast
<
Instr
*
>
(
this
)
)
=
new_instr
;
}
int
Bit
(
int
pos
)
const
{
return
(
InstructionBits
(
)
>
>
pos
)
&
1
;
}
uint32_t
Bits
(
int
msb
int
lsb
)
const
{
return
ExtractUnsignedBitfield32
(
msb
lsb
InstructionBits
(
)
)
;
}
int32_t
SignedBits
(
int
msb
int
lsb
)
const
{
int32_t
bits
=
*
(
reinterpret_cast
<
const
int32_t
*
>
(
this
)
)
;
return
ExtractSignedBitfield32
(
msb
lsb
bits
)
;
}
Instr
Mask
(
uint32_t
mask
)
const
{
return
InstructionBits
(
)
&
mask
;
}
#
define
DEFINE_GETTER
(
Name
HighBit
LowBit
Func
)
\
int32_t
Name
(
)
const
{
return
Func
(
HighBit
LowBit
)
;
}
INSTRUCTION_FIELDS_LIST
(
DEFINE_GETTER
)
#
undef
DEFINE_GETTER
#
define
DEFINE_SETTER
(
Name
HighBit
LowBit
Func
)
\
inline
void
Set
#
#
Name
(
unsigned
n
)
{
SetBits32
(
HighBit
LowBit
n
)
;
}
INSTRUCTION_FIELDS_LIST
(
DEFINE_SETTER
)
#
undef
DEFINE_SETTER
int
ImmPCRel
(
)
const
{
int
offset
=
static_cast
<
int
>
(
(
ImmPCRelHi
(
)
<
<
ImmPCRelLo_width
)
|
ImmPCRelLo
(
)
)
;
int
width
=
ImmPCRelLo_width
+
ImmPCRelHi_width
;
return
ExtractSignedBitfield32
(
width
-
1
0
offset
)
;
}
uint64_t
ImmLogical
(
)
const
;
unsigned
ImmNEONabcdefgh
(
)
const
;
float
ImmFP32
(
)
const
;
double
ImmFP64
(
)
const
;
float
ImmNEONFP32
(
)
const
;
double
ImmNEONFP64
(
)
const
;
unsigned
SizeLS
(
)
const
{
return
CalcLSDataSize
(
static_cast
<
LoadStoreOp
>
(
Mask
(
LoadStoreMask
)
)
)
;
}
unsigned
SizeLSPair
(
)
const
{
return
CalcLSPairDataSize
(
static_cast
<
LoadStorePairOp
>
(
Mask
(
LoadStorePairMask
)
)
)
;
}
int
NEONLSIndex
(
int
access_size_shift
)
const
{
int64_t
q
=
NEONQ
(
)
;
int64_t
s
=
NEONS
(
)
;
int64_t
size
=
NEONLSSize
(
)
;
int64_t
index
=
(
q
<
<
3
)
|
(
s
<
<
2
)
|
size
;
return
static_cast
<
int
>
(
index
>
>
access_size_shift
)
;
}
bool
IsCondBranchImm
(
)
const
{
return
Mask
(
ConditionalBranchFMask
)
=
=
ConditionalBranchFixed
;
}
bool
IsUncondBranchImm
(
)
const
{
return
Mask
(
UnconditionalBranchFMask
)
=
=
UnconditionalBranchFixed
;
}
bool
IsCompareBranch
(
)
const
{
return
Mask
(
CompareBranchFMask
)
=
=
CompareBranchFixed
;
}
bool
IsTestBranch
(
)
const
{
return
Mask
(
TestBranchFMask
)
=
=
TestBranchFixed
;
}
bool
IsImmBranch
(
)
const
{
return
BranchType
(
)
!
=
UnknownBranchType
;
}
bool
IsPCRelAddressing
(
)
const
{
return
Mask
(
PCRelAddressingFMask
)
=
=
PCRelAddressingFixed
;
}
bool
IsLogicalImmediate
(
)
const
{
return
Mask
(
LogicalImmediateFMask
)
=
=
LogicalImmediateFixed
;
}
bool
IsAddSubImmediate
(
)
const
{
return
Mask
(
AddSubImmediateFMask
)
=
=
AddSubImmediateFixed
;
}
bool
IsAddSubExtended
(
)
const
{
return
Mask
(
AddSubExtendedFMask
)
=
=
AddSubExtendedFixed
;
}
bool
IsLoadOrStore
(
)
const
{
return
Mask
(
LoadStoreAnyFMask
)
=
=
LoadStoreAnyFixed
;
}
bool
IsLoad
(
)
const
;
bool
IsStore
(
)
const
;
bool
IsLoadLiteral
(
)
const
{
return
Mask
(
LoadLiteralFMask
)
=
=
LoadLiteralFixed
;
}
bool
IsMovn
(
)
const
{
return
(
Mask
(
MoveWideImmediateMask
)
=
=
MOVN_x
)
|
|
(
Mask
(
MoveWideImmediateMask
)
=
=
MOVN_w
)
;
}
bool
IsUncondB
(
)
const
;
bool
IsCondB
(
)
const
;
bool
IsBL
(
)
const
;
bool
IsBR
(
)
const
;
bool
IsBLR
(
)
const
;
bool
IsTBZ
(
)
const
;
bool
IsTBNZ
(
)
const
;
bool
IsCBZ
(
)
const
;
bool
IsCBNZ
(
)
const
;
bool
IsLDR
(
)
const
;
bool
IsNOP
(
)
const
;
bool
IsCSDB
(
)
const
;
bool
IsADR
(
)
const
;
bool
IsADRP
(
)
const
;
bool
IsMovz
(
)
const
;
bool
IsMovk
(
)
const
;
bool
IsBranchLinkImm
(
)
const
;
bool
IsTargetReachable
(
const
Instruction
*
target
)
const
;
ptrdiff_t
ImmPCRawOffset
(
)
const
;
void
SetImmPCRawOffset
(
ptrdiff_t
offset
)
;
void
SetBits32
(
int
msb
int
lsb
unsigned
value
)
;
bool
IsStackPtrSync
(
)
const
;
static
int
ImmBranchRangeBitwidth
(
ImmBranchType
branch_type
)
;
static
int32_t
ImmBranchForwardRange
(
ImmBranchType
branch_type
)
;
static
bool
IsValidImmPCOffset
(
ImmBranchType
branch_type
int64_t
offset
)
;
static
ImmBranchRangeType
ImmBranchTypeToRange
(
ImmBranchType
)
;
static
int32_t
ImmBranchMaxForwardOffset
(
ImmBranchRangeType
range_type
)
;
static
int32_t
ImmBranchMinBackwardOffset
(
ImmBranchRangeType
range_type
)
;
Reg31Mode
RdMode
(
)
const
{
if
(
IsAddSubImmediate
(
)
|
|
IsAddSubExtended
(
)
)
{
if
(
Mask
(
AddSubSetFlagsBit
)
)
{
return
Reg31IsZeroRegister
;
}
else
{
return
Reg31IsStackPointer
;
}
}
if
(
IsLogicalImmediate
(
)
)
{
if
(
Mask
(
LogicalImmediateMask
&
LogicalOpMask
)
=
=
ANDS
)
{
return
Reg31IsZeroRegister
;
}
else
{
return
Reg31IsStackPointer
;
}
}
return
Reg31IsZeroRegister
;
}
Reg31Mode
RnMode
(
)
const
{
if
(
IsLoadOrStore
(
)
|
|
IsAddSubImmediate
(
)
|
|
IsAddSubExtended
(
)
)
{
return
Reg31IsStackPointer
;
}
return
Reg31IsZeroRegister
;
}
ImmBranchType
BranchType
(
)
const
{
if
(
IsCondBranchImm
(
)
)
{
return
CondBranchType
;
}
else
if
(
IsUncondBranchImm
(
)
)
{
return
UncondBranchType
;
}
else
if
(
IsCompareBranch
(
)
)
{
return
CompareBranchType
;
}
else
if
(
IsTestBranch
(
)
)
{
return
TestBranchType
;
}
else
{
return
UnknownBranchType
;
}
}
const
Instruction
*
ImmPCOffsetTarget
(
)
const
;
void
SetImmPCOffsetTarget
(
const
Instruction
*
target
)
;
void
SetImmLLiteral
(
const
Instruction
*
source
)
;
static
const
int
kLoadLiteralImmBitwidth
=
19
;
static
const
int
kLoadLiteralRange
=
(
1
<
<
kLoadLiteralImmBitwidth
)
/
2
-
kInstructionSize
;
template
<
typename
T
>
T
LiteralAddress
(
)
const
{
uint64_t
base_raw
=
reinterpret_cast
<
uint64_t
>
(
this
)
;
int64_t
offset
=
ImmLLiteral
(
)
<
<
kLiteralEntrySizeLog2
;
uint64_t
address_raw
=
base_raw
+
offset
;
T
address
=
(
T
)
(
address_raw
)
;
VIXL_ASSERT
(
(
uint64_t
)
(
address
)
=
=
address_raw
)
;
return
address
;
}
uint32_t
Literal32
(
)
const
{
uint32_t
literal
;
memcpy
(
&
literal
LiteralAddress
<
const
void
*
>
(
)
sizeof
(
literal
)
)
;
return
literal
;
}
uint64_t
Literal64
(
)
const
{
uint64_t
literal
;
memcpy
(
&
literal
LiteralAddress
<
const
void
*
>
(
)
sizeof
(
literal
)
)
;
return
literal
;
}
void
SetLiteral64
(
uint64_t
literal
)
const
{
memcpy
(
LiteralAddress
<
void
*
>
(
)
&
literal
sizeof
(
literal
)
)
;
}
float
LiteralFP32
(
)
const
{
return
RawbitsToFloat
(
Literal32
(
)
)
;
}
double
LiteralFP64
(
)
const
{
return
RawbitsToDouble
(
Literal64
(
)
)
;
}
const
Instruction
*
NextInstruction
(
)
const
{
return
this
+
kInstructionSize
;
}
const
Instruction
*
skipPool
(
)
const
;
const
Instruction
*
InstructionAtOffset
(
int64_t
offset
)
const
{
VIXL_ASSERT
(
IsWordAligned
(
this
+
offset
)
)
;
return
this
+
offset
;
}
template
<
typename
T
>
static
Instruction
*
Cast
(
T
src
)
{
return
reinterpret_cast
<
Instruction
*
>
(
src
)
;
}
template
<
typename
T
>
static
const
Instruction
*
CastConst
(
T
src
)
{
return
reinterpret_cast
<
const
Instruction
*
>
(
src
)
;
}
private
:
int
ImmBranch
(
)
const
;
static
float
Imm8ToFP32
(
uint32_t
imm8
)
;
static
double
Imm8ToFP64
(
uint32_t
imm8
)
;
void
SetPCRelImmTarget
(
const
Instruction
*
target
)
;
void
SetBranchImmTarget
(
const
Instruction
*
target
)
;
}
;
enum
VectorFormat
{
kFormatUndefined
=
0xffffffff
kFormat8B
=
NEON_8B
kFormat16B
=
NEON_16B
kFormat4H
=
NEON_4H
kFormat8H
=
NEON_8H
kFormat2S
=
NEON_2S
kFormat4S
=
NEON_4S
kFormat1D
=
NEON_1D
kFormat2D
=
NEON_2D
kFormatB
=
NEON_B
|
NEONScalar
kFormatH
=
NEON_H
|
NEONScalar
kFormatS
=
NEON_S
|
NEONScalar
kFormatD
=
NEON_D
|
NEONScalar
}
;
VectorFormat
VectorFormatHalfWidth
(
const
VectorFormat
vform
)
;
VectorFormat
VectorFormatDoubleWidth
(
const
VectorFormat
vform
)
;
VectorFormat
VectorFormatDoubleLanes
(
const
VectorFormat
vform
)
;
VectorFormat
VectorFormatHalfLanes
(
const
VectorFormat
vform
)
;
VectorFormat
ScalarFormatFromLaneSize
(
int
lanesize
)
;
VectorFormat
VectorFormatHalfWidthDoubleLanes
(
const
VectorFormat
vform
)
;
VectorFormat
VectorFormatFillQ
(
const
VectorFormat
vform
)
;
unsigned
RegisterSizeInBitsFromFormat
(
VectorFormat
vform
)
;
unsigned
RegisterSizeInBytesFromFormat
(
VectorFormat
vform
)
;
unsigned
LaneSizeInBitsFromFormat
(
VectorFormat
vform
)
;
int
LaneSizeInBytesFromFormat
(
VectorFormat
vform
)
;
int
LaneSizeInBytesLog2FromFormat
(
VectorFormat
vform
)
;
int
LaneCountFromFormat
(
VectorFormat
vform
)
;
int
MaxLaneCountFromFormat
(
VectorFormat
vform
)
;
bool
IsVectorFormat
(
VectorFormat
vform
)
;
int64_t
MaxIntFromFormat
(
VectorFormat
vform
)
;
int64_t
MinIntFromFormat
(
VectorFormat
vform
)
;
uint64_t
MaxUintFromFormat
(
VectorFormat
vform
)
;
enum
NEONFormat
{
NF_UNDEF
=
0
NF_8B
=
1
NF_16B
=
2
NF_4H
=
3
NF_8H
=
4
NF_2S
=
5
NF_4S
=
6
NF_1D
=
7
NF_2D
=
8
NF_B
=
9
NF_H
=
10
NF_S
=
11
NF_D
=
12
}
;
static
const
unsigned
kNEONFormatMaxBits
=
6
;
struct
NEONFormatMap
{
uint8_t
bits
[
kNEONFormatMaxBits
]
;
NEONFormat
map
[
1
<
<
kNEONFormatMaxBits
]
;
}
;
class
NEONFormatDecoder
{
public
:
enum
SubstitutionMode
{
kPlaceholder
kFormat
}
;
explicit
NEONFormatDecoder
(
const
Instruction
*
instr
)
{
instrbits_
=
instr
-
>
InstructionBits
(
)
;
SetFormatMaps
(
IntegerFormatMap
(
)
)
;
}
NEONFormatDecoder
(
const
Instruction
*
instr
const
NEONFormatMap
*
format
)
{
instrbits_
=
instr
-
>
InstructionBits
(
)
;
SetFormatMaps
(
format
)
;
}
NEONFormatDecoder
(
const
Instruction
*
instr
const
NEONFormatMap
*
format0
const
NEONFormatMap
*
format1
)
{
instrbits_
=
instr
-
>
InstructionBits
(
)
;
SetFormatMaps
(
format0
format1
)
;
}
NEONFormatDecoder
(
const
Instruction
*
instr
const
NEONFormatMap
*
format0
const
NEONFormatMap
*
format1
const
NEONFormatMap
*
format2
)
{
instrbits_
=
instr
-
>
InstructionBits
(
)
;
SetFormatMaps
(
format0
format1
format2
)
;
}
void
SetFormatMaps
(
const
NEONFormatMap
*
format0
const
NEONFormatMap
*
format1
=
NULL
const
NEONFormatMap
*
format2
=
NULL
)
{
VIXL_ASSERT
(
format0
!
=
NULL
)
;
formats_
[
0
]
=
format0
;
formats_
[
1
]
=
(
format1
=
=
NULL
)
?
formats_
[
0
]
:
format1
;
formats_
[
2
]
=
(
format2
=
=
NULL
)
?
formats_
[
1
]
:
format2
;
}
void
SetFormatMap
(
unsigned
index
const
NEONFormatMap
*
format
)
{
VIXL_ASSERT
(
index
<
=
(
sizeof
(
formats_
)
/
sizeof
(
formats_
[
0
]
)
)
)
;
VIXL_ASSERT
(
format
!
=
NULL
)
;
formats_
[
index
]
=
format
;
}
const
char
*
SubstitutePlaceholders
(
const
char
*
string
)
{
return
Substitute
(
string
kPlaceholder
kPlaceholder
kPlaceholder
)
;
}
const
char
*
Substitute
(
const
char
*
string
SubstitutionMode
mode0
=
kFormat
SubstitutionMode
mode1
=
kFormat
SubstitutionMode
mode2
=
kFormat
)
{
snprintf
(
form_buffer_
sizeof
(
form_buffer_
)
string
GetSubstitute
(
0
mode0
)
GetSubstitute
(
1
mode1
)
GetSubstitute
(
2
mode2
)
)
;
return
form_buffer_
;
}
const
char
*
Mnemonic
(
const
char
*
mnemonic
)
{
if
(
(
instrbits_
&
NEON_Q
)
!
=
0
)
{
snprintf
(
mne_buffer_
sizeof
(
mne_buffer_
)
"
%
s2
"
mnemonic
)
;
return
mne_buffer_
;
}
return
mnemonic
;
}
VectorFormat
GetVectorFormat
(
int
format_index
=
0
)
{
return
GetVectorFormat
(
formats_
[
format_index
]
)
;
}
VectorFormat
GetVectorFormat
(
const
NEONFormatMap
*
format_map
)
{
static
const
VectorFormat
vform
[
]
=
{
kFormatUndefined
kFormat8B
kFormat16B
kFormat4H
kFormat8H
kFormat2S
kFormat4S
kFormat1D
kFormat2D
kFormatB
kFormatH
kFormatS
kFormatD
}
;
VIXL_ASSERT
(
GetNEONFormat
(
format_map
)
<
(
sizeof
(
vform
)
/
sizeof
(
vform
[
0
]
)
)
)
;
return
vform
[
GetNEONFormat
(
format_map
)
]
;
}
static
const
NEONFormatMap
*
IntegerFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
23
22
30
}
{
NF_8B
NF_16B
NF_4H
NF_8H
NF_2S
NF_4S
NF_UNDEF
NF_2D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
LongIntegerFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
23
22
}
{
NF_8H
NF_4S
NF_2D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
FPFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
22
30
}
{
NF_2S
NF_4S
NF_UNDEF
NF_2D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
LoadStoreFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
11
10
30
}
{
NF_8B
NF_16B
NF_4H
NF_8H
NF_2S
NF_4S
NF_1D
NF_2D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
LogicalFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
30
}
{
NF_8B
NF_16B
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
TriangularFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
19
18
17
16
30
}
{
NF_UNDEF
NF_UNDEF
NF_8B
NF_16B
NF_4H
NF_8H
NF_8B
NF_16B
NF_2S
NF_4S
NF_8B
NF_16B
NF_4H
NF_8H
NF_8B
NF_16B
NF_UNDEF
NF_2D
NF_8B
NF_16B
NF_4H
NF_8H
NF_8B
NF_16B
NF_2S
NF_4S
NF_8B
NF_16B
NF_4H
NF_8H
NF_8B
NF_16B
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
ScalarFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
23
22
}
{
NF_B
NF_H
NF_S
NF_D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
LongScalarFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
23
22
}
{
NF_H
NF_S
NF_D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
FPScalarFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
22
}
{
NF_S
NF_D
}
}
;
return
&
map
;
}
static
const
NEONFormatMap
*
TriangularScalarFormatMap
(
)
{
static
const
NEONFormatMap
map
=
{
{
19
18
17
16
}
{
NF_UNDEF
NF_B
NF_H
NF_B
NF_S
NF_B
NF_H
NF_B
NF_D
NF_B
NF_H
NF_B
NF_S
NF_B
NF_H
NF_B
}
}
;
return
&
map
;
}
private
:
const
char
*
GetSubstitute
(
int
index
SubstitutionMode
mode
)
{
if
(
mode
=
=
kFormat
)
{
return
NEONFormatAsString
(
GetNEONFormat
(
formats_
[
index
]
)
)
;
}
VIXL_ASSERT
(
mode
=
=
kPlaceholder
)
;
return
NEONFormatAsPlaceholder
(
GetNEONFormat
(
formats_
[
index
]
)
)
;
}
NEONFormat
GetNEONFormat
(
const
NEONFormatMap
*
format_map
)
{
return
format_map
-
>
map
[
PickBits
(
format_map
-
>
bits
)
]
;
}
static
const
char
*
NEONFormatAsString
(
NEONFormat
format
)
{
static
const
char
*
formats
[
]
=
{
"
undefined
"
"
8b
"
"
16b
"
"
4h
"
"
8h
"
"
2s
"
"
4s
"
"
1d
"
"
2d
"
"
b
"
"
h
"
"
s
"
"
d
"
}
;
VIXL_ASSERT
(
format
<
(
sizeof
(
formats
)
/
sizeof
(
formats
[
0
]
)
)
)
;
return
formats
[
format
]
;
}
static
const
char
*
NEONFormatAsPlaceholder
(
NEONFormat
format
)
{
VIXL_ASSERT
(
(
format
=
=
NF_B
)
|
|
(
format
=
=
NF_H
)
|
|
(
format
=
=
NF_S
)
|
|
(
format
=
=
NF_D
)
|
|
(
format
=
=
NF_UNDEF
)
)
;
static
const
char
*
formats
[
]
=
{
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
undefined
"
"
'
B
"
"
'
H
"
"
'
S
"
"
'
D
"
}
;
return
formats
[
format
]
;
}
uint8_t
PickBits
(
const
uint8_t
bits
[
]
)
{
uint8_t
result
=
0
;
for
(
unsigned
b
=
0
;
b
<
kNEONFormatMaxBits
;
b
+
+
)
{
if
(
bits
[
b
]
=
=
0
)
break
;
result
<
<
=
1
;
result
|
=
(
(
instrbits_
&
(
1
<
<
bits
[
b
]
)
)
=
=
0
)
?
0
:
1
;
}
return
result
;
}
Instr
instrbits_
;
const
NEONFormatMap
*
formats_
[
3
]
;
char
form_buffer_
[
64
]
;
char
mne_buffer_
[
16
]
;
}
;
}
#
endif
