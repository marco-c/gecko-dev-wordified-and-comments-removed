#
ifndef
jit_CompilationDependencyTracker_h
#
define
jit_CompilationDependencyTracker_h
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
InlineTable
.
h
"
#
include
"
jit
/
JitAllocPolicy
.
h
"
struct
JSContext
;
namespace
js
:
:
jit
{
class
IonScriptKey
;
class
MIRGenerator
;
struct
CompilationDependency
:
public
TempObject
{
enum
class
Type
{
GetIterator
ArraySpecies
TypedArraySpecies
RegExpPrototype
StringPrototypeSymbols
EmulatesUndefined
ArrayExceedsInt32Length
ObjectFuseProperty
Limit
}
;
Type
type
;
CompilationDependency
(
Type
type
)
:
type
(
type
)
{
}
virtual
HashNumber
hash
(
)
const
=
0
;
virtual
bool
operator
=
=
(
const
CompilationDependency
&
other
)
const
=
0
;
virtual
bool
checkDependency
(
JSContext
*
cx
)
const
=
0
;
[
[
nodiscard
]
]
virtual
bool
registerDependency
(
JSContext
*
cx
const
IonScriptKey
&
ionScript
)
=
0
;
virtual
CompilationDependency
*
clone
(
TempAllocator
&
alloc
)
const
=
0
;
virtual
~
CompilationDependency
(
)
=
default
;
struct
Hasher
{
using
Lookup
=
const
CompilationDependency
*
;
static
HashNumber
hash
(
const
CompilationDependency
*
dep
)
{
return
dep
-
>
hash
(
)
;
}
static
bool
match
(
const
CompilationDependency
*
k
const
CompilationDependency
*
l
)
{
return
*
k
=
=
*
l
;
}
}
;
}
;
struct
CompilationDependencyTracker
{
using
SetType
=
InlineSet
<
CompilationDependency
*
8
CompilationDependency
:
:
Hasher
SystemAllocPolicy
>
;
SetType
dependencies
;
[
[
nodiscard
]
]
bool
addDependency
(
TempAllocator
&
alloc
const
CompilationDependency
&
dep
)
{
auto
p
=
dependencies
.
lookupForAdd
(
&
dep
)
;
if
(
p
)
{
return
true
;
}
auto
*
clone
=
dep
.
clone
(
alloc
)
;
if
(
!
clone
)
{
return
false
;
}
return
dependencies
.
add
(
p
clone
)
;
}
bool
checkDependencies
(
JSContext
*
cx
)
{
for
(
auto
r
(
dependencies
.
all
(
)
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
CompilationDependency
*
dep
=
r
.
front
(
)
;
if
(
!
dep
-
>
checkDependency
(
cx
)
)
{
return
false
;
}
}
return
true
;
}
void
reset
(
)
{
dependencies
.
clearAndCompact
(
)
;
}
}
;
}
#
endif
