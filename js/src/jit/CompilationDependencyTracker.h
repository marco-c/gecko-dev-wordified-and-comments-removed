#
ifndef
jit_CompilationDependencyTracker_h
#
define
jit_CompilationDependencyTracker_h
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
jit
/
JitAllocPolicy
.
h
"
struct
JSContext
;
namespace
js
:
:
jit
{
class
IonScriptKey
;
class
MIRGenerator
;
struct
CompilationDependency
:
public
TempObject
{
enum
class
Type
{
GetIterator
ArraySpecies
RegExpPrototype
StringPrototypeSymbols
EmulatesUndefined
ArrayExceedsInt32Length
Limit
}
;
Type
type
;
CompilationDependency
(
Type
type
)
:
type
(
type
)
{
}
virtual
bool
operator
=
=
(
const
CompilationDependency
&
other
)
const
=
0
;
virtual
bool
checkDependency
(
JSContext
*
cx
)
const
=
0
;
[
[
nodiscard
]
]
virtual
bool
registerDependency
(
JSContext
*
cx
const
IonScriptKey
&
ionScript
)
=
0
;
virtual
CompilationDependency
*
clone
(
TempAllocator
&
alloc
)
const
=
0
;
virtual
~
CompilationDependency
(
)
=
default
;
}
;
struct
CompilationDependencyTracker
{
mozilla
:
:
Vector
<
CompilationDependency
*
8
SystemAllocPolicy
>
dependencies
;
[
[
nodiscard
]
]
bool
addDependency
(
TempAllocator
&
alloc
const
CompilationDependency
&
dep
)
{
MOZ_ASSERT
(
dependencies
.
length
(
)
<
=
32
)
;
for
(
auto
&
existingDep
:
dependencies
)
{
if
(
dep
=
=
*
existingDep
)
{
return
true
;
}
}
auto
*
clone
=
dep
.
clone
(
alloc
)
;
if
(
!
clone
)
{
return
false
;
}
return
dependencies
.
append
(
clone
)
;
}
bool
checkDependencies
(
JSContext
*
cx
)
{
for
(
auto
&
dep
:
dependencies
)
{
if
(
!
dep
-
>
checkDependency
(
cx
)
)
{
return
false
;
}
}
return
true
;
}
void
reset
(
)
{
dependencies
.
clearAndFree
(
)
;
}
}
;
}
#
endif
