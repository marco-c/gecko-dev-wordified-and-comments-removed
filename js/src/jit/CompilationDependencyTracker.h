#
ifndef
jit_CompilationDependencyTracker_h
#
define
jit_CompilationDependencyTracker_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
vm
/
Logging
.
h
"
struct
JSContext
;
namespace
js
:
:
jit
{
class
MIRGenerator
;
struct
CompilationDependency
{
enum
class
Type
{
GetIterator
EmulatesUndefined
GenerationCounter
Limit
}
;
static
const
char
*
TypeToName
(
Type
type
)
{
switch
(
type
)
{
case
Type
:
:
GetIterator
:
return
"
GetIterator
"
;
case
Type
:
:
EmulatesUndefined
:
return
"
EmulatesUndefined
"
;
case
Type
:
:
GenerationCounter
:
return
"
GenerationCounter
"
;
default
:
MOZ_CRASH
(
"
Unknown
Type
"
)
;
}
}
Type
type
;
CompilationDependency
(
Type
type
)
:
type
(
type
)
{
}
virtual
bool
operator
=
=
(
CompilationDependency
&
other
)
=
0
;
virtual
bool
checkDependency
(
JSContext
*
cx
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
registerDependency
(
JSContext
*
cx
HandleScript
script
)
=
0
;
virtual
UniquePtr
<
CompilationDependency
>
clone
(
)
=
0
;
virtual
~
CompilationDependency
(
)
=
default
;
}
;
struct
CompilationDependencyTracker
{
mozilla
:
:
Vector
<
UniquePtr
<
CompilationDependency
>
8
SystemAllocPolicy
>
dependencies
;
[
[
nodiscard
]
]
bool
addDependency
(
CompilationDependency
&
dep
)
{
MOZ_ASSERT
(
dependencies
.
length
(
)
<
=
32
)
;
for
(
auto
&
existingDep
:
dependencies
)
{
if
(
dep
=
=
*
existingDep
)
{
return
true
;
}
}
auto
clone
=
dep
.
clone
(
)
;
if
(
!
clone
)
{
return
false
;
}
return
dependencies
.
append
(
std
:
:
move
(
clone
)
)
;
}
bool
checkDependencies
(
JSContext
*
cx
)
{
for
(
auto
&
dep
:
dependencies
)
{
if
(
!
dep
-
>
checkDependency
(
cx
)
)
{
JS_LOG
(
compilationDependency
Debug
"
Failed
dependency
check
type
%
s
\
n
"
CompilationDependency
:
:
TypeToName
(
dep
-
>
type
)
)
return
false
;
}
}
return
true
;
}
void
reset
(
)
{
dependencies
.
clearAndFree
(
)
;
}
}
;
}
#
endif
