#
include
"
jit
/
IonCaches
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
TypedObject
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitcodeMap
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
ifdef
JS_ION_PERF
#
include
"
jit
/
PerfSpewer
.
h
"
#
endif
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
tl
:
:
FloorLog2
;
typedef
Rooted
<
TypedArrayObject
*
>
RootedTypedArrayObject
;
void
CodeLocationJump
:
:
repoint
(
JitCode
*
code
MacroAssembler
*
masm
)
{
MOZ_ASSERT
(
state_
=
=
Relative
)
;
size_t
new_off
=
(
size_t
)
raw_
;
#
ifdef
JS_SMALL_BRANCH
size_t
jumpTableEntryOffset
=
reinterpret_cast
<
size_t
>
(
jumpTableEntry_
)
;
#
endif
if
(
masm
!
=
nullptr
)
{
#
ifdef
JS_CODEGEN_X64
MOZ_ASSERT
(
(
uint64_t
)
raw_
<
=
UINT32_MAX
)
;
#
endif
new_off
=
(
uintptr_t
)
raw_
;
#
ifdef
JS_SMALL_BRANCH
jumpTableEntryOffset
=
masm
-
>
actualIndex
(
jumpTableEntryOffset
)
;
#
endif
}
raw_
=
code
-
>
raw
(
)
+
new_off
;
#
ifdef
JS_SMALL_BRANCH
jumpTableEntry_
=
Assembler
:
:
PatchableJumpAddress
(
code
(
size_t
)
jumpTableEntryOffset
)
;
#
endif
setAbsolute
(
)
;
}
void
CodeLocationLabel
:
:
repoint
(
JitCode
*
code
MacroAssembler
*
masm
)
{
MOZ_ASSERT
(
state_
=
=
Relative
)
;
size_t
new_off
=
(
size_t
)
raw_
;
if
(
masm
!
=
nullptr
)
{
#
ifdef
JS_CODEGEN_X64
MOZ_ASSERT
(
(
uint64_t
)
raw_
<
=
UINT32_MAX
)
;
#
endif
new_off
=
(
uintptr_t
)
raw_
;
}
MOZ_ASSERT
(
new_off
<
code
-
>
instructionsSize
(
)
)
;
raw_
=
code
-
>
raw
(
)
+
new_off
;
setAbsolute
(
)
;
}
void
CodeOffsetJump
:
:
fixup
(
MacroAssembler
*
masm
)
{
#
ifdef
JS_SMALL_BRANCH
jumpTableIndex_
=
masm
-
>
actualIndex
(
jumpTableIndex_
)
;
#
endif
}
const
char
*
IonCache
:
:
CacheName
(
IonCache
:
:
Kind
kind
)
{
static
const
char
*
const
names
[
]
=
{
#
define
NAME
(
x
)
#
x
IONCACHE_KIND_LIST
(
NAME
)
#
undef
NAME
}
;
return
names
[
kind
]
;
}
const
size_t
IonCache
:
:
MAX_STUBS
=
16
;
class
IonCache
:
:
StubAttacher
{
protected
:
bool
hasNextStubOffset_
:
1
;
bool
hasStubCodePatchOffset_
:
1
;
IonCache
&
cache_
;
CodeLocationLabel
rejoinLabel_
;
CodeOffsetJump
nextStubOffset_
;
CodeOffsetJump
rejoinOffset_
;
CodeOffset
stubCodePatchOffset_
;
public
:
explicit
StubAttacher
(
IonCache
&
cache
)
:
hasNextStubOffset_
(
false
)
hasStubCodePatchOffset_
(
false
)
cache_
(
cache
)
rejoinLabel_
(
cache
.
rejoinLabel_
)
nextStubOffset_
(
)
rejoinOffset_
(
)
stubCodePatchOffset_
(
)
{
}
static
const
void
*
const
STUB_ADDR
;
template
<
class
T1
class
T2
>
void
branchNextStub
(
MacroAssembler
&
masm
Assembler
:
:
Condition
cond
T1
op1
T2
op2
)
{
MOZ_ASSERT
(
!
hasNextStubOffset_
)
;
RepatchLabel
nextStub
;
nextStubOffset_
=
masm
.
branchPtrWithPatch
(
cond
op1
op2
&
nextStub
)
;
hasNextStubOffset_
=
true
;
masm
.
bind
(
&
nextStub
)
;
}
template
<
class
T1
class
T2
>
void
branchNextStubOrLabel
(
MacroAssembler
&
masm
Assembler
:
:
Condition
cond
T1
op1
T2
op2
Label
*
label
)
{
if
(
label
!
=
nullptr
)
masm
.
branchPtr
(
cond
op1
op2
label
)
;
else
branchNextStub
(
masm
cond
op1
op2
)
;
}
void
jumpRejoin
(
MacroAssembler
&
masm
)
{
RepatchLabel
rejoin
;
rejoinOffset_
=
masm
.
jumpWithPatch
(
&
rejoin
)
;
masm
.
bind
(
&
rejoin
)
;
}
void
jumpNextStub
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
!
hasNextStubOffset_
)
;
RepatchLabel
nextStub
;
nextStubOffset_
=
masm
.
jumpWithPatch
(
&
nextStub
)
;
hasNextStubOffset_
=
true
;
masm
.
bind
(
&
nextStub
)
;
}
void
pushStubCodePointer
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
!
hasStubCodePatchOffset_
)
;
stubCodePatchOffset_
=
masm
.
PushWithPatch
(
ImmPtr
(
STUB_ADDR
)
)
;
hasStubCodePatchOffset_
=
true
;
}
void
patchRejoinJump
(
MacroAssembler
&
masm
JitCode
*
code
)
{
rejoinOffset_
.
fixup
(
&
masm
)
;
CodeLocationJump
rejoinJump
(
code
rejoinOffset_
)
;
PatchJump
(
rejoinJump
rejoinLabel_
)
;
}
void
patchStubCodePointer
(
JitCode
*
code
)
{
if
(
hasStubCodePatchOffset_
)
{
Assembler
:
:
PatchDataWithValueCheck
(
CodeLocationLabel
(
code
stubCodePatchOffset_
)
ImmPtr
(
code
)
ImmPtr
(
STUB_ADDR
)
)
;
}
}
void
patchNextStubJump
(
MacroAssembler
&
masm
JitCode
*
code
)
{
if
(
hasNextStubOffset_
)
{
nextStubOffset_
.
fixup
(
&
masm
)
;
CodeLocationJump
nextStubJump
(
code
nextStubOffset_
)
;
PatchJump
(
nextStubJump
cache_
.
fallbackLabel_
)
;
cache_
.
lastJump_
=
nextStubJump
;
}
}
}
;
const
void
*
const
IonCache
:
:
StubAttacher
:
:
STUB_ADDR
=
(
void
*
)
0xdeadc0de
;
void
IonCache
:
:
emitInitialJump
(
MacroAssembler
&
masm
RepatchLabel
&
entry
)
{
initialJump_
=
masm
.
jumpWithPatch
(
&
entry
)
;
lastJump_
=
initialJump_
;
Label
label
;
masm
.
bind
(
&
label
)
;
rejoinLabel_
=
CodeOffset
(
label
.
offset
(
)
)
;
}
void
IonCache
:
:
attachStub
(
MacroAssembler
&
masm
StubAttacher
&
attacher
CodeLocationJump
lastJump
Handle
<
JitCode
*
>
code
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
incrementStubCount
(
)
;
PatchJump
(
lastJump
CodeLocationLabel
(
code
)
Reprotect
)
;
}
IonCache
:
:
LinkStatus
IonCache
:
:
linkCode
(
JSContext
*
cx
MacroAssembler
&
masm
StubAttacher
&
attacher
IonScript
*
ion
JitCode
*
*
code
)
{
Linker
linker
(
masm
)
;
*
code
=
linker
.
newCode
<
CanGC
>
(
cx
ION_CODE
)
;
if
(
!
*
code
)
return
LINK_ERROR
;
if
(
ion
-
>
invalidated
(
)
)
return
CACHE_FLUSHED
;
attacher
.
patchRejoinJump
(
masm
*
code
)
;
attacher
.
patchStubCodePointer
(
*
code
)
;
attacher
.
patchNextStubJump
(
masm
*
code
)
;
return
LINK_GOOD
;
}
bool
IonCache
:
:
linkAndAttachStub
(
JSContext
*
cx
MacroAssembler
&
masm
StubAttacher
&
attacher
IonScript
*
ion
const
char
*
attachKind
JS
:
:
TrackedOutcome
trackedOutcome
)
{
CodeLocationJump
lastJumpBefore
=
lastJump_
;
Rooted
<
JitCode
*
>
code
(
cx
)
;
{
AutoFlushICache
afc
(
"
IonCache
"
)
;
LinkStatus
status
=
linkCode
(
cx
masm
attacher
ion
code
.
address
(
)
)
;
if
(
status
!
=
LINK_GOOD
)
return
status
!
=
LINK_ERROR
;
}
if
(
pc_
)
{
JitSpew
(
JitSpew_IonIC
"
Cache
%
p
(
%
s
:
%
"
PRIuSIZE
"
/
%
"
PRIuSIZE
"
)
generated
%
s
%
s
stub
at
%
p
"
this
script_
-
>
filename
(
)
script_
-
>
lineno
(
)
script_
-
>
pcToOffset
(
pc_
)
attachKind
CacheName
(
kind
(
)
)
code
-
>
raw
(
)
)
;
}
else
{
JitSpew
(
JitSpew_IonIC
"
Cache
%
p
generated
%
s
%
s
stub
at
%
p
"
this
attachKind
CacheName
(
kind
(
)
)
code
-
>
raw
(
)
)
;
}
#
ifdef
JS_ION_PERF
writePerfSpewerJitCodeProfile
(
code
"
IonCache
"
)
;
#
endif
attachStub
(
masm
attacher
lastJumpBefore
code
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
{
JitcodeGlobalEntry
:
:
IonCacheEntry
entry
;
entry
.
init
(
code
code
-
>
raw
(
)
code
-
>
rawEnd
(
)
rejoinAddress
(
)
trackedOutcome
)
;
JitcodeGlobalTable
*
globalTable
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getJitcodeGlobalTable
(
)
;
if
(
!
globalTable
-
>
addEntry
(
entry
cx
-
>
runtime
(
)
)
)
{
entry
.
destroy
(
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
code
-
>
setHasBytecodeMap
(
)
;
}
else
{
JitcodeGlobalEntry
:
:
DummyEntry
entry
;
entry
.
init
(
code
code
-
>
raw
(
)
code
-
>
rawEnd
(
)
)
;
JitcodeGlobalTable
*
globalTable
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getJitcodeGlobalTable
(
)
;
if
(
!
globalTable
-
>
addEntry
(
entry
cx
-
>
runtime
(
)
)
)
{
entry
.
destroy
(
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
code
-
>
setHasBytecodeMap
(
)
;
}
if
(
masm
.
oom
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
IonCache
:
:
updateBaseAddress
(
JitCode
*
code
MacroAssembler
&
masm
)
{
fallbackLabel_
.
repoint
(
code
&
masm
)
;
initialJump_
.
repoint
(
code
&
masm
)
;
lastJump_
.
repoint
(
code
&
masm
)
;
rejoinLabel_
.
repoint
(
code
&
masm
)
;
}
static
void
*
GetReturnAddressToIonCode
(
JSContext
*
cx
)
{
JitFrameIterator
iter
(
cx
)
;
MOZ_ASSERT
(
iter
.
type
(
)
=
=
JitFrame_Exit
"
An
exit
frame
is
expected
as
update
functions
are
called
with
a
VMFunction
.
"
)
;
void
*
returnAddr
=
iter
.
returnAddress
(
)
;
#
ifdef
DEBUG
+
+
iter
;
MOZ_ASSERT
(
iter
.
isIonJS
(
)
)
;
#
endif
return
returnAddr
;
}
static
void
GeneratePrototypeGuards
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
JSObject
*
obj
JSObject
*
holder
Register
objectReg
Register
scratchReg
Label
*
failures
)
{
MOZ_ASSERT
(
obj
!
=
holder
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
masm
.
loadPtr
(
Address
(
objectReg
JSObject
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
Address
proto
(
scratchReg
ObjectGroup
:
:
offsetOfProto
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
proto
ImmGCPtr
(
obj
-
>
getProto
(
)
)
failures
)
;
}
JSObject
*
pobj
=
IsCacheableDOMProxy
(
obj
)
?
obj
-
>
getTaggedProto
(
)
.
toObjectOrNull
(
)
:
obj
-
>
getProto
(
)
;
if
(
!
pobj
)
return
;
while
(
pobj
!
=
holder
)
{
if
(
pobj
-
>
hasUncacheableProto
(
)
)
{
masm
.
movePtr
(
ImmGCPtr
(
pobj
)
scratchReg
)
;
Address
groupAddr
(
scratchReg
JSObject
:
:
offsetOfGroup
(
)
)
;
if
(
pobj
-
>
isSingleton
(
)
)
{
masm
.
loadPtr
(
groupAddr
scratchReg
)
;
Address
protoAddr
(
scratchReg
ObjectGroup
:
:
offsetOfProto
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
protoAddr
ImmGCPtr
(
pobj
-
>
getProto
(
)
)
failures
)
;
}
else
{
masm
.
branchPtr
(
Assembler
:
:
NotEqual
groupAddr
ImmGCPtr
(
pobj
-
>
group
(
)
)
failures
)
;
}
}
pobj
=
pobj
-
>
getProto
(
)
;
}
}
static
bool
IsCacheableProtoChainForIon
(
JSObject
*
obj
JSObject
*
holder
)
{
while
(
obj
!
=
holder
)
{
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
if
(
!
proto
|
|
!
proto
-
>
isNative
(
)
)
return
false
;
obj
=
proto
;
}
return
true
;
}
static
bool
IsCacheableGetPropReadSlotForIon
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
if
(
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
return
true
;
}
static
bool
IsCacheableNoProperty
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
jsbytecode
*
pc
const
TypedOrValueRegister
&
output
)
{
if
(
shape
)
return
false
;
MOZ_ASSERT
(
!
holder
)
;
if
(
obj
-
>
getClass
(
)
-
>
getProperty
)
return
false
;
JSObject
*
obj2
=
obj
;
while
(
obj2
)
{
if
(
!
obj2
-
>
isNative
(
)
)
return
false
;
obj2
=
obj2
-
>
getProto
(
)
;
}
if
(
!
pc
)
return
false
;
if
(
!
output
.
hasValue
(
)
)
return
false
;
return
true
;
}
static
bool
IsOptimizableArgumentsObjectForLength
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
ArgumentsObject
>
(
)
)
return
false
;
if
(
obj
-
>
as
<
ArgumentsObject
>
(
)
.
hasOverriddenLength
(
)
)
return
false
;
return
true
;
}
static
bool
IsOptimizableArgumentsObjectForGetElem
(
JSObject
*
obj
Value
idval
)
{
if
(
!
IsOptimizableArgumentsObjectForLength
(
obj
)
)
return
false
;
ArgumentsObject
&
argsObj
=
obj
-
>
as
<
ArgumentsObject
>
(
)
;
if
(
argsObj
.
isAnyElementDeleted
(
)
)
return
false
;
if
(
!
idval
.
isInt32
(
)
)
return
false
;
int32_t
idint
=
idval
.
toInt32
(
)
;
if
(
idint
<
0
|
|
static_cast
<
uint32_t
>
(
idint
)
>
=
argsObj
.
initialLength
(
)
)
return
false
;
return
true
;
}
static
bool
IsCacheableGetPropCallNative
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
if
(
!
shape
-
>
hasGetterValue
(
)
|
|
!
shape
-
>
getterValue
(
)
.
isObject
(
)
)
return
false
;
if
(
!
shape
-
>
getterValue
(
)
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
&
getter
=
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
getter
.
isNative
(
)
)
return
false
;
if
(
getter
.
jitInfo
(
)
&
&
!
getter
.
jitInfo
(
)
-
>
needsOuterizedThisObject
(
)
)
return
true
;
return
!
IsWindow
(
obj
)
;
}
static
bool
IsCacheableGetPropCallScripted
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
if
(
!
shape
-
>
hasGetterValue
(
)
|
|
!
shape
-
>
getterValue
(
)
.
isObject
(
)
)
return
false
;
if
(
!
shape
-
>
getterValue
(
)
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
&
getter
=
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
getter
.
hasJITCode
(
)
)
return
false
;
return
!
IsWindow
(
obj
)
;
}
static
bool
IsCacheableGetPropCallPropertyOp
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
if
(
shape
-
>
hasSlot
(
)
|
|
shape
-
>
hasGetterValue
(
)
|
|
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
return
true
;
}
static
void
TestMatchingReceiver
(
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
Register
object
JSObject
*
obj
Label
*
failure
bool
alwaysCheckGroup
=
false
)
{
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
failure
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
object
obj
-
>
group
(
)
failure
)
;
Address
expandoAddress
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
{
masm
.
branchPtr
(
Assembler
:
:
Equal
expandoAddress
ImmWord
(
0
)
failure
)
;
Label
success
;
masm
.
push
(
object
)
;
masm
.
loadPtr
(
expandoAddress
object
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
Equal
object
expando
-
>
lastProperty
(
)
&
success
)
;
masm
.
pop
(
object
)
;
masm
.
jump
(
failure
)
;
masm
.
bind
(
&
success
)
;
masm
.
pop
(
object
)
;
}
else
{
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expandoAddress
ImmWord
(
0
)
failure
)
;
}
}
else
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
{
MOZ_ASSERT
(
failure
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
object
obj
-
>
group
(
)
failure
)
;
}
else
if
(
obj
-
>
is
<
TypedObject
>
(
)
)
{
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
ImmGCPtr
(
obj
-
>
group
(
)
)
failure
)
;
}
else
{
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
MOZ_ASSERT
(
shape
)
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
shape
)
failure
)
;
if
(
alwaysCheckGroup
)
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
object
obj
-
>
group
(
)
failure
)
;
}
}
static
inline
void
EmitLoadSlot
(
MacroAssembler
&
masm
NativeObject
*
holder
Shape
*
shape
Register
holderReg
TypedOrValueRegister
output
Register
scratchReg
)
{
MOZ_ASSERT
(
holder
)
;
NativeObject
:
:
slotsSizeMustNotOverflow
(
)
;
if
(
holder
-
>
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
Address
addr
(
holderReg
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
masm
.
loadTypedOrValue
(
addr
output
)
;
}
else
{
masm
.
loadPtr
(
Address
(
holderReg
NativeObject
:
:
offsetOfSlots
(
)
)
scratchReg
)
;
Address
addr
(
scratchReg
holder
-
>
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
)
;
masm
.
loadTypedOrValue
(
addr
output
)
;
}
}
static
void
CheckDOMProxyExpandoDoesNotShadow
(
JSContext
*
cx
MacroAssembler
&
masm
JSObject
*
obj
jsid
id
Register
object
Label
*
stubFailure
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
AllocatableRegisterSet
domProxyRegSet
(
RegisterSet
:
:
All
(
)
)
;
domProxyRegSet
.
take
(
AnyRegister
(
object
)
)
;
ValueOperand
tempVal
=
domProxyRegSet
.
takeAnyValue
(
)
;
masm
.
pushValue
(
tempVal
)
;
Label
failDOMProxyCheck
;
Label
domProxyOk
;
Value
expandoVal
=
GetProxyExtra
(
obj
GetDOMProxyExpandoSlot
(
)
)
;
masm
.
loadPtr
(
Address
(
object
ProxyObject
:
:
offsetOfValues
(
)
)
tempVal
.
scratchReg
(
)
)
;
masm
.
loadValue
(
Address
(
tempVal
.
scratchReg
(
)
ProxyObject
:
:
offsetOfExtraSlotInValues
(
GetDOMProxyExpandoSlot
(
)
)
)
tempVal
)
;
if
(
!
expandoVal
.
isObject
(
)
&
&
!
expandoVal
.
isUndefined
(
)
)
{
masm
.
branchTestValue
(
Assembler
:
:
NotEqual
tempVal
expandoVal
&
failDOMProxyCheck
)
;
ExpandoAndGeneration
*
expandoAndGeneration
=
(
ExpandoAndGeneration
*
)
expandoVal
.
toPrivate
(
)
;
masm
.
movePtr
(
ImmPtr
(
expandoAndGeneration
)
tempVal
.
scratchReg
(
)
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
tempVal
.
scratchReg
(
)
ExpandoAndGeneration
:
:
offsetOfGeneration
(
)
)
Imm32
(
expandoAndGeneration
-
>
generation
)
&
failDOMProxyCheck
)
;
expandoVal
=
expandoAndGeneration
-
>
expando
;
masm
.
loadValue
(
Address
(
tempVal
.
scratchReg
(
)
ExpandoAndGeneration
:
:
offsetOfExpando
(
)
)
tempVal
)
;
}
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
tempVal
&
domProxyOk
)
;
if
(
expandoVal
.
isObject
(
)
)
{
MOZ_ASSERT
(
!
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
.
contains
(
cx
id
)
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
tempVal
&
failDOMProxyCheck
)
;
masm
.
extractObject
(
tempVal
tempVal
.
scratchReg
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
Address
(
tempVal
.
scratchReg
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
expandoVal
.
toObject
(
)
.
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
&
domProxyOk
)
;
}
masm
.
bind
(
&
failDOMProxyCheck
)
;
masm
.
popValue
(
tempVal
)
;
masm
.
jump
(
stubFailure
)
;
masm
.
bind
(
&
domProxyOk
)
;
masm
.
popValue
(
tempVal
)
;
}
static
void
GenerateReadSlot
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
MaybeCheckLexical
checkLexical
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
Register
object
TypedOrValueRegister
output
Label
*
failures
=
nullptr
)
{
bool
multipleFailureJumps
=
(
obj
!
=
holder
)
|
|
obj
-
>
is
<
UnboxedPlainObject
>
(
)
|
|
(
checkLexical
&
&
output
.
hasValue
(
)
)
|
|
(
failures
!
=
nullptr
&
&
failures
-
>
used
(
)
)
;
Label
failures_
;
if
(
multipleFailureJumps
&
&
!
failures
)
failures
=
&
failures_
;
TestMatchingReceiver
(
masm
attacher
object
obj
failures
)
;
bool
restoreScratch
=
false
;
Register
scratchReg
=
Register
:
:
FromCode
(
0
)
;
if
(
obj
!
=
holder
|
|
obj
-
>
is
<
UnboxedPlainObject
>
(
)
|
|
!
holder
-
>
as
<
NativeObject
>
(
)
.
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
if
(
output
.
hasValue
(
)
)
{
scratchReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
if
(
output
.
type
(
)
=
=
MIRType_Double
)
{
scratchReg
=
object
;
masm
.
push
(
scratchReg
)
;
restoreScratch
=
true
;
}
else
{
scratchReg
=
output
.
typedReg
(
)
.
gpr
(
)
;
}
}
if
(
!
multipleFailureJumps
)
{
EmitLoadSlot
(
masm
&
holder
-
>
as
<
NativeObject
>
(
)
shape
object
output
scratchReg
)
;
if
(
restoreScratch
)
masm
.
pop
(
scratchReg
)
;
attacher
.
jumpRejoin
(
masm
)
;
return
;
}
Label
prototypeFailures
;
Register
holderReg
;
if
(
obj
!
=
holder
)
{
GeneratePrototypeGuards
(
cx
ion
masm
obj
holder
object
scratchReg
&
prototypeFailures
)
;
if
(
holder
)
{
holderReg
=
scratchReg
;
masm
.
movePtr
(
ImmGCPtr
(
holder
)
holderReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
holderReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
&
prototypeFailures
)
;
}
else
{
JSObject
*
proto
=
obj
-
>
getTaggedProto
(
)
.
toObjectOrNull
(
)
;
Register
lastReg
=
object
;
MOZ_ASSERT
(
scratchReg
!
=
object
)
;
while
(
proto
)
{
masm
.
loadObjProto
(
lastReg
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
scratchReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
&
prototypeFailures
)
;
proto
=
proto
-
>
getProto
(
)
;
lastReg
=
scratchReg
;
}
holderReg
=
InvalidReg
;
}
}
else
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holder
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
holderReg
=
scratchReg
;
masm
.
loadPtr
(
Address
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
holderReg
)
;
}
else
{
holderReg
=
object
;
}
if
(
holder
)
{
EmitLoadSlot
(
masm
&
holder
-
>
as
<
NativeObject
>
(
)
shape
holderReg
output
scratchReg
)
;
if
(
checkLexical
&
&
output
.
hasValue
(
)
)
masm
.
branchTestMagic
(
Assembler
:
:
Equal
output
.
valueReg
(
)
failures
)
;
}
else
{
masm
.
moveValue
(
UndefinedValue
(
)
output
.
valueReg
(
)
)
;
}
if
(
restoreScratch
)
masm
.
pop
(
scratchReg
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
prototypeFailures
)
;
if
(
restoreScratch
)
masm
.
pop
(
scratchReg
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
static
void
GenerateReadUnboxed
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
const
UnboxedLayout
:
:
Property
*
property
Register
object
TypedOrValueRegister
output
Label
*
failures
=
nullptr
)
{
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
ImmGCPtr
(
obj
-
>
group
(
)
)
failures
)
;
Address
address
(
object
UnboxedPlainObject
:
:
offsetOfData
(
)
+
property
-
>
offset
)
;
masm
.
loadUnboxedProperty
(
address
property
-
>
type
output
)
;
attacher
.
jumpRejoin
(
masm
)
;
if
(
failures
)
{
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
}
static
bool
EmitGetterCall
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
JSObject
*
holder
HandleShape
shape
bool
holderIsReceiver
LiveRegisterSet
liveRegs
Register
object
TypedOrValueRegister
output
void
*
returnAddr
)
{
MOZ_ASSERT
(
output
.
hasValue
(
)
)
;
MacroAssembler
:
:
AfterICSaveLive
aic
=
masm
.
icSaveLive
(
liveRegs
)
;
MOZ_ASSERT_IF
(
obj
!
=
holder
!
holderIsReceiver
)
;
AllocatableRegisterSet
regSet
(
RegisterSet
:
:
All
(
)
)
;
regSet
.
take
(
AnyRegister
(
object
)
)
;
Register
scratchReg
=
regSet
.
takeAnyGeneral
(
)
;
if
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
)
{
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argUintNReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argVpReg
=
regSet
.
takeAnyGeneral
(
)
;
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
masm
.
Push
(
TypedOrValueRegister
(
MIRType_Object
AnyRegister
(
object
)
)
)
;
masm
.
Push
(
ObjectValue
(
*
target
)
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
masm
.
move32
(
Imm32
(
0
)
argUintNReg
)
;
masm
.
moveStackPtrTo
(
argVpReg
)
;
masm
.
Push
(
argUintNReg
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLNativeExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
scratchReg
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argUintNReg
)
;
masm
.
passABIArg
(
argVpReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
target
-
>
native
(
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
Address
outparam
(
masm
.
getStackPointer
(
)
IonOOLNativeExitFrameLayout
:
:
offsetOfResult
(
)
)
;
masm
.
loadTypedOrValue
(
outparam
output
)
;
masm
.
adjustStack
(
IonOOLNativeExitFrameLayout
:
:
Size
(
0
)
)
;
}
else
if
(
IsCacheableGetPropCallPropertyOp
(
obj
holder
shape
)
)
{
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argObjReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argIdReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argVpReg
=
regSet
.
takeAnyGeneral
(
)
;
GetterOp
target
=
shape
-
>
getterOp
(
)
;
MOZ_ASSERT
(
target
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
masm
.
Push
(
UndefinedValue
(
)
)
;
masm
.
moveStackPtrTo
(
argVpReg
)
;
masm
.
Push
(
shape
-
>
propid
(
)
scratchReg
)
;
masm
.
moveStackPtrTo
(
argIdReg
)
;
if
(
holderIsReceiver
)
{
masm
.
Push
(
object
)
;
}
else
{
masm
.
movePtr
(
ImmGCPtr
(
holder
)
scratchReg
)
;
masm
.
Push
(
scratchReg
)
;
}
masm
.
moveStackPtrTo
(
argObjReg
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLPropertyOpExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
scratchReg
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argObjReg
)
;
masm
.
passABIArg
(
argIdReg
)
;
masm
.
passABIArg
(
argVpReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
target
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
Address
outparam
(
masm
.
getStackPointer
(
)
IonOOLPropertyOpExitFrameLayout
:
:
offsetOfResult
(
)
)
;
masm
.
loadTypedOrValue
(
outparam
output
)
;
masm
.
adjustStack
(
IonOOLPropertyOpExitFrameLayout
:
:
Size
(
)
)
;
}
else
{
MOZ_ASSERT
(
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
getterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
uint32_t
framePushedBefore
=
masm
.
framePushed
(
)
;
uint32_t
descriptor
=
MakeFrameDescriptor
(
masm
.
framePushed
(
)
JitFrame_IonJS
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
masm
.
Push
(
Imm32
(
descriptor
)
)
;
masm
.
Push
(
ImmPtr
(
returnAddr
)
)
;
uint32_t
argSize
=
(
target
-
>
nargs
(
)
+
1
)
*
sizeof
(
Value
)
;
uint32_t
padding
=
ComputeByteAlignment
(
masm
.
framePushed
(
)
+
argSize
JitStackAlignment
)
;
MOZ_ASSERT
(
padding
%
sizeof
(
uintptr_t
)
=
=
0
)
;
MOZ_ASSERT
(
padding
<
JitStackAlignment
)
;
masm
.
reserveStack
(
padding
)
;
for
(
size_t
i
=
0
;
i
<
target
-
>
nargs
(
)
;
i
+
+
)
masm
.
Push
(
UndefinedValue
(
)
)
;
masm
.
Push
(
TypedOrValueRegister
(
MIRType_Object
AnyRegister
(
object
)
)
)
;
masm
.
movePtr
(
ImmGCPtr
(
target
)
scratchReg
)
;
descriptor
=
MakeFrameDescriptor
(
argSize
+
padding
JitFrame_IonAccessorIC
)
;
masm
.
Push
(
Imm32
(
0
)
)
;
masm
.
Push
(
scratchReg
)
;
masm
.
Push
(
Imm32
(
descriptor
)
)
;
MOZ_ASSERT
(
(
(
masm
.
framePushed
(
)
+
sizeof
(
uintptr_t
)
)
%
JitStackAlignment
)
=
=
0
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
masm
.
loadPtr
(
Address
(
scratchReg
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
scratchReg
)
;
masm
.
loadBaselineOrIonRaw
(
scratchReg
scratchReg
nullptr
)
;
masm
.
callJit
(
scratchReg
)
;
masm
.
storeCallResultValue
(
output
)
;
masm
.
freeStack
(
masm
.
framePushed
(
)
-
framePushedBefore
)
;
}
masm
.
icRestoreLive
(
liveRegs
aic
)
;
return
true
;
}
static
bool
GenerateCallGetter
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
JSObject
*
holder
HandleShape
shape
LiveRegisterSet
&
liveRegs
Register
object
TypedOrValueRegister
output
void
*
returnAddr
Label
*
failures
=
nullptr
)
{
MOZ_ASSERT
(
output
.
hasValue
(
)
)
;
Label
stubFailure
;
failures
=
failures
?
failures
:
&
stubFailure
;
TestMatchingReceiver
(
masm
attacher
object
obj
failures
)
;
Register
scratchReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
bool
spillObjReg
=
scratchReg
=
=
object
;
Label
pop1AndFail
;
Label
*
maybePopAndFail
=
failures
;
if
(
IsGlobalLexicalScope
(
obj
)
)
masm
.
extractObject
(
Address
(
object
ScopeObject
:
:
offsetOfEnclosingScope
(
)
)
object
)
;
if
(
spillObjReg
)
{
masm
.
push
(
object
)
;
maybePopAndFail
=
&
pop1AndFail
;
}
if
(
obj
!
=
holder
)
GeneratePrototypeGuards
(
cx
ion
masm
obj
holder
object
scratchReg
failures
)
;
Register
holderReg
=
scratchReg
;
masm
.
movePtr
(
ImmGCPtr
(
holder
)
holderReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
holderReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
maybePopAndFail
)
;
if
(
spillObjReg
)
masm
.
pop
(
object
)
;
bool
holderIsReceiver
=
(
obj
=
=
holder
)
;
if
(
!
EmitGetterCall
(
cx
masm
attacher
obj
holder
shape
holderIsReceiver
liveRegs
object
output
returnAddr
)
)
return
false
;
attacher
.
jumpRejoin
(
masm
)
;
if
(
spillObjReg
)
{
masm
.
bind
(
&
pop1AndFail
)
;
masm
.
pop
(
object
)
;
}
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
static
bool
GenerateArrayLength
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
Register
object
TypedOrValueRegister
output
Label
*
failures
)
{
MOZ_ASSERT
(
obj
-
>
is
<
ArrayObject
>
(
)
)
;
RootedShape
shape
(
cx
obj
-
>
as
<
ArrayObject
>
(
)
.
lastProperty
(
)
)
;
if
(
!
shape
)
return
false
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
shape
failures
)
;
Register
outReg
;
if
(
output
.
hasValue
(
)
)
{
outReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
{
MOZ_ASSERT
(
output
.
type
(
)
=
=
MIRType_Int32
)
;
outReg
=
output
.
typedReg
(
)
.
gpr
(
)
;
}
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfElements
(
)
)
outReg
)
;
masm
.
load32
(
Address
(
outReg
ObjectElements
:
:
offsetOfLength
(
)
)
outReg
)
;
MOZ_ASSERT
(
object
!
=
outReg
)
;
masm
.
branchTest32
(
Assembler
:
:
Signed
outReg
outReg
failures
)
;
if
(
output
.
hasValue
(
)
)
masm
.
tagValue
(
JSVAL_TYPE_INT32
outReg
output
.
valueReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
static
void
GenerateUnboxedArrayLength
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
array
Register
object
TypedOrValueRegister
output
Label
*
failures
)
{
Register
outReg
;
if
(
output
.
hasValue
(
)
)
{
outReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
{
MOZ_ASSERT
(
output
.
type
(
)
=
=
MIRType_Int32
)
;
outReg
=
output
.
typedReg
(
)
.
gpr
(
)
;
}
MOZ_ASSERT
(
object
!
=
outReg
)
;
TestMatchingReceiver
(
masm
attacher
object
array
failures
)
;
masm
.
load32
(
Address
(
object
UnboxedArrayObject
:
:
offsetOfLength
(
)
)
outReg
)
;
masm
.
branchTest32
(
Assembler
:
:
Signed
outReg
outReg
failures
)
;
if
(
output
.
hasValue
(
)
)
masm
.
tagValue
(
JSVAL_TYPE_INT32
outReg
output
.
valueReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
static
void
GenerateTypedArrayLength
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
Register
object
TypedOrValueRegister
output
Label
*
failures
)
{
Register
tmpReg
;
if
(
output
.
hasValue
(
)
)
{
tmpReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
{
MOZ_ASSERT
(
output
.
type
(
)
=
=
MIRType_Int32
)
;
tmpReg
=
output
.
typedReg
(
)
.
gpr
(
)
;
}
MOZ_ASSERT
(
object
!
=
tmpReg
)
;
masm
.
loadObjClass
(
object
tmpReg
)
;
masm
.
branchPtr
(
Assembler
:
:
Below
tmpReg
ImmPtr
(
&
TypedArrayObject
:
:
classes
[
0
]
)
failures
)
;
masm
.
branchPtr
(
Assembler
:
:
AboveOrEqual
tmpReg
ImmPtr
(
&
TypedArrayObject
:
:
classes
[
Scalar
:
:
MaxTypedArrayViewType
]
)
failures
)
;
masm
.
loadTypedOrValue
(
Address
(
object
TypedArrayObject
:
:
lengthOffset
(
)
)
output
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
static
bool
IsCacheableArrayLength
(
JSContext
*
cx
HandleObject
obj
TypedOrValueRegister
output
)
{
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
)
return
false
;
if
(
output
.
type
(
)
!
=
MIRType_Value
&
&
output
.
type
(
)
!
=
MIRType_Int32
)
{
return
false
;
}
if
(
obj
-
>
as
<
ArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
return
false
;
return
true
;
}
template
<
class
GetPropCache
>
static
GetPropertyIC
:
:
NativeGetPropCacheability
CanAttachNativeGetProp
(
JSContext
*
cx
const
GetPropCache
&
cache
HandleObject
obj
HandleId
id
MutableHandleNativeObject
holder
MutableHandleShape
shape
bool
skipArrayLen
=
false
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
if
(
!
obj
)
return
GetPropertyIC
:
:
CanAttachNone
;
JSObject
*
baseHolder
=
nullptr
;
if
(
!
LookupPropertyPure
(
cx
obj
id
&
baseHolder
shape
.
address
(
)
)
)
return
GetPropertyIC
:
:
CanAttachNone
;
MOZ_ASSERT
(
!
holder
)
;
if
(
baseHolder
)
{
if
(
!
baseHolder
-
>
isNative
(
)
)
return
GetPropertyIC
:
:
CanAttachNone
;
holder
.
set
(
&
baseHolder
-
>
as
<
NativeObject
>
(
)
)
;
}
RootedScript
script
(
cx
)
;
jsbytecode
*
pc
;
cache
.
getScriptedLocation
(
&
script
&
pc
)
;
if
(
IsCacheableGetPropReadSlotForIon
(
obj
holder
shape
)
|
|
IsCacheableNoProperty
(
obj
holder
shape
pc
cache
.
output
(
)
)
)
{
return
GetPropertyIC
:
:
CanAttachReadSlot
;
}
if
(
!
skipArrayLen
&
&
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
&
&
cache
.
allowArrayLength
(
cx
)
&
&
IsCacheableArrayLength
(
cx
obj
cache
.
output
(
)
)
)
{
return
GetPropertyIC
:
:
CanAttachArrayLength
;
}
if
(
cache
.
allowGetters
(
)
&
&
(
IsCacheableGetPropCallNative
(
obj
holder
shape
)
|
|
IsCacheableGetPropCallPropertyOp
(
obj
holder
shape
)
|
|
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
)
)
{
return
GetPropertyIC
:
:
CanAttachCallGetter
;
}
return
GetPropertyIC
:
:
CanAttachNone
;
}
static
bool
EqualStringsHelper
(
JSString
*
str1
JSString
*
str2
)
{
MOZ_ASSERT
(
str1
-
>
isAtom
(
)
)
;
MOZ_ASSERT
(
!
str2
-
>
isAtom
(
)
)
;
MOZ_ASSERT
(
str1
-
>
length
(
)
=
=
str2
-
>
length
(
)
)
;
JSLinearString
*
str2Linear
=
str2
-
>
ensureLinear
(
nullptr
)
;
if
(
!
str2Linear
)
return
false
;
return
EqualChars
(
&
str1
-
>
asLinear
(
)
str2Linear
)
;
}
static
void
EmitIdGuard
(
MacroAssembler
&
masm
jsid
id
TypedOrValueRegister
idReg
Register
objReg
Register
scratchReg
Label
*
failures
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
)
;
MOZ_ASSERT
(
idReg
.
type
(
)
=
=
MIRType_String
|
|
idReg
.
type
(
)
=
=
MIRType_Symbol
|
|
idReg
.
type
(
)
=
=
MIRType_Value
)
;
Register
payloadReg
;
if
(
idReg
.
type
(
)
=
=
MIRType_Value
)
{
ValueOperand
val
=
idReg
.
valueReg
(
)
;
if
(
JSID_IS_SYMBOL
(
id
)
)
{
masm
.
branchTestSymbol
(
Assembler
:
:
NotEqual
val
failures
)
;
}
else
{
MOZ_ASSERT
(
JSID_IS_STRING
(
id
)
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
val
failures
)
;
}
masm
.
unboxNonDouble
(
val
scratchReg
)
;
payloadReg
=
scratchReg
;
}
else
{
payloadReg
=
idReg
.
typedReg
(
)
.
gpr
(
)
;
}
if
(
JSID_IS_SYMBOL
(
id
)
)
{
masm
.
branchPtr
(
Assembler
:
:
NotEqual
payloadReg
ImmGCPtr
(
JSID_TO_SYMBOL
(
id
)
)
failures
)
;
}
else
{
PropertyName
*
name
=
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
;
Label
equal
;
masm
.
branchPtr
(
Assembler
:
:
Equal
payloadReg
ImmGCPtr
(
name
)
&
equal
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
payloadReg
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
ATOM_BIT
)
failures
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
payloadReg
JSString
:
:
offsetOfLength
(
)
)
Imm32
(
name
-
>
length
(
)
)
failures
)
;
LiveRegisterSet
volatileRegs
(
RegisterSet
:
:
Volatile
(
)
)
;
masm
.
PushRegsInMask
(
volatileRegs
)
;
if
(
!
volatileRegs
.
has
(
objReg
)
)
masm
.
push
(
objReg
)
;
masm
.
setupUnalignedABICall
(
objReg
)
;
masm
.
movePtr
(
ImmGCPtr
(
name
)
objReg
)
;
masm
.
passABIArg
(
objReg
)
;
masm
.
passABIArg
(
payloadReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
EqualStringsHelper
)
)
;
masm
.
mov
(
ReturnReg
scratchReg
)
;
if
(
!
volatileRegs
.
has
(
objReg
)
)
masm
.
pop
(
objReg
)
;
LiveRegisterSet
ignore
;
ignore
.
add
(
scratchReg
)
;
masm
.
PopRegsInMaskIgnore
(
volatileRegs
ignore
)
;
masm
.
branchIfFalseBool
(
scratchReg
failures
)
;
masm
.
bind
(
&
equal
)
;
}
}
void
GetPropertyIC
:
:
emitIdGuard
(
MacroAssembler
&
masm
jsid
id
Label
*
fail
)
{
if
(
this
-
>
id
(
)
.
constant
(
)
)
return
;
Register
scratch
=
output
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
EmitIdGuard
(
masm
id
this
-
>
id
(
)
.
reg
(
)
object
(
)
scratch
fail
)
;
}
void
SetPropertyIC
:
:
emitIdGuard
(
MacroAssembler
&
masm
jsid
id
Label
*
fail
)
{
if
(
this
-
>
id
(
)
.
constant
(
)
)
return
;
EmitIdGuard
(
masm
id
this
-
>
id
(
)
.
reg
(
)
object
(
)
temp
(
)
fail
)
;
}
bool
GetPropertyIC
:
:
allowArrayLength
(
JSContext
*
cx
)
const
{
if
(
!
idempotent
(
)
)
return
true
;
uint32_t
locationIndex
numLocations
;
getLocationInfo
(
&
locationIndex
&
numLocations
)
;
IonScript
*
ion
=
GetTopJitJSScript
(
cx
)
-
>
ionScript
(
)
;
CacheLocation
*
locs
=
ion
-
>
getCacheLocs
(
locationIndex
)
;
for
(
size_t
i
=
0
;
i
<
numLocations
;
i
+
+
)
{
CacheLocation
&
curLoc
=
locs
[
i
]
;
StackTypeSet
*
bcTypes
=
TypeScript
:
:
BytecodeTypes
(
curLoc
.
script
curLoc
.
pc
)
;
if
(
!
bcTypes
-
>
hasType
(
TypeSet
:
:
Int32Type
(
)
)
)
return
false
;
}
return
true
;
}
bool
GetPropertyIC
:
:
tryAttachNative
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
outerScript
-
>
ionScript
(
)
=
=
ion
)
;
RootedShape
shape
(
cx
)
;
RootedNativeObject
holder
(
cx
)
;
NativeGetPropCacheability
type
=
CanAttachNativeGetProp
(
cx
*
this
obj
id
&
holder
&
shape
)
;
if
(
type
=
=
CanAttachNone
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
const
char
*
attachKind
;
JS
:
:
TrackedOutcome
outcome
=
JS
:
:
TrackedOutcome
:
:
ICOptStub_GenericSuccess
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
Label
*
maybeFailures
=
failures
.
used
(
)
?
&
failures
:
nullptr
;
switch
(
type
)
{
case
CanAttachReadSlot
:
GenerateReadSlot
(
cx
ion
masm
attacher
DontCheckLexical
obj
holder
shape
object
(
)
output
(
)
maybeFailures
)
;
attachKind
=
idempotent
(
)
?
"
idempotent
reading
"
:
"
non
idempotent
reading
"
;
outcome
=
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_ReadSlot
;
break
;
case
CanAttachCallGetter
:
if
(
!
GenerateCallGetter
(
cx
ion
masm
attacher
obj
holder
shape
liveRegs_
object
(
)
output
(
)
returnAddr
maybeFailures
)
)
{
return
false
;
}
attachKind
=
"
getter
call
"
;
outcome
=
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_CallGetter
;
break
;
case
CanAttachArrayLength
:
if
(
!
GenerateArrayLength
(
cx
masm
attacher
obj
object
(
)
output
(
)
&
failures
)
)
return
false
;
attachKind
=
"
array
length
"
;
outcome
=
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_ArrayLength
;
break
;
default
:
MOZ_CRASH
(
"
Bad
NativeGetPropCacheability
"
)
;
}
return
linkAndAttachStub
(
cx
masm
attacher
ion
attachKind
outcome
)
;
}
bool
GetPropertyIC
:
:
tryAttachUnboxed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
outerScript
-
>
ionScript
(
)
=
=
ion
)
;
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
true
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
!
property
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
Label
*
maybeFailures
=
failures
.
used
(
)
?
&
failures
:
nullptr
;
StubAttacher
attacher
(
*
this
)
;
GenerateReadUnboxed
(
cx
ion
masm
attacher
obj
property
object
(
)
output
(
)
maybeFailures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
read
unboxed
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_UnboxedRead
)
;
}
bool
GetPropertyIC
:
:
tryAttachUnboxedExpando
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
outerScript
-
>
ionScript
(
)
=
=
ion
)
;
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
true
;
Rooted
<
UnboxedExpandoObject
*
>
expando
(
cx
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
;
if
(
!
expando
)
return
true
;
Shape
*
shape
=
expando
-
>
lookup
(
cx
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
Label
*
maybeFailures
=
failures
.
used
(
)
?
&
failures
:
nullptr
;
StubAttacher
attacher
(
*
this
)
;
GenerateReadSlot
(
cx
ion
masm
attacher
DontCheckLexical
obj
obj
shape
object
(
)
output
(
)
maybeFailures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
read
unboxed
expando
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_UnboxedReadExpando
)
;
}
bool
GetPropertyIC
:
:
tryAttachUnboxedArrayLength
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
outerScript
-
>
ionScript
(
)
=
=
ion
)
;
if
(
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
true
;
if
(
!
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
return
true
;
if
(
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
length
(
)
>
INT32_MAX
)
return
true
;
if
(
!
allowArrayLength
(
cx
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
StubAttacher
attacher
(
*
this
)
;
GenerateUnboxedArrayLength
(
cx
masm
attacher
obj
object
(
)
output
(
)
&
failures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
unboxed
array
length
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_UnboxedArrayLength
)
;
}
bool
GetPropertyIC
:
:
tryAttachTypedArrayLength
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
return
true
;
if
(
!
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
return
true
;
if
(
hasTypedArrayLengthStub
(
obj
)
)
return
true
;
if
(
output
(
)
.
type
(
)
!
=
MIRType_Value
&
&
output
(
)
.
type
(
)
!
=
MIRType_Int32
)
{
return
true
;
}
if
(
idempotent
(
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
GenerateTypedArrayLength
(
cx
masm
attacher
object
(
)
output
(
)
&
failures
)
;
setHasTypedArrayLengthStub
(
obj
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
typed
array
length
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_TypedArrayLength
)
;
}
static
void
PushObjectOpResult
(
MacroAssembler
&
masm
)
{
static_assert
(
sizeof
(
ObjectOpResult
)
=
=
sizeof
(
uintptr_t
)
"
ObjectOpResult
size
must
match
size
reserved
by
masm
.
Push
(
)
here
"
)
;
masm
.
Push
(
ImmWord
(
ObjectOpResult
:
:
Uninitialized
)
)
;
}
static
bool
ProxyGetProperty
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
MutableHandleValue
vp
)
{
RootedValue
receiver
(
cx
ObjectValue
(
*
proxy
)
)
;
return
Proxy
:
:
get
(
cx
proxy
receiver
id
vp
)
;
}
static
bool
EmitCallProxyGet
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
jsid
id
LiveRegisterSet
liveRegs
Register
object
TypedOrValueRegister
output
jsbytecode
*
pc
void
*
returnAddr
)
{
MOZ_ASSERT
(
output
.
hasValue
(
)
)
;
MacroAssembler
:
:
AfterICSaveLive
aic
=
masm
.
icSaveLive
(
liveRegs
)
;
AllocatableRegisterSet
regSet
(
RegisterSet
:
:
All
(
)
)
;
regSet
.
take
(
AnyRegister
(
object
)
)
;
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argProxyReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argIdReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argVpReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
scratch
=
regSet
.
takeAnyGeneral
(
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
masm
.
Push
(
UndefinedValue
(
)
)
;
masm
.
moveStackPtrTo
(
argVpReg
)
;
masm
.
Push
(
id
scratch
)
;
masm
.
moveStackPtrTo
(
argIdReg
)
;
masm
.
Push
(
object
)
;
masm
.
moveStackPtrTo
(
argProxyReg
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLProxyExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argProxyReg
)
;
masm
.
passABIArg
(
argIdReg
)
;
masm
.
passABIArg
(
argVpReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
ProxyGetProperty
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
Address
outparam
(
masm
.
getStackPointer
(
)
IonOOLProxyExitFrameLayout
:
:
offsetOfResult
(
)
)
;
masm
.
loadTypedOrValue
(
outparam
output
)
;
masm
.
adjustStack
(
IonOOLProxyExitFrameLayout
:
:
Size
(
)
)
;
masm
.
icRestoreLive
(
liveRegs
aic
)
;
return
true
;
}
bool
GetPropertyIC
:
:
tryAttachDOMProxyShadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
MOZ_ASSERT
(
monitoredResult
(
)
)
;
MOZ_ASSERT
(
output
(
)
.
hasValue
(
)
)
;
if
(
idempotent
(
)
)
return
true
;
*
emitted
=
true
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
obj
-
>
maybeShape
(
)
)
&
failures
)
;
if
(
!
EmitCallProxyGet
(
cx
masm
attacher
id
liveRegs_
object
(
)
output
(
)
pc
(
)
returnAddr
)
)
{
return
false
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
list
base
shadowed
get
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_DOMProxyShadowed
)
;
}
bool
GetPropertyIC
:
:
tryAttachDOMProxyUnshadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
resetNeeded
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
MOZ_ASSERT
(
monitoredResult
(
)
)
;
MOZ_ASSERT
(
output
(
)
.
hasValue
(
)
)
;
RootedObject
checkObj
(
cx
obj
-
>
getTaggedProto
(
)
.
toObjectOrNull
(
)
)
;
RootedNativeObject
holder
(
cx
)
;
RootedShape
shape
(
cx
)
;
NativeGetPropCacheability
canCache
=
CanAttachNativeGetProp
(
cx
*
this
checkObj
id
&
holder
&
shape
true
)
;
MOZ_ASSERT
(
canCache
!
=
CanAttachArrayLength
)
;
if
(
canCache
=
=
CanAttachNone
)
return
true
;
if
(
!
holder
&
&
idempotent
(
)
)
return
true
;
*
emitted
=
true
;
if
(
resetNeeded
)
{
reset
(
Reprotect
)
;
}
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
obj
-
>
maybeShape
(
)
)
&
failures
)
;
CheckDOMProxyExpandoDoesNotShadow
(
cx
masm
obj
id
object
(
)
&
failures
)
;
if
(
holder
)
{
Register
scratchReg
=
output
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
GeneratePrototypeGuards
(
cx
ion
masm
obj
holder
object
(
)
scratchReg
&
failures
)
;
Register
holderReg
=
scratchReg
;
masm
.
movePtr
(
ImmGCPtr
(
holder
)
holderReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
holderReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
holder
-
>
lastProperty
(
)
)
&
failures
)
;
if
(
canCache
=
=
CanAttachReadSlot
)
{
EmitLoadSlot
(
masm
holder
shape
holderReg
output
(
)
scratchReg
)
;
}
else
{
MOZ_ASSERT
(
canCache
=
=
CanAttachCallGetter
)
;
MOZ_ASSERT
(
!
idempotent
(
)
)
;
bool
holderIsReceiver
=
(
obj
=
=
holder
)
;
if
(
!
EmitGetterCall
(
cx
masm
attacher
checkObj
holder
shape
holderIsReceiver
liveRegs_
object
(
)
output
(
)
returnAddr
)
)
{
return
false
;
}
}
}
else
{
MOZ_ASSERT
(
!
idempotent
(
)
)
;
if
(
!
EmitCallProxyGet
(
cx
masm
attacher
id
liveRegs_
object
(
)
output
(
)
pc
(
)
returnAddr
)
)
{
return
false
;
}
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
unshadowed
proxy
get
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_DOMProxyUnshadowed
)
;
}
bool
GetPropertyIC
:
:
tryAttachProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
true
;
if
(
!
monitoredResult
(
)
)
return
true
;
if
(
IsCacheableDOMProxy
(
obj
)
)
{
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
return
false
;
if
(
DOMProxyIsShadowing
(
shadows
)
)
return
tryAttachDOMProxyShadowed
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
;
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
return
tryAttachDOMProxyUnshadowed
(
cx
outerScript
ion
obj
id
shadows
=
=
DoesntShadowUnique
returnAddr
emitted
)
;
}
return
tryAttachGenericProxy
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
;
}
bool
GetPropertyIC
:
:
tryAttachGenericProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
obj
-
>
is
<
ProxyObject
>
(
)
)
;
MOZ_ASSERT
(
monitoredResult
(
)
)
;
MOZ_ASSERT
(
output
(
)
.
hasValue
(
)
)
;
if
(
hasGenericProxyStub
(
)
)
return
true
;
if
(
idempotent
(
)
)
return
true
;
*
emitted
=
true
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
Register
scratchReg
=
output
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
masm
.
branchTestObjectIsProxy
(
false
object
(
)
scratchReg
&
failures
)
;
masm
.
branchTestProxyHandlerFamily
(
Assembler
:
:
Equal
object
(
)
scratchReg
GetDOMProxyHandlerFamily
(
)
&
failures
)
;
if
(
!
EmitCallProxyGet
(
cx
masm
attacher
id
liveRegs_
object
(
)
output
(
)
pc
(
)
returnAddr
)
)
{
return
false
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
MOZ_ASSERT
(
!
hasGenericProxyStub_
)
;
hasGenericProxyStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
Generic
Proxy
get
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_GenericProxy
)
;
}
bool
GetPropertyIC
:
:
tryAttachArgumentsLength
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
)
return
true
;
if
(
!
IsOptimizableArgumentsObjectForLength
(
obj
)
)
return
true
;
MIRType
outputType
=
output
(
)
.
type
(
)
;
if
(
!
(
outputType
=
=
MIRType_Value
|
|
outputType
=
=
MIRType_Int32
)
)
return
true
;
if
(
hasArgumentsLengthStub
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
)
return
true
;
*
emitted
=
true
;
MOZ_ASSERT
(
!
idempotent
(
)
)
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
Register
tmpReg
;
if
(
output
(
)
.
hasValue
(
)
)
{
tmpReg
=
output
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
{
MOZ_ASSERT
(
output
(
)
.
type
(
)
=
=
MIRType_Int32
)
;
tmpReg
=
output
(
)
.
typedReg
(
)
.
gpr
(
)
;
}
MOZ_ASSERT
(
object
(
)
!
=
tmpReg
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
object
(
)
tmpReg
obj
-
>
getClass
(
)
&
failures
)
;
masm
.
unboxInt32
(
Address
(
object
(
)
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
tmpReg
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
tmpReg
Imm32
(
ArgumentsObject
:
:
LENGTH_OVERRIDDEN_BIT
)
&
failures
)
;
masm
.
rshiftPtr
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
tmpReg
)
;
if
(
output
(
)
.
hasValue
(
)
)
masm
.
tagValue
(
JSVAL_TYPE_INT32
tmpReg
output
(
)
.
valueReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
if
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
{
MOZ_ASSERT
(
!
hasUnmappedArgumentsLengthStub_
)
;
hasUnmappedArgumentsLengthStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
ArgsObj
length
(
unmapped
)
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_ArgumentsLength
)
;
}
MOZ_ASSERT
(
!
hasMappedArgumentsLengthStub_
)
;
hasMappedArgumentsLengthStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
ArgsObj
length
(
mapped
)
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_ArgumentsLength
)
;
}
static
void
GenerateReadModuleNamespace
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
ModuleNamespaceObject
*
ns
ModuleEnvironmentObject
*
env
Shape
*
shape
Register
object
TypedOrValueRegister
output
Label
*
failures
)
{
MOZ_ASSERT
(
ns
)
;
MOZ_ASSERT
(
env
)
;
Label
failures_
;
if
(
!
failures
)
failures
=
&
failures_
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
object
ImmGCPtr
(
ns
)
failures
)
;
bool
restoreScratch
=
false
;
Register
scratchReg
=
InvalidReg
;
if
(
output
.
hasValue
(
)
)
{
scratchReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
}
else
if
(
output
.
type
(
)
=
=
MIRType_Double
)
{
masm
.
push
(
object
)
;
scratchReg
=
object
;
restoreScratch
=
true
;
}
else
{
scratchReg
=
output
.
typedReg
(
)
.
gpr
(
)
;
}
Register
envReg
=
scratchReg
;
masm
.
movePtr
(
ImmGCPtr
(
env
)
envReg
)
;
EmitLoadSlot
(
masm
&
env
-
>
as
<
NativeObject
>
(
)
shape
envReg
output
scratchReg
)
;
if
(
restoreScratch
)
masm
.
pop
(
object
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
bool
GetPropertyIC
:
:
tryAttachModuleNamespace
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
outerScript
-
>
ionScript
(
)
=
=
ion
)
;
if
(
!
obj
-
>
is
<
ModuleNamespaceObject
>
(
)
)
return
true
;
Rooted
<
ModuleNamespaceObject
*
>
ns
(
cx
&
obj
-
>
as
<
ModuleNamespaceObject
>
(
)
)
;
RootedModuleEnvironmentObject
env
(
cx
)
;
RootedShape
shape
(
cx
)
;
if
(
!
ns
-
>
bindings
(
)
.
lookup
(
id
env
.
address
(
)
shape
.
address
(
)
)
)
return
true
;
if
(
env
-
>
getSlot
(
shape
-
>
slot
(
)
)
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
Label
*
maybeFailures
=
failures
.
used
(
)
?
&
failures
:
nullptr
;
GenerateReadModuleNamespace
(
cx
ion
masm
attacher
ns
env
shape
object
(
)
output
(
)
maybeFailures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
module
namespace
"
JS
:
:
TrackedOutcome
:
:
ICGetPropStub_ReadSlot
)
;
}
static
bool
ValueToNameOrSymbolId
(
JSContext
*
cx
HandleValue
idval
MutableHandleId
id
bool
*
nameOrSymbol
)
{
*
nameOrSymbol
=
false
;
if
(
!
idval
.
isString
(
)
&
&
!
idval
.
isSymbol
(
)
)
return
true
;
if
(
!
ValueToId
<
CanGC
>
(
cx
idval
id
)
)
return
false
;
if
(
!
JSID_IS_STRING
(
id
)
&
&
!
JSID_IS_SYMBOL
(
id
)
)
{
id
.
set
(
JSID_VOID
)
;
return
true
;
}
uint32_t
dummy
;
if
(
JSID_IS_STRING
(
id
)
&
&
JSID_TO_ATOM
(
id
)
-
>
isIndex
(
&
dummy
)
)
{
id
.
set
(
JSID_VOID
)
;
return
true
;
}
*
nameOrSymbol
=
true
;
return
true
;
}
bool
GetPropertyIC
:
:
tryAttachStub
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
canAttachStub
(
)
)
return
true
;
RootedId
id
(
cx
)
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx
idval
&
id
&
nameOrSymbol
)
)
return
false
;
if
(
nameOrSymbol
)
{
if
(
!
*
emitted
&
&
!
tryAttachArgumentsLength
(
cx
outerScript
ion
obj
id
emitted
)
)
return
false
;
void
*
returnAddr
=
GetReturnAddressToIonCode
(
cx
)
;
if
(
!
*
emitted
&
&
!
tryAttachModuleNamespace
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachProxy
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachNative
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachUnboxed
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachUnboxedExpando
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachUnboxedArrayLength
(
cx
outerScript
ion
obj
id
returnAddr
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachTypedArrayLength
(
cx
outerScript
ion
obj
id
emitted
)
)
return
false
;
}
if
(
idval
.
isInt32
(
)
)
{
if
(
!
*
emitted
&
&
!
tryAttachArgumentsElement
(
cx
outerScript
ion
obj
idval
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachDenseElement
(
cx
outerScript
ion
obj
idval
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachDenseElementHole
(
cx
outerScript
ion
obj
idval
emitted
)
)
return
false
;
}
if
(
idval
.
isInt32
(
)
|
|
idval
.
isString
(
)
)
{
if
(
!
*
emitted
&
&
!
tryAttachTypedOrUnboxedArrayElement
(
cx
outerScript
ion
obj
idval
emitted
)
)
return
false
;
}
if
(
!
*
emitted
)
JitSpew
(
JitSpew_IonIC
"
Failed
to
attach
GETPROP
cache
"
)
;
return
true
;
}
bool
GetPropertyIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
obj
HandleValue
idval
MutableHandleValue
vp
)
{
IonScript
*
ion
=
outerScript
-
>
ionScript
(
)
;
GetPropertyIC
&
cache
=
ion
-
>
getCache
(
cacheIndex
)
.
toGetProperty
(
)
;
AutoDetectInvalidation
adi
(
cx
vp
ion
)
;
if
(
cache
.
idempotent
(
)
)
adi
.
disable
(
)
;
bool
emitted
=
false
;
if
(
!
cache
.
isDisabled
(
)
)
{
if
(
!
cache
.
tryAttachStub
(
cx
outerScript
ion
obj
idval
&
emitted
)
)
return
false
;
cache
.
maybeDisable
(
emitted
)
;
}
if
(
cache
.
idempotent
(
)
&
&
!
emitted
)
{
JitSpew
(
JitSpew_IonIC
"
Invalidating
from
idempotent
cache
%
s
:
%
"
PRIuSIZE
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
)
;
outerScript
-
>
setInvalidatedIdempotentCache
(
)
;
if
(
!
outerScript
-
>
hasIonScript
(
)
)
return
true
;
return
Invalidate
(
cx
outerScript
)
;
}
jsbytecode
*
pc
=
cache
.
idempotent
(
)
?
nullptr
:
cache
.
pc
(
)
;
if
(
!
pc
|
|
*
pc
=
=
JSOP_GETPROP
|
|
*
pc
=
=
JSOP_CALLPROP
|
|
*
pc
=
=
JSOP_LENGTH
)
{
if
(
!
GetProperty
(
cx
obj
obj
idval
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
vp
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
*
pc
=
=
JSOP_GETELEM
|
|
*
pc
=
=
JSOP_CALLELEM
)
;
if
(
!
GetObjectElementOperation
(
cx
JSOp
(
*
pc
)
obj
obj
idval
vp
)
)
return
false
;
}
if
(
!
cache
.
idempotent
(
)
)
{
RootedScript
script
(
cx
)
;
jsbytecode
*
pc
;
cache
.
getScriptedLocation
(
&
script
&
pc
)
;
if
(
!
cache
.
monitoredResult
(
)
)
TypeScript
:
:
Monitor
(
cx
script
pc
vp
)
;
}
return
true
;
}
void
GetPropertyIC
:
:
reset
(
ReprotectCode
reprotect
)
{
IonCache
:
:
reset
(
reprotect
)
;
hasTypedArrayLengthStub_
=
false
;
hasMappedArgumentsLengthStub_
=
false
;
hasUnmappedArgumentsLengthStub_
=
false
;
hasMappedArgumentsElementStub_
=
false
;
hasUnmappedArgumentsElementStub_
=
false
;
hasGenericProxyStub_
=
false
;
hasDenseStub_
=
false
;
}
void
IonCache
:
:
disable
(
)
{
reset
(
Reprotect
)
;
this
-
>
disabled_
=
1
;
}
void
GetPropertyIC
:
:
maybeDisable
(
bool
emitted
)
{
if
(
emitted
)
{
failedUpdates_
=
0
;
return
;
}
if
(
!
canAttachStub
(
)
&
&
id
(
)
.
constant
(
)
)
{
return
;
}
if
(
+
+
failedUpdates_
>
MAX_FAILED_UPDATES
)
{
JitSpew
(
JitSpew_IonIC
"
Disable
inline
cache
"
)
;
disable
(
)
;
}
}
void
IonCache
:
:
reset
(
ReprotectCode
reprotect
)
{
this
-
>
stubCount_
=
0
;
PatchJump
(
initialJump_
fallbackLabel_
reprotect
)
;
lastJump_
=
initialJump_
;
}
static
void
CheckTypeSetForWrite
(
MacroAssembler
&
masm
JSObject
*
obj
jsid
id
Register
scratch
ConstantOrRegister
value
Label
*
failure
)
{
TypedOrValueRegister
valReg
=
value
.
reg
(
)
;
ObjectGroup
*
group
=
obj
-
>
group
(
)
;
MOZ_ASSERT
(
!
group
-
>
unknownProperties
(
)
)
;
HeapTypeSet
*
propTypes
=
group
-
>
maybeGetProperty
(
id
)
;
MOZ_ASSERT
(
propTypes
)
;
TypeSet
:
:
readBarrier
(
propTypes
)
;
masm
.
guardTypeSet
(
valReg
propTypes
BarrierKind
:
:
TypeSet
scratch
failure
)
;
}
static
void
GenerateSetSlot
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
Shape
*
shape
Register
object
Register
tempReg
ConstantOrRegister
value
bool
needsTypeBarrier
bool
checkTypeset
Label
*
failures
)
{
TestMatchingReceiver
(
masm
attacher
object
obj
failures
needsTypeBarrier
)
;
if
(
checkTypeset
)
{
MOZ_ASSERT
(
needsTypeBarrier
)
;
CheckTypeSetForWrite
(
masm
obj
shape
-
>
propid
(
)
tempReg
value
failures
)
;
}
NativeObject
:
:
slotsSizeMustNotOverflow
(
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
obj
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
masm
.
loadPtr
(
Address
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
tempReg
)
;
object
=
tempReg
;
}
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
isFixedSlot
(
shape
-
>
slot
(
)
)
)
{
Address
addr
(
object
NativeObject
:
:
getFixedSlotOffset
(
shape
-
>
slot
(
)
)
)
;
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
masm
.
callPreBarrier
(
addr
MIRType_Value
)
;
masm
.
storeConstantOrRegister
(
value
addr
)
;
}
else
{
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfSlots
(
)
)
tempReg
)
;
Address
addr
(
tempReg
obj
-
>
as
<
NativeObject
>
(
)
.
dynamicSlotIndex
(
shape
-
>
slot
(
)
)
*
sizeof
(
Value
)
)
;
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
masm
.
callPreBarrier
(
addr
MIRType_Value
)
;
masm
.
storeConstantOrRegister
(
value
addr
)
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
bool
SetPropertyIC
:
:
attachSetSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleShape
shape
bool
checkTypeset
)
{
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
shape
-
>
propid
(
)
&
failures
)
;
GenerateSetSlot
(
cx
masm
attacher
obj
shape
object
(
)
temp
(
)
value
(
)
needsTypeBarrier
(
)
checkTypeset
&
failures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
setting
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_Slot
)
;
}
static
bool
IsCacheableSetPropCallNative
(
HandleObject
obj
HandleObject
holder
HandleShape
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
return
shape
-
>
hasSetterValue
(
)
&
&
shape
-
>
setterObject
(
)
&
&
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
&
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
.
isNative
(
)
;
}
static
bool
IsCacheableSetPropCallScripted
(
HandleObject
obj
HandleObject
holder
HandleShape
shape
)
{
if
(
!
shape
|
|
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
return
shape
-
>
hasSetterValue
(
)
&
&
shape
-
>
setterObject
(
)
&
&
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
&
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
.
hasJITCode
(
)
;
}
static
bool
IsCacheableSetPropCallPropertyOp
(
HandleObject
obj
HandleObject
holder
HandleShape
shape
)
{
if
(
!
shape
)
return
false
;
if
(
!
IsCacheableProtoChainForIon
(
obj
holder
)
)
return
false
;
if
(
shape
-
>
hasSlot
(
)
)
return
false
;
if
(
shape
-
>
hasDefaultSetter
(
)
)
return
false
;
if
(
shape
-
>
hasSetterValue
(
)
)
return
false
;
if
(
!
shape
-
>
writable
(
)
)
return
false
;
return
true
;
}
static
bool
ReportStrictErrorOrWarning
(
JSContext
*
cx
JS
:
:
HandleObject
obj
JS
:
:
HandleId
id
bool
strict
JS
:
:
ObjectOpResult
&
result
)
{
return
result
.
reportStrictErrorOrWarning
(
cx
obj
id
strict
)
;
}
template
<
class
FrameLayout
>
void
EmitObjectOpResultCheck
(
MacroAssembler
&
masm
Label
*
failure
bool
strict
Register
scratchReg
Register
argJSContextReg
Register
argObjReg
Register
argIdReg
Register
argStrictReg
Register
argResultReg
)
{
Label
noStrictError
;
masm
.
branch32
(
Assembler
:
:
Equal
Address
(
masm
.
getStackPointer
(
)
FrameLayout
:
:
offsetOfObjectOpResult
(
)
)
Imm32
(
ObjectOpResult
:
:
OkCode
)
&
noStrictError
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
FrameLayout
:
:
offsetOfObject
(
)
)
argObjReg
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
FrameLayout
:
:
offsetOfId
(
)
)
argIdReg
)
;
masm
.
move32
(
Imm32
(
strict
)
argStrictReg
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
FrameLayout
:
:
offsetOfObjectOpResult
(
)
)
argResultReg
)
;
masm
.
setupUnalignedABICall
(
scratchReg
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argObjReg
)
;
masm
.
passABIArg
(
argIdReg
)
;
masm
.
passABIArg
(
argStrictReg
)
;
masm
.
passABIArg
(
argResultReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
ReportStrictErrorOrWarning
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
failure
)
;
masm
.
bind
(
&
noStrictError
)
;
}
static
bool
ProxySetProperty
(
JSContext
*
cx
HandleObject
proxy
HandleId
id
HandleValue
v
bool
strict
)
{
RootedValue
receiver
(
cx
ObjectValue
(
*
proxy
)
)
;
ObjectOpResult
result
;
return
Proxy
:
:
set
(
cx
proxy
id
v
receiver
result
)
&
&
result
.
checkStrictErrorOrWarning
(
cx
proxy
id
strict
)
;
}
static
bool
EmitCallProxySet
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
HandleId
propId
LiveRegisterSet
liveRegs
Register
object
ConstantOrRegister
value
void
*
returnAddr
bool
strict
)
{
MacroAssembler
:
:
AfterICSaveLive
aic
=
masm
.
icSaveLive
(
liveRegs
)
;
AllocatableRegisterSet
regSet
(
RegisterSet
:
:
All
(
)
)
;
regSet
.
take
(
AnyRegister
(
object
)
)
;
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argProxyReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argIdReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argValueReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argStrictReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
scratch
=
regSet
.
takeAnyGeneral
(
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
masm
.
Push
(
value
)
;
masm
.
moveStackPtrTo
(
argValueReg
)
;
masm
.
move32
(
Imm32
(
strict
)
argStrictReg
)
;
masm
.
Push
(
propId
scratch
)
;
masm
.
moveStackPtrTo
(
argIdReg
)
;
masm
.
Push
(
object
)
;
masm
.
moveStackPtrTo
(
argProxyReg
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLProxyExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argProxyReg
)
;
masm
.
passABIArg
(
argIdReg
)
;
masm
.
passABIArg
(
argValueReg
)
;
masm
.
passABIArg
(
argStrictReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
ProxySetProperty
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
adjustStack
(
IonOOLProxyExitFrameLayout
:
:
Size
(
)
)
;
masm
.
icRestoreLive
(
liveRegs
aic
)
;
return
true
;
}
bool
SetPropertyIC
:
:
attachGenericProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleId
id
void
*
returnAddr
)
{
MOZ_ASSERT
(
!
hasGenericProxyStub
(
)
)
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
{
masm
.
branchTestObjectIsProxy
(
false
object
(
)
temp
(
)
&
failures
)
;
masm
.
branchTestProxyHandlerFamily
(
Assembler
:
:
Equal
object
(
)
temp
(
)
GetDOMProxyHandlerFamily
(
)
&
failures
)
;
}
if
(
!
EmitCallProxySet
(
cx
masm
attacher
id
liveRegs_
object
(
)
value
(
)
returnAddr
strict
(
)
)
)
{
return
false
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
MOZ_ASSERT
(
!
hasGenericProxyStub_
)
;
hasGenericProxyStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
generic
proxy
set
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_GenericProxy
)
;
}
bool
SetPropertyIC
:
:
attachDOMProxyShadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
obj
-
>
maybeShape
(
)
)
&
failures
)
;
if
(
!
EmitCallProxySet
(
cx
masm
attacher
id
liveRegs_
object
(
)
value
(
)
returnAddr
strict
(
)
)
)
{
return
false
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
DOM
proxy
shadowed
set
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_DOMProxyShadowed
)
;
}
static
bool
GenerateCallSetter
(
JSContext
*
cx
IonScript
*
ion
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
HandleObject
obj
HandleObject
holder
HandleShape
shape
bool
strict
Register
object
Register
tempReg
ConstantOrRegister
value
Label
*
failure
LiveRegisterSet
liveRegs
void
*
returnAddr
)
{
{
if
(
obj
!
=
holder
)
GeneratePrototypeGuards
(
cx
ion
masm
obj
holder
object
tempReg
failure
)
;
masm
.
movePtr
(
ImmGCPtr
(
holder
)
tempReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
tempReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
failure
)
;
}
MacroAssembler
:
:
AfterICSaveLive
aic
=
masm
.
icSaveLive
(
liveRegs
)
;
AllocatableRegisterSet
regSet
(
RegisterSet
:
:
All
(
)
)
;
if
(
!
value
.
constant
(
)
)
regSet
.
take
(
value
.
reg
(
)
)
;
bool
valueAliasesObject
=
!
regSet
.
has
(
object
)
;
if
(
!
valueAliasesObject
)
regSet
.
take
(
object
)
;
regSet
.
take
(
tempReg
)
;
if
(
IsCacheableSetPropCallNative
(
obj
holder
shape
)
)
{
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argVpReg
=
regSet
.
takeAnyGeneral
(
)
;
MOZ_ASSERT
(
shape
-
>
hasSetterValue
(
)
&
&
shape
-
>
setterObject
(
)
&
&
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
)
;
JSFunction
*
target
=
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
target
-
>
isNative
(
)
)
;
Register
argUintNReg
=
regSet
.
takeAnyGeneral
(
)
;
masm
.
Push
(
value
)
;
masm
.
Push
(
TypedOrValueRegister
(
MIRType_Object
AnyRegister
(
object
)
)
)
;
masm
.
Push
(
ObjectValue
(
*
target
)
)
;
masm
.
moveStackPtrTo
(
argVpReg
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
masm
.
move32
(
Imm32
(
1
)
argUintNReg
)
;
masm
.
Push
(
argUintNReg
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLNativeExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
tempReg
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argUintNReg
)
;
masm
.
passABIArg
(
argVpReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
target
-
>
native
(
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
adjustStack
(
IonOOLNativeExitFrameLayout
:
:
Size
(
1
)
)
;
}
else
if
(
IsCacheableSetPropCallPropertyOp
(
obj
holder
shape
)
)
{
Register
argResultReg
=
regSet
.
takeAnyGeneral
(
)
;
SetterOp
target
=
shape
-
>
setterOp
(
)
;
MOZ_ASSERT
(
target
)
;
PushObjectOpResult
(
masm
)
;
masm
.
moveStackPtrTo
(
argResultReg
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
if
(
value
.
constant
(
)
)
{
masm
.
Push
(
value
.
value
(
)
)
;
}
else
{
masm
.
Push
(
value
.
reg
(
)
)
;
if
(
!
valueAliasesObject
)
regSet
.
add
(
value
.
reg
(
)
)
;
}
Register
argJSContextReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argValueReg
=
regSet
.
takeAnyGeneral
(
)
;
Register
argObjReg
=
object
;
Register
argIdReg
=
regSet
.
takeAnyGeneral
(
)
;
masm
.
moveStackPtrTo
(
argValueReg
)
;
masm
.
Push
(
shape
-
>
propid
(
)
argIdReg
)
;
masm
.
moveStackPtrTo
(
argIdReg
)
;
masm
.
Push
(
object
)
;
masm
.
moveStackPtrTo
(
argObjReg
)
;
masm
.
loadJSContext
(
argJSContextReg
)
;
if
(
!
masm
.
icBuildOOLFakeExitFrame
(
returnAddr
aic
)
)
return
false
;
masm
.
enterFakeExitFrame
(
IonOOLSetterOpExitFrameLayoutToken
)
;
masm
.
setupUnalignedABICall
(
tempReg
)
;
masm
.
passABIArg
(
argJSContextReg
)
;
masm
.
passABIArg
(
argObjReg
)
;
masm
.
passABIArg
(
argIdReg
)
;
masm
.
passABIArg
(
argValueReg
)
;
masm
.
passABIArg
(
argResultReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
target
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
EmitObjectOpResultCheck
<
IonOOLSetterOpExitFrameLayout
>
(
masm
masm
.
exceptionLabel
(
)
strict
tempReg
argJSContextReg
argObjReg
argIdReg
argValueReg
argResultReg
)
;
masm
.
adjustStack
(
IonOOLSetterOpExitFrameLayout
:
:
Size
(
)
)
;
}
else
{
MOZ_ASSERT
(
IsCacheableSetPropCallScripted
(
obj
holder
shape
)
)
;
JSFunction
*
target
=
&
shape
-
>
setterValue
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
uint32_t
framePushedBefore
=
masm
.
framePushed
(
)
;
uint32_t
descriptor
=
MakeFrameDescriptor
(
masm
.
framePushed
(
)
JitFrame_IonJS
)
;
attacher
.
pushStubCodePointer
(
masm
)
;
masm
.
Push
(
Imm32
(
descriptor
)
)
;
masm
.
Push
(
ImmPtr
(
returnAddr
)
)
;
uint32_t
numArgs
=
Max
(
size_t
(
1
)
target
-
>
nargs
(
)
)
;
uint32_t
argSize
=
(
numArgs
+
1
)
*
sizeof
(
Value
)
;
uint32_t
padding
=
ComputeByteAlignment
(
masm
.
framePushed
(
)
+
argSize
JitStackAlignment
)
;
MOZ_ASSERT
(
padding
%
sizeof
(
uintptr_t
)
=
=
0
)
;
MOZ_ASSERT
(
padding
<
JitStackAlignment
)
;
masm
.
reserveStack
(
padding
)
;
for
(
size_t
i
=
1
;
i
<
target
-
>
nargs
(
)
;
i
+
+
)
masm
.
Push
(
UndefinedValue
(
)
)
;
masm
.
Push
(
value
)
;
masm
.
Push
(
TypedOrValueRegister
(
MIRType_Object
AnyRegister
(
object
)
)
)
;
masm
.
movePtr
(
ImmGCPtr
(
target
)
tempReg
)
;
descriptor
=
MakeFrameDescriptor
(
argSize
+
padding
JitFrame_IonAccessorIC
)
;
masm
.
Push
(
Imm32
(
1
)
)
;
masm
.
Push
(
tempReg
)
;
masm
.
Push
(
Imm32
(
descriptor
)
)
;
MOZ_ASSERT
(
(
(
masm
.
framePushed
(
)
+
sizeof
(
uintptr_t
)
)
%
JitStackAlignment
)
=
=
0
)
;
MOZ_ASSERT
(
target
-
>
hasJITCode
(
)
)
;
masm
.
loadPtr
(
Address
(
tempReg
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
tempReg
)
;
masm
.
loadBaselineOrIonRaw
(
tempReg
tempReg
nullptr
)
;
masm
.
callJit
(
tempReg
)
;
masm
.
freeStack
(
masm
.
framePushed
(
)
-
framePushedBefore
)
;
}
masm
.
icRestoreLive
(
liveRegs
aic
)
;
return
true
;
}
static
bool
IsCacheableDOMProxyUnshadowedSetterCall
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
holder
MutableHandleShape
shape
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
RootedObject
checkObj
(
cx
obj
-
>
getTaggedProto
(
)
.
toObjectOrNull
(
)
)
;
if
(
!
checkObj
)
return
false
;
if
(
!
LookupPropertyPure
(
cx
obj
id
holder
.
address
(
)
shape
.
address
(
)
)
)
return
false
;
if
(
!
holder
)
return
false
;
return
IsCacheableSetPropCallNative
(
checkObj
holder
shape
)
|
|
IsCacheableSetPropCallPropertyOp
(
checkObj
holder
shape
)
|
|
IsCacheableSetPropCallScripted
(
checkObj
holder
shape
)
;
}
bool
SetPropertyIC
:
:
attachDOMProxyUnshadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
)
{
MOZ_ASSERT
(
IsCacheableDOMProxy
(
obj
)
)
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
emitIdGuard
(
masm
id
&
failures
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
obj
-
>
maybeShape
(
)
)
&
failures
)
;
CheckDOMProxyExpandoDoesNotShadow
(
cx
masm
obj
id
object
(
)
&
failures
)
;
RootedObject
holder
(
cx
)
;
RootedShape
shape
(
cx
)
;
if
(
IsCacheableDOMProxyUnshadowedSetterCall
(
cx
obj
id
&
holder
&
shape
)
)
{
if
(
!
GenerateCallSetter
(
cx
ion
masm
attacher
obj
holder
shape
strict
(
)
object
(
)
temp
(
)
value
(
)
&
failures
liveRegs_
returnAddr
)
)
{
return
false
;
}
}
else
{
if
(
!
EmitCallProxySet
(
cx
masm
attacher
id
liveRegs_
object
(
)
value
(
)
returnAddr
strict
(
)
)
)
{
return
false
;
}
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
DOM
proxy
unshadowed
set
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_DOMProxyUnshadowed
)
;
}
bool
SetPropertyIC
:
:
attachCallSetter
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleObject
holder
HandleShape
shape
void
*
returnAddr
)
{
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failure
;
emitIdGuard
(
masm
shape
-
>
propid
(
)
&
failure
)
;
TestMatchingReceiver
(
masm
attacher
object
(
)
obj
&
failure
)
;
if
(
!
GenerateCallSetter
(
cx
ion
masm
attacher
obj
holder
shape
strict
(
)
object
(
)
temp
(
)
value
(
)
&
failure
liveRegs_
returnAddr
)
)
{
return
false
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failure
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
setter
call
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_CallSetter
)
;
}
static
void
GenerateAddSlot
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
Shape
*
oldShape
ObjectGroup
*
oldGroup
Register
object
Register
tempReg
ConstantOrRegister
value
bool
checkTypeset
Label
*
failures
)
{
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
object
oldGroup
failures
)
;
if
(
obj
-
>
maybeShape
(
)
)
{
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
oldShape
failures
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
;
Address
expandoAddress
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
expandoAddress
ImmWord
(
0
)
failures
)
;
masm
.
loadPtr
(
expandoAddress
tempReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
tempReg
oldShape
failures
)
;
}
Shape
*
newShape
=
obj
-
>
maybeShape
(
)
;
if
(
!
newShape
)
newShape
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
-
>
lastProperty
(
)
;
if
(
checkTypeset
)
CheckTypeSetForWrite
(
masm
obj
newShape
-
>
propid
(
)
tempReg
value
failures
)
;
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
Register
protoReg
=
tempReg
;
bool
first
=
true
;
while
(
proto
)
{
Shape
*
protoShape
=
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
;
masm
.
loadObjProto
(
first
?
object
:
protoReg
protoReg
)
;
first
=
false
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
protoShape
failures
)
;
proto
=
proto
-
>
getProto
(
)
;
}
uint32_t
newNumDynamicSlots
=
obj
-
>
is
<
UnboxedPlainObject
>
(
)
?
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
-
>
numDynamicSlots
(
)
:
obj
-
>
as
<
NativeObject
>
(
)
.
numDynamicSlots
(
)
;
if
(
NativeObject
:
:
dynamicSlotsCount
(
oldShape
)
!
=
newNumDynamicSlots
)
{
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
masm
.
PushRegsInMask
(
save
)
;
regs
.
takeUnchecked
(
object
)
;
Register
temp1
=
regs
.
takeAnyGeneral
(
)
;
Register
temp2
=
regs
.
takeAnyGeneral
(
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
masm
.
Push
(
object
)
;
masm
.
loadPtr
(
Address
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
object
)
;
}
masm
.
setupUnalignedABICall
(
temp1
)
;
masm
.
loadJSContext
(
temp1
)
;
masm
.
passABIArg
(
temp1
)
;
masm
.
passABIArg
(
object
)
;
masm
.
move32
(
Imm32
(
newNumDynamicSlots
)
temp2
)
;
masm
.
passABIArg
(
temp2
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
NativeObject
:
:
growSlotsDontReportOOM
)
)
;
uint32_t
framePushedAfterCall
=
masm
.
framePushed
(
)
;
Label
allocFailed
allocDone
;
masm
.
branchIfFalseBool
(
ReturnReg
&
allocFailed
)
;
masm
.
jump
(
&
allocDone
)
;
masm
.
bind
(
&
allocFailed
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
masm
.
Pop
(
object
)
;
masm
.
PopRegsInMask
(
save
)
;
masm
.
jump
(
failures
)
;
masm
.
bind
(
&
allocDone
)
;
masm
.
setFramePushed
(
framePushedAfterCall
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
masm
.
Pop
(
object
)
;
masm
.
PopRegsInMask
(
save
)
;
}
bool
popObject
=
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
masm
.
push
(
object
)
;
popObject
=
true
;
obj
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
masm
.
loadPtr
(
Address
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
object
)
;
}
Address
shapeAddr
(
object
JSObject
:
:
offsetOfShape
(
)
)
;
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
masm
.
callPreBarrier
(
shapeAddr
MIRType_Shape
)
;
masm
.
storePtr
(
ImmGCPtr
(
newShape
)
shapeAddr
)
;
if
(
oldGroup
!
=
obj
-
>
group
(
)
)
{
MOZ_ASSERT
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
;
Label
noTypeChange
skipPop
;
masm
.
loadPtr
(
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
tempReg
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
Address
(
tempReg
ObjectGroup
:
:
offsetOfAddendum
(
)
)
ImmWord
(
0
)
&
noTypeChange
)
;
Address
groupAddr
(
object
JSObject
:
:
offsetOfGroup
(
)
)
;
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
masm
.
callPreBarrier
(
groupAddr
MIRType_ObjectGroup
)
;
masm
.
storePtr
(
ImmGCPtr
(
obj
-
>
group
(
)
)
groupAddr
)
;
masm
.
bind
(
&
noTypeChange
)
;
}
NativeObject
:
:
slotsSizeMustNotOverflow
(
)
;
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
isFixedSlot
(
newShape
-
>
slot
(
)
)
)
{
Address
addr
(
object
NativeObject
:
:
getFixedSlotOffset
(
newShape
-
>
slot
(
)
)
)
;
masm
.
storeConstantOrRegister
(
value
addr
)
;
}
else
{
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfSlots
(
)
)
tempReg
)
;
Address
addr
(
tempReg
obj
-
>
as
<
NativeObject
>
(
)
.
dynamicSlotIndex
(
newShape
-
>
slot
(
)
)
*
sizeof
(
Value
)
)
;
masm
.
storeConstantOrRegister
(
value
addr
)
;
}
if
(
popObject
)
masm
.
pop
(
object
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
bool
SetPropertyIC
:
:
attachAddSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
HandleShape
oldShape
HandleObjectGroup
oldGroup
bool
checkTypeset
)
{
MOZ_ASSERT_IF
(
!
needsTypeBarrier
(
)
!
checkTypeset
)
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
GenerateAddSlot
(
cx
masm
attacher
obj
oldShape
oldGroup
object
(
)
temp
(
)
value
(
)
checkTypeset
&
failures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
adding
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_AddSlot
)
;
}
static
bool
CanInlineSetPropTypeCheck
(
JSObject
*
obj
jsid
id
ConstantOrRegister
val
bool
*
checkTypeset
)
{
bool
shouldCheck
=
false
;
ObjectGroup
*
group
=
obj
-
>
group
(
)
;
if
(
!
group
-
>
unknownProperties
(
)
)
{
HeapTypeSet
*
propTypes
=
group
-
>
maybeGetProperty
(
id
)
;
if
(
!
propTypes
)
return
false
;
if
(
!
propTypes
-
>
unknown
(
)
)
{
if
(
obj
-
>
isSingleton
(
)
&
&
!
propTypes
-
>
nonConstantProperty
(
)
)
return
false
;
shouldCheck
=
true
;
if
(
val
.
constant
(
)
)
{
if
(
!
propTypes
-
>
hasType
(
TypeSet
:
:
GetValueType
(
val
.
value
(
)
)
)
)
return
false
;
shouldCheck
=
false
;
}
else
{
TypedOrValueRegister
reg
=
val
.
reg
(
)
;
if
(
reg
.
hasTyped
(
)
&
&
reg
.
type
(
)
!
=
MIRType_Object
)
{
JSValueType
valType
=
ValueTypeFromMIRType
(
reg
.
type
(
)
)
;
if
(
!
propTypes
-
>
hasType
(
TypeSet
:
:
PrimitiveType
(
valType
)
)
)
return
false
;
shouldCheck
=
false
;
}
}
}
}
*
checkTypeset
=
shouldCheck
;
return
true
;
}
static
bool
IsPropertySetInlineable
(
NativeObject
*
obj
HandleId
id
MutableHandleShape
pshape
ConstantOrRegister
val
bool
needsTypeBarrier
bool
*
checkTypeset
)
{
MOZ_ASSERT
(
!
obj
-
>
hasLazyGroup
(
)
)
;
pshape
.
set
(
obj
-
>
lookupPure
(
id
)
)
;
if
(
!
pshape
)
return
false
;
if
(
!
pshape
-
>
hasSlot
(
)
)
return
false
;
if
(
!
pshape
-
>
hasDefaultSetter
(
)
)
return
false
;
if
(
!
pshape
-
>
writable
(
)
)
return
false
;
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
id
val
checkTypeset
)
)
return
false
;
return
true
;
}
static
bool
PrototypeChainShadowsPropertyAdd
(
JSContext
*
cx
JSObject
*
obj
jsid
id
)
{
for
(
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
proto
;
proto
=
proto
-
>
getProto
(
)
)
{
if
(
!
proto
-
>
isNative
(
)
)
return
true
;
Shape
*
protoShape
=
proto
-
>
as
<
NativeObject
>
(
)
.
lookupPure
(
id
)
;
if
(
protoShape
&
&
!
protoShape
-
>
hasDefaultSetter
(
)
)
return
true
;
if
(
ClassMayResolveId
(
cx
-
>
names
(
)
proto
-
>
getClass
(
)
id
proto
)
)
return
true
;
}
return
false
;
}
static
bool
IsPropertyAddInlineable
(
JSContext
*
cx
NativeObject
*
obj
HandleId
id
ConstantOrRegister
val
HandleShape
oldShape
bool
needsTypeBarrier
bool
*
checkTypeset
)
{
if
(
obj
-
>
lastProperty
(
)
=
=
oldShape
)
return
false
;
Shape
*
shape
=
obj
-
>
lookupPure
(
id
)
;
if
(
!
shape
|
|
shape
-
>
inDictionary
(
)
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultSetter
(
)
)
return
false
;
MOZ_ASSERT
(
shape
=
=
obj
-
>
lastProperty
(
)
)
;
if
(
ClassMayResolveId
(
cx
-
>
names
(
)
obj
-
>
getClass
(
)
id
obj
)
)
return
false
;
if
(
obj
-
>
getClass
(
)
-
>
addProperty
)
return
false
;
if
(
!
obj
-
>
nonProxyIsExtensible
(
)
|
|
!
shape
-
>
writable
(
)
)
return
false
;
if
(
PrototypeChainShadowsPropertyAdd
(
cx
obj
id
)
)
return
false
;
if
(
obj
-
>
group
(
)
-
>
newScript
(
)
&
&
!
obj
-
>
group
(
)
-
>
newScript
(
)
-
>
analyzed
(
)
)
return
false
;
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
id
val
checkTypeset
)
)
return
false
;
return
true
;
}
static
SetPropertyIC
:
:
NativeSetPropCacheability
CanAttachNativeSetProp
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ConstantOrRegister
val
bool
needsTypeBarrier
MutableHandleObject
holder
MutableHandleShape
shape
bool
*
checkTypeset
)
{
if
(
obj
-
>
isNative
(
)
&
&
IsPropertySetInlineable
(
&
obj
-
>
as
<
NativeObject
>
(
)
id
shape
val
needsTypeBarrier
checkTypeset
)
)
{
return
SetPropertyIC
:
:
CanAttachSetSlot
;
}
if
(
!
LookupPropertyPure
(
cx
obj
id
holder
.
address
(
)
shape
.
address
(
)
)
)
return
SetPropertyIC
:
:
CanAttachNone
;
if
(
obj
-
>
isNative
(
)
&
&
(
!
shape
|
|
(
obj
!
=
holder
&
&
holder
-
>
isNative
(
)
&
&
shape
-
>
hasDefaultSetter
(
)
&
&
shape
-
>
hasSlot
(
)
)
)
)
{
return
SetPropertyIC
:
:
MaybeCanAttachAddSlot
;
}
if
(
IsImplicitNonNativeProperty
(
shape
)
)
return
SetPropertyIC
:
:
CanAttachNone
;
if
(
IsCacheableSetPropCallPropertyOp
(
obj
holder
shape
)
|
|
IsCacheableSetPropCallNative
(
obj
holder
shape
)
|
|
IsCacheableSetPropCallScripted
(
obj
holder
shape
)
)
{
return
SetPropertyIC
:
:
CanAttachCallSetter
;
}
return
SetPropertyIC
:
:
CanAttachNone
;
}
static
void
GenerateSetUnboxed
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
jsid
id
uint32_t
unboxedOffset
JSValueType
unboxedType
Register
object
Register
tempReg
ConstantOrRegister
value
bool
checkTypeset
Label
*
failures
)
{
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
ImmGCPtr
(
obj
-
>
group
(
)
)
failures
)
;
if
(
checkTypeset
)
CheckTypeSetForWrite
(
masm
obj
id
tempReg
value
failures
)
;
Address
address
(
object
UnboxedPlainObject
:
:
offsetOfData
(
)
+
unboxedOffset
)
;
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
if
(
unboxedType
=
=
JSVAL_TYPE_OBJECT
)
masm
.
callPreBarrier
(
address
MIRType_Object
)
;
else
if
(
unboxedType
=
=
JSVAL_TYPE_STRING
)
masm
.
callPreBarrier
(
address
MIRType_String
)
;
else
MOZ_ASSERT
(
!
UnboxedTypeNeedsPreBarrier
(
unboxedType
)
)
;
}
masm
.
storeUnboxedProperty
(
address
unboxedType
value
failures
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
static
bool
CanAttachSetUnboxed
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ConstantOrRegister
val
bool
needsTypeBarrier
bool
*
checkTypeset
uint32_t
*
unboxedOffset
JSValueType
*
unboxedType
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
property
)
{
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
id
val
checkTypeset
)
)
return
false
;
*
unboxedOffset
=
property
-
>
offset
;
*
unboxedType
=
property
-
>
type
;
return
true
;
}
return
false
;
}
static
bool
CanAttachSetUnboxedExpando
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ConstantOrRegister
val
bool
needsTypeBarrier
bool
*
checkTypeset
Shape
*
*
pshape
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
Rooted
<
UnboxedExpandoObject
*
>
expando
(
cx
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
;
if
(
!
expando
)
return
false
;
Shape
*
shape
=
expando
-
>
lookupPure
(
id
)
;
if
(
!
shape
|
|
!
shape
-
>
hasDefaultSetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
writable
(
)
)
return
false
;
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
id
val
checkTypeset
)
)
return
false
;
*
pshape
=
shape
;
return
true
;
}
static
bool
CanAttachAddUnboxedExpando
(
JSContext
*
cx
HandleObject
obj
HandleShape
oldShape
HandleId
id
ConstantOrRegister
val
bool
needsTypeBarrier
bool
*
checkTypeset
)
{
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
false
;
Rooted
<
UnboxedExpandoObject
*
>
expando
(
cx
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
;
if
(
!
expando
|
|
expando
-
>
inDictionaryMode
(
)
)
return
false
;
Shape
*
newShape
=
expando
-
>
lastProperty
(
)
;
if
(
newShape
-
>
isEmptyShape
(
)
|
|
newShape
-
>
propid
(
)
!
=
id
|
|
newShape
-
>
previous
(
)
!
=
oldShape
)
return
false
;
MOZ_ASSERT
(
newShape
-
>
hasDefaultSetter
(
)
&
&
newShape
-
>
hasSlot
(
)
&
&
newShape
-
>
writable
(
)
)
;
if
(
PrototypeChainShadowsPropertyAdd
(
cx
obj
id
)
)
return
false
;
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
id
val
checkTypeset
)
)
return
false
;
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachUnboxed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
bool
checkTypeset
=
false
;
uint32_t
unboxedOffset
;
JSValueType
unboxedType
;
if
(
!
CanAttachSetUnboxed
(
cx
obj
id
value
(
)
needsTypeBarrier
(
)
&
checkTypeset
&
unboxedOffset
&
unboxedType
)
)
{
return
true
;
}
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
emitIdGuard
(
masm
id
&
failures
)
;
GenerateSetUnboxed
(
cx
masm
attacher
obj
id
unboxedOffset
unboxedType
object
(
)
temp
(
)
value
(
)
checkTypeset
&
failures
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
set_unboxed
"
JS
:
:
TrackedOutcome
:
:
ICSetPropStub_SetUnboxed
)
;
}
bool
SetPropertyIC
:
:
tryAttachProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
obj
-
>
is
<
ProxyObject
>
(
)
)
return
true
;
void
*
returnAddr
=
GetReturnAddressToIonCode
(
cx
)
;
if
(
IsCacheableDOMProxy
(
obj
)
)
{
DOMProxyShadowsResult
shadows
=
GetDOMProxyShadowsCheck
(
)
(
cx
obj
id
)
;
if
(
shadows
=
=
ShadowCheckFailed
)
return
false
;
if
(
DOMProxyIsShadowing
(
shadows
)
)
{
if
(
!
attachDOMProxyShadowed
(
cx
outerScript
ion
obj
id
returnAddr
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
MOZ_ASSERT
(
shadows
=
=
DoesntShadow
|
|
shadows
=
=
DoesntShadowUnique
)
;
if
(
shadows
=
=
DoesntShadowUnique
)
reset
(
Reprotect
)
;
if
(
!
attachDOMProxyUnshadowed
(
cx
outerScript
ion
obj
id
returnAddr
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
if
(
hasGenericProxyStub
(
)
)
return
true
;
if
(
!
attachGenericProxy
(
cx
outerScript
ion
id
returnAddr
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachNative
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
bool
*
tryNativeAddSlot
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
!
*
tryNativeAddSlot
)
;
RootedShape
shape
(
cx
)
;
RootedObject
holder
(
cx
)
;
bool
checkTypeset
=
false
;
NativeSetPropCacheability
canCache
=
CanAttachNativeSetProp
(
cx
obj
id
value
(
)
needsTypeBarrier
(
)
&
holder
&
shape
&
checkTypeset
)
;
switch
(
canCache
)
{
case
CanAttachNone
:
return
true
;
case
CanAttachSetSlot
:
{
RootedNativeObject
nobj
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
)
;
if
(
!
attachSetSlot
(
cx
outerScript
ion
nobj
shape
checkTypeset
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
case
CanAttachCallSetter
:
{
void
*
returnAddr
=
GetReturnAddressToIonCode
(
cx
)
;
if
(
!
attachCallSetter
(
cx
outerScript
ion
obj
holder
shape
returnAddr
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
case
MaybeCanAttachAddSlot
:
*
tryNativeAddSlot
=
true
;
return
true
;
}
MOZ_CRASH
(
"
Unreachable
"
)
;
}
bool
SetPropertyIC
:
:
tryAttachUnboxedExpando
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
RootedShape
shape
(
cx
)
;
bool
checkTypeset
=
false
;
if
(
!
CanAttachSetUnboxedExpando
(
cx
obj
id
value
(
)
needsTypeBarrier
(
)
&
checkTypeset
shape
.
address
(
)
)
)
{
return
true
;
}
if
(
!
attachSetSlot
(
cx
outerScript
ion
obj
shape
checkTypeset
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachStub
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
HandleValue
value
MutableHandleId
id
bool
*
emitted
bool
*
tryNativeAddSlot
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
!
*
tryNativeAddSlot
)
;
if
(
!
canAttachStub
(
)
|
|
obj
-
>
watched
(
)
)
return
true
;
bool
nameOrSymbol
;
if
(
!
ValueToNameOrSymbolId
(
cx
idval
id
&
nameOrSymbol
)
)
return
false
;
if
(
nameOrSymbol
)
{
if
(
!
*
emitted
&
&
!
tryAttachProxy
(
cx
outerScript
ion
obj
id
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachNative
(
cx
outerScript
ion
obj
id
emitted
tryNativeAddSlot
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachUnboxed
(
cx
outerScript
ion
obj
id
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachUnboxedExpando
(
cx
outerScript
ion
obj
id
emitted
)
)
return
false
;
}
if
(
idval
.
isInt32
(
)
)
{
if
(
!
*
emitted
&
&
!
tryAttachDenseElement
(
cx
outerScript
ion
obj
idval
emitted
)
)
return
false
;
if
(
!
*
emitted
&
&
!
tryAttachTypedArrayElement
(
cx
outerScript
ion
obj
idval
value
emitted
)
)
{
return
false
;
}
}
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachAddSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
HandleObjectGroup
oldGroup
HandleShape
oldShape
bool
tryNativeAddSlot
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
canAttachStub
(
)
)
return
true
;
if
(
!
JSID_IS_STRING
(
id
)
&
&
!
JSID_IS_SYMBOL
(
id
)
)
return
true
;
JS
:
:
AutoAssertNoAlloc
nogc
;
if
(
ion
-
>
invalidated
(
)
)
return
true
;
bool
checkTypeset
=
false
;
if
(
tryNativeAddSlot
&
&
IsPropertyAddInlineable
(
cx
&
obj
-
>
as
<
NativeObject
>
(
)
id
value
(
)
oldShape
needsTypeBarrier
(
)
&
checkTypeset
)
)
{
if
(
!
attachAddSlot
(
cx
outerScript
ion
obj
id
oldShape
oldGroup
checkTypeset
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
checkTypeset
=
false
;
if
(
CanAttachAddUnboxedExpando
(
cx
obj
oldShape
id
value
(
)
needsTypeBarrier
(
)
&
checkTypeset
)
)
{
if
(
!
attachAddSlot
(
cx
outerScript
ion
obj
id
oldShape
oldGroup
checkTypeset
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
return
true
;
}
bool
SetPropertyIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
obj
HandleValue
idval
HandleValue
value
)
{
IonScript
*
ion
=
outerScript
-
>
ionScript
(
)
;
SetPropertyIC
&
cache
=
ion
-
>
getCache
(
cacheIndex
)
.
toSetProperty
(
)
;
RootedObjectGroup
oldGroup
(
cx
)
;
RootedShape
oldShape
(
cx
)
;
if
(
cache
.
canAttachStub
(
)
)
{
oldGroup
=
obj
-
>
getGroup
(
cx
)
;
if
(
!
oldGroup
)
return
false
;
oldShape
=
obj
-
>
maybeShape
(
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
}
RootedId
id
(
cx
)
;
bool
emitted
=
false
;
bool
tryNativeAddSlot
=
false
;
if
(
!
cache
.
tryAttachStub
(
cx
outerScript
ion
obj
idval
value
&
id
&
emitted
&
tryNativeAddSlot
)
)
{
return
false
;
}
if
(
JSOp
(
*
cache
.
pc
(
)
)
=
=
JSOP_INITGLEXICAL
)
{
RootedScript
script
(
cx
)
;
jsbytecode
*
pc
;
cache
.
getScriptedLocation
(
&
script
&
pc
)
;
MOZ_ASSERT
(
!
script
-
>
hasNonSyntacticScope
(
)
)
;
InitGlobalLexicalOperation
(
cx
&
cx
-
>
global
(
)
-
>
lexicalScope
(
)
script
pc
value
)
;
}
else
if
(
*
cache
.
pc
(
)
=
=
JSOP_SETELEM
|
|
*
cache
.
pc
(
)
=
=
JSOP_STRICTSETELEM
)
{
if
(
!
SetObjectElement
(
cx
obj
idval
value
cache
.
strict
(
)
)
)
return
false
;
}
else
{
RootedPropertyName
name
(
cx
idval
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
;
if
(
!
SetProperty
(
cx
obj
name
value
cache
.
strict
(
)
cache
.
pc
(
)
)
)
return
false
;
}
if
(
!
emitted
&
&
!
cache
.
tryAttachAddSlot
(
cx
outerScript
ion
obj
id
oldGroup
oldShape
tryNativeAddSlot
&
emitted
)
)
{
return
false
;
}
if
(
!
emitted
)
JitSpew
(
JitSpew_IonIC
"
Failed
to
attach
SETPROP
cache
"
)
;
return
true
;
}
void
SetPropertyIC
:
:
reset
(
ReprotectCode
reprotect
)
{
IonCache
:
:
reset
(
reprotect
)
;
hasGenericProxyStub_
=
false
;
hasDenseStub_
=
false
;
}
static
bool
GenerateDenseElement
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
const
Value
&
idval
Register
object
TypedOrValueRegister
index
TypedOrValueRegister
output
)
{
Label
failures
;
RootedShape
shape
(
cx
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
if
(
!
shape
)
return
false
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
shape
&
failures
)
;
Register
indexReg
=
InvalidReg
;
if
(
index
.
hasValue
(
)
)
{
indexReg
=
output
.
scratchReg
(
)
.
gpr
(
)
;
MOZ_ASSERT
(
indexReg
!
=
InvalidReg
)
;
ValueOperand
val
=
index
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
masm
.
unboxInt32
(
val
indexReg
)
;
}
else
{
MOZ_ASSERT
(
!
index
.
typedReg
(
)
.
isFloat
(
)
)
;
indexReg
=
index
.
typedReg
(
)
.
gpr
(
)
;
}
masm
.
push
(
object
)
;
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfElements
(
)
)
object
)
;
Label
hole
;
Address
initLength
(
object
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
indexReg
&
hole
)
;
masm
.
loadElementTypedOrValue
(
BaseObjectElementIndex
(
object
indexReg
)
output
true
&
hole
)
;
masm
.
pop
(
object
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
hole
)
;
masm
.
pop
(
object
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
bool
GetPropertyIC
:
:
tryAttachDenseElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
hasDenseStub
(
)
)
return
true
;
if
(
!
obj
-
>
isNative
(
)
|
|
!
idval
.
isInt32
(
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
if
(
!
GenerateDenseElement
(
cx
masm
attacher
obj
idval
object
(
)
id
(
)
.
reg
(
)
output
(
)
)
)
return
false
;
setHasDenseStub
(
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
dense
array
"
JS
:
:
TrackedOutcome
:
:
ICGetElemStub_Dense
)
;
}
bool
GetPropertyIC
:
:
canAttachDenseElementHole
(
JSObject
*
obj
HandleValue
idval
TypedOrValueRegister
output
)
{
if
(
!
idval
.
isInt32
(
)
|
|
idval
.
toInt32
(
)
<
0
)
return
false
;
if
(
!
output
.
hasValue
(
)
)
return
false
;
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
obj
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
=
=
0
)
return
false
;
do
{
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
if
(
ClassCanHaveExtraProperties
(
obj
-
>
getClass
(
)
)
)
return
false
;
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
if
(
!
proto
)
break
;
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
getDenseInitializedLength
(
)
!
=
0
)
return
false
;
obj
=
proto
;
}
while
(
obj
)
;
return
true
;
}
static
bool
GenerateDenseElementHole
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
IonScript
*
ion
JSObject
*
obj
HandleValue
idval
Register
object
TypedOrValueRegister
index
TypedOrValueRegister
output
)
{
MOZ_ASSERT
(
GetPropertyIC
:
:
canAttachDenseElementHole
(
obj
idval
output
)
)
;
Register
scratchReg
=
output
.
valueReg
(
)
.
scratchReg
(
)
;
Label
failures
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
&
failures
)
;
if
(
obj
-
>
hasUncacheableProto
(
)
)
{
masm
.
loadPtr
(
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
Address
proto
(
scratchReg
ObjectGroup
:
:
offsetOfProto
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
proto
ImmGCPtr
(
obj
-
>
getProto
(
)
)
&
failures
)
;
}
JSObject
*
pobj
=
obj
-
>
getProto
(
)
;
while
(
pobj
)
{
MOZ_ASSERT
(
pobj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
masm
.
movePtr
(
ImmGCPtr
(
pobj
)
scratchReg
)
;
if
(
pobj
-
>
hasUncacheableProto
(
)
&
&
!
pobj
-
>
isSingleton
(
)
)
{
Address
groupAddr
(
scratchReg
JSObject
:
:
offsetOfGroup
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
groupAddr
ImmGCPtr
(
pobj
-
>
group
(
)
)
&
failures
)
;
}
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
scratchReg
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
pobj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
&
failures
)
;
masm
.
loadPtr
(
Address
(
scratchReg
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Label
hole
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
initLength
Imm32
(
0
)
&
failures
)
;
pobj
=
pobj
-
>
getProto
(
)
;
}
Register
indexReg
;
if
(
index
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
indexReg
=
scratchReg
;
masm
.
unboxInt32
(
val
indexReg
)
;
}
else
{
MOZ_ASSERT
(
index
.
type
(
)
=
=
MIRType_Int32
)
;
indexReg
=
index
.
typedReg
(
)
.
gpr
(
)
;
}
masm
.
branch32
(
Assembler
:
:
LessThan
indexReg
Imm32
(
0
)
&
failures
)
;
Register
elementsReg
=
object
;
masm
.
push
(
object
)
;
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfElements
(
)
)
elementsReg
)
;
Label
hole
;
Address
initLength
(
elementsReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
indexReg
&
hole
)
;
Label
done
;
masm
.
loadValue
(
BaseObjectElementIndex
(
elementsReg
indexReg
)
output
.
valueReg
(
)
)
;
masm
.
branchTestMagic
(
Assembler
:
:
NotEqual
output
.
valueReg
(
)
&
done
)
;
masm
.
bind
(
&
hole
)
;
masm
.
moveValue
(
UndefinedValue
(
)
output
.
valueReg
(
)
)
;
masm
.
bind
(
&
done
)
;
if
(
elementsReg
=
=
object
)
masm
.
pop
(
object
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
bool
GetPropertyIC
:
:
tryAttachDenseElementHole
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
monitoredResult
(
)
)
return
true
;
if
(
!
canAttachDenseElementHole
(
obj
idval
output
(
)
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
GenerateDenseElementHole
(
cx
masm
attacher
ion
obj
idval
object
(
)
id
(
)
.
reg
(
)
output
(
)
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
dense
hole
"
JS
:
:
TrackedOutcome
:
:
ICGetElemStub_DenseHole
)
;
}
bool
GetPropertyIC
:
:
canAttachTypedOrUnboxedArrayElement
(
JSObject
*
obj
const
Value
&
idval
TypedOrValueRegister
output
)
{
if
(
!
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
MOZ_ASSERT
(
idval
.
isInt32
(
)
|
|
idval
.
isString
(
)
)
;
uint32_t
index
;
if
(
idval
.
isInt32
(
)
)
{
index
=
idval
.
toInt32
(
)
;
}
else
{
index
=
GetIndexFromString
(
idval
.
toString
(
)
)
;
if
(
index
=
=
UINT32_MAX
)
return
false
;
}
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
if
(
index
>
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
return
false
;
uint32_t
arrayType
=
obj
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
;
if
(
arrayType
=
=
Scalar
:
:
Float32
|
|
arrayType
=
=
Scalar
:
:
Float64
)
return
output
.
hasValue
(
)
;
return
output
.
hasValue
(
)
|
|
!
output
.
typedReg
(
)
.
isFloat
(
)
;
}
if
(
index
>
=
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
initializedLength
(
)
)
return
false
;
JSValueType
elementType
=
obj
-
>
as
<
UnboxedArrayObject
>
(
)
.
elementType
(
)
;
if
(
elementType
=
=
JSVAL_TYPE_DOUBLE
)
return
output
.
hasValue
(
)
;
return
output
.
hasValue
(
)
|
|
!
output
.
typedReg
(
)
.
isFloat
(
)
;
}
static
void
GenerateGetTypedOrUnboxedArrayElement
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
HandleObject
array
const
Value
&
idval
Register
object
ConstantOrRegister
index
TypedOrValueRegister
output
bool
allowDoubleResult
)
{
MOZ_ASSERT
(
GetPropertyIC
:
:
canAttachTypedOrUnboxedArrayElement
(
array
idval
output
)
)
;
Label
failures
;
TestMatchingReceiver
(
masm
attacher
object
array
&
failures
)
;
Register
tmpReg
=
output
.
scratchReg
(
)
.
gpr
(
)
;
MOZ_ASSERT
(
tmpReg
!
=
InvalidReg
)
;
Register
indexReg
=
tmpReg
;
if
(
idval
.
isString
(
)
)
{
MOZ_ASSERT
(
GetIndexFromString
(
idval
.
toString
(
)
)
!
=
UINT32_MAX
)
;
if
(
index
.
constant
(
)
)
{
MOZ_ASSERT
(
idval
=
=
index
.
value
(
)
)
;
masm
.
move32
(
Imm32
(
GetIndexFromString
(
idval
.
toString
(
)
)
)
indexReg
)
;
}
else
{
Register
str
;
if
(
index
.
reg
(
)
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
reg
(
)
.
valueReg
(
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
val
&
failures
)
;
str
=
masm
.
extractString
(
val
indexReg
)
;
}
else
{
MOZ_ASSERT
(
!
index
.
reg
(
)
.
typedReg
(
)
.
isFloat
(
)
)
;
str
=
index
.
reg
(
)
.
typedReg
(
)
.
gpr
(
)
;
}
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
masm
.
PushRegsInMask
(
save
)
;
regs
.
takeUnchecked
(
str
)
;
Register
temp
=
regs
.
takeAnyGeneral
(
)
;
masm
.
setupUnalignedABICall
(
temp
)
;
masm
.
passABIArg
(
str
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
GetIndexFromString
)
)
;
masm
.
mov
(
ReturnReg
indexReg
)
;
LiveRegisterSet
ignore
;
ignore
.
add
(
indexReg
)
;
masm
.
PopRegsInMaskIgnore
(
save
ignore
)
;
masm
.
branch32
(
Assembler
:
:
Equal
indexReg
Imm32
(
UINT32_MAX
)
&
failures
)
;
}
}
else
{
MOZ_ASSERT
(
idval
.
isInt32
(
)
)
;
MOZ_ASSERT
(
!
index
.
constant
(
)
)
;
if
(
index
.
reg
(
)
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
reg
(
)
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
masm
.
unboxInt32
(
val
indexReg
)
;
}
else
{
MOZ_ASSERT
(
!
index
.
reg
(
)
.
typedReg
(
)
.
isFloat
(
)
)
;
indexReg
=
index
.
reg
(
)
.
typedReg
(
)
.
gpr
(
)
;
}
}
Label
popObjectAndFail
;
if
(
array
-
>
is
<
TypedArrayObject
>
(
)
)
{
Address
length
(
object
TypedArrayObject
:
:
lengthOffset
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
length
indexReg
&
failures
)
;
Register
elementReg
=
object
;
masm
.
push
(
object
)
;
masm
.
loadPtr
(
Address
(
object
TypedArrayObject
:
:
dataOffset
(
)
)
elementReg
)
;
Scalar
:
:
Type
arrayType
=
array
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
;
int
width
=
Scalar
:
:
byteSize
(
arrayType
)
;
BaseIndex
source
(
elementReg
indexReg
ScaleFromElemWidth
(
width
)
)
;
if
(
output
.
hasValue
(
)
)
{
masm
.
loadFromTypedArray
(
arrayType
source
output
.
valueReg
(
)
allowDoubleResult
elementReg
&
popObjectAndFail
)
;
}
else
{
masm
.
loadFromTypedArray
(
arrayType
source
output
.
typedReg
(
)
elementReg
&
popObjectAndFail
)
;
}
}
else
{
masm
.
push
(
object
)
;
masm
.
load32
(
Address
(
object
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
object
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
object
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
object
indexReg
&
popObjectAndFail
)
;
Register
elementReg
=
object
;
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
0
)
object
)
;
masm
.
loadPtr
(
Address
(
object
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
elementReg
)
;
JSValueType
elementType
=
array
-
>
as
<
UnboxedArrayObject
>
(
)
.
elementType
(
)
;
BaseIndex
source
(
elementReg
indexReg
ScaleFromElemWidth
(
UnboxedTypeSize
(
elementType
)
)
)
;
masm
.
loadUnboxedProperty
(
source
elementType
output
)
;
}
masm
.
pop
(
object
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
popObjectAndFail
)
;
masm
.
pop
(
object
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
bool
GetPropertyIC
:
:
tryAttachTypedOrUnboxedArrayElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
canAttachTypedOrUnboxedArrayElement
(
obj
idval
output
(
)
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
GenerateGetTypedOrUnboxedArrayElement
(
cx
masm
attacher
obj
idval
object
(
)
id
(
)
output
(
)
allowDoubleResult_
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
typed
array
"
JS
:
:
TrackedOutcome
:
:
ICGetElemStub_TypedArray
)
;
}
bool
GetPropertyIC
:
:
tryAttachArgumentsElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
!
*
emitted
)
;
if
(
!
IsOptimizableArgumentsObjectForGetElem
(
obj
idval
)
)
return
true
;
MOZ_ASSERT
(
obj
-
>
is
<
ArgumentsObject
>
(
)
)
;
if
(
hasArgumentsElementStub
(
obj
-
>
is
<
MappedArgumentsObject
>
(
)
)
)
return
true
;
TypedOrValueRegister
index
=
id
(
)
.
reg
(
)
;
if
(
index
.
type
(
)
!
=
MIRType_Value
&
&
index
.
type
(
)
!
=
MIRType_Int32
)
return
true
;
MOZ_ASSERT
(
output
(
)
.
hasValue
(
)
)
;
*
emitted
=
true
;
Label
failures
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Register
tmpReg
=
output
(
)
.
scratchReg
(
)
.
gpr
(
)
;
MOZ_ASSERT
(
tmpReg
!
=
InvalidReg
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
object
(
)
tmpReg
obj
-
>
getClass
(
)
&
failures
)
;
masm
.
unboxInt32
(
Address
(
object
(
)
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
tmpReg
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
tmpReg
Imm32
(
ArgumentsObject
:
:
LENGTH_OVERRIDDEN_BIT
)
&
failures
)
;
masm
.
rshiftPtr
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
tmpReg
)
;
Register
indexReg
;
Label
failureRestoreIndex
;
if
(
index
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
indexReg
=
val
.
scratchReg
(
)
;
masm
.
unboxInt32
(
val
indexReg
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
indexReg
tmpReg
&
failureRestoreIndex
)
;
}
else
{
MOZ_ASSERT
(
index
.
type
(
)
=
=
MIRType_Int32
)
;
indexReg
=
index
.
typedReg
(
)
.
gpr
(
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
indexReg
tmpReg
&
failures
)
;
}
Label
failurePopIndex
;
masm
.
push
(
indexReg
)
;
masm
.
loadPrivate
(
Address
(
object
(
)
ArgumentsObject
:
:
getDataSlotOffset
(
)
)
tmpReg
)
;
masm
.
loadPtr
(
Address
(
tmpReg
offsetof
(
ArgumentsData
deletedBits
)
)
tmpReg
)
;
const
uint32_t
shift
=
FloorLog2
<
(
sizeof
(
size_t
)
*
JS_BITS_PER_BYTE
)
>
:
:
value
;
MOZ_ASSERT
(
shift
=
=
5
|
|
shift
=
=
6
)
;
masm
.
rshiftPtr
(
Imm32
(
shift
)
indexReg
)
;
masm
.
loadPtr
(
BaseIndex
(
tmpReg
indexReg
ScaleFromElemWidth
(
sizeof
(
size_t
)
)
)
tmpReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
tmpReg
ImmPtr
(
nullptr
)
&
failurePopIndex
)
;
masm
.
loadPrivate
(
Address
(
object
(
)
ArgumentsObject
:
:
getDataSlotOffset
(
)
)
tmpReg
)
;
masm
.
addPtr
(
Imm32
(
ArgumentsData
:
:
offsetOfArgs
(
)
)
tmpReg
)
;
masm
.
pop
(
indexReg
)
;
BaseValueIndex
elemIdx
(
tmpReg
indexReg
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
elemIdx
&
failureRestoreIndex
)
;
masm
.
loadTypedOrValue
(
elemIdx
output
(
)
)
;
if
(
index
.
hasValue
(
)
)
masm
.
tagValue
(
JSVAL_TYPE_INT32
indexReg
index
.
valueReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failurePopIndex
)
;
masm
.
pop
(
indexReg
)
;
masm
.
bind
(
&
failureRestoreIndex
)
;
if
(
index
.
hasValue
(
)
)
masm
.
tagValue
(
JSVAL_TYPE_INT32
indexReg
index
.
valueReg
(
)
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
if
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
{
MOZ_ASSERT
(
!
hasUnmappedArgumentsElementStub_
)
;
hasUnmappedArgumentsElementStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
ArgsObj
element
(
unmapped
)
"
JS
:
:
TrackedOutcome
:
:
ICGetElemStub_ArgsElementUnmapped
)
;
}
MOZ_ASSERT
(
!
hasMappedArgumentsElementStub_
)
;
hasMappedArgumentsElementStub_
=
true
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
ArgsObj
element
(
mapped
)
"
JS
:
:
TrackedOutcome
:
:
ICGetElemStub_ArgsElementMapped
)
;
}
static
bool
IsDenseElementSetInlineable
(
JSObject
*
obj
const
Value
&
idval
ConstantOrRegister
val
bool
needsTypeBarrier
bool
*
checkTypeset
)
{
if
(
!
obj
-
>
is
<
ArrayObject
>
(
)
)
return
false
;
if
(
obj
-
>
watched
(
)
)
return
false
;
if
(
!
idval
.
isInt32
(
)
)
return
false
;
JSObject
*
curObj
=
obj
;
while
(
curObj
)
{
if
(
!
curObj
-
>
isNative
(
)
)
return
false
;
if
(
curObj
-
>
isIndexed
(
)
)
return
false
;
curObj
=
curObj
-
>
getProto
(
)
;
}
*
checkTypeset
=
false
;
if
(
needsTypeBarrier
&
&
!
CanInlineSetPropTypeCheck
(
obj
JSID_VOID
val
checkTypeset
)
)
return
false
;
return
true
;
}
static
bool
IsTypedArrayElementSetInlineable
(
JSObject
*
obj
const
Value
&
idval
const
Value
&
value
)
{
return
obj
-
>
is
<
TypedArrayObject
>
(
)
&
&
idval
.
isInt32
(
)
&
&
!
value
.
isString
(
)
&
&
!
value
.
isObject
(
)
&
&
!
value
.
isSymbol
(
)
;
}
static
void
StoreDenseElement
(
MacroAssembler
&
masm
ConstantOrRegister
value
Register
elements
BaseObjectElementIndex
target
)
{
Address
elementsFlags
(
elements
ObjectElements
:
:
offsetOfFlags
(
)
)
;
if
(
value
.
constant
(
)
)
{
Value
v
=
value
.
value
(
)
;
Label
done
;
if
(
v
.
isInt32
(
)
)
{
Label
dontConvert
;
masm
.
branchTest32
(
Assembler
:
:
Zero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
)
&
dontConvert
)
;
masm
.
storeValue
(
DoubleValue
(
v
.
toInt32
(
)
)
target
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
dontConvert
)
;
}
masm
.
storeValue
(
v
target
)
;
masm
.
bind
(
&
done
)
;
return
;
}
TypedOrValueRegister
reg
=
value
.
reg
(
)
;
if
(
reg
.
hasTyped
(
)
&
&
reg
.
type
(
)
!
=
MIRType_Int32
)
{
masm
.
storeTypedOrValue
(
reg
target
)
;
return
;
}
Label
convert
storeValue
done
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
)
&
convert
)
;
masm
.
bind
(
&
storeValue
)
;
masm
.
storeTypedOrValue
(
reg
target
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
convert
)
;
if
(
reg
.
hasValue
(
)
)
{
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
reg
.
valueReg
(
)
&
storeValue
)
;
masm
.
int32ValueToDouble
(
reg
.
valueReg
(
)
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
target
)
;
}
else
{
MOZ_ASSERT
(
reg
.
type
(
)
=
=
MIRType_Int32
)
;
masm
.
convertInt32ToDouble
(
reg
.
typedReg
(
)
.
gpr
(
)
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
target
)
;
}
masm
.
bind
(
&
done
)
;
}
static
bool
GenerateSetDenseElement
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
JSObject
*
obj
const
Value
&
idval
bool
guardHoles
Register
object
TypedOrValueRegister
index
ConstantOrRegister
value
Register
tempToUnboxIndex
Register
temp
bool
needsTypeBarrier
bool
checkTypeset
)
{
MOZ_ASSERT
(
obj
-
>
isNative
(
)
)
;
MOZ_ASSERT
(
idval
.
isInt32
(
)
)
;
Label
failures
;
Shape
*
shape
=
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
;
if
(
!
shape
)
return
false
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
shape
&
failures
)
;
if
(
needsTypeBarrier
)
{
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
object
obj
-
>
group
(
)
&
failures
)
;
if
(
checkTypeset
)
CheckTypeSetForWrite
(
masm
obj
JSID_VOID
temp
value
&
failures
)
;
}
Register
indexReg
;
if
(
index
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
indexReg
=
masm
.
extractInt32
(
val
tempToUnboxIndex
)
;
}
else
{
MOZ_ASSERT
(
!
index
.
typedReg
(
)
.
isFloat
(
)
)
;
indexReg
=
index
.
typedReg
(
)
.
gpr
(
)
;
}
{
Register
elements
=
temp
;
masm
.
loadPtr
(
Address
(
object
NativeObject
:
:
offsetOfElements
(
)
)
elements
)
;
BaseObjectElementIndex
target
(
elements
indexReg
)
;
Label
storeElement
;
if
(
guardHoles
)
{
Address
initLength
(
elements
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
indexReg
&
failures
)
;
}
else
{
Address
capacity
(
elements
ObjectElements
:
:
offsetOfCapacity
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
capacity
indexReg
&
failures
)
;
Address
initLength
(
elements
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Below
initLength
indexReg
&
failures
)
;
Label
inBounds
;
masm
.
branch32
(
Assembler
:
:
NotEqual
initLength
indexReg
&
inBounds
)
;
{
Int32Key
newLength
(
indexReg
)
;
masm
.
bumpKey
(
&
newLength
1
)
;
masm
.
storeKey
(
newLength
initLength
)
;
Label
bumpedLength
;
Address
length
(
elements
ObjectElements
:
:
offsetOfLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
length
indexReg
&
bumpedLength
)
;
masm
.
storeKey
(
newLength
length
)
;
masm
.
bind
(
&
bumpedLength
)
;
masm
.
bumpKey
(
&
newLength
-
1
)
;
masm
.
jump
(
&
storeElement
)
;
}
masm
.
bind
(
&
inBounds
)
;
}
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
masm
.
callPreBarrier
(
target
MIRType_Value
)
;
if
(
guardHoles
)
masm
.
branchTestMagic
(
Assembler
:
:
Equal
target
&
failures
)
;
else
masm
.
bind
(
&
storeElement
)
;
StoreDenseElement
(
masm
value
elements
target
)
;
}
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachDenseElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
const
Value
&
idval
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
canAttachStub
(
)
)
;
if
(
hasDenseStub
(
)
)
return
true
;
bool
checkTypeset
=
false
;
if
(
!
IsDenseElementSetInlineable
(
obj
idval
value
(
)
needsTypeBarrier
(
)
&
checkTypeset
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
if
(
!
GenerateSetDenseElement
(
cx
masm
attacher
obj
idval
guardHoles
(
)
object
(
)
id
(
)
.
reg
(
)
value
(
)
tempToUnboxIndex
(
)
temp
(
)
needsTypeBarrier
(
)
checkTypeset
)
)
{
return
false
;
}
setHasDenseStub
(
)
;
const
char
*
message
=
guardHoles
(
)
?
"
dense
array
(
holes
)
"
:
"
dense
array
"
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
message
JS
:
:
TrackedOutcome
:
:
ICSetElemStub_Dense
)
;
}
static
bool
GenerateSetTypedArrayElement
(
JSContext
*
cx
MacroAssembler
&
masm
IonCache
:
:
StubAttacher
&
attacher
HandleObject
tarr
Register
object
TypedOrValueRegister
index
ConstantOrRegister
value
Register
tempUnbox
Register
temp
FloatRegister
tempDouble
FloatRegister
tempFloat32
)
{
Label
failures
done
popObjectAndFail
;
Shape
*
shape
=
tarr
-
>
as
<
TypedArrayObject
>
(
)
.
lastProperty
(
)
;
if
(
!
shape
)
return
false
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
shape
&
failures
)
;
Register
indexReg
;
if
(
index
.
hasValue
(
)
)
{
ValueOperand
val
=
index
.
valueReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
val
&
failures
)
;
indexReg
=
masm
.
extractInt32
(
val
tempUnbox
)
;
}
else
{
MOZ_ASSERT
(
!
index
.
typedReg
(
)
.
isFloat
(
)
)
;
indexReg
=
index
.
typedReg
(
)
.
gpr
(
)
;
}
Address
length
(
object
TypedArrayObject
:
:
lengthOffset
(
)
)
;
masm
.
unboxInt32
(
length
temp
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
temp
indexReg
&
done
)
;
Register
elements
=
temp
;
masm
.
loadPtr
(
Address
(
object
TypedArrayObject
:
:
dataOffset
(
)
)
elements
)
;
Scalar
:
:
Type
arrayType
=
tarr
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
;
int
width
=
Scalar
:
:
byteSize
(
arrayType
)
;
BaseIndex
target
(
elements
indexReg
ScaleFromElemWidth
(
width
)
)
;
if
(
arrayType
=
=
Scalar
:
:
Float32
)
{
MOZ_ASSERT_IF
(
hasUnaliasedDouble
(
)
tempFloat32
!
=
InvalidFloatReg
)
;
FloatRegister
tempFloat
=
hasUnaliasedDouble
(
)
?
tempFloat32
:
tempDouble
;
if
(
!
masm
.
convertConstantOrRegisterToFloat
(
cx
value
tempFloat
&
failures
)
)
return
false
;
masm
.
storeToTypedFloatArray
(
arrayType
tempFloat
target
)
;
}
else
if
(
arrayType
=
=
Scalar
:
:
Float64
)
{
if
(
!
masm
.
convertConstantOrRegisterToDouble
(
cx
value
tempDouble
&
failures
)
)
return
false
;
masm
.
storeToTypedFloatArray
(
arrayType
tempDouble
target
)
;
}
else
{
masm
.
push
(
object
)
;
if
(
arrayType
=
=
Scalar
:
:
Uint8Clamped
)
{
if
(
!
masm
.
clampConstantOrRegisterToUint8
(
cx
value
tempDouble
object
&
popObjectAndFail
)
)
{
return
false
;
}
}
else
{
if
(
!
masm
.
truncateConstantOrRegisterToInt32
(
cx
value
tempDouble
object
&
popObjectAndFail
)
)
{
return
false
;
}
}
masm
.
storeToTypedIntArray
(
arrayType
object
target
)
;
masm
.
pop
(
object
)
;
}
masm
.
bind
(
&
done
)
;
attacher
.
jumpRejoin
(
masm
)
;
if
(
popObjectAndFail
.
used
(
)
)
{
masm
.
bind
(
&
popObjectAndFail
)
;
masm
.
pop
(
object
)
;
}
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
true
;
}
bool
SetPropertyIC
:
:
tryAttachTypedArrayElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
HandleValue
val
bool
*
emitted
)
{
MOZ_ASSERT
(
!
*
emitted
)
;
MOZ_ASSERT
(
canAttachStub
(
)
)
;
if
(
!
IsTypedArrayElementSetInlineable
(
obj
idval
val
)
)
return
true
;
*
emitted
=
true
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
if
(
!
GenerateSetTypedArrayElement
(
cx
masm
attacher
obj
object
(
)
id
(
)
.
reg
(
)
value
(
)
tempToUnboxIndex
(
)
temp
(
)
tempDouble
(
)
tempFloat32
(
)
)
)
{
return
false
;
}
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
typed
array
"
JS
:
:
TrackedOutcome
:
:
ICSetElemStub_TypedArray
)
;
}
bool
BindNameIC
:
:
attachGlobal
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
scopeChain
)
{
MOZ_ASSERT
(
scopeChain
-
>
is
<
GlobalObject
>
(
)
)
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
attacher
.
branchNextStub
(
masm
Assembler
:
:
NotEqual
scopeChainReg
(
)
ImmGCPtr
(
scopeChain
)
)
;
masm
.
movePtr
(
ImmGCPtr
(
scopeChain
)
outputReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
global
"
)
;
}
static
inline
void
GenerateScopeChainGuard
(
MacroAssembler
&
masm
JSObject
*
scopeObj
Register
scopeObjReg
Shape
*
shape
Label
*
failures
)
{
if
(
scopeObj
-
>
is
<
CallObject
>
(
)
)
{
CallObject
*
callObj
=
&
scopeObj
-
>
as
<
CallObject
>
(
)
;
if
(
!
callObj
-
>
isForEval
(
)
)
{
JSFunction
*
fun
=
&
callObj
-
>
callee
(
)
;
if
(
fun
-
>
hasScript
(
)
)
{
JSScript
*
script
=
fun
-
>
nonLazyScript
(
)
;
if
(
!
script
-
>
funHasExtensibleScope
(
)
)
return
;
}
}
}
else
if
(
scopeObj
-
>
is
<
GlobalObject
>
(
)
)
{
if
(
shape
&
&
!
shape
-
>
configurable
(
)
)
return
;
}
Address
shapeAddr
(
scopeObjReg
JSObject
:
:
offsetOfShape
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
shapeAddr
ImmGCPtr
(
scopeObj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
failures
)
;
}
static
void
GenerateScopeChainGuards
(
MacroAssembler
&
masm
JSObject
*
scopeChain
JSObject
*
holder
Register
outputReg
Label
*
failures
bool
skipLastGuard
=
false
)
{
JSObject
*
tobj
=
scopeChain
;
while
(
true
)
{
MOZ_ASSERT
(
IsCacheableNonGlobalScope
(
tobj
)
|
|
tobj
-
>
is
<
GlobalObject
>
(
)
)
;
if
(
skipLastGuard
&
&
tobj
=
=
holder
)
break
;
GenerateScopeChainGuard
(
masm
tobj
outputReg
nullptr
failures
)
;
if
(
tobj
=
=
holder
)
break
;
tobj
=
&
tobj
-
>
as
<
ScopeObject
>
(
)
.
enclosingScope
(
)
;
masm
.
extractObject
(
Address
(
outputReg
ScopeObject
:
:
offsetOfEnclosingScope
(
)
)
outputReg
)
;
}
}
bool
BindNameIC
:
:
attachNonGlobal
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
scopeChain
HandleObject
holder
)
{
MOZ_ASSERT
(
IsCacheableNonGlobalScope
(
scopeChain
)
)
;
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
attacher
.
branchNextStubOrLabel
(
masm
Assembler
:
:
NotEqual
Address
(
scopeChainReg
(
)
JSObject
:
:
offsetOfShape
(
)
)
ImmGCPtr
(
scopeChain
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
holder
!
=
scopeChain
?
&
failures
:
nullptr
)
;
if
(
holder
!
=
scopeChain
)
{
JSObject
*
parent
=
&
scopeChain
-
>
as
<
ScopeObject
>
(
)
.
enclosingScope
(
)
;
masm
.
extractObject
(
Address
(
scopeChainReg
(
)
ScopeObject
:
:
offsetOfEnclosingScope
(
)
)
outputReg
(
)
)
;
GenerateScopeChainGuards
(
masm
parent
holder
outputReg
(
)
&
failures
)
;
}
else
{
masm
.
movePtr
(
scopeChainReg
(
)
outputReg
(
)
)
;
}
attacher
.
jumpRejoin
(
masm
)
;
if
(
holder
!
=
scopeChain
)
{
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
}
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
non
-
global
"
)
;
}
static
bool
IsCacheableNonGlobalScopeChain
(
JSObject
*
scopeChain
JSObject
*
holder
)
{
while
(
true
)
{
if
(
!
IsCacheableNonGlobalScope
(
scopeChain
)
)
{
JitSpew
(
JitSpew_IonIC
"
Non
-
cacheable
object
on
scope
chain
"
)
;
return
false
;
}
if
(
scopeChain
=
=
holder
)
return
true
;
scopeChain
=
&
scopeChain
-
>
as
<
ScopeObject
>
(
)
.
enclosingScope
(
)
;
if
(
!
scopeChain
)
{
JitSpew
(
JitSpew_IonIC
"
Scope
chain
indirect
hit
"
)
;
return
false
;
}
}
MOZ_CRASH
(
"
Invalid
scope
chain
"
)
;
}
JSObject
*
BindNameIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
scopeChain
)
{
IonScript
*
ion
=
outerScript
-
>
ionScript
(
)
;
BindNameIC
&
cache
=
ion
-
>
getCache
(
cacheIndex
)
.
toBindName
(
)
;
HandlePropertyName
name
=
cache
.
name
(
)
;
RootedObject
holder
(
cx
)
;
if
(
!
LookupNameUnqualified
(
cx
name
scopeChain
&
holder
)
)
return
nullptr
;
if
(
cache
.
canAttachStub
(
)
)
{
if
(
scopeChain
-
>
is
<
GlobalObject
>
(
)
)
{
if
(
!
cache
.
attachGlobal
(
cx
outerScript
ion
scopeChain
)
)
return
nullptr
;
}
else
if
(
IsCacheableNonGlobalScopeChain
(
scopeChain
holder
)
)
{
if
(
!
cache
.
attachNonGlobal
(
cx
outerScript
ion
scopeChain
holder
)
)
return
nullptr
;
}
else
{
JitSpew
(
JitSpew_IonIC
"
BINDNAME
uncacheable
scope
chain
"
)
;
}
}
return
holder
;
}
bool
NameIC
:
:
attachReadSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
scopeChain
HandleObject
holderBase
HandleNativeObject
holder
HandleShape
shape
)
{
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
Label
failures
;
StubAttacher
attacher
(
*
this
)
;
Register
scratchReg
=
outputReg
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
masm
.
mov
(
scopeChainReg
(
)
scratchReg
)
;
GenerateScopeChainGuards
(
masm
scopeChain
holderBase
scratchReg
&
failures
true
)
;
GenerateReadSlot
(
cx
ion
masm
attacher
CheckLexical
holderBase
holder
shape
scratchReg
outputReg
(
)
failures
.
used
(
)
?
&
failures
:
nullptr
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
generic
"
JS
:
:
TrackedOutcome
:
:
ICNameStub_ReadSlot
)
;
}
static
bool
IsCacheableScopeChain
(
JSObject
*
scopeChain
JSObject
*
obj
)
{
JSObject
*
obj2
=
scopeChain
;
while
(
obj2
)
{
if
(
!
IsCacheableNonGlobalScope
(
obj2
)
&
&
!
obj2
-
>
is
<
GlobalObject
>
(
)
)
return
false
;
if
(
obj2
-
>
is
<
GlobalObject
>
(
)
|
|
obj2
=
=
obj
)
break
;
obj2
=
obj2
-
>
enclosingScope
(
)
;
}
return
obj
=
=
obj2
;
}
static
bool
IsCacheableNameReadSlot
(
HandleObject
scopeChain
HandleObject
obj
HandleObject
holder
HandleShape
shape
jsbytecode
*
pc
const
TypedOrValueRegister
&
output
)
{
if
(
!
shape
)
return
false
;
if
(
!
obj
-
>
isNative
(
)
)
return
false
;
if
(
obj
-
>
is
<
GlobalObject
>
(
)
)
{
if
(
!
IsCacheableGetPropReadSlotForIon
(
obj
holder
shape
)
&
&
!
IsCacheableNoProperty
(
obj
holder
shape
pc
output
)
)
return
false
;
}
else
if
(
obj
-
>
is
<
ModuleEnvironmentObject
>
(
)
)
{
return
false
;
}
else
if
(
obj
-
>
is
<
CallObject
>
(
)
)
{
MOZ_ASSERT
(
obj
=
=
holder
)
;
if
(
!
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
}
else
{
return
false
;
}
return
IsCacheableScopeChain
(
scopeChain
obj
)
;
}
bool
NameIC
:
:
attachCallGetter
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
scopeChain
HandleObject
obj
HandleObject
holder
HandleShape
shape
void
*
returnAddr
)
{
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
StubAttacher
attacher
(
*
this
)
;
Label
failures
;
Register
scratchReg
=
outputReg
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
masm
.
mov
(
scopeChainReg
(
)
scratchReg
)
;
GenerateScopeChainGuards
(
masm
scopeChain
obj
scratchReg
&
failures
true
)
;
if
(
!
GenerateCallGetter
(
cx
ion
masm
attacher
obj
holder
shape
liveRegs_
scratchReg
outputReg
(
)
returnAddr
failures
.
used
(
)
?
&
failures
:
nullptr
)
)
{
return
false
;
}
const
char
*
attachKind
=
"
name
getter
"
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
attachKind
JS
:
:
TrackedOutcome
:
:
ICNameStub_CallGetter
)
;
}
static
bool
IsCacheableNameCallGetter
(
HandleObject
scopeChain
HandleObject
obj
HandleObject
holder
HandleShape
shape
)
{
if
(
!
shape
)
return
false
;
if
(
!
obj
-
>
is
<
GlobalObject
>
(
)
)
return
false
;
if
(
!
IsCacheableScopeChain
(
scopeChain
obj
)
)
return
false
;
return
IsCacheableGetPropCallNative
(
obj
holder
shape
)
|
|
IsCacheableGetPropCallPropertyOp
(
obj
holder
shape
)
|
|
IsCacheableGetPropCallScripted
(
obj
holder
shape
)
;
}
bool
NameIC
:
:
attachTypeOfNoProperty
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
scopeChain
)
{
MacroAssembler
masm
(
cx
ion
outerScript
profilerLeavePc_
)
;
Label
failures
;
StubAttacher
attacher
(
*
this
)
;
Register
scratchReg
=
outputReg
(
)
.
valueReg
(
)
.
scratchReg
(
)
;
masm
.
movePtr
(
scopeChainReg
(
)
scratchReg
)
;
JSObject
*
tobj
=
scopeChain
;
while
(
true
)
{
GenerateScopeChainGuard
(
masm
tobj
scratchReg
nullptr
&
failures
)
;
if
(
tobj
-
>
is
<
GlobalObject
>
(
)
)
break
;
tobj
=
&
tobj
-
>
as
<
ScopeObject
>
(
)
.
enclosingScope
(
)
;
masm
.
extractObject
(
Address
(
scratchReg
ScopeObject
:
:
offsetOfEnclosingScope
(
)
)
scratchReg
)
;
}
masm
.
moveValue
(
UndefinedValue
(
)
outputReg
(
)
.
valueReg
(
)
)
;
attacher
.
jumpRejoin
(
masm
)
;
masm
.
bind
(
&
failures
)
;
attacher
.
jumpNextStub
(
masm
)
;
return
linkAndAttachStub
(
cx
masm
attacher
ion
"
generic
"
JS
:
:
TrackedOutcome
:
:
ICNameStub_TypeOfNoProperty
)
;
}
static
bool
IsCacheableNameNoProperty
(
HandleObject
scopeChain
HandleObject
obj
HandleObject
holder
HandleShape
shape
jsbytecode
*
pc
NameIC
&
cache
)
{
if
(
cache
.
isTypeOf
(
)
&
&
!
shape
)
{
MOZ_ASSERT
(
!
obj
)
;
MOZ_ASSERT
(
!
holder
)
;
MOZ_ASSERT
(
scopeChain
)
;
MOZ_ASSERT
(
cache
.
outputReg
(
)
.
hasValue
(
)
)
;
MOZ_ASSERT
(
pc
!
=
nullptr
)
;
return
true
;
}
return
false
;
}
bool
NameIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
scopeChain
MutableHandleValue
vp
)
{
IonScript
*
ion
=
outerScript
-
>
ionScript
(
)
;
NameIC
&
cache
=
ion
-
>
getCache
(
cacheIndex
)
.
toName
(
)
;
RootedPropertyName
name
(
cx
cache
.
name
(
)
)
;
RootedScript
script
(
cx
)
;
jsbytecode
*
pc
;
cache
.
getScriptedLocation
(
&
script
&
pc
)
;
RootedObject
obj
(
cx
)
;
RootedObject
holder
(
cx
)
;
RootedShape
shape
(
cx
)
;
if
(
!
LookupName
(
cx
name
scopeChain
&
obj
&
holder
&
shape
)
)
return
false
;
if
(
cache
.
isTypeOf
(
)
)
{
if
(
!
FetchName
<
true
>
(
cx
obj
holder
name
shape
vp
)
)
return
false
;
}
else
{
if
(
!
FetchName
<
false
>
(
cx
obj
holder
name
shape
vp
)
)
return
false
;
}
if
(
cache
.
canAttachStub
(
)
)
{
if
(
IsCacheableNameReadSlot
(
scopeChain
obj
holder
shape
pc
cache
.
outputReg
(
)
)
)
{
if
(
!
cache
.
attachReadSlot
(
cx
outerScript
ion
scopeChain
obj
holder
.
as
<
NativeObject
>
(
)
shape
)
)
{
return
false
;
}
}
else
if
(
IsCacheableNameCallGetter
(
scopeChain
obj
holder
shape
)
)
{
void
*
returnAddr
=
GetReturnAddressToIonCode
(
cx
)
;
if
(
!
cache
.
attachCallGetter
(
cx
outerScript
ion
scopeChain
obj
holder
shape
returnAddr
)
)
{
return
false
;
}
}
else
if
(
IsCacheableNameNoProperty
(
scopeChain
obj
holder
shape
pc
cache
)
)
{
if
(
!
cache
.
attachTypeOfNoProperty
(
cx
outerScript
ion
scopeChain
)
)
return
false
;
}
}
TypeScript
:
:
Monitor
(
cx
script
pc
vp
)
;
return
true
;
}
