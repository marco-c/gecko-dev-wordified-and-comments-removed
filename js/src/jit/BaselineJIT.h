#
ifndef
jit_BaselineJIT_h
#
define
jit_BaselineJIT_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
Bailouts
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
namespace
js
{
namespace
jit
{
class
StackValue
;
class
BaselineICEntry
;
class
ICStub
;
class
ControlFlowGraph
;
class
PCMappingSlotInfo
{
uint8_t
slotInfo_
;
public
:
enum
SlotLocation
{
SlotInR0
=
0
SlotInR1
=
1
SlotIgnore
=
3
}
;
PCMappingSlotInfo
(
)
:
slotInfo_
(
0
)
{
}
explicit
PCMappingSlotInfo
(
uint8_t
slotInfo
)
:
slotInfo_
(
slotInfo
)
{
}
static
inline
bool
ValidSlotLocation
(
SlotLocation
loc
)
{
return
(
loc
=
=
SlotInR0
)
|
|
(
loc
=
=
SlotInR1
)
|
|
(
loc
=
=
SlotIgnore
)
;
}
static
SlotLocation
ToSlotLocation
(
const
StackValue
*
stackVal
)
;
inline
static
PCMappingSlotInfo
MakeSlotInfo
(
)
{
return
PCMappingSlotInfo
(
0
)
;
}
inline
static
PCMappingSlotInfo
MakeSlotInfo
(
SlotLocation
topSlotLoc
)
{
MOZ_ASSERT
(
ValidSlotLocation
(
topSlotLoc
)
)
;
return
PCMappingSlotInfo
(
1
|
(
topSlotLoc
<
<
2
)
)
;
}
inline
static
PCMappingSlotInfo
MakeSlotInfo
(
SlotLocation
topSlotLoc
SlotLocation
nextSlotLoc
)
{
MOZ_ASSERT
(
ValidSlotLocation
(
topSlotLoc
)
)
;
MOZ_ASSERT
(
ValidSlotLocation
(
nextSlotLoc
)
)
;
return
PCMappingSlotInfo
(
2
|
(
topSlotLoc
<
<
2
)
|
(
nextSlotLoc
)
<
<
4
)
;
}
inline
unsigned
numUnsynced
(
)
const
{
return
slotInfo_
&
0x3
;
}
inline
SlotLocation
topSlotLocation
(
)
const
{
return
static_cast
<
SlotLocation
>
(
(
slotInfo_
>
>
2
)
&
0x3
)
;
}
inline
SlotLocation
nextSlotLocation
(
)
const
{
return
static_cast
<
SlotLocation
>
(
(
slotInfo_
>
>
4
)
&
0x3
)
;
}
inline
uint8_t
toByte
(
)
const
{
return
slotInfo_
;
}
}
;
struct
PCMappingIndexEntry
{
uint32_t
pcOffset
;
uint32_t
nativeOffset
;
uint32_t
bufferOffset
;
}
;
struct
DependentWasmImport
{
wasm
:
:
Instance
*
instance
;
size_t
importIndex
;
DependentWasmImport
(
wasm
:
:
Instance
&
instance
size_t
importIndex
)
:
instance
(
&
instance
)
importIndex
(
importIndex
)
{
}
}
;
struct
BaselineScript
{
public
:
#
if
defined
(
JS_CODEGEN_ARM
)
static
const
uint32_t
MAX_JSSCRIPT_LENGTH
=
1000000u
;
#
else
static
const
uint32_t
MAX_JSSCRIPT_LENGTH
=
0x0fffffffu
;
#
endif
static
const
uint32_t
MAX_JSSCRIPT_SLOTS
=
0xffffu
;
private
:
HeapPtr
<
JitCode
*
>
method_
;
HeapPtr
<
EnvironmentObject
*
>
templateEnv_
;
FallbackICStubSpace
fallbackStubSpace_
;
Vector
<
DependentWasmImport
>
*
dependentWasmImports_
;
uint32_t
prologueOffset_
;
uint32_t
epilogueOffset_
;
uint32_t
profilerEnterToggleOffset_
;
uint32_t
profilerExitToggleOffset_
;
#
ifdef
JS_TRACE_LOGGING
#
ifdef
DEBUG
bool
traceLoggerScriptsEnabled_
;
bool
traceLoggerEngineEnabled_
;
#
endif
TraceLoggerEvent
traceLoggerScriptEvent_
;
#
endif
uint32_t
postDebugPrologueOffset_
;
public
:
enum
Flag
{
NEEDS_ARGS_OBJ
=
1
<
<
0
ACTIVE
=
1
<
<
1
MODIFIES_ARGUMENTS
=
1
<
<
2
HAS_DEBUG_INSTRUMENTATION
=
1
<
<
3
ION_COMPILED_OR_INLINED
=
1
<
<
4
PROFILER_INSTRUMENTATION_ON
=
1
<
<
5
USES_ENVIRONMENT_CHAIN
=
1
<
<
6
}
;
private
:
uint32_t
flags_
;
private
:
void
trace
(
JSTracer
*
trc
)
;
uint32_t
icEntriesOffset_
;
uint32_t
icEntries_
;
uint32_t
pcMappingIndexOffset_
;
uint32_t
pcMappingIndexEntries_
;
uint32_t
pcMappingOffset_
;
uint32_t
pcMappingSize_
;
uint32_t
bytecodeTypeMapOffset_
;
uint32_t
yieldEntriesOffset_
;
uint32_t
traceLoggerToggleOffsetsOffset_
;
uint32_t
numTraceLoggerToggleOffsets_
;
uint16_t
inlinedBytecodeLength_
;
uint8_t
maxInliningDepth_
;
IonBuilder
*
pendingBuilder_
;
ControlFlowGraph
*
controlFlowGraph_
;
public
:
BaselineScript
(
uint32_t
prologueOffset
uint32_t
epilogueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
uint32_t
postDebugPrologueOffset
)
;
~
BaselineScript
(
)
{
MOZ_ASSERT
(
fallbackStubSpace_
.
isEmpty
(
)
)
;
}
static
BaselineScript
*
New
(
JSScript
*
jsscript
uint32_t
prologueOffset
uint32_t
epilogueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
uint32_t
postDebugPrologueOffset
size_t
icEntries
size_t
pcMappingIndexEntries
size_t
pcMappingSize
size_t
bytecodeTypeMapEntries
size_t
yieldEntries
size_t
traceLoggerToggleOffsetEntries
)
;
static
void
Trace
(
JSTracer
*
trc
BaselineScript
*
script
)
;
static
void
Destroy
(
FreeOp
*
fop
BaselineScript
*
script
)
;
void
purgeOptimizedStubs
(
Zone
*
zone
)
;
static
inline
size_t
offsetOfMethod
(
)
{
return
offsetof
(
BaselineScript
method_
)
;
}
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
size_t
*
fallbackStubs
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
;
*
fallbackStubs
+
=
fallbackStubSpace_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
active
(
)
const
{
return
flags_
&
ACTIVE
;
}
void
setActive
(
)
{
flags_
|
=
ACTIVE
;
}
void
resetActive
(
)
{
flags_
&
=
~
ACTIVE
;
}
void
setNeedsArgsObj
(
)
{
flags_
|
=
NEEDS_ARGS_OBJ
;
}
void
setModifiesArguments
(
)
{
flags_
|
=
MODIFIES_ARGUMENTS
;
}
bool
modifiesArguments
(
)
{
return
flags_
&
MODIFIES_ARGUMENTS
;
}
void
setHasDebugInstrumentation
(
)
{
flags_
|
=
HAS_DEBUG_INSTRUMENTATION
;
}
bool
hasDebugInstrumentation
(
)
const
{
return
flags_
&
HAS_DEBUG_INSTRUMENTATION
;
}
void
setIonCompiledOrInlined
(
)
{
flags_
|
=
ION_COMPILED_OR_INLINED
;
}
void
clearIonCompiledOrInlined
(
)
{
flags_
&
=
~
ION_COMPILED_OR_INLINED
;
}
bool
ionCompiledOrInlined
(
)
const
{
return
flags_
&
ION_COMPILED_OR_INLINED
;
}
void
setUsesEnvironmentChain
(
)
{
flags_
|
=
USES_ENVIRONMENT_CHAIN
;
}
bool
usesEnvironmentChain
(
)
const
{
return
flags_
&
USES_ENVIRONMENT_CHAIN
;
}
uint32_t
prologueOffset
(
)
const
{
return
prologueOffset_
;
}
uint8_t
*
prologueEntryAddr
(
)
const
{
return
method_
-
>
raw
(
)
+
prologueOffset_
;
}
uint32_t
epilogueOffset
(
)
const
{
return
epilogueOffset_
;
}
uint8_t
*
epilogueEntryAddr
(
)
const
{
return
method_
-
>
raw
(
)
+
epilogueOffset_
;
}
uint32_t
postDebugPrologueOffset
(
)
const
{
return
postDebugPrologueOffset_
;
}
uint8_t
*
postDebugPrologueAddr
(
)
const
{
return
method_
-
>
raw
(
)
+
postDebugPrologueOffset_
;
}
BaselineICEntry
*
icEntryList
(
)
{
return
(
BaselineICEntry
*
)
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
icEntriesOffset_
)
;
}
uint8_t
*
*
yieldEntryList
(
)
{
return
(
uint8_t
*
*
)
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
yieldEntriesOffset_
)
;
}
PCMappingIndexEntry
*
pcMappingIndexEntryList
(
)
{
return
(
PCMappingIndexEntry
*
)
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
pcMappingIndexOffset_
)
;
}
uint8_t
*
pcMappingData
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
pcMappingOffset_
;
}
FallbackICStubSpace
*
fallbackStubSpace
(
)
{
return
&
fallbackStubSpace_
;
}
JitCode
*
method
(
)
const
{
return
method_
;
}
void
setMethod
(
JitCode
*
code
)
{
MOZ_ASSERT
(
!
method_
)
;
method_
=
code
;
}
EnvironmentObject
*
templateEnvironment
(
)
const
{
return
templateEnv_
;
}
void
setTemplateEnvironment
(
EnvironmentObject
*
templateEnv
)
{
MOZ_ASSERT
(
!
templateEnv_
)
;
templateEnv_
=
templateEnv
;
}
bool
containsCodeAddress
(
uint8_t
*
addr
)
const
{
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
BaselineICEntry
*
maybeICEntryFromPCOffset
(
uint32_t
pcOffset
)
;
BaselineICEntry
*
maybeICEntryFromPCOffset
(
uint32_t
pcOffset
BaselineICEntry
*
prevLookedUpEntry
)
;
BaselineICEntry
&
icEntry
(
size_t
index
)
;
BaselineICEntry
&
icEntryFromReturnOffset
(
CodeOffset
returnOffset
)
;
BaselineICEntry
&
icEntryFromPCOffset
(
uint32_t
pcOffset
)
;
BaselineICEntry
&
icEntryFromPCOffset
(
uint32_t
pcOffset
BaselineICEntry
*
prevLookedUpEntry
)
;
BaselineICEntry
&
callVMEntryFromPCOffset
(
uint32_t
pcOffset
)
;
BaselineICEntry
&
stackCheckICEntry
(
bool
earlyCheck
)
;
BaselineICEntry
&
warmupCountICEntry
(
)
;
BaselineICEntry
&
icEntryFromReturnAddress
(
uint8_t
*
returnAddr
)
;
uint8_t
*
returnAddressForIC
(
const
BaselineICEntry
&
ent
)
;
size_t
numICEntries
(
)
const
{
return
icEntries_
;
}
void
copyICEntries
(
JSScript
*
script
const
BaselineICEntry
*
entries
)
;
void
adoptFallbackStubs
(
FallbackICStubSpace
*
stubSpace
)
;
void
copyYieldAndAwaitEntries
(
JSScript
*
script
Vector
<
uint32_t
>
&
yieldAndAwaitOffsets
)
;
PCMappingIndexEntry
&
pcMappingIndexEntry
(
size_t
index
)
;
CompactBufferReader
pcMappingReader
(
size_t
indexEntry
)
;
size_t
numPCMappingIndexEntries
(
)
const
{
return
pcMappingIndexEntries_
;
}
void
copyPCMappingIndexEntries
(
const
PCMappingIndexEntry
*
entries
)
;
void
copyPCMappingEntries
(
const
CompactBufferWriter
&
entries
)
;
uint8_t
*
nativeCodeForPC
(
JSScript
*
script
jsbytecode
*
pc
PCMappingSlotInfo
*
slotInfo
=
nullptr
)
;
jsbytecode
*
approximatePcForNativeAddress
(
JSScript
*
script
uint8_t
*
nativeAddress
)
;
MOZ_MUST_USE
bool
addDependentWasmImport
(
JSContext
*
cx
wasm
:
:
Instance
&
instance
uint32_t
idx
)
;
void
removeDependentWasmImport
(
wasm
:
:
Instance
&
instance
uint32_t
idx
)
;
void
unlinkDependentWasmImports
(
FreeOp
*
fop
)
;
void
clearDependentWasmImports
(
)
;
void
toggleDebugTraps
(
JSScript
*
script
jsbytecode
*
pc
)
;
void
toggleProfilerInstrumentation
(
bool
enable
)
;
bool
isProfilerInstrumentationOn
(
)
const
{
return
flags_
&
PROFILER_INSTRUMENTATION_ON
;
}
#
ifdef
JS_TRACE_LOGGING
void
initTraceLogger
(
JSScript
*
script
const
Vector
<
CodeOffset
>
&
offsets
)
;
void
toggleTraceLoggerScripts
(
JSScript
*
script
bool
enable
)
;
void
toggleTraceLoggerEngine
(
bool
enable
)
;
static
size_t
offsetOfTraceLoggerScriptEvent
(
)
{
return
offsetof
(
BaselineScript
traceLoggerScriptEvent_
)
;
}
uint32_t
*
traceLoggerToggleOffsets
(
)
{
MOZ_ASSERT
(
traceLoggerToggleOffsetsOffset_
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
traceLoggerToggleOffsetsOffset_
)
;
}
#
endif
void
noteAccessedGetter
(
uint32_t
pcOffset
)
;
void
noteHasDenseAdd
(
uint32_t
pcOffset
)
;
static
size_t
offsetOfFlags
(
)
{
return
offsetof
(
BaselineScript
flags_
)
;
}
static
size_t
offsetOfYieldEntriesOffset
(
)
{
return
offsetof
(
BaselineScript
yieldEntriesOffset_
)
;
}
static
void
writeBarrierPre
(
Zone
*
zone
BaselineScript
*
script
)
;
uint32_t
*
bytecodeTypeMap
(
)
{
MOZ_ASSERT
(
bytecodeTypeMapOffset_
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
bytecodeTypeMapOffset_
)
;
}
uint8_t
maxInliningDepth
(
)
const
{
return
maxInliningDepth_
;
}
void
setMaxInliningDepth
(
uint32_t
depth
)
{
MOZ_ASSERT
(
depth
<
=
UINT8_MAX
)
;
maxInliningDepth_
=
depth
;
}
void
resetMaxInliningDepth
(
)
{
maxInliningDepth_
=
UINT8_MAX
;
}
uint16_t
inlinedBytecodeLength
(
)
const
{
return
inlinedBytecodeLength_
;
}
void
setInlinedBytecodeLength
(
uint32_t
len
)
{
if
(
len
>
UINT16_MAX
)
len
=
UINT16_MAX
;
inlinedBytecodeLength_
=
len
;
}
bool
hasPendingIonBuilder
(
)
const
{
return
!
!
pendingBuilder_
;
}
js
:
:
jit
:
:
IonBuilder
*
pendingIonBuilder
(
)
{
MOZ_ASSERT
(
hasPendingIonBuilder
(
)
)
;
return
pendingBuilder_
;
}
void
setPendingIonBuilder
(
JSRuntime
*
rt
JSScript
*
script
js
:
:
jit
:
:
IonBuilder
*
builder
)
{
MOZ_ASSERT
(
script
-
>
baselineScript
(
)
=
=
this
)
;
MOZ_ASSERT
(
!
builder
|
|
!
hasPendingIonBuilder
(
)
)
;
if
(
script
-
>
isIonCompilingOffThread
(
)
)
script
-
>
setIonScript
(
rt
ION_PENDING_SCRIPT
)
;
pendingBuilder_
=
builder
;
clearDependentWasmImports
(
)
;
script
-
>
updateJitCodeRaw
(
rt
)
;
}
void
removePendingIonBuilder
(
JSRuntime
*
rt
JSScript
*
script
)
{
setPendingIonBuilder
(
rt
script
nullptr
)
;
if
(
script
-
>
maybeIonScript
(
)
=
=
ION_PENDING_SCRIPT
)
script
-
>
setIonScript
(
rt
nullptr
)
;
}
const
ControlFlowGraph
*
controlFlowGraph
(
)
const
{
return
controlFlowGraph_
;
}
void
setControlFlowGraph
(
ControlFlowGraph
*
controlFlowGraph
)
{
controlFlowGraph_
=
controlFlowGraph
;
}
}
;
static_assert
(
sizeof
(
BaselineScript
)
%
sizeof
(
uintptr_t
)
=
=
0
"
The
data
attached
to
the
script
must
be
aligned
for
fast
JIT
access
.
"
)
;
inline
bool
IsBaselineEnabled
(
JSContext
*
cx
)
{
#
ifdef
JS_CODEGEN_NONE
return
false
;
#
else
return
cx
-
>
options
(
)
.
baseline
(
)
;
#
endif
}
MethodStatus
CanEnterBaselineMethod
(
JSContext
*
cx
RunState
&
state
)
;
MethodStatus
CanEnterBaselineAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
)
;
JitExecStatus
EnterBaselineAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
jsbytecode
*
pc
)
;
void
FinishDiscardBaselineScript
(
FreeOp
*
fop
JSScript
*
script
)
;
void
AddSizeOfBaselineData
(
JSScript
*
script
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
size_t
*
fallbackStubs
)
;
void
ToggleBaselineProfiling
(
JSRuntime
*
runtime
bool
enable
)
;
void
ToggleBaselineTraceLoggerScripts
(
JSRuntime
*
runtime
bool
enable
)
;
void
ToggleBaselineTraceLoggerEngine
(
JSRuntime
*
runtime
bool
enable
)
;
struct
BaselineBailoutInfo
{
uint8_t
*
incomingStack
;
uint8_t
*
copyStackTop
;
uint8_t
*
copyStackBottom
;
uint32_t
setR0
;
Value
valueR0
;
uint32_t
setR1
;
Value
valueR1
;
void
*
resumeFramePtr
;
void
*
resumeAddr
;
jsbytecode
*
resumePC
;
jsbytecode
*
tryPC
;
jsbytecode
*
faultPC
;
ICStub
*
monitorStub
;
uint32_t
numFrames
;
bool
checkGlobalDeclarationConflicts
;
BailoutKind
bailoutKind
;
}
;
uint32_t
BailoutIonToBaseline
(
JSContext
*
cx
JitActivation
*
activation
const
JSJitFrameIter
&
iter
bool
invalidate
BaselineBailoutInfo
*
*
bailoutInfo
const
ExceptionBailoutInfo
*
exceptionInfo
)
;
void
MarkActiveBaselineScripts
(
Zone
*
zone
)
;
MethodStatus
BaselineCompile
(
JSContext
*
cx
JSScript
*
script
bool
forceDebugInstrumentation
=
false
)
;
static
const
unsigned
BASELINE_MAX_ARGS_LENGTH
=
20000
;
}
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
jit
:
:
BaselineScript
>
{
explicit
DeletePolicy
(
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
void
operator
(
)
(
const
js
:
:
jit
:
:
BaselineScript
*
script
)
;
private
:
JSRuntime
*
rt_
;
}
;
}
#
endif
