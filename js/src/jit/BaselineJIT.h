#
ifndef
jit_BaselineJIT_h
#
define
jit_BaselineJIT_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
Bailouts
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
namespace
js
{
namespace
jit
{
class
ICEntry
;
class
ICStub
;
class
ReturnAddressEntry
;
class
BasePCToNativeEntry
{
uint32_t
pcOffset_
;
uint32_t
nativeOffset_
;
public
:
BasePCToNativeEntry
(
uint32_t
pcOffset
uint32_t
nativeOffset
)
:
pcOffset_
(
pcOffset
)
nativeOffset_
(
nativeOffset
)
{
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
uint32_t
nativeOffset
(
)
const
{
return
nativeOffset_
;
}
}
;
class
ResumeOffsetEntry
:
public
BasePCToNativeEntry
{
public
:
using
BasePCToNativeEntry
:
:
BasePCToNativeEntry
;
}
;
using
ResumeOffsetEntryVector
=
Vector
<
ResumeOffsetEntry
16
SystemAllocPolicy
>
;
#
if
defined
(
JS_CODEGEN_ARM
)
static
constexpr
uint32_t
BaselineMaxScriptLength
=
1000000u
;
#
else
static
constexpr
uint32_t
BaselineMaxScriptLength
=
0x0fffffffu
;
#
endif
static
constexpr
uint32_t
BaselineMaxScriptSlots
=
0xffffu
;
class
RetAddrEntry
{
uint32_t
returnOffset_
;
uint32_t
pcOffset_
:
28
;
public
:
enum
class
Kind
:
uint32_t
{
IC
PrologueIC
CallVM
NonOpCallVM
StackCheck
InterruptCheck
DebugTrap
DebugPrologue
DebugAfterYield
DebugEpilogue
Invalid
}
;
private
:
uint32_t
kind_
:
4
;
public
:
RetAddrEntry
(
uint32_t
pcOffset
Kind
kind
CodeOffset
retOffset
)
:
returnOffset_
(
uint32_t
(
retOffset
.
offset
(
)
)
)
pcOffset_
(
pcOffset
)
kind_
(
uint32_t
(
kind
)
)
{
MOZ_ASSERT
(
returnOffset_
=
=
retOffset
.
offset
(
)
"
retOffset
must
fit
in
returnOffset_
"
)
;
MOZ_ASSERT
(
pcOffset_
=
=
pcOffset
)
;
static_assert
(
BaselineMaxScriptLength
<
=
(
1u
<
<
28
)
-
1
)
;
MOZ_ASSERT
(
pcOffset
<
=
BaselineMaxScriptLength
)
;
MOZ_ASSERT
(
kind
<
Kind
:
:
Invalid
)
;
MOZ_ASSERT
(
this
-
>
kind
(
)
=
=
kind
"
kind
must
fit
in
kind_
bit
field
"
)
;
}
CodeOffset
returnOffset
(
)
const
{
return
CodeOffset
(
returnOffset_
)
;
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
jsbytecode
*
pc
(
JSScript
*
script
)
const
{
return
script
-
>
offsetToPC
(
pcOffset_
)
;
}
Kind
kind
(
)
const
{
MOZ_ASSERT
(
kind_
<
uint32_t
(
Kind
:
:
Invalid
)
)
;
return
Kind
(
kind_
)
;
}
}
;
class
alignas
(
uintptr_t
)
BaselineScript
final
:
public
TrailingArray
{
private
:
HeapPtr
<
JitCode
*
>
method_
=
nullptr
;
IonCompileTask
*
pendingIonCompileTask_
=
nullptr
;
uint32_t
warmUpCheckPrologueOffset_
=
0
;
uint32_t
profilerEnterToggleOffset_
=
0
;
uint32_t
profilerExitToggleOffset_
=
0
;
#
ifdef
JS_TRACE_LOGGING
#
ifdef
DEBUG
bool
traceLoggerScriptsEnabled_
=
false
;
bool
traceLoggerEngineEnabled_
=
false
;
#
endif
TraceLoggerEvent
traceLoggerScriptEvent_
=
{
}
;
#
endif
private
:
Offset
resumeEntriesOffset_
=
0
;
Offset
retAddrEntriesOffset_
=
0
;
Offset
osrEntriesOffset_
=
0
;
Offset
debugTrapEntriesOffset_
=
0
;
Offset
traceLoggerToggleOffsetsOffset_
=
0
;
Offset
allocBytes_
=
0
;
uint8_t
flags_
=
0
;
public
:
enum
Flag
{
HAS_DEBUG_INSTRUMENTATION
=
1
<
<
0
PROFILER_INSTRUMENTATION_ON
=
1
<
<
1
}
;
class
OSREntry
:
public
BasePCToNativeEntry
{
public
:
using
BasePCToNativeEntry
:
:
BasePCToNativeEntry
;
}
;
class
DebugTrapEntry
:
public
BasePCToNativeEntry
{
public
:
using
BasePCToNativeEntry
:
:
BasePCToNativeEntry
;
}
;
private
:
Offset
resumeEntriesOffset
(
)
const
{
return
resumeEntriesOffset_
;
}
Offset
retAddrEntriesOffset
(
)
const
{
return
retAddrEntriesOffset_
;
}
Offset
osrEntriesOffset
(
)
const
{
return
osrEntriesOffset_
;
}
Offset
debugTrapEntriesOffset
(
)
const
{
return
debugTrapEntriesOffset_
;
}
Offset
traceLoggerToggleOffsetsOffset
(
)
const
{
return
traceLoggerToggleOffsetsOffset_
;
}
Offset
endOffset
(
)
const
{
return
allocBytes_
;
}
BaselineScript
(
uint32_t
warmUpCheckPrologueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
)
:
warmUpCheckPrologueOffset_
(
warmUpCheckPrologueOffset
)
profilerEnterToggleOffset_
(
profilerEnterToggleOffset
)
profilerExitToggleOffset_
(
profilerExitToggleOffset
)
{
}
template
<
typename
T
>
mozilla
:
:
Span
<
T
>
makeSpan
(
Offset
start
Offset
end
)
{
return
mozilla
:
:
Span
{
offsetToPointer
<
T
>
(
start
)
numElements
<
T
>
(
start
end
)
}
;
}
mozilla
:
:
Span
<
uint8_t
*
>
resumeEntryList
(
)
{
return
makeSpan
<
uint8_t
*
>
(
resumeEntriesOffset
(
)
retAddrEntriesOffset
(
)
)
;
}
mozilla
:
:
Span
<
RetAddrEntry
>
retAddrEntries
(
)
{
return
makeSpan
<
RetAddrEntry
>
(
retAddrEntriesOffset
(
)
osrEntriesOffset
(
)
)
;
}
mozilla
:
:
Span
<
OSREntry
>
osrEntries
(
)
{
return
makeSpan
<
OSREntry
>
(
osrEntriesOffset
(
)
debugTrapEntriesOffset
(
)
)
;
}
mozilla
:
:
Span
<
DebugTrapEntry
>
debugTrapEntries
(
)
{
return
makeSpan
<
DebugTrapEntry
>
(
debugTrapEntriesOffset
(
)
traceLoggerToggleOffsetsOffset
(
)
)
;
}
#
ifdef
JS_TRACE_LOGGING
mozilla
:
:
Span
<
uint32_t
>
traceLoggerToggleOffsets
(
)
{
return
makeSpan
<
uint32_t
>
(
traceLoggerToggleOffsetsOffset
(
)
endOffset
(
)
)
;
}
#
endif
public
:
static
BaselineScript
*
New
(
JSContext
*
cx
uint32_t
warmUpCheckPrologueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
size_t
retAddrEntries
size_t
osrEntries
size_t
debugTrapEntries
size_t
resumeEntries
size_t
traceLoggerToggleOffsetEntries
)
;
static
void
Destroy
(
JSFreeOp
*
fop
BaselineScript
*
script
)
;
void
trace
(
JSTracer
*
trc
)
;
static
inline
size_t
offsetOfMethod
(
)
{
return
offsetof
(
BaselineScript
method_
)
;
}
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
;
}
void
setHasDebugInstrumentation
(
)
{
flags_
|
=
HAS_DEBUG_INSTRUMENTATION
;
}
bool
hasDebugInstrumentation
(
)
const
{
return
flags_
&
HAS_DEBUG_INSTRUMENTATION
;
}
uint8_t
*
warmUpCheckPrologueAddr
(
)
const
{
return
method_
-
>
raw
(
)
+
warmUpCheckPrologueOffset_
;
}
JitCode
*
method
(
)
const
{
return
method_
;
}
void
setMethod
(
JitCode
*
code
)
{
MOZ_ASSERT
(
!
method_
)
;
method_
=
code
;
}
bool
containsCodeAddress
(
uint8_t
*
addr
)
const
{
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
uint8_t
*
returnAddressForEntry
(
const
RetAddrEntry
&
ent
)
;
const
RetAddrEntry
&
retAddrEntryFromPCOffset
(
uint32_t
pcOffset
RetAddrEntry
:
:
Kind
kind
)
;
const
RetAddrEntry
&
prologueRetAddrEntry
(
RetAddrEntry
:
:
Kind
kind
)
;
const
RetAddrEntry
&
retAddrEntryFromReturnOffset
(
CodeOffset
returnOffset
)
;
const
RetAddrEntry
&
retAddrEntryFromReturnAddress
(
uint8_t
*
returnAddr
)
;
uint8_t
*
nativeCodeForOSREntry
(
uint32_t
pcOffset
)
;
void
copyRetAddrEntries
(
const
RetAddrEntry
*
entries
)
;
void
copyOSREntries
(
const
OSREntry
*
entries
)
;
void
copyDebugTrapEntries
(
const
DebugTrapEntry
*
entries
)
;
void
computeResumeNativeOffsets
(
JSScript
*
script
const
ResumeOffsetEntryVector
&
entries
)
;
jsbytecode
*
approximatePcForNativeAddress
(
JSScript
*
script
uint8_t
*
nativeAddress
)
;
void
toggleDebugTraps
(
JSScript
*
script
jsbytecode
*
pc
)
;
void
toggleProfilerInstrumentation
(
bool
enable
)
;
bool
isProfilerInstrumentationOn
(
)
const
{
return
flags_
&
PROFILER_INSTRUMENTATION_ON
;
}
#
ifdef
JS_TRACE_LOGGING
void
initTraceLogger
(
JSScript
*
script
const
Vector
<
CodeOffset
>
&
offsets
)
;
void
toggleTraceLoggerScripts
(
JSScript
*
script
bool
enable
)
;
void
toggleTraceLoggerEngine
(
bool
enable
)
;
static
size_t
offsetOfTraceLoggerScriptEvent
(
)
{
return
offsetof
(
BaselineScript
traceLoggerScriptEvent_
)
;
}
#
endif
static
size_t
offsetOfResumeEntriesOffset
(
)
{
static_assert
(
sizeof
(
Offset
)
=
=
sizeof
(
uint32_t
)
"
JIT
expect
Offset
to
be
uint32_t
"
)
;
return
offsetof
(
BaselineScript
resumeEntriesOffset_
)
;
}
static
void
writeBarrierPre
(
Zone
*
zone
BaselineScript
*
script
)
;
bool
hasPendingIonCompileTask
(
)
const
{
return
!
!
pendingIonCompileTask_
;
}
js
:
:
jit
:
:
IonCompileTask
*
pendingIonCompileTask
(
)
{
MOZ_ASSERT
(
hasPendingIonCompileTask
(
)
)
;
return
pendingIonCompileTask_
;
}
void
setPendingIonCompileTask
(
JSRuntime
*
rt
JSScript
*
script
js
:
:
jit
:
:
IonCompileTask
*
task
)
;
void
removePendingIonCompileTask
(
JSRuntime
*
rt
JSScript
*
script
)
;
size_t
allocBytes
(
)
const
{
return
allocBytes_
;
}
}
;
static_assert
(
sizeof
(
BaselineScript
)
%
sizeof
(
uintptr_t
)
=
=
0
"
The
data
attached
to
the
script
must
be
aligned
for
fast
JIT
access
.
"
)
;
enum
class
BaselineTier
{
Interpreter
Compiler
}
;
template
<
BaselineTier
Tier
>
MethodStatus
CanEnterBaselineMethod
(
JSContext
*
cx
RunState
&
state
)
;
MethodStatus
CanEnterBaselineInterpreterAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
)
;
JitExecStatus
EnterBaselineInterpreterAtBranch
(
JSContext
*
cx
InterpreterFrame
*
fp
jsbytecode
*
pc
)
;
bool
CanBaselineInterpretScript
(
JSScript
*
script
)
;
bool
BaselineCompileFromBaselineInterpreter
(
JSContext
*
cx
BaselineFrame
*
frame
uint8_t
*
*
res
)
;
void
FinishDiscardBaselineScript
(
JSFreeOp
*
fop
JSScript
*
script
)
;
void
AddSizeOfBaselineData
(
JSScript
*
script
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
)
;
void
ToggleBaselineProfiling
(
JSContext
*
cx
bool
enable
)
;
void
ToggleBaselineTraceLoggerScripts
(
JSRuntime
*
runtime
bool
enable
)
;
void
ToggleBaselineTraceLoggerEngine
(
JSRuntime
*
runtime
bool
enable
)
;
struct
alignas
(
uintptr_t
)
BaselineBailoutInfo
{
uint8_t
*
incomingStack
=
nullptr
;
uint8_t
*
copyStackTop
=
nullptr
;
uint8_t
*
copyStackBottom
=
nullptr
;
void
*
resumeFramePtr
=
nullptr
;
void
*
resumeAddr
=
nullptr
;
jsbytecode
*
monitorPC
=
nullptr
;
jsbytecode
*
tryPC
=
nullptr
;
jsbytecode
*
faultPC
=
nullptr
;
uint32_t
numFrames
=
0
;
uint32_t
frameSizeOfInnerMostFrame
=
0
;
mozilla
:
:
Maybe
<
BailoutKind
>
bailoutKind
=
{
}
;
BaselineBailoutInfo
(
)
=
default
;
BaselineBailoutInfo
(
const
BaselineBailoutInfo
&
)
=
default
;
void
operator
=
(
const
BaselineBailoutInfo
&
)
=
delete
;
}
;
MOZ_MUST_USE
bool
BailoutIonToBaseline
(
JSContext
*
cx
JitActivation
*
activation
const
JSJitFrameIter
&
iter
BaselineBailoutInfo
*
*
bailoutInfo
const
ExceptionBailoutInfo
*
exceptionInfo
)
;
MethodStatus
BaselineCompile
(
JSContext
*
cx
JSScript
*
script
bool
forceDebugInstrumentation
=
false
)
;
static
const
unsigned
BASELINE_MAX_ARGS_LENGTH
=
20000
;
class
BaselineInterpreter
{
public
:
struct
CallVMOffsets
{
uint32_t
debugPrologueOffset
=
0
;
uint32_t
debugEpilogueOffset
=
0
;
uint32_t
debugAfterYieldOffset
=
0
;
}
;
struct
ICReturnOffset
{
uint32_t
offset
;
JSOp
op
;
ICReturnOffset
(
uint32_t
offset
JSOp
op
)
:
offset
(
offset
)
op
(
op
)
{
}
}
;
using
ICReturnOffsetVector
=
Vector
<
ICReturnOffset
0
SystemAllocPolicy
>
;
private
:
JitCode
*
code_
=
nullptr
;
uint32_t
interpretOpOffset_
=
0
;
uint32_t
interpretOpNoDebugTrapOffset_
=
0
;
uint32_t
bailoutPrologueOffset_
=
0
;
uint32_t
profilerEnterToggleOffset_
=
0
;
uint32_t
profilerExitToggleOffset_
=
0
;
uint32_t
debugTrapHandlerOffset_
=
0
;
using
CodeOffsetVector
=
Vector
<
uint32_t
0
SystemAllocPolicy
>
;
CodeOffsetVector
debugInstrumentationOffsets_
;
CodeOffsetVector
debugTrapOffsets_
;
CodeOffsetVector
codeCoverageOffsets_
;
ICReturnOffsetVector
icReturnOffsets_
;
CallVMOffsets
callVMOffsets_
;
uint8_t
*
codeAtOffset
(
uint32_t
offset
)
const
{
MOZ_ASSERT
(
offset
>
0
)
;
MOZ_ASSERT
(
offset
<
code_
-
>
instructionsSize
(
)
)
;
return
codeRaw
(
)
+
offset
;
}
public
:
BaselineInterpreter
(
)
=
default
;
BaselineInterpreter
(
const
BaselineInterpreter
&
)
=
delete
;
void
operator
=
(
const
BaselineInterpreter
&
)
=
delete
;
void
init
(
JitCode
*
code
uint32_t
interpretOpOffset
uint32_t
interpretOpNoDebugTrapOffset
uint32_t
bailoutPrologueOffset
uint32_t
profilerEnterToggleOffset
uint32_t
profilerExitToggleOffset
uint32_t
debugTrapHandlerOffset
CodeOffsetVector
&
&
debugInstrumentationOffsets
CodeOffsetVector
&
&
debugTrapOffsets
CodeOffsetVector
&
&
codeCoverageOffsets
ICReturnOffsetVector
&
&
icReturnOffsets
const
CallVMOffsets
&
callVMOffsets
)
;
uint8_t
*
codeRaw
(
)
const
{
return
code_
-
>
raw
(
)
;
}
uint8_t
*
retAddrForDebugPrologueCallVM
(
)
const
{
return
codeAtOffset
(
callVMOffsets_
.
debugPrologueOffset
)
;
}
uint8_t
*
retAddrForDebugEpilogueCallVM
(
)
const
{
return
codeAtOffset
(
callVMOffsets_
.
debugEpilogueOffset
)
;
}
uint8_t
*
retAddrForDebugAfterYieldCallVM
(
)
const
{
return
codeAtOffset
(
callVMOffsets_
.
debugAfterYieldOffset
)
;
}
uint8_t
*
bailoutPrologueEntryAddr
(
)
const
{
return
codeAtOffset
(
bailoutPrologueOffset_
)
;
}
uint8_t
*
retAddrForIC
(
JSOp
op
)
const
;
TrampolinePtr
interpretOpAddr
(
)
const
{
return
TrampolinePtr
(
codeAtOffset
(
interpretOpOffset_
)
)
;
}
TrampolinePtr
interpretOpNoDebugTrapAddr
(
)
const
{
return
TrampolinePtr
(
codeAtOffset
(
interpretOpNoDebugTrapOffset_
)
)
;
}
void
toggleProfilerInstrumentation
(
bool
enable
)
;
void
toggleDebuggerInstrumentation
(
bool
enable
)
;
void
toggleCodeCoverageInstrumentationUnchecked
(
bool
enable
)
;
void
toggleCodeCoverageInstrumentation
(
bool
enable
)
;
}
;
MOZ_MUST_USE
bool
GenerateBaselineInterpreter
(
JSContext
*
cx
BaselineInterpreter
&
interpreter
)
;
inline
bool
IsBaselineJitEnabled
(
JSContext
*
cx
)
{
if
(
MOZ_UNLIKELY
(
!
IsBaselineInterpreterEnabled
(
)
)
)
{
return
false
;
}
if
(
MOZ_LIKELY
(
JitOptions
.
baselineJit
)
)
{
return
true
;
}
if
(
JitOptions
.
jitForTrustedPrincipals
)
{
JS
:
:
Realm
*
realm
=
js
:
:
GetContextRealm
(
cx
)
;
return
realm
&
&
JS
:
:
GetRealmPrincipals
(
realm
)
&
&
JS
:
:
GetRealmPrincipals
(
realm
)
-
>
isSystemOrAddonPrincipal
(
)
;
}
return
false
;
}
}
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
jit
:
:
BaselineScript
>
{
explicit
DeletePolicy
(
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
void
operator
(
)
(
const
js
:
:
jit
:
:
BaselineScript
*
script
)
;
private
:
JSRuntime
*
rt_
;
}
;
}
#
endif
