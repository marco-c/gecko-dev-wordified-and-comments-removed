#
ifndef
jit_BytecodeAnalysis_h
#
define
jit_BytecodeAnalysis_h
#
include
"
jit
/
JitAllocPolicy
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
namespace
jit
{
struct
BytecodeInfo
{
static
const
uint16_t
MAX_STACK_DEPTH
=
0xffffU
;
uint16_t
stackDepth
;
bool
initialized
:
1
;
bool
jumpTarget
:
1
;
bool
loopHeadCanOsr
:
1
;
bool
hasResumeOffset
:
1
;
void
init
(
unsigned
depth
)
{
MOZ_ASSERT
(
depth
<
=
MAX_STACK_DEPTH
)
;
MOZ_ASSERT_IF
(
initialized
stackDepth
=
=
depth
)
;
initialized
=
true
;
stackDepth
=
depth
;
}
}
;
class
BytecodeAnalysis
{
JSScript
*
script_
;
Vector
<
BytecodeInfo
0
JitAllocPolicy
>
infos_
;
bool
hasTryFinally_
;
public
:
explicit
BytecodeAnalysis
(
TempAllocator
&
alloc
JSScript
*
script
)
;
MOZ_MUST_USE
bool
init
(
TempAllocator
&
alloc
)
;
BytecodeInfo
&
info
(
jsbytecode
*
pc
)
{
uint32_t
pcOffset
=
script_
-
>
pcToOffset
(
pc
)
;
MOZ_ASSERT
(
infos_
[
pcOffset
]
.
initialized
)
;
return
infos_
[
pcOffset
]
;
}
BytecodeInfo
*
maybeInfo
(
jsbytecode
*
pc
)
{
uint32_t
pcOffset
=
script_
-
>
pcToOffset
(
pc
)
;
if
(
infos_
[
pcOffset
]
.
initialized
)
{
return
&
infos_
[
pcOffset
]
;
}
return
nullptr
;
}
bool
hasTryFinally
(
)
const
{
return
hasTryFinally_
;
}
}
;
struct
IonBytecodeInfo
;
IonBytecodeInfo
AnalyzeBytecodeForIon
(
JSContext
*
cx
JSScript
*
script
)
;
}
}
#
endif
