#
include
"
jit
/
DominatorTree
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
static
MBasicBlock
*
IntersectDominators
(
MBasicBlock
*
block1
MBasicBlock
*
block2
)
{
MBasicBlock
*
finger1
=
block1
;
MBasicBlock
*
finger2
=
block2
;
MOZ_ASSERT
(
finger1
)
;
MOZ_ASSERT
(
finger2
)
;
while
(
finger1
-
>
id
(
)
!
=
finger2
-
>
id
(
)
)
{
while
(
finger1
-
>
id
(
)
>
finger2
-
>
id
(
)
)
{
MBasicBlock
*
idom
=
finger1
-
>
immediateDominator
(
)
;
if
(
idom
=
=
finger1
)
{
return
nullptr
;
}
finger1
=
idom
;
}
while
(
finger2
-
>
id
(
)
>
finger1
-
>
id
(
)
)
{
MBasicBlock
*
idom
=
finger2
-
>
immediateDominator
(
)
;
if
(
idom
=
=
finger2
)
{
return
nullptr
;
}
finger2
=
idom
;
}
}
return
finger1
;
}
static
void
ComputeImmediateDominators
(
MIRGraph
&
graph
)
{
MBasicBlock
*
startBlock
=
graph
.
entryBlock
(
)
;
startBlock
-
>
setImmediateDominator
(
startBlock
)
;
MBasicBlock
*
osrBlock
=
graph
.
osrBlock
(
)
;
if
(
osrBlock
)
{
osrBlock
-
>
setImmediateDominator
(
osrBlock
)
;
}
bool
changed
=
true
;
while
(
changed
)
{
changed
=
false
;
ReversePostorderIterator
block
=
graph
.
rpoBegin
(
)
;
for
(
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
block
-
>
immediateDominator
(
)
=
=
*
block
)
{
continue
;
}
if
(
MOZ_UNLIKELY
(
block
-
>
numPredecessors
(
)
=
=
0
)
)
{
block
-
>
setImmediateDominator
(
*
block
)
;
continue
;
}
MBasicBlock
*
newIdom
=
block
-
>
getPredecessor
(
0
)
;
for
(
size_t
i
=
1
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
i
)
;
if
(
pred
-
>
immediateDominator
(
)
=
=
nullptr
)
{
continue
;
}
newIdom
=
IntersectDominators
(
pred
newIdom
)
;
if
(
newIdom
=
=
nullptr
)
{
block
-
>
setImmediateDominator
(
*
block
)
;
changed
=
true
;
break
;
}
}
if
(
newIdom
&
&
block
-
>
immediateDominator
(
)
!
=
newIdom
)
{
block
-
>
setImmediateDominator
(
newIdom
)
;
changed
=
true
;
}
}
}
#
ifdef
DEBUG
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
MOZ_ASSERT
(
block
-
>
immediateDominator
(
)
!
=
nullptr
)
;
}
#
endif
}
bool
jit
:
:
BuildDominatorTree
(
MIRGraph
&
graph
)
{
MOZ_ASSERT
(
graph
.
canBuildDominators
(
)
)
;
ComputeImmediateDominators
(
graph
)
;
Vector
<
MBasicBlock
*
4
JitAllocPolicy
>
worklist
(
graph
.
alloc
(
)
)
;
for
(
PostorderIterator
i
(
graph
.
poBegin
(
)
)
;
i
!
=
graph
.
poEnd
(
)
;
i
+
+
)
{
MBasicBlock
*
child
=
*
i
;
MBasicBlock
*
parent
=
child
-
>
immediateDominator
(
)
;
child
-
>
addNumDominated
(
1
)
;
if
(
child
=
=
parent
)
{
if
(
!
worklist
.
append
(
child
)
)
{
return
false
;
}
continue
;
}
if
(
!
parent
-
>
addImmediatelyDominatedBlock
(
child
)
)
{
return
false
;
}
parent
-
>
addNumDominated
(
child
-
>
numDominated
(
)
)
;
}
#
ifdef
DEBUG
if
(
!
graph
.
osrBlock
(
)
)
{
MOZ_ASSERT
(
graph
.
entryBlock
(
)
-
>
numDominated
(
)
=
=
graph
.
numBlocks
(
)
)
;
}
#
endif
size_t
index
=
0
;
while
(
!
worklist
.
empty
(
)
)
{
MBasicBlock
*
block
=
worklist
.
popCopy
(
)
;
block
-
>
setDomIndex
(
index
)
;
if
(
!
worklist
.
append
(
block
-
>
immediatelyDominatedBlocksBegin
(
)
block
-
>
immediatelyDominatedBlocksEnd
(
)
)
)
{
return
false
;
}
index
+
+
;
}
return
true
;
}
void
jit
:
:
ClearDominatorTree
(
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
iter
=
graph
.
begin
(
)
;
iter
!
=
graph
.
end
(
)
;
iter
+
+
)
{
iter
-
>
clearDominatorInfo
(
)
;
}
}
