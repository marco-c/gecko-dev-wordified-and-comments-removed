#
ifndef
jit_IonAnalysis_h
#
define
jit_IonAnalysis_h
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
jit
/
JitAllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
class
JS_PUBLIC_API
GenericPrinter
;
class
PlainObject
;
namespace
jit
{
class
MBasicBlock
;
class
MCompare
;
class
MDefinition
;
class
MIRGenerator
;
class
MIRGraph
;
class
MTest
;
[
[
nodiscard
]
]
bool
PruneUnusedBranches
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
FoldTests
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
FoldEmptyBlocks
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
SplitCriticalEdges
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
OptimizeIteratorIndices
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
bool
IsUint32Type
(
const
MDefinition
*
def
)
;
enum
Observability
{
ConservativeObservability
AggressiveObservability
}
;
[
[
nodiscard
]
]
bool
EliminatePhis
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
Observability
observe
)
;
size_t
MarkLoopBlocks
(
MIRGraph
&
graph
MBasicBlock
*
header
bool
*
canOsr
)
;
void
UnmarkLoopBlocks
(
MIRGraph
&
graph
MBasicBlock
*
header
)
;
[
[
nodiscard
]
]
bool
MakeLoopsContiguous
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
EliminateTriviallyDeadResumePointOperands
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
EliminateDeadResumePointOperands
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
EliminateDeadCode
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
FoldLoadsWithUnbox
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
ApplyTypeInformation
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
;
void
RenumberBlocks
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
AccountForCFGChanges
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
bool
updateAliasAnalysis
bool
underValueNumberer
=
false
)
;
[
[
nodiscard
]
]
bool
RemoveUnmarkedBlocks
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
uint32_t
numMarkedBlocks
)
;
void
ClearDominatorTree
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
BuildDominatorTree
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
BuildPhiReverseMapping
(
MIRGraph
&
graph
)
;
void
AssertBasicGraphCoherency
(
MIRGraph
&
graph
bool
force
=
false
)
;
void
AssertGraphCoherency
(
MIRGraph
&
graph
bool
force
=
false
)
;
void
AssertExtendedGraphCoherency
(
MIRGraph
&
graph
bool
underValueNumberer
=
false
bool
force
=
false
)
;
[
[
nodiscard
]
]
bool
EliminateRedundantChecks
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
EliminateRedundantShapeGuards
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
EliminateRedundantGCBarriers
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
AddKeepAliveInstructions
(
MIRGraph
&
graph
)
;
[
[
nodiscard
]
]
bool
MarkLoadsUsedAsPropertyKeys
(
MIRGraph
&
graph
)
;
struct
SimpleLinearSum
{
MDefinition
*
term
;
int32_t
constant
;
SimpleLinearSum
(
MDefinition
*
term
int32_t
constant
)
:
term
(
term
)
constant
(
constant
)
{
}
}
;
enum
class
MathSpace
{
Modulo
Infinite
Unknown
}
;
SimpleLinearSum
ExtractLinearSum
(
MDefinition
*
ins
MathSpace
space
=
MathSpace
:
:
Unknown
int32_t
recursionDepth
=
0
)
;
[
[
nodiscard
]
]
bool
ExtractLinearInequality
(
MTest
*
test
BranchDirection
direction
SimpleLinearSum
*
plhs
MDefinition
*
*
prhs
bool
*
plessEqual
)
;
struct
LinearTerm
{
MDefinition
*
term
;
int32_t
scale
;
LinearTerm
(
MDefinition
*
term
int32_t
scale
)
:
term
(
term
)
scale
(
scale
)
{
}
}
;
class
LinearSum
{
public
:
explicit
LinearSum
(
TempAllocator
&
alloc
)
:
terms_
(
alloc
)
constant_
(
0
)
{
}
LinearSum
(
const
LinearSum
&
other
)
:
terms_
(
other
.
terms_
.
allocPolicy
(
)
)
constant_
(
other
.
constant_
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
terms_
.
appendAll
(
other
.
terms_
)
)
{
oomUnsafe
.
crash
(
"
LinearSum
:
:
LinearSum
"
)
;
}
}
[
[
nodiscard
]
]
bool
multiply
(
int32_t
scale
)
;
[
[
nodiscard
]
]
bool
add
(
const
LinearSum
&
other
int32_t
scale
=
1
)
;
[
[
nodiscard
]
]
bool
add
(
SimpleLinearSum
other
int32_t
scale
=
1
)
;
[
[
nodiscard
]
]
bool
add
(
MDefinition
*
term
int32_t
scale
)
;
[
[
nodiscard
]
]
bool
add
(
int32_t
constant
)
;
[
[
nodiscard
]
]
bool
divide
(
uint32_t
scale
)
;
int32_t
constant
(
)
const
{
return
constant_
;
}
size_t
numTerms
(
)
const
{
return
terms_
.
length
(
)
;
}
LinearTerm
term
(
size_t
i
)
const
{
return
terms_
[
i
]
;
}
void
replaceTerm
(
size_t
i
MDefinition
*
def
)
{
terms_
[
i
]
.
term
=
def
;
}
void
dump
(
GenericPrinter
&
out
)
const
;
void
dump
(
)
const
;
private
:
Vector
<
LinearTerm
2
JitAllocPolicy
>
terms_
;
int32_t
constant_
;
}
;
MDefinition
*
ConvertLinearSum
(
TempAllocator
&
alloc
MBasicBlock
*
block
const
LinearSum
&
sum
BailoutKind
bailoutKind
)
;
bool
DeadIfUnused
(
const
MDefinition
*
def
)
;
bool
DeadIfUnusedAllowEffectful
(
const
MDefinition
*
def
)
;
bool
IsDiscardable
(
const
MDefinition
*
def
)
;
bool
IsDiscardableAllowEffectful
(
const
MDefinition
*
def
)
;
class
CompileInfo
;
void
DumpMIRExpressions
(
GenericPrinter
&
out
MIRGraph
&
graph
const
CompileInfo
&
info
const
char
*
phase
)
;
void
DumpMIRDefinition
(
GenericPrinter
&
out
MDefinition
*
def
)
;
}
}
#
endif
