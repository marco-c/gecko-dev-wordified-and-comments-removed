#
include
"
jit
/
Jit
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
CalleeToken
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitCommon
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Activation
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
static
EnterJitStatus
JS_HAZ_JSNATIVE_CALLER
EnterJit
(
JSContext
*
cx
RunState
&
state
uint8_t
*
code
)
{
MOZ_ASSERT
(
code
)
;
MOZ_ASSERT
(
code
!
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
interpreterStub
(
)
.
value
)
;
MOZ_ASSERT
(
IsBaselineInterpreterEnabled
(
)
)
;
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
EnterJitStatus
:
:
Error
;
}
#
ifdef
DEBUG
mozilla
:
:
Maybe
<
JS
:
:
AutoAssertNoGC
>
nogc
;
nogc
.
emplace
(
cx
)
;
#
endif
JSScript
*
script
=
state
.
script
(
)
;
size_t
numActualArgs
;
bool
constructing
;
size_t
maxArgc
;
Value
*
maxArgv
;
JSObject
*
envChain
;
CalleeToken
calleeToken
;
if
(
state
.
isInvoke
(
)
)
{
const
CallArgs
&
args
=
state
.
asInvoke
(
)
-
>
args
(
)
;
numActualArgs
=
args
.
length
(
)
;
if
(
TooManyActualArguments
(
numActualArgs
)
)
{
if
(
numActualArgs
>
BASELINE_MAX_ARGS_LENGTH
)
{
return
EnterJitStatus
:
:
NotEntered
;
}
if
(
script
-
>
hasBaselineScript
(
)
)
{
code
=
script
-
>
baselineScript
(
)
-
>
method
(
)
-
>
raw
(
)
;
}
else
{
code
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
baselineInterpreter
(
)
.
codeRaw
(
)
;
}
}
constructing
=
state
.
asInvoke
(
)
-
>
constructing
(
)
;
maxArgc
=
args
.
length
(
)
+
1
;
maxArgv
=
args
.
array
(
)
-
1
;
envChain
=
nullptr
;
calleeToken
=
CalleeToToken
(
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
constructing
)
;
unsigned
numFormals
=
script
-
>
function
(
)
-
>
nargs
(
)
;
if
(
numFormals
>
numActualArgs
)
{
code
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
.
value
;
}
}
else
{
numActualArgs
=
0
;
constructing
=
false
;
if
(
script
-
>
isDirectEvalInFunction
(
)
)
{
maxArgc
=
1
;
maxArgv
=
state
.
asExecute
(
)
-
>
addressOfNewTarget
(
)
;
}
else
{
maxArgc
=
0
;
maxArgv
=
nullptr
;
}
envChain
=
state
.
asExecute
(
)
-
>
environmentChain
(
)
;
calleeToken
=
CalleeToToken
(
state
.
script
(
)
)
;
}
MOZ_ASSERT_IF
(
constructing
maxArgv
[
0
]
.
isObject
(
)
|
|
maxArgv
[
0
]
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
;
RootedValue
result
(
cx
Int32Value
(
numActualArgs
)
)
;
{
AssertRealmUnchanged
aru
(
cx
)
;
ActivationEntryMonitor
entryMonitor
(
cx
calleeToken
)
;
JitActivation
activation
(
cx
)
;
EnterJitCode
enter
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
enterJit
(
)
;
#
ifdef
DEBUG
nogc
.
reset
(
)
;
#
endif
CALL_GENERATED_CODE
(
enter
code
maxArgc
maxArgv
nullptr
calleeToken
envChain
0
result
.
address
(
)
)
;
}
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
freeIonOsrTempData
(
)
;
if
(
result
.
isMagic
(
)
)
{
MOZ_ASSERT
(
result
.
isMagic
(
JS_ION_ERROR
)
)
;
return
EnterJitStatus
:
:
Error
;
}
if
(
constructing
&
&
result
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
maxArgv
[
0
]
.
isObject
(
)
)
;
result
=
maxArgv
[
0
]
;
}
state
.
setReturnValue
(
result
)
;
return
EnterJitStatus
:
:
Ok
;
}
EnterJitStatus
js
:
:
jit
:
:
MaybeEnterJit
(
JSContext
*
cx
RunState
&
state
)
{
if
(
!
IsBaselineInterpreterEnabled
(
)
)
{
return
EnterJitStatus
:
:
NotEntered
;
}
if
(
cx
-
>
insideDebuggerEvaluationWithOnNativeCallHook
)
{
return
EnterJitStatus
:
:
NotEntered
;
}
JSScript
*
script
=
state
.
script
(
)
;
uint8_t
*
code
=
script
-
>
jitCodeRaw
(
)
;
#
ifdef
JS_CACHEIR_SPEW
cx
-
>
spewer
(
)
.
enableSpewing
(
)
;
#
endif
do
{
if
(
script
-
>
hasJitScript
(
)
)
{
break
;
}
script
-
>
incWarmUpCounter
(
)
;
if
(
jit
:
:
IsIonEnabled
(
cx
)
)
{
jit
:
:
MethodStatus
status
=
jit
:
:
CanEnterIon
(
cx
state
)
;
if
(
status
=
=
jit
:
:
Method_Error
)
{
return
EnterJitStatus
:
:
Error
;
}
if
(
status
=
=
jit
:
:
Method_Compiled
)
{
code
=
script
-
>
jitCodeRaw
(
)
;
break
;
}
}
if
(
jit
:
:
IsBaselineJitEnabled
(
cx
)
)
{
jit
:
:
MethodStatus
status
=
jit
:
:
CanEnterBaselineMethod
<
BaselineTier
:
:
Compiler
>
(
cx
state
)
;
if
(
status
=
=
jit
:
:
Method_Error
)
{
return
EnterJitStatus
:
:
Error
;
}
if
(
status
=
=
jit
:
:
Method_Compiled
)
{
code
=
script
-
>
jitCodeRaw
(
)
;
break
;
}
}
if
(
IsBaselineInterpreterEnabled
(
)
)
{
jit
:
:
MethodStatus
status
=
jit
:
:
CanEnterBaselineMethod
<
BaselineTier
:
:
Interpreter
>
(
cx
state
)
;
if
(
status
=
=
jit
:
:
Method_Error
)
{
return
EnterJitStatus
:
:
Error
;
}
if
(
status
=
=
jit
:
:
Method_Compiled
)
{
code
=
script
-
>
jitCodeRaw
(
)
;
break
;
}
}
return
EnterJitStatus
:
:
NotEntered
;
}
while
(
false
)
;
#
ifdef
JS_CACHEIR_SPEW
cx
-
>
spewer
(
)
.
disableSpewing
(
)
;
#
endif
return
EnterJit
(
cx
state
code
)
;
}
