#
include
"
jit
/
WarpBuilderShared
.
h
"
#
include
"
jit
/
MIRBuilderShared
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
WarpBuilderShared
:
:
WarpBuilderShared
(
WarpSnapshot
&
snapshot
MIRGenerator
&
mirGen
MBasicBlock
*
current_
)
:
snapshot_
(
snapshot
)
mirGen_
(
mirGen
)
alloc_
(
mirGen
.
alloc
(
)
)
current
(
current_
)
{
}
bool
WarpBuilderShared
:
:
resumeAfter
(
MInstruction
*
ins
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
ins
-
>
isEffectful
(
)
|
|
ins
-
>
isInt64ToBigInt
(
)
)
;
MOZ_ASSERT
(
!
ins
-
>
isMovable
(
)
)
;
MResumePoint
*
resumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
ins
-
>
block
(
)
loc
.
toRawBytecode
(
)
MResumePoint
:
:
ResumeAfter
)
;
if
(
!
resumePoint
)
{
return
false
;
}
ins
-
>
setResumePoint
(
resumePoint
)
;
return
true
;
}
MConstant
*
WarpBuilderShared
:
:
constant
(
const
Value
&
v
)
{
MOZ_ASSERT_IF
(
v
.
isString
(
)
v
.
toString
(
)
-
>
isAtom
(
)
)
;
MOZ_ASSERT_IF
(
v
.
isGCThing
(
)
!
IsInsideNursery
(
v
.
toGCThing
(
)
)
)
;
MConstant
*
cst
=
MConstant
:
:
New
(
alloc
(
)
v
)
;
current
-
>
add
(
cst
)
;
return
cst
;
}
void
WarpBuilderShared
:
:
pushConstant
(
const
Value
&
v
)
{
MConstant
*
cst
=
constant
(
v
)
;
current
-
>
push
(
cst
)
;
}
MCall
*
WarpBuilderShared
:
:
makeCall
(
CallInfo
&
callInfo
bool
needsThisCheck
WrappedFunction
*
target
bool
isDOMCall
)
{
MOZ_ASSERT
(
callInfo
.
argFormat
(
)
=
=
CallInfo
:
:
ArgFormat
:
:
Standard
)
;
MOZ_ASSERT_IF
(
needsThisCheck
!
target
)
;
MOZ_ASSERT_IF
(
isDOMCall
target
-
>
jitInfo
(
)
-
>
type
(
)
=
=
JSJitInfo
:
:
Method
)
;
DOMObjectKind
objKind
=
DOMObjectKind
:
:
Unknown
;
if
(
isDOMCall
)
{
const
JSClass
*
clasp
=
callInfo
.
thisArg
(
)
-
>
toGuardToClass
(
)
-
>
getClass
(
)
;
MOZ_ASSERT
(
clasp
-
>
isDOMClass
(
)
)
;
if
(
clasp
-
>
isNative
(
)
)
{
objKind
=
DOMObjectKind
:
:
Native
;
}
else
{
MOZ_ASSERT
(
clasp
-
>
isProxy
(
)
)
;
objKind
=
DOMObjectKind
:
:
Proxy
;
}
}
uint32_t
targetArgs
=
callInfo
.
argc
(
)
;
if
(
target
&
&
target
-
>
hasJitEntry
(
)
)
{
targetArgs
=
std
:
:
max
<
uint32_t
>
(
target
-
>
nargs
(
)
callInfo
.
argc
(
)
)
;
}
MCall
*
call
=
MCall
:
:
New
(
alloc
(
)
target
targetArgs
+
1
+
callInfo
.
constructing
(
)
callInfo
.
argc
(
)
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
isDOMCall
objKind
)
;
if
(
!
call
)
{
return
nullptr
;
}
if
(
callInfo
.
constructing
(
)
)
{
if
(
needsThisCheck
)
{
call
-
>
setNeedsThisCheck
(
)
;
}
call
-
>
addArg
(
targetArgs
+
1
callInfo
.
getNewTarget
(
)
)
;
}
MOZ_ASSERT_IF
(
target
&
&
targetArgs
>
callInfo
.
argc
(
)
target
-
>
hasJitEntry
(
)
)
;
for
(
uint32_t
i
=
targetArgs
;
i
>
callInfo
.
argc
(
)
;
i
-
-
)
{
MConstant
*
undef
=
constant
(
UndefinedValue
(
)
)
;
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
nullptr
;
}
call
-
>
addArg
(
i
undef
)
;
}
for
(
int32_t
i
=
callInfo
.
argc
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
call
-
>
addArg
(
i
+
1
callInfo
.
getArg
(
i
)
)
;
}
if
(
isDOMCall
)
{
call
-
>
computeMovable
(
)
;
}
call
-
>
addArg
(
0
callInfo
.
thisArg
(
)
)
;
call
-
>
initCallee
(
callInfo
.
callee
(
)
)
;
if
(
target
)
{
call
-
>
disableClassCheck
(
)
;
}
return
call
;
}
MInstruction
*
WarpBuilderShared
:
:
makeSpreadCall
(
CallInfo
&
callInfo
bool
isSameRealm
WrappedFunction
*
target
)
{
MOZ_ASSERT
(
!
callInfo
.
constructing
(
)
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
callInfo
.
arrayArg
(
)
)
;
current
-
>
add
(
elements
)
;
auto
*
apply
=
MApplyArray
:
:
New
(
alloc
(
)
target
callInfo
.
callee
(
)
elements
callInfo
.
thisArg
(
)
)
;
if
(
callInfo
.
ignoresReturnValue
(
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
if
(
isSameRealm
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
return
apply
;
}
