#
include
"
jit
/
WarpBuilderShared
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
WarpBuilderShared
:
:
WarpBuilderShared
(
WarpSnapshot
&
snapshot
MIRGenerator
&
mirGen
MBasicBlock
*
current_
)
:
snapshot_
(
snapshot
)
mirGen_
(
mirGen
)
alloc_
(
mirGen
.
alloc
(
)
)
current
(
current_
)
{
}
bool
WarpBuilderShared
:
:
resumeAfter
(
MInstruction
*
ins
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
ins
-
>
isEffectful
(
)
|
|
ins
-
>
isInt64ToBigInt
(
)
|
|
ins
-
>
isPostIntPtrConversion
(
)
)
;
MOZ_ASSERT
(
!
ins
-
>
isMovable
(
)
)
;
MResumePoint
*
resumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
ins
-
>
block
(
)
loc
.
toRawBytecode
(
)
ResumeMode
:
:
ResumeAfter
)
;
if
(
!
resumePoint
)
{
return
false
;
}
ins
-
>
setResumePoint
(
resumePoint
)
;
return
true
;
}
MConstant
*
WarpBuilderShared
:
:
constant
(
const
Value
&
v
)
{
MOZ_ASSERT_IF
(
v
.
isString
(
)
v
.
toString
(
)
-
>
isLinear
(
)
)
;
MOZ_ASSERT_IF
(
v
.
isGCThing
(
)
!
IsInsideNursery
(
v
.
toGCThing
(
)
)
)
;
MConstant
*
cst
=
MConstant
:
:
New
(
alloc
(
)
v
)
;
current
-
>
add
(
cst
)
;
return
cst
;
}
void
WarpBuilderShared
:
:
pushConstant
(
const
Value
&
v
)
{
MConstant
*
cst
=
constant
(
v
)
;
current
-
>
push
(
cst
)
;
}
MDefinition
*
WarpBuilderShared
:
:
unboxObjectInfallible
(
MDefinition
*
def
IsMovable
movable
)
{
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Object
)
{
return
def
;
}
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
MOZ_ASSERT
(
movable
=
=
IsMovable
:
:
No
)
;
auto
*
box
=
MBox
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
box
)
;
def
=
box
;
}
auto
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
def
MIRType
:
:
Object
MUnbox
:
:
Infallible
)
;
if
(
movable
=
=
IsMovable
:
:
No
)
{
unbox
-
>
setNotMovable
(
)
;
}
current
-
>
add
(
unbox
)
;
return
unbox
;
}
MCall
*
WarpBuilderShared
:
:
makeCall
(
CallInfo
&
callInfo
bool
needsThisCheck
WrappedFunction
*
target
bool
isDOMCall
)
{
auto
addUndefined
=
[
this
]
(
)
-
>
MConstant
*
{
return
constant
(
UndefinedValue
(
)
)
;
}
;
return
MakeCall
(
alloc
(
)
addUndefined
callInfo
needsThisCheck
target
isDOMCall
)
;
}
MInstruction
*
WarpBuilderShared
:
:
makeSpreadCall
(
CallInfo
&
callInfo
bool
needsThisCheck
bool
isSameRealm
WrappedFunction
*
target
)
{
MOZ_ASSERT
(
callInfo
.
argFormat
(
)
=
=
CallInfo
:
:
ArgFormat
:
:
Array
)
;
MOZ_ASSERT_IF
(
needsThisCheck
!
target
)
;
MElements
*
elements
=
MElements
:
:
New
(
alloc
(
)
callInfo
.
arrayArg
(
)
)
;
current
-
>
add
(
elements
)
;
if
(
callInfo
.
constructing
(
)
)
{
auto
*
newTarget
=
unboxObjectInfallible
(
callInfo
.
getNewTarget
(
)
)
;
auto
*
construct
=
MConstructArray
:
:
New
(
alloc
(
)
target
callInfo
.
callee
(
)
elements
callInfo
.
thisArg
(
)
newTarget
)
;
if
(
isSameRealm
)
{
construct
-
>
setNotCrossRealm
(
)
;
}
if
(
needsThisCheck
)
{
construct
-
>
setNeedsThisCheck
(
)
;
}
return
construct
;
}
auto
*
apply
=
MApplyArray
:
:
New
(
alloc
(
)
target
callInfo
.
callee
(
)
elements
callInfo
.
thisArg
(
)
)
;
if
(
callInfo
.
ignoresReturnValue
(
)
)
{
apply
-
>
setIgnoresReturnValue
(
)
;
}
if
(
isSameRealm
)
{
apply
-
>
setNotCrossRealm
(
)
;
}
MOZ_ASSERT
(
!
needsThisCheck
)
;
return
apply
;
}
