#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
jit
/
arm
/
Simulator
-
arm
.
h
"
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
CalleeToken
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
IonScript
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
mips32
/
Simulator
-
mips32
.
h
"
#
include
"
jit
/
mips64
/
Simulator
-
mips64
.
h
"
#
include
"
jit
/
RematerializedFrame
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
template
<
typename
T
>
class
BufferPointer
{
const
UniquePtr
<
BaselineBailoutInfo
>
&
header_
;
size_t
offset_
;
bool
heap_
;
public
:
BufferPointer
(
const
UniquePtr
<
BaselineBailoutInfo
>
&
header
size_t
offset
bool
heap
)
:
header_
(
header
)
offset_
(
offset
)
heap_
(
heap
)
{
}
T
*
get
(
)
const
{
BaselineBailoutInfo
*
header
=
header_
.
get
(
)
;
if
(
!
heap_
)
{
return
(
T
*
)
(
header
-
>
incomingStack
+
offset_
)
;
}
uint8_t
*
p
=
header
-
>
copyStackTop
-
offset_
;
MOZ_ASSERT
(
p
>
=
header
-
>
copyStackBottom
&
&
p
<
header
-
>
copyStackTop
)
;
return
(
T
*
)
p
;
}
void
set
(
const
T
&
value
)
{
*
get
(
)
=
value
;
}
const
T
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
MOZ_STACK_CLASS
BaselineStackBuilder
{
JSContext
*
cx_
;
JitFrameLayout
*
frame_
=
nullptr
;
SnapshotIterator
&
iter_
;
RootedValueVector
outermostFrameFormals_
;
size_t
bufferTotal_
=
1024
;
size_t
bufferAvail_
=
0
;
size_t
bufferUsed_
=
0
;
size_t
framePushed_
=
0
;
UniquePtr
<
BaselineBailoutInfo
>
header_
;
JSScript
*
script_
;
JSFunction
*
fun_
;
const
ExceptionBailoutInfo
*
excInfo_
;
ICScript
*
icScript_
;
jsbytecode
*
pc_
=
nullptr
;
JSOp
op_
=
JSOp
:
:
Nop
;
uint32_t
exprStackSlots_
=
0
;
void
*
prevFramePtr_
=
nullptr
;
Maybe
<
BufferPointer
<
BaselineFrame
>
>
blFrame_
;
size_t
frameNo_
=
0
;
JSFunction
*
nextCallee_
=
nullptr
;
gc
:
:
AutoSuppressGC
suppress_
;
public
:
BaselineStackBuilder
(
JSContext
*
cx
const
JSJitFrameIter
&
frameIter
SnapshotIterator
&
iter
const
ExceptionBailoutInfo
*
excInfo
)
;
[
[
nodiscard
]
]
bool
init
(
)
{
MOZ_ASSERT
(
!
header_
)
;
MOZ_ASSERT
(
bufferUsed_
=
=
0
)
;
uint8_t
*
bufferRaw
=
cx_
-
>
pod_calloc
<
uint8_t
>
(
bufferTotal_
)
;
if
(
!
bufferRaw
)
{
return
false
;
}
bufferAvail_
=
bufferTotal_
-
sizeof
(
BaselineBailoutInfo
)
;
header_
.
reset
(
new
(
bufferRaw
)
BaselineBailoutInfo
(
)
)
;
header_
-
>
incomingStack
=
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
;
header_
-
>
copyStackTop
=
bufferRaw
+
bufferTotal_
;
header_
-
>
copyStackBottom
=
header_
-
>
copyStackTop
;
return
true
;
}
[
[
nodiscard
]
]
bool
buildOneFrame
(
)
;
bool
done
(
)
;
void
nextFrame
(
)
;
JSScript
*
script
(
)
const
{
return
script_
;
}
size_t
frameNo
(
)
const
{
return
frameNo_
;
}
bool
isOutermostFrame
(
)
const
{
return
frameNo_
=
=
0
;
}
MutableHandleValueVector
outermostFrameFormals
(
)
{
return
&
outermostFrameFormals_
;
}
inline
JitFrameLayout
*
startFrame
(
)
{
return
frame_
;
}
BaselineBailoutInfo
*
info
(
)
{
MOZ_ASSERT
(
header_
)
;
return
header_
.
get
(
)
;
}
BaselineBailoutInfo
*
takeBuffer
(
)
{
MOZ_ASSERT
(
header_
)
;
return
header_
.
release
(
)
;
}
private
:
[
[
nodiscard
]
]
bool
initFrame
(
)
;
[
[
nodiscard
]
]
bool
buildBaselineFrame
(
)
;
[
[
nodiscard
]
]
bool
buildArguments
(
)
;
[
[
nodiscard
]
]
bool
buildFixedSlots
(
)
;
[
[
nodiscard
]
]
bool
fixUpCallerArgs
(
MutableHandleValueVector
savedCallerArgs
bool
*
fixedUp
)
;
[
[
nodiscard
]
]
bool
buildExpressionStack
(
)
;
[
[
nodiscard
]
]
bool
finishLastFrame
(
)
;
[
[
nodiscard
]
]
bool
prepareForNextFrame
(
HandleValueVector
savedCallerArgs
)
;
[
[
nodiscard
]
]
bool
finishOuterFrame
(
uint32_t
frameSize
)
;
[
[
nodiscard
]
]
bool
buildStubFrame
(
uint32_t
frameSize
HandleValueVector
savedCallerArgs
)
;
[
[
nodiscard
]
]
bool
buildRectifierFrame
(
uint32_t
actualArgc
size_t
endOfBaselineStubArgs
)
;
#
ifdef
DEBUG
[
[
nodiscard
]
]
bool
validateFrame
(
)
;
#
endif
#
ifdef
DEBUG
bool
envChainSlotCanBeOptimized
(
)
;
#
endif
bool
hasLiveStackValueAtDepth
(
uint32_t
stackSlotIndex
)
;
bool
isPrologueBailout
(
)
;
jsbytecode
*
getResumePC
(
)
;
void
*
getStubReturnAddress
(
)
;
uint32_t
exprStackSlots
(
)
const
{
return
exprStackSlots_
;
}
bool
catchingException
(
)
const
{
return
excInfo_
&
&
excInfo_
-
>
catchingException
(
)
&
&
excInfo_
-
>
frameNo
(
)
=
=
frameNo_
;
}
bool
propagatingIonExceptionForDebugMode
(
)
const
{
return
excInfo_
&
&
excInfo_
-
>
propagatingIonExceptionForDebugMode
(
)
;
}
void
*
prevFramePtr
(
)
const
{
return
prevFramePtr_
;
}
BufferPointer
<
BaselineFrame
>
&
blFrame
(
)
{
return
blFrame_
.
ref
(
)
;
}
void
setNextCallee
(
JSFunction
*
nextCallee
)
;
JSFunction
*
nextCallee
(
)
const
{
return
nextCallee_
;
}
jsbytecode
*
pc
(
)
const
{
return
pc_
;
}
bool
resumeAfter
(
)
const
{
return
!
catchingException
(
)
&
&
iter_
.
resumeAfter
(
)
;
}
bool
needToSaveCallerArgs
(
)
const
{
return
IsIonInlinableGetterOrSetterOp
(
op_
)
;
}
[
[
nodiscard
]
]
bool
enlarge
(
)
{
MOZ_ASSERT
(
header_
!
=
nullptr
)
;
if
(
bufferTotal_
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
2
>
:
:
value
)
{
ReportOutOfMemory
(
cx_
)
;
return
false
;
}
size_t
newSize
=
bufferTotal_
*
2
;
uint8_t
*
newBufferRaw
=
cx_
-
>
pod_calloc
<
uint8_t
>
(
newSize
)
;
if
(
!
newBufferRaw
)
{
return
false
;
}
using
BailoutInfoPtr
=
UniquePtr
<
BaselineBailoutInfo
>
;
BailoutInfoPtr
newHeader
(
new
(
newBufferRaw
)
BaselineBailoutInfo
(
*
header_
)
)
;
newHeader
-
>
copyStackTop
=
newBufferRaw
+
newSize
;
newHeader
-
>
copyStackBottom
=
newHeader
-
>
copyStackTop
-
bufferUsed_
;
memcpy
(
newHeader
-
>
copyStackBottom
header_
-
>
copyStackBottom
bufferUsed_
)
;
bufferTotal_
=
newSize
;
bufferAvail_
=
newSize
-
(
sizeof
(
BaselineBailoutInfo
)
+
bufferUsed_
)
;
header_
=
std
:
:
move
(
newHeader
)
;
return
true
;
}
void
resetFramePushed
(
)
{
framePushed_
=
0
;
}
size_t
framePushed
(
)
const
{
return
framePushed_
;
}
[
[
nodiscard
]
]
bool
subtract
(
size_t
size
const
char
*
info
=
nullptr
)
{
while
(
size
>
bufferAvail_
)
{
if
(
!
enlarge
(
)
)
{
return
false
;
}
}
header_
-
>
copyStackBottom
-
=
size
;
bufferAvail_
-
=
size
;
bufferUsed_
+
=
size
;
framePushed_
+
=
size
;
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
SUB_
%
03d
%
p
/
%
p
%
-
15s
"
(
int
)
size
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
)
;
}
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
write
(
const
T
&
t
)
{
MOZ_ASSERT
(
!
(
uintptr_t
(
&
t
)
>
=
uintptr_t
(
header_
-
>
copyStackBottom
)
&
&
uintptr_t
(
&
t
)
<
uintptr_t
(
header_
-
>
copyStackTop
)
)
"
Should
not
reference
memory
that
can
be
freed
"
)
;
if
(
!
subtract
(
sizeof
(
T
)
)
)
{
return
false
;
}
memcpy
(
header_
-
>
copyStackBottom
&
t
sizeof
(
T
)
)
;
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
writePtr
(
T
*
t
const
char
*
info
)
{
if
(
!
write
<
T
*
>
(
t
)
)
{
return
false
;
}
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_PTR
%
p
/
%
p
%
-
15s
%
p
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
t
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
writeWord
(
size_t
w
const
char
*
info
)
{
if
(
!
write
<
size_t
>
(
w
)
)
{
return
false
;
}
if
(
info
)
{
if
(
sizeof
(
size_t
)
=
=
4
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_WRD
%
p
/
%
p
%
-
15s
%
08zx
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
w
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_WRD
%
p
/
%
p
%
-
15s
%
016zx
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
w
)
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
writeValue
(
const
Value
&
val
const
char
*
info
)
{
if
(
!
write
<
Value
>
(
val
)
)
{
return
false
;
}
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_VAL
%
p
/
%
p
%
-
15s
%
016
"
PRIx64
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
*
(
(
uint64_t
*
)
&
val
)
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
maybeWritePadding
(
size_t
alignment
size_t
after
const
char
*
info
)
{
MOZ_ASSERT
(
framePushed_
%
sizeof
(
Value
)
=
=
0
)
;
MOZ_ASSERT
(
after
%
sizeof
(
Value
)
=
=
0
)
;
size_t
offset
=
ComputeByteAlignment
(
after
alignment
)
;
while
(
framePushed_
%
alignment
!
=
offset
)
{
if
(
!
writeValue
(
MagicValue
(
JS_ARG_POISON
)
info
)
)
{
return
false
;
}
}
return
true
;
}
void
setResumeFramePtr
(
void
*
resumeFramePtr
)
{
header_
-
>
resumeFramePtr
=
resumeFramePtr
;
}
void
setResumeAddr
(
void
*
resumeAddr
)
{
header_
-
>
resumeAddr
=
resumeAddr
;
}
void
setFrameSizeOfInnerMostFrame
(
uint32_t
size
)
{
header_
-
>
frameSizeOfInnerMostFrame
=
size
;
}
template
<
typename
T
>
BufferPointer
<
T
>
pointerAtStackOffset
(
size_t
offset
)
{
if
(
offset
<
bufferUsed_
)
{
offset
=
header_
-
>
copyStackTop
-
(
header_
-
>
copyStackBottom
+
offset
)
;
return
BufferPointer
<
T
>
(
header_
offset
true
)
;
}
return
BufferPointer
<
T
>
(
header_
offset
-
bufferUsed_
false
)
;
}
BufferPointer
<
Value
>
valuePointerAtStackOffset
(
size_t
offset
)
{
return
pointerAtStackOffset
<
Value
>
(
offset
)
;
}
inline
uint8_t
*
virtualPointerAtStackOffset
(
size_t
offset
)
{
if
(
offset
<
bufferUsed_
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
-
(
bufferUsed_
-
offset
)
;
}
return
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
+
(
offset
-
bufferUsed_
)
;
}
BufferPointer
<
JitFrameLayout
>
topFrameAddress
(
)
{
return
pointerAtStackOffset
<
JitFrameLayout
>
(
0
)
;
}
void
*
calculatePrevFramePtr
(
)
{
BufferPointer
<
JitFrameLayout
>
topFrame
=
topFrameAddress
(
)
;
FrameType
type
=
topFrame
-
>
prevType
(
)
;
if
(
JSJitFrameIter
:
:
isEntry
(
type
)
|
|
type
=
=
FrameType
:
:
IonJS
|
|
type
=
=
FrameType
:
:
IonICCall
)
{
return
nullptr
;
}
if
(
type
=
=
FrameType
:
:
BaselineJS
)
{
return
nullptr
;
}
if
(
type
=
=
FrameType
:
:
BaselineStub
)
{
size_t
offset
=
JitFrameLayout
:
:
Size
(
)
+
topFrame
-
>
prevFrameLocalSize
(
)
+
BaselineStubFrameLayout
:
:
reverseOffsetOfSavedFramePtr
(
)
;
return
virtualPointerAtStackOffset
(
offset
)
;
}
MOZ_ASSERT
(
type
=
=
FrameType
:
:
Rectifier
)
;
size_t
priorOffset
=
JitFrameLayout
:
:
Size
(
)
+
topFrame
-
>
prevFrameLocalSize
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
static_assert
(
BaselineFrameReg
=
=
FramePointer
)
;
priorOffset
-
=
sizeof
(
void
*
)
;
return
virtualPointerAtStackOffset
(
priorOffset
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
|
|
\
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_X64
)
BufferPointer
<
RectifierFrameLayout
>
priorFrame
=
pointerAtStackOffset
<
RectifierFrameLayout
>
(
priorOffset
)
;
FrameType
priorType
=
priorFrame
-
>
prevType
(
)
;
MOZ_ASSERT
(
JSJitFrameIter
:
:
isEntry
(
priorType
)
|
|
priorType
=
=
FrameType
:
:
IonJS
|
|
priorType
=
=
FrameType
:
:
BaselineStub
)
;
if
(
priorType
=
=
FrameType
:
:
IonJS
|
|
JSJitFrameIter
:
:
isEntry
(
priorType
)
)
{
return
nullptr
;
}
size_t
extraOffset
=
RectifierFrameLayout
:
:
Size
(
)
+
priorFrame
-
>
prevFrameLocalSize
(
)
+
BaselineStubFrameLayout
:
:
reverseOffsetOfSavedFramePtr
(
)
;
return
virtualPointerAtStackOffset
(
priorOffset
+
extraOffset
)
;
#
elif
defined
(
JS_CODEGEN_NONE
)
(
void
)
priorOffset
;
MOZ_CRASH
(
)
;
#
else
#
error
"
Bad
architecture
!
"
#
endif
}
}
;
BaselineStackBuilder
:
:
BaselineStackBuilder
(
JSContext
*
cx
const
JSJitFrameIter
&
frameIter
SnapshotIterator
&
iter
const
ExceptionBailoutInfo
*
excInfo
)
:
cx_
(
cx
)
frame_
(
static_cast
<
JitFrameLayout
*
>
(
frameIter
.
current
(
)
)
)
iter_
(
iter
)
outermostFrameFormals_
(
cx
)
script_
(
frameIter
.
script
(
)
)
fun_
(
frameIter
.
maybeCallee
(
)
)
excInfo_
(
excInfo
)
icScript_
(
script_
-
>
jitScript
(
)
-
>
icScript
(
)
)
suppress_
(
cx
)
{
MOZ_ASSERT
(
bufferTotal_
>
=
sizeof
(
BaselineBailoutInfo
)
)
;
}
bool
BaselineStackBuilder
:
:
initFrame
(
)
{
if
(
catchingException
(
)
)
{
exprStackSlots_
=
excInfo_
-
>
numExprSlots
(
)
;
}
else
{
uint32_t
totalFrameSlots
=
iter_
.
numAllocations
(
)
;
uint32_t
fixedSlots
=
script_
-
>
nfixed
(
)
;
uint32_t
argSlots
=
CountArgSlots
(
script_
fun_
)
;
exprStackSlots_
=
totalFrameSlots
-
fixedSlots
-
argSlots
;
}
resetFramePushed
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Unpacking
%
s
:
%
u
:
%
u
"
script_
-
>
filename
(
)
script_
-
>
lineno
(
)
script_
-
>
column
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
[
BASELINE
-
JS
FRAME
]
"
)
;
void
*
prevFramePtr
=
calculatePrevFramePtr
(
)
;
if
(
!
writePtr
(
prevFramePtr
"
PrevFramePtr
"
)
)
{
return
false
;
}
prevFramePtr_
=
virtualPointerAtStackOffset
(
0
)
;
pc_
=
catchingException
(
)
?
excInfo_
-
>
resumePC
(
)
:
script_
-
>
offsetToPC
(
iter_
.
pcOffset
(
)
)
;
op_
=
JSOp
(
*
pc_
)
;
return
true
;
}
void
BaselineStackBuilder
:
:
setNextCallee
(
JSFunction
*
nextCallee
)
{
nextCallee_
=
nextCallee
;
const
uint32_t
pcOff
=
script_
-
>
pcToOffset
(
pc_
)
;
icScript_
=
icScript_
-
>
findInlinedChild
(
pcOff
)
;
}
bool
BaselineStackBuilder
:
:
done
(
)
{
if
(
!
iter_
.
moreFrames
(
)
)
{
MOZ_ASSERT
(
!
nextCallee_
)
;
return
true
;
}
return
catchingException
(
)
;
}
void
BaselineStackBuilder
:
:
nextFrame
(
)
{
MOZ_ASSERT
(
nextCallee_
)
;
fun_
=
nextCallee_
;
script_
=
fun_
-
>
nonLazyScript
(
)
;
nextCallee_
=
nullptr
;
MOZ_ASSERT
(
script_
-
>
hasBaselineScript
(
)
)
;
frameNo_
+
+
;
iter_
.
nextInstruction
(
)
;
}
bool
BaselineStackBuilder
:
:
buildBaselineFrame
(
)
{
if
(
!
subtract
(
BaselineFrame
:
:
Size
(
)
"
BaselineFrame
"
)
)
{
return
false
;
}
blFrame_
.
reset
(
)
;
blFrame_
.
emplace
(
pointerAtStackOffset
<
BaselineFrame
>
(
0
)
)
;
uint32_t
flags
=
BaselineFrame
:
:
RUNNING_IN_INTERPRETER
;
if
(
script_
-
>
isDebuggee
(
)
)
{
flags
|
=
BaselineFrame
:
:
DEBUGGEE
;
}
JSObject
*
envChain
=
nullptr
;
Value
envChainSlot
=
iter_
.
read
(
)
;
if
(
envChainSlot
.
isObject
(
)
)
{
envChain
=
&
envChainSlot
.
toObject
(
)
;
if
(
fun_
&
&
fun_
-
>
needsFunctionEnvironmentObjects
(
)
)
{
MOZ_ASSERT
(
fun_
-
>
nonLazyScript
(
)
-
>
initialEnvironmentShape
(
)
)
;
MOZ_ASSERT
(
!
fun_
-
>
needsExtraBodyVarEnvironment
(
)
)
;
flags
|
=
BaselineFrame
:
:
HAS_INITIAL_ENV
;
}
}
else
{
MOZ_ASSERT
(
envChainSlot
.
isUndefined
(
)
|
|
envChainSlot
.
isMagic
(
JS_OPTIMIZED_OUT
)
)
;
MOZ_ASSERT
(
envChainSlotCanBeOptimized
(
)
)
;
if
(
fun_
)
{
envChain
=
fun_
-
>
environment
(
)
;
}
else
if
(
script_
-
>
module
(
)
)
{
envChain
=
script_
-
>
module
(
)
-
>
environment
(
)
;
}
else
{
MOZ_ASSERT
(
!
script_
-
>
isForEval
(
)
)
;
MOZ_ASSERT
(
!
script_
-
>
hasNonSyntacticScope
(
)
)
;
envChain
=
&
(
script_
-
>
global
(
)
.
lexicalEnvironment
(
)
)
;
}
}
MOZ_ASSERT
(
envChain
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
EnvChain
=
%
p
"
envChain
)
;
blFrame
(
)
-
>
setEnvironmentChain
(
envChain
)
;
Value
returnValue
=
UndefinedValue
(
)
;
if
(
script_
-
>
noScriptRval
(
)
)
{
iter_
.
skip
(
)
;
}
else
{
returnValue
=
iter_
.
read
(
)
;
flags
|
=
BaselineFrame
:
:
HAS_RVAL
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
ReturnValue
=
%
016
"
PRIx64
*
(
(
uint64_t
*
)
&
returnValue
)
)
;
blFrame
(
)
-
>
setReturnValue
(
returnValue
)
;
ArgumentsObject
*
argsObj
=
nullptr
;
if
(
script_
-
>
needsArgsObj
(
)
)
{
Value
maybeArgsObj
=
iter_
.
read
(
)
;
MOZ_ASSERT
(
maybeArgsObj
.
isObject
(
)
|
|
maybeArgsObj
.
isUndefined
(
)
|
|
maybeArgsObj
.
isMagic
(
JS_OPTIMIZED_OUT
)
)
;
if
(
maybeArgsObj
.
isObject
(
)
)
{
argsObj
=
&
maybeArgsObj
.
toObject
(
)
.
as
<
ArgumentsObject
>
(
)
;
}
}
blFrame
(
)
-
>
setFlags
(
flags
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
ICScript
=
%
p
"
icScript_
)
;
blFrame
(
)
-
>
setICScript
(
icScript_
)
;
if
(
argsObj
)
{
blFrame
(
)
-
>
initArgsObjUnchecked
(
*
argsObj
)
;
}
return
true
;
}
bool
BaselineStackBuilder
:
:
buildArguments
(
)
{
Value
thisv
=
iter_
.
read
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Is
function
!
"
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
thisv
=
%
016
"
PRIx64
*
(
(
uint64_t
*
)
&
thisv
)
)
;
size_t
thisvOffset
=
framePushed
(
)
+
JitFrameLayout
:
:
offsetOfThis
(
)
;
valuePointerAtStackOffset
(
thisvOffset
)
.
set
(
thisv
)
;
MOZ_ASSERT
(
iter_
.
numAllocations
(
)
>
=
CountArgSlots
(
script_
fun_
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
frame
slots
%
u
nargs
%
zu
nfixed
%
zu
"
iter_
.
numAllocations
(
)
fun_
-
>
nargs
(
)
script_
-
>
nfixed
(
)
)
;
bool
shouldStoreOutermostFormals
=
isOutermostFrame
(
)
&
&
!
script_
-
>
argsObjAliasesFormals
(
)
;
if
(
shouldStoreOutermostFormals
)
{
MOZ_ASSERT
(
outermostFrameFormals
(
)
.
empty
(
)
)
;
if
(
!
outermostFrameFormals
(
)
.
resize
(
fun_
-
>
nargs
(
)
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
fun_
-
>
nargs
(
)
;
i
+
+
)
{
Value
arg
=
iter_
.
read
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
arg
%
d
=
%
016
"
PRIx64
(
int
)
i
*
(
(
uint64_t
*
)
&
arg
)
)
;
if
(
!
isOutermostFrame
(
)
)
{
size_t
argOffset
=
framePushed
(
)
+
JitFrameLayout
:
:
offsetOfActualArg
(
i
)
;
valuePointerAtStackOffset
(
argOffset
)
.
set
(
arg
)
;
}
else
if
(
shouldStoreOutermostFormals
)
{
outermostFrameFormals
(
)
[
i
]
.
set
(
arg
)
;
}
else
{
}
}
return
true
;
}
bool
BaselineStackBuilder
:
:
buildFixedSlots
(
)
{
for
(
uint32_t
i
=
0
;
i
<
script_
-
>
nfixed
(
)
;
i
+
+
)
{
Value
slot
=
iter_
.
read
(
)
;
if
(
!
writeValue
(
slot
"
FixedValue
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
BaselineStackBuilder
:
:
fixUpCallerArgs
(
MutableHandleValueVector
savedCallerArgs
bool
*
fixedUp
)
{
MOZ_ASSERT
(
!
*
fixedUp
)
;
MOZ_ASSERT
(
!
IsSpreadOp
(
op_
)
)
;
if
(
op_
!
=
JSOp
:
:
FunCall
&
&
!
needToSaveCallerArgs
(
)
)
{
return
true
;
}
uint32_t
inlinedArgs
=
2
;
if
(
op_
=
=
JSOp
:
:
FunCall
)
{
inlinedArgs
+
=
GET_ARGC
(
pc_
)
>
0
?
GET_ARGC
(
pc_
)
-
1
:
0
;
}
else
{
MOZ_ASSERT
(
IsIonInlinableGetterOrSetterOp
(
op_
)
)
;
if
(
IsSetPropOp
(
op_
)
)
{
inlinedArgs
+
+
;
}
}
MOZ_ASSERT
(
inlinedArgs
<
=
exprStackSlots
(
)
)
;
uint32_t
liveStackSlots
=
exprStackSlots
(
)
-
inlinedArgs
;
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
%
u
expression
stack
slots
before
fixup
"
liveStackSlots
)
;
for
(
uint32_t
i
=
0
;
i
<
liveStackSlots
;
i
+
+
)
{
Value
v
=
iter_
.
read
(
)
;
if
(
!
writeValue
(
v
"
StackValue
"
)
)
{
return
false
;
}
}
if
(
op_
=
=
JSOp
:
:
FunCall
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
undefined
to
fixup
funcall
"
)
;
if
(
!
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
if
(
GET_ARGC
(
pc_
)
>
0
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
%
u
expression
stack
slots
"
inlinedArgs
)
;
for
(
uint32_t
i
=
0
;
i
<
inlinedArgs
;
i
+
+
)
{
Value
arg
=
iter_
.
read
(
)
;
if
(
!
writeValue
(
arg
"
StackValue
"
)
)
{
return
false
;
}
}
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
target
of
funcall
"
)
;
Value
target
=
iter_
.
read
(
)
;
if
(
!
writeValue
(
target
"
StackValue
"
)
)
{
return
false
;
}
iter_
.
skip
(
)
;
}
}
if
(
needToSaveCallerArgs
(
)
)
{
if
(
!
savedCallerArgs
.
resize
(
inlinedArgs
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
inlinedArgs
;
i
+
+
)
{
savedCallerArgs
[
i
]
.
set
(
iter_
.
read
(
)
)
;
}
if
(
IsSetPropOp
(
op_
)
)
{
Value
initialArg
=
savedCallerArgs
[
inlinedArgs
-
1
]
;
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
setter
'
s
initial
argument
"
)
;
if
(
!
writeValue
(
initialArg
"
StackValue
"
)
)
{
return
false
;
}
}
}
*
fixedUp
=
true
;
return
true
;
}
bool
BaselineStackBuilder
:
:
buildExpressionStack
(
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
%
u
expression
stack
slots
"
exprStackSlots
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
exprStackSlots
(
)
;
i
+
+
)
{
Value
v
;
if
(
propagatingIonExceptionForDebugMode
(
)
)
{
MOZ_ASSERT
(
cx_
-
>
realm
(
)
-
>
isDebuggee
(
)
|
|
cx_
-
>
isPropagatingForcedReturn
(
)
)
;
if
(
iter_
.
moreFrames
(
)
|
|
hasLiveStackValueAtDepth
(
i
)
)
{
v
=
iter_
.
read
(
)
;
}
else
{
iter_
.
skip
(
)
;
v
=
MagicValue
(
JS_OPTIMIZED_OUT
)
;
}
}
else
{
v
=
iter_
.
read
(
)
;
}
if
(
!
writeValue
(
v
"
StackValue
"
)
)
{
return
false
;
}
}
return
true
;
}
bool
BaselineStackBuilder
:
:
prepareForNextFrame
(
HandleValueVector
savedCallerArgs
)
{
const
uint32_t
frameSize
=
framePushed
(
)
;
if
(
!
finishOuterFrame
(
frameSize
)
)
{
return
false
;
}
return
buildStubFrame
(
frameSize
savedCallerArgs
)
;
}
bool
BaselineStackBuilder
:
:
finishOuterFrame
(
uint32_t
frameSize
)
{
const
BaselineInterpreter
&
baselineInterp
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
baselineInterpreter
(
)
;
blFrame
(
)
-
>
setInterpreterFields
(
script_
pc_
)
;
size_t
baselineFrameDescr
=
MakeFrameDescriptor
(
frameSize
FrameType
:
:
BaselineJS
BaselineStubFrameLayout
:
:
Size
(
)
)
;
if
(
!
writeWord
(
baselineFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
uint8_t
*
retAddr
=
baselineInterp
.
retAddrForIC
(
op_
)
;
return
writePtr
(
retAddr
"
ReturnAddr
"
)
;
}
bool
BaselineStackBuilder
:
:
buildStubFrame
(
uint32_t
frameSize
HandleValueVector
savedCallerArgs
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
[
BASELINE
-
STUB
FRAME
]
"
)
;
size_t
startOfBaselineStubFrame
=
framePushed
(
)
;
uint32_t
pcOff
=
script_
-
>
pcToOffset
(
pc_
)
;
JitScript
*
jitScript
=
script_
-
>
jitScript
(
)
;
const
ICEntry
&
icEntry
=
jitScript
-
>
icEntryFromPCOffset
(
pcOff
)
;
ICFallbackStub
*
fallback
=
jitScript
-
>
fallbackStubForICEntry
(
&
icEntry
)
;
if
(
!
writePtr
(
fallback
"
StubPtr
"
)
)
{
return
false
;
}
if
(
!
writePtr
(
prevFramePtr
(
)
"
PrevFramePtr
"
)
)
{
return
false
;
}
prevFramePtr_
=
virtualPointerAtStackOffset
(
0
)
;
MOZ_ASSERT
(
IsIonInlinableOp
(
op_
)
)
;
bool
pushedNewTarget
=
IsConstructPC
(
pc_
)
;
unsigned
actualArgc
;
Value
callee
;
if
(
needToSaveCallerArgs
(
)
)
{
callee
=
savedCallerArgs
[
0
]
;
actualArgc
=
IsSetPropOp
(
op_
)
?
1
:
0
;
size_t
afterFrameSize
=
(
actualArgc
+
1
)
*
sizeof
(
Value
)
+
JitFrameLayout
:
:
Size
(
)
;
if
(
!
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
actualArgc
+
2
<
=
exprStackSlots
(
)
)
;
MOZ_ASSERT
(
savedCallerArgs
.
length
(
)
=
=
actualArgc
+
2
)
;
for
(
unsigned
i
=
0
;
i
<
actualArgc
+
1
;
i
+
+
)
{
size_t
arg
=
savedCallerArgs
.
length
(
)
-
(
i
+
1
)
;
if
(
!
writeValue
(
savedCallerArgs
[
arg
]
"
ArgVal
"
)
)
{
return
false
;
}
}
}
else
if
(
op_
=
=
JSOp
:
:
FunCall
&
&
GET_ARGC
(
pc_
)
=
=
0
)
{
MOZ_ASSERT
(
!
pushedNewTarget
)
;
actualArgc
=
0
;
size_t
afterFrameSize
=
sizeof
(
Value
)
+
JitFrameLayout
:
:
Size
(
)
;
if
(
!
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
if
(
!
writeValue
(
UndefinedValue
(
)
"
ThisValue
"
)
)
{
return
false
;
}
size_t
calleeSlot
=
blFrame
(
)
-
>
numValueSlots
(
frameSize
)
-
1
;
callee
=
*
blFrame
(
)
-
>
valueSlot
(
calleeSlot
)
;
}
else
{
actualArgc
=
GET_ARGC
(
pc_
)
;
if
(
op_
=
=
JSOp
:
:
FunCall
)
{
MOZ_ASSERT
(
actualArgc
>
0
)
;
actualArgc
-
-
;
}
uint32_t
numArguments
=
actualArgc
+
1
+
pushedNewTarget
;
size_t
afterFrameSize
=
numArguments
*
sizeof
(
Value
)
+
JitFrameLayout
:
:
Size
(
)
;
if
(
!
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
size_t
valueSlot
=
blFrame
(
)
-
>
numValueSlots
(
frameSize
)
-
1
;
size_t
calleeSlot
=
valueSlot
-
numArguments
;
for
(
size_t
i
=
valueSlot
;
i
>
calleeSlot
;
i
-
-
)
{
Value
v
=
*
blFrame
(
)
-
>
valueSlot
(
i
)
;
if
(
!
writeValue
(
v
"
ArgVal
"
)
)
{
return
false
;
}
}
callee
=
*
blFrame
(
)
-
>
valueSlot
(
calleeSlot
)
;
}
size_t
endOfBaselineStubArgs
=
framePushed
(
)
;
size_t
baselineStubFrameSize
=
endOfBaselineStubArgs
-
startOfBaselineStubFrame
;
size_t
baselineStubFrameDescr
=
MakeFrameDescriptor
(
(
uint32_t
)
baselineStubFrameSize
FrameType
:
:
BaselineStub
JitFrameLayout
:
:
Size
(
)
)
;
if
(
!
writeWord
(
actualArgc
"
ActualArgc
"
)
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Callee
=
%
016
"
PRIx64
callee
.
asRawBits
(
)
)
;
JSFunction
*
calleeFun
=
&
callee
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
writePtr
(
CalleeToToken
(
calleeFun
pushedNewTarget
)
"
CalleeToken
"
)
)
{
return
false
;
}
setNextCallee
(
calleeFun
)
;
if
(
!
writeWord
(
baselineStubFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
void
*
baselineCallReturnAddr
=
getStubReturnAddress
(
)
;
MOZ_ASSERT
(
baselineCallReturnAddr
)
;
if
(
!
writePtr
(
baselineCallReturnAddr
"
ReturnAddr
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
framePushed
(
)
%
JitStackAlignment
=
=
0
)
;
if
(
actualArgc
<
calleeFun
-
>
nargs
(
)
&
&
!
buildRectifierFrame
(
actualArgc
endOfBaselineStubArgs
)
)
{
return
false
;
}
return
true
;
}
bool
BaselineStackBuilder
:
:
buildRectifierFrame
(
uint32_t
actualArgc
size_t
endOfBaselineStubArgs
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
[
RECTIFIER
FRAME
]
"
)
;
bool
pushedNewTarget
=
IsConstructPC
(
pc_
)
;
size_t
startOfRectifierFrame
=
framePushed
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
if
(
!
writePtr
(
prevFramePtr
(
)
"
PrevFramePtr
-
X86Only
"
)
)
{
return
false
;
}
prevFramePtr_
=
virtualPointerAtStackOffset
(
0
)
;
if
(
!
writePtr
(
prevFramePtr
(
)
"
Padding
-
X86Only
"
)
)
{
return
false
;
}
#
endif
size_t
afterFrameSize
=
(
nextCallee
(
)
-
>
nargs
(
)
+
1
+
pushedNewTarget
)
*
sizeof
(
Value
)
+
RectifierFrameLayout
:
:
Size
(
)
;
if
(
!
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
if
(
pushedNewTarget
)
{
size_t
newTargetOffset
=
(
framePushed
(
)
-
endOfBaselineStubArgs
)
+
(
actualArgc
+
1
)
*
sizeof
(
Value
)
;
Value
newTargetValue
=
*
valuePointerAtStackOffset
(
newTargetOffset
)
;
if
(
!
writeValue
(
newTargetValue
"
CopiedNewTarget
"
)
)
{
return
false
;
}
}
for
(
unsigned
i
=
0
;
i
<
(
nextCallee
(
)
-
>
nargs
(
)
-
actualArgc
)
;
i
+
+
)
{
if
(
!
writeValue
(
UndefinedValue
(
)
"
FillerVal
"
)
)
{
return
false
;
}
}
if
(
!
subtract
(
(
actualArgc
+
1
)
*
sizeof
(
Value
)
"
CopiedArgs
"
)
)
{
return
false
;
}
BufferPointer
<
uint8_t
>
stubArgsEnd
=
pointerAtStackOffset
<
uint8_t
>
(
framePushed
(
)
-
endOfBaselineStubArgs
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
MemCpy
from
%
p
"
stubArgsEnd
.
get
(
)
)
;
memcpy
(
pointerAtStackOffset
<
uint8_t
>
(
0
)
.
get
(
)
stubArgsEnd
.
get
(
)
(
actualArgc
+
1
)
*
sizeof
(
Value
)
)
;
size_t
rectifierFrameSize
=
framePushed
(
)
-
startOfRectifierFrame
;
size_t
rectifierFrameDescr
=
MakeFrameDescriptor
(
(
uint32_t
)
rectifierFrameSize
FrameType
:
:
Rectifier
JitFrameLayout
:
:
Size
(
)
)
;
if
(
!
writeWord
(
actualArgc
"
ActualArgc
"
)
)
{
return
false
;
}
if
(
!
writePtr
(
CalleeToToken
(
nextCallee
(
)
pushedNewTarget
)
"
CalleeToken
"
)
)
{
return
false
;
}
if
(
!
writeWord
(
rectifierFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
void
*
rectReturnAddr
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifierReturnAddr
(
)
.
value
;
MOZ_ASSERT
(
rectReturnAddr
)
;
if
(
!
writePtr
(
rectReturnAddr
"
ReturnAddr
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
framePushed
(
)
%
JitStackAlignment
=
=
0
)
;
return
true
;
}
bool
BaselineStackBuilder
:
:
finishLastFrame
(
)
{
const
BaselineInterpreter
&
baselineInterp
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
baselineInterpreter
(
)
;
setResumeFramePtr
(
prevFramePtr
(
)
)
;
setFrameSizeOfInnerMostFrame
(
framePushed
(
)
)
;
uint8_t
*
resumeAddr
;
if
(
isPrologueBailout
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
into
prologue
.
"
)
;
MOZ_ASSERT
(
pc_
=
=
script_
-
>
code
(
)
)
;
blFrame
(
)
-
>
setInterpreterFieldsForPrologue
(
script_
)
;
resumeAddr
=
baselineInterp
.
bailoutPrologueEntryAddr
(
)
;
}
else
if
(
propagatingIonExceptionForDebugMode
(
)
)
{
jsbytecode
*
throwPC
=
script_
-
>
offsetToPC
(
iter_
.
pcOffset
(
)
)
;
blFrame
(
)
-
>
setInterpreterFields
(
script_
throwPC
)
;
resumeAddr
=
baselineInterp
.
interpretOpAddr
(
)
.
value
;
}
else
{
jsbytecode
*
resumePC
=
getResumePC
(
)
;
blFrame
(
)
-
>
setInterpreterFields
(
script_
resumePC
)
;
resumeAddr
=
baselineInterp
.
interpretOpAddr
(
)
.
value
;
}
setResumeAddr
(
resumeAddr
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Set
resumeAddr
=
%
p
"
resumeAddr
)
;
if
(
cx_
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
const
char
*
filename
=
script_
-
>
filename
(
)
;
if
(
filename
=
=
nullptr
)
{
filename
=
"
<
unknown
>
"
;
}
unsigned
len
=
strlen
(
filename
)
+
200
;
UniqueChars
buf
(
js_pod_malloc
<
char
>
(
len
)
)
;
if
(
buf
=
=
nullptr
)
{
ReportOutOfMemory
(
cx_
)
;
return
false
;
}
snprintf
(
buf
.
get
(
)
len
"
%
s
%
s
%
s
on
line
%
u
of
%
s
:
%
u
"
BailoutKindString
(
iter_
.
bailoutKind
(
)
)
resumeAfter
(
)
?
"
after
"
:
"
at
"
CodeName
(
op_
)
PCToLineNumber
(
script_
pc_
)
filename
script_
-
>
lineno
(
)
)
;
cx_
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
markEvent
(
"
Bailout
"
buf
.
get
(
)
)
;
}
return
true
;
}
#
ifdef
DEBUG
bool
BaselineStackBuilder
:
:
envChainSlotCanBeOptimized
(
)
{
jsbytecode
*
pc
=
script_
-
>
offsetToPC
(
iter_
.
pcOffset
(
)
)
;
Scope
*
scopeIter
=
script_
-
>
innermostScope
(
pc
)
;
while
(
scopeIter
!
=
script_
-
>
bodyScope
(
)
)
{
if
(
!
scopeIter
|
|
scopeIter
-
>
hasEnvironment
(
)
)
{
return
false
;
}
scopeIter
=
scopeIter
-
>
enclosing
(
)
;
}
return
true
;
}
bool
BaselineStackBuilder
:
:
validateFrame
(
)
{
const
uint32_t
frameSize
=
framePushed
(
)
;
blFrame
(
)
-
>
setDebugFrameSize
(
frameSize
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
FrameSize
=
%
u
"
frameSize
)
;
MOZ_ASSERT
(
blFrame
(
)
-
>
debugNumValueSlots
(
)
>
=
script_
-
>
nfixed
(
)
)
;
MOZ_ASSERT
(
blFrame
(
)
-
>
debugNumValueSlots
(
)
<
=
script_
-
>
nslots
(
)
)
;
uint32_t
expectedDepth
;
bool
reachablePC
;
jsbytecode
*
pcForStackDepth
=
resumeAfter
(
)
?
GetNextPc
(
pc_
)
:
pc_
;
if
(
!
ReconstructStackDepth
(
cx_
script_
pcForStackDepth
&
expectedDepth
&
reachablePC
)
)
{
return
false
;
}
if
(
!
reachablePC
)
{
return
true
;
}
if
(
op_
=
=
JSOp
:
:
FunCall
)
{
MOZ_ASSERT
(
expectedDepth
-
exprStackSlots
(
)
<
=
1
)
;
}
else
if
(
iter_
.
moreFrames
(
)
&
&
IsIonInlinableGetterOrSetterOp
(
op_
)
)
{
MOZ_ASSERT
(
exprStackSlots
(
)
-
expectedDepth
=
=
(
IsGetElemOp
(
op_
)
?
0
:
1
)
)
;
}
else
{
MOZ_ASSERT
(
exprStackSlots
(
)
=
=
expectedDepth
)
;
}
return
true
;
}
#
endif
void
*
BaselineStackBuilder
:
:
getStubReturnAddress
(
)
{
const
BaselineICFallbackCode
&
code
=
cx_
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
baselineICFallbackCode
(
)
;
if
(
IsGetPropOp
(
op_
)
)
{
return
code
.
bailoutReturnAddr
(
BailoutReturnKind
:
:
GetProp
)
;
}
if
(
IsSetPropOp
(
op_
)
)
{
return
code
.
bailoutReturnAddr
(
BailoutReturnKind
:
:
SetProp
)
;
}
if
(
IsGetElemOp
(
op_
)
)
{
return
code
.
bailoutReturnAddr
(
BailoutReturnKind
:
:
GetElem
)
;
}
MOZ_ASSERT
(
IsInvokeOp
(
op_
)
&
&
!
IsSpreadOp
(
op_
)
)
;
if
(
IsConstructOp
(
op_
)
)
{
return
code
.
bailoutReturnAddr
(
BailoutReturnKind
:
:
New
)
;
}
return
code
.
bailoutReturnAddr
(
BailoutReturnKind
:
:
Call
)
;
}
static
inline
jsbytecode
*
GetNextNonLoopHeadPc
(
jsbytecode
*
pc
jsbytecode
*
*
skippedLoopHead
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
switch
(
op
)
{
case
JSOp
:
:
Goto
:
return
pc
+
GET_JUMP_OFFSET
(
pc
)
;
case
JSOp
:
:
LoopHead
:
*
skippedLoopHead
=
pc
;
return
GetNextPc
(
pc
)
;
case
JSOp
:
:
Nop
:
return
GetNextPc
(
pc
)
;
default
:
return
pc
;
}
}
jsbytecode
*
BaselineStackBuilder
:
:
getResumePC
(
)
{
if
(
resumeAfter
(
)
)
{
return
GetNextPc
(
pc_
)
;
}
jsbytecode
*
skippedLoopHead
=
nullptr
;
jsbytecode
*
slowerPc
=
pc_
;
jsbytecode
*
fasterPc
=
pc_
;
while
(
true
)
{
slowerPc
=
GetNextNonLoopHeadPc
(
slowerPc
&
skippedLoopHead
)
;
fasterPc
=
GetNextNonLoopHeadPc
(
fasterPc
&
skippedLoopHead
)
;
fasterPc
=
GetNextNonLoopHeadPc
(
fasterPc
&
skippedLoopHead
)
;
if
(
fasterPc
=
=
slowerPc
)
{
break
;
}
}
return
slowerPc
;
}
bool
BaselineStackBuilder
:
:
hasLiveStackValueAtDepth
(
uint32_t
stackSlotIndex
)
{
MOZ_ASSERT
(
stackSlotIndex
<
exprStackSlots
(
)
)
;
for
(
TryNoteIterAllNoGC
tni
(
script_
pc_
)
;
!
tni
.
done
(
)
;
+
+
tni
)
{
const
TryNote
&
tn
=
*
*
tni
;
switch
(
tn
.
kind
(
)
)
{
case
TryNoteKind
:
:
ForIn
:
case
TryNoteKind
:
:
ForOf
:
case
TryNoteKind
:
:
Destructuring
:
MOZ_ASSERT
(
tn
.
stackDepth
<
=
exprStackSlots
(
)
)
;
if
(
stackSlotIndex
<
tn
.
stackDepth
)
{
return
true
;
}
break
;
default
:
break
;
}
}
return
false
;
}
bool
BaselineStackBuilder
:
:
isPrologueBailout
(
)
{
return
iter_
.
pcOffset
(
)
=
=
0
&
&
!
iter_
.
resumeAfter
(
)
&
&
!
propagatingIonExceptionForDebugMode
(
)
;
}
bool
BaselineStackBuilder
:
:
buildOneFrame
(
)
{
if
(
!
initFrame
(
)
)
{
return
false
;
}
if
(
!
buildBaselineFrame
(
)
)
{
return
false
;
}
if
(
fun_
&
&
!
buildArguments
(
)
)
{
return
false
;
}
if
(
!
buildFixedSlots
(
)
)
{
return
false
;
}
bool
fixedUp
=
false
;
RootedValueVector
savedCallerArgs
(
cx_
)
;
if
(
iter_
.
moreFrames
(
)
&
&
!
fixUpCallerArgs
(
&
savedCallerArgs
&
fixedUp
)
)
{
return
false
;
}
if
(
!
fixedUp
&
&
!
buildExpressionStack
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
if
(
!
validateFrame
(
)
)
{
return
false
;
}
#
endif
#
ifdef
JS_JITSPEW
const
uint32_t
pcOff
=
script_
-
>
pcToOffset
(
pc
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
%
s
pc
offset
%
d
(
op
%
s
)
(
line
%
u
)
of
%
s
:
%
u
:
%
u
"
resumeAfter
(
)
?
"
after
"
:
"
at
"
(
int
)
pcOff
CodeName
(
op_
)
PCToLineNumber
(
script_
pc
(
)
)
script_
-
>
filename
(
)
script_
-
>
lineno
(
)
script_
-
>
column
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Bailout
kind
:
%
s
"
BailoutKindString
(
iter_
.
bailoutKind
(
)
)
)
;
#
endif
if
(
done
(
)
)
{
return
finishLastFrame
(
)
;
}
return
prepareForNextFrame
(
savedCallerArgs
)
;
}
bool
jit
:
:
BailoutIonToBaseline
(
JSContext
*
cx
JitActivation
*
activation
const
JSJitFrameIter
&
iter
BaselineBailoutInfo
*
*
bailoutInfo
const
ExceptionBailoutInfo
*
excInfo
)
{
MOZ_ASSERT
(
bailoutInfo
!
=
nullptr
)
;
MOZ_ASSERT
(
*
bailoutInfo
=
=
nullptr
)
;
MOZ_ASSERT
(
iter
.
isBailoutJS
(
)
)
;
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
)
;
TraceLogStopEvent
(
logger
TraceLogger_IonMonkey
)
;
TraceLogStartEvent
(
logger
TraceLogger_Baseline
)
;
auto
guardRemoveRematerializedFramesFromDebugger
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
activation
-
>
removeRematerializedFramesFromDebugger
(
cx
iter
.
fp
(
)
)
;
}
)
;
auto
removeIonFrameRecovery
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
activation
-
>
removeIonFrameRecovery
(
iter
.
jsFrame
(
)
)
;
}
)
;
MOZ_ASSERT
(
iter
.
isBailoutJS
(
)
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
FrameType
prevFrameType
=
iter
.
prevType
(
)
;
MOZ_ASSERT
(
JSJitFrameIter
:
:
isEntry
(
prevFrameType
)
|
|
prevFrameType
=
=
FrameType
:
:
IonJS
|
|
prevFrameType
=
=
FrameType
:
:
BaselineStub
|
|
prevFrameType
=
=
FrameType
:
:
Rectifier
|
|
prevFrameType
=
=
FrameType
:
:
IonICCall
|
|
prevFrameType
=
=
FrameType
:
:
BaselineJS
)
;
#
endif
JitSpew
(
JitSpew_BaselineBailouts
"
Bailing
to
baseline
%
s
:
%
u
:
%
u
(
IonScript
=
%
p
)
(
FrameType
=
%
d
)
"
iter
.
script
(
)
-
>
filename
(
)
iter
.
script
(
)
-
>
lineno
(
)
iter
.
script
(
)
-
>
column
(
)
(
void
*
)
iter
.
ionScript
(
)
(
int
)
prevFrameType
)
;
if
(
excInfo
)
{
if
(
excInfo
-
>
catchingException
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
in
catch
or
finally
block
"
)
;
}
if
(
excInfo
-
>
propagatingIonExceptionForDebugMode
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
in
-
place
for
debug
mode
"
)
;
}
}
JitSpew
(
JitSpew_BaselineBailouts
"
Reading
from
snapshot
offset
%
u
size
%
zu
"
iter
.
snapshotOffset
(
)
iter
.
ionScript
(
)
-
>
snapshotsListSize
(
)
)
;
iter
.
script
(
)
-
>
updateJitCodeRaw
(
cx
-
>
runtime
(
)
)
;
MaybeReadFallback
recoverBailout
(
cx
activation
&
iter
MaybeReadFallback
:
:
Fallback_DoNothing
)
;
SnapshotIterator
snapIter
(
iter
activation
-
>
bailoutData
(
)
-
>
machineState
(
)
)
;
if
(
!
snapIter
.
initInstructionResults
(
recoverBailout
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
#
ifdef
TRACK_SNAPSHOTS
snapIter
.
spewBailingFrom
(
)
;
#
endif
BaselineStackBuilder
builder
(
cx
iter
snapIter
excInfo
)
;
if
(
!
builder
.
init
(
)
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Incoming
frame
ptr
=
%
p
"
builder
.
startFrame
(
)
)
;
if
(
iter
.
maybeCallee
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Callee
function
(
%
s
:
%
u
:
%
u
)
"
iter
.
script
(
)
-
>
filename
(
)
iter
.
script
(
)
-
>
lineno
(
)
iter
.
script
(
)
-
>
column
(
)
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
No
callee
!
"
)
;
}
if
(
iter
.
isConstructing
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Constructing
!
"
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
Not
constructing
!
"
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Restoring
frames
:
"
)
;
while
(
true
)
{
snapIter
.
settleOnFrame
(
)
;
if
(
!
builder
.
isOutermostFrame
(
)
)
{
TraceLoggerEvent
scriptEvent
(
TraceLogger_Scripts
builder
.
script
(
)
)
;
TraceLogStartEvent
(
logger
scriptEvent
)
;
TraceLogStartEvent
(
logger
TraceLogger_Baseline
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
FrameNo
%
zu
"
builder
.
frameNo
(
)
)
;
if
(
!
builder
.
buildOneFrame
(
)
)
{
MOZ_ASSERT
(
cx
-
>
isExceptionPending
(
)
)
;
return
false
;
}
if
(
builder
.
done
(
)
)
{
break
;
}
builder
.
nextFrame
(
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Done
restoring
frames
"
)
;
BailoutKind
bailoutKind
=
snapIter
.
bailoutKind
(
)
;
if
(
!
builder
.
outermostFrameFormals
(
)
.
empty
(
)
)
{
Value
*
argv
=
builder
.
startFrame
(
)
-
>
argv
(
)
+
1
;
mozilla
:
:
PodCopy
(
argv
builder
.
outermostFrameFormals
(
)
.
begin
(
)
builder
.
outermostFrameFormals
(
)
.
length
(
)
)
;
}
bool
overRecursed
=
false
;
BaselineBailoutInfo
*
info
=
builder
.
info
(
)
;
uint8_t
*
newsp
=
info
-
>
incomingStack
-
(
info
-
>
copyStackTop
-
info
-
>
copyStackBottom
)
;
#
ifdef
JS_SIMULATOR
if
(
Simulator
:
:
Current
(
)
-
>
overRecursed
(
uintptr_t
(
newsp
)
)
)
{
overRecursed
=
true
;
}
#
else
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
checkWithStackPointerDontReport
(
cx
newsp
)
)
{
overRecursed
=
true
;
}
#
endif
if
(
overRecursed
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Overrecursion
check
failed
!
"
)
;
ReportOverRecursed
(
cx
)
;
return
false
;
}
info
=
builder
.
takeBuffer
(
)
;
info
-
>
numFrames
=
builder
.
frameNo
(
)
+
1
;
info
-
>
bailoutKind
.
emplace
(
bailoutKind
)
;
*
bailoutInfo
=
info
;
guardRemoveRematerializedFramesFromDebugger
.
release
(
)
;
return
true
;
}
static
void
InvalidateAfterBailout
(
JSContext
*
cx
HandleScript
outerScript
const
char
*
reason
)
{
if
(
!
outerScript
-
>
hasIonScript
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Ion
script
is
already
invalidated
"
)
;
return
;
}
MOZ_ASSERT
(
!
outerScript
-
>
ionScript
(
)
-
>
invalidated
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Invalidating
due
to
%
s
"
reason
)
;
Invalidate
(
cx
outerScript
)
;
}
static
void
HandleLexicalCheckFailure
(
JSContext
*
cx
HandleScript
outerScript
HandleScript
innerScript
)
{
JitSpew
(
JitSpew_IonBailouts
"
Lexical
check
failure
%
s
:
%
u
:
%
u
inlined
into
%
s
:
%
u
:
%
u
"
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
)
;
if
(
!
innerScript
-
>
failedLexicalCheck
(
)
)
{
innerScript
-
>
setFailedLexicalCheck
(
)
;
}
InvalidateAfterBailout
(
cx
outerScript
"
lexical
check
failure
"
)
;
if
(
innerScript
-
>
hasIonScript
(
)
)
{
Invalidate
(
cx
innerScript
)
;
}
}
static
bool
CopyFromRematerializedFrame
(
JSContext
*
cx
JitActivation
*
act
uint8_t
*
fp
size_t
inlineDepth
BaselineFrame
*
frame
)
{
RematerializedFrame
*
rematFrame
=
act
-
>
lookupRematerializedFrame
(
fp
inlineDepth
)
;
if
(
!
rematFrame
)
{
return
true
;
}
MOZ_ASSERT
(
rematFrame
-
>
script
(
)
=
=
frame
-
>
script
(
)
)
;
MOZ_ASSERT
(
rematFrame
-
>
numActualArgs
(
)
=
=
frame
-
>
numActualArgs
(
)
)
;
frame
-
>
setEnvironmentChain
(
rematFrame
-
>
environmentChain
(
)
)
;
if
(
frame
-
>
isFunctionFrame
(
)
)
{
frame
-
>
thisArgument
(
)
=
rematFrame
-
>
thisArgument
(
)
;
}
for
(
unsigned
i
=
0
;
i
<
frame
-
>
numActualArgs
(
)
;
i
+
+
)
{
frame
-
>
argv
(
)
[
i
]
=
rematFrame
-
>
argv
(
)
[
i
]
;
}
for
(
size_t
i
=
0
;
i
<
frame
-
>
script
(
)
-
>
nfixed
(
)
;
i
+
+
)
{
*
frame
-
>
valueSlot
(
i
)
=
rematFrame
-
>
locals
(
)
[
i
]
;
}
frame
-
>
setReturnValue
(
rematFrame
-
>
returnValue
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Copied
from
rematerialized
frame
at
(
%
p
%
zu
)
"
fp
inlineDepth
)
;
if
(
rematFrame
-
>
isDebuggee
(
)
)
{
frame
-
>
setIsDebuggee
(
)
;
return
DebugAPI
:
:
handleIonBailout
(
cx
rematFrame
frame
)
;
}
return
true
;
}
enum
class
BailoutAction
{
InvalidateImmediately
InvalidateIfFrequent
DisableIfFrequent
NoAction
}
;
bool
jit
:
:
FinishBailoutToBaseline
(
BaselineBailoutInfo
*
bailoutInfoArg
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Done
restoring
frames
"
)
;
UniquePtr
<
BaselineBailoutInfo
>
bailoutInfo
(
bailoutInfoArg
)
;
bailoutInfoArg
=
nullptr
;
MOZ_DIAGNOSTIC_ASSERT
(
*
bailoutInfo
-
>
bailoutKind
!
=
BailoutKind
:
:
Unreachable
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
BaselineFrame
*
topFrame
=
GetTopBaselineFrame
(
cx
)
;
uint8_t
*
incomingStack
=
bailoutInfo
-
>
incomingStack
;
auto
guardRemoveRematerializedFramesFromDebugger
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
JitActivation
*
act
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
act
-
>
removeRematerializedFramesFromDebugger
(
cx
incomingStack
)
;
}
)
;
if
(
!
EnsureHasEnvironmentObjects
(
cx
topFrame
)
)
{
return
false
;
}
RootedScript
innerScript
(
cx
nullptr
)
;
RootedScript
outerScript
(
cx
nullptr
)
;
MOZ_ASSERT
(
cx
-
>
currentlyRunningInJit
(
)
)
;
JSJitFrameIter
iter
(
cx
-
>
activation
(
)
-
>
asJit
(
)
)
;
uint8_t
*
outerFp
=
nullptr
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
{
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
iter
.
prevFp
(
)
)
;
}
uint32_t
numFrames
=
bailoutInfo
-
>
numFrames
;
MOZ_ASSERT
(
numFrames
>
0
)
;
uint32_t
frameno
=
0
;
while
(
frameno
<
numFrames
)
{
MOZ_ASSERT
(
!
iter
.
isIonJS
(
)
)
;
if
(
iter
.
isBaselineJS
(
)
)
{
BaselineFrame
*
frame
=
iter
.
baselineFrame
(
)
;
MOZ_ASSERT
(
frame
-
>
script
(
)
-
>
hasBaselineScript
(
)
)
;
if
(
frame
-
>
environmentChain
(
)
&
&
frame
-
>
script
(
)
-
>
needsArgsObj
(
)
)
{
ArgumentsObject
*
argsObj
;
if
(
frame
-
>
hasArgsObj
(
)
)
{
argsObj
=
&
frame
-
>
argsObj
(
)
;
}
else
{
argsObj
=
ArgumentsObject
:
:
createExpected
(
cx
frame
)
;
if
(
!
argsObj
)
{
return
false
;
}
}
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
SetFrameArgumentsObject
(
cx
frame
script
argsObj
)
;
}
if
(
frameno
=
=
0
)
{
innerScript
=
frame
-
>
script
(
)
;
}
if
(
frameno
=
=
numFrames
-
1
)
{
outerScript
=
frame
-
>
script
(
)
;
outerFp
=
iter
.
fp
(
)
;
MOZ_ASSERT
(
outerFp
=
=
incomingStack
)
;
}
frameno
+
+
;
}
+
+
iter
;
}
MOZ_ASSERT
(
innerScript
)
;
MOZ_ASSERT
(
outerScript
)
;
MOZ_ASSERT
(
outerFp
)
;
JitActivation
*
act
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
if
(
act
-
>
hasRematerializedFrame
(
outerFp
)
)
{
JSJitFrameIter
iter
(
act
)
;
size_t
inlineDepth
=
numFrames
;
bool
ok
=
true
;
while
(
inlineDepth
>
0
)
{
if
(
iter
.
isBaselineJS
(
)
)
{
if
(
!
CopyFromRematerializedFrame
(
cx
act
outerFp
-
-
inlineDepth
iter
.
baselineFrame
(
)
)
)
{
ok
=
false
;
}
}
+
+
iter
;
}
if
(
!
ok
)
{
return
false
;
}
guardRemoveRematerializedFramesFromDebugger
.
release
(
)
;
act
-
>
removeRematerializedFrame
(
outerFp
)
;
}
if
(
cx
-
>
isExceptionPending
(
)
&
&
bailoutInfo
-
>
faultPC
)
{
EnvironmentIter
ei
(
cx
topFrame
bailoutInfo
-
>
faultPC
)
;
UnwindEnvironment
(
cx
ei
bailoutInfo
-
>
tryPC
)
;
}
if
(
!
cx
-
>
isExceptionPending
(
)
)
{
if
(
!
CheckForInterrupt
(
cx
)
)
{
return
false
;
}
}
BailoutKind
bailoutKind
=
*
bailoutInfo
-
>
bailoutKind
;
JitSpew
(
JitSpew_BaselineBailouts
"
Restored
outerScript
=
(
%
s
:
%
u
:
%
u
%
u
)
innerScript
=
(
%
s
:
%
u
:
%
u
%
u
)
"
"
(
bailoutKind
=
%
u
)
"
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
outerScript
-
>
getWarmUpCount
(
)
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
innerScript
-
>
getWarmUpCount
(
)
(
unsigned
)
bailoutKind
)
;
BailoutAction
action
=
BailoutAction
:
:
InvalidateImmediately
;
DebugOnly
<
bool
>
saveFailedICHash
=
false
;
switch
(
bailoutKind
)
{
case
BailoutKind
:
:
TranspiledCacheIR
:
action
=
BailoutAction
:
:
InvalidateIfFrequent
;
saveFailedICHash
=
true
;
break
;
case
BailoutKind
:
:
SpeculativePhi
:
MOZ_ASSERT
(
!
outerScript
-
>
hadSpeculativePhiBailout
(
)
)
;
outerScript
-
>
setHadSpeculativePhiBailout
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
phi
specialization
failure
"
)
;
break
;
case
BailoutKind
:
:
TypePolicy
:
action
=
BailoutAction
:
:
DisableIfFrequent
;
break
;
case
BailoutKind
:
:
LICM
:
MOZ_ASSERT
(
!
outerScript
-
>
hadLICMInvalidation
(
)
)
;
if
(
outerScript
-
>
hasIonScript
(
)
)
{
switch
(
outerScript
-
>
ionScript
(
)
-
>
licmState
(
)
)
{
case
IonScript
:
:
LICMState
:
:
NeverBailed
:
outerScript
-
>
ionScript
(
)
-
>
setHadLICMBailout
(
)
;
action
=
BailoutAction
:
:
NoAction
;
break
;
case
IonScript
:
:
LICMState
:
:
Bailed
:
outerScript
-
>
setHadLICMInvalidation
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
LICM
failure
"
)
;
break
;
case
IonScript
:
:
LICMState
:
:
BailedAndHitFallback
:
action
=
BailoutAction
:
:
InvalidateIfFrequent
;
break
;
}
}
break
;
case
BailoutKind
:
:
InstructionReordering
:
outerScript
-
>
setHadReorderingBailout
(
)
;
action
=
BailoutAction
:
:
InvalidateIfFrequent
;
break
;
case
BailoutKind
:
:
HoistBoundsCheck
:
MOZ_ASSERT
(
!
outerScript
-
>
failedBoundsCheck
(
)
)
;
outerScript
-
>
setFailedBoundsCheck
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
bounds
check
failure
"
)
;
break
;
case
BailoutKind
:
:
EagerTruncation
:
MOZ_ASSERT
(
!
outerScript
-
>
hadEagerTruncationBailout
(
)
)
;
outerScript
-
>
setHadEagerTruncationBailout
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
eager
range
analysis
failure
"
)
;
break
;
case
BailoutKind
:
:
UnboxFolding
:
MOZ_ASSERT
(
!
outerScript
-
>
hadUnboxFoldingBailout
(
)
)
;
outerScript
-
>
setHadUnboxFoldingBailout
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
unbox
folding
failure
"
)
;
break
;
case
BailoutKind
:
:
TooManyArguments
:
action
=
BailoutAction
:
:
DisableIfFrequent
;
break
;
case
BailoutKind
:
:
DuringVMCall
:
if
(
cx
-
>
isExceptionPending
(
)
)
{
action
=
BailoutAction
:
:
DisableIfFrequent
;
}
break
;
case
BailoutKind
:
:
Inevitable
:
case
BailoutKind
:
:
Debugger
:
action
=
BailoutAction
:
:
NoAction
;
break
;
case
BailoutKind
:
:
FirstExecution
:
action
=
BailoutAction
:
:
InvalidateIfFrequent
;
saveFailedICHash
=
true
;
break
;
case
BailoutKind
:
:
UninitializedLexical
:
HandleLexicalCheckFailure
(
cx
outerScript
innerScript
)
;
break
;
case
BailoutKind
:
:
IonExceptionDebugMode
:
return
false
;
case
BailoutKind
:
:
OnStackInvalidation
:
action
=
BailoutAction
:
:
NoAction
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
bailout
kind
!
"
)
;
}
#
ifdef
DEBUG
if
(
MOZ_UNLIKELY
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
ionBailAfterEnabled
(
)
)
)
{
action
=
BailoutAction
:
:
NoAction
;
}
#
endif
if
(
outerScript
-
>
hasIonScript
(
)
)
{
IonScript
*
ionScript
=
outerScript
-
>
ionScript
(
)
;
switch
(
action
)
{
case
BailoutAction
:
:
InvalidateImmediately
:
MOZ_ASSERT
(
false
)
;
break
;
case
BailoutAction
:
:
InvalidateIfFrequent
:
ionScript
-
>
incNumFixableBailouts
(
)
;
if
(
ionScript
-
>
shouldInvalidate
(
)
)
{
#
ifdef
DEBUG
if
(
saveFailedICHash
&
&
!
JitOptions
.
disableBailoutLoopCheck
)
{
outerScript
-
>
jitScript
(
)
-
>
setFailedICHash
(
ionScript
-
>
icHash
(
)
)
;
}
#
endif
InvalidateAfterBailout
(
cx
outerScript
"
fixable
bailouts
"
)
;
}
break
;
case
BailoutAction
:
:
DisableIfFrequent
:
ionScript
-
>
incNumUnfixableBailouts
(
)
;
if
(
ionScript
-
>
shouldInvalidateAndDisable
(
)
)
{
InvalidateAfterBailout
(
cx
outerScript
"
unfixable
bailouts
"
)
;
outerScript
-
>
disableIon
(
)
;
}
break
;
case
BailoutAction
:
:
NoAction
:
break
;
}
}
return
true
;
}
