#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
jit
/
arm
/
Simulator
-
arm
.
h
"
#
include
"
jit
/
BaselineFrame
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
mips32
/
Simulator
-
mips32
.
h
"
#
include
"
jit
/
mips64
/
Simulator
-
mips64
.
h
"
#
include
"
jit
/
Recover
.
h
"
#
include
"
jit
/
RematerializedFrame
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
ArgumentsObject
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
template
<
typename
T
>
class
BufferPointer
{
BaselineBailoutInfo
*
*
header_
;
size_t
offset_
;
bool
heap_
;
public
:
BufferPointer
(
BaselineBailoutInfo
*
*
header
size_t
offset
bool
heap
)
:
header_
(
header
)
offset_
(
offset
)
heap_
(
heap
)
{
}
T
*
get
(
)
const
{
BaselineBailoutInfo
*
header
=
*
header_
;
if
(
!
heap_
)
{
return
(
T
*
)
(
header
-
>
incomingStack
+
offset_
)
;
}
uint8_t
*
p
=
header
-
>
copyStackTop
-
offset_
;
MOZ_ASSERT
(
p
>
=
header
-
>
copyStackBottom
&
&
p
<
header
-
>
copyStackTop
)
;
return
(
T
*
)
p
;
}
void
set
(
const
T
&
value
)
{
*
get
(
)
=
value
;
}
const
T
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
struct
BaselineStackBuilder
{
JSContext
*
cx_
;
const
JSJitFrameIter
&
iter_
;
JitFrameLayout
*
frame_
;
static
size_t
HeaderSize
(
)
{
return
AlignBytes
(
sizeof
(
BaselineBailoutInfo
)
sizeof
(
void
*
)
)
;
}
size_t
bufferTotal_
;
size_t
bufferAvail_
;
size_t
bufferUsed_
;
uint8_t
*
buffer_
;
BaselineBailoutInfo
*
header_
;
size_t
framePushed_
;
BaselineStackBuilder
(
JSContext
*
cx
const
JSJitFrameIter
&
iter
size_t
initialSize
)
:
cx_
(
cx
)
iter_
(
iter
)
frame_
(
static_cast
<
JitFrameLayout
*
>
(
iter
.
current
(
)
)
)
bufferTotal_
(
initialSize
)
bufferAvail_
(
0
)
bufferUsed_
(
0
)
buffer_
(
nullptr
)
header_
(
nullptr
)
framePushed_
(
0
)
{
MOZ_ASSERT
(
bufferTotal_
>
=
HeaderSize
(
)
)
;
MOZ_ASSERT
(
iter
.
isBailoutJS
(
)
)
;
}
~
BaselineStackBuilder
(
)
{
js_free
(
buffer_
)
;
}
MOZ_MUST_USE
bool
init
(
)
{
MOZ_ASSERT
(
!
buffer_
)
;
MOZ_ASSERT
(
bufferUsed_
=
=
0
)
;
buffer_
=
cx_
-
>
pod_calloc
<
uint8_t
>
(
bufferTotal_
)
;
if
(
!
buffer_
)
{
return
false
;
}
bufferAvail_
=
bufferTotal_
-
HeaderSize
(
)
;
bufferUsed_
=
0
;
header_
=
reinterpret_cast
<
BaselineBailoutInfo
*
>
(
buffer_
)
;
header_
-
>
incomingStack
=
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
;
header_
-
>
copyStackTop
=
buffer_
+
bufferTotal_
;
header_
-
>
copyStackBottom
=
header_
-
>
copyStackTop
;
header_
-
>
setR0
=
0
;
header_
-
>
valueR0
=
UndefinedValue
(
)
;
header_
-
>
setR1
=
0
;
header_
-
>
valueR1
=
UndefinedValue
(
)
;
header_
-
>
resumeFramePtr
=
nullptr
;
header_
-
>
resumeAddr
=
nullptr
;
header_
-
>
resumePC
=
nullptr
;
header_
-
>
tryPC
=
nullptr
;
header_
-
>
faultPC
=
nullptr
;
header_
-
>
monitorStub
=
nullptr
;
header_
-
>
numFrames
=
0
;
header_
-
>
checkGlobalDeclarationConflicts
=
false
;
return
true
;
}
MOZ_MUST_USE
bool
enlarge
(
)
{
MOZ_ASSERT
(
buffer_
!
=
nullptr
)
;
if
(
bufferTotal_
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
2
>
:
:
value
)
{
ReportOutOfMemory
(
cx_
)
;
return
false
;
}
size_t
newSize
=
bufferTotal_
*
2
;
uint8_t
*
newBuffer
=
cx_
-
>
pod_calloc
<
uint8_t
>
(
newSize
)
;
if
(
!
newBuffer
)
{
return
false
;
}
memcpy
(
(
newBuffer
+
newSize
)
-
bufferUsed_
header_
-
>
copyStackBottom
bufferUsed_
)
;
memcpy
(
newBuffer
header_
sizeof
(
BaselineBailoutInfo
)
)
;
js_free
(
buffer_
)
;
buffer_
=
newBuffer
;
bufferTotal_
=
newSize
;
bufferAvail_
=
newSize
-
(
HeaderSize
(
)
+
bufferUsed_
)
;
header_
=
reinterpret_cast
<
BaselineBailoutInfo
*
>
(
buffer_
)
;
header_
-
>
copyStackTop
=
buffer_
+
bufferTotal_
;
header_
-
>
copyStackBottom
=
header_
-
>
copyStackTop
-
bufferUsed_
;
return
true
;
}
BaselineBailoutInfo
*
info
(
)
{
MOZ_ASSERT
(
header_
=
=
reinterpret_cast
<
BaselineBailoutInfo
*
>
(
buffer_
)
)
;
return
header_
;
}
BaselineBailoutInfo
*
takeBuffer
(
)
{
MOZ_ASSERT
(
header_
=
=
reinterpret_cast
<
BaselineBailoutInfo
*
>
(
buffer_
)
)
;
buffer_
=
nullptr
;
return
header_
;
}
void
resetFramePushed
(
)
{
framePushed_
=
0
;
}
size_t
framePushed
(
)
const
{
return
framePushed_
;
}
MOZ_MUST_USE
bool
subtract
(
size_t
size
const
char
*
info
=
nullptr
)
{
while
(
size
>
bufferAvail_
)
{
if
(
!
enlarge
(
)
)
{
return
false
;
}
}
header_
-
>
copyStackBottom
-
=
size
;
bufferAvail_
-
=
size
;
bufferUsed_
+
=
size
;
framePushed_
+
=
size
;
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
SUB_
%
03d
%
p
/
%
p
%
-
15s
"
(
int
)
size
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
)
;
}
return
true
;
}
template
<
typename
T
>
MOZ_MUST_USE
bool
write
(
const
T
&
t
)
{
MOZ_ASSERT
(
!
(
uintptr_t
(
&
t
)
>
=
uintptr_t
(
header_
-
>
copyStackBottom
)
&
&
uintptr_t
(
&
t
)
<
uintptr_t
(
header_
-
>
copyStackTop
)
)
"
Should
not
reference
memory
that
can
be
freed
"
)
;
if
(
!
subtract
(
sizeof
(
T
)
)
)
{
return
false
;
}
memcpy
(
header_
-
>
copyStackBottom
&
t
sizeof
(
T
)
)
;
return
true
;
}
template
<
typename
T
>
MOZ_MUST_USE
bool
writePtr
(
T
*
t
const
char
*
info
)
{
if
(
!
write
<
T
*
>
(
t
)
)
{
return
false
;
}
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_PTR
%
p
/
%
p
%
-
15s
%
p
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
t
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
writeWord
(
size_t
w
const
char
*
info
)
{
if
(
!
write
<
size_t
>
(
w
)
)
{
return
false
;
}
if
(
info
)
{
if
(
sizeof
(
size_t
)
=
=
4
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_WRD
%
p
/
%
p
%
-
15s
%
08zx
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
w
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_WRD
%
p
/
%
p
%
-
15s
%
016zx
"
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
w
)
;
}
}
return
true
;
}
MOZ_MUST_USE
bool
writeValue
(
const
Value
&
val
const
char
*
info
)
{
if
(
!
write
<
Value
>
(
val
)
)
{
return
false
;
}
if
(
info
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
WRITE_VAL
%
p
/
%
p
%
-
15s
%
016
"
PRIx64
header_
-
>
copyStackBottom
virtualPointerAtStackOffset
(
0
)
info
*
(
(
uint64_t
*
)
&
val
)
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
maybeWritePadding
(
size_t
alignment
size_t
after
const
char
*
info
)
{
MOZ_ASSERT
(
framePushed_
%
sizeof
(
Value
)
=
=
0
)
;
MOZ_ASSERT
(
after
%
sizeof
(
Value
)
=
=
0
)
;
size_t
offset
=
ComputeByteAlignment
(
after
alignment
)
;
while
(
framePushed_
%
alignment
!
=
offset
)
{
if
(
!
writeValue
(
MagicValue
(
JS_ARG_POISON
)
info
)
)
{
return
false
;
}
}
return
true
;
}
Value
popValue
(
)
{
MOZ_ASSERT
(
bufferUsed_
>
=
sizeof
(
Value
)
)
;
MOZ_ASSERT
(
framePushed_
>
=
sizeof
(
Value
)
)
;
bufferAvail_
+
=
sizeof
(
Value
)
;
bufferUsed_
-
=
sizeof
(
Value
)
;
framePushed_
-
=
sizeof
(
Value
)
;
Value
result
=
*
(
(
Value
*
)
header_
-
>
copyStackBottom
)
;
header_
-
>
copyStackBottom
+
=
sizeof
(
Value
)
;
return
result
;
}
void
popValueInto
(
PCMappingSlotInfo
:
:
SlotLocation
loc
)
{
MOZ_ASSERT
(
PCMappingSlotInfo
:
:
ValidSlotLocation
(
loc
)
)
;
switch
(
loc
)
{
case
PCMappingSlotInfo
:
:
SlotInR0
:
header_
-
>
setR0
=
1
;
header_
-
>
valueR0
=
popValue
(
)
;
break
;
case
PCMappingSlotInfo
:
:
SlotInR1
:
header_
-
>
setR1
=
1
;
header_
-
>
valueR1
=
popValue
(
)
;
break
;
default
:
MOZ_ASSERT
(
loc
=
=
PCMappingSlotInfo
:
:
SlotIgnore
)
;
popValue
(
)
;
break
;
}
}
void
setResumeFramePtr
(
void
*
resumeFramePtr
)
{
header_
-
>
resumeFramePtr
=
resumeFramePtr
;
}
void
setResumeAddr
(
void
*
resumeAddr
)
{
header_
-
>
resumeAddr
=
resumeAddr
;
}
void
setResumePC
(
jsbytecode
*
pc
)
{
header_
-
>
resumePC
=
pc
;
}
void
setMonitorStub
(
ICStub
*
stub
)
{
header_
-
>
monitorStub
=
stub
;
}
template
<
typename
T
>
BufferPointer
<
T
>
pointerAtStackOffset
(
size_t
offset
)
{
if
(
offset
<
bufferUsed_
)
{
offset
=
header_
-
>
copyStackTop
-
(
header_
-
>
copyStackBottom
+
offset
)
;
return
BufferPointer
<
T
>
(
&
header_
offset
true
)
;
}
return
BufferPointer
<
T
>
(
&
header_
offset
-
bufferUsed_
false
)
;
}
BufferPointer
<
Value
>
valuePointerAtStackOffset
(
size_t
offset
)
{
return
pointerAtStackOffset
<
Value
>
(
offset
)
;
}
inline
uint8_t
*
virtualPointerAtStackOffset
(
size_t
offset
)
{
if
(
offset
<
bufferUsed_
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
-
(
bufferUsed_
-
offset
)
;
}
return
reinterpret_cast
<
uint8_t
*
>
(
frame_
)
+
(
offset
-
bufferUsed_
)
;
}
inline
JitFrameLayout
*
startFrame
(
)
{
return
frame_
;
}
BufferPointer
<
JitFrameLayout
>
topFrameAddress
(
)
{
return
pointerAtStackOffset
<
JitFrameLayout
>
(
0
)
;
}
void
*
calculatePrevFramePtr
(
)
{
BufferPointer
<
JitFrameLayout
>
topFrame
=
topFrameAddress
(
)
;
FrameType
type
=
topFrame
-
>
prevType
(
)
;
if
(
JSJitFrameIter
:
:
isEntry
(
type
)
|
|
type
=
=
FrameType
:
:
IonJS
|
|
type
=
=
FrameType
:
:
IonICCall
)
{
return
nullptr
;
}
if
(
type
=
=
FrameType
:
:
BaselineStub
)
{
size_t
offset
=
JitFrameLayout
:
:
Size
(
)
+
topFrame
-
>
prevFrameLocalSize
(
)
+
BaselineStubFrameLayout
:
:
reverseOffsetOfSavedFramePtr
(
)
;
return
virtualPointerAtStackOffset
(
offset
)
;
}
MOZ_ASSERT
(
type
=
=
FrameType
:
:
Rectifier
)
;
size_t
priorOffset
=
JitFrameLayout
:
:
Size
(
)
+
topFrame
-
>
prevFrameLocalSize
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
MOZ_ASSERT
(
BaselineFrameReg
=
=
FramePointer
)
;
priorOffset
-
=
sizeof
(
void
*
)
;
return
virtualPointerAtStackOffset
(
priorOffset
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
|
|
\
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_X64
)
BufferPointer
<
RectifierFrameLayout
>
priorFrame
=
pointerAtStackOffset
<
RectifierFrameLayout
>
(
priorOffset
)
;
FrameType
priorType
=
priorFrame
-
>
prevType
(
)
;
MOZ_ASSERT
(
JSJitFrameIter
:
:
isEntry
(
priorType
)
|
|
priorType
=
=
FrameType
:
:
IonJS
|
|
priorType
=
=
FrameType
:
:
BaselineStub
)
;
if
(
priorType
=
=
FrameType
:
:
IonJS
|
|
JSJitFrameIter
:
:
isEntry
(
priorType
)
)
{
return
nullptr
;
}
size_t
extraOffset
=
RectifierFrameLayout
:
:
Size
(
)
+
priorFrame
-
>
prevFrameLocalSize
(
)
+
BaselineStubFrameLayout
:
:
reverseOffsetOfSavedFramePtr
(
)
;
return
virtualPointerAtStackOffset
(
priorOffset
+
extraOffset
)
;
#
elif
defined
(
JS_CODEGEN_NONE
)
(
void
)
priorOffset
;
MOZ_CRASH
(
)
;
#
else
#
error
"
Bad
architecture
!
"
#
endif
}
void
setCheckGlobalDeclarationConflicts
(
)
{
header_
-
>
checkGlobalDeclarationConflicts
=
true
;
}
}
;
#
ifdef
DEBUG
static
inline
bool
IsInlinableFallback
(
ICFallbackStub
*
icEntry
)
{
return
icEntry
-
>
isCall_Fallback
(
)
|
|
icEntry
-
>
isGetProp_Fallback
(
)
|
|
icEntry
-
>
isSetProp_Fallback
(
)
|
|
icEntry
-
>
isGetElem_Fallback
(
)
;
}
#
endif
static
inline
void
*
GetStubReturnAddress
(
JSContext
*
cx
jsbytecode
*
pc
)
{
JitRealm
*
jitRealm
=
cx
-
>
realm
(
)
-
>
jitRealm
(
)
;
if
(
IsGetPropPC
(
pc
)
)
{
return
jitRealm
-
>
bailoutReturnAddr
(
BailoutReturnStub
:
:
GetProp
)
;
}
if
(
IsSetPropPC
(
pc
)
)
{
return
jitRealm
-
>
bailoutReturnAddr
(
BailoutReturnStub
:
:
SetProp
)
;
}
if
(
IsGetElemPC
(
pc
)
)
{
return
jitRealm
-
>
bailoutReturnAddr
(
BailoutReturnStub
:
:
GetElem
)
;
}
MOZ_ASSERT
(
IsCallPC
(
pc
)
&
&
!
IsSpreadCallPC
(
pc
)
)
;
if
(
IsConstructorCallPC
(
pc
)
)
{
return
jitRealm
-
>
bailoutReturnAddr
(
BailoutReturnStub
:
:
New
)
;
}
return
jitRealm
-
>
bailoutReturnAddr
(
BailoutReturnStub
:
:
Call
)
;
}
static
inline
jsbytecode
*
GetNextNonLoopEntryPc
(
jsbytecode
*
pc
jsbytecode
*
*
skippedLoopEntry
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
if
(
op
=
=
JSOP_GOTO
)
{
return
pc
+
GET_JUMP_OFFSET
(
pc
)
;
}
if
(
op
=
=
JSOP_LOOPENTRY
|
|
op
=
=
JSOP_NOP
|
|
op
=
=
JSOP_LOOPHEAD
)
{
if
(
op
=
=
JSOP_LOOPENTRY
)
{
*
skippedLoopEntry
=
pc
;
}
return
GetNextPc
(
pc
)
;
}
return
pc
;
}
class
NoOpTryNoteFilter
{
public
:
explicit
NoOpTryNoteFilter
(
)
=
default
;
bool
operator
(
)
(
const
JSTryNote
*
)
{
return
true
;
}
}
;
class
TryNoteIterAll
:
public
TryNoteIter
<
NoOpTryNoteFilter
>
{
public
:
TryNoteIterAll
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
:
TryNoteIter
(
cx
script
pc
NoOpTryNoteFilter
(
)
)
{
}
}
;
static
bool
HasLiveStackValueAtDepth
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
uint32_t
stackDepth
)
{
if
(
!
script
-
>
hasTrynotes
(
)
)
{
return
false
;
}
for
(
TryNoteIterAll
tni
(
cx
script
pc
)
;
!
tni
.
done
(
)
;
+
+
tni
)
{
const
JSTryNote
&
tn
=
*
*
tni
;
switch
(
tn
.
kind
)
{
case
JSTRY_FOR_IN
:
if
(
stackDepth
=
=
tn
.
stackDepth
)
{
return
true
;
}
break
;
case
JSTRY_FOR_OF
:
if
(
stackDepth
=
=
tn
.
stackDepth
-
1
|
|
stackDepth
=
=
tn
.
stackDepth
-
2
)
{
return
true
;
}
break
;
case
JSTRY_DESTRUCTURING
:
if
(
stackDepth
=
=
tn
.
stackDepth
|
|
stackDepth
=
=
tn
.
stackDepth
-
1
)
{
return
true
;
}
break
;
default
:
break
;
}
}
return
false
;
}
static
bool
IsPrologueBailout
(
const
SnapshotIterator
&
iter
const
ExceptionBailoutInfo
*
excInfo
)
{
return
iter
.
pcOffset
(
)
=
=
0
&
&
!
iter
.
resumeAfter
(
)
&
&
(
!
excInfo
|
|
!
excInfo
-
>
propagatingIonExceptionForDebugMode
(
)
)
;
}
static
bool
InitFromBailout
(
JSContext
*
cx
size_t
frameNo
HandleFunction
fun
HandleScript
script
SnapshotIterator
&
iter
bool
invalidate
BaselineStackBuilder
&
builder
MutableHandle
<
GCVector
<
Value
>
>
startFrameFormals
MutableHandleFunction
nextCallee
const
ExceptionBailoutInfo
*
excInfo
)
{
MOZ_ASSERT
(
cx
-
>
suppressGC
)
;
MOZ_ASSERT
(
script
-
>
hasBaselineScript
(
)
)
;
bool
catchingException
=
excInfo
&
&
excInfo
-
>
catchingException
(
)
;
uint32_t
exprStackSlots
;
if
(
catchingException
)
{
exprStackSlots
=
excInfo
-
>
numExprSlots
(
)
;
}
else
{
exprStackSlots
=
iter
.
numAllocations
(
)
-
(
script
-
>
nfixed
(
)
+
CountArgSlots
(
script
fun
)
)
;
}
builder
.
resetFramePushed
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Unpacking
%
s
:
%
u
:
%
u
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
script
-
>
column
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
[
BASELINE
-
JS
FRAME
]
"
)
;
void
*
prevFramePtr
=
builder
.
calculatePrevFramePtr
(
)
;
if
(
!
builder
.
writePtr
(
prevFramePtr
"
PrevFramePtr
"
)
)
{
return
false
;
}
prevFramePtr
=
builder
.
virtualPointerAtStackOffset
(
0
)
;
if
(
!
builder
.
subtract
(
BaselineFrame
:
:
Size
(
)
"
BaselineFrame
"
)
)
{
return
false
;
}
BufferPointer
<
BaselineFrame
>
blFrame
=
builder
.
pointerAtStackOffset
<
BaselineFrame
>
(
0
)
;
uint32_t
flags
=
0
;
if
(
script
-
>
isDebuggee
(
)
)
{
flags
|
=
BaselineFrame
:
:
DEBUGGEE
;
}
JSObject
*
envChain
=
nullptr
;
Value
returnValue
;
ArgumentsObject
*
argsObj
=
nullptr
;
BailoutKind
bailoutKind
=
iter
.
bailoutKind
(
)
;
if
(
bailoutKind
=
=
Bailout_ArgumentCheck
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Bailout_ArgumentCheck
!
(
no
valid
envChain
)
"
)
;
iter
.
skip
(
)
;
iter
.
skip
(
)
;
returnValue
=
UndefinedValue
(
)
;
if
(
script
-
>
argumentsHasVarBinding
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Bailout_ArgumentCheck
for
script
with
argumentsHasVarBinding
!
"
"
Using
empty
arguments
object
"
)
;
iter
.
skip
(
)
;
}
}
else
{
Value
v
=
iter
.
read
(
)
;
if
(
v
.
isObject
(
)
)
{
envChain
=
&
v
.
toObject
(
)
;
if
(
fun
&
&
fun
-
>
needsFunctionEnvironmentObjects
(
)
)
{
MOZ_ASSERT
(
fun
-
>
nonLazyScript
(
)
-
>
initialEnvironmentShape
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
needsExtraBodyVarEnvironment
(
)
)
;
flags
|
=
BaselineFrame
:
:
HAS_INITIAL_ENV
;
}
}
else
{
MOZ_ASSERT
(
v
.
isUndefined
(
)
|
|
v
.
isMagic
(
JS_OPTIMIZED_OUT
)
)
;
#
ifdef
DEBUG
jsbytecode
*
pc
=
script
-
>
offsetToPC
(
iter
.
pcOffset
(
)
)
;
Scope
*
scopeIter
=
script
-
>
innermostScope
(
pc
)
;
while
(
scopeIter
!
=
script
-
>
bodyScope
(
)
)
{
MOZ_ASSERT
(
scopeIter
)
;
MOZ_ASSERT
(
!
scopeIter
-
>
hasEnvironment
(
)
)
;
scopeIter
=
scopeIter
-
>
enclosing
(
)
;
}
#
endif
if
(
fun
)
{
if
(
!
IsPrologueBailout
(
iter
excInfo
)
)
{
envChain
=
fun
-
>
environment
(
)
;
}
}
else
if
(
script
-
>
module
(
)
)
{
envChain
=
script
-
>
module
(
)
-
>
environment
(
)
;
}
else
{
MOZ_ASSERT
(
!
script
-
>
isForEval
(
)
)
;
MOZ_ASSERT
(
!
script
-
>
hasNonSyntacticScope
(
)
)
;
envChain
=
&
(
script
-
>
global
(
)
.
lexicalEnvironment
(
)
)
;
if
(
IsPrologueBailout
(
iter
excInfo
)
)
{
builder
.
setCheckGlobalDeclarationConflicts
(
)
;
}
}
}
returnValue
=
iter
.
read
(
)
;
flags
|
=
BaselineFrame
:
:
HAS_RVAL
;
if
(
script
-
>
argumentsHasVarBinding
(
)
)
{
v
=
iter
.
read
(
)
;
MOZ_ASSERT
(
v
.
isObject
(
)
|
|
v
.
isUndefined
(
)
|
|
v
.
isMagic
(
JS_OPTIMIZED_OUT
)
)
;
if
(
v
.
isObject
(
)
)
{
argsObj
=
&
v
.
toObject
(
)
.
as
<
ArgumentsObject
>
(
)
;
}
}
}
JitSpew
(
JitSpew_BaselineBailouts
"
EnvChain
=
%
p
"
envChain
)
;
blFrame
-
>
setEnvironmentChain
(
envChain
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
ReturnValue
=
%
016
"
PRIx64
*
(
(
uint64_t
*
)
&
returnValue
)
)
;
blFrame
-
>
setReturnValue
(
returnValue
)
;
blFrame
-
>
setFlags
(
flags
)
;
if
(
argsObj
)
{
blFrame
-
>
initArgsObjUnchecked
(
*
argsObj
)
;
}
if
(
fun
)
{
Value
thisv
=
iter
.
read
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Is
function
!
"
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
thisv
=
%
016
"
PRIx64
*
(
(
uint64_t
*
)
&
thisv
)
)
;
size_t
thisvOffset
=
builder
.
framePushed
(
)
+
JitFrameLayout
:
:
offsetOfThis
(
)
;
builder
.
valuePointerAtStackOffset
(
thisvOffset
)
.
set
(
thisv
)
;
MOZ_ASSERT
(
iter
.
numAllocations
(
)
>
=
CountArgSlots
(
script
fun
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
frame
slots
%
u
nargs
%
zu
nfixed
%
zu
"
iter
.
numAllocations
(
)
fun
-
>
nargs
(
)
script
-
>
nfixed
(
)
)
;
bool
argsObjAliasesFormals
=
script
-
>
argsObjAliasesFormals
(
)
;
if
(
frameNo
=
=
0
&
&
!
argsObjAliasesFormals
)
{
MOZ_ASSERT
(
startFrameFormals
.
empty
(
)
)
;
if
(
!
startFrameFormals
.
resize
(
fun
-
>
nargs
(
)
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
fun
-
>
nargs
(
)
;
i
+
+
)
{
Value
arg
=
iter
.
read
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
arg
%
d
=
%
016
"
PRIx64
(
int
)
i
*
(
(
uint64_t
*
)
&
arg
)
)
;
if
(
frameNo
>
0
)
{
size_t
argOffset
=
builder
.
framePushed
(
)
+
JitFrameLayout
:
:
offsetOfActualArg
(
i
)
;
builder
.
valuePointerAtStackOffset
(
argOffset
)
.
set
(
arg
)
;
}
else
if
(
argsObjAliasesFormals
)
{
}
else
{
startFrameFormals
[
i
]
.
set
(
arg
)
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
script
-
>
nfixed
(
)
;
i
+
+
)
{
Value
slot
=
iter
.
read
(
)
;
if
(
!
builder
.
writeValue
(
slot
"
FixedValue
"
)
)
{
return
false
;
}
}
jsbytecode
*
pc
=
catchingException
?
excInfo
-
>
resumePC
(
)
:
script
-
>
offsetToPC
(
iter
.
pcOffset
(
)
)
;
bool
resumeAfter
=
catchingException
?
false
:
iter
.
resumeAfter
(
)
;
if
(
!
JitOptions
.
disablePgo
&
&
script
-
>
hasScriptCounts
(
)
)
{
script
-
>
incHitCount
(
pc
)
;
}
JSOp
op
=
JSOp
(
*
pc
)
;
MOZ_ASSERT_IF
(
IsSpreadCallPC
(
pc
)
!
iter
.
moreFrames
(
)
)
;
uint32_t
pushedSlots
=
0
;
AutoValueVector
savedCallerArgs
(
cx
)
;
bool
needToSaveArgs
=
op
=
=
JSOP_FUNAPPLY
|
|
IsIonInlinableGetterOrSetterPC
(
pc
)
;
if
(
iter
.
moreFrames
(
)
&
&
(
op
=
=
JSOP_FUNCALL
|
|
needToSaveArgs
)
)
{
uint32_t
inlined_args
=
0
;
if
(
op
=
=
JSOP_FUNCALL
)
{
inlined_args
=
2
+
GET_ARGC
(
pc
)
-
1
;
}
else
if
(
op
=
=
JSOP_FUNAPPLY
)
{
inlined_args
=
2
+
blFrame
-
>
numActualArgs
(
)
;
}
else
{
MOZ_ASSERT
(
IsIonInlinableGetterOrSetterPC
(
pc
)
)
;
inlined_args
=
2
+
IsSetPropPC
(
pc
)
;
}
MOZ_ASSERT
(
exprStackSlots
>
=
inlined_args
)
;
pushedSlots
=
exprStackSlots
-
inlined_args
;
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
%
u
expression
stack
slots
before
fixup
"
pushedSlots
)
;
for
(
uint32_t
i
=
0
;
i
<
pushedSlots
;
i
+
+
)
{
Value
v
=
iter
.
read
(
)
;
if
(
!
builder
.
writeValue
(
v
"
StackValue
"
)
)
{
return
false
;
}
}
if
(
op
=
=
JSOP_FUNCALL
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
undefined
to
fixup
funcall
"
)
;
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
}
if
(
needToSaveArgs
)
{
if
(
op
=
=
JSOP_FUNAPPLY
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
4x
undefined
to
fixup
funapply
"
)
;
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
StackValue
"
)
)
{
return
false
;
}
}
if
(
!
savedCallerArgs
.
resize
(
inlined_args
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
inlined_args
;
i
+
+
)
{
savedCallerArgs
[
i
]
.
set
(
iter
.
read
(
)
)
;
}
if
(
IsSetPropPC
(
pc
)
)
{
Value
initialArg
=
savedCallerArgs
[
inlined_args
-
1
]
;
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
setter
'
s
initial
argument
"
)
;
if
(
!
builder
.
writeValue
(
initialArg
"
StackValue
"
)
)
{
return
false
;
}
}
pushedSlots
=
exprStackSlots
;
}
}
JitSpew
(
JitSpew_BaselineBailouts
"
pushing
%
u
expression
stack
slots
"
exprStackSlots
-
pushedSlots
)
;
for
(
uint32_t
i
=
pushedSlots
;
i
<
exprStackSlots
;
i
+
+
)
{
Value
v
;
if
(
!
iter
.
moreFrames
(
)
&
&
i
=
=
exprStackSlots
-
1
&
&
cx
-
>
hasIonReturnOverride
(
)
)
{
MOZ_ASSERT
(
invalidate
)
;
iter
.
skip
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
[
Return
Override
]
"
)
;
v
=
cx
-
>
takeIonReturnOverride
(
)
;
}
else
if
(
excInfo
&
&
excInfo
-
>
propagatingIonExceptionForDebugMode
(
)
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
isDebuggee
(
)
)
;
if
(
iter
.
moreFrames
(
)
|
|
HasLiveStackValueAtDepth
(
cx
script
pc
i
+
1
)
)
{
v
=
iter
.
read
(
)
;
}
else
{
iter
.
skip
(
)
;
v
=
MagicValue
(
JS_OPTIMIZED_OUT
)
;
}
}
else
{
v
=
iter
.
read
(
)
;
}
if
(
!
builder
.
writeValue
(
v
"
StackValue
"
)
)
{
return
false
;
}
}
uint32_t
frameSize
=
builder
.
framePushed
(
)
;
blFrame
-
>
setFrameSize
(
frameSize
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
FrameSize
=
%
u
"
frameSize
)
;
MOZ_ASSERT
(
blFrame
-
>
numValueSlots
(
)
>
=
script
-
>
nfixed
(
)
)
;
MOZ_ASSERT
(
blFrame
-
>
numValueSlots
(
)
<
=
script
-
>
nslots
(
)
)
;
jsbytecode
*
skippedLoopEntry
=
nullptr
;
if
(
!
resumeAfter
)
{
jsbytecode
*
fasterPc
=
pc
;
while
(
true
)
{
pc
=
GetNextNonLoopEntryPc
(
pc
&
skippedLoopEntry
)
;
fasterPc
=
GetNextNonLoopEntryPc
(
GetNextNonLoopEntryPc
(
fasterPc
&
skippedLoopEntry
)
&
skippedLoopEntry
)
;
if
(
fasterPc
=
=
pc
)
{
break
;
}
}
op
=
JSOp
(
*
pc
)
;
if
(
skippedLoopEntry
&
&
script
-
>
trackRecordReplayProgress
(
)
)
{
mozilla
:
:
recordreplay
:
:
AdvanceExecutionProgressCounter
(
)
;
}
}
const
uint32_t
pcOff
=
script
-
>
pcToOffset
(
pc
)
;
BaselineScript
*
baselineScript
=
script
-
>
baselineScript
(
)
;
ICScript
*
icScript
=
script
-
>
icScript
(
)
;
#
ifdef
DEBUG
uint32_t
expectedDepth
;
bool
reachablePC
;
if
(
!
ReconstructStackDepth
(
cx
script
resumeAfter
?
GetNextPc
(
pc
)
:
pc
&
expectedDepth
&
reachablePC
)
)
{
return
false
;
}
if
(
reachablePC
)
{
if
(
op
!
=
JSOP_FUNAPPLY
|
|
!
iter
.
moreFrames
(
)
|
|
resumeAfter
)
{
if
(
op
=
=
JSOP_FUNCALL
)
{
MOZ_ASSERT
(
expectedDepth
-
exprStackSlots
<
=
1
)
;
}
else
if
(
iter
.
moreFrames
(
)
&
&
IsIonInlinableGetterOrSetterPC
(
pc
)
)
{
MOZ_ASSERT
(
exprStackSlots
-
expectedDepth
=
=
(
IsGetElemPC
(
pc
)
?
0
:
1
)
)
;
}
else
{
MOZ_ASSERT
(
exprStackSlots
=
=
expectedDepth
)
;
}
}
}
#
endif
#
ifdef
JS_JITSPEW
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
%
s
pc
offset
%
d
(
op
%
s
)
(
line
%
d
)
of
%
s
:
%
u
:
%
u
"
resumeAfter
?
"
after
"
:
"
at
"
(
int
)
pcOff
CodeName
[
op
]
PCToLineNumber
(
script
pc
)
script
-
>
filename
(
)
script
-
>
lineno
(
)
script
-
>
column
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Bailout
kind
:
%
s
"
BailoutKindString
(
bailoutKind
)
)
;
#
endif
bool
pushedNewTarget
=
IsConstructorCallPC
(
pc
)
;
if
(
!
iter
.
moreFrames
(
)
|
|
catchingException
)
{
bool
enterMonitorChain
=
false
;
if
(
resumeAfter
&
&
(
CodeSpec
[
op
]
.
format
&
JOF_TYPESET
)
)
{
ICEntry
&
icEntry
=
icScript
-
>
icEntryFromPCOffset
(
pcOff
)
;
ICFallbackStub
*
fallbackStub
=
icEntry
.
firstStub
(
)
-
>
getChainFallback
(
)
;
if
(
fallbackStub
-
>
isMonitoredFallback
(
)
)
{
enterMonitorChain
=
true
;
}
}
uint32_t
numUses
=
js
:
:
StackUses
(
pc
)
;
if
(
resumeAfter
&
&
!
enterMonitorChain
)
{
pc
=
GetNextPc
(
pc
)
;
}
builder
.
setResumePC
(
pc
)
;
builder
.
setResumeFramePtr
(
prevFramePtr
)
;
if
(
enterMonitorChain
)
{
ICEntry
&
icEntry
=
icScript
-
>
icEntryFromPCOffset
(
pcOff
)
;
ICFallbackStub
*
fallbackStub
=
icEntry
.
firstStub
(
)
-
>
getChainFallback
(
)
;
MOZ_ASSERT
(
fallbackStub
-
>
isMonitoredFallback
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
[
TYPE
-
MONITOR
CHAIN
]
"
)
;
ICTypeMonitor_Fallback
*
typeMonitorFallback
=
fallbackStub
-
>
toMonitoredFallbackStub
(
)
-
>
getFallbackMonitorStub
(
cx
script
)
;
if
(
!
typeMonitorFallback
)
{
return
false
;
}
ICStub
*
firstMonStub
=
typeMonitorFallback
-
>
firstMonitorStub
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Popping
top
stack
value
into
R0
.
"
)
;
builder
.
popValueInto
(
PCMappingSlotInfo
:
:
SlotInR0
)
;
frameSize
-
=
sizeof
(
Value
)
;
if
(
JSOp
(
*
pc
)
=
=
JSOP_GETELEM_SUPER
)
{
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
GETELEM_SUPER
stack
balance
"
)
)
{
return
false
;
}
frameSize
+
=
sizeof
(
Value
)
;
}
blFrame
-
>
setFrameSize
(
frameSize
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Adjusted
framesize
:
%
u
"
unsigned
(
frameSize
)
)
;
if
(
IsCallPC
(
pc
)
)
{
uint32_t
numCallArgs
=
numUses
-
2
-
uint32_t
(
pushedNewTarget
)
;
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
CallOp
FillerCallee
"
)
)
{
return
false
;
}
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
CallOp
FillerThis
"
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
numCallArgs
;
i
+
+
)
{
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
CallOp
FillerArg
"
)
)
{
return
false
;
}
}
if
(
pushedNewTarget
)
{
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
CallOp
FillerNewTarget
"
)
)
{
return
false
;
}
}
frameSize
+
=
numUses
*
sizeof
(
Value
)
;
blFrame
-
>
setFrameSize
(
frameSize
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Adjusted
framesize
+
=
%
d
:
%
d
"
(
int
)
(
numUses
*
sizeof
(
Value
)
)
(
int
)
frameSize
)
;
}
RetAddrEntry
&
retAddrEntry
=
baselineScript
-
>
retAddrEntryFromPCOffset
(
pcOff
RetAddrEntry
:
:
Kind
:
:
IC
)
;
uint8_t
*
retAddr
=
baselineScript
-
>
returnAddressForEntry
(
retAddrEntry
)
;
builder
.
setResumeAddr
(
retAddr
)
;
builder
.
setMonitorStub
(
firstMonStub
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Set
resumeAddr
=
%
p
monitorStub
=
%
p
"
retAddr
firstMonStub
)
;
}
else
{
PCMappingSlotInfo
slotInfo
;
uint8_t
*
nativeCodeForPC
;
if
(
excInfo
&
&
excInfo
-
>
propagatingIonExceptionForDebugMode
(
)
)
{
jsbytecode
*
throwPC
=
script
-
>
offsetToPC
(
iter
.
pcOffset
(
)
)
;
builder
.
setResumePC
(
throwPC
)
;
PCMappingSlotInfo
unused
;
nativeCodeForPC
=
baselineScript
-
>
nativeCodeForPC
(
script
throwPC
&
unused
)
;
}
else
{
nativeCodeForPC
=
baselineScript
-
>
nativeCodeForPC
(
script
pc
&
slotInfo
)
;
}
MOZ_ASSERT
(
nativeCodeForPC
)
;
unsigned
numUnsynced
=
slotInfo
.
numUnsynced
(
)
;
MOZ_ASSERT
(
numUnsynced
<
=
2
)
;
PCMappingSlotInfo
:
:
SlotLocation
loc1
loc2
;
if
(
numUnsynced
>
0
)
{
loc1
=
slotInfo
.
topSlotLocation
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Popping
top
stack
value
into
%
d
.
"
(
int
)
loc1
)
;
builder
.
popValueInto
(
loc1
)
;
}
if
(
numUnsynced
>
1
)
{
loc2
=
slotInfo
.
nextSlotLocation
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Popping
next
stack
value
into
%
d
.
"
(
int
)
loc2
)
;
MOZ_ASSERT_IF
(
loc1
!
=
PCMappingSlotInfo
:
:
SlotIgnore
loc1
!
=
loc2
)
;
builder
.
popValueInto
(
loc2
)
;
}
frameSize
-
=
sizeof
(
Value
)
*
numUnsynced
;
blFrame
-
>
setFrameSize
(
frameSize
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Adjusted
framesize
-
=
%
d
:
%
d
"
int
(
sizeof
(
Value
)
*
numUnsynced
)
int
(
frameSize
)
)
;
uint8_t
*
opReturnAddr
;
if
(
envChain
=
=
nullptr
)
{
MOZ_ASSERT
(
fun
)
;
MOZ_ASSERT
(
numUnsynced
=
=
0
)
;
opReturnAddr
=
baselineScript
-
>
bailoutPrologueEntryAddr
(
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
into
prologue
.
"
)
;
if
(
skippedLoopEntry
&
&
script
-
>
trackRecordReplayProgress
(
)
)
{
-
-
*
mozilla
:
:
recordreplay
:
:
ExecutionProgressCounter
(
)
;
}
}
else
{
opReturnAddr
=
nativeCodeForPC
;
}
builder
.
setResumeAddr
(
opReturnAddr
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Set
resumeAddr
=
%
p
"
opReturnAddr
)
;
}
if
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
const
char
*
filename
=
script
-
>
filename
(
)
;
if
(
filename
=
=
nullptr
)
{
filename
=
"
<
unknown
>
"
;
}
unsigned
len
=
strlen
(
filename
)
+
200
;
UniqueChars
buf
(
js_pod_malloc
<
char
>
(
len
)
)
;
if
(
buf
=
=
nullptr
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
snprintf
(
buf
.
get
(
)
len
"
%
s
%
s
%
s
on
line
%
u
of
%
s
:
%
u
"
BailoutKindString
(
bailoutKind
)
resumeAfter
?
"
after
"
:
"
at
"
CodeName
[
op
]
PCToLineNumber
(
script
pc
)
filename
script
-
>
lineno
(
)
)
;
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
markEvent
(
buf
.
get
(
)
)
;
}
return
true
;
}
size_t
baselineFrameDescr
=
MakeFrameDescriptor
(
(
uint32_t
)
builder
.
framePushed
(
)
FrameType
:
:
BaselineJS
BaselineStubFrameLayout
:
:
Size
(
)
)
;
if
(
!
builder
.
writeWord
(
baselineFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
ICEntry
&
icEntry
=
icScript
-
>
icEntryFromPCOffset
(
pcOff
)
;
MOZ_ASSERT
(
IsInlinableFallback
(
icEntry
.
firstStub
(
)
-
>
getChainFallback
(
)
)
)
;
RetAddrEntry
&
retAddrEntry
=
baselineScript
-
>
retAddrEntryFromPCOffset
(
pcOff
RetAddrEntry
:
:
Kind
:
:
IC
)
;
if
(
!
builder
.
writePtr
(
baselineScript
-
>
returnAddressForEntry
(
retAddrEntry
)
"
ReturnAddr
"
)
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
[
BASELINE
-
STUB
FRAME
]
"
)
;
size_t
startOfBaselineStubFrame
=
builder
.
framePushed
(
)
;
MOZ_ASSERT
(
IsInlinableFallback
(
icEntry
.
fallbackStub
(
)
)
)
;
if
(
!
builder
.
writePtr
(
icEntry
.
fallbackStub
(
)
"
StubPtr
"
)
)
{
return
false
;
}
if
(
!
builder
.
writePtr
(
prevFramePtr
"
PrevFramePtr
"
)
)
{
return
false
;
}
prevFramePtr
=
builder
.
virtualPointerAtStackOffset
(
0
)
;
MOZ_ASSERT
(
IsIonInlinablePC
(
pc
)
)
;
unsigned
actualArgc
;
Value
callee
;
if
(
needToSaveArgs
)
{
if
(
op
=
=
JSOP_FUNAPPLY
)
{
actualArgc
=
blFrame
-
>
numActualArgs
(
)
;
}
else
{
actualArgc
=
IsSetPropPC
(
pc
)
;
}
callee
=
savedCallerArgs
[
0
]
;
size_t
afterFrameSize
=
(
actualArgc
+
1
)
*
sizeof
(
Value
)
+
JitFrameLayout
:
:
Size
(
)
;
if
(
!
builder
.
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
actualArgc
+
2
<
=
exprStackSlots
)
;
MOZ_ASSERT
(
savedCallerArgs
.
length
(
)
=
=
actualArgc
+
2
)
;
for
(
unsigned
i
=
0
;
i
<
actualArgc
+
1
;
i
+
+
)
{
size_t
arg
=
savedCallerArgs
.
length
(
)
-
(
i
+
1
)
;
if
(
!
builder
.
writeValue
(
savedCallerArgs
[
arg
]
"
ArgVal
"
)
)
{
return
false
;
}
}
}
else
{
actualArgc
=
GET_ARGC
(
pc
)
;
if
(
op
=
=
JSOP_FUNCALL
)
{
MOZ_ASSERT
(
actualArgc
>
0
)
;
actualArgc
-
-
;
}
size_t
afterFrameSize
=
(
actualArgc
+
1
+
pushedNewTarget
)
*
sizeof
(
Value
)
+
JitFrameLayout
:
:
Size
(
)
;
if
(
!
builder
.
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
size_t
valueSlot
=
blFrame
-
>
numValueSlots
(
)
-
1
;
size_t
calleeSlot
=
valueSlot
-
actualArgc
-
1
-
pushedNewTarget
;
for
(
size_t
i
=
valueSlot
;
i
>
calleeSlot
;
i
-
-
)
{
Value
v
=
*
blFrame
-
>
valueSlot
(
i
)
;
if
(
!
builder
.
writeValue
(
v
"
ArgVal
"
)
)
{
return
false
;
}
}
callee
=
*
blFrame
-
>
valueSlot
(
calleeSlot
)
;
}
size_t
endOfBaselineStubArgs
=
builder
.
framePushed
(
)
;
size_t
baselineStubFrameSize
=
builder
.
framePushed
(
)
-
startOfBaselineStubFrame
;
size_t
baselineStubFrameDescr
=
MakeFrameDescriptor
(
(
uint32_t
)
baselineStubFrameSize
FrameType
:
:
BaselineStub
JitFrameLayout
:
:
Size
(
)
)
;
if
(
!
builder
.
writeWord
(
actualArgc
"
ActualArgc
"
)
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Callee
=
%
016
"
PRIx64
callee
.
asRawBits
(
)
)
;
JSFunction
*
calleeFun
=
&
callee
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
builder
.
writePtr
(
CalleeToToken
(
calleeFun
pushedNewTarget
)
"
CalleeToken
"
)
)
{
return
false
;
}
nextCallee
.
set
(
calleeFun
)
;
if
(
!
builder
.
writeWord
(
baselineStubFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
if
(
CodeSpec
[
*
pc
]
.
format
&
JOF_TYPESET
)
{
ICFallbackStub
*
fallbackStub
=
icEntry
.
firstStub
(
)
-
>
getChainFallback
(
)
;
if
(
!
fallbackStub
-
>
toMonitoredFallbackStub
(
)
-
>
getFallbackMonitorStub
(
cx
script
)
)
{
return
false
;
}
}
void
*
baselineCallReturnAddr
=
GetStubReturnAddress
(
cx
pc
)
;
MOZ_ASSERT
(
baselineCallReturnAddr
)
;
if
(
!
builder
.
writePtr
(
baselineCallReturnAddr
"
ReturnAddr
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
builder
.
framePushed
(
)
%
JitStackAlignment
=
=
0
)
;
if
(
actualArgc
>
=
calleeFun
-
>
nargs
(
)
)
{
return
true
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
[
RECTIFIER
FRAME
]
"
)
;
size_t
startOfRectifierFrame
=
builder
.
framePushed
(
)
;
#
if
defined
(
JS_CODEGEN_X86
)
if
(
!
builder
.
writePtr
(
prevFramePtr
"
PrevFramePtr
-
X86Only
"
)
)
{
return
false
;
}
prevFramePtr
=
builder
.
virtualPointerAtStackOffset
(
0
)
;
if
(
!
builder
.
writePtr
(
prevFramePtr
"
Padding
-
X86Only
"
)
)
{
return
false
;
}
#
endif
size_t
afterFrameSize
=
(
calleeFun
-
>
nargs
(
)
+
1
+
pushedNewTarget
)
*
sizeof
(
Value
)
+
RectifierFrameLayout
:
:
Size
(
)
;
if
(
!
builder
.
maybeWritePadding
(
JitStackAlignment
afterFrameSize
"
Padding
"
)
)
{
return
false
;
}
if
(
pushedNewTarget
)
{
size_t
newTargetOffset
=
(
builder
.
framePushed
(
)
-
endOfBaselineStubArgs
)
+
(
actualArgc
+
1
)
*
sizeof
(
Value
)
;
Value
newTargetValue
=
*
builder
.
valuePointerAtStackOffset
(
newTargetOffset
)
;
if
(
!
builder
.
writeValue
(
newTargetValue
"
CopiedNewTarget
"
)
)
{
return
false
;
}
}
for
(
unsigned
i
=
0
;
i
<
(
calleeFun
-
>
nargs
(
)
-
actualArgc
)
;
i
+
+
)
{
if
(
!
builder
.
writeValue
(
UndefinedValue
(
)
"
FillerVal
"
)
)
{
return
false
;
}
}
if
(
!
builder
.
subtract
(
(
actualArgc
+
1
)
*
sizeof
(
Value
)
"
CopiedArgs
"
)
)
{
return
false
;
}
BufferPointer
<
uint8_t
>
stubArgsEnd
=
builder
.
pointerAtStackOffset
<
uint8_t
>
(
builder
.
framePushed
(
)
-
endOfBaselineStubArgs
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
MemCpy
from
%
p
"
stubArgsEnd
.
get
(
)
)
;
memcpy
(
builder
.
pointerAtStackOffset
<
uint8_t
>
(
0
)
.
get
(
)
stubArgsEnd
.
get
(
)
(
actualArgc
+
1
)
*
sizeof
(
Value
)
)
;
size_t
rectifierFrameSize
=
builder
.
framePushed
(
)
-
startOfRectifierFrame
;
size_t
rectifierFrameDescr
=
MakeFrameDescriptor
(
(
uint32_t
)
rectifierFrameSize
FrameType
:
:
Rectifier
JitFrameLayout
:
:
Size
(
)
)
;
if
(
!
builder
.
writeWord
(
actualArgc
"
ActualArgc
"
)
)
{
return
false
;
}
if
(
!
builder
.
writePtr
(
CalleeToToken
(
calleeFun
pushedNewTarget
)
"
CalleeToken
"
)
)
{
return
false
;
}
if
(
!
builder
.
writeWord
(
rectifierFrameDescr
"
Descriptor
"
)
)
{
return
false
;
}
void
*
rectReturnAddr
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifierReturnAddr
(
)
.
value
;
MOZ_ASSERT
(
rectReturnAddr
)
;
if
(
!
builder
.
writePtr
(
rectReturnAddr
"
ReturnAddr
"
)
)
{
return
false
;
}
MOZ_ASSERT
(
builder
.
framePushed
(
)
%
JitStackAlignment
=
=
0
)
;
return
true
;
}
bool
jit
:
:
BailoutIonToBaseline
(
JSContext
*
cx
JitActivation
*
activation
const
JSJitFrameIter
&
iter
bool
invalidate
BaselineBailoutInfo
*
*
bailoutInfo
const
ExceptionBailoutInfo
*
excInfo
)
{
MOZ_ASSERT
(
bailoutInfo
!
=
nullptr
)
;
MOZ_ASSERT
(
*
bailoutInfo
=
=
nullptr
)
;
MOZ_ASSERT
(
iter
.
isBailoutJS
(
)
)
;
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
)
;
TraceLogStopEvent
(
logger
TraceLogger_IonMonkey
)
;
TraceLogStartEvent
(
logger
TraceLogger_Baseline
)
;
auto
guardRemoveRematerializedFramesFromDebugger
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
activation
-
>
removeRematerializedFramesFromDebugger
(
cx
iter
.
fp
(
)
)
;
}
)
;
auto
removeIonFrameRecovery
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
activation
-
>
removeIonFrameRecovery
(
iter
.
jsFrame
(
)
)
;
}
)
;
MOZ_ASSERT
(
iter
.
isBailoutJS
(
)
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
FrameType
prevFrameType
=
iter
.
prevType
(
)
;
MOZ_ASSERT
(
JSJitFrameIter
:
:
isEntry
(
prevFrameType
)
|
|
prevFrameType
=
=
FrameType
:
:
IonJS
|
|
prevFrameType
=
=
FrameType
:
:
BaselineStub
|
|
prevFrameType
=
=
FrameType
:
:
Rectifier
|
|
prevFrameType
=
=
FrameType
:
:
IonICCall
)
;
#
endif
JitSpew
(
JitSpew_BaselineBailouts
"
Bailing
to
baseline
%
s
:
%
u
:
%
u
(
IonScript
=
%
p
)
(
FrameType
=
%
d
)
"
iter
.
script
(
)
-
>
filename
(
)
iter
.
script
(
)
-
>
lineno
(
)
iter
.
script
(
)
-
>
column
(
)
(
void
*
)
iter
.
ionScript
(
)
(
int
)
prevFrameType
)
;
bool
catchingException
;
bool
propagatingExceptionForDebugMode
;
if
(
excInfo
)
{
catchingException
=
excInfo
-
>
catchingException
(
)
;
propagatingExceptionForDebugMode
=
excInfo
-
>
propagatingIonExceptionForDebugMode
(
)
;
if
(
catchingException
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
in
catch
or
finally
block
"
)
;
}
if
(
propagatingExceptionForDebugMode
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Resuming
in
-
place
for
debug
mode
"
)
;
}
}
else
{
catchingException
=
false
;
propagatingExceptionForDebugMode
=
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Reading
from
snapshot
offset
%
u
size
%
zu
"
iter
.
snapshotOffset
(
)
iter
.
ionScript
(
)
-
>
snapshotsListSize
(
)
)
;
if
(
!
excInfo
)
{
iter
.
ionScript
(
)
-
>
incNumBailouts
(
)
;
}
iter
.
script
(
)
-
>
updateJitCodeRaw
(
cx
-
>
runtime
(
)
)
;
BaselineStackBuilder
builder
(
cx
iter
1024
)
;
if
(
!
builder
.
init
(
)
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Incoming
frame
ptr
=
%
p
"
builder
.
startFrame
(
)
)
;
MaybeReadFallback
recoverBailout
(
cx
activation
&
iter
MaybeReadFallback
:
:
Fallback_DoNothing
)
;
SnapshotIterator
snapIter
(
iter
activation
-
>
bailoutData
(
)
-
>
machineState
(
)
)
;
if
(
!
snapIter
.
initInstructionResults
(
recoverBailout
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
#
ifdef
TRACK_SNAPSHOTS
snapIter
.
spewBailingFrom
(
)
;
#
endif
RootedFunction
callee
(
cx
iter
.
maybeCallee
(
)
)
;
RootedScript
scr
(
cx
iter
.
script
(
)
)
;
if
(
callee
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Callee
function
(
%
s
:
%
u
:
%
u
)
"
scr
-
>
filename
(
)
scr
-
>
lineno
(
)
scr
-
>
column
(
)
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
No
callee
!
"
)
;
}
if
(
iter
.
isConstructing
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Constructing
!
"
)
;
}
else
{
JitSpew
(
JitSpew_BaselineBailouts
"
Not
constructing
!
"
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Restoring
frames
:
"
)
;
size_t
frameNo
=
0
;
RootedFunction
fun
(
cx
callee
)
;
Rooted
<
GCVector
<
Value
>
>
startFrameFormals
(
cx
GCVector
<
Value
>
(
cx
)
)
;
gc
:
:
AutoSuppressGC
suppress
(
cx
)
;
while
(
true
)
{
snapIter
.
settleOnFrame
(
)
;
if
(
frameNo
>
0
)
{
TraceLoggerEvent
scriptEvent
(
TraceLogger_Scripts
scr
)
;
TraceLogStartEvent
(
logger
scriptEvent
)
;
TraceLogStartEvent
(
logger
TraceLogger_Baseline
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
FrameNo
%
zu
"
frameNo
)
;
bool
handleException
=
(
catchingException
&
&
excInfo
-
>
frameNo
(
)
=
=
frameNo
)
;
bool
passExcInfo
=
handleException
|
|
propagatingExceptionForDebugMode
;
RootedFunction
nextCallee
(
cx
nullptr
)
;
if
(
!
InitFromBailout
(
cx
frameNo
fun
scr
snapIter
invalidate
builder
&
startFrameFormals
&
nextCallee
passExcInfo
?
excInfo
:
nullptr
)
)
{
MOZ_ASSERT
(
cx
-
>
isExceptionPending
(
)
)
;
return
false
;
}
if
(
!
snapIter
.
moreFrames
(
)
)
{
MOZ_ASSERT
(
!
nextCallee
)
;
break
;
}
if
(
handleException
)
{
break
;
}
MOZ_ASSERT
(
nextCallee
)
;
fun
=
nextCallee
;
scr
=
fun
-
>
existingScript
(
)
;
frameNo
+
+
;
snapIter
.
nextInstruction
(
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Done
restoring
frames
"
)
;
BailoutKind
bailoutKind
=
snapIter
.
bailoutKind
(
)
;
if
(
!
startFrameFormals
.
empty
(
)
)
{
Value
*
argv
=
builder
.
startFrame
(
)
-
>
argv
(
)
+
1
;
mozilla
:
:
PodCopy
(
argv
startFrameFormals
.
begin
(
)
startFrameFormals
.
length
(
)
)
;
}
bool
overRecursed
=
false
;
BaselineBailoutInfo
*
info
=
builder
.
info
(
)
;
uint8_t
*
newsp
=
info
-
>
incomingStack
-
(
info
-
>
copyStackTop
-
info
-
>
copyStackBottom
)
;
#
ifdef
JS_SIMULATOR
if
(
Simulator
:
:
Current
(
)
-
>
overRecursed
(
uintptr_t
(
newsp
)
)
)
{
overRecursed
=
true
;
}
#
else
if
(
!
CheckRecursionLimitWithStackPointerDontReport
(
cx
newsp
)
)
{
overRecursed
=
true
;
}
#
endif
if
(
overRecursed
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Overrecursion
check
failed
!
"
)
;
ReportOverRecursed
(
cx
)
;
return
false
;
}
info
=
builder
.
takeBuffer
(
)
;
info
-
>
numFrames
=
frameNo
+
1
;
info
-
>
bailoutKind
=
bailoutKind
;
*
bailoutInfo
=
info
;
guardRemoveRematerializedFramesFromDebugger
.
release
(
)
;
return
true
;
}
static
void
InvalidateAfterBailout
(
JSContext
*
cx
HandleScript
outerScript
const
char
*
reason
)
{
if
(
!
outerScript
-
>
hasIonScript
(
)
)
{
JitSpew
(
JitSpew_BaselineBailouts
"
Ion
script
is
already
invalidated
"
)
;
return
;
}
MOZ_ASSERT
(
!
outerScript
-
>
ionScript
(
)
-
>
invalidated
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Invalidating
due
to
%
s
"
reason
)
;
Invalidate
(
cx
outerScript
)
;
}
static
void
HandleBoundsCheckFailure
(
JSContext
*
cx
HandleScript
outerScript
HandleScript
innerScript
)
{
JitSpew
(
JitSpew_IonBailouts
"
Bounds
check
failure
%
s
:
%
u
:
%
u
inlined
into
%
s
:
%
u
:
%
u
"
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
)
;
if
(
!
innerScript
-
>
failedBoundsCheck
(
)
)
{
innerScript
-
>
setFailedBoundsCheck
(
)
;
}
InvalidateAfterBailout
(
cx
outerScript
"
bounds
check
failure
"
)
;
if
(
innerScript
-
>
hasIonScript
(
)
)
{
Invalidate
(
cx
innerScript
)
;
}
}
static
void
HandleShapeGuardFailure
(
JSContext
*
cx
HandleScript
outerScript
HandleScript
innerScript
)
{
JitSpew
(
JitSpew_IonBailouts
"
Shape
guard
failure
%
s
:
%
u
:
%
u
inlined
into
%
s
:
%
u
:
%
u
"
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
)
;
outerScript
-
>
setFailedShapeGuard
(
)
;
InvalidateAfterBailout
(
cx
outerScript
"
shape
guard
failure
"
)
;
}
static
void
HandleBaselineInfoBailout
(
JSContext
*
cx
HandleScript
outerScript
HandleScript
innerScript
)
{
JitSpew
(
JitSpew_IonBailouts
"
Baseline
info
failure
%
s
:
%
u
:
%
u
inlined
into
%
s
:
%
u
:
%
u
"
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
)
;
InvalidateAfterBailout
(
cx
outerScript
"
invalid
baseline
info
"
)
;
}
static
void
HandleLexicalCheckFailure
(
JSContext
*
cx
HandleScript
outerScript
HandleScript
innerScript
)
{
JitSpew
(
JitSpew_IonBailouts
"
Lexical
check
failure
%
s
:
%
u
:
%
u
inlined
into
%
s
:
%
u
:
%
u
"
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
)
;
if
(
!
innerScript
-
>
failedLexicalCheck
(
)
)
{
innerScript
-
>
setFailedLexicalCheck
(
)
;
}
InvalidateAfterBailout
(
cx
outerScript
"
lexical
check
failure
"
)
;
if
(
innerScript
-
>
hasIonScript
(
)
)
{
Invalidate
(
cx
innerScript
)
;
}
}
static
bool
CopyFromRematerializedFrame
(
JSContext
*
cx
JitActivation
*
act
uint8_t
*
fp
size_t
inlineDepth
BaselineFrame
*
frame
)
{
RematerializedFrame
*
rematFrame
=
act
-
>
lookupRematerializedFrame
(
fp
inlineDepth
)
;
if
(
!
rematFrame
)
{
return
true
;
}
MOZ_ASSERT
(
rematFrame
-
>
script
(
)
=
=
frame
-
>
script
(
)
)
;
MOZ_ASSERT
(
rematFrame
-
>
numActualArgs
(
)
=
=
frame
-
>
numActualArgs
(
)
)
;
frame
-
>
setEnvironmentChain
(
rematFrame
-
>
environmentChain
(
)
)
;
if
(
frame
-
>
isFunctionFrame
(
)
)
{
frame
-
>
thisArgument
(
)
=
rematFrame
-
>
thisArgument
(
)
;
}
for
(
unsigned
i
=
0
;
i
<
frame
-
>
numActualArgs
(
)
;
i
+
+
)
{
frame
-
>
argv
(
)
[
i
]
=
rematFrame
-
>
argv
(
)
[
i
]
;
}
for
(
size_t
i
=
0
;
i
<
frame
-
>
script
(
)
-
>
nfixed
(
)
;
i
+
+
)
{
*
frame
-
>
valueSlot
(
i
)
=
rematFrame
-
>
locals
(
)
[
i
]
;
}
frame
-
>
setReturnValue
(
rematFrame
-
>
returnValue
(
)
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Copied
from
rematerialized
frame
at
(
%
p
%
zu
)
"
fp
inlineDepth
)
;
if
(
rematFrame
-
>
isDebuggee
(
)
)
{
frame
-
>
setIsDebuggee
(
)
;
return
Debugger
:
:
handleIonBailout
(
cx
rematFrame
frame
)
;
}
return
true
;
}
bool
jit
:
:
FinishBailoutToBaseline
(
BaselineBailoutInfo
*
bailoutInfo
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
js
:
:
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
JitSpew
(
JitSpew_BaselineBailouts
"
Done
restoring
frames
"
)
;
BaselineFrame
*
topFrame
=
GetTopBaselineFrame
(
cx
)
;
topFrame
-
>
setOverridePc
(
bailoutInfo
-
>
resumePC
)
;
jsbytecode
*
faultPC
=
bailoutInfo
-
>
faultPC
;
jsbytecode
*
tryPC
=
bailoutInfo
-
>
tryPC
;
uint32_t
numFrames
=
bailoutInfo
-
>
numFrames
;
MOZ_ASSERT
(
numFrames
>
0
)
;
BailoutKind
bailoutKind
=
bailoutInfo
-
>
bailoutKind
;
bool
checkGlobalDeclarationConflicts
=
bailoutInfo
-
>
checkGlobalDeclarationConflicts
;
uint8_t
*
incomingStack
=
bailoutInfo
-
>
incomingStack
;
auto
guardRemoveRematerializedFramesFromDebugger
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
JitActivation
*
act
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
act
-
>
removeRematerializedFramesFromDebugger
(
cx
incomingStack
)
;
}
)
;
js_free
(
bailoutInfo
)
;
bailoutInfo
=
nullptr
;
if
(
topFrame
-
>
environmentChain
(
)
)
{
if
(
!
EnsureHasEnvironmentObjects
(
cx
topFrame
)
)
{
return
false
;
}
if
(
checkGlobalDeclarationConflicts
)
{
Rooted
<
LexicalEnvironmentObject
*
>
lexicalEnv
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
)
;
RootedScript
script
(
cx
topFrame
-
>
script
(
)
)
;
if
(
!
CheckGlobalDeclarationConflicts
(
cx
script
lexicalEnv
cx
-
>
global
(
)
)
)
{
return
false
;
}
}
}
RootedScript
innerScript
(
cx
nullptr
)
;
RootedScript
outerScript
(
cx
nullptr
)
;
MOZ_ASSERT
(
cx
-
>
currentlyRunningInJit
(
)
)
;
JSJitFrameIter
iter
(
cx
-
>
activation
(
)
-
>
asJit
(
)
)
;
uint8_t
*
outerFp
=
nullptr
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
{
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
iter
.
prevFp
(
)
)
;
}
uint32_t
frameno
=
0
;
while
(
frameno
<
numFrames
)
{
MOZ_ASSERT
(
!
iter
.
isIonJS
(
)
)
;
if
(
iter
.
isBaselineJS
(
)
)
{
BaselineFrame
*
frame
=
iter
.
baselineFrame
(
)
;
MOZ_ASSERT
(
frame
-
>
script
(
)
-
>
hasBaselineScript
(
)
)
;
if
(
frame
-
>
environmentChain
(
)
&
&
frame
-
>
script
(
)
-
>
needsArgsObj
(
)
)
{
ArgumentsObject
*
argsObj
;
if
(
frame
-
>
hasArgsObj
(
)
)
{
argsObj
=
&
frame
-
>
argsObj
(
)
;
}
else
{
argsObj
=
ArgumentsObject
:
:
createExpected
(
cx
frame
)
;
if
(
!
argsObj
)
{
return
false
;
}
}
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
SetFrameArgumentsObject
(
cx
frame
script
argsObj
)
;
}
if
(
frameno
=
=
0
)
{
innerScript
=
frame
-
>
script
(
)
;
}
if
(
frameno
=
=
numFrames
-
1
)
{
outerScript
=
frame
-
>
script
(
)
;
outerFp
=
iter
.
fp
(
)
;
MOZ_ASSERT
(
outerFp
=
=
incomingStack
)
;
}
frameno
+
+
;
}
+
+
iter
;
}
MOZ_ASSERT
(
innerScript
)
;
MOZ_ASSERT
(
outerScript
)
;
MOZ_ASSERT
(
outerFp
)
;
JitActivation
*
act
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
if
(
act
-
>
hasRematerializedFrame
(
outerFp
)
)
{
JSJitFrameIter
iter
(
act
)
;
size_t
inlineDepth
=
numFrames
;
bool
ok
=
true
;
while
(
inlineDepth
>
0
)
{
if
(
iter
.
isBaselineJS
(
)
)
{
if
(
!
CopyFromRematerializedFrame
(
cx
act
outerFp
-
-
inlineDepth
iter
.
baselineFrame
(
)
)
)
{
ok
=
false
;
}
}
+
+
iter
;
}
if
(
!
ok
)
{
return
false
;
}
guardRemoveRematerializedFramesFromDebugger
.
release
(
)
;
act
-
>
removeRematerializedFrame
(
outerFp
)
;
}
if
(
cx
-
>
isExceptionPending
(
)
&
&
faultPC
)
{
EnvironmentIter
ei
(
cx
topFrame
faultPC
)
;
UnwindEnvironment
(
cx
ei
tryPC
)
;
}
JitSpew
(
JitSpew_BaselineBailouts
"
Restored
outerScript
=
(
%
s
:
%
u
:
%
u
%
u
)
innerScript
=
(
%
s
:
%
u
:
%
u
%
u
)
"
"
(
bailoutKind
=
%
u
)
"
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
outerScript
-
>
column
(
)
outerScript
-
>
getWarmUpCount
(
)
innerScript
-
>
filename
(
)
innerScript
-
>
lineno
(
)
innerScript
-
>
column
(
)
innerScript
-
>
getWarmUpCount
(
)
(
unsigned
)
bailoutKind
)
;
switch
(
bailoutKind
)
{
case
Bailout_Inevitable
:
case
Bailout_DuringVMCall
:
case
Bailout_NonJSFunctionCallee
:
case
Bailout_DynamicNameNotFound
:
case
Bailout_StringArgumentsEval
:
case
Bailout_Overflow
:
case
Bailout_Round
:
case
Bailout_NonPrimitiveInput
:
case
Bailout_PrecisionLoss
:
case
Bailout_TypeBarrierO
:
case
Bailout_TypeBarrierV
:
case
Bailout_MonitorTypes
:
case
Bailout_Hole
:
case
Bailout_NegativeIndex
:
case
Bailout_NonInt32Input
:
case
Bailout_NonNumericInput
:
case
Bailout_NonBooleanInput
:
case
Bailout_NonObjectInput
:
case
Bailout_NonStringInput
:
case
Bailout_NonSymbolInput
:
case
Bailout_NonBigIntInput
:
case
Bailout_NonSharedTypedArrayInput
:
case
Bailout_Debugger
:
case
Bailout_UninitializedThis
:
case
Bailout_BadDerivedConstructorReturn
:
break
;
case
Bailout_FirstExecution
:
break
;
case
Bailout_OverflowInvalidate
:
outerScript
-
>
setHadOverflowBailout
(
)
;
MOZ_FALLTHROUGH
;
case
Bailout_DoubleOutput
:
case
Bailout_ObjectIdentityOrTypeGuard
:
HandleBaselineInfoBailout
(
cx
outerScript
innerScript
)
;
break
;
case
Bailout_ArgumentCheck
:
break
;
case
Bailout_BoundsCheck
:
case
Bailout_Detached
:
HandleBoundsCheckFailure
(
cx
outerScript
innerScript
)
;
break
;
case
Bailout_ShapeGuard
:
HandleShapeGuardFailure
(
cx
outerScript
innerScript
)
;
break
;
case
Bailout_UninitializedLexical
:
HandleLexicalCheckFailure
(
cx
outerScript
innerScript
)
;
break
;
case
Bailout_IonExceptionDebugMode
:
return
false
;
default
:
MOZ_CRASH
(
"
Unknown
bailout
kind
!
"
)
;
}
CheckFrequentBailouts
(
cx
outerScript
bailoutKind
)
;
topFrame
-
>
clearOverridePc
(
)
;
return
true
;
}
