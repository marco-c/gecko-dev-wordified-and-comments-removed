#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsmath
.
h
"
#
include
"
jswin
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
using
namespace
js
:
:
jit
;
size_t
ExecutableAllocator
:
:
determinePageSize
(
)
{
SYSTEM_INFO
system_info
;
GetSystemInfo
(
&
system_info
)
;
return
system_info
.
dwPageSize
;
}
static
void
*
ComputeRandomAllocationAddress
(
)
{
#
ifdef
HAVE_64BIT_BUILD
static
const
uintptr_t
base
=
0x0000000080000000
;
static
const
uintptr_t
mask
=
0x000003ffffff0000
;
#
elif
defined
(
_M_IX86
)
|
|
defined
(
__i386__
)
static
const
uintptr_t
base
=
0x04000000
;
static
const
uintptr_t
mask
=
0x3fff0000
;
#
else
#
error
"
Unsupported
architecture
"
#
endif
uint64_t
rand
=
js
:
:
GenerateRandomSeed
(
)
;
return
(
void
*
)
(
base
|
(
rand
&
mask
)
)
;
}
#
ifdef
HAVE_64BIT_BUILD
static
js
:
:
JitExceptionHandler
sJitExceptionHandler
;
JS_FRIEND_API
(
void
)
js
:
:
SetJitExceptionHandler
(
JitExceptionHandler
handler
)
{
MOZ_ASSERT
(
!
sJitExceptionHandler
)
;
sJitExceptionHandler
=
handler
;
}
struct
UnwindInfo
{
uint8_t
version
:
3
;
uint8_t
flags
:
5
;
uint8_t
sizeOfPrologue
;
uint8_t
countOfUnwindCodes
;
uint8_t
frameRegister
:
4
;
uint8_t
frameOffset
:
4
;
ULONG
exceptionHandler
;
}
;
static
const
unsigned
ThunkLength
=
12
;
struct
ExceptionHandlerRecord
{
RUNTIME_FUNCTION
runtimeFunction
;
UnwindInfo
unwindInfo
;
uint8_t
thunk
[
ThunkLength
]
;
}
;
static
DWORD
ExceptionHandler
(
PEXCEPTION_RECORD
exceptionRecord
_EXCEPTION_REGISTRATION_RECORD
*
PCONTEXT
context
_EXCEPTION_REGISTRATION_RECORD
*
*
)
{
return
sJitExceptionHandler
(
exceptionRecord
context
)
;
}
static
bool
RegisterExecutableMemory
(
void
*
p
size_t
bytes
size_t
pageSize
)
{
DWORD
oldProtect
;
if
(
!
VirtualProtect
(
p
pageSize
PAGE_READWRITE
&
oldProtect
)
)
return
false
;
ExceptionHandlerRecord
*
r
=
reinterpret_cast
<
ExceptionHandlerRecord
*
>
(
p
)
;
r
-
>
runtimeFunction
.
BeginAddress
=
pageSize
;
r
-
>
runtimeFunction
.
EndAddress
=
(
DWORD
)
bytes
;
r
-
>
runtimeFunction
.
UnwindData
=
offsetof
(
ExceptionHandlerRecord
unwindInfo
)
;
r
-
>
unwindInfo
.
version
=
1
;
r
-
>
unwindInfo
.
flags
=
UNW_FLAG_EHANDLER
;
r
-
>
unwindInfo
.
sizeOfPrologue
=
0
;
r
-
>
unwindInfo
.
countOfUnwindCodes
=
0
;
r
-
>
unwindInfo
.
frameRegister
=
0
;
r
-
>
unwindInfo
.
frameOffset
=
0
;
r
-
>
unwindInfo
.
exceptionHandler
=
offsetof
(
ExceptionHandlerRecord
thunk
)
;
r
-
>
thunk
[
0
]
=
0x48
;
r
-
>
thunk
[
1
]
=
0xb8
;
void
*
handler
=
JS_FUNC_TO_DATA_PTR
(
void
*
ExceptionHandler
)
;
memcpy
(
&
r
-
>
thunk
[
2
]
&
handler
8
)
;
r
-
>
thunk
[
10
]
=
0xff
;
r
-
>
thunk
[
11
]
=
0xe0
;
if
(
!
VirtualProtect
(
p
pageSize
PAGE_EXECUTE_READ
&
oldProtect
)
)
return
false
;
AcquireStackWalkWorkaroundLock
(
)
;
bool
success
=
RtlAddFunctionTable
(
&
r
-
>
runtimeFunction
1
reinterpret_cast
<
DWORD64
>
(
p
)
)
;
ReleaseStackWalkWorkaroundLock
(
)
;
return
success
;
}
static
void
UnregisterExecutableMemory
(
void
*
p
size_t
bytes
size_t
pageSize
)
{
ExceptionHandlerRecord
*
r
=
reinterpret_cast
<
ExceptionHandlerRecord
*
>
(
p
)
;
AcquireStackWalkWorkaroundLock
(
)
;
RtlDeleteFunctionTable
(
&
r
-
>
runtimeFunction
)
;
ReleaseStackWalkWorkaroundLock
(
)
;
}
#
endif
static
const
size_t
VirtualAllocGranularity
=
64
*
1024
;
void
*
js
:
:
jit
:
:
AllocateExecutableMemory
(
size_t
bytes
unsigned
permissions
const
char
*
tag
size_t
pageSize
)
{
MOZ_ASSERT
(
bytes
%
pageSize
=
=
0
)
;
size_t
bytesRounded
=
JS_ROUNDUP
(
bytes
VirtualAllocGranularity
)
;
if
(
!
AddAllocatedExecutableBytes
(
bytesRounded
)
)
return
nullptr
;
auto
autoSubtract
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
SubAllocatedExecutableBytes
(
bytesRounded
)
;
}
)
;
#
ifdef
HAVE_64BIT_BUILD
if
(
sJitExceptionHandler
)
bytes
+
=
pageSize
;
#
endif
void
*
randomAddr
=
ComputeRandomAllocationAddress
(
)
;
void
*
p
=
VirtualAlloc
(
randomAddr
bytes
MEM_COMMIT
|
MEM_RESERVE
permissions
)
;
if
(
!
p
)
{
p
=
VirtualAlloc
(
nullptr
bytes
MEM_COMMIT
|
MEM_RESERVE
permissions
)
;
if
(
!
p
)
return
nullptr
;
}
#
ifdef
HAVE_64BIT_BUILD
if
(
sJitExceptionHandler
)
{
if
(
!
RegisterExecutableMemory
(
p
bytes
pageSize
)
)
{
VirtualFree
(
p
0
MEM_RELEASE
)
;
return
nullptr
;
}
p
=
(
uint8_t
*
)
p
+
pageSize
;
}
#
endif
autoSubtract
.
release
(
)
;
return
p
;
}
void
js
:
:
jit
:
:
DeallocateExecutableMemory
(
void
*
addr
size_t
bytes
size_t
pageSize
)
{
MOZ_ASSERT
(
bytes
%
pageSize
=
=
0
)
;
#
ifdef
HAVE_64BIT_BUILD
if
(
sJitExceptionHandler
)
{
addr
=
(
uint8_t
*
)
addr
-
pageSize
;
UnregisterExecutableMemory
(
addr
bytes
pageSize
)
;
}
#
endif
VirtualFree
(
addr
0
MEM_RELEASE
)
;
SubAllocatedExecutableBytes
(
JS_ROUNDUP
(
bytes
VirtualAllocGranularity
)
)
;
}
ExecutablePool
:
:
Allocation
ExecutableAllocator
:
:
systemAlloc
(
size_t
n
)
{
unsigned
flags
=
initialProtectionFlags
(
Executable
)
;
void
*
allocation
=
AllocateExecutableMemory
(
n
flags
"
js
-
jit
-
code
"
pageSize
)
;
ExecutablePool
:
:
Allocation
alloc
=
{
reinterpret_cast
<
char
*
>
(
allocation
)
n
}
;
return
alloc
;
}
void
ExecutableAllocator
:
:
systemRelease
(
const
ExecutablePool
:
:
Allocation
&
alloc
)
{
DeallocateExecutableMemory
(
alloc
.
pages
alloc
.
size
pageSize
)
;
}
#
if
defined
(
NON_WRITABLE_JIT_CODE
)
bool
ExecutableAllocator
:
:
reprotectRegion
(
void
*
start
size_t
size
ProtectionSetting
setting
)
{
MOZ_ASSERT
(
pageSize
)
;
intptr_t
startPtr
=
reinterpret_cast
<
intptr_t
>
(
start
)
;
intptr_t
pageStartPtr
=
startPtr
&
~
(
pageSize
-
1
)
;
void
*
pageStart
=
reinterpret_cast
<
void
*
>
(
pageStartPtr
)
;
size
+
=
(
startPtr
-
pageStartPtr
)
;
size
+
=
(
pageSize
-
1
)
;
size
&
=
~
(
pageSize
-
1
)
;
DWORD
oldProtect
;
int
flags
=
(
setting
=
=
Writable
)
?
PAGE_READWRITE
:
PAGE_EXECUTE_READ
;
return
VirtualProtect
(
pageStart
size
flags
&
oldProtect
)
;
}
#
endif
unsigned
ExecutableAllocator
:
:
initialProtectionFlags
(
ProtectionSetting
protection
)
{
#
ifdef
NON_WRITABLE_JIT_CODE
return
(
protection
=
=
Writable
)
?
PAGE_READWRITE
:
PAGE_EXECUTE_READ
;
#
else
return
PAGE_EXECUTE_READWRITE
;
#
endif
}
