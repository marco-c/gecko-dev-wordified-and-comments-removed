#
ifndef
jit_Bailouts_h
#
define
jit_Bailouts_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
class
AbstractFramePtr
;
namespace
jit
{
static
const
BailoutId
INVALID_BAILOUT_ID
=
BailoutId
(
-
1
)
;
static
const
uint32_t
BAILOUT_TABLE_SIZE
=
16
;
class
BailoutStack
;
class
InvalidationBailoutStack
;
class
IonScript
;
class
InlineFrameIterator
;
class
JitActivation
;
class
JitActivationIterator
;
class
JSJitFrameIter
;
struct
ResumeFromException
;
class
BailoutFrameInfo
{
MachineState
machine_
;
uint8_t
*
framePointer_
;
size_t
topFrameSize_
;
IonScript
*
topIonScript_
;
uint32_t
snapshotOffset_
;
JitActivation
*
activation_
;
void
attachOnJitActivation
(
const
JitActivationIterator
&
activations
)
;
public
:
BailoutFrameInfo
(
const
JitActivationIterator
&
activations
BailoutStack
*
sp
)
;
BailoutFrameInfo
(
const
JitActivationIterator
&
activations
InvalidationBailoutStack
*
sp
)
;
BailoutFrameInfo
(
const
JitActivationIterator
&
activations
const
JSJitFrameIter
&
frame
)
;
~
BailoutFrameInfo
(
)
;
uint8_t
*
fp
(
)
const
{
return
framePointer_
;
}
SnapshotOffset
snapshotOffset
(
)
const
{
return
snapshotOffset_
;
}
const
MachineState
*
machineState
(
)
const
{
return
&
machine_
;
}
size_t
topFrameSize
(
)
const
{
return
topFrameSize_
;
}
IonScript
*
ionScript
(
)
const
{
return
topIonScript_
;
}
JitActivation
*
activation
(
)
const
{
return
activation_
;
}
}
;
[
[
nodiscard
]
]
bool
EnsureHasEnvironmentObjects
(
JSContext
*
cx
AbstractFramePtr
fp
)
;
struct
BaselineBailoutInfo
;
[
[
nodiscard
]
]
bool
Bailout
(
BailoutStack
*
sp
BaselineBailoutInfo
*
*
info
)
;
[
[
nodiscard
]
]
bool
InvalidationBailout
(
InvalidationBailoutStack
*
sp
size_t
*
frameSizeOut
BaselineBailoutInfo
*
*
info
)
;
class
ExceptionBailoutInfo
{
size_t
frameNo_
;
jsbytecode
*
resumePC_
;
size_t
numExprSlots_
;
bool
isFinally_
=
false
;
RootedValue
finallyException_
;
public
:
ExceptionBailoutInfo
(
JSContext
*
cx
size_t
frameNo
jsbytecode
*
resumePC
size_t
numExprSlots
)
:
frameNo_
(
frameNo
)
resumePC_
(
resumePC
)
numExprSlots_
(
numExprSlots
)
finallyException_
(
cx
)
{
}
explicit
ExceptionBailoutInfo
(
JSContext
*
cx
)
:
frameNo_
(
0
)
resumePC_
(
nullptr
)
numExprSlots_
(
0
)
finallyException_
(
cx
)
{
}
bool
catchingException
(
)
const
{
return
!
!
resumePC_
;
}
bool
propagatingIonExceptionForDebugMode
(
)
const
{
return
!
resumePC_
;
}
size_t
frameNo
(
)
const
{
MOZ_ASSERT
(
catchingException
(
)
)
;
return
frameNo_
;
}
jsbytecode
*
resumePC
(
)
const
{
MOZ_ASSERT
(
catchingException
(
)
)
;
return
resumePC_
;
}
size_t
numExprSlots
(
)
const
{
MOZ_ASSERT
(
catchingException
(
)
)
;
return
numExprSlots_
;
}
bool
isFinally
(
)
const
{
return
isFinally_
;
}
void
setFinallyException
(
JS
:
:
Value
&
exception
)
{
MOZ_ASSERT
(
!
isFinally
(
)
)
;
isFinally_
=
true
;
finallyException_
=
exception
;
}
HandleValue
finallyException
(
)
const
{
MOZ_ASSERT
(
isFinally
(
)
)
;
return
finallyException_
;
}
}
;
[
[
nodiscard
]
]
bool
ExceptionHandlerBailout
(
JSContext
*
cx
const
InlineFrameIterator
&
frame
ResumeFromException
*
rfe
const
ExceptionBailoutInfo
&
excInfo
)
;
[
[
nodiscard
]
]
bool
FinishBailoutToBaseline
(
BaselineBailoutInfo
*
bailoutInfoArg
)
;
#
ifdef
DEBUG
[
[
nodiscard
]
]
bool
AssertBailoutStackDepth
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
ResumeMode
mode
uint32_t
exprStackSlots
)
;
#
endif
}
}
#
endif
