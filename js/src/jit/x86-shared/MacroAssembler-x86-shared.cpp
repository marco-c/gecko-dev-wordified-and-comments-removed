#
include
"
jit
/
x86
-
shared
/
MacroAssembler
-
x86
-
shared
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
void
MacroAssembler
:
:
clampDoubleToUint8
(
FloatRegister
input
Register
output
)
{
ScratchDoubleScope
scratch
(
*
this
)
;
MOZ_ASSERT
(
input
!
=
scratch
)
;
Label
positive
done
;
zeroDouble
(
scratch
)
;
branchDouble
(
DoubleGreaterThan
input
scratch
&
positive
)
;
{
move32
(
Imm32
(
0
)
output
)
;
jump
(
&
done
)
;
}
bind
(
&
positive
)
;
loadConstantDouble
(
0
.
5
scratch
)
;
addDouble
(
scratch
input
)
;
Label
outOfRange
;
vcvttsd2si
(
input
output
)
;
branch32
(
Assembler
:
:
Above
output
Imm32
(
255
)
&
outOfRange
)
;
{
convertInt32ToDouble
(
output
scratch
)
;
branchDouble
(
DoubleNotEqual
input
scratch
&
done
)
;
and32
(
Imm32
(
~
1
)
output
)
;
jump
(
&
done
)
;
}
bind
(
&
outOfRange
)
;
{
move32
(
Imm32
(
255
)
output
)
;
}
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
alignFrameForICArguments
(
AfterICSaveLive
&
aic
)
{
}
void
MacroAssembler
:
:
restoreFrameAlignmentForICArguments
(
AfterICSaveLive
&
aic
)
{
}
bool
MacroAssemblerX86Shared
:
:
buildOOLFakeExitFrame
(
void
*
fakeReturnAddr
)
{
uint32_t
descriptor
=
MakeFrameDescriptor
(
asMasm
(
)
.
framePushed
(
)
JitFrame_IonJS
ExitFrameLayout
:
:
Size
(
)
)
;
asMasm
(
)
.
Push
(
Imm32
(
descriptor
)
)
;
asMasm
(
)
.
Push
(
ImmPtr
(
fakeReturnAddr
)
)
;
return
true
;
}
void
MacroAssemblerX86Shared
:
:
branchNegativeZero
(
FloatRegister
reg
Register
scratch
Label
*
label
bool
maybeNonZero
)
{
#
if
defined
(
JS_CODEGEN_X86
)
Label
nonZero
;
if
(
maybeNonZero
)
{
ScratchDoubleScope
scratchDouble
(
asMasm
(
)
)
;
zeroDouble
(
scratchDouble
)
;
asMasm
(
)
.
branchDouble
(
DoubleNotEqual
reg
scratchDouble
&
nonZero
)
;
}
vmovmskpd
(
reg
scratch
)
;
asMasm
(
)
.
branchTest32
(
NonZero
scratch
Imm32
(
1
)
label
)
;
bind
(
&
nonZero
)
;
#
elif
defined
(
JS_CODEGEN_X64
)
vmovq
(
reg
scratch
)
;
cmpq
(
Imm32
(
1
)
scratch
)
;
j
(
Overflow
label
)
;
#
endif
}
void
MacroAssemblerX86Shared
:
:
branchNegativeZeroFloat32
(
FloatRegister
reg
Register
scratch
Label
*
label
)
{
vmovd
(
reg
scratch
)
;
cmp32
(
scratch
Imm32
(
1
)
)
;
j
(
Overflow
label
)
;
}
MacroAssembler
&
MacroAssemblerX86Shared
:
:
asMasm
(
)
{
return
*
static_cast
<
MacroAssembler
*
>
(
this
)
;
}
const
MacroAssembler
&
MacroAssemblerX86Shared
:
:
asMasm
(
)
const
{
return
*
static_cast
<
const
MacroAssembler
*
>
(
this
)
;
}
template
<
typename
T
>
void
MacroAssemblerX86Shared
:
:
compareExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
T
&
mem
Register
oldval
Register
newval
Register
temp
AnyRegister
output
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
compareExchange8SignExtend
(
mem
oldval
newval
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint8
:
compareExchange8ZeroExtend
(
mem
oldval
newval
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int16
:
compareExchange16SignExtend
(
mem
oldval
newval
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint16
:
compareExchange16ZeroExtend
(
mem
oldval
newval
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int32
:
compareExchange32
(
mem
oldval
newval
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint32
:
MOZ_ASSERT
(
output
.
isFloat
(
)
)
;
compareExchange32
(
mem
oldval
newval
temp
)
;
asMasm
(
)
.
convertUInt32ToDouble
(
temp
output
.
fpu
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
template
void
MacroAssemblerX86Shared
:
:
compareExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
Address
&
mem
Register
oldval
Register
newval
Register
temp
AnyRegister
output
)
;
template
void
MacroAssemblerX86Shared
:
:
compareExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
BaseIndex
&
mem
Register
oldval
Register
newval
Register
temp
AnyRegister
output
)
;
template
<
typename
T
>
void
MacroAssemblerX86Shared
:
:
atomicExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
T
&
mem
Register
value
Register
temp
AnyRegister
output
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
atomicExchange8SignExtend
(
mem
value
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint8
:
atomicExchange8ZeroExtend
(
mem
value
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int16
:
atomicExchange16SignExtend
(
mem
value
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint16
:
atomicExchange16ZeroExtend
(
mem
value
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Int32
:
atomicExchange32
(
mem
value
output
.
gpr
(
)
)
;
break
;
case
Scalar
:
:
Uint32
:
MOZ_ASSERT
(
output
.
isFloat
(
)
)
;
atomicExchange32
(
mem
value
temp
)
;
asMasm
(
)
.
convertUInt32ToDouble
(
temp
output
.
fpu
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
template
void
MacroAssemblerX86Shared
:
:
atomicExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
Address
&
mem
Register
value
Register
temp
AnyRegister
output
)
;
template
void
MacroAssemblerX86Shared
:
:
atomicExchangeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
BaseIndex
&
mem
Register
value
Register
temp
AnyRegister
output
)
;
template
<
class
T
class
Map
>
T
*
MacroAssemblerX86Shared
:
:
getConstant
(
const
typename
T
:
:
Pod
&
value
Map
&
map
Vector
<
T
0
SystemAllocPolicy
>
&
vec
)
{
typedef
typename
Map
:
:
AddPtr
AddPtr
;
if
(
!
map
.
initialized
(
)
)
{
enoughMemory_
&
=
map
.
init
(
)
;
if
(
!
enoughMemory_
)
return
nullptr
;
}
size_t
index
;
if
(
AddPtr
p
=
map
.
lookupForAdd
(
value
)
)
{
index
=
p
-
>
value
(
)
;
}
else
{
index
=
vec
.
length
(
)
;
enoughMemory_
&
=
vec
.
append
(
T
(
value
)
)
;
if
(
!
enoughMemory_
)
return
nullptr
;
enoughMemory_
&
=
map
.
add
(
p
value
index
)
;
if
(
!
enoughMemory_
)
return
nullptr
;
}
return
&
vec
[
index
]
;
}
MacroAssemblerX86Shared
:
:
Float
*
MacroAssemblerX86Shared
:
:
getFloat
(
wasm
:
:
RawF32
f
)
{
return
getConstant
<
Float
FloatMap
>
(
f
.
bits
(
)
floatMap_
floats_
)
;
}
MacroAssemblerX86Shared
:
:
Double
*
MacroAssemblerX86Shared
:
:
getDouble
(
wasm
:
:
RawF64
d
)
{
return
getConstant
<
Double
DoubleMap
>
(
d
.
bits
(
)
doubleMap_
doubles_
)
;
}
MacroAssemblerX86Shared
:
:
SimdData
*
MacroAssemblerX86Shared
:
:
getSimdData
(
const
SimdConstant
&
v
)
{
return
getConstant
<
SimdData
SimdMap
>
(
v
simdMap_
simds_
)
;
}
template
<
class
T
class
Map
>
static
bool
MergeConstants
(
size_t
delta
const
Vector
<
T
0
SystemAllocPolicy
>
&
other
Map
&
map
Vector
<
T
0
SystemAllocPolicy
>
&
vec
)
{
typedef
typename
Map
:
:
AddPtr
AddPtr
;
if
(
!
map
.
initialized
(
)
&
&
!
map
.
init
(
)
)
return
false
;
for
(
const
T
&
c
:
other
)
{
size_t
index
;
if
(
AddPtr
p
=
map
.
lookupForAdd
(
c
.
value
)
)
{
index
=
p
-
>
value
(
)
;
}
else
{
index
=
vec
.
length
(
)
;
if
(
!
vec
.
append
(
T
(
c
.
value
)
)
|
|
!
map
.
add
(
p
c
.
value
index
)
)
return
false
;
}
MacroAssemblerX86Shared
:
:
UsesVector
&
uses
=
vec
[
index
]
.
uses
;
for
(
CodeOffset
use
:
c
.
uses
)
{
use
.
offsetBy
(
delta
)
;
if
(
!
uses
.
append
(
use
)
)
return
false
;
}
}
return
true
;
}
bool
MacroAssemblerX86Shared
:
:
asmMergeWith
(
const
MacroAssemblerX86Shared
&
other
)
{
size_t
sizeBefore
=
masm
.
size
(
)
;
if
(
!
Assembler
:
:
asmMergeWith
(
other
)
)
return
false
;
if
(
!
MergeConstants
<
Double
DoubleMap
>
(
sizeBefore
other
.
doubles_
doubleMap_
doubles_
)
)
return
false
;
if
(
!
MergeConstants
<
Float
FloatMap
>
(
sizeBefore
other
.
floats_
floatMap_
floats_
)
)
return
false
;
if
(
!
MergeConstants
<
SimdData
SimdMap
>
(
sizeBefore
other
.
simds_
simdMap_
simds_
)
)
return
false
;
return
true
;
}
void
MacroAssemblerX86Shared
:
:
minMaxDouble
(
FloatRegister
first
FloatRegister
second
bool
canBeNaN
bool
isMax
)
{
Label
done
nan
minMaxInst
;
vucomisd
(
second
first
)
;
j
(
Assembler
:
:
NotEqual
&
minMaxInst
)
;
if
(
canBeNaN
)
j
(
Assembler
:
:
Parity
&
nan
)
;
if
(
isMax
)
vandpd
(
second
first
first
)
;
else
vorpd
(
second
first
first
)
;
jump
(
&
done
)
;
if
(
canBeNaN
)
{
bind
(
&
nan
)
;
vucomisd
(
first
first
)
;
j
(
Assembler
:
:
Parity
&
done
)
;
}
bind
(
&
minMaxInst
)
;
if
(
isMax
)
vmaxsd
(
second
first
first
)
;
else
vminsd
(
second
first
first
)
;
bind
(
&
done
)
;
}
void
MacroAssemblerX86Shared
:
:
minMaxFloat32
(
FloatRegister
first
FloatRegister
second
bool
canBeNaN
bool
isMax
)
{
Label
done
nan
minMaxInst
;
vucomiss
(
second
first
)
;
j
(
Assembler
:
:
NotEqual
&
minMaxInst
)
;
if
(
canBeNaN
)
j
(
Assembler
:
:
Parity
&
nan
)
;
if
(
isMax
)
vandps
(
second
first
first
)
;
else
vorps
(
second
first
first
)
;
jump
(
&
done
)
;
if
(
canBeNaN
)
{
bind
(
&
nan
)
;
vucomiss
(
first
first
)
;
j
(
Assembler
:
:
Parity
&
done
)
;
}
bind
(
&
minMaxInst
)
;
if
(
isMax
)
vmaxss
(
second
first
first
)
;
else
vminss
(
second
first
first
)
;
bind
(
&
done
)
;
}
void
MacroAssembler
:
:
flush
(
)
{
}
void
MacroAssembler
:
:
comment
(
const
char
*
msg
)
{
masm
.
comment
(
msg
)
;
}
void
MacroAssembler
:
:
PushRegsInMask
(
LiveRegisterSet
set
)
{
FloatRegisterSet
fpuSet
(
set
.
fpus
(
)
.
reduceSetForPush
(
)
)
;
unsigned
numFpu
=
fpuSet
.
size
(
)
;
int32_t
diffF
=
fpuSet
.
getPushSizeInBytes
(
)
;
int32_t
diffG
=
set
.
gprs
(
)
.
size
(
)
*
sizeof
(
intptr_t
)
;
for
(
GeneralRegisterBackwardIterator
iter
(
set
.
gprs
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
diffG
-
=
sizeof
(
intptr_t
)
;
Push
(
*
iter
)
;
}
MOZ_ASSERT
(
diffG
=
=
0
)
;
reserveStack
(
diffF
)
;
for
(
FloatRegisterBackwardIterator
iter
(
fpuSet
)
;
iter
.
more
(
)
;
+
+
iter
)
{
FloatRegister
reg
=
*
iter
;
diffF
-
=
reg
.
size
(
)
;
numFpu
-
=
1
;
Address
spillAddress
(
StackPointer
diffF
)
;
if
(
reg
.
isDouble
(
)
)
storeDouble
(
reg
spillAddress
)
;
else
if
(
reg
.
isSingle
(
)
)
storeFloat32
(
reg
spillAddress
)
;
else
if
(
reg
.
isSimd128
(
)
)
storeUnalignedSimd128Float
(
reg
spillAddress
)
;
else
MOZ_CRASH
(
"
Unknown
register
type
.
"
)
;
}
MOZ_ASSERT
(
numFpu
=
=
0
)
;
diffF
-
=
diffF
%
sizeof
(
uintptr_t
)
;
MOZ_ASSERT
(
diffF
=
=
0
)
;
}
void
MacroAssembler
:
:
PopRegsInMaskIgnore
(
LiveRegisterSet
set
LiveRegisterSet
ignore
)
{
FloatRegisterSet
fpuSet
(
set
.
fpus
(
)
.
reduceSetForPush
(
)
)
;
unsigned
numFpu
=
fpuSet
.
size
(
)
;
int32_t
diffG
=
set
.
gprs
(
)
.
size
(
)
*
sizeof
(
intptr_t
)
;
int32_t
diffF
=
fpuSet
.
getPushSizeInBytes
(
)
;
const
int32_t
reservedG
=
diffG
;
const
int32_t
reservedF
=
diffF
;
for
(
FloatRegisterBackwardIterator
iter
(
fpuSet
)
;
iter
.
more
(
)
;
+
+
iter
)
{
FloatRegister
reg
=
*
iter
;
diffF
-
=
reg
.
size
(
)
;
numFpu
-
=
1
;
if
(
ignore
.
has
(
reg
)
)
continue
;
Address
spillAddress
(
StackPointer
diffF
)
;
if
(
reg
.
isDouble
(
)
)
loadDouble
(
spillAddress
reg
)
;
else
if
(
reg
.
isSingle
(
)
)
loadFloat32
(
spillAddress
reg
)
;
else
if
(
reg
.
isSimd128
(
)
)
loadUnalignedSimd128Float
(
spillAddress
reg
)
;
else
MOZ_CRASH
(
"
Unknown
register
type
.
"
)
;
}
freeStack
(
reservedF
)
;
MOZ_ASSERT
(
numFpu
=
=
0
)
;
diffF
-
=
diffF
%
sizeof
(
uintptr_t
)
;
MOZ_ASSERT
(
diffF
=
=
0
)
;
if
(
ignore
.
emptyGeneral
(
)
)
{
for
(
GeneralRegisterForwardIterator
iter
(
set
.
gprs
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
diffG
-
=
sizeof
(
intptr_t
)
;
Pop
(
*
iter
)
;
}
}
else
{
for
(
GeneralRegisterBackwardIterator
iter
(
set
.
gprs
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
diffG
-
=
sizeof
(
intptr_t
)
;
if
(
!
ignore
.
has
(
*
iter
)
)
loadPtr
(
Address
(
StackPointer
diffG
)
*
iter
)
;
}
freeStack
(
reservedG
)
;
}
MOZ_ASSERT
(
diffG
=
=
0
)
;
}
void
MacroAssembler
:
:
Push
(
const
Operand
op
)
{
push
(
op
)
;
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Push
(
Register
reg
)
{
push
(
reg
)
;
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Push
(
const
Imm32
imm
)
{
push
(
imm
)
;
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Push
(
const
ImmWord
imm
)
{
push
(
imm
)
;
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Push
(
const
ImmPtr
imm
)
{
Push
(
ImmWord
(
uintptr_t
(
imm
.
value
)
)
)
;
}
void
MacroAssembler
:
:
Push
(
const
ImmGCPtr
ptr
)
{
push
(
ptr
)
;
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Push
(
FloatRegister
t
)
{
push
(
t
)
;
adjustFrame
(
sizeof
(
double
)
)
;
}
void
MacroAssembler
:
:
Pop
(
const
Operand
op
)
{
pop
(
op
)
;
implicitPop
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Pop
(
Register
reg
)
{
pop
(
reg
)
;
implicitPop
(
sizeof
(
intptr_t
)
)
;
}
void
MacroAssembler
:
:
Pop
(
FloatRegister
reg
)
{
pop
(
reg
)
;
implicitPop
(
sizeof
(
double
)
)
;
}
void
MacroAssembler
:
:
Pop
(
const
ValueOperand
&
val
)
{
popValue
(
val
)
;
implicitPop
(
sizeof
(
Value
)
)
;
}
CodeOffset
MacroAssembler
:
:
call
(
Register
reg
)
{
return
Assembler
:
:
call
(
reg
)
;
}
CodeOffset
MacroAssembler
:
:
call
(
Label
*
label
)
{
return
Assembler
:
:
call
(
label
)
;
}
void
MacroAssembler
:
:
call
(
const
Address
&
addr
)
{
Assembler
:
:
call
(
Operand
(
addr
.
base
addr
.
offset
)
)
;
}
void
MacroAssembler
:
:
call
(
wasm
:
:
SymbolicAddress
target
)
{
mov
(
target
eax
)
;
Assembler
:
:
call
(
eax
)
;
}
void
MacroAssembler
:
:
call
(
ImmWord
target
)
{
Assembler
:
:
call
(
target
)
;
}
void
MacroAssembler
:
:
call
(
ImmPtr
target
)
{
Assembler
:
:
call
(
target
)
;
}
void
MacroAssembler
:
:
call
(
JitCode
*
target
)
{
Assembler
:
:
call
(
target
)
;
}
CodeOffset
MacroAssembler
:
:
callWithPatch
(
)
{
return
Assembler
:
:
callWithPatch
(
)
;
}
void
MacroAssembler
:
:
patchCall
(
uint32_t
callerOffset
uint32_t
calleeOffset
)
{
Assembler
:
:
patchCall
(
callerOffset
calleeOffset
)
;
}
void
MacroAssembler
:
:
callAndPushReturnAddress
(
Register
reg
)
{
call
(
reg
)
;
}
void
MacroAssembler
:
:
callAndPushReturnAddress
(
Label
*
label
)
{
call
(
label
)
;
}
CodeOffset
MacroAssembler
:
:
farJumpWithPatch
(
)
{
return
Assembler
:
:
farJumpWithPatch
(
)
;
}
void
MacroAssembler
:
:
patchFarJump
(
CodeOffset
farJump
uint32_t
targetOffset
)
{
Assembler
:
:
patchFarJump
(
farJump
targetOffset
)
;
}
void
MacroAssembler
:
:
repatchFarJump
(
uint8_t
*
code
uint32_t
farJumpOffset
uint32_t
targetOffset
)
{
Assembler
:
:
repatchFarJump
(
code
farJumpOffset
targetOffset
)
;
}
CodeOffset
MacroAssembler
:
:
nopPatchableToNearJump
(
)
{
return
Assembler
:
:
twoByteNop
(
)
;
}
void
MacroAssembler
:
:
patchNopToNearJump
(
uint8_t
*
jump
uint8_t
*
target
)
{
Assembler
:
:
patchTwoByteNopToJump
(
jump
target
)
;
}
void
MacroAssembler
:
:
patchNearJumpToNop
(
uint8_t
*
jump
)
{
Assembler
:
:
patchJumpToTwoByteNop
(
jump
)
;
}
uint32_t
MacroAssembler
:
:
pushFakeReturnAddress
(
Register
scratch
)
{
CodeLabel
cl
;
mov
(
cl
.
patchAt
(
)
scratch
)
;
Push
(
scratch
)
;
use
(
cl
.
target
(
)
)
;
uint32_t
retAddr
=
currentOffset
(
)
;
addCodeLabel
(
cl
)
;
return
retAddr
;
}
struct
MOZ_RAII
AutoHandleWasmTruncateToIntErrors
{
MacroAssembler
&
masm
;
Label
inputIsNaN
;
Label
fail
;
wasm
:
:
TrapOffset
off
;
explicit
AutoHandleWasmTruncateToIntErrors
(
MacroAssembler
&
masm
wasm
:
:
TrapOffset
off
)
:
masm
(
masm
)
off
(
off
)
{
}
~
AutoHandleWasmTruncateToIntErrors
(
)
{
masm
.
bind
(
&
fail
)
;
masm
.
jump
(
wasm
:
:
TrapDesc
(
off
wasm
:
:
Trap
:
:
IntegerOverflow
masm
.
framePushed
(
)
)
)
;
masm
.
bind
(
&
inputIsNaN
)
;
masm
.
jump
(
wasm
:
:
TrapDesc
(
off
wasm
:
:
Trap
:
:
InvalidConversionToInteger
masm
.
framePushed
(
)
)
)
;
}
}
;
void
MacroAssembler
:
:
wasmTruncateDoubleToInt32
(
FloatRegister
input
Register
output
Label
*
oolEntry
)
{
vcvttsd2si
(
input
output
)
;
cmp32
(
output
Imm32
(
1
)
)
;
j
(
Assembler
:
:
Overflow
oolEntry
)
;
}
void
MacroAssembler
:
:
wasmTruncateFloat32ToInt32
(
FloatRegister
input
Register
output
Label
*
oolEntry
)
{
vcvttss2si
(
input
output
)
;
cmp32
(
output
Imm32
(
1
)
)
;
j
(
Assembler
:
:
Overflow
oolEntry
)
;
}
void
MacroAssembler
:
:
outOfLineWasmTruncateDoubleToInt32
(
FloatRegister
input
bool
isUnsigned
wasm
:
:
TrapOffset
off
Label
*
rejoin
)
{
AutoHandleWasmTruncateToIntErrors
traps
(
*
this
off
)
;
branchDouble
(
Assembler
:
:
DoubleUnordered
input
input
&
traps
.
inputIsNaN
)
;
if
(
isUnsigned
)
return
;
loadConstantDouble
(
double
(
INT32_MIN
)
-
1
.
0
ScratchDoubleReg
)
;
branchDouble
(
Assembler
:
:
DoubleLessThanOrEqual
input
ScratchDoubleReg
&
traps
.
fail
)
;
loadConstantDouble
(
double
(
INT32_MIN
)
ScratchDoubleReg
)
;
branchDouble
(
Assembler
:
:
DoubleGreaterThan
input
ScratchDoubleReg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
}
void
MacroAssembler
:
:
outOfLineWasmTruncateFloat32ToInt32
(
FloatRegister
input
bool
isUnsigned
wasm
:
:
TrapOffset
off
Label
*
rejoin
)
{
AutoHandleWasmTruncateToIntErrors
traps
(
*
this
off
)
;
branchFloat
(
Assembler
:
:
DoubleUnordered
input
input
&
traps
.
inputIsNaN
)
;
if
(
isUnsigned
)
return
;
loadConstantFloat32
(
float
(
INT32_MIN
)
ScratchFloat32Reg
)
;
branchFloat
(
Assembler
:
:
DoubleNotEqual
input
ScratchFloat32Reg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
}
void
MacroAssembler
:
:
outOfLineWasmTruncateDoubleToInt64
(
FloatRegister
input
bool
isUnsigned
wasm
:
:
TrapOffset
off
Label
*
rejoin
)
{
AutoHandleWasmTruncateToIntErrors
traps
(
*
this
off
)
;
branchDouble
(
Assembler
:
:
DoubleUnordered
input
input
&
traps
.
inputIsNaN
)
;
if
(
isUnsigned
)
{
loadConstantDouble
(
-
0
.
0
ScratchDoubleReg
)
;
branchDouble
(
Assembler
:
:
DoubleGreaterThan
input
ScratchDoubleReg
&
traps
.
fail
)
;
loadConstantDouble
(
-
1
.
0
ScratchDoubleReg
)
;
branchDouble
(
Assembler
:
:
DoubleLessThanOrEqual
input
ScratchDoubleReg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
return
;
}
loadConstantDouble
(
double
(
int64_t
(
INT64_MIN
)
)
ScratchDoubleReg
)
;
branchDouble
(
Assembler
:
:
DoubleNotEqual
input
ScratchDoubleReg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
}
void
MacroAssembler
:
:
outOfLineWasmTruncateFloat32ToInt64
(
FloatRegister
input
bool
isUnsigned
wasm
:
:
TrapOffset
off
Label
*
rejoin
)
{
AutoHandleWasmTruncateToIntErrors
traps
(
*
this
off
)
;
branchFloat
(
Assembler
:
:
DoubleUnordered
input
input
&
traps
.
inputIsNaN
)
;
if
(
isUnsigned
)
{
loadConstantFloat32
(
-
0
.
0f
ScratchFloat32Reg
)
;
branchFloat
(
Assembler
:
:
DoubleGreaterThan
input
ScratchFloat32Reg
&
traps
.
fail
)
;
loadConstantFloat32
(
-
1
.
0f
ScratchFloat32Reg
)
;
branchFloat
(
Assembler
:
:
DoubleLessThanOrEqual
input
ScratchFloat32Reg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
return
;
}
loadConstantFloat32
(
float
(
int64_t
(
INT64_MIN
)
)
ScratchFloat32Reg
)
;
branchFloat
(
Assembler
:
:
DoubleNotEqual
input
ScratchFloat32Reg
&
traps
.
fail
)
;
jump
(
rejoin
)
;
}
