#
ifndef
jit_FixedList_h
#
define
jit_FixedList_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jit
/
JitAllocPolicy
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
js
{
namespace
jit
{
template
<
typename
T
>
class
FixedList
{
T
*
list_
;
size_t
length_
;
private
:
FixedList
(
const
FixedList
&
)
;
void
operator
=
(
const
FixedList
*
)
;
public
:
FixedList
(
)
:
list_
(
nullptr
)
length_
(
0
)
{
}
MOZ_MUST_USE
bool
init
(
TempAllocator
&
alloc
size_t
length
)
{
if
(
length
=
=
0
)
{
return
true
;
}
list_
=
alloc
.
allocateArray
<
T
>
(
length
)
;
if
(
!
list_
)
{
return
false
;
}
length_
=
length
;
return
true
;
}
size_t
empty
(
)
const
{
return
length_
=
=
0
;
}
size_t
length
(
)
const
{
return
length_
;
}
void
shrink
(
size_t
num
)
{
MOZ_ASSERT
(
num
<
length_
)
;
length_
-
=
num
;
}
MOZ_MUST_USE
bool
growBy
(
TempAllocator
&
alloc
size_t
num
)
{
size_t
newlength
=
length_
+
num
;
if
(
newlength
<
length_
)
{
return
false
;
}
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
CalculateAllocSize
<
T
>
(
newlength
&
bytes
)
)
)
{
return
false
;
}
T
*
list
=
(
T
*
)
alloc
.
allocate
(
bytes
)
;
if
(
MOZ_UNLIKELY
(
!
list
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
length_
;
i
+
+
)
{
list
[
i
]
=
list_
[
i
]
;
}
length_
+
=
num
;
list_
=
list
;
return
true
;
}
T
&
operator
[
]
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
length_
)
;
return
list_
[
index
]
;
}
const
T
&
operator
[
]
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
length_
)
;
return
list_
[
index
]
;
}
T
*
data
(
)
{
return
list_
;
}
T
*
begin
(
)
{
return
list_
;
}
T
*
end
(
)
{
return
list_
+
length_
;
}
}
;
}
}
#
endif
