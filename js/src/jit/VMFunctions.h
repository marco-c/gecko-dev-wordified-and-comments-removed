#
ifndef
jit_VMFunctions_h
#
define
jit_VMFunctions_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
namespace
js
{
class
NamedLambdaObject
;
class
WithScope
;
class
InlineTypedObject
;
class
GeneratorObject
;
class
RegExpObject
;
class
TypedArrayObject
;
namespace
gc
{
struct
Cell
;
}
namespace
jit
{
enum
DataType
:
uint8_t
{
Type_Void
Type_Bool
Type_Int32
Type_Double
Type_Pointer
Type_Object
Type_Value
Type_Handle
}
;
struct
PopValues
{
uint8_t
numValues
;
explicit
constexpr
PopValues
(
uint8_t
numValues
)
:
numValues
(
numValues
)
{
}
}
;
enum
MaybeTailCall
:
bool
{
TailCall
NonTailCall
}
;
struct
VMFunction
{
static
VMFunction
*
functions
;
VMFunction
*
next
;
void
*
wrapped
;
#
if
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_TRACE_LOGGING
)
const
char
*
name_
;
#
endif
enum
RootType
:
uint8_t
{
RootNone
=
0
RootObject
RootString
RootId
RootFunction
RootValue
RootCell
}
;
uint64_t
argumentRootTypes
;
enum
ArgProperties
{
WordByValue
=
0
DoubleByValue
=
1
WordByRef
=
2
DoubleByRef
=
3
Word
=
0
Double
=
1
ByRef
=
2
}
;
uint32_t
argumentProperties
;
uint32_t
argumentPassedInFloatRegs
;
uint8_t
explicitArgs
;
RootType
outParamRootType
;
DataType
outParam
;
DataType
returnType
;
uint8_t
extraValuesToPop
;
MaybeTailCall
expectTailCall
;
uint32_t
argc
(
)
const
{
return
1
+
explicitArgc
(
)
+
(
(
outParam
=
=
Type_Void
)
?
0
:
1
)
;
}
DataType
failType
(
)
const
{
return
returnType
;
}
bool
returnsData
(
)
const
{
return
returnType
=
=
Type_Object
|
|
outParam
!
=
Type_Void
;
}
ArgProperties
argProperties
(
uint32_t
explicitArg
)
const
{
return
ArgProperties
(
(
argumentProperties
>
>
(
2
*
explicitArg
)
)
&
3
)
;
}
RootType
argRootType
(
uint32_t
explicitArg
)
const
{
return
RootType
(
(
argumentRootTypes
>
>
(
3
*
explicitArg
)
)
&
7
)
;
}
bool
argPassedInFloatReg
(
uint32_t
explicitArg
)
const
{
return
(
(
argumentPassedInFloatRegs
>
>
explicitArg
)
&
1
)
=
=
1
;
}
#
if
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_TRACE_LOGGING
)
const
char
*
name
(
)
const
{
return
name_
;
}
#
endif
size_t
explicitStackSlots
(
)
const
{
size_t
stackSlots
=
explicitArgs
;
uint32_t
n
=
(
(
1
<
<
(
explicitArgs
*
2
)
)
-
1
)
&
0x55555555
&
argumentProperties
;
while
(
n
)
{
stackSlots
+
+
;
n
&
=
n
-
1
;
}
return
stackSlots
;
}
size_t
explicitArgc
(
)
const
{
size_t
stackSlots
=
explicitArgs
;
uint32_t
n
=
(
(
1
<
<
(
explicitArgs
*
2
)
)
-
1
)
&
argumentProperties
;
n
=
(
n
&
0x55555555
)
&
~
(
n
>
>
1
)
;
while
(
n
)
{
stackSlots
+
+
;
n
&
=
n
-
1
;
}
return
stackSlots
;
}
size_t
doubleByRefArgs
(
)
const
{
size_t
count
=
0
;
uint32_t
n
=
(
(
1
<
<
(
explicitArgs
*
2
)
)
-
1
)
&
argumentProperties
;
n
=
(
n
&
0x55555555
)
&
(
n
>
>
1
)
;
while
(
n
)
{
count
+
+
;
n
&
=
n
-
1
;
}
return
count
;
}
constexpr
VMFunction
(
void
*
wrapped
const
char
*
name
uint32_t
explicitArgs
uint32_t
argumentProperties
uint32_t
argumentPassedInFloatRegs
uint64_t
argRootTypes
DataType
outParam
RootType
outParamRootType
DataType
returnType
uint8_t
extraValuesToPop
=
0
MaybeTailCall
expectTailCall
=
NonTailCall
)
:
next
(
nullptr
)
wrapped
(
wrapped
)
#
if
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_TRACE_LOGGING
)
name_
(
name
)
#
endif
argumentRootTypes
(
argRootTypes
)
argumentProperties
(
argumentProperties
)
argumentPassedInFloatRegs
(
argumentPassedInFloatRegs
)
explicitArgs
(
explicitArgs
)
outParamRootType
(
outParamRootType
)
outParam
(
outParam
)
returnType
(
returnType
)
extraValuesToPop
(
extraValuesToPop
)
expectTailCall
(
expectTailCall
)
{
}
VMFunction
(
const
VMFunction
&
o
)
:
next
(
functions
)
wrapped
(
o
.
wrapped
)
#
if
defined
(
JS_JITSPEW
)
|
|
defined
(
JS_TRACE_LOGGING
)
name_
(
o
.
name_
)
#
endif
argumentRootTypes
(
o
.
argumentRootTypes
)
argumentProperties
(
o
.
argumentProperties
)
argumentPassedInFloatRegs
(
o
.
argumentPassedInFloatRegs
)
explicitArgs
(
o
.
explicitArgs
)
outParamRootType
(
o
.
outParamRootType
)
outParam
(
o
.
outParam
)
returnType
(
o
.
returnType
)
extraValuesToPop
(
o
.
extraValuesToPop
)
expectTailCall
(
o
.
expectTailCall
)
{
functions
=
this
;
MOZ_ASSERT_IF
(
outParam
!
=
Type_Void
returnType
=
=
Type_Void
|
|
returnType
=
=
Type_Bool
)
;
MOZ_ASSERT
(
returnType
=
=
Type_Void
|
|
returnType
=
=
Type_Bool
|
|
returnType
=
=
Type_Object
)
;
}
typedef
const
VMFunction
*
Lookup
;
static
HashNumber
hash
(
const
VMFunction
*
f
)
{
HashNumber
hash
=
0
;
hash
=
mozilla
:
:
AddToHash
(
hash
f
-
>
wrapped
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
f
-
>
expectTailCall
)
;
return
hash
;
}
static
bool
match
(
const
VMFunction
*
f1
const
VMFunction
*
f2
)
{
if
(
f1
-
>
wrapped
!
=
f2
-
>
wrapped
|
|
f1
-
>
expectTailCall
!
=
f2
-
>
expectTailCall
)
{
return
false
;
}
MOZ_ASSERT
(
f1
-
>
extraValuesToPop
=
=
f2
-
>
extraValuesToPop
)
;
MOZ_ASSERT
(
strcmp
(
f1
-
>
name_
f2
-
>
name_
)
=
=
0
)
;
MOZ_ASSERT
(
f1
-
>
explicitArgs
=
=
f2
-
>
explicitArgs
)
;
MOZ_ASSERT
(
f1
-
>
argumentProperties
=
=
f2
-
>
argumentProperties
)
;
MOZ_ASSERT
(
f1
-
>
argumentPassedInFloatRegs
=
=
f2
-
>
argumentPassedInFloatRegs
)
;
MOZ_ASSERT
(
f1
-
>
outParam
=
=
f2
-
>
outParam
)
;
MOZ_ASSERT
(
f1
-
>
returnType
=
=
f2
-
>
returnType
)
;
MOZ_ASSERT
(
f1
-
>
argumentRootTypes
=
=
f2
-
>
argumentRootTypes
)
;
MOZ_ASSERT
(
f1
-
>
outParamRootType
=
=
f2
-
>
outParamRootType
)
;
return
true
;
}
}
;
template
<
class
>
struct
TypeToDataType
{
}
;
template
<
>
struct
TypeToDataType
<
void
>
{
static
const
DataType
result
=
Type_Void
;
}
;
template
<
>
struct
TypeToDataType
<
bool
>
{
static
const
DataType
result
=
Type_Bool
;
}
;
template
<
>
struct
TypeToDataType
<
JSObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
JSFunction
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
NativeObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
PlainObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
InlineTypedObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
NamedLambdaObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
LexicalEnvironmentObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
ArrayObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
TypedArrayObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
ArrayIteratorObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
StringIteratorObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
RegExpStringIteratorObject
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
JSString
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
JSFlatString
*
>
{
static
const
DataType
result
=
Type_Object
;
}
;
template
<
>
struct
TypeToDataType
<
HandleObject
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandleString
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandlePropertyName
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandleFunction
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
NativeObject
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
InlineTypedObject
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
ArrayObject
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
GeneratorObject
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
PlainObject
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
WithScope
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
LexicalScope
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
Handle
<
Scope
*
>
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandleScript
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandleValue
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
MutableHandleValue
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
TypeToDataType
<
HandleId
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
class
T
>
struct
TypeToArgProperties
{
static
const
uint32_t
result
=
(
sizeof
(
T
)
<
=
sizeof
(
void
*
)
?
VMFunction
:
:
Word
:
VMFunction
:
:
Double
)
;
}
;
template
<
>
struct
TypeToArgProperties
<
const
Value
&
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
Value
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleObject
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
JSObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleString
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
JSString
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandlePropertyName
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
PropertyName
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleFunction
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
JSFunction
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
NativeObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
NativeObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
InlineTypedObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
InlineTypedObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
ArrayObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
ArrayObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
GeneratorObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
GeneratorObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
PlainObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
PlainObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
RegExpObject
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
RegExpObject
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
WithScope
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
WithScope
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
LexicalScope
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
LexicalScope
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
Handle
<
Scope
*
>
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
Scope
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleScript
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
JSScript
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleValue
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
Value
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
MutableHandleValue
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
Value
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleId
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
jsid
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleShape
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
Shape
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
>
struct
TypeToArgProperties
<
HandleObjectGroup
>
{
static
const
uint32_t
result
=
TypeToArgProperties
<
ObjectGroup
*
>
:
:
result
|
VMFunction
:
:
ByRef
;
}
;
template
<
class
T
>
struct
TypeToPassInFloatReg
{
static
const
uint32_t
result
=
0
;
}
;
template
<
>
struct
TypeToPassInFloatReg
<
double
>
{
static
const
uint32_t
result
=
1
;
}
;
template
<
class
T
>
struct
TypeToRootType
{
static
const
uint32_t
result
=
VMFunction
:
:
RootNone
;
}
;
template
<
>
struct
TypeToRootType
<
HandleObject
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
HandleString
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootString
;
}
;
template
<
>
struct
TypeToRootType
<
HandlePropertyName
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootString
;
}
;
template
<
>
struct
TypeToRootType
<
HandleFunction
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootFunction
;
}
;
template
<
>
struct
TypeToRootType
<
HandleValue
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootValue
;
}
;
template
<
>
struct
TypeToRootType
<
MutableHandleValue
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootValue
;
}
;
template
<
>
struct
TypeToRootType
<
HandleId
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootId
;
}
;
template
<
>
struct
TypeToRootType
<
HandleShape
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
>
struct
TypeToRootType
<
HandleObjectGroup
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
>
struct
TypeToRootType
<
HandleScript
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
NativeObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
InlineTypedObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
ArrayObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
GeneratorObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
PlainObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
RegExpObject
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
LexicalScope
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
WithScope
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
>
struct
TypeToRootType
<
Handle
<
Scope
*
>
>
{
static
const
uint32_t
result
=
VMFunction
:
:
RootCell
;
}
;
template
<
class
T
>
struct
TypeToRootType
<
Handle
<
T
>
>
{
}
;
template
<
class
>
struct
OutParamToDataType
{
static
const
DataType
result
=
Type_Void
;
}
;
template
<
>
struct
OutParamToDataType
<
Value
*
>
{
static
const
DataType
result
=
Type_Value
;
}
;
template
<
>
struct
OutParamToDataType
<
int
*
>
{
static
const
DataType
result
=
Type_Int32
;
}
;
template
<
>
struct
OutParamToDataType
<
uint32_t
*
>
{
static
const
DataType
result
=
Type_Int32
;
}
;
template
<
>
struct
OutParamToDataType
<
uint8_t
*
*
>
{
static
const
DataType
result
=
Type_Pointer
;
}
;
template
<
>
struct
OutParamToDataType
<
bool
*
>
{
static
const
DataType
result
=
Type_Bool
;
}
;
template
<
>
struct
OutParamToDataType
<
double
*
>
{
static
const
DataType
result
=
Type_Double
;
}
;
template
<
>
struct
OutParamToDataType
<
MutableHandleValue
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
OutParamToDataType
<
MutableHandleObject
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
>
struct
OutParamToDataType
<
MutableHandleString
>
{
static
const
DataType
result
=
Type_Handle
;
}
;
template
<
class
>
struct
OutParamToRootType
{
static
const
VMFunction
:
:
RootType
result
=
VMFunction
:
:
RootNone
;
}
;
template
<
>
struct
OutParamToRootType
<
MutableHandleValue
>
{
static
const
VMFunction
:
:
RootType
result
=
VMFunction
:
:
RootValue
;
}
;
template
<
>
struct
OutParamToRootType
<
MutableHandleObject
>
{
static
const
VMFunction
:
:
RootType
result
=
VMFunction
:
:
RootObject
;
}
;
template
<
>
struct
OutParamToRootType
<
MutableHandleString
>
{
static
const
VMFunction
:
:
RootType
result
=
VMFunction
:
:
RootString
;
}
;
template
<
class
>
struct
MatchContext
{
}
;
template
<
>
struct
MatchContext
<
JSContext
*
>
{
static
const
bool
valid
=
true
;
}
;
template
<
typename
.
.
.
ArgTypes
>
struct
LastArg
;
template
<
>
struct
LastArg
<
>
{
typedef
void
Type
;
static
constexpr
size_t
nbArgs
=
0
;
}
;
template
<
typename
HeadType
>
struct
LastArg
<
HeadType
>
{
typedef
HeadType
Type
;
static
constexpr
size_t
nbArgs
=
1
;
}
;
template
<
typename
HeadType
typename
.
.
.
TailTypes
>
struct
LastArg
<
HeadType
TailTypes
.
.
.
>
{
typedef
typename
LastArg
<
TailTypes
.
.
.
>
:
:
Type
Type
;
static
constexpr
size_t
nbArgs
=
LastArg
<
TailTypes
.
.
.
>
:
:
nbArgs
+
1
;
}
;
template
<
template
<
typename
>
class
Each
typename
ResultType
size_t
Shift
typename
.
.
.
Args
>
struct
BitMask
;
template
<
template
<
typename
>
class
Each
typename
ResultType
size_t
Shift
>
struct
BitMask
<
Each
ResultType
Shift
>
{
static
constexpr
ResultType
result
=
ResultType
(
)
;
}
;
template
<
template
<
typename
>
class
Each
typename
ResultType
size_t
Shift
typename
HeadType
typename
.
.
.
TailTypes
>
struct
BitMask
<
Each
ResultType
Shift
HeadType
TailTypes
.
.
.
>
{
static_assert
(
ResultType
(
Each
<
HeadType
>
:
:
result
)
<
(
1
<
<
Shift
)
"
not
enough
bits
reserved
by
the
shift
for
individual
results
"
)
;
static_assert
(
LastArg
<
TailTypes
.
.
.
>
:
:
nbArgs
<
(
8
*
sizeof
(
ResultType
)
/
Shift
)
"
not
enough
bits
in
the
result
type
to
store
all
bit
masks
"
)
;
static
constexpr
ResultType
result
=
ResultType
(
Each
<
HeadType
>
:
:
result
)
|
(
BitMask
<
Each
ResultType
Shift
TailTypes
.
.
.
>
:
:
result
<
<
Shift
)
;
}
;
template
<
typename
.
.
.
Args
>
struct
FunctionInfo
;
template
<
class
R
class
Context
typename
.
.
.
Args
>
struct
FunctionInfo
<
R
(
*
)
(
Context
Args
.
.
.
)
>
:
public
VMFunction
{
typedef
R
(
*
pf
)
(
Context
Args
.
.
.
)
;
static
DataType
returnType
(
)
{
return
TypeToDataType
<
R
>
:
:
result
;
}
static
DataType
outParam
(
)
{
return
OutParamToDataType
<
typename
LastArg
<
Args
.
.
.
>
:
:
Type
>
:
:
result
;
}
static
RootType
outParamRootType
(
)
{
return
OutParamToRootType
<
typename
LastArg
<
Args
.
.
.
>
:
:
Type
>
:
:
result
;
}
static
size_t
NbArgs
(
)
{
return
LastArg
<
Args
.
.
.
>
:
:
nbArgs
;
}
static
size_t
explicitArgs
(
)
{
return
NbArgs
(
)
-
(
outParam
(
)
!
=
Type_Void
?
1
:
0
)
;
}
static
uint32_t
argumentProperties
(
)
{
return
BitMask
<
TypeToArgProperties
uint32_t
2
Args
.
.
.
>
:
:
result
;
}
static
uint32_t
argumentPassedInFloatRegs
(
)
{
return
BitMask
<
TypeToPassInFloatReg
uint32_t
2
Args
.
.
.
>
:
:
result
;
}
static
uint64_t
argumentRootTypes
(
)
{
return
BitMask
<
TypeToRootType
uint64_t
3
Args
.
.
.
>
:
:
result
;
}
explicit
FunctionInfo
(
pf
fun
const
char
*
name
PopValues
extraValuesToPop
=
PopValues
(
0
)
)
:
VMFunction
(
JS_FUNC_TO_DATA_PTR
(
void
*
fun
)
name
explicitArgs
(
)
argumentProperties
(
)
argumentPassedInFloatRegs
(
)
argumentRootTypes
(
)
outParam
(
)
outParamRootType
(
)
returnType
(
)
extraValuesToPop
.
numValues
NonTailCall
)
{
static_assert
(
MatchContext
<
Context
>
:
:
valid
"
Invalid
cx
type
in
VMFunction
"
)
;
}
explicit
FunctionInfo
(
pf
fun
const
char
*
name
MaybeTailCall
expectTailCall
PopValues
extraValuesToPop
=
PopValues
(
0
)
)
:
VMFunction
(
JS_FUNC_TO_DATA_PTR
(
void
*
fun
)
name
explicitArgs
(
)
argumentProperties
(
)
argumentPassedInFloatRegs
(
)
argumentRootTypes
(
)
outParam
(
)
outParamRootType
(
)
returnType
(
)
extraValuesToPop
.
numValues
expectTailCall
)
{
static_assert
(
MatchContext
<
Context
>
:
:
valid
"
Invalid
cx
type
in
VMFunction
"
)
;
}
}
;
class
AutoDetectInvalidation
{
JSContext
*
cx_
;
IonScript
*
ionScript_
;
MutableHandleValue
rval_
;
bool
disabled_
;
void
setReturnOverride
(
)
;
public
:
AutoDetectInvalidation
(
JSContext
*
cx
MutableHandleValue
rval
IonScript
*
ionScript
)
:
cx_
(
cx
)
ionScript_
(
ionScript
)
rval_
(
rval
)
disabled_
(
false
)
{
MOZ_ASSERT
(
ionScript
)
;
}
AutoDetectInvalidation
(
JSContext
*
cx
MutableHandleValue
rval
)
;
void
disable
(
)
{
MOZ_ASSERT
(
!
disabled_
)
;
disabled_
=
true
;
}
bool
shouldSetReturnOverride
(
)
const
{
return
!
disabled_
&
&
ionScript_
-
>
invalidated
(
)
;
}
~
AutoDetectInvalidation
(
)
{
if
(
MOZ_UNLIKELY
(
shouldSetReturnOverride
(
)
)
)
{
setReturnOverride
(
)
;
}
}
}
;
MOZ_MUST_USE
bool
InvokeFunction
(
JSContext
*
cx
HandleObject
obj0
bool
constructing
bool
ignoresReturnValue
uint32_t
argc
Value
*
argv
MutableHandleValue
rval
)
;
MOZ_MUST_USE
bool
InvokeFunctionShuffleNewTarget
(
JSContext
*
cx
HandleObject
obj
uint32_t
numActualArgs
uint32_t
numFormalArgs
Value
*
argv
MutableHandleValue
rval
)
;
class
InterpreterStubExitFrameLayout
;
bool
InvokeFromInterpreterStub
(
JSContext
*
cx
InterpreterStubExitFrameLayout
*
frame
)
;
bool
CheckOverRecursed
(
JSContext
*
cx
)
;
bool
CheckOverRecursedBaseline
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
MutatePrototype
(
JSContext
*
cx
HandlePlainObject
obj
HandleValue
value
)
;
MOZ_MUST_USE
bool
InitProp
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
HandleValue
value
jsbytecode
*
pc
)
;
template
<
bool
Equal
>
bool
LooselyEqual
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
template
<
bool
Equal
>
bool
StrictlyEqual
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
bool
LessThan
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
bool
LessThanOrEqual
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
bool
GreaterThan
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
bool
GreaterThanOrEqual
(
JSContext
*
cx
MutableHandleValue
lhs
MutableHandleValue
rhs
bool
*
res
)
;
template
<
bool
Equal
>
bool
StringsEqual
(
JSContext
*
cx
HandleString
left
HandleString
right
bool
*
res
)
;
MOZ_MUST_USE
bool
StringSplitHelper
(
JSContext
*
cx
HandleString
str
HandleString
sep
HandleObjectGroup
group
uint32_t
limit
MutableHandleValue
result
)
;
MOZ_MUST_USE
bool
ArrayPopDense
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
rval
)
;
MOZ_MUST_USE
bool
ArrayPushDense
(
JSContext
*
cx
HandleArrayObject
arr
HandleValue
v
uint32_t
*
length
)
;
MOZ_MUST_USE
bool
ArrayShiftDense
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
rval
)
;
JSString
*
ArrayJoin
(
JSContext
*
cx
HandleObject
array
HandleString
sep
)
;
MOZ_MUST_USE
bool
SetArrayLength
(
JSContext
*
cx
HandleObject
obj
HandleValue
value
bool
strict
)
;
MOZ_MUST_USE
bool
CharCodeAt
(
JSContext
*
cx
HandleString
str
int32_t
index
uint32_t
*
code
)
;
JSFlatString
*
StringFromCharCode
(
JSContext
*
cx
int32_t
code
)
;
JSString
*
StringFromCodePoint
(
JSContext
*
cx
int32_t
codePoint
)
;
MOZ_MUST_USE
bool
SetProperty
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
HandleValue
value
bool
strict
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
InterruptCheck
(
JSContext
*
cx
)
;
void
*
MallocWrapper
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
JSObject
*
NewCallObject
(
JSContext
*
cx
HandleShape
shape
HandleObjectGroup
group
)
;
JSObject
*
NewStringObject
(
JSContext
*
cx
HandleString
str
)
;
bool
OperatorIn
(
JSContext
*
cx
HandleValue
key
HandleObject
obj
bool
*
out
)
;
bool
OperatorInI
(
JSContext
*
cx
uint32_t
index
HandleObject
obj
bool
*
out
)
;
MOZ_MUST_USE
bool
GetIntrinsicValue
(
JSContext
*
cx
HandlePropertyName
name
MutableHandleValue
rval
)
;
MOZ_MUST_USE
bool
CreateThis
(
JSContext
*
cx
HandleObject
callee
HandleObject
newTarget
MutableHandleValue
rval
)
;
bool
GetDynamicNamePure
(
JSContext
*
cx
JSObject
*
scopeChain
JSString
*
str
Value
*
vp
)
;
void
PostWriteBarrier
(
JSRuntime
*
rt
js
:
:
gc
:
:
Cell
*
cell
)
;
void
PostGlobalWriteBarrier
(
JSRuntime
*
rt
GlobalObject
*
obj
)
;
enum
class
IndexInBounds
{
Yes
Maybe
}
;
template
<
IndexInBounds
InBounds
>
void
PostWriteElementBarrier
(
JSRuntime
*
rt
JSObject
*
obj
int32_t
index
)
;
int32_t
GetIndexFromString
(
JSString
*
str
)
;
JSObject
*
WrapObjectPure
(
JSContext
*
cx
JSObject
*
obj
)
;
MOZ_MUST_USE
bool
DebugPrologue
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
bool
*
mustReturn
)
;
MOZ_MUST_USE
bool
DebugEpilogue
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
bool
ok
)
;
MOZ_MUST_USE
bool
DebugEpilogueOnBaselineReturn
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
void
FrameIsDebuggeeCheck
(
BaselineFrame
*
frame
)
;
JSObject
*
CreateGenerator
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
NormalSuspend
(
JSContext
*
cx
HandleObject
obj
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
FinalSuspend
(
JSContext
*
cx
HandleObject
obj
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
InterpretResume
(
JSContext
*
cx
HandleObject
obj
HandleValue
val
HandlePropertyName
kind
MutableHandleValue
rval
)
;
MOZ_MUST_USE
bool
DebugAfterYield
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
bool
*
mustReturn
)
;
MOZ_MUST_USE
bool
GeneratorThrowOrReturn
(
JSContext
*
cx
BaselineFrame
*
frame
Handle
<
GeneratorObject
*
>
genObj
HandleValue
arg
uint32_t
resumeKind
)
;
MOZ_MUST_USE
bool
GlobalNameConflictsCheckFromIon
(
JSContext
*
cx
HandleScript
script
)
;
MOZ_MUST_USE
bool
InitFunctionEnvironmentObjects
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
NewArgumentsObject
(
JSContext
*
cx
BaselineFrame
*
frame
MutableHandleValue
res
)
;
JSObject
*
CopyLexicalEnvironmentObject
(
JSContext
*
cx
HandleObject
env
bool
copySlots
)
;
JSObject
*
InitRestParameter
(
JSContext
*
cx
uint32_t
length
Value
*
rest
HandleObject
templateObj
HandleObject
res
)
;
MOZ_MUST_USE
bool
HandleDebugTrap
(
JSContext
*
cx
BaselineFrame
*
frame
uint8_t
*
retAddr
bool
*
mustReturn
)
;
MOZ_MUST_USE
bool
OnDebuggerStatement
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
bool
*
mustReturn
)
;
MOZ_MUST_USE
bool
GlobalHasLiveOnDebuggerStatement
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
EnterWith
(
JSContext
*
cx
BaselineFrame
*
frame
HandleValue
val
Handle
<
WithScope
*
>
templ
)
;
MOZ_MUST_USE
bool
LeaveWith
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
PushLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
Handle
<
LexicalScope
*
>
scope
)
;
MOZ_MUST_USE
bool
PopLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
DebugLeaveThenPopLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
FreshenLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
DebugLeaveThenFreshenLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
RecreateLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
DebugLeaveThenRecreateLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
DebugLeaveLexicalEnv
(
JSContext
*
cx
BaselineFrame
*
frame
jsbytecode
*
pc
)
;
MOZ_MUST_USE
bool
PushVarEnv
(
JSContext
*
cx
BaselineFrame
*
frame
HandleScope
scope
)
;
MOZ_MUST_USE
bool
PopVarEnv
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
InitBaselineFrameForOsr
(
BaselineFrame
*
frame
InterpreterFrame
*
interpFrame
uint32_t
numStackValues
)
;
JSObject
*
CreateDerivedTypedObj
(
JSContext
*
cx
HandleObject
descr
HandleObject
owner
int32_t
offset
)
;
MOZ_MUST_USE
bool
Recompile
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
ForcedRecompile
(
JSContext
*
cx
)
;
JSString
*
StringReplace
(
JSContext
*
cx
HandleString
string
HandleString
pattern
HandleString
repl
)
;
MOZ_MUST_USE
bool
SetDenseElement
(
JSContext
*
cx
HandleNativeObject
obj
int32_t
index
HandleValue
value
bool
strict
)
;
void
AssertValidObjectPtr
(
JSContext
*
cx
JSObject
*
obj
)
;
void
AssertValidObjectOrNullPtr
(
JSContext
*
cx
JSObject
*
obj
)
;
void
AssertValidStringPtr
(
JSContext
*
cx
JSString
*
str
)
;
void
AssertValidSymbolPtr
(
JSContext
*
cx
JS
:
:
Symbol
*
sym
)
;
void
AssertValidValue
(
JSContext
*
cx
Value
*
v
)
;
void
MarkValueFromJit
(
JSRuntime
*
rt
Value
*
vp
)
;
void
MarkStringFromJit
(
JSRuntime
*
rt
JSString
*
*
stringp
)
;
void
MarkObjectFromJit
(
JSRuntime
*
rt
JSObject
*
*
objp
)
;
void
MarkShapeFromJit
(
JSRuntime
*
rt
Shape
*
*
shapep
)
;
void
MarkObjectGroupFromJit
(
JSRuntime
*
rt
ObjectGroup
*
*
groupp
)
;
inline
void
*
JitMarkFunction
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Value
:
return
JS_FUNC_TO_DATA_PTR
(
void
*
MarkValueFromJit
)
;
case
MIRType
:
:
String
:
return
JS_FUNC_TO_DATA_PTR
(
void
*
MarkStringFromJit
)
;
case
MIRType
:
:
Object
:
return
JS_FUNC_TO_DATA_PTR
(
void
*
MarkObjectFromJit
)
;
case
MIRType
:
:
Shape
:
return
JS_FUNC_TO_DATA_PTR
(
void
*
MarkShapeFromJit
)
;
case
MIRType
:
:
ObjectGroup
:
return
JS_FUNC_TO_DATA_PTR
(
void
*
MarkObjectGroupFromJit
)
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
ObjectIsCallable
(
JSObject
*
obj
)
;
bool
ObjectIsConstructor
(
JSObject
*
obj
)
;
MOZ_MUST_USE
bool
ThrowRuntimeLexicalError
(
JSContext
*
cx
unsigned
errorNumber
)
;
MOZ_MUST_USE
bool
BaselineThrowUninitializedThis
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
MOZ_MUST_USE
bool
BaselineThrowInitializedThis
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
ThrowBadDerivedReturn
(
JSContext
*
cx
HandleValue
v
)
;
MOZ_MUST_USE
bool
ThrowObjectCoercible
(
JSContext
*
cx
HandleValue
v
)
;
MOZ_MUST_USE
bool
BaselineGetFunctionThis
(
JSContext
*
cx
BaselineFrame
*
frame
MutableHandleValue
res
)
;
MOZ_MUST_USE
bool
CallNativeGetter
(
JSContext
*
cx
HandleFunction
callee
HandleObject
obj
MutableHandleValue
result
)
;
MOZ_MUST_USE
bool
CallNativeSetter
(
JSContext
*
cx
HandleFunction
callee
HandleObject
obj
HandleValue
rhs
)
;
MOZ_MUST_USE
bool
EqualStringsHelperPure
(
JSString
*
str1
JSString
*
str2
)
;
MOZ_MUST_USE
bool
CheckIsCallable
(
JSContext
*
cx
HandleValue
v
CheckIsCallableKind
kind
)
;
template
<
bool
HandleMissing
>
bool
GetNativeDataPropertyPure
(
JSContext
*
cx
JSObject
*
obj
PropertyName
*
name
Value
*
vp
)
;
template
<
bool
HandleMissing
>
bool
GetNativeDataPropertyByValuePure
(
JSContext
*
cx
JSObject
*
obj
Value
*
vp
)
;
template
<
bool
HasOwn
>
bool
HasNativeDataPropertyPure
(
JSContext
*
cx
JSObject
*
obj
Value
*
vp
)
;
bool
HasNativeElementPure
(
JSContext
*
cx
NativeObject
*
obj
int32_t
index
Value
*
vp
)
;
template
<
bool
NeedsTypeBarrier
>
bool
SetNativeDataPropertyPure
(
JSContext
*
cx
JSObject
*
obj
PropertyName
*
name
Value
*
val
)
;
bool
ObjectHasGetterSetterPure
(
JSContext
*
cx
JSObject
*
obj
Shape
*
propShape
)
;
JSString
*
TypeOfObject
(
JSObject
*
obj
JSRuntime
*
rt
)
;
bool
GetPrototypeOf
(
JSContext
*
cx
HandleObject
target
MutableHandleValue
rval
)
;
void
CloseIteratorFromIon
(
JSContext
*
cx
JSObject
*
obj
)
;
bool
DoConcatStringObject
(
JSContext
*
cx
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
;
MOZ_MUST_USE
bool
TrySkipAwait
(
JSContext
*
cx
HandleValue
val
MutableHandleValue
resolved
)
;
bool
IsPossiblyWrappedTypedArray
(
JSContext
*
cx
JSObject
*
obj
bool
*
result
)
;
extern
const
VMFunction
SetArrayLengthInfo
;
extern
const
VMFunction
SetObjectElementInfo
;
extern
const
VMFunction
StringsEqualInfo
;
extern
const
VMFunction
StringsNotEqualInfo
;
extern
const
VMFunction
ConcatStringsInfo
;
extern
const
VMFunction
StringSplitHelperInfo
;
extern
const
VMFunction
ProxyGetPropertyInfo
;
extern
const
VMFunction
ProxyGetPropertyByValueInfo
;
extern
const
VMFunction
ProxySetPropertyInfo
;
extern
const
VMFunction
ProxySetPropertyByValueInfo
;
extern
const
VMFunction
ProxyHasInfo
;
extern
const
VMFunction
ProxyHasOwnInfo
;
extern
const
VMFunction
NativeGetElementInfo
;
extern
const
VMFunction
AddOrUpdateSparseElementHelperInfo
;
extern
const
VMFunction
GetSparseElementHelperInfo
;
extern
const
VMFunction
DoConcatStringObjectInfo
;
}
}
#
endif
