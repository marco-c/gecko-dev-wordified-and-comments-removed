#
ifndef
jit_JitCode_h
#
define
jit_JitCode_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
UbiNode
.
h
"
namespace
js
{
namespace
jit
{
class
ExecutablePool
;
class
JitCode
;
class
MacroAssembler
;
enum
class
CodeKind
:
uint8_t
;
struct
JitCodeHeader
{
JitCode
*
jitCode_
;
void
init
(
JitCode
*
jitCode
)
;
static
JitCodeHeader
*
FromExecutable
(
uint8_t
*
buffer
)
{
return
(
JitCodeHeader
*
)
(
buffer
-
sizeof
(
JitCodeHeader
)
)
;
}
}
;
class
JitCode
:
public
gc
:
:
TenuredCellWithNonGCPointer
<
uint8_t
>
{
friend
class
gc
:
:
CellAllocator
;
public
:
uint8_t
*
raw
(
)
const
{
return
headerPtr
(
)
;
}
uint8_t
*
allocatedMemory
(
)
const
{
return
headerPtr
(
)
-
sizeof
(
JitCodeHeader
)
;
}
protected
:
ExecutablePool
*
pool_
;
uint32_t
bufferSize_
;
uint32_t
insnSize_
;
uint32_t
dataSize_
;
uint32_t
jumpRelocTableBytes_
;
uint32_t
dataRelocTableBytes_
;
uint8_t
headerSize_
:
5
;
uint8_t
kind_
:
3
;
bool
invalidated_
:
1
;
bool
hasBytecodeMap_
:
1
;
uint8_t
localTracingSlots_
;
JitCode
(
)
=
delete
;
JitCode
(
uint8_t
*
code
uint32_t
bufferSize
uint32_t
headerSize
ExecutablePool
*
pool
CodeKind
kind
)
:
TenuredCellWithNonGCPointer
(
code
)
pool_
(
pool
)
bufferSize_
(
bufferSize
)
insnSize_
(
0
)
dataSize_
(
0
)
jumpRelocTableBytes_
(
0
)
dataRelocTableBytes_
(
0
)
headerSize_
(
headerSize
)
kind_
(
uint8_t
(
kind
)
)
invalidated_
(
false
)
hasBytecodeMap_
(
false
)
localTracingSlots_
(
0
)
{
MOZ_ASSERT
(
CodeKind
(
kind_
)
=
=
kind
)
;
MOZ_ASSERT
(
headerSize_
=
=
headerSize
)
;
}
uint32_t
dataOffset
(
)
const
{
return
insnSize_
;
}
uint32_t
jumpRelocTableOffset
(
)
const
{
return
dataOffset
(
)
+
dataSize_
;
}
uint32_t
dataRelocTableOffset
(
)
const
{
return
jumpRelocTableOffset
(
)
+
jumpRelocTableBytes_
;
}
public
:
uint8_t
*
rawEnd
(
)
const
{
return
raw
(
)
+
insnSize_
;
}
bool
containsNativePC
(
const
void
*
addr
)
const
{
const
uint8_t
*
addr_u8
=
(
const
uint8_t
*
)
addr
;
return
raw
(
)
<
=
addr_u8
&
&
addr_u8
<
rawEnd
(
)
;
}
size_t
instructionsSize
(
)
const
{
return
insnSize_
;
}
size_t
bufferSize
(
)
const
{
return
bufferSize_
;
}
size_t
headerSize
(
)
const
{
return
headerSize_
;
}
size_t
allocatedSize
(
)
const
{
return
bufferSize_
+
headerSize_
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JS
:
:
GCContext
*
gcx
)
;
void
setInvalidated
(
)
{
invalidated_
=
true
;
}
void
setHasBytecodeMap
(
)
{
hasBytecodeMap_
=
true
;
}
void
setLocalTracingSlots
(
uint8_t
localTracingSlots
)
{
localTracingSlots_
=
localTracingSlots
;
}
uint8_t
localTracingSlots
(
)
{
return
localTracingSlots_
;
}
bool
invalidated
(
)
const
{
return
!
!
invalidated_
;
}
template
<
typename
T
>
T
as
(
)
const
{
return
JS_DATA_TO_FUNC_PTR
(
T
raw
(
)
)
;
}
void
copyFrom
(
MacroAssembler
&
masm
)
;
static
JitCode
*
FromExecutable
(
uint8_t
*
buffer
)
{
JitCode
*
code
=
JitCodeHeader
:
:
FromExecutable
(
buffer
)
-
>
jitCode_
;
MOZ_ASSERT
(
code
-
>
raw
(
)
=
=
buffer
)
;
return
code
;
}
static
size_t
offsetOfCode
(
)
{
return
offsetOfHeaderPtr
(
)
;
}
uint8_t
*
jumpRelocTable
(
)
{
return
raw
(
)
+
jumpRelocTableOffset
(
)
;
}
template
<
AllowGC
allowGC
>
static
JitCode
*
New
(
JSContext
*
cx
uint8_t
*
code
uint32_t
totalSize
uint32_t
headerSize
ExecutablePool
*
pool
CodeKind
kind
)
;
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
JitCode
;
}
;
}
}
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
jit
:
:
JitCode
>
:
TracerConcrete
<
js
:
:
jit
:
:
JitCode
>
{
protected
:
explicit
Concrete
(
js
:
:
jit
:
:
JitCode
*
ptr
)
:
TracerConcrete
<
js
:
:
jit
:
:
JitCode
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
jit
:
:
JitCode
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
size
+
=
get
(
)
.
bufferSize
(
)
;
size
+
=
get
(
)
.
headerSize
(
)
;
return
size
;
}
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
