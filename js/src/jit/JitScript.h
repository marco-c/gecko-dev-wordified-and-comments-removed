#
ifndef
jit_JitScript_h
#
define
jit_JitScript_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
TypeInference
.
h
"
class
JS_PUBLIC_API
JSScript
;
namespace
js
{
namespace
jit
{
class
ControlFlowGraph
;
struct
DependentWasmImport
{
wasm
:
:
Instance
*
instance
;
size_t
importIndex
;
DependentWasmImport
(
wasm
:
:
Instance
&
instance
size_t
importIndex
)
:
instance
(
&
instance
)
importIndex
(
importIndex
)
{
}
}
;
struct
IonBytecodeInfo
{
bool
usesEnvironmentChain
=
false
;
bool
modifiesArguments
=
false
;
bool
hasTryFinally
=
false
;
}
;
static
constexpr
uintptr_t
BaselineDisabledScript
=
0x1
;
static
BaselineScript
*
const
BaselineDisabledScriptPtr
=
reinterpret_cast
<
BaselineScript
*
>
(
BaselineDisabledScript
)
;
static
constexpr
uintptr_t
IonDisabledScript
=
0x1
;
static
constexpr
uintptr_t
IonCompilingScript
=
0x2
;
static
IonScript
*
const
IonDisabledScriptPtr
=
reinterpret_cast
<
IonScript
*
>
(
IonDisabledScript
)
;
static
IonScript
*
const
IonCompilingScriptPtr
=
reinterpret_cast
<
IonScript
*
>
(
IonCompilingScript
)
;
class
alignas
(
uintptr_t
)
JitScript
final
{
friend
class
:
:
JSScript
;
FallbackICStubSpace
fallbackStubSpace_
=
{
}
;
uint8_t
*
jitCodeSkipArgCheck_
=
nullptr
;
js
:
:
UniquePtr
<
Vector
<
DependentWasmImport
>
>
dependentWasmImports_
;
const
char
*
profileString_
=
nullptr
;
struct
CachedIonData
{
RecompileInfoVector
inlinedCompilations_
;
const
HeapPtr
<
EnvironmentObject
*
>
templateEnv
=
nullptr
;
ControlFlowGraph
*
controlFlowGraph
=
nullptr
;
uint16_t
inlinedBytecodeLength
=
0
;
uint8_t
maxInliningDepth
=
UINT8_MAX
;
IonBytecodeInfo
bytecodeInfo
=
{
}
;
CachedIonData
(
EnvironmentObject
*
templateEnv
IonBytecodeInfo
bytecodeInfo
)
;
CachedIonData
(
const
CachedIonData
&
)
=
delete
;
void
operator
=
(
const
CachedIonData
&
)
=
delete
;
void
trace
(
JSTracer
*
trc
)
;
}
;
js
:
:
UniquePtr
<
CachedIonData
>
cachedIonData_
;
BaselineScript
*
baselineScript_
=
nullptr
;
IonScript
*
ionScript_
=
nullptr
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
warmUpCount_
=
{
}
;
uint32_t
typeSetOffset_
=
0
;
uint32_t
bytecodeTypeMapOffset_
=
0
;
uint32_t
bytecodeTypeMapHint_
=
0
;
uint32_t
allocBytes_
=
0
;
struct
Flags
{
bool
active
:
1
;
bool
typesGeneration
:
1
;
bool
hasFreezeConstraints
:
1
;
bool
ionCompiledOrInlined
:
1
;
}
;
Flags
flags_
=
{
}
;
ICEntry
*
icEntries
(
)
{
uint8_t
*
base
=
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
return
reinterpret_cast
<
ICEntry
*
>
(
base
+
offsetOfICEntries
(
)
)
;
}
StackTypeSet
*
typeArrayDontCheckGeneration
(
)
{
uint8_t
*
base
=
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
return
reinterpret_cast
<
StackTypeSet
*
>
(
base
+
typeSetOffset_
)
;
}
uint32_t
typesGeneration
(
)
const
{
return
uint32_t
(
flags_
.
typesGeneration
)
;
}
void
setTypesGeneration
(
uint32_t
generation
)
{
MOZ_ASSERT
(
generation
<
=
1
)
;
flags_
.
typesGeneration
=
generation
;
}
bool
hasCachedIonData
(
)
const
{
return
!
!
cachedIonData_
;
}
CachedIonData
&
cachedIonData
(
)
{
MOZ_ASSERT
(
hasCachedIonData
(
)
)
;
return
*
cachedIonData_
.
get
(
)
;
}
const
CachedIonData
&
cachedIonData
(
)
const
{
MOZ_ASSERT
(
hasCachedIonData
(
)
)
;
return
*
cachedIonData_
.
get
(
)
;
}
public
:
JitScript
(
JSScript
*
script
uint32_t
typeSetOffset
uint32_t
bytecodeTypeMapOffset
uint32_t
allocBytes
const
char
*
profileString
)
;
#
ifdef
DEBUG
~
JitScript
(
)
{
MOZ_ASSERT
(
fallbackStubSpace_
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
!
hasBaselineScript
(
)
)
;
MOZ_ASSERT
(
!
hasIonScript
(
)
)
;
}
#
endif
MOZ_MUST_USE
bool
initICEntriesAndBytecodeTypeMap
(
JSContext
*
cx
JSScript
*
script
)
;
MOZ_MUST_USE
bool
ensureHasCachedIonData
(
JSContext
*
cx
HandleScript
script
)
;
bool
hasFreezeConstraints
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
const
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
return
flags_
.
hasFreezeConstraints
;
}
void
setHasFreezeConstraints
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
flags_
.
hasFreezeConstraints
=
true
;
}
inline
bool
typesNeedsSweep
(
Zone
*
zone
)
const
;
void
sweepTypes
(
const
js
:
:
AutoSweepJitScript
&
sweep
Zone
*
zone
)
;
void
setIonCompiledOrInlined
(
)
{
flags_
.
ionCompiledOrInlined
=
true
;
}
void
clearIonCompiledOrInlined
(
)
{
flags_
.
ionCompiledOrInlined
=
false
;
}
bool
ionCompiledOrInlined
(
)
const
{
return
flags_
.
ionCompiledOrInlined
;
}
RecompileInfoVector
*
maybeInlinedCompilations
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
if
(
!
hasCachedIonData
(
)
)
{
return
nullptr
;
}
return
&
cachedIonData
(
)
.
inlinedCompilations_
;
}
MOZ_MUST_USE
bool
addInlinedCompilation
(
const
js
:
:
AutoSweepJitScript
&
sweep
RecompileInfo
info
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
auto
&
inlinedCompilations
=
cachedIonData
(
)
.
inlinedCompilations_
;
if
(
!
inlinedCompilations
.
empty
(
)
&
&
inlinedCompilations
.
back
(
)
=
=
info
)
{
return
true
;
}
return
inlinedCompilations
.
append
(
info
)
;
}
uint32_t
numICEntries
(
)
const
{
return
(
typeSetOffset_
-
offsetOfICEntries
(
)
)
/
sizeof
(
ICEntry
)
;
}
uint32_t
numTypeSets
(
)
const
{
return
(
bytecodeTypeMapOffset_
-
typeSetOffset_
)
/
sizeof
(
StackTypeSet
)
;
}
uint32_t
*
bytecodeTypeMapHint
(
)
{
return
&
bytecodeTypeMapHint_
;
}
bool
active
(
)
const
{
return
flags_
.
active
;
}
void
setActive
(
)
{
flags_
.
active
=
true
;
}
void
resetActive
(
)
{
flags_
.
active
=
false
;
}
void
ensureProfileString
(
JSContext
*
cx
JSScript
*
script
)
;
const
char
*
profileString
(
)
const
{
MOZ_ASSERT
(
profileString_
)
;
return
profileString_
;
}
StackTypeSet
*
typeArray
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
return
typeArrayDontCheckGeneration
(
)
;
}
uint32_t
*
bytecodeTypeMap
(
)
{
uint8_t
*
base
=
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
base
+
bytecodeTypeMapOffset_
)
;
}
inline
StackTypeSet
*
thisTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
)
;
inline
StackTypeSet
*
argTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
unsigned
i
)
;
static
size_t
NumTypeSets
(
JSScript
*
script
)
;
inline
StackTypeSet
*
bytecodeTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
jsbytecode
*
pc
)
;
template
<
typename
TYPESET
>
static
inline
TYPESET
*
BytecodeTypes
(
JSScript
*
script
jsbytecode
*
pc
uint32_t
*
bytecodeMap
uint32_t
*
hint
TYPESET
*
typeArray
)
;
static
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
const
js
:
:
Value
&
val
)
;
static
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
StackTypeSet
*
types
const
js
:
:
Value
&
val
)
;
private
:
static
void
MonitorBytecodeTypeSlow
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
StackTypeSet
*
types
TypeSet
:
:
Type
type
)
;
public
:
static
inline
void
MonitorAssign
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
static
inline
void
MonitorThisType
(
JSContext
*
cx
JSScript
*
script
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorThisType
(
JSContext
*
cx
JSScript
*
script
const
js
:
:
Value
&
value
)
;
static
inline
void
MonitorArgType
(
JSContext
*
cx
JSScript
*
script
unsigned
arg
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorArgType
(
JSContext
*
cx
JSScript
*
script
unsigned
arg
const
js
:
:
Value
&
value
)
;
static
bool
FreezeTypeSets
(
CompilerConstraintList
*
constraints
JSScript
*
script
TemporaryTypeSet
*
*
pThisTypes
TemporaryTypeSet
*
*
pArgTypes
TemporaryTypeSet
*
*
pBytecodeTypes
)
;
static
void
Destroy
(
Zone
*
zone
JitScript
*
script
)
;
static
constexpr
size_t
offsetOfICEntries
(
)
{
return
sizeof
(
JitScript
)
;
}
static
constexpr
size_t
offsetOfJitCodeSkipArgCheck
(
)
{
return
offsetof
(
JitScript
jitCodeSkipArgCheck_
)
;
}
static
constexpr
size_t
offsetOfBaselineScript
(
)
{
return
offsetof
(
JitScript
baselineScript_
)
;
}
static
constexpr
size_t
offsetOfIonScript
(
)
{
return
offsetof
(
JitScript
ionScript_
)
;
}
static
constexpr
size_t
offsetOfWarmUpCount
(
)
{
return
offsetof
(
JitScript
warmUpCount_
)
;
}
uint32_t
warmUpCount
(
)
const
{
return
warmUpCount_
;
}
uint32_t
*
addressOfWarmUpCount
(
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
&
warmUpCount_
)
;
}
#
ifdef
DEBUG
void
printTypes
(
JSContext
*
cx
HandleScript
script
)
;
#
endif
void
prepareForDestruction
(
Zone
*
zone
)
{
fallbackStubSpace_
.
freeAllAfterMinorGC
(
zone
)
;
}
FallbackICStubSpace
*
fallbackStubSpace
(
)
{
return
&
fallbackStubSpace_
;
}
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
data
size_t
*
fallbackStubs
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
;
*
fallbackStubs
+
=
fallbackStubSpace_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
ICEntry
&
icEntry
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numICEntries
(
)
)
;
return
icEntries
(
)
[
index
]
;
}
void
noteAccessedGetter
(
uint32_t
pcOffset
)
;
void
noteHasDenseAdd
(
uint32_t
pcOffset
)
;
void
trace
(
JSTracer
*
trc
)
;
void
purgeOptimizedStubs
(
JSScript
*
script
)
;
ICEntry
*
interpreterICEntryFromPCOffset
(
uint32_t
pcOffset
)
;
ICEntry
*
maybeICEntryFromPCOffset
(
uint32_t
pcOffset
)
;
ICEntry
*
maybeICEntryFromPCOffset
(
uint32_t
pcOffset
ICEntry
*
prevLookedUpEntry
)
;
ICEntry
&
icEntryFromPCOffset
(
uint32_t
pcOffset
)
;
ICEntry
&
icEntryFromPCOffset
(
uint32_t
pcOffset
ICEntry
*
prevLookedUpEntry
)
;
MOZ_MUST_USE
bool
addDependentWasmImport
(
JSContext
*
cx
wasm
:
:
Instance
&
instance
uint32_t
idx
)
;
void
removeDependentWasmImport
(
wasm
:
:
Instance
&
instance
uint32_t
idx
)
;
void
unlinkDependentWasmImports
(
)
;
size_t
allocBytes
(
)
const
{
return
allocBytes_
;
}
EnvironmentObject
*
templateEnvironment
(
)
const
{
return
cachedIonData
(
)
.
templateEnv
;
}
const
ControlFlowGraph
*
controlFlowGraph
(
)
const
{
return
cachedIonData
(
)
.
controlFlowGraph
;
}
void
setControlFlowGraph
(
ControlFlowGraph
*
controlFlowGraph
)
{
MOZ_ASSERT
(
controlFlowGraph
)
;
cachedIonData
(
)
.
controlFlowGraph
=
controlFlowGraph
;
}
void
clearControlFlowGraph
(
)
{
if
(
hasCachedIonData
(
)
)
{
cachedIonData
(
)
.
controlFlowGraph
=
nullptr
;
}
}
bool
modifiesArguments
(
)
const
{
return
cachedIonData
(
)
.
bytecodeInfo
.
modifiesArguments
;
}
bool
usesEnvironmentChain
(
)
const
{
return
cachedIonData
(
)
.
bytecodeInfo
.
usesEnvironmentChain
;
}
bool
hasTryFinally
(
)
const
{
return
cachedIonData
(
)
.
bytecodeInfo
.
hasTryFinally
;
}
uint8_t
maxInliningDepth
(
)
const
{
return
hasCachedIonData
(
)
?
cachedIonData
(
)
.
maxInliningDepth
:
UINT8_MAX
;
}
void
resetMaxInliningDepth
(
)
{
cachedIonData
(
)
.
maxInliningDepth
=
UINT8_MAX
;
}
void
setMaxInliningDepth
(
uint32_t
depth
)
{
MOZ_ASSERT
(
depth
<
=
UINT8_MAX
)
;
cachedIonData
(
)
.
maxInliningDepth
=
depth
;
}
uint16_t
inlinedBytecodeLength
(
)
const
{
return
hasCachedIonData
(
)
?
cachedIonData
(
)
.
inlinedBytecodeLength
:
0
;
}
void
setInlinedBytecodeLength
(
uint32_t
len
)
{
if
(
len
>
UINT16_MAX
)
{
len
=
UINT16_MAX
;
}
cachedIonData
(
)
.
inlinedBytecodeLength
=
len
;
}
private
:
void
setBaselineScriptImpl
(
JSScript
*
script
BaselineScript
*
baselineScript
)
;
void
setBaselineScriptImpl
(
JSFreeOp
*
fop
JSScript
*
script
BaselineScript
*
baselineScript
)
;
public
:
bool
hasBaselineScript
(
)
const
{
bool
res
=
baselineScript_
&
&
baselineScript_
!
=
BaselineDisabledScriptPtr
;
MOZ_ASSERT_IF
(
!
res
!
hasIonScript
(
)
)
;
return
res
;
}
BaselineScript
*
baselineScript
(
)
const
{
MOZ_ASSERT
(
hasBaselineScript
(
)
)
;
return
baselineScript_
;
}
void
setBaselineScript
(
JSScript
*
script
BaselineScript
*
baselineScript
)
{
MOZ_ASSERT
(
!
hasBaselineScript
(
)
)
;
setBaselineScriptImpl
(
script
baselineScript
)
;
MOZ_ASSERT
(
hasBaselineScript
(
)
)
;
}
MOZ_MUST_USE
BaselineScript
*
clearBaselineScript
(
JSFreeOp
*
fop
JSScript
*
script
)
{
BaselineScript
*
baseline
=
baselineScript
(
)
;
setBaselineScriptImpl
(
fop
script
nullptr
)
;
return
baseline
;
}
private
:
void
setIonScriptImpl
(
JSFreeOp
*
fop
JSScript
*
script
IonScript
*
ionScript
)
;
void
setIonScriptImpl
(
JSScript
*
script
IonScript
*
ionScript
)
;
public
:
bool
hasIonScript
(
)
const
{
bool
res
=
ionScript_
&
&
ionScript_
!
=
IonDisabledScriptPtr
&
&
ionScript_
!
=
IonCompilingScriptPtr
;
MOZ_ASSERT_IF
(
res
baselineScript_
)
;
return
res
;
}
IonScript
*
ionScript
(
)
const
{
MOZ_ASSERT
(
hasIonScript
(
)
)
;
return
ionScript_
;
}
void
setIonScript
(
JSScript
*
script
IonScript
*
ionScript
)
{
MOZ_ASSERT
(
!
hasIonScript
(
)
)
;
setIonScriptImpl
(
script
ionScript
)
;
MOZ_ASSERT
(
hasIonScript
(
)
)
;
}
MOZ_MUST_USE
IonScript
*
clearIonScript
(
JSFreeOp
*
fop
JSScript
*
script
)
{
IonScript
*
ion
=
ionScript
(
)
;
setIonScriptImpl
(
fop
script
nullptr
)
;
return
ion
;
}
bool
isIonCompilingOffThread
(
)
const
{
return
ionScript_
=
=
IonCompilingScriptPtr
;
}
void
setIsIonCompilingOffThread
(
JSScript
*
script
)
{
MOZ_ASSERT
(
ionScript_
=
=
nullptr
)
;
setIonScriptImpl
(
script
IonCompilingScriptPtr
)
;
}
void
clearIsIonCompilingOffThread
(
JSScript
*
script
)
{
MOZ_ASSERT
(
isIonCompilingOffThread
(
)
)
;
setIonScriptImpl
(
script
nullptr
)
;
}
}
;
class
MOZ_RAII
AutoKeepJitScripts
{
TypeZone
&
zone_
;
bool
prev_
;
AutoKeepJitScripts
(
const
AutoKeepJitScripts
&
)
=
delete
;
void
operator
=
(
const
AutoKeepJitScripts
&
)
=
delete
;
public
:
explicit
inline
AutoKeepJitScripts
(
JSContext
*
cx
)
;
inline
~
AutoKeepJitScripts
(
)
;
}
;
void
MarkActiveJitScripts
(
Zone
*
zone
)
;
#
ifdef
JS_STRUCTURED_SPEW
void
JitSpewBaselineICStats
(
JSScript
*
script
const
char
*
dumpReason
)
;
#
endif
}
}
#
endif
