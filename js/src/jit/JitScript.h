#
ifndef
jit_JitScript_h
#
define
jit_JitScript_h
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
TypeInference
.
h
"
class
JSScript
;
namespace
js
{
namespace
jit
{
class
ICScript
;
}
class
JitScript
{
friend
class
:
:
JSScript
;
RecompileInfoVector
inlinedCompilations_
;
using
ICScriptPtr
=
js
:
:
UniquePtr
<
js
:
:
jit
:
:
ICScript
>
;
ICScriptPtr
icScript_
;
uint32_t
numTypeSets_
;
uint32_t
bytecodeTypeMapHint_
=
0
;
struct
Flags
{
bool
active
:
1
;
bool
typesGeneration
:
1
;
bool
hasFreezeConstraints
:
1
;
}
;
Flags
flags_
=
{
}
;
StackTypeSet
typeArray_
[
1
]
;
StackTypeSet
*
typeArrayDontCheckGeneration
(
)
{
static_assert
(
sizeof
(
JitScript
)
=
=
sizeof
(
typeArray_
)
+
offsetof
(
JitScript
typeArray_
)
"
typeArray_
must
be
the
last
member
of
JitScript
"
)
;
return
const_cast
<
StackTypeSet
*
>
(
typeArray_
)
;
}
uint32_t
typesGeneration
(
)
const
{
return
uint32_t
(
flags_
.
typesGeneration
)
;
}
void
setTypesGeneration
(
uint32_t
generation
)
{
MOZ_ASSERT
(
generation
<
=
1
)
;
flags_
.
typesGeneration
=
generation
;
}
public
:
JitScript
(
JSScript
*
script
ICScriptPtr
&
&
icScript
uint32_t
numTypeSets
)
;
bool
hasFreezeConstraints
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
const
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
return
flags_
.
hasFreezeConstraints
;
}
void
setHasFreezeConstraints
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
flags_
.
hasFreezeConstraints
=
true
;
}
inline
bool
typesNeedsSweep
(
Zone
*
zone
)
const
;
void
sweepTypes
(
const
js
:
:
AutoSweepJitScript
&
sweep
Zone
*
zone
)
;
RecompileInfoVector
&
inlinedCompilations
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
return
inlinedCompilations_
;
}
MOZ_MUST_USE
bool
addInlinedCompilation
(
const
js
:
:
AutoSweepJitScript
&
sweep
RecompileInfo
info
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
if
(
!
inlinedCompilations_
.
empty
(
)
&
&
inlinedCompilations_
.
back
(
)
=
=
info
)
{
return
true
;
}
return
inlinedCompilations_
.
append
(
info
)
;
}
uint32_t
numTypeSets
(
)
const
{
return
numTypeSets_
;
}
uint32_t
*
bytecodeTypeMapHint
(
)
{
return
&
bytecodeTypeMapHint_
;
}
bool
active
(
)
const
{
return
flags_
.
active
;
}
void
setActive
(
)
{
flags_
.
active
=
true
;
}
void
resetActive
(
)
{
flags_
.
active
=
false
;
}
jit
:
:
ICScript
*
icScript
(
)
const
{
MOZ_ASSERT
(
icScript_
)
;
return
icScript_
.
get
(
)
;
}
StackTypeSet
*
typeArray
(
const
js
:
:
AutoSweepJitScript
&
sweep
)
{
MOZ_ASSERT
(
sweep
.
jitScript
(
)
=
=
this
)
;
return
typeArrayDontCheckGeneration
(
)
;
}
uint32_t
*
bytecodeTypeMap
(
)
{
MOZ_ASSERT
(
numTypeSets_
>
0
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
typeArray_
+
numTypeSets_
)
;
}
inline
StackTypeSet
*
thisTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
)
;
inline
StackTypeSet
*
argTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
unsigned
i
)
;
inline
StackTypeSet
*
bytecodeTypes
(
const
AutoSweepJitScript
&
sweep
JSScript
*
script
jsbytecode
*
pc
)
;
template
<
typename
TYPESET
>
static
inline
TYPESET
*
BytecodeTypes
(
JSScript
*
script
jsbytecode
*
pc
uint32_t
*
bytecodeMap
uint32_t
*
hint
TYPESET
*
typeArray
)
;
static
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
const
js
:
:
Value
&
val
)
;
static
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorBytecodeType
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
StackTypeSet
*
types
const
js
:
:
Value
&
val
)
;
private
:
static
void
MonitorBytecodeTypeSlow
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
StackTypeSet
*
types
TypeSet
:
:
Type
type
)
;
public
:
static
inline
void
MonitorAssign
(
JSContext
*
cx
HandleObject
obj
jsid
id
)
;
static
inline
void
MonitorThisType
(
JSContext
*
cx
JSScript
*
script
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorThisType
(
JSContext
*
cx
JSScript
*
script
const
js
:
:
Value
&
value
)
;
static
inline
void
MonitorArgType
(
JSContext
*
cx
JSScript
*
script
unsigned
arg
TypeSet
:
:
Type
type
)
;
static
inline
void
MonitorArgType
(
JSContext
*
cx
JSScript
*
script
unsigned
arg
const
js
:
:
Value
&
value
)
;
static
bool
FreezeTypeSets
(
CompilerConstraintList
*
constraints
JSScript
*
script
TemporaryTypeSet
*
*
pThisTypes
TemporaryTypeSet
*
*
pArgTypes
TemporaryTypeSet
*
*
pBytecodeTypes
)
;
void
destroy
(
Zone
*
zone
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
static
constexpr
size_t
offsetOfICScript
(
)
{
static_assert
(
sizeof
(
icScript_
)
=
=
sizeof
(
uintptr_t
)
"
JIT
code
assumes
icScript_
is
pointer
-
sized
"
)
;
return
offsetof
(
JitScript
icScript_
)
;
}
#
ifdef
DEBUG
void
printTypes
(
JSContext
*
cx
HandleScript
script
)
;
#
endif
}
;
class
MOZ_RAII
AutoKeepJitScripts
{
TypeZone
&
zone_
;
bool
prev_
;
AutoKeepJitScripts
(
const
AutoKeepJitScripts
&
)
=
delete
;
void
operator
=
(
const
AutoKeepJitScripts
&
)
=
delete
;
public
:
explicit
inline
AutoKeepJitScripts
(
JSContext
*
cx
)
;
inline
~
AutoKeepJitScripts
(
)
;
}
;
}
#
endif
