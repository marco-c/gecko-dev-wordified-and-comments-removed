#
ifndef
jit_BaselineCompileQueue_h
#
define
jit_BaselineCompileQueue_h
#
include
"
gc
/
Barrier
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
class
JSScript
;
namespace
js
{
namespace
jit
{
class
BaselineCompileQueue
{
public
:
static
constexpr
uint32_t
MaxCapacity
=
64
;
private
:
uint32_t
numQueued_
=
0
;
HeapPtr
<
JSScript
*
>
queue_
[
MaxCapacity
]
;
public
:
uint32_t
numQueued
(
)
const
{
return
numQueued_
;
}
static
constexpr
size_t
offsetOfQueue
(
)
{
return
offsetof
(
BaselineCompileQueue
queue_
)
;
}
static
constexpr
size_t
offsetOfNumQueued
(
)
{
return
offsetof
(
BaselineCompileQueue
numQueued_
)
;
}
JSScript
*
pop
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
assertInvariants
(
)
;
numQueued_
-
-
;
JSScript
*
result
=
queue_
[
numQueued_
]
;
queue_
[
numQueued_
]
=
nullptr
;
assertInvariants
(
)
;
return
result
;
}
bool
isEmpty
(
)
const
{
return
numQueued_
=
=
0
;
}
bool
enqueue
(
JSScript
*
script
)
{
if
(
numQueued_
>
=
JitOptions
.
baselineQueueCapacity
)
{
return
false
;
}
queue_
[
numQueued_
]
=
script
;
numQueued_
+
+
;
assertInvariants
(
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
void
assertInvariants
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
numQueued_
<
=
JitOptions
.
baselineQueueCapacity
)
;
MOZ_ASSERT
(
JitOptions
.
baselineQueueCapacity
<
=
MaxCapacity
)
;
for
(
uint32_t
i
=
0
;
i
<
numQueued_
;
i
+
+
)
{
MOZ_ASSERT
(
queue_
[
i
]
)
;
}
for
(
uint32_t
i
=
numQueued_
;
i
<
MaxCapacity
;
i
+
+
)
{
MOZ_ASSERT
(
!
queue_
[
i
]
)
;
}
#
endif
}
void
trace
(
JSTracer
*
trc
)
;
void
remove
(
JSScript
*
script
)
;
}
;
}
}
#
endif
