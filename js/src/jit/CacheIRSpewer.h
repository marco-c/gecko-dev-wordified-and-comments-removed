#
ifndef
jit_CacheIRSpewer_h
#
define
jit_CacheIRSpewer_h
#
ifdef
JS_CACHEIR_SPEW
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jit
/
CacheIR
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
vm
/
JSONPrinter
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
namespace
js
{
namespace
jit
{
class
CacheIRSpewer
{
Mutex
outputLock
;
Fprinter
output
;
mozilla
:
:
Maybe
<
JSONPrinter
>
json
;
static
CacheIRSpewer
cacheIRspewer
;
uint32_t
guardCount_
;
uint32_t
spewInterval_
;
CacheIRSpewer
(
)
;
~
CacheIRSpewer
(
)
;
bool
enabled
(
)
{
return
json
.
isSome
(
)
;
}
Mutex
&
lock
(
)
{
MOZ_ASSERT
(
enabled
(
)
)
;
return
outputLock
;
}
void
beginCache
(
const
IRGenerator
&
generator
)
;
void
valueProperty
(
const
char
*
name
const
Value
&
v
)
;
void
opcodeProperty
(
const
char
*
name
const
JSOp
op
)
;
void
attached
(
const
char
*
name
)
;
void
endCache
(
)
;
public
:
static
CacheIRSpewer
&
singleton
(
)
{
return
cacheIRspewer
;
}
bool
init
(
const
char
*
name
)
;
class
MOZ_RAII
Guard
{
CacheIRSpewer
&
sp_
;
const
IRGenerator
&
gen_
;
const
char
*
name_
;
public
:
Guard
(
const
IRGenerator
&
gen
const
char
*
name
)
:
sp_
(
CacheIRSpewer
:
:
singleton
(
)
)
gen_
(
gen
)
name_
(
name
)
{
if
(
sp_
.
enabled
(
)
)
{
sp_
.
lock
(
)
.
lock
(
)
;
sp_
.
beginCache
(
gen_
)
;
}
}
~
Guard
(
)
{
if
(
sp_
.
enabled
(
)
)
{
if
(
name_
!
=
nullptr
)
{
sp_
.
attached
(
name_
)
;
}
sp_
.
endCache
(
)
;
if
(
sp_
.
guardCount_
+
+
%
sp_
.
spewInterval_
=
=
0
)
{
sp_
.
output
.
flush
(
)
;
}
sp_
.
lock
(
)
.
unlock
(
)
;
}
}
void
valueProperty
(
const
char
*
name
const
Value
&
v
)
const
{
sp_
.
valueProperty
(
name
v
)
;
}
void
opcodeProperty
(
const
char
*
name
const
JSOp
op
)
const
{
sp_
.
opcodeProperty
(
name
op
)
;
}
explicit
operator
bool
(
)
const
{
return
sp_
.
enabled
(
)
;
}
}
;
}
;
}
}
#
endif
#
endif
