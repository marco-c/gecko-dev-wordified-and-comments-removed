#
include
"
jit
/
MIR
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
<
ctype
.
h
>
#
include
"
jslibmath
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
BaselineInspector
.
h
"
#
include
"
jit
/
IonBuilder
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
jit
/
RangeAnalysis
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
jsatominlines
.
h
"
#
include
"
jsboolinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
JS
:
:
ToInt32
;
using
mozilla
:
:
NumbersAreIdentical
;
using
mozilla
:
:
IsFloat32Representable
;
using
mozilla
:
:
IsNaN
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
DebugOnly
;
#
ifdef
DEBUG
size_t
MUse
:
:
index
(
)
const
{
return
consumer
(
)
-
>
indexOf
(
this
)
;
}
#
endif
template
<
size_t
Op
>
static
void
ConvertDefinitionToDouble
(
TempAllocator
&
alloc
MDefinition
*
def
MInstruction
*
consumer
)
{
MInstruction
*
replace
=
MToDouble
:
:
New
(
alloc
def
)
;
consumer
-
>
replaceOperand
(
Op
replace
)
;
consumer
-
>
block
(
)
-
>
insertBefore
(
consumer
replace
)
;
}
static
bool
CheckUsesAreFloat32Consumers
(
const
MInstruction
*
ins
)
{
bool
allConsumerUses
=
true
;
for
(
MUseDefIterator
use
(
ins
)
;
allConsumerUses
&
&
use
;
use
+
+
)
allConsumerUses
&
=
use
.
def
(
)
-
>
canConsumeFloat32
(
use
.
use
(
)
)
;
return
allConsumerUses
;
}
void
MDefinition
:
:
PrintOpcodeName
(
GenericPrinter
&
out
MDefinition
:
:
Opcode
op
)
{
static
const
char
*
const
names
[
]
=
{
#
define
NAME
(
x
)
#
x
MIR_OPCODE_LIST
(
NAME
)
#
undef
NAME
}
;
const
char
*
name
=
names
[
op
]
;
size_t
len
=
strlen
(
name
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
out
.
printf
(
"
%
c
"
tolower
(
name
[
i
]
)
)
;
}
static
MConstant
*
EvaluateConstantOperands
(
TempAllocator
&
alloc
MBinaryInstruction
*
ins
bool
*
ptypeChange
=
nullptr
)
{
MDefinition
*
left
=
ins
-
>
getOperand
(
0
)
;
MDefinition
*
right
=
ins
-
>
getOperand
(
1
)
;
MOZ_ASSERT
(
IsNumberType
(
left
-
>
type
(
)
)
&
&
IsNumberType
(
right
-
>
type
(
)
)
)
;
if
(
!
left
-
>
isConstant
(
)
|
|
!
right
-
>
isConstant
(
)
)
return
nullptr
;
MConstant
*
lhs
=
left
-
>
toConstant
(
)
;
MConstant
*
rhs
=
right
-
>
toConstant
(
)
;
Value
ret
=
UndefinedValue
(
)
;
switch
(
ins
-
>
op
(
)
)
{
case
MDefinition
:
:
Op_BitAnd
:
ret
=
Int32Value
(
lhs
-
>
toInt32
(
)
&
rhs
-
>
toInt32
(
)
)
;
break
;
case
MDefinition
:
:
Op_BitOr
:
ret
=
Int32Value
(
lhs
-
>
toInt32
(
)
|
rhs
-
>
toInt32
(
)
)
;
break
;
case
MDefinition
:
:
Op_BitXor
:
ret
=
Int32Value
(
lhs
-
>
toInt32
(
)
^
rhs
-
>
toInt32
(
)
)
;
break
;
case
MDefinition
:
:
Op_Lsh
:
ret
=
Int32Value
(
uint32_t
(
lhs
-
>
toInt32
(
)
)
<
<
(
rhs
-
>
toInt32
(
)
&
0x1F
)
)
;
break
;
case
MDefinition
:
:
Op_Rsh
:
ret
=
Int32Value
(
lhs
-
>
toInt32
(
)
>
>
(
rhs
-
>
toInt32
(
)
&
0x1F
)
)
;
break
;
case
MDefinition
:
:
Op_Ursh
:
ret
.
setNumber
(
uint32_t
(
lhs
-
>
toInt32
(
)
)
>
>
(
rhs
-
>
toInt32
(
)
&
0x1F
)
)
;
break
;
case
MDefinition
:
:
Op_Add
:
ret
.
setNumber
(
lhs
-
>
toNumber
(
)
+
rhs
-
>
toNumber
(
)
)
;
break
;
case
MDefinition
:
:
Op_Sub
:
ret
.
setNumber
(
lhs
-
>
toNumber
(
)
-
rhs
-
>
toNumber
(
)
)
;
break
;
case
MDefinition
:
:
Op_Mul
:
ret
.
setNumber
(
lhs
-
>
toNumber
(
)
*
rhs
-
>
toNumber
(
)
)
;
break
;
case
MDefinition
:
:
Op_Div
:
if
(
ins
-
>
toDiv
(
)
-
>
isUnsigned
(
)
)
ret
.
setInt32
(
rhs
-
>
isInt32
(
0
)
?
0
:
uint32_t
(
lhs
-
>
toInt32
(
)
)
/
uint32_t
(
rhs
-
>
toInt32
(
)
)
)
;
else
ret
.
setNumber
(
NumberDiv
(
lhs
-
>
toNumber
(
)
rhs
-
>
toNumber
(
)
)
)
;
break
;
case
MDefinition
:
:
Op_Mod
:
if
(
ins
-
>
toMod
(
)
-
>
isUnsigned
(
)
)
ret
.
setInt32
(
rhs
-
>
isInt32
(
0
)
?
0
:
uint32_t
(
lhs
-
>
toInt32
(
)
)
%
uint32_t
(
rhs
-
>
toInt32
(
)
)
)
;
else
ret
.
setNumber
(
NumberMod
(
lhs
-
>
toNumber
(
)
rhs
-
>
toNumber
(
)
)
)
;
break
;
default
:
MOZ_CRASH
(
"
NYI
"
)
;
}
if
(
ins
-
>
type
(
)
=
=
MIRType_Double
&
&
ret
.
isInt32
(
)
)
ret
.
setDouble
(
ret
.
toNumber
(
)
)
;
if
(
ins
-
>
type
(
)
!
=
MIRTypeFromValue
(
ret
)
)
{
if
(
ptypeChange
)
*
ptypeChange
=
true
;
return
nullptr
;
}
return
MConstant
:
:
New
(
alloc
ret
)
;
}
static
MMul
*
EvaluateExactReciprocal
(
TempAllocator
&
alloc
MDiv
*
ins
)
{
if
(
!
IsFloatingPointType
(
ins
-
>
type
(
)
)
)
return
nullptr
;
MDefinition
*
left
=
ins
-
>
getOperand
(
0
)
;
MDefinition
*
right
=
ins
-
>
getOperand
(
1
)
;
if
(
!
right
-
>
isConstant
(
)
)
return
nullptr
;
int32_t
num
;
if
(
!
mozilla
:
:
NumberIsInt32
(
right
-
>
toConstant
(
)
-
>
toNumber
(
)
&
num
)
)
return
nullptr
;
if
(
mozilla
:
:
Abs
(
num
)
&
(
mozilla
:
:
Abs
(
num
)
-
1
)
)
return
nullptr
;
Value
ret
;
ret
.
setDouble
(
1
.
0
/
(
double
)
num
)
;
MConstant
*
foldedRhs
;
if
(
ins
-
>
type
(
)
=
=
MIRType_Float32
)
foldedRhs
=
MConstant
:
:
NewFloat32
(
alloc
ret
.
toDouble
(
)
)
;
else
foldedRhs
=
MConstant
:
:
New
(
alloc
ret
)
;
MOZ_ASSERT
(
foldedRhs
-
>
type
(
)
=
=
ins
-
>
type
(
)
)
;
ins
-
>
block
(
)
-
>
insertBefore
(
ins
foldedRhs
)
;
MMul
*
mul
=
MMul
:
:
New
(
alloc
left
foldedRhs
ins
-
>
type
(
)
)
;
mul
-
>
setCommutative
(
)
;
return
mul
;
}
void
MDefinition
:
:
printName
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
out
.
printf
(
"
%
u
"
id
(
)
)
;
}
HashNumber
MDefinition
:
:
addU32ToHash
(
HashNumber
hash
uint32_t
data
)
{
return
data
+
(
hash
<
<
6
)
+
(
hash
<
<
16
)
-
hash
;
}
HashNumber
MDefinition
:
:
valueHash
(
)
const
{
HashNumber
out
=
op
(
)
;
for
(
size_t
i
=
0
e
=
numOperands
(
)
;
i
<
e
;
i
+
+
)
out
=
addU32ToHash
(
out
getOperand
(
i
)
-
>
id
(
)
)
;
if
(
MInstruction
*
dep
=
dependency
(
)
)
out
=
addU32ToHash
(
out
dep
-
>
id
(
)
)
;
return
out
;
}
bool
MDefinition
:
:
congruentIfOperandsEqual
(
const
MDefinition
*
ins
)
const
{
if
(
op
(
)
!
=
ins
-
>
op
(
)
)
return
false
;
if
(
type
(
)
!
=
ins
-
>
type
(
)
)
return
false
;
if
(
isEffectful
(
)
|
|
ins
-
>
isEffectful
(
)
)
return
false
;
if
(
numOperands
(
)
!
=
ins
-
>
numOperands
(
)
)
return
false
;
for
(
size_t
i
=
0
e
=
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
if
(
getOperand
(
i
)
!
=
ins
-
>
getOperand
(
i
)
)
return
false
;
}
return
true
;
}
MDefinition
*
MDefinition
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
return
this
;
}
bool
MDefinition
:
:
mightBeMagicType
(
)
const
{
if
(
IsMagicType
(
type
(
)
)
)
return
true
;
if
(
MIRType_Value
!
=
type
(
)
)
return
false
;
return
!
resultTypeSet
(
)
|
|
resultTypeSet
(
)
-
>
hasType
(
TypeSet
:
:
MagicArgType
(
)
)
;
}
MDefinition
*
MInstruction
:
:
foldsToStoredValue
(
TempAllocator
&
alloc
MDefinition
*
loaded
)
{
if
(
loaded
-
>
type
(
)
!
=
type
(
)
)
{
if
(
type
(
)
!
=
MIRType_Value
)
return
this
;
MOZ_ASSERT
(
loaded
-
>
type
(
)
<
MIRType_Value
)
;
MBox
*
box
=
MBox
:
:
New
(
alloc
loaded
)
;
loaded
=
box
;
}
return
loaded
;
}
void
MDefinition
:
:
analyzeEdgeCasesForward
(
)
{
}
void
MDefinition
:
:
analyzeEdgeCasesBackward
(
)
{
}
void
MInstruction
:
:
setResumePoint
(
MResumePoint
*
resumePoint
)
{
MOZ_ASSERT
(
!
resumePoint_
)
;
resumePoint_
=
resumePoint
;
resumePoint_
-
>
setInstruction
(
this
)
;
}
void
MInstruction
:
:
stealResumePoint
(
MInstruction
*
ins
)
{
MOZ_ASSERT
(
ins
-
>
resumePoint_
-
>
instruction
(
)
=
=
ins
)
;
resumePoint_
=
ins
-
>
resumePoint_
;
ins
-
>
resumePoint_
=
nullptr
;
resumePoint_
-
>
replaceInstruction
(
this
)
;
}
void
MInstruction
:
:
moveResumePointAsEntry
(
)
{
MOZ_ASSERT
(
isNop
(
)
)
;
block
(
)
-
>
clearEntryResumePoint
(
)
;
block
(
)
-
>
setEntryResumePoint
(
resumePoint_
)
;
resumePoint_
-
>
resetInstruction
(
)
;
resumePoint_
=
nullptr
;
}
void
MInstruction
:
:
clearResumePoint
(
)
{
resumePoint_
-
>
resetInstruction
(
)
;
block
(
)
-
>
discardPreAllocatedResumePoint
(
resumePoint_
)
;
resumePoint_
=
nullptr
;
}
bool
MDefinition
:
:
maybeEmulatesUndefined
(
CompilerConstraintList
*
constraints
)
{
if
(
!
mightBeType
(
MIRType_Object
)
)
return
false
;
TemporaryTypeSet
*
types
=
resultTypeSet
(
)
;
if
(
!
types
)
return
true
;
return
types
-
>
maybeEmulatesUndefined
(
constraints
)
;
}
static
bool
MaybeCallable
(
CompilerConstraintList
*
constraints
MDefinition
*
op
)
{
if
(
!
op
-
>
mightBeType
(
MIRType_Object
)
)
return
false
;
TemporaryTypeSet
*
types
=
op
-
>
resultTypeSet
(
)
;
if
(
!
types
)
return
true
;
return
types
-
>
maybeCallable
(
constraints
)
;
}
MTest
*
MTest
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
ins
MBasicBlock
*
ifTrue
MBasicBlock
*
ifFalse
)
{
return
new
(
alloc
)
MTest
(
ins
ifTrue
ifFalse
)
;
}
void
MTest
:
:
cacheOperandMightEmulateUndefined
(
CompilerConstraintList
*
constraints
)
{
MOZ_ASSERT
(
operandMightEmulateUndefined
(
)
)
;
if
(
!
getOperand
(
0
)
-
>
maybeEmulatesUndefined
(
constraints
)
)
markNoOperandEmulatesUndefined
(
)
;
}
MDefinition
*
MTest
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
op
=
getOperand
(
0
)
;
if
(
op
-
>
isNot
(
)
)
{
MDefinition
*
opop
=
op
-
>
getOperand
(
0
)
;
if
(
opop
-
>
isNot
(
)
)
return
MTest
:
:
New
(
alloc
opop
-
>
toNot
(
)
-
>
input
(
)
ifTrue
(
)
ifFalse
(
)
)
;
return
MTest
:
:
New
(
alloc
op
-
>
toNot
(
)
-
>
input
(
)
ifFalse
(
)
ifTrue
(
)
)
;
}
if
(
MConstant
*
opConst
=
op
-
>
maybeConstantValue
(
)
)
{
bool
b
;
if
(
opConst
-
>
valueToBoolean
(
&
b
)
)
return
MGoto
:
:
New
(
alloc
b
?
ifTrue
(
)
:
ifFalse
(
)
)
;
}
switch
(
op
-
>
type
(
)
)
{
case
MIRType_Undefined
:
case
MIRType_Null
:
return
MGoto
:
:
New
(
alloc
ifFalse
(
)
)
;
case
MIRType_Symbol
:
return
MGoto
:
:
New
(
alloc
ifTrue
(
)
)
;
case
MIRType_Object
:
if
(
!
operandMightEmulateUndefined
(
)
)
return
MGoto
:
:
New
(
alloc
ifTrue
(
)
)
;
break
;
default
:
break
;
}
return
this
;
}
void
MTest
:
:
filtersUndefinedOrNull
(
bool
trueBranch
MDefinition
*
*
subject
bool
*
filtersUndefined
bool
*
filtersNull
)
{
MDefinition
*
ins
=
getOperand
(
0
)
;
if
(
ins
-
>
isCompare
(
)
)
{
ins
-
>
toCompare
(
)
-
>
filtersUndefinedOrNull
(
trueBranch
subject
filtersUndefined
filtersNull
)
;
return
;
}
if
(
!
trueBranch
&
&
ins
-
>
isNot
(
)
)
{
*
subject
=
ins
-
>
getOperand
(
0
)
;
*
filtersUndefined
=
*
filtersNull
=
true
;
return
;
}
if
(
trueBranch
)
{
*
subject
=
ins
;
*
filtersUndefined
=
*
filtersNull
=
true
;
return
;
}
*
filtersUndefined
=
*
filtersNull
=
false
;
*
subject
=
nullptr
;
}
void
MDefinition
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
for
(
size_t
j
=
0
e
=
numOperands
(
)
;
j
<
e
;
j
+
+
)
{
out
.
printf
(
"
"
)
;
if
(
getUseFor
(
j
)
-
>
hasProducer
(
)
)
getOperand
(
j
)
-
>
printName
(
out
)
;
else
out
.
printf
(
"
(
null
)
"
)
;
}
}
void
MDefinition
:
:
dump
(
GenericPrinter
&
out
)
const
{
printName
(
out
)
;
out
.
printf
(
"
=
"
)
;
printOpcode
(
out
)
;
out
.
printf
(
"
\
n
"
)
;
if
(
isInstruction
(
)
)
{
if
(
MResumePoint
*
resume
=
toInstruction
(
)
-
>
resumePoint
(
)
)
resume
-
>
dump
(
out
)
;
}
}
void
MDefinition
:
:
dump
(
)
const
{
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
out
.
finish
(
)
;
}
void
MDefinition
:
:
dumpLocation
(
GenericPrinter
&
out
)
const
{
MResumePoint
*
rp
=
nullptr
;
const
char
*
linkWord
=
nullptr
;
if
(
isInstruction
(
)
&
&
toInstruction
(
)
-
>
resumePoint
(
)
)
{
rp
=
toInstruction
(
)
-
>
resumePoint
(
)
;
linkWord
=
"
at
"
;
}
else
{
rp
=
block
(
)
-
>
entryResumePoint
(
)
;
linkWord
=
"
after
"
;
}
while
(
rp
)
{
JSScript
*
script
=
rp
-
>
block
(
)
-
>
info
(
)
.
script
(
)
;
uint32_t
lineno
=
PCToLineNumber
(
rp
-
>
block
(
)
-
>
info
(
)
.
script
(
)
rp
-
>
pc
(
)
)
;
out
.
printf
(
"
%
s
%
s
:
%
d
\
n
"
linkWord
script
-
>
filename
(
)
lineno
)
;
rp
=
rp
-
>
caller
(
)
;
linkWord
=
"
in
"
;
}
}
void
MDefinition
:
:
dumpLocation
(
)
const
{
Fprinter
out
(
stderr
)
;
dumpLocation
(
out
)
;
out
.
finish
(
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
size_t
MDefinition
:
:
useCount
(
)
const
{
size_t
count
=
0
;
for
(
MUseIterator
i
(
uses_
.
begin
(
)
)
;
i
!
=
uses_
.
end
(
)
;
i
+
+
)
count
+
+
;
return
count
;
}
size_t
MDefinition
:
:
defUseCount
(
)
const
{
size_t
count
=
0
;
for
(
MUseIterator
i
(
uses_
.
begin
(
)
)
;
i
!
=
uses_
.
end
(
)
;
i
+
+
)
if
(
(
*
i
)
-
>
consumer
(
)
-
>
isDefinition
(
)
)
count
+
+
;
return
count
;
}
#
endif
bool
MDefinition
:
:
hasOneUse
(
)
const
{
MUseIterator
i
(
uses_
.
begin
(
)
)
;
if
(
i
=
=
uses_
.
end
(
)
)
return
false
;
i
+
+
;
return
i
=
=
uses_
.
end
(
)
;
}
bool
MDefinition
:
:
hasOneDefUse
(
)
const
{
bool
hasOneDefUse
=
false
;
for
(
MUseIterator
i
(
uses_
.
begin
(
)
)
;
i
!
=
uses_
.
end
(
)
;
i
+
+
)
{
if
(
!
(
*
i
)
-
>
consumer
(
)
-
>
isDefinition
(
)
)
continue
;
if
(
hasOneDefUse
)
return
false
;
hasOneDefUse
=
true
;
}
return
hasOneDefUse
;
}
bool
MDefinition
:
:
hasDefUses
(
)
const
{
for
(
MUseIterator
i
(
uses_
.
begin
(
)
)
;
i
!
=
uses_
.
end
(
)
;
i
+
+
)
{
if
(
(
*
i
)
-
>
consumer
(
)
-
>
isDefinition
(
)
)
return
true
;
}
return
false
;
}
bool
MDefinition
:
:
hasLiveDefUses
(
)
const
{
for
(
MUseIterator
i
(
uses_
.
begin
(
)
)
;
i
!
=
uses_
.
end
(
)
;
i
+
+
)
{
MNode
*
ins
=
(
*
i
)
-
>
consumer
(
)
;
if
(
ins
-
>
isDefinition
(
)
)
{
if
(
!
ins
-
>
toDefinition
(
)
-
>
isRecoveredOnBailout
(
)
)
return
true
;
}
else
{
MOZ_ASSERT
(
ins
-
>
isResumePoint
(
)
)
;
if
(
!
ins
-
>
toResumePoint
(
)
-
>
isRecoverableOperand
(
*
i
)
)
return
true
;
}
}
return
false
;
}
void
MDefinition
:
:
replaceAllUsesWith
(
MDefinition
*
dom
)
{
for
(
size_t
i
=
0
e
=
numOperands
(
)
;
i
<
e
;
+
+
i
)
getOperand
(
i
)
-
>
setUseRemovedUnchecked
(
)
;
justReplaceAllUsesWith
(
dom
)
;
}
void
MDefinition
:
:
justReplaceAllUsesWith
(
MDefinition
*
dom
)
{
MOZ_ASSERT
(
dom
!
=
nullptr
)
;
MOZ_ASSERT
(
dom
!
=
this
)
;
if
(
isUseRemoved
(
)
)
dom
-
>
setUseRemovedUnchecked
(
)
;
for
(
MUseIterator
i
(
usesBegin
(
)
)
e
(
usesEnd
(
)
)
;
i
!
=
e
;
+
+
i
)
i
-
>
setProducerUnchecked
(
dom
)
;
dom
-
>
uses_
.
takeElements
(
uses_
)
;
}
void
MDefinition
:
:
justReplaceAllUsesWithExcept
(
MDefinition
*
dom
)
{
MOZ_ASSERT
(
dom
!
=
nullptr
)
;
MOZ_ASSERT
(
dom
!
=
this
)
;
if
(
isUseRemoved
(
)
)
dom
-
>
setUseRemovedUnchecked
(
)
;
MUse
*
exceptUse
=
nullptr
;
for
(
MUseIterator
i
(
usesBegin
(
)
)
e
(
usesEnd
(
)
)
;
i
!
=
e
;
+
+
i
)
{
if
(
i
-
>
consumer
(
)
!
=
dom
)
{
i
-
>
setProducerUnchecked
(
dom
)
;
}
else
{
MOZ_ASSERT
(
!
exceptUse
)
;
exceptUse
=
*
i
;
}
}
dom
-
>
uses_
.
takeElements
(
uses_
)
;
dom
-
>
uses_
.
remove
(
exceptUse
)
;
exceptUse
-
>
setProducerUnchecked
(
this
)
;
uses_
.
pushFront
(
exceptUse
)
;
}
void
MDefinition
:
:
optimizeOutAllUses
(
TempAllocator
&
alloc
)
{
for
(
MUseIterator
i
(
usesBegin
(
)
)
e
(
usesEnd
(
)
)
;
i
!
=
e
;
)
{
MUse
*
use
=
*
i
+
+
;
MConstant
*
constant
=
use
-
>
consumer
(
)
-
>
block
(
)
-
>
optimizedOutConstant
(
alloc
)
;
use
-
>
setProducerUnchecked
(
constant
)
;
constant
-
>
addUseUnchecked
(
use
)
;
}
this
-
>
uses_
.
clear
(
)
;
}
void
MDefinition
:
:
replaceAllLiveUsesWith
(
MDefinition
*
dom
)
{
for
(
MUseIterator
i
(
usesBegin
(
)
)
e
(
usesEnd
(
)
)
;
i
!
=
e
;
)
{
MUse
*
use
=
*
i
+
+
;
MNode
*
consumer
=
use
-
>
consumer
(
)
;
if
(
consumer
-
>
isResumePoint
(
)
)
continue
;
if
(
consumer
-
>
isDefinition
(
)
&
&
consumer
-
>
toDefinition
(
)
-
>
isRecoveredOnBailout
(
)
)
continue
;
use
-
>
replaceProducer
(
dom
)
;
}
}
bool
MDefinition
:
:
emptyResultTypeSet
(
)
const
{
return
resultTypeSet
(
)
&
&
resultTypeSet
(
)
-
>
empty
(
)
;
}
MConstant
*
MConstant
:
:
New
(
TempAllocator
&
alloc
const
Value
&
v
CompilerConstraintList
*
constraints
)
{
return
new
(
alloc
)
MConstant
(
v
constraints
)
;
}
MConstant
*
MConstant
:
:
NewFloat32
(
TempAllocator
&
alloc
double
d
)
{
MOZ_ASSERT
(
IsNaN
(
d
)
|
|
d
=
=
double
(
float
(
d
)
)
)
;
return
new
(
alloc
)
MConstant
(
float
(
d
)
)
;
}
MConstant
*
MConstant
:
:
NewAsmJS
(
TempAllocator
&
alloc
const
Value
&
v
MIRType
type
)
{
if
(
type
=
=
MIRType_Float32
)
return
NewFloat32
(
alloc
v
.
toNumber
(
)
)
;
MConstant
*
res
=
New
(
alloc
v
)
;
MOZ_ASSERT
(
res
-
>
type
(
)
=
=
type
)
;
return
res
;
}
MConstant
*
MConstant
:
:
NewConstraintlessObject
(
TempAllocator
&
alloc
JSObject
*
v
)
{
return
new
(
alloc
)
MConstant
(
v
)
;
}
static
TemporaryTypeSet
*
MakeSingletonTypeSetFromKey
(
CompilerConstraintList
*
constraints
TypeSet
:
:
ObjectKey
*
key
)
{
MOZ_ASSERT
(
constraints
)
;
key
-
>
hasStableClassAndProto
(
constraints
)
;
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
return
alloc
-
>
new_
<
TemporaryTypeSet
>
(
alloc
TypeSet
:
:
ObjectType
(
key
)
)
;
}
TemporaryTypeSet
*
jit
:
:
MakeSingletonTypeSet
(
CompilerConstraintList
*
constraints
JSObject
*
obj
)
{
return
MakeSingletonTypeSetFromKey
(
constraints
TypeSet
:
:
ObjectKey
:
:
get
(
obj
)
)
;
}
TemporaryTypeSet
*
jit
:
:
MakeSingletonTypeSet
(
CompilerConstraintList
*
constraints
ObjectGroup
*
obj
)
{
return
MakeSingletonTypeSetFromKey
(
constraints
TypeSet
:
:
ObjectKey
:
:
get
(
obj
)
)
;
}
static
TemporaryTypeSet
*
MakeUnknownTypeSet
(
)
{
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
return
alloc
-
>
new_
<
TemporaryTypeSet
>
(
alloc
TypeSet
:
:
UnknownType
(
)
)
;
}
#
ifdef
DEBUG
bool
jit
:
:
IonCompilationCanUseNurseryPointers
(
)
{
if
(
CurrentThreadIsIonCompiling
(
)
)
return
!
CurrentThreadIsIonCompilingSafeForMinorGC
(
)
;
JSRuntime
*
rt
=
TlsPerThreadData
.
get
(
)
-
>
runtimeFromMainThread
(
)
;
return
rt
-
>
gc
.
storeBuffer
.
cancelIonCompilations
(
)
;
}
#
endif
MConstant
:
:
MConstant
(
const
js
:
:
Value
&
vp
CompilerConstraintList
*
constraints
)
{
setResultType
(
MIRTypeFromValue
(
vp
)
)
;
MOZ_ASSERT
(
payload_
.
asBits
=
=
0
)
;
switch
(
type
(
)
)
{
case
MIRType_Undefined
:
case
MIRType_Null
:
break
;
case
MIRType_Boolean
:
payload_
.
b
=
vp
.
toBoolean
(
)
;
break
;
case
MIRType_Int32
:
payload_
.
i32
=
vp
.
toInt32
(
)
;
break
;
case
MIRType_Double
:
payload_
.
d
=
vp
.
toDouble
(
)
;
break
;
case
MIRType_String
:
MOZ_ASSERT
(
vp
.
toString
(
)
-
>
isAtom
(
)
)
;
payload_
.
str
=
vp
.
toString
(
)
;
break
;
case
MIRType_Symbol
:
payload_
.
sym
=
vp
.
toSymbol
(
)
;
break
;
case
MIRType_Object
:
payload_
.
obj
=
&
vp
.
toObject
(
)
;
MOZ_ASSERT_IF
(
IsInsideNursery
(
&
vp
.
toObject
(
)
)
IonCompilationCanUseNurseryPointers
(
)
)
;
setResultTypeSet
(
MakeSingletonTypeSet
(
constraints
&
vp
.
toObject
(
)
)
)
;
break
;
case
MIRType_MagicOptimizedArguments
:
case
MIRType_MagicOptimizedOut
:
case
MIRType_MagicHole
:
case
MIRType_MagicIsConstructing
:
break
;
case
MIRType_MagicUninitializedLexical
:
setResultTypeSet
(
MakeUnknownTypeSet
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
type
"
)
;
}
setMovable
(
)
;
}
MConstant
:
:
MConstant
(
JSObject
*
obj
)
{
MOZ_ASSERT_IF
(
IsInsideNursery
(
obj
)
IonCompilationCanUseNurseryPointers
(
)
)
;
setResultType
(
MIRType_Object
)
;
payload_
.
obj
=
obj
;
setMovable
(
)
;
}
MConstant
:
:
MConstant
(
float
f
)
{
setResultType
(
MIRType_Float32
)
;
payload_
.
f
=
f
;
setMovable
(
)
;
}
#
ifdef
DEBUG
void
MConstant
:
:
assertInitializedPayload
(
)
const
{
switch
(
type
(
)
)
{
case
MIRType_Int32
:
case
MIRType_Float32
:
MOZ_ASSERT
(
(
payload_
.
asBits
>
>
32
)
=
=
0
)
;
break
;
case
MIRType_Boolean
:
MOZ_ASSERT
(
(
payload_
.
asBits
>
>
1
)
=
=
0
)
;
break
;
case
MIRType_Double
:
break
;
case
MIRType_String
:
case
MIRType_Object
:
case
MIRType_Symbol
:
MOZ_ASSERT_IF
(
JS_BITS_PER_WORD
=
=
32
(
payload_
.
asBits
>
>
32
)
=
=
0
)
;
break
;
default
:
MOZ_ASSERT
(
IsNullOrUndefined
(
type
(
)
)
|
|
IsMagicType
(
type
(
)
)
)
;
MOZ_ASSERT
(
payload_
.
asBits
=
=
0
)
;
break
;
}
}
#
endif
HashNumber
MConstant
:
:
valueHash
(
)
const
{
static_assert
(
sizeof
(
Payload
)
=
=
sizeof
(
uint64_t
)
"
Code
below
assumes
payload
fits
in
64
bits
"
)
;
assertInitializedPayload
(
)
;
static
const
size_t
TypeBits
=
8
;
static
const
size_t
TypeShift
=
64
-
TypeBits
;
MOZ_ASSERT
(
uintptr_t
(
type
(
)
)
<
=
(
1
<
<
TypeBits
)
-
1
)
;
uint64_t
bits
=
(
uint64_t
(
type
(
)
)
<
<
TypeShift
)
^
payload_
.
asBits
;
return
(
HashNumber
)
bits
^
(
HashNumber
)
(
bits
>
>
32
)
;
}
bool
MConstant
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
return
ins
-
>
isConstant
(
)
&
&
equals
(
ins
-
>
toConstant
(
)
)
;
}
void
MConstant
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
out
.
printf
(
"
"
)
;
switch
(
type
(
)
)
{
case
MIRType_Undefined
:
out
.
printf
(
"
undefined
"
)
;
break
;
case
MIRType_Null
:
out
.
printf
(
"
null
"
)
;
break
;
case
MIRType_Boolean
:
out
.
printf
(
toBoolean
(
)
?
"
true
"
:
"
false
"
)
;
break
;
case
MIRType_Int32
:
out
.
printf
(
"
0x
%
x
"
toInt32
(
)
)
;
break
;
case
MIRType_Double
:
out
.
printf
(
"
%
.
16g
"
toDouble
(
)
)
;
break
;
case
MIRType_Float32
:
{
float
val
=
toFloat32
(
)
;
out
.
printf
(
"
%
.
16g
"
val
)
;
break
;
}
case
MIRType_Object
:
if
(
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
fun
-
>
displayAtom
(
)
)
{
out
.
put
(
"
function
"
)
;
EscapedStringPrinter
(
out
fun
-
>
displayAtom
(
)
0
)
;
}
else
{
out
.
put
(
"
unnamed
function
"
)
;
}
if
(
fun
-
>
hasScript
(
)
)
{
JSScript
*
script
=
fun
-
>
nonLazyScript
(
)
;
out
.
printf
(
"
(
%
s
:
%
"
PRIuSIZE
"
)
"
script
-
>
filename
(
)
?
script
-
>
filename
(
)
:
"
"
script
-
>
lineno
(
)
)
;
}
out
.
printf
(
"
at
%
p
"
(
void
*
)
fun
)
;
break
;
}
out
.
printf
(
"
object
%
p
(
%
s
)
"
(
void
*
)
&
toObject
(
)
toObject
(
)
.
getClass
(
)
-
>
name
)
;
break
;
case
MIRType_Symbol
:
out
.
printf
(
"
symbol
at
%
p
"
(
void
*
)
toSymbol
(
)
)
;
break
;
case
MIRType_String
:
out
.
printf
(
"
string
%
p
"
(
void
*
)
toString
(
)
)
;
break
;
case
MIRType_MagicOptimizedArguments
:
out
.
printf
(
"
magic
lazyargs
"
)
;
break
;
case
MIRType_MagicHole
:
out
.
printf
(
"
magic
hole
"
)
;
break
;
case
MIRType_MagicIsConstructing
:
out
.
printf
(
"
magic
is
-
constructing
"
)
;
break
;
case
MIRType_MagicOptimizedOut
:
out
.
printf
(
"
magic
optimized
-
out
"
)
;
break
;
case
MIRType_MagicUninitializedLexical
:
out
.
printf
(
"
magic
uninitialized
-
lexical
"
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
}
bool
MConstant
:
:
canProduceFloat32
(
)
const
{
if
(
!
IsNumberType
(
type
(
)
)
)
return
false
;
if
(
type
(
)
=
=
MIRType_Int32
)
return
IsFloat32Representable
(
static_cast
<
double
>
(
toInt32
(
)
)
)
;
if
(
type
(
)
=
=
MIRType_Double
)
return
IsFloat32Representable
(
toDouble
(
)
)
;
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Float32
)
;
return
true
;
}
Value
MConstant
:
:
toJSValue
(
)
const
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
switch
(
type
(
)
)
{
case
MIRType_Undefined
:
return
UndefinedValue
(
)
;
case
MIRType_Null
:
return
NullValue
(
)
;
case
MIRType_Boolean
:
return
BooleanValue
(
toBoolean
(
)
)
;
case
MIRType_Int32
:
return
Int32Value
(
toInt32
(
)
)
;
case
MIRType_Double
:
return
DoubleValue
(
toDouble
(
)
)
;
case
MIRType_Float32
:
return
Float32Value
(
toFloat32
(
)
)
;
case
MIRType_String
:
return
StringValue
(
toString
(
)
)
;
case
MIRType_Symbol
:
return
SymbolValue
(
toSymbol
(
)
)
;
case
MIRType_Object
:
return
ObjectValue
(
toObject
(
)
)
;
case
MIRType_MagicOptimizedArguments
:
return
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
;
case
MIRType_MagicOptimizedOut
:
return
MagicValue
(
JS_OPTIMIZED_OUT
)
;
case
MIRType_MagicHole
:
return
MagicValue
(
JS_ELEMENTS_HOLE
)
;
case
MIRType_MagicIsConstructing
:
return
MagicValue
(
JS_IS_CONSTRUCTING
)
;
case
MIRType_MagicUninitializedLexical
:
return
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
;
default
:
MOZ_CRASH
(
"
Unexpected
type
"
)
;
}
}
bool
MConstant
:
:
valueToBoolean
(
bool
*
res
)
const
{
switch
(
type
(
)
)
{
case
MIRType_Boolean
:
*
res
=
toBoolean
(
)
;
return
true
;
case
MIRType_Int32
:
*
res
=
toInt32
(
)
!
=
0
;
return
true
;
case
MIRType_Double
:
*
res
=
!
mozilla
:
:
IsNaN
(
toDouble
(
)
)
&
&
toDouble
(
)
!
=
0
.
0
;
return
true
;
case
MIRType_Float32
:
*
res
=
!
mozilla
:
:
IsNaN
(
toFloat32
(
)
)
&
&
toFloat32
(
)
!
=
0
.
0f
;
return
true
;
case
MIRType_Null
:
case
MIRType_Undefined
:
*
res
=
false
;
return
true
;
case
MIRType_Symbol
:
*
res
=
true
;
return
true
;
case
MIRType_String
:
*
res
=
toString
(
)
-
>
length
(
)
!
=
0
;
return
true
;
case
MIRType_Object
:
*
res
=
!
EmulatesUndefined
(
&
toObject
(
)
)
;
return
true
;
default
:
MOZ_ASSERT
(
IsMagicType
(
type
(
)
)
)
;
return
false
;
}
}
MDefinition
*
MSimdValueX4
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
DebugOnly
<
MIRType
>
laneType
=
SimdTypeToLaneArgumentType
(
type
(
)
)
;
bool
allConstants
=
true
;
bool
allSame
=
true
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
{
MDefinition
*
op
=
getOperand
(
i
)
;
MOZ_ASSERT
(
op
-
>
type
(
)
=
=
laneType
)
;
if
(
!
op
-
>
isConstant
(
)
)
allConstants
=
false
;
if
(
i
>
0
&
&
op
!
=
getOperand
(
i
-
1
)
)
allSame
=
false
;
}
if
(
!
allConstants
&
&
!
allSame
)
return
this
;
if
(
allConstants
)
{
SimdConstant
cst
;
switch
(
type
(
)
)
{
case
MIRType_Bool32x4
:
{
int32_t
a
[
4
]
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
a
[
i
]
=
getOperand
(
i
)
-
>
toConstant
(
)
-
>
valueToBooleanInfallible
(
)
?
-
1
:
0
;
cst
=
SimdConstant
:
:
CreateX4
(
a
)
;
break
;
}
case
MIRType_Int32x4
:
{
int32_t
a
[
4
]
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
a
[
i
]
=
getOperand
(
i
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
cst
=
SimdConstant
:
:
CreateX4
(
a
)
;
break
;
}
case
MIRType_Float32x4
:
{
float
a
[
4
]
;
for
(
size_t
i
=
0
;
i
<
4
;
+
+
i
)
a
[
i
]
=
getOperand
(
i
)
-
>
toConstant
(
)
-
>
toNumber
(
)
;
cst
=
SimdConstant
:
:
CreateX4
(
a
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
type
in
MSimdValueX4
:
:
foldsTo
"
)
;
}
return
MSimdConstant
:
:
New
(
alloc
cst
type
(
)
)
;
}
MOZ_ASSERT
(
allSame
)
;
return
MSimdSplatX4
:
:
New
(
alloc
getOperand
(
0
)
type
(
)
)
;
}
MDefinition
*
MSimdSplatX4
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
DebugOnly
<
MIRType
>
laneType
=
SimdTypeToLaneArgumentType
(
type
(
)
)
;
MDefinition
*
op
=
getOperand
(
0
)
;
if
(
!
op
-
>
isConstant
(
)
)
return
this
;
MOZ_ASSERT
(
op
-
>
type
(
)
=
=
laneType
)
;
SimdConstant
cst
;
switch
(
type
(
)
)
{
case
MIRType_Bool32x4
:
{
int32_t
v
=
op
-
>
toConstant
(
)
-
>
valueToBooleanInfallible
(
)
?
-
1
:
0
;
cst
=
SimdConstant
:
:
SplatX4
(
v
)
;
break
;
}
case
MIRType_Int32x4
:
{
int32_t
v
=
op
-
>
toConstant
(
)
-
>
toInt32
(
)
;
cst
=
SimdConstant
:
:
SplatX4
(
v
)
;
break
;
}
case
MIRType_Float32x4
:
{
float
v
=
op
-
>
toConstant
(
)
-
>
toNumber
(
)
;
cst
=
SimdConstant
:
:
SplatX4
(
v
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
type
in
MSimdSplatX4
:
:
foldsTo
"
)
;
}
return
MSimdConstant
:
:
New
(
alloc
cst
type
(
)
)
;
}
MDefinition
*
MSimdUnbox
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
in
=
input
(
)
;
if
(
in
-
>
isSimdBox
(
)
)
{
MSimdBox
*
box
=
in
-
>
toSimdBox
(
)
;
in
=
box
-
>
input
(
)
;
if
(
box
-
>
simdType
(
)
!
=
simdType
(
)
)
return
this
;
MOZ_ASSERT
(
in
-
>
type
(
)
=
=
type
(
)
)
;
return
in
;
}
return
this
;
}
MDefinition
*
MSimdSwizzle
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
lanesMatch
(
0
1
2
3
)
)
return
input
(
)
;
return
this
;
}
MDefinition
*
MSimdGeneralShuffle
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
FixedList
<
uint32_t
>
lanes
;
if
(
!
lanes
.
init
(
alloc
numLanes
(
)
)
)
return
this
;
for
(
size_t
i
=
0
;
i
<
numLanes
(
)
;
i
+
+
)
{
if
(
!
lane
(
i
)
-
>
isConstant
(
)
|
|
lane
(
i
)
-
>
type
(
)
!
=
MIRType_Int32
)
return
this
;
int32_t
temp
=
lane
(
i
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
if
(
temp
<
0
|
|
uint32_t
(
temp
)
>
=
numLanes
(
)
*
numVectors
(
)
)
return
this
;
lanes
[
i
]
=
uint32_t
(
temp
)
;
}
if
(
numVectors
(
)
=
=
1
)
return
MSimdSwizzle
:
:
New
(
alloc
vector
(
0
)
lanes
[
0
]
lanes
[
1
]
lanes
[
2
]
lanes
[
3
]
)
;
MOZ_ASSERT
(
numVectors
(
)
=
=
2
)
;
return
MSimdShuffle
:
:
New
(
alloc
vector
(
0
)
vector
(
1
)
lanes
[
0
]
lanes
[
1
]
lanes
[
2
]
lanes
[
3
]
)
;
}
MInstruction
*
MSimdConvert
:
:
AddLegalized
(
TempAllocator
&
alloc
MBasicBlock
*
addTo
MDefinition
*
obj
MIRType
toType
SimdSign
sign
)
{
MIRType
fromType
=
obj
-
>
type
(
)
;
if
(
SupportsUint32x4FloatConversions
|
|
sign
!
=
SimdSign
:
:
Unsigned
)
{
MInstruction
*
ins
=
New
(
alloc
obj
toType
sign
)
;
addTo
-
>
add
(
ins
)
;
return
ins
;
}
MOZ_ASSERT
(
sign
=
=
SimdSign
:
:
Unsigned
)
;
if
(
fromType
=
=
MIRType_Int32x4
&
&
toType
=
=
MIRType_Float32x4
)
{
MInstruction
*
c16
=
MConstant
:
:
New
(
alloc
Int32Value
(
16
)
)
;
addTo
-
>
add
(
c16
)
;
MInstruction
*
hi
=
MSimdShift
:
:
New
(
alloc
obj
c16
MSimdShift
:
:
ursh
)
;
addTo
-
>
add
(
hi
)
;
MInstruction
*
m16
=
MSimdConstant
:
:
New
(
alloc
SimdConstant
:
:
SplatX4
(
0xffff
)
MIRType_Int32x4
)
;
addTo
-
>
add
(
m16
)
;
MInstruction
*
lo
=
MSimdBinaryBitwise
:
:
New
(
alloc
obj
m16
MSimdBinaryBitwise
:
:
and_
)
;
addTo
-
>
add
(
lo
)
;
MInstruction
*
exphi
=
MSimdConstant
:
:
New
(
alloc
SimdConstant
:
:
SplatX4
(
0x53000000
)
MIRType_Int32x4
)
;
addTo
-
>
add
(
exphi
)
;
MInstruction
*
mhi
=
MSimdBinaryBitwise
:
:
New
(
alloc
hi
exphi
MSimdBinaryBitwise
:
:
or_
)
;
addTo
-
>
add
(
mhi
)
;
MInstruction
*
explo
=
MSimdConstant
:
:
New
(
alloc
SimdConstant
:
:
SplatX4
(
0x4b000000
)
MIRType_Int32x4
)
;
addTo
-
>
add
(
explo
)
;
MInstruction
*
mlo
=
MSimdBinaryBitwise
:
:
New
(
alloc
lo
explo
MSimdBinaryBitwise
:
:
or_
)
;
addTo
-
>
add
(
mlo
)
;
MInstruction
*
fhi
=
MSimdReinterpretCast
:
:
New
(
alloc
mhi
MIRType_Float32x4
)
;
addTo
-
>
add
(
fhi
)
;
MInstruction
*
flo
=
MSimdReinterpretCast
:
:
New
(
alloc
mlo
MIRType_Float32x4
)
;
addTo
-
>
add
(
flo
)
;
const
float
BiasValue
=
549755813888
.
f
+
8388608
.
f
;
MInstruction
*
bias
=
MSimdConstant
:
:
New
(
alloc
SimdConstant
:
:
SplatX4
(
BiasValue
)
MIRType_Float32x4
)
;
addTo
-
>
add
(
bias
)
;
MInstruction
*
fhi_debiased
=
MSimdBinaryArith
:
:
New
(
alloc
fhi
bias
MSimdBinaryArith
:
:
Op_sub
)
;
addTo
-
>
add
(
fhi_debiased
)
;
MInstruction
*
result
=
MSimdBinaryArith
:
:
New
(
alloc
fhi_debiased
flo
MSimdBinaryArith
:
:
Op_add
)
;
addTo
-
>
add
(
result
)
;
return
result
;
}
if
(
fromType
=
=
MIRType_Float32x4
&
&
toType
=
=
MIRType_Int32x4
)
{
MInstruction
*
ins
=
New
(
alloc
obj
toType
sign
)
;
addTo
-
>
add
(
ins
)
;
return
ins
;
}
MOZ_CRASH
(
"
Unhandled
SIMD
type
conversion
"
)
;
}
MInstruction
*
MSimdBinaryComp
:
:
AddLegalized
(
TempAllocator
&
alloc
MBasicBlock
*
addTo
MDefinition
*
left
MDefinition
*
right
Operation
op
SimdSign
sign
)
{
MOZ_ASSERT
(
left
-
>
type
(
)
=
=
right
-
>
type
(
)
)
;
MIRType
opType
=
left
-
>
type
(
)
;
MOZ_ASSERT
(
IsSimdType
(
opType
)
)
;
bool
IsEquality
=
op
=
=
equal
|
|
op
=
=
notEqual
;
if
(
!
SupportsUint32x4Compares
&
&
sign
=
=
SimdSign
:
:
Unsigned
&
&
!
IsEquality
)
{
MOZ_ASSERT
(
opType
=
=
MIRType_Int32x4
)
;
MInstruction
*
bias
=
MSimdConstant
:
:
New
(
alloc
SimdConstant
:
:
SplatX4
(
int32_t
(
0x80000000
)
)
opType
)
;
addTo
-
>
add
(
bias
)
;
MInstruction
*
bleft
=
MSimdBinaryArith
:
:
New
(
alloc
left
bias
MSimdBinaryArith
:
:
Op_add
)
;
addTo
-
>
add
(
bleft
)
;
MInstruction
*
bright
=
MSimdBinaryArith
:
:
New
(
alloc
right
bias
MSimdBinaryArith
:
:
Op_add
)
;
addTo
-
>
add
(
bright
)
;
MInstruction
*
result
=
MSimdBinaryComp
:
:
New
(
alloc
bleft
bright
op
SimdSign
:
:
Signed
)
;
addTo
-
>
add
(
result
)
;
return
result
;
}
if
(
!
SupportsUint32x4Compares
&
&
sign
=
=
SimdSign
:
:
Unsigned
&
&
opType
=
=
MIRType_Int32x4
)
{
MOZ_ASSERT
(
IsEquality
)
;
sign
=
SimdSign
:
:
Signed
;
}
MInstruction
*
result
=
MSimdBinaryComp
:
:
New
(
alloc
left
right
op
sign
)
;
addTo
-
>
add
(
result
)
;
return
result
;
}
template
<
typename
T
>
static
void
PrintOpcodeOperation
(
T
*
mir
GenericPrinter
&
out
)
{
mir
-
>
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
(
%
s
)
"
T
:
:
OperationName
(
mir
-
>
operation
(
)
)
)
;
}
void
MSimdBinaryArith
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeOperation
(
this
out
)
;
}
void
MSimdBinaryBitwise
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeOperation
(
this
out
)
;
}
void
MSimdUnaryArith
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeOperation
(
this
out
)
;
}
void
MSimdBinaryComp
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeOperation
(
this
out
)
;
}
void
MSimdShift
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeOperation
(
this
out
)
;
}
void
MSimdInsertElement
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
(
%
s
)
"
MSimdInsertElement
:
:
LaneName
(
lane
(
)
)
)
;
}
void
MSimdBox
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
(
%
s
%
s
)
"
SimdTypeToString
(
simdType
(
)
)
initialHeap
(
)
=
=
gc
:
:
TenuredHeap
?
"
tenured
"
:
"
"
)
;
}
void
MSimdUnbox
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
(
%
s
)
"
SimdTypeToString
(
simdType
(
)
)
)
;
}
MCloneLiteral
*
MCloneLiteral
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
obj
)
{
return
new
(
alloc
)
MCloneLiteral
(
obj
)
;
}
void
MControlInstruction
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
for
(
size_t
j
=
0
;
j
<
numSuccessors
(
)
;
j
+
+
)
out
.
printf
(
"
block
%
u
"
getSuccessor
(
j
)
-
>
id
(
)
)
;
}
void
MCompare
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
%
s
"
CodeName
[
jsop
(
)
]
)
;
}
void
MConstantElements
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
out
.
printf
(
"
0x
%
"
PRIxPTR
value
(
)
.
asValue
(
)
)
;
}
void
MLoadUnboxedScalar
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
%
s
"
ScalarTypeDescr
:
:
typeName
(
storageType
(
)
)
)
;
}
void
MAssertRange
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
put
(
"
"
)
;
assertedRange
(
)
-
>
dump
(
out
)
;
}
const
char
*
MMathFunction
:
:
FunctionName
(
Function
function
)
{
switch
(
function
)
{
case
Log
:
return
"
Log
"
;
case
Sin
:
return
"
Sin
"
;
case
Cos
:
return
"
Cos
"
;
case
Exp
:
return
"
Exp
"
;
case
Tan
:
return
"
Tan
"
;
case
ACos
:
return
"
ACos
"
;
case
ASin
:
return
"
ASin
"
;
case
ATan
:
return
"
ATan
"
;
case
Log10
:
return
"
Log10
"
;
case
Log2
:
return
"
Log2
"
;
case
Log1P
:
return
"
Log1P
"
;
case
ExpM1
:
return
"
ExpM1
"
;
case
CosH
:
return
"
CosH
"
;
case
SinH
:
return
"
SinH
"
;
case
TanH
:
return
"
TanH
"
;
case
ACosH
:
return
"
ACosH
"
;
case
ASinH
:
return
"
ASinH
"
;
case
ATanH
:
return
"
ATanH
"
;
case
Sign
:
return
"
Sign
"
;
case
Trunc
:
return
"
Trunc
"
;
case
Cbrt
:
return
"
Cbrt
"
;
case
Floor
:
return
"
Floor
"
;
case
Ceil
:
return
"
Ceil
"
;
case
Round
:
return
"
Round
"
;
default
:
MOZ_CRASH
(
"
Unknown
math
function
"
)
;
}
}
void
MMathFunction
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
%
s
"
FunctionName
(
function
(
)
)
)
;
}
MDefinition
*
MMathFunction
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
!
input
-
>
isConstant
(
)
|
|
!
input
-
>
toConstant
(
)
-
>
isNumber
(
)
)
return
this
;
double
in
=
input
-
>
toConstant
(
)
-
>
toNumber
(
)
;
double
out
;
switch
(
function_
)
{
case
Log
:
out
=
js
:
:
math_log_uncached
(
in
)
;
break
;
case
Sin
:
out
=
js
:
:
math_sin_uncached
(
in
)
;
break
;
case
Cos
:
out
=
js
:
:
math_cos_uncached
(
in
)
;
break
;
case
Exp
:
out
=
js
:
:
math_exp_uncached
(
in
)
;
break
;
case
Tan
:
out
=
js
:
:
math_tan_uncached
(
in
)
;
break
;
case
ACos
:
out
=
js
:
:
math_acos_uncached
(
in
)
;
break
;
case
ASin
:
out
=
js
:
:
math_asin_uncached
(
in
)
;
break
;
case
ATan
:
out
=
js
:
:
math_atan_uncached
(
in
)
;
break
;
case
Log10
:
out
=
js
:
:
math_log10_uncached
(
in
)
;
break
;
case
Log2
:
out
=
js
:
:
math_log2_uncached
(
in
)
;
break
;
case
Log1P
:
out
=
js
:
:
math_log1p_uncached
(
in
)
;
break
;
case
ExpM1
:
out
=
js
:
:
math_expm1_uncached
(
in
)
;
break
;
case
CosH
:
out
=
js
:
:
math_cosh_uncached
(
in
)
;
break
;
case
SinH
:
out
=
js
:
:
math_sinh_uncached
(
in
)
;
break
;
case
TanH
:
out
=
js
:
:
math_tanh_uncached
(
in
)
;
break
;
case
ACosH
:
out
=
js
:
:
math_acosh_uncached
(
in
)
;
break
;
case
ASinH
:
out
=
js
:
:
math_asinh_uncached
(
in
)
;
break
;
case
ATanH
:
out
=
js
:
:
math_atanh_uncached
(
in
)
;
break
;
case
Sign
:
out
=
js
:
:
math_sign_uncached
(
in
)
;
break
;
case
Trunc
:
out
=
js
:
:
math_trunc_uncached
(
in
)
;
break
;
case
Cbrt
:
out
=
js
:
:
math_cbrt_uncached
(
in
)
;
break
;
case
Floor
:
out
=
js
:
:
math_floor_impl
(
in
)
;
break
;
case
Ceil
:
out
=
js
:
:
math_ceil_impl
(
in
)
;
break
;
case
Round
:
out
=
js
:
:
math_round_impl
(
in
)
;
break
;
default
:
return
this
;
}
if
(
input
-
>
type
(
)
=
=
MIRType_Float32
)
return
MConstant
:
:
NewFloat32
(
alloc
out
)
;
return
MConstant
:
:
New
(
alloc
DoubleValue
(
out
)
)
;
}
MDefinition
*
MAtomicIsLockFree
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
!
input
-
>
isConstant
(
)
|
|
input
-
>
type
(
)
!
=
MIRType_Int32
)
return
this
;
int32_t
i
=
input
-
>
toConstant
(
)
-
>
toInt32
(
)
;
return
MConstant
:
:
New
(
alloc
BooleanValue
(
AtomicOperations
:
:
isLockfree
(
i
)
)
)
;
}
MParameter
*
MParameter
:
:
New
(
TempAllocator
&
alloc
int32_t
index
TemporaryTypeSet
*
types
)
{
return
new
(
alloc
)
MParameter
(
index
types
)
;
}
void
MParameter
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
if
(
index
(
)
=
=
THIS_SLOT
)
out
.
printf
(
"
THIS_SLOT
"
)
;
else
out
.
printf
(
"
%
d
"
index
(
)
)
;
}
HashNumber
MParameter
:
:
valueHash
(
)
const
{
HashNumber
hash
=
MDefinition
:
:
valueHash
(
)
;
hash
=
addU32ToHash
(
hash
index_
)
;
return
hash
;
}
bool
MParameter
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
ins
-
>
isParameter
(
)
)
return
false
;
return
ins
-
>
toParameter
(
)
-
>
index
(
)
=
=
index_
;
}
MCall
*
MCall
:
:
New
(
TempAllocator
&
alloc
JSFunction
*
target
size_t
maxArgc
size_t
numActualArgs
bool
construct
bool
isDOMCall
)
{
MOZ_ASSERT
(
maxArgc
>
=
numActualArgs
)
;
MCall
*
ins
;
if
(
isDOMCall
)
{
MOZ_ASSERT
(
!
construct
)
;
ins
=
new
(
alloc
)
MCallDOMNative
(
target
numActualArgs
)
;
}
else
{
ins
=
new
(
alloc
)
MCall
(
target
numActualArgs
construct
)
;
}
if
(
!
ins
-
>
init
(
alloc
maxArgc
+
NumNonArgumentOperands
)
)
return
nullptr
;
return
ins
;
}
AliasSet
MCallDOMNative
:
:
getAliasSet
(
)
const
{
const
JSJitInfo
*
jitInfo
=
getJitInfo
(
)
;
if
(
jitInfo
-
>
aliasSet
(
)
=
=
JSJitInfo
:
:
AliasEverything
|
|
!
jitInfo
-
>
isTypedMethodJitInfo
(
)
)
return
AliasSet
:
:
Store
(
AliasSet
:
:
Any
)
;
uint32_t
argIndex
=
0
;
const
JSTypedMethodJitInfo
*
methodInfo
=
reinterpret_cast
<
const
JSTypedMethodJitInfo
*
>
(
jitInfo
)
;
for
(
const
JSJitInfo
:
:
ArgType
*
argType
=
methodInfo
-
>
argTypes
;
*
argType
!
=
JSJitInfo
:
:
ArgTypeListEnd
;
+
+
argType
+
+
argIndex
)
{
if
(
argIndex
>
=
numActualArgs
(
)
)
{
continue
;
}
MDefinition
*
arg
=
getArg
(
argIndex
+
1
)
;
MIRType
actualType
=
arg
-
>
type
(
)
;
if
(
(
actualType
=
=
MIRType_Value
|
|
actualType
=
=
MIRType_Object
)
|
|
(
*
argType
&
JSJitInfo
:
:
Object
)
)
{
return
AliasSet
:
:
Store
(
AliasSet
:
:
Any
)
;
}
}
if
(
jitInfo
-
>
aliasSet
(
)
=
=
JSJitInfo
:
:
AliasNone
)
return
AliasSet
:
:
None
(
)
;
MOZ_ASSERT
(
jitInfo
-
>
aliasSet
(
)
=
=
JSJitInfo
:
:
AliasDOMSets
)
;
return
AliasSet
:
:
Load
(
AliasSet
:
:
DOMProperty
)
;
}
void
MCallDOMNative
:
:
computeMovable
(
)
{
const
JSJitInfo
*
jitInfo
=
getJitInfo
(
)
;
MOZ_ASSERT_IF
(
jitInfo
-
>
isMovable
jitInfo
-
>
aliasSet
(
)
!
=
JSJitInfo
:
:
AliasEverything
)
;
if
(
jitInfo
-
>
isMovable
&
&
!
isEffectful
(
)
)
setMovable
(
)
;
}
bool
MCallDOMNative
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
isMovable
(
)
)
return
false
;
if
(
!
ins
-
>
isCall
(
)
)
return
false
;
const
MCall
*
call
=
ins
-
>
toCall
(
)
;
if
(
!
call
-
>
isCallDOMNative
(
)
)
return
false
;
if
(
getSingleTarget
(
)
!
=
call
-
>
getSingleTarget
(
)
)
return
false
;
if
(
isConstructing
(
)
!
=
call
-
>
isConstructing
(
)
)
return
false
;
if
(
numActualArgs
(
)
!
=
call
-
>
numActualArgs
(
)
)
return
false
;
if
(
needsArgCheck
(
)
!
=
call
-
>
needsArgCheck
(
)
)
return
false
;
if
(
!
congruentIfOperandsEqual
(
call
)
)
return
false
;
MOZ_ASSERT
(
call
-
>
isMovable
(
)
)
;
return
true
;
}
const
JSJitInfo
*
MCallDOMNative
:
:
getJitInfo
(
)
const
{
MOZ_ASSERT
(
getSingleTarget
(
)
&
&
getSingleTarget
(
)
-
>
isNative
(
)
)
;
const
JSJitInfo
*
jitInfo
=
getSingleTarget
(
)
-
>
jitInfo
(
)
;
MOZ_ASSERT
(
jitInfo
)
;
return
jitInfo
;
}
MApplyArgs
*
MApplyArgs
:
:
New
(
TempAllocator
&
alloc
JSFunction
*
target
MDefinition
*
fun
MDefinition
*
argc
MDefinition
*
self
)
{
return
new
(
alloc
)
MApplyArgs
(
target
fun
argc
self
)
;
}
MApplyArray
*
MApplyArray
:
:
New
(
TempAllocator
&
alloc
JSFunction
*
target
MDefinition
*
fun
MDefinition
*
elements
MDefinition
*
self
)
{
return
new
(
alloc
)
MApplyArray
(
target
fun
elements
self
)
;
}
MDefinition
*
MStringLength
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
type
(
)
=
=
MIRType_Int32
&
&
string
(
)
-
>
isConstant
(
)
)
{
JSAtom
*
atom
=
&
string
(
)
-
>
toConstant
(
)
-
>
toString
(
)
-
>
asAtom
(
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
atom
-
>
length
(
)
)
)
;
}
return
this
;
}
MDefinition
*
MConcat
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
lhs
(
)
-
>
isConstant
(
)
&
&
lhs
(
)
-
>
toConstant
(
)
-
>
toString
(
)
-
>
empty
(
)
)
return
rhs
(
)
;
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
rhs
(
)
-
>
toConstant
(
)
-
>
toString
(
)
-
>
empty
(
)
)
return
lhs
(
)
;
return
this
;
}
static
bool
EnsureFloatInputOrConvert
(
MUnaryInstruction
*
owner
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
owner
-
>
input
(
)
;
if
(
!
input
-
>
canProduceFloat32
(
)
)
{
if
(
input
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
input
owner
)
;
return
false
;
}
return
true
;
}
void
MFloor
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Int32
)
;
if
(
EnsureFloatInputOrConvert
(
this
alloc
)
)
specialization_
=
MIRType_Float32
;
}
void
MCeil
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Int32
)
;
if
(
EnsureFloatInputOrConvert
(
this
alloc
)
)
specialization_
=
MIRType_Float32
;
}
void
MRound
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Int32
)
;
if
(
EnsureFloatInputOrConvert
(
this
alloc
)
)
specialization_
=
MIRType_Float32
;
}
MCompare
*
MCompare
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
JSOp
op
)
{
return
new
(
alloc
)
MCompare
(
left
right
op
)
;
}
MCompare
*
MCompare
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
JSOp
op
CompareType
compareType
)
{
MOZ_ASSERT
(
compareType
=
=
Compare_Int32
|
|
compareType
=
=
Compare_UInt32
|
|
compareType
=
=
Compare_Double
|
|
compareType
=
=
Compare_Float32
)
;
MCompare
*
comp
=
new
(
alloc
)
MCompare
(
left
right
op
)
;
comp
-
>
compareType_
=
compareType
;
comp
-
>
operandMightEmulateUndefined_
=
false
;
comp
-
>
setResultType
(
MIRType_Int32
)
;
return
comp
;
}
MTableSwitch
*
MTableSwitch
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
ins
int32_t
low
int32_t
high
)
{
return
new
(
alloc
)
MTableSwitch
(
alloc
ins
low
high
)
;
}
MGoto
*
MGoto
:
:
New
(
TempAllocator
&
alloc
MBasicBlock
*
target
)
{
MOZ_ASSERT
(
target
)
;
return
new
(
alloc
)
MGoto
(
target
)
;
}
void
MUnbox
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
out
.
printf
(
"
"
)
;
getOperand
(
0
)
-
>
printName
(
out
)
;
out
.
printf
(
"
"
)
;
switch
(
type
(
)
)
{
case
MIRType_Int32
:
out
.
printf
(
"
to
Int32
"
)
;
break
;
case
MIRType_Double
:
out
.
printf
(
"
to
Double
"
)
;
break
;
case
MIRType_Boolean
:
out
.
printf
(
"
to
Boolean
"
)
;
break
;
case
MIRType_String
:
out
.
printf
(
"
to
String
"
)
;
break
;
case
MIRType_Symbol
:
out
.
printf
(
"
to
Symbol
"
)
;
break
;
case
MIRType_Object
:
out
.
printf
(
"
to
Object
"
)
;
break
;
default
:
break
;
}
switch
(
mode
(
)
)
{
case
Fallible
:
out
.
printf
(
"
(
fallible
)
"
)
;
break
;
case
Infallible
:
out
.
printf
(
"
(
infallible
)
"
)
;
break
;
case
TypeBarrier
:
out
.
printf
(
"
(
typebarrier
)
"
)
;
break
;
default
:
break
;
}
}
MDefinition
*
MUnbox
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
input
(
)
-
>
isLoadFixedSlot
(
)
)
return
this
;
MLoadFixedSlot
*
load
=
input
(
)
-
>
toLoadFixedSlot
(
)
;
if
(
load
-
>
type
(
)
!
=
MIRType_Value
)
return
this
;
if
(
type
(
)
!
=
MIRType_Boolean
&
&
!
IsNumberType
(
type
(
)
)
)
return
this
;
MInstructionIterator
iter
(
load
-
>
block
(
)
-
>
begin
(
load
)
)
;
+
+
iter
;
if
(
*
iter
!
=
this
)
return
this
;
MLoadFixedSlotAndUnbox
*
ins
=
MLoadFixedSlotAndUnbox
:
:
New
(
alloc
load
-
>
object
(
)
load
-
>
slot
(
)
mode
(
)
type
(
)
bailoutKind
(
)
)
;
ins
-
>
setDependency
(
load
-
>
dependency
(
)
)
;
return
ins
;
}
void
MTypeBarrier
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
PrintOpcodeName
(
out
op
(
)
)
;
out
.
printf
(
"
"
)
;
getOperand
(
0
)
-
>
printName
(
out
)
;
}
bool
MTypeBarrier
:
:
congruentTo
(
const
MDefinition
*
def
)
const
{
if
(
!
def
-
>
isTypeBarrier
(
)
)
return
false
;
const
MTypeBarrier
*
other
=
def
-
>
toTypeBarrier
(
)
;
if
(
barrierKind
(
)
!
=
other
-
>
barrierKind
(
)
|
|
isGuard
(
)
!
=
other
-
>
isGuard
(
)
)
return
false
;
if
(
!
resultTypeSet
(
)
-
>
equals
(
other
-
>
resultTypeSet
(
)
)
)
return
false
;
return
congruentIfOperandsEqual
(
other
)
;
}
#
ifdef
DEBUG
void
MPhi
:
:
assertLoopPhi
(
)
const
{
MBasicBlock
*
pred
=
block
(
)
-
>
getPredecessor
(
0
)
;
MBasicBlock
*
back
=
block
(
)
-
>
getPredecessor
(
1
)
;
MOZ_ASSERT
(
pred
=
=
block
(
)
-
>
loopPredecessor
(
)
)
;
MOZ_ASSERT
(
pred
-
>
successorWithPhis
(
)
=
=
block
(
)
)
;
MOZ_ASSERT
(
pred
-
>
positionInPhiSuccessor
(
)
=
=
0
)
;
MOZ_ASSERT
(
back
=
=
block
(
)
-
>
backedge
(
)
)
;
MOZ_ASSERT
(
back
-
>
successorWithPhis
(
)
=
=
block
(
)
)
;
MOZ_ASSERT
(
back
-
>
positionInPhiSuccessor
(
)
=
=
1
)
;
}
#
endif
void
MPhi
:
:
removeOperand
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numOperands
(
)
)
;
MOZ_ASSERT
(
getUseFor
(
index
)
-
>
index
(
)
=
=
index
)
;
MOZ_ASSERT
(
getUseFor
(
index
)
-
>
consumer
(
)
=
=
this
)
;
MUse
*
p
=
inputs_
.
begin
(
)
+
index
;
MUse
*
e
=
inputs_
.
end
(
)
;
p
-
>
producer
(
)
-
>
removeUse
(
p
)
;
for
(
;
p
<
e
-
1
;
+
+
p
)
{
MDefinition
*
producer
=
(
p
+
1
)
-
>
producer
(
)
;
p
-
>
setProducerUnchecked
(
producer
)
;
producer
-
>
replaceUse
(
p
+
1
p
)
;
}
inputs_
.
popBack
(
)
;
}
void
MPhi
:
:
removeAllOperands
(
)
{
for
(
MUse
&
p
:
inputs_
)
p
.
producer
(
)
-
>
removeUse
(
&
p
)
;
inputs_
.
clear
(
)
;
}
MDefinition
*
MPhi
:
:
foldsTernary
(
)
{
if
(
numOperands
(
)
!
=
2
)
return
nullptr
;
MOZ_ASSERT
(
block
(
)
-
>
numPredecessors
(
)
=
=
2
)
;
MBasicBlock
*
pred
=
block
(
)
-
>
immediateDominator
(
)
;
if
(
!
pred
|
|
!
pred
-
>
lastIns
(
)
-
>
isTest
(
)
)
return
nullptr
;
MTest
*
test
=
pred
-
>
lastIns
(
)
-
>
toTest
(
)
;
if
(
test
-
>
ifTrue
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
0
)
)
=
=
test
-
>
ifTrue
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
1
)
)
)
{
return
nullptr
;
}
if
(
test
-
>
ifFalse
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
0
)
)
=
=
test
-
>
ifFalse
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
1
)
)
)
{
return
nullptr
;
}
if
(
test
-
>
ifTrue
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
0
)
)
=
=
test
-
>
ifFalse
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
0
)
)
)
{
return
nullptr
;
}
bool
firstIsTrueBranch
=
test
-
>
ifTrue
(
)
-
>
dominates
(
block
(
)
-
>
getPredecessor
(
0
)
)
;
MDefinition
*
trueDef
=
firstIsTrueBranch
?
getOperand
(
0
)
:
getOperand
(
1
)
;
MDefinition
*
falseDef
=
firstIsTrueBranch
?
getOperand
(
1
)
:
getOperand
(
0
)
;
if
(
!
trueDef
-
>
isConstant
(
)
&
&
!
falseDef
-
>
isConstant
(
)
)
return
nullptr
;
MConstant
*
c
=
trueDef
-
>
isConstant
(
)
?
trueDef
-
>
toConstant
(
)
:
falseDef
-
>
toConstant
(
)
;
MDefinition
*
testArg
=
(
trueDef
=
=
c
)
?
falseDef
:
trueDef
;
if
(
testArg
!
=
test
-
>
input
(
)
)
return
nullptr
;
MBasicBlock
*
truePred
=
block
(
)
-
>
getPredecessor
(
firstIsTrueBranch
?
0
:
1
)
;
MBasicBlock
*
falsePred
=
block
(
)
-
>
getPredecessor
(
firstIsTrueBranch
?
1
:
0
)
;
if
(
!
trueDef
-
>
block
(
)
-
>
dominates
(
truePred
)
|
|
!
falseDef
-
>
block
(
)
-
>
dominates
(
falsePred
)
)
{
return
nullptr
;
}
if
(
testArg
-
>
type
(
)
=
=
MIRType_Int32
&
&
c
-
>
toNumber
(
)
=
=
0
)
{
if
(
trueDef
=
=
c
&
&
!
c
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
c
-
>
block
(
)
-
>
moveBefore
(
pred
-
>
lastIns
(
)
c
)
;
return
trueDef
;
}
if
(
testArg
-
>
type
(
)
=
=
MIRType_String
&
&
c
-
>
toString
(
)
=
=
GetJitContext
(
)
-
>
runtime
-
>
emptyString
(
)
)
{
if
(
trueDef
=
=
c
&
&
!
c
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
c
-
>
block
(
)
-
>
moveBefore
(
pred
-
>
lastIns
(
)
c
)
;
return
trueDef
;
}
return
nullptr
;
}
MDefinition
*
MPhi
:
:
operandIfRedundant
(
)
{
if
(
inputs_
.
length
(
)
=
=
0
)
return
nullptr
;
MDefinition
*
first
=
getOperand
(
0
)
;
for
(
size_t
i
=
1
e
=
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
op
=
getOperand
(
i
)
;
if
(
op
!
=
first
&
&
op
!
=
this
)
return
nullptr
;
}
return
first
;
}
MDefinition
*
MPhi
:
:
foldsFilterTypeSet
(
)
{
if
(
inputs_
.
length
(
)
=
=
0
)
return
nullptr
;
MDefinition
*
subject
=
getOperand
(
0
)
;
if
(
subject
-
>
isFilterTypeSet
(
)
)
subject
=
subject
-
>
toFilterTypeSet
(
)
-
>
input
(
)
;
if
(
subject
-
>
type
(
)
!
=
type
(
)
)
return
nullptr
;
if
(
resultTypeSet
(
)
&
&
!
subject
-
>
resultTypeSet
(
)
)
return
nullptr
;
if
(
subject
-
>
resultTypeSet
(
)
&
&
resultTypeSet
(
)
)
{
if
(
!
subject
-
>
resultTypeSet
(
)
-
>
isSubset
(
resultTypeSet
(
)
)
)
return
nullptr
;
}
for
(
size_t
i
=
1
e
=
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
op
=
getOperand
(
i
)
;
if
(
op
=
=
subject
)
continue
;
if
(
op
-
>
isFilterTypeSet
(
)
&
&
op
-
>
toFilterTypeSet
(
)
-
>
input
(
)
=
=
subject
)
continue
;
return
nullptr
;
}
return
subject
;
}
MDefinition
*
MPhi
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
MDefinition
*
def
=
operandIfRedundant
(
)
)
return
def
;
if
(
MDefinition
*
def
=
foldsTernary
(
)
)
return
def
;
if
(
MDefinition
*
def
=
foldsFilterTypeSet
(
)
)
return
def
;
return
this
;
}
bool
MPhi
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
ins
-
>
isPhi
(
)
)
return
false
;
if
(
ins
-
>
block
(
)
!
=
block
(
)
)
return
false
;
return
congruentIfOperandsEqual
(
ins
)
;
}
static
inline
TemporaryTypeSet
*
MakeMIRTypeSet
(
MIRType
type
)
{
MOZ_ASSERT
(
type
!
=
MIRType_Value
)
;
TypeSet
:
:
Type
ntype
=
type
=
=
MIRType_Object
?
TypeSet
:
:
AnyObjectType
(
)
:
TypeSet
:
:
PrimitiveType
(
ValueTypeFromMIRType
(
type
)
)
;
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
return
alloc
-
>
new_
<
TemporaryTypeSet
>
(
alloc
ntype
)
;
}
bool
jit
:
:
MergeTypes
(
MIRType
*
ptype
TemporaryTypeSet
*
*
ptypeSet
MIRType
newType
TemporaryTypeSet
*
newTypeSet
)
{
if
(
newTypeSet
&
&
newTypeSet
-
>
empty
(
)
)
return
true
;
if
(
newType
!
=
*
ptype
)
{
if
(
IsNumberType
(
newType
)
&
&
IsNumberType
(
*
ptype
)
)
{
*
ptype
=
MIRType_Double
;
}
else
if
(
*
ptype
!
=
MIRType_Value
)
{
if
(
!
*
ptypeSet
)
{
*
ptypeSet
=
MakeMIRTypeSet
(
*
ptype
)
;
if
(
!
*
ptypeSet
)
return
false
;
}
*
ptype
=
MIRType_Value
;
}
else
if
(
*
ptypeSet
&
&
(
*
ptypeSet
)
-
>
empty
(
)
)
{
*
ptype
=
newType
;
}
}
if
(
*
ptypeSet
)
{
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
if
(
!
newTypeSet
&
&
newType
!
=
MIRType_Value
)
{
newTypeSet
=
MakeMIRTypeSet
(
newType
)
;
if
(
!
newTypeSet
)
return
false
;
}
if
(
newTypeSet
)
{
if
(
!
newTypeSet
-
>
isSubset
(
*
ptypeSet
)
)
{
*
ptypeSet
=
TypeSet
:
:
unionSets
(
*
ptypeSet
newTypeSet
alloc
)
;
if
(
!
*
ptypeSet
)
return
false
;
}
}
else
{
*
ptypeSet
=
nullptr
;
}
}
return
true
;
}
bool
jit
:
:
TypeSetIncludes
(
TypeSet
*
types
MIRType
input
TypeSet
*
inputTypes
)
{
if
(
!
types
)
return
inputTypes
&
&
inputTypes
-
>
empty
(
)
;
switch
(
input
)
{
case
MIRType_Undefined
:
case
MIRType_Null
:
case
MIRType_Boolean
:
case
MIRType_Int32
:
case
MIRType_Double
:
case
MIRType_Float32
:
case
MIRType_String
:
case
MIRType_Symbol
:
case
MIRType_MagicOptimizedArguments
:
return
types
-
>
hasType
(
TypeSet
:
:
PrimitiveType
(
ValueTypeFromMIRType
(
input
)
)
)
;
case
MIRType_Object
:
return
types
-
>
unknownObject
(
)
|
|
(
inputTypes
&
&
inputTypes
-
>
isSubset
(
types
)
)
;
case
MIRType_Value
:
return
types
-
>
unknown
(
)
|
|
(
inputTypes
&
&
inputTypes
-
>
isSubset
(
types
)
)
;
default
:
MOZ_CRASH
(
"
Bad
input
type
"
)
;
}
}
bool
jit
:
:
EqualTypes
(
MIRType
type1
TemporaryTypeSet
*
typeset1
MIRType
type2
TemporaryTypeSet
*
typeset2
)
{
if
(
type1
!
=
type2
)
return
false
;
if
(
!
typeset1
&
&
!
typeset2
)
return
true
;
if
(
typeset1
&
&
!
typeset2
)
return
TypeSetIncludes
(
typeset1
type2
nullptr
)
;
if
(
!
typeset1
&
&
typeset2
)
return
TypeSetIncludes
(
typeset2
type1
nullptr
)
;
return
typeset1
-
>
equals
(
typeset2
)
;
}
bool
jit
:
:
CanStoreUnboxedType
(
TempAllocator
&
alloc
JSValueType
unboxedType
MIRType
input
TypeSet
*
inputTypes
)
{
TemporaryTypeSet
types
;
switch
(
unboxedType
)
{
case
JSVAL_TYPE_BOOLEAN
:
case
JSVAL_TYPE_INT32
:
case
JSVAL_TYPE_DOUBLE
:
case
JSVAL_TYPE_STRING
:
types
.
addType
(
TypeSet
:
:
PrimitiveType
(
unboxedType
)
alloc
.
lifoAlloc
(
)
)
;
break
;
case
JSVAL_TYPE_OBJECT
:
types
.
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc
.
lifoAlloc
(
)
)
;
types
.
addType
(
TypeSet
:
:
NullType
(
)
alloc
.
lifoAlloc
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Bad
unboxed
type
"
)
;
}
return
TypeSetIncludes
(
&
types
input
inputTypes
)
;
}
static
bool
CanStoreUnboxedType
(
TempAllocator
&
alloc
JSValueType
unboxedType
MDefinition
*
value
)
{
return
CanStoreUnboxedType
(
alloc
unboxedType
value
-
>
type
(
)
value
-
>
resultTypeSet
(
)
)
;
}
bool
MPhi
:
:
specializeType
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
specialized_
)
;
specialized_
=
true
;
#
endif
MOZ_ASSERT
(
!
inputs_
.
empty
(
)
)
;
size_t
start
;
if
(
hasBackedgeType_
)
{
start
=
0
;
}
else
{
setResultType
(
getOperand
(
0
)
-
>
type
(
)
)
;
setResultTypeSet
(
getOperand
(
0
)
-
>
resultTypeSet
(
)
)
;
start
=
1
;
}
MIRType
resultType
=
this
-
>
type
(
)
;
TemporaryTypeSet
*
resultTypeSet
=
this
-
>
resultTypeSet
(
)
;
for
(
size_t
i
=
start
;
i
<
inputs_
.
length
(
)
;
i
+
+
)
{
MDefinition
*
def
=
getOperand
(
i
)
;
if
(
!
MergeTypes
(
&
resultType
&
resultTypeSet
def
-
>
type
(
)
def
-
>
resultTypeSet
(
)
)
)
return
false
;
}
setResultType
(
resultType
)
;
setResultTypeSet
(
resultTypeSet
)
;
return
true
;
}
bool
MPhi
:
:
addBackedgeType
(
MIRType
type
TemporaryTypeSet
*
typeSet
)
{
MOZ_ASSERT
(
!
specialized_
)
;
if
(
hasBackedgeType_
)
{
MIRType
resultType
=
this
-
>
type
(
)
;
TemporaryTypeSet
*
resultTypeSet
=
this
-
>
resultTypeSet
(
)
;
if
(
!
MergeTypes
(
&
resultType
&
resultTypeSet
type
typeSet
)
)
return
false
;
setResultType
(
resultType
)
;
setResultTypeSet
(
resultTypeSet
)
;
}
else
{
setResultType
(
type
)
;
setResultTypeSet
(
typeSet
)
;
hasBackedgeType_
=
true
;
}
return
true
;
}
bool
MPhi
:
:
typeIncludes
(
MDefinition
*
def
)
{
if
(
def
-
>
type
(
)
=
=
MIRType_Int32
&
&
this
-
>
type
(
)
=
=
MIRType_Double
)
return
true
;
if
(
TemporaryTypeSet
*
types
=
def
-
>
resultTypeSet
(
)
)
{
if
(
this
-
>
resultTypeSet
(
)
)
return
types
-
>
isSubset
(
this
-
>
resultTypeSet
(
)
)
;
if
(
this
-
>
type
(
)
=
=
MIRType_Value
|
|
types
-
>
empty
(
)
)
return
true
;
return
this
-
>
type
(
)
=
=
types
-
>
getKnownMIRType
(
)
;
}
if
(
def
-
>
type
(
)
=
=
MIRType_Value
)
{
return
this
-
>
type
(
)
=
=
MIRType_Value
&
&
(
!
this
-
>
resultTypeSet
(
)
|
|
this
-
>
resultTypeSet
(
)
-
>
unknown
(
)
)
;
}
return
this
-
>
mightBeType
(
def
-
>
type
(
)
)
;
}
bool
MPhi
:
:
checkForTypeChange
(
MDefinition
*
ins
bool
*
ptypeChange
)
{
MIRType
resultType
=
this
-
>
type
(
)
;
TemporaryTypeSet
*
resultTypeSet
=
this
-
>
resultTypeSet
(
)
;
if
(
!
MergeTypes
(
&
resultType
&
resultTypeSet
ins
-
>
type
(
)
ins
-
>
resultTypeSet
(
)
)
)
return
false
;
if
(
resultType
!
=
this
-
>
type
(
)
|
|
resultTypeSet
!
=
this
-
>
resultTypeSet
(
)
)
{
*
ptypeChange
=
true
;
setResultType
(
resultType
)
;
setResultTypeSet
(
resultTypeSet
)
;
}
return
true
;
}
void
MCall
:
:
addArg
(
size_t
argnum
MDefinition
*
arg
)
{
initOperand
(
argnum
+
NumNonArgumentOperands
arg
)
;
}
static
inline
bool
IsConstant
(
MDefinition
*
def
double
v
)
{
if
(
!
def
-
>
isConstant
(
)
)
return
false
;
return
NumbersAreIdentical
(
def
-
>
toConstant
(
)
-
>
toNumber
(
)
v
)
;
}
MDefinition
*
MBinaryBitwiseInstruction
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
specialization_
!
=
MIRType_Int32
)
return
this
;
if
(
MDefinition
*
folded
=
EvaluateConstantOperands
(
alloc
this
)
)
return
folded
;
return
this
;
}
MDefinition
*
MBinaryBitwiseInstruction
:
:
foldUnnecessaryBitop
(
)
{
if
(
specialization_
!
=
MIRType_Int32
)
return
this
;
MDefinition
*
lhs
=
getOperand
(
0
)
;
MDefinition
*
rhs
=
getOperand
(
1
)
;
if
(
IsConstant
(
lhs
0
)
)
return
foldIfZero
(
0
)
;
if
(
IsConstant
(
rhs
0
)
)
return
foldIfZero
(
1
)
;
if
(
IsConstant
(
lhs
-
1
)
)
return
foldIfNegOne
(
0
)
;
if
(
IsConstant
(
rhs
-
1
)
)
return
foldIfNegOne
(
1
)
;
if
(
lhs
=
=
rhs
)
return
foldIfEqual
(
)
;
if
(
maskMatchesRightRange
)
{
MOZ_ASSERT
(
lhs
-
>
isConstant
(
)
)
;
MOZ_ASSERT
(
lhs
-
>
type
(
)
=
=
MIRType_Int32
)
;
return
foldIfAllBitsSet
(
0
)
;
}
if
(
maskMatchesLeftRange
)
{
MOZ_ASSERT
(
rhs
-
>
isConstant
(
)
)
;
MOZ_ASSERT
(
rhs
-
>
type
(
)
=
=
MIRType_Int32
)
;
return
foldIfAllBitsSet
(
1
)
;
}
return
this
;
}
void
MBinaryBitwiseInstruction
:
:
infer
(
BaselineInspector
*
jsbytecode
*
)
{
if
(
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Symbol
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Symbol
)
)
{
specialization_
=
MIRType_None
;
}
else
{
specializeAsInt32
(
)
;
}
}
void
MBinaryBitwiseInstruction
:
:
specializeAsInt32
(
)
{
specialization_
=
MIRType_Int32
;
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Int32
)
;
if
(
isBitOr
(
)
|
|
isBitAnd
(
)
|
|
isBitXor
(
)
)
setCommutative
(
)
;
}
void
MShiftInstruction
:
:
infer
(
BaselineInspector
*
jsbytecode
*
)
{
if
(
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Symbol
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Symbol
)
)
specialization_
=
MIRType_None
;
else
specialization_
=
MIRType_Int32
;
}
void
MUrsh
:
:
infer
(
BaselineInspector
*
inspector
jsbytecode
*
pc
)
{
if
(
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Object
)
|
|
getOperand
(
0
)
-
>
mightBeType
(
MIRType_Symbol
)
|
|
getOperand
(
1
)
-
>
mightBeType
(
MIRType_Symbol
)
)
{
specialization_
=
MIRType_None
;
setResultType
(
MIRType_Value
)
;
return
;
}
if
(
inspector
-
>
hasSeenDoubleResult
(
pc
)
)
{
specialization_
=
MIRType_Double
;
setResultType
(
MIRType_Double
)
;
return
;
}
specialization_
=
MIRType_Int32
;
setResultType
(
MIRType_Int32
)
;
}
static
inline
bool
CanProduceNegativeZero
(
MDefinition
*
def
)
{
switch
(
def
-
>
op
(
)
)
{
case
MDefinition
:
:
Op_Constant
:
if
(
def
-
>
type
(
)
=
=
MIRType_Double
&
&
def
-
>
toConstant
(
)
-
>
toDouble
(
)
=
=
-
0
.
0
)
return
true
;
MOZ_FALLTHROUGH
;
case
MDefinition
:
:
Op_BitAnd
:
case
MDefinition
:
:
Op_BitOr
:
case
MDefinition
:
:
Op_BitXor
:
case
MDefinition
:
:
Op_BitNot
:
case
MDefinition
:
:
Op_Lsh
:
case
MDefinition
:
:
Op_Rsh
:
return
false
;
default
:
return
true
;
}
}
static
inline
bool
NeedNegativeZeroCheck
(
MDefinition
*
def
)
{
for
(
MUseIterator
use
=
def
-
>
usesBegin
(
)
;
use
!
=
def
-
>
usesEnd
(
)
;
use
+
+
)
{
if
(
use
-
>
consumer
(
)
-
>
isResumePoint
(
)
)
continue
;
MDefinition
*
use_def
=
use
-
>
consumer
(
)
-
>
toDefinition
(
)
;
switch
(
use_def
-
>
op
(
)
)
{
case
MDefinition
:
:
Op_Add
:
{
if
(
use_def
-
>
toAdd
(
)
-
>
isTruncated
(
)
)
break
;
MDefinition
*
first
=
use_def
-
>
toAdd
(
)
-
>
lhs
(
)
;
MDefinition
*
second
=
use_def
-
>
toAdd
(
)
-
>
rhs
(
)
;
if
(
first
-
>
id
(
)
>
second
-
>
id
(
)
)
{
MDefinition
*
temp
=
first
;
first
=
second
;
second
=
temp
;
}
if
(
def
=
=
first
&
&
CanProduceNegativeZero
(
second
)
)
return
true
;
break
;
}
case
MDefinition
:
:
Op_Sub
:
{
if
(
use_def
-
>
toSub
(
)
-
>
isTruncated
(
)
)
break
;
MDefinition
*
lhs
=
use_def
-
>
toSub
(
)
-
>
lhs
(
)
;
MDefinition
*
rhs
=
use_def
-
>
toSub
(
)
-
>
rhs
(
)
;
if
(
rhs
-
>
id
(
)
<
lhs
-
>
id
(
)
&
&
CanProduceNegativeZero
(
lhs
)
)
return
true
;
MOZ_FALLTHROUGH
;
}
case
MDefinition
:
:
Op_StoreElement
:
case
MDefinition
:
:
Op_StoreElementHole
:
case
MDefinition
:
:
Op_LoadElement
:
case
MDefinition
:
:
Op_LoadElementHole
:
case
MDefinition
:
:
Op_LoadUnboxedScalar
:
case
MDefinition
:
:
Op_LoadTypedArrayElementHole
:
case
MDefinition
:
:
Op_CharCodeAt
:
case
MDefinition
:
:
Op_Mod
:
if
(
use_def
-
>
getOperand
(
0
)
=
=
def
)
return
true
;
for
(
size_t
i
=
2
e
=
use_def
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
if
(
use_def
-
>
getOperand
(
i
)
=
=
def
)
return
true
;
}
break
;
case
MDefinition
:
:
Op_BoundsCheck
:
if
(
use_def
-
>
toBoundsCheck
(
)
-
>
getOperand
(
1
)
=
=
def
)
return
true
;
break
;
case
MDefinition
:
:
Op_ToString
:
case
MDefinition
:
:
Op_FromCharCode
:
case
MDefinition
:
:
Op_TableSwitch
:
case
MDefinition
:
:
Op_Compare
:
case
MDefinition
:
:
Op_BitAnd
:
case
MDefinition
:
:
Op_BitOr
:
case
MDefinition
:
:
Op_BitXor
:
case
MDefinition
:
:
Op_Abs
:
case
MDefinition
:
:
Op_TruncateToInt32
:
break
;
default
:
return
true
;
}
}
return
false
;
}
MBinaryArithInstruction
*
MBinaryArithInstruction
:
:
New
(
TempAllocator
&
alloc
Opcode
op
MDefinition
*
left
MDefinition
*
right
)
{
switch
(
op
)
{
case
Op_Add
:
return
MAdd
:
:
New
(
alloc
left
right
)
;
case
Op_Sub
:
return
MSub
:
:
New
(
alloc
left
right
)
;
case
Op_Mul
:
return
MMul
:
:
New
(
alloc
left
right
)
;
case
Op_Div
:
return
MDiv
:
:
New
(
alloc
left
right
)
;
case
Op_Mod
:
return
MMod
:
:
New
(
alloc
left
right
)
;
default
:
MOZ_CRASH
(
"
unexpected
binary
opcode
"
)
;
}
}
void
MBinaryArithInstruction
:
:
setNumberSpecialization
(
TempAllocator
&
alloc
BaselineInspector
*
inspector
jsbytecode
*
pc
)
{
setSpecialization
(
MIRType_Double
)
;
if
(
getOperand
(
0
)
-
>
type
(
)
=
=
MIRType_Int32
&
&
getOperand
(
1
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
bool
seenDouble
=
inspector
-
>
hasSeenDoubleResult
(
pc
)
;
if
(
!
seenDouble
&
&
!
constantDoubleResult
(
alloc
)
)
setInt32Specialization
(
)
;
}
}
bool
MBinaryArithInstruction
:
:
constantDoubleResult
(
TempAllocator
&
alloc
)
{
bool
typeChange
=
false
;
EvaluateConstantOperands
(
alloc
this
&
typeChange
)
;
return
typeChange
;
}
MDefinition
*
MBinaryArithInstruction
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
specialization_
=
=
MIRType_None
)
return
this
;
MDefinition
*
lhs
=
getOperand
(
0
)
;
MDefinition
*
rhs
=
getOperand
(
1
)
;
if
(
MConstant
*
folded
=
EvaluateConstantOperands
(
alloc
this
)
)
{
if
(
isTruncated
(
)
)
{
if
(
!
folded
-
>
block
(
)
)
block
(
)
-
>
insertBefore
(
this
folded
)
;
return
MTruncateToInt32
:
:
New
(
alloc
folded
)
;
}
return
folded
;
}
if
(
isAdd
(
)
&
&
specialization_
!
=
MIRType_Int32
)
return
this
;
if
(
IsConstant
(
rhs
getIdentity
(
)
)
)
{
if
(
isTruncated
(
)
)
return
MTruncateToInt32
:
:
New
(
alloc
lhs
)
;
return
lhs
;
}
if
(
isSub
(
)
)
return
this
;
if
(
IsConstant
(
lhs
getIdentity
(
)
)
)
{
if
(
isTruncated
(
)
)
return
MTruncateToInt32
:
:
New
(
alloc
rhs
)
;
return
rhs
;
}
return
this
;
}
void
MFilterTypeSet
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MDefinition
*
in
=
input
(
)
;
if
(
in
-
>
type
(
)
!
=
MIRType_Float32
)
return
;
setResultType
(
MIRType_Float32
)
;
}
bool
MFilterTypeSet
:
:
canProduceFloat32
(
)
const
{
return
!
input
(
)
-
>
isPhi
(
)
&
&
input
(
)
-
>
canProduceFloat32
(
)
;
}
bool
MFilterTypeSet
:
:
canConsumeFloat32
(
MUse
*
operand
)
const
{
MOZ_ASSERT
(
getUseFor
(
0
)
=
=
operand
)
;
bool
allConsumerUses
=
true
;
for
(
MUseDefIterator
use
(
this
)
;
allConsumerUses
&
&
use
;
use
+
+
)
allConsumerUses
&
=
!
use
.
def
(
)
-
>
isPhi
(
)
&
&
use
.
def
(
)
-
>
canConsumeFloat32
(
use
.
use
(
)
)
;
return
allConsumerUses
;
}
void
MBinaryArithInstruction
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
if
(
specialization_
=
=
MIRType_Int32
)
return
;
if
(
specialization_
=
=
MIRType_None
)
return
;
MDefinition
*
left
=
lhs
(
)
;
MDefinition
*
right
=
rhs
(
)
;
if
(
!
left
-
>
canProduceFloat32
(
)
|
|
!
right
-
>
canProduceFloat32
(
)
|
|
!
CheckUsesAreFloat32Consumers
(
this
)
)
{
if
(
left
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
left
this
)
;
if
(
right
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
1
>
(
alloc
right
this
)
;
return
;
}
specialization_
=
MIRType_Float32
;
setResultType
(
MIRType_Float32
)
;
}
void
MMinMax
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
if
(
specialization_
=
=
MIRType_Int32
)
return
;
MDefinition
*
left
=
lhs
(
)
;
MDefinition
*
right
=
rhs
(
)
;
if
(
!
(
left
-
>
canProduceFloat32
(
)
|
|
(
left
-
>
isMinMax
(
)
&
&
left
-
>
type
(
)
=
=
MIRType_Float32
)
)
|
|
!
(
right
-
>
canProduceFloat32
(
)
|
|
(
right
-
>
isMinMax
(
)
&
&
right
-
>
type
(
)
=
=
MIRType_Float32
)
)
)
{
if
(
left
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
left
this
)
;
if
(
right
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
1
>
(
alloc
right
this
)
;
return
;
}
specialization_
=
MIRType_Float32
;
setResultType
(
MIRType_Float32
)
;
}
MDefinition
*
MMinMax
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
lhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
isConstant
(
)
)
return
this
;
if
(
lhs
(
)
-
>
isConstant
(
)
&
&
rhs
(
)
-
>
isConstant
(
)
)
{
if
(
!
lhs
(
)
-
>
toConstant
(
)
-
>
isNumber
(
)
|
|
!
rhs
(
)
-
>
toConstant
(
)
-
>
isNumber
(
)
)
return
this
;
double
lnum
=
lhs
(
)
-
>
toConstant
(
)
-
>
toNumber
(
)
;
double
rnum
=
rhs
(
)
-
>
toConstant
(
)
-
>
toNumber
(
)
;
double
result
;
if
(
isMax
(
)
)
result
=
js
:
:
math_max_impl
(
lnum
rnum
)
;
else
result
=
js
:
:
math_min_impl
(
lnum
rnum
)
;
if
(
type
(
)
=
=
MIRType_Int32
)
{
int32_t
cast
;
if
(
mozilla
:
:
NumberEqualsInt32
(
result
&
cast
)
)
return
MConstant
:
:
New
(
alloc
Int32Value
(
cast
)
)
;
}
else
if
(
type
(
)
=
=
MIRType_Float32
)
{
return
MConstant
:
:
NewFloat32
(
alloc
result
)
;
}
else
{
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Double
)
;
return
MConstant
:
:
New
(
alloc
DoubleValue
(
result
)
)
;
}
}
MDefinition
*
operand
=
lhs
(
)
-
>
isConstant
(
)
?
rhs
(
)
:
lhs
(
)
;
MConstant
*
constant
=
lhs
(
)
-
>
isConstant
(
)
?
lhs
(
)
-
>
toConstant
(
)
:
rhs
(
)
-
>
toConstant
(
)
;
if
(
operand
-
>
isToDouble
(
)
&
&
operand
-
>
getOperand
(
0
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
if
(
constant
-
>
isNumber
(
)
&
&
constant
-
>
toNumber
(
)
>
=
INT32_MAX
&
&
!
isMax
(
)
)
{
MLimitedTruncate
*
limit
=
MLimitedTruncate
:
:
New
(
alloc
operand
-
>
getOperand
(
0
)
MDefinition
:
:
NoTruncate
)
;
block
(
)
-
>
insertBefore
(
this
limit
)
;
MToDouble
*
toDouble
=
MToDouble
:
:
New
(
alloc
limit
)
;
return
toDouble
;
}
if
(
constant
-
>
isNumber
(
)
&
&
constant
-
>
toNumber
(
)
<
=
INT32_MIN
&
&
isMax
(
)
)
{
MLimitedTruncate
*
limit
=
MLimitedTruncate
:
:
New
(
alloc
operand
-
>
getOperand
(
0
)
MDefinition
:
:
NoTruncate
)
;
block
(
)
-
>
insertBefore
(
this
limit
)
;
MToDouble
*
toDouble
=
MToDouble
:
:
New
(
alloc
limit
)
;
return
toDouble
;
}
}
return
this
;
}
bool
MAbs
:
:
fallible
(
)
const
{
return
!
implicitTruncate_
&
&
(
!
range
(
)
|
|
!
range
(
)
-
>
hasInt32Bounds
(
)
)
;
}
void
MAbs
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
return
;
if
(
!
input
(
)
-
>
canProduceFloat32
(
)
|
|
!
CheckUsesAreFloat32Consumers
(
this
)
)
{
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
input
(
)
this
)
;
return
;
}
setResultType
(
MIRType_Float32
)
;
specialization_
=
MIRType_Float32
;
}
MDefinition
*
MDiv
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
specialization_
=
=
MIRType_None
)
return
this
;
if
(
MDefinition
*
folded
=
EvaluateConstantOperands
(
alloc
this
)
)
return
folded
;
if
(
MDefinition
*
folded
=
EvaluateExactReciprocal
(
alloc
this
)
)
return
folded
;
return
this
;
}
void
MDiv
:
:
analyzeEdgeCasesForward
(
)
{
if
(
specialization_
!
=
MIRType_Int32
)
return
;
MOZ_ASSERT
(
lhs
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
;
MOZ_ASSERT
(
rhs
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
;
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
toConstant
(
)
-
>
isInt32
(
0
)
)
canBeDivideByZero_
=
false
;
if
(
lhs
(
)
-
>
isConstant
(
)
&
&
!
lhs
(
)
-
>
toConstant
(
)
-
>
isInt32
(
INT32_MIN
)
)
canBeNegativeOverflow_
=
false
;
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
toConstant
(
)
-
>
isInt32
(
-
1
)
)
canBeNegativeOverflow_
=
false
;
if
(
lhs
(
)
-
>
isConstant
(
)
&
&
!
lhs
(
)
-
>
toConstant
(
)
-
>
isInt32
(
0
)
)
setCanBeNegativeZero
(
false
)
;
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
rhs
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
if
(
rhs
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
>
=
0
)
setCanBeNegativeZero
(
false
)
;
}
}
void
MDiv
:
:
analyzeEdgeCasesBackward
(
)
{
if
(
canBeNegativeZero
(
)
&
&
!
NeedNegativeZeroCheck
(
this
)
)
setCanBeNegativeZero
(
false
)
;
}
bool
MDiv
:
:
fallible
(
)
const
{
return
!
isTruncated
(
)
;
}
MDefinition
*
MMod
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
specialization_
=
=
MIRType_None
)
return
this
;
if
(
MDefinition
*
folded
=
EvaluateConstantOperands
(
alloc
this
)
)
return
folded
;
return
this
;
}
void
MMod
:
:
analyzeEdgeCasesForward
(
)
{
if
(
specialization_
!
=
MIRType_Int32
)
return
;
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
toConstant
(
)
-
>
isInt32
(
0
)
)
canBeDivideByZero_
=
false
;
if
(
rhs
(
)
-
>
isConstant
(
)
)
{
int32_t
n
=
rhs
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
if
(
n
>
0
&
&
!
IsPowerOfTwo
(
n
)
)
canBePowerOfTwoDivisor_
=
false
;
}
}
bool
MMod
:
:
fallible
(
)
const
{
return
!
isTruncated
(
)
&
&
(
isUnsigned
(
)
|
|
canBeDivideByZero
(
)
|
|
canBeNegativeDividend
(
)
)
;
}
void
MMathFunction
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
if
(
!
input
(
)
-
>
canProduceFloat32
(
)
|
|
!
CheckUsesAreFloat32Consumers
(
this
)
)
{
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
input
(
)
this
)
;
return
;
}
setResultType
(
MIRType_Float32
)
;
specialization_
=
MIRType_Float32
;
}
MHypot
*
MHypot
:
:
New
(
TempAllocator
&
alloc
const
MDefinitionVector
&
vector
)
{
uint32_t
length
=
vector
.
length
(
)
;
MHypot
*
hypot
=
new
(
alloc
)
MHypot
;
if
(
!
hypot
-
>
init
(
alloc
length
)
)
return
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
hypot
-
>
initOperand
(
i
vector
[
i
]
)
;
return
hypot
;
}
bool
MAdd
:
:
fallible
(
)
const
{
if
(
truncateKind
(
)
>
=
IndirectTruncate
)
return
false
;
if
(
range
(
)
&
&
range
(
)
-
>
hasInt32Bounds
(
)
)
return
false
;
return
true
;
}
bool
MSub
:
:
fallible
(
)
const
{
if
(
truncateKind
(
)
>
=
IndirectTruncate
)
return
false
;
if
(
range
(
)
&
&
range
(
)
-
>
hasInt32Bounds
(
)
)
return
false
;
return
true
;
}
MDefinition
*
MMul
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
out
=
MBinaryArithInstruction
:
:
foldsTo
(
alloc
)
;
if
(
out
!
=
this
)
return
out
;
if
(
specialization
(
)
!
=
MIRType_Int32
)
return
this
;
if
(
lhs
(
)
=
=
rhs
(
)
)
setCanBeNegativeZero
(
false
)
;
return
this
;
}
void
MMul
:
:
analyzeEdgeCasesForward
(
)
{
if
(
specialization
(
)
!
=
MIRType_Int32
)
return
;
if
(
lhs
(
)
-
>
isConstant
(
)
&
&
lhs
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
if
(
lhs
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
>
0
)
setCanBeNegativeZero
(
false
)
;
}
if
(
rhs
(
)
-
>
isConstant
(
)
&
&
rhs
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
if
(
rhs
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
>
0
)
setCanBeNegativeZero
(
false
)
;
}
}
void
MMul
:
:
analyzeEdgeCasesBackward
(
)
{
if
(
canBeNegativeZero
(
)
&
&
!
NeedNegativeZeroCheck
(
this
)
)
setCanBeNegativeZero
(
false
)
;
}
bool
MMul
:
:
updateForReplacement
(
MDefinition
*
ins_
)
{
MMul
*
ins
=
ins_
-
>
toMul
(
)
;
bool
negativeZero
=
canBeNegativeZero
(
)
|
|
ins
-
>
canBeNegativeZero
(
)
;
setCanBeNegativeZero
(
negativeZero
)
;
if
(
mode_
=
=
Integer
&
&
ins
-
>
mode
(
)
!
=
Integer
)
mode_
=
Normal
;
return
true
;
}
bool
MMul
:
:
canOverflow
(
)
const
{
if
(
isTruncated
(
)
)
return
false
;
return
!
range
(
)
|
|
!
range
(
)
-
>
hasInt32Bounds
(
)
;
}
bool
MUrsh
:
:
fallible
(
)
const
{
if
(
bailoutsDisabled
(
)
)
return
false
;
return
!
range
(
)
|
|
!
range
(
)
-
>
hasInt32Bounds
(
)
;
}
static
inline
bool
SimpleArithOperand
(
MDefinition
*
op
)
{
return
!
op
-
>
mightBeType
(
MIRType_Object
)
&
&
!
op
-
>
mightBeType
(
MIRType_String
)
&
&
!
op
-
>
mightBeType
(
MIRType_Symbol
)
&
&
!
op
-
>
mightBeType
(
MIRType_MagicOptimizedArguments
)
&
&
!
op
-
>
mightBeType
(
MIRType_MagicHole
)
&
&
!
op
-
>
mightBeType
(
MIRType_MagicIsConstructing
)
;
}
static
bool
SafelyCoercesToDouble
(
MDefinition
*
op
)
{
return
SimpleArithOperand
(
op
)
&
&
!
op
-
>
mightBeType
(
MIRType_Null
)
;
}
MIRType
MCompare
:
:
inputType
(
)
{
switch
(
compareType_
)
{
case
Compare_Undefined
:
return
MIRType_Undefined
;
case
Compare_Null
:
return
MIRType_Null
;
case
Compare_Boolean
:
return
MIRType_Boolean
;
case
Compare_UInt32
:
case
Compare_Int32
:
case
Compare_Int32MaybeCoerceBoth
:
case
Compare_Int32MaybeCoerceLHS
:
case
Compare_Int32MaybeCoerceRHS
:
return
MIRType_Int32
;
case
Compare_Double
:
case
Compare_DoubleMaybeCoerceLHS
:
case
Compare_DoubleMaybeCoerceRHS
:
return
MIRType_Double
;
case
Compare_Float32
:
return
MIRType_Float32
;
case
Compare_String
:
case
Compare_StrictString
:
return
MIRType_String
;
case
Compare_Object
:
return
MIRType_Object
;
case
Compare_Unknown
:
case
Compare_Bitwise
:
return
MIRType_Value
;
default
:
MOZ_CRASH
(
"
No
known
conversion
"
)
;
}
}
static
inline
bool
MustBeUInt32
(
MDefinition
*
def
MDefinition
*
*
pwrapped
)
{
if
(
def
-
>
isUrsh
(
)
)
{
*
pwrapped
=
def
-
>
toUrsh
(
)
-
>
lhs
(
)
;
MDefinition
*
rhs
=
def
-
>
toUrsh
(
)
-
>
rhs
(
)
;
return
!
def
-
>
toUrsh
(
)
-
>
bailoutsDisabled
(
)
&
&
rhs
-
>
maybeConstantValue
(
)
&
&
rhs
-
>
maybeConstantValue
(
)
-
>
isInt32
(
0
)
;
}
if
(
MConstant
*
defConst
=
def
-
>
maybeConstantValue
(
)
)
{
*
pwrapped
=
defConst
;
return
defConst
-
>
type
(
)
=
=
MIRType_Int32
&
&
defConst
-
>
toInt32
(
)
>
=
0
;
}
return
false
;
}
bool
MBinaryInstruction
:
:
unsignedOperands
(
MDefinition
*
left
MDefinition
*
right
)
{
MDefinition
*
replace
;
if
(
!
MustBeUInt32
(
left
&
replace
)
)
return
false
;
if
(
replace
-
>
type
(
)
!
=
MIRType_Int32
)
return
false
;
if
(
!
MustBeUInt32
(
right
&
replace
)
)
return
false
;
if
(
replace
-
>
type
(
)
!
=
MIRType_Int32
)
return
false
;
return
true
;
}
bool
MBinaryInstruction
:
:
unsignedOperands
(
)
{
return
unsignedOperands
(
getOperand
(
0
)
getOperand
(
1
)
)
;
}
void
MBinaryInstruction
:
:
replaceWithUnsignedOperands
(
)
{
MOZ_ASSERT
(
unsignedOperands
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numOperands
(
)
;
i
+
+
)
{
MDefinition
*
replace
;
MustBeUInt32
(
getOperand
(
i
)
&
replace
)
;
if
(
replace
=
=
getOperand
(
i
)
)
continue
;
getOperand
(
i
)
-
>
setImplicitlyUsedUnchecked
(
)
;
replaceOperand
(
i
replace
)
;
}
}
MCompare
:
:
CompareType
MCompare
:
:
determineCompareType
(
JSOp
op
MDefinition
*
left
MDefinition
*
right
)
{
MIRType
lhs
=
left
-
>
type
(
)
;
MIRType
rhs
=
right
-
>
type
(
)
;
bool
looseEq
=
op
=
=
JSOP_EQ
|
|
op
=
=
JSOP_NE
;
bool
strictEq
=
op
=
=
JSOP_STRICTEQ
|
|
op
=
=
JSOP_STRICTNE
;
bool
relationalEq
=
!
(
looseEq
|
|
strictEq
)
;
if
(
unsignedOperands
(
left
right
)
)
return
Compare_UInt32
;
if
(
(
lhs
=
=
MIRType_Int32
&
&
rhs
=
=
MIRType_Int32
)
|
|
(
lhs
=
=
MIRType_Boolean
&
&
rhs
=
=
MIRType_Boolean
)
)
{
return
Compare_Int32MaybeCoerceBoth
;
}
if
(
!
strictEq
&
&
(
lhs
=
=
MIRType_Int32
|
|
lhs
=
=
MIRType_Boolean
)
&
&
(
rhs
=
=
MIRType_Int32
|
|
rhs
=
=
MIRType_Boolean
)
)
{
return
Compare_Int32MaybeCoerceBoth
;
}
if
(
IsNumberType
(
lhs
)
&
&
IsNumberType
(
rhs
)
)
return
Compare_Double
;
if
(
!
strictEq
&
&
IsFloatingPointType
(
rhs
)
&
&
SafelyCoercesToDouble
(
left
)
)
return
Compare_DoubleMaybeCoerceLHS
;
if
(
!
strictEq
&
&
IsFloatingPointType
(
lhs
)
&
&
SafelyCoercesToDouble
(
right
)
)
return
Compare_DoubleMaybeCoerceRHS
;
if
(
!
relationalEq
&
&
lhs
=
=
MIRType_Object
&
&
rhs
=
=
MIRType_Object
)
return
Compare_Object
;
if
(
!
relationalEq
&
&
lhs
=
=
MIRType_String
&
&
rhs
=
=
MIRType_String
)
return
Compare_String
;
if
(
strictEq
&
&
lhs
=
=
MIRType_String
)
return
Compare_StrictString
;
if
(
strictEq
&
&
rhs
=
=
MIRType_String
)
return
Compare_StrictString
;
if
(
!
relationalEq
&
&
IsNullOrUndefined
(
lhs
)
)
return
(
lhs
=
=
MIRType_Null
)
?
Compare_Null
:
Compare_Undefined
;
if
(
!
relationalEq
&
&
IsNullOrUndefined
(
rhs
)
)
return
(
rhs
=
=
MIRType_Null
)
?
Compare_Null
:
Compare_Undefined
;
if
(
strictEq
&
&
(
lhs
=
=
MIRType_Boolean
|
|
rhs
=
=
MIRType_Boolean
)
)
{
MOZ_ASSERT
(
!
(
lhs
=
=
MIRType_Boolean
&
&
rhs
=
=
MIRType_Boolean
)
)
;
return
Compare_Boolean
;
}
return
Compare_Unknown
;
}
void
MCompare
:
:
cacheOperandMightEmulateUndefined
(
CompilerConstraintList
*
constraints
)
{
MOZ_ASSERT
(
operandMightEmulateUndefined
(
)
)
;
if
(
getOperand
(
0
)
-
>
maybeEmulatesUndefined
(
constraints
)
)
return
;
if
(
getOperand
(
1
)
-
>
maybeEmulatesUndefined
(
constraints
)
)
return
;
markNoOperandEmulatesUndefined
(
)
;
}
MBitNot
*
MBitNot
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
input
)
{
return
new
(
alloc
)
MBitNot
(
input
)
;
}
MBitNot
*
MBitNot
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
input
)
{
MBitNot
*
ins
=
new
(
alloc
)
MBitNot
(
input
)
;
ins
-
>
specialization_
=
MIRType_Int32
;
MOZ_ASSERT
(
ins
-
>
type
(
)
=
=
MIRType_Int32
)
;
return
ins
;
}
MDefinition
*
MBitNot
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
specialization_
!
=
MIRType_Int32
)
return
this
;
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
input
-
>
isConstant
(
)
)
{
js
:
:
Value
v
=
Int32Value
(
~
(
input
-
>
toConstant
(
)
-
>
toInt32
(
)
)
)
;
return
MConstant
:
:
New
(
alloc
v
)
;
}
if
(
input
-
>
isBitNot
(
)
&
&
input
-
>
toBitNot
(
)
-
>
specialization_
=
=
MIRType_Int32
)
{
MOZ_ASSERT
(
input
-
>
toBitNot
(
)
-
>
getOperand
(
0
)
-
>
type
(
)
=
=
MIRType_Int32
)
;
return
MTruncateToInt32
:
:
New
(
alloc
input
-
>
toBitNot
(
)
-
>
input
(
)
)
;
}
return
this
;
}
MDefinition
*
MTypeOf
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MOZ_ASSERT
(
input
(
)
-
>
type
(
)
=
=
MIRType_Value
)
;
JSType
type
;
switch
(
inputType
(
)
)
{
case
MIRType_Double
:
case
MIRType_Float32
:
case
MIRType_Int32
:
type
=
JSTYPE_NUMBER
;
break
;
case
MIRType_String
:
type
=
JSTYPE_STRING
;
break
;
case
MIRType_Symbol
:
type
=
JSTYPE_SYMBOL
;
break
;
case
MIRType_Null
:
type
=
JSTYPE_OBJECT
;
break
;
case
MIRType_Undefined
:
type
=
JSTYPE_VOID
;
break
;
case
MIRType_Boolean
:
type
=
JSTYPE_BOOLEAN
;
break
;
case
MIRType_Object
:
if
(
!
inputMaybeCallableOrEmulatesUndefined
(
)
)
{
type
=
JSTYPE_OBJECT
;
break
;
}
MOZ_FALLTHROUGH
;
default
:
return
this
;
}
return
MConstant
:
:
New
(
alloc
StringValue
(
TypeName
(
type
GetJitContext
(
)
-
>
runtime
-
>
names
(
)
)
)
)
;
}
void
MTypeOf
:
:
cacheInputMaybeCallableOrEmulatesUndefined
(
CompilerConstraintList
*
constraints
)
{
MOZ_ASSERT
(
inputMaybeCallableOrEmulatesUndefined
(
)
)
;
if
(
!
input
(
)
-
>
maybeEmulatesUndefined
(
constraints
)
&
&
!
MaybeCallable
(
constraints
input
(
)
)
)
markInputNotCallableOrEmulatesUndefined
(
)
;
}
MBitAnd
*
MBitAnd
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MBitAnd
(
left
right
)
;
}
MBitAnd
*
MBitAnd
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MBitAnd
*
ins
=
new
(
alloc
)
MBitAnd
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
return
ins
;
}
MBitOr
*
MBitOr
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MBitOr
(
left
right
)
;
}
MBitOr
*
MBitOr
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MBitOr
*
ins
=
new
(
alloc
)
MBitOr
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
return
ins
;
}
MBitXor
*
MBitXor
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MBitXor
(
left
right
)
;
}
MBitXor
*
MBitXor
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MBitXor
*
ins
=
new
(
alloc
)
MBitXor
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
return
ins
;
}
MLsh
*
MLsh
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MLsh
(
left
right
)
;
}
MLsh
*
MLsh
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MLsh
*
ins
=
new
(
alloc
)
MLsh
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
return
ins
;
}
MRsh
*
MRsh
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MRsh
(
left
right
)
;
}
MRsh
*
MRsh
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MRsh
*
ins
=
new
(
alloc
)
MRsh
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
return
ins
;
}
MUrsh
*
MUrsh
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
return
new
(
alloc
)
MUrsh
(
left
right
)
;
}
MUrsh
*
MUrsh
:
:
NewAsmJS
(
TempAllocator
&
alloc
MDefinition
*
left
MDefinition
*
right
)
{
MUrsh
*
ins
=
new
(
alloc
)
MUrsh
(
left
right
)
;
ins
-
>
specializeAsInt32
(
)
;
ins
-
>
bailoutsDisabled_
=
true
;
return
ins
;
}
MResumePoint
*
MResumePoint
:
:
New
(
TempAllocator
&
alloc
MBasicBlock
*
block
jsbytecode
*
pc
Mode
mode
)
{
MResumePoint
*
resume
=
new
(
alloc
)
MResumePoint
(
block
pc
mode
)
;
if
(
!
resume
-
>
init
(
alloc
)
)
return
nullptr
;
resume
-
>
inherit
(
block
)
;
return
resume
;
}
MResumePoint
*
MResumePoint
:
:
New
(
TempAllocator
&
alloc
MBasicBlock
*
block
MResumePoint
*
model
const
MDefinitionVector
&
operands
)
{
MResumePoint
*
resume
=
new
(
alloc
)
MResumePoint
(
block
model
-
>
pc
(
)
model
-
>
mode
(
)
)
;
if
(
!
resume
-
>
operands_
.
init
(
alloc
model
-
>
numAllocatedOperands
(
)
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
operands
.
length
(
)
;
i
+
+
)
resume
-
>
initOperand
(
i
operands
[
i
]
)
;
return
resume
;
}
MResumePoint
*
MResumePoint
:
:
Copy
(
TempAllocator
&
alloc
MResumePoint
*
src
)
{
MResumePoint
*
resume
=
new
(
alloc
)
MResumePoint
(
src
-
>
block
(
)
src
-
>
pc
(
)
src
-
>
mode
(
)
)
;
if
(
!
resume
-
>
operands_
.
init
(
alloc
src
-
>
numAllocatedOperands
(
)
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
resume
-
>
numOperands
(
)
;
i
+
+
)
resume
-
>
initOperand
(
i
src
-
>
getOperand
(
i
)
)
;
return
resume
;
}
MResumePoint
:
:
MResumePoint
(
MBasicBlock
*
block
jsbytecode
*
pc
Mode
mode
)
:
MNode
(
block
)
pc_
(
pc
)
instruction_
(
nullptr
)
mode_
(
mode
)
{
block
-
>
addResumePoint
(
this
)
;
}
bool
MResumePoint
:
:
init
(
TempAllocator
&
alloc
)
{
return
operands_
.
init
(
alloc
block
(
)
-
>
stackDepth
(
)
)
;
}
MResumePoint
*
MResumePoint
:
:
caller
(
)
const
{
return
block_
-
>
callerResumePoint
(
)
;
}
void
MResumePoint
:
:
inherit
(
MBasicBlock
*
block
)
{
for
(
size_t
i
=
0
;
i
<
stackDepth
(
)
;
i
+
+
)
initOperand
(
i
block
-
>
getSlot
(
i
)
)
;
}
void
MResumePoint
:
:
addStore
(
TempAllocator
&
alloc
MDefinition
*
store
const
MResumePoint
*
cache
)
{
MOZ_ASSERT
(
block
(
)
-
>
outerResumePoint
(
)
!
=
this
)
;
MOZ_ASSERT_IF
(
cache
!
cache
-
>
stores_
.
empty
(
)
)
;
if
(
cache
&
&
cache
-
>
stores_
.
begin
(
)
-
>
operand
=
=
store
)
{
if
(
+
+
cache
-
>
stores_
.
begin
(
)
=
=
stores_
.
begin
(
)
)
{
stores_
.
copy
(
cache
-
>
stores_
)
;
return
;
}
}
MOZ_ASSERT
(
store
-
>
isEffectful
(
)
)
;
MStoreToRecover
*
top
=
new
(
alloc
)
MStoreToRecover
(
store
)
;
stores_
.
push
(
top
)
;
}
void
MResumePoint
:
:
dump
(
GenericPrinter
&
out
)
const
{
out
.
printf
(
"
resumepoint
mode
=
"
)
;
switch
(
mode
(
)
)
{
case
MResumePoint
:
:
ResumeAt
:
out
.
printf
(
"
At
"
)
;
break
;
case
MResumePoint
:
:
ResumeAfter
:
out
.
printf
(
"
After
"
)
;
break
;
case
MResumePoint
:
:
Outer
:
out
.
printf
(
"
Outer
"
)
;
break
;
}
if
(
MResumePoint
*
c
=
caller
(
)
)
out
.
printf
(
"
(
caller
in
block
%
u
)
"
c
-
>
block
(
)
-
>
id
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numOperands
(
)
;
i
+
+
)
{
out
.
printf
(
"
"
)
;
if
(
operands_
[
i
]
.
hasProducer
(
)
)
getOperand
(
i
)
-
>
printName
(
out
)
;
else
out
.
printf
(
"
(
null
)
"
)
;
}
out
.
printf
(
"
\
n
"
)
;
}
void
MResumePoint
:
:
dump
(
)
const
{
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
out
.
finish
(
)
;
}
bool
MResumePoint
:
:
isObservableOperand
(
MUse
*
u
)
const
{
return
isObservableOperand
(
indexOf
(
u
)
)
;
}
bool
MResumePoint
:
:
isObservableOperand
(
size_t
index
)
const
{
return
block
(
)
-
>
info
(
)
.
isObservableSlot
(
index
)
;
}
bool
MResumePoint
:
:
isRecoverableOperand
(
MUse
*
u
)
const
{
return
block
(
)
-
>
info
(
)
.
isRecoverableOperand
(
indexOf
(
u
)
)
;
}
MDefinition
*
MToInt32
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
input
-
>
isConstant
(
)
)
{
DebugOnly
<
MacroAssembler
:
:
IntConversionInputKind
>
convert
=
conversion
(
)
;
switch
(
input
-
>
type
(
)
)
{
case
MIRType_Null
:
MOZ_ASSERT
(
convert
=
=
MacroAssembler
:
:
IntConversion_Any
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
0
)
)
;
case
MIRType_Boolean
:
MOZ_ASSERT
(
convert
=
=
MacroAssembler
:
:
IntConversion_Any
|
|
convert
=
=
MacroAssembler
:
:
IntConversion_NumbersOrBoolsOnly
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
input
-
>
toConstant
(
)
-
>
toBoolean
(
)
)
)
;
case
MIRType_Int32
:
return
MConstant
:
:
New
(
alloc
Int32Value
(
input
-
>
toConstant
(
)
-
>
toInt32
(
)
)
)
;
case
MIRType_Float32
:
case
MIRType_Double
:
int32_t
ival
;
if
(
mozilla
:
:
NumberEqualsInt32
(
input
-
>
toConstant
(
)
-
>
toNumber
(
)
&
ival
)
)
return
MConstant
:
:
New
(
alloc
Int32Value
(
ival
)
)
;
break
;
default
:
break
;
}
}
if
(
input
-
>
type
(
)
=
=
MIRType_Int32
)
return
input
;
return
this
;
}
void
MToInt32
:
:
analyzeEdgeCasesBackward
(
)
{
if
(
!
NeedNegativeZeroCheck
(
this
)
)
setCanBeNegativeZero
(
false
)
;
}
MDefinition
*
MTruncateToInt32
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
input
-
>
isBox
(
)
)
input
=
input
-
>
getOperand
(
0
)
;
if
(
input
-
>
type
(
)
=
=
MIRType_Int32
)
return
input
;
if
(
input
-
>
type
(
)
=
=
MIRType_Double
&
&
input
-
>
isConstant
(
)
)
{
int32_t
ret
=
ToInt32
(
input
-
>
toConstant
(
)
-
>
toDouble
(
)
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
ret
)
)
;
}
return
this
;
}
MDefinition
*
MToDouble
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
input
-
>
isBox
(
)
)
input
=
input
-
>
getOperand
(
0
)
;
if
(
input
-
>
type
(
)
=
=
MIRType_Double
)
return
input
;
if
(
input
-
>
isConstant
(
)
&
&
input
-
>
toConstant
(
)
-
>
isNumber
(
)
)
{
double
out
=
input
-
>
toConstant
(
)
-
>
toNumber
(
)
;
return
MConstant
:
:
New
(
alloc
DoubleValue
(
out
)
)
;
}
return
this
;
}
MDefinition
*
MToFloat32
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
input
=
getOperand
(
0
)
;
if
(
input
-
>
isBox
(
)
)
input
=
input
-
>
getOperand
(
0
)
;
if
(
input
-
>
type
(
)
=
=
MIRType_Float32
)
return
input
;
if
(
input
-
>
isToDouble
(
)
&
&
input
-
>
toToDouble
(
)
-
>
input
(
)
-
>
type
(
)
=
=
MIRType_Float32
)
return
input
-
>
toToDouble
(
)
-
>
input
(
)
;
if
(
input
-
>
isConstant
(
)
&
&
input
-
>
toConstant
(
)
-
>
isNumber
(
)
)
return
MConstant
:
:
NewFloat32
(
alloc
float
(
input
-
>
toConstant
(
)
-
>
toNumber
(
)
)
)
;
return
this
;
}
MDefinition
*
MToString
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
in
=
input
(
)
;
if
(
in
-
>
isBox
(
)
)
in
=
in
-
>
getOperand
(
0
)
;
if
(
in
-
>
type
(
)
=
=
MIRType_String
)
return
in
;
return
this
;
}
MDefinition
*
MClampToUint8
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
MConstant
*
inputConst
=
input
(
)
-
>
maybeConstantValue
(
)
)
{
if
(
inputConst
-
>
isNumber
(
)
)
{
int32_t
clamped
=
ClampDoubleToUint8
(
inputConst
-
>
toNumber
(
)
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
clamped
)
)
;
}
}
return
this
;
}
bool
MCompare
:
:
tryFoldEqualOperands
(
bool
*
result
)
{
if
(
lhs
(
)
!
=
rhs
(
)
)
return
false
;
if
(
jsop
(
)
!
=
JSOP_STRICTEQ
&
&
jsop
(
)
!
=
JSOP_STRICTNE
)
return
false
;
if
(
compareType_
=
=
Compare_Unknown
)
return
false
;
MOZ_ASSERT
(
compareType_
=
=
Compare_Undefined
|
|
compareType_
=
=
Compare_Null
|
|
compareType_
=
=
Compare_Boolean
|
|
compareType_
=
=
Compare_Int32
|
|
compareType_
=
=
Compare_Int32MaybeCoerceBoth
|
|
compareType_
=
=
Compare_Int32MaybeCoerceLHS
|
|
compareType_
=
=
Compare_Int32MaybeCoerceRHS
|
|
compareType_
=
=
Compare_UInt32
|
|
compareType_
=
=
Compare_Double
|
|
compareType_
=
=
Compare_DoubleMaybeCoerceLHS
|
|
compareType_
=
=
Compare_DoubleMaybeCoerceRHS
|
|
compareType_
=
=
Compare_Float32
|
|
compareType_
=
=
Compare_String
|
|
compareType_
=
=
Compare_StrictString
|
|
compareType_
=
=
Compare_Object
|
|
compareType_
=
=
Compare_Bitwise
)
;
if
(
isDoubleComparison
(
)
|
|
isFloat32Comparison
(
)
)
{
if
(
!
operandsAreNeverNaN
(
)
)
return
false
;
}
if
(
DeadIfUnused
(
lhs
(
)
)
)
lhs
(
)
-
>
setGuardRangeBailouts
(
)
;
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTEQ
)
;
return
true
;
}
bool
MCompare
:
:
tryFoldTypeOf
(
bool
*
result
)
{
if
(
!
lhs
(
)
-
>
isTypeOf
(
)
&
&
!
rhs
(
)
-
>
isTypeOf
(
)
)
return
false
;
if
(
!
lhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
isConstant
(
)
)
return
false
;
MTypeOf
*
typeOf
=
lhs
(
)
-
>
isTypeOf
(
)
?
lhs
(
)
-
>
toTypeOf
(
)
:
rhs
(
)
-
>
toTypeOf
(
)
;
MConstant
*
constant
=
lhs
(
)
-
>
isConstant
(
)
?
lhs
(
)
-
>
toConstant
(
)
:
rhs
(
)
-
>
toConstant
(
)
;
if
(
constant
-
>
type
(
)
!
=
MIRType_String
)
return
false
;
if
(
jsop
(
)
!
=
JSOP_STRICTEQ
&
&
jsop
(
)
!
=
JSOP_STRICTNE
&
&
jsop
(
)
!
=
JSOP_EQ
&
&
jsop
(
)
!
=
JSOP_NE
)
{
return
false
;
}
const
JSAtomState
&
names
=
GetJitContext
(
)
-
>
runtime
-
>
names
(
)
;
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_VOID
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Undefined
)
&
&
!
typeOf
-
>
inputMaybeCallableOrEmulatesUndefined
(
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_BOOLEAN
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Boolean
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_NUMBER
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Int32
)
&
&
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Float32
)
&
&
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Double
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_STRING
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_String
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_SYMBOL
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Symbol
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_OBJECT
names
)
)
{
if
(
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Object
)
&
&
!
typeOf
-
>
input
(
)
-
>
mightBeType
(
MIRType_Null
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
else
if
(
constant
-
>
toString
(
)
=
=
TypeName
(
JSTYPE_FUNCTION
names
)
)
{
if
(
!
typeOf
-
>
inputMaybeCallableOrEmulatesUndefined
(
)
)
{
*
result
=
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
;
return
true
;
}
}
return
false
;
}
bool
MCompare
:
:
tryFold
(
bool
*
result
)
{
JSOp
op
=
jsop
(
)
;
if
(
tryFoldEqualOperands
(
result
)
)
return
true
;
if
(
tryFoldTypeOf
(
result
)
)
return
true
;
if
(
compareType_
=
=
Compare_Null
|
|
compareType_
=
=
Compare_Undefined
)
{
if
(
op
=
=
JSOP_STRICTEQ
|
|
op
=
=
JSOP_STRICTNE
)
{
if
(
lhs
(
)
-
>
type
(
)
=
=
inputType
(
)
)
{
*
result
=
(
op
=
=
JSOP_STRICTEQ
)
;
return
true
;
}
if
(
!
lhs
(
)
-
>
mightBeType
(
inputType
(
)
)
)
{
*
result
=
(
op
=
=
JSOP_STRICTNE
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_EQ
|
|
op
=
=
JSOP_NE
)
;
if
(
IsNullOrUndefined
(
lhs
(
)
-
>
type
(
)
)
)
{
*
result
=
(
op
=
=
JSOP_EQ
)
;
return
true
;
}
if
(
!
lhs
(
)
-
>
mightBeType
(
MIRType_Null
)
&
&
!
lhs
(
)
-
>
mightBeType
(
MIRType_Undefined
)
&
&
!
(
lhs
(
)
-
>
mightBeType
(
MIRType_Object
)
&
&
operandMightEmulateUndefined
(
)
)
)
{
*
result
=
(
op
=
=
JSOP_NE
)
;
return
true
;
}
}
return
false
;
}
if
(
compareType_
=
=
Compare_Boolean
)
{
MOZ_ASSERT
(
op
=
=
JSOP_STRICTEQ
|
|
op
=
=
JSOP_STRICTNE
)
;
MOZ_ASSERT
(
rhs
(
)
-
>
type
(
)
=
=
MIRType_Boolean
)
;
MOZ_ASSERT
(
lhs
(
)
-
>
type
(
)
!
=
MIRType_Boolean
"
Should
use
Int32
comparison
"
)
;
if
(
!
lhs
(
)
-
>
mightBeType
(
MIRType_Boolean
)
)
{
*
result
=
(
op
=
=
JSOP_STRICTNE
)
;
return
true
;
}
return
false
;
}
if
(
compareType_
=
=
Compare_StrictString
)
{
MOZ_ASSERT
(
op
=
=
JSOP_STRICTEQ
|
|
op
=
=
JSOP_STRICTNE
)
;
MOZ_ASSERT
(
rhs
(
)
-
>
type
(
)
=
=
MIRType_String
)
;
MOZ_ASSERT
(
lhs
(
)
-
>
type
(
)
!
=
MIRType_String
"
Should
use
String
comparison
"
)
;
if
(
!
lhs
(
)
-
>
mightBeType
(
MIRType_String
)
)
{
*
result
=
(
op
=
=
JSOP_STRICTNE
)
;
return
true
;
}
return
false
;
}
return
false
;
}
bool
MCompare
:
:
evaluateConstantOperands
(
TempAllocator
&
alloc
bool
*
result
)
{
if
(
type
(
)
!
=
MIRType_Boolean
&
&
type
(
)
!
=
MIRType_Int32
)
return
false
;
MDefinition
*
left
=
getOperand
(
0
)
;
MDefinition
*
right
=
getOperand
(
1
)
;
if
(
compareType
(
)
=
=
Compare_Double
)
{
if
(
!
lhs
(
)
-
>
isConstant
(
)
&
&
!
rhs
(
)
-
>
isConstant
(
)
)
return
false
;
MDefinition
*
operand
=
left
-
>
isConstant
(
)
?
right
:
left
;
MConstant
*
constant
=
left
-
>
isConstant
(
)
?
left
-
>
toConstant
(
)
:
right
-
>
toConstant
(
)
;
MOZ_ASSERT
(
constant
-
>
type
(
)
=
=
MIRType_Double
)
;
double
cte
=
constant
-
>
toDouble
(
)
;
if
(
operand
-
>
isToDouble
(
)
&
&
operand
-
>
getOperand
(
0
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
bool
replaced
=
false
;
switch
(
jsop_
)
{
case
JSOP_LT
:
if
(
cte
>
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
!
(
(
constant
=
=
lhs
(
)
)
^
(
cte
<
INT32_MIN
)
)
;
replaced
=
true
;
}
break
;
case
JSOP_LE
:
if
(
constant
=
=
lhs
(
)
)
{
if
(
cte
>
INT32_MAX
|
|
cte
<
=
INT32_MIN
)
{
*
result
=
(
cte
<
=
INT32_MIN
)
;
replaced
=
true
;
}
}
else
{
if
(
cte
>
=
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
(
cte
>
=
INT32_MIN
)
;
replaced
=
true
;
}
}
break
;
case
JSOP_GT
:
if
(
cte
>
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
!
(
(
constant
=
=
rhs
(
)
)
^
(
cte
<
INT32_MIN
)
)
;
replaced
=
true
;
}
break
;
case
JSOP_GE
:
if
(
constant
=
=
lhs
(
)
)
{
if
(
cte
>
=
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
(
cte
>
=
INT32_MAX
)
;
replaced
=
true
;
}
}
else
{
if
(
cte
>
INT32_MAX
|
|
cte
<
=
INT32_MIN
)
{
*
result
=
(
cte
<
=
INT32_MIN
)
;
replaced
=
true
;
}
}
break
;
case
JSOP_STRICTEQ
:
case
JSOP_EQ
:
if
(
cte
>
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
false
;
replaced
=
true
;
}
break
;
case
JSOP_STRICTNE
:
case
JSOP_NE
:
if
(
cte
>
INT32_MAX
|
|
cte
<
INT32_MIN
)
{
*
result
=
true
;
replaced
=
true
;
}
break
;
default
:
MOZ_CRASH
(
"
Unexpected
op
.
"
)
;
}
if
(
replaced
)
{
MLimitedTruncate
*
limit
=
MLimitedTruncate
:
:
New
(
alloc
operand
-
>
getOperand
(
0
)
MDefinition
:
:
NoTruncate
)
;
limit
-
>
setGuardUnchecked
(
)
;
block
(
)
-
>
insertBefore
(
this
limit
)
;
return
true
;
}
}
}
if
(
!
left
-
>
isConstant
(
)
|
|
!
right
-
>
isConstant
(
)
)
return
false
;
MConstant
*
lhs
=
left
-
>
toConstant
(
)
;
MConstant
*
rhs
=
right
-
>
toConstant
(
)
;
if
(
lhs
-
>
type
(
)
=
=
MIRType_String
&
&
rhs
-
>
type
(
)
=
=
MIRType_String
)
{
int32_t
comp
=
0
;
if
(
left
!
=
right
)
comp
=
CompareAtoms
(
&
lhs
-
>
toString
(
)
-
>
asAtom
(
)
&
rhs
-
>
toString
(
)
-
>
asAtom
(
)
)
;
switch
(
jsop_
)
{
case
JSOP_LT
:
*
result
=
(
comp
<
0
)
;
break
;
case
JSOP_LE
:
*
result
=
(
comp
<
=
0
)
;
break
;
case
JSOP_GT
:
*
result
=
(
comp
>
0
)
;
break
;
case
JSOP_GE
:
*
result
=
(
comp
>
=
0
)
;
break
;
case
JSOP_STRICTEQ
:
case
JSOP_EQ
:
*
result
=
(
comp
=
=
0
)
;
break
;
case
JSOP_STRICTNE
:
case
JSOP_NE
:
*
result
=
(
comp
!
=
0
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
op
.
"
)
;
}
return
true
;
}
if
(
compareType_
=
=
Compare_UInt32
)
{
uint32_t
lhsUint
=
uint32_t
(
lhs
-
>
toInt32
(
)
)
;
uint32_t
rhsUint
=
uint32_t
(
rhs
-
>
toInt32
(
)
)
;
switch
(
jsop_
)
{
case
JSOP_LT
:
*
result
=
(
lhsUint
<
rhsUint
)
;
break
;
case
JSOP_LE
:
*
result
=
(
lhsUint
<
=
rhsUint
)
;
break
;
case
JSOP_GT
:
*
result
=
(
lhsUint
>
rhsUint
)
;
break
;
case
JSOP_GE
:
*
result
=
(
lhsUint
>
=
rhsUint
)
;
break
;
case
JSOP_STRICTEQ
:
case
JSOP_EQ
:
*
result
=
(
lhsUint
=
=
rhsUint
)
;
break
;
case
JSOP_STRICTNE
:
case
JSOP_NE
:
*
result
=
(
lhsUint
!
=
rhsUint
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
op
.
"
)
;
}
return
true
;
}
if
(
!
lhs
-
>
isNumber
(
)
|
|
!
rhs
-
>
isNumber
(
)
)
return
false
;
switch
(
jsop_
)
{
case
JSOP_LT
:
*
result
=
(
lhs
-
>
toNumber
(
)
<
rhs
-
>
toNumber
(
)
)
;
break
;
case
JSOP_LE
:
*
result
=
(
lhs
-
>
toNumber
(
)
<
=
rhs
-
>
toNumber
(
)
)
;
break
;
case
JSOP_GT
:
*
result
=
(
lhs
-
>
toNumber
(
)
>
rhs
-
>
toNumber
(
)
)
;
break
;
case
JSOP_GE
:
*
result
=
(
lhs
-
>
toNumber
(
)
>
=
rhs
-
>
toNumber
(
)
)
;
break
;
case
JSOP_STRICTEQ
:
case
JSOP_EQ
:
*
result
=
(
lhs
-
>
toNumber
(
)
=
=
rhs
-
>
toNumber
(
)
)
;
break
;
case
JSOP_STRICTNE
:
case
JSOP_NE
:
*
result
=
(
lhs
-
>
toNumber
(
)
!
=
rhs
-
>
toNumber
(
)
)
;
break
;
default
:
return
false
;
}
return
true
;
}
MDefinition
*
MCompare
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
bool
result
;
if
(
tryFold
(
&
result
)
|
|
evaluateConstantOperands
(
alloc
&
result
)
)
{
if
(
type
(
)
=
=
MIRType_Int32
)
return
MConstant
:
:
New
(
alloc
Int32Value
(
result
)
)
;
MOZ_ASSERT
(
type
(
)
=
=
MIRType_Boolean
)
;
return
MConstant
:
:
New
(
alloc
BooleanValue
(
result
)
)
;
}
return
this
;
}
void
MCompare
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MDefinition
*
lhs
=
getOperand
(
0
)
;
MDefinition
*
rhs
=
getOperand
(
1
)
;
if
(
lhs
-
>
canProduceFloat32
(
)
&
&
rhs
-
>
canProduceFloat32
(
)
&
&
compareType_
=
=
Compare_Double
)
{
compareType_
=
Compare_Float32
;
}
else
{
if
(
lhs
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
lhs
this
)
;
if
(
rhs
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
1
>
(
alloc
rhs
this
)
;
}
}
void
MCompare
:
:
filtersUndefinedOrNull
(
bool
trueBranch
MDefinition
*
*
subject
bool
*
filtersUndefined
bool
*
filtersNull
)
{
*
filtersNull
=
*
filtersUndefined
=
false
;
*
subject
=
nullptr
;
if
(
compareType
(
)
!
=
Compare_Undefined
&
&
compareType
(
)
!
=
Compare_Null
)
return
;
MOZ_ASSERT
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
|
|
jsop
(
)
=
=
JSOP_STRICTEQ
|
|
jsop
(
)
=
=
JSOP_EQ
)
;
if
(
!
trueBranch
&
&
(
jsop
(
)
=
=
JSOP_STRICTNE
|
|
jsop
(
)
=
=
JSOP_NE
)
)
return
;
if
(
trueBranch
&
&
(
jsop
(
)
=
=
JSOP_STRICTEQ
|
|
jsop
(
)
=
=
JSOP_EQ
)
)
return
;
if
(
jsop
(
)
=
=
JSOP_STRICTEQ
|
|
jsop
(
)
=
=
JSOP_STRICTNE
)
{
*
filtersUndefined
=
compareType
(
)
=
=
Compare_Undefined
;
*
filtersNull
=
compareType
(
)
=
=
Compare_Null
;
}
else
{
*
filtersUndefined
=
*
filtersNull
=
true
;
}
*
subject
=
lhs
(
)
;
}
void
MNot
:
:
cacheOperandMightEmulateUndefined
(
CompilerConstraintList
*
constraints
)
{
MOZ_ASSERT
(
operandMightEmulateUndefined
(
)
)
;
if
(
!
getOperand
(
0
)
-
>
maybeEmulatesUndefined
(
constraints
)
)
markNoOperandEmulatesUndefined
(
)
;
}
MDefinition
*
MNot
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
MConstant
*
inputConst
=
input
(
)
-
>
maybeConstantValue
(
)
)
{
bool
b
;
if
(
inputConst
-
>
valueToBoolean
(
&
b
)
)
{
if
(
type
(
)
=
=
MIRType_Int32
)
return
MConstant
:
:
New
(
alloc
Int32Value
(
!
b
)
)
;
return
MConstant
:
:
New
(
alloc
BooleanValue
(
!
b
)
)
;
}
}
MDefinition
*
op
=
getOperand
(
0
)
;
if
(
op
-
>
isNot
(
)
)
{
MDefinition
*
opop
=
op
-
>
getOperand
(
0
)
;
if
(
opop
-
>
isNot
(
)
)
return
opop
;
}
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Undefined
|
|
input
(
)
-
>
type
(
)
=
=
MIRType_Null
)
return
MConstant
:
:
New
(
alloc
BooleanValue
(
true
)
)
;
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Symbol
)
return
MConstant
:
:
New
(
alloc
BooleanValue
(
false
)
)
;
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Object
&
&
!
operandMightEmulateUndefined
(
)
)
return
MConstant
:
:
New
(
alloc
BooleanValue
(
false
)
)
;
return
this
;
}
void
MNot
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
MDefinition
*
in
=
input
(
)
;
if
(
!
in
-
>
canProduceFloat32
(
)
&
&
in
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
in
this
)
;
}
void
MBeta
:
:
printOpcode
(
GenericPrinter
&
out
)
const
{
MDefinition
:
:
printOpcode
(
out
)
;
out
.
printf
(
"
"
)
;
comparison_
-
>
dump
(
out
)
;
}
bool
MNewObject
:
:
shouldUseVM
(
)
const
{
if
(
JSObject
*
obj
=
templateObject
(
)
)
return
obj
-
>
is
<
PlainObject
>
(
)
&
&
obj
-
>
as
<
PlainObject
>
(
)
.
hasDynamicSlots
(
)
;
return
true
;
}
bool
MCreateThisWithTemplate
:
:
canRecoverOnBailout
(
)
const
{
MOZ_ASSERT
(
templateObject
(
)
-
>
is
<
PlainObject
>
(
)
|
|
templateObject
(
)
-
>
is
<
UnboxedPlainObject
>
(
)
)
;
MOZ_ASSERT_IF
(
templateObject
(
)
-
>
is
<
PlainObject
>
(
)
!
templateObject
(
)
-
>
as
<
PlainObject
>
(
)
.
denseElementsAreCopyOnWrite
(
)
)
;
return
true
;
}
bool
OperandIndexMap
:
:
init
(
TempAllocator
&
alloc
JSObject
*
templateObject
)
{
const
UnboxedLayout
&
layout
=
templateObject
-
>
as
<
UnboxedPlainObject
>
(
)
.
layoutDontCheckGeneration
(
)
;
const
UnboxedLayout
:
:
PropertyVector
&
properties
=
layout
.
properties
(
)
;
MOZ_ASSERT
(
properties
.
length
(
)
<
255
)
;
if
(
!
map
.
init
(
alloc
layout
.
size
(
)
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
map
.
length
(
)
;
i
+
+
)
map
[
i
]
=
0
;
uint8_t
index
=
1
;
for
(
size_t
i
=
0
;
i
<
properties
.
length
(
)
;
i
+
+
index
+
+
)
map
[
properties
[
i
]
.
offset
]
=
index
;
return
true
;
}
MObjectState
:
:
MObjectState
(
MObjectState
*
state
)
:
numSlots_
(
state
-
>
numSlots_
)
numFixedSlots_
(
state
-
>
numFixedSlots_
)
operandIndex_
(
state
-
>
operandIndex_
)
{
setResultType
(
MIRType_Object
)
;
setRecoveredOnBailout
(
)
;
}
MObjectState
:
:
MObjectState
(
JSObject
*
templateObject
OperandIndexMap
*
operandIndex
)
{
setResultType
(
MIRType_Object
)
;
setRecoveredOnBailout
(
)
;
if
(
templateObject
-
>
is
<
NativeObject
>
(
)
)
{
NativeObject
*
nativeObject
=
&
templateObject
-
>
as
<
NativeObject
>
(
)
;
numSlots_
=
nativeObject
-
>
slotSpan
(
)
;
numFixedSlots_
=
nativeObject
-
>
numFixedSlots
(
)
;
}
else
{
const
UnboxedLayout
&
layout
=
templateObject
-
>
as
<
UnboxedPlainObject
>
(
)
.
layoutDontCheckGeneration
(
)
;
numSlots_
=
layout
.
properties
(
)
.
length
(
)
;
numFixedSlots_
=
gc
:
:
GetGCKindSlots
(
layout
.
getAllocKind
(
)
)
;
}
operandIndex_
=
operandIndex
;
}
JSObject
*
MObjectState
:
:
templateObjectOf
(
MDefinition
*
obj
)
{
if
(
obj
-
>
isNewObject
(
)
)
return
obj
-
>
toNewObject
(
)
-
>
templateObject
(
)
;
else
if
(
obj
-
>
isCreateThisWithTemplate
(
)
)
return
obj
-
>
toCreateThisWithTemplate
(
)
-
>
templateObject
(
)
;
else
return
obj
-
>
toNewCallObject
(
)
-
>
templateObject
(
)
;
return
nullptr
;
}
bool
MObjectState
:
:
init
(
TempAllocator
&
alloc
MDefinition
*
obj
)
{
if
(
!
MVariadicInstruction
:
:
init
(
alloc
numSlots
(
)
+
1
)
)
return
false
;
initOperand
(
0
obj
)
;
return
true
;
}
bool
MObjectState
:
:
initFromTemplateObject
(
TempAllocator
&
alloc
MDefinition
*
undefinedVal
)
{
JSObject
*
templateObject
=
templateObjectOf
(
object
(
)
)
;
if
(
templateObject
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
UnboxedPlainObject
&
unboxedObject
=
templateObject
-
>
as
<
UnboxedPlainObject
>
(
)
;
const
UnboxedLayout
&
layout
=
unboxedObject
.
layoutDontCheckGeneration
(
)
;
const
UnboxedLayout
:
:
PropertyVector
&
properties
=
layout
.
properties
(
)
;
for
(
size_t
i
=
0
;
i
<
properties
.
length
(
)
;
i
+
+
)
{
Value
val
=
unboxedObject
.
getValue
(
properties
[
i
]
true
)
;
MDefinition
*
def
=
undefinedVal
;
if
(
!
val
.
isUndefined
(
)
)
{
MConstant
*
ins
=
val
.
isObject
(
)
?
MConstant
:
:
NewConstraintlessObject
(
alloc
&
val
.
toObject
(
)
)
:
MConstant
:
:
New
(
alloc
val
)
;
block
(
)
-
>
insertBefore
(
this
ins
)
;
def
=
ins
;
}
initSlot
(
i
def
)
;
}
}
else
{
NativeObject
&
nativeObject
=
templateObject
-
>
as
<
NativeObject
>
(
)
;
MOZ_ASSERT
(
nativeObject
.
slotSpan
(
)
=
=
numSlots
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numSlots
(
)
;
i
+
+
)
{
Value
val
=
nativeObject
.
getSlot
(
i
)
;
MDefinition
*
def
=
undefinedVal
;
if
(
!
val
.
isUndefined
(
)
)
{
MConstant
*
ins
=
val
.
isObject
(
)
?
MConstant
:
:
NewConstraintlessObject
(
alloc
&
val
.
toObject
(
)
)
:
MConstant
:
:
New
(
alloc
val
)
;
block
(
)
-
>
insertBefore
(
this
ins
)
;
def
=
ins
;
}
initSlot
(
i
def
)
;
}
}
return
true
;
}
MObjectState
*
MObjectState
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
obj
)
{
JSObject
*
templateObject
=
templateObjectOf
(
obj
)
;
MOZ_ASSERT
(
templateObject
"
Unexpected
object
creation
.
"
)
;
OperandIndexMap
*
operandIndex
=
nullptr
;
if
(
templateObject
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
operandIndex
=
new
(
alloc
)
OperandIndexMap
;
if
(
!
operandIndex
|
|
!
operandIndex
-
>
init
(
alloc
templateObject
)
)
return
nullptr
;
}
MObjectState
*
res
=
new
(
alloc
)
MObjectState
(
templateObject
operandIndex
)
;
if
(
!
res
|
|
!
res
-
>
init
(
alloc
obj
)
)
return
nullptr
;
return
res
;
}
MObjectState
*
MObjectState
:
:
Copy
(
TempAllocator
&
alloc
MObjectState
*
state
)
{
MObjectState
*
res
=
new
(
alloc
)
MObjectState
(
state
)
;
if
(
!
res
|
|
!
res
-
>
init
(
alloc
state
-
>
object
(
)
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
res
-
>
numSlots
(
)
;
i
+
+
)
res
-
>
initSlot
(
i
state
-
>
getSlot
(
i
)
)
;
return
res
;
}
MArrayState
:
:
MArrayState
(
MDefinition
*
arr
)
{
setResultType
(
MIRType_Object
)
;
setRecoveredOnBailout
(
)
;
numElements_
=
arr
-
>
toNewArray
(
)
-
>
length
(
)
;
}
bool
MArrayState
:
:
init
(
TempAllocator
&
alloc
MDefinition
*
obj
MDefinition
*
len
)
{
if
(
!
MVariadicInstruction
:
:
init
(
alloc
numElements
(
)
+
2
)
)
return
false
;
initOperand
(
0
obj
)
;
initOperand
(
1
len
)
;
return
true
;
}
MArrayState
*
MArrayState
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
arr
MDefinition
*
undefinedVal
MDefinition
*
initLength
)
{
MArrayState
*
res
=
new
(
alloc
)
MArrayState
(
arr
)
;
if
(
!
res
|
|
!
res
-
>
init
(
alloc
arr
initLength
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
res
-
>
numElements
(
)
;
i
+
+
)
res
-
>
initElement
(
i
undefinedVal
)
;
return
res
;
}
MArrayState
*
MArrayState
:
:
Copy
(
TempAllocator
&
alloc
MArrayState
*
state
)
{
MDefinition
*
arr
=
state
-
>
array
(
)
;
MDefinition
*
len
=
state
-
>
initializedLength
(
)
;
MArrayState
*
res
=
new
(
alloc
)
MArrayState
(
arr
)
;
if
(
!
res
|
|
!
res
-
>
init
(
alloc
arr
len
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
res
-
>
numElements
(
)
;
i
+
+
)
res
-
>
initElement
(
i
state
-
>
getElement
(
i
)
)
;
return
res
;
}
MNewArray
:
:
MNewArray
(
CompilerConstraintList
*
constraints
uint32_t
length
MConstant
*
templateConst
gc
:
:
InitialHeap
initialHeap
jsbytecode
*
pc
)
:
MUnaryInstruction
(
templateConst
)
length_
(
length
)
initialHeap_
(
initialHeap
)
convertDoubleElements_
(
false
)
pc_
(
pc
)
{
setResultType
(
MIRType_Object
)
;
if
(
templateObject
(
)
)
{
if
(
TemporaryTypeSet
*
types
=
MakeSingletonTypeSet
(
constraints
templateObject
(
)
)
)
{
setResultTypeSet
(
types
)
;
if
(
types
-
>
convertDoubleElements
(
constraints
)
=
=
TemporaryTypeSet
:
:
AlwaysConvertToDoubles
)
convertDoubleElements_
=
true
;
}
}
}
bool
MNewArray
:
:
shouldUseVM
(
)
const
{
if
(
!
templateObject
(
)
)
return
true
;
if
(
templateObject
(
)
-
>
is
<
UnboxedArrayObject
>
(
)
)
{
MOZ_ASSERT
(
templateObject
(
)
-
>
as
<
UnboxedArrayObject
>
(
)
.
capacity
(
)
>
=
length
(
)
)
;
return
!
templateObject
(
)
-
>
as
<
UnboxedArrayObject
>
(
)
.
hasInlineElements
(
)
;
}
MOZ_ASSERT
(
length
(
)
<
=
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
;
size_t
arraySlots
=
gc
:
:
GetGCKindSlots
(
templateObject
(
)
-
>
asTenured
(
)
.
getAllocKind
(
)
)
-
ObjectElements
:
:
VALUES_PER_HEADER
;
return
length
(
)
>
arraySlots
;
}
bool
MLoadFixedSlot
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
if
(
store
-
>
isStoreFixedSlot
(
)
&
&
store
-
>
toStoreFixedSlot
(
)
-
>
slot
(
)
!
=
slot
(
)
)
return
false
;
return
true
;
}
bool
MLoadFixedSlotAndUnbox
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
if
(
store
-
>
isStoreFixedSlot
(
)
&
&
store
-
>
toStoreFixedSlot
(
)
-
>
slot
(
)
!
=
slot
(
)
)
return
false
;
return
true
;
}
MDefinition
*
MLoadFixedSlot
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
dependency
(
)
|
|
!
dependency
(
)
-
>
isStoreFixedSlot
(
)
)
return
this
;
MStoreFixedSlot
*
store
=
dependency
(
)
-
>
toStoreFixedSlot
(
)
;
if
(
!
store
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
return
this
;
if
(
store
-
>
object
(
)
!
=
object
(
)
)
return
this
;
if
(
store
-
>
slot
(
)
!
=
slot
(
)
)
return
this
;
return
foldsToStoredValue
(
alloc
store
-
>
value
(
)
)
;
}
bool
MAsmJSLoadHeap
:
:
mightAlias
(
const
MDefinition
*
def
)
const
{
if
(
def
-
>
isAsmJSStoreHeap
(
)
)
{
const
MAsmJSStoreHeap
*
store
=
def
-
>
toAsmJSStoreHeap
(
)
;
if
(
store
-
>
accessType
(
)
!
=
accessType
(
)
)
return
true
;
if
(
!
ptr
(
)
-
>
isConstant
(
)
|
|
!
store
-
>
ptr
(
)
-
>
isConstant
(
)
)
return
true
;
const
MConstant
*
otherPtr
=
store
-
>
ptr
(
)
-
>
toConstant
(
)
;
return
ptr
(
)
-
>
toConstant
(
)
-
>
equals
(
otherPtr
)
;
}
return
true
;
}
bool
MAsmJSLoadHeap
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
ins
-
>
isAsmJSLoadHeap
(
)
)
return
false
;
const
MAsmJSLoadHeap
*
load
=
ins
-
>
toAsmJSLoadHeap
(
)
;
return
load
-
>
accessType
(
)
=
=
accessType
(
)
&
&
congruentIfOperandsEqual
(
load
)
;
}
bool
MAsmJSLoadGlobalVar
:
:
mightAlias
(
const
MDefinition
*
def
)
const
{
if
(
def
-
>
isAsmJSStoreGlobalVar
(
)
)
{
const
MAsmJSStoreGlobalVar
*
store
=
def
-
>
toAsmJSStoreGlobalVar
(
)
;
return
store
-
>
globalDataOffset
(
)
=
=
globalDataOffset_
;
}
return
true
;
}
HashNumber
MAsmJSLoadGlobalVar
:
:
valueHash
(
)
const
{
HashNumber
hash
=
MDefinition
:
:
valueHash
(
)
;
hash
=
addU32ToHash
(
hash
globalDataOffset_
)
;
return
hash
;
}
bool
MAsmJSLoadGlobalVar
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
ins
-
>
isAsmJSLoadGlobalVar
(
)
)
{
const
MAsmJSLoadGlobalVar
*
load
=
ins
-
>
toAsmJSLoadGlobalVar
(
)
;
return
globalDataOffset_
=
=
load
-
>
globalDataOffset_
;
}
return
false
;
}
MDefinition
*
MAsmJSLoadGlobalVar
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
dependency
(
)
|
|
!
dependency
(
)
-
>
isAsmJSStoreGlobalVar
(
)
)
return
this
;
MAsmJSStoreGlobalVar
*
store
=
dependency
(
)
-
>
toAsmJSStoreGlobalVar
(
)
;
if
(
!
store
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
return
this
;
if
(
store
-
>
globalDataOffset
(
)
!
=
globalDataOffset
(
)
)
return
this
;
if
(
store
-
>
value
(
)
-
>
type
(
)
!
=
type
(
)
)
return
this
;
return
store
-
>
value
(
)
;
}
HashNumber
MAsmJSLoadFuncPtr
:
:
valueHash
(
)
const
{
HashNumber
hash
=
MDefinition
:
:
valueHash
(
)
;
hash
=
addU32ToHash
(
hash
hasLimit_
)
;
hash
=
addU32ToHash
(
hash
limit_
)
;
hash
=
addU32ToHash
(
hash
alwaysThrow_
)
;
hash
=
addU32ToHash
(
hash
globalDataOffset_
)
;
return
hash
;
}
bool
MAsmJSLoadFuncPtr
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
ins
-
>
isAsmJSLoadFuncPtr
(
)
)
{
const
MAsmJSLoadFuncPtr
*
load
=
ins
-
>
toAsmJSLoadFuncPtr
(
)
;
return
hasLimit_
=
=
load
-
>
hasLimit_
&
&
limit_
=
=
load
-
>
limit_
&
&
alwaysThrow_
=
=
load
-
>
alwaysThrow_
&
&
globalDataOffset_
=
=
load
-
>
globalDataOffset_
;
}
return
false
;
}
HashNumber
MAsmJSLoadFFIFunc
:
:
valueHash
(
)
const
{
HashNumber
hash
=
MDefinition
:
:
valueHash
(
)
;
hash
=
addU32ToHash
(
hash
globalDataOffset_
)
;
return
hash
;
}
bool
MAsmJSLoadFFIFunc
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
ins
-
>
isAsmJSLoadFFIFunc
(
)
)
{
const
MAsmJSLoadFFIFunc
*
load
=
ins
-
>
toAsmJSLoadFFIFunc
(
)
;
return
globalDataOffset_
=
=
load
-
>
globalDataOffset_
;
}
return
false
;
}
bool
MLoadSlot
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
if
(
store
-
>
isStoreSlot
(
)
&
&
store
-
>
toStoreSlot
(
)
-
>
slot
(
)
!
=
slot
(
)
)
return
false
;
return
true
;
}
HashNumber
MLoadSlot
:
:
valueHash
(
)
const
{
HashNumber
hash
=
MDefinition
:
:
valueHash
(
)
;
hash
=
addU32ToHash
(
hash
slot_
)
;
return
hash
;
}
MDefinition
*
MLoadSlot
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
dependency
(
)
|
|
!
dependency
(
)
-
>
isStoreSlot
(
)
)
return
this
;
MStoreSlot
*
store
=
dependency
(
)
-
>
toStoreSlot
(
)
;
if
(
!
store
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
return
this
;
if
(
store
-
>
slots
(
)
!
=
slots
(
)
)
return
this
;
return
foldsToStoredValue
(
alloc
store
-
>
value
(
)
)
;
}
MDefinition
*
MFunctionEnvironment
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
input
(
)
-
>
isLambda
(
)
)
return
this
;
return
input
(
)
-
>
toLambda
(
)
-
>
scopeChain
(
)
;
}
MDefinition
*
MLoadElement
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
!
dependency
(
)
|
|
!
dependency
(
)
-
>
isStoreElement
(
)
)
return
this
;
MStoreElement
*
store
=
dependency
(
)
-
>
toStoreElement
(
)
;
if
(
!
store
-
>
block
(
)
-
>
dominates
(
block
(
)
)
)
return
this
;
if
(
store
-
>
elements
(
)
!
=
elements
(
)
)
return
this
;
if
(
store
-
>
index
(
)
!
=
index
(
)
)
return
this
;
return
foldsToStoredValue
(
alloc
store
-
>
value
(
)
)
;
}
static
inline
const
MElements
*
MaybeUnwrapElements
(
const
MDefinition
*
elementsOrObj
)
{
if
(
elementsOrObj
-
>
isConvertElementsToDoubles
(
)
)
return
MaybeUnwrapElements
(
elementsOrObj
-
>
toConvertElementsToDoubles
(
)
-
>
elements
(
)
)
;
if
(
elementsOrObj
-
>
type
(
)
=
=
MIRType_Object
)
return
nullptr
;
if
(
!
elementsOrObj
-
>
isElements
(
)
)
return
nullptr
;
return
elementsOrObj
-
>
toElements
(
)
;
}
static
inline
const
MDefinition
*
GetElementsObject
(
const
MDefinition
*
elementsOrObj
)
{
if
(
elementsOrObj
-
>
type
(
)
=
=
MIRType_Object
)
return
elementsOrObj
;
const
MDefinition
*
elements
=
MaybeUnwrapElements
(
elementsOrObj
)
;
if
(
elements
)
return
elements
-
>
toElements
(
)
-
>
input
(
)
;
return
nullptr
;
}
static
inline
const
MDefinition
*
GetStoreObject
(
const
MDefinition
*
store
)
{
switch
(
store
-
>
op
(
)
)
{
case
MDefinition
:
:
Op_StoreElement
:
return
GetElementsObject
(
store
-
>
toStoreElement
(
)
-
>
elements
(
)
)
;
case
MDefinition
:
:
Op_StoreElementHole
:
return
store
-
>
toStoreElementHole
(
)
-
>
object
(
)
;
case
MDefinition
:
:
Op_StoreUnboxedObjectOrNull
:
return
GetElementsObject
(
store
-
>
toStoreUnboxedObjectOrNull
(
)
-
>
elements
(
)
)
;
case
MDefinition
:
:
Op_StoreUnboxedString
:
return
GetElementsObject
(
store
-
>
toStoreUnboxedString
(
)
-
>
elements
(
)
)
;
case
MDefinition
:
:
Op_StoreUnboxedScalar
:
return
GetElementsObject
(
store
-
>
toStoreUnboxedScalar
(
)
-
>
elements
(
)
)
;
default
:
return
nullptr
;
}
}
static
bool
GenericLoadMightAlias
(
const
MDefinition
*
elementsOrObj
const
MDefinition
*
store
)
{
const
MElements
*
elements
=
MaybeUnwrapElements
(
elementsOrObj
)
;
if
(
elements
)
return
elements
-
>
mightAlias
(
store
)
;
if
(
elementsOrObj
-
>
type
(
)
!
=
MIRType_Object
)
return
true
;
const
MDefinition
*
object
=
elementsOrObj
;
MOZ_ASSERT
(
object
-
>
type
(
)
=
=
MIRType_Object
)
;
if
(
!
object
-
>
resultTypeSet
(
)
)
return
true
;
const
MDefinition
*
storeObject
=
GetStoreObject
(
store
)
;
if
(
!
storeObject
)
return
true
;
if
(
!
storeObject
-
>
resultTypeSet
(
)
)
return
true
;
return
object
-
>
resultTypeSet
(
)
-
>
objectsIntersect
(
storeObject
-
>
resultTypeSet
(
)
)
;
}
bool
MElements
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
if
(
!
input
(
)
-
>
resultTypeSet
(
)
)
return
true
;
const
MDefinition
*
storeObj
=
GetStoreObject
(
store
)
;
if
(
!
storeObj
)
return
true
;
if
(
!
storeObj
-
>
resultTypeSet
(
)
)
return
true
;
return
input
(
)
-
>
resultTypeSet
(
)
-
>
objectsIntersect
(
storeObj
-
>
resultTypeSet
(
)
)
;
}
bool
MLoadElement
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
elements
(
)
store
)
;
}
bool
MInitializedLength
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
elements
(
)
store
)
;
}
bool
MLoadUnboxedObjectOrNull
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
elements
(
)
store
)
;
}
bool
MLoadUnboxedString
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
elements
(
)
store
)
;
}
bool
MLoadUnboxedScalar
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
elements
(
)
store
)
;
}
bool
MUnboxedArrayInitializedLength
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
return
GenericLoadMightAlias
(
object
(
)
store
)
;
}
bool
MGuardReceiverPolymorphic
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
ins
-
>
isGuardReceiverPolymorphic
(
)
)
return
false
;
const
MGuardReceiverPolymorphic
*
other
=
ins
-
>
toGuardReceiverPolymorphic
(
)
;
if
(
numReceivers
(
)
!
=
other
-
>
numReceivers
(
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
numReceivers
(
)
;
i
+
+
)
{
if
(
receiver
(
i
)
!
=
other
-
>
receiver
(
i
)
)
return
false
;
}
return
congruentIfOperandsEqual
(
ins
)
;
}
void
InlinePropertyTable
:
:
trimTo
(
const
ObjectVector
&
targets
const
BoolVector
&
choiceSet
)
{
for
(
size_t
i
=
0
;
i
<
targets
.
length
(
)
;
i
+
+
)
{
if
(
choiceSet
[
i
]
)
continue
;
JSFunction
*
target
=
&
targets
[
i
]
-
>
as
<
JSFunction
>
(
)
;
size_t
j
=
0
;
while
(
j
<
numEntries
(
)
)
{
if
(
entries_
[
j
]
-
>
func
=
=
target
)
entries_
.
erase
(
&
entries_
[
j
]
)
;
else
j
+
+
;
}
}
}
void
InlinePropertyTable
:
:
trimToTargets
(
const
ObjectVector
&
targets
)
{
JitSpew
(
JitSpew_Inlining
"
Got
inlineable
property
cache
with
%
d
cases
"
(
int
)
numEntries
(
)
)
;
size_t
i
=
0
;
while
(
i
<
numEntries
(
)
)
{
bool
foundFunc
=
false
;
for
(
size_t
j
=
0
;
j
<
targets
.
length
(
)
;
j
+
+
)
{
if
(
entries_
[
i
]
-
>
func
=
=
targets
[
j
]
)
{
foundFunc
=
true
;
break
;
}
}
if
(
!
foundFunc
)
entries_
.
erase
(
&
(
entries_
[
i
]
)
)
;
else
i
+
+
;
}
JitSpew
(
JitSpew_Inlining
"
%
d
inlineable
cases
left
after
trimming
to
%
d
targets
"
(
int
)
numEntries
(
)
(
int
)
targets
.
length
(
)
)
;
}
bool
InlinePropertyTable
:
:
hasFunction
(
JSFunction
*
func
)
const
{
for
(
size_t
i
=
0
;
i
<
numEntries
(
)
;
i
+
+
)
{
if
(
entries_
[
i
]
-
>
func
=
=
func
)
return
true
;
}
return
false
;
}
bool
InlinePropertyTable
:
:
hasObjectGroup
(
ObjectGroup
*
group
)
const
{
for
(
size_t
i
=
0
;
i
<
numEntries
(
)
;
i
+
+
)
{
if
(
entries_
[
i
]
-
>
group
=
=
group
)
return
true
;
}
return
false
;
}
TemporaryTypeSet
*
InlinePropertyTable
:
:
buildTypeSetForFunction
(
JSFunction
*
func
)
const
{
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
TemporaryTypeSet
*
types
=
alloc
-
>
new_
<
TemporaryTypeSet
>
(
)
;
if
(
!
types
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
numEntries
(
)
;
i
+
+
)
{
if
(
entries_
[
i
]
-
>
func
=
=
func
)
types
-
>
addType
(
TypeSet
:
:
ObjectType
(
entries_
[
i
]
-
>
group
)
alloc
)
;
}
return
types
;
}
SharedMem
<
void
*
>
MLoadTypedArrayElementStatic
:
:
base
(
)
const
{
return
someTypedArray_
-
>
as
<
TypedArrayObject
>
(
)
.
viewDataEither
(
)
;
}
size_t
MLoadTypedArrayElementStatic
:
:
length
(
)
const
{
return
someTypedArray_
-
>
as
<
TypedArrayObject
>
(
)
.
byteLength
(
)
;
}
bool
MLoadTypedArrayElementStatic
:
:
congruentTo
(
const
MDefinition
*
ins
)
const
{
if
(
!
ins
-
>
isLoadTypedArrayElementStatic
(
)
)
return
false
;
const
MLoadTypedArrayElementStatic
*
other
=
ins
-
>
toLoadTypedArrayElementStatic
(
)
;
if
(
offset
(
)
!
=
other
-
>
offset
(
)
)
return
false
;
if
(
needsBoundsCheck
(
)
!
=
other
-
>
needsBoundsCheck
(
)
)
return
false
;
if
(
accessType
(
)
!
=
other
-
>
accessType
(
)
)
return
false
;
if
(
base
(
)
!
=
other
-
>
base
(
)
)
return
false
;
return
congruentIfOperandsEqual
(
other
)
;
}
SharedMem
<
void
*
>
MStoreTypedArrayElementStatic
:
:
base
(
)
const
{
return
someTypedArray_
-
>
as
<
TypedArrayObject
>
(
)
.
viewDataEither
(
)
;
}
bool
MGetPropertyCache
:
:
allowDoubleResult
(
)
const
{
if
(
!
resultTypeSet
(
)
)
return
true
;
return
resultTypeSet
(
)
-
>
hasType
(
TypeSet
:
:
DoubleType
(
)
)
;
}
size_t
MStoreTypedArrayElementStatic
:
:
length
(
)
const
{
return
someTypedArray_
-
>
as
<
TypedArrayObject
>
(
)
.
byteLength
(
)
;
}
bool
MGetPropertyPolymorphic
:
:
mightAlias
(
const
MDefinition
*
store
)
const
{
if
(
!
store
-
>
isStoreFixedSlot
(
)
&
&
!
store
-
>
isStoreSlot
(
)
)
return
true
;
for
(
size_t
i
=
0
;
i
<
numReceivers
(
)
;
i
+
+
)
{
const
Shape
*
shape
=
this
-
>
shape
(
i
)
;
if
(
!
shape
)
continue
;
if
(
shape
-
>
slot
(
)
<
shape
-
>
numFixedSlots
(
)
)
{
uint32_t
slot
=
shape
-
>
slot
(
)
;
if
(
store
-
>
isStoreFixedSlot
(
)
&
&
store
-
>
toStoreFixedSlot
(
)
-
>
slot
(
)
!
=
slot
)
continue
;
if
(
store
-
>
isStoreSlot
(
)
)
continue
;
}
else
{
uint32_t
slot
=
shape
-
>
slot
(
)
-
shape
-
>
numFixedSlots
(
)
;
if
(
store
-
>
isStoreSlot
(
)
&
&
store
-
>
toStoreSlot
(
)
-
>
slot
(
)
!
=
slot
)
continue
;
if
(
store
-
>
isStoreFixedSlot
(
)
)
continue
;
}
return
true
;
}
return
false
;
}
void
MGetPropertyCache
:
:
setBlock
(
MBasicBlock
*
block
)
{
MDefinition
:
:
setBlock
(
block
)
;
if
(
!
location_
.
pc
)
{
location_
.
pc
=
block
-
>
trackedPc
(
)
;
location_
.
script
=
block
-
>
info
(
)
.
script
(
)
;
}
}
bool
MGetPropertyCache
:
:
updateForReplacement
(
MDefinition
*
ins
)
{
MGetPropertyCache
*
other
=
ins
-
>
toGetPropertyCache
(
)
;
location_
.
append
(
&
other
-
>
location_
)
;
return
true
;
}
MDefinition
*
MAsmJSUnsignedToDouble
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
input
(
)
-
>
isConstant
(
)
&
&
input
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
return
MConstant
:
:
New
(
alloc
DoubleValue
(
uint32_t
(
input
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
)
)
)
;
return
this
;
}
MDefinition
*
MAsmJSUnsignedToFloat32
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
input
(
)
-
>
isConstant
(
)
&
&
input
(
)
-
>
type
(
)
=
=
MIRType_Int32
)
{
double
dval
=
double
(
uint32_t
(
input
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
)
)
;
if
(
IsFloat32Representable
(
dval
)
)
return
MConstant
:
:
NewAsmJS
(
alloc
JS
:
:
Float32Value
(
float
(
dval
)
)
MIRType_Float32
)
;
}
return
this
;
}
MAsmJSCall
*
MAsmJSCall
:
:
New
(
TempAllocator
&
alloc
const
wasm
:
:
CallSiteDesc
&
desc
Callee
callee
const
Args
&
args
MIRType
resultType
size_t
spIncrement
)
{
MAsmJSCall
*
call
=
new
(
alloc
)
MAsmJSCall
(
desc
callee
spIncrement
)
;
call
-
>
setResultType
(
resultType
)
;
if
(
!
call
-
>
argRegs_
.
init
(
alloc
args
.
length
(
)
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
call
-
>
argRegs_
.
length
(
)
;
i
+
+
)
call
-
>
argRegs_
[
i
]
=
args
[
i
]
.
reg
;
if
(
!
call
-
>
init
(
alloc
call
-
>
argRegs_
.
length
(
)
+
(
callee
.
which
(
)
=
=
Callee
:
:
Dynamic
?
1
:
0
)
)
)
return
nullptr
;
for
(
size_t
i
=
0
;
i
<
call
-
>
argRegs_
.
length
(
)
;
i
+
+
)
call
-
>
initOperand
(
i
args
[
i
]
.
def
)
;
if
(
callee
.
which
(
)
=
=
Callee
:
:
Dynamic
)
call
-
>
initOperand
(
call
-
>
argRegs_
.
length
(
)
callee
.
dynamic
(
)
)
;
return
call
;
}
void
MSqrt
:
:
trySpecializeFloat32
(
TempAllocator
&
alloc
)
{
if
(
!
input
(
)
-
>
canProduceFloat32
(
)
|
|
!
CheckUsesAreFloat32Consumers
(
this
)
)
{
if
(
input
(
)
-
>
type
(
)
=
=
MIRType_Float32
)
ConvertDefinitionToDouble
<
0
>
(
alloc
input
(
)
this
)
;
return
;
}
setResultType
(
MIRType_Float32
)
;
specialization_
=
MIRType_Float32
;
}
MDefinition
*
MClz
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
num
(
)
-
>
isConstant
(
)
)
{
int32_t
n
=
num
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
if
(
n
=
=
0
)
return
MConstant
:
:
New
(
alloc
Int32Value
(
32
)
)
;
return
MConstant
:
:
New
(
alloc
Int32Value
(
mozilla
:
:
CountLeadingZeroes32
(
n
)
)
)
;
}
return
this
;
}
MDefinition
*
MBoundsCheck
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
if
(
index
(
)
-
>
isConstant
(
)
&
&
length
(
)
-
>
isConstant
(
)
)
{
uint32_t
len
=
length
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
uint32_t
idx
=
index
(
)
-
>
toConstant
(
)
-
>
toInt32
(
)
;
if
(
idx
+
uint32_t
(
minimum
(
)
)
<
len
&
&
idx
+
uint32_t
(
maximum
(
)
)
<
len
)
return
index
(
)
;
}
return
this
;
}
MDefinition
*
MTableSwitch
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
op
=
getOperand
(
0
)
;
if
(
numSuccessors
(
)
=
=
1
|
|
(
op
-
>
type
(
)
!
=
MIRType_Value
&
&
!
IsNumberType
(
op
-
>
type
(
)
)
)
)
return
MGoto
:
:
New
(
alloc
getDefault
(
)
)
;
if
(
MConstant
*
opConst
=
op
-
>
maybeConstantValue
(
)
)
{
if
(
op
-
>
type
(
)
=
=
MIRType_Int32
)
{
int32_t
i
=
opConst
-
>
toInt32
(
)
-
low_
;
MBasicBlock
*
target
;
if
(
size_t
(
i
)
<
numCases
(
)
)
target
=
getCase
(
size_t
(
i
)
)
;
else
target
=
getDefault
(
)
;
MOZ_ASSERT
(
target
)
;
return
MGoto
:
:
New
(
alloc
target
)
;
}
}
return
this
;
}
MDefinition
*
MArrayJoin
:
:
foldsTo
(
TempAllocator
&
alloc
)
{
MDefinition
*
arr
=
array
(
)
;
if
(
!
arr
-
>
isStringSplit
(
)
)
return
this
;
setRecoveredOnBailout
(
)
;
if
(
arr
-
>
hasLiveDefUses
(
)
)
{
setNotRecoveredOnBailout
(
)
;
return
this
;
}
arr
-
>
setRecoveredOnBailout
(
)
;
MDefinition
*
string
=
arr
-
>
toStringSplit
(
)
-
>
string
(
)
;
MDefinition
*
pattern
=
arr
-
>
toStringSplit
(
)
-
>
separator
(
)
;
MDefinition
*
replacement
=
sep
(
)
;
MStringReplace
*
substr
=
MStringReplace
:
:
New
(
alloc
string
pattern
replacement
)
;
substr
-
>
setFlatReplacement
(
)
;
return
substr
;
}
MConvertUnboxedObjectToNative
*
MConvertUnboxedObjectToNative
:
:
New
(
TempAllocator
&
alloc
MDefinition
*
obj
ObjectGroup
*
group
)
{
MConvertUnboxedObjectToNative
*
res
=
new
(
alloc
)
MConvertUnboxedObjectToNative
(
obj
group
)
;
ObjectGroup
*
nativeGroup
=
group
-
>
unboxedLayout
(
)
.
nativeGroup
(
)
;
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
types
&
&
!
types
-
>
unknownObject
(
)
)
{
TemporaryTypeSet
*
newTypes
=
types
-
>
cloneWithoutObjects
(
alloc
.
lifoAlloc
(
)
)
;
if
(
newTypes
)
{
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
if
(
key
-
>
unknownProperties
(
)
|
|
!
key
-
>
isGroup
(
)
|
|
key
-
>
group
(
)
!
=
group
)
newTypes
-
>
addType
(
TypeSet
:
:
ObjectType
(
key
)
alloc
.
lifoAlloc
(
)
)
;
else
newTypes
-
>
addType
(
TypeSet
:
:
ObjectType
(
nativeGroup
)
alloc
.
lifoAlloc
(
)
)
;
}
res
-
>
setResultTypeSet
(
newTypes
)
;
}
}
return
res
;
}
bool
jit
:
:
ElementAccessIsDenseNative
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
MDefinition
*
id
)
{
if
(
obj
-
>
mightBeType
(
MIRType_String
)
)
return
false
;
if
(
id
-
>
type
(
)
!
=
MIRType_Int32
&
&
id
-
>
type
(
)
!
=
MIRType_Double
)
return
false
;
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
)
return
false
;
const
Class
*
clasp
=
types
-
>
getKnownClass
(
constraints
)
;
return
clasp
&
&
clasp
-
>
isNative
(
)
&
&
!
IsTypedArrayClass
(
clasp
)
;
}
JSValueType
jit
:
:
UnboxedArrayElementType
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
MDefinition
*
id
)
{
if
(
obj
-
>
mightBeType
(
MIRType_String
)
)
return
JSVAL_TYPE_MAGIC
;
if
(
id
&
&
id
-
>
type
(
)
!
=
MIRType_Int32
&
&
id
-
>
type
(
)
!
=
MIRType_Double
)
return
JSVAL_TYPE_MAGIC
;
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
return
JSVAL_TYPE_MAGIC
;
JSValueType
elementType
=
JSVAL_TYPE_MAGIC
;
for
(
unsigned
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
if
(
key
-
>
unknownProperties
(
)
|
|
!
key
-
>
isGroup
(
)
)
return
JSVAL_TYPE_MAGIC
;
if
(
key
-
>
clasp
(
)
!
=
&
UnboxedArrayObject
:
:
class_
)
return
JSVAL_TYPE_MAGIC
;
const
UnboxedLayout
&
layout
=
key
-
>
group
(
)
-
>
unboxedLayout
(
)
;
if
(
layout
.
nativeGroup
(
)
)
return
JSVAL_TYPE_MAGIC
;
if
(
elementType
=
=
layout
.
elementType
(
)
|
|
elementType
=
=
JSVAL_TYPE_MAGIC
)
elementType
=
layout
.
elementType
(
)
;
else
return
JSVAL_TYPE_MAGIC
;
key
-
>
watchStateChangeForUnboxedConvertedToNative
(
constraints
)
;
}
return
elementType
;
}
bool
jit
:
:
ElementAccessIsTypedArray
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
MDefinition
*
id
Scalar
:
:
Type
*
arrayType
)
{
if
(
obj
-
>
mightBeType
(
MIRType_String
)
)
return
false
;
if
(
id
-
>
type
(
)
!
=
MIRType_Int32
&
&
id
-
>
type
(
)
!
=
MIRType_Double
)
return
false
;
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
)
return
false
;
*
arrayType
=
types
-
>
getTypedArrayType
(
constraints
)
;
return
*
arrayType
!
=
Scalar
:
:
MaxTypedArrayViewType
;
}
bool
jit
:
:
ElementAccessIsPacked
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
return
types
&
&
!
types
-
>
hasObjectFlags
(
constraints
OBJECT_FLAG_NON_PACKED
)
;
}
bool
jit
:
:
ElementAccessMightBeCopyOnWrite
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
return
!
types
|
|
types
-
>
hasObjectFlags
(
constraints
OBJECT_FLAG_COPY_ON_WRITE
)
;
}
bool
jit
:
:
ElementAccessHasExtraIndexedProperty
(
IonBuilder
*
builder
MDefinition
*
obj
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
hasObjectFlags
(
builder
-
>
constraints
(
)
OBJECT_FLAG_LENGTH_OVERFLOW
)
)
return
true
;
return
TypeCanHaveExtraIndexedProperties
(
builder
types
)
;
}
MIRType
jit
:
:
DenseNativeElementType
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
)
{
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
MIRType
elementType
=
MIRType_None
;
unsigned
count
=
types
-
>
getObjectCount
(
)
;
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
if
(
key
-
>
unknownProperties
(
)
)
return
MIRType_None
;
HeapTypeSetKey
elementTypes
=
key
-
>
property
(
JSID_VOID
)
;
MIRType
type
=
elementTypes
.
knownMIRType
(
constraints
)
;
if
(
type
=
=
MIRType_None
)
return
MIRType_None
;
if
(
elementType
=
=
MIRType_None
)
elementType
=
type
;
else
if
(
elementType
!
=
type
)
return
MIRType_None
;
}
return
elementType
;
}
static
BarrierKind
PropertyReadNeedsTypeBarrier
(
CompilerConstraintList
*
constraints
TypeSet
:
:
ObjectKey
*
key
PropertyName
*
name
TypeSet
*
observed
)
{
if
(
key
-
>
unknownProperties
(
)
|
|
observed
-
>
empty
(
)
|
|
key
-
>
clasp
(
)
-
>
isProxy
(
)
)
{
return
BarrierKind
:
:
TypeSet
;
}
jsid
id
=
name
?
NameToId
(
name
)
:
JSID_VOID
;
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
property
.
maybeTypes
(
)
)
{
if
(
!
TypeSetIncludes
(
observed
MIRType_Value
property
.
maybeTypes
(
)
)
)
{
if
(
property
.
maybeTypes
(
)
-
>
objectsAreSubset
(
observed
)
)
{
property
.
freeze
(
constraints
)
;
return
BarrierKind
:
:
TypeTagOnly
;
}
return
BarrierKind
:
:
TypeSet
;
}
}
if
(
key
-
>
isSingleton
(
)
)
{
JSObject
*
obj
=
key
-
>
singleton
(
)
;
if
(
name
&
&
CanHaveEmptyPropertyTypesForOwnProperty
(
obj
)
&
&
(
!
property
.
maybeTypes
(
)
|
|
property
.
maybeTypes
(
)
-
>
empty
(
)
)
)
{
return
BarrierKind
:
:
TypeSet
;
}
}
property
.
freeze
(
constraints
)
;
return
BarrierKind
:
:
NoBarrier
;
}
static
bool
ObjectSubsumes
(
TypeSet
:
:
ObjectKey
*
first
TypeSet
:
:
ObjectKey
*
second
)
{
if
(
first
-
>
isSingleton
(
)
|
|
second
-
>
isSingleton
(
)
|
|
first
-
>
clasp
(
)
!
=
second
-
>
clasp
(
)
|
|
first
-
>
unknownProperties
(
)
|
|
second
-
>
unknownProperties
(
)
)
{
return
false
;
}
if
(
first
-
>
clasp
(
)
=
=
&
ArrayObject
:
:
class_
)
{
HeapTypeSetKey
firstElements
=
first
-
>
property
(
JSID_VOID
)
;
HeapTypeSetKey
secondElements
=
second
-
>
property
(
JSID_VOID
)
;
return
firstElements
.
maybeTypes
(
)
&
&
secondElements
.
maybeTypes
(
)
&
&
firstElements
.
maybeTypes
(
)
-
>
equals
(
secondElements
.
maybeTypes
(
)
)
;
}
if
(
first
-
>
clasp
(
)
=
=
&
UnboxedArrayObject
:
:
class_
)
{
return
first
-
>
group
(
)
-
>
unboxedLayout
(
)
.
elementType
(
)
=
=
second
-
>
group
(
)
-
>
unboxedLayout
(
)
.
elementType
(
)
;
}
return
false
;
}
BarrierKind
jit
:
:
PropertyReadNeedsTypeBarrier
(
JSContext
*
propertycx
CompilerConstraintList
*
constraints
TypeSet
:
:
ObjectKey
*
key
PropertyName
*
name
TemporaryTypeSet
*
observed
bool
updateObserved
)
{
if
(
!
updateObserved
)
return
PropertyReadNeedsTypeBarrier
(
constraints
key
name
observed
)
;
if
(
observed
-
>
empty
(
)
&
&
name
)
{
JSObject
*
obj
;
if
(
key
-
>
isSingleton
(
)
)
obj
=
key
-
>
singleton
(
)
;
else
obj
=
key
-
>
proto
(
)
.
isLazy
(
)
?
nullptr
:
key
-
>
proto
(
)
.
toObjectOrNull
(
)
;
while
(
obj
)
{
if
(
!
obj
-
>
getClass
(
)
-
>
isNative
(
)
)
break
;
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
obj
)
;
if
(
propertycx
)
key
-
>
ensureTrackedProperty
(
propertycx
NameToId
(
name
)
)
;
if
(
!
key
-
>
unknownProperties
(
)
)
{
HeapTypeSetKey
property
=
key
-
>
property
(
NameToId
(
name
)
)
;
if
(
property
.
maybeTypes
(
)
)
{
TypeSet
:
:
TypeList
types
;
if
(
!
property
.
maybeTypes
(
)
-
>
enumerateTypes
(
&
types
)
)
break
;
if
(
types
.
length
(
)
)
{
observed
-
>
addType
(
types
[
0
]
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
)
;
break
;
}
}
}
obj
=
obj
-
>
getProto
(
)
;
}
}
if
(
!
key
-
>
unknownProperties
(
)
)
{
HeapTypeSetKey
property
=
key
-
>
property
(
name
?
NameToId
(
name
)
:
JSID_VOID
)
;
if
(
property
.
maybeTypes
(
)
&
&
!
property
.
maybeTypes
(
)
-
>
unknownObject
(
)
)
{
for
(
size_t
i
=
0
;
i
<
property
.
maybeTypes
(
)
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
property
.
maybeTypes
(
)
-
>
getObject
(
i
)
;
if
(
!
key
|
|
observed
-
>
unknownObject
(
)
)
continue
;
for
(
size_t
j
=
0
;
j
<
observed
-
>
getObjectCount
(
)
;
j
+
+
)
{
TypeSet
:
:
ObjectKey
*
observedKey
=
observed
-
>
getObject
(
j
)
;
if
(
observedKey
&
&
ObjectSubsumes
(
observedKey
key
)
)
{
observed
-
>
addType
(
TypeSet
:
:
ObjectType
(
key
)
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
)
;
break
;
}
}
}
}
}
return
PropertyReadNeedsTypeBarrier
(
constraints
key
name
observed
)
;
}
BarrierKind
jit
:
:
PropertyReadNeedsTypeBarrier
(
JSContext
*
propertycx
CompilerConstraintList
*
constraints
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
observed
)
{
if
(
observed
-
>
unknown
(
)
)
return
BarrierKind
:
:
NoBarrier
;
TypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
return
BarrierKind
:
:
TypeSet
;
BarrierKind
res
=
BarrierKind
:
:
NoBarrier
;
bool
updateObserved
=
types
-
>
getObjectCount
(
)
=
=
1
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
if
(
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
)
{
BarrierKind
kind
=
PropertyReadNeedsTypeBarrier
(
propertycx
constraints
key
name
observed
updateObserved
)
;
if
(
kind
=
=
BarrierKind
:
:
TypeSet
)
return
BarrierKind
:
:
TypeSet
;
if
(
kind
=
=
BarrierKind
:
:
TypeTagOnly
)
{
MOZ_ASSERT
(
res
=
=
BarrierKind
:
:
NoBarrier
|
|
res
=
=
BarrierKind
:
:
TypeTagOnly
)
;
res
=
BarrierKind
:
:
TypeTagOnly
;
}
else
{
MOZ_ASSERT
(
kind
=
=
BarrierKind
:
:
NoBarrier
)
;
}
}
}
return
res
;
}
BarrierKind
jit
:
:
PropertyReadOnPrototypeNeedsTypeBarrier
(
IonBuilder
*
builder
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
observed
)
{
if
(
observed
-
>
unknown
(
)
)
return
BarrierKind
:
:
NoBarrier
;
TypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
return
BarrierKind
:
:
TypeSet
;
BarrierKind
res
=
BarrierKind
:
:
NoBarrier
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
while
(
true
)
{
if
(
!
key
-
>
hasStableClassAndProto
(
builder
-
>
constraints
(
)
)
)
return
BarrierKind
:
:
TypeSet
;
if
(
!
key
-
>
proto
(
)
.
isObject
(
)
)
break
;
JSObject
*
proto
=
builder
-
>
checkNurseryObject
(
key
-
>
proto
(
)
.
toObject
(
)
)
;
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
proto
)
;
BarrierKind
kind
=
PropertyReadNeedsTypeBarrier
(
builder
-
>
constraints
(
)
key
name
observed
)
;
if
(
kind
=
=
BarrierKind
:
:
TypeSet
)
return
BarrierKind
:
:
TypeSet
;
if
(
kind
=
=
BarrierKind
:
:
TypeTagOnly
)
{
MOZ_ASSERT
(
res
=
=
BarrierKind
:
:
NoBarrier
|
|
res
=
=
BarrierKind
:
:
TypeTagOnly
)
;
res
=
BarrierKind
:
:
TypeTagOnly
;
}
else
{
MOZ_ASSERT
(
kind
=
=
BarrierKind
:
:
NoBarrier
)
;
}
}
}
return
res
;
}
bool
jit
:
:
PropertyReadIsIdempotent
(
CompilerConstraintList
*
constraints
MDefinition
*
obj
PropertyName
*
name
)
{
TypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
if
(
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
)
{
if
(
key
-
>
unknownProperties
(
)
)
return
false
;
HeapTypeSetKey
property
=
key
-
>
property
(
NameToId
(
name
)
)
;
if
(
property
.
nonData
(
constraints
)
)
return
false
;
}
}
return
true
;
}
void
jit
:
:
AddObjectsForPropertyRead
(
MDefinition
*
obj
PropertyName
*
name
TemporaryTypeSet
*
observed
)
{
LifoAlloc
*
alloc
=
GetJitContext
(
)
-
>
temp
-
>
lifoAlloc
(
)
;
TemporaryTypeSet
*
types
=
obj
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
{
observed
-
>
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc
)
;
return
;
}
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
if
(
key
-
>
unknownProperties
(
)
)
{
observed
-
>
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc
)
;
return
;
}
jsid
id
=
name
?
NameToId
(
name
)
:
JSID_VOID
;
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
HeapTypeSet
*
types
=
property
.
maybeTypes
(
)
;
if
(
!
types
)
continue
;
if
(
types
-
>
unknownObject
(
)
)
{
observed
-
>
addType
(
TypeSet
:
:
AnyObjectType
(
)
alloc
)
;
return
;
}
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
if
(
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
)
observed
-
>
addType
(
TypeSet
:
:
ObjectType
(
key
)
alloc
)
;
}
}
}
static
bool
PrototypeHasIndexedProperty
(
IonBuilder
*
builder
JSObject
*
obj
)
{
do
{
TypeSet
:
:
ObjectKey
*
key
=
TypeSet
:
:
ObjectKey
:
:
get
(
builder
-
>
checkNurseryObject
(
obj
)
)
;
if
(
ClassCanHaveExtraProperties
(
key
-
>
clasp
(
)
)
)
return
true
;
if
(
key
-
>
unknownProperties
(
)
)
return
true
;
HeapTypeSetKey
index
=
key
-
>
property
(
JSID_VOID
)
;
if
(
index
.
nonData
(
builder
-
>
constraints
(
)
)
|
|
index
.
isOwnProperty
(
builder
-
>
constraints
(
)
)
)
return
true
;
obj
=
obj
-
>
getProto
(
)
;
}
while
(
obj
)
;
return
false
;
}
bool
jit
:
:
ArrayPrototypeHasIndexedProperty
(
IonBuilder
*
builder
JSScript
*
script
)
{
if
(
JSObject
*
proto
=
script
-
>
global
(
)
.
maybeGetArrayPrototype
(
)
)
return
PrototypeHasIndexedProperty
(
builder
proto
)
;
return
true
;
}
bool
jit
:
:
TypeCanHaveExtraIndexedProperties
(
IonBuilder
*
builder
TemporaryTypeSet
*
types
)
{
const
Class
*
clasp
=
types
-
>
getKnownClass
(
builder
-
>
constraints
(
)
)
;
if
(
!
clasp
|
|
(
ClassCanHaveExtraProperties
(
clasp
)
&
&
!
IsTypedArrayClass
(
clasp
)
)
)
return
true
;
if
(
types
-
>
hasObjectFlags
(
builder
-
>
constraints
(
)
OBJECT_FLAG_SPARSE_INDEXES
)
)
return
true
;
JSObject
*
proto
;
if
(
!
types
-
>
getCommonPrototype
(
builder
-
>
constraints
(
)
&
proto
)
)
return
true
;
if
(
!
proto
)
return
false
;
return
PrototypeHasIndexedProperty
(
builder
proto
)
;
}
static
bool
PropertyTypeIncludes
(
TempAllocator
&
alloc
HeapTypeSetKey
property
MDefinition
*
value
MIRType
implicitType
)
{
TypeSet
*
types
=
property
.
maybeTypes
(
)
;
if
(
implicitType
!
=
MIRType_None
)
{
TypeSet
:
:
Type
newType
=
TypeSet
:
:
PrimitiveType
(
ValueTypeFromMIRType
(
implicitType
)
)
;
if
(
types
)
types
=
types
-
>
clone
(
alloc
.
lifoAlloc
(
)
)
;
else
types
=
alloc
.
lifoAlloc
(
)
-
>
new_
<
TemporaryTypeSet
>
(
)
;
types
-
>
addType
(
newType
alloc
.
lifoAlloc
(
)
)
;
}
return
TypeSetIncludes
(
types
value
-
>
type
(
)
value
-
>
resultTypeSet
(
)
)
;
}
static
bool
TryAddTypeBarrierForWrite
(
TempAllocator
&
alloc
CompilerConstraintList
*
constraints
MBasicBlock
*
current
TemporaryTypeSet
*
objTypes
PropertyName
*
name
MDefinition
*
*
pvalue
MIRType
implicitType
)
{
Maybe
<
HeapTypeSetKey
>
aggregateProperty
;
for
(
size_t
i
=
0
;
i
<
objTypes
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
objTypes
-
>
getObject
(
i
)
;
if
(
!
key
)
continue
;
if
(
key
-
>
unknownProperties
(
)
)
return
false
;
jsid
id
=
name
?
NameToId
(
name
)
:
JSID_VOID
;
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
!
property
.
maybeTypes
(
)
|
|
property
.
couldBeConstant
(
constraints
)
)
return
false
;
if
(
PropertyTypeIncludes
(
alloc
property
*
pvalue
implicitType
)
)
return
false
;
property
.
freeze
(
constraints
)
;
if
(
!
aggregateProperty
)
{
aggregateProperty
.
emplace
(
property
)
;
}
else
{
if
(
!
aggregateProperty
-
>
maybeTypes
(
)
-
>
equals
(
property
.
maybeTypes
(
)
)
)
return
false
;
}
}
MOZ_ASSERT
(
aggregateProperty
)
;
MIRType
propertyType
=
aggregateProperty
-
>
knownMIRType
(
constraints
)
;
switch
(
propertyType
)
{
case
MIRType_Boolean
:
case
MIRType_Int32
:
case
MIRType_Double
:
case
MIRType_String
:
case
MIRType_Symbol
:
{
if
(
!
(
*
pvalue
)
-
>
mightBeType
(
propertyType
)
)
{
MOZ_ASSERT_IF
(
(
*
pvalue
)
-
>
type
(
)
!
=
MIRType_Value
(
*
pvalue
)
-
>
type
(
)
!
=
propertyType
)
;
return
false
;
}
MInstruction
*
ins
=
MUnbox
:
:
New
(
alloc
*
pvalue
propertyType
MUnbox
:
:
Fallible
)
;
current
-
>
add
(
ins
)
;
*
pvalue
=
ins
;
return
true
;
}
default
:
;
}
if
(
(
*
pvalue
)
-
>
type
(
)
!
=
MIRType_Value
)
return
false
;
TemporaryTypeSet
*
types
=
aggregateProperty
-
>
maybeTypes
(
)
-
>
clone
(
alloc
.
lifoAlloc
(
)
)
;
if
(
!
types
)
return
false
;
BarrierKind
kind
=
BarrierKind
:
:
TypeSet
;
if
(
(
*
pvalue
)
-
>
resultTypeSet
(
)
&
&
(
*
pvalue
)
-
>
resultTypeSet
(
)
-
>
objectsAreSubset
(
types
)
)
kind
=
BarrierKind
:
:
TypeTagOnly
;
MInstruction
*
ins
=
MMonitorTypes
:
:
New
(
alloc
*
pvalue
types
kind
)
;
current
-
>
add
(
ins
)
;
return
true
;
}
static
MInstruction
*
AddGroupGuard
(
TempAllocator
&
alloc
MBasicBlock
*
current
MDefinition
*
obj
TypeSet
:
:
ObjectKey
*
key
bool
bailOnEquality
)
{
MInstruction
*
guard
;
if
(
key
-
>
isGroup
(
)
)
{
guard
=
MGuardObjectGroup
:
:
New
(
alloc
obj
key
-
>
group
(
)
bailOnEquality
Bailout_ObjectIdentityOrTypeGuard
)
;
}
else
{
MConstant
*
singletonConst
=
MConstant
:
:
NewConstraintlessObject
(
alloc
key
-
>
singleton
(
)
)
;
current
-
>
add
(
singletonConst
)
;
guard
=
MGuardObjectIdentity
:
:
New
(
alloc
obj
singletonConst
bailOnEquality
)
;
}
current
-
>
add
(
guard
)
;
guard
-
>
setNotMovable
(
)
;
return
guard
;
}
bool
jit
:
:
CanWriteProperty
(
TempAllocator
&
alloc
CompilerConstraintList
*
constraints
HeapTypeSetKey
property
MDefinition
*
value
MIRType
implicitType
)
{
if
(
property
.
couldBeConstant
(
constraints
)
)
return
false
;
return
PropertyTypeIncludes
(
alloc
property
value
implicitType
)
;
}
bool
jit
:
:
PropertyWriteNeedsTypeBarrier
(
TempAllocator
&
alloc
CompilerConstraintList
*
constraints
MBasicBlock
*
current
MDefinition
*
*
pobj
PropertyName
*
name
MDefinition
*
*
pvalue
bool
canModify
MIRType
implicitType
)
{
TemporaryTypeSet
*
types
=
(
*
pobj
)
-
>
resultTypeSet
(
)
;
if
(
!
types
|
|
types
-
>
unknownObject
(
)
)
return
true
;
bool
success
=
true
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
|
|
key
-
>
unknownProperties
(
)
)
continue
;
if
(
!
name
&
&
IsTypedArrayClass
(
key
-
>
clasp
(
)
)
)
continue
;
jsid
id
=
name
?
NameToId
(
name
)
:
JSID_VOID
;
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
!
CanWriteProperty
(
alloc
constraints
property
*
pvalue
implicitType
)
)
{
if
(
!
canModify
)
return
true
;
success
=
TryAddTypeBarrierForWrite
(
alloc
constraints
current
types
name
pvalue
implicitType
)
;
break
;
}
}
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
key
&
&
key
-
>
isGroup
(
)
&
&
key
-
>
group
(
)
-
>
maybeUnboxedLayout
(
)
)
{
const
UnboxedLayout
&
layout
=
key
-
>
group
(
)
-
>
unboxedLayout
(
)
;
if
(
name
)
{
const
UnboxedLayout
:
:
Property
*
property
=
layout
.
lookup
(
name
)
;
if
(
property
&
&
!
CanStoreUnboxedType
(
alloc
property
-
>
type
*
pvalue
)
)
return
true
;
}
else
{
if
(
layout
.
isArray
(
)
&
&
!
CanStoreUnboxedType
(
alloc
layout
.
elementType
(
)
*
pvalue
)
)
return
true
;
}
}
}
if
(
success
)
return
false
;
if
(
types
-
>
getObjectCount
(
)
<
=
1
)
return
true
;
TypeSet
:
:
ObjectKey
*
excluded
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
types
-
>
getObjectCount
(
)
;
i
+
+
)
{
TypeSet
:
:
ObjectKey
*
key
=
types
-
>
getObject
(
i
)
;
if
(
!
key
|
|
key
-
>
unknownProperties
(
)
)
continue
;
if
(
!
name
&
&
IsTypedArrayClass
(
key
-
>
clasp
(
)
)
)
continue
;
jsid
id
=
name
?
NameToId
(
name
)
:
JSID_VOID
;
HeapTypeSetKey
property
=
key
-
>
property
(
id
)
;
if
(
CanWriteProperty
(
alloc
constraints
property
*
pvalue
implicitType
)
)
continue
;
if
(
(
property
.
maybeTypes
(
)
&
&
!
property
.
maybeTypes
(
)
-
>
empty
(
)
)
|
|
excluded
)
return
true
;
excluded
=
key
;
}
MOZ_ASSERT
(
excluded
)
;
if
(
excluded
-
>
isGroup
(
)
)
{
if
(
UnboxedLayout
*
layout
=
excluded
-
>
group
(
)
-
>
maybeUnboxedLayout
(
)
)
{
if
(
layout
-
>
nativeGroup
(
)
)
return
true
;
excluded
-
>
watchStateChangeForUnboxedConvertedToNative
(
constraints
)
;
}
}
*
pobj
=
AddGroupGuard
(
alloc
current
*
pobj
excluded
true
)
;
return
false
;
}
