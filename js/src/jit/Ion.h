#
ifndef
jit_Ion_h
#
define
jit_Ion_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
jit
/
CompileWrappers
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
TypeInference
.
h
"
namespace
js
{
namespace
jit
{
class
TempAllocator
;
enum
MethodStatus
{
Method_Error
Method_CantCompile
Method_Skipped
Method_Compiled
}
;
enum
class
AbortReason
:
uint8_t
{
Alloc
Inlining
PreliminaryObjects
Disable
Error
NoAbort
}
;
template
<
typename
V
>
using
AbortReasonOr
=
mozilla
:
:
Result
<
V
AbortReason
>
;
using
mozilla
:
:
Err
;
using
mozilla
:
:
Ok
;
static_assert
(
sizeof
(
AbortReasonOr
<
Ok
>
)
<
=
sizeof
(
uintptr_t
)
"
Unexpected
size
of
AbortReasonOr
<
Ok
>
"
)
;
static_assert
(
sizeof
(
AbortReasonOr
<
bool
>
)
<
=
sizeof
(
uintptr_t
)
"
Unexpected
size
of
AbortReasonOr
<
bool
>
"
)
;
class
JitContext
{
JitContext
*
prev_
=
nullptr
;
CompileRealm
*
realm_
=
nullptr
;
int
assemblerCount_
=
0
;
#
ifdef
DEBUG
bool
inIonBackend_
=
false
;
bool
inIonBackendSafeForMinorGC_
=
false
;
bool
isCompilingWasm_
=
false
;
bool
oom_
=
false
;
#
endif
public
:
JSContext
*
cx
=
nullptr
;
TempAllocator
*
temp
=
nullptr
;
CompileRuntime
*
runtime
=
nullptr
;
JitContext
(
JSContext
*
cx
TempAllocator
*
temp
)
;
JitContext
(
CompileRuntime
*
rt
CompileRealm
*
realm
TempAllocator
*
temp
)
;
explicit
JitContext
(
TempAllocator
*
temp
)
;
JitContext
(
)
;
~
JitContext
(
)
;
int
getNextAssemblerId
(
)
{
return
assemblerCount_
+
+
;
}
CompileRealm
*
maybeRealm
(
)
const
{
return
realm_
;
}
CompileRealm
*
realm
(
)
const
{
MOZ_ASSERT
(
maybeRealm
(
)
)
;
return
maybeRealm
(
)
;
}
#
ifdef
DEBUG
bool
isCompilingWasm
(
)
{
return
isCompilingWasm_
;
}
bool
hasOOM
(
)
{
return
oom_
;
}
void
setOOM
(
)
{
oom_
=
true
;
}
bool
inIonBackend
(
)
const
{
return
inIonBackend_
;
}
bool
inIonBackendSafeForMinorGC
(
)
const
{
return
inIonBackendSafeForMinorGC_
;
}
void
enterIonBackend
(
bool
safeForMinorGC
)
{
MOZ_ASSERT
(
!
inIonBackend_
)
;
MOZ_ASSERT
(
!
inIonBackendSafeForMinorGC_
)
;
inIonBackend_
=
true
;
inIonBackendSafeForMinorGC_
=
safeForMinorGC
;
}
void
leaveIonBackend
(
)
{
MOZ_ASSERT
(
inIonBackend_
)
;
inIonBackend_
=
false
;
inIonBackendSafeForMinorGC_
=
false
;
}
#
endif
}
;
MOZ_MUST_USE
bool
InitializeJit
(
)
;
JitContext
*
GetJitContext
(
)
;
JitContext
*
MaybeGetJitContext
(
)
;
void
SetJitContext
(
JitContext
*
ctx
)
;
bool
CanIonCompileScript
(
JSContext
*
cx
JSScript
*
script
)
;
bool
CanIonInlineScript
(
JSScript
*
script
)
;
MOZ_MUST_USE
bool
IonCompileScriptForBaselineAtEntry
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
struct
IonOsrTempData
{
void
*
jitcode
;
uint8_t
*
baselineFrame
;
static
constexpr
size_t
offsetOfJitCode
(
)
{
return
offsetof
(
IonOsrTempData
jitcode
)
;
}
static
constexpr
size_t
offsetOfBaselineFrame
(
)
{
return
offsetof
(
IonOsrTempData
baselineFrame
)
;
}
}
;
MOZ_MUST_USE
bool
IonCompileScriptForBaselineOSR
(
JSContext
*
cx
BaselineFrame
*
frame
uint32_t
frameSize
jsbytecode
*
pc
IonOsrTempData
*
*
infoPtr
)
;
MethodStatus
CanEnterIon
(
JSContext
*
cx
RunState
&
state
)
;
MethodStatus
Recompile
(
JSContext
*
cx
HandleScript
script
bool
force
)
;
enum
JitExecStatus
{
JitExec_Aborted
JitExec_Error
JitExec_Ok
}
;
static
inline
bool
IsErrorStatus
(
JitExecStatus
status
)
{
return
status
=
=
JitExec_Error
|
|
status
=
=
JitExec_Aborted
;
}
struct
EnterJitData
;
void
Invalidate
(
TypeZone
&
types
JSFreeOp
*
fop
const
RecompileInfoVector
&
invalid
bool
resetUses
=
true
bool
cancelOffThread
=
true
)
;
void
Invalidate
(
JSContext
*
cx
const
RecompileInfoVector
&
invalid
bool
resetUses
=
true
bool
cancelOffThread
=
true
)
;
void
Invalidate
(
JSContext
*
cx
JSScript
*
script
bool
resetUses
=
true
bool
cancelOffThread
=
true
)
;
class
IonCompileTask
;
class
MIRGenerator
;
class
LIRGraph
;
class
CodeGenerator
;
class
LazyLinkExitFrameLayout
;
MOZ_MUST_USE
bool
OptimizeMIR
(
MIRGenerator
*
mir
)
;
LIRGraph
*
GenerateLIR
(
MIRGenerator
*
mir
)
;
CodeGenerator
*
GenerateCode
(
MIRGenerator
*
mir
LIRGraph
*
lir
)
;
CodeGenerator
*
CompileBackEnd
(
MIRGenerator
*
mir
)
;
void
AttachFinishedCompilations
(
JSContext
*
cx
)
;
void
FinishOffThreadTask
(
JSRuntime
*
runtime
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
FreeIonCompileTask
(
IonCompileTask
*
task
)
;
void
LinkIonScript
(
JSContext
*
cx
HandleScript
calleescript
)
;
uint8_t
*
LazyLinkTopActivation
(
JSContext
*
cx
LazyLinkExitFrameLayout
*
frame
)
;
inline
bool
IsIonInlinableGetterOrSetterOp
(
JSOp
op
)
{
return
IsGetPropOp
(
op
)
|
|
IsGetElemOp
(
op
)
|
|
IsSetPropOp
(
op
)
;
}
inline
bool
IsIonInlinableOp
(
JSOp
op
)
{
return
(
IsInvokeOp
(
op
)
&
&
!
IsSpreadOp
(
op
)
)
|
|
IsIonInlinableGetterOrSetterOp
(
op
)
;
}
inline
bool
TooManyActualArguments
(
unsigned
nargs
)
{
return
nargs
>
JitOptions
.
maxStackArgs
;
}
inline
bool
TooManyFormalArguments
(
unsigned
nargs
)
{
return
nargs
>
=
SNAPSHOT_MAX_NARGS
|
|
TooManyActualArguments
(
nargs
)
;
}
inline
size_t
NumLocalsAndArgs
(
JSScript
*
script
)
{
size_t
num
=
1
+
script
-
>
nfixed
(
)
;
if
(
JSFunction
*
fun
=
script
-
>
function
(
)
)
{
num
+
=
fun
-
>
nargs
(
)
;
}
return
num
;
}
class
MOZ_RAII
AutoEnterIonBackend
{
public
:
explicit
AutoEnterIonBackend
(
bool
safeForMinorGC
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
DEBUG
JitContext
*
jcx
=
GetJitContext
(
)
;
jcx
-
>
enterIonBackend
(
safeForMinorGC
)
;
#
endif
}
#
ifdef
DEBUG
~
AutoEnterIonBackend
(
)
{
JitContext
*
jcx
=
GetJitContext
(
)
;
jcx
-
>
leaveIonBackend
(
)
;
}
#
endif
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
bool
OffThreadCompilationAvailable
(
JSContext
*
cx
)
;
void
ForbidCompilation
(
JSContext
*
cx
JSScript
*
script
)
;
size_t
SizeOfIonData
(
JSScript
*
script
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
bool
JitSupportsSimd
(
)
;
bool
JitSupportsAtomics
(
)
;
inline
bool
IsIonEnabled
(
JSContext
*
cx
)
{
return
IsBaselineJitEnabled
(
)
&
&
JitOptions
.
ion
&
&
!
cx
-
>
options
(
)
.
disableIon
(
)
;
}
}
}
#
endif
