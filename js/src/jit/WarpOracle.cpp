#
include
"
jit
/
WarpOracle
.
h
"
#
include
"
jit
/
JitScript
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
WarpBuilder
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
BytecodeIterator
-
inl
.
h
"
#
include
"
vm
/
BytecodeLocation
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
WarpOracle
:
:
WarpOracle
(
JSContext
*
cx
MIRGenerator
&
mirGen
HandleScript
script
)
:
cx_
(
cx
)
mirGen_
(
mirGen
)
alloc_
(
mirGen
.
alloc
(
)
)
script_
(
script
)
{
}
mozilla
:
:
GenericErrorResult
<
AbortReason
>
WarpOracle
:
:
abort
(
AbortReason
r
)
{
auto
res
=
mirGen_
.
abort
(
r
)
;
JitSpew
(
JitSpew_IonAbort
"
aborted
%
s
"
script_
-
>
filename
(
)
)
;
return
res
;
}
mozilla
:
:
GenericErrorResult
<
AbortReason
>
WarpOracle
:
:
abort
(
AbortReason
r
const
char
*
message
.
.
.
)
{
va_list
ap
;
va_start
(
ap
message
)
;
auto
res
=
mirGen_
.
abortFmt
(
r
message
ap
)
;
va_end
(
ap
)
;
JitSpew
(
JitSpew_IonAbort
"
aborted
%
s
"
script_
-
>
filename
(
)
)
;
return
res
;
}
AbortReasonOr
<
WarpSnapshot
*
>
WarpOracle
:
:
createSnapshot
(
)
{
WarpScriptSnapshot
*
scriptSnapshot
;
MOZ_TRY_VAR
(
scriptSnapshot
createScriptSnapshot
(
script_
)
)
;
auto
*
snapshot
=
alloc_
.
lifoAlloc
(
)
-
>
new_
<
WarpSnapshot
>
(
scriptSnapshot
)
;
if
(
!
snapshot
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
snapshot
;
}
AbortReasonOr
<
WarpScriptSnapshot
*
>
WarpOracle
:
:
createScriptSnapshot
(
HandleScript
script
)
{
MOZ_ASSERT
(
script
-
>
hasJitScript
(
)
)
;
if
(
!
script
-
>
jitScript
(
)
-
>
ensureHasCachedIonData
(
cx_
script
)
)
{
return
abort
(
AbortReason
:
:
Error
)
;
}
for
(
const
BytecodeLocation
&
it
:
AllBytecodesIterable
(
script
)
)
{
JSOp
op
=
it
.
getOp
(
)
;
switch
(
op
)
{
#
define
OP_CASE
(
OP
)
case
JSOp
:
:
OP
:
WARP_OPCODE_LIST
(
OP_CASE
)
#
undef
OP_CASE
break
;
default
:
#
ifdef
DEBUG
return
abort
(
AbortReason
:
:
Disable
"
Unsupported
opcode
:
%
s
"
CodeName
(
op
)
)
;
#
else
return
abort
(
AbortReason
:
:
Disable
"
Unsupported
opcode
:
%
u
"
uint8_t
(
op
)
)
;
#
endif
}
}
auto
*
scriptSnapshot
=
alloc_
.
lifoAlloc
(
)
-
>
new_
<
WarpScriptSnapshot
>
(
script
)
;
if
(
!
scriptSnapshot
)
{
return
abort
(
AbortReason
:
:
Alloc
)
;
}
return
scriptSnapshot
;
}
