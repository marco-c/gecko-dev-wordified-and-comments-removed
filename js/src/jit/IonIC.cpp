#
include
"
jit
/
IonIC
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
jit
/
CacheIRCompiler
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
Maybe
;
void
IonIC
:
:
updateBaseAddress
(
JitCode
*
code
MacroAssembler
&
masm
)
{
fallbackLabel_
.
repoint
(
code
&
masm
)
;
rejoinLabel_
.
repoint
(
code
&
masm
)
;
codeRaw_
=
fallbackLabel_
.
raw
(
)
;
}
Register
IonIC
:
:
scratchRegisterForEntryJump
(
)
{
switch
(
kind_
)
{
case
CacheKind
:
:
GetProp
:
case
CacheKind
:
:
GetElem
:
{
Register
temp
=
asGetPropertyIC
(
)
-
>
maybeTemp
(
)
;
if
(
temp
!
=
InvalidReg
)
return
temp
;
TypedOrValueRegister
output
=
asGetPropertyIC
(
)
-
>
output
(
)
;
return
output
.
hasValue
(
)
?
output
.
valueReg
(
)
.
scratchReg
(
)
:
output
.
typedReg
(
)
.
gpr
(
)
;
}
case
CacheKind
:
:
SetProp
:
case
CacheKind
:
:
SetElem
:
return
asSetPropertyIC
(
)
-
>
temp1
(
)
;
case
CacheKind
:
:
GetName
:
case
CacheKind
:
:
In
:
MOZ_CRASH
(
"
Baseline
-
specific
for
now
"
)
;
}
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
void
IonIC
:
:
reset
(
Zone
*
zone
)
{
if
(
firstStub_
&
&
zone
-
>
needsIncrementalBarrier
(
)
)
{
trace
(
zone
-
>
barrierTracer
(
)
)
;
}
#
ifdef
JS_CRASH_DIAGNOSTICS
IonICStub
*
stub
=
firstStub_
;
while
(
stub
)
{
IonICStub
*
next
=
stub
-
>
next
(
)
;
stub
-
>
poison
(
)
;
stub
=
next
;
}
#
endif
firstStub_
=
nullptr
;
codeRaw_
=
fallbackLabel_
.
raw
(
)
;
numStubs_
=
0
;
}
void
IonIC
:
:
trace
(
JSTracer
*
trc
)
{
if
(
script_
)
TraceManuallyBarrieredEdge
(
trc
&
script_
"
IonIC
:
:
script_
"
)
;
uint8_t
*
nextCodeRaw
=
codeRaw_
;
for
(
IonICStub
*
stub
=
firstStub_
;
stub
;
stub
=
stub
-
>
next
(
)
)
{
JitCode
*
code
=
JitCode
:
:
FromExecutable
(
nextCodeRaw
)
;
TraceManuallyBarrieredEdge
(
trc
&
code
"
ion
-
ic
-
code
"
)
;
TraceCacheIRStub
(
trc
stub
stub
-
>
stubInfo
(
)
)
;
nextCodeRaw
=
stub
-
>
nextCodeRaw
(
)
;
}
MOZ_ASSERT
(
nextCodeRaw
=
=
fallbackLabel_
.
raw
(
)
)
;
}
void
IonIC
:
:
togglePreBarriers
(
bool
enabled
ReprotectCode
reprotect
)
{
uint8_t
*
nextCodeRaw
=
codeRaw_
;
for
(
IonICStub
*
stub
=
firstStub_
;
stub
;
stub
=
stub
-
>
next
(
)
)
{
JitCode
*
code
=
JitCode
:
:
FromExecutable
(
nextCodeRaw
)
;
code
-
>
togglePreBarriers
(
enabled
reprotect
)
;
nextCodeRaw
=
stub
-
>
nextCodeRaw
(
)
;
}
MOZ_ASSERT
(
nextCodeRaw
=
=
fallbackLabel_
.
raw
(
)
)
;
}
void
IonGetPropertyIC
:
:
maybeDisable
(
Zone
*
zone
bool
attached
)
{
if
(
attached
)
{
failedUpdates_
=
0
;
return
;
}
if
(
!
canAttachStub
(
)
&
&
kind
(
)
=
=
CacheKind
:
:
GetProp
)
{
return
;
}
if
(
+
+
failedUpdates_
>
MAX_FAILED_UPDATES
)
{
JitSpew
(
JitSpew_IonIC
"
Disable
inline
cache
"
)
;
disable
(
zone
)
;
}
}
bool
IonGetPropertyIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
IonGetPropertyIC
*
ic
HandleValue
val
HandleValue
idVal
MutableHandleValue
res
)
{
IonScript
*
ionScript
=
outerScript
-
>
ionScript
(
)
;
AutoDetectInvalidation
adi
(
cx
res
ionScript
)
;
if
(
ic
-
>
idempotent
(
)
)
adi
.
disable
(
)
;
bool
attached
=
false
;
if
(
!
JitOptions
.
disableCacheIR
&
&
!
ic
-
>
disabled
(
)
)
{
if
(
ic
-
>
canAttachStub
(
)
)
{
CanAttachGetter
canAttachGetter
=
ic
-
>
monitoredResult
(
)
?
CanAttachGetter
:
:
Yes
:
CanAttachGetter
:
:
No
;
jsbytecode
*
pc
=
ic
-
>
idempotent
(
)
?
nullptr
:
ic
-
>
pc
(
)
;
bool
isTemporarilyUnoptimizable
;
GetPropIRGenerator
gen
(
cx
outerScript
pc
ic
-
>
kind
(
)
&
isTemporarilyUnoptimizable
val
idVal
canAttachGetter
)
;
if
(
ic
-
>
idempotent
(
)
?
gen
.
tryAttachIdempotentStub
(
)
:
gen
.
tryAttachStub
(
)
)
{
attached
=
ic
-
>
attachCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ionScript
)
;
}
}
ic
-
>
maybeDisable
(
cx
-
>
zone
(
)
attached
)
;
}
if
(
!
attached
&
&
ic
-
>
idempotent
(
)
)
{
JitSpew
(
JitSpew_IonIC
"
Invalidating
from
idempotent
cache
%
s
:
%
"
PRIuSIZE
outerScript
-
>
filename
(
)
outerScript
-
>
lineno
(
)
)
;
outerScript
-
>
setInvalidatedIdempotentCache
(
)
;
if
(
outerScript
-
>
hasIonScript
(
)
)
Invalidate
(
cx
outerScript
)
;
return
true
;
}
if
(
ic
-
>
kind
(
)
=
=
CacheKind
:
:
GetProp
)
{
RootedPropertyName
name
(
cx
idVal
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
;
if
(
!
GetProperty
(
cx
val
name
res
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
ic
-
>
kind
(
)
=
=
CacheKind
:
:
GetElem
)
;
if
(
!
GetElementOperation
(
cx
JSOp
(
*
ic
-
>
pc
(
)
)
val
idVal
res
)
)
return
false
;
}
if
(
!
ic
-
>
idempotent
(
)
)
{
if
(
!
ic
-
>
monitoredResult
(
)
)
TypeScript
:
:
Monitor
(
cx
ic
-
>
script
(
)
ic
-
>
pc
(
)
res
)
;
}
return
true
;
}
bool
IonSetPropertyIC
:
:
update
(
JSContext
*
cx
HandleScript
outerScript
IonSetPropertyIC
*
ic
HandleObject
obj
HandleValue
idVal
HandleValue
rhs
)
{
RootedShape
oldShape
(
cx
)
;
RootedObjectGroup
oldGroup
(
cx
)
;
IonScript
*
ionScript
=
outerScript
-
>
ionScript
(
)
;
bool
attached
=
false
;
if
(
!
JitOptions
.
disableCacheIR
&
&
ic
-
>
canAttachStub
(
)
)
{
oldShape
=
obj
-
>
maybeShape
(
)
;
oldGroup
=
JSObject
:
:
getGroup
(
cx
obj
)
;
if
(
!
oldGroup
)
return
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
RootedValue
objv
(
cx
ObjectValue
(
*
obj
)
)
;
RootedScript
script
(
cx
ic
-
>
script
(
)
)
;
jsbytecode
*
pc
=
ic
-
>
pc
(
)
;
bool
isTemporarilyUnoptimizable
;
SetPropIRGenerator
gen
(
cx
script
pc
ic
-
>
kind
(
)
&
isTemporarilyUnoptimizable
objv
idVal
rhs
ic
-
>
needsTypeBarrier
(
)
ic
-
>
guardHoles
(
)
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
attached
=
ic
-
>
attachCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ionScript
gen
.
typeCheckInfo
(
)
)
;
}
}
if
(
ic
-
>
kind
(
)
=
=
CacheKind
:
:
SetElem
)
{
if
(
!
SetObjectElement
(
cx
obj
idVal
rhs
ic
-
>
strict
(
)
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
ic
-
>
kind
(
)
=
=
CacheKind
:
:
SetProp
)
;
jsbytecode
*
pc
=
ic
-
>
pc
(
)
;
if
(
*
pc
=
=
JSOP_INITGLEXICAL
)
{
RootedScript
script
(
cx
ic
-
>
script
(
)
)
;
MOZ_ASSERT
(
!
script
-
>
hasNonSyntacticScope
(
)
)
;
InitGlobalLexicalOperation
(
cx
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
script
pc
rhs
)
;
}
else
{
RootedPropertyName
name
(
cx
idVal
.
toString
(
)
-
>
asAtom
(
)
.
asPropertyName
(
)
)
;
if
(
!
SetProperty
(
cx
obj
name
rhs
ic
-
>
strict
(
)
pc
)
)
return
false
;
}
}
if
(
!
attached
&
&
!
JitOptions
.
disableCacheIR
&
&
ic
-
>
canAttachStub
(
)
)
{
RootedValue
objv
(
cx
ObjectValue
(
*
obj
)
)
;
RootedScript
script
(
cx
ic
-
>
script
(
)
)
;
jsbytecode
*
pc
=
ic
-
>
pc
(
)
;
bool
isTemporarilyUnoptimizable
;
SetPropIRGenerator
gen
(
cx
script
pc
ic
-
>
kind
(
)
&
isTemporarilyUnoptimizable
objv
idVal
rhs
ic
-
>
needsTypeBarrier
(
)
ic
-
>
guardHoles
(
)
)
;
if
(
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
)
{
attached
=
ic
-
>
attachCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ionScript
gen
.
typeCheckInfo
(
)
)
;
}
else
{
gen
.
trackNotAttached
(
)
;
}
}
return
true
;
}
uint8_t
*
IonICStub
:
:
stubDataStart
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
stubInfo_
-
>
stubDataOffset
(
)
;
}
void
IonIC
:
:
attachStub
(
IonICStub
*
newStub
JitCode
*
code
)
{
MOZ_ASSERT
(
canAttachStub
(
)
)
;
MOZ_ASSERT
(
newStub
)
;
MOZ_ASSERT
(
code
)
;
if
(
firstStub_
)
{
IonICStub
*
last
=
firstStub_
;
while
(
IonICStub
*
next
=
last
-
>
next
(
)
)
last
=
next
;
last
-
>
setNext
(
newStub
code
)
;
}
else
{
firstStub_
=
newStub
;
codeRaw_
=
code
-
>
raw
(
)
;
}
numStubs_
+
+
;
}
