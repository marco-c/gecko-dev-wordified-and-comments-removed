#
include
"
jit
/
riscv64
/
Assembler
-
riscv64
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
AutoWritableJitCode
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
jit
/
riscv64
/
disasm
/
Disasm
-
riscv64
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
wasm
/
WasmFrame
.
h
"
using
mozilla
:
:
DebugOnly
;
namespace
js
{
namespace
jit
{
#
define
UNIMPLEMENTED_RISCV
(
)
MOZ_CRASH
(
"
RISC_V
not
implemented
"
)
;
bool
Assembler
:
:
FLAG_riscv_debug
=
false
;
void
Assembler
:
:
nop
(
)
{
addi
(
ToRegister
(
0
)
ToRegister
(
0
)
0
)
;
}
size_t
Assembler
:
:
size
(
)
const
{
return
m_buffer
.
size
(
)
;
}
bool
Assembler
:
:
swapBuffer
(
wasm
:
:
Bytes
&
bytes
)
{
MOZ_ASSERT
(
bytes
.
empty
(
)
)
;
if
(
!
bytes
.
resize
(
bytesNeeded
(
)
)
)
{
return
false
;
}
m_buffer
.
executableCopy
(
bytes
.
begin
(
)
)
;
return
true
;
}
size_t
Assembler
:
:
jumpRelocationTableBytes
(
)
const
{
return
jumpRelocations_
.
length
(
)
;
}
size_t
Assembler
:
:
dataRelocationTableBytes
(
)
const
{
return
dataRelocations_
.
length
(
)
;
}
size_t
Assembler
:
:
bytesNeeded
(
)
const
{
return
size
(
)
+
jumpRelocationTableBytes
(
)
+
dataRelocationTableBytes
(
)
;
}
void
Assembler
:
:
executableCopy
(
uint8_t
*
buffer
)
{
MOZ_ASSERT
(
isFinished
)
;
m_buffer
.
executableCopy
(
buffer
)
;
}
uint32_t
Assembler
:
:
AsmPoolMaxOffset
=
1024
;
uint32_t
Assembler
:
:
GetPoolMaxOffset
(
)
{
static
bool
isSet
=
false
;
if
(
!
isSet
)
{
char
*
poolMaxOffsetStr
=
getenv
(
"
ASM_POOL_MAX_OFFSET
"
)
;
uint32_t
poolMaxOffset
;
if
(
poolMaxOffsetStr
&
&
sscanf
(
poolMaxOffsetStr
"
%
u
"
&
poolMaxOffset
)
=
=
1
)
{
AsmPoolMaxOffset
=
poolMaxOffset
;
}
isSet
=
true
;
}
return
AsmPoolMaxOffset
;
}
void
Assembler
:
:
InsertIndexIntoTag
(
uint8_t
*
load_
uint32_t
index
)
{
MOZ_CRASH
(
"
Unimplement
"
)
;
}
void
Assembler
:
:
PatchConstantPoolLoad
(
void
*
loadAddr
void
*
constPoolAddr
)
{
MOZ_CRASH
(
"
Unimplement
"
)
;
}
void
Assembler
:
:
processCodeLabels
(
uint8_t
*
rawCode
)
{
for
(
const
CodeLabel
&
label
:
codeLabels_
)
{
Bind
(
rawCode
label
)
;
}
}
void
Assembler
:
:
WritePoolGuard
(
BufferOffset
branch
Instruction
*
dest
BufferOffset
afterPool
)
{
DEBUG_PRINTF
(
"
\
tWritePoolGuard
\
n
"
)
;
int32_t
off
=
afterPool
.
getOffset
(
)
-
branch
.
getOffset
(
)
;
if
(
!
is_int21
(
off
)
|
|
!
(
(
off
&
0x1
)
=
=
0
)
)
{
printf
(
"
%
d
\
n
"
off
)
;
MOZ_CRASH
(
"
imm
invalid
"
)
;
}
int32_t
imm20
=
(
off
&
0xff000
)
|
(
(
off
&
0x800
)
<
<
9
)
|
(
(
off
&
0x7fe
)
<
<
20
)
|
(
(
off
&
0x100000
)
<
<
11
)
;
Instr
instr
=
JAL
|
(
imm20
&
kImm20Mask
)
;
dest
-
>
SetInstructionBits
(
instr
)
;
DEBUG_PRINTF
(
"
%
p
(
%
x
)
:
"
dest
branch
.
getOffset
(
)
)
;
disassembleInstr
(
dest
-
>
InstructionBits
(
)
JitSpew_Codegen
)
;
}
void
Assembler
:
:
WritePoolHeader
(
uint8_t
*
start
Pool
*
p
bool
isNatural
)
{
static_assert
(
sizeof
(
PoolHeader
)
=
=
4
)
;
const
uintptr_t
totalPoolSize
=
sizeof
(
PoolHeader
)
+
p
-
>
getPoolSize
(
)
;
const
uintptr_t
totalPoolInstructions
=
totalPoolSize
/
kInstrSize
;
MOZ_ASSERT
(
(
totalPoolSize
&
0x3
)
=
=
0
)
;
MOZ_ASSERT
(
totalPoolInstructions
<
(
1
<
<
15
)
)
;
PoolHeader
header
(
totalPoolInstructions
isNatural
)
;
*
(
PoolHeader
*
)
start
=
header
;
}
void
Assembler
:
:
copyJumpRelocationTable
(
uint8_t
*
dest
)
{
if
(
jumpRelocations_
.
length
(
)
)
{
memcpy
(
dest
jumpRelocations_
.
buffer
(
)
jumpRelocations_
.
length
(
)
)
;
}
}
void
Assembler
:
:
copyDataRelocationTable
(
uint8_t
*
dest
)
{
if
(
dataRelocations_
.
length
(
)
)
{
memcpy
(
dest
dataRelocations_
.
buffer
(
)
dataRelocations_
.
length
(
)
)
;
}
}
void
Assembler
:
:
RV_li
(
Register
rd
int64_t
imm
)
{
UseScratchRegisterScope
temps
(
this
)
;
if
(
RecursiveLiCount
(
imm
)
>
GeneralLiCount
(
imm
temps
.
hasAvailable
(
)
)
)
{
GeneralLi
(
rd
imm
)
;
}
else
{
RecursiveLi
(
rd
imm
)
;
}
}
int
Assembler
:
:
RV_li_count
(
int64_t
imm
bool
is_get_temp_reg
)
{
if
(
RecursiveLiCount
(
imm
)
>
GeneralLiCount
(
imm
is_get_temp_reg
)
)
{
return
GeneralLiCount
(
imm
is_get_temp_reg
)
;
}
else
{
return
RecursiveLiCount
(
imm
)
;
}
}
void
Assembler
:
:
GeneralLi
(
Register
rd
int64_t
imm
)
{
if
(
is_int32
(
imm
+
0x800
)
)
{
int64_t
high_20
=
(
(
imm
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
imm
<
<
52
>
>
52
;
if
(
high_20
)
{
lui
(
rd
(
int32_t
)
high_20
)
;
if
(
low_12
)
{
addi
(
rd
rd
low_12
)
;
}
}
else
{
addi
(
rd
zero_reg
low_12
)
;
}
return
;
}
else
{
UseScratchRegisterScope
temps
(
this
)
;
BlockTrampolinePoolScope
block_trampoline_pool
(
this
8
)
;
int64_t
up_32
=
imm
>
>
32
;
int64_t
low_32
=
imm
&
0xffffffffull
;
Register
temp_reg
=
rd
;
if
(
up_32
=
=
0
|
|
low_32
=
=
0
)
{
}
else
{
temp_reg
=
temps
.
hasAvailable
(
)
?
temps
.
Acquire
(
)
:
InvalidReg
;
}
if
(
temp_reg
!
=
InvalidReg
)
{
int64_t
sim_low
=
0
;
if
(
low_32
!
=
0
)
{
int64_t
high_20
=
(
(
low_32
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
low_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
sim_low
=
(
(
high_20
<
<
12
)
<
<
32
)
>
>
32
;
lui
(
rd
(
int32_t
)
high_20
)
;
if
(
low_12
)
{
sim_low
+
=
(
low_12
<
<
52
>
>
52
)
|
low_12
;
addi
(
rd
rd
low_12
)
;
}
}
else
{
sim_low
=
low_12
;
ori
(
rd
zero_reg
low_12
)
;
}
}
if
(
sim_low
&
0x100000000
)
{
if
(
up_32
=
=
0
)
{
slli
(
rd
rd
32
)
;
srli
(
rd
rd
32
)
;
return
;
}
up_32
=
(
up_32
-
0xffffffff
)
&
0xffffffff
;
}
if
(
up_32
=
=
0
)
{
return
;
}
if
(
low_32
=
=
0
)
{
temp_reg
=
rd
;
}
int64_t
high_20
=
(
up_32
+
0x800
)
>
>
12
;
int64_t
low_12
=
up_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
lui
(
temp_reg
(
int32_t
)
high_20
)
;
if
(
low_12
)
{
addi
(
temp_reg
temp_reg
low_12
)
;
}
}
else
{
ori
(
temp_reg
zero_reg
low_12
)
;
}
slli
(
temp_reg
temp_reg
32
)
;
if
(
low_32
!
=
0
)
{
add
(
rd
rd
temp_reg
)
;
}
return
;
}
int64_t
high_20
=
(
up_32
+
0x800
)
>
>
12
;
int64_t
low_12
=
up_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
lui
(
rd
(
int32_t
)
high_20
)
;
if
(
low_12
)
{
addi
(
rd
rd
low_12
)
;
}
}
else
{
ori
(
rd
zero_reg
low_12
)
;
}
uint32_t
mask
=
0x80000000
;
int32_t
shift_val
=
0
;
int32_t
i
;
for
(
i
=
0
;
i
<
32
;
i
+
+
)
{
if
(
(
low_32
&
mask
)
=
=
0
)
{
mask
>
>
=
1
;
shift_val
+
+
;
if
(
i
=
=
31
)
{
slli
(
rd
rd
shift_val
)
;
}
continue
;
}
int32_t
part
;
if
(
(
i
+
11
)
<
32
)
{
part
=
(
(
uint32_t
)
(
low_32
<
<
i
)
>
>
i
)
>
>
(
32
-
(
i
+
11
)
)
;
slli
(
rd
rd
shift_val
+
11
)
;
ori
(
rd
rd
part
)
;
i
+
=
10
;
mask
>
>
=
11
;
}
else
{
part
=
(
uint32_t
)
(
low_32
<
<
i
)
>
>
i
;
slli
(
rd
rd
shift_val
+
(
32
-
i
)
)
;
ori
(
rd
rd
part
)
;
break
;
}
shift_val
=
0
;
}
}
}
int
Assembler
:
:
GeneralLiCount
(
int64_t
imm
bool
is_get_temp_reg
)
{
int
count
=
0
;
if
(
is_int32
(
imm
+
0x800
)
)
{
int64_t
high_20
=
(
(
imm
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
imm
<
<
52
>
>
52
;
if
(
high_20
)
{
count
+
+
;
if
(
low_12
)
{
count
+
+
;
}
}
else
{
count
+
+
;
}
return
count
;
}
else
{
int64_t
up_32
=
imm
>
>
32
;
int64_t
low_32
=
imm
&
0xffffffffull
;
if
(
is_get_temp_reg
)
{
int64_t
sim_low
=
0
;
if
(
low_32
!
=
0
)
{
int64_t
high_20
=
(
(
low_32
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
low_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
sim_low
=
(
(
high_20
<
<
12
)
<
<
32
)
>
>
32
;
count
+
+
;
if
(
low_12
)
{
sim_low
+
=
(
low_12
<
<
52
>
>
52
)
|
low_12
;
count
+
+
;
}
}
else
{
sim_low
=
low_12
;
count
+
+
;
}
}
if
(
sim_low
&
0x100000000
)
{
if
(
up_32
=
=
0
)
{
count
+
+
;
count
+
+
;
return
count
;
}
up_32
=
(
up_32
-
0xffffffff
)
&
0xffffffff
;
}
if
(
up_32
=
=
0
)
{
return
count
;
}
int64_t
high_20
=
(
up_32
+
0x800
)
>
>
12
;
int64_t
low_12
=
up_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
count
+
+
;
if
(
low_12
)
{
count
+
+
;
}
}
else
{
count
+
+
;
}
count
+
+
;
if
(
low_32
!
=
0
)
{
count
+
+
;
}
return
count
;
}
int64_t
high_20
=
(
up_32
+
0x800
)
>
>
12
;
int64_t
low_12
=
up_32
&
0xfff
;
if
(
high_20
)
{
high_20
&
=
0xfffff
;
count
+
+
;
if
(
low_12
)
{
count
+
+
;
}
}
else
{
count
+
+
;
}
uint32_t
mask
=
0x80000000
;
int32_t
i
;
for
(
i
=
0
;
i
<
32
;
i
+
+
)
{
if
(
(
low_32
&
mask
)
=
=
0
)
{
mask
>
>
=
1
;
if
(
i
=
=
31
)
{
count
+
+
;
}
continue
;
}
if
(
(
i
+
11
)
<
32
)
{
count
+
+
;
count
+
+
;
i
+
=
10
;
mask
>
>
=
11
;
}
else
{
count
+
+
;
count
+
+
;
break
;
}
}
}
return
count
;
}
void
Assembler
:
:
li_ptr
(
Register
rd
int64_t
imm
)
{
m_buffer
.
enterNoNops
(
)
;
m_buffer
.
assertNoPoolAndNoNops
(
)
;
DEBUG_PRINTF
(
"
li_ptr
(
%
d
%
"
PRIx64
"
<
%
"
PRId64
"
>
)
\
n
"
ToNumber
(
rd
)
imm
imm
)
;
MOZ_ASSERT
(
(
imm
&
0xfff0000000000000ll
)
=
=
0
)
;
int64_t
a6
=
imm
&
0x3f
;
int64_t
b11
=
(
imm
>
>
6
)
&
0x7ff
;
int64_t
high_31
=
(
imm
>
>
17
)
&
0x7fffffff
;
int64_t
high_20
=
(
(
high_31
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
high_31
&
0xfff
;
lui
(
rd
(
int32_t
)
high_20
)
;
addi
(
rd
rd
low_12
)
;
slli
(
rd
rd
11
)
;
ori
(
rd
rd
b11
)
;
slli
(
rd
rd
6
)
;
ori
(
rd
rd
a6
)
;
m_buffer
.
leaveNoNops
(
)
;
}
void
Assembler
:
:
li_constant
(
Register
rd
int64_t
imm
)
{
m_buffer
.
enterNoNops
(
)
;
m_buffer
.
assertNoPoolAndNoNops
(
)
;
DEBUG_PRINTF
(
"
li_constant
(
%
d
%
"
PRIx64
"
<
%
"
PRId64
"
>
)
\
n
"
ToNumber
(
rd
)
imm
imm
)
;
lui
(
rd
(
imm
+
(
1LL
<
<
47
)
+
(
1LL
<
<
35
)
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
>
>
48
)
;
addiw
(
rd
rd
(
imm
+
(
1LL
<
<
35
)
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
<
<
16
>
>
52
)
;
slli
(
rd
rd
12
)
;
addi
(
rd
rd
(
imm
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
<
<
28
>
>
52
)
;
slli
(
rd
rd
12
)
;
addi
(
rd
rd
(
imm
+
(
1LL
<
<
11
)
)
<
<
40
>
>
52
)
;
slli
(
rd
rd
12
)
;
addi
(
rd
rd
imm
<
<
52
>
>
52
)
;
m_buffer
.
leaveNoNops
(
)
;
}
ABIArg
ABIArgGenerator
:
:
next
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Int32
:
case
MIRType
:
:
Int64
:
case
MIRType
:
:
Pointer
:
case
MIRType
:
:
WasmAnyRef
:
case
MIRType
:
:
WasmArrayData
:
case
MIRType
:
:
StackResults
:
{
if
(
intRegIndex_
=
=
NumIntArgRegs
)
{
current_
=
ABIArg
(
stackOffset_
)
;
stackOffset_
+
=
sizeof
(
uintptr_t
)
;
break
;
}
current_
=
ABIArg
(
Register
:
:
FromCode
(
intRegIndex_
+
a0
.
encoding
(
)
)
)
;
intRegIndex_
+
+
;
break
;
}
case
MIRType
:
:
Float32
:
case
MIRType
:
:
Double
:
{
if
(
floatRegIndex_
=
=
NumFloatArgRegs
)
{
current_
=
ABIArg
(
stackOffset_
)
;
stackOffset_
+
=
sizeof
(
double
)
;
break
;
}
current_
=
ABIArg
(
FloatRegister
(
FloatRegisters
:
:
Encoding
(
floatRegIndex_
+
fa0
.
encoding
(
)
)
type
=
=
MIRType
:
:
Double
?
FloatRegisters
:
:
Double
:
FloatRegisters
:
:
Single
)
)
;
floatRegIndex_
+
+
;
break
;
}
case
MIRType
:
:
Simd128
:
{
MOZ_CRASH
(
"
RISCV64
does
not
support
simd
yet
.
"
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Unexpected
argument
type
"
)
;
}
return
current_
;
}
bool
Assembler
:
:
oom
(
)
const
{
return
AssemblerShared
:
:
oom
(
)
|
|
m_buffer
.
oom
(
)
|
|
jumpRelocations_
.
oom
(
)
|
|
dataRelocations_
.
oom
(
)
|
|
!
enoughLabelCache_
;
}
int
Assembler
:
:
disassembleInstr
(
Instr
instr
bool
enable_spew
)
{
if
(
!
FLAG_riscv_debug
&
&
!
enable_spew
)
return
-
1
;
disasm
:
:
NameConverter
converter
;
disasm
:
:
Disassembler
disasm
(
converter
)
;
EmbeddedVector
<
char
128
>
disasm_buffer
;
int
size
=
disasm
.
InstructionDecode
(
disasm_buffer
reinterpret_cast
<
byte
*
>
(
&
instr
)
)
;
DEBUG_PRINTF
(
"
%
s
\
n
"
disasm_buffer
.
start
(
)
)
;
if
(
enable_spew
)
{
JitSpew
(
JitSpew_Codegen
"
%
s
"
disasm_buffer
.
start
(
)
)
;
}
return
size
;
}
uint64_t
Assembler
:
:
target_address_at
(
Instruction
*
pc
)
{
Instruction
*
instr0
=
pc
;
DEBUG_PRINTF
(
"
target_address_at
:
pc
:
0x
%
p
\
t
"
instr0
)
;
Instruction
*
instr1
=
pc
+
1
*
kInstrSize
;
Instruction
*
instr2
=
pc
+
2
*
kInstrSize
;
Instruction
*
instr3
=
pc
+
3
*
kInstrSize
;
Instruction
*
instr4
=
pc
+
4
*
kInstrSize
;
Instruction
*
instr5
=
pc
+
5
*
kInstrSize
;
if
(
IsLui
(
*
reinterpret_cast
<
Instr
*
>
(
instr0
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr2
)
)
&
&
IsOri
(
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr4
)
)
&
&
IsOri
(
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
)
)
{
int64_t
addr
=
(
int64_t
)
(
instr0
-
>
Imm20UValue
(
)
<
<
kImm20Shift
)
+
(
int64_t
)
instr1
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
instr2
-
>
Imm12Value
(
)
=
=
11
)
;
addr
<
<
=
11
;
addr
|
=
(
int64_t
)
instr3
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
instr4
-
>
Imm12Value
(
)
=
=
6
)
;
addr
<
<
=
6
;
addr
|
=
(
int64_t
)
instr5
-
>
Imm12Value
(
)
;
DEBUG_PRINTF
(
"
addr
:
%
"
PRIx64
"
\
n
"
addr
)
;
return
static_cast
<
uint64_t
>
(
addr
)
;
}
MOZ_CRASH
(
"
RISC
-
V
UNREACHABLE
"
)
;
}
void
Assembler
:
:
PatchDataWithValueCheck
(
CodeLocationLabel
label
ImmPtr
newValue
ImmPtr
expectedValue
)
{
PatchDataWithValueCheck
(
label
PatchedImmPtr
(
newValue
.
value
)
PatchedImmPtr
(
expectedValue
.
value
)
)
;
}
void
Assembler
:
:
PatchDataWithValueCheck
(
CodeLocationLabel
label
PatchedImmPtr
newValue
PatchedImmPtr
expectedValue
)
{
Instruction
*
inst
=
(
Instruction
*
)
label
.
raw
(
)
;
DebugOnly
<
uint64_t
>
value
=
Assembler
:
:
ExtractLoad64Value
(
inst
)
;
MOZ_ASSERT
(
value
=
=
uint64_t
(
expectedValue
.
value
)
)
;
Assembler
:
:
UpdateLoad64Value
(
inst
uint64_t
(
newValue
.
value
)
)
;
}
uint64_t
Assembler
:
:
ExtractLoad64Value
(
Instruction
*
inst0
)
{
DEBUG_PRINTF
(
"
\
tExtractLoad64Value
:
\
tpc
:
%
p
"
inst0
)
;
if
(
IsJal
(
*
reinterpret_cast
<
Instr
*
>
(
inst0
)
)
)
{
int
offset
=
inst0
-
>
Imm20JValue
(
)
;
inst0
=
inst0
+
offset
;
}
Instruction
*
instr1
=
inst0
+
1
*
kInstrSize
;
if
(
IsAddiw
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
)
{
Instruction
*
instr2
=
inst0
+
2
*
kInstrSize
;
Instruction
*
instr3
=
inst0
+
3
*
kInstrSize
;
Instruction
*
instr4
=
inst0
+
4
*
kInstrSize
;
Instruction
*
instr5
=
inst0
+
5
*
kInstrSize
;
Instruction
*
instr6
=
inst0
+
6
*
kInstrSize
;
Instruction
*
instr7
=
inst0
+
7
*
kInstrSize
;
if
(
IsLui
(
*
reinterpret_cast
<
Instr
*
>
(
inst0
)
)
&
&
IsAddiw
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr2
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr4
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr6
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr7
)
)
)
{
int64_t
imm
=
(
int64_t
)
(
inst0
-
>
Imm20UValue
(
)
<
<
kImm20Shift
)
+
(
int64_t
)
instr1
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
instr2
-
>
Imm12Value
(
)
=
=
12
)
;
imm
<
<
=
12
;
imm
+
=
(
int64_t
)
instr3
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
instr4
-
>
Imm12Value
(
)
=
=
12
)
;
imm
<
<
=
12
;
imm
+
=
(
int64_t
)
instr5
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
instr6
-
>
Imm12Value
(
)
=
=
12
)
;
imm
<
<
=
12
;
imm
+
=
(
int64_t
)
instr7
-
>
Imm12Value
(
)
;
DEBUG_PRINTF
(
"
imm
:
%
"
PRIx64
"
\
n
"
imm
)
;
return
imm
;
}
else
{
FLAG_riscv_debug
=
true
;
disassembleInstr
(
inst0
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr1
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr2
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr3
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr4
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr5
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr6
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr7
-
>
InstructionBits
(
)
)
;
MOZ_CRASH
(
)
;
}
}
else
{
DEBUG_PRINTF
(
"
\
n
"
)
;
Instruction
*
instrf1
=
(
inst0
-
1
*
kInstrSize
)
;
Instruction
*
instr2
=
inst0
+
2
*
kInstrSize
;
Instruction
*
instr3
=
inst0
+
3
*
kInstrSize
;
Instruction
*
instr4
=
inst0
+
4
*
kInstrSize
;
Instruction
*
instr5
=
inst0
+
5
*
kInstrSize
;
Instruction
*
instr6
=
inst0
+
6
*
kInstrSize
;
Instruction
*
instr7
=
inst0
+
7
*
kInstrSize
;
disassembleInstr
(
instrf1
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
inst0
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr1
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr2
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr3
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr4
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr5
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr6
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr7
-
>
InstructionBits
(
)
)
;
MOZ_ASSERT
(
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
)
;
return
target_address_at
(
inst0
)
;
}
}
void
Assembler
:
:
UpdateLoad64Value
(
Instruction
*
pc
uint64_t
value
)
{
DEBUG_PRINTF
(
"
\
tUpdateLoad64Value
:
pc
:
%
p
\
tvalue
:
%
"
PRIx64
"
\
n
"
pc
value
)
;
Instruction
*
instr1
=
pc
+
1
*
kInstrSize
;
if
(
IsJal
(
*
reinterpret_cast
<
Instr
*
>
(
pc
)
)
)
{
pc
=
pc
+
pc
-
>
Imm20JValue
(
)
;
instr1
=
pc
+
1
*
kInstrSize
;
}
if
(
IsAddiw
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
)
{
Instruction
*
instr0
=
pc
;
Instruction
*
instr2
=
pc
+
2
*
kInstrSize
;
Instruction
*
instr3
=
pc
+
3
*
kInstrSize
;
Instruction
*
instr4
=
pc
+
4
*
kInstrSize
;
Instruction
*
instr5
=
pc
+
5
*
kInstrSize
;
Instruction
*
instr6
=
pc
+
6
*
kInstrSize
;
Instruction
*
instr7
=
pc
+
7
*
kInstrSize
;
MOZ_ASSERT
(
IsLui
(
*
reinterpret_cast
<
Instr
*
>
(
pc
)
)
&
&
IsAddiw
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr2
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr4
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
)
&
&
IsSlli
(
*
reinterpret_cast
<
Instr
*
>
(
instr6
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr7
)
)
)
;
*
reinterpret_cast
<
Instr
*
>
(
instr0
)
&
=
0xfff
;
*
reinterpret_cast
<
Instr
*
>
(
instr0
)
|
=
(
(
(
value
+
(
1LL
<
<
47
)
+
(
1LL
<
<
35
)
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
>
>
48
)
<
<
12
)
;
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
&
=
0xfffff
;
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
|
=
(
(
(
value
+
(
1LL
<
<
35
)
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
<
<
16
>
>
52
)
<
<
20
)
;
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
&
=
0xfffff
;
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
|
=
(
(
(
value
+
(
1LL
<
<
23
)
+
(
1LL
<
<
11
)
)
<
<
28
>
>
52
)
<
<
20
)
;
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
&
=
0xfffff
;
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
|
=
(
(
(
value
+
(
1LL
<
<
11
)
)
<
<
40
>
>
52
)
<
<
20
)
;
*
reinterpret_cast
<
Instr
*
>
(
instr7
)
&
=
0xfffff
;
*
reinterpret_cast
<
Instr
*
>
(
instr7
)
|
=
(
(
value
<
<
52
>
>
52
)
<
<
20
)
;
disassembleInstr
(
instr0
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr1
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr2
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr3
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr4
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr5
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr6
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr7
-
>
InstructionBits
(
)
)
;
MOZ_ASSERT
(
ExtractLoad64Value
(
pc
)
=
=
value
)
;
}
else
{
Instruction
*
instr0
=
pc
;
Instruction
*
instr2
=
pc
+
2
*
kInstrSize
;
Instruction
*
instr3
=
pc
+
3
*
kInstrSize
;
Instruction
*
instr4
=
pc
+
4
*
kInstrSize
;
Instruction
*
instr5
=
pc
+
5
*
kInstrSize
;
Instruction
*
instr6
=
pc
+
6
*
kInstrSize
;
Instruction
*
instr7
=
pc
+
7
*
kInstrSize
;
disassembleInstr
(
instr0
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr1
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr2
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr3
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr4
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr5
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr6
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
instr7
-
>
InstructionBits
(
)
)
;
MOZ_ASSERT
(
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
)
;
set_target_value_at
(
pc
value
)
;
}
}
void
Assembler
:
:
set_target_value_at
(
Instruction
*
pc
uint64_t
target
)
{
DEBUG_PRINTF
(
"
\
tset_target_value_at
:
pc
:
%
p
\
ttarget
:
%
"
PRIx64
"
\
n
"
pc
target
)
;
uint32_t
*
p
=
reinterpret_cast
<
uint32_t
*
>
(
pc
)
;
MOZ_ASSERT
(
(
target
&
0xffff000000000000ll
)
=
=
0
)
;
#
ifdef
DEBUG
Instruction
*
instr0
=
pc
;
Instruction
*
instr1
=
pc
+
1
*
kInstrSize
;
Instruction
*
instr3
=
pc
+
3
*
kInstrSize
;
Instruction
*
instr5
=
pc
+
5
*
kInstrSize
;
MOZ_ASSERT
(
IsLui
(
*
reinterpret_cast
<
Instr
*
>
(
instr0
)
)
&
&
IsAddi
(
*
reinterpret_cast
<
Instr
*
>
(
instr1
)
)
&
&
IsOri
(
*
reinterpret_cast
<
Instr
*
>
(
instr3
)
)
&
&
IsOri
(
*
reinterpret_cast
<
Instr
*
>
(
instr5
)
)
)
;
#
endif
int64_t
a6
=
target
&
0x3f
;
int64_t
b11
=
(
target
>
>
6
)
&
0x7ff
;
int64_t
high_31
=
(
target
>
>
17
)
&
0x7fffffff
;
int64_t
high_20
=
(
(
high_31
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
high_31
&
0xfff
;
*
p
=
*
p
&
0xfff
;
*
p
=
*
p
|
(
(
int32_t
)
high_20
<
<
12
)
;
*
(
p
+
1
)
=
*
(
p
+
1
)
&
0xfffff
;
*
(
p
+
1
)
=
*
(
p
+
1
)
|
(
(
int32_t
)
low_12
<
<
20
)
;
*
(
p
+
2
)
=
*
(
p
+
2
)
&
0xfffff
;
*
(
p
+
2
)
=
*
(
p
+
2
)
|
(
11
<
<
20
)
;
*
(
p
+
3
)
=
*
(
p
+
3
)
&
0xfffff
;
*
(
p
+
3
)
=
*
(
p
+
3
)
|
(
(
int32_t
)
b11
<
<
20
)
;
*
(
p
+
4
)
=
*
(
p
+
4
)
&
0xfffff
;
*
(
p
+
4
)
=
*
(
p
+
4
)
|
(
6
<
<
20
)
;
*
(
p
+
5
)
=
*
(
p
+
5
)
&
0xfffff
;
*
(
p
+
5
)
=
*
(
p
+
5
)
|
(
(
int32_t
)
a6
<
<
20
)
;
MOZ_ASSERT
(
target_address_at
(
pc
)
=
=
target
)
;
}
void
Assembler
:
:
WriteLoad64Instructions
(
Instruction
*
inst0
Register
reg
uint64_t
value
)
{
DEBUG_PRINTF
(
"
\
tWriteLoad64Instructions
\
n
"
)
;
MOZ_ASSERT
(
(
value
&
0xfff0000000000000ll
)
=
=
0
)
;
int64_t
a6
=
value
&
0x3f
;
int64_t
b11
=
(
value
>
>
6
)
&
0x7ff
;
int64_t
high_31
=
(
value
>
>
17
)
&
0x7fffffff
;
int64_t
high_20
=
(
(
high_31
+
0x800
)
>
>
12
)
;
int64_t
low_12
=
high_31
&
0xfff
;
Instr
lui_
=
LUI
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
(
int32_t
)
high_20
<
<
kImm20Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
)
=
lui_
;
Instr
addi_
=
OP_IMM
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
0b000
<
<
kFunct3Shift
)
|
(
reg
.
code
(
)
<
<
kRs1Shift
)
|
(
low_12
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
+
1
*
kInstrSize
)
=
addi_
;
Instr
slli_
=
OP_IMM
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
0b001
<
<
kFunct3Shift
)
|
(
reg
.
code
(
)
<
<
kRs1Shift
)
|
(
11
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
+
2
*
kInstrSize
)
=
slli_
;
Instr
ori_b11
=
OP_IMM
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
0b110
<
<
kFunct3Shift
)
|
(
reg
.
code
(
)
<
<
kRs1Shift
)
|
(
b11
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
+
3
*
kInstrSize
)
=
ori_b11
;
slli_
=
OP_IMM
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
0b001
<
<
kFunct3Shift
)
|
(
reg
.
code
(
)
<
<
kRs1Shift
)
|
(
6
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
+
4
*
kInstrSize
)
=
slli_
;
Instr
ori_a6
=
OP_IMM
|
(
reg
.
code
(
)
<
<
kRdShift
)
|
(
0b110
<
<
kFunct3Shift
)
|
(
reg
.
code
(
)
<
<
kRs1Shift
)
|
(
a6
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst0
+
5
*
kInstrSize
)
=
ori_a6
;
disassembleInstr
(
(
inst0
+
0
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
1
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
2
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
3
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
4
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
5
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
disassembleInstr
(
(
inst0
+
6
*
kInstrSize
)
-
>
InstructionBits
(
)
)
;
MOZ_ASSERT
(
ExtractLoad64Value
(
inst0
)
=
=
value
)
;
}
void
Assembler
:
:
PatchWrite_Imm32
(
CodeLocationLabel
label
Imm32
imm
)
{
uint32_t
*
raw
=
(
uint32_t
*
)
label
.
raw
(
)
;
*
(
raw
-
1
)
=
imm
.
value
;
}
bool
Assembler
:
:
target_at_put
(
BufferOffset
pos
BufferOffset
target_pos
bool
trampoline
)
{
if
(
m_buffer
.
oom
(
)
)
{
return
true
;
}
DEBUG_PRINTF
(
"
\
ttarget_at_put
:
%
p
(
%
d
)
to
%
p
(
%
d
)
\
n
"
reinterpret_cast
<
Instr
*
>
(
editSrc
(
pos
)
)
pos
.
getOffset
(
)
reinterpret_cast
<
Instr
*
>
(
editSrc
(
pos
)
)
+
target_pos
.
getOffset
(
)
-
pos
.
getOffset
(
)
target_pos
.
getOffset
(
)
)
;
Instruction
*
instruction
=
editSrc
(
pos
)
;
Instr
instr
=
instruction
-
>
InstructionBits
(
)
;
switch
(
instruction
-
>
InstructionOpcodeType
(
)
)
{
case
BRANCH
:
{
if
(
!
is_intn
(
pos
.
getOffset
(
)
-
target_pos
.
getOffset
(
)
kBranchOffsetBits
)
)
{
return
false
;
}
instr
=
SetBranchOffset
(
pos
.
getOffset
(
)
target_pos
.
getOffset
(
)
instr
)
;
instr_at_put
(
pos
instr
)
;
}
break
;
case
JAL
:
{
MOZ_ASSERT
(
IsJal
(
instr
)
)
;
if
(
!
is_intn
(
pos
.
getOffset
(
)
-
target_pos
.
getOffset
(
)
kJumpOffsetBits
)
)
{
return
false
;
}
instr
=
SetJalOffset
(
pos
.
getOffset
(
)
target_pos
.
getOffset
(
)
instr
)
;
instr_at_put
(
pos
instr
)
;
}
break
;
case
LUI
:
{
set_target_value_at
(
instruction
reinterpret_cast
<
uintptr_t
>
(
editSrc
(
target_pos
)
)
)
;
}
break
;
case
AUIPC
:
{
Instr
instr_auipc
=
instr
;
Instr
instr_I
=
editSrc
(
BufferOffset
(
pos
.
getOffset
(
)
+
4
)
)
-
>
InstructionBits
(
)
;
MOZ_ASSERT
(
IsJalr
(
instr_I
)
|
|
IsAddi
(
instr_I
)
)
;
intptr_t
offset
=
target_pos
.
getOffset
(
)
-
pos
.
getOffset
(
)
;
if
(
is_int21
(
offset
)
&
&
IsJalr
(
instr_I
)
&
&
trampoline
)
{
MOZ_ASSERT
(
is_int21
(
offset
)
&
&
(
(
offset
&
1
)
=
=
0
)
)
;
Instr
instr
=
JAL
;
instr
=
SetJalOffset
(
pos
.
getOffset
(
)
target_pos
.
getOffset
(
)
instr
)
;
MOZ_ASSERT
(
IsJal
(
instr
)
)
;
MOZ_ASSERT
(
JumpOffset
(
instr
)
=
=
offset
)
;
instr_at_put
(
pos
instr
)
;
instr_at_put
(
BufferOffset
(
pos
.
getOffset
(
)
+
4
)
kNopByte
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
is_int32
(
offset
+
0x800
)
)
;
MOZ_ASSERT
(
instruction
-
>
RdValue
(
)
=
=
editSrc
(
BufferOffset
(
pos
.
getOffset
(
)
+
4
)
)
-
>
Rs1Value
(
)
)
;
int32_t
Hi20
=
(
(
(
int32_t
)
offset
+
0x800
)
>
>
12
)
;
int32_t
Lo12
=
(
int32_t
)
offset
<
<
20
>
>
20
;
instr_auipc
=
(
instr_auipc
&
~
kImm31_12Mask
)
|
(
(
Hi20
&
kImm19_0Mask
)
<
<
12
)
;
instr_at_put
(
pos
instr_auipc
)
;
const
int
kImm31_20Mask
=
(
(
1
<
<
12
)
-
1
)
<
<
20
;
const
int
kImm11_0Mask
=
(
(
1
<
<
12
)
-
1
)
;
instr_I
=
(
instr_I
&
~
kImm31_20Mask
)
|
(
(
Lo12
&
kImm11_0Mask
)
<
<
20
)
;
instr_at_put
(
BufferOffset
(
pos
.
getOffset
(
)
+
4
)
instr_I
)
;
}
}
break
;
default
:
UNIMPLEMENTED_RISCV
(
)
;
break
;
}
return
true
;
}
const
int
kEndOfChain
=
-
1
;
const
int32_t
kEndOfJumpChain
=
0
;
int
Assembler
:
:
target_at
(
BufferOffset
pos
bool
is_internal
)
{
if
(
oom
(
)
)
{
return
kEndOfChain
;
}
Instruction
*
instruction
=
editSrc
(
pos
)
;
Instruction
*
instruction2
=
nullptr
;
if
(
IsAuipc
(
instruction
-
>
InstructionBits
(
)
)
)
{
instruction2
=
editSrc
(
BufferOffset
(
pos
.
getOffset
(
)
+
kInstrSize
)
)
;
}
return
target_at
(
instruction
pos
is_internal
instruction2
)
;
}
int
Assembler
:
:
target_at
(
Instruction
*
instruction
BufferOffset
pos
bool
is_internal
Instruction
*
instruction2
)
{
DEBUG_PRINTF
(
"
\
t
target_at
:
%
p
(
%
x
)
\
n
\
t
"
reinterpret_cast
<
Instr
*
>
(
instruction
)
pos
.
getOffset
(
)
)
;
disassembleInstr
(
instruction
-
>
InstructionBits
(
)
)
;
Instr
instr
=
instruction
-
>
InstructionBits
(
)
;
switch
(
instruction
-
>
InstructionOpcodeType
(
)
)
{
case
BRANCH
:
{
int32_t
imm13
=
BranchOffset
(
instr
)
;
if
(
imm13
=
=
kEndOfJumpChain
)
{
return
kEndOfChain
;
}
else
{
DEBUG_PRINTF
(
"
\
t
target_at
:
%
d
%
d
\
n
"
imm13
pos
.
getOffset
(
)
+
imm13
)
;
return
pos
.
getOffset
(
)
+
imm13
;
}
}
case
JAL
:
{
int32_t
imm21
=
JumpOffset
(
instr
)
;
if
(
imm21
=
=
kEndOfJumpChain
)
{
return
kEndOfChain
;
}
else
{
DEBUG_PRINTF
(
"
\
t
target_at
:
%
d
%
d
\
n
"
imm21
pos
.
getOffset
(
)
+
imm21
)
;
return
pos
.
getOffset
(
)
+
imm21
;
}
}
case
JALR
:
{
int32_t
imm12
=
instr
>
>
20
;
if
(
imm12
=
=
kEndOfJumpChain
)
{
return
kEndOfChain
;
}
else
{
DEBUG_PRINTF
(
"
\
t
target_at
:
%
d
%
d
\
n
"
imm12
pos
.
getOffset
(
)
+
imm12
)
;
return
pos
.
getOffset
(
)
+
imm12
;
}
}
case
LUI
:
{
uintptr_t
imm
=
target_address_at
(
instruction
)
;
uintptr_t
instr_address
=
reinterpret_cast
<
uintptr_t
>
(
instruction
)
;
if
(
imm
=
=
kEndOfJumpChain
)
{
return
kEndOfChain
;
}
else
{
MOZ_ASSERT
(
instr_address
-
imm
<
INT_MAX
)
;
int32_t
delta
=
static_cast
<
int32_t
>
(
instr_address
-
imm
)
;
MOZ_ASSERT
(
pos
.
getOffset
(
)
>
delta
)
;
return
pos
.
getOffset
(
)
-
delta
;
}
}
case
AUIPC
:
{
MOZ_ASSERT
(
instruction2
!
=
nullptr
)
;
Instr
instr_auipc
=
instr
;
Instr
instr_I
=
instruction2
-
>
InstructionBits
(
)
;
MOZ_ASSERT
(
IsJalr
(
instr_I
)
|
|
IsAddi
(
instr_I
)
)
;
int32_t
offset
=
BrachlongOffset
(
instr_auipc
instr_I
)
;
if
(
offset
=
=
kEndOfJumpChain
)
return
kEndOfChain
;
DEBUG_PRINTF
(
"
\
t
target_at
:
%
d
%
d
\
n
"
offset
pos
.
getOffset
(
)
+
offset
)
;
return
offset
+
pos
.
getOffset
(
)
;
}
default
:
{
UNIMPLEMENTED_RISCV
(
)
;
}
}
}
uint32_t
Assembler
:
:
next_link
(
Label
*
L
bool
is_internal
)
{
MOZ_ASSERT
(
L
-
>
used
(
)
)
;
BufferOffset
pos
(
L
)
;
int
link
=
target_at
(
pos
is_internal
)
;
if
(
link
=
=
kEndOfChain
)
{
L
-
>
reset
(
)
;
return
LabelBase
:
:
INVALID_OFFSET
;
}
else
{
MOZ_ASSERT
(
link
>
=
0
)
;
DEBUG_PRINTF
(
"
next
:
%
p
to
offset
%
d
\
n
"
L
link
)
;
L
-
>
use
(
link
)
;
return
link
;
}
}
void
Assembler
:
:
bind
(
Label
*
label
BufferOffset
boff
)
{
JitSpew
(
JitSpew_Codegen
"
.
set
Llabel
%
p
%
d
"
label
currentOffset
(
)
)
;
DEBUG_PRINTF
(
"
.
set
Llabel
%
p
\
n
"
label
)
;
BufferOffset
dest
=
boff
.
assigned
(
)
?
boff
:
nextOffset
(
)
;
if
(
label
-
>
used
(
)
)
{
uint32_t
next
;
do
{
BufferOffset
b
(
label
)
;
DEBUG_PRINTF
(
"
\
tbind
next
:
%
d
\
n
"
b
.
getOffset
(
)
)
;
if
(
oom
(
)
)
{
return
;
}
int
fixup_pos
=
b
.
getOffset
(
)
;
int
dist
=
dest
.
getOffset
(
)
-
fixup_pos
;
next
=
next_link
(
label
false
)
;
DEBUG_PRINTF
(
"
\
t
%
p
fixup
:
%
d
next
:
%
d
\
n
"
label
fixup_pos
next
)
;
DEBUG_PRINTF
(
"
\
t
fixup
:
%
d
dest
:
%
d
dist
:
%
d
%
d
%
d
\
n
"
fixup_pos
dest
.
getOffset
(
)
dist
nextOffset
(
)
.
getOffset
(
)
currentOffset
(
)
)
;
Instruction
*
instruction
=
editSrc
(
b
)
;
Instr
instr
=
instruction
-
>
InstructionBits
(
)
;
if
(
IsBranch
(
instr
)
)
{
if
(
dist
>
kMaxBranchOffset
)
{
MOZ_ASSERT
(
next
!
=
LabelBase
:
:
INVALID_OFFSET
)
;
MOZ_RELEASE_ASSERT
(
(
next
-
fixup_pos
)
<
=
kMaxBranchOffset
)
;
MOZ_ASSERT
(
IsAuipc
(
editSrc
(
BufferOffset
(
next
)
)
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsJalr
(
editSrc
(
BufferOffset
(
next
+
4
)
)
-
>
InstructionBits
(
)
)
)
;
DEBUG_PRINTF
(
"
\
t
\
ttrampolining
:
%
d
\
n
"
next
)
;
}
else
{
target_at_put
(
b
dest
)
;
BufferOffset
deadline
(
b
.
getOffset
(
)
+
ImmBranchMaxForwardOffset
(
CondBranchRangeType
)
)
;
m_buffer
.
unregisterBranchDeadline
(
CondBranchRangeType
deadline
)
;
}
}
else
if
(
IsJal
(
instr
)
)
{
if
(
dist
>
kMaxJumpOffset
)
{
MOZ_ASSERT
(
next
!
=
LabelBase
:
:
INVALID_OFFSET
)
;
MOZ_RELEASE_ASSERT
(
(
next
-
fixup_pos
)
<
=
kMaxJumpOffset
)
;
MOZ_ASSERT
(
IsAuipc
(
editSrc
(
BufferOffset
(
next
)
)
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsJalr
(
editSrc
(
BufferOffset
(
next
+
4
)
)
-
>
InstructionBits
(
)
)
)
;
DEBUG_PRINTF
(
"
\
t
\
ttrampolining
:
%
d
\
n
"
next
)
;
}
else
{
target_at_put
(
b
dest
)
;
BufferOffset
deadline
(
b
.
getOffset
(
)
+
ImmBranchMaxForwardOffset
(
UncondBranchRangeType
)
)
;
m_buffer
.
unregisterBranchDeadline
(
UncondBranchRangeType
deadline
)
;
}
}
else
{
MOZ_ASSERT
(
IsAuipc
(
instr
)
)
;
target_at_put
(
b
dest
)
;
}
}
while
(
next
!
=
LabelBase
:
:
INVALID_OFFSET
)
;
}
label
-
>
bind
(
dest
.
getOffset
(
)
)
;
}
void
Assembler
:
:
Bind
(
uint8_t
*
rawCode
const
CodeLabel
&
label
)
{
if
(
label
.
patchAt
(
)
.
bound
(
)
)
{
auto
mode
=
label
.
linkMode
(
)
;
intptr_t
offset
=
label
.
patchAt
(
)
.
offset
(
)
;
intptr_t
target
=
label
.
target
(
)
.
offset
(
)
;
if
(
mode
=
=
CodeLabel
:
:
RawPointer
)
{
*
reinterpret_cast
<
const
void
*
*
>
(
rawCode
+
offset
)
=
rawCode
+
target
;
}
else
{
MOZ_ASSERT
(
mode
=
=
CodeLabel
:
:
MoveImmediate
|
|
mode
=
=
CodeLabel
:
:
JumpImmediate
)
;
Instruction
*
inst
=
(
Instruction
*
)
(
rawCode
+
offset
)
;
Assembler
:
:
UpdateLoad64Value
(
inst
(
uint64_t
)
(
rawCode
+
target
)
)
;
}
}
}
bool
Assembler
:
:
is_near
(
Label
*
L
)
{
MOZ_ASSERT
(
L
-
>
bound
(
)
)
;
return
is_intn
(
(
currentOffset
(
)
-
L
-
>
offset
(
)
)
kJumpOffsetBits
)
;
}
bool
Assembler
:
:
is_near
(
Label
*
L
OffsetSize
bits
)
{
if
(
L
=
=
nullptr
|
|
!
L
-
>
bound
(
)
)
return
true
;
return
is_intn
(
(
currentOffset
(
)
-
L
-
>
offset
(
)
)
bits
)
;
}
bool
Assembler
:
:
is_near_branch
(
Label
*
L
)
{
MOZ_ASSERT
(
L
-
>
bound
(
)
)
;
return
is_intn
(
(
currentOffset
(
)
-
L
-
>
offset
(
)
)
kBranchOffsetBits
)
;
}
int32_t
Assembler
:
:
branch_long_offset
(
Label
*
L
)
{
if
(
oom
(
)
)
{
return
kEndOfJumpChain
;
}
intptr_t
target_pos
;
BufferOffset
next_instr_offset
=
nextInstrOffset
(
2
)
;
DEBUG_PRINTF
(
"
\
tbranch_long_offset
:
%
p
to
(
%
d
)
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
if
(
L
-
>
bound
(
)
)
{
JitSpew
(
JitSpew_Codegen
"
.
use
Llabel
%
p
on
%
d
"
L
next_instr_offset
.
getOffset
(
)
)
;
target_pos
=
L
-
>
offset
(
)
;
}
else
{
if
(
L
-
>
used
(
)
)
{
LabelCache
:
:
Ptr
p
=
label_cache_
.
lookup
(
L
-
>
offset
(
)
)
;
MOZ_ASSERT
(
p
)
;
MOZ_ASSERT
(
p
-
>
key
(
)
=
=
L
-
>
offset
(
)
)
;
target_pos
=
p
-
>
value
(
)
.
getOffset
(
)
;
if
(
!
target_at_put
(
BufferOffset
(
target_pos
)
next_instr_offset
)
)
{
DEBUG_PRINTF
(
"
\
tLabel
%
p
can
'
t
be
added
to
link
:
%
d
-
>
%
d
\
n
"
L
BufferOffset
(
target_pos
)
.
getOffset
(
)
next_instr_offset
.
getOffset
(
)
)
;
return
kEndOfJumpChain
;
}
DEBUG_PRINTF
(
"
\
tLabel
%
p
added
to
link
:
%
d
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
bool
ok
=
label_cache_
.
put
(
L
-
>
offset
(
)
next_instr_offset
)
;
if
(
!
ok
)
{
NoEnoughLabelCache
(
)
;
}
return
kEndOfJumpChain
;
}
else
{
JitSpew
(
JitSpew_Codegen
"
.
use
Llabel
%
p
on
%
d
"
L
next_instr_offset
.
getOffset
(
)
)
;
L
-
>
use
(
next_instr_offset
.
getOffset
(
)
)
;
DEBUG_PRINTF
(
"
\
tLabel
%
p
added
to
link
:
%
d
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
bool
ok
=
label_cache_
.
putNew
(
L
-
>
offset
(
)
next_instr_offset
)
;
if
(
!
ok
)
{
NoEnoughLabelCache
(
)
;
}
return
kEndOfJumpChain
;
}
}
intptr_t
offset
=
target_pos
-
next_instr_offset
.
getOffset
(
)
;
MOZ_ASSERT
(
(
offset
&
3
)
=
=
0
)
;
MOZ_ASSERT
(
is_int32
(
offset
)
)
;
return
static_cast
<
int32_t
>
(
offset
)
;
}
int32_t
Assembler
:
:
branch_offset_helper
(
Label
*
L
OffsetSize
bits
)
{
if
(
oom
(
)
)
{
return
kEndOfJumpChain
;
}
int32_t
target_pos
;
BufferOffset
next_instr_offset
=
nextInstrOffset
(
)
;
DEBUG_PRINTF
(
"
\
tbranch_offset_helper
:
%
p
to
%
d
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
if
(
L
-
>
bound
(
)
)
{
JitSpew
(
JitSpew_Codegen
"
.
use
Llabel
%
p
on
%
d
"
L
next_instr_offset
.
getOffset
(
)
)
;
target_pos
=
L
-
>
offset
(
)
;
}
else
{
BufferOffset
deadline
(
next_instr_offset
.
getOffset
(
)
+
ImmBranchMaxForwardOffset
(
bits
)
)
;
DEBUG_PRINTF
(
"
\
tregisterBranchDeadline
%
d
type
%
d
\
n
"
deadline
.
getOffset
(
)
OffsetSizeToImmBranchRangeType
(
bits
)
)
;
m_buffer
.
registerBranchDeadline
(
OffsetSizeToImmBranchRangeType
(
bits
)
deadline
)
;
if
(
L
-
>
used
(
)
)
{
LabelCache
:
:
Ptr
p
=
label_cache_
.
lookup
(
L
-
>
offset
(
)
)
;
MOZ_ASSERT
(
p
)
;
MOZ_ASSERT
(
p
-
>
key
(
)
=
=
L
-
>
offset
(
)
)
;
target_pos
=
p
-
>
value
(
)
.
getOffset
(
)
;
if
(
!
target_at_put
(
BufferOffset
(
target_pos
)
next_instr_offset
)
)
{
DEBUG_PRINTF
(
"
\
tLabel
%
p
can
'
t
be
added
to
link
:
%
d
-
>
%
d
\
n
"
L
BufferOffset
(
target_pos
)
.
getOffset
(
)
next_instr_offset
.
getOffset
(
)
)
;
return
kEndOfJumpChain
;
}
DEBUG_PRINTF
(
"
\
tLabel
%
p
added
to
link
:
%
d
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
bool
ok
=
label_cache_
.
put
(
L
-
>
offset
(
)
next_instr_offset
)
;
if
(
!
ok
)
{
NoEnoughLabelCache
(
)
;
}
return
kEndOfJumpChain
;
}
else
{
JitSpew
(
JitSpew_Codegen
"
.
use
Llabel
%
p
on
%
d
"
L
next_instr_offset
.
getOffset
(
)
)
;
L
-
>
use
(
next_instr_offset
.
getOffset
(
)
)
;
bool
ok
=
label_cache_
.
putNew
(
L
-
>
offset
(
)
next_instr_offset
)
;
if
(
!
ok
)
{
NoEnoughLabelCache
(
)
;
}
DEBUG_PRINTF
(
"
\
tLabel
%
p
added
to
link
:
%
d
\
n
"
L
next_instr_offset
.
getOffset
(
)
)
;
return
kEndOfJumpChain
;
}
}
int32_t
offset
=
target_pos
-
next_instr_offset
.
getOffset
(
)
;
DEBUG_PRINTF
(
"
\
toffset
=
%
d
\
n
"
offset
)
;
MOZ_ASSERT
(
is_intn
(
offset
bits
)
)
;
MOZ_ASSERT
(
(
offset
&
1
)
=
=
0
)
;
return
offset
;
}
Assembler
:
:
Condition
Assembler
:
:
InvertCondition
(
Condition
cond
)
{
switch
(
cond
)
{
case
Equal
:
return
NotEqual
;
case
NotEqual
:
return
Equal
;
case
Zero
:
return
NonZero
;
case
NonZero
:
return
Zero
;
case
LessThan
:
return
GreaterThanOrEqual
;
case
LessThanOrEqual
:
return
GreaterThan
;
case
GreaterThan
:
return
LessThanOrEqual
;
case
GreaterThanOrEqual
:
return
LessThan
;
case
Above
:
return
BelowOrEqual
;
case
AboveOrEqual
:
return
Below
;
case
Below
:
return
AboveOrEqual
;
case
BelowOrEqual
:
return
Above
;
case
Signed
:
return
NotSigned
;
case
NotSigned
:
return
Signed
;
default
:
MOZ_CRASH
(
"
unexpected
condition
"
)
;
}
}
Assembler
:
:
DoubleCondition
Assembler
:
:
InvertCondition
(
DoubleCondition
cond
)
{
switch
(
cond
)
{
case
DoubleOrdered
:
return
DoubleUnordered
;
case
DoubleEqual
:
return
DoubleNotEqualOrUnordered
;
case
DoubleNotEqual
:
return
DoubleEqualOrUnordered
;
case
DoubleGreaterThan
:
return
DoubleLessThanOrEqualOrUnordered
;
case
DoubleGreaterThanOrEqual
:
return
DoubleLessThanOrUnordered
;
case
DoubleLessThan
:
return
DoubleGreaterThanOrEqualOrUnordered
;
case
DoubleLessThanOrEqual
:
return
DoubleGreaterThanOrUnordered
;
case
DoubleUnordered
:
return
DoubleOrdered
;
case
DoubleEqualOrUnordered
:
return
DoubleNotEqual
;
case
DoubleNotEqualOrUnordered
:
return
DoubleEqual
;
case
DoubleGreaterThanOrUnordered
:
return
DoubleLessThanOrEqual
;
case
DoubleGreaterThanOrEqualOrUnordered
:
return
DoubleLessThan
;
case
DoubleLessThanOrUnordered
:
return
DoubleGreaterThanOrEqual
;
case
DoubleLessThanOrEqualOrUnordered
:
return
DoubleGreaterThan
;
default
:
MOZ_CRASH
(
"
unexpected
condition
"
)
;
}
}
void
Assembler
:
:
break_
(
uint32_t
code
bool
break_as_stop
)
{
MOZ_ASSERT
(
(
break_as_stop
&
&
code
<
=
kMaxStopCode
&
&
code
>
kMaxTracepointCode
)
|
|
(
!
break_as_stop
&
&
(
code
>
kMaxStopCode
|
|
code
<
=
kMaxTracepointCode
)
)
)
;
ebreak
(
)
;
MOZ_ASSERT
(
is_uint20
(
code
)
)
;
lui
(
zero_reg
code
)
;
}
void
Assembler
:
:
ToggleToJmp
(
CodeLocationLabel
inst_
)
{
Instruction
*
inst
=
(
Instruction
*
)
inst_
.
raw
(
)
;
MOZ_ASSERT
(
IsAddi
(
inst
-
>
InstructionBits
(
)
)
)
;
int32_t
offset
=
inst
-
>
Imm12Value
(
)
;
MOZ_ASSERT
(
is_int12
(
offset
)
)
;
Instr
jal_
=
JAL
|
(
0b000
<
<
kFunct3Shift
)
|
(
offset
&
0xff000
)
|
(
(
offset
&
0x800
)
<
<
9
)
|
(
(
offset
&
0x7fe
)
<
<
20
)
|
(
(
offset
&
0x100000
)
<
<
11
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst
)
=
jal_
;
}
void
Assembler
:
:
ToggleToCmp
(
CodeLocationLabel
inst_
)
{
Instruction
*
inst
=
(
Instruction
*
)
inst_
.
raw
(
)
;
MOZ_ASSERT
(
IsJal
(
inst
-
>
InstructionBits
(
)
)
)
;
int32_t
offset
=
inst
-
>
Imm20JValue
(
)
;
MOZ_ASSERT
(
is_int12
(
offset
)
)
;
Instr
addi_
=
OP_IMM
|
(
0b000
<
<
kFunct3Shift
)
|
(
offset
<
<
kImm12Shift
)
;
*
reinterpret_cast
<
Instr
*
>
(
inst
)
=
addi_
;
}
bool
Assembler
:
:
reserve
(
size_t
size
)
{
return
!
oom
(
)
;
}
static
JitCode
*
CodeFromJump
(
Instruction
*
jump
)
{
uint8_t
*
target
=
(
uint8_t
*
)
Assembler
:
:
ExtractLoad64Value
(
jump
)
;
return
JitCode
:
:
FromExecutable
(
target
)
;
}
void
Assembler
:
:
TraceJumpRelocations
(
JSTracer
*
trc
JitCode
*
code
CompactBufferReader
&
reader
)
{
while
(
reader
.
more
(
)
)
{
JitCode
*
child
=
CodeFromJump
(
(
Instruction
*
)
(
code
-
>
raw
(
)
+
reader
.
readUnsigned
(
)
)
)
;
TraceManuallyBarrieredEdge
(
trc
&
child
"
rel32
"
)
;
}
}
static
void
TraceOneDataRelocation
(
JSTracer
*
trc
mozilla
:
:
Maybe
<
AutoWritableJitCode
>
&
awjc
JitCode
*
code
Instruction
*
inst
)
{
void
*
ptr
=
(
void
*
)
Assembler
:
:
ExtractLoad64Value
(
inst
)
;
void
*
prior
=
ptr
;
uintptr_t
word
=
reinterpret_cast
<
uintptr_t
>
(
ptr
)
;
if
(
word
>
>
JSVAL_TAG_SHIFT
)
{
Value
v
=
Value
:
:
fromRawBits
(
word
)
;
TraceManuallyBarrieredEdge
(
trc
&
v
"
jit
-
masm
-
value
"
)
;
ptr
=
(
void
*
)
v
.
bitsAsPunboxPointer
(
)
;
}
else
{
TraceManuallyBarrieredGenericPointerEdge
(
trc
reinterpret_cast
<
gc
:
:
Cell
*
*
>
(
&
ptr
)
"
jit
-
masm
-
ptr
"
)
;
}
if
(
ptr
!
=
prior
)
{
if
(
awjc
.
isNothing
(
)
)
{
awjc
.
emplace
(
code
)
;
}
Assembler
:
:
UpdateLoad64Value
(
inst
uint64_t
(
ptr
)
)
;
}
}
void
Assembler
:
:
TraceDataRelocations
(
JSTracer
*
trc
JitCode
*
code
CompactBufferReader
&
reader
)
{
mozilla
:
:
Maybe
<
AutoWritableJitCode
>
awjc
;
while
(
reader
.
more
(
)
)
{
size_t
offset
=
reader
.
readUnsigned
(
)
;
Instruction
*
inst
=
(
Instruction
*
)
(
code
-
>
raw
(
)
+
offset
)
;
TraceOneDataRelocation
(
trc
awjc
code
inst
)
;
}
}
UseScratchRegisterScope
:
:
UseScratchRegisterScope
(
Assembler
&
assembler
)
:
available_
(
assembler
.
GetScratchRegisterList
(
)
)
old_available_
(
*
available_
)
{
}
UseScratchRegisterScope
:
:
UseScratchRegisterScope
(
Assembler
*
assembler
)
:
available_
(
assembler
-
>
GetScratchRegisterList
(
)
)
old_available_
(
*
available_
)
{
}
UseScratchRegisterScope
:
:
~
UseScratchRegisterScope
(
)
{
*
available_
=
old_available_
;
}
Register
UseScratchRegisterScope
:
:
Acquire
(
)
{
MOZ_ASSERT
(
available_
!
=
nullptr
)
;
MOZ_ASSERT
(
!
available_
-
>
empty
(
)
)
;
Register
index
=
GeneralRegisterSet
:
:
FirstRegister
(
available_
-
>
bits
(
)
)
;
available_
-
>
takeRegisterIndex
(
index
)
;
return
index
;
}
void
UseScratchRegisterScope
:
:
Release
(
const
Register
&
reg
)
{
MOZ_ASSERT
(
available_
!
=
nullptr
)
;
MOZ_ASSERT
(
old_available_
.
hasRegisterIndex
(
reg
)
)
;
MOZ_ASSERT
(
!
available_
-
>
hasRegisterIndex
(
reg
)
)
;
Include
(
GeneralRegisterSet
(
1
<
<
reg
.
code
(
)
)
)
;
}
bool
UseScratchRegisterScope
:
:
hasAvailable
(
)
const
{
return
(
available_
-
>
size
(
)
)
!
=
0
;
}
void
Assembler
:
:
retarget
(
Label
*
label
Label
*
target
)
{
spew
(
"
retarget
%
p
-
>
%
p
"
label
target
)
;
if
(
label
-
>
used
(
)
&
&
!
oom
(
)
)
{
if
(
target
-
>
bound
(
)
)
{
bind
(
label
BufferOffset
(
target
)
)
;
}
else
if
(
target
-
>
used
(
)
)
{
int32_t
next
;
BufferOffset
labelBranchOffset
(
label
)
;
do
{
next
=
next_link
(
label
false
)
;
labelBranchOffset
=
BufferOffset
(
next
)
;
}
while
(
next
!
=
LabelBase
:
:
INVALID_OFFSET
)
;
target
-
>
use
(
label
-
>
offset
(
)
)
;
target_at_put
(
labelBranchOffset
BufferOffset
(
target
)
)
;
MOZ_CRASH
(
"
check
"
)
;
}
else
{
target
-
>
use
(
label
-
>
offset
(
)
)
;
}
}
label
-
>
reset
(
)
;
}
bool
Assembler
:
:
appendRawCode
(
const
uint8_t
*
code
size_t
numBytes
)
{
if
(
m_buffer
.
oom
(
)
)
{
return
false
;
}
while
(
numBytes
>
SliceSize
)
{
m_buffer
.
putBytes
(
SliceSize
code
)
;
numBytes
-
=
SliceSize
;
code
+
=
SliceSize
;
}
m_buffer
.
putBytes
(
numBytes
code
)
;
return
!
m_buffer
.
oom
(
)
;
}
void
Assembler
:
:
ToggleCall
(
CodeLocationLabel
inst_
bool
enabled
)
{
Instruction
*
i0
=
(
Instruction
*
)
inst_
.
raw
(
)
;
Instruction
*
i1
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
1
*
kInstrSize
)
;
Instruction
*
i2
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
2
*
kInstrSize
)
;
Instruction
*
i3
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
3
*
kInstrSize
)
;
Instruction
*
i4
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
4
*
kInstrSize
)
;
Instruction
*
i5
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
5
*
kInstrSize
)
;
Instruction
*
i6
=
(
Instruction
*
)
(
inst_
.
raw
(
)
+
6
*
kInstrSize
)
;
MOZ_ASSERT
(
IsLui
(
i0
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsAddi
(
i1
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsSlli
(
i2
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsOri
(
i3
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsSlli
(
i4
-
>
InstructionBits
(
)
)
)
;
MOZ_ASSERT
(
IsOri
(
i5
-
>
InstructionBits
(
)
)
)
;
if
(
enabled
)
{
Instr
jalr_
=
JALR
|
(
ra
.
code
(
)
<
<
kRdShift
)
|
(
0x0
<
<
kFunct3Shift
)
|
(
i5
-
>
RdValue
(
)
<
<
kRs1Shift
)
|
(
0x0
<
<
kImm12Shift
)
;
*
(
(
Instr
*
)
i6
)
=
jalr_
;
}
else
{
*
(
(
Instr
*
)
i6
)
=
kNopByte
;
}
}
void
Assembler
:
:
PatchShortRangeBranchToVeneer
(
Buffer
*
buffer
unsigned
rangeIdx
BufferOffset
deadline
BufferOffset
veneer
)
{
if
(
buffer
-
>
oom
(
)
)
{
return
;
}
DEBUG_PRINTF
(
"
\
tPatchShortRangeBranchToVeneer
\
n
"
)
;
ImmBranchRangeType
branchRange
=
static_cast
<
ImmBranchRangeType
>
(
rangeIdx
)
;
BufferOffset
branch
(
deadline
.
getOffset
(
)
-
ImmBranchMaxForwardOffset
(
branchRange
)
)
;
Instruction
*
branchInst
=
buffer
-
>
getInst
(
branch
)
;
Instruction
*
veneerInst_1
=
buffer
-
>
getInst
(
veneer
)
;
Instruction
*
veneerInst_2
=
buffer
-
>
getInst
(
BufferOffset
(
veneer
.
getOffset
(
)
+
4
)
)
;
DEBUG_PRINTF
(
"
\
t
%
p
(
%
x
)
:
"
branchInst
branch
.
getOffset
(
)
)
;
disassembleInstr
(
branchInst
-
>
InstructionBits
(
)
JitSpew_Codegen
)
;
DEBUG_PRINTF
(
"
\
t
instert
veneer
%
x
branch
:
%
x
deadline
:
%
x
\
n
"
veneer
.
getOffset
(
)
branch
.
getOffset
(
)
deadline
.
getOffset
(
)
)
;
MOZ_ASSERT
(
branchRange
<
=
UncondBranchRangeType
)
;
MOZ_ASSERT
(
branchInst
-
>
GetImmBranchRangeType
(
)
=
=
branchRange
)
;
Instr
auipc
=
AUIPC
|
(
t6
.
code
(
)
<
<
kRdShift
)
|
(
0x0
<
<
kImm20Shift
)
;
Instr
jalr
=
JALR
|
(
zero_reg
.
code
(
)
<
<
kRdShift
)
|
(
0x0
<
<
kFunct3Shift
)
|
(
t6
.
code
(
)
<
<
kRs1Shift
)
|
(
0x0
<
<
kImm12Shift
)
;
int32_t
nextElemOffset
=
target_at
(
buffer
-
>
getInst
(
branch
)
branch
false
)
;
int32_t
dist
;
if
(
nextElemOffset
!
=
kEndOfChain
)
{
dist
=
nextElemOffset
-
veneer
.
getOffset
(
)
;
}
else
{
dist
=
0
;
}
int32_t
Hi20
=
(
(
(
int32_t
)
dist
+
0x800
)
>
>
12
)
;
int32_t
Lo12
=
(
int32_t
)
dist
<
<
20
>
>
20
;
auipc
=
SetAuipcOffset
(
Hi20
auipc
)
;
jalr
=
SetJalrOffset
(
Lo12
jalr
)
;
veneerInst_1
-
>
SetInstructionBits
(
auipc
)
;
veneerInst_2
-
>
SetInstructionBits
(
jalr
)
;
if
(
IsBranch
(
branchInst
-
>
InstructionBits
(
)
)
)
{
branchInst
-
>
SetInstructionBits
(
SetBranchOffset
(
branch
.
getOffset
(
)
veneer
.
getOffset
(
)
branchInst
-
>
InstructionBits
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
IsJal
(
branchInst
-
>
InstructionBits
(
)
)
)
;
branchInst
-
>
SetInstructionBits
(
SetJalOffset
(
branch
.
getOffset
(
)
veneer
.
getOffset
(
)
branchInst
-
>
InstructionBits
(
)
)
)
;
}
DEBUG_PRINTF
(
"
\
tfix
to
veneer
:
"
)
;
disassembleInstr
(
branchInst
-
>
InstructionBits
(
)
)
;
}
}
}
