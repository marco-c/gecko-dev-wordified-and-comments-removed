#
ifndef
jit_TrialInlining_h
#
define
jit_TrialInlining_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
jit
/
CacheIR
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSScript
.
h
"
class
JS_PUBLIC_API
JSTracer
;
struct
JS_PUBLIC_API
JSContext
;
class
JSFunction
;
namespace
JS
{
class
Zone
;
}
namespace
js
{
class
BytecodeLocation
;
namespace
jit
{
class
BaselineFrame
;
class
CacheIRWriter
;
class
ICCacheIRStub
;
class
ICEntry
;
class
ICFallbackStub
;
class
ICScript
;
class
InliningRoot
{
public
:
explicit
InliningRoot
(
JSContext
*
cx
JSScript
*
owningScript
)
:
owningScript_
(
owningScript
)
inlinedScripts_
(
cx
)
totalBytecodeSize_
(
owningScript
-
>
length
(
)
)
{
}
JitScriptICStubSpace
*
jitScriptStubSpace
(
)
{
return
&
jitScriptStubSpace_
;
}
void
trace
(
JSTracer
*
trc
)
;
bool
addInlinedScript
(
js
:
:
UniquePtr
<
ICScript
>
icScript
)
;
uint32_t
numInlinedScripts
(
)
const
{
return
inlinedScripts_
.
length
(
)
;
}
void
purgeOptimizedStubs
(
Zone
*
zone
)
;
void
resetWarmUpCounts
(
uint32_t
count
)
;
JSScript
*
owningScript
(
)
const
{
return
owningScript_
;
}
size_t
totalBytecodeSize
(
)
const
{
return
totalBytecodeSize_
;
}
void
addToTotalBytecodeSize
(
size_t
size
)
{
totalBytecodeSize_
+
=
size
;
}
private
:
JitScriptICStubSpace
jitScriptStubSpace_
=
{
}
;
HeapPtr
<
JSScript
*
>
owningScript_
;
js
:
:
Vector
<
js
:
:
UniquePtr
<
ICScript
>
>
inlinedScripts_
;
size_t
totalBytecodeSize_
;
}
;
class
InlinableOpData
{
public
:
JSFunction
*
target
=
nullptr
;
ICScript
*
icScript
=
nullptr
;
const
uint8_t
*
endOfSharedPrefix
=
nullptr
;
}
;
class
InlinableCallData
:
public
InlinableOpData
{
public
:
ObjOperandId
calleeOperand
;
CallFlags
callFlags
;
}
;
class
InlinableGetterData
:
public
InlinableOpData
{
public
:
ValOperandId
receiverOperand
;
bool
sameRealm
=
false
;
}
;
class
InlinableSetterData
:
public
InlinableOpData
{
public
:
ObjOperandId
receiverOperand
;
ValOperandId
rhsOperand
;
bool
sameRealm
=
false
;
}
;
mozilla
:
:
Maybe
<
InlinableOpData
>
FindInlinableOpData
(
ICCacheIRStub
*
stub
BytecodeLocation
loc
)
;
mozilla
:
:
Maybe
<
InlinableCallData
>
FindInlinableCallData
(
ICCacheIRStub
*
stub
)
;
mozilla
:
:
Maybe
<
InlinableGetterData
>
FindInlinableGetterData
(
ICCacheIRStub
*
stub
)
;
mozilla
:
:
Maybe
<
InlinableSetterData
>
FindInlinableSetterData
(
ICCacheIRStub
*
stub
)
;
class
MOZ_RAII
TrialInliner
{
public
:
TrialInliner
(
JSContext
*
cx
HandleScript
script
ICScript
*
icScript
InliningRoot
*
root
)
:
cx_
(
cx
)
script_
(
script
)
icScript_
(
icScript
)
root_
(
root
)
{
}
JSContext
*
cx
(
)
{
return
cx_
;
}
[
[
nodiscard
]
]
bool
tryInlining
(
)
;
[
[
nodiscard
]
]
bool
maybeInlineCall
(
ICEntry
&
entry
ICFallbackStub
*
fallback
BytecodeLocation
loc
)
;
[
[
nodiscard
]
]
bool
maybeInlineGetter
(
ICEntry
&
entry
ICFallbackStub
*
fallback
BytecodeLocation
loc
CacheKind
kind
)
;
[
[
nodiscard
]
]
bool
maybeInlineSetter
(
ICEntry
&
entry
ICFallbackStub
*
fallback
BytecodeLocation
loc
CacheKind
kind
)
;
static
bool
canInline
(
JSFunction
*
target
HandleScript
caller
BytecodeLocation
loc
)
;
private
:
ICCacheIRStub
*
maybeSingleStub
(
const
ICEntry
&
entry
)
;
void
cloneSharedPrefix
(
ICCacheIRStub
*
stub
const
uint8_t
*
endOfPrefix
CacheIRWriter
&
writer
)
;
ICScript
*
createInlinedICScript
(
JSFunction
*
target
BytecodeLocation
loc
)
;
[
[
nodiscard
]
]
bool
replaceICStub
(
ICEntry
&
entry
ICFallbackStub
*
fallback
CacheIRWriter
&
writer
CacheKind
kind
)
;
bool
shouldInline
(
JSFunction
*
target
ICCacheIRStub
*
stub
BytecodeLocation
loc
)
;
JSContext
*
cx_
;
HandleScript
script_
;
ICScript
*
icScript_
;
InliningRoot
*
root_
;
}
;
bool
DoTrialInlining
(
JSContext
*
cx
BaselineFrame
*
frame
)
;
}
}
#
endif
