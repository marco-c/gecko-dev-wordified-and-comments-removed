#
ifndef
jit_MacroAssembler_h
#
define
jit_MacroAssembler_h
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
jscompartment
.
h
"
#
if
defined
(
JS_CODEGEN_X86
)
#
include
"
jit
/
x86
/
MacroAssembler
-
x86
.
h
"
#
elif
defined
(
JS_CODEGEN_X64
)
#
include
"
jit
/
x64
/
MacroAssembler
-
x64
.
h
"
#
elif
defined
(
JS_CODEGEN_ARM
)
#
include
"
jit
/
arm
/
MacroAssembler
-
arm
.
h
"
#
elif
defined
(
JS_CODEGEN_ARM64
)
#
include
"
jit
/
arm64
/
MacroAssembler
-
arm64
.
h
"
#
elif
defined
(
JS_CODEGEN_MIPS32
)
#
include
"
jit
/
mips32
/
MacroAssembler
-
mips32
.
h
"
#
elif
defined
(
JS_CODEGEN_MIPS64
)
#
include
"
jit
/
mips64
/
MacroAssembler
-
mips64
.
h
"
#
elif
defined
(
JS_CODEGEN_NONE
)
#
include
"
jit
/
none
/
MacroAssembler
-
none
.
h
"
#
else
#
error
"
Unknown
architecture
!
"
#
endif
#
include
"
jit
/
AtomicOp
.
h
"
#
include
"
jit
/
IonInstrumentation
.
h
"
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
UnboxedObject
.
h
"
#
define
ALL_ARCH
mips32
mips64
arm
arm64
x86
x64
#
define
ALL_SHARED_ARCH
arm
arm64
x86_shared
mips_shared
#
define
DEFINED_ON_x86
#
define
DEFINED_ON_x64
#
define
DEFINED_ON_x86_shared
#
define
DEFINED_ON_arm
#
define
DEFINED_ON_arm64
#
define
DEFINED_ON_mips32
#
define
DEFINED_ON_mips64
#
define
DEFINED_ON_mips_shared
#
define
DEFINED_ON_none
#
if
defined
(
JS_CODEGEN_X86
)
#
undef
DEFINED_ON_x86
#
define
DEFINED_ON_x86
define
#
undef
DEFINED_ON_x86_shared
#
define
DEFINED_ON_x86_shared
define
#
elif
defined
(
JS_CODEGEN_X64
)
#
undef
DEFINED_ON_x64
#
define
DEFINED_ON_x64
define
#
undef
DEFINED_ON_x86_shared
#
define
DEFINED_ON_x86_shared
define
#
elif
defined
(
JS_CODEGEN_ARM
)
#
undef
DEFINED_ON_arm
#
define
DEFINED_ON_arm
define
#
elif
defined
(
JS_CODEGEN_ARM64
)
#
undef
DEFINED_ON_arm64
#
define
DEFINED_ON_arm64
define
#
elif
defined
(
JS_CODEGEN_MIPS32
)
#
undef
DEFINED_ON_mips32
#
define
DEFINED_ON_mips32
define
#
undef
DEFINED_ON_mips_shared
#
define
DEFINED_ON_mips_shared
define
#
elif
defined
(
JS_CODEGEN_MIPS64
)
#
undef
DEFINED_ON_mips64
#
define
DEFINED_ON_mips64
define
#
undef
DEFINED_ON_mips_shared
#
define
DEFINED_ON_mips_shared
define
#
elif
defined
(
JS_CODEGEN_NONE
)
#
undef
DEFINED_ON_none
#
define
DEFINED_ON_none
crash
#
else
#
error
"
Unknown
architecture
!
"
#
endif
#
define
DEFINED_ON_RESULT_crash
{
MOZ_CRASH
(
)
;
}
#
define
DEFINED_ON_RESULT_define
#
define
DEFINED_ON_RESULT_
=
delete
#
define
DEFINED_ON_DISPATCH_RESULT_2
(
Macro
Result
)
\
Macro
#
#
Result
#
define
DEFINED_ON_DISPATCH_RESULT
(
.
.
.
)
\
DEFINED_ON_DISPATCH_RESULT_2
(
DEFINED_ON_RESULT_
__VA_ARGS__
)
#
define
DEFINED_ON_EXPAND_ARCH_RESULTS_3
(
ParenResult
)
\
DEFINED_ON_DISPATCH_RESULT
ParenResult
#
define
DEFINED_ON_EXPAND_ARCH_RESULTS_2
(
ParenResult
)
\
DEFINED_ON_EXPAND_ARCH_RESULTS_3
(
ParenResult
)
#
define
DEFINED_ON_EXPAND_ARCH_RESULTS
(
ParenResult
)
\
DEFINED_ON_EXPAND_ARCH_RESULTS_2
(
ParenResult
)
#
define
DEFINED_ON_FWDARCH
(
Arch
)
DEFINED_ON_
#
#
Arch
#
define
DEFINED_ON_MAP_ON_ARCHS
(
ArchList
)
\
DEFINED_ON_EXPAND_ARCH_RESULTS
(
\
(
MOZ_FOR_EACH
(
DEFINED_ON_FWDARCH
(
)
ArchList
)
)
)
#
define
DEFINED_ON
(
.
.
.
)
\
DEFINED_ON_MAP_ON_ARCHS
(
(
none
__VA_ARGS__
)
)
#
define
PER_ARCH
DEFINED_ON
(
ALL_ARCH
)
#
define
PER_SHARED_ARCH
DEFINED_ON
(
ALL_SHARED_ARCH
)
#
ifdef
IS_LITTLE_ENDIAN
#
define
IMM32_16ADJ
(
X
)
X
<
<
16
#
else
#
define
IMM32_16ADJ
(
X
)
X
#
endif
namespace
js
{
namespace
jit
{
enum
ExitFrameTokenValues
;
class
MacroAssembler
:
public
MacroAssemblerSpecific
{
MacroAssembler
*
thisFromCtor
(
)
{
return
this
;
}
public
:
class
AutoRooter
:
public
JS
:
:
AutoGCRooter
{
MacroAssembler
*
masm_
;
public
:
AutoRooter
(
JSContext
*
cx
MacroAssembler
*
masm
)
:
JS
:
:
AutoGCRooter
(
cx
IONMASM
)
masm_
(
masm
)
{
}
MacroAssembler
*
masm
(
)
const
{
return
masm_
;
}
}
;
class
Branch
{
bool
init_
;
Condition
cond_
;
Label
*
jump_
;
Register
reg_
;
public
:
Branch
(
)
:
init_
(
false
)
cond_
(
Equal
)
jump_
(
nullptr
)
reg_
(
Register
:
:
FromCode
(
0
)
)
{
}
Branch
(
Condition
cond
Register
reg
Label
*
jump
)
:
init_
(
true
)
cond_
(
cond
)
jump_
(
jump
)
reg_
(
reg
)
{
}
bool
isInitialized
(
)
const
{
return
init_
;
}
Condition
cond
(
)
const
{
return
cond_
;
}
Label
*
jump
(
)
const
{
return
jump_
;
}
Register
reg
(
)
const
{
return
reg_
;
}
void
invertCondition
(
)
{
cond_
=
InvertCondition
(
cond_
)
;
}
void
relink
(
Label
*
jump
)
{
jump_
=
jump
;
}
virtual
void
emit
(
MacroAssembler
&
masm
)
=
0
;
}
;
class
BranchType
:
public
Branch
{
TypeSet
:
:
Type
type_
;
public
:
BranchType
(
)
:
Branch
(
)
type_
(
TypeSet
:
:
UnknownType
(
)
)
{
}
BranchType
(
Condition
cond
Register
reg
TypeSet
:
:
Type
type
Label
*
jump
)
:
Branch
(
cond
reg
jump
)
type_
(
type
)
{
}
void
emit
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
MIRType
mirType
=
MIRType_None
;
if
(
type_
.
isPrimitive
(
)
)
{
if
(
type_
.
isMagicArguments
(
)
)
mirType
=
MIRType_MagicOptimizedArguments
;
else
mirType
=
MIRTypeFromValueType
(
type_
.
primitive
(
)
)
;
}
else
if
(
type_
.
isAnyObject
(
)
)
{
mirType
=
MIRType_Object
;
}
else
{
MOZ_CRASH
(
"
Unknown
conversion
to
mirtype
"
)
;
}
if
(
mirType
=
=
MIRType_Double
)
masm
.
branchTestNumber
(
cond
(
)
reg
(
)
jump
(
)
)
;
else
masm
.
branchTestMIRType
(
cond
(
)
reg
(
)
mirType
jump
(
)
)
;
}
}
;
class
BranchGCPtr
:
public
Branch
{
ImmGCPtr
ptr_
;
public
:
BranchGCPtr
(
)
:
Branch
(
)
ptr_
(
ImmGCPtr
(
nullptr
)
)
{
}
BranchGCPtr
(
Condition
cond
Register
reg
ImmGCPtr
ptr
Label
*
jump
)
:
Branch
(
cond
reg
jump
)
ptr_
(
ptr
)
{
}
void
emit
(
MacroAssembler
&
masm
)
;
}
;
mozilla
:
:
Maybe
<
AutoRooter
>
autoRooter_
;
mozilla
:
:
Maybe
<
JitContext
>
jitContext_
;
mozilla
:
:
Maybe
<
AutoJitContextAlloc
>
alloc_
;
private
:
NonAssertingLabel
failureLabel_
;
public
:
MacroAssembler
(
)
:
framePushed_
(
0
)
#
ifdef
DEBUG
inCall_
(
false
)
#
endif
emitProfilingInstrumentation_
(
false
)
{
JitContext
*
jcx
=
GetJitContext
(
)
;
JSContext
*
cx
=
jcx
-
>
cx
;
if
(
cx
)
constructRoot
(
cx
)
;
if
(
!
jcx
-
>
temp
)
{
MOZ_ASSERT
(
cx
)
;
alloc_
.
emplace
(
cx
)
;
}
moveResolver_
.
setAllocator
(
*
jcx
-
>
temp
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
initWithAllocator
(
)
;
m_buffer
.
id
=
jcx
-
>
getNextAssemblerId
(
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
initWithAllocator
(
)
;
armbuffer_
.
id
=
jcx
-
>
getNextAssemblerId
(
)
;
#
endif
}
explicit
MacroAssembler
(
JSContext
*
cx
IonScript
*
ion
=
nullptr
JSScript
*
script
=
nullptr
jsbytecode
*
pc
=
nullptr
)
;
struct
AsmJSToken
{
}
;
explicit
MacroAssembler
(
AsmJSToken
TempAllocator
&
alloc
)
:
framePushed_
(
0
)
#
ifdef
DEBUG
inCall_
(
false
)
#
endif
emitProfilingInstrumentation_
(
false
)
{
moveResolver_
.
setAllocator
(
alloc
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
initWithAllocator
(
)
;
m_buffer
.
id
=
0
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
initWithAllocator
(
)
;
armbuffer_
.
id
=
0
;
#
endif
}
void
constructRoot
(
JSContext
*
cx
)
{
autoRooter_
.
emplace
(
cx
this
)
;
}
MoveResolver
&
moveResolver
(
)
{
return
moveResolver_
;
}
size_t
instructionsSize
(
)
const
{
return
size
(
)
;
}
public
:
inline
uint32_t
framePushed
(
)
const
;
inline
void
setFramePushed
(
uint32_t
framePushed
)
;
inline
void
adjustFrame
(
int32_t
value
)
;
inline
void
implicitPop
(
uint32_t
bytes
)
;
private
:
uint32_t
framePushed_
;
public
:
void
PushRegsInMask
(
LiveRegisterSet
set
)
DEFINED_ON
(
arm
arm64
mips32
mips64
x86_shared
)
;
void
PushRegsInMask
(
LiveGeneralRegisterSet
set
)
;
void
PopRegsInMask
(
LiveRegisterSet
set
)
;
void
PopRegsInMask
(
LiveGeneralRegisterSet
set
)
;
void
PopRegsInMaskIgnore
(
LiveRegisterSet
set
LiveRegisterSet
ignore
)
DEFINED_ON
(
arm
arm64
mips32
mips64
x86_shared
)
;
void
Push
(
const
Operand
op
)
DEFINED_ON
(
x86_shared
)
;
void
Push
(
Register
reg
)
PER_SHARED_ARCH
;
void
Push
(
Register
reg1
Register
reg2
Register
reg3
Register
reg4
)
DEFINED_ON
(
arm64
)
;
void
Push
(
const
Imm32
imm
)
PER_SHARED_ARCH
;
void
Push
(
const
ImmWord
imm
)
PER_SHARED_ARCH
;
void
Push
(
const
ImmPtr
imm
)
PER_SHARED_ARCH
;
void
Push
(
const
ImmGCPtr
ptr
)
PER_SHARED_ARCH
;
void
Push
(
FloatRegister
reg
)
PER_SHARED_ARCH
;
void
Push
(
jsid
id
Register
scratchReg
)
;
void
Push
(
TypedOrValueRegister
v
)
;
void
Push
(
ConstantOrRegister
v
)
;
void
Push
(
const
ValueOperand
&
val
)
;
void
Push
(
const
Value
&
val
)
;
void
Push
(
JSValueType
type
Register
reg
)
;
void
PushValue
(
const
Address
&
addr
)
;
void
PushEmptyRooted
(
VMFunction
:
:
RootType
rootType
)
;
inline
CodeOffset
PushWithPatch
(
ImmWord
word
)
;
inline
CodeOffset
PushWithPatch
(
ImmPtr
imm
)
;
void
Pop
(
const
Operand
op
)
DEFINED_ON
(
x86_shared
)
;
void
Pop
(
Register
reg
)
PER_SHARED_ARCH
;
void
Pop
(
FloatRegister
t
)
DEFINED_ON
(
x86_shared
)
;
void
Pop
(
const
ValueOperand
&
val
)
PER_SHARED_ARCH
;
void
popRooted
(
VMFunction
:
:
RootType
rootType
Register
cellReg
const
ValueOperand
&
valueReg
)
;
void
adjustStack
(
int
amount
)
;
void
reserveStack
(
uint32_t
amount
)
PER_ARCH
;
void
freeStack
(
uint32_t
amount
)
;
void
freeStack
(
Register
amount
)
;
private
:
#
ifdef
DEBUG
friend
AutoRegisterScope
;
friend
AutoFloatRegisterScope
;
AllocatableRegisterSet
debugTrackedRegisters_
;
#
endif
public
:
CodeOffset
call
(
Register
reg
)
PER_SHARED_ARCH
;
CodeOffset
call
(
Label
*
label
)
PER_SHARED_ARCH
;
void
call
(
const
Address
&
addr
)
DEFINED_ON
(
x86_shared
)
;
void
call
(
ImmWord
imm
)
PER_SHARED_ARCH
;
void
call
(
ImmPtr
imm
)
PER_SHARED_ARCH
;
void
call
(
wasm
:
:
SymbolicAddress
imm
)
PER_SHARED_ARCH
;
void
call
(
JitCode
*
c
)
PER_SHARED_ARCH
;
inline
void
call
(
const
wasm
:
:
CallSiteDesc
&
desc
const
Register
reg
)
;
inline
void
call
(
const
wasm
:
:
CallSiteDesc
&
desc
AsmJSInternalCallee
callee
)
;
CodeOffset
callWithPatch
(
)
PER_SHARED_ARCH
;
void
patchCall
(
uint32_t
callerOffset
uint32_t
calleeOffset
)
PER_SHARED_ARCH
;
CodeOffset
thunkWithPatch
(
)
PER_SHARED_ARCH
;
void
patchThunk
(
uint32_t
thunkOffset
uint32_t
targetOffset
)
PER_SHARED_ARCH
;
static
void
repatchThunk
(
uint8_t
*
code
uint32_t
thunkOffset
uint32_t
targetOffset
)
PER_SHARED_ARCH
;
void
callAndPushReturnAddress
(
Register
reg
)
DEFINED_ON
(
mips_shared
x86_shared
)
;
void
callAndPushReturnAddress
(
Label
*
label
)
DEFINED_ON
(
mips_shared
x86_shared
)
;
void
pushReturnAddress
(
)
DEFINED_ON
(
arm
arm64
)
;
public
:
void
setupAlignedABICall
(
)
;
void
setupUnalignedABICall
(
Register
scratch
)
PER_ARCH
;
void
passABIArg
(
const
MoveOperand
&
from
MoveOp
:
:
Type
type
)
;
inline
void
passABIArg
(
Register
reg
)
;
inline
void
passABIArg
(
FloatRegister
reg
MoveOp
:
:
Type
type
)
;
template
<
typename
T
>
inline
void
callWithABI
(
const
T
&
fun
MoveOp
:
:
Type
result
=
MoveOp
:
:
GENERAL
)
;
private
:
void
setupABICall
(
)
;
void
callWithABIPre
(
uint32_t
*
stackAdjust
bool
callFromAsmJS
=
false
)
PER_ARCH
;
void
callWithABINoProfiler
(
void
*
fun
MoveOp
:
:
Type
result
)
;
void
callWithABINoProfiler
(
wasm
:
:
SymbolicAddress
imm
MoveOp
:
:
Type
result
)
;
void
callWithABINoProfiler
(
Register
fun
MoveOp
:
:
Type
result
)
PER_ARCH
;
void
callWithABINoProfiler
(
const
Address
&
fun
MoveOp
:
:
Type
result
)
PER_ARCH
;
void
callWithABIPost
(
uint32_t
stackAdjust
MoveOp
:
:
Type
result
)
PER_ARCH
;
inline
void
appendSignatureType
(
MoveOp
:
:
Type
type
)
;
inline
ABIFunctionType
signature
(
)
const
;
MoveResolver
moveResolver_
;
ABIArgGenerator
abiArgs_
;
#
ifdef
DEBUG
bool
inCall_
;
#
endif
bool
dynamicAlignment_
;
#
ifdef
JS_SIMULATOR
uint32_t
signature_
;
#
endif
public
:
inline
uint32_t
callJitNoProfiler
(
Register
callee
)
;
inline
uint32_t
callJit
(
Register
callee
)
;
inline
uint32_t
callJit
(
JitCode
*
code
)
;
inline
void
makeFrameDescriptor
(
Register
frameSizeReg
FrameType
type
uint32_t
headerSize
)
;
inline
void
pushStaticFrameDescriptor
(
FrameType
type
uint32_t
headerSize
)
;
inline
void
PushCalleeToken
(
Register
callee
bool
constructing
)
;
inline
void
loadFunctionFromCalleeToken
(
Address
token
Register
dest
)
;
inline
uint32_t
buildFakeExitFrame
(
Register
scratch
)
;
private
:
uint32_t
pushFakeReturnAddress
(
Register
scratch
)
PER_SHARED_ARCH
;
public
:
inline
void
PushStubCode
(
)
;
inline
bool
hasSelfReference
(
)
const
;
inline
void
enterExitFrame
(
const
VMFunction
*
f
=
nullptr
)
;
inline
void
enterFakeExitFrame
(
enum
ExitFrameTokenValues
token
)
;
inline
void
enterFakeExitFrameForNative
(
bool
isConstructing
)
;
inline
void
leaveExitFrame
(
size_t
extraFrame
=
0
)
;
private
:
void
linkExitFrame
(
)
;
void
linkSelfReference
(
JitCode
*
code
)
;
CodeOffset
selfReferencePatch_
;
public
:
inline
void
not32
(
Register
reg
)
PER_SHARED_ARCH
;
inline
void
and32
(
Register
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
and32
(
Imm32
imm
Register
dest
)
PER_SHARED_ARCH
;
inline
void
and32
(
Imm32
imm
Register
src
Register
dest
)
DEFINED_ON
(
arm64
)
;
inline
void
and32
(
Imm32
imm
const
Address
&
dest
)
PER_SHARED_ARCH
;
inline
void
and32
(
const
Address
&
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
andPtr
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
andPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
and64
(
Imm64
imm
Register64
dest
)
PER_ARCH
;
inline
void
or32
(
Register
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
or32
(
Imm32
imm
Register
dest
)
PER_SHARED_ARCH
;
inline
void
or32
(
Imm32
imm
const
Address
&
dest
)
PER_SHARED_ARCH
;
inline
void
orPtr
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
orPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
or64
(
Register64
src
Register64
dest
)
PER_ARCH
;
inline
void
xor64
(
Register64
src
Register64
dest
)
PER_ARCH
;
inline
void
xor32
(
Register
src
Register
dest
)
DEFINED_ON
(
x86_shared
)
;
inline
void
xor32
(
Imm32
imm
Register
dest
)
PER_SHARED_ARCH
;
inline
void
xorPtr
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
xorPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
add32
(
Register
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
add32
(
Imm32
imm
Register
dest
)
PER_SHARED_ARCH
;
inline
void
add32
(
Imm32
imm
const
Address
&
dest
)
PER_SHARED_ARCH
;
inline
void
add32
(
Imm32
imm
const
AbsoluteAddress
&
dest
)
DEFINED_ON
(
x86_shared
)
;
inline
void
addPtr
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
addPtr
(
Register
src1
Register
src2
Register
dest
)
DEFINED_ON
(
arm64
)
;
inline
void
addPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
addPtr
(
Imm32
imm
Register
src
Register
dest
)
DEFINED_ON
(
arm64
)
;
inline
void
addPtr
(
ImmWord
imm
Register
dest
)
PER_ARCH
;
inline
void
addPtr
(
ImmPtr
imm
Register
dest
)
;
inline
void
addPtr
(
Imm32
imm
const
Address
&
dest
)
DEFINED_ON
(
mips_shared
arm
arm64
x86
x64
)
;
inline
void
addPtr
(
Imm32
imm
const
AbsoluteAddress
&
dest
)
DEFINED_ON
(
x86
x64
)
;
inline
void
addPtr
(
const
Address
&
src
Register
dest
)
DEFINED_ON
(
mips_shared
arm
arm64
x86
x64
)
;
inline
void
add64
(
Register64
src
Register64
dest
)
PER_ARCH
;
inline
void
add64
(
Imm32
imm
Register64
dest
)
PER_ARCH
;
inline
void
addFloat32
(
FloatRegister
src
FloatRegister
dest
)
DEFINED_ON
(
x86_shared
)
;
inline
void
addDouble
(
FloatRegister
src
FloatRegister
dest
)
PER_SHARED_ARCH
;
inline
void
addConstantDouble
(
double
d
FloatRegister
dest
)
DEFINED_ON
(
x86
)
;
inline
void
sub32
(
const
Address
&
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
sub32
(
Register
src
Register
dest
)
PER_SHARED_ARCH
;
inline
void
sub32
(
Imm32
imm
Register
dest
)
PER_SHARED_ARCH
;
inline
void
subPtr
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
subPtr
(
Register
src
const
Address
&
dest
)
DEFINED_ON
(
mips_shared
arm
arm64
x86
x64
)
;
inline
void
subPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
subPtr
(
const
Address
&
addr
Register
dest
)
DEFINED_ON
(
mips_shared
arm
arm64
x86
x64
)
;
inline
void
subDouble
(
FloatRegister
src
FloatRegister
dest
)
PER_SHARED_ARCH
;
inline
void
mul32
(
Register
src1
Register
src2
Register
dest
Label
*
onOver
Label
*
onZero
)
DEFINED_ON
(
arm64
)
;
inline
void
mul64
(
Imm64
imm
const
Register64
&
dest
)
PER_ARCH
;
inline
void
mulBy3
(
Register
src
Register
dest
)
PER_ARCH
;
inline
void
mulDouble
(
FloatRegister
src
FloatRegister
dest
)
PER_SHARED_ARCH
;
inline
void
mulDoublePtr
(
ImmPtr
imm
Register
temp
FloatRegister
dest
)
DEFINED_ON
(
mips_shared
arm
arm64
x86
x64
)
;
inline
void
divDouble
(
FloatRegister
src
FloatRegister
dest
)
PER_SHARED_ARCH
;
inline
void
inc64
(
AbsoluteAddress
dest
)
PER_ARCH
;
inline
void
neg32
(
Register
reg
)
PER_SHARED_ARCH
;
inline
void
negateFloat
(
FloatRegister
reg
)
DEFINED_ON
(
arm64
x86_shared
)
;
inline
void
negateDouble
(
FloatRegister
reg
)
PER_SHARED_ARCH
;
inline
void
lshiftPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
lshift64
(
Imm32
imm
Register64
dest
)
PER_ARCH
;
inline
void
rshiftPtr
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
rshiftPtr
(
Imm32
imm
Register
src
Register
dest
)
DEFINED_ON
(
arm64
)
;
inline
void
rshiftPtrArithmetic
(
Imm32
imm
Register
dest
)
PER_ARCH
;
inline
void
rshift64
(
Imm32
imm
Register64
dest
)
PER_ARCH
;
inline
void
branchPtr
(
Condition
cond
Register
lhs
Register
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
Register
lhs
Imm32
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
Register
lhs
ImmPtr
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
Register
lhs
ImmGCPtr
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
Register
lhs
ImmWord
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
const
Address
&
lhs
Register
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
const
Address
&
lhs
ImmPtr
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
const
Address
&
lhs
ImmGCPtr
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
const
Address
&
lhs
ImmWord
rhs
Label
*
label
)
PER_SHARED_ARCH
;
inline
void
branchPtr
(
Condition
cond
const
AbsoluteAddress
&
lhs
Register
rhs
Label
*
label
)
DEFINED_ON
(
arm
arm64
mips_shared
x86
x64
)
;
inline
void
branchPtr
(
Condition
cond
const
AbsoluteAddress
&
lhs
ImmWord
rhs
Label
*
label
)
DEFINED_ON
(
arm
arm64
mips_shared
x86
x64
)
;
inline
void
branchPtr
(
Condition
cond
wasm
:
:
SymbolicAddress
lhs
Register
rhs
Label
*
label
)
DEFINED_ON
(
arm
arm64
mips_shared
x86
x64
)
;
inline
void
branchPrivatePtr
(
Condition
cond
const
Address
&
lhs
Register
rhs
Label
*
label
)
PER_ARCH
;
public
:
template
<
typename
Source
>
void
guardTypeSet
(
const
Source
&
address
const
TypeSet
*
types
BarrierKind
kind
Register
scratch
Label
*
miss
)
;
void
guardObjectType
(
Register
obj
const
TypeSet
*
types
Register
scratch
Label
*
miss
)
;
template
<
typename
TypeSet
>
void
guardTypeSetMightBeIncomplete
(
TypeSet
*
types
Register
obj
Register
scratch
Label
*
label
)
;
void
loadObjShape
(
Register
objReg
Register
dest
)
{
loadPtr
(
Address
(
objReg
JSObject
:
:
offsetOfShape
(
)
)
dest
)
;
}
void
loadObjGroup
(
Register
objReg
Register
dest
)
{
loadPtr
(
Address
(
objReg
JSObject
:
:
offsetOfGroup
(
)
)
dest
)
;
}
void
loadBaseShape
(
Register
objReg
Register
dest
)
{
loadObjShape
(
objReg
dest
)
;
loadPtr
(
Address
(
dest
Shape
:
:
offsetOfBase
(
)
)
dest
)
;
}
void
loadObjClass
(
Register
objReg
Register
dest
)
{
loadObjGroup
(
objReg
dest
)
;
loadPtr
(
Address
(
dest
ObjectGroup
:
:
offsetOfClasp
(
)
)
dest
)
;
}
inline
void
branchTestObjClass
(
Condition
cond
Register
obj
Register
scratch
const
js
:
:
Class
*
clasp
Label
*
label
)
;
inline
void
branchTestObjShape
(
Condition
cond
Register
obj
const
Shape
*
shape
Label
*
label
)
;
inline
void
branchTestObjShape
(
Condition
cond
Register
obj
Register
shape
Label
*
label
)
;
inline
void
branchTestObjGroup
(
Condition
cond
Register
obj
ObjectGroup
*
group
Label
*
label
)
;
inline
void
branchTestObjGroup
(
Condition
cond
Register
obj
Register
group
Label
*
label
)
;
inline
void
branchTestProxyHandlerFamily
(
Condition
cond
Register
proxy
Register
scratch
const
void
*
handlerp
Label
*
label
)
;
template
<
typename
Value
>
void
branchTestMIRType
(
Condition
cond
const
Value
&
val
MIRType
type
Label
*
label
)
{
switch
(
type
)
{
case
MIRType_Null
:
return
branchTestNull
(
cond
val
label
)
;
case
MIRType_Undefined
:
return
branchTestUndefined
(
cond
val
label
)
;
case
MIRType_Boolean
:
return
branchTestBoolean
(
cond
val
label
)
;
case
MIRType_Int32
:
return
branchTestInt32
(
cond
val
label
)
;
case
MIRType_String
:
return
branchTestString
(
cond
val
label
)
;
case
MIRType_Symbol
:
return
branchTestSymbol
(
cond
val
label
)
;
case
MIRType_Object
:
return
branchTestObject
(
cond
val
label
)
;
case
MIRType_Double
:
return
branchTestDouble
(
cond
val
label
)
;
case
MIRType_MagicOptimizedArguments
:
case
MIRType_MagicIsConstructing
:
case
MIRType_MagicHole
:
return
branchTestMagic
(
cond
val
label
)
;
default
:
MOZ_CRASH
(
"
Bad
MIRType
"
)
;
}
}
template
<
class
L
>
void
branchIfFalseBool
(
Register
reg
L
label
)
{
branchTest32
(
Assembler
:
:
Zero
reg
Imm32
(
0xFF
)
label
)
;
}
void
branchIfTrueBool
(
Register
reg
Label
*
label
)
{
branchTest32
(
Assembler
:
:
NonZero
reg
Imm32
(
0xFF
)
label
)
;
}
void
loadObjPrivate
(
Register
obj
uint32_t
nfixed
Register
dest
)
{
loadPtr
(
Address
(
obj
NativeObject
:
:
getPrivateDataOffset
(
nfixed
)
)
dest
)
;
}
void
loadObjProto
(
Register
obj
Register
dest
)
{
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
dest
)
;
loadPtr
(
Address
(
dest
ObjectGroup
:
:
offsetOfProto
(
)
)
dest
)
;
}
void
loadStringLength
(
Register
str
Register
dest
)
{
load32
(
Address
(
str
JSString
:
:
offsetOfLength
(
)
)
dest
)
;
}
void
loadStringChars
(
Register
str
Register
dest
)
;
void
loadStringChar
(
Register
str
Register
index
Register
output
)
;
void
branchIfRope
(
Register
str
Label
*
label
)
{
Address
flags
(
str
JSString
:
:
offsetOfFlags
(
)
)
;
static_assert
(
JSString
:
:
ROPE_FLAGS
=
=
0
"
Rope
type
flags
must
be
0
"
)
;
branchTest32
(
Assembler
:
:
Zero
flags
Imm32
(
JSString
:
:
TYPE_FLAGS_MASK
)
label
)
;
}
void
branchLatin1String
(
Register
string
Label
*
label
)
{
branchTest32
(
Assembler
:
:
NonZero
Address
(
string
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
LATIN1_CHARS_BIT
)
label
)
;
}
void
branchTwoByteString
(
Register
string
Label
*
label
)
{
branchTest32
(
Assembler
:
:
Zero
Address
(
string
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
LATIN1_CHARS_BIT
)
label
)
;
}
void
loadJSContext
(
Register
dest
)
{
loadPtr
(
AbsoluteAddress
(
GetJitContext
(
)
-
>
runtime
-
>
addressOfJSContext
(
)
)
dest
)
;
}
void
loadJitActivation
(
Register
dest
)
{
loadPtr
(
AbsoluteAddress
(
GetJitContext
(
)
-
>
runtime
-
>
addressOfActivation
(
)
)
dest
)
;
}
template
<
typename
T
>
void
loadTypedOrValue
(
const
T
&
src
TypedOrValueRegister
dest
)
{
if
(
dest
.
hasValue
(
)
)
loadValue
(
src
dest
.
valueReg
(
)
)
;
else
loadUnboxedValue
(
src
dest
.
type
(
)
dest
.
typedReg
(
)
)
;
}
template
<
typename
T
>
void
loadElementTypedOrValue
(
const
T
&
src
TypedOrValueRegister
dest
bool
holeCheck
Label
*
hole
)
{
if
(
dest
.
hasValue
(
)
)
{
loadValue
(
src
dest
.
valueReg
(
)
)
;
if
(
holeCheck
)
branchTestMagic
(
Assembler
:
:
Equal
dest
.
valueReg
(
)
hole
)
;
}
else
{
if
(
holeCheck
)
branchTestMagic
(
Assembler
:
:
Equal
src
hole
)
;
loadUnboxedValue
(
src
dest
.
type
(
)
dest
.
typedReg
(
)
)
;
}
}
template
<
typename
T
>
void
storeTypedOrValue
(
TypedOrValueRegister
src
const
T
&
dest
)
{
if
(
src
.
hasValue
(
)
)
{
storeValue
(
src
.
valueReg
(
)
dest
)
;
}
else
if
(
IsFloatingPointType
(
src
.
type
(
)
)
)
{
FloatRegister
reg
=
src
.
typedReg
(
)
.
fpu
(
)
;
if
(
src
.
type
(
)
=
=
MIRType_Float32
)
{
convertFloat32ToDouble
(
reg
ScratchDoubleReg
)
;
reg
=
ScratchDoubleReg
;
}
storeDouble
(
reg
dest
)
;
}
else
{
storeValue
(
ValueTypeFromMIRType
(
src
.
type
(
)
)
src
.
typedReg
(
)
.
gpr
(
)
dest
)
;
}
}
template
<
typename
T
>
void
storeObjectOrNull
(
Register
src
const
T
&
dest
)
{
Label
notNull
done
;
branchTestPtr
(
Assembler
:
:
NonZero
src
src
&
notNull
)
;
storeValue
(
NullValue
(
)
dest
)
;
jump
(
&
done
)
;
bind
(
&
notNull
)
;
storeValue
(
JSVAL_TYPE_OBJECT
src
dest
)
;
bind
(
&
done
)
;
}
template
<
typename
T
>
void
storeConstantOrRegister
(
ConstantOrRegister
src
const
T
&
dest
)
{
if
(
src
.
constant
(
)
)
storeValue
(
src
.
value
(
)
dest
)
;
else
storeTypedOrValue
(
src
.
reg
(
)
dest
)
;
}
void
storeCallResult
(
Register
reg
)
{
if
(
reg
!
=
ReturnReg
)
mov
(
ReturnReg
reg
)
;
}
void
storeCallFloatResult
(
FloatRegister
reg
)
{
if
(
reg
!
=
ReturnDoubleReg
)
moveDouble
(
ReturnDoubleReg
reg
)
;
}
void
storeCallResultValue
(
AnyRegister
dest
)
{
#
if
defined
(
JS_NUNBOX32
)
unboxValue
(
ValueOperand
(
JSReturnReg_Type
JSReturnReg_Data
)
dest
)
;
#
elif
defined
(
JS_PUNBOX64
)
unboxValue
(
ValueOperand
(
JSReturnReg
)
dest
)
;
#
else
#
error
"
Bad
architecture
"
#
endif
}
void
storeCallResultValue
(
ValueOperand
dest
)
{
#
if
defined
(
JS_NUNBOX32
)
if
(
dest
.
typeReg
(
)
=
=
JSReturnReg_Data
)
{
if
(
dest
.
payloadReg
(
)
=
=
JSReturnReg_Type
)
{
mov
(
JSReturnReg_Type
ReturnReg
)
;
mov
(
JSReturnReg_Data
JSReturnReg_Type
)
;
mov
(
ReturnReg
JSReturnReg_Data
)
;
}
else
{
mov
(
JSReturnReg_Data
dest
.
payloadReg
(
)
)
;
mov
(
JSReturnReg_Type
dest
.
typeReg
(
)
)
;
}
}
else
{
mov
(
JSReturnReg_Type
dest
.
typeReg
(
)
)
;
mov
(
JSReturnReg_Data
dest
.
payloadReg
(
)
)
;
}
#
elif
defined
(
JS_PUNBOX64
)
if
(
dest
.
valueReg
(
)
!
=
JSReturnReg
)
mov
(
JSReturnReg
dest
.
valueReg
(
)
)
;
#
else
#
error
"
Bad
architecture
"
#
endif
}
void
storeCallResultValue
(
TypedOrValueRegister
dest
)
{
if
(
dest
.
hasValue
(
)
)
storeCallResultValue
(
dest
.
valueReg
(
)
)
;
else
storeCallResultValue
(
dest
.
typedReg
(
)
)
;
}
template
<
typename
T
>
Register
extractString
(
const
T
&
source
Register
scratch
)
{
return
extractObject
(
source
scratch
)
;
}
void
branchIfFunctionHasNoScript
(
Register
fun
Label
*
label
)
{
MOZ_ASSERT
(
JSFunction
:
:
offsetOfNargs
(
)
%
sizeof
(
uint32_t
)
=
=
0
)
;
MOZ_ASSERT
(
JSFunction
:
:
offsetOfFlags
(
)
=
=
JSFunction
:
:
offsetOfNargs
(
)
+
2
)
;
Address
address
(
fun
JSFunction
:
:
offsetOfNargs
(
)
)
;
int32_t
bit
=
IMM32_16ADJ
(
JSFunction
:
:
INTERPRETED
)
;
branchTest32
(
Assembler
:
:
Zero
address
Imm32
(
bit
)
label
)
;
}
void
branchIfInterpreted
(
Register
fun
Label
*
label
)
{
MOZ_ASSERT
(
JSFunction
:
:
offsetOfNargs
(
)
%
sizeof
(
uint32_t
)
=
=
0
)
;
MOZ_ASSERT
(
JSFunction
:
:
offsetOfFlags
(
)
=
=
JSFunction
:
:
offsetOfNargs
(
)
+
2
)
;
Address
address
(
fun
JSFunction
:
:
offsetOfNargs
(
)
)
;
int32_t
bit
=
IMM32_16ADJ
(
JSFunction
:
:
INTERPRETED
)
;
branchTest32
(
Assembler
:
:
NonZero
address
Imm32
(
bit
)
label
)
;
}
void
branchIfNotInterpretedConstructor
(
Register
fun
Register
scratch
Label
*
label
)
;
inline
void
bumpKey
(
Int32Key
*
key
int
diff
)
;
void
storeKey
(
const
Int32Key
&
key
const
Address
&
dest
)
{
if
(
key
.
isRegister
(
)
)
store32
(
key
.
reg
(
)
dest
)
;
else
store32
(
Imm32
(
key
.
constant
(
)
)
dest
)
;
}
template
<
typename
T
>
void
branchKey
(
Condition
cond
const
T
&
length
const
Int32Key
&
key
Label
*
label
)
{
if
(
key
.
isRegister
(
)
)
branch32
(
cond
length
key
.
reg
(
)
label
)
;
else
branch32
(
cond
length
Imm32
(
key
.
constant
(
)
)
label
)
;
}
void
branchTestNeedsIncrementalBarrier
(
Condition
cond
Label
*
label
)
{
MOZ_ASSERT
(
cond
=
=
Zero
|
|
cond
=
=
NonZero
)
;
CompileZone
*
zone
=
GetJitContext
(
)
-
>
compartment
-
>
zone
(
)
;
AbsoluteAddress
needsBarrierAddr
(
zone
-
>
addressOfNeedsIncrementalBarrier
(
)
)
;
branchTest32
(
cond
needsBarrierAddr
Imm32
(
0x1
)
label
)
;
}
template
<
typename
T
>
void
callPreBarrier
(
const
T
&
address
MIRType
type
)
{
Label
done
;
if
(
type
=
=
MIRType_Value
)
branchTestGCThing
(
Assembler
:
:
NotEqual
address
&
done
)
;
Push
(
PreBarrierReg
)
;
computeEffectiveAddress
(
address
PreBarrierReg
)
;
const
JitRuntime
*
rt
=
GetJitContext
(
)
-
>
runtime
-
>
jitRuntime
(
)
;
JitCode
*
preBarrier
=
rt
-
>
preBarrier
(
type
)
;
call
(
preBarrier
)
;
Pop
(
PreBarrierReg
)
;
bind
(
&
done
)
;
}
template
<
typename
T
>
void
patchableCallPreBarrier
(
const
T
&
address
MIRType
type
)
{
Label
done
;
CodeOffset
nopJump
=
toggledJump
(
&
done
)
;
writePrebarrierOffset
(
nopJump
)
;
callPreBarrier
(
address
type
)
;
jump
(
&
done
)
;
haltingAlign
(
8
)
;
bind
(
&
done
)
;
}
void
canonicalizeDouble
(
FloatRegister
reg
)
{
Label
notNaN
;
branchDouble
(
DoubleOrdered
reg
reg
&
notNaN
)
;
loadConstantDouble
(
JS
:
:
GenericNaN
(
)
reg
)
;
bind
(
&
notNaN
)
;
}
void
canonicalizeFloat
(
FloatRegister
reg
)
{
Label
notNaN
;
branchFloat
(
DoubleOrdered
reg
reg
&
notNaN
)
;
loadConstantFloat32
(
float
(
JS
:
:
GenericNaN
(
)
)
reg
)
;
bind
(
&
notNaN
)
;
}
template
<
typename
T
>
void
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
T
&
src
AnyRegister
dest
Register
temp
Label
*
fail
bool
canonicalizeDoubles
=
true
unsigned
numElems
=
0
)
;
template
<
typename
T
>
void
loadFromTypedArray
(
Scalar
:
:
Type
arrayType
const
T
&
src
const
ValueOperand
&
dest
bool
allowDouble
Register
temp
Label
*
fail
)
;
template
<
typename
S
typename
T
>
void
storeToTypedIntArray
(
Scalar
:
:
Type
arrayType
const
S
&
value
const
T
&
dest
)
{
switch
(
arrayType
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Uint8Clamped
:
store8
(
value
dest
)
;
break
;
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
store16
(
value
dest
)
;
break
;
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
store32
(
value
dest
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
typed
array
type
"
)
;
}
}
void
storeToTypedFloatArray
(
Scalar
:
:
Type
arrayType
FloatRegister
value
const
BaseIndex
&
dest
unsigned
numElems
=
0
)
;
void
storeToTypedFloatArray
(
Scalar
:
:
Type
arrayType
FloatRegister
value
const
Address
&
dest
unsigned
numElems
=
0
)
;
template
<
typename
T
>
void
loadUnboxedProperty
(
T
address
JSValueType
type
TypedOrValueRegister
output
)
;
template
<
typename
T
>
void
storeUnboxedProperty
(
T
address
JSValueType
type
ConstantOrRegister
value
Label
*
failure
)
;
void
checkUnboxedArrayCapacity
(
Register
obj
const
Int32Key
&
index
Register
temp
Label
*
failure
)
;
Register
extractString
(
const
Address
&
address
Register
scratch
)
{
return
extractObject
(
address
scratch
)
;
}
Register
extractString
(
const
ValueOperand
&
value
Register
scratch
)
{
return
extractObject
(
value
scratch
)
;
}
using
MacroAssemblerSpecific
:
:
extractTag
;
Register
extractTag
(
const
TypedOrValueRegister
&
reg
Register
scratch
)
{
if
(
reg
.
hasValue
(
)
)
return
extractTag
(
reg
.
valueReg
(
)
scratch
)
;
mov
(
ImmWord
(
MIRTypeToTag
(
reg
.
type
(
)
)
)
scratch
)
;
return
scratch
;
}
using
MacroAssemblerSpecific
:
:
extractObject
;
Register
extractObject
(
const
TypedOrValueRegister
&
reg
Register
scratch
)
{
if
(
reg
.
hasValue
(
)
)
return
extractObject
(
reg
.
valueReg
(
)
scratch
)
;
MOZ_ASSERT
(
reg
.
type
(
)
=
=
MIRType_Object
)
;
return
reg
.
typedReg
(
)
.
gpr
(
)
;
}
void
clampDoubleToUint8
(
FloatRegister
input
Register
output
)
PER_ARCH
;
using
MacroAssemblerSpecific
:
:
ensureDouble
;
template
<
typename
S
>
void
ensureDouble
(
const
S
&
source
FloatRegister
dest
Label
*
failure
)
{
Label
isDouble
done
;
branchTestDouble
(
Assembler
:
:
Equal
source
&
isDouble
)
;
branchTestInt32
(
Assembler
:
:
NotEqual
source
failure
)
;
convertInt32ToDouble
(
source
dest
)
;
jump
(
&
done
)
;
bind
(
&
isDouble
)
;
unboxDouble
(
source
dest
)
;
bind
(
&
done
)
;
}
void
branchEqualTypeIfNeeded
(
MIRType
type
MDefinition
*
maybeDef
Register
tag
Label
*
label
)
;
private
:
void
checkAllocatorState
(
Label
*
fail
)
;
bool
shouldNurseryAllocate
(
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
initialHeap
)
;
void
nurseryAllocate
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
size_t
nDynamicSlots
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
;
void
freeListAllocate
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
Label
*
fail
)
;
void
allocateObject
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
uint32_t
nDynamicSlots
gc
:
:
InitialHeap
initialHeap
Label
*
fail
)
;
void
allocateNonObject
(
Register
result
Register
temp
gc
:
:
AllocKind
allocKind
Label
*
fail
)
;
void
copySlotsFromTemplate
(
Register
obj
const
NativeObject
*
templateObj
uint32_t
start
uint32_t
end
)
;
void
fillSlotsWithConstantValue
(
Address
addr
Register
temp
uint32_t
start
uint32_t
end
const
Value
&
v
)
;
void
fillSlotsWithUndefined
(
Address
addr
Register
temp
uint32_t
start
uint32_t
end
)
;
void
fillSlotsWithUninitialized
(
Address
addr
Register
temp
uint32_t
start
uint32_t
end
)
;
void
initGCSlots
(
Register
obj
Register
temp
NativeObject
*
templateObj
bool
initContents
)
;
public
:
void
callMallocStub
(
size_t
nbytes
Register
result
Label
*
fail
)
;
void
callFreeStub
(
Register
slots
)
;
void
createGCObject
(
Register
result
Register
temp
JSObject
*
templateObj
gc
:
:
InitialHeap
initialHeap
Label
*
fail
bool
initContents
=
true
bool
convertDoubleElements
=
false
)
;
void
initGCThing
(
Register
obj
Register
temp
JSObject
*
templateObj
bool
initContents
=
true
bool
convertDoubleElements
=
false
)
;
void
initUnboxedObjectContents
(
Register
object
UnboxedPlainObject
*
templateObject
)
;
void
newGCString
(
Register
result
Register
temp
Label
*
fail
)
;
void
newGCFatInlineString
(
Register
result
Register
temp
Label
*
fail
)
;
void
compareStrings
(
JSOp
op
Register
left
Register
right
Register
result
Label
*
fail
)
;
public
:
void
generateBailoutTail
(
Register
scratch
Register
bailoutInfo
)
;
void
branchTestObjectTruthy
(
bool
truthy
Register
objReg
Register
scratch
Label
*
slowCheck
Label
*
checked
)
{
loadObjClass
(
objReg
scratch
)
;
Address
flags
(
scratch
Class
:
:
offsetOfFlags
(
)
)
;
branchTestClassIsProxy
(
true
scratch
slowCheck
)
;
Condition
cond
=
truthy
?
Assembler
:
:
Zero
:
Assembler
:
:
NonZero
;
branchTest32
(
cond
flags
Imm32
(
JSCLASS_EMULATES_UNDEFINED
)
checked
)
;
}
void
branchTestClassIsProxy
(
bool
proxy
Register
clasp
Label
*
label
)
{
branchTest32
(
proxy
?
Assembler
:
:
NonZero
:
Assembler
:
:
Zero
Address
(
clasp
Class
:
:
offsetOfFlags
(
)
)
Imm32
(
JSCLASS_IS_PROXY
)
label
)
;
}
void
branchTestObjectIsProxy
(
bool
proxy
Register
object
Register
scratch
Label
*
label
)
{
loadObjClass
(
object
scratch
)
;
branchTestClassIsProxy
(
proxy
scratch
label
)
;
}
inline
void
branchFunctionKind
(
Condition
cond
JSFunction
:
:
FunctionKind
kind
Register
fun
Register
scratch
Label
*
label
)
;
public
:
#
ifndef
JS_CODEGEN_ARM64
template
<
typename
T
>
inline
void
addToStackPtr
(
T
t
)
;
template
<
typename
T
>
inline
void
addStackPtrTo
(
T
t
)
;
template
<
typename
T
>
void
subFromStackPtr
(
T
t
)
{
subPtr
(
t
getStackPointer
(
)
)
;
}
template
<
typename
T
>
void
subStackPtrFrom
(
T
t
)
{
subPtr
(
getStackPointer
(
)
t
)
;
}
template
<
typename
T
>
void
andToStackPtr
(
T
t
)
{
andPtr
(
t
getStackPointer
(
)
)
;
}
template
<
typename
T
>
void
andStackPtrTo
(
T
t
)
{
andPtr
(
getStackPointer
(
)
t
)
;
}
template
<
typename
T
>
void
moveToStackPtr
(
T
t
)
{
movePtr
(
t
getStackPointer
(
)
)
;
}
template
<
typename
T
>
void
moveStackPtrTo
(
T
t
)
{
movePtr
(
getStackPointer
(
)
t
)
;
}
template
<
typename
T
>
void
loadStackPtr
(
T
t
)
{
loadPtr
(
t
getStackPointer
(
)
)
;
}
template
<
typename
T
>
void
storeStackPtr
(
T
t
)
{
storePtr
(
getStackPointer
(
)
t
)
;
}
template
<
typename
T
>
void
branchTestStackPtr
(
Condition
cond
T
t
Label
*
label
)
{
branchTestPtr
(
cond
getStackPointer
(
)
t
label
)
;
}
template
<
typename
T
>
inline
void
branchStackPtr
(
Condition
cond
T
rhs
Label
*
label
)
;
template
<
typename
T
>
inline
void
branchStackPtrRhs
(
Condition
cond
T
lhs
Label
*
label
)
;
#
endif
public
:
void
enableProfilingInstrumentation
(
)
{
emitProfilingInstrumentation_
=
true
;
}
private
:
class
AutoProfilerCallInstrumentation
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
public
:
explicit
AutoProfilerCallInstrumentation
(
MacroAssembler
&
masm
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoProfilerCallInstrumentation
(
)
{
}
}
;
friend
class
AutoProfilerCallInstrumentation
;
void
appendProfilerCallSite
(
CodeOffset
label
)
{
propagateOOM
(
profilerCallSites_
.
append
(
label
)
)
;
}
void
linkProfilerCallSites
(
JitCode
*
code
)
;
bool
emitProfilingInstrumentation_
;
Vector
<
CodeOffset
0
SystemAllocPolicy
>
profilerCallSites_
;
public
:
void
loadBaselineOrIonRaw
(
Register
script
Register
dest
Label
*
failure
)
;
void
loadBaselineOrIonNoArgCheck
(
Register
callee
Register
dest
Label
*
failure
)
;
void
loadBaselineFramePtr
(
Register
framePtr
Register
dest
)
;
void
pushBaselineFramePtr
(
Register
framePtr
Register
scratch
)
{
loadBaselineFramePtr
(
framePtr
scratch
)
;
push
(
scratch
)
;
}
void
PushBaselineFramePtr
(
Register
framePtr
Register
scratch
)
{
loadBaselineFramePtr
(
framePtr
scratch
)
;
Push
(
scratch
)
;
}
private
:
void
handleFailure
(
)
;
public
:
Label
*
exceptionLabel
(
)
{
return
&
failureLabel_
;
}
Label
*
failureLabel
(
)
{
return
&
failureLabel_
;
}
void
finish
(
)
;
void
link
(
JitCode
*
code
)
;
void
assumeUnreachable
(
const
char
*
output
)
;
template
<
typename
T
>
void
assertTestInt32
(
Condition
cond
const
T
&
value
const
char
*
output
)
;
void
printf
(
const
char
*
output
)
;
void
printf
(
const
char
*
output
Register
value
)
;
#
ifdef
JS_TRACE_LOGGING
void
tracelogStartId
(
Register
logger
uint32_t
textId
bool
force
=
false
)
;
void
tracelogStartId
(
Register
logger
Register
textId
)
;
void
tracelogStartEvent
(
Register
logger
Register
event
)
;
void
tracelogStopId
(
Register
logger
uint32_t
textId
bool
force
=
false
)
;
void
tracelogStopId
(
Register
logger
Register
textId
)
;
#
endif
#
define
DISPATCH_FLOATING_POINT_OP
(
method
type
arg1d
arg1f
arg2
)
\
MOZ_ASSERT
(
IsFloatingPointType
(
type
)
)
;
\
if
(
type
=
=
MIRType_Double
)
\
method
#
#
Double
(
arg1d
arg2
)
;
\
else
\
method
#
#
Float32
(
arg1f
arg2
)
;
\
void
loadConstantFloatingPoint
(
double
d
float
f
FloatRegister
dest
MIRType
destType
)
{
DISPATCH_FLOATING_POINT_OP
(
loadConstant
destType
d
f
dest
)
;
}
void
boolValueToFloatingPoint
(
ValueOperand
value
FloatRegister
dest
MIRType
destType
)
{
DISPATCH_FLOATING_POINT_OP
(
boolValueTo
destType
value
value
dest
)
;
}
void
int32ValueToFloatingPoint
(
ValueOperand
value
FloatRegister
dest
MIRType
destType
)
{
DISPATCH_FLOATING_POINT_OP
(
int32ValueTo
destType
value
value
dest
)
;
}
void
convertInt32ToFloatingPoint
(
Register
src
FloatRegister
dest
MIRType
destType
)
{
DISPATCH_FLOATING_POINT_OP
(
convertInt32To
destType
src
src
dest
)
;
}
#
undef
DISPATCH_FLOATING_POINT_OP
void
convertValueToFloatingPoint
(
ValueOperand
value
FloatRegister
output
Label
*
fail
MIRType
outputType
)
;
bool
convertValueToFloatingPoint
(
JSContext
*
cx
const
Value
&
v
FloatRegister
output
Label
*
fail
MIRType
outputType
)
;
bool
convertConstantOrRegisterToFloatingPoint
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
output
Label
*
fail
MIRType
outputType
)
;
void
convertTypedOrValueToFloatingPoint
(
TypedOrValueRegister
src
FloatRegister
output
Label
*
fail
MIRType
outputType
)
;
void
convertInt32ValueToDouble
(
const
Address
&
address
Register
scratch
Label
*
done
)
;
void
convertValueToDouble
(
ValueOperand
value
FloatRegister
output
Label
*
fail
)
{
convertValueToFloatingPoint
(
value
output
fail
MIRType_Double
)
;
}
bool
convertValueToDouble
(
JSContext
*
cx
const
Value
&
v
FloatRegister
output
Label
*
fail
)
{
return
convertValueToFloatingPoint
(
cx
v
output
fail
MIRType_Double
)
;
}
bool
convertConstantOrRegisterToDouble
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
output
Label
*
fail
)
{
return
convertConstantOrRegisterToFloatingPoint
(
cx
src
output
fail
MIRType_Double
)
;
}
void
convertTypedOrValueToDouble
(
TypedOrValueRegister
src
FloatRegister
output
Label
*
fail
)
{
convertTypedOrValueToFloatingPoint
(
src
output
fail
MIRType_Double
)
;
}
void
convertValueToFloat
(
ValueOperand
value
FloatRegister
output
Label
*
fail
)
{
convertValueToFloatingPoint
(
value
output
fail
MIRType_Float32
)
;
}
bool
convertValueToFloat
(
JSContext
*
cx
const
Value
&
v
FloatRegister
output
Label
*
fail
)
{
return
convertValueToFloatingPoint
(
cx
v
output
fail
MIRType_Float32
)
;
}
bool
convertConstantOrRegisterToFloat
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
output
Label
*
fail
)
{
return
convertConstantOrRegisterToFloatingPoint
(
cx
src
output
fail
MIRType_Float32
)
;
}
void
convertTypedOrValueToFloat
(
TypedOrValueRegister
src
FloatRegister
output
Label
*
fail
)
{
convertTypedOrValueToFloatingPoint
(
src
output
fail
MIRType_Float32
)
;
}
enum
IntConversionBehavior
{
IntConversion_Normal
IntConversion_NegativeZeroCheck
IntConversion_Truncate
IntConversion_ClampToUint8
}
;
enum
IntConversionInputKind
{
IntConversion_NumbersOnly
IntConversion_NumbersOrBoolsOnly
IntConversion_Any
}
;
void
convertDoubleToInt
(
FloatRegister
src
Register
output
FloatRegister
temp
Label
*
truncateFail
Label
*
fail
IntConversionBehavior
behavior
)
;
void
convertValueToInt
(
ValueOperand
value
MDefinition
*
input
Label
*
handleStringEntry
Label
*
handleStringRejoin
Label
*
truncateDoubleSlow
Register
stringReg
FloatRegister
temp
Register
output
Label
*
fail
IntConversionBehavior
behavior
IntConversionInputKind
conversion
=
IntConversion_Any
)
;
void
convertValueToInt
(
ValueOperand
value
FloatRegister
temp
Register
output
Label
*
fail
IntConversionBehavior
behavior
)
{
convertValueToInt
(
value
nullptr
nullptr
nullptr
nullptr
InvalidReg
temp
output
fail
behavior
)
;
}
bool
convertValueToInt
(
JSContext
*
cx
const
Value
&
v
Register
output
Label
*
fail
IntConversionBehavior
behavior
)
;
bool
convertConstantOrRegisterToInt
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
temp
Register
output
Label
*
fail
IntConversionBehavior
behavior
)
;
void
convertTypedOrValueToInt
(
TypedOrValueRegister
src
FloatRegister
temp
Register
output
Label
*
fail
IntConversionBehavior
behavior
)
;
void
convertValueToInt32
(
ValueOperand
value
FloatRegister
temp
Register
output
Label
*
fail
bool
negativeZeroCheck
)
{
convertValueToInt
(
value
temp
output
fail
negativeZeroCheck
?
IntConversion_NegativeZeroCheck
:
IntConversion_Normal
)
;
}
void
convertValueToInt32
(
ValueOperand
value
MDefinition
*
input
FloatRegister
temp
Register
output
Label
*
fail
bool
negativeZeroCheck
IntConversionInputKind
conversion
=
IntConversion_Any
)
{
convertValueToInt
(
value
input
nullptr
nullptr
nullptr
InvalidReg
temp
output
fail
negativeZeroCheck
?
IntConversion_NegativeZeroCheck
:
IntConversion_Normal
conversion
)
;
}
bool
convertValueToInt32
(
JSContext
*
cx
const
Value
&
v
Register
output
Label
*
fail
bool
negativeZeroCheck
)
{
return
convertValueToInt
(
cx
v
output
fail
negativeZeroCheck
?
IntConversion_NegativeZeroCheck
:
IntConversion_Normal
)
;
}
bool
convertConstantOrRegisterToInt32
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
temp
Register
output
Label
*
fail
bool
negativeZeroCheck
)
{
return
convertConstantOrRegisterToInt
(
cx
src
temp
output
fail
negativeZeroCheck
?
IntConversion_NegativeZeroCheck
:
IntConversion_Normal
)
;
}
void
convertTypedOrValueToInt32
(
TypedOrValueRegister
src
FloatRegister
temp
Register
output
Label
*
fail
bool
negativeZeroCheck
)
{
convertTypedOrValueToInt
(
src
temp
output
fail
negativeZeroCheck
?
IntConversion_NegativeZeroCheck
:
IntConversion_Normal
)
;
}
void
truncateValueToInt32
(
ValueOperand
value
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
temp
output
fail
IntConversion_Truncate
)
;
}
void
truncateValueToInt32
(
ValueOperand
value
MDefinition
*
input
Label
*
handleStringEntry
Label
*
handleStringRejoin
Label
*
truncateDoubleSlow
Register
stringReg
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
input
handleStringEntry
handleStringRejoin
truncateDoubleSlow
stringReg
temp
output
fail
IntConversion_Truncate
)
;
}
void
truncateValueToInt32
(
ValueOperand
value
MDefinition
*
input
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
input
nullptr
nullptr
nullptr
InvalidReg
temp
output
fail
IntConversion_Truncate
)
;
}
bool
truncateValueToInt32
(
JSContext
*
cx
const
Value
&
v
Register
output
Label
*
fail
)
{
return
convertValueToInt
(
cx
v
output
fail
IntConversion_Truncate
)
;
}
bool
truncateConstantOrRegisterToInt32
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
temp
Register
output
Label
*
fail
)
{
return
convertConstantOrRegisterToInt
(
cx
src
temp
output
fail
IntConversion_Truncate
)
;
}
void
truncateTypedOrValueToInt32
(
TypedOrValueRegister
src
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertTypedOrValueToInt
(
src
temp
output
fail
IntConversion_Truncate
)
;
}
void
clampValueToUint8
(
ValueOperand
value
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
temp
output
fail
IntConversion_ClampToUint8
)
;
}
void
clampValueToUint8
(
ValueOperand
value
MDefinition
*
input
Label
*
handleStringEntry
Label
*
handleStringRejoin
Register
stringReg
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
input
handleStringEntry
handleStringRejoin
nullptr
stringReg
temp
output
fail
IntConversion_ClampToUint8
)
;
}
void
clampValueToUint8
(
ValueOperand
value
MDefinition
*
input
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertValueToInt
(
value
input
nullptr
nullptr
nullptr
InvalidReg
temp
output
fail
IntConversion_ClampToUint8
)
;
}
bool
clampValueToUint8
(
JSContext
*
cx
const
Value
&
v
Register
output
Label
*
fail
)
{
return
convertValueToInt
(
cx
v
output
fail
IntConversion_ClampToUint8
)
;
}
bool
clampConstantOrRegisterToUint8
(
JSContext
*
cx
ConstantOrRegister
src
FloatRegister
temp
Register
output
Label
*
fail
)
{
return
convertConstantOrRegisterToInt
(
cx
src
temp
output
fail
IntConversion_ClampToUint8
)
;
}
void
clampTypedOrValueToUint8
(
TypedOrValueRegister
src
FloatRegister
temp
Register
output
Label
*
fail
)
{
convertTypedOrValueToInt
(
src
temp
output
fail
IntConversion_ClampToUint8
)
;
}
public
:
class
AfterICSaveLive
{
friend
class
MacroAssembler
;
explicit
AfterICSaveLive
(
uint32_t
initialStack
)
#
ifdef
JS_DEBUG
:
initialStack
(
initialStack
)
#
endif
{
}
public
:
#
ifdef
JS_DEBUG
uint32_t
initialStack
;
#
endif
uint32_t
alignmentPadding
;
}
;
void
alignFrameForICArguments
(
AfterICSaveLive
&
aic
)
PER_ARCH
;
void
restoreFrameAlignmentForICArguments
(
AfterICSaveLive
&
aic
)
PER_ARCH
;
AfterICSaveLive
icSaveLive
(
LiveRegisterSet
&
liveRegs
)
;
bool
icBuildOOLFakeExitFrame
(
void
*
fakeReturnAddr
AfterICSaveLive
&
aic
)
;
void
icRestoreLive
(
LiveRegisterSet
&
liveRegs
AfterICSaveLive
&
aic
)
;
void
alignJitStackBasedOnNArgs
(
Register
nargs
)
;
void
alignJitStackBasedOnNArgs
(
uint32_t
nargs
)
;
void
assertStackAlignment
(
uint32_t
alignment
int32_t
offset
=
0
)
{
#
ifdef
DEBUG
Label
ok
bad
;
MOZ_ASSERT
(
IsPowerOfTwo
(
alignment
)
)
;
offset
%
=
alignment
;
if
(
offset
<
0
)
offset
+
=
alignment
;
uint32_t
off
=
offset
;
while
(
off
)
{
uint32_t
lowestBit
=
1
<
<
mozilla
:
:
CountTrailingZeroes32
(
off
)
;
branchTestStackPtr
(
Assembler
:
:
Zero
Imm32
(
lowestBit
)
&
bad
)
;
off
^
=
lowestBit
;
}
branchTestStackPtr
(
Assembler
:
:
Zero
Imm32
(
(
alignment
-
1
)
^
offset
)
&
ok
)
;
bind
(
&
bad
)
;
breakpoint
(
)
;
bind
(
&
ok
)
;
#
endif
}
}
;
static
inline
Assembler
:
:
DoubleCondition
JSOpToDoubleCondition
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOP_EQ
:
case
JSOP_STRICTEQ
:
return
Assembler
:
:
DoubleEqual
;
case
JSOP_NE
:
case
JSOP_STRICTNE
:
return
Assembler
:
:
DoubleNotEqualOrUnordered
;
case
JSOP_LT
:
return
Assembler
:
:
DoubleLessThan
;
case
JSOP_LE
:
return
Assembler
:
:
DoubleLessThanOrEqual
;
case
JSOP_GT
:
return
Assembler
:
:
DoubleGreaterThan
;
case
JSOP_GE
:
return
Assembler
:
:
DoubleGreaterThanOrEqual
;
default
:
MOZ_CRASH
(
"
Unexpected
comparison
operation
"
)
;
}
}
static
inline
Assembler
:
:
Condition
JSOpToCondition
(
JSOp
op
bool
isSigned
)
{
if
(
isSigned
)
{
switch
(
op
)
{
case
JSOP_EQ
:
case
JSOP_STRICTEQ
:
return
Assembler
:
:
Equal
;
case
JSOP_NE
:
case
JSOP_STRICTNE
:
return
Assembler
:
:
NotEqual
;
case
JSOP_LT
:
return
Assembler
:
:
LessThan
;
case
JSOP_LE
:
return
Assembler
:
:
LessThanOrEqual
;
case
JSOP_GT
:
return
Assembler
:
:
GreaterThan
;
case
JSOP_GE
:
return
Assembler
:
:
GreaterThanOrEqual
;
default
:
MOZ_CRASH
(
"
Unrecognized
comparison
operation
"
)
;
}
}
else
{
switch
(
op
)
{
case
JSOP_EQ
:
case
JSOP_STRICTEQ
:
return
Assembler
:
:
Equal
;
case
JSOP_NE
:
case
JSOP_STRICTNE
:
return
Assembler
:
:
NotEqual
;
case
JSOP_LT
:
return
Assembler
:
:
Below
;
case
JSOP_LE
:
return
Assembler
:
:
BelowOrEqual
;
case
JSOP_GT
:
return
Assembler
:
:
Above
;
case
JSOP_GE
:
return
Assembler
:
:
AboveOrEqual
;
default
:
MOZ_CRASH
(
"
Unrecognized
comparison
operation
"
)
;
}
}
}
static
inline
size_t
StackDecrementForCall
(
uint32_t
alignment
size_t
bytesAlreadyPushed
size_t
bytesToPush
)
{
return
bytesToPush
+
ComputeByteAlignment
(
bytesAlreadyPushed
+
bytesToPush
alignment
)
;
}
static
inline
MIRType
ToMIRType
(
MIRType
t
)
{
return
t
;
}
template
<
class
VecT
>
class
ABIArgIter
{
ABIArgGenerator
gen_
;
const
VecT
&
types_
;
unsigned
i_
;
void
settle
(
)
{
if
(
!
done
(
)
)
gen_
.
next
(
ToMIRType
(
types_
[
i_
]
)
)
;
}
public
:
explicit
ABIArgIter
(
const
VecT
&
types
)
:
types_
(
types
)
i_
(
0
)
{
settle
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
i_
+
+
;
settle
(
)
;
}
bool
done
(
)
const
{
return
i_
=
=
types_
.
length
(
)
;
}
ABIArg
*
operator
-
>
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
&
gen_
.
current
(
)
;
}
ABIArg
&
operator
*
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
gen_
.
current
(
)
;
}
unsigned
index
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
i_
;
}
MIRType
mirType
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
ToMIRType
(
types_
[
i_
]
)
;
}
uint32_t
stackBytesConsumedSoFar
(
)
const
{
return
gen_
.
stackBytesConsumedSoFar
(
)
;
}
}
;
}
}
#
endif
