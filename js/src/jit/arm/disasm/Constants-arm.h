#
ifndef
jit_arm_disasm_Constants_arm_h
#
define
jit_arm_disasm_Constants_arm_h
#
ifdef
JS_DISASM_ARM
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
string
.
h
>
namespace
js
{
namespace
jit
{
namespace
disasm
{
const
int
kConstantPoolMarkerMask
=
0xfff000f0
;
const
int
kConstantPoolMarker
=
0xe7f000f0
;
const
int
kConstantPoolLengthMaxMask
=
0xffff
;
inline
int
EncodeConstantPoolLength
(
int
length
)
{
MOZ_ASSERT
(
(
length
&
kConstantPoolLengthMaxMask
)
=
=
length
)
;
return
(
(
length
&
0xfff0
)
<
<
4
)
|
(
length
&
0xf
)
;
}
inline
int
DecodeConstantPoolLength
(
int
instr
)
{
MOZ_ASSERT
(
(
instr
&
kConstantPoolMarkerMask
)
=
=
kConstantPoolMarker
)
;
return
(
(
instr
>
>
4
)
&
0xfff0
)
|
(
instr
&
0xf
)
;
}
const
int
kCodeAgeJumpInstruction
=
0xe51ff004
;
const
int
kNumRegisters
=
16
;
const
int
kNumVFPSingleRegisters
=
32
;
const
int
kNumVFPDoubleRegisters
=
32
;
const
int
kNumVFPRegisters
=
kNumVFPSingleRegisters
+
kNumVFPDoubleRegisters
;
const
int
kPCRegister
=
15
;
const
int
kNoRegister
=
-
1
;
enum
Condition
{
kNoCondition
=
-
1
eq
=
0
<
<
28
ne
=
1
<
<
28
cs
=
2
<
<
28
cc
=
3
<
<
28
mi
=
4
<
<
28
pl
=
5
<
<
28
vs
=
6
<
<
28
vc
=
7
<
<
28
hi
=
8
<
<
28
ls
=
9
<
<
28
ge
=
10
<
<
28
lt
=
11
<
<
28
gt
=
12
<
<
28
le
=
13
<
<
28
al
=
14
<
<
28
kSpecialCondition
=
15
<
<
28
kNumberOfConditions
=
16
hs
=
cs
lo
=
cc
}
;
inline
Condition
NegateCondition
(
Condition
cond
)
{
MOZ_ASSERT
(
cond
!
=
al
)
;
return
static_cast
<
Condition
>
(
cond
^
ne
)
;
}
inline
Condition
CommuteCondition
(
Condition
cond
)
{
switch
(
cond
)
{
case
lo
:
return
hi
;
case
hi
:
return
lo
;
case
hs
:
return
ls
;
case
ls
:
return
hs
;
case
lt
:
return
gt
;
case
gt
:
return
lt
;
case
ge
:
return
le
;
case
le
:
return
ge
;
default
:
return
cond
;
}
}
typedef
int32_t
Instr
;
enum
Opcode
{
AND
=
0
<
<
21
EOR
=
1
<
<
21
SUB
=
2
<
<
21
RSB
=
3
<
<
21
ADD
=
4
<
<
21
ADC
=
5
<
<
21
SBC
=
6
<
<
21
RSC
=
7
<
<
21
TST
=
8
<
<
21
TEQ
=
9
<
<
21
CMP
=
10
<
<
21
CMN
=
11
<
<
21
ORR
=
12
<
<
21
MOV
=
13
<
<
21
BIC
=
14
<
<
21
MVN
=
15
<
<
21
}
;
enum
MiscInstructionsBits74
{
BX
=
1
<
<
4
BXJ
=
2
<
<
4
BLX
=
3
<
<
4
BKPT
=
7
<
<
4
CLZ
=
1
<
<
4
}
;
enum
{
ExclusiveOpHi
=
24
ExclusiveOpLo
=
23
ExclusiveSizeHi
=
22
ExclusiveSizeLo
=
21
ExclusiveLoad
=
20
}
;
enum
{
ExclusiveOpcode
=
3
}
;
enum
{
ExclusiveWord
=
0
ExclusiveDouble
=
1
ExclusiveByte
=
2
ExclusiveHalf
=
3
}
;
enum
{
H
=
1
<
<
5
S6
=
1
<
<
6
L
=
1
<
<
20
S
=
1
<
<
20
W
=
1
<
<
21
A
=
1
<
<
21
B
=
1
<
<
22
N
=
1
<
<
22
U
=
1
<
<
23
P
=
1
<
<
24
I
=
1
<
<
25
B0
=
1
<
<
0
B4
=
1
<
<
4
B5
=
1
<
<
5
B6
=
1
<
<
6
B7
=
1
<
<
7
B8
=
1
<
<
8
B9
=
1
<
<
9
B12
=
1
<
<
12
B16
=
1
<
<
16
B17
=
1
<
<
17
B18
=
1
<
<
18
B19
=
1
<
<
19
B20
=
1
<
<
20
B21
=
1
<
<
21
B22
=
1
<
<
22
B23
=
1
<
<
23
B24
=
1
<
<
24
B25
=
1
<
<
25
B26
=
1
<
<
26
B27
=
1
<
<
27
B28
=
1
<
<
28
kCondMask
=
15
<
<
28
kALUMask
=
0x6f
<
<
21
kRdMask
=
15
<
<
12
kCoprocessorMask
=
15
<
<
8
kOpCodeMask
=
15
<
<
21
kImm24Mask
=
(
1
<
<
24
)
-
1
kImm16Mask
=
(
1
<
<
16
)
-
1
kImm8Mask
=
(
1
<
<
8
)
-
1
kOff12Mask
=
(
1
<
<
12
)
-
1
kOff8Mask
=
(
1
<
<
8
)
-
1
}
;
enum
SBit
{
SetCC
=
1
<
<
20
LeaveCC
=
0
<
<
20
}
;
enum
SRegister
{
CPSR
=
0
<
<
22
SPSR
=
1
<
<
22
}
;
enum
ShiftOp
{
LSL
=
0
<
<
5
LSR
=
1
<
<
5
ASR
=
2
<
<
5
ROR
=
3
<
<
5
RRX
=
-
1
kNumberOfShifts
=
4
}
;
enum
SRegisterField
{
CPSR_c
=
CPSR
|
1
<
<
16
CPSR_x
=
CPSR
|
1
<
<
17
CPSR_s
=
CPSR
|
1
<
<
18
CPSR_f
=
CPSR
|
1
<
<
19
SPSR_c
=
SPSR
|
1
<
<
16
SPSR_x
=
SPSR
|
1
<
<
17
SPSR_s
=
SPSR
|
1
<
<
18
SPSR_f
=
SPSR
|
1
<
<
19
}
;
typedef
uint32_t
SRegisterFieldMask
;
enum
AddrMode
{
Offset
=
(
8
|
4
|
0
)
<
<
21
PreIndex
=
(
8
|
4
|
1
)
<
<
21
PostIndex
=
(
0
|
4
|
0
)
<
<
21
NegOffset
=
(
8
|
0
|
0
)
<
<
21
NegPreIndex
=
(
8
|
0
|
1
)
<
<
21
NegPostIndex
=
(
0
|
0
|
0
)
<
<
21
}
;
enum
BlockAddrMode
{
da
=
(
0
|
0
|
0
)
<
<
21
ia
=
(
0
|
4
|
0
)
<
<
21
db
=
(
8
|
0
|
0
)
<
<
21
ib
=
(
8
|
4
|
0
)
<
<
21
da_w
=
(
0
|
0
|
1
)
<
<
21
ia_w
=
(
0
|
4
|
1
)
<
<
21
db_w
=
(
8
|
0
|
1
)
<
<
21
ib_w
=
(
8
|
4
|
1
)
<
<
21
da_x
=
(
0
|
0
|
0
)
<
<
21
ia_x
=
(
0
|
4
|
0
)
<
<
21
db_x
=
(
8
|
0
|
0
)
<
<
21
ib_x
=
(
8
|
4
|
0
)
<
<
21
kBlockAddrModeMask
=
(
8
|
4
|
1
)
<
<
21
}
;
enum
LFlag
{
Long
=
1
<
<
22
Short
=
0
<
<
22
}
;
enum
NeonDataType
{
NeonS8
=
0x1
NeonS16
=
0x2
NeonS32
=
0x4
NeonU8
=
1
<
<
24
|
0x1
NeonU16
=
1
<
<
24
|
0x2
NeonU32
=
1
<
<
24
|
0x4
NeonDataTypeSizeMask
=
0x7
NeonDataTypeUMask
=
1
<
<
24
}
;
enum
NeonListType
{
nlt_1
=
0x7
nlt_2
=
0xA
nlt_3
=
0x6
nlt_4
=
0x2
}
;
enum
NeonSize
{
Neon8
=
0x0
Neon16
=
0x1
Neon32
=
0x2
Neon64
=
0x3
}
;
enum
SoftwareInterruptCodes
{
kCallRtRedirected
=
0x10
kBreakpoint
=
0x20
kStopCode
=
1
<
<
23
}
;
const
uint32_t
kStopCodeMask
=
kStopCode
-
1
;
const
uint32_t
kMaxStopCode
=
kStopCode
-
1
;
const
int32_t
kDefaultStopCode
=
-
1
;
enum
VFPRegPrecision
{
kSinglePrecision
=
0
kDoublePrecision
=
1
}
;
enum
VFPConversionMode
{
kFPSCRRounding
=
0
kDefaultRoundToZero
=
1
}
;
const
uint32_t
kVFPExceptionMask
=
0xf
;
const
uint32_t
kVFPInvalidOpExceptionBit
=
1
<
<
0
;
const
uint32_t
kVFPOverflowExceptionBit
=
1
<
<
2
;
const
uint32_t
kVFPUnderflowExceptionBit
=
1
<
<
3
;
const
uint32_t
kVFPInexactExceptionBit
=
1
<
<
4
;
const
uint32_t
kVFPFlushToZeroMask
=
1
<
<
24
;
const
uint32_t
kVFPDefaultNaNModeControlBit
=
1
<
<
25
;
const
uint32_t
kVFPNConditionFlagBit
=
1
<
<
31
;
const
uint32_t
kVFPZConditionFlagBit
=
1
<
<
30
;
const
uint32_t
kVFPCConditionFlagBit
=
1
<
<
29
;
const
uint32_t
kVFPVConditionFlagBit
=
1
<
<
28
;
enum
VFPRoundingMode
{
RN
=
0
<
<
22
RP
=
1
<
<
22
RM
=
2
<
<
22
RZ
=
3
<
<
22
kRoundToNearest
=
RN
kRoundToPlusInf
=
RP
kRoundToMinusInf
=
RM
kRoundToZero
=
RZ
}
;
const
uint32_t
kVFPRoundingModeMask
=
3
<
<
22
;
enum
CheckForInexactConversion
{
kCheckForInexactConversion
kDontCheckForInexactConversion
}
;
enum
Hint
{
no_hint
}
;
inline
Hint
NegateHint
(
Hint
ignored
)
{
return
no_hint
;
}
class
Instruction
{
public
:
enum
{
kInstrSize
=
4
kInstrSizeLog2
=
2
kPCReadOffset
=
8
}
;
#
define
DECLARE_STATIC_TYPED_ACCESSOR
(
return_type
Name
)
\
static
inline
return_type
Name
(
Instr
instr
)
{
\
char
*
temp
=
reinterpret_cast
<
char
*
>
(
&
instr
)
;
\
return
reinterpret_cast
<
Instruction
*
>
(
temp
)
-
>
Name
(
)
;
\
}
#
define
DECLARE_STATIC_ACCESSOR
(
Name
)
DECLARE_STATIC_TYPED_ACCESSOR
(
int
Name
)
inline
Instr
InstructionBits
(
)
const
{
return
*
reinterpret_cast
<
const
Instr
*
>
(
this
)
;
}
inline
void
SetInstructionBits
(
Instr
value
)
{
*
reinterpret_cast
<
Instr
*
>
(
this
)
=
value
;
}
inline
int
Bit
(
int
nr
)
const
{
return
(
InstructionBits
(
)
>
>
nr
)
&
1
;
}
inline
int
Bits
(
int
hi
int
lo
)
const
{
return
(
InstructionBits
(
)
>
>
lo
)
&
(
(
2
<
<
(
hi
-
lo
)
)
-
1
)
;
}
inline
int
BitField
(
int
hi
int
lo
)
const
{
return
InstructionBits
(
)
&
(
(
(
2
<
<
(
hi
-
lo
)
)
-
1
)
<
<
lo
)
;
}
static
inline
int
Bit
(
Instr
instr
int
nr
)
{
return
(
instr
>
>
nr
)
&
1
;
}
static
inline
int
Bits
(
Instr
instr
int
hi
int
lo
)
{
return
(
instr
>
>
lo
)
&
(
(
2
<
<
(
hi
-
lo
)
)
-
1
)
;
}
static
inline
int
BitField
(
Instr
instr
int
hi
int
lo
)
{
return
instr
&
(
(
(
2
<
<
(
hi
-
lo
)
)
-
1
)
<
<
lo
)
;
}
inline
Condition
ConditionValue
(
)
const
{
return
static_cast
<
Condition
>
(
Bits
(
31
28
)
)
;
}
inline
Condition
ConditionField
(
)
const
{
return
static_cast
<
Condition
>
(
BitField
(
31
28
)
)
;
}
DECLARE_STATIC_TYPED_ACCESSOR
(
Condition
ConditionValue
)
;
DECLARE_STATIC_TYPED_ACCESSOR
(
Condition
ConditionField
)
;
inline
int
TypeValue
(
)
const
{
return
Bits
(
27
25
)
;
}
inline
int
SpecialValue
(
)
const
{
return
Bits
(
27
23
)
;
}
inline
int
RnValue
(
)
const
{
return
Bits
(
19
16
)
;
}
DECLARE_STATIC_ACCESSOR
(
RnValue
)
;
inline
int
RdValue
(
)
const
{
return
Bits
(
15
12
)
;
}
DECLARE_STATIC_ACCESSOR
(
RdValue
)
;
inline
int
CoprocessorValue
(
)
const
{
return
Bits
(
11
8
)
;
}
inline
int
VnValue
(
)
const
{
return
Bits
(
19
16
)
;
}
inline
int
VmValue
(
)
const
{
return
Bits
(
3
0
)
;
}
inline
int
VdValue
(
)
const
{
return
Bits
(
15
12
)
;
}
inline
int
NValue
(
)
const
{
return
Bit
(
7
)
;
}
inline
int
MValue
(
)
const
{
return
Bit
(
5
)
;
}
inline
int
DValue
(
)
const
{
return
Bit
(
22
)
;
}
inline
int
RtValue
(
)
const
{
return
Bits
(
15
12
)
;
}
inline
int
PValue
(
)
const
{
return
Bit
(
24
)
;
}
inline
int
UValue
(
)
const
{
return
Bit
(
23
)
;
}
inline
int
Opc1Value
(
)
const
{
return
(
Bit
(
23
)
<
<
2
)
|
Bits
(
21
20
)
;
}
inline
int
Opc2Value
(
)
const
{
return
Bits
(
19
16
)
;
}
inline
int
Opc3Value
(
)
const
{
return
Bits
(
7
6
)
;
}
inline
int
SzValue
(
)
const
{
return
Bit
(
8
)
;
}
inline
int
VLValue
(
)
const
{
return
Bit
(
20
)
;
}
inline
int
VCValue
(
)
const
{
return
Bit
(
8
)
;
}
inline
int
VAValue
(
)
const
{
return
Bits
(
23
21
)
;
}
inline
int
VBValue
(
)
const
{
return
Bits
(
6
5
)
;
}
inline
int
VFPNRegValue
(
VFPRegPrecision
pre
)
{
return
VFPGlueRegValue
(
pre
16
7
)
;
}
inline
int
VFPMRegValue
(
VFPRegPrecision
pre
)
{
return
VFPGlueRegValue
(
pre
0
5
)
;
}
inline
int
VFPDRegValue
(
VFPRegPrecision
pre
)
{
return
VFPGlueRegValue
(
pre
12
22
)
;
}
inline
int
OpcodeValue
(
)
const
{
return
static_cast
<
Opcode
>
(
Bits
(
24
21
)
)
;
}
inline
Opcode
OpcodeField
(
)
const
{
return
static_cast
<
Opcode
>
(
BitField
(
24
21
)
)
;
}
inline
int
SValue
(
)
const
{
return
Bit
(
20
)
;
}
inline
int
RmValue
(
)
const
{
return
Bits
(
3
0
)
;
}
DECLARE_STATIC_ACCESSOR
(
RmValue
)
;
inline
int
ShiftValue
(
)
const
{
return
static_cast
<
ShiftOp
>
(
Bits
(
6
5
)
)
;
}
inline
ShiftOp
ShiftField
(
)
const
{
return
static_cast
<
ShiftOp
>
(
BitField
(
6
5
)
)
;
}
inline
int
RegShiftValue
(
)
const
{
return
Bit
(
4
)
;
}
inline
int
RsValue
(
)
const
{
return
Bits
(
11
8
)
;
}
inline
int
ShiftAmountValue
(
)
const
{
return
Bits
(
11
7
)
;
}
inline
int
RotateValue
(
)
const
{
return
Bits
(
11
8
)
;
}
DECLARE_STATIC_ACCESSOR
(
RotateValue
)
;
inline
int
Immed8Value
(
)
const
{
return
Bits
(
7
0
)
;
}
DECLARE_STATIC_ACCESSOR
(
Immed8Value
)
;
inline
int
Immed4Value
(
)
const
{
return
Bits
(
19
16
)
;
}
inline
int
ImmedMovwMovtValue
(
)
const
{
return
Immed4Value
(
)
<
<
12
|
Offset12Value
(
)
;
}
DECLARE_STATIC_ACCESSOR
(
ImmedMovwMovtValue
)
;
inline
int
PUValue
(
)
const
{
return
Bits
(
24
23
)
;
}
inline
int
PUField
(
)
const
{
return
BitField
(
24
23
)
;
}
inline
int
BValue
(
)
const
{
return
Bit
(
22
)
;
}
inline
int
WValue
(
)
const
{
return
Bit
(
21
)
;
}
inline
int
LValue
(
)
const
{
return
Bit
(
20
)
;
}
inline
int
Offset12Value
(
)
const
{
return
Bits
(
11
0
)
;
}
inline
int
RlistValue
(
)
const
{
return
Bits
(
15
0
)
;
}
inline
int
SignValue
(
)
const
{
return
Bit
(
6
)
;
}
inline
int
HValue
(
)
const
{
return
Bit
(
5
)
;
}
inline
int
ImmedHValue
(
)
const
{
return
Bits
(
11
8
)
;
}
inline
int
ImmedLValue
(
)
const
{
return
Bits
(
3
0
)
;
}
inline
int
LinkValue
(
)
const
{
return
Bit
(
24
)
;
}
inline
int
SImmed24Value
(
)
const
{
return
(
(
InstructionBits
(
)
<
<
8
)
>
>
8
)
;
}
inline
SoftwareInterruptCodes
SvcValue
(
)
const
{
return
static_cast
<
SoftwareInterruptCodes
>
(
Bits
(
23
0
)
)
;
}
inline
bool
IsSpecialType0
(
)
const
{
return
(
Bit
(
7
)
=
=
1
)
&
&
(
Bit
(
4
)
=
=
1
)
;
}
inline
bool
IsMiscType0
(
)
const
{
return
(
Bit
(
24
)
=
=
1
)
&
&
(
Bit
(
23
)
=
=
0
)
&
&
(
Bit
(
20
)
=
=
0
)
&
&
(
(
Bit
(
7
)
=
=
0
)
)
;
}
inline
bool
IsNopType1
(
)
const
{
return
Bits
(
24
0
)
=
=
0x0120F000
;
}
inline
bool
IsStop
(
)
const
{
return
(
TypeValue
(
)
=
=
7
)
&
&
(
Bit
(
24
)
=
=
1
)
&
&
(
SvcValue
(
)
>
=
kStopCode
)
;
}
inline
bool
HasS
(
)
const
{
return
SValue
(
)
=
=
1
;
}
inline
bool
HasB
(
)
const
{
return
BValue
(
)
=
=
1
;
}
inline
bool
HasW
(
)
const
{
return
WValue
(
)
=
=
1
;
}
inline
bool
HasL
(
)
const
{
return
LValue
(
)
=
=
1
;
}
inline
bool
HasU
(
)
const
{
return
UValue
(
)
=
=
1
;
}
inline
bool
HasSign
(
)
const
{
return
SignValue
(
)
=
=
1
;
}
inline
bool
HasH
(
)
const
{
return
HValue
(
)
=
=
1
;
}
inline
bool
HasLink
(
)
const
{
return
LinkValue
(
)
=
=
1
;
}
double
DoubleImmedVmov
(
)
const
;
static
Instruction
*
At
(
uint8_t
*
pc
)
{
return
reinterpret_cast
<
Instruction
*
>
(
pc
)
;
}
private
:
inline
int
VFPGlueRegValue
(
VFPRegPrecision
pre
int
four_bit
int
one_bit
)
{
if
(
pre
=
=
kSinglePrecision
)
{
return
(
Bits
(
four_bit
+
3
four_bit
)
<
<
1
)
|
Bit
(
one_bit
)
;
}
return
(
Bit
(
one_bit
)
<
<
4
)
|
Bits
(
four_bit
+
3
four_bit
)
;
}
Instruction
(
)
=
delete
;
Instruction
(
const
Instruction
&
)
=
delete
;
void
operator
=
(
const
Instruction
&
)
=
delete
;
}
;
class
Registers
{
public
:
static
const
char
*
Name
(
int
reg
)
;
static
int
Number
(
const
char
*
name
)
;
struct
RegisterAlias
{
int
reg
;
const
char
*
name
;
}
;
private
:
static
const
char
*
names_
[
kNumRegisters
]
;
static
const
RegisterAlias
aliases_
[
]
;
}
;
class
VFPRegisters
{
public
:
static
const
char
*
Name
(
int
reg
bool
is_double
)
;
static
int
Number
(
const
char
*
name
bool
*
is_double
)
;
private
:
static
const
char
*
names_
[
kNumVFPRegisters
]
;
}
;
}
}
}
#
endif
#
endif
