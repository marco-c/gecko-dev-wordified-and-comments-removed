#
ifndef
jit_arm_disasm_Disasm_arm_h
#
define
jit_arm_disasm_Disasm_arm_h
#
ifdef
JS_DISASM_ARM
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
stdio
.
h
>
namespace
js
{
namespace
jit
{
namespace
disasm
{
typedef
unsigned
char
byte
;
const
int
ReasonableBufferSize
=
256
;
template
<
typename
T
>
class
V8Vector
{
public
:
V8Vector
(
)
:
start_
(
nullptr
)
length_
(
0
)
{
}
V8Vector
(
T
*
data
int
length
)
:
start_
(
data
)
length_
(
length
)
{
MOZ_ASSERT
(
length
=
=
0
|
|
(
length
>
0
&
&
data
!
=
nullptr
)
)
;
}
int
length
(
)
const
{
return
length_
;
}
T
*
start
(
)
const
{
return
start_
;
}
T
&
operator
[
]
(
int
index
)
const
{
MOZ_ASSERT
(
0
<
=
index
&
&
index
<
length_
)
;
return
start_
[
index
]
;
}
inline
V8Vector
<
T
>
operator
+
(
int
offset
)
{
MOZ_ASSERT
(
offset
<
length_
)
;
return
V8Vector
<
T
>
(
start_
+
offset
length_
-
offset
)
;
}
private
:
T
*
start_
;
int
length_
;
}
;
template
<
typename
T
int
kSize
>
class
EmbeddedVector
:
public
V8Vector
<
T
>
{
public
:
EmbeddedVector
(
)
:
V8Vector
<
T
>
(
buffer_
kSize
)
{
}
explicit
EmbeddedVector
(
T
initial_value
)
:
V8Vector
<
T
>
(
buffer_
kSize
)
{
for
(
int
i
=
0
;
i
<
kSize
;
+
+
i
)
{
buffer_
[
i
]
=
initial_value
;
}
}
EmbeddedVector
(
const
EmbeddedVector
&
rhs
)
:
V8Vector
<
T
>
(
rhs
)
{
MemCopy
(
buffer_
rhs
.
buffer_
sizeof
(
T
)
*
kSize
)
;
this
-
>
set_start
(
buffer_
)
;
}
EmbeddedVector
&
operator
=
(
const
EmbeddedVector
&
rhs
)
{
if
(
this
=
=
&
rhs
)
return
*
this
;
V8Vector
<
T
>
:
:
operator
=
(
rhs
)
;
MemCopy
(
buffer_
rhs
.
buffer_
sizeof
(
T
)
*
kSize
)
;
this
-
>
set_start
(
buffer_
)
;
return
*
this
;
}
private
:
T
buffer_
[
kSize
]
;
}
;
class
NameConverter
{
public
:
virtual
~
NameConverter
(
)
{
}
virtual
const
char
*
NameOfCPURegister
(
int
reg
)
const
;
virtual
const
char
*
NameOfByteCPURegister
(
int
reg
)
const
;
virtual
const
char
*
NameOfXMMRegister
(
int
reg
)
const
;
virtual
const
char
*
NameOfAddress
(
byte
*
addr
)
const
;
virtual
const
char
*
NameOfConstant
(
byte
*
addr
)
const
;
virtual
const
char
*
NameInCode
(
byte
*
addr
)
const
;
protected
:
EmbeddedVector
<
char
128
>
tmp_buffer_
;
}
;
class
Disassembler
{
public
:
explicit
Disassembler
(
const
NameConverter
&
converter
)
;
virtual
~
Disassembler
(
)
;
int
InstructionDecode
(
V8Vector
<
char
>
buffer
uint8_t
*
instruction
)
;
int
ConstantPoolSizeAt
(
byte
*
instruction
)
;
static
void
Disassemble
(
FILE
*
f
uint8_t
*
begin
uint8_t
*
end
)
;
private
:
const
NameConverter
&
converter_
;
Disassembler
(
)
=
delete
;
Disassembler
(
const
Disassembler
&
)
=
delete
;
void
operator
=
(
const
Disassembler
&
)
=
delete
;
}
;
}
}
}
#
endif
#
endif
