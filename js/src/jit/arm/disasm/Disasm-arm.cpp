#
include
"
jit
/
arm
/
disasm
/
Disasm
-
arm
.
h
"
#
ifdef
JS_DISASM_ARM
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
jit
/
arm
/
disasm
/
Constants
-
arm
.
h
"
namespace
js
{
namespace
jit
{
namespace
disasm
{
static
int
SNPrintF
(
V8Vector
<
char
>
str
const
char
*
format
.
.
.
)
{
va_list
args
;
va_start
(
args
format
)
;
int
result
=
vsnprintf
(
str
.
start
(
)
str
.
length
(
)
format
args
)
;
va_end
(
args
)
;
return
result
;
}
class
Decoder
{
public
:
Decoder
(
const
disasm
:
:
NameConverter
&
converter
V8Vector
<
char
>
out_buffer
)
:
converter_
(
converter
)
out_buffer_
(
out_buffer
)
out_buffer_pos_
(
0
)
{
out_buffer_
[
out_buffer_pos_
]
=
'
\
0
'
;
}
~
Decoder
(
)
{
}
int
InstructionDecode
(
uint8_t
*
instruction
)
;
static
bool
IsConstantPoolAt
(
uint8_t
*
instr_ptr
)
;
static
int
ConstantPoolSizeAt
(
uint8_t
*
instr_ptr
)
;
private
:
void
PrintChar
(
const
char
ch
)
;
void
Print
(
const
char
*
str
)
;
void
PrintRegister
(
int
reg
)
;
void
PrintSRegister
(
int
reg
)
;
void
PrintDRegister
(
int
reg
)
;
int
FormatVFPRegister
(
Instruction
*
instr
const
char
*
format
)
;
void
PrintMovwMovt
(
Instruction
*
instr
)
;
int
FormatVFPinstruction
(
Instruction
*
instr
const
char
*
format
)
;
void
PrintCondition
(
Instruction
*
instr
)
;
void
PrintShiftRm
(
Instruction
*
instr
)
;
void
PrintShiftImm
(
Instruction
*
instr
)
;
void
PrintShiftSat
(
Instruction
*
instr
)
;
void
PrintPU
(
Instruction
*
instr
)
;
void
PrintSoftwareInterrupt
(
SoftwareInterruptCodes
svc
)
;
int
FormatRegister
(
Instruction
*
instr
const
char
*
option
)
;
void
FormatNeonList
(
int
Vd
int
type
)
;
void
FormatNeonMemory
(
int
Rn
int
align
int
Rm
)
;
int
FormatOption
(
Instruction
*
instr
const
char
*
option
)
;
void
Format
(
Instruction
*
instr
const
char
*
format
)
;
void
Unknown
(
Instruction
*
instr
)
;
void
DecodeType01
(
Instruction
*
instr
)
;
void
DecodeType2
(
Instruction
*
instr
)
;
void
DecodeType3
(
Instruction
*
instr
)
;
void
DecodeType4
(
Instruction
*
instr
)
;
void
DecodeType5
(
Instruction
*
instr
)
;
void
DecodeType6
(
Instruction
*
instr
)
;
int
DecodeType7
(
Instruction
*
instr
)
;
void
DecodeTypeVFP
(
Instruction
*
instr
)
;
void
DecodeType6CoprocessorIns
(
Instruction
*
instr
)
;
void
DecodeSpecialCondition
(
Instruction
*
instr
)
;
void
DecodeVMOVBetweenCoreAndSinglePrecisionRegisters
(
Instruction
*
instr
)
;
void
DecodeVCMP
(
Instruction
*
instr
)
;
void
DecodeVCVTBetweenDoubleAndSingle
(
Instruction
*
instr
)
;
void
DecodeVCVTBetweenFloatingPointAndInteger
(
Instruction
*
instr
)
;
const
disasm
:
:
NameConverter
&
converter_
;
V8Vector
<
char
>
out_buffer_
;
int
out_buffer_pos_
;
Decoder
(
const
Decoder
&
)
=
delete
;
void
operator
=
(
const
Decoder
&
)
=
delete
;
}
;
#
define
STRING_STARTS_WITH
(
string
compare_string
)
\
(
strncmp
(
string
compare_string
strlen
(
compare_string
)
)
=
=
0
)
void
Decoder
:
:
PrintChar
(
const
char
ch
)
{
out_buffer_
[
out_buffer_pos_
+
+
]
=
ch
;
}
void
Decoder
:
:
Print
(
const
char
*
str
)
{
char
cur
=
*
str
+
+
;
while
(
cur
!
=
'
\
0
'
&
&
(
out_buffer_pos_
<
int
(
out_buffer_
.
length
(
)
-
1
)
)
)
{
PrintChar
(
cur
)
;
cur
=
*
str
+
+
;
}
out_buffer_
[
out_buffer_pos_
]
=
0
;
}
static
const
char
*
const
cond_names
[
kNumberOfConditions
]
=
{
"
eq
"
"
ne
"
"
cs
"
"
cc
"
"
mi
"
"
pl
"
"
vs
"
"
vc
"
"
hi
"
"
ls
"
"
ge
"
"
lt
"
"
gt
"
"
le
"
"
"
"
invalid
"
}
;
void
Decoder
:
:
PrintCondition
(
Instruction
*
instr
)
{
Print
(
cond_names
[
instr
-
>
ConditionValue
(
)
]
)
;
}
void
Decoder
:
:
PrintRegister
(
int
reg
)
{
Print
(
converter_
.
NameOfCPURegister
(
reg
)
)
;
}
void
Decoder
:
:
PrintSRegister
(
int
reg
)
{
Print
(
VFPRegisters
:
:
Name
(
reg
false
)
)
;
}
void
Decoder
:
:
PrintDRegister
(
int
reg
)
{
Print
(
VFPRegisters
:
:
Name
(
reg
true
)
)
;
}
static
const
char
*
const
shift_names
[
kNumberOfShifts
]
=
{
"
lsl
"
"
lsr
"
"
asr
"
"
ror
"
}
;
void
Decoder
:
:
PrintShiftRm
(
Instruction
*
instr
)
{
ShiftOp
shift
=
instr
-
>
ShiftField
(
)
;
int
shift_index
=
instr
-
>
ShiftValue
(
)
;
int
shift_amount
=
instr
-
>
ShiftAmountValue
(
)
;
int
rm
=
instr
-
>
RmValue
(
)
;
PrintRegister
(
rm
)
;
if
(
(
instr
-
>
RegShiftValue
(
)
=
=
0
)
&
&
(
shift
=
=
LSL
)
&
&
(
shift_amount
=
=
0
)
)
{
return
;
}
if
(
instr
-
>
RegShiftValue
(
)
=
=
0
)
{
if
(
(
shift
=
=
ROR
)
&
&
(
shift_amount
=
=
0
)
)
{
Print
(
"
RRX
"
)
;
return
;
}
else
if
(
(
(
shift
=
=
LSR
)
|
|
(
shift
=
=
ASR
)
)
&
&
(
shift_amount
=
=
0
)
)
{
shift_amount
=
32
;
}
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
s
#
%
d
"
shift_names
[
shift_index
]
shift_amount
)
;
}
else
{
int
rs
=
instr
-
>
RsValue
(
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
s
"
shift_names
[
shift_index
]
)
;
PrintRegister
(
rs
)
;
}
}
static
inline
uint32_t
RotateRight32
(
uint32_t
value
uint32_t
shift
)
{
if
(
shift
=
=
0
)
return
value
;
return
(
value
>
>
shift
)
|
(
value
<
<
(
32
-
shift
)
)
;
}
void
Decoder
:
:
PrintShiftImm
(
Instruction
*
instr
)
{
int
rotate
=
instr
-
>
RotateValue
(
)
*
2
;
int
immed8
=
instr
-
>
Immed8Value
(
)
;
int
imm
=
RotateRight32
(
immed8
rotate
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
#
%
d
"
imm
)
;
}
void
Decoder
:
:
PrintShiftSat
(
Instruction
*
instr
)
{
int
shift
=
instr
-
>
Bits
(
11
7
)
;
if
(
shift
>
0
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
s
#
%
d
"
shift_names
[
instr
-
>
Bit
(
6
)
*
2
]
instr
-
>
Bits
(
11
7
)
)
;
}
}
void
Decoder
:
:
PrintPU
(
Instruction
*
instr
)
{
switch
(
instr
-
>
PUField
(
)
)
{
case
da_x
:
{
Print
(
"
da
"
)
;
break
;
}
case
ia_x
:
{
Print
(
"
ia
"
)
;
break
;
}
case
db_x
:
{
Print
(
"
db
"
)
;
break
;
}
case
ib_x
:
{
Print
(
"
ib
"
)
;
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
}
void
Decoder
:
:
PrintSoftwareInterrupt
(
SoftwareInterruptCodes
svc
)
{
switch
(
svc
)
{
case
kCallRtRedirected
:
Print
(
"
call
rt
redirected
"
)
;
return
;
case
kBreakpoint
:
Print
(
"
breakpoint
"
)
;
return
;
default
:
if
(
svc
>
=
kStopCode
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
-
0x
%
x
"
svc
&
kStopCodeMask
svc
&
kStopCodeMask
)
;
}
else
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
"
svc
)
;
}
return
;
}
}
int
Decoder
:
:
FormatRegister
(
Instruction
*
instr
const
char
*
format
)
{
MOZ_ASSERT
(
format
[
0
]
=
=
'
r
'
)
;
if
(
format
[
1
]
=
=
'
n
'
)
{
int
reg
=
instr
-
>
RnValue
(
)
;
PrintRegister
(
reg
)
;
return
2
;
}
else
if
(
format
[
1
]
=
=
'
d
'
)
{
int
reg
=
instr
-
>
RdValue
(
)
;
PrintRegister
(
reg
)
;
return
2
;
}
else
if
(
format
[
1
]
=
=
'
s
'
)
{
int
reg
=
instr
-
>
RsValue
(
)
;
PrintRegister
(
reg
)
;
return
2
;
}
else
if
(
format
[
1
]
=
=
'
m
'
)
{
int
reg
=
instr
-
>
RmValue
(
)
;
PrintRegister
(
reg
)
;
return
2
;
}
else
if
(
format
[
1
]
=
=
'
t
'
)
{
int
reg
=
instr
-
>
RtValue
(
)
;
PrintRegister
(
reg
)
;
return
2
;
}
else
if
(
format
[
1
]
=
=
'
l
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
rlist
"
)
)
;
int
rlist
=
instr
-
>
RlistValue
(
)
;
int
reg
=
0
;
Print
(
"
{
"
)
;
while
(
rlist
!
=
0
)
{
if
(
(
rlist
&
1
)
!
=
0
)
{
PrintRegister
(
reg
)
;
if
(
(
rlist
>
>
1
)
!
=
0
)
{
Print
(
"
"
)
;
}
}
reg
+
+
;
rlist
>
>
=
1
;
}
Print
(
"
}
"
)
;
return
5
;
}
MOZ_CRASH
(
)
;
return
-
1
;
}
int
Decoder
:
:
FormatVFPRegister
(
Instruction
*
instr
const
char
*
format
)
{
MOZ_ASSERT
(
(
format
[
0
]
=
=
'
S
'
)
|
|
(
format
[
0
]
=
=
'
D
'
)
)
;
VFPRegPrecision
precision
=
format
[
0
]
=
=
'
D
'
?
kDoublePrecision
:
kSinglePrecision
;
int
retval
=
2
;
int
reg
=
-
1
;
if
(
format
[
1
]
=
=
'
n
'
)
{
reg
=
instr
-
>
VFPNRegValue
(
precision
)
;
}
else
if
(
format
[
1
]
=
=
'
m
'
)
{
reg
=
instr
-
>
VFPMRegValue
(
precision
)
;
}
else
if
(
format
[
1
]
=
=
'
d
'
)
{
if
(
(
instr
-
>
TypeValue
(
)
=
=
7
)
&
&
(
instr
-
>
Bit
(
24
)
=
=
0x0
)
&
&
(
instr
-
>
Bits
(
11
9
)
=
=
0x5
)
&
&
(
instr
-
>
Bit
(
4
)
=
=
0x1
)
)
{
reg
=
instr
-
>
Bits
(
19
16
)
|
(
instr
-
>
Bit
(
7
)
<
<
4
)
;
}
else
{
reg
=
instr
-
>
VFPDRegValue
(
precision
)
;
}
if
(
format
[
2
]
=
=
'
+
'
)
{
int
immed8
=
instr
-
>
Immed8Value
(
)
;
if
(
format
[
0
]
=
=
'
S
'
)
reg
+
=
immed8
-
1
;
if
(
format
[
0
]
=
=
'
D
'
)
reg
+
=
(
immed8
/
2
-
1
)
;
}
if
(
format
[
2
]
=
=
'
+
'
)
retval
=
3
;
}
else
{
MOZ_CRASH
(
)
;
}
if
(
precision
=
=
kSinglePrecision
)
{
PrintSRegister
(
reg
)
;
}
else
{
PrintDRegister
(
reg
)
;
}
return
retval
;
}
int
Decoder
:
:
FormatVFPinstruction
(
Instruction
*
instr
const
char
*
format
)
{
Print
(
format
)
;
return
0
;
}
void
Decoder
:
:
FormatNeonList
(
int
Vd
int
type
)
{
if
(
type
=
=
nlt_1
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
{
d
%
d
}
"
Vd
)
;
}
else
if
(
type
=
=
nlt_2
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
{
d
%
d
d
%
d
}
"
Vd
Vd
+
1
)
;
}
else
if
(
type
=
=
nlt_3
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
{
d
%
d
d
%
d
d
%
d
}
"
Vd
Vd
+
1
Vd
+
2
)
;
}
else
if
(
type
=
=
nlt_4
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
{
d
%
d
d
%
d
d
%
d
d
%
d
}
"
Vd
Vd
+
1
Vd
+
2
Vd
+
3
)
;
}
}
void
Decoder
:
:
FormatNeonMemory
(
int
Rn
int
align
int
Rm
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
[
r
%
d
"
Rn
)
;
if
(
align
!
=
0
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
:
%
d
"
(
1
<
<
align
)
<
<
6
)
;
}
if
(
Rm
=
=
15
)
{
Print
(
"
]
"
)
;
}
else
if
(
Rm
=
=
13
)
{
Print
(
"
]
!
"
)
;
}
else
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
]
r
%
d
"
Rm
)
;
}
}
void
Decoder
:
:
PrintMovwMovt
(
Instruction
*
instr
)
{
int
imm
=
instr
-
>
ImmedMovwMovtValue
(
)
;
int
rd
=
instr
-
>
RdValue
(
)
;
PrintRegister
(
rd
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
#
%
d
"
imm
)
;
}
int
Decoder
:
:
FormatOption
(
Instruction
*
instr
const
char
*
format
)
{
switch
(
format
[
0
]
)
{
case
'
a
'
:
{
if
(
instr
-
>
Bit
(
21
)
=
=
0
)
{
Print
(
"
ul
"
)
;
}
else
{
Print
(
"
la
"
)
;
}
return
1
;
}
case
'
b
'
:
{
if
(
instr
-
>
HasB
(
)
)
{
Print
(
"
b
"
)
;
}
return
1
;
}
case
'
c
'
:
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
cond
"
)
)
;
PrintCondition
(
instr
)
;
return
4
;
}
case
'
d
'
:
{
double
d
=
instr
-
>
DoubleImmedVmov
(
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
#
%
g
"
d
)
;
return
1
;
}
case
'
f
'
:
{
uint32_t
lsbit
=
instr
-
>
Bits
(
11
7
)
;
uint32_t
width
=
instr
-
>
Bits
(
20
16
)
+
1
;
if
(
instr
-
>
Bit
(
21
)
=
=
0
)
{
width
-
=
lsbit
;
MOZ_ASSERT
(
width
>
0
)
;
}
MOZ_ASSERT
(
(
width
+
lsbit
)
<
=
32
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
#
%
d
#
%
d
"
lsbit
width
)
;
return
1
;
}
case
'
h
'
:
{
if
(
instr
-
>
HasH
(
)
)
{
Print
(
"
h
"
)
;
}
else
{
Print
(
"
b
"
)
;
}
return
1
;
}
case
'
i
'
:
{
int
width
=
(
format
[
3
]
-
'
0
'
)
*
10
+
(
format
[
4
]
-
'
0
'
)
;
int
lsb
=
(
format
[
6
]
-
'
0
'
)
*
10
+
(
format
[
7
]
-
'
0
'
)
;
MOZ_ASSERT
(
(
width
>
=
1
)
&
&
(
width
<
=
32
)
)
;
MOZ_ASSERT
(
(
lsb
>
=
0
)
&
&
(
lsb
<
=
31
)
)
;
MOZ_ASSERT
(
(
width
+
lsb
)
<
=
32
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
"
instr
-
>
Bits
(
width
+
lsb
-
1
lsb
)
)
;
return
8
;
}
case
'
l
'
:
{
if
(
instr
-
>
HasLink
(
)
)
{
Print
(
"
l
"
)
;
}
return
1
;
}
case
'
m
'
:
{
if
(
format
[
1
]
=
=
'
w
'
)
{
PrintMovwMovt
(
instr
)
;
return
2
;
}
if
(
format
[
1
]
=
=
'
e
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
memop
"
)
)
;
if
(
instr
-
>
HasL
(
)
)
{
Print
(
"
ldr
"
)
;
}
else
{
if
(
(
instr
-
>
Bits
(
27
25
)
=
=
0
)
&
&
(
instr
-
>
Bit
(
20
)
=
=
0
)
&
&
(
instr
-
>
Bits
(
7
6
)
=
=
3
)
&
&
(
instr
-
>
Bit
(
4
)
=
=
1
)
)
{
if
(
instr
-
>
Bit
(
5
)
=
=
1
)
{
Print
(
"
strd
"
)
;
}
else
{
Print
(
"
ldrd
"
)
;
}
return
5
;
}
Print
(
"
str
"
)
;
}
return
5
;
}
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
msg
"
)
)
;
uint8_t
*
str
=
reinterpret_cast
<
uint8_t
*
>
(
instr
-
>
InstructionBits
(
)
&
0x0fffffff
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
s
"
converter_
.
NameInCode
(
str
)
)
;
return
3
;
}
case
'
o
'
:
{
if
(
(
format
[
3
]
=
=
'
1
'
)
&
&
(
format
[
4
]
=
=
'
2
'
)
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
off12
"
)
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
"
instr
-
>
Offset12Value
(
)
)
;
return
5
;
}
else
if
(
format
[
3
]
=
=
'
0
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
off0to3and8to19
"
)
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
"
(
instr
-
>
Bits
(
19
8
)
<
<
4
)
+
instr
-
>
Bits
(
3
0
)
)
;
return
15
;
}
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
off8
"
)
)
;
int
offs8
=
(
instr
-
>
ImmedHValue
(
)
<
<
4
)
|
instr
-
>
ImmedLValue
(
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
d
"
offs8
)
;
return
4
;
}
case
'
p
'
:
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
pu
"
)
)
;
PrintPU
(
instr
)
;
return
2
;
}
case
'
r
'
:
{
return
FormatRegister
(
instr
format
)
;
}
case
'
s
'
:
{
if
(
format
[
1
]
=
=
'
h
'
)
{
if
(
format
[
6
]
=
=
'
o
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
shift_op
"
)
)
;
if
(
instr
-
>
TypeValue
(
)
=
=
0
)
{
PrintShiftRm
(
instr
)
;
}
else
{
MOZ_ASSERT
(
instr
-
>
TypeValue
(
)
=
=
1
)
;
PrintShiftImm
(
instr
)
;
}
return
8
;
}
else
if
(
format
[
6
]
=
=
'
s
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
shift_sat
"
)
)
;
PrintShiftSat
(
instr
)
;
return
9
;
}
else
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
shift_rm
"
)
)
;
PrintShiftRm
(
instr
)
;
return
8
;
}
}
else
if
(
format
[
1
]
=
=
'
v
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
svc
"
)
)
;
PrintSoftwareInterrupt
(
instr
-
>
SvcValue
(
)
)
;
return
3
;
}
else
if
(
format
[
1
]
=
=
'
i
'
)
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
sign
"
)
)
;
if
(
instr
-
>
HasSign
(
)
)
{
Print
(
"
s
"
)
;
}
return
4
;
}
if
(
instr
-
>
HasS
(
)
)
{
Print
(
"
s
"
)
;
}
return
1
;
}
case
'
t
'
:
{
MOZ_ASSERT
(
STRING_STARTS_WITH
(
format
"
target
"
)
)
;
int
off
=
(
instr
-
>
SImmed24Value
(
)
<
<
2
)
+
8
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
+
d
-
>
%
s
"
off
converter_
.
NameOfAddress
(
reinterpret_cast
<
uint8_t
*
>
(
instr
)
+
off
)
)
;
return
6
;
}
case
'
u
'
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Print
(
"
u
"
)
;
}
else
{
Print
(
"
s
"
)
;
}
return
1
;
}
case
'
v
'
:
{
return
FormatVFPinstruction
(
instr
format
)
;
}
case
'
S
'
:
case
'
D
'
:
{
return
FormatVFPRegister
(
instr
format
)
;
}
case
'
w
'
:
{
if
(
instr
-
>
HasW
(
)
)
{
Print
(
"
!
"
)
;
}
return
1
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
MOZ_CRASH
(
)
;
return
-
1
;
}
void
Decoder
:
:
Format
(
Instruction
*
instr
const
char
*
format
)
{
char
cur
=
*
format
+
+
;
while
(
(
cur
!
=
0
)
&
&
(
out_buffer_pos_
<
(
out_buffer_
.
length
(
)
-
1
)
)
)
{
if
(
cur
=
=
'
\
'
'
)
{
format
+
=
FormatOption
(
instr
format
)
;
}
else
{
out_buffer_
[
out_buffer_pos_
+
+
]
=
cur
;
}
cur
=
*
format
+
+
;
}
out_buffer_
[
out_buffer_pos_
]
=
'
\
0
'
;
}
#
define
VERIFY
(
condition
)
\
if
(
!
(
condition
)
)
{
\
Unknown
(
instr
)
;
\
return
;
\
}
void
Decoder
:
:
Unknown
(
Instruction
*
instr
)
{
Format
(
instr
"
unknown
"
)
;
}
void
Decoder
:
:
DecodeType01
(
Instruction
*
instr
)
{
int
type
=
instr
-
>
TypeValue
(
)
;
if
(
(
type
=
=
0
)
&
&
instr
-
>
IsSpecialType0
(
)
)
{
if
(
instr
-
>
Bits
(
7
4
)
=
=
9
)
{
if
(
instr
-
>
Bit
(
24
)
=
=
0
)
{
if
(
instr
-
>
Bit
(
23
)
=
=
0
)
{
if
(
instr
-
>
Bit
(
21
)
=
=
0
)
{
Format
(
instr
"
mul
'
cond
'
s
'
rn
'
rm
'
rs
"
)
;
}
else
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
mla
'
cond
'
s
'
rn
'
rm
'
rs
'
rd
"
)
;
}
else
{
Format
(
instr
"
mls
'
cond
'
s
'
rn
'
rm
'
rs
'
rd
"
)
;
}
}
}
else
{
Format
(
instr
"
'
um
'
al
'
cond
'
s
'
rd
'
rn
'
rm
'
rs
"
)
;
}
}
else
{
if
(
instr
-
>
Bits
(
ExclusiveOpHi
ExclusiveOpLo
)
=
=
ExclusiveOpcode
)
{
if
(
instr
-
>
Bit
(
ExclusiveLoad
)
=
=
1
)
{
switch
(
instr
-
>
Bits
(
ExclusiveSizeHi
ExclusiveSizeLo
)
)
{
case
ExclusiveWord
:
Format
(
instr
"
ldrex
'
cond
'
rt
[
'
rn
]
"
)
;
break
;
case
ExclusiveDouble
:
Format
(
instr
"
ldrexd
'
cond
'
rt
[
'
rn
]
"
)
;
break
;
case
ExclusiveByte
:
Format
(
instr
"
ldrexb
'
cond
'
rt
[
'
rn
]
"
)
;
break
;
case
ExclusiveHalf
:
Format
(
instr
"
ldrexh
'
cond
'
rt
[
'
rn
]
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
ExclusiveSizeHi
ExclusiveSizeLo
)
)
{
case
ExclusiveWord
:
Format
(
instr
"
strex
'
cond
'
rd
'
rm
[
'
rn
]
"
)
;
break
;
case
ExclusiveDouble
:
Format
(
instr
"
strexd
'
cond
'
rd
'
rm
[
'
rn
]
"
)
;
break
;
case
ExclusiveByte
:
Format
(
instr
"
strexb
'
cond
'
rd
'
rm
[
'
rn
]
"
)
;
break
;
case
ExclusiveHalf
:
Format
(
instr
"
strexh
'
cond
'
rd
'
rm
[
'
rn
]
"
)
;
break
;
}
}
}
else
{
Unknown
(
instr
)
;
}
}
}
else
if
(
(
instr
-
>
Bit
(
20
)
=
=
0
)
&
&
(
(
instr
-
>
Bits
(
7
4
)
&
0xd
)
=
=
0xd
)
)
{
switch
(
instr
-
>
PUField
(
)
)
{
case
da_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
]
-
'
rm
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
]
#
-
'
off8
"
)
;
}
break
;
}
case
ia_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
]
+
'
rm
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
]
#
+
'
off8
"
)
;
}
break
;
}
case
db_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
-
'
rm
]
'
w
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
#
-
'
off8
]
'
w
"
)
;
}
break
;
}
case
ib_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
+
'
rm
]
'
w
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
s
'
rd
[
'
rn
#
+
'
off8
]
'
w
"
)
;
}
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
}
else
{
switch
(
instr
-
>
PUField
(
)
)
{
case
da_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
]
-
'
rm
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
]
#
-
'
off8
"
)
;
}
break
;
}
case
ia_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
]
+
'
rm
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
]
#
+
'
off8
"
)
;
}
break
;
}
case
db_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
-
'
rm
]
'
w
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
#
-
'
off8
]
'
w
"
)
;
}
break
;
}
case
ib_x
:
{
if
(
instr
-
>
Bit
(
22
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
+
'
rm
]
'
w
"
)
;
}
else
{
Format
(
instr
"
'
memop
'
cond
'
sign
'
h
'
rd
[
'
rn
#
+
'
off8
]
'
w
"
)
;
}
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
return
;
}
}
else
if
(
(
type
=
=
0
)
&
&
instr
-
>
IsMiscType0
(
)
)
{
if
(
instr
-
>
Bits
(
22
21
)
=
=
1
)
{
switch
(
instr
-
>
BitField
(
7
4
)
)
{
case
BX
:
Format
(
instr
"
bx
'
cond
'
rm
"
)
;
break
;
case
BLX
:
Format
(
instr
"
blx
'
cond
'
rm
"
)
;
break
;
case
BKPT
:
Format
(
instr
"
bkpt
'
off0to3and8to19
"
)
;
break
;
default
:
Unknown
(
instr
)
;
break
;
}
}
else
if
(
instr
-
>
Bits
(
22
21
)
=
=
3
)
{
switch
(
instr
-
>
BitField
(
7
4
)
)
{
case
CLZ
:
Format
(
instr
"
clz
'
cond
'
rd
'
rm
"
)
;
break
;
default
:
Unknown
(
instr
)
;
break
;
}
}
else
{
Unknown
(
instr
)
;
}
}
else
if
(
(
type
=
=
1
)
&
&
instr
-
>
IsNopType1
(
)
)
{
Format
(
instr
"
nop
'
cond
"
)
;
}
else
{
switch
(
instr
-
>
OpcodeField
(
)
)
{
case
AND
:
{
Format
(
instr
"
and
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
EOR
:
{
Format
(
instr
"
eor
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
SUB
:
{
Format
(
instr
"
sub
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
RSB
:
{
Format
(
instr
"
rsb
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
ADD
:
{
Format
(
instr
"
add
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
ADC
:
{
Format
(
instr
"
adc
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
SBC
:
{
Format
(
instr
"
sbc
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
RSC
:
{
Format
(
instr
"
rsc
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
TST
:
{
if
(
instr
-
>
HasS
(
)
)
{
Format
(
instr
"
tst
'
cond
'
rn
'
shift_op
"
)
;
}
else
{
Format
(
instr
"
movw
'
cond
'
mw
"
)
;
}
break
;
}
case
TEQ
:
{
if
(
instr
-
>
HasS
(
)
)
{
Format
(
instr
"
teq
'
cond
'
rn
'
shift_op
"
)
;
}
else
{
MOZ_CRASH
(
)
;
}
break
;
}
case
CMP
:
{
if
(
instr
-
>
HasS
(
)
)
{
Format
(
instr
"
cmp
'
cond
'
rn
'
shift_op
"
)
;
}
else
{
Format
(
instr
"
movt
'
cond
'
mw
"
)
;
}
break
;
}
case
CMN
:
{
if
(
instr
-
>
HasS
(
)
)
{
Format
(
instr
"
cmn
'
cond
'
rn
'
shift_op
"
)
;
}
else
{
MOZ_CRASH
(
)
;
}
break
;
}
case
ORR
:
{
Format
(
instr
"
orr
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
MOV
:
{
Format
(
instr
"
mov
'
cond
'
s
'
rd
'
shift_op
"
)
;
break
;
}
case
BIC
:
{
Format
(
instr
"
bic
'
cond
'
s
'
rd
'
rn
'
shift_op
"
)
;
break
;
}
case
MVN
:
{
Format
(
instr
"
mvn
'
cond
'
s
'
rd
'
shift_op
"
)
;
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
}
}
void
Decoder
:
:
DecodeType2
(
Instruction
*
instr
)
{
switch
(
instr
-
>
PUField
(
)
)
{
case
da_x
:
{
if
(
instr
-
>
HasW
(
)
)
{
Unknown
(
instr
)
;
return
;
}
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
]
#
-
'
off12
"
)
;
break
;
}
case
ia_x
:
{
if
(
instr
-
>
HasW
(
)
)
{
Unknown
(
instr
)
;
return
;
}
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
]
#
+
'
off12
"
)
;
break
;
}
case
db_x
:
{
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
#
-
'
off12
]
'
w
"
)
;
break
;
}
case
ib_x
:
{
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
#
+
'
off12
]
'
w
"
)
;
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
}
void
Decoder
:
:
DecodeType3
(
Instruction
*
instr
)
{
switch
(
instr
-
>
PUField
(
)
)
{
case
da_x
:
{
VERIFY
(
!
instr
-
>
HasW
(
)
)
;
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
]
-
'
shift_rm
"
)
;
break
;
}
case
ia_x
:
{
if
(
instr
-
>
Bit
(
4
)
=
=
0
)
{
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
]
+
'
shift_rm
"
)
;
}
else
{
if
(
instr
-
>
Bit
(
5
)
=
=
0
)
{
switch
(
instr
-
>
Bits
(
22
21
)
)
{
case
0
:
if
(
instr
-
>
Bit
(
20
)
=
=
0
)
{
if
(
instr
-
>
Bit
(
6
)
=
=
0
)
{
Format
(
instr
"
pkhbt
'
cond
'
rd
'
rn
'
rm
lsl
#
'
imm05
07
"
)
;
}
else
{
if
(
instr
-
>
Bits
(
11
7
)
=
=
0
)
{
Format
(
instr
"
pkhtb
'
cond
'
rd
'
rn
'
rm
asr
#
32
"
)
;
}
else
{
Format
(
instr
"
pkhtb
'
cond
'
rd
'
rn
'
rm
asr
#
'
imm05
07
"
)
;
}
}
}
else
{
MOZ_CRASH
(
)
;
}
break
;
case
1
:
MOZ_CRASH
(
)
;
break
;
case
2
:
MOZ_CRASH
(
)
;
break
;
case
3
:
Format
(
instr
"
usat
'
rd
#
'
imm05
16
'
rm
'
shift_sat
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
22
21
)
)
{
case
0
:
MOZ_CRASH
(
)
;
break
;
case
1
:
if
(
instr
-
>
Bits
(
9
6
)
=
=
1
)
{
if
(
instr
-
>
Bit
(
20
)
=
=
0
)
{
if
(
instr
-
>
Bits
(
19
16
)
=
=
0xF
)
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
sxtb
'
cond
'
rd
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
sxtb
'
cond
'
rd
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
sxtb
'
cond
'
rd
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
sxtb
'
cond
'
rd
'
rm
ror
#
24
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
sxtab
'
cond
'
rd
'
rn
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
sxtab
'
cond
'
rd
'
rn
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
sxtab
'
cond
'
rd
'
rn
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
sxtab
'
cond
'
rd
'
rn
'
rm
ror
#
24
"
)
;
break
;
}
}
}
else
{
if
(
instr
-
>
Bits
(
19
16
)
=
=
0xF
)
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
sxth
'
cond
'
rd
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
sxth
'
cond
'
rd
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
sxth
'
cond
'
rd
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
sxth
'
cond
'
rd
'
rm
ror
#
24
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
sxtah
'
cond
'
rd
'
rn
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
sxtah
'
cond
'
rd
'
rn
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
sxtah
'
cond
'
rd
'
rn
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
sxtah
'
cond
'
rd
'
rn
'
rm
ror
#
24
"
)
;
break
;
}
}
}
}
else
{
MOZ_CRASH
(
)
;
}
break
;
case
2
:
if
(
(
instr
-
>
Bit
(
20
)
=
=
0
)
&
&
(
instr
-
>
Bits
(
9
6
)
=
=
1
)
)
{
if
(
instr
-
>
Bits
(
19
16
)
=
=
0xF
)
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
uxtb16
'
cond
'
rd
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
uxtb16
'
cond
'
rd
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
uxtb16
'
cond
'
rd
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
uxtb16
'
cond
'
rd
'
rm
ror
#
24
"
)
;
break
;
}
}
else
{
MOZ_CRASH
(
)
;
}
}
else
{
MOZ_CRASH
(
)
;
}
break
;
case
3
:
if
(
(
instr
-
>
Bits
(
9
6
)
=
=
1
)
)
{
if
(
(
instr
-
>
Bit
(
20
)
=
=
0
)
)
{
if
(
instr
-
>
Bits
(
19
16
)
=
=
0xF
)
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
uxtb
'
cond
'
rd
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
uxtb
'
cond
'
rd
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
uxtb
'
cond
'
rd
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
uxtb
'
cond
'
rd
'
rm
ror
#
24
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
uxtab
'
cond
'
rd
'
rn
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
uxtab
'
cond
'
rd
'
rn
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
uxtab
'
cond
'
rd
'
rn
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
uxtab
'
cond
'
rd
'
rn
'
rm
ror
#
24
"
)
;
break
;
}
}
}
else
{
if
(
instr
-
>
Bits
(
19
16
)
=
=
0xF
)
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
uxth
'
cond
'
rd
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
uxth
'
cond
'
rd
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
uxth
'
cond
'
rd
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
uxth
'
cond
'
rd
'
rm
ror
#
24
"
)
;
break
;
}
}
else
{
switch
(
instr
-
>
Bits
(
11
10
)
)
{
case
0
:
Format
(
instr
"
uxtah
'
cond
'
rd
'
rn
'
rm
"
)
;
break
;
case
1
:
Format
(
instr
"
uxtah
'
cond
'
rd
'
rn
'
rm
ror
#
8
"
)
;
break
;
case
2
:
Format
(
instr
"
uxtah
'
cond
'
rd
'
rn
'
rm
ror
#
16
"
)
;
break
;
case
3
:
Format
(
instr
"
uxtah
'
cond
'
rd
'
rn
'
rm
ror
#
24
"
)
;
break
;
}
}
}
}
else
{
MOZ_CRASH
(
)
;
}
break
;
}
}
}
break
;
}
case
db_x
:
{
if
(
instr
-
>
Bits
(
22
20
)
=
=
0x5
)
{
if
(
instr
-
>
Bits
(
7
4
)
=
=
0x1
)
{
if
(
instr
-
>
Bits
(
15
12
)
=
=
0xF
)
{
Format
(
instr
"
smmul
'
cond
'
rn
'
rm
'
rs
"
)
;
}
else
{
Format
(
instr
"
smmla
'
cond
'
rn
'
rm
'
rs
'
rd
"
)
;
}
break
;
}
}
bool
FLAG_enable_sudiv
=
true
;
if
(
FLAG_enable_sudiv
)
{
if
(
instr
-
>
Bits
(
5
4
)
=
=
0x1
)
{
if
(
(
instr
-
>
Bit
(
22
)
=
=
0x0
)
&
&
(
instr
-
>
Bit
(
20
)
=
=
0x1
)
)
{
if
(
instr
-
>
Bit
(
21
)
=
=
0x1
)
{
Format
(
instr
"
udiv
'
cond
'
b
'
rn
'
rm
'
rs
"
)
;
}
else
{
Format
(
instr
"
sdiv
'
cond
'
b
'
rn
'
rm
'
rs
"
)
;
}
break
;
}
}
}
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
-
'
shift_rm
]
'
w
"
)
;
break
;
}
case
ib_x
:
{
if
(
instr
-
>
HasW
(
)
&
&
(
instr
-
>
Bits
(
6
4
)
=
=
0x5
)
)
{
uint32_t
widthminus1
=
static_cast
<
uint32_t
>
(
instr
-
>
Bits
(
20
16
)
)
;
uint32_t
lsbit
=
static_cast
<
uint32_t
>
(
instr
-
>
Bits
(
11
7
)
)
;
uint32_t
msbit
=
widthminus1
+
lsbit
;
if
(
msbit
<
=
31
)
{
if
(
instr
-
>
Bit
(
22
)
)
{
Format
(
instr
"
ubfx
'
cond
'
rd
'
rm
'
f
"
)
;
}
else
{
Format
(
instr
"
sbfx
'
cond
'
rd
'
rm
'
f
"
)
;
}
}
else
{
MOZ_CRASH
(
)
;
}
}
else
if
(
!
instr
-
>
HasW
(
)
&
&
(
instr
-
>
Bits
(
6
4
)
=
=
0x1
)
)
{
uint32_t
lsbit
=
static_cast
<
uint32_t
>
(
instr
-
>
Bits
(
11
7
)
)
;
uint32_t
msbit
=
static_cast
<
uint32_t
>
(
instr
-
>
Bits
(
20
16
)
)
;
if
(
msbit
>
=
lsbit
)
{
if
(
instr
-
>
RmValue
(
)
=
=
15
)
{
Format
(
instr
"
bfc
'
cond
'
rd
'
f
"
)
;
}
else
{
Format
(
instr
"
bfi
'
cond
'
rd
'
rm
'
f
"
)
;
}
}
else
{
MOZ_CRASH
(
)
;
}
}
else
{
Format
(
instr
"
'
memop
'
cond
'
b
'
rd
[
'
rn
+
'
shift_rm
]
'
w
"
)
;
}
break
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
}
void
Decoder
:
:
DecodeType4
(
Instruction
*
instr
)
{
if
(
instr
-
>
Bit
(
22
)
!
=
0
)
{
Unknown
(
instr
)
;
}
else
{
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
ldm
'
cond
'
pu
'
rn
'
w
'
rlist
"
)
;
}
else
{
Format
(
instr
"
stm
'
cond
'
pu
'
rn
'
w
'
rlist
"
)
;
}
}
}
void
Decoder
:
:
DecodeType5
(
Instruction
*
instr
)
{
Format
(
instr
"
b
'
l
'
cond
'
target
"
)
;
}
void
Decoder
:
:
DecodeType6
(
Instruction
*
instr
)
{
DecodeType6CoprocessorIns
(
instr
)
;
}
int
Decoder
:
:
DecodeType7
(
Instruction
*
instr
)
{
if
(
instr
-
>
Bit
(
24
)
=
=
1
)
{
if
(
instr
-
>
SvcValue
(
)
>
=
kStopCode
)
{
Format
(
instr
"
stop
'
cond
'
svc
"
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
\
n
%
p
%
08x
stop
message
:
%
s
"
reinterpret_cast
<
void
*
>
(
instr
+
Instruction
:
:
kInstrSize
)
*
reinterpret_cast
<
uint32_t
*
>
(
instr
+
Instruction
:
:
kInstrSize
)
*
reinterpret_cast
<
char
*
*
>
(
instr
+
Instruction
:
:
kInstrSize
)
)
;
return
2
*
Instruction
:
:
kInstrSize
;
}
else
{
Format
(
instr
"
svc
'
cond
'
svc
"
)
;
}
}
else
{
DecodeTypeVFP
(
instr
)
;
}
return
Instruction
:
:
kInstrSize
;
}
void
Decoder
:
:
DecodeTypeVFP
(
Instruction
*
instr
)
{
VERIFY
(
(
instr
-
>
TypeValue
(
)
=
=
7
)
&
&
(
instr
-
>
Bit
(
24
)
=
=
0x0
)
)
;
VERIFY
(
instr
-
>
Bits
(
11
9
)
=
=
0x5
)
;
if
(
instr
-
>
Bit
(
4
)
=
=
0
)
{
if
(
instr
-
>
Opc1Value
(
)
=
=
0x7
)
{
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0x0
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vmov
'
cond
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vmov
'
cond
.
f32
'
Sd
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0x0
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x3
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vabs
'
cond
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vabs
'
cond
.
f32
'
Sd
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0x1
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vneg
'
cond
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vneg
'
cond
.
f32
'
Sd
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0x7
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x3
)
)
{
DecodeVCVTBetweenDoubleAndSingle
(
instr
)
;
}
else
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0x8
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
DecodeVCVTBetweenFloatingPointAndInteger
(
instr
)
;
}
else
if
(
(
instr
-
>
Opc2Value
(
)
=
=
0xA
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x3
)
&
&
(
instr
-
>
Bit
(
8
)
=
=
1
)
)
{
int
fraction_bits
=
32
-
(
(
instr
-
>
Bits
(
3
0
)
<
<
1
)
|
instr
-
>
Bit
(
5
)
)
;
Format
(
instr
"
vcvt
'
cond
.
f64
.
s32
'
Dd
'
Dd
"
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
#
%
d
"
fraction_bits
)
;
}
else
if
(
(
(
instr
-
>
Opc2Value
(
)
>
>
1
)
=
=
0x6
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
DecodeVCVTBetweenFloatingPointAndInteger
(
instr
)
;
}
else
if
(
(
(
instr
-
>
Opc2Value
(
)
=
=
0x4
)
|
|
(
instr
-
>
Opc2Value
(
)
=
=
0x5
)
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
DecodeVCMP
(
instr
)
;
}
else
if
(
(
(
instr
-
>
Opc2Value
(
)
=
=
0x1
)
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x3
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vsqrt
'
cond
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vsqrt
'
cond
.
f32
'
Sd
'
Sm
"
)
;
}
}
else
if
(
instr
-
>
Opc3Value
(
)
=
=
0x0
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vmov
'
cond
.
f64
'
Dd
'
d
"
)
;
}
else
{
Unknown
(
instr
)
;
}
}
else
if
(
(
(
instr
-
>
Opc2Value
(
)
=
=
0x6
)
)
&
&
instr
-
>
Opc3Value
(
)
=
=
0x3
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vrintz
'
cond
.
f64
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vrintz
'
cond
.
f32
.
f32
'
Sd
'
Sm
"
)
;
}
}
else
{
Unknown
(
instr
)
;
}
}
else
if
(
instr
-
>
Opc1Value
(
)
=
=
0x3
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
if
(
instr
-
>
Opc3Value
(
)
&
0x1
)
{
Format
(
instr
"
vsub
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vadd
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
}
else
{
if
(
instr
-
>
Opc3Value
(
)
&
0x1
)
{
Format
(
instr
"
vsub
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
else
{
Format
(
instr
"
vadd
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
}
}
else
if
(
(
instr
-
>
Opc1Value
(
)
=
=
0x2
)
&
&
!
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vmul
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vmul
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc1Value
(
)
=
=
0x0
)
&
&
!
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vmla
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vmla
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc1Value
(
)
=
=
0x0
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vmls
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vmls
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
}
else
if
(
(
instr
-
>
Opc1Value
(
)
=
=
0x4
)
&
&
!
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
{
if
(
instr
-
>
SzValue
(
)
=
=
0x1
)
{
Format
(
instr
"
vdiv
'
cond
.
f64
'
Dd
'
Dn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vdiv
'
cond
.
f32
'
Sd
'
Sn
'
Sm
"
)
;
}
}
else
{
Unknown
(
instr
)
;
}
}
else
{
if
(
(
instr
-
>
VCValue
(
)
=
=
0x0
)
&
&
(
instr
-
>
VAValue
(
)
=
=
0x0
)
)
{
DecodeVMOVBetweenCoreAndSinglePrecisionRegisters
(
instr
)
;
}
else
if
(
(
instr
-
>
VLValue
(
)
=
=
0x0
)
&
&
(
instr
-
>
VCValue
(
)
=
=
0x1
)
&
&
(
instr
-
>
Bit
(
23
)
=
=
0x0
)
)
{
if
(
instr
-
>
Bit
(
21
)
=
=
0x0
)
{
Format
(
instr
"
vmov
'
cond
.
32
'
Dd
[
0
]
'
rt
"
)
;
}
else
{
Format
(
instr
"
vmov
'
cond
.
32
'
Dd
[
1
]
'
rt
"
)
;
}
}
else
if
(
(
instr
-
>
VLValue
(
)
=
=
0x1
)
&
&
(
instr
-
>
VCValue
(
)
=
=
0x1
)
&
&
(
instr
-
>
Bit
(
23
)
=
=
0x0
)
)
{
if
(
instr
-
>
Bit
(
21
)
=
=
0x0
)
{
Format
(
instr
"
vmov
'
cond
.
32
'
rt
'
Dd
[
0
]
"
)
;
}
else
{
Format
(
instr
"
vmov
'
cond
.
32
'
rt
'
Dd
[
1
]
"
)
;
}
}
else
if
(
(
instr
-
>
VCValue
(
)
=
=
0x0
)
&
&
(
instr
-
>
VAValue
(
)
=
=
0x7
)
&
&
(
instr
-
>
Bits
(
19
16
)
=
=
0x1
)
)
{
if
(
instr
-
>
VLValue
(
)
=
=
0
)
{
if
(
instr
-
>
Bits
(
15
12
)
=
=
0xF
)
{
Format
(
instr
"
vmsr
'
cond
FPSCR
APSR
"
)
;
}
else
{
Format
(
instr
"
vmsr
'
cond
FPSCR
'
rt
"
)
;
}
}
else
{
if
(
instr
-
>
Bits
(
15
12
)
=
=
0xF
)
{
Format
(
instr
"
vmrs
'
cond
APSR
FPSCR
"
)
;
}
else
{
Format
(
instr
"
vmrs
'
cond
'
rt
FPSCR
"
)
;
}
}
}
}
}
void
Decoder
:
:
DecodeVMOVBetweenCoreAndSinglePrecisionRegisters
(
Instruction
*
instr
)
{
VERIFY
(
(
instr
-
>
Bit
(
4
)
=
=
1
)
&
&
(
instr
-
>
VCValue
(
)
=
=
0x0
)
&
&
(
instr
-
>
VAValue
(
)
=
=
0x0
)
)
;
bool
to_arm_register
=
(
instr
-
>
VLValue
(
)
=
=
0x1
)
;
if
(
to_arm_register
)
{
Format
(
instr
"
vmov
'
cond
'
rt
'
Sn
"
)
;
}
else
{
Format
(
instr
"
vmov
'
cond
'
Sn
'
rt
"
)
;
}
}
void
Decoder
:
:
DecodeVCMP
(
Instruction
*
instr
)
{
VERIFY
(
(
instr
-
>
Bit
(
4
)
=
=
0
)
&
&
(
instr
-
>
Opc1Value
(
)
=
=
0x7
)
)
;
VERIFY
(
(
(
instr
-
>
Opc2Value
(
)
=
=
0x4
)
|
|
(
instr
-
>
Opc2Value
(
)
=
=
0x5
)
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
;
bool
dp_operation
=
(
instr
-
>
SzValue
(
)
=
=
1
)
;
bool
raise_exception_for_qnan
=
(
instr
-
>
Bit
(
7
)
=
=
0x1
)
;
if
(
dp_operation
&
&
!
raise_exception_for_qnan
)
{
if
(
instr
-
>
Opc2Value
(
)
=
=
0x4
)
{
Format
(
instr
"
vcmp
'
cond
.
f64
'
Dd
'
Dm
"
)
;
}
else
if
(
instr
-
>
Opc2Value
(
)
=
=
0x5
)
{
Format
(
instr
"
vcmp
'
cond
.
f64
'
Dd
#
0
.
0
"
)
;
}
else
{
Unknown
(
instr
)
;
}
}
else
if
(
!
raise_exception_for_qnan
)
{
if
(
instr
-
>
Opc2Value
(
)
=
=
0x4
)
{
Format
(
instr
"
vcmp
'
cond
.
f32
'
Sd
'
Sm
"
)
;
}
else
if
(
instr
-
>
Opc2Value
(
)
=
=
0x5
)
{
Format
(
instr
"
vcmp
'
cond
.
f32
'
Sd
#
0
.
0
"
)
;
}
else
{
Unknown
(
instr
)
;
}
}
else
{
Unknown
(
instr
)
;
}
}
void
Decoder
:
:
DecodeVCVTBetweenDoubleAndSingle
(
Instruction
*
instr
)
{
VERIFY
(
(
instr
-
>
Bit
(
4
)
=
=
0
)
&
&
(
instr
-
>
Opc1Value
(
)
=
=
0x7
)
)
;
VERIFY
(
(
instr
-
>
Opc2Value
(
)
=
=
0x7
)
&
&
(
instr
-
>
Opc3Value
(
)
=
=
0x3
)
)
;
bool
double_to_single
=
(
instr
-
>
SzValue
(
)
=
=
1
)
;
if
(
double_to_single
)
{
Format
(
instr
"
vcvt
'
cond
.
f32
.
f64
'
Sd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vcvt
'
cond
.
f64
.
f32
'
Dd
'
Sm
"
)
;
}
}
void
Decoder
:
:
DecodeVCVTBetweenFloatingPointAndInteger
(
Instruction
*
instr
)
{
VERIFY
(
(
instr
-
>
Bit
(
4
)
=
=
0
)
&
&
(
instr
-
>
Opc1Value
(
)
=
=
0x7
)
)
;
VERIFY
(
(
(
instr
-
>
Opc2Value
(
)
=
=
0x8
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
|
|
(
(
(
instr
-
>
Opc2Value
(
)
>
>
1
)
=
=
0x6
)
&
&
(
instr
-
>
Opc3Value
(
)
&
0x1
)
)
)
;
bool
to_integer
=
(
instr
-
>
Bit
(
18
)
=
=
1
)
;
bool
dp_operation
=
(
instr
-
>
SzValue
(
)
=
=
1
)
;
if
(
to_integer
)
{
bool
unsigned_integer
=
(
instr
-
>
Bit
(
16
)
=
=
0
)
;
if
(
dp_operation
)
{
if
(
unsigned_integer
)
{
Format
(
instr
"
vcvt
'
cond
.
u32
.
f64
'
Sd
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vcvt
'
cond
.
s32
.
f64
'
Sd
'
Dm
"
)
;
}
}
else
{
if
(
unsigned_integer
)
{
Format
(
instr
"
vcvt
'
cond
.
u32
.
f32
'
Sd
'
Sm
"
)
;
}
else
{
Format
(
instr
"
vcvt
'
cond
.
s32
.
f32
'
Sd
'
Sm
"
)
;
}
}
}
else
{
bool
unsigned_integer
=
(
instr
-
>
Bit
(
7
)
=
=
0
)
;
if
(
dp_operation
)
{
if
(
unsigned_integer
)
{
Format
(
instr
"
vcvt
'
cond
.
f64
.
u32
'
Dd
'
Sm
"
)
;
}
else
{
Format
(
instr
"
vcvt
'
cond
.
f64
.
s32
'
Dd
'
Sm
"
)
;
}
}
else
{
if
(
unsigned_integer
)
{
Format
(
instr
"
vcvt
'
cond
.
f32
.
u32
'
Sd
'
Sm
"
)
;
}
else
{
Format
(
instr
"
vcvt
'
cond
.
f32
.
s32
'
Sd
'
Sm
"
)
;
}
}
}
}
void
Decoder
:
:
DecodeType6CoprocessorIns
(
Instruction
*
instr
)
{
VERIFY
(
instr
-
>
TypeValue
(
)
=
=
6
)
;
if
(
instr
-
>
CoprocessorValue
(
)
=
=
0xA
)
{
switch
(
instr
-
>
OpcodeValue
(
)
)
{
case
0x8
:
case
0xA
:
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
vldr
'
cond
'
Sd
[
'
rn
-
4
*
'
imm08
00
]
"
)
;
}
else
{
Format
(
instr
"
vstr
'
cond
'
Sd
[
'
rn
-
4
*
'
imm08
00
]
"
)
;
}
break
;
case
0xC
:
case
0xE
:
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
vldr
'
cond
'
Sd
[
'
rn
+
4
*
'
imm08
00
]
"
)
;
}
else
{
Format
(
instr
"
vstr
'
cond
'
Sd
[
'
rn
+
4
*
'
imm08
00
]
"
)
;
}
break
;
case
0x4
:
case
0x5
:
case
0x6
:
case
0x7
:
case
0x9
:
case
0xB
:
{
bool
to_vfp_register
=
(
instr
-
>
VLValue
(
)
=
=
0x1
)
;
if
(
to_vfp_register
)
{
Format
(
instr
"
vldm
'
cond
'
pu
'
rn
'
w
{
'
Sd
-
'
Sd
+
}
"
)
;
}
else
{
Format
(
instr
"
vstm
'
cond
'
pu
'
rn
'
w
{
'
Sd
-
'
Sd
+
}
"
)
;
}
break
;
}
default
:
Unknown
(
instr
)
;
}
}
else
if
(
instr
-
>
CoprocessorValue
(
)
=
=
0xB
)
{
switch
(
instr
-
>
OpcodeValue
(
)
)
{
case
0x2
:
if
(
instr
-
>
Bits
(
7
6
)
!
=
0
|
|
instr
-
>
Bit
(
4
)
!
=
1
)
{
Unknown
(
instr
)
;
}
else
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
vmov
'
cond
'
rt
'
rn
'
Dm
"
)
;
}
else
{
Format
(
instr
"
vmov
'
cond
'
Dm
'
rt
'
rn
"
)
;
}
break
;
case
0x8
:
case
0xA
:
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
vldr
'
cond
'
Dd
[
'
rn
-
4
*
'
imm08
00
]
"
)
;
}
else
{
Format
(
instr
"
vstr
'
cond
'
Dd
[
'
rn
-
4
*
'
imm08
00
]
"
)
;
}
break
;
case
0xC
:
case
0xE
:
if
(
instr
-
>
HasL
(
)
)
{
Format
(
instr
"
vldr
'
cond
'
Dd
[
'
rn
+
4
*
'
imm08
00
]
"
)
;
}
else
{
Format
(
instr
"
vstr
'
cond
'
Dd
[
'
rn
+
4
*
'
imm08
00
]
"
)
;
}
break
;
case
0x4
:
case
0x5
:
case
0x6
:
case
0x7
:
case
0x9
:
case
0xB
:
{
bool
to_vfp_register
=
(
instr
-
>
VLValue
(
)
=
=
0x1
)
;
if
(
to_vfp_register
)
{
Format
(
instr
"
vldm
'
cond
'
pu
'
rn
'
w
{
'
Dd
-
'
Dd
+
}
"
)
;
}
else
{
Format
(
instr
"
vstm
'
cond
'
pu
'
rn
'
w
{
'
Dd
-
'
Dd
+
}
"
)
;
}
break
;
}
default
:
Unknown
(
instr
)
;
}
}
else
{
Unknown
(
instr
)
;
}
}
void
Decoder
:
:
DecodeSpecialCondition
(
Instruction
*
instr
)
{
switch
(
instr
-
>
SpecialValue
(
)
)
{
case
5
:
if
(
(
instr
-
>
Bits
(
18
16
)
=
=
0
)
&
&
(
instr
-
>
Bits
(
11
6
)
=
=
0x28
)
&
&
(
instr
-
>
Bit
(
4
)
=
=
1
)
)
{
if
(
(
instr
-
>
VdValue
(
)
&
1
)
!
=
0
)
Unknown
(
instr
)
;
int
Vd
=
(
instr
-
>
Bit
(
22
)
<
<
3
)
|
(
instr
-
>
VdValue
(
)
>
>
1
)
;
int
Vm
=
(
instr
-
>
Bit
(
5
)
<
<
4
)
|
instr
-
>
VmValue
(
)
;
int
imm3
=
instr
-
>
Bits
(
21
19
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
vmovl
.
s
%
d
q
%
d
d
%
d
"
imm3
*
8
Vd
Vm
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
7
:
if
(
(
instr
-
>
Bits
(
18
16
)
=
=
0
)
&
&
(
instr
-
>
Bits
(
11
6
)
=
=
0x28
)
&
&
(
instr
-
>
Bit
(
4
)
=
=
1
)
)
{
if
(
(
instr
-
>
VdValue
(
)
&
1
)
!
=
0
)
Unknown
(
instr
)
;
int
Vd
=
(
instr
-
>
Bit
(
22
)
<
<
3
)
|
(
instr
-
>
VdValue
(
)
>
>
1
)
;
int
Vm
=
(
instr
-
>
Bit
(
5
)
<
<
4
)
|
instr
-
>
VmValue
(
)
;
int
imm3
=
instr
-
>
Bits
(
21
19
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
vmovl
.
u
%
d
q
%
d
d
%
d
"
imm3
*
8
Vd
Vm
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
8
:
if
(
instr
-
>
Bits
(
21
20
)
=
=
0
)
{
int
Vd
=
(
instr
-
>
Bit
(
22
)
<
<
4
)
|
instr
-
>
VdValue
(
)
;
int
Rn
=
instr
-
>
VnValue
(
)
;
int
type
=
instr
-
>
Bits
(
11
8
)
;
int
size
=
instr
-
>
Bits
(
7
6
)
;
int
align
=
instr
-
>
Bits
(
5
4
)
;
int
Rm
=
instr
-
>
VmValue
(
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
vst1
.
%
d
"
(
1
<
<
size
)
<
<
3
)
;
FormatNeonList
(
Vd
type
)
;
Print
(
"
"
)
;
FormatNeonMemory
(
Rn
align
Rm
)
;
}
else
if
(
instr
-
>
Bits
(
21
20
)
=
=
2
)
{
int
Vd
=
(
instr
-
>
Bit
(
22
)
<
<
4
)
|
instr
-
>
VdValue
(
)
;
int
Rn
=
instr
-
>
VnValue
(
)
;
int
type
=
instr
-
>
Bits
(
11
8
)
;
int
size
=
instr
-
>
Bits
(
7
6
)
;
int
align
=
instr
-
>
Bits
(
5
4
)
;
int
Rm
=
instr
-
>
VmValue
(
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
vld1
.
%
d
"
(
1
<
<
size
)
<
<
3
)
;
FormatNeonList
(
Vd
type
)
;
Print
(
"
"
)
;
FormatNeonMemory
(
Rn
align
Rm
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
0xA
:
if
(
instr
-
>
Bits
(
22
20
)
=
=
7
)
{
const
char
*
option
=
"
?
"
;
switch
(
instr
-
>
Bits
(
3
0
)
)
{
case
2
:
option
=
"
oshst
"
;
break
;
case
3
:
option
=
"
osh
"
;
break
;
case
6
:
option
=
"
nshst
"
;
break
;
case
7
:
option
=
"
nsh
"
;
break
;
case
10
:
option
=
"
ishst
"
;
break
;
case
11
:
option
=
"
ish
"
;
break
;
case
14
:
option
=
"
st
"
;
break
;
case
15
:
option
=
"
sy
"
;
break
;
}
switch
(
instr
-
>
Bits
(
7
4
)
)
{
case
4
:
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
dsb
%
s
"
option
)
;
break
;
case
5
:
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
dmb
%
s
"
option
)
;
break
;
default
:
Unknown
(
instr
)
;
}
break
;
}
MOZ_FALLTHROUGH
;
case
0xB
:
if
(
(
instr
-
>
Bits
(
22
20
)
=
=
5
)
&
&
(
instr
-
>
Bits
(
15
12
)
=
=
0xf
)
)
{
int
Rn
=
instr
-
>
Bits
(
19
16
)
;
int
offset
=
instr
-
>
Bits
(
11
0
)
;
if
(
offset
=
=
0
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
pld
[
r
%
d
]
"
Rn
)
;
}
else
if
(
instr
-
>
Bit
(
23
)
=
=
0
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
pld
[
r
%
d
#
-
%
d
]
"
Rn
offset
)
;
}
else
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
pld
[
r
%
d
#
+
%
d
]
"
Rn
offset
)
;
}
}
else
{
Unknown
(
instr
)
;
}
break
;
case
0x1D
:
if
(
instr
-
>
Opc1Value
(
)
=
=
0x7
&
&
instr
-
>
Bits
(
19
18
)
=
=
0x2
&
&
instr
-
>
Bits
(
11
9
)
=
=
0x5
&
&
instr
-
>
Bits
(
7
6
)
=
=
0x1
&
&
instr
-
>
Bit
(
4
)
=
=
0x0
)
{
bool
dp_operation
=
(
instr
-
>
SzValue
(
)
=
=
1
)
;
int
rounding_mode
=
instr
-
>
Bits
(
17
16
)
;
switch
(
rounding_mode
)
{
case
0x0
:
if
(
dp_operation
)
{
Format
(
instr
"
vrinta
.
f64
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
0x1
:
if
(
dp_operation
)
{
Format
(
instr
"
vrintn
.
f64
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
0x2
:
if
(
dp_operation
)
{
Format
(
instr
"
vrintp
.
f64
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
case
0x3
:
if
(
dp_operation
)
{
Format
(
instr
"
vrintm
.
f64
.
f64
'
Dd
'
Dm
"
)
;
}
else
{
Unknown
(
instr
)
;
}
break
;
default
:
MOZ_CRASH
(
)
;
break
;
}
}
else
{
Unknown
(
instr
)
;
}
break
;
default
:
Unknown
(
instr
)
;
break
;
}
}
#
undef
VERIFIY
bool
Decoder
:
:
IsConstantPoolAt
(
uint8_t
*
instr_ptr
)
{
int
instruction_bits
=
*
(
reinterpret_cast
<
int
*
>
(
instr_ptr
)
)
;
return
(
instruction_bits
&
kConstantPoolMarkerMask
)
=
=
kConstantPoolMarker
;
}
int
Decoder
:
:
ConstantPoolSizeAt
(
uint8_t
*
instr_ptr
)
{
if
(
IsConstantPoolAt
(
instr_ptr
)
)
{
int
instruction_bits
=
*
(
reinterpret_cast
<
int
*
>
(
instr_ptr
)
)
;
return
DecodeConstantPoolLength
(
instruction_bits
)
;
}
else
{
return
-
1
;
}
}
int
Decoder
:
:
InstructionDecode
(
uint8_t
*
instr_ptr
)
{
Instruction
*
instr
=
Instruction
:
:
At
(
instr_ptr
)
;
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
%
08x
"
instr
-
>
InstructionBits
(
)
)
;
if
(
instr
-
>
ConditionField
(
)
=
=
kSpecialCondition
)
{
DecodeSpecialCondition
(
instr
)
;
return
Instruction
:
:
kInstrSize
;
}
int
instruction_bits
=
*
(
reinterpret_cast
<
int
*
>
(
instr_ptr
)
)
;
if
(
(
instruction_bits
&
kConstantPoolMarkerMask
)
=
=
kConstantPoolMarker
)
{
out_buffer_pos_
+
=
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
constant
pool
begin
(
length
%
d
)
"
DecodeConstantPoolLength
(
instruction_bits
)
)
;
return
Instruction
:
:
kInstrSize
;
}
else
if
(
instruction_bits
=
=
kCodeAgeJumpInstruction
)
{
Instruction
*
target
=
Instruction
:
:
At
(
instr_ptr
+
Instruction
:
:
kInstrSize
)
;
DecodeType2
(
instr
)
;
SNPrintF
(
out_buffer_
+
out_buffer_pos_
"
(
0x
%
08x
)
"
target
-
>
InstructionBits
(
)
)
;
return
2
*
Instruction
:
:
kInstrSize
;
}
switch
(
instr
-
>
TypeValue
(
)
)
{
case
0
:
case
1
:
{
DecodeType01
(
instr
)
;
break
;
}
case
2
:
{
DecodeType2
(
instr
)
;
break
;
}
case
3
:
{
DecodeType3
(
instr
)
;
break
;
}
case
4
:
{
DecodeType4
(
instr
)
;
break
;
}
case
5
:
{
DecodeType5
(
instr
)
;
break
;
}
case
6
:
{
DecodeType6
(
instr
)
;
break
;
}
case
7
:
{
return
DecodeType7
(
instr
)
;
}
default
:
{
MOZ_CRASH
(
)
;
break
;
}
}
return
Instruction
:
:
kInstrSize
;
}
}
#
undef
STRING_STARTS_WITH
#
undef
VERIFY
namespace
disasm
{
const
char
*
NameConverter
:
:
NameOfAddress
(
uint8_t
*
addr
)
const
{
SNPrintF
(
tmp_buffer_
"
%
p
"
addr
)
;
return
tmp_buffer_
.
start
(
)
;
}
const
char
*
NameConverter
:
:
NameOfConstant
(
uint8_t
*
addr
)
const
{
return
NameOfAddress
(
addr
)
;
}
const
char
*
NameConverter
:
:
NameOfCPURegister
(
int
reg
)
const
{
return
disasm
:
:
Registers
:
:
Name
(
reg
)
;
}
const
char
*
NameConverter
:
:
NameOfByteCPURegister
(
int
reg
)
const
{
MOZ_CRASH
(
)
;
return
"
nobytereg
"
;
}
const
char
*
NameConverter
:
:
NameOfXMMRegister
(
int
reg
)
const
{
MOZ_CRASH
(
)
;
return
"
noxmmreg
"
;
}
const
char
*
NameConverter
:
:
NameInCode
(
uint8_t
*
addr
)
const
{
return
"
"
;
}
Disassembler
:
:
Disassembler
(
const
NameConverter
&
converter
)
:
converter_
(
converter
)
{
}
Disassembler
:
:
~
Disassembler
(
)
{
}
int
Disassembler
:
:
InstructionDecode
(
V8Vector
<
char
>
buffer
uint8_t
*
instruction
)
{
Decoder
d
(
converter_
buffer
)
;
return
d
.
InstructionDecode
(
instruction
)
;
}
int
Disassembler
:
:
ConstantPoolSizeAt
(
uint8_t
*
instruction
)
{
return
Decoder
:
:
ConstantPoolSizeAt
(
instruction
)
;
}
void
Disassembler
:
:
Disassemble
(
FILE
*
f
uint8_t
*
begin
uint8_t
*
end
)
{
NameConverter
converter
;
Disassembler
d
(
converter
)
;
for
(
uint8_t
*
pc
=
begin
;
pc
<
end
;
)
{
EmbeddedVector
<
char
ReasonableBufferSize
>
buffer
;
buffer
[
0
]
=
'
\
0
'
;
uint8_t
*
prev_pc
=
pc
;
pc
+
=
d
.
InstructionDecode
(
buffer
pc
)
;
fprintf
(
f
"
%
p
%
08x
%
s
\
n
"
prev_pc
*
reinterpret_cast
<
int32_t
*
>
(
prev_pc
)
buffer
.
start
(
)
)
;
}
}
}
}
}
#
endif
