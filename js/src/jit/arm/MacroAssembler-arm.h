#
ifndef
jit_arm_MacroAssembler_arm_h
#
define
jit_arm_MacroAssembler_arm_h
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
jit
/
arm
/
Assembler
-
arm
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
MoveResolver
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
namespace
js
{
namespace
jit
{
static
Register
CallReg
=
ip
;
static
const
int
defaultShift
=
3
;
JS_STATIC_ASSERT
(
1
<
<
defaultShift
=
=
sizeof
(
JS
:
:
Value
)
)
;
class
ScratchTagScope
{
const
ValueOperand
&
v_
;
public
:
ScratchTagScope
(
MacroAssembler
&
const
ValueOperand
&
v
)
:
v_
(
v
)
{
}
operator
Register
(
)
{
return
v_
.
typeReg
(
)
;
}
void
release
(
)
{
}
void
reacquire
(
)
{
}
}
;
class
ScratchTagScopeRelease
{
public
:
explicit
ScratchTagScopeRelease
(
ScratchTagScope
*
)
{
}
}
;
class
MacroAssemblerARM
:
public
Assembler
{
private
:
MacroAssembler
&
asMasm
(
)
;
const
MacroAssembler
&
asMasm
(
)
const
;
protected
:
Register
secondScratchReg_
;
public
:
Register
getSecondScratchReg
(
)
const
{
return
secondScratchReg_
;
}
public
:
Operand
ToPayload
(
Operand
base
)
const
{
return
Operand
(
Register
:
:
FromCode
(
base
.
base
(
)
)
base
.
disp
(
)
)
;
}
Address
ToPayload
(
const
Address
&
base
)
const
{
return
base
;
}
protected
:
Operand
ToType
(
Operand
base
)
const
{
return
Operand
(
Register
:
:
FromCode
(
base
.
base
(
)
)
base
.
disp
(
)
+
sizeof
(
void
*
)
)
;
}
Address
ToType
(
const
Address
&
base
)
const
{
return
ToType
(
Operand
(
base
)
)
.
toAddress
(
)
;
}
Address
ToPayloadAfterStackPush
(
const
Address
&
base
)
const
{
if
(
base
.
base
=
=
StackPointer
)
{
return
Address
(
base
.
base
base
.
offset
+
sizeof
(
void
*
)
)
;
}
return
ToPayload
(
base
)
;
}
public
:
MacroAssemblerARM
(
)
:
secondScratchReg_
(
lr
)
{
}
void
setSecondScratchReg
(
Register
reg
)
{
MOZ_ASSERT
(
reg
!
=
ScratchRegister
)
;
secondScratchReg_
=
reg
;
}
void
convertBoolToInt32
(
Register
source
Register
dest
)
;
void
convertInt32ToDouble
(
Register
src
FloatRegister
dest
)
;
void
convertInt32ToDouble
(
const
Address
&
src
FloatRegister
dest
)
;
void
convertInt32ToDouble
(
const
BaseIndex
&
src
FloatRegister
dest
)
;
void
convertUInt32ToFloat32
(
Register
src
FloatRegister
dest
)
;
void
convertUInt32ToDouble
(
Register
src
FloatRegister
dest
)
;
void
convertDoubleToFloat32
(
FloatRegister
src
FloatRegister
dest
Condition
c
=
Always
)
;
void
convertDoubleToInt32
(
FloatRegister
src
Register
dest
Label
*
fail
bool
negativeZeroCheck
=
true
)
;
void
convertFloat32ToInt32
(
FloatRegister
src
Register
dest
Label
*
fail
bool
negativeZeroCheck
=
true
)
;
void
convertFloat32ToDouble
(
FloatRegister
src
FloatRegister
dest
)
;
void
convertInt32ToFloat32
(
Register
src
FloatRegister
dest
)
;
void
convertInt32ToFloat32
(
const
Address
&
src
FloatRegister
dest
)
;
void
wasmTruncateToInt32
(
FloatRegister
input
Register
output
MIRType
fromType
bool
isUnsigned
bool
isSaturating
Label
*
oolEntry
)
;
void
outOfLineWasmTruncateToIntCheck
(
FloatRegister
input
MIRType
fromType
MIRType
toType
TruncFlags
flags
Label
*
rejoin
wasm
:
:
BytecodeOffset
trapOffset
)
;
private
:
bool
alu_dbl
(
Register
src1
Imm32
imm
Register
dest
ALUOp
op
SBit
s
Condition
c
)
;
public
:
void
ma_alu
(
Register
src1
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
ALUOp
op
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_alu
(
Register
src1
Operand2
op2
Register
dest
ALUOp
op
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_alu
(
Register
src1
Operand
op2
Register
dest
ALUOp
op
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_nop
(
)
;
BufferOffset
ma_movPatchable
(
Imm32
imm
Register
dest
Assembler
:
:
Condition
c
)
;
BufferOffset
ma_movPatchable
(
ImmPtr
imm
Register
dest
Assembler
:
:
Condition
c
)
;
template
<
class
Iter
>
static
void
ma_mov_patch
(
Imm32
imm
Register
dest
Assembler
:
:
Condition
c
RelocStyle
rs
Iter
iter
)
;
void
ma_mov
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_mov
(
Imm32
imm
Register
dest
Condition
c
=
Always
)
;
void
ma_mov
(
ImmWord
imm
Register
dest
Condition
c
=
Always
)
;
void
ma_mov
(
ImmGCPtr
ptr
Register
dest
)
;
void
ma_lsl
(
Imm32
shift
Register
src
Register
dst
)
;
void
ma_lsr
(
Imm32
shift
Register
src
Register
dst
)
;
void
ma_asr
(
Imm32
shift
Register
src
Register
dst
)
;
void
ma_ror
(
Imm32
shift
Register
src
Register
dst
)
;
void
ma_rol
(
Imm32
shift
Register
src
Register
dst
)
;
void
ma_lsl
(
Register
shift
Register
src
Register
dst
)
;
void
ma_lsr
(
Register
shift
Register
src
Register
dst
)
;
void
ma_asr
(
Register
shift
Register
src
Register
dst
)
;
void
ma_ror
(
Register
shift
Register
src
Register
dst
)
;
void
ma_rol
(
Register
shift
Register
src
Register
dst
AutoRegisterScope
&
scratch
)
;
void
ma_mvn
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_neg
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_and
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_and
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_and
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_and
(
Imm32
imm
Register
src1
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_bic
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_eor
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_eor
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_eor
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_eor
(
Imm32
imm
Register
src1
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_orr
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_orr
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_orr
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_orr
(
Imm32
imm
Register
src1
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_adc
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_adc
(
Register
src
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_adc
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_add
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_add
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_add
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_add
(
Register
src1
Operand
op
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_add
(
Register
src1
Imm32
op
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sbc
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sbc
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sbc
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sub
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sub
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sub
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sub
(
Register
src1
Operand
op
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_sub
(
Register
src1
Imm32
op
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsb
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsb
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsb
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsb
(
Register
src1
Imm32
op2
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsc
(
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsc
(
Register
src1
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_rsc
(
Register
src1
Register
src2
Register
dest
SBit
s
=
LeaveCC
Condition
c
=
Always
)
;
void
ma_cmn
(
Register
src1
Imm32
imm
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_cmn
(
Register
src1
Register
src2
Condition
c
=
Always
)
;
void
ma_cmn
(
Register
src1
Operand
op
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
Imm32
imm
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
ImmTag
tag
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
ImmWord
ptr
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
ImmGCPtr
ptr
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
Operand
op
AutoRegisterScope
&
scratch
AutoRegisterScope
&
scratch2
Condition
c
=
Always
)
;
void
ma_cmp
(
Register
src1
Register
src2
Condition
c
=
Always
)
;
void
ma_teq
(
Register
src1
Imm32
imm
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_teq
(
Register
src1
Register
src2
Condition
c
=
Always
)
;
void
ma_teq
(
Register
src1
Operand
op
Condition
c
=
Always
)
;
void
ma_tst
(
Register
src1
Imm32
imm
AutoRegisterScope
&
scratch
Condition
c
=
Always
)
;
void
ma_tst
(
Register
src1
Register
src2
Condition
c
=
Always
)
;
void
ma_tst
(
Register
src1
Operand
op
Condition
c
=
Always
)
;
void
ma_mul
(
Register
src1
Register
src2
Register
dest
)
;
void
ma_mul
(
Register
src1
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
)
;
Condition
ma_check_mul
(
Register
src1
Register
src2
Register
dest
AutoRegisterScope
&
scratch
Condition
cond
)
;
Condition
ma_check_mul
(
Register
src1
Imm32
imm
Register
dest
AutoRegisterScope
&
scratch
Condition
cond
)
;
void
ma_umull
(
Register
src1
Imm32
imm
Register
destHigh
Register
destLow
AutoRegisterScope
&
scratch
)
;
void
ma_umull
(
Register
src1
Register
src2
Register
destHigh
Register
destLow
)
;
void
ma_mod_mask
(
Register
src
Register
dest
Register
hold
Register
tmp
AutoRegisterScope
&
scratch
AutoRegisterScope
&
scratch2
int32_t
shift
)
;
void
ma_smod
(
Register
num
Register
div
Register
dest
AutoRegisterScope
&
scratch
)
;
void
ma_umod
(
Register
num
Register
div
Register
dest
AutoRegisterScope
&
scratch
)
;
void
ma_sdiv
(
Register
num
Register
div
Register
dest
Condition
cond
=
Always
)
;
void
ma_udiv
(
Register
num
Register
div
Register
dest
Condition
cond
=
Always
)
;
void
ma_clz
(
Register
src
Register
dest
Condition
cond
=
Always
)
;
void
ma_ctz
(
Register
src
Register
dest
AutoRegisterScope
&
scratch
)
;
void
ma_dtr
(
LoadStore
ls
Register
rn
Imm32
offset
Register
rt
AutoRegisterScope
&
scratch
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_dtr
(
LoadStore
ls
Register
rt
const
Address
&
addr
AutoRegisterScope
&
scratch
Index
mode
Condition
cc
)
;
void
ma_str
(
Register
rt
DTRAddr
addr
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_str
(
Register
rt
const
Address
&
addr
AutoRegisterScope
&
scratch
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldr
(
DTRAddr
addr
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldr
(
const
Address
&
addr
Register
rt
AutoRegisterScope
&
scratch
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldrb
(
DTRAddr
addr
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldrh
(
EDtrAddr
addr
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldrsh
(
EDtrAddr
addr
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldrsb
(
EDtrAddr
addr
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_ldrd
(
EDtrAddr
addr
Register
rt
mozilla
:
:
DebugOnly
<
Register
>
rt2
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_strb
(
Register
rt
DTRAddr
addr
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_strh
(
Register
rt
EDtrAddr
addr
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_strd
(
Register
rt
mozilla
:
:
DebugOnly
<
Register
>
rt2
EDtrAddr
addr
Index
mode
=
Offset
Condition
cc
=
Always
)
;
BufferOffset
ma_dataTransferN
(
LoadStore
ls
int
size
bool
IsSigned
Register
rn
Register
rm
Register
rt
AutoRegisterScope
&
scratch
Index
mode
=
Offset
Condition
cc
=
Always
Scale
scale
=
TimesOne
)
;
BufferOffset
ma_dataTransferN
(
LoadStore
ls
int
size
bool
IsSigned
Register
rn
Register
rm
Register
rt
Index
mode
=
Offset
Condition
cc
=
Always
)
;
BufferOffset
ma_dataTransferN
(
LoadStore
ls
int
size
bool
IsSigned
Register
rn
Imm32
offset
Register
rt
AutoRegisterScope
&
scratch
Index
mode
=
Offset
Condition
cc
=
Always
)
;
void
ma_pop
(
Register
r
)
;
void
ma_popn_pc
(
Imm32
n
AutoRegisterScope
&
scratch
AutoRegisterScope
&
scratch2
)
;
void
ma_push
(
Register
r
)
;
void
ma_push_sp
(
Register
r
AutoRegisterScope
&
scratch
)
;
void
ma_vpop
(
VFPRegister
r
)
;
void
ma_vpush
(
VFPRegister
r
)
;
void
ma_dmb
(
BarrierOption
option
=
BarrierSY
)
;
void
ma_dsb
(
BarrierOption
option
=
BarrierSY
)
;
BufferOffset
ma_b
(
Label
*
dest
Condition
c
=
Always
)
;
void
ma_b
(
void
*
target
Condition
c
=
Always
)
;
void
ma_bx
(
Register
dest
Condition
c
=
Always
)
;
void
ma_bl
(
Label
*
dest
Condition
c
=
Always
)
;
void
ma_blx
(
Register
dest
Condition
c
=
Always
)
;
void
ma_vadd
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vsub
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vmul
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vdiv
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vneg
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vmov
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vmov_f32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vabs
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vabs_f32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vsqrt
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vsqrt_f32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vimm
(
double
value
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vimm_f32
(
float
value
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcmp
(
FloatRegister
src1
FloatRegister
src2
Condition
cc
=
Always
)
;
void
ma_vcmp_f32
(
FloatRegister
src1
FloatRegister
src2
Condition
cc
=
Always
)
;
void
ma_vcmpz
(
FloatRegister
src1
Condition
cc
=
Always
)
;
void
ma_vcmpz_f32
(
FloatRegister
src1
Condition
cc
=
Always
)
;
void
ma_vadd_f32
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vsub_f32
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vmul_f32
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vdiv_f32
(
FloatRegister
src1
FloatRegister
src2
FloatRegister
dst
)
;
void
ma_vneg_f32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_F64_I32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_F64_U32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_I32_F64
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_U32_F64
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_F32_I32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_F32_U32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_I32_F32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vcvt_U32_F32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vxfer
(
VFPRegister
src
Register
dest
Condition
cc
=
Always
)
;
void
ma_vxfer
(
VFPRegister
src
Register
dest1
Register
dest2
Condition
cc
=
Always
)
;
void
ma_vxfer
(
Register
src
FloatRegister
dest
Condition
cc
=
Always
)
;
void
ma_vxfer
(
Register
src1
Register
src2
FloatRegister
dest
Condition
cc
=
Always
)
;
BufferOffset
ma_vdtr
(
LoadStore
ls
const
Address
&
addr
VFPRegister
dest
AutoRegisterScope
&
scratch
Condition
cc
=
Always
)
;
BufferOffset
ma_vldr
(
VFPAddr
addr
VFPRegister
dest
Condition
cc
=
Always
)
;
BufferOffset
ma_vldr
(
const
Address
&
addr
VFPRegister
dest
AutoRegisterScope
&
scratch
Condition
cc
=
Always
)
;
BufferOffset
ma_vldr
(
VFPRegister
src
Register
base
Register
index
AutoRegisterScope
&
scratch
int32_t
shift
=
defaultShift
Condition
cc
=
Always
)
;
BufferOffset
ma_vstr
(
VFPRegister
src
VFPAddr
addr
Condition
cc
=
Always
)
;
BufferOffset
ma_vstr
(
VFPRegister
src
const
Address
&
addr
AutoRegisterScope
&
scratch
Condition
cc
=
Always
)
;
BufferOffset
ma_vstr
(
VFPRegister
src
Register
base
Register
index
AutoRegisterScope
&
scratch
AutoRegisterScope
&
scratch2
int32_t
shift
int32_t
offset
Condition
cc
=
Always
)
;
BufferOffset
ma_vstr
(
VFPRegister
src
Register
base
Register
index
AutoRegisterScope
&
scratch
int32_t
shift
Condition
cc
=
Always
)
;
void
ma_call
(
ImmPtr
dest
)
;
int32_t
transferMultipleByRuns
(
FloatRegisterSet
set
LoadStore
ls
Register
rm
DTMMode
mode
)
{
if
(
mode
=
=
IA
)
{
return
transferMultipleByRunsImpl
<
FloatRegisterForwardIterator
>
(
set
ls
rm
mode
1
)
;
}
if
(
mode
=
=
DB
)
{
return
transferMultipleByRunsImpl
<
FloatRegisterBackwardIterator
>
(
set
ls
rm
mode
-
1
)
;
}
MOZ_CRASH
(
"
Invalid
data
transfer
addressing
mode
"
)
;
}
void
wasmLoadImpl
(
const
wasm
:
:
MemoryAccessDesc
&
access
Register
memoryBase
Register
ptr
Register
ptrScratch
AnyRegister
outAny
Register64
out64
)
;
void
wasmStoreImpl
(
const
wasm
:
:
MemoryAccessDesc
&
access
AnyRegister
valAny
Register64
val64
Register
memoryBase
Register
ptr
Register
ptrScratch
)
;
protected
:
void
wasmUnalignedLoadImpl
(
const
wasm
:
:
MemoryAccessDesc
&
access
Register
memoryBase
Register
ptr
Register
ptrScratch
AnyRegister
outAny
Register64
out64
Register
tmp1
Register
tmp2
Register
tmp3
)
;
void
wasmUnalignedStoreImpl
(
const
wasm
:
:
MemoryAccessDesc
&
access
FloatRegister
floatValue
Register64
val64
Register
memoryBase
Register
ptr
Register
ptrScratch
Register
valOrTmp
)
;
private
:
void
emitUnalignedLoad
(
const
wasm
:
:
MemoryAccessDesc
*
access
bool
isSigned
unsigned
byteSize
Register
ptr
Register
tmp
Register
dest
unsigned
offset
=
0
)
;
void
emitUnalignedStore
(
const
wasm
:
:
MemoryAccessDesc
*
access
unsigned
byteSize
Register
ptr
Register
val
unsigned
offset
=
0
)
;
template
<
typename
RegisterIterator
>
int32_t
transferMultipleByRunsImpl
(
FloatRegisterSet
set
LoadStore
ls
Register
rm
DTMMode
mode
int32_t
sign
)
{
MOZ_ASSERT
(
sign
=
=
1
|
|
sign
=
=
-
1
)
;
int32_t
delta
=
sign
*
sizeof
(
float
)
;
int32_t
offset
=
0
;
FloatRegisterSet
mod
=
set
.
reduceSetForPush
(
)
;
RegisterIterator
iter
(
mod
)
;
while
(
iter
.
more
(
)
)
{
startFloatTransferM
(
ls
rm
mode
WriteBack
)
;
int32_t
reg
=
(
*
iter
)
.
code
(
)
;
do
{
offset
+
=
delta
;
if
(
(
*
iter
)
.
isDouble
(
)
)
{
offset
+
=
delta
;
}
transferFloatReg
(
*
iter
)
;
}
while
(
(
+
+
iter
)
.
more
(
)
&
&
int32_t
(
(
*
iter
)
.
code
(
)
)
=
=
(
reg
+
=
sign
)
)
;
finishFloatTransfer
(
)
;
}
return
offset
;
}
}
;
class
MacroAssembler
;
class
MacroAssemblerARMCompat
:
public
MacroAssemblerARM
{
private
:
MacroAssembler
&
asMasm
(
)
;
const
MacroAssembler
&
asMasm
(
)
const
;
public
:
MacroAssemblerARMCompat
(
)
{
}
public
:
void
j
(
Condition
code
Label
*
dest
)
{
as_b
(
dest
code
)
;
}
void
j
(
Label
*
dest
)
{
as_b
(
dest
Always
)
;
}
void
mov
(
Register
src
Register
dest
)
{
ma_mov
(
src
dest
)
;
}
void
mov
(
ImmWord
imm
Register
dest
)
{
ma_mov
(
Imm32
(
imm
.
value
)
dest
)
;
}
void
mov
(
ImmPtr
imm
Register
dest
)
{
mov
(
ImmWord
(
uintptr_t
(
imm
.
value
)
)
dest
)
;
}
void
branch
(
JitCode
*
c
)
{
BufferOffset
bo
=
m_buffer
.
nextOffset
(
)
;
addPendingJump
(
bo
ImmPtr
(
c
-
>
raw
(
)
)
RelocationKind
:
:
JITCODE
)
;
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_movPatchable
(
ImmPtr
(
c
-
>
raw
(
)
)
scratch
Always
)
;
ma_bx
(
scratch
)
;
}
void
branch
(
const
Register
reg
)
{
ma_bx
(
reg
)
;
}
void
nop
(
)
{
ma_nop
(
)
;
}
void
shortJumpSizedNop
(
)
{
ma_nop
(
)
;
}
void
ret
(
)
{
ma_pop
(
pc
)
;
}
void
retn
(
Imm32
n
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_popn_pc
(
n
scratch
scratch2
)
;
}
void
push
(
Imm32
imm
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_mov
(
imm
scratch
)
;
ma_push
(
scratch
)
;
}
void
push
(
ImmWord
imm
)
{
push
(
Imm32
(
imm
.
value
)
)
;
}
void
push
(
ImmGCPtr
imm
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_mov
(
imm
scratch
)
;
ma_push
(
scratch
)
;
}
void
push
(
const
Address
&
addr
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_ldr
(
addr
scratch
scratch2
)
;
ma_push
(
scratch
)
;
}
void
push
(
Register
reg
)
{
if
(
reg
=
=
sp
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_push_sp
(
reg
scratch
)
;
}
else
{
ma_push
(
reg
)
;
}
}
void
push
(
FloatRegister
reg
)
{
ma_vpush
(
VFPRegister
(
reg
)
)
;
}
void
pushWithPadding
(
Register
reg
const
Imm32
extraSpace
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
Imm32
totSpace
=
Imm32
(
extraSpace
.
value
+
4
)
;
ma_dtr
(
IsStore
sp
totSpace
reg
scratch
PreIndex
)
;
}
void
pushWithPadding
(
Imm32
imm
const
Imm32
extraSpace
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
Imm32
totSpace
=
Imm32
(
extraSpace
.
value
+
4
)
;
ma_mov
(
imm
scratch
)
;
ma_dtr
(
IsStore
sp
totSpace
scratch
scratch2
PreIndex
)
;
}
void
pop
(
Register
reg
)
{
ma_pop
(
reg
)
;
}
void
pop
(
FloatRegister
reg
)
{
ma_vpop
(
VFPRegister
(
reg
)
)
;
}
void
popN
(
Register
reg
Imm32
extraSpace
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
Imm32
totSpace
=
Imm32
(
extraSpace
.
value
+
4
)
;
ma_dtr
(
IsLoad
sp
totSpace
reg
scratch
PostIndex
)
;
}
CodeOffset
toggledJump
(
Label
*
label
)
;
CodeOffset
toggledCall
(
JitCode
*
target
bool
enabled
)
;
CodeOffset
pushWithPatch
(
ImmWord
imm
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
CodeOffset
label
=
movWithPatch
(
imm
scratch
)
;
ma_push
(
scratch
)
;
return
label
;
}
CodeOffset
movWithPatch
(
ImmWord
imm
Register
dest
)
{
CodeOffset
label
=
CodeOffset
(
currentOffset
(
)
)
;
ma_movPatchable
(
Imm32
(
imm
.
value
)
dest
Always
)
;
return
label
;
}
CodeOffset
movWithPatch
(
ImmPtr
imm
Register
dest
)
{
return
movWithPatch
(
ImmWord
(
uintptr_t
(
imm
.
value
)
)
dest
)
;
}
void
jump
(
Label
*
label
)
{
as_b
(
label
)
;
}
void
jump
(
JitCode
*
code
)
{
branch
(
code
)
;
}
void
jump
(
TrampolinePtr
code
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
movePtr
(
ImmPtr
(
code
.
value
)
scratch
)
;
ma_bx
(
scratch
)
;
}
void
jump
(
Register
reg
)
{
ma_bx
(
reg
)
;
}
void
jump
(
const
Address
&
addr
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_ldr
(
addr
scratch
scratch2
)
;
ma_bx
(
scratch
)
;
}
void
negl
(
Register
reg
)
{
ma_neg
(
reg
reg
SetCC
)
;
}
void
test32
(
Register
lhs
Register
rhs
)
{
ma_tst
(
lhs
rhs
)
;
}
void
test32
(
Register
lhs
Imm32
imm
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_tst
(
lhs
imm
scratch
)
;
}
void
test32
(
const
Address
&
addr
Imm32
imm
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_ldr
(
addr
scratch
scratch2
)
;
ma_tst
(
scratch
imm
scratch2
)
;
}
void
testPtr
(
Register
lhs
Register
rhs
)
{
test32
(
lhs
rhs
)
;
}
void
splitTagForTest
(
const
ValueOperand
&
value
ScratchTagScope
&
tag
)
{
MOZ_ASSERT
(
value
.
typeReg
(
)
=
=
tag
)
;
}
Condition
testInt32
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testBoolean
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testDouble
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testNull
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testUndefined
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testString
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testSymbol
(
Condition
cond
const
ValueOperand
&
value
)
;
#
ifdef
ENABLE_BIGINT
Condition
testBigInt
(
Condition
cond
const
ValueOperand
&
value
)
;
#
endif
Condition
testObject
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testNumber
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testMagic
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testPrimitive
(
Condition
cond
const
ValueOperand
&
value
)
;
Condition
testInt32
(
Condition
cond
Register
tag
)
;
Condition
testBoolean
(
Condition
cond
Register
tag
)
;
Condition
testNull
(
Condition
cond
Register
tag
)
;
Condition
testUndefined
(
Condition
cond
Register
tag
)
;
Condition
testString
(
Condition
cond
Register
tag
)
;
Condition
testSymbol
(
Condition
cond
Register
tag
)
;
#
ifdef
ENABLE_BIGINT
Condition
testBigInt
(
Condition
cond
Register
tag
)
;
#
endif
Condition
testObject
(
Condition
cond
Register
tag
)
;
Condition
testDouble
(
Condition
cond
Register
tag
)
;
Condition
testNumber
(
Condition
cond
Register
tag
)
;
Condition
testMagic
(
Condition
cond
Register
tag
)
;
Condition
testPrimitive
(
Condition
cond
Register
tag
)
;
Condition
testGCThing
(
Condition
cond
const
Address
&
address
)
;
Condition
testMagic
(
Condition
cond
const
Address
&
address
)
;
Condition
testInt32
(
Condition
cond
const
Address
&
address
)
;
Condition
testDouble
(
Condition
cond
const
Address
&
address
)
;
Condition
testBoolean
(
Condition
cond
const
Address
&
address
)
;
Condition
testNull
(
Condition
cond
const
Address
&
address
)
;
Condition
testUndefined
(
Condition
cond
const
Address
&
address
)
;
Condition
testString
(
Condition
cond
const
Address
&
address
)
;
Condition
testSymbol
(
Condition
cond
const
Address
&
address
)
;
#
ifdef
ENABLE_BIGINT
Condition
testBigInt
(
Condition
cond
const
Address
&
address
)
;
#
endif
Condition
testObject
(
Condition
cond
const
Address
&
address
)
;
Condition
testNumber
(
Condition
cond
const
Address
&
address
)
;
Condition
testUndefined
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testNull
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testBoolean
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testString
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testSymbol
(
Condition
cond
const
BaseIndex
&
src
)
;
#
ifdef
ENABLE_BIGINT
Condition
testBigInt
(
Condition
cond
const
BaseIndex
&
src
)
;
#
endif
Condition
testInt32
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testObject
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testDouble
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testMagic
(
Condition
cond
const
BaseIndex
&
src
)
;
Condition
testGCThing
(
Condition
cond
const
BaseIndex
&
src
)
;
void
unboxNonDouble
(
const
ValueOperand
&
operand
Register
dest
JSValueType
type
)
;
void
unboxNonDouble
(
const
Address
&
src
Register
dest
JSValueType
type
)
;
void
unboxNonDouble
(
const
BaseIndex
&
src
Register
dest
JSValueType
type
)
;
void
unboxInt32
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_INT32
)
;
}
void
unboxInt32
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_INT32
)
;
}
void
unboxBoolean
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_BOOLEAN
)
;
}
void
unboxBoolean
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_BOOLEAN
)
;
}
void
unboxString
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_STRING
)
;
}
void
unboxString
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_STRING
)
;
}
void
unboxSymbol
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_SYMBOL
)
;
}
void
unboxSymbol
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_SYMBOL
)
;
}
#
ifdef
ENABLE_BIGINT
void
unboxBigInt
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_BIGINT
)
;
}
void
unboxBigInt
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_BIGINT
)
;
}
#
endif
void
unboxObject
(
const
ValueOperand
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_OBJECT
)
;
}
void
unboxObject
(
const
Address
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_OBJECT
)
;
}
void
unboxObject
(
const
BaseIndex
&
src
Register
dest
)
{
unboxNonDouble
(
src
dest
JSVAL_TYPE_OBJECT
)
;
}
void
unboxDouble
(
const
ValueOperand
&
src
FloatRegister
dest
)
;
void
unboxDouble
(
const
Address
&
src
FloatRegister
dest
)
;
void
unboxValue
(
const
ValueOperand
&
src
AnyRegister
dest
JSValueType
type
)
;
void
unboxPrivate
(
const
ValueOperand
&
src
Register
dest
)
;
void
unboxGCThingForPreBarrierTrampoline
(
const
Address
&
src
Register
dest
)
{
load32
(
ToPayload
(
src
)
dest
)
;
}
void
notBoolean
(
const
ValueOperand
&
val
)
{
as_eor
(
val
.
payloadReg
(
)
val
.
payloadReg
(
)
Imm8
(
1
)
)
;
}
void
boxDouble
(
FloatRegister
src
const
ValueOperand
&
dest
FloatRegister
)
;
void
boxNonDouble
(
JSValueType
type
Register
src
const
ValueOperand
&
dest
)
;
MOZ_MUST_USE
Register
extractObject
(
const
Address
&
address
Register
scratch
)
;
MOZ_MUST_USE
Register
extractObject
(
const
ValueOperand
&
value
Register
scratch
)
{
unboxNonDouble
(
value
value
.
payloadReg
(
)
JSVAL_TYPE_OBJECT
)
;
return
value
.
payloadReg
(
)
;
}
MOZ_MUST_USE
Register
extractSymbol
(
const
ValueOperand
&
value
Register
scratch
)
{
unboxNonDouble
(
value
value
.
payloadReg
(
)
JSVAL_TYPE_SYMBOL
)
;
return
value
.
payloadReg
(
)
;
}
MOZ_MUST_USE
Register
extractInt32
(
const
ValueOperand
&
value
Register
scratch
)
{
return
value
.
payloadReg
(
)
;
}
MOZ_MUST_USE
Register
extractBoolean
(
const
ValueOperand
&
value
Register
scratch
)
{
return
value
.
payloadReg
(
)
;
}
MOZ_MUST_USE
Register
extractTag
(
const
Address
&
address
Register
scratch
)
;
MOZ_MUST_USE
Register
extractTag
(
const
BaseIndex
&
address
Register
scratch
)
;
MOZ_MUST_USE
Register
extractTag
(
const
ValueOperand
&
value
Register
scratch
)
{
return
value
.
typeReg
(
)
;
}
void
boolValueToDouble
(
const
ValueOperand
&
operand
FloatRegister
dest
)
;
void
int32ValueToDouble
(
const
ValueOperand
&
operand
FloatRegister
dest
)
;
void
loadInt32OrDouble
(
const
Address
&
src
FloatRegister
dest
)
;
void
loadInt32OrDouble
(
Register
base
Register
index
FloatRegister
dest
int32_t
shift
=
defaultShift
)
;
void
loadConstantDouble
(
double
dp
FloatRegister
dest
)
;
Condition
testInt32Truthy
(
bool
truthy
const
ValueOperand
&
operand
)
;
Condition
testBooleanTruthy
(
bool
truthy
const
ValueOperand
&
operand
)
;
Condition
testDoubleTruthy
(
bool
truthy
FloatRegister
reg
)
;
Condition
testStringTruthy
(
bool
truthy
const
ValueOperand
&
value
)
;
#
ifdef
ENABLE_BIGINT
Condition
testBigIntTruthy
(
bool
truthy
const
ValueOperand
&
value
)
;
#
endif
void
boolValueToFloat32
(
const
ValueOperand
&
operand
FloatRegister
dest
)
;
void
int32ValueToFloat32
(
const
ValueOperand
&
operand
FloatRegister
dest
)
;
void
loadConstantFloat32
(
float
f
FloatRegister
dest
)
;
CodeOffsetJump
jumpWithPatch
(
RepatchLabel
*
label
)
;
void
loadUnboxedValue
(
Address
address
MIRType
type
AnyRegister
dest
)
{
if
(
dest
.
isFloat
(
)
)
{
loadInt32OrDouble
(
address
dest
.
fpu
(
)
)
;
}
else
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_ldr
(
address
dest
.
gpr
(
)
scratch
)
;
}
}
void
loadUnboxedValue
(
BaseIndex
address
MIRType
type
AnyRegister
dest
)
{
if
(
dest
.
isFloat
(
)
)
{
loadInt32OrDouble
(
address
.
base
address
.
index
dest
.
fpu
(
)
address
.
scale
)
;
}
else
{
load32
(
address
dest
.
gpr
(
)
)
;
}
}
template
<
typename
T
>
void
storeUnboxedPayload
(
ValueOperand
value
T
address
size_t
nbytes
JSValueType
)
{
switch
(
nbytes
)
{
case
4
:
storePtr
(
value
.
payloadReg
(
)
address
)
;
return
;
case
1
:
store8
(
value
.
payloadReg
(
)
address
)
;
return
;
default
:
MOZ_CRASH
(
"
Bad
payload
width
"
)
;
}
}
void
storeValue
(
ValueOperand
val
const
Address
&
dst
)
;
void
storeValue
(
ValueOperand
val
const
BaseIndex
&
dest
)
;
void
storeValue
(
JSValueType
type
Register
reg
BaseIndex
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
int32_t
payloadoffset
=
dest
.
offset
+
NUNBOX32_PAYLOAD_OFFSET
;
int32_t
typeoffset
=
dest
.
offset
+
NUNBOX32_TYPE_OFFSET
;
ma_alu
(
dest
.
base
lsl
(
dest
.
index
dest
.
scale
)
scratch
OpAdd
)
;
if
(
payloadoffset
<
4096
&
&
payloadoffset
>
-
4096
)
{
ma_str
(
reg
DTRAddr
(
scratch
DtrOffImm
(
payloadoffset
)
)
)
;
}
else
{
ma_str
(
reg
Address
(
scratch
payloadoffset
)
scratch2
)
;
}
if
(
typeoffset
<
4096
&
&
typeoffset
>
-
4096
)
{
ma_mov
(
ImmTag
(
JSVAL_TYPE_TO_TAG
(
type
)
)
scratch2
)
;
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
typeoffset
)
)
)
;
}
else
{
ma_add
(
Imm32
(
typeoffset
)
scratch
scratch2
)
;
ma_mov
(
ImmTag
(
JSVAL_TYPE_TO_TAG
(
type
)
)
scratch2
)
;
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
0
)
)
)
;
}
}
void
storeValue
(
JSValueType
type
Register
reg
Address
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_str
(
reg
dest
scratch2
)
;
ma_mov
(
ImmTag
(
JSVAL_TYPE_TO_TAG
(
type
)
)
scratch
)
;
ma_str
(
scratch
Address
(
dest
.
base
dest
.
offset
+
NUNBOX32_TYPE_OFFSET
)
scratch2
)
;
}
void
storeValue
(
const
Value
&
val
const
Address
&
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_mov
(
Imm32
(
val
.
toNunboxTag
(
)
)
scratch
)
;
ma_str
(
scratch
ToType
(
dest
)
scratch2
)
;
if
(
val
.
isGCThing
(
)
)
{
ma_mov
(
ImmGCPtr
(
val
.
toGCThing
(
)
)
scratch
)
;
}
else
{
ma_mov
(
Imm32
(
val
.
toNunboxPayload
(
)
)
scratch
)
;
}
ma_str
(
scratch
ToPayload
(
dest
)
scratch2
)
;
}
void
storeValue
(
const
Value
&
val
BaseIndex
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
int32_t
typeoffset
=
dest
.
offset
+
NUNBOX32_TYPE_OFFSET
;
int32_t
payloadoffset
=
dest
.
offset
+
NUNBOX32_PAYLOAD_OFFSET
;
ma_alu
(
dest
.
base
lsl
(
dest
.
index
dest
.
scale
)
scratch
OpAdd
)
;
if
(
typeoffset
<
4096
&
&
typeoffset
>
-
4096
)
{
ma_mov
(
Imm32
(
val
.
toNunboxTag
(
)
)
scratch2
)
;
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
typeoffset
)
)
)
;
}
else
{
ma_add
(
Imm32
(
typeoffset
)
scratch
scratch2
)
;
ma_mov
(
Imm32
(
val
.
toNunboxTag
(
)
)
scratch2
)
;
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
0
)
)
)
;
ma_alu
(
dest
.
base
lsl
(
dest
.
index
dest
.
scale
)
scratch
OpAdd
)
;
}
if
(
payloadoffset
<
4096
&
&
payloadoffset
>
-
4096
)
{
if
(
val
.
isGCThing
(
)
)
{
ma_mov
(
ImmGCPtr
(
val
.
toGCThing
(
)
)
scratch2
)
;
}
else
{
ma_mov
(
Imm32
(
val
.
toNunboxPayload
(
)
)
scratch2
)
;
}
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
payloadoffset
)
)
)
;
}
else
{
ma_add
(
Imm32
(
payloadoffset
)
scratch
scratch2
)
;
if
(
val
.
isGCThing
(
)
)
{
ma_mov
(
ImmGCPtr
(
val
.
toGCThing
(
)
)
scratch2
)
;
}
else
{
ma_mov
(
Imm32
(
val
.
toNunboxPayload
(
)
)
scratch2
)
;
}
ma_str
(
scratch2
DTRAddr
(
scratch
DtrOffImm
(
0
)
)
)
;
}
}
void
storeValue
(
const
Address
&
src
const
Address
&
dest
Register
temp
)
{
load32
(
ToType
(
src
)
temp
)
;
store32
(
temp
ToType
(
dest
)
)
;
load32
(
ToPayload
(
src
)
temp
)
;
store32
(
temp
ToPayload
(
dest
)
)
;
}
void
loadValue
(
Address
src
ValueOperand
val
)
;
void
loadValue
(
Operand
dest
ValueOperand
val
)
{
loadValue
(
dest
.
toAddress
(
)
val
)
;
}
void
loadValue
(
const
BaseIndex
&
addr
ValueOperand
val
)
;
void
tagValue
(
JSValueType
type
Register
payload
ValueOperand
dest
)
;
void
pushValue
(
ValueOperand
val
)
;
void
popValue
(
ValueOperand
val
)
;
void
pushValue
(
const
Value
&
val
)
{
push
(
Imm32
(
val
.
toNunboxTag
(
)
)
)
;
if
(
val
.
isGCThing
(
)
)
{
push
(
ImmGCPtr
(
val
.
toGCThing
(
)
)
)
;
}
else
{
push
(
Imm32
(
val
.
toNunboxPayload
(
)
)
)
;
}
}
void
pushValue
(
JSValueType
type
Register
reg
)
{
push
(
ImmTag
(
JSVAL_TYPE_TO_TAG
(
type
)
)
)
;
ma_push
(
reg
)
;
}
void
pushValue
(
const
Address
&
addr
)
;
void
storePayload
(
const
Value
&
val
const
Address
&
dest
)
;
void
storePayload
(
Register
src
const
Address
&
dest
)
;
void
storePayload
(
const
Value
&
val
const
BaseIndex
&
dest
)
;
void
storePayload
(
Register
src
const
BaseIndex
&
dest
)
;
void
storeTypeTag
(
ImmTag
tag
const
Address
&
dest
)
;
void
storeTypeTag
(
ImmTag
tag
const
BaseIndex
&
dest
)
;
void
handleFailureWithHandlerTail
(
void
*
handler
Label
*
profilerExitTail
)
;
public
:
void
not32
(
Register
reg
)
;
void
move32
(
Imm32
imm
Register
dest
)
;
void
move32
(
Register
src
Register
dest
)
;
void
movePtr
(
Register
src
Register
dest
)
;
void
movePtr
(
ImmWord
imm
Register
dest
)
;
void
movePtr
(
ImmPtr
imm
Register
dest
)
;
void
movePtr
(
wasm
:
:
SymbolicAddress
imm
Register
dest
)
;
void
movePtr
(
ImmGCPtr
imm
Register
dest
)
;
void
load8SignExtend
(
const
Address
&
address
Register
dest
)
;
void
load8SignExtend
(
const
BaseIndex
&
src
Register
dest
)
;
void
load8ZeroExtend
(
const
Address
&
address
Register
dest
)
;
void
load8ZeroExtend
(
const
BaseIndex
&
src
Register
dest
)
;
void
load16SignExtend
(
const
Address
&
address
Register
dest
)
;
void
load16SignExtend
(
const
BaseIndex
&
src
Register
dest
)
;
void
load16ZeroExtend
(
const
Address
&
address
Register
dest
)
;
void
load16ZeroExtend
(
const
BaseIndex
&
src
Register
dest
)
;
void
load32
(
const
Address
&
address
Register
dest
)
;
void
load32
(
const
BaseIndex
&
address
Register
dest
)
;
void
load32
(
AbsoluteAddress
address
Register
dest
)
;
void
load64
(
const
Address
&
address
Register64
dest
)
{
load32
(
LowWord
(
address
)
dest
.
low
)
;
load32
(
HighWord
(
address
)
dest
.
high
)
;
}
void
loadPtr
(
const
Address
&
address
Register
dest
)
;
void
loadPtr
(
const
BaseIndex
&
src
Register
dest
)
;
void
loadPtr
(
AbsoluteAddress
address
Register
dest
)
;
void
loadPtr
(
wasm
:
:
SymbolicAddress
address
Register
dest
)
;
void
loadPrivate
(
const
Address
&
address
Register
dest
)
;
void
loadDouble
(
const
Address
&
addr
FloatRegister
dest
)
;
void
loadDouble
(
const
BaseIndex
&
src
FloatRegister
dest
)
;
void
loadFloatAsDouble
(
const
Address
&
addr
FloatRegister
dest
)
;
void
loadFloatAsDouble
(
const
BaseIndex
&
src
FloatRegister
dest
)
;
void
loadFloat32
(
const
Address
&
addr
FloatRegister
dest
)
;
void
loadFloat32
(
const
BaseIndex
&
src
FloatRegister
dest
)
;
void
store8
(
Register
src
const
Address
&
address
)
;
void
store8
(
Imm32
imm
const
Address
&
address
)
;
void
store8
(
Register
src
const
BaseIndex
&
address
)
;
void
store8
(
Imm32
imm
const
BaseIndex
&
address
)
;
void
store16
(
Register
src
const
Address
&
address
)
;
void
store16
(
Imm32
imm
const
Address
&
address
)
;
void
store16
(
Register
src
const
BaseIndex
&
address
)
;
void
store16
(
Imm32
imm
const
BaseIndex
&
address
)
;
void
store32
(
Register
src
AbsoluteAddress
address
)
;
void
store32
(
Register
src
const
Address
&
address
)
;
void
store32
(
Register
src
const
BaseIndex
&
address
)
;
void
store32
(
Imm32
src
const
Address
&
address
)
;
void
store32
(
Imm32
src
const
BaseIndex
&
address
)
;
void
store64
(
Register64
src
Address
address
)
{
store32
(
src
.
low
LowWord
(
address
)
)
;
store32
(
src
.
high
HighWord
(
address
)
)
;
}
void
store64
(
Imm64
imm
Address
address
)
{
store32
(
imm
.
low
(
)
LowWord
(
address
)
)
;
store32
(
imm
.
hi
(
)
HighWord
(
address
)
)
;
}
void
storePtr
(
ImmWord
imm
const
Address
&
address
)
;
void
storePtr
(
ImmWord
imm
const
BaseIndex
&
address
)
;
void
storePtr
(
ImmPtr
imm
const
Address
&
address
)
;
void
storePtr
(
ImmPtr
imm
const
BaseIndex
&
address
)
;
void
storePtr
(
ImmGCPtr
imm
const
Address
&
address
)
;
void
storePtr
(
ImmGCPtr
imm
const
BaseIndex
&
address
)
;
void
storePtr
(
Register
src
const
Address
&
address
)
;
void
storePtr
(
Register
src
const
BaseIndex
&
address
)
;
void
storePtr
(
Register
src
AbsoluteAddress
dest
)
;
void
moveDouble
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
{
ma_vmov
(
src
dest
cc
)
;
}
inline
void
incrementInt32Value
(
const
Address
&
addr
)
;
void
cmp32
(
Register
lhs
Imm32
rhs
)
;
void
cmp32
(
Register
lhs
Register
rhs
)
;
void
cmp32
(
const
Address
&
lhs
Imm32
rhs
)
;
void
cmp32
(
const
Address
&
lhs
Register
rhs
)
;
void
cmpPtr
(
Register
lhs
Register
rhs
)
;
void
cmpPtr
(
Register
lhs
ImmWord
rhs
)
;
void
cmpPtr
(
Register
lhs
ImmPtr
rhs
)
;
void
cmpPtr
(
Register
lhs
ImmGCPtr
rhs
)
;
void
cmpPtr
(
Register
lhs
Imm32
rhs
)
;
void
cmpPtr
(
const
Address
&
lhs
Register
rhs
)
;
void
cmpPtr
(
const
Address
&
lhs
ImmWord
rhs
)
;
void
cmpPtr
(
const
Address
&
lhs
ImmPtr
rhs
)
;
void
cmpPtr
(
const
Address
&
lhs
ImmGCPtr
rhs
)
;
void
cmpPtr
(
const
Address
&
lhs
Imm32
rhs
)
;
void
setStackArg
(
Register
reg
uint32_t
arg
)
;
void
breakpoint
(
)
;
void
breakpoint
(
Condition
cc
)
;
void
simulatorStop
(
const
char
*
msg
)
;
void
minMaxDouble
(
FloatRegister
srcDest
FloatRegister
other
bool
canBeNaN
bool
isMax
)
;
void
minMaxFloat32
(
FloatRegister
srcDest
FloatRegister
other
bool
canBeNaN
bool
isMax
)
;
void
compareDouble
(
FloatRegister
lhs
FloatRegister
rhs
)
;
void
compareFloat
(
FloatRegister
lhs
FloatRegister
rhs
)
;
void
checkStackAlignment
(
)
;
void
ensureDouble
(
const
ValueOperand
&
source
FloatRegister
dest
Label
*
failure
)
;
void
emitSet
(
Assembler
:
:
Condition
cond
Register
dest
)
{
ma_mov
(
Imm32
(
0
)
dest
)
;
ma_mov
(
Imm32
(
1
)
dest
cond
)
;
}
void
testNullSet
(
Condition
cond
const
ValueOperand
&
value
Register
dest
)
{
cond
=
testNull
(
cond
value
)
;
emitSet
(
cond
dest
)
;
}
void
testObjectSet
(
Condition
cond
const
ValueOperand
&
value
Register
dest
)
{
cond
=
testObject
(
cond
value
)
;
emitSet
(
cond
dest
)
;
}
void
testUndefinedSet
(
Condition
cond
const
ValueOperand
&
value
Register
dest
)
{
cond
=
testUndefined
(
cond
value
)
;
emitSet
(
cond
dest
)
;
}
protected
:
bool
buildOOLFakeExitFrame
(
void
*
fakeReturnAddr
)
;
public
:
CodeOffset
labelForPatch
(
)
{
return
CodeOffset
(
nextOffset
(
)
.
getOffset
(
)
)
;
}
void
computeEffectiveAddress
(
const
Address
&
address
Register
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_add
(
address
.
base
Imm32
(
address
.
offset
)
dest
scratch
LeaveCC
)
;
}
void
computeEffectiveAddress
(
const
BaseIndex
&
address
Register
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_alu
(
address
.
base
lsl
(
address
.
index
address
.
scale
)
dest
OpAdd
LeaveCC
)
;
if
(
address
.
offset
)
{
ma_add
(
dest
Imm32
(
address
.
offset
)
dest
scratch
LeaveCC
)
;
}
}
void
floor
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
floorf
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
ceil
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
ceilf
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
round
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
FloatRegister
tmp
)
;
void
roundf
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
FloatRegister
tmp
)
;
void
trunc
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
truncf
(
FloatRegister
input
Register
output
Label
*
handleNotAnInt
)
;
void
clampCheck
(
Register
r
Label
*
handleNotAnInt
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
SecondScratchRegisterScope
scratch2
(
asMasm
(
)
)
;
ma_sub
(
r
Imm32
(
0x80000001
)
scratch
scratch2
)
;
as_cmn
(
scratch
Imm8
(
3
)
)
;
ma_b
(
handleNotAnInt
Above
)
;
}
void
lea
(
Operand
addr
Register
dest
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_add
(
addr
.
baseReg
(
)
Imm32
(
addr
.
disp
(
)
)
dest
scratch
)
;
}
void
abiret
(
)
{
as_bx
(
lr
)
;
}
void
moveFloat32
(
FloatRegister
src
FloatRegister
dest
Condition
cc
=
Always
)
{
as_vmov
(
VFPRegister
(
dest
)
.
singleOverlay
(
)
VFPRegister
(
src
)
.
singleOverlay
(
)
cc
)
;
}
void
loadWasmGlobalPtr
(
uint32_t
globalDataOffset
Register
dest
)
{
loadPtr
(
Address
(
WasmTlsReg
offsetof
(
wasm
:
:
TlsData
globalArea
)
+
globalDataOffset
)
dest
)
;
}
void
loadWasmPinnedRegsFromTls
(
)
{
ScratchRegisterScope
scratch
(
asMasm
(
)
)
;
ma_ldr
(
Address
(
WasmTlsReg
offsetof
(
wasm
:
:
TlsData
memoryBase
)
)
HeapReg
scratch
)
;
}
void
profilerEnterFrame
(
Register
framePtr
Register
scratch
)
;
void
profilerExitFrame
(
)
;
}
;
typedef
MacroAssemblerARMCompat
MacroAssemblerSpecific
;
}
}
#
endif
