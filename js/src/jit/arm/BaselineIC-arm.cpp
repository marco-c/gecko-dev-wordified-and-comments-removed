#
include
"
jit
/
BaselineCompiler
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
namespace
js
{
namespace
jit
{
bool
ICCompare_Int32
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Assembler
:
:
Condition
cond
=
JSOpToCondition
(
op
true
)
;
masm
.
cmp32
(
R0
.
payloadReg
(
)
R1
.
payloadReg
(
)
)
;
masm
.
ma_mov
(
Imm32
(
1
)
R0
.
payloadReg
(
)
cond
)
;
masm
.
ma_mov
(
Imm32
(
0
)
R0
.
payloadReg
(
)
Assembler
:
:
InvertCondition
(
cond
)
)
;
masm
.
tagValue
(
JSVAL_TYPE_BOOLEAN
R0
.
payloadReg
(
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCompare_Double
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
isNaN
;
masm
.
ensureDouble
(
R0
FloatReg0
&
failure
)
;
masm
.
ensureDouble
(
R1
FloatReg1
&
failure
)
;
Register
dest
=
R0
.
scratchReg
(
)
;
Assembler
:
:
DoubleCondition
doubleCond
=
JSOpToDoubleCondition
(
op
)
;
Assembler
:
:
Condition
cond
=
Assembler
:
:
ConditionFromDoubleCondition
(
doubleCond
)
;
masm
.
compareDouble
(
FloatReg0
FloatReg1
)
;
masm
.
ma_mov
(
Imm32
(
0
)
dest
)
;
masm
.
ma_mov
(
Imm32
(
1
)
dest
cond
)
;
masm
.
tagValue
(
JSVAL_TYPE_BOOLEAN
dest
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
}
}
