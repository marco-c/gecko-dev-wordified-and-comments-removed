#
include
<
initializer_list
>
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
void
JitRuntime
:
:
generateExceptionTailStub
(
MacroAssembler
&
masm
Label
*
profilerExitTail
Label
*
bailoutTail
)
{
AutoCreatedBy
acb
(
masm
"
JitRuntime
:
:
generateExceptionTailStub
"
)
;
exceptionTailOffset_
=
startTrampolineCode
(
masm
)
;
masm
.
bind
(
masm
.
failureLabel
(
)
)
;
masm
.
handleFailureWithHandlerTail
(
profilerExitTail
bailoutTail
)
;
}
void
JitRuntime
:
:
generateProfilerExitFrameTailStub
(
MacroAssembler
&
masm
Label
*
profilerExitTail
)
{
AutoCreatedBy
acb
(
masm
"
JitRuntime
:
:
generateProfilerExitFrameTailStub
"
)
;
profilerExitFrameTailOffset_
=
startTrampolineCode
(
masm
)
;
masm
.
bind
(
profilerExitTail
)
;
static
constexpr
size_t
CallerFPOffset
=
CommonFrameLayout
:
:
offsetOfCallerFramePtr
(
)
;
auto
emitAssertPrevFrameType
=
[
&
masm
]
(
Register
framePtr
Register
scratch
std
:
:
initializer_list
<
FrameType
>
types
)
{
#
ifdef
DEBUG
masm
.
loadPtr
(
Address
(
framePtr
CommonFrameLayout
:
:
offsetOfDescriptor
(
)
)
scratch
)
;
masm
.
and32
(
Imm32
(
FRAMETYPE_MASK
)
scratch
)
;
Label
checkOk
;
for
(
FrameType
type
:
types
)
{
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
type
)
&
checkOk
)
;
}
masm
.
assumeUnreachable
(
"
Unexpected
previous
frame
"
)
;
masm
.
bind
(
&
checkOk
)
;
#
else
(
void
)
masm
;
#
endif
}
;
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
regs
.
take
(
JSReturnOperand
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
actReg
=
regs
.
takeAny
(
)
;
masm
.
loadJSContext
(
actReg
)
;
masm
.
loadPtr
(
Address
(
actReg
offsetof
(
JSContext
profilingActivation_
)
)
actReg
)
;
Address
lastProfilingFrame
(
actReg
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
;
Address
lastProfilingCallSite
(
actReg
JitActivation
:
:
offsetOfLastProfilingCallSite
(
)
)
;
#
ifdef
DEBUG
{
masm
.
loadPtr
(
lastProfilingFrame
scratch
)
;
Label
checkOk
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch
ImmWord
(
0
)
&
checkOk
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
FramePointer
scratch
&
checkOk
)
;
masm
.
assumeUnreachable
(
"
Mismatch
between
stored
lastProfilingFrame
and
current
frame
"
"
pointer
.
"
)
;
masm
.
bind
(
&
checkOk
)
;
}
#
endif
Register
fpScratch
=
regs
.
takeAny
(
)
;
masm
.
mov
(
FramePointer
fpScratch
)
;
Label
again
;
masm
.
bind
(
&
again
)
;
masm
.
loadPtr
(
Address
(
fpScratch
JitFrameLayout
:
:
offsetOfDescriptor
(
)
)
scratch
)
;
masm
.
and32
(
Imm32
(
FRAMETYPE_MASK
)
scratch
)
;
Label
handle_BaselineOrIonJS
;
Label
handle_BaselineStub
;
Label
handle_Rectifier
;
Label
handle_IonICCall
;
Label
handle_Entry
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
IonJS
)
&
handle_BaselineOrIonJS
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineStub
)
&
handle_BaselineStub
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
Rectifier
)
&
handle_Rectifier
)
;
if
(
JitOptions
.
emitInterpreterEntryTrampoline
)
{
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineInterpreterEntry
)
&
handle_Rectifier
)
;
}
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
CppToJSJit
)
&
handle_Entry
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineJS
)
&
handle_BaselineOrIonJS
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
IonICCall
)
&
handle_IonICCall
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
WasmToJSJit
)
&
handle_Entry
)
;
masm
.
assumeUnreachable
(
"
Invalid
caller
frame
type
when
returning
from
a
JIT
frame
.
"
)
;
masm
.
bind
(
&
handle_BaselineOrIonJS
)
;
{
masm
.
loadPtr
(
Address
(
fpScratch
JitFrameLayout
:
:
offsetOfReturnAddress
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
auto
emitHandleStubFrame
=
[
&
]
(
FrameType
expectedPrevType
)
{
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
fpScratch
)
;
emitAssertPrevFrameType
(
fpScratch
scratch
{
expectedPrevType
}
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CommonFrameLayout
:
:
offsetOfReturnAddress
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
;
masm
.
bind
(
&
handle_BaselineStub
)
;
{
emitHandleStubFrame
(
FrameType
:
:
BaselineJS
)
;
}
masm
.
bind
(
&
handle_IonICCall
)
;
{
emitHandleStubFrame
(
FrameType
:
:
IonJS
)
;
}
masm
.
bind
(
&
handle_Rectifier
)
;
{
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
fpScratch
)
;
emitAssertPrevFrameType
(
fpScratch
scratch
{
FrameType
:
:
IonJS
FrameType
:
:
BaselineStub
FrameType
:
:
CppToJSJit
FrameType
:
:
WasmToJSJit
}
)
;
masm
.
jump
(
&
again
)
;
}
masm
.
bind
(
&
handle_Entry
)
;
{
masm
.
movePtr
(
ImmPtr
(
nullptr
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
}
