#
include
<
initializer_list
>
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
void
JitRuntime
:
:
generateExceptionTailStub
(
MacroAssembler
&
masm
Label
*
profilerExitTail
Label
*
bailoutTail
)
{
AutoCreatedBy
acb
(
masm
"
JitRuntime
:
:
generateExceptionTailStub
"
)
;
exceptionTailOffset_
=
startTrampolineCode
(
masm
)
;
uint32_t
returnValueCheckOffset
=
0
;
masm
.
bind
(
masm
.
failureLabel
(
)
)
;
masm
.
handleFailureWithHandlerTail
(
profilerExitTail
bailoutTail
&
returnValueCheckOffset
)
;
exceptionTailReturnValueCheckOffset_
=
returnValueCheckOffset
;
}
void
JitRuntime
:
:
generateProfilerExitFrameTailStub
(
MacroAssembler
&
masm
Label
*
profilerExitTail
)
{
AutoCreatedBy
acb
(
masm
"
JitRuntime
:
:
generateProfilerExitFrameTailStub
"
)
;
profilerExitFrameTailOffset_
=
startTrampolineCode
(
masm
)
;
masm
.
bind
(
profilerExitTail
)
;
static
constexpr
size_t
CallerFPOffset
=
CommonFrameLayout
:
:
offsetOfCallerFramePtr
(
)
;
auto
emitAssertPrevFrameType
=
[
&
masm
]
(
Register
framePtr
Register
scratch
std
:
:
initializer_list
<
FrameType
>
types
)
{
#
ifdef
DEBUG
masm
.
loadPtr
(
Address
(
framePtr
CommonFrameLayout
:
:
offsetOfDescriptor
(
)
)
scratch
)
;
masm
.
and32
(
Imm32
(
FrameDescriptor
:
:
TypeMask
)
scratch
)
;
Label
checkOk
;
for
(
FrameType
type
:
types
)
{
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
type
)
&
checkOk
)
;
}
masm
.
assumeUnreachable
(
"
Unexpected
previous
frame
"
)
;
masm
.
bind
(
&
checkOk
)
;
#
else
(
void
)
masm
;
#
endif
}
;
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
regs
.
take
(
JSReturnOperand
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
actReg
=
regs
.
takeAny
(
)
;
masm
.
loadJSContext
(
actReg
)
;
masm
.
loadPtr
(
Address
(
actReg
offsetof
(
JSContext
profilingActivation_
)
)
actReg
)
;
Address
lastProfilingFrame
(
actReg
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
;
Address
lastProfilingCallSite
(
actReg
JitActivation
:
:
offsetOfLastProfilingCallSite
(
)
)
;
#
ifdef
DEBUG
{
masm
.
loadPtr
(
lastProfilingFrame
scratch
)
;
Label
checkOk
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch
ImmWord
(
0
)
&
checkOk
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
FramePointer
scratch
&
checkOk
)
;
masm
.
assumeUnreachable
(
"
Mismatch
between
stored
lastProfilingFrame
and
current
frame
"
"
pointer
.
"
)
;
masm
.
bind
(
&
checkOk
)
;
}
#
endif
Register
fpScratch
=
regs
.
takeAny
(
)
;
masm
.
mov
(
FramePointer
fpScratch
)
;
Label
again
;
masm
.
bind
(
&
again
)
;
masm
.
loadPtr
(
Address
(
fpScratch
JitFrameLayout
:
:
offsetOfDescriptor
(
)
)
scratch
)
;
masm
.
and32
(
Imm32
(
FrameDescriptor
:
:
TypeMask
)
scratch
)
;
Label
handle_BaselineOrIonJS
;
Label
handle_BaselineStub
;
Label
handle_TrampolineNative
;
Label
handle_BaselineInterpreterEntry
;
Label
handle_IonICCall
;
Label
handle_Entry
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
IonJS
)
&
handle_BaselineOrIonJS
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineStub
)
&
handle_BaselineStub
)
;
if
(
JitOptions
.
emitInterpreterEntryTrampoline
)
{
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineInterpreterEntry
)
&
handle_BaselineInterpreterEntry
)
;
}
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
CppToJSJit
)
&
handle_Entry
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
BaselineJS
)
&
handle_BaselineOrIonJS
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
IonICCall
)
&
handle_IonICCall
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
TrampolineNative
)
&
handle_TrampolineNative
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
FrameType
:
:
WasmToJSJit
)
&
handle_Entry
)
;
masm
.
assumeUnreachable
(
"
Invalid
caller
frame
type
when
returning
from
a
JIT
frame
.
"
)
;
masm
.
bind
(
&
handle_BaselineOrIonJS
)
;
{
masm
.
loadPtr
(
Address
(
fpScratch
JitFrameLayout
:
:
offsetOfReturnAddress
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
auto
emitHandleStubFrame
=
[
&
]
(
FrameType
expectedPrevType
)
{
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
fpScratch
)
;
emitAssertPrevFrameType
(
fpScratch
scratch
{
expectedPrevType
}
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CommonFrameLayout
:
:
offsetOfReturnAddress
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
;
masm
.
bind
(
&
handle_BaselineStub
)
;
{
emitHandleStubFrame
(
FrameType
:
:
BaselineJS
)
;
}
masm
.
bind
(
&
handle_IonICCall
)
;
{
emitHandleStubFrame
(
FrameType
:
:
IonJS
)
;
}
masm
.
bind
(
&
handle_TrampolineNative
)
;
{
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
fpScratch
)
;
emitAssertPrevFrameType
(
fpScratch
scratch
{
FrameType
:
:
IonJS
FrameType
:
:
BaselineStub
FrameType
:
:
CppToJSJit
FrameType
:
:
WasmToJSJit
}
)
;
masm
.
jump
(
&
again
)
;
}
if
(
JitOptions
.
emitInterpreterEntryTrampoline
)
{
masm
.
bind
(
&
handle_BaselineInterpreterEntry
)
;
{
masm
.
loadPtr
(
Address
(
fpScratch
CallerFPOffset
)
fpScratch
)
;
emitAssertPrevFrameType
(
fpScratch
scratch
{
FrameType
:
:
IonJS
FrameType
:
:
BaselineJS
FrameType
:
:
BaselineStub
FrameType
:
:
CppToJSJit
FrameType
:
:
WasmToJSJit
FrameType
:
:
IonICCall
}
)
;
masm
.
jump
(
&
again
)
;
}
}
masm
.
bind
(
&
handle_Entry
)
;
{
masm
.
movePtr
(
ImmPtr
(
nullptr
)
scratch
)
;
masm
.
storePtr
(
scratch
lastProfilingCallSite
)
;
masm
.
storePtr
(
scratch
lastProfilingFrame
)
;
masm
.
moveToStackPtr
(
FramePointer
)
;
masm
.
pop
(
FramePointer
)
;
masm
.
ret
(
)
;
}
}
#
ifndef
JS_CODEGEN_ARM64
void
JitRuntime
:
:
generateEnterJitShared
(
MacroAssembler
&
masm
Register
argcReg
Register
argvReg
Register
calleeTokenReg
Register
scratch
Register
scratch2
Register
scratch3
)
{
static_assert
(
sizeof
(
JitFrameLayout
)
%
JitStackAlignment
=
=
0
"
No
need
to
consider
the
JitFrameLayout
for
aligning
the
stack
"
)
;
Label
notFunction
doneArgs
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
calleeTokenReg
Imm32
(
CalleeTokenScriptBit
)
&
notFunction
)
;
Register
actualArgs
=
scratch
;
masm
.
andPtr
(
Imm32
(
uint32_t
(
CalleeTokenMask
)
)
calleeTokenReg
actualArgs
)
;
masm
.
loadFunctionArgCount
(
actualArgs
actualArgs
)
;
masm
.
max32
(
actualArgs
argcReg
actualArgs
)
;
if
(
JitStackValueAlignment
=
=
1
)
{
masm
.
andToStackPtr
(
Imm32
(
~
(
JitStackAlignment
-
1
)
)
)
;
}
else
{
MOZ_ASSERT
(
JitStackValueAlignment
=
=
2
)
;
static_assert
(
CalleeToken_FunctionConstructing
=
=
1
)
;
masm
.
computeEffectiveAddress
(
BaseIndex
(
calleeTokenReg
actualArgs
Scale
:
:
TimesOne
1
)
scratch2
)
;
masm
.
and32
(
Imm32
(
1
)
scratch2
)
;
masm
.
lshift32
(
Imm32
(
3
)
scratch2
)
;
masm
.
moveStackPtrTo
(
scratch3
)
;
masm
.
subPtr
(
scratch2
scratch3
)
;
masm
.
andPtr
(
Imm32
(
JitStackAlignment
-
1
)
scratch3
)
;
masm
.
subFromStackPtr
(
scratch3
)
;
}
Register
argCursor
=
scratch3
;
masm
.
computeEffectiveAddress
(
BaseValueIndex
(
argvReg
argcReg
)
argCursor
)
;
Label
notConstructing
;
masm
.
branchTest32
(
Assembler
:
:
Zero
calleeTokenReg
Imm32
(
CalleeToken_FunctionConstructing
)
&
notConstructing
)
;
masm
.
pushValue
(
Address
(
argCursor
0
)
)
;
masm
.
bind
(
&
notConstructing
)
;
Label
undefLoop
doneUndef
;
masm
.
bind
(
&
undefLoop
)
;
masm
.
branch32
(
Assembler
:
:
Equal
actualArgs
argcReg
&
doneUndef
)
;
masm
.
pushValue
(
UndefinedValue
(
)
)
;
masm
.
sub32
(
Imm32
(
1
)
actualArgs
)
;
masm
.
jump
(
&
undefLoop
)
;
masm
.
bind
(
&
doneUndef
)
;
Label
argLoop
;
masm
.
bind
(
&
argLoop
)
;
masm
.
pushValue
(
Address
(
argCursor
-
int32_t
(
sizeof
(
Value
)
)
)
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
argCursor
)
;
masm
.
branchPtr
(
Assembler
:
:
AboveOrEqual
argCursor
argvReg
&
argLoop
)
;
masm
.
jump
(
&
doneArgs
)
;
masm
.
bind
(
&
notFunction
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
JitStackAlignment
-
1
)
)
)
;
masm
.
bind
(
&
doneArgs
)
;
masm
.
push
(
calleeTokenReg
)
;
}
#
endif
