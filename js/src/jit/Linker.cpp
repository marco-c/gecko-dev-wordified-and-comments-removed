#
include
"
jit
/
Linker
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
namespace
js
{
namespace
jit
{
JitCode
*
Linker
:
:
newCode
(
JSContext
*
cx
CodeKind
kind
bool
hasPatchableBackedges
)
{
MOZ_ASSERT_IF
(
hasPatchableBackedges
kind
=
=
CodeKind
:
:
Ion
)
;
JS
:
:
AutoAssertNoGC
nogc
(
cx
)
;
if
(
masm
.
oom
(
)
)
return
fail
(
cx
)
;
static
const
size_t
ExecutableAllocatorAlignment
=
sizeof
(
void
*
)
;
static_assert
(
CodeAlignment
>
=
ExecutableAllocatorAlignment
"
Unexpected
alignment
requirements
"
)
;
size_t
bytesNeeded
=
masm
.
bytesNeeded
(
)
+
sizeof
(
JitCodeHeader
)
+
(
CodeAlignment
-
ExecutableAllocatorAlignment
)
;
if
(
bytesNeeded
>
=
MAX_BUFFER_SIZE
)
return
fail
(
cx
)
;
bytesNeeded
=
AlignBytes
(
bytesNeeded
ExecutableAllocatorAlignment
)
;
ExecutableAllocator
&
execAlloc
=
hasPatchableBackedges
?
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
backedgeExecAlloc
(
)
:
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
execAlloc
(
)
;
ExecutablePool
*
pool
;
uint8_t
*
result
=
(
uint8_t
*
)
execAlloc
.
alloc
(
cx
bytesNeeded
&
pool
kind
)
;
if
(
!
result
)
return
fail
(
cx
)
;
uint8_t
*
codeStart
=
result
+
sizeof
(
JitCodeHeader
)
;
codeStart
=
(
uint8_t
*
)
AlignBytes
(
(
uintptr_t
)
codeStart
CodeAlignment
)
;
MOZ_ASSERT
(
codeStart
+
masm
.
bytesNeeded
(
)
<
=
result
+
bytesNeeded
)
;
uint32_t
headerSize
=
codeStart
-
result
;
JitCode
*
code
=
JitCode
:
:
New
<
NoGC
>
(
cx
codeStart
bytesNeeded
-
headerSize
headerSize
pool
kind
)
;
if
(
!
code
)
return
fail
(
cx
)
;
if
(
masm
.
oom
(
)
)
return
fail
(
cx
)
;
awjc
.
emplace
(
result
bytesNeeded
)
;
code
-
>
copyFrom
(
masm
)
;
masm
.
link
(
code
)
;
if
(
masm
.
embedsNurseryPointers
(
)
)
cx
-
>
zone
(
)
-
>
group
(
)
-
>
storeBuffer
(
)
.
putWholeCell
(
code
)
;
return
code
;
}
}
}
