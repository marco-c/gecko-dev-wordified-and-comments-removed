#
include
"
jit
/
Linker
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
namespace
js
{
namespace
jit
{
JitCode
*
Linker
:
:
newCode
(
JSContext
*
cx
CodeKind
kind
)
{
JS
:
:
AutoAssertNoGC
nogc
(
cx
)
;
if
(
masm
.
oom
(
)
)
{
return
fail
(
cx
)
;
}
masm
.
performPendingReadBarriers
(
)
;
static
const
size_t
ExecutableAllocatorAlignment
=
sizeof
(
void
*
)
;
static_assert
(
CodeAlignment
>
=
ExecutableAllocatorAlignment
"
Unexpected
alignment
requirements
"
)
;
size_t
bytesNeeded
=
masm
.
bytesNeeded
(
)
+
sizeof
(
JitCodeHeader
)
+
(
CodeAlignment
-
ExecutableAllocatorAlignment
)
;
if
(
bytesNeeded
>
=
MAX_BUFFER_SIZE
)
{
return
fail
(
cx
)
;
}
bytesNeeded
=
AlignBytes
(
bytesNeeded
ExecutableAllocatorAlignment
)
;
JitZone
*
jitZone
=
cx
-
>
zone
(
)
-
>
getJitZone
(
cx
)
;
if
(
!
jitZone
)
{
return
nullptr
;
}
ExecutablePool
*
pool
;
uint8_t
*
result
=
(
uint8_t
*
)
jitZone
-
>
execAlloc
(
)
.
alloc
(
cx
bytesNeeded
&
pool
kind
)
;
if
(
!
result
)
{
return
fail
(
cx
)
;
}
uint8_t
*
codeStart
=
result
+
sizeof
(
JitCodeHeader
)
;
codeStart
=
(
uint8_t
*
)
AlignBytes
(
(
uintptr_t
)
codeStart
CodeAlignment
)
;
MOZ_ASSERT
(
codeStart
+
masm
.
bytesNeeded
(
)
<
=
result
+
bytesNeeded
)
;
uint32_t
headerSize
=
codeStart
-
result
;
JitCode
*
code
=
JitCode
:
:
New
<
NoGC
>
(
cx
codeStart
bytesNeeded
headerSize
pool
kind
)
;
if
(
!
code
)
{
return
fail
(
cx
)
;
}
if
(
masm
.
oom
(
)
)
{
return
fail
(
cx
)
;
}
awjcf
.
emplace
(
result
bytesNeeded
)
;
if
(
!
awjcf
-
>
makeWritable
(
)
)
{
return
fail
(
cx
)
;
}
code
-
>
copyFrom
(
masm
)
;
masm
.
link
(
code
)
;
if
(
masm
.
embedsNurseryPointers
(
)
)
{
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
(
)
.
putWholeCell
(
code
)
;
}
return
code
;
}
}
}
