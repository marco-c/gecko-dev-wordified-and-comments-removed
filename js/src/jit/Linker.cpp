#
include
"
jit
/
Linker
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
namespace
js
{
namespace
jit
{
template
<
AllowGC
allowGC
>
JitCode
*
Linker
:
:
newCode
(
JSContext
*
cx
CodeKind
kind
bool
hasPatchableBackedges
)
{
MOZ_ASSERT
(
masm
.
numSymbolicAccesses
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
hasPatchableBackedges
kind
=
=
ION_CODE
)
;
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
if
(
masm
.
oom
(
)
)
return
fail
(
cx
)
;
ExecutablePool
*
pool
;
size_t
bytesNeeded
=
masm
.
bytesNeeded
(
)
+
sizeof
(
JitCode
*
)
+
CodeAlignment
;
if
(
bytesNeeded
>
=
MAX_BUFFER_SIZE
)
return
fail
(
cx
)
;
bytesNeeded
=
AlignBytes
(
bytesNeeded
sizeof
(
void
*
)
)
;
ExecutableAllocator
&
execAlloc
=
hasPatchableBackedges
?
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
backedgeExecAlloc
(
)
:
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
execAlloc
(
)
;
uint8_t
*
result
=
(
uint8_t
*
)
execAlloc
.
alloc
(
cx
bytesNeeded
&
pool
kind
)
;
if
(
!
result
)
return
fail
(
cx
)
;
uint8_t
*
codeStart
=
result
+
sizeof
(
JitCode
*
)
;
codeStart
=
(
uint8_t
*
)
AlignBytes
(
(
uintptr_t
)
codeStart
CodeAlignment
)
;
uint32_t
headerSize
=
codeStart
-
result
;
JitCode
*
code
=
JitCode
:
:
New
<
allowGC
>
(
cx
codeStart
bytesNeeded
-
headerSize
headerSize
pool
kind
)
;
if
(
!
code
)
return
nullptr
;
if
(
masm
.
oom
(
)
)
return
fail
(
cx
)
;
awjc
.
emplace
(
result
bytesNeeded
)
;
code
-
>
copyFrom
(
masm
)
;
masm
.
link
(
code
)
;
if
(
masm
.
embedsNurseryPointers
(
)
)
cx
-
>
zone
(
)
-
>
group
(
)
-
>
storeBuffer
(
)
.
putWholeCell
(
code
)
;
return
code
;
}
template
JitCode
*
Linker
:
:
newCode
<
CanGC
>
(
JSContext
*
cx
CodeKind
kind
bool
hasPatchableBackedges
)
;
template
JitCode
*
Linker
:
:
newCode
<
NoGC
>
(
JSContext
*
cx
CodeKind
kind
bool
hasPatchableBackedges
)
;
}
}
