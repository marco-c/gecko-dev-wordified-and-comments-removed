#
include
"
jit
/
mips32
/
MoveEmitter
-
mips32
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
void
MoveEmitterMIPS
:
:
breakCycle
(
const
MoveOperand
&
from
const
MoveOperand
&
to
MoveOp
:
:
Type
type
uint32_t
slotId
)
{
switch
(
type
)
{
case
MoveOp
:
:
FLOAT32
:
if
(
to
.
isMemory
(
)
)
{
FloatRegister
temp
=
ScratchFloat32Reg
;
masm
.
loadFloat32
(
getAdjustedAddress
(
to
)
temp
)
;
masm
.
storeFloat32
(
temp
cycleSlot
(
slotId
0
)
)
;
masm
.
storeFloat32
(
temp
cycleSlot
(
slotId
4
)
)
;
}
else
{
masm
.
storeDouble
(
to
.
floatReg
(
)
.
doubleOverlay
(
)
cycleSlot
(
slotId
0
)
)
;
}
break
;
case
MoveOp
:
:
DOUBLE
:
if
(
to
.
isMemory
(
)
)
{
FloatRegister
temp
=
ScratchDoubleReg
;
masm
.
loadDouble
(
getAdjustedAddress
(
to
)
temp
)
;
masm
.
storeDouble
(
temp
cycleSlot
(
slotId
0
)
)
;
}
else
{
masm
.
storeDouble
(
to
.
floatReg
(
)
cycleSlot
(
slotId
0
)
)
;
}
break
;
case
MoveOp
:
:
INT32
:
MOZ_ASSERT
(
sizeof
(
uintptr_t
)
=
=
sizeof
(
int32_t
)
)
;
case
MoveOp
:
:
GENERAL
:
if
(
to
.
isMemory
(
)
)
{
Register
temp
=
tempReg
(
)
;
masm
.
loadPtr
(
getAdjustedAddress
(
to
)
temp
)
;
masm
.
storePtr
(
temp
cycleSlot
(
0
0
)
)
;
}
else
{
MOZ_ASSERT
(
to
.
reg
(
)
!
=
spilledReg_
)
;
masm
.
storePtr
(
to
.
reg
(
)
cycleSlot
(
0
0
)
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Unexpected
move
type
"
)
;
}
}
void
MoveEmitterMIPS
:
:
completeCycle
(
const
MoveOperand
&
from
const
MoveOperand
&
to
MoveOp
:
:
Type
type
uint32_t
slotId
)
{
switch
(
type
)
{
case
MoveOp
:
:
FLOAT32
:
if
(
to
.
isMemory
(
)
)
{
FloatRegister
temp
=
ScratchFloat32Reg
;
masm
.
loadFloat32
(
cycleSlot
(
slotId
0
)
temp
)
;
masm
.
storeFloat32
(
temp
getAdjustedAddress
(
to
)
)
;
}
else
{
uint32_t
offset
=
0
;
if
(
from
.
floatReg
(
)
.
numAlignedAliased
(
)
=
=
1
)
offset
=
sizeof
(
float
)
;
masm
.
loadFloat32
(
cycleSlot
(
slotId
offset
)
to
.
floatReg
(
)
)
;
}
break
;
case
MoveOp
:
:
DOUBLE
:
if
(
to
.
isMemory
(
)
)
{
FloatRegister
temp
=
ScratchDoubleReg
;
masm
.
loadDouble
(
cycleSlot
(
slotId
0
)
temp
)
;
masm
.
storeDouble
(
temp
getAdjustedAddress
(
to
)
)
;
}
else
{
masm
.
loadDouble
(
cycleSlot
(
slotId
0
)
to
.
floatReg
(
)
)
;
}
break
;
case
MoveOp
:
:
INT32
:
MOZ_ASSERT
(
sizeof
(
uintptr_t
)
=
=
sizeof
(
int32_t
)
)
;
case
MoveOp
:
:
GENERAL
:
MOZ_ASSERT
(
slotId
=
=
0
)
;
if
(
to
.
isMemory
(
)
)
{
Register
temp
=
tempReg
(
)
;
masm
.
loadPtr
(
cycleSlot
(
0
0
)
temp
)
;
masm
.
storePtr
(
temp
getAdjustedAddress
(
to
)
)
;
}
else
{
MOZ_ASSERT
(
to
.
reg
(
)
!
=
spilledReg_
)
;
masm
.
loadPtr
(
cycleSlot
(
0
0
)
to
.
reg
(
)
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Unexpected
move
type
"
)
;
}
}
void
MoveEmitterMIPS
:
:
emitDoubleMove
(
const
MoveOperand
&
from
const
MoveOperand
&
to
)
{
MOZ_ASSERT_IF
(
from
.
isFloatReg
(
)
from
.
floatReg
(
)
!
=
ScratchDoubleReg
)
;
MOZ_ASSERT_IF
(
to
.
isFloatReg
(
)
to
.
floatReg
(
)
!
=
ScratchDoubleReg
)
;
if
(
from
.
isFloatReg
(
)
)
{
if
(
to
.
isFloatReg
(
)
)
{
masm
.
moveDouble
(
from
.
floatReg
(
)
to
.
floatReg
(
)
)
;
}
else
if
(
to
.
isGeneralRegPair
(
)
)
{
MOZ_ASSERT
(
to
.
evenReg
(
)
=
=
a2
&
&
to
.
oddReg
(
)
=
=
a3
"
Invalid
emitDoubleMove
arguments
.
"
)
;
masm
.
moveFromDoubleLo
(
from
.
floatReg
(
)
a2
)
;
masm
.
moveFromDoubleHi
(
from
.
floatReg
(
)
a3
)
;
}
else
{
MOZ_ASSERT
(
to
.
isMemory
(
)
)
;
masm
.
storeDouble
(
from
.
floatReg
(
)
getAdjustedAddress
(
to
)
)
;
}
}
else
if
(
to
.
isFloatReg
(
)
)
{
MOZ_ASSERT
(
from
.
isMemory
(
)
)
;
masm
.
loadDouble
(
getAdjustedAddress
(
from
)
to
.
floatReg
(
)
)
;
}
else
if
(
to
.
isGeneralRegPair
(
)
)
{
MOZ_ASSERT
(
from
.
isMemory
(
)
)
;
MOZ_ASSERT
(
to
.
evenReg
(
)
=
=
a2
&
&
to
.
oddReg
(
)
=
=
a3
"
Invalid
emitDoubleMove
arguments
.
"
)
;
masm
.
loadPtr
(
getAdjustedAddress
(
from
)
a2
)
;
masm
.
loadPtr
(
Address
(
from
.
base
(
)
getAdjustedOffset
(
from
)
+
sizeof
(
uint32_t
)
)
a3
)
;
}
else
{
MOZ_ASSERT
(
from
.
isMemory
(
)
)
;
MOZ_ASSERT
(
to
.
isMemory
(
)
)
;
masm
.
loadDouble
(
getAdjustedAddress
(
from
)
ScratchDoubleReg
)
;
masm
.
storeDouble
(
ScratchDoubleReg
getAdjustedAddress
(
to
)
)
;
}
}
