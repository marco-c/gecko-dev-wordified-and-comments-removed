#
ifndef
jit_mips32_Assembler_mips32_h
#
define
jit_mips32_Assembler_mips32_h
#
include
"
jit
/
mips
-
shared
/
Assembler
-
mips
-
shared
.
h
"
#
include
"
jit
/
mips32
/
Architecture
-
mips32
.
h
"
namespace
js
{
namespace
jit
{
static
constexpr
Register
CallTempReg4
=
t4
;
static
constexpr
Register
CallTempReg5
=
t5
;
static
constexpr
Register
CallTempNonArgRegs
[
]
=
{
t0
t1
t2
t3
t4
}
;
static
const
uint32_t
NumCallTempNonArgRegs
=
mozilla
:
:
ArrayLength
(
CallTempNonArgRegs
)
;
class
ABIArgGenerator
{
unsigned
usedArgSlots_
;
unsigned
firstArgFloatSize_
;
bool
useGPRForFloats_
;
ABIArg
current_
;
public
:
ABIArgGenerator
(
)
;
ABIArg
next
(
MIRType
argType
)
;
ABIArg
&
current
(
)
{
return
current_
;
}
void
enforceO32ABI
(
)
{
useGPRForFloats_
=
true
;
}
uint32_t
stackBytesConsumedSoFar
(
)
const
{
if
(
usedArgSlots_
<
=
4
)
{
return
ShadowStackSpace
;
}
return
usedArgSlots_
*
sizeof
(
intptr_t
)
;
}
}
;
static
constexpr
Register
ABINonArgReg0
=
t0
;
static
constexpr
Register
ABINonArgReg1
=
t1
;
static
constexpr
Register
ABINonArgReg2
=
t2
;
static
constexpr
Register
ABINonArgReg3
=
t3
;
static
constexpr
FloatRegister
ABINonArgDoubleReg
{
FloatRegisters
:
:
f16
FloatRegister
:
:
Double
}
;
static
constexpr
Register
ABINonArgReturnReg0
=
t0
;
static
constexpr
Register
ABINonArgReturnReg1
=
t1
;
static
constexpr
Register
ABINonVolatileReg
=
s0
;
static
constexpr
Register
ABINonArgReturnVolatileReg
=
t0
;
static
constexpr
Register
WasmTlsReg
=
s5
;
static
constexpr
Register
WasmTableCallScratchReg0
=
ABINonArgReg0
;
static
constexpr
Register
WasmTableCallScratchReg1
=
ABINonArgReg1
;
static
constexpr
Register
WasmTableCallSigReg
=
ABINonArgReg2
;
static
constexpr
Register
WasmTableCallIndexReg
=
ABINonArgReg3
;
static
constexpr
Register
WasmJitEntryReturnScratch
=
t1
;
static
constexpr
Register
InterpreterPCReg
=
t5
;
static
constexpr
Register
JSReturnReg_Type
=
a3
;
static
constexpr
Register
JSReturnReg_Data
=
a2
;
static
constexpr
Register64
ReturnReg64
(
v1
v0
)
;
static
constexpr
FloatRegister
ReturnFloat32Reg
=
{
FloatRegisters
:
:
f0
FloatRegister
:
:
Single
}
;
static
constexpr
FloatRegister
ReturnDoubleReg
=
{
FloatRegisters
:
:
f0
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
ScratchFloat32Reg
=
{
FloatRegisters
:
:
f18
FloatRegister
:
:
Single
}
;
static
constexpr
FloatRegister
ScratchDoubleReg
=
{
FloatRegisters
:
:
f18
FloatRegister
:
:
Double
}
;
struct
ScratchFloat32Scope
:
public
AutoFloatRegisterScope
{
explicit
ScratchFloat32Scope
(
MacroAssembler
&
masm
)
:
AutoFloatRegisterScope
(
masm
ScratchFloat32Reg
)
{
}
}
;
struct
ScratchDoubleScope
:
public
AutoFloatRegisterScope
{
explicit
ScratchDoubleScope
(
MacroAssembler
&
masm
)
:
AutoFloatRegisterScope
(
masm
ScratchDoubleReg
)
{
}
}
;
static
constexpr
FloatRegister
f0
=
{
FloatRegisters
:
:
f0
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f2
=
{
FloatRegisters
:
:
f2
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f4
=
{
FloatRegisters
:
:
f4
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f6
=
{
FloatRegisters
:
:
f6
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f8
=
{
FloatRegisters
:
:
f8
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f10
=
{
FloatRegisters
:
:
f10
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f12
=
{
FloatRegisters
:
:
f12
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f14
=
{
FloatRegisters
:
:
f14
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f16
=
{
FloatRegisters
:
:
f16
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f18
=
{
FloatRegisters
:
:
f18
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f20
=
{
FloatRegisters
:
:
f20
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f22
=
{
FloatRegisters
:
:
f22
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f24
=
{
FloatRegisters
:
:
f24
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f26
=
{
FloatRegisters
:
:
f26
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f28
=
{
FloatRegisters
:
:
f28
FloatRegister
:
:
Double
}
;
static
constexpr
FloatRegister
f30
=
{
FloatRegisters
:
:
f30
FloatRegister
:
:
Double
}
;
static
constexpr
uint32_t
ABIStackAlignment
=
8
;
static
constexpr
uint32_t
JitStackAlignment
=
8
;
static
constexpr
uint32_t
JitStackValueAlignment
=
JitStackAlignment
/
sizeof
(
Value
)
;
static_assert
(
JitStackAlignment
%
sizeof
(
Value
)
=
=
0
&
&
JitStackValueAlignment
>
=
1
"
Stack
alignment
should
be
a
non
-
zero
multiple
of
sizeof
(
Value
)
"
)
;
static
constexpr
uint32_t
SimdMemoryAlignment
=
8
;
static
constexpr
uint32_t
WasmStackAlignment
=
SimdMemoryAlignment
;
static
const
uint32_t
WasmTrapInstructionLength
=
4
;
static
constexpr
bool
SupportsUint32x4FloatConversions
=
false
;
static
constexpr
bool
SupportsUint8x16Compares
=
false
;
static
constexpr
bool
SupportsUint16x8Compares
=
false
;
static
constexpr
bool
SupportsUint32x4Compares
=
false
;
static
constexpr
Scale
ScalePointer
=
TimesFour
;
class
Assembler
:
public
AssemblerMIPSShared
{
public
:
Assembler
(
)
:
AssemblerMIPSShared
(
)
{
}
static
Condition
UnsignedCondition
(
Condition
cond
)
;
static
Condition
ConditionWithoutEqual
(
Condition
cond
)
;
static
uintptr_t
GetPointer
(
uint8_t
*
)
;
protected
:
FloatRegister
getOddPair
(
FloatRegister
reg
)
{
MOZ_ASSERT
(
reg
.
isDouble
(
)
)
;
MOZ_ASSERT
(
reg
.
id
(
)
%
2
=
=
0
)
;
FloatRegister
odd
(
reg
.
id
(
)
|
1
FloatRegister
:
:
Single
)
;
return
odd
;
}
public
:
using
AssemblerMIPSShared
:
:
bind
;
static
void
Bind
(
uint8_t
*
rawCode
const
CodeLabel
&
label
)
;
void
processCodeLabels
(
uint8_t
*
rawCode
)
;
static
void
TraceJumpRelocations
(
JSTracer
*
trc
JitCode
*
code
CompactBufferReader
&
reader
)
;
static
void
TraceDataRelocations
(
JSTracer
*
trc
JitCode
*
code
CompactBufferReader
&
reader
)
;
void
bind
(
InstImm
*
inst
uintptr_t
branch
uintptr_t
target
)
;
void
executableCopy
(
uint8_t
*
buffer
)
;
static
uint32_t
PatchWrite_NearCallSize
(
)
;
static
uint32_t
ExtractLuiOriValue
(
Instruction
*
inst0
Instruction
*
inst1
)
;
static
void
WriteLuiOriInstructions
(
Instruction
*
inst
Instruction
*
inst1
Register
reg
uint32_t
value
)
;
static
void
PatchWrite_NearCall
(
CodeLocationLabel
start
CodeLocationLabel
toCall
)
;
static
void
PatchDataWithValueCheck
(
CodeLocationLabel
label
ImmPtr
newValue
ImmPtr
expectedValue
)
;
static
void
PatchDataWithValueCheck
(
CodeLocationLabel
label
PatchedImmPtr
newValue
PatchedImmPtr
expectedValue
)
;
static
uint32_t
ExtractInstructionImmediate
(
uint8_t
*
code
)
;
static
void
ToggleCall
(
CodeLocationLabel
inst_
bool
enabled
)
;
}
;
static
const
uint32_t
NumIntArgRegs
=
4
;
static
inline
bool
GetIntArgReg
(
uint32_t
usedArgSlots
Register
*
out
)
{
if
(
usedArgSlots
<
NumIntArgRegs
)
{
*
out
=
Register
:
:
FromCode
(
a0
.
code
(
)
+
usedArgSlots
)
;
return
true
;
}
return
false
;
}
static
inline
bool
GetTempRegForIntArg
(
uint32_t
usedIntArgs
uint32_t
usedFloatArgs
Register
*
out
)
{
MOZ_ASSERT
(
usedFloatArgs
=
=
0
)
;
if
(
GetIntArgReg
(
usedIntArgs
out
)
)
{
return
true
;
}
usedIntArgs
-
=
NumIntArgRegs
;
if
(
usedIntArgs
>
=
NumCallTempNonArgRegs
)
{
return
false
;
}
*
out
=
CallTempNonArgRegs
[
usedIntArgs
]
;
return
true
;
}
static
inline
uint32_t
GetArgStackDisp
(
uint32_t
usedArgSlots
)
{
MOZ_ASSERT
(
usedArgSlots
>
=
NumIntArgRegs
)
;
return
usedArgSlots
*
sizeof
(
intptr_t
)
;
}
}
}
#
endif
