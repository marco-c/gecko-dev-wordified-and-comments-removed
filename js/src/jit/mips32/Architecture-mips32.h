#
ifndef
jit_mips32_Architecture_mips32_h
#
define
jit_mips32_Architecture_mips32_h
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
limits
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jit
/
mips
-
shared
/
Architecture
-
mips
-
shared
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
js
{
namespace
jit
{
static
const
uint32_t
ShadowStackSpace
=
4
*
sizeof
(
uintptr_t
)
;
static
const
int32_t
NUNBOX32_TYPE_OFFSET
=
4
;
static
const
int32_t
NUNBOX32_PAYLOAD_OFFSET
=
0
;
static
const
uint32_t
BAILOUT_TABLE_ENTRY_SIZE
=
2
*
sizeof
(
void
*
)
;
class
FloatRegisters
:
public
FloatRegistersMIPSShared
{
public
:
static
const
char
*
GetName
(
uint32_t
i
)
{
MOZ_ASSERT
(
i
<
Total
)
;
return
FloatRegistersMIPSShared
:
:
GetName
(
Code
(
i
%
32
)
)
;
}
static
Code
FromName
(
const
char
*
name
)
;
static
const
uint32_t
Total
=
64
;
static
const
uint32_t
TotalDouble
=
16
;
static
const
uint32_t
RegisterIdLimit
=
32
;
#
if
defined
(
_MIPS_ARCH_LOONGSON3A
)
static
const
uint32_t
TotalSingle
=
16
;
static
const
uint32_t
Allocatable
=
28
;
static
const
SetType
AllSingleMask
=
0x55555555ULL
;
#
else
static
const
uint32_t
TotalSingle
=
32
;
static
const
uint32_t
Allocatable
=
42
;
static
const
SetType
AllSingleMask
=
(
1ULL
<
<
32
)
-
1
;
#
endif
static
const
uint32_t
TotalPhys
=
16
;
static_assert
(
sizeof
(
SetType
)
*
8
>
=
Total
"
SetType
should
be
large
enough
to
enumerate
all
registers
.
"
)
;
static
const
SetType
AllDoubleMask
=
0x55555555ULL
<
<
32
;
static
const
SetType
AllMask
=
AllDoubleMask
|
AllSingleMask
;
static
const
SetType
NonVolatileDoubleMask
=
(
(
1ULL
<
<
FloatRegisters
:
:
f20
)
|
(
1ULL
<
<
FloatRegisters
:
:
f22
)
|
(
1ULL
<
<
FloatRegisters
:
:
f24
)
|
(
1ULL
<
<
FloatRegisters
:
:
f26
)
|
(
1ULL
<
<
FloatRegisters
:
:
f28
)
|
(
1ULL
<
<
FloatRegisters
:
:
f30
)
)
<
<
32
;
static
const
SetType
NonVolatileMask
=
NonVolatileDoubleMask
|
(
1ULL
<
<
FloatRegisters
:
:
f20
)
|
(
1ULL
<
<
FloatRegisters
:
:
f21
)
|
(
1ULL
<
<
FloatRegisters
:
:
f22
)
|
(
1ULL
<
<
FloatRegisters
:
:
f23
)
|
(
1ULL
<
<
FloatRegisters
:
:
f24
)
|
(
1ULL
<
<
FloatRegisters
:
:
f25
)
|
(
1ULL
<
<
FloatRegisters
:
:
f26
)
|
(
1ULL
<
<
FloatRegisters
:
:
f27
)
|
(
1ULL
<
<
FloatRegisters
:
:
f28
)
|
(
1ULL
<
<
FloatRegisters
:
:
f29
)
|
(
1ULL
<
<
FloatRegisters
:
:
f30
)
|
(
1ULL
<
<
FloatRegisters
:
:
f31
)
;
static
const
SetType
VolatileMask
=
AllMask
&
~
NonVolatileMask
;
static
const
SetType
VolatileDoubleMask
=
AllDoubleMask
&
~
NonVolatileDoubleMask
;
static
const
SetType
WrapperMask
=
VolatileMask
;
static
const
SetType
NonAllocatableDoubleMask
=
(
(
1ULL
<
<
FloatRegisters
:
:
f16
)
|
(
1ULL
<
<
FloatRegisters
:
:
f18
)
)
<
<
32
;
static
const
SetType
NonAllocatableMask
=
NonAllocatableDoubleMask
|
(
1ULL
<
<
FloatRegisters
:
:
f16
)
|
(
1ULL
<
<
FloatRegisters
:
:
f17
)
|
(
1ULL
<
<
FloatRegisters
:
:
f18
)
|
(
1ULL
<
<
FloatRegisters
:
:
f19
)
;
static
const
SetType
TempMask
=
VolatileMask
&
~
NonAllocatableMask
;
static
const
SetType
AllocatableMask
=
AllMask
&
~
NonAllocatableMask
;
}
;
class
FloatRegister
:
public
FloatRegisterMIPSShared
{
public
:
enum
RegType
{
Single
=
0x0
Double
=
0x1
}
;
typedef
FloatRegisters
Codes
;
typedef
Codes
:
:
Code
Code
;
typedef
Codes
:
:
Encoding
Encoding
;
uint32_t
code_
:
6
;
protected
:
RegType
kind_
:
1
;
public
:
constexpr
FloatRegister
(
uint32_t
code
RegType
kind
=
Double
)
:
code_
(
Code
(
code
)
)
kind_
(
kind
)
{
}
constexpr
FloatRegister
(
)
:
code_
(
Code
(
FloatRegisters
:
:
invalid_freg
)
)
kind_
(
Double
)
{
}
bool
operator
=
=
(
const
FloatRegister
&
other
)
const
{
MOZ_ASSERT
(
!
isInvalid
(
)
)
;
MOZ_ASSERT
(
!
other
.
isInvalid
(
)
)
;
return
kind_
=
=
other
.
kind_
&
&
code_
=
=
other
.
code_
;
}
bool
equiv
(
const
FloatRegister
&
other
)
const
{
return
other
.
kind_
=
=
kind_
;
}
size_t
size
(
)
const
{
return
(
kind_
=
=
Double
)
?
8
:
4
;
}
bool
isInvalid
(
)
const
{
return
code_
=
=
FloatRegisters
:
:
invalid_freg
;
}
bool
isSingle
(
)
const
{
return
kind_
=
=
Single
;
}
bool
isDouble
(
)
const
{
return
kind_
=
=
Double
;
}
FloatRegister
doubleOverlay
(
unsigned
int
which
=
0
)
const
;
FloatRegister
singleOverlay
(
unsigned
int
which
=
0
)
const
;
FloatRegister
sintOverlay
(
unsigned
int
which
=
0
)
const
;
FloatRegister
uintOverlay
(
unsigned
int
which
=
0
)
const
;
FloatRegister
asSingle
(
)
const
{
return
singleOverlay
(
)
;
}
FloatRegister
asDouble
(
)
const
{
return
doubleOverlay
(
)
;
}
FloatRegister
asSimd128
(
)
const
{
MOZ_CRASH
(
"
NYI
"
)
;
}
Code
code
(
)
const
{
MOZ_ASSERT
(
!
isInvalid
(
)
)
;
return
Code
(
code_
|
(
kind_
<
<
5
)
)
;
}
Encoding
encoding
(
)
const
{
MOZ_ASSERT
(
!
isInvalid
(
)
)
;
return
Encoding
(
code_
)
;
}
uint32_t
id
(
)
const
{
return
code_
;
}
static
FloatRegister
FromCode
(
uint32_t
i
)
{
uint32_t
code
=
i
&
31
;
uint32_t
kind
=
i
>
>
5
;
return
FloatRegister
(
code
RegType
(
kind
)
)
;
}
static
FloatRegister
FromIndex
(
uint32_t
index
RegType
kind
)
{
#
if
defined
(
USES_O32_ABI
)
#
if
defined
(
_MIPS_ARCH_LOONGSON3A
)
return
FloatRegister
(
index
*
2
kind
)
;
#
else
if
(
kind
=
=
Double
)
return
FloatRegister
(
index
*
2
kind
)
;
#
endif
#
endif
return
FloatRegister
(
index
kind
)
;
}
bool
volatile_
(
)
const
{
if
(
isDouble
(
)
)
return
!
!
(
(
1ULL
<
<
code_
)
&
FloatRegisters
:
:
VolatileMask
)
;
return
!
!
(
(
1ULL
<
<
(
code_
&
~
1
)
)
&
FloatRegisters
:
:
VolatileMask
)
;
}
const
char
*
name
(
)
const
{
return
FloatRegisters
:
:
GetName
(
code_
)
;
}
bool
operator
!
=
(
const
FloatRegister
&
other
)
const
{
return
other
.
kind_
!
=
kind_
|
|
code_
!
=
other
.
code_
;
}
bool
aliases
(
const
FloatRegister
&
other
)
{
if
(
kind_
=
=
other
.
kind_
)
return
code_
=
=
other
.
code_
;
return
doubleOverlay
(
)
=
=
other
.
doubleOverlay
(
)
;
}
uint32_t
numAliased
(
)
const
{
if
(
isDouble
(
)
)
{
MOZ_ASSERT
(
(
code_
&
1
)
=
=
0
)
;
return
3
;
}
return
2
;
}
void
aliased
(
uint32_t
aliasIdx
FloatRegister
*
ret
)
{
if
(
aliasIdx
=
=
0
)
{
*
ret
=
*
this
;
return
;
}
if
(
isDouble
(
)
)
{
MOZ_ASSERT
(
(
code_
&
1
)
=
=
0
)
;
MOZ_ASSERT
(
aliasIdx
<
=
2
)
;
*
ret
=
singleOverlay
(
aliasIdx
-
1
)
;
return
;
}
MOZ_ASSERT
(
aliasIdx
=
=
1
)
;
*
ret
=
doubleOverlay
(
aliasIdx
-
1
)
;
}
uint32_t
numAlignedAliased
(
)
const
{
if
(
isDouble
(
)
)
{
MOZ_ASSERT
(
(
code_
&
1
)
=
=
0
)
;
return
2
;
}
return
2
-
(
code_
&
1
)
;
}
void
alignedAliased
(
uint32_t
aliasIdx
FloatRegister
*
ret
)
{
MOZ_ASSERT
(
isDouble
(
)
)
;
MOZ_ASSERT
(
(
code_
&
1
)
=
=
0
)
;
if
(
aliasIdx
=
=
0
)
{
*
ret
=
*
this
;
return
;
}
MOZ_ASSERT
(
aliasIdx
=
=
1
)
;
*
ret
=
singleOverlay
(
aliasIdx
-
1
)
;
}
SetType
alignedOrDominatedAliasedSet
(
)
const
{
if
(
isSingle
(
)
)
return
SetType
(
1
)
<
<
code_
;
MOZ_ASSERT
(
isDouble
(
)
)
;
return
SetType
(
0b11
)
<
<
code_
;
}
static
constexpr
RegTypeName
DefaultType
=
RegTypeName
:
:
Float64
;
template
<
RegTypeName
=
DefaultType
>
static
SetType
LiveAsIndexableSet
(
SetType
s
)
{
return
SetType
(
0
)
;
}
template
<
RegTypeName
Name
=
DefaultType
>
static
SetType
AllocatableAsIndexableSet
(
SetType
s
)
{
static_assert
(
Name
!
=
RegTypeName
:
:
Any
"
Allocatable
set
are
not
iterable
"
)
;
return
LiveAsIndexableSet
<
Name
>
(
s
)
;
}
static
Code
FromName
(
const
char
*
name
)
{
return
FloatRegisters
:
:
FromName
(
name
)
;
}
static
TypedRegisterSet
<
FloatRegister
>
ReduceSetForPush
(
const
TypedRegisterSet
<
FloatRegister
>
&
s
)
;
static
uint32_t
GetPushSizeInBytes
(
const
TypedRegisterSet
<
FloatRegister
>
&
s
)
;
uint32_t
getRegisterDumpOffsetInBytes
(
)
;
}
;
template
<
>
inline
FloatRegister
:
:
SetType
FloatRegister
:
:
LiveAsIndexableSet
<
RegTypeName
:
:
Float32
>
(
SetType
set
)
{
return
set
&
FloatRegisters
:
:
AllSingleMask
;
}
template
<
>
inline
FloatRegister
:
:
SetType
FloatRegister
:
:
LiveAsIndexableSet
<
RegTypeName
:
:
Float64
>
(
SetType
set
)
{
return
set
&
FloatRegisters
:
:
AllDoubleMask
;
}
template
<
>
inline
FloatRegister
:
:
SetType
FloatRegister
:
:
LiveAsIndexableSet
<
RegTypeName
:
:
Any
>
(
SetType
set
)
{
return
set
;
}
#
define
JS_CODEGEN_REGISTER_PAIR
1
}
}
#
endif
