#
include
"
jit
/
IonCompileTask
.
h
"
#
include
"
jit
/
CodeGenerator
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JitScript
.
h
"
#
include
"
jit
/
WarpSnapshot
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
void
IonCompileTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
{
alloc
(
)
.
lifoAlloc
(
)
-
>
setReadWrite
(
)
;
{
AutoUnlockHelperThreadState
unlock
(
locked
)
;
runTask
(
)
;
}
FinishOffThreadIonCompile
(
this
locked
)
;
JSRuntime
*
rt
=
script
(
)
-
>
runtimeFromAnyThread
(
)
;
rt
-
>
mainContextFromAnyThread
(
)
-
>
requestInterrupt
(
InterruptReason
:
:
AttachIonCompilations
)
;
}
void
IonCompileTask
:
:
runTask
(
)
{
jit
:
:
JitContext
jctx
(
mirGen_
.
realm
-
>
runtime
(
)
)
;
setBackgroundCodegen
(
jit
:
:
CompileBackEnd
(
&
mirGen_
snapshot_
)
)
;
}
void
IonCompileTask
:
:
trace
(
JSTracer
*
trc
)
{
if
(
!
mirGen_
.
runtime
-
>
runtimeMatches
(
trc
-
>
runtime
(
)
)
)
{
return
;
}
snapshot_
-
>
trace
(
trc
)
;
}
IonCompileTask
:
:
IonCompileTask
(
JSContext
*
cx
MIRGenerator
&
mirGen
WarpSnapshot
*
snapshot
)
:
mirGen_
(
mirGen
)
snapshot_
(
snapshot
)
isExecuting_
(
cx
-
>
isExecutingRef
(
)
)
{
}
size_t
IonCompileTask
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
result
=
alloc
(
)
.
lifoAlloc
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
backgroundCodegen_
)
{
result
+
=
mallocSizeOf
(
backgroundCodegen_
)
;
}
return
result
;
}
static
inline
bool
TooManyUnlinkedTasks
(
JSRuntime
*
rt
)
{
static
const
size_t
MaxUnlinkedTasks
=
100
;
return
rt
-
>
jitRuntime
(
)
-
>
ionLazyLinkListSize
(
)
>
MaxUnlinkedTasks
;
}
static
void
MoveFinishedTasksToLazyLinkList
(
JSRuntime
*
rt
const
AutoLockHelperThreadState
&
lock
)
{
GlobalHelperThreadState
:
:
IonCompileTaskVector
&
finished
=
HelperThreadState
(
)
.
ionFinishedList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
finished
.
length
(
)
;
i
+
+
)
{
IonCompileTask
*
task
=
finished
[
i
]
;
if
(
task
-
>
script
(
)
-
>
runtimeFromAnyThread
(
)
!
=
rt
)
{
continue
;
}
HelperThreadState
(
)
.
remove
(
finished
&
i
)
;
rt
-
>
jitRuntime
(
)
-
>
numFinishedOffThreadTasksRef
(
lock
)
-
-
;
JSScript
*
script
=
task
-
>
script
(
)
;
MOZ_ASSERT
(
script
-
>
hasBaselineScript
(
)
)
;
script
-
>
baselineScript
(
)
-
>
setPendingIonCompileTask
(
rt
script
task
)
;
rt
-
>
jitRuntime
(
)
-
>
ionLazyLinkListAdd
(
rt
task
)
;
}
}
static
void
EagerlyLinkExcessTasks
(
JSContext
*
cx
AutoLockHelperThreadState
&
lock
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
MOZ_ASSERT
(
TooManyUnlinkedTasks
(
rt
)
)
;
do
{
jit
:
:
IonCompileTask
*
task
=
rt
-
>
jitRuntime
(
)
-
>
ionLazyLinkList
(
rt
)
.
getLast
(
)
;
RootedScript
script
(
cx
task
-
>
script
(
)
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
AutoRealm
ar
(
cx
script
)
;
jit
:
:
LinkIonScript
(
cx
script
)
;
}
while
(
TooManyUnlinkedTasks
(
rt
)
)
;
}
void
jit
:
:
AttachFinishedCompilations
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
if
(
!
rt
-
>
jitRuntime
(
)
|
|
!
rt
-
>
jitRuntime
(
)
-
>
numFinishedOffThreadTasks
(
)
)
{
return
;
}
AutoLockHelperThreadState
lock
;
while
(
true
)
{
MoveFinishedTasksToLazyLinkList
(
rt
lock
)
;
if
(
!
TooManyUnlinkedTasks
(
rt
)
)
{
break
;
}
EagerlyLinkExcessTasks
(
cx
lock
)
;
}
MOZ_ASSERT
(
!
rt
-
>
jitRuntime
(
)
-
>
numFinishedOffThreadTasks
(
)
)
;
}
void
jit
:
:
FreeIonCompileTask
(
IonCompileTask
*
task
)
{
js_delete
(
task
-
>
backgroundCodegen
(
)
)
;
js_delete
(
task
-
>
alloc
(
)
.
lifoAlloc
(
)
)
;
}
void
IonFreeTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
{
{
AutoUnlockHelperThreadState
unlock
(
locked
)
;
jit
:
:
FreeIonCompileTask
(
task_
)
;
}
js_delete
(
this
)
;
}
void
jit
:
:
FinishOffThreadTask
(
JSRuntime
*
runtime
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
locked
)
{
MOZ_ASSERT
(
runtime
)
;
JSScript
*
script
=
task
-
>
script
(
)
;
if
(
script
-
>
baselineScript
(
)
-
>
hasPendingIonCompileTask
(
)
&
&
script
-
>
baselineScript
(
)
-
>
pendingIonCompileTask
(
)
=
=
task
)
{
script
-
>
baselineScript
(
)
-
>
removePendingIonCompileTask
(
runtime
script
)
;
}
if
(
task
-
>
isInList
(
)
)
{
runtime
-
>
jitRuntime
(
)
-
>
ionLazyLinkListRemove
(
runtime
task
)
;
}
if
(
script
-
>
isIonCompilingOffThread
(
)
)
{
script
-
>
jitScript
(
)
-
>
clearIsIonCompilingOffThread
(
script
)
;
const
AbortReasonOr
<
Ok
>
&
status
=
task
-
>
mirGen
(
)
.
getOffThreadStatus
(
)
;
if
(
status
.
isErr
(
)
&
&
status
.
inspectErr
(
)
=
=
AbortReason
:
:
Disable
)
{
script
-
>
disableIon
(
)
;
}
}
if
(
!
StartOffThreadIonFree
(
task
locked
)
)
{
FreeIonCompileTask
(
task
)
;
}
}
