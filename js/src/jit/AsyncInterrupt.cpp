#
include
"
jit
/
AsyncInterrupt
.
h
"
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
util
/
Windows
.
h
"
#
if
defined
(
ANDROID
)
#
include
<
sys
/
system_properties
.
h
>
#
endif
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
PodArrayZero
;
static
void
RedirectIonBackedgesToInterruptCheck
(
JSContext
*
cx
)
{
if
(
cx
!
=
cx
-
>
runtime
(
)
-
>
activeContext
(
)
)
return
;
AutoNoteSingleThreadedRegion
anstr
;
Zone
*
zone
=
cx
-
>
zoneRaw
(
)
;
if
(
zone
&
&
!
zone
-
>
isAtomsZone
(
)
)
{
jit
:
:
JitRuntime
*
jitRuntime
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
;
if
(
!
jitRuntime
)
return
;
if
(
!
jitRuntime
-
>
preventBackedgePatching
(
)
)
{
jit
:
:
JitZoneGroup
*
jzg
=
zone
-
>
group
(
)
-
>
jitZoneGroup
;
jzg
-
>
patchIonBackedges
(
cx
jit
:
:
JitZoneGroup
:
:
BackedgeInterruptCheck
)
;
}
}
}
#
if
!
defined
(
XP_WIN
)
static
const
int
sJitAsyncInterruptSignal
=
SIGVTALRM
;
static
void
JitAsyncInterruptHandler
(
int
signum
siginfo_t
*
void
*
)
{
MOZ_RELEASE_ASSERT
(
signum
=
=
sJitAsyncInterruptSignal
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
if
(
!
cx
)
return
;
#
if
defined
(
JS_SIMULATOR_ARM
)
|
|
defined
(
JS_SIMULATOR_MIPS32
)
|
|
defined
(
JS_SIMULATOR_MIPS64
)
SimulatorProcess
:
:
ICacheCheckingDisableCount
+
+
;
#
endif
RedirectIonBackedgesToInterruptCheck
(
cx
)
;
#
if
defined
(
JS_SIMULATOR_ARM
)
|
|
defined
(
JS_SIMULATOR_MIPS32
)
|
|
defined
(
JS_SIMULATOR_MIPS64
)
SimulatorProcess
:
:
cacheInvalidatedBySignalHandler_
=
true
;
SimulatorProcess
:
:
ICacheCheckingDisableCount
-
-
;
#
endif
cx
-
>
finishHandlingJitInterrupt
(
)
;
}
#
endif
static
bool
sTriedInstallAsyncInterrupt
=
false
;
static
bool
sHaveAsyncInterrupt
=
false
;
bool
jit
:
:
EnsureAsyncInterrupt
(
JSContext
*
cx
)
{
if
(
sTriedInstallAsyncInterrupt
)
return
sHaveAsyncInterrupt
;
sTriedInstallAsyncInterrupt
=
true
;
#
if
defined
(
ANDROID
)
&
&
!
defined
(
__aarch64__
)
char
version_string
[
PROP_VALUE_MAX
]
;
PodArrayZero
(
version_string
)
;
if
(
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
version_string
)
>
0
)
{
if
(
atol
(
version_string
)
<
19
)
return
false
;
}
#
endif
#
if
defined
(
XP_WIN
)
#
else
struct
sigaction
interruptHandler
;
interruptHandler
.
sa_flags
=
SA_SIGINFO
;
interruptHandler
.
sa_sigaction
=
&
JitAsyncInterruptHandler
;
sigemptyset
(
&
interruptHandler
.
sa_mask
)
;
struct
sigaction
prev
;
if
(
sigaction
(
sJitAsyncInterruptSignal
&
interruptHandler
&
prev
)
)
MOZ_CRASH
(
"
unable
to
install
interrupt
handler
"
)
;
if
(
(
prev
.
sa_flags
&
SA_SIGINFO
&
&
prev
.
sa_sigaction
)
|
|
(
prev
.
sa_handler
!
=
SIG_DFL
&
&
prev
.
sa_handler
!
=
SIG_IGN
)
)
{
MOZ_CRASH
(
"
contention
for
interrupt
signal
"
)
;
}
#
endif
sHaveAsyncInterrupt
=
true
;
return
true
;
}
bool
jit
:
:
HaveAsyncInterrupt
(
)
{
MOZ_ASSERT
(
sTriedInstallAsyncInterrupt
)
;
return
sHaveAsyncInterrupt
;
}
void
jit
:
:
InterruptRunningCode
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
sTriedInstallAsyncInterrupt
)
;
if
(
!
sHaveAsyncInterrupt
)
return
;
if
(
!
cx
-
>
startHandlingJitInterrupt
(
)
)
return
;
if
(
cx
=
=
TlsContext
.
get
(
)
)
{
RedirectIonBackedgesToInterruptCheck
(
cx
)
;
cx
-
>
finishHandlingJitInterrupt
(
)
;
return
;
}
#
if
defined
(
XP_WIN
)
HANDLE
thread
=
(
HANDLE
)
cx
-
>
threadNative
(
)
;
if
(
SuspendThread
(
thread
)
!
=
(
DWORD
)
-
1
)
{
RedirectIonBackedgesToInterruptCheck
(
cx
)
;
ResumeThread
(
thread
)
;
}
cx
-
>
finishHandlingJitInterrupt
(
)
;
#
else
pthread_t
thread
=
(
pthread_t
)
cx
-
>
threadNative
(
)
;
pthread_kill
(
thread
sJitAsyncInterruptSignal
)
;
#
endif
}
