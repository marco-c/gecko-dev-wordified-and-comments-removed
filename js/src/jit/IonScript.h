#
ifndef
jit_IonScript_h
#
define
jit_IonScript_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
namespace
js
{
namespace
jit
{
class
SnapshotWriter
;
class
RecoverWriter
;
class
SafepointWriter
;
class
CodegenSafepointIndex
;
class
SafepointIndex
;
class
OsiIndex
;
class
IonIC
;
class
alignas
(
8
)
IonScript
final
:
public
TrailingArray
<
IonScript
>
{
private
:
Offset
constantTableOffset_
=
0
;
Offset
runtimeDataOffset_
=
0
;
Offset
nurseryObjectsOffset_
=
0
;
Offset
osiIndexOffset_
=
0
;
Offset
safepointIndexOffset_
=
0
;
Offset
icIndexOffset_
=
0
;
Offset
safepointsOffset_
=
0
;
Offset
snapshotsOffset_
=
0
;
Offset
rvaTableOffset_
=
0
;
Offset
recoversOffset_
=
0
;
Offset
allocBytes_
=
0
;
HeapPtr
<
JitCode
*
>
method_
=
nullptr
;
jsbytecode
*
osrPc_
=
nullptr
;
uint32_t
osrEntryOffset_
=
0
;
uint32_t
invalidateEpilogueOffset_
=
0
;
uint32_t
invalidateEpilogueDataOffset_
=
0
;
uint16_t
numFixableBailouts_
=
0
;
uint16_t
numUnfixableBailouts_
=
0
;
public
:
enum
class
LICMState
:
uint8_t
{
NeverBailed
Bailed
BailedAndHitFallback
}
;
private
:
LICMState
licmState_
=
LICMState
:
:
NeverBailed
;
bool
hasProfilingInstrumentation_
=
false
;
bool
purgedICScripts_
=
false
;
uint32_t
localSlotsSize_
=
0
;
uint32_t
argumentSlotsSize_
=
0
;
uint32_t
frameSize_
=
0
;
uint32_t
invalidationCount_
=
0
;
IonCompilationId
compilationId_
;
uint32_t
osrPcMismatchCounter_
=
0
;
#
ifdef
DEBUG
mozilla
:
:
HashNumber
icHash_
=
0
;
#
endif
private
:
Offset
constantTableOffset
(
)
const
{
return
constantTableOffset_
;
}
Offset
runtimeDataOffset
(
)
const
{
return
runtimeDataOffset_
;
}
Offset
nurseryObjectsOffset
(
)
const
{
return
nurseryObjectsOffset_
;
}
Offset
osiIndexOffset
(
)
const
{
return
osiIndexOffset_
;
}
Offset
safepointIndexOffset
(
)
const
{
return
safepointIndexOffset_
;
}
Offset
icIndexOffset
(
)
const
{
return
icIndexOffset_
;
}
Offset
safepointsOffset
(
)
const
{
return
safepointsOffset_
;
}
Offset
snapshotsOffset
(
)
const
{
return
snapshotsOffset_
;
}
Offset
rvaTableOffset
(
)
const
{
return
rvaTableOffset_
;
}
Offset
recoversOffset
(
)
const
{
return
recoversOffset_
;
}
Offset
endOffset
(
)
const
{
return
allocBytes_
;
}
static
constexpr
size_t
SizeOf_OsiIndex
=
2
*
sizeof
(
uint32_t
)
;
static
constexpr
size_t
SizeOf_SafepointIndex
=
2
*
sizeof
(
uint32_t
)
;
public
:
HeapPtr
<
Value
>
*
constants
(
)
{
return
offsetToPointer
<
HeapPtr
<
Value
>
>
(
constantTableOffset
(
)
)
;
}
size_t
numConstants
(
)
const
{
return
numElements
<
HeapPtr
<
Value
>
>
(
constantTableOffset
(
)
runtimeDataOffset
(
)
)
;
}
uint8_t
*
runtimeData
(
)
{
return
offsetToPointer
<
uint8_t
>
(
runtimeDataOffset
(
)
)
;
}
size_t
runtimeSize
(
)
const
{
return
numElements
<
uint8_t
>
(
runtimeDataOffset
(
)
nurseryObjectsOffset
(
)
)
;
}
HeapPtr
<
JSObject
*
>
*
nurseryObjects
(
)
{
return
offsetToPointer
<
HeapPtr
<
JSObject
*
>
>
(
nurseryObjectsOffset
(
)
)
;
}
size_t
numNurseryObjects
(
)
const
{
return
numElements
<
HeapPtr
<
JSObject
*
>
>
(
nurseryObjectsOffset
(
)
osiIndexOffset
(
)
)
;
}
void
*
addressOfNurseryObject
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
numNurseryObjects
(
)
)
;
return
&
nurseryObjects
(
)
[
index
]
;
}
OsiIndex
*
osiIndices
(
)
{
return
offsetToPointer
<
OsiIndex
>
(
osiIndexOffset
(
)
)
;
}
const
OsiIndex
*
osiIndices
(
)
const
{
return
offsetToPointer
<
OsiIndex
>
(
osiIndexOffset
(
)
)
;
}
size_t
numOsiIndices
(
)
const
{
return
numElements
<
SizeOf_OsiIndex
>
(
osiIndexOffset
(
)
safepointIndexOffset
(
)
)
;
}
SafepointIndex
*
safepointIndices
(
)
{
return
offsetToPointer
<
SafepointIndex
>
(
safepointIndexOffset
(
)
)
;
}
const
SafepointIndex
*
safepointIndices
(
)
const
{
return
offsetToPointer
<
SafepointIndex
>
(
safepointIndexOffset
(
)
)
;
}
size_t
numSafepointIndices
(
)
const
{
return
numElements
<
SizeOf_SafepointIndex
>
(
safepointIndexOffset
(
)
icIndexOffset
(
)
)
;
}
uint32_t
*
icIndex
(
)
{
return
offsetToPointer
<
uint32_t
>
(
icIndexOffset
(
)
)
;
}
size_t
numICs
(
)
const
{
return
numElements
<
uint32_t
>
(
icIndexOffset
(
)
safepointsOffset
(
)
)
;
}
const
uint8_t
*
safepoints
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
safepointsOffset
(
)
)
;
}
size_t
safepointsSize
(
)
const
{
return
numElements
<
uint8_t
>
(
safepointsOffset
(
)
snapshotsOffset
(
)
)
;
}
const
uint8_t
*
snapshots
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
snapshotsOffset
(
)
)
;
}
size_t
snapshotsListSize
(
)
const
{
return
numElements
<
uint8_t
>
(
snapshotsOffset
(
)
rvaTableOffset
(
)
)
;
}
size_t
snapshotsRVATableSize
(
)
const
{
return
numElements
<
uint8_t
>
(
rvaTableOffset
(
)
recoversOffset
(
)
)
;
}
const
uint8_t
*
recovers
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
recoversOffset
(
)
)
;
}
size_t
recoversSize
(
)
const
{
return
numElements
<
uint8_t
>
(
recoversOffset
(
)
endOffset
(
)
)
;
}
private
:
IonScript
(
IonCompilationId
compilationId
uint32_t
localSlotsSize
uint32_t
argumentSlotsSize
uint32_t
frameSize
)
;
public
:
static
IonScript
*
New
(
JSContext
*
cx
IonCompilationId
compilationId
uint32_t
localSlotsSize
uint32_t
argumentSlotsSize
uint32_t
frameSize
size_t
snapshotsListSize
size_t
snapshotsRVATableSize
size_t
recoversSize
size_t
constants
size_t
nurseryObjects
size_t
safepointIndices
size_t
osiIndices
size_t
icEntries
size_t
runtimeSize
size_t
safepointsSize
)
;
static
void
Destroy
(
JS
:
:
GCContext
*
gcx
IonScript
*
script
)
;
void
trace
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
static
inline
size_t
offsetOfInvalidationCount
(
)
{
return
offsetof
(
IonScript
invalidationCount_
)
;
}
public
:
JitCode
*
method
(
)
const
{
return
method_
;
}
void
setMethod
(
JitCode
*
code
)
{
MOZ_ASSERT
(
!
invalidated
(
)
)
;
method_
=
code
;
}
void
setOsrPc
(
jsbytecode
*
osrPc
)
{
osrPc_
=
osrPc
;
}
jsbytecode
*
osrPc
(
)
const
{
return
osrPc_
;
}
void
setOsrEntryOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
osrEntryOffset_
)
;
osrEntryOffset_
=
offset
;
}
uint32_t
osrEntryOffset
(
)
const
{
return
osrEntryOffset_
;
}
bool
containsCodeAddress
(
uint8_t
*
addr
)
const
{
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
bool
containsReturnAddress
(
uint8_t
*
addr
)
const
{
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
void
setInvalidationEpilogueOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
invalidateEpilogueOffset_
)
;
invalidateEpilogueOffset_
=
offset
;
}
uint32_t
invalidateEpilogueOffset
(
)
const
{
MOZ_ASSERT
(
invalidateEpilogueOffset_
)
;
return
invalidateEpilogueOffset_
;
}
void
setInvalidationEpilogueDataOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
invalidateEpilogueDataOffset_
)
;
invalidateEpilogueDataOffset_
=
offset
;
}
uint32_t
invalidateEpilogueDataOffset
(
)
const
{
MOZ_ASSERT
(
invalidateEpilogueDataOffset_
)
;
return
invalidateEpilogueDataOffset_
;
}
uint32_t
numFixableBailouts
(
)
const
{
return
numFixableBailouts_
;
}
void
incNumFixableBailouts
(
)
{
numFixableBailouts_
+
+
;
}
void
resetNumFixableBailouts
(
)
{
numFixableBailouts_
=
0
;
}
void
incNumUnfixableBailouts
(
)
{
numUnfixableBailouts_
+
+
;
}
bool
shouldInvalidate
(
)
const
{
return
numFixableBailouts_
>
=
JitOptions
.
frequentBailoutThreshold
;
}
bool
shouldInvalidateAndDisable
(
)
const
{
return
numUnfixableBailouts_
>
=
JitOptions
.
frequentBailoutThreshold
*
5
;
}
LICMState
licmState
(
)
const
{
return
licmState_
;
}
void
setHadLICMBailout
(
)
{
if
(
licmState_
=
=
LICMState
:
:
NeverBailed
)
{
licmState_
=
LICMState
:
:
Bailed
;
}
}
void
noteBaselineFallback
(
)
{
if
(
licmState_
=
=
LICMState
:
:
Bailed
)
{
licmState_
=
LICMState
:
:
BailedAndHitFallback
;
}
}
void
setHasProfilingInstrumentation
(
)
{
hasProfilingInstrumentation_
=
true
;
}
void
clearHasProfilingInstrumentation
(
)
{
hasProfilingInstrumentation_
=
false
;
}
bool
hasProfilingInstrumentation
(
)
const
{
return
hasProfilingInstrumentation_
;
}
bool
purgedICScripts
(
)
const
{
return
purgedICScripts_
;
}
void
notePurgedICScripts
(
)
{
purgedICScripts_
=
true
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
HeapPtr
<
Value
>
&
getConstant
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numConstants
(
)
)
;
return
constants
(
)
[
index
]
;
}
uint32_t
localSlotsSize
(
)
const
{
return
localSlotsSize_
;
}
uint32_t
argumentSlotsSize
(
)
const
{
return
argumentSlotsSize_
;
}
uint32_t
frameSize
(
)
const
{
return
frameSize_
;
}
const
SafepointIndex
*
getSafepointIndex
(
uint32_t
disp
)
const
;
const
SafepointIndex
*
getSafepointIndex
(
uint8_t
*
retAddr
)
const
{
MOZ_ASSERT
(
containsCodeAddress
(
retAddr
)
)
;
return
getSafepointIndex
(
retAddr
-
method
(
)
-
>
raw
(
)
)
;
}
const
OsiIndex
*
getOsiIndex
(
uint32_t
disp
)
const
;
const
OsiIndex
*
getOsiIndex
(
uint8_t
*
retAddr
)
const
;
IonIC
&
getICFromIndex
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
numICs
(
)
)
;
uint32_t
offset
=
icIndex
(
)
[
index
]
;
return
getIC
(
offset
)
;
}
inline
IonIC
&
getIC
(
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
runtimeSize
(
)
)
;
return
*
reinterpret_cast
<
IonIC
*
>
(
runtimeData
(
)
+
offset
)
;
}
void
purgeICs
(
Zone
*
zone
)
;
void
copySnapshots
(
const
SnapshotWriter
*
writer
)
;
void
copyRecovers
(
const
RecoverWriter
*
writer
)
;
void
copyConstants
(
const
Value
*
vp
)
;
void
copySafepointIndices
(
const
CodegenSafepointIndex
*
si
)
;
void
copyOsiIndices
(
const
OsiIndex
*
oi
)
;
void
copyRuntimeData
(
const
uint8_t
*
data
)
;
void
copyICEntries
(
const
uint32_t
*
icEntries
)
;
void
copySafepoints
(
const
SafepointWriter
*
writer
)
;
bool
invalidated
(
)
const
{
return
invalidationCount_
!
=
0
;
}
void
invalidate
(
JSContext
*
cx
JSScript
*
script
bool
resetUses
const
char
*
reason
)
;
size_t
invalidationCount
(
)
const
{
return
invalidationCount_
;
}
void
incrementInvalidationCount
(
)
{
invalidationCount_
+
+
;
}
void
decrementInvalidationCount
(
JS
:
:
GCContext
*
gcx
)
{
MOZ_ASSERT
(
invalidationCount_
)
;
invalidationCount_
-
-
;
if
(
!
invalidationCount_
)
{
Destroy
(
gcx
this
)
;
}
}
IonCompilationId
compilationId
(
)
const
{
return
compilationId_
;
}
uint32_t
incrOsrPcMismatchCounter
(
)
{
return
+
+
osrPcMismatchCounter_
;
}
void
resetOsrPcMismatchCounter
(
)
{
osrPcMismatchCounter_
=
0
;
}
size_t
allocBytes
(
)
const
{
return
allocBytes_
;
}
static
void
preWriteBarrier
(
Zone
*
zone
IonScript
*
ionScript
)
;
#
ifdef
DEBUG
mozilla
:
:
HashNumber
icHash
(
)
const
{
return
icHash_
;
}
void
setICHash
(
mozilla
:
:
HashNumber
hash
)
{
icHash_
=
hash
;
}
#
endif
}
;
struct
IonBlockCounts
{
private
:
uint32_t
id_
;
uint32_t
offset_
;
char
*
description_
;
uint32_t
numSuccessors_
;
uint32_t
*
successors_
;
uint64_t
hitCount_
;
char
*
code_
;
public
:
[
[
nodiscard
]
]
bool
init
(
uint32_t
id
uint32_t
offset
char
*
description
uint32_t
numSuccessors
)
{
id_
=
id
;
offset_
=
offset
;
description_
=
description
;
numSuccessors_
=
numSuccessors
;
if
(
numSuccessors
)
{
successors_
=
js_pod_calloc
<
uint32_t
>
(
numSuccessors
)
;
if
(
!
successors_
)
{
return
false
;
}
}
return
true
;
}
void
destroy
(
)
{
js_free
(
description_
)
;
js_free
(
successors_
)
;
js_free
(
code_
)
;
}
uint32_t
id
(
)
const
{
return
id_
;
}
uint32_t
offset
(
)
const
{
return
offset_
;
}
const
char
*
description
(
)
const
{
return
description_
;
}
size_t
numSuccessors
(
)
const
{
return
numSuccessors_
;
}
void
setSuccessor
(
size_t
i
uint32_t
id
)
{
MOZ_ASSERT
(
i
<
numSuccessors_
)
;
successors_
[
i
]
=
id
;
}
uint32_t
successor
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
numSuccessors_
)
;
return
successors_
[
i
]
;
}
uint64_t
*
addressOfHitCount
(
)
{
return
&
hitCount_
;
}
uint64_t
hitCount
(
)
const
{
return
hitCount_
;
}
void
setCode
(
const
char
*
code
)
{
char
*
ncode
=
js_pod_malloc
<
char
>
(
strlen
(
code
)
+
1
)
;
if
(
ncode
)
{
strcpy
(
ncode
code
)
;
code_
=
ncode
;
}
}
const
char
*
code
(
)
const
{
return
code_
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
description_
)
+
mallocSizeOf
(
successors_
)
+
mallocSizeOf
(
code_
)
;
}
}
;
struct
IonScriptCounts
{
private
:
IonScriptCounts
*
previous_
=
nullptr
;
size_t
numBlocks_
=
0
;
IonBlockCounts
*
blocks_
=
nullptr
;
public
:
IonScriptCounts
(
)
=
default
;
~
IonScriptCounts
(
)
{
for
(
size_t
i
=
0
;
i
<
numBlocks_
;
i
+
+
)
{
blocks_
[
i
]
.
destroy
(
)
;
}
js_free
(
blocks_
)
;
IonScriptCounts
*
victims
=
previous_
;
while
(
victims
)
{
IonScriptCounts
*
victim
=
victims
;
victims
=
victim
-
>
previous_
;
victim
-
>
previous_
=
nullptr
;
js_delete
(
victim
)
;
}
}
[
[
nodiscard
]
]
bool
init
(
size_t
numBlocks
)
{
blocks_
=
js_pod_calloc
<
IonBlockCounts
>
(
numBlocks
)
;
if
(
!
blocks_
)
{
return
false
;
}
numBlocks_
=
numBlocks
;
return
true
;
}
size_t
numBlocks
(
)
const
{
return
numBlocks_
;
}
IonBlockCounts
&
block
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
numBlocks_
)
;
return
blocks_
[
i
]
;
}
void
setPrevious
(
IonScriptCounts
*
previous
)
{
previous_
=
previous
;
}
IonScriptCounts
*
previous
(
)
const
{
return
previous_
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
auto
currCounts
=
this
;
do
{
size
+
=
currCounts
-
>
sizeOfOneIncludingThis
(
mallocSizeOf
)
;
currCounts
=
currCounts
-
>
previous_
;
}
while
(
currCounts
)
;
return
size
;
}
size_t
sizeOfOneIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
mallocSizeOf
(
this
)
+
mallocSizeOf
(
blocks_
)
;
for
(
size_t
i
=
0
;
i
<
numBlocks_
;
i
+
+
)
{
blocks_
[
i
]
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
}
;
}
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
jit
:
:
IonScript
>
{
explicit
DeletePolicy
(
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
void
operator
(
)
(
const
js
:
:
jit
:
:
IonScript
*
script
)
;
private
:
JSRuntime
*
rt_
;
}
;
}
#
endif
