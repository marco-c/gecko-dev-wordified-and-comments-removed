#
ifndef
jit_JitCompartment_h
#
define
jit_JitCompartment_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
builtin
/
SIMD
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
class
FrameSizeClass
;
enum
EnterJitType
{
EnterJitBaseline
=
0
EnterJitOptimized
=
1
}
;
struct
EnterJitData
{
explicit
EnterJitData
(
JSContext
*
cx
)
:
scopeChain
(
cx
)
result
(
cx
)
{
}
uint8_t
*
jitcode
;
InterpreterFrame
*
osrFrame
;
void
*
calleeToken
;
Value
*
maxArgv
;
unsigned
maxArgc
;
unsigned
numActualArgs
;
unsigned
osrNumStackValues
;
RootedObject
scopeChain
;
RootedValue
result
;
bool
constructing
;
}
;
typedef
void
(
*
EnterJitCode
)
(
void
*
code
unsigned
argc
Value
*
argv
InterpreterFrame
*
fp
CalleeToken
calleeToken
JSObject
*
scopeChain
size_t
numStackValues
Value
*
vp
)
;
class
JitcodeGlobalTable
;
class
PatchableBackedge
:
public
InlineListNode
<
PatchableBackedge
>
{
friend
class
JitRuntime
;
CodeLocationJump
backedge
;
CodeLocationLabel
loopHeader
;
CodeLocationLabel
interruptCheck
;
public
:
PatchableBackedge
(
CodeLocationJump
backedge
CodeLocationLabel
loopHeader
CodeLocationLabel
interruptCheck
)
:
backedge
(
backedge
)
loopHeader
(
loopHeader
)
interruptCheck
(
interruptCheck
)
{
}
}
;
class
JitRuntime
{
public
:
enum
BackedgeTarget
{
BackedgeLoopHeader
BackedgeInterruptCheck
}
;
private
:
friend
class
JitCompartment
;
ExecutableAllocator
execAlloc_
;
ExecutableAllocator
backedgeExecAlloc_
;
JitCode
*
exceptionTail_
;
JitCode
*
bailoutTail_
;
JitCode
*
profilerExitFrameTail_
;
JitCode
*
enterJIT_
;
JitCode
*
enterBaselineJIT_
;
Vector
<
JitCode
*
4
SystemAllocPolicy
>
bailoutTables_
;
JitCode
*
bailoutHandler_
;
JitCode
*
argumentsRectifier_
;
void
*
argumentsRectifierReturnAddr_
;
JitCode
*
invalidator_
;
JitCode
*
valuePreBarrier_
;
JitCode
*
stringPreBarrier_
;
JitCode
*
objectPreBarrier_
;
JitCode
*
shapePreBarrier_
;
JitCode
*
objectGroupPreBarrier_
;
JitCode
*
mallocStub_
;
JitCode
*
freeStub_
;
JitCode
*
lazyLinkStub_
;
JitCode
*
debugTrapHandler_
;
JitCode
*
baselineDebugModeOSRHandler_
;
void
*
baselineDebugModeOSRHandlerNoFrameRegPopAddr_
;
typedef
GCRekeyableHashMap
<
const
VMFunction
*
JitCode
*
>
VMWrapperMap
;
VMWrapperMap
*
functionWrappers_
;
uint8_t
*
osrTempData_
;
mozilla
:
:
Atomic
<
bool
>
preventBackedgePatching_
;
BackedgeTarget
backedgeTarget_
;
InlineList
<
PatchableBackedge
>
backedgeList_
;
js
:
:
Value
ionReturnOverride_
;
JitcodeGlobalTable
*
jitcodeGlobalTable_
;
private
:
JitCode
*
generateLazyLinkStub
(
JSContext
*
cx
)
;
JitCode
*
generateProfilerExitFrameTailStub
(
JSContext
*
cx
)
;
JitCode
*
generateExceptionTailStub
(
JSContext
*
cx
void
*
handler
)
;
JitCode
*
generateBailoutTailStub
(
JSContext
*
cx
)
;
JitCode
*
generateEnterJIT
(
JSContext
*
cx
EnterJitType
type
)
;
JitCode
*
generateArgumentsRectifier
(
JSContext
*
cx
void
*
*
returnAddrOut
)
;
JitCode
*
generateBailoutTable
(
JSContext
*
cx
uint32_t
frameClass
)
;
JitCode
*
generateBailoutHandler
(
JSContext
*
cx
)
;
JitCode
*
generateInvalidator
(
JSContext
*
cx
)
;
JitCode
*
generatePreBarrier
(
JSContext
*
cx
MIRType
type
)
;
JitCode
*
generateMallocStub
(
JSContext
*
cx
)
;
JitCode
*
generateFreeStub
(
JSContext
*
cx
)
;
JitCode
*
generateDebugTrapHandler
(
JSContext
*
cx
)
;
JitCode
*
generateBaselineDebugModeOSRHandler
(
JSContext
*
cx
uint32_t
*
noFrameRegPopOffsetOut
)
;
JitCode
*
generateVMWrapper
(
JSContext
*
cx
const
VMFunction
&
f
)
;
public
:
explicit
JitRuntime
(
JSRuntime
*
rt
)
;
~
JitRuntime
(
)
;
bool
initialize
(
JSContext
*
cx
)
;
uint8_t
*
allocateOsrTempData
(
size_t
size
)
;
void
freeOsrTempData
(
)
;
static
void
Mark
(
JSTracer
*
trc
)
;
static
void
MarkJitcodeGlobalTableUnconditionally
(
JSTracer
*
trc
)
;
static
bool
MarkJitcodeGlobalTableIteratively
(
JSTracer
*
trc
)
;
static
void
SweepJitcodeGlobalTable
(
JSRuntime
*
rt
)
;
ExecutableAllocator
&
execAlloc
(
)
{
return
execAlloc_
;
}
ExecutableAllocator
&
backedgeExecAlloc
(
)
{
return
backedgeExecAlloc_
;
}
class
AutoPreventBackedgePatching
{
mozilla
:
:
DebugOnly
<
JSRuntime
*
>
rt_
;
JitRuntime
*
jrt_
;
bool
prev_
;
public
:
AutoPreventBackedgePatching
(
JSRuntime
*
rt
JitRuntime
*
jrt
)
:
rt_
(
rt
)
jrt_
(
jrt
)
prev_
(
false
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
if
(
jrt_
)
{
prev_
=
jrt_
-
>
preventBackedgePatching_
;
jrt_
-
>
preventBackedgePatching_
=
true
;
}
}
explicit
AutoPreventBackedgePatching
(
JSRuntime
*
rt
)
:
AutoPreventBackedgePatching
(
rt
rt
-
>
jitRuntime
(
)
)
{
}
~
AutoPreventBackedgePatching
(
)
{
MOZ_ASSERT
(
jrt_
=
=
rt_
-
>
jitRuntime
(
)
)
;
if
(
jrt_
)
{
MOZ_ASSERT
(
jrt_
-
>
preventBackedgePatching_
)
;
jrt_
-
>
preventBackedgePatching_
=
prev_
;
}
}
}
;
bool
preventBackedgePatching
(
)
const
{
return
preventBackedgePatching_
;
}
BackedgeTarget
backedgeTarget
(
)
const
{
return
backedgeTarget_
;
}
void
addPatchableBackedge
(
PatchableBackedge
*
backedge
)
{
MOZ_ASSERT
(
preventBackedgePatching_
)
;
backedgeList_
.
pushFront
(
backedge
)
;
}
void
removePatchableBackedge
(
PatchableBackedge
*
backedge
)
{
MOZ_ASSERT
(
preventBackedgePatching_
)
;
backedgeList_
.
remove
(
backedge
)
;
}
void
patchIonBackedges
(
JSRuntime
*
rt
BackedgeTarget
target
)
;
JitCode
*
getVMWrapper
(
const
VMFunction
&
f
)
const
;
JitCode
*
debugTrapHandler
(
JSContext
*
cx
)
;
JitCode
*
getBaselineDebugModeOSRHandler
(
JSContext
*
cx
)
;
void
*
getBaselineDebugModeOSRHandlerAddress
(
JSContext
*
cx
bool
popFrameReg
)
;
JitCode
*
getGenericBailoutHandler
(
)
const
{
return
bailoutHandler_
;
}
JitCode
*
getExceptionTail
(
)
const
{
return
exceptionTail_
;
}
JitCode
*
getBailoutTail
(
)
const
{
return
bailoutTail_
;
}
JitCode
*
getProfilerExitFrameTail
(
)
const
{
return
profilerExitFrameTail_
;
}
JitCode
*
getBailoutTable
(
const
FrameSizeClass
&
frameClass
)
const
;
JitCode
*
getArgumentsRectifier
(
)
const
{
return
argumentsRectifier_
;
}
void
*
getArgumentsRectifierReturnAddr
(
)
const
{
return
argumentsRectifierReturnAddr_
;
}
JitCode
*
getInvalidationThunk
(
)
const
{
return
invalidator_
;
}
EnterJitCode
enterIon
(
)
const
{
return
enterJIT_
-
>
as
<
EnterJitCode
>
(
)
;
}
EnterJitCode
enterBaseline
(
)
const
{
return
enterBaselineJIT_
-
>
as
<
EnterJitCode
>
(
)
;
}
JitCode
*
preBarrier
(
MIRType
type
)
const
{
switch
(
type
)
{
case
MIRType_Value
:
return
valuePreBarrier_
;
case
MIRType_String
:
return
stringPreBarrier_
;
case
MIRType_Object
:
return
objectPreBarrier_
;
case
MIRType_Shape
:
return
shapePreBarrier_
;
case
MIRType_ObjectGroup
:
return
objectGroupPreBarrier_
;
default
:
MOZ_CRASH
(
)
;
}
}
JitCode
*
mallocStub
(
)
const
{
return
mallocStub_
;
}
JitCode
*
freeStub
(
)
const
{
return
freeStub_
;
}
JitCode
*
lazyLinkStub
(
)
const
{
return
lazyLinkStub_
;
}
bool
hasIonReturnOverride
(
)
const
{
return
!
ionReturnOverride_
.
isMagic
(
JS_ARG_POISON
)
;
}
js
:
:
Value
takeIonReturnOverride
(
)
{
js
:
:
Value
v
=
ionReturnOverride_
;
ionReturnOverride_
=
js
:
:
MagicValue
(
JS_ARG_POISON
)
;
return
v
;
}
void
setIonReturnOverride
(
const
js
:
:
Value
&
v
)
{
MOZ_ASSERT
(
!
hasIonReturnOverride
(
)
)
;
MOZ_ASSERT
(
!
v
.
isMagic
(
)
)
;
ionReturnOverride_
=
v
;
}
bool
hasJitcodeGlobalTable
(
)
const
{
return
jitcodeGlobalTable_
!
=
nullptr
;
}
JitcodeGlobalTable
*
getJitcodeGlobalTable
(
)
{
MOZ_ASSERT
(
hasJitcodeGlobalTable
(
)
)
;
return
jitcodeGlobalTable_
;
}
bool
isProfilerInstrumentationEnabled
(
JSRuntime
*
rt
)
{
return
rt
-
>
spsProfiler
.
enabled
(
)
;
}
bool
isOptimizationTrackingEnabled
(
JSRuntime
*
rt
)
{
return
isProfilerInstrumentationEnabled
(
rt
)
;
}
}
;
class
JitZone
{
OptimizedICStubSpace
optimizedStubSpace_
;
public
:
OptimizedICStubSpace
*
optimizedStubSpace
(
)
{
return
&
optimizedStubSpace_
;
}
}
;
class
JitCompartment
{
friend
class
JitActivation
;
struct
IcStubCodeMapGCPolicy
{
static
bool
needsSweep
(
uint32_t
*
key
ReadBarrieredJitCode
*
value
)
{
return
IsAboutToBeFinalized
(
value
)
;
}
}
;
using
ICStubCodeMap
=
GCHashMap
<
uint32_t
ReadBarrieredJitCode
DefaultHasher
<
uint32_t
>
RuntimeAllocPolicy
IcStubCodeMapGCPolicy
>
;
ICStubCodeMap
*
stubCodes_
;
void
*
baselineCallReturnAddrs_
[
2
]
;
void
*
baselineGetPropReturnAddr_
;
void
*
baselineSetPropReturnAddr_
;
JitCode
*
stringConcatStub_
;
JitCode
*
regExpMatcherStub_
;
JitCode
*
regExpTesterStub_
;
mozilla
:
:
EnumeratedArray
<
SimdType
SimdType
:
:
Count
ReadBarrieredObject
>
simdTemplateObjects_
;
JitCode
*
generateStringConcatStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpMatcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpTesterStub
(
JSContext
*
cx
)
;
public
:
JSObject
*
getSimdTemplateObjectFor
(
JSContext
*
cx
Handle
<
SimdTypeDescr
*
>
descr
)
{
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
descr
-
>
type
(
)
]
;
if
(
!
tpl
)
tpl
.
set
(
TypedObject
:
:
createZeroed
(
cx
descr
0
gc
:
:
TenuredHeap
)
)
;
return
tpl
.
get
(
)
;
}
JSObject
*
maybeGetSimdTemplateObjectFor
(
SimdType
type
)
const
{
const
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
type
]
;
return
tpl
.
unbarrieredGet
(
)
;
}
void
registerSimdTemplateObjectFor
(
SimdType
type
)
{
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
type
]
;
MOZ_ASSERT
(
tpl
.
unbarrieredGet
(
)
)
;
tpl
.
get
(
)
;
}
JitCode
*
getStubCode
(
uint32_t
key
)
{
ICStubCodeMap
:
:
AddPtr
p
=
stubCodes_
-
>
lookupForAdd
(
key
)
;
if
(
p
)
return
p
-
>
value
(
)
;
return
nullptr
;
}
bool
putStubCode
(
JSContext
*
cx
uint32_t
key
Handle
<
JitCode
*
>
stubCode
)
{
MOZ_ASSERT
(
stubCode
)
;
if
(
!
stubCodes_
-
>
putNew
(
key
stubCode
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
initBaselineCallReturnAddr
(
void
*
addr
bool
constructing
)
{
MOZ_ASSERT
(
baselineCallReturnAddrs_
[
constructing
]
=
=
nullptr
)
;
baselineCallReturnAddrs_
[
constructing
]
=
addr
;
}
void
*
baselineCallReturnAddr
(
bool
constructing
)
{
MOZ_ASSERT
(
baselineCallReturnAddrs_
[
constructing
]
!
=
nullptr
)
;
return
baselineCallReturnAddrs_
[
constructing
]
;
}
void
initBaselineGetPropReturnAddr
(
void
*
addr
)
{
MOZ_ASSERT
(
baselineGetPropReturnAddr_
=
=
nullptr
)
;
baselineGetPropReturnAddr_
=
addr
;
}
void
*
baselineGetPropReturnAddr
(
)
{
MOZ_ASSERT
(
baselineGetPropReturnAddr_
!
=
nullptr
)
;
return
baselineGetPropReturnAddr_
;
}
void
initBaselineSetPropReturnAddr
(
void
*
addr
)
{
MOZ_ASSERT
(
baselineSetPropReturnAddr_
=
=
nullptr
)
;
baselineSetPropReturnAddr_
=
addr
;
}
void
*
baselineSetPropReturnAddr
(
)
{
MOZ_ASSERT
(
baselineSetPropReturnAddr_
!
=
nullptr
)
;
return
baselineSetPropReturnAddr_
;
}
void
toggleBarriers
(
bool
enabled
)
;
public
:
JitCompartment
(
)
;
~
JitCompartment
(
)
;
bool
initialize
(
JSContext
*
cx
)
;
bool
ensureIonStubsExist
(
JSContext
*
cx
)
;
void
mark
(
JSTracer
*
trc
JSCompartment
*
compartment
)
;
void
sweep
(
FreeOp
*
fop
JSCompartment
*
compartment
)
;
JitCode
*
stringConcatStubNoBarrier
(
)
const
{
return
stringConcatStub_
;
}
JitCode
*
regExpMatcherStubNoBarrier
(
)
const
{
return
regExpMatcherStub_
;
}
bool
ensureRegExpMatcherStubExists
(
JSContext
*
cx
)
{
if
(
regExpMatcherStub_
)
return
true
;
regExpMatcherStub_
=
generateRegExpMatcherStub
(
cx
)
;
return
regExpMatcherStub_
!
=
nullptr
;
}
JitCode
*
regExpTesterStubNoBarrier
(
)
const
{
return
regExpTesterStub_
;
}
bool
ensureRegExpTesterStubExists
(
JSContext
*
cx
)
{
if
(
regExpTesterStub_
)
return
true
;
regExpTesterStub_
=
generateRegExpTesterStub
(
cx
)
;
return
regExpTesterStub_
!
=
nullptr
;
}
}
;
void
InvalidateAll
(
FreeOp
*
fop
JS
:
:
Zone
*
zone
)
;
void
FinishInvalidation
(
FreeOp
*
fop
JSScript
*
script
)
;
#
ifdef
XP_WIN
const
unsigned
WINDOWS_BIG_FRAME_TOUCH_INCREMENT
=
4096
-
1
;
#
endif
class
MOZ_STACK_CLASS
AutoWritableJitCode
{
JitRuntime
:
:
AutoPreventBackedgePatching
preventPatching_
;
JSRuntime
*
rt_
;
void
*
addr_
;
size_t
size_
;
public
:
AutoWritableJitCode
(
JSRuntime
*
rt
void
*
addr
size_t
size
)
:
preventPatching_
(
rt
)
rt_
(
rt
)
addr_
(
addr
)
size_
(
size
)
{
rt_
-
>
toggleAutoWritableJitCodeActive
(
true
)
;
if
(
!
ExecutableAllocator
:
:
makeWritable
(
addr_
size_
)
)
MOZ_CRASH
(
)
;
}
AutoWritableJitCode
(
void
*
addr
size_t
size
)
:
AutoWritableJitCode
(
TlsPerThreadData
.
get
(
)
-
>
runtimeFromMainThread
(
)
addr
size
)
{
}
explicit
AutoWritableJitCode
(
JitCode
*
code
)
:
AutoWritableJitCode
(
code
-
>
runtimeFromMainThread
(
)
code
-
>
raw
(
)
code
-
>
bufferSize
(
)
)
{
}
~
AutoWritableJitCode
(
)
{
if
(
!
ExecutableAllocator
:
:
makeExecutable
(
addr_
size_
)
)
MOZ_CRASH
(
)
;
rt_
-
>
toggleAutoWritableJitCodeActive
(
false
)
;
}
}
;
class
MOZ_STACK_CLASS
MaybeAutoWritableJitCode
{
mozilla
:
:
Maybe
<
AutoWritableJitCode
>
awjc_
;
public
:
MaybeAutoWritableJitCode
(
void
*
addr
size_t
size
ReprotectCode
reprotect
)
{
if
(
reprotect
)
awjc_
.
emplace
(
addr
size
)
;
}
MaybeAutoWritableJitCode
(
JitCode
*
code
ReprotectCode
reprotect
)
{
if
(
reprotect
)
awjc_
.
emplace
(
code
)
;
}
}
;
}
}
#
endif
