#
ifndef
jit_JitCompartment_h
#
define
jit_JitCompartment_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
builtin
/
TypedObject
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
jit
/
IonControlFlow
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
class
FrameSizeClass
;
struct
EnterJitData
{
explicit
EnterJitData
(
JSContext
*
cx
)
:
envChain
(
cx
)
result
(
cx
)
{
}
uint8_t
*
jitcode
;
InterpreterFrame
*
osrFrame
;
void
*
calleeToken
;
Value
*
maxArgv
;
unsigned
maxArgc
;
unsigned
numActualArgs
;
unsigned
osrNumStackValues
;
RootedObject
envChain
;
RootedValue
result
;
bool
constructing
;
}
;
typedef
void
(
*
EnterJitCode
)
(
void
*
code
unsigned
argc
Value
*
argv
InterpreterFrame
*
fp
CalleeToken
calleeToken
JSObject
*
envChain
size_t
numStackValues
Value
*
vp
)
;
class
JitcodeGlobalTable
;
class
PatchableBackedge
:
public
InlineListNode
<
PatchableBackedge
>
{
friend
class
JitZoneGroup
;
CodeLocationJump
backedge
;
CodeLocationLabel
loopHeader
;
CodeLocationLabel
interruptCheck
;
public
:
PatchableBackedge
(
CodeLocationJump
backedge
CodeLocationLabel
loopHeader
CodeLocationLabel
interruptCheck
)
:
backedge
(
backedge
)
loopHeader
(
loopHeader
)
interruptCheck
(
interruptCheck
)
{
}
}
;
class
JitRuntime
{
private
:
friend
class
JitCompartment
;
ActiveThreadData
<
ExecutableAllocator
>
execAlloc_
;
ActiveThreadData
<
ExecutableAllocator
>
backedgeExecAlloc_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
exceptionTailOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
bailoutTailOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
profilerExitFrameTailOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
enterJITOffset_
;
struct
BailoutTable
{
uint32_t
startOffset
;
uint32_t
size
;
BailoutTable
(
uint32_t
startOffset
uint32_t
size
)
:
startOffset
(
startOffset
)
size
(
size
)
{
}
}
;
typedef
Vector
<
BailoutTable
4
SystemAllocPolicy
>
BailoutTableVector
;
ExclusiveAccessLockWriteOnceData
<
BailoutTableVector
>
bailoutTables_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
bailoutHandlerOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
argumentsRectifierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
argumentsRectifierReturnOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
invalidatorOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
valuePreBarrierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
stringPreBarrierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
objectPreBarrierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
shapePreBarrierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
objectGroupPreBarrierOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
mallocStubOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
freeStubOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
lazyLinkStubOffset_
;
ExclusiveAccessLockWriteOnceData
<
uint32_t
>
interpreterStubOffset_
;
ExclusiveAccessLockWriteOnceData
<
JitCode
*
>
debugTrapHandler_
;
ExclusiveAccessLockWriteOnceData
<
JitCode
*
>
baselineDebugModeOSRHandler_
;
ExclusiveAccessLockWriteOnceData
<
void
*
>
baselineDebugModeOSRHandlerNoFrameRegPopAddr_
;
ExclusiveAccessLockWriteOnceData
<
JitCode
*
>
trampolineCode_
;
using
VMWrapperMap
=
HashMap
<
const
VMFunction
*
uint32_t
VMFunction
>
;
ExclusiveAccessLockWriteOnceData
<
VMWrapperMap
*
>
functionWrappers_
;
mozilla
:
:
Atomic
<
bool
>
preventBackedgePatching_
;
UnprotectedData
<
JitcodeGlobalTable
*
>
jitcodeGlobalTable_
;
private
:
void
generateLazyLinkStub
(
MacroAssembler
&
masm
)
;
void
generateInterpreterStub
(
MacroAssembler
&
masm
)
;
void
generateProfilerExitFrameTailStub
(
MacroAssembler
&
masm
Label
*
profilerExitTail
)
;
void
generateExceptionTailStub
(
MacroAssembler
&
masm
void
*
handler
Label
*
profilerExitTail
)
;
void
generateBailoutTailStub
(
MacroAssembler
&
masm
Label
*
bailoutTail
)
;
void
generateEnterJIT
(
JSContext
*
cx
MacroAssembler
&
masm
)
;
void
generateArgumentsRectifier
(
MacroAssembler
&
masm
)
;
BailoutTable
generateBailoutTable
(
MacroAssembler
&
masm
Label
*
bailoutTail
uint32_t
frameClass
)
;
void
generateBailoutHandler
(
MacroAssembler
&
masm
Label
*
bailoutTail
)
;
void
generateInvalidator
(
MacroAssembler
&
masm
Label
*
bailoutTail
)
;
uint32_t
generatePreBarrier
(
JSContext
*
cx
MacroAssembler
&
masm
MIRType
type
)
;
void
generateMallocStub
(
MacroAssembler
&
masm
)
;
void
generateFreeStub
(
MacroAssembler
&
masm
)
;
JitCode
*
generateDebugTrapHandler
(
JSContext
*
cx
)
;
JitCode
*
generateBaselineDebugModeOSRHandler
(
JSContext
*
cx
uint32_t
*
noFrameRegPopOffsetOut
)
;
bool
generateVMWrapper
(
JSContext
*
cx
MacroAssembler
&
masm
const
VMFunction
&
f
)
;
bool
generateTLEventVM
(
JSContext
*
cx
MacroAssembler
&
masm
const
VMFunction
&
f
bool
enter
)
;
inline
bool
generateTLEnterVM
(
JSContext
*
cx
MacroAssembler
&
masm
const
VMFunction
&
f
)
{
return
generateTLEventVM
(
cx
masm
f
true
)
;
}
inline
bool
generateTLExitVM
(
JSContext
*
cx
MacroAssembler
&
masm
const
VMFunction
&
f
)
{
return
generateTLEventVM
(
cx
masm
f
false
)
;
}
uint32_t
startTrampolineCode
(
MacroAssembler
&
masm
)
;
TrampolinePtr
trampolineCode
(
uint32_t
offset
)
const
{
MOZ_ASSERT
(
offset
>
0
)
;
MOZ_ASSERT
(
offset
<
trampolineCode_
-
>
instructionsSize
(
)
)
;
return
TrampolinePtr
(
trampolineCode_
-
>
raw
(
)
+
offset
)
;
}
public
:
explicit
JitRuntime
(
JSRuntime
*
rt
)
;
~
JitRuntime
(
)
;
MOZ_MUST_USE
bool
initialize
(
JSContext
*
cx
js
:
:
AutoLockForExclusiveAccess
&
lock
)
;
static
void
Trace
(
JSTracer
*
trc
js
:
:
AutoLockForExclusiveAccess
&
lock
)
;
static
void
TraceJitcodeGlobalTableForMinorGC
(
JSTracer
*
trc
)
;
static
MOZ_MUST_USE
bool
MarkJitcodeGlobalTableIteratively
(
GCMarker
*
marker
)
;
static
void
SweepJitcodeGlobalTable
(
JSRuntime
*
rt
)
;
ExecutableAllocator
&
execAlloc
(
)
{
return
execAlloc_
.
ref
(
)
;
}
ExecutableAllocator
&
backedgeExecAlloc
(
)
{
return
backedgeExecAlloc_
.
ref
(
)
;
}
class
AutoPreventBackedgePatching
{
mozilla
:
:
DebugOnly
<
JSRuntime
*
>
rt_
;
JitRuntime
*
jrt_
;
bool
prev_
;
public
:
AutoPreventBackedgePatching
(
JSRuntime
*
rt
JitRuntime
*
jrt
)
:
rt_
(
rt
)
jrt_
(
jrt
)
prev_
(
false
)
{
if
(
jrt_
)
{
prev_
=
jrt_
-
>
preventBackedgePatching_
;
jrt_
-
>
preventBackedgePatching_
=
true
;
}
}
explicit
AutoPreventBackedgePatching
(
JSRuntime
*
rt
)
:
AutoPreventBackedgePatching
(
rt
rt
-
>
jitRuntime
(
)
)
{
}
~
AutoPreventBackedgePatching
(
)
{
MOZ_ASSERT
(
jrt_
=
=
rt_
-
>
jitRuntime
(
)
)
;
if
(
jrt_
)
{
MOZ_ASSERT
(
jrt_
-
>
preventBackedgePatching_
)
;
jrt_
-
>
preventBackedgePatching_
=
prev_
;
}
}
}
;
bool
preventBackedgePatching
(
)
const
{
return
preventBackedgePatching_
;
}
TrampolinePtr
getVMWrapper
(
const
VMFunction
&
f
)
const
;
JitCode
*
debugTrapHandler
(
JSContext
*
cx
)
;
JitCode
*
getBaselineDebugModeOSRHandler
(
JSContext
*
cx
)
;
void
*
getBaselineDebugModeOSRHandlerAddress
(
JSContext
*
cx
bool
popFrameReg
)
;
TrampolinePtr
getGenericBailoutHandler
(
)
const
{
return
trampolineCode
(
bailoutHandlerOffset_
)
;
}
TrampolinePtr
getExceptionTail
(
)
const
{
return
trampolineCode
(
exceptionTailOffset_
)
;
}
TrampolinePtr
getBailoutTail
(
)
const
{
return
trampolineCode
(
bailoutTailOffset_
)
;
}
TrampolinePtr
getProfilerExitFrameTail
(
)
const
{
return
trampolineCode
(
profilerExitFrameTailOffset_
)
;
}
TrampolinePtr
getBailoutTable
(
const
FrameSizeClass
&
frameClass
)
const
;
uint32_t
getBailoutTableSize
(
const
FrameSizeClass
&
frameClass
)
const
;
TrampolinePtr
getArgumentsRectifier
(
)
const
{
return
trampolineCode
(
argumentsRectifierOffset_
)
;
}
TrampolinePtr
getArgumentsRectifierReturnAddr
(
)
const
{
return
trampolineCode
(
argumentsRectifierReturnOffset_
)
;
}
TrampolinePtr
getInvalidationThunk
(
)
const
{
return
trampolineCode
(
invalidatorOffset_
)
;
}
EnterJitCode
enterJit
(
)
const
{
return
JS_DATA_TO_FUNC_PTR
(
EnterJitCode
trampolineCode
(
enterJITOffset_
)
.
value
)
;
}
TrampolinePtr
preBarrier
(
MIRType
type
)
const
{
switch
(
type
)
{
case
MIRType
:
:
Value
:
return
trampolineCode
(
valuePreBarrierOffset_
)
;
case
MIRType
:
:
String
:
return
trampolineCode
(
stringPreBarrierOffset_
)
;
case
MIRType
:
:
Object
:
return
trampolineCode
(
objectPreBarrierOffset_
)
;
case
MIRType
:
:
Shape
:
return
trampolineCode
(
shapePreBarrierOffset_
)
;
case
MIRType
:
:
ObjectGroup
:
return
trampolineCode
(
objectGroupPreBarrierOffset_
)
;
default
:
MOZ_CRASH
(
)
;
}
}
TrampolinePtr
mallocStub
(
)
const
{
return
trampolineCode
(
mallocStubOffset_
)
;
}
TrampolinePtr
freeStub
(
)
const
{
return
trampolineCode
(
freeStubOffset_
)
;
}
TrampolinePtr
lazyLinkStub
(
)
const
{
return
trampolineCode
(
lazyLinkStubOffset_
)
;
}
TrampolinePtr
interpreterStub
(
)
const
{
return
trampolineCode
(
interpreterStubOffset_
)
;
}
bool
hasJitcodeGlobalTable
(
)
const
{
return
jitcodeGlobalTable_
!
=
nullptr
;
}
JitcodeGlobalTable
*
getJitcodeGlobalTable
(
)
{
MOZ_ASSERT
(
hasJitcodeGlobalTable
(
)
)
;
return
jitcodeGlobalTable_
;
}
bool
isProfilerInstrumentationEnabled
(
JSRuntime
*
rt
)
{
return
rt
-
>
geckoProfiler
(
)
.
enabled
(
)
;
}
bool
isOptimizationTrackingEnabled
(
ZoneGroup
*
group
)
{
return
isProfilerInstrumentationEnabled
(
group
-
>
runtime
)
;
}
}
;
class
JitZoneGroup
{
public
:
enum
BackedgeTarget
{
BackedgeLoopHeader
BackedgeInterruptCheck
}
;
private
:
ZoneGroupData
<
BackedgeTarget
>
backedgeTarget_
;
ZoneGroupData
<
InlineList
<
PatchableBackedge
>
>
backedgeList_
;
InlineList
<
PatchableBackedge
>
&
backedgeList
(
)
{
return
backedgeList_
.
ref
(
)
;
}
public
:
explicit
JitZoneGroup
(
ZoneGroup
*
group
)
;
BackedgeTarget
backedgeTarget
(
)
const
{
return
backedgeTarget_
;
}
void
addPatchableBackedge
(
JitRuntime
*
jrt
PatchableBackedge
*
backedge
)
{
MOZ_ASSERT
(
jrt
-
>
preventBackedgePatching
(
)
)
;
backedgeList
(
)
.
pushFront
(
backedge
)
;
}
void
removePatchableBackedge
(
JitRuntime
*
jrt
PatchableBackedge
*
backedge
)
{
MOZ_ASSERT
(
jrt
-
>
preventBackedgePatching
(
)
)
;
backedgeList
(
)
.
remove
(
backedge
)
;
}
void
patchIonBackedges
(
JSContext
*
cx
BackedgeTarget
target
)
;
}
;
enum
class
CacheKind
:
uint8_t
;
class
CacheIRStubInfo
;
enum
class
ICStubEngine
:
uint8_t
{
Baseline
=
0
IonSharedIC
IonIC
}
;
struct
CacheIRStubKey
:
public
DefaultHasher
<
CacheIRStubKey
>
{
struct
Lookup
{
CacheKind
kind
;
ICStubEngine
engine
;
const
uint8_t
*
code
;
uint32_t
length
;
Lookup
(
CacheKind
kind
ICStubEngine
engine
const
uint8_t
*
code
uint32_t
length
)
:
kind
(
kind
)
engine
(
engine
)
code
(
code
)
length
(
length
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
CacheIRStubKey
&
entry
const
Lookup
&
l
)
;
UniquePtr
<
CacheIRStubInfo
JS
:
:
FreePolicy
>
stubInfo
;
explicit
CacheIRStubKey
(
CacheIRStubInfo
*
info
)
:
stubInfo
(
info
)
{
}
CacheIRStubKey
(
CacheIRStubKey
&
&
other
)
:
stubInfo
(
Move
(
other
.
stubInfo
)
)
{
}
void
operator
=
(
CacheIRStubKey
&
&
other
)
{
stubInfo
=
Move
(
other
.
stubInfo
)
;
}
}
;
template
<
typename
Key
>
struct
IcStubCodeMapGCPolicy
{
static
bool
needsSweep
(
Key
*
ReadBarrieredJitCode
*
value
)
{
return
IsAboutToBeFinalized
(
value
)
;
}
}
;
class
JitZone
{
OptimizedICStubSpace
optimizedStubSpace_
;
CFGSpace
cfgSpace_
;
using
IonCacheIRStubInfoSet
=
HashSet
<
CacheIRStubKey
CacheIRStubKey
SystemAllocPolicy
>
;
IonCacheIRStubInfoSet
ionCacheIRStubInfoSet_
;
using
BaselineCacheIRStubCodeMap
=
GCHashMap
<
CacheIRStubKey
ReadBarrieredJitCode
CacheIRStubKey
SystemAllocPolicy
IcStubCodeMapGCPolicy
<
CacheIRStubKey
>
>
;
BaselineCacheIRStubCodeMap
baselineCacheIRStubCodes_
;
public
:
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
void
sweep
(
FreeOp
*
fop
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
jitZone
size_t
*
baselineStubsOptimized
size_t
*
cachedCFG
)
const
;
OptimizedICStubSpace
*
optimizedStubSpace
(
)
{
return
&
optimizedStubSpace_
;
}
CFGSpace
*
cfgSpace
(
)
{
return
&
cfgSpace_
;
}
JitCode
*
getBaselineCacheIRStubCode
(
const
CacheIRStubKey
:
:
Lookup
&
key
CacheIRStubInfo
*
*
stubInfo
)
{
auto
p
=
baselineCacheIRStubCodes_
.
lookup
(
key
)
;
if
(
p
)
{
*
stubInfo
=
p
-
>
key
(
)
.
stubInfo
.
get
(
)
;
return
p
-
>
value
(
)
;
}
*
stubInfo
=
nullptr
;
return
nullptr
;
}
MOZ_MUST_USE
bool
putBaselineCacheIRStubCode
(
const
CacheIRStubKey
:
:
Lookup
&
lookup
CacheIRStubKey
&
key
JitCode
*
stubCode
)
{
auto
p
=
baselineCacheIRStubCodes_
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
)
;
return
baselineCacheIRStubCodes_
.
add
(
p
Move
(
key
)
stubCode
)
;
}
CacheIRStubInfo
*
getIonCacheIRStubInfo
(
const
CacheIRStubKey
:
:
Lookup
&
key
)
{
if
(
!
ionCacheIRStubInfoSet_
.
initialized
(
)
)
return
nullptr
;
IonCacheIRStubInfoSet
:
:
Ptr
p
=
ionCacheIRStubInfoSet_
.
lookup
(
key
)
;
return
p
?
p
-
>
stubInfo
.
get
(
)
:
nullptr
;
}
MOZ_MUST_USE
bool
putIonCacheIRStubInfo
(
const
CacheIRStubKey
:
:
Lookup
&
lookup
CacheIRStubKey
&
key
)
{
if
(
!
ionCacheIRStubInfoSet_
.
initialized
(
)
&
&
!
ionCacheIRStubInfoSet_
.
init
(
)
)
return
false
;
IonCacheIRStubInfoSet
:
:
AddPtr
p
=
ionCacheIRStubInfoSet_
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
)
;
return
ionCacheIRStubInfoSet_
.
add
(
p
Move
(
key
)
)
;
}
void
purgeIonCacheIRStubInfo
(
)
{
ionCacheIRStubInfoSet_
.
finish
(
)
;
}
}
;
enum
class
BailoutReturnStub
{
GetProp
GetPropSuper
SetProp
Call
New
Count
}
;
class
JitCompartment
{
friend
class
JitActivation
;
using
ICStubCodeMap
=
GCHashMap
<
uint32_t
ReadBarrieredJitCode
DefaultHasher
<
uint32_t
>
ZoneAllocPolicy
IcStubCodeMapGCPolicy
<
uint32_t
>
>
;
ICStubCodeMap
*
stubCodes_
;
struct
BailoutReturnStubInfo
{
void
*
addr
;
uint32_t
key
;
BailoutReturnStubInfo
(
)
:
addr
(
nullptr
)
key
(
0
)
{
}
BailoutReturnStubInfo
(
void
*
addr_
uint32_t
key_
)
:
addr
(
addr_
)
key
(
key_
)
{
}
}
;
mozilla
:
:
EnumeratedArray
<
BailoutReturnStub
BailoutReturnStub
:
:
Count
BailoutReturnStubInfo
>
bailoutReturnStubInfo_
;
JitCode
*
stringConcatStub_
;
JitCode
*
regExpMatcherStub_
;
JitCode
*
regExpSearcherStub_
;
JitCode
*
regExpTesterStub_
;
mozilla
:
:
EnumeratedArray
<
SimdType
SimdType
:
:
Count
ReadBarrieredObject
>
simdTemplateObjects_
;
JitCode
*
generateStringConcatStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpMatcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpSearcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpTesterStub
(
JSContext
*
cx
)
;
public
:
JSObject
*
getSimdTemplateObjectFor
(
JSContext
*
cx
Handle
<
SimdTypeDescr
*
>
descr
)
{
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
descr
-
>
type
(
)
]
;
if
(
!
tpl
)
tpl
.
set
(
TypedObject
:
:
createZeroed
(
cx
descr
0
gc
:
:
TenuredHeap
)
)
;
return
tpl
.
get
(
)
;
}
JSObject
*
maybeGetSimdTemplateObjectFor
(
SimdType
type
)
const
{
const
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
type
]
;
return
tpl
.
unbarrieredGet
(
)
;
}
void
registerSimdTemplateObjectFor
(
SimdType
type
)
{
ReadBarrieredObject
&
tpl
=
simdTemplateObjects_
[
type
]
;
MOZ_ASSERT
(
tpl
.
unbarrieredGet
(
)
)
;
tpl
.
get
(
)
;
}
JitCode
*
getStubCode
(
uint32_t
key
)
{
ICStubCodeMap
:
:
Ptr
p
=
stubCodes_
-
>
lookup
(
key
)
;
if
(
p
)
return
p
-
>
value
(
)
;
return
nullptr
;
}
MOZ_MUST_USE
bool
putStubCode
(
JSContext
*
cx
uint32_t
key
Handle
<
JitCode
*
>
stubCode
)
{
MOZ_ASSERT
(
stubCode
)
;
if
(
!
stubCodes_
-
>
putNew
(
key
stubCode
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
initBailoutReturnAddr
(
void
*
addr
uint32_t
key
BailoutReturnStub
kind
)
{
MOZ_ASSERT
(
bailoutReturnStubInfo_
[
kind
]
.
addr
=
=
nullptr
)
;
bailoutReturnStubInfo_
[
kind
]
=
BailoutReturnStubInfo
{
addr
key
}
;
}
void
*
bailoutReturnAddr
(
BailoutReturnStub
kind
)
{
MOZ_ASSERT
(
bailoutReturnStubInfo_
[
kind
]
.
addr
)
;
return
bailoutReturnStubInfo_
[
kind
]
.
addr
;
}
JitCompartment
(
)
;
~
JitCompartment
(
)
;
MOZ_MUST_USE
bool
initialize
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
ensureIonStubsExist
(
JSContext
*
cx
)
;
void
sweep
(
FreeOp
*
fop
JSCompartment
*
compartment
)
;
JitCode
*
stringConcatStubNoBarrier
(
)
const
{
return
stringConcatStub_
;
}
JitCode
*
regExpMatcherStubNoBarrier
(
)
const
{
return
regExpMatcherStub_
;
}
MOZ_MUST_USE
bool
ensureRegExpMatcherStubExists
(
JSContext
*
cx
)
{
if
(
regExpMatcherStub_
)
return
true
;
regExpMatcherStub_
=
generateRegExpMatcherStub
(
cx
)
;
return
regExpMatcherStub_
!
=
nullptr
;
}
JitCode
*
regExpSearcherStubNoBarrier
(
)
const
{
return
regExpSearcherStub_
;
}
MOZ_MUST_USE
bool
ensureRegExpSearcherStubExists
(
JSContext
*
cx
)
{
if
(
regExpSearcherStub_
)
return
true
;
regExpSearcherStub_
=
generateRegExpSearcherStub
(
cx
)
;
return
regExpSearcherStub_
!
=
nullptr
;
}
JitCode
*
regExpTesterStubNoBarrier
(
)
const
{
return
regExpTesterStub_
;
}
MOZ_MUST_USE
bool
ensureRegExpTesterStubExists
(
JSContext
*
cx
)
{
if
(
regExpTesterStub_
)
return
true
;
regExpTesterStub_
=
generateRegExpTesterStub
(
cx
)
;
return
regExpTesterStub_
!
=
nullptr
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
bool
stringsCanBeInNursery
;
}
;
void
InvalidateAll
(
FreeOp
*
fop
JS
:
:
Zone
*
zone
)
;
void
FinishInvalidation
(
FreeOp
*
fop
JSScript
*
script
)
;
#
ifdef
XP_WIN
const
unsigned
WINDOWS_BIG_FRAME_TOUCH_INCREMENT
=
4096
-
1
;
#
endif
class
MOZ_STACK_CLASS
AutoWritableJitCode
{
JitRuntime
:
:
AutoPreventBackedgePatching
preventPatching_
;
JSRuntime
*
rt_
;
void
*
addr_
;
size_t
size_
;
public
:
AutoWritableJitCode
(
JSRuntime
*
rt
void
*
addr
size_t
size
)
:
preventPatching_
(
rt
)
rt_
(
rt
)
addr_
(
addr
)
size_
(
size
)
{
rt_
-
>
toggleAutoWritableJitCodeActive
(
true
)
;
if
(
!
ExecutableAllocator
:
:
makeWritable
(
addr_
size_
)
)
MOZ_CRASH
(
)
;
}
AutoWritableJitCode
(
void
*
addr
size_t
size
)
:
AutoWritableJitCode
(
TlsContext
.
get
(
)
-
>
runtime
(
)
addr
size
)
{
}
explicit
AutoWritableJitCode
(
JitCode
*
code
)
:
AutoWritableJitCode
(
code
-
>
runtimeFromActiveCooperatingThread
(
)
code
-
>
raw
(
)
code
-
>
bufferSize
(
)
)
{
}
~
AutoWritableJitCode
(
)
{
if
(
!
ExecutableAllocator
:
:
makeExecutable
(
addr_
size_
)
)
MOZ_CRASH
(
)
;
rt_
-
>
toggleAutoWritableJitCodeActive
(
false
)
;
}
}
;
class
MOZ_STACK_CLASS
MaybeAutoWritableJitCode
{
mozilla
:
:
Maybe
<
AutoWritableJitCode
>
awjc_
;
public
:
MaybeAutoWritableJitCode
(
void
*
addr
size_t
size
ReprotectCode
reprotect
)
{
if
(
reprotect
)
awjc_
.
emplace
(
addr
size
)
;
}
MaybeAutoWritableJitCode
(
JitCode
*
code
ReprotectCode
reprotect
)
{
if
(
reprotect
)
awjc_
.
emplace
(
code
)
;
}
}
;
}
}
#
endif
