#
ifndef
jit_JitcodeMap_h
#
define
jit_JitcodeMap_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
ds
/
AvlTree
.
h
"
#
include
"
jit
/
CompactBuffer
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
class
JSScript
;
class
JSTracer
;
struct
JSRuntime
;
namespace
JS
{
class
Zone
;
}
namespace
js
{
class
GCMarker
;
namespace
jit
{
class
InlineScriptTree
;
class
JitcodeGlobalTable
;
class
JitcodeIonTable
;
class
JitcodeRegionEntry
;
struct
NativeToBytecode
{
CodeOffset
nativeOffset
;
InlineScriptTree
*
tree
;
jsbytecode
*
pc
;
}
;
class
JitCodeRange
{
protected
:
void
*
const
nativeStartAddr_
;
void
*
const
nativeEndAddr_
;
public
:
JitCodeRange
(
void
*
start
void
*
end
)
:
nativeStartAddr_
(
start
)
nativeEndAddr_
(
end
)
{
MOZ_ASSERT
(
start
<
end
)
;
}
static
int
compare
(
const
JitCodeRange
*
r1
const
JitCodeRange
*
r2
)
{
if
(
r1
-
>
nativeEndAddr_
<
=
r2
-
>
nativeStartAddr_
)
{
return
-
1
;
}
if
(
r1
-
>
nativeStartAddr_
>
=
r2
-
>
nativeEndAddr_
)
{
return
1
;
}
return
0
;
}
void
*
nativeStartAddr
(
)
const
{
return
nativeStartAddr_
;
}
void
*
nativeEndAddr
(
)
const
{
return
nativeEndAddr_
;
}
bool
containsPointer
(
void
*
ptr
)
const
{
return
nativeStartAddr
(
)
<
=
ptr
&
&
ptr
<
nativeEndAddr
(
)
;
}
}
;
using
BytecodeLocationVector
=
Vector
<
BytecodeLocation
0
SystemAllocPolicy
>
;
class
IonEntry
;
class
IonICEntry
;
class
BaselineEntry
;
class
BaselineInterpreterEntry
;
class
DummyEntry
;
class
SelfHostedSharedEntry
;
class
JitcodeGlobalEntry
:
public
JitCodeRange
{
protected
:
JitCode
*
jitcode_
;
static
const
uint64_t
kNoSampleInBuffer
=
UINT64_MAX
;
uint64_t
samplePositionInBuffer_
=
kNoSampleInBuffer
;
public
:
enum
class
Kind
:
uint8_t
{
Ion
IonIC
Baseline
BaselineInterpreter
Dummy
SelfHostedShared
}
;
protected
:
Kind
kind_
;
JitcodeGlobalEntry
(
Kind
kind
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
)
:
JitCodeRange
(
nativeStartAddr
nativeEndAddr
)
jitcode_
(
code
)
kind_
(
kind
)
{
MOZ_ASSERT
(
code
)
;
MOZ_ASSERT
(
nativeStartAddr
)
;
MOZ_ASSERT
(
nativeEndAddr
)
;
}
~
JitcodeGlobalEntry
(
)
=
default
;
JitcodeGlobalEntry
(
const
JitcodeGlobalEntry
&
other
)
=
delete
;
void
operator
=
(
const
JitcodeGlobalEntry
&
other
)
=
delete
;
public
:
struct
DestroyPolicy
{
void
operator
(
)
(
JitcodeGlobalEntry
*
entry
)
;
}
;
void
setSamplePositionInBuffer
(
uint64_t
bufferWritePos
)
{
samplePositionInBuffer_
=
bufferWritePos
;
}
void
setAsExpired
(
)
{
samplePositionInBuffer_
=
kNoSampleInBuffer
;
}
bool
isSampled
(
uint64_t
bufferRangeStart
)
{
if
(
samplePositionInBuffer_
=
=
kNoSampleInBuffer
)
{
return
false
;
}
return
bufferRangeStart
<
=
samplePositionInBuffer_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isIon
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Ion
;
}
bool
isIonIC
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
IonIC
;
}
bool
isBaseline
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Baseline
;
}
bool
isBaselineInterpreter
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
BaselineInterpreter
;
}
bool
isDummy
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Dummy
;
}
bool
isSelfHostedShared
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
SelfHostedShared
;
}
inline
const
IonEntry
&
asIon
(
)
const
;
inline
const
IonICEntry
&
asIonIC
(
)
const
;
inline
const
BaselineEntry
&
asBaseline
(
)
const
;
inline
const
BaselineInterpreterEntry
&
asBaselineInterpreter
(
)
const
;
inline
const
DummyEntry
&
asDummy
(
)
const
;
inline
const
SelfHostedSharedEntry
&
asSelfHostedShared
(
)
const
;
inline
IonEntry
&
asIon
(
)
;
inline
IonICEntry
&
asIonIC
(
)
;
inline
BaselineEntry
&
asBaseline
(
)
;
inline
BaselineInterpreterEntry
&
asBaselineInterpreter
(
)
;
inline
DummyEntry
&
asDummy
(
)
;
inline
SelfHostedSharedEntry
&
asSelfHostedShared
(
)
;
JitCode
*
jitcode
(
)
const
{
return
jitcode_
;
}
JitCode
*
*
jitcodePtr
(
)
{
return
&
jitcode_
;
}
Zone
*
zone
(
)
const
{
return
jitcode
(
)
-
>
zone
(
)
;
}
bool
traceJitcode
(
JSTracer
*
trc
)
;
bool
isJitcodeMarkedFromAnyThread
(
JSRuntime
*
rt
)
;
bool
trace
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
uint64_t
realmID
(
JSRuntime
*
rt
)
const
;
void
*
canonicalNativeAddrFor
(
JSRuntime
*
rt
void
*
ptr
)
const
;
uint32_t
callStackAtAddr
(
JSRuntime
*
rt
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
}
;
using
UniqueJitcodeGlobalEntry
=
UniquePtr
<
JitcodeGlobalEntry
JitcodeGlobalEntry
:
:
DestroyPolicy
>
;
template
<
typename
T
typename
.
.
.
Args
>
inline
UniqueJitcodeGlobalEntry
MakeJitcodeGlobalEntry
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
{
UniqueJitcodeGlobalEntry
res
(
js_new
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
if
(
!
res
)
{
ReportOutOfMemory
(
cx
)
;
}
return
res
;
}
class
IonEntry
:
public
JitcodeGlobalEntry
{
public
:
struct
ScriptNamePair
{
JSScript
*
script
;
UniqueChars
str
;
ScriptNamePair
(
JSScript
*
script
UniqueChars
str
)
:
script
(
script
)
str
(
std
:
:
move
(
str
)
)
{
}
}
;
using
ScriptList
=
Vector
<
ScriptNamePair
2
SystemAllocPolicy
>
;
private
:
ScriptList
scriptList_
;
const
JitcodeIonTable
*
regionTable_
;
uint64_t
realmId_
;
public
:
IonEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
ScriptList
&
&
scriptList
JitcodeIonTable
*
regionTable
uint64_t
realmId
)
:
JitcodeGlobalEntry
(
Kind
:
:
Ion
code
nativeStartAddr
nativeEndAddr
)
scriptList_
(
std
:
:
move
(
scriptList
)
)
regionTable_
(
regionTable
)
realmId_
(
realmId
)
{
MOZ_ASSERT
(
regionTable
)
;
}
~
IonEntry
(
)
;
ScriptList
&
scriptList
(
)
{
return
scriptList_
;
}
size_t
numScripts
(
)
const
{
return
scriptList_
.
length
(
)
;
}
JSScript
*
getScript
(
unsigned
idx
)
const
{
MOZ_ASSERT
(
idx
<
numScripts
(
)
)
;
return
scriptList_
[
idx
]
.
script
;
}
const
char
*
getStr
(
unsigned
idx
)
const
{
MOZ_ASSERT
(
idx
<
numScripts
(
)
)
;
return
scriptList_
[
idx
]
.
str
.
get
(
)
;
}
const
JitcodeIonTable
*
regionTable
(
)
const
{
return
regionTable_
;
}
void
*
canonicalNativeAddrFor
(
void
*
ptr
)
const
;
uint32_t
callStackAtAddr
(
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
uint64_t
realmID
(
)
const
{
return
realmId_
;
}
bool
trace
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
}
;
class
IonICEntry
:
public
JitcodeGlobalEntry
{
void
*
rejoinAddr_
;
public
:
IonICEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
void
*
rejoinAddr
)
:
JitcodeGlobalEntry
(
Kind
:
:
IonIC
code
nativeStartAddr
nativeEndAddr
)
rejoinAddr_
(
rejoinAddr
)
{
MOZ_ASSERT
(
rejoinAddr_
)
;
}
void
*
rejoinAddr
(
)
const
{
return
rejoinAddr_
;
}
void
*
canonicalNativeAddrFor
(
void
*
ptr
)
const
;
uint32_t
callStackAtAddr
(
JSRuntime
*
rt
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
uint64_t
realmID
(
JSRuntime
*
rt
)
const
;
bool
trace
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
}
;
class
BaselineEntry
:
public
JitcodeGlobalEntry
{
JSScript
*
script_
;
UniqueChars
str_
;
uint64_t
realmId_
;
public
:
BaselineEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
JSScript
*
script
UniqueChars
str
uint64_t
realmId
)
:
JitcodeGlobalEntry
(
Kind
:
:
Baseline
code
nativeStartAddr
nativeEndAddr
)
script_
(
script
)
str_
(
std
:
:
move
(
str
)
)
realmId_
(
realmId
)
{
MOZ_ASSERT
(
script_
)
;
MOZ_ASSERT
(
str_
)
;
}
JSScript
*
script
(
)
const
{
return
script_
;
}
const
char
*
str
(
)
const
{
return
str_
.
get
(
)
;
}
void
*
canonicalNativeAddrFor
(
void
*
ptr
)
const
;
uint32_t
callStackAtAddr
(
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
uint64_t
realmID
(
)
const
{
return
realmId_
;
}
bool
trace
(
JSTracer
*
trc
)
;
void
traceWeak
(
JSTracer
*
trc
)
;
}
;
class
SelfHostedSharedEntry
:
public
JitcodeGlobalEntry
{
UniqueChars
str_
;
public
:
SelfHostedSharedEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
UniqueChars
str
)
:
JitcodeGlobalEntry
(
Kind
:
:
SelfHostedShared
code
nativeStartAddr
nativeEndAddr
)
str_
(
std
:
:
move
(
str
)
)
{
MOZ_ASSERT
(
str_
)
;
}
const
char
*
str
(
)
const
{
return
str_
.
get
(
)
;
}
void
*
canonicalNativeAddrFor
(
void
*
ptr
)
const
;
[
[
nodiscard
]
]
bool
callStackAtAddr
(
void
*
ptr
BytecodeLocationVector
&
results
uint32_t
*
depth
)
const
;
uint32_t
callStackAtAddr
(
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
uint64_t
realmID
(
)
const
;
}
;
class
BaselineInterpreterEntry
:
public
JitcodeGlobalEntry
{
public
:
BaselineInterpreterEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
)
:
JitcodeGlobalEntry
(
Kind
:
:
BaselineInterpreter
code
nativeStartAddr
nativeEndAddr
)
{
}
void
*
canonicalNativeAddrFor
(
void
*
ptr
)
const
;
uint32_t
callStackAtAddr
(
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
;
uint64_t
realmID
(
)
const
;
}
;
class
DummyEntry
:
public
JitcodeGlobalEntry
{
public
:
DummyEntry
(
JitCode
*
code
void
*
nativeStartAddr
void
*
nativeEndAddr
)
:
JitcodeGlobalEntry
(
Kind
:
:
Dummy
code
nativeStartAddr
nativeEndAddr
)
{
}
void
*
canonicalNativeAddrFor
(
JSRuntime
*
rt
void
*
ptr
)
const
{
return
nullptr
;
}
uint32_t
callStackAtAddr
(
JSRuntime
*
rt
void
*
ptr
const
char
*
*
results
uint32_t
maxResults
)
const
{
return
0
;
}
uint64_t
realmID
(
)
const
{
return
0
;
}
}
;
inline
const
IonEntry
&
JitcodeGlobalEntry
:
:
asIon
(
)
const
{
MOZ_ASSERT
(
isIon
(
)
)
;
return
*
static_cast
<
const
IonEntry
*
>
(
this
)
;
}
inline
const
IonICEntry
&
JitcodeGlobalEntry
:
:
asIonIC
(
)
const
{
MOZ_ASSERT
(
isIonIC
(
)
)
;
return
*
static_cast
<
const
IonICEntry
*
>
(
this
)
;
}
inline
const
BaselineEntry
&
JitcodeGlobalEntry
:
:
asBaseline
(
)
const
{
MOZ_ASSERT
(
isBaseline
(
)
)
;
return
*
static_cast
<
const
BaselineEntry
*
>
(
this
)
;
}
inline
const
BaselineInterpreterEntry
&
JitcodeGlobalEntry
:
:
asBaselineInterpreter
(
)
const
{
MOZ_ASSERT
(
isBaselineInterpreter
(
)
)
;
return
*
static_cast
<
const
BaselineInterpreterEntry
*
>
(
this
)
;
}
inline
const
DummyEntry
&
JitcodeGlobalEntry
:
:
asDummy
(
)
const
{
MOZ_ASSERT
(
isDummy
(
)
)
;
return
*
static_cast
<
const
DummyEntry
*
>
(
this
)
;
}
inline
const
SelfHostedSharedEntry
&
JitcodeGlobalEntry
:
:
asSelfHostedShared
(
)
const
{
MOZ_ASSERT
(
isSelfHostedShared
(
)
)
;
return
*
static_cast
<
const
SelfHostedSharedEntry
*
>
(
this
)
;
}
inline
IonEntry
&
JitcodeGlobalEntry
:
:
asIon
(
)
{
MOZ_ASSERT
(
isIon
(
)
)
;
return
*
static_cast
<
IonEntry
*
>
(
this
)
;
}
inline
IonICEntry
&
JitcodeGlobalEntry
:
:
asIonIC
(
)
{
MOZ_ASSERT
(
isIonIC
(
)
)
;
return
*
static_cast
<
IonICEntry
*
>
(
this
)
;
}
inline
BaselineEntry
&
JitcodeGlobalEntry
:
:
asBaseline
(
)
{
MOZ_ASSERT
(
isBaseline
(
)
)
;
return
*
static_cast
<
BaselineEntry
*
>
(
this
)
;
}
inline
BaselineInterpreterEntry
&
JitcodeGlobalEntry
:
:
asBaselineInterpreter
(
)
{
MOZ_ASSERT
(
isBaselineInterpreter
(
)
)
;
return
*
static_cast
<
BaselineInterpreterEntry
*
>
(
this
)
;
}
inline
DummyEntry
&
JitcodeGlobalEntry
:
:
asDummy
(
)
{
MOZ_ASSERT
(
isDummy
(
)
)
;
return
*
static_cast
<
DummyEntry
*
>
(
this
)
;
}
inline
SelfHostedSharedEntry
&
JitcodeGlobalEntry
:
:
asSelfHostedShared
(
)
{
MOZ_ASSERT
(
isSelfHostedShared
(
)
)
;
return
*
static_cast
<
SelfHostedSharedEntry
*
>
(
this
)
;
}
class
JitcodeGlobalTable
{
private
:
using
EntryVector
=
Vector
<
UniqueJitcodeGlobalEntry
0
SystemAllocPolicy
>
;
EntryVector
entries_
;
using
EntryTree
=
AvlTree
<
JitCodeRange
*
JitCodeRange
>
;
static
const
size_t
LIFO_CHUNK_SIZE
=
16
*
1024
;
LifoAlloc
alloc_
;
EntryTree
tree_
;
public
:
JitcodeGlobalTable
(
)
:
alloc_
(
LIFO_CHUNK_SIZE
js
:
:
BackgroundMallocArena
)
tree_
(
&
alloc_
)
{
}
bool
empty
(
)
const
{
MOZ_ASSERT
(
entries_
.
empty
(
)
=
=
tree_
.
empty
(
)
)
;
return
entries_
.
empty
(
)
;
}
JitcodeGlobalEntry
*
lookup
(
void
*
ptr
)
{
return
lookupInternal
(
ptr
)
;
}
const
JitcodeGlobalEntry
*
lookupForSampler
(
void
*
ptr
JSRuntime
*
rt
uint64_t
samplePosInBuffer
)
;
[
[
nodiscard
]
]
bool
addEntry
(
UniqueJitcodeGlobalEntry
entry
)
;
void
setAllEntriesAsExpired
(
)
;
[
[
nodiscard
]
]
bool
markIteratively
(
GCMarker
*
marker
)
;
void
traceWeak
(
JSRuntime
*
rt
JSTracer
*
trc
)
;
private
:
JitcodeGlobalEntry
*
lookupInternal
(
void
*
ptr
)
;
}
;
class
JitcodeRegionEntry
{
private
:
static
const
unsigned
MAX_RUN_LENGTH
=
100
;
public
:
static
void
WriteHead
(
CompactBufferWriter
&
writer
uint32_t
nativeOffset
uint8_t
scriptDepth
)
;
static
void
ReadHead
(
CompactBufferReader
&
reader
uint32_t
*
nativeOffset
uint8_t
*
scriptDepth
)
;
static
void
WriteScriptPc
(
CompactBufferWriter
&
writer
uint32_t
scriptIdx
uint32_t
pcOffset
)
;
static
void
ReadScriptPc
(
CompactBufferReader
&
reader
uint32_t
*
scriptIdx
uint32_t
*
pcOffset
)
;
static
void
WriteDelta
(
CompactBufferWriter
&
writer
uint32_t
nativeDelta
int32_t
pcDelta
)
;
static
void
ReadDelta
(
CompactBufferReader
&
reader
uint32_t
*
nativeDelta
int32_t
*
pcDelta
)
;
static
uint32_t
ExpectedRunLength
(
const
NativeToBytecode
*
entry
const
NativeToBytecode
*
end
)
;
[
[
nodiscard
]
]
static
bool
WriteRun
(
CompactBufferWriter
&
writer
const
IonEntry
:
:
ScriptList
&
scriptList
uint32_t
runLength
const
NativeToBytecode
*
entry
)
;
static
const
uint32_t
ENC1_MASK
=
0x1
;
static
const
uint32_t
ENC1_MASK_VAL
=
0x0
;
static
const
uint32_t
ENC1_NATIVE_DELTA_MAX
=
0xf
;
static
const
unsigned
ENC1_NATIVE_DELTA_SHIFT
=
4
;
static
const
uint32_t
ENC1_PC_DELTA_MASK
=
0x0e
;
static
const
int32_t
ENC1_PC_DELTA_MAX
=
0x7
;
static
const
unsigned
ENC1_PC_DELTA_SHIFT
=
1
;
static
const
uint32_t
ENC2_MASK
=
0x3
;
static
const
uint32_t
ENC2_MASK_VAL
=
0x1
;
static
const
uint32_t
ENC2_NATIVE_DELTA_MAX
=
0xff
;
static
const
unsigned
ENC2_NATIVE_DELTA_SHIFT
=
8
;
static
const
uint32_t
ENC2_PC_DELTA_MASK
=
0x00fc
;
static
const
int32_t
ENC2_PC_DELTA_MAX
=
0x3f
;
static
const
unsigned
ENC2_PC_DELTA_SHIFT
=
2
;
static
const
uint32_t
ENC3_MASK
=
0x7
;
static
const
uint32_t
ENC3_MASK_VAL
=
0x3
;
static
const
uint32_t
ENC3_NATIVE_DELTA_MAX
=
0x7ff
;
static
const
unsigned
ENC3_NATIVE_DELTA_SHIFT
=
13
;
static
const
uint32_t
ENC3_PC_DELTA_MASK
=
0x001ff8
;
static
const
int32_t
ENC3_PC_DELTA_MAX
=
0x1ff
;
static
const
int32_t
ENC3_PC_DELTA_MIN
=
-
ENC3_PC_DELTA_MAX
-
1
;
static
const
unsigned
ENC3_PC_DELTA_SHIFT
=
3
;
static
const
uint32_t
ENC4_MASK
=
0x7
;
static
const
uint32_t
ENC4_MASK_VAL
=
0x7
;
static
const
uint32_t
ENC4_NATIVE_DELTA_MAX
=
0xffff
;
static
const
unsigned
ENC4_NATIVE_DELTA_SHIFT
=
16
;
static
const
uint32_t
ENC4_PC_DELTA_MASK
=
0x0000fff8
;
static
const
int32_t
ENC4_PC_DELTA_MAX
=
0xfff
;
static
const
int32_t
ENC4_PC_DELTA_MIN
=
-
ENC4_PC_DELTA_MAX
-
1
;
static
const
unsigned
ENC4_PC_DELTA_SHIFT
=
3
;
static
bool
IsDeltaEncodeable
(
uint32_t
nativeDelta
int32_t
pcDelta
)
{
return
(
nativeDelta
<
=
ENC4_NATIVE_DELTA_MAX
)
&
&
(
pcDelta
>
=
ENC4_PC_DELTA_MIN
)
&
&
(
pcDelta
<
=
ENC4_PC_DELTA_MAX
)
;
}
private
:
const
uint8_t
*
data_
;
const
uint8_t
*
end_
;
uint32_t
nativeOffset_
;
uint8_t
scriptDepth_
;
const
uint8_t
*
scriptPcStack_
;
const
uint8_t
*
deltaRun_
;
void
unpack
(
)
;
public
:
JitcodeRegionEntry
(
const
uint8_t
*
data
const
uint8_t
*
end
)
:
data_
(
data
)
end_
(
end
)
nativeOffset_
(
0
)
scriptDepth_
(
0
)
scriptPcStack_
(
nullptr
)
deltaRun_
(
nullptr
)
{
MOZ_ASSERT
(
data_
<
end_
)
;
unpack
(
)
;
MOZ_ASSERT
(
scriptPcStack_
<
end_
)
;
MOZ_ASSERT
(
deltaRun_
<
=
end_
)
;
}
uint32_t
nativeOffset
(
)
const
{
return
nativeOffset_
;
}
uint32_t
scriptDepth
(
)
const
{
return
scriptDepth_
;
}
class
ScriptPcIterator
{
private
:
const
uint8_t
*
start_
;
const
uint8_t
*
end_
;
#
ifdef
DEBUG
uint32_t
count_
;
#
endif
uint32_t
idx_
;
const
uint8_t
*
cur_
;
public
:
ScriptPcIterator
(
const
uint8_t
*
start
const
uint8_t
*
end
uint32_t
count
)
:
start_
(
start
)
end_
(
end
)
#
ifdef
DEBUG
count_
(
count
)
#
endif
idx_
(
0
)
cur_
(
start_
)
{
}
bool
hasMore
(
)
const
{
MOZ_ASSERT
(
(
idx_
=
=
count_
)
=
=
(
cur_
=
=
end_
)
)
;
MOZ_ASSERT
(
(
idx_
<
count_
)
=
=
(
cur_
<
end_
)
)
;
return
cur_
<
end_
;
}
void
readNext
(
uint32_t
*
scriptIdxOut
uint32_t
*
pcOffsetOut
)
{
MOZ_ASSERT
(
scriptIdxOut
)
;
MOZ_ASSERT
(
pcOffsetOut
)
;
MOZ_ASSERT
(
hasMore
(
)
)
;
CompactBufferReader
reader
(
cur_
end_
)
;
ReadScriptPc
(
reader
scriptIdxOut
pcOffsetOut
)
;
cur_
=
reader
.
currentPosition
(
)
;
MOZ_ASSERT
(
cur_
<
=
end_
)
;
idx_
+
+
;
MOZ_ASSERT_IF
(
idx_
=
=
count_
cur_
=
=
end_
)
;
}
void
reset
(
)
{
idx_
=
0
;
cur_
=
start_
;
}
}
;
ScriptPcIterator
scriptPcIterator
(
)
const
{
return
ScriptPcIterator
(
scriptPcStack_
deltaRun_
scriptDepth_
)
;
}
class
DeltaIterator
{
private
:
const
uint8_t
*
start_
;
const
uint8_t
*
end_
;
const
uint8_t
*
cur_
;
public
:
DeltaIterator
(
const
uint8_t
*
start
const
uint8_t
*
end
)
:
start_
(
start
)
end_
(
end
)
cur_
(
start
)
{
}
bool
hasMore
(
)
const
{
MOZ_ASSERT
(
cur_
<
=
end_
)
;
return
cur_
<
end_
;
}
void
readNext
(
uint32_t
*
nativeDeltaOut
int32_t
*
pcDeltaOut
)
{
MOZ_ASSERT
(
nativeDeltaOut
!
=
nullptr
)
;
MOZ_ASSERT
(
pcDeltaOut
!
=
nullptr
)
;
MOZ_ASSERT
(
hasMore
(
)
)
;
CompactBufferReader
reader
(
cur_
end_
)
;
ReadDelta
(
reader
nativeDeltaOut
pcDeltaOut
)
;
cur_
=
reader
.
currentPosition
(
)
;
MOZ_ASSERT
(
cur_
<
=
end_
)
;
}
void
reset
(
)
{
cur_
=
start_
;
}
}
;
DeltaIterator
deltaIterator
(
)
const
{
return
DeltaIterator
(
deltaRun_
end_
)
;
}
uint32_t
findPcOffset
(
uint32_t
queryNativeOffset
uint32_t
startPcOffset
)
const
;
}
;
class
JitcodeIonTable
{
private
:
uint32_t
numRegions_
;
uint32_t
regionOffsets_
[
1
]
;
const
uint8_t
*
payloadEnd
(
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
;
}
public
:
JitcodeIonTable
(
)
=
delete
;
uint32_t
numRegions
(
)
const
{
return
numRegions_
;
}
uint32_t
regionOffset
(
uint32_t
regionIndex
)
const
{
MOZ_ASSERT
(
regionIndex
<
numRegions
(
)
)
;
return
regionOffsets_
[
regionIndex
]
;
}
JitcodeRegionEntry
regionEntry
(
uint32_t
regionIndex
)
const
{
const
uint8_t
*
regionStart
=
payloadEnd
(
)
-
regionOffset
(
regionIndex
)
;
const
uint8_t
*
regionEnd
=
payloadEnd
(
)
;
if
(
regionIndex
<
numRegions_
-
1
)
{
regionEnd
-
=
regionOffset
(
regionIndex
+
1
)
;
}
return
JitcodeRegionEntry
(
regionStart
regionEnd
)
;
}
uint32_t
findRegionEntry
(
uint32_t
offset
)
const
;
const
uint8_t
*
payloadStart
(
)
const
{
return
payloadEnd
(
)
-
regionOffset
(
0
)
;
}
[
[
nodiscard
]
]
static
bool
WriteIonTable
(
CompactBufferWriter
&
writer
const
IonEntry
:
:
ScriptList
&
scriptList
const
NativeToBytecode
*
start
const
NativeToBytecode
*
end
uint32_t
*
tableOffsetOut
uint32_t
*
numRegionsOut
)
;
}
;
}
}
#
endif
