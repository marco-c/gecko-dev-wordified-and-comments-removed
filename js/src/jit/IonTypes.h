#
ifndef
jit_IonTypes_h
#
define
jit_IonTypes_h
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
class
IonCompilationId
{
uint32_t
idLo_
;
uint32_t
idHi_
;
public
:
explicit
IonCompilationId
(
uint64_t
id
)
:
idLo_
(
id
&
UINT32_MAX
)
idHi_
(
id
>
>
32
)
{
}
bool
operator
=
=
(
const
IonCompilationId
&
other
)
const
{
return
idLo_
=
=
other
.
idLo_
&
&
idHi_
=
=
other
.
idHi_
;
}
bool
operator
!
=
(
const
IonCompilationId
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
}
;
namespace
jit
{
using
RecoverOffset
=
uint32_t
;
using
SnapshotOffset
=
uint32_t
;
using
BailoutId
=
uint32_t
;
static
const
uint32_t
MAX_BUFFER_SIZE
=
(
1
<
<
30
)
-
1
;
static
const
uint32_t
SNAPSHOT_MAX_NARGS
=
127
;
static
const
SnapshotOffset
INVALID_RECOVER_OFFSET
=
uint32_t
(
-
1
)
;
static
const
SnapshotOffset
INVALID_SNAPSHOT_OFFSET
=
uint32_t
(
-
1
)
;
enum
class
BailoutKind
:
uint8_t
{
Inevitable
DuringVMCall
TooManyArguments
DynamicNameNotFound
Overflow
Round
NonPrimitiveInput
PrecisionLoss
TypeBarrierO
TypeBarrierV
Hole
NoDenseElementsGuard
NegativeIndex
ObjectIdentityOrTypeGuard
SpecificAtomGuard
SpecificSymbolGuard
StringToIndexGuard
StringToInt32Guard
StringToDoubleGuard
NonInt32Input
NonNumericInput
NonBooleanInput
NonObjectInput
NonStringInput
NonSymbolInput
NonBigIntInput
Debugger
FirstExecution
NonInt32ArrayLength
OverflowInvalidate
DoubleOutput
ArgumentCheck
BoundsCheck
ShapeGuard
ProtoGuard
ProxyGuard
NotProxyGuard
NotDOMProxyGuard
NotArrayBufferMaybeSharedGuard
MegamorphicAccess
ArgumentsObjectAccess
ArrayPopShift
ArraySlice
ValueGuard
NotOptimizedArgumentsGuard
NullOrUndefinedGuard
TagNotEqualGuard
FunctionFlagsGuard
FunctionKindGuard
FunctionScriptGuard
PackedArrayGuard
UninitializedLexical
IonExceptionDebugMode
Limit
}
;
inline
const
char
*
BailoutKindString
(
BailoutKind
kind
)
{
switch
(
kind
)
{
case
BailoutKind
:
:
Inevitable
:
return
"
BailoutKind
:
:
Inevitable
"
;
case
BailoutKind
:
:
DuringVMCall
:
return
"
BailoutKind
:
:
DuringVMCall
"
;
case
BailoutKind
:
:
TooManyArguments
:
return
"
BailoutKind
:
:
TooManyArguments
"
;
case
BailoutKind
:
:
DynamicNameNotFound
:
return
"
BailoutKind
:
:
DynamicNameNotFound
"
;
case
BailoutKind
:
:
Overflow
:
return
"
BailoutKind
:
:
Overflow
"
;
case
BailoutKind
:
:
Round
:
return
"
BailoutKind
:
:
Round
"
;
case
BailoutKind
:
:
NonPrimitiveInput
:
return
"
BailoutKind
:
:
NonPrimitiveInput
"
;
case
BailoutKind
:
:
PrecisionLoss
:
return
"
BailoutKind
:
:
PrecisionLoss
"
;
case
BailoutKind
:
:
TypeBarrierO
:
return
"
BailoutKind
:
:
TypeBarrierO
"
;
case
BailoutKind
:
:
TypeBarrierV
:
return
"
BailoutKind
:
:
TypeBarrierV
"
;
case
BailoutKind
:
:
Hole
:
return
"
BailoutKind
:
:
Hole
"
;
case
BailoutKind
:
:
NoDenseElementsGuard
:
return
"
BailoutKind
:
:
NoDenseElementsGuard
"
;
case
BailoutKind
:
:
NegativeIndex
:
return
"
BailoutKind
:
:
NegativeIndex
"
;
case
BailoutKind
:
:
ObjectIdentityOrTypeGuard
:
return
"
BailoutKind
:
:
ObjectIdentityOrTypeGuard
"
;
case
BailoutKind
:
:
SpecificAtomGuard
:
return
"
BailoutKind
:
:
SpecifcAtomGuard
"
;
case
BailoutKind
:
:
SpecificSymbolGuard
:
return
"
BailoutKind
:
:
SpecificSymbolGuard
"
;
case
BailoutKind
:
:
StringToIndexGuard
:
return
"
BailoutKind
:
:
StringToIndexGuard
"
;
case
BailoutKind
:
:
StringToInt32Guard
:
return
"
BailoutKind
:
:
StringToInt32Guard
"
;
case
BailoutKind
:
:
StringToDoubleGuard
:
return
"
BailoutKind
:
:
StringToDoubleGuard
"
;
case
BailoutKind
:
:
NonInt32Input
:
return
"
BailoutKind
:
:
NonInt32Input
"
;
case
BailoutKind
:
:
NonNumericInput
:
return
"
BailoutKind
:
:
NonNumericInput
"
;
case
BailoutKind
:
:
NonBooleanInput
:
return
"
BailoutKind
:
:
NonBooleanInput
"
;
case
BailoutKind
:
:
NonObjectInput
:
return
"
BailoutKind
:
:
NonObjectInput
"
;
case
BailoutKind
:
:
NonStringInput
:
return
"
BailoutKind
:
:
NonStringInput
"
;
case
BailoutKind
:
:
NonSymbolInput
:
return
"
BailoutKind
:
:
NonSymbolInput
"
;
case
BailoutKind
:
:
NonBigIntInput
:
return
"
BailoutKind
:
:
NonBigIntInput
"
;
case
BailoutKind
:
:
Debugger
:
return
"
BailoutKind
:
:
Debugger
"
;
case
BailoutKind
:
:
FirstExecution
:
return
"
BailoutKind
:
:
FirstExecution
"
;
case
BailoutKind
:
:
NonInt32ArrayLength
:
return
"
BailoutKind
:
:
NonInt32ArrayLength
"
;
case
BailoutKind
:
:
OverflowInvalidate
:
return
"
BailoutKind
:
:
OverflowInvalidate
"
;
case
BailoutKind
:
:
DoubleOutput
:
return
"
BailoutKind
:
:
DoubleOutput
"
;
case
BailoutKind
:
:
ArgumentCheck
:
return
"
BailoutKind
:
:
ArgumentCheck
"
;
case
BailoutKind
:
:
BoundsCheck
:
return
"
BailoutKind
:
:
BoundsCheck
"
;
case
BailoutKind
:
:
ShapeGuard
:
return
"
BailoutKind
:
:
ShapeGuard
"
;
case
BailoutKind
:
:
ProtoGuard
:
return
"
BailoutKind
:
:
ProtoGuard
"
;
case
BailoutKind
:
:
ProxyGuard
:
return
"
BailoutKind
:
:
ProxyGuard
"
;
case
BailoutKind
:
:
NotProxyGuard
:
return
"
BailoutKind
:
:
NotProxyGuard
"
;
case
BailoutKind
:
:
NotDOMProxyGuard
:
return
"
BailoutKind
:
:
NotDOMProxyGuard
"
;
case
BailoutKind
:
:
NotArrayBufferMaybeSharedGuard
:
return
"
BailoutKind
:
:
NotArrayBufferMaybeSharedGuard
"
;
case
BailoutKind
:
:
MegamorphicAccess
:
return
"
BailoutKind
:
:
MegamorphicAccess
"
;
case
BailoutKind
:
:
ArgumentsObjectAccess
:
return
"
BailoutKind
:
:
ArgumentsObjectAccess
"
;
case
BailoutKind
:
:
ArrayPopShift
:
return
"
BailoutKind
:
:
ArrayPopShift
"
;
case
BailoutKind
:
:
ArraySlice
:
return
"
BailoutKind
:
:
ArraySlice
"
;
case
BailoutKind
:
:
ValueGuard
:
return
"
BailoutKind
:
:
ValueGuard
"
;
case
BailoutKind
:
:
NotOptimizedArgumentsGuard
:
return
"
BailoutKind
:
:
NotOptimizedArgumentsGuard
"
;
case
BailoutKind
:
:
NullOrUndefinedGuard
:
return
"
BailoutKind
:
:
NullOrUndefinedGuard
"
;
case
BailoutKind
:
:
TagNotEqualGuard
:
return
"
BailoutKind
:
:
TagNotEqualGuard
"
;
case
BailoutKind
:
:
FunctionFlagsGuard
:
return
"
BailoutKind
:
:
FunctionFlagsGuard
"
;
case
BailoutKind
:
:
FunctionKindGuard
:
return
"
BailoutKind
:
:
FunctionKindGuard
"
;
case
BailoutKind
:
:
FunctionScriptGuard
:
return
"
BailoutKind
:
:
FunctionScriptGuard
"
;
case
BailoutKind
:
:
PackedArrayGuard
:
return
"
BailoutKind
:
:
PackedArrayGuard
"
;
case
BailoutKind
:
:
UninitializedLexical
:
return
"
BailoutKind
:
:
UninitializedLexical
"
;
case
BailoutKind
:
:
IonExceptionDebugMode
:
return
"
BailoutKind
:
:
IonExceptionDebugMode
"
;
case
BailoutKind
:
:
Limit
:
break
;
}
MOZ_CRASH
(
"
Invalid
BailoutKind
"
)
;
}
static
const
uint32_t
ELEMENT_TYPE_BITS
=
5
;
static
const
uint32_t
ELEMENT_TYPE_SHIFT
=
0
;
static
const
uint32_t
ELEMENT_TYPE_MASK
=
(
1
<
<
ELEMENT_TYPE_BITS
)
-
1
;
static
const
uint32_t
VECTOR_TYPE_BITS
=
1
;
static
const
uint32_t
VECTOR_TYPE_SHIFT
=
ELEMENT_TYPE_BITS
+
ELEMENT_TYPE_SHIFT
;
static
const
uint32_t
VECTOR_TYPE_MASK
=
(
1
<
<
VECTOR_TYPE_BITS
)
-
1
;
enum
class
SimdSign
{
NotApplicable
Unsigned
Signed
}
;
class
SimdConstant
{
public
:
enum
Type
{
Int8x16
Int16x8
Int32x4
Int64x2
Float32x4
Float64x2
Undefined
=
-
1
}
;
typedef
int8_t
I8x16
[
16
]
;
typedef
int16_t
I16x8
[
8
]
;
typedef
int32_t
I32x4
[
4
]
;
typedef
int64_t
I64x2
[
2
]
;
typedef
float
F32x4
[
4
]
;
typedef
double
F64x2
[
2
]
;
private
:
Type
type_
;
union
{
I8x16
i8x16
;
I16x8
i16x8
;
I32x4
i32x4
;
I64x2
i64x2
;
F32x4
f32x4
;
F64x2
f64x2
;
}
u
;
bool
defined
(
)
const
{
return
type_
!
=
Undefined
;
}
public
:
static
SimdConstant
CreateX16
(
const
int8_t
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Int8x16
;
memcpy
(
cst
.
u
.
i8x16
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX16
(
int8_t
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Int8x16
;
std
:
:
fill_n
(
cst
.
u
.
i8x16
16
v
)
;
return
cst
;
}
static
SimdConstant
CreateX8
(
const
int16_t
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Int16x8
;
memcpy
(
cst
.
u
.
i16x8
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX8
(
int16_t
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Int16x8
;
std
:
:
fill_n
(
cst
.
u
.
i16x8
8
v
)
;
return
cst
;
}
static
SimdConstant
CreateX4
(
const
int32_t
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Int32x4
;
memcpy
(
cst
.
u
.
i32x4
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX4
(
int32_t
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Int32x4
;
std
:
:
fill_n
(
cst
.
u
.
i32x4
4
v
)
;
return
cst
;
}
static
SimdConstant
CreateX2
(
const
int64_t
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Int64x2
;
memcpy
(
cst
.
u
.
i64x2
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX2
(
int64_t
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Int64x2
;
std
:
:
fill_n
(
cst
.
u
.
i64x2
2
v
)
;
return
cst
;
}
static
SimdConstant
CreateX4
(
const
float
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Float32x4
;
memcpy
(
cst
.
u
.
f32x4
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX4
(
float
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Float32x4
;
std
:
:
fill_n
(
cst
.
u
.
f32x4
4
v
)
;
return
cst
;
}
static
SimdConstant
CreateX2
(
const
double
*
array
)
{
SimdConstant
cst
;
cst
.
type_
=
Float64x2
;
memcpy
(
cst
.
u
.
f64x2
array
sizeof
(
cst
.
u
)
)
;
return
cst
;
}
static
SimdConstant
SplatX2
(
double
v
)
{
SimdConstant
cst
;
cst
.
type_
=
Float64x2
;
std
:
:
fill_n
(
cst
.
u
.
f64x2
2
v
)
;
return
cst
;
}
static
SimdConstant
CreateSimd128
(
const
int8_t
*
array
)
{
return
CreateX16
(
array
)
;
}
static
SimdConstant
CreateSimd128
(
const
int16_t
*
array
)
{
return
CreateX8
(
array
)
;
}
static
SimdConstant
CreateSimd128
(
const
int32_t
*
array
)
{
return
CreateX4
(
array
)
;
}
static
SimdConstant
CreateSimd128
(
const
int64_t
*
array
)
{
return
CreateX2
(
array
)
;
}
static
SimdConstant
CreateSimd128
(
const
float
*
array
)
{
return
CreateX4
(
array
)
;
}
static
SimdConstant
CreateSimd128
(
const
double
*
array
)
{
return
CreateX2
(
array
)
;
}
Type
type
(
)
const
{
MOZ_ASSERT
(
defined
(
)
)
;
return
type_
;
}
const
void
*
bytes
(
)
const
{
return
u
.
i8x16
;
}
const
I8x16
&
asInt8x16
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Int8x16
)
;
return
u
.
i8x16
;
}
const
I16x8
&
asInt16x8
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Int16x8
)
;
return
u
.
i16x8
;
}
const
I32x4
&
asInt32x4
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Int32x4
)
;
return
u
.
i32x4
;
}
const
I64x2
&
asInt64x2
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Int64x2
)
;
return
u
.
i64x2
;
}
const
F32x4
&
asFloat32x4
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Float32x4
)
;
return
u
.
f32x4
;
}
const
F64x2
&
asFloat64x2
(
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
type_
=
=
Float64x2
)
;
return
u
.
f64x2
;
}
bool
operator
=
=
(
const
SimdConstant
&
rhs
)
const
{
MOZ_ASSERT
(
defined
(
)
&
&
rhs
.
defined
(
)
)
;
if
(
type
(
)
!
=
rhs
.
type
(
)
)
{
return
false
;
}
return
memcmp
(
&
u
&
rhs
.
u
sizeof
(
u
)
)
=
=
0
;
}
bool
operator
!
=
(
const
SimdConstant
&
rhs
)
const
{
return
!
operator
=
=
(
rhs
)
;
}
bool
isIntegerZero
(
)
const
{
return
type_
<
=
Int64x2
&
&
u
.
i64x2
[
0
]
=
=
0
&
&
u
.
i64x2
[
1
]
=
=
0
;
}
using
Lookup
=
SimdConstant
;
static
HashNumber
hash
(
const
SimdConstant
&
val
)
{
uint32_t
hash
=
mozilla
:
:
HashBytes
(
&
val
.
u
sizeof
(
val
.
u
)
)
;
return
mozilla
:
:
AddToHash
(
hash
val
.
type_
)
;
}
static
bool
match
(
const
SimdConstant
&
lhs
const
SimdConstant
&
rhs
)
{
return
lhs
=
=
rhs
;
}
}
;
enum
class
IntConversionBehavior
{
Normal
NegativeZeroCheck
Truncate
TruncateNoWrap
ClampToUint8
}
;
enum
class
IntConversionInputKind
{
NumbersOnly
NumbersOrBoolsOnly
Any
}
;
enum
class
MIRType
:
uint8_t
{
Undefined
Null
Boolean
Int32
Int64
Double
Float32
String
Symbol
BigInt
Simd128
Object
MagicOptimizedArguments
MagicOptimizedOut
MagicHole
MagicIsConstructing
MagicUninitializedLexical
Value
ObjectOrNull
None
Slots
Elements
Pointer
RefOrNull
StackResults
Shape
ObjectGroup
Last
=
ObjectGroup
}
;
static
inline
MIRType
MIRTypeFromValueType
(
JSValueType
type
)
{
switch
(
type
)
{
case
JSVAL_TYPE_DOUBLE
:
return
MIRType
:
:
Double
;
case
JSVAL_TYPE_INT32
:
return
MIRType
:
:
Int32
;
case
JSVAL_TYPE_UNDEFINED
:
return
MIRType
:
:
Undefined
;
case
JSVAL_TYPE_STRING
:
return
MIRType
:
:
String
;
case
JSVAL_TYPE_SYMBOL
:
return
MIRType
:
:
Symbol
;
case
JSVAL_TYPE_BIGINT
:
return
MIRType
:
:
BigInt
;
case
JSVAL_TYPE_BOOLEAN
:
return
MIRType
:
:
Boolean
;
case
JSVAL_TYPE_NULL
:
return
MIRType
:
:
Null
;
case
JSVAL_TYPE_OBJECT
:
return
MIRType
:
:
Object
;
case
JSVAL_TYPE_UNKNOWN
:
return
MIRType
:
:
Value
;
default
:
MOZ_CRASH
(
"
unexpected
jsval
type
"
)
;
}
}
static
inline
JSValueType
ValueTypeFromMIRType
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Undefined
:
return
JSVAL_TYPE_UNDEFINED
;
case
MIRType
:
:
Null
:
return
JSVAL_TYPE_NULL
;
case
MIRType
:
:
Boolean
:
return
JSVAL_TYPE_BOOLEAN
;
case
MIRType
:
:
Int32
:
return
JSVAL_TYPE_INT32
;
case
MIRType
:
:
Float32
:
case
MIRType
:
:
Double
:
return
JSVAL_TYPE_DOUBLE
;
case
MIRType
:
:
String
:
return
JSVAL_TYPE_STRING
;
case
MIRType
:
:
Symbol
:
return
JSVAL_TYPE_SYMBOL
;
case
MIRType
:
:
BigInt
:
return
JSVAL_TYPE_BIGINT
;
case
MIRType
:
:
MagicOptimizedArguments
:
case
MIRType
:
:
MagicOptimizedOut
:
case
MIRType
:
:
MagicHole
:
case
MIRType
:
:
MagicIsConstructing
:
case
MIRType
:
:
MagicUninitializedLexical
:
return
JSVAL_TYPE_MAGIC
;
default
:
MOZ_ASSERT
(
type
=
=
MIRType
:
:
Object
)
;
return
JSVAL_TYPE_OBJECT
;
}
}
static
inline
JSValueTag
MIRTypeToTag
(
MIRType
type
)
{
return
JSVAL_TYPE_TO_TAG
(
ValueTypeFromMIRType
(
type
)
)
;
}
static
inline
size_t
MIRTypeToSize
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Int32
:
return
4
;
case
MIRType
:
:
Int64
:
return
8
;
case
MIRType
:
:
Float32
:
return
4
;
case
MIRType
:
:
Double
:
return
8
;
case
MIRType
:
:
Simd128
:
return
16
;
case
MIRType
:
:
Pointer
:
case
MIRType
:
:
RefOrNull
:
return
sizeof
(
uintptr_t
)
;
default
:
MOZ_CRASH
(
"
MIRTypeToSize
-
unhandled
case
"
)
;
}
}
static
inline
const
char
*
StringFromMIRType
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Undefined
:
return
"
Undefined
"
;
case
MIRType
:
:
Null
:
return
"
Null
"
;
case
MIRType
:
:
Boolean
:
return
"
Bool
"
;
case
MIRType
:
:
Int32
:
return
"
Int32
"
;
case
MIRType
:
:
Int64
:
return
"
Int64
"
;
case
MIRType
:
:
Double
:
return
"
Double
"
;
case
MIRType
:
:
Float32
:
return
"
Float32
"
;
case
MIRType
:
:
String
:
return
"
String
"
;
case
MIRType
:
:
Symbol
:
return
"
Symbol
"
;
case
MIRType
:
:
BigInt
:
return
"
BigInt
"
;
case
MIRType
:
:
Object
:
return
"
Object
"
;
case
MIRType
:
:
MagicOptimizedArguments
:
return
"
MagicOptimizedArguments
"
;
case
MIRType
:
:
MagicOptimizedOut
:
return
"
MagicOptimizedOut
"
;
case
MIRType
:
:
MagicHole
:
return
"
MagicHole
"
;
case
MIRType
:
:
MagicIsConstructing
:
return
"
MagicIsConstructing
"
;
case
MIRType
:
:
MagicUninitializedLexical
:
return
"
MagicUninitializedLexical
"
;
case
MIRType
:
:
Value
:
return
"
Value
"
;
case
MIRType
:
:
ObjectOrNull
:
return
"
ObjectOrNull
"
;
case
MIRType
:
:
None
:
return
"
None
"
;
case
MIRType
:
:
Slots
:
return
"
Slots
"
;
case
MIRType
:
:
Elements
:
return
"
Elements
"
;
case
MIRType
:
:
Pointer
:
return
"
Pointer
"
;
case
MIRType
:
:
RefOrNull
:
return
"
RefOrNull
"
;
case
MIRType
:
:
StackResults
:
return
"
StackResults
"
;
case
MIRType
:
:
Shape
:
return
"
Shape
"
;
case
MIRType
:
:
ObjectGroup
:
return
"
ObjectGroup
"
;
case
MIRType
:
:
Simd128
:
return
"
Simd128
"
;
}
MOZ_CRASH
(
"
Unknown
MIRType
.
"
)
;
}
static
inline
bool
IsIntType
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
Int64
;
}
static
inline
bool
IsNumberType
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
Double
|
|
type
=
=
MIRType
:
:
Float32
|
|
type
=
=
MIRType
:
:
Int64
;
}
static
inline
bool
IsNumericType
(
MIRType
type
)
{
return
IsNumberType
(
type
)
|
|
type
=
=
MIRType
:
:
BigInt
;
}
static
inline
bool
IsTypeRepresentableAsDouble
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
Double
|
|
type
=
=
MIRType
:
:
Float32
;
}
static
inline
bool
IsFloatType
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
Float32
;
}
static
inline
bool
IsFloatingPointType
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Double
|
|
type
=
=
MIRType
:
:
Float32
;
}
static
inline
bool
IsNullOrUndefined
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
Null
|
|
type
=
=
MIRType
:
:
Undefined
;
}
static
inline
bool
IsMagicType
(
MIRType
type
)
{
return
type
=
=
MIRType
:
:
MagicHole
|
|
type
=
=
MIRType
:
:
MagicOptimizedOut
|
|
type
=
=
MIRType
:
:
MagicIsConstructing
|
|
type
=
=
MIRType
:
:
MagicOptimizedArguments
|
|
type
=
=
MIRType
:
:
MagicUninitializedLexical
;
}
static
inline
MIRType
ScalarTypeToMIRType
(
Scalar
:
:
Type
type
)
{
switch
(
type
)
{
case
Scalar
:
:
Int8
:
case
Scalar
:
:
Uint8
:
case
Scalar
:
:
Int16
:
case
Scalar
:
:
Uint16
:
case
Scalar
:
:
Int32
:
case
Scalar
:
:
Uint32
:
case
Scalar
:
:
Uint8Clamped
:
return
MIRType
:
:
Int32
;
case
Scalar
:
:
Int64
:
return
MIRType
:
:
Int64
;
case
Scalar
:
:
Float32
:
return
MIRType
:
:
Float32
;
case
Scalar
:
:
Float64
:
return
MIRType
:
:
Double
;
case
Scalar
:
:
BigInt64
:
case
Scalar
:
:
BigUint64
:
MOZ_CRASH
(
"
NYI
"
)
;
case
Scalar
:
:
Simd128
:
return
MIRType
:
:
Simd128
;
case
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
static
constexpr
bool
NeedsPostBarrier
(
MIRType
type
)
{
MOZ_ASSERT
(
type
!
=
MIRType
:
:
Value
)
;
MOZ_ASSERT
(
type
!
=
MIRType
:
:
ObjectOrNull
)
;
return
type
=
=
MIRType
:
:
Object
|
|
type
=
=
MIRType
:
:
String
|
|
type
=
=
MIRType
:
:
BigInt
;
}
#
ifdef
DEBUG
#
define
TRACK_SNAPSHOTS
1
#
define
CHECK_OSIPOINT_REGISTERS
1
#
endif
enum
ABIArgType
{
ArgType_General
=
0x1
ArgType_Int32
=
0x2
ArgType_Int64
=
0x3
ArgType_Float32
=
0x4
ArgType_Float64
=
0x5
RetType_Shift
=
0x0
ArgType_Shift
=
0x3
ArgType_Mask
=
0x7
}
;
namespace
detail
{
static
constexpr
int
MakeABIFunctionType
(
ABIArgType
ret
std
:
:
initializer_list
<
ABIArgType
>
args
)
{
int
abiType
=
ret
<
<
RetType_Shift
;
int
i
=
1
;
for
(
auto
arg
:
args
)
{
abiType
|
=
(
arg
<
<
(
ArgType_Shift
*
i
)
)
;
i
+
+
;
}
return
abiType
;
}
}
enum
ABIFunctionType
{
Args_General0
=
ArgType_General
<
<
RetType_Shift
Args_General1
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
Args_General2
=
Args_General1
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
Args_General3
=
Args_General2
|
(
ArgType_General
<
<
(
ArgType_Shift
*
3
)
)
Args_General4
=
Args_General3
|
(
ArgType_General
<
<
(
ArgType_Shift
*
4
)
)
Args_General5
=
Args_General4
|
(
ArgType_General
<
<
(
ArgType_Shift
*
5
)
)
Args_General6
=
Args_General5
|
(
ArgType_General
<
<
(
ArgType_Shift
*
6
)
)
Args_General7
=
Args_General6
|
(
ArgType_General
<
<
(
ArgType_Shift
*
7
)
)
Args_General8
=
Args_General7
|
(
ArgType_General
<
<
(
ArgType_Shift
*
8
)
)
Args_Int64_Double
=
(
ArgType_Int64
<
<
RetType_Shift
)
|
(
ArgType_Float64
<
<
ArgType_Shift
)
Args_Double_None
=
ArgType_Float64
<
<
RetType_Shift
Args_Int_Double
=
Args_General0
|
(
ArgType_Float64
<
<
ArgType_Shift
)
Args_Int_Float32
=
Args_General0
|
(
ArgType_Float32
<
<
ArgType_Shift
)
Args_Float32_Float32
=
(
ArgType_Float32
<
<
RetType_Shift
)
|
(
ArgType_Float32
<
<
ArgType_Shift
)
Args_Float32_IntInt
=
(
ArgType_Float32
<
<
RetType_Shift
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
Args_Double_Double
=
Args_Double_None
|
(
ArgType_Float64
<
<
ArgType_Shift
)
Args_Double_Int
=
Args_Double_None
|
(
ArgType_General
<
<
ArgType_Shift
)
Args_Double_IntInt
=
Args_Double_Int
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
Args_Double_DoubleInt
=
Args_Double_None
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
2
)
)
Args_Double_DoubleDouble
=
Args_Double_Double
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
2
)
)
Args_Float32_Float32Float32
=
Args_Float32_Float32
|
(
ArgType_Float32
<
<
(
ArgType_Shift
*
2
)
)
Args_Double_IntDouble
=
Args_Double_None
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
Args_Int_IntDouble
=
Args_General0
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
Args_Int_DoubleInt
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
2
)
)
Args_Double_DoubleDoubleDouble
=
Args_Double_DoubleDouble
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
3
)
)
Args_Double_DoubleDoubleDoubleDouble
=
Args_Double_DoubleDoubleDouble
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
4
)
)
Args_Int_DoubleIntInt
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
3
)
)
Args_Int_IntDoubleIntInt
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
|
(
ArgType_Float64
<
<
(
ArgType_Shift
*
3
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
4
)
)
Args_Int_GeneralGeneralGeneralInt64
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
3
)
)
|
(
ArgType_Int64
<
<
(
ArgType_Shift
*
4
)
)
Args_Int_GeneralGeneralInt64Int64
=
Args_General0
|
(
ArgType_General
<
<
(
ArgType_Shift
*
1
)
)
|
(
ArgType_General
<
<
(
ArgType_Shift
*
2
)
)
|
(
ArgType_Int64
<
<
(
ArgType_Shift
*
3
)
)
|
(
ArgType_Int64
<
<
(
ArgType_Shift
*
4
)
)
Args_Int32_General
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
}
)
Args_Int32_GeneralInt32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
}
)
Args_Int32_GeneralInt32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
}
)
Args_Int32_GeneralInt32Int32Int32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_Int32
ArgType_Int32
}
)
Args_Int32_GeneralInt32Int32Int32Int32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_Int32
ArgType_Int32
ArgType_Int32
}
)
Args_Int32_GeneralInt32Int32Int32General
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_Int32
ArgType_General
}
)
Args_Int32_GeneralInt32Int32Int64
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_Int64
}
)
Args_Int32_GeneralInt32Int32General
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_General
}
)
Args_Int32_GeneralInt32Int64Int64
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_Int64
ArgType_Int64
}
)
Args_Int32_GeneralInt32GeneralInt32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_General
ArgType_Int32
}
)
Args_Int32_GeneralInt32GeneralInt32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_Int32
ArgType_General
ArgType_Int32
ArgType_Int32
}
)
Args_Int32_GeneralGeneral
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_General
}
)
Args_Int32_GeneralGeneralInt32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_Int32
{
ArgType_General
ArgType_General
ArgType_Int32
ArgType_Int32
}
)
Args_General_GeneralInt32
=
detail
:
:
MakeABIFunctionType
(
ArgType_General
{
ArgType_General
ArgType_Int32
}
)
Args_General_GeneralInt32Int32
=
detail
:
:
MakeABIFunctionType
(
ArgType_General
{
ArgType_General
ArgType_Int32
ArgType_Int32
}
)
Args_General_GeneralInt32Int32General
=
detail
:
:
MakeABIFunctionType
(
ArgType_General
{
ArgType_General
ArgType_Int32
ArgType_Int32
ArgType_General
}
)
}
;
static
constexpr
ABIFunctionType
MakeABIFunctionType
(
ABIArgType
ret
std
:
:
initializer_list
<
ABIArgType
>
args
)
{
return
ABIFunctionType
(
detail
:
:
MakeABIFunctionType
(
ret
args
)
)
;
}
enum
class
BarrierKind
:
uint32_t
{
NoBarrier
TypeTagOnly
TypeSet
}
;
enum
ReprotectCode
{
Reprotect
=
true
DontReprotect
=
false
}
;
enum
class
RoundingMode
{
Down
Up
NearestTiesToEven
TowardsZero
}
;
static
const
uint32_t
MAX_UNCHECKED_LEAF_FRAME_SIZE
=
64
;
using
TruncFlags
=
uint32_t
;
static
const
TruncFlags
TRUNC_UNSIGNED
=
TruncFlags
(
1
)
<
<
0
;
static
const
TruncFlags
TRUNC_SATURATING
=
TruncFlags
(
1
)
<
<
1
;
enum
BranchDirection
{
FALSE_BRANCH
TRUE_BRANCH
}
;
template
<
typename
T
>
constexpr
T
SplatByteToUInt
(
uint8_t
val
uint8_t
x
)
{
T
splatted
=
val
;
for
(
;
x
>
1
;
x
-
-
)
{
splatted
|
=
splatted
<
<
8
;
}
return
splatted
;
}
}
}
#
endif
