#
ifndef
jit_BaselineIC_h
#
define
jit_BaselineIC_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
jit
/
BaselineICList
.
h
"
#
include
"
jit
/
ICState
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
jit
/
RegisterSets
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
js
{
class
StackTypeSet
;
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
namespace
jit
{
class
BaselineFrame
;
class
CacheIRStubInfo
;
class
ICScript
;
class
MacroAssembler
;
enum
class
TailCallVMFunctionId
;
enum
class
VMFunctionId
;
class
ICStub
;
class
ICFallbackStub
;
#
define
FORWARD_DECLARE_STUBS
(
kindName
)
class
IC
#
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
FORWARD_DECLARE_STUBS
)
#
undef
FORWARD_DECLARE_STUBS
#
ifdef
JS_JITSPEW
void
FallbackICSpew
(
JSContext
*
cx
ICFallbackStub
*
stub
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
3
4
)
;
#
else
#
define
FallbackICSpew
(
.
.
.
)
#
endif
class
ICEntry
{
ICStub
*
firstStub_
;
uint32_t
pcOffset_
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
#
ifdef
JS_64BIT
static
const
uint32_t
EXPECTED_TRACE_MAGIC
=
0xdeaddead
;
uint32_t
traceMagic_
=
EXPECTED_TRACE_MAGIC
;
#
endif
#
endif
public
:
ICEntry
(
ICStub
*
firstStub
uint32_t
pcOffset
)
:
firstStub_
(
firstStub
)
pcOffset_
(
pcOffset
)
{
}
ICStub
*
firstStub
(
)
const
{
MOZ_ASSERT
(
firstStub_
)
;
return
firstStub_
;
}
ICFallbackStub
*
fallbackStub
(
)
const
;
void
setFirstStub
(
ICStub
*
stub
)
{
firstStub_
=
stub
;
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
jsbytecode
*
pc
(
JSScript
*
script
)
const
{
return
script
-
>
offsetToPC
(
pcOffset
(
)
)
;
}
static
constexpr
size_t
offsetOfFirstStub
(
)
{
return
offsetof
(
ICEntry
firstStub_
)
;
}
inline
ICStub
*
*
addressOfFirstStub
(
)
{
return
&
firstStub_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ICStubConstIterator
{
friend
class
ICStub
;
friend
class
ICFallbackStub
;
private
:
ICStub
*
currentStub_
;
public
:
explicit
ICStubConstIterator
(
ICStub
*
currentStub
)
:
currentStub_
(
currentStub
)
{
}
static
ICStubConstIterator
StartingAt
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
stub
)
;
}
static
ICStubConstIterator
End
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
nullptr
)
;
}
bool
operator
=
=
(
const
ICStubConstIterator
&
other
)
const
{
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubConstIterator
&
operator
+
+
(
)
;
ICStubConstIterator
operator
+
+
(
int
)
{
ICStubConstIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
nullptr
;
}
}
;
class
ICStubIterator
{
friend
class
ICFallbackStub
;
private
:
ICEntry
*
icEntry_
;
ICFallbackStub
*
fallbackStub_
;
ICStub
*
previousStub_
;
ICStub
*
currentStub_
;
bool
unlinked_
;
explicit
ICStubIterator
(
ICFallbackStub
*
fallbackStub
bool
end
=
false
)
;
public
:
bool
operator
=
=
(
const
ICStubIterator
&
other
)
const
{
MOZ_ASSERT
(
icEntry_
=
=
other
.
icEntry_
)
;
MOZ_ASSERT
(
fallbackStub_
=
=
other
.
fallbackStub_
)
;
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubIterator
&
operator
+
+
(
)
;
ICStubIterator
operator
+
+
(
int
)
{
ICStubIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
(
ICStub
*
)
fallbackStub_
;
}
void
unlink
(
JSContext
*
cx
JSScript
*
script
)
;
}
;
class
ICStub
{
friend
class
ICFallbackStub
;
public
:
enum
Kind
:
uint16_t
{
INVALID
=
0
#
define
DEF_ENUM_KIND
(
kindName
)
kindName
IC_BASELINE_STUB_KIND_LIST
(
DEF_ENUM_KIND
)
#
undef
DEF_ENUM_KIND
LIMIT
}
;
static
bool
IsValidKind
(
Kind
k
)
{
return
(
k
>
INVALID
)
&
&
(
k
<
LIMIT
)
;
}
static
bool
IsCacheIRKind
(
Kind
k
)
{
return
k
=
=
CacheIR_Regular
;
}
static
const
char
*
KindString
(
Kind
k
)
{
switch
(
k
)
{
#
define
DEF_KIND_STR
(
kindName
)
\
case
kindName
:
\
return
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
DEF_KIND_STR
)
#
undef
DEF_KIND_STR
default
:
MOZ_CRASH
(
"
Invalid
kind
.
"
)
;
}
}
enum
Trait
:
uint16_t
{
Regular
=
0x0
Fallback
=
0x1
}
;
void
updateCode
(
JitCode
*
stubCode
)
;
void
trace
(
JSTracer
*
trc
)
;
template
<
typename
T
typename
.
.
.
Args
>
static
T
*
New
(
JSContext
*
cx
ICStubSpace
*
space
JitCode
*
code
Args
&
&
.
.
.
args
)
{
if
(
!
code
)
{
return
nullptr
;
}
T
*
result
=
space
-
>
allocate
<
T
>
(
code
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
result
)
{
ReportOutOfMemory
(
cx
)
;
}
return
result
;
}
template
<
typename
T
typename
.
.
.
Args
>
static
T
*
NewFallback
(
JSContext
*
cx
ICStubSpace
*
space
TrampolinePtr
code
Args
&
&
.
.
.
args
)
{
T
*
result
=
space
-
>
allocate
<
T
>
(
code
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
MOZ_UNLIKELY
(
!
result
)
)
{
ReportOutOfMemory
(
cx
)
;
}
return
result
;
}
protected
:
uint8_t
*
stubCode_
;
ICStub
*
next_
=
nullptr
;
uint16_t
extra_
=
0
;
uint16_t
traitKindBits_
;
static
const
uint16_t
TRAIT_OFFSET
=
0
;
static
const
uint16_t
TRAIT_BITS
=
3
;
static
const
uint16_t
TRAIT_MASK
=
(
1
<
<
TRAIT_BITS
)
-
1
;
static
const
uint16_t
KIND_OFFSET
=
TRAIT_OFFSET
+
TRAIT_BITS
;
static
const
uint16_t
KIND_BITS
=
5
;
static
const
uint16_t
KIND_MASK
=
(
1
<
<
KIND_BITS
)
-
1
;
static
const
uint16_t
MAGIC_OFFSET
=
KIND_OFFSET
+
KIND_BITS
;
static
const
uint16_t
MAGIC_BITS
=
8
;
static
const
uint16_t
MAGIC_MASK
=
(
1
<
<
MAGIC_BITS
)
-
1
;
static
const
uint16_t
EXPECTED_MAGIC
=
0b11100011
;
static_assert
(
LIMIT
<
=
(
1
<
<
KIND_BITS
)
"
Not
enough
kind
bits
"
)
;
static_assert
(
LIMIT
>
(
1
<
<
(
KIND_BITS
-
1
)
)
"
Too
many
kind
bits
"
)
;
static_assert
(
TRAIT_BITS
+
KIND_BITS
+
MAGIC_BITS
=
=
16
"
Unused
bits
"
)
;
inline
ICStub
(
Kind
kind
uint8_t
*
stubCode
)
:
stubCode_
(
stubCode
)
{
setTraitKind
(
Regular
kind
)
;
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
ICStub
(
Kind
kind
JitCode
*
stubCode
)
:
ICStub
(
kind
stubCode
-
>
raw
(
)
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
ICStub
(
Kind
kind
Trait
trait
uint8_t
*
stubCode
)
:
stubCode_
(
stubCode
)
{
setTraitKind
(
trait
kind
)
;
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
ICStub
(
Kind
kind
Trait
trait
JitCode
*
stubCode
)
:
ICStub
(
kind
trait
stubCode
-
>
raw
(
)
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
Trait
trait
(
)
const
{
return
(
Trait
)
(
(
traitKindBits_
>
>
TRAIT_OFFSET
)
&
TRAIT_MASK
)
;
}
inline
void
setTraitKind
(
Trait
trait
Kind
kind
)
{
traitKindBits_
=
(
trait
<
<
TRAIT_OFFSET
)
|
(
kind
<
<
KIND_OFFSET
)
|
(
EXPECTED_MAGIC
<
<
MAGIC_OFFSET
)
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
inline
void
checkTraceMagic
(
)
{
uint16_t
magic
=
(
traitKindBits_
>
>
MAGIC_OFFSET
)
&
MAGIC_MASK
;
MOZ_DIAGNOSTIC_ASSERT
(
magic
=
=
EXPECTED_MAGIC
)
;
}
#
endif
public
:
inline
Kind
kind
(
)
const
{
return
(
Kind
)
(
(
traitKindBits_
>
>
KIND_OFFSET
)
&
KIND_MASK
)
;
}
inline
bool
isFallback
(
)
const
{
return
trait
(
)
=
=
Fallback
;
}
inline
const
ICFallbackStub
*
toFallbackStub
(
)
const
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
const
ICFallbackStub
*
>
(
this
)
;
}
inline
ICFallbackStub
*
toFallbackStub
(
)
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
ICFallbackStub
*
>
(
this
)
;
}
#
define
KIND_METHODS
(
kindName
)
\
inline
bool
is
#
#
kindName
(
)
const
{
return
kind
(
)
=
=
kindName
;
}
\
inline
const
IC
#
#
kindName
*
to
#
#
kindName
(
)
const
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
const
IC
#
#
kindName
*
>
(
this
)
;
\
}
\
inline
IC
#
#
kindName
*
to
#
#
kindName
(
)
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
IC
#
#
kindName
*
>
(
this
)
;
\
}
IC_BASELINE_STUB_KIND_LIST
(
KIND_METHODS
)
#
undef
KIND_METHODS
inline
ICStub
*
next
(
)
const
{
return
next_
;
}
inline
bool
hasNext
(
)
const
{
return
next_
!
=
nullptr
;
}
inline
void
setNext
(
ICStub
*
stub
)
{
next_
=
stub
;
}
inline
ICStub
*
*
addressOfNext
(
)
{
return
&
next_
;
}
bool
usesTrampolineCode
(
)
const
{
return
isFallback
(
)
;
}
JitCode
*
jitCode
(
)
{
MOZ_ASSERT
(
!
usesTrampolineCode
(
)
)
;
return
JitCode
:
:
FromExecutable
(
stubCode_
)
;
}
inline
uint8_t
*
rawStubCode
(
)
const
{
return
stubCode_
;
}
inline
ICFallbackStub
*
getChainFallback
(
)
{
ICStub
*
lastStub
=
this
;
while
(
lastStub
-
>
next_
)
{
lastStub
=
lastStub
-
>
next_
;
}
MOZ_ASSERT
(
lastStub
-
>
isFallback
(
)
)
;
return
lastStub
-
>
toFallbackStub
(
)
;
}
inline
ICStubConstIterator
beginHere
(
)
{
return
ICStubConstIterator
:
:
StartingAt
(
this
)
;
}
static
inline
size_t
offsetOfNext
(
)
{
return
offsetof
(
ICStub
next_
)
;
}
static
inline
size_t
offsetOfStubCode
(
)
{
return
offsetof
(
ICStub
stubCode_
)
;
}
static
inline
size_t
offsetOfExtra
(
)
{
return
offsetof
(
ICStub
extra_
)
;
}
static
bool
NonCacheIRStubMakesGCCalls
(
Kind
kind
)
;
bool
makesGCCalls
(
)
const
;
uint32_t
getEnteredCount
(
)
const
;
bool
allocatedInFallbackSpace
(
)
const
{
MOZ_ASSERT
(
next
(
)
)
;
return
makesGCCalls
(
)
;
}
const
CacheIRStubInfo
*
cacheIRStubInfo
(
)
const
;
const
uint8_t
*
cacheIRStubData
(
)
;
}
;
class
ICFallbackStub
:
public
ICStub
{
friend
class
ICStubConstIterator
;
protected
:
ICEntry
*
icEntry_
=
nullptr
;
ICState
state_
{
}
;
uint32_t
enteredCount_
=
0
;
ICFallbackStub
(
Kind
kind
TrampolinePtr
stubCode
)
:
ICStub
(
kind
ICStub
:
:
Fallback
stubCode
.
value
)
{
}
ICFallbackStub
(
Kind
kind
Trait
trait
TrampolinePtr
stubCode
)
:
ICStub
(
kind
trait
stubCode
.
value
)
{
MOZ_ASSERT
(
trait
=
=
ICStub
:
:
Fallback
)
;
}
public
:
inline
ICEntry
*
icEntry
(
)
const
{
return
icEntry_
;
}
inline
size_t
numOptimizedStubs
(
)
const
{
return
state_
.
numOptimizedStubs
(
)
;
}
bool
newStubIsFirstStub
(
)
const
{
return
(
state_
.
mode
(
)
=
=
ICState
:
:
Mode
:
:
Specialized
&
&
numOptimizedStubs
(
)
=
=
0
)
;
}
ICState
&
state
(
)
{
return
state_
;
}
void
fixupICEntry
(
ICEntry
*
icEntry
)
{
MOZ_ASSERT
(
icEntry_
=
=
nullptr
)
;
icEntry_
=
icEntry
;
}
void
addNewStub
(
ICStub
*
stub
)
{
MOZ_ASSERT
(
stub
-
>
next
(
)
=
=
nullptr
)
;
stub
-
>
setNext
(
icEntry_
-
>
firstStub
(
)
)
;
icEntry_
-
>
setFirstStub
(
stub
)
;
state_
.
trackAttached
(
)
;
}
ICStubConstIterator
beginChainConst
(
)
const
{
return
ICStubConstIterator
(
icEntry_
-
>
firstStub
(
)
)
;
}
ICStubIterator
beginChain
(
)
{
return
ICStubIterator
(
this
)
;
}
void
discardStubs
(
JSContext
*
cx
JSScript
*
script
)
;
void
clearUsedByTranspiler
(
)
{
state_
.
clearUsedByTranspiler
(
)
;
}
void
setUsedByTranspiler
(
)
{
state_
.
setUsedByTranspiler
(
)
;
}
TrialInliningState
trialInliningState
(
)
const
{
return
state_
.
trialInliningState
(
)
;
}
void
setTrialInliningState
(
TrialInliningState
state
)
{
state_
.
setTrialInliningState
(
state
)
;
}
void
trackNotAttached
(
JSContext
*
cx
JSScript
*
script
)
;
void
maybeInvalidateWarp
(
JSContext
*
cx
JSScript
*
script
)
;
void
unlinkStubDontInvalidateWarp
(
Zone
*
zone
ICStub
*
prev
ICStub
*
stub
)
;
uint32_t
enteredCount
(
)
const
{
return
enteredCount_
;
}
inline
void
incrementEnteredCount
(
)
{
enteredCount_
+
+
;
}
void
resetEnteredCount
(
)
{
enteredCount_
=
0
;
}
}
;
template
<
typename
Base
>
class
ICCacheIR_Trait
:
public
Base
{
static
constexpr
uint16_t
PreliminaryObjectBit
=
1
<
<
0
;
protected
:
const
CacheIRStubInfo
*
stubInfo_
;
uint32_t
enteredCount_
=
0
;
public
:
template
<
typename
.
.
.
Args
>
explicit
ICCacheIR_Trait
(
const
CacheIRStubInfo
*
stubInfo
Args
&
&
.
.
.
args
)
:
Base
(
args
.
.
.
)
stubInfo_
(
stubInfo
)
{
}
const
CacheIRStubInfo
*
stubInfo
(
)
const
{
return
stubInfo_
;
}
uint8_t
*
stubDataStart
(
)
;
uint32_t
enteredCount
(
)
const
{
return
enteredCount_
;
}
void
resetEnteredCount
(
)
{
enteredCount_
=
0
;
}
void
notePreliminaryObject
(
)
{
this
-
>
extra_
|
=
PreliminaryObjectBit
;
}
bool
hasPreliminaryObject
(
)
const
{
return
(
this
-
>
extra_
&
PreliminaryObjectBit
)
!
=
0
;
}
static
constexpr
size_t
offsetOfEnteredCount
(
)
{
using
T
=
ICCacheIR_Trait
<
Base
>
;
return
offsetof
(
T
enteredCount_
)
;
}
}
;
class
ICCacheIR_Regular
:
public
ICCacheIR_Trait
<
ICStub
>
{
using
Base
=
ICCacheIR_Trait
<
ICStub
>
;
public
:
ICCacheIR_Regular
(
JitCode
*
stubCode
const
CacheIRStubInfo
*
stubInfo
)
:
Base
(
stubInfo
ICStub
:
:
CacheIR_Regular
stubCode
)
{
}
}
;
class
ICStubCompilerBase
{
protected
:
JSContext
*
cx
;
bool
inStubFrame_
=
false
;
#
ifdef
DEBUG
bool
entersStubFrame_
=
false
;
uint32_t
framePushedAtEnterStubFrame_
=
0
;
#
endif
explicit
ICStubCompilerBase
(
JSContext
*
cx
)
:
cx
(
cx
)
{
}
void
pushCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isConstructing
)
;
void
PushStubPayload
(
MacroAssembler
&
masm
Register
scratch
)
;
void
pushStubPayload
(
MacroAssembler
&
masm
Register
scratch
)
;
MOZ_MUST_USE
bool
tailCallVMInternal
(
MacroAssembler
&
masm
TailCallVMFunctionId
id
)
;
template
<
typename
Fn
Fn
fn
>
MOZ_MUST_USE
bool
tailCallVM
(
MacroAssembler
&
masm
)
;
MOZ_MUST_USE
bool
callVMInternal
(
MacroAssembler
&
masm
VMFunctionId
id
)
;
template
<
typename
Fn
Fn
fn
>
MOZ_MUST_USE
bool
callVM
(
MacroAssembler
&
masm
)
;
void
enterStubFrame
(
MacroAssembler
&
masm
Register
scratch
)
;
void
assumeStubFrame
(
)
;
void
leaveStubFrame
(
MacroAssembler
&
masm
bool
calledIntoIon
=
false
)
;
public
:
static
inline
AllocatableGeneralRegisterSet
availableGeneralRegs
(
size_t
numInputs
)
{
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
regs
.
take
(
BaselineSecondScratchReg
)
;
#
elif
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
BaselineSecondScratchReg
)
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
MOZ_ASSERT
(
!
regs
.
has
(
PseudoStackPointer
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
RealStackPointer
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
#
else
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
#
endif
regs
.
take
(
BaselineFrameReg
)
;
regs
.
take
(
ICStubReg
)
;
#
ifdef
JS_CODEGEN_X64
regs
.
take
(
ExtractTemp0
)
;
regs
.
take
(
ExtractTemp1
)
;
#
endif
switch
(
numInputs
)
{
case
0
:
break
;
case
1
:
regs
.
take
(
R0
)
;
break
;
case
2
:
regs
.
take
(
R0
)
;
regs
.
take
(
R1
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
numInputs
"
)
;
}
return
regs
;
}
}
;
class
ICStubCompiler
:
public
ICStubCompilerBase
{
js
:
:
gc
:
:
AutoSuppressGC
suppressGC
;
protected
:
ICStub
:
:
Kind
kind
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
kind
)
;
}
virtual
MOZ_MUST_USE
bool
generateStubCode
(
MacroAssembler
&
masm
)
=
0
;
ICStubCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
)
:
ICStubCompilerBase
(
cx
)
suppressGC
(
cx
)
kind
(
kind
)
{
}
protected
:
template
<
typename
T
typename
.
.
.
Args
>
T
*
newStub
(
Args
&
&
.
.
.
args
)
{
return
ICStub
:
:
New
<
T
>
(
cx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
public
:
virtual
ICStub
*
getStub
(
ICStubSpace
*
space
)
=
0
;
static
ICStubSpace
*
StubSpaceForStub
(
bool
makesGCCalls
JSScript
*
script
ICScript
*
icScript
)
;
}
;
class
ICToBool_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICToBool_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
ToBool_Fallback
stubCode
)
{
}
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
}
;
class
ICGetElem_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetElem_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
GetElem_Fallback
stubCode
)
{
}
static
const
uint16_t
EXTRA_NEGATIVE_INDEX
=
0x1
;
static
const
uint16_t
SAW_NON_INTEGER_INDEX_BIT
=
0x2
;
public
:
void
noteNegativeIndex
(
)
{
extra_
|
=
EXTRA_NEGATIVE_INDEX
;
}
bool
hasNegativeIndex
(
)
const
{
return
extra_
&
EXTRA_NEGATIVE_INDEX
;
}
void
setSawNonIntegerIndex
(
)
{
extra_
|
=
SAW_NON_INTEGER_INDEX_BIT
;
}
bool
sawNonIntegerIndex
(
)
const
{
return
extra_
&
SAW_NON_INTEGER_INDEX_BIT
;
}
}
;
class
ICSetElem_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICSetElem_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
SetElem_Fallback
stubCode
)
{
}
static
const
size_t
HasDenseAddFlag
=
0x1
;
static
const
size_t
HasTypedArrayOOBFlag
=
0x2
;
public
:
void
noteHasDenseAdd
(
)
{
extra_
|
=
HasDenseAddFlag
;
}
bool
hasDenseAdd
(
)
const
{
return
extra_
&
HasDenseAddFlag
;
}
void
noteHasTypedArrayOOB
(
)
{
extra_
|
=
HasTypedArrayOOBFlag
;
}
bool
hasTypedArrayOOB
(
)
const
{
return
extra_
&
HasTypedArrayOOBFlag
;
}
}
;
class
ICIn_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICIn_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
In_Fallback
stubCode
)
{
}
}
;
class
ICHasOwn_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICHasOwn_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
HasOwn_Fallback
stubCode
)
{
}
}
;
class
ICCheckPrivateField_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICCheckPrivateField_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
CheckPrivateField_Fallback
stubCode
)
{
}
}
;
class
ICGetName_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetName_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
GetName_Fallback
stubCode
)
{
}
}
;
class
ICBindName_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICBindName_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
BindName_Fallback
stubCode
)
{
}
}
;
class
ICGetIntrinsic_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetIntrinsic_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
GetIntrinsic_Fallback
stubCode
)
{
}
}
;
class
ICGetProp_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetProp_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
GetProp_Fallback
stubCode
)
{
}
public
:
static
const
size_t
ACCESSED_GETTER_BIT
=
1
;
void
noteAccessedGetter
(
)
{
extra_
|
=
(
1u
<
<
ACCESSED_GETTER_BIT
)
;
}
bool
hasAccessedGetter
(
)
const
{
return
extra_
&
(
1u
<
<
ACCESSED_GETTER_BIT
)
;
}
}
;
class
ICSetProp_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICSetProp_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
SetProp_Fallback
stubCode
)
{
}
}
;
class
ICCall_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
16
;
private
:
explicit
ICCall_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
Call_Fallback
stubCode
)
{
}
}
;
class
ICGetIterator_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetIterator_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
GetIterator_Fallback
stubCode
)
{
}
}
;
class
ICOptimizeSpreadCall_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICOptimizeSpreadCall_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
OptimizeSpreadCall_Fallback
stubCode
)
{
}
}
;
class
ICInstanceOf_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICInstanceOf_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
InstanceOf_Fallback
stubCode
)
{
}
}
;
class
ICTypeOf_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICTypeOf_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
TypeOf_Fallback
stubCode
)
{
}
}
;
class
ICToPropertyKey_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICToPropertyKey_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
ToPropertyKey_Fallback
stubCode
)
{
}
}
;
class
ICRest_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
GCPtrArrayObject
templateObject_
;
ICRest_Fallback
(
TrampolinePtr
stubCode
ArrayObject
*
templateObject
)
:
ICFallbackStub
(
ICStub
:
:
Rest_Fallback
stubCode
)
templateObject_
(
templateObject
)
{
}
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
GCPtrArrayObject
&
templateObject
(
)
{
return
templateObject_
;
}
}
;
class
ICUnaryArith_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICUnaryArith_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
UnaryArith_Fallback
stubCode
)
{
}
public
:
bool
sawDoubleResult
(
)
{
return
extra_
;
}
void
setSawDoubleResult
(
)
{
extra_
=
1
;
}
}
;
class
ICCompare_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
Compare_Fallback
stubCode
)
{
}
}
;
class
ICBinaryArith_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICBinaryArith_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
BinaryArith_Fallback
stubCode
)
{
}
static
const
uint16_t
SAW_DOUBLE_RESULT_BIT
=
0x1
;
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
bool
sawDoubleResult
(
)
const
{
return
extra_
&
SAW_DOUBLE_RESULT_BIT
;
}
void
setSawDoubleResult
(
)
{
extra_
|
=
SAW_DOUBLE_RESULT_BIT
;
}
}
;
class
ICNewArray_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
GCPtrArrayObject
templateObject_
;
GCPtrObjectGroup
templateGroup_
;
ICNewArray_Fallback
(
TrampolinePtr
stubCode
ObjectGroup
*
templateGroup
)
:
ICFallbackStub
(
ICStub
:
:
NewArray_Fallback
stubCode
)
templateObject_
(
nullptr
)
templateGroup_
(
templateGroup
)
{
}
public
:
GCPtrArrayObject
&
templateObject
(
)
{
return
templateObject_
;
}
void
setTemplateObject
(
ArrayObject
*
obj
)
{
MOZ_ASSERT
(
obj
-
>
group
(
)
=
=
templateGroup
(
)
)
;
templateObject_
=
obj
;
}
GCPtrObjectGroup
&
templateGroup
(
)
{
return
templateGroup_
;
}
void
setTemplateGroup
(
ObjectGroup
*
group
)
{
templateObject_
=
nullptr
;
templateGroup_
=
group
;
}
}
;
class
ICNewObject_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
GCPtrObject
templateObject_
;
explicit
ICNewObject_Fallback
(
TrampolinePtr
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
NewObject_Fallback
stubCode
)
templateObject_
(
nullptr
)
{
}
public
:
GCPtrObject
&
templateObject
(
)
{
return
templateObject_
;
}
void
setTemplateObject
(
JSObject
*
obj
)
{
templateObject_
=
obj
;
}
}
;
struct
IonOsrTempData
;
extern
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
;
extern
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub
Value
*
vp
MutableHandleValue
res
)
;
extern
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToBool_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
;
extern
bool
DoGetElemSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
HandleValue
receiver
MutableHandleValue
res
)
;
extern
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
;
extern
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetElem_Fallback
*
stub
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
;
extern
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIn_Fallback
*
stub
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
;
extern
bool
DoHasOwnFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICHasOwn_Fallback
*
stub
HandleValue
keyValue
HandleValue
objValue
MutableHandleValue
res
)
;
extern
bool
DoCheckPrivateFieldFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCheckPrivateField_Fallback
*
stub
HandleValue
objValue
HandleValue
keyValue
MutableHandleValue
res
)
;
extern
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
;
extern
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBindName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
;
extern
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIntrinsic_Fallback
*
stub
MutableHandleValue
res
)
;
extern
bool
DoGetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetProp_Fallback
*
stub
MutableHandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoGetPropSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetProp_Fallback
*
stub
HandleValue
receiver
MutableHandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetProp_Fallback
*
stub
Value
*
stack
HandleValue
lhs
HandleValue
rhs
)
;
extern
bool
DoGetIteratorFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIterator_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
;
extern
bool
DoOptimizeSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICOptimizeSpreadCall_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
;
extern
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
;
extern
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeOf_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoToPropertyKeyFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToPropertyKey_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRest_Fallback
*
stub
MutableHandleValue
res
)
;
extern
bool
DoUnaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICUnaryArith_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoBinaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBinaryArith_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
;
extern
bool
DoNewArrayFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewArray_Fallback
*
stub
uint32_t
length
MutableHandleValue
res
)
;
extern
bool
DoNewObjectFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewObject_Fallback
*
stub
MutableHandleValue
res
)
;
extern
bool
DoCompareFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCompare_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
;
}
}
#
endif
