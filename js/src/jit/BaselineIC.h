#
ifndef
jit_BaselineIC_h
#
define
jit_BaselineIC_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jit
/
ICState
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
jit
/
TypeData
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JS_PUBLIC_API
JSTracer
;
enum
class
JSOp
:
uint8_t
;
namespace
js
{
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
namespace
jit
{
class
BaselineFrame
;
class
CacheIRStubInfo
;
class
ICScript
;
enum
class
TailCallVMFunctionId
;
enum
class
VMFunctionId
;
class
ICStub
;
class
ICCacheIRStub
;
class
ICFallbackStub
;
#
ifdef
JS_JITSPEW
void
FallbackICSpew
(
JSContext
*
cx
ICFallbackStub
*
stub
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
3
4
)
;
#
else
#
define
FallbackICSpew
(
.
.
.
)
#
endif
class
ICEntry
{
ICStub
*
firstStub_
;
public
:
explicit
ICEntry
(
ICStub
*
firstStub
)
:
firstStub_
(
firstStub
)
{
}
ICStub
*
firstStub
(
)
const
{
MOZ_ASSERT
(
firstStub_
)
;
return
firstStub_
;
}
void
setFirstStub
(
ICStub
*
stub
)
{
firstStub_
=
stub
;
}
static
constexpr
size_t
offsetOfFirstStub
(
)
{
return
offsetof
(
ICEntry
firstStub_
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ICStub
{
friend
class
ICFallbackStub
;
protected
:
uint8_t
*
stubCode_
;
uint32_t
enteredCount_
=
0
;
TypeData
typeData_
;
bool
isFallback_
;
ICStub
(
uint8_t
*
stubCode
bool
isFallback
)
:
stubCode_
(
stubCode
)
isFallback_
(
isFallback
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
public
:
inline
bool
isFallback
(
)
const
{
return
isFallback_
;
}
inline
ICStub
*
maybeNext
(
)
const
;
inline
const
ICFallbackStub
*
toFallbackStub
(
)
const
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
const
ICFallbackStub
*
>
(
this
)
;
}
inline
ICFallbackStub
*
toFallbackStub
(
)
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
ICFallbackStub
*
>
(
this
)
;
}
ICCacheIRStub
*
toCacheIRStub
(
)
{
MOZ_ASSERT
(
!
isFallback
(
)
)
;
return
reinterpret_cast
<
ICCacheIRStub
*
>
(
this
)
;
}
const
ICCacheIRStub
*
toCacheIRStub
(
)
const
{
MOZ_ASSERT
(
!
isFallback
(
)
)
;
return
reinterpret_cast
<
const
ICCacheIRStub
*
>
(
this
)
;
}
bool
usesTrampolineCode
(
)
const
{
return
isFallback
(
)
;
}
JitCode
*
jitCode
(
)
{
MOZ_ASSERT
(
!
usesTrampolineCode
(
)
)
;
return
JitCode
:
:
FromExecutable
(
stubCode_
)
;
}
uint32_t
enteredCount
(
)
const
{
return
enteredCount_
;
}
inline
void
incrementEnteredCount
(
)
{
enteredCount_
+
+
;
}
void
resetEnteredCount
(
)
{
enteredCount_
=
0
;
}
static
constexpr
size_t
offsetOfStubCode
(
)
{
return
offsetof
(
ICStub
stubCode_
)
;
}
static
constexpr
size_t
offsetOfEnteredCount
(
)
{
return
offsetof
(
ICStub
enteredCount_
)
;
}
}
;
class
ICFallbackStub
final
:
public
ICStub
{
friend
class
ICStubConstIterator
;
protected
:
uint32_t
pcOffset_
;
ICState
state_
{
}
;
public
:
explicit
ICFallbackStub
(
uint32_t
pcOffset
TrampolinePtr
stubCode
)
:
ICStub
(
stubCode
.
value
true
)
pcOffset_
(
pcOffset
)
{
}
inline
size_t
numOptimizedStubs
(
)
const
{
return
state_
.
numOptimizedStubs
(
)
;
}
bool
newStubIsFirstStub
(
)
const
{
return
state_
.
newStubIsFirstStub
(
)
;
}
ICState
&
state
(
)
{
return
state_
;
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
inline
void
addNewStub
(
ICEntry
*
icEntry
ICCacheIRStub
*
stub
)
;
void
discardStubs
(
JSContext
*
cx
ICEntry
*
icEntry
)
;
void
clearUsedByTranspiler
(
)
{
state_
.
clearUsedByTranspiler
(
)
;
}
void
setUsedByTranspiler
(
)
{
state_
.
setUsedByTranspiler
(
)
;
}
void
clearHasFoldedStub
(
)
{
state_
.
clearHasFoldedStub
(
)
;
}
void
setHasFoldedStub
(
)
{
state_
.
setHasFoldedStub
(
)
;
}
bool
hasFoldedStub
(
)
const
{
return
state_
.
hasFoldedStub
(
)
;
}
TrialInliningState
trialInliningState
(
)
const
{
return
state_
.
trialInliningState
(
)
;
}
void
setTrialInliningState
(
TrialInliningState
state
)
{
state_
.
setTrialInliningState
(
state
)
;
}
void
trackNotAttached
(
)
;
void
unlinkStub
(
Zone
*
zone
ICEntry
*
icEntry
ICCacheIRStub
*
prev
ICCacheIRStub
*
stub
)
;
}
;
class
ICCacheIRStub
final
:
public
ICStub
{
ICStub
*
next_
=
nullptr
;
const
CacheIRStubInfo
*
stubInfo_
;
#
ifndef
JS_64BIT
uintptr_t
padding_
=
0
;
#
endif
public
:
ICCacheIRStub
(
JitCode
*
stubCode
const
CacheIRStubInfo
*
stubInfo
)
:
ICStub
(
stubCode
-
>
raw
(
)
false
)
stubInfo_
(
stubInfo
)
{
}
ICStub
*
next
(
)
const
{
return
next_
;
}
void
setNext
(
ICStub
*
stub
)
{
next_
=
stub
;
}
ICCacheIRStub
*
nextCacheIR
(
)
const
{
return
next_
-
>
isFallback
(
)
?
nullptr
:
next_
-
>
toCacheIRStub
(
)
;
}
const
CacheIRStubInfo
*
stubInfo
(
)
const
{
return
stubInfo_
;
}
uint8_t
*
stubDataStart
(
)
;
void
trace
(
JSTracer
*
trc
)
;
bool
makesGCCalls
(
)
const
;
bool
allocatedInFallbackSpace
(
)
const
{
return
makesGCCalls
(
)
;
}
static
constexpr
size_t
offsetOfNext
(
)
{
return
offsetof
(
ICCacheIRStub
next_
)
;
}
void
setTypeData
(
TypeData
data
)
{
typeData_
=
data
;
}
TypeData
typeData
(
)
const
{
return
typeData_
;
}
}
;
#
ifdef
JS_64BIT
static_assert
(
sizeof
(
ICFallbackStub
)
=
=
3
*
sizeof
(
uintptr_t
)
)
;
static_assert
(
sizeof
(
ICCacheIRStub
)
=
=
4
*
sizeof
(
uintptr_t
)
)
;
#
else
static_assert
(
sizeof
(
ICFallbackStub
)
=
=
5
*
sizeof
(
uintptr_t
)
)
;
static_assert
(
sizeof
(
ICCacheIRStub
)
=
=
6
*
sizeof
(
uintptr_t
)
)
;
#
endif
inline
ICStub
*
ICStub
:
:
maybeNext
(
)
const
{
return
isFallback
(
)
?
nullptr
:
toCacheIRStub
(
)
-
>
next
(
)
;
}
inline
void
ICFallbackStub
:
:
addNewStub
(
ICEntry
*
icEntry
ICCacheIRStub
*
stub
)
{
MOZ_ASSERT
(
stub
-
>
next
(
)
=
=
nullptr
)
;
stub
-
>
setNext
(
icEntry
-
>
firstStub
(
)
)
;
icEntry
-
>
setFirstStub
(
stub
)
;
state_
.
trackAttached
(
)
;
}
AllocatableGeneralRegisterSet
BaselineICAvailableGeneralRegs
(
size_t
numInputs
)
;
bool
ICSupportsPolymorphicTypeData
(
JSOp
op
)
;
struct
IonOsrTempData
;
extern
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
;
extern
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
Value
*
vp
MutableHandleValue
res
)
;
extern
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
arg
MutableHandleValue
ret
)
;
extern
bool
DoGetElemSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
lhs
HandleValue
rhs
HandleValue
receiver
MutableHandleValue
res
)
;
extern
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
;
extern
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
;
extern
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
;
extern
bool
DoHasOwnFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
keyValue
HandleValue
objValue
MutableHandleValue
res
)
;
extern
bool
DoCheckPrivateFieldFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
objValue
HandleValue
keyValue
MutableHandleValue
res
)
;
extern
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleObject
envChain
MutableHandleValue
res
)
;
extern
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleObject
envChain
MutableHandleValue
res
)
;
extern
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
MutableHandleValue
res
)
;
extern
bool
DoGetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
MutableHandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoGetPropSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
receiver
MutableHandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
Value
*
stack
HandleValue
lhs
HandleValue
rhs
)
;
extern
bool
DoGetIteratorFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
value
MutableHandleValue
res
)
;
extern
bool
DoOptimizeSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
value
MutableHandleValue
res
)
;
extern
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
;
extern
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoToPropertyKeyFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
MutableHandleValue
res
)
;
extern
bool
DoUnaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
val
MutableHandleValue
res
)
;
extern
bool
DoBinaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
;
extern
bool
DoNewArrayFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
MutableHandleValue
res
)
;
extern
bool
DoNewObjectFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
MutableHandleValue
res
)
;
extern
bool
DoCompareFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
;
extern
bool
DoCloseIterFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
HandleObject
iter
)
;
}
}
#
endif
