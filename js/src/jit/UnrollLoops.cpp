#
include
"
jit
/
UnrollLoops
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdio
.
h
>
#
include
"
jit
/
DominatorTree
.
h
"
#
include
"
jit
/
IonAnalysis
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
namespace
js
{
namespace
jit
{
const
float
InitialCandidateThreshold
=
100
.
0
;
const
size_t
MaxBlocksForPeel
=
12
;
const
size_t
MaxValuesForPeel
=
150
;
const
size_t
MaxBlocksForUnroll
=
10
;
const
size_t
MaxValuesForUnroll
=
100
;
using
BlockVector
=
mozilla
:
:
Vector
<
MBasicBlock
*
32
SystemAllocPolicy
>
;
static
bool
BlockVectorContains
(
const
BlockVector
&
vec
const
MBasicBlock
*
block
)
{
for
(
const
MBasicBlock
*
b
:
vec
)
{
if
(
b
=
=
block
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
T
int
N
typename
AP
>
class
Matrix
{
static_assert
(
std
:
:
is_pointer
<
T
>
:
:
value
)
;
mozilla
:
:
Vector
<
T
N
AP
>
vec_
;
size_t
size1_
=
0
;
size_t
size2_
=
0
;
inline
size_t
index
(
size_t
ix1
size_t
ix2
)
const
{
MOZ_ASSERT
(
ix1
<
size1_
&
&
ix2
<
size2_
)
;
return
ix1
*
size2_
+
ix2
;
}
public
:
[
[
nodiscard
]
]
bool
init
(
size_t
size1
size_t
size2
)
{
MOZ_ASSERT
(
size1_
=
=
0
&
&
size2_
=
=
0
&
&
vec_
.
empty
(
)
)
;
MOZ_ASSERT
(
size1
>
0
&
&
size2
>
0
)
;
MOZ_RELEASE_ASSERT
(
size1
<
=
1000
&
&
size2
<
=
1000
)
;
size1_
=
size1
;
size2_
=
size2
;
if
(
!
vec_
.
resize
(
size1
*
size2
)
)
{
return
false
;
}
return
true
;
}
inline
size_t
size1
(
)
const
{
MOZ_ASSERT
(
size1_
*
size2_
=
=
vec_
.
length
(
)
)
;
return
size1_
;
}
inline
size_t
size2
(
)
const
{
MOZ_ASSERT
(
size1_
*
size2_
=
=
vec_
.
length
(
)
)
;
return
size2_
;
}
inline
T
get
(
size_t
ix1
size_t
ix2
)
const
{
return
vec_
[
index
(
ix1
ix2
)
]
;
}
inline
void
set
(
size_t
ix1
size_t
ix2
T
value
)
{
vec_
[
index
(
ix1
ix2
)
]
=
value
;
}
inline
bool
rowContains
(
size_t
ix1
const
T
value
)
const
{
return
findInRow
(
ix1
value
)
.
isSome
(
)
;
}
mozilla
:
:
Maybe
<
size_t
>
findInRow
(
size_t
ix1
const
T
value
)
const
{
for
(
size_t
ix2
=
0
;
ix2
<
size2_
;
ix2
+
+
)
{
if
(
get
(
ix1
ix2
)
=
=
value
)
{
return
mozilla
:
:
Some
(
ix2
)
;
}
}
return
mozilla
:
:
Nothing
(
)
;
}
}
;
using
BlockTable
=
Matrix
<
MBasicBlock
*
32
SystemAllocPolicy
>
;
using
ValueTable
=
Matrix
<
MDefinition
*
128
SystemAllocPolicy
>
;
#
ifdef
JS_JITSPEW
static
void
DumpBlockTableRows
(
const
BlockTable
&
table
int32_t
firstCix
int32_t
lastCix
const
char
*
tag
)
{
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
%
s
\
n
"
tag
)
;
for
(
int32_t
cix
=
firstCix
;
cix
<
=
lastCix
;
cix
+
+
)
{
if
(
cix
=
=
0
)
{
printer
.
printf
(
"
-
-
-
-
-
-
-
-
Original
-
-
-
-
-
-
-
-
\
n
"
)
;
}
else
{
printer
.
printf
(
"
-
-
-
-
-
-
-
-
Copy
%
u
-
-
-
-
-
-
-
-
\
n
"
cix
)
;
}
for
(
uint32_t
bix
=
0
;
bix
<
table
.
size2
(
)
;
bix
+
+
)
{
DumpMIRBlock
(
printer
table
.
get
(
uint32_t
(
cix
)
bix
)
true
)
;
}
}
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
static
void
DumpBlockTable
(
const
BlockTable
&
table
const
char
*
tag
)
{
DumpBlockTableRows
(
table
0
int32_t
(
table
.
size1
(
)
)
-
1
tag
)
;
}
static
void
DumpBlockTableRowZero
(
const
BlockTable
&
table
const
char
*
tag
)
{
DumpBlockTableRows
(
table
0
0
tag
)
;
}
static
void
DumpValueTable
(
const
ValueTable
&
table
const
char
*
tag
)
{
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
%
s
\
n
"
tag
)
;
for
(
uint32_t
cix
=
0
;
cix
<
table
.
size1
(
)
;
cix
+
+
)
{
if
(
cix
=
=
0
)
{
printer
.
printf
(
"
-
-
-
-
-
-
-
-
Original
-
-
-
-
-
-
-
-
\
n
"
)
;
}
else
{
printer
.
printf
(
"
-
-
-
-
-
-
-
-
Copy
%
u
-
-
-
-
-
-
-
-
\
n
"
cix
)
;
}
for
(
uint32_t
vix
=
0
;
vix
<
table
.
size2
(
)
;
vix
+
+
)
{
printer
.
printf
(
"
"
)
;
DumpMIRDefinition
(
printer
table
.
get
(
cix
vix
)
true
)
;
printer
.
printf
(
"
\
n
"
)
;
}
}
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
#
endif
template
<
typename
T
int
N
typename
AP
>
class
SimpleSet
{
static_assert
(
std
:
:
is_pointer
<
T
>
:
:
value
)
;
mozilla
:
:
Vector
<
T
N
AP
>
vec_
;
public
:
[
[
nodiscard
]
]
bool
copy
(
const
SimpleSet
<
T
N
AP
>
&
other
)
{
vec_
.
clear
(
)
;
for
(
T
elem
:
other
.
vec_
)
{
if
(
!
vec_
.
append
(
elem
)
)
{
return
false
;
}
}
return
true
;
}
bool
contains
(
T
t
)
const
{
for
(
auto
*
existing
:
vec_
)
{
if
(
existing
=
=
t
)
{
return
true
;
}
}
return
false
;
}
[
[
nodiscard
]
]
bool
add
(
T
t
)
{
MOZ_ASSERT
(
t
)
;
return
contains
(
t
)
?
true
:
vec_
.
append
(
t
)
;
}
bool
empty
(
)
const
{
return
vec_
.
empty
(
)
;
}
size_t
size
(
)
const
{
return
vec_
.
length
(
)
;
}
T
get
(
size_t
ix
)
const
{
return
vec_
[
ix
]
;
}
}
;
using
BlockSet
=
SimpleSet
<
MBasicBlock
*
8
SystemAllocPolicy
>
;
using
ValueSet
=
SimpleSet
<
MDefinition
*
64
SystemAllocPolicy
>
;
class
MDefinitionRemapper
{
using
Pair
=
std
:
:
pair
<
MDefinition
*
MDefinition
*
>
;
mozilla
:
:
Vector
<
Pair
32
SystemAllocPolicy
>
pairs
;
public
:
MDefinitionRemapper
(
)
{
}
[
[
nodiscard
]
]
bool
enregister
(
MDefinition
*
original
)
{
MOZ_ASSERT
(
original
)
;
for
(
auto
&
p
:
pairs
)
{
(
void
)
p
;
MOZ_ASSERT
(
p
.
first
!
=
original
)
;
MOZ_ASSERT
(
p
.
second
=
=
p
.
first
)
;
}
return
pairs
.
append
(
std
:
:
pair
(
original
original
)
)
;
}
MDefinition
*
lookup
(
const
MDefinition
*
original
)
const
{
MOZ_ASSERT
(
original
)
;
MDefinition
*
res
=
nullptr
;
for
(
auto
&
p
:
pairs
)
{
if
(
p
.
first
=
=
original
)
{
res
=
p
.
second
;
break
;
}
}
return
res
;
}
void
update
(
const
MDefinition
*
original
MDefinition
*
replacement
)
{
MOZ_ASSERT
(
original
&
&
replacement
)
;
MOZ_ASSERT
(
original
!
=
replacement
)
;
for
(
auto
&
p
:
pairs
)
{
if
(
p
.
first
=
=
original
)
{
p
.
second
=
replacement
;
return
;
}
}
MOZ_CRASH
(
)
;
}
}
;
static
MInstruction
*
MakeReplacementInstruction
(
TempAllocator
&
alloc
const
MDefinitionRemapper
&
mapper
const
MInstruction
*
ins
)
{
MDefinitionVector
inputs
(
alloc
)
;
for
(
size_t
i
=
0
;
i
<
ins
-
>
numOperands
(
)
;
i
+
+
)
{
MDefinition
*
old
=
ins
-
>
getOperand
(
i
)
;
MDefinition
*
replacement
=
mapper
.
lookup
(
old
)
;
if
(
!
replacement
)
{
replacement
=
old
;
}
if
(
!
inputs
.
append
(
replacement
)
)
{
return
nullptr
;
}
}
return
ins
-
>
clone
(
alloc
inputs
)
;
}
static
MPhi
*
MakeReplacementPhi
(
TempAllocator
&
alloc
const
MDefinitionRemapper
&
mapper
const
MPhi
*
phi
)
{
MDefinitionVector
inputs
(
alloc
)
;
for
(
size_t
i
=
0
;
i
<
phi
-
>
numOperands
(
)
;
i
+
+
)
{
MDefinition
*
old
=
phi
-
>
getOperand
(
i
)
;
MDefinition
*
replacement
=
mapper
.
lookup
(
old
)
;
if
(
!
replacement
)
{
replacement
=
old
;
}
if
(
!
inputs
.
append
(
replacement
)
)
{
return
nullptr
;
}
}
return
phi
-
>
clone
(
alloc
inputs
)
;
}
enum
class
UnrollMode
{
Peel
Unroll
PeelAndUnroll
}
;
struct
UnrollState
{
const
UnrollMode
mode
;
BlockTable
blockTable
;
BlockSet
exitTargetBlocks
;
ValueSet
exitingValues
;
explicit
UnrollState
(
UnrollMode
mode
)
:
mode
(
mode
)
{
}
bool
doPeeling
(
)
const
{
return
mode
=
=
UnrollMode
:
:
Peel
|
|
mode
=
=
UnrollMode
:
:
PeelAndUnroll
;
}
bool
doUnrolling
(
)
const
{
return
mode
=
=
UnrollMode
:
:
Unroll
|
|
mode
=
=
UnrollMode
:
:
PeelAndUnroll
;
}
}
;
enum
class
AnalysisResult
{
OOM
Peel
Unroll
PeelAndUnroll
BadInvariants
TooComplex
Uncloneable
TooLarge
Unsuitable
}
;
#
ifdef
JS_JITSPEW
static
const
char
*
Name_of_AnalysisResult
(
AnalysisResult
res
)
{
switch
(
res
)
{
case
AnalysisResult
:
:
OOM
:
return
"
OOM
"
;
case
AnalysisResult
:
:
Peel
:
return
"
Peel
"
;
case
AnalysisResult
:
:
Unroll
:
return
"
Unroll
"
;
case
AnalysisResult
:
:
PeelAndUnroll
:
return
"
PeelAndUnroll
"
;
case
AnalysisResult
:
:
BadInvariants
:
return
"
BadInvariants
"
;
case
AnalysisResult
:
:
TooComplex
:
return
"
TooComplex
"
;
case
AnalysisResult
:
:
Uncloneable
:
return
"
Uncloneable
"
;
case
AnalysisResult
:
:
TooLarge
:
return
"
TooLarge
"
;
case
AnalysisResult
:
:
Unsuitable
:
return
"
Unsuitable
"
;
default
:
MOZ_CRASH
(
)
;
}
}
#
endif
static
AnalysisResult
AnalyzeLoop
(
const
BlockVector
&
originalBlocks
BlockSet
*
exitTargetBlocks
ValueSet
*
exitingValues
)
{
MOZ_ASSERT
(
exitTargetBlocks
-
>
empty
(
)
)
;
MOZ_ASSERT
(
exitingValues
-
>
empty
(
)
)
;
const
size_t
numBlocksInOriginal
=
originalBlocks
.
length
(
)
;
if
(
numBlocksInOriginal
<
2
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
{
MBasicBlock
*
header
=
originalBlocks
[
0
]
;
if
(
!
header
-
>
isLoopHeader
(
)
|
|
header
-
>
backedge
(
)
!
=
originalBlocks
[
numBlocksInOriginal
-
1
]
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
originalBlocks
[
bix
]
;
size_t
numInsns
=
0
;
for
(
MInstructionIterator
insnIter
(
block
-
>
begin
(
)
)
;
insnIter
!
=
block
-
>
end
(
)
;
insnIter
+
+
)
{
numInsns
+
+
;
}
if
(
numInsns
<
1
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
bool
ok
=
true
;
size_t
curInsn
=
0
;
for
(
MInstructionIterator
insnIter
(
block
-
>
begin
(
)
)
;
insnIter
!
=
block
-
>
end
(
)
;
insnIter
+
+
)
{
MInstruction
*
insn
=
*
insnIter
;
if
(
curInsn
=
=
numInsns
-
1
)
{
ok
=
ok
&
&
insn
-
>
isControlInstruction
(
)
;
}
else
{
ok
=
ok
&
&
!
insn
-
>
isControlInstruction
(
)
;
}
curInsn
+
+
;
}
MOZ_ASSERT
(
curInsn
=
=
numInsns
)
;
ok
=
ok
&
&
block
-
>
loopDepth
(
)
>
0
;
if
(
!
ok
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
{
MBasicBlock
*
header
=
originalBlocks
[
0
]
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
-
1
;
bix
+
+
)
{
MBasicBlock
*
block
=
originalBlocks
[
bix
]
;
if
(
!
block
-
>
hasLastIns
(
)
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
MControlInstruction
*
lastIns
=
block
-
>
lastIns
(
)
;
for
(
size_t
i
=
0
;
i
<
lastIns
-
>
numSuccessors
(
)
;
i
+
+
)
{
if
(
lastIns
-
>
getSuccessor
(
i
)
=
=
header
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
}
}
{
MBasicBlock
*
header
=
originalBlocks
[
0
]
;
MBasicBlock
*
backedge
=
originalBlocks
[
numBlocksInOriginal
-
1
]
;
if
(
!
backedge
-
>
hasLastIns
(
)
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
MControlInstruction
*
lastIns
=
backedge
-
>
lastIns
(
)
;
if
(
!
lastIns
-
>
isGoto
(
)
|
|
lastIns
-
>
toGoto
(
)
-
>
target
(
)
!
=
header
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
{
MBasicBlock
*
header
=
originalBlocks
[
0
]
;
if
(
header
-
>
numPredecessors
(
)
!
=
2
|
|
BlockVectorContains
(
originalBlocks
header
-
>
getPredecessor
(
0
)
)
|
|
!
BlockVectorContains
(
originalBlocks
header
-
>
getPredecessor
(
1
)
)
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
{
MBasicBlock
*
header
=
originalBlocks
[
0
]
;
for
(
MPhiIterator
phiIter
(
header
-
>
phisBegin
(
)
)
;
phiIter
!
=
header
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
MPhi
*
phi
=
*
phiIter
;
if
(
phi
-
>
numOperands
(
)
!
=
2
|
|
BlockVectorContains
(
originalBlocks
phi
-
>
getOperand
(
0
)
-
>
block
(
)
)
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
}
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
originalBlocks
[
bix
]
;
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
insIter
+
+
)
{
MInstruction
*
ins
=
*
insIter
;
if
(
ins
-
>
isWasmCallCatchable
(
)
|
|
ins
-
>
isWasmCallUncatchable
(
)
|
|
ins
-
>
isWasmReturnCall
(
)
|
|
ins
-
>
isTableSwitch
(
)
)
{
return
AnalysisResult
:
:
Unsuitable
;
}
if
(
!
ins
-
>
canClone
(
)
)
{
return
AnalysisResult
:
:
Uncloneable
;
}
}
}
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
originalBlocks
[
bix
]
;
MControlInstruction
*
lastIns
=
block
-
>
lastIns
(
)
;
for
(
size_t
i
=
0
;
i
<
lastIns
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
succ
=
lastIns
-
>
getSuccessor
(
i
)
;
if
(
!
BlockVectorContains
(
originalBlocks
succ
)
)
{
if
(
!
exitTargetBlocks
-
>
add
(
succ
)
)
{
return
AnalysisResult
:
:
OOM
;
}
}
}
}
if
(
exitTargetBlocks
-
>
empty
(
)
)
{
return
AnalysisResult
:
:
Unsuitable
;
}
size_t
numValuesInOriginal
=
0
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
originalBlocks
[
bix
]
;
for
(
MPhiIterator
phiIter
(
block
-
>
phisBegin
(
)
)
;
phiIter
!
=
block
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
numValuesInOriginal
+
+
;
MPhi
*
phi
=
*
phiIter
;
bool
usedAfterLoop
=
false
;
for
(
MUseIterator
useIter
(
phi
-
>
usesBegin
(
)
)
;
useIter
!
=
phi
-
>
usesEnd
(
)
;
useIter
+
+
)
{
MUse
*
use
=
*
useIter
;
if
(
!
BlockVectorContains
(
originalBlocks
use
-
>
consumer
(
)
-
>
block
(
)
)
)
{
usedAfterLoop
=
true
;
break
;
}
}
if
(
usedAfterLoop
&
&
!
exitingValues
-
>
add
(
phi
)
)
{
return
AnalysisResult
:
:
OOM
;
}
}
for
(
MInstructionIterator
insnIter
(
block
-
>
begin
(
)
)
;
insnIter
!
=
block
-
>
end
(
)
;
insnIter
+
+
)
{
numValuesInOriginal
+
+
;
MInstruction
*
insn
=
*
insnIter
;
bool
usedAfterLoop
=
false
;
for
(
MUseIterator
useIter
(
insn
-
>
usesBegin
(
)
)
;
useIter
!
=
insn
-
>
usesEnd
(
)
;
useIter
+
+
)
{
MUse
*
use
=
*
useIter
;
if
(
!
BlockVectorContains
(
originalBlocks
use
-
>
consumer
(
)
-
>
block
(
)
)
)
{
usedAfterLoop
=
true
;
break
;
}
}
if
(
usedAfterLoop
&
&
!
exitingValues
-
>
add
(
insn
)
)
{
return
AnalysisResult
:
:
OOM
;
}
}
}
if
(
exitTargetBlocks
-
>
size
(
)
>
=
2
&
&
exitingValues
-
>
size
(
)
>
0
)
{
return
AnalysisResult
:
:
TooComplex
;
}
for
(
size_t
i
=
0
;
i
<
exitTargetBlocks
-
>
size
(
)
;
i
+
+
)
{
MBasicBlock
*
exitTargetBlock
=
exitTargetBlocks
-
>
get
(
i
)
;
if
(
!
exitTargetBlock
-
>
phisEmpty
(
)
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
if
(
exitTargetBlock
-
>
numPredecessors
(
)
!
=
1
)
{
return
AnalysisResult
:
:
BadInvariants
;
}
}
bool
peel
=
true
;
bool
unroll
=
true
;
if
(
numBlocksInOriginal
>
MaxBlocksForPeel
|
|
numValuesInOriginal
>
MaxValuesForPeel
)
{
peel
=
false
;
}
if
(
numBlocksInOriginal
>
MaxBlocksForUnroll
|
|
numValuesInOriginal
>
MaxValuesForUnroll
)
{
unroll
=
false
;
}
if
(
peel
)
{
return
unroll
?
AnalysisResult
:
:
PeelAndUnroll
:
AnalysisResult
:
:
Peel
;
}
else
{
return
unroll
?
AnalysisResult
:
:
Unroll
:
AnalysisResult
:
:
TooLarge
;
}
}
[
[
nodiscard
]
]
static
bool
AddClosingPhisForLoop
(
TempAllocator
&
alloc
const
UnrollState
&
state
)
{
if
(
state
.
exitingValues
.
empty
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
state
.
exitTargetBlocks
.
size
(
)
=
=
1
)
;
MBasicBlock
*
targetBlock
=
state
.
exitTargetBlocks
.
get
(
0
)
;
MOZ_ASSERT
(
targetBlock
-
>
numPredecessors
(
)
=
=
1
)
;
for
(
size_t
i
=
0
;
i
<
state
.
exitingValues
.
size
(
)
;
i
+
+
)
{
MDefinition
*
exitingValue
=
state
.
exitingValues
.
get
(
i
)
;
MPhi
*
phi
=
MPhi
:
:
New
(
alloc
exitingValue
-
>
type
(
)
)
;
if
(
!
phi
)
{
return
false
;
}
targetBlock
-
>
addPhi
(
phi
)
;
for
(
MUseIterator
useIter
(
exitingValue
-
>
usesBegin
(
)
)
useIterEnd
(
exitingValue
-
>
usesEnd
(
)
)
;
useIter
!
=
useIterEnd
;
)
{
MUse
*
use
=
*
useIter
+
+
;
if
(
state
.
blockTable
.
rowContains
(
0
use
-
>
consumer
(
)
-
>
block
(
)
)
)
{
continue
;
}
MOZ_ASSERT
(
use
-
>
consumer
(
)
)
;
use
-
>
replaceProducer
(
phi
)
;
}
if
(
!
phi
-
>
addInputFallible
(
exitingValue
)
)
{
return
false
;
}
}
for
(
size_t
i
=
0
;
i
<
state
.
exitingValues
.
size
(
)
;
i
+
+
)
{
MDefinition
*
exitingValue
=
state
.
exitingValues
.
get
(
i
)
;
for
(
MUseIterator
useIter
(
exitingValue
-
>
usesBegin
(
)
)
;
useIter
!
=
exitingValue
-
>
usesEnd
(
)
;
useIter
+
+
)
{
mozilla
:
:
DebugOnly
<
MUse
*
>
use
=
*
useIter
;
MOZ_ASSERT_IF
(
!
state
.
blockTable
.
rowContains
(
0
use
-
>
consumer
(
)
-
>
block
(
)
)
use
-
>
consumer
(
)
-
>
isDefinition
(
)
&
&
use
-
>
consumer
(
)
-
>
toDefinition
(
)
-
>
isPhi
(
)
)
;
}
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
UnrollAndOrPeelLoop
(
MIRGraph
&
graph
UnrollState
&
state
)
{
const
MBasicBlock
*
originalHeader
=
state
.
blockTable
.
get
(
0
0
)
;
MOZ_ASSERT
(
originalHeader
-
>
isLoopHeader
(
)
)
;
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_UnrollDetails
)
)
{
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
ORIGINAL
FUNCTION
(
after
LCSSA
-
ification
of
chosen
loops
)
\
n
"
)
;
DumpMIRGraph
(
printer
graph
true
)
;
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
#
endif
const
uint32_t
unrollFactor
=
state
.
blockTable
.
size1
(
)
;
MOZ_ASSERT
(
unrollFactor
>
=
2
)
;
const
uint32_t
numBlocksInOriginal
=
state
.
blockTable
.
size2
(
)
;
uint32_t
numValuesInOriginal
=
0
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
0
bix
)
;
for
(
MPhiIterator
phiIter
(
block
-
>
phisBegin
(
)
)
;
phiIter
!
=
block
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
numValuesInOriginal
+
+
;
}
for
(
MInstructionIterator
insnIter
(
block
-
>
begin
(
)
)
;
insnIter
!
=
block
-
>
end
(
)
;
insnIter
+
+
)
{
numValuesInOriginal
+
+
;
}
}
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_UnrollDetails
)
)
{
DumpBlockTableRowZero
(
state
.
blockTable
"
ORIGINAL
LOOP
"
)
;
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
EXIT
TARGET
BLOCKS
:
"
)
;
for
(
size_t
i
=
0
;
i
<
state
.
exitTargetBlocks
.
size
(
)
;
i
+
+
)
{
MBasicBlock
*
targetBlock
=
state
.
exitTargetBlocks
.
get
(
i
)
;
DumpMIRBlockID
(
printer
targetBlock
true
)
;
printer
.
printf
(
"
"
)
;
}
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
printer
.
printf
(
"
<
<
<
<
EXITING
VALUES
:
"
)
;
for
(
size_t
i
=
0
;
i
<
state
.
exitingValues
.
size
(
)
;
i
+
+
)
{
MDefinition
*
exitingValue
=
state
.
exitingValues
.
get
(
i
)
;
DumpMIRDefinitionID
(
printer
exitingValue
true
)
;
printer
.
printf
(
"
"
)
;
}
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
#
endif
ValueTable
valueTable
;
if
(
!
valueTable
.
init
(
unrollFactor
numValuesInOriginal
)
)
{
return
false
;
}
{
uint32_t
vix
=
0
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
0
bix
)
;
for
(
MPhiIterator
phiIter
(
block
-
>
phisBegin
(
)
)
;
phiIter
!
=
block
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
valueTable
.
set
(
0
vix
*
phiIter
)
;
vix
+
+
;
}
for
(
MInstructionIterator
insnIter
(
block
-
>
begin
(
)
)
;
insnIter
!
=
block
-
>
end
(
)
;
insnIter
+
+
)
{
valueTable
.
set
(
0
vix
*
insnIter
)
;
vix
+
+
;
}
}
MOZ_ASSERT
(
vix
=
=
numValuesInOriginal
)
;
}
MDefinitionRemapper
mapper
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
originalBlock
=
state
.
blockTable
.
get
(
0
bix
)
;
for
(
MPhiIterator
phiIter
(
originalBlock
-
>
phisBegin
(
)
)
;
phiIter
!
=
originalBlock
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
MPhi
*
originalPhi
=
*
phiIter
;
if
(
!
mapper
.
enregister
(
originalPhi
)
)
{
return
false
;
}
}
for
(
MInstructionIterator
insnIter
(
originalBlock
-
>
begin
(
)
)
;
insnIter
!
=
originalBlock
-
>
end
(
)
;
insnIter
+
+
)
{
MInstruction
*
originalInsn
=
*
insnIter
;
if
(
!
mapper
.
enregister
(
originalInsn
)
)
{
return
false
;
}
}
}
const
CompileInfo
&
info
=
originalHeader
-
>
info
(
)
;
for
(
uint32_t
cix
=
1
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
empty
=
MBasicBlock
:
:
New
(
graph
info
nullptr
MBasicBlock
:
:
Kind
:
:
NORMAL
)
;
if
(
!
empty
)
{
return
false
;
}
empty
-
>
setLoopDepth
(
state
.
blockTable
.
get
(
0
bix
)
-
>
loopDepth
(
)
)
;
MOZ_ASSERT
(
!
state
.
blockTable
.
get
(
cix
bix
)
)
;
state
.
blockTable
.
set
(
cix
bix
empty
)
;
}
}
for
(
uint32_t
cix
=
1
;
cix
<
unrollFactor
;
cix
+
+
)
{
uint32_t
vix
=
0
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
originalBlock
=
state
.
blockTable
.
get
(
0
bix
)
;
MBasicBlock
*
clonedBlock
=
state
.
blockTable
.
get
(
cix
bix
)
;
mozilla
:
:
Vector
<
std
:
:
pair
<
const
MPhi
*
MPhi
*
>
16
SystemAllocPolicy
>
mapperUpdates
;
for
(
MPhiIterator
phiIter
(
originalBlock
-
>
phisBegin
(
)
)
;
phiIter
!
=
originalBlock
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
const
MPhi
*
originalPhi
=
*
phiIter
;
MPhi
*
clonedPhi
=
MakeReplacementPhi
(
graph
.
alloc
(
)
mapper
originalPhi
)
;
if
(
!
clonedPhi
)
{
return
false
;
}
clonedBlock
-
>
addPhi
(
clonedPhi
)
;
MOZ_ASSERT
(
!
valueTable
.
get
(
cix
vix
)
)
;
valueTable
.
set
(
cix
vix
clonedPhi
)
;
vix
+
+
;
if
(
!
mapperUpdates
.
append
(
std
:
:
pair
(
originalPhi
clonedPhi
)
)
)
{
return
false
;
}
}
for
(
auto
&
p
:
mapperUpdates
)
{
mapper
.
update
(
p
.
first
p
.
second
)
;
}
for
(
MInstructionIterator
insnIter
(
originalBlock
-
>
begin
(
)
)
;
insnIter
!
=
originalBlock
-
>
end
(
)
;
insnIter
+
+
)
{
const
MInstruction
*
originalInsn
=
*
insnIter
;
MInstruction
*
clonedInsn
=
MakeReplacementInstruction
(
graph
.
alloc
(
)
mapper
originalInsn
)
;
if
(
!
clonedInsn
)
{
return
false
;
}
clonedBlock
-
>
insertAtEnd
(
clonedInsn
)
;
MOZ_ASSERT
(
!
valueTable
.
get
(
cix
vix
)
)
;
valueTable
.
set
(
cix
vix
clonedInsn
)
;
vix
+
+
;
mapper
.
update
(
originalInsn
clonedInsn
)
;
}
MOZ_ASSERT
(
clonedBlock
-
>
numPredecessors
(
)
=
=
0
)
;
for
(
uint32_t
i
=
0
;
i
<
originalBlock
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
pred
=
originalBlock
-
>
getPredecessor
(
i
)
;
if
(
!
clonedBlock
-
>
appendPredecessor
(
pred
)
)
{
return
false
;
}
}
}
MOZ_ASSERT
(
vix
=
=
numValuesInOriginal
)
;
for
(
vix
=
0
;
vix
<
numValuesInOriginal
;
vix
+
+
)
{
MOZ_ASSERT
(
valueTable
.
get
(
cix
vix
)
-
>
op
(
)
=
=
valueTable
.
get
(
0
vix
)
-
>
op
(
)
)
;
}
for
(
vix
=
0
;
vix
<
numValuesInOriginal
;
vix
+
+
)
{
MDefinition
*
clonedInsn
=
valueTable
.
get
(
cix
vix
)
;
MDefinition
*
originalDep
=
clonedInsn
-
>
dependency
(
)
;
if
(
originalDep
)
{
mozilla
:
:
Maybe
<
size_t
>
originalInsnIndex
=
valueTable
.
findInRow
(
0
originalDep
)
;
if
(
originalInsnIndex
.
isSome
(
)
)
{
MDefinition
*
clonedDep
=
valueTable
.
get
(
cix
originalInsnIndex
.
value
(
)
)
;
clonedInsn
-
>
setDependency
(
clonedDep
)
;
}
}
}
}
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_UnrollDetails
)
)
{
DumpValueTable
(
valueTable
"
VALUE
TABLE
(
final
)
"
)
;
}
#
endif
auto
RemapEdgeDestination
=
[
=
&
state
]
(
uint32_t
cix
MBasicBlock
*
oldDestination
)
-
>
MBasicBlock
*
{
if
(
oldDestination
=
=
state
.
blockTable
.
get
(
0
0
)
)
{
MOZ_ASSERT
(
oldDestination
=
=
originalHeader
)
;
return
state
.
blockTable
.
get
(
(
cix
+
1
)
%
unrollFactor
0
)
;
}
for
(
uint32_t
i
=
1
;
i
<
numBlocksInOriginal
;
i
+
+
)
{
if
(
oldDestination
=
=
state
.
blockTable
.
get
(
0
i
)
)
{
return
state
.
blockTable
.
get
(
cix
i
)
;
}
}
return
oldDestination
;
}
;
auto
RemapEdgeSource
=
[
=
&
state
]
(
uint32_t
cix
MBasicBlock
*
oldSource
)
-
>
MBasicBlock
*
{
if
(
oldSource
=
=
state
.
blockTable
.
get
(
0
numBlocksInOriginal
-
1
)
)
{
MOZ_ASSERT
(
oldSource
=
=
originalHeader
-
>
backedge
(
)
)
;
return
state
.
blockTable
.
get
(
cix
=
=
0
?
(
unrollFactor
-
1
)
:
(
cix
-
1
)
numBlocksInOriginal
-
1
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numBlocksInOriginal
-
1
;
i
+
+
)
{
if
(
oldSource
=
=
state
.
blockTable
.
get
(
0
i
)
)
{
return
state
.
blockTable
.
get
(
cix
i
)
;
}
}
return
oldSource
;
}
;
for
(
uint32_t
cix
=
0
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
b
=
state
.
blockTable
.
get
(
cix
bix
)
;
MControlInstruction
*
lastI
=
b
-
>
lastIns
(
)
;
if
(
lastI
-
>
isGoto
(
)
)
{
MGoto
*
insn
=
lastI
-
>
toGoto
(
)
;
insn
-
>
setTarget
(
RemapEdgeDestination
(
cix
insn
-
>
target
(
)
)
)
;
}
else
if
(
lastI
-
>
isTest
(
)
)
{
MTest
*
insn
=
lastI
-
>
toTest
(
)
;
insn
-
>
setIfTrue
(
RemapEdgeDestination
(
cix
insn
-
>
ifTrue
(
)
)
)
;
insn
-
>
setIfFalse
(
RemapEdgeDestination
(
cix
insn
-
>
ifFalse
(
)
)
)
;
}
else
{
MOZ_CRASH
(
)
;
}
}
}
for
(
int32_t
cix
=
unrollFactor
-
1
;
cix
>
=
0
;
cix
-
-
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
cix
bix
)
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
oldPred
=
block
-
>
getPredecessor
(
i
)
;
MBasicBlock
*
newPred
=
RemapEdgeSource
(
cix
oldPred
)
;
block
-
>
setPredecessor
(
i
newPred
)
;
}
}
}
for
(
uint32_t
cix
=
1
;
cix
<
unrollFactor
;
cix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
cix
0
)
;
MOZ_ASSERT
(
block
-
>
numPredecessors
(
)
=
=
2
)
;
block
-
>
erasePredecessor
(
0
)
;
MOZ_ASSERT
(
block
-
>
numPredecessors
(
)
=
=
1
)
;
for
(
MPhiIterator
phiIter
(
block
-
>
phisBegin
(
)
)
;
phiIter
!
=
block
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
MPhi
*
phi
=
*
phiIter
;
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
2
)
;
phi
-
>
removeOperand
(
0
)
;
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
1
)
;
}
}
for
(
MPhiIterator
phiIter
(
originalHeader
-
>
phisBegin
(
)
)
;
phiIter
!
=
originalHeader
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
MPhi
*
phi
=
*
phiIter
;
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
state
.
blockTable
.
rowContains
(
0
phi
-
>
getOperand
(
0
)
-
>
block
(
)
)
)
;
MDefinition
*
operand1
=
phi
-
>
getOperand
(
1
)
;
MDefinition
*
replacement
=
mapper
.
lookup
(
operand1
)
;
MOZ_ASSERT
(
(
replacement
=
=
nullptr
)
=
=
!
state
.
blockTable
.
rowContains
(
0
operand1
-
>
block
(
)
)
)
;
if
(
replacement
)
{
phi
-
>
replaceOperand
(
1
replacement
)
;
}
}
for
(
uint32_t
cix
=
0
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
cix
bix
)
;
MControlInstruction
*
lastIns
=
block
-
>
lastIns
(
)
;
for
(
size_t
i
=
0
;
i
<
lastIns
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
succ
=
lastIns
-
>
getSuccessor
(
i
)
;
if
(
!
state
.
exitTargetBlocks
.
contains
(
succ
)
)
{
continue
;
}
mozilla
:
:
DebugOnly
<
bool
>
found
=
false
;
for
(
uint32_t
j
=
0
;
j
<
succ
-
>
numPredecessors
(
)
;
j
+
+
)
{
if
(
block
=
=
succ
-
>
getPredecessor
(
j
)
)
{
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
(
cix
=
=
0
)
=
=
found
)
;
if
(
cix
>
0
)
{
if
(
!
succ
-
>
appendPredecessor
(
block
)
)
{
return
false
;
}
for
(
MPhiIterator
phiIter
(
succ
-
>
phisBegin
(
)
)
;
phiIter
!
=
succ
-
>
phisEnd
(
)
;
phiIter
+
+
)
{
MPhi
*
phi
=
*
phiIter
;
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
+
1
=
=
succ
-
>
numPredecessors
(
)
)
;
MDefinition
*
exitingValue
=
phi
-
>
getOperand
(
0
)
;
MOZ_ASSERT
(
state
.
exitingValues
.
contains
(
exitingValue
)
)
;
mozilla
:
:
Maybe
<
size_t
>
colIndex
=
valueTable
.
findInRow
(
0
exitingValue
)
;
MOZ_ASSERT
(
colIndex
.
isSome
(
)
)
;
MDefinition
*
equivValue
=
valueTable
.
get
(
cix
colIndex
.
value
(
)
)
;
if
(
!
phi
-
>
addInputFallible
(
equivValue
)
)
{
return
false
;
}
}
}
}
}
}
mozilla
:
:
Vector
<
MBasicBlock
*
16
SystemAllocPolicy
>
splitterBlocks
;
for
(
uint32_t
cix
=
0
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
cix
bix
)
;
MControlInstruction
*
lastIns
=
block
-
>
lastIns
(
)
;
for
(
size_t
i
=
0
;
i
<
lastIns
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
succ
=
lastIns
-
>
getSuccessor
(
i
)
;
if
(
!
state
.
exitTargetBlocks
.
contains
(
succ
)
)
{
continue
;
}
MBasicBlock
*
splitter
=
MBasicBlock
:
:
New
(
graph
info
block
MBasicBlock
:
:
Kind
:
:
SPLIT_EDGE
)
;
if
(
!
splitter
|
|
!
splitterBlocks
.
append
(
splitter
)
)
{
return
false
;
}
splitter
-
>
setLoopDepth
(
succ
-
>
loopDepth
(
)
)
;
MGoto
*
jump
=
MGoto
:
:
New
(
graph
.
alloc
(
)
succ
)
;
if
(
!
jump
)
{
return
false
;
}
splitter
-
>
insertAtEnd
(
jump
)
;
mozilla
:
:
DebugOnly
<
bool
>
found
=
false
;
for
(
uint32_t
j
=
0
;
j
<
succ
-
>
numPredecessors
(
)
;
j
+
+
)
{
if
(
succ
-
>
getPredecessor
(
j
)
=
=
block
)
{
succ
-
>
setPredecessor
(
j
splitter
)
;
found
=
true
;
break
;
}
}
lastIns
-
>
replaceSuccessor
(
i
splitter
)
;
MOZ_ASSERT
(
found
)
;
}
}
}
{
mozilla
:
:
Vector
<
MBasicBlock
*
32
+
16
SystemAllocPolicy
>
workList
;
for
(
uint32_t
cix
=
0
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
block
=
state
.
blockTable
.
get
(
cix
bix
)
;
if
(
!
workList
.
append
(
block
)
)
{
return
false
;
}
}
}
for
(
MBasicBlock
*
block
:
splitterBlocks
)
{
if
(
!
workList
.
append
(
block
)
)
{
return
false
;
}
}
for
(
MBasicBlock
*
block
:
workList
)
{
MBasicBlock
*
succWithPhis
=
nullptr
;
MControlInstruction
*
lastIns
=
block
-
>
lastIns
(
)
;
for
(
size_t
i
=
0
;
i
<
lastIns
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
succ
=
lastIns
-
>
getSuccessor
(
i
)
;
if
(
succ
-
>
phisEmpty
(
)
)
{
continue
;
}
MOZ_ASSERT
(
succ
)
;
if
(
!
succWithPhis
)
{
succWithPhis
=
succ
;
}
else
if
(
succWithPhis
=
=
succ
)
{
}
else
{
MOZ_CRASH
(
)
;
}
}
if
(
!
succWithPhis
)
{
block
-
>
setSuccessorWithPhis
(
nullptr
0
)
;
}
else
{
MOZ_ASSERT
(
!
succWithPhis
-
>
phisEmpty
(
)
)
;
uint32_t
predIx
=
UINT32_MAX
;
for
(
uint32_t
i
=
0
;
i
<
succWithPhis
-
>
numPredecessors
(
)
;
i
+
+
)
{
if
(
succWithPhis
-
>
getPredecessor
(
i
)
=
=
block
)
{
predIx
=
i
;
break
;
}
}
MOZ_ASSERT
(
predIx
!
=
UINT32_MAX
)
;
block
-
>
setSuccessorWithPhis
(
succWithPhis
predIx
)
;
}
}
}
for
(
uint32_t
cix
=
0
;
cix
<
unrollFactor
-
1
;
cix
+
+
)
{
for
(
uint32_t
vix
=
0
;
vix
<
numValuesInOriginal
;
vix
+
+
)
{
MDefinition
*
ins
=
valueTable
.
get
(
cix
vix
)
;
if
(
!
ins
-
>
isWasmInterruptCheck
(
)
)
{
continue
;
}
MWasmInterruptCheck
*
ic
=
ins
-
>
toWasmInterruptCheck
(
)
;
ic
-
>
block
(
)
-
>
discard
(
ic
)
;
valueTable
.
set
(
cix
vix
nullptr
)
;
}
}
if
(
state
.
doPeeling
(
)
)
{
MBasicBlock
*
backedge
=
state
.
blockTable
.
get
(
unrollFactor
-
1
numBlocksInOriginal
-
1
)
;
MBasicBlock
*
header0
=
state
.
blockTable
.
get
(
0
0
)
;
MBasicBlock
*
header1
=
state
.
blockTable
.
get
(
1
0
)
;
MOZ_ASSERT
(
header0
=
=
originalHeader
)
;
MOZ_ASSERT
(
backedge
-
>
hasLastIns
(
)
)
;
MOZ_ASSERT
(
backedge
-
>
lastIns
(
)
-
>
isGoto
(
)
)
;
MGoto
*
backedgeG
=
backedge
-
>
lastIns
(
)
-
>
toGoto
(
)
;
MOZ_ASSERT
(
backedgeG
-
>
target
(
)
=
=
header0
)
;
backedgeG
-
>
setTarget
(
header1
)
;
header0
-
>
clearLoopHeader
(
)
;
header1
-
>
setLoopHeader
(
)
;
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
originalBlock
=
state
.
blockTable
.
get
(
0
bix
)
;
MOZ_ASSERT
(
originalBlock
-
>
loopDepth
(
)
>
0
)
;
originalBlock
-
>
setLoopDepth
(
originalBlock
-
>
loopDepth
(
)
-
1
)
;
}
MOZ_ASSERT
(
header0
-
>
numPredecessors
(
)
=
=
2
)
;
MOZ_ASSERT
(
header0
-
>
getPredecessor
(
1
)
=
=
backedge
)
;
header0
-
>
erasePredecessor
(
1
)
;
MOZ_ASSERT
(
header1
-
>
numPredecessors
(
)
=
=
1
)
;
if
(
!
header1
-
>
appendPredecessor
(
backedge
)
)
{
return
false
;
}
MPhiIterator
phiIter0
(
header0
-
>
phisBegin
(
)
)
;
MPhiIterator
phiIter1
(
header1
-
>
phisBegin
(
)
)
;
while
(
true
)
{
bool
finished0
=
phiIter0
=
=
header0
-
>
phisEnd
(
)
;
mozilla
:
:
DebugOnly
<
bool
>
finished1
=
phiIter1
=
=
header1
-
>
phisEnd
(
)
;
MOZ_ASSERT
(
finished0
=
=
finished1
)
;
if
(
finished0
)
{
break
;
}
MPhi
*
phi0
=
*
phiIter0
;
MPhi
*
phi1
=
*
phiIter1
;
MOZ_ASSERT
(
phi0
-
>
numOperands
(
)
=
=
2
)
;
MOZ_ASSERT
(
phi1
-
>
numOperands
(
)
=
=
1
)
;
MDefinition
*
phi0arg1
=
phi0
-
>
getOperand
(
1
)
;
phi0
-
>
removeOperand
(
1
)
;
if
(
!
phi1
-
>
addInputFallible
(
phi0arg1
)
)
{
return
false
;
}
phiIter0
+
+
;
phiIter1
+
+
;
}
if
(
backedge
-
>
successorWithPhis
(
)
)
{
MOZ_ASSERT
(
backedge
-
>
successorWithPhis
(
)
=
=
header0
)
;
MOZ_ASSERT
(
backedge
-
>
positionInPhiSuccessor
(
)
=
=
1
)
;
backedge
-
>
setSuccessorWithPhis
(
header1
1
)
;
}
}
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_UnrollDetails
)
)
{
DumpBlockTable
(
state
.
blockTable
"
LOOP
BLOCKS
(
final
)
"
)
;
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
SPLITTER
BLOCKS
\
n
"
)
;
for
(
MBasicBlock
*
block
:
splitterBlocks
)
{
DumpMIRBlock
(
printer
block
true
)
;
}
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
#
endif
{
MBasicBlock
*
cursor
=
state
.
blockTable
.
get
(
0
numBlocksInOriginal
-
1
)
;
for
(
uint32_t
cix
=
1
;
cix
<
unrollFactor
;
cix
+
+
)
{
for
(
uint32_t
bix
=
0
;
bix
<
numBlocksInOriginal
;
bix
+
+
)
{
MBasicBlock
*
addMe
=
state
.
blockTable
.
get
(
cix
bix
)
;
graph
.
insertBlockAfter
(
cursor
addMe
)
;
cursor
=
addMe
;
}
}
for
(
MBasicBlock
*
addMe
:
splitterBlocks
)
{
graph
.
insertBlockAfter
(
cursor
addMe
)
;
cursor
=
addMe
;
}
}
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_UnrollDetails
)
)
{
Fprinter
&
printer
(
JitSpewPrinter
(
)
)
;
printer
.
printf
(
"
<
<
<
<
FUNCTION
AFTER
UNROLLING
\
n
"
)
;
DumpMIRGraph
(
printer
graph
true
)
;
printer
.
printf
(
"
>
>
>
>
\
n
"
)
;
}
#
endif
return
true
;
}
struct
InitialCandidate
{
MBasicBlock
*
header
;
uint32_t
numBlocks
;
float
score
;
bool
valid
;
InitialCandidate
(
MBasicBlock
*
header
uint32_t
numBlocks
)
:
header
(
header
)
numBlocks
(
numBlocks
)
score
(
0
.
0
)
valid
(
true
)
{
}
}
;
using
InitialCandidateVector
=
mozilla
:
:
Vector
<
InitialCandidate
64
SystemAllocPolicy
>
;
[
[
nodiscard
]
]
bool
FindInitialCandidates
(
MIRGraph
&
graph
InitialCandidateVector
&
initialCandidates
)
{
MOZ_ASSERT
(
initialCandidates
.
empty
(
)
)
;
mozilla
:
:
Vector
<
MBasicBlock
*
128
SystemAllocPolicy
>
initialHeaders
;
{
MBasicBlock
*
backedge
=
nullptr
;
uint32_t
expectedNextId
=
0
;
for
(
auto
rpoIter
(
graph
.
rpoBegin
(
)
)
rpoIterEnd
(
graph
.
rpoEnd
(
)
)
;
rpoIter
!
=
rpoIterEnd
;
+
+
rpoIter
)
{
MBasicBlock
*
block
=
*
rpoIter
;
MOZ_RELEASE_ASSERT
(
block
-
>
id
(
)
=
=
expectedNextId
)
;
expectedNextId
+
+
;
if
(
block
-
>
isLoopHeader
(
)
)
{
backedge
=
block
-
>
backedge
(
)
;
}
if
(
block
=
=
backedge
)
{
if
(
!
initialHeaders
.
append
(
block
-
>
loopHeaderOfBackedge
(
)
)
)
{
return
false
;
}
}
}
}
for
(
MBasicBlock
*
header
:
initialHeaders
)
{
MOZ_ASSERT
(
header
-
>
isLoopHeader
(
)
)
;
bool
hasOsrEntry
;
size_t
numBlocks
=
MarkLoopBlocks
(
graph
header
&
hasOsrEntry
)
;
if
(
numBlocks
=
=
0
)
{
continue
;
}
UnmarkLoopBlocks
(
graph
header
)
;
if
(
hasOsrEntry
)
{
continue
;
}
MOZ_RELEASE_ASSERT
(
numBlocks
<
=
UINT32_MAX
)
;
if
(
!
initialCandidates
.
append
(
InitialCandidate
(
header
numBlocks
)
)
)
{
return
false
;
}
}
std
:
:
sort
(
initialCandidates
.
begin
(
)
initialCandidates
.
end
(
)
[
]
(
const
InitialCandidate
&
cand1
const
InitialCandidate
&
cand2
)
{
return
cand1
.
header
-
>
id
(
)
<
cand2
.
header
-
>
id
(
)
;
}
)
;
for
(
size_t
i
=
1
;
i
<
initialCandidates
.
length
(
)
;
i
+
+
)
{
MOZ_RELEASE_ASSERT
(
initialCandidates
[
i
-
1
]
.
header
-
>
id
(
)
+
initialCandidates
[
i
-
1
]
.
numBlocks
<
=
initialCandidates
[
i
]
.
header
-
>
id
(
)
)
;
}
for
(
InitialCandidate
&
cand
:
initialCandidates
)
{
uint32_t
nBlocks
=
cand
.
numBlocks
;
uint32_t
nInsns
=
0
;
uint32_t
nPhis
=
0
;
mozilla
:
:
DebugOnly
<
uint32_t
>
numBlocksVisited
=
0
;
const
MBasicBlock
*
backedge
=
cand
.
header
-
>
backedge
(
)
;
for
(
auto
i
(
graph
.
rpoBegin
(
cand
.
header
)
)
;
;
+
+
i
)
{
MOZ_ASSERT
(
i
!
=
graph
.
rpoEnd
(
)
"
UnrollLoops
:
loop
blocks
overrun
graph
end
"
)
;
MBasicBlock
*
block
=
*
i
;
numBlocksVisited
+
+
;
for
(
MInstructionIterator
iter
(
block
-
>
begin
(
)
)
;
iter
!
=
block
-
>
end
(
)
;
iter
+
+
)
{
nInsns
+
+
;
}
for
(
MPhiIterator
iter
(
block
-
>
phisBegin
(
)
)
;
iter
!
=
block
-
>
phisEnd
(
)
;
iter
+
+
)
{
nPhis
+
+
;
}
if
(
block
=
=
backedge
)
{
break
;
}
}
MOZ_ASSERT
(
numBlocksVisited
=
=
nBlocks
)
;
cand
.
score
=
10
.
0
*
float
(
nBlocks
)
+
2
.
0
*
float
(
nInsns
)
+
1
.
0
*
float
(
nPhis
)
;
}
std
:
:
sort
(
initialCandidates
.
begin
(
)
initialCandidates
.
end
(
)
[
]
(
const
InitialCandidate
&
cand1
const
InitialCandidate
&
cand2
)
{
return
cand1
.
score
<
cand2
.
score
;
}
)
;
return
true
;
}
bool
UnrollLoops
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
bool
*
changed
)
{
*
changed
=
false
;
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Unroll
)
)
{
JitSpew
(
JitSpew_Unroll
"
BEGIN
UnrollLoops
"
)
;
}
#
endif
InitialCandidateVector
initialCandidates
;
if
(
!
FindInitialCandidates
(
graph
initialCandidates
)
)
{
return
false
;
}
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Unroll
)
)
{
for
(
const
InitialCandidate
&
cand
:
initialCandidates
)
{
MOZ_ASSERT
(
cand
.
valid
)
;
JitSpew
(
JitSpew_Unroll
"
initial
cand
:
score
=
%
-
5
.
1f
blocks
=
%
u
-
%
u
"
cand
.
score
cand
.
header
-
>
id
(
)
cand
.
header
-
>
id
(
)
+
cand
.
numBlocks
-
1
)
;
}
}
#
endif
mozilla
:
:
Vector
<
UnrollState
32
SystemAllocPolicy
>
unrollStates
;
for
(
const
InitialCandidate
&
cand
:
initialCandidates
)
{
if
(
cand
.
score
>
InitialCandidateThreshold
)
{
break
;
}
BlockVector
originalBlocks
;
const
MBasicBlock
*
backedge
=
cand
.
header
-
>
backedge
(
)
;
for
(
auto
blockIter
(
graph
.
rpoBegin
(
cand
.
header
)
)
;
;
+
+
blockIter
)
{
MOZ_ASSERT
(
blockIter
!
=
graph
.
rpoEnd
(
)
)
;
MBasicBlock
*
block
=
*
blockIter
;
if
(
!
originalBlocks
.
append
(
block
)
)
{
return
false
;
}
if
(
block
=
=
backedge
)
{
break
;
}
}
BlockSet
exitTargetBlocks
;
ValueSet
exitingValues
;
AnalysisResult
res
=
AnalyzeLoop
(
originalBlocks
&
exitTargetBlocks
&
exitingValues
)
;
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Unroll
)
)
{
MOZ_ASSERT
(
cand
.
valid
)
;
JitSpew
(
JitSpew_Unroll
"
%
13s
:
score
=
%
-
5
.
1f
blocks
=
%
u
-
%
u
"
Name_of_AnalysisResult
(
res
)
cand
.
score
cand
.
header
-
>
id
(
)
cand
.
header
-
>
id
(
)
+
cand
.
numBlocks
-
1
)
;
}
#
endif
switch
(
res
)
{
case
AnalysisResult
:
:
OOM
:
return
false
;
case
AnalysisResult
:
:
Peel
:
case
AnalysisResult
:
:
Unroll
:
case
AnalysisResult
:
:
PeelAndUnroll
:
break
;
case
AnalysisResult
:
:
BadInvariants
:
MOZ_CRASH
(
"
js
:
:
jit
:
:
UnrollLoops
:
unexpected
incoming
MIR
"
)
;
case
AnalysisResult
:
:
TooComplex
:
case
AnalysisResult
:
:
Uncloneable
:
case
AnalysisResult
:
:
TooLarge
:
case
AnalysisResult
:
:
Unsuitable
:
continue
;
default
:
MOZ_CRASH
(
)
;
}
UnrollMode
mode
;
if
(
res
=
=
AnalysisResult
:
:
Peel
)
{
mode
=
UnrollMode
:
:
Peel
;
}
else
if
(
res
=
=
AnalysisResult
:
:
Unroll
)
{
mode
=
UnrollMode
:
:
Unroll
;
}
else
if
(
res
=
=
AnalysisResult
:
:
PeelAndUnroll
)
{
mode
=
UnrollMode
:
:
PeelAndUnroll
;
}
else
{
MOZ_CRASH
(
)
;
}
if
(
!
unrollStates
.
emplaceBack
(
mode
)
)
{
return
false
;
}
UnrollState
*
state
=
&
unrollStates
.
back
(
)
;
if
(
!
state
-
>
exitTargetBlocks
.
copy
(
exitTargetBlocks
)
|
|
!
state
-
>
exitingValues
.
copy
(
exitingValues
)
)
{
return
false
;
}
uint32_t
basicUnrollingFactor
=
JS
:
:
Prefs
:
:
wasm_unroll_factor
(
)
;
if
(
basicUnrollingFactor
<
2
)
{
basicUnrollingFactor
=
2
;
}
else
if
(
basicUnrollingFactor
>
8
)
{
basicUnrollingFactor
=
8
;
}
uint32_t
unrollingFactor
;
if
(
res
=
=
AnalysisResult
:
:
Peel
)
{
unrollingFactor
=
1
+
1
;
}
else
if
(
res
=
=
AnalysisResult
:
:
Unroll
)
{
unrollingFactor
=
0
+
basicUnrollingFactor
;
}
else
if
(
res
=
=
AnalysisResult
:
:
PeelAndUnroll
)
{
unrollingFactor
=
1
+
basicUnrollingFactor
;
}
else
{
MOZ_CRASH
(
)
;
}
if
(
!
state
-
>
blockTable
.
init
(
unrollingFactor
originalBlocks
.
length
(
)
)
)
{
return
false
;
}
for
(
uint32_t
bix
=
0
;
bix
<
originalBlocks
.
length
(
)
;
bix
+
+
)
{
state
-
>
blockTable
.
set
(
0
bix
originalBlocks
[
bix
]
)
;
}
}
for
(
const
UnrollState
&
state
:
unrollStates
)
{
if
(
!
AddClosingPhisForLoop
(
graph
.
alloc
(
)
state
)
)
{
return
false
;
}
}
uint32_t
numLoopsPeeled
=
0
;
uint32_t
numLoopsUnrolled
=
0
;
uint32_t
numLoopsPeeledAndUnrolled
=
0
;
for
(
UnrollState
&
state
:
unrollStates
)
{
if
(
!
UnrollAndOrPeelLoop
(
graph
state
)
)
{
return
false
;
}
switch
(
state
.
mode
)
{
case
UnrollMode
:
:
Peel
:
numLoopsPeeled
+
+
;
break
;
case
UnrollMode
:
:
Unroll
:
numLoopsUnrolled
+
+
;
break
;
case
UnrollMode
:
:
PeelAndUnroll
:
numLoopsPeeledAndUnrolled
+
+
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
if
(
!
unrollStates
.
empty
(
)
)
{
RenumberBlocks
(
graph
)
;
ClearDominatorTree
(
graph
)
;
if
(
!
BuildDominatorTree
(
mir
graph
)
)
{
return
false
;
}
}
uint32_t
numLoopsChanged
=
numLoopsPeeled
+
numLoopsUnrolled
+
numLoopsPeeledAndUnrolled
;
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Unroll
)
)
{
if
(
numLoopsChanged
=
=
0
)
{
JitSpew
(
JitSpew_Unroll
"
END
UnrollLoops
"
)
;
}
else
{
JitSpew
(
JitSpew_Unroll
"
END
UnrollLoops
%
u
processed
(
P
=
%
u
U
=
%
u
P
&
U
=
%
u
)
"
numLoopsChanged
numLoopsPeeled
numLoopsUnrolled
numLoopsPeeledAndUnrolled
)
;
}
}
#
endif
*
changed
=
numLoopsChanged
>
0
;
return
true
;
}
}
}
