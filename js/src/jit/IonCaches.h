#
ifndef
jit_IonCaches_h
#
define
jit_IonCaches_h
#
if
defined
(
JS_CODEGEN_ARM
)
#
include
"
jit
/
arm
/
Assembler
-
arm
.
h
"
#
elif
defined
(
JS_CODEGEN_ARM64
)
#
include
"
jit
/
arm64
/
Assembler
-
arm64
.
h
"
#
elif
defined
(
JS_CODEGEN_MIPS32
)
#
include
"
jit
/
mips32
/
Assembler
-
mips32
.
h
"
#
elif
defined
(
JS_CODEGEN_MIPS64
)
#
include
"
jit
/
mips64
/
Assembler
-
mips64
.
h
"
#
endif
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
TrackedOptimizationInfo
.
h
"
#
include
"
vm
/
TypedArrayCommon
.
h
"
namespace
js
{
namespace
jit
{
class
LInstruction
;
#
define
IONCACHE_KIND_LIST
(
_
)
\
_
(
SetProperty
)
\
_
(
BindName
)
\
_
(
Name
)
#
define
FORWARD_DECLARE
(
kind
)
class
kind
#
#
IC
;
IONCACHE_KIND_LIST
(
FORWARD_DECLARE
)
#
undef
FORWARD_DECLARE
class
IonCacheVisitor
{
public
:
#
define
VISIT_INS
(
op
)
\
virtual
void
visit
#
#
op
#
#
IC
(
CodeGenerator
*
codegen
)
{
\
MOZ_CRASH
(
"
NYI
:
"
#
op
"
IC
"
)
;
\
}
IONCACHE_KIND_LIST
(
VISIT_INS
)
#
undef
VISIT_INS
}
;
class
IonCache
{
public
:
class
StubAttacher
;
enum
Kind
{
#
define
DEFINE_CACHEKINDS
(
ickind
)
Cache_
#
#
ickind
IONCACHE_KIND_LIST
(
DEFINE_CACHEKINDS
)
#
undef
DEFINE_CACHEKINDS
Cache_Invalid
}
;
#
define
CACHEKIND_CASTS
(
ickind
)
\
bool
is
#
#
ickind
(
)
const
{
\
return
kind
(
)
=
=
Cache_
#
#
ickind
;
\
}
\
inline
ickind
#
#
IC
&
to
#
#
ickind
(
)
;
\
inline
const
ickind
#
#
IC
&
to
#
#
ickind
(
)
const
;
IONCACHE_KIND_LIST
(
CACHEKIND_CASTS
)
#
undef
CACHEKIND_CASTS
virtual
Kind
kind
(
)
const
=
0
;
virtual
void
accept
(
CodeGenerator
*
codegen
IonCacheVisitor
*
visitor
)
=
0
;
public
:
static
const
char
*
CacheName
(
Kind
kind
)
;
protected
:
bool
pure_
:
1
;
bool
idempotent_
:
1
;
bool
disabled_
:
1
;
size_t
stubCount_
:
5
;
CodeLocationLabel
fallbackLabel_
;
JSScript
*
script_
;
jsbytecode
*
pc_
;
jsbytecode
*
profilerLeavePc_
;
CodeLocationJump
initialJump_
;
CodeLocationJump
lastJump_
;
CodeLocationLabel
rejoinLabel_
;
private
:
static
const
size_t
MAX_STUBS
;
void
incrementStubCount
(
)
{
stubCount_
+
+
;
MOZ_ASSERT
(
stubCount_
)
;
}
public
:
IonCache
(
)
:
pure_
(
false
)
idempotent_
(
false
)
disabled_
(
false
)
stubCount_
(
0
)
fallbackLabel_
(
)
script_
(
nullptr
)
pc_
(
nullptr
)
profilerLeavePc_
(
nullptr
)
initialJump_
(
)
lastJump_
(
)
rejoinLabel_
(
)
{
}
void
disable
(
)
;
inline
bool
isDisabled
(
)
const
{
return
disabled_
;
}
void
setFallbackLabel
(
CodeOffset
fallbackLabel
)
{
fallbackLabel_
=
fallbackLabel
;
}
void
setProfilerLeavePC
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
pc
!
=
nullptr
)
;
profilerLeavePc_
=
pc
;
}
void
*
rejoinAddress
(
)
const
{
return
rejoinLabel_
.
raw
(
)
;
}
void
emitInitialJump
(
MacroAssembler
&
masm
RepatchLabel
&
entry
)
;
void
updateBaseAddress
(
JitCode
*
code
MacroAssembler
&
masm
)
;
virtual
void
reset
(
ReprotectCode
reprotect
)
;
bool
canAttachStub
(
)
const
{
return
stubCount_
<
MAX_STUBS
;
}
bool
empty
(
)
const
{
return
stubCount_
=
=
0
;
}
enum
LinkStatus
{
LINK_ERROR
CACHE_FLUSHED
LINK_GOOD
}
;
LinkStatus
linkCode
(
JSContext
*
cx
MacroAssembler
&
masm
StubAttacher
&
attacher
IonScript
*
ion
JitCode
*
*
code
)
;
void
attachStub
(
MacroAssembler
&
masm
StubAttacher
&
attacher
CodeLocationJump
lastJump
Handle
<
JitCode
*
>
code
)
;
MOZ_MUST_USE
bool
linkAndAttachStub
(
JSContext
*
cx
MacroAssembler
&
masm
StubAttacher
&
attacher
IonScript
*
ion
const
char
*
attachKind
JS
:
:
TrackedOutcome
=
JS
:
:
TrackedOutcome
:
:
ICOptStub_GenericSuccess
)
;
#
ifdef
DEBUG
bool
isAllocated
(
)
{
return
fallbackLabel_
.
isSet
(
)
;
}
#
endif
bool
pure
(
)
const
{
return
pure_
;
}
bool
idempotent
(
)
const
{
return
idempotent_
;
}
void
setIdempotent
(
)
{
MOZ_ASSERT
(
!
idempotent_
)
;
MOZ_ASSERT
(
!
script_
)
;
MOZ_ASSERT
(
!
pc_
)
;
idempotent_
=
true
;
}
void
setScriptedLocation
(
JSScript
*
script
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
!
idempotent_
)
;
script_
=
script
;
pc_
=
pc
;
}
void
getScriptedLocation
(
MutableHandleScript
pscript
jsbytecode
*
*
ppc
)
const
{
pscript
.
set
(
script_
)
;
*
ppc
=
pc_
;
}
jsbytecode
*
pc
(
)
const
{
MOZ_ASSERT
(
pc_
)
;
return
pc_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
#
define
CACHE_HEADER
(
ickind
)
\
Kind
kind
(
)
const
{
\
return
IonCache
:
:
Cache_
#
#
ickind
;
\
}
\
\
void
accept
(
CodeGenerator
*
codegen
IonCacheVisitor
*
visitor
)
{
\
visitor
-
>
visit
#
#
ickind
#
#
IC
(
codegen
)
;
\
}
\
\
static
const
VMFunction
UpdateInfo
;
class
SetPropertyIC
:
public
IonCache
{
protected
:
LiveRegisterSet
liveRegs_
;
Register
object_
;
Register
temp_
;
Register
tempToUnboxIndex_
;
FloatRegister
tempDouble_
;
FloatRegister
tempFloat32_
;
ConstantOrRegister
id_
;
ConstantOrRegister
value_
;
bool
strict_
:
1
;
bool
needsTypeBarrier_
:
1
;
bool
guardHoles_
:
1
;
bool
hasGenericProxyStub_
:
1
;
bool
hasDenseStub_
:
1
;
void
emitIdGuard
(
MacroAssembler
&
masm
jsid
id
Label
*
fail
)
;
public
:
SetPropertyIC
(
LiveRegisterSet
liveRegs
Register
object
Register
temp
Register
tempToUnboxIndex
FloatRegister
tempDouble
FloatRegister
tempFloat32
const
ConstantOrRegister
&
id
const
ConstantOrRegister
&
value
bool
strict
bool
needsTypeBarrier
bool
guardHoles
)
:
liveRegs_
(
liveRegs
)
object_
(
object
)
temp_
(
temp
)
tempToUnboxIndex_
(
tempToUnboxIndex
)
tempDouble_
(
tempDouble
)
tempFloat32_
(
tempFloat32
)
id_
(
id
)
value_
(
value
)
strict_
(
strict
)
needsTypeBarrier_
(
needsTypeBarrier
)
guardHoles_
(
guardHoles
)
hasGenericProxyStub_
(
false
)
hasDenseStub_
(
false
)
{
}
CACHE_HEADER
(
SetProperty
)
void
reset
(
ReprotectCode
reprotect
)
;
Register
object
(
)
const
{
return
object_
;
}
Register
temp
(
)
const
{
return
temp_
;
}
Register
tempToUnboxIndex
(
)
const
{
return
tempToUnboxIndex_
;
}
FloatRegister
tempDouble
(
)
const
{
return
tempDouble_
;
}
FloatRegister
tempFloat32
(
)
const
{
return
tempFloat32_
;
}
ConstantOrRegister
id
(
)
const
{
return
id_
;
}
ConstantOrRegister
value
(
)
const
{
return
value_
;
}
bool
strict
(
)
const
{
return
strict_
;
}
bool
needsTypeBarrier
(
)
const
{
return
needsTypeBarrier_
;
}
bool
guardHoles
(
)
const
{
return
guardHoles_
;
}
bool
hasGenericProxyStub
(
)
const
{
return
hasGenericProxyStub_
;
}
bool
hasDenseStub
(
)
const
{
return
hasDenseStub_
;
}
void
setHasDenseStub
(
)
{
MOZ_ASSERT
(
!
hasDenseStub
(
)
)
;
hasDenseStub_
=
true
;
}
enum
NativeSetPropCacheability
{
CanAttachNone
CanAttachSetSlot
MaybeCanAttachAddSlot
CanAttachCallSetter
}
;
MOZ_MUST_USE
bool
attachSetSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleShape
shape
bool
checkTypeset
)
;
MOZ_MUST_USE
bool
attachCallSetter
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleObject
holder
HandleShape
shape
void
*
returnAddr
)
;
MOZ_MUST_USE
bool
attachAddSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
HandleShape
oldShape
HandleObjectGroup
oldGroup
bool
checkTypeset
)
;
MOZ_MUST_USE
bool
attachGenericProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleId
id
void
*
returnAddr
)
;
MOZ_MUST_USE
bool
attachDOMProxyShadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
)
;
MOZ_MUST_USE
bool
attachDOMProxyUnshadowed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
void
*
returnAddr
)
;
static
MOZ_MUST_USE
bool
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
obj
HandleValue
idval
HandleValue
value
)
;
MOZ_MUST_USE
bool
tryAttachNative
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
bool
*
tryNativeAddSlot
)
;
MOZ_MUST_USE
bool
tryAttachUnboxed
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
;
MOZ_MUST_USE
bool
tryAttachUnboxedExpando
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
;
MOZ_MUST_USE
bool
tryAttachProxy
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
bool
*
emitted
)
;
MOZ_MUST_USE
bool
tryAttachStub
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
HandleValue
value
MutableHandleId
id
bool
*
emitted
bool
*
tryNativeAddSlot
)
;
MOZ_MUST_USE
bool
tryAttachAddSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleId
id
HandleObjectGroup
oldGroup
HandleShape
oldShape
bool
tryNativeAddSlot
bool
*
emitted
)
;
MOZ_MUST_USE
bool
tryAttachDenseElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
const
Value
&
idval
bool
*
emitted
)
;
MOZ_MUST_USE
bool
tryAttachTypedArrayElement
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
obj
HandleValue
idval
HandleValue
val
bool
*
emitted
)
;
}
;
class
BindNameIC
:
public
IonCache
{
protected
:
Register
environmentChain_
;
PropertyName
*
name_
;
Register
output_
;
public
:
BindNameIC
(
Register
envChain
PropertyName
*
name
Register
output
)
:
environmentChain_
(
envChain
)
name_
(
name
)
output_
(
output
)
{
}
CACHE_HEADER
(
BindName
)
Register
environmentChainReg
(
)
const
{
return
environmentChain_
;
}
HandlePropertyName
name
(
)
const
{
return
HandlePropertyName
:
:
fromMarkedLocation
(
&
name_
)
;
}
Register
outputReg
(
)
const
{
return
output_
;
}
MOZ_MUST_USE
bool
attachGlobal
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
envChain
)
;
MOZ_MUST_USE
bool
attachNonGlobal
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
envChain
HandleObject
holder
)
;
static
JSObject
*
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
envChain
)
;
}
;
class
NameIC
:
public
IonCache
{
protected
:
LiveRegisterSet
liveRegs_
;
bool
typeOf_
;
Register
environmentChain_
;
PropertyName
*
name_
;
TypedOrValueRegister
output_
;
public
:
NameIC
(
LiveRegisterSet
liveRegs
bool
typeOf
Register
envChain
PropertyName
*
name
TypedOrValueRegister
output
)
:
liveRegs_
(
liveRegs
)
typeOf_
(
typeOf
)
environmentChain_
(
envChain
)
name_
(
name
)
output_
(
output
)
{
}
CACHE_HEADER
(
Name
)
Register
environmentChainReg
(
)
const
{
return
environmentChain_
;
}
HandlePropertyName
name
(
)
const
{
return
HandlePropertyName
:
:
fromMarkedLocation
(
&
name_
)
;
}
TypedOrValueRegister
outputReg
(
)
const
{
return
output_
;
}
bool
isTypeOf
(
)
const
{
return
typeOf_
;
}
MOZ_MUST_USE
bool
attachReadSlot
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
envChain
HandleObject
holderBase
HandleNativeObject
holder
Handle
<
PropertyResult
>
prop
)
;
MOZ_MUST_USE
bool
attachCallGetter
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
envChain
HandleObject
obj
HandleObject
holder
HandleShape
shape
void
*
returnAddr
)
;
MOZ_MUST_USE
bool
attachTypeOfNoProperty
(
JSContext
*
cx
HandleScript
outerScript
IonScript
*
ion
HandleObject
envChain
)
;
static
MOZ_MUST_USE
bool
update
(
JSContext
*
cx
HandleScript
outerScript
size_t
cacheIndex
HandleObject
envChain
MutableHandleValue
vp
)
;
}
;
#
undef
CACHE_HEADER
#
define
CACHE_CASTS
(
ickind
)
\
ickind
#
#
IC
&
IonCache
:
:
to
#
#
ickind
(
)
\
{
\
MOZ_ASSERT
(
is
#
#
ickind
(
)
)
;
\
return
*
static_cast
<
ickind
#
#
IC
*
>
(
this
)
;
\
}
\
const
ickind
#
#
IC
&
IonCache
:
:
to
#
#
ickind
(
)
const
\
{
\
MOZ_ASSERT
(
is
#
#
ickind
(
)
)
;
\
return
*
static_cast
<
const
ickind
#
#
IC
*
>
(
this
)
;
\
}
IONCACHE_KIND_LIST
(
CACHE_CASTS
)
#
undef
OPCODE_CASTS
bool
IsCacheableProtoChainForIonOrCacheIR
(
JSObject
*
obj
JSObject
*
holder
)
;
bool
IsCacheableGetPropReadSlotForIonOrCacheIR
(
JSObject
*
obj
JSObject
*
holder
PropertyResult
prop
)
;
bool
IsCacheableGetPropCallScripted
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
*
isTemporarilyUnoptimizable
=
nullptr
)
;
bool
IsCacheableGetPropCallNative
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
;
bool
IsCacheableSetPropCallScripted
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
*
isTemporarilyUnoptimizable
=
nullptr
)
;
bool
IsCacheableSetPropCallNative
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
)
;
bool
ValueToNameOrSymbolId
(
JSContext
*
cx
HandleValue
idval
MutableHandleId
id
bool
*
nameOrSymbol
)
;
void
*
GetReturnAddressToIonCode
(
JSContext
*
cx
)
;
}
}
#
endif
