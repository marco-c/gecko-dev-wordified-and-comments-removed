#
ifndef
jit_SharedIC_h
#
define
jit_SharedIC_h
#
include
"
jscntxt
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
jit
/
BaselineICList
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
SharedICList
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
#
include
"
vm
/
ReceiverGuard
.
h
"
#
include
"
vm
/
TypedArrayCommon
.
h
"
namespace
js
{
namespace
jit
{
class
AutoShapeVector
;
class
ICStub
;
class
ICFallbackStub
;
#
define
FORWARD_DECLARE_STUBS
(
kindName
)
class
IC
#
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
FORWARD_DECLARE_STUBS
)
IC_SHARED_STUB_KIND_LIST
(
FORWARD_DECLARE_STUBS
)
#
undef
FORWARD_DECLARE_STUBS
#
ifdef
JS_JITSPEW
void
FallbackICSpew
(
JSContext
*
cx
ICFallbackStub
*
stub
const
char
*
fmt
.
.
.
)
;
void
TypeFallbackICSpew
(
JSContext
*
cx
ICTypeMonitor_Fallback
*
stub
const
char
*
fmt
.
.
.
)
;
#
else
#
define
FallbackICSpew
(
.
.
.
)
#
define
TypeFallbackICSpew
(
.
.
.
)
#
endif
class
ICEntry
{
private
:
ICStub
*
firstStub_
;
uint32_t
returnOffset_
;
uint32_t
pcOffset_
:
28
;
public
:
enum
Kind
{
Kind_Op
=
0
Kind_NonOp
Kind_CallVM
Kind_NonOpCallVM
Kind_StackCheck
Kind_EarlyStackCheck
Kind_DebugTrap
Kind_DebugPrologue
Kind_DebugEpilogue
Kind_Invalid
}
;
private
:
Kind
kind_
:
4
;
void
setKind
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
<
Kind_Invalid
)
;
kind_
=
kind
;
MOZ_ASSERT
(
this
-
>
kind
(
)
=
=
kind
)
;
}
public
:
ICEntry
(
uint32_t
pcOffset
Kind
kind
)
:
firstStub_
(
nullptr
)
returnOffset_
(
)
pcOffset_
(
pcOffset
)
{
MOZ_ASSERT
(
pcOffset_
=
=
pcOffset
)
;
JS_STATIC_ASSERT
(
BaselineScript
:
:
MAX_JSSCRIPT_LENGTH
<
=
(
1u
<
<
28
)
-
1
)
;
MOZ_ASSERT
(
pcOffset
<
=
BaselineScript
:
:
MAX_JSSCRIPT_LENGTH
)
;
setKind
(
kind
)
;
}
CodeOffsetLabel
returnOffset
(
)
const
{
return
CodeOffsetLabel
(
returnOffset_
)
;
}
void
setReturnOffset
(
CodeOffsetLabel
offset
)
{
MOZ_ASSERT
(
offset
.
offset
(
)
<
=
(
size_t
)
UINT32_MAX
)
;
returnOffset_
=
(
uint32_t
)
offset
.
offset
(
)
;
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
jsbytecode
*
pc
(
JSScript
*
script
)
const
{
return
script
-
>
offsetToPC
(
pcOffset_
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
&
0xf
)
;
}
bool
isForOp
(
)
const
{
return
kind
(
)
=
=
Kind_Op
;
}
void
setFakeKind
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
!
=
Kind_Op
&
&
kind
!
=
Kind_NonOp
)
;
setKind
(
kind
)
;
}
bool
hasStub
(
)
const
{
return
firstStub_
!
=
nullptr
;
}
ICStub
*
firstStub
(
)
const
{
MOZ_ASSERT
(
hasStub
(
)
)
;
return
firstStub_
;
}
ICFallbackStub
*
fallbackStub
(
)
const
;
void
setFirstStub
(
ICStub
*
stub
)
{
firstStub_
=
stub
;
}
static
inline
size_t
offsetOfFirstStub
(
)
{
return
offsetof
(
ICEntry
firstStub_
)
;
}
inline
ICStub
*
*
addressOfFirstStub
(
)
{
return
&
firstStub_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
IonICEntry
:
public
ICEntry
{
JSScript
*
script_
;
public
:
IonICEntry
(
uint32_t
pcOffset
Kind
kind
JSScript
*
script
)
:
ICEntry
(
pcOffset
kind
)
script_
(
script
)
{
}
JSScript
*
script
(
)
{
return
script_
;
}
}
;
class
ICMonitoredStub
;
class
ICMonitoredFallbackStub
;
class
ICUpdatedStub
;
class
ICStubConstIterator
{
friend
class
ICStub
;
friend
class
ICFallbackStub
;
private
:
ICStub
*
currentStub_
;
public
:
explicit
ICStubConstIterator
(
ICStub
*
currentStub
)
:
currentStub_
(
currentStub
)
{
}
static
ICStubConstIterator
StartingAt
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
stub
)
;
}
static
ICStubConstIterator
End
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
nullptr
)
;
}
bool
operator
=
=
(
const
ICStubConstIterator
&
other
)
const
{
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubConstIterator
&
operator
+
+
(
)
;
ICStubConstIterator
operator
+
+
(
int
)
{
ICStubConstIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
nullptr
;
}
}
;
class
ICStubIterator
{
friend
class
ICFallbackStub
;
private
:
ICEntry
*
icEntry_
;
ICFallbackStub
*
fallbackStub_
;
ICStub
*
previousStub_
;
ICStub
*
currentStub_
;
bool
unlinked_
;
explicit
ICStubIterator
(
ICFallbackStub
*
fallbackStub
bool
end
=
false
)
;
public
:
bool
operator
=
=
(
const
ICStubIterator
&
other
)
const
{
MOZ_ASSERT
(
icEntry_
=
=
other
.
icEntry_
)
;
MOZ_ASSERT
(
fallbackStub_
=
=
other
.
fallbackStub_
)
;
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubIterator
&
operator
+
+
(
)
;
ICStubIterator
operator
+
+
(
int
)
{
ICStubIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
(
ICStub
*
)
fallbackStub_
;
}
void
unlink
(
JSContext
*
cx
)
;
}
;
class
ICStub
{
friend
class
ICFallbackStub
;
public
:
enum
Kind
{
INVALID
=
0
#
define
DEF_ENUM_KIND
(
kindName
)
kindName
IC_BASELINE_STUB_KIND_LIST
(
DEF_ENUM_KIND
)
IC_SHARED_STUB_KIND_LIST
(
DEF_ENUM_KIND
)
#
undef
DEF_ENUM_KIND
LIMIT
}
;
static
inline
bool
IsValidKind
(
Kind
k
)
{
return
(
k
>
INVALID
)
&
&
(
k
<
LIMIT
)
;
}
static
const
char
*
KindString
(
Kind
k
)
{
switch
(
k
)
{
#
define
DEF_KIND_STR
(
kindName
)
case
kindName
:
return
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
DEF_KIND_STR
)
IC_SHARED_STUB_KIND_LIST
(
DEF_KIND_STR
)
#
undef
DEF_KIND_STR
default
:
MOZ_CRASH
(
"
Invalid
kind
.
"
)
;
}
}
enum
Trait
{
Regular
=
0x0
Fallback
=
0x1
Monitored
=
0x2
MonitoredFallback
=
0x3
Updated
=
0x4
}
;
void
markCode
(
JSTracer
*
trc
const
char
*
name
)
;
void
updateCode
(
JitCode
*
stubCode
)
;
void
trace
(
JSTracer
*
trc
)
;
template
<
typename
T
typename
.
.
.
Args
>
static
T
*
New
(
JSContext
*
cx
ICStubSpace
*
space
JitCode
*
code
Args
&
&
.
.
.
args
)
{
if
(
!
code
)
return
nullptr
;
T
*
result
=
space
-
>
allocate
<
T
>
(
code
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
result
)
ReportOutOfMemory
(
cx
)
;
return
result
;
}
protected
:
uint8_t
*
stubCode_
;
ICStub
*
next_
;
uint16_t
extra_
;
Trait
trait_
:
3
;
Kind
kind_
:
13
;
inline
ICStub
(
Kind
kind
JitCode
*
stubCode
)
:
stubCode_
(
stubCode
-
>
raw
(
)
)
next_
(
nullptr
)
extra_
(
0
)
trait_
(
Regular
)
kind_
(
kind
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
ICStub
(
Kind
kind
Trait
trait
JitCode
*
stubCode
)
:
stubCode_
(
stubCode
-
>
raw
(
)
)
next_
(
nullptr
)
extra_
(
0
)
trait_
(
trait
)
kind_
(
kind
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
Trait
trait
(
)
const
{
return
(
Trait
)
(
trait_
&
0x7
)
;
}
public
:
inline
Kind
kind
(
)
const
{
return
static_cast
<
Kind
>
(
kind_
)
;
}
inline
bool
isFallback
(
)
const
{
return
trait
(
)
=
=
Fallback
|
|
trait
(
)
=
=
MonitoredFallback
;
}
inline
bool
isMonitored
(
)
const
{
return
trait
(
)
=
=
Monitored
;
}
inline
bool
isUpdated
(
)
const
{
return
trait
(
)
=
=
Updated
;
}
inline
bool
isMonitoredFallback
(
)
const
{
return
trait
(
)
=
=
MonitoredFallback
;
}
inline
const
ICFallbackStub
*
toFallbackStub
(
)
const
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
const
ICFallbackStub
*
>
(
this
)
;
}
inline
ICFallbackStub
*
toFallbackStub
(
)
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
ICFallbackStub
*
>
(
this
)
;
}
inline
const
ICMonitoredStub
*
toMonitoredStub
(
)
const
{
MOZ_ASSERT
(
isMonitored
(
)
)
;
return
reinterpret_cast
<
const
ICMonitoredStub
*
>
(
this
)
;
}
inline
ICMonitoredStub
*
toMonitoredStub
(
)
{
MOZ_ASSERT
(
isMonitored
(
)
)
;
return
reinterpret_cast
<
ICMonitoredStub
*
>
(
this
)
;
}
inline
const
ICMonitoredFallbackStub
*
toMonitoredFallbackStub
(
)
const
{
MOZ_ASSERT
(
isMonitoredFallback
(
)
)
;
return
reinterpret_cast
<
const
ICMonitoredFallbackStub
*
>
(
this
)
;
}
inline
ICMonitoredFallbackStub
*
toMonitoredFallbackStub
(
)
{
MOZ_ASSERT
(
isMonitoredFallback
(
)
)
;
return
reinterpret_cast
<
ICMonitoredFallbackStub
*
>
(
this
)
;
}
inline
const
ICUpdatedStub
*
toUpdatedStub
(
)
const
{
MOZ_ASSERT
(
isUpdated
(
)
)
;
return
reinterpret_cast
<
const
ICUpdatedStub
*
>
(
this
)
;
}
inline
ICUpdatedStub
*
toUpdatedStub
(
)
{
MOZ_ASSERT
(
isUpdated
(
)
)
;
return
reinterpret_cast
<
ICUpdatedStub
*
>
(
this
)
;
}
#
define
KIND_METHODS
(
kindName
)
\
inline
bool
is
#
#
kindName
(
)
const
{
return
kind
(
)
=
=
kindName
;
}
\
inline
const
IC
#
#
kindName
*
to
#
#
kindName
(
)
const
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
const
IC
#
#
kindName
*
>
(
this
)
;
\
}
\
inline
IC
#
#
kindName
*
to
#
#
kindName
(
)
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
IC
#
#
kindName
*
>
(
this
)
;
\
}
IC_BASELINE_STUB_KIND_LIST
(
KIND_METHODS
)
IC_SHARED_STUB_KIND_LIST
(
KIND_METHODS
)
#
undef
KIND_METHODS
inline
ICStub
*
next
(
)
const
{
return
next_
;
}
inline
bool
hasNext
(
)
const
{
return
next_
!
=
nullptr
;
}
inline
void
setNext
(
ICStub
*
stub
)
{
next_
=
stub
;
}
inline
ICStub
*
*
addressOfNext
(
)
{
return
&
next_
;
}
inline
JitCode
*
jitCode
(
)
{
return
JitCode
:
:
FromExecutable
(
stubCode_
)
;
}
inline
uint8_t
*
rawStubCode
(
)
const
{
return
stubCode_
;
}
inline
ICFallbackStub
*
getChainFallback
(
)
{
ICStub
*
lastStub
=
this
;
while
(
lastStub
-
>
next_
)
lastStub
=
lastStub
-
>
next_
;
MOZ_ASSERT
(
lastStub
-
>
isFallback
(
)
)
;
return
lastStub
-
>
toFallbackStub
(
)
;
}
inline
ICStubConstIterator
beginHere
(
)
{
return
ICStubConstIterator
:
:
StartingAt
(
this
)
;
}
static
inline
size_t
offsetOfNext
(
)
{
return
offsetof
(
ICStub
next_
)
;
}
static
inline
size_t
offsetOfStubCode
(
)
{
return
offsetof
(
ICStub
stubCode_
)
;
}
static
inline
size_t
offsetOfExtra
(
)
{
return
offsetof
(
ICStub
extra_
)
;
}
static
bool
CanMakeCalls
(
ICStub
:
:
Kind
kind
)
{
MOZ_ASSERT
(
IsValidKind
(
kind
)
)
;
switch
(
kind
)
{
case
Call_Fallback
:
case
Call_Scripted
:
case
Call_AnyScripted
:
case
Call_Native
:
case
Call_ClassHook
:
case
Call_ScriptedApplyArray
:
case
Call_ScriptedApplyArguments
:
case
Call_ScriptedFunCall
:
case
Call_StringSplit
:
case
WarmUpCounter_Fallback
:
case
GetElem_NativeSlotName
:
case
GetElem_NativeSlotSymbol
:
case
GetElem_NativePrototypeSlotName
:
case
GetElem_NativePrototypeSlotSymbol
:
case
GetElem_NativePrototypeCallNativeName
:
case
GetElem_NativePrototypeCallNativeSymbol
:
case
GetElem_NativePrototypeCallScriptedName
:
case
GetElem_NativePrototypeCallScriptedSymbol
:
case
GetElem_UnboxedPropertyName
:
case
GetProp_CallScripted
:
case
GetProp_CallNative
:
case
GetProp_CallNativeGlobal
:
case
GetProp_CallDOMProxyNative
:
case
GetProp_CallDOMProxyWithGenerationNative
:
case
GetProp_DOMProxyShadowed
:
case
GetProp_Generic
:
case
SetProp_CallScripted
:
case
SetProp_CallNative
:
case
RetSub_Fallback
:
case
GetProp_Fallback
:
case
SetProp_Fallback
:
return
true
;
default
:
return
false
;
}
}
bool
allocatedInFallbackSpace
(
)
const
{
MOZ_ASSERT
(
next
(
)
)
;
return
CanMakeCalls
(
kind
(
)
)
;
}
}
;
class
ICFallbackStub
:
public
ICStub
{
friend
class
ICStubConstIterator
;
protected
:
ICEntry
*
icEntry_
;
uint32_t
numOptimizedStubs_
;
ICStub
*
*
lastStubPtrAddr_
;
ICFallbackStub
(
Kind
kind
JitCode
*
stubCode
)
:
ICStub
(
kind
ICStub
:
:
Fallback
stubCode
)
icEntry_
(
nullptr
)
numOptimizedStubs_
(
0
)
lastStubPtrAddr_
(
nullptr
)
{
}
ICFallbackStub
(
Kind
kind
Trait
trait
JitCode
*
stubCode
)
:
ICStub
(
kind
trait
stubCode
)
icEntry_
(
nullptr
)
numOptimizedStubs_
(
0
)
lastStubPtrAddr_
(
nullptr
)
{
MOZ_ASSERT
(
trait
=
=
ICStub
:
:
Fallback
|
|
trait
=
=
ICStub
:
:
MonitoredFallback
)
;
}
public
:
inline
ICEntry
*
icEntry
(
)
const
{
return
icEntry_
;
}
inline
size_t
numOptimizedStubs
(
)
const
{
return
(
size_t
)
numOptimizedStubs_
;
}
void
fixupICEntry
(
ICEntry
*
icEntry
)
{
MOZ_ASSERT
(
icEntry_
=
=
nullptr
)
;
MOZ_ASSERT
(
lastStubPtrAddr_
=
=
nullptr
)
;
icEntry_
=
icEntry
;
lastStubPtrAddr_
=
icEntry_
-
>
addressOfFirstStub
(
)
;
}
void
addNewStub
(
ICStub
*
stub
)
{
MOZ_ASSERT
(
*
lastStubPtrAddr_
=
=
this
)
;
MOZ_ASSERT
(
stub
-
>
next
(
)
=
=
nullptr
)
;
stub
-
>
setNext
(
this
)
;
*
lastStubPtrAddr_
=
stub
;
lastStubPtrAddr_
=
stub
-
>
addressOfNext
(
)
;
numOptimizedStubs_
+
+
;
}
ICStubConstIterator
beginChainConst
(
)
const
{
return
ICStubConstIterator
(
icEntry_
-
>
firstStub
(
)
)
;
}
ICStubIterator
beginChain
(
)
{
return
ICStubIterator
(
this
)
;
}
bool
hasStub
(
ICStub
:
:
Kind
kind
)
const
{
for
(
ICStubConstIterator
iter
=
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
kind
(
)
=
=
kind
)
return
true
;
}
return
false
;
}
unsigned
numStubsWithKind
(
ICStub
:
:
Kind
kind
)
const
{
unsigned
count
=
0
;
for
(
ICStubConstIterator
iter
=
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
kind
(
)
=
=
kind
)
count
+
+
;
}
return
count
;
}
void
unlinkStub
(
Zone
*
zone
ICStub
*
prev
ICStub
*
stub
)
;
void
unlinkStubsWithKind
(
JSContext
*
cx
ICStub
:
:
Kind
kind
)
;
}
;
class
ICMonitoredStub
:
public
ICStub
{
protected
:
ICStub
*
firstMonitorStub_
;
ICMonitoredStub
(
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
)
;
public
:
inline
void
updateFirstMonitorStub
(
ICStub
*
monitorStub
)
{
MOZ_ASSERT
(
firstMonitorStub_
&
&
firstMonitorStub_
-
>
isTypeMonitor_Fallback
(
)
)
;
firstMonitorStub_
=
monitorStub
;
}
inline
void
resetFirstMonitorStub
(
ICStub
*
monitorFallback
)
{
MOZ_ASSERT
(
monitorFallback
-
>
isTypeMonitor_Fallback
(
)
)
;
firstMonitorStub_
=
monitorFallback
;
}
inline
ICStub
*
firstMonitorStub
(
)
const
{
return
firstMonitorStub_
;
}
static
inline
size_t
offsetOfFirstMonitorStub
(
)
{
return
offsetof
(
ICMonitoredStub
firstMonitorStub_
)
;
}
}
;
class
ICMonitoredFallbackStub
:
public
ICFallbackStub
{
protected
:
ICTypeMonitor_Fallback
*
fallbackMonitorStub_
;
ICMonitoredFallbackStub
(
Kind
kind
JitCode
*
stubCode
)
:
ICFallbackStub
(
kind
ICStub
:
:
MonitoredFallback
stubCode
)
fallbackMonitorStub_
(
nullptr
)
{
}
public
:
bool
initMonitoringChain
(
JSContext
*
cx
ICStubSpace
*
space
)
;
bool
addMonitorStubForValue
(
JSContext
*
cx
JSScript
*
script
HandleValue
val
)
;
inline
ICTypeMonitor_Fallback
*
fallbackMonitorStub
(
)
const
{
return
fallbackMonitorStub_
;
}
static
inline
size_t
offsetOfFallbackMonitorStub
(
)
{
return
offsetof
(
ICMonitoredFallbackStub
fallbackMonitorStub_
)
;
}
}
;
class
ICUpdatedStub
:
public
ICStub
{
protected
:
ICStub
*
firstUpdateStub_
;
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
uint32_t
numOptimizedStubs_
;
ICUpdatedStub
(
Kind
kind
JitCode
*
stubCode
)
:
ICStub
(
kind
ICStub
:
:
Updated
stubCode
)
firstUpdateStub_
(
nullptr
)
numOptimizedStubs_
(
0
)
{
}
public
:
bool
initUpdatingChain
(
JSContext
*
cx
ICStubSpace
*
space
)
;
bool
addUpdateStubForValue
(
JSContext
*
cx
HandleScript
script
HandleObject
obj
HandleId
id
HandleValue
val
)
;
void
addOptimizedUpdateStub
(
ICStub
*
stub
)
{
if
(
firstUpdateStub_
-
>
isTypeUpdate_Fallback
(
)
)
{
stub
-
>
setNext
(
firstUpdateStub_
)
;
firstUpdateStub_
=
stub
;
}
else
{
ICStub
*
iter
=
firstUpdateStub_
;
MOZ_ASSERT
(
iter
-
>
next
(
)
!
=
nullptr
)
;
while
(
!
iter
-
>
next
(
)
-
>
isTypeUpdate_Fallback
(
)
)
iter
=
iter
-
>
next
(
)
;
MOZ_ASSERT
(
iter
-
>
next
(
)
-
>
next
(
)
=
=
nullptr
)
;
stub
-
>
setNext
(
iter
-
>
next
(
)
)
;
iter
-
>
setNext
(
stub
)
;
}
numOptimizedStubs_
+
+
;
}
inline
ICStub
*
firstUpdateStub
(
)
const
{
return
firstUpdateStub_
;
}
bool
hasTypeUpdateStub
(
ICStub
:
:
Kind
kind
)
{
ICStub
*
stub
=
firstUpdateStub_
;
do
{
if
(
stub
-
>
kind
(
)
=
=
kind
)
return
true
;
stub
=
stub
-
>
next
(
)
;
}
while
(
stub
)
;
return
false
;
}
inline
uint32_t
numOptimizedStubs
(
)
const
{
return
numOptimizedStubs_
;
}
static
inline
size_t
offsetOfFirstUpdateStub
(
)
{
return
offsetof
(
ICUpdatedStub
firstUpdateStub_
)
;
}
}
;
class
ICStubCompiler
{
js
:
:
gc
:
:
AutoSuppressGC
suppressGC
;
public
:
enum
class
Engine
{
Baseline
=
0
IonMonkey
}
;
protected
:
JSContext
*
cx
;
ICStub
:
:
Kind
kind
;
Engine
engine_
;
bool
inStubFrame_
;
#
ifdef
DEBUG
bool
entersStubFrame_
;
#
endif
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
;
}
virtual
bool
generateStubCode
(
MacroAssembler
&
masm
)
=
0
;
virtual
void
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
genCode
)
{
}
JitCode
*
getStubCode
(
)
;
ICStubCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
Engine
engine
)
:
suppressGC
(
cx
)
cx
(
cx
)
kind
(
kind
)
engine_
(
engine
)
inStubFrame_
(
false
)
#
ifdef
DEBUG
entersStubFrame_
(
false
)
#
endif
{
}
void
pushFramePtr
(
MacroAssembler
&
masm
Register
scratch
)
;
bool
tailCallVM
(
const
VMFunction
&
fun
MacroAssembler
&
masm
)
;
bool
callVM
(
const
VMFunction
&
fun
MacroAssembler
&
masm
)
;
bool
callTypeUpdateIC
(
MacroAssembler
&
masm
uint32_t
objectOffset
)
;
void
enterStubFrame
(
MacroAssembler
&
masm
Register
scratch
)
;
void
leaveStubFrame
(
MacroAssembler
&
masm
bool
calledIntoIon
=
false
)
;
void
guardProfilingEnabled
(
MacroAssembler
&
masm
Register
scratch
Label
*
skip
)
;
inline
AllocatableGeneralRegisterSet
availableGeneralRegs
(
size_t
numInputs
)
const
{
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
All
(
)
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
regs
.
take
(
BaselineSecondScratchReg
)
;
#
elif
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
BaselineSecondScratchReg
)
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
MOZ_ASSERT
(
!
regs
.
has
(
PseudoStackPointer
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
RealStackPointer
)
)
;
MOZ_ASSERT
(
!
regs
.
has
(
ICTailCallReg
)
)
;
#
else
MOZ_ASSERT
(
!
regs
.
has
(
BaselineStackReg
)
)
;
#
endif
regs
.
take
(
BaselineFrameReg
)
;
regs
.
take
(
ICStubReg
)
;
#
ifdef
JS_CODEGEN_X64
regs
.
take
(
ExtractTemp0
)
;
regs
.
take
(
ExtractTemp1
)
;
#
endif
switch
(
numInputs
)
{
case
0
:
break
;
case
1
:
regs
.
take
(
R0
)
;
break
;
case
2
:
regs
.
take
(
R0
)
;
regs
.
take
(
R1
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
numInputs
"
)
;
}
return
regs
;
}
bool
emitPostWriteBarrierSlot
(
MacroAssembler
&
masm
Register
obj
ValueOperand
val
Register
scratch
LiveGeneralRegisterSet
saveRegs
)
;
template
<
typename
T
typename
.
.
.
Args
>
T
*
newStub
(
Args
&
&
.
.
.
args
)
{
return
ICStub
:
:
New
<
T
>
(
cx
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
}
public
:
virtual
ICStub
*
getStub
(
ICStubSpace
*
space
)
=
0
;
static
ICStubSpace
*
StubSpaceForKind
(
ICStub
:
:
Kind
kind
JSScript
*
script
)
{
if
(
ICStub
:
:
CanMakeCalls
(
kind
)
)
return
script
-
>
baselineScript
(
)
-
>
fallbackStubSpace
(
)
;
return
script
-
>
zone
(
)
-
>
jitZone
(
)
-
>
optimizedStubSpace
(
)
;
}
ICStubSpace
*
getStubSpace
(
JSScript
*
script
)
{
return
StubSpaceForKind
(
kind
script
)
;
}
}
;
class
ICMultiStubCompiler
:
public
ICStubCompiler
{
protected
:
JSOp
op
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op
)
<
<
17
)
;
}
ICMultiStubCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
JSOp
op
Engine
engine
)
:
ICStubCompiler
(
cx
kind
engine
)
op
(
op
)
{
}
}
;
class
ICBinaryArith_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICBinaryArith_Fallback
(
JitCode
*
stubCode
)
:
ICFallbackStub
(
BinaryArith_Fallback
stubCode
)
{
extra_
=
0
;
}
static
const
uint16_t
SAW_DOUBLE_RESULT_BIT
=
0x1
;
static
const
uint16_t
UNOPTIMIZABLE_OPERANDS_BIT
=
0x2
;
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
bool
sawDoubleResult
(
)
const
{
return
extra_
&
SAW_DOUBLE_RESULT_BIT
;
}
void
setSawDoubleResult
(
)
{
extra_
|
=
SAW_DOUBLE_RESULT_BIT
;
}
bool
hadUnoptimizableOperands
(
)
const
{
return
extra_
&
UNOPTIMIZABLE_OPERANDS_BIT
;
}
void
noteUnoptimizableOperands
(
)
{
extra_
|
=
UNOPTIMIZABLE_OPERANDS_BIT
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
Engine
engine
)
:
ICStubCompiler
(
cx
ICStub
:
:
BinaryArith_Fallback
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_Fallback
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICBinaryArith_Int32
:
public
ICStub
{
friend
class
ICStubSpace
;
ICBinaryArith_Int32
(
JitCode
*
stubCode
bool
allowDouble
)
:
ICStub
(
BinaryArith_Int32
stubCode
)
{
extra_
=
allowDouble
;
}
public
:
bool
allowDouble
(
)
const
{
return
extra_
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
JSOp
op_
;
bool
allowDouble_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
allowDouble_
)
<
<
25
)
;
}
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
allowDouble
)
:
ICStubCompiler
(
cx
ICStub
:
:
BinaryArith_Int32
engine
)
op_
(
op
)
allowDouble_
(
allowDouble
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_Int32
>
(
space
getStubCode
(
)
allowDouble_
)
;
}
}
;
}
;
class
ICBinaryArith_StringConcat
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICBinaryArith_StringConcat
(
JitCode
*
stubCode
)
:
ICStub
(
BinaryArith_StringConcat
stubCode
)
{
}
public
:
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
Engine
engine
)
:
ICStubCompiler
(
cx
ICStub
:
:
BinaryArith_StringConcat
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_StringConcat
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICBinaryArith_StringObjectConcat
:
public
ICStub
{
friend
class
ICStubSpace
;
ICBinaryArith_StringObjectConcat
(
JitCode
*
stubCode
bool
lhsIsString
)
:
ICStub
(
BinaryArith_StringObjectConcat
stubCode
)
{
extra_
=
lhsIsString
;
}
public
:
bool
lhsIsString
(
)
const
{
return
extra_
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
lhsIsString_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
lhsIsString_
)
<
<
17
)
;
}
public
:
Compiler
(
JSContext
*
cx
Engine
engine
bool
lhsIsString
)
:
ICStubCompiler
(
cx
ICStub
:
:
BinaryArith_StringObjectConcat
engine
)
lhsIsString_
(
lhsIsString
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_StringObjectConcat
>
(
space
getStubCode
(
)
lhsIsString_
)
;
}
}
;
}
;
class
ICBinaryArith_Double
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICBinaryArith_Double
(
JitCode
*
stubCode
)
:
ICStub
(
BinaryArith_Double
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
BinaryArith_Double
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_Double
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICBinaryArith_BooleanWithInt32
:
public
ICStub
{
friend
class
ICStubSpace
;
ICBinaryArith_BooleanWithInt32
(
JitCode
*
stubCode
bool
lhsIsBool
bool
rhsIsBool
)
:
ICStub
(
BinaryArith_BooleanWithInt32
stubCode
)
{
MOZ_ASSERT
(
lhsIsBool
|
|
rhsIsBool
)
;
extra_
=
0
;
if
(
lhsIsBool
)
extra_
|
=
1
;
if
(
rhsIsBool
)
extra_
|
=
2
;
}
public
:
bool
lhsIsBoolean
(
)
const
{
return
extra_
&
1
;
}
bool
rhsIsBoolean
(
)
const
{
return
extra_
&
2
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
JSOp
op_
;
bool
lhsIsBool_
;
bool
rhsIsBool_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
lhsIsBool_
)
<
<
25
)
|
(
static_cast
<
int32_t
>
(
rhsIsBool_
)
<
<
26
)
;
}
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
lhsIsBool
bool
rhsIsBool
)
:
ICStubCompiler
(
cx
ICStub
:
:
BinaryArith_BooleanWithInt32
engine
)
op_
(
op
)
lhsIsBool_
(
lhsIsBool
)
rhsIsBool_
(
rhsIsBool
)
{
MOZ_ASSERT
(
op_
=
=
JSOP_ADD
|
|
op_
=
=
JSOP_SUB
|
|
op_
=
=
JSOP_BITOR
|
|
op_
=
=
JSOP_BITAND
|
|
op_
=
=
JSOP_BITXOR
)
;
MOZ_ASSERT
(
lhsIsBool_
|
|
rhsIsBool_
)
;
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_BooleanWithInt32
>
(
space
getStubCode
(
)
lhsIsBool_
rhsIsBool_
)
;
}
}
;
}
;
class
ICBinaryArith_DoubleWithInt32
:
public
ICStub
{
friend
class
ICStubSpace
;
ICBinaryArith_DoubleWithInt32
(
JitCode
*
stubCode
bool
lhsIsDouble
)
:
ICStub
(
BinaryArith_DoubleWithInt32
stubCode
)
{
extra_
=
lhsIsDouble
;
}
public
:
bool
lhsIsDouble
(
)
const
{
return
extra_
;
}
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
lhsIsDouble_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
lhsIsDouble_
)
<
<
25
)
;
}
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
lhsIsDouble
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
BinaryArith_DoubleWithInt32
op
engine
)
lhsIsDouble_
(
lhsIsDouble
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICBinaryArith_DoubleWithInt32
>
(
space
getStubCode
(
)
lhsIsDouble_
)
;
}
}
;
}
;
class
ICUnaryArith_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICUnaryArith_Fallback
(
JitCode
*
stubCode
)
:
ICFallbackStub
(
UnaryArith_Fallback
stubCode
)
{
extra_
=
0
;
}
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
bool
sawDoubleResult
(
)
{
return
extra_
;
}
void
setSawDoubleResult
(
)
{
extra_
=
1
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
Engine
engine
)
:
ICStubCompiler
(
cx
ICStub
:
:
UnaryArith_Fallback
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICUnaryArith_Fallback
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICUnaryArith_Int32
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICUnaryArith_Int32
(
JitCode
*
stubCode
)
:
ICStub
(
UnaryArith_Int32
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
UnaryArith_Int32
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICUnaryArith_Int32
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICUnaryArith_Double
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICUnaryArith_Double
(
JitCode
*
stubCode
)
:
ICStub
(
UnaryArith_Double
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
UnaryArith_Double
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICUnaryArith_Double
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Fallback
:
public
ICFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Fallback
(
JitCode
*
stubCode
)
:
ICFallbackStub
(
ICStub
:
:
Compare_Fallback
stubCode
)
{
}
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
8
;
static
const
size_t
UNOPTIMIZABLE_ACCESS_BIT
=
0
;
void
noteUnoptimizableAccess
(
)
{
extra_
|
=
(
1u
<
<
UNOPTIMIZABLE_ACCESS_BIT
)
;
}
bool
hadUnoptimizableAccess
(
)
const
{
return
extra_
&
(
1u
<
<
UNOPTIMIZABLE_ACCESS_BIT
)
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
Engine
engine
)
:
ICStubCompiler
(
cx
ICStub
:
:
Compare_Fallback
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Fallback
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Int32
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Int32
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_Int32
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_Int32
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Int32
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Double
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Double
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_Double
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_Double
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Double
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_NumberWithUndefined
:
public
ICStub
{
friend
class
ICStubSpace
;
ICCompare_NumberWithUndefined
(
JitCode
*
stubCode
bool
lhsIsUndefined
)
:
ICStub
(
ICStub
:
:
Compare_NumberWithUndefined
stubCode
)
{
extra_
=
lhsIsUndefined
;
}
public
:
bool
lhsIsUndefined
(
)
{
return
extra_
;
}
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
bool
lhsIsUndefined
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
lhsIsUndefined
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_NumberWithUndefined
op
engine
)
lhsIsUndefined
(
lhsIsUndefined
)
{
}
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
lhsIsUndefined
)
<
<
25
)
;
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_NumberWithUndefined
>
(
space
getStubCode
(
)
lhsIsUndefined
)
;
}
}
;
}
;
class
ICCompare_String
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_String
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_String
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_String
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_String
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Boolean
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Boolean
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_Boolean
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_Boolean
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Boolean
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Object
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_Object
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_Object
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_Object
op
engine
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Object
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_ObjectWithUndefined
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICCompare_ObjectWithUndefined
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
Compare_ObjectWithUndefined
stubCode
)
{
}
public
:
class
Compiler
:
public
ICMultiStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
bool
lhsIsUndefined
;
bool
compareWithNull
;
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
lhsIsUndefined
bool
compareWithNull
)
:
ICMultiStubCompiler
(
cx
ICStub
:
:
Compare_ObjectWithUndefined
op
engine
)
lhsIsUndefined
(
lhsIsUndefined
)
compareWithNull
(
compareWithNull
)
{
}
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
lhsIsUndefined
)
<
<
25
)
|
(
static_cast
<
int32_t
>
(
compareWithNull
)
<
<
26
)
;
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_ObjectWithUndefined
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICCompare_Int32WithBoolean
:
public
ICStub
{
friend
class
ICStubSpace
;
ICCompare_Int32WithBoolean
(
JitCode
*
stubCode
bool
lhsIsInt32
)
:
ICStub
(
ICStub
:
:
Compare_Int32WithBoolean
stubCode
)
{
extra_
=
lhsIsInt32
;
}
public
:
bool
lhsIsInt32
(
)
const
{
return
extra_
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
JSOp
op_
;
bool
lhsIsInt32_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
op_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
lhsIsInt32_
)
<
<
25
)
;
}
public
:
Compiler
(
JSContext
*
cx
JSOp
op
Engine
engine
bool
lhsIsInt32
)
:
ICStubCompiler
(
cx
ICStub
:
:
Compare_Int32WithBoolean
engine
)
op_
(
op
)
lhsIsInt32_
(
lhsIsInt32
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICCompare_Int32WithBoolean
>
(
space
getStubCode
(
)
lhsIsInt32_
)
;
}
}
;
}
;
enum
TypedThingLayout
{
Layout_TypedArray
Layout_OutlineTypedObject
Layout_InlineTypedObject
}
;
static
inline
TypedThingLayout
GetTypedThingLayout
(
const
Class
*
clasp
)
{
if
(
IsAnyTypedArrayClass
(
clasp
)
)
return
Layout_TypedArray
;
if
(
IsOutlineTypedObjectClass
(
clasp
)
)
return
Layout_OutlineTypedObject
;
if
(
IsInlineTypedObjectClass
(
clasp
)
)
return
Layout_InlineTypedObject
;
MOZ_CRASH
(
"
Bad
object
class
"
)
;
}
bool
IsPreliminaryObject
(
JSObject
*
obj
)
;
void
StripPreliminaryObjectStubs
(
JSContext
*
cx
ICFallbackStub
*
stub
)
;
bool
EffectlesslyLookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
name
MutableHandleObject
holder
MutableHandleShape
shape
bool
*
checkDOMProxy
=
nullptr
DOMProxyShadowsResult
*
shadowsResult
=
nullptr
bool
*
domProxyHasGeneration
=
nullptr
)
;
JSObject
*
GetDOMProxyProto
(
JSObject
*
obj
)
;
bool
IsCacheableProtoChain
(
JSObject
*
obj
JSObject
*
holder
bool
isDOMProxy
=
false
)
;
bool
IsCacheableGetPropReadSlot
(
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
isDOMProxy
=
false
)
;
void
GetFixedOrDynamicSlotOffset
(
Shape
*
shape
bool
*
isFixed
uint32_t
*
offset
)
;
bool
IsCacheableGetPropCall
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
*
isScripted
bool
*
isTemporarilyUnoptimizable
bool
isDOMProxy
=
false
)
;
bool
UpdateExistingGetPropCallStubs
(
ICFallbackStub
*
fallbackStub
ICStub
:
:
Kind
kind
HandleNativeObject
holder
HandleObject
receiver
HandleFunction
getter
)
;
bool
CheckHasNoSuchProperty
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
MutableHandleObject
lastProto
size_t
*
protoChainDepthOut
)
;
void
GuardReceiverObject
(
MacroAssembler
&
masm
ReceiverGuard
guard
Register
object
Register
scratch
size_t
receiverGuardOffset
Label
*
failure
)
;
bool
GetProtoShapes
(
JSObject
*
obj
size_t
protoChainDepth
MutableHandle
<
ShapeVector
>
shapes
)
;
void
CheckDOMProxyExpandoDoesNotShadow
(
JSContext
*
cx
MacroAssembler
&
masm
Register
object
const
Address
&
checkExpandoShapeAddr
Address
*
expandoAndGenerationAddr
Address
*
generationAddr
Register
scratch
AllocatableGeneralRegisterSet
&
domProxyRegSet
Label
*
checkFailed
)
;
void
CheckForNeuteredTypedObject
(
JSContext
*
cx
MacroAssembler
&
masm
Label
*
failure
)
;
bool
DoCallNativeGetter
(
JSContext
*
cx
HandleFunction
callee
HandleObject
obj
MutableHandleValue
result
)
;
void
LoadTypedThingData
(
MacroAssembler
&
masm
TypedThingLayout
layout
Register
obj
Register
result
)
;
class
ICGetProp_Fallback
:
public
ICMonitoredFallbackStub
{
friend
class
ICStubSpace
;
explicit
ICGetProp_Fallback
(
JitCode
*
stubCode
)
:
ICMonitoredFallbackStub
(
ICStub
:
:
GetProp_Fallback
stubCode
)
{
}
public
:
static
const
uint32_t
MAX_OPTIMIZED_STUBS
=
16
;
static
const
size_t
UNOPTIMIZABLE_ACCESS_BIT
=
0
;
static
const
size_t
ACCESSED_GETTER_BIT
=
1
;
void
noteUnoptimizableAccess
(
)
{
extra_
|
=
(
1u
<
<
UNOPTIMIZABLE_ACCESS_BIT
)
;
}
bool
hadUnoptimizableAccess
(
)
const
{
return
extra_
&
(
1u
<
<
UNOPTIMIZABLE_ACCESS_BIT
)
;
}
void
noteAccessedGetter
(
)
{
extra_
|
=
(
1u
<
<
ACCESSED_GETTER_BIT
)
;
}
bool
hasAccessedGetter
(
)
const
{
return
extra_
&
(
1u
<
<
ACCESSED_GETTER_BIT
)
;
}
class
Compiler
:
public
ICStubCompiler
{
public
:
static
const
int32_t
BASELINE_KEY
=
(
static_cast
<
int32_t
>
(
Engine
:
:
Baseline
)
)
|
(
static_cast
<
int32_t
>
(
ICStub
:
:
GetProp_Fallback
)
<
<
1
)
;
protected
:
uint32_t
returnOffset_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
void
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_Fallback
Engine
:
:
Baseline
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
ICGetProp_Fallback
*
stub
=
newStub
<
ICGetProp_Fallback
>
(
space
getStubCode
(
)
)
;
if
(
!
stub
|
|
!
stub
-
>
initMonitoringChain
(
cx
space
)
)
return
nullptr
;
return
stub
;
}
}
;
}
;
class
ICGetProp_Generic
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
protected
:
explicit
ICGetProp_Generic
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
)
:
ICMonitoredStub
(
ICStub
:
:
GetProp_Generic
stubCode
firstMonitorStub
)
{
}
public
:
static
ICGetProp_Generic
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_Generic
&
other
)
;
class
Compiler
:
public
ICStubCompiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
ICStub
*
firstMonitorStub_
;
public
:
explicit
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_Generic
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_Generic
>
(
space
getStubCode
(
)
firstMonitorStub_
)
;
}
}
;
}
;
class
ICGetProp_ArrayLength
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICGetProp_ArrayLength
(
JitCode
*
stubCode
)
:
ICStub
(
GetProp_ArrayLength
stubCode
)
{
}
public
:
class
Compiler
:
public
ICStubCompiler
{
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_ArrayLength
Engine
:
:
Baseline
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_ArrayLength
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICGetProp_UnboxedArrayLength
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICGetProp_UnboxedArrayLength
(
JitCode
*
stubCode
)
:
ICStub
(
GetProp_UnboxedArrayLength
stubCode
)
{
}
public
:
class
Compiler
:
public
ICStubCompiler
{
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_UnboxedArrayLength
Engine
:
:
Baseline
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_UnboxedArrayLength
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICGetProp_Primitive
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
protected
:
HeapPtrShape
protoShape_
;
uint32_t
offset_
;
ICGetProp_Primitive
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSValueType
primitiveType
Shape
*
protoShape
uint32_t
offset
)
;
public
:
HeapPtrShape
&
protoShape
(
)
{
return
protoShape_
;
}
JSValueType
primitiveType
(
)
const
{
return
JSValueType
(
extra_
)
;
}
static
size_t
offsetOfProtoShape
(
)
{
return
offsetof
(
ICGetProp_Primitive
protoShape_
)
;
}
static
size_t
offsetOfOffset
(
)
{
return
offsetof
(
ICGetProp_Primitive
offset_
)
;
}
class
Compiler
:
public
ICStubCompiler
{
ICStub
*
firstMonitorStub_
;
JSValueType
primitiveType_
;
RootedObject
prototype_
;
bool
isFixedSlot_
;
uint32_t
offset_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
protected
:
virtual
int32_t
getKey
(
)
const
{
static_assert
(
sizeof
(
JSValueType
)
=
=
1
"
JSValueType
should
fit
in
one
byte
"
)
;
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
isFixedSlot_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
primitiveType_
)
<
<
25
)
;
}
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
JSValueType
primitiveType
HandleObject
prototype
bool
isFixedSlot
uint32_t
offset
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_Primitive
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
primitiveType_
(
primitiveType
)
prototype_
(
cx
prototype
)
isFixedSlot_
(
isFixedSlot
)
offset_
(
offset
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
RootedShape
protoShape
(
cx
prototype_
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
return
newStub
<
ICGetProp_Primitive
>
(
space
getStubCode
(
)
firstMonitorStub_
primitiveType_
protoShape
offset_
)
;
}
}
;
}
;
class
ICGetProp_StringLength
:
public
ICStub
{
friend
class
ICStubSpace
;
explicit
ICGetProp_StringLength
(
JitCode
*
stubCode
)
:
ICStub
(
GetProp_StringLength
stubCode
)
{
}
public
:
class
Compiler
:
public
ICStubCompiler
{
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
explicit
Compiler
(
JSContext
*
cx
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_StringLength
Engine
:
:
Baseline
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_StringLength
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICGetPropNativeStub
:
public
ICMonitoredStub
{
HeapReceiverGuard
receiverGuard_
;
uint32_t
offset_
;
protected
:
ICGetPropNativeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
offset
)
;
public
:
HeapReceiverGuard
&
receiverGuard
(
)
{
return
receiverGuard_
;
}
uint32_t
offset
(
)
const
{
return
offset_
;
}
void
notePreliminaryObject
(
)
{
extra_
=
1
;
}
bool
hasPreliminaryObject
(
)
const
{
return
extra_
;
}
static
size_t
offsetOfReceiverGuard
(
)
{
return
offsetof
(
ICGetPropNativeStub
receiverGuard_
)
;
}
static
size_t
offsetOfOffset
(
)
{
return
offsetof
(
ICGetPropNativeStub
offset_
)
;
}
}
;
class
ICGetProp_Native
:
public
ICGetPropNativeStub
{
friend
class
ICStubSpace
;
ICGetProp_Native
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
offset
)
:
ICGetPropNativeStub
(
GetProp_Native
stubCode
firstMonitorStub
guard
offset
)
{
}
public
:
static
ICGetProp_Native
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_Native
&
other
)
;
}
;
class
ICGetPropNativePrototypeStub
:
public
ICGetPropNativeStub
{
HeapPtrObject
holder_
;
HeapPtrShape
holderShape_
;
protected
:
ICGetPropNativePrototypeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
offset
JSObject
*
holder
Shape
*
holderShape
)
;
public
:
HeapPtrObject
&
holder
(
)
{
return
holder_
;
}
HeapPtrShape
&
holderShape
(
)
{
return
holderShape_
;
}
static
size_t
offsetOfHolder
(
)
{
return
offsetof
(
ICGetPropNativePrototypeStub
holder_
)
;
}
static
size_t
offsetOfHolderShape
(
)
{
return
offsetof
(
ICGetPropNativePrototypeStub
holderShape_
)
;
}
}
;
class
ICGetProp_NativePrototype
:
public
ICGetPropNativePrototypeStub
{
friend
class
ICStubSpace
;
protected
:
ICGetProp_NativePrototype
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
offset
JSObject
*
holder
Shape
*
holderShape
)
:
ICGetPropNativePrototypeStub
(
GetProp_NativePrototype
stubCode
firstMonitorStub
guard
offset
holder
holderShape
)
{
}
public
:
static
ICGetProp_NativePrototype
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_NativePrototype
&
other
)
;
}
;
class
ICGetName_Global
:
public
ICGetPropNativePrototypeStub
{
friend
class
ICStubSpace
;
protected
:
HeapPtrShape
globalShape_
;
ICGetName_Global
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
slot
JSObject
*
holder
Shape
*
holderShape
Shape
*
globalShape
)
;
public
:
static
ICGetName_Global
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetName_Global
&
other
)
;
HeapPtrShape
&
globalShape
(
)
{
return
globalShape_
;
}
static
size_t
offsetOfGlobalShape
(
)
{
return
offsetof
(
ICGetName_Global
globalShape_
)
;
}
}
;
class
ICGetPropNativeCompiler
:
public
ICStubCompiler
{
ICStub
*
firstMonitorStub_
;
HandleObject
obj_
;
HandleObject
holder_
;
HandlePropertyName
propName_
;
bool
isFixedSlot_
;
uint32_t
offset_
;
bool
inputDefinitelyObject_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
protected
:
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
isFixedSlot_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
inputDefinitelyObject_
)
<
<
18
)
|
(
HeapReceiverGuard
:
:
keyBits
(
obj_
)
<
<
19
)
;
}
public
:
ICGetPropNativeCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICStub
*
firstMonitorStub
HandleObject
obj
HandleObject
holder
HandlePropertyName
propName
bool
isFixedSlot
uint32_t
offset
bool
inputDefinitelyObject
=
false
)
:
ICStubCompiler
(
cx
kind
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
obj_
(
obj
)
holder_
(
holder
)
propName_
(
propName
)
isFixedSlot_
(
isFixedSlot
)
offset_
(
offset
)
inputDefinitelyObject_
(
inputDefinitelyObject
)
{
}
ICGetPropNativeStub
*
getStub
(
ICStubSpace
*
space
)
;
}
;
template
<
size_t
ProtoChainDepth
>
class
ICGetProp_NativeDoesNotExistImpl
;
class
ICGetProp_NativeDoesNotExist
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
public
:
HeapReceiverGuard
guard_
;
static
const
size_t
MAX_PROTO_CHAIN_DEPTH
=
8
;
protected
:
ICGetProp_NativeDoesNotExist
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
size_t
protoChainDepth
)
;
public
:
size_t
protoChainDepth
(
)
const
{
MOZ_ASSERT
(
extra_
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
return
extra_
;
}
template
<
size_t
ProtoChainDepth
>
ICGetProp_NativeDoesNotExistImpl
<
ProtoChainDepth
>
*
toImpl
(
)
{
MOZ_ASSERT
(
ProtoChainDepth
=
=
protoChainDepth
(
)
)
;
return
static_cast
<
ICGetProp_NativeDoesNotExistImpl
<
ProtoChainDepth
>
*
>
(
this
)
;
}
HeapReceiverGuard
&
guard
(
)
{
return
guard_
;
}
static
size_t
offsetOfGuard
(
)
{
return
offsetof
(
ICGetProp_NativeDoesNotExist
guard_
)
;
}
static
size_t
offsetOfShape
(
size_t
idx
)
;
}
;
template
<
size_t
ProtoChainDepth
>
class
ICGetProp_NativeDoesNotExistImpl
:
public
ICGetProp_NativeDoesNotExist
{
friend
class
ICStubSpace
;
public
:
static
const
size_t
MAX_PROTO_CHAIN_DEPTH
=
8
;
static
const
size_t
NumShapes
=
ProtoChainDepth
;
private
:
mozilla
:
:
Array
<
HeapPtrShape
NumShapes
>
shapes_
;
ICGetProp_NativeDoesNotExistImpl
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
Handle
<
ShapeVector
>
shapes
)
;
public
:
void
traceShapes
(
JSTracer
*
trc
)
{
for
(
int32_t
i
=
0
;
i
<
int32_t
(
NumShapes
)
;
i
+
+
)
TraceEdge
(
trc
&
shapes_
[
i
]
"
baseline
-
getpropnativedoesnotexist
-
stub
-
shape
"
)
;
}
static
size_t
offsetOfShape
(
size_t
idx
)
{
return
offsetof
(
ICGetProp_NativeDoesNotExistImpl
shapes_
)
+
(
idx
*
sizeof
(
HeapPtrShape
)
)
;
}
}
;
class
ICGetPropNativeDoesNotExistCompiler
:
public
ICStubCompiler
{
ICStub
*
firstMonitorStub_
;
RootedObject
obj_
;
size_t
protoChainDepth_
;
protected
:
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
HeapReceiverGuard
:
:
keyBits
(
obj_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
protoChainDepth_
)
<
<
19
)
;
}
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
ICGetPropNativeDoesNotExistCompiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
HandleObject
obj
size_t
protoChainDepth
)
;
template
<
size_t
ProtoChainDepth
>
ICStub
*
getStubSpecific
(
ICStubSpace
*
space
Handle
<
ShapeVector
>
shapes
)
{
ReceiverGuard
guard
(
obj_
)
;
return
newStub
<
ICGetProp_NativeDoesNotExistImpl
<
ProtoChainDepth
>
>
(
space
getStubCode
(
)
firstMonitorStub_
guard
shapes
)
;
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
;
}
;
class
ICGetProp_Unboxed
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
HeapPtrObjectGroup
group_
;
uint32_t
fieldOffset_
;
ICGetProp_Unboxed
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ObjectGroup
*
group
uint32_t
fieldOffset
)
:
ICMonitoredStub
(
ICStub
:
:
GetProp_Unboxed
stubCode
firstMonitorStub
)
group_
(
group
)
fieldOffset_
(
fieldOffset
)
{
(
void
)
fieldOffset_
;
}
public
:
HeapPtrObjectGroup
&
group
(
)
{
return
group_
;
}
static
size_t
offsetOfGroup
(
)
{
return
offsetof
(
ICGetProp_Unboxed
group_
)
;
}
static
size_t
offsetOfFieldOffset
(
)
{
return
offsetof
(
ICGetProp_Unboxed
fieldOffset_
)
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
ICStub
*
firstMonitorStub_
;
RootedObjectGroup
group_
;
uint32_t
fieldOffset_
;
JSValueType
fieldType_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
fieldType_
)
<
<
17
)
;
}
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
ObjectGroup
*
group
uint32_t
fieldOffset
JSValueType
fieldType
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_Unboxed
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
group_
(
cx
group
)
fieldOffset_
(
fieldOffset
)
fieldType_
(
fieldType
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_Unboxed
>
(
space
getStubCode
(
)
firstMonitorStub_
group_
fieldOffset_
)
;
}
}
;
}
;
static
uint32_t
SimpleTypeDescrKey
(
SimpleTypeDescr
*
descr
)
{
if
(
descr
-
>
is
<
ScalarTypeDescr
>
(
)
)
return
uint32_t
(
descr
-
>
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
)
<
<
1
;
return
(
uint32_t
(
descr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
)
<
<
1
)
|
1
;
}
class
ICGetProp_TypedObject
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
HeapPtrShape
shape_
;
uint32_t
fieldOffset_
;
ICGetProp_TypedObject
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
uint32_t
fieldOffset
)
:
ICMonitoredStub
(
ICStub
:
:
GetProp_TypedObject
stubCode
firstMonitorStub
)
shape_
(
shape
)
fieldOffset_
(
fieldOffset
)
{
(
void
)
fieldOffset_
;
}
public
:
HeapPtrShape
&
shape
(
)
{
return
shape_
;
}
static
size_t
offsetOfShape
(
)
{
return
offsetof
(
ICGetProp_TypedObject
shape_
)
;
}
static
size_t
offsetOfFieldOffset
(
)
{
return
offsetof
(
ICGetProp_TypedObject
fieldOffset_
)
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
ICStub
*
firstMonitorStub_
;
RootedShape
shape_
;
uint32_t
fieldOffset_
;
TypedThingLayout
layout_
;
Rooted
<
SimpleTypeDescr
*
>
fieldDescr_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
SimpleTypeDescrKey
(
fieldDescr_
)
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
layout_
)
<
<
25
)
;
}
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
Shape
*
shape
uint32_t
fieldOffset
SimpleTypeDescr
*
fieldDescr
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_TypedObject
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
shape_
(
cx
shape
)
fieldOffset_
(
fieldOffset
)
layout_
(
GetTypedThingLayout
(
shape
-
>
getObjectClass
(
)
)
)
fieldDescr_
(
cx
fieldDescr
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_TypedObject
>
(
space
getStubCode
(
)
firstMonitorStub_
shape_
fieldOffset_
)
;
}
}
;
}
;
class
ICGetPropCallGetter
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
protected
:
HeapReceiverGuard
receiverGuard_
;
HeapPtrObject
holder_
;
HeapPtrShape
holderShape_
;
HeapPtrFunction
getter_
;
uint32_t
pcOffset_
;
ICGetPropCallGetter
(
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
receiverGuard
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
;
public
:
HeapPtrObject
&
holder
(
)
{
return
holder_
;
}
HeapPtrShape
&
holderShape
(
)
{
return
holderShape_
;
}
HeapPtrFunction
&
getter
(
)
{
return
getter_
;
}
HeapReceiverGuard
&
receiverGuard
(
)
{
return
receiverGuard_
;
}
bool
isOwnGetter
(
)
const
{
MOZ_ASSERT
(
holder_
-
>
isNative
(
)
)
;
MOZ_ASSERT
(
holderShape_
)
;
return
receiverGuard_
.
shape
(
)
=
=
holderShape_
;
}
static
size_t
offsetOfHolder
(
)
{
return
offsetof
(
ICGetPropCallGetter
holder_
)
;
}
static
size_t
offsetOfHolderShape
(
)
{
return
offsetof
(
ICGetPropCallGetter
holderShape_
)
;
}
static
size_t
offsetOfGetter
(
)
{
return
offsetof
(
ICGetPropCallGetter
getter_
)
;
}
static
size_t
offsetOfPCOffset
(
)
{
return
offsetof
(
ICGetPropCallGetter
pcOffset_
)
;
}
static
size_t
offsetOfReceiverGuard
(
)
{
return
offsetof
(
ICGetPropCallGetter
receiverGuard_
)
;
}
class
Compiler
:
public
ICStubCompiler
{
protected
:
ICStub
*
firstMonitorStub_
;
RootedObject
receiver_
;
RootedObject
holder_
;
RootedFunction
getter_
;
uint32_t
pcOffset_
;
const
Class
*
outerClass_
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
HeapReceiverGuard
:
:
keyBits
(
receiver_
)
<
<
17
)
|
(
static_cast
<
int32_t
>
(
!
!
outerClass_
)
<
<
19
)
|
(
static_cast
<
int32_t
>
(
receiver_
!
=
holder_
)
<
<
20
)
;
}
public
:
Compiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICStub
*
firstMonitorStub
HandleObject
receiver
HandleObject
holder
HandleFunction
getter
uint32_t
pcOffset
const
Class
*
outerClass
)
:
ICStubCompiler
(
cx
kind
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
receiver_
(
cx
receiver
)
holder_
(
cx
holder
)
getter_
(
cx
getter
)
pcOffset_
(
pcOffset
)
outerClass_
(
outerClass
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
GetProp_CallScripted
|
|
kind
=
=
ICStub
:
:
GetProp_CallNative
|
|
kind
=
=
ICStub
:
:
GetProp_CallNativeGlobal
)
;
}
}
;
}
;
class
ICGetProp_CallScripted
:
public
ICGetPropCallGetter
{
friend
class
ICStubSpace
;
protected
:
ICGetProp_CallScripted
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
receiverGuard
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetPropCallGetter
(
GetProp_CallScripted
stubCode
firstMonitorStub
receiverGuard
holder
holderShape
getter
pcOffset
)
{
}
public
:
static
ICGetProp_CallScripted
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_CallScripted
&
other
)
;
class
Compiler
:
public
ICGetPropCallGetter
:
:
Compiler
{
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
HandleObject
obj
HandleObject
holder
HandleFunction
getter
uint32_t
pcOffset
)
:
ICGetPropCallGetter
:
:
Compiler
(
cx
ICStub
:
:
GetProp_CallScripted
firstMonitorStub
obj
holder
getter
pcOffset
nullptr
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
ReceiverGuard
guard
(
receiver_
)
;
Shape
*
holderShape
=
holder_
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
;
return
newStub
<
ICGetProp_CallScripted
>
(
space
getStubCode
(
)
firstMonitorStub_
guard
holder_
holderShape
getter_
pcOffset_
)
;
}
}
;
}
;
class
ICGetProp_CallNative
:
public
ICGetPropCallGetter
{
friend
class
ICStubSpace
;
protected
:
ICGetProp_CallNative
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
receiverGuard
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetPropCallGetter
(
GetProp_CallNative
stubCode
firstMonitorStub
receiverGuard
holder
holderShape
getter
pcOffset
)
{
}
public
:
static
ICGetProp_CallNative
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_CallNative
&
other
)
;
}
;
class
ICGetProp_CallNativeGlobal
:
public
ICGetPropCallGetter
{
friend
class
ICStubSpace
;
protected
:
HeapPtrShape
globalShape_
;
ICGetProp_CallNativeGlobal
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
receiverGuard
JSObject
*
holder
Shape
*
holderShape
Shape
*
globalShape
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetPropCallGetter
(
GetProp_CallNativeGlobal
stubCode
firstMonitorStub
receiverGuard
holder
holderShape
getter
pcOffset
)
globalShape_
(
globalShape
)
{
}
public
:
static
ICGetProp_CallNativeGlobal
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_CallNativeGlobal
&
other
)
;
HeapPtrShape
&
globalShape
(
)
{
return
globalShape_
;
}
static
size_t
offsetOfGlobalShape
(
)
{
return
offsetof
(
ICGetProp_CallNativeGlobal
globalShape_
)
;
}
}
;
class
ICGetPropCallNativeCompiler
:
public
ICGetPropCallGetter
:
:
Compiler
{
bool
inputDefinitelyObject_
;
protected
:
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
int32_t
baseKey
=
ICGetPropCallGetter
:
:
Compiler
:
:
getKey
(
)
;
MOZ_ASSERT
(
(
baseKey
>
>
21
)
=
=
0
)
;
return
baseKey
|
(
static_cast
<
int32_t
>
(
inputDefinitelyObject_
)
<
<
21
)
;
}
public
:
ICGetPropCallNativeCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICStub
*
firstMonitorStub
HandleObject
receiver
HandleObject
holder
HandleFunction
getter
uint32_t
pcOffset
const
Class
*
outerClass
bool
inputDefinitelyObject
=
false
)
:
ICGetPropCallGetter
:
:
Compiler
(
cx
kind
firstMonitorStub
receiver
holder
getter
pcOffset
outerClass
)
inputDefinitelyObject_
(
inputDefinitelyObject
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
;
}
;
class
ICGetPropCallDOMProxyNativeStub
:
public
ICGetPropCallGetter
{
friend
class
ICStubSpace
;
protected
:
HeapPtrShape
expandoShape_
;
ICGetPropCallDOMProxyNativeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
Shape
*
expandoShape
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
;
public
:
HeapPtrShape
&
expandoShape
(
)
{
return
expandoShape_
;
}
static
size_t
offsetOfExpandoShape
(
)
{
return
offsetof
(
ICGetPropCallDOMProxyNativeStub
expandoShape_
)
;
}
}
;
class
ICGetProp_CallDOMProxyNative
:
public
ICGetPropCallDOMProxyNativeStub
{
friend
class
ICStubSpace
;
ICGetProp_CallDOMProxyNative
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
Shape
*
expandoShape
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetPropCallDOMProxyNativeStub
(
ICStub
:
:
GetProp_CallDOMProxyNative
stubCode
firstMonitorStub
shape
expandoShape
holder
holderShape
getter
pcOffset
)
{
}
public
:
static
ICGetProp_CallDOMProxyNative
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_CallDOMProxyNative
&
other
)
;
}
;
class
ICGetProp_CallDOMProxyWithGenerationNative
:
public
ICGetPropCallDOMProxyNativeStub
{
protected
:
ExpandoAndGeneration
*
expandoAndGeneration_
;
uint32_t
generation_
;
public
:
ICGetProp_CallDOMProxyWithGenerationNative
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
ExpandoAndGeneration
*
expandoAndGeneration
uint32_t
generation
Shape
*
expandoShape
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetPropCallDOMProxyNativeStub
(
ICStub
:
:
GetProp_CallDOMProxyWithGenerationNative
stubCode
firstMonitorStub
shape
expandoShape
holder
holderShape
getter
pcOffset
)
expandoAndGeneration_
(
expandoAndGeneration
)
generation_
(
generation
)
{
}
static
ICGetProp_CallDOMProxyWithGenerationNative
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_CallDOMProxyWithGenerationNative
&
other
)
;
void
*
expandoAndGeneration
(
)
const
{
return
expandoAndGeneration_
;
}
uint32_t
generation
(
)
const
{
return
generation_
;
}
void
setGeneration
(
uint32_t
value
)
{
generation_
=
value
;
}
static
size_t
offsetOfInternalStruct
(
)
{
return
offsetof
(
ICGetProp_CallDOMProxyWithGenerationNative
expandoAndGeneration_
)
;
}
static
size_t
offsetOfGeneration
(
)
{
return
offsetof
(
ICGetProp_CallDOMProxyWithGenerationNative
generation_
)
;
}
}
;
class
ICGetPropCallDOMProxyNativeCompiler
:
public
ICStubCompiler
{
ICStub
*
firstMonitorStub_
;
Rooted
<
ProxyObject
*
>
proxy_
;
RootedObject
holder_
;
RootedFunction
getter_
;
uint32_t
pcOffset_
;
bool
generateStubCode
(
MacroAssembler
&
masm
Address
*
internalStructAddr
Address
*
generationAddr
)
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
ICGetPropCallDOMProxyNativeCompiler
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICStub
*
firstMonitorStub
Handle
<
ProxyObject
*
>
proxy
HandleObject
holder
HandleFunction
getter
uint32_t
pcOffset
)
;
ICStub
*
getStub
(
ICStubSpace
*
space
)
;
}
;
class
ICGetProp_DOMProxyShadowed
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
protected
:
HeapPtrShape
shape_
;
const
BaseProxyHandler
*
proxyHandler_
;
HeapPtrPropertyName
name_
;
uint32_t
pcOffset_
;
ICGetProp_DOMProxyShadowed
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
const
BaseProxyHandler
*
proxyHandler
PropertyName
*
name
uint32_t
pcOffset
)
;
public
:
static
ICGetProp_DOMProxyShadowed
*
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetProp_DOMProxyShadowed
&
other
)
;
HeapPtrShape
&
shape
(
)
{
return
shape_
;
}
HeapPtrPropertyName
&
name
(
)
{
return
name_
;
}
static
size_t
offsetOfShape
(
)
{
return
offsetof
(
ICGetProp_DOMProxyShadowed
shape_
)
;
}
static
size_t
offsetOfProxyHandler
(
)
{
return
offsetof
(
ICGetProp_DOMProxyShadowed
proxyHandler_
)
;
}
static
size_t
offsetOfName
(
)
{
return
offsetof
(
ICGetProp_DOMProxyShadowed
name_
)
;
}
static
size_t
offsetOfPCOffset
(
)
{
return
offsetof
(
ICGetProp_DOMProxyShadowed
pcOffset_
)
;
}
class
Compiler
:
public
ICStubCompiler
{
ICStub
*
firstMonitorStub_
;
Rooted
<
ProxyObject
*
>
proxy_
;
RootedPropertyName
name_
;
uint32_t
pcOffset_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
Handle
<
ProxyObject
*
>
proxy
HandlePropertyName
name
uint32_t
pcOffset
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_CallNative
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
proxy_
(
cx
proxy
)
name_
(
cx
name
)
pcOffset_
(
pcOffset
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
;
}
;
}
;
class
ICGetProp_ArgumentsLength
:
public
ICStub
{
friend
class
ICStubSpace
;
public
:
enum
Which
{
Mapped
Unmapped
Magic
}
;
protected
:
explicit
ICGetProp_ArgumentsLength
(
JitCode
*
stubCode
)
:
ICStub
(
ICStub
:
:
GetProp_ArgumentsLength
stubCode
)
{
}
public
:
class
Compiler
:
public
ICStubCompiler
{
protected
:
Which
which_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
virtual
int32_t
getKey
(
)
const
{
return
static_cast
<
int32_t
>
(
engine_
)
|
(
static_cast
<
int32_t
>
(
kind
)
<
<
1
)
|
(
static_cast
<
int32_t
>
(
which_
)
<
<
17
)
;
}
public
:
Compiler
(
JSContext
*
cx
Which
which
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_ArgumentsLength
Engine
:
:
Baseline
)
which_
(
which
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_ArgumentsLength
>
(
space
getStubCode
(
)
)
;
}
}
;
}
;
class
ICGetProp_ArgumentsCallee
:
public
ICMonitoredStub
{
friend
class
ICStubSpace
;
protected
:
ICGetProp_ArgumentsCallee
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
)
;
public
:
class
Compiler
:
public
ICStubCompiler
{
protected
:
ICStub
*
firstMonitorStub_
;
bool
generateStubCode
(
MacroAssembler
&
masm
)
;
public
:
Compiler
(
JSContext
*
cx
ICStub
*
firstMonitorStub
)
:
ICStubCompiler
(
cx
ICStub
:
:
GetProp_ArgumentsCallee
Engine
:
:
Baseline
)
firstMonitorStub_
(
firstMonitorStub
)
{
}
ICStub
*
getStub
(
ICStubSpace
*
space
)
{
return
newStub
<
ICGetProp_ArgumentsCallee
>
(
space
getStubCode
(
)
firstMonitorStub_
)
;
}
}
;
}
;
}
}
#
endif
