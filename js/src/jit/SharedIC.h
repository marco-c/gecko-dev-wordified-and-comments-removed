#
ifndef
jit_SharedIC_h
#
define
jit_SharedIC_h
#
include
"
gc
/
GC
.
h
"
#
include
"
jit
/
BaselineICList
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
ICState
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
SharedICRegisters
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
ReceiverGuard
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
namespace
js
{
namespace
jit
{
class
ICStub
;
class
ICFallbackStub
;
#
define
FORWARD_DECLARE_STUBS
(
kindName
)
class
IC
#
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
FORWARD_DECLARE_STUBS
)
#
undef
FORWARD_DECLARE_STUBS
#
ifdef
JS_JITSPEW
void
FallbackICSpew
(
JSContext
*
cx
ICFallbackStub
*
stub
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
3
4
)
;
void
TypeFallbackICSpew
(
JSContext
*
cx
ICTypeMonitor_Fallback
*
stub
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
3
4
)
;
#
else
#
define
FallbackICSpew
(
.
.
.
)
#
define
TypeFallbackICSpew
(
.
.
.
)
#
endif
class
ICEntry
{
private
:
ICStub
*
firstStub_
;
uint32_t
returnOffset_
;
uint32_t
pcOffset_
:
28
;
public
:
enum
Kind
{
Kind_Op
=
0
Kind_NonOp
Kind_CallVM
Kind_NonOpCallVM
Kind_WarmupCounter
Kind_StackCheck
Kind_EarlyStackCheck
Kind_DebugTrap
Kind_DebugPrologue
Kind_DebugAfterYield
Kind_DebugEpilogue
Kind_Invalid
}
;
private
:
Kind
kind_
:
4
;
void
setKind
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
<
Kind_Invalid
)
;
kind_
=
kind
;
MOZ_ASSERT
(
this
-
>
kind
(
)
=
=
kind
)
;
}
public
:
ICEntry
(
uint32_t
pcOffset
Kind
kind
)
:
firstStub_
(
nullptr
)
returnOffset_
(
)
pcOffset_
(
pcOffset
)
{
MOZ_ASSERT
(
pcOffset_
=
=
pcOffset
)
;
JS_STATIC_ASSERT
(
BaselineScript
:
:
MAX_JSSCRIPT_LENGTH
<
=
(
1u
<
<
28
)
-
1
)
;
MOZ_ASSERT
(
pcOffset
<
=
BaselineScript
:
:
MAX_JSSCRIPT_LENGTH
)
;
setKind
(
kind
)
;
}
CodeOffset
returnOffset
(
)
const
{
return
CodeOffset
(
returnOffset_
)
;
}
void
setReturnOffset
(
CodeOffset
offset
)
{
MOZ_ASSERT
(
offset
.
offset
(
)
<
=
(
size_t
)
UINT32_MAX
)
;
returnOffset_
=
(
uint32_t
)
offset
.
offset
(
)
;
}
uint32_t
pcOffset
(
)
const
{
return
pcOffset_
;
}
jsbytecode
*
pc
(
JSScript
*
script
)
const
{
return
script
-
>
offsetToPC
(
pcOffset_
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
&
0xf
)
;
}
bool
isForOp
(
)
const
{
return
kind
(
)
=
=
Kind_Op
;
}
void
setFakeKind
(
Kind
kind
)
{
MOZ_ASSERT
(
kind
!
=
Kind_Op
&
&
kind
!
=
Kind_NonOp
)
;
setKind
(
kind
)
;
}
bool
hasStub
(
)
const
{
return
firstStub_
!
=
nullptr
;
}
ICStub
*
firstStub
(
)
const
{
MOZ_ASSERT
(
hasStub
(
)
)
;
return
firstStub_
;
}
ICFallbackStub
*
fallbackStub
(
)
const
;
void
setFirstStub
(
ICStub
*
stub
)
{
firstStub_
=
stub
;
}
static
inline
size_t
offsetOfFirstStub
(
)
{
return
offsetof
(
ICEntry
firstStub_
)
;
}
inline
ICStub
*
*
addressOfFirstStub
(
)
{
return
&
firstStub_
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ICMonitoredStub
;
class
ICMonitoredFallbackStub
;
class
ICUpdatedStub
;
class
ICStubConstIterator
{
friend
class
ICStub
;
friend
class
ICFallbackStub
;
private
:
ICStub
*
currentStub_
;
public
:
explicit
ICStubConstIterator
(
ICStub
*
currentStub
)
:
currentStub_
(
currentStub
)
{
}
static
ICStubConstIterator
StartingAt
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
stub
)
;
}
static
ICStubConstIterator
End
(
ICStub
*
stub
)
{
return
ICStubConstIterator
(
nullptr
)
;
}
bool
operator
=
=
(
const
ICStubConstIterator
&
other
)
const
{
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubConstIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubConstIterator
&
operator
+
+
(
)
;
ICStubConstIterator
operator
+
+
(
int
)
{
ICStubConstIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
currentStub_
)
;
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
nullptr
;
}
}
;
class
ICStubIterator
{
friend
class
ICFallbackStub
;
private
:
ICEntry
*
icEntry_
;
ICFallbackStub
*
fallbackStub_
;
ICStub
*
previousStub_
;
ICStub
*
currentStub_
;
bool
unlinked_
;
explicit
ICStubIterator
(
ICFallbackStub
*
fallbackStub
bool
end
=
false
)
;
public
:
bool
operator
=
=
(
const
ICStubIterator
&
other
)
const
{
MOZ_ASSERT
(
icEntry_
=
=
other
.
icEntry_
)
;
MOZ_ASSERT
(
fallbackStub_
=
=
other
.
fallbackStub_
)
;
return
currentStub_
=
=
other
.
currentStub_
;
}
bool
operator
!
=
(
const
ICStubIterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
ICStubIterator
&
operator
+
+
(
)
;
ICStubIterator
operator
+
+
(
int
)
{
ICStubIterator
oldThis
(
*
this
)
;
+
+
(
*
this
)
;
return
oldThis
;
}
ICStub
*
operator
*
(
)
const
{
return
currentStub_
;
}
ICStub
*
operator
-
>
(
)
const
{
return
currentStub_
;
}
bool
atEnd
(
)
const
{
return
currentStub_
=
=
(
ICStub
*
)
fallbackStub_
;
}
void
unlink
(
JSContext
*
cx
)
;
}
;
class
ICStub
{
friend
class
ICFallbackStub
;
public
:
enum
Kind
{
INVALID
=
0
#
define
DEF_ENUM_KIND
(
kindName
)
kindName
IC_BASELINE_STUB_KIND_LIST
(
DEF_ENUM_KIND
)
#
undef
DEF_ENUM_KIND
LIMIT
}
;
static
bool
IsValidKind
(
Kind
k
)
{
return
(
k
>
INVALID
)
&
&
(
k
<
LIMIT
)
;
}
static
bool
IsCacheIRKind
(
Kind
k
)
{
return
k
=
=
CacheIR_Regular
|
|
k
=
=
CacheIR_Monitored
|
|
k
=
=
CacheIR_Updated
;
}
static
const
char
*
KindString
(
Kind
k
)
{
switch
(
k
)
{
#
define
DEF_KIND_STR
(
kindName
)
case
kindName
:
return
#
kindName
;
IC_BASELINE_STUB_KIND_LIST
(
DEF_KIND_STR
)
#
undef
DEF_KIND_STR
default
:
MOZ_CRASH
(
"
Invalid
kind
.
"
)
;
}
}
enum
Trait
{
Regular
=
0x0
Fallback
=
0x1
Monitored
=
0x2
MonitoredFallback
=
0x3
Updated
=
0x4
}
;
void
traceCode
(
JSTracer
*
trc
const
char
*
name
)
;
void
updateCode
(
JitCode
*
stubCode
)
;
void
trace
(
JSTracer
*
trc
)
;
template
<
typename
T
typename
.
.
.
Args
>
static
T
*
New
(
JSContext
*
cx
ICStubSpace
*
space
JitCode
*
code
Args
&
&
.
.
.
args
)
{
if
(
!
code
)
return
nullptr
;
T
*
result
=
space
-
>
allocate
<
T
>
(
code
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
result
)
ReportOutOfMemory
(
cx
)
;
return
result
;
}
protected
:
uint8_t
*
stubCode_
;
ICStub
*
next_
;
uint16_t
extra_
;
Trait
trait_
:
3
;
Kind
kind_
:
13
;
inline
ICStub
(
Kind
kind
JitCode
*
stubCode
)
:
stubCode_
(
stubCode
-
>
raw
(
)
)
next_
(
nullptr
)
extra_
(
0
)
trait_
(
Regular
)
kind_
(
kind
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
ICStub
(
Kind
kind
Trait
trait
JitCode
*
stubCode
)
:
stubCode_
(
stubCode
-
>
raw
(
)
)
next_
(
nullptr
)
extra_
(
0
)
trait_
(
trait
)
kind_
(
kind
)
{
MOZ_ASSERT
(
stubCode
!
=
nullptr
)
;
}
inline
Trait
trait
(
)
const
{
return
(
Trait
)
(
trait_
&
0x7
)
;
}
public
:
inline
Kind
kind
(
)
const
{
return
static_cast
<
Kind
>
(
kind_
)
;
}
inline
bool
isFallback
(
)
const
{
return
trait
(
)
=
=
Fallback
|
|
trait
(
)
=
=
MonitoredFallback
;
}
inline
bool
isMonitored
(
)
const
{
return
trait
(
)
=
=
Monitored
;
}
inline
bool
isUpdated
(
)
const
{
return
trait
(
)
=
=
Updated
;
}
inline
bool
isMonitoredFallback
(
)
const
{
return
trait
(
)
=
=
MonitoredFallback
;
}
inline
const
ICFallbackStub
*
toFallbackStub
(
)
const
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
const
ICFallbackStub
*
>
(
this
)
;
}
inline
ICFallbackStub
*
toFallbackStub
(
)
{
MOZ_ASSERT
(
isFallback
(
)
)
;
return
reinterpret_cast
<
ICFallbackStub
*
>
(
this
)
;
}
inline
const
ICMonitoredStub
*
toMonitoredStub
(
)
const
{
MOZ_ASSERT
(
isMonitored
(
)
)
;
return
reinterpret_cast
<
const
ICMonitoredStub
*
>
(
this
)
;
}
inline
ICMonitoredStub
*
toMonitoredStub
(
)
{
MOZ_ASSERT
(
isMonitored
(
)
)
;
return
reinterpret_cast
<
ICMonitoredStub
*
>
(
this
)
;
}
inline
const
ICMonitoredFallbackStub
*
toMonitoredFallbackStub
(
)
const
{
MOZ_ASSERT
(
isMonitoredFallback
(
)
)
;
return
reinterpret_cast
<
const
ICMonitoredFallbackStub
*
>
(
this
)
;
}
inline
ICMonitoredFallbackStub
*
toMonitoredFallbackStub
(
)
{
MOZ_ASSERT
(
isMonitoredFallback
(
)
)
;
return
reinterpret_cast
<
ICMonitoredFallbackStub
*
>
(
this
)
;
}
inline
const
ICUpdatedStub
*
toUpdatedStub
(
)
const
{
MOZ_ASSERT
(
isUpdated
(
)
)
;
return
reinterpret_cast
<
const
ICUpdatedStub
*
>
(
this
)
;
}
inline
ICUpdatedStub
*
toUpdatedStub
(
)
{
MOZ_ASSERT
(
isUpdated
(
)
)
;
return
reinterpret_cast
<
ICUpdatedStub
*
>
(
this
)
;
}
#
define
KIND_METHODS
(
kindName
)
\
inline
bool
is
#
#
kindName
(
)
const
{
return
kind
(
)
=
=
kindName
;
}
\
inline
const
IC
#
#
kindName
*
to
#
#
kindName
(
)
const
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
const
IC
#
#
kindName
*
>
(
this
)
;
\
}
\
inline
IC
#
#
kindName
*
to
#
#
kindName
(
)
{
\
MOZ_ASSERT
(
is
#
#
kindName
(
)
)
;
\
return
reinterpret_cast
<
IC
#
#
kindName
*
>
(
this
)
;
\
}
IC_BASELINE_STUB_KIND_LIST
(
KIND_METHODS
)
#
undef
KIND_METHODS
inline
ICStub
*
next
(
)
const
{
return
next_
;
}
inline
bool
hasNext
(
)
const
{
return
next_
!
=
nullptr
;
}
inline
void
setNext
(
ICStub
*
stub
)
{
next_
=
stub
;
}
inline
ICStub
*
*
addressOfNext
(
)
{
return
&
next_
;
}
inline
JitCode
*
jitCode
(
)
{
return
JitCode
:
:
FromExecutable
(
stubCode_
)
;
}
inline
uint8_t
*
rawStubCode
(
)
const
{
return
stubCode_
;
}
inline
ICFallbackStub
*
getChainFallback
(
)
{
ICStub
*
lastStub
=
this
;
while
(
lastStub
-
>
next_
)
lastStub
=
lastStub
-
>
next_
;
MOZ_ASSERT
(
lastStub
-
>
isFallback
(
)
)
;
return
lastStub
-
>
toFallbackStub
(
)
;
}
inline
ICStubConstIterator
beginHere
(
)
{
return
ICStubConstIterator
:
:
StartingAt
(
this
)
;
}
static
inline
size_t
offsetOfNext
(
)
{
return
offsetof
(
ICStub
next_
)
;
}
static
inline
size_t
offsetOfStubCode
(
)
{
return
offsetof
(
ICStub
stubCode_
)
;
}
static
inline
size_t
offsetOfExtra
(
)
{
return
offsetof
(
ICStub
extra_
)
;
}
static
bool
NonCacheIRStubMakesGCCalls
(
Kind
kind
)
;
bool
makesGCCalls
(
)
const
;
bool
allocatedInFallbackSpace
(
)
const
{
MOZ_ASSERT
(
next
(
)
)
;
return
makesGCCalls
(
)
;
}
}
;
}
}
#
endif
