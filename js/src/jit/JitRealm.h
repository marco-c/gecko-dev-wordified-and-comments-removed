#
ifndef
jit_JitRealm_h
#
define
jit_JitRealm_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
namespace
jit
{
class
JitCode
;
struct
IcStubCodeMapGCPolicy
{
static
bool
traceWeak
(
JSTracer
*
trc
uint32_t
*
WeakHeapPtr
<
JitCode
*
>
*
value
)
{
return
TraceWeakEdge
(
trc
value
"
traceWeak
"
)
;
}
}
;
class
JitRealm
{
friend
class
JitActivation
;
using
ICStubCodeMap
=
GCHashMap
<
uint32_t
WeakHeapPtr
<
JitCode
*
>
DefaultHasher
<
uint32_t
>
ZoneAllocPolicy
IcStubCodeMapGCPolicy
>
;
ICStubCodeMap
*
stubCodes_
;
enum
StubIndex
:
uint32_t
{
StringConcat
=
0
RegExpMatcher
RegExpSearcher
RegExpTester
Count
}
;
mozilla
:
:
EnumeratedArray
<
StubIndex
StubIndex
:
:
Count
WeakHeapPtr
<
JitCode
*
>
>
stubs_
;
gc
:
:
InitialHeap
initialStringHeap
;
JitCode
*
generateStringConcatStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpMatcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpSearcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpTesterStub
(
JSContext
*
cx
)
;
JitCode
*
getStubNoBarrier
(
StubIndex
stub
uint32_t
*
requiredBarriersOut
)
const
{
MOZ_ASSERT
(
CurrentThreadIsIonCompiling
(
)
)
;
*
requiredBarriersOut
|
=
1
<
<
uint32_t
(
stub
)
;
return
stubs_
[
stub
]
.
unbarrieredGet
(
)
;
}
public
:
JitCode
*
getStubCode
(
uint32_t
key
)
{
ICStubCodeMap
:
:
Ptr
p
=
stubCodes_
-
>
lookup
(
key
)
;
if
(
p
)
{
return
p
-
>
value
(
)
;
}
return
nullptr
;
}
[
[
nodiscard
]
]
bool
putStubCode
(
JSContext
*
cx
uint32_t
key
Handle
<
JitCode
*
>
stubCode
)
{
MOZ_ASSERT
(
stubCode
)
;
if
(
!
stubCodes_
-
>
putNew
(
key
stubCode
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
JitRealm
(
)
;
~
JitRealm
(
)
;
[
[
nodiscard
]
]
bool
initialize
(
JSContext
*
cx
bool
zoneHasNurseryStrings
)
;
[
[
nodiscard
]
]
bool
ensureIonStubsExist
(
JSContext
*
cx
)
{
if
(
stubs_
[
StringConcat
]
)
{
return
true
;
}
stubs_
[
StringConcat
]
=
generateStringConcatStub
(
cx
)
;
return
stubs_
[
StringConcat
]
;
}
void
traceWeak
(
JSTracer
*
trc
JS
:
:
Realm
*
realm
)
;
void
discardStubs
(
)
{
for
(
WeakHeapPtr
<
JitCode
*
>
&
stubRef
:
stubs_
)
{
stubRef
=
nullptr
;
}
}
bool
hasStubs
(
)
const
{
for
(
const
WeakHeapPtr
<
JitCode
*
>
&
stubRef
:
stubs_
)
{
if
(
stubRef
)
{
return
true
;
}
}
return
false
;
}
void
setStringsCanBeInNursery
(
bool
allow
)
{
MOZ_ASSERT
(
!
hasStubs
(
)
)
;
initialStringHeap
=
allow
?
gc
:
:
DefaultHeap
:
gc
:
:
TenuredHeap
;
}
JitCode
*
stringConcatStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
StringConcat
requiredBarriersOut
)
;
}
JitCode
*
regExpMatcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpMatcher
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpMatcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpMatcher
]
)
{
return
true
;
}
stubs_
[
RegExpMatcher
]
=
generateRegExpMatcherStub
(
cx
)
;
return
stubs_
[
RegExpMatcher
]
;
}
JitCode
*
regExpSearcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpSearcher
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpSearcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpSearcher
]
)
{
return
true
;
}
stubs_
[
RegExpSearcher
]
=
generateRegExpSearcherStub
(
cx
)
;
return
stubs_
[
RegExpSearcher
]
;
}
JitCode
*
regExpTesterStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpTester
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpTesterStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpTester
]
)
{
return
true
;
}
stubs_
[
RegExpTester
]
=
generateRegExpTesterStub
(
cx
)
;
return
stubs_
[
RegExpTester
]
;
}
void
performStubReadBarriers
(
uint32_t
stubsToBarrier
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
}
}
#
endif
