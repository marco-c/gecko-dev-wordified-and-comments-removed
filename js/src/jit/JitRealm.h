#
ifndef
jit_JitRealm_h
#
define
jit_JitRealm_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
utility
>
#
include
"
builtin
/
TypedObject
.
h
"
#
include
"
jit
/
BaselineICList
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
enum
class
CacheKind
:
uint8_t
;
class
CacheIRStubInfo
;
enum
class
ICStubEngine
:
uint8_t
{
Baseline
=
0
IonIC
}
;
struct
CacheIRStubKey
:
public
DefaultHasher
<
CacheIRStubKey
>
{
struct
Lookup
{
CacheKind
kind
;
ICStubEngine
engine
;
const
uint8_t
*
code
;
uint32_t
length
;
Lookup
(
CacheKind
kind
ICStubEngine
engine
const
uint8_t
*
code
uint32_t
length
)
:
kind
(
kind
)
engine
(
engine
)
code
(
code
)
length
(
length
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
CacheIRStubKey
&
entry
const
Lookup
&
l
)
;
UniquePtr
<
CacheIRStubInfo
JS
:
:
FreePolicy
>
stubInfo
;
explicit
CacheIRStubKey
(
CacheIRStubInfo
*
info
)
:
stubInfo
(
info
)
{
}
CacheIRStubKey
(
CacheIRStubKey
&
&
other
)
:
stubInfo
(
std
:
:
move
(
other
.
stubInfo
)
)
{
}
void
operator
=
(
CacheIRStubKey
&
&
other
)
{
stubInfo
=
std
:
:
move
(
other
.
stubInfo
)
;
}
}
;
template
<
typename
Key
>
struct
IcStubCodeMapGCPolicy
{
static
bool
traceWeak
(
JSTracer
*
trc
Key
*
WeakHeapPtrJitCode
*
value
)
{
return
TraceWeakEdge
(
trc
value
"
traceWeak
"
)
;
}
}
;
class
JitZone
{
OptimizedICStubSpace
optimizedStubSpace_
;
using
IonCacheIRStubInfoSet
=
HashSet
<
CacheIRStubKey
CacheIRStubKey
SystemAllocPolicy
>
;
IonCacheIRStubInfoSet
ionCacheIRStubInfoSet_
;
using
BaselineCacheIRStubCodeMap
=
GCHashMap
<
CacheIRStubKey
WeakHeapPtrJitCode
CacheIRStubKey
SystemAllocPolicy
IcStubCodeMapGCPolicy
<
CacheIRStubKey
>
>
;
BaselineCacheIRStubCodeMap
baselineCacheIRStubCodes_
;
MainThreadData
<
ExecutableAllocator
>
execAlloc_
;
public
:
void
traceWeak
(
JSTracer
*
trc
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
CodeSizes
*
code
size_t
*
jitZone
size_t
*
baselineStubsOptimized
)
const
;
OptimizedICStubSpace
*
optimizedStubSpace
(
)
{
return
&
optimizedStubSpace_
;
}
JitCode
*
getBaselineCacheIRStubCode
(
const
CacheIRStubKey
:
:
Lookup
&
key
CacheIRStubInfo
*
*
stubInfo
)
{
auto
p
=
baselineCacheIRStubCodes_
.
lookup
(
key
)
;
if
(
p
)
{
*
stubInfo
=
p
-
>
key
(
)
.
stubInfo
.
get
(
)
;
return
p
-
>
value
(
)
;
}
*
stubInfo
=
nullptr
;
return
nullptr
;
}
MOZ_MUST_USE
bool
putBaselineCacheIRStubCode
(
const
CacheIRStubKey
:
:
Lookup
&
lookup
CacheIRStubKey
&
key
JitCode
*
stubCode
)
{
auto
p
=
baselineCacheIRStubCodes_
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
)
;
return
baselineCacheIRStubCodes_
.
add
(
p
std
:
:
move
(
key
)
stubCode
)
;
}
CacheIRStubInfo
*
getIonCacheIRStubInfo
(
const
CacheIRStubKey
:
:
Lookup
&
key
)
{
IonCacheIRStubInfoSet
:
:
Ptr
p
=
ionCacheIRStubInfoSet_
.
lookup
(
key
)
;
return
p
?
p
-
>
stubInfo
.
get
(
)
:
nullptr
;
}
MOZ_MUST_USE
bool
putIonCacheIRStubInfo
(
const
CacheIRStubKey
:
:
Lookup
&
lookup
CacheIRStubKey
&
key
)
{
IonCacheIRStubInfoSet
:
:
AddPtr
p
=
ionCacheIRStubInfoSet_
.
lookupForAdd
(
lookup
)
;
MOZ_ASSERT
(
!
p
)
;
return
ionCacheIRStubInfoSet_
.
add
(
p
std
:
:
move
(
key
)
)
;
}
void
purgeIonCacheIRStubInfo
(
)
{
ionCacheIRStubInfoSet_
.
clearAndCompact
(
)
;
}
ExecutableAllocator
&
execAlloc
(
)
{
return
execAlloc_
.
ref
(
)
;
}
const
ExecutableAllocator
&
execAlloc
(
)
const
{
return
execAlloc_
.
ref
(
)
;
}
}
;
class
JitRealm
{
friend
class
JitActivation
;
using
ICStubCodeMap
=
GCHashMap
<
uint32_t
WeakHeapPtrJitCode
DefaultHasher
<
uint32_t
>
ZoneAllocPolicy
IcStubCodeMapGCPolicy
<
uint32_t
>
>
;
ICStubCodeMap
*
stubCodes_
;
enum
StubIndex
:
uint32_t
{
StringConcat
=
0
RegExpMatcher
RegExpSearcher
RegExpTester
Count
}
;
mozilla
:
:
EnumeratedArray
<
StubIndex
StubIndex
:
:
Count
WeakHeapPtrJitCode
>
stubs_
;
bool
stringsCanBeInNursery
;
JitCode
*
generateStringConcatStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpMatcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpSearcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpTesterStub
(
JSContext
*
cx
)
;
JitCode
*
getStubNoBarrier
(
StubIndex
stub
uint32_t
*
requiredBarriersOut
)
const
{
MOZ_ASSERT
(
CurrentThreadIsIonCompiling
(
)
)
;
*
requiredBarriersOut
|
=
1
<
<
uint32_t
(
stub
)
;
return
stubs_
[
stub
]
.
unbarrieredGet
(
)
;
}
public
:
JitCode
*
getStubCode
(
uint32_t
key
)
{
ICStubCodeMap
:
:
Ptr
p
=
stubCodes_
-
>
lookup
(
key
)
;
if
(
p
)
{
return
p
-
>
value
(
)
;
}
return
nullptr
;
}
MOZ_MUST_USE
bool
putStubCode
(
JSContext
*
cx
uint32_t
key
Handle
<
JitCode
*
>
stubCode
)
{
MOZ_ASSERT
(
stubCode
)
;
if
(
!
stubCodes_
-
>
putNew
(
key
stubCode
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
JitRealm
(
)
;
~
JitRealm
(
)
;
MOZ_MUST_USE
bool
initialize
(
JSContext
*
cx
bool
zoneHasNurseryStrings
)
;
MOZ_MUST_USE
bool
ensureIonStubsExist
(
JSContext
*
cx
)
{
if
(
stubs_
[
StringConcat
]
)
{
return
true
;
}
stubs_
[
StringConcat
]
=
generateStringConcatStub
(
cx
)
;
return
stubs_
[
StringConcat
]
;
}
void
traceWeak
(
JSTracer
*
trc
JS
:
:
Realm
*
realm
)
;
void
discardStubs
(
)
{
for
(
WeakHeapPtrJitCode
&
stubRef
:
stubs_
)
{
stubRef
=
nullptr
;
}
}
bool
hasStubs
(
)
const
{
for
(
const
WeakHeapPtrJitCode
&
stubRef
:
stubs_
)
{
if
(
stubRef
)
{
return
true
;
}
}
return
false
;
}
void
setStringsCanBeInNursery
(
bool
allow
)
{
MOZ_ASSERT
(
!
hasStubs
(
)
)
;
stringsCanBeInNursery
=
allow
;
}
JitCode
*
stringConcatStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
StringConcat
requiredBarriersOut
)
;
}
JitCode
*
regExpMatcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpMatcher
requiredBarriersOut
)
;
}
MOZ_MUST_USE
bool
ensureRegExpMatcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpMatcher
]
)
{
return
true
;
}
stubs_
[
RegExpMatcher
]
=
generateRegExpMatcherStub
(
cx
)
;
return
stubs_
[
RegExpMatcher
]
;
}
JitCode
*
regExpSearcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpSearcher
requiredBarriersOut
)
;
}
MOZ_MUST_USE
bool
ensureRegExpSearcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpSearcher
]
)
{
return
true
;
}
stubs_
[
RegExpSearcher
]
=
generateRegExpSearcherStub
(
cx
)
;
return
stubs_
[
RegExpSearcher
]
;
}
JitCode
*
regExpTesterStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpTester
requiredBarriersOut
)
;
}
MOZ_MUST_USE
bool
ensureRegExpTesterStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpTester
]
)
{
return
true
;
}
stubs_
[
RegExpTester
]
=
generateRegExpTesterStub
(
cx
)
;
return
stubs_
[
RegExpTester
]
;
}
void
performStubReadBarriers
(
uint32_t
stubsToBarrier
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
void
InvalidateAll
(
JSFreeOp
*
fop
JS
:
:
Zone
*
zone
)
;
void
FinishInvalidation
(
JSFreeOp
*
fop
JSScript
*
script
)
;
}
}
#
endif
