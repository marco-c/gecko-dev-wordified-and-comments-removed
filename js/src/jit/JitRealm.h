#
ifndef
jit_JitRealm_h
#
define
jit_JitRealm_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
MOZ_COLD
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
namespace
jit
{
class
JitCode
;
class
JitRealm
{
friend
class
JitActivation
;
enum
StubIndex
:
uint32_t
{
StringConcat
=
0
RegExpMatcher
RegExpSearcher
RegExpExecMatch
RegExpExecTest
Count
}
;
mozilla
:
:
EnumeratedArray
<
StubIndex
StubIndex
:
:
Count
WeakHeapPtr
<
JitCode
*
>
>
stubs_
;
gc
:
:
InitialHeap
initialStringHeap
;
JitCode
*
generateStringConcatStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpMatcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpSearcherStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpExecMatchStub
(
JSContext
*
cx
)
;
JitCode
*
generateRegExpExecTestStub
(
JSContext
*
cx
)
;
JitCode
*
getStubNoBarrier
(
StubIndex
stub
uint32_t
*
requiredBarriersOut
)
const
{
MOZ_ASSERT
(
CurrentThreadIsIonCompiling
(
)
)
;
*
requiredBarriersOut
|
=
1
<
<
uint32_t
(
stub
)
;
return
stubs_
[
stub
]
.
unbarrieredGet
(
)
;
}
public
:
JitRealm
(
)
;
void
initialize
(
bool
zoneHasNurseryStrings
)
;
[
[
nodiscard
]
]
bool
ensureIonStubsExist
(
JSContext
*
cx
)
{
if
(
stubs_
[
StringConcat
]
)
{
return
true
;
}
stubs_
[
StringConcat
]
=
generateStringConcatStub
(
cx
)
;
return
stubs_
[
StringConcat
]
;
}
void
traceWeak
(
JSTracer
*
trc
JS
:
:
Realm
*
realm
)
;
void
discardStubs
(
)
{
for
(
WeakHeapPtr
<
JitCode
*
>
&
stubRef
:
stubs_
)
{
stubRef
=
nullptr
;
}
}
bool
hasStubs
(
)
const
{
for
(
const
WeakHeapPtr
<
JitCode
*
>
&
stubRef
:
stubs_
)
{
if
(
stubRef
)
{
return
true
;
}
}
return
false
;
}
void
setStringsCanBeInNursery
(
bool
allow
)
{
MOZ_ASSERT
(
!
hasStubs
(
)
)
;
initialStringHeap
=
allow
?
gc
:
:
DefaultHeap
:
gc
:
:
TenuredHeap
;
}
JitCode
*
stringConcatStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
StringConcat
requiredBarriersOut
)
;
}
JitCode
*
regExpMatcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpMatcher
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpMatcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpMatcher
]
)
{
return
true
;
}
stubs_
[
RegExpMatcher
]
=
generateRegExpMatcherStub
(
cx
)
;
return
stubs_
[
RegExpMatcher
]
;
}
JitCode
*
regExpSearcherStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpSearcher
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpSearcherStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpSearcher
]
)
{
return
true
;
}
stubs_
[
RegExpSearcher
]
=
generateRegExpSearcherStub
(
cx
)
;
return
stubs_
[
RegExpSearcher
]
;
}
JitCode
*
regExpExecMatchStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpExecMatch
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpExecMatchStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpExecMatch
]
)
{
return
true
;
}
stubs_
[
RegExpExecMatch
]
=
generateRegExpExecMatchStub
(
cx
)
;
return
stubs_
[
RegExpExecMatch
]
;
}
JitCode
*
regExpExecTestStubNoBarrier
(
uint32_t
*
requiredBarriersOut
)
const
{
return
getStubNoBarrier
(
RegExpExecTest
requiredBarriersOut
)
;
}
[
[
nodiscard
]
]
bool
ensureRegExpExecTestStubExists
(
JSContext
*
cx
)
{
if
(
stubs_
[
RegExpExecTest
]
)
{
return
true
;
}
stubs_
[
RegExpExecTest
]
=
generateRegExpExecTestStub
(
cx
)
;
return
stubs_
[
RegExpExecTest
]
;
}
void
performStubReadBarriers
(
uint32_t
stubsToBarrier
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
}
}
#
endif
