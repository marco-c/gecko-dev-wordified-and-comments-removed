#
include
"
jit
/
IonOptimizationLevels
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitHints
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
namespace
js
{
namespace
jit
{
uint32_t
OptimizationInfo
:
:
compilerWarmUpThreshold
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
pc
=
=
nullptr
|
|
pc
=
=
script
-
>
code
(
)
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
MOZ_ASSERT_IF
(
pc
&
&
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
pc
>
script
-
>
code
(
)
)
;
uint32_t
warmUpThreshold
=
baseCompilerWarmUpThreshold
(
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
hasJitHintsMap
(
)
)
{
JitHintsMap
*
jitHints
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getJitHintsMap
(
)
;
uint32_t
hintThreshold
;
if
(
jitHints
-
>
getIonThresholdHint
(
script
hintThreshold
)
)
{
warmUpThreshold
=
hintThreshold
;
}
}
if
(
pc
=
=
script
-
>
code
(
)
)
{
pc
=
nullptr
;
}
if
(
script
-
>
length
(
)
>
JitOptions
.
ionMaxScriptSizeMainThread
)
{
warmUpThreshold
*
=
(
script
-
>
length
(
)
/
double
(
JitOptions
.
ionMaxScriptSizeMainThread
)
)
;
}
uint32_t
numLocalsAndArgs
=
NumLocalsAndArgs
(
script
)
;
if
(
numLocalsAndArgs
>
JitOptions
.
ionMaxLocalsAndArgsMainThread
)
{
warmUpThreshold
*
=
(
numLocalsAndArgs
/
double
(
JitOptions
.
ionMaxLocalsAndArgsMainThread
)
)
;
}
if
(
!
pc
|
|
JitOptions
.
eagerIonCompilation
(
)
)
{
return
warmUpThreshold
;
}
uint32_t
loopDepth
=
LoopHeadDepthHint
(
pc
)
;
MOZ_ASSERT
(
loopDepth
>
0
)
;
return
warmUpThreshold
+
loopDepth
*
(
baseCompilerWarmUpThreshold
(
)
/
10
)
;
}
uint32_t
OptimizationInfo
:
:
recompileWarmUpThreshold
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
const
{
MOZ_ASSERT
(
pc
=
=
script
-
>
code
(
)
|
|
JSOp
(
*
pc
)
=
=
JSOp
:
:
LoopHead
)
;
uint32_t
threshold
=
compilerWarmUpThreshold
(
cx
script
pc
)
;
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
LoopHead
|
|
JitOptions
.
eagerIonCompilation
(
)
)
{
return
threshold
;
}
uint32_t
loopDepth
=
LoopHeadDepthHint
(
pc
)
;
MOZ_ASSERT
(
loopDepth
>
0
)
;
return
threshold
+
loopDepth
*
(
baseCompilerWarmUpThreshold
(
)
/
10
)
;
}
OptimizationLevel
OptimizationLevelInfo
:
:
levelForScript
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
const
{
const
OptimizationInfo
*
info
=
get
(
OptimizationLevel
:
:
Normal
)
;
if
(
script
-
>
getWarmUpCount
(
)
<
info
-
>
compilerWarmUpThreshold
(
cx
script
pc
)
)
{
return
OptimizationLevel
:
:
DontCompile
;
}
return
OptimizationLevel
:
:
Normal
;
}
}
}
