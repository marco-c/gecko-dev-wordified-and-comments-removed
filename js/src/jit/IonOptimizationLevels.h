#
ifndef
jit_IonOptimizationLevels_h
#
define
jit_IonOptimizationLevels_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
jsbytecode
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
jit
{
enum
class
OptimizationLevel
:
uint8_t
{
Normal
Wasm
Count
DontCompile
}
;
#
ifdef
JS_JITSPEW
inline
const
char
*
OptimizationLevelString
(
OptimizationLevel
level
)
{
switch
(
level
)
{
case
OptimizationLevel
:
:
DontCompile
:
return
"
Optimization_DontCompile
"
;
case
OptimizationLevel
:
:
Normal
:
return
"
Optimization_Normal
"
;
case
OptimizationLevel
:
:
Wasm
:
return
"
Optimization_Wasm
"
;
case
OptimizationLevel
:
:
Count
:
;
}
MOZ_CRASH
(
"
Invalid
OptimizationLevel
"
)
;
}
#
endif
class
OptimizationInfo
{
public
:
OptimizationLevel
level_
;
bool
eaa_
;
bool
ama_
;
bool
edgeCaseAnalysis_
;
bool
eliminateRedundantChecks_
;
bool
inlineInterpreted_
;
bool
inlineNative_
;
bool
eagerSimdUnbox_
;
bool
gvn_
;
bool
licm_
;
bool
rangeAnalysis_
;
bool
loopUnrolling_
;
bool
reordering_
;
bool
autoTruncate_
;
bool
sincos_
;
bool
sink_
;
IonRegisterAllocator
registerAllocator_
;
uint32_t
inlineMaxBytecodePerCallSiteOffThread_
;
uint32_t
inlineMaxBytecodePerCallSiteMainThread_
;
uint16_t
inlineMaxCalleeInlinedBytecodeLength_
;
uint32_t
inlineMaxTotalBytecodeLength_
;
uint32_t
inliningMaxCallerBytecodeLength_
;
uint32_t
maxInlineDepth_
;
bool
scalarReplacement_
;
uint32_t
smallFunctionMaxInlineDepth_
;
uint32_t
compilerWarmUpThreshold_
;
static
const
uint32_t
CompilerWarmupThreshold
=
1000
;
uint32_t
compilerSmallFunctionWarmUpThreshold_
;
static
const
uint32_t
CompilerSmallFunctionWarmupThreshold
=
100
;
double
inliningWarmUpThresholdFactor_
;
uint32_t
inliningRecompileThresholdFactor_
;
OptimizationInfo
(
)
{
}
void
initNormalOptimizationInfo
(
)
;
void
initWasmOptimizationInfo
(
)
;
OptimizationLevel
level
(
)
const
{
return
level_
;
}
bool
inlineInterpreted
(
)
const
{
return
inlineInterpreted_
&
&
!
JitOptions
.
disableInlining
;
}
bool
inlineNative
(
)
const
{
return
inlineNative_
&
&
!
JitOptions
.
disableInlining
;
}
uint32_t
compilerWarmUpThreshold
(
JSScript
*
script
jsbytecode
*
pc
=
nullptr
)
const
;
bool
eagerSimdUnboxEnabled
(
)
const
{
return
eagerSimdUnbox_
&
&
!
JitOptions
.
disableEagerSimdUnbox
;
}
bool
gvnEnabled
(
)
const
{
return
gvn_
&
&
!
JitOptions
.
disableGvn
;
}
bool
licmEnabled
(
)
const
{
return
licm_
&
&
!
JitOptions
.
disableLicm
;
}
bool
rangeAnalysisEnabled
(
)
const
{
return
rangeAnalysis_
&
&
!
JitOptions
.
disableRangeAnalysis
;
}
bool
loopUnrollingEnabled
(
)
const
{
return
loopUnrolling_
&
&
!
JitOptions
.
disableLoopUnrolling
;
}
bool
instructionReorderingEnabled
(
)
const
{
return
reordering_
&
&
!
JitOptions
.
disableInstructionReordering
;
}
bool
autoTruncateEnabled
(
)
const
{
return
autoTruncate_
&
&
rangeAnalysisEnabled
(
)
;
}
bool
sincosEnabled
(
)
const
{
return
sincos_
&
&
!
JitOptions
.
disableSincos
;
}
bool
sinkEnabled
(
)
const
{
return
sink_
&
&
!
JitOptions
.
disableSink
;
}
bool
eaaEnabled
(
)
const
{
return
eaa_
&
&
!
JitOptions
.
disableEaa
;
}
bool
amaEnabled
(
)
const
{
return
ama_
&
&
!
JitOptions
.
disableAma
;
}
bool
edgeCaseAnalysisEnabled
(
)
const
{
return
edgeCaseAnalysis_
&
&
!
JitOptions
.
disableEdgeCaseAnalysis
;
}
bool
eliminateRedundantChecksEnabled
(
)
const
{
return
eliminateRedundantChecks_
;
}
bool
flowAliasAnalysisEnabled
(
)
const
{
return
!
JitOptions
.
disableFlowAA
;
}
IonRegisterAllocator
registerAllocator
(
)
const
{
if
(
JitOptions
.
forcedRegisterAllocator
.
isSome
(
)
)
return
JitOptions
.
forcedRegisterAllocator
.
ref
(
)
;
return
registerAllocator_
;
}
bool
scalarReplacementEnabled
(
)
const
{
return
scalarReplacement_
&
&
!
JitOptions
.
disableScalarReplacement
;
}
uint32_t
smallFunctionMaxInlineDepth
(
)
const
{
return
smallFunctionMaxInlineDepth_
;
}
bool
isSmallFunction
(
JSScript
*
script
)
const
;
uint32_t
maxInlineDepth
(
)
const
{
return
maxInlineDepth_
;
}
uint32_t
inlineMaxBytecodePerCallSite
(
bool
offThread
)
const
{
return
(
offThread
|
|
!
JitOptions
.
limitScriptSize
)
?
inlineMaxBytecodePerCallSiteOffThread_
:
inlineMaxBytecodePerCallSiteMainThread_
;
}
uint16_t
inlineMaxCalleeInlinedBytecodeLength
(
)
const
{
return
inlineMaxCalleeInlinedBytecodeLength_
;
}
uint32_t
inlineMaxTotalBytecodeLength
(
)
const
{
return
inlineMaxTotalBytecodeLength_
;
}
uint32_t
inliningMaxCallerBytecodeLength
(
)
const
{
return
inliningMaxCallerBytecodeLength_
;
}
uint32_t
inliningWarmUpThreshold
(
)
const
{
uint32_t
compilerWarmUpThreshold
=
compilerWarmUpThreshold_
;
if
(
JitOptions
.
forcedDefaultIonWarmUpThreshold
.
isSome
(
)
)
compilerWarmUpThreshold
=
JitOptions
.
forcedDefaultIonWarmUpThreshold
.
ref
(
)
;
return
compilerWarmUpThreshold
*
inliningWarmUpThresholdFactor_
;
}
uint32_t
inliningRecompileThreshold
(
)
const
{
return
inliningWarmUpThreshold
(
)
*
inliningRecompileThresholdFactor_
;
}
}
;
class
OptimizationLevelInfo
{
private
:
mozilla
:
:
EnumeratedArray
<
OptimizationLevel
OptimizationLevel
:
:
Count
OptimizationInfo
>
infos_
;
public
:
OptimizationLevelInfo
(
)
;
const
OptimizationInfo
*
get
(
OptimizationLevel
level
)
const
{
return
&
infos_
[
level
]
;
}
OptimizationLevel
nextLevel
(
OptimizationLevel
level
)
const
;
OptimizationLevel
firstLevel
(
)
const
;
bool
isLastLevel
(
OptimizationLevel
level
)
const
;
OptimizationLevel
levelForScript
(
JSScript
*
script
jsbytecode
*
pc
=
nullptr
)
const
;
}
;
extern
OptimizationLevelInfo
IonOptimizations
;
}
}
#
endif
