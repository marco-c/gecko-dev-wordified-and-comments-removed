#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jslibmath
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
builtin
/
SIMD
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
BaselineCacheIRCompiler
.
h
"
#
include
"
jit
/
BaselineDebugModeOSR
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
ifdef
JS_ION_PERF
#
include
"
jit
/
PerfSpewer
.
h
"
#
endif
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
jsboolinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
mozilla
:
:
DebugOnly
;
namespace
js
{
namespace
jit
{
struct
IonOsrTempData
{
void
*
jitcode
;
uint8_t
*
baselineFrame
;
}
;
static
IonOsrTempData
*
PrepareOsrTempData
(
JSContext
*
cx
ICWarmUpCounter_Fallback
*
stub
BaselineFrame
*
frame
HandleScript
script
jsbytecode
*
pc
void
*
jitcode
)
{
size_t
numLocalsAndStackVals
=
frame
-
>
numValueSlots
(
)
;
size_t
frameSpace
=
sizeof
(
BaselineFrame
)
+
sizeof
(
Value
)
*
numLocalsAndStackVals
;
size_t
ionOsrTempDataSpace
=
sizeof
(
IonOsrTempData
)
;
size_t
totalSpace
=
AlignBytes
(
frameSpace
sizeof
(
Value
)
)
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
IonOsrTempData
*
info
=
(
IonOsrTempData
*
)
cx
-
>
allocateOsrTempData
(
totalSpace
)
;
if
(
!
info
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
memset
(
info
0
totalSpace
)
;
info
-
>
jitcode
=
jitcode
;
uint8_t
*
frameStart
=
(
uint8_t
*
)
info
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
info
-
>
baselineFrame
=
frameStart
+
frameSpace
;
memcpy
(
frameStart
(
uint8_t
*
)
frame
-
numLocalsAndStackVals
*
sizeof
(
Value
)
frameSpace
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Allocated
IonOsrTempData
at
%
p
"
(
void
*
)
info
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Jitcode
is
%
p
"
info
-
>
jitcode
)
;
return
info
;
}
static
bool
DoWarmUpCounterFallbackOSR
(
JSContext
*
cx
BaselineFrame
*
frame
ICWarmUpCounter_Fallback
*
stub
IonOsrTempData
*
*
infoPtr
)
{
MOZ_ASSERT
(
infoPtr
)
;
*
infoPtr
=
nullptr
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOP_LOOPENTRY
)
;
FallbackICSpew
(
cx
stub
"
WarmUpCounter
(
%
d
)
"
int
(
script
-
>
pcToOffset
(
pc
)
)
)
;
if
(
!
IonCompileScriptForBaseline
(
cx
frame
pc
)
)
return
false
;
if
(
!
script
-
>
hasIonScript
(
)
|
|
script
-
>
ionScript
(
)
-
>
osrPc
(
)
!
=
pc
|
|
script
-
>
ionScript
(
)
-
>
bailoutExpected
(
)
|
|
frame
-
>
isDebuggee
(
)
)
{
return
true
;
}
IonScript
*
ion
=
script
-
>
ionScript
(
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
=
=
ion
-
>
hasProfilingInstrumentation
(
)
)
;
MOZ_ASSERT
(
ion
-
>
osrPc
(
)
=
=
pc
)
;
JitSpew
(
JitSpew_BaselineOSR
"
OSR
possible
!
"
)
;
void
*
jitcode
=
ion
-
>
method
(
)
-
>
raw
(
)
+
ion
-
>
osrEntryOffset
(
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Got
jitcode
.
Preparing
for
OSR
into
ion
.
"
)
;
IonOsrTempData
*
info
=
PrepareOsrTempData
(
cx
stub
frame
script
pc
jitcode
)
;
if
(
!
info
)
return
false
;
*
infoPtr
=
info
;
return
true
;
}
typedef
bool
(
*
DoWarmUpCounterFallbackOSRFn
)
(
JSContext
*
BaselineFrame
*
ICWarmUpCounter_Fallback
*
IonOsrTempData
*
*
infoPtr
)
;
static
const
VMFunction
DoWarmUpCounterFallbackOSRInfo
=
FunctionInfo
<
DoWarmUpCounterFallbackOSRFn
>
(
DoWarmUpCounterFallbackOSR
"
DoWarmUpCounterFallbackOSR
"
)
;
bool
ICWarmUpCounter_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
Label
noCompiledCode
;
{
masm
.
subFromStackPtr
(
Imm32
(
sizeof
(
void
*
)
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoWarmUpCounterFallbackOSRInfo
masm
)
)
return
false
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
leaveStubFrame
(
masm
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
R0
.
scratchReg
(
)
ImmPtr
(
nullptr
)
&
noCompiledCode
)
;
}
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
osrDataReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
osrDataReg
)
;
regs
.
takeUnchecked
(
OsrFrameReg
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
masm
.
moveToStackPtr
(
BaselineFrameReg
)
;
masm
.
pop
(
scratchReg
)
;
#
ifdef
DEBUG
{
Label
checkOk
;
AbsoluteAddress
addressOfEnabled
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
addressOfEnabled
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Equal
addressOfEnabled
Imm32
(
0
)
&
checkOk
)
;
masm
.
loadPtr
(
AbsoluteAddress
(
(
void
*
)
&
cx
-
>
jitActivation
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
scratchReg
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratchReg
ImmWord
(
0
)
&
checkOk
)
;
masm
.
branchStackPtr
(
Assembler
:
:
Equal
scratchReg
&
checkOk
)
;
masm
.
assumeUnreachable
(
"
Baseline
OSR
lastProfilingFrame
mismatch
.
"
)
;
masm
.
bind
(
&
checkOk
)
;
}
#
endif
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
jitcode
)
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
baselineFrame
)
)
OsrFrameReg
)
;
masm
.
jump
(
scratchReg
)
;
masm
.
bind
(
&
noCompiledCode
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoTypeUpdateFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICUpdatedStub
*
stub
HandleValue
objval
HandleValue
value
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
FallbackICSpew
(
cx
stub
-
>
getChainFallback
(
)
"
TypeUpdate
(
%
s
)
"
ICStub
:
:
KindString
(
stub
-
>
kind
(
)
)
)
;
MOZ_ASSERT
(
stub
-
>
isCacheIR_Updated
(
)
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedObject
obj
(
cx
&
objval
.
toObject
(
)
)
;
RootedId
id
(
cx
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
)
;
MOZ_ASSERT
(
id
!
=
JSID_EMPTY
)
;
RootedObjectGroup
group
(
cx
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
)
;
#
ifdef
DEBUG
if
(
obj
-
>
is
<
UnboxedExpandoObject
>
(
)
)
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
&
UnboxedPlainObject
:
:
class_
)
;
else
MOZ_ASSERT
(
obj
-
>
group
(
)
=
=
group
)
;
#
endif
bool
addType
=
true
;
if
(
MOZ_UNLIKELY
(
obj
-
>
is
<
TypedObject
>
(
)
)
&
&
value
.
isNullOrUndefined
(
)
)
{
StructTypeDescr
*
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
MOZ_ALWAYS_TRUE
(
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
ReferenceTypeDescr
:
:
Type
type
=
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
if
(
type
=
=
ReferenceTypeDescr
:
:
TYPE_ANY
)
{
if
(
value
.
isUndefined
(
)
)
addType
=
false
;
}
else
{
MOZ_ASSERT
(
type
=
=
ReferenceTypeDescr
:
:
TYPE_OBJECT
)
;
if
(
value
.
isNull
(
)
)
addType
=
false
;
}
}
if
(
MOZ_LIKELY
(
addType
)
)
{
JSObject
*
maybeSingleton
=
obj
-
>
isSingleton
(
)
?
obj
.
get
(
)
:
nullptr
;
AddTypePropertyId
(
cx
group
maybeSingleton
id
value
)
;
}
if
(
MOZ_UNLIKELY
(
!
stub
-
>
addUpdateStubForValue
(
cx
script
obj
group
id
value
)
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
return
true
;
}
typedef
bool
(
*
DoTypeUpdateFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICUpdatedStub
*
HandleValue
HandleValue
)
;
const
VMFunction
DoTypeUpdateFallbackInfo
=
FunctionInfo
<
DoTypeUpdateFallbackFn
>
(
DoTypeUpdateFallback
"
DoTypeUpdateFallback
"
NonTailCall
)
;
bool
ICTypeUpdate_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
move32
(
Imm32
(
0
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_PrimitiveSet
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
success
;
if
(
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_INT32
)
)
&
&
!
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
)
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
masm
.
branchTestNumber
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_UNDEFINED
)
)
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_BOOLEAN
)
)
masm
.
branchTestBoolean
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_STRING
)
)
masm
.
branchTestString
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_SYMBOL
)
)
masm
.
branchTestSymbol
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_OBJECT
)
)
masm
.
branchTestObject
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_NULL
)
)
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
success
)
;
EmitStubGuardFailure
(
masm
)
;
masm
.
bind
(
&
success
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_SingleObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
Address
expectedObject
(
ICStubReg
ICTypeUpdate_SingleObject
:
:
offsetOfObject
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedObject
obj
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_ObjectGroup
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
R1
.
scratchReg
(
)
)
;
Address
expectedGroup
(
ICStubReg
ICTypeUpdate_ObjectGroup
:
:
offsetOfGroup
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedGroup
R1
.
scratchReg
(
)
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_AnyValue
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToBool_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToBool
"
)
;
bool
cond
=
ToBoolean
(
arg
)
;
ret
.
setBoolean
(
cond
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICToBool_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
MOZ_ASSERT
(
!
arg
.
isBoolean
(
)
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
if
(
arg
.
isInt32
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Int32
)
stub
.
"
)
;
ICToBool_Int32
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
int32Stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
int32Stub
)
return
false
;
stub
-
>
addNewStub
(
int32Stub
)
;
return
true
;
}
if
(
arg
.
isDouble
(
)
&
&
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Double
)
stub
.
"
)
;
ICToBool_Double
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
doubleStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
doubleStub
)
return
false
;
stub
-
>
addNewStub
(
doubleStub
)
;
return
true
;
}
if
(
arg
.
isString
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
String
)
stub
"
)
;
ICToBool_String
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stringStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
stringStub
)
return
false
;
stub
-
>
addNewStub
(
stringStub
)
;
return
true
;
}
if
(
arg
.
isNull
(
)
|
|
arg
.
isUndefined
(
)
)
{
ICToBool_NullUndefined
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
nilStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
nilStub
)
return
false
;
stub
-
>
addNewStub
(
nilStub
)
;
return
true
;
}
if
(
arg
.
isObject
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Object
)
stub
.
"
)
;
ICToBool_Object
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
objStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
objStub
)
return
false
;
stub
-
>
addNewStub
(
objStub
)
;
return
true
;
}
return
true
;
}
typedef
bool
(
*
pf
)
(
JSContext
*
BaselineFrame
*
ICToBool_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
fun
=
FunctionInfo
<
pf
>
(
DoToBoolFallback
"
DoToBoolFallback
"
TailCall
)
;
bool
ICToBool_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
fun
masm
)
;
}
bool
ICToBool_Int32
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestInt32Truthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_String
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestStringTruthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_NullUndefined
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifFalse
;
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
ifFalse
)
;
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Double
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifTrue
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
branchTestDoubleTruthy
(
true
FloatReg0
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Object
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
emulatesUndefined
slowPath
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchIfObjectEmulatesUndefined
(
objReg
scratch
&
slowPath
&
emulatesUndefined
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
emulatesUndefined
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
slowPath
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
objReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
js
:
:
EmulatesUndefined
)
)
;
masm
.
convertBoolToInt32
(
ReturnReg
ReturnReg
)
;
masm
.
xor32
(
Imm32
(
1
)
ReturnReg
)
;
masm
.
tagValue
(
JSVAL_TYPE_BOOLEAN
ReturnReg
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoToNumberFallback
(
JSContext
*
cx
ICToNumber_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToNumber
"
)
;
ret
.
set
(
arg
)
;
return
ToNumber
(
cx
ret
)
;
}
typedef
bool
(
*
DoToNumberFallbackFn
)
(
JSContext
*
ICToNumber_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoToNumberFallbackInfo
=
FunctionInfo
<
DoToNumberFallbackFn
>
(
DoToNumberFallback
"
DoToNumberFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICToNumber_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoToNumberFallbackInfo
masm
)
;
}
static
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub_
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
StackTypeSet
*
types
=
TypeScript
:
:
BytecodeTypes
(
script
pc
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElem
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETELEM
|
|
op
=
=
JSOP_CALLELEM
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
bool
isOptimizedArgs
=
false
;
if
(
lhs
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GetElemOptimizedArguments
(
cx
frame
&
lhsCopy
rhs
res
&
isOptimizedArgs
)
)
return
false
;
if
(
isOptimizedArgs
)
TypeScript
:
:
Monitor
(
cx
script
pc
types
res
)
;
}
bool
attached
=
false
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
GetElem
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
lhs
rhs
lhs
GetPropertyResultFlags
:
:
All
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Monitored
engine
script
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Monitored
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
if
(
!
isOptimizedArgs
)
{
if
(
!
GetElementOperation
(
cx
op
lhsCopy
rhs
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
script
pc
types
res
)
;
}
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
frame
types
res
)
)
return
false
;
if
(
attached
)
return
true
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
stub
-
>
noteNegativeIndex
(
)
;
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
static
bool
DoGetElemSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub_
HandleValue
lhs
HandleValue
receiver
HandleValue
rhs
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
StackTypeSet
*
types
=
TypeScript
:
:
BytecodeTypes
(
script
pc
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElemSuper
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETELEM_SUPER
)
;
bool
attached
=
false
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
GetElemSuper
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
lhs
rhs
receiver
GetPropertyResultFlags
:
:
All
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Monitored
engine
script
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Monitored
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
RootedObject
lhsObj
(
cx
&
lhs
.
toObject
(
)
)
;
if
(
!
GetObjectElementOperation
(
cx
op
lhsObj
receiver
rhs
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
script
pc
types
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
frame
types
res
)
)
return
false
;
if
(
attached
)
return
true
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
stub
-
>
noteNegativeIndex
(
)
;
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoGetElemFallbackInfo
=
FunctionInfo
<
DoGetElemFallbackFn
>
(
DoGetElemFallback
"
DoGetElemFallback
"
TailCall
PopValues
(
2
)
)
;
typedef
bool
(
*
DoGetElemSuperFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoGetElemSuperFallbackInfo
=
FunctionInfo
<
DoGetElemSuperFallbackFn
>
(
DoGetElemSuperFallback
"
DoGetElemSuperFallback
"
TailCall
PopValues
(
3
)
)
;
bool
ICGetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
if
(
hasReceiver_
)
{
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
*
2
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
*
5
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetElemSuperFallbackInfo
masm
)
;
}
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetElemFallbackInfo
masm
)
;
}
void
LoadTypedThingLength
(
MacroAssembler
&
masm
TypedThingLayout
layout
Register
obj
Register
result
)
{
switch
(
layout
)
{
case
Layout_TypedArray
:
masm
.
unboxInt32
(
Address
(
obj
TypedArrayObject
:
:
lengthOffset
(
)
)
result
)
;
break
;
case
Layout_OutlineTypedObject
:
case
Layout_InlineTypedObject
:
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
result
)
;
masm
.
loadPtr
(
Address
(
result
ObjectGroup
:
:
offsetOfAddendum
(
)
)
result
)
;
masm
.
unboxInt32
(
Address
(
result
ArrayTypeDescr
:
:
offsetOfLength
(
)
)
result
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
static
void
SetUpdateStubData
(
ICCacheIR_Updated
*
stub
const
PropertyTypeCheckInfo
*
info
)
{
if
(
info
-
>
isSet
(
)
)
{
stub
-
>
updateStubGroup
(
)
=
info
-
>
group
(
)
;
stub
-
>
updateStubId
(
)
=
info
-
>
id
(
)
;
}
}
static
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetElem_Fallback
*
stub_
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
{
DebugModeOSRVolatileStub
<
ICSetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedScript
outerScript
(
cx
script
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetElem
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETELEM
|
|
op
=
=
JSOP_STRICTSETELEM
|
|
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
|
|
op
=
=
JSOP_INITELEM_ARRAY
|
|
op
=
=
JSOP_INITELEM_INC
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
objv
)
)
;
if
(
!
obj
)
return
false
;
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
return
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
bool
isTemporarilyUnoptimizable
=
false
;
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetElem
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
objv
index
rhs
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
if
(
gen
.
attachedTypedArrayOOBStub
(
)
)
stub
-
>
noteHasTypedArrayOOB
(
)
;
}
}
}
if
(
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
)
{
if
(
!
InitElemOperation
(
cx
pc
obj
index
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_ARRAY
)
{
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
<
=
INT32_MAX
"
the
bytecode
emitter
must
fail
to
compile
code
that
would
"
"
produce
JSOP_INITELEM_ARRAY
with
an
index
exceeding
"
"
int32_t
range
"
)
;
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
=
=
GET_UINT32
(
pc
)
)
;
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_INC
)
{
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
{
if
(
!
SetObjectElement
(
cx
obj
index
rhs
objv
JSOp
(
*
pc
)
=
=
JSOP_STRICTSETELEM
script
pc
)
)
return
false
;
}
if
(
op
=
=
JSOP_INITHIDDENELEM
)
return
true
;
MOZ_ASSERT
(
stack
[
2
]
=
=
objv
)
;
stack
[
2
]
=
rhs
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
attached
)
return
true
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetElem
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
objv
index
rhs
)
;
if
(
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
return
true
;
}
}
else
{
gen
.
trackNotAttached
(
)
;
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
return
true
;
}
typedef
bool
(
*
DoSetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetElem_Fallback
*
Value
*
HandleValue
HandleValue
HandleValue
)
;
static
const
VMFunction
DoSetElemFallbackInfo
=
FunctionInfo
<
DoSetElemFallbackFn
>
(
DoSetElemFallback
"
DoSetElemFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICSetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
R1
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
moveStackPtrTo
(
R1
.
scratchReg
(
)
)
;
masm
.
pushValue
(
Address
(
R1
.
scratchReg
(
)
2
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoSetElemFallbackInfo
masm
)
;
}
void
BaselineScript
:
:
noteHasDenseAdd
(
uint32_t
pcOffset
)
{
ICEntry
&
entry
=
icEntryFromPCOffset
(
pcOffset
)
;
ICFallbackStub
*
stub
=
entry
.
fallbackStub
(
)
;
if
(
stub
-
>
isSetElem_Fallback
(
)
)
stub
-
>
toSetElem_Fallback
(
)
-
>
noteHasDenseAdd
(
)
;
}
template
<
typename
T
>
void
EmitICUnboxedPreBarrier
(
MacroAssembler
&
masm
const
T
&
address
JSValueType
type
)
{
if
(
type
=
=
JSVAL_TYPE_OBJECT
)
EmitPreBarrier
(
masm
address
MIRType
:
:
Object
)
;
else
if
(
type
=
=
JSVAL_TYPE_STRING
)
EmitPreBarrier
(
masm
address
MIRType
:
:
String
)
;
else
MOZ_ASSERT
(
!
UnboxedTypeNeedsPreBarrier
(
type
)
)
;
}
template
void
EmitICUnboxedPreBarrier
(
MacroAssembler
&
masm
const
Address
&
address
JSValueType
type
)
;
template
void
EmitICUnboxedPreBarrier
(
MacroAssembler
&
masm
const
BaseIndex
&
address
JSValueType
type
)
;
template
<
typename
T
>
void
StoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
ValueOperand
&
value
const
T
&
dest
Register
scratch
Label
*
failure
)
{
Label
done
;
if
(
type
=
=
Scalar
:
:
Float32
|
|
type
=
=
Scalar
:
:
Float64
)
{
masm
.
ensureDouble
(
value
FloatReg0
failure
)
;
if
(
type
=
=
Scalar
:
:
Float32
)
{
masm
.
convertDoubleToFloat32
(
FloatReg0
ScratchFloat32Reg
)
;
masm
.
storeToTypedFloatArray
(
type
ScratchFloat32Reg
dest
)
;
}
else
{
masm
.
storeToTypedFloatArray
(
type
FloatReg0
dest
)
;
}
}
else
if
(
type
=
=
Scalar
:
:
Uint8Clamped
)
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
masm
.
clampIntToUint8
(
scratch
)
;
Label
clamped
;
masm
.
bind
(
&
clamped
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
clampDoubleToUint8
(
FloatReg0
scratch
)
;
masm
.
jump
(
&
clamped
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
else
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
Label
isInt32
;
masm
.
bind
(
&
isInt32
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
branchTruncateDoubleMaybeModUint32
(
FloatReg0
scratch
failure
)
;
masm
.
jump
(
&
isInt32
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
masm
.
bind
(
&
done
)
;
}
template
void
StoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
ValueOperand
&
value
const
Address
&
dest
Register
scratch
Label
*
failure
)
;
template
void
StoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
ValueOperand
&
value
const
BaseIndex
&
dest
Register
scratch
Label
*
failure
)
;
static
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIn_Fallback
*
stub_
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIn_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
In
"
)
;
if
(
!
objValue
.
isObject
(
)
)
{
ReportInNotObjectError
(
cx
key
-
2
objValue
-
1
)
;
return
false
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
HasPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
In
stub
-
>
state
(
)
.
mode
(
)
key
objValue
)
;
bool
attached
=
false
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Regular
engine
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
RootedObject
obj
(
cx
&
objValue
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
OperatorIn
(
cx
key
obj
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
return
true
;
}
typedef
bool
(
*
DoInFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInFallbackInfo
=
FunctionInfo
<
DoInFallbackFn
>
(
DoInFallback
"
DoInFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICIn_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInFallbackInfo
masm
)
;
}
static
bool
DoHasOwnFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICHasOwn_Fallback
*
stub_
HandleValue
keyValue
HandleValue
objValue
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIn_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
HasOwn
"
)
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
HasPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
HasOwn
stub
-
>
state
(
)
.
mode
(
)
keyValue
objValue
)
;
bool
attached
=
false
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Regular
engine
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
bool
found
;
if
(
!
HasOwnProperty
(
cx
objValue
keyValue
&
found
)
)
return
false
;
res
.
setBoolean
(
found
)
;
return
true
;
}
typedef
bool
(
*
DoHasOwnFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICHasOwn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoHasOwnFallbackInfo
=
FunctionInfo
<
DoHasOwnFallbackFn
>
(
DoHasOwnFallback
"
DoHasOwnFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICHasOwn_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoHasOwnFallbackInfo
masm
)
;
}
static
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetName_Fallback
*
stub_
HandleObject
envChain
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetName_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETNAME
|
|
op
=
=
JSOP_GETGNAME
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetNameIRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
envChain
name
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Monitored
engine
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
static_assert
(
JSOP_GETGNAME_LENGTH
=
=
JSOP_GETNAME_LENGTH
"
Otherwise
our
check
for
JSOP_TYPEOF
isn
'
t
ok
"
)
;
if
(
JSOp
(
pc
[
JSOP_GETGNAME_LENGTH
]
)
=
=
JSOP_TYPEOF
)
{
if
(
!
GetEnvironmentName
<
GetNameMode
:
:
TypeOf
>
(
cx
envChain
name
res
)
)
return
false
;
}
else
{
if
(
!
GetEnvironmentName
<
GetNameMode
:
:
Normal
>
(
cx
envChain
name
res
)
)
return
false
;
}
StackTypeSet
*
types
=
TypeScript
:
:
BytecodeTypes
(
script
pc
)
;
TypeScript
:
:
Monitor
(
cx
script
pc
types
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
frame
types
res
)
)
return
false
;
if
(
!
attached
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoGetNameFallbackInfo
=
FunctionInfo
<
DoGetNameFallbackFn
>
(
DoGetNameFallback
"
DoGetNameFallback
"
TailCall
)
;
bool
ICGetName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetNameFallbackInfo
masm
)
;
}
static
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBindName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
BindName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_BINDNAME
|
|
op
=
=
JSOP_BINDGNAME
)
;
RootedPropertyName
name
(
cx
frame
-
>
script
(
)
-
>
getName
(
pc
)
)
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
bool
attached
=
false
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
BindNameIRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
envChain
name
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Regular
ICStubEngine
:
:
Baseline
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
RootedObject
scope
(
cx
)
;
if
(
!
LookupNameUnqualified
(
cx
name
envChain
&
scope
)
)
return
false
;
res
.
setObject
(
*
scope
)
;
return
true
;
}
typedef
bool
(
*
DoBindNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICBindName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoBindNameFallbackInfo
=
FunctionInfo
<
DoBindNameFallbackFn
>
(
DoBindNameFallback
"
DoBindNameFallback
"
TailCall
)
;
bool
ICBindName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoBindNameFallbackInfo
masm
)
;
}
static
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIntrinsic_Fallback
*
stub_
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetIntrinsic_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetIntrinsic
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETINTRINSIC
)
;
if
(
!
GetIntrinsicOperation
(
cx
pc
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetIntrinsic
optimized
stub
"
)
;
ICGetIntrinsic_Constant
:
:
Compiler
compiler
(
cx
res
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
typedef
bool
(
*
DoGetIntrinsicFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetIntrinsic_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoGetIntrinsicFallbackInfo
=
FunctionInfo
<
DoGetIntrinsicFallbackFn
>
(
DoGetIntrinsicFallback
"
DoGetIntrinsicFallback
"
TailCall
)
;
bool
ICGetIntrinsic_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetIntrinsicFallbackInfo
masm
)
;
}
bool
ICGetIntrinsic_Constant
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
loadValue
(
Address
(
ICStubReg
ICGetIntrinsic_Constant
:
:
offsetOfValue
(
)
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetProp_Fallback
*
stub_
Value
*
stack
HandleValue
lhs
HandleValue
rhs
)
{
DebugModeOSRVolatileStub
<
ICSetProp_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetProp
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
|
|
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
|
|
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
|
|
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
|
|
op
=
=
JSOP_INITGLEXICAL
)
;
RootedPropertyName
name
(
cx
)
;
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
name
=
EnvironmentCoordinateName
(
cx
-
>
caches
(
)
.
envCoordinateNameCache
script
pc
)
;
else
name
=
script
-
>
getName
(
pc
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
lhs
)
)
;
if
(
!
obj
)
return
false
;
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
return
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
bool
isTemporarilyUnoptimizable
=
false
;
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetProp
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
lhs
idVal
rhs
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
if
(
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
)
{
if
(
!
InitPropertyOperation
(
cx
op
obj
name
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
)
{
if
(
!
SetNameOperation
(
cx
script
pc
obj
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
{
obj
-
>
as
<
EnvironmentObject
>
(
)
.
setAliasedBinding
(
cx
EnvironmentCoordinate
(
pc
)
name
rhs
)
;
}
else
if
(
op
=
=
JSOP_INITGLEXICAL
)
{
RootedValue
v
(
cx
rhs
)
;
LexicalEnvironmentObject
*
lexicalEnv
;
if
(
script
-
>
hasNonSyntacticScope
(
)
)
lexicalEnv
=
&
NearestEnclosingExtensibleLexicalEnvironment
(
frame
-
>
environmentChain
(
)
)
;
else
lexicalEnv
=
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
;
InitGlobalLexicalOperation
(
cx
lexicalEnv
script
pc
v
)
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
)
;
ObjectOpResult
result
;
if
(
!
SetProperty
(
cx
obj
id
rhs
lhs
result
)
|
|
!
result
.
checkStrictErrorOrWarning
(
cx
obj
id
op
=
=
JSOP_STRICTSETPROP
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
stack
[
1
]
=
=
lhs
)
;
stack
[
1
]
=
rhs
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
attached
)
return
true
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetProp
stub
-
>
state
(
)
.
mode
(
)
&
isTemporarilyUnoptimizable
lhs
idVal
rhs
)
;
if
(
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
}
}
else
{
gen
.
trackNotAttached
(
)
;
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoSetPropFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetProp_Fallback
*
Value
*
HandleValue
HandleValue
)
;
static
const
VMFunction
DoSetPropFallbackInfo
=
FunctionInfo
<
DoSetPropFallbackFn
>
(
DoSetPropFallback
"
DoSetPropFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICSetProp_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
0
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
tailCallVM
(
DoSetPropFallbackInfo
masm
)
)
return
false
;
assumeStubFrame
(
masm
)
;
bailoutReturnOffset_
.
bind
(
masm
.
currentOffset
(
)
)
;
leaveStubFrame
(
masm
true
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
void
ICSetProp_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
BailoutReturnStub
kind
=
BailoutReturnStub
:
:
SetProp
;
void
*
address
=
code
-
>
raw
(
)
+
bailoutReturnOffset_
.
offset
(
)
;
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBailoutReturnAddr
(
address
getKey
(
)
kind
)
;
}
static
bool
TryAttachFunApplyStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
uint32_t
argc
Value
*
argv
ICTypeMonitor_Fallback
*
typeMonitorFallback
bool
*
attached
)
{
if
(
argc
!
=
2
)
return
true
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
bool
isScripted
=
target
-
>
hasJITCode
(
)
;
if
(
argv
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
!
script
-
>
needsArgsObj
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArguments
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArguments
stub
"
)
;
ICCall_ScriptedApplyArguments
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
if
(
argv
[
1
]
.
isObject
(
)
&
&
argv
[
1
]
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArray
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArray
stub
"
)
;
ICCall_ScriptedApplyArray
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
return
true
;
}
static
bool
TryAttachFunCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
ICTypeMonitor_Fallback
*
typeMonitorFallback
bool
*
attached
)
{
*
attached
=
false
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
target
-
>
hasScript
(
)
&
&
target
-
>
nonLazyScript
(
)
-
>
canBaselineCompile
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedFunCall
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedFunCall
stub
"
)
;
ICCall_ScriptedFunCall
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
return
true
;
}
static
bool
GetTemplateObjectForSimd
(
JSContext
*
cx
JSFunction
*
target
MutableHandleObject
res
)
{
const
JSJitInfo
*
jitInfo
=
target
-
>
jitInfo
(
)
;
if
(
!
jitInfo
|
|
jitInfo
-
>
type
(
)
!
=
JSJitInfo
:
:
InlinableNative
)
return
false
;
SimdType
ctrlType
;
switch
(
jitInfo
-
>
inlinableNative
)
{
case
InlinableNative
:
:
SimdInt8x16
:
ctrlType
=
SimdType
:
:
Int8x16
;
break
;
case
InlinableNative
:
:
SimdUint8x16
:
ctrlType
=
SimdType
:
:
Uint8x16
;
break
;
case
InlinableNative
:
:
SimdInt16x8
:
ctrlType
=
SimdType
:
:
Int16x8
;
break
;
case
InlinableNative
:
:
SimdUint16x8
:
ctrlType
=
SimdType
:
:
Uint16x8
;
break
;
case
InlinableNative
:
:
SimdInt32x4
:
ctrlType
=
SimdType
:
:
Int32x4
;
break
;
case
InlinableNative
:
:
SimdUint32x4
:
ctrlType
=
SimdType
:
:
Uint32x4
;
break
;
case
InlinableNative
:
:
SimdFloat32x4
:
ctrlType
=
SimdType
:
:
Float32x4
;
break
;
case
InlinableNative
:
:
SimdBool8x16
:
ctrlType
=
SimdType
:
:
Bool8x16
;
break
;
case
InlinableNative
:
:
SimdBool16x8
:
ctrlType
=
SimdType
:
:
Bool16x8
;
break
;
case
InlinableNative
:
:
SimdBool32x4
:
ctrlType
=
SimdType
:
:
Bool32x4
;
break
;
default
:
return
false
;
}
SimdOperation
simdOp
=
SimdOperation
(
jitInfo
-
>
nativeOp
)
;
SimdType
retType
;
switch
(
simdOp
)
{
case
SimdOperation
:
:
Fn_allTrue
:
case
SimdOperation
:
:
Fn_anyTrue
:
case
SimdOperation
:
:
Fn_extractLane
:
return
false
;
case
SimdOperation
:
:
Fn_lessThan
:
case
SimdOperation
:
:
Fn_lessThanOrEqual
:
case
SimdOperation
:
:
Fn_equal
:
case
SimdOperation
:
:
Fn_notEqual
:
case
SimdOperation
:
:
Fn_greaterThan
:
case
SimdOperation
:
:
Fn_greaterThanOrEqual
:
retType
=
GetBooleanSimdType
(
ctrlType
)
;
break
;
default
:
retType
=
ctrlType
;
break
;
}
RootedGlobalObject
global
(
cx
cx
-
>
global
(
)
)
;
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
GlobalObject
:
:
getOrCreateSimdTypeDescr
(
cx
global
retType
)
)
;
res
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
true
;
}
static
bool
GetTemplateObjectForNative
(
JSContext
*
cx
HandleFunction
target
const
CallArgs
&
args
MutableHandleObject
res
bool
*
skipAttach
)
{
Native
native
=
target
-
>
native
(
)
;
if
(
native
=
=
ArrayConstructor
|
|
native
=
=
array_construct
)
{
size_t
count
=
0
;
if
(
args
.
length
(
)
!
=
1
)
count
=
args
.
length
(
)
;
else
if
(
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isInt32
(
)
&
&
args
[
0
]
.
toInt32
(
)
>
=
0
)
count
=
args
[
0
]
.
toInt32
(
)
;
if
(
count
<
=
ArrayObject
:
:
EagerAllocationMaxLength
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
count
TenuredObject
)
)
;
return
!
!
res
;
}
}
if
(
args
.
length
(
)
=
=
1
)
{
size_t
len
=
0
;
if
(
args
[
0
]
.
isInt32
(
)
&
&
args
[
0
]
.
toInt32
(
)
>
=
0
)
len
=
args
[
0
]
.
toInt32
(
)
;
if
(
!
TypedArrayObject
:
:
GetTemplateObjectForNative
(
cx
native
len
res
)
)
return
false
;
if
(
res
)
return
true
;
}
if
(
native
=
=
js
:
:
array_slice
)
{
if
(
args
.
thisv
(
)
.
isObject
(
)
)
{
RootedObject
obj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
if
(
!
obj
-
>
isSingleton
(
)
)
{
if
(
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayTryReuseGroup
(
cx
obj
0
TenuredObject
)
)
;
return
!
!
res
;
}
}
}
if
(
native
=
=
js
:
:
intrinsic_StringSplitString
&
&
args
.
length
(
)
=
=
2
&
&
args
[
0
]
.
isString
(
)
&
&
args
[
1
]
.
isString
(
)
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
0
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
StringConstructor
)
{
RootedString
emptyString
(
cx
cx
-
>
runtime
(
)
-
>
emptyString
)
;
res
.
set
(
StringObject
:
:
create
(
cx
emptyString
nullptr
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
obj_create
&
&
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isObjectOrNull
(
)
)
{
RootedObject
proto
(
cx
args
[
0
]
.
toObjectOrNull
(
)
)
;
res
.
set
(
ObjectCreateImpl
(
cx
proto
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
js
:
:
intrinsic_NewArrayIterator
)
{
res
.
set
(
NewArrayIteratorObject
(
cx
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
js
:
:
intrinsic_NewStringIterator
)
{
res
.
set
(
NewStringIteratorObject
(
cx
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
JitSupportsSimd
(
)
&
&
GetTemplateObjectForSimd
(
cx
target
res
)
)
return
!
!
res
;
return
true
;
}
static
bool
GetTemplateObjectForClassHook
(
JSContext
*
cx
JSNative
hook
CallArgs
&
args
MutableHandleObject
templateObject
)
{
if
(
hook
=
=
TypedObject
:
:
construct
)
{
Rooted
<
TypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
TypeDescr
>
(
)
)
;
templateObject
.
set
(
TypedObject
:
:
createZeroed
(
cx
descr
1
gc
:
:
TenuredHeap
)
)
;
return
!
!
templateObject
;
}
if
(
hook
=
=
SimdTypeDescr
:
:
call
&
&
JitSupportsSimd
(
)
)
{
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
SimdTypeDescr
>
(
)
)
;
templateObject
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
!
!
templateObject
;
}
return
true
;
}
static
bool
IsOptimizableConstStringSplit
(
const
Value
&
callee
int
argc
Value
*
args
)
{
if
(
argc
!
=
2
|
|
!
args
[
0
]
.
isString
(
)
|
|
!
args
[
1
]
.
isString
(
)
)
return
false
;
if
(
!
args
[
0
]
.
toString
(
)
-
>
isAtom
(
)
|
|
!
args
[
1
]
.
toString
(
)
-
>
isAtom
(
)
)
return
false
;
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
&
calleeFun
=
callee
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
calleeFun
.
isNative
(
)
|
|
calleeFun
.
native
(
)
!
=
js
:
:
intrinsic_StringSplitString
)
return
false
;
return
true
;
}
static
bool
TryAttachCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
JSOp
op
uint32_t
argc
Value
*
vp
bool
constructing
bool
isSpread
bool
createSingleton
bool
*
handled
)
{
bool
isSuper
=
op
=
=
JSOP_SUPERCALL
|
|
op
=
=
JSOP_SPREADSUPERCALL
;
if
(
createSingleton
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICCall_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
=
=
0
&
&
IsOptimizableConstStringSplit
(
callee
argc
vp
+
2
)
)
return
true
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_ConstStringSplit
)
;
if
(
!
callee
.
isObject
(
)
)
return
true
;
ICTypeMonitor_Fallback
*
typeMonitorFallback
=
stub
-
>
getFallbackMonitorStub
(
cx
script
)
;
if
(
!
typeMonitorFallback
)
return
false
;
RootedObject
obj
(
cx
&
callee
.
toObject
(
)
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
return
true
;
if
(
JSNative
hook
=
constructing
?
obj
-
>
constructHook
(
)
:
obj
-
>
callHook
(
)
)
{
if
(
op
!
=
JSOP_FUNAPPLY
&
&
!
isSpread
&
&
!
createSingleton
)
{
RootedObject
templateObject
(
cx
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForClassHook
(
cx
hook
args
&
templateObject
)
)
return
false
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ClassHook
stub
"
)
;
ICCall_ClassHook
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
obj
-
>
getClass
(
)
hook
templateObject
script
-
>
pcToOffset
(
pc
)
constructing
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
}
return
true
;
}
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
fun
-
>
hasScript
(
)
)
{
if
(
op
=
=
JSOP_FUNAPPLY
)
return
true
;
if
(
constructing
&
&
!
fun
-
>
isConstructor
(
)
)
return
true
;
if
(
!
constructing
&
&
fun
-
>
isClassConstructor
(
)
)
return
true
;
if
(
!
fun
-
>
hasJITCode
(
)
)
{
*
handled
=
true
;
return
true
;
}
if
(
stub
-
>
scriptedStubsAreGeneralized
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Chain
already
has
generalized
scripted
call
stub
!
"
)
;
return
true
;
}
if
(
stub
-
>
scriptedStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_SCRIPTED_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_AnyScripted
stub
(
cons
=
%
s
spread
=
%
s
)
"
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_Scripted
)
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
IsIonEnabled
(
cx
)
)
EnsureTrackPropertyTypes
(
cx
fun
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
RootedObject
templateObject
(
cx
)
;
if
(
constructing
&
&
!
isSuper
)
{
RootedObject
newTarget
(
cx
&
vp
[
2
+
argc
]
.
toObject
(
)
)
;
RootedValue
protov
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
newTarget
NameToId
(
cx
-
>
names
(
)
.
prototype
)
protov
.
address
(
)
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Can
'
t
purely
lookup
function
prototype
"
)
;
return
true
;
}
if
(
protov
.
isObject
(
)
)
{
TaggedProto
proto
(
&
protov
.
toObject
(
)
)
;
ObjectGroup
*
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx
nullptr
proto
newTarget
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
newScript
(
)
&
&
!
group
-
>
newScript
(
)
-
>
analyzed
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Function
newScript
has
not
been
analyzed
"
)
;
*
handled
=
true
;
return
true
;
}
}
JSObject
*
thisObject
=
CreateThisForFunction
(
cx
fun
newTarget
TenuredObject
)
;
if
(
!
thisObject
)
return
false
;
if
(
thisObject
-
>
is
<
PlainObject
>
(
)
|
|
thisObject
-
>
is
<
UnboxedPlainObject
>
(
)
)
templateObject
=
thisObject
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Scripted
stub
(
fun
=
%
p
%
s
:
%
zu
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
fun
-
>
nonLazyScript
(
)
-
>
filename
(
)
fun
-
>
nonLazyScript
(
)
-
>
lineno
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
fun
-
>
isNative
(
)
&
&
(
!
constructing
|
|
(
constructing
&
&
fun
-
>
isConstructor
(
)
)
)
)
{
MOZ_ASSERT
(
!
stub
-
>
nativeStubsAreGeneralized
(
)
)
;
if
(
op
=
=
JSOP_FUNAPPLY
)
{
if
(
fun
-
>
native
(
)
=
=
fun_apply
)
{
return
TryAttachFunApplyStub
(
cx
stub
script
pc
thisv
argc
vp
+
2
typeMonitorFallback
handled
)
;
}
return
true
;
}
if
(
op
=
=
JSOP_FUNCALL
&
&
fun
-
>
native
(
)
=
=
fun_call
)
{
if
(
!
TryAttachFunCallStub
(
cx
stub
script
pc
thisv
typeMonitorFallback
handled
)
)
return
false
;
if
(
*
handled
)
return
true
;
}
if
(
stub
-
>
nativeStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_NATIVE_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Too
many
Call_Native
stubs
.
TODO
:
add
Call_AnyNative
!
"
)
;
return
true
;
}
if
(
fun
-
>
native
(
)
=
=
intrinsic_IsSuspendedGenerator
)
{
MOZ_ASSERT
(
op
!
=
JSOP_NEW
)
;
MOZ_ASSERT
(
argc
=
=
1
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_IsSuspendedGenerator
stub
"
)
;
ICCall_IsSuspendedGenerator
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
RootedObject
templateObject
(
cx
)
;
if
(
MOZ_LIKELY
(
!
isSpread
&
&
!
isSuper
)
)
{
bool
skipAttach
=
false
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForNative
(
cx
fun
args
&
templateObject
&
skipAttach
)
)
return
false
;
if
(
skipAttach
)
{
*
handled
=
true
;
return
true
;
}
MOZ_ASSERT_IF
(
templateObject
!
templateObject
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
;
}
bool
ignoresReturnValue
=
false
;
if
(
op
=
=
JSOP_CALL_IGNORES_RV
&
&
fun
-
>
isNative
(
)
)
{
const
JSJitInfo
*
jitInfo
=
fun
-
>
jitInfo
(
)
;
ignoresReturnValue
=
jitInfo
&
&
jitInfo
-
>
type
(
)
=
=
JSJitInfo
:
:
IgnoresReturnValueNative
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Native
stub
(
fun
=
%
p
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCall_Native
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
ignoresReturnValue
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
return
true
;
}
static
bool
CopyArray
(
JSContext
*
cx
HandleArrayObject
arr
MutableHandleValue
result
)
{
uint32_t
length
=
arr
-
>
length
(
)
;
ArrayObject
*
nobj
=
NewFullyAllocatedArrayTryReuseGroup
(
cx
arr
length
TenuredObject
)
;
if
(
!
nobj
)
return
false
;
nobj
-
>
initDenseElements
(
arr
0
length
)
;
result
.
setObject
(
*
nobj
)
;
return
true
;
}
static
bool
TryAttachConstStringSplit
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
uint32_t
argc
HandleValue
callee
Value
*
vp
jsbytecode
*
pc
HandleValue
res
bool
*
attached
)
{
if
(
stub
-
>
numOptimizedStubs
(
)
!
=
0
)
return
true
;
Value
*
args
=
vp
+
2
;
if
(
JSOp
(
*
pc
)
=
=
JSOP_NEW
)
return
true
;
if
(
!
IsOptimizableConstStringSplit
(
callee
argc
args
)
)
return
true
;
MOZ_ASSERT
(
callee
.
isObject
(
)
)
;
MOZ_ASSERT
(
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
RootedString
str
(
cx
args
[
0
]
.
toString
(
)
)
;
RootedString
sep
(
cx
args
[
1
]
.
toString
(
)
)
;
RootedObject
obj
(
cx
&
res
.
toObject
(
)
)
;
RootedValue
arr
(
cx
)
;
if
(
!
CopyArray
(
cx
obj
.
as
<
ArrayObject
>
(
)
&
arr
)
)
return
false
;
RootedArrayObject
arrObj
(
cx
&
arr
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
)
;
uint32_t
initLength
=
arrObj
-
>
length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
initLength
;
i
+
+
)
{
JSAtom
*
str
=
js
:
:
AtomizeString
(
cx
arrObj
-
>
getDenseElement
(
i
)
.
toString
(
)
)
;
if
(
!
str
)
return
false
;
arrObj
-
>
setDenseElementWithType
(
cx
i
StringValue
(
str
)
)
;
}
ICTypeMonitor_Fallback
*
typeMonitorFallback
=
stub
-
>
getFallbackMonitorStub
(
cx
script
)
;
if
(
!
typeMonitorFallback
)
return
false
;
ICCall_ConstStringSplit
:
:
Compiler
compiler
(
cx
typeMonitorFallback
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
str
sep
arrObj
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
Call
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
argc
=
=
GET_ARGC
(
pc
)
)
;
bool
constructing
=
(
op
=
=
JSOP_NEW
|
|
op
=
=
JSOP_SUPERCALL
)
;
bool
ignoresReturnValue
=
(
op
=
=
JSOP_CALL_IGNORES_RV
)
;
size_t
numValues
=
argc
+
2
+
constructing
;
AutoArrayRooter
vpRoot
(
cx
numValues
vp
)
;
CallArgs
callArgs
=
CallArgsFromSp
(
argc
+
constructing
vp
+
numValues
constructing
ignoresReturnValue
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
if
(
op
=
=
JSOP_FUNAPPLY
&
&
argc
=
=
2
&
&
callArgs
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GuardFunApplyArgumentsOptimization
(
cx
frame
callArgs
)
)
return
false
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
bool
canAttachStub
=
stub
-
>
state
(
)
.
canAttachStub
(
)
;
bool
handled
=
false
;
if
(
canAttachStub
)
{
CallIRGenerator
gen
(
cx
script
pc
op
stub
stub
-
>
state
(
)
.
mode
(
)
argc
callee
callArgs
.
thisv
(
)
HandleValueArray
:
:
fromMarkedLocation
(
argc
vp
+
2
)
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
gen
.
cacheIRStubKind
(
)
ICStubEngine
:
:
Baseline
script
stub
&
handled
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
if
(
gen
.
cacheIRStubKind
(
)
=
=
BaselineCacheIRStubKind
:
:
Updated
)
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
}
}
if
(
!
handled
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
if
(
!
handled
)
{
bool
createSingleton
=
ObjectGroup
:
:
useSingletonForNewObject
(
cx
script
pc
)
;
if
(
!
TryAttachCallStub
(
cx
stub
script
pc
op
argc
vp
constructing
false
createSingleton
&
handled
)
)
{
return
false
;
}
}
if
(
constructing
)
{
if
(
!
ConstructFromStack
(
cx
callArgs
)
)
return
false
;
res
.
set
(
callArgs
.
rval
(
)
)
;
}
else
if
(
(
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
&
&
frame
-
>
environmentChain
(
)
-
>
global
(
)
.
valueIsEval
(
callee
)
)
{
if
(
!
DirectEval
(
cx
callArgs
.
get
(
0
)
res
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_CALL
|
|
op
=
=
JSOP_CALL_IGNORES_RV
|
|
op
=
=
JSOP_CALLITER
|
|
op
=
=
JSOP_FUNCALL
|
|
op
=
=
JSOP_FUNAPPLY
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
;
if
(
op
=
=
JSOP_CALLITER
&
&
callee
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
argc
=
=
0
"
thisv
must
be
on
top
of
the
stack
"
)
;
ReportValueError
(
cx
JSMSG_NOT_ITERABLE
-
1
callArgs
.
thisv
(
)
nullptr
)
;
return
false
;
}
if
(
!
CallFromStack
(
cx
callArgs
)
)
return
false
;
res
.
set
(
callArgs
.
rval
(
)
)
;
}
StackTypeSet
*
types
=
TypeScript
:
:
BytecodeTypes
(
script
pc
)
;
TypeScript
:
:
Monitor
(
cx
script
pc
types
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
frame
types
res
)
)
return
false
;
if
(
!
handled
)
{
if
(
!
TryAttachConstStringSplit
(
cx
stub
script
argc
callee
vp
pc
res
&
handled
)
)
return
false
;
}
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
static
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
Value
*
vp
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
bool
constructing
=
(
op
=
=
JSOP_SPREADNEW
|
|
op
=
=
JSOP_SPREADSUPERCALL
)
;
FallbackICSpew
(
cx
stub
"
SpreadCall
(
%
s
)
"
CodeName
[
op
]
)
;
AutoArrayRooter
vpRoot
(
cx
3
+
constructing
vp
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
RootedValue
arr
(
cx
vp
[
2
]
)
;
RootedValue
newTarget
(
cx
constructing
?
vp
[
3
]
:
NullValue
(
)
)
;
bool
handled
=
false
;
if
(
op
!
=
JSOP_SPREADEVAL
&
&
op
!
=
JSOP_STRICTSPREADEVAL
&
&
!
TryAttachCallStub
(
cx
stub
script
pc
op
1
vp
constructing
true
false
&
handled
)
)
{
return
false
;
}
if
(
!
SpreadCallOperation
(
cx
script
pc
thisv
callee
arr
newTarget
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
StackTypeSet
*
types
=
TypeScript
:
:
BytecodeTypes
(
script
pc
)
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
frame
types
res
)
)
return
false
;
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
void
ICCallStubCompiler
:
:
pushCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
MOZ_ASSERT
(
!
regs
.
has
(
argcReg
)
)
;
Register
count
=
regs
.
takeAny
(
)
;
masm
.
move32
(
argcReg
count
)
;
if
(
isJitCall
)
{
if
(
isConstructing
)
masm
.
add32
(
Imm32
(
1
)
count
)
;
}
else
{
masm
.
add32
(
Imm32
(
2
+
isConstructing
)
count
)
;
}
Register
argPtr
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
argPtr
)
;
masm
.
addPtr
(
Imm32
(
STUB_FRAME_SIZE
)
argPtr
)
;
if
(
isJitCall
)
{
masm
.
alignJitStackBasedOnNArgs
(
count
)
;
masm
.
add32
(
Imm32
(
2
)
count
)
;
}
Label
loop
done
;
masm
.
bind
(
&
loop
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
count
count
&
done
)
;
{
masm
.
pushValue
(
Address
(
argPtr
0
)
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
argPtr
)
;
masm
.
sub32
(
Imm32
(
1
)
count
)
;
masm
.
jump
(
&
loop
)
;
}
masm
.
bind
(
&
done
)
;
}
void
ICCallStubCompiler
:
:
guardSpreadCall
(
MacroAssembler
&
masm
Register
argcReg
Label
*
failure
bool
isConstructing
)
{
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
isConstructing
*
sizeof
(
Value
)
+
ICStackValueOffset
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfLength
(
)
)
argcReg
)
;
static_assert
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
<
=
ARGS_LENGTH_MAX
"
maximum
arguments
length
for
optimized
stub
should
be
<
=
ARGS_LENGTH_MAX
"
)
;
masm
.
branch32
(
Assembler
:
:
Above
argcReg
Imm32
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
)
failure
)
;
}
void
ICCallStubCompiler
:
:
pushSpreadCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
(
isConstructing
*
sizeof
(
Value
)
)
+
STUB_FRAME_SIZE
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
if
(
isJitCall
)
{
Register
alignReg
=
argcReg
;
if
(
isConstructing
)
{
alignReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
alignReg
)
;
masm
.
addPtr
(
Imm32
(
1
)
alignReg
)
;
}
masm
.
alignJitStackBasedOnNArgs
(
alignReg
)
;
if
(
isConstructing
)
{
MOZ_ASSERT
(
alignReg
!
=
argcReg
)
;
regs
.
add
(
alignReg
)
;
}
}
if
(
isConstructing
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
endReg
)
;
static_assert
(
sizeof
(
Value
)
=
=
8
"
Value
must
be
8
bytes
"
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
regs
.
add
(
startReg
)
;
regs
.
add
(
endReg
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
1
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
2
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
}
Register
ICCallStubCompiler
:
:
guardFunApply
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
FunApplyThing
applyThing
Label
*
failure
)
{
masm
.
branch32
(
Assembler
:
:
NotEqual
argcReg
Imm32
(
2
)
failure
)
;
Address
secondArgSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
applyThing
=
=
FunApply_MagicArgs
)
{
masm
.
branchTestMagic
(
Assembler
:
:
NotEqual
secondArgSlot
failure
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFlags
(
)
)
Imm32
(
BaselineFrame
:
:
HAS_ARGS_OBJ
)
failure
)
;
masm
.
branch32
(
Assembler
:
:
Above
Address
(
BaselineFrameReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
Imm32
(
ICCall_ScriptedApplyArray
:
:
MAX_ARGS_ARRAY_LENGTH
)
failure
)
;
}
else
{
MOZ_ASSERT
(
applyThing
=
=
FunApply_Array
)
;
AllocatableGeneralRegisterSet
regsx
=
regs
;
ValueOperand
secondArgVal
=
regsx
.
takeAnyValue
(
)
;
masm
.
loadValue
(
secondArgSlot
secondArgVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
secondArgVal
failure
)
;
Register
secondArgObj
=
masm
.
extractObject
(
secondArgVal
ExtractTemp1
)
;
regsx
.
add
(
secondArgVal
)
;
regsx
.
takeUnchecked
(
secondArgObj
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
secondArgObj
regsx
.
getAny
(
)
&
ArrayObject
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
secondArgObj
NativeObject
:
:
offsetOfElements
(
)
)
secondArgObj
)
;
Register
lenReg
=
regsx
.
takeAny
(
)
;
masm
.
load32
(
Address
(
secondArgObj
ObjectElements
:
:
offsetOfLength
(
)
)
lenReg
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
secondArgObj
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
lenReg
failure
)
;
masm
.
branch32
(
Assembler
:
:
Above
lenReg
Imm32
(
ICCall_ScriptedApplyArray
:
:
MAX_ARGS_ARRAY_LENGTH
)
failure
)
;
JS_STATIC_ASSERT
(
sizeof
(
Value
)
=
=
8
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
lenReg
)
;
masm
.
addPtr
(
secondArgObj
lenReg
)
;
Register
start
=
secondArgObj
;
Register
end
=
lenReg
;
Label
loop
;
Label
endLoop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
AboveOrEqual
start
end
&
endLoop
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
Address
(
start
0
)
failure
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
start
)
;
masm
.
jump
(
&
loop
)
;
masm
.
bind
(
&
endLoop
)
;
}
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
Address
calleeSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
3
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
calleeSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
callee
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrEnv
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_apply
)
failure
)
;
Address
thisSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
2
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
thisSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
target
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
regs
.
add
(
val
)
;
regs
.
takeUnchecked
(
target
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
target
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
Register
temp
=
regs
.
takeAny
(
)
;
masm
.
branchIfFunctionHasNoScript
(
target
failure
)
;
masm
.
branchFunctionKind
(
Assembler
:
:
Equal
JSFunction
:
:
ClassConstructor
callee
temp
failure
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfScript
(
)
)
temp
)
;
masm
.
loadBaselineOrIonRaw
(
temp
temp
failure
)
;
regs
.
add
(
temp
)
;
return
target
;
}
void
ICCallStubCompiler
:
:
pushCallerArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
endReg
)
;
masm
.
addPtr
(
Imm32
(
BaselineFrame
:
:
offsetOfArg
(
0
)
)
startReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
void
ICCallStubCompiler
:
:
pushArrayArguments
(
MacroAssembler
&
masm
Address
arrayVal
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
extractObject
(
arrayVal
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
masm
.
load32
(
Address
(
startReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
endReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
typedef
bool
(
*
DoCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
uint32_t
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoCallFallbackInfo
=
FunctionInfo
<
DoCallFallbackFn
>
(
DoCallFallback
"
DoCallFallback
"
)
;
typedef
bool
(
*
DoSpreadCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoSpreadCallFallbackInfo
=
FunctionInfo
<
DoSpreadCallFallbackFn
>
(
DoSpreadCallFallback
"
DoSpreadCallFallback
"
)
;
bool
ICCall_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
{
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
if
(
isConstructing_
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
uint32_t
valueOffset
=
isConstructing_
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoSpreadCallFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
regs
.
take
(
R0
.
scratchReg
(
)
)
;
pushCallArguments
(
masm
regs
R0
.
scratchReg
(
)
false
isConstructing_
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoCallFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
assumeStubFrame
(
masm
)
;
bailoutReturnOffset_
.
bind
(
masm
.
currentOffset
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
size_t
)
)
R1
)
;
leaveStubFrame
(
masm
true
)
;
if
(
isConstructing_
)
{
MOZ_ASSERT
(
JSReturnOperand
=
=
R0
)
;
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
moveValue
(
R1
R0
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Failed
to
return
object
in
constructing
call
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
void
ICCall_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
return
;
void
*
address
=
code
-
>
raw
(
)
+
bailoutReturnOffset_
.
offset
(
)
;
BailoutReturnStub
kind
=
isConstructing_
?
BailoutReturnStub
:
:
New
:
BailoutReturnStub
:
:
Call
;
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBailoutReturnAddr
(
address
getKey
(
)
kind
)
;
}
typedef
bool
(
*
CreateThisFn
)
(
JSContext
*
cx
HandleObject
callee
HandleObject
newTarget
MutableHandleValue
rval
)
;
static
const
VMFunction
CreateThisInfoBaseline
=
FunctionInfo
<
CreateThisFn
>
(
CreateThis
"
CreateThis
"
)
;
bool
ICCallScriptedCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
unsigned
skipToCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipToCallee
+
ICStackValueOffset
)
R1
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSkip
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
if
(
callee_
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
Call_Scripted
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Scripted
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
}
else
{
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
if
(
isConstructing_
)
{
masm
.
branchIfNotInterpretedConstructor
(
callee
regs
.
getAny
(
)
&
failure
)
;
}
else
{
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
branchFunctionKind
(
Assembler
:
:
Equal
JSFunction
:
:
ClassConstructor
callee
regs
.
getAny
(
)
&
failure
)
;
}
}
Register
code
;
if
(
!
isConstructing_
)
{
code
=
regs
.
takeAny
(
)
;
masm
.
loadJitCodeRaw
(
callee
code
&
failure
)
;
}
else
{
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfScript
(
)
)
callee
)
;
Address
scriptCode
(
callee
JSScript
:
:
offsetOfBaselineOrIonRaw
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scriptCode
ImmPtr
(
nullptr
)
&
failure
)
;
}
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
failureLeaveStubFrame
;
if
(
isConstructing_
)
{
masm
.
push
(
argcReg
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
)
R1
)
;
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
isSpread_
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
R1
)
;
}
else
{
BaseValueIndex
calleeSlot2
(
masm
.
getStackPointer
(
)
argcReg
2
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
;
masm
.
loadValue
(
calleeSlot2
R1
)
;
}
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
!
callVM
(
CreateThisInfoBaseline
masm
)
)
return
false
;
#
ifdef
DEBUG
Label
createdThisOK
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
assumeUnreachable
(
"
The
return
of
CreateThis
must
be
an
object
or
uninitialized
.
"
)
;
masm
.
bind
(
&
createdThisOK
)
;
#
endif
static_assert
(
JSReturnOperand
=
=
R0
"
The
code
below
needs
to
be
adapted
.
"
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
take
(
R0
)
;
argcReg
=
regs
.
takeAny
(
)
;
masm
.
pop
(
argcReg
)
;
if
(
isSpread_
)
{
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
}
else
{
BaseValueIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
STUB_FRAME_SIZE
+
isConstructing_
*
sizeof
(
Value
)
)
;
masm
.
storeValue
(
R0
thisSlot
)
;
}
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SAVED_STUB_OFFSET
)
ICStubReg
)
;
if
(
isSpread_
)
{
unsigned
skipForCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipForCallee
+
STUB_FRAME_SIZE
)
R0
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot3
(
masm
.
getStackPointer
(
)
argcReg
nonArgsSkip
+
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
calleeSlot3
R0
)
;
}
callee
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
regs
.
add
(
R0
)
;
regs
.
takeUnchecked
(
callee
)
;
code
=
regs
.
takeAny
(
)
;
masm
.
loadJitCodeRaw
(
callee
code
&
failureLeaveStubFrame
)
;
if
(
callee
!
=
ExtractTemp0
)
regs
.
add
(
callee
)
;
if
(
canUseTailCallReg
)
regs
.
addUnchecked
(
ICTailCallReg
)
;
}
Register
scratch
=
regs
.
takeAny
(
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
PushCalleeToken
(
callee
isConstructing_
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
TrampolinePtr
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
argumentsRectifier
code
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
if
(
isConstructing_
)
{
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
Address
descriptorAddr
(
masm
.
getStackPointer
(
)
0
)
;
masm
.
loadPtr
(
descriptorAddr
BaselineFrameReg
)
;
masm
.
rshiftPtr
(
Imm32
(
FRAMESIZE_SHIFT
)
BaselineFrameReg
)
;
masm
.
addPtr
(
Imm32
(
(
3
-
2
)
*
sizeof
(
size_t
)
)
BaselineFrameReg
)
;
masm
.
addStackPtrTo
(
BaselineFrameReg
)
;
Register
argcReg
=
JSReturnOperand
.
scratchReg
(
)
;
if
(
isSpread_
)
{
masm
.
move32
(
Imm32
(
1
)
argcReg
)
;
}
else
{
Address
argcAddr
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
size_t
)
)
;
masm
.
loadPtr
(
argcAddr
argcReg
)
;
}
BaseValueIndex
thisSlotAddr
(
BaselineFrameReg
argcReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
thisSlotAddr
JSReturnOperand
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Return
of
constructing
call
should
be
an
object
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
assumeStubFrame
(
masm
)
;
masm
.
bind
(
&
failureLeaveStubFrame
)
;
leaveStubFrame
(
masm
false
)
;
if
(
argcReg
!
=
R0
.
scratchReg
(
)
)
masm
.
movePtr
(
argcReg
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
typedef
bool
(
*
CopyArrayFn
)
(
JSContext
*
HandleArrayObject
MutableHandleValue
)
;
static
const
VMFunction
CopyArrayInfo
=
FunctionInfo
<
CopyArrayFn
>
(
CopyArray
"
CopyArray
"
)
;
bool
ICCall_ConstStringSplit
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
static
const
size_t
SEP_DEPTH
=
0
;
static
const
size_t
STR_DEPTH
=
sizeof
(
Value
)
;
static
const
size_t
CALLEE_DEPTH
=
3
*
sizeof
(
Value
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Label
failureRestoreArgc
;
#
ifdef
DEBUG
Label
twoArg
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
masm
.
branch32
(
Assembler
:
:
Equal
argcReg
Imm32
(
2
)
&
twoArg
)
;
masm
.
assumeUnreachable
(
"
Expected
argc
=
=
2
"
)
;
masm
.
bind
(
&
twoArg
)
;
#
endif
Register
scratchReg
=
regs
.
takeAny
(
)
;
{
Address
calleeAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
CALLEE_DEPTH
)
;
ValueOperand
calleeVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
calleeAddr
calleeVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
calleeVal
&
failureRestoreArgc
)
;
Register
calleeObj
=
masm
.
extractObject
(
calleeVal
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
calleeObj
scratchReg
&
JSFunction
:
:
class_
&
failureRestoreArgc
)
;
masm
.
loadPtr
(
Address
(
calleeObj
JSFunction
:
:
offsetOfNativeOrEnv
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
scratchReg
ImmPtr
(
js
:
:
intrinsic_StringSplitString
)
&
failureRestoreArgc
)
;
regs
.
add
(
calleeVal
)
;
}
{
Address
sepAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
SEP_DEPTH
)
;
ValueOperand
sepVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
sepAddr
sepVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
sepVal
&
failureRestoreArgc
)
;
Register
sep
=
masm
.
extractString
(
sepVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedSep
(
)
)
sep
&
failureRestoreArgc
)
;
regs
.
add
(
sepVal
)
;
}
{
Address
strAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
STR_DEPTH
)
;
ValueOperand
strVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
strAddr
strVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
strVal
&
failureRestoreArgc
)
;
Register
str
=
masm
.
extractString
(
strVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedStr
(
)
)
str
&
failureRestoreArgc
)
;
regs
.
add
(
strVal
)
;
}
{
Register
paramReg
=
regs
.
takeAny
(
)
;
enterStubFrame
(
masm
scratchReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetOfTemplateObject
(
)
)
paramReg
)
;
masm
.
push
(
paramReg
)
;
if
(
!
callVM
(
CopyArrayInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
regs
.
add
(
paramReg
)
;
}
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreArgc
)
;
masm
.
move32
(
Imm32
(
2
)
R0
.
scratchReg
(
)
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_IsSuspendedGenerator
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Address
argAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
ValueOperand
argVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
argAddr
argVal
)
;
Label
returnFalse
;
Register
genObj
=
regs
.
takeAny
(
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxObject
(
argVal
genObj
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
genObj
scratch
&
GeneratorObject
:
:
class_
&
returnFalse
)
;
masm
.
loadValue
(
Address
(
genObj
GeneratorObject
:
:
offsetOfYieldAndAwaitIndexSlot
(
)
)
argVal
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxInt32
(
argVal
scratch
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
scratch
Imm32
(
GeneratorObject
:
:
YIELD_AND_AWAIT_INDEX_CLOSING
)
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICCall_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
unsigned
skipToCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipToCallee
+
ICStackValueOffset
)
R1
)
;
}
else
{
unsigned
nonArgsSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Native
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
enterFakeExitFrameForNative
(
scratch
scratch
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
#
ifdef
JS_SIMULATOR
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_Native
:
:
offsetOfNative
(
)
)
)
;
#
else
if
(
ignoresReturnValue_
)
{
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfJitInfo
(
)
)
callee
)
;
masm
.
callWithABI
(
Address
(
callee
JSJitInfo
:
:
offsetOfIgnoresReturnValueNative
(
)
)
)
;
}
else
{
masm
.
callWithABI
(
Address
(
callee
JSFunction
:
:
offsetOfNative
(
)
)
)
;
}
#
endif
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ClassHook
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
unsigned
nonArgSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
loadObjClass
(
callee
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfClass
(
)
)
scratch
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
regs
.
add
(
scratch
)
;
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
regs
.
take
(
scratch
)
;
masm
.
checkStackAlignment
(
)
;
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
enterFakeExitFrameForNative
(
scratch
scratch
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfNative
(
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
FunApply_Array
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
Address
arrayVal
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
pushArrayArguments
(
masm
arrayVal
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
extractObject
(
arrayVal
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadJitCodeRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
TrampolinePtr
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
argumentsRectifier
target
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArguments
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
FunApply_MagicArgs
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
pushCallerArguments
(
masm
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadJitCodeRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
TrampolinePtr
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
argumentsRectifier
target
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedFunCall
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrEnv
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_call
)
&
failure
)
;
BaseIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
TimesEight
ICStackValueOffset
)
;
masm
.
loadValue
(
thisSlot
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
branchFunctionKind
(
Assembler
:
:
Equal
JSFunction
:
:
ClassConstructor
callee
regs
.
getAny
(
)
&
failure
)
;
Register
code
=
regs
.
takeAny
(
)
;
masm
.
loadJitCodeRaw
(
callee
code
&
failure
)
;
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
zeroArgs
done
;
masm
.
branchTest32
(
Assembler
:
:
Zero
argcReg
argcReg
&
zeroArgs
)
;
masm
.
sub32
(
Imm32
(
1
)
argcReg
)
;
pushCallArguments
(
masm
regs
argcReg
true
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
zeroArgs
)
;
Address
thisSlotFromStubFrame
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
thisSlotFromStubFrame
val
)
;
masm
.
alignJitStackBasedOnNArgs
(
0
)
;
masm
.
pushValue
(
UndefinedValue
(
)
)
;
masm
.
bind
(
&
done
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
callee
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
TrampolinePtr
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
argumentsRectifier
code
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoubleValueToInt32ForSwitch
(
Value
*
v
)
{
double
d
=
v
-
>
toDouble
(
)
;
int32_t
truncated
=
int32_t
(
d
)
;
if
(
d
!
=
double
(
truncated
)
)
return
false
;
v
-
>
setInt32
(
truncated
)
;
return
true
;
}
bool
ICTableSwitch
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
isInt32
notInt32
outOfRange
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
notInt32
)
;
Register
key
=
masm
.
extractInt32
(
R0
ExtractTemp0
)
;
masm
.
bind
(
&
isInt32
)
;
masm
.
load32
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
min_
)
)
scratch
)
;
masm
.
sub32
(
scratch
key
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
Address
(
ICStubReg
offsetof
(
ICTableSwitch
length_
)
)
key
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
table_
)
)
scratch
)
;
masm
.
loadPtr
(
BaseIndex
(
scratch
key
ScalePointer
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
notInt32
)
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
outOfRange
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
key
&
outOfRange
false
)
;
}
else
{
masm
.
pushValue
(
R0
)
;
masm
.
moveStackPtrTo
(
R0
.
scratchReg
(
)
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
R0
.
scratchReg
(
)
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
DoubleValueToInt32ForSwitch
)
)
;
masm
.
movePtr
(
ReturnReg
scratch
)
;
masm
.
popValue
(
R0
)
;
masm
.
branchIfFalseBool
(
scratch
&
outOfRange
)
;
masm
.
unboxInt32
(
R0
key
)
;
}
masm
.
jump
(
&
isInt32
)
;
masm
.
bind
(
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
defaultTarget_
)
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
ICStub
*
ICTableSwitch
:
:
Compiler
:
:
getStub
(
ICStubSpace
*
space
)
{
JitCode
*
code
=
getStubCode
(
)
;
if
(
!
code
)
return
nullptr
;
jsbytecode
*
pc
=
pc_
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc
)
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc
)
;
int32_t
length
=
high
-
low
+
1
;
pc
+
=
JUMP_OFFSET_LEN
;
void
*
*
table
=
(
void
*
*
)
space
-
>
alloc
(
sizeof
(
void
*
)
*
length
)
;
if
(
!
table
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
jsbytecode
*
defaultpc
=
pc_
+
GET_JUMP_OFFSET
(
pc_
)
;
for
(
int32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
int32_t
off
=
GET_JUMP_OFFSET
(
pc
)
;
if
(
off
)
table
[
i
]
=
pc_
+
off
;
else
table
[
i
]
=
defaultpc
;
pc
+
=
JUMP_OFFSET_LEN
;
}
return
newStub
<
ICTableSwitch
>
(
space
code
table
low
length
defaultpc
)
;
}
void
ICTableSwitch
:
:
fixupJumpTable
(
JSScript
*
script
BaselineScript
*
baseline
)
{
defaultTarget_
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
defaultTarget_
)
;
for
(
int32_t
i
=
0
;
i
<
length_
;
i
+
+
)
table_
[
i
]
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
table_
[
i
]
)
;
}
static
bool
DoGetIteratorFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIterator_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
FallbackICSpew
(
cx
stub
"
GetIterator
"
)
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetIteratorIRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
value
)
;
bool
attached
=
false
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Regular
engine
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
uint8_t
flags
=
GET_UINT8
(
pc
)
;
JSObject
*
iterobj
=
ValueToIterator
(
cx
flags
value
)
;
if
(
!
iterobj
)
return
false
;
res
.
setObject
(
*
iterobj
)
;
return
true
;
}
typedef
bool
(
*
DoGetIteratorFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetIterator_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoGetIteratorFallbackInfo
=
FunctionInfo
<
DoGetIteratorFallbackFn
>
(
DoGetIteratorFallback
"
DoGetIteratorFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICGetIterator_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetIteratorFallbackInfo
masm
)
;
}
static
bool
DoIteratorMoreFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIteratorMore_Fallback
*
stub_
HandleObject
iterObj
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIteratorMore_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
IteratorMore
"
)
;
if
(
!
IteratorMore
(
cx
iterObj
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
res
.
isMagic
(
JS_NO_ITER_VALUE
)
&
&
!
res
.
isString
(
)
)
stub
-
>
setHasNonStringResult
(
)
;
if
(
iterObj
-
>
is
<
PropertyIteratorObject
>
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
IteratorMore_Native
)
)
{
ICIteratorMore_Native
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
}
return
true
;
}
typedef
bool
(
*
DoIteratorMoreFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIteratorMore_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoIteratorMoreFallbackInfo
=
FunctionInfo
<
DoIteratorMoreFallbackFn
>
(
DoIteratorMoreFallback
"
DoIteratorMoreFallback
"
TailCall
)
;
bool
ICIteratorMore_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
unboxObject
(
R0
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoIteratorMoreFallbackInfo
masm
)
;
}
bool
ICIteratorMore_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
nativeIterator
=
regs
.
takeAny
(
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
obj
scratch
&
PropertyIteratorObject
:
:
class_
&
failure
)
;
masm
.
loadObjPrivate
(
obj
JSObject
:
:
ITER_CLASS_NFIXED_SLOTS
nativeIterator
)
;
Label
iterDone
;
Address
cursorAddr
(
nativeIterator
offsetof
(
NativeIterator
props_cursor
)
)
;
Address
cursorEndAddr
(
nativeIterator
offsetof
(
NativeIterator
props_end
)
)
;
masm
.
loadPtr
(
cursorAddr
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
BelowOrEqual
cursorEndAddr
scratch
&
iterDone
)
;
masm
.
loadPtr
(
Address
(
scratch
0
)
scratch
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
JSString
*
)
)
cursorAddr
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
scratch
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
iterDone
)
;
masm
.
moveValue
(
MagicValue
(
JS_NO_ITER_VALUE
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
void
DoIteratorCloseFallback
(
JSContext
*
cx
ICIteratorClose_Fallback
*
stub
HandleValue
iterValue
)
{
FallbackICSpew
(
cx
stub
"
IteratorClose
"
)
;
CloseIterator
(
&
iterValue
.
toObject
(
)
)
;
}
typedef
void
(
*
DoIteratorCloseFallbackFn
)
(
JSContext
*
ICIteratorClose_Fallback
*
HandleValue
)
;
static
const
VMFunction
DoIteratorCloseFallbackInfo
=
FunctionInfo
<
DoIteratorCloseFallbackFn
>
(
DoIteratorCloseFallback
"
DoIteratorCloseFallback
"
TailCall
)
;
bool
ICIteratorClose_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoIteratorCloseFallbackInfo
masm
)
;
}
static
bool
TryAttachInstanceOfStub
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleFunction
fun
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
fun
-
>
isBoundFunction
(
)
)
return
true
;
if
(
!
js
:
:
FunctionHasDefaultHasInstance
(
fun
cx
-
>
wellKnownSymbols
(
)
)
)
return
true
;
if
(
!
fun
-
>
hasStaticPrototype
(
)
|
|
fun
-
>
hasUncacheableProto
(
)
)
return
true
;
Value
funProto
=
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_Function
)
;
if
(
funProto
.
isObject
(
)
&
&
fun
-
>
staticPrototype
(
)
!
=
&
funProto
.
toObject
(
)
)
return
true
;
Shape
*
shape
=
fun
-
>
lookupPure
(
cx
-
>
names
(
)
.
prototype
)
;
if
(
!
shape
|
|
!
shape
-
>
isDataProperty
(
)
)
return
true
;
uint32_t
slot
=
shape
-
>
slot
(
)
;
MOZ_ASSERT
(
fun
-
>
numFixedSlots
(
)
=
=
0
"
Stub
code
relies
on
this
"
)
;
if
(
!
fun
-
>
getSlot
(
slot
)
.
isObject
(
)
)
return
true
;
JSObject
*
protoObject
=
&
fun
-
>
getSlot
(
slot
)
.
toObject
(
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
InstanceOf
(
Function
)
stub
"
)
;
ICInstanceOf_Function
:
:
Compiler
compiler
(
cx
fun
-
>
lastProperty
(
)
protoObject
slot
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
InstanceOf
"
)
;
if
(
!
rhs
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_BAD_INSTANCEOF_RHS
-
1
rhs
nullptr
)
;
return
false
;
}
RootedObject
obj
(
cx
&
rhs
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
HasInstance
(
cx
obj
lhs
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
EnsureTrackPropertyTypes
(
cx
obj
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICInstanceOf_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
bool
attached
=
false
;
if
(
!
TryAttachInstanceOfStub
(
cx
frame
stub
fun
&
attached
)
)
return
false
;
if
(
!
attached
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoInstanceOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICInstanceOf_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInstanceOfFallbackInfo
=
FunctionInfo
<
DoInstanceOfFallbackFn
>
(
DoInstanceOfFallback
"
DoInstanceOfFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICInstanceOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInstanceOfFallbackInfo
masm
)
;
}
bool
ICInstanceOf_Function
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
rhsObj
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Label
failureRestoreR1
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
regs
.
takeUnchecked
(
rhsObj
)
;
Register
scratch1
=
regs
.
takeAny
(
)
;
Register
scratch2
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfShape
(
)
)
scratch1
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
rhsObj
scratch1
&
failureRestoreR1
)
;
masm
.
loadPtr
(
Address
(
rhsObj
NativeObject
:
:
offsetOfSlots
(
)
)
scratch1
)
;
masm
.
load32
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfSlot
(
)
)
scratch2
)
;
BaseValueIndex
prototypeSlot
(
scratch1
scratch2
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
prototypeSlot
&
failureRestoreR1
)
;
masm
.
unboxObject
(
prototypeSlot
scratch1
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfPrototypeObject
(
)
)
scratch1
&
failureRestoreR1
)
;
Label
returnFalse
returnTrue
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
returnFalse
)
;
masm
.
unboxObject
(
R0
scratch2
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
{
Label
loop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
scratch1
&
returnTrue
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch2
scratch2
&
returnFalse
)
;
MOZ_ASSERT
(
uintptr_t
(
TaggedProto
:
:
LazyProto
)
=
=
1
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
ImmWord
(
1
)
&
failureRestoreR1
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
masm
.
jump
(
&
loop
)
;
}
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreR1
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
rhsObj
R1
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeOf_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
TypeOf
"
)
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
stub
-
>
discardStubs
(
cx
)
;
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
TypeOfIRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
val
)
;
bool
attached
=
false
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Regular
engine
script
stub
&
attached
)
;
if
(
newStub
)
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
}
if
(
!
attached
)
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
JSType
type
=
js
:
:
TypeOfValue
(
val
)
;
RootedString
string
(
cx
TypeName
(
type
cx
-
>
names
(
)
)
)
;
res
.
setString
(
string
)
;
return
true
;
}
typedef
bool
(
*
DoTypeOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
frame
ICTypeOf_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoTypeOfFallbackInfo
=
FunctionInfo
<
DoTypeOfFallbackFn
>
(
DoTypeOfFallback
"
DoTypeOfFallback
"
TailCall
)
;
bool
ICTypeOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoTypeOfFallbackInfo
masm
)
;
}
static
bool
DoRetSubFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRetSub_Fallback
*
stub
HandleValue
val
uint8_t
*
*
resumeAddr
)
{
FallbackICSpew
(
cx
stub
"
RetSub
"
)
;
MOZ_ASSERT
(
val
.
isInt32
(
)
)
;
MOZ_ASSERT
(
val
.
toInt32
(
)
>
=
0
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
uint32_t
offset
=
uint32_t
(
val
.
toInt32
(
)
)
;
*
resumeAddr
=
script
-
>
baselineScript
(
)
-
>
nativeCodeForPC
(
script
script
-
>
offsetToPC
(
offset
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICRetSub_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
RetSub
stub
for
pc
offset
%
u
"
offset
)
;
ICRetSub_Resume
:
:
Compiler
compiler
(
cx
offset
*
resumeAddr
)
;
ICStub
*
optStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
optStub
)
return
false
;
stub
-
>
addNewStub
(
optStub
)
;
return
true
;
}
typedef
bool
(
*
DoRetSubFallbackFn
)
(
JSContext
*
cx
BaselineFrame
*
ICRetSub_Fallback
*
HandleValue
uint8_t
*
*
)
;
static
const
VMFunction
DoRetSubFallbackInfo
=
FunctionInfo
<
DoRetSubFallbackFn
>
(
DoRetSubFallback
"
DoRetSubFallback
"
)
;
typedef
bool
(
*
ThrowFn
)
(
JSContext
*
HandleValue
)
;
static
const
VMFunction
ThrowInfoBaseline
=
FunctionInfo
<
ThrowFn
>
(
js
:
:
Throw
"
ThrowInfoBaseline
"
TailCall
)
;
bool
ICRetSub_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
{
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
regs
.
take
(
R1
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
Register
scratch
=
regs
.
getAny
(
)
;
enterStubFrame
(
masm
scratch
)
;
masm
.
pushValue
(
R1
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
scratch
)
;
if
(
!
callVM
(
DoRetSubFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitChangeICReturnAddress
(
masm
ReturnReg
)
;
EmitReturnFromIC
(
masm
)
;
}
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
return
tailCallVM
(
ThrowInfoBaseline
masm
)
;
}
bool
ICRetSub_Resume
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
fail
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
Register
offset
=
masm
.
extractInt32
(
R1
ExtractTemp0
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfPCOffset
(
)
)
offset
&
fail
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfAddr
(
)
)
R0
.
scratchReg
(
)
)
;
EmitChangeICReturnAddress
(
masm
R0
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
if
(
!
tailCallVM
(
ThrowInfoBaseline
masm
)
)
return
false
;
masm
.
bind
(
&
fail
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICTypeMonitor_SingleObject
:
:
ICTypeMonitor_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeMonitor_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeMonitor_ObjectGroup
:
:
ICTypeMonitor_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeMonitor_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICTypeUpdate_SingleObject
:
:
ICTypeUpdate_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeUpdate_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeUpdate_ObjectGroup
:
:
ICTypeUpdate_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeUpdate_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICGetIntrinsic_Constant
:
:
ICGetIntrinsic_Constant
(
JitCode
*
stubCode
const
Value
&
value
)
:
ICStub
(
GetIntrinsic_Constant
stubCode
)
value_
(
value
)
{
}
ICGetIntrinsic_Constant
:
:
~
ICGetIntrinsic_Constant
(
)
{
}
ICInstanceOf_Function
:
:
ICInstanceOf_Function
(
JitCode
*
stubCode
Shape
*
shape
JSObject
*
prototypeObj
uint32_t
slot
)
:
ICStub
(
InstanceOf_Function
stubCode
)
shape_
(
shape
)
prototypeObj_
(
prototypeObj
)
slot_
(
slot
)
{
}
ICCall_Scripted
:
:
ICCall_Scripted
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Scripted
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
}
ICCall_Scripted
*
ICCall_Scripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Scripted
&
other
)
{
return
New
<
ICCall_Scripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_AnyScripted
*
ICCall_AnyScripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_AnyScripted
&
other
)
{
return
New
<
ICCall_AnyScripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_Native
:
:
ICCall_Native
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Native
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
JS_FUNC_TO_DATA_PTR
(
void
*
callee
-
>
native
(
)
)
Args_General3
)
;
#
endif
}
ICCall_Native
*
ICCall_Native
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Native
&
other
)
{
return
New
<
ICCall_Native
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_ClassHook
:
:
ICCall_ClassHook
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
const
Class
*
clasp
Native
native
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_ClassHook
stubCode
firstMonitorStub
)
clasp_
(
clasp
)
native_
(
JS_FUNC_TO_DATA_PTR
(
void
*
native
)
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
native_
Args_General3
)
;
#
endif
}
ICCall_ClassHook
*
ICCall_ClassHook
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ClassHook
&
other
)
{
ICCall_ClassHook
*
res
=
New
<
ICCall_ClassHook
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
clasp
(
)
nullptr
other
.
templateObject_
other
.
pcOffset_
)
;
if
(
res
)
res
-
>
native_
=
other
.
native
(
)
;
return
res
;
}
ICCall_ScriptedApplyArray
*
ICCall_ScriptedApplyArray
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArray
&
other
)
{
return
New
<
ICCall_ScriptedApplyArray
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedApplyArguments
*
ICCall_ScriptedApplyArguments
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArguments
&
other
)
{
return
New
<
ICCall_ScriptedApplyArguments
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedFunCall
*
ICCall_ScriptedFunCall
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedFunCall
&
other
)
{
return
New
<
ICCall_ScriptedFunCall
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
static
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRest_Fallback
*
stub
MutableHandleValue
res
)
{
unsigned
numFormals
=
frame
-
>
numFormalArgs
(
)
-
1
;
unsigned
numActuals
=
frame
-
>
numActualArgs
(
)
;
unsigned
numRest
=
numActuals
>
numFormals
?
numActuals
-
numFormals
:
0
;
Value
*
rest
=
frame
-
>
argv
(
)
+
numFormals
;
ArrayObject
*
obj
=
ObjectGroup
:
:
newArrayObject
(
cx
rest
numRest
GenericObject
ObjectGroup
:
:
NewArrayKind
:
:
UnknownIndex
)
;
if
(
!
obj
)
return
false
;
res
.
setObject
(
*
obj
)
;
return
true
;
}
typedef
bool
(
*
DoRestFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICRest_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoRestFallbackInfo
=
FunctionInfo
<
DoRestFallbackFn
>
(
DoRestFallback
"
DoRestFallback
"
TailCall
)
;
bool
ICRest_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoRestFallbackInfo
masm
)
;
}
}
}
