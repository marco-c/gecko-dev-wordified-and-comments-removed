#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
jslibmath
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
builtin
/
SIMD
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
BaselineCacheIRCompiler
.
h
"
#
include
"
jit
/
BaselineDebugModeOSR
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
ifdef
JS_ION_PERF
#
include
"
jit
/
PerfSpewer
.
h
"
#
endif
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
TypedArrayCommon
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
jsboolinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
mozilla
:
:
DebugOnly
;
namespace
js
{
namespace
jit
{
struct
IonOsrTempData
{
void
*
jitcode
;
uint8_t
*
baselineFrame
;
}
;
static
IonOsrTempData
*
PrepareOsrTempData
(
JSContext
*
cx
ICWarmUpCounter_Fallback
*
stub
BaselineFrame
*
frame
HandleScript
script
jsbytecode
*
pc
void
*
jitcode
)
{
size_t
numLocalsAndStackVals
=
frame
-
>
numValueSlots
(
)
;
size_t
frameSpace
=
sizeof
(
BaselineFrame
)
+
sizeof
(
Value
)
*
numLocalsAndStackVals
;
size_t
ionOsrTempDataSpace
=
sizeof
(
IonOsrTempData
)
;
size_t
totalSpace
=
AlignBytes
(
frameSpace
sizeof
(
Value
)
)
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
IonOsrTempData
*
info
=
(
IonOsrTempData
*
)
cx
-
>
allocateOsrTempData
(
totalSpace
)
;
if
(
!
info
)
return
nullptr
;
memset
(
info
0
totalSpace
)
;
info
-
>
jitcode
=
jitcode
;
uint8_t
*
frameStart
=
(
uint8_t
*
)
info
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
info
-
>
baselineFrame
=
frameStart
+
frameSpace
;
memcpy
(
frameStart
(
uint8_t
*
)
frame
-
numLocalsAndStackVals
*
sizeof
(
Value
)
frameSpace
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Allocated
IonOsrTempData
at
%
p
"
(
void
*
)
info
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Jitcode
is
%
p
"
info
-
>
jitcode
)
;
return
info
;
}
static
bool
DoWarmUpCounterFallbackOSR
(
JSContext
*
cx
BaselineFrame
*
frame
ICWarmUpCounter_Fallback
*
stub
IonOsrTempData
*
*
infoPtr
)
{
MOZ_ASSERT
(
infoPtr
)
;
*
infoPtr
=
nullptr
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOP_LOOPENTRY
)
;
FallbackICSpew
(
cx
stub
"
WarmUpCounter
(
%
d
)
"
int
(
script
-
>
pcToOffset
(
pc
)
)
)
;
if
(
!
IonCompileScriptForBaseline
(
cx
frame
pc
)
)
return
false
;
if
(
!
script
-
>
hasIonScript
(
)
|
|
script
-
>
ionScript
(
)
-
>
osrPc
(
)
!
=
pc
|
|
script
-
>
ionScript
(
)
-
>
bailoutExpected
(
)
|
|
frame
-
>
isDebuggee
(
)
)
{
return
true
;
}
IonScript
*
ion
=
script
-
>
ionScript
(
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
=
=
ion
-
>
hasProfilingInstrumentation
(
)
)
;
MOZ_ASSERT
(
ion
-
>
osrPc
(
)
=
=
pc
)
;
JitSpew
(
JitSpew_BaselineOSR
"
OSR
possible
!
"
)
;
void
*
jitcode
=
ion
-
>
method
(
)
-
>
raw
(
)
+
ion
-
>
osrEntryOffset
(
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Got
jitcode
.
Preparing
for
OSR
into
ion
.
"
)
;
IonOsrTempData
*
info
=
PrepareOsrTempData
(
cx
stub
frame
script
pc
jitcode
)
;
if
(
!
info
)
return
false
;
*
infoPtr
=
info
;
return
true
;
}
typedef
bool
(
*
DoWarmUpCounterFallbackOSRFn
)
(
JSContext
*
BaselineFrame
*
ICWarmUpCounter_Fallback
*
IonOsrTempData
*
*
infoPtr
)
;
static
const
VMFunction
DoWarmUpCounterFallbackOSRInfo
=
FunctionInfo
<
DoWarmUpCounterFallbackOSRFn
>
(
DoWarmUpCounterFallbackOSR
"
DoWarmUpCounterFallbackOSR
"
)
;
bool
ICWarmUpCounter_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
Label
noCompiledCode
;
{
masm
.
subFromStackPtr
(
Imm32
(
sizeof
(
void
*
)
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoWarmUpCounterFallbackOSRInfo
masm
)
)
return
false
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
leaveStubFrame
(
masm
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
R0
.
scratchReg
(
)
ImmPtr
(
nullptr
)
&
noCompiledCode
)
;
}
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
osrDataReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
osrDataReg
)
;
regs
.
takeUnchecked
(
OsrFrameReg
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
masm
.
moveToStackPtr
(
BaselineFrameReg
)
;
masm
.
pop
(
scratchReg
)
;
#
ifdef
DEBUG
{
Label
checkOk
;
AbsoluteAddress
addressOfEnabled
(
cx
-
>
runtime
(
)
-
>
geckoProfiler
(
)
.
addressOfEnabled
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Equal
addressOfEnabled
Imm32
(
0
)
&
checkOk
)
;
masm
.
loadPtr
(
AbsoluteAddress
(
(
void
*
)
&
cx
-
>
jitActivation
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
scratchReg
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratchReg
ImmWord
(
0
)
&
checkOk
)
;
masm
.
branchStackPtr
(
Assembler
:
:
Equal
scratchReg
&
checkOk
)
;
masm
.
assumeUnreachable
(
"
Baseline
OSR
lastProfilingFrame
mismatch
.
"
)
;
masm
.
bind
(
&
checkOk
)
;
}
#
endif
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
jitcode
)
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
baselineFrame
)
)
OsrFrameReg
)
;
masm
.
jump
(
scratchReg
)
;
masm
.
bind
(
&
noCompiledCode
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoTypeUpdateFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICUpdatedStub
*
stub
HandleValue
objval
HandleValue
value
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
FallbackICSpew
(
cx
stub
-
>
getChainFallback
(
)
"
TypeUpdate
(
%
s
)
"
ICStub
:
:
KindString
(
stub
-
>
kind
(
)
)
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedObject
obj
(
cx
&
objval
.
toObject
(
)
)
;
RootedId
id
(
cx
)
;
switch
(
stub
-
>
kind
(
)
)
{
case
ICStub
:
:
CacheIR_Updated
:
{
id
=
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
;
MOZ_ASSERT
(
id
!
=
JSID_EMPTY
)
;
RootedObjectGroup
group
(
cx
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
)
;
#
ifdef
DEBUG
if
(
obj
-
>
is
<
UnboxedExpandoObject
>
(
)
)
MOZ_ASSERT
(
group
-
>
clasp
(
)
=
=
&
UnboxedPlainObject
:
:
class_
)
;
else
MOZ_ASSERT
(
obj
-
>
group
(
)
=
=
group
)
;
#
endif
if
(
MOZ_UNLIKELY
(
obj
-
>
is
<
TypedObject
>
(
)
)
&
&
value
.
isNullOrUndefined
(
)
)
{
StructTypeDescr
*
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
MOZ_ALWAYS_TRUE
(
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
ReferenceTypeDescr
:
:
Type
type
=
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
if
(
type
=
=
ReferenceTypeDescr
:
:
TYPE_ANY
)
{
if
(
value
.
isUndefined
(
)
)
break
;
}
else
{
MOZ_ASSERT
(
type
=
=
ReferenceTypeDescr
:
:
TYPE_OBJECT
)
;
if
(
value
.
isNull
(
)
)
break
;
}
}
JSObject
*
maybeSingleton
=
obj
-
>
isSingleton
(
)
?
obj
.
get
(
)
:
nullptr
;
AddTypePropertyId
(
cx
group
maybeSingleton
id
value
)
;
break
;
}
case
ICStub
:
:
SetElem_DenseOrUnboxedArray
:
case
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
:
{
id
=
JSID_VOID
;
AddTypePropertyId
(
cx
obj
id
value
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Invalid
stub
"
)
;
}
return
stub
-
>
addUpdateStubForValue
(
cx
script
obj
id
value
)
;
}
typedef
bool
(
*
DoTypeUpdateFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICUpdatedStub
*
HandleValue
HandleValue
)
;
const
VMFunction
DoTypeUpdateFallbackInfo
=
FunctionInfo
<
DoTypeUpdateFallbackFn
>
(
DoTypeUpdateFallback
"
DoTypeUpdateFallback
"
NonTailCall
)
;
bool
ICTypeUpdate_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
move32
(
Imm32
(
0
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_PrimitiveSet
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
success
;
if
(
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_INT32
)
)
&
&
!
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
)
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
masm
.
branchTestNumber
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_UNDEFINED
)
)
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_BOOLEAN
)
)
masm
.
branchTestBoolean
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_STRING
)
)
masm
.
branchTestString
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_SYMBOL
)
)
masm
.
branchTestSymbol
(
Assembler
:
:
Equal
R0
&
success
)
;
MOZ_ASSERT
(
!
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_OBJECT
)
)
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_NULL
)
)
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
success
)
;
EmitStubGuardFailure
(
masm
)
;
masm
.
bind
(
&
success
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_SingleObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
Address
expectedObject
(
ICStubReg
ICTypeUpdate_SingleObject
:
:
offsetOfObject
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedObject
obj
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_ObjectGroup
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
R1
.
scratchReg
(
)
)
;
Address
expectedGroup
(
ICStubReg
ICTypeUpdate_ObjectGroup
:
:
offsetOfGroup
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedGroup
R1
.
scratchReg
(
)
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToBool_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToBool
"
)
;
bool
cond
=
ToBoolean
(
arg
)
;
ret
.
setBoolean
(
cond
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICToBool_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
MOZ_ASSERT
(
!
arg
.
isBoolean
(
)
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
if
(
arg
.
isInt32
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Int32
)
stub
.
"
)
;
ICToBool_Int32
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
int32Stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
int32Stub
)
return
false
;
stub
-
>
addNewStub
(
int32Stub
)
;
return
true
;
}
if
(
arg
.
isDouble
(
)
&
&
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Double
)
stub
.
"
)
;
ICToBool_Double
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
doubleStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
doubleStub
)
return
false
;
stub
-
>
addNewStub
(
doubleStub
)
;
return
true
;
}
if
(
arg
.
isString
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
String
)
stub
"
)
;
ICToBool_String
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stringStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
stringStub
)
return
false
;
stub
-
>
addNewStub
(
stringStub
)
;
return
true
;
}
if
(
arg
.
isNull
(
)
|
|
arg
.
isUndefined
(
)
)
{
ICToBool_NullUndefined
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
nilStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
nilStub
)
return
false
;
stub
-
>
addNewStub
(
nilStub
)
;
return
true
;
}
if
(
arg
.
isObject
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Object
)
stub
.
"
)
;
ICToBool_Object
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
objStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
objStub
)
return
false
;
stub
-
>
addNewStub
(
objStub
)
;
return
true
;
}
return
true
;
}
typedef
bool
(
*
pf
)
(
JSContext
*
BaselineFrame
*
ICToBool_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
fun
=
FunctionInfo
<
pf
>
(
DoToBoolFallback
"
DoToBoolFallback
"
TailCall
)
;
bool
ICToBool_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
fun
masm
)
;
}
bool
ICToBool_Int32
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestInt32Truthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_String
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestStringTruthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_NullUndefined
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifFalse
;
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
ifFalse
)
;
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Double
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifTrue
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
branchTestDoubleTruthy
(
true
FloatReg0
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Object
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifFalse
slowPath
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchTestObjectTruthy
(
false
objReg
scratch
&
slowPath
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
slowPath
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
objReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
js
:
:
EmulatesUndefined
)
)
;
masm
.
convertBoolToInt32
(
ReturnReg
ReturnReg
)
;
masm
.
xor32
(
Imm32
(
1
)
ReturnReg
)
;
masm
.
tagValue
(
JSVAL_TYPE_BOOLEAN
ReturnReg
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoToNumberFallback
(
JSContext
*
cx
ICToNumber_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToNumber
"
)
;
ret
.
set
(
arg
)
;
return
ToNumber
(
cx
ret
)
;
}
typedef
bool
(
*
DoToNumberFallbackFn
)
(
JSContext
*
ICToNumber_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoToNumberFallbackInfo
=
FunctionInfo
<
DoToNumberFallbackFn
>
(
DoToNumberFallback
"
DoToNumberFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICToNumber_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoToNumberFallbackInfo
masm
)
;
}
static
bool
IsOptimizableElementPropertyName
(
JSContext
*
cx
HandleValue
key
MutableHandleId
idp
)
{
if
(
!
key
.
isString
(
)
)
return
false
;
if
(
!
ValueToId
<
CanGC
>
(
cx
key
idp
)
)
return
false
;
uint32_t
dummy
;
if
(
!
JSID_IS_ATOM
(
idp
)
|
|
JSID_TO_ATOM
(
idp
)
-
>
isIndex
(
&
dummy
)
)
return
false
;
return
true
;
}
bool
IsPrimitiveArrayTypedObject
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
return
false
;
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
is
<
ArrayTypeDescr
>
(
)
&
&
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
is
<
ScalarTypeDescr
>
(
)
;
}
static
Scalar
:
:
Type
PrimitiveArrayTypedObjectType
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsPrimitiveArrayTypedObject
(
obj
)
)
;
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
}
Scalar
:
:
Type
TypedThingElementType
(
JSObject
*
obj
)
{
return
obj
-
>
is
<
TypedArrayObject
>
(
)
?
obj
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
:
PrimitiveArrayTypedObjectType
(
obj
)
;
}
bool
TypedThingRequiresFloatingPoint
(
JSObject
*
obj
)
{
Scalar
:
:
Type
type
=
TypedThingElementType
(
obj
)
;
return
type
=
=
Scalar
:
:
Uint32
|
|
type
=
=
Scalar
:
:
Float32
|
|
type
=
=
Scalar
:
:
Float64
;
}
static
bool
IsNativeOrUnboxedDenseElementAccess
(
HandleObject
obj
HandleValue
key
)
{
if
(
!
obj
-
>
isNative
(
)
&
&
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
if
(
key
.
isInt32
(
)
&
&
key
.
toInt32
(
)
>
=
0
&
&
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
return
true
;
return
false
;
}
static
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub_
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICGetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElem
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETELEM
|
|
op
=
=
JSOP_CALLELEM
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
bool
isOptimizedArgs
=
false
;
if
(
lhs
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GetElemOptimizedArguments
(
cx
frame
&
lhsCopy
rhs
res
&
isOptimizedArgs
)
)
return
false
;
if
(
isOptimizedArgs
)
TypeScript
:
:
Monitor
(
cx
frame
-
>
script
(
)
pc
res
)
;
}
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICGetElem_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
stub
-
>
noteUnoptimizableAccess
(
)
;
attached
=
true
;
}
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
attached
&
&
!
JitOptions
.
disableCacheIR
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetPropIRGenerator
gen
(
cx
pc
CacheKind
:
:
GetElem
engine
&
isTemporarilyUnoptimizable
lhs
rhs
CanAttachGetter
:
:
Yes
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
engine
info
.
outerScript
(
cx
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Monitored
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
if
(
!
isOptimizedArgs
)
{
if
(
!
GetElementOperation
(
cx
op
lhsCopy
rhs
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
frame
-
>
script
(
)
pc
res
)
;
}
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
attached
)
return
true
;
if
(
lhs
.
isObject
(
)
&
&
!
lhs
.
toObject
(
)
.
isNative
(
)
)
stub
-
>
noteNonNativeAccess
(
)
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
stub
-
>
noteNegativeIndex
(
)
;
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoGetElemFallbackInfo
=
FunctionInfo
<
DoGetElemFallbackFn
>
(
DoGetElemFallback
"
DoGetElemFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICGetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetElemFallbackInfo
masm
)
;
}
void
LoadTypedThingLength
(
MacroAssembler
&
masm
TypedThingLayout
layout
Register
obj
Register
result
)
{
switch
(
layout
)
{
case
Layout_TypedArray
:
masm
.
unboxInt32
(
Address
(
obj
TypedArrayObject
:
:
lengthOffset
(
)
)
result
)
;
break
;
case
Layout_OutlineTypedObject
:
case
Layout_InlineTypedObject
:
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
result
)
;
masm
.
loadPtr
(
Address
(
result
ObjectGroup
:
:
offsetOfAddendum
(
)
)
result
)
;
masm
.
unboxInt32
(
Address
(
result
ArrayTypeDescr
:
:
offsetOfLength
(
)
)
result
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
static
bool
SetElemAddHasSameShapes
(
ICSetElem_DenseOrUnboxedArrayAdd
*
stub
JSObject
*
obj
)
{
static
const
size_t
MAX_DEPTH
=
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
;
ICSetElem_DenseOrUnboxedArrayAddImpl
<
MAX_DEPTH
>
*
nstub
=
stub
-
>
toImplUnchecked
<
MAX_DEPTH
>
(
)
;
if
(
obj
-
>
maybeShape
(
)
!
=
nstub
-
>
shape
(
0
)
)
return
false
;
JSObject
*
proto
=
obj
-
>
staticPrototype
(
)
;
for
(
size_t
i
=
0
;
i
<
stub
-
>
protoChainDepth
(
)
;
i
+
+
)
{
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
nstub
-
>
shape
(
i
+
1
)
)
return
false
;
proto
=
obj
-
>
staticPrototype
(
)
;
if
(
!
proto
)
{
if
(
i
!
=
stub
-
>
protoChainDepth
(
)
-
1
)
return
false
;
break
;
}
}
return
true
;
}
static
bool
DenseOrUnboxedArraySetElemStubExists
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICSetElem_Fallback
*
stub
HandleObject
obj
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArray
|
|
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
)
;
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArray
&
&
iter
-
>
isSetElem_DenseOrUnboxedArray
(
)
)
{
ICSetElem_DenseOrUnboxedArray
*
nstub
=
iter
-
>
toSetElem_DenseOrUnboxedArray
(
)
;
if
(
obj
-
>
maybeShape
(
)
=
=
nstub
-
>
shape
(
)
&
&
JSObject
:
:
getGroup
(
cx
obj
)
=
=
nstub
-
>
group
(
)
)
{
return
true
;
}
}
if
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
&
&
iter
-
>
isSetElem_DenseOrUnboxedArrayAdd
(
)
)
{
ICSetElem_DenseOrUnboxedArrayAdd
*
nstub
=
iter
-
>
toSetElem_DenseOrUnboxedArrayAdd
(
)
;
if
(
JSObject
:
:
getGroup
(
cx
obj
)
=
=
nstub
-
>
group
(
)
&
&
SetElemAddHasSameShapes
(
nstub
obj
)
)
{
return
true
;
}
}
}
return
false
;
}
static
bool
TypedArraySetElemStubExists
(
ICSetElem_Fallback
*
stub
HandleObject
obj
bool
expectOOB
)
{
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isSetElem_TypedArray
(
)
)
continue
;
ICSetElem_TypedArray
*
taStub
=
iter
-
>
toSetElem_TypedArray
(
)
;
if
(
obj
-
>
maybeShape
(
)
=
=
taStub
-
>
shape
(
)
&
&
taStub
-
>
expectOutOfBounds
(
)
=
=
expectOOB
)
return
true
;
}
return
false
;
}
static
bool
RemoveExistingTypedArraySetElemStub
(
JSContext
*
cx
ICSetElem_Fallback
*
stub
HandleObject
obj
)
{
for
(
ICStubIterator
iter
=
stub
-
>
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isSetElem_TypedArray
(
)
)
continue
;
if
(
obj
-
>
maybeShape
(
)
!
=
iter
-
>
toSetElem_TypedArray
(
)
-
>
shape
(
)
)
continue
;
MOZ_ASSERT
(
!
iter
-
>
toSetElem_TypedArray
(
)
-
>
expectOutOfBounds
(
)
)
;
iter
.
unlink
(
cx
)
;
return
true
;
}
return
false
;
}
static
bool
CanOptimizeDenseOrUnboxedArraySetElem
(
JSObject
*
obj
uint32_t
index
Shape
*
oldShape
uint32_t
oldCapacity
uint32_t
oldInitLength
bool
*
isAddingCaseOut
size_t
*
protoDepthOut
)
{
uint32_t
initLength
=
GetAnyBoxedOrUnboxedInitializedLength
(
obj
)
;
uint32_t
capacity
=
GetAnyBoxedOrUnboxedCapacity
(
obj
)
;
*
isAddingCaseOut
=
false
;
*
protoDepthOut
=
0
;
if
(
initLength
<
oldInitLength
|
|
capacity
<
oldCapacity
)
return
false
;
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
&
&
!
obj
-
>
runtimeFromMainThread
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
if
(
oldShape
!
=
shape
)
return
false
;
if
(
oldCapacity
!
=
capacity
)
return
false
;
if
(
index
>
=
initLength
)
return
false
;
if
(
obj
-
>
isNative
(
)
&
&
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
if
(
oldInitLength
=
=
initLength
)
return
true
;
if
(
oldInitLength
+
1
!
=
initLength
)
return
false
;
if
(
index
!
=
oldInitLength
)
return
false
;
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
JSObject
*
curObj
=
obj
-
>
staticPrototype
(
)
;
while
(
curObj
)
{
+
+
*
protoDepthOut
;
if
(
!
curObj
-
>
isNative
(
)
|
|
curObj
-
>
isIndexed
(
)
)
return
false
;
curObj
=
curObj
-
>
staticPrototype
(
)
;
}
if
(
*
protoDepthOut
>
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
)
return
false
;
*
isAddingCaseOut
=
true
;
return
true
;
}
static
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetElem_Fallback
*
stub_
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
{
DebugModeOSRVolatileStub
<
ICSetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedScript
outerScript
(
cx
script
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetElem
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETELEM
|
|
op
=
=
JSOP_STRICTSETELEM
|
|
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
|
|
op
=
=
JSOP_INITELEM_ARRAY
|
|
op
=
=
JSOP_INITELEM_INC
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
objv
)
)
;
if
(
!
obj
)
return
false
;
bool
isTemporarilyUnoptimizable
=
false
;
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
<
ICSetElem_Fallback
:
:
MAX_OPTIMIZED_STUBS
&
&
!
JitOptions
.
disableCacheIR
)
{
SetPropIRGenerator
gen
(
cx
pc
CacheKind
:
:
SetElem
&
isTemporarilyUnoptimizable
objv
index
rhs
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
if
(
gen
.
needUpdateStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
=
gen
.
updateStubGroup
(
)
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
=
gen
.
updateStubId
(
)
;
}
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
return
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
uint32_t
oldCapacity
=
0
;
uint32_t
oldInitLength
=
0
;
if
(
index
.
isInt32
(
)
&
&
index
.
toInt32
(
)
>
=
0
)
{
oldCapacity
=
GetAnyBoxedOrUnboxedCapacity
(
obj
)
;
oldInitLength
=
GetAnyBoxedOrUnboxedInitializedLength
(
obj
)
;
}
if
(
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
)
{
if
(
!
InitElemOperation
(
cx
pc
obj
index
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_ARRAY
)
{
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
<
=
INT32_MAX
"
the
bytecode
emitter
must
fail
to
compile
code
that
would
"
"
produce
JSOP_INITELEM_ARRAY
with
an
index
exceeding
"
"
int32_t
range
"
)
;
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
=
=
GET_UINT32
(
pc
)
)
;
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_INC
)
{
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
{
if
(
!
SetObjectElement
(
cx
obj
index
rhs
objv
JSOp
(
*
pc
)
=
=
JSOP_STRICTSETELEM
script
pc
)
)
return
false
;
}
if
(
op
=
=
JSOP_INITHIDDENELEM
)
return
true
;
MOZ_ASSERT
(
stack
[
2
]
=
=
objv
)
;
stack
[
2
]
=
rhs
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
attached
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICSetElem_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
if
(
!
JitOptions
.
disableCacheIR
)
{
SetPropIRGenerator
gen
(
cx
pc
CacheKind
:
:
SetElem
&
isTemporarilyUnoptimizable
objv
index
rhs
)
;
if
(
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
=
gen
.
updateStubGroup
(
)
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
=
gen
.
updateStubId
(
)
;
return
true
;
}
}
}
if
(
IsNativeOrUnboxedDenseElementAccess
(
obj
index
)
&
&
!
rhs
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
{
bool
addingCase
;
size_t
protoDepth
;
if
(
CanOptimizeDenseOrUnboxedArraySetElem
(
obj
index
.
toInt32
(
)
oldShape
oldCapacity
oldInitLength
&
addingCase
&
protoDepth
)
)
{
RootedShape
shape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
group
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
group
)
return
false
;
if
(
addingCase
&
&
!
DenseOrUnboxedArraySetElemStubExists
(
cx
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
stub
obj
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_DenseOrUnboxedArrayAdd
stub
"
"
(
shape
=
%
p
group
=
%
p
protoDepth
=
%
"
PRIuSIZE
"
)
"
shape
.
get
(
)
group
.
get
(
)
protoDepth
)
;
ICSetElemDenseOrUnboxedArrayAddCompiler
compiler
(
cx
obj
protoDepth
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
outerScript
obj
JSID_VOIDHANDLE
rhs
)
)
{
return
false
;
}
stub
-
>
addNewStub
(
newStub
)
;
}
else
if
(
!
addingCase
&
&
!
DenseOrUnboxedArraySetElemStubExists
(
cx
ICStub
:
:
SetElem_DenseOrUnboxedArray
stub
obj
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_DenseOrUnboxedArray
stub
(
shape
=
%
p
group
=
%
p
)
"
shape
.
get
(
)
group
.
get
(
)
)
;
ICSetElem_DenseOrUnboxedArray
:
:
Compiler
compiler
(
cx
shape
group
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
outerScript
obj
JSID_VOIDHANDLE
rhs
)
)
{
return
false
;
}
stub
-
>
addNewStub
(
newStub
)
;
}
}
return
true
;
}
if
(
(
obj
-
>
is
<
TypedArrayObject
>
(
)
|
|
IsPrimitiveArrayTypedObject
(
obj
)
)
&
&
index
.
isNumber
(
)
&
&
rhs
.
isNumber
(
)
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
(
TypedThingRequiresFloatingPoint
(
obj
)
|
|
index
.
isDouble
(
)
)
)
{
return
true
;
}
bool
expectOutOfBounds
;
double
idx
=
index
.
toNumber
(
)
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
expectOutOfBounds
=
(
idx
<
0
|
|
idx
>
=
double
(
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
)
;
}
else
{
if
(
idx
<
0
|
|
idx
>
=
double
(
obj
-
>
as
<
TypedObject
>
(
)
.
length
(
)
)
)
return
true
;
expectOutOfBounds
=
false
;
if
(
cx
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
true
;
}
if
(
!
TypedArraySetElemStubExists
(
stub
obj
expectOutOfBounds
)
)
{
if
(
expectOutOfBounds
)
RemoveExistingTypedArraySetElemStub
(
cx
stub
obj
)
;
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
Scalar
:
:
Type
type
=
TypedThingElementType
(
obj
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_TypedArray
stub
(
shape
=
%
p
type
=
%
u
oob
=
%
s
)
"
shape
type
expectOutOfBounds
?
"
yes
"
:
"
no
"
)
;
ICSetElem_TypedArray
:
:
Compiler
compiler
(
cx
shape
type
expectOutOfBounds
)
;
ICStub
*
typedArrayStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
typedArrayStub
)
return
false
;
stub
-
>
addNewStub
(
typedArrayStub
)
;
return
true
;
}
}
return
true
;
}
typedef
bool
(
*
DoSetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetElem_Fallback
*
Value
*
HandleValue
HandleValue
HandleValue
)
;
static
const
VMFunction
DoSetElemFallbackInfo
=
FunctionInfo
<
DoSetElemFallbackFn
>
(
DoSetElemFallback
"
DoSetElemFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICSetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
R1
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
moveStackPtrTo
(
R1
.
scratchReg
(
)
)
;
masm
.
pushValue
(
Address
(
R1
.
scratchReg
(
)
2
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoSetElemFallbackInfo
masm
)
;
}
void
BaselineScript
:
:
noteArrayWriteHole
(
uint32_t
pcOffset
)
{
ICEntry
&
entry
=
icEntryFromPCOffset
(
pcOffset
)
;
ICFallbackStub
*
stub
=
entry
.
fallbackStub
(
)
;
if
(
stub
-
>
isSetElem_Fallback
(
)
)
stub
-
>
toSetElem_Fallback
(
)
-
>
noteArrayWriteHole
(
)
;
}
void
EmitUnboxedPreBarrierForBaseline
(
MacroAssembler
&
masm
const
BaseIndex
&
address
JSValueType
type
)
{
if
(
type
=
=
JSVAL_TYPE_OBJECT
)
EmitPreBarrier
(
masm
address
MIRType
:
:
Object
)
;
else
if
(
type
=
=
JSVAL_TYPE_STRING
)
EmitPreBarrier
(
masm
address
MIRType
:
:
String
)
;
else
MOZ_ASSERT
(
!
UnboxedTypeNeedsPreBarrier
(
type
)
)
;
}
bool
ICSetElem_DenseOrUnboxedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArray
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArray
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
}
if
(
needsUpdateStubs
(
)
)
{
EmitStowICValues
(
masm
2
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
+
ICStackValueOffset
)
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
Push
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
+
ICStackValueOffset
)
R1
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
addUnchecked
(
obj
)
;
saveRegs
.
add
(
ICStubReg
)
;
BaselineEmitPostWriteBarrierSlot
(
masm
obj
R1
scratchReg
saveRegs
cx
)
;
masm
.
Pop
(
R1
)
;
}
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
key
&
failure
)
;
BaseIndex
element
(
scratchReg
key
TimesEight
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
element
&
failure
)
;
Label
noSpecialHandling
;
Address
elementsFlags
(
scratchReg
ObjectElements
:
:
offsetOfFlags
(
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
|
ObjectElements
:
:
COPY_ON_WRITE
|
ObjectElements
:
:
FROZEN
)
&
noSpecialHandling
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
elementsFlags
Imm32
(
ObjectElements
:
:
COPY_ON_WRITE
|
ObjectElements
:
:
FROZEN
)
&
failure
)
;
regs
.
add
(
R0
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
masm
.
convertInt32ValueToDouble
(
valueAddr
regs
.
getAny
(
)
&
noSpecialHandling
)
;
else
masm
.
assumeUnreachable
(
"
There
shouldn
'
t
be
double
arrays
when
there
is
no
FP
support
.
"
)
;
masm
.
bind
(
&
noSpecialHandling
)
;
ValueOperand
tmpVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
valueAddr
tmpVal
)
;
EmitPreBarrier
(
masm
element
MIRType
:
:
Value
)
;
masm
.
storeValue
(
tmpVal
element
)
;
}
else
{
Address
initLength
(
obj
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
;
masm
.
load32
(
initLength
scratchReg
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
BaseIndex
address
(
scratchReg
key
ScaleFromElemWidth
(
UnboxedTypeSize
(
unboxedType_
)
)
)
;
EmitUnboxedPreBarrierForBaseline
(
masm
address
unboxedType_
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
Push
(
R0
)
;
masm
.
loadValue
(
valueAddr
R0
)
;
masm
.
storeUnboxedProperty
(
address
unboxedType_
ConstantOrRegister
(
TypedOrValueRegister
(
R0
)
)
&
failurePopR0
)
;
masm
.
Pop
(
R0
)
;
}
EmitReturnFromIC
(
masm
)
;
if
(
failurePopR0
.
used
(
)
)
{
masm
.
bind
(
&
failurePopR0
)
;
masm
.
popValue
(
R0
)
;
}
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICUpdatedStub
*
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
getStub
(
ICStubSpace
*
space
)
{
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
if
(
!
shapes
.
append
(
obj_
-
>
maybeShape
(
)
)
)
return
nullptr
;
if
(
!
GetProtoShapes
(
obj_
protoChainDepth_
&
shapes
)
)
return
nullptr
;
JS_STATIC_ASSERT
(
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
=
=
4
)
;
ICUpdatedStub
*
stub
=
nullptr
;
switch
(
protoChainDepth_
)
{
case
0
:
stub
=
getStubSpecific
<
0
>
(
space
shapes
)
;
break
;
case
1
:
stub
=
getStubSpecific
<
1
>
(
space
shapes
)
;
break
;
case
2
:
stub
=
getStubSpecific
<
2
>
(
space
shapes
)
;
break
;
case
3
:
stub
=
getStubSpecific
<
3
>
(
space
shapes
)
;
break
;
case
4
:
stub
=
getStubSpecific
<
4
>
(
space
shapes
)
;
break
;
default
:
MOZ_CRASH
(
"
ProtoChainDepth
too
high
.
"
)
;
}
if
(
!
stub
|
|
!
stub
-
>
initUpdatingChain
(
cx
space
)
)
return
nullptr
;
return
stub
;
}
bool
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0
failureUnstow
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAdd
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAddImpl
<
0
>
:
:
offsetOfShape
(
0
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
}
EmitStowICValues
(
masm
2
)
;
uint32_t
framePushedAfterStow
=
masm
.
framePushed
(
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
take
(
R0
)
;
regs
.
take
(
scratchReg
)
;
Register
protoReg
=
regs
.
takeAny
(
)
;
for
(
size_t
i
=
0
;
i
<
protoChainDepth_
;
i
+
+
)
{
masm
.
loadObjProto
(
i
=
=
0
?
obj
:
protoReg
protoReg
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
protoReg
protoReg
&
failureUnstow
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAddImpl
<
0
>
:
:
offsetOfShape
(
i
+
1
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
scratchReg
&
failureUnstow
)
;
}
regs
.
add
(
protoReg
)
;
regs
.
add
(
scratchReg
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
+
ICStackValueOffset
)
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
}
EmitUnstowICValues
(
masm
2
)
;
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
Push
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
+
ICStackValueOffset
)
R1
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
addUnchecked
(
obj
)
;
saveRegs
.
add
(
ICStubReg
)
;
BaselineEmitPostWriteBarrierSlot
(
masm
obj
R1
scratchReg
saveRegs
cx
)
;
masm
.
Pop
(
R1
)
;
}
regs
=
availableGeneralRegs
(
2
)
;
scratchReg
=
regs
.
takeAny
(
)
;
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
initLength
key
&
failure
)
;
Address
capacity
(
scratchReg
ObjectElements
:
:
offsetOfCapacity
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
capacity
key
&
failure
)
;
Address
elementsFlags
(
scratchReg
ObjectElements
:
:
offsetOfFlags
(
)
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
elementsFlags
Imm32
(
ObjectElements
:
:
COPY_ON_WRITE
|
ObjectElements
:
:
FROZEN
)
&
failure
)
;
regs
.
add
(
R0
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
masm
.
add32
(
Imm32
(
1
)
initLength
)
;
Label
skipIncrementLength
;
Address
length
(
scratchReg
ObjectElements
:
:
offsetOfLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Above
length
key
&
skipIncrementLength
)
;
masm
.
add32
(
Imm32
(
1
)
length
)
;
masm
.
bind
(
&
skipIncrementLength
)
;
Label
dontConvertDoubles
;
masm
.
branchTest32
(
Assembler
:
:
Zero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
)
&
dontConvertDoubles
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
masm
.
convertInt32ValueToDouble
(
valueAddr
regs
.
getAny
(
)
&
dontConvertDoubles
)
;
else
masm
.
assumeUnreachable
(
"
There
shouldn
'
t
be
double
arrays
when
there
is
no
FP
support
.
"
)
;
masm
.
bind
(
&
dontConvertDoubles
)
;
ValueOperand
tmpVal
=
regs
.
takeAnyValue
(
)
;
BaseIndex
element
(
scratchReg
key
TimesEight
)
;
masm
.
loadValue
(
valueAddr
tmpVal
)
;
masm
.
storeValue
(
tmpVal
element
)
;
}
else
{
Address
initLengthAddr
(
obj
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
;
masm
.
load32
(
initLengthAddr
scratchReg
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
scratchReg
key
&
failure
)
;
masm
.
checkUnboxedArrayCapacity
(
obj
RegisterOrInt32Constant
(
key
)
scratchReg
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
masm
.
Push
(
R0
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
valueAddr
R0
)
;
BaseIndex
address
(
scratchReg
key
ScaleFromElemWidth
(
UnboxedTypeSize
(
unboxedType_
)
)
)
;
masm
.
storeUnboxedProperty
(
address
unboxedType_
ConstantOrRegister
(
TypedOrValueRegister
(
R0
)
)
&
failurePopR0
)
;
masm
.
Pop
(
R0
)
;
masm
.
add32
(
Imm32
(
1
)
initLengthAddr
)
;
Address
lengthAddr
(
obj
UnboxedArrayObject
:
:
offsetOfLength
(
)
)
;
Label
skipIncrementLength
;
masm
.
branch32
(
Assembler
:
:
Above
lengthAddr
key
&
skipIncrementLength
)
;
masm
.
add32
(
Imm32
(
1
)
lengthAddr
)
;
masm
.
bind
(
&
skipIncrementLength
)
;
}
EmitReturnFromIC
(
masm
)
;
if
(
failurePopR0
.
used
(
)
)
{
masm
.
bind
(
&
failurePopR0
)
;
masm
.
popValue
(
R0
)
;
masm
.
jump
(
&
failure
)
;
}
masm
.
bind
(
&
failureUnstow
)
;
masm
.
setFramePushed
(
framePushedAfterStow
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
template
<
typename
S
typename
T
>
void
BaselineStoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
S
&
value
const
T
&
dest
Register
scratch
Label
*
failure
Label
*
failureModifiedScratch
)
{
Label
done
;
if
(
type
=
=
Scalar
:
:
Float32
|
|
type
=
=
Scalar
:
:
Float64
)
{
masm
.
ensureDouble
(
value
FloatReg0
failure
)
;
if
(
type
=
=
Scalar
:
:
Float32
)
{
masm
.
convertDoubleToFloat32
(
FloatReg0
ScratchFloat32Reg
)
;
masm
.
storeToTypedFloatArray
(
type
ScratchFloat32Reg
dest
)
;
}
else
{
masm
.
storeToTypedFloatArray
(
type
FloatReg0
dest
)
;
}
}
else
if
(
type
=
=
Scalar
:
:
Uint8Clamped
)
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
masm
.
clampIntToUint8
(
scratch
)
;
Label
clamped
;
masm
.
bind
(
&
clamped
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
clampDoubleToUint8
(
FloatReg0
scratch
)
;
masm
.
jump
(
&
clamped
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
else
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
Label
isInt32
;
masm
.
bind
(
&
isInt32
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
branchTruncateDoubleMaybeModUint32
(
FloatReg0
scratch
failureModifiedScratch
)
;
masm
.
jump
(
&
isInt32
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
masm
.
bind
(
&
done
)
;
}
template
void
BaselineStoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
ValueOperand
&
value
const
Address
&
dest
Register
scratch
Label
*
failure
Label
*
failureModifiedScratch
)
;
template
void
BaselineStoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
const
Address
&
value
const
BaseIndex
&
dest
Register
scratch
Label
*
failure
Label
*
failureModifiedScratch
)
;
bool
ICSetElem_TypedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
if
(
layout_
!
=
Layout_TypedArray
)
CheckForTypedObjectWithDetachedStorage
(
cx
masm
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_TypedArray
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
Label
isInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R1
&
isInt32
)
;
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
masm
.
unboxDouble
(
R1
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
scratchReg
&
failure
false
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
scratchReg
R1
)
;
}
masm
.
bind
(
&
isInt32
)
;
}
else
{
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
}
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
Label
oobWrite
;
LoadTypedThingLength
(
masm
layout_
obj
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
expectOutOfBounds_
?
&
oobWrite
:
&
failure
)
;
LoadTypedThingData
(
masm
layout_
obj
scratchReg
)
;
BaseIndex
dest
(
scratchReg
key
ScaleFromElemWidth
(
Scalar
:
:
byteSize
(
type_
)
)
)
;
Address
value
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
regs
.
take
(
scratchReg
)
;
Register
secondScratch
=
regs
.
takeAny
(
)
;
Label
failureModifiedSecondScratch
;
BaselineStoreToTypedArray
(
cx
masm
type_
value
dest
secondScratch
&
failure
&
failureModifiedSecondScratch
)
;
EmitReturnFromIC
(
masm
)
;
if
(
failureModifiedSecondScratch
.
used
(
)
)
{
masm
.
bind
(
&
failureModifiedSecondScratch
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
obj
R0
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
key
R1
)
;
}
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
if
(
expectOutOfBounds_
)
{
MOZ_ASSERT
(
layout_
=
=
Layout_TypedArray
)
;
masm
.
bind
(
&
oobWrite
)
;
EmitReturnFromIC
(
masm
)
;
}
return
true
;
}
static
bool
TryAttachNativeInStub
(
JSContext
*
cx
HandleScript
outerScript
ICIn_Fallback
*
stub
HandleValue
key
HandleObject
obj
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
RootedId
id
(
cx
)
;
if
(
!
IsOptimizableElementPropertyName
(
cx
key
&
id
)
)
return
true
;
RootedPropertyName
name
(
cx
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
Rooted
<
PropertyResult
>
prop
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
LookupPropertyPure
(
cx
obj
id
holder
.
address
(
)
prop
.
address
(
)
)
)
return
true
;
if
(
prop
.
isNonNativeProperty
(
)
)
{
MOZ_ASSERT
(
!
IsCacheableProtoChain
(
obj
holder
false
)
)
;
return
true
;
}
RootedShape
shape
(
cx
prop
.
maybeShape
(
)
)
;
if
(
IsCacheableGetPropReadSlot
(
obj
holder
shape
)
)
{
ICStub
:
:
Kind
kind
=
(
obj
=
=
holder
)
?
ICStub
:
:
In_Native
:
ICStub
:
:
In_NativePrototype
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
In
(
Native
%
s
)
stub
"
(
obj
=
=
holder
)
?
"
direct
"
:
"
prototype
"
)
;
ICInNativeCompiler
compiler
(
cx
kind
obj
holder
name
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
return
true
;
}
static
bool
TryAttachNativeInDoesNotExistStub
(
JSContext
*
cx
HandleScript
outerScript
ICIn_Fallback
*
stub
HandleValue
key
HandleObject
obj
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
RootedId
id
(
cx
)
;
if
(
!
IsOptimizableElementPropertyName
(
cx
key
&
id
)
)
return
true
;
RootedPropertyName
name
(
cx
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
RootedObject
lastProto
(
cx
)
;
size_t
protoChainDepth
=
SIZE_MAX
;
if
(
!
CheckHasNoSuchProperty
(
cx
obj
.
get
(
)
id
lastProto
.
address
(
)
&
protoChainDepth
)
)
return
true
;
MOZ_ASSERT
(
protoChainDepth
<
SIZE_MAX
)
;
if
(
protoChainDepth
>
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
In_NativeDoesNotExist
stub
"
)
;
ICInNativeDoesNotExistCompiler
compiler
(
cx
obj
name
protoChainDepth
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
static
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIn_Fallback
*
stub_
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIn_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
In
"
)
;
if
(
!
objValue
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_IN_NOT_OBJECT
-
1
objValue
nullptr
)
;
return
false
;
}
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICIn_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
attached
=
true
;
RootedObject
obj
(
cx
&
objValue
.
toObject
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
if
(
!
attached
&
&
!
JitOptions
.
disableCacheIR
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
InIRGenerator
gen
(
cx
pc
key
obj
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
engine
frame
-
>
script
(
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
}
}
}
bool
cond
=
false
;
if
(
!
OperatorIn
(
cx
key
obj
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
attached
)
return
true
;
if
(
obj
-
>
isNative
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
bool
attached
=
false
;
if
(
cond
)
{
if
(
!
TryAttachNativeInStub
(
cx
script
stub
key
obj
&
attached
)
)
return
false
;
if
(
attached
)
return
true
;
}
else
{
if
(
!
TryAttachNativeInDoesNotExistStub
(
cx
script
stub
key
obj
&
attached
)
)
return
false
;
if
(
attached
)
return
true
;
}
}
return
true
;
}
typedef
bool
(
*
DoInFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInFallbackInfo
=
FunctionInfo
<
DoInFallbackFn
>
(
DoInFallback
"
DoInFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICIn_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInFallbackInfo
masm
)
;
}
bool
ICInNativeCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0Scratch
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
strExtract
=
masm
.
extractString
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInNativeStub
:
:
offsetOfName
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
strExtract
scratch
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInNativeStub
:
:
offsetOfShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
objReg
scratch
&
failure
)
;
if
(
kind
=
=
ICStub
:
:
In_NativePrototype
)
{
Register
holderReg
=
R0
.
scratchReg
(
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativePrototype
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativePrototype
:
:
offsetOfHolderShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
holderReg
scratch
&
failurePopR0Scratch
)
;
masm
.
addToStackPtr
(
Imm32
(
sizeof
(
size_t
)
)
)
;
}
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failurePopR0Scratch
)
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICStub
*
ICInNativeDoesNotExistCompiler
:
:
getStub
(
ICStubSpace
*
space
)
{
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
if
(
!
shapes
.
append
(
obj_
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
)
return
nullptr
;
if
(
!
GetProtoShapes
(
obj_
protoChainDepth_
&
shapes
)
)
return
nullptr
;
JS_STATIC_ASSERT
(
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
=
=
8
)
;
ICStub
*
stub
=
nullptr
;
switch
(
protoChainDepth_
)
{
case
0
:
stub
=
getStubSpecific
<
0
>
(
space
shapes
)
;
break
;
case
1
:
stub
=
getStubSpecific
<
1
>
(
space
shapes
)
;
break
;
case
2
:
stub
=
getStubSpecific
<
2
>
(
space
shapes
)
;
break
;
case
3
:
stub
=
getStubSpecific
<
3
>
(
space
shapes
)
;
break
;
case
4
:
stub
=
getStubSpecific
<
4
>
(
space
shapes
)
;
break
;
case
5
:
stub
=
getStubSpecific
<
5
>
(
space
shapes
)
;
break
;
case
6
:
stub
=
getStubSpecific
<
6
>
(
space
shapes
)
;
break
;
case
7
:
stub
=
getStubSpecific
<
7
>
(
space
shapes
)
;
break
;
case
8
:
stub
=
getStubSpecific
<
8
>
(
space
shapes
)
;
break
;
default
:
MOZ_CRASH
(
"
ProtoChainDepth
too
high
.
"
)
;
}
if
(
!
stub
)
return
nullptr
;
return
stub
;
}
bool
ICInNativeDoesNotExistCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0Scratch
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
#
ifdef
DEBUG
{
Label
ok
;
masm
.
load16ZeroExtend
(
Address
(
ICStubReg
ICStub
:
:
offsetOfExtra
(
)
)
scratch
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
protoChainDepth_
)
&
ok
)
;
masm
.
assumeUnreachable
(
"
Non
-
matching
proto
chain
depth
on
stub
.
"
)
;
masm
.
bind
(
&
ok
)
;
}
#
endif
Register
strExtract
=
masm
.
extractString
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativeDoesNotExist
:
:
offsetOfName
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
strExtract
scratch
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativeDoesNotExist
:
:
offsetOfShape
(
0
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
objReg
scratch
&
failure
)
;
Register
protoReg
=
R0
.
scratchReg
(
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
for
(
size_t
i
=
0
;
i
<
protoChainDepth_
;
+
+
i
)
{
masm
.
loadObjProto
(
i
=
=
0
?
objReg
:
protoReg
protoReg
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
protoReg
protoReg
&
failurePopR0Scratch
)
;
size_t
shapeOffset
=
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
i
+
1
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
shapeOffset
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
scratch
&
failurePopR0Scratch
)
;
}
masm
.
addToStackPtr
(
Imm32
(
sizeof
(
size_t
)
)
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failurePopR0Scratch
)
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetName_Fallback
*
stub_
HandleObject
envChain
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICGetName_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETNAME
|
|
op
=
=
JSOP_GETGNAME
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICGetName_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
attached
=
true
;
}
if
(
!
attached
&
&
!
JitOptions
.
disableCacheIR
)
{
ICStubEngine
engine
=
ICStubEngine
:
:
Baseline
;
GetNameIRGenerator
gen
(
cx
pc
script
envChain
name
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
engine
info
.
outerScript
(
cx
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
}
}
}
static_assert
(
JSOP_GETGNAME_LENGTH
=
=
JSOP_GETNAME_LENGTH
"
Otherwise
our
check
for
JSOP_TYPEOF
isn
'
t
ok
"
)
;
if
(
JSOp
(
pc
[
JSOP_GETGNAME_LENGTH
]
)
=
=
JSOP_TYPEOF
)
{
if
(
!
GetEnvironmentNameForTypeOf
(
cx
envChain
name
res
)
)
return
false
;
}
else
{
if
(
!
GetEnvironmentName
(
cx
envChain
name
res
)
)
return
false
;
}
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
!
attached
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoGetNameFallbackInfo
=
FunctionInfo
<
DoGetNameFallbackFn
>
(
DoGetNameFallback
"
DoGetNameFallback
"
TailCall
)
;
bool
ICGetName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetNameFallbackInfo
masm
)
;
}
static
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBindName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
BindName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_BINDNAME
|
|
op
=
=
JSOP_BINDGNAME
)
;
RootedPropertyName
name
(
cx
frame
-
>
script
(
)
-
>
getName
(
pc
)
)
;
RootedObject
scope
(
cx
)
;
if
(
!
LookupNameUnqualified
(
cx
name
envChain
&
scope
)
)
return
false
;
res
.
setObject
(
*
scope
)
;
return
true
;
}
typedef
bool
(
*
DoBindNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICBindName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoBindNameFallbackInfo
=
FunctionInfo
<
DoBindNameFallbackFn
>
(
DoBindNameFallback
"
DoBindNameFallback
"
TailCall
)
;
bool
ICBindName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoBindNameFallbackInfo
masm
)
;
}
static
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIntrinsic_Fallback
*
stub_
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetIntrinsic_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetIntrinsic
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETINTRINSIC
)
;
if
(
!
GetIntrinsicOperation
(
cx
pc
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetIntrinsic
optimized
stub
"
)
;
ICGetIntrinsic_Constant
:
:
Compiler
compiler
(
cx
res
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
typedef
bool
(
*
DoGetIntrinsicFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetIntrinsic_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoGetIntrinsicFallbackInfo
=
FunctionInfo
<
DoGetIntrinsicFallbackFn
>
(
DoGetIntrinsicFallback
"
DoGetIntrinsicFallback
"
TailCall
)
;
bool
ICGetIntrinsic_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetIntrinsicFallbackInfo
masm
)
;
}
bool
ICGetIntrinsic_Constant
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
loadValue
(
Address
(
ICStubReg
ICGetIntrinsic_Constant
:
:
offsetOfValue
(
)
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetProp_Fallback
*
stub_
Value
*
stack
HandleValue
lhs
HandleValue
rhs
)
{
DebugModeOSRVolatileStub
<
ICSetProp_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetProp
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
|
|
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
|
|
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
|
|
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
|
|
op
=
=
JSOP_INITGLEXICAL
)
;
RootedPropertyName
name
(
cx
)
;
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
name
=
EnvironmentCoordinateName
(
cx
-
>
caches
(
)
.
envCoordinateNameCache
script
pc
)
;
else
name
=
script
-
>
getName
(
pc
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
lhs
)
)
;
if
(
!
obj
)
return
false
;
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
return
false
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
bool
isTemporarilyUnoptimizable
=
false
;
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
<
ICSetProp_Fallback
:
:
MAX_OPTIMIZED_STUBS
&
&
!
JitOptions
.
disableCacheIR
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
pc
CacheKind
:
:
SetProp
&
isTemporarilyUnoptimizable
lhs
idVal
rhs
)
;
if
(
gen
.
tryAttachStub
(
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
if
(
gen
.
needUpdateStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
=
gen
.
updateStubGroup
(
)
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
=
gen
.
updateStubId
(
)
;
}
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
if
(
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
)
{
if
(
!
InitPropertyOperation
(
cx
op
obj
id
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
)
{
if
(
!
SetNameOperation
(
cx
script
pc
obj
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
{
obj
-
>
as
<
EnvironmentObject
>
(
)
.
setAliasedBinding
(
cx
EnvironmentCoordinate
(
pc
)
name
rhs
)
;
}
else
if
(
op
=
=
JSOP_INITGLEXICAL
)
{
RootedValue
v
(
cx
rhs
)
;
LexicalEnvironmentObject
*
lexicalEnv
;
if
(
script
-
>
hasNonSyntacticScope
(
)
)
lexicalEnv
=
&
NearestEnclosingExtensibleLexicalEnvironment
(
frame
-
>
environmentChain
(
)
)
;
else
lexicalEnv
=
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
;
InitGlobalLexicalOperation
(
cx
lexicalEnv
script
pc
v
)
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
)
;
ObjectOpResult
result
;
if
(
!
SetProperty
(
cx
obj
id
rhs
lhs
result
)
|
|
!
result
.
checkStrictErrorOrWarning
(
cx
obj
id
op
=
=
JSOP_STRICTSETPROP
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
stack
[
1
]
=
=
lhs
)
;
stack
[
1
]
=
rhs
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
attached
&
&
stub
-
>
numOptimizedStubs
(
)
<
ICSetProp_Fallback
:
:
MAX_OPTIMIZED_STUBS
&
&
!
JitOptions
.
disableCacheIR
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
pc
CacheKind
:
:
SetProp
&
isTemporarilyUnoptimizable
lhs
idVal
rhs
)
;
if
(
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
)
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
ICStubEngine
:
:
Baseline
frame
-
>
script
(
)
stub
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
CacheIR
stub
"
)
;
attached
=
true
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
=
gen
.
updateStubGroup
(
)
;
newStub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
=
gen
.
updateStubId
(
)
;
}
}
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoSetPropFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetProp_Fallback
*
Value
*
HandleValue
HandleValue
)
;
static
const
VMFunction
DoSetPropFallbackInfo
=
FunctionInfo
<
DoSetPropFallbackFn
>
(
DoSetPropFallback
"
DoSetPropFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICSetProp_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
0
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
tailCallVM
(
DoSetPropFallbackInfo
masm
)
)
return
false
;
#
ifdef
DEBUG
EmitRepushTailCallReg
(
masm
)
;
EmitStowICValues
(
masm
1
)
;
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
#
else
inStubFrame_
=
true
;
#
endif
returnOffset_
=
masm
.
currentOffset
(
)
;
leaveStubFrame
(
masm
true
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
void
ICSetProp_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBaselineSetPropReturnAddr
(
code
-
>
raw
(
)
+
returnOffset_
)
;
}
static
bool
TryAttachFunApplyStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
uint32_t
argc
Value
*
argv
bool
*
attached
)
{
if
(
argc
!
=
2
)
return
true
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
bool
isScripted
=
target
-
>
hasJITCode
(
)
;
if
(
argv
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
!
script
-
>
needsArgsObj
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArguments
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArguments
stub
"
)
;
ICCall_ScriptedApplyArguments
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
if
(
argv
[
1
]
.
isObject
(
)
&
&
argv
[
1
]
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArray
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArray
stub
"
)
;
ICCall_ScriptedApplyArray
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
return
true
;
}
static
bool
TryAttachFunCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
bool
*
attached
)
{
*
attached
=
false
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
target
-
>
hasScript
(
)
&
&
target
-
>
nonLazyScript
(
)
-
>
canBaselineCompile
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedFunCall
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedFunCall
stub
"
)
;
ICCall_ScriptedFunCall
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
return
true
;
}
static
bool
GetTemplateObjectForSimd
(
JSContext
*
cx
JSFunction
*
target
MutableHandleObject
res
)
{
const
JSJitInfo
*
jitInfo
=
target
-
>
jitInfo
(
)
;
if
(
!
jitInfo
|
|
jitInfo
-
>
type
(
)
!
=
JSJitInfo
:
:
InlinableNative
)
return
false
;
SimdType
ctrlType
;
switch
(
jitInfo
-
>
inlinableNative
)
{
case
InlinableNative
:
:
SimdInt8x16
:
ctrlType
=
SimdType
:
:
Int8x16
;
break
;
case
InlinableNative
:
:
SimdUint8x16
:
ctrlType
=
SimdType
:
:
Uint8x16
;
break
;
case
InlinableNative
:
:
SimdInt16x8
:
ctrlType
=
SimdType
:
:
Int16x8
;
break
;
case
InlinableNative
:
:
SimdUint16x8
:
ctrlType
=
SimdType
:
:
Uint16x8
;
break
;
case
InlinableNative
:
:
SimdInt32x4
:
ctrlType
=
SimdType
:
:
Int32x4
;
break
;
case
InlinableNative
:
:
SimdUint32x4
:
ctrlType
=
SimdType
:
:
Uint32x4
;
break
;
case
InlinableNative
:
:
SimdFloat32x4
:
ctrlType
=
SimdType
:
:
Float32x4
;
break
;
case
InlinableNative
:
:
SimdBool8x16
:
ctrlType
=
SimdType
:
:
Bool8x16
;
break
;
case
InlinableNative
:
:
SimdBool16x8
:
ctrlType
=
SimdType
:
:
Bool16x8
;
break
;
case
InlinableNative
:
:
SimdBool32x4
:
ctrlType
=
SimdType
:
:
Bool32x4
;
break
;
default
:
return
false
;
}
SimdOperation
simdOp
=
SimdOperation
(
jitInfo
-
>
nativeOp
)
;
SimdType
retType
;
switch
(
simdOp
)
{
case
SimdOperation
:
:
Fn_allTrue
:
case
SimdOperation
:
:
Fn_anyTrue
:
case
SimdOperation
:
:
Fn_extractLane
:
return
false
;
case
SimdOperation
:
:
Fn_lessThan
:
case
SimdOperation
:
:
Fn_lessThanOrEqual
:
case
SimdOperation
:
:
Fn_equal
:
case
SimdOperation
:
:
Fn_notEqual
:
case
SimdOperation
:
:
Fn_greaterThan
:
case
SimdOperation
:
:
Fn_greaterThanOrEqual
:
retType
=
GetBooleanSimdType
(
ctrlType
)
;
break
;
default
:
retType
=
ctrlType
;
break
;
}
RootedGlobalObject
global
(
cx
cx
-
>
global
(
)
)
;
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
GlobalObject
:
:
getOrCreateSimdTypeDescr
(
cx
global
retType
)
)
;
res
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
true
;
}
static
void
EnsureArrayGroupAnalyzed
(
JSContext
*
cx
JSObject
*
obj
)
{
if
(
PreliminaryObjectArrayWithTemplate
*
objects
=
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
objects
-
>
maybeAnalyze
(
cx
obj
-
>
group
(
)
true
)
;
}
static
bool
GetTemplateObjectForNative
(
JSContext
*
cx
HandleFunction
target
const
CallArgs
&
args
MutableHandleObject
res
bool
*
skipAttach
)
{
Native
native
=
target
-
>
native
(
)
;
if
(
native
=
=
ArrayConstructor
|
|
native
=
=
array_construct
)
{
size_t
count
=
0
;
if
(
args
.
length
(
)
!
=
1
)
count
=
args
.
length
(
)
;
else
if
(
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isInt32
(
)
&
&
args
[
0
]
.
toInt32
(
)
>
=
0
)
count
=
args
[
0
]
.
toInt32
(
)
;
if
(
count
<
=
ArrayObject
:
:
EagerAllocationMaxLength
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
count
TenuredObject
)
)
;
if
(
!
res
)
return
false
;
EnsureArrayGroupAnalyzed
(
cx
res
)
;
return
true
;
}
}
if
(
args
.
length
(
)
=
=
1
)
{
size_t
len
=
0
;
if
(
args
[
0
]
.
isInt32
(
)
&
&
args
[
0
]
.
toInt32
(
)
>
=
0
)
len
=
args
[
0
]
.
toInt32
(
)
;
if
(
!
TypedArrayObject
:
:
GetTemplateObjectForNative
(
cx
native
len
res
)
)
return
false
;
if
(
res
)
return
true
;
}
if
(
native
=
=
js
:
:
array_slice
)
{
if
(
args
.
thisv
(
)
.
isObject
(
)
)
{
RootedObject
obj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
if
(
!
obj
-
>
isSingleton
(
)
)
{
if
(
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayTryReuseGroup
(
cx
obj
0
TenuredObject
)
)
;
if
(
!
res
)
return
false
;
EnsureArrayGroupAnalyzed
(
cx
res
)
;
return
true
;
}
}
}
if
(
native
=
=
js
:
:
intrinsic_StringSplitString
&
&
args
.
length
(
)
=
=
2
&
&
args
[
0
]
.
isString
(
)
&
&
args
[
1
]
.
isString
(
)
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
0
TenuredObject
)
)
;
if
(
!
res
)
return
false
;
EnsureArrayGroupAnalyzed
(
cx
res
)
;
return
true
;
}
if
(
native
=
=
StringConstructor
)
{
RootedString
emptyString
(
cx
cx
-
>
runtime
(
)
-
>
emptyString
)
;
res
.
set
(
StringObject
:
:
create
(
cx
emptyString
nullptr
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
obj_create
&
&
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isObjectOrNull
(
)
)
{
RootedObject
proto
(
cx
args
[
0
]
.
toObjectOrNull
(
)
)
;
res
.
set
(
ObjectCreateImpl
(
cx
proto
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
JitSupportsSimd
(
)
&
&
GetTemplateObjectForSimd
(
cx
target
res
)
)
return
!
!
res
;
return
true
;
}
static
bool
GetTemplateObjectForClassHook
(
JSContext
*
cx
JSNative
hook
CallArgs
&
args
MutableHandleObject
templateObject
)
{
if
(
hook
=
=
TypedObject
:
:
construct
)
{
Rooted
<
TypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
TypeDescr
>
(
)
)
;
templateObject
.
set
(
TypedObject
:
:
createZeroed
(
cx
descr
1
gc
:
:
TenuredHeap
)
)
;
return
!
!
templateObject
;
}
if
(
hook
=
=
SimdTypeDescr
:
:
call
&
&
JitSupportsSimd
(
)
)
{
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
SimdTypeDescr
>
(
)
)
;
templateObject
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
!
!
templateObject
;
}
return
true
;
}
static
bool
IsOptimizableCallStringSplit
(
const
Value
&
callee
int
argc
Value
*
args
)
{
if
(
argc
!
=
2
|
|
!
args
[
0
]
.
isString
(
)
|
|
!
args
[
1
]
.
isString
(
)
)
return
false
;
if
(
!
args
[
0
]
.
toString
(
)
-
>
isAtom
(
)
|
|
!
args
[
1
]
.
toString
(
)
-
>
isAtom
(
)
)
return
false
;
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
&
calleeFun
=
callee
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
calleeFun
.
isNative
(
)
|
|
calleeFun
.
native
(
)
!
=
js
:
:
intrinsic_StringSplitString
)
return
false
;
return
true
;
}
static
bool
TryAttachCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
JSOp
op
uint32_t
argc
Value
*
vp
bool
constructing
bool
isSpread
bool
createSingleton
bool
*
handled
)
{
bool
isSuper
=
op
=
=
JSOP_SUPERCALL
|
|
op
=
=
JSOP_SPREADSUPERCALL
;
if
(
createSingleton
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICCall_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
=
=
0
&
&
IsOptimizableCallStringSplit
(
callee
argc
vp
+
2
)
)
return
true
;
MOZ_ASSERT_IF
(
stub
-
>
hasStub
(
ICStub
:
:
Call_StringSplit
)
stub
-
>
numOptimizedStubs
(
)
=
=
1
)
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_StringSplit
)
;
if
(
!
callee
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
callee
.
toObject
(
)
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
return
true
;
if
(
JSNative
hook
=
constructing
?
obj
-
>
constructHook
(
)
:
obj
-
>
callHook
(
)
)
{
if
(
op
!
=
JSOP_FUNAPPLY
&
&
!
isSpread
&
&
!
createSingleton
)
{
RootedObject
templateObject
(
cx
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForClassHook
(
cx
hook
args
&
templateObject
)
)
return
false
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ClassHook
stub
"
)
;
ICCall_ClassHook
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
obj
-
>
getClass
(
)
hook
templateObject
script
-
>
pcToOffset
(
pc
)
constructing
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
}
return
true
;
}
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
fun
-
>
hasScript
(
)
)
{
if
(
op
=
=
JSOP_FUNAPPLY
)
return
true
;
if
(
constructing
&
&
!
fun
-
>
isConstructor
(
)
)
return
true
;
if
(
!
constructing
&
&
fun
-
>
isClassConstructor
(
)
)
return
true
;
if
(
!
fun
-
>
hasJITCode
(
)
)
{
*
handled
=
true
;
return
true
;
}
if
(
stub
-
>
scriptedStubsAreGeneralized
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Chain
already
has
generalized
scripted
call
stub
!
"
)
;
return
true
;
}
if
(
stub
-
>
scriptedStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_SCRIPTED_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_AnyScripted
stub
(
cons
=
%
s
spread
=
%
s
)
"
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_Scripted
)
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
IsIonEnabled
(
cx
)
)
EnsureTrackPropertyTypes
(
cx
fun
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
RootedObject
templateObject
(
cx
)
;
if
(
constructing
&
&
!
isSuper
)
{
RootedObject
newTarget
(
cx
&
vp
[
2
+
argc
]
.
toObject
(
)
)
;
RootedValue
protov
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
newTarget
NameToId
(
cx
-
>
names
(
)
.
prototype
)
protov
.
address
(
)
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Can
'
t
purely
lookup
function
prototype
"
)
;
return
true
;
}
if
(
protov
.
isObject
(
)
)
{
TaggedProto
proto
(
&
protov
.
toObject
(
)
)
;
ObjectGroup
*
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx
nullptr
proto
newTarget
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
newScript
(
)
&
&
!
group
-
>
newScript
(
)
-
>
analyzed
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Function
newScript
has
not
been
analyzed
"
)
;
*
handled
=
true
;
return
true
;
}
}
JSObject
*
thisObject
=
CreateThisForFunction
(
cx
fun
newTarget
TenuredObject
)
;
if
(
!
thisObject
)
return
false
;
if
(
thisObject
-
>
is
<
PlainObject
>
(
)
|
|
thisObject
-
>
is
<
UnboxedPlainObject
>
(
)
)
templateObject
=
thisObject
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Scripted
stub
(
fun
=
%
p
%
s
:
%
"
PRIuSIZE
"
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
fun
-
>
nonLazyScript
(
)
-
>
filename
(
)
fun
-
>
nonLazyScript
(
)
-
>
lineno
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
fun
-
>
isNative
(
)
&
&
(
!
constructing
|
|
(
constructing
&
&
fun
-
>
isConstructor
(
)
)
)
)
{
MOZ_ASSERT
(
!
stub
-
>
nativeStubsAreGeneralized
(
)
)
;
if
(
op
=
=
JSOP_FUNAPPLY
)
{
if
(
fun
-
>
native
(
)
=
=
fun_apply
)
return
TryAttachFunApplyStub
(
cx
stub
script
pc
thisv
argc
vp
+
2
handled
)
;
return
true
;
}
if
(
op
=
=
JSOP_FUNCALL
&
&
fun
-
>
native
(
)
=
=
fun_call
)
{
if
(
!
TryAttachFunCallStub
(
cx
stub
script
pc
thisv
handled
)
)
return
false
;
if
(
*
handled
)
return
true
;
}
if
(
stub
-
>
nativeStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_NATIVE_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Too
many
Call_Native
stubs
.
TODO
:
add
Call_AnyNative
!
"
)
;
return
true
;
}
if
(
fun
-
>
native
(
)
=
=
intrinsic_IsSuspendedStarGenerator
)
{
MOZ_ASSERT
(
op
!
=
JSOP_NEW
)
;
MOZ_ASSERT
(
argc
=
=
1
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_IsSuspendedStarGenerator
stub
"
)
;
ICCall_IsSuspendedStarGenerator
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
RootedObject
templateObject
(
cx
)
;
if
(
MOZ_LIKELY
(
!
isSpread
&
&
!
isSuper
)
)
{
bool
skipAttach
=
false
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForNative
(
cx
fun
args
&
templateObject
&
skipAttach
)
)
return
false
;
if
(
skipAttach
)
{
*
handled
=
true
;
return
true
;
}
MOZ_ASSERT_IF
(
templateObject
!
templateObject
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Native
stub
(
fun
=
%
p
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCall_Native
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
return
true
;
}
static
bool
CopyArray
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
result
)
{
uint32_t
length
=
GetAnyBoxedOrUnboxedArrayLength
(
obj
)
;
JSObject
*
nobj
=
NewFullyAllocatedArrayTryReuseGroup
(
cx
obj
length
TenuredObject
)
;
if
(
!
nobj
)
return
false
;
EnsureArrayGroupAnalyzed
(
cx
nobj
)
;
CopyAnyBoxedOrUnboxedDenseElements
(
cx
nobj
obj
0
0
length
)
;
result
.
setObject
(
*
nobj
)
;
return
true
;
}
static
bool
TryAttachStringSplit
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
uint32_t
argc
HandleValue
callee
Value
*
vp
jsbytecode
*
pc
HandleValue
res
bool
*
attached
)
{
if
(
stub
-
>
numOptimizedStubs
(
)
!
=
0
)
return
true
;
Value
*
args
=
vp
+
2
;
if
(
JSOp
(
*
pc
)
=
=
JSOP_NEW
)
return
true
;
if
(
!
IsOptimizableCallStringSplit
(
callee
argc
args
)
)
return
true
;
MOZ_ASSERT
(
callee
.
isObject
(
)
)
;
MOZ_ASSERT
(
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
RootedString
str
(
cx
args
[
0
]
.
toString
(
)
)
;
RootedString
sep
(
cx
args
[
1
]
.
toString
(
)
)
;
RootedObject
obj
(
cx
&
res
.
toObject
(
)
)
;
RootedValue
arr
(
cx
)
;
if
(
!
CopyArray
(
cx
obj
&
arr
)
)
return
false
;
RootedObject
arrObj
(
cx
&
arr
.
toObject
(
)
)
;
uint32_t
initLength
=
GetAnyBoxedOrUnboxedArrayLength
(
arrObj
)
;
for
(
uint32_t
i
=
0
;
i
<
initLength
;
i
+
+
)
{
JSAtom
*
str
=
js
:
:
AtomizeString
(
cx
GetAnyBoxedOrUnboxedDenseElement
(
arrObj
i
)
.
toString
(
)
)
;
if
(
!
str
)
return
false
;
if
(
!
SetAnyBoxedOrUnboxedDenseElement
(
cx
arrObj
i
StringValue
(
str
)
)
)
{
return
true
;
}
}
ICCall_StringSplit
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
str
sep
arr
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
Call
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
argc
=
=
GET_ARGC
(
pc
)
)
;
bool
constructing
=
(
op
=
=
JSOP_NEW
)
;
size_t
numValues
=
argc
+
2
+
constructing
;
AutoArrayRooter
vpRoot
(
cx
numValues
vp
)
;
CallArgs
callArgs
=
CallArgsFromSp
(
argc
+
constructing
vp
+
numValues
constructing
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
if
(
op
=
=
JSOP_FUNAPPLY
&
&
argc
=
=
2
&
&
callArgs
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GuardFunApplyArgumentsOptimization
(
cx
frame
callArgs
)
)
return
false
;
}
bool
createSingleton
=
ObjectGroup
:
:
useSingletonForNewObject
(
cx
script
pc
)
;
bool
handled
=
false
;
if
(
!
TryAttachCallStub
(
cx
stub
script
pc
op
argc
vp
constructing
false
createSingleton
&
handled
)
)
{
return
false
;
}
if
(
op
=
=
JSOP_NEW
)
{
if
(
!
ConstructFromStack
(
cx
callArgs
)
)
return
false
;
res
.
set
(
callArgs
.
rval
(
)
)
;
}
else
if
(
(
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
&
&
frame
-
>
environmentChain
(
)
-
>
global
(
)
.
valueIsEval
(
callee
)
)
{
if
(
!
DirectEval
(
cx
callArgs
.
get
(
0
)
res
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_CALL
|
|
op
=
=
JSOP_CALLITER
|
|
op
=
=
JSOP_FUNCALL
|
|
op
=
=
JSOP_FUNAPPLY
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
;
if
(
op
=
=
JSOP_CALLITER
&
&
callee
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
argc
=
=
0
"
thisv
must
be
on
top
of
the
stack
"
)
;
ReportValueError
(
cx
JSMSG_NOT_ITERABLE
-
1
callArgs
.
thisv
(
)
nullptr
)
;
return
false
;
}
if
(
!
CallFromStack
(
cx
callArgs
)
)
return
false
;
res
.
set
(
callArgs
.
rval
(
)
)
;
}
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
ICTypeMonitor_Fallback
*
typeMonFbStub
=
stub
-
>
fallbackMonitorStub
(
)
;
if
(
!
typeMonFbStub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
!
TryAttachStringSplit
(
cx
stub
script
argc
callee
vp
pc
res
&
handled
)
)
return
false
;
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
static
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
Value
*
vp
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
bool
constructing
=
(
op
=
=
JSOP_SPREADNEW
)
;
FallbackICSpew
(
cx
stub
"
SpreadCall
(
%
s
)
"
CodeName
[
op
]
)
;
AutoArrayRooter
vpRoot
(
cx
3
+
constructing
vp
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
RootedValue
arr
(
cx
vp
[
2
]
)
;
RootedValue
newTarget
(
cx
constructing
?
vp
[
3
]
:
NullValue
(
)
)
;
bool
handled
=
false
;
if
(
op
!
=
JSOP_SPREADEVAL
&
&
op
!
=
JSOP_STRICTSPREADEVAL
&
&
!
TryAttachCallStub
(
cx
stub
script
pc
op
1
vp
constructing
true
false
&
handled
)
)
{
return
false
;
}
if
(
!
SpreadCallOperation
(
cx
script
pc
thisv
callee
arr
newTarget
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
ICTypeMonitor_Fallback
*
typeMonFbStub
=
stub
-
>
fallbackMonitorStub
(
)
;
if
(
!
typeMonFbStub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
void
ICCallStubCompiler
:
:
pushCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
MOZ_ASSERT
(
!
regs
.
has
(
argcReg
)
)
;
Register
count
=
regs
.
takeAny
(
)
;
masm
.
move32
(
argcReg
count
)
;
if
(
isJitCall
)
{
if
(
isConstructing
)
masm
.
add32
(
Imm32
(
1
)
count
)
;
}
else
{
masm
.
add32
(
Imm32
(
2
+
isConstructing
)
count
)
;
}
Register
argPtr
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
argPtr
)
;
masm
.
addPtr
(
Imm32
(
STUB_FRAME_SIZE
)
argPtr
)
;
if
(
isJitCall
)
{
masm
.
alignJitStackBasedOnNArgs
(
count
)
;
masm
.
add32
(
Imm32
(
2
)
count
)
;
}
Label
loop
done
;
masm
.
bind
(
&
loop
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
count
count
&
done
)
;
{
masm
.
pushValue
(
Address
(
argPtr
0
)
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
argPtr
)
;
masm
.
sub32
(
Imm32
(
1
)
count
)
;
masm
.
jump
(
&
loop
)
;
}
masm
.
bind
(
&
done
)
;
}
void
ICCallStubCompiler
:
:
guardSpreadCall
(
MacroAssembler
&
masm
Register
argcReg
Label
*
failure
bool
isConstructing
)
{
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
isConstructing
*
sizeof
(
Value
)
+
ICStackValueOffset
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfLength
(
)
)
argcReg
)
;
static_assert
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
<
=
ARGS_LENGTH_MAX
"
maximum
arguments
length
for
optimized
stub
should
be
<
=
ARGS_LENGTH_MAX
"
)
;
masm
.
branch32
(
Assembler
:
:
Above
argcReg
Imm32
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
)
failure
)
;
}
void
ICCallStubCompiler
:
:
pushSpreadCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
(
isConstructing
*
sizeof
(
Value
)
)
+
STUB_FRAME_SIZE
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
if
(
isJitCall
)
{
Register
alignReg
=
argcReg
;
if
(
isConstructing
)
{
alignReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
alignReg
)
;
masm
.
addPtr
(
Imm32
(
1
)
alignReg
)
;
}
masm
.
alignJitStackBasedOnNArgs
(
alignReg
)
;
if
(
isConstructing
)
{
MOZ_ASSERT
(
alignReg
!
=
argcReg
)
;
regs
.
add
(
alignReg
)
;
}
}
if
(
isConstructing
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
endReg
)
;
static_assert
(
sizeof
(
Value
)
=
=
8
"
Value
must
be
8
bytes
"
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
regs
.
add
(
startReg
)
;
regs
.
add
(
endReg
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
1
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
2
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
}
Register
ICCallStubCompiler
:
:
guardFunApply
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
checkNative
FunApplyThing
applyThing
Label
*
failure
)
{
masm
.
branch32
(
Assembler
:
:
NotEqual
argcReg
Imm32
(
2
)
failure
)
;
Address
secondArgSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
applyThing
=
=
FunApply_MagicArgs
)
{
masm
.
branchTestMagic
(
Assembler
:
:
NotEqual
secondArgSlot
failure
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFlags
(
)
)
Imm32
(
BaselineFrame
:
:
HAS_ARGS_OBJ
)
failure
)
;
masm
.
branch32
(
Assembler
:
:
Above
Address
(
BaselineFrameReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
Imm32
(
ICCall_ScriptedApplyArray
:
:
MAX_ARGS_ARRAY_LENGTH
)
failure
)
;
}
else
{
MOZ_ASSERT
(
applyThing
=
=
FunApply_Array
)
;
AllocatableGeneralRegisterSet
regsx
=
regs
;
ValueOperand
secondArgVal
=
regsx
.
takeAnyValue
(
)
;
masm
.
loadValue
(
secondArgSlot
secondArgVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
secondArgVal
failure
)
;
Register
secondArgObj
=
masm
.
extractObject
(
secondArgVal
ExtractTemp1
)
;
regsx
.
add
(
secondArgVal
)
;
regsx
.
takeUnchecked
(
secondArgObj
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
secondArgObj
regsx
.
getAny
(
)
&
ArrayObject
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
secondArgObj
NativeObject
:
:
offsetOfElements
(
)
)
secondArgObj
)
;
Register
lenReg
=
regsx
.
takeAny
(
)
;
masm
.
load32
(
Address
(
secondArgObj
ObjectElements
:
:
offsetOfLength
(
)
)
lenReg
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
secondArgObj
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
lenReg
failure
)
;
masm
.
branch32
(
Assembler
:
:
Above
lenReg
Imm32
(
ICCall_ScriptedApplyArray
:
:
MAX_ARGS_ARRAY_LENGTH
)
failure
)
;
JS_STATIC_ASSERT
(
sizeof
(
Value
)
=
=
8
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
lenReg
)
;
masm
.
addPtr
(
secondArgObj
lenReg
)
;
Register
start
=
secondArgObj
;
Register
end
=
lenReg
;
Label
loop
;
Label
endLoop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
AboveOrEqual
start
end
&
endLoop
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
Address
(
start
0
)
failure
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
start
)
;
masm
.
jump
(
&
loop
)
;
masm
.
bind
(
&
endLoop
)
;
}
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
Address
calleeSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
3
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
calleeSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
callee
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_apply
)
failure
)
;
Address
thisSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
2
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
thisSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
target
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
regs
.
add
(
val
)
;
regs
.
takeUnchecked
(
target
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
target
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
if
(
checkNative
)
{
masm
.
branchIfInterpreted
(
target
failure
)
;
}
else
{
masm
.
branchIfFunctionHasNoScript
(
target
failure
)
;
Register
temp
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
temp
)
;
masm
.
loadBaselineOrIonRaw
(
temp
temp
failure
)
;
regs
.
add
(
temp
)
;
}
return
target
;
}
void
ICCallStubCompiler
:
:
pushCallerArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
endReg
)
;
masm
.
addPtr
(
Imm32
(
BaselineFrame
:
:
offsetOfArg
(
0
)
)
startReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
void
ICCallStubCompiler
:
:
pushArrayArguments
(
MacroAssembler
&
masm
Address
arrayVal
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
extractObject
(
arrayVal
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
masm
.
load32
(
Address
(
startReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
endReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
typedef
bool
(
*
DoCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
uint32_t
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoCallFallbackInfo
=
FunctionInfo
<
DoCallFallbackFn
>
(
DoCallFallback
"
DoCallFallback
"
)
;
typedef
bool
(
*
DoSpreadCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoSpreadCallFallbackInfo
=
FunctionInfo
<
DoSpreadCallFallbackFn
>
(
DoSpreadCallFallback
"
DoSpreadCallFallback
"
)
;
bool
ICCall_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
{
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
if
(
isConstructing_
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
uint32_t
valueOffset
=
isConstructing_
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoSpreadCallFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
regs
.
take
(
R0
.
scratchReg
(
)
)
;
pushCallArguments
(
masm
regs
R0
.
scratchReg
(
)
false
isConstructing_
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoCallFallbackInfo
masm
)
)
return
false
;
uint32_t
framePushed
=
masm
.
framePushed
(
)
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
returnOffset_
=
masm
.
currentOffset
(
)
;
inStubFrame_
=
true
;
masm
.
setFramePushed
(
framePushed
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
size_t
)
)
R1
)
;
leaveStubFrame
(
masm
true
)
;
if
(
isConstructing_
)
{
MOZ_ASSERT
(
JSReturnOperand
=
=
R0
)
;
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
moveValue
(
R1
R0
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Failed
to
return
object
in
constructing
call
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
void
ICCall_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
return
;
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBaselineCallReturnAddr
(
code
-
>
raw
(
)
+
returnOffset_
isConstructing_
)
;
}
typedef
bool
(
*
CreateThisFn
)
(
JSContext
*
cx
HandleObject
callee
HandleObject
newTarget
MutableHandleValue
rval
)
;
static
const
VMFunction
CreateThisInfoBaseline
=
FunctionInfo
<
CreateThisFn
>
(
CreateThis
"
CreateThis
"
)
;
bool
ICCallScriptedCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
MOZ_ASSERT
(
argcReg
!
=
ArgumentsRectifierReg
)
;
regs
.
take
(
argcReg
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
unsigned
skipToCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipToCallee
+
ICStackValueOffset
)
R1
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSkip
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
if
(
callee_
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
Call_Scripted
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Scripted
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
}
else
{
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
if
(
isConstructing_
)
{
masm
.
branchIfNotInterpretedConstructor
(
callee
regs
.
getAny
(
)
&
failure
)
;
}
else
{
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
branchFunctionKind
(
Assembler
:
:
Equal
JSFunction
:
:
ClassConstructor
callee
regs
.
getAny
(
)
&
failure
)
;
}
}
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
Register
code
;
if
(
!
isConstructing_
)
{
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failure
)
;
}
else
{
Address
scriptCode
(
callee
JSScript
:
:
offsetOfBaselineOrIonRaw
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scriptCode
ImmPtr
(
nullptr
)
&
failure
)
;
}
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
failureLeaveStubFrame
;
if
(
isConstructing_
)
{
masm
.
push
(
argcReg
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
)
R1
)
;
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
isSpread_
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
R1
)
;
}
else
{
BaseValueIndex
calleeSlot2
(
masm
.
getStackPointer
(
)
argcReg
2
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
;
masm
.
loadValue
(
calleeSlot2
R1
)
;
}
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
!
callVM
(
CreateThisInfoBaseline
masm
)
)
return
false
;
#
ifdef
DEBUG
Label
createdThisOK
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
assumeUnreachable
(
"
The
return
of
CreateThis
must
be
an
object
or
uninitialized
.
"
)
;
masm
.
bind
(
&
createdThisOK
)
;
#
endif
MOZ_ASSERT
(
JSReturnOperand
=
=
R0
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
take
(
R0
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
argcReg
=
regs
.
takeAny
(
)
;
masm
.
pop
(
argcReg
)
;
if
(
isSpread_
)
{
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
}
else
{
BaseValueIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
STUB_FRAME_SIZE
+
isConstructing_
*
sizeof
(
Value
)
)
;
masm
.
storeValue
(
R0
thisSlot
)
;
}
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SAVED_STUB_OFFSET
)
ICStubReg
)
;
if
(
isSpread_
)
{
unsigned
skipForCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipForCallee
+
STUB_FRAME_SIZE
)
R0
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot3
(
masm
.
getStackPointer
(
)
argcReg
nonArgsSkip
+
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
calleeSlot3
R0
)
;
}
callee
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
regs
.
add
(
R0
)
;
regs
.
takeUnchecked
(
callee
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failureLeaveStubFrame
)
;
if
(
callee
!
=
ExtractTemp0
)
regs
.
add
(
callee
)
;
if
(
canUseTailCallReg
)
regs
.
addUnchecked
(
ICTailCallReg
)
;
}
Register
scratch
=
regs
.
takeAny
(
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
PushCalleeToken
(
callee
isConstructing_
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
if
(
isConstructing_
)
{
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
Address
descriptorAddr
(
masm
.
getStackPointer
(
)
0
)
;
masm
.
loadPtr
(
descriptorAddr
BaselineFrameReg
)
;
masm
.
rshiftPtr
(
Imm32
(
FRAMESIZE_SHIFT
)
BaselineFrameReg
)
;
masm
.
addPtr
(
Imm32
(
(
3
-
2
)
*
sizeof
(
size_t
)
)
BaselineFrameReg
)
;
masm
.
addStackPtrTo
(
BaselineFrameReg
)
;
Register
argcReg
=
JSReturnOperand
.
scratchReg
(
)
;
if
(
isSpread_
)
{
masm
.
move32
(
Imm32
(
1
)
argcReg
)
;
}
else
{
Address
argcAddr
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
size_t
)
)
;
masm
.
loadPtr
(
argcAddr
argcReg
)
;
}
BaseValueIndex
thisSlotAddr
(
BaselineFrameReg
argcReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
thisSlotAddr
JSReturnOperand
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Return
of
constructing
call
should
be
an
object
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureLeaveStubFrame
)
;
inStubFrame_
=
true
;
leaveStubFrame
(
masm
false
)
;
if
(
argcReg
!
=
R0
.
scratchReg
(
)
)
masm
.
movePtr
(
argcReg
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
typedef
bool
(
*
CopyArrayFn
)
(
JSContext
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
CopyArrayInfo
=
FunctionInfo
<
CopyArrayFn
>
(
CopyArray
"
CopyArray
"
)
;
bool
ICCall_StringSplit
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
static
const
size_t
SEP_DEPTH
=
0
;
static
const
size_t
STR_DEPTH
=
sizeof
(
Value
)
;
static
const
size_t
CALLEE_DEPTH
=
3
*
sizeof
(
Value
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Label
failureRestoreArgc
;
#
ifdef
DEBUG
Label
twoArg
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
masm
.
branch32
(
Assembler
:
:
Equal
argcReg
Imm32
(
2
)
&
twoArg
)
;
masm
.
assumeUnreachable
(
"
Expected
argc
=
=
2
"
)
;
masm
.
bind
(
&
twoArg
)
;
#
endif
Register
scratchReg
=
regs
.
takeAny
(
)
;
{
Address
calleeAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
CALLEE_DEPTH
)
;
ValueOperand
calleeVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
calleeAddr
calleeVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
calleeVal
&
failureRestoreArgc
)
;
Register
calleeObj
=
masm
.
extractObject
(
calleeVal
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
calleeObj
scratchReg
&
JSFunction
:
:
class_
&
failureRestoreArgc
)
;
masm
.
loadPtr
(
Address
(
calleeObj
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
scratchReg
ImmPtr
(
js
:
:
intrinsic_StringSplitString
)
&
failureRestoreArgc
)
;
regs
.
add
(
calleeVal
)
;
}
{
Address
sepAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
SEP_DEPTH
)
;
ValueOperand
sepVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
sepAddr
sepVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
sepVal
&
failureRestoreArgc
)
;
Register
sep
=
masm
.
extractString
(
sepVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedSep
(
)
)
sep
&
failureRestoreArgc
)
;
regs
.
add
(
sepVal
)
;
}
{
Address
strAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
STR_DEPTH
)
;
ValueOperand
strVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
strAddr
strVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
strVal
&
failureRestoreArgc
)
;
Register
str
=
masm
.
extractString
(
strVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedStr
(
)
)
str
&
failureRestoreArgc
)
;
regs
.
add
(
strVal
)
;
}
{
Register
paramReg
=
regs
.
takeAny
(
)
;
enterStubFrame
(
masm
scratchReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetOfTemplateObject
(
)
)
paramReg
)
;
masm
.
push
(
paramReg
)
;
if
(
!
callVM
(
CopyArrayInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
regs
.
add
(
paramReg
)
;
}
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreArgc
)
;
masm
.
move32
(
Imm32
(
2
)
R0
.
scratchReg
(
)
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_IsSuspendedStarGenerator
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Address
argAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
ValueOperand
argVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
argAddr
argVal
)
;
Label
returnFalse
;
Register
genObj
=
regs
.
takeAny
(
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxObject
(
argVal
genObj
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
genObj
scratch
&
StarGeneratorObject
:
:
class_
&
returnFalse
)
;
masm
.
loadValue
(
Address
(
genObj
GeneratorObject
:
:
offsetOfYieldIndexSlot
(
)
)
argVal
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxInt32
(
argVal
scratch
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
scratch
Imm32
(
StarGeneratorObject
:
:
YIELD_INDEX_CLOSING
)
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICCall_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
2
*
sizeof
(
Value
)
)
R1
)
;
}
else
{
unsigned
nonArgsSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Native
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
enterFakeExitFrameForNative
(
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
#
ifdef
JS_SIMULATOR
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_Native
:
:
offsetOfNative
(
)
)
)
;
#
else
masm
.
callWithABI
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
)
;
#
endif
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ClassHook
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
unsigned
nonArgSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
loadObjClass
(
callee
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfClass
(
)
)
scratch
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
regs
.
add
(
scratch
)
;
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
regs
.
take
(
scratch
)
;
masm
.
checkStackAlignment
(
)
;
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
enterFakeExitFrameForNative
(
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfNative
(
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
regs
.
takeUnchecked
(
ArgumentsRectifierReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
false
FunApply_Array
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
Address
arrayVal
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
pushArrayArguments
(
masm
arrayVal
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
extractObject
(
arrayVal
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
target
)
;
masm
.
loadBaselineOrIonRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
target
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
target
)
;
masm
.
loadPtr
(
Address
(
target
JitCode
:
:
offsetOfCode
(
)
)
target
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArguments
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
regs
.
takeUnchecked
(
ArgumentsRectifierReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
false
FunApply_MagicArgs
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
pushCallerArguments
(
masm
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
target
)
;
masm
.
loadBaselineOrIonRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
target
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
target
)
;
masm
.
loadPtr
(
Address
(
target
JitCode
:
:
offsetOfCode
(
)
)
target
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedFunCall
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
MOZ_ASSERT
(
argcReg
!
=
ArgumentsRectifierReg
)
;
regs
.
take
(
argcReg
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_call
)
&
failure
)
;
BaseIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
TimesEight
ICStackValueOffset
)
;
masm
.
loadValue
(
thisSlot
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
Register
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failure
)
;
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
zeroArgs
done
;
masm
.
branchTest32
(
Assembler
:
:
Zero
argcReg
argcReg
&
zeroArgs
)
;
masm
.
sub32
(
Imm32
(
1
)
argcReg
)
;
pushCallArguments
(
masm
regs
argcReg
true
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
zeroArgs
)
;
Address
thisSlotFromStubFrame
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
thisSlotFromStubFrame
val
)
;
masm
.
alignJitStackBasedOnNArgs
(
0
)
;
masm
.
pushValue
(
UndefinedValue
(
)
)
;
masm
.
bind
(
&
done
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
callee
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoubleValueToInt32ForSwitch
(
Value
*
v
)
{
double
d
=
v
-
>
toDouble
(
)
;
int32_t
truncated
=
int32_t
(
d
)
;
if
(
d
!
=
double
(
truncated
)
)
return
false
;
v
-
>
setInt32
(
truncated
)
;
return
true
;
}
bool
ICTableSwitch
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
isInt32
notInt32
outOfRange
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
notInt32
)
;
Register
key
=
masm
.
extractInt32
(
R0
ExtractTemp0
)
;
masm
.
bind
(
&
isInt32
)
;
masm
.
load32
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
min_
)
)
scratch
)
;
masm
.
sub32
(
scratch
key
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
Address
(
ICStubReg
offsetof
(
ICTableSwitch
length_
)
)
key
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
table_
)
)
scratch
)
;
masm
.
loadPtr
(
BaseIndex
(
scratch
key
ScalePointer
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
notInt32
)
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
outOfRange
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
key
&
outOfRange
false
)
;
}
else
{
masm
.
pushValue
(
R0
)
;
masm
.
moveStackPtrTo
(
R0
.
scratchReg
(
)
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
R0
.
scratchReg
(
)
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
DoubleValueToInt32ForSwitch
)
)
;
masm
.
movePtr
(
ReturnReg
scratch
)
;
masm
.
popValue
(
R0
)
;
masm
.
branchIfFalseBool
(
scratch
&
outOfRange
)
;
masm
.
unboxInt32
(
R0
key
)
;
}
masm
.
jump
(
&
isInt32
)
;
masm
.
bind
(
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
defaultTarget_
)
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
ICStub
*
ICTableSwitch
:
:
Compiler
:
:
getStub
(
ICStubSpace
*
space
)
{
JitCode
*
code
=
getStubCode
(
)
;
if
(
!
code
)
return
nullptr
;
jsbytecode
*
pc
=
pc_
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc
)
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc
)
;
int32_t
length
=
high
-
low
+
1
;
pc
+
=
JUMP_OFFSET_LEN
;
void
*
*
table
=
(
void
*
*
)
space
-
>
alloc
(
sizeof
(
void
*
)
*
length
)
;
if
(
!
table
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
jsbytecode
*
defaultpc
=
pc_
+
GET_JUMP_OFFSET
(
pc_
)
;
for
(
int32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
int32_t
off
=
GET_JUMP_OFFSET
(
pc
)
;
if
(
off
)
table
[
i
]
=
pc_
+
off
;
else
table
[
i
]
=
defaultpc
;
pc
+
=
JUMP_OFFSET_LEN
;
}
return
newStub
<
ICTableSwitch
>
(
space
code
table
low
length
defaultpc
)
;
}
void
ICTableSwitch
:
:
fixupJumpTable
(
JSScript
*
script
BaselineScript
*
baseline
)
{
defaultTarget_
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
defaultTarget_
)
;
for
(
int32_t
i
=
0
;
i
<
length_
;
i
+
+
)
table_
[
i
]
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
table_
[
i
]
)
;
}
static
bool
DoIteratorNewFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIteratorNew_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
FallbackICSpew
(
cx
stub
"
IteratorNew
"
)
;
uint8_t
flags
=
GET_UINT8
(
pc
)
;
res
.
set
(
value
)
;
RootedObject
iterobj
(
cx
ValueToIterator
(
cx
flags
res
)
)
;
if
(
!
iterobj
)
return
false
;
res
.
setObject
(
*
iterobj
)
;
return
true
;
}
typedef
bool
(
*
DoIteratorNewFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIteratorNew_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoIteratorNewFallbackInfo
=
FunctionInfo
<
DoIteratorNewFallbackFn
>
(
DoIteratorNewFallback
"
DoIteratorNewFallback
"
TailCall
PopValues
(
1
)
)
;
bool
ICIteratorNew_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoIteratorNewFallbackInfo
masm
)
;
}
static
bool
DoIteratorMoreFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIteratorMore_Fallback
*
stub_
HandleObject
iterObj
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIteratorMore_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
IteratorMore
"
)
;
if
(
!
IteratorMore
(
cx
iterObj
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
res
.
isMagic
(
JS_NO_ITER_VALUE
)
&
&
!
res
.
isString
(
)
)
stub
-
>
setHasNonStringResult
(
)
;
if
(
iterObj
-
>
is
<
PropertyIteratorObject
>
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
IteratorMore_Native
)
)
{
ICIteratorMore_Native
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
}
return
true
;
}
typedef
bool
(
*
DoIteratorMoreFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIteratorMore_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoIteratorMoreFallbackInfo
=
FunctionInfo
<
DoIteratorMoreFallbackFn
>
(
DoIteratorMoreFallback
"
DoIteratorMoreFallback
"
TailCall
)
;
bool
ICIteratorMore_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
unboxObject
(
R0
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoIteratorMoreFallbackInfo
masm
)
;
}
bool
ICIteratorMore_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
nativeIterator
=
regs
.
takeAny
(
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
obj
scratch
&
PropertyIteratorObject
:
:
class_
&
failure
)
;
masm
.
loadObjPrivate
(
obj
JSObject
:
:
ITER_CLASS_NFIXED_SLOTS
nativeIterator
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
nativeIterator
offsetof
(
NativeIterator
flags
)
)
Imm32
(
JSITER_FOREACH
)
&
failure
)
;
Label
iterDone
;
Address
cursorAddr
(
nativeIterator
offsetof
(
NativeIterator
props_cursor
)
)
;
Address
cursorEndAddr
(
nativeIterator
offsetof
(
NativeIterator
props_end
)
)
;
masm
.
loadPtr
(
cursorAddr
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
BelowOrEqual
cursorEndAddr
scratch
&
iterDone
)
;
masm
.
loadPtr
(
Address
(
scratch
0
)
scratch
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
JSString
*
)
)
cursorAddr
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
scratch
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
iterDone
)
;
masm
.
moveValue
(
MagicValue
(
JS_NO_ITER_VALUE
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoIteratorCloseFallback
(
JSContext
*
cx
ICIteratorClose_Fallback
*
stub
HandleValue
iterValue
)
{
FallbackICSpew
(
cx
stub
"
IteratorClose
"
)
;
RootedObject
iteratorObject
(
cx
&
iterValue
.
toObject
(
)
)
;
return
CloseIterator
(
cx
iteratorObject
)
;
}
typedef
bool
(
*
DoIteratorCloseFallbackFn
)
(
JSContext
*
ICIteratorClose_Fallback
*
HandleValue
)
;
static
const
VMFunction
DoIteratorCloseFallbackInfo
=
FunctionInfo
<
DoIteratorCloseFallbackFn
>
(
DoIteratorCloseFallback
"
DoIteratorCloseFallback
"
TailCall
)
;
bool
ICIteratorClose_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoIteratorCloseFallbackInfo
masm
)
;
}
static
bool
TryAttachInstanceOfStub
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleFunction
fun
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
fun
-
>
isBoundFunction
(
)
)
return
true
;
if
(
!
js
:
:
FunctionHasDefaultHasInstance
(
fun
cx
-
>
wellKnownSymbols
(
)
)
)
return
true
;
if
(
!
fun
-
>
hasStaticPrototype
(
)
|
|
fun
-
>
hasUncacheableProto
(
)
)
return
true
;
Value
funProto
=
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_Function
)
;
if
(
funProto
.
isObject
(
)
&
&
fun
-
>
staticPrototype
(
)
!
=
&
funProto
.
toObject
(
)
)
return
true
;
Shape
*
shape
=
fun
-
>
lookupPure
(
cx
-
>
names
(
)
.
prototype
)
;
if
(
!
shape
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
true
;
uint32_t
slot
=
shape
-
>
slot
(
)
;
MOZ_ASSERT
(
fun
-
>
numFixedSlots
(
)
=
=
0
"
Stub
code
relies
on
this
"
)
;
if
(
!
fun
-
>
getSlot
(
slot
)
.
isObject
(
)
)
return
true
;
JSObject
*
protoObject
=
&
fun
-
>
getSlot
(
slot
)
.
toObject
(
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
InstanceOf
(
Function
)
stub
"
)
;
ICInstanceOf_Function
:
:
Compiler
compiler
(
cx
fun
-
>
lastProperty
(
)
protoObject
slot
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
InstanceOf
"
)
;
if
(
!
rhs
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_BAD_INSTANCEOF_RHS
-
1
rhs
nullptr
)
;
return
false
;
}
RootedObject
obj
(
cx
&
rhs
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
HasInstance
(
cx
obj
lhs
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
EnsureTrackPropertyTypes
(
cx
obj
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICInstanceOf_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
bool
attached
=
false
;
if
(
!
TryAttachInstanceOfStub
(
cx
frame
stub
fun
&
attached
)
)
return
false
;
if
(
!
attached
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoInstanceOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICInstanceOf_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInstanceOfFallbackInfo
=
FunctionInfo
<
DoInstanceOfFallbackFn
>
(
DoInstanceOfFallback
"
DoInstanceOfFallback
"
TailCall
PopValues
(
2
)
)
;
bool
ICInstanceOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInstanceOfFallbackInfo
masm
)
;
}
bool
ICInstanceOf_Function
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
rhsObj
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Label
failureRestoreR1
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
regs
.
takeUnchecked
(
rhsObj
)
;
Register
scratch1
=
regs
.
takeAny
(
)
;
Register
scratch2
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfShape
(
)
)
scratch1
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
rhsObj
scratch1
&
failureRestoreR1
)
;
masm
.
loadPtr
(
Address
(
rhsObj
NativeObject
:
:
offsetOfSlots
(
)
)
scratch1
)
;
masm
.
load32
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfSlot
(
)
)
scratch2
)
;
BaseValueIndex
prototypeSlot
(
scratch1
scratch2
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
prototypeSlot
&
failureRestoreR1
)
;
masm
.
unboxObject
(
prototypeSlot
scratch1
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfPrototypeObject
(
)
)
scratch1
&
failureRestoreR1
)
;
Label
returnFalse
returnTrue
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
returnFalse
)
;
masm
.
unboxObject
(
R0
scratch2
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
{
Label
loop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
scratch1
&
returnTrue
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch2
scratch2
&
returnFalse
)
;
MOZ_ASSERT
(
uintptr_t
(
TaggedProto
:
:
LazyProto
)
=
=
1
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
ImmWord
(
1
)
&
failureRestoreR1
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
masm
.
jump
(
&
loop
)
;
}
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreR1
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
rhsObj
R1
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeOf_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
TypeOf
"
)
;
JSType
type
=
js
:
:
TypeOfValue
(
val
)
;
RootedString
string
(
cx
TypeName
(
type
cx
-
>
names
(
)
)
)
;
res
.
setString
(
string
)
;
MOZ_ASSERT
(
type
!
=
JSTYPE_NULL
)
;
if
(
type
!
=
JSTYPE_OBJECT
&
&
type
!
=
JSTYPE_FUNCTION
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
TypeOf
stub
for
JSType
(
%
d
)
"
(
int
)
type
)
;
ICTypeOf_Typed
:
:
Compiler
compiler
(
cx
type
string
)
;
ICStub
*
typeOfStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
typeOfStub
)
return
false
;
stub
-
>
addNewStub
(
typeOfStub
)
;
}
return
true
;
}
typedef
bool
(
*
DoTypeOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
frame
ICTypeOf_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoTypeOfFallbackInfo
=
FunctionInfo
<
DoTypeOfFallbackFn
>
(
DoTypeOfFallback
"
DoTypeOfFallback
"
TailCall
)
;
bool
ICTypeOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoTypeOfFallbackInfo
masm
)
;
}
bool
ICTypeOf_Typed
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_NULL
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_FUNCTION
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_OBJECT
)
;
Label
failure
;
switch
(
type_
)
{
case
JSTYPE_VOID
:
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_STRING
:
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_NUMBER
:
masm
.
branchTestNumber
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_BOOLEAN
:
masm
.
branchTestBoolean
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_SYMBOL
:
masm
.
branchTestSymbol
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
type
"
)
;
}
masm
.
movePtr
(
ImmGCPtr
(
typeString_
)
R0
.
scratchReg
(
)
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
R0
.
scratchReg
(
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoRetSubFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRetSub_Fallback
*
stub
HandleValue
val
uint8_t
*
*
resumeAddr
)
{
FallbackICSpew
(
cx
stub
"
RetSub
"
)
;
MOZ_ASSERT
(
val
.
isInt32
(
)
)
;
MOZ_ASSERT
(
val
.
toInt32
(
)
>
=
0
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
uint32_t
offset
=
uint32_t
(
val
.
toInt32
(
)
)
;
*
resumeAddr
=
script
-
>
baselineScript
(
)
-
>
nativeCodeForPC
(
script
script
-
>
offsetToPC
(
offset
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICRetSub_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
RetSub
stub
for
pc
offset
%
u
"
offset
)
;
ICRetSub_Resume
:
:
Compiler
compiler
(
cx
offset
*
resumeAddr
)
;
ICStub
*
optStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
optStub
)
return
false
;
stub
-
>
addNewStub
(
optStub
)
;
return
true
;
}
typedef
bool
(
*
DoRetSubFallbackFn
)
(
JSContext
*
cx
BaselineFrame
*
ICRetSub_Fallback
*
HandleValue
uint8_t
*
*
)
;
static
const
VMFunction
DoRetSubFallbackInfo
=
FunctionInfo
<
DoRetSubFallbackFn
>
(
DoRetSubFallback
"
DoRetSubFallback
"
)
;
typedef
bool
(
*
ThrowFn
)
(
JSContext
*
HandleValue
)
;
static
const
VMFunction
ThrowInfoBaseline
=
FunctionInfo
<
ThrowFn
>
(
js
:
:
Throw
"
ThrowInfoBaseline
"
TailCall
)
;
bool
ICRetSub_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
{
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
regs
.
take
(
R1
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
Register
scratch
=
regs
.
getAny
(
)
;
enterStubFrame
(
masm
scratch
)
;
masm
.
pushValue
(
R1
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
scratch
)
;
if
(
!
callVM
(
DoRetSubFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitChangeICReturnAddress
(
masm
ReturnReg
)
;
EmitReturnFromIC
(
masm
)
;
}
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
return
tailCallVM
(
ThrowInfoBaseline
masm
)
;
}
bool
ICRetSub_Resume
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
fail
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
Register
offset
=
masm
.
extractInt32
(
R1
ExtractTemp0
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfPCOffset
(
)
)
offset
&
fail
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfAddr
(
)
)
R0
.
scratchReg
(
)
)
;
EmitChangeICReturnAddress
(
masm
R0
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
if
(
!
tailCallVM
(
ThrowInfoBaseline
masm
)
)
return
false
;
masm
.
bind
(
&
fail
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICTypeMonitor_SingleObject
:
:
ICTypeMonitor_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeMonitor_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeMonitor_ObjectGroup
:
:
ICTypeMonitor_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeMonitor_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICTypeUpdate_SingleObject
:
:
ICTypeUpdate_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeUpdate_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeUpdate_ObjectGroup
:
:
ICTypeUpdate_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeUpdate_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICSetElem_DenseOrUnboxedArray
:
:
ICSetElem_DenseOrUnboxedArray
(
JitCode
*
stubCode
Shape
*
shape
ObjectGroup
*
group
)
:
ICUpdatedStub
(
SetElem_DenseOrUnboxedArray
stubCode
)
shape_
(
shape
)
group_
(
group
)
{
}
ICSetElem_DenseOrUnboxedArrayAdd
:
:
ICSetElem_DenseOrUnboxedArrayAdd
(
JitCode
*
stubCode
ObjectGroup
*
group
size_t
protoChainDepth
)
:
ICUpdatedStub
(
SetElem_DenseOrUnboxedArrayAdd
stubCode
)
group_
(
group
)
{
MOZ_ASSERT
(
protoChainDepth
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
extra_
=
protoChainDepth
;
}
template
<
size_t
ProtoChainDepth
>
ICUpdatedStub
*
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
getStubSpecific
(
ICStubSpace
*
space
Handle
<
ShapeVector
>
shapes
)
{
RootedObjectGroup
group
(
cx
JSObject
:
:
getGroup
(
cx
obj_
)
)
;
if
(
!
group
)
return
nullptr
;
Rooted
<
JitCode
*
>
stubCode
(
cx
getStubCode
(
)
)
;
return
newStub
<
ICSetElem_DenseOrUnboxedArrayAddImpl
<
ProtoChainDepth
>
>
(
space
stubCode
group
shapes
)
;
}
ICSetElem_TypedArray
:
:
ICSetElem_TypedArray
(
JitCode
*
stubCode
Shape
*
shape
Scalar
:
:
Type
type
bool
expectOutOfBounds
)
:
ICStub
(
SetElem_TypedArray
stubCode
)
shape_
(
shape
)
{
extra_
=
uint8_t
(
type
)
;
MOZ_ASSERT
(
extra_
=
=
type
)
;
extra_
|
=
(
static_cast
<
uint16_t
>
(
expectOutOfBounds
)
<
<
8
)
;
}
ICInNativeStub
:
:
ICInNativeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
HandleShape
shape
HandlePropertyName
name
)
:
ICStub
(
kind
stubCode
)
shape_
(
shape
)
name_
(
name
)
{
}
ICIn_NativePrototype
:
:
ICIn_NativePrototype
(
JitCode
*
stubCode
HandleShape
shape
HandlePropertyName
name
HandleObject
holder
HandleShape
holderShape
)
:
ICInNativeStub
(
In_NativePrototype
stubCode
shape
name
)
holder_
(
holder
)
holderShape_
(
holderShape
)
{
}
ICIn_NativeDoesNotExist
:
:
ICIn_NativeDoesNotExist
(
JitCode
*
stubCode
size_t
protoChainDepth
HandlePropertyName
name
)
:
ICStub
(
In_NativeDoesNotExist
stubCode
)
name_
(
name
)
{
MOZ_ASSERT
(
protoChainDepth
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
extra_
=
protoChainDepth
;
}
size_t
ICIn_NativeDoesNotExist
:
:
offsetOfShape
(
size_t
idx
)
{
MOZ_ASSERT
(
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
idx
)
=
=
ICIn_NativeDoesNotExistImpl
<
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
>
:
:
offsetOfShape
(
idx
)
)
;
return
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
idx
)
;
}
template
<
size_t
ProtoChainDepth
>
ICIn_NativeDoesNotExistImpl
<
ProtoChainDepth
>
:
:
ICIn_NativeDoesNotExistImpl
(
JitCode
*
stubCode
Handle
<
ShapeVector
>
shapes
HandlePropertyName
name
)
:
ICIn_NativeDoesNotExist
(
stubCode
ProtoChainDepth
name
)
{
MOZ_ASSERT
(
shapes
.
length
(
)
=
=
NumShapes
)
;
for
(
size_t
i
=
0
;
i
<
NumShapes
;
i
+
+
)
shapes_
[
i
]
.
init
(
shapes
[
i
]
)
;
}
ICInNativeDoesNotExistCompiler
:
:
ICInNativeDoesNotExistCompiler
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
size_t
protoChainDepth
)
:
ICStubCompiler
(
cx
ICStub
:
:
In_NativeDoesNotExist
Engine
:
:
Baseline
)
obj_
(
cx
obj
)
name_
(
cx
name
)
protoChainDepth_
(
protoChainDepth
)
{
MOZ_ASSERT
(
protoChainDepth_
<
=
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
)
;
}
ICGetIntrinsic_Constant
:
:
ICGetIntrinsic_Constant
(
JitCode
*
stubCode
const
Value
&
value
)
:
ICStub
(
GetIntrinsic_Constant
stubCode
)
value_
(
value
)
{
}
ICGetIntrinsic_Constant
:
:
~
ICGetIntrinsic_Constant
(
)
{
}
ICInstanceOf_Function
:
:
ICInstanceOf_Function
(
JitCode
*
stubCode
Shape
*
shape
JSObject
*
prototypeObj
uint32_t
slot
)
:
ICStub
(
InstanceOf_Function
stubCode
)
shape_
(
shape
)
prototypeObj_
(
prototypeObj
)
slot_
(
slot
)
{
}
ICCall_Scripted
:
:
ICCall_Scripted
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Scripted
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
}
ICCall_Scripted
*
ICCall_Scripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Scripted
&
other
)
{
return
New
<
ICCall_Scripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_AnyScripted
*
ICCall_AnyScripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_AnyScripted
&
other
)
{
return
New
<
ICCall_AnyScripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_Native
:
:
ICCall_Native
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Native
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
JS_FUNC_TO_DATA_PTR
(
void
*
callee
-
>
native
(
)
)
Args_General3
)
;
#
endif
}
ICCall_Native
*
ICCall_Native
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Native
&
other
)
{
return
New
<
ICCall_Native
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_ClassHook
:
:
ICCall_ClassHook
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
const
Class
*
clasp
Native
native
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_ClassHook
stubCode
firstMonitorStub
)
clasp_
(
clasp
)
native_
(
JS_FUNC_TO_DATA_PTR
(
void
*
native
)
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
native_
Args_General3
)
;
#
endif
}
ICCall_ClassHook
*
ICCall_ClassHook
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ClassHook
&
other
)
{
ICCall_ClassHook
*
res
=
New
<
ICCall_ClassHook
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
clasp
(
)
nullptr
other
.
templateObject_
other
.
pcOffset_
)
;
if
(
res
)
res
-
>
native_
=
other
.
native
(
)
;
return
res
;
}
ICCall_ScriptedApplyArray
*
ICCall_ScriptedApplyArray
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArray
&
other
)
{
return
New
<
ICCall_ScriptedApplyArray
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedApplyArguments
*
ICCall_ScriptedApplyArguments
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArguments
&
other
)
{
return
New
<
ICCall_ScriptedApplyArguments
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedFunCall
*
ICCall_ScriptedFunCall
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedFunCall
&
other
)
{
return
New
<
ICCall_ScriptedFunCall
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
static
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRest_Fallback
*
stub
MutableHandleValue
res
)
{
unsigned
numFormals
=
frame
-
>
numFormalArgs
(
)
-
1
;
unsigned
numActuals
=
frame
-
>
numActualArgs
(
)
;
unsigned
numRest
=
numActuals
>
numFormals
?
numActuals
-
numFormals
:
0
;
Value
*
rest
=
frame
-
>
argv
(
)
+
numFormals
;
JSObject
*
obj
=
ObjectGroup
:
:
newArrayObject
(
cx
rest
numRest
GenericObject
ObjectGroup
:
:
NewArrayKind
:
:
UnknownIndex
)
;
if
(
!
obj
)
return
false
;
res
.
setObject
(
*
obj
)
;
return
true
;
}
typedef
bool
(
*
DoRestFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICRest_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoRestFallbackInfo
=
FunctionInfo
<
DoRestFallbackFn
>
(
DoRestFallback
"
DoRestFallback
"
TailCall
)
;
bool
ICRest_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoRestFallbackInfo
masm
)
;
}
}
}
