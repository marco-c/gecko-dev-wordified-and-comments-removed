#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
jslibmath
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
builtin
/
SIMD
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
BaselineDebugModeOSR
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
ifdef
JS_ION_PERF
#
include
"
jit
/
PerfSpewer
.
h
"
#
endif
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
TypedArrayCommon
.
h
"
#
include
"
jsboolinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
ScopeObject
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
#
include
"
vm
/
UnboxedObject
-
inl
.
h
"
using
mozilla
:
:
DebugOnly
;
namespace
js
{
namespace
jit
{
struct
IonOsrTempData
{
void
*
jitcode
;
uint8_t
*
baselineFrame
;
}
;
static
IonOsrTempData
*
PrepareOsrTempData
(
JSContext
*
cx
ICWarmUpCounter_Fallback
*
stub
BaselineFrame
*
frame
HandleScript
script
jsbytecode
*
pc
void
*
jitcode
)
{
size_t
numLocalsAndStackVals
=
frame
-
>
numValueSlots
(
)
;
size_t
frameSpace
=
sizeof
(
BaselineFrame
)
+
sizeof
(
Value
)
*
numLocalsAndStackVals
;
size_t
ionOsrTempDataSpace
=
sizeof
(
IonOsrTempData
)
;
size_t
totalSpace
=
AlignBytes
(
frameSpace
sizeof
(
Value
)
)
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
IonOsrTempData
*
info
=
(
IonOsrTempData
*
)
cx
-
>
runtime
(
)
-
>
getJitRuntime
(
cx
)
-
>
allocateOsrTempData
(
totalSpace
)
;
if
(
!
info
)
return
nullptr
;
memset
(
info
0
totalSpace
)
;
info
-
>
jitcode
=
jitcode
;
uint8_t
*
frameStart
=
(
uint8_t
*
)
info
+
AlignBytes
(
ionOsrTempDataSpace
sizeof
(
Value
)
)
;
info
-
>
baselineFrame
=
frameStart
+
frameSpace
;
memcpy
(
frameStart
(
uint8_t
*
)
frame
-
numLocalsAndStackVals
*
sizeof
(
Value
)
frameSpace
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Allocated
IonOsrTempData
at
%
p
"
(
void
*
)
info
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Jitcode
is
%
p
"
info
-
>
jitcode
)
;
return
info
;
}
static
bool
DoWarmUpCounterFallbackOSR
(
JSContext
*
cx
BaselineFrame
*
frame
ICWarmUpCounter_Fallback
*
stub
IonOsrTempData
*
*
infoPtr
)
{
MOZ_ASSERT
(
infoPtr
)
;
*
infoPtr
=
nullptr
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOP_LOOPENTRY
)
;
FallbackICSpew
(
cx
stub
"
WarmUpCounter
(
%
d
)
"
int
(
script
-
>
pcToOffset
(
pc
)
)
)
;
if
(
!
IonCompileScriptForBaseline
(
cx
frame
pc
)
)
return
false
;
if
(
!
script
-
>
hasIonScript
(
)
|
|
script
-
>
ionScript
(
)
-
>
osrPc
(
)
!
=
pc
|
|
script
-
>
ionScript
(
)
-
>
bailoutExpected
(
)
|
|
frame
-
>
isDebuggee
(
)
)
{
return
true
;
}
IonScript
*
ion
=
script
-
>
ionScript
(
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
spsProfiler
.
enabled
(
)
=
=
ion
-
>
hasProfilingInstrumentation
(
)
)
;
MOZ_ASSERT
(
ion
-
>
osrPc
(
)
=
=
pc
)
;
JitSpew
(
JitSpew_BaselineOSR
"
OSR
possible
!
"
)
;
void
*
jitcode
=
ion
-
>
method
(
)
-
>
raw
(
)
+
ion
-
>
osrEntryOffset
(
)
;
JitSpew
(
JitSpew_BaselineOSR
"
Got
jitcode
.
Preparing
for
OSR
into
ion
.
"
)
;
IonOsrTempData
*
info
=
PrepareOsrTempData
(
cx
stub
frame
script
pc
jitcode
)
;
if
(
!
info
)
return
false
;
*
infoPtr
=
info
;
return
true
;
}
typedef
bool
(
*
DoWarmUpCounterFallbackOSRFn
)
(
JSContext
*
BaselineFrame
*
ICWarmUpCounter_Fallback
*
IonOsrTempData
*
*
infoPtr
)
;
static
const
VMFunction
DoWarmUpCounterFallbackOSRInfo
=
FunctionInfo
<
DoWarmUpCounterFallbackOSRFn
>
(
DoWarmUpCounterFallbackOSR
)
;
bool
ICWarmUpCounter_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
Label
noCompiledCode
;
{
masm
.
subFromStackPtr
(
Imm32
(
sizeof
(
void
*
)
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoWarmUpCounterFallbackOSRInfo
masm
)
)
return
false
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
leaveStubFrame
(
masm
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
R0
.
scratchReg
(
)
ImmPtr
(
nullptr
)
&
noCompiledCode
)
;
}
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
osrDataReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
osrDataReg
)
;
regs
.
takeUnchecked
(
OsrFrameReg
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
masm
.
moveToStackPtr
(
BaselineFrameReg
)
;
masm
.
pop
(
scratchReg
)
;
#
ifdef
DEBUG
{
Label
checkOk
;
AbsoluteAddress
addressOfEnabled
(
cx
-
>
runtime
(
)
-
>
spsProfiler
.
addressOfEnabled
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Equal
addressOfEnabled
Imm32
(
0
)
&
checkOk
)
;
masm
.
loadPtr
(
AbsoluteAddress
(
(
void
*
)
&
cx
-
>
runtime
(
)
-
>
jitActivation
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
scratchReg
JitActivation
:
:
offsetOfLastProfilingFrame
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratchReg
ImmWord
(
0
)
&
checkOk
)
;
masm
.
branchStackPtr
(
Assembler
:
:
Equal
scratchReg
&
checkOk
)
;
masm
.
assumeUnreachable
(
"
Baseline
OSR
lastProfilingFrame
mismatch
.
"
)
;
masm
.
bind
(
&
checkOk
)
;
}
#
endif
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
jitcode
)
)
scratchReg
)
;
masm
.
loadPtr
(
Address
(
osrDataReg
offsetof
(
IonOsrTempData
baselineFrame
)
)
OsrFrameReg
)
;
masm
.
jump
(
scratchReg
)
;
masm
.
bind
(
&
noCompiledCode
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
DoTypeUpdateFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICUpdatedStub
*
stub
HandleValue
objval
HandleValue
value
)
{
FallbackICSpew
(
cx
stub
-
>
getChainFallback
(
)
"
TypeUpdate
(
%
s
)
"
ICStub
:
:
KindString
(
stub
-
>
kind
(
)
)
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedObject
obj
(
cx
&
objval
.
toObject
(
)
)
;
RootedId
id
(
cx
)
;
switch
(
stub
-
>
kind
(
)
)
{
case
ICStub
:
:
SetElem_DenseOrUnboxedArray
:
case
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
:
{
id
=
JSID_VOID
;
AddTypePropertyId
(
cx
obj
id
value
)
;
break
;
}
case
ICStub
:
:
SetProp_Native
:
case
ICStub
:
:
SetProp_NativeAdd
:
case
ICStub
:
:
SetProp_Unboxed
:
{
MOZ_ASSERT
(
obj
-
>
isNative
(
)
|
|
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
getChainFallback
(
)
-
>
icEntry
(
)
-
>
pc
(
script
)
;
if
(
*
pc
=
=
JSOP_SETALIASEDVAR
|
|
*
pc
=
=
JSOP_INITALIASEDLEXICAL
)
id
=
NameToId
(
ScopeCoordinateName
(
cx
-
>
runtime
(
)
-
>
scopeCoordinateNameCache
script
pc
)
)
;
else
id
=
NameToId
(
script
-
>
getName
(
pc
)
)
;
AddTypePropertyId
(
cx
obj
id
value
)
;
break
;
}
case
ICStub
:
:
SetProp_TypedObject
:
{
MOZ_ASSERT
(
obj
-
>
is
<
TypedObject
>
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
getChainFallback
(
)
-
>
icEntry
(
)
-
>
pc
(
script
)
;
id
=
NameToId
(
script
-
>
getName
(
pc
)
)
;
if
(
stub
-
>
toSetProp_TypedObject
(
)
-
>
isObjectReference
(
)
)
{
if
(
value
.
isObject
(
)
)
AddTypePropertyId
(
cx
obj
id
value
)
;
}
else
{
if
(
!
value
.
isUndefined
(
)
)
AddTypePropertyId
(
cx
obj
id
value
)
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Invalid
stub
"
)
;
}
return
stub
-
>
addUpdateStubForValue
(
cx
script
obj
id
value
)
;
}
typedef
bool
(
*
DoTypeUpdateFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICUpdatedStub
*
HandleValue
HandleValue
)
;
const
VMFunction
DoTypeUpdateFallbackInfo
=
FunctionInfo
<
DoTypeUpdateFallbackFn
>
(
DoTypeUpdateFallback
NonTailCall
)
;
bool
ICTypeUpdate_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
move32
(
Imm32
(
0
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_PrimitiveSet
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
success
;
if
(
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_INT32
)
)
&
&
!
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
)
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_DOUBLE
)
)
masm
.
branchTestNumber
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_UNDEFINED
)
)
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_BOOLEAN
)
)
masm
.
branchTestBoolean
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_STRING
)
)
masm
.
branchTestString
(
Assembler
:
:
Equal
R0
&
success
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_SYMBOL
)
)
masm
.
branchTestSymbol
(
Assembler
:
:
Equal
R0
&
success
)
;
MOZ_ASSERT
(
!
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_OBJECT
)
)
)
;
if
(
flags_
&
TypeToFlag
(
JSVAL_TYPE_NULL
)
)
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
success
)
;
EmitStubGuardFailure
(
masm
)
;
masm
.
bind
(
&
success
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_SingleObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
Address
expectedObject
(
ICStubReg
ICTypeUpdate_SingleObject
:
:
offsetOfObject
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedObject
obj
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_ObjectGroup
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
R1
.
scratchReg
(
)
)
;
Address
expectedGroup
(
ICStubReg
ICTypeUpdate_ObjectGroup
:
:
offsetOfGroup
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedGroup
R1
.
scratchReg
(
)
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
typedef
bool
(
*
DoCallNativeGetterFn
)
(
JSContext
*
HandleFunction
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoCallNativeGetterInfo
=
FunctionInfo
<
DoCallNativeGetterFn
>
(
DoCallNativeGetter
)
;
static
bool
DoNewArray
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewArray_Fallback
*
stub
uint32_t
length
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
NewArray
"
)
;
RootedObject
obj
(
cx
)
;
if
(
stub
-
>
templateObject
(
)
)
{
RootedObject
templateObject
(
cx
stub
-
>
templateObject
(
)
)
;
obj
=
NewArrayOperationWithTemplate
(
cx
templateObject
)
;
if
(
!
obj
)
return
false
;
}
else
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
obj
=
NewArrayOperation
(
cx
script
pc
length
)
;
if
(
!
obj
)
return
false
;
if
(
obj
&
&
!
obj
-
>
isSingleton
(
)
&
&
!
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
{
JSObject
*
templateObject
=
NewArrayOperation
(
cx
script
pc
length
TenuredObject
)
;
if
(
!
templateObject
)
return
false
;
stub
-
>
setTemplateObject
(
templateObject
)
;
}
}
res
.
setObject
(
*
obj
)
;
return
true
;
}
typedef
bool
(
*
DoNewArrayFn
)
(
JSContext
*
BaselineFrame
*
ICNewArray_Fallback
*
uint32_t
MutableHandleValue
)
;
static
const
VMFunction
DoNewArrayInfo
=
FunctionInfo
<
DoNewArrayFn
>
(
DoNewArray
TailCall
)
;
bool
ICNewArray_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoNewArrayInfo
masm
)
;
}
static
JitCode
*
GenerateNewObjectWithTemplateCode
(
JSContext
*
cx
JSObject
*
templateObject
)
{
JitContext
jctx
(
cx
nullptr
)
;
MacroAssembler
masm
;
#
ifdef
JS_CODEGEN_ARM
masm
.
setSecondScratchReg
(
BaselineSecondScratchReg
)
;
#
endif
Label
failure
;
Register
objReg
=
R0
.
scratchReg
(
)
;
Register
tempReg
=
R1
.
scratchReg
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
templateObject
-
>
group
(
)
)
tempReg
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
tempReg
ObjectGroup
:
:
offsetOfFlags
(
)
)
Imm32
(
OBJECT_FLAG_PRE_TENURE
)
&
failure
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
AbsoluteAddress
(
cx
-
>
compartment
(
)
-
>
addressOfMetadataCallback
(
)
)
ImmWord
(
0
)
&
failure
)
;
masm
.
createGCObject
(
objReg
tempReg
templateObject
gc
:
:
DefaultHeap
&
failure
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
objReg
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
Linker
linker
(
masm
)
;
AutoFlushICache
afc
(
"
GenerateNewObjectWithTemplateCode
"
)
;
return
linker
.
newCode
<
CanGC
>
(
cx
BASELINE_CODE
)
;
}
static
bool
DoNewObject
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewObject_Fallback
*
stub
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
NewObject
"
)
;
RootedObject
obj
(
cx
)
;
RootedObject
templateObject
(
cx
stub
-
>
templateObject
(
)
)
;
if
(
templateObject
)
{
MOZ_ASSERT
(
!
templateObject
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
;
obj
=
NewObjectOperationWithTemplate
(
cx
templateObject
)
;
}
else
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
obj
=
NewObjectOperation
(
cx
script
pc
)
;
if
(
obj
&
&
!
obj
-
>
isSingleton
(
)
&
&
!
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
{
JSObject
*
templateObject
=
NewObjectOperation
(
cx
script
pc
TenuredObject
)
;
if
(
!
templateObject
)
return
false
;
if
(
templateObject
-
>
is
<
UnboxedPlainObject
>
(
)
|
|
!
templateObject
-
>
as
<
PlainObject
>
(
)
.
hasDynamicSlots
(
)
)
{
JitCode
*
code
=
GenerateNewObjectWithTemplateCode
(
cx
templateObject
)
;
if
(
!
code
)
return
false
;
ICStubSpace
*
space
=
ICStubCompiler
:
:
StubSpaceForKind
(
ICStub
:
:
NewObject_WithTemplate
script
ICStubCompiler
:
:
Engine
:
:
Baseline
)
;
ICStub
*
templateStub
=
ICStub
:
:
New
<
ICNewObject_WithTemplate
>
(
cx
space
code
)
;
if
(
!
templateStub
)
return
false
;
stub
-
>
addNewStub
(
templateStub
)
;
}
stub
-
>
setTemplateObject
(
templateObject
)
;
}
}
if
(
!
obj
)
return
false
;
res
.
setObject
(
*
obj
)
;
return
true
;
}
typedef
bool
(
*
DoNewObjectFn
)
(
JSContext
*
BaselineFrame
*
ICNewObject_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoNewObjectInfo
=
FunctionInfo
<
DoNewObjectFn
>
(
DoNewObject
TailCall
)
;
bool
ICNewObject_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoNewObjectInfo
masm
)
;
}
static
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToBool_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToBool
"
)
;
bool
cond
=
ToBoolean
(
arg
)
;
ret
.
setBoolean
(
cond
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICToBool_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
MOZ_ASSERT
(
!
arg
.
isBoolean
(
)
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
if
(
arg
.
isInt32
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Int32
)
stub
.
"
)
;
ICToBool_Int32
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
int32Stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
int32Stub
)
return
false
;
stub
-
>
addNewStub
(
int32Stub
)
;
return
true
;
}
if
(
arg
.
isDouble
(
)
&
&
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Double
)
stub
.
"
)
;
ICToBool_Double
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
doubleStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
doubleStub
)
return
false
;
stub
-
>
addNewStub
(
doubleStub
)
;
return
true
;
}
if
(
arg
.
isString
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
String
)
stub
"
)
;
ICToBool_String
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stringStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
stringStub
)
return
false
;
stub
-
>
addNewStub
(
stringStub
)
;
return
true
;
}
if
(
arg
.
isNull
(
)
|
|
arg
.
isUndefined
(
)
)
{
ICToBool_NullUndefined
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
nilStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
nilStub
)
return
false
;
stub
-
>
addNewStub
(
nilStub
)
;
return
true
;
}
if
(
arg
.
isObject
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
ToBool
(
Object
)
stub
.
"
)
;
ICToBool_Object
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
objStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
objStub
)
return
false
;
stub
-
>
addNewStub
(
objStub
)
;
return
true
;
}
return
true
;
}
typedef
bool
(
*
pf
)
(
JSContext
*
BaselineFrame
*
ICToBool_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
fun
=
FunctionInfo
<
pf
>
(
DoToBoolFallback
TailCall
)
;
bool
ICToBool_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
fun
masm
)
;
}
bool
ICToBool_Int32
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestInt32Truthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_String
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Label
ifFalse
;
masm
.
branchTestStringTruthy
(
false
R0
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_NullUndefined
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifFalse
;
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
ifFalse
)
;
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Double
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifTrue
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
branchTestDoubleTruthy
(
true
FloatReg0
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICToBool_Object
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
ifFalse
slowPath
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchTestObjectTruthy
(
false
objReg
scratch
&
slowPath
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
ifFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
slowPath
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
objReg
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
js
:
:
EmulatesUndefined
)
)
;
masm
.
convertBoolToInt32
(
ReturnReg
ReturnReg
)
;
masm
.
xor32
(
Imm32
(
1
)
ReturnReg
)
;
masm
.
tagValue
(
JSVAL_TYPE_BOOLEAN
ReturnReg
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoToNumberFallback
(
JSContext
*
cx
ICToNumber_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
FallbackICSpew
(
cx
stub
"
ToNumber
"
)
;
ret
.
set
(
arg
)
;
return
ToNumber
(
cx
ret
)
;
}
typedef
bool
(
*
DoToNumberFallbackFn
)
(
JSContext
*
ICToNumber_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoToNumberFallbackInfo
=
FunctionInfo
<
DoToNumberFallbackFn
>
(
DoToNumberFallback
TailCall
PopValues
(
1
)
)
;
bool
ICToNumber_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoToNumberFallbackInfo
masm
)
;
}
static
Shape
*
LastPropertyForSetProp
(
JSObject
*
obj
)
{
if
(
obj
-
>
isNative
(
)
)
return
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
return
expando
?
expando
-
>
lastProperty
(
)
:
nullptr
;
}
return
nullptr
;
}
static
bool
IsCacheableSetPropWriteSlot
(
JSObject
*
obj
Shape
*
oldShape
Shape
*
propertyShape
)
{
if
(
LastPropertyForSetProp
(
obj
)
!
=
oldShape
)
return
false
;
if
(
!
propertyShape
-
>
hasSlot
(
)
|
|
!
propertyShape
-
>
hasDefaultSetter
(
)
|
|
!
propertyShape
-
>
writable
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsCacheableSetPropAddSlot
(
JSContext
*
cx
JSObject
*
obj
Shape
*
oldShape
jsid
id
Shape
*
propertyShape
size_t
*
protoChainDepth
)
{
if
(
LastPropertyForSetProp
(
obj
)
!
=
propertyShape
)
return
false
;
if
(
!
obj
-
>
nonProxyIsExtensible
(
)
|
|
propertyShape
-
>
previous
(
)
!
=
oldShape
)
return
false
;
if
(
propertyShape
-
>
inDictionary
(
)
|
|
!
propertyShape
-
>
hasSlot
(
)
|
|
!
propertyShape
-
>
hasDefaultSetter
(
)
|
|
!
propertyShape
-
>
writable
(
)
)
{
return
false
;
}
if
(
ClassMayResolveId
(
cx
-
>
names
(
)
obj
-
>
getClass
(
)
id
obj
)
|
|
obj
-
>
getClass
(
)
-
>
addProperty
)
{
return
false
;
}
size_t
chainDepth
=
0
;
for
(
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
proto
;
proto
=
proto
-
>
getProto
(
)
)
{
chainDepth
+
+
;
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
Shape
*
protoShape
=
proto
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx
id
)
;
if
(
protoShape
&
&
!
protoShape
-
>
hasDefaultSetter
(
)
)
return
false
;
if
(
ClassMayResolveId
(
cx
-
>
names
(
)
proto
-
>
getClass
(
)
id
proto
)
)
return
false
;
}
if
(
NativeObject
:
:
dynamicSlotsCount
(
propertyShape
)
!
=
NativeObject
:
:
dynamicSlotsCount
(
oldShape
)
)
return
false
;
*
protoChainDepth
=
chainDepth
;
return
true
;
}
static
bool
IsCacheableSetPropCall
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
holder
Shape
*
shape
bool
*
isScripted
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
isScripted
)
;
if
(
!
shape
|
|
!
IsCacheableProtoChain
(
obj
holder
)
)
return
false
;
if
(
shape
-
>
hasSlot
(
)
|
|
shape
-
>
hasDefaultSetter
(
)
)
return
false
;
if
(
!
shape
-
>
hasSetterValue
(
)
)
return
false
;
if
(
!
shape
-
>
setterValue
(
)
.
isObject
(
)
|
|
!
shape
-
>
setterObject
(
)
-
>
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
*
func
=
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
;
if
(
func
-
>
isNative
(
)
)
{
*
isScripted
=
false
;
return
true
;
}
if
(
!
func
-
>
hasJITCode
(
)
)
{
*
isTemporarilyUnoptimizable
=
true
;
return
false
;
}
*
isScripted
=
true
;
return
true
;
}
template
<
class
T
>
static
bool
GetElemNativeStubExists
(
ICGetElem_Fallback
*
stub
HandleObject
obj
HandleObject
holder
Handle
<
T
>
key
bool
needsAtomize
)
{
bool
indirect
=
(
obj
.
get
(
)
!
=
holder
.
get
(
)
)
;
MOZ_ASSERT_IF
(
indirect
holder
-
>
isNative
(
)
)
;
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativeSlotName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativeSlotSymbol
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeSlotName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeSlotSymbol
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallNativeName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
)
{
continue
;
}
if
(
indirect
&
&
(
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeSlotName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeSlotSymbol
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallNativeName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
&
&
iter
-
>
kind
(
)
!
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
)
)
{
continue
;
}
if
(
mozilla
:
:
IsSame
<
T
JS
:
:
Symbol
*
>
:
:
value
!
=
static_cast
<
ICGetElemNativeStub
*
>
(
*
iter
)
-
>
isSymbol
(
)
)
{
continue
;
}
ICGetElemNativeStubImpl
<
T
>
*
getElemNativeStub
=
reinterpret_cast
<
ICGetElemNativeStubImpl
<
T
>
*
>
(
*
iter
)
;
if
(
key
!
=
getElemNativeStub
-
>
key
(
)
)
continue
;
if
(
ReceiverGuard
(
obj
)
!
=
getElemNativeStub
-
>
receiverGuard
(
)
)
continue
;
if
(
needsAtomize
&
&
!
getElemNativeStub
-
>
needsAtomize
(
)
)
continue
;
if
(
indirect
)
{
if
(
iter
-
>
isGetElem_NativePrototypeSlotName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeSlotSymbol
(
)
)
{
ICGetElem_NativePrototypeSlot
<
T
>
*
protoStub
=
reinterpret_cast
<
ICGetElem_NativePrototypeSlot
<
T
>
*
>
(
*
iter
)
;
if
(
holder
!
=
protoStub
-
>
holder
(
)
)
continue
;
if
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
protoStub
-
>
holderShape
(
)
)
continue
;
}
else
{
MOZ_ASSERT
(
iter
-
>
isGetElem_NativePrototypeCallNativeName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallNativeSymbol
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallScriptedName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallScriptedSymbol
(
)
)
;
ICGetElemNativePrototypeCallStub
<
T
>
*
protoStub
=
reinterpret_cast
<
ICGetElemNativePrototypeCallStub
<
T
>
*
>
(
*
iter
)
;
if
(
holder
!
=
protoStub
-
>
holder
(
)
)
continue
;
if
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
protoStub
-
>
holderShape
(
)
)
continue
;
}
}
return
true
;
}
return
false
;
}
template
<
class
T
>
static
void
RemoveExistingGetElemNativeStubs
(
JSContext
*
cx
ICGetElem_Fallback
*
stub
HandleObject
obj
HandleObject
holder
Handle
<
T
>
key
bool
needsAtomize
)
{
bool
indirect
=
(
obj
.
get
(
)
!
=
holder
.
get
(
)
)
;
MOZ_ASSERT_IF
(
indirect
holder
-
>
isNative
(
)
)
;
for
(
ICStubIterator
iter
=
stub
-
>
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
switch
(
iter
-
>
kind
(
)
)
{
case
ICStub
:
:
GetElem_NativeSlotName
:
case
ICStub
:
:
GetElem_NativeSlotSymbol
:
if
(
indirect
)
continue
;
MOZ_FALLTHROUGH
;
case
ICStub
:
:
GetElem_NativePrototypeSlotName
:
case
ICStub
:
:
GetElem_NativePrototypeSlotSymbol
:
case
ICStub
:
:
GetElem_NativePrototypeCallNativeName
:
case
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
:
case
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
:
case
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
:
break
;
default
:
continue
;
}
if
(
mozilla
:
:
IsSame
<
T
JS
:
:
Symbol
*
>
:
:
value
!
=
static_cast
<
ICGetElemNativeStub
*
>
(
*
iter
)
-
>
isSymbol
(
)
)
{
continue
;
}
ICGetElemNativeStubImpl
<
T
>
*
getElemNativeStub
=
reinterpret_cast
<
ICGetElemNativeStubImpl
<
T
>
*
>
(
*
iter
)
;
if
(
key
!
=
getElemNativeStub
-
>
key
(
)
)
continue
;
if
(
ReceiverGuard
(
obj
)
!
=
getElemNativeStub
-
>
receiverGuard
(
)
)
continue
;
if
(
indirect
)
{
if
(
iter
-
>
isGetElem_NativePrototypeSlotName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeSlotSymbol
(
)
)
{
ICGetElem_NativePrototypeSlot
<
T
>
*
protoStub
=
reinterpret_cast
<
ICGetElem_NativePrototypeSlot
<
T
>
*
>
(
*
iter
)
;
if
(
holder
!
=
protoStub
-
>
holder
(
)
)
continue
;
if
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
protoStub
-
>
holderShape
(
)
)
{
iter
.
unlink
(
cx
)
;
continue
;
}
}
else
{
MOZ_ASSERT
(
iter
-
>
isGetElem_NativePrototypeCallNativeName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallNativeSymbol
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallScriptedName
(
)
|
|
iter
-
>
isGetElem_NativePrototypeCallScriptedSymbol
(
)
)
;
ICGetElemNativePrototypeCallStub
<
T
>
*
protoStub
=
reinterpret_cast
<
ICGetElemNativePrototypeCallStub
<
T
>
*
>
(
*
iter
)
;
if
(
holder
!
=
protoStub
-
>
holder
(
)
)
continue
;
if
(
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
protoStub
-
>
holderShape
(
)
)
{
iter
.
unlink
(
cx
)
;
continue
;
}
}
}
if
(
needsAtomize
&
&
!
getElemNativeStub
-
>
needsAtomize
(
)
)
{
iter
.
unlink
(
cx
)
;
continue
;
}
MOZ_CRASH
(
"
Procedure
should
never
have
been
called
.
"
)
;
}
}
static
bool
TypedArrayGetElemStubExists
(
ICGetElem_Fallback
*
stub
HandleObject
obj
)
{
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isGetElem_TypedArray
(
)
)
continue
;
if
(
obj
-
>
maybeShape
(
)
=
=
iter
-
>
toGetElem_TypedArray
(
)
-
>
shape
(
)
)
return
true
;
}
return
false
;
}
static
bool
ArgumentsGetElemStubExists
(
ICGetElem_Fallback
*
stub
ICGetElem_Arguments
:
:
Which
which
)
{
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isGetElem_Arguments
(
)
)
continue
;
if
(
iter
-
>
toGetElem_Arguments
(
)
-
>
which
(
)
=
=
which
)
return
true
;
}
return
false
;
}
template
<
class
T
>
static
T
getKey
(
jsid
id
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Key
has
to
be
PropertyName
or
Symbol
"
)
;
return
false
;
}
template
<
>
JS
:
:
Symbol
*
getKey
<
JS
:
:
Symbol
*
>
(
jsid
id
)
{
if
(
!
JSID_IS_SYMBOL
(
id
)
)
return
nullptr
;
return
JSID_TO_SYMBOL
(
id
)
;
}
template
<
>
PropertyName
*
getKey
<
PropertyName
*
>
(
jsid
id
)
{
uint32_t
dummy
;
if
(
!
JSID_IS_ATOM
(
id
)
|
|
JSID_TO_ATOM
(
id
)
-
>
isIndex
(
&
dummy
)
)
return
nullptr
;
return
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
;
}
static
bool
IsOptimizableElementPropertyName
(
JSContext
*
cx
HandleValue
key
MutableHandleId
idp
)
{
if
(
!
key
.
isString
(
)
)
return
false
;
if
(
!
ValueToId
<
CanGC
>
(
cx
key
idp
)
)
return
false
;
uint32_t
dummy
;
if
(
!
JSID_IS_ATOM
(
idp
)
|
|
JSID_TO_ATOM
(
idp
)
-
>
isIndex
(
&
dummy
)
)
return
false
;
return
true
;
}
template
<
class
T
>
static
bool
checkAtomize
(
HandleValue
key
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Key
has
to
be
PropertyName
or
Symbol
"
)
;
return
false
;
}
template
<
>
bool
checkAtomize
<
JS
:
:
Symbol
*
>
(
HandleValue
key
)
{
return
false
;
}
template
<
>
bool
checkAtomize
<
PropertyName
*
>
(
HandleValue
key
)
{
return
!
key
.
toString
(
)
-
>
isAtom
(
)
;
}
template
<
class
T
>
static
bool
TryAttachNativeOrUnboxedGetValueElemStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICGetElem_Fallback
*
stub
HandleObject
obj
HandleValue
keyVal
bool
*
attached
)
{
MOZ_ASSERT
(
keyVal
.
isString
(
)
|
|
keyVal
.
isSymbol
(
)
)
;
RootedId
id
(
cx
)
;
if
(
!
ValueToId
<
CanGC
>
(
cx
keyVal
&
id
)
)
return
false
;
Rooted
<
T
>
key
(
cx
getKey
<
T
>
(
id
)
)
;
if
(
!
key
)
return
true
;
bool
needsAtomize
=
checkAtomize
<
T
>
(
keyVal
)
;
RootedShape
shape
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
EffectlesslyLookupProperty
(
cx
obj
id
&
holder
&
shape
)
)
return
false
;
if
(
!
holder
|
|
(
holder
!
=
obj
&
&
!
holder
-
>
isNative
(
)
)
)
return
true
;
if
(
GetElemNativeStubExists
<
T
>
(
stub
obj
holder
key
needsAtomize
)
)
return
true
;
RemoveExistingGetElemNativeStubs
<
T
>
(
cx
stub
obj
holder
key
needsAtomize
)
;
ICStub
*
monitorStub
=
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
&
&
holder
=
=
obj
)
{
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
MOZ_ASSERT_IF
(
!
keyVal
.
isString
(
)
!
property
)
;
if
(
property
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
true
;
RootedPropertyName
name
(
cx
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
ICGetElemNativeCompiler
<
PropertyName
*
>
compiler
(
cx
ICStub
:
:
GetElem_UnboxedPropertyName
monitorStub
obj
holder
name
ICGetElemNativeStub
:
:
UnboxedProperty
needsAtomize
property
-
>
offset
+
UnboxedPlainObject
:
:
offsetOfData
(
)
property
-
>
type
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
Shape
*
shape
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
-
>
lookup
(
cx
id
)
;
if
(
!
shape
-
>
hasDefaultGetter
(
)
|
|
!
shape
-
>
hasSlot
(
)
)
return
true
;
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
ICGetElemNativeStub
:
:
AccessType
acctype
=
isFixedSlot
?
ICGetElemNativeStub
:
:
FixedSlot
:
ICGetElemNativeStub
:
:
DynamicSlot
;
ICGetElemNativeCompiler
<
T
>
compiler
(
cx
getGetElemStubKind
<
T
>
(
ICStub
:
:
GetElem_NativeSlotName
)
monitorStub
obj
holder
key
acctype
needsAtomize
offset
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
!
holder
-
>
isNative
(
)
)
return
true
;
if
(
IsCacheableGetPropReadSlot
(
obj
holder
shape
)
)
{
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
ICStub
:
:
Kind
kind
=
(
obj
=
=
holder
)
?
ICStub
:
:
GetElem_NativeSlotName
:
ICStub
:
:
GetElem_NativePrototypeSlotName
;
kind
=
getGetElemStubKind
<
T
>
(
kind
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
Native
%
s
%
s
slot
)
stub
"
"
(
obj
=
%
p
holder
=
%
p
holderShape
=
%
p
)
"
(
obj
=
=
holder
)
?
"
direct
"
:
"
prototype
"
needsAtomize
?
"
atomizing
"
:
"
"
obj
.
get
(
)
holder
.
get
(
)
holder
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
AccType
acctype
=
isFixedSlot
?
ICGetElemNativeStub
:
:
FixedSlot
:
ICGetElemNativeStub
:
:
DynamicSlot
;
ICGetElemNativeCompiler
<
T
>
compiler
(
cx
kind
monitorStub
obj
holder
key
acctype
needsAtomize
offset
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
return
true
;
}
template
<
class
T
>
static
bool
TryAttachNativeGetAccessorElemStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICGetElem_Fallback
*
stub
HandleNativeObject
obj
HandleValue
keyVal
bool
*
attached
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
!
*
attached
)
;
MOZ_ASSERT
(
keyVal
.
isString
(
)
|
|
keyVal
.
isSymbol
(
)
)
;
RootedId
id
(
cx
)
;
if
(
!
ValueToId
<
CanGC
>
(
cx
keyVal
&
id
)
)
return
false
;
Rooted
<
T
>
key
(
cx
getKey
<
T
>
(
id
)
)
;
if
(
!
key
)
return
true
;
bool
needsAtomize
=
checkAtomize
<
T
>
(
keyVal
)
;
RootedShape
shape
(
cx
)
;
RootedObject
baseHolder
(
cx
)
;
if
(
!
EffectlesslyLookupProperty
(
cx
obj
id
&
baseHolder
&
shape
)
)
return
false
;
if
(
!
baseHolder
|
|
baseHolder
-
>
isNative
(
)
)
return
true
;
HandleNativeObject
holder
=
baseHolder
.
as
<
NativeObject
>
(
)
;
bool
getterIsScripted
=
false
;
if
(
IsCacheableGetPropCall
(
cx
obj
baseHolder
shape
&
getterIsScripted
isTemporarilyUnoptimizable
false
)
)
{
RootedFunction
getter
(
cx
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
if
(
obj
=
=
holder
)
return
true
;
if
(
GetElemNativeStubExists
<
T
>
(
stub
obj
holder
key
needsAtomize
)
)
return
true
;
RemoveExistingGetElemNativeStubs
<
T
>
(
cx
stub
obj
holder
key
needsAtomize
)
;
ICStub
*
monitorStub
=
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
;
ICStub
:
:
Kind
kind
=
getterIsScripted
?
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
:
ICStub
:
:
GetElem_NativePrototypeCallNativeName
;
kind
=
getGetElemStubKind
<
T
>
(
kind
)
;
if
(
getterIsScripted
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
Native
%
s
%
s
call
scripted
%
s
:
%
"
PRIuSIZE
"
)
stub
"
"
(
obj
=
%
p
shape
=
%
p
holder
=
%
p
holderShape
=
%
p
)
"
(
obj
=
=
holder
)
?
"
direct
"
:
"
prototype
"
needsAtomize
?
"
atomizing
"
:
"
"
getter
-
>
nonLazyScript
(
)
-
>
filename
(
)
getter
-
>
nonLazyScript
(
)
-
>
lineno
(
)
obj
.
get
(
)
obj
-
>
lastProperty
(
)
holder
.
get
(
)
holder
-
>
lastProperty
(
)
)
;
}
else
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
Native
%
s
%
s
call
native
)
stub
"
"
(
obj
=
%
p
shape
=
%
p
holder
=
%
p
holderShape
=
%
p
)
"
(
obj
=
=
holder
)
?
"
direct
"
:
"
prototype
"
needsAtomize
?
"
atomizing
"
:
"
"
obj
.
get
(
)
obj
-
>
lastProperty
(
)
holder
.
get
(
)
holder
-
>
lastProperty
(
)
)
;
}
AccType
acctype
=
getterIsScripted
?
ICGetElemNativeStub
:
:
ScriptedGetter
:
ICGetElemNativeStub
:
:
NativeGetter
;
ICGetElemNativeCompiler
<
T
>
compiler
(
cx
kind
monitorStub
obj
holder
key
acctype
needsAtomize
getter
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
return
true
;
}
static
bool
IsPrimitiveArrayTypedObject
(
JSObject
*
obj
)
{
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
return
false
;
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
is
<
ArrayTypeDescr
>
(
)
&
&
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
is
<
ScalarTypeDescr
>
(
)
;
}
static
Scalar
:
:
Type
PrimitiveArrayTypedObjectType
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsPrimitiveArrayTypedObject
(
obj
)
)
;
TypeDescr
&
descr
=
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
;
return
descr
.
as
<
ArrayTypeDescr
>
(
)
.
elementType
(
)
.
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
}
static
Scalar
:
:
Type
TypedThingElementType
(
JSObject
*
obj
)
{
return
obj
-
>
is
<
TypedArrayObject
>
(
)
?
obj
-
>
as
<
TypedArrayObject
>
(
)
.
type
(
)
:
PrimitiveArrayTypedObjectType
(
obj
)
;
}
static
bool
TypedThingRequiresFloatingPoint
(
JSObject
*
obj
)
{
Scalar
:
:
Type
type
=
TypedThingElementType
(
obj
)
;
return
type
=
=
Scalar
:
:
Uint32
|
|
type
=
=
Scalar
:
:
Float32
|
|
type
=
=
Scalar
:
:
Float64
;
}
static
bool
IsNativeDenseElementAccess
(
HandleObject
obj
HandleValue
key
)
{
if
(
obj
-
>
isNative
(
)
&
&
key
.
isInt32
(
)
&
&
key
.
toInt32
(
)
>
=
0
&
&
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
return
true
;
return
false
;
}
static
bool
IsNativeOrUnboxedDenseElementAccess
(
HandleObject
obj
HandleValue
key
)
{
if
(
!
obj
-
>
isNative
(
)
&
&
!
obj
-
>
is
<
UnboxedArrayObject
>
(
)
)
return
false
;
if
(
key
.
isInt32
(
)
&
&
key
.
toInt32
(
)
>
=
0
&
&
!
obj
-
>
is
<
TypedArrayObject
>
(
)
)
return
true
;
return
false
;
}
static
bool
TryAttachGetElemStub
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
ICGetElem_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
HandleValue
res
bool
*
attached
)
{
if
(
lhs
.
isString
(
)
&
&
rhs
.
isInt32
(
)
&
&
res
.
isString
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
GetElem_String
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
String
[
Int32
]
)
stub
"
)
;
ICGetElem_String
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stringStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
stringStub
)
return
false
;
stub
-
>
addNewStub
(
stringStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
lhs
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
rhs
.
isInt32
(
)
&
&
!
ArgumentsGetElemStubExists
(
stub
ICGetElem_Arguments
:
:
Magic
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
MagicArgs
[
Int32
]
)
stub
"
)
;
ICGetElem_Arguments
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
ICGetElem_Arguments
:
:
Magic
)
;
ICStub
*
argsStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
argsStub
)
return
false
;
stub
-
>
addNewStub
(
argsStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
!
lhs
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
lhs
.
toObject
(
)
)
;
if
(
obj
-
>
is
<
ArgumentsObject
>
(
)
&
&
rhs
.
isInt32
(
)
)
{
ICGetElem_Arguments
:
:
Which
which
=
ICGetElem_Arguments
:
:
Mapped
;
if
(
obj
-
>
is
<
UnmappedArgumentsObject
>
(
)
)
which
=
ICGetElem_Arguments
:
:
Unmapped
;
if
(
!
ArgumentsGetElemStubExists
(
stub
which
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
ArgsObj
[
Int32
]
)
stub
"
)
;
ICGetElem_Arguments
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
which
)
;
ICStub
*
argsStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
argsStub
)
return
false
;
stub
-
>
addNewStub
(
argsStub
)
;
*
attached
=
true
;
return
true
;
}
}
if
(
IsNativeDenseElementAccess
(
obj
rhs
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
Native
[
Int32
]
dense
)
stub
"
)
;
ICGetElem_Dense
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
ICStub
*
denseStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
denseStub
)
return
false
;
stub
-
>
addNewStub
(
denseStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
obj
-
>
isNative
(
)
|
|
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
RootedScript
rootedScript
(
cx
script
)
;
if
(
rhs
.
isString
(
)
)
{
if
(
!
TryAttachNativeOrUnboxedGetValueElemStub
<
PropertyName
*
>
(
cx
rootedScript
pc
stub
obj
rhs
attached
)
)
{
return
false
;
}
}
else
if
(
rhs
.
isSymbol
(
)
)
{
if
(
!
TryAttachNativeOrUnboxedGetValueElemStub
<
JS
:
:
Symbol
*
>
(
cx
rootedScript
pc
stub
obj
rhs
attached
)
)
{
return
false
;
}
}
if
(
*
attached
)
return
true
;
script
=
rootedScript
;
}
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
&
&
rhs
.
isInt32
(
)
&
&
rhs
.
toInt32
(
)
>
=
0
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
UnboxedArray
[
Int32
]
)
stub
"
)
;
ICGetElem_UnboxedArray
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
obj
-
>
group
(
)
)
;
ICStub
*
unboxedStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
unboxedStub
)
return
false
;
stub
-
>
addNewStub
(
unboxedStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
(
obj
-
>
is
<
TypedArrayObject
>
(
)
|
|
IsPrimitiveArrayTypedObject
(
obj
)
)
&
&
rhs
.
isNumber
(
)
&
&
res
.
isNumber
(
)
&
&
!
TypedArrayGetElemStubExists
(
stub
obj
)
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
(
TypedThingRequiresFloatingPoint
(
obj
)
|
|
rhs
.
isDouble
(
)
)
)
{
return
true
;
}
if
(
IsPrimitiveArrayTypedObject
(
obj
)
&
&
cx
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetElem
(
TypedArray
[
Int32
]
)
stub
"
)
;
ICGetElem_TypedArray
:
:
Compiler
compiler
(
cx
obj
-
>
maybeShape
(
)
TypedThingElementType
(
obj
)
)
;
ICStub
*
typedArrayStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
typedArrayStub
)
return
false
;
stub
-
>
addNewStub
(
typedArrayStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
!
obj
-
>
isNative
(
)
)
stub
-
>
noteNonNativeAccess
(
)
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
stub
-
>
noteNegativeIndex
(
)
;
return
true
;
}
static
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub_
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICGetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElem
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETELEM
|
|
op
=
=
JSOP_CALLELEM
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
bool
isOptimizedArgs
=
false
;
if
(
lhs
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GetElemOptimizedArguments
(
cx
frame
&
lhsCopy
rhs
res
&
isOptimizedArgs
)
)
return
false
;
if
(
isOptimizedArgs
)
TypeScript
:
:
Monitor
(
cx
frame
-
>
script
(
)
pc
res
)
;
}
bool
attached
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICGetElem_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
stub
-
>
noteUnoptimizableAccess
(
)
;
attached
=
true
;
}
bool
isTemporarilyUnoptimizable
=
false
;
if
(
!
attached
&
&
lhs
.
isObject
(
)
&
&
lhs
.
toObject
(
)
.
isNative
(
)
)
{
if
(
rhs
.
isString
(
)
)
{
RootedScript
rootedScript
(
cx
frame
-
>
script
(
)
)
;
RootedNativeObject
obj
(
cx
&
lhs
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
!
TryAttachNativeGetAccessorElemStub
<
PropertyName
*
>
(
cx
rootedScript
pc
stub
obj
rhs
&
attached
&
isTemporarilyUnoptimizable
)
)
{
return
false
;
}
script
=
rootedScript
;
}
else
if
(
rhs
.
isSymbol
(
)
)
{
RootedScript
rootedScript
(
cx
frame
-
>
script
(
)
)
;
RootedNativeObject
obj
(
cx
&
lhs
.
toObject
(
)
.
as
<
NativeObject
>
(
)
)
;
if
(
!
TryAttachNativeGetAccessorElemStub
<
JS
:
:
Symbol
*
>
(
cx
rootedScript
pc
stub
obj
rhs
&
attached
&
isTemporarilyUnoptimizable
)
)
{
return
false
;
}
script
=
rootedScript
;
}
}
if
(
!
isOptimizedArgs
)
{
if
(
!
GetElementOperation
(
cx
op
&
lhsCopy
rhs
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
frame
-
>
script
(
)
pc
res
)
;
}
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
attached
)
return
true
;
if
(
!
TryAttachGetElemStub
(
cx
frame
-
>
script
(
)
pc
stub
lhs
rhs
res
&
attached
)
)
return
false
;
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoGetElemFallbackInfo
=
FunctionInfo
<
DoGetElemFallbackFn
>
(
DoGetElemFallback
TailCall
PopValues
(
2
)
)
;
bool
ICGetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetElemFallbackInfo
masm
)
;
}
static
bool
DoAtomizeString
(
JSContext
*
cx
HandleString
string
MutableHandleValue
result
)
{
JitSpew
(
JitSpew_BaselineIC
"
AtomizeString
called
"
)
;
RootedValue
key
(
cx
StringValue
(
string
)
)
;
RootedId
id
(
cx
)
;
if
(
!
ValueToId
<
CanGC
>
(
cx
key
&
id
)
)
return
false
;
if
(
!
JSID_IS_ATOM
(
id
)
)
{
result
.
set
(
key
)
;
return
true
;
}
result
.
set
(
StringValue
(
JSID_TO_ATOM
(
id
)
)
)
;
return
true
;
}
typedef
bool
(
*
DoAtomizeStringFn
)
(
JSContext
*
HandleString
MutableHandleValue
)
;
static
const
VMFunction
DoAtomizeStringInfo
=
FunctionInfo
<
DoAtomizeStringFn
>
(
DoAtomizeString
)
;
template
<
class
T
>
bool
ICGetElemNativeCompiler
<
T
>
:
:
emitCallNative
(
MacroAssembler
&
masm
Register
objReg
)
{
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
regs
.
takeUnchecked
(
objReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
masm
.
push
(
objReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElemNativeGetterStub
<
T
>
:
:
offsetOfGetter
(
)
)
objReg
)
;
masm
.
push
(
objReg
)
;
regs
.
add
(
objReg
)
;
if
(
!
callVM
(
DoCallNativeGetterInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
return
true
;
}
template
<
class
T
>
bool
ICGetElemNativeCompiler
<
T
>
:
:
emitCallScripted
(
MacroAssembler
&
masm
Register
objReg
)
{
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
regs
.
takeUnchecked
(
objReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
masm
.
alignJitStackBasedOnNArgs
(
0
)
;
{
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
objReg
val
)
;
masm
.
Push
(
val
)
;
regs
.
add
(
val
)
;
}
regs
.
add
(
objReg
)
;
Register
callee
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElemNativeGetterStub
<
T
>
:
:
offsetOfGetter
(
)
)
callee
)
;
{
Register
callScratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
callScratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
Imm32
(
0
)
)
;
masm
.
Push
(
callee
)
;
masm
.
Push
(
callScratch
)
;
regs
.
add
(
callScratch
)
;
}
Register
code
=
regs
.
takeAnyExcluding
(
ArgumentsRectifierReg
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
code
)
;
masm
.
loadBaselineOrIonRaw
(
code
code
nullptr
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
0
)
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
ImmWord
(
0
)
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
leaveStubFrame
(
masm
true
)
;
return
true
;
}
template
<
class
T
>
bool
ICGetElemNativeCompiler
<
T
>
:
:
emitCheckKey
(
MacroAssembler
&
masm
Label
&
failure
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Key
has
to
be
PropertyName
or
Symbol
"
)
;
return
false
;
}
template
<
>
bool
ICGetElemNativeCompiler
<
JS
:
:
Symbol
*
>
:
:
emitCheckKey
(
MacroAssembler
&
masm
Label
&
failure
)
{
MOZ_ASSERT
(
!
needsAtomize_
)
;
masm
.
branchTestSymbol
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Address
symbolAddr
(
ICStubReg
ICGetElemNativeStubImpl
<
JS
:
:
Symbol
*
>
:
:
offsetOfKey
(
)
)
;
Register
symExtract
=
masm
.
extractObject
(
R1
ExtractTemp1
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
symbolAddr
symExtract
&
failure
)
;
return
true
;
}
template
<
>
bool
ICGetElemNativeCompiler
<
PropertyName
*
>
:
:
emitCheckKey
(
MacroAssembler
&
masm
Label
&
failure
)
{
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Address
nameAddr
(
ICStubReg
ICGetElemNativeStubImpl
<
PropertyName
*
>
:
:
offsetOfKey
(
)
)
;
Register
strExtract
=
masm
.
extractString
(
R1
ExtractTemp1
)
;
if
(
needsAtomize_
)
{
Label
skipAtomize
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
strExtract
JSString
:
:
offsetOfFlags
(
)
)
Imm32
(
JSString
:
:
ATOM_BIT
)
&
skipAtomize
)
;
EmitStowICValues
(
masm
1
)
;
enterStubFrame
(
masm
R0
.
scratchReg
(
)
)
;
masm
.
push
(
strExtract
)
;
if
(
!
callVM
(
DoAtomizeStringInfo
masm
)
)
return
false
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
leaveStubFrame
(
masm
)
;
masm
.
moveValue
(
JSReturnOperand
R1
)
;
EmitUnstowICValues
(
masm
1
)
;
DebugOnly
<
Register
>
strExtract2
=
masm
.
extractString
(
R1
ExtractTemp1
)
;
MOZ_ASSERT
(
Register
(
strExtract2
)
=
=
strExtract
)
;
masm
.
bind
(
&
skipAtomize
)
;
}
masm
.
branchPtr
(
Assembler
:
:
NotEqual
nameAddr
strExtract
&
failure
)
;
return
true
;
}
template
<
class
T
>
bool
ICGetElemNativeCompiler
<
T
>
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Label
failurePopR1
;
bool
popR1
=
false
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
GuardReceiverObject
(
masm
ReceiverGuard
(
obj_
)
objReg
scratchReg
ICGetElemNativeStub
:
:
offsetOfReceiverGuard
(
)
&
failure
)
;
#
ifdef
DEBUG
entersStubFrame_
=
true
;
#
endif
if
(
!
emitCheckKey
(
masm
failure
)
)
return
false
;
Register
holderReg
;
if
(
obj_
=
=
holder_
)
{
holderReg
=
objReg
;
if
(
obj_
-
>
is
<
UnboxedPlainObject
>
(
)
&
&
acctype_
!
=
ICGetElemNativeStub
:
:
UnboxedProperty
)
{
masm
.
push
(
R1
.
scratchReg
(
)
)
;
popR1
=
true
;
holderReg
=
R1
.
scratchReg
(
)
;
masm
.
loadPtr
(
Address
(
objReg
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
holderReg
)
;
}
}
else
{
if
(
regs
.
empty
(
)
)
{
masm
.
push
(
R1
.
scratchReg
(
)
)
;
popR1
=
true
;
holderReg
=
R1
.
scratchReg
(
)
;
}
else
{
holderReg
=
regs
.
takeAny
(
)
;
}
if
(
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElemNativePrototypeCallStub
<
T
>
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElemNativePrototypeCallStub
<
T
>
:
:
offsetOfHolderShape
(
)
)
scratchReg
)
;
}
else
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElem_NativePrototypeSlot
<
T
>
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElem_NativePrototypeSlot
<
T
>
:
:
offsetOfHolderShape
(
)
)
scratchReg
)
;
}
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
holderReg
scratchReg
popR1
?
&
failurePopR1
:
&
failure
)
;
}
if
(
acctype_
=
=
ICGetElemNativeStub
:
:
DynamicSlot
|
|
acctype_
=
=
ICGetElemNativeStub
:
:
FixedSlot
)
{
masm
.
load32
(
Address
(
ICStubReg
ICGetElemNativeSlotStub
<
T
>
:
:
offsetOfOffset
(
)
)
scratchReg
)
;
if
(
acctype_
=
=
ICGetElemNativeStub
:
:
DynamicSlot
)
masm
.
addPtr
(
Address
(
holderReg
NativeObject
:
:
offsetOfSlots
(
)
)
scratchReg
)
;
else
masm
.
addPtr
(
holderReg
scratchReg
)
;
Address
valAddr
(
scratchReg
0
)
;
masm
.
loadValue
(
valAddr
R0
)
;
if
(
popR1
)
masm
.
addToStackPtr
(
ImmWord
(
sizeof
(
size_t
)
)
)
;
}
else
if
(
acctype_
=
=
ICGetElemNativeStub
:
:
UnboxedProperty
)
{
masm
.
load32
(
Address
(
ICStubReg
ICGetElemNativeSlotStub
<
T
>
:
:
offsetOfOffset
(
)
)
scratchReg
)
;
masm
.
loadUnboxedProperty
(
BaseIndex
(
objReg
scratchReg
TimesOne
)
unboxedType_
TypedOrValueRegister
(
R0
)
)
;
if
(
popR1
)
masm
.
addToStackPtr
(
ImmWord
(
sizeof
(
size_t
)
)
)
;
}
else
{
MOZ_ASSERT
(
acctype_
=
=
ICGetElemNativeStub
:
:
NativeGetter
|
|
acctype_
=
=
ICGetElemNativeStub
:
:
ScriptedGetter
)
;
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
)
;
if
(
acctype_
=
=
ICGetElemNativeStub
:
:
NativeGetter
)
{
if
(
popR1
)
masm
.
addToStackPtr
(
ImmWord
(
sizeof
(
size_t
)
)
)
;
emitCallNative
(
masm
objReg
)
;
}
else
{
MOZ_ASSERT
(
acctype_
=
=
ICGetElemNativeStub
:
:
ScriptedGetter
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElemNativeGetterStub
<
T
>
:
:
offsetOfGetter
(
)
)
scratchReg
)
;
masm
.
branchIfFunctionHasNoScript
(
scratchReg
popR1
?
&
failurePopR1
:
&
failure
)
;
masm
.
loadPtr
(
Address
(
scratchReg
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
scratchReg
)
;
masm
.
loadBaselineOrIonRaw
(
scratchReg
scratchReg
popR1
?
&
failurePopR1
:
&
failure
)
;
if
(
popR1
)
masm
.
addToStackPtr
(
Imm32
(
sizeof
(
size_t
)
)
)
;
emitCallScripted
(
masm
objReg
)
;
}
}
EmitEnterTypeMonitorIC
(
masm
)
;
if
(
popR1
)
{
masm
.
bind
(
&
failurePopR1
)
;
masm
.
pop
(
R1
.
scratchReg
(
)
)
;
}
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICGetElem_String
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
str
=
masm
.
extractString
(
R0
ExtractTemp0
)
;
masm
.
branchIfRope
(
str
&
failure
)
;
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
Address
(
str
JSString
:
:
offsetOfLength
(
)
)
key
&
failure
)
;
masm
.
loadStringChar
(
str
key
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
scratchReg
Imm32
(
StaticStrings
:
:
UNIT_STATIC_LIMIT
)
&
failure
)
;
masm
.
movePtr
(
ImmPtr
(
&
cx
-
>
staticStrings
(
)
.
unitStaticTable
)
str
)
;
masm
.
loadPtr
(
BaseIndex
(
str
scratchReg
ScalePointer
)
str
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
str
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICGetElem_Dense
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElem_Dense
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
key
&
failure
)
;
BaseObjectElementIndex
element
(
scratchReg
key
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
element
&
failure
)
;
masm
.
loadValue
(
element
R0
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICGetElem_UnboxedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElem_UnboxedArray
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
masm
.
load32
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
scratchReg
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
size_t
width
=
UnboxedTypeSize
(
elementType_
)
;
BaseIndex
addr
(
scratchReg
key
ScaleFromElemWidth
(
width
)
)
;
masm
.
loadUnboxedProperty
(
addr
elementType_
R0
)
;
if
(
elementType_
=
=
JSVAL_TYPE_OBJECT
)
EmitEnterTypeMonitorIC
(
masm
)
;
else
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
void
LoadTypedThingLength
(
MacroAssembler
&
masm
TypedThingLayout
layout
Register
obj
Register
result
)
{
switch
(
layout
)
{
case
Layout_TypedArray
:
masm
.
unboxInt32
(
Address
(
obj
TypedArrayObject
:
:
lengthOffset
(
)
)
result
)
;
break
;
case
Layout_OutlineTypedObject
:
case
Layout_InlineTypedObject
:
masm
.
loadPtr
(
Address
(
obj
JSObject
:
:
offsetOfGroup
(
)
)
result
)
;
masm
.
loadPtr
(
Address
(
result
ObjectGroup
:
:
offsetOfAddendum
(
)
)
result
)
;
masm
.
unboxInt32
(
Address
(
result
ArrayTypeDescr
:
:
offsetOfLength
(
)
)
result
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
ICGetElem_TypedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
if
(
layout_
!
=
Layout_TypedArray
)
CheckForTypedObjectWithDetachedStorage
(
cx
masm
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetElem_TypedArray
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
Label
isInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R1
&
isInt32
)
;
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
masm
.
unboxDouble
(
R1
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
scratchReg
&
failure
false
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
scratchReg
R1
)
;
}
masm
.
bind
(
&
isInt32
)
;
}
else
{
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
}
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
LoadTypedThingLength
(
masm
layout_
obj
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
&
failure
)
;
LoadTypedThingData
(
masm
layout_
obj
scratchReg
)
;
BaseIndex
source
(
scratchReg
key
ScaleFromElemWidth
(
Scalar
:
:
byteSize
(
type_
)
)
)
;
masm
.
loadFromTypedArray
(
type_
source
R0
false
scratchReg
&
failure
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICGetElem_Arguments
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
if
(
which_
=
=
ICGetElem_Arguments
:
:
Magic
)
{
masm
.
branchTestMagicValue
(
Assembler
:
:
NotEqual
R0
JS_OPTIMIZED_ARGUMENTS
&
failure
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFlags
(
)
)
Imm32
(
BaselineFrame
:
:
HAS_ARGS_OBJ
)
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
idx
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Address
actualArgs
(
BaselineFrameReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
;
masm
.
loadPtr
(
actualArgs
scratch
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
idx
scratch
&
failure
)
;
masm
.
movePtr
(
BaselineFrameReg
scratch
)
;
masm
.
addPtr
(
Imm32
(
BaselineFrame
:
:
offsetOfArg
(
0
)
)
scratch
)
;
BaseValueIndex
element
(
scratch
idx
)
;
masm
.
loadValue
(
element
R0
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
MOZ_ASSERT
(
which_
=
=
ICGetElem_Arguments
:
:
Mapped
|
|
which_
=
=
ICGetElem_Arguments
:
:
Unmapped
)
;
const
Class
*
clasp
=
(
which_
=
=
ICGetElem_Arguments
:
:
Mapped
)
?
&
MappedArgumentsObject
:
:
class_
:
&
UnmappedArgumentsObject
:
:
class_
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
objReg
scratchReg
clasp
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
idxReg
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
masm
.
unboxInt32
(
Address
(
objReg
ArgumentsObject
:
:
getInitialLengthSlotOffset
(
)
)
scratchReg
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
scratchReg
Imm32
(
ArgumentsObject
:
:
LENGTH_OVERRIDDEN_BIT
)
&
failure
)
;
masm
.
rshiftPtr
(
Imm32
(
ArgumentsObject
:
:
PACKED_BITS_COUNT
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
idxReg
scratchReg
&
failure
)
;
Label
failureReconstructInputs
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
takeUnchecked
(
objReg
)
;
regs
.
takeUnchecked
(
idxReg
)
;
regs
.
take
(
scratchReg
)
;
Register
argData
=
regs
.
takeAny
(
)
;
Register
tempReg
=
regs
.
takeAny
(
)
;
masm
.
loadPrivate
(
Address
(
objReg
ArgumentsObject
:
:
getDataSlotOffset
(
)
)
argData
)
;
masm
.
loadPtr
(
Address
(
argData
offsetof
(
ArgumentsData
deletedBits
)
)
scratchReg
)
;
masm
.
movePtr
(
idxReg
tempReg
)
;
const
uint32_t
shift
=
mozilla
:
:
tl
:
:
FloorLog2
<
(
sizeof
(
size_t
)
*
JS_BITS_PER_BYTE
)
>
:
:
value
;
MOZ_ASSERT
(
shift
=
=
5
|
|
shift
=
=
6
)
;
masm
.
rshiftPtr
(
Imm32
(
shift
)
tempReg
)
;
masm
.
loadPtr
(
BaseIndex
(
scratchReg
tempReg
ScaleFromElemWidth
(
sizeof
(
size_t
)
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
scratchReg
ImmPtr
(
nullptr
)
&
failureReconstructInputs
)
;
masm
.
addPtr
(
Imm32
(
ArgumentsData
:
:
offsetOfArgs
(
)
)
argData
)
;
regs
.
add
(
scratchReg
)
;
regs
.
add
(
tempReg
)
;
ValueOperand
tempVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
BaseValueIndex
(
argData
idxReg
)
tempVal
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
tempVal
&
failureReconstructInputs
)
;
masm
.
moveValue
(
tempVal
R0
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureReconstructInputs
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
objReg
R0
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
idxReg
R1
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
SetElemAddHasSameShapes
(
ICSetElem_DenseOrUnboxedArrayAdd
*
stub
JSObject
*
obj
)
{
static
const
size_t
MAX_DEPTH
=
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
;
ICSetElem_DenseOrUnboxedArrayAddImpl
<
MAX_DEPTH
>
*
nstub
=
stub
-
>
toImplUnchecked
<
MAX_DEPTH
>
(
)
;
if
(
obj
-
>
maybeShape
(
)
!
=
nstub
-
>
shape
(
0
)
)
return
false
;
JSObject
*
proto
=
obj
-
>
getProto
(
)
;
for
(
size_t
i
=
0
;
i
<
stub
-
>
protoChainDepth
(
)
;
i
+
+
)
{
if
(
!
proto
-
>
isNative
(
)
)
return
false
;
if
(
proto
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
!
=
nstub
-
>
shape
(
i
+
1
)
)
return
false
;
proto
=
obj
-
>
getProto
(
)
;
if
(
!
proto
)
{
if
(
i
!
=
stub
-
>
protoChainDepth
(
)
-
1
)
return
false
;
break
;
}
}
return
true
;
}
static
bool
DenseOrUnboxedArraySetElemStubExists
(
JSContext
*
cx
ICStub
:
:
Kind
kind
ICSetElem_Fallback
*
stub
HandleObject
obj
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArray
|
|
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
)
;
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArray
&
&
iter
-
>
isSetElem_DenseOrUnboxedArray
(
)
)
{
ICSetElem_DenseOrUnboxedArray
*
nstub
=
iter
-
>
toSetElem_DenseOrUnboxedArray
(
)
;
if
(
obj
-
>
maybeShape
(
)
=
=
nstub
-
>
shape
(
)
&
&
obj
-
>
getGroup
(
cx
)
=
=
nstub
-
>
group
(
)
)
return
true
;
}
if
(
kind
=
=
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
&
&
iter
-
>
isSetElem_DenseOrUnboxedArrayAdd
(
)
)
{
ICSetElem_DenseOrUnboxedArrayAdd
*
nstub
=
iter
-
>
toSetElem_DenseOrUnboxedArrayAdd
(
)
;
if
(
obj
-
>
getGroup
(
cx
)
=
=
nstub
-
>
group
(
)
&
&
SetElemAddHasSameShapes
(
nstub
obj
)
)
return
true
;
}
}
return
false
;
}
static
bool
TypedArraySetElemStubExists
(
ICSetElem_Fallback
*
stub
HandleObject
obj
bool
expectOOB
)
{
for
(
ICStubConstIterator
iter
=
stub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isSetElem_TypedArray
(
)
)
continue
;
ICSetElem_TypedArray
*
taStub
=
iter
-
>
toSetElem_TypedArray
(
)
;
if
(
obj
-
>
maybeShape
(
)
=
=
taStub
-
>
shape
(
)
&
&
taStub
-
>
expectOutOfBounds
(
)
=
=
expectOOB
)
return
true
;
}
return
false
;
}
static
bool
RemoveExistingTypedArraySetElemStub
(
JSContext
*
cx
ICSetElem_Fallback
*
stub
HandleObject
obj
)
{
for
(
ICStubIterator
iter
=
stub
-
>
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isSetElem_TypedArray
(
)
)
continue
;
if
(
obj
-
>
maybeShape
(
)
!
=
iter
-
>
toSetElem_TypedArray
(
)
-
>
shape
(
)
)
continue
;
MOZ_ASSERT
(
!
iter
-
>
toSetElem_TypedArray
(
)
-
>
expectOutOfBounds
(
)
)
;
iter
.
unlink
(
cx
)
;
return
true
;
}
return
false
;
}
static
bool
CanOptimizeDenseOrUnboxedArraySetElem
(
JSObject
*
obj
uint32_t
index
Shape
*
oldShape
uint32_t
oldCapacity
uint32_t
oldInitLength
bool
*
isAddingCaseOut
size_t
*
protoDepthOut
)
{
uint32_t
initLength
=
GetAnyBoxedOrUnboxedInitializedLength
(
obj
)
;
uint32_t
capacity
=
GetAnyBoxedOrUnboxedCapacity
(
obj
)
;
*
isAddingCaseOut
=
false
;
*
protoDepthOut
=
0
;
if
(
initLength
<
oldInitLength
|
|
capacity
<
oldCapacity
)
return
false
;
if
(
obj
-
>
is
<
UnboxedArrayObject
>
(
)
&
&
!
obj
-
>
runtimeFromMainThread
(
)
-
>
jitSupportsFloatingPoint
)
return
false
;
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
if
(
oldShape
!
=
shape
)
return
false
;
if
(
oldCapacity
!
=
capacity
)
return
false
;
if
(
index
>
=
initLength
)
return
false
;
if
(
obj
-
>
isNative
(
)
&
&
!
obj
-
>
as
<
NativeObject
>
(
)
.
containsDenseElement
(
index
)
)
return
false
;
if
(
oldInitLength
=
=
initLength
)
return
true
;
if
(
oldInitLength
+
1
!
=
initLength
)
return
false
;
if
(
index
!
=
oldInitLength
)
return
false
;
if
(
obj
-
>
isIndexed
(
)
)
return
false
;
JSObject
*
curObj
=
obj
-
>
getProto
(
)
;
while
(
curObj
)
{
+
+
*
protoDepthOut
;
if
(
!
curObj
-
>
isNative
(
)
|
|
curObj
-
>
isIndexed
(
)
)
return
false
;
curObj
=
curObj
-
>
getProto
(
)
;
}
if
(
*
protoDepthOut
>
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
)
return
false
;
*
isAddingCaseOut
=
true
;
return
true
;
}
static
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetElem_Fallback
*
stub_
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
{
DebugModeOSRVolatileStub
<
ICSetElem_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedScript
outerScript
(
cx
script
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetElem
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETELEM
|
|
op
=
=
JSOP_STRICTSETELEM
|
|
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
|
|
op
=
=
JSOP_INITELEM_ARRAY
|
|
op
=
=
JSOP_INITELEM_INC
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
objv
)
)
;
if
(
!
obj
)
return
false
;
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
uint32_t
oldCapacity
=
0
;
uint32_t
oldInitLength
=
0
;
if
(
index
.
isInt32
(
)
&
&
index
.
toInt32
(
)
>
=
0
)
{
oldCapacity
=
GetAnyBoxedOrUnboxedCapacity
(
obj
)
;
oldInitLength
=
GetAnyBoxedOrUnboxedInitializedLength
(
obj
)
;
}
if
(
op
=
=
JSOP_INITELEM
|
|
op
=
=
JSOP_INITHIDDENELEM
)
{
if
(
!
InitElemOperation
(
cx
pc
obj
index
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_ARRAY
)
{
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
<
=
INT32_MAX
"
the
bytecode
emitter
must
fail
to
compile
code
that
would
"
"
produce
JSOP_INITELEM_ARRAY
with
an
index
exceeding
"
"
int32_t
range
"
)
;
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
=
=
GET_UINT32
(
pc
)
)
;
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_INITELEM_INC
)
{
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
return
false
;
}
else
{
if
(
!
SetObjectElement
(
cx
obj
index
rhs
objv
JSOp
(
*
pc
)
=
=
JSOP_STRICTSETELEM
script
pc
)
)
return
false
;
}
if
(
op
=
=
JSOP_INITHIDDENELEM
)
return
true
;
MOZ_ASSERT
(
stack
[
2
]
=
=
objv
)
;
stack
[
2
]
=
rhs
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICSetElem_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
if
(
IsNativeOrUnboxedDenseElementAccess
(
obj
index
)
&
&
!
rhs
.
isMagic
(
JS_ELEMENTS_HOLE
)
)
{
bool
addingCase
;
size_t
protoDepth
;
if
(
CanOptimizeDenseOrUnboxedArraySetElem
(
obj
index
.
toInt32
(
)
oldShape
oldCapacity
oldInitLength
&
addingCase
&
protoDepth
)
)
{
RootedShape
shape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
group
(
cx
obj
-
>
getGroup
(
cx
)
)
;
if
(
!
group
)
return
false
;
if
(
addingCase
&
&
!
DenseOrUnboxedArraySetElemStubExists
(
cx
ICStub
:
:
SetElem_DenseOrUnboxedArrayAdd
stub
obj
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_DenseOrUnboxedArrayAdd
stub
"
"
(
shape
=
%
p
group
=
%
p
protoDepth
=
%
u
)
"
shape
.
get
(
)
group
.
get
(
)
protoDepth
)
;
ICSetElemDenseOrUnboxedArrayAddCompiler
compiler
(
cx
obj
protoDepth
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
outerScript
obj
JSID_VOIDHANDLE
rhs
)
)
{
return
false
;
}
stub
-
>
addNewStub
(
newStub
)
;
}
else
if
(
!
addingCase
&
&
!
DenseOrUnboxedArraySetElemStubExists
(
cx
ICStub
:
:
SetElem_DenseOrUnboxedArray
stub
obj
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_DenseOrUnboxedArray
stub
(
shape
=
%
p
group
=
%
p
)
"
shape
.
get
(
)
group
.
get
(
)
)
;
ICSetElem_DenseOrUnboxedArray
:
:
Compiler
compiler
(
cx
shape
group
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
outerScript
obj
JSID_VOIDHANDLE
rhs
)
)
{
return
false
;
}
stub
-
>
addNewStub
(
newStub
)
;
}
}
return
true
;
}
if
(
(
obj
-
>
is
<
TypedArrayObject
>
(
)
|
|
IsPrimitiveArrayTypedObject
(
obj
)
)
&
&
index
.
isNumber
(
)
&
&
rhs
.
isNumber
(
)
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
&
&
(
TypedThingRequiresFloatingPoint
(
obj
)
|
|
index
.
isDouble
(
)
)
)
{
return
true
;
}
bool
expectOutOfBounds
;
double
idx
=
index
.
toNumber
(
)
;
if
(
obj
-
>
is
<
TypedArrayObject
>
(
)
)
{
expectOutOfBounds
=
(
idx
<
0
|
|
idx
>
=
double
(
obj
-
>
as
<
TypedArrayObject
>
(
)
.
length
(
)
)
)
;
}
else
{
if
(
idx
<
0
|
|
idx
>
=
double
(
obj
-
>
as
<
TypedObject
>
(
)
.
length
(
)
)
)
return
true
;
expectOutOfBounds
=
false
;
if
(
cx
-
>
compartment
(
)
-
>
detachedTypedObjects
)
return
true
;
}
if
(
!
TypedArraySetElemStubExists
(
stub
obj
expectOutOfBounds
)
)
{
if
(
expectOutOfBounds
)
RemoveExistingTypedArraySetElemStub
(
cx
stub
obj
)
;
Shape
*
shape
=
obj
-
>
maybeShape
(
)
;
Scalar
:
:
Type
type
=
TypedThingElementType
(
obj
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetElem_TypedArray
stub
(
shape
=
%
p
type
=
%
u
oob
=
%
s
)
"
shape
type
expectOutOfBounds
?
"
yes
"
:
"
no
"
)
;
ICSetElem_TypedArray
:
:
Compiler
compiler
(
cx
shape
type
expectOutOfBounds
)
;
ICStub
*
typedArrayStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
typedArrayStub
)
return
false
;
stub
-
>
addNewStub
(
typedArrayStub
)
;
return
true
;
}
}
return
true
;
}
typedef
bool
(
*
DoSetElemFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetElem_Fallback
*
Value
*
HandleValue
HandleValue
HandleValue
)
;
static
const
VMFunction
DoSetElemFallbackInfo
=
FunctionInfo
<
DoSetElemFallbackFn
>
(
DoSetElemFallback
TailCall
PopValues
(
2
)
)
;
bool
ICSetElem_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
R1
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
moveStackPtrTo
(
R1
.
scratchReg
(
)
)
;
masm
.
pushValue
(
Address
(
R1
.
scratchReg
(
)
2
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoSetElemFallbackInfo
masm
)
;
}
void
BaselineScript
:
:
noteArrayWriteHole
(
uint32_t
pcOffset
)
{
ICEntry
&
entry
=
icEntryFromPCOffset
(
pcOffset
)
;
ICFallbackStub
*
stub
=
entry
.
fallbackStub
(
)
;
if
(
stub
-
>
isSetElem_Fallback
(
)
)
stub
-
>
toSetElem_Fallback
(
)
-
>
noteArrayWriteHole
(
)
;
}
template
<
typename
T
>
void
EmitUnboxedPreBarrierForBaseline
(
MacroAssembler
&
masm
T
address
JSValueType
type
)
{
if
(
type
=
=
JSVAL_TYPE_OBJECT
)
EmitPreBarrier
(
masm
address
MIRType_Object
)
;
else
if
(
type
=
=
JSVAL_TYPE_STRING
)
EmitPreBarrier
(
masm
address
MIRType_String
)
;
else
MOZ_ASSERT
(
!
UnboxedTypeNeedsPreBarrier
(
type
)
)
;
}
bool
ICSetElem_DenseOrUnboxedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArray
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArray
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
}
if
(
needsUpdateStubs
(
)
)
{
EmitStowICValues
(
masm
2
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
+
ICStackValueOffset
)
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
Push
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
+
ICStackValueOffset
)
R1
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
addUnchecked
(
obj
)
;
saveRegs
.
add
(
ICStubReg
)
;
emitPostWriteBarrierSlot
(
masm
obj
R1
scratchReg
saveRegs
)
;
masm
.
Pop
(
R1
)
;
}
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
key
&
failure
)
;
BaseIndex
element
(
scratchReg
key
TimesEight
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
element
&
failure
)
;
Label
noSpecialHandling
;
Address
elementsFlags
(
scratchReg
ObjectElements
:
:
offsetOfFlags
(
)
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
|
ObjectElements
:
:
COPY_ON_WRITE
)
&
noSpecialHandling
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
elementsFlags
Imm32
(
ObjectElements
:
:
COPY_ON_WRITE
)
&
failure
)
;
regs
.
add
(
R0
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
masm
.
convertInt32ValueToDouble
(
valueAddr
regs
.
getAny
(
)
&
noSpecialHandling
)
;
else
masm
.
assumeUnreachable
(
"
There
shouldn
'
t
be
double
arrays
when
there
is
no
FP
support
.
"
)
;
masm
.
bind
(
&
noSpecialHandling
)
;
ValueOperand
tmpVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
valueAddr
tmpVal
)
;
EmitPreBarrier
(
masm
element
MIRType_Value
)
;
masm
.
storeValue
(
tmpVal
element
)
;
}
else
{
Address
initLength
(
obj
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
;
masm
.
load32
(
initLength
scratchReg
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
BaseIndex
address
(
scratchReg
key
ScaleFromElemWidth
(
UnboxedTypeSize
(
unboxedType_
)
)
)
;
EmitUnboxedPreBarrierForBaseline
(
masm
address
unboxedType_
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
Push
(
R0
)
;
masm
.
loadValue
(
valueAddr
R0
)
;
masm
.
storeUnboxedProperty
(
address
unboxedType_
ConstantOrRegister
(
TypedOrValueRegister
(
R0
)
)
&
failurePopR0
)
;
masm
.
Pop
(
R0
)
;
}
EmitReturnFromIC
(
masm
)
;
if
(
failurePopR0
.
used
(
)
)
{
masm
.
bind
(
&
failurePopR0
)
;
masm
.
popValue
(
R0
)
;
}
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICUpdatedStub
*
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
getStub
(
ICStubSpace
*
space
)
{
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
if
(
!
shapes
.
append
(
obj_
-
>
maybeShape
(
)
)
)
return
nullptr
;
if
(
!
GetProtoShapes
(
obj_
protoChainDepth_
&
shapes
)
)
return
nullptr
;
JS_STATIC_ASSERT
(
ICSetElem_DenseOrUnboxedArrayAdd
:
:
MAX_PROTO_CHAIN_DEPTH
=
=
4
)
;
ICUpdatedStub
*
stub
=
nullptr
;
switch
(
protoChainDepth_
)
{
case
0
:
stub
=
getStubSpecific
<
0
>
(
space
shapes
)
;
break
;
case
1
:
stub
=
getStubSpecific
<
1
>
(
space
shapes
)
;
break
;
case
2
:
stub
=
getStubSpecific
<
2
>
(
space
shapes
)
;
break
;
case
3
:
stub
=
getStubSpecific
<
3
>
(
space
shapes
)
;
break
;
case
4
:
stub
=
getStubSpecific
<
4
>
(
space
shapes
)
;
break
;
default
:
MOZ_CRASH
(
"
ProtoChainDepth
too
high
.
"
)
;
}
if
(
!
stub
|
|
!
stub
-
>
initUpdatingChain
(
cx
space
)
)
return
nullptr
;
return
stub
;
}
bool
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0
failureUnstow
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAdd
:
:
offsetOfGroup
(
)
)
scratchReg
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAddImpl
<
0
>
:
:
offsetOfShape
(
0
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
}
EmitStowICValues
(
masm
2
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
take
(
R0
)
;
regs
.
take
(
scratchReg
)
;
Register
protoReg
=
regs
.
takeAny
(
)
;
for
(
size_t
i
=
0
;
i
<
protoChainDepth_
;
i
+
+
)
{
masm
.
loadObjProto
(
i
=
=
0
?
obj
:
protoReg
protoReg
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
protoReg
protoReg
&
failureUnstow
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_DenseOrUnboxedArrayAddImpl
<
0
>
:
:
offsetOfShape
(
i
+
1
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
scratchReg
&
failureUnstow
)
;
}
regs
.
add
(
protoReg
)
;
regs
.
add
(
scratchReg
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
+
ICStackValueOffset
)
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
}
EmitUnstowICValues
(
masm
2
)
;
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
Push
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
+
ICStackValueOffset
)
R1
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
addUnchecked
(
obj
)
;
saveRegs
.
add
(
ICStubReg
)
;
emitPostWriteBarrierSlot
(
masm
obj
R1
scratchReg
saveRegs
)
;
masm
.
Pop
(
R1
)
;
}
regs
=
availableGeneralRegs
(
2
)
;
scratchReg
=
regs
.
takeAny
(
)
;
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
if
(
unboxedType_
=
=
JSVAL_TYPE_MAGIC
)
{
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
Address
initLength
(
scratchReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
initLength
key
&
failure
)
;
Address
capacity
(
scratchReg
ObjectElements
:
:
offsetOfCapacity
(
)
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
capacity
key
&
failure
)
;
Address
elementsFlags
(
scratchReg
ObjectElements
:
:
offsetOfFlags
(
)
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
elementsFlags
Imm32
(
ObjectElements
:
:
COPY_ON_WRITE
)
&
failure
)
;
regs
.
add
(
R0
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
masm
.
add32
(
Imm32
(
1
)
initLength
)
;
Label
skipIncrementLength
;
Address
length
(
scratchReg
ObjectElements
:
:
offsetOfLength
(
)
)
;
masm
.
branch32
(
Assembler
:
:
Above
length
key
&
skipIncrementLength
)
;
masm
.
add32
(
Imm32
(
1
)
length
)
;
masm
.
bind
(
&
skipIncrementLength
)
;
Label
dontConvertDoubles
;
masm
.
branchTest32
(
Assembler
:
:
Zero
elementsFlags
Imm32
(
ObjectElements
:
:
CONVERT_DOUBLE_ELEMENTS
)
&
dontConvertDoubles
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
masm
.
convertInt32ValueToDouble
(
valueAddr
regs
.
getAny
(
)
&
dontConvertDoubles
)
;
else
masm
.
assumeUnreachable
(
"
There
shouldn
'
t
be
double
arrays
when
there
is
no
FP
support
.
"
)
;
masm
.
bind
(
&
dontConvertDoubles
)
;
ValueOperand
tmpVal
=
regs
.
takeAnyValue
(
)
;
BaseIndex
element
(
scratchReg
key
TimesEight
)
;
masm
.
loadValue
(
valueAddr
tmpVal
)
;
masm
.
storeValue
(
tmpVal
element
)
;
}
else
{
Address
initLengthAddr
(
obj
UnboxedArrayObject
:
:
offsetOfCapacityIndexAndInitializedLength
(
)
)
;
masm
.
load32
(
initLengthAddr
scratchReg
)
;
masm
.
and32
(
Imm32
(
UnboxedArrayObject
:
:
InitializedLengthMask
)
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
scratchReg
key
&
failure
)
;
masm
.
checkUnboxedArrayCapacity
(
obj
Int32Key
(
key
)
scratchReg
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
UnboxedArrayObject
:
:
offsetOfElements
(
)
)
scratchReg
)
;
masm
.
Push
(
R0
)
;
Address
valueAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
valueAddr
R0
)
;
BaseIndex
address
(
scratchReg
key
ScaleFromElemWidth
(
UnboxedTypeSize
(
unboxedType_
)
)
)
;
masm
.
storeUnboxedProperty
(
address
unboxedType_
ConstantOrRegister
(
TypedOrValueRegister
(
R0
)
)
&
failurePopR0
)
;
masm
.
Pop
(
R0
)
;
masm
.
add32
(
Imm32
(
1
)
initLengthAddr
)
;
Address
lengthAddr
(
obj
UnboxedArrayObject
:
:
offsetOfLength
(
)
)
;
Label
skipIncrementLength
;
masm
.
branch32
(
Assembler
:
:
Above
lengthAddr
key
&
skipIncrementLength
)
;
masm
.
add32
(
Imm32
(
1
)
lengthAddr
)
;
masm
.
bind
(
&
skipIncrementLength
)
;
}
EmitReturnFromIC
(
masm
)
;
if
(
failurePopR0
.
used
(
)
)
{
masm
.
bind
(
&
failurePopR0
)
;
masm
.
popValue
(
R0
)
;
masm
.
jump
(
&
failure
)
;
}
masm
.
bind
(
&
failureUnstow
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
template
<
typename
T
>
static
void
StoreToTypedArray
(
JSContext
*
cx
MacroAssembler
&
masm
Scalar
:
:
Type
type
Address
value
T
dest
Register
scratch
Label
*
failure
Label
*
failureModifiedScratch
)
{
Label
done
;
if
(
type
=
=
Scalar
:
:
Float32
|
|
type
=
=
Scalar
:
:
Float64
)
{
masm
.
ensureDouble
(
value
FloatReg0
failure
)
;
if
(
type
=
=
Scalar
:
:
Float32
)
{
masm
.
convertDoubleToFloat32
(
FloatReg0
ScratchFloat32Reg
)
;
masm
.
storeToTypedFloatArray
(
type
ScratchFloat32Reg
dest
)
;
}
else
{
masm
.
storeToTypedFloatArray
(
type
FloatReg0
dest
)
;
}
}
else
if
(
type
=
=
Scalar
:
:
Uint8Clamped
)
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
masm
.
clampIntToUint8
(
scratch
)
;
Label
clamped
;
masm
.
bind
(
&
clamped
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
clampDoubleToUint8
(
FloatReg0
scratch
)
;
masm
.
jump
(
&
clamped
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
else
{
Label
notInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
value
&
notInt32
)
;
masm
.
unboxInt32
(
value
scratch
)
;
Label
isInt32
;
masm
.
bind
(
&
isInt32
)
;
masm
.
storeToTypedIntArray
(
type
scratch
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notInt32
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
value
failure
)
;
masm
.
unboxDouble
(
value
FloatReg0
)
;
masm
.
branchTruncateDouble
(
FloatReg0
scratch
failureModifiedScratch
)
;
masm
.
jump
(
&
isInt32
)
;
}
else
{
masm
.
jump
(
failure
)
;
}
}
masm
.
bind
(
&
done
)
;
}
bool
ICSetElem_TypedArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
if
(
layout_
!
=
Layout_TypedArray
)
CheckForTypedObjectWithDetachedStorage
(
cx
masm
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratchReg
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetElem_TypedArray
:
:
offsetOfShape
(
)
)
scratchReg
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratchReg
&
failure
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
Label
isInt32
;
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R1
&
isInt32
)
;
{
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
masm
.
unboxDouble
(
R1
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
scratchReg
&
failure
false
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
scratchReg
R1
)
;
}
masm
.
bind
(
&
isInt32
)
;
}
else
{
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
}
Register
key
=
masm
.
extractInt32
(
R1
ExtractTemp1
)
;
Label
oobWrite
;
LoadTypedThingLength
(
masm
layout_
obj
scratchReg
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratchReg
key
expectOutOfBounds_
?
&
oobWrite
:
&
failure
)
;
LoadTypedThingData
(
masm
layout_
obj
scratchReg
)
;
BaseIndex
dest
(
scratchReg
key
ScaleFromElemWidth
(
Scalar
:
:
byteSize
(
type_
)
)
)
;
Address
value
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
takeUnchecked
(
obj
)
;
regs
.
takeUnchecked
(
key
)
;
regs
.
take
(
scratchReg
)
;
Register
secondScratch
=
regs
.
takeAny
(
)
;
Label
failureModifiedSecondScratch
;
StoreToTypedArray
(
cx
masm
type_
value
dest
secondScratch
&
failure
&
failureModifiedSecondScratch
)
;
EmitReturnFromIC
(
masm
)
;
if
(
failureModifiedSecondScratch
.
used
(
)
)
{
masm
.
bind
(
&
failureModifiedSecondScratch
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
obj
R0
)
;
masm
.
tagValue
(
JSVAL_TYPE_INT32
key
R1
)
;
}
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
if
(
expectOutOfBounds_
)
{
MOZ_ASSERT
(
layout_
=
=
Layout_TypedArray
)
;
masm
.
bind
(
&
oobWrite
)
;
EmitReturnFromIC
(
masm
)
;
}
return
true
;
}
static
bool
TryAttachDenseInStub
(
JSContext
*
cx
HandleScript
outerScript
ICIn_Fallback
*
stub
HandleValue
key
HandleObject
obj
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
!
IsNativeDenseElementAccess
(
obj
key
)
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
In
(
Native
[
Int32
]
dense
)
stub
"
)
;
ICIn_Dense
:
:
Compiler
compiler
(
cx
obj
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
;
ICStub
*
denseStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
denseStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
denseStub
)
;
return
true
;
}
static
bool
TryAttachNativeInStub
(
JSContext
*
cx
HandleScript
outerScript
ICIn_Fallback
*
stub
HandleValue
key
HandleObject
obj
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
RootedId
id
(
cx
)
;
if
(
!
IsOptimizableElementPropertyName
(
cx
key
&
id
)
)
return
true
;
RootedPropertyName
name
(
cx
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
RootedShape
shape
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
EffectlesslyLookupProperty
(
cx
obj
id
&
holder
&
shape
)
)
return
false
;
if
(
IsCacheableGetPropReadSlot
(
obj
holder
shape
)
)
{
ICStub
:
:
Kind
kind
=
(
obj
=
=
holder
)
?
ICStub
:
:
In_Native
:
ICStub
:
:
In_NativePrototype
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
In
(
Native
%
s
)
stub
"
(
obj
=
=
holder
)
?
"
direct
"
:
"
prototype
"
)
;
ICInNativeCompiler
compiler
(
cx
kind
obj
holder
name
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
return
true
;
}
static
bool
TryAttachNativeInDoesNotExistStub
(
JSContext
*
cx
HandleScript
outerScript
ICIn_Fallback
*
stub
HandleValue
key
HandleObject
obj
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
RootedId
id
(
cx
)
;
if
(
!
IsOptimizableElementPropertyName
(
cx
key
&
id
)
)
return
true
;
RootedPropertyName
name
(
cx
JSID_TO_ATOM
(
id
)
-
>
asPropertyName
(
)
)
;
RootedObject
lastProto
(
cx
)
;
size_t
protoChainDepth
=
SIZE_MAX
;
if
(
!
CheckHasNoSuchProperty
(
cx
obj
name
&
lastProto
&
protoChainDepth
)
)
return
true
;
MOZ_ASSERT
(
protoChainDepth
<
SIZE_MAX
)
;
if
(
protoChainDepth
>
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
In_NativeDoesNotExist
stub
"
)
;
ICInNativeDoesNotExistCompiler
compiler
(
cx
obj
name
protoChainDepth
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
static
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIn_Fallback
*
stub_
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIn_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
In
"
)
;
if
(
!
objValue
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_IN_NOT_OBJECT
-
1
objValue
nullptr
)
;
return
false
;
}
RootedObject
obj
(
cx
&
objValue
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
OperatorIn
(
cx
key
obj
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICIn_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
if
(
obj
-
>
isNative
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
bool
attached
=
false
;
if
(
cond
)
{
if
(
!
TryAttachDenseInStub
(
cx
script
stub
key
obj
&
attached
)
)
return
false
;
if
(
attached
)
return
true
;
if
(
!
TryAttachNativeInStub
(
cx
script
stub
key
obj
&
attached
)
)
return
false
;
if
(
attached
)
return
true
;
}
else
{
if
(
!
TryAttachNativeInDoesNotExistStub
(
cx
script
stub
key
obj
&
attached
)
)
return
false
;
if
(
attached
)
return
true
;
}
}
return
true
;
}
typedef
bool
(
*
DoInFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInFallbackInfo
=
FunctionInfo
<
DoInFallbackFn
>
(
DoInFallback
TailCall
PopValues
(
2
)
)
;
bool
ICIn_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInFallbackInfo
masm
)
;
}
bool
ICInNativeCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0Scratch
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
strExtract
=
masm
.
extractString
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInNativeStub
:
:
offsetOfName
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
strExtract
scratch
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInNativeStub
:
:
offsetOfShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
objReg
scratch
&
failure
)
;
if
(
kind
=
=
ICStub
:
:
In_NativePrototype
)
{
Register
holderReg
=
R0
.
scratchReg
(
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativePrototype
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativePrototype
:
:
offsetOfHolderShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
holderReg
scratch
&
failurePopR0Scratch
)
;
masm
.
addToStackPtr
(
Imm32
(
sizeof
(
size_t
)
)
)
;
}
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failurePopR0Scratch
)
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICStub
*
ICInNativeDoesNotExistCompiler
:
:
getStub
(
ICStubSpace
*
space
)
{
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
if
(
!
shapes
.
append
(
obj_
-
>
as
<
NativeObject
>
(
)
.
lastProperty
(
)
)
)
return
nullptr
;
if
(
!
GetProtoShapes
(
obj_
protoChainDepth_
&
shapes
)
)
return
nullptr
;
JS_STATIC_ASSERT
(
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
=
=
8
)
;
ICStub
*
stub
=
nullptr
;
switch
(
protoChainDepth_
)
{
case
0
:
stub
=
getStubSpecific
<
0
>
(
space
shapes
)
;
break
;
case
1
:
stub
=
getStubSpecific
<
1
>
(
space
shapes
)
;
break
;
case
2
:
stub
=
getStubSpecific
<
2
>
(
space
shapes
)
;
break
;
case
3
:
stub
=
getStubSpecific
<
3
>
(
space
shapes
)
;
break
;
case
4
:
stub
=
getStubSpecific
<
4
>
(
space
shapes
)
;
break
;
case
5
:
stub
=
getStubSpecific
<
5
>
(
space
shapes
)
;
break
;
case
6
:
stub
=
getStubSpecific
<
6
>
(
space
shapes
)
;
break
;
case
7
:
stub
=
getStubSpecific
<
7
>
(
space
shapes
)
;
break
;
case
8
:
stub
=
getStubSpecific
<
8
>
(
space
shapes
)
;
break
;
default
:
MOZ_CRASH
(
"
ProtoChainDepth
too
high
.
"
)
;
}
if
(
!
stub
)
return
nullptr
;
return
stub
;
}
bool
ICInNativeDoesNotExistCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
failurePopR0Scratch
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
#
ifdef
DEBUG
{
Label
ok
;
masm
.
load16ZeroExtend
(
Address
(
ICStubReg
ICStub
:
:
offsetOfExtra
(
)
)
scratch
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch
Imm32
(
protoChainDepth_
)
&
ok
)
;
masm
.
assumeUnreachable
(
"
Non
-
matching
proto
chain
depth
on
stub
.
"
)
;
masm
.
bind
(
&
ok
)
;
}
#
endif
Register
strExtract
=
masm
.
extractString
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativeDoesNotExist
:
:
offsetOfName
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
strExtract
scratch
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_NativeDoesNotExist
:
:
offsetOfShape
(
0
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
objReg
scratch
&
failure
)
;
Register
protoReg
=
R0
.
scratchReg
(
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
for
(
size_t
i
=
0
;
i
<
protoChainDepth_
;
+
+
i
)
{
masm
.
loadObjProto
(
i
=
=
0
?
objReg
:
protoReg
protoReg
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
protoReg
protoReg
&
failurePopR0Scratch
)
;
size_t
shapeOffset
=
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
i
+
1
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
shapeOffset
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
scratch
&
failurePopR0Scratch
)
;
}
masm
.
addToStackPtr
(
Imm32
(
sizeof
(
size_t
)
)
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failurePopR0Scratch
)
;
masm
.
pop
(
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICIn_Dense
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
obj
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICIn_Dense
:
:
offsetOfShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
obj
scratch
&
failure
)
;
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfElements
(
)
)
scratch
)
;
Address
initLength
(
scratch
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
;
Register
key
=
masm
.
extractInt32
(
R0
ExtractTemp0
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
initLength
key
&
failure
)
;
JS_STATIC_ASSERT
(
sizeof
(
Value
)
=
=
8
)
;
BaseIndex
element
(
scratch
key
TimesEight
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
element
&
failure
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
UpdateExistingSetPropCallStubs
(
ICSetProp_Fallback
*
fallbackStub
ICStub
:
:
Kind
kind
NativeObject
*
holder
JSObject
*
receiver
JSFunction
*
setter
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
SetProp_CallScripted
|
|
kind
=
=
ICStub
:
:
SetProp_CallNative
)
;
MOZ_ASSERT
(
holder
)
;
MOZ_ASSERT
(
receiver
)
;
bool
isOwnSetter
=
(
holder
=
=
receiver
)
;
bool
foundMatchingStub
=
false
;
ReceiverGuard
receiverGuard
(
receiver
)
;
for
(
ICStubConstIterator
iter
=
fallbackStub
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
kind
(
)
=
=
kind
)
{
ICSetPropCallSetter
*
setPropStub
=
static_cast
<
ICSetPropCallSetter
*
>
(
*
iter
)
;
if
(
setPropStub
-
>
holder
(
)
=
=
holder
&
&
setPropStub
-
>
isOwnSetter
(
)
=
=
isOwnSetter
)
{
if
(
isOwnSetter
)
setPropStub
-
>
receiverGuard
(
)
.
update
(
receiverGuard
)
;
MOZ_ASSERT
(
setPropStub
-
>
holderShape
(
)
!
=
holder
-
>
lastProperty
(
)
|
|
!
setPropStub
-
>
receiverGuard
(
)
.
matches
(
receiverGuard
)
"
Why
didn
'
t
we
end
up
using
this
stub
?
"
)
;
setPropStub
-
>
holderShape
(
)
=
holder
-
>
lastProperty
(
)
;
setPropStub
-
>
setter
(
)
=
setter
;
if
(
setPropStub
-
>
receiverGuard
(
)
.
matches
(
receiverGuard
)
)
foundMatchingStub
=
true
;
}
}
}
return
foundMatchingStub
;
}
static
bool
TryAttachGlobalNameValueStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICGetName_Fallback
*
stub
Handle
<
ClonedBlockObject
*
>
globalLexical
HandlePropertyName
name
bool
*
attached
)
{
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
MOZ_ASSERT
(
!
*
attached
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedShape
shape
(
cx
globalLexical
-
>
lookup
(
cx
id
)
)
;
RootedNativeObject
current
(
cx
globalLexical
)
;
while
(
true
)
{
shape
=
current
-
>
lookup
(
cx
id
)
;
if
(
shape
)
break
;
if
(
current
=
=
globalLexical
)
{
current
=
&
globalLexical
-
>
global
(
)
;
}
else
{
JSObject
*
proto
=
current
-
>
getProto
(
)
;
if
(
!
proto
|
|
!
proto
-
>
is
<
NativeObject
>
(
)
)
return
true
;
current
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
}
if
(
IsIonEnabled
(
cx
)
)
EnsureTrackPropertyTypes
(
cx
current
id
)
;
if
(
shape
-
>
hasDefaultGetter
(
)
&
&
shape
-
>
hasSlot
(
)
)
{
ICStub
*
monitorStub
=
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
;
ICStub
*
newStub
;
if
(
current
=
=
globalLexical
)
{
MOZ_ASSERT
(
shape
-
>
slot
(
)
>
=
current
-
>
numFixedSlots
(
)
)
;
uint32_t
slot
=
shape
-
>
slot
(
)
-
current
-
>
numFixedSlots
(
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetName
(
GlobalName
lexical
)
stub
"
)
;
ICGetName_GlobalLexical
:
:
Compiler
compiler
(
cx
monitorStub
slot
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
}
else
{
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
if
(
!
IsCacheableGetPropReadSlot
(
&
globalLexical
-
>
global
(
)
current
shape
)
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetName
(
GlobalName
non
-
lexical
)
stub
"
)
;
ICGetPropNativeCompiler
compiler
(
cx
ICStub
:
:
GetName_Global
ICStubCompiler
:
:
Engine
:
:
Baseline
monitorStub
globalLexical
current
name
isFixedSlot
offset
true
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
}
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
}
return
true
;
}
static
bool
TryAttachGlobalNameAccessorStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICGetName_Fallback
*
stub
Handle
<
ClonedBlockObject
*
>
globalLexical
HandlePropertyName
name
bool
*
attached
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
globalLexical
-
>
isGlobal
(
)
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
if
(
globalLexical
-
>
lookup
(
cx
id
)
)
return
true
;
RootedGlobalObject
global
(
cx
&
globalLexical
-
>
global
(
)
)
;
RootedShape
shape
(
cx
)
;
RootedNativeObject
current
(
cx
global
)
;
while
(
true
)
{
shape
=
current
-
>
lookup
(
cx
id
)
;
if
(
shape
)
break
;
JSObject
*
proto
=
current
-
>
getProto
(
)
;
if
(
!
proto
|
|
!
proto
-
>
is
<
NativeObject
>
(
)
)
return
true
;
current
=
&
proto
-
>
as
<
NativeObject
>
(
)
;
}
if
(
IsIonEnabled
(
cx
)
)
EnsureTrackPropertyTypes
(
cx
current
id
)
;
bool
isScripted
;
if
(
IsCacheableGetPropCall
(
cx
global
current
shape
&
isScripted
isTemporarilyUnoptimizable
)
&
&
!
isScripted
)
{
ICStub
*
monitorStub
=
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
;
RootedFunction
getter
(
cx
&
shape
-
>
getterObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetName
(
GlobalName
/
NativeGetter
)
stub
"
)
;
if
(
UpdateExistingGetPropCallStubs
(
stub
ICStub
:
:
GetProp_CallNativeGlobal
current
globalLexical
getter
)
)
{
*
attached
=
true
;
return
true
;
}
ICGetPropCallNativeCompiler
compiler
(
cx
ICStub
:
:
GetProp_CallNativeGlobal
ICStubCompiler
:
:
Engine
:
:
Baseline
monitorStub
globalLexical
current
getter
script
-
>
pcToOffset
(
pc
)
nullptr
true
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
}
return
true
;
}
static
bool
TryAttachScopeNameStub
(
JSContext
*
cx
HandleScript
script
ICGetName_Fallback
*
stub
HandleObject
initialScopeChain
HandlePropertyName
name
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
scopeChain
(
cx
initialScopeChain
)
;
Shape
*
shape
=
nullptr
;
while
(
scopeChain
)
{
if
(
!
shapes
.
append
(
scopeChain
-
>
maybeShape
(
)
)
)
return
false
;
if
(
scopeChain
-
>
is
<
GlobalObject
>
(
)
)
{
shape
=
scopeChain
-
>
as
<
GlobalObject
>
(
)
.
lookup
(
cx
id
)
;
if
(
shape
)
break
;
return
true
;
}
if
(
!
scopeChain
-
>
is
<
ScopeObject
>
(
)
|
|
scopeChain
-
>
is
<
DynamicWithObject
>
(
)
)
return
true
;
shape
=
scopeChain
-
>
as
<
NativeObject
>
(
)
.
lookup
(
cx
id
)
;
if
(
shape
)
break
;
scopeChain
=
scopeChain
-
>
enclosingScope
(
)
;
}
if
(
!
IsCacheableGetPropReadSlot
(
scopeChain
scopeChain
shape
)
)
return
true
;
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
ICStub
*
monitorStub
=
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
;
ICStub
*
newStub
;
switch
(
shapes
.
length
(
)
)
{
case
1
:
{
ICGetName_Scope
<
0
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
2
:
{
ICGetName_Scope
<
1
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
3
:
{
ICGetName_Scope
<
2
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
4
:
{
ICGetName_Scope
<
3
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
5
:
{
ICGetName_Scope
<
4
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
6
:
{
ICGetName_Scope
<
5
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
case
7
:
{
ICGetName_Scope
<
6
>
:
:
Compiler
compiler
(
cx
monitorStub
Move
(
shapes
.
get
(
)
)
isFixedSlot
offset
)
;
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
break
;
}
default
:
return
true
;
}
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetName_Fallback
*
stub_
HandleObject
scopeChain
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICGetName_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETNAME
|
|
op
=
=
JSOP_GETGNAME
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
bool
attached
=
false
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICGetName_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
attached
=
true
;
}
if
(
!
attached
&
&
IsGlobalOp
(
JSOp
(
*
pc
)
)
&
&
!
script
-
>
hasNonSyntacticScope
(
)
)
{
if
(
!
TryAttachGlobalNameAccessorStub
(
cx
script
pc
stub
scopeChain
.
as
<
ClonedBlockObject
>
(
)
name
&
attached
&
isTemporarilyUnoptimizable
)
)
{
return
false
;
}
}
static_assert
(
JSOP_GETGNAME_LENGTH
=
=
JSOP_GETNAME_LENGTH
"
Otherwise
our
check
for
JSOP_TYPEOF
isn
'
t
ok
"
)
;
if
(
JSOp
(
pc
[
JSOP_GETGNAME_LENGTH
]
)
=
=
JSOP_TYPEOF
)
{
if
(
!
GetScopeNameForTypeOf
(
cx
scopeChain
name
res
)
)
return
false
;
}
else
{
if
(
!
GetScopeName
(
cx
scopeChain
name
res
)
)
return
false
;
}
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
attached
)
return
true
;
if
(
IsGlobalOp
(
JSOp
(
*
pc
)
)
&
&
!
script
-
>
hasNonSyntacticScope
(
)
)
{
Handle
<
ClonedBlockObject
*
>
globalLexical
=
scopeChain
.
as
<
ClonedBlockObject
>
(
)
;
if
(
!
TryAttachGlobalNameValueStub
(
cx
script
pc
stub
globalLexical
name
&
attached
)
)
return
false
;
}
else
{
if
(
!
TryAttachScopeNameStub
(
cx
script
stub
scopeChain
name
&
attached
)
)
return
false
;
}
if
(
!
attached
&
&
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoGetNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoGetNameFallbackInfo
=
FunctionInfo
<
DoGetNameFallbackFn
>
(
DoGetNameFallback
TailCall
)
;
bool
ICGetName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetNameFallbackInfo
masm
)
;
}
bool
ICGetName_GlobalLexical
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Register
obj
=
R0
.
scratchReg
(
)
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
loadPtr
(
Address
(
obj
NativeObject
:
:
offsetOfSlots
(
)
)
obj
)
;
masm
.
load32
(
Address
(
ICStubReg
ICGetName_GlobalLexical
:
:
offsetOfSlot
(
)
)
scratch
)
;
masm
.
loadValue
(
BaseIndex
(
obj
scratch
TimesEight
)
R0
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
template
<
size_t
NumHops
>
bool
ICGetName_Scope
<
NumHops
>
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
obj
=
R0
.
scratchReg
(
)
;
Register
walker
=
regs
.
takeAny
(
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
size_t
numHops
=
NumHops
;
for
(
size_t
index
=
0
;
index
<
NumHops
+
1
;
index
+
+
)
{
Register
scope
=
index
?
walker
:
obj
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICGetName_Scope
:
:
offsetOfShape
(
index
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
scope
scratch
&
failure
)
;
if
(
index
<
numHops
)
masm
.
extractObject
(
Address
(
scope
ScopeObject
:
:
offsetOfEnclosingScope
(
)
)
walker
)
;
}
Register
scope
=
NumHops
?
walker
:
obj
;
if
(
!
isFixedSlot_
)
{
masm
.
loadPtr
(
Address
(
scope
NativeObject
:
:
offsetOfSlots
(
)
)
walker
)
;
scope
=
walker
;
}
masm
.
load32
(
Address
(
ICStubReg
ICGetName_Scope
:
:
offsetOfOffset
(
)
)
scratch
)
;
BaseIndex
slot
(
scope
scratch
TimesOne
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
slot
&
failure
)
;
masm
.
loadValue
(
slot
R0
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBindName_Fallback
*
stub
HandleObject
scopeChain
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
BindName
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_BINDNAME
|
|
op
=
=
JSOP_BINDGNAME
)
;
RootedPropertyName
name
(
cx
frame
-
>
script
(
)
-
>
getName
(
pc
)
)
;
RootedObject
scope
(
cx
)
;
if
(
!
LookupNameUnqualified
(
cx
name
scopeChain
&
scope
)
)
return
false
;
res
.
setObject
(
*
scope
)
;
return
true
;
}
typedef
bool
(
*
DoBindNameFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICBindName_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoBindNameFallbackInfo
=
FunctionInfo
<
DoBindNameFallbackFn
>
(
DoBindNameFallback
TailCall
)
;
bool
ICBindName_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoBindNameFallbackInfo
masm
)
;
}
static
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIntrinsic_Fallback
*
stub_
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICGetIntrinsic_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetIntrinsic
(
%
s
)
"
CodeName
[
JSOp
(
*
pc
)
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_GETINTRINSIC
)
;
if
(
!
GetIntrinsicOperation
(
cx
pc
res
)
)
return
false
;
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
GetIntrinsic
optimized
stub
"
)
;
ICGetIntrinsic_Constant
:
:
Compiler
compiler
(
cx
res
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
typedef
bool
(
*
DoGetIntrinsicFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICGetIntrinsic_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoGetIntrinsicFallbackInfo
=
FunctionInfo
<
DoGetIntrinsicFallbackFn
>
(
DoGetIntrinsicFallback
TailCall
)
;
bool
ICGetIntrinsic_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoGetIntrinsicFallbackInfo
masm
)
;
}
bool
ICGetIntrinsic_Constant
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
masm
.
loadValue
(
Address
(
ICStubReg
ICGetIntrinsic_Constant
:
:
offsetOfValue
(
)
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
bool
TryAttachSetValuePropStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICSetProp_Fallback
*
stub
HandleObject
obj
HandleShape
oldShape
HandleObjectGroup
oldGroup
HandlePropertyName
name
HandleId
id
HandleValue
rhs
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
obj
-
>
watched
(
)
)
return
true
;
RootedShape
shape
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
EffectlesslyLookupProperty
(
cx
obj
id
&
holder
&
shape
)
)
return
false
;
if
(
obj
!
=
holder
)
return
true
;
if
(
!
obj
-
>
isNative
(
)
)
{
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
;
if
(
expando
)
{
shape
=
expando
-
>
lookup
(
cx
name
)
;
if
(
!
shape
)
return
true
;
}
else
{
return
true
;
}
}
else
{
return
true
;
}
}
size_t
chainDepth
;
if
(
IsCacheableSetPropAddSlot
(
cx
obj
oldShape
id
shape
&
chainDepth
)
)
{
if
(
chainDepth
>
ICSetProp_NativeAdd
:
:
MAX_PROTO_CHAIN_DEPTH
)
return
true
;
if
(
oldGroup
-
>
newScript
(
)
&
&
!
oldGroup
-
>
newScript
(
)
-
>
analyzed
(
)
)
{
*
attached
=
true
;
return
true
;
}
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetProp
(
NativeObject
.
ADD
)
stub
"
)
;
ICSetPropNativeAddCompiler
compiler
(
cx
obj
oldShape
oldGroup
chainDepth
isFixedSlot
offset
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
if
(
!
newStub
-
>
addUpdateStubForValue
(
cx
script
obj
id
rhs
)
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
IsCacheableSetPropWriteSlot
(
obj
oldShape
shape
)
)
{
EnsureTrackPropertyTypes
(
cx
obj
id
)
;
if
(
!
PropertyHasBeenMarkedNonConstant
(
obj
id
)
)
{
*
attached
=
true
;
return
true
;
}
bool
isFixedSlot
;
uint32_t
offset
;
GetFixedOrDynamicSlotOffset
(
shape
&
isFixedSlot
&
offset
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetProp
(
NativeObject
.
PROP
)
stub
"
)
;
MOZ_ASSERT
(
LastPropertyForSetProp
(
obj
)
=
=
oldShape
"
Should
this
really
be
a
SetPropWriteSlot
?
"
)
;
ICSetProp_Native
:
:
Compiler
compiler
(
cx
obj
isFixedSlot
offset
)
;
ICSetProp_Native
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
if
(
!
newStub
-
>
addUpdateStubForValue
(
cx
script
obj
id
rhs
)
)
return
false
;
if
(
IsPreliminaryObject
(
obj
)
)
newStub
-
>
notePreliminaryObject
(
)
;
else
StripPreliminaryObjectStubs
(
cx
stub
)
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
return
true
;
}
static
bool
TryAttachSetAccessorPropStub
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
ICSetProp_Fallback
*
stub
HandleObject
obj
const
RootedReceiverGuard
&
receiverGuard
HandlePropertyName
name
HandleId
id
HandleValue
rhs
bool
*
attached
bool
*
isTemporarilyUnoptimizable
)
{
MOZ_ASSERT
(
!
*
attached
)
;
MOZ_ASSERT
(
!
*
isTemporarilyUnoptimizable
)
;
if
(
obj
-
>
watched
(
)
)
return
true
;
RootedShape
shape
(
cx
)
;
RootedObject
holder
(
cx
)
;
if
(
!
EffectlesslyLookupProperty
(
cx
obj
id
&
holder
&
shape
)
)
return
false
;
bool
isScripted
=
false
;
bool
cacheableCall
=
IsCacheableSetPropCall
(
cx
obj
holder
shape
&
isScripted
isTemporarilyUnoptimizable
)
;
if
(
cacheableCall
&
&
isScripted
)
{
RootedFunction
callee
(
cx
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
MOZ_ASSERT
(
callee
-
>
hasScript
(
)
)
;
if
(
UpdateExistingSetPropCallStubs
(
stub
ICStub
:
:
SetProp_CallScripted
&
holder
-
>
as
<
NativeObject
>
(
)
obj
callee
)
)
{
*
attached
=
true
;
return
true
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetProp
(
NativeObj
/
ScriptedSetter
%
s
:
%
"
PRIuSIZE
"
)
stub
"
callee
-
>
nonLazyScript
(
)
-
>
filename
(
)
callee
-
>
nonLazyScript
(
)
-
>
lineno
(
)
)
;
ICSetProp_CallScripted
:
:
Compiler
compiler
(
cx
obj
holder
callee
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
if
(
cacheableCall
&
&
!
isScripted
)
{
RootedFunction
callee
(
cx
&
shape
-
>
setterObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
if
(
UpdateExistingSetPropCallStubs
(
stub
ICStub
:
:
SetProp_CallNative
&
holder
-
>
as
<
NativeObject
>
(
)
obj
callee
)
)
{
*
attached
=
true
;
return
true
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
SetProp
(
NativeObj
/
NativeSetter
%
p
)
stub
"
callee
-
>
native
(
)
)
;
ICSetProp_CallNative
:
:
Compiler
compiler
(
cx
obj
holder
callee
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
return
true
;
}
static
bool
TryAttachUnboxedSetPropStub
(
JSContext
*
cx
HandleScript
script
ICSetProp_Fallback
*
stub
HandleId
id
HandleObject
obj
HandleValue
rhs
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
true
;
if
(
!
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
return
true
;
const
UnboxedLayout
:
:
Property
*
property
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
layout
(
)
.
lookup
(
id
)
;
if
(
!
property
)
return
true
;
ICSetProp_Unboxed
:
:
Compiler
compiler
(
cx
obj
-
>
group
(
)
property
-
>
offset
+
UnboxedPlainObject
:
:
offsetOfData
(
)
property
-
>
type
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
script
obj
id
rhs
)
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
StripPreliminaryObjectStubs
(
cx
stub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
TryAttachTypedObjectSetPropStub
(
JSContext
*
cx
HandleScript
script
ICSetProp_Fallback
*
stub
HandleId
id
HandleObject
obj
HandleValue
rhs
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
!
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
return
true
;
if
(
!
obj
-
>
is
<
TypedObject
>
(
)
)
return
true
;
if
(
!
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
is
<
StructTypeDescr
>
(
)
)
return
true
;
Rooted
<
StructTypeDescr
*
>
structDescr
(
cx
)
;
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
if
(
!
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
return
true
;
Rooted
<
TypeDescr
*
>
fieldDescr
(
cx
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
)
;
if
(
!
fieldDescr
-
>
is
<
SimpleTypeDescr
>
(
)
)
return
true
;
uint32_t
fieldOffset
=
structDescr
-
>
fieldOffset
(
fieldIndex
)
;
ICSetProp_TypedObject
:
:
Compiler
compiler
(
cx
obj
-
>
maybeShape
(
)
obj
-
>
group
(
)
fieldOffset
&
fieldDescr
-
>
as
<
SimpleTypeDescr
>
(
)
)
;
ICUpdatedStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
if
(
compiler
.
needsUpdateStubs
(
)
&
&
!
newStub
-
>
addUpdateStubForValue
(
cx
script
obj
id
rhs
)
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetProp_Fallback
*
stub_
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICSetProp_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetProp
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
|
|
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
|
|
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
|
|
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
|
|
op
=
=
JSOP_INITGLEXICAL
)
;
RootedPropertyName
name
(
cx
)
;
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
name
=
ScopeCoordinateName
(
cx
-
>
runtime
(
)
-
>
scopeCoordinateNameCache
script
pc
)
;
else
name
=
script
-
>
getName
(
pc
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
RootedObject
obj
(
cx
ToObjectFromStack
(
cx
lhs
)
)
;
if
(
!
obj
)
return
false
;
RootedShape
oldShape
(
cx
obj
-
>
maybeShape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
obj
-
>
getGroup
(
cx
)
)
;
if
(
!
oldGroup
)
return
false
;
RootedReceiverGuard
oldGuard
(
cx
ReceiverGuard
(
obj
)
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
MOZ_ASSERT
(
!
oldShape
)
;
if
(
UnboxedExpandoObject
*
expando
=
obj
-
>
as
<
UnboxedPlainObject
>
(
)
.
maybeExpando
(
)
)
oldShape
=
expando
-
>
lastProperty
(
)
;
}
bool
attached
=
false
;
bool
isTemporarilyUnoptimizable
=
false
;
if
(
stub
-
>
numOptimizedStubs
(
)
<
ICSetProp_Fallback
:
:
MAX_OPTIMIZED_STUBS
&
&
lhs
.
isObject
(
)
&
&
!
TryAttachSetAccessorPropStub
(
cx
script
pc
stub
obj
oldGuard
name
id
rhs
&
attached
&
isTemporarilyUnoptimizable
)
)
{
return
false
;
}
if
(
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITLOCKEDPROP
|
|
op
=
=
JSOP_INITHIDDENPROP
)
{
if
(
!
InitPropertyOperation
(
cx
op
obj
id
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
)
{
if
(
!
SetNameOperation
(
cx
script
pc
obj
rhs
)
)
return
false
;
}
else
if
(
op
=
=
JSOP_SETALIASEDVAR
|
|
op
=
=
JSOP_INITALIASEDLEXICAL
)
{
obj
-
>
as
<
ScopeObject
>
(
)
.
setAliasedVar
(
cx
ScopeCoordinate
(
pc
)
name
rhs
)
;
}
else
if
(
op
=
=
JSOP_INITGLEXICAL
)
{
RootedValue
v
(
cx
rhs
)
;
ClonedBlockObject
*
lexicalScope
;
if
(
script
-
>
hasNonSyntacticScope
(
)
)
lexicalScope
=
&
NearestEnclosingExtensibleLexicalScope
(
frame
-
>
scopeChain
(
)
)
;
else
lexicalScope
=
&
cx
-
>
global
(
)
-
>
lexicalScope
(
)
;
InitGlobalLexicalOperation
(
cx
lexicalScope
script
pc
v
)
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_SETPROP
|
|
op
=
=
JSOP_STRICTSETPROP
)
;
ObjectOpResult
result
;
if
(
!
SetProperty
(
cx
obj
id
rhs
lhs
result
)
|
|
!
result
.
checkStrictErrorOrWarning
(
cx
obj
id
op
=
=
JSOP_STRICTSETPROP
)
)
{
return
false
;
}
}
res
.
set
(
rhs
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICSetProp_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
if
(
!
attached
&
&
lhs
.
isObject
(
)
&
&
!
TryAttachSetValuePropStub
(
cx
script
pc
stub
obj
oldShape
oldGroup
name
id
rhs
&
attached
)
)
{
return
false
;
}
if
(
attached
)
return
true
;
if
(
!
attached
&
&
lhs
.
isObject
(
)
&
&
!
TryAttachUnboxedSetPropStub
(
cx
script
stub
id
obj
rhs
&
attached
)
)
{
return
false
;
}
if
(
attached
)
return
true
;
if
(
!
attached
&
&
lhs
.
isObject
(
)
&
&
!
TryAttachTypedObjectSetPropStub
(
cx
script
stub
id
obj
rhs
&
attached
)
)
{
return
false
;
}
if
(
attached
)
return
true
;
MOZ_ASSERT
(
!
attached
)
;
if
(
!
isTemporarilyUnoptimizable
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoSetPropFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICSetProp_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoSetPropFallbackInfo
=
FunctionInfo
<
DoSetPropFallbackFn
>
(
DoSetPropFallback
TailCall
PopValues
(
2
)
)
;
bool
ICSetProp_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
tailCallVM
(
DoSetPropFallbackInfo
masm
)
)
return
false
;
#
ifdef
DEBUG
EmitRepushTailCallReg
(
masm
)
;
EmitStowICValues
(
masm
1
)
;
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
#
else
inStubFrame_
=
true
;
#
endif
returnOffset_
=
masm
.
currentOffset
(
)
;
leaveStubFrame
(
masm
true
)
;
EmitUnstowICValues
(
masm
1
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
void
ICSetProp_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBaselineSetPropReturnAddr
(
code
-
>
raw
(
)
+
returnOffset_
)
;
}
static
void
GuardGroupAndShapeMaybeUnboxedExpando
(
MacroAssembler
&
masm
JSObject
*
obj
Register
object
Register
scratch
size_t
offsetOfGroup
size_t
offsetOfShape
Label
*
failure
)
{
masm
.
loadPtr
(
Address
(
ICStubReg
offsetOfGroup
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
scratch
failure
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetOfShape
)
scratch
)
;
if
(
obj
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
Address
expandoAddress
(
object
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
expandoAddress
ImmWord
(
0
)
failure
)
;
Label
done
;
masm
.
push
(
object
)
;
masm
.
loadPtr
(
expandoAddress
object
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
Equal
object
scratch
&
done
)
;
masm
.
pop
(
object
)
;
masm
.
jump
(
failure
)
;
masm
.
bind
(
&
done
)
;
masm
.
pop
(
object
)
;
}
else
{
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
scratch
failure
)
;
}
}
bool
ICSetProp_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
GuardGroupAndShapeMaybeUnboxedExpando
(
masm
obj_
objReg
scratch
ICSetProp_Native
:
:
offsetOfGroup
(
)
ICSetProp_Native
:
:
offsetOfShape
(
)
&
failure
)
;
EmitStowICValues
(
masm
2
)
;
masm
.
moveValue
(
R1
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
regs
.
add
(
R0
)
;
regs
.
takeUnchecked
(
objReg
)
;
Register
holderReg
;
if
(
obj_
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
objReg
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
holderReg
)
;
if
(
!
isFixedSlot_
)
masm
.
loadPtr
(
Address
(
holderReg
NativeObject
:
:
offsetOfSlots
(
)
)
holderReg
)
;
}
else
if
(
isFixedSlot_
)
{
holderReg
=
objReg
;
}
else
{
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
objReg
NativeObject
:
:
offsetOfSlots
(
)
)
holderReg
)
;
}
masm
.
load32
(
Address
(
ICStubReg
ICSetProp_Native
:
:
offsetOfOffset
(
)
)
scratch
)
;
EmitPreBarrier
(
masm
BaseIndex
(
holderReg
scratch
TimesOne
)
MIRType_Value
)
;
masm
.
storeValue
(
R1
BaseIndex
(
holderReg
scratch
TimesOne
)
)
;
if
(
holderReg
!
=
objReg
)
regs
.
add
(
holderReg
)
;
if
(
cx
-
>
runtime
(
)
-
>
gc
.
nursery
.
exists
(
)
)
{
Register
scr
=
regs
.
takeAny
(
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R1
)
;
emitPostWriteBarrierSlot
(
masm
objReg
R1
scr
saveRegs
)
;
regs
.
add
(
scr
)
;
}
masm
.
moveValue
(
R1
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICUpdatedStub
*
ICSetPropNativeAddCompiler
:
:
getStub
(
ICStubSpace
*
space
)
{
Rooted
<
ShapeVector
>
shapes
(
cx
ShapeVector
(
cx
)
)
;
if
(
!
shapes
.
append
(
oldShape_
)
)
return
nullptr
;
if
(
!
GetProtoShapes
(
obj_
protoChainDepth_
&
shapes
)
)
return
nullptr
;
JS_STATIC_ASSERT
(
ICSetProp_NativeAdd
:
:
MAX_PROTO_CHAIN_DEPTH
=
=
4
)
;
ICUpdatedStub
*
stub
=
nullptr
;
switch
(
protoChainDepth_
)
{
case
0
:
stub
=
getStubSpecific
<
0
>
(
space
shapes
)
;
break
;
case
1
:
stub
=
getStubSpecific
<
1
>
(
space
shapes
)
;
break
;
case
2
:
stub
=
getStubSpecific
<
2
>
(
space
shapes
)
;
break
;
case
3
:
stub
=
getStubSpecific
<
3
>
(
space
shapes
)
;
break
;
case
4
:
stub
=
getStubSpecific
<
4
>
(
space
shapes
)
;
break
;
default
:
MOZ_CRASH
(
"
ProtoChainDepth
too
high
.
"
)
;
}
if
(
!
stub
|
|
!
stub
-
>
initUpdatingChain
(
cx
space
)
)
return
nullptr
;
return
stub
;
}
bool
ICSetPropNativeAddCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Label
failureUnstow
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
GuardGroupAndShapeMaybeUnboxedExpando
(
masm
obj_
objReg
scratch
ICSetProp_NativeAdd
:
:
offsetOfGroup
(
)
ICSetProp_NativeAddImpl
<
0
>
:
:
offsetOfShape
(
0
)
&
failure
)
;
EmitStowICValues
(
masm
2
)
;
regs
=
availableGeneralRegs
(
1
)
;
scratch
=
regs
.
takeAny
(
)
;
Register
protoReg
=
regs
.
takeAny
(
)
;
for
(
size_t
i
=
0
;
i
<
protoChainDepth_
;
i
+
+
)
{
masm
.
loadObjProto
(
i
=
=
0
?
objReg
:
protoReg
protoReg
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
protoReg
protoReg
&
failureUnstow
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_NativeAddImpl
<
0
>
:
:
offsetOfShape
(
i
+
1
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
protoReg
scratch
&
failureUnstow
)
;
}
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
regs
=
availableGeneralRegs
(
2
)
;
scratch
=
regs
.
takeAny
(
)
;
if
(
obj_
-
>
is
<
PlainObject
>
(
)
)
{
Label
noGroupChange
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_NativeAdd
:
:
offsetOfNewGroup
(
)
)
scratch
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch
scratch
&
noGroupChange
)
;
masm
.
loadPtr
(
Address
(
objReg
JSObject
:
:
offsetOfGroup
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
Address
(
scratch
ObjectGroup
:
:
offsetOfAddendum
(
)
)
ImmWord
(
0
)
&
noGroupChange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_NativeAdd
:
:
offsetOfNewGroup
(
)
)
scratch
)
;
Address
groupAddr
(
objReg
JSObject
:
:
offsetOfGroup
(
)
)
;
EmitPreBarrier
(
masm
groupAddr
MIRType_ObjectGroup
)
;
masm
.
storePtr
(
scratch
groupAddr
)
;
masm
.
bind
(
&
noGroupChange
)
;
}
Register
holderReg
;
regs
.
add
(
R0
)
;
regs
.
takeUnchecked
(
objReg
)
;
if
(
obj_
-
>
is
<
UnboxedPlainObject
>
(
)
)
{
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
objReg
UnboxedPlainObject
:
:
offsetOfExpando
(
)
)
holderReg
)
;
Address
shapeAddr
(
holderReg
JSObject
:
:
offsetOfShape
(
)
)
;
EmitPreBarrier
(
masm
shapeAddr
MIRType_Shape
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_NativeAdd
:
:
offsetOfNewShape
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
shapeAddr
)
;
if
(
!
isFixedSlot_
)
masm
.
loadPtr
(
Address
(
holderReg
NativeObject
:
:
offsetOfSlots
(
)
)
holderReg
)
;
}
else
{
Address
shapeAddr
(
objReg
JSObject
:
:
offsetOfShape
(
)
)
;
EmitPreBarrier
(
masm
shapeAddr
MIRType_Shape
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_NativeAdd
:
:
offsetOfNewShape
(
)
)
scratch
)
;
masm
.
storePtr
(
scratch
shapeAddr
)
;
if
(
isFixedSlot_
)
{
holderReg
=
objReg
;
}
else
{
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
objReg
NativeObject
:
:
offsetOfSlots
(
)
)
holderReg
)
;
}
}
masm
.
load32
(
Address
(
ICStubReg
ICSetProp_NativeAdd
:
:
offsetOfOffset
(
)
)
scratch
)
;
masm
.
storeValue
(
R1
BaseIndex
(
holderReg
scratch
TimesOne
)
)
;
if
(
holderReg
!
=
objReg
)
regs
.
add
(
holderReg
)
;
if
(
cx
-
>
runtime
(
)
-
>
gc
.
nursery
.
exists
(
)
)
{
Register
scr
=
regs
.
takeAny
(
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R1
)
;
emitPostWriteBarrierSlot
(
masm
objReg
R1
scr
saveRegs
)
;
}
masm
.
moveValue
(
R1
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureUnstow
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICSetProp_Unboxed
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
object
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_Unboxed
:
:
offsetOfGroup
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
scratch
&
failure
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
push
(
object
)
;
masm
.
push
(
ICStubReg
)
;
EmitStowICValues
(
masm
2
)
;
masm
.
moveValue
(
R1
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
pop
(
ICStubReg
)
;
masm
.
pop
(
object
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
add
(
R1
)
;
saveRegs
.
addUnchecked
(
object
)
;
saveRegs
.
add
(
ICStubReg
)
;
emitPostWriteBarrierSlot
(
masm
object
R1
scratch
saveRegs
)
;
}
masm
.
load32
(
Address
(
ICStubReg
ICSetProp_Unboxed
:
:
offsetOfFieldOffset
(
)
)
scratch
)
;
BaseIndex
address
(
object
scratch
TimesOne
)
;
EmitUnboxedPreBarrierForBaseline
(
masm
address
fieldType_
)
;
masm
.
storeUnboxedProperty
(
address
fieldType_
ConstantOrRegister
(
TypedOrValueRegister
(
R1
)
)
&
failure
)
;
masm
.
moveValue
(
R1
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICSetProp_TypedObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
CheckForTypedObjectWithDetachedStorage
(
cx
masm
&
failure
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
2
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
Register
object
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_TypedObject
:
:
offsetOfShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
object
scratch
&
failure
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_TypedObject
:
:
offsetOfGroup
(
)
)
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
object
JSObject
:
:
offsetOfGroup
(
)
)
scratch
&
failure
)
;
if
(
needsUpdateStubs
(
)
)
{
masm
.
push
(
object
)
;
masm
.
push
(
ICStubReg
)
;
EmitStowICValues
(
masm
2
)
;
masm
.
moveValue
(
R1
R0
)
;
if
(
!
callTypeUpdateIC
(
masm
sizeof
(
Value
)
)
)
return
false
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
pop
(
ICStubReg
)
;
masm
.
pop
(
object
)
;
LiveGeneralRegisterSet
saveRegs
;
saveRegs
.
add
(
R0
)
;
saveRegs
.
add
(
R1
)
;
saveRegs
.
addUnchecked
(
object
)
;
saveRegs
.
add
(
ICStubReg
)
;
emitPostWriteBarrierSlot
(
masm
object
R1
scratch
saveRegs
)
;
}
Label
failurePopRHS
;
masm
.
pushValue
(
R1
)
;
regs
=
availableGeneralRegs
(
1
)
;
regs
.
takeUnchecked
(
object
)
;
regs
.
take
(
scratch
)
;
Register
secondScratch
=
regs
.
takeAny
(
)
;
LoadTypedThingData
(
masm
layout_
object
scratch
)
;
masm
.
load32
(
Address
(
ICStubReg
ICSetProp_TypedObject
:
:
offsetOfFieldOffset
(
)
)
secondScratch
)
;
masm
.
addPtr
(
secondScratch
scratch
)
;
Address
dest
(
scratch
0
)
;
Address
value
(
masm
.
getStackPointer
(
)
0
)
;
if
(
fieldDescr_
-
>
is
<
ScalarTypeDescr
>
(
)
)
{
Scalar
:
:
Type
type
=
fieldDescr_
-
>
as
<
ScalarTypeDescr
>
(
)
.
type
(
)
;
StoreToTypedArray
(
cx
masm
type
value
dest
secondScratch
&
failurePopRHS
&
failurePopRHS
)
;
masm
.
popValue
(
R1
)
;
EmitReturnFromIC
(
masm
)
;
}
else
{
ReferenceTypeDescr
:
:
Type
type
=
fieldDescr_
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
masm
.
popValue
(
R1
)
;
switch
(
type
)
{
case
ReferenceTypeDescr
:
:
TYPE_ANY
:
EmitPreBarrier
(
masm
dest
MIRType_Value
)
;
masm
.
storeValue
(
R1
dest
)
;
break
;
case
ReferenceTypeDescr
:
:
TYPE_OBJECT
:
{
EmitPreBarrier
(
masm
dest
MIRType_Object
)
;
Label
notObject
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
notObject
)
;
Register
rhsObject
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
storePtr
(
rhsObject
dest
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
notObject
)
;
masm
.
branchTestNull
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
masm
.
storePtr
(
ImmWord
(
0
)
dest
)
;
break
;
}
case
ReferenceTypeDescr
:
:
TYPE_STRING
:
{
EmitPreBarrier
(
masm
dest
MIRType_String
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
rhsString
=
masm
.
extractString
(
R1
ExtractTemp0
)
;
masm
.
storePtr
(
rhsString
dest
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
EmitReturnFromIC
(
masm
)
;
}
masm
.
bind
(
&
failurePopRHS
)
;
masm
.
popValue
(
R1
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICSetProp_CallScripted
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Label
failureUnstow
;
Label
failureLeaveStubFrame
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
EmitStowICValues
(
masm
2
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
scratch
=
regs
.
takeAnyExcluding
(
ICTailCallReg
)
;
uint32_t
framePushed
=
masm
.
framePushed
(
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
GuardReceiverObject
(
masm
ReceiverGuard
(
receiver_
)
objReg
scratch
ICSetProp_CallScripted
:
:
offsetOfReceiverGuard
(
)
&
failureUnstow
)
;
if
(
receiver_
!
=
holder_
)
{
Register
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallScripted
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallScripted
:
:
offsetOfHolderShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
holderReg
scratch
&
failureUnstow
)
;
regs
.
add
(
holderReg
)
;
}
enterStubFrame
(
masm
scratch
)
;
Register
callee
;
if
(
regs
.
has
(
ArgumentsRectifierReg
)
)
{
callee
=
ArgumentsRectifierReg
;
regs
.
take
(
callee
)
;
}
else
{
callee
=
regs
.
takeAny
(
)
;
}
Register
code
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallScripted
:
:
offsetOfSetter
(
)
)
callee
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failureLeaveStubFrame
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
code
)
;
masm
.
loadBaselineOrIonRaw
(
code
code
&
failureLeaveStubFrame
)
;
masm
.
alignJitStackBasedOnNArgs
(
1
)
;
masm
.
PushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
masm
.
Push
(
R0
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
Imm32
(
1
)
)
;
masm
.
Push
(
callee
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
scratch
Imm32
(
1
)
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
ImmWord
(
1
)
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
uint32_t
framePushedAfterCall
=
masm
.
framePushed
(
)
;
leaveStubFrame
(
masm
true
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
moveValue
(
R1
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureLeaveStubFrame
)
;
masm
.
setFramePushed
(
framePushedAfterCall
)
;
inStubFrame_
=
true
;
leaveStubFrame
(
masm
false
)
;
masm
.
bind
(
&
failureUnstow
)
;
masm
.
setFramePushed
(
framePushed
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoCallNativeSetter
(
JSContext
*
cx
HandleFunction
callee
HandleObject
obj
HandleValue
val
)
{
MOZ_ASSERT
(
callee
-
>
isNative
(
)
)
;
JSNative
natfun
=
callee
-
>
native
(
)
;
JS
:
:
AutoValueArray
<
3
>
vp
(
cx
)
;
vp
[
0
]
.
setObject
(
*
callee
.
get
(
)
)
;
vp
[
1
]
.
setObject
(
*
obj
.
get
(
)
)
;
vp
[
2
]
.
set
(
val
)
;
return
natfun
(
cx
1
vp
.
begin
(
)
)
;
}
typedef
bool
(
*
DoCallNativeSetterFn
)
(
JSContext
*
HandleFunction
HandleObject
HandleValue
)
;
static
const
VMFunction
DoCallNativeSetterInfo
=
FunctionInfo
<
DoCallNativeSetterFn
>
(
DoCallNativeSetter
)
;
bool
ICSetProp_CallNative
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Label
failureUnstow
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
EmitStowICValues
(
masm
2
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
scratch
=
regs
.
takeAnyExcluding
(
ICTailCallReg
)
;
uint32_t
framePushed
=
masm
.
framePushed
(
)
;
Register
objReg
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
GuardReceiverObject
(
masm
ReceiverGuard
(
receiver_
)
objReg
scratch
ICSetProp_CallNative
:
:
offsetOfReceiverGuard
(
)
&
failureUnstow
)
;
if
(
receiver_
!
=
holder_
)
{
Register
holderReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallNative
:
:
offsetOfHolder
(
)
)
holderReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallNative
:
:
offsetOfHolderShape
(
)
)
scratch
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
holderReg
scratch
&
failureUnstow
)
;
regs
.
add
(
holderReg
)
;
}
enterStubFrame
(
masm
scratch
)
;
Register
callee
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICSetProp_CallNative
:
:
offsetOfSetter
(
)
)
callee
)
;
masm
.
moveStackPtrTo
(
scratch
)
;
masm
.
pushValue
(
Address
(
scratch
STUB_FRAME_SIZE
)
)
;
masm
.
push
(
objReg
)
;
masm
.
push
(
callee
)
;
regs
.
add
(
R0
)
;
if
(
!
callVM
(
DoCallNativeSetterInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
moveValue
(
R1
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureUnstow
)
;
masm
.
setFramePushed
(
framePushed
)
;
EmitUnstowICValues
(
masm
2
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
TryAttachFunApplyStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
uint32_t
argc
Value
*
argv
bool
*
attached
)
{
if
(
argc
!
=
2
)
return
true
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
bool
isScripted
=
target
-
>
hasJITCode
(
)
;
if
(
argv
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
!
script
-
>
needsArgsObj
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArguments
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArguments
stub
"
)
;
ICCall_ScriptedApplyArguments
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
if
(
argv
[
1
]
.
isObject
(
)
&
&
argv
[
1
]
.
toObject
(
)
.
is
<
ArrayObject
>
(
)
)
{
if
(
isScripted
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedApplyArray
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedApplyArray
stub
"
)
;
ICCall_ScriptedApplyArray
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
}
return
true
;
}
static
bool
TryAttachFunCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
HandleValue
thisv
bool
*
attached
)
{
*
attached
=
false
;
if
(
!
thisv
.
isObject
(
)
|
|
!
thisv
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
true
;
RootedFunction
target
(
cx
&
thisv
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
target
-
>
hasScript
(
)
&
&
target
-
>
nonLazyScript
(
)
-
>
canBaselineCompile
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
Call_ScriptedFunCall
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ScriptedFunCall
stub
"
)
;
ICCall_ScriptedFunCall
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
*
attached
=
true
;
stub
-
>
addNewStub
(
newStub
)
;
return
true
;
}
return
true
;
}
static
bool
GetTemplateObjectForSimd
(
JSContext
*
cx
JSFunction
*
target
MutableHandleObject
res
)
{
const
JSJitInfo
*
jitInfo
=
target
-
>
jitInfo
(
)
;
if
(
!
jitInfo
|
|
jitInfo
-
>
type
(
)
!
=
JSJitInfo
:
:
InlinableNative
)
return
false
;
SimdType
ctrlType
;
switch
(
jitInfo
-
>
inlinableNative
)
{
case
InlinableNative
:
:
SimdInt32x4
:
ctrlType
=
SimdType
:
:
Int32x4
;
break
;
case
InlinableNative
:
:
SimdUint32x4
:
ctrlType
=
SimdType
:
:
Uint32x4
;
break
;
case
InlinableNative
:
:
SimdFloat32x4
:
ctrlType
=
SimdType
:
:
Float32x4
;
break
;
case
InlinableNative
:
:
SimdBool32x4
:
ctrlType
=
SimdType
:
:
Bool32x4
;
break
;
default
:
return
false
;
}
SimdOperation
simdOp
=
SimdOperation
(
jitInfo
-
>
nativeOp
)
;
SimdType
retType
;
switch
(
simdOp
)
{
case
SimdOperation
:
:
Fn_allTrue
:
case
SimdOperation
:
:
Fn_anyTrue
:
case
SimdOperation
:
:
Fn_extractLane
:
return
false
;
case
SimdOperation
:
:
Fn_lessThan
:
case
SimdOperation
:
:
Fn_lessThanOrEqual
:
case
SimdOperation
:
:
Fn_equal
:
case
SimdOperation
:
:
Fn_notEqual
:
case
SimdOperation
:
:
Fn_greaterThan
:
case
SimdOperation
:
:
Fn_greaterThanOrEqual
:
retType
=
GetBooleanSimdType
(
ctrlType
)
;
break
;
default
:
retType
=
ctrlType
;
break
;
}
RootedGlobalObject
global
(
cx
cx
-
>
global
(
)
)
;
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
GlobalObject
:
:
getOrCreateSimdTypeDescr
(
cx
global
retType
)
)
;
res
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
true
;
}
static
bool
GetTemplateObjectForNative
(
JSContext
*
cx
JSFunction
*
target
const
CallArgs
&
args
MutableHandleObject
res
bool
*
skipAttach
)
{
Native
native
=
target
-
>
native
(
)
;
if
(
native
=
=
ArrayConstructor
)
{
size_t
count
=
0
;
if
(
args
.
length
(
)
!
=
1
)
count
=
args
.
length
(
)
;
else
if
(
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isInt32
(
)
&
&
args
[
0
]
.
toInt32
(
)
>
=
0
)
count
=
args
[
0
]
.
toInt32
(
)
;
if
(
count
<
=
ArrayObject
:
:
EagerAllocationMaxLength
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
count
TenuredObject
)
)
;
if
(
!
res
)
return
false
;
return
true
;
}
}
if
(
native
=
=
js
:
:
array_concat
|
|
native
=
=
js
:
:
array_slice
)
{
if
(
args
.
thisv
(
)
.
isObject
(
)
)
{
JSObject
*
obj
=
&
args
.
thisv
(
)
.
toObject
(
)
;
if
(
!
obj
-
>
isSingleton
(
)
)
{
if
(
obj
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayTryReuseGroup
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
0
TenuredObject
)
)
;
return
!
!
res
;
}
}
}
if
(
native
=
=
js
:
:
str_split
&
&
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isString
(
)
)
{
ObjectGroup
*
group
=
ObjectGroup
:
:
callingAllocationSiteGroup
(
cx
JSProto_Array
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
maybePreliminaryObjects
(
)
)
{
*
skipAttach
=
true
;
return
true
;
}
res
.
set
(
NewFullyAllocatedArrayForCallingAllocationSite
(
cx
0
TenuredObject
)
)
;
if
(
!
res
)
return
false
;
return
true
;
}
if
(
native
=
=
StringConstructor
)
{
RootedString
emptyString
(
cx
cx
-
>
runtime
(
)
-
>
emptyString
)
;
res
.
set
(
StringObject
:
:
create
(
cx
emptyString
nullptr
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
native
=
=
obj_create
&
&
args
.
length
(
)
=
=
1
&
&
args
[
0
]
.
isObjectOrNull
(
)
)
{
RootedObject
proto
(
cx
args
[
0
]
.
toObjectOrNull
(
)
)
;
res
.
set
(
ObjectCreateImpl
(
cx
proto
TenuredObject
)
)
;
return
!
!
res
;
}
if
(
JitSupportsSimd
(
)
&
&
GetTemplateObjectForSimd
(
cx
target
res
)
)
return
!
!
res
;
return
true
;
}
static
bool
GetTemplateObjectForClassHook
(
JSContext
*
cx
JSNative
hook
CallArgs
&
args
MutableHandleObject
templateObject
)
{
if
(
hook
=
=
TypedObject
:
:
construct
)
{
Rooted
<
TypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
TypeDescr
>
(
)
)
;
templateObject
.
set
(
TypedObject
:
:
createZeroed
(
cx
descr
1
gc
:
:
TenuredHeap
)
)
;
return
!
!
templateObject
;
}
if
(
hook
=
=
SimdTypeDescr
:
:
call
&
&
JitSupportsSimd
(
)
)
{
Rooted
<
SimdTypeDescr
*
>
descr
(
cx
&
args
.
callee
(
)
.
as
<
SimdTypeDescr
>
(
)
)
;
templateObject
.
set
(
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
getSimdTemplateObjectFor
(
cx
descr
)
)
;
return
!
!
templateObject
;
}
return
true
;
}
static
bool
IsOptimizableCallStringSplit
(
Value
callee
Value
thisv
int
argc
Value
*
args
)
{
if
(
argc
!
=
1
|
|
!
thisv
.
isString
(
)
|
|
!
args
[
0
]
.
isString
(
)
)
return
false
;
if
(
!
thisv
.
toString
(
)
-
>
isAtom
(
)
|
|
!
args
[
0
]
.
toString
(
)
-
>
isAtom
(
)
)
return
false
;
if
(
!
callee
.
isObject
(
)
|
|
!
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
return
false
;
JSFunction
&
calleeFun
=
callee
.
toObject
(
)
.
as
<
JSFunction
>
(
)
;
if
(
!
calleeFun
.
isNative
(
)
|
|
calleeFun
.
native
(
)
!
=
js
:
:
str_split
)
return
false
;
return
true
;
}
static
bool
TryAttachCallStub
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
jsbytecode
*
pc
JSOp
op
uint32_t
argc
Value
*
vp
bool
constructing
bool
isSpread
bool
createSingleton
bool
*
handled
)
{
bool
isSuper
=
op
=
=
JSOP_SUPERCALL
|
|
op
=
=
JSOP_SPREADSUPERCALL
;
if
(
createSingleton
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
return
true
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICCall_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
{
return
true
;
}
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
=
=
0
&
&
IsOptimizableCallStringSplit
(
callee
thisv
argc
vp
+
2
)
)
return
true
;
MOZ_ASSERT_IF
(
stub
-
>
hasStub
(
ICStub
:
:
Call_StringSplit
)
stub
-
>
numOptimizedStubs
(
)
=
=
1
)
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_StringSplit
)
;
if
(
!
callee
.
isObject
(
)
)
return
true
;
RootedObject
obj
(
cx
&
callee
.
toObject
(
)
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
obj
-
>
is
<
ProxyObject
>
(
)
)
return
true
;
if
(
JSNative
hook
=
constructing
?
obj
-
>
constructHook
(
)
:
obj
-
>
callHook
(
)
)
{
if
(
op
!
=
JSOP_FUNAPPLY
&
&
!
isSpread
&
&
!
createSingleton
)
{
RootedObject
templateObject
(
cx
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForClassHook
(
cx
hook
args
&
templateObject
)
)
return
false
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_ClassHook
stub
"
)
;
ICCall_ClassHook
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
obj
-
>
getClass
(
)
hook
templateObject
script
-
>
pcToOffset
(
pc
)
constructing
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
}
return
true
;
}
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
fun
-
>
hasScript
(
)
)
{
if
(
op
=
=
JSOP_FUNAPPLY
)
return
true
;
if
(
constructing
&
&
!
fun
-
>
isConstructor
(
)
)
return
true
;
if
(
!
constructing
&
&
fun
-
>
isClassConstructor
(
)
)
return
true
;
if
(
!
fun
-
>
hasJITCode
(
)
)
{
*
handled
=
true
;
return
true
;
}
if
(
stub
-
>
scriptedStubsAreGeneralized
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Chain
already
has
generalized
scripted
call
stub
!
"
)
;
return
true
;
}
if
(
stub
-
>
scriptedStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_SCRIPTED_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_AnyScripted
stub
(
cons
=
%
s
spread
=
%
s
)
"
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
unlinkStubsWithKind
(
cx
ICStub
:
:
Call_Scripted
)
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
IsIonEnabled
(
cx
)
)
EnsureTrackPropertyTypes
(
cx
fun
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
RootedObject
templateObject
(
cx
)
;
if
(
constructing
&
&
!
isSuper
)
{
RootedObject
newTarget
(
cx
&
vp
[
2
+
argc
]
.
toObject
(
)
)
;
RootedValue
protov
(
cx
)
;
if
(
!
GetPropertyPure
(
cx
newTarget
NameToId
(
cx
-
>
names
(
)
.
prototype
)
protov
.
address
(
)
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Can
'
t
purely
lookup
function
prototype
"
)
;
return
true
;
}
if
(
protov
.
isObject
(
)
)
{
TaggedProto
proto
(
&
protov
.
toObject
(
)
)
;
ObjectGroup
*
group
=
ObjectGroup
:
:
defaultNewGroup
(
cx
nullptr
proto
newTarget
)
;
if
(
!
group
)
return
false
;
if
(
group
-
>
newScript
(
)
&
&
!
group
-
>
newScript
(
)
-
>
analyzed
(
)
)
{
JitSpew
(
JitSpew_BaselineIC
"
Function
newScript
has
not
been
analyzed
"
)
;
*
handled
=
true
;
return
true
;
}
}
JSObject
*
thisObject
=
CreateThisForFunction
(
cx
fun
newTarget
TenuredObject
)
;
if
(
!
thisObject
)
return
false
;
if
(
thisObject
-
>
is
<
PlainObject
>
(
)
|
|
thisObject
-
>
is
<
UnboxedPlainObject
>
(
)
)
templateObject
=
thisObject
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Scripted
stub
(
fun
=
%
p
%
s
:
%
"
PRIuSIZE
"
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
fun
-
>
nonLazyScript
(
)
-
>
filename
(
)
fun
-
>
nonLazyScript
(
)
-
>
lineno
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCallScriptedCompiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
if
(
fun
-
>
isNative
(
)
&
&
(
!
constructing
|
|
(
constructing
&
&
fun
-
>
isConstructor
(
)
)
)
)
{
MOZ_ASSERT
(
!
stub
-
>
nativeStubsAreGeneralized
(
)
)
;
if
(
op
=
=
JSOP_FUNAPPLY
)
{
if
(
fun
-
>
native
(
)
=
=
fun_apply
)
return
TryAttachFunApplyStub
(
cx
stub
script
pc
thisv
argc
vp
+
2
handled
)
;
return
true
;
}
if
(
op
=
=
JSOP_FUNCALL
&
&
fun
-
>
native
(
)
=
=
fun_call
)
{
if
(
!
TryAttachFunCallStub
(
cx
stub
script
pc
thisv
handled
)
)
return
false
;
if
(
*
handled
)
return
true
;
}
if
(
stub
-
>
nativeStubCount
(
)
>
=
ICCall_Fallback
:
:
MAX_NATIVE_STUBS
)
{
JitSpew
(
JitSpew_BaselineIC
"
Too
many
Call_Native
stubs
.
TODO
:
add
Call_AnyNative
!
"
)
;
return
true
;
}
if
(
fun
-
>
native
(
)
=
=
intrinsic_IsSuspendedStarGenerator
)
{
MOZ_ASSERT
(
op
!
=
JSOP_NEW
)
;
MOZ_ASSERT
(
argc
=
=
1
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_IsSuspendedStarGenerator
stub
"
)
;
ICCall_IsSuspendedStarGenerator
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
RootedObject
templateObject
(
cx
)
;
if
(
MOZ_LIKELY
(
!
isSpread
&
&
!
isSuper
)
)
{
bool
skipAttach
=
false
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GetTemplateObjectForNative
(
cx
fun
args
&
templateObject
&
skipAttach
)
)
return
false
;
if
(
skipAttach
)
{
*
handled
=
true
;
return
true
;
}
MOZ_ASSERT_IF
(
templateObject
!
templateObject
-
>
group
(
)
-
>
maybePreliminaryObjects
(
)
)
;
}
JitSpew
(
JitSpew_BaselineIC
"
Generating
Call_Native
stub
(
fun
=
%
p
cons
=
%
s
spread
=
%
s
)
"
fun
.
get
(
)
constructing
?
"
yes
"
:
"
no
"
isSpread
?
"
yes
"
:
"
no
"
)
;
ICCall_Native
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
fun
templateObject
constructing
isSpread
script
-
>
pcToOffset
(
pc
)
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
handled
=
true
;
return
true
;
}
return
true
;
}
static
bool
CopyArray
(
JSContext
*
cx
HandleObject
obj
MutableHandleValue
result
)
{
uint32_t
length
=
GetAnyBoxedOrUnboxedArrayLength
(
obj
)
;
JSObject
*
nobj
=
NewFullyAllocatedArrayTryReuseGroup
(
cx
obj
length
TenuredObject
true
)
;
if
(
!
nobj
)
return
false
;
CopyAnyBoxedOrUnboxedDenseElements
(
cx
nobj
obj
0
0
length
)
;
result
.
setObject
(
*
nobj
)
;
return
true
;
}
static
bool
TryAttachStringSplit
(
JSContext
*
cx
ICCall_Fallback
*
stub
HandleScript
script
uint32_t
argc
Value
*
vp
jsbytecode
*
pc
HandleValue
res
bool
*
attached
)
{
if
(
stub
-
>
numOptimizedStubs
(
)
!
=
0
)
return
true
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
Value
*
args
=
vp
+
2
;
if
(
JSOp
(
*
pc
)
=
=
JSOP_NEW
)
return
true
;
if
(
!
IsOptimizableCallStringSplit
(
callee
thisv
argc
args
)
)
return
true
;
MOZ_ASSERT
(
callee
.
isObject
(
)
)
;
MOZ_ASSERT
(
callee
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
;
RootedString
thisString
(
cx
thisv
.
toString
(
)
)
;
RootedString
argString
(
cx
args
[
0
]
.
toString
(
)
)
;
RootedObject
obj
(
cx
&
res
.
toObject
(
)
)
;
RootedValue
arr
(
cx
)
;
if
(
!
CopyArray
(
cx
obj
&
arr
)
)
return
false
;
RootedObject
arrObj
(
cx
&
arr
.
toObject
(
)
)
;
uint32_t
initLength
=
GetAnyBoxedOrUnboxedArrayLength
(
arrObj
)
;
for
(
uint32_t
i
=
0
;
i
<
initLength
;
i
+
+
)
{
JSAtom
*
str
=
js
:
:
AtomizeString
(
cx
GetAnyBoxedOrUnboxedDenseElement
(
arrObj
i
)
.
toString
(
)
)
;
if
(
!
str
)
return
false
;
if
(
!
SetAnyBoxedOrUnboxedDenseElement
(
cx
arrObj
i
StringValue
(
str
)
)
)
{
return
true
;
}
}
ICCall_StringSplit
:
:
Compiler
compiler
(
cx
stub
-
>
fallbackMonitorStub
(
)
-
>
firstMonitorStub
(
)
script
-
>
pcToOffset
(
pc
)
thisString
argString
arr
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
Call
(
%
s
)
"
CodeName
[
op
]
)
;
MOZ_ASSERT
(
argc
=
=
GET_ARGC
(
pc
)
)
;
bool
constructing
=
(
op
=
=
JSOP_NEW
)
;
AutoArrayRooter
vpRoot
(
cx
argc
+
2
+
constructing
vp
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
Value
*
args
=
vp
+
2
;
if
(
op
=
=
JSOP_FUNAPPLY
&
&
argc
=
=
2
&
&
args
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
CallArgs
callArgs
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
GuardFunApplyArgumentsOptimization
(
cx
frame
callArgs
)
)
return
false
;
}
bool
createSingleton
=
ObjectGroup
:
:
useSingletonForNewObject
(
cx
script
pc
)
;
bool
handled
=
false
;
if
(
!
TryAttachCallStub
(
cx
stub
script
pc
op
argc
vp
constructing
false
createSingleton
&
handled
)
)
{
return
false
;
}
if
(
op
=
=
JSOP_NEW
)
{
if
(
!
IsConstructor
(
callee
)
)
{
ReportValueError
(
cx
JSMSG_NOT_CONSTRUCTOR
JSDVG_IGNORE_STACK
callee
nullptr
)
;
return
false
;
}
ConstructArgs
cargs
(
cx
)
;
if
(
!
cargs
.
init
(
argc
)
)
return
false
;
for
(
uint32_t
i
=
0
;
i
<
argc
;
i
+
+
)
cargs
[
i
]
.
set
(
args
[
i
]
)
;
RootedValue
newTarget
(
cx
args
[
argc
]
)
;
MOZ_ASSERT
(
IsConstructor
(
newTarget
)
"
either
callee
=
=
newTarget
or
the
initial
|
new
|
checked
"
"
that
IsConstructor
(
newTarget
)
"
)
;
RootedObject
obj
(
cx
)
;
if
(
!
Construct
(
cx
callee
cargs
newTarget
&
obj
)
)
return
false
;
res
.
setObject
(
*
obj
)
;
}
else
if
(
(
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
&
&
frame
-
>
scopeChain
(
)
-
>
global
(
)
.
valueIsEval
(
callee
)
)
{
if
(
!
DirectEval
(
cx
CallArgsFromVp
(
argc
vp
)
)
)
return
false
;
res
.
set
(
vp
[
0
]
)
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOP_CALL
|
|
op
=
=
JSOP_CALLITER
|
|
op
=
=
JSOP_FUNCALL
|
|
op
=
=
JSOP_FUNAPPLY
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_STRICTEVAL
)
;
if
(
op
=
=
JSOP_CALLITER
&
&
callee
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
argc
=
=
0
"
thisv
must
be
on
top
of
the
stack
"
)
;
ReportValueError
(
cx
JSMSG_NOT_ITERABLE
-
1
thisv
nullptr
)
;
return
false
;
}
if
(
!
Invoke
(
cx
thisv
callee
argc
args
res
)
)
return
false
;
}
TypeScript
:
:
Monitor
(
cx
script
pc
res
)
;
if
(
stub
.
invalid
(
)
)
return
true
;
ICTypeMonitor_Fallback
*
typeMonFbStub
=
stub
-
>
fallbackMonitorStub
(
)
;
if
(
!
typeMonFbStub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
!
TryAttachStringSplit
(
cx
stub
script
argc
vp
pc
res
&
handled
)
)
return
false
;
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
static
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub_
Value
*
vp
MutableHandleValue
res
)
{
SharedStubInfo
info
(
cx
frame
stub_
-
>
icEntry
(
)
)
;
DebugModeOSRVolatileStub
<
ICCall_Fallback
*
>
stub
(
frame
stub_
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
bool
constructing
=
(
op
=
=
JSOP_SPREADNEW
)
;
FallbackICSpew
(
cx
stub
"
SpreadCall
(
%
s
)
"
CodeName
[
op
]
)
;
AutoArrayRooter
vpRoot
(
cx
3
+
constructing
vp
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
RootedValue
arr
(
cx
vp
[
2
]
)
;
RootedValue
newTarget
(
cx
constructing
?
vp
[
3
]
:
NullValue
(
)
)
;
bool
handled
=
false
;
if
(
op
!
=
JSOP_SPREADEVAL
&
&
op
!
=
JSOP_STRICTSPREADEVAL
&
&
!
TryAttachCallStub
(
cx
stub
script
pc
op
1
vp
constructing
true
false
&
handled
)
)
{
return
false
;
}
if
(
!
SpreadCallOperation
(
cx
script
pc
thisv
callee
arr
newTarget
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
ICTypeMonitor_Fallback
*
typeMonFbStub
=
stub
-
>
fallbackMonitorStub
(
)
;
if
(
!
typeMonFbStub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
{
return
false
;
}
if
(
!
stub
-
>
addMonitorStubForValue
(
cx
&
info
res
)
)
return
false
;
if
(
!
handled
)
stub
-
>
noteUnoptimizableCall
(
)
;
return
true
;
}
void
ICCallStubCompiler
:
:
pushCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
MOZ_ASSERT
(
!
regs
.
has
(
argcReg
)
)
;
Register
count
=
regs
.
takeAny
(
)
;
masm
.
move32
(
argcReg
count
)
;
if
(
isJitCall
)
{
if
(
isConstructing
)
masm
.
add32
(
Imm32
(
1
)
count
)
;
}
else
{
masm
.
add32
(
Imm32
(
2
+
isConstructing
)
count
)
;
}
Register
argPtr
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
argPtr
)
;
masm
.
addPtr
(
Imm32
(
STUB_FRAME_SIZE
)
argPtr
)
;
if
(
isJitCall
)
{
masm
.
alignJitStackBasedOnNArgs
(
count
)
;
masm
.
add32
(
Imm32
(
2
)
count
)
;
}
Label
loop
done
;
masm
.
bind
(
&
loop
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
count
count
&
done
)
;
{
masm
.
pushValue
(
Address
(
argPtr
0
)
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
argPtr
)
;
masm
.
sub32
(
Imm32
(
1
)
count
)
;
masm
.
jump
(
&
loop
)
;
}
masm
.
bind
(
&
done
)
;
}
void
ICCallStubCompiler
:
:
guardSpreadCall
(
MacroAssembler
&
masm
Register
argcReg
Label
*
failure
bool
isConstructing
)
{
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
isConstructing
*
sizeof
(
Value
)
+
ICStackValueOffset
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfLength
(
)
)
argcReg
)
;
static_assert
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
<
=
ARGS_LENGTH_MAX
"
maximum
arguments
length
for
optimized
stub
should
be
<
=
ARGS_LENGTH_MAX
"
)
;
masm
.
branch32
(
Assembler
:
:
Above
argcReg
Imm32
(
ICCall_Scripted
:
:
MAX_ARGS_SPREAD_LENGTH
)
failure
)
;
}
void
ICCallStubCompiler
:
:
pushSpreadCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isJitCall
bool
isConstructing
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
masm
.
unboxObject
(
Address
(
masm
.
getStackPointer
(
)
(
isConstructing
*
sizeof
(
Value
)
)
+
STUB_FRAME_SIZE
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
if
(
isJitCall
)
{
Register
alignReg
=
argcReg
;
if
(
isConstructing
)
{
alignReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
alignReg
)
;
masm
.
addPtr
(
Imm32
(
1
)
alignReg
)
;
}
masm
.
alignJitStackBasedOnNArgs
(
alignReg
)
;
if
(
isConstructing
)
{
MOZ_ASSERT
(
alignReg
!
=
argcReg
)
;
regs
.
add
(
alignReg
)
;
}
}
if
(
isConstructing
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
argcReg
endReg
)
;
static_assert
(
sizeof
(
Value
)
=
=
8
"
Value
must
be
8
bytes
"
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
regs
.
add
(
startReg
)
;
regs
.
add
(
endReg
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
1
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
(
2
+
isConstructing
)
*
sizeof
(
Value
)
)
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
=
=
1800
#
pragma
optimize
(
"
g
"
off
)
#
endif
Register
ICCallStubCompiler
:
:
guardFunApply
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
checkNative
FunApplyThing
applyThing
Label
*
failure
)
{
masm
.
branch32
(
Assembler
:
:
NotEqual
argcReg
Imm32
(
2
)
failure
)
;
Address
secondArgSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
if
(
applyThing
=
=
FunApply_MagicArgs
)
{
masm
.
branchTestMagic
(
Assembler
:
:
NotEqual
secondArgSlot
failure
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
BaselineFrameReg
BaselineFrame
:
:
reverseOffsetOfFlags
(
)
)
Imm32
(
BaselineFrame
:
:
HAS_ARGS_OBJ
)
failure
)
;
}
else
{
MOZ_ASSERT
(
applyThing
=
=
FunApply_Array
)
;
AllocatableGeneralRegisterSet
regsx
=
regs
;
ValueOperand
secondArgVal
=
regsx
.
takeAnyValue
(
)
;
masm
.
loadValue
(
secondArgSlot
secondArgVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
secondArgVal
failure
)
;
Register
secondArgObj
=
masm
.
extractObject
(
secondArgVal
ExtractTemp1
)
;
regsx
.
add
(
secondArgVal
)
;
regsx
.
takeUnchecked
(
secondArgObj
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
secondArgObj
regsx
.
getAny
(
)
&
ArrayObject
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
secondArgObj
NativeObject
:
:
offsetOfElements
(
)
)
secondArgObj
)
;
Register
lenReg
=
regsx
.
takeAny
(
)
;
masm
.
load32
(
Address
(
secondArgObj
ObjectElements
:
:
offsetOfLength
(
)
)
lenReg
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
secondArgObj
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
lenReg
failure
)
;
masm
.
branch32
(
Assembler
:
:
Above
lenReg
Imm32
(
ICCall_ScriptedApplyArray
:
:
MAX_ARGS_ARRAY_LENGTH
)
failure
)
;
JS_STATIC_ASSERT
(
sizeof
(
Value
)
=
=
8
)
;
masm
.
lshiftPtr
(
Imm32
(
3
)
lenReg
)
;
masm
.
addPtr
(
secondArgObj
lenReg
)
;
Register
start
=
secondArgObj
;
Register
end
=
lenReg
;
Label
loop
;
Label
endLoop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
AboveOrEqual
start
end
&
endLoop
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
Address
(
start
0
)
failure
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
start
)
;
masm
.
jump
(
&
loop
)
;
masm
.
bind
(
&
endLoop
)
;
}
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
Address
calleeSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
3
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
calleeSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
callee
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_apply
)
failure
)
;
Address
thisSlot
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
2
*
sizeof
(
Value
)
)
)
;
masm
.
loadValue
(
thisSlot
val
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
val
failure
)
;
Register
target
=
masm
.
extractObject
(
val
ExtractTemp1
)
;
regs
.
add
(
val
)
;
regs
.
takeUnchecked
(
target
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
target
regs
.
getAny
(
)
&
JSFunction
:
:
class_
failure
)
;
if
(
checkNative
)
{
masm
.
branchIfInterpreted
(
target
failure
)
;
}
else
{
masm
.
branchIfFunctionHasNoScript
(
target
failure
)
;
Register
temp
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
temp
)
;
masm
.
loadBaselineOrIonRaw
(
temp
temp
failure
)
;
regs
.
add
(
temp
)
;
}
return
target
;
}
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
=
=
1800
#
pragma
optimize
(
"
"
on
)
#
endif
void
ICCallStubCompiler
:
:
pushCallerArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
endReg
)
;
masm
.
addPtr
(
Imm32
(
BaselineFrame
:
:
offsetOfArg
(
0
)
)
startReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
void
ICCallStubCompiler
:
:
pushArrayArguments
(
MacroAssembler
&
masm
Address
arrayVal
AllocatableGeneralRegisterSet
regs
)
{
Register
startReg
=
regs
.
takeAny
(
)
;
Register
endReg
=
regs
.
takeAny
(
)
;
masm
.
extractObject
(
arrayVal
startReg
)
;
masm
.
loadPtr
(
Address
(
startReg
NativeObject
:
:
offsetOfElements
(
)
)
startReg
)
;
masm
.
load32
(
Address
(
startReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
endReg
)
;
masm
.
alignJitStackBasedOnNArgs
(
endReg
)
;
masm
.
lshiftPtr
(
Imm32
(
ValueShift
)
endReg
)
;
masm
.
addPtr
(
startReg
endReg
)
;
Label
copyDone
;
Label
copyStart
;
masm
.
bind
(
&
copyStart
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
endReg
startReg
&
copyDone
)
;
masm
.
subPtr
(
Imm32
(
sizeof
(
Value
)
)
endReg
)
;
masm
.
pushValue
(
Address
(
endReg
0
)
)
;
masm
.
jump
(
&
copyStart
)
;
masm
.
bind
(
&
copyDone
)
;
}
typedef
bool
(
*
DoCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
uint32_t
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoCallFallbackInfo
=
FunctionInfo
<
DoCallFallbackFn
>
(
DoCallFallback
)
;
typedef
bool
(
*
DoSpreadCallFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
Value
*
MutableHandleValue
)
;
static
const
VMFunction
DoSpreadCallFallbackInfo
=
FunctionInfo
<
DoSpreadCallFallbackFn
>
(
DoSpreadCallFallback
)
;
bool
ICCall_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
R0
=
=
JSReturnOperand
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
{
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
if
(
isConstructing_
)
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
uint32_t
valueOffset
=
isConstructing_
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
+
+
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoSpreadCallFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
regs
.
take
(
R0
.
scratchReg
(
)
)
;
pushCallArguments
(
masm
regs
R0
.
scratchReg
(
)
false
isConstructing_
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
if
(
!
callVM
(
DoCallFallbackInfo
masm
)
)
return
false
;
uint32_t
framePushed
=
masm
.
framePushed
(
)
;
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
returnOffset_
=
masm
.
currentOffset
(
)
;
inStubFrame_
=
true
;
masm
.
setFramePushed
(
framePushed
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
size_t
)
)
R1
)
;
leaveStubFrame
(
masm
true
)
;
if
(
isConstructing_
)
{
MOZ_ASSERT
(
JSReturnOperand
=
=
R0
)
;
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
moveValue
(
R1
R0
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Failed
to
return
object
in
constructing
call
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
void
ICCall_Fallback
:
:
Compiler
:
:
postGenerateStubCode
(
MacroAssembler
&
masm
Handle
<
JitCode
*
>
code
)
{
if
(
MOZ_UNLIKELY
(
isSpread_
)
)
return
;
cx
-
>
compartment
(
)
-
>
jitCompartment
(
)
-
>
initBaselineCallReturnAddr
(
code
-
>
raw
(
)
+
returnOffset_
isConstructing_
)
;
}
typedef
bool
(
*
CreateThisFn
)
(
JSContext
*
cx
HandleObject
callee
HandleObject
newTarget
MutableHandleValue
rval
)
;
static
const
VMFunction
CreateThisInfoBaseline
=
FunctionInfo
<
CreateThisFn
>
(
CreateThis
)
;
bool
ICCallScriptedCompiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
MOZ_ASSERT
(
argcReg
!
=
ArgumentsRectifierReg
)
;
regs
.
take
(
argcReg
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
unsigned
skipToCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipToCallee
+
ICStackValueOffset
)
R1
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSkip
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
if
(
callee_
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
Call_Scripted
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Scripted
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
}
else
{
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
if
(
isConstructing_
)
{
masm
.
branchIfNotInterpretedConstructor
(
callee
regs
.
getAny
(
)
&
failure
)
;
}
else
{
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
branchFunctionKind
(
Assembler
:
:
Equal
JSFunction
:
:
ClassConstructor
callee
regs
.
getAny
(
)
&
failure
)
;
}
}
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
Register
code
;
if
(
!
isConstructing_
)
{
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failure
)
;
}
else
{
Address
scriptCode
(
callee
JSScript
:
:
offsetOfBaselineOrIonRaw
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scriptCode
ImmPtr
(
nullptr
)
&
failure
)
;
}
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
failureLeaveStubFrame
;
if
(
isConstructing_
)
{
masm
.
push
(
argcReg
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
)
R1
)
;
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
isSpread_
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
R1
)
;
}
else
{
BaseValueIndex
calleeSlot2
(
masm
.
getStackPointer
(
)
argcReg
2
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
+
sizeof
(
size_t
)
+
sizeof
(
JSObject
*
)
)
;
masm
.
loadValue
(
calleeSlot2
R1
)
;
}
masm
.
push
(
masm
.
extractObject
(
R1
ExtractTemp0
)
)
;
if
(
!
callVM
(
CreateThisInfoBaseline
masm
)
)
return
false
;
#
ifdef
DEBUG
Label
createdThisOK
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
branchTestMagic
(
Assembler
:
:
Equal
JSReturnOperand
&
createdThisOK
)
;
masm
.
assumeUnreachable
(
"
The
return
of
CreateThis
must
be
an
object
or
uninitialized
.
"
)
;
masm
.
bind
(
&
createdThisOK
)
;
#
endif
MOZ_ASSERT
(
JSReturnOperand
=
=
R0
)
;
regs
=
availableGeneralRegs
(
0
)
;
regs
.
take
(
R0
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
argcReg
=
regs
.
takeAny
(
)
;
masm
.
pop
(
argcReg
)
;
if
(
isSpread_
)
{
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
}
else
{
BaseValueIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
STUB_FRAME_SIZE
+
isConstructing_
*
sizeof
(
Value
)
)
;
masm
.
storeValue
(
R0
thisSlot
)
;
}
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
STUB_FRAME_SAVED_STUB_OFFSET
)
ICStubReg
)
;
if
(
isSpread_
)
{
unsigned
skipForCallee
=
(
2
+
isConstructing_
)
*
sizeof
(
Value
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
skipForCallee
+
STUB_FRAME_SIZE
)
R0
)
;
}
else
{
unsigned
nonArgsSkip
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot3
(
masm
.
getStackPointer
(
)
argcReg
nonArgsSkip
+
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
calleeSlot3
R0
)
;
}
callee
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
regs
.
add
(
R0
)
;
regs
.
takeUnchecked
(
callee
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failureLeaveStubFrame
)
;
if
(
callee
!
=
ExtractTemp0
)
regs
.
add
(
callee
)
;
if
(
canUseTailCallReg
)
regs
.
addUnchecked
(
ICTailCallReg
)
;
}
Register
scratch
=
regs
.
takeAny
(
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
true
isConstructing_
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
PushCalleeToken
(
callee
isConstructing_
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
if
(
isConstructing_
)
{
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
Address
descriptorAddr
(
masm
.
getStackPointer
(
)
0
)
;
masm
.
loadPtr
(
descriptorAddr
BaselineFrameReg
)
;
masm
.
rshiftPtr
(
Imm32
(
FRAMESIZE_SHIFT
)
BaselineFrameReg
)
;
masm
.
addPtr
(
Imm32
(
(
3
-
2
)
*
sizeof
(
size_t
)
)
BaselineFrameReg
)
;
masm
.
addStackPtrTo
(
BaselineFrameReg
)
;
Register
argcReg
=
JSReturnOperand
.
scratchReg
(
)
;
if
(
isSpread_
)
{
masm
.
move32
(
Imm32
(
1
)
argcReg
)
;
}
else
{
Address
argcAddr
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
size_t
)
)
;
masm
.
loadPtr
(
argcAddr
argcReg
)
;
}
BaseValueIndex
thisSlotAddr
(
BaselineFrameReg
argcReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
thisSlotAddr
JSReturnOperand
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Return
of
constructing
call
should
be
an
object
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureLeaveStubFrame
)
;
inStubFrame_
=
true
;
leaveStubFrame
(
masm
false
)
;
if
(
argcReg
!
=
R0
.
scratchReg
(
)
)
masm
.
movePtr
(
argcReg
R0
.
scratchReg
(
)
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
typedef
bool
(
*
CopyArrayFn
)
(
JSContext
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
CopyArrayInfo
=
FunctionInfo
<
CopyArrayFn
>
(
CopyArray
)
;
bool
ICCall_StringSplit
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Label
failureRestoreArgc
;
#
ifdef
DEBUG
Label
oneArg
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
masm
.
branch32
(
Assembler
:
:
Equal
argcReg
Imm32
(
1
)
&
oneArg
)
;
masm
.
assumeUnreachable
(
"
Expected
argc
=
=
1
"
)
;
masm
.
bind
(
&
oneArg
)
;
#
endif
Register
scratchReg
=
regs
.
takeAny
(
)
;
{
Address
calleeAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
(
2
*
sizeof
(
Value
)
)
)
;
ValueOperand
calleeVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
calleeAddr
calleeVal
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
calleeVal
&
failureRestoreArgc
)
;
Register
calleeObj
=
masm
.
extractObject
(
calleeVal
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
calleeObj
scratchReg
&
JSFunction
:
:
class_
&
failureRestoreArgc
)
;
masm
.
loadPtr
(
Address
(
calleeObj
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
scratchReg
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
scratchReg
ImmPtr
(
js
:
:
str_split
)
&
failureRestoreArgc
)
;
regs
.
add
(
calleeVal
)
;
}
{
Address
argAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
ValueOperand
argVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
argAddr
argVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
argVal
&
failureRestoreArgc
)
;
Register
argString
=
masm
.
extractString
(
argVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedArg
(
)
)
argString
&
failureRestoreArgc
)
;
regs
.
add
(
argVal
)
;
}
{
Address
thisvAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
sizeof
(
Value
)
)
;
ValueOperand
thisvVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
thisvAddr
thisvVal
)
;
masm
.
branchTestString
(
Assembler
:
:
NotEqual
thisvVal
&
failureRestoreArgc
)
;
Register
thisvString
=
masm
.
extractString
(
thisvVal
ExtractTemp0
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
offsetOfExpectedThis
(
)
)
thisvString
&
failureRestoreArgc
)
;
regs
.
add
(
thisvVal
)
;
}
{
Register
paramReg
=
regs
.
takeAny
(
)
;
enterStubFrame
(
masm
scratchReg
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetOfTemplateObject
(
)
)
paramReg
)
;
masm
.
push
(
paramReg
)
;
if
(
!
callVM
(
CopyArrayInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
regs
.
add
(
paramReg
)
;
}
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreArgc
)
;
masm
.
move32
(
Imm32
(
1
)
R0
.
scratchReg
(
)
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_IsSuspendedStarGenerator
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Address
argAddr
(
masm
.
getStackPointer
(
)
ICStackValueOffset
)
;
ValueOperand
argVal
=
regs
.
takeAnyValue
(
)
;
masm
.
loadValue
(
argAddr
argVal
)
;
Label
returnFalse
;
Register
genObj
=
regs
.
takeAny
(
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxObject
(
argVal
genObj
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
genObj
scratch
&
StarGeneratorObject
:
:
class_
&
returnFalse
)
;
masm
.
loadValue
(
Address
(
genObj
GeneratorObject
:
:
offsetOfYieldIndexSlot
(
)
)
argVal
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
argVal
&
returnFalse
)
;
masm
.
unboxInt32
(
argVal
scratch
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
scratch
Imm32
(
StarGeneratorObject
:
:
YIELD_INDEX_CLOSING
)
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICCall_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
if
(
isSpread_
)
guardSpreadCall
(
masm
argcReg
&
failure
isConstructing_
)
;
if
(
isSpread_
)
{
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
ICStackValueOffset
+
2
*
sizeof
(
Value
)
)
R1
)
;
}
else
{
unsigned
nonArgsSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgsSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
}
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Address
expectedCallee
(
ICStubReg
ICCall_Native
:
:
offsetOfCallee
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedCallee
callee
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
isSpread_
)
pushSpreadCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
else
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
if
(
isConstructing_
)
{
masm
.
storeValue
(
MagicValue
(
JS_IS_CONSTRUCTING
)
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
}
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
enterFakeExitFrameForNative
(
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
#
ifdef
JS_SIMULATOR
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_Native
:
:
offsetOfNative
(
)
)
)
;
#
else
masm
.
callWithABI
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
)
;
#
endif
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ClassHook
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
unsigned
nonArgSlots
=
(
1
+
isConstructing_
)
*
sizeof
(
Value
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
nonArgSlots
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
loadObjClass
(
callee
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfClass
(
)
)
scratch
&
failure
)
;
regs
.
add
(
R1
)
;
regs
.
takeUnchecked
(
callee
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
regs
.
add
(
scratch
)
;
pushCallArguments
(
masm
regs
argcReg
false
isConstructing_
)
;
regs
.
take
(
scratch
)
;
if
(
isConstructing_
)
{
masm
.
storeValue
(
MagicValue
(
JS_IS_CONSTRUCTING
)
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
}
masm
.
checkStackAlignment
(
)
;
Register
vpReg
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
vpReg
)
;
masm
.
push
(
argcReg
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
ExitFrameLayout
:
:
Size
(
)
)
;
masm
.
push
(
scratch
)
;
masm
.
push
(
ICTailCallReg
)
;
masm
.
enterFakeExitFrameForNative
(
isConstructing_
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
passABIArg
(
scratch
)
;
masm
.
passABIArg
(
argcReg
)
;
masm
.
passABIArg
(
vpReg
)
;
masm
.
callWithABI
(
Address
(
ICStubReg
ICCall_ClassHook
:
:
offsetOfNative
(
)
)
)
;
masm
.
branchIfFalseBool
(
ReturnReg
masm
.
exceptionLabel
(
)
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
NativeExitFrameLayout
:
:
offsetOfResult
(
)
)
R0
)
;
leaveStubFrame
(
masm
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArray
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
regs
.
takeUnchecked
(
ArgumentsRectifierReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
false
FunApply_Array
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
Address
arrayVal
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
pushArrayArguments
(
masm
arrayVal
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
extractObject
(
arrayVal
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
NativeObject
:
:
offsetOfElements
(
)
)
argcReg
)
;
masm
.
load32
(
Address
(
argcReg
ObjectElements
:
:
offsetOfInitializedLength
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
target
)
;
masm
.
loadBaselineOrIonRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
target
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
target
)
;
masm
.
loadPtr
(
Address
(
target
JitCode
:
:
offsetOfCode
(
)
)
target
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedApplyArguments
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
regs
.
take
(
argcReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
regs
.
takeUnchecked
(
ArgumentsRectifierReg
)
;
Register
target
=
guardFunApply
(
masm
regs
argcReg
false
FunApply_MagicArgs
&
failure
)
;
if
(
regs
.
has
(
target
)
)
{
regs
.
take
(
target
)
;
}
else
{
Register
targetTemp
=
regs
.
takeAny
(
)
;
masm
.
movePtr
(
target
targetTemp
)
;
target
=
targetTemp
;
}
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
pushCallerArguments
(
masm
regs
)
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
+
sizeof
(
Value
)
)
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
argcReg
)
;
masm
.
loadPtr
(
Address
(
argcReg
BaselineFrame
:
:
offsetOfNumActualArgs
(
)
)
argcReg
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
target
)
;
masm
.
Push
(
scratch
)
;
masm
.
load16ZeroExtend
(
Address
(
target
JSFunction
:
:
offsetOfNargs
(
)
)
scratch
)
;
masm
.
loadPtr
(
Address
(
target
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
target
)
;
masm
.
loadBaselineOrIonRaw
(
target
target
nullptr
)
;
Label
noUnderflow
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
scratch
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
target
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
target
)
;
masm
.
loadPtr
(
Address
(
target
JitCode
:
:
offsetOfCode
(
)
)
target
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
regs
.
add
(
argcReg
)
;
masm
.
callJit
(
target
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICCall_ScriptedFunCall
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
bool
canUseTailCallReg
=
regs
.
has
(
ICTailCallReg
)
;
Register
argcReg
=
R0
.
scratchReg
(
)
;
MOZ_ASSERT
(
argcReg
!
=
ArgumentsRectifierReg
)
;
regs
.
take
(
argcReg
)
;
regs
.
take
(
ArgumentsRectifierReg
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
BaseValueIndex
calleeSlot
(
masm
.
getStackPointer
(
)
argcReg
ICStackValueOffset
+
sizeof
(
Value
)
)
;
masm
.
loadValue
(
calleeSlot
R1
)
;
regs
.
take
(
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
callee
ImmPtr
(
fun_call
)
&
failure
)
;
BaseIndex
thisSlot
(
masm
.
getStackPointer
(
)
argcReg
TimesEight
ICStackValueOffset
)
;
masm
.
loadValue
(
thisSlot
R1
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
callee
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
callee
regs
.
getAny
(
)
&
JSFunction
:
:
class_
&
failure
)
;
masm
.
branchIfFunctionHasNoScript
(
callee
&
failure
)
;
masm
.
loadPtr
(
Address
(
callee
JSFunction
:
:
offsetOfNativeOrScript
(
)
)
callee
)
;
Register
code
=
regs
.
takeAny
(
)
;
masm
.
loadBaselineOrIonRaw
(
callee
code
&
failure
)
;
regs
.
add
(
R1
)
;
enterStubFrame
(
masm
regs
.
getAny
(
)
)
;
if
(
canUseTailCallReg
)
regs
.
add
(
ICTailCallReg
)
;
Label
zeroArgs
done
;
masm
.
branchTest32
(
Assembler
:
:
Zero
argcReg
argcReg
&
zeroArgs
)
;
masm
.
sub32
(
Imm32
(
1
)
argcReg
)
;
pushCallArguments
(
masm
regs
argcReg
true
)
;
ValueOperand
val
=
regs
.
takeAnyValue
(
)
;
masm
.
popValue
(
val
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
zeroArgs
)
;
Address
thisSlotFromStubFrame
(
BaselineFrameReg
STUB_FRAME_SIZE
)
;
masm
.
loadValue
(
thisSlotFromStubFrame
val
)
;
masm
.
alignJitStackBasedOnNArgs
(
0
)
;
masm
.
pushValue
(
UndefinedValue
(
)
)
;
masm
.
bind
(
&
done
)
;
callee
=
masm
.
extractObject
(
val
ExtractTemp0
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
EmitBaselineCreateStubFrameDescriptor
(
masm
scratch
JitFrameLayout
:
:
Size
(
)
)
;
masm
.
Push
(
argcReg
)
;
masm
.
Push
(
callee
)
;
masm
.
Push
(
scratch
)
;
Label
noUnderflow
;
masm
.
load16ZeroExtend
(
Address
(
callee
JSFunction
:
:
offsetOfNargs
(
)
)
callee
)
;
masm
.
branch32
(
Assembler
:
:
AboveOrEqual
argcReg
callee
&
noUnderflow
)
;
{
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
code
)
;
MOZ_ASSERT
(
ArgumentsRectifierReg
!
=
argcReg
)
;
JitCode
*
argumentsRectifier
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
;
masm
.
movePtr
(
ImmGCPtr
(
argumentsRectifier
)
code
)
;
masm
.
loadPtr
(
Address
(
code
JitCode
:
:
offsetOfCode
(
)
)
code
)
;
masm
.
movePtr
(
argcReg
ArgumentsRectifierReg
)
;
}
masm
.
bind
(
&
noUnderflow
)
;
masm
.
callJit
(
code
)
;
leaveStubFrame
(
masm
true
)
;
EmitEnterTypeMonitorIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoubleValueToInt32ForSwitch
(
Value
*
v
)
{
double
d
=
v
-
>
toDouble
(
)
;
int32_t
truncated
=
int32_t
(
d
)
;
if
(
d
!
=
double
(
truncated
)
)
return
false
;
v
-
>
setInt32
(
truncated
)
;
return
true
;
}
bool
ICTableSwitch
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
isInt32
notInt32
outOfRange
;
Register
scratch
=
R1
.
scratchReg
(
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
R0
&
notInt32
)
;
Register
key
=
masm
.
extractInt32
(
R0
ExtractTemp0
)
;
masm
.
bind
(
&
isInt32
)
;
masm
.
load32
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
min_
)
)
scratch
)
;
masm
.
sub32
(
scratch
key
)
;
masm
.
branch32
(
Assembler
:
:
BelowOrEqual
Address
(
ICStubReg
offsetof
(
ICTableSwitch
length_
)
)
key
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
table_
)
)
scratch
)
;
masm
.
loadPtr
(
BaseIndex
(
scratch
key
ScalePointer
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
notInt32
)
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
R0
&
outOfRange
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitSupportsFloatingPoint
)
{
masm
.
unboxDouble
(
R0
FloatReg0
)
;
masm
.
convertDoubleToInt32
(
FloatReg0
key
&
outOfRange
false
)
;
}
else
{
masm
.
pushValue
(
R0
)
;
masm
.
moveStackPtrTo
(
R0
.
scratchReg
(
)
)
;
masm
.
setupUnalignedABICall
(
scratch
)
;
masm
.
passABIArg
(
R0
.
scratchReg
(
)
)
;
masm
.
callWithABI
(
JS_FUNC_TO_DATA_PTR
(
void
*
DoubleValueToInt32ForSwitch
)
)
;
masm
.
movePtr
(
ReturnReg
scratch
)
;
masm
.
popValue
(
R0
)
;
masm
.
branchIfFalseBool
(
scratch
&
outOfRange
)
;
masm
.
unboxInt32
(
R0
key
)
;
}
masm
.
jump
(
&
isInt32
)
;
masm
.
bind
(
&
outOfRange
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
offsetof
(
ICTableSwitch
defaultTarget_
)
)
scratch
)
;
EmitChangeICReturnAddress
(
masm
scratch
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
ICStub
*
ICTableSwitch
:
:
Compiler
:
:
getStub
(
ICStubSpace
*
space
)
{
JitCode
*
code
=
getStubCode
(
)
;
if
(
!
code
)
return
nullptr
;
jsbytecode
*
pc
=
pc_
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc
)
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc
)
;
int32_t
length
=
high
-
low
+
1
;
pc
+
=
JUMP_OFFSET_LEN
;
void
*
*
table
=
(
void
*
*
)
space
-
>
alloc
(
sizeof
(
void
*
)
*
length
)
;
if
(
!
table
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
jsbytecode
*
defaultpc
=
pc_
+
GET_JUMP_OFFSET
(
pc_
)
;
for
(
int32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
int32_t
off
=
GET_JUMP_OFFSET
(
pc
)
;
if
(
off
)
table
[
i
]
=
pc_
+
off
;
else
table
[
i
]
=
defaultpc
;
pc
+
=
JUMP_OFFSET_LEN
;
}
return
newStub
<
ICTableSwitch
>
(
space
code
table
low
length
defaultpc
)
;
}
void
ICTableSwitch
:
:
fixupJumpTable
(
JSScript
*
script
BaselineScript
*
baseline
)
{
defaultTarget_
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
defaultTarget_
)
;
for
(
int32_t
i
=
0
;
i
<
length_
;
i
+
+
)
table_
[
i
]
=
baseline
-
>
nativeCodeForPC
(
script
(
jsbytecode
*
)
table_
[
i
]
)
;
}
static
bool
DoIteratorNewFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIteratorNew_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
{
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
FallbackICSpew
(
cx
stub
"
IteratorNew
"
)
;
uint8_t
flags
=
GET_UINT8
(
pc
)
;
res
.
set
(
value
)
;
return
ValueToIterator
(
cx
flags
res
)
;
}
typedef
bool
(
*
DoIteratorNewFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIteratorNew_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoIteratorNewFallbackInfo
=
FunctionInfo
<
DoIteratorNewFallbackFn
>
(
DoIteratorNewFallback
TailCall
PopValues
(
1
)
)
;
bool
ICIteratorNew_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoIteratorNewFallbackInfo
masm
)
;
}
static
bool
DoIteratorMoreFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIteratorMore_Fallback
*
stub_
HandleObject
iterObj
MutableHandleValue
res
)
{
DebugModeOSRVolatileStub
<
ICIteratorMore_Fallback
*
>
stub
(
frame
stub_
)
;
FallbackICSpew
(
cx
stub
"
IteratorMore
"
)
;
if
(
!
IteratorMore
(
cx
iterObj
res
)
)
return
false
;
if
(
stub
.
invalid
(
)
)
return
true
;
if
(
!
res
.
isMagic
(
JS_NO_ITER_VALUE
)
&
&
!
res
.
isString
(
)
)
stub
-
>
setHasNonStringResult
(
)
;
if
(
iterObj
-
>
is
<
PropertyIteratorObject
>
(
)
&
&
!
stub
-
>
hasStub
(
ICStub
:
:
IteratorMore_Native
)
)
{
ICIteratorMore_Native
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
}
return
true
;
}
typedef
bool
(
*
DoIteratorMoreFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICIteratorMore_Fallback
*
HandleObject
MutableHandleValue
)
;
static
const
VMFunction
DoIteratorMoreFallbackInfo
=
FunctionInfo
<
DoIteratorMoreFallbackFn
>
(
DoIteratorMoreFallback
TailCall
)
;
bool
ICIteratorMore_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
unboxObject
(
R0
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoIteratorMoreFallbackInfo
masm
)
;
}
bool
ICIteratorMore_Native
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
Register
nativeIterator
=
regs
.
takeAny
(
)
;
Register
scratch
=
regs
.
takeAny
(
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
NotEqual
obj
scratch
&
PropertyIteratorObject
:
:
class_
&
failure
)
;
masm
.
loadObjPrivate
(
obj
JSObject
:
:
ITER_CLASS_NFIXED_SLOTS
nativeIterator
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
Address
(
nativeIterator
offsetof
(
NativeIterator
flags
)
)
Imm32
(
JSITER_FOREACH
)
&
failure
)
;
Label
iterDone
;
Address
cursorAddr
(
nativeIterator
offsetof
(
NativeIterator
props_cursor
)
)
;
Address
cursorEndAddr
(
nativeIterator
offsetof
(
NativeIterator
props_end
)
)
;
masm
.
loadPtr
(
cursorAddr
scratch
)
;
masm
.
branchPtr
(
Assembler
:
:
BelowOrEqual
cursorEndAddr
scratch
&
iterDone
)
;
masm
.
loadPtr
(
Address
(
scratch
0
)
scratch
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
JSString
*
)
)
cursorAddr
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
scratch
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
iterDone
)
;
masm
.
moveValue
(
MagicValue
(
JS_NO_ITER_VALUE
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoIteratorCloseFallback
(
JSContext
*
cx
ICIteratorClose_Fallback
*
stub
HandleValue
iterValue
)
{
FallbackICSpew
(
cx
stub
"
IteratorClose
"
)
;
RootedObject
iteratorObject
(
cx
&
iterValue
.
toObject
(
)
)
;
return
CloseIterator
(
cx
iteratorObject
)
;
}
typedef
bool
(
*
DoIteratorCloseFallbackFn
)
(
JSContext
*
ICIteratorClose_Fallback
*
HandleValue
)
;
static
const
VMFunction
DoIteratorCloseFallbackInfo
=
FunctionInfo
<
DoIteratorCloseFallbackFn
>
(
DoIteratorCloseFallback
TailCall
)
;
bool
ICIteratorClose_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
return
tailCallVM
(
DoIteratorCloseFallbackInfo
masm
)
;
}
static
bool
TryAttachInstanceOfStub
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleFunction
fun
bool
*
attached
)
{
MOZ_ASSERT
(
!
*
attached
)
;
if
(
fun
-
>
isBoundFunction
(
)
)
return
true
;
Shape
*
shape
=
fun
-
>
lookupPure
(
cx
-
>
names
(
)
.
prototype
)
;
if
(
!
shape
|
|
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
true
;
uint32_t
slot
=
shape
-
>
slot
(
)
;
MOZ_ASSERT
(
fun
-
>
numFixedSlots
(
)
=
=
0
"
Stub
code
relies
on
this
"
)
;
if
(
!
fun
-
>
getSlot
(
slot
)
.
isObject
(
)
)
return
true
;
JSObject
*
protoObject
=
&
fun
-
>
getSlot
(
slot
)
.
toObject
(
)
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
InstanceOf
(
Function
)
stub
"
)
;
ICInstanceOf_Function
:
:
Compiler
compiler
(
cx
fun
-
>
lastProperty
(
)
protoObject
slot
)
;
ICStub
*
newStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
newStub
)
return
false
;
stub
-
>
addNewStub
(
newStub
)
;
*
attached
=
true
;
return
true
;
}
static
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
InstanceOf
"
)
;
if
(
!
rhs
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_BAD_INSTANCEOF_RHS
-
1
rhs
nullptr
)
;
return
false
;
}
RootedObject
obj
(
cx
&
rhs
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
HasInstance
(
cx
obj
lhs
&
cond
)
)
return
false
;
res
.
setBoolean
(
cond
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
EnsureTrackPropertyTypes
(
cx
obj
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICInstanceOf_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
bool
attached
=
false
;
if
(
!
TryAttachInstanceOfStub
(
cx
frame
stub
fun
&
attached
)
)
return
false
;
if
(
!
attached
)
stub
-
>
noteUnoptimizableAccess
(
)
;
return
true
;
}
typedef
bool
(
*
DoInstanceOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICInstanceOf_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoInstanceOfFallbackInfo
=
FunctionInfo
<
DoInstanceOfFallbackFn
>
(
DoInstanceOfFallback
TailCall
PopValues
(
2
)
)
;
bool
ICInstanceOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoInstanceOfFallbackInfo
masm
)
;
}
bool
ICInstanceOf_Function
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R1
&
failure
)
;
Register
rhsObj
=
masm
.
extractObject
(
R1
ExtractTemp0
)
;
Label
failureRestoreR1
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
1
)
)
;
regs
.
takeUnchecked
(
rhsObj
)
;
Register
scratch1
=
regs
.
takeAny
(
)
;
Register
scratch2
=
regs
.
takeAny
(
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfShape
(
)
)
scratch1
)
;
masm
.
branchTestObjShape
(
Assembler
:
:
NotEqual
rhsObj
scratch1
&
failureRestoreR1
)
;
masm
.
loadPtr
(
Address
(
rhsObj
NativeObject
:
:
offsetOfSlots
(
)
)
scratch1
)
;
masm
.
load32
(
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfSlot
(
)
)
scratch2
)
;
BaseValueIndex
prototypeSlot
(
scratch1
scratch2
)
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
prototypeSlot
&
failureRestoreR1
)
;
masm
.
unboxObject
(
prototypeSlot
scratch1
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICInstanceOf_Function
:
:
offsetOfPrototypeObject
(
)
)
scratch1
&
failureRestoreR1
)
;
Label
returnFalse
returnTrue
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
returnFalse
)
;
masm
.
unboxObject
(
R0
scratch2
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
{
Label
loop
;
masm
.
bind
(
&
loop
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
scratch1
&
returnTrue
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch2
scratch2
&
returnFalse
)
;
MOZ_ASSERT
(
uintptr_t
(
TaggedProto
:
:
LazyProto
)
=
=
1
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
scratch2
ImmWord
(
1
)
&
failureRestoreR1
)
;
masm
.
loadObjProto
(
scratch2
scratch2
)
;
masm
.
jump
(
&
loop
)
;
}
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnFalse
)
;
masm
.
moveValue
(
BooleanValue
(
false
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
returnTrue
)
;
masm
.
moveValue
(
BooleanValue
(
true
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failureRestoreR1
)
;
masm
.
tagValue
(
JSVAL_TYPE_OBJECT
rhsObj
R1
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeOf_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
{
FallbackICSpew
(
cx
stub
"
TypeOf
"
)
;
JSType
type
=
js
:
:
TypeOfValue
(
val
)
;
RootedString
string
(
cx
TypeName
(
type
cx
-
>
names
(
)
)
)
;
res
.
setString
(
string
)
;
MOZ_ASSERT
(
type
!
=
JSTYPE_NULL
)
;
if
(
type
!
=
JSTYPE_OBJECT
&
&
type
!
=
JSTYPE_FUNCTION
)
{
JitSpew
(
JitSpew_BaselineIC
"
Generating
TypeOf
stub
for
JSType
(
%
d
)
"
(
int
)
type
)
;
ICTypeOf_Typed
:
:
Compiler
compiler
(
cx
type
string
)
;
ICStub
*
typeOfStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
typeOfStub
)
return
false
;
stub
-
>
addNewStub
(
typeOfStub
)
;
}
return
true
;
}
typedef
bool
(
*
DoTypeOfFallbackFn
)
(
JSContext
*
BaselineFrame
*
frame
ICTypeOf_Fallback
*
HandleValue
MutableHandleValue
)
;
static
const
VMFunction
DoTypeOfFallbackInfo
=
FunctionInfo
<
DoTypeOfFallbackFn
>
(
DoTypeOfFallback
TailCall
)
;
bool
ICTypeOf_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoTypeOfFallbackInfo
masm
)
;
}
bool
ICTypeOf_Typed
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_NULL
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_FUNCTION
)
;
MOZ_ASSERT
(
type_
!
=
JSTYPE_OBJECT
)
;
Label
failure
;
switch
(
type_
)
{
case
JSTYPE_VOID
:
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_STRING
:
masm
.
branchTestString
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_NUMBER
:
masm
.
branchTestNumber
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_BOOLEAN
:
masm
.
branchTestBoolean
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
case
JSTYPE_SYMBOL
:
masm
.
branchTestSymbol
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
type
"
)
;
}
masm
.
movePtr
(
ImmGCPtr
(
typeString_
)
R0
.
scratchReg
(
)
)
;
masm
.
tagValue
(
JSVAL_TYPE_STRING
R0
.
scratchReg
(
)
R0
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
static
bool
DoRetSubFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRetSub_Fallback
*
stub
HandleValue
val
uint8_t
*
*
resumeAddr
)
{
FallbackICSpew
(
cx
stub
"
RetSub
"
)
;
MOZ_ASSERT
(
val
.
isInt32
(
)
)
;
MOZ_ASSERT
(
val
.
toInt32
(
)
>
=
0
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
uint32_t
offset
=
uint32_t
(
val
.
toInt32
(
)
)
;
*
resumeAddr
=
script
-
>
baselineScript
(
)
-
>
nativeCodeForPC
(
script
script
-
>
offsetToPC
(
offset
)
)
;
if
(
stub
-
>
numOptimizedStubs
(
)
>
=
ICRetSub_Fallback
:
:
MAX_OPTIMIZED_STUBS
)
return
true
;
JitSpew
(
JitSpew_BaselineIC
"
Generating
RetSub
stub
for
pc
offset
%
u
"
offset
)
;
ICRetSub_Resume
:
:
Compiler
compiler
(
cx
offset
*
resumeAddr
)
;
ICStub
*
optStub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
script
)
)
;
if
(
!
optStub
)
return
false
;
stub
-
>
addNewStub
(
optStub
)
;
return
true
;
}
typedef
bool
(
*
DoRetSubFallbackFn
)
(
JSContext
*
cx
BaselineFrame
*
ICRetSub_Fallback
*
HandleValue
uint8_t
*
*
)
;
static
const
VMFunction
DoRetSubFallbackInfo
=
FunctionInfo
<
DoRetSubFallbackFn
>
(
DoRetSubFallback
)
;
typedef
bool
(
*
ThrowFn
)
(
JSContext
*
HandleValue
)
;
static
const
VMFunction
ThrowInfoBaseline
=
FunctionInfo
<
ThrowFn
>
(
js
:
:
Throw
TailCall
)
;
bool
ICRetSub_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
{
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
regs
.
take
(
R1
)
;
regs
.
takeUnchecked
(
ICTailCallReg
)
;
Register
scratch
=
regs
.
getAny
(
)
;
enterStubFrame
(
masm
scratch
)
;
masm
.
pushValue
(
R1
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
scratch
)
;
if
(
!
callVM
(
DoRetSubFallbackInfo
masm
)
)
return
false
;
leaveStubFrame
(
masm
)
;
EmitChangeICReturnAddress
(
masm
ReturnReg
)
;
EmitReturnFromIC
(
masm
)
;
}
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
return
tailCallVM
(
ThrowInfoBaseline
masm
)
;
}
bool
ICRetSub_Resume
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
Label
fail
rethrow
;
masm
.
branchTestBooleanTruthy
(
true
R0
&
rethrow
)
;
Register
offset
=
masm
.
extractInt32
(
R1
ExtractTemp0
)
;
masm
.
branch32
(
Assembler
:
:
NotEqual
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfPCOffset
(
)
)
offset
&
fail
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICRetSub_Resume
:
:
offsetOfAddr
(
)
)
R0
.
scratchReg
(
)
)
;
EmitChangeICReturnAddress
(
masm
R0
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
rethrow
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
if
(
!
tailCallVM
(
ThrowInfoBaseline
masm
)
)
return
false
;
masm
.
bind
(
&
fail
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
ICTypeMonitor_SingleObject
:
:
ICTypeMonitor_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeMonitor_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeMonitor_ObjectGroup
:
:
ICTypeMonitor_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeMonitor_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICTypeUpdate_SingleObject
:
:
ICTypeUpdate_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeUpdate_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeUpdate_ObjectGroup
:
:
ICTypeUpdate_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeUpdate_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICGetElemNativeStub
:
:
ICGetElemNativeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
AccessType
acctype
bool
needsAtomize
bool
isSymbol
)
:
ICMonitoredStub
(
kind
stubCode
firstMonitorStub
)
receiverGuard_
(
guard
)
{
extra_
=
(
static_cast
<
uint16_t
>
(
acctype
)
<
<
ACCESSTYPE_SHIFT
)
|
(
static_cast
<
uint16_t
>
(
needsAtomize
)
<
<
NEEDS_ATOMIZE_SHIFT
)
|
(
static_cast
<
uint16_t
>
(
isSymbol
)
<
<
ISSYMBOL_SHIFT
)
;
}
ICGetElemNativeStub
:
:
~
ICGetElemNativeStub
(
)
{
}
template
<
class
T
>
ICGetElemNativeGetterStub
<
T
>
:
:
ICGetElemNativeGetterStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
const
T
*
key
AccType
acctype
bool
needsAtomize
JSFunction
*
getter
uint32_t
pcOffset
)
:
ICGetElemNativeStubImpl
<
T
>
(
kind
stubCode
firstMonitorStub
guard
key
acctype
needsAtomize
)
getter_
(
getter
)
pcOffset_
(
pcOffset
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallNativeSymbol
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedName
|
|
kind
=
=
ICStub
:
:
GetElem_NativePrototypeCallScriptedSymbol
)
;
MOZ_ASSERT
(
acctype
=
=
ICGetElemNativeStub
:
:
NativeGetter
|
|
acctype
=
=
ICGetElemNativeStub
:
:
ScriptedGetter
)
;
}
template
<
class
T
>
ICGetElem_NativePrototypeSlot
<
T
>
:
:
ICGetElem_NativePrototypeSlot
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
const
T
*
key
AccType
acctype
bool
needsAtomize
uint32_t
offset
JSObject
*
holder
Shape
*
holderShape
)
:
ICGetElemNativeSlotStub
<
T
>
(
getGetElemStubKind
<
T
>
(
ICStub
:
:
GetElem_NativePrototypeSlotName
)
stubCode
firstMonitorStub
guard
key
acctype
needsAtomize
offset
)
holder_
(
holder
)
holderShape_
(
holderShape
)
{
}
template
<
class
T
>
ICGetElemNativePrototypeCallStub
<
T
>
:
:
ICGetElemNativePrototypeCallStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
const
T
*
key
AccType
acctype
bool
needsAtomize
JSFunction
*
getter
uint32_t
pcOffset
JSObject
*
holder
Shape
*
holderShape
)
:
ICGetElemNativeGetterStub
<
T
>
(
kind
stubCode
firstMonitorStub
guard
key
acctype
needsAtomize
getter
pcOffset
)
holder_
(
holder
)
holderShape_
(
holderShape
)
{
}
template
<
class
T
>
ICGetElem_NativePrototypeCallNative
<
T
>
*
ICGetElem_NativePrototypeCallNative
<
T
>
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetElem_NativePrototypeCallNative
<
T
>
&
other
)
{
return
ICStub
:
:
New
<
ICGetElem_NativePrototypeCallNative
<
T
>
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
receiverGuard
(
)
&
other
.
key
(
)
.
get
(
)
other
.
accessType
(
)
other
.
needsAtomize
(
)
other
.
getter
(
)
other
.
pcOffset_
other
.
holder
(
)
other
.
holderShape
(
)
)
;
}
template
ICGetElem_NativePrototypeCallNative
<
JS
:
:
Symbol
*
>
*
ICGetElem_NativePrototypeCallNative
<
JS
:
:
Symbol
*
>
:
:
Clone
(
JSContext
*
ICStubSpace
*
ICStub
*
ICGetElem_NativePrototypeCallNative
<
JS
:
:
Symbol
*
>
&
)
;
template
ICGetElem_NativePrototypeCallNative
<
js
:
:
PropertyName
*
>
*
ICGetElem_NativePrototypeCallNative
<
js
:
:
PropertyName
*
>
:
:
Clone
(
JSContext
*
ICStubSpace
*
ICStub
*
ICGetElem_NativePrototypeCallNative
<
js
:
:
PropertyName
*
>
&
)
;
template
<
class
T
>
ICGetElem_NativePrototypeCallScripted
<
T
>
*
ICGetElem_NativePrototypeCallScripted
<
T
>
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetElem_NativePrototypeCallScripted
<
T
>
&
other
)
{
return
ICStub
:
:
New
<
ICGetElem_NativePrototypeCallScripted
<
T
>
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
receiverGuard
(
)
&
other
.
key
(
)
.
get
(
)
other
.
accessType
(
)
other
.
needsAtomize
(
)
other
.
getter
(
)
other
.
pcOffset_
other
.
holder
(
)
other
.
holderShape
(
)
)
;
}
template
ICGetElem_NativePrototypeCallScripted
<
JS
:
:
Symbol
*
>
*
ICGetElem_NativePrototypeCallScripted
<
JS
:
:
Symbol
*
>
:
:
Clone
(
JSContext
*
ICStubSpace
*
ICStub
*
ICGetElem_NativePrototypeCallScripted
<
JS
:
:
Symbol
*
>
&
)
;
template
ICGetElem_NativePrototypeCallScripted
<
js
:
:
PropertyName
*
>
*
ICGetElem_NativePrototypeCallScripted
<
js
:
:
PropertyName
*
>
:
:
Clone
(
JSContext
*
ICStubSpace
*
ICStub
*
ICGetElem_NativePrototypeCallScripted
<
js
:
:
PropertyName
*
>
&
)
;
ICGetElem_Dense
:
:
ICGetElem_Dense
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Shape
*
shape
)
:
ICMonitoredStub
(
GetElem_Dense
stubCode
firstMonitorStub
)
shape_
(
shape
)
{
}
ICGetElem_Dense
*
ICGetElem_Dense
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetElem_Dense
&
other
)
{
return
New
<
ICGetElem_Dense
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
shape_
)
;
}
ICGetElem_UnboxedArray
:
:
ICGetElem_UnboxedArray
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ObjectGroup
*
group
)
:
ICMonitoredStub
(
GetElem_UnboxedArray
stubCode
firstMonitorStub
)
group_
(
group
)
{
}
ICGetElem_UnboxedArray
*
ICGetElem_UnboxedArray
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetElem_UnboxedArray
&
other
)
{
return
New
<
ICGetElem_UnboxedArray
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
group_
)
;
}
ICGetElem_TypedArray
:
:
ICGetElem_TypedArray
(
JitCode
*
stubCode
Shape
*
shape
Scalar
:
:
Type
type
)
:
ICStub
(
GetElem_TypedArray
stubCode
)
shape_
(
shape
)
{
extra_
=
uint16_t
(
type
)
;
MOZ_ASSERT
(
extra_
=
=
type
)
;
}
ICGetElem_Arguments
*
ICGetElem_Arguments
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetElem_Arguments
&
other
)
{
return
New
<
ICGetElem_Arguments
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
which
(
)
)
;
}
ICSetElem_DenseOrUnboxedArray
:
:
ICSetElem_DenseOrUnboxedArray
(
JitCode
*
stubCode
Shape
*
shape
ObjectGroup
*
group
)
:
ICUpdatedStub
(
SetElem_DenseOrUnboxedArray
stubCode
)
shape_
(
shape
)
group_
(
group
)
{
}
ICSetElem_DenseOrUnboxedArrayAdd
:
:
ICSetElem_DenseOrUnboxedArrayAdd
(
JitCode
*
stubCode
ObjectGroup
*
group
size_t
protoChainDepth
)
:
ICUpdatedStub
(
SetElem_DenseOrUnboxedArrayAdd
stubCode
)
group_
(
group
)
{
MOZ_ASSERT
(
protoChainDepth
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
extra_
=
protoChainDepth
;
}
template
<
size_t
ProtoChainDepth
>
ICUpdatedStub
*
ICSetElemDenseOrUnboxedArrayAddCompiler
:
:
getStubSpecific
(
ICStubSpace
*
space
Handle
<
ShapeVector
>
shapes
)
{
RootedObjectGroup
group
(
cx
obj_
-
>
getGroup
(
cx
)
)
;
if
(
!
group
)
return
nullptr
;
Rooted
<
JitCode
*
>
stubCode
(
cx
getStubCode
(
)
)
;
return
newStub
<
ICSetElem_DenseOrUnboxedArrayAddImpl
<
ProtoChainDepth
>
>
(
space
stubCode
group
shapes
)
;
}
ICSetElem_TypedArray
:
:
ICSetElem_TypedArray
(
JitCode
*
stubCode
Shape
*
shape
Scalar
:
:
Type
type
bool
expectOutOfBounds
)
:
ICStub
(
SetElem_TypedArray
stubCode
)
shape_
(
shape
)
{
extra_
=
uint8_t
(
type
)
;
MOZ_ASSERT
(
extra_
=
=
type
)
;
extra_
|
=
(
static_cast
<
uint16_t
>
(
expectOutOfBounds
)
<
<
8
)
;
}
ICInNativeStub
:
:
ICInNativeStub
(
ICStub
:
:
Kind
kind
JitCode
*
stubCode
HandleShape
shape
HandlePropertyName
name
)
:
ICStub
(
kind
stubCode
)
shape_
(
shape
)
name_
(
name
)
{
}
ICIn_NativePrototype
:
:
ICIn_NativePrototype
(
JitCode
*
stubCode
HandleShape
shape
HandlePropertyName
name
HandleObject
holder
HandleShape
holderShape
)
:
ICInNativeStub
(
In_NativePrototype
stubCode
shape
name
)
holder_
(
holder
)
holderShape_
(
holderShape
)
{
}
ICIn_NativeDoesNotExist
:
:
ICIn_NativeDoesNotExist
(
JitCode
*
stubCode
size_t
protoChainDepth
HandlePropertyName
name
)
:
ICStub
(
In_NativeDoesNotExist
stubCode
)
name_
(
name
)
{
MOZ_ASSERT
(
protoChainDepth
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
extra_
=
protoChainDepth
;
}
size_t
ICIn_NativeDoesNotExist
:
:
offsetOfShape
(
size_t
idx
)
{
MOZ_ASSERT
(
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
idx
)
=
=
ICIn_NativeDoesNotExistImpl
<
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
>
:
:
offsetOfShape
(
idx
)
)
;
return
ICIn_NativeDoesNotExistImpl
<
0
>
:
:
offsetOfShape
(
idx
)
;
}
template
<
size_t
ProtoChainDepth
>
ICIn_NativeDoesNotExistImpl
<
ProtoChainDepth
>
:
:
ICIn_NativeDoesNotExistImpl
(
JitCode
*
stubCode
Handle
<
ShapeVector
>
shapes
HandlePropertyName
name
)
:
ICIn_NativeDoesNotExist
(
stubCode
ProtoChainDepth
name
)
{
MOZ_ASSERT
(
shapes
.
length
(
)
=
=
NumShapes
)
;
for
(
size_t
i
=
0
;
i
<
NumShapes
;
i
+
+
)
shapes_
[
i
]
.
init
(
shapes
[
i
]
)
;
}
ICInNativeDoesNotExistCompiler
:
:
ICInNativeDoesNotExistCompiler
(
JSContext
*
cx
HandleObject
obj
HandlePropertyName
name
size_t
protoChainDepth
)
:
ICStubCompiler
(
cx
ICStub
:
:
In_NativeDoesNotExist
Engine
:
:
Baseline
)
obj_
(
cx
obj
)
name_
(
cx
name
)
protoChainDepth_
(
protoChainDepth
)
{
MOZ_ASSERT
(
protoChainDepth_
<
=
ICIn_NativeDoesNotExist
:
:
MAX_PROTO_CHAIN_DEPTH
)
;
}
ICIn_Dense
:
:
ICIn_Dense
(
JitCode
*
stubCode
HandleShape
shape
)
:
ICStub
(
In_Dense
stubCode
)
shape_
(
shape
)
{
}
ICGetName_GlobalLexical
:
:
ICGetName_GlobalLexical
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
uint32_t
slot
)
:
ICMonitoredStub
(
GetName_GlobalLexical
stubCode
firstMonitorStub
)
slot_
(
slot
)
{
}
template
<
size_t
NumHops
>
ICGetName_Scope
<
NumHops
>
:
:
ICGetName_Scope
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
Handle
<
ShapeVector
>
shapes
uint32_t
offset
)
:
ICMonitoredStub
(
GetStubKind
(
)
stubCode
firstMonitorStub
)
offset_
(
offset
)
{
JS_STATIC_ASSERT
(
NumHops
<
=
MAX_HOPS
)
;
MOZ_ASSERT
(
shapes
.
length
(
)
=
=
NumHops
+
1
)
;
for
(
size_t
i
=
0
;
i
<
NumHops
+
1
;
i
+
+
)
shapes_
[
i
]
.
init
(
shapes
[
i
]
)
;
}
ICGetIntrinsic_Constant
:
:
ICGetIntrinsic_Constant
(
JitCode
*
stubCode
const
Value
&
value
)
:
ICStub
(
GetIntrinsic_Constant
stubCode
)
value_
(
value
)
{
}
ICGetIntrinsic_Constant
:
:
~
ICGetIntrinsic_Constant
(
)
{
}
ICGetName_Global
:
:
ICGetName_Global
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
ReceiverGuard
guard
uint32_t
offset
JSObject
*
holder
Shape
*
holderShape
Shape
*
globalShape
)
:
ICGetPropNativePrototypeStub
(
GetName_Global
stubCode
firstMonitorStub
guard
offset
holder
holderShape
)
globalShape_
(
globalShape
)
{
}
ICGetName_Global
*
ICGetName_Global
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICGetName_Global
&
other
)
{
return
New
<
ICGetName_Global
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
receiverGuard
(
)
other
.
offset
(
)
other
.
holder
(
)
other
.
holderShape
(
)
other
.
globalShape
(
)
)
;
}
ICInstanceOf_Function
:
:
ICInstanceOf_Function
(
JitCode
*
stubCode
Shape
*
shape
JSObject
*
prototypeObj
uint32_t
slot
)
:
ICStub
(
InstanceOf_Function
stubCode
)
shape_
(
shape
)
prototypeObj_
(
prototypeObj
)
slot_
(
slot
)
{
}
ICSetProp_Native
:
:
ICSetProp_Native
(
JitCode
*
stubCode
ObjectGroup
*
group
Shape
*
shape
uint32_t
offset
)
:
ICUpdatedStub
(
SetProp_Native
stubCode
)
group_
(
group
)
shape_
(
shape
)
offset_
(
offset
)
{
}
ICSetProp_Native
*
ICSetProp_Native
:
:
Compiler
:
:
getStub
(
ICStubSpace
*
space
)
{
RootedObjectGroup
group
(
cx
obj_
-
>
getGroup
(
cx
)
)
;
if
(
!
group
)
return
nullptr
;
RootedShape
shape
(
cx
LastPropertyForSetProp
(
obj_
)
)
;
ICSetProp_Native
*
stub
=
newStub
<
ICSetProp_Native
>
(
space
getStubCode
(
)
group
shape
offset_
)
;
if
(
!
stub
|
|
!
stub
-
>
initUpdatingChain
(
cx
space
)
)
return
nullptr
;
return
stub
;
}
ICSetProp_NativeAdd
:
:
ICSetProp_NativeAdd
(
JitCode
*
stubCode
ObjectGroup
*
group
size_t
protoChainDepth
Shape
*
newShape
ObjectGroup
*
newGroup
uint32_t
offset
)
:
ICUpdatedStub
(
SetProp_NativeAdd
stubCode
)
group_
(
group
)
newShape_
(
newShape
)
newGroup_
(
newGroup
)
offset_
(
offset
)
{
MOZ_ASSERT
(
protoChainDepth
<
=
MAX_PROTO_CHAIN_DEPTH
)
;
extra_
=
protoChainDepth
;
}
template
<
size_t
ProtoChainDepth
>
ICSetProp_NativeAddImpl
<
ProtoChainDepth
>
:
:
ICSetProp_NativeAddImpl
(
JitCode
*
stubCode
ObjectGroup
*
group
Handle
<
ShapeVector
>
shapes
Shape
*
newShape
ObjectGroup
*
newGroup
uint32_t
offset
)
:
ICSetProp_NativeAdd
(
stubCode
group
ProtoChainDepth
newShape
newGroup
offset
)
{
MOZ_ASSERT
(
shapes
.
length
(
)
=
=
NumShapes
)
;
for
(
size_t
i
=
0
;
i
<
NumShapes
;
i
+
+
)
shapes_
[
i
]
.
init
(
shapes
[
i
]
)
;
}
ICSetPropNativeAddCompiler
:
:
ICSetPropNativeAddCompiler
(
JSContext
*
cx
HandleObject
obj
HandleShape
oldShape
HandleObjectGroup
oldGroup
size_t
protoChainDepth
bool
isFixedSlot
uint32_t
offset
)
:
ICStubCompiler
(
cx
ICStub
:
:
SetProp_NativeAdd
Engine
:
:
Baseline
)
obj_
(
cx
obj
)
oldShape_
(
cx
oldShape
)
oldGroup_
(
cx
oldGroup
)
protoChainDepth_
(
protoChainDepth
)
isFixedSlot_
(
isFixedSlot
)
offset_
(
offset
)
{
MOZ_ASSERT
(
protoChainDepth_
<
=
ICSetProp_NativeAdd
:
:
MAX_PROTO_CHAIN_DEPTH
)
;
}
ICSetPropCallSetter
:
:
ICSetPropCallSetter
(
Kind
kind
JitCode
*
stubCode
ReceiverGuard
receiverGuard
JSObject
*
holder
Shape
*
holderShape
JSFunction
*
setter
uint32_t
pcOffset
)
:
ICStub
(
kind
stubCode
)
receiverGuard_
(
receiverGuard
)
holder_
(
holder
)
holderShape_
(
holderShape
)
setter_
(
setter
)
pcOffset_
(
pcOffset
)
{
MOZ_ASSERT
(
kind
=
=
ICStub
:
:
SetProp_CallScripted
|
|
kind
=
=
ICStub
:
:
SetProp_CallNative
)
;
}
ICSetProp_CallScripted
*
ICSetProp_CallScripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
ICSetProp_CallScripted
&
other
)
{
return
New
<
ICSetProp_CallScripted
>
(
cx
space
other
.
jitCode
(
)
other
.
receiverGuard
(
)
other
.
holder_
other
.
holderShape_
other
.
setter_
other
.
pcOffset_
)
;
}
ICSetProp_CallNative
*
ICSetProp_CallNative
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
ICSetProp_CallNative
&
other
)
{
return
New
<
ICSetProp_CallNative
>
(
cx
space
other
.
jitCode
(
)
other
.
receiverGuard
(
)
other
.
holder_
other
.
holderShape_
other
.
setter_
other
.
pcOffset_
)
;
}
ICCall_Scripted
:
:
ICCall_Scripted
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Scripted
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
}
ICCall_Scripted
*
ICCall_Scripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Scripted
&
other
)
{
return
New
<
ICCall_Scripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_AnyScripted
*
ICCall_AnyScripted
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_AnyScripted
&
other
)
{
return
New
<
ICCall_AnyScripted
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_Native
:
:
ICCall_Native
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
JSFunction
*
callee
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_Native
stubCode
firstMonitorStub
)
callee_
(
callee
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
JS_FUNC_TO_DATA_PTR
(
void
*
callee
-
>
native
(
)
)
Args_General3
)
;
#
endif
}
ICCall_Native
*
ICCall_Native
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_Native
&
other
)
{
return
New
<
ICCall_Native
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
callee_
other
.
templateObject_
other
.
pcOffset_
)
;
}
ICCall_ClassHook
:
:
ICCall_ClassHook
(
JitCode
*
stubCode
ICStub
*
firstMonitorStub
const
Class
*
clasp
Native
native
JSObject
*
templateObject
uint32_t
pcOffset
)
:
ICMonitoredStub
(
ICStub
:
:
Call_ClassHook
stubCode
firstMonitorStub
)
clasp_
(
clasp
)
native_
(
JS_FUNC_TO_DATA_PTR
(
void
*
native
)
)
templateObject_
(
templateObject
)
pcOffset_
(
pcOffset
)
{
#
ifdef
JS_SIMULATOR
native_
=
Simulator
:
:
RedirectNativeFunction
(
native_
Args_General3
)
;
#
endif
}
ICCall_ClassHook
*
ICCall_ClassHook
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ClassHook
&
other
)
{
ICCall_ClassHook
*
res
=
New
<
ICCall_ClassHook
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
clasp
(
)
nullptr
other
.
templateObject_
other
.
pcOffset_
)
;
if
(
res
)
res
-
>
native_
=
other
.
native
(
)
;
return
res
;
}
ICCall_ScriptedApplyArray
*
ICCall_ScriptedApplyArray
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArray
&
other
)
{
return
New
<
ICCall_ScriptedApplyArray
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedApplyArguments
*
ICCall_ScriptedApplyArguments
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedApplyArguments
&
other
)
{
return
New
<
ICCall_ScriptedApplyArguments
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
ICCall_ScriptedFunCall
*
ICCall_ScriptedFunCall
:
:
Clone
(
JSContext
*
cx
ICStubSpace
*
space
ICStub
*
firstMonitorStub
ICCall_ScriptedFunCall
&
other
)
{
return
New
<
ICCall_ScriptedFunCall
>
(
cx
space
other
.
jitCode
(
)
firstMonitorStub
other
.
pcOffset_
)
;
}
static
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRest_Fallback
*
stub
MutableHandleValue
res
)
{
unsigned
numFormals
=
frame
-
>
numFormalArgs
(
)
-
1
;
unsigned
numActuals
=
frame
-
>
numActualArgs
(
)
;
unsigned
numRest
=
numActuals
>
numFormals
?
numActuals
-
numFormals
:
0
;
Value
*
rest
=
frame
-
>
argv
(
)
+
numFormals
;
JSObject
*
obj
=
ObjectGroup
:
:
newArrayObject
(
cx
rest
numRest
GenericObject
ObjectGroup
:
:
NewArrayKind
:
:
UnknownIndex
)
;
if
(
!
obj
)
return
false
;
res
.
setObject
(
*
obj
)
;
return
true
;
}
typedef
bool
(
*
DoRestFallbackFn
)
(
JSContext
*
BaselineFrame
*
ICRest_Fallback
*
MutableHandleValue
)
;
static
const
VMFunction
DoRestFallbackInfo
=
FunctionInfo
<
DoRestFallbackFn
>
(
DoRestFallback
TailCall
)
;
bool
ICRest_Fallback
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
MOZ_ASSERT
(
engine_
=
=
Engine
:
:
Baseline
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
return
tailCallVM
(
DoRestFallbackInfo
masm
)
;
}
}
}
