#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jslibmath
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
BaselineCacheIRCompiler
.
h
"
#
include
"
jit
/
BaselineDebugModeOSR
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Linker
.
h
"
#
include
"
jit
/
Lowering
.
h
"
#
ifdef
JS_ION_PERF
#
include
"
jit
/
PerfSpewer
.
h
"
#
endif
#
include
"
jit
/
SharedICHelpers
.
h
"
#
include
"
jit
/
VMFunctions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
ifdef
MOZ_VTUNE
#
include
"
vtune
/
VTuneWrapper
.
h
"
#
endif
#
include
"
builtin
/
Boolean
-
inl
.
h
"
#
include
"
jit
/
JitFrames
-
inl
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
jit
/
shared
/
Lowering
-
shared
-
inl
.
h
"
#
include
"
jit
/
SharedICHelpers
-
inl
.
h
"
#
include
"
jit
/
VMFunctionList
-
inl
.
h
"
#
include
"
vm
/
BytecodeIterator
-
inl
.
h
"
#
include
"
vm
/
BytecodeLocation
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
StringObject
-
inl
.
h
"
using
mozilla
:
:
DebugOnly
;
namespace
js
{
namespace
jit
{
class
MOZ_RAII
FallbackICCodeCompiler
final
:
public
ICStubCompilerBase
{
BaselineICFallbackCode
&
code
;
MacroAssembler
&
masm
;
MOZ_MUST_USE
bool
emitCall
(
bool
isSpread
bool
isConstructing
)
;
MOZ_MUST_USE
bool
emitGetElem
(
bool
hasReceiver
)
;
MOZ_MUST_USE
bool
emitGetProp
(
bool
hasReceiver
)
;
public
:
FallbackICCodeCompiler
(
JSContext
*
cx
BaselineICFallbackCode
&
code
MacroAssembler
&
masm
)
:
ICStubCompilerBase
(
cx
)
code
(
code
)
masm
(
masm
)
{
}
#
define
DEF_METHOD
(
kind
)
MOZ_MUST_USE
bool
emit_
#
#
kind
(
)
;
IC_BASELINE_FALLBACK_CODE_KIND_LIST
(
DEF_METHOD
)
#
undef
DEF_METHOD
}
;
#
ifdef
JS_JITSPEW
void
FallbackICSpew
(
JSContext
*
cx
ICFallbackStub
*
stub
const
char
*
fmt
.
.
.
)
{
if
(
JitSpewEnabled
(
JitSpew_BaselineICFallback
)
)
{
RootedScript
script
(
cx
GetTopJitJSScript
(
cx
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
char
fmtbuf
[
100
]
;
va_list
args
;
va_start
(
args
fmt
)
;
(
void
)
VsprintfLiteral
(
fmtbuf
fmt
args
)
;
va_end
(
args
)
;
JitSpew
(
JitSpew_BaselineICFallback
"
Fallback
hit
for
(
%
s
:
%
u
:
%
u
)
(
pc
=
%
zu
line
=
%
u
uses
=
%
u
stubs
=
%
zu
)
:
%
s
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
script
-
>
column
(
)
script
-
>
pcToOffset
(
pc
)
PCToLineNumber
(
script
pc
)
script
-
>
getWarmUpCount
(
)
stub
-
>
numOptimizedStubs
(
)
fmtbuf
)
;
}
}
void
TypeFallbackICSpew
(
JSContext
*
cx
ICTypeMonitor_Fallback
*
stub
const
char
*
fmt
.
.
.
)
{
if
(
JitSpewEnabled
(
JitSpew_BaselineICFallback
)
)
{
RootedScript
script
(
cx
GetTopJitJSScript
(
cx
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
char
fmtbuf
[
100
]
;
va_list
args
;
va_start
(
args
fmt
)
;
(
void
)
VsprintfLiteral
(
fmtbuf
fmt
args
)
;
va_end
(
args
)
;
JitSpew
(
JitSpew_BaselineICFallback
"
Type
monitor
fallback
hit
for
(
%
s
:
%
u
:
%
u
)
"
"
(
pc
=
%
zu
line
=
%
u
uses
=
%
u
stubs
=
%
d
)
:
%
s
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
script
-
>
column
(
)
script
-
>
pcToOffset
(
pc
)
PCToLineNumber
(
script
pc
)
script
-
>
getWarmUpCount
(
)
(
int
)
stub
-
>
numOptimizedMonitorStubs
(
)
fmtbuf
)
;
}
}
#
endif
ICFallbackStub
*
ICEntry
:
:
fallbackStub
(
)
const
{
return
firstStub
(
)
-
>
getChainFallback
(
)
;
}
void
ICEntry
:
:
trace
(
JSTracer
*
trc
)
{
#
ifdef
JS_64BIT
MOZ_DIAGNOSTIC_ASSERT
(
traceMagic_
=
=
EXPECTED_TRACE_MAGIC
)
;
#
endif
for
(
ICStub
*
stub
=
firstStub
(
)
;
stub
;
stub
=
stub
-
>
next
(
)
)
{
stub
-
>
trace
(
trc
)
;
}
}
class
MOZ_RAII
FallbackStubAllocator
{
JSContext
*
cx_
;
ICStubSpace
&
stubSpace_
;
const
BaselineICFallbackCode
&
code_
;
public
:
FallbackStubAllocator
(
JSContext
*
cx
ICStubSpace
&
stubSpace
)
:
cx_
(
cx
)
stubSpace_
(
stubSpace
)
code_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
baselineICFallbackCode
(
)
)
{
}
template
<
typename
T
typename
.
.
.
Args
>
T
*
newStub
(
BaselineICFallbackKind
kind
Args
&
&
.
.
.
args
)
{
TrampolinePtr
addr
=
code_
.
addr
(
kind
)
;
return
ICStub
:
:
NewFallback
<
T
>
(
cx_
&
stubSpace_
addr
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
static
bool
AddICImpl
(
JSContext
*
cx
JitScript
*
jitScript
uint32_t
offset
ICStub
*
stub
uint32_t
&
icEntryIndex
)
{
if
(
!
stub
)
{
MOZ_ASSERT
(
cx
-
>
isExceptionPending
(
)
)
;
mozilla
:
:
Unused
<
<
cx
;
return
false
;
}
ICEntry
&
entryRef
=
jitScript
-
>
icEntry
(
icEntryIndex
)
;
icEntryIndex
+
+
;
new
(
&
entryRef
)
ICEntry
(
stub
offset
)
;
if
(
stub
-
>
isFallback
(
)
)
{
stub
-
>
toFallbackStub
(
)
-
>
fixupICEntry
(
&
entryRef
)
;
}
else
{
stub
-
>
toTypeMonitor_Fallback
(
)
-
>
fixupICEntry
(
&
entryRef
)
;
}
return
true
;
}
bool
JitScript
:
:
initICEntriesAndBytecodeTypeMap
(
JSContext
*
cx
JSScript
*
script
)
{
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
jitRealm
(
)
)
;
MOZ_ASSERT
(
jit
:
:
IsBaselineInterpreterEnabled
(
)
)
;
MOZ_ASSERT
(
numICEntries
(
)
=
=
script
-
>
numICEntries
(
)
)
;
FallbackStubAllocator
alloc
(
cx
fallbackStubSpace_
)
;
uint32_t
icEntryIndex
=
0
;
using
Kind
=
BaselineICFallbackKind
;
auto
addIC
=
[
cx
this
script
&
icEntryIndex
]
(
BytecodeLocation
loc
ICStub
*
stub
)
{
uint32_t
offset
=
loc
.
bytecodeToOffset
(
script
)
;
return
AddICImpl
(
cx
this
offset
stub
icEntryIndex
)
;
}
;
auto
addPrologueIC
=
[
cx
this
&
icEntryIndex
]
(
ICStub
*
stub
)
{
return
AddICImpl
(
cx
this
ICEntry
:
:
ProloguePCOffset
stub
icEntryIndex
)
;
}
;
if
(
IsTypeInferenceEnabled
(
)
)
{
if
(
JSFunction
*
fun
=
script
-
>
function
(
)
)
{
ICStub
*
stub
=
alloc
.
newStub
<
ICTypeMonitor_Fallback
>
(
Kind
:
:
TypeMonitor
nullptr
0
)
;
if
(
!
addPrologueIC
(
stub
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
fun
-
>
nargs
(
)
;
i
+
+
)
{
ICStub
*
stub
=
alloc
.
newStub
<
ICTypeMonitor_Fallback
>
(
Kind
:
:
TypeMonitor
nullptr
i
+
1
)
;
if
(
!
addPrologueIC
(
stub
)
)
{
return
false
;
}
}
}
}
uint32_t
typeMapIndex
=
0
;
uint32_t
*
const
typeMap
=
IsTypeInferenceEnabled
(
)
?
bytecodeTypeMap
(
)
:
nullptr
;
for
(
BytecodeLocation
loc
:
js
:
:
AllBytecodesIterable
(
script
)
)
{
JSOp
op
=
loc
.
getOp
(
)
;
if
(
BytecodeOpHasTypeSet
(
op
)
&
&
typeMap
&
&
typeMapIndex
<
JSScript
:
:
MaxBytecodeTypeSets
)
{
typeMap
[
typeMapIndex
]
=
loc
.
bytecodeToOffset
(
script
)
;
typeMapIndex
+
+
;
}
MOZ_ASSERT_IF
(
BytecodeIsJumpTarget
(
op
)
loc
.
icIndex
(
)
=
=
icEntryIndex
)
;
if
(
!
BytecodeOpHasIC
(
op
)
)
{
continue
;
}
switch
(
op
)
{
case
JSOp
:
:
Not
:
case
JSOp
:
:
And
:
case
JSOp
:
:
Or
:
case
JSOp
:
:
IfEq
:
case
JSOp
:
:
IfNe
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICToBool_Fallback
>
(
Kind
:
:
ToBool
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
BitNot
:
case
JSOp
:
:
Pos
:
case
JSOp
:
:
Neg
:
case
JSOp
:
:
Inc
:
case
JSOp
:
:
Dec
:
case
JSOp
:
:
ToNumeric
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICUnaryArith_Fallback
>
(
Kind
:
:
UnaryArith
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
BitOr
:
case
JSOp
:
:
BitXor
:
case
JSOp
:
:
BitAnd
:
case
JSOp
:
:
Lsh
:
case
JSOp
:
:
Rsh
:
case
JSOp
:
:
Ursh
:
case
JSOp
:
:
Add
:
case
JSOp
:
:
Sub
:
case
JSOp
:
:
Mul
:
case
JSOp
:
:
Div
:
case
JSOp
:
:
Mod
:
case
JSOp
:
:
Pow
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICBinaryArith_Fallback
>
(
Kind
:
:
BinaryArith
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Eq
:
case
JSOp
:
:
Ne
:
case
JSOp
:
:
Lt
:
case
JSOp
:
:
Le
:
case
JSOp
:
:
Gt
:
case
JSOp
:
:
Ge
:
case
JSOp
:
:
StrictEq
:
case
JSOp
:
:
StrictNe
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICCompare_Fallback
>
(
Kind
:
:
Compare
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
NewArray
:
{
ObjectGroup
*
group
=
ObjectGroup
:
:
allocationSiteGroup
(
cx
script
loc
.
toRawBytecode
(
)
JSProto_Array
)
;
if
(
!
group
)
{
return
false
;
}
ICStub
*
stub
=
alloc
.
newStub
<
ICNewArray_Fallback
>
(
Kind
:
:
NewArray
group
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
NewObject
:
case
JSOp
:
:
NewObjectWithGroup
:
case
JSOp
:
:
NewInit
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICNewObject_Fallback
>
(
Kind
:
:
NewObject
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
InitElem
:
case
JSOp
:
:
InitHiddenElem
:
case
JSOp
:
:
InitElemArray
:
case
JSOp
:
:
InitElemInc
:
case
JSOp
:
:
SetElem
:
case
JSOp
:
:
StrictSetElem
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICSetElem_Fallback
>
(
Kind
:
:
SetElem
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
InitProp
:
case
JSOp
:
:
InitLockedProp
:
case
JSOp
:
:
InitHiddenProp
:
case
JSOp
:
:
InitGLexical
:
case
JSOp
:
:
SetProp
:
case
JSOp
:
:
StrictSetProp
:
case
JSOp
:
:
SetName
:
case
JSOp
:
:
StrictSetName
:
case
JSOp
:
:
SetGName
:
case
JSOp
:
:
StrictSetGName
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICSetProp_Fallback
>
(
Kind
:
:
SetProp
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetProp
:
case
JSOp
:
:
CallProp
:
case
JSOp
:
:
Length
:
case
JSOp
:
:
GetBoundName
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetProp_Fallback
>
(
Kind
:
:
GetProp
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetPropSuper
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetProp_Fallback
>
(
Kind
:
:
GetPropSuper
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetElem
:
case
JSOp
:
:
CallElem
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetElem_Fallback
>
(
Kind
:
:
GetElem
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetElemSuper
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetElem_Fallback
>
(
Kind
:
:
GetElemSuper
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
In
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICIn_Fallback
>
(
Kind
:
:
In
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
HasOwn
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICHasOwn_Fallback
>
(
Kind
:
:
HasOwn
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetName
:
case
JSOp
:
:
GetGName
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetName_Fallback
>
(
Kind
:
:
GetName
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
BindName
:
case
JSOp
:
:
BindGName
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICBindName_Fallback
>
(
Kind
:
:
BindName
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetAliasedVar
:
case
JSOp
:
:
GetImport
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICTypeMonitor_Fallback
>
(
Kind
:
:
TypeMonitor
nullptr
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
GetIntrinsic
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetIntrinsic_Fallback
>
(
Kind
:
:
GetIntrinsic
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Call
:
case
JSOp
:
:
CallIgnoresRv
:
case
JSOp
:
:
CallIter
:
case
JSOp
:
:
FunCall
:
case
JSOp
:
:
FunApply
:
case
JSOp
:
:
Eval
:
case
JSOp
:
:
StrictEval
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICCall_Fallback
>
(
Kind
:
:
Call
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
SuperCall
:
case
JSOp
:
:
New
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICCall_Fallback
>
(
Kind
:
:
CallConstructing
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
SpreadCall
:
case
JSOp
:
:
SpreadEval
:
case
JSOp
:
:
StrictSpreadEval
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICCall_Fallback
>
(
Kind
:
:
SpreadCall
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
SpreadSuperCall
:
case
JSOp
:
:
SpreadNew
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICCall_Fallback
>
(
Kind
:
:
SpreadCallConstructing
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Instanceof
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICInstanceOf_Fallback
>
(
Kind
:
:
InstanceOf
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Typeof
:
case
JSOp
:
:
TypeofExpr
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICTypeOf_Fallback
>
(
Kind
:
:
TypeOf
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Iter
:
{
ICStub
*
stub
=
alloc
.
newStub
<
ICGetIterator_Fallback
>
(
Kind
:
:
GetIterator
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Rest
:
{
ArrayObject
*
templateObject
=
ObjectGroup
:
:
newArrayObject
(
cx
nullptr
0
TenuredObject
ObjectGroup
:
:
NewArrayKind
:
:
UnknownIndex
)
;
if
(
!
templateObject
)
{
return
false
;
}
ICStub
*
stub
=
alloc
.
newStub
<
ICRest_Fallback
>
(
Kind
:
:
Rest
templateObject
)
;
if
(
!
addIC
(
loc
stub
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_CRASH
(
"
JOF_IC
op
not
handled
"
)
;
}
}
MOZ_ASSERT
(
icEntryIndex
=
=
numICEntries
(
)
)
;
MOZ_ASSERT_IF
(
IsTypeInferenceEnabled
(
)
typeMapIndex
=
=
script
-
>
numBytecodeTypeSets
(
)
)
;
return
true
;
}
ICStubConstIterator
&
ICStubConstIterator
:
:
operator
+
+
(
)
{
MOZ_ASSERT
(
currentStub_
!
=
nullptr
)
;
currentStub_
=
currentStub_
-
>
next
(
)
;
return
*
this
;
}
ICStubIterator
:
:
ICStubIterator
(
ICFallbackStub
*
fallbackStub
bool
end
)
:
icEntry_
(
fallbackStub
-
>
icEntry
(
)
)
fallbackStub_
(
fallbackStub
)
previousStub_
(
nullptr
)
currentStub_
(
end
?
fallbackStub
:
icEntry_
-
>
firstStub
(
)
)
unlinked_
(
false
)
{
}
ICStubIterator
&
ICStubIterator
:
:
operator
+
+
(
)
{
MOZ_ASSERT
(
currentStub_
-
>
next
(
)
!
=
nullptr
)
;
if
(
!
unlinked_
)
{
previousStub_
=
currentStub_
;
}
currentStub_
=
currentStub_
-
>
next
(
)
;
unlinked_
=
false
;
return
*
this
;
}
void
ICStubIterator
:
:
unlink
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
currentStub_
-
>
next
(
)
!
=
nullptr
)
;
MOZ_ASSERT
(
currentStub_
!
=
fallbackStub_
)
;
MOZ_ASSERT
(
!
unlinked_
)
;
fallbackStub_
-
>
unlinkStub
(
cx
-
>
zone
(
)
previousStub_
currentStub_
)
;
unlinked_
=
true
;
}
bool
ICStub
:
:
NonCacheIRStubMakesGCCalls
(
Kind
kind
)
{
MOZ_ASSERT
(
IsValidKind
(
kind
)
)
;
MOZ_ASSERT
(
!
IsCacheIRKind
(
kind
)
)
;
switch
(
kind
)
{
case
Call_Fallback
:
case
GetProp_Fallback
:
case
SetProp_Fallback
:
case
GetElem_Fallback
:
return
true
;
default
:
return
false
;
}
}
bool
ICStub
:
:
makesGCCalls
(
)
const
{
switch
(
kind
(
)
)
{
case
CacheIR_Regular
:
return
toCacheIR_Regular
(
)
-
>
stubInfo
(
)
-
>
makesGCCalls
(
)
;
case
CacheIR_Monitored
:
return
toCacheIR_Monitored
(
)
-
>
stubInfo
(
)
-
>
makesGCCalls
(
)
;
case
CacheIR_Updated
:
return
toCacheIR_Updated
(
)
-
>
stubInfo
(
)
-
>
makesGCCalls
(
)
;
default
:
return
NonCacheIRStubMakesGCCalls
(
kind
(
)
)
;
}
}
void
ICStub
:
:
updateCode
(
JitCode
*
code
)
{
JitCode
:
:
writeBarrierPre
(
jitCode
(
)
)
;
stubCode_
=
code
-
>
raw
(
)
;
}
void
ICStub
:
:
trace
(
JSTracer
*
trc
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
checkTraceMagic
(
)
;
#
endif
if
(
!
usesTrampolineCode
(
)
)
{
JitCode
*
stubJitCode
=
jitCode
(
)
;
TraceManuallyBarrieredEdge
(
trc
&
stubJitCode
"
baseline
-
ic
-
stub
-
code
"
)
;
}
if
(
isMonitoredFallback
(
)
)
{
ICTypeMonitor_Fallback
*
lastMonStub
=
toMonitoredFallbackStub
(
)
-
>
maybeFallbackMonitorStub
(
)
;
if
(
lastMonStub
)
{
for
(
ICStubConstIterator
iter
(
lastMonStub
-
>
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
next
(
)
=
=
nullptr
*
iter
=
=
lastMonStub
)
;
iter
-
>
trace
(
trc
)
;
}
}
}
if
(
isUpdated
(
)
)
{
for
(
ICStubConstIterator
iter
(
toUpdatedStub
(
)
-
>
firstUpdateStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
next
(
)
=
=
nullptr
iter
-
>
isTypeUpdate_Fallback
(
)
)
;
iter
-
>
trace
(
trc
)
;
}
}
switch
(
kind
(
)
)
{
case
ICStub
:
:
TypeMonitor_SingleObject
:
{
ICTypeMonitor_SingleObject
*
monitorStub
=
toTypeMonitor_SingleObject
(
)
;
TraceEdge
(
trc
&
monitorStub
-
>
object
(
)
"
baseline
-
monitor
-
singleton
"
)
;
break
;
}
case
ICStub
:
:
TypeMonitor_ObjectGroup
:
{
ICTypeMonitor_ObjectGroup
*
monitorStub
=
toTypeMonitor_ObjectGroup
(
)
;
TraceEdge
(
trc
&
monitorStub
-
>
group
(
)
"
baseline
-
monitor
-
group
"
)
;
break
;
}
case
ICStub
:
:
TypeUpdate_SingleObject
:
{
ICTypeUpdate_SingleObject
*
updateStub
=
toTypeUpdate_SingleObject
(
)
;
TraceEdge
(
trc
&
updateStub
-
>
object
(
)
"
baseline
-
update
-
singleton
"
)
;
break
;
}
case
ICStub
:
:
TypeUpdate_ObjectGroup
:
{
ICTypeUpdate_ObjectGroup
*
updateStub
=
toTypeUpdate_ObjectGroup
(
)
;
TraceEdge
(
trc
&
updateStub
-
>
group
(
)
"
baseline
-
update
-
group
"
)
;
break
;
}
case
ICStub
:
:
NewArray_Fallback
:
{
ICNewArray_Fallback
*
stub
=
toNewArray_Fallback
(
)
;
TraceNullableEdge
(
trc
&
stub
-
>
templateObject
(
)
"
baseline
-
newarray
-
template
"
)
;
TraceEdge
(
trc
&
stub
-
>
templateGroup
(
)
"
baseline
-
newarray
-
template
-
group
"
)
;
break
;
}
case
ICStub
:
:
NewObject_Fallback
:
{
ICNewObject_Fallback
*
stub
=
toNewObject_Fallback
(
)
;
TraceNullableEdge
(
trc
&
stub
-
>
templateObject
(
)
"
baseline
-
newobject
-
template
"
)
;
break
;
}
case
ICStub
:
:
Rest_Fallback
:
{
ICRest_Fallback
*
stub
=
toRest_Fallback
(
)
;
TraceEdge
(
trc
&
stub
-
>
templateObject
(
)
"
baseline
-
rest
-
template
"
)
;
break
;
}
case
ICStub
:
:
CacheIR_Regular
:
TraceCacheIRStub
(
trc
this
toCacheIR_Regular
(
)
-
>
stubInfo
(
)
)
;
break
;
case
ICStub
:
:
CacheIR_Monitored
:
TraceCacheIRStub
(
trc
this
toCacheIR_Monitored
(
)
-
>
stubInfo
(
)
)
;
break
;
case
ICStub
:
:
CacheIR_Updated
:
{
ICCacheIR_Updated
*
stub
=
toCacheIR_Updated
(
)
;
TraceNullableEdge
(
trc
&
stub
-
>
updateStubGroup
(
)
"
baseline
-
update
-
stub
-
group
"
)
;
TraceEdge
(
trc
&
stub
-
>
updateStubId
(
)
"
baseline
-
update
-
stub
-
id
"
)
;
TraceCacheIRStub
(
trc
this
stub
-
>
stubInfo
(
)
)
;
break
;
}
default
:
break
;
}
}
template
<
typename
IRGenerator
typename
.
.
.
Args
>
static
void
TryAttachStub
(
const
char
*
name
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
BaselineCacheIRStubKind
kind
Args
&
&
.
.
.
args
)
{
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
bool
attached
=
false
;
IRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
kind
script
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
%
s
CacheIR
stub
"
name
)
;
}
}
break
;
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
expected
in
generic
TryAttachStub
"
)
;
break
;
}
if
(
!
attached
)
{
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
}
}
void
ICFallbackStub
:
:
unlinkStub
(
Zone
*
zone
ICStub
*
prev
ICStub
*
stub
)
{
MOZ_ASSERT
(
stub
-
>
next
(
)
)
;
if
(
stub
-
>
next
(
)
=
=
this
)
{
MOZ_ASSERT
(
lastStubPtrAddr_
=
=
stub
-
>
addressOfNext
(
)
)
;
if
(
prev
)
{
lastStubPtrAddr_
=
prev
-
>
addressOfNext
(
)
;
}
else
{
lastStubPtrAddr_
=
icEntry
(
)
-
>
addressOfFirstStub
(
)
;
}
*
lastStubPtrAddr_
=
this
;
}
else
{
if
(
prev
)
{
MOZ_ASSERT
(
prev
-
>
next
(
)
=
=
stub
)
;
prev
-
>
setNext
(
stub
-
>
next
(
)
)
;
}
else
{
MOZ_ASSERT
(
icEntry
(
)
-
>
firstStub
(
)
=
=
stub
)
;
icEntry
(
)
-
>
setFirstStub
(
stub
-
>
next
(
)
)
;
}
}
state_
.
trackUnlinkedStub
(
)
;
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
stub
-
>
trace
(
zone
-
>
barrierTracer
(
)
)
;
}
if
(
IsTypeInferenceEnabled
(
)
&
&
stub
-
>
makesGCCalls
(
)
&
&
stub
-
>
isMonitored
(
)
)
{
ICTypeMonitor_Fallback
*
monitorFallback
=
toMonitoredFallbackStub
(
)
-
>
maybeFallbackMonitorStub
(
)
;
MOZ_ASSERT
(
monitorFallback
)
;
stub
-
>
toMonitoredStub
(
)
-
>
resetFirstMonitorStub
(
monitorFallback
)
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
stub
-
>
checkTraceMagic
(
)
;
#
endif
#
ifdef
DEBUG
if
(
!
stub
-
>
makesGCCalls
(
)
)
{
stub
-
>
stubCode_
=
(
uint8_t
*
)
0xbad
;
}
#
endif
}
void
ICFallbackStub
:
:
unlinkStubsWithKind
(
JSContext
*
cx
ICStub
:
:
Kind
kind
)
{
for
(
ICStubIterator
iter
=
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
kind
(
)
=
=
kind
)
{
iter
.
unlink
(
cx
)
;
}
}
}
void
ICFallbackStub
:
:
discardStubs
(
JSContext
*
cx
)
{
for
(
ICStubIterator
iter
=
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
iter
.
unlink
(
cx
)
;
}
}
void
ICTypeMonitor_Fallback
:
:
resetMonitorStubChain
(
Zone
*
zone
)
{
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
for
(
ICStub
*
s
=
firstMonitorStub_
;
!
s
-
>
isTypeMonitor_Fallback
(
)
;
s
=
s
-
>
next
(
)
)
{
s
-
>
trace
(
zone
-
>
barrierTracer
(
)
)
;
}
}
firstMonitorStub_
=
this
;
numOptimizedMonitorStubs_
=
0
;
if
(
hasFallbackStub_
)
{
lastMonitorStubPtrAddr_
=
nullptr
;
for
(
ICStubConstIterator
iter
=
mainFallbackStub_
-
>
beginChainConst
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isMonitored
(
)
)
{
continue
;
}
iter
-
>
toMonitoredStub
(
)
-
>
resetFirstMonitorStub
(
this
)
;
}
}
else
{
icEntry_
-
>
setFirstStub
(
this
)
;
lastMonitorStubPtrAddr_
=
icEntry_
-
>
addressOfFirstStub
(
)
;
}
}
void
ICCacheIR_Updated
:
:
resetUpdateStubChain
(
Zone
*
zone
)
{
while
(
!
firstUpdateStub_
-
>
isTypeUpdate_Fallback
(
)
)
{
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
firstUpdateStub_
-
>
trace
(
zone
-
>
barrierTracer
(
)
)
;
}
firstUpdateStub_
=
firstUpdateStub_
-
>
next
(
)
;
}
numOptimizedStubs_
=
0
;
}
ICMonitoredStub
:
:
ICMonitoredStub
(
Kind
kind
JitCode
*
stubCode
ICStub
*
firstMonitorStub
)
:
ICStub
(
kind
ICStub
:
:
Monitored
stubCode
)
firstMonitorStub_
(
firstMonitorStub
)
{
if
(
IsTypeInferenceEnabled
(
)
)
{
MOZ_ASSERT
(
firstMonitorStub_
)
;
MOZ_ASSERT_IF
(
firstMonitorStub_
-
>
isTypeMonitor_Fallback
(
)
firstMonitorStub_
-
>
toTypeMonitor_Fallback
(
)
-
>
firstMonitorStub
(
)
=
=
firstMonitorStub_
)
;
}
else
{
MOZ_ASSERT
(
!
firstMonitorStub_
)
;
}
}
bool
ICMonitoredFallbackStub
:
:
initMonitoringChain
(
JSContext
*
cx
JSScript
*
script
)
{
MOZ_ASSERT
(
fallbackMonitorStub_
=
=
nullptr
)
;
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
ICStubSpace
*
space
=
script
-
>
jitScript
(
)
-
>
fallbackStubSpace
(
)
;
FallbackStubAllocator
alloc
(
cx
*
space
)
;
auto
*
stub
=
alloc
.
newStub
<
ICTypeMonitor_Fallback
>
(
BaselineICFallbackKind
:
:
TypeMonitor
this
)
;
if
(
!
stub
)
{
return
false
;
}
fallbackMonitorStub_
=
stub
;
return
true
;
}
bool
TypeMonitorResult
(
JSContext
*
cx
ICMonitoredFallbackStub
*
stub
BaselineFrame
*
frame
HandleScript
script
jsbytecode
*
pc
HandleValue
val
)
{
if
(
!
IsTypeInferenceEnabled
(
)
)
{
return
true
;
}
ICTypeMonitor_Fallback
*
typeMonitorFallback
=
stub
-
>
getFallbackMonitorStub
(
cx
script
)
;
if
(
!
typeMonitorFallback
)
{
return
false
;
}
AutoSweepJitScript
sweep
(
script
)
;
StackTypeSet
*
types
=
script
-
>
jitScript
(
)
-
>
bytecodeTypes
(
sweep
script
pc
)
;
JitScript
:
:
MonitorBytecodeType
(
cx
script
pc
types
val
)
;
return
typeMonitorFallback
-
>
addMonitorStubForValue
(
cx
frame
types
val
)
;
}
bool
ICCacheIR_Updated
:
:
initUpdatingChain
(
JSContext
*
cx
ICStubSpace
*
space
)
{
MOZ_ASSERT
(
firstUpdateStub_
=
=
nullptr
)
;
FallbackStubAllocator
alloc
(
cx
*
space
)
;
auto
*
stub
=
alloc
.
newStub
<
ICTypeUpdate_Fallback
>
(
BaselineICFallbackKind
:
:
TypeUpdate
)
;
if
(
!
stub
)
{
return
false
;
}
firstUpdateStub_
=
stub
;
return
true
;
}
ICStubSpace
*
ICStubCompiler
:
:
StubSpaceForStub
(
bool
makesGCCalls
JSScript
*
script
)
{
if
(
makesGCCalls
)
{
return
script
-
>
jitScript
(
)
-
>
fallbackStubSpace
(
)
;
}
return
script
-
>
zone
(
)
-
>
jitZone
(
)
-
>
optimizedStubSpace
(
)
;
}
static
void
InitMacroAssemblerForICStub
(
StackMacroAssembler
&
masm
)
{
#
ifndef
JS_USE_LINK_REGISTER
masm
.
adjustFrame
(
sizeof
(
intptr_t
)
)
;
#
endif
#
ifdef
JS_CODEGEN_ARM
masm
.
setSecondScratchReg
(
BaselineSecondScratchReg
)
;
#
endif
}
JitCode
*
ICStubCompiler
:
:
getStubCode
(
)
{
JitRealm
*
realm
=
cx
-
>
realm
(
)
-
>
jitRealm
(
)
;
uint32_t
stubKey
=
getKey
(
)
;
JitCode
*
stubCode
=
realm
-
>
getStubCode
(
stubKey
)
;
if
(
stubCode
)
{
return
stubCode
;
}
JitContext
jctx
(
cx
nullptr
)
;
StackMacroAssembler
masm
;
InitMacroAssemblerForICStub
(
masm
)
;
if
(
!
generateStubCode
(
masm
)
)
{
return
nullptr
;
}
Linker
linker
(
masm
)
;
Rooted
<
JitCode
*
>
newStubCode
(
cx
linker
.
newCode
(
cx
CodeKind
:
:
Baseline
)
)
;
if
(
!
newStubCode
)
{
return
nullptr
;
}
if
(
!
realm
-
>
putStubCode
(
cx
stubKey
newStubCode
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
entersStubFrame_
=
=
ICStub
:
:
NonCacheIRStubMakesGCCalls
(
kind
)
)
;
MOZ_ASSERT
(
!
inStubFrame_
)
;
#
ifdef
JS_ION_PERF
writePerfSpewerJitCodeProfile
(
newStubCode
"
BaselineIC
"
)
;
#
endif
return
newStubCode
;
}
bool
ICStubCompilerBase
:
:
tailCallVMInternal
(
MacroAssembler
&
masm
TailCallVMFunctionId
id
)
{
TrampolinePtr
code
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getVMWrapper
(
id
)
;
const
VMFunctionData
&
fun
=
GetVMFunction
(
id
)
;
MOZ_ASSERT
(
fun
.
expectTailCall
=
=
TailCall
)
;
uint32_t
argSize
=
fun
.
explicitStackSlots
(
)
*
sizeof
(
void
*
)
;
EmitBaselineTailCallVM
(
code
masm
argSize
)
;
return
true
;
}
bool
ICStubCompilerBase
:
:
callVMInternal
(
MacroAssembler
&
masm
VMFunctionId
id
)
{
MOZ_ASSERT
(
inStubFrame_
)
;
TrampolinePtr
code
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getVMWrapper
(
id
)
;
MOZ_ASSERT
(
GetVMFunction
(
id
)
.
expectTailCall
=
=
NonTailCall
)
;
EmitBaselineCallVM
(
code
masm
)
;
return
true
;
}
template
<
typename
Fn
Fn
fn
>
bool
ICStubCompilerBase
:
:
callVM
(
MacroAssembler
&
masm
)
{
VMFunctionId
id
=
VMFunctionToId
<
Fn
fn
>
:
:
id
;
return
callVMInternal
(
masm
id
)
;
}
template
<
typename
Fn
Fn
fn
>
bool
ICStubCompilerBase
:
:
tailCallVM
(
MacroAssembler
&
masm
)
{
TailCallVMFunctionId
id
=
TailCallVMFunctionToId
<
Fn
fn
>
:
:
id
;
return
tailCallVMInternal
(
masm
id
)
;
}
void
ICStubCompilerBase
:
:
enterStubFrame
(
MacroAssembler
&
masm
Register
scratch
)
{
EmitBaselineEnterStubFrame
(
masm
scratch
)
;
#
ifdef
DEBUG
framePushedAtEnterStubFrame_
=
masm
.
framePushed
(
)
;
#
endif
MOZ_ASSERT
(
!
inStubFrame_
)
;
inStubFrame_
=
true
;
#
ifdef
DEBUG
entersStubFrame_
=
true
;
#
endif
}
void
ICStubCompilerBase
:
:
assumeStubFrame
(
)
{
MOZ_ASSERT
(
!
inStubFrame_
)
;
inStubFrame_
=
true
;
#
ifdef
DEBUG
entersStubFrame_
=
true
;
framePushedAtEnterStubFrame_
=
STUB_FRAME_SIZE
;
#
endif
}
void
ICStubCompilerBase
:
:
leaveStubFrame
(
MacroAssembler
&
masm
bool
calledIntoIon
)
{
MOZ_ASSERT
(
entersStubFrame_
&
&
inStubFrame_
)
;
inStubFrame_
=
false
;
#
ifdef
DEBUG
masm
.
setFramePushed
(
framePushedAtEnterStubFrame_
)
;
if
(
calledIntoIon
)
{
masm
.
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
#
endif
EmitBaselineLeaveStubFrame
(
masm
calledIntoIon
)
;
}
void
ICStubCompilerBase
:
:
pushStubPayload
(
MacroAssembler
&
masm
Register
scratch
)
{
if
(
inStubFrame_
)
{
masm
.
loadPtr
(
Address
(
BaselineFrameReg
0
)
scratch
)
;
masm
.
pushBaselineFramePtr
(
scratch
scratch
)
;
}
else
{
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
scratch
)
;
}
}
void
ICStubCompilerBase
:
:
PushStubPayload
(
MacroAssembler
&
masm
Register
scratch
)
{
pushStubPayload
(
masm
scratch
)
;
masm
.
adjustFrame
(
sizeof
(
intptr_t
)
)
;
}
bool
ICTypeMonitor_Fallback
:
:
addMonitorStubForValue
(
JSContext
*
cx
BaselineFrame
*
frame
StackTypeSet
*
types
HandleValue
val
)
{
MOZ_ASSERT
(
types
)
;
if
(
MOZ_UNLIKELY
(
val
.
isMagic
(
)
)
)
{
return
true
;
}
if
(
numOptimizedMonitorStubs_
>
=
MAX_OPTIMIZED_STUBS
&
&
val
.
isObject
(
)
&
&
!
types
-
>
unknownObject
(
)
)
{
return
true
;
}
bool
wasDetachedMonitorChain
=
lastMonitorStubPtrAddr_
=
=
nullptr
;
MOZ_ASSERT_IF
(
wasDetachedMonitorChain
numOptimizedMonitorStubs_
=
=
0
)
;
if
(
types
-
>
unknown
(
)
)
{
for
(
ICStubConstIterator
iter
(
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeMonitor_AnyValue
(
)
)
{
return
true
;
}
}
resetMonitorStubChain
(
cx
-
>
zone
(
)
)
;
wasDetachedMonitorChain
=
(
lastMonitorStubPtrAddr_
=
=
nullptr
)
;
ICTypeMonitor_AnyValue
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
stub
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeMonitor
stub
%
p
for
any
value
"
stub
)
;
addOptimizedMonitorStub
(
stub
)
;
}
else
if
(
val
.
isPrimitive
(
)
|
|
types
-
>
unknownObject
(
)
)
{
ValueType
type
=
val
.
type
(
)
;
ICTypeMonitor_PrimitiveSet
*
existingStub
=
nullptr
;
for
(
ICStubConstIterator
iter
(
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeMonitor_PrimitiveSet
(
)
)
{
existingStub
=
iter
-
>
toTypeMonitor_PrimitiveSet
(
)
;
if
(
existingStub
-
>
containsType
(
type
)
)
{
return
true
;
}
}
}
if
(
val
.
isObject
(
)
)
{
MOZ_ASSERT
(
types
-
>
unknownObject
(
)
)
;
bool
hasObjectStubs
=
false
;
for
(
ICStubConstIterator
iter
(
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeMonitor_SingleObject
(
)
|
|
iter
-
>
isTypeMonitor_ObjectGroup
(
)
)
{
hasObjectStubs
=
true
;
break
;
}
}
if
(
hasObjectStubs
)
{
resetMonitorStubChain
(
cx
-
>
zone
(
)
)
;
wasDetachedMonitorChain
=
(
lastMonitorStubPtrAddr_
=
=
nullptr
)
;
existingStub
=
nullptr
;
}
}
ICTypeMonitor_PrimitiveSet
:
:
Compiler
compiler
(
cx
existingStub
type
)
;
ICStub
*
stub
=
existingStub
?
compiler
.
updateStub
(
)
:
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
stub
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
%
s
TypeMonitor
stub
%
p
for
primitive
type
%
u
"
existingStub
?
"
Modified
existing
"
:
"
Created
new
"
stub
static_cast
<
uint8_t
>
(
type
)
)
;
if
(
!
existingStub
)
{
MOZ_ASSERT
(
!
hasStub
(
TypeMonitor_PrimitiveSet
)
)
;
addOptimizedMonitorStub
(
stub
)
;
}
}
else
if
(
val
.
toObject
(
)
.
isSingleton
(
)
)
{
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
for
(
ICStubConstIterator
iter
(
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeMonitor_SingleObject
(
)
&
&
iter
-
>
toTypeMonitor_SingleObject
(
)
-
>
object
(
)
=
=
obj
)
{
return
true
;
}
}
ICTypeMonitor_SingleObject
:
:
Compiler
compiler
(
cx
obj
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
stub
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeMonitor
stub
%
p
for
singleton
%
p
"
stub
obj
.
get
(
)
)
;
addOptimizedMonitorStub
(
stub
)
;
}
else
{
RootedObjectGroup
group
(
cx
val
.
toObject
(
)
.
group
(
)
)
;
for
(
ICStubConstIterator
iter
(
firstMonitorStub
(
)
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeMonitor_ObjectGroup
(
)
&
&
iter
-
>
toTypeMonitor_ObjectGroup
(
)
-
>
group
(
)
=
=
group
)
{
return
true
;
}
}
ICTypeMonitor_ObjectGroup
:
:
Compiler
compiler
(
cx
group
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
frame
-
>
script
(
)
)
)
;
if
(
!
stub
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeMonitor
stub
%
p
for
ObjectGroup
%
p
"
stub
group
.
get
(
)
)
;
addOptimizedMonitorStub
(
stub
)
;
}
bool
firstMonitorStubAdded
=
wasDetachedMonitorChain
&
&
(
numOptimizedMonitorStubs_
>
0
)
;
if
(
firstMonitorStubAdded
)
{
ICStub
*
firstStub
=
mainFallbackStub_
-
>
icEntry
(
)
-
>
firstStub
(
)
;
for
(
ICStubConstIterator
iter
(
firstStub
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isMonitored
(
)
)
{
continue
;
}
MOZ_ASSERT
(
iter
-
>
toMonitoredStub
(
)
-
>
firstMonitorStub
(
)
=
=
this
)
;
iter
-
>
toMonitoredStub
(
)
-
>
updateFirstMonitorStub
(
firstMonitorStub_
)
;
}
}
return
true
;
}
bool
DoTypeMonitorFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeMonitor_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
{
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
JSScript
*
script
=
frame
-
>
script
(
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
TypeFallbackICSpew
(
cx
stub
"
TypeMonitor
"
)
;
res
.
set
(
value
)
;
JitScript
*
jitScript
=
script
-
>
jitScript
(
)
;
AutoSweepJitScript
sweep
(
script
)
;
StackTypeSet
*
types
;
uint32_t
argument
;
if
(
stub
-
>
monitorsArgument
(
&
argument
)
)
{
MOZ_ASSERT
(
pc
=
=
script
-
>
code
(
)
)
;
types
=
jitScript
-
>
argTypes
(
sweep
script
argument
)
;
JitScript
:
:
MonitorArgType
(
cx
script
argument
value
)
;
}
else
if
(
stub
-
>
monitorsThis
(
)
)
{
MOZ_ASSERT
(
pc
=
=
script
-
>
code
(
)
)
;
types
=
jitScript
-
>
thisTypes
(
sweep
script
)
;
JitScript
:
:
MonitorThisType
(
cx
script
value
)
;
}
else
{
types
=
jitScript
-
>
bytecodeTypes
(
sweep
script
pc
)
;
JitScript
:
:
MonitorBytecodeType
(
cx
script
pc
types
value
)
;
}
return
stub
-
>
addMonitorStubForValue
(
cx
frame
types
value
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_TypeMonitor
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICTypeMonitor_Fallback
*
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoTypeMonitorFallback
>
(
masm
)
;
}
bool
ICTypeMonitor_PrimitiveSet
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
success
;
if
(
(
flags_
&
TypeToFlag
(
ValueType
:
:
Int32
)
)
&
&
!
(
flags_
&
TypeToFlag
(
ValueType
:
:
Double
)
)
)
{
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Double
)
)
{
masm
.
branchTestNumber
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Undefined
)
)
{
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Boolean
)
)
{
masm
.
branchTestBoolean
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
String
)
)
{
masm
.
branchTestString
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Symbol
)
)
{
masm
.
branchTestSymbol
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
BigInt
)
)
{
masm
.
branchTestBigInt
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Object
)
)
{
masm
.
branchTestObject
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Null
)
)
{
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
success
)
;
}
EmitStubGuardFailure
(
masm
)
;
masm
.
bind
(
&
success
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
static
void
MaybeWorkAroundAmdBug
(
MacroAssembler
&
masm
)
{
#
if
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
if
(
CPUInfo
:
:
NeedAmdBugWorkaround
(
)
)
{
masm
.
nop
(
9
)
;
masm
.
nop
(
9
)
;
masm
.
nop
(
9
)
;
masm
.
nop
(
5
)
;
}
#
endif
}
bool
ICTypeMonitor_SingleObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
Address
expectedObject
(
ICStubReg
ICTypeMonitor_SingleObject
:
:
offsetOfObject
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedObject
obj
&
failure
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeMonitor_ObjectGroup
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
Register
obj
=
masm
.
extractObject
(
R0
ExtractTemp0
)
;
Address
expectedGroup
(
ICStubReg
ICTypeMonitor_ObjectGroup
:
:
offsetOfGroup
(
)
)
;
masm
.
branchTestObjGroupNoSpectreMitigations
(
Assembler
:
:
NotEqual
obj
expectedGroup
R1
.
scratchReg
(
)
&
failure
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
MaybeWorkAroundAmdBug
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeMonitor_AnyValue
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICCacheIR_Updated
:
:
addUpdateStubForValue
(
JSContext
*
cx
HandleScript
outerScript
HandleObject
obj
HandleObjectGroup
group
HandleId
id
HandleValue
val
)
{
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
EnsureTrackPropertyTypes
(
cx
obj
id
)
;
if
(
val
.
isUndefined
(
)
&
&
CanHaveEmptyPropertyTypesForOwnProperty
(
obj
)
)
{
MOZ_ASSERT
(
obj
-
>
group
(
)
=
=
group
)
;
AddTypePropertyId
(
cx
obj
id
val
)
;
}
bool
unknown
=
false
unknownObject
=
false
;
AutoSweepObjectGroup
sweep
(
group
)
;
if
(
group
-
>
unknownProperties
(
sweep
)
)
{
unknown
=
unknownObject
=
true
;
}
else
{
if
(
HeapTypeSet
*
types
=
group
-
>
maybeGetProperty
(
sweep
id
)
)
{
unknown
=
types
-
>
unknown
(
)
;
unknownObject
=
types
-
>
unknownObject
(
)
;
}
else
{
MOZ_ASSERT
(
obj
-
>
is
<
TypedObject
>
(
)
)
;
MOZ_ASSERT
(
val
.
isNullOrUndefined
(
)
)
;
}
}
MOZ_ASSERT_IF
(
unknown
unknownObject
)
;
if
(
numOptimizedStubs_
>
=
MAX_OPTIMIZED_STUBS
&
&
val
.
isObject
(
)
&
&
!
unknownObject
)
{
return
true
;
}
if
(
unknown
)
{
MOZ_ASSERT
(
!
hasTypeUpdateStub
(
TypeUpdate_AnyValue
)
)
;
resetUpdateStubChain
(
cx
-
>
zone
(
)
)
;
ICTypeUpdate_AnyValue
:
:
Compiler
compiler
(
cx
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
stub
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeUpdate
stub
%
p
for
any
value
"
stub
)
;
addOptimizedUpdateStub
(
stub
)
;
}
else
if
(
val
.
isPrimitive
(
)
|
|
unknownObject
)
{
ValueType
type
=
val
.
type
(
)
;
ICTypeUpdate_PrimitiveSet
*
existingStub
=
nullptr
;
for
(
ICStubConstIterator
iter
(
firstUpdateStub_
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isTypeUpdate_PrimitiveSet
(
)
)
{
existingStub
=
iter
-
>
toTypeUpdate_PrimitiveSet
(
)
;
MOZ_ASSERT
(
!
existingStub
-
>
containsType
(
type
)
)
;
}
}
if
(
val
.
isObject
(
)
)
{
resetUpdateStubChain
(
cx
-
>
zone
(
)
)
;
if
(
existingStub
)
{
addOptimizedUpdateStub
(
existingStub
)
;
}
}
ICTypeUpdate_PrimitiveSet
:
:
Compiler
compiler
(
cx
existingStub
type
)
;
ICStub
*
stub
=
existingStub
?
compiler
.
updateStub
(
)
:
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
stub
)
{
return
false
;
}
if
(
!
existingStub
)
{
MOZ_ASSERT
(
!
hasTypeUpdateStub
(
TypeUpdate_PrimitiveSet
)
)
;
addOptimizedUpdateStub
(
stub
)
;
}
JitSpew
(
JitSpew_BaselineIC
"
%
s
TypeUpdate
stub
%
p
for
primitive
type
%
d
"
existingStub
?
"
Modified
existing
"
:
"
Created
new
"
stub
static_cast
<
uint8_t
>
(
type
)
)
;
}
else
if
(
val
.
toObject
(
)
.
isSingleton
(
)
)
{
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
#
ifdef
DEBUG
for
(
ICStubConstIterator
iter
(
firstUpdateStub_
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
isTypeUpdate_SingleObject
(
)
iter
-
>
toTypeUpdate_SingleObject
(
)
-
>
object
(
)
!
=
obj
)
;
}
#
endif
ICTypeUpdate_SingleObject
:
:
Compiler
compiler
(
cx
obj
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
stub
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeUpdate
stub
%
p
for
singleton
%
p
"
stub
obj
.
get
(
)
)
;
addOptimizedUpdateStub
(
stub
)
;
}
else
{
RootedObjectGroup
group
(
cx
val
.
toObject
(
)
.
group
(
)
)
;
#
ifdef
DEBUG
for
(
ICStubConstIterator
iter
(
firstUpdateStub_
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
isTypeUpdate_ObjectGroup
(
)
iter
-
>
toTypeUpdate_ObjectGroup
(
)
-
>
group
(
)
!
=
group
)
;
}
#
endif
ICTypeUpdate_ObjectGroup
:
:
Compiler
compiler
(
cx
group
)
;
ICStub
*
stub
=
compiler
.
getStub
(
compiler
.
getStubSpace
(
outerScript
)
)
;
if
(
!
stub
)
{
return
false
;
}
JitSpew
(
JitSpew_BaselineIC
"
Added
TypeUpdate
stub
%
p
for
ObjectGroup
%
p
"
stub
group
.
get
(
)
)
;
addOptimizedUpdateStub
(
stub
)
;
}
return
true
;
}
bool
DoTypeUpdateFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCacheIR_Updated
*
stub
HandleValue
objval
HandleValue
value
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
IsTypeInferenceEnabled
(
)
)
;
FallbackICSpew
(
cx
stub
-
>
getChainFallback
(
)
"
TypeUpdate
(
%
s
)
"
ICStub
:
:
KindString
(
stub
-
>
kind
(
)
)
)
;
MOZ_ASSERT
(
stub
-
>
isCacheIR_Updated
(
)
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedObject
obj
(
cx
&
objval
.
toObject
(
)
)
;
RootedId
id
(
cx
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubId
(
)
)
;
MOZ_ASSERT
(
id
.
get
(
)
!
=
JSID_EMPTY
)
;
RootedObjectGroup
group
(
cx
stub
-
>
toCacheIR_Updated
(
)
-
>
updateStubGroup
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
obj
-
>
group
(
)
=
=
group
)
;
#
endif
bool
addType
=
true
;
if
(
MOZ_UNLIKELY
(
obj
-
>
is
<
TypedObject
>
(
)
)
&
&
value
.
isNullOrUndefined
(
)
)
{
StructTypeDescr
*
structDescr
=
&
obj
-
>
as
<
TypedObject
>
(
)
.
typeDescr
(
)
.
as
<
StructTypeDescr
>
(
)
;
size_t
fieldIndex
;
MOZ_ALWAYS_TRUE
(
structDescr
-
>
fieldIndex
(
id
&
fieldIndex
)
)
;
TypeDescr
*
fieldDescr
=
&
structDescr
-
>
fieldDescr
(
fieldIndex
)
;
ReferenceType
type
=
fieldDescr
-
>
as
<
ReferenceTypeDescr
>
(
)
.
type
(
)
;
if
(
type
=
=
ReferenceType
:
:
TYPE_ANY
)
{
if
(
value
.
isUndefined
(
)
)
{
addType
=
false
;
}
}
else
{
MOZ_ASSERT
(
type
=
=
ReferenceType
:
:
TYPE_OBJECT
|
|
type
=
=
ReferenceType
:
:
TYPE_WASM_ANYREF
)
;
if
(
value
.
isNull
(
)
)
{
addType
=
false
;
}
}
}
if
(
MOZ_LIKELY
(
addType
)
)
{
JSObject
*
maybeSingleton
=
obj
-
>
isSingleton
(
)
?
obj
.
get
(
)
:
nullptr
;
AddTypePropertyId
(
cx
group
maybeSingleton
id
value
)
;
}
if
(
MOZ_UNLIKELY
(
!
stub
-
>
addUpdateStubForValue
(
cx
script
obj
group
id
value
)
)
)
{
cx
-
>
recoverFromOutOfMemory
(
)
;
}
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_TypeUpdate
(
)
{
masm
.
move32
(
Imm32
(
0
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_PrimitiveSet
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
success
;
if
(
(
flags_
&
TypeToFlag
(
ValueType
:
:
Int32
)
)
&
&
!
(
flags_
&
TypeToFlag
(
ValueType
:
:
Double
)
)
)
{
masm
.
branchTestInt32
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Double
)
)
{
masm
.
branchTestNumber
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Undefined
)
)
{
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Boolean
)
)
{
masm
.
branchTestBoolean
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
String
)
)
{
masm
.
branchTestString
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Symbol
)
)
{
masm
.
branchTestSymbol
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
BigInt
)
)
{
masm
.
branchTestBigInt
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Object
)
)
{
masm
.
branchTestObject
(
Assembler
:
:
Equal
R0
&
success
)
;
}
if
(
flags_
&
TypeToFlag
(
ValueType
:
:
Null
)
)
{
masm
.
branchTestNull
(
Assembler
:
:
Equal
R0
&
success
)
;
}
EmitStubGuardFailure
(
masm
)
;
masm
.
bind
(
&
success
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_SingleObject
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Register
obj
=
masm
.
extractObject
(
R0
R1
.
scratchReg
(
)
)
;
Address
expectedObject
(
ICStubReg
ICTypeUpdate_SingleObject
:
:
offsetOfObject
(
)
)
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
expectedObject
obj
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_ObjectGroup
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
Label
failure
;
masm
.
branchTestObject
(
Assembler
:
:
NotEqual
R0
&
failure
)
;
Address
expectedGroup
(
ICStubReg
ICTypeUpdate_ObjectGroup
:
:
offsetOfGroup
(
)
)
;
Register
scratch1
=
R1
.
scratchReg
(
)
;
masm
.
unboxObject
(
R0
scratch1
)
;
masm
.
branchTestObjGroup
(
Assembler
:
:
NotEqual
scratch1
expectedGroup
scratch1
R0
.
payloadOrValueReg
(
)
&
failure
)
;
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
masm
.
bind
(
&
failure
)
;
EmitStubGuardFailure
(
masm
)
;
return
true
;
}
bool
ICTypeUpdate_AnyValue
:
:
Compiler
:
:
generateStubCode
(
MacroAssembler
&
masm
)
{
masm
.
mov
(
ImmWord
(
1
)
R1
.
scratchReg
(
)
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
DoToBoolFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICToBool_Fallback
*
stub
HandleValue
arg
MutableHandleValue
ret
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
ToBool
"
)
;
MOZ_ASSERT
(
!
arg
.
isBoolean
(
)
)
;
TryAttachStub
<
ToBoolIRGenerator
>
(
"
ToBool
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
arg
)
;
bool
cond
=
ToBoolean
(
arg
)
;
ret
.
setBoolean
(
cond
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_ToBool
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICToBool_Fallback
*
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoToBoolFallback
>
(
masm
)
;
}
static
void
StripPreliminaryObjectStubs
(
JSContext
*
cx
ICFallbackStub
*
stub
)
{
for
(
ICStubIterator
iter
=
stub
-
>
beginChain
(
)
;
!
iter
.
atEnd
(
)
;
iter
+
+
)
{
if
(
iter
-
>
isCacheIR_Regular
(
)
&
&
iter
-
>
toCacheIR_Regular
(
)
-
>
hasPreliminaryObject
(
)
)
{
iter
.
unlink
(
cx
)
;
}
else
if
(
iter
-
>
isCacheIR_Monitored
(
)
&
&
iter
-
>
toCacheIR_Monitored
(
)
-
>
hasPreliminaryObject
(
)
)
{
iter
.
unlink
(
cx
)
;
}
else
if
(
iter
-
>
isCacheIR_Updated
(
)
&
&
iter
-
>
toCacheIR_Updated
(
)
-
>
hasPreliminaryObject
(
)
)
{
iter
.
unlink
(
cx
)
;
}
}
}
static
bool
TryAttachGetPropStub
(
const
char
*
name
JSContext
*
cx
BaselineFrame
*
frame
ICFallbackStub
*
stub
CacheKind
kind
HandleValue
val
HandleValue
idVal
HandleValue
receiver
)
{
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
GetPropIRGenerator
gen
(
cx
script
pc
stub
-
>
state
(
)
.
mode
(
)
kind
val
idVal
receiver
GetPropertyResultFlags
:
:
All
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Monitored
script
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
%
s
CacheIR
stub
"
name
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
{
newStub
-
>
toCacheIR_Monitored
(
)
-
>
notePreliminaryObject
(
)
;
}
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
{
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
attached
=
true
;
break
;
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
No
deferred
GetProp
stubs
"
)
;
break
;
}
}
return
attached
;
}
bool
DoGetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElem
(
%
s
)
"
CodeName
(
op
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetElem
|
|
op
=
=
JSOp
:
:
CallElem
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
bool
isOptimizedArgs
=
false
;
if
(
lhs
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
if
(
!
GetElemOptimizedArguments
(
cx
frame
&
lhsCopy
rhs
res
&
isOptimizedArgs
)
)
{
return
false
;
}
if
(
isOptimizedArgs
)
{
if
(
!
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
)
{
return
false
;
}
}
}
bool
attached
=
TryAttachGetPropStub
(
"
GetElem
"
cx
frame
stub
CacheKind
:
:
GetElem
lhs
rhs
lhs
)
;
if
(
!
isOptimizedArgs
)
{
if
(
!
GetElementOperation
(
cx
op
lhsCopy
rhs
res
)
)
{
return
false
;
}
if
(
!
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
)
{
return
false
;
}
}
if
(
attached
)
{
return
true
;
}
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
{
stub
-
>
noteNegativeIndex
(
)
;
}
int32_t
representable
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
isDouble
(
)
&
&
!
mozilla
:
:
NumberEqualsInt32
(
rhs
.
toDouble
(
)
&
representable
)
)
{
stub
-
>
setSawNonIntegerIndex
(
)
;
}
return
true
;
}
bool
DoGetElemSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetElem_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
HandleValue
receiver
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetElemSuper
(
%
s
)
"
CodeName
(
op
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetElemSuper
)
;
bool
attached
=
TryAttachGetPropStub
(
"
GetElemSuper
"
cx
frame
stub
CacheKind
:
:
GetElemSuper
lhs
rhs
receiver
)
;
RootedObject
lhsObj
(
cx
&
lhs
.
toObject
(
)
)
;
if
(
!
GetObjectElementOperation
(
cx
op
lhsObj
receiver
rhs
res
)
)
{
return
false
;
}
if
(
!
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
)
{
return
false
;
}
if
(
attached
)
{
return
true
;
}
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
toNumber
(
)
<
0
)
{
stub
-
>
noteNegativeIndex
(
)
;
}
int32_t
representable
;
if
(
rhs
.
isNumber
(
)
&
&
rhs
.
isDouble
(
)
&
&
!
mozilla
:
:
NumberEqualsInt32
(
rhs
.
toDouble
(
)
&
representable
)
)
{
stub
-
>
setSawNonIntegerIndex
(
)
;
}
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emitGetElem
(
bool
hasReceiver
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
if
(
hasReceiver
)
{
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
*
2
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
*
5
)
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
HandleValue
MutableHandleValue
)
;
if
(
!
tailCallVM
<
Fn
DoGetElemSuperFallback
>
(
masm
)
)
{
return
false
;
}
}
else
{
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetElem_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
if
(
!
tailCallVM
<
Fn
DoGetElemFallback
>
(
masm
)
)
{
return
false
;
}
}
assumeStubFrame
(
)
;
if
(
hasReceiver
)
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
GetElemSuper
masm
.
currentOffset
(
)
)
;
}
else
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
GetElem
masm
.
currentOffset
(
)
)
;
}
leaveStubFrame
(
masm
true
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetElem
(
)
{
return
emitGetElem
(
false
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetElemSuper
(
)
{
return
emitGetElem
(
true
)
;
}
static
void
SetUpdateStubData
(
ICCacheIR_Updated
*
stub
const
PropertyTypeCheckInfo
*
info
)
{
if
(
info
-
>
isSet
(
)
)
{
stub
-
>
updateStubGroup
(
)
=
info
-
>
group
(
)
;
stub
-
>
updateStubId
(
)
=
info
-
>
id
(
)
;
}
}
bool
DoSetElemFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetElem_Fallback
*
stub
Value
*
stack
HandleValue
objv
HandleValue
index
HandleValue
rhs
)
{
using
DeferType
=
SetPropIRGenerator
:
:
DeferType
;
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
RootedScript
outerScript
(
cx
script
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetElem
(
%
s
)
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
SetElem
|
|
op
=
=
JSOp
:
:
StrictSetElem
|
|
op
=
=
JSOp
:
:
InitElem
|
|
op
=
=
JSOp
:
:
InitHiddenElem
|
|
op
=
=
JSOp
:
:
InitElemArray
|
|
op
=
=
JSOp
:
:
InitElemInc
)
;
int
objvIndex
=
-
3
;
RootedObject
obj
(
cx
ToObjectFromStackForPropertyAccess
(
cx
objv
objvIndex
index
)
)
;
if
(
!
obj
)
{
return
false
;
}
RootedShape
oldShape
(
cx
obj
-
>
shape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
{
return
false
;
}
DeferType
deferType
=
DeferType
:
:
None
;
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetElem
stub
-
>
state
(
)
.
mode
(
)
objv
index
rhs
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
SetElem
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
}
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
{
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
if
(
gen
.
attachedTypedArrayOOBStub
(
)
)
{
stub
-
>
noteHasTypedArrayOOB
(
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
attached
=
true
;
break
;
case
AttachDecision
:
:
Deferred
:
deferType
=
gen
.
deferType
(
)
;
MOZ_ASSERT
(
deferType
!
=
DeferType
:
:
None
)
;
break
;
}
}
if
(
op
=
=
JSOp
:
:
InitElem
|
|
op
=
=
JSOp
:
:
InitHiddenElem
)
{
if
(
!
InitElemOperation
(
cx
pc
obj
index
rhs
)
)
{
return
false
;
}
}
else
if
(
op
=
=
JSOp
:
:
InitElemArray
)
{
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
<
=
INT32_MAX
"
the
bytecode
emitter
must
fail
to
compile
code
that
would
"
"
produce
JSOp
:
:
InitElemArray
with
an
index
exceeding
"
"
int32_t
range
"
)
;
MOZ_ASSERT
(
uint32_t
(
index
.
toInt32
(
)
)
=
=
GET_UINT32
(
pc
)
)
;
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
{
return
false
;
}
}
else
if
(
op
=
=
JSOp
:
:
InitElemInc
)
{
if
(
!
InitArrayElemOperation
(
cx
pc
obj
index
.
toInt32
(
)
rhs
)
)
{
return
false
;
}
}
else
{
if
(
!
SetObjectElement
(
cx
obj
index
rhs
objv
JSOp
(
*
pc
)
=
=
JSOp
:
:
StrictSetElem
script
pc
)
)
{
return
false
;
}
}
if
(
op
=
=
JSOp
:
:
InitHiddenElem
)
{
return
true
;
}
MOZ_ASSERT
(
stack
[
2
]
=
=
objv
)
;
stack
[
2
]
=
rhs
;
if
(
attached
)
{
return
true
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
bool
canAttachStub
=
stub
-
>
state
(
)
.
canAttachStub
(
)
;
if
(
deferType
!
=
DeferType
:
:
None
&
&
canAttachStub
)
{
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetElem
stub
-
>
state
(
)
.
mode
(
)
objv
index
rhs
)
;
MOZ_ASSERT
(
deferType
=
=
DeferType
:
:
AddSlot
)
;
AttachDecision
decision
=
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
;
switch
(
decision
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
SetElem
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
}
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
{
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
gen
.
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
attach
result
"
)
;
break
;
}
}
if
(
!
attached
&
&
canAttachStub
)
{
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_SetElem
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R1
)
;
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
R1
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
moveStackPtrTo
(
R1
.
scratchReg
(
)
)
;
masm
.
pushValue
(
Address
(
R1
.
scratchReg
(
)
2
*
sizeof
(
Value
)
)
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICSetElem_Fallback
*
Value
*
HandleValue
HandleValue
HandleValue
)
;
return
tailCallVM
<
Fn
DoSetElemFallback
>
(
masm
)
;
}
bool
DoInFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICIn_Fallback
*
stub
HandleValue
key
HandleValue
objValue
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
In
"
)
;
if
(
!
objValue
.
isObject
(
)
)
{
ReportInNotObjectError
(
cx
key
-
2
objValue
-
1
)
;
return
false
;
}
TryAttachStub
<
HasPropIRGenerator
>
(
"
In
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
CacheKind
:
:
In
key
objValue
)
;
RootedObject
obj
(
cx
&
objValue
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
OperatorIn
(
cx
key
obj
&
cond
)
)
{
return
false
;
}
res
.
setBoolean
(
cond
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_In
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICIn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoInFallback
>
(
masm
)
;
}
bool
DoHasOwnFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICHasOwn_Fallback
*
stub
HandleValue
keyValue
HandleValue
objValue
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
HasOwn
"
)
;
TryAttachStub
<
HasPropIRGenerator
>
(
"
HasOwn
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
CacheKind
:
:
HasOwn
keyValue
objValue
)
;
bool
found
;
if
(
!
HasOwnProperty
(
cx
objValue
keyValue
&
found
)
)
{
return
false
;
}
res
.
setBoolean
(
found
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_HasOwn
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICHasOwn_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoHasOwnFallback
>
(
masm
)
;
}
bool
DoGetNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetName
(
%
s
)
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetName
|
|
op
=
=
JSOp
:
:
GetGName
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
TryAttachStub
<
GetNameIRGenerator
>
(
"
GetName
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Monitored
envChain
name
)
;
static_assert
(
JSOpLength_GetGName
=
=
JSOpLength_GetName
"
Otherwise
our
check
for
JSOp
:
:
Typeof
isn
'
t
ok
"
)
;
if
(
JSOp
(
pc
[
JSOpLength_GetGName
]
)
=
=
JSOp
:
:
Typeof
)
{
if
(
!
GetEnvironmentName
<
GetNameMode
:
:
TypeOf
>
(
cx
envChain
name
res
)
)
{
return
false
;
}
}
else
{
if
(
!
GetEnvironmentName
<
GetNameMode
:
:
Normal
>
(
cx
envChain
name
res
)
)
{
return
false
;
}
}
return
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetName
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetName_Fallback
*
HandleObject
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoGetNameFallback
>
(
masm
)
;
}
bool
DoBindNameFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBindName_Fallback
*
stub
HandleObject
envChain
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
frame
-
>
script
(
)
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
BindName
(
%
s
)
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
BindName
|
|
op
=
=
JSOp
:
:
BindGName
)
;
RootedPropertyName
name
(
cx
frame
-
>
script
(
)
-
>
getName
(
pc
)
)
;
TryAttachStub
<
BindNameIRGenerator
>
(
"
BindName
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
envChain
name
)
;
RootedObject
scope
(
cx
)
;
if
(
!
LookupNameUnqualified
(
cx
name
envChain
&
scope
)
)
{
return
false
;
}
res
.
setObject
(
*
scope
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_BindName
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICBindName_Fallback
*
HandleObject
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoBindNameFallback
>
(
masm
)
;
}
bool
DoGetIntrinsicFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIntrinsic_Fallback
*
stub
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
mozilla
:
:
DebugOnly
<
JSOp
>
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetIntrinsic
(
%
s
)
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetIntrinsic
)
;
if
(
!
GetIntrinsicOperation
(
cx
script
pc
res
)
)
{
return
false
;
}
JitScript
:
:
MonitorBytecodeType
(
cx
script
pc
res
)
;
TryAttachStub
<
GetIntrinsicIRGenerator
>
(
"
GetIntrinsic
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
res
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetIntrinsic
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetIntrinsic_Fallback
*
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoGetIntrinsicFallback
>
(
masm
)
;
}
static
bool
ComputeGetPropResult
(
JSContext
*
cx
BaselineFrame
*
frame
JSOp
op
HandlePropertyName
name
MutableHandleValue
val
MutableHandleValue
res
)
{
if
(
val
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
&
&
IsOptimizedArguments
(
frame
val
)
)
{
if
(
op
=
=
JSOp
:
:
Length
)
{
res
.
setInt32
(
frame
-
>
numActualArgs
(
)
)
;
}
else
{
MOZ_ASSERT
(
name
=
=
cx
-
>
names
(
)
.
callee
)
;
MOZ_ASSERT
(
frame
-
>
script
(
)
-
>
hasMappedArgsObj
(
)
)
;
res
.
setObject
(
*
frame
-
>
callee
(
)
)
;
}
}
else
{
if
(
op
=
=
JSOp
:
:
GetBoundName
)
{
RootedObject
env
(
cx
&
val
.
toObject
(
)
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
if
(
!
GetNameBoundInEnvironment
(
cx
env
id
res
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetProp
|
|
op
=
=
JSOp
:
:
CallProp
|
|
op
=
=
JSOp
:
:
Length
)
;
if
(
!
GetProperty
(
cx
val
name
res
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
DoGetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetProp_Fallback
*
stub
MutableHandleValue
val
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
GetProp
(
%
s
)
"
CodeName
(
op
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
GetProp
|
|
op
=
=
JSOp
:
:
CallProp
|
|
op
=
=
JSOp
:
:
Length
|
|
op
=
=
JSOp
:
:
GetBoundName
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
TryAttachGetPropStub
(
"
GetProp
"
cx
frame
stub
CacheKind
:
:
GetProp
val
idVal
val
)
;
if
(
!
ComputeGetPropResult
(
cx
frame
op
name
val
res
)
)
{
return
false
;
}
return
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
;
}
bool
DoGetPropSuperFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetProp_Fallback
*
stub
HandleValue
receiver
MutableHandleValue
val
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
FallbackICSpew
(
cx
stub
"
GetPropSuper
(
%
s
)
"
CodeName
(
JSOp
(
*
pc
)
)
)
;
MOZ_ASSERT
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
GetPropSuper
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
TryAttachGetPropStub
(
"
GetPropSuper
"
cx
frame
stub
CacheKind
:
:
GetPropSuper
val
idVal
receiver
)
;
RootedObject
valObj
(
cx
&
val
.
toObject
(
)
)
;
if
(
!
GetProperty
(
cx
valObj
receiver
name
res
)
)
{
return
false
;
}
return
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
;
}
bool
FallbackICCodeCompiler
:
:
emitGetProp
(
bool
hasReceiver
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
if
(
hasReceiver
)
{
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetProp_Fallback
*
HandleValue
MutableHandleValue
MutableHandleValue
)
;
if
(
!
tailCallVM
<
Fn
DoGetPropSuperFallback
>
(
masm
)
)
{
return
false
;
}
}
else
{
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetProp_Fallback
*
MutableHandleValue
MutableHandleValue
)
;
if
(
!
tailCallVM
<
Fn
DoGetPropFallback
>
(
masm
)
)
{
return
false
;
}
}
assumeStubFrame
(
)
;
if
(
hasReceiver
)
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
GetPropSuper
masm
.
currentOffset
(
)
)
;
}
else
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
GetProp
masm
.
currentOffset
(
)
)
;
}
leaveStubFrame
(
masm
true
)
;
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetProp
(
)
{
return
emitGetProp
(
false
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetPropSuper
(
)
{
return
emitGetProp
(
true
)
;
}
bool
DoSetPropFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICSetProp_Fallback
*
stub
Value
*
stack
HandleValue
lhs
HandleValue
rhs
)
{
using
DeferType
=
SetPropIRGenerator
:
:
DeferType
;
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
SetProp
(
%
s
)
"
CodeName
(
op
)
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
SetProp
|
|
op
=
=
JSOp
:
:
StrictSetProp
|
|
op
=
=
JSOp
:
:
SetName
|
|
op
=
=
JSOp
:
:
StrictSetName
|
|
op
=
=
JSOp
:
:
SetGName
|
|
op
=
=
JSOp
:
:
StrictSetGName
|
|
op
=
=
JSOp
:
:
InitProp
|
|
op
=
=
JSOp
:
:
InitLockedProp
|
|
op
=
=
JSOp
:
:
InitHiddenProp
|
|
op
=
=
JSOp
:
:
InitGLexical
)
;
RootedPropertyName
name
(
cx
script
-
>
getName
(
pc
)
)
;
RootedId
id
(
cx
NameToId
(
name
)
)
;
int
lhsIndex
=
-
2
;
RootedObject
obj
(
cx
ToObjectFromStackForPropertyAccess
(
cx
lhs
lhsIndex
id
)
)
;
if
(
!
obj
)
{
return
false
;
}
RootedShape
oldShape
(
cx
obj
-
>
shape
(
)
)
;
RootedObjectGroup
oldGroup
(
cx
JSObject
:
:
getGroup
(
cx
obj
)
)
;
if
(
!
oldGroup
)
{
return
false
;
}
DeferType
deferType
=
DeferType
:
:
None
;
bool
attached
=
false
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
if
(
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetProp
stub
-
>
state
(
)
.
mode
(
)
lhs
idVal
rhs
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
SetProp
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
}
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
{
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
attached
=
true
;
break
;
case
AttachDecision
:
:
Deferred
:
deferType
=
gen
.
deferType
(
)
;
MOZ_ASSERT
(
deferType
!
=
DeferType
:
:
None
)
;
break
;
}
}
if
(
op
=
=
JSOp
:
:
InitProp
|
|
op
=
=
JSOp
:
:
InitLockedProp
|
|
op
=
=
JSOp
:
:
InitHiddenProp
)
{
if
(
!
InitPropertyOperation
(
cx
op
obj
name
rhs
)
)
{
return
false
;
}
}
else
if
(
op
=
=
JSOp
:
:
SetName
|
|
op
=
=
JSOp
:
:
StrictSetName
|
|
op
=
=
JSOp
:
:
SetGName
|
|
op
=
=
JSOp
:
:
StrictSetGName
)
{
if
(
!
SetNameOperation
(
cx
script
pc
obj
rhs
)
)
{
return
false
;
}
}
else
if
(
op
=
=
JSOp
:
:
InitGLexical
)
{
RootedValue
v
(
cx
rhs
)
;
LexicalEnvironmentObject
*
lexicalEnv
;
if
(
script
-
>
hasNonSyntacticScope
(
)
)
{
lexicalEnv
=
&
NearestEnclosingExtensibleLexicalEnvironment
(
frame
-
>
environmentChain
(
)
)
;
}
else
{
lexicalEnv
=
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
;
}
InitGlobalLexicalOperation
(
cx
lexicalEnv
script
pc
v
)
;
}
else
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
SetProp
|
|
op
=
=
JSOp
:
:
StrictSetProp
)
;
ObjectOpResult
result
;
if
(
!
SetProperty
(
cx
obj
id
rhs
lhs
result
)
|
|
!
result
.
checkStrictModeError
(
cx
obj
id
op
=
=
JSOp
:
:
StrictSetProp
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
stack
[
1
]
=
=
lhs
)
;
stack
[
1
]
=
rhs
;
if
(
attached
)
{
return
true
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
bool
canAttachStub
=
stub
-
>
state
(
)
.
canAttachStub
(
)
;
if
(
deferType
!
=
DeferType
:
:
None
&
&
canAttachStub
)
{
RootedValue
idVal
(
cx
StringValue
(
name
)
)
;
SetPropIRGenerator
gen
(
cx
script
pc
CacheKind
:
:
SetProp
stub
-
>
state
(
)
.
mode
(
)
lhs
idVal
rhs
)
;
MOZ_ASSERT
(
deferType
=
=
DeferType
:
:
AddSlot
)
;
AttachDecision
decision
=
gen
.
tryAttachAddSlotStub
(
oldGroup
oldShape
)
;
switch
(
decision
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
BaselineCacheIRStubKind
:
:
Updated
frame
-
>
script
(
)
stub
&
attached
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
SetElem
CacheIR
stub
"
)
;
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
if
(
gen
.
shouldNotePreliminaryObjectStub
(
)
)
{
newStub
-
>
toCacheIR_Updated
(
)
-
>
notePreliminaryObject
(
)
;
}
else
if
(
gen
.
shouldUnlinkPreliminaryObjectStubs
(
)
)
{
StripPreliminaryObjectStubs
(
cx
stub
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
gen
.
trackAttached
(
IRGenerator
:
:
NotAttached
)
;
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
attach
result
"
)
;
break
;
}
}
if
(
!
attached
&
&
canAttachStub
)
{
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_SetProp
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
storeValue
(
R0
Address
(
masm
.
getStackPointer
(
)
0
)
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
computeEffectiveAddress
(
Address
(
masm
.
getStackPointer
(
)
2
*
sizeof
(
Value
)
)
R0
.
scratchReg
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICSetProp_Fallback
*
Value
*
HandleValue
HandleValue
)
;
if
(
!
tailCallVM
<
Fn
DoSetPropFallback
>
(
masm
)
)
{
return
false
;
}
assumeStubFrame
(
)
;
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
SetProp
masm
.
currentOffset
(
)
)
;
leaveStubFrame
(
masm
true
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
bool
DoCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub
uint32_t
argc
Value
*
vp
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
Call
(
%
s
)
"
CodeName
(
op
)
)
;
MOZ_ASSERT
(
argc
=
=
GET_ARGC
(
pc
)
)
;
bool
constructing
=
(
op
=
=
JSOp
:
:
New
|
|
op
=
=
JSOp
:
:
SuperCall
)
;
bool
ignoresReturnValue
=
(
op
=
=
JSOp
:
:
CallIgnoresRv
)
;
size_t
numValues
=
argc
+
2
+
constructing
;
AutoArrayRooter
vpRoot
(
cx
numValues
vp
)
;
CallArgs
callArgs
=
CallArgsFromSp
(
argc
+
constructing
vp
+
numValues
constructing
ignoresReturnValue
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
newTarget
(
cx
constructing
?
callArgs
.
newTarget
(
)
:
NullValue
(
)
)
;
if
(
op
=
=
JSOp
:
:
FunApply
&
&
argc
=
=
2
&
&
callArgs
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
GuardFunApplyArgumentsOptimization
(
cx
frame
callArgs
)
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
bool
canAttachStub
=
stub
-
>
state
(
)
.
canAttachStub
(
)
;
bool
handled
=
false
;
bool
deferred
=
false
;
if
(
canAttachStub
)
{
HandleValueArray
args
=
HandleValueArray
:
:
fromMarkedLocation
(
argc
vp
+
2
)
;
CallIRGenerator
gen
(
cx
script
pc
op
stub
-
>
state
(
)
.
mode
(
)
argc
callee
callArgs
.
thisv
(
)
newTarget
args
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
gen
.
cacheIRStubKind
(
)
script
stub
&
handled
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
Call
CacheIR
stub
"
)
;
if
(
gen
.
cacheIRStubKind
(
)
=
=
BaselineCacheIRStubKind
:
:
Updated
)
{
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
}
}
}
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
handled
=
true
;
break
;
case
AttachDecision
:
:
Deferred
:
deferred
=
true
;
}
}
if
(
constructing
)
{
if
(
!
ConstructFromStack
(
cx
callArgs
)
)
{
return
false
;
}
res
.
set
(
callArgs
.
rval
(
)
)
;
}
else
if
(
(
op
=
=
JSOp
:
:
Eval
|
|
op
=
=
JSOp
:
:
StrictEval
)
&
&
cx
-
>
global
(
)
-
>
valueIsEval
(
callee
)
)
{
if
(
!
DirectEval
(
cx
callArgs
.
get
(
0
)
res
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
Call
|
|
op
=
=
JSOp
:
:
CallIgnoresRv
|
|
op
=
=
JSOp
:
:
CallIter
|
|
op
=
=
JSOp
:
:
FunCall
|
|
op
=
=
JSOp
:
:
FunApply
|
|
op
=
=
JSOp
:
:
Eval
|
|
op
=
=
JSOp
:
:
StrictEval
)
;
if
(
op
=
=
JSOp
:
:
CallIter
&
&
callee
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
argc
=
=
0
"
thisv
must
be
on
top
of
the
stack
"
)
;
ReportValueError
(
cx
JSMSG_NOT_ITERABLE
-
1
callArgs
.
thisv
(
)
nullptr
)
;
return
false
;
}
if
(
!
CallFromStack
(
cx
callArgs
)
)
{
return
false
;
}
res
.
set
(
callArgs
.
rval
(
)
)
;
}
if
(
!
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
)
{
return
false
;
}
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
canAttachStub
=
stub
-
>
state
(
)
.
canAttachStub
(
)
;
if
(
deferred
&
&
canAttachStub
)
{
HandleValueArray
args
=
HandleValueArray
:
:
fromMarkedLocation
(
argc
vp
+
2
)
;
CallIRGenerator
gen
(
cx
script
pc
op
stub
-
>
state
(
)
.
mode
(
)
argc
callee
callArgs
.
thisv
(
)
newTarget
args
)
;
switch
(
gen
.
tryAttachDeferredStub
(
res
)
)
{
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
gen
.
cacheIRStubKind
(
)
script
stub
&
handled
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
Call
CacheIR
stub
"
)
;
if
(
gen
.
cacheIRStubKind
(
)
=
=
BaselineCacheIRStubKind
:
:
Updated
)
{
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
}
}
}
break
;
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
Impossible
attach
decision
"
)
;
break
;
}
}
if
(
!
handled
&
&
canAttachStub
)
{
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
return
true
;
}
bool
DoSpreadCallFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCall_Fallback
*
stub
Value
*
vp
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
bool
constructing
=
(
op
=
=
JSOp
:
:
SpreadNew
|
|
op
=
=
JSOp
:
:
SpreadSuperCall
)
;
FallbackICSpew
(
cx
stub
"
SpreadCall
(
%
s
)
"
CodeName
(
op
)
)
;
AutoArrayRooter
vpRoot
(
cx
3
+
constructing
vp
)
;
RootedValue
callee
(
cx
vp
[
0
]
)
;
RootedValue
thisv
(
cx
vp
[
1
]
)
;
RootedValue
arr
(
cx
vp
[
2
]
)
;
RootedValue
newTarget
(
cx
constructing
?
vp
[
3
]
:
NullValue
(
)
)
;
if
(
stub
-
>
state
(
)
.
maybeTransition
(
)
)
{
stub
-
>
discardStubs
(
cx
)
;
}
bool
handled
=
false
;
if
(
op
!
=
JSOp
:
:
SpreadEval
&
&
op
!
=
JSOp
:
:
StrictSpreadEval
&
&
stub
-
>
state
(
)
.
canAttachStub
(
)
)
{
RootedArrayObject
aobj
(
cx
&
arr
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
)
;
MOZ_ASSERT
(
aobj
-
>
length
(
)
=
=
aobj
-
>
getDenseInitializedLength
(
)
)
;
HandleValueArray
args
=
HandleValueArray
:
:
fromMarkedLocation
(
aobj
-
>
length
(
)
aobj
-
>
getDenseElements
(
)
)
;
CallIRGenerator
gen
(
cx
script
pc
op
stub
-
>
state
(
)
.
mode
(
)
1
callee
thisv
newTarget
args
)
;
switch
(
gen
.
tryAttachStub
(
)
)
{
case
AttachDecision
:
:
NoAction
:
break
;
case
AttachDecision
:
:
Attach
:
{
ICStub
*
newStub
=
AttachBaselineCacheIRStub
(
cx
gen
.
writerRef
(
)
gen
.
cacheKind
(
)
gen
.
cacheIRStubKind
(
)
script
stub
&
handled
)
;
if
(
newStub
)
{
JitSpew
(
JitSpew_BaselineIC
"
Attached
Spread
Call
CacheIR
stub
"
)
;
if
(
gen
.
cacheIRStubKind
(
)
=
=
BaselineCacheIRStubKind
:
:
Updated
)
{
SetUpdateStubData
(
newStub
-
>
toCacheIR_Updated
(
)
gen
.
typeCheckInfo
(
)
)
;
}
}
}
break
;
case
AttachDecision
:
:
TemporarilyUnoptimizable
:
handled
=
true
;
break
;
case
AttachDecision
:
:
Deferred
:
MOZ_ASSERT_UNREACHABLE
(
"
No
deferred
optimizations
for
spread
calls
"
)
;
break
;
}
}
if
(
!
SpreadCallOperation
(
cx
script
pc
thisv
callee
arr
newTarget
res
)
)
{
return
false
;
}
return
TypeMonitorResult
(
cx
stub
frame
script
pc
res
)
;
}
void
ICStubCompilerBase
:
:
pushCallArguments
(
MacroAssembler
&
masm
AllocatableGeneralRegisterSet
regs
Register
argcReg
bool
isConstructing
)
{
MOZ_ASSERT
(
!
regs
.
has
(
argcReg
)
)
;
Register
argPtr
=
regs
.
takeAny
(
)
;
masm
.
moveStackPtrTo
(
argPtr
)
;
size_t
valueOffset
=
STUB_FRAME_SIZE
;
size_t
numNonArgValues
=
2
+
isConstructing
;
for
(
size_t
i
=
0
;
i
<
numNonArgValues
;
i
+
+
)
{
masm
.
pushValue
(
Address
(
argPtr
valueOffset
)
)
;
valueOffset
+
=
sizeof
(
Value
)
;
}
Label
done
;
masm
.
branchTest32
(
Assembler
:
:
Zero
argcReg
argcReg
&
done
)
;
Label
loop
;
Register
count
=
regs
.
takeAny
(
)
;
masm
.
addPtr
(
Imm32
(
valueOffset
)
argPtr
)
;
masm
.
move32
(
argcReg
count
)
;
masm
.
bind
(
&
loop
)
;
{
masm
.
pushValue
(
Address
(
argPtr
0
)
)
;
masm
.
addPtr
(
Imm32
(
sizeof
(
Value
)
)
argPtr
)
;
masm
.
branchSub32
(
Assembler
:
:
NonZero
Imm32
(
1
)
count
&
loop
)
;
}
masm
.
bind
(
&
done
)
;
}
bool
FallbackICCodeCompiler
:
:
emitCall
(
bool
isSpread
bool
isConstructing
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
AllocatableGeneralRegisterSet
regs
(
availableGeneralRegs
(
0
)
)
;
if
(
MOZ_UNLIKELY
(
isSpread
)
)
{
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
uint32_t
valueOffset
=
0
;
if
(
isConstructing
)
{
masm
.
pushValue
(
Address
(
BaselineFrameReg
STUB_FRAME_SIZE
)
)
;
valueOffset
+
+
;
}
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
valueOffset
+
+
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
valueOffset
+
+
;
masm
.
pushValue
(
Address
(
BaselineFrameReg
valueOffset
*
sizeof
(
Value
)
+
STUB_FRAME_SIZE
)
)
;
valueOffset
+
+
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
Value
*
MutableHandleValue
)
;
if
(
!
callVM
<
Fn
DoSpreadCallFallback
>
(
masm
)
)
{
return
false
;
}
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
return
true
;
}
enterStubFrame
(
masm
R1
.
scratchReg
(
)
)
;
regs
.
take
(
R0
.
scratchReg
(
)
)
;
pushCallArguments
(
masm
regs
R0
.
scratchReg
(
)
isConstructing
)
;
masm
.
push
(
masm
.
getStackPointer
(
)
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
PushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICCall_Fallback
*
uint32_t
Value
*
MutableHandleValue
)
;
if
(
!
callVM
<
Fn
DoCallFallback
>
(
masm
)
)
{
return
false
;
}
leaveStubFrame
(
masm
)
;
EmitReturnFromIC
(
masm
)
;
assumeStubFrame
(
)
;
MOZ_ASSERT
(
!
isSpread
)
;
if
(
isConstructing
)
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
New
masm
.
currentOffset
(
)
)
;
}
else
{
code
.
initBailoutReturnOffset
(
BailoutReturnKind
:
:
Call
masm
.
currentOffset
(
)
)
;
}
masm
.
loadValue
(
Address
(
masm
.
getStackPointer
(
)
3
*
sizeof
(
size_t
)
)
R1
)
;
leaveStubFrame
(
masm
true
)
;
if
(
isConstructing
)
{
static_assert
(
JSReturnOperand
=
=
R0
)
;
Label
skipThisReplace
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
moveValue
(
R1
R0
)
;
#
ifdef
DEBUG
masm
.
branchTestObject
(
Assembler
:
:
Equal
JSReturnOperand
&
skipThisReplace
)
;
masm
.
assumeUnreachable
(
"
Failed
to
return
object
in
constructing
call
.
"
)
;
#
endif
masm
.
bind
(
&
skipThisReplace
)
;
}
masm
.
loadPtr
(
Address
(
ICStubReg
ICMonitoredFallbackStub
:
:
offsetOfFallbackMonitorStub
(
)
)
ICStubReg
)
;
EmitEnterTypeMonitorIC
(
masm
ICTypeMonitor_Fallback
:
:
offsetOfFirstMonitorStub
(
)
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_Call
(
)
{
return
emitCall
(
false
false
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_CallConstructing
(
)
{
return
emitCall
(
false
true
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_SpreadCall
(
)
{
return
emitCall
(
true
false
)
;
}
bool
FallbackICCodeCompiler
:
:
emit_SpreadCallConstructing
(
)
{
return
emitCall
(
true
true
)
;
}
bool
DoGetIteratorFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICGetIterator_Fallback
*
stub
HandleValue
value
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
GetIterator
"
)
;
TryAttachStub
<
GetIteratorIRGenerator
>
(
"
GetIterator
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
value
)
;
JSObject
*
iterobj
=
ValueToIterator
(
cx
value
)
;
if
(
!
iterobj
)
{
return
false
;
}
res
.
setObject
(
*
iterobj
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_GetIterator
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICGetIterator_Fallback
*
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoGetIteratorFallback
>
(
masm
)
;
}
bool
DoInstanceOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICInstanceOf_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
InstanceOf
"
)
;
if
(
!
rhs
.
isObject
(
)
)
{
ReportValueError
(
cx
JSMSG_BAD_INSTANCEOF_RHS
-
1
rhs
nullptr
)
;
return
false
;
}
RootedObject
obj
(
cx
&
rhs
.
toObject
(
)
)
;
bool
cond
=
false
;
if
(
!
HasInstance
(
cx
obj
lhs
&
cond
)
)
{
return
false
;
}
res
.
setBoolean
(
cond
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
!
stub
-
>
state
(
)
.
hasFailures
(
)
)
{
stub
-
>
state
(
)
.
trackNotAttached
(
)
;
}
return
true
;
}
EnsureTrackPropertyTypes
(
cx
obj
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
TryAttachStub
<
InstanceOfIRGenerator
>
(
"
InstanceOf
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
lhs
obj
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_InstanceOf
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICInstanceOf_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoInstanceOfFallback
>
(
masm
)
;
}
bool
DoTypeOfFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICTypeOf_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
TypeOf
"
)
;
TryAttachStub
<
TypeOfIRGenerator
>
(
"
TypeOf
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
val
)
;
JSType
type
=
js
:
:
TypeOfValue
(
val
)
;
RootedString
string
(
cx
TypeName
(
type
cx
-
>
names
(
)
)
)
;
res
.
setString
(
string
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_TypeOf
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICTypeOf_Fallback
*
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoTypeOfFallback
>
(
masm
)
;
}
ICTypeMonitor_SingleObject
:
:
ICTypeMonitor_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeMonitor_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeMonitor_ObjectGroup
:
:
ICTypeMonitor_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeMonitor_ObjectGroup
stubCode
)
group_
(
group
)
{
}
ICTypeUpdate_SingleObject
:
:
ICTypeUpdate_SingleObject
(
JitCode
*
stubCode
JSObject
*
obj
)
:
ICStub
(
TypeUpdate_SingleObject
stubCode
)
obj_
(
obj
)
{
}
ICTypeUpdate_ObjectGroup
:
:
ICTypeUpdate_ObjectGroup
(
JitCode
*
stubCode
ObjectGroup
*
group
)
:
ICStub
(
TypeUpdate_ObjectGroup
stubCode
)
group_
(
group
)
{
}
bool
DoRestFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICRest_Fallback
*
stub
MutableHandleValue
res
)
{
unsigned
numFormals
=
frame
-
>
numFormalArgs
(
)
-
1
;
unsigned
numActuals
=
frame
-
>
numActualArgs
(
)
;
unsigned
numRest
=
numActuals
>
numFormals
?
numActuals
-
numFormals
:
0
;
Value
*
rest
=
frame
-
>
argv
(
)
+
numFormals
;
ArrayObject
*
obj
=
ObjectGroup
:
:
newArrayObject
(
cx
rest
numRest
GenericObject
ObjectGroup
:
:
NewArrayKind
:
:
UnknownIndex
)
;
if
(
!
obj
)
{
return
false
;
}
res
.
setObject
(
*
obj
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_Rest
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICRest_Fallback
*
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoRestFallback
>
(
masm
)
;
}
bool
DoUnaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICUnaryArith_Fallback
*
stub
HandleValue
val
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
UnaryArith
(
%
s
)
"
CodeName
(
op
)
)
;
switch
(
op
)
{
case
JSOp
:
:
BitNot
:
{
res
.
set
(
val
)
;
if
(
!
BitNot
(
cx
res
res
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Pos
:
{
res
.
set
(
val
)
;
if
(
!
ToNumber
(
cx
res
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Neg
:
{
res
.
set
(
val
)
;
if
(
!
NegOperation
(
cx
res
res
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Inc
:
{
if
(
!
IncOperation
(
cx
val
res
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Dec
:
{
if
(
!
DecOperation
(
cx
val
res
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
ToNumeric
:
{
res
.
set
(
val
)
;
if
(
!
ToNumeric
(
cx
res
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Unexpected
op
"
)
;
}
MOZ_ASSERT
(
res
.
isNumeric
(
)
)
;
if
(
res
.
isDouble
(
)
)
{
stub
-
>
setSawDoubleResult
(
)
;
}
TryAttachStub
<
UnaryArithIRGenerator
>
(
"
UnaryArith
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
op
val
res
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_UnaryArith
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICUnaryArith_Fallback
*
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoUnaryArithFallback
>
(
masm
)
;
}
bool
DoBinaryArithFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICBinaryArith_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
CacheIRBinaryArith
(
%
s
%
d
%
d
)
"
CodeName
(
op
)
int
(
lhs
.
isDouble
(
)
?
JSVAL_TYPE_DOUBLE
:
lhs
.
extractNonDoubleType
(
)
)
int
(
rhs
.
isDouble
(
)
?
JSVAL_TYPE_DOUBLE
:
rhs
.
extractNonDoubleType
(
)
)
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
RootedValue
rhsCopy
(
cx
rhs
)
;
switch
(
op
)
{
case
JSOp
:
:
Add
:
if
(
!
AddValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Sub
:
if
(
!
SubValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Mul
:
if
(
!
MulValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Div
:
if
(
!
DivValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Mod
:
if
(
!
ModValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Pow
:
if
(
!
PowValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
BitOr
:
{
if
(
!
BitOr
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
BitXor
:
{
if
(
!
BitXor
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
BitAnd
:
{
if
(
!
BitAnd
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Lsh
:
{
if
(
!
BitLsh
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Rsh
:
{
if
(
!
BitRsh
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
case
JSOp
:
:
Ursh
:
{
if
(
!
UrshValues
(
cx
&
lhsCopy
&
rhsCopy
ret
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Unhandled
baseline
arith
op
"
)
;
}
if
(
ret
.
isDouble
(
)
)
{
stub
-
>
setSawDoubleResult
(
)
;
}
TryAttachStub
<
BinaryArithIRGenerator
>
(
"
BinaryArith
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
op
lhs
rhs
ret
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_BinaryArith
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICBinaryArith_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoBinaryArithFallback
>
(
masm
)
;
}
bool
DoCompareFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICCompare_Fallback
*
stub
HandleValue
lhs
HandleValue
rhs
MutableHandleValue
ret
)
{
stub
-
>
incrementEnteredCount
(
)
;
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
FallbackICSpew
(
cx
stub
"
Compare
(
%
s
)
"
CodeName
(
op
)
)
;
RootedValue
lhsCopy
(
cx
lhs
)
;
RootedValue
rhsCopy
(
cx
rhs
)
;
bool
out
;
switch
(
op
)
{
case
JSOp
:
:
Lt
:
if
(
!
LessThan
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Le
:
if
(
!
LessThanOrEqual
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Gt
:
if
(
!
GreaterThan
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Ge
:
if
(
!
GreaterThanOrEqual
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Eq
:
if
(
!
LooselyEqual
<
EqualityKind
:
:
Equal
>
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
Ne
:
if
(
!
LooselyEqual
<
EqualityKind
:
:
NotEqual
>
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
StrictEq
:
if
(
!
StrictlyEqual
<
EqualityKind
:
:
Equal
>
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
case
JSOp
:
:
StrictNe
:
if
(
!
StrictlyEqual
<
EqualityKind
:
:
NotEqual
>
(
cx
&
lhsCopy
&
rhsCopy
&
out
)
)
{
return
false
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
baseline
compare
op
"
)
;
return
false
;
}
ret
.
setBoolean
(
out
)
;
TryAttachStub
<
CompareIRGenerator
>
(
"
Compare
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
op
lhs
rhs
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_Compare
(
)
{
static_assert
(
R0
=
=
JSReturnOperand
)
;
EmitRestoreTailCallReg
(
masm
)
;
masm
.
pushValue
(
R0
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R1
)
;
masm
.
pushValue
(
R0
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICCompare_Fallback
*
HandleValue
HandleValue
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoCompareFallback
>
(
masm
)
;
}
bool
DoNewArrayFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewArray_Fallback
*
stub
uint32_t
length
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
NewArray
"
)
;
RootedObject
obj
(
cx
)
;
if
(
stub
-
>
templateObject
(
)
)
{
RootedObject
templateObject
(
cx
stub
-
>
templateObject
(
)
)
;
obj
=
NewArrayOperationWithTemplate
(
cx
templateObject
)
;
if
(
!
obj
)
{
return
false
;
}
}
else
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
obj
=
NewArrayOperation
(
cx
script
pc
length
)
;
if
(
!
obj
)
{
return
false
;
}
if
(
!
obj
-
>
isSingleton
(
)
)
{
JSObject
*
templateObject
=
NewArrayOperation
(
cx
script
pc
length
TenuredObject
)
;
if
(
!
templateObject
)
{
return
false
;
}
stub
-
>
setTemplateObject
(
templateObject
)
;
}
}
res
.
setObject
(
*
obj
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_NewArray
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
R0
.
scratchReg
(
)
)
;
masm
.
push
(
ICStubReg
)
;
masm
.
pushBaselineFramePtr
(
BaselineFrameReg
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICNewArray_Fallback
*
uint32_t
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoNewArrayFallback
>
(
masm
)
;
}
bool
DoNewObjectFallback
(
JSContext
*
cx
BaselineFrame
*
frame
ICNewObject_Fallback
*
stub
MutableHandleValue
res
)
{
stub
-
>
incrementEnteredCount
(
)
;
FallbackICSpew
(
cx
stub
"
NewObject
"
)
;
RootedObject
obj
(
cx
)
;
RootedObject
templateObject
(
cx
stub
-
>
templateObject
(
)
)
;
if
(
templateObject
)
{
MOZ_ASSERT
(
!
templateObject
-
>
group
(
)
-
>
maybePreliminaryObjectsDontCheckGeneration
(
)
)
;
obj
=
NewObjectOperationWithTemplate
(
cx
templateObject
)
;
}
else
{
RootedScript
script
(
cx
frame
-
>
script
(
)
)
;
jsbytecode
*
pc
=
stub
-
>
icEntry
(
)
-
>
pc
(
script
)
;
obj
=
NewObjectOperation
(
cx
script
pc
)
;
if
(
obj
&
&
!
obj
-
>
isSingleton
(
)
&
&
!
obj
-
>
group
(
)
-
>
maybePreliminaryObjectsDontCheckGeneration
(
)
)
{
templateObject
=
NewObjectOperation
(
cx
script
pc
TenuredObject
)
;
if
(
!
templateObject
)
{
return
false
;
}
TryAttachStub
<
NewObjectIRGenerator
>
(
"
NewObject
"
cx
frame
stub
BaselineCacheIRStubKind
:
:
Regular
JSOp
(
*
pc
)
templateObject
)
;
stub
-
>
setTemplateObject
(
templateObject
)
;
}
}
if
(
!
obj
)
{
return
false
;
}
res
.
setObject
(
*
obj
)
;
return
true
;
}
bool
FallbackICCodeCompiler
:
:
emit_NewObject
(
)
{
EmitRestoreTailCallReg
(
masm
)
;
masm
.
push
(
ICStubReg
)
;
pushStubPayload
(
masm
R0
.
scratchReg
(
)
)
;
using
Fn
=
bool
(
*
)
(
JSContext
*
BaselineFrame
*
ICNewObject_Fallback
*
MutableHandleValue
)
;
return
tailCallVM
<
Fn
DoNewObjectFallback
>
(
masm
)
;
}
bool
JitRuntime
:
:
generateBaselineICFallbackCode
(
JSContext
*
cx
)
{
StackMacroAssembler
masm
;
BaselineICFallbackCode
&
fallbackCode
=
baselineICFallbackCode_
.
ref
(
)
;
FallbackICCodeCompiler
compiler
(
cx
fallbackCode
masm
)
;
JitSpew
(
JitSpew_Codegen
"
#
Emitting
Baseline
IC
fallback
code
"
)
;
#
define
EMIT_CODE
(
kind
)
\
{
\
uint32_t
offset
=
startTrampolineCode
(
masm
)
;
\
InitMacroAssemblerForICStub
(
masm
)
;
\
if
(
!
compiler
.
emit_
#
#
kind
(
)
)
{
\
return
false
;
\
}
\
fallbackCode
.
initOffset
(
BaselineICFallbackKind
:
:
kind
offset
)
;
\
}
IC_BASELINE_FALLBACK_CODE_KIND_LIST
(
EMIT_CODE
)
#
undef
EMIT_CODE
Linker
linker
(
masm
)
;
JitCode
*
code
=
linker
.
newCode
(
cx
CodeKind
:
:
Other
)
;
if
(
!
code
)
{
return
false
;
}
#
ifdef
JS_ION_PERF
writePerfSpewerJitCodeProfile
(
code
"
BaselineICFallback
"
)
;
#
endif
#
ifdef
MOZ_VTUNE
vtune
:
:
MarkStub
(
code
"
BaselineICFallback
"
)
;
#
endif
fallbackCode
.
initCode
(
code
)
;
return
true
;
}
}
}
