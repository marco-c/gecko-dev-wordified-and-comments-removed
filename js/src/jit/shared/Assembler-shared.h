#
ifndef
jit_shared_Assembler_shared_h
#
define
jit_shared_Assembler_shared_h
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
limits
.
h
>
#
include
"
asmjs
/
WasmTypes
.
h
"
#
include
"
jit
/
JitAllocPolicy
.
h
"
#
include
"
jit
/
Label
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
jit
/
RegisterSets
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
#
define
JS_USE_LINK_REGISTER
#
endif
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
#
define
JS_SMALL_BRANCH
#
endif
namespace
js
{
namespace
jit
{
namespace
Disassembler
{
class
HeapAccess
;
}
static
const
uint32_t
Simd128DataSize
=
4
*
sizeof
(
int32_t
)
;
static_assert
(
Simd128DataSize
=
=
4
*
sizeof
(
int32_t
)
"
SIMD
data
should
be
able
to
contain
int32x4
"
)
;
static_assert
(
Simd128DataSize
=
=
4
*
sizeof
(
float
)
"
SIMD
data
should
be
able
to
contain
float32x4
"
)
;
static_assert
(
Simd128DataSize
=
=
2
*
sizeof
(
double
)
"
SIMD
data
should
be
able
to
contain
float64x2
"
)
;
enum
Scale
{
TimesOne
=
0
TimesTwo
=
1
TimesFour
=
2
TimesEight
=
3
}
;
static_assert
(
sizeof
(
JS
:
:
Value
)
=
=
8
"
required
for
TimesEight
and
3
below
to
be
correct
"
)
;
static
const
Scale
ValueScale
=
TimesEight
;
static
const
size_t
ValueShift
=
3
;
static
inline
unsigned
ScaleToShift
(
Scale
scale
)
{
return
unsigned
(
scale
)
;
}
static
inline
bool
IsShiftInScaleRange
(
int
i
)
{
return
i
>
=
TimesOne
&
&
i
<
=
TimesEight
;
}
static
inline
Scale
ShiftToScale
(
int
i
)
{
MOZ_ASSERT
(
IsShiftInScaleRange
(
i
)
)
;
return
Scale
(
i
)
;
}
static
inline
Scale
ScaleFromElemWidth
(
int
shift
)
{
switch
(
shift
)
{
case
1
:
return
TimesOne
;
case
2
:
return
TimesTwo
;
case
4
:
return
TimesFour
;
case
8
:
return
TimesEight
;
}
MOZ_CRASH
(
"
Invalid
scale
"
)
;
}
struct
Imm32
{
int32_t
value
;
explicit
Imm32
(
int32_t
value
)
:
value
(
value
)
{
}
static
inline
Imm32
ShiftOf
(
enum
Scale
s
)
{
switch
(
s
)
{
case
TimesOne
:
return
Imm32
(
0
)
;
case
TimesTwo
:
return
Imm32
(
1
)
;
case
TimesFour
:
return
Imm32
(
2
)
;
case
TimesEight
:
return
Imm32
(
3
)
;
}
;
MOZ_CRASH
(
"
Invalid
scale
"
)
;
}
static
inline
Imm32
FactorOf
(
enum
Scale
s
)
{
return
Imm32
(
1
<
<
ShiftOf
(
s
)
.
value
)
;
}
}
;
struct
ImmWord
{
uintptr_t
value
;
explicit
ImmWord
(
uintptr_t
value
)
:
value
(
value
)
{
}
}
;
struct
Imm64
{
uint64_t
value
;
explicit
Imm64
(
uint64_t
value
)
:
value
(
value
)
{
}
}
;
#
ifdef
DEBUG
static
inline
bool
IsCompilingAsmJS
(
)
{
return
GetJitContext
(
)
-
>
compartment
=
=
nullptr
;
}
#
endif
struct
ImmPtr
{
void
*
value
;
explicit
ImmPtr
(
const
void
*
value
)
:
value
(
const_cast
<
void
*
>
(
value
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
template
<
class
R
>
explicit
ImmPtr
(
R
(
*
pf
)
(
)
)
:
value
(
JS_FUNC_TO_DATA_PTR
(
void
*
pf
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
template
<
class
R
class
A1
>
explicit
ImmPtr
(
R
(
*
pf
)
(
A1
)
)
:
value
(
JS_FUNC_TO_DATA_PTR
(
void
*
pf
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
template
<
class
R
class
A1
class
A2
>
explicit
ImmPtr
(
R
(
*
pf
)
(
A1
A2
)
)
:
value
(
JS_FUNC_TO_DATA_PTR
(
void
*
pf
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
template
<
class
R
class
A1
class
A2
class
A3
>
explicit
ImmPtr
(
R
(
*
pf
)
(
A1
A2
A3
)
)
:
value
(
JS_FUNC_TO_DATA_PTR
(
void
*
pf
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
template
<
class
R
class
A1
class
A2
class
A3
class
A4
>
explicit
ImmPtr
(
R
(
*
pf
)
(
A1
A2
A3
A4
)
)
:
value
(
JS_FUNC_TO_DATA_PTR
(
void
*
pf
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
}
;
struct
PatchedImmPtr
{
void
*
value
;
explicit
PatchedImmPtr
(
)
:
value
(
nullptr
)
{
}
explicit
PatchedImmPtr
(
const
void
*
value
)
:
value
(
const_cast
<
void
*
>
(
value
)
)
{
}
}
;
class
AssemblerShared
;
class
ImmGCPtr
;
class
ImmGCPtr
{
public
:
const
gc
:
:
Cell
*
value
;
explicit
ImmGCPtr
(
const
gc
:
:
Cell
*
ptr
)
:
value
(
ptr
)
{
MOZ_ASSERT_IF
(
ptr
&
&
!
ptr
-
>
isTenured
(
)
!
CurrentThreadIsIonCompilingSafeForMinorGC
(
)
)
;
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
private
:
ImmGCPtr
(
)
:
value
(
0
)
{
}
}
;
struct
AbsoluteAddress
{
void
*
addr
;
explicit
AbsoluteAddress
(
const
void
*
addr
)
:
addr
(
const_cast
<
void
*
>
(
addr
)
)
{
MOZ_ASSERT
(
!
IsCompilingAsmJS
(
)
)
;
}
AbsoluteAddress
offset
(
ptrdiff_t
delta
)
{
return
AbsoluteAddress
(
(
(
uint8_t
*
)
addr
)
+
delta
)
;
}
}
;
struct
PatchedAbsoluteAddress
{
void
*
addr
;
explicit
PatchedAbsoluteAddress
(
)
:
addr
(
nullptr
)
{
}
explicit
PatchedAbsoluteAddress
(
const
void
*
addr
)
:
addr
(
const_cast
<
void
*
>
(
addr
)
)
{
}
explicit
PatchedAbsoluteAddress
(
uintptr_t
addr
)
:
addr
(
reinterpret_cast
<
void
*
>
(
addr
)
)
{
}
}
;
struct
Address
{
Register
base
;
int32_t
offset
;
Address
(
Register
base
int32_t
offset
)
:
base
(
base
)
offset
(
offset
)
{
}
Address
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
}
;
struct
BaseIndex
{
Register
base
;
Register
index
;
Scale
scale
;
int32_t
offset
;
BaseIndex
(
Register
base
Register
index
Scale
scale
int32_t
offset
=
0
)
:
base
(
base
)
index
(
index
)
scale
(
scale
)
offset
(
offset
)
{
}
BaseIndex
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
}
;
struct
BaseValueIndex
:
BaseIndex
{
BaseValueIndex
(
Register
base
Register
index
int32_t
offset
=
0
)
:
BaseIndex
(
base
index
ValueScale
offset
)
{
}
}
;
struct
BaseObjectElementIndex
:
BaseValueIndex
{
BaseObjectElementIndex
(
Register
base
Register
index
int32_t
offset
=
0
)
:
BaseValueIndex
(
base
index
offset
)
{
NativeObject
:
:
elementsSizeMustNotOverflow
(
)
;
}
}
;
struct
BaseObjectSlotIndex
:
BaseValueIndex
{
BaseObjectSlotIndex
(
Register
base
Register
index
)
:
BaseValueIndex
(
base
index
)
{
NativeObject
:
:
slotsSizeMustNotOverflow
(
)
;
}
}
;
class
Relocation
{
public
:
enum
Kind
{
HARDCODED
JITCODE
}
;
}
;
class
RepatchLabel
{
static
const
int32_t
INVALID_OFFSET
=
0xC0000000
;
int32_t
offset_
:
31
;
uint32_t
bound_
:
1
;
public
:
RepatchLabel
(
)
:
offset_
(
INVALID_OFFSET
)
bound_
(
0
)
{
}
void
use
(
uint32_t
newOffset
)
{
MOZ_ASSERT
(
offset_
=
=
INVALID_OFFSET
)
;
MOZ_ASSERT
(
newOffset
!
=
(
uint32_t
)
INVALID_OFFSET
)
;
offset_
=
newOffset
;
}
bool
bound
(
)
const
{
return
bound_
;
}
void
bind
(
int32_t
dest
)
{
MOZ_ASSERT
(
!
bound_
)
;
MOZ_ASSERT
(
dest
!
=
INVALID_OFFSET
)
;
offset_
=
dest
;
bound_
=
true
;
}
int32_t
target
(
)
{
MOZ_ASSERT
(
bound
(
)
)
;
int32_t
ret
=
offset_
;
offset_
=
INVALID_OFFSET
;
return
ret
;
}
int32_t
offset
(
)
{
MOZ_ASSERT
(
!
bound
(
)
)
;
return
offset_
;
}
bool
used
(
)
const
{
return
!
bound
(
)
&
&
offset_
!
=
(
INVALID_OFFSET
)
;
}
}
;
struct
AbsoluteLabel
:
public
LabelBase
{
public
:
AbsoluteLabel
(
)
{
}
AbsoluteLabel
(
const
AbsoluteLabel
&
label
)
:
LabelBase
(
label
)
{
}
int32_t
prev
(
)
const
{
MOZ_ASSERT
(
!
bound
(
)
)
;
if
(
!
used
(
)
)
return
INVALID_OFFSET
;
return
offset
(
)
;
}
void
setPrev
(
int32_t
offset
)
{
use
(
offset
)
;
}
void
bind
(
)
{
bound_
=
true
;
offset_
=
-
1
;
}
}
;
class
CodeOffset
{
size_t
offset_
;
static
const
size_t
NOT_BOUND
=
size_t
(
-
1
)
;
public
:
explicit
CodeOffset
(
size_t
offset
)
:
offset_
(
offset
)
{
}
CodeOffset
(
)
:
offset_
(
NOT_BOUND
)
{
}
size_t
offset
(
)
const
{
MOZ_ASSERT
(
bound
(
)
)
;
return
offset_
;
}
void
bind
(
size_t
offset
)
{
MOZ_ASSERT
(
!
bound
(
)
)
;
offset_
=
offset
;
MOZ_ASSERT
(
bound
(
)
)
;
}
bool
bound
(
)
const
{
return
offset_
!
=
NOT_BOUND
;
}
void
offsetBy
(
size_t
delta
)
{
MOZ_ASSERT
(
bound
(
)
)
;
MOZ_ASSERT
(
offset_
+
delta
>
=
offset_
"
no
overflow
"
)
;
offset_
+
=
delta
;
}
}
;
class
CodeLabel
{
CodeOffset
patchAt_
;
CodeOffset
target_
;
public
:
CodeLabel
(
)
{
}
explicit
CodeLabel
(
const
CodeOffset
&
patchAt
)
:
patchAt_
(
patchAt
)
{
}
CodeLabel
(
const
CodeOffset
&
patchAt
const
CodeOffset
&
target
)
:
patchAt_
(
patchAt
)
target_
(
target
)
{
}
CodeOffset
*
patchAt
(
)
{
return
&
patchAt_
;
}
CodeOffset
*
target
(
)
{
return
&
target_
;
}
void
offsetBy
(
size_t
delta
)
{
patchAt_
.
offsetBy
(
delta
)
;
target_
.
offsetBy
(
delta
)
;
}
}
;
class
CodeOffsetJump
{
size_t
offset_
;
#
ifdef
JS_SMALL_BRANCH
size_t
jumpTableIndex_
;
#
endif
public
:
#
ifdef
JS_SMALL_BRANCH
CodeOffsetJump
(
size_t
offset
size_t
jumpTableIndex
)
:
offset_
(
offset
)
jumpTableIndex_
(
jumpTableIndex
)
{
}
size_t
jumpTableIndex
(
)
const
{
return
jumpTableIndex_
;
}
#
else
CodeOffsetJump
(
size_t
offset
)
:
offset_
(
offset
)
{
}
#
endif
CodeOffsetJump
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
size_t
offset
(
)
const
{
return
offset_
;
}
void
fixup
(
MacroAssembler
*
masm
)
;
}
;
class
CodeLocationJump
{
uint8_t
*
raw_
;
#
ifdef
DEBUG
enum
State
{
Uninitialized
Absolute
Relative
}
;
State
state_
;
void
setUninitialized
(
)
{
state_
=
Uninitialized
;
}
void
setAbsolute
(
)
{
state_
=
Absolute
;
}
void
setRelative
(
)
{
state_
=
Relative
;
}
#
else
void
setUninitialized
(
)
const
{
}
void
setAbsolute
(
)
const
{
}
void
setRelative
(
)
const
{
}
#
endif
#
ifdef
JS_SMALL_BRANCH
uint8_t
*
jumpTableEntry_
;
#
endif
public
:
CodeLocationJump
(
)
{
raw_
=
nullptr
;
setUninitialized
(
)
;
#
ifdef
JS_SMALL_BRANCH
jumpTableEntry_
=
(
uint8_t
*
)
0xdeadab1e
;
#
endif
}
CodeLocationJump
(
JitCode
*
code
CodeOffsetJump
base
)
{
*
this
=
base
;
repoint
(
code
)
;
}
void
operator
=
(
CodeOffsetJump
base
)
{
raw_
=
(
uint8_t
*
)
base
.
offset
(
)
;
setRelative
(
)
;
#
ifdef
JS_SMALL_BRANCH
jumpTableEntry_
=
(
uint8_t
*
)
base
.
jumpTableIndex
(
)
;
#
endif
}
void
repoint
(
JitCode
*
code
MacroAssembler
*
masm
=
nullptr
)
;
uint8_t
*
raw
(
)
const
{
MOZ_ASSERT
(
state_
=
=
Absolute
)
;
return
raw_
;
}
uint8_t
*
offset
(
)
const
{
MOZ_ASSERT
(
state_
=
=
Relative
)
;
return
raw_
;
}
#
ifdef
JS_SMALL_BRANCH
uint8_t
*
jumpTableEntry
(
)
const
{
MOZ_ASSERT
(
state_
=
=
Absolute
)
;
return
jumpTableEntry_
;
}
#
endif
}
;
class
CodeLocationLabel
{
uint8_t
*
raw_
;
#
ifdef
DEBUG
enum
State
{
Uninitialized
Absolute
Relative
}
;
State
state_
;
void
setUninitialized
(
)
{
state_
=
Uninitialized
;
}
void
setAbsolute
(
)
{
state_
=
Absolute
;
}
void
setRelative
(
)
{
state_
=
Relative
;
}
#
else
void
setUninitialized
(
)
const
{
}
void
setAbsolute
(
)
const
{
}
void
setRelative
(
)
const
{
}
#
endif
public
:
CodeLocationLabel
(
)
{
raw_
=
nullptr
;
setUninitialized
(
)
;
}
CodeLocationLabel
(
JitCode
*
code
CodeOffset
base
)
{
*
this
=
base
;
repoint
(
code
)
;
}
explicit
CodeLocationLabel
(
JitCode
*
code
)
{
raw_
=
code
-
>
raw
(
)
;
setAbsolute
(
)
;
}
explicit
CodeLocationLabel
(
uint8_t
*
raw
)
{
raw_
=
raw
;
setAbsolute
(
)
;
}
void
operator
=
(
CodeOffset
base
)
{
raw_
=
(
uint8_t
*
)
base
.
offset
(
)
;
setRelative
(
)
;
}
ptrdiff_t
operator
-
(
const
CodeLocationLabel
&
other
)
{
return
raw_
-
other
.
raw_
;
}
void
repoint
(
JitCode
*
code
MacroAssembler
*
masm
=
nullptr
)
;
#
ifdef
DEBUG
bool
isSet
(
)
const
{
return
state_
!
=
Uninitialized
;
}
#
endif
uint8_t
*
raw
(
)
const
{
MOZ_ASSERT
(
state_
=
=
Absolute
)
;
return
raw_
;
}
uint8_t
*
offset
(
)
const
{
MOZ_ASSERT
(
state_
=
=
Relative
)
;
return
raw_
;
}
}
;
struct
AsmJSFrame
{
uint8_t
*
callerFP
;
void
*
returnAddress
;
}
;
static_assert
(
sizeof
(
AsmJSFrame
)
=
=
2
*
sizeof
(
void
*
)
"
?
!
"
)
;
static
const
uint32_t
AsmJSFrameBytesAfterReturnAddress
=
sizeof
(
void
*
)
;
struct
AsmJSGlobalAccess
{
CodeOffset
patchAt
;
unsigned
globalDataOffset
;
AsmJSGlobalAccess
(
CodeOffset
patchAt
unsigned
globalDataOffset
)
:
patchAt
(
patchAt
)
globalDataOffset
(
globalDataOffset
)
{
}
}
;
struct
AsmJSAbsoluteAddress
{
AsmJSAbsoluteAddress
(
CodeOffset
patchAt
wasm
:
:
SymbolicAddress
target
)
:
patchAt
(
patchAt
)
target
(
target
)
{
}
CodeOffset
patchAt
;
wasm
:
:
SymbolicAddress
target
;
}
;
struct
AsmJSInternalCallee
{
uint32_t
index
;
AsmJSInternalCallee
(
)
=
default
;
explicit
AsmJSInternalCallee
(
uint32_t
calleeIndex
)
:
index
(
calleeIndex
)
{
}
}
;
class
AssemblerShared
{
wasm
:
:
CallSiteAndTargetVector
callsites_
;
wasm
:
:
JumpSiteArray
jumpsites_
;
wasm
:
:
HeapAccessVector
heapAccesses_
;
Vector
<
AsmJSGlobalAccess
0
SystemAllocPolicy
>
asmJSGlobalAccesses_
;
Vector
<
AsmJSAbsoluteAddress
0
SystemAllocPolicy
>
asmJSAbsoluteAddresses_
;
protected
:
Vector
<
CodeLabel
0
SystemAllocPolicy
>
codeLabels_
;
bool
enoughMemory_
;
bool
embedsNurseryPointers_
;
public
:
AssemblerShared
(
)
:
enoughMemory_
(
true
)
embedsNurseryPointers_
(
false
)
{
}
void
propagateOOM
(
bool
success
)
{
enoughMemory_
&
=
success
;
}
void
setOOM
(
)
{
enoughMemory_
=
false
;
}
bool
oom
(
)
const
{
return
!
enoughMemory_
;
}
bool
embedsNurseryPointers
(
)
const
{
return
embedsNurseryPointers_
;
}
void
append
(
const
wasm
:
:
CallSiteDesc
&
desc
CodeOffset
retAddr
size_t
framePushed
uint32_t
targetIndex
=
wasm
:
:
CallSiteAndTarget
:
:
NOT_INTERNAL
)
{
wasm
:
:
CallSite
callsite
(
desc
retAddr
.
offset
(
)
framePushed
+
sizeof
(
AsmJSFrame
)
)
;
enoughMemory_
&
=
callsites_
.
append
(
wasm
:
:
CallSiteAndTarget
(
callsite
targetIndex
)
)
;
}
wasm
:
:
CallSiteAndTargetVector
&
callSites
(
)
{
return
callsites_
;
}
void
append
(
wasm
:
:
JumpTarget
target
uint32_t
offset
)
{
enoughMemory_
&
=
jumpsites_
[
target
]
.
append
(
offset
)
;
}
const
wasm
:
:
JumpSiteArray
&
jumpSites
(
)
{
return
jumpsites_
;
}
void
clearJumpSites
(
)
{
for
(
auto
&
v
:
jumpsites_
)
v
.
clear
(
)
;
}
void
append
(
wasm
:
:
HeapAccess
access
)
{
enoughMemory_
&
=
heapAccesses_
.
append
(
access
)
;
}
wasm
:
:
HeapAccessVector
&
&
extractHeapAccesses
(
)
{
return
Move
(
heapAccesses_
)
;
}
void
append
(
AsmJSGlobalAccess
access
)
{
enoughMemory_
&
=
asmJSGlobalAccesses_
.
append
(
access
)
;
}
size_t
numAsmJSGlobalAccesses
(
)
const
{
return
asmJSGlobalAccesses_
.
length
(
)
;
}
AsmJSGlobalAccess
asmJSGlobalAccess
(
size_t
i
)
const
{
return
asmJSGlobalAccesses_
[
i
]
;
}
void
append
(
AsmJSAbsoluteAddress
link
)
{
enoughMemory_
&
=
asmJSAbsoluteAddresses_
.
append
(
link
)
;
}
size_t
numAsmJSAbsoluteAddresses
(
)
const
{
return
asmJSAbsoluteAddresses_
.
length
(
)
;
}
AsmJSAbsoluteAddress
asmJSAbsoluteAddress
(
size_t
i
)
const
{
return
asmJSAbsoluteAddresses_
[
i
]
;
}
static
bool
canUseInSingleByteInstruction
(
Register
reg
)
{
return
true
;
}
void
addCodeLabel
(
CodeLabel
label
)
{
propagateOOM
(
codeLabels_
.
append
(
label
)
)
;
}
size_t
numCodeLabels
(
)
const
{
return
codeLabels_
.
length
(
)
;
}
CodeLabel
codeLabel
(
size_t
i
)
{
return
codeLabels_
[
i
]
;
}
bool
asmMergeWith
(
size_t
delta
const
AssemblerShared
&
other
)
{
size_t
i
=
callsites_
.
length
(
)
;
enoughMemory_
&
=
callsites_
.
appendAll
(
other
.
callsites_
)
;
for
(
;
i
<
callsites_
.
length
(
)
;
i
+
+
)
callsites_
[
i
]
.
offsetReturnAddressBy
(
delta
)
;
for
(
wasm
:
:
JumpTarget
target
:
mozilla
:
:
MakeEnumeratedRange
(
wasm
:
:
JumpTarget
:
:
Limit
)
)
{
wasm
:
:
Uint32Vector
&
offsets
=
jumpsites_
[
target
]
;
i
=
offsets
.
length
(
)
;
enoughMemory_
&
=
offsets
.
appendAll
(
other
.
jumpsites_
[
target
]
)
;
for
(
;
i
<
offsets
.
length
(
)
;
i
+
+
)
offsets
[
i
]
+
=
delta
;
}
i
=
heapAccesses_
.
length
(
)
;
enoughMemory_
&
=
heapAccesses_
.
appendAll
(
other
.
heapAccesses_
)
;
for
(
;
i
<
heapAccesses_
.
length
(
)
;
i
+
+
)
heapAccesses_
[
i
]
.
offsetInsnOffsetBy
(
delta
)
;
i
=
asmJSGlobalAccesses_
.
length
(
)
;
enoughMemory_
&
=
asmJSGlobalAccesses_
.
appendAll
(
other
.
asmJSGlobalAccesses_
)
;
for
(
;
i
<
asmJSGlobalAccesses_
.
length
(
)
;
i
+
+
)
asmJSGlobalAccesses_
[
i
]
.
patchAt
.
offsetBy
(
delta
)
;
i
=
asmJSAbsoluteAddresses_
.
length
(
)
;
enoughMemory_
&
=
asmJSAbsoluteAddresses_
.
appendAll
(
other
.
asmJSAbsoluteAddresses_
)
;
for
(
;
i
<
asmJSAbsoluteAddresses_
.
length
(
)
;
i
+
+
)
asmJSAbsoluteAddresses_
[
i
]
.
patchAt
.
offsetBy
(
delta
)
;
i
=
codeLabels_
.
length
(
)
;
enoughMemory_
&
=
codeLabels_
.
appendAll
(
other
.
codeLabels_
)
;
for
(
;
i
<
codeLabels_
.
length
(
)
;
i
+
+
)
codeLabels_
[
i
]
.
offsetBy
(
delta
)
;
return
!
oom
(
)
;
}
}
;
}
}
#
endif
