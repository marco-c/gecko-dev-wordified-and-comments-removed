#
ifndef
jit_shared_BaselineCompiler_shared_h
#
define
jit_shared_BaselineCompiler_shared_h
#
include
"
jit
/
BaselineFrameInfo
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
BytecodeAnalysis
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
namespace
js
{
namespace
jit
{
class
BaselineCompilerShared
{
protected
:
JSContext
*
cx
;
JSScript
*
script
;
jsbytecode
*
pc
;
StackMacroAssembler
masm
;
bool
ionCompileable_
;
bool
compileDebugInstrumentation_
;
TempAllocator
&
alloc_
;
BytecodeAnalysis
analysis_
;
FrameInfo
frame
;
FallbackICStubSpace
stubSpace_
;
js
:
:
Vector
<
ICEntry
16
SystemAllocPolicy
>
icEntries_
;
struct
PCMappingEntry
{
uint32_t
pcOffset
;
uint32_t
nativeOffset
;
PCMappingSlotInfo
slotInfo
;
bool
addIndexEntry
;
}
;
js
:
:
Vector
<
PCMappingEntry
16
SystemAllocPolicy
>
pcMappingEntries_
;
struct
ICLoadLabel
{
size_t
icEntry
;
CodeOffset
label
;
}
;
js
:
:
Vector
<
ICLoadLabel
16
SystemAllocPolicy
>
icLoadLabels_
;
uint32_t
pushedBeforeCall_
;
#
ifdef
DEBUG
bool
inCall_
;
#
endif
CodeOffset
profilerPushToggleOffset_
;
CodeOffset
profilerEnterFrameToggleOffset_
;
CodeOffset
profilerExitFrameToggleOffset_
;
Vector
<
CodeOffset
>
traceLoggerToggleOffsets_
;
CodeOffset
traceLoggerScriptTextIdOffset_
;
BaselineCompilerShared
(
JSContext
*
cx
TempAllocator
&
alloc
JSScript
*
script
)
;
ICEntry
*
allocateICEntry
(
ICStub
*
stub
ICEntry
:
:
Kind
kind
)
{
if
(
!
stub
)
{
return
nullptr
;
}
if
(
!
icEntries_
.
append
(
ICEntry
(
script
-
>
pcToOffset
(
pc
)
kind
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
ICEntry
&
vecEntry
=
icEntries_
.
back
(
)
;
vecEntry
.
setFirstStub
(
stub
)
;
return
&
vecEntry
;
}
bool
appendICEntry
(
ICEntry
:
:
Kind
kind
uint32_t
returnOffset
)
{
ICEntry
entry
(
script
-
>
pcToOffset
(
pc
)
kind
)
;
entry
.
setReturnOffset
(
CodeOffset
(
returnOffset
)
)
;
if
(
!
icEntries_
.
append
(
entry
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
addICLoadLabel
(
CodeOffset
label
)
{
MOZ_ASSERT
(
!
icEntries_
.
empty
(
)
)
;
ICLoadLabel
loadLabel
;
loadLabel
.
label
=
label
;
loadLabel
.
icEntry
=
icEntries_
.
length
(
)
-
1
;
if
(
!
icLoadLabels_
.
append
(
loadLabel
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
JSFunction
*
function
(
)
const
{
return
script
-
>
functionNonDelazifying
(
)
;
}
ModuleObject
*
module
(
)
const
{
return
script
-
>
module
(
)
;
}
PCMappingSlotInfo
getStackTopSlotInfo
(
)
{
MOZ_ASSERT
(
frame
.
numUnsyncedSlots
(
)
<
=
2
)
;
switch
(
frame
.
numUnsyncedSlots
(
)
)
{
case
0
:
return
PCMappingSlotInfo
:
:
MakeSlotInfo
(
)
;
case
1
:
return
PCMappingSlotInfo
:
:
MakeSlotInfo
(
PCMappingSlotInfo
:
:
ToSlotLocation
(
frame
.
peek
(
-
1
)
)
)
;
case
2
:
default
:
return
PCMappingSlotInfo
:
:
MakeSlotInfo
(
PCMappingSlotInfo
:
:
ToSlotLocation
(
frame
.
peek
(
-
1
)
)
PCMappingSlotInfo
:
:
ToSlotLocation
(
frame
.
peek
(
-
2
)
)
)
;
}
}
template
<
typename
T
>
void
pushArg
(
const
T
&
t
)
{
masm
.
Push
(
t
)
;
}
void
prepareVMCall
(
)
;
enum
CallVMPhase
{
POST_INITIALIZE
PRE_INITIALIZE
CHECK_OVER_RECURSED
}
;
bool
callVM
(
const
VMFunction
&
fun
CallVMPhase
phase
=
POST_INITIALIZE
)
;
bool
callVMNonOp
(
const
VMFunction
&
fun
CallVMPhase
phase
=
POST_INITIALIZE
)
{
if
(
!
callVM
(
fun
phase
)
)
{
return
false
;
}
icEntries_
.
back
(
)
.
setFakeKind
(
ICEntry
:
:
Kind_NonOpCallVM
)
;
return
true
;
}
public
:
BytecodeAnalysis
&
analysis
(
)
{
return
analysis_
;
}
void
setCompileDebugInstrumentation
(
)
{
compileDebugInstrumentation_
=
true
;
}
}
;
}
}
#
endif
