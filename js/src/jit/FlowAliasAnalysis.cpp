#
include
"
jit
/
FlowAliasAnalysis
.
h
"
#
include
<
stdio
.
h
>
#
include
"
jit
/
AliasAnalysisShared
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
IonBuilder
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
MIR
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
vm
/
Printer
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
Array
;
namespace
js
{
namespace
jit
{
class
LoopInfo
:
public
TempObject
{
private
:
LoopInfo
*
outer_
;
MBasicBlock
*
loopHeader_
;
MDefinitionVector
loopinvariant_
;
public
:
LoopInfo
(
TempAllocator
&
alloc
LoopInfo
*
outer
MBasicBlock
*
loopHeader
)
:
outer_
(
outer
)
loopHeader_
(
loopHeader
)
loopinvariant_
(
alloc
)
{
}
MBasicBlock
*
loopHeader
(
)
const
{
return
loopHeader_
;
}
LoopInfo
*
outer
(
)
const
{
return
outer_
;
}
MDefinitionVector
&
loopinvariant
(
)
{
return
loopinvariant_
;
}
}
;
static
bool
KeepBlock
(
MBasicBlock
*
block
)
{
if
(
block
-
>
numSuccessors
(
)
=
=
1
&
&
block
-
>
getSuccessor
(
0
)
-
>
isLoopHeader
(
)
)
return
true
;
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
MOZ_ASSERT
(
!
block
-
>
getSuccessor
(
i
)
-
>
isLoopHeader
(
)
)
;
#
endif
return
false
;
}
class
GraphStoreInfo
:
public
TempObject
{
BlockStoreInfo
*
current_
;
GraphStoreVector
stores_
;
GraphStoreVector
empty_
;
public
:
explicit
GraphStoreInfo
(
TempAllocator
&
alloc
)
:
current_
(
nullptr
)
stores_
(
alloc
)
empty_
(
alloc
)
{
}
bool
reserve
(
size_t
num
)
{
return
stores_
.
appendN
(
nullptr
num
)
;
}
BlockStoreInfo
&
current
(
)
{
return
*
current_
;
}
void
unsetCurrent
(
)
{
current_
=
nullptr
;
}
BlockStoreInfo
*
newCurrent
(
TempAllocator
&
alloc
MBasicBlock
*
block
)
{
BlockStoreInfo
*
info
=
nullptr
;
if
(
empty_
.
length
(
)
!
=
0
)
{
info
=
empty_
.
popCopy
(
)
;
}
else
{
info
=
(
BlockStoreInfo
*
)
alloc
.
allocate
(
sizeof
(
BlockStoreInfo
)
)
;
if
(
!
info
)
return
nullptr
;
new
(
info
)
BlockStoreInfo
(
alloc
)
;
}
stores_
[
block
-
>
id
(
)
]
=
info
;
current_
=
info
;
return
current_
;
}
void
swap
(
MBasicBlock
*
block1
MBasicBlock
*
block2
)
{
BlockStoreInfo
*
info
=
stores_
[
block1
-
>
id
(
)
]
;
stores_
[
block1
-
>
id
(
)
]
=
stores_
[
block2
-
>
id
(
)
]
;
stores_
[
block2
-
>
id
(
)
]
=
info
;
if
(
stores_
[
block1
-
>
id
(
)
]
=
=
current_
)
current_
=
stores_
[
block2
-
>
id
(
)
]
;
else
if
(
stores_
[
block2
-
>
id
(
)
]
=
=
current_
)
current_
=
stores_
[
block1
-
>
id
(
)
]
;
}
bool
maybeFreePredecessorBlocks
(
MBasicBlock
*
block
)
{
for
(
size_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
if
(
KeepBlock
(
block
-
>
getPredecessor
(
i
)
)
)
continue
;
bool
release
=
true
;
for
(
size_t
j
=
0
;
j
<
block
-
>
getPredecessor
(
i
)
-
>
numSuccessors
(
)
;
j
+
+
)
{
if
(
block
-
>
getPredecessor
(
i
)
-
>
getSuccessor
(
j
)
-
>
id
(
)
>
block
-
>
id
(
)
)
{
release
=
false
;
break
;
}
}
if
(
release
)
{
BlockStoreInfo
*
info
=
stores_
[
block
-
>
getPredecessor
(
i
)
-
>
id
(
)
]
;
if
(
!
empty_
.
append
(
info
)
)
return
false
;
info
-
>
clear
(
)
;
stores_
[
block
-
>
getPredecessor
(
i
)
-
>
id
(
)
]
=
nullptr
;
}
}
return
true
;
}
BlockStoreInfo
&
get
(
MBasicBlock
*
block
)
{
MOZ_ASSERT
(
stores_
[
block
-
>
id
(
)
]
!
=
current_
)
;
return
*
stores_
[
block
-
>
id
(
)
]
;
}
}
;
}
}
FlowAliasAnalysis
:
:
FlowAliasAnalysis
(
MIRGenerator
*
mir
MIRGraph
&
graph
)
:
AliasAnalysisShared
(
mir
graph
)
loop_
(
nullptr
)
output_
(
graph_
.
alloc
(
)
)
worklist_
(
graph_
.
alloc
(
)
)
{
stores_
=
new
(
graph_
.
alloc
(
)
)
GraphStoreInfo
(
graph_
.
alloc
(
)
)
;
}
template
<
typename
T
>
static
bool
AppendToWorklist
(
MDefinitionVector
&
worklist
T
&
stores
)
{
if
(
!
worklist
.
reserve
(
worklist
.
length
(
)
+
stores
.
length
(
)
)
)
return
false
;
for
(
size_t
j
=
0
;
j
<
stores
.
length
(
)
;
j
+
+
)
{
MOZ_ASSERT
(
stores
[
j
]
)
;
if
(
stores
[
j
]
-
>
isInWorklist
(
)
)
continue
;
worklist
.
infallibleAppend
(
stores
[
j
]
)
;
stores
[
j
]
-
>
setInWorklist
(
)
;
}
return
true
;
}
static
void
SetNotInWorkList
(
MDefinitionVector
&
worklist
)
{
for
(
size_t
item
=
0
;
item
<
worklist
.
length
(
)
;
item
+
+
)
worklist
[
item
]
-
>
setNotInWorklistUnchecked
(
)
;
}
static
bool
LoadAliasesStore
(
MDefinition
*
load
MDefinition
*
store
)
{
if
(
store
-
>
id
(
)
=
=
0
)
return
true
;
if
(
store
-
>
isControlInstruction
(
)
)
return
true
;
if
(
(
load
-
>
getAliasSet
(
)
&
store
-
>
getAliasSet
(
)
)
.
isNone
(
)
)
return
false
;
MDefinition
:
:
AliasType
mightAlias
=
AliasAnalysisShared
:
:
genericMightAlias
(
load
store
)
;
if
(
mightAlias
=
=
MDefinition
:
:
AliasType
:
:
NoAlias
)
return
false
;
mightAlias
=
load
-
>
mightAlias
(
store
)
;
if
(
mightAlias
=
=
MDefinition
:
:
AliasType
:
:
NoAlias
)
return
false
;
return
true
;
}
#
ifdef
JS_JITSPEW
static
void
DumpAliasSet
(
AliasSet
set
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
if
(
set
.
flags
(
)
=
=
AliasSet
:
:
Any
)
{
print
.
printf
(
"
Any
"
)
;
return
;
}
bool
first
=
true
;
for
(
AliasSetIterator
iter
(
set
)
;
iter
;
iter
+
+
)
{
if
(
!
first
)
print
.
printf
(
"
"
)
;
print
.
printf
(
"
%
s
"
AliasSet
:
:
Name
(
*
iter
)
)
;
first
=
false
;
}
}
#
endif
#
ifdef
JS_JITSPEW
static
void
DumpStoreList
(
BlockStoreInfo
&
stores
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
if
(
stores
.
length
(
)
=
=
0
)
{
print
.
printf
(
"
empty
"
)
;
return
;
}
bool
first
=
true
;
for
(
size_t
i
=
0
;
i
<
stores
.
length
(
)
;
i
+
+
)
{
if
(
!
first
)
print
.
printf
(
"
"
)
;
if
(
!
stores
[
i
]
)
{
print
.
printf
(
"
nullptr
"
)
;
continue
;
}
MOZ_ASSERT
(
stores
[
i
]
-
>
isControlInstruction
(
)
|
|
stores
[
i
]
-
>
getAliasSet
(
)
.
isStore
(
)
|
|
stores
[
i
]
-
>
id
(
)
=
=
0
)
;
MDefinition
:
:
PrintOpcodeName
(
print
stores
[
i
]
-
>
op
(
)
)
;
print
.
printf
(
"
%
d
"
stores
[
i
]
-
>
id
(
)
)
;
first
=
false
;
}
}
#
endif
static
void
DumpAnalyzeStart
(
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
|
|
JitSpewEnabled
(
JitSpew_AliasSummaries
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpewEnabled
(
JitSpew_Alias
)
?
JitSpew_Alias
:
JitSpew_AliasSummaries
)
;
print
.
printf
(
"
Running
Alias
Analysis
on
graph
\
n
"
)
;
}
#
endif
}
static
void
DumpBlockStart
(
MBasicBlock
*
block
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
|
|
JitSpewEnabled
(
JitSpew_AliasSummaries
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpewEnabled
(
JitSpew_Alias
)
?
JitSpew_Alias
:
JitSpew_AliasSummaries
)
;
if
(
block
-
>
isLoopHeader
(
)
)
print
.
printf
(
"
Visiting
block
%
d
(
loopheader
)
\
n
"
block
-
>
id
(
)
)
;
else
print
.
printf
(
"
Visiting
block
%
d
\
n
"
block
-
>
id
(
)
)
;
}
#
endif
}
static
void
DumpProcessingDeferredLoads
(
MBasicBlock
*
loopHeader
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
print
.
printf
(
"
Process
deferred
loads
of
loop
%
d
\
n
"
loopHeader
-
>
id
(
)
)
;
}
#
endif
}
static
void
DumpBlockSummary
(
MBasicBlock
*
block
BlockStoreInfo
&
blockInfo
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_AliasSummaries
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_AliasSummaries
)
;
print
.
printf
(
"
Store
at
end
of
block
:
"
)
;
DumpStoreList
(
blockInfo
)
;
print
.
printf
(
"
\
n
"
)
;
}
#
endif
}
static
void
DumpStore
(
MDefinition
*
store
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
print
.
printf
(
"
Store
"
)
;
store
-
>
PrintOpcodeName
(
print
store
-
>
op
(
)
)
;
print
.
printf
(
"
%
d
with
flags
(
"
store
-
>
id
(
)
)
;
DumpAliasSet
(
store
-
>
getAliasSet
(
)
)
;
print
.
printf
(
"
)
\
n
"
)
;
}
#
endif
}
static
void
DumpLoad
(
MDefinition
*
load
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
print
.
printf
(
"
Load
"
)
;
load
-
>
PrintOpcodeName
(
print
load
-
>
op
(
)
)
;
print
.
printf
(
"
%
d
"
load
-
>
id
(
)
)
;
print
.
printf
(
"
with
flag
(
"
)
;
DumpAliasSet
(
load
-
>
getAliasSet
(
)
)
;
print
.
printf
(
"
)
\
n
"
)
;
}
#
endif
}
static
void
DumpLoadOutcome
(
MDefinition
*
load
MDefinitionVector
&
stores
bool
defer
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
print
.
printf
(
"
Marked
depending
on
"
)
;
DumpStoreList
(
stores
)
;
if
(
defer
)
print
.
printf
(
"
deferred
"
)
;
print
.
printf
(
"
\
n
"
)
;
}
#
endif
}
static
void
DumpLoopInvariant
(
MDefinition
*
load
MBasicBlock
*
loopheader
bool
loopinvariant
MDefinitionVector
&
loopInvariantDependency
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
if
(
!
loopinvariant
)
{
print
.
printf
(
"
Determine
not
loop
invariant
to
loop
%
d
.
\
n
"
loopheader
-
>
id
(
)
)
;
}
else
{
print
.
printf
(
"
Determine
loop
invariant
to
loop
%
d
.
Dependendy
is
now
:
"
loopheader
-
>
id
(
)
)
;
DumpStoreList
(
loopInvariantDependency
)
;
print
.
printf
(
"
\
n
"
)
;
}
}
#
endif
}
static
void
DumpImprovement
(
MDefinition
*
load
MDefinitionVector
&
input
MDefinitionVector
&
output
)
{
#
ifdef
JS_JITSPEW
if
(
JitSpewEnabled
(
JitSpew_Alias
)
)
{
Fprinter
&
print
=
JitSpewPrinter
(
)
;
JitSpewHeader
(
JitSpew_Alias
)
;
print
.
printf
(
"
Improve
dependency
from
%
d
"
load
-
>
id
(
)
)
;
DumpStoreList
(
input
)
;
print
.
printf
(
"
to
"
)
;
DumpStoreList
(
output
)
;
print
.
printf
(
"
\
n
"
)
;
}
#
endif
}
bool
FlowAliasAnalysis
:
:
analyze
(
)
{
DumpAnalyzeStart
(
)
;
uint32_t
newId
=
0
;
if
(
!
stores_
-
>
reserve
(
graph_
.
numBlocks
(
)
)
)
return
false
;
for
(
ReversePostorderIterator
block
(
graph_
.
rpoBegin
(
)
)
;
block
!
=
graph_
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Alias
Analysis
(
main
loop
)
"
)
)
return
false
;
DumpBlockStart
(
*
block
)
;
if
(
!
computeBlockStores
(
*
block
)
)
return
false
;
if
(
!
stores_
-
>
maybeFreePredecessorBlocks
(
*
block
)
)
return
false
;
if
(
block
-
>
isLoopHeader
(
)
)
loop_
=
new
(
alloc
(
)
)
LoopInfo
(
alloc
(
)
loop_
*
block
)
;
for
(
MPhiIterator
def
(
block
-
>
phisBegin
(
)
)
end
(
block
-
>
phisEnd
(
)
)
;
def
!
=
end
;
+
+
def
)
def
-
>
setId
(
newId
+
+
)
;
BlockStoreInfo
&
blockInfo
=
stores_
-
>
current
(
)
;
for
(
MInstructionIterator
def
(
block
-
>
begin
(
)
)
end
(
block
-
>
begin
(
block
-
>
lastIns
(
)
)
)
;
def
!
=
end
;
+
+
def
)
{
def
-
>
setId
(
newId
+
+
)
;
if
(
def
-
>
canRecoverOnBailout
(
)
)
continue
;
AliasSet
set
=
def
-
>
getAliasSet
(
)
;
if
(
set
.
isStore
(
)
)
{
if
(
!
processStore
(
blockInfo
*
def
)
)
return
false
;
}
else
if
(
set
.
isLoad
(
)
)
{
if
(
!
processLoad
(
blockInfo
*
def
)
)
return
false
;
}
}
block
-
>
lastIns
(
)
-
>
setId
(
newId
+
+
)
;
if
(
block
-
>
isLoopBackedge
(
)
)
{
stores_
-
>
unsetCurrent
(
)
;
LoopInfo
*
info
=
loop_
;
loop_
=
loop_
-
>
outer
(
)
;
if
(
!
processDeferredLoads
(
info
)
)
return
false
;
}
DumpBlockSummary
(
*
block
blockInfo
)
;
}
spewDependencyList
(
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
processStore
(
BlockStoreInfo
&
blockInfo
MDefinition
*
store
)
{
if
(
!
saveStoreDependency
(
store
blockInfo
)
)
return
false
;
blockInfo
.
clear
(
)
;
if
(
!
blockInfo
.
append
(
store
)
)
return
false
;
DumpStore
(
store
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
processLoad
(
BlockStoreInfo
&
blockInfo
MDefinition
*
load
)
{
DumpLoad
(
load
)
;
MDefinitionVector
&
dependencies
=
blockInfo
;
if
(
!
improveDependency
(
load
dependencies
output_
)
)
return
false
;
saveLoadDependency
(
load
output_
)
;
if
(
deferImproveDependency
(
output_
)
)
{
if
(
!
loop_
-
>
loopinvariant
(
)
.
append
(
load
)
)
return
false
;
DumpLoadOutcome
(
load
output_
true
)
;
return
true
;
}
DumpLoadOutcome
(
load
output_
false
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
processDeferredLoads
(
LoopInfo
*
info
)
{
DumpProcessingDeferredLoads
(
info
-
>
loopHeader
(
)
)
;
MOZ_ASSERT
(
loopIsFinished
(
info
-
>
loopHeader
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
info
-
>
loopinvariant
(
)
.
length
(
)
;
i
+
+
)
{
MDefinition
*
load
=
info
-
>
loopinvariant
(
)
[
i
]
;
DumpLoad
(
load
)
;
if
(
!
loopIsFinished
(
load
-
>
dependency
(
)
-
>
block
(
)
)
)
{
MOZ_ASSERT
(
loop_
)
;
if
(
!
loop_
-
>
loopinvariant
(
)
.
append
(
load
)
)
return
false
;
DumpLoadOutcome
(
load
output_
true
)
;
continue
;
}
MOZ_ASSERT
(
load
-
>
dependency
(
)
-
>
block
(
)
=
=
info
-
>
loopHeader
(
)
)
;
MDefinition
*
store
=
load
-
>
dependency
(
)
;
load
-
>
setDependency
(
nullptr
)
;
bool
loopinvariant
;
if
(
!
isLoopInvariant
(
load
store
&
loopinvariant
)
)
return
false
;
MDefinitionVector
&
loopInvariantDependency
=
stores_
-
>
get
(
store
-
>
block
(
)
-
>
loopPredecessor
(
)
)
;
DumpLoopInvariant
(
load
info
-
>
loopHeader
(
)
loopinvariant
loopInvariantDependency
)
;
if
(
loopinvariant
)
{
if
(
!
improveDependency
(
load
loopInvariantDependency
output_
)
)
return
false
;
saveLoadDependency
(
load
output_
)
;
if
(
deferImproveDependency
(
output_
)
)
{
if
(
!
loop_
-
>
loopinvariant
(
)
.
append
(
load
)
)
return
false
;
DumpLoadOutcome
(
load
output_
true
)
;
}
else
{
DumpLoadOutcome
(
load
output_
false
)
;
}
}
else
{
load
-
>
setDependency
(
store
)
;
#
ifdef
JS_JITSPEW
output_
.
clear
(
)
;
if
(
!
output_
.
append
(
store
)
)
return
false
;
DumpLoadOutcome
(
load
output_
false
)
;
#
endif
}
}
return
true
;
}
bool
FlowAliasAnalysis
:
:
improveDependency
(
MDefinition
*
load
MDefinitionVector
&
inputStores
MDefinitionVector
&
outputStores
)
{
MOZ_ASSERT
(
inputStores
.
length
(
)
>
0
)
;
outputStores
.
clear
(
)
;
if
(
!
outputStores
.
appendAll
(
inputStores
)
)
return
false
;
bool
improved
=
false
;
bool
adjusted
=
true
;
while
(
adjusted
)
{
adjusted
=
false
;
if
(
!
improveNonAliasedStores
(
load
outputStores
outputStores
&
improved
)
)
return
false
;
MOZ_ASSERT
(
outputStores
.
length
(
)
!
=
0
)
;
if
(
!
improveStoresInFinishedLoops
(
load
outputStores
&
adjusted
)
)
return
false
;
if
(
adjusted
)
improved
=
true
;
}
if
(
improved
)
DumpImprovement
(
load
inputStores
outputStores
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
improveNonAliasedStores
(
MDefinition
*
load
MDefinitionVector
&
inputStores
MDefinitionVector
&
outputStores
bool
*
improved
bool
onlyControlInstructions
)
{
MOZ_ASSERT
(
worklist_
.
length
(
)
=
=
0
)
;
if
(
!
AppendToWorklist
(
worklist_
inputStores
)
)
return
false
;
outputStores
.
clear
(
)
;
for
(
size_t
i
=
0
;
i
<
worklist_
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
worklist_
[
i
]
)
;
if
(
!
LoadAliasesStore
(
load
worklist_
[
i
]
)
)
{
StoreDependency
*
dep
=
worklist_
[
i
]
-
>
storeDependency
(
)
;
MOZ_ASSERT
(
dep
)
;
MOZ_ASSERT
(
dep
-
>
get
(
)
.
length
(
)
>
0
)
;
if
(
!
AppendToWorklist
(
worklist_
dep
-
>
get
(
)
)
)
return
false
;
*
improved
=
true
;
continue
;
}
if
(
onlyControlInstructions
&
&
!
worklist_
[
i
]
-
>
isControlInstruction
(
)
)
{
outputStores
.
clear
(
)
;
break
;
}
if
(
!
outputStores
.
append
(
worklist_
[
i
]
)
)
return
false
;
}
SetNotInWorkList
(
worklist_
)
;
worklist_
.
clear
(
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
improveLoopDependency
(
MDefinition
*
load
MDefinitionVector
&
inputStores
MDefinitionVector
&
outputStores
)
{
outputStores
.
clear
(
)
;
if
(
!
outputStores
.
appendAll
(
inputStores
)
)
return
false
;
bool
improved
=
false
;
bool
adjusted
=
true
;
while
(
adjusted
)
{
adjusted
=
false
;
if
(
!
improveNonAliasedStores
(
load
outputStores
outputStores
&
improved
true
)
)
{
return
false
;
}
if
(
outputStores
.
length
(
)
=
=
0
)
return
true
;
if
(
!
improveStoresInFinishedLoops
(
load
outputStores
&
adjusted
)
)
return
false
;
if
(
adjusted
)
improved
=
true
;
}
if
(
improved
)
DumpImprovement
(
load
inputStores
outputStores
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
improveStoresInFinishedLoops
(
MDefinition
*
load
MDefinitionVector
&
stores
bool
*
improved
)
{
for
(
size_t
i
=
0
;
i
<
stores
.
length
(
)
;
i
+
+
)
{
if
(
!
stores
[
i
]
-
>
isControlInstruction
(
)
)
continue
;
if
(
!
stores
[
i
]
-
>
block
(
)
-
>
isLoopHeader
(
)
)
continue
;
MOZ_ASSERT
(
!
stores
[
i
]
-
>
storeDependency
(
)
)
;
if
(
!
loopIsFinished
(
stores
[
i
]
-
>
block
(
)
)
)
continue
;
if
(
load
-
>
dependency
(
)
=
=
stores
[
i
]
)
continue
;
bool
loopinvariant
;
if
(
!
isLoopInvariant
(
load
stores
[
i
]
&
loopinvariant
)
)
return
false
;
if
(
!
loopinvariant
)
continue
;
MBasicBlock
*
pred
=
stores
[
i
]
-
>
block
(
)
-
>
loopPredecessor
(
)
;
BlockStoreInfo
&
predInfo
=
stores_
-
>
get
(
pred
)
;
MOZ_ASSERT
(
predInfo
.
length
(
)
>
0
)
;
stores
[
i
]
=
predInfo
[
0
]
;
for
(
size_t
j
=
1
;
j
<
predInfo
.
length
(
)
;
j
+
+
)
{
if
(
!
stores
.
append
(
predInfo
[
j
]
)
)
return
false
;
}
*
improved
=
true
;
}
return
true
;
}
bool
FlowAliasAnalysis
:
:
deferImproveDependency
(
MDefinitionVector
&
stores
)
{
return
loop_
&
&
stores
.
length
(
)
=
=
1
&
&
stores
[
0
]
-
>
isControlInstruction
(
)
&
&
stores
[
0
]
-
>
block
(
)
-
>
isLoopHeader
(
)
&
&
!
loopIsFinished
(
stores
[
0
]
-
>
block
(
)
)
;
}
void
FlowAliasAnalysis
:
:
saveLoadDependency
(
MDefinition
*
load
MDefinitionVector
&
dependencies
)
{
MOZ_ASSERT
(
dependencies
.
length
(
)
>
0
)
;
MDefinition
*
max
=
dependencies
[
0
]
;
MDefinition
*
maxNonControl
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
dependencies
.
length
(
)
;
i
+
+
)
{
MDefinition
*
ins
=
dependencies
[
i
]
;
if
(
max
-
>
id
(
)
<
ins
-
>
id
(
)
)
max
=
ins
;
if
(
!
ins
-
>
isControlInstruction
(
)
)
{
if
(
!
maxNonControl
|
|
maxNonControl
-
>
id
(
)
<
ins
-
>
id
(
)
)
maxNonControl
=
ins
;
}
}
if
(
maxNonControl
!
=
max
&
&
maxNonControl
)
{
if
(
maxNonControl
-
>
block
(
)
=
=
max
-
>
block
(
)
)
max
=
maxNonControl
;
}
load
-
>
setDependency
(
max
)
;
}
bool
FlowAliasAnalysis
:
:
saveStoreDependency
(
MDefinition
*
ins
BlockStoreInfo
&
prevStores
)
{
StoreDependency
*
dependency
=
new
(
alloc
(
)
)
StoreDependency
(
alloc
(
)
)
;
if
(
!
dependency
)
return
false
;
if
(
!
dependency
-
>
init
(
prevStores
)
)
return
false
;
ins
-
>
setStoreDependency
(
dependency
)
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
loopIsFinished
(
MBasicBlock
*
loopheader
)
{
MOZ_ASSERT
(
loopheader
-
>
isLoopHeader
(
)
)
;
if
(
!
loop_
)
return
true
;
return
loopheader
-
>
backedge
(
)
-
>
id
(
)
<
loop_
-
>
loopHeader
(
)
-
>
backedge
(
)
-
>
id
(
)
;
}
bool
FlowAliasAnalysis
:
:
isLoopInvariant
(
MDefinition
*
load
MDefinition
*
store
bool
*
loopinvariant
)
{
MOZ_ASSERT
(
store
-
>
isControlInstruction
(
)
)
;
MOZ_ASSERT
(
!
store
-
>
storeDependency
(
)
)
;
MOZ_ASSERT
(
store
-
>
block
(
)
-
>
isLoopHeader
(
)
)
;
MOZ_ASSERT
(
loopIsFinished
(
store
-
>
block
(
)
)
)
;
*
loopinvariant
=
false
;
MBasicBlock
*
backedge
=
store
-
>
block
(
)
-
>
backedge
(
)
;
MDefinitionVector
output
(
alloc
(
)
)
;
MDefinition
*
olddep
=
load
-
>
dependency
(
)
;
load
-
>
setDependency
(
store
)
;
if
(
!
improveLoopDependency
(
load
stores_
-
>
get
(
backedge
)
output
)
)
return
false
;
load
-
>
setDependency
(
olddep
)
;
if
(
output
.
length
(
)
=
=
0
)
return
true
;
for
(
size_t
i
=
0
;
i
<
output
.
length
(
)
;
i
+
+
)
{
if
(
output
[
i
]
-
>
storeDependency
(
)
)
return
true
;
if
(
!
output
[
i
]
-
>
isControlInstruction
(
)
)
return
true
;
if
(
!
output
[
i
]
-
>
block
(
)
-
>
isLoopHeader
(
)
)
return
true
;
if
(
output
[
i
]
=
=
store
)
continue
;
return
true
;
}
*
loopinvariant
=
true
;
return
true
;
}
bool
FlowAliasAnalysis
:
:
computeBlockStores
(
MBasicBlock
*
block
)
{
BlockStoreInfo
*
blockInfo
=
stores_
-
>
newCurrent
(
alloc
(
)
block
)
;
if
(
!
blockInfo
)
return
false
;
if
(
block
-
>
id
(
)
=
=
0
)
{
MDefinition
*
firstIns
=
*
graph_
.
entryBlock
(
)
-
>
begin
(
)
;
if
(
!
blockInfo
-
>
append
(
firstIns
)
)
return
false
;
return
true
;
}
if
(
block
-
>
isLoopHeader
(
)
)
{
if
(
!
blockInfo
-
>
append
(
block
-
>
lastIns
(
)
)
)
return
false
;
return
true
;
}
if
(
block
-
>
numPredecessors
(
)
=
=
1
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
0
)
;
if
(
pred
-
>
numSuccessors
(
)
=
=
1
)
{
stores_
-
>
swap
(
block
pred
)
;
return
true
;
}
MOZ_ASSERT
(
pred
-
>
numSuccessors
(
)
>
1
)
;
BlockStoreInfo
&
predInfo
=
stores_
-
>
get
(
pred
)
;
return
blockInfo
-
>
appendAll
(
predInfo
)
;
}
if
(
block
-
>
numPredecessors
(
)
>
5
)
{
if
(
!
blockInfo
-
>
append
(
block
-
>
getPredecessor
(
0
)
-
>
lastIns
(
)
)
)
return
false
;
return
true
;
}
for
(
size_t
pred
=
0
;
pred
<
block
-
>
numPredecessors
(
)
;
pred
+
+
)
{
BlockStoreInfo
&
predInfo
=
stores_
-
>
get
(
block
-
>
getPredecessor
(
pred
)
)
;
if
(
!
AppendToWorklist
(
*
blockInfo
predInfo
)
)
return
false
;
}
SetNotInWorkList
(
*
blockInfo
)
;
return
true
;
}
