#
ifndef
jit_IonCompileTask_h
#
define
jit_IonCompileTask_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
js
{
class
CompilerConstraintList
;
namespace
jit
{
class
CodeGenerator
;
class
MRootList
;
class
IonCompileTask
final
:
public
HelperThreadTask
public
mozilla
:
:
LinkedListElement
<
IonCompileTask
>
{
MIRGenerator
&
mirGen_
;
CodeGenerator
*
backgroundCodegen_
=
nullptr
;
CompilerConstraintList
*
constraints_
=
nullptr
;
MRootList
*
rootList_
=
nullptr
;
WarpSnapshot
*
snapshot_
=
nullptr
;
bool
scriptHasIonScript_
;
public
:
explicit
IonCompileTask
(
MIRGenerator
&
mirGen
bool
scriptHasIonScript
CompilerConstraintList
*
constraints
WarpSnapshot
*
snapshot
)
;
JSScript
*
script
(
)
{
return
mirGen_
.
outerInfo
(
)
.
script
(
)
;
}
MIRGenerator
&
mirGen
(
)
{
return
mirGen_
;
}
TempAllocator
&
alloc
(
)
{
return
mirGen_
.
alloc
(
)
;
}
bool
scriptHasIonScript
(
)
const
{
return
scriptHasIonScript_
;
}
CompilerConstraintList
*
constraints
(
)
{
return
constraints_
;
}
WarpSnapshot
*
snapshot
(
)
{
return
snapshot_
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
void
trace
(
JSTracer
*
trc
)
;
void
setRootList
(
MRootList
&
rootList
)
{
MOZ_ASSERT
(
!
rootList_
)
;
rootList_
=
&
rootList
;
}
CodeGenerator
*
backgroundCodegen
(
)
const
{
return
backgroundCodegen_
;
}
void
setBackgroundCodegen
(
CodeGenerator
*
codegen
)
{
backgroundCodegen_
=
codegen
;
}
void
runTaskLocked
(
AutoLockHelperThreadState
&
locked
)
override
;
ThreadType
threadType
(
)
override
{
return
THREAD_TYPE_ION
;
}
void
runTask
(
)
;
}
;
void
AttachFinishedCompilations
(
JSContext
*
cx
)
;
void
FinishOffThreadTask
(
JSRuntime
*
runtime
IonCompileTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
FreeIonCompileTask
(
IonCompileTask
*
task
)
;
MOZ_MUST_USE
bool
CreateMIRRootList
(
IonCompileTask
&
task
)
;
}
}
#
endif
