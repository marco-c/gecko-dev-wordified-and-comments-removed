#
ifndef
jit_ExecutableAllocator_h
#
define
jit_ExecutableAllocator_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
<
limits
>
#
include
<
stddef
.
h
>
#
include
"
jit
/
ProcessExecutableMemory
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
JS
{
struct
CodeSizes
;
}
namespace
js
{
namespace
jit
{
enum
class
CodeKind
:
uint8_t
{
Ion
Baseline
RegExp
Other
Count
}
;
class
ExecutableAllocator
;
class
ExecutablePool
{
friend
class
ExecutableAllocator
;
private
:
struct
Allocation
{
char
*
pages
;
size_t
size
;
}
;
ExecutableAllocator
*
m_allocator
;
char
*
m_freePtr
;
char
*
m_end
;
Allocation
m_allocation
;
unsigned
m_refCount
:
31
;
bool
m_mark
:
1
;
mozilla
:
:
EnumeratedArray
<
CodeKind
size_t
CodeKind
:
:
Count
>
m_codeBytes
;
public
:
void
release
(
bool
willDestroy
=
false
)
;
void
release
(
size_t
n
CodeKind
kind
)
;
void
addRef
(
)
;
ExecutablePool
(
ExecutableAllocator
*
allocator
Allocation
a
)
:
m_allocator
(
allocator
)
m_freePtr
(
a
.
pages
)
m_end
(
m_freePtr
+
a
.
size
)
m_allocation
(
a
)
m_refCount
(
1
)
m_mark
(
false
)
{
for
(
size_t
&
count
:
m_codeBytes
)
{
count
=
0
;
}
}
~
ExecutablePool
(
)
;
void
mark
(
)
{
MOZ_ASSERT
(
!
m_mark
)
;
m_mark
=
true
;
}
void
unmark
(
)
{
MOZ_ASSERT
(
m_mark
)
;
m_mark
=
false
;
}
bool
isMarked
(
)
const
{
return
m_mark
;
}
private
:
ExecutablePool
(
const
ExecutablePool
&
)
=
delete
;
void
operator
=
(
const
ExecutablePool
&
)
=
delete
;
void
*
alloc
(
size_t
n
CodeKind
kind
)
;
size_t
available
(
)
const
;
size_t
usedCodeBytes
(
)
const
{
size_t
res
=
0
;
for
(
size_t
count
:
m_codeBytes
)
{
res
+
=
count
;
}
return
res
;
}
}
;
struct
JitPoisonRange
{
jit
:
:
ExecutablePool
*
pool
;
void
*
start
;
size_t
size
;
JitPoisonRange
(
jit
:
:
ExecutablePool
*
pool
void
*
start
size_t
size
)
:
pool
(
pool
)
start
(
start
)
size
(
size
)
{
}
}
;
typedef
Vector
<
JitPoisonRange
0
SystemAllocPolicy
>
JitPoisonRangeVector
;
class
ExecutableAllocator
{
public
:
ExecutableAllocator
(
)
=
default
;
~
ExecutableAllocator
(
)
;
void
purge
(
)
;
void
*
alloc
(
JSContext
*
cx
size_t
n
ExecutablePool
*
*
poolp
CodeKind
type
)
;
void
releasePoolPages
(
ExecutablePool
*
pool
)
;
void
addSizeOfCode
(
JS
:
:
CodeSizes
*
sizes
)
const
;
private
:
static
const
size_t
OVERSIZE_ALLOCATION
=
size_t
(
-
1
)
;
static
size_t
roundUpAllocationSize
(
size_t
request
size_t
granularity
)
;
ExecutablePool
:
:
Allocation
systemAlloc
(
size_t
n
)
;
static
void
systemRelease
(
const
ExecutablePool
:
:
Allocation
&
alloc
)
;
ExecutablePool
*
createPool
(
size_t
n
)
;
ExecutablePool
*
poolForSize
(
size_t
n
)
;
static
void
reprotectPool
(
JSRuntime
*
rt
ExecutablePool
*
pool
ProtectionSetting
protection
MustFlushICache
flushICache
)
;
public
:
[
[
nodiscard
]
]
static
bool
makeWritable
(
void
*
start
size_t
size
)
{
return
ReprotectRegion
(
start
size
ProtectionSetting
:
:
Writable
MustFlushICache
:
:
No
)
;
}
[
[
nodiscard
]
]
static
bool
makeExecutableAndFlushICache
(
void
*
start
size_t
size
)
{
return
ReprotectRegion
(
start
size
ProtectionSetting
:
:
Executable
MustFlushICache
:
:
Yes
)
;
}
static
void
poisonCode
(
JSRuntime
*
rt
JitPoisonRangeVector
&
ranges
)
;
private
:
ExecutableAllocator
(
const
ExecutableAllocator
&
)
=
delete
;
void
operator
=
(
const
ExecutableAllocator
&
)
=
delete
;
static
const
size_t
maxSmallPools
=
4
;
typedef
js
:
:
Vector
<
ExecutablePool
*
maxSmallPools
js
:
:
SystemAllocPolicy
>
SmallExecPoolVector
;
SmallExecPoolVector
m_smallPools
;
typedef
js
:
:
HashSet
<
ExecutablePool
*
js
:
:
DefaultHasher
<
ExecutablePool
*
>
js
:
:
SystemAllocPolicy
>
ExecPoolHashSet
;
ExecPoolHashSet
m_pools
;
}
;
}
}
#
endif
