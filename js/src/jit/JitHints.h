#
ifndef
jit_JitHints_h
#
define
jit_JitHints_h
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
vm
/
BytecodeLocation
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
:
:
jit
{
class
JitHintsMap
{
using
ScriptKey
=
HashNumber
;
ScriptKey
getScriptKey
(
JSScript
*
script
)
const
;
class
IonHint
:
public
mozilla
:
:
LinkedListElement
<
IonHint
>
{
ScriptKey
key_
=
0
;
uint32_t
threshold_
=
0
;
Vector
<
uint32_t
0
SystemAllocPolicy
>
monomorphicInlineOffsets
;
public
:
explicit
IonHint
(
ScriptKey
key
)
{
key_
=
key
;
}
void
initThreshold
(
uint32_t
threshold
)
{
threshold_
=
threshold
;
}
uint32_t
threshold
(
)
{
return
threshold_
;
}
void
incThreshold
(
uint32_t
inc
)
{
uint32_t
newThreshold
=
threshold
(
)
+
inc
;
threshold_
=
(
newThreshold
>
JitOptions
.
normalIonWarmUpThreshold
)
?
JitOptions
.
normalIonWarmUpThreshold
:
newThreshold
;
}
bool
hasSpaceForMonomorphicInlineEntry
(
)
{
return
monomorphicInlineOffsets
.
length
(
)
<
MonomorphicInlineMaxEntries
;
}
bool
hasMonomorphicInlineOffset
(
uint32_t
offset
)
{
for
(
uint32_t
iterOffset
:
monomorphicInlineOffsets
)
{
if
(
iterOffset
=
=
offset
)
{
return
true
;
}
}
return
false
;
}
bool
addMonomorphicInlineOffset
(
uint32_t
newOffset
)
{
MOZ_ASSERT
(
hasSpaceForMonomorphicInlineEntry
(
)
)
;
if
(
hasMonomorphicInlineOffset
(
newOffset
)
)
{
return
true
;
}
return
monomorphicInlineOffsets
.
append
(
newOffset
)
;
}
ScriptKey
key
(
)
{
MOZ_ASSERT
(
key_
!
=
0
"
Should
have
valid
key
.
"
)
;
return
key_
;
}
}
;
using
ScriptToHintMap
=
HashMap
<
ScriptKey
IonHint
*
js
:
:
DefaultHasher
<
ScriptKey
>
js
:
:
SystemAllocPolicy
>
;
using
IonHintPriorityQueue
=
mozilla
:
:
LinkedList
<
IonHint
>
;
static
constexpr
uint32_t
InvalidationThresholdIncrement
=
500
;
static
constexpr
uint32_t
IonHintMaxEntries
=
5000
;
static
constexpr
uint32_t
MonomorphicInlineMaxEntries
=
16
;
static
uint32_t
IonHintEagerThresholdValue
(
uint32_t
lastStubCounter
bool
hasPretenuredAllocSites
)
;
ScriptToHintMap
ionHintMap_
;
IonHintPriorityQueue
ionHintQueue_
;
static
constexpr
uint32_t
EagerBaselineCacheSize_
=
16
;
mozilla
:
:
BitBloomFilter
<
EagerBaselineCacheSize_
ScriptKey
>
baselineHintMap_
;
static
constexpr
uint32_t
MaxEntries_
=
4281
;
static_assert
(
EagerBaselineCacheSize_
=
=
16
&
&
MaxEntries_
=
=
4281
"
MaxEntries
should
be
recalculated
for
given
CacheSize
.
"
)
;
uint32_t
baselineEntryCount_
=
0
;
void
incrementBaselineEntryCount
(
)
;
void
updateAsRecentlyUsed
(
IonHint
*
hint
)
;
IonHint
*
addIonHint
(
ScriptKey
key
ScriptToHintMap
:
:
AddPtr
&
p
)
;
public
:
~
JitHintsMap
(
)
;
void
setEagerBaselineHint
(
JSScript
*
script
)
;
bool
mightHaveEagerBaselineHint
(
JSScript
*
script
)
const
;
bool
recordIonCompilation
(
JSScript
*
script
)
;
bool
getIonThresholdHint
(
JSScript
*
script
uint32_t
&
thresholdOut
)
;
bool
addMonomorphicInlineLocation
(
JSScript
*
script
BytecodeLocation
loc
)
;
bool
hasMonomorphicInlineHintAtOffset
(
JSScript
*
script
uint32_t
offset
)
;
void
recordInvalidation
(
JSScript
*
script
)
;
}
;
}
#
endif
