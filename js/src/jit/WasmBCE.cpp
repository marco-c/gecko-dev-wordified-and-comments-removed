#
include
"
jit
/
WasmBCE
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
wasm
/
WasmMetadata
.
h
"
using
mozilla
:
:
HashGeneric
;
using
namespace
js
;
using
namespace
js
:
:
jit
;
struct
LastCheckedKey
{
MWasmBoundsCheck
:
:
Target
target
;
uint32_t
targetIndex
;
uint32_t
addressID
;
using
Lookup
=
LastCheckedKey
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
HashGeneric
(
l
.
target
l
.
targetIndex
l
.
addressID
)
;
}
static
bool
match
(
const
LastCheckedKey
&
lhs
const
Lookup
&
rhs
)
{
return
lhs
.
target
=
=
rhs
.
target
&
&
lhs
.
targetIndex
=
=
rhs
.
targetIndex
&
&
lhs
.
addressID
=
=
rhs
.
addressID
;
}
}
;
using
LastCheckedMap
=
js
:
:
HashMap
<
LastCheckedKey
MWasmBoundsCheck
*
LastCheckedKey
SystemAllocPolicy
>
;
bool
jit
:
:
EliminateBoundsChecks
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_WasmBCE
"
Begin
"
)
;
LastCheckedMap
lastChecked
;
for
(
ReversePostorderIterator
bIter
(
graph
.
rpoBegin
(
)
)
;
bIter
!
=
graph
.
rpoEnd
(
)
;
bIter
+
+
)
{
MBasicBlock
*
block
=
*
bIter
;
for
(
MDefinitionIterator
dIter
(
block
)
;
dIter
;
)
{
MDefinition
*
def
=
*
dIter
+
+
;
if
(
!
def
-
>
isWasmBoundsCheck
(
)
)
{
continue
;
}
MWasmBoundsCheck
*
bc
=
def
-
>
toWasmBoundsCheck
(
)
;
MDefinition
*
addr
=
bc
-
>
index
(
)
;
if
(
bc
-
>
target
(
)
=
=
MWasmBoundsCheck
:
:
Other
)
{
continue
;
}
if
(
addr
-
>
isConstant
(
)
)
{
uint64_t
addrConstantValue
=
UINT64_MAX
;
switch
(
addr
-
>
type
(
)
)
{
case
MIRType
:
:
Int32
:
{
addrConstantValue
=
addr
-
>
toConstant
(
)
-
>
toInt32
(
)
;
}
break
;
case
MIRType
:
:
Int64
:
{
addrConstantValue
=
addr
-
>
toConstant
(
)
-
>
toInt64
(
)
;
}
break
;
default
:
break
;
}
uint64_t
initialLength
=
0
;
switch
(
bc
-
>
target
(
)
)
{
case
MWasmBoundsCheck
:
:
Memory
:
{
initialLength
=
mir
-
>
wasmCodeMeta
(
)
-
>
memories
[
bc
-
>
targetIndex
(
)
]
.
initialLength
(
)
;
}
break
;
case
MWasmBoundsCheck
:
:
Table
:
{
initialLength
=
mir
-
>
wasmCodeMeta
(
)
-
>
tables
[
bc
-
>
targetIndex
(
)
]
.
initialLength
(
)
;
}
break
;
default
:
MOZ_CRASH
(
)
;
}
if
(
addrConstantValue
<
initialLength
)
{
bc
-
>
setRedundant
(
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
bc
-
>
replaceAllUsesWith
(
addr
)
;
}
else
{
MOZ_ASSERT
(
!
bc
-
>
hasUses
(
)
)
;
}
}
}
else
{
LastCheckedKey
key
=
(
LastCheckedKey
)
{
.
target
=
bc
-
>
target
(
)
.
targetIndex
=
bc
-
>
targetIndex
(
)
.
addressID
=
addr
-
>
id
(
)
}
;
LastCheckedMap
:
:
AddPtr
ptr
=
lastChecked
.
lookupForAdd
(
key
)
;
if
(
!
ptr
)
{
if
(
!
lastChecked
.
add
(
ptr
key
bc
)
)
{
return
false
;
}
}
else
{
MWasmBoundsCheck
*
prevCheckOfSameAddr
=
ptr
-
>
value
(
)
;
if
(
prevCheckOfSameAddr
-
>
block
(
)
-
>
dominates
(
block
)
)
{
bc
-
>
setRedundant
(
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
bc
-
>
replaceAllUsesWith
(
prevCheckOfSameAddr
)
;
}
else
{
MOZ_ASSERT
(
!
bc
-
>
hasUses
(
)
)
;
}
}
}
}
}
}
return
true
;
}
