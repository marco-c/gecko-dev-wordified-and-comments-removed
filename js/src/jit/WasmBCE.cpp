#
include
"
jit
/
WasmBCE
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
mozilla
;
struct
DefAndOffset
{
MDefinition
*
loc
;
uint32_t
endOffset
;
}
;
typedef
js
:
:
HashMap
<
uint32_t
DefAndOffset
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
LastSeenMap
;
bool
jit
:
:
EliminateBoundsChecks
(
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
LastSeenMap
lastSeen
;
if
(
!
lastSeen
.
init
(
)
)
return
false
;
for
(
ReversePostorderIterator
bIter
(
graph
.
rpoBegin
(
)
)
;
bIter
!
=
graph
.
rpoEnd
(
)
;
bIter
+
+
)
{
MBasicBlock
*
block
=
*
bIter
;
for
(
MDefinitionIterator
dIter
(
block
)
;
dIter
;
)
{
MDefinition
*
def
=
*
dIter
+
+
;
switch
(
def
-
>
op
(
)
)
{
case
MDefinition
:
:
Op_WasmBoundsCheck
:
{
MWasmBoundsCheck
*
bc
=
def
-
>
toWasmBoundsCheck
(
)
;
MDefinition
*
addr
=
def
-
>
getOperand
(
0
)
;
LastSeenMap
:
:
Ptr
checkPtr
=
lastSeen
.
lookup
(
addr
-
>
id
(
)
)
;
if
(
checkPtr
&
&
checkPtr
-
>
value
(
)
.
endOffset
>
=
bc
-
>
endOffset
(
)
&
&
checkPtr
-
>
value
(
)
.
loc
-
>
block
(
)
-
>
dominates
(
block
)
)
{
bc
-
>
setRedundant
(
true
)
;
}
else
{
DefAndOffset
defOff
=
{
def
bc
-
>
endOffset
(
)
}
;
if
(
!
lastSeen
.
put
(
addr
-
>
id
(
)
defOff
)
)
return
false
;
}
break
;
}
case
MDefinition
:
:
Op_Phi
:
{
MPhi
*
phi
=
def
-
>
toPhi
(
)
;
bool
phiChecked
=
true
;
uint32_t
off
=
UINT32_MAX
;
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
>
0
)
;
for
(
int
i
=
0
nOps
=
phi
-
>
numOperands
(
)
;
i
<
nOps
;
i
+
+
)
{
MDefinition
*
src
=
phi
-
>
getOperand
(
i
)
;
LastSeenMap
:
:
Ptr
checkPtr
=
lastSeen
.
lookup
(
src
-
>
id
(
)
)
;
if
(
!
checkPtr
|
|
!
checkPtr
-
>
value
(
)
.
loc
-
>
block
(
)
-
>
dominates
(
block
)
)
{
phiChecked
=
false
;
break
;
}
else
{
off
=
Min
(
off
checkPtr
-
>
value
(
)
.
endOffset
)
;
}
}
if
(
phiChecked
)
{
DefAndOffset
defOff
=
{
def
off
}
;
if
(
!
lastSeen
.
put
(
def
-
>
id
(
)
defOff
)
)
return
false
;
}
break
;
}
default
:
break
;
}
}
}
return
true
;
}
