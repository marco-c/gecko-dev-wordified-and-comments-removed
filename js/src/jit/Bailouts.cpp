#
include
"
jit
/
Bailouts
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
jit
/
JitSpewer
.
h
"
#
include
"
jit
/
Snapshots
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
jit
/
JitFrameIterator
-
inl
.
h
"
#
include
"
vm
/
Probes
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
IsInRange
;
uint32_t
jit
:
:
Bailout
(
BailoutStack
*
sp
BaselineBailoutInfo
*
*
bailoutInfo
)
{
JSContext
*
cx
=
TlsContext
.
get
(
)
;
MOZ_ASSERT
(
bailoutInfo
)
;
MOZ_ASSERT
(
IsInRange
(
FAKE_JIT_TOP_FOR_BAILOUT
0
0x1000
)
&
&
IsInRange
(
FAKE_JIT_TOP_FOR_BAILOUT
+
sizeof
(
CommonFrameLayout
)
0
0x1000
)
"
Fake
jitTop
pointer
should
be
within
the
first
page
.
"
)
;
cx
-
>
jitTop
=
FAKE_JIT_TOP_FOR_BAILOUT
;
JitActivationIterator
jitActivations
(
cx
)
;
BailoutFrameInfo
bailoutData
(
jitActivations
sp
)
;
JitFrameIterator
iter
(
jitActivations
)
;
MOZ_ASSERT
(
!
iter
.
ionScript
(
)
-
>
invalidated
(
)
)
;
CommonFrameLayout
*
currentFramePtr
=
iter
.
current
(
)
;
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
)
;
TraceLogTimestamp
(
logger
TraceLogger_Bailout
)
;
JitSpew
(
JitSpew_IonBailouts
"
Took
bailout
!
Snapshot
offset
:
%
d
"
iter
.
snapshotOffset
(
)
)
;
MOZ_ASSERT
(
IsBaselineEnabled
(
cx
)
)
;
*
bailoutInfo
=
nullptr
;
uint32_t
retval
=
BailoutIonToBaseline
(
cx
bailoutData
.
activation
(
)
iter
false
bailoutInfo
nullptr
)
;
MOZ_ASSERT
(
retval
=
=
BAILOUT_RETURN_OK
|
|
retval
=
=
BAILOUT_RETURN_FATAL_ERROR
|
|
retval
=
=
BAILOUT_RETURN_OVERRECURSED
)
;
MOZ_ASSERT_IF
(
retval
=
=
BAILOUT_RETURN_OK
*
bailoutInfo
!
=
nullptr
)
;
if
(
retval
!
=
BAILOUT_RETURN_OK
)
{
JSScript
*
script
=
iter
.
script
(
)
;
probes
:
:
ExitScript
(
cx
script
script
-
>
functionNonDelazifying
(
)
false
)
;
}
if
(
iter
.
ionScript
(
)
-
>
invalidated
(
)
)
iter
.
ionScript
(
)
-
>
decrementInvalidationCount
(
cx
-
>
runtime
(
)
-
>
defaultFreeOp
(
)
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
currentFramePtr
)
;
return
retval
;
}
uint32_t
jit
:
:
InvalidationBailout
(
InvalidationBailoutStack
*
sp
size_t
*
frameSizeOut
BaselineBailoutInfo
*
*
bailoutInfo
)
{
sp
-
>
checkInvariants
(
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
cx
-
>
jitTop
=
FAKE_JIT_TOP_FOR_BAILOUT
;
JitActivationIterator
jitActivations
(
cx
)
;
BailoutFrameInfo
bailoutData
(
jitActivations
sp
)
;
JitFrameIterator
iter
(
jitActivations
)
;
CommonFrameLayout
*
currentFramePtr
=
iter
.
current
(
)
;
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
cx
)
;
TraceLogTimestamp
(
logger
TraceLogger_Invalidation
)
;
JitSpew
(
JitSpew_IonBailouts
"
Took
invalidation
bailout
!
Snapshot
offset
:
%
d
"
iter
.
snapshotOffset
(
)
)
;
*
frameSizeOut
=
iter
.
frameSize
(
)
;
MOZ_ASSERT
(
IsBaselineEnabled
(
cx
)
)
;
*
bailoutInfo
=
nullptr
;
uint32_t
retval
=
BailoutIonToBaseline
(
cx
bailoutData
.
activation
(
)
iter
true
bailoutInfo
nullptr
)
;
MOZ_ASSERT
(
retval
=
=
BAILOUT_RETURN_OK
|
|
retval
=
=
BAILOUT_RETURN_FATAL_ERROR
|
|
retval
=
=
BAILOUT_RETURN_OVERRECURSED
)
;
MOZ_ASSERT_IF
(
retval
=
=
BAILOUT_RETURN_OK
*
bailoutInfo
!
=
nullptr
)
;
if
(
retval
!
=
BAILOUT_RETURN_OK
)
{
JSScript
*
script
=
iter
.
script
(
)
;
probes
:
:
ExitScript
(
cx
script
script
-
>
functionNonDelazifying
(
)
false
)
;
#
ifdef
JS_JITSPEW
JitFrameLayout
*
frame
=
iter
.
jsFrame
(
)
;
JitSpew
(
JitSpew_IonInvalidate
"
Bailout
failed
(
%
s
)
"
(
retval
=
=
BAILOUT_RETURN_FATAL_ERROR
)
?
"
Fatal
Error
"
:
"
Over
Recursion
"
)
;
JitSpew
(
JitSpew_IonInvalidate
"
calleeToken
%
p
"
(
void
*
)
frame
-
>
calleeToken
(
)
)
;
JitSpew
(
JitSpew_IonInvalidate
"
frameSize
%
u
"
unsigned
(
frame
-
>
prevFrameLocalSize
(
)
)
)
;
JitSpew
(
JitSpew_IonInvalidate
"
ra
%
p
"
(
void
*
)
frame
-
>
returnAddress
(
)
)
;
#
endif
}
iter
.
ionScript
(
)
-
>
decrementInvalidationCount
(
cx
-
>
runtime
(
)
-
>
defaultFreeOp
(
)
)
;
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
currentFramePtr
)
;
return
retval
;
}
BailoutFrameInfo
:
:
BailoutFrameInfo
(
const
JitActivationIterator
&
activations
const
JitFrameIterator
&
frame
)
:
machine_
(
frame
.
machineState
(
)
)
{
framePointer_
=
(
uint8_t
*
)
frame
.
fp
(
)
;
topFrameSize_
=
frame
.
frameSize
(
)
;
topIonScript_
=
frame
.
ionScript
(
)
;
attachOnJitActivation
(
activations
)
;
const
OsiIndex
*
osiIndex
=
frame
.
osiIndex
(
)
;
snapshotOffset_
=
osiIndex
-
>
snapshotOffset
(
)
;
}
uint32_t
jit
:
:
ExceptionHandlerBailout
(
JSContext
*
cx
const
InlineFrameIterator
&
frame
ResumeFromException
*
rfe
const
ExceptionBailoutInfo
&
excInfo
bool
*
overrecursed
)
{
MOZ_ASSERT_IF
(
!
excInfo
.
propagatingIonExceptionForDebugMode
(
)
cx
-
>
isExceptionPending
(
)
)
;
uint8_t
*
prevJitTop
=
cx
-
>
jitTop
;
auto
restoreJitTop
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
cx
-
>
jitTop
=
prevJitTop
;
}
)
;
cx
-
>
jitTop
=
FAKE_JIT_TOP_FOR_BAILOUT
;
gc
:
:
AutoSuppressGC
suppress
(
cx
)
;
JitActivationIterator
jitActivations
(
cx
)
;
BailoutFrameInfo
bailoutData
(
jitActivations
frame
.
frame
(
)
)
;
JitFrameIterator
iter
(
jitActivations
)
;
CommonFrameLayout
*
currentFramePtr
=
iter
.
current
(
)
;
BaselineBailoutInfo
*
bailoutInfo
=
nullptr
;
uint32_t
retval
;
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
retval
=
BailoutIonToBaseline
(
cx
bailoutData
.
activation
(
)
iter
true
&
bailoutInfo
&
excInfo
)
;
if
(
retval
=
=
BAILOUT_RETURN_FATAL_ERROR
&
&
cx
-
>
isThrowingOutOfMemory
(
)
)
oomUnsafe
.
crash
(
"
ExceptionHandlerBailout
"
)
;
}
if
(
retval
=
=
BAILOUT_RETURN_OK
)
{
MOZ_ASSERT
(
bailoutInfo
)
;
if
(
excInfo
.
propagatingIonExceptionForDebugMode
(
)
)
bailoutInfo
-
>
bailoutKind
=
Bailout_IonExceptionDebugMode
;
rfe
-
>
kind
=
ResumeFromException
:
:
RESUME_BAILOUT
;
rfe
-
>
target
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getBailoutTail
(
)
-
>
raw
(
)
;
rfe
-
>
bailoutInfo
=
bailoutInfo
;
}
else
{
MOZ_ASSERT
(
!
bailoutInfo
)
;
if
(
retval
=
=
BAILOUT_RETURN_OVERRECURSED
)
{
*
overrecursed
=
true
;
if
(
!
excInfo
.
propagatingIonExceptionForDebugMode
(
)
)
cx
-
>
clearPendingException
(
)
;
}
else
{
MOZ_ASSERT
(
retval
=
=
BAILOUT_RETURN_FATAL_ERROR
)
;
MOZ_CRASH
(
)
;
}
}
if
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
isProfilerInstrumentationEnabled
(
cx
-
>
runtime
(
)
)
)
cx
-
>
jitActivation
-
>
setLastProfilingFrame
(
currentFramePtr
)
;
return
retval
;
}
bool
jit
:
:
EnsureHasEnvironmentObjects
(
JSContext
*
cx
AbstractFramePtr
fp
)
{
MOZ_ASSERT
(
!
fp
.
isEvalFrame
(
)
)
;
if
(
fp
.
isFunctionFrame
(
)
)
{
MOZ_ASSERT
(
!
fp
.
callee
(
)
-
>
needsExtraBodyVarEnvironment
(
)
)
;
if
(
!
fp
.
hasInitialEnvironment
(
)
&
&
fp
.
callee
(
)
-
>
needsFunctionEnvironmentObjects
(
)
)
{
if
(
!
fp
.
initFunctionEnvironmentObjects
(
cx
)
)
return
false
;
}
}
return
true
;
}
void
jit
:
:
CheckFrequentBailouts
(
JSContext
*
cx
JSScript
*
script
BailoutKind
bailoutKind
)
{
if
(
script
-
>
hasIonScript
(
)
)
{
IonScript
*
ionScript
=
script
-
>
ionScript
(
)
;
if
(
ionScript
-
>
bailoutExpected
(
)
)
{
if
(
bailoutKind
!
=
Bailout_FirstExecution
&
&
!
script
-
>
hadFrequentBailouts
(
)
)
script
-
>
setHadFrequentBailouts
(
)
;
JitSpew
(
JitSpew_IonInvalidate
"
Invalidating
due
to
too
many
bailouts
"
)
;
Invalidate
(
cx
script
)
;
}
}
}
void
BailoutFrameInfo
:
:
attachOnJitActivation
(
const
JitActivationIterator
&
jitActivations
)
{
MOZ_ASSERT
(
jitActivations
.
jitTop
(
)
=
=
FAKE_JIT_TOP_FOR_BAILOUT
)
;
activation_
=
jitActivations
-
>
asJit
(
)
;
activation_
-
>
setBailoutData
(
this
)
;
}
BailoutFrameInfo
:
:
~
BailoutFrameInfo
(
)
{
activation_
-
>
cleanBailoutData
(
)
;
}
