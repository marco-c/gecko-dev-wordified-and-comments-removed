#
include
"
jit
/
MoveResolver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
jit
/
RegisterSets
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
MoveOperand
:
:
MoveOperand
(
MacroAssembler
&
masm
const
ABIArg
&
arg
)
{
switch
(
arg
.
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
kind_
=
REG
;
code_
=
arg
.
gpr
(
)
.
code
(
)
;
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
kind_
=
REG_PAIR
;
code_
=
arg
.
evenGpr
(
)
.
code
(
)
;
MOZ_ASSERT
(
code_
%
2
=
=
0
)
;
MOZ_ASSERT
(
code_
+
1
=
=
arg
.
oddGpr
(
)
.
code
(
)
)
;
break
;
#
endif
case
ABIArg
:
:
FPU
:
kind_
=
FLOAT_REG
;
code_
=
arg
.
fpu
(
)
.
code
(
)
;
break
;
case
ABIArg
:
:
Stack
:
kind_
=
MEMORY
;
if
(
IsHiddenSP
(
masm
.
getStackPointer
(
)
)
)
MOZ_CRASH
(
"
Hidden
SP
cannot
be
represented
as
register
code
on
this
platform
"
)
;
else
code_
=
AsRegister
(
masm
.
getStackPointer
(
)
)
.
code
(
)
;
disp_
=
arg
.
offsetFromArgBase
(
)
;
break
;
case
ABIArg
:
:
Uninitialized
:
MOZ_CRASH
(
"
Uninitialized
ABIArg
kind
"
)
;
}
}
MoveResolver
:
:
MoveResolver
(
)
:
numCycles_
(
0
)
curCycles_
(
0
)
{
}
void
MoveResolver
:
:
resetState
(
)
{
numCycles_
=
0
;
curCycles_
=
0
;
}
bool
MoveResolver
:
:
addMove
(
const
MoveOperand
&
from
const
MoveOperand
&
to
MoveOp
:
:
Type
type
)
{
MOZ_ASSERT
(
!
(
from
=
=
to
)
)
;
PendingMove
*
pm
=
movePool_
.
allocate
(
)
;
if
(
!
pm
)
return
false
;
new
(
pm
)
PendingMove
(
from
to
type
)
;
pending_
.
pushBack
(
pm
)
;
return
true
;
}
MoveResolver
:
:
PendingMove
*
MoveResolver
:
:
findBlockingMove
(
const
PendingMove
*
last
)
{
for
(
PendingMoveIterator
iter
=
pending_
.
begin
(
)
;
iter
!
=
pending_
.
end
(
)
;
iter
+
+
)
{
PendingMove
*
other
=
*
iter
;
if
(
other
-
>
from
(
)
.
aliases
(
last
-
>
to
(
)
)
)
{
return
other
;
}
}
return
nullptr
;
}
MoveResolver
:
:
PendingMove
*
MoveResolver
:
:
findCycledMove
(
PendingMoveIterator
*
iter
PendingMoveIterator
end
const
PendingMove
*
last
)
{
for
(
;
*
iter
!
=
end
;
(
*
iter
)
+
+
)
{
PendingMove
*
other
=
*
*
iter
;
if
(
other
-
>
from
(
)
.
aliases
(
last
-
>
to
(
)
)
)
{
(
*
iter
)
+
+
;
return
other
;
}
}
return
nullptr
;
}
#
ifdef
JS_CODEGEN_ARM
static
inline
bool
MoveIsDouble
(
const
MoveOperand
&
move
)
{
if
(
!
move
.
isFloatReg
(
)
)
return
false
;
return
move
.
floatReg
(
)
.
isDouble
(
)
;
}
#
endif
#
ifdef
JS_CODEGEN_ARM
static
inline
bool
MoveIsSingle
(
const
MoveOperand
&
move
)
{
if
(
!
move
.
isFloatReg
(
)
)
return
false
;
return
move
.
floatReg
(
)
.
isSingle
(
)
;
}
#
endif
#
ifdef
JS_CODEGEN_ARM
bool
MoveResolver
:
:
isDoubleAliasedAsSingle
(
const
MoveOperand
&
move
)
{
if
(
!
MoveIsDouble
(
move
)
)
return
false
;
for
(
auto
iter
=
pending_
.
begin
(
)
;
iter
!
=
pending_
.
end
(
)
;
+
+
iter
)
{
PendingMove
*
other
=
*
iter
;
if
(
other
-
>
from
(
)
.
aliases
(
move
)
&
&
MoveIsSingle
(
other
-
>
from
(
)
)
)
return
true
;
if
(
other
-
>
to
(
)
.
aliases
(
move
)
&
&
MoveIsSingle
(
other
-
>
to
(
)
)
)
return
true
;
}
return
false
;
}
#
endif
#
ifdef
JS_CODEGEN_ARM
static
MoveOperand
SplitIntoLowerHalf
(
const
MoveOperand
&
move
)
{
if
(
MoveIsDouble
(
move
)
)
{
FloatRegister
lowerSingle
=
move
.
floatReg
(
)
.
asSingle
(
)
;
return
MoveOperand
(
lowerSingle
)
;
}
MOZ_ASSERT
(
move
.
isMemoryOrEffectiveAddress
(
)
)
;
return
move
;
}
#
endif
#
ifdef
JS_CODEGEN_ARM
static
MoveOperand
SplitIntoUpperHalf
(
const
MoveOperand
&
move
)
{
if
(
MoveIsDouble
(
move
)
)
{
FloatRegister
lowerSingle
=
move
.
floatReg
(
)
.
asSingle
(
)
;
FloatRegister
upperSingle
=
VFPRegister
(
lowerSingle
.
code
(
)
+
1
VFPRegister
:
:
Single
)
;
return
MoveOperand
(
upperSingle
)
;
}
MOZ_ASSERT
(
move
.
isMemoryOrEffectiveAddress
(
)
)
;
return
MoveOperand
(
move
.
base
(
)
move
.
disp
(
)
+
sizeof
(
float
)
)
;
}
#
endif
bool
MoveResolver
:
:
resolve
(
)
{
resetState
(
)
;
orderedMoves_
.
clear
(
)
;
auto
clearPending
=
mozilla
:
:
MakeScopeExit
(
[
this
]
(
)
{
pending_
.
clear
(
)
;
}
)
;
#
ifdef
JS_CODEGEN_ARM
for
(
auto
iter
=
pending_
.
begin
(
)
;
iter
!
=
pending_
.
end
(
)
;
+
+
iter
)
{
PendingMove
*
pm
=
*
iter
;
if
(
isDoubleAliasedAsSingle
(
pm
-
>
from
(
)
)
|
|
isDoubleAliasedAsSingle
(
pm
-
>
to
(
)
)
)
{
PendingMove
*
lower
=
movePool_
.
allocate
(
)
;
if
(
!
lower
)
return
false
;
MoveOperand
fromLower
=
SplitIntoLowerHalf
(
pm
-
>
from
(
)
)
;
MoveOperand
toLower
=
SplitIntoLowerHalf
(
pm
-
>
to
(
)
)
;
new
(
lower
)
PendingMove
(
fromLower
toLower
MoveOp
:
:
FLOAT32
)
;
pending_
.
insertBefore
(
pm
lower
)
;
MoveOperand
fromUpper
=
SplitIntoUpperHalf
(
pm
-
>
from
(
)
)
;
MoveOperand
toUpper
=
SplitIntoUpperHalf
(
pm
-
>
to
(
)
)
;
pm
-
>
overwrite
(
fromUpper
toUpper
MoveOp
:
:
FLOAT32
)
;
}
}
#
endif
InlineList
<
PendingMove
>
stack
;
while
(
!
pending_
.
empty
(
)
)
{
PendingMove
*
pm
=
pending_
.
popBack
(
)
;
stack
.
pushBack
(
pm
)
;
while
(
!
stack
.
empty
(
)
)
{
PendingMove
*
blocking
=
findBlockingMove
(
stack
.
peekBack
(
)
)
;
if
(
blocking
)
{
PendingMoveIterator
stackiter
=
stack
.
begin
(
)
;
PendingMove
*
cycled
=
findCycledMove
(
&
stackiter
stack
.
end
(
)
blocking
)
;
if
(
cycled
)
{
do
{
cycled
-
>
setCycleEnd
(
curCycles_
)
;
cycled
=
findCycledMove
(
&
stackiter
stack
.
end
(
)
blocking
)
;
}
while
(
cycled
)
;
blocking
-
>
setCycleBegin
(
pm
-
>
type
(
)
curCycles_
)
;
curCycles_
+
+
;
pending_
.
remove
(
blocking
)
;
stack
.
pushBack
(
blocking
)
;
}
else
{
pending_
.
remove
(
blocking
)
;
stack
.
pushBack
(
blocking
)
;
}
}
else
{
PendingMove
*
done
=
stack
.
popBack
(
)
;
if
(
!
addOrderedMove
(
*
done
)
)
return
false
;
movePool_
.
free
(
done
)
;
}
}
if
(
numCycles_
<
curCycles_
)
numCycles_
=
curCycles_
;
curCycles_
=
0
;
}
return
true
;
}
bool
MoveResolver
:
:
addOrderedMove
(
const
MoveOp
&
move
)
{
MOZ_ASSERT
(
!
move
.
from
(
)
.
aliases
(
move
.
to
(
)
)
)
;
if
(
!
move
.
from
(
)
.
isMemory
(
)
|
|
move
.
isCycleBegin
(
)
|
|
move
.
isCycleEnd
(
)
)
return
orderedMoves_
.
append
(
move
)
;
for
(
int
i
=
orderedMoves_
.
length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
const
MoveOp
&
existing
=
orderedMoves_
[
i
]
;
if
(
existing
.
from
(
)
=
=
move
.
from
(
)
&
&
!
existing
.
to
(
)
.
aliases
(
move
.
to
(
)
)
&
&
existing
.
type
(
)
=
=
move
.
type
(
)
&
&
!
existing
.
isCycleBegin
(
)
&
&
!
existing
.
isCycleEnd
(
)
)
{
MoveOp
*
after
=
orderedMoves_
.
begin
(
)
+
i
+
1
;
if
(
existing
.
to
(
)
.
isGeneralReg
(
)
|
|
existing
.
to
(
)
.
isFloatReg
(
)
)
{
MoveOp
nmove
(
existing
.
to
(
)
move
.
to
(
)
move
.
type
(
)
)
;
return
orderedMoves_
.
insert
(
after
nmove
)
;
}
else
if
(
move
.
to
(
)
.
isGeneralReg
(
)
|
|
move
.
to
(
)
.
isFloatReg
(
)
)
{
MoveOp
nmove
(
move
.
to
(
)
existing
.
to
(
)
move
.
type
(
)
)
;
orderedMoves_
[
i
]
=
move
;
return
orderedMoves_
.
insert
(
after
nmove
)
;
}
}
if
(
existing
.
aliases
(
move
)
)
break
;
}
return
orderedMoves_
.
append
(
move
)
;
}
void
MoveResolver
:
:
reorderMove
(
size_t
from
size_t
to
)
{
MOZ_ASSERT
(
from
!
=
to
)
;
MoveOp
op
=
orderedMoves_
[
from
]
;
if
(
from
<
to
)
{
for
(
size_t
i
=
from
;
i
<
to
;
i
+
+
)
orderedMoves_
[
i
]
=
orderedMoves_
[
i
+
1
]
;
}
else
{
for
(
size_t
i
=
from
;
i
>
to
;
i
-
-
)
orderedMoves_
[
i
]
=
orderedMoves_
[
i
-
1
]
;
}
orderedMoves_
[
to
]
=
op
;
}
void
MoveResolver
:
:
sortMemoryToMemoryMoves
(
)
{
for
(
size_t
i
=
0
;
i
<
orderedMoves_
.
length
(
)
;
i
+
+
)
{
const
MoveOp
&
base
=
orderedMoves_
[
i
]
;
if
(
!
base
.
from
(
)
.
isMemory
(
)
|
|
!
base
.
to
(
)
.
isMemory
(
)
)
continue
;
if
(
base
.
type
(
)
!
=
MoveOp
:
:
GENERAL
&
&
base
.
type
(
)
!
=
MoveOp
:
:
INT32
)
continue
;
bool
found
=
false
;
for
(
int
j
=
i
-
1
;
j
>
=
0
;
j
-
-
)
{
const
MoveOp
&
previous
=
orderedMoves_
[
j
]
;
if
(
previous
.
aliases
(
base
)
|
|
previous
.
isCycleBegin
(
)
|
|
previous
.
isCycleEnd
(
)
)
break
;
if
(
previous
.
to
(
)
.
isGeneralReg
(
)
)
{
reorderMove
(
i
j
)
;
found
=
true
;
break
;
}
}
if
(
found
)
continue
;
if
(
i
+
1
<
orderedMoves_
.
length
(
)
)
{
bool
found
=
false
skippedRegisterUse
=
false
;
for
(
size_t
j
=
i
+
1
;
j
<
orderedMoves_
.
length
(
)
;
j
+
+
)
{
const
MoveOp
&
later
=
orderedMoves_
[
j
]
;
if
(
later
.
aliases
(
base
)
|
|
later
.
isCycleBegin
(
)
|
|
later
.
isCycleEnd
(
)
)
break
;
if
(
later
.
to
(
)
.
isGeneralReg
(
)
)
{
if
(
skippedRegisterUse
)
{
reorderMove
(
i
j
)
;
found
=
true
;
}
else
{
}
break
;
}
if
(
later
.
from
(
)
.
isGeneralReg
(
)
)
skippedRegisterUse
=
true
;
}
if
(
found
)
{
i
-
-
;
}
}
}
}
