#
ifndef
jit_AtomicOperations_h
#
define
jit_AtomicOperations_h
#
include
"
vm
/
SharedMem
.
h
"
namespace
js
{
namespace
jit
{
class
RegionLock
;
class
AtomicOperations
{
friend
class
RegionLock
;
private
:
template
<
typename
T
>
static
inline
T
loadSeqCst
(
T
*
addr
)
;
template
<
typename
T
>
static
inline
void
storeSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
exchangeSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
compareExchangeSeqCst
(
T
*
addr
T
oldval
T
newval
)
;
template
<
typename
T
>
static
inline
T
fetchAddSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
fetchSubSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
fetchAndSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
fetchOrSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
fetchXorSeqCst
(
T
*
addr
T
val
)
;
template
<
typename
T
>
static
inline
T
loadSafeWhenRacy
(
T
*
addr
)
;
template
<
typename
T
>
static
inline
void
storeSafeWhenRacy
(
T
*
addr
T
val
)
;
static
inline
void
memcpySafeWhenRacy
(
void
*
dest
const
void
*
src
size_t
nbytes
)
;
static
inline
void
memmoveSafeWhenRacy
(
void
*
dest
const
void
*
src
size_t
nbytes
)
;
public
:
static
inline
bool
isLockfree
(
int32_t
n
)
;
static
inline
bool
isLockfree8
(
)
;
static
inline
void
fenceSeqCst
(
)
;
template
<
typename
T
>
static
T
loadSeqCst
(
SharedMem
<
T
*
>
addr
)
{
return
loadSeqCst
(
addr
.
unwrap
(
)
)
;
}
template
<
typename
T
>
static
void
storeSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
storeSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
exchangeSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
exchangeSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
compareExchangeSeqCst
(
SharedMem
<
T
*
>
addr
T
oldval
T
newval
)
{
return
compareExchangeSeqCst
(
addr
.
unwrap
(
)
oldval
newval
)
;
}
template
<
typename
T
>
static
T
fetchAddSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
fetchAddSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
fetchSubSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
fetchSubSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
fetchAndSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
fetchAndSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
fetchOrSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
fetchOrSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
fetchXorSeqCst
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
fetchXorSeqCst
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
T
loadSafeWhenRacy
(
SharedMem
<
T
*
>
addr
)
{
return
loadSafeWhenRacy
(
addr
.
unwrap
(
)
)
;
}
template
<
typename
T
>
static
void
storeSafeWhenRacy
(
SharedMem
<
T
*
>
addr
T
val
)
{
return
storeSafeWhenRacy
(
addr
.
unwrap
(
)
val
)
;
}
template
<
typename
T
>
static
void
memcpySafeWhenRacy
(
SharedMem
<
T
>
dest
SharedMem
<
T
>
src
size_t
nbytes
)
{
memcpySafeWhenRacy
(
static_cast
<
void
*
>
(
dest
.
unwrap
(
)
)
static_cast
<
void
*
>
(
src
.
unwrap
(
)
)
nbytes
)
;
}
template
<
typename
T
>
static
void
memcpySafeWhenRacy
(
SharedMem
<
T
>
dest
T
src
size_t
nbytes
)
{
memcpySafeWhenRacy
(
static_cast
<
void
*
>
(
dest
.
unwrap
(
)
)
static_cast
<
void
*
>
(
src
)
nbytes
)
;
}
template
<
typename
T
>
static
void
memcpySafeWhenRacy
(
T
dest
SharedMem
<
T
>
src
size_t
nbytes
)
{
memcpySafeWhenRacy
(
static_cast
<
void
*
>
(
dest
)
static_cast
<
void
*
>
(
src
.
unwrap
(
)
)
nbytes
)
;
}
template
<
typename
T
>
static
void
memmoveSafeWhenRacy
(
SharedMem
<
T
>
dest
SharedMem
<
T
>
src
size_t
nbytes
)
{
memmoveSafeWhenRacy
(
static_cast
<
void
*
>
(
dest
.
unwrap
(
)
)
static_cast
<
void
*
>
(
src
.
unwrap
(
)
)
nbytes
)
;
}
}
;
class
RegionLock
{
public
:
RegionLock
(
)
:
spinlock
(
0
)
{
}
template
<
size_t
nbytes
>
void
acquire
(
void
*
addr
)
;
template
<
size_t
nbytes
>
void
release
(
void
*
addr
)
;
private
:
uint32_t
spinlock
;
}
;
}
}
#
endif
