#
include
"
jit
/
IonAnalysis
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
jit
/
AliasAnalysis
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
DominatorTree
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
util
/
CheckedArithmetic
.
h
"
#
include
"
vm
/
BytecodeUtil
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
MPhiUseIteratorStack
=
Vector
<
std
:
:
pair
<
MPhi
*
MUseIterator
>
16
SystemAllocPolicy
>
;
[
[
nodiscard
]
]
static
bool
DepthFirstSearchUse
(
const
MIRGenerator
*
mir
MPhiUseIteratorStack
&
worklist
MPhi
*
phi
)
{
auto
push
=
[
&
worklist
]
(
MPhi
*
phi
MUseIterator
use
)
-
>
bool
{
phi
-
>
setInWorklist
(
)
;
return
worklist
.
append
(
std
:
:
make_pair
(
phi
use
)
)
;
}
;
#
ifdef
DEBUG
size_t
refUseCount
=
phi
-
>
useCount
(
)
;
size_t
useCount
=
0
;
#
endif
MOZ_ASSERT
(
worklist
.
empty
(
)
)
;
if
(
!
push
(
phi
phi
-
>
usesBegin
(
)
)
)
{
return
false
;
}
while
(
!
worklist
.
empty
(
)
)
{
auto
pair
=
worklist
.
popCopy
(
)
;
MPhi
*
producer
=
pair
.
first
;
MUseIterator
use
=
pair
.
second
;
MUseIterator
end
(
producer
-
>
usesEnd
(
)
)
;
producer
-
>
setNotInWorklist
(
)
;
while
(
use
!
=
end
)
{
MNode
*
consumer
=
(
*
use
)
-
>
consumer
(
)
;
MUseIterator
it
=
use
;
use
+
+
;
#
ifdef
DEBUG
useCount
+
+
;
#
endif
if
(
mir
-
>
shouldCancel
(
"
FlagPhiInputsAsImplicitlyUsed
inner
loop
"
)
)
{
return
false
;
}
if
(
consumer
-
>
isResumePoint
(
)
)
{
MResumePoint
*
rp
=
consumer
-
>
toResumePoint
(
)
;
if
(
rp
-
>
isObservableOperand
(
*
it
)
)
{
return
push
(
producer
use
)
;
}
continue
;
}
MDefinition
*
cdef
=
consumer
-
>
toDefinition
(
)
;
if
(
!
cdef
-
>
isPhi
(
)
)
{
return
push
(
producer
use
)
;
}
MPhi
*
cphi
=
cdef
-
>
toPhi
(
)
;
if
(
cphi
-
>
getUsageAnalysis
(
)
=
=
PhiUsage
:
:
Used
|
|
cphi
-
>
isImplicitlyUsed
(
)
)
{
return
push
(
producer
use
)
;
}
if
(
cphi
-
>
isInWorklist
(
)
|
|
cphi
=
=
producer
)
{
return
push
(
producer
use
)
;
}
if
(
cphi
-
>
getUsageAnalysis
(
)
=
=
PhiUsage
:
:
Unused
)
{
continue
;
}
if
(
!
push
(
producer
use
)
)
{
return
false
;
}
producer
=
cphi
;
use
=
producer
-
>
usesBegin
(
)
;
end
=
producer
-
>
usesEnd
(
)
;
#
ifdef
DEBUG
refUseCount
+
=
producer
-
>
useCount
(
)
;
#
endif
}
MOZ_ASSERT
(
use
=
=
end
)
;
producer
-
>
setUsageAnalysis
(
PhiUsage
:
:
Unused
)
;
}
MOZ_ASSERT
(
useCount
=
=
refUseCount
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
FlagPhiInputsAsImplicitlyUsed
(
const
MIRGenerator
*
mir
MBasicBlock
*
block
MBasicBlock
*
succ
MPhiUseIteratorStack
&
worklist
)
{
size_t
predIndex
=
succ
-
>
getPredecessorIndex
(
block
)
;
MPhiIterator
end
=
succ
-
>
phisEnd
(
)
;
MPhiIterator
it
=
succ
-
>
phisBegin
(
)
;
for
(
;
it
!
=
end
;
it
+
+
)
{
MPhi
*
phi
=
*
it
;
if
(
mir
-
>
shouldCancel
(
"
FlagPhiInputsAsImplicitlyUsed
outer
loop
"
)
)
{
return
false
;
}
MDefinition
*
def
=
phi
-
>
getOperand
(
predIndex
)
;
if
(
def
-
>
isImplicitlyUsed
(
)
)
{
continue
;
}
if
(
phi
-
>
getUsageAnalysis
(
)
=
=
PhiUsage
:
:
Used
|
|
phi
-
>
isImplicitlyUsed
(
)
)
{
def
-
>
setImplicitlyUsedUnchecked
(
)
;
continue
;
}
else
if
(
phi
-
>
getUsageAnalysis
(
)
=
=
PhiUsage
:
:
Unused
)
{
continue
;
}
MOZ_ASSERT
(
worklist
.
empty
(
)
)
;
if
(
!
DepthFirstSearchUse
(
mir
worklist
phi
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
worklist
.
empty
(
)
phi
-
>
getUsageAnalysis
(
)
=
=
PhiUsage
:
:
Unused
)
;
if
(
!
worklist
.
empty
(
)
)
{
def
-
>
setImplicitlyUsedUnchecked
(
)
;
do
{
auto
pair
=
worklist
.
popCopy
(
)
;
MPhi
*
producer
=
pair
.
first
;
producer
-
>
setUsageAnalysis
(
PhiUsage
:
:
Used
)
;
producer
-
>
setNotInWorklist
(
)
;
}
while
(
!
worklist
.
empty
(
)
)
;
}
MOZ_ASSERT
(
phi
-
>
getUsageAnalysis
(
)
!
=
PhiUsage
:
:
Unknown
)
;
}
return
true
;
}
static
MInstructionIterator
FindFirstInstructionAfterBail
(
MBasicBlock
*
block
)
{
MOZ_ASSERT
(
block
-
>
alwaysBails
(
)
)
;
for
(
MInstructionIterator
it
=
block
-
>
begin
(
)
;
it
!
=
block
-
>
end
(
)
;
it
+
+
)
{
MInstruction
*
ins
=
*
it
;
if
(
ins
-
>
isBail
(
)
)
{
it
+
+
;
return
it
;
}
}
MOZ_CRASH
(
"
Expected
MBail
in
alwaysBails
block
"
)
;
}
[
[
nodiscard
]
]
static
bool
FlagOperandsAsImplicitlyUsedAfter
(
const
MIRGenerator
*
mir
MBasicBlock
*
block
MInstructionIterator
firstRemoved
)
{
MOZ_ASSERT
(
firstRemoved
-
>
block
(
)
=
=
block
)
;
const
CompileInfo
&
info
=
block
-
>
info
(
)
;
MInstructionIterator
end
=
block
-
>
end
(
)
;
for
(
MInstructionIterator
it
=
firstRemoved
;
it
!
=
end
;
it
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
FlagOperandsAsImplicitlyUsedAfter
(
loop
1
)
"
)
)
{
return
false
;
}
MInstruction
*
ins
=
*
it
;
for
(
size_t
i
=
0
e
=
ins
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
ins
-
>
getOperand
(
i
)
-
>
setImplicitlyUsedUnchecked
(
)
;
}
if
(
MResumePoint
*
rp
=
ins
-
>
resumePoint
(
)
)
{
MOZ_ASSERT
(
&
rp
-
>
block
(
)
-
>
info
(
)
=
=
&
info
)
;
for
(
size_t
i
=
0
e
=
rp
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
if
(
info
.
isObservableSlot
(
i
)
)
{
rp
-
>
getOperand
(
i
)
-
>
setImplicitlyUsedUnchecked
(
)
;
}
}
}
}
MPhiUseIteratorStack
worklist
;
for
(
size_t
i
=
0
e
=
block
-
>
numSuccessors
(
)
;
i
<
e
;
i
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
FlagOperandsAsImplicitlyUsedAfter
(
loop
2
)
"
)
)
{
return
false
;
}
if
(
!
FlagPhiInputsAsImplicitlyUsed
(
mir
block
block
-
>
getSuccessor
(
i
)
worklist
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
FlagEntryResumePointOperands
(
const
MIRGenerator
*
mir
MBasicBlock
*
block
)
{
MResumePoint
*
rp
=
block
-
>
entryResumePoint
(
)
;
while
(
rp
)
{
if
(
mir
-
>
shouldCancel
(
"
FlagEntryResumePointOperands
"
)
)
{
return
false
;
}
const
CompileInfo
&
info
=
rp
-
>
block
(
)
-
>
info
(
)
;
for
(
size_t
i
=
0
e
=
rp
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
if
(
info
.
isObservableSlot
(
i
)
)
{
rp
-
>
getOperand
(
i
)
-
>
setImplicitlyUsedUnchecked
(
)
;
}
}
rp
=
rp
-
>
caller
(
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
FlagAllOperandsAsImplicitlyUsed
(
const
MIRGenerator
*
mir
MBasicBlock
*
block
)
{
return
FlagEntryResumePointOperands
(
mir
block
)
&
&
FlagOperandsAsImplicitlyUsedAfter
(
mir
block
block
-
>
begin
(
)
)
;
}
bool
jit
:
:
PruneUnusedBranches
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_Prune
"
Begin
"
)
;
MOZ_ASSERT
(
!
mir
-
>
compilingWasm
(
)
)
;
Vector
<
MBasicBlock
*
16
SystemAllocPolicy
>
worklist
;
uint32_t
numMarked
=
0
;
bool
needsTrim
=
false
;
auto
markReachable
=
[
&
]
(
MBasicBlock
*
block
)
-
>
bool
{
block
-
>
mark
(
)
;
numMarked
+
+
;
if
(
block
-
>
alwaysBails
(
)
)
{
needsTrim
=
true
;
}
return
worklist
.
append
(
block
)
;
}
;
if
(
!
markReachable
(
graph
.
entryBlock
(
)
)
)
{
return
false
;
}
if
(
graph
.
osrBlock
(
)
&
&
!
markReachable
(
graph
.
osrBlock
(
)
)
)
{
return
false
;
}
while
(
!
worklist
.
empty
(
)
)
{
if
(
mir
-
>
shouldCancel
(
"
Prune
unused
branches
(
marking
reachable
)
"
)
)
{
return
false
;
}
MBasicBlock
*
block
=
worklist
.
popCopy
(
)
;
JitSpew
(
JitSpew_Prune
"
Visit
block
%
u
:
"
block
-
>
id
(
)
)
;
JitSpewIndent
indent
(
JitSpew_Prune
)
;
if
(
block
-
>
alwaysBails
(
)
)
{
continue
;
}
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
succ
=
block
-
>
getSuccessor
(
i
)
;
if
(
succ
-
>
isMarked
(
)
)
{
continue
;
}
JitSpew
(
JitSpew_Prune
"
Reaches
block
%
u
"
succ
-
>
id
(
)
)
;
if
(
!
markReachable
(
succ
)
)
{
return
false
;
}
}
}
if
(
!
needsTrim
&
&
numMarked
=
=
graph
.
numBlocks
(
)
)
{
graph
.
unmarkBlocks
(
)
;
return
true
;
}
JitSpew
(
JitSpew_Prune
"
Remove
unreachable
instructions
and
blocks
:
"
)
;
JitSpewIndent
indent
(
JitSpew_Prune
)
;
for
(
PostorderIterator
it
(
graph
.
poBegin
(
)
)
;
it
!
=
graph
.
poEnd
(
)
;
)
{
if
(
mir
-
>
shouldCancel
(
"
Prune
unused
branches
(
marking
operands
)
"
)
)
{
return
false
;
}
MBasicBlock
*
block
=
*
it
+
+
;
if
(
!
block
-
>
isMarked
(
)
)
{
if
(
!
FlagAllOperandsAsImplicitlyUsed
(
mir
block
)
)
{
return
false
;
}
}
else
if
(
block
-
>
alwaysBails
(
)
)
{
MInstructionIterator
firstRemoved
=
FindFirstInstructionAfterBail
(
block
)
;
if
(
!
FlagOperandsAsImplicitlyUsedAfter
(
mir
block
firstRemoved
)
)
{
return
false
;
}
}
}
for
(
PostorderIterator
it
(
graph
.
poBegin
(
)
)
;
it
!
=
graph
.
poEnd
(
)
;
)
{
if
(
mir
-
>
shouldCancel
(
"
Prune
unused
branches
(
removal
loop
)
"
)
)
{
return
false
;
}
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MBasicBlock
*
block
=
*
it
+
+
;
if
(
block
-
>
isMarked
(
)
&
&
!
block
-
>
alwaysBails
(
)
)
{
continue
;
}
size_t
numSucc
=
block
-
>
numSuccessors
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numSucc
;
i
+
+
)
{
MBasicBlock
*
succ
=
block
-
>
getSuccessor
(
i
)
;
if
(
succ
-
>
isDead
(
)
)
{
continue
;
}
if
(
succ
-
>
isLoopHeader
(
)
&
&
block
!
=
succ
-
>
backedge
(
)
)
{
MOZ_ASSERT
(
graph
.
osrBlock
(
)
)
;
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MBasicBlock
*
fake
=
MBasicBlock
:
:
NewFakeLoopPredecessor
(
graph
succ
)
;
if
(
!
fake
)
{
return
false
;
}
fake
-
>
mark
(
)
;
JitSpew
(
JitSpew_Prune
"
Header
%
u
only
reachable
by
OSR
.
Add
fake
predecessor
%
u
"
succ
-
>
id
(
)
fake
-
>
id
(
)
)
;
}
JitSpew
(
JitSpew_Prune
"
Remove
block
edge
%
u
-
>
%
u
.
"
block
-
>
id
(
)
succ
-
>
id
(
)
)
;
succ
-
>
removePredecessor
(
block
)
;
}
if
(
!
block
-
>
isMarked
(
)
)
{
JitSpew
(
JitSpew_Prune
"
Remove
block
%
u
.
"
block
-
>
id
(
)
)
;
graph
.
removeBlock
(
block
)
;
}
else
{
JitSpew
(
JitSpew_Prune
"
Trim
block
%
u
.
"
block
-
>
id
(
)
)
;
MInstructionIterator
firstRemoved
=
FindFirstInstructionAfterBail
(
block
)
;
block
-
>
discardAllInstructionsStartingAt
(
firstRemoved
)
;
if
(
block
-
>
outerResumePoint
(
)
)
{
block
-
>
clearOuterResumePoint
(
)
;
}
block
-
>
end
(
MUnreachable
:
:
New
(
graph
.
alloc
(
)
)
)
;
}
}
graph
.
unmarkBlocks
(
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
SplitCriticalEdgesForBlock
(
MIRGraph
&
graph
MBasicBlock
*
block
)
{
if
(
block
-
>
numSuccessors
(
)
<
2
)
{
return
true
;
}
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
{
MBasicBlock
*
target
=
block
-
>
getSuccessor
(
i
)
;
if
(
target
-
>
numPredecessors
(
)
<
2
)
{
continue
;
}
MBasicBlock
*
split
=
MBasicBlock
:
:
NewSplitEdge
(
graph
block
i
target
)
;
if
(
!
split
)
{
return
false
;
}
}
return
true
;
}
bool
jit
:
:
SplitCriticalEdges
(
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
iter
(
graph
.
begin
(
)
)
;
iter
!
=
graph
.
end
(
)
;
iter
+
+
)
{
MBasicBlock
*
block
=
*
iter
;
if
(
!
SplitCriticalEdgesForBlock
(
graph
block
)
)
{
return
false
;
}
}
return
true
;
}
bool
jit
:
:
IsUint32Type
(
const
MDefinition
*
def
)
{
if
(
def
-
>
isBeta
(
)
)
{
def
=
def
-
>
getOperand
(
0
)
;
}
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
false
;
}
return
def
-
>
isUrsh
(
)
&
&
def
-
>
getOperand
(
1
)
-
>
isConstant
(
)
&
&
def
-
>
getOperand
(
1
)
-
>
toConstant
(
)
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
def
-
>
getOperand
(
1
)
-
>
toConstant
(
)
-
>
toInt32
(
)
=
=
0
;
}
static
bool
BlockIsSingleTest
(
MBasicBlock
*
phiBlock
MBasicBlock
*
testBlock
MPhi
*
*
pphi
MTest
*
*
ptest
)
{
*
pphi
=
nullptr
;
*
ptest
=
nullptr
;
if
(
phiBlock
!
=
testBlock
)
{
MOZ_ASSERT
(
phiBlock
-
>
numSuccessors
(
)
=
=
1
&
&
phiBlock
-
>
getSuccessor
(
0
)
=
=
testBlock
)
;
if
(
!
phiBlock
-
>
begin
(
)
-
>
isGoto
(
)
)
{
return
false
;
}
}
auto
iter
=
testBlock
-
>
rbegin
(
)
;
if
(
!
iter
-
>
isTest
(
)
)
{
return
false
;
}
MTest
*
test
=
iter
-
>
toTest
(
)
;
MInstruction
*
testOrNot
=
test
;
bool
hasOddNumberOfNots
=
false
;
while
(
+
+
iter
!
=
testBlock
-
>
rend
(
)
)
{
if
(
iter
-
>
isNot
(
)
)
{
auto
*
notIns
=
iter
-
>
toNot
(
)
;
if
(
testOrNot
-
>
getOperand
(
0
)
!
=
notIns
)
{
return
false
;
}
if
(
!
notIns
-
>
hasOneUse
(
)
)
{
return
false
;
}
testOrNot
=
notIns
;
hasOddNumberOfNots
=
!
hasOddNumberOfNots
;
}
else
{
return
false
;
}
}
if
(
hasOddNumberOfNots
)
{
return
false
;
}
MOZ_ASSERT
(
testOrNot
-
>
isTest
(
)
|
|
testOrNot
-
>
isNot
(
)
)
;
MDefinition
*
testInput
=
testOrNot
-
>
getOperand
(
0
)
;
if
(
!
testInput
-
>
isPhi
(
)
)
{
return
false
;
}
MPhi
*
phi
=
testInput
-
>
toPhi
(
)
;
if
(
phi
-
>
block
(
)
!
=
phiBlock
)
{
return
false
;
}
for
(
MUseIterator
iter
=
phi
-
>
usesBegin
(
)
;
iter
!
=
phi
-
>
usesEnd
(
)
;
+
+
iter
)
{
MUse
*
use
=
*
iter
;
if
(
use
-
>
consumer
(
)
=
=
testOrNot
)
{
continue
;
}
if
(
use
-
>
consumer
(
)
-
>
isResumePoint
(
)
)
{
MBasicBlock
*
useBlock
=
use
-
>
consumer
(
)
-
>
block
(
)
;
if
(
useBlock
=
=
phiBlock
|
|
useBlock
=
=
testBlock
)
{
continue
;
}
}
return
false
;
}
for
(
MPhiIterator
iter
=
phiBlock
-
>
phisBegin
(
)
;
iter
!
=
phiBlock
-
>
phisEnd
(
)
;
+
+
iter
)
{
if
(
*
iter
!
=
phi
)
{
return
false
;
}
}
if
(
phiBlock
!
=
testBlock
&
&
!
testBlock
-
>
phisEmpty
(
)
)
{
return
false
;
}
*
pphi
=
phi
;
*
ptest
=
test
;
return
true
;
}
static
bool
IsTestInputMaybeToBool
(
MTest
*
test
MDefinition
*
value
)
{
auto
*
input
=
test
-
>
input
(
)
;
bool
hasEvenNumberOfNots
=
true
;
while
(
true
)
{
if
(
input
=
=
value
&
&
hasEvenNumberOfNots
)
{
return
true
;
}
if
(
input
-
>
isNot
(
)
)
{
input
=
input
-
>
toNot
(
)
-
>
input
(
)
;
hasEvenNumberOfNots
=
!
hasEvenNumberOfNots
;
continue
;
}
return
false
;
}
}
[
[
nodiscard
]
]
static
bool
UpdateGotoSuccessor
(
TempAllocator
&
alloc
MBasicBlock
*
block
MDefinition
*
blockResult
MBasicBlock
*
target
MBasicBlock
*
existingPred
)
{
blockResult
-
>
setImplicitlyUsedUnchecked
(
)
;
MInstruction
*
ins
=
block
-
>
lastIns
(
)
;
MOZ_ASSERT
(
ins
-
>
isGoto
(
)
)
;
ins
-
>
toGoto
(
)
-
>
target
(
)
-
>
removePredecessor
(
block
)
;
block
-
>
discardLastIns
(
)
;
MGoto
*
newGoto
=
MGoto
:
:
New
(
alloc
target
)
;
block
-
>
end
(
newGoto
)
;
return
target
-
>
addPredecessorSameInputsAs
(
block
existingPred
)
;
}
[
[
nodiscard
]
]
static
bool
UpdateTestSuccessors
(
TempAllocator
&
alloc
MBasicBlock
*
block
MDefinition
*
value
MBasicBlock
*
ifTrue
MBasicBlock
*
ifFalse
MBasicBlock
*
existingPred
)
{
MInstruction
*
ins
=
block
-
>
lastIns
(
)
;
if
(
ins
-
>
isTest
(
)
)
{
MTest
*
test
=
ins
-
>
toTest
(
)
;
MOZ_ASSERT
(
test
-
>
input
(
)
=
=
value
)
;
if
(
ifTrue
!
=
test
-
>
ifTrue
(
)
)
{
test
-
>
ifTrue
(
)
-
>
removePredecessor
(
block
)
;
if
(
!
ifTrue
-
>
addPredecessorSameInputsAs
(
block
existingPred
)
)
{
return
false
;
}
MOZ_ASSERT
(
test
-
>
ifTrue
(
)
=
=
test
-
>
getSuccessor
(
0
)
)
;
test
-
>
replaceSuccessor
(
0
ifTrue
)
;
}
if
(
ifFalse
!
=
test
-
>
ifFalse
(
)
)
{
test
-
>
ifFalse
(
)
-
>
removePredecessor
(
block
)
;
if
(
!
ifFalse
-
>
addPredecessorSameInputsAs
(
block
existingPred
)
)
{
return
false
;
}
MOZ_ASSERT
(
test
-
>
ifFalse
(
)
=
=
test
-
>
getSuccessor
(
1
)
)
;
test
-
>
replaceSuccessor
(
1
ifFalse
)
;
}
return
true
;
}
MOZ_ASSERT
(
ins
-
>
isGoto
(
)
)
;
ins
-
>
toGoto
(
)
-
>
target
(
)
-
>
removePredecessor
(
block
)
;
block
-
>
discardLastIns
(
)
;
MTest
*
test
=
MTest
:
:
New
(
alloc
value
ifTrue
ifFalse
)
;
block
-
>
end
(
test
)
;
if
(
!
ifTrue
-
>
addPredecessorSameInputsAs
(
block
existingPred
)
)
{
return
false
;
}
if
(
!
ifFalse
-
>
addPredecessorSameInputsAs
(
block
existingPred
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsDiamondPattern
(
MBasicBlock
*
initialBlock
)
{
MInstruction
*
ins
=
initialBlock
-
>
lastIns
(
)
;
if
(
!
ins
-
>
isTest
(
)
)
{
return
false
;
}
MTest
*
initialTest
=
ins
-
>
toTest
(
)
;
MBasicBlock
*
trueBranch
=
initialTest
-
>
ifTrue
(
)
;
if
(
trueBranch
-
>
numPredecessors
(
)
!
=
1
|
|
!
trueBranch
-
>
lastIns
(
)
-
>
isGoto
(
)
)
{
return
false
;
}
MBasicBlock
*
falseBranch
=
initialTest
-
>
ifFalse
(
)
;
if
(
falseBranch
-
>
numPredecessors
(
)
!
=
1
|
|
!
falseBranch
-
>
lastIns
(
)
-
>
isGoto
(
)
)
{
return
false
;
}
MBasicBlock
*
phiBlock
=
trueBranch
-
>
getSuccessor
(
0
)
;
if
(
phiBlock
!
=
falseBranch
-
>
getSuccessor
(
0
)
)
{
return
false
;
}
if
(
phiBlock
-
>
numPredecessors
(
)
!
=
2
)
{
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
MaybeFoldDiamondConditionBlock
(
MIRGraph
&
graph
MBasicBlock
*
initialBlock
)
{
MOZ_ASSERT
(
IsDiamondPattern
(
initialBlock
)
)
;
MTest
*
initialTest
=
initialBlock
-
>
lastIns
(
)
-
>
toTest
(
)
;
MBasicBlock
*
trueBranch
=
initialTest
-
>
ifTrue
(
)
;
MBasicBlock
*
falseBranch
=
initialTest
-
>
ifFalse
(
)
;
if
(
initialBlock
-
>
isLoopBackedge
(
)
|
|
trueBranch
-
>
isLoopBackedge
(
)
|
|
falseBranch
-
>
isLoopBackedge
(
)
)
{
return
true
;
}
MBasicBlock
*
phiBlock
=
trueBranch
-
>
getSuccessor
(
0
)
;
MBasicBlock
*
testBlock
=
phiBlock
;
if
(
testBlock
-
>
numSuccessors
(
)
=
=
1
)
{
if
(
testBlock
-
>
isLoopBackedge
(
)
)
{
return
true
;
}
testBlock
=
testBlock
-
>
getSuccessor
(
0
)
;
if
(
testBlock
-
>
numPredecessors
(
)
!
=
1
)
{
return
true
;
}
}
MPhi
*
phi
;
MTest
*
finalTest
;
if
(
!
BlockIsSingleTest
(
phiBlock
testBlock
&
phi
&
finalTest
)
)
{
return
true
;
}
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
2
)
;
if
(
!
SplitCriticalEdgesForBlock
(
graph
testBlock
)
)
{
return
false
;
}
MDefinition
*
trueResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
trueBranch
)
)
;
MDefinition
*
falseResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
falseBranch
)
)
;
phiBlock
-
>
discardPhi
(
*
phiBlock
-
>
phisBegin
(
)
)
;
if
(
IsTestInputMaybeToBool
(
initialTest
trueResult
)
)
{
if
(
!
UpdateGotoSuccessor
(
graph
.
alloc
(
)
trueBranch
trueResult
finalTest
-
>
ifTrue
(
)
testBlock
)
)
{
return
false
;
}
}
else
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
trueBranch
trueResult
finalTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
if
(
IsTestInputMaybeToBool
(
initialTest
falseResult
)
)
{
if
(
!
UpdateGotoSuccessor
(
graph
.
alloc
(
)
falseBranch
falseResult
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
else
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
falseBranch
falseResult
finalTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
if
(
phiBlock
!
=
testBlock
)
{
testBlock
-
>
removePredecessor
(
phiBlock
)
;
graph
.
removeBlock
(
phiBlock
)
;
}
finalTest
-
>
ifTrue
(
)
-
>
removePredecessor
(
testBlock
)
;
finalTest
-
>
ifFalse
(
)
-
>
removePredecessor
(
testBlock
)
;
graph
.
removeBlock
(
testBlock
)
;
return
true
;
}
static
bool
IsTrianglePattern
(
MBasicBlock
*
initialBlock
)
{
MInstruction
*
ins
=
initialBlock
-
>
lastIns
(
)
;
if
(
!
ins
-
>
isTest
(
)
)
{
return
false
;
}
MTest
*
initialTest
=
ins
-
>
toTest
(
)
;
MBasicBlock
*
trueBranch
=
initialTest
-
>
ifTrue
(
)
;
MBasicBlock
*
falseBranch
=
initialTest
-
>
ifFalse
(
)
;
if
(
trueBranch
-
>
numSuccessors
(
)
=
=
1
&
&
trueBranch
-
>
getSuccessor
(
0
)
=
=
falseBranch
)
{
if
(
trueBranch
-
>
numPredecessors
(
)
!
=
1
)
{
return
false
;
}
if
(
falseBranch
-
>
numPredecessors
(
)
!
=
2
)
{
return
false
;
}
return
true
;
}
if
(
falseBranch
-
>
numSuccessors
(
)
=
=
1
&
&
falseBranch
-
>
getSuccessor
(
0
)
=
=
trueBranch
)
{
if
(
trueBranch
-
>
numPredecessors
(
)
!
=
2
)
{
return
false
;
}
if
(
falseBranch
-
>
numPredecessors
(
)
!
=
1
)
{
return
false
;
}
return
true
;
}
return
false
;
}
[
[
nodiscard
]
]
static
bool
MaybeFoldTriangleConditionBlock
(
MIRGraph
&
graph
MBasicBlock
*
initialBlock
)
{
MOZ_ASSERT
(
IsTrianglePattern
(
initialBlock
)
)
;
MTest
*
initialTest
=
initialBlock
-
>
lastIns
(
)
-
>
toTest
(
)
;
MBasicBlock
*
trueBranch
=
initialTest
-
>
ifTrue
(
)
;
MBasicBlock
*
falseBranch
=
initialTest
-
>
ifFalse
(
)
;
if
(
initialBlock
-
>
isLoopBackedge
(
)
|
|
trueBranch
-
>
isLoopBackedge
(
)
|
|
falseBranch
-
>
isLoopBackedge
(
)
)
{
return
true
;
}
MBasicBlock
*
phiBlock
;
if
(
trueBranch
-
>
numSuccessors
(
)
=
=
1
&
&
trueBranch
-
>
getSuccessor
(
0
)
=
=
falseBranch
)
{
phiBlock
=
falseBranch
;
}
else
{
MOZ_ASSERT
(
falseBranch
-
>
getSuccessor
(
0
)
=
=
trueBranch
)
;
phiBlock
=
trueBranch
;
}
MBasicBlock
*
testBlock
=
phiBlock
;
if
(
testBlock
-
>
numSuccessors
(
)
=
=
1
)
{
MOZ_ASSERT
(
!
testBlock
-
>
isLoopBackedge
(
)
)
;
testBlock
=
testBlock
-
>
getSuccessor
(
0
)
;
if
(
testBlock
-
>
numPredecessors
(
)
!
=
1
)
{
return
true
;
}
}
MPhi
*
phi
;
MTest
*
finalTest
;
if
(
!
BlockIsSingleTest
(
phiBlock
testBlock
&
phi
&
finalTest
)
)
{
return
true
;
}
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
2
)
;
auto
*
phiInputForInitialBlock
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
initialBlock
)
)
;
if
(
!
IsTestInputMaybeToBool
(
initialTest
phiInputForInitialBlock
)
)
{
return
true
;
}
if
(
!
SplitCriticalEdgesForBlock
(
graph
testBlock
)
)
{
return
false
;
}
MDefinition
*
trueResult
;
MDefinition
*
falseResult
;
if
(
phiBlock
=
=
trueBranch
)
{
trueResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
initialBlock
)
)
;
falseResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
falseBranch
)
)
;
}
else
{
trueResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
trueBranch
)
)
;
falseResult
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
initialBlock
)
)
;
}
phiBlock
-
>
discardPhi
(
*
phiBlock
-
>
phisBegin
(
)
)
;
if
(
phiBlock
=
=
trueBranch
)
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
initialBlock
initialTest
-
>
input
(
)
finalTest
-
>
ifTrue
(
)
initialTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
else
if
(
IsTestInputMaybeToBool
(
initialTest
trueResult
)
)
{
if
(
!
UpdateGotoSuccessor
(
graph
.
alloc
(
)
trueBranch
trueResult
finalTest
-
>
ifTrue
(
)
testBlock
)
)
{
return
false
;
}
}
else
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
trueBranch
trueResult
finalTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
if
(
phiBlock
=
=
falseBranch
)
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
initialBlock
initialTest
-
>
input
(
)
initialTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
else
if
(
IsTestInputMaybeToBool
(
initialTest
falseResult
)
)
{
if
(
!
UpdateGotoSuccessor
(
graph
.
alloc
(
)
falseBranch
falseResult
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
else
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
falseBranch
falseResult
finalTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
if
(
phiBlock
!
=
testBlock
)
{
testBlock
-
>
removePredecessor
(
phiBlock
)
;
graph
.
removeBlock
(
phiBlock
)
;
}
finalTest
-
>
ifTrue
(
)
-
>
removePredecessor
(
testBlock
)
;
finalTest
-
>
ifFalse
(
)
-
>
removePredecessor
(
testBlock
)
;
graph
.
removeBlock
(
testBlock
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
MaybeFoldConditionBlock
(
MIRGraph
&
graph
MBasicBlock
*
initialBlock
)
{
if
(
IsDiamondPattern
(
initialBlock
)
)
{
return
MaybeFoldDiamondConditionBlock
(
graph
initialBlock
)
;
}
if
(
IsTrianglePattern
(
initialBlock
)
)
{
return
MaybeFoldTriangleConditionBlock
(
graph
initialBlock
)
;
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
MaybeFoldTestBlock
(
MIRGraph
&
graph
MBasicBlock
*
initialBlock
)
{
auto
*
ins
=
initialBlock
-
>
lastIns
(
)
;
if
(
!
ins
-
>
isTest
(
)
)
{
return
true
;
}
auto
*
initialTest
=
ins
-
>
toTest
(
)
;
MBasicBlock
*
trueBranch
=
initialTest
-
>
ifTrue
(
)
;
MBasicBlock
*
falseBranch
=
initialTest
-
>
ifFalse
(
)
;
MBasicBlock
*
phiBlock
;
if
(
trueBranch
-
>
numPredecessors
(
)
>
2
)
{
phiBlock
=
trueBranch
;
}
else
if
(
falseBranch
-
>
numPredecessors
(
)
>
2
)
{
phiBlock
=
falseBranch
;
}
else
{
return
true
;
}
MBasicBlock
*
testBlock
=
phiBlock
;
if
(
testBlock
-
>
numSuccessors
(
)
=
=
1
)
{
if
(
testBlock
-
>
isLoopBackedge
(
)
)
{
return
true
;
}
testBlock
=
testBlock
-
>
getSuccessor
(
0
)
;
if
(
testBlock
-
>
numPredecessors
(
)
!
=
1
)
{
return
true
;
}
}
MOZ_ASSERT
(
!
phiBlock
-
>
isLoopBackedge
(
)
)
;
MPhi
*
phi
=
nullptr
;
MTest
*
finalTest
=
nullptr
;
if
(
!
BlockIsSingleTest
(
phiBlock
testBlock
&
phi
&
finalTest
)
)
{
return
true
;
}
MOZ_ASSERT
(
phiBlock
-
>
numPredecessors
(
)
=
=
phi
-
>
numOperands
(
)
)
;
auto
*
phiInputForInitialBlock
=
phi
-
>
getOperand
(
phiBlock
-
>
indexForPredecessor
(
initialBlock
)
)
;
if
(
!
IsTestInputMaybeToBool
(
initialTest
phiInputForInitialBlock
)
)
{
return
true
;
}
MBasicBlock
*
newTestBlock
=
nullptr
;
MDefinition
*
newTestInput
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
phiBlock
-
>
numPredecessors
(
)
;
i
+
+
)
{
auto
*
pred
=
phiBlock
-
>
getPredecessor
(
i
)
;
auto
*
operand
=
phi
-
>
getOperand
(
i
)
;
auto
*
lastIns
=
pred
-
>
lastIns
(
)
;
if
(
lastIns
-
>
isGoto
(
)
&
&
!
newTestBlock
)
{
newTestBlock
=
pred
;
newTestInput
=
operand
;
}
else
if
(
lastIns
-
>
isTest
(
)
)
{
if
(
!
IsTestInputMaybeToBool
(
lastIns
-
>
toTest
(
)
operand
)
)
{
return
true
;
}
}
else
{
return
true
;
}
MOZ_ASSERT
(
!
pred
-
>
isLoopBackedge
(
)
)
;
}
if
(
!
newTestBlock
)
{
return
true
;
}
if
(
!
SplitCriticalEdgesForBlock
(
graph
testBlock
)
)
{
return
false
;
}
phiBlock
-
>
discardPhi
(
*
phiBlock
-
>
phisBegin
(
)
)
;
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
newTestBlock
newTestInput
finalTest
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
while
(
phiBlock
-
>
numPredecessors
(
)
)
{
mozilla
:
:
DebugOnly
<
size_t
>
oldNumPred
=
phiBlock
-
>
numPredecessors
(
)
;
auto
*
pred
=
phiBlock
-
>
getPredecessor
(
0
)
;
auto
*
test
=
pred
-
>
lastIns
(
)
-
>
toTest
(
)
;
if
(
test
-
>
ifTrue
(
)
=
=
phiBlock
)
{
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
pred
test
-
>
input
(
)
finalTest
-
>
ifTrue
(
)
test
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
test
-
>
ifFalse
(
)
=
=
phiBlock
)
;
if
(
!
UpdateTestSuccessors
(
graph
.
alloc
(
)
pred
test
-
>
input
(
)
test
-
>
ifTrue
(
)
finalTest
-
>
ifFalse
(
)
testBlock
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
phiBlock
-
>
numPredecessors
(
)
+
1
=
=
oldNumPred
)
;
}
if
(
phiBlock
!
=
testBlock
)
{
testBlock
-
>
removePredecessor
(
phiBlock
)
;
graph
.
removeBlock
(
phiBlock
)
;
}
finalTest
-
>
ifTrue
(
)
-
>
removePredecessor
(
testBlock
)
;
finalTest
-
>
ifFalse
(
)
-
>
removePredecessor
(
testBlock
)
;
graph
.
removeBlock
(
testBlock
)
;
return
true
;
}
bool
jit
:
:
FoldTests
(
MIRGraph
&
graph
)
{
for
(
PostorderIterator
block
(
graph
.
poBegin
(
)
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
!
MaybeFoldConditionBlock
(
graph
*
block
)
)
{
return
false
;
}
if
(
!
MaybeFoldTestBlock
(
graph
*
block
)
)
{
return
false
;
}
}
return
true
;
}
bool
jit
:
:
FoldEmptyBlocks
(
MIRGraph
&
graph
bool
*
changed
)
{
*
changed
=
false
;
for
(
MBasicBlockIterator
iter
(
graph
.
begin
(
)
)
;
iter
!
=
graph
.
end
(
)
;
)
{
MBasicBlock
*
block
=
*
iter
;
iter
+
+
;
if
(
block
-
>
numPredecessors
(
)
!
=
1
|
|
block
-
>
numSuccessors
(
)
!
=
1
)
{
continue
;
}
if
(
!
block
-
>
phisEmpty
(
)
)
{
continue
;
}
if
(
block
-
>
outerResumePoint
(
)
)
{
continue
;
}
if
(
*
block
-
>
begin
(
)
!
=
*
block
-
>
rbegin
(
)
)
{
continue
;
}
MBasicBlock
*
succ
=
block
-
>
getSuccessor
(
0
)
;
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
0
)
;
if
(
succ
-
>
numPredecessors
(
)
!
=
1
)
{
continue
;
}
size_t
pos
=
pred
-
>
getSuccessorIndex
(
block
)
;
pred
-
>
lastIns
(
)
-
>
replaceSuccessor
(
pos
succ
)
;
graph
.
removeBlock
(
block
)
;
if
(
!
succ
-
>
addPredecessorSameInputsAs
(
pred
block
)
)
{
return
false
;
}
succ
-
>
removePredecessor
(
block
)
;
*
changed
=
true
;
}
return
true
;
}
static
void
EliminateTriviallyDeadResumePointOperands
(
MIRGraph
&
graph
MResumePoint
*
rp
)
{
if
(
rp
-
>
mode
(
)
!
=
ResumeMode
:
:
ResumeAt
)
{
return
;
}
jsbytecode
*
pc
=
rp
-
>
pc
(
)
;
if
(
JSOp
(
*
pc
)
=
=
JSOp
:
:
JumpTarget
)
{
pc
+
=
JSOpLength_JumpTarget
;
}
if
(
JSOp
(
*
pc
)
!
=
JSOp
:
:
Pop
)
{
return
;
}
size_t
top
=
rp
-
>
stackDepth
(
)
-
1
;
MOZ_ASSERT
(
!
rp
-
>
isObservableOperand
(
top
)
)
;
MDefinition
*
def
=
rp
-
>
getOperand
(
top
)
;
if
(
def
-
>
isConstant
(
)
)
{
return
;
}
MConstant
*
constant
=
rp
-
>
block
(
)
-
>
optimizedOutConstant
(
graph
.
alloc
(
)
)
;
rp
-
>
replaceOperand
(
top
constant
)
;
}
bool
jit
:
:
EliminateTriviallyDeadResumePointOperands
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
for
(
auto
*
block
:
graph
)
{
if
(
MResumePoint
*
rp
=
block
-
>
entryResumePoint
(
)
)
{
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
:
:
EliminateTriviallyDeadResumePointOperands
(
graph
rp
)
;
}
}
return
true
;
}
bool
jit
:
:
EliminateDeadResumePointOperands
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
if
(
graph
.
hasTryBlock
(
)
)
{
return
true
;
}
for
(
PostorderIterator
block
=
graph
.
poBegin
(
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Eliminate
Dead
Resume
Point
Operands
(
main
loop
)
"
)
)
{
return
false
;
}
if
(
MResumePoint
*
rp
=
block
-
>
entryResumePoint
(
)
)
{
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
:
:
EliminateTriviallyDeadResumePointOperands
(
graph
rp
)
;
}
if
(
block
-
>
isLoopHeader
(
)
&
&
block
-
>
backedge
(
)
=
=
*
block
)
{
continue
;
}
for
(
MInstructionIterator
ins
=
block
-
>
begin
(
)
;
ins
!
=
block
-
>
end
(
)
;
ins
+
+
)
{
if
(
MResumePoint
*
rp
=
ins
-
>
resumePoint
(
)
)
{
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
:
:
EliminateTriviallyDeadResumePointOperands
(
graph
rp
)
;
}
if
(
ins
-
>
isConstant
(
)
)
{
continue
;
}
if
(
ins
-
>
isUnbox
(
)
|
|
ins
-
>
isParameter
(
)
|
|
ins
-
>
isBoxNonStrictThis
(
)
)
{
continue
;
}
if
(
ins
-
>
isRecoveredOnBailout
(
)
)
{
MOZ_ASSERT
(
ins
-
>
canRecoverOnBailout
(
)
)
;
continue
;
}
if
(
ins
-
>
isImplicitlyUsed
(
)
)
{
continue
;
}
uint32_t
maxDefinition
=
0
;
for
(
MUseIterator
uses
(
ins
-
>
usesBegin
(
)
)
;
uses
!
=
ins
-
>
usesEnd
(
)
;
uses
+
+
)
{
MNode
*
consumer
=
uses
-
>
consumer
(
)
;
if
(
consumer
-
>
isResumePoint
(
)
)
{
MResumePoint
*
resume
=
consumer
-
>
toResumePoint
(
)
;
if
(
resume
-
>
isObservableOperand
(
*
uses
)
)
{
maxDefinition
=
UINT32_MAX
;
break
;
}
continue
;
}
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
if
(
def
-
>
block
(
)
!
=
*
block
|
|
def
-
>
isBox
(
)
|
|
def
-
>
isPhi
(
)
)
{
maxDefinition
=
UINT32_MAX
;
break
;
}
maxDefinition
=
std
:
:
max
(
maxDefinition
def
-
>
id
(
)
)
;
}
if
(
maxDefinition
=
=
UINT32_MAX
)
{
continue
;
}
for
(
MUseIterator
uses
(
ins
-
>
usesBegin
(
)
)
;
uses
!
=
ins
-
>
usesEnd
(
)
;
)
{
MUse
*
use
=
*
uses
+
+
;
if
(
use
-
>
consumer
(
)
-
>
isDefinition
(
)
)
{
continue
;
}
MResumePoint
*
mrp
=
use
-
>
consumer
(
)
-
>
toResumePoint
(
)
;
if
(
mrp
-
>
block
(
)
!
=
*
block
|
|
!
mrp
-
>
instruction
(
)
|
|
mrp
-
>
instruction
(
)
=
=
*
ins
|
|
mrp
-
>
instruction
(
)
-
>
id
(
)
<
=
maxDefinition
)
{
continue
;
}
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MConstant
*
constant
=
MConstant
:
:
NewMagic
(
graph
.
alloc
(
)
JS_OPTIMIZED_OUT
)
;
block
-
>
insertBefore
(
*
(
block
-
>
begin
(
)
)
constant
)
;
use
-
>
replaceProducer
(
constant
)
;
}
}
}
return
true
;
}
bool
js
:
:
jit
:
:
DeadIfUnused
(
const
MDefinition
*
def
)
{
if
(
def
-
>
isEffectful
(
)
)
{
return
false
;
}
if
(
def
-
>
isGuard
(
)
)
{
return
false
;
}
if
(
def
-
>
isGuardRangeBailouts
(
)
)
{
return
false
;
}
if
(
def
-
>
isControlInstruction
(
)
)
{
return
false
;
}
if
(
def
-
>
isInstruction
(
)
&
&
def
-
>
toInstruction
(
)
-
>
resumePoint
(
)
)
{
return
false
;
}
return
true
;
}
bool
js
:
:
jit
:
:
DeadIfUnusedAllowEffectful
(
const
MDefinition
*
def
)
{
if
(
def
-
>
isGuard
(
)
)
{
return
false
;
}
if
(
def
-
>
isGuardRangeBailouts
(
)
)
{
return
false
;
}
if
(
def
-
>
isControlInstruction
(
)
)
{
return
false
;
}
if
(
def
-
>
isInstruction
(
)
&
&
def
-
>
toInstruction
(
)
-
>
resumePoint
(
)
)
{
if
(
!
def
-
>
isEffectful
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
js
:
:
jit
:
:
IsDiscardable
(
const
MDefinition
*
def
)
{
return
!
def
-
>
hasUses
(
)
&
&
(
DeadIfUnused
(
def
)
|
|
def
-
>
block
(
)
-
>
isMarked
(
)
)
;
}
bool
js
:
:
jit
:
:
IsDiscardableAllowEffectful
(
const
MDefinition
*
def
)
{
return
!
def
-
>
hasUses
(
)
&
&
(
DeadIfUnusedAllowEffectful
(
def
)
|
|
def
-
>
block
(
)
-
>
isMarked
(
)
)
;
}
bool
jit
:
:
EliminateDeadCode
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
for
(
PostorderIterator
block
=
graph
.
poBegin
(
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Eliminate
Dead
Code
(
main
loop
)
"
)
)
{
return
false
;
}
for
(
MInstructionReverseIterator
iter
=
block
-
>
rbegin
(
)
;
iter
!
=
block
-
>
rend
(
)
;
)
{
MInstruction
*
inst
=
*
iter
+
+
;
if
(
js
:
:
jit
:
:
IsDiscardable
(
inst
)
)
{
block
-
>
discard
(
inst
)
;
}
}
}
return
true
;
}
static
inline
bool
IsPhiObservable
(
MPhi
*
phi
Observability
observe
)
{
if
(
phi
-
>
isImplicitlyUsed
(
)
)
{
return
true
;
}
for
(
MUseIterator
iter
(
phi
-
>
usesBegin
(
)
)
;
iter
!
=
phi
-
>
usesEnd
(
)
;
iter
+
+
)
{
MNode
*
consumer
=
iter
-
>
consumer
(
)
;
if
(
consumer
-
>
isResumePoint
(
)
)
{
MResumePoint
*
resume
=
consumer
-
>
toResumePoint
(
)
;
if
(
observe
=
=
ConservativeObservability
)
{
return
true
;
}
if
(
resume
-
>
isObservableOperand
(
*
iter
)
)
{
return
true
;
}
}
else
{
MDefinition
*
def
=
consumer
-
>
toDefinition
(
)
;
if
(
!
def
-
>
isPhi
(
)
)
{
return
true
;
}
}
}
return
false
;
}
static
inline
MDefinition
*
IsPhiRedundant
(
MPhi
*
phi
)
{
MDefinition
*
first
=
phi
-
>
operandIfRedundant
(
)
;
if
(
first
=
=
nullptr
)
{
return
nullptr
;
}
if
(
phi
-
>
isImplicitlyUsed
(
)
)
{
first
-
>
setImplicitlyUsedUnchecked
(
)
;
}
return
first
;
}
bool
jit
:
:
EliminatePhis
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
Observability
observe
)
{
Vector
<
MPhi
*
16
SystemAllocPolicy
>
worklist
;
for
(
PostorderIterator
block
=
graph
.
poBegin
(
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
MPhiIterator
iter
=
block
-
>
phisBegin
(
)
;
while
(
iter
!
=
block
-
>
phisEnd
(
)
)
{
MPhi
*
phi
=
*
iter
+
+
;
if
(
mir
-
>
shouldCancel
(
"
Eliminate
Phis
(
populate
loop
)
"
)
)
{
return
false
;
}
phi
-
>
setUnused
(
)
;
if
(
MDefinition
*
redundant
=
IsPhiRedundant
(
phi
)
)
{
phi
-
>
justReplaceAllUsesWith
(
redundant
)
;
block
-
>
discardPhi
(
phi
)
;
continue
;
}
if
(
IsPhiObservable
(
phi
observe
)
)
{
phi
-
>
setInWorklist
(
)
;
if
(
!
worklist
.
append
(
phi
)
)
{
return
false
;
}
}
}
}
while
(
!
worklist
.
empty
(
)
)
{
if
(
mir
-
>
shouldCancel
(
"
Eliminate
Phis
(
worklist
)
"
)
)
{
return
false
;
}
MPhi
*
phi
=
worklist
.
popCopy
(
)
;
MOZ_ASSERT
(
phi
-
>
isUnused
(
)
)
;
phi
-
>
setNotInWorklist
(
)
;
if
(
MDefinition
*
redundant
=
IsPhiRedundant
(
phi
)
)
{
for
(
MUseDefIterator
it
(
phi
)
;
it
;
it
+
+
)
{
if
(
it
.
def
(
)
-
>
isPhi
(
)
)
{
MPhi
*
use
=
it
.
def
(
)
-
>
toPhi
(
)
;
if
(
!
use
-
>
isUnused
(
)
)
{
use
-
>
setUnusedUnchecked
(
)
;
use
-
>
setInWorklist
(
)
;
if
(
!
worklist
.
append
(
use
)
)
{
return
false
;
}
}
}
}
phi
-
>
justReplaceAllUsesWith
(
redundant
)
;
}
else
{
phi
-
>
setNotUnused
(
)
;
}
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
in
=
phi
-
>
getOperand
(
i
)
;
if
(
!
in
-
>
isPhi
(
)
|
|
!
in
-
>
isUnused
(
)
|
|
in
-
>
isInWorklist
(
)
)
{
continue
;
}
in
-
>
setInWorklist
(
)
;
if
(
!
worklist
.
append
(
in
-
>
toPhi
(
)
)
)
{
return
false
;
}
}
}
for
(
PostorderIterator
block
=
graph
.
poBegin
(
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Eliminate
Phis
(
sweep
dead
phis
)
"
)
)
{
return
false
;
}
MPhiIterator
iter
=
block
-
>
phisBegin
(
)
;
while
(
iter
!
=
block
-
>
phisEnd
(
)
)
{
MPhi
*
phi
=
*
iter
+
+
;
if
(
phi
-
>
isUnused
(
)
)
{
if
(
!
phi
-
>
optimizeOutAllUses
(
graph
.
alloc
(
)
)
)
{
return
false
;
}
block
-
>
discardPhi
(
phi
)
;
}
}
}
return
true
;
}
namespace
{
class
TypeAnalyzer
{
const
MIRGenerator
*
mir
;
MIRGraph
&
graph
;
Vector
<
MPhi
*
0
SystemAllocPolicy
>
phiWorklist_
;
TempAllocator
&
alloc
(
)
const
{
return
graph
.
alloc
(
)
;
}
bool
addPhiToWorklist
(
MPhi
*
phi
)
{
if
(
phi
-
>
isInWorklist
(
)
)
{
return
true
;
}
if
(
!
phiWorklist_
.
append
(
phi
)
)
{
return
false
;
}
phi
-
>
setInWorklist
(
)
;
return
true
;
}
MPhi
*
popPhi
(
)
{
MPhi
*
phi
=
phiWorklist_
.
popCopy
(
)
;
phi
-
>
setNotInWorklist
(
)
;
return
phi
;
}
[
[
nodiscard
]
]
bool
propagateAllPhiSpecializations
(
)
;
bool
respecialize
(
MPhi
*
phi
MIRType
type
)
;
bool
propagateSpecialization
(
MPhi
*
phi
)
;
bool
specializePhis
(
)
;
bool
specializeOsrOnlyPhis
(
)
;
void
replaceRedundantPhi
(
MPhi
*
phi
)
;
bool
adjustPhiInputs
(
MPhi
*
phi
)
;
bool
adjustInputs
(
MDefinition
*
def
)
;
bool
insertConversions
(
)
;
bool
checkFloatCoherency
(
)
;
bool
graphContainsFloat32
(
)
;
bool
markPhiConsumers
(
)
;
bool
markPhiProducers
(
)
;
bool
specializeValidFloatOps
(
)
;
bool
tryEmitFloatOperations
(
)
;
bool
propagateUnbox
(
)
;
bool
shouldSpecializeOsrPhis
(
)
const
;
MIRType
guessPhiType
(
MPhi
*
phi
)
const
;
public
:
TypeAnalyzer
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
:
mir
(
mir
)
graph
(
graph
)
{
}
bool
analyze
(
)
;
}
;
}
bool
TypeAnalyzer
:
:
shouldSpecializeOsrPhis
(
)
const
{
if
(
!
graph
.
osrBlock
(
)
)
{
return
false
;
}
return
!
mir
-
>
outerInfo
(
)
.
hadSpeculativePhiBailout
(
)
;
}
MIRType
TypeAnalyzer
:
:
guessPhiType
(
MPhi
*
phi
)
const
{
#
ifdef
DEBUG
MIRType
magicType
=
MIRType
:
:
None
;
for
(
size_t
i
=
0
;
i
<
phi
-
>
numOperands
(
)
;
i
+
+
)
{
MDefinition
*
in
=
phi
-
>
getOperand
(
i
)
;
if
(
in
-
>
type
(
)
=
=
MIRType
:
:
MagicHole
|
|
in
-
>
type
(
)
=
=
MIRType
:
:
MagicIsConstructing
)
{
if
(
magicType
=
=
MIRType
:
:
None
)
{
magicType
=
in
-
>
type
(
)
;
}
MOZ_ASSERT
(
magicType
=
=
in
-
>
type
(
)
)
;
}
}
#
endif
MIRType
type
=
MIRType
:
:
None
;
bool
convertibleToFloat32
=
false
;
bool
hasOSRValueInput
=
false
;
DebugOnly
<
bool
>
hasSpecializableInput
=
false
;
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
in
=
phi
-
>
getOperand
(
i
)
;
if
(
in
-
>
isPhi
(
)
)
{
hasSpecializableInput
=
true
;
if
(
!
in
-
>
toPhi
(
)
-
>
triedToSpecialize
(
)
)
{
continue
;
}
if
(
in
-
>
type
(
)
=
=
MIRType
:
:
None
)
{
continue
;
}
}
if
(
shouldSpecializeOsrPhis
(
)
&
&
in
-
>
isOsrValue
(
)
)
{
hasOSRValueInput
=
true
;
hasSpecializableInput
=
true
;
continue
;
}
if
(
type
=
=
MIRType
:
:
None
)
{
type
=
in
-
>
type
(
)
;
if
(
in
-
>
canProduceFloat32
(
)
&
&
!
mir
-
>
outerInfo
(
)
.
hadSpeculativePhiBailout
(
)
)
{
convertibleToFloat32
=
true
;
}
continue
;
}
if
(
type
=
=
in
-
>
type
(
)
)
{
convertibleToFloat32
=
convertibleToFloat32
&
&
in
-
>
canProduceFloat32
(
)
;
}
else
{
if
(
convertibleToFloat32
&
&
in
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
{
type
=
MIRType
:
:
Float32
;
}
else
if
(
IsTypeRepresentableAsDouble
(
type
)
&
&
IsTypeRepresentableAsDouble
(
in
-
>
type
(
)
)
)
{
type
=
MIRType
:
:
Double
;
convertibleToFloat32
=
convertibleToFloat32
&
&
in
-
>
canProduceFloat32
(
)
;
}
else
{
return
MIRType
:
:
Value
;
}
}
}
if
(
hasOSRValueInput
&
&
type
=
=
MIRType
:
:
Float32
)
{
type
=
MIRType
:
:
Double
;
}
MOZ_ASSERT_IF
(
type
=
=
MIRType
:
:
None
hasSpecializableInput
)
;
return
type
;
}
bool
TypeAnalyzer
:
:
respecialize
(
MPhi
*
phi
MIRType
type
)
{
if
(
phi
-
>
type
(
)
=
=
type
)
{
return
true
;
}
phi
-
>
specialize
(
type
)
;
return
addPhiToWorklist
(
phi
)
;
}
bool
TypeAnalyzer
:
:
propagateSpecialization
(
MPhi
*
phi
)
{
MOZ_ASSERT
(
phi
-
>
type
(
)
!
=
MIRType
:
:
None
)
;
for
(
MUseDefIterator
iter
(
phi
)
;
iter
;
iter
+
+
)
{
if
(
!
iter
.
def
(
)
-
>
isPhi
(
)
)
{
continue
;
}
MPhi
*
use
=
iter
.
def
(
)
-
>
toPhi
(
)
;
if
(
!
use
-
>
triedToSpecialize
(
)
)
{
continue
;
}
if
(
use
-
>
type
(
)
=
=
MIRType
:
:
None
)
{
MIRType
type
=
phi
-
>
type
(
)
;
if
(
type
=
=
MIRType
:
:
Float32
&
&
!
use
-
>
canProduceFloat32
(
)
)
{
type
=
MIRType
:
:
Double
;
}
if
(
!
respecialize
(
use
type
)
)
{
return
false
;
}
continue
;
}
if
(
use
-
>
type
(
)
!
=
phi
-
>
type
(
)
)
{
if
(
(
use
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
use
-
>
canProduceFloat32
(
)
&
&
phi
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
|
|
(
phi
-
>
type
(
)
=
=
MIRType
:
:
Int32
&
&
phi
-
>
canProduceFloat32
(
)
&
&
use
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
)
{
if
(
!
respecialize
(
use
MIRType
:
:
Float32
)
)
{
return
false
;
}
continue
;
}
if
(
IsTypeRepresentableAsDouble
(
use
-
>
type
(
)
)
&
&
IsTypeRepresentableAsDouble
(
phi
-
>
type
(
)
)
)
{
if
(
!
respecialize
(
use
MIRType
:
:
Double
)
)
{
return
false
;
}
continue
;
}
if
(
!
respecialize
(
use
MIRType
:
:
Value
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
propagateAllPhiSpecializations
(
)
{
while
(
!
phiWorklist_
.
empty
(
)
)
{
if
(
mir
-
>
shouldCancel
(
"
Specialize
Phis
(
worklist
)
"
)
)
{
return
false
;
}
MPhi
*
phi
=
popPhi
(
)
;
if
(
!
propagateSpecialization
(
phi
)
)
{
return
false
;
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
specializeOsrOnlyPhis
(
)
{
MOZ_ASSERT
(
graph
.
osrBlock
(
)
)
;
MOZ_ASSERT
(
graph
.
osrPreHeaderBlock
(
)
-
>
numPredecessors
(
)
=
=
1
)
;
for
(
PostorderIterator
block
(
graph
.
poBegin
(
)
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Specialize
osr
-
only
phis
(
main
loop
)
"
)
)
{
return
false
;
}
for
(
MPhiIterator
phi
(
block
-
>
phisBegin
(
)
)
;
phi
!
=
block
-
>
phisEnd
(
)
;
phi
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Specialize
osr
-
only
phis
(
inner
loop
)
"
)
)
{
return
false
;
}
if
(
phi
-
>
type
(
)
=
=
MIRType
:
:
None
)
{
phi
-
>
specialize
(
MIRType
:
:
Value
)
;
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
specializePhis
(
)
{
for
(
PostorderIterator
block
(
graph
.
poBegin
(
)
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Specialize
Phis
(
main
loop
)
"
)
)
{
return
false
;
}
for
(
MPhiIterator
phi
(
block
-
>
phisBegin
(
)
)
;
phi
!
=
block
-
>
phisEnd
(
)
;
phi
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Specialize
Phis
(
inner
loop
)
"
)
)
{
return
false
;
}
MIRType
type
=
guessPhiType
(
*
phi
)
;
phi
-
>
specialize
(
type
)
;
if
(
type
=
=
MIRType
:
:
None
)
{
continue
;
}
if
(
!
propagateSpecialization
(
*
phi
)
)
{
return
false
;
}
}
}
if
(
!
propagateAllPhiSpecializations
(
)
)
{
return
false
;
}
if
(
shouldSpecializeOsrPhis
(
)
)
{
MBasicBlock
*
preHeader
=
graph
.
osrPreHeaderBlock
(
)
;
MBasicBlock
*
header
=
preHeader
-
>
getSingleSuccessor
(
)
;
if
(
preHeader
-
>
numPredecessors
(
)
=
=
1
)
{
MOZ_ASSERT
(
preHeader
-
>
getPredecessor
(
0
)
=
=
graph
.
osrBlock
(
)
)
;
if
(
!
specializeOsrOnlyPhis
(
)
)
{
return
false
;
}
}
else
if
(
header
-
>
isLoopHeader
(
)
)
{
for
(
MPhiIterator
phi
(
header
-
>
phisBegin
(
)
)
;
phi
!
=
header
-
>
phisEnd
(
)
;
phi
+
+
)
{
MPhi
*
preHeaderPhi
=
phi
-
>
getOperand
(
0
)
-
>
toPhi
(
)
;
MOZ_ASSERT
(
preHeaderPhi
-
>
block
(
)
=
=
preHeader
)
;
if
(
preHeaderPhi
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
continue
;
}
MIRType
loopType
=
phi
-
>
type
(
)
;
if
(
!
respecialize
(
preHeaderPhi
loopType
)
)
{
return
false
;
}
}
if
(
!
propagateAllPhiSpecializations
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
header
-
>
numPredecessors
(
)
=
=
1
)
;
}
}
MOZ_ASSERT
(
phiWorklist_
.
empty
(
)
)
;
return
true
;
}
bool
TypeAnalyzer
:
:
adjustPhiInputs
(
MPhi
*
phi
)
{
MIRType
phiType
=
phi
-
>
type
(
)
;
MOZ_ASSERT
(
phiType
!
=
MIRType
:
:
None
)
;
if
(
phiType
!
=
MIRType
:
:
Value
)
{
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
in
=
phi
-
>
getOperand
(
i
)
;
if
(
in
-
>
type
(
)
=
=
phiType
)
{
continue
;
}
if
(
in
-
>
isBox
(
)
&
&
in
-
>
toBox
(
)
-
>
input
(
)
-
>
type
(
)
=
=
phiType
)
{
phi
-
>
replaceOperand
(
i
in
-
>
toBox
(
)
-
>
input
(
)
)
;
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MBasicBlock
*
predecessor
=
phi
-
>
block
(
)
-
>
getPredecessor
(
i
)
;
MInstruction
*
replacement
;
if
(
IsFloatingPointType
(
phiType
)
&
&
IsTypeRepresentableAsDouble
(
in
-
>
type
(
)
)
)
{
if
(
phiType
=
=
MIRType
:
:
Double
)
{
replacement
=
MToDouble
:
:
New
(
alloc
(
)
in
)
;
}
else
{
MOZ_ASSERT
(
phiType
=
=
MIRType
:
:
Float32
)
;
replacement
=
MToFloat32
:
:
New
(
alloc
(
)
in
)
;
}
}
else
{
if
(
in
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
auto
*
box
=
MBox
:
:
New
(
alloc
(
)
in
)
;
predecessor
-
>
insertAtEnd
(
box
)
;
in
=
box
;
}
if
(
phiType
=
=
MIRType
:
:
Float32
)
{
auto
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
in
MIRType
:
:
Double
MUnbox
:
:
Fallible
)
;
unbox
-
>
setBailoutKind
(
BailoutKind
:
:
SpeculativePhi
)
;
predecessor
-
>
insertAtEnd
(
unbox
)
;
replacement
=
MToFloat32
:
:
New
(
alloc
(
)
unbox
)
;
}
else
{
replacement
=
MUnbox
:
:
New
(
alloc
(
)
in
phiType
MUnbox
:
:
Fallible
)
;
replacement
-
>
setBailoutKind
(
BailoutKind
:
:
SpeculativePhi
)
;
}
}
MOZ_ASSERT
(
replacement
-
>
type
(
)
=
=
phiType
)
;
predecessor
-
>
insertAtEnd
(
replacement
)
;
phi
-
>
replaceOperand
(
i
replacement
)
;
}
return
true
;
}
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
MDefinition
*
in
=
phi
-
>
getOperand
(
i
)
;
if
(
in
-
>
type
(
)
=
=
MIRType
:
:
Value
)
{
continue
;
}
if
(
in
-
>
isUnbox
(
)
)
{
MDefinition
*
unboxInput
=
in
-
>
toUnbox
(
)
-
>
input
(
)
;
if
(
!
IsMagicType
(
unboxInput
-
>
type
(
)
)
&
&
phi
-
>
typeIncludes
(
unboxInput
)
)
{
in
=
in
-
>
toUnbox
(
)
-
>
input
(
)
;
}
}
if
(
in
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MBasicBlock
*
pred
=
phi
-
>
block
(
)
-
>
getPredecessor
(
i
)
;
in
=
BoxAt
(
alloc
(
)
pred
-
>
lastIns
(
)
in
)
;
}
phi
-
>
replaceOperand
(
i
in
)
;
}
return
true
;
}
bool
TypeAnalyzer
:
:
adjustInputs
(
MDefinition
*
def
)
{
if
(
!
def
-
>
isInstruction
(
)
)
{
return
true
;
}
MInstruction
*
ins
=
def
-
>
toInstruction
(
)
;
const
TypePolicy
*
policy
=
ins
-
>
typePolicy
(
)
;
if
(
policy
&
&
!
policy
-
>
adjustInputs
(
alloc
(
)
ins
)
)
{
return
false
;
}
return
true
;
}
void
TypeAnalyzer
:
:
replaceRedundantPhi
(
MPhi
*
phi
)
{
MBasicBlock
*
block
=
phi
-
>
block
(
)
;
js
:
:
Value
v
;
switch
(
phi
-
>
type
(
)
)
{
case
MIRType
:
:
Undefined
:
v
=
UndefinedValue
(
)
;
break
;
case
MIRType
:
:
Null
:
v
=
NullValue
(
)
;
break
;
case
MIRType
:
:
MagicOptimizedOut
:
v
=
MagicValue
(
JS_OPTIMIZED_OUT
)
;
break
;
case
MIRType
:
:
MagicUninitializedLexical
:
v
=
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
;
break
;
case
MIRType
:
:
MagicIsConstructing
:
v
=
MagicValue
(
JS_IS_CONSTRUCTING
)
;
break
;
case
MIRType
:
:
MagicHole
:
default
:
MOZ_CRASH
(
"
unexpected
type
"
)
;
}
MConstant
*
c
=
MConstant
:
:
New
(
alloc
(
)
v
)
;
block
-
>
insertBefore
(
*
(
block
-
>
begin
(
)
)
c
)
;
phi
-
>
justReplaceAllUsesWith
(
c
)
;
if
(
shouldSpecializeOsrPhis
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
phi
-
>
numOperands
(
)
;
i
+
+
)
{
MDefinition
*
def
=
phi
-
>
getOperand
(
i
)
;
if
(
def
-
>
type
(
)
!
=
phi
-
>
type
(
)
)
{
MOZ_ASSERT
(
def
-
>
isOsrValue
(
)
|
|
def
-
>
isPhi
(
)
)
;
MOZ_ASSERT
(
def
-
>
type
(
)
=
=
MIRType
:
:
Value
)
;
MGuardValue
*
guard
=
MGuardValue
:
:
New
(
alloc
(
)
def
v
)
;
guard
-
>
setBailoutKind
(
BailoutKind
:
:
SpeculativePhi
)
;
def
-
>
block
(
)
-
>
insertBefore
(
def
-
>
block
(
)
-
>
lastIns
(
)
guard
)
;
}
}
}
}
bool
TypeAnalyzer
:
:
insertConversions
(
)
{
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Insert
Conversions
"
)
)
{
return
false
;
}
for
(
MPhiIterator
iter
(
block
-
>
phisBegin
(
)
)
end
(
block
-
>
phisEnd
(
)
)
;
iter
!
=
end
;
)
{
MPhi
*
phi
=
*
iter
+
+
;
if
(
IsNullOrUndefined
(
phi
-
>
type
(
)
)
|
|
IsMagicType
(
phi
-
>
type
(
)
)
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
replaceRedundantPhi
(
phi
)
;
block
-
>
discardPhi
(
phi
)
;
}
else
{
if
(
!
adjustPhiInputs
(
phi
)
)
{
return
false
;
}
}
}
for
(
MInstructionIterator
iter
(
block
-
>
begin
(
)
)
;
iter
!
=
block
-
>
end
(
)
;
iter
+
+
)
{
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
adjustInputs
(
*
iter
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
markPhiConsumers
(
)
{
MOZ_ASSERT
(
phiWorklist_
.
empty
(
)
)
;
for
(
PostorderIterator
block
(
graph
.
poBegin
(
)
)
;
block
!
=
graph
.
poEnd
(
)
;
+
+
block
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Consumer
Phis
-
Initial
state
"
)
)
{
return
false
;
}
for
(
MPhiIterator
phi
(
block
-
>
phisBegin
(
)
)
;
phi
!
=
block
-
>
phisEnd
(
)
;
+
+
phi
)
{
MOZ_ASSERT
(
!
phi
-
>
isInWorklist
(
)
)
;
bool
canConsumeFloat32
=
!
phi
-
>
isImplicitlyUsed
(
)
;
for
(
MUseDefIterator
use
(
*
phi
)
;
canConsumeFloat32
&
&
use
;
use
+
+
)
{
MDefinition
*
usedef
=
use
.
def
(
)
;
canConsumeFloat32
&
=
usedef
-
>
isPhi
(
)
|
|
usedef
-
>
canConsumeFloat32
(
use
.
use
(
)
)
;
}
phi
-
>
setCanConsumeFloat32
(
canConsumeFloat32
)
;
if
(
canConsumeFloat32
&
&
!
addPhiToWorklist
(
*
phi
)
)
{
return
false
;
}
}
}
while
(
!
phiWorklist_
.
empty
(
)
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Consumer
Phis
-
Fixed
point
"
)
)
{
return
false
;
}
MPhi
*
phi
=
popPhi
(
)
;
MOZ_ASSERT
(
phi
-
>
canConsumeFloat32
(
nullptr
)
)
;
bool
validConsumer
=
true
;
for
(
MUseDefIterator
use
(
phi
)
;
use
;
use
+
+
)
{
MDefinition
*
def
=
use
.
def
(
)
;
if
(
def
-
>
isPhi
(
)
&
&
!
def
-
>
canConsumeFloat32
(
use
.
use
(
)
)
)
{
validConsumer
=
false
;
break
;
}
}
if
(
validConsumer
)
{
continue
;
}
phi
-
>
setCanConsumeFloat32
(
false
)
;
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
input
=
phi
-
>
getOperand
(
i
)
;
if
(
input
-
>
isPhi
(
)
&
&
!
input
-
>
isInWorklist
(
)
&
&
input
-
>
canConsumeFloat32
(
nullptr
)
)
{
if
(
!
addPhiToWorklist
(
input
-
>
toPhi
(
)
)
)
{
return
false
;
}
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
markPhiProducers
(
)
{
MOZ_ASSERT
(
phiWorklist_
.
empty
(
)
)
;
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
+
+
block
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Producer
Phis
-
initial
state
"
)
)
{
return
false
;
}
for
(
MPhiIterator
phi
(
block
-
>
phisBegin
(
)
)
;
phi
!
=
block
-
>
phisEnd
(
)
;
+
+
phi
)
{
MOZ_ASSERT
(
!
phi
-
>
isInWorklist
(
)
)
;
bool
canProduceFloat32
=
true
;
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
canProduceFloat32
&
&
i
<
e
;
+
+
i
)
{
MDefinition
*
input
=
phi
-
>
getOperand
(
i
)
;
canProduceFloat32
&
=
input
-
>
isPhi
(
)
|
|
input
-
>
canProduceFloat32
(
)
;
}
phi
-
>
setCanProduceFloat32
(
canProduceFloat32
)
;
if
(
canProduceFloat32
&
&
!
addPhiToWorklist
(
*
phi
)
)
{
return
false
;
}
}
}
while
(
!
phiWorklist_
.
empty
(
)
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Producer
Phis
-
Fixed
point
"
)
)
{
return
false
;
}
MPhi
*
phi
=
popPhi
(
)
;
MOZ_ASSERT
(
phi
-
>
canProduceFloat32
(
)
)
;
bool
validProducer
=
true
;
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
input
=
phi
-
>
getOperand
(
i
)
;
if
(
input
-
>
isPhi
(
)
&
&
!
input
-
>
canProduceFloat32
(
)
)
{
validProducer
=
false
;
break
;
}
}
if
(
validProducer
)
{
continue
;
}
phi
-
>
setCanProduceFloat32
(
false
)
;
for
(
MUseDefIterator
use
(
phi
)
;
use
;
use
+
+
)
{
MDefinition
*
def
=
use
.
def
(
)
;
if
(
def
-
>
isPhi
(
)
&
&
!
def
-
>
isInWorklist
(
)
&
&
def
-
>
canProduceFloat32
(
)
)
{
if
(
!
addPhiToWorklist
(
def
-
>
toPhi
(
)
)
)
{
return
false
;
}
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
specializeValidFloatOps
(
)
{
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
+
+
block
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Instructions
"
)
)
{
return
false
;
}
for
(
MInstructionIterator
ins
(
block
-
>
begin
(
)
)
;
ins
!
=
block
-
>
end
(
)
;
+
+
ins
)
{
if
(
!
ins
-
>
isFloat32Commutative
(
)
)
{
continue
;
}
if
(
ins
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
ins
-
>
trySpecializeFloat32
(
alloc
(
)
)
;
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
graphContainsFloat32
(
)
{
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
+
+
block
)
{
for
(
MDefinitionIterator
def
(
*
block
)
;
def
;
def
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Ensure
Float32
commutativity
-
Graph
contains
Float32
"
)
)
{
return
false
;
}
if
(
def
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
{
return
true
;
}
}
}
return
false
;
}
bool
TypeAnalyzer
:
:
tryEmitFloatOperations
(
)
{
if
(
mir
-
>
compilingWasm
(
)
)
{
return
true
;
}
if
(
!
graphContainsFloat32
(
)
)
{
return
true
;
}
if
(
graph
.
hasTryBlock
(
)
)
{
return
true
;
}
if
(
!
markPhiConsumers
(
)
)
{
return
false
;
}
if
(
!
markPhiProducers
(
)
)
{
return
false
;
}
if
(
!
specializeValidFloatOps
(
)
)
{
return
false
;
}
return
true
;
}
bool
TypeAnalyzer
:
:
checkFloatCoherency
(
)
{
#
ifdef
DEBUG
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
+
+
block
)
{
if
(
mir
-
>
shouldCancel
(
"
Check
Float32
coherency
"
)
)
{
return
false
;
}
for
(
MDefinitionIterator
def
(
*
block
)
;
def
;
def
+
+
)
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
Float32
)
{
continue
;
}
for
(
MUseDefIterator
use
(
*
def
)
;
use
;
use
+
+
)
{
MDefinition
*
consumer
=
use
.
def
(
)
;
MOZ_ASSERT
(
consumer
-
>
isConsistentFloat32Use
(
use
.
use
(
)
)
)
;
}
}
}
#
endif
return
true
;
}
static
bool
HappensBefore
(
const
MDefinition
*
earlier
const
MDefinition
*
later
)
{
MOZ_ASSERT
(
earlier
-
>
block
(
)
=
=
later
-
>
block
(
)
)
;
for
(
auto
*
ins
:
*
earlier
-
>
block
(
)
)
{
if
(
ins
=
=
earlier
)
{
return
true
;
}
if
(
ins
=
=
later
)
{
return
false
;
}
}
MOZ_CRASH
(
"
earlier
and
later
are
instructions
in
the
block
"
)
;
}
bool
TypeAnalyzer
:
:
propagateUnbox
(
)
{
for
(
PostorderIterator
block
(
graph
.
poBegin
(
)
)
;
block
!
=
graph
.
poEnd
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
Propagate
Unbox
"
)
)
{
return
false
;
}
for
(
MInstructionIterator
iter
(
block
-
>
begin
(
)
)
;
iter
!
=
block
-
>
end
(
)
;
iter
+
+
)
{
if
(
!
iter
-
>
isUnbox
(
)
)
{
continue
;
}
auto
*
unbox
=
iter
-
>
toUnbox
(
)
;
auto
*
input
=
unbox
-
>
input
(
)
;
if
(
input
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
continue
;
}
if
(
IsFloatingPointType
(
unbox
-
>
type
(
)
)
)
{
continue
;
}
for
(
auto
uses
=
input
-
>
usesBegin
(
)
;
uses
!
=
input
-
>
usesEnd
(
)
;
)
{
auto
*
use
=
*
uses
+
+
;
if
(
!
use
-
>
consumer
(
)
-
>
isDefinition
(
)
)
{
continue
;
}
auto
*
def
=
use
-
>
consumer
(
)
-
>
toDefinition
(
)
;
if
(
def
-
>
isUnbox
(
)
)
{
continue
;
}
if
(
def
-
>
isPhi
(
)
)
{
continue
;
}
if
(
unbox
-
>
block
(
)
=
=
def
-
>
block
(
)
)
{
if
(
!
HappensBefore
(
unbox
def
)
)
{
continue
;
}
}
else
{
if
(
!
unbox
-
>
block
(
)
-
>
dominates
(
def
-
>
block
(
)
)
)
{
continue
;
}
}
use
-
>
replaceProducer
(
unbox
)
;
input
-
>
setImplicitlyUsedUnchecked
(
)
;
}
}
}
return
true
;
}
bool
TypeAnalyzer
:
:
analyze
(
)
{
if
(
!
tryEmitFloatOperations
(
)
)
{
return
false
;
}
if
(
!
specializePhis
(
)
)
{
return
false
;
}
if
(
!
propagateUnbox
(
)
)
{
return
false
;
}
if
(
!
insertConversions
(
)
)
{
return
false
;
}
if
(
!
checkFloatCoherency
(
)
)
{
return
false
;
}
return
true
;
}
bool
jit
:
:
ApplyTypeInformation
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
TypeAnalyzer
analyzer
(
mir
graph
)
;
if
(
!
analyzer
.
analyze
(
)
)
{
return
false
;
}
return
true
;
}
void
jit
:
:
RenumberBlocks
(
MIRGraph
&
graph
)
{
size_t
id
=
0
;
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
block
-
>
setId
(
id
+
+
)
;
}
}
bool
jit
:
:
AccountForCFGChanges
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
bool
updateAliasAnalysis
bool
underValueNumberer
)
{
size_t
id
=
0
;
for
(
ReversePostorderIterator
i
(
graph
.
rpoBegin
(
)
)
e
(
graph
.
rpoEnd
(
)
)
;
i
!
=
e
;
+
+
i
)
{
i
-
>
clearDominatorInfo
(
)
;
i
-
>
setId
(
id
+
+
)
;
}
if
(
!
BuildDominatorTree
(
mir
graph
)
)
{
return
false
;
}
if
(
updateAliasAnalysis
)
{
if
(
!
AliasAnalysis
(
mir
graph
)
.
analyze
(
)
)
{
return
false
;
}
}
AssertExtendedGraphCoherency
(
graph
underValueNumberer
)
;
return
true
;
}
bool
jit
:
:
RemoveUnmarkedBlocks
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
uint32_t
numMarkedBlocks
)
{
if
(
numMarkedBlocks
=
=
graph
.
numBlocks
(
)
)
{
graph
.
unmarkBlocks
(
)
;
}
else
{
for
(
PostorderIterator
it
(
graph
.
poBegin
(
)
)
;
it
!
=
graph
.
poEnd
(
)
;
)
{
MBasicBlock
*
block
=
*
it
+
+
;
if
(
block
-
>
isMarked
(
)
)
{
continue
;
}
if
(
!
FlagAllOperandsAsImplicitlyUsed
(
mir
block
)
)
{
return
false
;
}
}
for
(
ReversePostorderIterator
iter
(
graph
.
rpoBegin
(
)
)
;
iter
!
=
graph
.
rpoEnd
(
)
;
)
{
MBasicBlock
*
block
=
*
iter
+
+
;
if
(
block
-
>
isMarked
(
)
)
{
block
-
>
unmark
(
)
;
continue
;
}
if
(
block
-
>
isLoopHeader
(
)
)
{
block
-
>
clearLoopHeader
(
)
;
}
for
(
size_t
i
=
0
e
=
block
-
>
numSuccessors
(
)
;
i
!
=
e
;
+
+
i
)
{
block
-
>
getSuccessor
(
i
)
-
>
removePredecessor
(
block
)
;
}
graph
.
removeBlock
(
block
)
;
}
}
return
AccountForCFGChanges
(
mir
graph
false
)
;
}
bool
jit
:
:
BuildPhiReverseMapping
(
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
if
(
block
-
>
phisEmpty
(
)
)
{
continue
;
}
for
(
size_t
j
=
0
;
j
<
block
-
>
numPredecessors
(
)
;
j
+
+
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
j
)
;
#
ifdef
DEBUG
size_t
numSuccessorsWithPhis
=
0
;
for
(
size_t
k
=
0
;
k
<
pred
-
>
numSuccessors
(
)
;
k
+
+
)
{
MBasicBlock
*
successor
=
pred
-
>
getSuccessor
(
k
)
;
if
(
!
successor
-
>
phisEmpty
(
)
)
{
numSuccessorsWithPhis
+
+
;
}
}
MOZ_ASSERT
(
numSuccessorsWithPhis
<
=
1
)
;
#
endif
pred
-
>
setSuccessorWithPhis
(
*
block
j
)
;
}
}
return
true
;
}
#
ifdef
DEBUG
static
bool
CheckSuccessorImpliesPredecessor
(
MBasicBlock
*
A
MBasicBlock
*
B
)
{
for
(
size_t
i
=
0
;
i
<
B
-
>
numPredecessors
(
)
;
i
+
+
)
{
if
(
A
=
=
B
-
>
getPredecessor
(
i
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
CheckPredecessorImpliesSuccessor
(
MBasicBlock
*
A
MBasicBlock
*
B
)
{
for
(
size_t
i
=
0
;
i
<
B
-
>
numSuccessors
(
)
;
i
+
+
)
{
if
(
A
=
=
B
-
>
getSuccessor
(
i
)
)
{
return
true
;
}
}
return
false
;
}
static
void
CheckOperand
(
const
MNode
*
consumer
const
MUse
*
use
int32_t
*
usesBalance
)
{
MOZ_ASSERT
(
use
-
>
hasProducer
(
)
)
;
MDefinition
*
producer
=
use
-
>
producer
(
)
;
MOZ_ASSERT
(
!
producer
-
>
isDiscarded
(
)
)
;
MOZ_ASSERT
(
producer
-
>
block
(
)
!
=
nullptr
)
;
MOZ_ASSERT
(
use
-
>
consumer
(
)
=
=
consumer
)
;
#
ifdef
_DEBUG_CHECK_OPERANDS_USES_BALANCE
Fprinter
print
(
stderr
)
;
print
.
printf
(
"
=
=
Check
Operand
\
n
"
)
;
use
-
>
producer
(
)
-
>
dump
(
print
)
;
print
.
printf
(
"
index
:
%
zu
\
n
"
use
-
>
consumer
(
)
-
>
indexOf
(
use
)
)
;
use
-
>
consumer
(
)
-
>
dump
(
print
)
;
print
.
printf
(
"
=
=
End
\
n
"
)
;
#
endif
-
-
*
usesBalance
;
}
static
void
CheckUse
(
const
MDefinition
*
producer
const
MUse
*
use
int32_t
*
usesBalance
)
{
MOZ_ASSERT
(
!
use
-
>
consumer
(
)
-
>
block
(
)
-
>
isDead
(
)
)
;
MOZ_ASSERT_IF
(
use
-
>
consumer
(
)
-
>
isDefinition
(
)
!
use
-
>
consumer
(
)
-
>
toDefinition
(
)
-
>
isDiscarded
(
)
)
;
MOZ_ASSERT
(
use
-
>
consumer
(
)
-
>
block
(
)
!
=
nullptr
)
;
MOZ_ASSERT
(
use
-
>
consumer
(
)
-
>
getOperand
(
use
-
>
index
(
)
)
=
=
producer
)
;
#
ifdef
_DEBUG_CHECK_OPERANDS_USES_BALANCE
Fprinter
print
(
stderr
)
;
print
.
printf
(
"
=
=
Check
Use
\
n
"
)
;
use
-
>
producer
(
)
-
>
dump
(
print
)
;
print
.
printf
(
"
index
:
%
zu
\
n
"
use
-
>
consumer
(
)
-
>
indexOf
(
use
)
)
;
use
-
>
consumer
(
)
-
>
dump
(
print
)
;
print
.
printf
(
"
=
=
End
\
n
"
)
;
#
endif
+
+
*
usesBalance
;
}
static
void
AssertOperandsBeforeSafeInsertTop
(
MResumePoint
*
resume
)
{
MBasicBlock
*
block
=
resume
-
>
block
(
)
;
if
(
block
=
=
block
-
>
graph
(
)
.
osrBlock
(
)
)
{
return
;
}
MInstruction
*
stop
=
block
-
>
safeInsertTop
(
)
;
for
(
size_t
i
=
0
e
=
resume
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
def
=
resume
-
>
getOperand
(
i
)
;
if
(
def
-
>
block
(
)
!
=
block
)
{
continue
;
}
if
(
def
-
>
isPhi
(
)
)
{
continue
;
}
for
(
MInstructionIterator
ins
=
block
-
>
begin
(
)
;
true
;
ins
+
+
)
{
if
(
*
ins
=
=
def
)
{
break
;
}
MOZ_ASSERT
(
*
ins
!
=
stop
"
Resume
point
operand
located
after
the
safeInsertTop
location
"
)
;
}
}
}
#
endif
void
jit
:
:
AssertBasicGraphCoherency
(
MIRGraph
&
graph
bool
force
)
{
#
ifdef
DEBUG
if
(
!
JitOptions
.
fullDebugChecks
&
&
!
force
)
{
return
;
}
MOZ_ASSERT
(
graph
.
entryBlock
(
)
-
>
numPredecessors
(
)
=
=
0
)
;
MOZ_ASSERT
(
graph
.
entryBlock
(
)
-
>
phisEmpty
(
)
)
;
MOZ_ASSERT
(
!
graph
.
entryBlock
(
)
-
>
unreachable
(
)
)
;
if
(
MBasicBlock
*
osrBlock
=
graph
.
osrBlock
(
)
)
{
MOZ_ASSERT
(
osrBlock
-
>
numPredecessors
(
)
=
=
0
)
;
MOZ_ASSERT
(
osrBlock
-
>
phisEmpty
(
)
)
;
MOZ_ASSERT
(
osrBlock
!
=
graph
.
entryBlock
(
)
)
;
MOZ_ASSERT
(
!
osrBlock
-
>
unreachable
(
)
)
;
}
if
(
MResumePoint
*
resumePoint
=
graph
.
entryResumePoint
(
)
)
{
MOZ_ASSERT
(
resumePoint
-
>
block
(
)
=
=
graph
.
entryBlock
(
)
)
;
}
uint32_t
count
=
0
;
int32_t
usesBalance
=
0
;
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
count
+
+
;
MOZ_ASSERT
(
&
block
-
>
graph
(
)
=
=
&
graph
)
;
MOZ_ASSERT
(
!
block
-
>
isDead
(
)
)
;
MOZ_ASSERT_IF
(
block
-
>
outerResumePoint
(
)
!
=
nullptr
block
-
>
entryResumePoint
(
)
!
=
nullptr
)
;
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
CheckSuccessorImpliesPredecessor
(
*
block
block
-
>
getSuccessor
(
i
)
)
)
;
}
for
(
size_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
CheckPredecessorImpliesSuccessor
(
*
block
block
-
>
getPredecessor
(
i
)
)
)
;
}
if
(
MResumePoint
*
resume
=
block
-
>
entryResumePoint
(
)
)
{
MOZ_ASSERT
(
!
resume
-
>
instruction
(
)
)
;
MOZ_ASSERT
(
resume
-
>
block
(
)
=
=
*
block
)
;
AssertOperandsBeforeSafeInsertTop
(
resume
)
;
}
if
(
MResumePoint
*
resume
=
block
-
>
outerResumePoint
(
)
)
{
MOZ_ASSERT
(
!
resume
-
>
instruction
(
)
)
;
MOZ_ASSERT
(
resume
-
>
block
(
)
=
=
*
block
)
;
}
for
(
MResumePointIterator
iter
(
block
-
>
resumePointsBegin
(
)
)
;
iter
!
=
block
-
>
resumePointsEnd
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
instruction
(
)
iter
-
>
instruction
(
)
-
>
block
(
)
=
=
*
block
)
;
for
(
uint32_t
i
=
0
e
=
iter
-
>
numOperands
(
)
;
i
<
e
;
i
+
+
)
{
CheckOperand
(
*
iter
iter
-
>
getUseFor
(
i
)
&
usesBalance
)
;
}
}
for
(
MPhiIterator
phi
(
block
-
>
phisBegin
(
)
)
;
phi
!
=
block
-
>
phisEnd
(
)
;
phi
+
+
)
{
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
block
-
>
numPredecessors
(
)
)
;
MOZ_ASSERT
(
!
phi
-
>
isRecoveredOnBailout
(
)
)
;
MOZ_ASSERT
(
phi
-
>
type
(
)
!
=
MIRType
:
:
None
)
;
MOZ_ASSERT
(
phi
-
>
dependency
(
)
=
=
nullptr
)
;
}
for
(
MDefinitionIterator
iter
(
*
block
)
;
iter
;
iter
+
+
)
{
MOZ_ASSERT
(
iter
-
>
block
(
)
=
=
*
block
)
;
MOZ_ASSERT_IF
(
iter
-
>
hasUses
(
)
iter
-
>
type
(
)
!
=
MIRType
:
:
None
)
;
MOZ_ASSERT
(
!
iter
-
>
isDiscarded
(
)
)
;
MOZ_ASSERT_IF
(
iter
-
>
isStart
(
)
*
block
=
=
graph
.
entryBlock
(
)
|
|
*
block
=
=
graph
.
osrBlock
(
)
)
;
MOZ_ASSERT_IF
(
iter
-
>
isParameter
(
)
*
block
=
=
graph
.
entryBlock
(
)
|
|
*
block
=
=
graph
.
osrBlock
(
)
)
;
MOZ_ASSERT_IF
(
iter
-
>
isOsrEntry
(
)
*
block
=
=
graph
.
osrBlock
(
)
)
;
MOZ_ASSERT_IF
(
iter
-
>
isOsrValue
(
)
*
block
=
=
graph
.
osrBlock
(
)
)
;
for
(
uint32_t
i
=
0
end
=
iter
-
>
numOperands
(
)
;
i
<
end
;
i
+
+
)
{
CheckOperand
(
*
iter
iter
-
>
getUseFor
(
i
)
&
usesBalance
)
;
}
for
(
MUseIterator
use
(
iter
-
>
usesBegin
(
)
)
;
use
!
=
iter
-
>
usesEnd
(
)
;
use
+
+
)
{
CheckUse
(
*
iter
*
use
&
usesBalance
)
;
}
if
(
iter
-
>
isInstruction
(
)
)
{
if
(
MResumePoint
*
resume
=
iter
-
>
toInstruction
(
)
-
>
resumePoint
(
)
)
{
MOZ_ASSERT
(
resume
-
>
instruction
(
)
=
=
*
iter
)
;
MOZ_ASSERT
(
resume
-
>
block
(
)
=
=
*
block
)
;
MOZ_ASSERT
(
resume
-
>
block
(
)
-
>
entryResumePoint
(
)
!
=
nullptr
)
;
}
}
if
(
iter
-
>
isRecoveredOnBailout
(
)
)
{
MOZ_ASSERT
(
!
iter
-
>
hasLiveDefUses
(
)
)
;
}
}
MControlInstruction
*
control
=
block
-
>
lastIns
(
)
;
MOZ_ASSERT
(
control
-
>
block
(
)
=
=
*
block
)
;
MOZ_ASSERT
(
!
control
-
>
hasUses
(
)
)
;
MOZ_ASSERT
(
control
-
>
type
(
)
=
=
MIRType
:
:
None
)
;
MOZ_ASSERT
(
!
control
-
>
isDiscarded
(
)
)
;
MOZ_ASSERT
(
!
control
-
>
isRecoveredOnBailout
(
)
)
;
MOZ_ASSERT
(
control
-
>
resumePoint
(
)
=
=
nullptr
)
;
for
(
uint32_t
i
=
0
end
=
control
-
>
numOperands
(
)
;
i
<
end
;
i
+
+
)
{
CheckOperand
(
control
control
-
>
getUseFor
(
i
)
&
usesBalance
)
;
}
for
(
size_t
i
=
0
;
i
<
control
-
>
numSuccessors
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
control
-
>
getSuccessor
(
i
)
)
;
}
}
MOZ_ASSERT
(
usesBalance
<
=
0
"
More
use
checks
than
operand
checks
"
)
;
MOZ_ASSERT
(
usesBalance
>
=
0
"
More
operand
checks
than
use
checks
"
)
;
MOZ_ASSERT
(
graph
.
numBlocks
(
)
=
=
count
)
;
#
endif
}
#
ifdef
DEBUG
static
void
AssertReversePostorder
(
MIRGraph
&
graph
)
{
for
(
ReversePostorderIterator
iter
(
graph
.
rpoBegin
(
)
)
;
iter
!
=
graph
.
rpoEnd
(
)
;
+
+
iter
)
{
MBasicBlock
*
block
=
*
iter
;
MOZ_ASSERT
(
!
block
-
>
isMarked
(
)
)
;
for
(
size_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
i
)
;
if
(
!
pred
-
>
isMarked
(
)
)
{
MOZ_ASSERT
(
pred
-
>
isLoopBackedge
(
)
)
;
MOZ_ASSERT
(
block
-
>
backedge
(
)
=
=
pred
)
;
}
}
block
-
>
mark
(
)
;
}
graph
.
unmarkBlocks
(
)
;
}
#
endif
#
ifdef
DEBUG
static
void
AssertDominatorTree
(
MIRGraph
&
graph
)
{
MOZ_ASSERT
(
graph
.
entryBlock
(
)
-
>
immediateDominator
(
)
=
=
graph
.
entryBlock
(
)
)
;
if
(
MBasicBlock
*
osrBlock
=
graph
.
osrBlock
(
)
)
{
MOZ_ASSERT
(
osrBlock
-
>
immediateDominator
(
)
=
=
osrBlock
)
;
}
else
{
MOZ_ASSERT
(
graph
.
entryBlock
(
)
-
>
numDominated
(
)
=
=
graph
.
numBlocks
(
)
)
;
}
size_t
i
=
graph
.
numBlocks
(
)
;
size_t
totalNumDominated
=
0
;
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
MOZ_ASSERT
(
block
-
>
dominates
(
*
block
)
)
;
MBasicBlock
*
idom
=
block
-
>
immediateDominator
(
)
;
MOZ_ASSERT
(
idom
-
>
dominates
(
*
block
)
)
;
MOZ_ASSERT
(
idom
=
=
*
block
|
|
idom
-
>
id
(
)
<
block
-
>
id
(
)
)
;
if
(
idom
=
=
*
block
)
{
totalNumDominated
+
=
block
-
>
numDominated
(
)
;
}
else
{
bool
foundInParent
=
false
;
for
(
size_t
j
=
0
;
j
<
idom
-
>
numImmediatelyDominatedBlocks
(
)
;
j
+
+
)
{
if
(
idom
-
>
getImmediatelyDominatedBlock
(
j
)
=
=
*
block
)
{
foundInParent
=
true
;
break
;
}
}
MOZ_ASSERT
(
foundInParent
)
;
}
size_t
numDominated
=
1
;
for
(
size_t
j
=
0
;
j
<
block
-
>
numImmediatelyDominatedBlocks
(
)
;
j
+
+
)
{
MBasicBlock
*
dom
=
block
-
>
getImmediatelyDominatedBlock
(
j
)
;
MOZ_ASSERT
(
block
-
>
dominates
(
dom
)
)
;
MOZ_ASSERT
(
dom
-
>
id
(
)
>
block
-
>
id
(
)
)
;
MOZ_ASSERT
(
dom
-
>
immediateDominator
(
)
=
=
*
block
)
;
numDominated
+
=
dom
-
>
numDominated
(
)
;
}
MOZ_ASSERT
(
block
-
>
numDominated
(
)
=
=
numDominated
)
;
MOZ_ASSERT
(
block
-
>
numDominated
(
)
<
=
i
)
;
MOZ_ASSERT
(
block
-
>
numSuccessors
(
)
!
=
0
|
|
block
-
>
numDominated
(
)
=
=
1
)
;
i
-
-
;
}
MOZ_ASSERT
(
i
=
=
0
)
;
MOZ_ASSERT
(
totalNumDominated
=
=
graph
.
numBlocks
(
)
)
;
}
#
endif
void
jit
:
:
AssertGraphCoherency
(
MIRGraph
&
graph
bool
force
)
{
#
ifdef
DEBUG
if
(
!
JitOptions
.
checkGraphConsistency
)
{
return
;
}
if
(
!
JitOptions
.
fullDebugChecks
&
&
!
force
)
{
return
;
}
AssertBasicGraphCoherency
(
graph
force
)
;
AssertReversePostorder
(
graph
)
;
#
endif
}
#
ifdef
DEBUG
static
bool
IsResumableMIRType
(
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Undefined
:
case
MIRType
:
:
Null
:
case
MIRType
:
:
Boolean
:
case
MIRType
:
:
Int32
:
case
MIRType
:
:
Double
:
case
MIRType
:
:
Float32
:
case
MIRType
:
:
String
:
case
MIRType
:
:
Symbol
:
case
MIRType
:
:
BigInt
:
case
MIRType
:
:
Object
:
case
MIRType
:
:
Shape
:
case
MIRType
:
:
MagicOptimizedOut
:
case
MIRType
:
:
MagicUninitializedLexical
:
case
MIRType
:
:
MagicIsConstructing
:
case
MIRType
:
:
Value
:
case
MIRType
:
:
Int64
:
case
MIRType
:
:
IntPtr
:
return
true
;
case
MIRType
:
:
Simd128
:
case
MIRType
:
:
MagicHole
:
case
MIRType
:
:
None
:
case
MIRType
:
:
Slots
:
case
MIRType
:
:
Elements
:
case
MIRType
:
:
Pointer
:
case
MIRType
:
:
WasmAnyRef
:
case
MIRType
:
:
WasmArrayData
:
case
MIRType
:
:
StackResults
:
return
false
;
}
MOZ_CRASH
(
"
Unknown
MIRType
.
"
)
;
}
static
void
AssertResumableOperands
(
MNode
*
node
)
{
for
(
size_t
i
=
0
e
=
node
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
op
=
node
-
>
getOperand
(
i
)
;
if
(
op
-
>
isRecoveredOnBailout
(
)
)
{
continue
;
}
MOZ_ASSERT
(
IsResumableMIRType
(
op
-
>
type
(
)
)
"
Resume
point
cannot
encode
its
operands
"
)
;
}
}
static
void
AssertIfResumableInstruction
(
MDefinition
*
def
)
{
if
(
!
def
-
>
isRecoveredOnBailout
(
)
)
{
return
;
}
AssertResumableOperands
(
def
)
;
}
static
void
AssertResumePointDominatedByOperands
(
MResumePoint
*
resume
)
{
for
(
size_t
i
=
0
e
=
resume
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
op
=
resume
-
>
getOperand
(
i
)
;
MOZ_ASSERT
(
op
-
>
block
(
)
-
>
dominates
(
resume
-
>
block
(
)
)
"
Resume
point
is
not
dominated
by
its
operands
"
)
;
}
}
#
endif
void
jit
:
:
AssertExtendedGraphCoherency
(
MIRGraph
&
graph
bool
underValueNumberer
bool
force
)
{
#
ifdef
DEBUG
if
(
!
JitOptions
.
checkGraphConsistency
)
{
return
;
}
if
(
!
JitOptions
.
fullDebugChecks
&
&
!
force
)
{
return
;
}
AssertGraphCoherency
(
graph
force
)
;
AssertDominatorTree
(
graph
)
;
DebugOnly
<
uint32_t
>
idx
=
0
;
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
MOZ_ASSERT
(
block
-
>
id
(
)
=
=
idx
)
;
+
+
idx
;
if
(
block
-
>
numSuccessors
(
)
>
1
)
{
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
block
-
>
getSuccessor
(
i
)
-
>
numPredecessors
(
)
=
=
1
)
;
}
}
if
(
block
-
>
isLoopHeader
(
)
)
{
if
(
underValueNumberer
&
&
block
-
>
numPredecessors
(
)
=
=
3
)
{
MOZ_ASSERT
(
block
-
>
getPredecessor
(
1
)
-
>
numPredecessors
(
)
=
=
0
)
;
MOZ_ASSERT
(
graph
.
osrBlock
(
)
"
Fixup
blocks
should
only
exists
if
we
have
an
osr
block
.
"
)
;
}
else
{
MOZ_ASSERT
(
block
-
>
numPredecessors
(
)
=
=
2
)
;
}
MBasicBlock
*
backedge
=
block
-
>
backedge
(
)
;
MOZ_ASSERT
(
backedge
-
>
id
(
)
>
=
block
-
>
id
(
)
)
;
MOZ_ASSERT
(
backedge
-
>
numSuccessors
(
)
=
=
1
)
;
MOZ_ASSERT
(
backedge
-
>
getSuccessor
(
0
)
=
=
*
block
)
;
}
if
(
!
block
-
>
phisEmpty
(
)
)
{
for
(
size_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
i
)
;
MOZ_ASSERT
(
pred
-
>
successorWithPhis
(
)
=
=
*
block
)
;
MOZ_ASSERT
(
pred
-
>
positionInPhiSuccessor
(
)
=
=
i
)
;
}
}
uint32_t
successorWithPhis
=
0
;
for
(
size_t
i
=
0
;
i
<
block
-
>
numSuccessors
(
)
;
i
+
+
)
{
if
(
!
block
-
>
getSuccessor
(
i
)
-
>
phisEmpty
(
)
)
{
successorWithPhis
+
+
;
}
}
MOZ_ASSERT
(
successorWithPhis
<
=
1
)
;
MOZ_ASSERT
(
(
successorWithPhis
!
=
0
)
=
=
(
block
-
>
successorWithPhis
(
)
!
=
nullptr
)
)
;
for
(
MPhiIterator
iter
(
block
-
>
phisBegin
(
)
)
end
(
block
-
>
phisEnd
(
)
)
;
iter
!
=
end
;
+
+
iter
)
{
MPhi
*
phi
=
*
iter
;
for
(
size_t
i
=
0
e
=
phi
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MOZ_ASSERT
(
phi
-
>
getOperand
(
i
)
-
>
block
(
)
-
>
dominates
(
block
-
>
getPredecessor
(
i
)
)
"
Phi
input
is
not
dominated
by
its
operand
"
)
;
}
}
for
(
MInstructionIterator
iter
(
block
-
>
begin
(
)
)
end
(
block
-
>
end
(
)
)
;
iter
!
=
end
;
+
+
iter
)
{
MInstruction
*
ins
=
*
iter
;
for
(
size_t
i
=
0
e
=
ins
-
>
numOperands
(
)
;
i
<
e
;
+
+
i
)
{
MDefinition
*
op
=
ins
-
>
getOperand
(
i
)
;
MBasicBlock
*
opBlock
=
op
-
>
block
(
)
;
MOZ_ASSERT
(
opBlock
-
>
dominates
(
*
block
)
"
Instruction
is
not
dominated
by
its
operands
"
)
;
if
(
opBlock
=
=
*
block
&
&
!
op
-
>
isPhi
(
)
)
{
MInstructionIterator
opIter
=
block
-
>
begin
(
op
-
>
toInstruction
(
)
)
;
do
{
+
+
opIter
;
MOZ_ASSERT
(
opIter
!
=
block
-
>
end
(
)
"
Operand
in
same
block
as
instruction
does
not
precede
"
)
;
}
while
(
*
opIter
!
=
ins
)
;
}
}
AssertIfResumableInstruction
(
ins
)
;
if
(
MResumePoint
*
resume
=
ins
-
>
resumePoint
(
)
)
{
AssertResumePointDominatedByOperands
(
resume
)
;
AssertResumableOperands
(
resume
)
;
}
}
if
(
MResumePoint
*
resume
=
block
-
>
entryResumePoint
(
)
)
{
AssertResumePointDominatedByOperands
(
resume
)
;
AssertResumableOperands
(
resume
)
;
}
if
(
MResumePoint
*
resume
=
block
-
>
outerResumePoint
(
)
)
{
AssertResumePointDominatedByOperands
(
resume
)
;
AssertResumableOperands
(
resume
)
;
}
for
(
MDefinitionIterator
def
(
*
block
)
;
def
;
def
+
+
)
{
MOZ_ASSERT_IF
(
def
-
>
wasmRefType
(
)
.
isSome
(
)
def
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
}
}
#
endif
}
struct
BoundsCheckInfo
{
MBoundsCheck
*
check
;
uint32_t
validEnd
;
}
;
using
BoundsCheckMap
=
HashMap
<
uint32_t
BoundsCheckInfo
DefaultHasher
<
uint32_t
>
JitAllocPolicy
>
;
static
HashNumber
BoundsCheckHashIgnoreOffset
(
MBoundsCheck
*
check
)
{
SimpleLinearSum
indexSum
=
ExtractLinearSum
(
check
-
>
index
(
)
)
;
uintptr_t
index
=
indexSum
.
term
?
uintptr_t
(
indexSum
.
term
)
:
0
;
uintptr_t
length
=
uintptr_t
(
check
-
>
length
(
)
)
;
return
index
^
length
;
}
static
MBoundsCheck
*
FindDominatingBoundsCheck
(
BoundsCheckMap
&
checks
MBoundsCheck
*
check
size_t
index
)
{
HashNumber
hash
=
BoundsCheckHashIgnoreOffset
(
check
)
;
BoundsCheckMap
:
:
Ptr
p
=
checks
.
lookup
(
hash
)
;
if
(
!
p
|
|
index
>
=
p
-
>
value
(
)
.
validEnd
)
{
BoundsCheckInfo
info
;
info
.
check
=
check
;
info
.
validEnd
=
index
+
check
-
>
block
(
)
-
>
numDominated
(
)
;
if
(
!
checks
.
put
(
hash
info
)
)
return
nullptr
;
return
check
;
}
return
p
-
>
value
(
)
.
check
;
}
static
MathSpace
ExtractMathSpace
(
MDefinition
*
ins
)
{
MOZ_ASSERT
(
ins
-
>
isAdd
(
)
|
|
ins
-
>
isSub
(
)
)
;
MBinaryArithInstruction
*
arith
=
nullptr
;
if
(
ins
-
>
isAdd
(
)
)
{
arith
=
ins
-
>
toAdd
(
)
;
}
else
{
arith
=
ins
-
>
toSub
(
)
;
}
switch
(
arith
-
>
truncateKind
(
)
)
{
case
TruncateKind
:
:
NoTruncate
:
case
TruncateKind
:
:
TruncateAfterBailouts
:
return
MathSpace
:
:
Infinite
;
case
TruncateKind
:
:
IndirectTruncate
:
case
TruncateKind
:
:
Truncate
:
return
MathSpace
:
:
Modulo
;
}
MOZ_CRASH
(
"
Unknown
TruncateKind
"
)
;
}
static
bool
MonotoneAdd
(
int32_t
lhs
int32_t
rhs
)
{
return
(
lhs
>
=
0
&
&
rhs
>
=
0
)
|
|
(
lhs
<
=
0
&
&
rhs
<
=
0
)
;
}
static
bool
MonotoneSub
(
int32_t
lhs
int32_t
rhs
)
{
return
(
lhs
>
=
0
&
&
rhs
<
=
0
)
|
|
(
lhs
<
=
0
&
&
rhs
>
=
0
)
;
}
SimpleLinearSum
jit
:
:
ExtractLinearSum
(
MDefinition
*
ins
MathSpace
space
int32_t
recursionDepth
)
{
const
int32_t
SAFE_RECURSION_LIMIT
=
100
;
if
(
recursionDepth
>
SAFE_RECURSION_LIMIT
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
if
(
ins
-
>
isInt32ToIntPtr
(
)
)
{
ins
=
ins
-
>
toInt32ToIntPtr
(
)
-
>
input
(
)
;
}
if
(
ins
-
>
isBeta
(
)
)
{
ins
=
ins
-
>
getOperand
(
0
)
;
}
MOZ_ASSERT
(
!
ins
-
>
isInt32ToIntPtr
(
)
)
;
if
(
ins
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
if
(
ins
-
>
isConstant
(
)
)
{
return
SimpleLinearSum
(
nullptr
ins
-
>
toConstant
(
)
-
>
toInt32
(
)
)
;
}
if
(
!
ins
-
>
isAdd
(
)
&
&
!
ins
-
>
isSub
(
)
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
MathSpace
insSpace
=
ExtractMathSpace
(
ins
)
;
if
(
space
=
=
MathSpace
:
:
Unknown
)
{
space
=
insSpace
;
}
else
if
(
space
!
=
insSpace
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
MOZ_ASSERT
(
space
=
=
MathSpace
:
:
Modulo
|
|
space
=
=
MathSpace
:
:
Infinite
)
;
if
(
space
=
=
MathSpace
:
:
Modulo
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
MDefinition
*
lhs
=
ins
-
>
getOperand
(
0
)
;
MDefinition
*
rhs
=
ins
-
>
getOperand
(
1
)
;
if
(
lhs
-
>
type
(
)
!
=
MIRType
:
:
Int32
|
|
rhs
-
>
type
(
)
!
=
MIRType
:
:
Int32
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
SimpleLinearSum
lsum
=
ExtractLinearSum
(
lhs
space
recursionDepth
+
1
)
;
SimpleLinearSum
rsum
=
ExtractLinearSum
(
rhs
space
recursionDepth
+
1
)
;
if
(
lsum
.
term
&
&
rsum
.
term
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
if
(
ins
-
>
isAdd
(
)
)
{
int32_t
constant
;
if
(
space
=
=
MathSpace
:
:
Modulo
)
{
constant
=
uint32_t
(
lsum
.
constant
)
+
uint32_t
(
rsum
.
constant
)
;
}
else
if
(
!
SafeAdd
(
lsum
.
constant
rsum
.
constant
&
constant
)
|
|
!
MonotoneAdd
(
lsum
.
constant
rsum
.
constant
)
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
return
SimpleLinearSum
(
lsum
.
term
?
lsum
.
term
:
rsum
.
term
constant
)
;
}
MOZ_ASSERT
(
ins
-
>
isSub
(
)
)
;
if
(
lsum
.
term
)
{
int32_t
constant
;
if
(
space
=
=
MathSpace
:
:
Modulo
)
{
constant
=
uint32_t
(
lsum
.
constant
)
-
uint32_t
(
rsum
.
constant
)
;
}
else
if
(
!
SafeSub
(
lsum
.
constant
rsum
.
constant
&
constant
)
|
|
!
MonotoneSub
(
lsum
.
constant
rsum
.
constant
)
)
{
return
SimpleLinearSum
(
ins
0
)
;
}
return
SimpleLinearSum
(
lsum
.
term
constant
)
;
}
return
SimpleLinearSum
(
ins
0
)
;
}
bool
jit
:
:
ExtractLinearInequality
(
const
MTest
*
test
BranchDirection
direction
SimpleLinearSum
*
plhs
MDefinition
*
*
prhs
bool
*
plessEqual
)
{
if
(
!
test
-
>
getOperand
(
0
)
-
>
isCompare
(
)
)
{
return
false
;
}
MCompare
*
compare
=
test
-
>
getOperand
(
0
)
-
>
toCompare
(
)
;
MDefinition
*
lhs
=
compare
-
>
getOperand
(
0
)
;
MDefinition
*
rhs
=
compare
-
>
getOperand
(
1
)
;
if
(
!
compare
-
>
isInt32Comparison
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
lhs
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
MOZ_ASSERT
(
rhs
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
JSOp
jsop
=
compare
-
>
jsop
(
)
;
if
(
direction
=
=
FALSE_BRANCH
)
{
jsop
=
NegateCompareOp
(
jsop
)
;
}
SimpleLinearSum
lsum
=
ExtractLinearSum
(
lhs
)
;
SimpleLinearSum
rsum
=
ExtractLinearSum
(
rhs
)
;
if
(
!
SafeSub
(
lsum
.
constant
rsum
.
constant
&
lsum
.
constant
)
)
{
return
false
;
}
switch
(
jsop
)
{
case
JSOp
:
:
Le
:
*
plessEqual
=
true
;
break
;
case
JSOp
:
:
Lt
:
if
(
!
SafeAdd
(
lsum
.
constant
1
&
lsum
.
constant
)
)
{
return
false
;
}
*
plessEqual
=
true
;
break
;
case
JSOp
:
:
Ge
:
*
plessEqual
=
false
;
break
;
case
JSOp
:
:
Gt
:
if
(
!
SafeSub
(
lsum
.
constant
1
&
lsum
.
constant
)
)
{
return
false
;
}
*
plessEqual
=
false
;
break
;
default
:
return
false
;
}
*
plhs
=
lsum
;
*
prhs
=
rsum
.
term
;
return
true
;
}
static
bool
TryEliminateBoundsCheck
(
BoundsCheckMap
&
checks
size_t
blockIndex
MBoundsCheck
*
dominated
bool
*
eliminated
)
{
MOZ_ASSERT
(
!
*
eliminated
)
;
dominated
-
>
replaceAllUsesWith
(
dominated
-
>
index
(
)
)
;
if
(
!
dominated
-
>
isMovable
(
)
)
{
return
true
;
}
if
(
!
dominated
-
>
fallible
(
)
)
{
return
true
;
}
MBoundsCheck
*
dominating
=
FindDominatingBoundsCheck
(
checks
dominated
blockIndex
)
;
if
(
!
dominating
)
{
return
false
;
}
if
(
dominating
=
=
dominated
)
{
return
true
;
}
if
(
dominating
-
>
length
(
)
!
=
dominated
-
>
length
(
)
)
{
return
true
;
}
SimpleLinearSum
sumA
=
ExtractLinearSum
(
dominating
-
>
index
(
)
)
;
SimpleLinearSum
sumB
=
ExtractLinearSum
(
dominated
-
>
index
(
)
)
;
if
(
sumA
.
term
!
=
sumB
.
term
)
{
return
true
;
}
*
eliminated
=
true
;
int32_t
minimumA
maximumA
minimumB
maximumB
;
if
(
!
SafeAdd
(
sumA
.
constant
dominating
-
>
minimum
(
)
&
minimumA
)
|
|
!
SafeAdd
(
sumA
.
constant
dominating
-
>
maximum
(
)
&
maximumA
)
|
|
!
SafeAdd
(
sumB
.
constant
dominated
-
>
minimum
(
)
&
minimumB
)
|
|
!
SafeAdd
(
sumB
.
constant
dominated
-
>
maximum
(
)
&
maximumB
)
)
{
return
false
;
}
int32_t
newMinimum
newMaximum
;
if
(
!
SafeSub
(
std
:
:
min
(
minimumA
minimumB
)
sumA
.
constant
&
newMinimum
)
|
|
!
SafeSub
(
std
:
:
max
(
maximumA
maximumB
)
sumA
.
constant
&
newMaximum
)
)
{
return
false
;
}
dominating
-
>
setMinimum
(
newMinimum
)
;
dominating
-
>
setMaximum
(
newMaximum
)
;
dominating
-
>
setBailoutKind
(
BailoutKind
:
:
HoistBoundsCheck
)
;
return
true
;
}
bool
jit
:
:
EliminateRedundantChecks
(
MIRGraph
&
graph
)
{
BoundsCheckMap
checks
(
graph
.
alloc
(
)
)
;
Vector
<
MBasicBlock
*
1
JitAllocPolicy
>
worklist
(
graph
.
alloc
(
)
)
;
size_t
index
=
0
;
for
(
MBasicBlockIterator
i
(
graph
.
begin
(
)
)
;
i
!
=
graph
.
end
(
)
;
i
+
+
)
{
MBasicBlock
*
block
=
*
i
;
if
(
block
-
>
immediateDominator
(
)
=
=
block
)
{
if
(
!
worklist
.
append
(
block
)
)
{
return
false
;
}
}
}
while
(
!
worklist
.
empty
(
)
)
{
MBasicBlock
*
block
=
worklist
.
popCopy
(
)
;
if
(
!
worklist
.
append
(
block
-
>
immediatelyDominatedBlocksBegin
(
)
block
-
>
immediatelyDominatedBlocksEnd
(
)
)
)
{
return
false
;
}
for
(
MDefinitionIterator
iter
(
block
)
;
iter
;
)
{
MDefinition
*
def
=
*
iter
+
+
;
if
(
!
def
-
>
isBoundsCheck
(
)
)
{
continue
;
}
auto
*
boundsCheck
=
def
-
>
toBoundsCheck
(
)
;
bool
eliminated
=
false
;
if
(
!
TryEliminateBoundsCheck
(
checks
index
boundsCheck
&
eliminated
)
)
{
return
false
;
}
if
(
eliminated
)
{
block
-
>
discard
(
boundsCheck
)
;
}
}
index
+
+
;
}
MOZ_ASSERT
(
index
=
=
graph
.
numBlocks
(
)
)
;
return
true
;
}
static
bool
ShapeGuardIsRedundant
(
MGuardShape
*
guard
const
MDefinition
*
storeObject
const
Shape
*
storeShape
)
{
const
MDefinition
*
guardObject
=
guard
-
>
object
(
)
-
>
skipObjectGuards
(
)
;
if
(
guardObject
!
=
storeObject
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
different
objects
(
%
d
vs
%
d
)
"
guardObject
-
>
id
(
)
storeObject
-
>
id
(
)
)
;
return
false
;
}
const
Shape
*
guardShape
=
guard
-
>
shape
(
)
;
if
(
guardShape
!
=
storeShape
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
different
shapes
"
)
;
return
false
;
}
return
true
;
}
bool
jit
:
:
EliminateRedundantShapeGuards
(
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
Begin
"
)
;
for
(
ReversePostorderIterator
block
=
graph
.
rpoBegin
(
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
)
{
MInstruction
*
ins
=
*
insIter
;
insIter
+
+
;
if
(
!
ins
-
>
isGuardShape
(
)
)
{
continue
;
}
MGuardShape
*
guard
=
ins
-
>
toGuardShape
(
)
;
MDefinition
*
lastStore
=
guard
-
>
dependency
(
)
;
JitSpew
(
JitSpew_RedundantShapeGuards
"
Visit
shape
guard
%
d
"
guard
-
>
id
(
)
)
;
JitSpewIndent
spewIndent
(
JitSpew_RedundantShapeGuards
)
;
if
(
lastStore
-
>
isDiscarded
(
)
|
|
lastStore
-
>
block
(
)
-
>
isDead
(
)
|
|
!
lastStore
-
>
block
(
)
-
>
dominates
(
guard
-
>
block
(
)
)
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
ins
%
d
does
not
dominate
block
%
d
"
lastStore
-
>
id
(
)
guard
-
>
block
(
)
-
>
id
(
)
)
;
continue
;
}
if
(
lastStore
-
>
isAddAndStoreSlot
(
)
)
{
auto
*
add
=
lastStore
-
>
toAddAndStoreSlot
(
)
;
auto
*
addObject
=
add
-
>
object
(
)
-
>
skipObjectGuards
(
)
;
if
(
!
ShapeGuardIsRedundant
(
guard
addObject
add
-
>
shape
(
)
)
)
{
continue
;
}
}
else
if
(
lastStore
-
>
isAllocateAndStoreSlot
(
)
)
{
auto
*
allocate
=
lastStore
-
>
toAllocateAndStoreSlot
(
)
;
auto
*
allocateObject
=
allocate
-
>
object
(
)
-
>
skipObjectGuards
(
)
;
if
(
!
ShapeGuardIsRedundant
(
guard
allocateObject
allocate
-
>
shape
(
)
)
)
{
continue
;
}
}
else
if
(
lastStore
-
>
isStart
(
)
)
{
auto
*
obj
=
guard
-
>
object
(
)
-
>
skipObjectGuards
(
)
;
const
Shape
*
initialShape
=
nullptr
;
if
(
obj
-
>
isNewObject
(
)
)
{
auto
*
templateObject
=
obj
-
>
toNewObject
(
)
-
>
templateObject
(
)
;
if
(
!
templateObject
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
no
template
"
)
;
continue
;
}
initialShape
=
templateObject
-
>
shape
(
)
;
}
else
if
(
obj
-
>
isNewPlainObject
(
)
)
{
initialShape
=
obj
-
>
toNewPlainObject
(
)
-
>
shape
(
)
;
}
else
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
not
NewObject
or
NewPlainObject
(
%
d
)
"
obj
-
>
id
(
)
)
;
continue
;
}
if
(
initialShape
!
=
guard
-
>
shape
(
)
)
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
shapes
don
'
t
match
"
)
;
continue
;
}
}
else
{
JitSpew
(
JitSpew_RedundantShapeGuards
"
SKIP
:
Last
store
not
supported
(
%
d
)
"
lastStore
-
>
id
(
)
)
;
continue
;
}
#
ifdef
DEBUG
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
auto
*
assert
=
MAssertShape
:
:
New
(
graph
.
alloc
(
)
guard
-
>
object
(
)
const_cast
<
Shape
*
>
(
guard
-
>
shape
(
)
)
)
;
guard
-
>
block
(
)
-
>
insertBefore
(
guard
assert
)
;
#
endif
JitSpew
(
JitSpew_RedundantShapeGuards
"
SUCCESS
:
Removing
shape
guard
%
d
"
guard
-
>
id
(
)
)
;
guard
-
>
replaceAllUsesWith
(
guard
-
>
input
(
)
)
;
guard
-
>
block
(
)
-
>
discard
(
guard
)
;
}
}
return
true
;
}
[
[
nodiscard
]
]
static
bool
TryEliminateGCBarriersForAllocation
(
TempAllocator
&
alloc
MInstruction
*
allocation
)
{
MOZ_ASSERT
(
allocation
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
JitSpew
(
JitSpew_RedundantGCBarriers
"
Analyzing
allocation
%
s
"
allocation
-
>
opName
(
)
)
;
MBasicBlock
*
block
=
allocation
-
>
block
(
)
;
MInstructionIterator
insIter
(
block
-
>
begin
(
allocation
)
)
;
MOZ_ASSERT
(
*
insIter
=
=
allocation
)
;
insIter
+
+
;
while
(
insIter
!
=
block
-
>
end
(
)
)
{
MInstruction
*
ins
=
*
insIter
;
insIter
+
+
;
switch
(
ins
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
Constant
:
case
MDefinition
:
:
Opcode
:
:
Box
:
case
MDefinition
:
:
Opcode
:
:
Unbox
:
case
MDefinition
:
:
Opcode
:
:
AssertCanElidePostWriteBarrier
:
break
;
case
MDefinition
:
:
Opcode
:
:
StoreFixedSlot
:
{
auto
*
store
=
ins
-
>
toStoreFixedSlot
(
)
;
if
(
store
-
>
object
(
)
!
=
allocation
)
{
JitSpew
(
JitSpew_RedundantGCBarriers
"
Stopped
at
StoreFixedSlot
for
other
object
"
)
;
return
true
;
}
store
-
>
setNeedsBarrier
(
false
)
;
JitSpew
(
JitSpew_RedundantGCBarriers
"
Elided
StoreFixedSlot
barrier
"
)
;
break
;
}
case
MDefinition
:
:
Opcode
:
:
PostWriteBarrier
:
{
auto
*
barrier
=
ins
-
>
toPostWriteBarrier
(
)
;
if
(
barrier
-
>
object
(
)
!
=
allocation
)
{
JitSpew
(
JitSpew_RedundantGCBarriers
"
Stopped
at
PostWriteBarrier
for
other
object
"
)
;
return
true
;
}
#
ifdef
DEBUG
if
(
!
alloc
.
ensureBallast
(
)
)
{
return
false
;
}
MDefinition
*
value
=
barrier
-
>
value
(
)
;
if
(
value
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
value
=
MBox
:
:
New
(
alloc
value
)
;
block
-
>
insertBefore
(
barrier
value
-
>
toInstruction
(
)
)
;
}
auto
*
assert
=
MAssertCanElidePostWriteBarrier
:
:
New
(
alloc
allocation
value
)
;
block
-
>
insertBefore
(
barrier
assert
)
;
#
endif
block
-
>
discard
(
barrier
)
;
JitSpew
(
JitSpew_RedundantGCBarriers
"
Elided
PostWriteBarrier
"
)
;
break
;
}
default
:
JitSpew
(
JitSpew_RedundantGCBarriers
"
Stopped
at
unsupported
instruction
%
s
"
ins
-
>
opName
(
)
)
;
return
true
;
}
}
return
true
;
}
bool
jit
:
:
EliminateRedundantGCBarriers
(
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_RedundantGCBarriers
"
Begin
"
)
;
for
(
ReversePostorderIterator
block
=
graph
.
rpoBegin
(
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
insIter
+
+
)
{
MInstruction
*
ins
=
*
insIter
;
if
(
ins
-
>
isNewCallObject
(
)
)
{
MNewCallObject
*
allocation
=
ins
-
>
toNewCallObject
(
)
;
if
(
allocation
-
>
initialHeap
(
)
=
=
gc
:
:
Heap
:
:
Default
)
{
if
(
!
TryEliminateGCBarriersForAllocation
(
graph
.
alloc
(
)
allocation
)
)
{
return
false
;
}
}
}
}
}
return
true
;
}
bool
jit
:
:
MarkLoadsUsedAsPropertyKeys
(
MIRGraph
&
graph
)
{
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
Begin
"
)
;
for
(
ReversePostorderIterator
block
=
graph
.
rpoBegin
(
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
)
{
MInstruction
*
ins
=
*
insIter
;
insIter
+
+
;
MDefinition
*
idVal
=
nullptr
;
if
(
ins
-
>
isGetPropertyCache
(
)
)
{
idVal
=
ins
-
>
toGetPropertyCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isHasOwnCache
(
)
)
{
idVal
=
ins
-
>
toHasOwnCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isSetPropertyCache
(
)
)
{
idVal
=
ins
-
>
toSetPropertyCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isGetPropSuperCache
(
)
)
{
idVal
=
ins
-
>
toGetPropSuperCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isMegamorphicLoadSlotByValue
(
)
)
{
idVal
=
ins
-
>
toMegamorphicLoadSlotByValue
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isMegamorphicHasProp
(
)
)
{
idVal
=
ins
-
>
toMegamorphicHasProp
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isMegamorphicSetElement
(
)
)
{
idVal
=
ins
-
>
toMegamorphicSetElement
(
)
-
>
index
(
)
;
}
else
if
(
ins
-
>
isProxyGetByValue
(
)
)
{
idVal
=
ins
-
>
toProxyGetByValue
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isProxyHasProp
(
)
)
{
idVal
=
ins
-
>
toProxyHasProp
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isProxySetByValue
(
)
)
{
idVal
=
ins
-
>
toProxySetByValue
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isIdToStringOrSymbol
(
)
)
{
idVal
=
ins
-
>
toIdToStringOrSymbol
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isGuardSpecificAtom
(
)
)
{
idVal
=
ins
-
>
toGuardSpecificAtom
(
)
-
>
input
(
)
;
}
else
if
(
ins
-
>
isToHashableString
(
)
)
{
idVal
=
ins
-
>
toToHashableString
(
)
-
>
input
(
)
;
}
else
if
(
ins
-
>
isToHashableValue
(
)
)
{
idVal
=
ins
-
>
toToHashableValue
(
)
-
>
input
(
)
;
}
else
if
(
ins
-
>
isMapObjectHasValueVMCall
(
)
)
{
idVal
=
ins
-
>
toMapObjectHasValueVMCall
(
)
-
>
value
(
)
;
}
else
if
(
ins
-
>
isMapObjectGetValueVMCall
(
)
)
{
idVal
=
ins
-
>
toMapObjectGetValueVMCall
(
)
-
>
value
(
)
;
}
else
if
(
ins
-
>
isSetObjectHasValueVMCall
(
)
)
{
idVal
=
ins
-
>
toSetObjectHasValueVMCall
(
)
-
>
value
(
)
;
}
else
{
continue
;
}
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
Analyzing
property
access
%
s
%
d
with
idVal
%
s
%
d
"
ins
-
>
opName
(
)
ins
-
>
id
(
)
idVal
-
>
opName
(
)
idVal
-
>
id
(
)
)
;
do
{
if
(
idVal
-
>
isLexicalCheck
(
)
)
{
idVal
=
idVal
-
>
toLexicalCheck
(
)
-
>
input
(
)
;
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
-
Skipping
lexical
check
.
idVal
is
now
%
s
%
d
"
idVal
-
>
opName
(
)
idVal
-
>
id
(
)
)
;
continue
;
}
if
(
idVal
-
>
isUnbox
(
)
&
&
idVal
-
>
type
(
)
=
=
MIRType
:
:
String
)
{
idVal
=
idVal
-
>
toUnbox
(
)
-
>
input
(
)
;
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
-
Skipping
unbox
.
idVal
is
now
%
s
%
d
"
idVal
-
>
opName
(
)
idVal
-
>
id
(
)
)
;
continue
;
}
break
;
}
while
(
true
)
;
if
(
idVal
-
>
isLoadFixedSlot
(
)
)
{
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
-
SUCCESS
:
Marking
fixed
slot
"
)
;
idVal
-
>
toLoadFixedSlot
(
)
-
>
setUsedAsPropertyKey
(
)
;
}
else
if
(
idVal
-
>
isLoadDynamicSlot
(
)
)
{
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
-
SUCCESS
:
Marking
dynamic
slot
"
)
;
idVal
-
>
toLoadDynamicSlot
(
)
-
>
setUsedAsPropertyKey
(
)
;
}
else
{
JitSpew
(
JitSpew_MarkLoadsUsedAsPropertyKeys
"
-
SKIP
:
%
s
not
supported
"
idVal
-
>
opName
(
)
)
;
}
}
}
return
true
;
}
static
bool
UpdateWasmRefType
(
MDefinition
*
def
)
{
wasm
:
:
MaybeRefType
newRefType
=
def
-
>
computeWasmRefType
(
)
;
bool
changed
=
newRefType
!
=
def
-
>
wasmRefType
(
)
;
MOZ_ASSERT
(
!
(
def
-
>
wasmRefType
(
)
.
isSome
(
)
&
&
newRefType
.
isNothing
(
)
)
)
;
MOZ_ASSERT_IF
(
def
-
>
wasmRefType
(
)
.
isSome
(
)
wasm
:
:
RefType
:
:
isSubTypeOf
(
newRefType
.
value
(
)
def
-
>
wasmRefType
(
)
.
value
(
)
)
)
;
def
-
>
setWasmRefType
(
newRefType
)
;
return
changed
;
}
bool
jit
:
:
TrackWasmRefTypes
(
MIRGraph
&
graph
)
{
Vector
<
MDefinition
*
16
SystemAllocPolicy
>
worklist
;
for
(
ReversePostorderIterator
blockIter
=
graph
.
rpoBegin
(
)
;
blockIter
!
=
graph
.
rpoEnd
(
)
;
blockIter
+
+
)
{
MBasicBlock
*
block
=
*
blockIter
;
for
(
MDefinitionIterator
def
(
block
)
;
def
;
def
+
+
)
{
if
(
def
-
>
type
(
)
!
=
MIRType
:
:
WasmAnyRef
)
{
continue
;
}
bool
hasType
=
UpdateWasmRefType
(
*
def
)
;
if
(
hasType
)
{
for
(
MUseIterator
use
(
def
-
>
usesBegin
(
)
)
;
use
!
=
def
-
>
usesEnd
(
)
;
use
+
+
)
{
MNode
*
consumer
=
use
-
>
consumer
(
)
;
if
(
!
consumer
-
>
isDefinition
(
)
|
|
!
consumer
-
>
toDefinition
(
)
-
>
isPhi
(
)
)
{
continue
;
}
MPhi
*
phi
=
consumer
-
>
toDefinition
(
)
-
>
toPhi
(
)
;
if
(
phi
-
>
block
(
)
-
>
isLoopHeader
(
)
&
&
*
def
=
=
phi
-
>
getLoopBackedgeOperand
(
)
)
{
bool
changed
=
UpdateWasmRefType
(
phi
)
;
if
(
changed
&
&
!
worklist
.
append
(
phi
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
consumer
-
>
toDefinition
(
)
-
>
wasmRefType
(
)
.
isNothing
(
)
)
;
}
}
}
}
}
while
(
!
worklist
.
empty
(
)
)
{
MDefinition
*
def
=
worklist
.
popCopy
(
)
;
for
(
MUseIterator
use
(
def
-
>
usesBegin
(
)
)
;
use
!
=
def
-
>
usesEnd
(
)
;
use
+
+
)
{
if
(
!
use
-
>
consumer
(
)
-
>
isDefinition
(
)
)
{
continue
;
}
bool
changed
=
UpdateWasmRefType
(
use
-
>
consumer
(
)
-
>
toDefinition
(
)
)
;
if
(
changed
&
&
!
worklist
.
append
(
use
-
>
consumer
(
)
-
>
toDefinition
(
)
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
NeedsKeepAlive
(
MInstruction
*
slotsOrElements
MInstruction
*
use
)
{
MOZ_ASSERT
(
slotsOrElements
-
>
type
(
)
=
=
MIRType
:
:
Elements
|
|
slotsOrElements
-
>
type
(
)
=
=
MIRType
:
:
Slots
)
;
if
(
slotsOrElements
-
>
block
(
)
!
=
use
-
>
block
(
)
)
{
return
true
;
}
if
(
use
-
>
type
(
)
=
=
MIRType
:
:
BigInt
)
{
return
true
;
}
if
(
use
-
>
isLoadTypedArrayElementHole
(
)
&
&
Scalar
:
:
isBigIntType
(
use
-
>
toLoadTypedArrayElementHole
(
)
-
>
arrayType
(
)
)
)
{
return
true
;
}
MBasicBlock
*
block
=
use
-
>
block
(
)
;
MInstructionIterator
iter
(
block
-
>
begin
(
slotsOrElements
)
)
;
MOZ_ASSERT
(
*
iter
=
=
slotsOrElements
)
;
+
+
iter
;
while
(
true
)
{
if
(
*
iter
=
=
use
)
{
return
false
;
}
switch
(
iter
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
Nop
:
case
MDefinition
:
:
Opcode
:
:
Constant
:
case
MDefinition
:
:
Opcode
:
:
KeepAliveObject
:
case
MDefinition
:
:
Opcode
:
:
Unbox
:
case
MDefinition
:
:
Opcode
:
:
LoadDynamicSlot
:
case
MDefinition
:
:
Opcode
:
:
StoreDynamicSlot
:
case
MDefinition
:
:
Opcode
:
:
LoadFixedSlot
:
case
MDefinition
:
:
Opcode
:
:
StoreFixedSlot
:
case
MDefinition
:
:
Opcode
:
:
LoadElement
:
case
MDefinition
:
:
Opcode
:
:
LoadElementAndUnbox
:
case
MDefinition
:
:
Opcode
:
:
LoadElementHole
:
case
MDefinition
:
:
Opcode
:
:
StoreElement
:
case
MDefinition
:
:
Opcode
:
:
StoreHoleValueElement
:
case
MDefinition
:
:
Opcode
:
:
InitializedLength
:
case
MDefinition
:
:
Opcode
:
:
ArrayLength
:
case
MDefinition
:
:
Opcode
:
:
BoundsCheck
:
case
MDefinition
:
:
Opcode
:
:
GuardElementNotHole
:
case
MDefinition
:
:
Opcode
:
:
GuardElementsArePacked
:
case
MDefinition
:
:
Opcode
:
:
InArray
:
case
MDefinition
:
:
Opcode
:
:
SpectreMaskIndex
:
case
MDefinition
:
:
Opcode
:
:
DebugEnterGCUnsafeRegion
:
case
MDefinition
:
:
Opcode
:
:
DebugLeaveGCUnsafeRegion
:
iter
+
+
;
break
;
default
:
return
true
;
}
}
MOZ_CRASH
(
"
Unreachable
"
)
;
}
bool
jit
:
:
AddKeepAliveInstructions
(
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
i
(
graph
.
begin
(
)
)
;
i
!
=
graph
.
end
(
)
;
i
+
+
)
{
MBasicBlock
*
block
=
*
i
;
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
insIter
+
+
)
{
MInstruction
*
ins
=
*
insIter
;
if
(
ins
-
>
type
(
)
!
=
MIRType
:
:
Elements
&
&
ins
-
>
type
(
)
!
=
MIRType
:
:
Slots
)
{
continue
;
}
MDefinition
*
ownerObject
;
switch
(
ins
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
Elements
:
case
MDefinition
:
:
Opcode
:
:
ArrayBufferViewElements
:
MOZ_ASSERT
(
ins
-
>
numOperands
(
)
=
=
1
)
;
ownerObject
=
ins
-
>
getOperand
(
0
)
;
break
;
case
MDefinition
:
:
Opcode
:
:
ArrayBufferViewElementsWithOffset
:
MOZ_ASSERT
(
ins
-
>
numOperands
(
)
=
=
2
)
;
ownerObject
=
ins
-
>
getOperand
(
0
)
;
break
;
case
MDefinition
:
:
Opcode
:
:
Slots
:
ownerObject
=
ins
-
>
toSlots
(
)
-
>
object
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
op
"
)
;
}
MOZ_ASSERT
(
ownerObject
-
>
type
(
)
=
=
MIRType
:
:
Object
)
;
const
MDefinition
*
unwrapped
=
ownerObject
-
>
skipObjectGuards
(
)
;
if
(
unwrapped
-
>
isConstant
(
)
|
|
unwrapped
-
>
isNurseryObject
(
)
)
{
continue
;
}
for
(
MUseDefIterator
uses
(
ins
)
;
uses
;
uses
+
+
)
{
MInstruction
*
use
=
uses
.
def
(
)
-
>
toInstruction
(
)
;
if
(
use
-
>
isStoreElementHole
(
)
)
{
MOZ_ASSERT_IF
(
!
use
-
>
toStoreElementHole
(
)
-
>
object
(
)
-
>
isUnbox
(
)
&
&
!
ownerObject
-
>
isUnbox
(
)
use
-
>
toStoreElementHole
(
)
-
>
object
(
)
=
=
ownerObject
)
;
continue
;
}
if
(
!
NeedsKeepAlive
(
ins
use
)
)
{
#
ifdef
DEBUG
if
(
use
-
>
isApplyArray
(
)
|
|
use
-
>
isConstructArray
(
)
)
{
continue
;
}
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
auto
*
enter
=
MDebugEnterGCUnsafeRegion
:
:
New
(
graph
.
alloc
(
)
)
;
use
-
>
block
(
)
-
>
insertAfter
(
ins
enter
)
;
auto
*
leave
=
MDebugLeaveGCUnsafeRegion
:
:
New
(
graph
.
alloc
(
)
)
;
use
-
>
block
(
)
-
>
insertAfter
(
use
leave
)
;
#
endif
continue
;
}
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MKeepAliveObject
*
keepAlive
=
MKeepAliveObject
:
:
New
(
graph
.
alloc
(
)
ownerObject
)
;
use
-
>
block
(
)
-
>
insertAfter
(
use
keepAlive
)
;
}
}
}
return
true
;
}
bool
LinearSum
:
:
multiply
(
int32_t
scale
)
{
for
(
size_t
i
=
0
;
i
<
terms_
.
length
(
)
;
i
+
+
)
{
if
(
!
SafeMul
(
scale
terms_
[
i
]
.
scale
&
terms_
[
i
]
.
scale
)
)
{
return
false
;
}
}
return
SafeMul
(
scale
constant_
&
constant_
)
;
}
bool
LinearSum
:
:
divide
(
uint32_t
scale
)
{
MOZ_ASSERT
(
scale
>
0
)
;
for
(
size_t
i
=
0
;
i
<
terms_
.
length
(
)
;
i
+
+
)
{
if
(
terms_
[
i
]
.
scale
%
scale
!
=
0
)
{
return
false
;
}
}
if
(
constant_
%
scale
!
=
0
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
terms_
.
length
(
)
;
i
+
+
)
{
terms_
[
i
]
.
scale
/
=
scale
;
}
constant_
/
=
scale
;
return
true
;
}
bool
LinearSum
:
:
add
(
const
LinearSum
&
other
int32_t
scale
)
{
for
(
size_t
i
=
0
;
i
<
other
.
terms_
.
length
(
)
;
i
+
+
)
{
int32_t
newScale
=
scale
;
if
(
!
SafeMul
(
scale
other
.
terms_
[
i
]
.
scale
&
newScale
)
)
{
return
false
;
}
if
(
!
add
(
other
.
terms_
[
i
]
.
term
newScale
)
)
{
return
false
;
}
}
int32_t
newConstant
=
scale
;
if
(
!
SafeMul
(
scale
other
.
constant_
&
newConstant
)
)
{
return
false
;
}
return
add
(
newConstant
)
;
}
bool
LinearSum
:
:
add
(
SimpleLinearSum
other
int32_t
scale
)
{
if
(
other
.
term
&
&
!
add
(
other
.
term
scale
)
)
{
return
false
;
}
int32_t
constant
;
if
(
!
SafeMul
(
other
.
constant
scale
&
constant
)
)
{
return
false
;
}
return
add
(
constant
)
;
}
bool
LinearSum
:
:
add
(
MDefinition
*
term
int32_t
scale
)
{
MOZ_ASSERT
(
term
)
;
if
(
scale
=
=
0
)
{
return
true
;
}
if
(
MConstant
*
termConst
=
term
-
>
maybeConstantValue
(
)
)
{
int32_t
constant
=
termConst
-
>
toInt32
(
)
;
if
(
!
SafeMul
(
constant
scale
&
constant
)
)
{
return
false
;
}
return
add
(
constant
)
;
}
for
(
size_t
i
=
0
;
i
<
terms_
.
length
(
)
;
i
+
+
)
{
if
(
term
=
=
terms_
[
i
]
.
term
)
{
if
(
!
SafeAdd
(
scale
terms_
[
i
]
.
scale
&
terms_
[
i
]
.
scale
)
)
{
return
false
;
}
if
(
terms_
[
i
]
.
scale
=
=
0
)
{
terms_
[
i
]
=
terms_
.
back
(
)
;
terms_
.
popBack
(
)
;
}
return
true
;
}
}
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
terms_
.
append
(
LinearTerm
(
term
scale
)
)
)
{
oomUnsafe
.
crash
(
"
LinearSum
:
:
add
"
)
;
}
return
true
;
}
bool
LinearSum
:
:
add
(
int32_t
constant
)
{
return
SafeAdd
(
constant
constant_
&
constant_
)
;
}
void
LinearSum
:
:
dump
(
GenericPrinter
&
out
)
const
{
for
(
size_t
i
=
0
;
i
<
terms_
.
length
(
)
;
i
+
+
)
{
int32_t
scale
=
terms_
[
i
]
.
scale
;
int32_t
id
=
terms_
[
i
]
.
term
-
>
id
(
)
;
MOZ_ASSERT
(
scale
)
;
if
(
scale
>
0
)
{
if
(
i
)
{
out
.
printf
(
"
+
"
)
;
}
if
(
scale
=
=
1
)
{
out
.
printf
(
"
#
%
d
"
id
)
;
}
else
{
out
.
printf
(
"
%
d
*
#
%
d
"
scale
id
)
;
}
}
else
if
(
scale
=
=
-
1
)
{
out
.
printf
(
"
-
#
%
d
"
id
)
;
}
else
{
out
.
printf
(
"
%
d
*
#
%
d
"
scale
id
)
;
}
}
if
(
constant_
>
0
)
{
out
.
printf
(
"
+
%
d
"
constant_
)
;
}
else
if
(
constant_
<
0
)
{
out
.
printf
(
"
%
d
"
constant_
)
;
}
}
void
LinearSum
:
:
dump
(
)
const
{
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
out
.
finish
(
)
;
}
MDefinition
*
jit
:
:
ConvertLinearSum
(
TempAllocator
&
alloc
MBasicBlock
*
block
const
LinearSum
&
sum
BailoutKind
bailoutKind
)
{
MDefinition
*
def
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
sum
.
numTerms
(
)
;
i
+
+
)
{
LinearTerm
term
=
sum
.
term
(
i
)
;
MOZ_ASSERT
(
!
term
.
term
-
>
isConstant
(
)
)
;
if
(
term
.
scale
=
=
1
)
{
if
(
def
)
{
def
=
MAdd
:
:
New
(
alloc
def
term
.
term
MIRType
:
:
Int32
)
;
def
-
>
setBailoutKind
(
bailoutKind
)
;
block
-
>
insertAtEnd
(
def
-
>
toInstruction
(
)
)
;
def
-
>
computeRange
(
alloc
)
;
}
else
{
def
=
term
.
term
;
}
}
else
if
(
term
.
scale
=
=
-
1
)
{
if
(
!
def
)
{
def
=
MConstant
:
:
NewInt32
(
alloc
0
)
;
block
-
>
insertAtEnd
(
def
-
>
toInstruction
(
)
)
;
def
-
>
computeRange
(
alloc
)
;
}
def
=
MSub
:
:
New
(
alloc
def
term
.
term
MIRType
:
:
Int32
)
;
def
-
>
setBailoutKind
(
bailoutKind
)
;
block
-
>
insertAtEnd
(
def
-
>
toInstruction
(
)
)
;
def
-
>
computeRange
(
alloc
)
;
}
else
{
MOZ_ASSERT
(
term
.
scale
!
=
0
)
;
MConstant
*
factor
=
MConstant
:
:
NewInt32
(
alloc
term
.
scale
)
;
block
-
>
insertAtEnd
(
factor
)
;
MMul
*
mul
=
MMul
:
:
New
(
alloc
term
.
term
factor
MIRType
:
:
Int32
)
;
mul
-
>
setBailoutKind
(
bailoutKind
)
;
block
-
>
insertAtEnd
(
mul
)
;
mul
-
>
computeRange
(
alloc
)
;
if
(
def
)
{
def
=
MAdd
:
:
New
(
alloc
def
mul
MIRType
:
:
Int32
)
;
def
-
>
setBailoutKind
(
bailoutKind
)
;
block
-
>
insertAtEnd
(
def
-
>
toInstruction
(
)
)
;
def
-
>
computeRange
(
alloc
)
;
}
else
{
def
=
mul
;
}
}
}
if
(
!
def
)
{
def
=
MConstant
:
:
NewInt32
(
alloc
0
)
;
block
-
>
insertAtEnd
(
def
-
>
toInstruction
(
)
)
;
def
-
>
computeRange
(
alloc
)
;
}
return
def
;
}
size_t
jit
:
:
MarkLoopBlocks
(
MIRGraph
&
graph
const
MBasicBlock
*
header
bool
*
canOsr
)
{
#
ifdef
DEBUG
for
(
ReversePostorderIterator
i
=
graph
.
rpoBegin
(
)
e
=
graph
.
rpoEnd
(
)
;
i
!
=
e
;
+
+
i
)
{
MOZ_ASSERT
(
!
i
-
>
isMarked
(
)
"
Some
blocks
already
marked
"
)
;
}
#
endif
MBasicBlock
*
osrBlock
=
graph
.
osrBlock
(
)
;
*
canOsr
=
false
;
MBasicBlock
*
backedge
=
header
-
>
backedge
(
)
;
backedge
-
>
mark
(
)
;
size_t
numMarked
=
1
;
for
(
PostorderIterator
i
=
graph
.
poBegin
(
backedge
)
;
;
+
+
i
)
{
MOZ_ASSERT
(
i
!
=
graph
.
poEnd
(
)
"
Reached
the
end
of
the
graph
while
searching
for
the
loop
header
"
)
;
MBasicBlock
*
block
=
*
i
;
if
(
block
=
=
header
)
{
break
;
}
if
(
!
block
-
>
isMarked
(
)
)
{
continue
;
}
for
(
size_t
p
=
0
e
=
block
-
>
numPredecessors
(
)
;
p
!
=
e
;
+
+
p
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
p
)
;
if
(
pred
-
>
isMarked
(
)
)
{
continue
;
}
if
(
osrBlock
&
&
pred
!
=
header
&
&
osrBlock
-
>
dominates
(
pred
)
&
&
!
osrBlock
-
>
dominates
(
header
)
)
{
*
canOsr
=
true
;
continue
;
}
MOZ_ASSERT
(
pred
-
>
id
(
)
>
=
header
-
>
id
(
)
&
&
pred
-
>
id
(
)
<
=
backedge
-
>
id
(
)
"
Loop
block
not
between
loop
header
and
loop
backedge
"
)
;
pred
-
>
mark
(
)
;
+
+
numMarked
;
if
(
pred
-
>
isLoopHeader
(
)
)
{
MBasicBlock
*
innerBackedge
=
pred
-
>
backedge
(
)
;
if
(
!
innerBackedge
-
>
isMarked
(
)
)
{
innerBackedge
-
>
mark
(
)
;
+
+
numMarked
;
if
(
innerBackedge
-
>
id
(
)
>
block
-
>
id
(
)
)
{
i
=
graph
.
poBegin
(
innerBackedge
)
;
-
-
i
;
}
}
}
}
}
if
(
!
header
-
>
isMarked
(
)
)
{
jit
:
:
UnmarkLoopBlocks
(
graph
header
)
;
return
0
;
}
return
numMarked
;
}
void
jit
:
:
UnmarkLoopBlocks
(
MIRGraph
&
graph
const
MBasicBlock
*
header
)
{
MBasicBlock
*
backedge
=
header
-
>
backedge
(
)
;
for
(
ReversePostorderIterator
i
=
graph
.
rpoBegin
(
header
)
;
;
+
+
i
)
{
MOZ_ASSERT
(
i
!
=
graph
.
rpoEnd
(
)
"
Reached
the
end
of
the
graph
while
searching
for
the
backedge
"
)
;
MBasicBlock
*
block
=
*
i
;
if
(
block
-
>
isMarked
(
)
)
{
block
-
>
unmark
(
)
;
if
(
block
=
=
backedge
)
{
break
;
}
}
}
#
ifdef
DEBUG
for
(
ReversePostorderIterator
i
=
graph
.
rpoBegin
(
)
e
=
graph
.
rpoEnd
(
)
;
i
!
=
e
;
+
+
i
)
{
MOZ_ASSERT
(
!
i
-
>
isMarked
(
)
"
Not
all
blocks
got
unmarked
"
)
;
}
#
endif
}
bool
jit
:
:
FoldLoadsWithUnbox
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
block
(
graph
.
begin
(
)
)
;
block
!
=
graph
.
end
(
)
;
block
+
+
)
{
if
(
mir
-
>
shouldCancel
(
"
FoldLoadsWithUnbox
"
)
)
{
return
false
;
}
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
)
{
MInstruction
*
ins
=
*
insIter
;
insIter
+
+
;
if
(
!
ins
-
>
isLoadFixedSlot
(
)
&
&
!
ins
-
>
isLoadDynamicSlot
(
)
&
&
!
ins
-
>
isLoadElement
(
)
)
{
continue
;
}
if
(
ins
-
>
type
(
)
!
=
MIRType
:
:
Value
)
{
continue
;
}
MInstruction
*
load
=
ins
;
MDefinition
*
defUse
=
load
-
>
maybeSingleDefUse
(
)
;
if
(
!
defUse
)
{
continue
;
}
MLexicalCheck
*
lexicalCheck
=
nullptr
;
if
(
defUse
-
>
isLexicalCheck
(
)
)
{
lexicalCheck
=
defUse
-
>
toLexicalCheck
(
)
;
defUse
=
lexicalCheck
-
>
maybeSingleDefUse
(
)
;
if
(
!
defUse
)
{
continue
;
}
}
if
(
!
defUse
-
>
isUnbox
(
)
)
{
continue
;
}
MUnbox
*
unbox
=
defUse
-
>
toUnbox
(
)
;
if
(
unbox
-
>
block
(
)
!
=
*
block
)
{
continue
;
}
MOZ_ASSERT_IF
(
lexicalCheck
lexicalCheck
-
>
block
(
)
=
=
*
block
)
;
MOZ_ASSERT
(
!
IsMagicType
(
unbox
-
>
type
(
)
)
)
;
if
(
(
load
-
>
isLoadElement
(
)
|
|
lexicalCheck
)
&
&
!
unbox
-
>
fallible
(
)
)
{
continue
;
}
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MIRType
type
=
unbox
-
>
type
(
)
;
MUnbox
:
:
Mode
mode
=
unbox
-
>
mode
(
)
;
MInstruction
*
replacement
;
switch
(
load
-
>
op
(
)
)
{
case
MDefinition
:
:
Opcode
:
:
LoadFixedSlot
:
{
auto
*
loadIns
=
load
-
>
toLoadFixedSlot
(
)
;
replacement
=
MLoadFixedSlotAndUnbox
:
:
New
(
graph
.
alloc
(
)
loadIns
-
>
object
(
)
loadIns
-
>
slot
(
)
mode
type
loadIns
-
>
usedAsPropertyKey
(
)
)
;
break
;
}
case
MDefinition
:
:
Opcode
:
:
LoadDynamicSlot
:
{
auto
*
loadIns
=
load
-
>
toLoadDynamicSlot
(
)
;
replacement
=
MLoadDynamicSlotAndUnbox
:
:
New
(
graph
.
alloc
(
)
loadIns
-
>
slots
(
)
loadIns
-
>
slot
(
)
mode
type
loadIns
-
>
usedAsPropertyKey
(
)
)
;
break
;
}
case
MDefinition
:
:
Opcode
:
:
LoadElement
:
{
auto
*
loadIns
=
load
-
>
toLoadElement
(
)
;
MOZ_ASSERT
(
unbox
-
>
fallible
(
)
)
;
replacement
=
MLoadElementAndUnbox
:
:
New
(
graph
.
alloc
(
)
loadIns
-
>
elements
(
)
loadIns
-
>
index
(
)
mode
type
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Unexpected
instruction
"
)
;
}
replacement
-
>
setBailoutKind
(
BailoutKind
:
:
UnboxFolding
)
;
block
-
>
insertBefore
(
load
replacement
)
;
unbox
-
>
replaceAllUsesWith
(
replacement
)
;
if
(
lexicalCheck
)
{
lexicalCheck
-
>
replaceAllUsesWith
(
replacement
)
;
}
load
-
>
replaceAllUsesWith
(
replacement
)
;
if
(
lexicalCheck
&
&
*
insIter
=
=
lexicalCheck
)
{
insIter
+
+
;
}
if
(
*
insIter
=
=
unbox
)
{
insIter
+
+
;
}
block
-
>
discard
(
unbox
)
;
if
(
lexicalCheck
)
{
block
-
>
discard
(
lexicalCheck
)
;
}
block
-
>
discard
(
load
)
;
}
}
return
true
;
}
static
void
MakeLoopContiguous
(
MIRGraph
&
graph
MBasicBlock
*
header
size_t
numMarked
)
{
MBasicBlock
*
backedge
=
header
-
>
backedge
(
)
;
MOZ_ASSERT
(
header
-
>
isMarked
(
)
"
Loop
header
is
not
part
of
loop
"
)
;
MOZ_ASSERT
(
backedge
-
>
isMarked
(
)
"
Loop
backedge
is
not
part
of
loop
"
)
;
ReversePostorderIterator
insertIter
=
graph
.
rpoBegin
(
backedge
)
;
insertIter
+
+
;
MBasicBlock
*
insertPt
=
*
insertIter
;
size_t
headerId
=
header
-
>
id
(
)
;
size_t
inLoopId
=
headerId
;
size_t
notInLoopId
=
inLoopId
+
numMarked
;
ReversePostorderIterator
i
=
graph
.
rpoBegin
(
header
)
;
for
(
;
;
)
{
MBasicBlock
*
block
=
*
i
+
+
;
MOZ_ASSERT
(
block
-
>
id
(
)
>
=
header
-
>
id
(
)
&
&
block
-
>
id
(
)
<
=
backedge
-
>
id
(
)
"
Loop
backedge
should
be
last
block
in
loop
"
)
;
if
(
block
-
>
isMarked
(
)
)
{
block
-
>
unmark
(
)
;
block
-
>
setId
(
inLoopId
+
+
)
;
if
(
block
=
=
backedge
)
{
break
;
}
}
else
{
graph
.
moveBlockBefore
(
insertPt
block
)
;
block
-
>
setId
(
notInLoopId
+
+
)
;
}
}
MOZ_ASSERT
(
header
-
>
id
(
)
=
=
headerId
"
Loop
header
id
changed
"
)
;
MOZ_ASSERT
(
inLoopId
=
=
headerId
+
numMarked
"
Wrong
number
of
blocks
kept
in
loop
"
)
;
MOZ_ASSERT
(
notInLoopId
=
=
(
insertIter
!
=
graph
.
rpoEnd
(
)
?
insertPt
-
>
id
(
)
:
graph
.
numBlocks
(
)
)
"
Wrong
number
of
blocks
moved
out
of
loop
"
)
;
}
bool
jit
:
:
MakeLoopsContiguous
(
MIRGraph
&
graph
)
{
for
(
MBasicBlockIterator
i
(
graph
.
begin
(
)
)
;
i
!
=
graph
.
end
(
)
;
i
+
+
)
{
MBasicBlock
*
header
=
*
i
;
if
(
!
header
-
>
isLoopHeader
(
)
)
{
continue
;
}
bool
canOsr
;
size_t
numMarked
=
MarkLoopBlocks
(
graph
header
&
canOsr
)
;
if
(
numMarked
=
=
0
)
{
continue
;
}
if
(
canOsr
)
{
UnmarkLoopBlocks
(
graph
header
)
;
continue
;
}
MakeLoopContiguous
(
graph
header
numMarked
)
;
}
return
true
;
}
static
MDefinition
*
SkipUnbox
(
MDefinition
*
ins
)
{
if
(
ins
-
>
isUnbox
(
)
)
{
return
ins
-
>
toUnbox
(
)
-
>
input
(
)
;
}
return
ins
;
}
bool
jit
:
:
OptimizeIteratorIndices
(
const
MIRGenerator
*
mir
MIRGraph
&
graph
)
{
bool
changed
=
false
;
for
(
ReversePostorderIterator
blockIter
=
graph
.
rpoBegin
(
)
;
blockIter
!
=
graph
.
rpoEnd
(
)
;
)
{
MBasicBlock
*
block
=
*
blockIter
+
+
;
for
(
MInstructionIterator
insIter
(
block
-
>
begin
(
)
)
;
insIter
!
=
block
-
>
end
(
)
;
)
{
MInstruction
*
ins
=
*
insIter
;
insIter
+
+
;
if
(
!
graph
.
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
MDefinition
*
receiver
=
nullptr
;
MDefinition
*
idVal
=
nullptr
;
MDefinition
*
setValue
=
nullptr
;
if
(
ins
-
>
isMegamorphicHasProp
(
)
&
&
ins
-
>
toMegamorphicHasProp
(
)
-
>
hasOwn
(
)
)
{
receiver
=
ins
-
>
toMegamorphicHasProp
(
)
-
>
object
(
)
;
idVal
=
ins
-
>
toMegamorphicHasProp
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isHasOwnCache
(
)
)
{
receiver
=
ins
-
>
toHasOwnCache
(
)
-
>
value
(
)
;
idVal
=
ins
-
>
toHasOwnCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isMegamorphicLoadSlotByValue
(
)
)
{
receiver
=
ins
-
>
toMegamorphicLoadSlotByValue
(
)
-
>
object
(
)
;
idVal
=
ins
-
>
toMegamorphicLoadSlotByValue
(
)
-
>
idVal
(
)
;
}
else
if
(
ins
-
>
isGetPropertyCache
(
)
)
{
receiver
=
ins
-
>
toGetPropertyCache
(
)
-
>
value
(
)
;
idVal
=
ins
-
>
toGetPropertyCache
(
)
-
>
idval
(
)
;
}
else
if
(
ins
-
>
isMegamorphicSetElement
(
)
)
{
receiver
=
ins
-
>
toMegamorphicSetElement
(
)
-
>
object
(
)
;
idVal
=
ins
-
>
toMegamorphicSetElement
(
)
-
>
index
(
)
;
setValue
=
ins
-
>
toMegamorphicSetElement
(
)
-
>
value
(
)
;
}
else
if
(
ins
-
>
isSetPropertyCache
(
)
)
{
receiver
=
ins
-
>
toSetPropertyCache
(
)
-
>
object
(
)
;
idVal
=
ins
-
>
toSetPropertyCache
(
)
-
>
idval
(
)
;
setValue
=
ins
-
>
toSetPropertyCache
(
)
-
>
value
(
)
;
}
if
(
!
receiver
)
{
continue
;
}
if
(
!
idVal
-
>
isIteratorMore
(
)
)
{
continue
;
}
auto
*
iterNext
=
idVal
-
>
toIteratorMore
(
)
;
if
(
!
iterNext
-
>
iterator
(
)
-
>
isObjectToIterator
(
)
)
{
continue
;
}
MObjectToIterator
*
iter
=
iterNext
-
>
iterator
(
)
-
>
toObjectToIterator
(
)
;
if
(
SkipUnbox
(
iter
-
>
object
(
)
)
!
=
SkipUnbox
(
receiver
)
)
{
continue
;
}
MInstruction
*
indicesCheck
=
MIteratorHasIndices
:
:
New
(
graph
.
alloc
(
)
iter
-
>
object
(
)
iter
)
;
MInstruction
*
replacement
;
if
(
ins
-
>
isHasOwnCache
(
)
|
|
ins
-
>
isMegamorphicHasProp
(
)
)
{
MOZ_ASSERT
(
!
setValue
)
;
replacement
=
MConstant
:
:
NewBoolean
(
graph
.
alloc
(
)
true
)
;
}
else
if
(
ins
-
>
isMegamorphicLoadSlotByValue
(
)
|
|
ins
-
>
isGetPropertyCache
(
)
)
{
MOZ_ASSERT
(
!
setValue
)
;
replacement
=
MLoadSlotByIteratorIndex
:
:
New
(
graph
.
alloc
(
)
receiver
iter
)
;
}
else
{
MOZ_ASSERT
(
ins
-
>
isMegamorphicSetElement
(
)
|
|
ins
-
>
isSetPropertyCache
(
)
)
;
MOZ_ASSERT
(
setValue
)
;
replacement
=
MStoreSlotByIteratorIndex
:
:
New
(
graph
.
alloc
(
)
receiver
iter
setValue
)
;
}
if
(
!
block
-
>
wrapInstructionInFastpath
(
ins
replacement
indicesCheck
)
)
{
return
false
;
}
iter
-
>
setWantsIndices
(
true
)
;
changed
=
true
;
blockIter
=
graph
.
rpoBegin
(
block
-
>
getSuccessor
(
0
)
-
>
getSuccessor
(
0
)
)
;
break
;
}
}
if
(
changed
&
&
!
AccountForCFGChanges
(
mir
graph
false
)
)
{
return
false
;
}
return
true
;
}
void
jit
:
:
DumpHashedPointer
(
GenericPrinter
&
out
const
void
*
p
)
{
#
ifdef
JS_JITSPEW
if
(
!
p
)
{
out
.
printf
(
"
NULL
"
)
;
return
;
}
char
tab
[
27
]
=
"
abcdefghijklmnopqrstuvwxyz
"
;
MOZ_ASSERT
(
tab
[
26
]
=
=
'
\
0
'
)
;
mozilla
:
:
HashNumber
hash
=
mozilla
:
:
AddToHash
(
mozilla
:
:
HashNumber
(
0
)
p
)
;
hash
%
=
(
26
*
26
*
26
*
26
*
26
)
;
char
buf
[
6
]
;
for
(
int
i
=
0
;
i
<
=
4
;
i
+
+
)
{
buf
[
i
]
=
tab
[
hash
%
26
]
;
hash
/
=
26
;
}
buf
[
5
]
=
'
\
0
'
;
out
.
printf
(
"
%
s
"
buf
)
;
#
endif
}
void
jit
:
:
DumpMIRDefinitionID
(
GenericPrinter
&
out
const
MDefinition
*
def
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
if
(
!
def
)
{
out
.
printf
(
"
(
null
)
"
)
;
return
;
}
if
(
showDetails
)
{
DumpHashedPointer
(
out
def
)
;
out
.
printf
(
"
.
"
)
;
}
out
.
printf
(
"
%
u
"
def
-
>
id
(
)
)
;
#
endif
}
void
jit
:
:
DumpMIRDefinition
(
GenericPrinter
&
out
const
MDefinition
*
def
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
DumpMIRDefinitionID
(
out
def
showDetails
)
;
out
.
printf
(
"
=
%
s
.
"
StringFromMIRType
(
def
-
>
type
(
)
)
)
;
if
(
def
-
>
isConstant
(
)
)
{
def
-
>
printOpcode
(
out
)
;
}
else
{
MDefinition
:
:
PrintOpcodeName
(
out
def
-
>
op
(
)
)
;
}
ExtrasCollector
extras
;
def
-
>
getExtras
(
&
extras
)
;
for
(
size_t
i
=
0
;
i
<
extras
.
count
(
)
;
i
+
+
)
{
out
.
printf
(
"
%
s
"
extras
.
get
(
i
)
.
get
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
def
-
>
numOperands
(
)
;
i
+
+
)
{
out
.
printf
(
"
"
)
;
DumpMIRDefinitionID
(
out
def
-
>
getOperand
(
i
)
showDetails
)
;
}
if
(
def
-
>
dependency
(
)
&
&
showDetails
)
{
out
.
printf
(
"
DEP
=
"
)
;
DumpMIRDefinitionID
(
out
def
-
>
dependency
(
)
showDetails
)
;
}
if
(
def
-
>
hasUses
(
)
)
{
out
.
printf
(
"
uses
=
"
)
;
bool
first
=
true
;
for
(
auto
use
=
def
-
>
usesBegin
(
)
;
use
!
=
def
-
>
usesEnd
(
)
;
use
+
+
)
{
MNode
*
consumer
=
(
*
use
)
-
>
consumer
(
)
;
if
(
!
first
)
{
out
.
printf
(
"
"
)
;
}
if
(
consumer
-
>
isDefinition
(
)
)
{
out
.
printf
(
"
%
d
"
consumer
-
>
toDefinition
(
)
-
>
id
(
)
)
;
}
else
{
out
.
printf
(
"
?
"
)
;
}
first
=
false
;
}
}
if
(
def
-
>
hasAnyFlags
(
)
&
&
showDetails
)
{
out
.
printf
(
"
flags
=
"
)
;
bool
first
=
true
;
#
define
OUTPUT_FLAG
(
_F
)
\
do
{
\
if
(
def
-
>
is
#
#
_F
(
)
)
{
\
out
.
printf
(
"
%
s
%
s
"
first
?
"
"
:
"
"
#
_F
)
;
\
first
=
false
;
\
}
\
}
while
(
0
)
;
MIR_FLAG_LIST
(
OUTPUT_FLAG
)
;
#
undef
OUTPUT_FLAG
}
#
endif
}
void
jit
:
:
DumpMIRBlockID
(
GenericPrinter
&
out
const
MBasicBlock
*
block
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
if
(
!
block
)
{
out
.
printf
(
"
Block
(
null
)
"
)
;
return
;
}
out
.
printf
(
"
Block
"
)
;
if
(
showDetails
)
{
out
.
printf
(
"
.
"
)
;
DumpHashedPointer
(
out
block
)
;
out
.
printf
(
"
.
"
)
;
}
out
.
printf
(
"
%
u
"
block
-
>
id
(
)
)
;
#
endif
}
void
jit
:
:
DumpMIRBlock
(
GenericPrinter
&
out
MBasicBlock
*
block
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
out
.
printf
(
"
"
)
;
DumpMIRBlockID
(
out
block
showDetails
)
;
out
.
printf
(
"
-
-
preds
=
[
"
)
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
numPredecessors
(
)
;
i
+
+
)
{
MBasicBlock
*
pred
=
block
-
>
getPredecessor
(
i
)
;
out
.
printf
(
"
%
s
"
i
=
=
0
?
"
"
:
"
"
)
;
DumpMIRBlockID
(
out
pred
showDetails
)
;
}
out
.
printf
(
"
]
-
-
LD
=
%
u
-
-
K
=
%
s
-
-
s
-
w
-
phis
=
"
block
-
>
loopDepth
(
)
block
-
>
nameOfKind
(
)
)
;
if
(
block
-
>
successorWithPhis
(
)
)
{
DumpMIRBlockID
(
out
block
-
>
successorWithPhis
(
)
showDetails
)
;
out
.
printf
(
"
#
%
u
\
n
"
block
-
>
positionInPhiSuccessor
(
)
)
;
}
else
{
out
.
printf
(
"
(
null
)
\
n
"
)
;
}
for
(
MPhiIterator
iter
(
block
-
>
phisBegin
(
)
)
end
(
block
-
>
phisEnd
(
)
)
;
iter
!
=
end
;
iter
+
+
)
{
out
.
printf
(
"
"
)
;
jit
:
:
DumpMIRDefinition
(
out
*
iter
showDetails
)
;
out
.
printf
(
"
\
n
"
)
;
}
for
(
MInstructionIterator
iter
(
block
-
>
begin
(
)
)
end
(
block
-
>
end
(
)
)
;
iter
!
=
end
;
iter
+
+
)
{
out
.
printf
(
"
"
)
;
DumpMIRDefinition
(
out
*
iter
showDetails
)
;
out
.
printf
(
"
\
n
"
)
;
}
#
endif
}
void
jit
:
:
DumpMIRGraph
(
GenericPrinter
&
out
MIRGraph
&
graph
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
for
(
ReversePostorderIterator
block
(
graph
.
rpoBegin
(
)
)
;
block
!
=
graph
.
rpoEnd
(
)
;
block
+
+
)
{
DumpMIRBlock
(
out
*
block
showDetails
)
;
}
#
endif
}
void
jit
:
:
DumpMIRExpressions
(
GenericPrinter
&
out
MIRGraph
&
graph
const
CompileInfo
&
info
const
char
*
phase
bool
showDetails
)
{
#
ifdef
JS_JITSPEW
if
(
!
JitSpewEnabled
(
JitSpew_MIRExpressions
)
)
{
return
;
}
out
.
printf
(
"
=
=
=
=
=
%
s
=
=
=
=
=
\
n
"
phase
)
;
DumpMIRGraph
(
out
graph
showDetails
)
;
if
(
info
.
compilingWasm
(
)
)
{
out
.
printf
(
"
=
=
=
=
=
end
wasm
MIR
dump
=
=
=
=
=
\
n
"
)
;
}
else
{
out
.
printf
(
"
=
=
=
=
=
%
s
:
%
u
=
=
=
=
=
\
n
"
info
.
filename
(
)
info
.
lineno
(
)
)
;
}
#
endif
}
