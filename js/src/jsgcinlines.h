#
ifndef
jsgcinlines_h
#
define
jsgcinlines_h
#
include
"
jsgc
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
GCTrace
.
h
"
#
include
"
gc
/
Zone
.
h
"
namespace
js
{
namespace
gc
{
inline
void
MakeAccessibleAfterMovingGC
(
void
*
anyp
)
{
}
inline
void
MakeAccessibleAfterMovingGC
(
JSObject
*
obj
)
{
if
(
obj
-
>
isNative
(
)
)
obj
-
>
as
<
NativeObject
>
(
)
.
updateShapeAfterMovingGC
(
)
;
}
static
inline
AllocKind
GetGCObjectKind
(
const
Class
*
clasp
)
{
if
(
clasp
=
=
FunctionClassPtr
)
return
AllocKind
:
:
FUNCTION
;
uint32_t
nslots
=
JSCLASS_RESERVED_SLOTS
(
clasp
)
;
if
(
clasp
-
>
flags
&
JSCLASS_HAS_PRIVATE
)
nslots
+
+
;
return
GetGCObjectKind
(
nslots
)
;
}
inline
void
GCRuntime
:
:
poke
(
)
{
poked
=
true
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
Poke
)
)
nextScheduled
=
1
;
#
endif
}
class
ArenaIter
{
Arena
*
arena
;
Arena
*
unsweptArena
;
Arena
*
sweptArena
;
mozilla
:
:
DebugOnly
<
bool
>
initialized
;
public
:
ArenaIter
(
)
:
arena
(
nullptr
)
unsweptArena
(
nullptr
)
sweptArena
(
nullptr
)
initialized
(
false
)
{
}
ArenaIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
:
initialized
(
false
)
{
init
(
zone
kind
)
;
}
void
init
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
{
MOZ_ASSERT
(
!
initialized
)
;
MOZ_ASSERT
(
zone
)
;
initialized
=
true
;
arena
=
zone
-
>
arenas
.
getFirstArena
(
kind
)
;
unsweptArena
=
zone
-
>
arenas
.
getFirstArenaToSweep
(
kind
)
;
sweptArena
=
zone
-
>
arenas
.
getFirstSweptArena
(
kind
)
;
if
(
!
unsweptArena
)
{
unsweptArena
=
sweptArena
;
sweptArena
=
nullptr
;
}
if
(
!
arena
)
{
arena
=
unsweptArena
;
unsweptArena
=
sweptArena
;
sweptArena
=
nullptr
;
}
}
bool
done
(
)
const
{
MOZ_ASSERT
(
initialized
)
;
return
!
arena
;
}
Arena
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
arena
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
arena
=
arena
-
>
next
;
if
(
!
arena
)
{
arena
=
unsweptArena
;
unsweptArena
=
sweptArena
;
sweptArena
=
nullptr
;
}
}
}
;
enum
CellIterNeedsBarrier
:
uint8_t
{
CellIterDoesntNeedBarrier
=
0
CellIterMayNeedBarrier
=
1
}
;
class
ArenaCellIterImpl
{
size_t
firstThingOffset
;
size_t
thingSize
;
Arena
*
arenaAddr
;
FreeSpan
span
;
uint_fast16_t
thing
;
JS
:
:
TraceKind
traceKind
;
bool
needsBarrier
;
mozilla
:
:
DebugOnly
<
bool
>
initialized
;
void
moveForwardIfFree
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
thing
)
;
if
(
thing
=
=
span
.
first
)
{
thing
=
span
.
last
+
thingSize
;
span
=
*
span
.
nextSpan
(
arenaAddr
)
;
}
}
public
:
ArenaCellIterImpl
(
)
:
firstThingOffset
(
0
)
thingSize
(
0
)
arenaAddr
(
nullptr
)
thing
(
0
)
traceKind
(
JS
:
:
TraceKind
:
:
Null
)
needsBarrier
(
false
)
initialized
(
false
)
{
}
explicit
ArenaCellIterImpl
(
Arena
*
arena
CellIterNeedsBarrier
mayNeedBarrier
)
:
initialized
(
false
)
{
init
(
arena
mayNeedBarrier
)
;
}
void
init
(
Arena
*
arena
CellIterNeedsBarrier
mayNeedBarrier
)
{
MOZ_ASSERT
(
!
initialized
)
;
MOZ_ASSERT
(
arena
)
;
initialized
=
true
;
AllocKind
kind
=
arena
-
>
getAllocKind
(
)
;
firstThingOffset
=
Arena
:
:
firstThingOffset
(
kind
)
;
thingSize
=
Arena
:
:
thingSize
(
kind
)
;
traceKind
=
MapAllocToTraceKind
(
kind
)
;
needsBarrier
=
mayNeedBarrier
&
&
!
JS
:
:
CurrentThreadIsHeapCollecting
(
)
;
reset
(
arena
)
;
}
void
reset
(
Arena
*
arena
)
{
MOZ_ASSERT
(
initialized
)
;
MOZ_ASSERT
(
arena
)
;
arenaAddr
=
arena
;
span
=
*
arena
-
>
getFirstFreeSpan
(
)
;
thing
=
firstThingOffset
;
moveForwardIfFree
(
)
;
}
bool
done
(
)
const
{
MOZ_ASSERT
(
initialized
)
;
MOZ_ASSERT
(
thing
<
=
ArenaSize
)
;
return
thing
=
=
ArenaSize
;
}
TenuredCell
*
getCell
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
TenuredCell
*
cell
=
reinterpret_cast
<
TenuredCell
*
>
(
uintptr_t
(
arenaAddr
)
+
thing
)
;
if
(
needsBarrier
)
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
(
cell
traceKind
)
)
;
return
cell
;
}
template
<
typename
T
>
T
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
=
=
traceKind
)
;
return
static_cast
<
T
*
>
(
getCell
(
)
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
thing
+
=
thingSize
;
if
(
thing
<
ArenaSize
)
moveForwardIfFree
(
)
;
}
}
;
template
<
>
JSObject
*
ArenaCellIterImpl
:
:
get
<
JSObject
>
(
)
const
;
class
ArenaCellIter
:
public
ArenaCellIterImpl
{
public
:
explicit
ArenaCellIter
(
Arena
*
arena
)
:
ArenaCellIterImpl
(
arena
CellIterMayNeedBarrier
)
{
MOZ_ASSERT
(
JS
:
:
CurrentThreadIsHeapTracing
(
)
)
;
}
}
;
class
ArenaCellIterUnderGC
:
public
ArenaCellIterImpl
{
public
:
explicit
ArenaCellIterUnderGC
(
Arena
*
arena
)
:
ArenaCellIterImpl
(
arena
CellIterDoesntNeedBarrier
)
{
MOZ_ASSERT
(
CurrentThreadIsPerformingGC
(
)
)
;
}
}
;
class
ArenaCellIterUnderFinalize
:
public
ArenaCellIterImpl
{
public
:
explicit
ArenaCellIterUnderFinalize
(
Arena
*
arena
)
:
ArenaCellIterImpl
(
arena
CellIterDoesntNeedBarrier
)
{
MOZ_ASSERT
(
CurrentThreadIsGCSweeping
(
)
)
;
}
}
;
class
ArenaCellIterUnbarriered
:
public
ArenaCellIterImpl
{
public
:
explicit
ArenaCellIterUnbarriered
(
Arena
*
arena
)
:
ArenaCellIterImpl
(
arena
CellIterDoesntNeedBarrier
)
{
}
}
;
template
<
typename
T
>
class
ZoneCellIter
;
template
<
>
class
ZoneCellIter
<
TenuredCell
>
{
ArenaIter
arenaIter
;
ArenaCellIterImpl
cellIter
;
mozilla
:
:
Maybe
<
JS
:
:
AutoAssertNoGC
>
nogc
;
protected
:
ZoneCellIter
(
)
{
}
void
init
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
{
MOZ_ASSERT_IF
(
IsNurseryAllocable
(
kind
)
zone
-
>
isAtomsZone
(
)
|
|
zone
-
>
group
(
)
-
>
nursery
(
)
.
isEmpty
(
)
)
;
initForTenuredIteration
(
zone
kind
)
;
}
void
initForTenuredIteration
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
{
JSRuntime
*
rt
=
zone
-
>
runtimeFromAnyThread
(
)
;
if
(
!
JS
:
:
CurrentThreadIsHeapBusy
(
)
)
{
nogc
.
emplace
(
)
;
}
if
(
IsBackgroundFinalized
(
kind
)
&
&
zone
-
>
arenas
.
needBackgroundFinalizeWait
(
kind
)
)
rt
-
>
gc
.
waitBackgroundSweepEnd
(
)
;
arenaIter
.
init
(
zone
kind
)
;
if
(
!
arenaIter
.
done
(
)
)
cellIter
.
init
(
arenaIter
.
get
(
)
CellIterMayNeedBarrier
)
;
}
public
:
ZoneCellIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
{
if
(
IsNurseryAllocable
(
kind
)
)
zone
-
>
runtimeFromActiveCooperatingThread
(
)
-
>
gc
.
evictNursery
(
)
;
init
(
zone
kind
)
;
}
ZoneCellIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
const
js
:
:
gc
:
:
AutoAssertEmptyNursery
&
)
{
init
(
zone
kind
)
;
}
bool
done
(
)
const
{
return
arenaIter
.
done
(
)
;
}
template
<
typename
T
>
T
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
cellIter
.
get
<
T
>
(
)
;
}
TenuredCell
*
getCell
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
cellIter
.
getCell
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
cellIter
.
next
(
)
;
if
(
cellIter
.
done
(
)
)
{
MOZ_ASSERT
(
!
arenaIter
.
done
(
)
)
;
arenaIter
.
next
(
)
;
if
(
!
arenaIter
.
done
(
)
)
cellIter
.
reset
(
arenaIter
.
get
(
)
)
;
}
}
}
;
template
<
typename
GCType
>
class
ZoneCellIter
:
public
ZoneCellIter
<
TenuredCell
>
{
public
:
explicit
ZoneCellIter
(
JS
:
:
Zone
*
zone
)
:
ZoneCellIter
<
TenuredCell
>
(
)
{
init
(
zone
MapTypeToFinalizeKind
<
GCType
>
:
:
kind
)
;
}
ZoneCellIter
(
JS
:
:
Zone
*
zone
const
js
:
:
gc
:
:
AutoAssertEmptyNursery
&
)
:
ZoneCellIter
(
zone
)
{
}
ZoneCellIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
:
ZoneCellIter
<
TenuredCell
>
(
zone
kind
)
{
}
ZoneCellIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
const
js
:
:
gc
:
:
AutoAssertEmptyNursery
&
empty
)
:
ZoneCellIter
<
TenuredCell
>
(
zone
kind
empty
)
{
}
GCType
*
get
(
)
const
{
return
ZoneCellIter
<
TenuredCell
>
:
:
get
<
GCType
>
(
)
;
}
operator
GCType
*
(
)
const
{
return
get
(
)
;
}
GCType
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
GrayObjectIter
:
public
ZoneCellIter
<
TenuredCell
>
{
public
:
explicit
GrayObjectIter
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
:
ZoneCellIter
<
TenuredCell
>
(
)
{
initForTenuredIteration
(
zone
kind
)
;
}
JSObject
*
get
(
)
const
{
return
ZoneCellIter
<
TenuredCell
>
:
:
get
<
JSObject
>
(
)
;
}
operator
JSObject
*
(
)
const
{
return
get
(
)
;
}
JSObject
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
GCZonesIter
{
private
:
ZonesIter
zone
;
public
:
explicit
GCZonesIter
(
JSRuntime
*
rt
ZoneSelector
selector
=
WithAtoms
)
:
zone
(
rt
selector
)
{
MOZ_ASSERT
(
JS
:
:
CurrentThreadIsHeapBusy
(
)
)
;
if
(
!
zone
-
>
isCollectingFromAnyThread
(
)
)
next
(
)
;
}
bool
done
(
)
const
{
return
zone
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
do
{
zone
.
next
(
)
;
}
while
(
!
zone
.
done
(
)
&
&
!
zone
-
>
isCollectingFromAnyThread
(
)
)
;
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
zone
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
CompartmentsIterT
<
GCZonesIter
>
GCCompartmentsIter
;
class
GCSweepGroupIter
{
private
:
JS
:
:
Zone
*
current
;
public
:
explicit
GCSweepGroupIter
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
CurrentThreadIsPerformingGC
(
)
)
;
current
=
rt
-
>
gc
.
getCurrentSweepGroup
(
)
;
}
bool
done
(
)
const
{
return
!
current
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
current
=
current
-
>
nextNodeInGroup
(
)
;
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
current
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
CompartmentsIterT
<
GCSweepGroupIter
>
GCCompartmentGroupIter
;
inline
void
RelocationOverlay
:
:
forwardTo
(
Cell
*
cell
)
{
MOZ_ASSERT
(
!
isForwarded
(
)
)
;
static_assert
(
offsetof
(
RelocationOverlay
magic_
)
=
=
offsetof
(
JSObject
group_
)
&
&
offsetof
(
RelocationOverlay
magic_
)
=
=
offsetof
(
js
:
:
Shape
base_
)
&
&
offsetof
(
RelocationOverlay
magic_
)
=
=
offsetof
(
JSString
d
.
u1
.
flags
)
"
RelocationOverlay
:
:
magic_
is
in
the
wrong
location
"
)
;
magic_
=
Relocated
;
newLocation_
=
cell
;
}
template
<
typename
T
>
struct
MightBeForwarded
{
static_assert
(
mozilla
:
:
IsBaseOf
<
Cell
T
>
:
:
value
"
T
must
derive
from
Cell
"
)
;
static_assert
(
!
mozilla
:
:
IsSame
<
Cell
T
>
:
:
value
&
&
!
mozilla
:
:
IsSame
<
TenuredCell
T
>
:
:
value
"
T
must
not
be
Cell
or
TenuredCell
"
)
;
static
const
bool
value
=
mozilla
:
:
IsBaseOf
<
JSObject
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
Shape
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
BaseShape
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
JSString
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
JSScript
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
js
:
:
LazyScript
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
js
:
:
Scope
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
js
:
:
RegExpShared
T
>
:
:
value
;
}
;
template
<
typename
T
>
inline
bool
IsForwarded
(
T
*
t
)
{
RelocationOverlay
*
overlay
=
RelocationOverlay
:
:
fromCell
(
t
)
;
if
(
!
MightBeForwarded
<
T
>
:
:
value
)
{
MOZ_ASSERT
(
!
overlay
-
>
isForwarded
(
)
)
;
return
false
;
}
return
overlay
-
>
isForwarded
(
)
;
}
struct
IsForwardedFunctor
:
public
BoolDefaultAdaptor
<
Value
false
>
{
template
<
typename
T
>
bool
operator
(
)
(
T
*
t
)
{
return
IsForwarded
(
t
)
;
}
}
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
{
return
DispatchTyped
(
IsForwardedFunctor
(
)
value
)
;
}
template
<
typename
T
>
inline
T
*
Forwarded
(
T
*
t
)
{
RelocationOverlay
*
overlay
=
RelocationOverlay
:
:
fromCell
(
t
)
;
MOZ_ASSERT
(
overlay
-
>
isForwarded
(
)
)
;
return
reinterpret_cast
<
T
*
>
(
overlay
-
>
forwardingAddress
(
)
)
;
}
struct
ForwardedFunctor
:
public
IdentityDefaultAdaptor
<
Value
>
{
template
<
typename
T
>
inline
Value
operator
(
)
(
T
*
t
)
{
return
js
:
:
gc
:
:
RewrapTaggedPointer
<
Value
T
>
:
:
wrap
(
Forwarded
(
t
)
)
;
}
}
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
{
return
DispatchTyped
(
ForwardedFunctor
(
)
value
)
;
}
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
{
if
(
IsForwarded
(
t
)
)
t
=
Forwarded
(
t
)
;
MakeAccessibleAfterMovingGC
(
t
)
;
return
t
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
{
return
!
IsInsideNursery
(
t
)
&
&
!
RelocationOverlay
:
:
isCellForwarded
(
t
)
;
}
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
{
if
(
t
)
MOZ_RELEASE_ASSERT
(
IsGCThingValidAfterMovingGC
(
t
)
)
;
}
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
{
CheckGCThingAfterMovingGC
(
t
.
unbarrieredGet
(
)
)
;
}
struct
CheckValueAfterMovingGCFunctor
:
public
VoidDefaultAdaptor
<
Value
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
{
CheckGCThingAfterMovingGC
(
t
)
;
}
}
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
{
DispatchTyped
(
CheckValueAfterMovingGCFunctor
(
)
value
)
;
}
#
endif
}
}
#
endif
