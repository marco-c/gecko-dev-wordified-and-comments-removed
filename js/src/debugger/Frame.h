#
ifndef
debugger_Frame_h
#
define
debugger_Frame_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
debugger
/
Debugger
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
vm
/
FrameIter
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
class
AbstractGeneratorObject
;
class
GlobalObject
;
struct
OnStepHandler
:
Handler
{
virtual
bool
onStep
(
JSContext
*
cx
HandleDebuggerFrame
frame
ResumeMode
&
resumeMode
MutableHandleValue
vp
)
=
0
;
}
;
class
ScriptedOnStepHandler
final
:
public
OnStepHandler
{
public
:
explicit
ScriptedOnStepHandler
(
JSObject
*
object
)
;
virtual
JSObject
*
object
(
)
const
override
;
virtual
void
hold
(
JSObject
*
owner
)
override
;
virtual
void
drop
(
JSFreeOp
*
fop
JSObject
*
owner
)
override
;
virtual
void
trace
(
JSTracer
*
tracer
)
override
;
virtual
size_t
allocSize
(
)
const
override
;
virtual
bool
onStep
(
JSContext
*
cx
HandleDebuggerFrame
frame
ResumeMode
&
resumeMode
MutableHandleValue
vp
)
override
;
private
:
const
HeapPtr
<
JSObject
*
>
object_
;
}
;
struct
OnPopHandler
:
Handler
{
virtual
bool
onPop
(
JSContext
*
cx
HandleDebuggerFrame
frame
const
Completion
&
completion
ResumeMode
&
resumeMode
MutableHandleValue
vp
)
=
0
;
}
;
class
ScriptedOnPopHandler
final
:
public
OnPopHandler
{
public
:
explicit
ScriptedOnPopHandler
(
JSObject
*
object
)
;
virtual
JSObject
*
object
(
)
const
override
;
virtual
void
hold
(
JSObject
*
owner
)
override
;
virtual
void
drop
(
JSFreeOp
*
fop
JSObject
*
owner
)
override
;
virtual
void
trace
(
JSTracer
*
tracer
)
override
;
virtual
size_t
allocSize
(
)
const
override
;
virtual
bool
onPop
(
JSContext
*
cx
HandleDebuggerFrame
frame
const
Completion
&
completion
ResumeMode
&
resumeMode
MutableHandleValue
vp
)
override
;
private
:
const
HeapPtr
<
JSObject
*
>
object_
;
}
;
enum
class
DebuggerFrameType
{
Eval
Global
Call
Module
WasmCall
}
;
enum
class
DebuggerFrameImplementation
{
Interpreter
Baseline
Ion
Wasm
}
;
class
DebuggerArguments
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
DebuggerArguments
*
create
(
JSContext
*
cx
HandleObject
proto
HandleDebuggerFrame
frame
)
;
private
:
enum
{
FRAME_SLOT
}
;
static
const
unsigned
RESERVED_SLOTS
=
1
;
}
;
class
DebuggerFrame
:
public
NativeObject
{
friend
class
DebuggerArguments
;
friend
class
ScriptedOnStepHandler
;
friend
class
ScriptedOnPopHandler
;
public
:
static
const
JSClass
class_
;
enum
{
OWNER_SLOT
=
0
ARGUMENTS_SLOT
ONSTEP_HANDLER_SLOT
ONPOP_HANDLER_SLOT
GENERATOR_INFO_SLOT
RESERVED_SLOTS
}
;
void
trace
(
JSTracer
*
trc
)
;
static
NativeObject
*
initClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleObject
dbgCtor
)
;
static
DebuggerFrame
*
create
(
JSContext
*
cx
HandleObject
proto
HandleNativeObject
debugger
const
FrameIter
*
maybeIter
Handle
<
AbstractGeneratorObject
*
>
maybeGenerator
)
;
static
MOZ_MUST_USE
bool
getArguments
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleDebuggerArguments
result
)
;
static
MOZ_MUST_USE
bool
getCallee
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleDebuggerObject
result
)
;
static
MOZ_MUST_USE
bool
getIsConstructing
(
JSContext
*
cx
HandleDebuggerFrame
frame
bool
&
result
)
;
static
MOZ_MUST_USE
bool
getEnvironment
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleDebuggerEnvironment
result
)
;
static
MOZ_MUST_USE
bool
getOffset
(
JSContext
*
cx
HandleDebuggerFrame
frame
size_t
&
result
)
;
static
MOZ_MUST_USE
bool
getOlder
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleDebuggerFrame
result
)
;
static
MOZ_MUST_USE
bool
getAsyncPromise
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleDebuggerObject
result
)
;
static
MOZ_MUST_USE
bool
getOlderSavedFrame
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleSavedFrame
result
)
;
static
MOZ_MUST_USE
bool
getThis
(
JSContext
*
cx
HandleDebuggerFrame
frame
MutableHandleValue
result
)
;
static
DebuggerFrameType
getType
(
HandleDebuggerFrame
frame
)
;
static
DebuggerFrameImplementation
getImplementation
(
HandleDebuggerFrame
frame
)
;
static
MOZ_MUST_USE
bool
setOnStepHandler
(
JSContext
*
cx
HandleDebuggerFrame
frame
OnStepHandler
*
handler
)
;
static
MOZ_MUST_USE
JS
:
:
Result
<
Completion
>
eval
(
JSContext
*
cx
HandleDebuggerFrame
frame
mozilla
:
:
Range
<
const
char16_t
>
chars
HandleObject
bindings
const
EvalOptions
&
options
)
;
static
MOZ_MUST_USE
DebuggerFrame
*
check
(
JSContext
*
cx
HandleValue
thisv
)
;
bool
isOnStack
(
)
const
;
bool
isOnStackMaybeForwarded
(
)
const
;
bool
isSuspended
(
)
const
;
OnStepHandler
*
onStepHandler
(
)
const
;
OnPopHandler
*
onPopHandler
(
)
const
;
void
setOnPopHandler
(
JSContext
*
cx
OnPopHandler
*
handler
)
;
inline
bool
hasGeneratorInfo
(
)
const
;
AbstractGeneratorObject
&
unwrappedGenerator
(
)
const
;
#
ifdef
DEBUG
JSScript
*
generatorScript
(
)
const
;
#
endif
[
[
nodiscard
]
]
bool
setGeneratorInfo
(
JSContext
*
cx
Handle
<
AbstractGeneratorObject
*
>
genObj
)
;
void
clearGeneratorInfo
(
JSFreeOp
*
fop
)
;
bool
resume
(
const
FrameIter
&
iter
)
;
bool
hasAnyHooks
(
)
const
;
bool
isInstance
(
)
const
;
Debugger
*
owner
(
)
const
;
private
:
static
const
JSClassOps
classOps_
;
static
const
JSPropertySpec
properties_
[
]
;
static
const
JSFunctionSpec
methods_
[
]
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
AbstractFramePtr
getReferent
(
HandleDebuggerFrame
frame
)
;
static
MOZ_MUST_USE
bool
requireScriptReferent
(
JSContext
*
cx
HandleDebuggerFrame
frame
)
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
struct
CallData
;
[
[
nodiscard
]
]
bool
incrementStepperCounter
(
JSContext
*
cx
AbstractFramePtr
referent
)
;
[
[
nodiscard
]
]
bool
incrementStepperCounter
(
JSContext
*
cx
JSScript
*
script
)
;
void
decrementStepperCounter
(
JSFreeOp
*
fop
JSScript
*
script
)
;
void
decrementStepperCounter
(
JSFreeOp
*
fop
AbstractFramePtr
referent
)
;
FrameIter
:
:
Data
*
frameIterData
(
)
const
;
void
setFrameIterData
(
FrameIter
:
:
Data
*
)
;
void
freeFrameIterData
(
JSFreeOp
*
fop
)
;
public
:
FrameIter
getFrameIter
(
JSContext
*
cx
)
;
void
terminate
(
JSFreeOp
*
fop
AbstractFramePtr
frame
)
;
void
suspend
(
JSFreeOp
*
fop
)
;
[
[
nodiscard
]
]
bool
replaceFrameIterData
(
JSContext
*
cx
const
FrameIter
&
)
;
class
GeneratorInfo
;
inline
GeneratorInfo
*
generatorInfo
(
)
const
;
}
;
}
#
endif
