#
ifndef
debugger_ExecutionTracer_h
#
define
debugger_ExecutionTracer_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
limits
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
enum
class
OutOfLineEntryType
:
uint8_t
{
ScriptURL
Atom
Shape
}
;
enum
class
InlineEntryType
:
uint8_t
{
StackFunctionEnter
StackFunctionLeave
LabelEnter
LabelLeave
Error
}
;
enum
class
PropertyKeyKind
:
uint8_t
{
Undefined
String
Int
Symbol
}
;
using
TracingScratchBuffer
=
mozilla
:
:
Vector
<
char
512
>
;
template
<
size_t
BUFFER_SIZE
>
class
TracingBuffer
{
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
BUFFER_SIZE
)
)
;
static
const
size_t
BUFFER_MASK
=
BUFFER_SIZE
-
1
;
static
const
size_t
ENTRY_HEADER_SIZE
=
sizeof
(
uint16_t
)
;
uint8_t
*
buffer_
=
nullptr
;
uint64_t
writeHead_
=
0
;
uint64_t
readHead_
=
0
;
uint64_t
uncommittedWriteHead_
=
0
;
uint64_t
uncommittedReadHead_
=
0
;
bool
ensureScratchBufferSize
(
TracingScratchBuffer
&
scratchBuffer
size_t
requiredSize
)
{
if
(
scratchBuffer
.
length
(
)
>
=
requiredSize
)
{
return
true
;
}
return
scratchBuffer
.
growByUninitialized
(
requiredSize
-
scratchBuffer
.
length
(
)
)
;
}
public
:
static
const
size_t
SIZE
=
BUFFER_SIZE
;
~
TracingBuffer
(
)
{
if
(
buffer_
)
{
js_free
(
buffer_
)
;
}
}
bool
init
(
)
{
buffer_
=
static_cast
<
uint8_t
*
>
(
js_malloc
(
BUFFER_SIZE
)
)
;
return
buffer_
!
=
nullptr
;
}
bool
readable
(
)
{
return
writeHead_
>
readHead_
;
}
uint64_t
uncommittedWriteHead
(
)
{
return
uncommittedWriteHead_
;
}
uint64_t
readHead
(
)
{
return
readHead_
;
}
void
beginWritingEntry
(
)
{
MOZ_ASSERT
(
uncommittedWriteHead_
>
=
writeHead_
)
;
uncommittedWriteHead_
=
writeHead_
;
uncommittedWriteHead_
+
=
ENTRY_HEADER_SIZE
;
}
void
finishWritingEntry
(
)
{
MOZ_RELEASE_ASSERT
(
uncommittedWriteHead_
-
writeHead_
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
uint16_t
entryHeader
=
uint16_t
(
uncommittedWriteHead_
-
writeHead_
)
;
writeBytesAtOffset
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
writeHead_
)
;
writeHead_
=
uncommittedWriteHead_
;
}
void
beginReadingEntry
(
)
{
MOZ_ASSERT
(
uncommittedReadHead_
=
=
readHead_
)
;
uncommittedReadHead_
+
=
ENTRY_HEADER_SIZE
;
}
void
finishReadingEntry
(
)
{
uint16_t
entryHeader
;
readBytesAtOffset
(
reinterpret_cast
<
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
readHead_
)
;
size_t
read
=
uncommittedReadHead_
-
readHead_
;
MOZ_RELEASE_ASSERT
(
entryHeader
=
=
uint16_t
(
read
)
)
;
readHead_
+
=
entryHeader
;
uncommittedReadHead_
=
readHead_
;
}
void
skipEntry
(
)
{
uint16_t
entryHeader
;
readBytesAtOffset
(
reinterpret_cast
<
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
readHead_
)
;
readHead_
+
=
entryHeader
;
uncommittedReadHead_
=
readHead_
;
}
void
writeBytesAtOffset
(
const
uint8_t
*
bytes
size_t
length
uint64_t
offset
)
{
MOZ_ASSERT
(
offset
+
length
<
=
readHead_
+
BUFFER_SIZE
)
;
size_t
maskedWriteHead
=
offset
&
BUFFER_MASK
;
if
(
maskedWriteHead
+
length
>
BUFFER_SIZE
)
{
size_t
firstChunk
=
BUFFER_SIZE
-
maskedWriteHead
;
memcpy
(
buffer_
+
maskedWriteHead
bytes
firstChunk
)
;
memcpy
(
buffer_
bytes
+
firstChunk
length
-
firstChunk
)
;
}
else
{
memcpy
(
buffer_
+
maskedWriteHead
bytes
length
)
;
}
}
void
writeBytes
(
const
uint8_t
*
bytes
size_t
length
)
{
while
(
MOZ_UNLIKELY
(
uncommittedWriteHead_
+
length
>
readHead_
+
BUFFER_SIZE
)
)
{
skipEntry
(
)
;
}
writeBytesAtOffset
(
bytes
length
uncommittedWriteHead_
)
;
uncommittedWriteHead_
+
=
length
;
}
template
<
typename
T
>
void
write
(
T
val
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
T
>
)
;
if
constexpr
(
sizeof
(
T
)
>
1
)
{
val
=
mozilla
:
:
NativeEndian
:
:
swapToLittleEndian
(
val
)
;
}
writeBytes
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
val
)
sizeof
(
T
)
)
;
}
template
<
typename
T
>
void
writeAtOffset
(
T
val
uint64_t
offset
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
T
>
)
;
if
constexpr
(
sizeof
(
T
)
>
1
)
{
val
=
mozilla
:
:
NativeEndian
:
:
swapToLittleEndian
(
val
)
;
}
writeBytesAtOffset
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
val
)
sizeof
(
T
)
offset
)
;
}
void
writeEmptyString
(
)
{
write
(
uint8_t
(
JS
:
:
TracerStringEncoding
:
:
Latin1
)
)
;
write
(
uint32_t
(
0
)
)
;
}
void
writeEmptySmallString
(
)
{
write
(
uint16_t
(
0
)
)
;
}
enum
class
InlineStringEncoding
{
No
Yes
}
;
template
<
typename
LengthType
=
uint32_t
InlineStringEncoding
InlineEncoding
=
InlineStringEncoding
:
:
No
>
void
writeAdjustedLengthAndEncoding
(
size_t
*
length
JS
:
:
TracerStringEncoding
encoding
size_t
lengthLimit
=
std
:
:
numeric_limits
<
LengthType
>
:
:
max
(
)
)
{
if
(
*
length
>
lengthLimit
)
{
*
length
=
lengthLimit
;
}
if
constexpr
(
InlineEncoding
=
=
InlineStringEncoding
:
:
No
)
{
write
(
uint8_t
(
encoding
)
)
;
write
(
LengthType
(
*
length
)
)
;
}
else
{
constexpr
LengthType
encodingBits
=
2
;
LengthType
typedLength
=
LengthType
(
*
length
)
|
(
uint16_t
(
encoding
)
<
<
(
sizeof
(
LengthType
)
*
8
-
encodingBits
)
)
;
write
(
typedLength
)
;
}
}
template
<
typename
LengthType
=
uint32_t
InlineStringEncoding
InlineEncoding
=
InlineStringEncoding
:
:
No
>
bool
writeString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
size_t
lengthLimit
=
std
:
:
numeric_limits
<
LengthType
>
:
:
max
(
)
)
{
JS
:
:
TracerStringEncoding
encoding
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
encoding
=
JS
:
:
TracerStringEncoding
:
:
Latin1
;
}
else
{
encoding
=
JS
:
:
TracerStringEncoding
:
:
TwoByte
;
}
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
size_t
length
=
linear
-
>
length
(
)
;
writeAdjustedLengthAndEncoding
<
LengthType
InlineEncoding
>
(
&
length
encoding
lengthLimit
)
;
size_t
size
=
length
;
JS
:
:
AutoAssertNoGC
nogc
;
const
uint8_t
*
charBuffer
=
nullptr
;
if
(
encoding
=
=
JS
:
:
TracerStringEncoding
:
:
TwoByte
)
{
size
*
=
sizeof
(
char16_t
)
;
charBuffer
=
reinterpret_cast
<
const
uint8_t
*
>
(
linear
-
>
twoByteChars
(
nogc
)
)
;
}
else
{
charBuffer
=
reinterpret_cast
<
const
uint8_t
*
>
(
linear
-
>
latin1Chars
(
nogc
)
)
;
}
writeBytes
(
charBuffer
size
)
;
return
true
;
}
template
<
typename
CharType
JS
:
:
TracerStringEncoding
Encoding
typename
LengthType
=
uint32_t
InlineStringEncoding
InlineEncoding
=
InlineStringEncoding
:
:
No
>
void
writeCString
(
const
CharType
*
chars
size_t
lengthLimit
=
std
:
:
numeric_limits
<
LengthType
>
:
:
max
(
)
)
{
size_t
length
=
std
:
:
char_traits
<
CharType
>
:
:
length
(
chars
)
;
static_assert
(
sizeof
(
CharType
)
=
=
1
|
|
Encoding
=
=
JS
:
:
TracerStringEncoding
:
:
TwoByte
)
;
static_assert
(
sizeof
(
CharType
)
<
=
2
)
;
writeAdjustedLengthAndEncoding
<
LengthType
InlineEncoding
>
(
&
length
Encoding
lengthLimit
)
;
const
size_t
size
=
length
*
sizeof
(
CharType
)
;
writeBytes
(
reinterpret_cast
<
const
uint8_t
*
>
(
chars
)
size
)
;
}
bool
writeSmallString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
)
{
return
writeString
<
uint16_t
InlineStringEncoding
:
:
Yes
>
(
cx
str
JS
:
:
ValueSummary
:
:
SMALL_STRING_LENGTH_LIMIT
)
;
}
template
<
typename
CharType
JS
:
:
TracerStringEncoding
Encoding
>
void
writeSmallCString
(
const
CharType
*
chars
)
{
writeCString
<
CharType
Encoding
char16_t
InlineStringEncoding
:
:
Yes
>
(
chars
JS
:
:
ValueSummary
:
:
SMALL_STRING_LENGTH_LIMIT
)
;
}
void
readBytesAtOffset
(
uint8_t
*
bytes
size_t
length
uint64_t
offset
)
{
size_t
maskedReadHead
=
offset
&
BUFFER_MASK
;
if
(
maskedReadHead
+
length
>
BUFFER_SIZE
)
{
size_t
firstChunk
=
BUFFER_SIZE
-
maskedReadHead
;
memcpy
(
bytes
buffer_
+
maskedReadHead
firstChunk
)
;
memcpy
(
bytes
+
firstChunk
buffer_
length
-
firstChunk
)
;
}
else
{
memcpy
(
bytes
buffer_
+
maskedReadHead
length
)
;
}
}
void
readBytes
(
uint8_t
*
bytes
size_t
length
)
{
readBytesAtOffset
(
bytes
length
uncommittedReadHead_
)
;
uncommittedReadHead_
+
=
length
;
}
template
<
typename
T
>
void
read
(
T
*
val
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
T
>
)
;
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
val
)
sizeof
(
T
)
)
;
if
constexpr
(
sizeof
(
T
)
>
1
)
{
*
val
=
mozilla
:
:
NativeEndian
:
:
swapFromLittleEndian
(
*
val
)
;
}
}
template
<
typename
LengthType
=
uint32_t
InlineStringEncoding
InlineEncoding
=
InlineStringEncoding
:
:
No
>
bool
readString
(
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
size_t
*
index
)
{
uint8_t
encodingByte
;
LengthType
length
;
if
constexpr
(
InlineEncoding
=
=
InlineStringEncoding
:
:
Yes
)
{
LengthType
lengthAndEncoding
;
read
(
&
lengthAndEncoding
)
;
constexpr
LengthType
encodingBits
=
2
;
constexpr
LengthType
encodingShift
=
sizeof
(
LengthType
)
*
8
-
encodingBits
;
constexpr
LengthType
encodingMask
=
0b11
<
<
encodingShift
;
length
=
lengthAndEncoding
&
~
encodingMask
;
encodingByte
=
(
lengthAndEncoding
&
encodingMask
)
>
>
encodingShift
;
}
else
{
read
(
&
encodingByte
)
;
read
(
&
length
)
;
}
JS
:
:
TracerStringEncoding
encoding
=
JS
:
:
TracerStringEncoding
(
encodingByte
)
;
*
index
=
stringBuffer
.
length
(
)
;
if
(
length
=
=
0
)
{
if
(
!
stringBuffer
.
append
(
'
\
0
'
)
)
{
return
false
;
}
return
true
;
}
if
(
encoding
=
=
JS
:
:
TracerStringEncoding
:
:
UTF8
)
{
size_t
reserveLength
=
length
+
1
;
if
(
!
stringBuffer
.
growByUninitialized
(
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
-
reserveLength
;
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
writePtr
)
length
)
;
writePtr
[
length
]
=
'
\
0
'
;
}
else
if
(
encoding
=
=
JS
:
:
TracerStringEncoding
:
:
Latin1
)
{
if
(
!
ensureScratchBufferSize
(
scratchBuffer
length
)
)
{
return
false
;
}
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
)
;
size_t
reserveLength
=
length
*
2
+
1
;
if
(
!
stringBuffer
.
reserve
(
stringBuffer
.
length
(
)
+
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
;
size_t
convertedLength
=
mozilla
:
:
ConvertLatin1toUtf8
(
mozilla
:
:
Span
<
const
char
>
(
scratchBuffer
.
begin
(
)
length
)
mozilla
:
:
Span
<
char
>
(
writePtr
reserveLength
)
)
;
writePtr
[
convertedLength
]
=
0
;
if
(
!
stringBuffer
.
growByUninitialized
(
convertedLength
+
1
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
encoding
=
=
JS
:
:
TracerStringEncoding
:
:
TwoByte
)
;
if
(
!
ensureScratchBufferSize
(
scratchBuffer
length
*
sizeof
(
char16_t
)
)
)
{
return
false
;
}
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
*
sizeof
(
char16_t
)
)
;
size_t
reserveLength
=
length
*
3
+
1
;
if
(
!
stringBuffer
.
reserve
(
stringBuffer
.
length
(
)
+
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
;
size_t
convertedLength
=
mozilla
:
:
ConvertUtf16toUtf8
(
mozilla
:
:
Span
<
const
char16_t
>
(
reinterpret_cast
<
char16_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
)
mozilla
:
:
Span
<
char
>
(
writePtr
reserveLength
)
)
;
writePtr
[
convertedLength
]
=
0
;
if
(
!
stringBuffer
.
growByUninitialized
(
convertedLength
+
1
)
)
{
return
false
;
}
}
return
true
;
}
bool
readSmallString
(
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
size_t
*
index
)
{
return
readString
<
uint16_t
InlineStringEncoding
:
:
Yes
>
(
scratchBuffer
stringBuffer
index
)
;
}
}
;
using
InlineDataBuffer
=
TracingBuffer
<
1
<
<
28
>
;
using
ValueDataBuffer
=
InlineDataBuffer
;
using
OutOfLineDataBuffer
=
TracingBuffer
<
1
<
<
22
>
;
class
ValueSummaries
{
ValueDataBuffer
*
valueData_
=
nullptr
;
OutOfLineDataBuffer
*
outOfLineData_
=
nullptr
;
friend
struct
:
:
JS_TracerSummaryWriter
;
public
:
enum
class
IsNested
{
No
Yes
}
;
void
init
(
ValueDataBuffer
*
valueData
OutOfLineDataBuffer
*
outOfLineData
)
{
valueData_
=
valueData
;
outOfLineData_
=
outOfLineData
;
}
bool
writeValue
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
val
IsNested
nested
)
;
bool
writeArguments
(
JSContext
*
cx
AbstractFramePtr
frame
uint64_t
*
valueBufferIndex
)
;
bool
populateOutputBuffer
(
JS
:
:
ExecutionTrace
:
:
TracedJSContext
&
context
)
;
int32_t
getOutputBufferIndex
(
uint64_t
ringBufferIndex
)
;
void
writeHeader
(
JS
:
:
ValueType
type
uint8_t
flags
)
;
bool
writeShapeSummary
(
JSContext
*
cx
JS
:
:
Handle
<
NativeShape
*
>
shape
)
;
bool
writeMinimalShapeSummary
(
JSContext
*
cx
JS
:
:
Handle
<
Shape
*
>
shape
)
;
void
writeObjectHeader
(
JS
:
:
ObjectSummary
:
:
Kind
kind
uint8_t
flags
)
;
bool
writeObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
IsNested
nested
)
;
bool
writeFunctionSummary
(
JSContext
*
cx
JS
:
:
Handle
<
JSFunction
*
>
fn
IsNested
nested
)
;
bool
writeArrayObjectSummary
(
JSContext
*
cx
JS
:
:
Handle
<
ArrayObject
*
>
array
IsNested
nested
)
;
bool
writeSetObjectSummary
(
JSContext
*
cx
JS
:
:
Handle
<
SetObject
*
>
set
IsNested
nested
)
;
bool
writeMapObjectSummary
(
JSContext
*
cx
JS
:
:
Handle
<
MapObject
*
>
set
IsNested
nested
)
;
bool
writeGenericOrWrappedPrimitiveObjectSummary
(
JSContext
*
cx
JS
:
:
Handle
<
NativeObject
*
>
nobj
IsNested
nested
)
;
bool
writeExternalObjectSummary
(
JSContext
*
cx
JS
:
:
Handle
<
NativeObject
*
>
nobj
IsNested
nested
)
;
bool
writeStringLikeValue
(
JSContext
*
cx
JS
:
:
ValueType
valueType
JS
:
:
Handle
<
JSString
*
>
str
)
;
}
;
class
ExecutionTracer
{
private
:
static
Mutex
globalInstanceLock
MOZ_UNANNOTATED
;
static
mozilla
:
:
Vector
<
ExecutionTracer
*
>
globalInstances
;
Mutex
bufferLock_
MOZ_UNANNOTATED
;
InlineDataBuffer
inlineData_
;
OutOfLineDataBuffer
outOfLineData_
;
ValueDataBuffer
valueData_
;
mozilla
:
:
baseprofiler
:
:
BaseProfilerThreadId
threadId_
;
ValueSummaries
valueSummaries_
;
void
handleError
(
JSContext
*
cx
)
;
void
writeScriptUrl
(
ScriptSource
*
scriptSource
)
;
bool
writeAtom
(
JSContext
*
cx
JS
:
:
Handle
<
JSAtom
*
>
atom
uint32_t
id
)
;
bool
writeFunctionFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
bool
readFunctionFrame
(
JS
:
:
ExecutionTrace
:
:
EventKind
kind
JS
:
:
ExecutionTrace
:
:
TracedEvent
&
event
)
;
bool
readLabel
(
JS
:
:
ExecutionTrace
:
:
EventKind
kind
JS
:
:
ExecutionTrace
:
:
TracedEvent
&
event
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readInlineEntry
(
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
TracedEvent
>
&
events
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readOutOfLineEntry
(
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
scriptUrls
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
atoms
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
ShapeSummary
>
&
shapes
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readInlineEntries
(
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
TracedEvent
>
&
events
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readOutOfLineEntries
(
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
scriptUrls
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
atoms
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
ShapeSummary
>
&
shapes
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
public
:
ExecutionTracer
(
)
:
bufferLock_
(
mutexid
:
:
ExecutionTracerInstanceLock
)
{
}
~
ExecutionTracer
(
)
{
LockGuard
<
Mutex
>
guard
(
globalInstanceLock
)
;
globalInstances
.
eraseIfEqual
(
this
)
;
}
mozilla
:
:
baseprofiler
:
:
BaseProfilerThreadId
threadId
(
)
const
{
return
threadId_
;
}
bool
init
(
)
{
LockGuard
<
Mutex
>
guard
(
globalInstanceLock
)
;
LockGuard
<
Mutex
>
guard2
(
bufferLock_
)
;
threadId_
=
mozilla
:
:
baseprofiler
:
:
profiler_current_thread_id
(
)
;
if
(
!
inlineData_
.
init
(
)
)
{
return
false
;
}
if
(
!
outOfLineData_
.
init
(
)
)
{
return
false
;
}
if
(
!
valueData_
.
init
(
)
)
{
return
false
;
}
if
(
!
globalInstances
.
append
(
this
)
)
{
return
false
;
}
valueSummaries_
.
init
(
&
valueData_
&
outOfLineData_
)
;
return
true
;
}
void
onEnterFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
void
onLeaveFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
template
<
typename
CharType
JS
:
:
TracerStringEncoding
Encoding
>
void
onEnterLabel
(
const
CharType
*
eventType
)
;
template
<
typename
CharType
JS
:
:
TracerStringEncoding
Encoding
>
void
onLeaveLabel
(
const
CharType
*
eventType
)
;
bool
getNativeTrace
(
JS
:
:
ExecutionTrace
:
:
TracedJSContext
&
context
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
static
bool
getNativeTraceForAllContexts
(
JS
:
:
ExecutionTrace
&
trace
)
;
}
;
}
#
endif
