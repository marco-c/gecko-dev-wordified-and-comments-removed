#
ifndef
debugger_ExecutionTracer_h
#
define
debugger_ExecutionTracer_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
limits
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
enum
class
TracerStringEncoding
{
Latin1
TwoByte
UTF8
}
;
using
TracingScratchBuffer
=
mozilla
:
:
Vector
<
char
512
>
;
template
<
size_t
BUFFER_SIZE
>
class
TracingBuffer
{
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
BUFFER_SIZE
)
)
;
static
const
size_t
BUFFER_MASK
=
BUFFER_SIZE
-
1
;
static
const
size_t
ENTRY_HEADER_SIZE
=
sizeof
(
uint16_t
)
;
uint8_t
*
buffer_
=
nullptr
;
uint64_t
writeHead_
=
0
;
uint64_t
readHead_
=
0
;
uint64_t
uncommittedWriteHead_
=
0
;
uint64_t
uncommittedReadHead_
=
0
;
bool
ensureScratchBufferSize
(
TracingScratchBuffer
&
scratchBuffer
size_t
requiredSize
)
{
if
(
scratchBuffer
.
length
(
)
>
=
requiredSize
)
{
return
true
;
}
return
scratchBuffer
.
growByUninitialized
(
requiredSize
-
scratchBuffer
.
length
(
)
)
;
}
public
:
~
TracingBuffer
(
)
{
if
(
buffer_
)
{
js_free
(
buffer_
)
;
}
}
bool
init
(
)
{
buffer_
=
static_cast
<
uint8_t
*
>
(
js_malloc
(
BUFFER_SIZE
)
)
;
return
buffer_
!
=
nullptr
;
}
bool
readable
(
)
{
return
writeHead_
>
readHead_
;
}
void
beginWritingEntry
(
)
{
MOZ_ASSERT
(
uncommittedWriteHead_
>
=
writeHead_
)
;
uncommittedWriteHead_
=
writeHead_
;
uncommittedWriteHead_
+
=
ENTRY_HEADER_SIZE
;
}
void
finishWritingEntry
(
)
{
MOZ_ASSERT
(
uncommittedWriteHead_
-
writeHead_
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
uint16_t
entryHeader
=
uint16_t
(
uncommittedWriteHead_
-
writeHead_
)
;
writeBytesAtOffset
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
writeHead_
)
;
writeHead_
=
uncommittedWriteHead_
;
}
void
beginReadingEntry
(
)
{
MOZ_ASSERT
(
uncommittedReadHead_
=
=
readHead_
)
;
uncommittedReadHead_
+
=
ENTRY_HEADER_SIZE
;
}
void
finishReadingEntry
(
)
{
uint16_t
entryHeader
;
readBytesAtOffset
(
reinterpret_cast
<
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
readHead_
)
;
size_t
read
=
uncommittedReadHead_
-
readHead_
;
MOZ_RELEASE_ASSERT
(
entryHeader
=
=
uint16_t
(
read
)
)
;
readHead_
+
=
entryHeader
;
uncommittedReadHead_
=
readHead_
;
}
void
skipEntry
(
)
{
uint16_t
entryHeader
;
readBytesAtOffset
(
reinterpret_cast
<
uint8_t
*
>
(
&
entryHeader
)
sizeof
(
entryHeader
)
readHead_
)
;
readHead_
+
=
entryHeader
;
uncommittedReadHead_
=
readHead_
;
}
void
writeBytesAtOffset
(
const
uint8_t
*
bytes
size_t
length
uint64_t
offset
)
{
MOZ_ASSERT
(
offset
+
length
<
=
readHead_
+
BUFFER_SIZE
)
;
size_t
maskedWriteHead
=
offset
&
BUFFER_MASK
;
if
(
maskedWriteHead
+
length
>
BUFFER_SIZE
)
{
size_t
firstChunk
=
BUFFER_SIZE
-
maskedWriteHead
;
memcpy
(
buffer_
+
maskedWriteHead
bytes
firstChunk
)
;
memcpy
(
buffer_
bytes
+
firstChunk
length
-
firstChunk
)
;
}
else
{
memcpy
(
buffer_
+
maskedWriteHead
bytes
length
)
;
}
}
void
writeBytes
(
const
uint8_t
*
bytes
size_t
length
)
{
while
(
MOZ_UNLIKELY
(
uncommittedWriteHead_
+
length
>
readHead_
+
BUFFER_SIZE
)
)
{
skipEntry
(
)
;
}
writeBytesAtOffset
(
bytes
length
uncommittedWriteHead_
)
;
uncommittedWriteHead_
+
=
length
;
}
template
<
typename
T
>
void
write
(
T
val
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
T
>
)
;
writeBytes
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
val
)
sizeof
(
T
)
)
;
}
void
writeEmptyString
(
)
{
write
(
uint8_t
(
TracerStringEncoding
:
:
Latin1
)
)
;
write
(
uint32_t
(
0
)
)
;
}
bool
writeString
(
JSContext
*
cx
JS
:
:
Handle
<
JSString
*
>
str
)
{
TracerStringEncoding
encoding
;
if
(
str
-
>
hasLatin1Chars
(
)
)
{
encoding
=
TracerStringEncoding
:
:
Latin1
;
}
else
{
encoding
=
TracerStringEncoding
:
:
TwoByte
;
}
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
{
return
false
;
}
write
(
uint8_t
(
encoding
)
)
;
size_t
length
=
linear
-
>
length
(
)
;
MOZ_ASSERT
(
length
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
write
(
uint32_t
(
length
)
)
;
size_t
size
=
length
;
JS
:
:
AutoAssertNoGC
nogc
;
const
uint8_t
*
charBuffer
=
nullptr
;
if
(
encoding
=
=
TracerStringEncoding
:
:
TwoByte
)
{
size
*
=
sizeof
(
char16_t
)
;
charBuffer
=
reinterpret_cast
<
const
uint8_t
*
>
(
linear
-
>
twoByteChars
(
nogc
)
)
;
}
else
{
charBuffer
=
reinterpret_cast
<
const
uint8_t
*
>
(
linear
-
>
latin1Chars
(
nogc
)
)
;
}
writeBytes
(
charBuffer
size
)
;
return
true
;
}
template
<
typename
CharType
TracerStringEncoding
Encoding
>
void
writeCString
(
const
CharType
*
chars
)
{
size_t
length
=
std
:
:
char_traits
<
CharType
>
:
:
length
(
chars
)
;
static_assert
(
sizeof
(
CharType
)
=
=
1
|
|
Encoding
=
=
TracerStringEncoding
:
:
TwoByte
)
;
static_assert
(
sizeof
(
CharType
)
<
=
2
)
;
write
(
uint8_t
(
Encoding
)
)
;
MOZ_ASSERT
(
length
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
write
(
uint32_t
(
length
)
)
;
const
size_t
size
=
length
*
sizeof
(
CharType
)
;
writeBytes
(
reinterpret_cast
<
const
uint8_t
*
>
(
chars
)
size
)
;
}
void
readBytesAtOffset
(
uint8_t
*
bytes
size_t
length
uint64_t
offset
)
{
size_t
maskedReadHead
=
offset
&
BUFFER_MASK
;
if
(
maskedReadHead
+
length
>
BUFFER_SIZE
)
{
size_t
firstChunk
=
BUFFER_SIZE
-
maskedReadHead
;
memcpy
(
bytes
buffer_
+
maskedReadHead
firstChunk
)
;
memcpy
(
bytes
+
firstChunk
buffer_
length
-
firstChunk
)
;
}
else
{
memcpy
(
bytes
buffer_
+
maskedReadHead
length
)
;
}
}
void
readBytes
(
uint8_t
*
bytes
size_t
length
)
{
readBytesAtOffset
(
bytes
length
uncommittedReadHead_
)
;
uncommittedReadHead_
+
=
length
;
}
template
<
typename
T
>
void
read
(
T
*
val
)
{
static_assert
(
std
:
:
is_arithmetic_v
<
T
>
)
;
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
val
)
sizeof
(
T
)
)
;
}
bool
readString
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JSString
*
>
result
)
{
uint8_t
encodingByte
;
read
(
&
encodingByte
)
;
TracerStringEncoding
encoding
=
TracerStringEncoding
(
encodingByte
)
;
uint32_t
length
;
read
(
&
length
)
;
if
(
length
=
=
0
)
{
result
.
set
(
JS_GetEmptyString
(
cx
)
)
;
return
true
;
}
JSLinearString
*
str
=
nullptr
;
if
(
encoding
=
=
TracerStringEncoding
:
:
UTF8
|
|
encoding
=
=
TracerStringEncoding
:
:
Latin1
)
{
UniquePtr
<
unsigned
char
[
]
JS
:
:
FreePolicy
>
chars
(
cx
-
>
make_pod_arena_array
<
unsigned
char
>
(
StringBufferArena
length
)
)
;
if
(
!
chars
)
{
return
false
;
}
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
chars
.
get
(
)
)
length
)
;
if
(
encoding
=
=
TracerStringEncoding
:
:
UTF8
)
{
str
=
NewStringCopyUTF8N
(
cx
JS
:
:
UTF8Chars
(
reinterpret_cast
<
char
*
>
(
chars
.
get
(
)
)
length
)
)
;
}
else
{
str
=
NewString
<
CanGC
>
(
cx
std
:
:
move
(
chars
)
length
)
;
}
}
else
{
MOZ_ASSERT
(
encoding
=
=
TracerStringEncoding
:
:
TwoByte
)
;
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
chars
(
cx
-
>
make_pod_arena_array
<
char16_t
>
(
StringBufferArena
length
)
)
;
if
(
!
chars
)
{
return
false
;
}
readBytes
(
(
uint8_t
*
)
chars
.
get
(
)
length
*
sizeof
(
char16_t
)
)
;
str
=
NewString
<
CanGC
>
(
cx
std
:
:
move
(
chars
)
length
)
;
}
if
(
!
str
)
{
return
false
;
}
result
.
set
(
str
)
;
return
true
;
}
bool
readStringNative
(
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
size_t
*
index
)
{
uint8_t
encodingByte
;
read
(
&
encodingByte
)
;
TracerStringEncoding
encoding
=
TracerStringEncoding
(
encodingByte
)
;
uint32_t
length
;
read
(
&
length
)
;
*
index
=
stringBuffer
.
length
(
)
;
if
(
length
=
=
0
)
{
if
(
!
stringBuffer
.
append
(
'
\
0
'
)
)
{
return
false
;
}
return
true
;
}
if
(
encoding
=
=
TracerStringEncoding
:
:
UTF8
)
{
size_t
reserveLength
=
length
+
1
;
if
(
!
stringBuffer
.
growByUninitialized
(
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
-
reserveLength
;
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
writePtr
)
length
)
;
writePtr
[
length
]
=
'
\
0
'
;
}
else
if
(
encoding
=
=
TracerStringEncoding
:
:
Latin1
)
{
if
(
!
ensureScratchBufferSize
(
scratchBuffer
length
)
)
{
return
false
;
}
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
)
;
size_t
reserveLength
=
length
*
2
+
1
;
if
(
!
stringBuffer
.
reserve
(
stringBuffer
.
length
(
)
+
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
;
size_t
convertedLength
=
mozilla
:
:
ConvertLatin1toUtf8
(
mozilla
:
:
Span
<
const
char
>
(
scratchBuffer
.
begin
(
)
length
)
mozilla
:
:
Span
<
char
>
(
writePtr
reserveLength
)
)
;
writePtr
[
convertedLength
]
=
0
;
if
(
!
stringBuffer
.
growByUninitialized
(
convertedLength
+
1
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
encoding
=
=
TracerStringEncoding
:
:
TwoByte
)
;
if
(
!
ensureScratchBufferSize
(
scratchBuffer
length
*
sizeof
(
char16_t
)
)
)
{
return
false
;
}
readBytes
(
reinterpret_cast
<
uint8_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
*
sizeof
(
char16_t
)
)
;
size_t
reserveLength
=
length
*
3
+
1
;
if
(
!
stringBuffer
.
reserve
(
stringBuffer
.
length
(
)
+
reserveLength
)
)
{
return
false
;
}
char
*
writePtr
=
stringBuffer
.
end
(
)
;
size_t
convertedLength
=
mozilla
:
:
ConvertUtf16toUtf8
(
mozilla
:
:
Span
<
const
char16_t
>
(
reinterpret_cast
<
char16_t
*
>
(
scratchBuffer
.
begin
(
)
)
length
)
mozilla
:
:
Span
<
char
>
(
writePtr
reserveLength
)
)
;
writePtr
[
convertedLength
]
=
0
;
if
(
!
stringBuffer
.
growByUninitialized
(
convertedLength
+
1
)
)
{
return
false
;
}
}
return
true
;
}
}
;
using
InlineDataBuffer
=
TracingBuffer
<
1
<
<
28
>
;
using
OutOfLineDataBuffer
=
TracingBuffer
<
1
<
<
22
>
;
class
ExecutionTracer
{
private
:
static
Mutex
globalInstanceLock
MOZ_UNANNOTATED
;
static
mozilla
:
:
Vector
<
ExecutionTracer
*
>
globalInstances
;
Mutex
bufferLock_
MOZ_UNANNOTATED
;
InlineDataBuffer
inlineData_
;
OutOfLineDataBuffer
outOfLineData_
;
mozilla
:
:
baseprofiler
:
:
BaseProfilerThreadId
threadId_
;
void
writeScriptUrl
(
ScriptSource
*
scriptSource
)
;
bool
writeAtom
(
JSContext
*
cx
JS
:
:
Handle
<
JSAtom
*
>
atom
uint32_t
id
)
;
bool
writeFunctionFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
bool
readFunctionFrame
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
result
JS
:
:
ExecutionTrace
:
:
EventKind
kind
)
;
bool
readStackFunctionEnter
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
events
)
;
bool
readStackFunctionLeave
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
events
)
;
bool
readScriptURLEntry
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scriptUrls
)
;
bool
readAtomEntry
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
atoms
)
;
bool
readLabel
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
events
JS
:
:
ExecutionTrace
:
:
EventKind
kind
)
;
bool
readInlineEntry
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
events
)
;
bool
readOutOfLineEntry
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scriptUrls
JS
:
:
Handle
<
JSObject
*
>
atoms
)
;
bool
readInlineEntries
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
events
)
;
bool
readOutOfLineEntries
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scriptUrls
JS
:
:
Handle
<
JSObject
*
>
atoms
)
;
bool
readFunctionFrameNative
(
JS
:
:
ExecutionTrace
:
:
EventKind
kind
JS
:
:
ExecutionTrace
:
:
TracedEvent
&
event
)
;
bool
readLabelNative
(
JS
:
:
ExecutionTrace
:
:
EventKind
kind
JS
:
:
ExecutionTrace
:
:
TracedEvent
&
event
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readInlineEntryNative
(
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
TracedEvent
>
&
events
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readOutOfLineEntryNative
(
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
scriptUrls
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
atoms
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readInlineEntriesNative
(
mozilla
:
:
Vector
<
JS
:
:
ExecutionTrace
:
:
TracedEvent
>
&
events
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
bool
readOutOfLineEntriesNative
(
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
scriptUrls
mozilla
:
:
HashMap
<
uint32_t
size_t
>
&
atoms
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
public
:
ExecutionTracer
(
)
:
bufferLock_
(
mutexid
:
:
ExecutionTracerInstanceLock
)
{
}
~
ExecutionTracer
(
)
{
LockGuard
<
Mutex
>
guard
(
globalInstanceLock
)
;
globalInstances
.
eraseIfEqual
(
this
)
;
}
mozilla
:
:
baseprofiler
:
:
BaseProfilerThreadId
threadId
(
)
const
{
return
threadId_
;
}
bool
init
(
)
{
LockGuard
<
Mutex
>
guard
(
globalInstanceLock
)
;
LockGuard
<
Mutex
>
guard2
(
bufferLock_
)
;
threadId_
=
mozilla
:
:
baseprofiler
:
:
profiler_current_thread_id
(
)
;
if
(
!
inlineData_
.
init
(
)
)
{
return
false
;
}
if
(
!
outOfLineData_
.
init
(
)
)
{
return
false
;
}
if
(
!
globalInstances
.
append
(
this
)
)
{
return
false
;
}
return
true
;
}
bool
onEnterFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
bool
onLeaveFrame
(
JSContext
*
cx
AbstractFramePtr
frame
)
;
template
<
typename
CharType
TracerStringEncoding
Encoding
>
void
onEnterLabel
(
const
CharType
*
eventType
)
;
template
<
typename
CharType
TracerStringEncoding
Encoding
>
void
onLeaveLabel
(
const
CharType
*
eventType
)
;
bool
getTrace
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
result
)
;
bool
getNativeTrace
(
JS
:
:
ExecutionTrace
:
:
TracedJSContext
&
context
TracingScratchBuffer
&
scratchBuffer
mozilla
:
:
Vector
<
char
>
&
stringBuffer
)
;
static
bool
getNativeTraceForAllContexts
(
JS
:
:
ExecutionTrace
&
trace
)
;
}
;
}
#
endif
