#
ifndef
debugger_Script_h
#
define
debugger_Script_h
#
include
"
jsapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
debugger
/
Debugger
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
class
JS_PUBLIC_API
JSObject
;
namespace
js
{
class
BaseScript
;
class
GlobalObject
;
namespace
gc
{
struct
Cell
;
}
class
DebuggerScript
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
OWNER_SLOT
INSTRUMENTATION_ID_SLOT
RESERVED_SLOTS
}
;
static
NativeObject
*
initClass
(
JSContext
*
cx
Handle
<
GlobalObject
*
>
global
HandleObject
debugCtor
)
;
static
DebuggerScript
*
create
(
JSContext
*
cx
HandleObject
proto
Handle
<
DebuggerScriptReferent
>
referent
HandleNativeObject
debugger
)
;
void
trace
(
JSTracer
*
trc
)
;
using
ReferentVariant
=
DebuggerScriptReferent
;
inline
gc
:
:
Cell
*
getReferentCell
(
)
const
;
inline
js
:
:
BaseScript
*
getReferentScript
(
)
const
;
inline
DebuggerScriptReferent
getReferent
(
)
const
;
static
DebuggerScript
*
check
(
JSContext
*
cx
HandleValue
v
)
;
static
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
struct
CallData
;
static
bool
getSuccessorOrPredecessorOffsets
(
JSContext
*
cx
unsigned
argc
Value
*
vp
const
char
*
name
bool
successor
)
;
Value
getInstrumentationId
(
)
const
{
return
getSlot
(
INSTRUMENTATION_ID_SLOT
)
;
}
private
:
static
const
JSClassOps
classOps_
;
static
const
JSPropertySpec
properties_
[
]
;
static
const
JSFunctionSpec
methods_
[
]
;
struct
GetLineCountMatcher
;
class
GetSourceMatcher
;
template
<
bool
OnlyOffsets
>
class
GetPossibleBreakpointsMatcher
;
class
GetOffsetMetadataMatcher
;
class
GetOffsetLocationMatcher
;
class
GetSuccessorOrPredecessorOffsetsMatcher
;
class
GetAllColumnOffsetsMatcher
;
class
GetLineOffsetsMatcher
;
struct
SetBreakpointMatcher
;
class
ClearBreakpointMatcher
;
class
IsInCatchScopeMatcher
;
}
;
}
#
endif
