#
ifndef
debugger_NoExecute_h
#
define
debugger_NoExecute_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
debugger
/
Debugger
.
h
"
#
include
"
js
/
Promise
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
namespace
js
{
class
LeaveDebuggeeNoExecute
;
class
MOZ_RAII
EnterDebuggeeNoExecute
{
friend
class
LeaveDebuggeeNoExecute
;
Debugger
&
dbg_
;
EnterDebuggeeNoExecute
*
*
stack_
;
EnterDebuggeeNoExecute
*
prev_
;
LeaveDebuggeeNoExecute
*
unlocked_
;
bool
reported_
;
public
:
explicit
EnterDebuggeeNoExecute
(
JSContext
*
cx
Debugger
&
dbg
const
JS
:
:
AutoDebuggerJobQueueInterruption
&
adjqiProof
)
;
~
EnterDebuggeeNoExecute
(
)
{
MOZ_ASSERT
(
*
stack_
=
=
this
)
;
*
stack_
=
prev_
;
}
Debugger
&
debugger
(
)
const
{
return
dbg_
;
}
#
ifdef
DEBUG
static
bool
isLockedInStack
(
JSContext
*
cx
Debugger
&
dbg
)
;
#
endif
static
EnterDebuggeeNoExecute
*
findInStack
(
JSContext
*
cx
)
;
static
bool
reportIfFoundInStack
(
JSContext
*
cx
HandleScript
script
)
;
}
;
class
MOZ_RAII
LeaveDebuggeeNoExecute
{
EnterDebuggeeNoExecute
*
prevLocked_
;
public
:
explicit
LeaveDebuggeeNoExecute
(
JSContext
*
cx
)
:
prevLocked_
(
EnterDebuggeeNoExecute
:
:
findInStack
(
cx
)
)
{
if
(
prevLocked_
)
{
MOZ_ASSERT
(
!
prevLocked_
-
>
unlocked_
)
;
prevLocked_
-
>
unlocked_
=
this
;
}
}
~
LeaveDebuggeeNoExecute
(
)
{
if
(
prevLocked_
)
{
MOZ_ASSERT
(
prevLocked_
-
>
unlocked_
=
=
this
)
;
prevLocked_
-
>
unlocked_
=
nullptr
;
}
}
}
;
}
#
endif
