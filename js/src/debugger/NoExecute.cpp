#
include
"
debugger
/
NoExecute
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
EnterDebuggeeNoExecute
:
:
EnterDebuggeeNoExecute
(
JSContext
*
cx
Debugger
&
dbg
const
JS
:
:
AutoDebuggerJobQueueInterruption
&
adjqiProof
)
:
dbg_
(
dbg
)
unlocked_
(
nullptr
)
reported_
(
false
)
{
MOZ_ASSERT
(
adjqiProof
.
initialized
(
)
)
;
stack_
=
&
cx
-
>
noExecuteDebuggerTop
.
ref
(
)
;
prev_
=
*
stack_
;
*
stack_
=
this
;
}
#
ifdef
DEBUG
bool
EnterDebuggeeNoExecute
:
:
isLockedInStack
(
JSContext
*
cx
Debugger
&
dbg
)
{
for
(
EnterDebuggeeNoExecute
*
it
=
cx
-
>
noExecuteDebuggerTop
;
it
;
it
=
it
-
>
prev_
)
{
if
(
&
it
-
>
debugger
(
)
=
=
&
dbg
)
{
return
!
it
-
>
unlocked_
;
}
}
return
false
;
}
#
endif
EnterDebuggeeNoExecute
*
EnterDebuggeeNoExecute
:
:
findInStack
(
JSContext
*
cx
)
{
Realm
*
debuggee
=
cx
-
>
realm
(
)
;
for
(
EnterDebuggeeNoExecute
*
it
=
cx
-
>
noExecuteDebuggerTop
;
it
;
it
=
it
-
>
prev_
)
{
Debugger
&
dbg
=
it
-
>
debugger
(
)
;
if
(
!
it
-
>
unlocked_
&
&
dbg
.
isEnabled
(
)
&
&
dbg
.
observesGlobal
(
debuggee
-
>
maybeGlobal
(
)
)
)
{
return
it
;
}
}
return
nullptr
;
}
bool
EnterDebuggeeNoExecute
:
:
reportIfFoundInStack
(
JSContext
*
cx
HandleScript
script
)
{
if
(
EnterDebuggeeNoExecute
*
nx
=
findInStack
(
cx
)
)
{
bool
warning
=
!
cx
-
>
options
(
)
.
throwOnDebuggeeWouldRun
(
)
;
if
(
!
warning
|
|
!
nx
-
>
reported_
)
{
AutoRealm
ar
(
cx
nx
-
>
debugger
(
)
.
toJSObject
(
)
)
;
nx
-
>
reported_
=
true
;
if
(
cx
-
>
options
(
)
.
dumpStackOnDebuggeeWouldRun
(
)
)
{
fprintf
(
stdout
"
Dumping
stack
for
DebuggeeWouldRun
:
\
n
"
)
;
DumpBacktrace
(
cx
)
;
}
const
char
*
filename
=
script
-
>
filename
(
)
?
script
-
>
filename
(
)
:
"
(
none
)
"
;
char
linenoStr
[
15
]
;
SprintfLiteral
(
linenoStr
"
%
u
"
script
-
>
lineno
(
)
)
;
unsigned
flags
=
warning
?
JSREPORT_WARNING
:
JSREPORT_ERROR
;
return
JS_ReportErrorFlagsAndNumberLatin1
(
cx
flags
GetErrorMessage
nullptr
JSMSG_DEBUGGEE_WOULD_RUN
filename
linenoStr
)
;
}
}
return
true
;
}
