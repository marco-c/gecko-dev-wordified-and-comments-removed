#
include
"
debugger
/
DebugScript
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
utility
>
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
debugger
/
Debugger
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
vm
/
BytecodeIterator
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
gc
/
GCContext
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
BytecodeIterator
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
namespace
js
{
const
JSClass
DebugScriptObject
:
:
class_
=
{
"
DebugScriptObject
"
JSCLASS_HAS_RESERVED_SLOTS
(
SlotCount
)
|
JSCLASS_BACKGROUND_FINALIZE
&
classOps_
JS_NULL_CLASS_SPEC
}
;
const
JSClassOps
DebugScriptObject
:
:
classOps_
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
DebugScriptObject
:
:
finalize
nullptr
nullptr
DebugScriptObject
:
:
trace
}
;
DebugScriptObject
*
DebugScriptObject
:
:
create
(
JSContext
*
cx
UniqueDebugScript
debugScript
size_t
nbytes
)
{
auto
*
object
=
NewObjectWithGivenProto
<
DebugScriptObject
>
(
cx
nullptr
)
;
if
(
!
object
)
{
return
nullptr
;
}
object
-
>
initReservedSlot
(
ScriptSlot
PrivateValue
(
debugScript
.
release
(
)
)
)
;
AddCellMemory
(
object
nbytes
MemoryUse
:
:
ScriptDebugScript
)
;
return
object
;
}
DebugScript
*
DebugScriptObject
:
:
debugScript
(
)
const
{
return
maybePtrFromReservedSlot
<
DebugScript
>
(
ScriptSlot
)
;
}
void
DebugScriptObject
:
:
trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
DebugScript
*
debugScript
=
obj
-
>
as
<
DebugScriptObject
>
(
)
.
debugScript
(
)
;
if
(
debugScript
)
{
debugScript
-
>
trace
(
trc
)
;
}
}
void
DebugScriptObject
:
:
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
DebugScriptObject
*
object
=
&
obj
-
>
as
<
DebugScriptObject
>
(
)
;
DebugScript
*
debugScript
=
object
-
>
debugScript
(
)
;
if
(
debugScript
)
{
debugScript
-
>
delete_
(
gcx
object
)
;
}
}
DebugScript
*
DebugScript
:
:
get
(
JSScript
*
script
)
{
MOZ_ASSERT
(
script
-
>
hasDebugScript
(
)
)
;
DebugScriptMap
*
map
=
script
-
>
zone
(
)
-
>
debugScriptMap
;
MOZ_ASSERT
(
map
)
;
DebugScriptMap
:
:
Ptr
p
=
map
-
>
lookupUnbarriered
(
script
)
;
MOZ_ASSERT
(
p
)
;
return
p
-
>
value
(
)
.
get
(
)
-
>
as
<
DebugScriptObject
>
(
)
.
debugScript
(
)
;
}
DebugScript
*
DebugScript
:
:
getOrCreate
(
JSContext
*
cx
HandleScript
script
)
{
cx
-
>
check
(
script
)
;
if
(
script
-
>
hasDebugScript
(
)
)
{
return
get
(
script
)
;
}
size_t
nbytes
=
allocSize
(
script
-
>
length
(
)
)
;
UniqueDebugScript
debug
(
reinterpret_cast
<
DebugScript
*
>
(
cx
-
>
pod_calloc
<
uint8_t
>
(
nbytes
)
)
)
;
if
(
!
debug
)
{
return
nullptr
;
}
debug
-
>
codeLength
=
script
-
>
length
(
)
;
Rooted
<
DebugScriptObject
*
>
object
(
cx
DebugScriptObject
:
:
create
(
cx
std
:
:
move
(
debug
)
nbytes
)
)
;
if
(
!
object
)
{
return
nullptr
;
}
Zone
*
zone
=
script
-
>
zone
(
)
;
MOZ_ASSERT
(
cx
-
>
zone
(
)
=
=
zone
)
;
if
(
!
zone
-
>
debugScriptMap
)
{
DebugScriptMap
*
map
=
cx
-
>
new_
<
DebugScriptMap
>
(
cx
)
;
if
(
!
map
)
{
return
nullptr
;
}
zone
-
>
debugScriptMap
=
map
;
}
MOZ_ASSERT
(
script
-
>
hasBytecode
(
)
)
;
if
(
!
zone
-
>
debugScriptMap
-
>
putNew
(
script
.
get
(
)
object
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
script
-
>
setHasDebugScript
(
true
)
;
for
(
ActivationIterator
iter
(
cx
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
iter
-
>
isInterpreter
(
)
)
{
iter
-
>
asInterpreter
(
)
-
>
enableInterruptsIfRunning
(
script
)
;
}
}
return
object
-
>
debugScript
(
)
;
}
JSBreakpointSite
*
DebugScript
:
:
getBreakpointSite
(
JSScript
*
script
jsbytecode
*
pc
)
{
uint32_t
offset
=
script
-
>
pcToOffset
(
pc
)
;
return
script
-
>
hasDebugScript
(
)
?
get
(
script
)
-
>
breakpoints
[
offset
]
:
nullptr
;
}
JSBreakpointSite
*
DebugScript
:
:
getOrCreateBreakpointSite
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
)
{
AutoRealm
ar
(
cx
script
)
;
DebugScript
*
debug
=
getOrCreate
(
cx
script
)
;
if
(
!
debug
)
{
return
nullptr
;
}
JSBreakpointSite
*
&
site
=
debug
-
>
breakpoints
[
script
-
>
pcToOffset
(
pc
)
]
;
if
(
!
site
)
{
site
=
cx
-
>
new_
<
JSBreakpointSite
>
(
script
pc
)
;
if
(
!
site
)
{
return
nullptr
;
}
debug
-
>
numSites
+
+
;
AddCellMemory
(
script
sizeof
(
JSBreakpointSite
)
MemoryUse
:
:
BreakpointSite
)
;
if
(
script
-
>
hasBaselineScript
(
)
)
{
script
-
>
baselineScript
(
)
-
>
toggleDebugTraps
(
script
pc
)
;
}
}
return
site
;
}
void
DebugScript
:
:
destroyBreakpointSite
(
JS
:
:
GCContext
*
gcx
JSScript
*
script
jsbytecode
*
pc
)
{
DebugScript
*
debug
=
get
(
script
)
;
JSBreakpointSite
*
&
site
=
debug
-
>
breakpoints
[
script
-
>
pcToOffset
(
pc
)
]
;
MOZ_ASSERT
(
site
)
;
MOZ_ASSERT
(
site
-
>
isEmpty
(
)
)
;
site
-
>
delete_
(
gcx
)
;
site
=
nullptr
;
debug
-
>
numSites
-
-
;
if
(
!
debug
-
>
needed
(
)
)
{
DebugAPI
:
:
removeDebugScript
(
gcx
script
)
;
}
if
(
script
-
>
hasBaselineScript
(
)
)
{
script
-
>
baselineScript
(
)
-
>
toggleDebugTraps
(
script
pc
)
;
}
}
void
DebugScript
:
:
clearBreakpointsIn
(
JS
:
:
GCContext
*
gcx
JSScript
*
script
Debugger
*
dbg
JSObject
*
handler
)
{
MOZ_ASSERT
(
script
)
;
MOZ_ASSERT_IF
(
handler
script
-
>
compartment
(
)
=
=
handler
-
>
compartment
(
)
)
;
if
(
!
script
-
>
hasDebugScript
(
)
)
{
return
;
}
AllBytecodesIterable
iter
(
script
)
;
for
(
BytecodeLocation
loc
:
iter
)
{
JSBreakpointSite
*
site
=
getBreakpointSite
(
script
loc
.
toRawBytecode
(
)
)
;
if
(
site
)
{
Breakpoint
*
nextbp
;
for
(
Breakpoint
*
bp
=
site
-
>
firstBreakpoint
(
)
;
bp
;
bp
=
nextbp
)
{
nextbp
=
bp
-
>
nextInSite
(
)
;
if
(
(
!
dbg
|
|
bp
-
>
debugger
=
=
dbg
)
&
&
(
!
handler
|
|
bp
-
>
getHandler
(
)
=
=
handler
)
)
{
bp
-
>
remove
(
gcx
)
;
}
}
}
}
}
#
ifdef
DEBUG
uint32_t
DebugScript
:
:
getStepperCount
(
JSScript
*
script
)
{
return
script
-
>
hasDebugScript
(
)
?
get
(
script
)
-
>
stepperCount
:
0
;
}
#
endif
bool
DebugScript
:
:
incrementStepperCount
(
JSContext
*
cx
HandleScript
script
)
{
cx
-
>
check
(
script
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
isDebuggee
(
)
)
;
AutoRealm
ar
(
cx
script
)
;
DebugScript
*
debug
=
getOrCreate
(
cx
script
)
;
if
(
!
debug
)
{
return
false
;
}
debug
-
>
stepperCount
+
+
;
if
(
debug
-
>
stepperCount
=
=
1
)
{
if
(
script
-
>
hasBaselineScript
(
)
)
{
script
-
>
baselineScript
(
)
-
>
toggleDebugTraps
(
script
nullptr
)
;
}
}
return
true
;
}
void
DebugScript
:
:
decrementStepperCount
(
JS
:
:
GCContext
*
gcx
JSScript
*
script
)
{
DebugScript
*
debug
=
get
(
script
)
;
MOZ_ASSERT
(
debug
)
;
MOZ_ASSERT
(
debug
-
>
stepperCount
>
0
)
;
debug
-
>
stepperCount
-
-
;
if
(
debug
-
>
stepperCount
=
=
0
)
{
if
(
script
-
>
hasBaselineScript
(
)
)
{
script
-
>
baselineScript
(
)
-
>
toggleDebugTraps
(
script
nullptr
)
;
}
if
(
!
debug
-
>
needed
(
)
)
{
DebugAPI
:
:
removeDebugScript
(
gcx
script
)
;
}
}
}
bool
DebugScript
:
:
incrementGeneratorObserverCount
(
JSContext
*
cx
HandleScript
script
)
{
cx
-
>
check
(
script
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
-
>
isDebuggee
(
)
)
;
AutoRealm
ar
(
cx
script
)
;
DebugScript
*
debug
=
getOrCreate
(
cx
script
)
;
if
(
!
debug
)
{
return
false
;
}
debug
-
>
generatorObserverCount
+
+
;
MOZ_ASSERT_IF
(
script
-
>
hasBaselineScript
(
)
script
-
>
baselineScript
(
)
-
>
hasDebugInstrumentation
(
)
)
;
return
true
;
}
void
DebugScript
:
:
decrementGeneratorObserverCount
(
JS
:
:
GCContext
*
gcx
JSScript
*
script
)
{
DebugScript
*
debug
=
get
(
script
)
;
MOZ_ASSERT
(
debug
)
;
MOZ_ASSERT
(
debug
-
>
generatorObserverCount
>
0
)
;
debug
-
>
generatorObserverCount
-
-
;
if
(
!
debug
-
>
needed
(
)
)
{
DebugAPI
:
:
removeDebugScript
(
gcx
script
)
;
}
}
void
DebugScript
:
:
trace
(
JSTracer
*
trc
)
{
for
(
size_t
i
=
0
;
i
<
codeLength
;
i
+
+
)
{
JSBreakpointSite
*
site
=
breakpoints
[
i
]
;
if
(
site
)
{
site
-
>
trace
(
trc
)
;
}
}
}
void
DebugAPI
:
:
removeDebugScript
(
JS
:
:
GCContext
*
gcx
JSScript
*
script
)
{
if
(
script
-
>
hasDebugScript
(
)
)
{
if
(
IsAboutToBeFinalizedUnbarriered
(
script
)
)
{
return
;
}
DebugScriptMap
*
map
=
script
-
>
zone
(
)
-
>
debugScriptMap
;
MOZ_ASSERT
(
map
)
;
DebugScriptMap
:
:
Ptr
p
=
map
-
>
lookupUnbarriered
(
script
)
;
MOZ_ASSERT
(
p
)
;
map
-
>
remove
(
p
)
;
script
-
>
setHasDebugScript
(
false
)
;
}
}
void
DebugScript
:
:
delete_
(
JS
:
:
GCContext
*
gcx
DebugScriptObject
*
owner
)
{
for
(
size_t
i
=
0
;
i
<
codeLength
;
i
+
+
)
{
JSBreakpointSite
*
site
=
breakpoints
[
i
]
;
if
(
site
)
{
site
-
>
delete_
(
gcx
)
;
}
}
gcx
-
>
free_
(
owner
this
allocSize
(
codeLength
)
MemoryUse
:
:
ScriptDebugScript
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
DebugAPI
:
:
checkDebugScriptAfterMovingGC
(
DebugScript
*
ds
)
{
for
(
uint32_t
i
=
0
;
i
<
ds
-
>
numSites
;
i
+
+
)
{
JSBreakpointSite
*
site
=
ds
-
>
breakpoints
[
i
]
;
if
(
site
)
{
CheckGCThingAfterMovingGC
(
site
-
>
script
.
get
(
)
)
;
}
}
}
#
endif
bool
DebugAPI
:
:
stepModeEnabledSlow
(
JSScript
*
script
)
{
return
DebugScript
:
:
get
(
script
)
-
>
stepperCount
>
0
;
}
bool
DebugAPI
:
:
hasBreakpointsAtSlow
(
JSScript
*
script
jsbytecode
*
pc
)
{
JSBreakpointSite
*
site
=
DebugScript
:
:
getBreakpointSite
(
script
pc
)
;
return
!
!
site
;
}
void
DebugAPI
:
:
traceDebugScriptMap
(
JSTracer
*
trc
DebugScriptMap
*
map
)
{
map
-
>
trace
(
trc
)
;
}
void
DebugAPI
:
:
deleteDebugScriptMap
(
DebugScriptMap
*
map
)
{
js_delete
(
map
)
;
}
}
