#
ifndef
threading_ConditionVariable_h
#
define
threading_ConditionVariable_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
stdint
.
h
>
#
ifndef
XP_WIN
#
include
<
pthread
.
h
>
#
endif
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
namespace
js
{
enum
class
CVStatus
{
NoTimeout
Timeout
}
;
namespace
detail
{
class
ConditionVariableImpl
{
public
:
struct
PlatformData
;
ConditionVariableImpl
(
)
;
~
ConditionVariableImpl
(
)
;
void
notify_one
(
)
;
void
notify_all
(
)
;
void
wait
(
Mutex
&
lock
)
;
CVStatus
wait_for
(
Mutex
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
)
;
private
:
ConditionVariableImpl
(
const
ConditionVariableImpl
&
)
=
delete
;
ConditionVariableImpl
&
operator
=
(
const
ConditionVariableImpl
&
)
=
delete
;
PlatformData
*
platformData
(
)
;
#
ifndef
XP_WIN
void
*
platformData_
[
sizeof
(
pthread_cond_t
)
/
sizeof
(
void
*
)
]
;
static_assert
(
sizeof
(
pthread_cond_t
)
/
sizeof
(
void
*
)
!
=
0
&
&
sizeof
(
pthread_cond_t
)
%
sizeof
(
void
*
)
=
=
0
"
pthread_cond_t
must
have
pointer
alignment
"
)
;
#
else
void
*
platformData_
[
4
]
;
#
endif
}
;
}
template
<
typename
T
>
using
UniqueLock
=
LockGuard
<
T
>
;
class
ConditionVariable
{
public
:
struct
PlatformData
;
ConditionVariable
(
)
=
default
;
~
ConditionVariable
(
)
=
default
;
void
notify_one
(
)
{
impl_
.
notify_one
(
)
;
}
void
notify_all
(
)
{
impl_
.
notify_all
(
)
;
}
void
wait
(
UniqueLock
<
Mutex
>
&
lock
)
{
impl_
.
wait
(
lock
.
lock
)
;
}
template
<
typename
Predicate
>
void
wait
(
UniqueLock
<
Mutex
>
&
lock
Predicate
pred
)
{
while
(
!
pred
(
)
)
{
wait
(
lock
)
;
}
}
CVStatus
wait_until
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeStamp
&
abs_time
)
{
return
wait_for
(
lock
abs_time
-
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
;
}
template
<
typename
Predicate
>
bool
wait_until
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeStamp
&
abs_time
Predicate
pred
)
{
while
(
!
pred
(
)
)
{
if
(
wait_until
(
lock
abs_time
)
=
=
CVStatus
:
:
Timeout
)
{
return
pred
(
)
;
}
}
return
true
;
}
CVStatus
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
)
{
return
impl_
.
wait_for
(
lock
.
lock
rel_time
)
;
}
template
<
typename
Predicate
>
bool
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
Predicate
pred
)
{
return
wait_until
(
lock
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
rel_time
mozilla
:
:
Move
(
pred
)
)
;
}
private
:
ConditionVariable
(
const
ConditionVariable
&
)
=
delete
;
ConditionVariable
&
operator
=
(
const
ConditionVariable
&
)
=
delete
;
detail
:
:
ConditionVariableImpl
impl_
;
}
;
}
#
endif
