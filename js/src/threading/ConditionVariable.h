#
ifndef
threading_ConditionVariable_h
#
define
threading_ConditionVariable_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
PlatformConditionVariable
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
ifndef
XP_WIN
#
include
<
pthread
.
h
>
#
endif
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
namespace
js
{
template
<
class
T
>
class
ExclusiveData
;
enum
class
CVStatus
{
NoTimeout
Timeout
}
;
template
<
typename
T
>
using
UniqueLock
=
LockGuard
<
T
>
;
class
ConditionVariable
{
public
:
struct
PlatformData
;
ConditionVariable
(
)
=
default
;
~
ConditionVariable
(
)
=
default
;
void
notify_one
(
)
{
impl_
.
notify_one
(
)
;
}
void
notify_all
(
)
{
impl_
.
notify_all
(
)
;
}
void
wait
(
Mutex
&
lock
)
{
#
ifdef
DEBUG
lock
.
preUnlockChecks
(
)
;
#
endif
impl_
.
wait
(
lock
.
impl_
)
;
#
ifdef
DEBUG
lock
.
preLockChecks
(
)
;
lock
.
postLockChecks
(
)
;
#
endif
}
void
wait
(
UniqueLock
<
Mutex
>
&
lock
)
{
wait
(
lock
.
lock
)
;
}
template
<
typename
Predicate
>
void
wait
(
UniqueLock
<
Mutex
>
&
lock
Predicate
pred
)
{
while
(
!
pred
(
)
)
{
wait
(
lock
)
;
}
}
CVStatus
wait_until
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeStamp
&
abs_time
)
{
return
wait_for
(
lock
abs_time
-
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
;
}
template
<
typename
Predicate
>
bool
wait_until
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeStamp
&
abs_time
Predicate
pred
)
{
while
(
!
pred
(
)
)
{
if
(
wait_until
(
lock
abs_time
)
=
=
CVStatus
:
:
Timeout
)
{
return
pred
(
)
;
}
}
return
true
;
}
CVStatus
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
)
{
#
ifdef
DEBUG
lock
.
lock
.
preUnlockChecks
(
)
;
#
endif
CVStatus
res
=
impl_
.
wait_for
(
lock
.
lock
.
impl_
rel_time
)
=
=
mozilla
:
:
CVStatus
:
:
Timeout
?
CVStatus
:
:
Timeout
:
CVStatus
:
:
NoTimeout
;
#
ifdef
DEBUG
lock
.
lock
.
preLockChecks
(
)
;
lock
.
lock
.
postLockChecks
(
)
;
#
endif
return
res
;
}
template
<
typename
Predicate
>
bool
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
Predicate
pred
)
{
return
wait_until
(
lock
mozilla
:
:
TimeStamp
:
:
Now
(
)
+
rel_time
std
:
:
move
(
pred
)
)
;
}
private
:
ConditionVariable
(
const
ConditionVariable
&
)
=
delete
;
ConditionVariable
&
operator
=
(
const
ConditionVariable
&
)
=
delete
;
template
<
class
T
>
friend
class
ExclusiveWaitableData
;
mozilla
:
:
detail
:
:
ConditionVariableImpl
impl_
;
}
;
}
#
endif
