#
ifndef
threading_Thread_h
#
define
threading_Thread_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
<
stdint
.
h
>
#
include
"
js
/
Utility
.
h
"
#
ifdef
XP_WIN
#
define
THREAD_RETURN_TYPE
unsigned
int
#
define
THREAD_CALL_API
__stdcall
#
else
#
define
THREAD_RETURN_TYPE
void
*
#
define
THREAD_CALL_API
#
endif
namespace
js
{
namespace
detail
{
template
<
typename
F
typename
.
.
.
Args
>
class
ThreadTrampoline
;
}
class
Thread
{
public
:
struct
Hasher
;
class
Id
{
friend
struct
Hasher
;
class
PlatformData
;
void
*
platformData_
[
2
]
;
public
:
Id
(
)
;
Id
(
const
Id
&
)
=
default
;
Id
(
Id
&
&
)
=
default
;
Id
&
operator
=
(
const
Id
&
)
=
default
;
Id
&
operator
=
(
Id
&
&
)
=
default
;
bool
operator
=
=
(
const
Id
&
aOther
)
const
;
bool
operator
!
=
(
const
Id
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
inline
PlatformData
*
platformData
(
)
;
inline
const
PlatformData
*
platformData
(
)
const
;
}
;
class
Options
{
size_t
stackSize_
;
public
:
Options
(
)
:
stackSize_
(
0
)
{
}
Options
&
setStackSize
(
size_t
sz
)
{
stackSize_
=
sz
;
return
*
this
;
}
size_t
stackSize
(
)
const
{
return
stackSize_
;
}
}
;
struct
Hasher
{
typedef
Id
Lookup
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
Id
&
key
const
Lookup
&
lookup
)
{
return
key
=
=
lookup
;
}
}
;
template
<
typename
O
=
Options
typename
NonConstO
=
typename
mozilla
:
:
RemoveConst
<
O
>
:
:
Type
typename
DerefO
=
typename
mozilla
:
:
RemoveReference
<
NonConstO
>
:
:
Type
typename
=
typename
mozilla
:
:
EnableIf
<
mozilla
:
:
IsSame
<
DerefO
Options
>
:
:
value
void
*
>
:
:
Type
>
explicit
Thread
(
O
&
&
options
=
Options
(
)
)
:
id_
(
Id
(
)
)
options_
(
mozilla
:
:
Forward
<
O
>
(
options
)
)
{
}
template
<
typename
F
typename
.
.
.
Args
>
MOZ_MUST_USE
bool
init
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
MOZ_RELEASE_ASSERT
(
!
joinable
(
)
)
;
using
Trampoline
=
detail
:
:
ThreadTrampoline
<
F
Args
.
.
.
>
;
AutoEnterOOMUnsafeRegion
oom
;
auto
trampoline
=
js_new
<
Trampoline
>
(
mozilla
:
:
Forward
<
F
>
(
f
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
trampoline
)
oom
.
crash
(
"
js
:
:
Thread
:
:
init
"
)
;
return
create
(
Trampoline
:
:
Start
trampoline
)
;
}
~
Thread
(
)
{
MOZ_RELEASE_ASSERT
(
!
joinable
(
)
)
;
}
void
detach
(
)
;
void
join
(
)
;
bool
joinable
(
)
const
{
return
get_id
(
)
!
=
Id
(
)
;
}
Id
get_id
(
)
const
{
return
id_
;
}
Thread
(
Thread
&
&
aOther
)
;
Thread
&
operator
=
(
Thread
&
&
aOther
)
;
private
:
Thread
(
const
Thread
&
)
=
delete
;
void
operator
=
(
const
Thread
&
)
=
delete
;
Id
id_
;
Options
options_
;
MOZ_MUST_USE
bool
create
(
THREAD_RETURN_TYPE
(
THREAD_CALL_API
*
aMain
)
(
void
*
)
void
*
aArg
)
;
}
;
namespace
ThisThread
{
Thread
:
:
Id
GetId
(
)
;
void
SetName
(
const
char
*
name
)
;
void
GetName
(
char
*
nameBuffer
size_t
len
)
;
}
namespace
detail
{
template
<
typename
F
typename
.
.
.
Args
>
class
ThreadTrampoline
{
F
f
;
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Args
>
:
:
Type
.
.
.
>
args
;
public
:
template
<
typename
G
typename
.
.
.
ArgsT
>
explicit
ThreadTrampoline
(
G
&
&
aG
ArgsT
&
&
.
.
.
aArgsT
)
:
f
(
mozilla
:
:
Forward
<
F
>
(
aG
)
)
args
(
mozilla
:
:
Forward
<
Args
>
(
aArgsT
)
.
.
.
)
{
}
static
THREAD_RETURN_TYPE
THREAD_CALL_API
Start
(
void
*
aPack
)
{
auto
*
pack
=
static_cast
<
ThreadTrampoline
<
F
Args
.
.
.
>
*
>
(
aPack
)
;
pack
-
>
callMain
(
typename
mozilla
:
:
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
)
;
js_delete
(
pack
)
;
return
0
;
}
template
<
size_t
.
.
.
Indices
>
void
callMain
(
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
{
f
(
mozilla
:
:
Get
<
Indices
>
(
args
)
.
.
.
)
;
}
}
;
}
}
#
undef
THREAD_RETURN_TYPE
#
endif
