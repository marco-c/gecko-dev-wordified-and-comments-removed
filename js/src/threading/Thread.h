#
ifndef
threading_Thread_h
#
define
threading_Thread_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
ThreadId
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
ifdef
XP_WIN
#
define
THREAD_RETURN_TYPE
unsigned
int
#
define
THREAD_CALL_API
__stdcall
#
else
#
define
THREAD_RETURN_TYPE
void
*
#
define
THREAD_CALL_API
#
endif
namespace
js
{
namespace
detail
{
template
<
typename
F
typename
.
.
.
Args
>
class
ThreadTrampoline
;
}
class
Thread
{
public
:
class
Options
{
size_t
stackSize_
;
public
:
Options
(
)
:
stackSize_
(
0
)
{
}
Options
&
setStackSize
(
size_t
sz
)
{
stackSize_
=
sz
;
return
*
this
;
}
size_t
stackSize
(
)
const
{
return
stackSize_
;
}
}
;
template
<
typename
O
=
Options
typename
NonConstO
=
std
:
:
remove_const_t
<
O
>
typename
DerefO
=
std
:
:
remove_reference_t
<
NonConstO
>
typename
=
std
:
:
enable_if_t
<
std
:
:
is_same_v
<
DerefO
Options
>
>
>
explicit
Thread
(
O
&
&
options
=
Options
(
)
)
:
id_
(
ThreadId
(
)
)
options_
(
std
:
:
forward
<
O
>
(
options
)
)
{
MOZ_ASSERT
(
isInitialized
(
)
)
;
}
template
<
typename
F
typename
.
.
.
Args
>
[
[
nodiscard
]
]
bool
init
(
F
&
&
f
Args
&
&
.
.
.
args
)
{
MOZ_RELEASE_ASSERT
(
id_
=
=
ThreadId
(
)
)
;
using
Trampoline
=
detail
:
:
ThreadTrampoline
<
F
Args
.
.
.
>
;
auto
trampoline
=
js_new
<
Trampoline
>
(
std
:
:
forward
<
F
>
(
f
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
trampoline
)
{
return
false
;
}
LockGuard
<
Mutex
>
lock
(
trampoline
-
>
createMutex
)
;
return
create
(
Trampoline
:
:
Start
trampoline
)
;
}
~
Thread
(
)
;
void
detach
(
)
;
void
join
(
)
;
bool
joinable
(
)
;
ThreadId
get_id
(
)
;
Thread
(
Thread
&
&
aOther
)
;
Thread
&
operator
=
(
Thread
&
&
aOther
)
;
private
:
Thread
(
const
Thread
&
)
=
delete
;
void
operator
=
(
const
Thread
&
)
=
delete
;
ThreadId
id_
;
Options
options_
;
[
[
nodiscard
]
]
bool
create
(
THREAD_RETURN_TYPE
(
THREAD_CALL_API
*
aMain
)
(
void
*
)
void
*
aArg
)
;
static
inline
bool
isInitialized
(
)
{
using
namespace
JS
:
:
detail
;
return
libraryInitState
=
=
InitState
:
:
Initializing
|
|
libraryInitState
=
=
InitState
:
:
Running
;
}
}
;
namespace
ThisThread
{
void
SetName
(
const
char
*
name
)
;
void
GetName
(
char
*
nameBuffer
size_t
len
)
;
void
SleepMilliseconds
(
size_t
ms
)
;
}
namespace
detail
{
template
<
typename
F
typename
.
.
.
Args
>
class
ThreadTrampoline
{
F
f
;
mozilla
:
:
Tuple
<
std
:
:
decay_t
<
Args
>
.
.
.
>
args
;
Mutex
createMutex
MOZ_UNANNOTATED
;
friend
class
js
:
:
Thread
;
public
:
template
<
typename
G
typename
.
.
.
ArgsT
>
explicit
ThreadTrampoline
(
G
&
&
aG
ArgsT
&
&
.
.
.
aArgsT
)
:
f
(
std
:
:
forward
<
F
>
(
aG
)
)
args
(
std
:
:
forward
<
Args
>
(
aArgsT
)
.
.
.
)
createMutex
(
mutexid
:
:
ThreadId
)
{
}
static
THREAD_RETURN_TYPE
THREAD_CALL_API
Start
(
void
*
aPack
)
{
auto
*
pack
=
static_cast
<
ThreadTrampoline
<
F
Args
.
.
.
>
*
>
(
aPack
)
;
pack
-
>
callMain
(
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
js_delete
(
pack
)
;
return
0
;
}
template
<
size_t
.
.
.
Indices
>
void
callMain
(
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
createMutex
.
lock
(
)
;
createMutex
.
unlock
(
)
;
f
(
std
:
:
move
(
mozilla
:
:
Get
<
Indices
>
(
args
)
)
.
.
.
)
;
}
}
;
}
}
#
undef
THREAD_RETURN_TYPE
#
endif
