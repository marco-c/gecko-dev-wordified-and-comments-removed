#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
float
.
h
>
#
include
<
intrin
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
windows
.
h
>
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
windows
/
MutexPlatformData
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
InterlockedExchangeAdd
)
#
define
InterlockedExchangeAdd
(
addend
value
)
\
_InterlockedExchangeAdd
(
(
volatile
long
*
)
(
addend
)
(
long
)
(
value
)
)
#
endif
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
InterlockedIncrement
)
#
define
InterlockedIncrement
(
addend
)
\
_InterlockedIncrement
(
(
volatile
long
*
)
(
addend
)
)
#
endif
struct
js
:
:
ConditionVariable
:
:
PlatformData
{
CONDITION_VARIABLE
cv_
;
}
;
js
:
:
ConditionVariable
:
:
ConditionVariable
(
)
{
InitializeConditionVariable
(
&
platformData
(
)
-
>
cv_
)
;
}
void
js
:
:
ConditionVariable
:
:
notify_one
(
)
{
WakeConditionVariable
(
&
platformData
(
)
-
>
cv_
)
;
}
void
js
:
:
ConditionVariable
:
:
notify_all
(
)
{
WakeAllConditionVariable
(
&
platformData
(
)
-
>
cv_
)
;
}
void
js
:
:
ConditionVariable
:
:
wait
(
UniqueLock
<
Mutex
>
&
lock
)
{
CRITICAL_SECTION
*
cs
=
&
lock
.
lock
.
platformData
(
)
-
>
criticalSection
;
bool
r
=
SleepConditionVariableCS
(
&
platformData
(
)
-
>
cv_
cs
INFINITE
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
}
js
:
:
CVStatus
js
:
:
ConditionVariable
:
:
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
)
{
CRITICAL_SECTION
*
cs
=
&
lock
.
lock
.
platformData
(
)
-
>
criticalSection
;
double
msecd
=
rel_time
.
ToMilliseconds
(
)
;
DWORD
msec
=
msecd
<
0
.
0
?
0
:
msecd
>
UINT32_MAX
?
INFINITE
:
static_cast
<
DWORD
>
(
msecd
)
;
BOOL
r
=
SleepConditionVariableCS
(
&
platformData
(
)
-
>
cv_
cs
msec
)
;
if
(
r
)
return
CVStatus
:
:
NoTimeout
;
MOZ_RELEASE_ASSERT
(
GetLastError
(
)
=
=
ERROR_TIMEOUT
)
;
return
CVStatus
:
:
Timeout
;
}
js
:
:
ConditionVariable
:
:
~
ConditionVariable
(
)
{
}
inline
js
:
:
ConditionVariable
:
:
PlatformData
*
js
:
:
ConditionVariable
:
:
platformData
(
)
{
static_assert
(
sizeof
platformData_
>
=
sizeof
(
PlatformData
)
"
platformData_
is
too
small
"
)
;
return
reinterpret_cast
<
PlatformData
*
>
(
platformData_
)
;
}
