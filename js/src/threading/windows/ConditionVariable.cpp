#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
float
.
h
>
#
include
<
intrin
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
windows
.
h
>
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
windows
/
MutexPlatformData
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
InterlockedExchangeAdd
)
#
define
InterlockedExchangeAdd
(
addend
value
)
\
_InterlockedExchangeAdd
(
(
volatile
long
*
)
(
addend
)
(
long
)
(
value
)
)
#
endif
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
InterlockedIncrement
)
#
define
InterlockedIncrement
(
addend
)
\
_InterlockedIncrement
(
(
volatile
long
*
)
(
addend
)
)
#
endif
class
ConditionVariableNativeImports
{
public
:
ConditionVariableNativeImports
(
)
{
HMODULE
kernel32_dll
=
GetModuleHandle
(
"
kernel32
.
dll
"
)
;
MOZ_RELEASE_ASSERT
(
kernel32_dll
!
=
NULL
)
;
#
define
LOAD_SYMBOL
(
symbol
)
loadSymbol
(
kernel32_dll
#
symbol
symbol
)
supported_
=
LOAD_SYMBOL
(
InitializeConditionVariable
)
&
&
LOAD_SYMBOL
(
WakeConditionVariable
)
&
&
LOAD_SYMBOL
(
WakeAllConditionVariable
)
&
&
LOAD_SYMBOL
(
SleepConditionVariableCS
)
;
#
undef
LOAD_SYMBOL
}
inline
bool
supported
(
)
const
{
return
supported_
;
}
void
(
WINAPI
*
InitializeConditionVariable
)
(
CONDITION_VARIABLE
*
ConditionVariable
)
;
void
(
WINAPI
*
WakeAllConditionVariable
)
(
PCONDITION_VARIABLE
ConditionVariable
)
;
void
(
WINAPI
*
WakeConditionVariable
)
(
CONDITION_VARIABLE
*
ConditionVariable
)
;
BOOL
(
WINAPI
*
SleepConditionVariableCS
)
(
CONDITION_VARIABLE
*
ConditionVariable
CRITICAL_SECTION
*
CriticalSection
DWORD
dwMilliseconds
)
;
private
:
template
<
typename
T
>
inline
bool
loadSymbol
(
HMODULE
module
const
char
*
name
T
&
fn
)
{
FARPROC
ptr
=
GetProcAddress
(
module
name
)
;
if
(
!
ptr
)
return
false
;
fn
=
reinterpret_cast
<
T
>
(
ptr
)
;
return
true
;
}
bool
supported_
;
}
;
static
ConditionVariableNativeImports
sNativeImports
;
struct
ConditionVariableNative
{
inline
void
initialize
(
)
{
sNativeImports
.
InitializeConditionVariable
(
&
cv_
)
;
}
inline
void
destroy
(
)
{
}
inline
void
notify_one
(
)
{
sNativeImports
.
WakeConditionVariable
(
&
cv_
)
;
}
inline
void
notify_all
(
)
{
sNativeImports
.
WakeAllConditionVariable
(
&
cv_
)
;
}
inline
bool
wait
(
CRITICAL_SECTION
*
cs
DWORD
msec
)
{
return
sNativeImports
.
SleepConditionVariableCS
(
&
cv_
cs
msec
)
;
}
private
:
CONDITION_VARIABLE
cv_
;
}
;
struct
ConditionVariableFallback
{
static
const
uint32_t
WAKEUP_MODE_NONE
=
0
;
static
const
uint32_t
WAKEUP_MODE_ONE
=
0x40000000
;
static
const
uint32_t
WAKEUP_MODE_ALL
=
0x80000000
;
static
const
uint32_t
WAKEUP_MODE_MASK
=
WAKEUP_MODE_ONE
|
WAKEUP_MODE_ALL
;
static
const
uint32_t
SLEEPERS_COUNT_MASK
=
~
WAKEUP_MODE_MASK
;
void
initialize
(
)
{
sleepersCountAndWakeupMode_
=
0
|
WAKEUP_MODE_NONE
;
sleepWakeupSemaphore_
=
CreateSemaphoreW
(
NULL
1
1
NULL
)
;
MOZ_RELEASE_ASSERT
(
sleepWakeupSemaphore_
)
;
wakeOneEvent_
=
CreateEventW
(
NULL
FALSE
FALSE
NULL
)
;
MOZ_RELEASE_ASSERT
(
wakeOneEvent_
)
;
wakeAllEvent_
=
CreateEventW
(
NULL
TRUE
FALSE
NULL
)
;
MOZ_RELEASE_ASSERT
(
wakeAllEvent_
)
;
}
void
destroy
(
)
{
BOOL
r
;
MOZ_RELEASE_ASSERT
(
sleepersCountAndWakeupMode_
=
=
(
0
|
WAKEUP_MODE_NONE
)
)
;
r
=
CloseHandle
(
sleepWakeupSemaphore_
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
r
=
CloseHandle
(
wakeOneEvent_
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
r
=
CloseHandle
(
wakeAllEvent_
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
}
private
:
void
wakeup
(
uint32_t
wakeupMode
HANDLE
wakeEvent
)
{
BOOL
result
=
WaitForSingleObject
(
sleepWakeupSemaphore_
INFINITE
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
WAIT_OBJECT_0
)
;
uint32_t
wcwm
=
InterlockedExchangeAdd
(
&
sleepersCountAndWakeupMode_
wakeupMode
)
;
uint32_t
sleepersCount
=
wcwm
&
SLEEPERS_COUNT_MASK
;
MOZ_RELEASE_ASSERT
(
(
wcwm
&
WAKEUP_MODE_MASK
)
=
=
WAKEUP_MODE_NONE
)
;
if
(
sleepersCount
>
0
)
{
BOOL
success
=
SetEvent
(
wakeEvent
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
else
{
sleepersCountAndWakeupMode_
=
0
|
WAKEUP_MODE_NONE
;
BOOL
success
=
ReleaseSemaphore
(
sleepWakeupSemaphore_
1
NULL
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
}
public
:
void
notify_one
(
)
{
wakeup
(
WAKEUP_MODE_ONE
wakeOneEvent_
)
;
}
void
notify_all
(
)
{
wakeup
(
WAKEUP_MODE_ALL
wakeAllEvent_
)
;
}
bool
wait
(
CRITICAL_SECTION
*
userLock
DWORD
msec
)
{
DWORD
result
=
WaitForSingleObject
(
sleepWakeupSemaphore_
INFINITE
)
;
MOZ_RELEASE_ASSERT
(
result
=
=
WAIT_OBJECT_0
)
;
uint32_t
wcwm
=
InterlockedIncrement
(
&
sleepersCountAndWakeupMode_
)
;
MOZ_RELEASE_ASSERT
(
(
wcwm
&
WAKEUP_MODE_MASK
)
=
=
WAKEUP_MODE_NONE
)
;
BOOL
success
=
ReleaseSemaphore
(
sleepWakeupSemaphore_
1
NULL
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
LeaveCriticalSection
(
userLock
)
;
HANDLE
handles
[
2
]
=
{
wakeOneEvent_
wakeAllEvent_
}
;
DWORD
waitResult
=
WaitForMultipleObjects
(
2
handles
FALSE
msec
)
;
MOZ_RELEASE_ASSERT
(
waitResult
=
=
WAIT_OBJECT_0
|
|
waitResult
=
=
WAIT_OBJECT_0
+
1
|
|
(
waitResult
=
=
WAIT_TIMEOUT
&
&
msec
!
=
INFINITE
)
)
;
uint32_t
sub
;
if
(
waitResult
=
=
WAIT_OBJECT_0
)
sub
=
1
|
WAKEUP_MODE_ONE
;
else
sub
=
1
;
wcwm
=
InterlockedExchangeAdd
(
&
sleepersCountAndWakeupMode_
-
sub
)
-
sub
;
uint32_t
wakeupMode
=
wcwm
&
WAKEUP_MODE_MASK
;
uint32_t
sleepersCount
=
wcwm
&
SLEEPERS_COUNT_MASK
;
bool
releaseSleepWakeupSemaphore
=
false
;
if
(
waitResult
=
=
WAIT_OBJECT_0
)
{
MOZ_RELEASE_ASSERT
(
wakeupMode
=
=
WAKEUP_MODE_NONE
)
;
releaseSleepWakeupSemaphore
=
true
;
}
else
if
(
waitResult
=
=
WAIT_TIMEOUT
&
&
wakeupMode
=
=
WAKEUP_MODE_ONE
&
&
sleepersCount
=
=
0
)
{
BOOL
success
=
ResetEvent
(
wakeOneEvent_
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
sleepersCountAndWakeupMode_
=
0
|
WAKEUP_MODE_NONE
;
releaseSleepWakeupSemaphore
=
true
;
}
else
if
(
wakeupMode
=
=
WAKEUP_MODE_ALL
&
&
sleepersCount
=
=
0
)
{
MOZ_RELEASE_ASSERT
(
waitResult
=
WAIT_OBJECT_0
+
1
|
|
waitResult
=
=
WAIT_TIMEOUT
)
;
BOOL
success
=
ResetEvent
(
wakeAllEvent_
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
sleepersCountAndWakeupMode_
=
0
|
WAKEUP_MODE_NONE
;
releaseSleepWakeupSemaphore
=
true
;
}
else
if
(
(
waitResult
=
=
WAIT_TIMEOUT
&
&
msec
!
=
INFINITE
)
|
|
(
waitResult
=
=
WAIT_OBJECT_0
+
1
&
&
wakeupMode
=
=
WAKEUP_MODE_ALL
)
)
{
}
else
{
MOZ_CRASH
(
"
invalid
wakeup
condition
"
)
;
}
if
(
releaseSleepWakeupSemaphore
)
{
BOOL
success
=
ReleaseSemaphore
(
sleepWakeupSemaphore_
1
NULL
)
;
MOZ_RELEASE_ASSERT
(
success
)
;
}
EnterCriticalSection
(
userLock
)
;
if
(
waitResult
=
=
WAIT_TIMEOUT
)
{
SetLastError
(
ERROR_TIMEOUT
)
;
return
false
;
}
return
true
;
}
private
:
uint32_t
sleepersCountAndWakeupMode_
;
HANDLE
sleepWakeupSemaphore_
;
HANDLE
wakeOneEvent_
;
HANDLE
wakeAllEvent_
;
}
;
struct
js
:
:
ConditionVariable
:
:
PlatformData
{
union
{
ConditionVariableNative
native
;
ConditionVariableFallback
fallback
;
}
;
}
;
js
:
:
ConditionVariable
:
:
ConditionVariable
(
)
{
if
(
sNativeImports
.
supported
(
)
)
platformData
(
)
-
>
native
.
initialize
(
)
;
else
platformData
(
)
-
>
fallback
.
initialize
(
)
;
}
void
js
:
:
ConditionVariable
:
:
notify_one
(
)
{
if
(
sNativeImports
.
supported
(
)
)
platformData
(
)
-
>
native
.
notify_one
(
)
;
else
platformData
(
)
-
>
fallback
.
notify_one
(
)
;
}
void
js
:
:
ConditionVariable
:
:
notify_all
(
)
{
if
(
sNativeImports
.
supported
(
)
)
platformData
(
)
-
>
native
.
notify_all
(
)
;
else
platformData
(
)
-
>
fallback
.
notify_all
(
)
;
}
void
js
:
:
ConditionVariable
:
:
wait
(
UniqueLock
<
Mutex
>
&
lock
)
{
CRITICAL_SECTION
*
cs
=
&
lock
.
lock
.
platformData
(
)
-
>
criticalSection
;
bool
r
;
if
(
sNativeImports
.
supported
(
)
)
r
=
platformData
(
)
-
>
native
.
wait
(
cs
INFINITE
)
;
else
r
=
platformData
(
)
-
>
fallback
.
wait
(
cs
INFINITE
)
;
MOZ_RELEASE_ASSERT
(
r
)
;
}
js
:
:
CVStatus
js
:
:
ConditionVariable
:
:
wait_until
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeStamp
&
abs_time
)
{
return
wait_for
(
lock
abs_time
-
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
;
}
js
:
:
CVStatus
js
:
:
ConditionVariable
:
:
wait_for
(
UniqueLock
<
Mutex
>
&
lock
const
mozilla
:
:
TimeDuration
&
rel_time
)
{
CRITICAL_SECTION
*
cs
=
&
lock
.
lock
.
platformData
(
)
-
>
criticalSection
;
double
msecd
=
rel_time
.
ToMilliseconds
(
)
;
DWORD
msec
=
msecd
<
0
.
0
?
0
:
msecd
>
DBL_MAX
?
INFINITE
:
static_cast
<
DWORD
>
(
msecd
)
;
BOOL
r
;
if
(
sNativeImports
.
supported
(
)
)
r
=
platformData
(
)
-
>
native
.
wait
(
cs
msec
)
;
else
r
=
platformData
(
)
-
>
fallback
.
wait
(
cs
msec
)
;
if
(
r
)
return
CVStatus
:
:
NoTimeout
;
MOZ_RELEASE_ASSERT
(
GetLastError
(
)
=
=
ERROR_TIMEOUT
)
;
return
CVStatus
:
:
Timeout
;
}
js
:
:
ConditionVariable
:
:
~
ConditionVariable
(
)
{
if
(
sNativeImports
.
supported
(
)
)
platformData
(
)
-
>
native
.
destroy
(
)
;
else
platformData
(
)
-
>
fallback
.
destroy
(
)
;
}
inline
js
:
:
ConditionVariable
:
:
PlatformData
*
js
:
:
ConditionVariable
:
:
platformData
(
)
{
static_assert
(
sizeof
platformData_
>
=
sizeof
(
PlatformData
)
"
platformData_
is
too
small
"
)
;
return
reinterpret_cast
<
PlatformData
*
>
(
platformData_
)
;
}
