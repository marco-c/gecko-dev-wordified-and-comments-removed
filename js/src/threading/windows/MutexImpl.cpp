#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
jswin
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
windows
/
MutexPlatformData
.
h
"
namespace
{
struct
MutexNativeImports
{
using
InitializeCriticalSectionExT
=
BOOL
(
WINAPI
*
)
(
CRITICAL_SECTION
*
DWORD
DWORD
)
;
InitializeCriticalSectionExT
InitializeCriticalSectionEx
;
MutexNativeImports
(
)
{
HMODULE
kernel32_dll
=
GetModuleHandle
(
"
kernel32
.
dll
"
)
;
MOZ_RELEASE_ASSERT
(
kernel32_dll
!
=
NULL
)
;
InitializeCriticalSectionEx
=
reinterpret_cast
<
InitializeCriticalSectionExT
>
(
GetProcAddress
(
kernel32_dll
"
InitializeCriticalSectionEx
"
)
)
;
}
bool
hasInitializeCriticalSectionEx
(
)
const
{
return
InitializeCriticalSectionEx
;
}
}
;
static
MutexNativeImports
NativeImports
;
}
js
:
:
detail
:
:
MutexImpl
:
:
MutexImpl
(
)
{
AutoEnterOOMUnsafeRegion
oom
;
platformData_
=
js_new
<
PlatformData
>
(
)
;
if
(
!
platformData_
)
oom
.
crash
(
"
js
:
:
Mutex
:
:
Mutex
"
)
;
const
static
DWORD
LockSpinCount
=
1500
;
BOOL
r
;
if
(
NativeImports
.
hasInitializeCriticalSectionEx
(
)
)
{
r
=
NativeImports
.
InitializeCriticalSectionEx
(
&
platformData
(
)
-
>
criticalSection
LockSpinCount
CRITICAL_SECTION_NO_DEBUG_INFO
)
;
}
else
{
r
=
InitializeCriticalSectionAndSpinCount
(
&
platformData
(
)
-
>
criticalSection
LockSpinCount
)
;
}
MOZ_RELEASE_ASSERT
(
r
)
;
}
js
:
:
detail
:
:
MutexImpl
:
:
~
MutexImpl
(
)
{
if
(
!
platformData_
)
return
;
DeleteCriticalSection
(
&
platformData
(
)
-
>
criticalSection
)
;
js_delete
(
platformData
(
)
)
;
}
void
js
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
{
EnterCriticalSection
(
&
platformData
(
)
-
>
criticalSection
)
;
}
void
js
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
{
LeaveCriticalSection
(
&
platformData
(
)
-
>
criticalSection
)
;
}
