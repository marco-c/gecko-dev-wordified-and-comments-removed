#
include
"
frontend
/
Parser
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
FoldConstants
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
jsatominlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
frontend
/
ParseNode
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
Some
;
using
JS
:
:
AutoGCRooter
;
namespace
js
{
namespace
frontend
{
using
DeclaredNamePtr
=
ParseContext
:
:
Scope
:
:
DeclaredNamePtr
;
using
AddDeclaredNamePtr
=
ParseContext
:
:
Scope
:
:
AddDeclaredNamePtr
;
using
BindingIter
=
ParseContext
:
:
Scope
:
:
BindingIter
;
using
UsedNamePtr
=
UsedNameTracker
:
:
UsedNameMap
:
:
Ptr
;
#
define
MUST_MATCH_TOKEN_MOD
(
tt
modifier
errorNumber
)
\
JS_BEGIN_MACRO
\
TokenKind
token
;
\
if
(
!
tokenStream
.
getToken
(
&
token
modifier
)
)
\
return
null
(
)
;
\
if
(
token
!
=
tt
)
{
\
error
(
errorNumber
)
;
\
return
null
(
)
;
\
}
\
JS_END_MACRO
#
define
MUST_MATCH_TOKEN
(
tt
errno
)
MUST_MATCH_TOKEN_MOD
(
tt
TokenStream
:
:
None
errno
)
template
<
class
T
class
U
>
static
inline
void
PropagateTransitiveParseFlags
(
const
T
*
inner
U
*
outer
)
{
if
(
inner
-
>
bindingsAccessedDynamically
(
)
)
outer
-
>
setBindingsAccessedDynamically
(
)
;
if
(
inner
-
>
hasDebuggerStatement
(
)
)
outer
-
>
setHasDebuggerStatement
(
)
;
if
(
inner
-
>
hasDirectEval
(
)
)
outer
-
>
setHasDirectEval
(
)
;
}
static
const
char
*
DeclarationKindString
(
DeclarationKind
kind
)
{
switch
(
kind
)
{
case
DeclarationKind
:
:
PositionalFormalParameter
:
case
DeclarationKind
:
:
FormalParameter
:
return
"
formal
parameter
"
;
case
DeclarationKind
:
:
CoverArrowParameter
:
return
"
cover
arrow
parameter
"
;
case
DeclarationKind
:
:
Var
:
return
"
var
"
;
case
DeclarationKind
:
:
Let
:
return
"
let
"
;
case
DeclarationKind
:
:
Const
:
return
"
const
"
;
case
DeclarationKind
:
:
Import
:
return
"
import
"
;
case
DeclarationKind
:
:
BodyLevelFunction
:
case
DeclarationKind
:
:
LexicalFunction
:
return
"
function
"
;
case
DeclarationKind
:
:
VarForAnnexBLexicalFunction
:
return
"
annex
b
var
"
;
case
DeclarationKind
:
:
ForOfVar
:
return
"
var
in
for
-
of
"
;
case
DeclarationKind
:
:
SimpleCatchParameter
:
case
DeclarationKind
:
:
CatchParameter
:
return
"
catch
parameter
"
;
}
MOZ_CRASH
(
"
Bad
DeclarationKind
"
)
;
}
static
bool
StatementKindIsBraced
(
StatementKind
kind
)
{
return
kind
=
=
StatementKind
:
:
Block
|
|
kind
=
=
StatementKind
:
:
Switch
|
|
kind
=
=
StatementKind
:
:
Try
|
|
kind
=
=
StatementKind
:
:
Catch
|
|
kind
=
=
StatementKind
:
:
Finally
;
}
void
ParseContext
:
:
Scope
:
:
dump
(
ParseContext
*
pc
)
{
JSContext
*
cx
=
pc
-
>
sc
(
)
-
>
context
;
fprintf
(
stdout
"
ParseScope
%
p
"
this
)
;
fprintf
(
stdout
"
\
n
decls
:
\
n
"
)
;
for
(
DeclaredNameMap
:
:
Range
r
=
declared_
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
cx
r
.
front
(
)
.
key
(
)
&
bytes
)
)
return
;
DeclaredNameInfo
&
info
=
r
.
front
(
)
.
value
(
)
.
wrapped
;
fprintf
(
stdout
"
%
s
%
s
%
s
\
n
"
DeclarationKindString
(
info
.
kind
(
)
)
bytes
.
ptr
(
)
info
.
closedOver
(
)
?
"
(
closed
over
)
"
:
"
"
)
;
}
fprintf
(
stdout
"
\
n
"
)
;
}
void
ParseContext
:
:
Scope
:
:
removeVarForAnnexBLexicalFunction
(
ParseContext
*
pc
JSAtom
*
name
)
{
MOZ_ASSERT
(
!
pc
-
>
sc
(
)
-
>
strictScript
)
;
for
(
ParseContext
:
:
Scope
*
scope
=
pc
-
>
innermostScope
(
)
;
scope
!
=
pc
-
>
varScope
(
)
.
enclosing
(
)
;
scope
=
scope
-
>
enclosing
(
)
)
{
if
(
DeclaredNamePtr
p
=
scope
-
>
declared_
-
>
lookup
(
name
)
)
{
if
(
p
-
>
value
(
)
-
>
kind
(
)
=
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
)
scope
-
>
declared_
-
>
remove
(
p
)
;
}
}
pc
-
>
removeInnerFunctionBoxesForAnnexB
(
name
)
;
}
static
bool
DeclarationKindIsCatchParameter
(
DeclarationKind
kind
)
{
return
kind
=
=
DeclarationKind
:
:
SimpleCatchParameter
|
|
kind
=
=
DeclarationKind
:
:
CatchParameter
;
}
bool
ParseContext
:
:
Scope
:
:
addCatchParameters
(
ParseContext
*
pc
Scope
&
catchParamScope
)
{
if
(
pc
-
>
useAsmOrInsideUseAsm
(
)
)
return
true
;
for
(
DeclaredNameMap
:
:
Range
r
=
catchParamScope
.
declared_
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
DeclarationKind
kind
=
r
.
front
(
)
.
value
(
)
-
>
kind
(
)
;
MOZ_ASSERT
(
DeclarationKindIsCatchParameter
(
kind
)
)
;
JSAtom
*
name
=
r
.
front
(
)
.
key
(
)
;
AddDeclaredNamePtr
p
=
lookupDeclaredNameForAdd
(
name
)
;
MOZ_ASSERT
(
!
p
)
;
if
(
!
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
}
return
true
;
}
void
ParseContext
:
:
Scope
:
:
removeCatchParameters
(
ParseContext
*
pc
Scope
&
catchParamScope
)
{
if
(
pc
-
>
useAsmOrInsideUseAsm
(
)
)
return
;
for
(
DeclaredNameMap
:
:
Range
r
=
catchParamScope
.
declared_
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
DeclaredNamePtr
p
=
declared_
-
>
lookup
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
p
)
;
if
(
DeclarationKindIsCatchParameter
(
r
.
front
(
)
.
value
(
)
-
>
kind
(
)
)
)
declared_
-
>
remove
(
p
)
;
}
}
void
SharedContext
:
:
computeAllowSyntax
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
continue
;
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
fun
-
>
isDerivedClassConstructor
(
)
;
return
;
}
}
}
void
SharedContext
:
:
computeThisBinding
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
return
;
}
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
|
|
fun
-
>
nonLazyScript
(
)
-
>
isGeneratorExp
(
)
)
continue
;
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
needsThisTDZChecks_
=
true
;
thisBinding_
=
ThisBinding
:
:
Function
;
return
;
}
}
thisBinding_
=
ThisBinding
:
:
Global
;
}
void
SharedContext
:
:
computeInWith
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
inWith_
=
true
;
break
;
}
}
}
EvalSharedContext
:
:
EvalSharedContext
(
JSContext
*
cx
JSObject
*
enclosingEnv
Scope
*
enclosingScope
Directives
directives
bool
extraWarnings
)
:
SharedContext
(
cx
Kind
:
:
Eval
directives
extraWarnings
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
{
computeAllowSyntax
(
enclosingScope
)
;
computeInWith
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
if
(
enclosingEnv
&
&
enclosingScope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
{
JSObject
*
env
=
enclosingEnv
;
while
(
env
)
{
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
env
=
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
.
environment
(
)
;
if
(
env
-
>
is
<
CallObject
>
(
)
)
{
computeThisBinding
(
env
-
>
as
<
CallObject
>
(
)
.
callee
(
)
.
nonLazyScript
(
)
-
>
bodyScope
(
)
)
;
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
}
}
bool
ParseContext
:
:
init
(
)
{
if
(
scriptId_
=
=
UINT32_MAX
)
{
tokenStream_
.
reportError
(
JSMSG_NEED_DIET
js_script_str
)
;
return
false
;
}
JSContext
*
cx
=
sc
(
)
-
>
context
;
if
(
isFunctionBox
(
)
)
{
RootedFunction
fun
(
cx
functionBox
(
)
-
>
function
(
)
)
;
if
(
fun
-
>
isNamedLambda
(
)
)
{
if
(
!
namedLambdaScope_
-
>
init
(
this
)
)
return
false
;
AddDeclaredNamePtr
p
=
namedLambdaScope_
-
>
lookupDeclaredNameForAdd
(
fun
-
>
explicitName
(
)
)
;
MOZ_ASSERT
(
!
p
)
;
if
(
!
namedLambdaScope_
-
>
addDeclaredName
(
this
p
fun
-
>
explicitName
(
)
DeclarationKind
:
:
Const
)
)
{
return
false
;
}
}
if
(
!
functionScope_
-
>
init
(
this
)
)
return
false
;
if
(
!
positionalFormalParameterNames_
.
acquire
(
cx
)
)
return
false
;
}
if
(
!
closedOverBindingsForLazy_
.
acquire
(
cx
)
)
return
false
;
if
(
!
sc
(
)
-
>
strict
(
)
)
{
if
(
!
innerFunctionBoxesForAnnexB_
.
acquire
(
cx
)
)
return
false
;
}
return
true
;
}
bool
ParseContext
:
:
addInnerFunctionBoxForAnnexB
(
FunctionBox
*
funbox
)
{
for
(
uint32_t
i
=
0
;
i
<
innerFunctionBoxesForAnnexB_
-
>
length
(
)
;
i
+
+
)
{
if
(
!
innerFunctionBoxesForAnnexB_
[
i
]
)
{
innerFunctionBoxesForAnnexB_
[
i
]
=
funbox
;
return
true
;
}
}
return
innerFunctionBoxesForAnnexB_
-
>
append
(
funbox
)
;
}
void
ParseContext
:
:
removeInnerFunctionBoxesForAnnexB
(
JSAtom
*
name
)
{
for
(
uint32_t
i
=
0
;
i
<
innerFunctionBoxesForAnnexB_
-
>
length
(
)
;
i
+
+
)
{
if
(
FunctionBox
*
funbox
=
innerFunctionBoxesForAnnexB_
[
i
]
)
{
if
(
funbox
-
>
function
(
)
-
>
explicitName
(
)
=
=
name
)
innerFunctionBoxesForAnnexB_
[
i
]
=
nullptr
;
}
}
}
void
ParseContext
:
:
finishInnerFunctionBoxesForAnnexB
(
)
{
if
(
sc
(
)
-
>
strict
(
)
|
|
!
innerFunctionBoxesForAnnexB_
)
return
;
for
(
uint32_t
i
=
0
;
i
<
innerFunctionBoxesForAnnexB_
-
>
length
(
)
;
i
+
+
)
{
if
(
FunctionBox
*
funbox
=
innerFunctionBoxesForAnnexB_
[
i
]
)
funbox
-
>
isAnnexB
=
true
;
}
}
ParseContext
:
:
~
ParseContext
(
)
{
finishInnerFunctionBoxesForAnnexB
(
)
;
}
bool
UsedNameTracker
:
:
noteUse
(
JSContext
*
cx
JSAtom
*
name
uint32_t
scriptId
uint32_t
scopeId
)
{
if
(
UsedNameMap
:
:
AddPtr
p
=
map_
.
lookupForAdd
(
name
)
)
{
if
(
!
p
-
>
value
(
)
.
noteUsedInScope
(
scriptId
scopeId
)
)
return
false
;
}
else
{
UsedNameInfo
info
(
cx
)
;
if
(
!
info
.
noteUsedInScope
(
scriptId
scopeId
)
)
return
false
;
if
(
!
map_
.
add
(
p
name
Move
(
info
)
)
)
return
false
;
}
return
true
;
}
void
UsedNameTracker
:
:
UsedNameInfo
:
:
resetToScope
(
uint32_t
scriptId
uint32_t
scopeId
)
{
while
(
!
uses_
.
empty
(
)
)
{
Use
&
innermost
=
uses_
.
back
(
)
;
if
(
innermost
.
scopeId
<
scopeId
)
break
;
MOZ_ASSERT
(
innermost
.
scriptId
>
=
scriptId
)
;
uses_
.
popBack
(
)
;
}
}
void
UsedNameTracker
:
:
rewind
(
RewindToken
token
)
{
scriptCounter_
=
token
.
scriptId
;
scopeCounter_
=
token
.
scopeId
;
for
(
UsedNameMap
:
:
Range
r
=
map_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
r
.
front
(
)
.
value
(
)
.
resetToScope
(
token
.
scriptId
token
.
scopeId
)
;
}
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
LifoAlloc
&
alloc
ObjectBox
*
traceListHead
JSFunction
*
fun
Directives
directives
bool
extraWarnings
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
)
:
ObjectBox
(
fun
traceListHead
)
SharedContext
(
cx
Kind
:
:
ObjectBox
directives
extraWarnings
)
enclosingScope_
(
nullptr
)
namedLambdaBindings_
(
nullptr
)
functionScopeBindings_
(
nullptr
)
extraVarScopeBindings_
(
nullptr
)
functionNode
(
nullptr
)
bufStart
(
0
)
bufEnd
(
0
)
startLine
(
1
)
startColumn
(
0
)
length
(
0
)
generatorKindBits_
(
GeneratorKindAsBits
(
generatorKind
)
)
asyncKindBits_
(
AsyncKindAsBits
(
asyncKind
)
)
isGenexpLambda
(
false
)
hasDestructuringArgs
(
false
)
hasParameterExprs
(
false
)
hasDirectEvalInParameterExpr
(
false
)
hasDuplicateParameters
(
false
)
useAsm
(
false
)
insideUseAsm
(
false
)
isAnnexB
(
false
)
wasEmitted
(
false
)
declaredArguments
(
false
)
usesArguments
(
false
)
usesApply
(
false
)
usesThis
(
false
)
usesReturn
(
false
)
hasRest_
(
false
)
isExprBody_
(
false
)
funCxFlags
(
)
{
MOZ_ASSERT
(
fun
-
>
isTenured
(
)
)
;
}
void
FunctionBox
:
:
initFromLazyFunction
(
)
{
JSFunction
*
fun
=
function
(
)
;
if
(
fun
-
>
lazyScript
(
)
-
>
isDerivedClassConstructor
(
)
)
setDerivedClassConstructor
(
)
;
if
(
fun
-
>
lazyScript
(
)
-
>
needsHomeObject
(
)
)
setNeedsHomeObject
(
)
;
enclosingScope_
=
fun
-
>
lazyScript
(
)
-
>
enclosingScope
(
)
;
initWithEnclosingScope
(
enclosingScope_
)
;
}
void
FunctionBox
:
:
initStandaloneFunction
(
Scope
*
enclosingScope
)
{
MOZ_ASSERT
(
enclosingScope
-
>
is
<
GlobalScope
>
(
)
)
;
enclosingScope_
=
enclosingScope
;
allowNewTarget_
=
true
;
thisBinding_
=
ThisBinding
:
:
Function
;
}
void
FunctionBox
:
:
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionSyntaxKind
kind
)
{
SharedContext
*
sc
=
enclosing
-
>
sc
(
)
;
useAsm
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
JSFunction
*
fun
=
function
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
allowNewTarget_
=
sc
-
>
allowNewTarget
(
)
;
allowSuperProperty_
=
sc
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
sc
-
>
allowSuperCall
(
)
;
needsThisTDZChecks_
=
sc
-
>
needsThisTDZChecks
(
)
;
thisBinding_
=
sc
-
>
thisBinding
(
)
;
}
else
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
if
(
kind
=
=
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
if
(
isGenexpLambda
)
thisBinding_
=
sc
-
>
thisBinding
(
)
;
else
thisBinding_
=
ThisBinding
:
:
Function
;
}
if
(
sc
-
>
inWith
(
)
)
{
inWith_
=
true
;
}
else
{
auto
isWith
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
With
;
}
;
inWith_
=
enclosing
-
>
findInnermostStatement
(
isWith
)
;
}
}
void
FunctionBox
:
:
initWithEnclosingScope
(
Scope
*
enclosingScope
)
{
if
(
!
function
(
)
-
>
isArrow
(
)
)
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
function
(
)
-
>
allowSuperProperty
(
)
;
if
(
isDerivedClassConstructor
(
)
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
thisBinding_
=
ThisBinding
:
:
Function
;
}
else
{
computeAllowSyntax
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
}
computeInWith
(
enclosingScope
)
;
}
void
ParserBase
:
:
error
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
#
ifdef
DEBUG
bool
result
=
#
endif
tokenStream
.
reportCompileErrorNumberVA
(
pos
(
)
.
begin
JSREPORT_ERROR
errorNumber
args
)
;
MOZ_ASSERT
(
!
result
"
reporting
an
error
returned
true
?
"
)
;
va_end
(
args
)
;
}
void
ParserBase
:
:
errorAt
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
#
ifdef
DEBUG
bool
result
=
#
endif
tokenStream
.
reportCompileErrorNumberVA
(
offset
JSREPORT_ERROR
errorNumber
args
)
;
MOZ_ASSERT
(
!
result
"
reporting
an
error
returned
true
?
"
)
;
va_end
(
args
)
;
}
bool
ParserBase
:
:
warning
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
.
reportCompileErrorNumberVA
(
pos
(
)
.
begin
JSREPORT_WARNING
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
ParserBase
:
:
warningAt
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
.
reportCompileErrorNumberVA
(
offset
JSREPORT_WARNING
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
ParserBase
:
:
extraWarning
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
.
reportExtraWarningErrorNumberVA
(
pos
(
)
.
begin
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
ParserBase
:
:
strictModeError
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
res
=
tokenStream
.
reportStrictModeErrorNumberVA
(
pos
(
)
.
begin
pc
-
>
sc
(
)
-
>
strict
(
)
errorNumber
args
)
;
va_end
(
args
)
;
return
res
;
}
bool
ParserBase
:
:
strictModeErrorAt
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
res
=
tokenStream
.
reportStrictModeErrorNumberVA
(
offset
pc
-
>
sc
(
)
-
>
strict
(
)
errorNumber
args
)
;
va_end
(
args
)
;
return
res
;
}
bool
ParserBase
:
:
reportNoOffset
(
ParseReportKind
kind
bool
strict
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
false
;
uint32_t
offset
=
TokenStream
:
:
NoOffset
;
switch
(
kind
)
{
case
ParseError
:
result
=
tokenStream
.
reportCompileErrorNumberVA
(
offset
JSREPORT_ERROR
errorNumber
args
)
;
break
;
case
ParseWarning
:
result
=
tokenStream
.
reportCompileErrorNumberVA
(
offset
JSREPORT_WARNING
errorNumber
args
)
;
break
;
case
ParseExtraWarning
:
result
=
tokenStream
.
reportExtraWarningErrorNumberVA
(
offset
errorNumber
args
)
;
break
;
case
ParseStrictError
:
result
=
tokenStream
.
reportStrictModeErrorNumberVA
(
offset
strict
errorNumber
args
)
;
break
;
}
va_end
(
args
)
;
return
result
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
abortIfSyntaxParser
(
)
{
handler
.
disableSyntaxParser
(
)
;
return
true
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
abortIfSyntaxParser
(
)
{
abortedSyntaxParse
=
true
;
return
false
;
}
ParserBase
:
:
ParserBase
(
JSContext
*
cx
LifoAlloc
&
alloc
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
bool
foldConstants
UsedNameTracker
&
usedNames
Parser
<
SyntaxParseHandler
>
*
syntaxParser
LazyScript
*
lazyOuterFunction
)
:
context
(
cx
)
alloc
(
alloc
)
tokenStream
(
cx
options
chars
length
thisForCtor
(
)
)
traceListHead
(
nullptr
)
pc
(
nullptr
)
usedNames
(
usedNames
)
sct
(
nullptr
)
ss
(
nullptr
)
keepAtoms
(
cx
)
foldConstants
(
foldConstants
)
#
ifdef
DEBUG
checkOptionsCalled
(
false
)
#
endif
abortedSyntaxParse
(
false
)
isUnexpectedEOF_
(
false
)
{
cx
-
>
frontendCollectionPool
(
)
.
addActiveCompilation
(
)
;
tempPoolMark
=
alloc
.
mark
(
)
;
}
ParserBase
:
:
~
ParserBase
(
)
{
alloc
.
release
(
tempPoolMark
)
;
alloc
.
freeAllIfHugeAndUnused
(
)
;
context
-
>
frontendCollectionPool
(
)
.
removeActiveCompilation
(
)
;
}
template
<
typename
ParseHandler
>
Parser
<
ParseHandler
>
:
:
Parser
(
JSContext
*
cx
LifoAlloc
&
alloc
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
bool
foldConstants
UsedNameTracker
&
usedNames
Parser
<
SyntaxParseHandler
>
*
syntaxParser
LazyScript
*
lazyOuterFunction
)
:
ParserBase
(
cx
alloc
options
chars
length
foldConstants
usedNames
syntaxParser
lazyOuterFunction
)
AutoGCRooter
(
cx
PARSER
)
handler
(
cx
alloc
tokenStream
syntaxParser
lazyOuterFunction
)
{
if
(
options
.
extraWarningsOption
)
handler
.
disableSyntaxParser
(
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkOptions
(
)
{
#
ifdef
DEBUG
checkOptionsCalled
=
true
;
#
endif
return
tokenStream
.
checkOptions
(
)
;
}
template
<
typename
ParseHandler
>
Parser
<
ParseHandler
>
:
:
~
Parser
(
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
}
template
<
typename
ParseHandler
>
ObjectBox
*
Parser
<
ParseHandler
>
:
:
newObjectBox
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
ObjectBox
*
objbox
=
alloc
.
new_
<
ObjectBox
>
(
obj
traceListHead
)
;
if
(
!
objbox
)
{
ReportOutOfMemory
(
context
)
;
return
nullptr
;
}
traceListHead
=
objbox
;
return
objbox
;
}
template
<
typename
ParseHandler
>
FunctionBox
*
Parser
<
ParseHandler
>
:
:
newFunctionBox
(
Node
fn
JSFunction
*
fun
Directives
inheritedDirectives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
tryAnnexB
)
{
MOZ_ASSERT
(
fun
)
;
MOZ_ASSERT_IF
(
tryAnnexB
!
pc
-
>
sc
(
)
-
>
strict
(
)
)
;
FunctionBox
*
funbox
=
alloc
.
new_
<
FunctionBox
>
(
context
alloc
traceListHead
fun
inheritedDirectives
options
(
)
.
extraWarningsOption
generatorKind
asyncKind
)
;
if
(
!
funbox
)
{
ReportOutOfMemory
(
context
)
;
return
nullptr
;
}
traceListHead
=
funbox
;
if
(
fn
)
handler
.
setFunctionBox
(
fn
funbox
)
;
if
(
tryAnnexB
&
&
!
pc
-
>
addInnerFunctionBoxForAnnexB
(
funbox
)
)
return
nullptr
;
return
funbox
;
}
ModuleSharedContext
:
:
ModuleSharedContext
(
JSContext
*
cx
ModuleObject
*
module
Scope
*
enclosingScope
ModuleBuilder
&
builder
)
:
SharedContext
(
cx
Kind
:
:
Module
Directives
(
true
)
false
)
module_
(
cx
module
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
builder
(
builder
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
trace
(
JSTracer
*
trc
)
{
ObjectBox
:
:
TraceList
(
trc
traceListHead
)
;
}
void
TraceParser
(
JSTracer
*
trc
AutoGCRooter
*
parser
)
{
static_cast
<
Parser
<
FullParseHandler
>
*
>
(
parser
)
-
>
trace
(
trc
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
parse
(
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
Directives
directives
(
options
(
)
.
strictOption
)
;
GlobalSharedContext
globalsc
(
context
ScopeKind
:
:
Global
directives
options
(
)
.
extraWarningsOption
)
;
ParseContext
globalpc
(
this
&
globalsc
nullptr
)
;
if
(
!
globalpc
.
init
(
)
)
return
null
(
)
;
ParseContext
:
:
VarScope
varScope
(
this
)
;
if
(
!
varScope
.
init
(
pc
)
)
return
null
(
)
;
Node
pn
=
statementList
(
YieldIsName
)
;
if
(
!
pn
)
return
null
(
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_EOF
)
{
error
(
JSMSG_GARBAGE_AFTER_INPUT
"
script
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
if
(
foldConstants
)
{
if
(
!
FoldConstants
(
context
&
pn
this
)
)
return
null
(
)
;
}
return
pn
;
}
bool
ParserBase
:
:
isValidStrictBinding
(
PropertyName
*
name
)
{
return
name
!
=
context
-
>
names
(
)
.
eval
&
&
name
!
=
context
-
>
names
(
)
.
arguments
&
&
name
!
=
context
-
>
names
(
)
.
let
&
&
name
!
=
context
-
>
names
(
)
.
static_
&
&
!
(
IsKeyword
(
name
)
&
&
name
!
=
context
-
>
names
(
)
.
await
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkStrictBinding
(
PropertyName
*
name
TokenPos
pos
)
{
if
(
!
pc
-
>
sc
(
)
-
>
needStrictChecks
(
)
)
return
true
;
if
(
!
isValidStrictBinding
(
name
)
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
context
name
&
bytes
)
)
return
false
;
return
strictModeErrorAt
(
pos
.
begin
JSMSG_BAD_BINDING
bytes
.
ptr
(
)
)
;
}
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
hasValidSimpleStrictParameterNames
(
)
{
MOZ_ASSERT
(
pc
-
>
isFunctionBox
(
)
&
&
pc
-
>
functionBox
(
)
-
>
hasSimpleParameterList
(
)
)
;
if
(
pc
-
>
functionBox
(
)
-
>
hasDuplicateParameters
)
return
false
;
for
(
auto
*
name
:
pc
-
>
positionalFormalParameterNames
(
)
)
{
MOZ_ASSERT
(
name
)
;
if
(
!
isValidStrictBinding
(
name
-
>
asPropertyName
(
)
)
)
return
false
;
}
return
true
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
reportRedeclaration
(
HandlePropertyName
name
DeclarationKind
kind
TokenPos
pos
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
context
name
&
bytes
)
)
return
;
errorAt
(
pos
.
begin
JSMSG_REDECLARED_VAR
DeclarationKindString
(
kind
)
bytes
.
ptr
(
)
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
notePositionalFormalParameter
(
Node
fn
HandlePropertyName
name
bool
disallowDuplicateParams
bool
*
duplicatedParam
)
{
if
(
AddDeclaredNamePtr
p
=
pc
-
>
functionScope
(
)
.
lookupDeclaredNameForAdd
(
name
)
)
{
if
(
disallowDuplicateParams
)
{
error
(
JSMSG_BAD_DUP_ARGS
)
;
return
false
;
}
if
(
pc
-
>
sc
(
)
-
>
needStrictChecks
(
)
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
context
name
&
bytes
)
)
return
false
;
if
(
!
strictModeError
(
JSMSG_DUPLICATE_FORMAL
bytes
.
ptr
(
)
)
)
return
false
;
}
*
duplicatedParam
=
true
;
}
else
{
DeclarationKind
kind
=
DeclarationKind
:
:
PositionalFormalParameter
;
if
(
!
pc
-
>
functionScope
(
)
.
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
}
if
(
!
pc
-
>
positionalFormalParameterNames
(
)
.
append
(
name
)
)
{
ReportOutOfMemory
(
context
)
;
return
false
;
}
Node
paramNode
=
newName
(
name
)
;
if
(
!
paramNode
)
return
false
;
if
(
!
checkStrictBinding
(
name
pos
(
)
)
)
return
false
;
handler
.
addFunctionFormalParameter
(
fn
paramNode
)
;
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
noteDestructuredPositionalFormalParameter
(
Node
fn
Node
destruct
)
{
if
(
!
pc
-
>
positionalFormalParameterNames
(
)
.
append
(
nullptr
)
)
{
ReportOutOfMemory
(
context
)
;
return
false
;
}
handler
.
addFunctionFormalParameter
(
fn
destruct
)
;
return
true
;
}
static
bool
DeclarationKindIsVar
(
DeclarationKind
kind
)
{
return
kind
=
=
DeclarationKind
:
:
Var
|
|
kind
=
=
DeclarationKind
:
:
BodyLevelFunction
|
|
kind
=
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
|
|
kind
=
=
DeclarationKind
:
:
ForOfVar
;
}
template
<
typename
ParseHandler
>
Maybe
<
DeclarationKind
>
Parser
<
ParseHandler
>
:
:
isVarRedeclaredInEval
(
HandlePropertyName
name
DeclarationKind
kind
)
{
MOZ_ASSERT
(
DeclarationKindIsVar
(
kind
)
)
;
MOZ_ASSERT
(
pc
-
>
sc
(
)
-
>
isEvalContext
(
)
)
;
Scope
*
enclosingScope
=
pc
-
>
sc
(
)
-
>
compilationEnclosingScope
(
)
;
Scope
*
varScope
=
EvalScope
:
:
nearestVarScopeForDirectEval
(
enclosingScope
)
;
MOZ_ASSERT
(
varScope
)
;
for
(
ScopeIter
si
(
enclosingScope
)
;
si
;
si
+
+
)
{
for
(
js
:
:
BindingIter
bi
(
si
.
scope
(
)
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
!
=
name
)
continue
;
switch
(
bi
.
kind
(
)
)
{
case
BindingKind
:
:
Let
:
{
bool
annexB35Allowance
=
si
.
kind
(
)
=
=
ScopeKind
:
:
SimpleCatch
&
&
kind
!
=
DeclarationKind
:
:
ForOfVar
;
if
(
!
annexB35Allowance
)
{
return
Some
(
ScopeKindIsCatch
(
si
.
kind
(
)
)
?
DeclarationKind
:
:
CatchParameter
:
DeclarationKind
:
:
Let
)
;
}
break
;
}
case
BindingKind
:
:
Const
:
return
Some
(
DeclarationKind
:
:
Const
)
;
case
BindingKind
:
:
Import
:
case
BindingKind
:
:
FormalParameter
:
case
BindingKind
:
:
Var
:
case
BindingKind
:
:
NamedLambdaCallee
:
break
;
}
}
if
(
si
.
scope
(
)
=
=
varScope
)
break
;
}
return
Nothing
(
)
;
}
static
bool
DeclarationKindIsParameter
(
DeclarationKind
kind
)
{
return
kind
=
=
DeclarationKind
:
:
PositionalFormalParameter
|
|
kind
=
=
DeclarationKind
:
:
FormalParameter
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
tryDeclareVar
(
HandlePropertyName
name
DeclarationKind
kind
Maybe
<
DeclarationKind
>
*
redeclaredKind
)
{
MOZ_ASSERT
(
DeclarationKindIsVar
(
kind
)
)
;
for
(
ParseContext
:
:
Scope
*
scope
=
pc
-
>
innermostScope
(
)
;
scope
!
=
pc
-
>
varScope
(
)
.
enclosing
(
)
;
scope
=
scope
-
>
enclosing
(
)
)
{
if
(
AddDeclaredNamePtr
p
=
scope
-
>
lookupDeclaredNameForAdd
(
name
)
)
{
DeclarationKind
declaredKind
=
p
-
>
value
(
)
-
>
kind
(
)
;
if
(
DeclarationKindIsVar
(
declaredKind
)
)
{
if
(
kind
=
=
DeclarationKind
:
:
BodyLevelFunction
)
p
-
>
value
(
)
-
>
alterKind
(
kind
)
;
}
else
if
(
!
DeclarationKindIsParameter
(
declaredKind
)
)
{
bool
annexB35Allowance
=
declaredKind
=
=
DeclarationKind
:
:
SimpleCatchParameter
&
&
kind
!
=
DeclarationKind
:
:
ForOfVar
;
bool
annexB33Allowance
=
declaredKind
=
=
DeclarationKind
:
:
LexicalFunction
&
&
kind
=
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
&
&
scope
=
=
pc
-
>
innermostScope
(
)
;
if
(
!
annexB35Allowance
&
&
!
annexB33Allowance
)
{
*
redeclaredKind
=
Some
(
declaredKind
)
;
return
true
;
}
}
else
if
(
kind
=
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
)
{
MOZ_ASSERT
(
DeclarationKindIsParameter
(
declaredKind
)
)
;
*
redeclaredKind
=
Some
(
declaredKind
)
;
return
true
;
}
}
else
{
if
(
!
scope
-
>
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
}
}
if
(
!
pc
-
>
sc
(
)
-
>
strict
(
)
&
&
pc
-
>
sc
(
)
-
>
isEvalContext
(
)
)
*
redeclaredKind
=
isVarRedeclaredInEval
(
name
kind
)
;
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
tryDeclareVarForAnnexBLexicalFunction
(
HandlePropertyName
name
bool
*
tryAnnexB
)
{
Maybe
<
DeclarationKind
>
redeclaredKind
;
if
(
!
tryDeclareVar
(
name
DeclarationKind
:
:
VarForAnnexBLexicalFunction
&
redeclaredKind
)
)
return
false
;
if
(
redeclaredKind
)
{
*
tryAnnexB
=
false
;
ParseContext
:
:
Scope
:
:
removeVarForAnnexBLexicalFunction
(
pc
name
)
;
}
else
{
*
tryAnnexB
=
true
;
}
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkLexicalDeclarationDirectlyWithinBlock
(
ParseContext
:
:
Statement
&
stmt
DeclarationKind
kind
TokenPos
pos
)
{
MOZ_ASSERT
(
DeclarationKindIsLexical
(
kind
)
)
;
if
(
!
StatementKindIsBraced
(
stmt
.
kind
(
)
)
&
&
stmt
.
kind
(
)
!
=
StatementKind
:
:
ForLoopLexicalHead
)
{
errorAt
(
pos
.
begin
stmt
.
kind
(
)
=
=
StatementKind
:
:
Label
?
JSMSG_LEXICAL_DECL_LABEL
:
JSMSG_LEXICAL_DECL_NOT_IN_BLOCK
DeclarationKindString
(
kind
)
)
;
return
false
;
}
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
noteDeclaredName
(
HandlePropertyName
name
DeclarationKind
kind
TokenPos
pos
)
{
if
(
pc
-
>
useAsmOrInsideUseAsm
(
)
)
return
true
;
if
(
!
checkStrictBinding
(
name
pos
)
)
return
false
;
switch
(
kind
)
{
case
DeclarationKind
:
:
Var
:
case
DeclarationKind
:
:
BodyLevelFunction
:
case
DeclarationKind
:
:
ForOfVar
:
{
Maybe
<
DeclarationKind
>
redeclaredKind
;
if
(
!
tryDeclareVar
(
name
kind
&
redeclaredKind
)
)
return
false
;
if
(
redeclaredKind
)
{
reportRedeclaration
(
name
*
redeclaredKind
pos
)
;
return
false
;
}
break
;
}
case
DeclarationKind
:
:
FormalParameter
:
{
AddDeclaredNamePtr
p
=
pc
-
>
functionScope
(
)
.
lookupDeclaredNameForAdd
(
name
)
;
if
(
p
)
{
error
(
JSMSG_BAD_DUP_ARGS
)
;
return
false
;
}
if
(
!
pc
-
>
functionScope
(
)
.
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
break
;
}
case
DeclarationKind
:
:
LexicalFunction
:
{
ParseContext
:
:
Scope
*
scope
=
pc
-
>
innermostScope
(
)
;
if
(
AddDeclaredNamePtr
p
=
scope
-
>
lookupDeclaredNameForAdd
(
name
)
)
{
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
|
|
(
p
-
>
value
(
)
-
>
kind
(
)
!
=
DeclarationKind
:
:
LexicalFunction
&
&
p
-
>
value
(
)
-
>
kind
(
)
!
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
)
)
{
reportRedeclaration
(
name
p
-
>
value
(
)
-
>
kind
(
)
pos
)
;
return
false
;
}
p
-
>
value
(
)
-
>
alterKind
(
kind
)
;
}
else
{
if
(
!
scope
-
>
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
}
break
;
}
case
DeclarationKind
:
:
Let
:
case
DeclarationKind
:
:
Const
:
if
(
name
=
=
context
-
>
names
(
)
.
let
)
{
errorAt
(
pos
.
begin
JSMSG_LEXICAL_DECL_DEFINES_LET
)
;
return
false
;
}
MOZ_FALLTHROUGH
;
case
DeclarationKind
:
:
Import
:
MOZ_ASSERT
(
name
!
=
context
-
>
names
(
)
.
let
)
;
MOZ_FALLTHROUGH
;
case
DeclarationKind
:
:
SimpleCatchParameter
:
case
DeclarationKind
:
:
CatchParameter
:
{
if
(
ParseContext
:
:
Statement
*
stmt
=
pc
-
>
innermostStatement
(
)
)
{
if
(
!
checkLexicalDeclarationDirectlyWithinBlock
(
*
stmt
kind
pos
)
)
return
false
;
}
ParseContext
:
:
Scope
*
scope
=
pc
-
>
innermostScope
(
)
;
if
(
pc
-
>
isFunctionExtraBodyVarScopeInnermost
(
)
)
{
DeclaredNamePtr
p
=
pc
-
>
functionScope
(
)
.
lookupDeclaredName
(
name
)
;
if
(
p
&
&
DeclarationKindIsParameter
(
p
-
>
value
(
)
-
>
kind
(
)
)
)
{
reportRedeclaration
(
name
p
-
>
value
(
)
-
>
kind
(
)
pos
)
;
return
false
;
}
}
AddDeclaredNamePtr
p
=
scope
-
>
lookupDeclaredNameForAdd
(
name
)
;
if
(
p
)
{
if
(
p
-
>
value
(
)
-
>
kind
(
)
=
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
)
{
ParseContext
:
:
Scope
:
:
removeVarForAnnexBLexicalFunction
(
pc
name
)
;
p
=
scope
-
>
lookupDeclaredNameForAdd
(
name
)
;
MOZ_ASSERT
(
!
p
)
;
}
else
{
reportRedeclaration
(
name
p
-
>
value
(
)
-
>
kind
(
)
pos
)
;
return
false
;
}
}
if
(
!
p
&
&
!
scope
-
>
addDeclaredName
(
pc
p
name
kind
)
)
return
false
;
break
;
}
case
DeclarationKind
:
:
CoverArrowParameter
:
break
;
case
DeclarationKind
:
:
PositionalFormalParameter
:
MOZ_CRASH
(
"
Positional
formal
parameter
names
should
use
"
"
notePositionalFormalParameter
"
)
;
break
;
case
DeclarationKind
:
:
VarForAnnexBLexicalFunction
:
MOZ_CRASH
(
"
Synthesized
Annex
B
vars
should
go
through
"
"
tryDeclareVarForAnnexBLexicalFunction
"
)
;
break
;
}
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
noteUsedName
(
HandlePropertyName
name
)
{
if
(
handler
.
canSkipLazyClosedOverBindings
(
)
)
return
true
;
if
(
pc
-
>
useAsmOrInsideUseAsm
(
)
)
return
true
;
ParseContext
:
:
Scope
*
scope
=
pc
-
>
innermostScope
(
)
;
if
(
pc
-
>
sc
(
)
-
>
isGlobalContext
(
)
&
&
scope
=
=
&
pc
-
>
varScope
(
)
)
return
true
;
return
usedNames
.
noteUse
(
context
name
pc
-
>
scriptId
(
)
scope
-
>
id
(
)
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
hasUsedName
(
HandlePropertyName
name
)
{
if
(
UsedNamePtr
p
=
usedNames
.
lookup
(
name
)
)
return
p
-
>
value
(
)
.
isUsedInScript
(
pc
-
>
scriptId
(
)
)
;
return
false
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
propagateFreeNamesAndMarkClosedOverBindings
(
ParseContext
:
:
Scope
&
scope
)
{
if
(
handler
.
canSkipLazyClosedOverBindings
(
)
)
{
while
(
JSAtom
*
name
=
handler
.
nextLazyClosedOverBinding
(
)
)
scope
.
lookupDeclaredName
(
name
)
-
>
value
(
)
-
>
setClosedOver
(
)
;
return
true
;
}
bool
isSyntaxParser
=
mozilla
:
:
IsSame
<
ParseHandler
SyntaxParseHandler
>
:
:
value
;
uint32_t
scriptId
=
pc
-
>
scriptId
(
)
;
uint32_t
scopeId
=
scope
.
id
(
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
if
(
UsedNamePtr
p
=
usedNames
.
lookup
(
bi
.
name
(
)
)
)
{
bool
closedOver
;
p
-
>
value
(
)
.
noteBoundInScope
(
scriptId
scopeId
&
closedOver
)
;
if
(
closedOver
)
{
bi
.
setClosedOver
(
)
;
if
(
isSyntaxParser
&
&
!
pc
-
>
closedOverBindingsForLazy
(
)
.
append
(
bi
.
name
(
)
)
)
{
ReportOutOfMemory
(
context
)
;
return
false
;
}
}
}
}
if
(
isSyntaxParser
&
&
!
pc
-
>
closedOverBindingsForLazy
(
)
.
append
(
nullptr
)
)
{
ReportOutOfMemory
(
context
)
;
return
false
;
}
return
true
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkStatementsEOF
(
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
false
;
if
(
tt
!
=
TOK_EOF
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
expression
"
TokenKindToDesc
(
tt
)
)
;
return
false
;
}
return
true
;
}
template
<
typename
Scope
>
static
typename
Scope
:
:
Data
*
NewEmptyBindingData
(
JSContext
*
cx
LifoAlloc
&
alloc
uint32_t
numBindings
)
{
size_t
allocSize
=
Scope
:
:
sizeOfData
(
numBindings
)
;
typename
Scope
:
:
Data
*
bindings
=
static_cast
<
typename
Scope
:
:
Data
*
>
(
alloc
.
alloc
(
allocSize
)
)
;
if
(
!
bindings
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
PodZero
(
bindings
)
;
return
bindings
;
}
template
<
>
Maybe
<
GlobalScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newGlobalScopeData
(
ParseContext
:
:
Scope
&
scope
)
{
Vector
<
BindingName
>
funs
(
context
)
;
Vector
<
BindingName
>
vars
(
context
)
;
Vector
<
BindingName
>
lets
(
context
)
;
Vector
<
BindingName
>
consts
(
context
)
;
bool
allBindingsClosedOver
=
pc
-
>
sc
(
)
-
>
allBindingsClosedOver
(
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
BindingName
binding
(
bi
.
name
(
)
allBindingsClosedOver
|
|
bi
.
closedOver
(
)
)
;
switch
(
bi
.
kind
(
)
)
{
case
BindingKind
:
:
Var
:
if
(
bi
.
declarationKind
(
)
=
=
DeclarationKind
:
:
BodyLevelFunction
)
{
if
(
!
funs
.
append
(
binding
)
)
return
Nothing
(
)
;
}
else
{
if
(
!
vars
.
append
(
binding
)
)
return
Nothing
(
)
;
}
break
;
case
BindingKind
:
:
Let
:
if
(
!
lets
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
case
BindingKind
:
:
Const
:
if
(
!
consts
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Bad
global
scope
BindingKind
"
)
;
}
}
GlobalScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
funs
.
length
(
)
+
vars
.
length
(
)
+
lets
.
length
(
)
+
consts
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
GlobalScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
start
=
bindings
-
>
names
;
BindingName
*
cursor
=
start
;
PodCopy
(
cursor
funs
.
begin
(
)
funs
.
length
(
)
)
;
cursor
+
=
funs
.
length
(
)
;
bindings
-
>
varStart
=
cursor
-
start
;
PodCopy
(
cursor
vars
.
begin
(
)
vars
.
length
(
)
)
;
cursor
+
=
vars
.
length
(
)
;
bindings
-
>
letStart
=
cursor
-
start
;
PodCopy
(
cursor
lets
.
begin
(
)
lets
.
length
(
)
)
;
cursor
+
=
lets
.
length
(
)
;
bindings
-
>
constStart
=
cursor
-
start
;
PodCopy
(
cursor
consts
.
begin
(
)
consts
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
Maybe
<
ModuleScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newModuleScopeData
(
ParseContext
:
:
Scope
&
scope
)
{
Vector
<
BindingName
>
imports
(
context
)
;
Vector
<
BindingName
>
vars
(
context
)
;
Vector
<
BindingName
>
lets
(
context
)
;
Vector
<
BindingName
>
consts
(
context
)
;
bool
allBindingsClosedOver
=
pc
-
>
sc
(
)
-
>
allBindingsClosedOver
(
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
BindingName
binding
(
bi
.
name
(
)
(
allBindingsClosedOver
|
|
bi
.
closedOver
(
)
)
&
&
bi
.
kind
(
)
!
=
BindingKind
:
:
Import
)
;
switch
(
bi
.
kind
(
)
)
{
case
BindingKind
:
:
Import
:
if
(
!
imports
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
case
BindingKind
:
:
Var
:
if
(
!
vars
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
case
BindingKind
:
:
Let
:
if
(
!
lets
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
case
BindingKind
:
:
Const
:
if
(
!
consts
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Bad
module
scope
BindingKind
"
)
;
}
}
ModuleScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
imports
.
length
(
)
+
vars
.
length
(
)
+
lets
.
length
(
)
+
consts
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
ModuleScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
start
=
bindings
-
>
names
;
BindingName
*
cursor
=
start
;
PodCopy
(
cursor
imports
.
begin
(
)
imports
.
length
(
)
)
;
cursor
+
=
imports
.
length
(
)
;
bindings
-
>
varStart
=
cursor
-
start
;
PodCopy
(
cursor
vars
.
begin
(
)
vars
.
length
(
)
)
;
cursor
+
=
vars
.
length
(
)
;
bindings
-
>
letStart
=
cursor
-
start
;
PodCopy
(
cursor
lets
.
begin
(
)
lets
.
length
(
)
)
;
cursor
+
=
lets
.
length
(
)
;
bindings
-
>
constStart
=
cursor
-
start
;
PodCopy
(
cursor
consts
.
begin
(
)
consts
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
Maybe
<
EvalScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newEvalScopeData
(
ParseContext
:
:
Scope
&
scope
)
{
Vector
<
BindingName
>
funs
(
context
)
;
Vector
<
BindingName
>
vars
(
context
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
MOZ_ASSERT
(
bi
.
kind
(
)
=
=
BindingKind
:
:
Var
)
;
BindingName
binding
(
bi
.
name
(
)
true
)
;
if
(
bi
.
declarationKind
(
)
=
=
DeclarationKind
:
:
BodyLevelFunction
)
{
if
(
!
funs
.
append
(
binding
)
)
return
Nothing
(
)
;
}
else
{
if
(
!
vars
.
append
(
binding
)
)
return
Nothing
(
)
;
}
}
EvalScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
funs
.
length
(
)
+
vars
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
EvalScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
start
=
bindings
-
>
names
;
BindingName
*
cursor
=
start
;
PodCopy
(
cursor
funs
.
begin
(
)
funs
.
length
(
)
)
;
cursor
+
=
funs
.
length
(
)
;
bindings
-
>
varStart
=
cursor
-
start
;
PodCopy
(
cursor
vars
.
begin
(
)
vars
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
Maybe
<
FunctionScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newFunctionScopeData
(
ParseContext
:
:
Scope
&
scope
bool
hasParameterExprs
)
{
Vector
<
BindingName
>
positionalFormals
(
context
)
;
Vector
<
BindingName
>
formals
(
context
)
;
Vector
<
BindingName
>
vars
(
context
)
;
bool
allBindingsClosedOver
=
pc
-
>
sc
(
)
-
>
allBindingsClosedOver
(
)
;
bool
hasDuplicateParams
=
pc
-
>
functionBox
(
)
-
>
hasDuplicateParameters
;
for
(
size_t
i
=
0
;
i
<
pc
-
>
positionalFormalParameterNames
(
)
.
length
(
)
;
i
+
+
)
{
JSAtom
*
name
=
pc
-
>
positionalFormalParameterNames
(
)
[
i
]
;
BindingName
bindName
;
if
(
name
)
{
DeclaredNamePtr
p
=
scope
.
lookupDeclaredName
(
name
)
;
bool
closedOver
=
allBindingsClosedOver
|
|
(
p
&
&
p
-
>
value
(
)
-
>
closedOver
(
)
)
;
if
(
hasDuplicateParams
)
{
for
(
size_t
j
=
pc
-
>
positionalFormalParameterNames
(
)
.
length
(
)
-
1
;
j
>
i
;
j
-
-
)
{
if
(
pc
-
>
positionalFormalParameterNames
(
)
[
j
]
=
=
name
)
{
closedOver
=
false
;
break
;
}
}
}
bindName
=
BindingName
(
name
closedOver
)
;
}
if
(
!
positionalFormals
.
append
(
bindName
)
)
return
Nothing
(
)
;
}
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
BindingName
binding
(
bi
.
name
(
)
allBindingsClosedOver
|
|
bi
.
closedOver
(
)
)
;
switch
(
bi
.
kind
(
)
)
{
case
BindingKind
:
:
FormalParameter
:
if
(
bi
.
declarationKind
(
)
=
=
DeclarationKind
:
:
FormalParameter
)
{
if
(
!
formals
.
append
(
binding
)
)
return
Nothing
(
)
;
}
break
;
case
BindingKind
:
:
Var
:
MOZ_ASSERT_IF
(
hasParameterExprs
bi
.
name
(
)
=
=
context
-
>
names
(
)
.
arguments
|
|
bi
.
name
(
)
=
=
context
-
>
names
(
)
.
dotThis
|
|
bi
.
name
(
)
=
=
context
-
>
names
(
)
.
dotGenerator
)
;
if
(
!
vars
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
default
:
break
;
}
}
FunctionScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
positionalFormals
.
length
(
)
+
formals
.
length
(
)
+
vars
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
FunctionScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
start
=
bindings
-
>
names
;
BindingName
*
cursor
=
start
;
PodCopy
(
cursor
positionalFormals
.
begin
(
)
positionalFormals
.
length
(
)
)
;
cursor
+
=
positionalFormals
.
length
(
)
;
bindings
-
>
nonPositionalFormalStart
=
cursor
-
start
;
PodCopy
(
cursor
formals
.
begin
(
)
formals
.
length
(
)
)
;
cursor
+
=
formals
.
length
(
)
;
bindings
-
>
varStart
=
cursor
-
start
;
PodCopy
(
cursor
vars
.
begin
(
)
vars
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
Maybe
<
VarScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newVarScopeData
(
ParseContext
:
:
Scope
&
scope
)
{
Vector
<
BindingName
>
vars
(
context
)
;
bool
allBindingsClosedOver
=
pc
-
>
sc
(
)
-
>
allBindingsClosedOver
(
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
BindingName
binding
(
bi
.
name
(
)
allBindingsClosedOver
|
|
bi
.
closedOver
(
)
)
;
if
(
!
vars
.
append
(
binding
)
)
return
Nothing
(
)
;
}
VarScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
vars
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
VarScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
start
=
bindings
-
>
names
;
BindingName
*
cursor
=
start
;
PodCopy
(
cursor
vars
.
begin
(
)
vars
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
Maybe
<
LexicalScope
:
:
Data
*
>
Parser
<
FullParseHandler
>
:
:
newLexicalScopeData
(
ParseContext
:
:
Scope
&
scope
)
{
Vector
<
BindingName
>
lets
(
context
)
;
Vector
<
BindingName
>
consts
(
context
)
;
for
(
BindingIter
bi
=
scope
.
bindings
(
pc
)
;
bi
;
bi
+
+
)
{
BindingName
binding
(
bi
.
name
(
)
bi
.
closedOver
(
)
)
;
switch
(
bi
.
kind
(
)
)
{
case
BindingKind
:
:
Let
:
if
(
!
lets
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
case
BindingKind
:
:
Const
:
if
(
!
consts
.
append
(
binding
)
)
return
Nothing
(
)
;
break
;
default
:
break
;
}
}
LexicalScope
:
:
Data
*
bindings
=
nullptr
;
uint32_t
numBindings
=
lets
.
length
(
)
+
consts
.
length
(
)
;
if
(
numBindings
>
0
)
{
bindings
=
NewEmptyBindingData
<
LexicalScope
>
(
context
alloc
numBindings
)
;
if
(
!
bindings
)
return
Nothing
(
)
;
BindingName
*
cursor
=
bindings
-
>
names
;
BindingName
*
start
=
cursor
;
PodCopy
(
cursor
lets
.
begin
(
)
lets
.
length
(
)
)
;
cursor
+
=
lets
.
length
(
)
;
bindings
-
>
constStart
=
cursor
-
start
;
PodCopy
(
cursor
consts
.
begin
(
)
consts
.
length
(
)
)
;
bindings
-
>
length
=
numBindings
;
}
return
Some
(
bindings
)
;
}
template
<
>
SyntaxParseHandler
:
:
Node
Parser
<
SyntaxParseHandler
>
:
:
finishLexicalScope
(
ParseContext
:
:
Scope
&
scope
Node
body
)
{
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
scope
)
)
return
null
(
)
;
return
body
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
finishLexicalScope
(
ParseContext
:
:
Scope
&
scope
ParseNode
*
body
)
{
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
scope
)
)
return
nullptr
;
Maybe
<
LexicalScope
:
:
Data
*
>
bindings
=
newLexicalScopeData
(
scope
)
;
if
(
!
bindings
)
return
nullptr
;
return
handler
.
newLexicalScope
(
*
bindings
body
)
;
}
static
bool
IsArgumentsUsedInLegacyGenerator
(
JSContext
*
cx
Scope
*
scope
)
{
JSAtom
*
argumentsName
=
cx
-
>
names
(
)
.
arguments
;
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
scope
(
)
-
>
is
<
LexicalScope
>
(
)
)
{
for
(
:
:
BindingIter
bi
(
si
.
scope
(
)
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
=
=
argumentsName
)
return
false
;
}
}
else
if
(
si
.
scope
(
)
-
>
is
<
FunctionScope
>
(
)
)
{
JSScript
*
script
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
script
(
)
;
return
script
-
>
isGeneratorExp
(
)
&
&
script
-
>
isLegacyGenerator
(
)
;
}
}
return
false
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
evalBody
(
EvalSharedContext
*
evalsc
)
{
ParseContext
evalpc
(
this
evalsc
nullptr
)
;
if
(
!
evalpc
.
init
(
)
)
return
nullptr
;
ParseContext
:
:
VarScope
varScope
(
this
)
;
if
(
!
varScope
.
init
(
pc
)
)
return
nullptr
;
ParseContext
:
:
Scope
lexicalScope
(
this
)
;
if
(
!
lexicalScope
.
init
(
pc
)
)
return
nullptr
;
ParseNode
*
body
=
statementList
(
YieldIsName
)
;
if
(
!
body
)
return
nullptr
;
if
(
!
checkStatementsEOF
(
)
)
return
nullptr
;
body
=
finishLexicalScope
(
lexicalScope
body
)
;
if
(
!
body
)
return
nullptr
;
if
(
hasUsedName
(
context
-
>
names
(
)
.
arguments
)
)
{
if
(
IsArgumentsUsedInLegacyGenerator
(
context
pc
-
>
sc
(
)
-
>
compilationEnclosingScope
(
)
)
)
{
error
(
JSMSG_BAD_GENEXP_BODY
js_arguments_str
)
;
return
nullptr
;
}
}
#
ifdef
DEBUG
if
(
evalpc
.
superScopeNeedsHomeObject
(
)
&
&
evalsc
-
>
compilationEnclosingScope
(
)
)
{
ScopeIter
si
(
evalsc
-
>
compilationEnclosingScope
(
)
)
;
for
(
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
continue
;
MOZ_ASSERT
(
fun
-
>
allowSuperProperty
(
)
)
;
MOZ_ASSERT
(
fun
-
>
nonLazyScript
(
)
-
>
needsHomeObject
(
)
)
;
break
;
}
}
MOZ_ASSERT
(
!
si
.
done
(
)
"
Eval
must
have
found
an
enclosing
function
box
scope
that
allows
super
.
property
"
)
;
}
#
endif
if
(
!
FoldConstants
(
context
&
body
this
)
)
return
nullptr
;
Maybe
<
EvalScope
:
:
Data
*
>
bindings
=
newEvalScopeData
(
pc
-
>
varScope
(
)
)
;
if
(
!
bindings
)
return
nullptr
;
evalsc
-
>
bindings
=
*
bindings
;
return
body
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
globalBody
(
GlobalSharedContext
*
globalsc
)
{
ParseContext
globalpc
(
this
globalsc
nullptr
)
;
if
(
!
globalpc
.
init
(
)
)
return
nullptr
;
ParseContext
:
:
VarScope
varScope
(
this
)
;
if
(
!
varScope
.
init
(
pc
)
)
return
nullptr
;
ParseNode
*
body
=
statementList
(
YieldIsName
)
;
if
(
!
body
)
return
nullptr
;
if
(
!
checkStatementsEOF
(
)
)
return
nullptr
;
if
(
!
FoldConstants
(
context
&
body
this
)
)
return
nullptr
;
Maybe
<
GlobalScope
:
:
Data
*
>
bindings
=
newGlobalScopeData
(
pc
-
>
varScope
(
)
)
;
if
(
!
bindings
)
return
nullptr
;
globalsc
-
>
bindings
=
*
bindings
;
return
body
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
moduleBody
(
ModuleSharedContext
*
modulesc
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
ParseContext
modulepc
(
this
modulesc
nullptr
)
;
if
(
!
modulepc
.
init
(
)
)
return
null
(
)
;
ParseContext
:
:
VarScope
varScope
(
this
)
;
if
(
!
varScope
.
init
(
pc
)
)
return
nullptr
;
Node
mn
=
handler
.
newModule
(
)
;
if
(
!
mn
)
return
null
(
)
;
AutoAwaitIsKeyword
awaitIsKeyword
(
&
tokenStream
true
)
;
ParseNode
*
pn
=
statementList
(
YieldIsKeyword
)
;
if
(
!
pn
)
return
null
(
)
;
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_STATEMENTLIST
)
)
;
mn
-
>
pn_body
=
pn
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_EOF
)
{
error
(
JSMSG_GARBAGE_AFTER_INPUT
"
module
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
if
(
!
modulesc
-
>
builder
.
buildTables
(
)
)
return
null
(
)
;
for
(
auto
entry
:
modulesc
-
>
builder
.
localExportEntries
(
)
)
{
JSAtom
*
name
=
entry
-
>
localName
(
)
;
MOZ_ASSERT
(
name
)
;
DeclaredNamePtr
p
=
modulepc
.
varScope
(
)
.
lookupDeclaredName
(
name
)
;
if
(
!
p
)
{
JSAutoByteString
str
;
if
(
!
str
.
encodeLatin1
(
context
name
)
)
return
null
(
)
;
JS_ReportErrorNumberLatin1
(
context
GetErrorMessage
nullptr
JSMSG_MISSING_EXPORT
str
.
ptr
(
)
)
;
return
null
(
)
;
}
p
-
>
value
(
)
-
>
setClosedOver
(
)
;
}
if
(
!
FoldConstants
(
context
&
pn
this
)
)
return
null
(
)
;
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
modulepc
.
varScope
(
)
)
)
return
null
(
)
;
Maybe
<
ModuleScope
:
:
Data
*
>
bindings
=
newModuleScopeData
(
modulepc
.
varScope
(
)
)
;
if
(
!
bindings
)
return
nullptr
;
modulesc
-
>
bindings
=
*
bindings
;
return
mn
;
}
template
<
>
SyntaxParseHandler
:
:
Node
Parser
<
SyntaxParseHandler
>
:
:
moduleBody
(
ModuleSharedContext
*
modulesc
)
{
MOZ_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
SyntaxParseHandler
:
:
NodeFailure
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
hasUsedFunctionSpecialName
(
HandlePropertyName
name
)
{
MOZ_ASSERT
(
name
=
=
context
-
>
names
(
)
.
arguments
|
|
name
=
=
context
-
>
names
(
)
.
dotThis
)
;
return
hasUsedName
(
name
)
|
|
pc
-
>
functionBox
(
)
-
>
bindingsAccessedDynamically
(
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
declareFunctionThis
(
)
{
if
(
pc
-
>
useAsmOrInsideUseAsm
(
)
)
return
true
;
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
HandlePropertyName
dotThis
=
context
-
>
names
(
)
.
dotThis
;
bool
declareThis
;
if
(
handler
.
canSkipLazyClosedOverBindings
(
)
)
declareThis
=
funbox
-
>
function
(
)
-
>
lazyScript
(
)
-
>
hasThisBinding
(
)
;
else
declareThis
=
hasUsedFunctionSpecialName
(
dotThis
)
|
|
funbox
-
>
isDerivedClassConstructor
(
)
;
if
(
declareThis
)
{
ParseContext
:
:
Scope
&
funScope
=
pc
-
>
functionScope
(
)
;
AddDeclaredNamePtr
p
=
funScope
.
lookupDeclaredNameForAdd
(
dotThis
)
;
MOZ_ASSERT
(
!
p
)
;
if
(
!
funScope
.
addDeclaredName
(
pc
p
dotThis
DeclarationKind
:
:
Var
)
)
return
false
;
funbox
-
>
setHasThisBinding
(
)
;
}
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newInternalDotName
(
HandlePropertyName
name
)
{
Node
nameNode
=
newName
(
name
)
;
if
(
!
nameNode
)
return
null
(
)
;
if
(
!
noteUsedName
(
name
)
)
return
null
(
)
;
return
nameNode
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newThisName
(
)
{
return
newInternalDotName
(
context
-
>
names
(
)
.
dotThis
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newDotGeneratorName
(
)
{
return
newInternalDotName
(
context
-
>
names
(
)
.
dotGenerator
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
declareDotGeneratorName
(
)
{
ParseContext
:
:
Scope
&
funScope
=
pc
-
>
functionScope
(
)
;
HandlePropertyName
dotGenerator
=
context
-
>
names
(
)
.
dotGenerator
;
AddDeclaredNamePtr
p
=
funScope
.
lookupDeclaredNameForAdd
(
dotGenerator
)
;
if
(
!
p
&
&
!
funScope
.
addDeclaredName
(
pc
p
dotGenerator
DeclarationKind
:
:
Var
)
)
return
false
;
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
finishFunctionScopes
(
bool
isStandaloneFunction
)
{
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
if
(
funbox
-
>
hasParameterExprs
)
{
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
pc
-
>
functionScope
(
)
)
)
return
false
;
}
if
(
funbox
-
>
function
(
)
-
>
isNamedLambda
(
)
&
&
!
isStandaloneFunction
)
{
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
pc
-
>
namedLambdaScope
(
)
)
)
return
false
;
}
return
true
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
finishFunction
(
bool
isStandaloneFunction
)
{
if
(
!
finishFunctionScopes
(
isStandaloneFunction
)
)
return
false
;
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
bool
hasParameterExprs
=
funbox
-
>
hasParameterExprs
;
if
(
hasParameterExprs
)
{
Maybe
<
VarScope
:
:
Data
*
>
bindings
=
newVarScopeData
(
pc
-
>
varScope
(
)
)
;
if
(
!
bindings
)
return
false
;
funbox
-
>
extraVarScopeBindings
(
)
.
set
(
*
bindings
)
;
}
{
Maybe
<
FunctionScope
:
:
Data
*
>
bindings
=
newFunctionScopeData
(
pc
-
>
functionScope
(
)
hasParameterExprs
)
;
if
(
!
bindings
)
return
false
;
funbox
-
>
functionScopeBindings
(
)
.
set
(
*
bindings
)
;
}
if
(
funbox
-
>
function
(
)
-
>
isNamedLambda
(
)
&
&
!
isStandaloneFunction
)
{
Maybe
<
LexicalScope
:
:
Data
*
>
bindings
=
newLexicalScopeData
(
pc
-
>
namedLambdaScope
(
)
)
;
if
(
!
bindings
)
return
false
;
funbox
-
>
namedLambdaBindings
(
)
.
set
(
*
bindings
)
;
}
return
true
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
finishFunction
(
bool
isStandaloneFunction
)
{
if
(
!
finishFunctionScopes
(
isStandaloneFunction
)
)
return
false
;
if
(
pc
-
>
closedOverBindingsForLazy
(
)
.
length
(
)
>
=
LazyScript
:
:
NumClosedOverBindingsLimit
|
|
pc
-
>
innerFunctionsForLazy
.
length
(
)
>
=
LazyScript
:
:
NumInnerFunctionsLimit
)
{
MOZ_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
false
;
}
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
RootedFunction
fun
(
context
funbox
-
>
function
(
)
)
;
LazyScript
*
lazy
=
LazyScript
:
:
Create
(
context
fun
pc
-
>
closedOverBindingsForLazy
(
)
pc
-
>
innerFunctionsForLazy
versionNumber
(
)
funbox
-
>
bufStart
funbox
-
>
bufEnd
funbox
-
>
startLine
funbox
-
>
startColumn
)
;
if
(
!
lazy
)
return
false
;
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
lazy
-
>
setStrict
(
)
;
lazy
-
>
setGeneratorKind
(
funbox
-
>
generatorKind
(
)
)
;
lazy
-
>
setAsyncKind
(
funbox
-
>
asyncKind
(
)
)
;
if
(
funbox
-
>
hasRest
(
)
)
lazy
-
>
setHasRest
(
)
;
if
(
funbox
-
>
isExprBody
(
)
)
lazy
-
>
setIsExprBody
(
)
;
if
(
funbox
-
>
isLikelyConstructorWrapper
(
)
)
lazy
-
>
setLikelyConstructorWrapper
(
)
;
if
(
funbox
-
>
isDerivedClassConstructor
(
)
)
lazy
-
>
setIsDerivedClassConstructor
(
)
;
if
(
funbox
-
>
needsHomeObject
(
)
)
lazy
-
>
setNeedsHomeObject
(
)
;
if
(
funbox
-
>
declaredArguments
)
lazy
-
>
setShouldDeclareArguments
(
)
;
if
(
funbox
-
>
hasThisBinding
(
)
)
lazy
-
>
setHasThisBinding
(
)
;
PropagateTransitiveParseFlags
(
funbox
lazy
)
;
fun
-
>
initLazyScript
(
lazy
)
;
return
true
;
}
static
YieldHandling
GetYieldHandling
(
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
)
{
if
(
asyncKind
=
=
AsyncFunction
)
return
YieldIsName
;
if
(
generatorKind
=
=
NotGenerator
)
return
YieldIsName
;
return
YieldIsKeyword
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
standaloneFunction
(
HandleFunction
fun
HandleScope
enclosingScope
const
Maybe
<
uint32_t
>
&
parameterListEnd
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
Directives
inheritedDirectives
Directives
*
newDirectives
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
Node
fn
=
handler
.
newFunctionStatement
(
)
;
if
(
!
fn
)
return
null
(
)
;
ParseNode
*
argsbody
=
handler
.
newList
(
PNK_PARAMSBODY
)
;
if
(
!
argsbody
)
return
null
(
)
;
fn
-
>
pn_body
=
argsbody
;
FunctionBox
*
funbox
=
newFunctionBox
(
fn
fun
inheritedDirectives
generatorKind
asyncKind
false
)
;
if
(
!
funbox
)
return
null
(
)
;
funbox
-
>
initStandaloneFunction
(
enclosingScope
)
;
ParseContext
funpc
(
this
funbox
newDirectives
)
;
if
(
!
funpc
.
init
(
)
)
return
null
(
)
;
funpc
.
setIsStandaloneFunctionBody
(
)
;
YieldHandling
yieldHandling
=
GetYieldHandling
(
generatorKind
asyncKind
)
;
AutoAwaitIsKeyword
awaitIsKeyword
(
&
tokenStream
asyncKind
=
=
AsyncFunction
)
;
if
(
!
functionFormalParametersAndBody
(
InAllowed
yieldHandling
fn
Statement
parameterListEnd
true
)
)
{
return
null
(
)
;
}
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_EOF
)
{
error
(
JSMSG_GARBAGE_AFTER_INPUT
"
function
body
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
if
(
!
FoldConstants
(
context
&
fn
this
)
)
return
null
(
)
;
return
fn
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
declareFunctionArgumentsObject
(
)
{
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
ParseContext
:
:
Scope
&
funScope
=
pc
-
>
functionScope
(
)
;
ParseContext
:
:
Scope
&
varScope
=
pc
-
>
varScope
(
)
;
bool
hasExtraBodyVarScope
=
&
funScope
!
=
&
varScope
;
HandlePropertyName
argumentsName
=
context
-
>
names
(
)
.
arguments
;
bool
tryDeclareArguments
;
if
(
handler
.
canSkipLazyClosedOverBindings
(
)
)
tryDeclareArguments
=
funbox
-
>
function
(
)
-
>
lazyScript
(
)
-
>
shouldDeclareArguments
(
)
;
else
tryDeclareArguments
=
hasUsedFunctionSpecialName
(
argumentsName
)
;
DeclaredNamePtr
p
=
varScope
.
lookupDeclaredName
(
argumentsName
)
;
if
(
p
&
&
(
p
-
>
value
(
)
-
>
kind
(
)
=
=
DeclarationKind
:
:
Var
|
|
p
-
>
value
(
)
-
>
kind
(
)
=
=
DeclarationKind
:
:
ForOfVar
)
)
{
if
(
hasExtraBodyVarScope
)
tryDeclareArguments
=
true
;
else
funbox
-
>
usesArguments
=
true
;
}
if
(
tryDeclareArguments
)
{
AddDeclaredNamePtr
p
=
funScope
.
lookupDeclaredNameForAdd
(
argumentsName
)
;
if
(
!
p
)
{
if
(
!
funScope
.
addDeclaredName
(
pc
p
argumentsName
DeclarationKind
:
:
Var
)
)
return
false
;
funbox
-
>
declaredArguments
=
true
;
funbox
-
>
usesArguments
=
true
;
}
else
if
(
hasExtraBodyVarScope
)
{
return
true
;
}
}
if
(
funbox
-
>
usesArguments
)
{
funbox
-
>
setArgumentsHasLocalBinding
(
)
;
if
(
pc
-
>
sc
(
)
-
>
bindingsAccessedDynamically
(
)
)
funbox
-
>
setDefinitelyNeedsArgsObj
(
)
;
if
(
pc
-
>
sc
(
)
-
>
hasDebuggerStatement
(
)
)
funbox
-
>
setDefinitelyNeedsArgsObj
(
)
;
}
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
functionBody
(
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
FunctionBodyType
type
)
{
MOZ_ASSERT
(
pc
-
>
isFunctionBox
(
)
)
;
MOZ_ASSERT
(
!
pc
-
>
funHasReturnExpr
&
&
!
pc
-
>
funHasReturnVoid
)
;
#
ifdef
DEBUG
uint32_t
startYieldOffset
=
pc
-
>
lastYieldOffset
;
#
endif
Node
pn
;
if
(
type
=
=
StatementListBody
)
{
bool
inheritedStrict
=
pc
-
>
sc
(
)
-
>
strict
(
)
;
pn
=
statementList
(
yieldHandling
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
!
inheritedStrict
&
&
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
MOZ_ASSERT
(
pc
-
>
sc
(
)
-
>
hasExplicitUseStrict
(
)
"
strict
mode
should
only
change
when
a
'
use
strict
'
directive
is
present
"
)
;
if
(
!
hasValidSimpleStrictParameterNames
(
)
)
{
pc
-
>
newDirectives
-
>
setStrict
(
)
;
return
null
(
)
;
}
}
}
else
{
MOZ_ASSERT
(
type
=
=
ExpressionBody
)
;
Node
stmtList
=
null
(
)
;
if
(
pc
-
>
isAsync
(
)
)
{
stmtList
=
handler
.
newStatementList
(
pos
(
)
)
;
if
(
!
stmtList
)
return
null
(
)
;
}
Node
kid
=
assignExpr
(
inHandling
yieldHandling
TripledotProhibited
)
;
if
(
!
kid
)
return
null
(
)
;
pn
=
handler
.
newReturnStatement
(
kid
handler
.
getPosition
(
kid
)
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
pc
-
>
isAsync
(
)
)
{
handler
.
addStatementToList
(
stmtList
pn
)
;
pn
=
stmtList
;
}
}
switch
(
pc
-
>
generatorKind
(
)
)
{
case
NotGenerator
:
MOZ_ASSERT
(
pc
-
>
lastYieldOffset
=
=
startYieldOffset
)
;
break
;
case
LegacyGenerator
:
MOZ_ASSERT
(
pc
-
>
lastYieldOffset
!
=
startYieldOffset
)
;
MOZ_ASSERT
(
kind
!
=
Arrow
)
;
MOZ_ASSERT
(
!
IsGetterKind
(
kind
)
)
;
MOZ_ASSERT
(
!
IsSetterKind
(
kind
)
)
;
MOZ_ASSERT
(
!
IsConstructorKind
(
kind
)
)
;
MOZ_ASSERT
(
kind
!
=
Method
)
;
MOZ_ASSERT
(
type
!
=
ExpressionBody
)
;
break
;
case
StarGenerator
:
MOZ_ASSERT_IF
(
!
pc
-
>
isAsync
(
)
kind
!
=
Arrow
)
;
MOZ_ASSERT_IF
(
!
pc
-
>
isAsync
(
)
type
=
=
StatementListBody
)
;
break
;
}
if
(
pc
-
>
isGenerator
(
)
)
{
MOZ_ASSERT_IF
(
!
pc
-
>
isAsync
(
)
type
=
=
StatementListBody
)
;
if
(
!
declareDotGeneratorName
(
)
)
return
null
(
)
;
Node
generator
=
newDotGeneratorName
(
)
;
if
(
!
generator
)
return
null
(
)
;
if
(
!
handler
.
prependInitialYield
(
pn
generator
)
)
return
null
(
)
;
}
if
(
kind
!
=
Arrow
)
{
if
(
!
declareFunctionArgumentsObject
(
)
)
return
null
(
)
;
if
(
!
declareFunctionThis
(
)
)
return
null
(
)
;
}
return
finishLexicalScope
(
pc
-
>
varScope
(
)
pn
)
;
}
template
<
typename
ParseHandler
>
JSFunction
*
Parser
<
ParseHandler
>
:
:
newFunction
(
HandleAtom
atom
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
HandleObject
proto
)
{
MOZ_ASSERT_IF
(
kind
=
=
Statement
atom
!
=
nullptr
)
;
RootedFunction
fun
(
context
)
;
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
;
JSFunction
:
:
Flags
flags
;
#
ifdef
DEBUG
bool
isGlobalSelfHostedBuiltin
=
false
;
#
endif
switch
(
kind
)
{
case
Expression
:
flags
=
(
generatorKind
=
=
NotGenerator
?
JSFunction
:
:
INTERPRETED_LAMBDA
:
JSFunction
:
:
INTERPRETED_LAMBDA_GENERATOR
)
;
break
;
case
Arrow
:
flags
=
JSFunction
:
:
INTERPRETED_LAMBDA_ARROW
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
break
;
case
Method
:
MOZ_ASSERT
(
generatorKind
=
=
NotGenerator
|
|
generatorKind
=
=
StarGenerator
)
;
flags
=
(
generatorKind
=
=
NotGenerator
?
JSFunction
:
:
INTERPRETED_METHOD
:
JSFunction
:
:
INTERPRETED_METHOD_GENERATOR
)
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
break
;
case
ClassConstructor
:
case
DerivedClassConstructor
:
flags
=
JSFunction
:
:
INTERPRETED_CLASS_CONSTRUCTOR
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
break
;
case
Getter
:
case
GetterNoExpressionClosure
:
flags
=
JSFunction
:
:
INTERPRETED_GETTER
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
break
;
case
Setter
:
case
SetterNoExpressionClosure
:
flags
=
JSFunction
:
:
INTERPRETED_SETTER
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
break
;
default
:
MOZ_ASSERT
(
kind
=
=
Statement
)
;
#
ifdef
DEBUG
if
(
options
(
)
.
selfHostingMode
&
&
!
pc
-
>
isFunctionBox
(
)
)
{
isGlobalSelfHostedBuiltin
=
true
;
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
}
#
endif
flags
=
(
generatorKind
=
=
NotGenerator
?
JSFunction
:
:
INTERPRETED_NORMAL
:
JSFunction
:
:
INTERPRETED_GENERATOR
)
;
}
if
(
asyncKind
=
=
AsyncFunction
)
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
fun
=
NewFunctionWithProto
(
context
nullptr
0
flags
nullptr
atom
proto
allocKind
TenuredObject
)
;
if
(
!
fun
)
return
nullptr
;
if
(
options
(
)
.
selfHostingMode
)
{
fun
-
>
setIsSelfHostedBuiltin
(
)
;
#
ifdef
DEBUG
if
(
isGlobalSelfHostedBuiltin
)
fun
-
>
setExtendedSlot
(
HAS_SELFHOSTED_CANONICAL_NAME_SLOT
BooleanValue
(
false
)
)
;
#
endif
}
return
fun
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
matchOrInsertSemicolonHelper
(
TokenStream
:
:
Modifier
modifier
)
{
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
modifier
)
)
return
false
;
if
(
tt
!
=
TOK_EOF
&
&
tt
!
=
TOK_EOL
&
&
tt
!
=
TOK_SEMI
&
&
tt
!
=
TOK_RC
)
{
if
(
!
pc
-
>
isAsync
(
)
&
&
tokenStream
.
currentToken
(
)
.
type
=
=
TOK_NAME
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
await
)
{
error
(
JSMSG_AWAIT_OUTSIDE_ASYNC
)
;
return
false
;
}
tokenStream
.
consumeKnownToken
(
tt
modifier
)
;
error
(
JSMSG_SEMI_BEFORE_STMNT
)
;
return
false
;
}
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_SEMI
modifier
)
)
return
false
;
if
(
!
matched
&
&
modifier
=
=
TokenStream
:
:
None
)
tokenStream
.
addModifierException
(
TokenStream
:
:
OperandIsNone
)
;
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
matchOrInsertSemicolonAfterExpression
(
)
{
return
matchOrInsertSemicolonHelper
(
TokenStream
:
:
None
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
matchOrInsertSemicolonAfterNonExpression
(
)
{
return
matchOrInsertSemicolonHelper
(
TokenStream
:
:
Operand
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
leaveInnerFunction
(
ParseContext
*
outerpc
)
{
MOZ_ASSERT
(
pc
!
=
outerpc
)
;
if
(
pc
-
>
superScopeNeedsHomeObject
(
)
)
{
if
(
!
pc
-
>
isArrowFunction
(
)
)
MOZ_ASSERT
(
pc
-
>
functionBox
(
)
-
>
needsHomeObject
(
)
)
;
else
outerpc
-
>
setSuperScopeNeedsHomeObject
(
)
;
}
if
(
!
outerpc
-
>
innerFunctionsForLazy
.
append
(
pc
-
>
functionBox
(
)
-
>
function
(
)
)
)
return
false
;
PropagateTransitiveParseFlags
(
pc
-
>
functionBox
(
)
outerpc
-
>
sc
(
)
)
;
return
true
;
}
template
<
typename
ParseHandler
>
JSAtom
*
Parser
<
ParseHandler
>
:
:
prefixAccessorName
(
PropertyType
propType
HandleAtom
propAtom
)
{
RootedAtom
prefix
(
context
)
;
if
(
propType
=
=
PropertyType
:
:
Setter
|
|
propType
=
=
PropertyType
:
:
SetterNoExpressionClosure
)
{
prefix
=
context
-
>
names
(
)
.
setPrefix
;
}
else
{
MOZ_ASSERT
(
propType
=
=
PropertyType
:
:
Getter
|
|
propType
=
=
PropertyType
:
:
GetterNoExpressionClosure
)
;
prefix
=
context
-
>
names
(
)
.
getPrefix
;
}
RootedString
str
(
context
ConcatStrings
<
CanGC
>
(
context
prefix
propAtom
)
)
;
if
(
!
str
)
return
nullptr
;
return
AtomizeString
(
context
str
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
functionArguments
(
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
Node
funcpn
)
{
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
bool
parenFreeArrow
=
false
;
TokenStream
:
:
Modifier
firstTokenModifier
=
TokenStream
:
:
None
;
TokenStream
:
:
Modifier
argModifier
=
TokenStream
:
:
Operand
;
if
(
kind
=
=
Arrow
)
{
TokenKind
tt
;
firstTokenModifier
=
funbox
-
>
isAsync
(
)
?
TokenStream
:
:
None
:
TokenStream
:
:
Operand
;
if
(
!
tokenStream
.
peekToken
(
&
tt
firstTokenModifier
)
)
return
false
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
{
parenFreeArrow
=
true
;
argModifier
=
firstTokenModifier
;
}
}
if
(
!
parenFreeArrow
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
firstTokenModifier
)
)
return
false
;
if
(
tt
!
=
TOK_LP
)
{
error
(
kind
=
=
Arrow
?
JSMSG_BAD_ARROW_ARGS
:
JSMSG_PAREN_BEFORE_FORMAL
)
;
return
false
;
}
funbox
-
>
setStart
(
tokenStream
)
;
}
Node
argsbody
=
handler
.
newList
(
PNK_PARAMSBODY
)
;
if
(
!
argsbody
)
return
false
;
handler
.
setFunctionFormalParametersAndBody
(
funcpn
argsbody
)
;
bool
hasArguments
=
false
;
if
(
parenFreeArrow
)
{
hasArguments
=
true
;
}
else
{
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_RP
TokenStream
:
:
Operand
)
)
return
false
;
if
(
!
matched
)
hasArguments
=
true
;
}
if
(
hasArguments
)
{
bool
hasRest
=
false
;
bool
hasDefault
=
false
;
bool
duplicatedParam
=
false
;
bool
disallowDuplicateParams
=
kind
=
=
Arrow
|
|
kind
=
=
Method
|
|
kind
=
=
ClassConstructor
;
AtomVector
&
positionalFormals
=
pc
-
>
positionalFormalParameterNames
(
)
;
if
(
IsGetterKind
(
kind
)
)
{
error
(
JSMSG_ACCESSOR_WRONG_ARGS
"
getter
"
"
no
"
"
s
"
)
;
return
false
;
}
while
(
true
)
{
if
(
hasRest
)
{
error
(
JSMSG_PARAMETER_AFTER_REST
)
;
return
false
;
}
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
argModifier
)
)
return
false
;
argModifier
=
TokenStream
:
:
Operand
;
MOZ_ASSERT_IF
(
parenFreeArrow
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
;
if
(
tt
=
=
TOK_TRIPLEDOT
)
{
if
(
IsSetterKind
(
kind
)
)
{
error
(
JSMSG_ACCESSOR_WRONG_ARGS
"
setter
"
"
one
"
"
"
)
;
return
false
;
}
disallowDuplicateParams
=
true
;
if
(
duplicatedParam
)
{
error
(
JSMSG_BAD_DUP_ARGS
)
;
return
false
;
}
hasRest
=
true
;
funbox
-
>
setHasRest
(
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
!
=
TOK_NAME
&
&
tt
!
=
TOK_YIELD
&
&
tt
!
=
TOK_LB
&
&
tt
!
=
TOK_LC
)
{
error
(
JSMSG_NO_REST_NAME
)
;
return
false
;
}
}
switch
(
tt
)
{
case
TOK_LB
:
case
TOK_LC
:
{
disallowDuplicateParams
=
true
;
if
(
duplicatedParam
)
{
error
(
JSMSG_BAD_DUP_ARGS
)
;
return
false
;
}
funbox
-
>
hasDestructuringArgs
=
true
;
Node
destruct
=
destructuringDeclarationWithoutYieldOrAwait
(
DeclarationKind
:
:
FormalParameter
yieldHandling
tt
)
;
if
(
!
destruct
)
return
false
;
if
(
!
noteDestructuredPositionalFormalParameter
(
funcpn
destruct
)
)
return
false
;
break
;
}
case
TOK_NAME
:
case
TOK_YIELD
:
{
if
(
parenFreeArrow
)
funbox
-
>
setStart
(
tokenStream
)
;
if
(
funbox
-
>
isAsync
(
)
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
await
)
{
error
(
JSMSG_RESERVED_ID
"
await
"
)
;
return
false
;
}
RootedPropertyName
name
(
context
bindingIdentifier
(
yieldHandling
)
)
;
if
(
!
name
)
return
false
;
if
(
!
notePositionalFormalParameter
(
funcpn
name
disallowDuplicateParams
&
duplicatedParam
)
)
{
return
false
;
}
if
(
duplicatedParam
)
funbox
-
>
hasDuplicateParameters
=
true
;
break
;
}
default
:
error
(
JSMSG_MISSING_FORMAL
)
;
return
false
;
}
if
(
positionalFormals
.
length
(
)
>
=
ARGNO_LIMIT
)
{
error
(
JSMSG_TOO_MANY_FUN_ARGS
)
;
return
false
;
}
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_ASSIGN
)
)
return
false
;
if
(
matched
)
{
MOZ_ASSERT
(
!
parenFreeArrow
)
;
if
(
hasRest
)
{
error
(
JSMSG_REST_WITH_DEFAULT
)
;
return
false
;
}
disallowDuplicateParams
=
true
;
if
(
duplicatedParam
)
{
error
(
JSMSG_BAD_DUP_ARGS
)
;
return
false
;
}
if
(
!
hasDefault
)
{
hasDefault
=
true
;
funbox
-
>
length
=
positionalFormals
.
length
(
)
-
1
;
}
funbox
-
>
hasParameterExprs
=
true
;
Node
def_expr
=
assignExprWithoutYieldOrAwait
(
yieldHandling
)
;
if
(
!
def_expr
)
return
false
;
if
(
!
handler
.
setLastFunctionFormalParameterDefault
(
funcpn
def_expr
)
)
return
false
;
}
if
(
parenFreeArrow
|
|
IsSetterKind
(
kind
)
)
break
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
false
;
if
(
!
matched
)
break
;
if
(
!
hasRest
)
{
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RP
)
{
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
break
;
}
}
}
if
(
!
parenFreeArrow
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
!
=
TOK_RP
)
{
if
(
IsSetterKind
(
kind
)
)
{
error
(
JSMSG_ACCESSOR_WRONG_ARGS
"
setter
"
"
one
"
"
"
)
;
return
false
;
}
error
(
JSMSG_PAREN_AFTER_FORMAL
)
;
return
false
;
}
}
if
(
!
hasDefault
)
funbox
-
>
length
=
positionalFormals
.
length
(
)
-
hasRest
;
if
(
funbox
-
>
hasParameterExprs
&
&
funbox
-
>
hasDirectEval
(
)
)
funbox
-
>
hasDirectEvalInParameterExpr
=
true
;
funbox
-
>
function
(
)
-
>
setArgCount
(
positionalFormals
.
length
(
)
)
;
}
else
if
(
IsSetterKind
(
kind
)
)
{
error
(
JSMSG_ACCESSOR_WRONG_ARGS
"
setter
"
"
one
"
"
"
)
;
return
false
;
}
return
true
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
skipLazyInnerFunction
(
ParseNode
*
pn
FunctionSyntaxKind
kind
bool
tryAnnexB
)
{
RootedFunction
fun
(
context
handler
.
nextLazyInnerFunction
(
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isLegacyGenerator
(
)
)
;
FunctionBox
*
funbox
=
newFunctionBox
(
pn
fun
Directives
(
false
)
fun
-
>
generatorKind
(
)
fun
-
>
asyncKind
(
)
tryAnnexB
)
;
if
(
!
funbox
)
return
false
;
LazyScript
*
lazy
=
fun
-
>
lazyScript
(
)
;
if
(
lazy
-
>
needsHomeObject
(
)
)
funbox
-
>
setNeedsHomeObject
(
)
;
if
(
lazy
-
>
isExprBody
(
)
)
funbox
-
>
setIsExprBody
(
)
;
PropagateTransitiveParseFlags
(
lazy
pc
-
>
sc
(
)
)
;
Rooted
<
LazyScript
*
>
lazyOuter
(
context
handler
.
lazyOuterFunction
(
)
)
;
uint32_t
userbufBase
=
lazyOuter
-
>
begin
(
)
-
lazyOuter
-
>
column
(
)
;
if
(
!
tokenStream
.
advance
(
fun
-
>
lazyScript
(
)
-
>
end
(
)
-
userbufBase
)
)
return
false
;
#
if
JS_HAS_EXPR_CLOSURES
if
(
kind
=
=
Statement
&
&
funbox
-
>
isExprBody
(
)
)
{
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
false
;
}
#
endif
return
true
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
skipLazyInnerFunction
(
Node
pn
FunctionSyntaxKind
kind
bool
tryAnnexB
)
{
MOZ_CRASH
(
"
Cannot
skip
lazy
inner
functions
when
syntax
parsing
"
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
addExprAndGetNextTemplStrToken
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
*
ttp
)
{
Node
pn
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
pn
)
return
false
;
handler
.
addList
(
nodeList
pn
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
!
=
TOK_RC
)
{
error
(
JSMSG_TEMPLSTR_UNTERM_EXPR
)
;
return
false
;
}
return
tokenStream
.
getToken
(
ttp
TokenStream
:
:
TemplateTail
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
taggedTemplate
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
tt
)
{
Node
callSiteObjNode
=
handler
.
newCallSiteObject
(
pos
(
)
.
begin
)
;
if
(
!
callSiteObjNode
)
return
false
;
handler
.
addList
(
nodeList
callSiteObjNode
)
;
while
(
true
)
{
if
(
!
appendToCallSiteObj
(
callSiteObjNode
)
)
return
false
;
if
(
tt
!
=
TOK_TEMPLATE_HEAD
)
break
;
if
(
!
addExprAndGetNextTemplStrToken
(
yieldHandling
nodeList
&
tt
)
)
return
false
;
}
handler
.
setEndPosition
(
nodeList
callSiteObjNode
)
;
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
templateLiteral
(
YieldHandling
yieldHandling
)
{
Node
pn
=
noSubstitutionUntaggedTemplate
(
)
;
if
(
!
pn
)
return
null
(
)
;
Node
nodeList
=
handler
.
newList
(
PNK_TEMPLATE_STRING_LIST
pn
)
;
if
(
!
nodeList
)
return
null
(
)
;
TokenKind
tt
;
do
{
if
(
!
addExprAndGetNextTemplStrToken
(
yieldHandling
nodeList
&
tt
)
)
return
null
(
)
;
pn
=
noSubstitutionUntaggedTemplate
(
)
;
if
(
!
pn
)
return
null
(
)
;
handler
.
addList
(
nodeList
pn
)
;
}
while
(
tt
=
=
TOK_TEMPLATE_HEAD
)
;
return
nodeList
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
functionDefinition
(
Node
pn
InHandling
inHandling
YieldHandling
yieldHandling
HandleAtom
funName
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
tryAnnexB
)
{
MOZ_ASSERT_IF
(
kind
=
=
Statement
funName
)
;
MOZ_ASSERT_IF
(
asyncKind
=
=
AsyncFunction
generatorKind
=
=
StarGenerator
)
;
if
(
handler
.
canSkipLazyInnerFunctions
(
)
)
{
if
(
!
skipLazyInnerFunction
(
pn
kind
tryAnnexB
)
)
return
null
(
)
;
return
pn
;
}
RootedObject
proto
(
context
)
;
if
(
generatorKind
=
=
StarGenerator
)
{
JSContext
*
cx
=
context
-
>
helperThread
(
)
?
nullptr
:
context
;
proto
=
GlobalObject
:
:
getOrCreateStarGeneratorFunctionPrototype
(
cx
context
-
>
global
(
)
)
;
if
(
!
proto
)
return
null
(
)
;
}
RootedFunction
fun
(
context
newFunction
(
funName
kind
generatorKind
asyncKind
proto
)
)
;
if
(
!
fun
)
return
null
(
)
;
Directives
directives
(
pc
)
;
Directives
newDirectives
=
directives
;
TokenStream
:
:
Position
start
(
keepAtoms
)
;
tokenStream
.
tell
(
&
start
)
;
while
(
true
)
{
if
(
trySyntaxParseInnerFunction
(
pn
fun
inHandling
yieldHandling
kind
generatorKind
asyncKind
tryAnnexB
directives
&
newDirectives
)
)
{
break
;
}
if
(
tokenStream
.
hadError
(
)
|
|
directives
=
=
newDirectives
)
return
null
(
)
;
MOZ_ASSERT_IF
(
directives
.
strict
(
)
newDirectives
.
strict
(
)
)
;
MOZ_ASSERT_IF
(
directives
.
asmJS
(
)
newDirectives
.
asmJS
(
)
)
;
directives
=
newDirectives
;
tokenStream
.
seek
(
start
)
;
handler
.
setFunctionFormalParametersAndBody
(
pn
null
(
)
)
;
}
return
pn
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
trySyntaxParseInnerFunction
(
ParseNode
*
pn
HandleFunction
fun
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
tryAnnexB
Directives
inheritedDirectives
Directives
*
newDirectives
)
{
do
{
if
(
pn
-
>
isLikelyIIFE
(
)
&
&
generatorKind
=
=
NotGenerator
)
break
;
Parser
<
SyntaxParseHandler
>
*
parser
=
handler
.
syntaxParser
;
if
(
!
parser
)
break
;
UsedNameTracker
:
:
RewindToken
token
=
usedNames
.
getRewindToken
(
)
;
TokenStream
:
:
Position
position
(
keepAtoms
)
;
tokenStream
.
tell
(
&
position
)
;
if
(
!
parser
-
>
tokenStream
.
seek
(
position
tokenStream
)
)
return
false
;
FunctionBox
*
funbox
=
newFunctionBox
(
pn
fun
inheritedDirectives
generatorKind
asyncKind
tryAnnexB
)
;
if
(
!
funbox
)
return
false
;
funbox
-
>
initWithEnclosingParseContext
(
pc
kind
)
;
if
(
!
parser
-
>
innerFunction
(
SyntaxParseHandler
:
:
NodeGeneric
pc
funbox
inHandling
yieldHandling
kind
inheritedDirectives
newDirectives
)
)
{
if
(
parser
-
>
hadAbortedSyntaxParse
(
)
)
{
parser
-
>
clearAbortedSyntaxParse
(
)
;
usedNames
.
rewind
(
token
)
;
MOZ_ASSERT_IF
(
!
parser
-
>
context
-
>
helperThread
(
)
!
parser
-
>
context
-
>
isExceptionPending
(
)
)
;
break
;
}
return
false
;
}
parser
-
>
tokenStream
.
tell
(
&
position
)
;
if
(
!
tokenStream
.
seek
(
position
parser
-
>
tokenStream
)
)
return
false
;
pn
-
>
pn_pos
.
end
=
tokenStream
.
currentToken
(
)
.
pos
.
end
;
return
true
;
}
while
(
false
)
;
return
innerFunction
(
pn
pc
fun
inHandling
yieldHandling
kind
generatorKind
asyncKind
tryAnnexB
inheritedDirectives
newDirectives
)
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
trySyntaxParseInnerFunction
(
Node
pn
HandleFunction
fun
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
tryAnnexB
Directives
inheritedDirectives
Directives
*
newDirectives
)
{
return
innerFunction
(
pn
pc
fun
inHandling
yieldHandling
kind
generatorKind
asyncKind
tryAnnexB
inheritedDirectives
newDirectives
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
innerFunction
(
Node
pn
ParseContext
*
outerpc
FunctionBox
*
funbox
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
Directives
inheritedDirectives
Directives
*
newDirectives
)
{
ParseContext
funpc
(
this
funbox
newDirectives
)
;
if
(
!
funpc
.
init
(
)
)
return
false
;
if
(
!
functionFormalParametersAndBody
(
inHandling
yieldHandling
pn
kind
)
)
return
false
;
return
leaveInnerFunction
(
outerpc
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
innerFunction
(
Node
pn
ParseContext
*
outerpc
HandleFunction
fun
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
tryAnnexB
Directives
inheritedDirectives
Directives
*
newDirectives
)
{
FunctionBox
*
funbox
=
newFunctionBox
(
pn
fun
inheritedDirectives
generatorKind
asyncKind
tryAnnexB
)
;
if
(
!
funbox
)
return
false
;
funbox
-
>
initWithEnclosingParseContext
(
outerpc
kind
)
;
return
innerFunction
(
pn
outerpc
funbox
inHandling
yieldHandling
kind
inheritedDirectives
newDirectives
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
appendToCallSiteObj
(
Node
callSiteObj
)
{
Node
cookedNode
=
noSubstitutionTaggedTemplate
(
)
;
if
(
!
cookedNode
)
return
false
;
JSAtom
*
atom
=
tokenStream
.
getRawTemplateStringAtom
(
)
;
if
(
!
atom
)
return
false
;
Node
rawNode
=
handler
.
newTemplateStringLiteral
(
atom
pos
(
)
)
;
if
(
!
rawNode
)
return
false
;
handler
.
addToCallSiteObject
(
callSiteObj
rawNode
cookedNode
)
;
return
true
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
standaloneLazyFunction
(
HandleFunction
fun
bool
strict
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
Node
pn
=
handler
.
newFunctionStatement
(
)
;
if
(
!
pn
)
return
null
(
)
;
Directives
directives
(
strict
)
;
FunctionBox
*
funbox
=
newFunctionBox
(
pn
fun
directives
generatorKind
asyncKind
false
)
;
if
(
!
funbox
)
return
null
(
)
;
funbox
-
>
initFromLazyFunction
(
)
;
Directives
newDirectives
=
directives
;
ParseContext
funpc
(
this
funbox
&
newDirectives
)
;
if
(
!
funpc
.
init
(
)
)
return
null
(
)
;
TokenStream
:
:
Modifier
modifier
=
(
fun
-
>
isArrow
(
)
&
&
asyncKind
=
=
SyncFunction
)
?
TokenStream
:
:
Operand
:
TokenStream
:
:
None
;
if
(
!
tokenStream
.
peekTokenPos
(
&
pn
-
>
pn_pos
modifier
)
)
return
null
(
)
;
YieldHandling
yieldHandling
=
GetYieldHandling
(
generatorKind
asyncKind
)
;
FunctionSyntaxKind
syntaxKind
=
Statement
;
if
(
fun
-
>
isClassConstructor
(
)
)
syntaxKind
=
ClassConstructor
;
else
if
(
fun
-
>
isMethod
(
)
)
syntaxKind
=
Method
;
else
if
(
fun
-
>
isGetter
(
)
)
syntaxKind
=
Getter
;
else
if
(
fun
-
>
isSetter
(
)
)
syntaxKind
=
Setter
;
else
if
(
fun
-
>
isArrow
(
)
)
syntaxKind
=
Arrow
;
if
(
!
functionFormalParametersAndBody
(
InAllowed
yieldHandling
pn
syntaxKind
)
)
{
MOZ_ASSERT
(
directives
=
=
newDirectives
)
;
return
null
(
)
;
}
if
(
!
FoldConstants
(
context
&
pn
this
)
)
return
null
(
)
;
return
pn
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
functionFormalParametersAndBody
(
InHandling
inHandling
YieldHandling
yieldHandling
Node
pn
FunctionSyntaxKind
kind
const
Maybe
<
uint32_t
>
&
parameterListEnd
bool
isStandaloneFunction
)
{
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
RootedFunction
fun
(
context
funbox
-
>
function
(
)
)
;
AutoAwaitIsKeyword
awaitIsKeyword
(
&
tokenStream
funbox
-
>
isAsync
(
)
)
;
if
(
!
functionArguments
(
yieldHandling
kind
pn
)
)
return
false
;
Maybe
<
ParseContext
:
:
VarScope
>
varScope
;
if
(
funbox
-
>
hasParameterExprs
)
{
varScope
.
emplace
(
this
)
;
if
(
!
varScope
-
>
init
(
pc
)
)
return
false
;
}
else
{
pc
-
>
functionScope
(
)
.
useAsVarScope
(
pc
)
;
}
if
(
kind
=
=
Arrow
)
{
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_ARROW
)
)
return
false
;
if
(
!
matched
)
{
error
(
JSMSG_BAD_ARROW_ARGS
)
;
return
false
;
}
}
if
(
parameterListEnd
.
isSome
(
)
&
&
parameterListEnd
.
value
(
)
!
=
pos
(
)
.
begin
)
{
error
(
JSMSG_UNEXPECTED_PARAMLIST_END
)
;
return
false
;
}
FunctionBodyType
bodyType
=
StatementListBody
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
false
;
if
(
tt
!
=
TOK_LC
)
{
if
(
(
funbox
-
>
isStarGenerator
(
)
&
&
!
funbox
-
>
isAsync
(
)
)
|
|
kind
=
=
Method
|
|
kind
=
=
GetterNoExpressionClosure
|
|
kind
=
=
SetterNoExpressionClosure
|
|
IsConstructorKind
(
kind
)
)
{
error
(
JSMSG_CURLY_BEFORE_BODY
)
;
return
false
;
}
if
(
kind
!
=
Arrow
)
{
#
if
JS_HAS_EXPR_CLOSURES
addTelemetry
(
JSCompartment
:
:
DeprecatedExpressionClosure
)
;
if
(
!
warnOnceAboutExprClosure
(
)
)
return
false
;
#
else
error
(
JSMSG_CURLY_BEFORE_BODY
)
;
return
false
;
#
endif
}
tokenStream
.
ungetToken
(
)
;
bodyType
=
ExpressionBody
;
funbox
-
>
setIsExprBody
(
)
;
}
YieldHandling
bodyYieldHandling
=
GetYieldHandling
(
pc
-
>
generatorKind
(
)
pc
-
>
asyncKind
(
)
)
;
Node
body
=
functionBody
(
inHandling
bodyYieldHandling
kind
bodyType
)
;
if
(
!
body
)
return
false
;
if
(
(
kind
!
=
Method
&
&
!
IsConstructorKind
(
kind
)
)
&
&
fun
-
>
explicitName
(
)
)
{
RootedPropertyName
propertyName
(
context
fun
-
>
explicitName
(
)
-
>
asPropertyName
(
)
)
;
if
(
!
checkStrictBinding
(
propertyName
handler
.
getPosition
(
pn
)
)
)
return
false
;
}
if
(
bodyType
=
=
StatementListBody
)
{
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_RC
TokenStream
:
:
Operand
)
)
return
false
;
if
(
!
matched
)
{
error
(
JSMSG_CURLY_AFTER_BODY
)
;
return
false
;
}
funbox
-
>
bufEnd
=
pos
(
)
.
end
;
}
else
{
#
if
!
JS_HAS_EXPR_CLOSURES
MOZ_ASSERT
(
kind
=
=
Arrow
)
;
#
endif
if
(
tokenStream
.
hadError
(
)
)
return
false
;
funbox
-
>
bufEnd
=
pos
(
)
.
end
;
if
(
kind
=
=
Statement
&
&
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
false
;
}
if
(
IsMethodDefinitionKind
(
kind
)
&
&
pc
-
>
superScopeNeedsHomeObject
(
)
)
funbox
-
>
setNeedsHomeObject
(
)
;
if
(
!
finishFunction
(
isStandaloneFunction
)
)
return
false
;
handler
.
setEndPosition
(
body
pos
(
)
.
begin
)
;
handler
.
setEndPosition
(
pn
pos
(
)
.
end
)
;
handler
.
setFunctionBody
(
pn
body
)
;
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
functionStmt
(
YieldHandling
yieldHandling
DefaultHandling
defaultHandling
FunctionAsyncKind
asyncKind
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FUNCTION
)
)
;
ParseContext
:
:
Statement
*
declaredInStmt
=
pc
-
>
innermostStatement
(
)
;
if
(
declaredInStmt
&
&
declaredInStmt
-
>
kind
(
)
=
=
StatementKind
:
:
Label
)
{
MOZ_ASSERT
(
!
pc
-
>
sc
(
)
-
>
strict
(
)
"
labeled
functions
shouldn
'
t
be
parsed
in
strict
mode
"
)
;
while
(
declaredInStmt
&
&
declaredInStmt
-
>
kind
(
)
=
=
StatementKind
:
:
Label
)
declaredInStmt
=
declaredInStmt
-
>
enclosing
(
)
;
if
(
declaredInStmt
&
&
!
StatementKindIsBraced
(
declaredInStmt
-
>
kind
(
)
)
)
{
error
(
JSMSG_SLOPPY_FUNCTION_LABEL
)
;
return
null
(
)
;
}
}
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
GeneratorKind
generatorKind
=
asyncKind
=
=
AsyncFunction
?
StarGenerator
:
NotGenerator
;
if
(
tt
=
=
TOK_MUL
)
{
if
(
asyncKind
!
=
SyncFunction
)
{
error
(
JSMSG_ASYNC_GENERATOR
)
;
return
null
(
)
;
}
generatorKind
=
StarGenerator
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
}
RootedPropertyName
name
(
context
)
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
{
name
=
bindingIdentifier
(
yieldHandling
)
;
if
(
!
name
)
return
null
(
)
;
}
else
if
(
defaultHandling
=
=
AllowDefaultName
)
{
name
=
context
-
>
names
(
)
.
starDefaultStar
;
tokenStream
.
ungetToken
(
)
;
}
else
{
error
(
JSMSG_UNNAMED_FUNCTION_STMT
)
;
return
null
(
)
;
}
bool
tryAnnexB
=
false
;
if
(
declaredInStmt
)
{
MOZ_ASSERT
(
declaredInStmt
-
>
kind
(
)
!
=
StatementKind
:
:
Label
)
;
MOZ_ASSERT
(
StatementKindIsBraced
(
declaredInStmt
-
>
kind
(
)
)
)
;
if
(
!
pc
-
>
sc
(
)
-
>
strict
(
)
&
&
generatorKind
=
=
NotGenerator
)
{
if
(
!
tryDeclareVarForAnnexBLexicalFunction
(
name
&
tryAnnexB
)
)
return
null
(
)
;
}
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
LexicalFunction
pos
(
)
)
)
return
null
(
)
;
}
else
{
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
BodyLevelFunction
pos
(
)
)
)
return
null
(
)
;
if
(
pc
-
>
atModuleLevel
(
)
)
pc
-
>
varScope
(
)
.
lookupDeclaredName
(
name
)
-
>
value
(
)
-
>
setClosedOver
(
)
;
}
Node
pn
=
handler
.
newFunctionStatement
(
)
;
if
(
!
pn
)
return
null
(
)
;
YieldHandling
newYieldHandling
=
GetYieldHandling
(
generatorKind
asyncKind
)
;
return
functionDefinition
(
pn
InAllowed
newYieldHandling
name
Statement
generatorKind
asyncKind
tryAnnexB
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
functionExpr
(
InvokedPrediction
invoked
FunctionAsyncKind
asyncKind
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FUNCTION
)
)
;
AutoAwaitIsKeyword
awaitIsKeyword
(
&
tokenStream
asyncKind
=
=
AsyncFunction
)
;
GeneratorKind
generatorKind
=
asyncKind
=
=
AsyncFunction
?
StarGenerator
:
NotGenerator
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_MUL
)
{
if
(
asyncKind
!
=
SyncFunction
)
{
error
(
JSMSG_ASYNC_GENERATOR
)
;
return
null
(
)
;
}
generatorKind
=
StarGenerator
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
}
YieldHandling
yieldHandling
=
GetYieldHandling
(
generatorKind
asyncKind
)
;
RootedPropertyName
name
(
context
)
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
{
name
=
bindingIdentifier
(
yieldHandling
)
;
if
(
!
name
)
return
null
(
)
;
}
else
{
tokenStream
.
ungetToken
(
)
;
}
Node
pn
=
handler
.
newFunctionExpression
(
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
invoked
)
pn
=
handler
.
setLikelyIIFE
(
pn
)
;
return
functionDefinition
(
pn
InAllowed
yieldHandling
name
Expression
generatorKind
asyncKind
)
;
}
static
inline
bool
IsEscapeFreeStringLiteral
(
const
TokenPos
&
pos
JSAtom
*
str
)
{
return
pos
.
begin
+
str
-
>
length
(
)
+
2
=
=
pos
.
end
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkUnescapedName
(
)
{
const
Token
&
token
=
tokenStream
.
currentToken
(
)
;
if
(
!
token
.
nameContainsEscape
(
)
)
return
true
;
errorAt
(
token
.
pos
.
begin
JSMSG_ESCAPED_KEYWORD
)
;
return
false
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
asmJS
(
Node
list
)
{
JS_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
false
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
asmJS
(
Node
list
)
{
handler
.
disableSyntaxParser
(
)
;
if
(
!
pc
-
>
newDirectives
|
|
pc
-
>
newDirectives
-
>
asmJS
(
)
)
return
true
;
if
(
ss
=
=
nullptr
)
return
true
;
pc
-
>
functionBox
(
)
-
>
useAsm
=
true
;
bool
validated
;
if
(
!
CompileAsmJS
(
context
*
this
list
&
validated
)
)
return
false
;
if
(
!
validated
)
{
pc
-
>
newDirectives
-
>
setAsmJS
(
)
;
return
false
;
}
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
maybeParseDirective
(
Node
list
Node
possibleDirective
bool
*
cont
)
{
TokenPos
directivePos
;
JSAtom
*
directive
=
handler
.
isStringExprStatement
(
possibleDirective
&
directivePos
)
;
*
cont
=
!
!
directive
;
if
(
!
*
cont
)
return
true
;
if
(
IsEscapeFreeStringLiteral
(
directivePos
directive
)
)
{
handler
.
setInDirectivePrologue
(
possibleDirective
)
;
if
(
directive
=
=
context
-
>
names
(
)
.
useStrict
)
{
if
(
pc
-
>
isFunctionBox
(
)
)
{
FunctionBox
*
funbox
=
pc
-
>
functionBox
(
)
;
if
(
!
funbox
-
>
hasSimpleParameterList
(
)
)
{
const
char
*
parameterKind
=
funbox
-
>
hasDestructuringArgs
?
"
destructuring
"
:
funbox
-
>
hasParameterExprs
?
"
default
"
:
"
rest
"
;
errorAt
(
directivePos
.
begin
JSMSG_STRICT_NON_SIMPLE_PARAMS
parameterKind
)
;
return
false
;
}
}
pc
-
>
sc
(
)
-
>
setExplicitUseStrict
(
)
;
if
(
!
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
if
(
tokenStream
.
sawOctalEscape
(
)
)
{
error
(
JSMSG_DEPRECATED_OCTAL
)
;
return
false
;
}
pc
-
>
sc
(
)
-
>
strictScript
=
true
;
}
}
else
if
(
directive
=
=
context
-
>
names
(
)
.
useAsm
)
{
if
(
pc
-
>
isFunctionBox
(
)
)
return
asmJS
(
list
)
;
return
warningAt
(
directivePos
.
begin
JSMSG_USE_ASM_DIRECTIVE_FAIL
)
;
}
}
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
statementList
(
YieldHandling
yieldHandling
)
{
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
Node
pn
=
handler
.
newStatementList
(
pos
(
)
)
;
if
(
!
pn
)
return
null
(
)
;
bool
canHaveDirectives
=
pc
-
>
atBodyLevel
(
)
;
if
(
canHaveDirectives
)
tokenStream
.
clearSawOctalEscape
(
)
;
bool
afterReturn
=
false
;
bool
warnedAboutStatementsAfterReturn
=
false
;
uint32_t
statementBegin
=
0
;
for
(
;
;
)
{
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
{
if
(
tokenStream
.
isEOF
(
)
)
isUnexpectedEOF_
=
true
;
return
null
(
)
;
}
if
(
tt
=
=
TOK_EOF
|
|
tt
=
=
TOK_RC
)
break
;
if
(
afterReturn
)
{
if
(
!
tokenStream
.
peekOffset
(
&
statementBegin
TokenStream
:
:
Operand
)
)
return
null
(
)
;
}
Node
next
=
statementListItem
(
yieldHandling
canHaveDirectives
)
;
if
(
!
next
)
{
if
(
tokenStream
.
isEOF
(
)
)
isUnexpectedEOF_
=
true
;
return
null
(
)
;
}
if
(
!
warnedAboutStatementsAfterReturn
)
{
if
(
afterReturn
)
{
if
(
!
handler
.
isStatementPermittedAfterReturnStatement
(
next
)
)
{
if
(
!
warningAt
(
statementBegin
JSMSG_STMT_AFTER_RETURN
)
)
return
null
(
)
;
warnedAboutStatementsAfterReturn
=
true
;
}
}
else
if
(
handler
.
isReturnStatement
(
next
)
)
{
afterReturn
=
true
;
}
}
if
(
canHaveDirectives
)
{
if
(
!
maybeParseDirective
(
pn
next
&
canHaveDirectives
)
)
return
null
(
)
;
}
handler
.
addStatementToList
(
pn
next
)
;
}
return
pn
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
condition
(
InHandling
inHandling
YieldHandling
yieldHandling
)
{
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_BEFORE_COND
)
;
Node
pn
=
exprInParens
(
inHandling
yieldHandling
TripledotProhibited
)
;
if
(
!
pn
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_COND
)
;
if
(
handler
.
isUnparenthesizedAssignment
(
pn
)
)
{
if
(
!
extraWarning
(
JSMSG_EQUAL_AS_ASSIGN
)
)
return
null
(
)
;
}
return
pn
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
matchLabel
(
YieldHandling
yieldHandling
MutableHandle
<
PropertyName
*
>
label
)
{
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
TokenStream
:
:
Operand
)
)
return
false
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
{
tokenStream
.
consumeKnownToken
(
tt
TokenStream
:
:
Operand
)
;
label
.
set
(
labelIdentifier
(
yieldHandling
)
)
;
if
(
!
label
)
return
false
;
}
else
{
label
.
set
(
nullptr
)
;
}
return
true
;
}
template
<
typename
ParseHandler
>
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
PossibleError
(
Parser
<
ParseHandler
>
&
parser
)
:
parser_
(
parser
)
{
}
template
<
typename
ParseHandler
>
typename
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
Error
&
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
error
(
ErrorKind
kind
)
{
if
(
kind
=
=
ErrorKind
:
:
Expression
)
return
exprError_
;
MOZ_ASSERT
(
kind
=
=
ErrorKind
:
:
Destructuring
)
;
return
destructuringError_
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
setResolved
(
ErrorKind
kind
)
{
error
(
kind
)
.
state_
=
ErrorState
:
:
None
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
hasError
(
ErrorKind
kind
)
{
return
error
(
kind
)
.
state_
=
=
ErrorState
:
:
Pending
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
setPending
(
ErrorKind
kind
const
TokenPos
&
pos
unsigned
errorNumber
)
{
if
(
hasError
(
kind
)
)
return
;
Error
&
err
=
error
(
kind
)
;
err
.
offset_
=
pos
.
begin
;
err
.
errorNumber_
=
errorNumber
;
err
.
state_
=
ErrorState
:
:
Pending
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
setPendingDestructuringErrorAt
(
const
TokenPos
&
pos
unsigned
errorNumber
)
{
setPending
(
ErrorKind
:
:
Destructuring
pos
errorNumber
)
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
setPendingExpressionErrorAt
(
const
TokenPos
&
pos
unsigned
errorNumber
)
{
setPending
(
ErrorKind
:
:
Expression
pos
errorNumber
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
checkForError
(
ErrorKind
kind
)
{
if
(
!
hasError
(
kind
)
)
return
true
;
Error
&
err
=
error
(
kind
)
;
parser_
.
errorAt
(
err
.
offset_
err
.
errorNumber_
)
;
return
false
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
checkForDestructuringError
(
)
{
setResolved
(
ErrorKind
:
:
Expression
)
;
return
checkForError
(
ErrorKind
:
:
Destructuring
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
checkForExpressionError
(
)
{
setResolved
(
ErrorKind
:
:
Destructuring
)
;
return
checkForError
(
ErrorKind
:
:
Expression
)
;
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
transferErrorTo
(
ErrorKind
kind
PossibleError
*
other
)
{
if
(
hasError
(
kind
)
&
&
!
other
-
>
hasError
(
kind
)
)
{
Error
&
err
=
error
(
kind
)
;
Error
&
otherErr
=
other
-
>
error
(
kind
)
;
otherErr
.
offset_
=
err
.
offset_
;
otherErr
.
errorNumber_
=
err
.
errorNumber_
;
otherErr
.
state_
=
err
.
state_
;
}
}
template
<
typename
ParseHandler
>
void
Parser
<
ParseHandler
>
:
:
PossibleError
:
:
transferErrorsTo
(
PossibleError
*
other
)
{
MOZ_ASSERT
(
other
)
;
MOZ_ASSERT
(
this
!
=
other
)
;
MOZ_ASSERT
(
&
parser_
=
=
&
other
-
>
parser_
"
Can
'
t
transfer
fields
to
an
instance
which
belongs
to
a
different
parser
"
)
;
transferErrorTo
(
ErrorKind
:
:
Destructuring
other
)
;
transferErrorTo
(
ErrorKind
:
:
Expression
other
)
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkDestructuringName
(
ParseNode
*
expr
const
Maybe
<
DeclarationKind
>
&
maybeDecl
)
{
MOZ_ASSERT
(
!
handler
.
isUnparenthesizedDestructuringPattern
(
expr
)
)
;
if
(
handler
.
isParenthesizedDestructuringPattern
(
expr
)
)
{
errorAt
(
expr
-
>
pn_pos
.
begin
JSMSG_BAD_DESTRUCT_PARENS
)
;
return
false
;
}
if
(
maybeDecl
)
{
if
(
!
handler
.
isUnparenthesizedName
(
expr
)
)
{
errorAt
(
expr
-
>
pn_pos
.
begin
JSMSG_NO_VARIABLE_NAME
)
;
return
false
;
}
RootedPropertyName
name
(
context
expr
-
>
name
(
)
)
;
return
noteDeclaredName
(
name
*
maybeDecl
expr
-
>
pn_pos
)
;
}
if
(
handler
.
isNameAnyParentheses
(
expr
)
)
{
if
(
const
char
*
chars
=
handler
.
nameIsArgumentsEvalAnyParentheses
(
expr
context
)
)
{
if
(
!
strictModeErrorAt
(
expr
-
>
pn_pos
.
begin
JSMSG_BAD_STRICT_ASSIGN
chars
)
)
return
false
;
}
return
true
;
}
if
(
handler
.
isPropertyAccess
(
expr
)
)
return
true
;
errorAt
(
expr
-
>
pn_pos
.
begin
JSMSG_BAD_DESTRUCT_TARGET
)
;
return
false
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkDestructuringPattern
(
ParseNode
*
pattern
const
Maybe
<
DeclarationKind
>
&
maybeDecl
PossibleError
*
possibleError
)
;
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkDestructuringObject
(
ParseNode
*
objectPattern
const
Maybe
<
DeclarationKind
>
&
maybeDecl
)
{
MOZ_ASSERT
(
objectPattern
-
>
isKind
(
PNK_OBJECT
)
)
;
for
(
ParseNode
*
member
=
objectPattern
-
>
pn_head
;
member
;
member
=
member
-
>
pn_next
)
{
ParseNode
*
target
;
if
(
member
-
>
isKind
(
PNK_MUTATEPROTO
)
)
{
target
=
member
-
>
pn_kid
;
}
else
{
MOZ_ASSERT
(
member
-
>
isKind
(
PNK_COLON
)
|
|
member
-
>
isKind
(
PNK_SHORTHAND
)
)
;
MOZ_ASSERT_IF
(
member
-
>
isKind
(
PNK_SHORTHAND
)
member
-
>
pn_left
-
>
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
&
&
member
-
>
pn_right
-
>
isKind
(
PNK_NAME
)
&
&
member
-
>
pn_left
-
>
pn_atom
=
=
member
-
>
pn_right
-
>
pn_atom
)
;
target
=
member
-
>
pn_right
;
}
if
(
handler
.
isUnparenthesizedAssignment
(
target
)
)
target
=
target
-
>
pn_left
;
if
(
handler
.
isUnparenthesizedDestructuringPattern
(
target
)
)
{
if
(
!
checkDestructuringPattern
(
target
maybeDecl
)
)
return
false
;
}
else
{
if
(
!
checkDestructuringName
(
target
maybeDecl
)
)
return
false
;
}
}
return
true
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkDestructuringArray
(
ParseNode
*
arrayPattern
const
Maybe
<
DeclarationKind
>
&
maybeDecl
)
{
MOZ_ASSERT
(
arrayPattern
-
>
isKind
(
PNK_ARRAY
)
)
;
for
(
ParseNode
*
element
=
arrayPattern
-
>
pn_head
;
element
;
element
=
element
-
>
pn_next
)
{
if
(
element
-
>
isKind
(
PNK_ELISION
)
)
continue
;
ParseNode
*
target
;
if
(
element
-
>
isKind
(
PNK_SPREAD
)
)
{
if
(
element
-
>
pn_next
)
{
errorAt
(
element
-
>
pn_next
-
>
pn_pos
.
begin
JSMSG_PARAMETER_AFTER_REST
)
;
return
false
;
}
target
=
element
-
>
pn_kid
;
}
else
if
(
handler
.
isUnparenthesizedAssignment
(
element
)
)
{
target
=
element
-
>
pn_left
;
}
else
{
target
=
element
;
}
if
(
handler
.
isUnparenthesizedDestructuringPattern
(
target
)
)
{
if
(
!
checkDestructuringPattern
(
target
maybeDecl
)
)
return
false
;
}
else
{
if
(
!
checkDestructuringName
(
target
maybeDecl
)
)
return
false
;
}
}
return
true
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkDestructuringPattern
(
ParseNode
*
pattern
const
Maybe
<
DeclarationKind
>
&
maybeDecl
PossibleError
*
possibleError
)
{
if
(
pattern
-
>
isKind
(
PNK_ARRAYCOMP
)
)
{
errorAt
(
pattern
-
>
pn_pos
.
begin
JSMSG_ARRAY_COMP_LEFTSIDE
)
;
return
false
;
}
bool
isDestructuring
=
pattern
-
>
isKind
(
PNK_ARRAY
)
?
checkDestructuringArray
(
pattern
maybeDecl
)
:
checkDestructuringObject
(
pattern
maybeDecl
)
;
if
(
isDestructuring
&
&
possibleError
&
&
!
possibleError
-
>
checkForDestructuringError
(
)
)
return
false
;
return
isDestructuring
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
checkDestructuringPattern
(
Node
pattern
const
Maybe
<
DeclarationKind
>
&
maybeDecl
PossibleError
*
possibleError
)
{
return
abortIfSyntaxParser
(
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
destructuringDeclaration
(
DeclarationKind
kind
YieldHandling
yieldHandling
TokenKind
tt
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
tt
)
)
;
MOZ_ASSERT
(
tt
=
=
TOK_LB
|
|
tt
=
=
TOK_LC
)
;
PossibleError
possibleError
(
*
this
)
;
Node
pattern
;
{
pc
-
>
inDestructuringDecl
=
Some
(
kind
)
;
pattern
=
primaryExpr
(
yieldHandling
TripledotProhibited
tt
&
possibleError
)
;
pc
-
>
inDestructuringDecl
=
Nothing
(
)
;
}
if
(
!
pattern
|
|
!
checkDestructuringPattern
(
pattern
Some
(
kind
)
&
possibleError
)
)
return
null
(
)
;
return
pattern
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
destructuringDeclarationWithoutYieldOrAwait
(
DeclarationKind
kind
YieldHandling
yieldHandling
TokenKind
tt
)
{
uint32_t
startYieldOffset
=
pc
-
>
lastYieldOffset
;
uint32_t
startAwaitOffset
=
pc
-
>
lastAwaitOffset
;
Node
res
=
destructuringDeclaration
(
kind
yieldHandling
tt
)
;
if
(
res
)
{
if
(
pc
-
>
lastYieldOffset
!
=
startYieldOffset
)
{
errorAt
(
pc
-
>
lastYieldOffset
JSMSG_YIELD_IN_DEFAULT
)
;
return
null
(
)
;
}
if
(
pc
-
>
lastAwaitOffset
!
=
startAwaitOffset
)
{
errorAt
(
pc
-
>
lastAwaitOffset
JSMSG_AWAIT_IN_DEFAULT
)
;
return
null
(
)
;
}
}
return
res
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
blockStatement
(
YieldHandling
yieldHandling
unsigned
errorNumber
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LC
)
)
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Block
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
Node
list
=
statementList
(
yieldHandling
)
;
if
(
!
list
)
return
null
(
)
;
MUST_MATCH_TOKEN_MOD
(
TOK_RC
TokenStream
:
:
Operand
errorNumber
)
;
return
finishLexicalScope
(
scope
list
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
expressionAfterForInOrOf
(
ParseNodeKind
forHeadKind
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
forHeadKind
=
=
PNK_FORIN
|
|
forHeadKind
=
=
PNK_FOROF
)
;
Node
pn
=
forHeadKind
=
=
PNK_FOROF
?
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
)
:
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
return
pn
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
declarationPattern
(
Node
decl
DeclarationKind
declKind
TokenKind
tt
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LB
)
|
|
tokenStream
.
isCurrentTokenType
(
TOK_LC
)
)
;
Node
pattern
=
destructuringDeclaration
(
declKind
yieldHandling
tt
)
;
if
(
!
pattern
)
return
null
(
)
;
if
(
initialDeclaration
&
&
forHeadKind
)
{
bool
isForIn
isForOf
;
if
(
!
matchInOrOf
(
&
isForIn
&
isForOf
)
)
return
null
(
)
;
if
(
isForIn
)
{
*
forHeadKind
=
PNK_FORIN
;
}
else
if
(
isForOf
)
{
*
forHeadKind
=
PNK_FOROF
;
if
(
declKind
=
=
DeclarationKind
:
:
Var
)
declKind
=
DeclarationKind
:
:
ForOfVar
;
}
else
{
*
forHeadKind
=
PNK_FORHEAD
;
}
if
(
*
forHeadKind
!
=
PNK_FORHEAD
)
{
*
forInOrOfExpression
=
expressionAfterForInOrOf
(
*
forHeadKind
yieldHandling
)
;
if
(
!
*
forInOrOfExpression
)
return
null
(
)
;
return
pattern
;
}
}
MUST_MATCH_TOKEN
(
TOK_ASSIGN
JSMSG_BAD_DESTRUCT_DECL
)
;
Node
init
=
assignExpr
(
forHeadKind
?
InProhibited
:
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
init
)
return
null
(
)
;
handler
.
checkAndSetIsDirectRHSAnonFunction
(
init
)
;
if
(
forHeadKind
)
{
tokenStream
.
addModifierException
(
TokenStream
:
:
OperandIsNone
)
;
}
return
handler
.
newBinary
(
PNK_ASSIGN
pattern
init
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
initializerInNameDeclaration
(
Node
decl
Node
binding
Handle
<
PropertyName
*
>
name
DeclarationKind
declKind
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_ASSIGN
)
)
;
uint32_t
initializerOffset
;
if
(
!
tokenStream
.
peekOffset
(
&
initializerOffset
TokenStream
:
:
Operand
)
)
return
false
;
Node
initializer
=
assignExpr
(
forHeadKind
?
InProhibited
:
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
initializer
)
return
false
;
handler
.
checkAndSetIsDirectRHSAnonFunction
(
initializer
)
;
if
(
forHeadKind
)
{
if
(
initialDeclaration
)
{
bool
isForIn
isForOf
;
if
(
!
matchInOrOf
(
&
isForIn
&
isForOf
)
)
return
false
;
if
(
isForOf
)
{
errorAt
(
initializerOffset
JSMSG_OF_AFTER_FOR_LOOP_DECL
)
;
return
false
;
}
if
(
isForIn
)
{
if
(
DeclarationKindIsLexical
(
declKind
)
)
{
errorAt
(
initializerOffset
JSMSG_IN_AFTER_LEXICAL_FOR_DECL
)
;
return
false
;
}
*
forHeadKind
=
PNK_FORIN
;
if
(
!
strictModeErrorAt
(
initializerOffset
JSMSG_INVALID_FOR_IN_DECL_WITH_INIT
)
)
return
false
;
*
forInOrOfExpression
=
expressionAfterForInOrOf
(
PNK_FORIN
yieldHandling
)
;
if
(
!
*
forInOrOfExpression
)
return
false
;
}
else
{
*
forHeadKind
=
PNK_FORHEAD
;
}
}
else
{
MOZ_ASSERT
(
*
forHeadKind
=
=
PNK_FORHEAD
)
;
TokenKind
ignored
;
if
(
!
tokenStream
.
peekToken
(
&
ignored
)
)
return
false
;
}
if
(
*
forHeadKind
=
=
PNK_FORHEAD
)
{
tokenStream
.
addModifierException
(
TokenStream
:
:
OperandIsNone
)
;
}
}
return
handler
.
finishInitializerAssignment
(
binding
initializer
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
declarationName
(
Node
decl
DeclarationKind
declKind
TokenKind
tt
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
{
if
(
tt
!
=
TOK_NAME
&
&
tt
!
=
TOK_YIELD
)
{
error
(
JSMSG_NO_VARIABLE_NAME
)
;
return
null
(
)
;
}
RootedPropertyName
name
(
context
bindingIdentifier
(
yieldHandling
)
)
;
if
(
!
name
)
return
null
(
)
;
Node
binding
=
newName
(
name
)
;
if
(
!
binding
)
return
null
(
)
;
TokenPos
namePos
=
pos
(
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_ASSIGN
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
matched
)
{
if
(
!
initializerInNameDeclaration
(
decl
binding
name
declKind
initialDeclaration
yieldHandling
forHeadKind
forInOrOfExpression
)
)
{
return
null
(
)
;
}
}
else
{
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
if
(
initialDeclaration
&
&
forHeadKind
)
{
bool
isForIn
isForOf
;
if
(
!
matchInOrOf
(
&
isForIn
&
isForOf
)
)
return
null
(
)
;
if
(
isForIn
)
{
*
forHeadKind
=
PNK_FORIN
;
}
else
if
(
isForOf
)
{
*
forHeadKind
=
PNK_FOROF
;
if
(
declKind
=
=
DeclarationKind
:
:
Var
)
declKind
=
DeclarationKind
:
:
ForOfVar
;
}
else
{
*
forHeadKind
=
PNK_FORHEAD
;
}
}
if
(
forHeadKind
&
&
*
forHeadKind
!
=
PNK_FORHEAD
)
{
*
forInOrOfExpression
=
expressionAfterForInOrOf
(
*
forHeadKind
yieldHandling
)
;
if
(
!
*
forInOrOfExpression
)
return
null
(
)
;
}
else
{
if
(
declKind
=
=
DeclarationKind
:
:
Const
)
{
errorAt
(
namePos
.
begin
JSMSG_BAD_CONST_DECL
)
;
return
null
(
)
;
}
}
}
if
(
!
noteDeclaredName
(
name
declKind
namePos
)
)
return
null
(
)
;
return
binding
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
declarationList
(
YieldHandling
yieldHandling
ParseNodeKind
kind
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
{
MOZ_ASSERT
(
kind
=
=
PNK_VAR
|
|
kind
=
=
PNK_LET
|
|
kind
=
=
PNK_CONST
)
;
JSOp
op
;
DeclarationKind
declKind
;
switch
(
kind
)
{
case
PNK_VAR
:
op
=
JSOP_DEFVAR
;
declKind
=
DeclarationKind
:
:
Var
;
break
;
case
PNK_CONST
:
op
=
JSOP_DEFCONST
;
declKind
=
DeclarationKind
:
:
Const
;
break
;
case
PNK_LET
:
op
=
JSOP_DEFLET
;
declKind
=
DeclarationKind
:
:
Let
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
declaration
kind
"
)
;
}
Node
decl
=
handler
.
newDeclarationList
(
kind
op
)
;
if
(
!
decl
)
return
null
(
)
;
bool
matched
;
bool
initialDeclaration
=
true
;
do
{
MOZ_ASSERT_IF
(
!
initialDeclaration
&
&
forHeadKind
*
forHeadKind
=
=
PNK_FORHEAD
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
Node
binding
=
(
tt
=
=
TOK_LB
|
|
tt
=
=
TOK_LC
)
?
declarationPattern
(
decl
declKind
tt
initialDeclaration
yieldHandling
forHeadKind
forInOrOfExpression
)
:
declarationName
(
decl
declKind
tt
initialDeclaration
yieldHandling
forHeadKind
forInOrOfExpression
)
;
if
(
!
binding
)
return
null
(
)
;
handler
.
addList
(
decl
binding
)
;
if
(
forHeadKind
&
&
*
forHeadKind
!
=
PNK_FORHEAD
)
break
;
initialDeclaration
=
false
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
null
(
)
;
}
while
(
matched
)
;
return
decl
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
lexicalDeclaration
(
YieldHandling
yieldHandling
bool
isConst
)
{
Node
decl
=
declarationList
(
yieldHandling
isConst
?
PNK_CONST
:
PNK_LET
)
;
if
(
!
decl
|
|
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
return
decl
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
namedImportsOrNamespaceImport
(
TokenKind
tt
Node
importSpecSet
)
{
if
(
tt
=
=
TOK_LC
)
{
while
(
true
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
false
;
if
(
tt
=
=
TOK_RC
)
break
;
if
(
tt
!
=
TOK_NAME
)
{
error
(
JSMSG_NO_IMPORT_NAME
)
;
return
false
;
}
Rooted
<
PropertyName
*
>
importName
(
context
tokenStream
.
currentName
(
)
)
;
TokenPos
importNamePos
=
pos
(
)
;
TokenKind
maybeAs
;
if
(
!
tokenStream
.
peekToken
(
&
maybeAs
)
)
return
null
(
)
;
if
(
maybeAs
=
=
TOK_NAME
&
&
tokenStream
.
nextName
(
)
=
=
context
-
>
names
(
)
.
as
)
{
tokenStream
.
consumeKnownToken
(
TOK_NAME
)
;
if
(
!
checkUnescapedName
(
)
)
return
false
;
TokenKind
afterAs
;
if
(
!
tokenStream
.
getToken
(
&
afterAs
)
)
return
false
;
if
(
afterAs
!
=
TOK_NAME
&
&
afterAs
!
=
TOK_YIELD
)
{
error
(
JSMSG_NO_BINDING_NAME
)
;
return
false
;
}
}
else
{
if
(
IsKeyword
(
importName
)
)
{
JSAutoByteString
bytes
;
if
(
!
AtomToPrintableString
(
context
importName
&
bytes
)
)
return
false
;
error
(
JSMSG_AS_AFTER_RESERVED_WORD
bytes
.
ptr
(
)
)
;
return
false
;
}
}
RootedPropertyName
bindingAtom
(
context
importedBinding
(
)
)
;
if
(
!
bindingAtom
)
return
false
;
Node
bindingName
=
newName
(
bindingAtom
)
;
if
(
!
bindingName
)
return
false
;
if
(
!
noteDeclaredName
(
bindingAtom
DeclarationKind
:
:
Import
pos
(
)
)
)
return
false
;
Node
importNameNode
=
newName
(
importName
importNamePos
)
;
if
(
!
importNameNode
)
return
false
;
Node
importSpec
=
handler
.
newBinary
(
PNK_IMPORT_SPEC
importNameNode
bindingName
)
;
if
(
!
importSpec
)
return
false
;
handler
.
addList
(
importSpecSet
importSpec
)
;
TokenKind
next
;
if
(
!
tokenStream
.
getToken
(
&
next
)
)
return
false
;
if
(
next
=
=
TOK_RC
)
break
;
if
(
next
!
=
TOK_COMMA
)
{
error
(
JSMSG_RC_AFTER_IMPORT_SPEC_LIST
)
;
return
false
;
}
}
}
else
{
MOZ_ASSERT
(
tt
=
=
TOK_MUL
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
!
=
TOK_NAME
|
|
tokenStream
.
currentName
(
)
!
=
context
-
>
names
(
)
.
as
)
{
error
(
JSMSG_AS_AFTER_IMPORT_STAR
)
;
return
false
;
}
if
(
!
checkUnescapedName
(
)
)
return
false
;
MUST_MATCH_TOKEN
(
TOK_NAME
JSMSG_NO_BINDING_NAME
)
;
Node
importName
=
newName
(
context
-
>
names
(
)
.
star
)
;
if
(
!
importName
)
return
false
;
RootedPropertyName
bindingName
(
context
importedBinding
(
)
)
;
if
(
!
bindingName
)
return
false
;
Node
bindingNameNode
=
newName
(
bindingName
)
;
if
(
!
bindingNameNode
)
return
false
;
if
(
!
noteDeclaredName
(
bindingName
DeclarationKind
:
:
Const
pos
(
)
)
)
return
false
;
pc
-
>
varScope
(
)
.
lookupDeclaredName
(
bindingName
)
-
>
value
(
)
-
>
setClosedOver
(
)
;
Node
importSpec
=
handler
.
newBinary
(
PNK_IMPORT_SPEC
importName
bindingNameNode
)
;
if
(
!
importSpec
)
return
false
;
handler
.
addList
(
importSpecSet
importSpec
)
;
}
return
true
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
namedImportsOrNamespaceImport
(
TokenKind
tt
Node
importSpecSet
)
{
MOZ_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
false
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
importDeclaration
(
)
{
MOZ_ASSERT
(
tokenStream
.
currentToken
(
)
.
type
=
=
TOK_IMPORT
)
;
if
(
!
pc
-
>
atModuleLevel
(
)
)
{
error
(
JSMSG_IMPORT_DECL_AT_TOP_LEVEL
)
;
return
null
(
)
;
}
uint32_t
begin
=
pos
(
)
.
begin
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
Node
importSpecSet
=
handler
.
newList
(
PNK_IMPORT_SPEC_LIST
)
;
if
(
!
importSpecSet
)
return
null
(
)
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_LC
|
|
tt
=
=
TOK_MUL
)
{
if
(
tt
=
=
TOK_NAME
)
{
Node
importName
=
newName
(
context
-
>
names
(
)
.
default_
)
;
if
(
!
importName
)
return
null
(
)
;
RootedPropertyName
bindingAtom
(
context
importedBinding
(
)
)
;
if
(
!
bindingAtom
)
return
null
(
)
;
Node
bindingName
=
newName
(
bindingAtom
)
;
if
(
!
bindingName
)
return
null
(
)
;
if
(
!
noteDeclaredName
(
bindingAtom
DeclarationKind
:
:
Import
pos
(
)
)
)
return
null
(
)
;
Node
importSpec
=
handler
.
newBinary
(
PNK_IMPORT_SPEC
importName
bindingName
)
;
if
(
!
importSpec
)
return
null
(
)
;
handler
.
addList
(
importSpecSet
importSpec
)
;
if
(
!
tokenStream
.
peekToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_COMMA
)
{
tokenStream
.
consumeKnownToken
(
tt
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_LC
&
&
tt
!
=
TOK_MUL
)
{
error
(
JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT
)
;
return
null
(
)
;
}
if
(
!
namedImportsOrNamespaceImport
(
tt
importSpecSet
)
)
return
null
(
)
;
}
}
else
{
if
(
!
namedImportsOrNamespaceImport
(
tt
importSpecSet
)
)
return
null
(
)
;
}
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_NAME
|
|
tokenStream
.
currentName
(
)
!
=
context
-
>
names
(
)
.
from
)
{
error
(
JSMSG_FROM_AFTER_IMPORT_CLAUSE
)
;
return
null
(
)
;
}
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_STRING
JSMSG_MODULE_SPEC_AFTER_FROM
)
;
}
else
if
(
tt
=
=
TOK_STRING
)
{
importSpecSet
-
>
pn_pos
.
end
=
importSpecSet
-
>
pn_pos
.
begin
;
}
else
{
error
(
JSMSG_DECLARATION_AFTER_IMPORT
)
;
return
null
(
)
;
}
Node
moduleSpec
=
stringLiteral
(
)
;
if
(
!
moduleSpec
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
ParseNode
*
node
=
handler
.
newImportDeclaration
(
importSpecSet
moduleSpec
TokenPos
(
begin
pos
(
)
.
end
)
)
;
if
(
!
node
|
|
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
processImport
(
node
)
)
return
null
(
)
;
return
node
;
}
template
<
>
SyntaxParseHandler
:
:
Node
Parser
<
SyntaxParseHandler
>
:
:
importDeclaration
(
)
{
JS_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
SyntaxParseHandler
:
:
NodeFailure
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkExportedName
(
JSAtom
*
exportName
)
{
if
(
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
hasExportedName
(
exportName
)
)
return
true
;
JSAutoByteString
str
;
if
(
!
AtomToPrintableString
(
context
exportName
&
str
)
)
return
false
;
error
(
JSMSG_DUPLICATE_EXPORT_NAME
str
.
ptr
(
)
)
;
return
false
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
checkExportedName
(
JSAtom
*
exportName
)
{
MOZ_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
false
;
}
template
<
>
bool
Parser
<
FullParseHandler
>
:
:
checkExportedNamesForDeclaration
(
ParseNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
binding
=
node
-
>
pn_head
;
binding
;
binding
=
binding
-
>
pn_next
)
{
if
(
binding
-
>
isKind
(
PNK_ASSIGN
)
)
binding
=
binding
-
>
pn_left
;
MOZ_ASSERT
(
binding
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
checkExportedName
(
binding
-
>
pn_atom
)
)
return
false
;
}
return
true
;
}
template
<
>
bool
Parser
<
SyntaxParseHandler
>
:
:
checkExportedNamesForDeclaration
(
Node
node
)
{
MOZ_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
false
;
}
template
<
>
ParseNode
*
Parser
<
FullParseHandler
>
:
:
exportDeclaration
(
)
{
MOZ_ASSERT
(
tokenStream
.
currentToken
(
)
.
type
=
=
TOK_EXPORT
)
;
if
(
!
pc
-
>
atModuleLevel
(
)
)
{
error
(
JSMSG_EXPORT_DECL_AT_TOP_LEVEL
)
;
return
null
(
)
;
}
uint32_t
begin
=
pos
(
)
.
begin
;
Node
kid
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_LC
:
{
kid
=
handler
.
newList
(
PNK_EXPORT_SPEC_LIST
)
;
if
(
!
kid
)
return
null
(
)
;
while
(
true
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
break
;
if
(
tt
!
=
TOK_NAME
)
{
error
(
JSMSG_NO_BINDING_NAME
)
;
return
null
(
)
;
}
Node
bindingName
=
newName
(
tokenStream
.
currentName
(
)
)
;
if
(
!
bindingName
)
return
null
(
)
;
bool
foundAs
;
if
(
!
tokenStream
.
matchContextualKeyword
(
&
foundAs
context
-
>
names
(
)
.
as
)
)
return
null
(
)
;
if
(
foundAs
)
MUST_MATCH_TOKEN_MOD
(
TOK_NAME
TokenStream
:
:
KeywordIsName
JSMSG_NO_EXPORT_NAME
)
;
Node
exportName
=
newName
(
tokenStream
.
currentName
(
)
)
;
if
(
!
exportName
)
return
null
(
)
;
if
(
!
checkExportedName
(
exportName
-
>
pn_atom
)
)
return
null
(
)
;
Node
exportSpec
=
handler
.
newBinary
(
PNK_EXPORT_SPEC
bindingName
exportName
)
;
if
(
!
exportSpec
)
return
null
(
)
;
handler
.
addList
(
kid
exportSpec
)
;
TokenKind
next
;
if
(
!
tokenStream
.
getToken
(
&
next
)
)
return
null
(
)
;
if
(
next
=
=
TOK_RC
)
break
;
if
(
next
!
=
TOK_COMMA
)
{
error
(
JSMSG_RC_AFTER_EXPORT_SPEC_LIST
)
;
return
null
(
)
;
}
}
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_NAME
&
&
tokenStream
.
currentToken
(
)
.
name
(
)
=
=
context
-
>
names
(
)
.
from
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
MUST_MATCH_TOKEN
(
TOK_STRING
JSMSG_MODULE_SPEC_AFTER_FROM
)
;
Node
moduleSpec
=
stringLiteral
(
)
;
if
(
!
moduleSpec
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
ParseNode
*
node
=
handler
.
newExportFromDeclaration
(
begin
kid
moduleSpec
)
;
if
(
!
node
|
|
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
processExportFrom
(
node
)
)
return
null
(
)
;
return
node
;
}
tokenStream
.
ungetToken
(
)
;
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
break
;
}
case
TOK_MUL
:
{
kid
=
handler
.
newList
(
PNK_EXPORT_SPEC_LIST
)
;
if
(
!
kid
)
return
null
(
)
;
Node
exportSpec
=
handler
.
newNullary
(
PNK_EXPORT_BATCH_SPEC
JSOP_NOP
pos
(
)
)
;
if
(
!
exportSpec
)
return
null
(
)
;
handler
.
addList
(
kid
exportSpec
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_NAME
|
|
tokenStream
.
currentName
(
)
!
=
context
-
>
names
(
)
.
from
)
{
error
(
JSMSG_FROM_AFTER_EXPORT_STAR
)
;
return
null
(
)
;
}
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_STRING
JSMSG_MODULE_SPEC_AFTER_FROM
)
;
Node
moduleSpec
=
stringLiteral
(
)
;
if
(
!
moduleSpec
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
ParseNode
*
node
=
handler
.
newExportFromDeclaration
(
begin
kid
moduleSpec
)
;
if
(
!
node
|
|
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
processExportFrom
(
node
)
)
return
null
(
)
;
return
node
;
}
case
TOK_FUNCTION
:
kid
=
functionStmt
(
YieldIsKeyword
NameRequired
)
;
if
(
!
kid
)
return
null
(
)
;
if
(
!
checkExportedName
(
kid
-
>
pn_funbox
-
>
function
(
)
-
>
explicitName
(
)
)
)
return
null
(
)
;
break
;
case
TOK_CLASS
:
{
kid
=
classDefinition
(
YieldIsKeyword
ClassStatement
NameRequired
)
;
if
(
!
kid
)
return
null
(
)
;
const
ClassNode
&
cls
=
kid
-
>
as
<
ClassNode
>
(
)
;
MOZ_ASSERT
(
cls
.
names
(
)
)
;
if
(
!
checkExportedName
(
cls
.
names
(
)
-
>
innerBinding
(
)
-
>
pn_atom
)
)
return
null
(
)
;
break
;
}
case
TOK_VAR
:
kid
=
declarationList
(
YieldIsName
PNK_VAR
)
;
if
(
!
kid
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
if
(
!
checkExportedNamesForDeclaration
(
kid
)
)
return
null
(
)
;
break
;
case
TOK_DEFAULT
:
{
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
!
checkExportedName
(
context
-
>
names
(
)
.
default_
)
)
return
null
(
)
;
ParseNode
*
nameNode
=
nullptr
;
switch
(
tt
)
{
case
TOK_FUNCTION
:
kid
=
functionStmt
(
YieldIsKeyword
AllowDefaultName
)
;
if
(
!
kid
)
return
null
(
)
;
break
;
case
TOK_CLASS
:
kid
=
classDefinition
(
YieldIsKeyword
ClassStatement
AllowDefaultName
)
;
if
(
!
kid
)
return
null
(
)
;
break
;
default
:
{
if
(
tt
=
=
TOK_NAME
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
TokenKind
nextSameLine
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
if
(
nextSameLine
=
=
TOK_FUNCTION
)
{
tokenStream
.
consumeKnownToken
(
nextSameLine
)
;
kid
=
functionStmt
(
YieldIsName
AllowDefaultName
AsyncFunction
)
;
if
(
!
kid
)
return
null
(
)
;
break
;
}
}
tokenStream
.
ungetToken
(
)
;
RootedPropertyName
name
(
context
context
-
>
names
(
)
.
starDefaultStar
)
;
nameNode
=
newName
(
name
)
;
if
(
!
nameNode
)
return
null
(
)
;
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
Const
pos
(
)
)
)
return
null
(
)
;
kid
=
assignExpr
(
InAllowed
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
kid
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
break
;
}
}
ParseNode
*
node
=
handler
.
newExportDefaultDeclaration
(
kid
nameNode
TokenPos
(
begin
pos
(
)
.
end
)
)
;
if
(
!
node
|
|
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
processExport
(
node
)
)
return
null
(
)
;
return
node
;
}
case
TOK_CONST
:
kid
=
lexicalDeclaration
(
YieldIsName
true
)
;
if
(
!
kid
)
return
null
(
)
;
if
(
!
checkExportedNamesForDeclaration
(
kid
)
)
return
null
(
)
;
break
;
case
TOK_NAME
:
if
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
let
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
kid
=
lexicalDeclaration
(
YieldIsName
false
)
;
if
(
!
kid
)
return
null
(
)
;
if
(
!
checkExportedNamesForDeclaration
(
kid
)
)
return
null
(
)
;
break
;
}
MOZ_FALLTHROUGH
;
default
:
error
(
JSMSG_DECLARATION_AFTER_EXPORT
)
;
return
null
(
)
;
}
ParseNode
*
node
=
handler
.
newExportDeclaration
(
kid
TokenPos
(
begin
pos
(
)
.
end
)
)
;
if
(
!
node
|
|
!
pc
-
>
sc
(
)
-
>
asModuleContext
(
)
-
>
builder
.
processExport
(
node
)
)
return
null
(
)
;
return
node
;
}
template
<
>
SyntaxParseHandler
:
:
Node
Parser
<
SyntaxParseHandler
>
:
:
exportDeclaration
(
)
{
JS_ALWAYS_FALSE
(
abortIfSyntaxParser
(
)
)
;
return
SyntaxParseHandler
:
:
NodeFailure
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
expressionStatement
(
YieldHandling
yieldHandling
InvokedPrediction
invoked
)
{
tokenStream
.
ungetToken
(
)
;
Node
pnexpr
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
nullptr
invoked
)
;
if
(
!
pnexpr
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
return
handler
.
newExprStatement
(
pnexpr
pos
(
)
.
end
)
;
}
template
<
class
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
consequentOrAlternative
(
YieldHandling
yieldHandling
)
{
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
next
=
=
TOK_NAME
&
&
!
tokenStream
.
nextNameContainsEscape
(
)
&
&
tokenStream
.
nextName
(
)
=
=
context
-
>
names
(
)
.
async
)
{
tokenStream
.
consumeKnownToken
(
next
TokenStream
:
:
Operand
)
;
TokenKind
maybeFunction
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
maybeFunction
)
)
return
null
(
)
;
if
(
maybeFunction
=
=
TOK_FUNCTION
)
{
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
async
function
declarations
"
)
;
return
null
(
)
;
}
tokenStream
.
ungetToken
(
)
;
}
else
if
(
next
=
=
TOK_FUNCTION
)
{
tokenStream
.
consumeKnownToken
(
next
TokenStream
:
:
Operand
)
;
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
function
declarations
"
)
;
return
null
(
)
;
}
TokenKind
maybeStar
;
if
(
!
tokenStream
.
peekToken
(
&
maybeStar
)
)
return
null
(
)
;
if
(
maybeStar
=
=
TOK_MUL
)
{
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
generator
declarations
"
)
;
return
null
(
)
;
}
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Block
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
TokenPos
funcPos
=
pos
(
)
;
Node
fun
=
functionStmt
(
yieldHandling
NameRequired
)
;
if
(
!
fun
)
return
null
(
)
;
Node
block
=
handler
.
newStatementList
(
funcPos
)
;
if
(
!
block
)
return
null
(
)
;
handler
.
addStatementToList
(
block
fun
)
;
return
finishLexicalScope
(
scope
block
)
;
}
return
statement
(
yieldHandling
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
ifStatement
(
YieldHandling
yieldHandling
)
{
Vector
<
Node
4
>
condList
(
context
)
thenList
(
context
)
;
Vector
<
uint32_t
4
>
posList
(
context
)
;
Node
elseBranch
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
If
)
;
while
(
true
)
{
uint32_t
begin
=
pos
(
)
.
begin
;
Node
cond
=
condition
(
InAllowed
yieldHandling
)
;
if
(
!
cond
)
return
null
(
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_SEMI
)
{
if
(
!
extraWarning
(
JSMSG_EMPTY_CONSEQUENT
)
)
return
null
(
)
;
}
Node
thenBranch
=
consequentOrAlternative
(
yieldHandling
)
;
if
(
!
thenBranch
)
return
null
(
)
;
if
(
!
condList
.
append
(
cond
)
|
|
!
thenList
.
append
(
thenBranch
)
|
|
!
posList
.
append
(
begin
)
)
return
null
(
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_ELSE
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
matched
)
{
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_IF
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
matched
)
continue
;
elseBranch
=
consequentOrAlternative
(
yieldHandling
)
;
if
(
!
elseBranch
)
return
null
(
)
;
}
else
{
elseBranch
=
null
(
)
;
}
break
;
}
for
(
int
i
=
condList
.
length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
elseBranch
=
handler
.
newIfStatement
(
posList
[
i
]
condList
[
i
]
thenList
[
i
]
elseBranch
)
;
if
(
!
elseBranch
)
return
null
(
)
;
}
return
elseBranch
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
doWhileStatement
(
YieldHandling
yieldHandling
)
{
uint32_t
begin
=
pos
(
)
.
begin
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
DoLoop
)
;
Node
body
=
statement
(
yieldHandling
)
;
if
(
!
body
)
return
null
(
)
;
MUST_MATCH_TOKEN_MOD
(
TOK_WHILE
TokenStream
:
:
Operand
JSMSG_WHILE_AFTER_DO
)
;
Node
cond
=
condition
(
InAllowed
yieldHandling
)
;
if
(
!
cond
)
return
null
(
)
;
bool
ignored
;
if
(
!
tokenStream
.
matchToken
(
&
ignored
TOK_SEMI
TokenStream
:
:
Operand
)
)
return
null
(
)
;
return
handler
.
newDoWhileStatement
(
body
cond
TokenPos
(
begin
pos
(
)
.
end
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
whileStatement
(
YieldHandling
yieldHandling
)
{
uint32_t
begin
=
pos
(
)
.
begin
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
WhileLoop
)
;
Node
cond
=
condition
(
InAllowed
yieldHandling
)
;
if
(
!
cond
)
return
null
(
)
;
Node
body
=
statement
(
yieldHandling
)
;
if
(
!
body
)
return
null
(
)
;
return
handler
.
newWhileStatement
(
begin
cond
body
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
matchInOrOf
(
bool
*
isForInp
bool
*
isForOfp
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
false
;
*
isForInp
=
tt
=
=
TOK_IN
;
*
isForOfp
=
tt
=
=
TOK_NAME
&
&
tokenStream
.
currentToken
(
)
.
name
(
)
=
=
context
-
>
names
(
)
.
of
;
if
(
!
*
isForInp
&
&
!
*
isForOfp
)
{
tokenStream
.
ungetToken
(
)
;
}
else
{
if
(
tt
=
=
TOK_NAME
&
&
!
checkUnescapedName
(
)
)
return
false
;
}
MOZ_ASSERT_IF
(
*
isForInp
|
|
*
isForOfp
*
isForInp
!
=
*
isForOfp
)
;
return
true
;
}
template
<
class
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
forHeadStart
(
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInitialPart
Maybe
<
ParseContext
:
:
Scope
>
&
forLoopLexicalScope
Node
*
forInOrOfExpression
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LP
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_SEMI
)
{
*
forInitialPart
=
null
(
)
;
*
forHeadKind
=
PNK_FORHEAD
;
return
true
;
}
if
(
tt
=
=
TOK_VAR
)
{
tokenStream
.
consumeKnownToken
(
tt
TokenStream
:
:
Operand
)
;
*
forInitialPart
=
declarationList
(
yieldHandling
PNK_VAR
forHeadKind
forInOrOfExpression
)
;
return
*
forInitialPart
!
=
null
(
)
;
}
bool
parsingLexicalDeclaration
=
false
;
bool
letIsIdentifier
=
false
;
if
(
tt
=
=
TOK_CONST
)
{
parsingLexicalDeclaration
=
true
;
tokenStream
.
consumeKnownToken
(
tt
TokenStream
:
:
Operand
)
;
}
else
if
(
tt
=
=
TOK_NAME
&
&
tokenStream
.
nextName
(
)
=
=
context
-
>
names
(
)
.
let
&
&
!
tokenStream
.
nextNameContainsEscape
(
)
)
{
tokenStream
.
consumeKnownToken
(
TOK_NAME
TokenStream
:
:
Operand
)
;
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
false
;
parsingLexicalDeclaration
=
nextTokenContinuesLetDeclaration
(
next
yieldHandling
)
;
if
(
!
parsingLexicalDeclaration
)
{
tokenStream
.
ungetToken
(
)
;
letIsIdentifier
=
true
;
}
}
if
(
parsingLexicalDeclaration
)
{
forLoopLexicalScope
.
emplace
(
this
)
;
if
(
!
forLoopLexicalScope
-
>
init
(
pc
)
)
return
null
(
)
;
ParseContext
:
:
Statement
forHeadStmt
(
pc
StatementKind
:
:
ForLoopLexicalHead
)
;
*
forInitialPart
=
declarationList
(
yieldHandling
tt
=
=
TOK_CONST
?
PNK_CONST
:
PNK_LET
forHeadKind
forInOrOfExpression
)
;
return
*
forInitialPart
!
=
null
(
)
;
}
uint32_t
exprOffset
;
if
(
!
tokenStream
.
peekOffset
(
&
exprOffset
TokenStream
:
:
Operand
)
)
return
false
;
PossibleError
possibleError
(
*
this
)
;
*
forInitialPart
=
expr
(
InProhibited
yieldHandling
TripledotProhibited
&
possibleError
)
;
if
(
!
*
forInitialPart
)
return
false
;
bool
isForIn
isForOf
;
if
(
!
matchInOrOf
(
&
isForIn
&
isForOf
)
)
return
false
;
if
(
!
isForIn
&
&
!
isForOf
)
{
if
(
!
possibleError
.
checkForExpressionError
(
)
)
return
false
;
*
forHeadKind
=
PNK_FORHEAD
;
tokenStream
.
addModifierException
(
TokenStream
:
:
OperandIsNone
)
;
return
true
;
}
MOZ_ASSERT
(
isForIn
!
=
isForOf
)
;
if
(
isForOf
&
&
letIsIdentifier
)
{
errorAt
(
exprOffset
JSMSG_LET_STARTING_FOROF_LHS
)
;
return
false
;
}
*
forHeadKind
=
isForIn
?
PNK_FORIN
:
PNK_FOROF
;
if
(
handler
.
isUnparenthesizedDestructuringPattern
(
*
forInitialPart
)
)
{
if
(
!
checkDestructuringPattern
(
*
forInitialPart
Nothing
(
)
&
possibleError
)
)
return
false
;
}
else
if
(
handler
.
isNameAnyParentheses
(
*
forInitialPart
)
)
{
const
char
*
chars
=
handler
.
nameIsArgumentsEvalAnyParentheses
(
*
forInitialPart
context
)
;
if
(
chars
)
{
if
(
!
strictModeErrorAt
(
exprOffset
JSMSG_BAD_STRICT_ASSIGN
chars
)
)
return
false
;
}
handler
.
adjustGetToSet
(
*
forInitialPart
)
;
}
else
if
(
handler
.
isPropertyAccess
(
*
forInitialPart
)
)
{
}
else
if
(
handler
.
isFunctionCall
(
*
forInitialPart
)
)
{
if
(
!
strictModeErrorAt
(
exprOffset
JSMSG_BAD_FOR_LEFTSIDE
)
)
return
false
;
}
else
{
errorAt
(
exprOffset
JSMSG_BAD_FOR_LEFTSIDE
)
;
return
false
;
}
if
(
!
possibleError
.
checkForExpressionError
(
)
)
return
false
;
*
forInOrOfExpression
=
expressionAfterForInOrOf
(
*
forHeadKind
yieldHandling
)
;
return
*
forInOrOfExpression
!
=
null
(
)
;
}
template
<
class
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
forStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FOR
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
ForLoop
)
;
bool
isForEach
=
false
;
unsigned
iflags
=
0
;
if
(
allowsForEachIn
(
)
)
{
bool
matched
;
if
(
!
tokenStream
.
matchContextualKeyword
(
&
matched
context
-
>
names
(
)
.
each
)
)
return
null
(
)
;
if
(
matched
)
{
iflags
=
JSITER_FOREACH
;
isForEach
=
true
;
addTelemetry
(
JSCompartment
:
:
DeprecatedForEach
)
;
if
(
!
warnOnceAboutForEach
(
)
)
return
null
(
)
;
}
}
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_AFTER_FOR
)
;
ParseNodeKind
headKind
;
Node
startNode
;
Maybe
<
ParseContext
:
:
Scope
>
forLoopLexicalScope
;
Node
iteratedExpr
;
if
(
!
forHeadStart
(
yieldHandling
&
headKind
&
startNode
forLoopLexicalScope
&
iteratedExpr
)
)
{
return
null
(
)
;
}
MOZ_ASSERT
(
headKind
=
=
PNK_FORIN
|
|
headKind
=
=
PNK_FOROF
|
|
headKind
=
=
PNK_FORHEAD
)
;
Node
forHead
;
if
(
headKind
=
=
PNK_FORHEAD
)
{
Node
init
=
startNode
;
if
(
isForEach
)
{
errorAt
(
begin
JSMSG_BAD_FOR_EACH_LOOP
)
;
return
null
(
)
;
}
MUST_MATCH_TOKEN_MOD
(
TOK_SEMI
TokenStream
:
:
Operand
JSMSG_SEMI_AFTER_FOR_INIT
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
Node
test
;
TokenStream
:
:
Modifier
mod
;
if
(
tt
=
=
TOK_SEMI
)
{
test
=
null
(
)
;
mod
=
TokenStream
:
:
Operand
;
}
else
{
test
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
test
)
return
null
(
)
;
mod
=
TokenStream
:
:
None
;
}
MUST_MATCH_TOKEN_MOD
(
TOK_SEMI
mod
JSMSG_SEMI_AFTER_FOR_COND
)
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
Node
update
;
if
(
tt
=
=
TOK_RP
)
{
update
=
null
(
)
;
mod
=
TokenStream
:
:
Operand
;
}
else
{
update
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
update
)
return
null
(
)
;
mod
=
TokenStream
:
:
None
;
}
MUST_MATCH_TOKEN_MOD
(
TOK_RP
mod
JSMSG_PAREN_AFTER_FOR_CTRL
)
;
TokenPos
headPos
(
begin
pos
(
)
.
end
)
;
forHead
=
handler
.
newForHead
(
init
test
update
headPos
)
;
if
(
!
forHead
)
return
null
(
)
;
}
else
{
MOZ_ASSERT
(
headKind
=
=
PNK_FORIN
|
|
headKind
=
=
PNK_FOROF
)
;
Node
target
=
startNode
;
if
(
headKind
=
=
PNK_FORIN
)
{
stmt
.
refineForKind
(
StatementKind
:
:
ForInLoop
)
;
iflags
|
=
JSITER_ENUMERATE
;
}
else
{
if
(
isForEach
)
{
errorAt
(
begin
JSMSG_BAD_FOR_EACH_LOOP
)
;
return
null
(
)
;
}
stmt
.
refineForKind
(
StatementKind
:
:
ForOfLoop
)
;
}
MUST_MATCH_TOKEN_MOD
(
TOK_RP
TokenStream
:
:
None
JSMSG_PAREN_AFTER_FOR_CTRL
)
;
TokenPos
headPos
(
begin
pos
(
)
.
end
)
;
forHead
=
handler
.
newForInOrOfHead
(
headKind
target
iteratedExpr
headPos
)
;
if
(
!
forHead
)
return
null
(
)
;
}
Node
body
=
statement
(
yieldHandling
)
;
if
(
!
body
)
return
null
(
)
;
Node
forLoop
=
handler
.
newForStatement
(
begin
forHead
body
iflags
)
;
if
(
!
forLoop
)
return
null
(
)
;
if
(
forLoopLexicalScope
)
return
finishLexicalScope
(
*
forLoopLexicalScope
forLoop
)
;
return
forLoop
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
switchStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_SWITCH
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_BEFORE_SWITCH
)
;
Node
discriminant
=
exprInParens
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
discriminant
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_SWITCH
)
;
MUST_MATCH_TOKEN
(
TOK_LC
JSMSG_CURLY_BEFORE_SWITCH
)
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Switch
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
Node
caseList
=
handler
.
newStatementList
(
pos
(
)
)
;
if
(
!
caseList
)
return
null
(
)
;
bool
seenDefault
=
false
;
TokenKind
tt
;
while
(
true
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
break
;
uint32_t
caseBegin
=
pos
(
)
.
begin
;
Node
caseExpr
;
switch
(
tt
)
{
case
TOK_DEFAULT
:
if
(
seenDefault
)
{
error
(
JSMSG_TOO_MANY_DEFAULTS
)
;
return
null
(
)
;
}
seenDefault
=
true
;
caseExpr
=
null
(
)
;
break
;
case
TOK_CASE
:
caseExpr
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
caseExpr
)
return
null
(
)
;
break
;
default
:
error
(
JSMSG_BAD_SWITCH
)
;
return
null
(
)
;
}
MUST_MATCH_TOKEN
(
TOK_COLON
JSMSG_COLON_AFTER_CASE
)
;
Node
body
=
handler
.
newStatementList
(
pos
(
)
)
;
if
(
!
body
)
return
null
(
)
;
bool
afterReturn
=
false
;
bool
warnedAboutStatementsAfterReturn
=
false
;
uint32_t
statementBegin
=
0
;
while
(
true
)
{
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
|
|
tt
=
=
TOK_CASE
|
|
tt
=
=
TOK_DEFAULT
)
break
;
if
(
afterReturn
)
{
if
(
!
tokenStream
.
peekOffset
(
&
statementBegin
TokenStream
:
:
Operand
)
)
return
null
(
)
;
}
Node
stmt
=
statementListItem
(
yieldHandling
)
;
if
(
!
stmt
)
return
null
(
)
;
if
(
!
warnedAboutStatementsAfterReturn
)
{
if
(
afterReturn
)
{
if
(
!
handler
.
isStatementPermittedAfterReturnStatement
(
stmt
)
)
{
if
(
!
warningAt
(
statementBegin
JSMSG_STMT_AFTER_RETURN
)
)
return
null
(
)
;
warnedAboutStatementsAfterReturn
=
true
;
}
}
else
if
(
handler
.
isReturnStatement
(
stmt
)
)
{
afterReturn
=
true
;
}
}
handler
.
addStatementToList
(
body
stmt
)
;
}
Node
casepn
=
handler
.
newCaseOrDefault
(
caseBegin
caseExpr
body
)
;
if
(
!
casepn
)
return
null
(
)
;
handler
.
addCaseStatementToList
(
caseList
casepn
)
;
}
caseList
=
finishLexicalScope
(
scope
caseList
)
;
if
(
!
caseList
)
return
null
(
)
;
handler
.
setEndPosition
(
caseList
pos
(
)
.
end
)
;
return
handler
.
newSwitchStatement
(
begin
discriminant
caseList
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
continueStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_CONTINUE
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
RootedPropertyName
label
(
context
)
;
if
(
!
matchLabel
(
yieldHandling
&
label
)
)
return
null
(
)
;
auto
isLoop
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
StatementKindIsLoop
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
label
)
{
ParseContext
:
:
Statement
*
stmt
=
pc
-
>
innermostStatement
(
)
;
bool
foundLoop
=
false
;
for
(
;
;
)
{
stmt
=
ParseContext
:
:
Statement
:
:
findNearest
(
stmt
isLoop
)
;
if
(
!
stmt
)
{
if
(
foundLoop
)
error
(
JSMSG_LABEL_NOT_FOUND
)
;
else
errorAt
(
begin
JSMSG_BAD_CONTINUE
)
;
return
null
(
)
;
}
foundLoop
=
true
;
bool
foundTarget
=
false
;
stmt
=
stmt
-
>
enclosing
(
)
;
while
(
stmt
&
&
stmt
-
>
is
<
ParseContext
:
:
LabelStatement
>
(
)
)
{
if
(
stmt
-
>
as
<
ParseContext
:
:
LabelStatement
>
(
)
.
label
(
)
=
=
label
)
{
foundTarget
=
true
;
break
;
}
stmt
=
stmt
-
>
enclosing
(
)
;
}
if
(
foundTarget
)
break
;
}
}
else
if
(
!
pc
-
>
findInnermostStatement
(
isLoop
)
)
{
error
(
JSMSG_BAD_CONTINUE
)
;
return
null
(
)
;
}
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
return
handler
.
newContinueStatement
(
label
TokenPos
(
begin
pos
(
)
.
end
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
breakStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_BREAK
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
RootedPropertyName
label
(
context
)
;
if
(
!
matchLabel
(
yieldHandling
&
label
)
)
return
null
(
)
;
if
(
label
)
{
auto
hasSameLabel
=
[
&
label
]
(
ParseContext
:
:
LabelStatement
*
stmt
)
{
return
stmt
-
>
label
(
)
=
=
label
;
}
;
if
(
!
pc
-
>
findInnermostStatement
<
ParseContext
:
:
LabelStatement
>
(
hasSameLabel
)
)
{
error
(
JSMSG_LABEL_NOT_FOUND
)
;
return
null
(
)
;
}
}
else
{
auto
isBreakTarget
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
StatementKindIsUnlabeledBreakTarget
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
!
pc
-
>
findInnermostStatement
(
isBreakTarget
)
)
{
errorAt
(
begin
JSMSG_TOUGH_BREAK
)
;
return
null
(
)
;
}
}
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
return
handler
.
newBreakStatement
(
label
TokenPos
(
begin
pos
(
)
.
end
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
returnStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_RETURN
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
MOZ_ASSERT
(
pc
-
>
isFunctionBox
(
)
)
;
pc
-
>
functionBox
(
)
-
>
usesReturn
=
true
;
Node
exprNode
;
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_EOL
:
case
TOK_EOF
:
case
TOK_SEMI
:
case
TOK_RC
:
exprNode
=
null
(
)
;
pc
-
>
funHasReturnVoid
=
true
;
break
;
default
:
{
exprNode
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
exprNode
)
return
null
(
)
;
pc
-
>
funHasReturnExpr
=
true
;
}
}
if
(
exprNode
)
{
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
}
else
{
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
}
Node
pn
=
handler
.
newReturnStatement
(
exprNode
TokenPos
(
begin
pos
(
)
.
end
)
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
pc
-
>
isLegacyGenerator
(
)
&
&
exprNode
)
{
errorAt
(
begin
JSMSG_BAD_GENERATOR_RETURN
)
;
return
null
(
)
;
}
return
pn
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newYieldExpression
(
uint32_t
begin
typename
ParseHandler
:
:
Node
expr
bool
isYieldStar
)
{
Node
generator
=
newDotGeneratorName
(
)
;
if
(
!
generator
)
return
null
(
)
;
if
(
isYieldStar
)
return
handler
.
newYieldStarExpression
(
begin
expr
generator
)
;
return
handler
.
newYieldExpression
(
begin
expr
generator
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newAwaitExpression
(
uint32_t
begin
typename
ParseHandler
:
:
Node
expr
)
{
Node
generator
=
newDotGeneratorName
(
)
;
if
(
!
generator
)
return
null
(
)
;
return
handler
.
newAwaitExpression
(
begin
expr
generator
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
yieldExpression
(
InHandling
inHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_YIELD
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
switch
(
pc
-
>
generatorKind
(
)
)
{
case
StarGenerator
:
{
MOZ_ASSERT
(
pc
-
>
isFunctionBox
(
)
)
;
pc
-
>
lastYieldOffset
=
begin
;
Node
exprNode
;
ParseNodeKind
kind
=
PNK_YIELD
;
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_EOL
:
case
TOK_EOF
:
case
TOK_SEMI
:
case
TOK_RC
:
case
TOK_RB
:
case
TOK_RP
:
case
TOK_COLON
:
case
TOK_COMMA
:
case
TOK_IN
:
exprNode
=
null
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
break
;
case
TOK_MUL
:
kind
=
PNK_YIELD_STAR
;
tokenStream
.
consumeKnownToken
(
TOK_MUL
TokenStream
:
:
Operand
)
;
MOZ_FALLTHROUGH
;
default
:
exprNode
=
assignExpr
(
inHandling
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
exprNode
)
return
null
(
)
;
}
return
newYieldExpression
(
begin
exprNode
kind
=
=
PNK_YIELD_STAR
)
;
}
case
NotGenerator
:
MOZ_ASSERT
(
tokenStream
.
versionNumber
(
)
>
=
JSVERSION_1_7
)
;
MOZ_ASSERT
(
pc
-
>
lastYieldOffset
=
=
ParseContext
:
:
NoYieldOffset
)
;
if
(
!
abortIfSyntaxParser
(
)
)
return
null
(
)
;
if
(
!
pc
-
>
isFunctionBox
(
)
)
{
error
(
JSMSG_BAD_RETURN_OR_YIELD
js_yield_str
)
;
return
null
(
)
;
}
if
(
pc
-
>
functionBox
(
)
-
>
isArrow
(
)
)
{
errorAt
(
begin
JSMSG_YIELD_IN_ARROW
js_yield_str
)
;
return
null
(
)
;
}
if
(
pc
-
>
functionBox
(
)
-
>
function
(
)
-
>
isMethod
(
)
|
|
pc
-
>
functionBox
(
)
-
>
function
(
)
-
>
isGetter
(
)
|
|
pc
-
>
functionBox
(
)
-
>
function
(
)
-
>
isSetter
(
)
)
{
errorAt
(
begin
JSMSG_YIELD_IN_METHOD
js_yield_str
)
;
return
null
(
)
;
}
if
(
pc
-
>
funHasReturnExpr
#
if
JS_HAS_EXPR_CLOSURES
|
|
pc
-
>
functionBox
(
)
-
>
isExprBody
(
)
#
endif
)
{
errorAt
(
begin
JSMSG_BAD_FUNCTION_YIELD
)
;
return
null
(
)
;
}
pc
-
>
functionBox
(
)
-
>
setGeneratorKind
(
LegacyGenerator
)
;
addTelemetry
(
JSCompartment
:
:
DeprecatedLegacyGenerator
)
;
MOZ_FALLTHROUGH
;
case
LegacyGenerator
:
{
MOZ_ASSERT
(
pc
-
>
isFunctionBox
(
)
)
;
pc
-
>
lastYieldOffset
=
begin
;
Node
exprNode
;
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_EOF
:
case
TOK_EOL
:
case
TOK_SEMI
:
case
TOK_RC
:
case
TOK_RB
:
case
TOK_RP
:
case
TOK_COLON
:
case
TOK_COMMA
:
exprNode
=
null
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
break
;
default
:
exprNode
=
assignExpr
(
inHandling
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
exprNode
)
return
null
(
)
;
}
return
newYieldExpression
(
begin
exprNode
)
;
}
}
MOZ_CRASH
(
"
yieldExpr
"
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
withStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_WITH
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
if
(
!
strictModeError
(
JSMSG_STRICT_CODE_WITH
)
)
return
null
(
)
;
}
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_BEFORE_WITH
)
;
Node
objectExpr
=
exprInParens
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
objectExpr
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_WITH
)
;
Node
innerBlock
;
{
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
With
)
;
innerBlock
=
statement
(
yieldHandling
)
;
if
(
!
innerBlock
)
return
null
(
)
;
}
pc
-
>
sc
(
)
-
>
setBindingsAccessedDynamically
(
)
;
return
handler
.
newWithStatement
(
begin
objectExpr
innerBlock
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
labeledItem
(
YieldHandling
yieldHandling
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_FUNCTION
)
{
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
null
(
)
;
if
(
next
=
=
TOK_MUL
)
{
error
(
JSMSG_GENERATOR_LABEL
)
;
return
null
(
)
;
}
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
error
(
JSMSG_FUNCTION_LABEL
)
;
return
null
(
)
;
}
return
functionStmt
(
yieldHandling
NameRequired
)
;
}
tokenStream
.
ungetToken
(
)
;
return
statement
(
yieldHandling
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
labeledStatement
(
YieldHandling
yieldHandling
)
{
RootedPropertyName
label
(
context
labelIdentifier
(
yieldHandling
)
)
;
if
(
!
label
)
return
null
(
)
;
auto
hasSameLabel
=
[
&
label
]
(
ParseContext
:
:
LabelStatement
*
stmt
)
{
return
stmt
-
>
label
(
)
=
=
label
;
}
;
uint32_t
begin
=
pos
(
)
.
begin
;
if
(
pc
-
>
findInnermostStatement
<
ParseContext
:
:
LabelStatement
>
(
hasSameLabel
)
)
{
errorAt
(
begin
JSMSG_DUPLICATE_LABEL
)
;
return
null
(
)
;
}
tokenStream
.
consumeKnownToken
(
TOK_COLON
)
;
ParseContext
:
:
LabelStatement
stmt
(
pc
label
)
;
Node
pn
=
labeledItem
(
yieldHandling
)
;
if
(
!
pn
)
return
null
(
)
;
return
handler
.
newLabeledStatement
(
label
pn
begin
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
throwStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_THROW
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
TokenKind
tt
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_EOF
|
|
tt
=
=
TOK_SEMI
|
|
tt
=
=
TOK_RC
)
{
error
(
JSMSG_MISSING_EXPR_AFTER_THROW
)
;
return
null
(
)
;
}
if
(
tt
=
=
TOK_EOL
)
{
error
(
JSMSG_LINE_BREAK_AFTER_THROW
)
;
return
null
(
)
;
}
Node
throwExpr
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
throwExpr
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
return
handler
.
newThrowStatement
(
throwExpr
TokenPos
(
begin
pos
(
)
.
end
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
tryStatement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_TRY
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
Node
innerBlock
;
{
MUST_MATCH_TOKEN
(
TOK_LC
JSMSG_CURLY_BEFORE_TRY
)
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Try
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
innerBlock
=
statementList
(
yieldHandling
)
;
if
(
!
innerBlock
)
return
null
(
)
;
innerBlock
=
finishLexicalScope
(
scope
innerBlock
)
;
if
(
!
innerBlock
)
return
null
(
)
;
MUST_MATCH_TOKEN_MOD
(
TOK_RC
TokenStream
:
:
Operand
JSMSG_CURLY_AFTER_TRY
)
;
}
bool
hasUnconditionalCatch
=
false
;
Node
catchList
=
null
(
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_CATCH
)
{
catchList
=
handler
.
newCatchList
(
)
;
if
(
!
catchList
)
return
null
(
)
;
do
{
Node
pnblock
;
if
(
hasUnconditionalCatch
)
{
error
(
JSMSG_CATCH_AFTER_GENERAL
)
;
return
null
(
)
;
}
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Catch
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_BEFORE_CATCH
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
Node
catchName
;
switch
(
tt
)
{
case
TOK_LB
:
case
TOK_LC
:
catchName
=
destructuringDeclaration
(
DeclarationKind
:
:
CatchParameter
yieldHandling
tt
)
;
if
(
!
catchName
)
return
null
(
)
;
break
;
case
TOK_NAME
:
case
TOK_YIELD
:
{
RootedPropertyName
param
(
context
bindingIdentifier
(
yieldHandling
)
)
;
if
(
!
param
)
return
null
(
)
;
catchName
=
newName
(
param
)
;
if
(
!
catchName
)
return
null
(
)
;
if
(
!
noteDeclaredName
(
param
DeclarationKind
:
:
SimpleCatchParameter
pos
(
)
)
)
return
null
(
)
;
break
;
}
default
:
error
(
JSMSG_CATCH_IDENTIFIER
)
;
return
null
(
)
;
}
Node
catchGuard
=
null
(
)
;
#
if
JS_HAS_CATCH_GUARD
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_IF
)
)
return
null
(
)
;
if
(
matched
)
{
catchGuard
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
catchGuard
)
return
null
(
)
;
}
#
endif
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_CATCH
)
;
MUST_MATCH_TOKEN
(
TOK_LC
JSMSG_CURLY_BEFORE_CATCH
)
;
Node
catchBody
=
catchBlockStatement
(
yieldHandling
scope
)
;
if
(
!
catchBody
)
return
null
(
)
;
if
(
!
catchGuard
)
hasUnconditionalCatch
=
true
;
pnblock
=
finishLexicalScope
(
scope
catchBody
)
;
if
(
!
pnblock
)
return
null
(
)
;
if
(
!
handler
.
addCatchBlock
(
catchList
pnblock
catchName
catchGuard
catchBody
)
)
return
null
(
)
;
handler
.
setEndPosition
(
catchList
pos
(
)
.
end
)
;
handler
.
setEndPosition
(
pnblock
pos
(
)
.
end
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
}
while
(
tt
=
=
TOK_CATCH
)
;
}
Node
finallyBlock
=
null
(
)
;
if
(
tt
=
=
TOK_FINALLY
)
{
MUST_MATCH_TOKEN
(
TOK_LC
JSMSG_CURLY_BEFORE_FINALLY
)
;
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Finally
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
finallyBlock
=
statementList
(
yieldHandling
)
;
if
(
!
finallyBlock
)
return
null
(
)
;
finallyBlock
=
finishLexicalScope
(
scope
finallyBlock
)
;
if
(
!
finallyBlock
)
return
null
(
)
;
MUST_MATCH_TOKEN_MOD
(
TOK_RC
TokenStream
:
:
Operand
JSMSG_CURLY_AFTER_FINALLY
)
;
}
else
{
tokenStream
.
ungetToken
(
)
;
}
if
(
!
catchList
&
&
!
finallyBlock
)
{
error
(
JSMSG_CATCH_OR_FINALLY
)
;
return
null
(
)
;
}
return
handler
.
newTryStatement
(
begin
innerBlock
catchList
finallyBlock
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
catchBlockStatement
(
YieldHandling
yieldHandling
ParseContext
:
:
Scope
&
catchParamScope
)
{
ParseContext
:
:
Statement
stmt
(
pc
StatementKind
:
:
Block
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
if
(
!
scope
.
addCatchParameters
(
pc
catchParamScope
)
)
return
null
(
)
;
Node
list
=
statementList
(
yieldHandling
)
;
if
(
!
list
)
return
null
(
)
;
MUST_MATCH_TOKEN_MOD
(
TOK_RC
TokenStream
:
:
Operand
JSMSG_CURLY_AFTER_CATCH
)
;
scope
.
removeCatchParameters
(
pc
catchParamScope
)
;
return
finishLexicalScope
(
scope
list
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
debuggerStatement
(
)
{
TokenPos
p
;
p
.
begin
=
pos
(
)
.
begin
;
if
(
!
matchOrInsertSemicolonAfterNonExpression
(
)
)
return
null
(
)
;
p
.
end
=
pos
(
)
.
end
;
pc
-
>
sc
(
)
-
>
setBindingsAccessedDynamically
(
)
;
pc
-
>
sc
(
)
-
>
setHasDebuggerStatement
(
)
;
return
handler
.
newDebuggerStatement
(
p
)
;
}
static
JSOp
JSOpFromPropertyType
(
PropertyType
propType
)
{
switch
(
propType
)
{
case
PropertyType
:
:
Getter
:
case
PropertyType
:
:
GetterNoExpressionClosure
:
return
JSOP_INITPROP_GETTER
;
case
PropertyType
:
:
Setter
:
case
PropertyType
:
:
SetterNoExpressionClosure
:
return
JSOP_INITPROP_SETTER
;
case
PropertyType
:
:
Normal
:
case
PropertyType
:
:
Method
:
case
PropertyType
:
:
GeneratorMethod
:
case
PropertyType
:
:
AsyncMethod
:
case
PropertyType
:
:
Constructor
:
case
PropertyType
:
:
DerivedConstructor
:
return
JSOP_INITPROP
;
default
:
MOZ_CRASH
(
"
unexpected
property
type
"
)
;
}
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
classDefinition
(
YieldHandling
yieldHandling
ClassContext
classContext
DefaultHandling
defaultHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_CLASS
)
)
;
bool
savedStrictness
=
setLocalStrictMode
(
true
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
RootedPropertyName
name
(
context
)
;
if
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
{
name
=
bindingIdentifier
(
yieldHandling
)
;
if
(
!
name
)
return
null
(
)
;
}
else
if
(
classContext
=
=
ClassStatement
)
{
if
(
defaultHandling
=
=
AllowDefaultName
)
{
name
=
context
-
>
names
(
)
.
starDefaultStar
;
tokenStream
.
ungetToken
(
)
;
}
else
{
error
(
JSMSG_UNNAMED_CLASS_STMT
)
;
return
null
(
)
;
}
}
else
{
tokenStream
.
ungetToken
(
)
;
}
RootedAtom
propAtom
(
context
)
;
Maybe
<
ParseContext
:
:
Statement
>
classStmt
;
Maybe
<
ParseContext
:
:
Scope
>
classScope
;
if
(
name
)
{
classStmt
.
emplace
(
pc
StatementKind
:
:
Block
)
;
classScope
.
emplace
(
this
)
;
if
(
!
classScope
-
>
init
(
pc
)
)
return
null
(
)
;
}
TokenPos
namePos
=
pos
(
)
;
Node
classHeritage
=
null
(
)
;
bool
hasHeritage
;
if
(
!
tokenStream
.
matchToken
(
&
hasHeritage
TOK_EXTENDS
)
)
return
null
(
)
;
if
(
hasHeritage
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
classHeritage
=
memberExpr
(
yieldHandling
TripledotProhibited
tt
)
;
if
(
!
classHeritage
)
return
null
(
)
;
}
MUST_MATCH_TOKEN
(
TOK_LC
JSMSG_CURLY_BEFORE_CLASS
)
;
Node
classMethods
=
handler
.
newClassMethodList
(
pos
(
)
.
begin
)
;
if
(
!
classMethods
)
return
null
(
)
;
bool
seenConstructor
=
false
;
for
(
;
;
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
break
;
if
(
tt
=
=
TOK_SEMI
)
continue
;
bool
isStatic
=
false
;
if
(
tt
=
=
TOK_NAME
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
static_
)
{
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
{
tokenStream
.
consumeKnownToken
(
tt
TokenStream
:
:
KeywordIsName
)
;
error
(
JSMSG_UNEXPECTED_TOKEN
"
property
name
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
if
(
tt
!
=
TOK_LP
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
isStatic
=
true
;
}
else
{
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsKeywordIsName
)
;
tokenStream
.
ungetToken
(
)
;
}
}
else
{
tokenStream
.
ungetToken
(
)
;
}
uint32_t
nameOffset
;
if
(
!
tokenStream
.
peekOffset
(
&
nameOffset
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
PropertyType
propType
;
Node
propName
=
propertyName
(
yieldHandling
classMethods
&
propType
&
propAtom
)
;
if
(
!
propName
)
return
null
(
)
;
if
(
propType
!
=
PropertyType
:
:
Getter
&
&
propType
!
=
PropertyType
:
:
Setter
&
&
propType
!
=
PropertyType
:
:
Method
&
&
propType
!
=
PropertyType
:
:
GeneratorMethod
&
&
propType
!
=
PropertyType
:
:
AsyncMethod
&
&
propType
!
=
PropertyType
:
:
Constructor
&
&
propType
!
=
PropertyType
:
:
DerivedConstructor
)
{
errorAt
(
nameOffset
JSMSG_BAD_METHOD_DEF
)
;
return
null
(
)
;
}
if
(
propType
=
=
PropertyType
:
:
Getter
)
propType
=
PropertyType
:
:
GetterNoExpressionClosure
;
if
(
propType
=
=
PropertyType
:
:
Setter
)
propType
=
PropertyType
:
:
SetterNoExpressionClosure
;
if
(
!
isStatic
&
&
propAtom
=
=
context
-
>
names
(
)
.
constructor
)
{
if
(
propType
!
=
PropertyType
:
:
Method
)
{
errorAt
(
nameOffset
JSMSG_BAD_METHOD_DEF
)
;
return
null
(
)
;
}
if
(
seenConstructor
)
{
errorAt
(
nameOffset
JSMSG_DUPLICATE_PROPERTY
"
constructor
"
)
;
return
null
(
)
;
}
seenConstructor
=
true
;
propType
=
hasHeritage
?
PropertyType
:
:
DerivedConstructor
:
PropertyType
:
:
Constructor
;
}
else
if
(
isStatic
&
&
propAtom
=
=
context
-
>
names
(
)
.
prototype
)
{
errorAt
(
nameOffset
JSMSG_BAD_METHOD_DEF
)
;
return
null
(
)
;
}
RootedAtom
funName
(
context
)
;
switch
(
propType
)
{
case
PropertyType
:
:
GetterNoExpressionClosure
:
case
PropertyType
:
:
SetterNoExpressionClosure
:
if
(
!
tokenStream
.
isCurrentTokenType
(
TOK_RB
)
)
{
funName
=
prefixAccessorName
(
propType
propAtom
)
;
if
(
!
funName
)
return
null
(
)
;
}
break
;
case
PropertyType
:
:
Constructor
:
case
PropertyType
:
:
DerivedConstructor
:
funName
=
name
;
break
;
default
:
if
(
!
tokenStream
.
isCurrentTokenType
(
TOK_RB
)
)
funName
=
propAtom
;
}
Node
fn
=
methodDefinition
(
propType
funName
)
;
if
(
!
fn
)
return
null
(
)
;
handler
.
checkAndSetIsDirectRHSAnonFunction
(
fn
)
;
JSOp
op
=
JSOpFromPropertyType
(
propType
)
;
if
(
!
handler
.
addClassMethodDefinition
(
classMethods
propName
fn
op
isStatic
)
)
return
null
(
)
;
}
Node
nameNode
=
null
(
)
;
Node
methodsOrBlock
=
classMethods
;
if
(
name
)
{
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
Const
namePos
)
)
return
null
(
)
;
Node
innerName
=
newName
(
name
namePos
)
;
if
(
!
innerName
)
return
null
(
)
;
Node
classBlock
=
finishLexicalScope
(
*
classScope
classMethods
)
;
if
(
!
classBlock
)
return
null
(
)
;
methodsOrBlock
=
classBlock
;
classScope
.
reset
(
)
;
classStmt
.
reset
(
)
;
Node
outerName
=
null
(
)
;
if
(
classContext
=
=
ClassStatement
)
{
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
Let
namePos
)
)
return
null
(
)
;
outerName
=
newName
(
name
namePos
)
;
if
(
!
outerName
)
return
null
(
)
;
}
nameNode
=
handler
.
newClassNames
(
outerName
innerName
namePos
)
;
if
(
!
nameNode
)
return
null
(
)
;
}
MOZ_ALWAYS_TRUE
(
setLocalStrictMode
(
savedStrictness
)
)
;
return
handler
.
newClass
(
nameNode
classHeritage
methodsOrBlock
)
;
}
template
<
class
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
nextTokenContinuesLetDeclaration
(
TokenKind
next
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_NAME
)
)
;
MOZ_ASSERT
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
let
)
;
MOZ_ASSERT
(
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
;
#
ifdef
DEBUG
TokenKind
verify
;
MOZ_ALWAYS_TRUE
(
tokenStream
.
peekToken
(
&
verify
)
)
;
MOZ_ASSERT
(
next
=
=
verify
)
;
#
endif
if
(
next
=
=
TOK_LB
|
|
next
=
=
TOK_LC
)
return
true
;
if
(
next
=
=
TOK_NAME
)
{
if
(
tokenStream
.
nextName
(
)
=
=
context
-
>
names
(
)
.
yield
)
{
MOZ_ASSERT
(
tokenStream
.
nextNameContainsEscape
(
)
"
token
stream
should
interpret
unescaped
'
yield
'
as
TOK_YIELD
"
)
;
return
yieldHandling
=
=
YieldIsName
;
}
return
true
;
}
if
(
next
=
=
TOK_YIELD
)
return
yieldHandling
=
=
YieldIsName
;
return
false
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
variableStatement
(
YieldHandling
yieldHandling
)
{
Node
vars
=
declarationList
(
yieldHandling
PNK_VAR
)
;
if
(
!
vars
)
return
null
(
)
;
if
(
!
matchOrInsertSemicolonAfterExpression
(
)
)
return
null
(
)
;
return
vars
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
statement
(
YieldHandling
yieldHandling
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_LC
:
return
blockStatement
(
yieldHandling
)
;
case
TOK_VAR
:
return
variableStatement
(
yieldHandling
)
;
case
TOK_SEMI
:
return
handler
.
newEmptyStatement
(
pos
(
)
)
;
case
TOK_YIELD
:
{
TokenStream
:
:
Modifier
modifier
;
if
(
yieldExpressionsSupported
(
)
)
modifier
=
TokenStream
:
:
Operand
;
else
modifier
=
TokenStream
:
:
None
;
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
modifier
)
)
return
null
(
)
;
if
(
next
=
=
TOK_COLON
)
return
labeledStatement
(
yieldHandling
)
;
return
expressionStatement
(
yieldHandling
)
;
}
case
TOK_NAME
:
{
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
null
(
)
;
if
(
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
let
)
{
bool
forbiddenLetDeclaration
=
false
;
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
|
|
versionNumber
(
)
>
=
JSVERSION_1_7
)
{
forbiddenLetDeclaration
=
true
;
}
else
if
(
next
=
=
TOK_LB
)
{
forbiddenLetDeclaration
=
true
;
}
else
if
(
next
=
=
TOK_LC
|
|
next
=
=
TOK_NAME
)
{
TokenKind
nextSameLine
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
MOZ_ASSERT
(
nextSameLine
=
=
TOK_NAME
|
|
nextSameLine
=
=
TOK_LC
|
|
nextSameLine
=
=
TOK_EOL
)
;
forbiddenLetDeclaration
=
nextSameLine
!
=
TOK_EOL
;
}
if
(
forbiddenLetDeclaration
)
{
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
lexical
declarations
"
)
;
return
null
(
)
;
}
}
if
(
next
=
=
TOK_COLON
)
return
labeledStatement
(
yieldHandling
)
;
return
expressionStatement
(
yieldHandling
)
;
}
case
TOK_NEW
:
return
expressionStatement
(
yieldHandling
PredictInvoked
)
;
default
:
return
expressionStatement
(
yieldHandling
)
;
case
TOK_IF
:
return
ifStatement
(
yieldHandling
)
;
case
TOK_DO
:
return
doWhileStatement
(
yieldHandling
)
;
case
TOK_WHILE
:
return
whileStatement
(
yieldHandling
)
;
case
TOK_FOR
:
return
forStatement
(
yieldHandling
)
;
case
TOK_SWITCH
:
return
switchStatement
(
yieldHandling
)
;
case
TOK_CONTINUE
:
return
continueStatement
(
yieldHandling
)
;
case
TOK_BREAK
:
return
breakStatement
(
yieldHandling
)
;
case
TOK_RETURN
:
if
(
!
pc
-
>
isFunctionBox
(
)
)
{
error
(
JSMSG_BAD_RETURN_OR_YIELD
js_return_str
)
;
return
null
(
)
;
}
return
returnStatement
(
yieldHandling
)
;
case
TOK_WITH
:
return
withStatement
(
yieldHandling
)
;
case
TOK_THROW
:
return
throwStatement
(
yieldHandling
)
;
case
TOK_TRY
:
return
tryStatement
(
yieldHandling
)
;
case
TOK_DEBUGGER
:
return
debuggerStatement
(
)
;
case
TOK_FUNCTION
:
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
function
declarations
"
)
;
return
null
(
)
;
case
TOK_CLASS
:
error
(
JSMSG_FORBIDDEN_AS_STATEMENT
"
classes
"
)
;
return
null
(
)
;
case
TOK_IMPORT
:
return
importDeclaration
(
)
;
case
TOK_EXPORT
:
return
exportDeclaration
(
)
;
case
TOK_CATCH
:
error
(
JSMSG_CATCH_WITHOUT_TRY
)
;
return
null
(
)
;
case
TOK_FINALLY
:
error
(
JSMSG_FINALLY_WITHOUT_TRY
)
;
return
null
(
)
;
}
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
statementListItem
(
YieldHandling
yieldHandling
bool
canHaveDirectives
)
{
MOZ_ASSERT
(
checkOptionsCalled
)
;
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
switch
(
tt
)
{
case
TOK_LC
:
return
blockStatement
(
yieldHandling
)
;
case
TOK_VAR
:
return
variableStatement
(
yieldHandling
)
;
case
TOK_SEMI
:
return
handler
.
newEmptyStatement
(
pos
(
)
)
;
case
TOK_STRING
:
if
(
!
canHaveDirectives
&
&
tokenStream
.
currentToken
(
)
.
atom
(
)
=
=
context
-
>
names
(
)
.
useAsm
)
{
if
(
!
abortIfSyntaxParser
(
)
)
return
null
(
)
;
if
(
!
warning
(
JSMSG_USE_ASM_DIRECTIVE_FAIL
)
)
return
null
(
)
;
}
return
expressionStatement
(
yieldHandling
)
;
case
TOK_YIELD
:
{
TokenStream
:
:
Modifier
modifier
;
if
(
yieldExpressionsSupported
(
)
)
modifier
=
TokenStream
:
:
Operand
;
else
modifier
=
TokenStream
:
:
None
;
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
modifier
)
)
return
null
(
)
;
if
(
next
=
=
TOK_COLON
)
return
labeledStatement
(
yieldHandling
)
;
return
expressionStatement
(
yieldHandling
)
;
}
case
TOK_NAME
:
{
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
null
(
)
;
if
(
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
if
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
let
&
&
nextTokenContinuesLetDeclaration
(
next
yieldHandling
)
)
{
return
lexicalDeclaration
(
yieldHandling
false
)
;
}
if
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
)
{
TokenKind
nextSameLine
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
if
(
nextSameLine
=
=
TOK_FUNCTION
)
{
tokenStream
.
consumeKnownToken
(
TOK_FUNCTION
)
;
return
functionStmt
(
yieldHandling
NameRequired
AsyncFunction
)
;
}
}
}
if
(
next
=
=
TOK_COLON
)
return
labeledStatement
(
yieldHandling
)
;
return
expressionStatement
(
yieldHandling
)
;
}
case
TOK_NEW
:
return
expressionStatement
(
yieldHandling
PredictInvoked
)
;
default
:
return
expressionStatement
(
yieldHandling
)
;
case
TOK_IF
:
return
ifStatement
(
yieldHandling
)
;
case
TOK_DO
:
return
doWhileStatement
(
yieldHandling
)
;
case
TOK_WHILE
:
return
whileStatement
(
yieldHandling
)
;
case
TOK_FOR
:
return
forStatement
(
yieldHandling
)
;
case
TOK_SWITCH
:
return
switchStatement
(
yieldHandling
)
;
case
TOK_CONTINUE
:
return
continueStatement
(
yieldHandling
)
;
case
TOK_BREAK
:
return
breakStatement
(
yieldHandling
)
;
case
TOK_RETURN
:
if
(
!
pc
-
>
isFunctionBox
(
)
)
{
error
(
JSMSG_BAD_RETURN_OR_YIELD
js_return_str
)
;
return
null
(
)
;
}
return
returnStatement
(
yieldHandling
)
;
case
TOK_WITH
:
return
withStatement
(
yieldHandling
)
;
case
TOK_THROW
:
return
throwStatement
(
yieldHandling
)
;
case
TOK_TRY
:
return
tryStatement
(
yieldHandling
)
;
case
TOK_DEBUGGER
:
return
debuggerStatement
(
)
;
case
TOK_FUNCTION
:
return
functionStmt
(
yieldHandling
NameRequired
)
;
case
TOK_CLASS
:
return
classDefinition
(
yieldHandling
ClassStatement
NameRequired
)
;
case
TOK_CONST
:
return
lexicalDeclaration
(
yieldHandling
true
)
;
case
TOK_IMPORT
:
return
importDeclaration
(
)
;
case
TOK_EXPORT
:
return
exportDeclaration
(
)
;
case
TOK_CATCH
:
error
(
JSMSG_CATCH_WITHOUT_TRY
)
;
return
null
(
)
;
case
TOK_FINALLY
:
error
(
JSMSG_FINALLY_WITHOUT_TRY
)
;
return
null
(
)
;
}
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
expr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
Node
pn
=
assignExpr
(
inHandling
yieldHandling
tripledotHandling
possibleError
invoked
)
;
if
(
!
pn
)
return
null
(
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
null
(
)
;
if
(
!
matched
)
return
pn
;
Node
seq
=
handler
.
newCommaExpressionList
(
pn
)
;
if
(
!
seq
)
return
null
(
)
;
while
(
true
)
{
if
(
tripledotHandling
=
=
TripledotAllowed
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RP
)
{
tokenStream
.
consumeKnownToken
(
TOK_RP
TokenStream
:
:
Operand
)
;
if
(
!
tokenStream
.
peekToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_ARROW
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
expression
"
TokenKindToDesc
(
TOK_RP
)
)
;
return
null
(
)
;
}
tokenStream
.
ungetToken
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
break
;
}
}
PossibleError
possibleErrorInner
(
*
this
)
;
pn
=
assignExpr
(
inHandling
yieldHandling
tripledotHandling
&
possibleErrorInner
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
!
possibleError
)
{
if
(
!
possibleErrorInner
.
checkForExpressionError
(
)
)
return
null
(
)
;
}
else
{
possibleErrorInner
.
transferErrorsTo
(
possibleError
)
;
}
handler
.
addList
(
seq
pn
)
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
null
(
)
;
if
(
!
matched
)
break
;
}
return
seq
;
}
static
const
JSOp
ParseNodeKindToJSOp
[
]
=
{
JSOP_OR
JSOP_AND
JSOP_BITOR
JSOP_BITXOR
JSOP_BITAND
JSOP_STRICTEQ
JSOP_EQ
JSOP_STRICTNE
JSOP_NE
JSOP_LT
JSOP_LE
JSOP_GT
JSOP_GE
JSOP_INSTANCEOF
JSOP_IN
JSOP_LSH
JSOP_RSH
JSOP_URSH
JSOP_ADD
JSOP_SUB
JSOP_MUL
JSOP_DIV
JSOP_MOD
JSOP_POW
}
;
static
inline
JSOp
BinaryOpParseNodeKindToJSOp
(
ParseNodeKind
pnk
)
{
MOZ_ASSERT
(
pnk
>
=
PNK_BINOP_FIRST
)
;
MOZ_ASSERT
(
pnk
<
=
PNK_BINOP_LAST
)
;
return
ParseNodeKindToJSOp
[
pnk
-
PNK_BINOP_FIRST
]
;
}
static
ParseNodeKind
BinaryOpTokenKindToParseNodeKind
(
TokenKind
tok
)
{
MOZ_ASSERT
(
TokenKindIsBinaryOp
(
tok
)
)
;
return
ParseNodeKind
(
PNK_BINOP_FIRST
+
(
tok
-
TOK_BINOP_FIRST
)
)
;
}
static
const
int
PrecedenceTable
[
]
=
{
1
2
3
4
5
6
6
6
6
7
7
7
7
7
7
8
8
8
9
9
10
10
10
11
}
;
static
const
int
PRECEDENCE_CLASSES
=
11
;
static
int
Precedence
(
ParseNodeKind
pnk
)
{
if
(
pnk
=
=
PNK_LIMIT
)
return
0
;
MOZ_ASSERT
(
pnk
>
=
PNK_BINOP_FIRST
)
;
MOZ_ASSERT
(
pnk
<
=
PNK_BINOP_LAST
)
;
return
PrecedenceTable
[
pnk
-
PNK_BINOP_FIRST
]
;
}
template
<
typename
ParseHandler
>
MOZ_ALWAYS_INLINE
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
orExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
Node
nodeStack
[
PRECEDENCE_CLASSES
]
;
ParseNodeKind
kindStack
[
PRECEDENCE_CLASSES
]
;
int
depth
=
0
;
Node
pn
;
for
(
;
;
)
{
pn
=
unaryExpr
(
yieldHandling
tripledotHandling
possibleError
invoked
)
;
if
(
!
pn
)
return
pn
;
TokenKind
tok
;
if
(
!
tokenStream
.
getToken
(
&
tok
)
)
return
null
(
)
;
ParseNodeKind
pnk
;
if
(
tok
=
=
TOK_IN
?
inHandling
=
=
InAllowed
:
TokenKindIsBinaryOp
(
tok
)
)
{
if
(
possibleError
&
&
!
possibleError
-
>
checkForExpressionError
(
)
)
return
null
(
)
;
if
(
tok
=
=
TOK_POW
&
&
handler
.
isUnparenthesizedUnaryExpression
(
pn
)
)
{
error
(
JSMSG_BAD_POW_LEFTSIDE
)
;
return
null
(
)
;
}
pnk
=
BinaryOpTokenKindToParseNodeKind
(
tok
)
;
}
else
{
tok
=
TOK_EOF
;
pnk
=
PNK_LIMIT
;
}
possibleError
=
nullptr
;
while
(
depth
>
0
&
&
Precedence
(
kindStack
[
depth
-
1
]
)
>
=
Precedence
(
pnk
)
)
{
depth
-
-
;
ParseNodeKind
combiningPnk
=
kindStack
[
depth
]
;
JSOp
combiningOp
=
BinaryOpParseNodeKindToJSOp
(
combiningPnk
)
;
pn
=
handler
.
appendOrCreateList
(
combiningPnk
nodeStack
[
depth
]
pn
pc
combiningOp
)
;
if
(
!
pn
)
return
pn
;
}
if
(
pnk
=
=
PNK_LIMIT
)
break
;
nodeStack
[
depth
]
=
pn
;
kindStack
[
depth
]
=
pnk
;
depth
+
+
;
MOZ_ASSERT
(
depth
<
=
PRECEDENCE_CLASSES
)
;
}
MOZ_ASSERT
(
depth
=
=
0
)
;
return
pn
;
}
template
<
typename
ParseHandler
>
MOZ_ALWAYS_INLINE
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
condExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
Node
condition
=
orExpr1
(
inHandling
yieldHandling
tripledotHandling
possibleError
invoked
)
;
if
(
!
condition
|
|
!
tokenStream
.
isCurrentTokenType
(
TOK_HOOK
)
)
return
condition
;
Node
thenExpr
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
thenExpr
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_COLON
JSMSG_COLON_IN_COND
)
;
Node
elseExpr
=
assignExpr
(
inHandling
yieldHandling
TripledotProhibited
)
;
if
(
!
elseExpr
)
return
null
(
)
;
TokenKind
ignored
;
if
(
!
tokenStream
.
getToken
(
&
ignored
)
)
return
null
(
)
;
return
handler
.
newConditional
(
condition
thenExpr
elseExpr
)
;
}
class
AutoClearInDestructuringDecl
{
ParseContext
*
pc_
;
Maybe
<
DeclarationKind
>
saved_
;
public
:
explicit
AutoClearInDestructuringDecl
(
ParseContext
*
pc
)
:
pc_
(
pc
)
saved_
(
pc
-
>
inDestructuringDecl
)
{
pc
-
>
inDestructuringDecl
=
Nothing
(
)
;
if
(
saved_
&
&
*
saved_
=
=
DeclarationKind
:
:
FormalParameter
)
pc
-
>
functionBox
(
)
-
>
hasParameterExprs
=
true
;
}
~
AutoClearInDestructuringDecl
(
)
{
pc_
-
>
inDestructuringDecl
=
saved_
;
}
}
;
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
assignExpr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
uint32_t
exprOffset
=
pos
(
)
.
begin
;
bool
endsExpr
;
if
(
tt
=
=
TOK_NAME
)
{
if
(
!
tokenStream
.
nextTokenEndsExpr
(
&
endsExpr
)
)
return
null
(
)
;
if
(
endsExpr
)
{
Rooted
<
PropertyName
*
>
name
(
context
identifierReference
(
yieldHandling
)
)
;
if
(
!
name
)
return
null
(
)
;
return
identifierReference
(
name
)
;
}
}
if
(
tt
=
=
TOK_NUMBER
)
{
if
(
!
tokenStream
.
nextTokenEndsExpr
(
&
endsExpr
)
)
return
null
(
)
;
if
(
endsExpr
)
return
newNumber
(
tokenStream
.
currentToken
(
)
)
;
}
if
(
tt
=
=
TOK_STRING
)
{
if
(
!
tokenStream
.
nextTokenEndsExpr
(
&
endsExpr
)
)
return
null
(
)
;
if
(
endsExpr
)
return
stringLiteral
(
)
;
}
if
(
tt
=
=
TOK_YIELD
&
&
yieldExpressionsSupported
(
)
)
return
yieldExpression
(
inHandling
)
;
bool
maybeAsyncArrow
=
false
;
if
(
tt
=
=
TOK_NAME
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
TokenKind
nextSameLine
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
if
(
nextSameLine
=
=
TOK_NAME
|
|
nextSameLine
=
=
TOK_YIELD
)
maybeAsyncArrow
=
true
;
}
tokenStream
.
ungetToken
(
)
;
TokenStream
:
:
Position
start
(
keepAtoms
)
;
tokenStream
.
tell
(
&
start
)
;
PossibleError
possibleErrorInner
(
*
this
)
;
Node
lhs
;
if
(
maybeAsyncArrow
)
{
tokenStream
.
consumeKnownToken
(
TOK_NAME
TokenStream
:
:
Operand
)
;
MOZ_ASSERT
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
)
;
MOZ_ASSERT
(
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
MOZ_ASSERT
(
tt
=
=
TOK_NAME
|
|
tt
=
=
TOK_YIELD
)
;
RootedPropertyName
name
(
context
bindingIdentifier
(
yieldHandling
)
)
;
if
(
!
name
)
return
null
(
)
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_ARROW
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
'
=
>
'
after
argument
list
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
}
else
{
lhs
=
condExpr1
(
inHandling
yieldHandling
tripledotHandling
&
possibleErrorInner
invoked
)
;
if
(
!
lhs
)
{
return
null
(
)
;
}
}
ParseNodeKind
kind
;
JSOp
op
;
switch
(
tokenStream
.
currentToken
(
)
.
type
)
{
case
TOK_ASSIGN
:
kind
=
PNK_ASSIGN
;
op
=
JSOP_NOP
;
break
;
case
TOK_ADDASSIGN
:
kind
=
PNK_ADDASSIGN
;
op
=
JSOP_ADD
;
break
;
case
TOK_SUBASSIGN
:
kind
=
PNK_SUBASSIGN
;
op
=
JSOP_SUB
;
break
;
case
TOK_BITORASSIGN
:
kind
=
PNK_BITORASSIGN
;
op
=
JSOP_BITOR
;
break
;
case
TOK_BITXORASSIGN
:
kind
=
PNK_BITXORASSIGN
;
op
=
JSOP_BITXOR
;
break
;
case
TOK_BITANDASSIGN
:
kind
=
PNK_BITANDASSIGN
;
op
=
JSOP_BITAND
;
break
;
case
TOK_LSHASSIGN
:
kind
=
PNK_LSHASSIGN
;
op
=
JSOP_LSH
;
break
;
case
TOK_RSHASSIGN
:
kind
=
PNK_RSHASSIGN
;
op
=
JSOP_RSH
;
break
;
case
TOK_URSHASSIGN
:
kind
=
PNK_URSHASSIGN
;
op
=
JSOP_URSH
;
break
;
case
TOK_MULASSIGN
:
kind
=
PNK_MULASSIGN
;
op
=
JSOP_MUL
;
break
;
case
TOK_DIVASSIGN
:
kind
=
PNK_DIVASSIGN
;
op
=
JSOP_DIV
;
break
;
case
TOK_MODASSIGN
:
kind
=
PNK_MODASSIGN
;
op
=
JSOP_MOD
;
break
;
case
TOK_POWASSIGN
:
kind
=
PNK_POWASSIGN
;
op
=
JSOP_POW
;
break
;
case
TOK_ARROW
:
{
tokenStream
.
ungetToken
(
)
;
TokenKind
next
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
next
)
)
return
null
(
)
;
MOZ_ASSERT
(
next
=
=
TOK_ARROW
|
|
next
=
=
TOK_EOL
)
;
if
(
next
!
=
TOK_ARROW
)
{
error
(
JSMSG_LINE_BREAK_BEFORE_ARROW
)
;
return
null
(
)
;
}
tokenStream
.
consumeKnownToken
(
TOK_ARROW
)
;
bool
isBlock
=
false
;
if
(
!
tokenStream
.
peekToken
(
&
next
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
next
=
=
TOK_LC
)
isBlock
=
true
;
tokenStream
.
seek
(
start
)
;
if
(
!
tokenStream
.
peekToken
(
&
next
TokenStream
:
:
Operand
)
)
return
null
(
)
;
GeneratorKind
generatorKind
=
NotGenerator
;
FunctionAsyncKind
asyncKind
=
SyncFunction
;
if
(
next
=
=
TOK_NAME
)
{
tokenStream
.
consumeKnownToken
(
next
TokenStream
:
:
Operand
)
;
if
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
TokenKind
nextSameLine
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
if
(
nextSameLine
=
=
TOK_ARROW
)
{
tokenStream
.
ungetToken
(
)
;
}
else
{
generatorKind
=
StarGenerator
;
asyncKind
=
AsyncFunction
;
}
}
else
{
tokenStream
.
ungetToken
(
)
;
}
}
Node
pn
=
handler
.
newArrowFunction
(
)
;
if
(
!
pn
)
return
null
(
)
;
Node
arrowFunc
=
functionDefinition
(
pn
inHandling
yieldHandling
nullptr
Arrow
generatorKind
asyncKind
)
;
if
(
!
arrowFunc
)
return
null
(
)
;
if
(
isBlock
)
{
TokenKind
ignored
;
if
(
!
tokenStream
.
peekToken
(
&
ignored
TokenStream
:
:
Operand
)
)
return
null
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
}
return
arrowFunc
;
}
default
:
MOZ_ASSERT
(
!
tokenStream
.
isCurrentTokenAssignment
(
)
)
;
if
(
!
possibleError
)
{
if
(
!
possibleErrorInner
.
checkForExpressionError
(
)
)
return
null
(
)
;
}
else
{
possibleErrorInner
.
transferErrorsTo
(
possibleError
)
;
}
tokenStream
.
ungetToken
(
)
;
return
lhs
;
}
if
(
handler
.
isUnparenthesizedDestructuringPattern
(
lhs
)
)
{
if
(
kind
!
=
PNK_ASSIGN
)
{
error
(
JSMSG_BAD_DESTRUCT_ASS
)
;
return
null
(
)
;
}
if
(
!
checkDestructuringPattern
(
lhs
Nothing
(
)
&
possibleErrorInner
)
)
return
null
(
)
;
}
else
if
(
handler
.
isNameAnyParentheses
(
lhs
)
)
{
if
(
const
char
*
chars
=
handler
.
nameIsArgumentsEvalAnyParentheses
(
lhs
context
)
)
{
if
(
!
strictModeErrorAt
(
exprOffset
JSMSG_BAD_STRICT_ASSIGN
chars
)
)
return
null
(
)
;
}
handler
.
adjustGetToSet
(
lhs
)
;
}
else
if
(
handler
.
isPropertyAccess
(
lhs
)
)
{
}
else
if
(
handler
.
isFunctionCall
(
lhs
)
)
{
if
(
!
strictModeErrorAt
(
exprOffset
JSMSG_BAD_LEFTSIDE_OF_ASS
)
)
return
null
(
)
;
}
else
{
errorAt
(
exprOffset
JSMSG_BAD_LEFTSIDE_OF_ASS
)
;
return
null
(
)
;
}
if
(
!
possibleErrorInner
.
checkForExpressionError
(
)
)
return
null
(
)
;
Node
rhs
;
{
AutoClearInDestructuringDecl
autoClear
(
pc
)
;
rhs
=
assignExpr
(
inHandling
yieldHandling
TripledotProhibited
)
;
if
(
!
rhs
)
return
null
(
)
;
}
if
(
kind
=
=
PNK_ASSIGN
)
handler
.
checkAndSetIsDirectRHSAnonFunction
(
rhs
)
;
return
handler
.
newAssignment
(
kind
lhs
rhs
op
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
isValidSimpleAssignmentTarget
(
Node
node
FunctionCallBehavior
behavior
)
{
if
(
handler
.
isNameAnyParentheses
(
node
)
)
{
if
(
!
pc
-
>
sc
(
)
-
>
strict
(
)
)
return
true
;
return
!
handler
.
nameIsArgumentsEvalAnyParentheses
(
node
context
)
;
}
if
(
handler
.
isPropertyAccess
(
node
)
)
return
true
;
if
(
behavior
=
=
PermitAssignmentToFunctionCalls
)
{
if
(
handler
.
isFunctionCall
(
node
)
)
return
true
;
}
return
false
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkIncDecOperand
(
Node
operand
uint32_t
operandOffset
)
{
if
(
handler
.
isNameAnyParentheses
(
operand
)
)
{
if
(
const
char
*
chars
=
handler
.
nameIsArgumentsEvalAnyParentheses
(
operand
context
)
)
{
if
(
!
strictModeErrorAt
(
operandOffset
JSMSG_BAD_STRICT_ASSIGN
chars
)
)
return
false
;
}
}
else
if
(
handler
.
isPropertyAccess
(
operand
)
)
{
}
else
if
(
handler
.
isFunctionCall
(
operand
)
)
{
if
(
!
strictModeErrorAt
(
operandOffset
JSMSG_BAD_INCOP_OPERAND
)
)
return
false
;
}
else
{
errorAt
(
operandOffset
JSMSG_BAD_INCOP_OPERAND
)
;
return
false
;
}
MOZ_ASSERT
(
isValidSimpleAssignmentTarget
(
operand
PermitAssignmentToFunctionCalls
)
"
inconsistent
increment
/
decrement
operand
validation
"
)
;
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
unaryOpExpr
(
YieldHandling
yieldHandling
ParseNodeKind
kind
JSOp
op
uint32_t
begin
)
{
Node
kid
=
unaryExpr
(
yieldHandling
TripledotProhibited
)
;
if
(
!
kid
)
return
null
(
)
;
return
handler
.
newUnary
(
kind
op
begin
kid
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
unaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
switch
(
tt
)
{
case
TOK_VOID
:
return
unaryOpExpr
(
yieldHandling
PNK_VOID
JSOP_VOID
begin
)
;
case
TOK_NOT
:
return
unaryOpExpr
(
yieldHandling
PNK_NOT
JSOP_NOT
begin
)
;
case
TOK_BITNOT
:
return
unaryOpExpr
(
yieldHandling
PNK_BITNOT
JSOP_BITNOT
begin
)
;
case
TOK_ADD
:
return
unaryOpExpr
(
yieldHandling
PNK_POS
JSOP_POS
begin
)
;
case
TOK_SUB
:
return
unaryOpExpr
(
yieldHandling
PNK_NEG
JSOP_NEG
begin
)
;
case
TOK_TYPEOF
:
{
Node
kid
=
unaryExpr
(
yieldHandling
TripledotProhibited
)
;
if
(
!
kid
)
return
null
(
)
;
return
handler
.
newTypeof
(
begin
kid
)
;
}
case
TOK_INC
:
case
TOK_DEC
:
{
TokenKind
tt2
;
if
(
!
tokenStream
.
getToken
(
&
tt2
TokenStream
:
:
Operand
)
)
return
null
(
)
;
uint32_t
operandOffset
=
pos
(
)
.
begin
;
Node
operand
=
memberExpr
(
yieldHandling
TripledotProhibited
tt2
)
;
if
(
!
operand
|
|
!
checkIncDecOperand
(
operand
operandOffset
)
)
return
null
(
)
;
return
handler
.
newUpdate
(
(
tt
=
=
TOK_INC
)
?
PNK_PREINCREMENT
:
PNK_PREDECREMENT
begin
operand
)
;
}
case
TOK_DELETE
:
{
uint32_t
exprOffset
;
if
(
!
tokenStream
.
peekOffset
(
&
exprOffset
TokenStream
:
:
Operand
)
)
return
null
(
)
;
Node
expr
=
unaryExpr
(
yieldHandling
TripledotProhibited
)
;
if
(
!
expr
)
return
null
(
)
;
if
(
handler
.
isNameAnyParentheses
(
expr
)
)
{
if
(
!
strictModeErrorAt
(
exprOffset
JSMSG_DEPRECATED_DELETE_OPERAND
)
)
return
null
(
)
;
pc
-
>
sc
(
)
-
>
setBindingsAccessedDynamically
(
)
;
}
return
handler
.
newDelete
(
begin
expr
)
;
}
case
TOK_AWAIT
:
{
if
(
!
pc
-
>
isAsync
(
)
)
{
error
(
JSMSG_RESERVED_ID
"
await
"
)
;
return
null
(
)
;
}
Node
kid
=
unaryExpr
(
yieldHandling
tripledotHandling
possibleError
invoked
)
;
if
(
!
kid
)
return
null
(
)
;
pc
-
>
lastAwaitOffset
=
begin
;
return
newAwaitExpression
(
begin
kid
)
;
}
default
:
{
Node
expr
=
memberExpr
(
yieldHandling
tripledotHandling
tt
true
possibleError
invoked
)
;
if
(
!
expr
)
return
null
(
)
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
tt
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_INC
&
&
tt
!
=
TOK_DEC
)
return
expr
;
tokenStream
.
consumeKnownToken
(
tt
)
;
if
(
!
checkIncDecOperand
(
expr
begin
)
)
return
null
(
)
;
return
handler
.
newUpdate
(
(
tt
=
=
TOK_INC
)
?
PNK_POSTINCREMENT
:
PNK_POSTDECREMENT
begin
expr
)
;
}
}
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
generatorComprehensionLambda
(
unsigned
begin
)
{
Node
genfn
=
handler
.
newFunctionExpression
(
)
;
if
(
!
genfn
)
return
null
(
)
;
ParseContext
*
outerpc
=
pc
;
RootedObject
proto
(
context
)
;
JSContext
*
cx
=
context
-
>
helperThread
(
)
?
nullptr
:
context
;
proto
=
GlobalObject
:
:
getOrCreateStarGeneratorFunctionPrototype
(
cx
context
-
>
global
(
)
)
;
if
(
!
proto
)
return
null
(
)
;
RootedFunction
fun
(
context
newFunction
(
nullptr
Expression
StarGenerator
SyncFunction
proto
)
)
;
if
(
!
fun
)
return
null
(
)
;
Directives
directives
(
outerpc
-
>
sc
(
)
-
>
strict
(
)
)
;
FunctionBox
*
genFunbox
=
newFunctionBox
(
genfn
fun
directives
StarGenerator
SyncFunction
false
)
;
if
(
!
genFunbox
)
return
null
(
)
;
genFunbox
-
>
isGenexpLambda
=
true
;
genFunbox
-
>
initWithEnclosingParseContext
(
outerpc
Expression
)
;
ParseContext
genpc
(
this
genFunbox
nullptr
)
;
if
(
!
genpc
.
init
(
)
)
return
null
(
)
;
genpc
.
functionScope
(
)
.
useAsVarScope
(
&
genpc
)
;
genFunbox
-
>
anyCxFlags
=
outerpc
-
>
sc
(
)
-
>
anyCxFlags
;
if
(
!
declareDotGeneratorName
(
)
)
return
null
(
)
;
Node
body
=
handler
.
newStatementList
(
TokenPos
(
begin
pos
(
)
.
end
)
)
;
if
(
!
body
)
return
null
(
)
;
Node
comp
=
comprehension
(
StarGenerator
)
;
if
(
!
comp
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_IN_PAREN
)
;
handler
.
setBeginPosition
(
comp
begin
)
;
handler
.
setEndPosition
(
comp
pos
(
)
.
end
)
;
handler
.
addStatementToList
(
body
comp
)
;
handler
.
setEndPosition
(
body
pos
(
)
.
end
)
;
handler
.
setBeginPosition
(
genfn
begin
)
;
handler
.
setEndPosition
(
genfn
pos
(
)
.
end
)
;
Node
generator
=
newDotGeneratorName
(
)
;
if
(
!
generator
)
return
null
(
)
;
if
(
!
handler
.
prependInitialYield
(
body
generator
)
)
return
null
(
)
;
if
(
!
propagateFreeNamesAndMarkClosedOverBindings
(
pc
-
>
varScope
(
)
)
)
return
null
(
)
;
if
(
!
finishFunction
(
)
)
return
null
(
)
;
if
(
!
leaveInnerFunction
(
outerpc
)
)
return
null
(
)
;
if
(
!
handler
.
setComprehensionLambdaBody
(
genfn
body
)
)
return
null
(
)
;
return
genfn
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
comprehensionFor
(
GeneratorKind
comprehensionKind
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FOR
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_AFTER_FOR
)
;
MUST_MATCH_TOKEN
(
TOK_NAME
JSMSG_NO_VARIABLE_NAME
)
;
RootedPropertyName
name
(
context
tokenStream
.
currentName
(
)
)
;
if
(
name
=
=
context
-
>
names
(
)
.
let
)
{
error
(
JSMSG_LET_COMP_BINDING
)
;
return
null
(
)
;
}
TokenPos
namePos
=
pos
(
)
;
Node
lhs
=
newName
(
name
)
;
if
(
!
lhs
)
return
null
(
)
;
bool
matched
;
if
(
!
tokenStream
.
matchContextualKeyword
(
&
matched
context
-
>
names
(
)
.
of
)
)
return
null
(
)
;
if
(
!
matched
)
{
error
(
JSMSG_OF_AFTER_FOR_NAME
)
;
return
null
(
)
;
}
Node
rhs
=
assignExpr
(
InAllowed
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
rhs
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_FOR_OF_ITERABLE
)
;
TokenPos
headPos
(
begin
pos
(
)
.
end
)
;
ParseContext
:
:
Scope
scope
(
this
)
;
if
(
!
scope
.
init
(
pc
)
)
return
null
(
)
;
{
ParseContext
:
:
Statement
forHeadStmt
(
pc
StatementKind
:
:
ForLoopLexicalHead
)
;
if
(
!
noteDeclaredName
(
name
DeclarationKind
:
:
Let
namePos
)
)
return
null
(
)
;
}
Node
decls
=
handler
.
newComprehensionBinding
(
lhs
)
;
if
(
!
decls
)
return
null
(
)
;
Node
tail
=
comprehensionTail
(
comprehensionKind
)
;
if
(
!
tail
)
return
null
(
)
;
Node
lexicalScope
=
finishLexicalScope
(
scope
decls
)
;
if
(
!
lexicalScope
)
return
null
(
)
;
Node
head
=
handler
.
newForInOrOfHead
(
PNK_FOROF
lexicalScope
rhs
headPos
)
;
if
(
!
head
)
return
null
(
)
;
return
handler
.
newComprehensionFor
(
begin
head
tail
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
comprehensionIf
(
GeneratorKind
comprehensionKind
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_IF
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
MUST_MATCH_TOKEN
(
TOK_LP
JSMSG_PAREN_BEFORE_COND
)
;
Node
cond
=
assignExpr
(
InAllowed
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
cond
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_COND
)
;
if
(
handler
.
isUnparenthesizedAssignment
(
cond
)
)
{
if
(
!
extraWarning
(
JSMSG_EQUAL_AS_ASSIGN
)
)
return
null
(
)
;
}
Node
then
=
comprehensionTail
(
comprehensionKind
)
;
if
(
!
then
)
return
null
(
)
;
return
handler
.
newIfStatement
(
begin
cond
then
null
(
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
comprehensionTail
(
GeneratorKind
comprehensionKind
)
{
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_FOR
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
matched
)
return
comprehensionFor
(
comprehensionKind
)
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_IF
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
matched
)
return
comprehensionIf
(
comprehensionKind
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
Node
bodyExpr
=
assignExpr
(
InAllowed
YieldIsKeyword
TripledotProhibited
)
;
if
(
!
bodyExpr
)
return
null
(
)
;
if
(
comprehensionKind
=
=
NotGenerator
)
return
handler
.
newArrayPush
(
begin
bodyExpr
)
;
MOZ_ASSERT
(
comprehensionKind
=
=
StarGenerator
)
;
Node
yieldExpr
=
newYieldExpression
(
begin
bodyExpr
)
;
if
(
!
yieldExpr
)
return
null
(
)
;
yieldExpr
=
handler
.
parenthesize
(
yieldExpr
)
;
return
handler
.
newExprStatement
(
yieldExpr
pos
(
)
.
end
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
comprehension
(
GeneratorKind
comprehensionKind
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FOR
)
)
;
uint32_t
startYieldOffset
=
pc
-
>
lastYieldOffset
;
Node
body
=
comprehensionFor
(
comprehensionKind
)
;
if
(
!
body
)
return
null
(
)
;
if
(
comprehensionKind
!
=
NotGenerator
&
&
pc
-
>
lastYieldOffset
!
=
startYieldOffset
)
{
errorAt
(
pc
-
>
lastYieldOffset
JSMSG_BAD_GENEXP_BODY
js_yield_str
)
;
return
null
(
)
;
}
return
body
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
arrayComprehension
(
uint32_t
begin
)
{
Node
inner
=
comprehension
(
NotGenerator
)
;
if
(
!
inner
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RB
JSMSG_BRACKET_AFTER_ARRAY_COMPREHENSION
)
;
Node
comp
=
handler
.
newList
(
PNK_ARRAYCOMP
inner
)
;
if
(
!
comp
)
return
null
(
)
;
handler
.
setBeginPosition
(
comp
begin
)
;
handler
.
setEndPosition
(
comp
pos
(
)
.
end
)
;
return
comp
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
generatorComprehension
(
uint32_t
begin
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_FOR
)
)
;
if
(
!
abortIfSyntaxParser
(
)
)
return
null
(
)
;
Node
genfn
=
generatorComprehensionLambda
(
begin
)
;
if
(
!
genfn
)
return
null
(
)
;
Node
result
=
handler
.
newList
(
PNK_GENEXP
genfn
JSOP_CALL
)
;
if
(
!
result
)
return
null
(
)
;
handler
.
setBeginPosition
(
result
begin
)
;
handler
.
setEndPosition
(
result
pos
(
)
.
end
)
;
return
result
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
assignExprWithoutYieldOrAwait
(
YieldHandling
yieldHandling
)
{
uint32_t
startYieldOffset
=
pc
-
>
lastYieldOffset
;
uint32_t
startAwaitOffset
=
pc
-
>
lastAwaitOffset
;
Node
res
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
res
)
{
if
(
pc
-
>
lastYieldOffset
!
=
startYieldOffset
)
{
errorAt
(
pc
-
>
lastYieldOffset
JSMSG_YIELD_IN_DEFAULT
)
;
return
null
(
)
;
}
if
(
pc
-
>
lastAwaitOffset
!
=
startAwaitOffset
)
{
errorAt
(
pc
-
>
lastAwaitOffset
JSMSG_AWAIT_IN_DEFAULT
)
;
return
null
(
)
;
}
}
return
res
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
argumentList
(
YieldHandling
yieldHandling
Node
listNode
bool
*
isSpread
PossibleError
*
possibleError
)
{
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_RP
TokenStream
:
:
Operand
)
)
return
false
;
if
(
matched
)
{
handler
.
setEndPosition
(
listNode
pos
(
)
.
end
)
;
return
true
;
}
while
(
true
)
{
bool
spread
=
false
;
uint32_t
begin
=
0
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_TRIPLEDOT
TokenStream
:
:
Operand
)
)
return
false
;
if
(
matched
)
{
spread
=
true
;
begin
=
pos
(
)
.
begin
;
*
isSpread
=
true
;
}
Node
argNode
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
possibleError
)
;
if
(
!
argNode
)
return
false
;
if
(
spread
)
{
argNode
=
handler
.
newSpread
(
begin
argNode
)
;
if
(
!
argNode
)
return
false
;
}
handler
.
addList
(
listNode
argNode
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
false
;
if
(
!
matched
)
break
;
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RP
)
{
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsOperand
)
;
break
;
}
}
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_AFTER_ARGS
)
;
handler
.
setEndPosition
(
listNode
pos
(
)
.
end
)
;
return
true
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
checkAndMarkSuperScope
(
)
{
if
(
!
pc
-
>
sc
(
)
-
>
allowSuperProperty
(
)
)
return
false
;
pc
-
>
setSuperScopeNeedsHomeObject
(
)
;
return
true
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
memberExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
TokenKind
tt
bool
allowCallSyntax
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
tt
)
)
;
Node
lhs
;
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
if
(
tt
=
=
TOK_NEW
)
{
uint32_t
newBegin
=
pos
(
)
.
begin
;
Node
newTarget
;
if
(
!
tryNewTarget
(
newTarget
)
)
return
null
(
)
;
if
(
newTarget
)
{
lhs
=
newTarget
;
}
else
{
lhs
=
handler
.
newList
(
PNK_NEW
newBegin
JSOP_NEW
)
;
if
(
!
lhs
)
return
null
(
)
;
tt
=
tokenStream
.
currentToken
(
)
.
type
;
Node
ctorExpr
=
memberExpr
(
yieldHandling
TripledotProhibited
tt
false
nullptr
PredictInvoked
)
;
if
(
!
ctorExpr
)
return
null
(
)
;
handler
.
addList
(
lhs
ctorExpr
)
;
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_LP
)
)
return
null
(
)
;
if
(
matched
)
{
bool
isSpread
=
false
;
if
(
!
argumentList
(
yieldHandling
lhs
&
isSpread
)
)
return
null
(
)
;
if
(
isSpread
)
handler
.
setOp
(
lhs
JSOP_SPREADNEW
)
;
}
}
}
else
if
(
tt
=
=
TOK_SUPER
)
{
Node
thisName
=
newThisName
(
)
;
if
(
!
thisName
)
return
null
(
)
;
lhs
=
handler
.
newSuperBase
(
thisName
pos
(
)
)
;
if
(
!
lhs
)
return
null
(
)
;
}
else
{
lhs
=
primaryExpr
(
yieldHandling
tripledotHandling
tt
possibleError
invoked
)
;
if
(
!
lhs
)
return
null
(
)
;
}
MOZ_ASSERT_IF
(
handler
.
isSuperBase
(
lhs
)
tokenStream
.
isCurrentTokenType
(
TOK_SUPER
)
)
;
while
(
true
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_EOF
)
break
;
Node
nextMember
;
if
(
tt
=
=
TOK_DOT
)
{
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_NAME
)
{
PropertyName
*
field
=
tokenStream
.
currentName
(
)
;
if
(
handler
.
isSuperBase
(
lhs
)
&
&
!
checkAndMarkSuperScope
(
)
)
{
error
(
JSMSG_BAD_SUPERPROP
"
property
"
)
;
return
null
(
)
;
}
nextMember
=
handler
.
newPropertyAccess
(
lhs
field
pos
(
)
.
end
)
;
if
(
!
nextMember
)
return
null
(
)
;
}
else
{
error
(
JSMSG_NAME_AFTER_DOT
)
;
return
null
(
)
;
}
}
else
if
(
tt
=
=
TOK_LB
)
{
Node
propExpr
=
expr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
propExpr
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RB
JSMSG_BRACKET_IN_INDEX
)
;
if
(
handler
.
isSuperBase
(
lhs
)
&
&
!
checkAndMarkSuperScope
(
)
)
{
error
(
JSMSG_BAD_SUPERPROP
"
member
"
)
;
return
null
(
)
;
}
nextMember
=
handler
.
newPropertyByValue
(
lhs
propExpr
pos
(
)
.
end
)
;
if
(
!
nextMember
)
return
null
(
)
;
}
else
if
(
(
allowCallSyntax
&
&
tt
=
=
TOK_LP
)
|
|
tt
=
=
TOK_TEMPLATE_HEAD
|
|
tt
=
=
TOK_NO_SUBS_TEMPLATE
)
{
if
(
handler
.
isSuperBase
(
lhs
)
)
{
if
(
!
pc
-
>
sc
(
)
-
>
allowSuperCall
(
)
)
{
error
(
JSMSG_BAD_SUPERCALL
)
;
return
null
(
)
;
}
if
(
tt
!
=
TOK_LP
)
{
error
(
JSMSG_BAD_SUPER
)
;
return
null
(
)
;
}
nextMember
=
handler
.
newList
(
PNK_SUPERCALL
lhs
JSOP_SUPERCALL
)
;
if
(
!
nextMember
)
return
null
(
)
;
bool
isSpread
=
false
;
if
(
!
argumentList
(
yieldHandling
nextMember
&
isSpread
)
)
return
null
(
)
;
if
(
isSpread
)
handler
.
setOp
(
nextMember
JSOP_SPREADSUPERCALL
)
;
Node
thisName
=
newThisName
(
)
;
if
(
!
thisName
)
return
null
(
)
;
nextMember
=
handler
.
newSetThis
(
thisName
nextMember
)
;
if
(
!
nextMember
)
return
null
(
)
;
}
else
{
if
(
options
(
)
.
selfHostingMode
&
&
handler
.
isPropertyAccess
(
lhs
)
)
{
error
(
JSMSG_SELFHOSTED_METHOD_CALL
)
;
return
null
(
)
;
}
nextMember
=
tt
=
=
TOK_LP
?
handler
.
newCall
(
)
:
handler
.
newTaggedTemplate
(
)
;
if
(
!
nextMember
)
return
null
(
)
;
JSOp
op
=
JSOP_CALL
;
bool
maybeAsyncArrow
=
false
;
if
(
PropertyName
*
prop
=
handler
.
maybeDottedProperty
(
lhs
)
)
{
if
(
prop
=
=
context
-
>
names
(
)
.
apply
)
{
op
=
JSOP_FUNAPPLY
;
if
(
pc
-
>
isFunctionBox
(
)
)
pc
-
>
functionBox
(
)
-
>
usesApply
=
true
;
}
else
if
(
prop
=
=
context
-
>
names
(
)
.
call
)
{
op
=
JSOP_FUNCALL
;
}
}
else
if
(
tt
=
=
TOK_LP
)
{
if
(
handler
.
isAsyncKeyword
(
lhs
context
)
)
{
maybeAsyncArrow
=
true
;
}
else
if
(
handler
.
isEvalAnyParentheses
(
lhs
context
)
)
{
op
=
pc
-
>
sc
(
)
-
>
strict
(
)
?
JSOP_STRICTEVAL
:
JSOP_EVAL
;
pc
-
>
sc
(
)
-
>
setBindingsAccessedDynamically
(
)
;
pc
-
>
sc
(
)
-
>
setHasDirectEval
(
)
;
if
(
pc
-
>
isFunctionBox
(
)
&
&
!
pc
-
>
sc
(
)
-
>
strict
(
)
)
pc
-
>
functionBox
(
)
-
>
setHasExtensibleScope
(
)
;
checkAndMarkSuperScope
(
)
;
}
}
handler
.
setBeginPosition
(
nextMember
lhs
)
;
handler
.
addList
(
nextMember
lhs
)
;
if
(
tt
=
=
TOK_LP
)
{
bool
isSpread
=
false
;
PossibleError
*
asyncPossibleError
=
maybeAsyncArrow
?
possibleError
:
nullptr
;
if
(
!
argumentList
(
yieldHandling
nextMember
&
isSpread
asyncPossibleError
)
)
return
null
(
)
;
if
(
isSpread
)
{
if
(
op
=
=
JSOP_EVAL
)
op
=
JSOP_SPREADEVAL
;
else
if
(
op
=
=
JSOP_STRICTEVAL
)
op
=
JSOP_STRICTSPREADEVAL
;
else
op
=
JSOP_SPREADCALL
;
}
}
else
{
if
(
!
taggedTemplate
(
yieldHandling
nextMember
tt
)
)
return
null
(
)
;
}
handler
.
setOp
(
nextMember
op
)
;
}
}
else
{
tokenStream
.
ungetToken
(
)
;
if
(
handler
.
isSuperBase
(
lhs
)
)
break
;
return
lhs
;
}
lhs
=
nextMember
;
}
if
(
handler
.
isSuperBase
(
lhs
)
)
{
error
(
JSMSG_BAD_SUPER
)
;
return
null
(
)
;
}
return
lhs
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newName
(
PropertyName
*
name
)
{
return
newName
(
name
pos
(
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newName
(
PropertyName
*
name
TokenPos
pos
)
{
return
handler
.
newName
(
name
pos
context
)
;
}
template
<
typename
ParseHandler
>
PropertyName
*
Parser
<
ParseHandler
>
:
:
labelOrIdentifierReference
(
YieldHandling
yieldHandling
bool
yieldTokenizedAsName
)
{
PropertyName
*
ident
;
bool
isYield
;
const
Token
&
tok
=
tokenStream
.
currentToken
(
)
;
if
(
tok
.
type
=
=
TOK_NAME
)
{
MOZ_ASSERT
(
tok
.
name
(
)
!
=
context
-
>
names
(
)
.
yield
|
|
tok
.
nameContainsEscape
(
)
|
|
yieldTokenizedAsName
"
tokenizer
should
have
treated
unescaped
'
yield
'
as
TOK_YIELD
"
)
;
MOZ_ASSERT_IF
(
yieldTokenizedAsName
tok
.
name
(
)
=
=
context
-
>
names
(
)
.
yield
)
;
ident
=
tok
.
name
(
)
;
isYield
=
ident
=
=
context
-
>
names
(
)
.
yield
;
}
else
{
MOZ_ASSERT
(
tok
.
type
=
=
TOK_YIELD
&
&
!
yieldTokenizedAsName
)
;
ident
=
context
-
>
names
(
)
.
yield
;
isYield
=
true
;
}
if
(
!
isYield
)
{
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
const
char
*
badName
=
ident
=
=
context
-
>
names
(
)
.
let
?
"
let
"
:
ident
=
=
context
-
>
names
(
)
.
static_
?
"
static
"
:
nullptr
;
if
(
badName
)
{
error
(
JSMSG_RESERVED_ID
badName
)
;
return
nullptr
;
}
}
}
else
{
if
(
yieldHandling
=
=
YieldIsKeyword
|
|
pc
-
>
sc
(
)
-
>
strict
(
)
|
|
versionNumber
(
)
>
=
JSVERSION_1_7
)
{
error
(
JSMSG_RESERVED_ID
"
yield
"
)
;
return
nullptr
;
}
}
return
ident
;
}
template
<
typename
ParseHandler
>
PropertyName
*
Parser
<
ParseHandler
>
:
:
bindingIdentifier
(
YieldHandling
yieldHandling
)
{
PropertyName
*
ident
;
bool
isYield
;
const
Token
&
tok
=
tokenStream
.
currentToken
(
)
;
if
(
tok
.
type
=
=
TOK_NAME
)
{
MOZ_ASSERT
(
tok
.
name
(
)
!
=
context
-
>
names
(
)
.
yield
|
|
tok
.
nameContainsEscape
(
)
"
tokenizer
should
have
treated
unescaped
'
yield
'
as
TOK_YIELD
"
)
;
ident
=
tok
.
name
(
)
;
isYield
=
ident
=
=
context
-
>
names
(
)
.
yield
;
}
else
{
MOZ_ASSERT
(
tok
.
type
=
=
TOK_YIELD
)
;
ident
=
context
-
>
names
(
)
.
yield
;
isYield
=
true
;
}
if
(
!
isYield
)
{
if
(
pc
-
>
sc
(
)
-
>
strict
(
)
)
{
const
char
*
badName
=
ident
=
=
context
-
>
names
(
)
.
arguments
?
"
arguments
"
:
ident
=
=
context
-
>
names
(
)
.
eval
?
"
eval
"
:
nullptr
;
if
(
badName
)
{
error
(
JSMSG_BAD_STRICT_ASSIGN
badName
)
;
return
nullptr
;
}
badName
=
ident
=
=
context
-
>
names
(
)
.
let
?
"
let
"
:
ident
=
=
context
-
>
names
(
)
.
static_
?
"
static
"
:
nullptr
;
if
(
badName
)
{
error
(
JSMSG_RESERVED_ID
badName
)
;
return
nullptr
;
}
}
}
else
{
if
(
yieldHandling
=
=
YieldIsKeyword
|
|
pc
-
>
sc
(
)
-
>
strict
(
)
|
|
versionNumber
(
)
>
=
JSVERSION_1_7
)
{
error
(
JSMSG_RESERVED_ID
"
yield
"
)
;
return
nullptr
;
}
}
return
ident
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
identifierReference
(
Handle
<
PropertyName
*
>
name
)
{
Node
pn
=
newName
(
name
)
;
if
(
!
pn
)
return
null
(
)
;
if
(
!
pc
-
>
inDestructuringDecl
&
&
!
noteUsedName
(
name
)
)
return
null
(
)
;
return
pn
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
stringLiteral
(
)
{
return
handler
.
newStringLiteral
(
stopStringCompression
(
)
pos
(
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
noSubstitutionTaggedTemplate
(
)
{
if
(
tokenStream
.
hasInvalidTemplateEscape
(
)
)
{
tokenStream
.
clearInvalidTemplateEscape
(
)
;
return
handler
.
newRawUndefinedLiteral
(
pos
(
)
)
;
}
return
handler
.
newTemplateStringLiteral
(
stopStringCompression
(
)
pos
(
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
noSubstitutionUntaggedTemplate
(
)
{
if
(
!
tokenStream
.
checkForInvalidTemplateEscapeError
(
)
)
return
null
(
)
;
return
handler
.
newTemplateStringLiteral
(
stopStringCompression
(
)
pos
(
)
)
;
}
template
<
typename
ParseHandler
>
JSAtom
*
Parser
<
ParseHandler
>
:
:
stopStringCompression
(
)
{
JSAtom
*
atom
=
tokenStream
.
currentToken
(
)
.
atom
(
)
;
const
size_t
HUGE_STRING
=
50000
;
if
(
sct
&
&
sct
-
>
active
(
)
&
&
atom
-
>
length
(
)
>
=
HUGE_STRING
)
sct
-
>
abort
(
)
;
return
atom
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
newRegExp
(
)
{
MOZ_ASSERT
(
!
options
(
)
.
selfHostingMode
)
;
const
char16_t
*
chars
=
tokenStream
.
getTokenbuf
(
)
.
begin
(
)
;
size_t
length
=
tokenStream
.
getTokenbuf
(
)
.
length
(
)
;
RegExpFlag
flags
=
tokenStream
.
currentToken
(
)
.
regExpFlags
(
)
;
Rooted
<
RegExpObject
*
>
reobj
(
context
)
;
reobj
=
RegExpObject
:
:
create
(
context
chars
length
flags
&
tokenStream
alloc
)
;
if
(
!
reobj
)
return
null
(
)
;
return
handler
.
newRegExp
(
reobj
pos
(
)
*
this
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
arrayInitializer
(
YieldHandling
yieldHandling
PossibleError
*
possibleError
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LB
)
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
Node
literal
=
handler
.
newArrayLiteral
(
begin
)
;
if
(
!
literal
)
return
null
(
)
;
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_FOR
)
return
arrayComprehension
(
begin
)
;
if
(
tt
=
=
TOK_RB
)
{
handler
.
setListFlag
(
literal
PNX_NONCONST
)
;
}
else
{
tokenStream
.
ungetToken
(
)
;
uint32_t
index
=
0
;
TokenStream
:
:
Modifier
modifier
=
TokenStream
:
:
Operand
;
for
(
;
;
index
+
+
)
{
if
(
index
>
=
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
{
error
(
JSMSG_ARRAY_INIT_TOO_BIG
)
;
return
null
(
)
;
}
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RB
)
break
;
if
(
tt
=
=
TOK_COMMA
)
{
tokenStream
.
consumeKnownToken
(
TOK_COMMA
TokenStream
:
:
Operand
)
;
if
(
!
handler
.
addElision
(
literal
pos
(
)
)
)
return
null
(
)
;
}
else
if
(
tt
=
=
TOK_TRIPLEDOT
)
{
tokenStream
.
consumeKnownToken
(
TOK_TRIPLEDOT
TokenStream
:
:
Operand
)
;
uint32_t
begin
=
pos
(
)
.
begin
;
Node
inner
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
possibleError
)
;
if
(
!
inner
)
return
null
(
)
;
if
(
!
handler
.
addSpreadElement
(
literal
begin
inner
)
)
return
null
(
)
;
}
else
{
Node
element
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
possibleError
)
;
if
(
!
element
)
return
null
(
)
;
if
(
foldConstants
&
&
!
FoldConstants
(
context
&
element
this
)
)
return
null
(
)
;
handler
.
addArrayElement
(
literal
element
)
;
}
if
(
tt
!
=
TOK_COMMA
)
{
bool
matched
;
if
(
!
tokenStream
.
matchToken
(
&
matched
TOK_COMMA
)
)
return
null
(
)
;
if
(
!
matched
)
{
modifier
=
TokenStream
:
:
None
;
break
;
}
if
(
tt
=
=
TOK_TRIPLEDOT
&
&
possibleError
)
possibleError
-
>
setPendingDestructuringErrorAt
(
pos
(
)
JSMSG_REST_WITH_COMMA
)
;
}
}
MUST_MATCH_TOKEN_MOD
(
TOK_RB
modifier
JSMSG_BRACKET_AFTER_LIST
)
;
}
handler
.
setEndPosition
(
literal
pos
(
)
.
end
)
;
return
literal
;
}
static
JSAtom
*
DoubleToAtom
(
JSContext
*
cx
double
value
)
{
Value
tmp
=
DoubleValue
(
value
)
;
return
ToAtom
<
CanGC
>
(
cx
HandleValue
:
:
fromMarkedLocation
(
&
tmp
)
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
propertyName
(
YieldHandling
yieldHandling
Node
propList
PropertyType
*
propType
MutableHandleAtom
propAtom
)
{
TokenKind
ltok
;
if
(
!
tokenStream
.
getToken
(
&
ltok
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
MOZ_ASSERT
(
ltok
!
=
TOK_RC
"
caller
should
have
handled
TOK_RC
"
)
;
bool
isGenerator
=
false
;
bool
isAsync
=
false
;
if
(
ltok
=
=
TOK_MUL
)
{
isGenerator
=
true
;
if
(
!
tokenStream
.
getToken
(
&
ltok
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
}
if
(
ltok
=
=
TOK_NAME
&
&
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
!
=
TOK_LP
&
&
tt
!
=
TOK_COLON
&
&
tt
!
=
TOK_RC
&
&
tt
!
=
TOK_ASSIGN
)
{
isAsync
=
true
;
ltok
=
tt
;
}
else
{
tokenStream
.
ungetToken
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsKeywordIsName
)
;
}
}
if
(
isAsync
&
&
isGenerator
)
{
error
(
JSMSG_ASYNC_GENERATOR
)
;
return
null
(
)
;
}
propAtom
.
set
(
nullptr
)
;
Node
propName
;
switch
(
ltok
)
{
case
TOK_NUMBER
:
propAtom
.
set
(
DoubleToAtom
(
context
tokenStream
.
currentToken
(
)
.
number
(
)
)
)
;
if
(
!
propAtom
.
get
(
)
)
return
null
(
)
;
propName
=
newNumber
(
tokenStream
.
currentToken
(
)
)
;
if
(
!
propName
)
return
null
(
)
;
break
;
case
TOK_LB
:
propName
=
computedPropertyName
(
yieldHandling
propList
)
;
if
(
!
propName
)
return
null
(
)
;
break
;
case
TOK_NAME
:
{
propAtom
.
set
(
tokenStream
.
currentName
(
)
)
;
if
(
isGenerator
|
|
isAsync
|
|
!
(
propAtom
.
get
(
)
=
=
context
-
>
names
(
)
.
get
|
|
propAtom
.
get
(
)
=
=
context
-
>
names
(
)
.
set
)
)
{
propName
=
handler
.
newObjectLiteralPropertyName
(
propAtom
pos
(
)
)
;
if
(
!
propName
)
return
null
(
)
;
break
;
}
*
propType
=
propAtom
.
get
(
)
=
=
context
-
>
names
(
)
.
get
?
PropertyType
:
:
Getter
:
PropertyType
:
:
Setter
;
TokenKind
tt
;
if
(
!
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_NAME
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
tokenStream
.
consumeKnownToken
(
TOK_NAME
TokenStream
:
:
KeywordIsName
)
;
propAtom
.
set
(
tokenStream
.
currentName
(
)
)
;
return
handler
.
newObjectLiteralPropertyName
(
propAtom
pos
(
)
)
;
}
if
(
tt
=
=
TOK_STRING
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
tokenStream
.
consumeKnownToken
(
TOK_STRING
TokenStream
:
:
KeywordIsName
)
;
propAtom
.
set
(
tokenStream
.
currentToken
(
)
.
atom
(
)
)
;
uint32_t
index
;
if
(
propAtom
-
>
isIndex
(
&
index
)
)
{
propAtom
.
set
(
DoubleToAtom
(
context
index
)
)
;
if
(
!
propAtom
.
get
(
)
)
return
null
(
)
;
return
handler
.
newNumber
(
index
NoDecimal
pos
(
)
)
;
}
return
stringLiteral
(
)
;
}
if
(
tt
=
=
TOK_NUMBER
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
tokenStream
.
consumeKnownToken
(
TOK_NUMBER
TokenStream
:
:
KeywordIsName
)
;
propAtom
.
set
(
DoubleToAtom
(
context
tokenStream
.
currentToken
(
)
.
number
(
)
)
)
;
if
(
!
propAtom
.
get
(
)
)
return
null
(
)
;
return
newNumber
(
tokenStream
.
currentToken
(
)
)
;
}
if
(
tt
=
=
TOK_LB
)
{
if
(
!
checkUnescapedName
(
)
)
return
null
(
)
;
tokenStream
.
consumeKnownToken
(
TOK_LB
TokenStream
:
:
KeywordIsName
)
;
return
computedPropertyName
(
yieldHandling
propList
)
;
}
propName
=
handler
.
newObjectLiteralPropertyName
(
propAtom
.
get
(
)
pos
(
)
)
;
if
(
!
propName
)
return
null
(
)
;
tokenStream
.
addModifierException
(
TokenStream
:
:
NoneIsKeywordIsName
)
;
break
;
}
case
TOK_STRING
:
{
propAtom
.
set
(
tokenStream
.
currentToken
(
)
.
atom
(
)
)
;
uint32_t
index
;
if
(
propAtom
-
>
isIndex
(
&
index
)
)
{
propName
=
handler
.
newNumber
(
index
NoDecimal
pos
(
)
)
;
if
(
!
propName
)
return
null
(
)
;
break
;
}
propName
=
stringLiteral
(
)
;
if
(
!
propName
)
return
null
(
)
;
break
;
}
default
:
error
(
JSMSG_UNEXPECTED_TOKEN
"
property
name
"
TokenKindToDesc
(
ltok
)
)
;
return
null
(
)
;
}
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_COLON
)
{
if
(
isGenerator
)
{
error
(
JSMSG_BAD_PROP_ID
)
;
return
null
(
)
;
}
*
propType
=
PropertyType
:
:
Normal
;
return
propName
;
}
if
(
ltok
=
=
TOK_NAME
&
&
(
tt
=
=
TOK_COMMA
|
|
tt
=
=
TOK_RC
|
|
tt
=
=
TOK_ASSIGN
)
)
{
if
(
isGenerator
)
{
error
(
JSMSG_BAD_PROP_ID
)
;
return
null
(
)
;
}
tokenStream
.
ungetToken
(
)
;
*
propType
=
tt
=
=
TOK_ASSIGN
?
PropertyType
:
:
CoverInitializedName
:
PropertyType
:
:
Shorthand
;
return
propName
;
}
if
(
tt
=
=
TOK_LP
)
{
tokenStream
.
ungetToken
(
)
;
if
(
isGenerator
)
*
propType
=
PropertyType
:
:
GeneratorMethod
;
else
if
(
isAsync
)
*
propType
=
PropertyType
:
:
AsyncMethod
;
else
*
propType
=
PropertyType
:
:
Method
;
return
propName
;
}
error
(
JSMSG_COLON_AFTER_ID
)
;
return
null
(
)
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
computedPropertyName
(
YieldHandling
yieldHandling
Node
literal
)
{
uint32_t
begin
=
pos
(
)
.
begin
;
Node
assignNode
;
{
AutoClearInDestructuringDecl
autoClear
(
pc
)
;
assignNode
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
assignNode
)
return
null
(
)
;
}
MUST_MATCH_TOKEN
(
TOK_RB
JSMSG_COMP_PROP_UNTERM_EXPR
)
;
Node
propname
=
handler
.
newComputedName
(
assignNode
begin
pos
(
)
.
end
)
;
if
(
!
propname
)
return
null
(
)
;
handler
.
setListFlag
(
literal
PNX_NONCONST
)
;
return
propname
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
objectLiteral
(
YieldHandling
yieldHandling
PossibleError
*
possibleError
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LC
)
)
;
Node
literal
=
handler
.
newObjectLiteral
(
pos
(
)
.
begin
)
;
if
(
!
literal
)
return
null
(
)
;
bool
seenPrototypeMutation
=
false
;
bool
seenCoverInitializedName
=
false
;
RootedAtom
propAtom
(
context
)
;
for
(
;
;
)
{
TokenKind
tt
;
if
(
!
tokenStream
.
getToken
(
&
tt
TokenStream
:
:
KeywordIsName
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
break
;
TokenPos
namePos
=
pos
(
)
;
tokenStream
.
ungetToken
(
)
;
PropertyType
propType
;
Node
propName
=
propertyName
(
yieldHandling
literal
&
propType
&
propAtom
)
;
if
(
!
propName
)
return
null
(
)
;
if
(
propType
=
=
PropertyType
:
:
Normal
)
{
Node
propExpr
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
possibleError
)
;
if
(
!
propExpr
)
return
null
(
)
;
handler
.
checkAndSetIsDirectRHSAnonFunction
(
propExpr
)
;
if
(
foldConstants
&
&
!
FoldConstants
(
context
&
propExpr
this
)
)
return
null
(
)
;
if
(
propAtom
=
=
context
-
>
names
(
)
.
proto
)
{
if
(
seenPrototypeMutation
)
{
if
(
!
possibleError
)
{
errorAt
(
namePos
.
begin
JSMSG_DUPLICATE_PROTO_PROPERTY
)
;
return
null
(
)
;
}
possibleError
-
>
setPendingExpressionErrorAt
(
namePos
JSMSG_DUPLICATE_PROTO_PROPERTY
)
;
}
seenPrototypeMutation
=
true
;
if
(
!
handler
.
addPrototypeMutation
(
literal
namePos
.
begin
propExpr
)
)
return
null
(
)
;
}
else
{
if
(
!
handler
.
isConstant
(
propExpr
)
)
handler
.
setListFlag
(
literal
PNX_NONCONST
)
;
if
(
!
handler
.
addPropertyDefinition
(
literal
propName
propExpr
)
)
return
null
(
)
;
}
}
else
if
(
propType
=
=
PropertyType
:
:
Shorthand
)
{
TokenKind
propToken
=
TOK_NAME
;
if
(
!
tokenStream
.
checkForKeyword
(
propAtom
&
propToken
)
)
return
null
(
)
;
if
(
propToken
!
=
TOK_NAME
&
&
propToken
!
=
TOK_YIELD
)
{
error
(
JSMSG_RESERVED_ID
TokenKindToDesc
(
propToken
)
)
;
return
null
(
)
;
}
Rooted
<
PropertyName
*
>
name
(
context
identifierReference
(
yieldHandling
propToken
=
=
TOK_YIELD
)
)
;
if
(
!
name
)
return
null
(
)
;
Node
nameExpr
=
identifierReference
(
name
)
;
if
(
!
nameExpr
)
return
null
(
)
;
if
(
!
handler
.
addShorthand
(
literal
propName
nameExpr
)
)
return
null
(
)
;
}
else
if
(
propType
=
=
PropertyType
:
:
CoverInitializedName
)
{
TokenKind
propToken
=
TOK_NAME
;
if
(
!
tokenStream
.
checkForKeyword
(
propAtom
&
propToken
)
)
return
null
(
)
;
if
(
propToken
!
=
TOK_NAME
&
&
propToken
!
=
TOK_YIELD
)
{
error
(
JSMSG_RESERVED_ID
TokenKindToDesc
(
propToken
)
)
;
return
null
(
)
;
}
Rooted
<
PropertyName
*
>
name
(
context
identifierReference
(
yieldHandling
propToken
=
=
TOK_YIELD
)
)
;
if
(
!
name
)
return
null
(
)
;
Node
lhs
=
identifierReference
(
name
)
;
if
(
!
lhs
)
return
null
(
)
;
tokenStream
.
consumeKnownToken
(
TOK_ASSIGN
)
;
if
(
!
seenCoverInitializedName
)
{
seenCoverInitializedName
=
true
;
if
(
!
possibleError
)
{
error
(
JSMSG_COLON_AFTER_ID
)
;
return
null
(
)
;
}
possibleError
-
>
setPendingExpressionErrorAt
(
pos
(
)
JSMSG_COLON_AFTER_ID
)
;
}
Node
rhs
;
{
AutoClearInDestructuringDecl
autoClear
(
pc
)
;
rhs
=
assignExpr
(
InAllowed
yieldHandling
TripledotProhibited
)
;
if
(
!
rhs
)
return
null
(
)
;
}
handler
.
checkAndSetIsDirectRHSAnonFunction
(
rhs
)
;
Node
propExpr
=
handler
.
newAssignment
(
PNK_ASSIGN
lhs
rhs
JSOP_NOP
)
;
if
(
!
propExpr
)
return
null
(
)
;
if
(
!
handler
.
addPropertyDefinition
(
literal
propName
propExpr
)
)
return
null
(
)
;
if
(
!
abortIfSyntaxParser
(
)
)
return
null
(
)
;
}
else
{
RootedAtom
funName
(
context
)
;
if
(
!
tokenStream
.
isCurrentTokenType
(
TOK_RB
)
)
{
funName
=
propAtom
;
if
(
propType
=
=
PropertyType
:
:
Getter
|
|
propType
=
=
PropertyType
:
:
Setter
)
{
funName
=
prefixAccessorName
(
propType
propAtom
)
;
if
(
!
funName
)
return
null
(
)
;
}
}
Node
fn
=
methodDefinition
(
propType
funName
)
;
if
(
!
fn
)
return
null
(
)
;
handler
.
checkAndSetIsDirectRHSAnonFunction
(
fn
)
;
JSOp
op
=
JSOpFromPropertyType
(
propType
)
;
if
(
!
handler
.
addObjectMethodDefinition
(
literal
propName
fn
op
)
)
return
null
(
)
;
}
if
(
!
tokenStream
.
getToken
(
&
tt
)
)
return
null
(
)
;
if
(
tt
=
=
TOK_RC
)
break
;
if
(
tt
!
=
TOK_COMMA
)
{
error
(
JSMSG_CURLY_AFTER_LIST
)
;
return
null
(
)
;
}
}
handler
.
setEndPosition
(
literal
pos
(
)
.
end
)
;
return
literal
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
methodDefinition
(
PropertyType
propType
HandleAtom
funName
)
{
FunctionSyntaxKind
kind
;
switch
(
propType
)
{
case
PropertyType
:
:
Getter
:
kind
=
Getter
;
break
;
case
PropertyType
:
:
GetterNoExpressionClosure
:
kind
=
GetterNoExpressionClosure
;
break
;
case
PropertyType
:
:
Setter
:
kind
=
Setter
;
break
;
case
PropertyType
:
:
SetterNoExpressionClosure
:
kind
=
SetterNoExpressionClosure
;
break
;
case
PropertyType
:
:
Method
:
case
PropertyType
:
:
GeneratorMethod
:
case
PropertyType
:
:
AsyncMethod
:
kind
=
Method
;
break
;
case
PropertyType
:
:
Constructor
:
kind
=
ClassConstructor
;
break
;
case
PropertyType
:
:
DerivedConstructor
:
kind
=
DerivedClassConstructor
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
property
type
"
)
;
}
GeneratorKind
generatorKind
=
(
propType
=
=
PropertyType
:
:
GeneratorMethod
|
|
propType
=
=
PropertyType
:
:
AsyncMethod
)
?
StarGenerator
:
NotGenerator
;
FunctionAsyncKind
asyncKind
=
(
propType
=
=
PropertyType
:
:
AsyncMethod
)
?
AsyncFunction
:
SyncFunction
;
YieldHandling
yieldHandling
=
GetYieldHandling
(
generatorKind
asyncKind
)
;
Node
pn
=
handler
.
newFunctionExpression
(
)
;
if
(
!
pn
)
return
null
(
)
;
return
functionDefinition
(
pn
InAllowed
yieldHandling
funName
kind
generatorKind
asyncKind
)
;
}
template
<
typename
ParseHandler
>
bool
Parser
<
ParseHandler
>
:
:
tryNewTarget
(
Node
&
newTarget
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_NEW
)
)
;
newTarget
=
null
(
)
;
Node
newHolder
=
handler
.
newPosHolder
(
pos
(
)
)
;
if
(
!
newHolder
)
return
false
;
uint32_t
begin
=
pos
(
)
.
begin
;
TokenKind
next
;
if
(
!
tokenStream
.
getToken
(
&
next
TokenStream
:
:
Operand
)
)
return
false
;
if
(
next
!
=
TOK_DOT
)
return
true
;
if
(
!
tokenStream
.
getToken
(
&
next
)
)
return
false
;
if
(
next
!
=
TOK_NAME
|
|
tokenStream
.
currentName
(
)
!
=
context
-
>
names
(
)
.
target
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
target
"
TokenKindToDesc
(
next
)
)
;
return
false
;
}
if
(
!
checkUnescapedName
(
)
)
return
false
;
if
(
!
pc
-
>
sc
(
)
-
>
allowNewTarget
(
)
)
{
errorAt
(
begin
JSMSG_BAD_NEWTARGET
)
;
return
false
;
}
Node
targetHolder
=
handler
.
newPosHolder
(
pos
(
)
)
;
if
(
!
targetHolder
)
return
false
;
newTarget
=
handler
.
newNewTarget
(
newHolder
targetHolder
)
;
return
!
!
newTarget
;
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
primaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
TokenKind
tt
PossibleError
*
possibleError
InvokedPrediction
invoked
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
tt
)
)
;
JS_CHECK_RECURSION
(
context
return
null
(
)
)
;
switch
(
tt
)
{
case
TOK_FUNCTION
:
return
functionExpr
(
invoked
)
;
case
TOK_CLASS
:
return
classDefinition
(
yieldHandling
ClassExpression
NameRequired
)
;
case
TOK_LB
:
return
arrayInitializer
(
yieldHandling
possibleError
)
;
case
TOK_LC
:
return
objectLiteral
(
yieldHandling
possibleError
)
;
case
TOK_LP
:
{
TokenKind
next
;
if
(
!
tokenStream
.
peekToken
(
&
next
TokenStream
:
:
Operand
)
)
return
null
(
)
;
if
(
next
=
=
TOK_RP
)
{
tokenStream
.
consumeKnownToken
(
next
TokenStream
:
:
Operand
)
;
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
null
(
)
;
if
(
next
!
=
TOK_ARROW
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
expression
"
TokenKindToDesc
(
TOK_RP
)
)
;
return
null
(
)
;
}
return
handler
.
newNullLiteral
(
pos
(
)
)
;
}
if
(
next
=
=
TOK_FOR
)
{
uint32_t
begin
=
pos
(
)
.
begin
;
tokenStream
.
consumeKnownToken
(
next
TokenStream
:
:
Operand
)
;
return
generatorComprehension
(
begin
)
;
}
Node
expr
=
exprInParens
(
InAllowed
yieldHandling
TripledotAllowed
possibleError
)
;
if
(
!
expr
)
return
null
(
)
;
MUST_MATCH_TOKEN
(
TOK_RP
JSMSG_PAREN_IN_PAREN
)
;
handler
.
setEndPosition
(
expr
pos
(
)
.
end
)
;
return
handler
.
parenthesize
(
expr
)
;
}
case
TOK_TEMPLATE_HEAD
:
return
templateLiteral
(
yieldHandling
)
;
case
TOK_NO_SUBS_TEMPLATE
:
return
noSubstitutionUntaggedTemplate
(
)
;
case
TOK_STRING
:
return
stringLiteral
(
)
;
case
TOK_YIELD
:
case
TOK_NAME
:
{
if
(
tokenStream
.
currentName
(
)
=
=
context
-
>
names
(
)
.
async
&
&
!
tokenStream
.
currentToken
(
)
.
nameContainsEscape
(
)
)
{
TokenKind
nextSameLine
=
TOK_EOF
;
if
(
!
tokenStream
.
peekTokenSameLine
(
&
nextSameLine
)
)
return
null
(
)
;
if
(
nextSameLine
=
=
TOK_FUNCTION
)
{
tokenStream
.
consumeKnownToken
(
TOK_FUNCTION
)
;
return
functionExpr
(
PredictUninvoked
AsyncFunction
)
;
}
}
Rooted
<
PropertyName
*
>
name
(
context
identifierReference
(
yieldHandling
)
)
;
if
(
!
name
)
return
null
(
)
;
return
identifierReference
(
name
)
;
}
case
TOK_REGEXP
:
return
newRegExp
(
)
;
case
TOK_NUMBER
:
return
newNumber
(
tokenStream
.
currentToken
(
)
)
;
case
TOK_TRUE
:
return
handler
.
newBooleanLiteral
(
true
pos
(
)
)
;
case
TOK_FALSE
:
return
handler
.
newBooleanLiteral
(
false
pos
(
)
)
;
case
TOK_THIS
:
{
if
(
pc
-
>
isFunctionBox
(
)
)
pc
-
>
functionBox
(
)
-
>
usesThis
=
true
;
Node
thisName
=
null
(
)
;
if
(
pc
-
>
sc
(
)
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Function
)
{
thisName
=
newThisName
(
)
;
if
(
!
thisName
)
return
null
(
)
;
}
return
handler
.
newThisLiteral
(
pos
(
)
thisName
)
;
}
case
TOK_NULL
:
return
handler
.
newNullLiteral
(
pos
(
)
)
;
case
TOK_TRIPLEDOT
:
{
if
(
tripledotHandling
!
=
TripledotAllowed
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
expression
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
TokenKind
next
;
if
(
!
tokenStream
.
getToken
(
&
next
)
)
return
null
(
)
;
if
(
next
=
=
TOK_LB
|
|
next
=
=
TOK_LC
)
{
if
(
!
destructuringDeclaration
(
DeclarationKind
:
:
CoverArrowParameter
yieldHandling
next
)
)
{
return
null
(
)
;
}
}
else
{
if
(
next
!
=
TOK_NAME
&
&
next
!
=
TOK_YIELD
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
rest
argument
name
"
TokenKindToDesc
(
next
)
)
;
return
null
(
)
;
}
}
if
(
!
tokenStream
.
getToken
(
&
next
)
)
return
null
(
)
;
if
(
next
!
=
TOK_RP
)
{
error
(
JSMSG_UNEXPECTED_TOKEN
"
closing
parenthesis
"
TokenKindToDesc
(
next
)
)
;
return
null
(
)
;
}
if
(
!
tokenStream
.
peekToken
(
&
next
)
)
return
null
(
)
;
if
(
next
!
=
TOK_ARROW
)
{
tokenStream
.
consumeKnownToken
(
next
)
;
error
(
JSMSG_UNEXPECTED_TOKEN
"
'
=
>
'
after
argument
list
"
TokenKindToDesc
(
next
)
)
;
return
null
(
)
;
}
tokenStream
.
ungetToken
(
)
;
return
handler
.
newNullLiteral
(
pos
(
)
)
;
}
default
:
error
(
JSMSG_UNEXPECTED_TOKEN
"
expression
"
TokenKindToDesc
(
tt
)
)
;
return
null
(
)
;
}
}
template
<
typename
ParseHandler
>
typename
ParseHandler
:
:
Node
Parser
<
ParseHandler
>
:
:
exprInParens
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
)
{
MOZ_ASSERT
(
tokenStream
.
isCurrentTokenType
(
TOK_LP
)
)
;
return
expr
(
inHandling
yieldHandling
tripledotHandling
possibleError
PredictInvoked
)
;
}
void
ParserBase
:
:
addTelemetry
(
JSCompartment
:
:
DeprecatedLanguageExtension
e
)
{
if
(
context
-
>
helperThread
(
)
)
return
;
context
-
>
compartment
(
)
-
>
addTelemetry
(
getFilename
(
)
e
)
;
}
bool
ParserBase
:
:
warnOnceAboutExprClosure
(
)
{
#
ifndef
RELEASE_OR_BETA
if
(
context
-
>
helperThread
(
)
)
return
true
;
if
(
!
context
-
>
compartment
(
)
-
>
warnedAboutExprClosure
)
{
if
(
!
warning
(
JSMSG_DEPRECATED_EXPR_CLOSURE
)
)
return
false
;
context
-
>
compartment
(
)
-
>
warnedAboutExprClosure
=
true
;
}
#
endif
return
true
;
}
bool
ParserBase
:
:
warnOnceAboutForEach
(
)
{
if
(
context
-
>
helperThread
(
)
)
return
true
;
if
(
!
context
-
>
compartment
(
)
-
>
warnedAboutForEach
)
{
if
(
!
warning
(
JSMSG_DEPRECATED_FOR_EACH
)
)
return
false
;
context
-
>
compartment
(
)
-
>
warnedAboutForEach
=
true
;
}
return
true
;
}
template
class
Parser
<
FullParseHandler
>
;
template
class
Parser
<
SyntaxParseHandler
>
;
}
}
