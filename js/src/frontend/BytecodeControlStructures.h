#
ifndef
frontend_BytecodeControlStructures_h
#
define
frontend_BytecodeControlStructures_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ds
/
Nestable
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
TDZCheckCache
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
namespace
frontend
{
struct
BytecodeEmitter
;
class
EmitterScope
;
class
NestableControl
:
public
Nestable
<
NestableControl
>
{
StatementKind
kind_
;
EmitterScope
*
emitterScope_
;
protected
:
NestableControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
;
public
:
using
Nestable
<
NestableControl
>
:
:
enclosing
;
using
Nestable
<
NestableControl
>
:
:
findNearest
;
StatementKind
kind
(
)
const
{
return
kind_
;
}
EmitterScope
*
emitterScope
(
)
const
{
return
emitterScope_
;
}
template
<
typename
T
>
bool
is
(
)
const
;
template
<
typename
T
>
T
&
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
&
>
(
*
this
)
;
}
}
;
class
BreakableControl
:
public
NestableControl
{
public
:
JumpList
breaks
;
BreakableControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
;
MOZ_MUST_USE
bool
patchBreaks
(
BytecodeEmitter
*
bce
)
;
}
;
template
<
>
inline
bool
NestableControl
:
:
is
<
BreakableControl
>
(
)
const
{
return
StatementKindIsUnlabeledBreakTarget
(
kind_
)
|
|
kind_
=
=
StatementKind
:
:
Label
;
}
class
LabelControl
:
public
BreakableControl
{
RootedAtom
label_
;
BytecodeOffset
startOffset_
;
public
:
LabelControl
(
BytecodeEmitter
*
bce
JSAtom
*
label
BytecodeOffset
startOffset
)
;
HandleAtom
label
(
)
const
{
return
label_
;
}
BytecodeOffset
startOffset
(
)
const
{
return
startOffset_
;
}
}
;
template
<
>
inline
bool
NestableControl
:
:
is
<
LabelControl
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Label
;
}
class
LoopControl
:
public
BreakableControl
{
TDZCheckCache
tdzCache_
;
BytecodeOffset
loopEndOffset_
=
BytecodeOffset
:
:
invalidOffset
(
)
;
JumpList
entryJump_
;
JumpTarget
head_
;
JumpTarget
breakTarget_
;
JumpTarget
continueTarget_
;
int32_t
stackDepth_
;
uint32_t
loopDepth_
;
bool
canIonOsr_
;
public
:
JumpList
continues
;
LoopControl
(
BytecodeEmitter
*
bce
StatementKind
loopKind
)
;
BytecodeOffset
headOffset
(
)
const
{
return
head_
.
offset
;
}
BytecodeOffset
loopEndOffset
(
)
const
{
return
loopEndOffset_
;
}
BytecodeOffset
breakTargetOffset
(
)
const
{
return
breakTarget_
.
offset
;
}
BytecodeOffset
continueTargetOffset
(
)
const
{
return
continueTarget_
.
offset
;
}
BytecodeOffsetDiff
loopEndOffsetFromEntryJump
(
)
const
{
return
loopEndOffset_
-
entryJump_
.
offset
;
}
BytecodeOffsetDiff
loopEndOffsetFromLoopHead
(
)
const
{
return
loopEndOffset_
-
head_
.
offset
;
}
void
setContinueTarget
(
BytecodeOffset
offset
)
{
continueTarget_
.
offset
=
offset
;
}
MOZ_MUST_USE
bool
emitContinueTarget
(
BytecodeEmitter
*
bce
)
;
MOZ_MUST_USE
bool
emitSpecialBreakForDone
(
BytecodeEmitter
*
bce
)
;
MOZ_MUST_USE
bool
emitEntryJump
(
BytecodeEmitter
*
bce
)
;
MOZ_MUST_USE
bool
emitLoopHead
(
BytecodeEmitter
*
bce
const
mozilla
:
:
Maybe
<
uint32_t
>
&
nextPos
)
;
MOZ_MUST_USE
bool
emitLoopEntry
(
BytecodeEmitter
*
bce
const
mozilla
:
:
Maybe
<
uint32_t
>
&
nextPos
)
;
MOZ_MUST_USE
bool
emitLoopEnd
(
BytecodeEmitter
*
bce
JSOp
op
)
;
MOZ_MUST_USE
bool
patchBreaksAndContinues
(
BytecodeEmitter
*
bce
)
;
}
;
template
<
>
inline
bool
NestableControl
:
:
is
<
LoopControl
>
(
)
const
{
return
StatementKindIsLoop
(
kind_
)
;
}
class
TryFinallyControl
:
public
NestableControl
{
bool
emittingSubroutine_
;
public
:
JumpList
gosubs
;
TryFinallyControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
;
void
setEmittingSubroutine
(
)
{
emittingSubroutine_
=
true
;
}
bool
emittingSubroutine
(
)
const
{
return
emittingSubroutine_
;
}
}
;
template
<
>
inline
bool
NestableControl
:
:
is
<
TryFinallyControl
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Try
|
|
kind_
=
=
StatementKind
:
:
Finally
;
}
}
}
#
endif
