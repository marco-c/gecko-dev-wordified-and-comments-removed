#
include
"
frontend
/
BCEScriptStencil
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
BCEScriptStencil
:
:
BCEScriptStencil
(
BytecodeEmitter
&
bce
UniquePtr
<
ImmutableScriptData
>
immutableScriptData
)
:
ScriptStencil
(
bce
.
cx
std
:
:
move
(
immutableScriptData
)
)
bce_
(
bce
)
{
init
(
)
;
}
void
BCEScriptStencil
:
:
init
(
)
{
lineno
=
bce_
.
firstLine
;
column
=
bce_
.
firstColumn
;
natoms
=
bce_
.
perScriptData
(
)
.
atomIndices
(
)
-
>
count
(
)
;
ngcthings
=
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
;
immutableFlags
=
bce_
.
sc
-
>
immutableFlags
(
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
Strict
bce_
.
sc
-
>
strict
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NeedsFunctionEnvironmentObjects
getNeedsFunctionEnvironmentObjects
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
HasNonSyntacticScope
bce_
.
outermostScope
(
)
.
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
gcThings
=
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
stealGCThings
(
)
;
if
(
isFunction
(
)
)
{
FunctionBox
*
funbox
=
bce_
.
sc
-
>
asFunctionBox
(
)
;
functionIndex
.
emplace
(
funbox
-
>
index
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
HasMappedArgsObj
funbox
-
>
hasMappedArgsObj
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
FunctionHasExtraBodyVarScope
funbox
-
>
hasExtraBodyVarScope
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
AlwaysNeedsArgsObj
funbox
-
>
definitelyNeedsArgsObj
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
ArgumentsHasVarBinding
funbox
-
>
argumentsHasLocalBinding
(
)
)
;
}
}
bool
BCEScriptStencil
:
:
getNeedsFunctionEnvironmentObjects
(
)
const
{
js
:
:
AbstractScopePtr
bodyScope
=
bce_
.
bodyScope
(
)
;
if
(
bodyScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
Function
)
{
if
(
bodyScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
js
:
:
AbstractScopePtr
outerScope
=
bce_
.
outermostScope
(
)
;
if
(
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
NamedLambda
|
|
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
StrictNamedLambda
)
{
MOZ_ASSERT
(
bce_
.
sc
-
>
asFunctionBox
(
)
-
>
isNamedLambda
(
)
)
;
if
(
outerScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
BCEScriptStencil
:
:
finishGCThings
(
JSContext
*
cx
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
output
)
const
{
return
EmitScriptThingsVector
(
cx
bce_
.
compilationInfo
gcThings
output
)
;
}
void
BCEScriptStencil
:
:
initAtomMap
(
GCPtrAtom
*
atoms
)
const
{
const
AtomIndexMap
&
indices
=
*
bce_
.
perScriptData
(
)
.
atomIndices
(
)
;
for
(
AtomIndexMap
:
:
Range
r
=
indices
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSAtom
*
atom
=
r
.
front
(
)
.
key
(
)
;
uint32_t
index
=
r
.
front
(
)
.
value
(
)
;
MOZ_ASSERT
(
index
<
indices
.
count
(
)
)
;
atoms
[
index
]
.
init
(
atom
)
;
}
}
void
BCEScriptStencil
:
:
finishInnerFunctions
(
)
const
{
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
finishInnerFunctions
(
)
;
}
