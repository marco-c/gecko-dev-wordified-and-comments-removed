#
include
"
frontend
/
BCEScriptStencil
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
BCEScriptStencil
:
:
BCEScriptStencil
(
BytecodeEmitter
&
bce
)
:
ScriptStencil
(
bce
.
cx
)
bce_
(
bce
)
{
}
bool
BCEScriptStencil
:
:
init
(
JSContext
*
cx
uint32_t
nslots
)
{
lineno
=
bce_
.
firstLine
;
column
=
bce_
.
firstColumn
;
natoms
=
bce_
.
perScriptData
(
)
.
atomIndices
(
)
-
>
count
(
)
;
ngcthings
=
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
;
bool
isFunction
=
bce_
.
sc
-
>
isFunctionBox
(
)
;
uint16_t
funLength
=
isFunction
?
bce_
.
sc
-
>
asFunctionBox
(
)
-
>
length
:
0
;
immutableScriptData
=
ImmutableScriptData
:
:
new_
(
cx
bce_
.
mainOffset
(
)
bce_
.
maxFixedSlots
nslots
bce_
.
bodyScopeIndex
bce_
.
bytecodeSection
(
)
.
numICEntries
(
)
bce_
.
bytecodeSection
(
)
.
numTypeSets
(
)
isFunction
funLength
bce_
.
bytecodeSection
(
)
.
code
(
)
bce_
.
bytecodeSection
(
)
.
notes
(
)
bce_
.
bytecodeSection
(
)
.
resumeOffsetList
(
)
.
span
(
)
bce_
.
bytecodeSection
(
)
.
scopeNoteList
(
)
.
span
(
)
bce_
.
bytecodeSection
(
)
.
tryNoteList
(
)
.
span
(
)
)
;
if
(
!
immutableScriptData
)
{
return
false
;
}
immutableFlags
=
bce_
.
sc
-
>
immutableFlags
(
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
Strict
bce_
.
sc
-
>
strict
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
NeedsFunctionEnvironmentObjects
getNeedsFunctionEnvironmentObjects
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableScriptFlagsEnum
:
:
HasNonSyntacticScope
bce_
.
outermostScope
(
)
.
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
gcThings
=
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
stealGCThings
(
)
;
if
(
isFunction
)
{
functionBox
=
bce_
.
sc
-
>
asFunctionBox
(
)
;
}
return
true
;
}
bool
BCEScriptStencil
:
:
getNeedsFunctionEnvironmentObjects
(
)
const
{
js
:
:
AbstractScopePtr
bodyScope
=
bce_
.
bodyScope
(
)
;
if
(
bodyScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
Function
)
{
if
(
bodyScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
js
:
:
AbstractScopePtr
outerScope
=
bce_
.
outermostScope
(
)
;
if
(
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
NamedLambda
|
|
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
StrictNamedLambda
)
{
MOZ_ASSERT
(
bce_
.
sc
-
>
asFunctionBox
(
)
-
>
isNamedLambda
(
)
)
;
if
(
outerScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
BCEScriptStencil
:
:
finishGCThings
(
JSContext
*
cx
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
output
)
const
{
return
EmitScriptThingsVector
(
cx
bce_
.
compilationInfo
gcThings
output
)
;
}
void
BCEScriptStencil
:
:
initAtomMap
(
GCPtrAtom
*
atoms
)
const
{
const
AtomIndexMap
&
indices
=
*
bce_
.
perScriptData
(
)
.
atomIndices
(
)
;
for
(
AtomIndexMap
:
:
Range
r
=
indices
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSAtom
*
atom
=
r
.
front
(
)
.
key
(
)
;
uint32_t
index
=
r
.
front
(
)
.
value
(
)
;
MOZ_ASSERT
(
index
<
indices
.
count
(
)
)
;
atoms
[
index
]
.
init
(
atom
)
;
}
}
void
BCEScriptStencil
:
:
finishInnerFunctions
(
)
const
{
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
finishInnerFunctions
(
)
;
}
