#
ifndef
frontend_Stencil_h
#
define
frontend_Stencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
namespace
js
{
class
JSONPrinter
;
namespace
frontend
{
struct
CompilationInfo
;
struct
CompilationAtomCache
;
struct
CompilationStencil
;
struct
CompilationGCOutput
;
class
ScriptStencil
;
class
RegExpStencil
;
class
BigIntStencil
;
class
StencilXDR
;
using
BaseParserScopeData
=
AbstractBaseScopeData
<
const
ParserAtom
>
;
template
<
typename
Scope
>
using
ParserScopeData
=
typename
Scope
:
:
template
AbstractData
<
const
ParserAtom
>
;
using
ParserGlobalScopeData
=
ParserScopeData
<
GlobalScope
>
;
using
ParserEvalScopeData
=
ParserScopeData
<
EvalScope
>
;
using
ParserLexicalScopeData
=
ParserScopeData
<
LexicalScope
>
;
using
ParserFunctionScopeData
=
ParserScopeData
<
FunctionScope
>
;
using
ParserModuleScopeData
=
ParserScopeData
<
ModuleScope
>
;
using
ParserVarScopeData
=
ParserScopeData
<
VarScope
>
;
using
ParserBindingIter
=
AbstractBindingIter
<
const
ParserAtom
>
;
using
RegExpIndex
=
TypedIndex
<
RegExpStencil
>
;
using
BigIntIndex
=
TypedIndex
<
BigIntStencil
>
;
using
ObjLiteralIndex
=
TypedIndex
<
ObjLiteralStencil
>
;
using
FunctionIndex
=
TypedIndex
<
ScriptStencil
>
;
FunctionFlags
InitialFunctionFlags
(
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
isSelfHosting
=
false
bool
hasUnclonedName
=
false
)
;
class
RegExpStencil
{
friend
class
StencilXDR
;
TaggedParserAtomIndex
atom_
;
JS
:
:
RegExpFlags
flags_
;
public
:
RegExpStencil
(
)
=
default
;
RegExpStencil
(
TaggedParserAtomIndex
atom
JS
:
:
RegExpFlags
flags
)
:
atom_
(
atom
)
flags_
(
flags
)
{
}
RegExpObject
*
createRegExp
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
)
const
;
RegExpObject
*
createRegExpAndEnsureAtom
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
CompilationStencil
&
stencil
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
class
BigIntStencil
{
friend
class
StencilXDR
;
UniqueTwoByteChars
buf_
;
size_t
length_
=
0
;
public
:
BigIntStencil
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
const
Vector
<
char16_t
32
>
&
buf
)
{
#
ifdef
DEBUG
for
(
char16_t
c
:
buf
)
{
MOZ_ASSERT
(
c
!
=
'
_
'
)
;
}
#
endif
length_
=
buf
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
buf
.
begin
(
)
buf
.
length
(
)
)
;
return
buf_
!
=
nullptr
;
}
BigInt
*
createBigInt
(
JSContext
*
cx
)
const
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
ParseBigIntLiteral
(
cx
source
)
;
}
bool
isZero
(
)
const
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
BigIntLiteralIsZero
(
source
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
#
endif
}
;
class
ScopeStencil
{
friend
class
StencilXDR
;
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing_
;
ScopeKind
kind_
{
UINT8_MAX
}
;
uint32_t
firstFrameSlot_
=
UINT32_MAX
;
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots_
;
mozilla
:
:
Maybe
<
FunctionIndex
>
functionIndex_
;
bool
isArrow_
=
false
;
BaseParserScopeData
*
data_
=
nullptr
;
public
:
ScopeStencil
(
)
=
default
;
ScopeStencil
(
ScopeKind
kind
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots
BaseParserScopeData
*
data
=
{
}
mozilla
:
:
Maybe
<
FunctionIndex
>
functionIndex
=
mozilla
:
:
Nothing
(
)
bool
isArrow
=
false
)
:
enclosing_
(
enclosing
)
kind_
(
kind
)
firstFrameSlot_
(
firstFrameSlot
)
numEnvironmentSlots_
(
numEnvironmentSlots
)
functionIndex_
(
functionIndex
)
isArrow_
(
isArrow
)
data_
(
data
)
{
}
static
bool
createForFunctionScope
(
JSContext
*
cx
CompilationStencil
&
stencil
ParserFunctionScopeData
*
dataArg
bool
hasParameterExprs
bool
needsEnvironment
FunctionIndex
functionIndex
bool
isArrow
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForLexicalScope
(
JSContext
*
cx
CompilationStencil
&
stencil
ScopeKind
kind
ParserLexicalScopeData
*
dataArg
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForVarScope
(
JSContext
*
cx
frontend
:
:
CompilationStencil
&
stencil
ScopeKind
kind
ParserVarScopeData
*
dataArg
uint32_t
firstFrameSlot
bool
needsEnvironment
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForGlobalScope
(
JSContext
*
cx
CompilationStencil
&
stencil
ScopeKind
kind
ParserGlobalScopeData
*
dataArg
ScopeIndex
*
index
)
;
static
bool
createForEvalScope
(
JSContext
*
cx
CompilationStencil
&
stencil
ScopeKind
kind
ParserEvalScopeData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForModuleScope
(
JSContext
*
cx
CompilationStencil
&
stencil
ParserModuleScopeData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForWithScope
(
JSContext
*
cx
CompilationStencil
&
stencil
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
AbstractScopePtr
enclosing
(
CompilationInfo
&
compilationInfo
)
const
;
js
:
:
Scope
*
enclosingExistingScope
(
const
CompilationInput
&
input
const
CompilationGCOutput
&
gcOutput
)
const
;
ScopeKind
kind
(
)
const
{
return
kind_
;
}
bool
hasEnvironment
(
)
const
{
bool
hasEnvironmentShape
=
numEnvironmentSlots_
.
isSome
(
)
;
return
Scope
:
:
hasEnvironment
(
kind
(
)
hasEnvironmentShape
)
;
}
bool
isArrow
(
)
const
{
return
isArrow_
;
}
Scope
*
createScope
(
JSContext
*
cx
CompilationInput
&
input
CompilationGCOutput
&
gcOutput
)
const
;
uint32_t
nextFrameSlot
(
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
void
dumpFields
(
JSONPrinter
&
json
)
;
#
endif
private
:
template
<
typename
SpecificScopeType
>
typename
SpecificScopeType
:
:
template
AbstractData
<
const
ParserAtom
>
&
data
(
)
const
{
using
Data
=
typename
SpecificScopeType
:
:
template
AbstractData
<
const
ParserAtom
>
;
MOZ_ASSERT
(
data_
)
;
return
*
static_cast
<
Data
*
>
(
data_
)
;
}
template
<
typename
SpecificScopeType
>
UniquePtr
<
typename
SpecificScopeType
:
:
Data
>
createSpecificScopeData
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
CompilationGCOutput
&
gcOutput
)
const
;
template
<
typename
SpecificScopeType
>
uint32_t
nextFrameSlot
(
)
const
{
return
data
<
SpecificScopeType
>
(
)
.
nextFrameSlot
;
}
template
<
typename
SpecificEnvironmentType
>
MOZ_MUST_USE
bool
createSpecificShape
(
JSContext
*
cx
ScopeKind
kind
BaseScopeData
*
scopeData
MutableHandleShape
shape
)
const
;
template
<
typename
SpecificScopeType
typename
SpecificEnvironmentType
>
Scope
*
createSpecificScope
(
JSContext
*
cx
CompilationInput
&
input
CompilationGCOutput
&
gcOutput
)
const
;
}
;
using
FunctionDeclaration
=
GCThingIndex
;
using
FunctionDeclarationVector
=
Vector
<
FunctionDeclaration
0
js
:
:
SystemAllocPolicy
>
;
class
StencilModuleEntry
{
public
:
TaggedParserAtomIndex
specifier
;
TaggedParserAtomIndex
localName
;
TaggedParserAtomIndex
importName
;
TaggedParserAtomIndex
exportName
;
uint32_t
lineno
=
0
;
uint32_t
column
=
0
;
private
:
StencilModuleEntry
(
uint32_t
lineno
uint32_t
column
)
:
lineno
(
lineno
)
column
(
column
)
{
}
public
:
StencilModuleEntry
(
)
=
default
;
static
StencilModuleEntry
moduleRequest
(
TaggedParserAtomIndex
specifier
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
!
!
specifier
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
return
entry
;
}
static
StencilModuleEntry
importEntry
(
TaggedParserAtomIndex
specifier
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
importName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
localName
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
localName
=
localName
;
entry
.
importName
=
importName
;
return
entry
;
}
static
StencilModuleEntry
exportAsEntry
(
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
localName
&
&
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
localName
=
localName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportFromEntry
(
TaggedParserAtomIndex
specifier
TaggedParserAtomIndex
importName
TaggedParserAtomIndex
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
importName
=
importName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
}
;
class
StencilModuleMetadata
{
public
:
using
EntryVector
=
Vector
<
StencilModuleEntry
0
js
:
:
SystemAllocPolicy
>
;
EntryVector
requestedModules
;
EntryVector
importEntries
;
EntryVector
localExportEntries
;
EntryVector
indirectExportEntries
;
EntryVector
starExportEntries
;
FunctionDeclarationVector
functionDecls
;
StencilModuleMetadata
(
)
=
default
;
bool
initModule
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
JS
:
:
Handle
<
ModuleObject
*
>
module
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
class
EmptyGlobalScopeType
{
}
;
class
TaggedScriptThingIndex
{
uint32_t
data_
;
static
constexpr
size_t
IndexBit
=
TaggedParserAtomIndex
:
:
IndexBit
;
static
constexpr
size_t
IndexMask
=
TaggedParserAtomIndex
:
:
IndexMask
;
static
constexpr
size_t
TagShift
=
TaggedParserAtomIndex
:
:
TagShift
;
static
constexpr
size_t
TagBit
=
TaggedParserAtomIndex
:
:
TagBit
;
static
constexpr
size_t
TagMask
=
TaggedParserAtomIndex
:
:
TagMask
;
public
:
enum
class
Kind
:
uint32_t
{
Null
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
Null
)
ParserAtomIndex
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
ParserAtomIndex
)
WellKnown
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
WellKnown
)
BigInt
ObjLiteral
RegExp
Scope
Function
EmptyGlobalScope
}
;
private
:
static
constexpr
uint32_t
NullTag
=
uint32_t
(
Kind
:
:
Null
)
<
<
TagShift
;
static_assert
(
NullTag
=
=
TaggedParserAtomIndex
:
:
NullTag
)
;
static
constexpr
uint32_t
ParserAtomIndexTag
=
uint32_t
(
Kind
:
:
ParserAtomIndex
)
<
<
TagShift
;
static_assert
(
ParserAtomIndexTag
=
=
TaggedParserAtomIndex
:
:
ParserAtomIndexTag
)
;
static
constexpr
uint32_t
WellKnownTag
=
uint32_t
(
Kind
:
:
WellKnown
)
<
<
TagShift
;
static_assert
(
WellKnownTag
=
=
TaggedParserAtomIndex
:
:
WellKnownTag
)
;
static
constexpr
uint32_t
BigIntTag
=
uint32_t
(
Kind
:
:
BigInt
)
<
<
TagShift
;
static
constexpr
uint32_t
ObjLiteralTag
=
uint32_t
(
Kind
:
:
ObjLiteral
)
<
<
TagShift
;
static
constexpr
uint32_t
RegExpTag
=
uint32_t
(
Kind
:
:
RegExp
)
<
<
TagShift
;
static
constexpr
uint32_t
ScopeTag
=
uint32_t
(
Kind
:
:
Scope
)
<
<
TagShift
;
static
constexpr
uint32_t
FunctionTag
=
uint32_t
(
Kind
:
:
Function
)
<
<
TagShift
;
static
constexpr
uint32_t
EmptyGlobalScopeTag
=
uint32_t
(
Kind
:
:
EmptyGlobalScope
)
<
<
TagShift
;
public
:
static
constexpr
uint32_t
IndexLimit
=
Bit
(
IndexBit
)
;
TaggedScriptThingIndex
(
)
:
data_
(
NullTag
)
{
}
explicit
TaggedScriptThingIndex
(
TaggedParserAtomIndex
index
)
:
data_
(
*
index
.
rawData
(
)
)
{
}
explicit
TaggedScriptThingIndex
(
BigIntIndex
index
)
:
data_
(
uint32_t
(
index
)
|
BigIntTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ObjLiteralIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ObjLiteralTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
RegExpIndex
index
)
:
data_
(
uint32_t
(
index
)
|
RegExpTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ScopeIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ScopeTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
FunctionIndex
index
)
:
data_
(
uint32_t
(
index
)
|
FunctionTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
EmptyGlobalScopeType
t
)
:
data_
(
EmptyGlobalScopeTag
)
{
}
bool
isAtom
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ParserAtomIndexTag
|
|
(
data_
&
TagMask
)
=
=
WellKnownTag
;
}
bool
isNull
(
)
const
{
bool
result
=
!
data_
;
MOZ_ASSERT_IF
(
result
(
data_
&
TagMask
)
=
=
NullTag
)
;
return
result
;
}
bool
isBigInt
(
)
const
{
return
(
data_
&
TagMask
)
=
=
BigIntTag
;
}
bool
isObjLiteral
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ObjLiteralTag
;
}
bool
isRegExp
(
)
const
{
return
(
data_
&
TagMask
)
=
=
RegExpTag
;
}
bool
isScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ScopeTag
;
}
bool
isFunction
(
)
const
{
return
(
data_
&
TagMask
)
=
=
FunctionTag
;
}
bool
isEmptyGlobalScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
EmptyGlobalScopeTag
;
}
TaggedParserAtomIndex
toAtom
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
)
;
return
TaggedParserAtomIndex
:
:
fromRaw
(
data_
)
;
}
BigIntIndex
toBigInt
(
)
const
{
return
BigIntIndex
(
data_
&
IndexMask
)
;
}
ObjLiteralIndex
toObjLiteral
(
)
const
{
return
ObjLiteralIndex
(
data_
&
IndexMask
)
;
}
RegExpIndex
toRegExp
(
)
const
{
return
RegExpIndex
(
data_
&
IndexMask
)
;
}
ScopeIndex
toScope
(
)
const
{
return
ScopeIndex
(
data_
&
IndexMask
)
;
}
FunctionIndex
toFunction
(
)
const
{
return
FunctionIndex
(
data_
&
IndexMask
)
;
}
uint32_t
*
rawData
(
)
{
return
&
data_
;
}
Kind
tag
(
)
const
{
return
Kind
(
(
data_
&
TagMask
)
>
>
TagShift
)
;
}
bool
operator
=
=
(
const
TaggedScriptThingIndex
&
rhs
)
const
{
return
data_
=
=
rhs
.
data_
;
}
}
;
class
ScriptStencil
{
public
:
ImmutableScriptFlags
immutableFlags
;
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
;
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
gcThings
;
RefPtr
<
js
:
:
SharedImmutableScriptData
>
sharedData
=
{
}
;
SourceExtent
extent
=
{
}
;
TaggedParserAtomIndex
functionAtom
;
FunctionFlags
functionFlags
=
{
}
;
uint16_t
nargs
=
0
;
mozilla
:
:
Maybe
<
ScopeIndex
>
lazyFunctionEnclosingScopeIndex_
;
bool
isStandaloneFunction
:
1
;
bool
wasFunctionEmitted
:
1
;
bool
allowRelazify
:
1
;
ScriptStencil
(
)
:
isStandaloneFunction
(
false
)
wasFunctionEmitted
(
false
)
allowRelazify
(
false
)
{
}
bool
isFunction
(
)
const
{
bool
result
=
functionFlags
.
toRaw
(
)
!
=
0x0000
;
MOZ_ASSERT_IF
(
result
functionFlags
.
isAsmJSNative
(
)
|
|
functionFlags
.
hasBaseScript
(
)
)
;
return
result
;
}
bool
isModule
(
)
const
{
bool
result
=
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
IsModule
)
;
MOZ_ASSERT_IF
(
result
!
isFunction
(
)
)
;
return
result
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
DumpTaggedParserAtomIndex
(
js
:
:
JSONPrinter
&
json
TaggedParserAtomIndex
taggedIndex
CompilationStencil
*
compilationStencil
)
;
#
endif
}
}
#
endif
