#
ifndef
frontend_Stencil_h
#
define
frontend_Stencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
namespace
js
{
class
LifoAlloc
;
class
JSONPrinter
;
class
RegExpObject
;
namespace
frontend
{
struct
CompilationInput
;
struct
CompilationStencil
;
struct
CompilationAtomCache
;
struct
CompilationGCOutput
;
struct
CompilationStencilMerger
;
class
RegExpStencil
;
class
BigIntStencil
;
class
StencilXDR
;
using
BaseParserScopeData
=
AbstractBaseScopeData
<
TaggedParserAtomIndex
>
;
using
ParserBindingName
=
AbstractBindingName
<
TaggedParserAtomIndex
>
;
template
<
typename
Scope
>
using
ParserScopeSlotInfo
=
typename
Scope
:
:
SlotInfo
;
using
ParserGlobalScopeSlotInfo
=
ParserScopeSlotInfo
<
GlobalScope
>
;
using
ParserEvalScopeSlotInfo
=
ParserScopeSlotInfo
<
EvalScope
>
;
using
ParserLexicalScopeSlotInfo
=
ParserScopeSlotInfo
<
LexicalScope
>
;
using
ParserClassBodyScopeSlotInfo
=
ParserScopeSlotInfo
<
ClassBodyScope
>
;
using
ParserFunctionScopeSlotInfo
=
ParserScopeSlotInfo
<
FunctionScope
>
;
using
ParserModuleScopeSlotInfo
=
ParserScopeSlotInfo
<
ModuleScope
>
;
using
ParserVarScopeSlotInfo
=
ParserScopeSlotInfo
<
VarScope
>
;
using
ParserBindingIter
=
AbstractBindingIter
<
TaggedParserAtomIndex
>
;
using
ParserPositionalFormalParameterIter
=
AbstractPositionalFormalParameterIter
<
TaggedParserAtomIndex
>
;
using
RegExpIndex
=
TypedIndex
<
RegExpStencil
>
;
using
BigIntIndex
=
TypedIndex
<
BigIntStencil
>
;
using
ObjLiteralIndex
=
TypedIndex
<
ObjLiteralStencil
>
;
class
CompilationGCThingType
{
}
;
using
CompilationGCThingIndex
=
TypedIndex
<
CompilationGCThingType
>
;
class
RegExpStencil
{
friend
class
StencilXDR
;
TaggedParserAtomIndex
atom_
;
uint32_t
flags_
;
friend
struct
CompilationStencilMerger
;
public
:
RegExpStencil
(
)
=
default
;
RegExpStencil
(
TaggedParserAtomIndex
atom
JS
:
:
RegExpFlags
flags
)
:
atom_
(
atom
)
flags_
(
flags
.
value
(
)
)
{
}
JS
:
:
RegExpFlags
flags
(
)
const
{
return
JS
:
:
RegExpFlags
(
flags_
)
;
}
RegExpObject
*
createRegExp
(
JSContext
*
cx
const
CompilationAtomCache
&
atomCache
)
const
;
RegExpObject
*
createRegExpAndEnsureAtom
(
JSContext
*
cx
FrontendContext
*
fc
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
#
endif
}
;
class
BigIntStencil
{
friend
class
StencilXDR
;
mozilla
:
:
Variant
<
mozilla
:
:
Span
<
char16_t
>
int64_t
>
bigInt_
{
int64_t
{
}
}
;
mozilla
:
:
Span
<
char16_t
>
&
source
(
)
{
if
(
bigInt_
.
is
<
int64_t
>
(
)
)
{
bigInt_
=
mozilla
:
:
AsVariant
(
mozilla
:
:
Span
<
char16_t
>
{
}
)
;
}
return
bigInt_
.
as
<
mozilla
:
:
Span
<
char16_t
>
>
(
)
;
}
const
mozilla
:
:
Span
<
char16_t
>
&
source
(
)
const
{
return
bigInt_
.
as
<
mozilla
:
:
Span
<
char16_t
>
>
(
)
;
}
[
[
nodiscard
]
]
bool
initFromChars
(
FrontendContext
*
fc
LifoAlloc
&
alloc
mozilla
:
:
Span
<
const
char16_t
>
buf
)
;
public
:
BigIntStencil
(
)
=
default
;
[
[
nodiscard
]
]
bool
init
(
FrontendContext
*
fc
LifoAlloc
&
alloc
mozilla
:
:
Span
<
const
char16_t
>
buf
)
;
[
[
nodiscard
]
]
bool
init
(
FrontendContext
*
fc
LifoAlloc
&
alloc
const
BigIntStencil
&
other
)
;
BigInt
*
createBigInt
(
JSContext
*
cx
)
const
;
bool
isZero
(
)
const
;
#
ifdef
DEBUG
bool
isContainedIn
(
const
LifoAlloc
&
alloc
)
const
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
)
const
;
void
dumpCharsNoQuote
(
GenericPrinter
&
out
)
const
;
#
endif
}
;
class
ScopeStencil
{
friend
class
StencilXDR
;
friend
class
InputScope
;
friend
class
AbstractBindingIter
<
frontend
:
:
TaggedParserAtomIndex
>
;
friend
struct
CompilationStencil
;
friend
struct
CompilationStencilMerger
;
ScopeIndex
enclosing_
;
uint32_t
firstFrameSlot_
=
UINT32_MAX
;
uint32_t
numEnvironmentSlots_
;
ScriptIndex
functionIndex_
;
ScopeKind
kind_
{
UINT8_MAX
}
;
static
constexpr
uint8_t
HasEnclosing
=
1
<
<
0
;
static
constexpr
uint8_t
HasEnvironmentShape
=
1
<
<
1
;
static
constexpr
uint8_t
IsArrow
=
1
<
<
2
;
uint8_t
flags_
=
0
;
uint16_t
padding_
=
0
;
public
:
ScopeStencil
(
)
=
default
;
ScopeStencil
(
ScopeKind
kind
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots
mozilla
:
:
Maybe
<
ScriptIndex
>
functionIndex
=
mozilla
:
:
Nothing
(
)
bool
isArrow
=
false
)
:
enclosing_
(
enclosing
.
valueOr
(
ScopeIndex
(
0
)
)
)
firstFrameSlot_
(
firstFrameSlot
)
numEnvironmentSlots_
(
numEnvironmentSlots
.
valueOr
(
0
)
)
functionIndex_
(
functionIndex
.
valueOr
(
ScriptIndex
(
0
)
)
)
kind_
(
kind
)
flags_
(
(
enclosing
.
isSome
(
)
?
HasEnclosing
:
0
)
|
(
numEnvironmentSlots
.
isSome
(
)
?
HasEnvironmentShape
:
0
)
|
(
isArrow
?
IsArrow
:
0
)
)
{
MOZ_ASSERT
(
(
kind
=
=
ScopeKind
:
:
Function
)
=
=
functionIndex
.
isSome
(
)
)
;
(
void
)
padding_
;
}
private
:
template
<
typename
.
.
.
Args
>
static
bool
appendScopeStencilAndData
(
FrontendContext
*
fc
CompilationState
&
compilationState
BaseParserScopeData
*
data
ScopeIndex
*
indexOut
Args
&
&
.
.
.
args
)
;
public
:
static
bool
createForFunctionScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
FunctionScope
:
:
ParserData
*
dataArg
bool
hasParameterExprs
bool
needsEnvironment
ScriptIndex
functionIndex
bool
isArrow
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForLexicalScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ScopeKind
kind
LexicalScope
:
:
ParserData
*
dataArg
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForClassBodyScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ScopeKind
kind
ClassBodyScope
:
:
ParserData
*
dataArg
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForVarScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ScopeKind
kind
VarScope
:
:
ParserData
*
dataArg
uint32_t
firstFrameSlot
bool
needsEnvironment
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForGlobalScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ScopeKind
kind
GlobalScope
:
:
ParserData
*
dataArg
ScopeIndex
*
index
)
;
static
bool
createForEvalScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ScopeKind
kind
EvalScope
:
:
ParserData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForModuleScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
ModuleScope
:
:
ParserData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForWithScope
(
FrontendContext
*
fc
CompilationState
&
compilationState
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
AbstractScopePtr
enclosing
(
CompilationState
&
compilationState
)
const
;
js
:
:
Scope
*
enclosingExistingScope
(
const
CompilationInput
&
input
const
CompilationGCOutput
&
gcOutput
)
const
;
private
:
bool
hasEnclosing
(
)
const
{
return
flags_
&
HasEnclosing
;
}
ScopeIndex
enclosing
(
)
const
{
MOZ_ASSERT
(
hasEnclosing
(
)
)
;
return
enclosing_
;
}
uint32_t
firstFrameSlot
(
)
const
{
return
firstFrameSlot_
;
}
bool
hasEnvironmentShape
(
)
const
{
return
flags_
&
HasEnvironmentShape
;
}
uint32_t
numEnvironmentSlots
(
)
const
{
MOZ_ASSERT
(
hasEnvironmentShape
(
)
)
;
return
numEnvironmentSlots_
;
}
bool
isFunction
(
)
const
{
return
kind_
=
=
ScopeKind
:
:
Function
;
}
ScriptIndex
functionIndex
(
)
const
{
return
functionIndex_
;
}
public
:
ScopeKind
kind
(
)
const
{
return
kind_
;
}
bool
hasEnvironment
(
)
const
{
return
Scope
:
:
hasEnvironment
(
kind
(
)
hasEnvironmentShape
(
)
)
;
}
bool
isArrow
(
)
const
{
return
flags_
&
IsArrow
;
}
Scope
*
createScope
(
JSContext
*
cx
CompilationInput
&
input
CompilationGCOutput
&
gcOutput
BaseParserScopeData
*
baseScopeData
)
const
;
Scope
*
createScope
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
Handle
<
Scope
*
>
enclosingScope
BaseParserScopeData
*
baseScopeData
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
BaseParserScopeData
*
baseScopeData
const
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
BaseParserScopeData
*
baseScopeData
const
CompilationStencil
*
stencil
)
const
;
#
endif
private
:
template
<
typename
SpecificScopeType
>
UniquePtr
<
typename
SpecificScopeType
:
:
RuntimeData
>
createSpecificScopeData
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
BaseParserScopeData
*
baseData
)
const
;
template
<
typename
SpecificEnvironmentType
>
[
[
nodiscard
]
]
bool
createSpecificShape
(
JSContext
*
cx
ScopeKind
kind
BaseScopeData
*
scopeData
MutableHandle
<
SharedShape
*
>
shape
)
const
;
template
<
typename
SpecificScopeType
typename
SpecificEnvironmentType
>
Scope
*
createSpecificScope
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
Handle
<
Scope
*
>
enclosingScope
BaseParserScopeData
*
baseData
)
const
;
template
<
typename
ScopeT
>
static
constexpr
bool
matchScopeKind
(
ScopeKind
kind
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
Function
:
{
return
std
:
:
is_same_v
<
ScopeT
FunctionScope
>
;
}
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
{
return
std
:
:
is_same_v
<
ScopeT
LexicalScope
>
;
}
case
ScopeKind
:
:
ClassBody
:
{
return
std
:
:
is_same_v
<
ScopeT
ClassBodyScope
>
;
}
case
ScopeKind
:
:
FunctionBodyVar
:
{
return
std
:
:
is_same_v
<
ScopeT
VarScope
>
;
}
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
{
return
std
:
:
is_same_v
<
ScopeT
GlobalScope
>
;
}
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
{
return
std
:
:
is_same_v
<
ScopeT
EvalScope
>
;
}
case
ScopeKind
:
:
Module
:
{
return
std
:
:
is_same_v
<
ScopeT
ModuleScope
>
;
}
case
ScopeKind
:
:
With
:
{
return
std
:
:
is_same_v
<
ScopeT
WithScope
>
;
}
case
ScopeKind
:
:
WasmFunction
:
case
ScopeKind
:
:
WasmInstance
:
{
return
false
;
}
}
return
false
;
}
}
;
class
StencilModuleImportAttribute
{
public
:
TaggedParserAtomIndex
key
;
TaggedParserAtomIndex
value
;
StencilModuleImportAttribute
(
)
=
default
;
StencilModuleImportAttribute
(
TaggedParserAtomIndex
key
TaggedParserAtomIndex
value
)
:
key
(
key
)
value
(
value
)
{
}
}
;
class
StencilModuleRequest
{
public
:
TaggedParserAtomIndex
specifier
;
TaggedParserAtomIndex
firstUnsupportedAttributeKey
;
using
ImportAttributeVector
=
Vector
<
StencilModuleImportAttribute
0
js
:
:
SystemAllocPolicy
>
;
ImportAttributeVector
attributes
;
StencilModuleRequest
(
)
=
default
;
explicit
StencilModuleRequest
(
TaggedParserAtomIndex
specifier
)
:
specifier
(
specifier
)
{
MOZ_ASSERT
(
specifier
)
;
}
StencilModuleRequest
(
const
StencilModuleRequest
&
other
)
:
specifier
(
other
.
specifier
)
firstUnsupportedAttributeKey
(
other
.
firstUnsupportedAttributeKey
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
attributes
.
appendAll
(
other
.
attributes
)
)
{
oomUnsafe
.
crash
(
"
StencilModuleRequest
:
:
StencilModuleRequest
"
)
;
}
}
StencilModuleRequest
(
StencilModuleRequest
&
&
other
)
noexcept
:
specifier
(
other
.
specifier
)
firstUnsupportedAttributeKey
(
other
.
firstUnsupportedAttributeKey
)
attributes
(
std
:
:
move
(
other
.
attributes
)
)
{
}
StencilModuleRequest
&
operator
=
(
StencilModuleRequest
&
other
)
{
specifier
=
other
.
specifier
;
firstUnsupportedAttributeKey
=
other
.
firstUnsupportedAttributeKey
;
attributes
=
std
:
:
move
(
other
.
attributes
)
;
return
*
this
;
}
StencilModuleRequest
&
operator
=
(
StencilModuleRequest
&
&
other
)
noexcept
{
specifier
=
other
.
specifier
;
firstUnsupportedAttributeKey
=
other
.
firstUnsupportedAttributeKey
;
attributes
=
std
:
:
move
(
other
.
attributes
)
;
return
*
this
;
}
}
;
class
MaybeModuleRequestIndex
{
static
constexpr
uint32_t
NOTHING
=
UINT32_MAX
;
uint32_t
bits
=
NOTHING
;
public
:
MaybeModuleRequestIndex
(
)
=
default
;
explicit
MaybeModuleRequestIndex
(
uint32_t
index
)
:
bits
(
index
)
{
MOZ_ASSERT
(
isSome
(
)
)
;
}
MaybeModuleRequestIndex
(
const
MaybeModuleRequestIndex
&
other
)
=
default
;
MaybeModuleRequestIndex
&
operator
=
(
const
MaybeModuleRequestIndex
&
other
)
=
default
;
bool
isNothing
(
)
const
{
return
bits
=
=
NOTHING
;
}
bool
isSome
(
)
const
{
return
!
isNothing
(
)
;
}
explicit
operator
bool
(
)
const
{
return
isSome
(
)
;
}
uint32_t
value
(
)
const
{
MOZ_ASSERT
(
isSome
(
)
)
;
return
bits
;
}
uint32_t
*
operator
&
(
)
{
return
&
bits
;
}
}
;
class
StencilModuleEntry
{
public
:
MaybeModuleRequestIndex
moduleRequest
;
TaggedParserAtomIndex
localName
;
TaggedParserAtomIndex
importName
;
TaggedParserAtomIndex
exportName
;
uint32_t
lineno
=
0
;
JS
:
:
ColumnNumberOneOrigin
column
;
private
:
StencilModuleEntry
(
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
:
lineno
(
lineno
)
column
(
column
)
{
}
public
:
StencilModuleEntry
(
)
=
default
;
StencilModuleEntry
(
const
StencilModuleEntry
&
other
)
:
moduleRequest
(
other
.
moduleRequest
)
localName
(
other
.
localName
)
importName
(
other
.
importName
)
exportName
(
other
.
exportName
)
lineno
(
other
.
lineno
)
column
(
other
.
column
)
{
}
StencilModuleEntry
(
StencilModuleEntry
&
&
other
)
noexcept
:
moduleRequest
(
other
.
moduleRequest
)
localName
(
other
.
localName
)
importName
(
other
.
importName
)
exportName
(
other
.
exportName
)
lineno
(
other
.
lineno
)
column
(
other
.
column
)
{
}
StencilModuleEntry
&
operator
=
(
StencilModuleEntry
&
other
)
{
moduleRequest
=
other
.
moduleRequest
;
localName
=
other
.
localName
;
importName
=
other
.
importName
;
exportName
=
other
.
exportName
;
lineno
=
other
.
lineno
;
column
=
other
.
column
;
return
*
this
;
}
StencilModuleEntry
&
operator
=
(
StencilModuleEntry
&
&
other
)
noexcept
{
moduleRequest
=
other
.
moduleRequest
;
localName
=
other
.
localName
;
importName
=
other
.
importName
;
exportName
=
other
.
exportName
;
lineno
=
other
.
lineno
;
column
=
other
.
column
;
return
*
this
;
}
static
StencilModuleEntry
requestedModule
(
MaybeModuleRequestIndex
moduleRequest
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
moduleRequest
;
return
entry
;
}
static
StencilModuleEntry
importEntry
(
MaybeModuleRequestIndex
moduleRequest
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
importName
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
MOZ_ASSERT
(
localName
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
moduleRequest
;
entry
.
localName
=
localName
;
entry
.
importName
=
importName
;
return
entry
;
}
static
StencilModuleEntry
importNamespaceEntry
(
MaybeModuleRequestIndex
moduleRequest
TaggedParserAtomIndex
localName
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
MOZ_ASSERT
(
localName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
moduleRequest
;
entry
.
localName
=
localName
;
return
entry
;
}
static
StencilModuleEntry
exportAsEntry
(
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
exportName
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
localName
&
&
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
localName
=
localName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportFromEntry
(
MaybeModuleRequestIndex
moduleRequest
TaggedParserAtomIndex
importName
TaggedParserAtomIndex
exportName
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
MOZ_ASSERT
(
importName
&
&
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
moduleRequest
;
entry
.
importName
=
importName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportNamespaceFromEntry
(
MaybeModuleRequestIndex
moduleRequest
TaggedParserAtomIndex
exportName
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
MOZ_ASSERT
(
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
MaybeModuleRequestIndex
(
moduleRequest
)
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportBatchFromEntry
(
MaybeModuleRequestIndex
moduleRequest
uint32_t
lineno
JS
:
:
ColumnNumberOneOrigin
column
)
{
MOZ_ASSERT
(
moduleRequest
.
isSome
(
)
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
moduleRequest
=
MaybeModuleRequestIndex
(
moduleRequest
)
;
return
entry
;
}
}
;
class
StencilModuleMetadata
:
public
js
:
:
AtomicRefCounted
<
StencilModuleMetadata
>
{
public
:
using
RequestVector
=
Vector
<
StencilModuleRequest
0
js
:
:
SystemAllocPolicy
>
;
using
EntryVector
=
Vector
<
StencilModuleEntry
0
js
:
:
SystemAllocPolicy
>
;
RequestVector
moduleRequests
;
EntryVector
requestedModules
;
EntryVector
importEntries
;
EntryVector
localExportEntries
;
EntryVector
indirectExportEntries
;
EntryVector
starExportEntries
;
FunctionDeclarationVector
functionDecls
;
bool
isAsync
=
false
;
StencilModuleMetadata
(
)
=
default
;
bool
initModule
(
JSContext
*
cx
FrontendContext
*
fc
CompilationAtomCache
&
atomCache
JS
:
:
Handle
<
ModuleObject
*
>
module
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
requestedModules
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
importEntries
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
localExportEntries
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
indirectExportEntries
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
starExportEntries
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
functionDecls
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
#
endif
private
:
bool
createModuleRequestObjects
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
MutableHandle
<
ModuleRequestVector
>
output
)
const
;
bool
createRequestedModules
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
Handle
<
ModuleRequestVector
>
moduleRequests
MutableHandle
<
RequestedModuleVector
>
output
)
const
;
bool
createImportEntries
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
Handle
<
ModuleRequestVector
>
moduleRequests
MutableHandle
<
ImportEntryVector
>
output
)
const
;
bool
createExportEntries
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
Handle
<
ModuleRequestVector
>
moduleRequests
const
EntryVector
&
input
MutableHandle
<
ExportEntryVector
>
output
)
const
;
ModuleRequestObject
*
createModuleRequestObject
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
const
StencilModuleRequest
&
request
)
const
;
}
;
class
EmptyGlobalScopeType
{
}
;
class
TaggedScriptThingIndex
{
uint32_t
data_
;
static
constexpr
size_t
IndexBit
=
TaggedParserAtomIndex
:
:
IndexBit
;
static
constexpr
size_t
IndexMask
=
TaggedParserAtomIndex
:
:
IndexMask
;
static
constexpr
size_t
TagShift
=
TaggedParserAtomIndex
:
:
TagShift
;
static
constexpr
size_t
TagBit
=
TaggedParserAtomIndex
:
:
TagBit
;
static
constexpr
size_t
TagMask
=
TaggedParserAtomIndex
:
:
TagMask
;
public
:
enum
class
Kind
:
uint32_t
{
Null
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
Null
)
ParserAtomIndex
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
ParserAtomIndex
)
WellKnown
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
WellKnown
)
BigInt
ObjLiteral
RegExp
Scope
Function
EmptyGlobalScope
}
;
private
:
static
constexpr
uint32_t
NullTag
=
uint32_t
(
Kind
:
:
Null
)
<
<
TagShift
;
static_assert
(
NullTag
=
=
TaggedParserAtomIndex
:
:
NullTag
)
;
static
constexpr
uint32_t
ParserAtomIndexTag
=
uint32_t
(
Kind
:
:
ParserAtomIndex
)
<
<
TagShift
;
static_assert
(
ParserAtomIndexTag
=
=
TaggedParserAtomIndex
:
:
ParserAtomIndexTag
)
;
static
constexpr
uint32_t
WellKnownTag
=
uint32_t
(
Kind
:
:
WellKnown
)
<
<
TagShift
;
static_assert
(
WellKnownTag
=
=
TaggedParserAtomIndex
:
:
WellKnownTag
)
;
static
constexpr
uint32_t
BigIntTag
=
uint32_t
(
Kind
:
:
BigInt
)
<
<
TagShift
;
static
constexpr
uint32_t
ObjLiteralTag
=
uint32_t
(
Kind
:
:
ObjLiteral
)
<
<
TagShift
;
static
constexpr
uint32_t
RegExpTag
=
uint32_t
(
Kind
:
:
RegExp
)
<
<
TagShift
;
static
constexpr
uint32_t
ScopeTag
=
uint32_t
(
Kind
:
:
Scope
)
<
<
TagShift
;
static
constexpr
uint32_t
FunctionTag
=
uint32_t
(
Kind
:
:
Function
)
<
<
TagShift
;
static
constexpr
uint32_t
EmptyGlobalScopeTag
=
uint32_t
(
Kind
:
:
EmptyGlobalScope
)
<
<
TagShift
;
public
:
static
constexpr
uint32_t
IndexLimit
=
Bit
(
IndexBit
)
;
TaggedScriptThingIndex
(
)
:
data_
(
NullTag
)
{
}
explicit
TaggedScriptThingIndex
(
TaggedParserAtomIndex
index
)
:
data_
(
index
.
rawData
(
)
)
{
}
explicit
TaggedScriptThingIndex
(
BigIntIndex
index
)
:
data_
(
uint32_t
(
index
)
|
BigIntTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ObjLiteralIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ObjLiteralTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
RegExpIndex
index
)
:
data_
(
uint32_t
(
index
)
|
RegExpTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ScopeIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ScopeTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ScriptIndex
index
)
:
data_
(
uint32_t
(
index
)
|
FunctionTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
EmptyGlobalScopeType
t
)
:
data_
(
EmptyGlobalScopeTag
)
{
}
bool
isAtom
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ParserAtomIndexTag
|
|
(
data_
&
TagMask
)
=
=
WellKnownTag
;
}
bool
isNull
(
)
const
{
bool
result
=
!
data_
;
MOZ_ASSERT_IF
(
result
(
data_
&
TagMask
)
=
=
NullTag
)
;
return
result
;
}
bool
isBigInt
(
)
const
{
return
(
data_
&
TagMask
)
=
=
BigIntTag
;
}
bool
isObjLiteral
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ObjLiteralTag
;
}
bool
isRegExp
(
)
const
{
return
(
data_
&
TagMask
)
=
=
RegExpTag
;
}
bool
isScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ScopeTag
;
}
bool
isFunction
(
)
const
{
return
(
data_
&
TagMask
)
=
=
FunctionTag
;
}
bool
isEmptyGlobalScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
EmptyGlobalScopeTag
;
}
TaggedParserAtomIndex
toAtom
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
)
;
return
TaggedParserAtomIndex
:
:
fromRaw
(
data_
)
;
}
BigIntIndex
toBigInt
(
)
const
{
return
BigIntIndex
(
data_
&
IndexMask
)
;
}
ObjLiteralIndex
toObjLiteral
(
)
const
{
return
ObjLiteralIndex
(
data_
&
IndexMask
)
;
}
RegExpIndex
toRegExp
(
)
const
{
return
RegExpIndex
(
data_
&
IndexMask
)
;
}
ScopeIndex
toScope
(
)
const
{
return
ScopeIndex
(
data_
&
IndexMask
)
;
}
ScriptIndex
toFunction
(
)
const
{
return
ScriptIndex
(
data_
&
IndexMask
)
;
}
TaggedParserAtomIndex
toAtomOrNull
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
|
|
isNull
(
)
)
;
return
TaggedParserAtomIndex
:
:
fromRaw
(
data_
)
;
}
uint32_t
*
rawDataRef
(
)
{
return
&
data_
;
}
uint32_t
rawData
(
)
const
{
return
data_
;
}
Kind
tag
(
)
const
{
return
Kind
(
(
data_
&
TagMask
)
>
>
TagShift
)
;
}
bool
operator
=
=
(
const
TaggedScriptThingIndex
&
rhs
)
const
{
return
data_
=
=
rhs
.
data_
;
}
}
;
class
ScriptStencil
{
friend
struct
CompilationStencilMerger
;
public
:
CompilationGCThingIndex
gcThingsOffset
;
uint32_t
gcThingsLength
=
0
;
TaggedParserAtomIndex
functionAtom
;
TaggedScriptThingIndex
enclosingScopeOrCanonicalName
;
FunctionFlags
functionFlags
=
{
}
;
static
constexpr
uint16_t
WasEmittedByEnclosingScriptFlag
=
1
<
<
0
;
static
constexpr
uint16_t
AllowRelazifyFlag
=
1
<
<
1
;
static
constexpr
uint16_t
HasSharedDataFlag
=
1
<
<
2
;
static
constexpr
uint16_t
HasLazyFunctionEnclosingScopeIndexFlag
=
1
<
<
3
;
static
constexpr
uint16_t
HasSelfHostedCanonicalName
=
1
<
<
4
;
uint16_t
flags_
=
0
;
ScriptStencil
(
)
=
default
;
bool
isFunction
(
)
const
{
bool
result
=
functionFlags
.
toRaw
(
)
!
=
0x0000
;
MOZ_ASSERT_IF
(
result
functionFlags
.
isAsmJSNative
(
)
|
|
functionFlags
.
hasBaseScript
(
)
)
;
return
result
;
}
bool
hasGCThings
(
)
const
{
return
gcThingsLength
;
}
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
gcthings
(
const
CompilationStencil
&
stencil
)
const
;
bool
wasEmittedByEnclosingScript
(
)
const
{
return
flags_
&
WasEmittedByEnclosingScriptFlag
;
}
void
setWasEmittedByEnclosingScript
(
)
{
flags_
|
=
WasEmittedByEnclosingScriptFlag
;
}
bool
allowRelazify
(
)
const
{
return
flags_
&
AllowRelazifyFlag
;
}
void
setAllowRelazify
(
)
{
flags_
|
=
AllowRelazifyFlag
;
}
bool
isGhost
(
)
const
{
return
functionFlags
.
isGhost
(
)
;
}
void
setIsGhost
(
)
{
functionFlags
.
setIsGhost
(
)
;
}
bool
hasSharedData
(
)
const
{
return
flags_
&
HasSharedDataFlag
;
}
void
setHasSharedData
(
)
{
flags_
|
=
HasSharedDataFlag
;
}
bool
hasLazyFunctionEnclosingScopeIndex
(
)
const
{
return
flags_
&
HasLazyFunctionEnclosingScopeIndexFlag
;
}
bool
hasSelfHostedCanonicalName
(
)
const
{
return
flags_
&
HasSelfHostedCanonicalName
;
}
private
:
void
setHasLazyFunctionEnclosingScopeIndex
(
)
{
flags_
|
=
HasLazyFunctionEnclosingScopeIndexFlag
;
}
void
setHasSelfHostedCanonicalName
(
)
{
flags_
|
=
HasSelfHostedCanonicalName
;
}
public
:
void
setLazyFunctionEnclosingScopeIndex
(
ScopeIndex
index
)
{
MOZ_ASSERT
(
enclosingScopeOrCanonicalName
.
isNull
(
)
)
;
enclosingScopeOrCanonicalName
=
TaggedScriptThingIndex
(
index
)
;
setHasLazyFunctionEnclosingScopeIndex
(
)
;
}
void
resetHasLazyFunctionEnclosingScopeIndexAfterStencilMerge
(
)
{
flags_
&
=
~
HasLazyFunctionEnclosingScopeIndexFlag
;
enclosingScopeOrCanonicalName
=
TaggedScriptThingIndex
(
)
;
}
ScopeIndex
lazyFunctionEnclosingScopeIndex
(
)
const
{
MOZ_ASSERT
(
hasLazyFunctionEnclosingScopeIndex
(
)
)
;
return
enclosingScopeOrCanonicalName
.
toScope
(
)
;
}
void
setSelfHostedCanonicalName
(
TaggedParserAtomIndex
name
)
{
MOZ_ASSERT
(
enclosingScopeOrCanonicalName
.
isNull
(
)
)
;
enclosingScopeOrCanonicalName
=
TaggedScriptThingIndex
(
name
)
;
setHasSelfHostedCanonicalName
(
)
;
}
TaggedParserAtomIndex
selfHostedCanonicalName
(
)
const
{
MOZ_ASSERT
(
hasSelfHostedCanonicalName
(
)
)
;
return
enclosingScopeOrCanonicalName
.
toAtom
(
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
CompilationStencil
*
stencil
)
const
;
#
endif
}
;
class
ScriptStencilExtra
{
public
:
ImmutableScriptFlags
immutableFlags
;
SourceExtent
extent
;
uint32_t
memberInitializers_
=
0
;
uint16_t
nargs
=
0
;
uint16_t
padding_
=
0
;
ScriptStencilExtra
(
)
=
default
;
RO_IMMUTABLE_SCRIPT_FLAGS
(
immutableFlags
)
void
setMemberInitializers
(
MemberInitializers
member
)
{
MOZ_ASSERT
(
useMemberInitializers
(
)
)
;
memberInitializers_
=
member
.
serialize
(
)
;
}
MemberInitializers
memberInitializers
(
)
const
{
MOZ_ASSERT
(
useMemberInitializers
(
)
)
;
return
MemberInitializers
:
:
deserialize
(
memberInitializers_
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
)
const
;
void
dumpFields
(
JSONPrinter
&
json
)
const
;
#
endif
}
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
DumpTaggedParserAtomIndex
(
js
:
:
JSONPrinter
&
json
TaggedParserAtomIndex
taggedIndex
const
CompilationStencil
*
stencil
)
;
void
DumpTaggedParserAtomIndexNoQuote
(
GenericPrinter
&
out
TaggedParserAtomIndex
taggedIndex
const
CompilationStencil
*
stencil
)
;
#
endif
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
DumpImmutableScriptFlags
(
js
:
:
JSONPrinter
&
json
ImmutableScriptFlags
immutableFlags
)
;
void
DumpFunctionFlagsItems
(
js
:
:
JSONPrinter
&
json
FunctionFlags
functionFlags
)
;
#
endif
}
#
endif
