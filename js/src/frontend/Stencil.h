#
ifndef
frontend_Stencil_h
#
define
frontend_Stencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
js
:
:
frontend
{
struct
CompilationInfo
;
class
FunctionBox
;
enum
class
FunctionSyntaxKind
:
uint8_t
;
class
FunctionIndexType
;
class
FunctionIndex
:
public
TypedIndex
<
FunctionIndexType
>
{
using
Base
=
TypedIndex
<
FunctionIndexType
>
;
using
Base
:
:
Base
;
}
;
struct
LazyScriptCreationData
{
frontend
:
:
AtomVector
closedOverBindings
;
Vector
<
FunctionIndex
>
innerFunctionIndexes
;
bool
forceStrict
=
false
;
bool
strict
=
false
;
explicit
LazyScriptCreationData
(
JSContext
*
cx
)
:
innerFunctionIndexes
(
cx
)
{
}
bool
init
(
JSContext
*
cx
const
frontend
:
:
AtomVector
&
COB
Vector
<
FunctionIndex
>
&
&
innerIndexes
bool
isForceStrict
bool
isStrict
)
{
mozilla
:
:
CheckedUint32
ngcthings
=
mozilla
:
:
CheckedUint32
(
COB
.
length
(
)
)
+
mozilla
:
:
CheckedUint32
(
innerIndexes
.
length
(
)
)
;
if
(
!
ngcthings
.
isValid
(
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
forceStrict
=
isForceStrict
;
strict
=
isStrict
;
innerFunctionIndexes
=
std
:
:
move
(
innerIndexes
)
;
if
(
!
closedOverBindings
.
appendAll
(
COB
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
create
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
HandleFunction
function
FunctionBox
*
funbox
HandleScriptSourceObject
sourceObject
)
;
}
;
struct
FunctionCreationData
{
FunctionCreationData
(
HandleAtom
atom
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
isSelfHosting
=
false
bool
inFunctionBox
=
false
)
;
FunctionCreationData
(
const
FunctionCreationData
&
data
)
:
atom
(
data
.
atom
)
kind
(
data
.
kind
)
generatorKind
(
data
.
generatorKind
)
asyncKind
(
data
.
asyncKind
)
allocKind
(
data
.
allocKind
)
flags
(
data
.
flags
)
isSelfHosting
(
data
.
isSelfHosting
)
lazyScriptData
(
mozilla
:
:
Nothing
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
data
.
lazyScriptData
)
;
}
FunctionCreationData
(
FunctionCreationData
&
&
data
)
=
default
;
JSAtom
*
atom
=
nullptr
;
FunctionSyntaxKind
kind
;
GeneratorKind
generatorKind
=
GeneratorKind
:
:
NotGenerator
;
FunctionAsyncKind
asyncKind
=
FunctionAsyncKind
:
:
SyncFunction
;
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
;
FunctionFlags
flags
=
{
}
;
bool
isSelfHosting
=
false
;
mozilla
:
:
Maybe
<
LazyScriptCreationData
>
lazyScriptData
;
HandleAtom
getAtom
(
JSContext
*
cx
)
const
;
void
trace
(
JSTracer
*
trc
)
{
TraceNullableRoot
(
trc
&
atom
"
FunctionCreationData
atom
"
)
;
}
}
;
class
RegExpCreationData
{
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
buf_
;
size_t
length_
=
0
;
JS
:
:
RegExpFlags
flags_
;
public
:
RegExpCreationData
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
mozilla
:
:
Range
<
const
char16_t
>
range
JS
:
:
RegExpFlags
flags
)
{
length_
=
range
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
range
.
begin
(
)
.
get
(
)
range
.
length
(
)
)
;
if
(
!
buf_
)
{
return
false
;
}
flags_
=
flags
;
return
true
;
}
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
JSAtom
*
pattern
JS
:
:
RegExpFlags
flags
)
;
RegExpObject
*
createRegExp
(
JSContext
*
cx
)
const
;
}
;
using
RegExpIndex
=
TypedIndex
<
RegExpCreationData
>
;
class
BigIntCreationData
{
UniqueTwoByteChars
buf_
;
size_t
length_
=
0
;
public
:
BigIntCreationData
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
const
Vector
<
char16_t
32
>
&
buf
)
{
#
ifdef
DEBUG
for
(
char16_t
c
:
buf
)
{
MOZ_ASSERT
(
c
!
=
'
_
'
)
;
}
#
endif
length_
=
buf
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
buf
.
begin
(
)
buf
.
length
(
)
)
;
return
buf_
!
=
nullptr
;
}
BigInt
*
createBigInt
(
JSContext
*
cx
)
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
ParseBigIntLiteral
(
cx
source
)
;
}
bool
isZero
(
)
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
BigIntLiteralIsZero
(
source
)
;
}
}
;
using
BigIntIndex
=
TypedIndex
<
BigIntCreationData
>
;
class
EnvironmentShapeCreationData
{
struct
CreateEnvShapeData
{
BindingIter
freshBi
;
const
JSClass
*
cls
;
uint32_t
nextEnvironmentSlot
;
uint32_t
baseShapeFlags
;
void
trace
(
JSTracer
*
trc
)
{
freshBi
.
trace
(
trc
)
;
}
}
;
struct
EmptyEnvShapeData
{
const
JSClass
*
cls
;
uint32_t
baseShapeFlags
;
void
trace
(
JSTracer
*
trc
)
{
}
;
}
;
mozilla
:
:
Variant
<
mozilla
:
:
Nothing
CreateEnvShapeData
EmptyEnvShapeData
>
data_
=
mozilla
:
:
AsVariant
(
mozilla
:
:
Nothing
(
)
)
;
public
:
explicit
operator
bool
(
)
const
{
return
!
data_
.
is
<
mozilla
:
:
Nothing
>
(
)
;
}
void
set
(
const
BindingIter
&
freshBi
const
JSClass
*
cls
uint32_t
nextEnvironmentSlot
uint32_t
baseShapeFlags
)
{
data_
=
mozilla
:
:
AsVariant
(
CreateEnvShapeData
{
freshBi
cls
nextEnvironmentSlot
baseShapeFlags
}
)
;
}
void
set
(
const
JSClass
*
cls
uint32_t
shapeFlags
)
{
data_
=
mozilla
:
:
AsVariant
(
EmptyEnvShapeData
{
cls
shapeFlags
}
)
;
}
MOZ_MUST_USE
bool
createShape
(
JSContext
*
cx
MutableHandleShape
shape
)
;
void
trace
(
JSTracer
*
trc
)
{
using
DataGCPolicy
=
JS
:
:
GCPolicy
<
decltype
(
data_
)
>
;
DataGCPolicy
:
:
trace
(
trc
&
data_
"
data_
"
)
;
}
}
;
class
ScopeCreationData
{
friend
class
js
:
:
AbstractScopePtr
;
friend
class
js
:
:
GCMarker
;
AbstractScopePtr
enclosing_
;
ScopeKind
kind_
;
EnvironmentShapeCreationData
environmentShape_
;
HeapPtr
<
Scope
*
>
scope_
=
{
}
;
frontend
:
:
FunctionBox
*
funbox_
=
nullptr
;
UniquePtr
<
BaseScopeData
>
data_
;
public
:
ScopeCreationData
(
JSContext
*
cx
ScopeKind
kind
Handle
<
AbstractScopePtr
>
enclosing
Handle
<
frontend
:
:
EnvironmentShapeCreationData
>
environmentShape
UniquePtr
<
BaseScopeData
>
data
=
{
}
frontend
:
:
FunctionBox
*
funbox
=
nullptr
)
:
enclosing_
(
enclosing
)
kind_
(
kind
)
environmentShape_
(
environmentShape
)
funbox_
(
funbox
)
data_
(
std
:
:
move
(
data
)
)
{
}
ScopeKind
kind
(
)
const
{
return
kind_
;
}
AbstractScopePtr
enclosing
(
)
{
return
enclosing_
;
}
bool
getOrCreateEnclosingScope
(
JSContext
*
cx
MutableHandleScope
scope
)
{
return
enclosing_
.
getOrCreateScope
(
cx
scope
)
;
}
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
Handle
<
FunctionScope
:
:
Data
*
>
dataArg
bool
hasParameterExprs
bool
needsEnvironment
frontend
:
:
FunctionBox
*
funbox
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
LexicalScope
:
:
Data
*
>
dataArg
uint32_t
firstFrameSlot
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
VarScope
:
:
Data
*
>
dataArg
uint32_t
firstFrameSlot
bool
needsEnvironment
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
GlobalScope
:
:
Data
*
>
dataArg
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
EvalScope
:
:
Data
*
>
dataArg
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
Handle
<
ModuleScope
:
:
Data
*
>
dataArg
HandleModuleObject
module
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
static
bool
create
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
Handle
<
AbstractScopePtr
>
enclosing
ScopeIndex
*
index
)
;
bool
hasEnvironment
(
)
const
{
return
Scope
:
:
hasEnvironment
(
kind
(
)
!
!
environmentShape_
)
;
}
bool
isArrow
(
)
const
;
JSFunction
*
canonicalFunction
(
)
const
;
bool
hasScope
(
)
const
{
return
scope_
!
=
nullptr
;
}
Scope
*
getScope
(
)
const
{
MOZ_ASSERT
(
hasScope
(
)
)
;
return
scope_
;
}
Scope
*
createScope
(
JSContext
*
cx
)
;
void
trace
(
JSTracer
*
trc
)
;
uint32_t
nextFrameSlot
(
)
const
;
private
:
template
<
typename
SpecificScopeType
>
typename
SpecificScopeType
:
:
Data
&
data
(
)
const
{
MOZ_ASSERT
(
data_
.
get
(
)
)
;
return
*
static_cast
<
typename
SpecificScopeType
:
:
Data
*
>
(
data_
.
get
(
)
)
;
}
template
<
typename
SpecificScopeType
>
UniquePtr
<
typename
SpecificScopeType
:
:
Data
>
releaseData
(
)
{
return
UniquePtr
<
typename
SpecificScopeType
:
:
Data
>
(
static_cast
<
typename
SpecificScopeType
:
:
Data
*
>
(
data_
.
release
(
)
)
)
;
}
template
<
typename
SpecificScopeType
>
Scope
*
createSpecificScope
(
JSContext
*
cx
)
;
template
<
typename
SpecificScopeType
>
uint32_t
nextFrameSlot
(
)
const
{
if
(
hasScope
(
)
)
{
return
getScope
(
)
-
>
template
as
<
SpecificScopeType
>
(
)
.
nextFrameSlot
(
)
;
}
return
data
<
SpecificScopeType
>
(
)
.
nextFrameSlot
;
}
}
;
class
EmptyGlobalScopeType
{
}
;
using
ScriptThingVariant
=
mozilla
:
:
Variant
<
BigIntIndex
ObjLiteralCreationData
RegExpIndex
ScopeIndex
FunctionIndex
EmptyGlobalScopeType
>
;
using
ScriptThingsVector
=
Vector
<
ScriptThingVariant
>
;
class
ScriptStencil
{
public
:
using
ImmutableFlags
=
ImmutableScriptFlagsEnum
;
public
:
js
:
:
UniquePtr
<
js
:
:
ImmutableScriptData
>
immutableScriptData
=
nullptr
;
uint32_t
natoms
=
0
;
uint32_t
ngcthings
=
0
;
ImmutableScriptFlags
immutableFlags
;
ScriptThingsVector
gcThings
;
mozilla
:
:
Maybe
<
FunctionIndex
>
functionIndex
;
mozilla
:
:
Maybe
<
FieldInitializers
>
fieldInitializers
;
ScriptStencil
(
JSContext
*
cx
)
:
gcThings
(
cx
)
{
}
bool
isFunction
(
)
const
{
return
immutableFlags
.
hasFlag
(
ImmutableFlags
:
:
IsFunction
)
;
}
virtual
bool
finishGCThings
(
JSContext
*
cx
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
output
)
const
=
0
;
virtual
void
initAtomMap
(
GCPtrAtom
*
atoms
)
const
=
0
;
virtual
void
finishInnerFunctions
(
)
const
=
0
;
}
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
frontend
:
:
ScopeCreationData
*
>
{
static
void
trace
(
JSTracer
*
trc
js
:
:
frontend
:
:
ScopeCreationData
*
*
data
const
char
*
name
)
{
(
*
data
)
-
>
trace
(
trc
)
;
}
}
;
}
#
endif
