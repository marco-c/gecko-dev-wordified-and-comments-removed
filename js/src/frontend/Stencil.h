#
ifndef
frontend_Stencil_h
#
define
frontend_Stencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
namespace
js
{
class
JSONPrinter
;
class
RegExpObject
;
namespace
frontend
{
struct
CompilationInfo
;
struct
CompilationAtomCache
;
struct
CompilationStencil
;
struct
CompilationGCOutput
;
class
RegExpStencil
;
class
BigIntStencil
;
class
StencilXDR
;
using
BaseParserScopeData
=
AbstractBaseScopeData
<
TaggedParserAtomIndex
>
;
using
ParserBindingName
=
AbstractBindingName
<
TaggedParserAtomIndex
>
;
template
<
typename
Scope
>
using
ParserScopeSlotInfo
=
typename
Scope
:
:
SlotInfo
;
using
ParserGlobalScopeSlotInfo
=
ParserScopeSlotInfo
<
GlobalScope
>
;
using
ParserEvalScopeSlotInfo
=
ParserScopeSlotInfo
<
EvalScope
>
;
using
ParserLexicalScopeSlotInfo
=
ParserScopeSlotInfo
<
LexicalScope
>
;
using
ParserFunctionScopeSlotInfo
=
ParserScopeSlotInfo
<
FunctionScope
>
;
using
ParserModuleScopeSlotInfo
=
ParserScopeSlotInfo
<
ModuleScope
>
;
using
ParserVarScopeSlotInfo
=
ParserScopeSlotInfo
<
VarScope
>
;
using
ParserBindingIter
=
AbstractBindingIter
<
TaggedParserAtomIndex
>
;
using
RegExpIndex
=
TypedIndex
<
RegExpStencil
>
;
using
BigIntIndex
=
TypedIndex
<
BigIntStencil
>
;
using
ObjLiteralIndex
=
TypedIndex
<
ObjLiteralStencil
>
;
class
CompilationGCThingType
{
}
;
using
CompilationGCThingIndex
=
TypedIndex
<
CompilationGCThingType
>
;
FunctionFlags
InitialFunctionFlags
(
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
isSelfHosting
=
false
bool
hasUnclonedName
=
false
)
;
class
RegExpStencil
{
friend
class
StencilXDR
;
TaggedParserAtomIndex
atom_
;
uint32_t
flags_
;
public
:
RegExpStencil
(
)
=
default
;
RegExpStencil
(
TaggedParserAtomIndex
atom
JS
:
:
RegExpFlags
flags
)
:
atom_
(
atom
)
flags_
(
flags
.
value
(
)
)
{
}
JS
:
:
RegExpFlags
flags
(
)
const
{
return
JS
:
:
RegExpFlags
(
flags_
)
;
}
RegExpObject
*
createRegExp
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
)
const
;
RegExpObject
*
createRegExpAndEnsureAtom
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
CompilationStencil
&
stencil
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
class
BigIntStencil
{
friend
class
StencilXDR
;
UniqueTwoByteChars
buf_
;
size_t
length_
=
0
;
public
:
BigIntStencil
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
const
Vector
<
char16_t
32
>
&
buf
)
{
#
ifdef
DEBUG
for
(
char16_t
c
:
buf
)
{
MOZ_ASSERT
(
c
!
=
'
_
'
)
;
}
#
endif
length_
=
buf
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
buf
.
begin
(
)
buf
.
length
(
)
)
;
return
buf_
!
=
nullptr
;
}
BigInt
*
createBigInt
(
JSContext
*
cx
)
const
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
ParseBigIntLiteral
(
cx
source
)
;
}
bool
isZero
(
)
const
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
BigIntLiteralIsZero
(
source
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
#
endif
}
;
class
ScopeStencil
{
friend
class
StencilXDR
;
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing_
;
ScopeKind
kind_
{
UINT8_MAX
}
;
uint32_t
firstFrameSlot_
=
UINT32_MAX
;
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots_
;
mozilla
:
:
Maybe
<
ScriptIndex
>
functionIndex_
;
bool
isArrow_
=
false
;
public
:
ScopeStencil
(
)
=
default
;
ScopeStencil
(
ScopeKind
kind
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots
mozilla
:
:
Maybe
<
ScriptIndex
>
functionIndex
=
mozilla
:
:
Nothing
(
)
bool
isArrow
=
false
)
:
enclosing_
(
enclosing
)
kind_
(
kind
)
firstFrameSlot_
(
firstFrameSlot
)
numEnvironmentSlots_
(
numEnvironmentSlots
)
functionIndex_
(
functionIndex
)
isArrow_
(
isArrow
)
{
}
private
:
template
<
typename
.
.
.
Args
>
static
bool
appendScopeStencilAndData
(
JSContext
*
cx
CompilationState
&
compilationState
BaseParserScopeData
*
data
ScopeIndex
*
indexOut
Args
&
&
.
.
.
args
)
;
public
:
static
bool
createForFunctionScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
FunctionScope
:
:
ParserData
*
dataArg
bool
hasParameterExprs
bool
needsEnvironment
ScriptIndex
functionIndex
bool
isArrow
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForLexicalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
ScopeKind
kind
LexicalScope
:
:
ParserData
*
dataArg
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForVarScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
ScopeKind
kind
VarScope
:
:
ParserData
*
dataArg
uint32_t
firstFrameSlot
bool
needsEnvironment
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForGlobalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
ScopeKind
kind
GlobalScope
:
:
ParserData
*
dataArg
ScopeIndex
*
index
)
;
static
bool
createForEvalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
ScopeKind
kind
EvalScope
:
:
ParserData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForModuleScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
ModuleScope
:
:
ParserData
*
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForWithScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
AbstractScopePtr
enclosing
(
CompilationState
&
compilationState
)
const
;
js
:
:
Scope
*
enclosingExistingScope
(
const
CompilationInput
&
input
const
CompilationGCOutput
&
gcOutput
)
const
;
ScopeKind
kind
(
)
const
{
return
kind_
;
}
bool
hasEnvironment
(
)
const
{
bool
hasEnvironmentShape
=
numEnvironmentSlots_
.
isSome
(
)
;
return
Scope
:
:
hasEnvironment
(
kind
(
)
hasEnvironmentShape
)
;
}
bool
isArrow
(
)
const
{
return
isArrow_
;
}
Scope
*
createScope
(
JSContext
*
cx
CompilationInput
&
input
CompilationGCOutput
&
gcOutput
BaseParserScopeData
*
baseScopeData
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
BaseParserScopeData
*
baseScopeData
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
BaseParserScopeData
*
baseScopeData
CompilationStencil
*
compilationStencil
)
;
#
endif
private
:
template
<
typename
SpecificScopeType
>
UniquePtr
<
typename
SpecificScopeType
:
:
RuntimeData
>
createSpecificScopeData
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
CompilationGCOutput
&
gcOutput
BaseParserScopeData
*
baseData
)
const
;
template
<
typename
SpecificEnvironmentType
>
MOZ_MUST_USE
bool
createSpecificShape
(
JSContext
*
cx
ScopeKind
kind
BaseScopeData
*
scopeData
MutableHandleShape
shape
)
const
;
template
<
typename
SpecificScopeType
typename
SpecificEnvironmentType
>
Scope
*
createSpecificScope
(
JSContext
*
cx
CompilationInput
&
input
CompilationGCOutput
&
gcOutput
BaseParserScopeData
*
baseData
)
const
;
template
<
typename
ScopeT
>
static
constexpr
bool
matchScopeKind
(
ScopeKind
kind
)
{
switch
(
kind
)
{
case
ScopeKind
:
:
Function
:
{
return
std
:
:
is_same_v
<
ScopeT
FunctionScope
>
;
}
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
{
return
std
:
:
is_same_v
<
ScopeT
LexicalScope
>
;
}
case
ScopeKind
:
:
FunctionBodyVar
:
{
return
std
:
:
is_same_v
<
ScopeT
VarScope
>
;
}
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
{
return
std
:
:
is_same_v
<
ScopeT
GlobalScope
>
;
}
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
{
return
std
:
:
is_same_v
<
ScopeT
EvalScope
>
;
}
case
ScopeKind
:
:
Module
:
{
return
std
:
:
is_same_v
<
ScopeT
ModuleScope
>
;
}
case
ScopeKind
:
:
With
:
{
return
std
:
:
is_same_v
<
ScopeT
WithScope
>
;
}
case
ScopeKind
:
:
WasmFunction
:
case
ScopeKind
:
:
WasmInstance
:
{
return
false
;
}
}
return
false
;
}
}
;
using
FunctionDeclaration
=
GCThingIndex
;
using
FunctionDeclarationVector
=
Vector
<
FunctionDeclaration
0
js
:
:
SystemAllocPolicy
>
;
class
StencilModuleEntry
{
public
:
TaggedParserAtomIndex
specifier
;
TaggedParserAtomIndex
localName
;
TaggedParserAtomIndex
importName
;
TaggedParserAtomIndex
exportName
;
uint32_t
lineno
=
0
;
uint32_t
column
=
0
;
private
:
StencilModuleEntry
(
uint32_t
lineno
uint32_t
column
)
:
lineno
(
lineno
)
column
(
column
)
{
}
public
:
StencilModuleEntry
(
)
=
default
;
static
StencilModuleEntry
moduleRequest
(
TaggedParserAtomIndex
specifier
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
!
!
specifier
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
return
entry
;
}
static
StencilModuleEntry
importEntry
(
TaggedParserAtomIndex
specifier
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
importName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
localName
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
localName
=
localName
;
entry
.
importName
=
importName
;
return
entry
;
}
static
StencilModuleEntry
exportAsEntry
(
TaggedParserAtomIndex
localName
TaggedParserAtomIndex
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
localName
&
&
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
localName
=
localName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportFromEntry
(
TaggedParserAtomIndex
specifier
TaggedParserAtomIndex
importName
TaggedParserAtomIndex
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
importName
=
importName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
}
;
class
StencilModuleMetadata
{
public
:
using
EntryVector
=
Vector
<
StencilModuleEntry
0
js
:
:
SystemAllocPolicy
>
;
EntryVector
requestedModules
;
EntryVector
importEntries
;
EntryVector
localExportEntries
;
EntryVector
indirectExportEntries
;
EntryVector
starExportEntries
;
FunctionDeclarationVector
functionDecls
;
bool
isAsync
=
false
;
StencilModuleMetadata
(
)
=
default
;
bool
initModule
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
JS
:
:
Handle
<
ModuleObject
*
>
module
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
class
EmptyGlobalScopeType
{
}
;
class
TaggedScriptThingIndex
{
uint32_t
data_
;
static
constexpr
size_t
IndexBit
=
TaggedParserAtomIndex
:
:
IndexBit
;
static
constexpr
size_t
IndexMask
=
TaggedParserAtomIndex
:
:
IndexMask
;
static
constexpr
size_t
TagShift
=
TaggedParserAtomIndex
:
:
TagShift
;
static
constexpr
size_t
TagBit
=
TaggedParserAtomIndex
:
:
TagBit
;
static
constexpr
size_t
TagMask
=
TaggedParserAtomIndex
:
:
TagMask
;
public
:
enum
class
Kind
:
uint32_t
{
Null
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
Null
)
ParserAtomIndex
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
ParserAtomIndex
)
WellKnown
=
uint32_t
(
TaggedParserAtomIndex
:
:
Kind
:
:
WellKnown
)
BigInt
ObjLiteral
RegExp
Scope
Function
EmptyGlobalScope
}
;
private
:
static
constexpr
uint32_t
NullTag
=
uint32_t
(
Kind
:
:
Null
)
<
<
TagShift
;
static_assert
(
NullTag
=
=
TaggedParserAtomIndex
:
:
NullTag
)
;
static
constexpr
uint32_t
ParserAtomIndexTag
=
uint32_t
(
Kind
:
:
ParserAtomIndex
)
<
<
TagShift
;
static_assert
(
ParserAtomIndexTag
=
=
TaggedParserAtomIndex
:
:
ParserAtomIndexTag
)
;
static
constexpr
uint32_t
WellKnownTag
=
uint32_t
(
Kind
:
:
WellKnown
)
<
<
TagShift
;
static_assert
(
WellKnownTag
=
=
TaggedParserAtomIndex
:
:
WellKnownTag
)
;
static
constexpr
uint32_t
BigIntTag
=
uint32_t
(
Kind
:
:
BigInt
)
<
<
TagShift
;
static
constexpr
uint32_t
ObjLiteralTag
=
uint32_t
(
Kind
:
:
ObjLiteral
)
<
<
TagShift
;
static
constexpr
uint32_t
RegExpTag
=
uint32_t
(
Kind
:
:
RegExp
)
<
<
TagShift
;
static
constexpr
uint32_t
ScopeTag
=
uint32_t
(
Kind
:
:
Scope
)
<
<
TagShift
;
static
constexpr
uint32_t
FunctionTag
=
uint32_t
(
Kind
:
:
Function
)
<
<
TagShift
;
static
constexpr
uint32_t
EmptyGlobalScopeTag
=
uint32_t
(
Kind
:
:
EmptyGlobalScope
)
<
<
TagShift
;
public
:
static
constexpr
uint32_t
IndexLimit
=
Bit
(
IndexBit
)
;
TaggedScriptThingIndex
(
)
:
data_
(
NullTag
)
{
}
explicit
TaggedScriptThingIndex
(
TaggedParserAtomIndex
index
)
:
data_
(
*
index
.
rawData
(
)
)
{
}
explicit
TaggedScriptThingIndex
(
BigIntIndex
index
)
:
data_
(
uint32_t
(
index
)
|
BigIntTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ObjLiteralIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ObjLiteralTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
RegExpIndex
index
)
:
data_
(
uint32_t
(
index
)
|
RegExpTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ScopeIndex
index
)
:
data_
(
uint32_t
(
index
)
|
ScopeTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
ScriptIndex
index
)
:
data_
(
uint32_t
(
index
)
|
FunctionTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
IndexLimit
)
;
}
explicit
TaggedScriptThingIndex
(
EmptyGlobalScopeType
t
)
:
data_
(
EmptyGlobalScopeTag
)
{
}
bool
isAtom
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ParserAtomIndexTag
|
|
(
data_
&
TagMask
)
=
=
WellKnownTag
;
}
bool
isNull
(
)
const
{
bool
result
=
!
data_
;
MOZ_ASSERT_IF
(
result
(
data_
&
TagMask
)
=
=
NullTag
)
;
return
result
;
}
bool
isBigInt
(
)
const
{
return
(
data_
&
TagMask
)
=
=
BigIntTag
;
}
bool
isObjLiteral
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ObjLiteralTag
;
}
bool
isRegExp
(
)
const
{
return
(
data_
&
TagMask
)
=
=
RegExpTag
;
}
bool
isScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ScopeTag
;
}
bool
isFunction
(
)
const
{
return
(
data_
&
TagMask
)
=
=
FunctionTag
;
}
bool
isEmptyGlobalScope
(
)
const
{
return
(
data_
&
TagMask
)
=
=
EmptyGlobalScopeTag
;
}
TaggedParserAtomIndex
toAtom
(
)
const
{
MOZ_ASSERT
(
isAtom
(
)
)
;
return
TaggedParserAtomIndex
:
:
fromRaw
(
data_
)
;
}
BigIntIndex
toBigInt
(
)
const
{
return
BigIntIndex
(
data_
&
IndexMask
)
;
}
ObjLiteralIndex
toObjLiteral
(
)
const
{
return
ObjLiteralIndex
(
data_
&
IndexMask
)
;
}
RegExpIndex
toRegExp
(
)
const
{
return
RegExpIndex
(
data_
&
IndexMask
)
;
}
ScopeIndex
toScope
(
)
const
{
return
ScopeIndex
(
data_
&
IndexMask
)
;
}
ScriptIndex
toFunction
(
)
const
{
return
ScriptIndex
(
data_
&
IndexMask
)
;
}
uint32_t
*
rawData
(
)
{
return
&
data_
;
}
Kind
tag
(
)
const
{
return
Kind
(
(
data_
&
TagMask
)
>
>
TagShift
)
;
}
bool
operator
=
=
(
const
TaggedScriptThingIndex
&
rhs
)
const
{
return
data_
=
=
rhs
.
data_
;
}
}
;
class
ScriptStencil
{
public
:
ImmutableScriptFlags
immutableFlags
;
uint32_t
memberInitializers_
=
0
;
CompilationGCThingIndex
gcThingsOffset
;
uint32_t
gcThingsLength
=
0
;
SourceExtent
extent
=
{
}
;
TaggedParserAtomIndex
functionAtom
;
FunctionFlags
functionFlags
=
{
}
;
uint16_t
nargs
=
0
;
ScopeIndex
lazyFunctionEnclosingScopeIndex_
;
static
constexpr
uint32_t
WasFunctionEmittedFlag
=
1
<
<
0
;
static
constexpr
uint32_t
AllowRelazifyFlag
=
1
<
<
1
;
static
constexpr
uint32_t
HasSharedDataFlag
=
1
<
<
2
;
static
constexpr
uint32_t
HasMemberInitializersFlag
=
1
<
<
3
;
static
constexpr
uint32_t
HasLazyFunctionEnclosingScopeIndexFlag
=
1
<
<
4
;
uint32_t
flags_
=
0
;
ScriptStencil
(
)
=
default
;
bool
isFunction
(
)
const
{
bool
result
=
functionFlags
.
toRaw
(
)
!
=
0x0000
;
MOZ_ASSERT_IF
(
result
functionFlags
.
isAsmJSNative
(
)
|
|
functionFlags
.
hasBaseScript
(
)
)
;
return
result
;
}
bool
isModule
(
)
const
{
bool
result
=
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
IsModule
)
;
MOZ_ASSERT_IF
(
result
!
isFunction
(
)
)
;
return
result
;
}
bool
hasGCThings
(
)
const
{
return
gcThingsLength
;
}
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
gcthings
(
CompilationStencil
&
stencil
)
const
;
bool
wasFunctionEmitted
(
)
const
{
return
flags_
&
WasFunctionEmittedFlag
;
}
void
setWasFunctionEmitted
(
)
{
flags_
|
=
WasFunctionEmittedFlag
;
}
bool
allowRelazify
(
)
const
{
return
flags_
&
AllowRelazifyFlag
;
}
void
setAllowRelazify
(
)
{
flags_
|
=
AllowRelazifyFlag
;
}
bool
hasSharedData
(
)
const
{
return
flags_
&
HasSharedDataFlag
;
}
void
setHasSharedData
(
)
{
flags_
|
=
HasSharedDataFlag
;
}
bool
hasMemberInitializers
(
)
const
{
return
flags_
&
HasMemberInitializersFlag
;
}
private
:
void
setHasMemberInitializers
(
)
{
flags_
|
=
HasMemberInitializersFlag
;
}
public
:
void
setMemberInitializers
(
MemberInitializers
member
)
{
memberInitializers_
=
member
.
serialize
(
)
;
setHasMemberInitializers
(
)
;
}
MemberInitializers
memberInitializers
(
)
const
{
MOZ_ASSERT
(
hasMemberInitializers
(
)
)
;
return
MemberInitializers
(
memberInitializers_
)
;
}
bool
hasLazyFunctionEnclosingScopeIndex
(
)
const
{
return
flags_
&
HasLazyFunctionEnclosingScopeIndexFlag
;
}
private
:
void
setHasLazyFunctionEnclosingScopeIndex
(
)
{
flags_
|
=
HasLazyFunctionEnclosingScopeIndexFlag
;
}
public
:
void
setLazyFunctionEnclosingScopeIndex
(
ScopeIndex
index
)
{
lazyFunctionEnclosingScopeIndex_
=
index
;
setHasLazyFunctionEnclosingScopeIndex
(
)
;
}
ScopeIndex
lazyFunctionEnclosingScopeIndex
(
)
const
{
MOZ_ASSERT
(
hasLazyFunctionEnclosingScopeIndex
(
)
)
;
return
lazyFunctionEnclosingScopeIndex_
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
void
dumpFields
(
JSONPrinter
&
json
CompilationStencil
*
compilationStencil
)
;
#
endif
}
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
DumpTaggedParserAtomIndex
(
js
:
:
JSONPrinter
&
json
TaggedParserAtomIndex
taggedIndex
CompilationStencil
*
compilationStencil
)
;
#
endif
}
}
#
endif
