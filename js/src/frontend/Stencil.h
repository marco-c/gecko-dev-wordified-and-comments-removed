#
ifndef
frontend_Stencil_h
#
define
frontend_Stencil_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
js
{
class
JSONPrinter
;
namespace
frontend
{
struct
CompilationInfo
;
class
ScriptStencil
;
class
RegExpStencil
;
class
BigIntStencil
;
using
RegExpIndex
=
TypedIndex
<
RegExpStencil
>
;
using
BigIntIndex
=
TypedIndex
<
BigIntStencil
>
;
using
ObjLiteralIndex
=
TypedIndex
<
ObjLiteralStencil
>
;
using
FunctionIndex
=
TypedIndex
<
ScriptStencil
>
;
FunctionFlags
InitialFunctionFlags
(
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
bool
isSelfHosting
=
false
bool
hasUnclonedName
=
false
)
;
class
RegExpStencil
{
UniqueTwoByteChars
buf_
;
size_t
length_
=
0
;
JS
:
:
RegExpFlags
flags_
;
public
:
RegExpStencil
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
mozilla
:
:
Range
<
const
char16_t
>
range
JS
:
:
RegExpFlags
flags
)
{
length_
=
range
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
range
.
begin
(
)
.
get
(
)
range
.
length
(
)
)
;
if
(
!
buf_
)
{
return
false
;
}
flags_
=
flags
;
return
true
;
}
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
JSAtom
*
pattern
JS
:
:
RegExpFlags
flags
)
;
RegExpObject
*
createRegExp
(
JSContext
*
cx
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
#
endif
}
;
class
BigIntStencil
{
UniqueTwoByteChars
buf_
;
size_t
length_
=
0
;
public
:
BigIntStencil
(
)
=
default
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
const
Vector
<
char16_t
32
>
&
buf
)
{
#
ifdef
DEBUG
for
(
char16_t
c
:
buf
)
{
MOZ_ASSERT
(
c
!
=
'
_
'
)
;
}
#
endif
length_
=
buf
.
length
(
)
;
buf_
=
js
:
:
DuplicateString
(
cx
buf
.
begin
(
)
buf
.
length
(
)
)
;
return
buf_
!
=
nullptr
;
}
BigInt
*
createBigInt
(
JSContext
*
cx
)
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
ParseBigIntLiteral
(
cx
source
)
;
}
bool
isZero
(
)
{
mozilla
:
:
Range
<
const
char16_t
>
source
(
buf_
.
get
(
)
length_
)
;
return
js
:
:
BigIntLiteralIsZero
(
source
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
#
endif
}
;
class
ScopeStencil
{
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing_
;
ScopeKind
kind_
;
uint32_t
firstFrameSlot_
;
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots_
;
mozilla
:
:
Maybe
<
FunctionIndex
>
functionIndex_
;
bool
isArrow_
;
UniquePtr
<
BaseScopeData
>
data_
;
public
:
ScopeStencil
(
ScopeKind
kind
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
uint32_t
>
numEnvironmentSlots
UniquePtr
<
BaseScopeData
>
data
=
{
}
mozilla
:
:
Maybe
<
FunctionIndex
>
functionIndex
=
mozilla
:
:
Nothing
(
)
bool
isArrow
=
false
)
:
enclosing_
(
enclosing
)
kind_
(
kind
)
firstFrameSlot_
(
firstFrameSlot
)
numEnvironmentSlots_
(
numEnvironmentSlots
)
functionIndex_
(
functionIndex
)
isArrow_
(
isArrow
)
data_
(
std
:
:
move
(
data
)
)
{
}
static
bool
createForFunctionScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
Handle
<
FunctionScope
:
:
Data
*
>
dataArg
bool
hasParameterExprs
bool
needsEnvironment
FunctionIndex
functionIndex
bool
isArrow
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForLexicalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
LexicalScope
:
:
Data
*
>
dataArg
uint32_t
firstFrameSlot
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForVarScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
VarScope
:
:
Data
*
>
dataArg
uint32_t
firstFrameSlot
bool
needsEnvironment
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForGlobalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
GlobalScope
:
:
Data
*
>
dataArg
ScopeIndex
*
index
)
;
static
bool
createForEvalScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScopeKind
kind
Handle
<
EvalScope
:
:
Data
*
>
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForModuleScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
Handle
<
ModuleScope
:
:
Data
*
>
dataArg
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
static
bool
createForWithScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
;
AbstractScopePtr
enclosing
(
CompilationInfo
&
compilationInfo
)
;
ScopeKind
kind
(
)
const
{
return
kind_
;
}
bool
hasEnvironment
(
)
const
{
bool
hasEnvironmentShape
=
numEnvironmentSlots_
.
isSome
(
)
;
return
Scope
:
:
hasEnvironment
(
kind
(
)
hasEnvironmentShape
)
;
}
bool
isArrow
(
)
const
{
return
isArrow_
;
}
Scope
*
createScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
;
void
trace
(
JSTracer
*
trc
)
;
uint32_t
nextFrameSlot
(
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
void
dumpFields
(
JSONPrinter
&
json
)
;
#
endif
private
:
template
<
typename
SpecificScopeType
>
typename
SpecificScopeType
:
:
Data
&
data
(
)
const
{
MOZ_ASSERT
(
data_
.
get
(
)
)
;
return
*
static_cast
<
typename
SpecificScopeType
:
:
Data
*
>
(
data_
.
get
(
)
)
;
}
template
<
typename
SpecificScopeType
>
UniquePtr
<
typename
SpecificScopeType
:
:
Data
>
releaseData
(
CompilationInfo
&
compilationInfo
)
;
template
<
typename
SpecificScopeType
>
uint32_t
nextFrameSlot
(
)
const
{
return
data
<
SpecificScopeType
>
(
)
.
nextFrameSlot
;
}
template
<
typename
SpecificEnvironmentType
>
MOZ_MUST_USE
bool
createSpecificShape
(
JSContext
*
cx
ScopeKind
kind
BaseScopeData
*
scopeData
MutableHandleShape
shape
)
;
template
<
typename
SpecificScopeType
typename
SpecificEnvironmentType
>
Scope
*
createSpecificScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
;
}
;
class
EmptyGlobalScopeType
{
}
;
using
FunctionDeclaration
=
GCThingIndex
;
using
FunctionDeclarationVector
=
Vector
<
FunctionDeclaration
>
;
class
StencilModuleEntry
{
public
:
JSAtom
*
specifier
=
nullptr
;
JSAtom
*
localName
=
nullptr
;
JSAtom
*
importName
=
nullptr
;
JSAtom
*
exportName
=
nullptr
;
uint32_t
lineno
=
0
;
uint32_t
column
=
0
;
private
:
StencilModuleEntry
(
uint32_t
lineno
uint32_t
column
)
:
lineno
(
lineno
)
column
(
column
)
{
}
public
:
static
StencilModuleEntry
moduleRequest
(
JSAtom
*
specifier
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
return
entry
;
}
static
StencilModuleEntry
importEntry
(
JSAtom
*
specifier
JSAtom
*
localName
JSAtom
*
importName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
localName
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
localName
=
localName
;
entry
.
importName
=
importName
;
return
entry
;
}
static
StencilModuleEntry
exportAsEntry
(
JSAtom
*
localName
JSAtom
*
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
localName
&
&
exportName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
localName
=
localName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
static
StencilModuleEntry
exportFromEntry
(
JSAtom
*
specifier
JSAtom
*
importName
JSAtom
*
exportName
uint32_t
lineno
uint32_t
column
)
{
MOZ_ASSERT
(
specifier
&
&
importName
)
;
StencilModuleEntry
entry
(
lineno
column
)
;
entry
.
specifier
=
specifier
;
entry
.
importName
=
importName
;
entry
.
exportName
=
exportName
;
return
entry
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
StencilModuleMetadata
{
public
:
using
EntryVector
=
JS
:
:
GCVector
<
StencilModuleEntry
>
;
EntryVector
requestedModules
;
EntryVector
importEntries
;
EntryVector
localExportEntries
;
EntryVector
indirectExportEntries
;
EntryVector
starExportEntries
;
FunctionDeclarationVector
functionDecls
;
explicit
StencilModuleMetadata
(
JSContext
*
cx
)
:
requestedModules
(
cx
)
importEntries
(
cx
)
localExportEntries
(
cx
)
indirectExportEntries
(
cx
)
starExportEntries
(
cx
)
functionDecls
(
cx
)
{
}
bool
initModule
(
JSContext
*
cx
JS
:
:
Handle
<
ModuleObject
*
>
module
)
;
void
trace
(
JSTracer
*
trc
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
void
dumpFields
(
JSONPrinter
&
json
)
;
#
endif
}
;
class
NullScriptThing
{
}
;
using
ScriptAtom
=
JSAtom
*
;
using
ScriptThingVariant
=
mozilla
:
:
Variant
<
ScriptAtom
NullScriptThing
BigIntIndex
ObjLiteralIndex
RegExpIndex
ScopeIndex
FunctionIndex
EmptyGlobalScopeType
>
;
using
ScriptThingsVector
=
Vector
<
ScriptThingVariant
>
;
class
ScriptStencil
{
public
:
ImmutableScriptFlags
immutableFlags
;
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
;
ScriptThingsVector
gcThings
;
js
:
:
UniquePtr
<
js
:
:
ImmutableScriptData
>
immutableScriptData
=
nullptr
;
SourceExtent
extent
=
{
}
;
JSAtom
*
functionAtom
=
nullptr
;
FunctionFlags
functionFlags
=
{
}
;
uint16_t
nargs
=
0
;
mozilla
:
:
Maybe
<
ScopeIndex
>
lazyFunctionEnclosingScopeIndex_
;
bool
isStandaloneFunction
:
1
;
bool
wasFunctionEmitted
:
1
;
bool
isSingletonFunction
:
1
;
explicit
ScriptStencil
(
JSContext
*
cx
)
:
gcThings
(
cx
)
isStandaloneFunction
(
false
)
wasFunctionEmitted
(
false
)
isSingletonFunction
(
false
)
{
}
void
trace
(
JSTracer
*
trc
)
;
bool
isFunction
(
)
const
{
bool
result
=
functionFlags
.
toRaw
(
)
!
=
0x0000
;
MOZ_ASSERT_IF
(
result
functionFlags
.
isAsmJSNative
(
)
|
|
functionFlags
.
hasBaseScript
(
)
)
;
return
result
;
}
bool
isModule
(
)
const
{
bool
result
=
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
IsModule
)
;
MOZ_ASSERT_IF
(
result
!
isFunction
(
)
)
;
return
result
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
JSONPrinter
&
json
)
;
void
dumpFields
(
JSONPrinter
&
json
)
;
#
endif
}
;
}
}
#
endif
