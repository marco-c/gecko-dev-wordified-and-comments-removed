#
ifndef
frontend_UsingEmitter_h
#
define
frontend_UsingEmitter_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
TryEmitter
.
h
"
#
include
"
vm
/
CompletionKind
.
h
"
#
include
"
vm
/
UsingHint
.
h
"
namespace
js
:
:
frontend
{
struct
BytecodeEmitter
;
class
EmitterScope
;
class
MOZ_STACK_CLASS
DisposalEmitter
{
private
:
BytecodeEmitter
*
bce_
;
bool
hasAsyncDisposables_
;
CompletionKind
initialCompletion_
;
#
ifdef
DEBUG
enum
class
State
{
Start
DisposeCapability
End
}
;
State
state_
=
State
:
:
Start
;
#
endif
[
[
nodiscard
]
]
bool
emitResourcePropertyAccess
(
TaggedParserAtomIndex
prop
unsigned
resourcesFromTop
=
1
)
;
public
:
DisposalEmitter
(
BytecodeEmitter
*
bce
bool
hasAsyncDisposables
CompletionKind
initialCompletion
)
:
bce_
(
bce
)
hasAsyncDisposables_
(
hasAsyncDisposables
)
initialCompletion_
(
initialCompletion
)
{
}
[
[
nodiscard
]
]
bool
prepareForDisposeCapability
(
)
;
[
[
nodiscard
]
]
bool
emitEnd
(
EmitterScope
&
es
)
;
}
;
class
MOZ_STACK_CLASS
UsingEmitter
{
private
:
mozilla
:
:
Maybe
<
TryEmitter
>
tryEmitter_
;
bool
hasAwaitUsing_
=
false
;
[
[
nodiscard
]
]
bool
emitThrowIfException
(
)
;
[
[
nodiscard
]
]
bool
emitGetDisposeMethod
(
UsingHint
hint
)
;
[
[
nodiscard
]
]
bool
emitCreateDisposableResource
(
UsingHint
hint
)
;
[
[
nodiscard
]
]
bool
emitTakeDisposeCapability
(
)
;
protected
:
BytecodeEmitter
*
bce_
;
[
[
nodiscard
]
]
bool
emitDisposeResourcesForEnvironment
(
EmitterScope
&
es
CompletionKind
initialCompletion
=
CompletionKind
:
:
Normal
)
;
public
:
explicit
UsingEmitter
(
BytecodeEmitter
*
bce
)
;
bool
hasAwaitUsing
(
)
const
{
return
hasAwaitUsing_
;
}
void
setHasAwaitUsing
(
bool
hasAwaitUsing
)
{
hasAwaitUsing_
=
hasAwaitUsing
;
}
[
[
nodiscard
]
]
bool
prepareForDisposableScopeBody
(
)
;
[
[
nodiscard
]
]
bool
prepareForAssignment
(
UsingHint
hint
)
;
[
[
nodiscard
]
]
bool
prepareForForOfLoopIteration
(
)
;
[
[
nodiscard
]
]
bool
prepareForForOfIteratorCloseOnThrow
(
)
;
[
[
nodiscard
]
]
bool
emitNonLocalJump
(
EmitterScope
*
present
)
;
[
[
nodiscard
]
]
bool
emitEnd
(
)
;
[
[
nodiscard
]
]
bool
emitNonLocalJumpNeedingIteratorClose
(
EmitterScope
*
present
)
;
}
;
class
MOZ_STACK_CLASS
NonLocalIteratorCloseUsingEmitter
:
protected
UsingEmitter
{
private
:
mozilla
:
:
Maybe
<
TryEmitter
>
tryClosingIterator_
;
#
ifdef
DEBUG
enum
class
State
{
Start
IteratorClose
End
}
;
State
state_
=
State
:
:
Start
;
#
endif
public
:
explicit
NonLocalIteratorCloseUsingEmitter
(
BytecodeEmitter
*
bce
)
:
UsingEmitter
(
bce
)
{
}
[
[
nodiscard
]
]
bool
prepareForIteratorClose
(
EmitterScope
&
es
)
;
[
[
nodiscard
]
]
bool
emitEnd
(
)
;
}
;
}
#
endif
