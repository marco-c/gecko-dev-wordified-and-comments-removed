#
include
"
frontend
/
TryEmitter
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
IfEmitter
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
TryEmitter
:
:
TryEmitter
(
BytecodeEmitter
*
bce
Kind
kind
ControlKind
controlKind
)
:
bce_
(
bce
)
kind_
(
kind
)
controlKind_
(
controlKind
)
depth_
(
0
)
tryOpOffset_
(
0
)
#
ifdef
DEBUG
state_
(
State
:
:
Start
)
#
endif
{
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
controlInfo_
.
emplace
(
bce_
hasFinally
(
)
?
StatementKind
:
:
Finally
:
StatementKind
:
:
Try
)
;
}
}
bool
TryEmitter
:
:
emitTry
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
)
;
depth_
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
;
tryOpOffset_
=
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
;
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Try
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
Try
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitJumpToFinallyWithFallthrough
(
)
{
BytecodeOffset
off
;
if
(
!
bce_
-
>
emitN
(
JSOp
:
:
ResumeIndex
3
&
off
)
)
{
return
false
;
}
if
(
!
controlInfo_
-
>
defaultResumeIndexOffsets_
.
append
(
off
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
False
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitJumpNoFallthrough
(
JSOp
:
:
Goto
&
controlInfo_
-
>
finallyJumps_
)
)
{
return
false
;
}
uint32_t
stackDepthForNextBlock
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
-
2
;
bce_
-
>
bytecodeSection
(
)
.
setStackDepth
(
stackDepthForNextBlock
)
;
return
true
;
}
bool
TryEmitter
:
:
emitTryEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
MOZ_ASSERT
(
depth_
=
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
)
;
if
(
hasFinally
(
)
&
&
controlInfo_
)
{
if
(
!
emitJumpToFinallyWithFallthrough
(
)
)
{
return
false
;
}
}
else
{
if
(
!
bce_
-
>
emitJump
(
JSOp
:
:
Goto
&
catchAndFinallyJump_
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emitJumpTarget
(
&
tryEnd_
)
)
{
return
false
;
}
return
true
;
}
bool
TryEmitter
:
:
emitCatch
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
if
(
!
emitTryEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Exception
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
Catch
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitCatchEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
controlInfo_
)
{
return
true
;
}
if
(
hasFinally
(
)
)
{
if
(
!
emitJumpToFinallyWithFallthrough
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
TryEmitter
:
:
emitFinally
(
const
Maybe
<
uint32_t
>
&
finallyPos
)
{
if
(
!
controlInfo_
)
{
if
(
kind_
=
=
Kind
:
:
TryCatch
)
{
kind_
=
Kind
:
:
TryCatchFinally
;
}
}
else
{
MOZ_ASSERT
(
hasFinally
(
)
)
;
}
if
(
!
hasCatch
(
)
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
if
(
!
emitTryEnd
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
emitCatchEnd
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
bce_
-
>
bytecodeSection
(
)
.
setStackDepth
(
depth_
+
2
)
;
if
(
!
bce_
-
>
emitJumpTarget
(
&
finallyStart_
)
)
{
return
false
;
}
if
(
controlInfo_
)
{
bce_
-
>
patchJumpsToTarget
(
controlInfo_
-
>
finallyJumps_
finallyStart_
)
;
controlInfo_
-
>
setEmittingSubroutine
(
)
;
}
if
(
finallyPos
)
{
if
(
!
bce_
-
>
updateSourceCoordNotes
(
finallyPos
.
value
(
)
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Finally
)
)
{
return
false
;
}
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
GetRval
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
Finally
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitFinallyEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Finally
)
;
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
}
InternalIfEmitter
ifThrowing
(
bce_
)
;
if
(
!
ifThrowing
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Throw
)
)
{
return
false
;
}
if
(
!
ifThrowing
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
Retsub
)
)
{
return
false
;
}
if
(
!
ifThrowing
.
emitEnd
(
)
)
{
return
false
;
}
bce_
-
>
hasTryFinally
=
true
;
return
true
;
}
bool
TryEmitter
:
:
emitEnd
(
)
{
if
(
!
hasFinally
(
)
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
emitCatchEnd
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Finally
)
;
if
(
!
emitFinallyEnd
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
hasFinally
(
)
&
&
controlInfo_
)
{
MOZ_ASSERT
(
!
catchAndFinallyJump_
.
offset
.
valid
(
)
)
;
JumpTarget
target
;
if
(
!
bce_
-
>
emitJumpTarget
(
&
target
)
)
{
return
false
;
}
uint32_t
resumeIndex
;
if
(
!
bce_
-
>
allocateResumeIndex
(
target
.
offset
&
resumeIndex
)
)
{
return
false
;
}
for
(
BytecodeOffset
offset
:
controlInfo_
-
>
defaultResumeIndexOffsets_
)
{
SET_RESUMEINDEX
(
bce_
-
>
bytecodeSection
(
)
.
code
(
offset
)
resumeIndex
)
;
}
}
else
{
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
catchAndFinallyJump_
)
)
{
return
false
;
}
}
if
(
hasCatch
(
)
)
{
if
(
!
bce_
-
>
addTryNote
(
TryNoteKind
:
:
Catch
depth_
offsetAfterTryOp
(
)
tryEnd_
.
offset
)
)
{
return
false
;
}
}
if
(
hasFinally
(
)
)
{
if
(
!
bce_
-
>
addTryNote
(
TryNoteKind
:
:
Finally
depth_
offsetAfterTryOp
(
)
finallyStart_
.
offset
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
End
;
#
endif
return
true
;
}
