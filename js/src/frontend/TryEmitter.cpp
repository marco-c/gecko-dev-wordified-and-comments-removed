#
include
"
frontend
/
TryEmitter
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
TryEmitter
:
:
TryEmitter
(
BytecodeEmitter
*
bce
Kind
kind
ControlKind
controlKind
)
:
bce_
(
bce
)
kind_
(
kind
)
controlKind_
(
controlKind
)
depth_
(
0
)
noteIndex_
(
0
)
tryStart_
(
0
)
#
ifdef
DEBUG
state_
(
State
:
:
Start
)
#
endif
{
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
controlInfo_
.
emplace
(
bce_
hasFinally
(
)
?
StatementKind
:
:
Finally
:
StatementKind
:
:
Try
)
;
}
finallyStart_
.
offset
=
0
;
}
bool
TryEmitter
:
:
emitJumpOverCatchAndFinally
(
)
{
if
(
!
bce_
-
>
emitJump
(
JSOP_GOTO
&
catchAndFinallyJump_
)
)
{
return
false
;
}
return
true
;
}
bool
TryEmitter
:
:
emitTry
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
)
;
depth_
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
;
if
(
!
bce_
-
>
newSrcNote
(
SRC_TRY
&
noteIndex_
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOP_TRY
)
)
{
return
false
;
}
tryStart_
=
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
;
#
ifdef
DEBUG
state_
=
State
:
:
Try
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitTryEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
MOZ_ASSERT
(
depth_
=
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
)
;
if
(
hasFinally
(
)
&
&
controlInfo_
)
{
if
(
!
bce_
-
>
emitGoSub
(
&
controlInfo_
-
>
gosubs
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
setSrcNoteOffset
(
noteIndex_
SrcNote
:
:
Try
:
:
EndOfTryJumpOffset
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
-
tryStart_
+
JSOP_TRY_LENGTH
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitJump
(
JSOP_GOTO
&
catchAndFinallyJump_
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitJumpTarget
(
&
tryEnd_
)
)
{
return
false
;
}
return
true
;
}
bool
TryEmitter
:
:
emitCatch
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
if
(
!
emitTryEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOP_UNDEFINED
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOP_SETRVAL
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
Catch
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitCatchEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
controlInfo_
)
{
return
true
;
}
if
(
hasFinally
(
)
)
{
if
(
!
bce_
-
>
emitGoSub
(
&
controlInfo_
-
>
gosubs
)
)
{
return
false
;
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
!
bce_
-
>
emitJump
(
JSOP_GOTO
&
catchAndFinallyJump_
)
)
{
return
false
;
}
}
return
true
;
}
bool
TryEmitter
:
:
emitFinally
(
const
Maybe
<
uint32_t
>
&
finallyPos
)
{
if
(
!
controlInfo_
)
{
if
(
kind_
=
=
Kind
:
:
TryCatch
)
{
kind_
=
Kind
:
:
TryCatchFinally
;
}
}
else
{
MOZ_ASSERT
(
hasFinally
(
)
)
;
}
if
(
!
hasCatch
(
)
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Try
)
;
if
(
!
emitTryEnd
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
emitCatchEnd
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
!
bce_
-
>
emitJumpTarget
(
&
finallyStart_
)
)
{
return
false
;
}
if
(
controlInfo_
)
{
bce_
-
>
patchJumpsToTarget
(
controlInfo_
-
>
gosubs
finallyStart_
)
;
controlInfo_
-
>
setEmittingSubroutine
(
)
;
}
if
(
finallyPos
)
{
if
(
!
bce_
-
>
updateSourceCoordNotes
(
finallyPos
.
value
(
)
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emit1
(
JSOP_FINALLY
)
)
{
return
false
;
}
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOP_GETRVAL
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOP_UNDEFINED
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOP_SETRVAL
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
Finally
;
#
endif
return
true
;
}
bool
TryEmitter
:
:
emitFinallyEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Finally
)
;
if
(
controlKind_
=
=
ControlKind
:
:
Syntactic
)
{
if
(
!
bce_
-
>
emit1
(
JSOP_SETRVAL
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emit1
(
JSOP_RETSUB
)
)
{
return
false
;
}
bce_
-
>
hasTryFinally
=
true
;
return
true
;
}
bool
TryEmitter
:
:
emitEnd
(
)
{
if
(
!
hasFinally
(
)
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Catch
)
;
if
(
!
emitCatchEnd
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Finally
)
;
if
(
!
emitFinallyEnd
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth_
)
;
if
(
!
bce_
-
>
emit1
(
JSOP_NOP
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
catchAndFinallyJump_
)
)
{
return
false
;
}
if
(
hasCatch
(
)
)
{
if
(
!
bce_
-
>
addTryNote
(
JSTRY_CATCH
depth_
tryStart_
tryEnd_
.
offset
)
)
{
return
false
;
}
}
if
(
hasFinally
(
)
)
{
if
(
!
bce_
-
>
addTryNote
(
JSTRY_FINALLY
depth_
tryStart_
finallyStart_
.
offset
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
End
;
#
endif
return
true
;
}
