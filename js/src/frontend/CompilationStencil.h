#
ifndef
frontend_CompilationStencil_h
#
define
frontend_CompilationStencil_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
TaggedParserAtomIndexHasher
.
h
"
#
include
"
frontend
/
UsedNameTracker
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
js
/
WasmModule
.
h
"
#
include
"
vm
/
ErrorContext
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
class
JSAtom
;
class
JSString
;
namespace
JS
{
class
JS_PUBLIC_API
ReadOnlyCompileOptions
;
}
namespace
js
{
class
AtomSet
;
class
JSONPrinter
;
class
ModuleObject
;
namespace
frontend
{
struct
CompilationInput
;
struct
CompilationStencil
;
struct
CompilationGCOutput
;
class
ScriptStencilIterable
;
struct
InputName
;
class
ScopeBindingCache
;
struct
ScopeStencilRef
{
const
CompilationStencil
&
context_
;
const
ScopeIndex
scopeIndex_
;
inline
const
ScopeStencil
&
scope
(
)
const
;
}
;
class
InputScope
{
using
InputScopeStorage
=
mozilla
:
:
Variant
<
Scope
*
ScopeStencilRef
>
;
InputScopeStorage
scope_
;
public
:
explicit
InputScope
(
Scope
*
ptr
)
:
scope_
(
ptr
)
{
}
InputScope
(
const
CompilationStencil
&
context
ScopeIndex
scopeIndex
)
:
scope_
(
ScopeStencilRef
{
context
scopeIndex
}
)
{
}
const
InputScopeStorage
&
variant
(
)
const
{
return
scope_
;
}
InputScopeStorage
&
variant
(
)
{
return
scope_
;
}
template
<
typename
Matcher
>
decltype
(
auto
)
match
(
Matcher
&
&
matcher
)
const
&
{
return
scope_
.
match
(
std
:
:
forward
<
Matcher
>
(
matcher
)
)
;
}
template
<
typename
Matcher
>
decltype
(
auto
)
match
(
Matcher
&
&
matcher
)
&
{
return
scope_
.
match
(
std
:
:
forward
<
Matcher
>
(
matcher
)
)
;
}
bool
isNull
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
return
!
ptr
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
return
!
ref
.
scopeIndex_
.
isValid
(
)
;
}
)
;
}
ScopeKind
kind
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
return
ptr
-
>
kind
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
return
ref
.
scope
(
)
.
kind
(
)
;
}
)
;
}
;
bool
hasEnvironment
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
return
ptr
-
>
hasEnvironment
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
return
ref
.
scope
(
)
.
hasEnvironment
(
)
;
}
)
;
}
;
inline
InputScope
enclosing
(
)
const
;
bool
hasOnChain
(
ScopeKind
kind
)
const
{
return
scope_
.
match
(
[
=
]
(
const
Scope
*
ptr
)
{
return
ptr
-
>
hasOnChain
(
kind
)
;
}
[
=
]
(
const
ScopeStencilRef
&
ref
)
{
ScopeStencilRef
it
=
ref
;
while
(
true
)
{
const
ScopeStencil
&
scope
=
it
.
scope
(
)
;
if
(
scope
.
kind
(
)
=
=
kind
)
{
return
true
;
}
if
(
!
scope
.
hasEnclosing
(
)
)
{
break
;
}
new
(
&
it
)
ScopeStencilRef
{
ref
.
context_
scope
.
enclosing
(
)
}
;
}
return
false
;
}
)
;
}
uint32_t
environmentChainLength
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
return
ptr
-
>
environmentChainLength
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
uint32_t
length
=
0
;
ScopeStencilRef
it
=
ref
;
while
(
true
)
{
const
ScopeStencil
&
scope
=
it
.
scope
(
)
;
if
(
scope
.
hasEnvironment
(
)
&
&
scope
.
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
)
{
length
+
+
;
}
if
(
!
scope
.
hasEnclosing
(
)
)
{
break
;
}
new
(
&
it
)
ScopeStencilRef
{
ref
.
context_
scope
.
enclosing
(
)
}
;
}
return
length
;
}
)
;
}
void
trace
(
JSTracer
*
trc
)
;
bool
isStencil
(
)
const
{
return
scope_
.
is
<
ScopeStencilRef
>
(
)
;
}
;
private
:
inline
FunctionFlags
functionFlags
(
)
const
;
inline
ImmutableScriptFlags
immutableFlags
(
)
const
;
public
:
inline
MemberInitializers
getMemberInitializers
(
)
const
;
RO_IMMUTABLE_SCRIPT_FLAGS
(
immutableFlags
(
)
)
bool
isArrow
(
)
const
{
return
functionFlags
(
)
.
isArrow
(
)
;
}
bool
allowSuperProperty
(
)
const
{
return
functionFlags
(
)
.
allowSuperProperty
(
)
;
}
bool
isClassConstructor
(
)
const
{
return
functionFlags
(
)
.
isClassConstructor
(
)
;
}
}
;
struct
ScriptStencilRef
{
const
CompilationStencil
&
context_
;
const
ScriptIndex
scriptIndex_
;
inline
const
ScriptStencil
&
scriptData
(
)
const
;
inline
const
ScriptStencilExtra
&
scriptExtra
(
)
const
;
}
;
class
InputScript
{
using
InputScriptStorage
=
mozilla
:
:
Variant
<
BaseScript
*
ScriptStencilRef
>
;
InputScriptStorage
script_
;
public
:
explicit
InputScript
(
BaseScript
*
ptr
)
:
script_
(
ptr
)
{
}
InputScript
(
const
CompilationStencil
&
context
ScriptIndex
scriptIndex
)
:
script_
(
ScriptStencilRef
{
context
scriptIndex
}
)
{
}
const
InputScriptStorage
&
raw
(
)
const
{
return
script_
;
}
InputScriptStorage
&
raw
(
)
{
return
script_
;
}
SourceExtent
extent
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
ptr
-
>
extent
(
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
ref
.
scriptExtra
(
)
.
extent
;
}
)
;
}
ImmutableScriptFlags
immutableFlags
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
ptr
-
>
immutableFlags
(
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
ref
.
scriptExtra
(
)
.
immutableFlags
;
}
)
;
}
RO_IMMUTABLE_SCRIPT_FLAGS
(
immutableFlags
(
)
)
FunctionFlags
functionFlags
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
ptr
-
>
function
(
)
-
>
flags
(
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
ref
.
scriptData
(
)
.
functionFlags
;
}
)
;
}
bool
hasPrivateScriptData
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
ptr
-
>
hasPrivateScriptData
(
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
ref
.
scriptData
(
)
.
hasGCThings
(
)
|
|
ref
.
scriptExtra
(
)
.
useMemberInitializers
(
)
;
}
)
;
}
InputScope
enclosingScope
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
InputScope
(
ptr
-
>
function
(
)
-
>
enclosingScope
(
)
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
MOZ_RELEASE_ASSERT
(
!
ref
.
scriptData
(
)
.
hasSharedData
(
)
)
;
MOZ_ASSERT
(
ref
.
scriptData
(
)
.
hasLazyFunctionEnclosingScopeIndex
(
)
)
;
auto
scopeIndex
=
ref
.
scriptData
(
)
.
lazyFunctionEnclosingScopeIndex
(
)
;
return
InputScope
(
ref
.
context_
scopeIndex
)
;
}
)
;
}
MemberInitializers
getMemberInitializers
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
ptr
-
>
getMemberInitializers
(
)
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
ref
.
scriptExtra
(
)
.
memberInitializers
(
)
;
}
)
;
}
InputName
displayAtom
(
)
const
;
void
trace
(
JSTracer
*
trc
)
;
bool
isNull
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
!
ptr
;
}
[
]
(
const
ScriptStencilRef
&
ref
)
{
return
false
;
}
)
;
}
bool
isStencil
(
)
const
{
return
script_
.
match
(
[
]
(
const
BaseScript
*
ptr
)
{
return
false
;
}
[
]
(
const
ScriptStencilRef
&
)
{
return
true
;
}
)
;
}
;
}
;
class
MOZ_STACK_CLASS
InputScopeIter
{
InputScope
scope_
;
public
:
explicit
InputScopeIter
(
const
InputScope
&
scope
)
:
scope_
(
scope
)
{
}
InputScope
&
scope
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
;
}
const
InputScope
&
scope
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
scope_
;
}
bool
done
(
)
const
{
return
scope_
.
isNull
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
void
operator
+
+
(
int
)
{
scope_
=
scope_
.
enclosing
(
)
;
}
ScopeKind
kind
(
)
const
{
return
scope_
.
kind
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
{
return
scope_
.
hasEnvironment
(
)
&
&
scope_
.
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
void
trace
(
JSTracer
*
trc
)
{
scope_
.
trace
(
trc
)
;
}
}
;
struct
NameStencilRef
{
const
CompilationStencil
&
context_
;
const
TaggedParserAtomIndex
atomIndex_
;
}
;
struct
InputName
{
using
InputNameStorage
=
mozilla
:
:
Variant
<
JSAtom
*
NameStencilRef
>
;
InputNameStorage
variant_
;
InputName
(
Scope
*
JSAtom
*
ptr
)
:
variant_
(
ptr
)
{
}
InputName
(
const
ScopeStencilRef
&
scope
TaggedParserAtomIndex
index
)
:
variant_
(
NameStencilRef
{
scope
.
context_
index
}
)
{
}
InputName
(
BaseScript
*
JSAtom
*
ptr
)
:
variant_
(
ptr
)
{
}
InputName
(
const
ScriptStencilRef
&
script
TaggedParserAtomIndex
index
)
:
variant_
(
NameStencilRef
{
script
.
context_
index
}
)
{
}
TaggedParserAtomIndex
internInto
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
)
;
bool
isEqualTo
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
TaggedParserAtomIndex
other
JSAtom
*
*
otherCached
)
const
;
bool
isNull
(
)
const
{
return
variant_
.
match
(
[
]
(
JSAtom
*
ptr
)
{
return
!
ptr
;
}
[
]
(
const
NameStencilRef
&
ref
)
{
return
!
ref
.
atomIndex_
;
}
)
;
}
}
;
struct
ScopeContext
{
ScopeBindingCache
*
scopeCache
=
nullptr
;
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
=
{
}
;
enum
class
EnclosingLexicalBindingKind
{
Let
Const
CatchParameter
Synthetic
PrivateMethod
}
;
using
EnclosingLexicalBindingCache
=
mozilla
:
:
HashMap
<
TaggedParserAtomIndex
EnclosingLexicalBindingKind
TaggedParserAtomIndexHasher
>
;
mozilla
:
:
Maybe
<
EnclosingLexicalBindingCache
>
enclosingLexicalBindingCache_
;
using
EffectiveScopePrivateFieldCache
=
mozilla
:
:
HashMap
<
TaggedParserAtomIndex
NameLocation
TaggedParserAtomIndexHasher
>
;
mozilla
:
:
Maybe
<
EffectiveScopePrivateFieldCache
>
effectiveScopePrivateFieldCache_
;
#
ifdef
DEBUG
bool
enclosingEnvironmentIsDebugProxy_
=
false
;
#
endif
uint32_t
effectiveScopeHops
=
0
;
uint32_t
enclosingScopeEnvironmentChainLength
=
0
;
uint32_t
enclosingThisEnvironmentHops
=
0
;
ScopeKind
enclosingScopeKind
=
ScopeKind
:
:
Global
;
ThisBinding
thisBinding
=
ThisBinding
:
:
Global
;
bool
allowNewTarget
=
false
;
bool
allowSuperProperty
=
false
;
bool
allowSuperCall
=
false
;
bool
allowArguments
=
true
;
bool
inClass
=
false
;
bool
inWith
=
false
;
bool
enclosingScopeIsArrow
=
false
;
bool
enclosingScopeHasEnvironment
=
false
;
#
ifdef
DEBUG
bool
hasNonSyntacticScopeOnChain
=
false
;
bool
hasFunctionNeedsHomeObjectOnChain
=
false
;
#
endif
bool
init
(
JSContext
*
cx
ErrorContext
*
ec
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
ScopeBindingCache
*
scopeCache
InheritThis
inheritThis
JSObject
*
enclosingEnv
)
;
mozilla
:
:
Maybe
<
EnclosingLexicalBindingKind
>
lookupLexicalBindingInEnclosingScope
(
TaggedParserAtomIndex
name
)
;
NameLocation
searchInEnclosingScope
(
JSContext
*
cx
ErrorContext
*
ec
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
TaggedParserAtomIndex
name
)
;
bool
effectiveScopePrivateFieldCacheHas
(
TaggedParserAtomIndex
name
)
;
mozilla
:
:
Maybe
<
NameLocation
>
getPrivateFieldLocation
(
TaggedParserAtomIndex
name
)
;
private
:
void
computeThisBinding
(
const
InputScope
&
scope
)
;
void
computeThisEnvironment
(
const
InputScope
&
enclosingScope
)
;
void
computeInScope
(
const
InputScope
&
enclosingScope
)
;
void
cacheEnclosingScope
(
const
InputScope
&
enclosingScope
)
;
InputScope
determineEffectiveScope
(
InputScope
&
scope
JSObject
*
environment
)
;
bool
cachePrivateFieldsForEval
(
JSContext
*
cx
ErrorContext
*
ec
CompilationInput
&
input
JSObject
*
enclosingEnvironment
const
InputScope
&
effectiveScope
ParserAtomsTable
&
parserAtoms
)
;
bool
cacheEnclosingScopeBindingForEval
(
JSContext
*
cx
ErrorContext
*
ec
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
)
;
bool
addToEnclosingLexicalBindingCache
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
InputName
&
name
EnclosingLexicalBindingKind
kind
)
;
}
;
struct
CompilationAtomCache
{
public
:
using
AtomCacheVector
=
JS
:
:
GCVector
<
JSString
*
0
js
:
:
SystemAllocPolicy
>
;
private
:
AtomCacheVector
atoms_
;
public
:
JSString
*
getExistingStringAt
(
ParserAtomIndex
index
)
const
;
JSString
*
getExistingStringAt
(
JSContext
*
cx
TaggedParserAtomIndex
taggedIndex
)
const
;
JSString
*
getStringAt
(
ParserAtomIndex
index
)
const
;
JSAtom
*
getExistingAtomAt
(
ParserAtomIndex
index
)
const
;
JSAtom
*
getExistingAtomAt
(
JSContext
*
cx
TaggedParserAtomIndex
taggedIndex
)
const
;
JSAtom
*
getAtomAt
(
ParserAtomIndex
index
)
const
;
bool
hasAtomAt
(
ParserAtomIndex
index
)
const
;
bool
setAtomAt
(
ErrorContext
*
ec
ParserAtomIndex
index
JSString
*
atom
)
;
bool
allocate
(
ErrorContext
*
ec
size_t
length
)
;
bool
empty
(
)
const
{
return
atoms_
.
empty
(
)
;
}
void
stealBuffer
(
AtomCacheVector
&
atoms
)
;
void
releaseBuffer
(
AtomCacheVector
&
atoms
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
atoms_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
CompilationInput
{
enum
class
CompilationTarget
{
Global
SelfHosting
StandaloneFunction
StandaloneFunctionInNonSyntacticScope
Eval
Module
Delazification
}
;
CompilationTarget
target
=
CompilationTarget
:
:
Global
;
const
JS
:
:
ReadOnlyCompileOptions
&
options
;
CompilationAtomCache
atomCache
;
private
:
InputScript
lazy_
=
InputScript
(
nullptr
)
;
public
:
RefPtr
<
ScriptSource
>
source
;
InputScope
enclosingScope
=
InputScope
(
nullptr
)
;
explicit
CompilationInput
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
options
(
options
)
{
}
private
:
bool
initScriptSource
(
JSContext
*
cx
ErrorContext
*
ec
)
;
public
:
bool
initForGlobal
(
JSContext
*
cx
ErrorContext
*
ec
)
{
target
=
CompilationTarget
:
:
Global
;
return
initScriptSource
(
cx
ec
)
;
}
bool
initForSelfHostingGlobal
(
JSContext
*
cx
)
{
target
=
CompilationTarget
:
:
SelfHosting
;
MainThreadErrorContext
ec
(
cx
)
;
return
initScriptSource
(
cx
&
ec
)
;
}
bool
initForStandaloneFunction
(
JSContext
*
cx
ErrorContext
*
ec
)
{
target
=
CompilationTarget
:
:
StandaloneFunction
;
if
(
!
initScriptSource
(
cx
ec
)
)
{
return
false
;
}
enclosingScope
=
InputScope
(
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
return
true
;
}
bool
initForStandaloneFunctionInNonSyntacticScope
(
JSContext
*
cx
ErrorContext
*
ec
Handle
<
Scope
*
>
functionEnclosingScope
)
;
bool
initForEval
(
JSContext
*
cx
ErrorContext
*
ec
Handle
<
Scope
*
>
evalEnclosingScope
)
{
target
=
CompilationTarget
:
:
Eval
;
if
(
!
initScriptSource
(
cx
ec
)
)
{
return
false
;
}
enclosingScope
=
InputScope
(
evalEnclosingScope
)
;
return
true
;
}
bool
initForModule
(
JSContext
*
cx
ErrorContext
*
ec
)
{
target
=
CompilationTarget
:
:
Module
;
if
(
!
initScriptSource
(
cx
ec
)
)
{
return
false
;
}
return
true
;
}
void
initFromLazy
(
JSContext
*
cx
BaseScript
*
lazyScript
ScriptSource
*
ss
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
lazyScript
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
lazyScript
-
>
isReadyForDelazification
(
)
)
;
target
=
CompilationTarget
:
:
Delazification
;
lazy_
=
InputScript
(
lazyScript
)
;
source
=
ss
;
enclosingScope
=
lazy_
.
enclosingScope
(
)
;
}
void
initFromStencil
(
CompilationStencil
&
context
ScriptIndex
scriptIndex
ScriptSource
*
ss
)
{
target
=
CompilationTarget
:
:
Delazification
;
lazy_
=
InputScript
(
context
scriptIndex
)
;
source
=
ss
;
enclosingScope
=
lazy_
.
enclosingScope
(
)
;
}
bool
hasNonDefaultEnclosingScope
(
)
const
{
return
target
=
=
CompilationTarget
:
:
StandaloneFunctionInNonSyntacticScope
|
|
target
=
=
CompilationTarget
:
:
Eval
|
|
target
=
=
CompilationTarget
:
:
Delazification
;
}
InputScope
maybeNonDefaultEnclosingScope
(
)
const
{
if
(
hasNonDefaultEnclosingScope
(
)
)
{
return
enclosingScope
;
}
return
InputScope
(
nullptr
)
;
}
InputScript
lazyOuterScript
(
)
{
return
lazy_
;
}
BaseScript
*
lazyOuterBaseScript
(
)
{
return
lazy_
.
raw
(
)
.
as
<
BaseScript
*
>
(
)
;
}
JSFunction
*
function
(
)
const
{
return
lazy_
.
raw
(
)
.
as
<
BaseScript
*
>
(
)
-
>
function
(
)
;
}
SourceExtent
extent
(
)
const
{
return
lazy_
.
extent
(
)
;
}
ImmutableScriptFlags
immutableFlags
(
)
const
{
return
lazy_
.
immutableFlags
(
)
;
}
RO_IMMUTABLE_SCRIPT_FLAGS
(
immutableFlags
(
)
)
FunctionFlags
functionFlags
(
)
const
{
return
lazy_
.
functionFlags
(
)
;
}
FunctionSyntaxKind
functionSyntaxKind
(
)
const
;
bool
hasPrivateScriptData
(
)
const
{
return
lazy_
.
hasPrivateScriptData
(
)
;
}
bool
isInitialStencil
(
)
{
return
lazy_
.
isNull
(
)
;
}
bool
isDelazifying
(
)
{
return
target
=
=
CompilationTarget
:
:
Delazification
;
}
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
atomCache
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
class
CompilationSyntaxParseCache
{
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
cachedGCThings_
;
mozilla
:
:
Span
<
ScriptStencil
>
cachedScriptData_
;
mozilla
:
:
Span
<
ScriptStencilExtra
>
cachedScriptExtra_
;
mozilla
:
:
Span
<
TaggedParserAtomIndex
>
closedOverBindings_
;
TaggedParserAtomIndex
displayAtom_
;
ScriptStencilExtra
funExtra_
;
#
ifdef
DEBUG
bool
isInitialized
=
false
;
#
endif
public
:
mozilla
:
:
Span
<
TaggedParserAtomIndex
>
closedOverBindings
(
)
const
{
MOZ_ASSERT
(
isInitialized
)
;
return
closedOverBindings_
;
}
const
ScriptStencil
&
scriptData
(
size_t
functionIndex
)
const
{
return
cachedScriptData_
[
scriptIndex
(
functionIndex
)
]
;
}
const
ScriptStencilExtra
&
scriptExtra
(
size_t
functionIndex
)
const
{
return
cachedScriptExtra_
[
scriptIndex
(
functionIndex
)
]
;
}
TaggedParserAtomIndex
displayAtom
(
)
const
{
MOZ_ASSERT
(
isInitialized
)
;
return
displayAtom_
;
}
const
ScriptStencilExtra
&
funExtra
(
)
const
{
MOZ_ASSERT
(
isInitialized
)
;
return
funExtra_
;
}
[
[
nodiscard
]
]
bool
init
(
JSContext
*
cx
ErrorContext
*
ec
LifoAlloc
&
alloc
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
const
InputScript
&
lazy
)
;
private
:
ScriptIndex
scriptIndex
(
size_t
functionIndex
)
const
{
MOZ_ASSERT
(
isInitialized
)
;
auto
taggedScriptIndex
=
cachedGCThings_
[
functionIndex
]
;
MOZ_ASSERT
(
taggedScriptIndex
.
isFunction
(
)
)
;
return
taggedScriptIndex
.
toFunction
(
)
;
}
[
[
nodiscard
]
]
bool
copyFunctionInfo
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
const
InputScript
&
lazy
)
;
[
[
nodiscard
]
]
bool
copyScriptInfo
(
JSContext
*
cx
ErrorContext
*
ec
LifoAlloc
&
alloc
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
BaseScript
*
lazy
)
;
[
[
nodiscard
]
]
bool
copyScriptInfo
(
JSContext
*
cx
ErrorContext
*
ec
LifoAlloc
&
alloc
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
const
ScriptStencilRef
&
lazy
)
;
[
[
nodiscard
]
]
bool
copyClosedOverBindings
(
JSContext
*
cx
ErrorContext
*
ec
LifoAlloc
&
alloc
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
BaseScript
*
lazy
)
;
[
[
nodiscard
]
]
bool
copyClosedOverBindings
(
JSContext
*
cx
ErrorContext
*
ec
LifoAlloc
&
alloc
ParserAtomsTable
&
parseAtoms
CompilationAtomCache
&
atomCache
const
ScriptStencilRef
&
lazy
)
;
}
;
using
StencilAsmJSMap
=
HashMap
<
ScriptIndex
RefPtr
<
const
JS
:
:
WasmModule
>
mozilla
:
:
DefaultHasher
<
ScriptIndex
>
js
:
:
SystemAllocPolicy
>
;
struct
StencilAsmJSContainer
:
public
js
:
:
AtomicRefCounted
<
StencilAsmJSContainer
>
{
StencilAsmJSMap
moduleMap
;
StencilAsmJSContainer
(
)
=
default
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
moduleMap
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
SharedDataContainer
{
using
SingleSharedDataPtr
=
SharedImmutableScriptData
*
;
using
SharedDataVector
=
Vector
<
RefPtr
<
js
:
:
SharedImmutableScriptData
>
0
js
:
:
SystemAllocPolicy
>
;
using
SharedDataVectorPtr
=
SharedDataVector
*
;
using
SharedDataMap
=
HashMap
<
ScriptIndex
RefPtr
<
js
:
:
SharedImmutableScriptData
>
mozilla
:
:
DefaultHasher
<
ScriptIndex
>
js
:
:
SystemAllocPolicy
>
;
using
SharedDataMapPtr
=
SharedDataMap
*
;
private
:
enum
{
SingleTag
=
0
VectorTag
=
1
MapTag
=
2
BorrowTag
=
3
TagMask
=
3
}
;
uintptr_t
data_
=
0
;
public
:
SharedDataContainer
(
)
=
default
;
SharedDataContainer
(
const
SharedDataContainer
&
)
=
delete
;
SharedDataContainer
(
SharedDataContainer
&
&
other
)
noexcept
{
std
:
:
swap
(
data_
other
.
data_
)
;
MOZ_ASSERT
(
other
.
isEmpty
(
)
)
;
}
SharedDataContainer
&
operator
=
(
const
SharedDataContainer
&
)
=
delete
;
SharedDataContainer
&
operator
=
(
SharedDataContainer
&
&
other
)
noexcept
{
std
:
:
swap
(
data_
other
.
data_
)
;
MOZ_ASSERT
(
other
.
isEmpty
(
)
)
;
return
*
this
;
}
~
SharedDataContainer
(
)
;
[
[
nodiscard
]
]
bool
initVector
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
initVector
(
ErrorContext
*
ec
)
;
[
[
nodiscard
]
]
bool
initMap
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
initMap
(
ErrorContext
*
ec
)
;
private
:
[
[
nodiscard
]
]
bool
convertFromSingleToMap
(
ErrorContext
*
ec
)
;
public
:
bool
isEmpty
(
)
const
{
return
(
data_
)
=
=
SingleTag
;
}
bool
isSingle
(
)
const
{
return
(
data_
&
TagMask
)
=
=
SingleTag
;
}
bool
isVector
(
)
const
{
return
(
data_
&
TagMask
)
=
=
VectorTag
;
}
bool
isMap
(
)
const
{
return
(
data_
&
TagMask
)
=
=
MapTag
;
}
bool
isBorrow
(
)
const
{
return
(
data_
&
TagMask
)
=
=
BorrowTag
;
}
void
setSingle
(
already_AddRefed
<
SharedImmutableScriptData
>
&
&
data
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
data_
=
reinterpret_cast
<
uintptr_t
>
(
data
.
take
(
)
)
;
MOZ_ASSERT
(
isSingle
(
)
)
;
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
}
void
setBorrow
(
SharedDataContainer
*
sharedData
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
data_
=
reinterpret_cast
<
uintptr_t
>
(
sharedData
)
|
BorrowTag
;
MOZ_ASSERT
(
isBorrow
(
)
)
;
}
SingleSharedDataPtr
asSingle
(
)
const
{
MOZ_ASSERT
(
isSingle
(
)
)
;
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
static_assert
(
SingleTag
=
=
0
)
;
return
reinterpret_cast
<
SingleSharedDataPtr
>
(
data_
)
;
}
SharedDataVectorPtr
asVector
(
)
const
{
MOZ_ASSERT
(
isVector
(
)
)
;
return
reinterpret_cast
<
SharedDataVectorPtr
>
(
data_
&
~
TagMask
)
;
}
SharedDataMapPtr
asMap
(
)
const
{
MOZ_ASSERT
(
isMap
(
)
)
;
return
reinterpret_cast
<
SharedDataMapPtr
>
(
data_
&
~
TagMask
)
;
}
SharedDataContainer
*
asBorrow
(
)
const
{
MOZ_ASSERT
(
isBorrow
(
)
)
;
return
reinterpret_cast
<
SharedDataContainer
*
>
(
data_
&
~
TagMask
)
;
}
[
[
nodiscard
]
]
bool
prepareStorageFor
(
ErrorContext
*
ec
size_t
nonLazyScriptCount
size_t
allScriptCount
)
;
[
[
nodiscard
]
]
bool
cloneFrom
(
ErrorContext
*
ec
const
SharedDataContainer
&
other
)
;
js
:
:
SharedImmutableScriptData
*
get
(
ScriptIndex
index
)
const
;
[
[
nodiscard
]
]
bool
addAndShare
(
JSContext
*
cx
ErrorContext
*
ec
ScriptIndex
index
js
:
:
SharedImmutableScriptData
*
data
)
;
[
[
nodiscard
]
]
bool
addExtraWithoutShare
(
ErrorContext
*
ec
ScriptIndex
index
js
:
:
SharedImmutableScriptData
*
data
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
if
(
isVector
(
)
)
{
return
asVector
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
if
(
isMap
(
)
)
{
return
asMap
(
)
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
}
MOZ_ASSERT
(
isSingle
(
)
|
|
isBorrow
(
)
)
;
return
0
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
struct
ExtensibleCompilationStencil
;
struct
CompilationStencil
{
friend
struct
ExtensibleCompilationStencil
;
static
constexpr
ScriptIndex
TopLevelIndex
=
ScriptIndex
(
0
)
;
static
constexpr
size_t
LifoAllocChunkSize
=
512
;
mutable
mozilla
:
:
Atomic
<
uintptr_t
>
refCount
{
0
}
;
private
:
UniquePtr
<
ExtensibleCompilationStencil
>
ownedBorrowStencil
;
public
:
enum
class
StorageType
{
Owned
Borrowed
OwnedExtensible
}
;
StorageType
storageType
=
StorageType
:
:
Owned
;
bool
canLazilyParse
=
false
;
using
FunctionKey
=
SourceExtent
:
:
FunctionKey
;
FunctionKey
functionKey
=
SourceExtent
:
:
NullFunctionKey
;
LifoAlloc
alloc
;
RefPtr
<
ScriptSource
>
source
;
mozilla
:
:
Span
<
ScriptStencil
>
scriptData
;
mozilla
:
:
Span
<
ScriptStencilExtra
>
scriptExtra
;
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
gcThingData
;
mozilla
:
:
Span
<
ScopeStencil
>
scopeData
;
mozilla
:
:
Span
<
BaseParserScopeData
*
>
scopeNames
;
mozilla
:
:
Span
<
RegExpStencil
>
regExpData
;
mozilla
:
:
Span
<
BigIntStencil
>
bigIntData
;
mozilla
:
:
Span
<
ObjLiteralStencil
>
objLiteralData
;
ParserAtomSpan
parserAtomData
;
SharedDataContainer
sharedData
;
RefPtr
<
StencilModuleMetadata
>
moduleMetadata
;
RefPtr
<
StencilAsmJSContainer
>
asmJS
;
explicit
CompilationStencil
(
ScriptSource
*
source
)
:
alloc
(
LifoAllocChunkSize
)
source
(
source
)
{
}
explicit
CompilationStencil
(
UniquePtr
<
ExtensibleCompilationStencil
>
&
&
extensibleStencil
)
;
protected
:
void
borrowFromExtensibleCompilationStencil
(
ExtensibleCompilationStencil
&
extensibleStencil
)
;
#
ifdef
DEBUG
void
assertBorrowingFromExtensibleCompilationStencil
(
const
ExtensibleCompilationStencil
&
extensibleStencil
)
const
;
#
endif
public
:
bool
isInitialStencil
(
)
const
{
return
functionKey
=
=
SourceExtent
:
:
NullFunctionKey
;
}
[
[
nodiscard
]
]
static
bool
instantiateStencilAfterPreparation
(
JSContext
*
cx
CompilationInput
&
input
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
[
[
nodiscard
]
]
static
bool
prepareForInstantiate
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
[
[
nodiscard
]
]
static
bool
instantiateStencils
(
JSContext
*
cx
CompilationInput
&
input
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
[
[
nodiscard
]
]
bool
instantiateSelfHostedAtoms
(
JSContext
*
cx
AtomSet
&
atomSet
CompilationAtomCache
&
atomCache
)
const
;
[
[
nodiscard
]
]
JSScript
*
instantiateSelfHostedTopLevelForRealm
(
JSContext
*
cx
CompilationInput
&
input
)
;
[
[
nodiscard
]
]
JSFunction
*
instantiateSelfHostedLazyFunction
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
ScriptIndex
index
Handle
<
JSAtom
*
>
name
)
;
[
[
nodiscard
]
]
bool
delazifySelfHostedFunction
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
ScriptIndexRange
range
HandleFunction
fun
)
;
[
[
nodiscard
]
]
bool
serializeStencils
(
JSContext
*
cx
CompilationInput
&
input
JS
:
:
TranscodeBuffer
&
buf
bool
*
succeededOut
=
nullptr
)
const
;
[
[
nodiscard
]
]
bool
deserializeStencils
(
JSContext
*
cx
CompilationInput
&
input
const
JS
:
:
TranscodeRange
&
range
bool
*
succeededOut
=
nullptr
)
;
CompilationStencil
(
const
CompilationStencil
&
)
=
delete
;
CompilationStencil
(
CompilationStencil
&
&
)
=
delete
;
CompilationStencil
&
operator
=
(
const
CompilationStencil
&
)
=
delete
;
CompilationStencil
&
operator
=
(
CompilationStencil
&
&
)
=
delete
;
#
ifdef
DEBUG
~
CompilationStencil
(
)
{
MOZ_ASSERT
(
!
refCount
)
;
}
#
endif
static
inline
ScriptStencilIterable
functionScriptStencils
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
void
setFunctionKey
(
BaseScript
*
lazy
)
{
functionKey
=
lazy
-
>
extent
(
)
.
toFunctionKey
(
)
;
}
inline
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
const
ParserAtomSpan
&
parserAtomsSpan
(
)
const
{
return
parserAtomData
;
}
bool
isModule
(
)
const
;
bool
hasMultipleReference
(
)
const
{
return
refCount
>
1
;
}
bool
hasOwnedBorrow
(
)
const
{
return
storageType
=
=
StorageType
:
:
OwnedExtensible
;
}
ExtensibleCompilationStencil
*
takeOwnedBorrow
(
)
{
MOZ_ASSERT
(
!
hasMultipleReference
(
)
)
;
MOZ_ASSERT
(
hasOwnedBorrow
(
)
)
;
return
ownedBorrowStencil
.
release
(
)
;
}
#
ifdef
DEBUG
void
assertNoExternalDependency
(
)
const
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpAtom
(
TaggedParserAtomIndex
index
)
const
;
#
endif
}
;
struct
ExtensibleCompilationStencil
{
bool
canLazilyParse
=
false
;
using
FunctionKey
=
SourceExtent
:
:
FunctionKey
;
FunctionKey
functionKey
=
SourceExtent
:
:
NullFunctionKey
;
LifoAlloc
alloc
;
RefPtr
<
ScriptSource
>
source
;
Vector
<
ScriptStencil
1
js
:
:
SystemAllocPolicy
>
scriptData
;
Vector
<
ScriptStencilExtra
0
js
:
:
SystemAllocPolicy
>
scriptExtra
;
Vector
<
TaggedScriptThingIndex
8
js
:
:
SystemAllocPolicy
>
gcThingData
;
Vector
<
ScopeStencil
1
js
:
:
SystemAllocPolicy
>
scopeData
;
Vector
<
BaseParserScopeData
*
1
js
:
:
SystemAllocPolicy
>
scopeNames
;
Vector
<
RegExpStencil
0
js
:
:
SystemAllocPolicy
>
regExpData
;
Vector
<
BigIntStencil
0
js
:
:
SystemAllocPolicy
>
bigIntData
;
Vector
<
ObjLiteralStencil
0
js
:
:
SystemAllocPolicy
>
objLiteralData
;
ParserAtomsTable
parserAtoms
;
SharedDataContainer
sharedData
;
RefPtr
<
StencilModuleMetadata
>
moduleMetadata
;
RefPtr
<
StencilAsmJSContainer
>
asmJS
;
explicit
ExtensibleCompilationStencil
(
JSContext
*
cx
ScriptSource
*
source
)
;
ExtensibleCompilationStencil
(
JSContext
*
cx
CompilationInput
&
input
)
;
ExtensibleCompilationStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
RefPtr
<
ScriptSource
>
source
)
;
ExtensibleCompilationStencil
(
ExtensibleCompilationStencil
&
&
other
)
noexcept
:
canLazilyParse
(
other
.
canLazilyParse
)
functionKey
(
other
.
functionKey
)
alloc
(
CompilationStencil
:
:
LifoAllocChunkSize
)
source
(
std
:
:
move
(
other
.
source
)
)
scriptData
(
std
:
:
move
(
other
.
scriptData
)
)
scriptExtra
(
std
:
:
move
(
other
.
scriptExtra
)
)
gcThingData
(
std
:
:
move
(
other
.
gcThingData
)
)
scopeData
(
std
:
:
move
(
other
.
scopeData
)
)
scopeNames
(
std
:
:
move
(
other
.
scopeNames
)
)
regExpData
(
std
:
:
move
(
other
.
regExpData
)
)
bigIntData
(
std
:
:
move
(
other
.
bigIntData
)
)
objLiteralData
(
std
:
:
move
(
other
.
objLiteralData
)
)
parserAtoms
(
std
:
:
move
(
other
.
parserAtoms
)
)
sharedData
(
std
:
:
move
(
other
.
sharedData
)
)
moduleMetadata
(
std
:
:
move
(
other
.
moduleMetadata
)
)
asmJS
(
std
:
:
move
(
other
.
asmJS
)
)
{
alloc
.
steal
(
&
other
.
alloc
)
;
parserAtoms
.
fixupAlloc
(
alloc
)
;
}
ExtensibleCompilationStencil
&
operator
=
(
ExtensibleCompilationStencil
&
&
other
)
noexcept
{
MOZ_ASSERT
(
alloc
.
isEmpty
(
)
)
;
canLazilyParse
=
other
.
canLazilyParse
;
functionKey
=
other
.
functionKey
;
source
=
std
:
:
move
(
other
.
source
)
;
scriptData
=
std
:
:
move
(
other
.
scriptData
)
;
scriptExtra
=
std
:
:
move
(
other
.
scriptExtra
)
;
gcThingData
=
std
:
:
move
(
other
.
gcThingData
)
;
scopeData
=
std
:
:
move
(
other
.
scopeData
)
;
scopeNames
=
std
:
:
move
(
other
.
scopeNames
)
;
regExpData
=
std
:
:
move
(
other
.
regExpData
)
;
bigIntData
=
std
:
:
move
(
other
.
bigIntData
)
;
objLiteralData
=
std
:
:
move
(
other
.
objLiteralData
)
;
parserAtoms
=
std
:
:
move
(
other
.
parserAtoms
)
;
sharedData
=
std
:
:
move
(
other
.
sharedData
)
;
moduleMetadata
=
std
:
:
move
(
other
.
moduleMetadata
)
;
asmJS
=
std
:
:
move
(
other
.
asmJS
)
;
alloc
.
steal
(
&
other
.
alloc
)
;
parserAtoms
.
fixupAlloc
(
alloc
)
;
return
*
this
;
}
void
setFunctionKey
(
const
SourceExtent
&
extent
)
{
functionKey
=
extent
.
toFunctionKey
(
)
;
}
bool
isInitialStencil
(
)
const
{
return
functionKey
=
=
SourceExtent
:
:
NullFunctionKey
;
}
[
[
nodiscard
]
]
bool
steal
(
ErrorContext
*
ec
RefPtr
<
CompilationStencil
>
&
&
other
)
;
[
[
nodiscard
]
]
bool
cloneFrom
(
ErrorContext
*
ec
const
CompilationStencil
&
other
)
;
[
[
nodiscard
]
]
bool
cloneFrom
(
ErrorContext
*
ec
const
ExtensibleCompilationStencil
&
other
)
;
private
:
template
<
typename
Stencil
>
[
[
nodiscard
]
]
bool
cloneFromImpl
(
ErrorContext
*
ec
const
Stencil
&
other
)
;
public
:
const
ParserAtomVector
&
parserAtomsSpan
(
)
const
{
return
parserAtoms
.
entries
(
)
;
}
bool
isModule
(
)
const
;
inline
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
ifdef
DEBUG
void
assertNoExternalDependency
(
)
const
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
;
void
dumpAtom
(
TaggedParserAtomIndex
index
)
;
#
endif
}
;
struct
MOZ_RAII
CompilationState
:
public
ExtensibleCompilationStencil
{
Directives
directives
;
ScopeContext
scopeContext
;
UsedNameTracker
usedNames
;
LifoAllocScope
&
parserAllocScope
;
CompilationInput
&
input
;
CompilationSyntaxParseCache
previousParseCache
;
size_t
nonLazyFunctionCount
=
0
;
CompilationState
(
JSContext
*
cx
LifoAllocScope
&
parserAllocScope
CompilationInput
&
input
)
;
bool
init
(
JSContext
*
cx
ErrorContext
*
ec
ScopeBindingCache
*
scopeCache
InheritThis
inheritThis
=
InheritThis
:
:
No
JSObject
*
enclosingEnv
=
nullptr
)
{
if
(
!
scopeContext
.
init
(
cx
ec
input
parserAtoms
scopeCache
inheritThis
enclosingEnv
)
)
{
return
false
;
}
if
(
input
.
isDelazifying
(
)
)
{
InputScript
lazy
=
input
.
lazyOuterScript
(
)
;
auto
&
atomCache
=
input
.
atomCache
;
if
(
!
previousParseCache
.
init
(
cx
ec
alloc
parserAtoms
atomCache
lazy
)
)
{
return
false
;
}
}
return
true
;
}
struct
CompilationStatePosition
{
size_t
scriptDataLength
=
0
;
size_t
asmJSCount
=
0
;
}
;
bool
prepareSharedDataStorage
(
ErrorContext
*
ec
)
;
CompilationStatePosition
getPosition
(
)
;
void
rewind
(
const
CompilationStatePosition
&
pos
)
;
void
markGhost
(
const
CompilationStatePosition
&
pos
)
;
bool
allocateGCThingsUninitialized
(
JSContext
*
cx
ErrorContext
*
ec
ScriptIndex
scriptIndex
size_t
length
TaggedScriptThingIndex
*
*
cursor
)
;
bool
appendScriptStencilAndData
(
ErrorContext
*
ec
)
;
bool
appendGCThings
(
JSContext
*
cx
ErrorContext
*
ec
ScriptIndex
scriptIndex
mozilla
:
:
Span
<
const
TaggedScriptThingIndex
>
things
)
;
}
;
class
MOZ_STACK_CLASS
BorrowingCompilationStencil
:
public
CompilationStencil
{
public
:
explicit
BorrowingCompilationStencil
(
ExtensibleCompilationStencil
&
extensibleStencil
)
;
}
;
inline
size_t
CompilationStencil
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
if
(
ownedBorrowStencil
)
{
return
ownedBorrowStencil
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
size_t
moduleMetadataSize
=
moduleMetadata
?
moduleMetadata
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
size_t
asmJSSize
=
asmJS
?
asmJS
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
return
alloc
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
sharedData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
moduleMetadataSize
+
asmJSSize
;
}
inline
size_t
ExtensibleCompilationStencil
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
moduleMetadataSize
=
moduleMetadata
?
moduleMetadata
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
size_t
asmJSSize
=
asmJS
?
asmJS
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
return
alloc
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
scriptData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
scriptExtra
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
gcThingData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
scopeData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
scopeNames
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
regExpData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
bigIntData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
objLiteralData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
parserAtoms
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
sharedData
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
moduleMetadataSize
+
asmJSSize
;
}
struct
CompilationGCOutput
{
JSScript
*
script
=
nullptr
;
ModuleObject
*
module
=
nullptr
;
JS
:
:
GCVector
<
JSFunction
*
1
js
:
:
SystemAllocPolicy
>
functions
;
JS
:
:
GCVector
<
js
:
:
Scope
*
1
js
:
:
SystemAllocPolicy
>
scopes
;
ScriptSourceObject
*
sourceObject
=
nullptr
;
private
:
ScriptIndex
functionsBaseIndex
{
}
;
ScopeIndex
scopesBaseIndex
{
}
;
public
:
CompilationGCOutput
(
)
=
default
;
JSFunction
*
&
getFunction
(
ScriptIndex
index
)
{
return
functions
[
index
-
functionsBaseIndex
]
;
}
JSFunction
*
&
getFunctionNoBaseIndex
(
ScriptIndex
index
)
{
MOZ_ASSERT
(
!
functionsBaseIndex
)
;
return
functions
[
index
]
;
}
js
:
:
Scope
*
&
getScope
(
ScopeIndex
index
)
{
return
scopes
[
index
-
scopesBaseIndex
]
;
}
js
:
:
Scope
*
&
getScopeNoBaseIndex
(
ScopeIndex
index
)
{
MOZ_ASSERT
(
!
scopesBaseIndex
)
;
return
scopes
[
index
]
;
}
js
:
:
Scope
*
getScopeNoBaseIndex
(
ScopeIndex
index
)
const
{
MOZ_ASSERT
(
!
scopesBaseIndex
)
;
return
scopes
[
index
]
;
}
[
[
nodiscard
]
]
bool
ensureReserved
(
ErrorContext
*
ec
size_t
scriptDataLength
size_t
scopeDataLength
)
{
if
(
!
functions
.
reserve
(
scriptDataLength
)
)
{
ReportOutOfMemory
(
ec
)
;
return
false
;
}
if
(
!
scopes
.
reserve
(
scopeDataLength
)
)
{
ReportOutOfMemory
(
ec
)
;
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
ensureReservedWithBaseIndex
(
ErrorContext
*
ec
ScriptIndex
scriptStart
ScriptIndex
scriptLimit
ScopeIndex
scopeStart
ScopeIndex
scopeLimit
)
{
this
-
>
functionsBaseIndex
=
scriptStart
;
this
-
>
scopesBaseIndex
=
scopeStart
;
return
ensureReserved
(
ec
scriptLimit
-
scriptStart
scopeLimit
-
scopeStart
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
functions
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
scopes
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
class
ScriptStencilIterable
{
public
:
class
ScriptAndFunction
{
public
:
const
ScriptStencil
&
script
;
const
ScriptStencilExtra
*
scriptExtra
;
JSFunction
*
function
;
ScriptIndex
index
;
ScriptAndFunction
(
)
=
delete
;
ScriptAndFunction
(
const
ScriptStencil
&
script
const
ScriptStencilExtra
*
scriptExtra
JSFunction
*
function
ScriptIndex
index
)
:
script
(
script
)
scriptExtra
(
scriptExtra
)
function
(
function
)
index
(
index
)
{
}
}
;
class
Iterator
{
size_t
index_
=
0
;
const
CompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
Iterator
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
size_t
index
)
:
index_
(
index
)
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
MOZ_ASSERT
(
index
=
=
stencil
.
scriptData
.
size
(
)
)
;
}
public
:
explicit
Iterator
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
skipTopLevelNonFunction
(
)
;
}
Iterator
operator
+
+
(
)
{
next
(
)
;
assertFunction
(
)
;
return
*
this
;
}
void
next
(
)
{
MOZ_ASSERT
(
index_
<
stencil_
.
scriptData
.
size
(
)
)
;
index_
+
+
;
}
void
assertFunction
(
)
{
if
(
index_
<
stencil_
.
scriptData
.
size
(
)
)
{
MOZ_ASSERT
(
stencil_
.
scriptData
[
index_
]
.
isFunction
(
)
)
;
}
}
void
skipTopLevelNonFunction
(
)
{
MOZ_ASSERT
(
index_
=
=
0
)
;
if
(
stencil_
.
scriptData
.
size
(
)
)
{
if
(
!
stencil_
.
scriptData
[
0
]
.
isFunction
(
)
)
{
next
(
)
;
assertFunction
(
)
;
}
}
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
index_
!
=
other
.
index_
;
}
ScriptAndFunction
operator
*
(
)
{
ScriptIndex
index
=
ScriptIndex
(
index_
)
;
const
ScriptStencil
&
script
=
stencil_
.
scriptData
[
index
]
;
const
ScriptStencilExtra
*
scriptExtra
=
nullptr
;
if
(
stencil_
.
isInitialStencil
(
)
)
{
scriptExtra
=
&
stencil_
.
scriptExtra
[
index
]
;
}
return
ScriptAndFunction
(
script
scriptExtra
gcOutput_
.
getFunctionNoBaseIndex
(
index
)
index
)
;
}
static
Iterator
end
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
{
return
Iterator
(
stencil
gcOutput
stencil
.
scriptData
.
size
(
)
)
;
}
}
;
const
CompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
explicit
ScriptStencilIterable
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
}
Iterator
begin
(
)
const
{
return
Iterator
(
stencil_
gcOutput_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
:
:
end
(
stencil_
gcOutput_
)
;
}
}
;
inline
ScriptStencilIterable
CompilationStencil
:
:
functionScriptStencils
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
{
return
ScriptStencilIterable
(
stencil
gcOutput
)
;
}
struct
CompilationStencilMerger
{
private
:
using
FunctionKey
=
SourceExtent
:
:
FunctionKey
;
UniquePtr
<
ExtensibleCompilationStencil
>
initial_
;
using
FunctionKeyToScriptIndexMap
=
HashMap
<
FunctionKey
ScriptIndex
mozilla
:
:
DefaultHasher
<
FunctionKey
>
js
:
:
SystemAllocPolicy
>
;
FunctionKeyToScriptIndexMap
functionKeyToInitialScriptIndex_
;
[
[
nodiscard
]
]
bool
buildFunctionKeyToIndex
(
ErrorContext
*
ec
)
;
ScriptIndex
getInitialScriptIndexFor
(
const
CompilationStencil
&
delazification
)
const
;
using
AtomIndexMap
=
Vector
<
TaggedParserAtomIndex
0
js
:
:
SystemAllocPolicy
>
;
[
[
nodiscard
]
]
bool
buildAtomIndexMap
(
ErrorContext
*
ec
const
CompilationStencil
&
delazification
AtomIndexMap
&
atomIndexMap
)
;
public
:
CompilationStencilMerger
(
)
=
default
;
[
[
nodiscard
]
]
bool
setInitial
(
JSContext
*
cx
UniquePtr
<
ExtensibleCompilationStencil
>
&
&
initial
)
;
[
[
nodiscard
]
]
bool
setInitial
(
ErrorContext
*
ec
UniquePtr
<
ExtensibleCompilationStencil
>
&
&
initial
)
;
[
[
nodiscard
]
]
bool
addDelazification
(
JSContext
*
cx
const
CompilationStencil
&
delazification
)
;
[
[
nodiscard
]
]
bool
addDelazification
(
ErrorContext
*
ec
const
CompilationStencil
&
delazification
)
;
ExtensibleCompilationStencil
&
getResult
(
)
const
{
return
*
initial_
;
}
UniquePtr
<
ExtensibleCompilationStencil
>
takeResult
(
)
{
return
std
:
:
move
(
initial_
)
;
}
}
;
const
ScopeStencil
&
ScopeStencilRef
:
:
scope
(
)
const
{
return
context_
.
scopeData
[
scopeIndex_
]
;
}
InputScope
InputScope
:
:
enclosing
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
return
InputScope
(
ptr
-
>
enclosing
(
)
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
if
(
ref
.
scope
(
)
.
hasEnclosing
(
)
)
{
return
InputScope
(
ref
.
context_
ref
.
scope
(
)
.
enclosing
(
)
)
;
}
return
InputScope
(
nullptr
)
;
}
)
;
}
FunctionFlags
InputScope
:
:
functionFlags
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
JSFunction
*
fun
=
ptr
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
return
fun
-
>
flags
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
MOZ_ASSERT
(
ref
.
scope
(
)
.
isFunction
(
)
)
;
ScriptIndex
scriptIndex
=
ref
.
scope
(
)
.
functionIndex
(
)
;
ScriptStencil
&
data
=
ref
.
context_
.
scriptData
[
scriptIndex
]
;
return
data
.
functionFlags
;
}
)
;
}
ImmutableScriptFlags
InputScope
:
:
immutableFlags
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
JSFunction
*
fun
=
ptr
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
return
fun
-
>
baseScript
(
)
-
>
immutableFlags
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
MOZ_ASSERT
(
ref
.
scope
(
)
.
isFunction
(
)
)
;
ScriptIndex
scriptIndex
=
ref
.
scope
(
)
.
functionIndex
(
)
;
ScriptStencilExtra
&
extra
=
ref
.
context_
.
scriptExtra
[
scriptIndex
]
;
return
extra
.
immutableFlags
;
}
)
;
}
MemberInitializers
InputScope
:
:
getMemberInitializers
(
)
const
{
return
scope_
.
match
(
[
]
(
const
Scope
*
ptr
)
{
JSFunction
*
fun
=
ptr
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
return
fun
-
>
baseScript
(
)
-
>
getMemberInitializers
(
)
;
}
[
]
(
const
ScopeStencilRef
&
ref
)
{
MOZ_ASSERT
(
ref
.
scope
(
)
.
isFunction
(
)
)
;
ScriptIndex
scriptIndex
=
ref
.
scope
(
)
.
functionIndex
(
)
;
ScriptStencilExtra
&
extra
=
ref
.
context_
.
scriptExtra
[
scriptIndex
]
;
return
extra
.
memberInitializers
(
)
;
}
)
;
}
const
ScriptStencil
&
ScriptStencilRef
:
:
scriptData
(
)
const
{
return
context_
.
scriptData
[
scriptIndex_
]
;
}
const
ScriptStencilExtra
&
ScriptStencilRef
:
:
scriptExtra
(
)
const
{
return
context_
.
scriptExtra
[
scriptIndex_
]
;
}
}
}
#
endif
