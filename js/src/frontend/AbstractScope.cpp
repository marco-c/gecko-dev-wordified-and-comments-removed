#
include
"
frontend
/
AbstractScope
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
GCVariant
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
MutableHandle
<
ScopeCreationData
>
AbstractScope
:
:
scopeCreationData
(
)
const
{
const
Deferred
&
data
=
scope_
.
as
<
Deferred
>
(
)
;
return
data
.
compilationInfo
.
scopeCreationData
[
data
.
index
.
index
]
;
}
bool
AbstractScope
:
:
getOrCreateScope
(
JSContext
*
cx
MutableHandleScope
scope
)
{
if
(
isScopeCreationData
(
)
)
{
MutableHandle
<
ScopeCreationData
>
scd
=
scopeCreationData
(
)
;
if
(
scd
.
get
(
)
.
hasScope
(
)
)
{
scope
.
set
(
scd
.
get
(
)
.
getScope
(
)
)
;
return
true
;
}
scope
.
set
(
scd
.
get
(
)
.
createScope
(
cx
)
)
;
return
scope
;
}
scope
.
set
(
this
-
>
scope
(
)
)
;
return
true
;
}
Scope
*
AbstractScope
:
:
getExistingScope
(
)
const
{
if
(
scope_
.
is
<
HeapPtrScope
>
(
)
)
{
return
scope_
.
as
<
HeapPtrScope
>
(
)
;
}
MOZ_ASSERT
(
isScopeCreationData
(
)
)
;
MOZ_ASSERT
(
scopeCreationData
(
)
.
get
(
)
.
getScope
(
)
)
;
return
scopeCreationData
(
)
.
get
(
)
.
getScope
(
)
;
}
ScopeKind
AbstractScope
:
:
kind
(
)
const
{
MOZ_ASSERT
(
!
isNullptr
(
)
)
;
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
kind
(
)
;
}
return
scope
(
)
-
>
kind
(
)
;
}
AbstractScope
AbstractScope
:
:
enclosing
(
)
const
{
MOZ_ASSERT
(
!
isNullptr
(
)
)
;
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
enclosing
(
)
;
}
return
AbstractScope
(
scope
(
)
-
>
enclosing
(
)
)
;
}
bool
AbstractScope
:
:
hasEnvironment
(
)
const
{
MOZ_ASSERT
(
!
isNullptr
(
)
)
;
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
hasEnvironment
(
)
;
}
return
scope
(
)
-
>
hasEnvironment
(
)
;
}
bool
AbstractScope
:
:
isArrow
(
)
const
{
MOZ_ASSERT
(
is
<
FunctionScope
>
(
)
)
;
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
isArrow
(
)
;
}
return
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
-
>
isArrow
(
)
;
}
JSFunction
*
AbstractScope
:
:
canonicalFunction
(
)
const
{
MOZ_ASSERT
(
is
<
FunctionScope
>
(
)
)
;
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
canonicalFunction
(
)
;
}
return
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
}
uint32_t
AbstractScope
:
:
nextFrameSlot
(
)
const
{
if
(
isScopeCreationData
(
)
)
{
return
scopeCreationData
(
)
.
get
(
)
.
nextFrameSlot
(
)
;
}
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
return
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
FunctionBodyVar
:
return
scope
(
)
-
>
as
<
VarScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
FunctionLexical
:
return
scope
(
)
-
>
as
<
LexicalScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
return
0
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
return
scope
(
)
-
>
as
<
EvalScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
0
;
case
ScopeKind
:
:
Module
:
return
scope
(
)
-
>
as
<
ModuleScope
>
(
)
.
nextFrameSlot
(
)
;
case
ScopeKind
:
:
WasmInstance
:
MOZ_CRASH
(
"
WasmInstanceScope
doesn
'
t
have
nextFrameSlot
(
)
"
)
;
return
0
;
case
ScopeKind
:
:
WasmFunction
:
MOZ_CRASH
(
"
WasmFunctionScope
doesn
'
t
have
nextFrameSlot
(
)
"
)
;
return
0
;
case
ScopeKind
:
:
With
:
MOZ_CRASH
(
"
With
Scopes
don
'
t
get
nextFrameSlot
(
)
"
)
;
return
0
;
}
MOZ_CRASH
(
"
Not
an
enclosing
intra
-
frame
scope
"
)
;
}
void
AbstractScope
:
:
trace
(
JSTracer
*
trc
)
{
JS
:
:
GCPolicy
<
ScopeType
>
:
:
trace
(
trc
&
scope_
"
AbstractScope
"
)
;
}
bool
AbstractScopeIter
:
:
hasSyntacticEnvironment
(
)
const
{
return
abstractScope
(
)
.
hasEnvironment
(
)
&
&
abstractScope
(
)
.
kind
(
)
!
=
ScopeKind
:
:
NonSyntactic
;
}
