#
include
"
frontend
/
IfEmitter
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
BranchEmitterBase
:
:
BranchEmitterBase
(
BytecodeEmitter
*
bce
LexicalKind
lexicalKind
)
:
bce_
(
bce
)
lexicalKind_
(
lexicalKind
)
{
}
IfEmitter
:
:
IfEmitter
(
BytecodeEmitter
*
bce
LexicalKind
lexicalKind
)
:
BranchEmitterBase
(
bce
lexicalKind
)
{
}
IfEmitter
:
:
IfEmitter
(
BytecodeEmitter
*
bce
)
:
IfEmitter
(
bce
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
}
bool
BranchEmitterBase
:
:
emitThenInternal
(
ConditionKind
conditionKind
)
{
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
tdzCache_
.
reset
(
)
;
}
JSOp
op
=
conditionKind
=
=
ConditionKind
:
:
Positive
?
JSOp
:
:
JumpIfFalse
:
JSOp
:
:
JumpIfTrue
;
if
(
!
bce_
-
>
emitJump
(
op
&
jumpAroundThen_
)
)
{
return
false
;
}
thenDepth_
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
;
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
tdzCache_
.
emplace
(
bce_
)
;
}
return
true
;
}
void
BranchEmitterBase
:
:
calculateOrCheckPushed
(
)
{
#
ifdef
DEBUG
if
(
!
calculatedPushed_
)
{
pushed_
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
-
thenDepth_
;
calculatedPushed_
=
true
;
}
else
{
MOZ_ASSERT
(
pushed_
=
=
bce_
-
>
bytecodeSection
(
)
.
stackDepth
(
)
-
thenDepth_
)
;
}
#
endif
}
bool
BranchEmitterBase
:
:
emitElseInternal
(
)
{
calculateOrCheckPushed
(
)
;
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT
(
tdzCache_
.
isSome
(
)
)
;
tdzCache_
.
reset
(
)
;
}
if
(
!
bce_
-
>
emitJump
(
JSOp
:
:
Goto
&
jumpsAroundElse_
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpAroundThen_
)
)
{
return
false
;
}
jumpAroundThen_
=
JumpList
(
)
;
bce_
-
>
bytecodeSection
(
)
.
setStackDepth
(
thenDepth_
)
;
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
tdzCache_
.
emplace
(
bce_
)
;
}
return
true
;
}
bool
BranchEmitterBase
:
:
emitEndInternal
(
)
{
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT
(
tdzCache_
.
isSome
(
)
)
;
tdzCache_
.
reset
(
)
;
}
calculateOrCheckPushed
(
)
;
if
(
jumpAroundThen_
.
offset
.
valid
(
)
)
{
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpAroundThen_
)
)
{
return
false
;
}
}
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpsAroundElse_
)
)
{
return
false
;
}
return
true
;
}
bool
IfEmitter
:
:
emitIf
(
const
Maybe
<
uint32_t
>
&
ifPos
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
)
;
if
(
ifPos
)
{
if
(
!
bce_
-
>
updateSourceCoordNotes
(
*
ifPos
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
If
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitThen
(
ConditionKind
conditionKind
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
If
|
|
state_
=
=
State
:
:
ElseIf
)
;
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
ElseIf
tdzCache_
.
isSome
(
)
)
;
MOZ_ASSERT_IF
(
state_
!
=
State
:
:
ElseIf
tdzCache_
.
isNothing
(
)
)
;
}
if
(
!
emitThenInternal
(
conditionKind
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
Then
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitThenElse
(
ConditionKind
conditionKind
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
If
|
|
state_
=
=
State
:
:
ElseIf
)
;
if
(
lexicalKind_
=
=
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
ElseIf
tdzCache_
.
isSome
(
)
)
;
MOZ_ASSERT_IF
(
state_
!
=
State
:
:
ElseIf
tdzCache_
.
isNothing
(
)
)
;
}
if
(
!
emitThenInternal
(
conditionKind
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
ThenElse
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitElseIf
(
const
Maybe
<
uint32_t
>
&
ifPos
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
ThenElse
)
;
if
(
!
emitElseInternal
(
)
)
{
return
false
;
}
if
(
ifPos
)
{
if
(
!
bce_
-
>
updateSourceCoordNotes
(
*
ifPos
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
state_
=
State
:
:
ElseIf
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitElse
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
ThenElse
)
;
if
(
!
emitElseInternal
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
Else
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Then
|
|
state_
=
=
State
:
:
Else
)
;
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
Then
jumpAroundThen_
.
offset
.
valid
(
)
)
;
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
Else
!
jumpAroundThen_
.
offset
.
valid
(
)
)
;
if
(
!
emitEndInternal
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
End
;
#
endif
return
true
;
}
InternalIfEmitter
:
:
InternalIfEmitter
(
BytecodeEmitter
*
bce
)
:
IfEmitter
(
bce
LexicalKind
:
:
NoLexicalAccessInBranch
)
{
#
ifdef
DEBUG
state_
=
State
:
:
If
;
#
endif
}
CondEmitter
:
:
CondEmitter
(
BytecodeEmitter
*
bce
)
:
BranchEmitterBase
(
bce
LexicalKind
:
:
MayContainLexicalAccessInBranch
)
{
}
bool
CondEmitter
:
:
emitCond
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
)
;
#
ifdef
DEBUG
state_
=
State
:
:
Cond
;
#
endif
return
true
;
}
bool
CondEmitter
:
:
emitThenElse
(
ConditionKind
conditionKind
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Cond
)
;
if
(
!
emitThenInternal
(
conditionKind
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
ThenElse
;
#
endif
return
true
;
}
bool
CondEmitter
:
:
emitElse
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
ThenElse
)
;
if
(
!
emitElseInternal
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
Else
;
#
endif
return
true
;
}
bool
CondEmitter
:
:
emitEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Else
)
;
MOZ_ASSERT
(
!
jumpAroundThen_
.
offset
.
valid
(
)
)
;
if
(
!
emitEndInternal
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
state_
=
State
:
:
End
;
#
endif
return
true
;
}
