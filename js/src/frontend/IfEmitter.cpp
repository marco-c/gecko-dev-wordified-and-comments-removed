#
include
"
frontend
/
IfEmitter
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
IfEmitter
:
:
IfEmitter
(
BytecodeEmitter
*
bce
Kind
kind
)
:
bce_
(
bce
)
thenDepth_
(
0
)
kind_
(
kind
)
#
ifdef
DEBUG
pushed_
(
0
)
calculatedPushed_
(
false
)
state_
(
State
:
:
Start
)
#
endif
{
}
IfEmitter
:
:
IfEmitter
(
BytecodeEmitter
*
bce
)
:
IfEmitter
(
bce
Kind
:
:
MayContainLexicalAccessInBranch
)
{
}
bool
IfEmitter
:
:
emitIfInternal
(
SrcNoteType
type
)
{
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
ElseIf
tdzCache_
.
isSome
(
)
)
;
MOZ_ASSERT_IF
(
state_
!
=
State
:
:
ElseIf
tdzCache_
.
isNothing
(
)
)
;
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
tdzCache_
.
reset
(
)
;
if
(
!
bce_
-
>
newSrcNote
(
type
)
)
return
false
;
if
(
!
bce_
-
>
emitJump
(
JSOP_IFEQ
&
jumpAroundThen_
)
)
return
false
;
#
ifdef
DEBUG
thenDepth_
=
bce_
-
>
stackDepth
;
#
else
if
(
type
=
=
SRC_COND
|
|
type
=
=
SRC_IF_ELSE
)
thenDepth_
=
bce_
-
>
stackDepth
;
#
endif
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
tdzCache_
.
emplace
(
bce_
)
;
return
true
;
}
void
IfEmitter
:
:
calculateOrCheckPushed
(
)
{
#
ifdef
DEBUG
if
(
!
calculatedPushed_
)
{
pushed_
=
bce_
-
>
stackDepth
-
thenDepth_
;
calculatedPushed_
=
true
;
}
else
{
MOZ_ASSERT
(
pushed_
=
=
bce_
-
>
stackDepth
-
thenDepth_
)
;
}
#
endif
}
bool
IfEmitter
:
:
emitThen
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
|
|
state_
=
=
State
:
:
ElseIf
)
;
if
(
!
emitIfInternal
(
SRC_IF
)
)
return
false
;
#
ifdef
DEBUG
state_
=
State
:
:
Then
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitCond
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
)
;
if
(
!
emitIfInternal
(
SRC_COND
)
)
return
false
;
#
ifdef
DEBUG
state_
=
State
:
:
Cond
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitThenElse
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Start
|
|
state_
=
=
State
:
:
ElseIf
)
;
if
(
!
emitIfInternal
(
SRC_IF_ELSE
)
)
return
false
;
#
ifdef
DEBUG
state_
=
State
:
:
ThenElse
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitElseInternal
(
)
{
calculateOrCheckPushed
(
)
;
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT
(
tdzCache_
.
isSome
(
)
)
;
tdzCache_
.
reset
(
)
;
}
if
(
!
bce_
-
>
emitJump
(
JSOP_GOTO
&
jumpsAroundElse_
)
)
return
false
;
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpAroundThen_
)
)
return
false
;
jumpAroundThen_
=
JumpList
(
)
;
bce_
-
>
stackDepth
=
thenDepth_
;
#
ifdef
DEBUG
state_
=
State
:
:
Else
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitElse
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
ThenElse
|
|
state_
=
=
State
:
:
Cond
)
;
if
(
!
emitElseInternal
(
)
)
return
false
;
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
tdzCache_
.
emplace
(
bce_
)
;
#
ifdef
DEBUG
state_
=
State
:
:
Else
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitElseIf
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
ThenElse
)
;
if
(
!
emitElseInternal
(
)
)
return
false
;
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
tdzCache_
.
emplace
(
bce_
)
;
#
ifdef
DEBUG
state_
=
State
:
:
ElseIf
;
#
endif
return
true
;
}
bool
IfEmitter
:
:
emitEnd
(
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Then
|
|
state_
=
=
State
:
:
Else
)
;
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
Then
jumpAroundThen_
.
offset
!
=
-
1
)
;
MOZ_ASSERT_IF
(
state_
=
=
State
:
:
Else
jumpAroundThen_
.
offset
=
=
-
1
)
;
if
(
kind_
=
=
Kind
:
:
MayContainLexicalAccessInBranch
)
{
MOZ_ASSERT
(
tdzCache_
.
isSome
(
)
)
;
tdzCache_
.
reset
(
)
;
}
calculateOrCheckPushed
(
)
;
if
(
jumpAroundThen_
.
offset
!
=
-
1
)
{
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpAroundThen_
)
)
return
false
;
}
if
(
!
bce_
-
>
emitJumpTargetAndPatch
(
jumpsAroundElse_
)
)
return
false
;
#
ifdef
DEBUG
state_
=
State
:
:
End
;
#
endif
return
true
;
}
InternalIfEmitter
:
:
InternalIfEmitter
(
BytecodeEmitter
*
bce
)
:
IfEmitter
(
bce
Kind
:
:
NoLexicalAccessInBranch
)
{
}
