#
ifndef
frontend_BinASTTokenReaderMultipart_h
#
define
frontend_BinASTTokenReaderMultipart_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
Result
.
h
"
namespace
js
{
namespace
frontend
{
class
MOZ_STACK_CLASS
BinASTTokenReaderMultipart
:
public
BinASTTokenReaderBase
{
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Context
=
BinASTTokenReaderBase
:
:
Context
;
using
RootContext
=
BinASTTokenReaderBase
:
:
RootContext
;
using
ListContext
=
BinASTTokenReaderBase
:
:
ListContext
;
using
FieldContext
=
BinASTTokenReaderBase
:
:
FieldContext
;
class
BinASTFields
{
public
:
explicit
BinASTFields
(
JSContext
*
)
{
}
}
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderMultipart
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderMultipart
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderMultipart
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
FieldContext
&
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
)
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
ListContext
&
context
)
{
return
readVariant
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
FieldContext
&
context
)
{
return
readVariant
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
ListContext
&
AutoList
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderMultipart
:
:
BinASTFields
&
fields
const
Context
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderMultipart
:
:
BinASTFields
&
fields
const
RootContext
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderMultipart
:
:
BinASTFields
&
fields
const
ListContext
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderMultipart
:
:
BinASTFields
&
fields
const
FieldContext
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
FieldContext
&
)
{
return
readInternalUint32
(
)
;
}
private
:
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readInternalUint32
(
)
;
private
:
js
:
:
HashMap
<
uint32_t
BinASTVariant
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
variantsTable_
;
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadata
*
metadata_
;
const
uint8_t
*
posBeforeTree_
;
BinASTTokenReaderMultipart
(
const
BinASTTokenReaderMultipart
&
)
=
delete
;
BinASTTokenReaderMultipart
(
BinASTTokenReaderMultipart
&
&
)
=
delete
;
BinASTTokenReaderMultipart
&
operator
=
(
BinASTTokenReaderMultipart
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderMultipart
&
reader
)
;
~
AutoBase
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkPosition
(
const
uint8_t
*
expectedPosition
)
;
friend
BinASTTokenReaderMultipart
;
void
init
(
)
;
bool
initialized_
;
BinASTTokenReaderMultipart
&
reader_
;
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderMultipart
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
protected
:
friend
BinASTTokenReaderMultipart
;
void
init
(
)
;
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderMultipart
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
template
<
size_t
N
>
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields
(
const
BinASTKind
kind
const
BinASTFields
&
actual
const
BinASTField
(
&
expected
)
[
N
]
)
{
return
Ok
(
)
;
}
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields0
(
const
BinASTKind
kind
const
BinASTFields
&
actual
)
{
return
Ok
(
)
;
}
}
;
}
}
#
endif
