#
ifndef
frontend_ObjLiteral_h
#
define
frontend_ObjLiteral_h
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
class
LifoAlloc
;
class
JSONPrinter
;
namespace
frontend
{
struct
CompilationAtomCache
;
struct
CompilationStencil
;
class
StencilXDR
;
}
enum
class
ObjLiteralOpcode
:
uint8_t
{
INVALID
=
0
ConstValue
=
1
ConstAtom
=
2
Null
=
3
Undefined
=
4
True
=
5
False
=
6
MAX
=
False
}
;
enum
class
ObjLiteralFlag
:
uint8_t
{
Array
=
1
Singleton
=
2
HasIndexOrDuplicatePropName
=
3
}
;
using
ObjLiteralFlags
=
mozilla
:
:
EnumSet
<
ObjLiteralFlag
>
;
inline
bool
ObjLiteralOpcodeHasValueArg
(
ObjLiteralOpcode
op
)
{
return
op
=
=
ObjLiteralOpcode
:
:
ConstValue
;
}
inline
bool
ObjLiteralOpcodeHasAtomArg
(
ObjLiteralOpcode
op
)
{
return
op
=
=
ObjLiteralOpcode
:
:
ConstAtom
;
}
struct
ObjLiteralReaderBase
;
struct
ObjLiteralKey
{
private
:
uint32_t
value_
;
enum
ObjLiteralKeyType
{
None
AtomIndex
ArrayIndex
}
;
ObjLiteralKeyType
type_
;
ObjLiteralKey
(
uint32_t
value
ObjLiteralKeyType
ty
)
:
value_
(
value
)
type_
(
ty
)
{
}
public
:
ObjLiteralKey
(
)
:
ObjLiteralKey
(
0
None
)
{
}
ObjLiteralKey
(
uint32_t
value
bool
isArrayIndex
)
:
ObjLiteralKey
(
value
isArrayIndex
?
ArrayIndex
:
AtomIndex
)
{
}
ObjLiteralKey
(
const
ObjLiteralKey
&
other
)
=
default
;
static
ObjLiteralKey
fromPropName
(
frontend
:
:
TaggedParserAtomIndex
atomIndex
)
{
return
ObjLiteralKey
(
atomIndex
.
rawData
(
)
false
)
;
}
static
ObjLiteralKey
fromArrayIndex
(
uint32_t
index
)
{
return
ObjLiteralKey
(
index
true
)
;
}
static
ObjLiteralKey
none
(
)
{
return
ObjLiteralKey
(
)
;
}
bool
isNone
(
)
const
{
return
type_
=
=
None
;
}
bool
isAtomIndex
(
)
const
{
return
type_
=
=
AtomIndex
;
}
bool
isArrayIndex
(
)
const
{
return
type_
=
=
ArrayIndex
;
}
frontend
:
:
TaggedParserAtomIndex
getAtomIndex
(
)
const
{
MOZ_ASSERT
(
isAtomIndex
(
)
)
;
return
frontend
:
:
TaggedParserAtomIndex
:
:
fromRaw
(
value_
)
;
}
uint32_t
getArrayIndex
(
)
const
{
MOZ_ASSERT
(
isArrayIndex
(
)
)
;
return
value_
;
}
uint32_t
rawIndex
(
)
const
{
return
value_
;
}
}
;
struct
ObjLiteralWriterBase
{
protected
:
friend
struct
ObjLiteralReaderBase
;
static
const
uint32_t
ATOM_INDEX_MASK
=
0x7fffffff
;
static
const
uint32_t
INDEXED_PROP
=
0x80000000
;
public
:
using
CodeVector
=
Vector
<
uint8_t
64
js
:
:
SystemAllocPolicy
>
;
protected
:
CodeVector
code_
;
public
:
ObjLiteralWriterBase
(
)
=
default
;
uint32_t
curOffset
(
)
const
{
return
code_
.
length
(
)
;
}
private
:
[
[
nodiscard
]
]
bool
pushByte
(
JSContext
*
cx
uint8_t
data
)
{
if
(
!
code_
.
append
(
data
)
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
prepareBytes
(
JSContext
*
cx
size_t
len
uint8_t
*
*
p
)
{
size_t
offset
=
code_
.
length
(
)
;
if
(
!
code_
.
growByUninitialized
(
len
)
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
false
;
}
*
p
=
&
code_
[
offset
]
;
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
pushRawData
(
JSContext
*
cx
T
data
)
{
uint8_t
*
p
=
nullptr
;
if
(
!
prepareBytes
(
cx
sizeof
(
T
)
&
p
)
)
{
return
false
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapToLittleEndian
(
reinterpret_cast
<
void
*
>
(
p
)
&
data
1
)
;
return
true
;
}
protected
:
[
[
nodiscard
]
]
bool
pushOpAndName
(
JSContext
*
cx
ObjLiteralOpcode
op
ObjLiteralKey
key
)
{
uint8_t
opdata
=
static_cast
<
uint8_t
>
(
op
)
;
uint32_t
data
=
key
.
rawIndex
(
)
|
(
key
.
isArrayIndex
(
)
?
INDEXED_PROP
:
0
)
;
return
pushByte
(
cx
opdata
)
&
&
pushRawData
(
cx
data
)
;
}
[
[
nodiscard
]
]
bool
pushValueArg
(
JSContext
*
cx
const
JS
:
:
Value
&
value
)
{
MOZ_ASSERT
(
value
.
isNumber
(
)
|
|
value
.
isNullOrUndefined
(
)
|
|
value
.
isBoolean
(
)
)
;
uint64_t
data
=
value
.
asRawBits
(
)
;
return
pushRawData
(
cx
data
)
;
}
[
[
nodiscard
]
]
bool
pushAtomArg
(
JSContext
*
cx
frontend
:
:
TaggedParserAtomIndex
atomIndex
)
{
return
pushRawData
(
cx
atomIndex
.
rawData
(
)
)
;
}
}
;
struct
ObjLiteralWriter
:
private
ObjLiteralWriterBase
{
public
:
ObjLiteralWriter
(
)
=
default
;
void
clear
(
)
{
code_
.
clear
(
)
;
}
using
CodeVector
=
typename
ObjLiteralWriterBase
:
:
CodeVector
;
bool
checkForDuplicatedNames
(
JSContext
*
cx
)
;
mozilla
:
:
Span
<
const
uint8_t
>
getCode
(
)
const
{
return
code_
;
}
ObjLiteralFlags
getFlags
(
)
const
{
return
flags_
;
}
uint32_t
getPropertyCount
(
)
const
{
return
propertyCount_
;
}
void
beginObject
(
ObjLiteralFlags
flags
)
{
flags_
=
flags
;
}
bool
setPropName
(
JSContext
*
cx
frontend
:
:
ParserAtomsTable
&
parserAtoms
const
frontend
:
:
TaggedParserAtomIndex
propName
)
{
setPropNameNoDuplicateCheck
(
parserAtoms
propName
)
;
if
(
flags_
.
contains
(
ObjLiteralFlag
:
:
HasIndexOrDuplicatePropName
)
)
{
return
true
;
}
if
(
mightContainDuplicatePropertyNames_
)
{
return
true
;
}
if
(
propNamesFilter_
.
mightContain
(
propName
.
rawData
(
)
)
)
{
mightContainDuplicatePropertyNames_
=
true
;
}
else
{
propNamesFilter_
.
add
(
propName
.
rawData
(
)
)
;
}
return
true
;
}
void
setPropNameNoDuplicateCheck
(
frontend
:
:
ParserAtomsTable
&
parserAtoms
const
frontend
:
:
TaggedParserAtomIndex
propName
)
{
MOZ_ASSERT
(
!
flags_
.
contains
(
ObjLiteralFlag
:
:
Array
)
)
;
parserAtoms
.
markUsedByStencil
(
propName
)
;
nextKey_
=
ObjLiteralKey
:
:
fromPropName
(
propName
)
;
}
void
setPropIndex
(
uint32_t
propIndex
)
{
MOZ_ASSERT
(
!
flags_
.
contains
(
ObjLiteralFlag
:
:
Array
)
)
;
MOZ_ASSERT
(
propIndex
<
=
ATOM_INDEX_MASK
)
;
nextKey_
=
ObjLiteralKey
:
:
fromArrayIndex
(
propIndex
)
;
flags_
+
=
ObjLiteralFlag
:
:
HasIndexOrDuplicatePropName
;
}
void
beginDenseArrayElements
(
)
{
MOZ_ASSERT
(
flags_
.
contains
(
ObjLiteralFlag
:
:
Array
)
)
;
nextKey_
=
ObjLiteralKey
:
:
none
(
)
;
}
[
[
nodiscard
]
]
bool
propWithConstNumericValue
(
JSContext
*
cx
const
JS
:
:
Value
&
value
)
{
propertyCount_
+
+
;
MOZ_ASSERT
(
value
.
isNumber
(
)
)
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
ConstValue
nextKey_
)
&
&
pushValueArg
(
cx
value
)
;
}
[
[
nodiscard
]
]
bool
propWithAtomValue
(
JSContext
*
cx
frontend
:
:
ParserAtomsTable
&
parserAtoms
const
frontend
:
:
TaggedParserAtomIndex
value
)
{
propertyCount_
+
+
;
parserAtoms
.
markUsedByStencil
(
value
)
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
ConstAtom
nextKey_
)
&
&
pushAtomArg
(
cx
value
)
;
}
[
[
nodiscard
]
]
bool
propWithNullValue
(
JSContext
*
cx
)
{
propertyCount_
+
+
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
Null
nextKey_
)
;
}
[
[
nodiscard
]
]
bool
propWithUndefinedValue
(
JSContext
*
cx
)
{
propertyCount_
+
+
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
Undefined
nextKey_
)
;
}
[
[
nodiscard
]
]
bool
propWithTrueValue
(
JSContext
*
cx
)
{
propertyCount_
+
+
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
True
nextKey_
)
;
}
[
[
nodiscard
]
]
bool
propWithFalseValue
(
JSContext
*
cx
)
{
propertyCount_
+
+
;
return
pushOpAndName
(
cx
ObjLiteralOpcode
:
:
False
nextKey_
)
;
}
static
bool
arrayIndexInRange
(
int32_t
i
)
{
return
i
>
=
0
&
&
static_cast
<
uint32_t
>
(
i
)
<
=
ATOM_INDEX_MASK
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
frontend
:
:
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
frontend
:
:
CompilationStencil
*
stencil
)
const
;
#
endif
private
:
bool
mightContainDuplicatePropertyNames_
=
false
;
ObjLiteralFlags
flags_
;
ObjLiteralKey
nextKey_
;
uint32_t
propertyCount_
=
0
;
mozilla
:
:
BitBloomFilter
<
12
frontend
:
:
TaggedParserAtomIndex
>
propNamesFilter_
;
}
;
struct
ObjLiteralReaderBase
{
private
:
mozilla
:
:
Span
<
const
uint8_t
>
data_
;
size_t
cursor_
;
[
[
nodiscard
]
]
bool
readByte
(
uint8_t
*
b
)
{
if
(
cursor_
+
1
>
data_
.
Length
(
)
)
{
return
false
;
}
*
b
=
*
data_
.
From
(
cursor_
)
.
data
(
)
;
cursor_
+
=
1
;
return
true
;
}
[
[
nodiscard
]
]
bool
readBytes
(
size_t
size
const
uint8_t
*
*
p
)
{
if
(
cursor_
+
size
>
data_
.
Length
(
)
)
{
return
false
;
}
*
p
=
data_
.
From
(
cursor_
)
.
data
(
)
;
cursor_
+
=
size
;
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
readRawData
(
T
*
data
)
{
const
uint8_t
*
p
=
nullptr
;
if
(
!
readBytes
(
sizeof
(
T
)
&
p
)
)
{
return
false
;
}
mozilla
:
:
NativeEndian
:
:
copyAndSwapFromLittleEndian
(
data
reinterpret_cast
<
const
void
*
>
(
p
)
1
)
;
return
true
;
}
public
:
explicit
ObjLiteralReaderBase
(
mozilla
:
:
Span
<
const
uint8_t
>
data
)
:
data_
(
data
)
cursor_
(
0
)
{
}
[
[
nodiscard
]
]
bool
readOpAndKey
(
ObjLiteralOpcode
*
op
ObjLiteralKey
*
key
)
{
uint8_t
opbyte
;
if
(
!
readByte
(
&
opbyte
)
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
opbyte
>
static_cast
<
uint8_t
>
(
ObjLiteralOpcode
:
:
MAX
)
)
)
{
return
false
;
}
*
op
=
static_cast
<
ObjLiteralOpcode
>
(
opbyte
)
;
uint32_t
data
;
if
(
!
readRawData
(
&
data
)
)
{
return
false
;
}
bool
isArray
=
data
&
ObjLiteralWriterBase
:
:
INDEXED_PROP
;
uint32_t
rawIndex
=
data
&
~
ObjLiteralWriterBase
:
:
INDEXED_PROP
;
*
key
=
ObjLiteralKey
(
rawIndex
isArray
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
readValueArg
(
JS
:
:
Value
*
value
)
{
uint64_t
data
;
if
(
!
readRawData
(
&
data
)
)
{
return
false
;
}
*
value
=
JS
:
:
Value
:
:
fromRawBits
(
data
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
readAtomArg
(
frontend
:
:
TaggedParserAtomIndex
*
atomIndex
)
{
return
readRawData
(
atomIndex
-
>
rawDataRef
(
)
)
;
}
size_t
cursor
(
)
const
{
return
cursor_
;
}
}
;
struct
ObjLiteralInsn
{
private
:
ObjLiteralOpcode
op_
;
ObjLiteralKey
key_
;
union
Arg
{
explicit
Arg
(
uint64_t
raw_
)
:
raw
(
raw_
)
{
}
JS
:
:
Value
constValue
;
frontend
:
:
TaggedParserAtomIndex
atomIndex
;
uint64_t
raw
;
}
arg_
;
public
:
ObjLiteralInsn
(
)
:
op_
(
ObjLiteralOpcode
:
:
INVALID
)
arg_
(
0
)
{
}
ObjLiteralInsn
(
ObjLiteralOpcode
op
ObjLiteralKey
key
)
:
op_
(
op
)
key_
(
key
)
arg_
(
0
)
{
MOZ_ASSERT
(
!
hasConstValue
(
)
)
;
MOZ_ASSERT
(
!
hasAtomIndex
(
)
)
;
}
ObjLiteralInsn
(
ObjLiteralOpcode
op
ObjLiteralKey
key
const
JS
:
:
Value
&
value
)
:
op_
(
op
)
key_
(
key
)
arg_
(
0
)
{
MOZ_ASSERT
(
hasConstValue
(
)
)
;
MOZ_ASSERT
(
!
hasAtomIndex
(
)
)
;
arg_
.
constValue
=
value
;
}
ObjLiteralInsn
(
ObjLiteralOpcode
op
ObjLiteralKey
key
frontend
:
:
TaggedParserAtomIndex
atomIndex
)
:
op_
(
op
)
key_
(
key
)
arg_
(
0
)
{
MOZ_ASSERT
(
!
hasConstValue
(
)
)
;
MOZ_ASSERT
(
hasAtomIndex
(
)
)
;
arg_
.
atomIndex
=
atomIndex
;
}
ObjLiteralInsn
(
const
ObjLiteralInsn
&
other
)
:
ObjLiteralInsn
(
)
{
*
this
=
other
;
}
ObjLiteralInsn
&
operator
=
(
const
ObjLiteralInsn
&
other
)
{
op_
=
other
.
op_
;
key_
=
other
.
key_
;
arg_
.
raw
=
other
.
arg_
.
raw
;
return
*
this
;
}
bool
isValid
(
)
const
{
return
op_
>
ObjLiteralOpcode
:
:
INVALID
&
&
op_
<
=
ObjLiteralOpcode
:
:
MAX
;
}
ObjLiteralOpcode
getOp
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
op_
;
}
const
ObjLiteralKey
&
getKey
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
key_
;
}
bool
hasConstValue
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
ObjLiteralOpcodeHasValueArg
(
op_
)
;
}
bool
hasAtomIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
ObjLiteralOpcodeHasAtomArg
(
op_
)
;
}
JS
:
:
Value
getConstValue
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
MOZ_ASSERT
(
hasConstValue
(
)
)
;
return
arg_
.
constValue
;
}
frontend
:
:
TaggedParserAtomIndex
getAtomIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
MOZ_ASSERT
(
hasAtomIndex
(
)
)
;
return
arg_
.
atomIndex
;
}
;
}
;
struct
ObjLiteralReader
:
private
ObjLiteralReaderBase
{
public
:
explicit
ObjLiteralReader
(
mozilla
:
:
Span
<
const
uint8_t
>
data
)
:
ObjLiteralReaderBase
(
data
)
{
}
[
[
nodiscard
]
]
bool
readInsn
(
ObjLiteralInsn
*
insn
)
{
ObjLiteralOpcode
op
;
ObjLiteralKey
key
;
if
(
!
readOpAndKey
(
&
op
&
key
)
)
{
return
false
;
}
if
(
ObjLiteralOpcodeHasValueArg
(
op
)
)
{
JS
:
:
Value
value
;
if
(
!
readValueArg
(
&
value
)
)
{
return
false
;
}
*
insn
=
ObjLiteralInsn
(
op
key
value
)
;
return
true
;
}
if
(
ObjLiteralOpcodeHasAtomArg
(
op
)
)
{
frontend
:
:
TaggedParserAtomIndex
atomIndex
;
if
(
!
readAtomArg
(
&
atomIndex
)
)
{
return
false
;
}
*
insn
=
ObjLiteralInsn
(
op
key
atomIndex
)
;
return
true
;
}
*
insn
=
ObjLiteralInsn
(
op
key
)
;
return
true
;
}
}
;
struct
ObjLiteralModifier
:
private
ObjLiteralReaderBase
{
mozilla
:
:
Span
<
uint8_t
>
mutableData_
;
public
:
explicit
ObjLiteralModifier
(
mozilla
:
:
Span
<
uint8_t
>
data
)
:
ObjLiteralReaderBase
(
data
)
mutableData_
(
data
)
{
}
private
:
template
<
typename
MapT
>
void
mapOneAtom
(
MapT
map
frontend
:
:
TaggedParserAtomIndex
atom
size_t
atomCursor
)
{
auto
atomIndex
=
map
(
atom
)
;
mozilla
:
:
NativeEndian
:
:
copyAndSwapToLittleEndian
(
reinterpret_cast
<
void
*
>
(
mutableData_
.
data
(
)
+
atomCursor
)
atomIndex
.
rawDataRef
(
)
1
)
;
}
template
<
typename
MapT
>
bool
mapInsnAtom
(
MapT
map
)
{
ObjLiteralOpcode
op
;
ObjLiteralKey
key
;
size_t
opCursor
=
cursor
(
)
;
if
(
!
readOpAndKey
(
&
op
&
key
)
)
{
return
false
;
}
if
(
key
.
isAtomIndex
(
)
)
{
static
constexpr
size_t
OpLength
=
1
;
size_t
atomCursor
=
opCursor
+
OpLength
;
mapOneAtom
(
map
key
.
getAtomIndex
(
)
atomCursor
)
;
}
if
(
ObjLiteralOpcodeHasValueArg
(
op
)
)
{
JS
:
:
Value
value
;
if
(
!
readValueArg
(
&
value
)
)
{
return
false
;
}
}
else
if
(
ObjLiteralOpcodeHasAtomArg
(
op
)
)
{
size_t
atomCursor
=
cursor
(
)
;
frontend
:
:
TaggedParserAtomIndex
atomIndex
;
if
(
!
readAtomArg
(
&
atomIndex
)
)
{
return
false
;
}
mapOneAtom
(
map
atomIndex
atomCursor
)
;
}
return
true
;
}
public
:
template
<
typename
MapT
>
void
mapAtom
(
MapT
map
)
{
while
(
mapInsnAtom
(
map
)
)
{
}
}
}
;
class
ObjLiteralStencil
{
friend
class
frontend
:
:
StencilXDR
;
mozilla
:
:
Span
<
uint8_t
>
code_
;
ObjLiteralFlags
flags_
;
uint32_t
propertyCount_
=
0
;
public
:
ObjLiteralStencil
(
)
=
default
;
ObjLiteralStencil
(
uint8_t
*
code
size_t
length
const
ObjLiteralFlags
&
flags
uint32_t
propertyCount
)
:
code_
(
mozilla
:
:
Span
(
code
length
)
)
flags_
(
flags
)
propertyCount_
(
propertyCount
)
{
}
JSObject
*
create
(
JSContext
*
cx
const
frontend
:
:
CompilationAtomCache
&
atomCache
)
const
;
mozilla
:
:
Span
<
const
uint8_t
>
code
(
)
const
{
return
code_
;
}
ObjLiteralFlags
flags
(
)
const
{
return
flags_
;
}
uint32_t
propertyCount
(
)
const
{
return
propertyCount_
;
}
#
ifdef
DEBUG
bool
isContainedIn
(
const
LifoAlloc
&
alloc
)
const
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
JSONPrinter
&
json
const
frontend
:
:
CompilationStencil
*
stencil
)
const
;
void
dumpFields
(
JSONPrinter
&
json
const
frontend
:
:
CompilationStencil
*
stencil
)
const
;
#
endif
}
;
}
#
endif
