#
ifndef
frontend_BytecodeSection_h
#
define
frontend_BytecodeSection_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
NamespaceImports
.
h
"
#
include
"
frontend
/
BytecodeOffset
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
namespace
js
{
class
Scope
;
namespace
frontend
{
class
ObjectBox
;
class
CGNumberList
{
JS
:
:
Rooted
<
ValueVector
>
vector
;
public
:
explicit
CGNumberList
(
JSContext
*
cx
)
:
vector
(
cx
ValueVector
(
cx
)
)
{
}
MOZ_MUST_USE
bool
append
(
const
JS
:
:
Value
&
v
)
{
return
vector
.
append
(
v
)
;
}
size_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
GCPtrValue
>
array
)
;
}
;
struct
CGObjectList
{
uint32_t
length
;
ObjectBox
*
lastbox
;
CGObjectList
(
)
:
length
(
0
)
lastbox
(
nullptr
)
{
}
unsigned
add
(
ObjectBox
*
objbox
)
;
void
finish
(
mozilla
:
:
Span
<
GCPtrObject
>
array
)
;
void
finishInnerFunctions
(
)
;
}
;
struct
MOZ_STACK_CLASS
CGScopeList
{
JS
:
:
Rooted
<
GCVector
<
Scope
*
>
>
vector
;
explicit
CGScopeList
(
JSContext
*
cx
)
:
vector
(
cx
GCVector
<
Scope
*
>
(
cx
)
)
{
}
bool
append
(
Scope
*
scope
)
{
return
vector
.
append
(
scope
)
;
}
uint32_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
GCPtrScope
>
array
)
;
}
;
struct
CGTryNoteList
{
Vector
<
JSTryNote
>
list
;
explicit
CGTryNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
JSTryNote
>
array
)
;
}
;
struct
CGScopeNote
:
public
ScopeNote
{
uint32_t
end
;
}
;
struct
CGScopeNoteList
{
Vector
<
CGScopeNote
>
list
;
explicit
CGScopeNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
scopeIndex
BytecodeOffset
offset
uint32_t
parent
)
;
void
recordEnd
(
uint32_t
index
BytecodeOffset
offset
)
;
void
recordEndFunctionBodyVar
(
uint32_t
index
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
ScopeNote
>
array
)
;
private
:
void
recordEndImpl
(
uint32_t
index
uint32_t
offset
)
;
}
;
struct
CGResumeOffsetList
{
Vector
<
uint32_t
>
list
;
explicit
CGResumeOffsetList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
offset
)
{
return
list
.
append
(
offset
)
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
uint32_t
>
array
)
;
}
;
static
constexpr
size_t
MaxBytecodeLength
=
INT32_MAX
;
static
constexpr
size_t
MaxSrcNotesLength
=
INT32_MAX
;
typedef
Vector
<
jsbytecode
64
>
BytecodeVector
;
typedef
Vector
<
jssrcnote
64
>
SrcNotesVector
;
class
BytecodeSection
{
public
:
BytecodeSection
(
JSContext
*
cx
uint32_t
lineNum
)
;
BytecodeVector
&
code
(
)
{
return
code_
;
}
const
BytecodeVector
&
code
(
)
const
{
return
code_
;
}
jsbytecode
*
code
(
BytecodeOffset
offset
)
{
return
code_
.
begin
(
)
+
offset
.
value
(
)
;
}
BytecodeOffset
offset
(
)
const
{
return
BytecodeOffset
(
code_
.
end
(
)
-
code_
.
begin
(
)
)
;
}
SrcNotesVector
&
notes
(
)
{
return
notes_
;
}
const
SrcNotesVector
&
notes
(
)
const
{
return
notes_
;
}
BytecodeOffset
lastNoteOffset
(
)
const
{
return
lastNoteOffset_
;
}
void
setLastNoteOffset
(
BytecodeOffset
offset
)
{
lastNoteOffset_
=
offset
;
}
BytecodeOffset
lastTargetOffset
(
)
const
{
return
lastTarget_
.
offset
;
}
void
setLastTargetOffset
(
BytecodeOffset
offset
)
{
lastTarget_
.
offset
=
offset
;
}
bool
lastOpcodeIsJumpTarget
(
)
const
{
return
lastTarget_
.
offset
.
valid
(
)
&
&
offset
(
)
-
lastTarget_
.
offset
=
=
BytecodeOffsetDiff
(
JSOP_JUMPTARGET_LENGTH
)
;
}
BytecodeOffset
lastNonJumpTargetOffset
(
)
const
{
return
lastOpcodeIsJumpTarget
(
)
?
lastTarget_
.
offset
:
offset
(
)
;
}
int32_t
stackDepth
(
)
const
{
return
stackDepth_
;
}
void
setStackDepth
(
int32_t
depth
)
{
stackDepth_
=
depth
;
}
uint32_t
maxStackDepth
(
)
const
{
return
maxStackDepth_
;
}
void
updateDepth
(
BytecodeOffset
target
)
;
CGTryNoteList
&
tryNoteList
(
)
{
return
tryNoteList_
;
}
;
const
CGTryNoteList
&
tryNoteList
(
)
const
{
return
tryNoteList_
;
}
;
CGScopeNoteList
&
scopeNoteList
(
)
{
return
scopeNoteList_
;
}
;
const
CGScopeNoteList
&
scopeNoteList
(
)
const
{
return
scopeNoteList_
;
}
;
CGResumeOffsetList
&
resumeOffsetList
(
)
{
return
resumeOffsetList_
;
}
const
CGResumeOffsetList
&
resumeOffsetList
(
)
const
{
return
resumeOffsetList_
;
}
uint32_t
numYields
(
)
const
{
return
numYields_
;
}
void
addNumYields
(
)
{
numYields_
+
+
;
}
uint32_t
currentLine
(
)
const
{
return
currentLine_
;
}
uint32_t
lastColumn
(
)
const
{
return
lastColumn_
;
}
void
setCurrentLine
(
uint32_t
line
)
{
currentLine_
=
line
;
lastColumn_
=
0
;
}
void
setLastColumn
(
uint32_t
column
)
{
lastColumn_
=
column
;
}
void
updateSeparatorPosition
(
)
{
lastSeparatorOffet_
=
code
(
)
.
length
(
)
;
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
void
updateSeparatorPositionIfPresent
(
)
{
if
(
lastSeparatorOffet_
=
=
code
(
)
.
length
(
)
)
{
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
}
bool
isDuplicateLocation
(
)
const
{
return
lastSeparatorLine_
=
=
currentLine_
&
&
lastSeparatorColumn_
=
=
lastColumn_
;
}
uint32_t
numICEntries
(
)
const
{
return
numICEntries_
;
}
void
incrementNumICEntries
(
)
{
MOZ_ASSERT
(
numICEntries_
!
=
UINT32_MAX
"
Shouldn
'
t
overflow
"
)
;
numICEntries_
+
+
;
}
void
setNumICEntries
(
uint32_t
entries
)
{
numICEntries_
=
entries
;
}
uint32_t
numTypeSets
(
)
const
{
return
numTypeSets_
;
}
void
incrementNumTypeSets
(
)
{
MOZ_ASSERT
(
numTypeSets_
!
=
UINT32_MAX
"
Shouldn
'
t
overflow
"
)
;
numTypeSets_
+
+
;
}
private
:
BytecodeVector
code_
;
SrcNotesVector
notes_
;
BytecodeOffset
lastNoteOffset_
;
JumpTarget
lastTarget_
;
uint32_t
maxStackDepth_
=
0
;
int32_t
stackDepth_
=
0
;
CGTryNoteList
tryNoteList_
;
CGScopeNoteList
scopeNoteList_
;
CGResumeOffsetList
resumeOffsetList_
;
uint32_t
numYields_
=
0
;
uint32_t
currentLine_
;
uint32_t
lastColumn_
=
0
;
uint32_t
lastSeparatorOffet_
=
0
;
uint32_t
lastSeparatorLine_
=
0
;
uint32_t
lastSeparatorColumn_
=
0
;
uint32_t
numICEntries_
=
0
;
uint32_t
numTypeSets_
=
0
;
}
;
class
PerScriptData
{
public
:
explicit
PerScriptData
(
JSContext
*
cx
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
CGScopeList
&
scopeList
(
)
{
return
scopeList_
;
}
const
CGScopeList
&
scopeList
(
)
const
{
return
scopeList_
;
}
CGNumberList
&
numberList
(
)
{
return
numberList_
;
}
const
CGNumberList
&
numberList
(
)
const
{
return
numberList_
;
}
CGObjectList
&
objectList
(
)
{
return
objectList_
;
}
const
CGObjectList
&
objectList
(
)
const
{
return
objectList_
;
}
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
{
return
atomIndices_
;
}
const
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
const
{
return
atomIndices_
;
}
private
:
CGScopeList
scopeList_
;
CGNumberList
numberList_
;
CGObjectList
objectList_
;
PooledMapPtr
<
AtomIndexMap
>
atomIndices_
;
}
;
}
}
#
endif
