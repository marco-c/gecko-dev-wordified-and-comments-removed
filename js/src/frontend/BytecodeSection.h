#
ifndef
frontend_BytecodeSection_h
#
define
frontend_BytecodeSection_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeOffset
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
namespace
js
{
class
Scope
;
namespace
frontend
{
class
FunctionBox
;
struct
MOZ_STACK_CLASS
GCThingList
{
using
ScriptThingsStackVector
=
Vector
<
TaggedScriptThingIndex
8
>
;
CompilationStencil
&
stencil
;
CompilationState
&
compilationState
;
ScriptThingsStackVector
vector
;
mozilla
:
:
Maybe
<
GCThingIndex
>
firstScopeIndex
;
explicit
GCThingList
(
JSContext
*
cx
CompilationStencil
&
stencil
CompilationState
&
compilationState
)
:
stencil
(
stencil
)
compilationState
(
compilationState
)
vector
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
const
ParserAtom
*
atom
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
atom
-
>
markUsedByStencil
(
)
;
if
(
!
vector
.
emplaceBack
(
atom
-
>
toIndex
(
)
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
ScopeIndex
scope
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
if
(
!
vector
.
emplaceBack
(
scope
)
)
{
return
false
;
}
if
(
!
firstScopeIndex
)
{
firstScopeIndex
.
emplace
(
*
index
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
BigIntLiteral
*
literal
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
if
(
!
vector
.
emplaceBack
(
literal
-
>
index
(
)
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
RegExpLiteral
*
literal
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
if
(
!
vector
.
emplaceBack
(
literal
-
>
index
(
)
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
ObjLiteralIndex
objlit
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
if
(
!
vector
.
emplaceBack
(
objlit
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
FunctionBox
*
funbox
GCThingIndex
*
index
)
;
MOZ_MUST_USE
bool
appendEmptyGlobalScope
(
GCThingIndex
*
index
)
{
*
index
=
GCThingIndex
(
vector
.
length
(
)
)
;
EmptyGlobalScopeType
emptyGlobalScope
;
if
(
!
vector
.
emplaceBack
(
emptyGlobalScope
)
)
{
return
false
;
}
if
(
!
firstScopeIndex
)
{
firstScopeIndex
.
emplace
(
*
index
)
;
}
return
true
;
}
uint32_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
const
ScriptThingsStackVector
&
objects
(
)
{
return
vector
;
}
AbstractScopePtr
getScope
(
size_t
index
)
const
;
mozilla
:
:
Maybe
<
ScopeIndex
>
getScopeIndex
(
size_t
index
)
const
;
AbstractScopePtr
firstScope
(
)
const
{
MOZ_ASSERT
(
firstScopeIndex
.
isSome
(
)
)
;
return
getScope
(
*
firstScopeIndex
)
;
}
}
;
MOZ_MUST_USE
bool
EmitScriptThingsVector
(
JSContext
*
cx
CompilationInput
&
input
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
mozilla
:
:
Span
<
const
TaggedScriptThingIndex
>
things
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
output
)
;
struct
CGTryNoteList
{
Vector
<
TryNote
0
>
list
;
explicit
CGTryNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
TryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
;
mozilla
:
:
Span
<
const
TryNote
>
span
(
)
const
{
return
{
list
.
begin
(
)
list
.
length
(
)
}
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
}
;
struct
CGScopeNoteList
{
Vector
<
ScopeNote
0
>
list
;
explicit
CGScopeNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
GCThingIndex
scopeIndex
BytecodeOffset
offset
uint32_t
parent
)
;
void
recordEnd
(
uint32_t
index
BytecodeOffset
offset
)
;
void
recordEndFunctionBodyVar
(
uint32_t
index
)
;
mozilla
:
:
Span
<
const
ScopeNote
>
span
(
)
const
{
return
{
list
.
begin
(
)
list
.
length
(
)
}
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
private
:
void
recordEndImpl
(
uint32_t
index
uint32_t
offset
)
;
}
;
struct
CGResumeOffsetList
{
Vector
<
uint32_t
0
>
list
;
explicit
CGResumeOffsetList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
offset
)
{
return
list
.
append
(
offset
)
;
}
mozilla
:
:
Span
<
const
uint32_t
>
span
(
)
const
{
return
{
list
.
begin
(
)
list
.
length
(
)
}
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
}
;
static
constexpr
size_t
MaxBytecodeLength
=
INT32_MAX
;
static
constexpr
size_t
MaxSrcNotesLength
=
INT32_MAX
;
typedef
Vector
<
jsbytecode
64
>
BytecodeVector
;
typedef
Vector
<
js
:
:
SrcNote
64
>
SrcNotesVector
;
class
BytecodeSection
{
public
:
BytecodeSection
(
JSContext
*
cx
uint32_t
lineNum
uint32_t
column
)
;
BytecodeVector
&
code
(
)
{
return
code_
;
}
const
BytecodeVector
&
code
(
)
const
{
return
code_
;
}
jsbytecode
*
code
(
BytecodeOffset
offset
)
{
return
code_
.
begin
(
)
+
offset
.
value
(
)
;
}
BytecodeOffset
offset
(
)
const
{
return
BytecodeOffset
(
code_
.
end
(
)
-
code_
.
begin
(
)
)
;
}
SrcNotesVector
&
notes
(
)
{
return
notes_
;
}
const
SrcNotesVector
&
notes
(
)
const
{
return
notes_
;
}
BytecodeOffset
lastNoteOffset
(
)
const
{
return
lastNoteOffset_
;
}
void
setLastNoteOffset
(
BytecodeOffset
offset
)
{
lastNoteOffset_
=
offset
;
}
BytecodeOffset
lastTargetOffset
(
)
const
{
return
lastTarget_
.
offset
;
}
void
setLastTargetOffset
(
BytecodeOffset
offset
)
{
lastTarget_
.
offset
=
offset
;
}
bool
lastOpcodeIsJumpTarget
(
)
const
{
return
lastTarget_
.
offset
.
valid
(
)
&
&
offset
(
)
-
lastTarget_
.
offset
=
=
BytecodeOffsetDiff
(
JSOpLength_JumpTarget
)
;
}
BytecodeOffset
lastNonJumpTargetOffset
(
)
const
{
return
lastOpcodeIsJumpTarget
(
)
?
lastTarget_
.
offset
:
offset
(
)
;
}
int32_t
stackDepth
(
)
const
{
return
stackDepth_
;
}
void
setStackDepth
(
int32_t
depth
)
{
stackDepth_
=
depth
;
}
uint32_t
maxStackDepth
(
)
const
{
return
maxStackDepth_
;
}
void
updateDepth
(
BytecodeOffset
target
)
;
CGTryNoteList
&
tryNoteList
(
)
{
return
tryNoteList_
;
}
;
const
CGTryNoteList
&
tryNoteList
(
)
const
{
return
tryNoteList_
;
}
;
CGScopeNoteList
&
scopeNoteList
(
)
{
return
scopeNoteList_
;
}
;
const
CGScopeNoteList
&
scopeNoteList
(
)
const
{
return
scopeNoteList_
;
}
;
CGResumeOffsetList
&
resumeOffsetList
(
)
{
return
resumeOffsetList_
;
}
const
CGResumeOffsetList
&
resumeOffsetList
(
)
const
{
return
resumeOffsetList_
;
}
uint32_t
numYields
(
)
const
{
return
numYields_
;
}
void
addNumYields
(
)
{
numYields_
+
+
;
}
uint32_t
currentLine
(
)
const
{
return
currentLine_
;
}
uint32_t
lastColumn
(
)
const
{
return
lastColumn_
;
}
void
setCurrentLine
(
uint32_t
line
uint32_t
sourceOffset
)
{
currentLine_
=
line
;
lastColumn_
=
0
;
lastSourceOffset_
=
sourceOffset
;
}
void
setLastColumn
(
uint32_t
column
uint32_t
offset
)
{
lastColumn_
=
column
;
lastSourceOffset_
=
offset
;
}
void
updateSeparatorPosition
(
)
{
lastSeparatorCodeOffset_
=
code
(
)
.
length
(
)
;
lastSeparatorSourceOffset_
=
lastSourceOffset_
;
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
void
updateSeparatorPositionIfPresent
(
)
{
if
(
lastSeparatorCodeOffset_
=
=
code
(
)
.
length
(
)
)
{
lastSeparatorSourceOffset_
=
lastSourceOffset_
;
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
}
bool
isDuplicateLocation
(
)
const
{
return
lastSeparatorLine_
=
=
currentLine_
&
&
lastSeparatorColumn_
=
=
lastColumn_
;
}
bool
atSeparator
(
uint32_t
offset
)
const
{
return
lastSeparatorSourceOffset_
=
=
offset
;
}
uint32_t
numICEntries
(
)
const
{
return
numICEntries_
;
}
void
incrementNumICEntries
(
)
{
MOZ_ASSERT
(
numICEntries_
!
=
UINT32_MAX
"
Shouldn
'
t
overflow
"
)
;
numICEntries_
+
+
;
}
void
setNumICEntries
(
uint32_t
entries
)
{
numICEntries_
=
entries
;
}
private
:
BytecodeVector
code_
;
SrcNotesVector
notes_
;
BytecodeOffset
lastNoteOffset_
;
JumpTarget
lastTarget_
;
uint32_t
maxStackDepth_
=
0
;
int32_t
stackDepth_
=
0
;
CGTryNoteList
tryNoteList_
;
CGScopeNoteList
scopeNoteList_
;
CGResumeOffsetList
resumeOffsetList_
;
uint32_t
numYields_
=
0
;
uint32_t
currentLine_
;
uint32_t
lastColumn_
=
0
;
uint32_t
lastSourceOffset_
=
0
;
uint32_t
lastSeparatorCodeOffset_
=
0
;
uint32_t
lastSeparatorSourceOffset_
=
0
;
uint32_t
lastSeparatorLine_
=
0
;
uint32_t
lastSeparatorColumn_
=
0
;
uint32_t
numICEntries_
=
0
;
}
;
class
PerScriptData
{
public
:
explicit
PerScriptData
(
JSContext
*
cx
frontend
:
:
CompilationStencil
&
stencil
frontend
:
:
CompilationState
&
compilationState
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
GCThingList
&
gcThingList
(
)
{
return
gcThingList_
;
}
const
GCThingList
&
gcThingList
(
)
const
{
return
gcThingList_
;
}
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
{
return
atomIndices_
;
}
const
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
const
{
return
atomIndices_
;
}
private
:
GCThingList
gcThingList_
;
PooledMapPtr
<
AtomIndexMap
>
atomIndices_
;
}
;
}
}
#
endif
