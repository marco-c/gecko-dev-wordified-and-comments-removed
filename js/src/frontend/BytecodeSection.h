#
ifndef
frontend_BytecodeSection_h
#
define
frontend_BytecodeSection_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
frontend
/
AbstractScope
.
h
"
#
include
"
frontend
/
BytecodeOffset
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
namespace
js
{
class
Scope
;
using
BigIntVector
=
JS
:
:
GCVector
<
js
:
:
BigInt
*
>
;
namespace
frontend
{
class
BigIntLiteral
;
class
ObjectBox
;
struct
MOZ_STACK_CLASS
GCThingList
{
using
ListType
=
mozilla
:
:
Variant
<
JS
:
:
GCCellPtr
BigIntIndex
ObjLiteralCreationData
RegExpIndex
ScopeIndex
>
;
CompilationInfo
&
compilationInfo
;
JS
:
:
RootedVector
<
ListType
>
vector
;
ObjectBox
*
lastbox
=
nullptr
;
mozilla
:
:
Maybe
<
uint32_t
>
firstScopeIndex
;
explicit
GCThingList
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
:
compilationInfo
(
compilationInfo
)
vector
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
ScopeIndex
scope
uint32_t
*
index
)
{
*
index
=
vector
.
length
(
)
;
if
(
!
vector
.
append
(
mozilla
:
:
AsVariant
(
scope
)
)
)
{
return
false
;
}
if
(
!
firstScopeIndex
)
{
firstScopeIndex
.
emplace
(
*
index
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
Scope
*
scope
uint32_t
*
index
)
{
*
index
=
vector
.
length
(
)
;
if
(
!
vector
.
append
(
mozilla
:
:
AsVariant
(
JS
:
:
GCCellPtr
(
scope
)
)
)
)
{
return
false
;
}
if
(
!
firstScopeIndex
)
{
firstScopeIndex
.
emplace
(
*
index
)
;
}
return
true
;
}
MOZ_MUST_USE
bool
append
(
BigIntLiteral
*
literal
uint32_t
*
index
)
{
*
index
=
vector
.
length
(
)
;
return
vector
.
append
(
mozilla
:
:
AsVariant
(
literal
-
>
index
(
)
)
)
;
}
MOZ_MUST_USE
bool
append
(
RegExpLiteral
*
literal
uint32_t
*
index
)
{
*
index
=
vector
.
length
(
)
;
if
(
literal
-
>
isDeferred
(
)
)
{
return
vector
.
append
(
mozilla
:
:
AsVariant
(
literal
-
>
index
(
)
)
)
;
}
return
vector
.
append
(
mozilla
:
:
AsVariant
(
JS
:
:
GCCellPtr
(
literal
-
>
objbox
(
)
-
>
object
(
)
)
)
)
;
}
MOZ_MUST_USE
bool
append
(
ObjLiteralCreationData
&
&
objlit
uint32_t
*
index
)
{
*
index
=
vector
.
length
(
)
;
return
vector
.
append
(
mozilla
:
:
AsVariant
(
std
:
:
move
(
objlit
)
)
)
;
}
MOZ_MUST_USE
bool
append
(
ObjectBox
*
obj
uint32_t
*
index
)
;
uint32_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
MOZ_MUST_USE
bool
finish
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
array
)
;
void
finishInnerFunctions
(
)
;
AbstractScope
getScope
(
size_t
index
)
const
{
auto
&
elem
=
vector
[
index
]
.
get
(
)
;
if
(
elem
.
is
<
JS
:
:
GCCellPtr
>
(
)
)
{
return
AbstractScope
(
&
elem
.
as
<
JS
:
:
GCCellPtr
>
(
)
.
as
<
Scope
>
(
)
)
;
}
return
AbstractScope
(
compilationInfo
elem
.
as
<
ScopeIndex
>
(
)
)
;
}
AbstractScope
firstScope
(
)
const
{
MOZ_ASSERT
(
firstScopeIndex
.
isSome
(
)
)
;
return
getScope
(
*
firstScopeIndex
)
;
}
}
;
struct
CGTryNoteList
{
Vector
<
JSTryNote
>
list
;
explicit
CGTryNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
JSTryNote
>
array
)
;
}
;
struct
CGScopeNote
:
public
ScopeNote
{
uint32_t
end
;
}
;
struct
CGScopeNoteList
{
Vector
<
CGScopeNote
>
list
;
explicit
CGScopeNoteList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
scopeIndex
BytecodeOffset
offset
uint32_t
parent
)
;
void
recordEnd
(
uint32_t
index
BytecodeOffset
offset
)
;
void
recordEndFunctionBodyVar
(
uint32_t
index
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
ScopeNote
>
array
)
;
private
:
void
recordEndImpl
(
uint32_t
index
uint32_t
offset
)
;
}
;
struct
CGResumeOffsetList
{
Vector
<
uint32_t
>
list
;
explicit
CGResumeOffsetList
(
JSContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
offset
)
{
return
list
.
append
(
offset
)
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
mozilla
:
:
Span
<
uint32_t
>
array
)
;
}
;
static
constexpr
size_t
MaxBytecodeLength
=
INT32_MAX
;
static
constexpr
size_t
MaxSrcNotesLength
=
INT32_MAX
;
typedef
Vector
<
jsbytecode
64
>
BytecodeVector
;
typedef
Vector
<
jssrcnote
64
>
SrcNotesVector
;
class
BytecodeSection
{
public
:
BytecodeSection
(
JSContext
*
cx
uint32_t
lineNum
)
;
BytecodeVector
&
code
(
)
{
return
code_
;
}
const
BytecodeVector
&
code
(
)
const
{
return
code_
;
}
jsbytecode
*
code
(
BytecodeOffset
offset
)
{
return
code_
.
begin
(
)
+
offset
.
value
(
)
;
}
BytecodeOffset
offset
(
)
const
{
return
BytecodeOffset
(
code_
.
end
(
)
-
code_
.
begin
(
)
)
;
}
SrcNotesVector
&
notes
(
)
{
return
notes_
;
}
const
SrcNotesVector
&
notes
(
)
const
{
return
notes_
;
}
BytecodeOffset
lastNoteOffset
(
)
const
{
return
lastNoteOffset_
;
}
void
setLastNoteOffset
(
BytecodeOffset
offset
)
{
lastNoteOffset_
=
offset
;
}
BytecodeOffset
lastTargetOffset
(
)
const
{
return
lastTarget_
.
offset
;
}
void
setLastTargetOffset
(
BytecodeOffset
offset
)
{
lastTarget_
.
offset
=
offset
;
}
bool
lastOpcodeIsJumpTarget
(
)
const
{
return
lastTarget_
.
offset
.
valid
(
)
&
&
offset
(
)
-
lastTarget_
.
offset
=
=
BytecodeOffsetDiff
(
JSOpLength_JumpTarget
)
;
}
BytecodeOffset
lastNonJumpTargetOffset
(
)
const
{
return
lastOpcodeIsJumpTarget
(
)
?
lastTarget_
.
offset
:
offset
(
)
;
}
int32_t
stackDepth
(
)
const
{
return
stackDepth_
;
}
void
setStackDepth
(
int32_t
depth
)
{
stackDepth_
=
depth
;
}
uint32_t
maxStackDepth
(
)
const
{
return
maxStackDepth_
;
}
void
updateDepth
(
BytecodeOffset
target
)
;
CGTryNoteList
&
tryNoteList
(
)
{
return
tryNoteList_
;
}
;
const
CGTryNoteList
&
tryNoteList
(
)
const
{
return
tryNoteList_
;
}
;
CGScopeNoteList
&
scopeNoteList
(
)
{
return
scopeNoteList_
;
}
;
const
CGScopeNoteList
&
scopeNoteList
(
)
const
{
return
scopeNoteList_
;
}
;
CGResumeOffsetList
&
resumeOffsetList
(
)
{
return
resumeOffsetList_
;
}
const
CGResumeOffsetList
&
resumeOffsetList
(
)
const
{
return
resumeOffsetList_
;
}
uint32_t
numYields
(
)
const
{
return
numYields_
;
}
void
addNumYields
(
)
{
numYields_
+
+
;
}
uint32_t
currentLine
(
)
const
{
return
currentLine_
;
}
uint32_t
lastColumn
(
)
const
{
return
lastColumn_
;
}
void
setCurrentLine
(
uint32_t
line
uint32_t
sourceOffset
)
{
currentLine_
=
line
;
lastColumn_
=
0
;
lastSourceOffset_
=
sourceOffset
;
}
void
setLastColumn
(
uint32_t
column
uint32_t
offset
)
{
lastColumn_
=
column
;
lastSourceOffset_
=
offset
;
}
void
updateSeparatorPosition
(
)
{
lastSeparatorCodeOffset_
=
code
(
)
.
length
(
)
;
lastSeparatorSourceOffset_
=
lastSourceOffset_
;
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
void
updateSeparatorPositionIfPresent
(
)
{
if
(
lastSeparatorCodeOffset_
=
=
code
(
)
.
length
(
)
)
{
lastSeparatorSourceOffset_
=
lastSourceOffset_
;
lastSeparatorLine_
=
currentLine_
;
lastSeparatorColumn_
=
lastColumn_
;
}
}
bool
isDuplicateLocation
(
)
const
{
return
lastSeparatorLine_
=
=
currentLine_
&
&
lastSeparatorColumn_
=
=
lastColumn_
;
}
bool
atSeparator
(
uint32_t
offset
)
const
{
return
lastSeparatorSourceOffset_
=
=
offset
;
}
uint32_t
numICEntries
(
)
const
{
return
numICEntries_
;
}
void
incrementNumICEntries
(
)
{
MOZ_ASSERT
(
numICEntries_
!
=
UINT32_MAX
"
Shouldn
'
t
overflow
"
)
;
numICEntries_
+
+
;
}
void
setNumICEntries
(
uint32_t
entries
)
{
numICEntries_
=
entries
;
}
uint32_t
numTypeSets
(
)
const
{
return
numTypeSets_
;
}
void
incrementNumTypeSets
(
)
{
MOZ_ASSERT
(
numTypeSets_
!
=
UINT32_MAX
"
Shouldn
'
t
overflow
"
)
;
numTypeSets_
+
+
;
}
private
:
BytecodeVector
code_
;
SrcNotesVector
notes_
;
BytecodeOffset
lastNoteOffset_
;
JumpTarget
lastTarget_
;
uint32_t
maxStackDepth_
=
0
;
int32_t
stackDepth_
=
0
;
CGTryNoteList
tryNoteList_
;
CGScopeNoteList
scopeNoteList_
;
CGResumeOffsetList
resumeOffsetList_
;
uint32_t
numYields_
=
0
;
uint32_t
currentLine_
;
uint32_t
lastColumn_
=
0
;
uint32_t
lastSourceOffset_
=
0
;
uint32_t
lastSeparatorCodeOffset_
=
0
;
uint32_t
lastSeparatorSourceOffset_
=
0
;
uint32_t
lastSeparatorLine_
=
0
;
uint32_t
lastSeparatorColumn_
=
0
;
uint32_t
numICEntries_
=
0
;
uint32_t
numTypeSets_
=
0
;
}
;
class
PerScriptData
{
public
:
explicit
PerScriptData
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
)
;
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
)
;
GCThingList
&
gcThingList
(
)
{
return
gcThingList_
;
}
const
GCThingList
&
gcThingList
(
)
const
{
return
gcThingList_
;
}
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
{
return
atomIndices_
;
}
const
PooledMapPtr
<
AtomIndexMap
>
&
atomIndices
(
)
const
{
return
atomIndices_
;
}
private
:
GCThingList
gcThingList_
;
PooledMapPtr
<
AtomIndexMap
>
atomIndices_
;
}
;
}
}
namespace
JS
{
template
<
typename
T
>
struct
GCPolicy
<
js
:
:
frontend
:
:
TypedIndex
<
T
>
>
:
JS
:
:
IgnoreGCPolicy
<
js
:
:
frontend
:
:
TypedIndex
<
T
>
>
{
}
;
}
#
endif
