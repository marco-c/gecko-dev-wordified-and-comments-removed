#
ifndef
frontend_BytecodeEmitter_h
#
define
frontend_BytecodeEmitter_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Saturate
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
frontend
/
DestructuringFlavor
.
h
"
#
include
"
frontend
/
EitherParser
.
h
"
#
include
"
frontend
/
IteratorKind
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
SelfHostedIter
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
ValueUsage
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
BuiltinObjectKind
.
h
"
#
include
"
vm
/
CheckIsObjectKind
.
h
"
#
include
"
vm
/
CompletionKind
.
h
"
#
include
"
vm
/
FunctionPrefixKind
.
h
"
#
include
"
vm
/
GeneratorResumeKind
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
#
include
"
vm
/
ThrowMsgKind
.
h
"
namespace
js
{
class
FrontendContext
;
namespace
frontend
{
class
BytecodeOffset
;
class
CallOrNewEmitter
;
class
ClassEmitter
;
class
DestructuringLHSRef
;
class
ElemOpEmitter
;
class
EmitterScope
;
class
ErrorReporter
;
class
FullParseHandler
;
class
NestableControl
;
class
PrivateOpEmitter
;
class
PropertyEmitter
;
class
PropOpEmitter
;
class
OptionalEmitter
;
class
SharedContext
;
class
TDZCheckCache
;
class
TryEmitter
;
struct
TokenPos
;
enum
class
ValueIsOnStack
{
Yes
No
}
;
struct
MOZ_STACK_CLASS
BytecodeEmitter
{
SharedContext
*
const
sc
=
nullptr
;
FrontendContext
*
const
fc
=
nullptr
;
BytecodeEmitter
*
const
parent
=
nullptr
;
BytecodeSection
bytecodeSection_
;
static
constexpr
unsigned
LastSrcNoteIsNotLineOnly
=
unsigned
(
-
1
)
;
unsigned
lastLineOnlySrcNoteIndex
=
LastSrcNoteIsNotLineOnly
;
public
:
BytecodeSection
&
bytecodeSection
(
)
{
return
bytecodeSection_
;
}
const
BytecodeSection
&
bytecodeSection
(
)
const
{
return
bytecodeSection_
;
}
private
:
PerScriptData
perScriptData_
;
public
:
PerScriptData
&
perScriptData
(
)
{
return
perScriptData_
;
}
const
PerScriptData
&
perScriptData
(
)
const
{
return
perScriptData_
;
}
private
:
mozilla
:
:
Maybe
<
uint32_t
>
mainOffset_
=
{
}
;
mozilla
:
:
Maybe
<
EitherParser
>
ep_
=
{
}
;
const
ErrorReporter
&
errorReporter_
;
public
:
CompilationState
&
compilationState
;
uint32_t
maxFixedSlots
=
0
;
GCThingIndex
bodyScopeIndex
=
ScopeNote
:
:
NoScopeIndex
;
EmitterScope
*
varEmitterScope
=
nullptr
;
NestableControl
*
innermostNestableControl
=
nullptr
;
EmitterScope
*
innermostEmitterScope_
=
nullptr
;
TDZCheckCache
*
innermostTDZCheckCache
=
nullptr
;
FunctionBox
*
prevSelfHostedTopLevelFunction
=
nullptr
;
#
ifdef
DEBUG
bool
unstableEmitterScope
=
false
;
friend
class
AutoCheckUnstableEmitterScope
;
#
endif
const
ErrorReporter
&
errorReporter
(
)
const
{
return
errorReporter_
;
}
ParserAtomsTable
&
parserAtoms
(
)
{
return
compilationState
.
parserAtoms
;
}
const
ParserAtomsTable
&
parserAtoms
(
)
const
{
return
compilationState
.
parserAtoms
;
}
EmitterScope
*
innermostEmitterScope
(
)
const
{
MOZ_ASSERT
(
!
unstableEmitterScope
)
;
return
innermostEmitterScopeNoCheck
(
)
;
}
EmitterScope
*
innermostEmitterScopeNoCheck
(
)
const
{
return
innermostEmitterScope_
;
}
const
bool
suppressBreakpointsAndSourceNotes
=
false
;
bool
hasTryFinally
=
false
;
enum
EmitterMode
{
Normal
SelfHosting
LazyFunction
}
;
const
EmitterMode
emitterMode
=
Normal
;
mozilla
:
:
Maybe
<
uint32_t
>
scriptStartOffset
=
{
}
;
mozilla
:
:
Maybe
<
uint32_t
>
functionBodyEndPos
=
{
}
;
JumpList
endOfDerivedClassConstructorBody
=
{
}
;
JumpList
finalYields
=
{
}
;
mozilla
:
:
SaturateUint8
propertyAdditionEstimate
=
{
}
;
private
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
FrontendContext
*
fc
SharedContext
*
sc
const
ErrorReporter
&
errorReporter
CompilationState
&
compilationState
EmitterMode
emitterMode
)
;
void
initFromBodyPosition
(
TokenPos
bodyPosition
)
;
public
:
BytecodeEmitter
(
FrontendContext
*
fc
const
EitherParser
&
parser
SharedContext
*
sc
CompilationState
&
compilationState
EmitterMode
emitterMode
=
Normal
)
;
template
<
typename
Unit
>
BytecodeEmitter
(
FrontendContext
*
fc
Parser
<
FullParseHandler
Unit
>
*
parser
SharedContext
*
sc
CompilationState
&
compilationState
EmitterMode
emitterMode
=
Normal
)
:
BytecodeEmitter
(
fc
EitherParser
(
parser
)
sc
compilationState
emitterMode
)
{
}
BytecodeEmitter
(
BytecodeEmitter
*
parent
SharedContext
*
sc
)
;
[
[
nodiscard
]
]
bool
init
(
)
;
[
[
nodiscard
]
]
bool
init
(
TokenPos
bodyPosition
)
;
template
<
typename
T
>
T
*
findInnermostNestableControl
(
)
const
;
template
<
typename
T
typename
Predicate
>
T
*
findInnermostNestableControl
(
Predicate
predicate
)
const
;
NameLocation
lookupName
(
TaggedParserAtomIndex
name
)
;
void
lookupPrivate
(
TaggedParserAtomIndex
name
NameLocation
&
loc
mozilla
:
:
Maybe
<
NameLocation
>
&
brandLoc
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInScope
(
TaggedParserAtomIndex
name
EmitterScope
*
target
)
;
template
<
typename
T
>
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInScopeType
(
TaggedParserAtomIndex
name
EmitterScope
*
source
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInFunctionScope
(
TaggedParserAtomIndex
name
)
{
return
locationOfNameBoundInScopeType
<
FunctionScope
>
(
name
innermostEmitterScope
(
)
)
;
}
void
setVarEmitterScope
(
EmitterScope
*
emitterScope
)
{
MOZ_ASSERT
(
emitterScope
)
;
MOZ_ASSERT
(
!
varEmitterScope
)
;
varEmitterScope
=
emitterScope
;
}
AbstractScopePtr
outermostScope
(
)
const
{
return
perScriptData
(
)
.
gcThingList
(
)
.
firstScope
(
)
;
}
AbstractScopePtr
innermostScope
(
)
const
;
ScopeIndex
innermostScopeIndex
(
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
makeAtomIndex
(
TaggedParserAtomIndex
atom
ParserAtom
:
:
Atomize
atomize
GCThingIndex
*
indexp
)
{
MOZ_ASSERT
(
perScriptData
(
)
.
atomIndices
(
)
)
;
AtomIndexMap
:
:
AddPtr
p
=
perScriptData
(
)
.
atomIndices
(
)
-
>
lookupForAdd
(
atom
)
;
if
(
p
)
{
compilationState
.
parserAtoms
.
markAtomize
(
atom
atomize
)
;
*
indexp
=
GCThingIndex
(
p
-
>
value
(
)
)
;
return
true
;
}
GCThingIndex
index
;
if
(
!
perScriptData
(
)
.
gcThingList
(
)
.
append
(
atom
atomize
&
index
)
)
{
return
false
;
}
if
(
!
perScriptData
(
)
.
atomIndices
(
)
-
>
add
(
p
atom
index
.
index
)
)
{
ReportOutOfMemory
(
fc
)
;
return
false
;
}
*
indexp
=
index
;
return
true
;
}
bool
isInLoop
(
)
;
[
[
nodiscard
]
]
bool
checkSingletonContext
(
)
;
bool
needsImplicitThis
(
)
;
size_t
countThisEnvironmentHops
(
)
;
[
[
nodiscard
]
]
bool
emitThisEnvironmentCallee
(
)
;
[
[
nodiscard
]
]
bool
emitSuperBase
(
)
;
uint32_t
mainOffset
(
)
const
{
return
*
mainOffset_
;
}
bool
inPrologue
(
)
const
{
return
mainOffset_
.
isNothing
(
)
;
}
void
switchToMain
(
)
{
MOZ_ASSERT
(
inPrologue
(
)
)
;
mainOffset_
.
emplace
(
bytecodeSection
(
)
.
code
(
)
.
length
(
)
)
;
}
void
setFunctionBodyEndPos
(
uint32_t
pos
)
{
functionBodyEndPos
=
mozilla
:
:
Some
(
pos
)
;
}
void
setScriptStartOffsetIfUnset
(
uint32_t
pos
)
{
if
(
scriptStartOffset
.
isNothing
(
)
)
{
scriptStartOffset
=
mozilla
:
:
Some
(
pos
)
;
}
}
void
reportError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
;
void
reportError
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
;
bool
intoScriptStencil
(
ScriptIndex
scriptIndex
)
;
[
[
nodiscard
]
]
bool
checkSideEffects
(
ParseNode
*
pn
bool
*
answer
)
;
#
ifdef
DEBUG
[
[
nodiscard
]
]
bool
checkStrictOrSloppy
(
JSOp
op
)
;
#
endif
[
[
nodiscard
]
]
bool
addTryNote
(
TryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
;
bool
skipLocationSrcNotes
(
)
const
{
return
inPrologue
(
)
|
|
suppressBreakpointsAndSourceNotes
;
}
bool
skipBreakpointSrcNotes
(
)
const
{
return
inPrologue
(
)
|
|
suppressBreakpointsAndSourceNotes
;
}
[
[
nodiscard
]
]
bool
newSrcNote
(
SrcNoteType
type
unsigned
*
indexp
=
nullptr
)
;
[
[
nodiscard
]
]
bool
newSrcNote2
(
SrcNoteType
type
ptrdiff_t
operand
unsigned
*
indexp
=
nullptr
)
;
[
[
nodiscard
]
]
bool
convertLastNewLineToNewLineColumn
(
JS
:
:
LimitedColumnNumberOneOrigin
column
)
;
[
[
nodiscard
]
]
bool
convertLastSetLineToSetLineColumn
(
JS
:
:
LimitedColumnNumberOneOrigin
column
)
;
[
[
nodiscard
]
]
bool
newSrcNoteOperand
(
ptrdiff_t
operand
)
;
enum
EmitLineNumberNote
{
EMIT_LINENOTE
SUPPRESS_LINENOTE
}
;
[
[
nodiscard
]
]
bool
emitTree
(
ParseNode
*
pn
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
EmitLineNumberNote
emitLineNote
=
EMIT_LINENOTE
)
;
[
[
nodiscard
]
]
bool
emitOptionalTree
(
ParseNode
*
pn
OptionalEmitter
&
oe
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
)
;
[
[
nodiscard
]
]
bool
emitDeclarationInstantiation
(
ParseNode
*
body
)
;
[
[
nodiscard
]
]
bool
emitScript
(
ParseNode
*
body
)
;
[
[
nodiscard
]
]
bool
getNslots
(
uint32_t
*
nslots
)
;
[
[
nodiscard
]
]
bool
emitFunctionScript
(
FunctionNode
*
funNode
)
;
[
[
nodiscard
]
]
bool
markStepBreakpoint
(
)
;
[
[
nodiscard
]
]
bool
markSimpleBreakpoint
(
)
;
[
[
nodiscard
]
]
bool
updateLineNumberNotes
(
uint32_t
offset
)
;
[
[
nodiscard
]
]
bool
updateSourceCoordNotes
(
uint32_t
offset
)
;
[
[
nodiscard
]
]
bool
updateSourceCoordNotesIfNonLiteral
(
ParseNode
*
node
)
;
JSOp
strictifySetNameOp
(
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitCheck
(
JSOp
op
ptrdiff_t
delta
BytecodeOffset
*
offset
)
;
[
[
nodiscard
]
]
bool
emit1
(
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emit2
(
JSOp
op
uint8_t
op1
)
;
[
[
nodiscard
]
]
bool
emit3
(
JSOp
op
jsbytecode
op1
jsbytecode
op2
)
;
[
[
nodiscard
]
]
bool
emitDupAt
(
unsigned
slotFromTop
unsigned
count
=
1
)
;
[
[
nodiscard
]
]
bool
emitPopN
(
unsigned
n
)
;
[
[
nodiscard
]
]
bool
emitPickN
(
uint8_t
n
)
;
[
[
nodiscard
]
]
bool
emitUnpickN
(
uint8_t
n
)
;
[
[
nodiscard
]
]
bool
emitCheckIsObj
(
CheckIsObjectKind
kind
)
;
[
[
nodiscard
]
]
bool
emitBuiltinObject
(
BuiltinObjectKind
kind
)
;
[
[
nodiscard
]
]
bool
emitUint16Operand
(
JSOp
op
uint32_t
operand
)
;
[
[
nodiscard
]
]
bool
emitUint32Operand
(
JSOp
op
uint32_t
operand
)
;
[
[
nodiscard
]
]
bool
emitN
(
JSOp
op
size_t
extra
BytecodeOffset
*
offset
=
nullptr
)
;
[
[
nodiscard
]
]
bool
emitDouble
(
double
dval
)
;
[
[
nodiscard
]
]
bool
emitNumberOp
(
double
dval
)
;
[
[
nodiscard
]
]
bool
emitBigIntOp
(
BigIntLiteral
*
bigint
)
;
[
[
nodiscard
]
]
bool
emitThisLiteral
(
ThisLiteral
*
pn
)
;
[
[
nodiscard
]
]
bool
emitGetFunctionThis
(
NameNode
*
thisName
)
;
[
[
nodiscard
]
]
bool
emitGetThisForSuperBase
(
UnaryNode
*
superBase
)
;
[
[
nodiscard
]
]
bool
emitSetThis
(
BinaryNode
*
setThisNode
)
;
[
[
nodiscard
]
]
bool
emitCheckDerivedClassConstructorReturn
(
)
;
private
:
[
[
nodiscard
]
]
bool
emitNewTarget
(
)
;
public
:
[
[
nodiscard
]
]
bool
emitNewTarget
(
NewTargetNode
*
pn
)
;
[
[
nodiscard
]
]
bool
emitNewTarget
(
CallNode
*
pn
)
;
[
[
nodiscard
]
]
bool
emitJumpTargetOp
(
JSOp
op
BytecodeOffset
*
off
)
;
[
[
nodiscard
]
]
bool
emitJumpTarget
(
JumpTarget
*
target
)
;
[
[
nodiscard
]
]
bool
emitJumpNoFallthrough
(
JSOp
op
JumpList
*
jump
)
;
[
[
nodiscard
]
]
bool
emitJump
(
JSOp
op
JumpList
*
jump
)
;
void
patchJumpsToTarget
(
JumpList
jump
JumpTarget
target
)
;
[
[
nodiscard
]
]
bool
emitJumpTargetAndPatch
(
JumpList
jump
)
;
[
[
nodiscard
]
]
bool
emitCall
(
JSOp
op
uint16_t
argc
const
mozilla
:
:
Maybe
<
uint32_t
>
&
sourceCoordOffset
)
;
[
[
nodiscard
]
]
bool
emitCall
(
JSOp
op
uint16_t
argc
ParseNode
*
pn
=
nullptr
)
;
[
[
nodiscard
]
]
bool
emitCallIncDec
(
UnaryNode
*
incDec
)
;
uint32_t
getOffsetForLoop
(
ParseNode
*
nextpn
)
;
enum
class
GotoKind
{
Break
Continue
}
;
[
[
nodiscard
]
]
bool
emitGoto
(
NestableControl
*
target
GotoKind
kind
)
;
[
[
nodiscard
]
]
bool
emitGCIndexOp
(
JSOp
op
GCThingIndex
index
)
;
[
[
nodiscard
]
]
bool
emitAtomOp
(
JSOp
op
TaggedParserAtomIndex
atom
)
;
[
[
nodiscard
]
]
bool
emitAtomOp
(
JSOp
op
GCThingIndex
atomIndex
)
;
[
[
nodiscard
]
]
bool
emitStringOp
(
JSOp
op
TaggedParserAtomIndex
atom
)
;
[
[
nodiscard
]
]
bool
emitStringOp
(
JSOp
op
GCThingIndex
atomIndex
)
;
[
[
nodiscard
]
]
bool
emitArrayLiteral
(
ListNode
*
array
)
;
[
[
nodiscard
]
]
bool
emitArray
(
ListNode
*
array
)
;
[
[
nodiscard
]
]
bool
emitSpreadIntoArray
(
UnaryNode
*
elem
)
;
[
[
nodiscard
]
]
bool
emitInternedScopeOp
(
GCThingIndex
index
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitInternedObjectOp
(
GCThingIndex
index
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitRegExp
(
GCThingIndex
index
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitFunction
(
FunctionNode
*
funNode
bool
needsProto
=
false
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitObject
(
ListNode
*
objNode
)
;
[
[
nodiscard
]
]
bool
emitHoistedFunctionsInList
(
ListNode
*
stmtList
)
;
void
isPropertyListObjLiteralCompatible
(
ListNode
*
obj
bool
*
withValues
bool
*
withoutValues
)
;
bool
isArrayObjLiteralCompatible
(
ListNode
*
array
)
;
[
[
nodiscard
]
]
bool
emitPropertyList
(
ListNode
*
obj
PropertyEmitter
&
pe
PropListType
type
)
;
[
[
nodiscard
]
]
bool
emitPropertyListObjLiteral
(
ListNode
*
obj
JSOp
op
bool
useObjLiteralValues
)
;
[
[
nodiscard
]
]
bool
emitDestructuringRestExclusionSetObjLiteral
(
ListNode
*
pattern
)
;
[
[
nodiscard
]
]
bool
emitObjLiteralArray
(
ListNode
*
array
)
;
[
[
nodiscard
]
]
bool
isRHSObjLiteralCompatible
(
ParseNode
*
value
)
;
[
[
nodiscard
]
]
bool
emitObjLiteralValue
(
ObjLiteralWriter
&
writer
ParseNode
*
value
)
;
mozilla
:
:
Maybe
<
MemberInitializers
>
setupMemberInitializers
(
ListNode
*
classMembers
FieldPlacement
placement
)
;
[
[
nodiscard
]
]
bool
emitCreateFieldKeys
(
ListNode
*
obj
FieldPlacement
placement
)
;
[
[
nodiscard
]
]
bool
emitCreateMemberInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
FieldPlacement
placement
#
ifdef
ENABLE_DECORATORS
bool
hasHeritage
#
endif
)
;
const
MemberInitializers
&
findMemberInitializersForCall
(
)
;
[
[
nodiscard
]
]
bool
emitInitializeInstanceMembers
(
bool
isDerivedClassConstructor
)
;
[
[
nodiscard
]
]
bool
emitInitializeStaticFields
(
ListNode
*
classMembers
)
;
[
[
nodiscard
]
]
bool
emitPrivateMethodInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
)
;
[
[
nodiscard
]
]
bool
emitPrivateMethodInitializer
(
ClassMethod
*
classMethod
TaggedParserAtomIndex
storedMethodAtom
)
;
[
[
nodiscard
]
]
bool
emitLocalOp
(
JSOp
op
uint32_t
slot
)
;
[
[
nodiscard
]
]
bool
emitArgOp
(
JSOp
op
uint16_t
slot
)
;
[
[
nodiscard
]
]
bool
emitEnvCoordOp
(
JSOp
op
EnvironmentCoordinate
ec
)
;
[
[
nodiscard
]
]
bool
emitGetNameAtLocation
(
TaggedParserAtomIndex
name
const
NameLocation
&
loc
)
;
[
[
nodiscard
]
]
bool
emitGetName
(
TaggedParserAtomIndex
name
)
{
return
emitGetNameAtLocation
(
name
lookupName
(
name
)
)
;
}
[
[
nodiscard
]
]
bool
emitGetName
(
NameNode
*
name
)
;
[
[
nodiscard
]
]
bool
emitGetPrivateName
(
NameNode
*
name
)
;
[
[
nodiscard
]
]
bool
emitGetPrivateName
(
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
emitTDZCheckIfNeeded
(
TaggedParserAtomIndex
name
const
NameLocation
&
loc
ValueIsOnStack
isOnStack
)
;
[
[
nodiscard
]
]
bool
emitNameIncDec
(
UnaryNode
*
incDec
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitDeclarationList
(
ListNode
*
declList
)
;
[
[
nodiscard
]
]
bool
emitSingleDeclaration
(
ListNode
*
declList
NameNode
*
decl
ParseNode
*
initializer
)
;
[
[
nodiscard
]
]
bool
emitAssignmentRhs
(
ParseNode
*
rhs
TaggedParserAtomIndex
anonFunctionName
)
;
[
[
nodiscard
]
]
bool
emitAssignmentRhs
(
uint8_t
offset
)
;
[
[
nodiscard
]
]
bool
emitPrepareIteratorResult
(
)
;
[
[
nodiscard
]
]
bool
emitFinishIteratorResult
(
bool
done
)
;
[
[
nodiscard
]
]
bool
addObjLiteralData
(
ObjLiteralWriter
&
writer
GCThingIndex
*
outIndex
)
;
[
[
nodiscard
]
]
bool
emitGetDotGeneratorInInnermostScope
(
)
{
return
emitGetDotGeneratorInScope
(
*
innermostEmitterScope
(
)
)
;
}
[
[
nodiscard
]
]
bool
emitGetDotGeneratorInScope
(
EmitterScope
&
currentScope
)
;
[
[
nodiscard
]
]
bool
allocateResumeIndex
(
BytecodeOffset
offset
uint32_t
*
resumeIndex
)
;
[
[
nodiscard
]
]
bool
allocateResumeIndexRange
(
mozilla
:
:
Span
<
BytecodeOffset
>
offsets
uint32_t
*
firstResumeIndex
)
;
[
[
nodiscard
]
]
bool
emitInitialYield
(
UnaryNode
*
yieldNode
)
;
[
[
nodiscard
]
]
bool
emitYield
(
UnaryNode
*
yieldNode
)
;
[
[
nodiscard
]
]
bool
emitYieldOp
(
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitYieldStar
(
ParseNode
*
iter
)
;
[
[
nodiscard
]
]
bool
emitAwaitInInnermostScope
(
)
{
return
emitAwaitInScope
(
*
innermostEmitterScope
(
)
)
;
}
[
[
nodiscard
]
]
bool
emitAwaitInInnermostScope
(
UnaryNode
*
awaitNode
)
;
[
[
nodiscard
]
]
bool
emitAwaitInScope
(
EmitterScope
&
currentScope
)
;
[
[
nodiscard
]
]
bool
emitPushResumeKind
(
GeneratorResumeKind
kind
)
;
[
[
nodiscard
]
]
bool
emitPropLHS
(
PropertyAccess
*
prop
)
;
[
[
nodiscard
]
]
bool
emitPropIncDec
(
UnaryNode
*
incDec
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitComputedPropertyName
(
UnaryNode
*
computedPropName
)
;
enum
class
EmitElemOption
{
Get
Call
IncDec
CompoundAssign
Ref
}
;
[
[
nodiscard
]
]
bool
emitElemOperands
(
PropertyByValue
*
elem
EmitElemOption
opts
)
;
[
[
nodiscard
]
]
bool
emitElemObjAndKey
(
PropertyByValue
*
elem
ElemOpEmitter
&
eoe
)
;
[
[
nodiscard
]
]
bool
emitElemOpBase
(
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitElemIncDec
(
UnaryNode
*
incDec
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitObjAndPrivateName
(
PrivateMemberAccess
*
elem
ElemOpEmitter
&
eoe
)
;
[
[
nodiscard
]
]
bool
emitPrivateIncDec
(
UnaryNode
*
incDec
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitCatch
(
BinaryNode
*
catchClause
)
;
[
[
nodiscard
]
]
bool
emitIf
(
TernaryNode
*
ifNode
)
;
[
[
nodiscard
]
]
bool
emitWith
(
BinaryNode
*
withNode
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitLabeledStatement
(
const
LabeledStatement
*
labeledStmt
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitLexicalScope
(
LexicalScopeNode
*
lexicalScope
)
;
[
[
nodiscard
]
]
bool
emitLexicalScopeBody
(
ParseNode
*
body
EmitLineNumberNote
emitLineNote
=
EMIT_LINENOTE
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitSwitch
(
SwitchStatement
*
switchStmt
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitTry
(
TryNode
*
tryNode
)
;
[
[
nodiscard
]
]
bool
emitJumpToFinally
(
JumpList
*
jump
uint32_t
idx
)
;
[
[
nodiscard
]
]
bool
emitDestructuringLHSRef
(
ParseNode
*
target
DestructuringFlavor
flav
DestructuringLHSRef
&
lref
)
;
[
[
nodiscard
]
]
bool
emitSetOrInitializeDestructuring
(
ParseNode
*
target
DestructuringFlavor
flav
DestructuringLHSRef
&
lref
)
;
[
[
nodiscard
]
]
bool
emitDestructuringObjRestExclusionSet
(
ListNode
*
pattern
)
;
[
[
nodiscard
]
]
bool
emitDestructuringOps
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
[
[
nodiscard
]
]
bool
emitDestructuringOpsArray
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
[
[
nodiscard
]
]
bool
emitDestructuringOpsObject
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
enum
class
CopyOption
{
Filtered
Unfiltered
}
;
[
[
nodiscard
]
]
bool
emitCopyDataProperties
(
CopyOption
option
)
;
JSOp
getIterCallOp
(
JSOp
callOp
SelfHostedIter
selfHostedIter
)
;
[
[
nodiscard
]
]
bool
emitIterable
(
ParseNode
*
value
SelfHostedIter
selfHostedIter
IteratorKind
iterKind
=
IteratorKind
:
:
Sync
)
;
[
[
nodiscard
]
]
bool
emitIterator
(
SelfHostedIter
selfHostedIter
)
;
[
[
nodiscard
]
]
bool
emitAsyncIterator
(
SelfHostedIter
selfHostedIter
)
;
[
[
nodiscard
]
]
bool
emitIteratorNext
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
callSourceCoordOffset
IteratorKind
kind
=
IteratorKind
:
:
Sync
SelfHostedIter
selfHostedIter
=
SelfHostedIter
:
:
Deny
)
;
[
[
nodiscard
]
]
bool
emitIteratorCloseInScope
(
EmitterScope
&
currentScope
IteratorKind
iterKind
=
IteratorKind
:
:
Sync
CompletionKind
completionKind
=
CompletionKind
:
:
Normal
SelfHostedIter
selfHostedIter
=
SelfHostedIter
:
:
Deny
)
;
[
[
nodiscard
]
]
bool
emitIteratorCloseInInnermostScope
(
IteratorKind
iterKind
=
IteratorKind
:
:
Sync
CompletionKind
completionKind
=
CompletionKind
:
:
Normal
SelfHostedIter
selfHostedIter
=
SelfHostedIter
:
:
Deny
)
{
return
emitIteratorCloseInScope
(
*
innermostEmitterScope
(
)
iterKind
completionKind
selfHostedIter
)
;
}
template
<
typename
InnerEmitter
>
[
[
nodiscard
]
]
bool
wrapWithDestructuringTryNote
(
int32_t
iterDepth
InnerEmitter
emitter
)
;
[
[
nodiscard
]
]
bool
defineHoistedTopLevelFunctions
(
ParseNode
*
body
)
;
[
[
nodiscard
]
]
bool
emitDefault
(
ParseNode
*
defaultExpr
ParseNode
*
pattern
)
;
[
[
nodiscard
]
]
bool
emitAnonymousFunctionWithName
(
ParseNode
*
node
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
emitAnonymousFunctionWithComputedName
(
ParseNode
*
node
FunctionPrefixKind
prefixKind
)
;
[
[
nodiscard
]
]
bool
setFunName
(
FunctionBox
*
fun
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
emitInitializer
(
ParseNode
*
initializer
ParseNode
*
pattern
)
;
[
[
nodiscard
]
]
bool
emitCallSiteObjectArray
(
ObjLiteralWriter
&
writer
ListNode
*
cookedOrRaw
ParseNode
*
head
uint32_t
count
)
;
[
[
nodiscard
]
]
bool
emitCallSiteObject
(
CallSiteNode
*
callSiteObj
)
;
[
[
nodiscard
]
]
bool
emitTemplateString
(
ListNode
*
templateString
)
;
[
[
nodiscard
]
]
bool
emitAssignmentOrInit
(
ParseNodeKind
kind
ParseNode
*
lhs
ParseNode
*
rhs
)
;
[
[
nodiscard
]
]
bool
emitShortCircuitAssignment
(
AssignmentNode
*
node
)
;
[
[
nodiscard
]
]
bool
emitReturn
(
UnaryNode
*
returnNode
)
;
[
[
nodiscard
]
]
bool
finishReturn
(
BytecodeOffset
setRvalOffset
)
;
[
[
nodiscard
]
]
bool
emitExpressionStatement
(
UnaryNode
*
exprStmt
)
;
[
[
nodiscard
]
]
bool
emitStatementList
(
ListNode
*
stmtList
)
;
[
[
nodiscard
]
]
bool
emitDeleteName
(
UnaryNode
*
deleteNode
)
;
[
[
nodiscard
]
]
bool
emitDeleteProperty
(
UnaryNode
*
deleteNode
)
;
[
[
nodiscard
]
]
bool
emitDeleteElement
(
UnaryNode
*
deleteNode
)
;
[
[
nodiscard
]
]
bool
emitDeleteExpression
(
UnaryNode
*
deleteNode
)
;
[
[
nodiscard
]
]
bool
emitOptionalChain
(
UnaryNode
*
expr
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitCalleeAndThisForOptionalChain
(
UnaryNode
*
expr
CallNode
*
callNode
CallOrNewEmitter
&
cone
)
;
[
[
nodiscard
]
]
bool
emitDeleteOptionalChain
(
UnaryNode
*
deleteNode
)
;
[
[
nodiscard
]
]
bool
emitOptionalDotExpression
(
PropertyAccessBase
*
expr
PropOpEmitter
&
poe
bool
isSuper
OptionalEmitter
&
oe
)
;
[
[
nodiscard
]
]
bool
emitOptionalElemExpression
(
PropertyByValueBase
*
elem
ElemOpEmitter
&
eoe
bool
isSuper
OptionalEmitter
&
oe
)
;
[
[
nodiscard
]
]
bool
emitOptionalPrivateExpression
(
PrivateMemberAccessBase
*
privateExpr
PrivateOpEmitter
&
xoe
OptionalEmitter
&
oe
)
;
[
[
nodiscard
]
]
bool
emitOptionalCall
(
CallNode
*
callNode
OptionalEmitter
&
oe
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitDeletePropertyInOptChain
(
PropertyAccessBase
*
propExpr
OptionalEmitter
&
oe
)
;
[
[
nodiscard
]
]
bool
emitDeleteElementInOptChain
(
PropertyByValueBase
*
elemExpr
OptionalEmitter
&
oe
)
;
[
[
nodiscard
]
]
bool
emitTypeof
(
UnaryNode
*
typeofNode
JSOp
op
)
;
[
[
nodiscard
]
]
bool
tryEmitTypeofEq
(
ListNode
*
node
bool
*
emitted
)
;
[
[
nodiscard
]
]
bool
emitUnary
(
UnaryNode
*
unaryNode
)
;
[
[
nodiscard
]
]
bool
emitRightAssociative
(
ListNode
*
node
)
;
[
[
nodiscard
]
]
bool
emitLeftAssociative
(
ListNode
*
node
)
;
[
[
nodiscard
]
]
bool
emitPrivateInExpr
(
ListNode
*
node
)
;
[
[
nodiscard
]
]
bool
emitShortCircuit
(
ListNode
*
node
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitSequenceExpr
(
ListNode
*
node
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
MOZ_NEVER_INLINE
bool
emitIncOrDec
(
UnaryNode
*
incDec
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitConditionalExpression
(
ConditionalExpression
&
conditional
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
ParseNode
*
getCoordNode
(
ParseNode
*
callNode
ParseNode
*
calleeNode
JSOp
op
ListNode
*
argsList
)
;
[
[
nodiscard
]
]
bool
emitArguments
(
ListNode
*
argsList
bool
isCall
bool
isSpread
CallOrNewEmitter
&
cone
)
;
[
[
nodiscard
]
]
bool
emitCallOrNew
(
CallNode
*
callNode
ValueUsage
valueUsage
)
;
[
[
nodiscard
]
]
bool
emitDebugCheckSelfHosted
(
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedCallFunction
(
CallNode
*
callNode
JSOp
op
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedResumeGenerator
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedForceInterpreter
(
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedAllowContentIter
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedAllowContentIterWith
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedAllowContentIterWithNext
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedDefineDataProperty
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetPropertySuper
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedHasOwn
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedToNumeric
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedToString
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedIsNullOrUndefined
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedIteratorClose
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetBuiltinConstructor
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetBuiltinPrototype
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetBuiltinSymbol
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedSetIsInlinableLargeFunction
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedSetCanonicalName
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedArgumentsLength
(
CallNode
*
callNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetArgument
(
CallNode
*
callNode
)
;
#
ifdef
DEBUG
void
assertSelfHostedExpectedTopLevel
(
ParseNode
*
node
)
;
void
assertSelfHostedUnsafeGetReservedSlot
(
ListNode
*
argsList
)
;
void
assertSelfHostedUnsafeSetReservedSlot
(
ListNode
*
argsList
)
;
#
endif
[
[
nodiscard
]
]
bool
emitDo
(
BinaryNode
*
doNode
)
;
[
[
nodiscard
]
]
bool
emitWhile
(
BinaryNode
*
whileNode
)
;
[
[
nodiscard
]
]
bool
emitFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
=
nullptr
)
;
[
[
nodiscard
]
]
bool
emitCStyleFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
[
[
nodiscard
]
]
bool
emitForIn
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
[
[
nodiscard
]
]
bool
emitForOf
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
[
[
nodiscard
]
]
bool
emitInitializeForInOrOfTarget
(
TernaryNode
*
forHead
)
;
[
[
nodiscard
]
]
bool
emitBreak
(
TaggedParserAtomIndex
label
)
;
[
[
nodiscard
]
]
bool
emitContinue
(
TaggedParserAtomIndex
label
)
;
[
[
nodiscard
]
]
bool
emitFunctionFormalParameters
(
ParamsBodyNode
*
paramsBody
)
;
[
[
nodiscard
]
]
bool
emitInitializeFunctionSpecialNames
(
)
;
[
[
nodiscard
]
]
bool
emitLexicalInitialization
(
NameNode
*
name
)
;
[
[
nodiscard
]
]
bool
emitLexicalInitialization
(
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
emitSpread
(
SelfHostedIter
selfHostedIter
int
spreadeeStackItems
JSOp
storeElementOp
)
;
[
[
nodiscard
]
]
bool
emitSpread
(
SelfHostedIter
selfHostedIter
)
;
enum
class
ClassNameKind
{
BindingName
InferredName
ComputedName
}
;
[
[
nodiscard
]
]
bool
emitClass
(
ClassNode
*
classNode
ClassNameKind
nameKind
=
ClassNameKind
:
:
BindingName
TaggedParserAtomIndex
nameForAnonymousClass
=
TaggedParserAtomIndex
:
:
null
(
)
)
;
[
[
nodiscard
]
]
bool
emitSuperElemOperands
(
PropertyByValue
*
elem
EmitElemOption
opts
=
EmitElemOption
:
:
Get
)
;
[
[
nodiscard
]
]
bool
emitSuperGetElem
(
PropertyByValue
*
elem
bool
isCall
=
false
)
;
[
[
nodiscard
]
]
bool
emitCalleeAndThis
(
ParseNode
*
callee
CallNode
*
maybeCall
CallOrNewEmitter
&
cone
)
;
[
[
nodiscard
]
]
bool
emitOptionalCalleeAndThis
(
ParseNode
*
callee
CallNode
*
call
CallOrNewEmitter
&
cone
OptionalEmitter
&
oe
)
;
#
ifdef
ENABLE_RECORD_TUPLE
[
[
nodiscard
]
]
bool
emitRecordLiteral
(
ListNode
*
record
)
;
[
[
nodiscard
]
]
bool
emitTupleLiteral
(
ListNode
*
tuple
)
;
#
endif
[
[
nodiscard
]
]
bool
emitExportDefault
(
BinaryNode
*
exportNode
)
;
[
[
nodiscard
]
]
bool
emitReturnRval
(
)
{
return
emit1
(
JSOp
:
:
RetRval
)
;
}
[
[
nodiscard
]
]
bool
emitCheckPrivateField
(
ThrowCondition
throwCondition
ThrowMsgKind
msgKind
)
{
return
emit3
(
JSOp
:
:
CheckPrivateField
uint8_t
(
throwCondition
)
uint8_t
(
msgKind
)
)
;
}
[
[
nodiscard
]
]
bool
emitNewPrivateName
(
TaggedParserAtomIndex
bindingName
TaggedParserAtomIndex
symbolName
)
;
template
<
class
ClassMemberType
>
[
[
nodiscard
]
]
bool
emitNewPrivateNames
(
ListNode
*
classMembers
)
;
[
[
nodiscard
]
]
bool
emitNewPrivateNames
(
TaggedParserAtomIndex
privateBrandName
ListNode
*
classMembers
)
;
[
[
nodiscard
]
]
js
:
:
UniquePtr
<
ImmutableScriptData
>
createImmutableScriptData
(
)
;
#
if
defined
(
ENABLE_DECORATORS
)
|
|
defined
(
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
)
[
[
nodiscard
]
]
bool
emitCheckIsCallable
(
)
;
#
endif
private
:
[
[
nodiscard
]
]
SelfHostedIter
getSelfHostedIterFor
(
ParseNode
*
parseNode
)
;
[
[
nodiscard
]
]
bool
emitSelfHostedGetBuiltinConstructorOrPrototype
(
CallNode
*
callNode
bool
isConstructor
)
;
public
:
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dumpAtom
(
TaggedParserAtomIndex
index
)
const
;
#
endif
}
;
class
MOZ_RAII
AutoCheckUnstableEmitterScope
{
#
ifdef
DEBUG
bool
prev_
;
BytecodeEmitter
*
bce_
;
#
endif
public
:
AutoCheckUnstableEmitterScope
(
)
=
delete
;
explicit
AutoCheckUnstableEmitterScope
(
BytecodeEmitter
*
bce
)
#
ifdef
DEBUG
:
bce_
(
bce
)
#
endif
{
#
ifdef
DEBUG
prev_
=
bce_
-
>
unstableEmitterScope
;
bce_
-
>
unstableEmitterScope
=
true
;
#
endif
}
~
AutoCheckUnstableEmitterScope
(
)
{
#
ifdef
DEBUG
bce_
-
>
unstableEmitterScope
=
prev_
;
#
endif
}
}
;
}
}
#
endif
