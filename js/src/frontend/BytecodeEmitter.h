#
ifndef
frontend_BytecodeEmitter_h
#
define
frontend_BytecodeEmitter_h
#
include
"
jscntxt
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
frontend
/
ParseMaps
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
namespace
js
{
class
ScopeObject
;
namespace
frontend
{
class
FullParseHandler
;
class
ObjectBox
;
class
ParseNode
;
template
<
typename
ParseHandler
>
class
Parser
;
class
SharedContext
;
class
TokenStream
;
class
CGConstList
{
Vector
<
Value
>
list
;
public
:
explicit
CGConstList
(
ExclusiveContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
Value
v
)
{
MOZ_ASSERT_IF
(
v
.
isString
(
)
v
.
toString
(
)
-
>
isAtom
(
)
)
;
return
list
.
append
(
v
)
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
ConstArray
*
array
)
;
}
;
struct
CGObjectList
{
uint32_t
length
;
ObjectBox
*
lastbox
;
CGObjectList
(
)
:
length
(
0
)
lastbox
(
nullptr
)
{
}
unsigned
add
(
ObjectBox
*
objbox
)
;
unsigned
indexOf
(
JSObject
*
obj
)
;
void
finish
(
ObjectArray
*
array
)
;
ObjectBox
*
find
(
uint32_t
index
)
;
}
;
struct
CGTryNoteList
{
Vector
<
JSTryNote
>
list
;
explicit
CGTryNoteList
(
ExclusiveContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
size_t
start
size_t
end
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
TryNoteArray
*
array
)
;
}
;
struct
CGBlockScopeNote
:
public
BlockScopeNote
{
uint32_t
end
;
bool
startInPrologue
;
bool
endInPrologue
;
}
;
struct
CGBlockScopeList
{
Vector
<
CGBlockScopeNote
>
list
;
explicit
CGBlockScopeList
(
ExclusiveContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
scopeObjectIndex
uint32_t
offset
bool
inPrologue
uint32_t
parent
)
;
uint32_t
findEnclosingScope
(
uint32_t
index
)
;
void
recordEnd
(
uint32_t
index
uint32_t
offset
bool
inPrologue
)
;
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
BlockScopeArray
*
array
uint32_t
prologueLength
)
;
}
;
struct
CGYieldOffsetList
{
Vector
<
uint32_t
>
list
;
explicit
CGYieldOffsetList
(
ExclusiveContext
*
cx
)
:
list
(
cx
)
{
}
MOZ_MUST_USE
bool
append
(
uint32_t
offset
)
{
return
list
.
append
(
offset
)
;
}
size_t
length
(
)
const
{
return
list
.
length
(
)
;
}
void
finish
(
YieldOffsetArray
&
array
uint32_t
prologueLength
)
;
}
;
struct
LoopStmtInfo
;
struct
StmtInfoBCE
;
typedef
Vector
<
jsbytecode
0
>
BytecodeVector
;
typedef
Vector
<
jssrcnote
0
>
SrcNotesVector
;
enum
VarEmitOption
{
InitializeVars
DefineVars
PushInitialValues
AnnexB
}
;
struct
JumpTarget
{
ptrdiff_t
offset
;
}
;
struct
JumpList
{
JumpList
(
)
:
offset
(
-
1
)
{
}
ptrdiff_t
offset
;
void
push
(
jsbytecode
*
code
ptrdiff_t
jumpOffset
)
;
void
patchAll
(
jsbytecode
*
code
JumpTarget
target
)
;
}
;
struct
BytecodeEmitter
{
SharedContext
*
const
sc
;
ExclusiveContext
*
const
cx
;
BytecodeEmitter
*
const
parent
;
Rooted
<
JSScript
*
>
script
;
Rooted
<
LazyScript
*
>
lazyScript
;
struct
EmitSection
{
BytecodeVector
code
;
SrcNotesVector
notes
;
ptrdiff_t
lastNoteOffset
;
uint32_t
currentLine
;
uint32_t
lastColumn
;
JumpTarget
lastTarget
;
EmitSection
(
ExclusiveContext
*
cx
uint32_t
lineNum
)
:
code
(
cx
)
notes
(
cx
)
lastNoteOffset
(
0
)
currentLine
(
lineNum
)
lastColumn
(
0
)
lastTarget
{
-
1
-
ptrdiff_t
(
JSOP_JUMPTARGET_LENGTH
)
}
{
}
}
;
EmitSection
prologue
main
*
current
;
Parser
<
FullParseHandler
>
*
const
parser
;
HandleScript
evalCaller
;
StmtInfoStack
<
StmtInfoBCE
>
stmtStack
;
OwnedAtomIndexMapPtr
atomIndices
;
unsigned
firstLine
;
Vector
<
uint32_t
16
>
localsToFrameSlots_
;
int32_t
stackDepth
;
uint32_t
maxStackDepth
;
uint32_t
arrayCompDepth
;
unsigned
emitLevel
;
CGConstList
constList
;
CGObjectList
objectList
;
CGTryNoteList
tryNoteList
;
CGBlockScopeList
blockScopeList
;
CGYieldOffsetList
yieldOffsetList
;
uint16_t
typesetCount
;
bool
hasSingletons
:
1
;
bool
hasTryFinally
:
1
;
bool
emittingForInit
:
1
;
bool
emittingRunOnceLambda
:
1
;
bool
isRunOnceLambda
(
)
;
bool
insideEval
:
1
;
const
bool
insideNonGlobalEval
:
1
;
bool
insideModule
:
1
;
enum
EmitterMode
{
Normal
SelfHosting
LazyFunction
}
;
const
EmitterMode
emitterMode
;
uint32_t
functionBodyEndPos
;
bool
functionBodyEndPosSet
;
BytecodeEmitter
(
BytecodeEmitter
*
parent
Parser
<
FullParseHandler
>
*
parser
SharedContext
*
sc
HandleScript
script
Handle
<
LazyScript
*
>
lazyScript
bool
insideEval
HandleScript
evalCaller
bool
insideNonGlobalEval
uint32_t
lineNum
EmitterMode
emitterMode
=
Normal
)
;
BytecodeEmitter
(
BytecodeEmitter
*
parent
Parser
<
FullParseHandler
>
*
parser
SharedContext
*
sc
HandleScript
script
Handle
<
LazyScript
*
>
lazyScript
bool
insideEval
HandleScript
evalCaller
bool
insideNonGlobalEval
TokenPos
bodyPosition
EmitterMode
emitterMode
=
Normal
)
;
MOZ_MUST_USE
bool
init
(
)
;
MOZ_MUST_USE
bool
updateLocalsToFrameSlots
(
)
;
StmtInfoBCE
*
innermostStmt
(
)
const
{
return
stmtStack
.
innermost
(
)
;
}
StmtInfoBCE
*
innermostScopeStmt
(
)
const
{
return
stmtStack
.
innermostScopeStmt
(
)
;
}
JSObject
*
innermostStaticScope
(
)
const
;
JSObject
*
blockScopeOfDef
(
Definition
*
dn
)
const
{
return
parser
-
>
blockScopes
[
dn
-
>
pn_blockid
]
;
}
bool
atBodyLevel
(
StmtInfoBCE
*
stmt
)
const
;
bool
atBodyLevel
(
)
const
{
return
atBodyLevel
(
innermostStmt
(
)
)
;
}
uint32_t
computeHops
(
ParseNode
*
pn
BytecodeEmitter
*
*
bceOfDefOut
)
;
bool
isAliasedName
(
BytecodeEmitter
*
bceOfDef
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
computeDefinitionIsAliased
(
BytecodeEmitter
*
bceOfDef
Definition
*
dn
JSOp
*
op
)
;
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
bool
makeAtomIndex
(
JSAtom
*
atom
jsatomid
*
indexp
)
{
AtomIndexAddPtr
p
=
atomIndices
-
>
lookupForAdd
(
atom
)
;
if
(
p
)
{
*
indexp
=
p
.
value
(
)
;
return
true
;
}
jsatomid
index
=
atomIndices
-
>
count
(
)
;
if
(
!
atomIndices
-
>
add
(
p
atom
index
)
)
return
false
;
*
indexp
=
index
;
return
true
;
}
bool
isInLoop
(
)
;
MOZ_MUST_USE
bool
checkSingletonContext
(
)
;
MOZ_MUST_USE
bool
checkRunOnceContext
(
)
;
bool
needsImplicitThis
(
)
;
void
tellDebuggerAboutCompiledScript
(
ExclusiveContext
*
cx
)
;
inline
TokenStream
*
tokenStream
(
)
;
BytecodeVector
&
code
(
)
const
{
return
current
-
>
code
;
}
jsbytecode
*
code
(
ptrdiff_t
offset
)
const
{
return
current
-
>
code
.
begin
(
)
+
offset
;
}
ptrdiff_t
offset
(
)
const
{
return
current
-
>
code
.
end
(
)
-
current
-
>
code
.
begin
(
)
;
}
ptrdiff_t
prologueOffset
(
)
const
{
return
prologue
.
code
.
end
(
)
-
prologue
.
code
.
begin
(
)
;
}
void
switchToMain
(
)
{
current
=
&
main
;
}
void
switchToPrologue
(
)
{
current
=
&
prologue
;
}
bool
inPrologue
(
)
const
{
return
current
=
=
&
prologue
;
}
SrcNotesVector
&
notes
(
)
const
{
return
current
-
>
notes
;
}
ptrdiff_t
lastNoteOffset
(
)
const
{
return
current
-
>
lastNoteOffset
;
}
unsigned
currentLine
(
)
const
{
return
current
-
>
currentLine
;
}
unsigned
lastColumn
(
)
const
{
return
current
-
>
lastColumn
;
}
bool
lastOpcodeIsJumpTarget
(
)
const
{
return
offset
(
)
-
current
-
>
lastTarget
.
offset
=
=
ptrdiff_t
(
JSOP_JUMPTARGET_LENGTH
)
;
}
ptrdiff_t
lastNonJumpTargetOffset
(
)
const
{
return
lastOpcodeIsJumpTarget
(
)
?
current
-
>
lastTarget
.
offset
:
offset
(
)
;
}
void
setFunctionBodyEndPos
(
TokenPos
pos
)
{
functionBodyEndPos
=
pos
.
end
;
functionBodyEndPosSet
=
true
;
}
bool
reportError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
;
bool
reportStrictWarning
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
;
bool
reportStrictModeError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
;
MOZ_MUST_USE
bool
checkSideEffects
(
ParseNode
*
pn
bool
*
answer
)
;
#
ifdef
DEBUG
MOZ_MUST_USE
bool
checkStrictOrSloppy
(
JSOp
op
)
;
#
endif
MOZ_MUST_USE
bool
newSrcNote
(
SrcNoteType
type
unsigned
*
indexp
=
nullptr
)
;
MOZ_MUST_USE
bool
newSrcNote2
(
SrcNoteType
type
ptrdiff_t
offset
unsigned
*
indexp
=
nullptr
)
;
MOZ_MUST_USE
bool
newSrcNote3
(
SrcNoteType
type
ptrdiff_t
offset1
ptrdiff_t
offset2
unsigned
*
indexp
=
nullptr
)
;
void
copySrcNotes
(
jssrcnote
*
destination
uint32_t
nsrcnotes
)
;
MOZ_MUST_USE
bool
setSrcNoteOffset
(
unsigned
index
unsigned
which
ptrdiff_t
offset
)
;
MOZ_MUST_USE
bool
addToSrcNoteDelta
(
jssrcnote
*
sn
ptrdiff_t
delta
)
;
MOZ_MUST_USE
bool
finishTakingSrcNotes
(
uint32_t
*
out
)
;
enum
EmitLineNumberNote
{
EMIT_LINENOTE
SUPPRESS_LINENOTE
}
;
MOZ_MUST_USE
bool
emitTree
(
ParseNode
*
pn
EmitLineNumberNote
emitLineNote
=
EMIT_LINENOTE
)
;
MOZ_MUST_USE
bool
emitFunctionScript
(
ParseNode
*
body
)
;
MOZ_MUST_USE
bool
emitModuleScript
(
ParseNode
*
body
)
;
void
checkTypeSet
(
JSOp
op
)
;
void
updateDepth
(
ptrdiff_t
target
)
;
MOZ_MUST_USE
bool
updateLineNumberNotes
(
uint32_t
offset
)
;
MOZ_MUST_USE
bool
updateSourceCoordNotes
(
uint32_t
offset
)
;
MOZ_MUST_USE
bool
bindNameToSlot
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
bindNameToSlotHelper
(
ParseNode
*
pn
)
;
void
strictifySetNameNode
(
ParseNode
*
pn
)
;
JSOp
strictifySetNameOp
(
JSOp
op
)
;
MOZ_MUST_USE
bool
tryConvertFreeName
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
popStatement
(
)
;
void
pushStatement
(
StmtInfoBCE
*
stmt
StmtType
type
JumpTarget
top
)
;
void
pushStatementInner
(
StmtInfoBCE
*
stmt
StmtType
type
JumpTarget
top
)
;
void
pushLoopStatement
(
LoopStmtInfo
*
stmt
StmtType
type
JumpTarget
top
)
;
MOZ_MUST_USE
bool
enterNestedScope
(
StmtInfoBCE
*
stmt
ObjectBox
*
objbox
StmtType
stmtType
)
;
MOZ_MUST_USE
bool
leaveNestedScope
(
StmtInfoBCE
*
stmt
)
;
MOZ_MUST_USE
bool
enterBlockScope
(
StmtInfoBCE
*
stmtInfo
ObjectBox
*
objbox
JSOp
initialValueOp
unsigned
alreadyPushed
=
0
)
;
MOZ_MUST_USE
bool
computeAliasedSlots
(
Handle
<
StaticBlockScope
*
>
blockScope
)
;
MOZ_MUST_USE
bool
lookupAliasedName
(
HandleScript
script
PropertyName
*
name
uint32_t
*
pslot
ParseNode
*
pn
=
nullptr
)
;
MOZ_MUST_USE
bool
lookupAliasedNameSlot
(
PropertyName
*
name
ScopeCoordinate
*
sc
)
;
void
computeLocalOffset
(
Handle
<
StaticBlockScope
*
>
blockScope
)
;
MOZ_MUST_USE
bool
flushPops
(
int
*
npops
)
;
MOZ_MUST_USE
bool
emitCheck
(
ptrdiff_t
delta
ptrdiff_t
*
offset
)
;
MOZ_MUST_USE
bool
emit1
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emit2
(
JSOp
op
uint8_t
op1
)
;
MOZ_MUST_USE
bool
emit3
(
JSOp
op
jsbytecode
op1
jsbytecode
op2
)
;
MOZ_MUST_USE
bool
emitDupAt
(
unsigned
slotFromTop
)
;
MOZ_MUST_USE
bool
emitCheckIsObj
(
CheckIsObjectKind
kind
)
;
MOZ_MUST_USE
bool
emitUint16Operand
(
JSOp
op
uint32_t
operand
)
;
MOZ_MUST_USE
bool
emitUint32Operand
(
JSOp
op
uint32_t
operand
)
;
MOZ_MUST_USE
bool
emitN
(
JSOp
op
size_t
extra
ptrdiff_t
*
offset
=
nullptr
)
;
MOZ_MUST_USE
bool
emitNumberOp
(
double
dval
)
;
MOZ_MUST_USE
bool
emitThisLiteral
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitCreateFunctionThis
(
)
;
MOZ_MUST_USE
bool
emitGetFunctionThis
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitGetThisForSuperBase
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSetThis
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitLoadFromEnclosingFunctionScope
(
BindingIter
&
bi
)
;
MOZ_MUST_USE
bool
emitStoreToEnclosingFunctionScope
(
BindingIter
&
bi
)
;
uint32_t
computeHopsToEnclosingFunction
(
)
;
MOZ_MUST_USE
bool
emitJumpTarget
(
JumpTarget
*
target
)
;
MOZ_MUST_USE
bool
emitJumpNoFallthrough
(
JSOp
op
JumpList
*
jump
)
;
MOZ_MUST_USE
bool
emitJump
(
JSOp
op
JumpList
*
jump
)
;
MOZ_MUST_USE
bool
emitBackwardJump
(
JSOp
op
JumpTarget
target
JumpList
*
jump
JumpTarget
*
fallthrough
)
;
void
patchJumpsToTarget
(
JumpList
jump
JumpTarget
target
)
;
MOZ_MUST_USE
bool
emitJumpTargetAndPatch
(
JumpList
jump
)
;
MOZ_MUST_USE
bool
emitCall
(
JSOp
op
uint16_t
argc
ParseNode
*
pn
=
nullptr
)
;
MOZ_MUST_USE
bool
emitLoopHead
(
ParseNode
*
nextpn
JumpTarget
*
top
)
;
MOZ_MUST_USE
bool
emitLoopEntry
(
ParseNode
*
nextpn
JumpList
entryJump
)
;
void
setContinueTarget
(
StmtInfoBCE
*
stmt
JumpTarget
target
)
;
void
setContinueHere
(
StmtInfoBCE
*
stmt
)
;
MOZ_MUST_USE
bool
emitGoto
(
StmtInfoBCE
*
toStmt
JumpList
*
jumplist
SrcNoteType
noteType
=
SRC_NULL
)
;
MOZ_MUST_USE
bool
emitIndex32
(
JSOp
op
uint32_t
index
)
;
MOZ_MUST_USE
bool
emitIndexOp
(
JSOp
op
uint32_t
index
)
;
MOZ_MUST_USE
bool
emitAtomOp
(
JSAtom
*
atom
JSOp
op
)
;
MOZ_MUST_USE
bool
emitAtomOp
(
ParseNode
*
pn
JSOp
op
)
;
MOZ_MUST_USE
bool
emitArrayLiteral
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitArray
(
ParseNode
*
pn
uint32_t
count
JSOp
op
)
;
MOZ_MUST_USE
bool
emitArrayComp
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitInternedObjectOp
(
uint32_t
index
JSOp
op
)
;
MOZ_MUST_USE
bool
emitObjectOp
(
ObjectBox
*
objbox
JSOp
op
)
;
MOZ_MUST_USE
bool
emitObjectPairOp
(
ObjectBox
*
objbox1
ObjectBox
*
objbox2
JSOp
op
)
;
MOZ_MUST_USE
bool
emitRegExp
(
uint32_t
index
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitFunction
(
ParseNode
*
pn
bool
needsProto
=
false
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitObject
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitHoistedFunctionsInList
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitPropertyList
(
ParseNode
*
pn
MutableHandlePlainObject
objp
PropListType
type
)
;
MOZ_MUST_USE
bool
emitLocalOp
(
JSOp
op
uint32_t
slot
)
;
MOZ_MUST_USE
bool
emitScopeCoordOp
(
JSOp
op
ScopeCoordinate
sc
)
;
MOZ_MUST_USE
bool
emitAliasedVarOp
(
JSOp
op
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitAliasedVarOp
(
JSOp
op
ScopeCoordinate
sc
MaybeCheckLexical
checkLexical
)
;
MOZ_MUST_USE
bool
emitUnaliasedVarOp
(
JSOp
op
uint32_t
slot
MaybeCheckLexical
checkLexical
)
;
MOZ_MUST_USE
bool
emitVarOp
(
ParseNode
*
pn
JSOp
op
)
;
MOZ_MUST_USE
bool
emitVarIncDec
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitNameOp
(
ParseNode
*
pn
bool
callContext
)
;
MOZ_MUST_USE
bool
emitNameIncDec
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
maybeEmitVarDecl
(
JSOp
prologueOp
ParseNode
*
pn
jsatomid
*
result
)
;
MOZ_MUST_USE
bool
emitVariables
(
ParseNode
*
pn
VarEmitOption
emitOption
)
;
MOZ_MUST_USE
bool
emitSingleVariable
(
ParseNode
*
pn
ParseNode
*
binding
ParseNode
*
initializer
VarEmitOption
emitOption
)
;
MOZ_MUST_USE
bool
emitNewInit
(
JSProtoKey
key
)
;
MOZ_MUST_USE
bool
emitSingletonInitialiser
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitPrepareIteratorResult
(
)
;
MOZ_MUST_USE
bool
emitFinishIteratorResult
(
bool
done
)
;
MOZ_MUST_USE
bool
iteratorResultShape
(
unsigned
*
shape
)
;
MOZ_MUST_USE
bool
emitYield
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitYieldOp
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emitYieldStar
(
ParseNode
*
iter
ParseNode
*
gen
)
;
MOZ_MUST_USE
bool
emitPropLHS
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitPropOp
(
ParseNode
*
pn
JSOp
op
)
;
MOZ_MUST_USE
bool
emitPropIncDec
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitComputedPropertyName
(
ParseNode
*
computedPropName
)
;
enum
class
EmitElemOption
{
Get
Set
Call
IncDec
CompoundAssign
}
;
MOZ_MUST_USE
bool
emitElemOperands
(
ParseNode
*
pn
EmitElemOption
opts
)
;
MOZ_MUST_USE
bool
emitElemOpBase
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emitElemOp
(
ParseNode
*
pn
JSOp
op
)
;
MOZ_MUST_USE
bool
emitElemIncDec
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitCatch
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitIf
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitWith
(
ParseNode
*
pn
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitLabeledStatement
(
const
LabeledStatement
*
pn
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitLetBlock
(
ParseNode
*
pnLet
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitLexicalScope
(
ParseNode
*
pn
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitSwitch
(
ParseNode
*
pn
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitTry
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDestructuringLHS
(
ParseNode
*
target
VarEmitOption
emitOption
)
;
MOZ_MUST_USE
bool
emitDestructuringOps
(
ParseNode
*
pattern
bool
isLet
=
false
)
;
MOZ_MUST_USE
bool
emitDestructuringOpsHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
;
MOZ_MUST_USE
bool
emitDestructuringOpsArrayHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
;
MOZ_MUST_USE
bool
emitDestructuringOpsObjectHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
;
typedef
bool
(
*
DestructuringDeclEmitter
)
(
BytecodeEmitter
*
bce
JSOp
prologueOp
ParseNode
*
pn
)
;
template
<
DestructuringDeclEmitter
EmitName
>
MOZ_MUST_USE
bool
emitDestructuringDeclsWithEmitter
(
JSOp
prologueOp
ParseNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitDestructuringDecls
(
JSOp
prologueOp
ParseNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitInitializeDestructuringDecls
(
JSOp
prologueOp
ParseNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitRequireObjectCoercible
(
)
;
MOZ_MUST_USE
bool
emitIterator
(
)
;
MOZ_MUST_USE
bool
emitIteratorNext
(
ParseNode
*
pn
bool
allowSelfHosted
=
false
)
;
MOZ_MUST_USE
bool
emitDefault
(
ParseNode
*
defaultExpr
)
;
MOZ_MUST_USE
bool
emitCallSiteObject
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitTemplateString
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitAssignment
(
ParseNode
*
lhs
JSOp
op
ParseNode
*
rhs
)
;
MOZ_MUST_USE
bool
emitReturn
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitStatement
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitStatementList
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDeleteName
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDeleteProperty
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDeleteElement
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDeleteExpression
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitTypeof
(
ParseNode
*
node
JSOp
op
)
;
MOZ_MUST_USE
bool
emitUnary
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitRightAssociative
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitLeftAssociative
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitLogical
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSequenceExpr
(
ParseNode
*
pn
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitIncOrDec
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitConditionalExpression
(
ConditionalExpression
&
conditional
)
;
MOZ_MUST_USE
bool
isRestParameter
(
ParseNode
*
pn
bool
*
result
)
;
MOZ_MUST_USE
bool
emitOptimizeSpread
(
ParseNode
*
arg0
JumpList
*
jmp
bool
*
emitted
)
;
MOZ_MUST_USE
bool
emitCallOrNew
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSelfHostedCallFunction
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSelfHostedResumeGenerator
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSelfHostedForceInterpreter
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSelfHostedAllowContentSpread
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitComprehensionFor
(
ParseNode
*
compFor
)
;
MOZ_MUST_USE
bool
emitComprehensionForIn
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitComprehensionForInOrOfVariables
(
ParseNode
*
pn
bool
*
letBlockScope
)
;
MOZ_MUST_USE
bool
emitComprehensionForOf
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDo
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitFor
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitForIn
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitForInOrOfVariables
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitCStyleFor
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitWhile
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitBreak
(
PropertyName
*
label
)
;
MOZ_MUST_USE
bool
emitContinue
(
PropertyName
*
label
)
;
MOZ_MUST_USE
bool
emitArgsBody
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitDefaultsAndDestructuring
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitLexicalInitialization
(
ParseNode
*
pn
JSOp
globalDefOp
)
;
MOZ_MUST_USE
bool
pushInitialConstants
(
JSOp
op
unsigned
n
)
;
MOZ_MUST_USE
bool
initializeBlockScopedLocalsFromStack
(
Handle
<
StaticBlockScope
*
>
blockScope
)
;
MOZ_MUST_USE
bool
emitSpread
(
bool
allowSelfHosted
=
false
)
;
MOZ_MUST_USE
bool
emitForOf
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitClass
(
ParseNode
*
pn
)
;
MOZ_MUST_USE
bool
emitSuperPropLHS
(
ParseNode
*
superBase
bool
isCall
=
false
)
;
MOZ_MUST_USE
bool
emitSuperPropOp
(
ParseNode
*
pn
JSOp
op
bool
isCall
=
false
)
;
MOZ_MUST_USE
bool
emitSuperElemOperands
(
ParseNode
*
pn
EmitElemOption
opts
=
EmitElemOption
:
:
Get
)
;
MOZ_MUST_USE
bool
emitSuperElemOp
(
ParseNode
*
pn
JSOp
op
bool
isCall
=
false
)
;
}
;
}
}
#
endif
