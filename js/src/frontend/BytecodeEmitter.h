#
ifndef
frontend_BytecodeEmitter_h
#
define
frontend_BytecodeEmitter_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
functional
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BCEParserHandle
.
h
"
#
include
"
frontend
/
BytecodeControlStructures
.
h
"
#
include
"
frontend
/
BytecodeOffset
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
frontend
/
DestructuringFlavor
.
h
"
#
include
"
frontend
/
EitherParser
.
h
"
#
include
"
frontend
/
ErrorReporter
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
frontend
/
ValueUsage
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
BuiltinObjectKind
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
CheckIsObjectKind
.
h
"
#
include
"
vm
/
FunctionPrefixKind
.
h
"
#
include
"
vm
/
GeneratorResumeKind
.
h
"
#
include
"
vm
/
Instrumentation
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
ThrowMsgKind
.
h
"
namespace
js
{
namespace
frontend
{
class
CallOrNewEmitter
;
class
ClassEmitter
;
class
ElemOpEmitter
;
class
EmitterScope
;
class
NestableControl
;
class
PropertyEmitter
;
class
PropOpEmitter
;
class
OptionalEmitter
;
class
TDZCheckCache
;
class
TryEmitter
;
class
ScriptStencil
;
enum
class
ValueIsOnStack
{
Yes
No
}
;
struct
MOZ_STACK_CLASS
BytecodeEmitter
{
SharedContext
*
const
sc
=
nullptr
;
JSContext
*
const
cx
=
nullptr
;
BytecodeEmitter
*
const
parent
=
nullptr
;
BytecodeSection
bytecodeSection_
;
public
:
BytecodeSection
&
bytecodeSection
(
)
{
return
bytecodeSection_
;
}
const
BytecodeSection
&
bytecodeSection
(
)
const
{
return
bytecodeSection_
;
}
private
:
PerScriptData
perScriptData_
;
public
:
PerScriptData
&
perScriptData
(
)
{
return
perScriptData_
;
}
const
PerScriptData
&
perScriptData
(
)
const
{
return
perScriptData_
;
}
private
:
mozilla
:
:
Maybe
<
uint32_t
>
mainOffset_
=
{
}
;
public
:
mozilla
:
:
Maybe
<
EitherParser
>
ep_
=
{
}
;
BCEParserHandle
*
parser
=
nullptr
;
CompilationInfo
&
compilationInfo
;
CompilationState
&
compilationState
;
uint32_t
maxFixedSlots
=
0
;
GCThingIndex
bodyScopeIndex
=
ScopeNote
:
:
NoScopeIndex
;
EmitterScope
*
varEmitterScope
=
nullptr
;
NestableControl
*
innermostNestableControl
=
nullptr
;
EmitterScope
*
innermostEmitterScope_
=
nullptr
;
TDZCheckCache
*
innermostTDZCheckCache
=
nullptr
;
#
ifdef
DEBUG
bool
unstableEmitterScope
=
false
;
friend
class
AutoCheckUnstableEmitterScope
;
#
endif
EmitterScope
*
innermostEmitterScope
(
)
const
{
MOZ_ASSERT
(
!
unstableEmitterScope
)
;
return
innermostEmitterScopeNoCheck
(
)
;
}
EmitterScope
*
innermostEmitterScopeNoCheck
(
)
const
{
return
innermostEmitterScope_
;
}
bool
hasTryFinally
=
false
;
enum
EmitterMode
{
Normal
SelfHosting
LazyFunction
}
;
const
EmitterMode
emitterMode
=
Normal
;
mozilla
:
:
Maybe
<
uint32_t
>
scriptStartOffset
=
{
}
;
mozilla
:
:
Maybe
<
uint32_t
>
functionBodyEndPos
=
{
}
;
uint32_t
instrumentationKinds
=
0
;
private
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
SharedContext
*
sc
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
EmitterMode
emitterMode
)
;
void
initFromBodyPosition
(
TokenPos
bodyPosition
)
;
void
reportNeedMoreArgsError
(
ParseNode
*
pn
const
char
*
errorName
const
char
*
requiredArgs
const
char
*
pluralizer
const
ListNode
*
argsList
)
;
public
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
BCEParserHandle
*
handle
SharedContext
*
sc
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
EmitterMode
emitterMode
=
Normal
)
;
BytecodeEmitter
(
BytecodeEmitter
*
parent
const
EitherParser
&
parser
SharedContext
*
sc
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
EmitterMode
emitterMode
=
Normal
)
;
template
<
typename
Unit
>
BytecodeEmitter
(
BytecodeEmitter
*
parent
Parser
<
FullParseHandler
Unit
>
*
parser
SharedContext
*
sc
CompilationInfo
&
compilationInfo
CompilationState
&
compilationState
EmitterMode
emitterMode
=
Normal
)
:
BytecodeEmitter
(
parent
EitherParser
(
parser
)
sc
compilationInfo
compilationState
emitterMode
)
{
}
MOZ_MUST_USE
bool
init
(
)
;
MOZ_MUST_USE
bool
init
(
TokenPos
bodyPosition
)
;
template
<
typename
T
>
T
*
findInnermostNestableControl
(
)
const
;
template
<
typename
T
typename
Predicate
>
T
*
findInnermostNestableControl
(
Predicate
predicate
)
const
;
NameLocation
lookupName
(
const
ParserAtom
*
name
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInScope
(
const
ParserAtom
*
name
EmitterScope
*
target
)
;
template
<
typename
T
>
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInScopeType
(
const
ParserAtom
*
name
EmitterScope
*
source
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationOfNameBoundInFunctionScope
(
const
ParserAtom
*
name
)
{
return
locationOfNameBoundInScopeType
<
FunctionScope
>
(
name
innermostEmitterScope
(
)
)
;
}
void
setVarEmitterScope
(
EmitterScope
*
emitterScope
)
{
MOZ_ASSERT
(
emitterScope
)
;
MOZ_ASSERT
(
!
varEmitterScope
)
;
varEmitterScope
=
emitterScope
;
}
AbstractScopePtr
outermostScope
(
)
const
{
return
perScriptData
(
)
.
gcThingList
(
)
.
firstScope
(
)
;
}
AbstractScopePtr
innermostScope
(
)
const
;
ScopeIndex
innermostScopeIndex
(
)
const
;
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
bool
makeAtomIndex
(
const
ParserAtom
*
atom
GCThingIndex
*
indexp
)
{
MOZ_ASSERT
(
perScriptData
(
)
.
atomIndices
(
)
)
;
AtomIndexMap
:
:
AddPtr
p
=
perScriptData
(
)
.
atomIndices
(
)
-
>
lookupForAdd
(
atom
)
;
if
(
p
)
{
*
indexp
=
GCThingIndex
(
p
-
>
value
(
)
)
;
return
true
;
}
GCThingIndex
index
;
if
(
!
perScriptData
(
)
.
gcThingList
(
)
.
append
(
atom
&
index
)
)
{
return
false
;
}
if
(
!
perScriptData
(
)
.
atomIndices
(
)
-
>
add
(
p
atom
index
.
index
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
*
indexp
=
index
;
return
true
;
}
bool
isInLoop
(
)
;
MOZ_MUST_USE
bool
checkSingletonContext
(
)
;
bool
needsImplicitThis
(
)
;
MOZ_MUST_USE
bool
emitThisEnvironmentCallee
(
)
;
MOZ_MUST_USE
bool
emitSuperBase
(
)
;
uint32_t
mainOffset
(
)
const
{
return
*
mainOffset_
;
}
bool
inPrologue
(
)
const
{
return
mainOffset_
.
isNothing
(
)
;
}
MOZ_MUST_USE
bool
switchToMain
(
)
{
MOZ_ASSERT
(
inPrologue
(
)
)
;
mainOffset_
.
emplace
(
bytecodeSection
(
)
.
code
(
)
.
length
(
)
)
;
return
emitInstrumentation
(
InstrumentationKind
:
:
Main
)
;
}
void
setFunctionBodyEndPos
(
uint32_t
pos
)
{
functionBodyEndPos
=
mozilla
:
:
Some
(
pos
)
;
}
void
setScriptStartOffsetIfUnset
(
uint32_t
pos
)
{
if
(
scriptStartOffset
.
isNothing
(
)
)
{
scriptStartOffset
=
mozilla
:
:
Some
(
pos
)
;
}
}
void
reportError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
;
void
reportError
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
maybeOffset
unsigned
errorNumber
.
.
.
)
;
bool
intoScriptStencil
(
ScriptIndex
scriptIndex
)
;
MOZ_MUST_USE
bool
checkSideEffects
(
ParseNode
*
pn
bool
*
answer
)
;
#
ifdef
DEBUG
MOZ_MUST_USE
bool
checkStrictOrSloppy
(
JSOp
op
)
;
#
endif
MOZ_MUST_USE
bool
addTryNote
(
TryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
;
bool
skipLocationSrcNotes
(
)
const
{
return
inPrologue
(
)
|
|
(
emitterMode
=
=
EmitterMode
:
:
SelfHosting
)
;
}
bool
skipBreakpointSrcNotes
(
)
const
{
return
inPrologue
(
)
|
|
(
emitterMode
=
=
EmitterMode
:
:
SelfHosting
)
;
}
MOZ_MUST_USE
bool
newSrcNote
(
SrcNoteType
type
unsigned
*
indexp
=
nullptr
)
;
MOZ_MUST_USE
bool
newSrcNote2
(
SrcNoteType
type
ptrdiff_t
operand
unsigned
*
indexp
=
nullptr
)
;
MOZ_MUST_USE
bool
newSrcNoteOperand
(
ptrdiff_t
operand
)
;
enum
EmitLineNumberNote
{
EMIT_LINENOTE
SUPPRESS_LINENOTE
}
;
MOZ_MUST_USE
bool
emitTree
(
ParseNode
*
pn
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
EmitLineNumberNote
emitLineNote
=
EMIT_LINENOTE
)
;
MOZ_MUST_USE
bool
emitOptionalTree
(
ParseNode
*
pn
OptionalEmitter
&
oe
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
)
;
MOZ_MUST_USE
bool
emitDeclarationInstantiation
(
ParseNode
*
body
)
;
MOZ_MUST_USE
bool
emitScript
(
ParseNode
*
body
)
;
MOZ_MUST_USE
bool
getNslots
(
uint32_t
*
nslots
)
;
MOZ_MUST_USE
bool
emitFunctionScript
(
FunctionNode
*
funNode
)
;
MOZ_MUST_USE
bool
markStepBreakpoint
(
)
;
MOZ_MUST_USE
bool
markSimpleBreakpoint
(
)
;
MOZ_MUST_USE
bool
updateLineNumberNotes
(
uint32_t
offset
)
;
MOZ_MUST_USE
bool
updateSourceCoordNotes
(
uint32_t
offset
)
;
JSOp
strictifySetNameOp
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emitCheck
(
JSOp
op
ptrdiff_t
delta
BytecodeOffset
*
offset
)
;
MOZ_MUST_USE
bool
emit1
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emit2
(
JSOp
op
uint8_t
op1
)
;
MOZ_MUST_USE
bool
emit3
(
JSOp
op
jsbytecode
op1
jsbytecode
op2
)
;
MOZ_MUST_USE
bool
emitDupAt
(
unsigned
slotFromTop
unsigned
count
=
1
)
;
MOZ_MUST_USE
bool
emitPopN
(
unsigned
n
)
;
MOZ_MUST_USE
bool
emitPickN
(
uint8_t
n
)
;
MOZ_MUST_USE
bool
emitUnpickN
(
uint8_t
n
)
;
MOZ_MUST_USE
bool
emitCheckIsObj
(
CheckIsObjectKind
kind
)
;
MOZ_MUST_USE
bool
emitBuiltinObject
(
BuiltinObjectKind
kind
)
;
MOZ_MUST_USE
bool
emitPushNotUndefinedOrNull
(
)
;
MOZ_MUST_USE
bool
emitUint16Operand
(
JSOp
op
uint32_t
operand
)
;
MOZ_MUST_USE
bool
emitUint32Operand
(
JSOp
op
uint32_t
operand
)
;
MOZ_MUST_USE
bool
emitN
(
JSOp
op
size_t
extra
BytecodeOffset
*
offset
=
nullptr
)
;
MOZ_MUST_USE
bool
emitDouble
(
double
dval
)
;
MOZ_MUST_USE
bool
emitNumberOp
(
double
dval
)
;
MOZ_MUST_USE
bool
emitBigIntOp
(
BigIntLiteral
*
bigint
)
;
MOZ_MUST_USE
bool
emitThisLiteral
(
ThisLiteral
*
pn
)
;
MOZ_MUST_USE
bool
emitGetFunctionThis
(
NameNode
*
thisName
)
;
MOZ_MUST_USE
bool
emitGetFunctionThis
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
offset
)
;
MOZ_MUST_USE
bool
emitGetThisForSuperBase
(
UnaryNode
*
superBase
)
;
MOZ_MUST_USE
bool
emitSetThis
(
BinaryNode
*
setThisNode
)
;
MOZ_MUST_USE
bool
emitCheckDerivedClassConstructorReturn
(
)
;
MOZ_MUST_USE
bool
emitJumpTargetOp
(
JSOp
op
BytecodeOffset
*
off
)
;
MOZ_MUST_USE
bool
emitJumpTarget
(
JumpTarget
*
target
)
;
MOZ_MUST_USE
bool
emitJumpNoFallthrough
(
JSOp
op
JumpList
*
jump
)
;
MOZ_MUST_USE
bool
emitJump
(
JSOp
op
JumpList
*
jump
)
;
void
patchJumpsToTarget
(
JumpList
jump
JumpTarget
target
)
;
MOZ_MUST_USE
bool
emitJumpTargetAndPatch
(
JumpList
jump
)
;
MOZ_MUST_USE
bool
emitCall
(
JSOp
op
uint16_t
argc
const
mozilla
:
:
Maybe
<
uint32_t
>
&
sourceCoordOffset
)
;
MOZ_MUST_USE
bool
emitCall
(
JSOp
op
uint16_t
argc
ParseNode
*
pn
=
nullptr
)
;
MOZ_MUST_USE
bool
emitCallIncDec
(
UnaryNode
*
incDec
)
;
mozilla
:
:
Maybe
<
uint32_t
>
getOffsetForLoop
(
ParseNode
*
nextpn
)
;
enum
class
GotoKind
{
Break
Continue
}
;
MOZ_MUST_USE
bool
emitGoto
(
NestableControl
*
target
JumpList
*
jumplist
GotoKind
kind
)
;
MOZ_MUST_USE
bool
emitGCIndexOp
(
JSOp
op
GCThingIndex
index
)
;
MOZ_MUST_USE
bool
emitAtomOp
(
JSOp
op
const
ParserAtom
*
atom
ShouldInstrument
shouldInstrument
=
ShouldInstrument
:
:
No
)
;
MOZ_MUST_USE
bool
emitAtomOp
(
JSOp
op
GCThingIndex
atomIndex
ShouldInstrument
shouldInstrument
=
ShouldInstrument
:
:
No
)
;
MOZ_MUST_USE
bool
emitArrayLiteral
(
ListNode
*
array
)
;
MOZ_MUST_USE
bool
emitArray
(
ParseNode
*
arrayHead
uint32_t
count
)
;
MOZ_MUST_USE
bool
emitInternedScopeOp
(
GCThingIndex
index
JSOp
op
)
;
MOZ_MUST_USE
bool
emitInternedObjectOp
(
GCThingIndex
index
JSOp
op
)
;
MOZ_MUST_USE
bool
emitObjectPairOp
(
GCThingIndex
index1
GCThingIndex
index2
JSOp
op
)
;
MOZ_MUST_USE
bool
emitRegExp
(
GCThingIndex
index
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitFunction
(
FunctionNode
*
funNode
bool
needsProto
=
false
ListNode
*
classContentsIfConstructor
=
nullptr
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitObject
(
ListNode
*
objNode
)
;
MOZ_MUST_USE
bool
emitHoistedFunctionsInList
(
ListNode
*
stmtList
)
;
void
isPropertyListObjLiteralCompatible
(
ListNode
*
obj
bool
*
withValues
bool
*
withoutValues
)
;
bool
isArrayObjLiteralCompatible
(
ParseNode
*
arrayHead
)
;
MOZ_MUST_USE
bool
emitPropertyList
(
ListNode
*
obj
PropertyEmitter
&
pe
PropListType
type
)
;
MOZ_MUST_USE
bool
emitPropertyListObjLiteral
(
ListNode
*
obj
ObjLiteralFlags
flags
)
;
MOZ_MUST_USE
bool
emitDestructuringRestExclusionSetObjLiteral
(
ListNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitObjLiteralArray
(
ParseNode
*
arrayHead
)
;
MOZ_MUST_USE
bool
isRHSObjLiteralCompatible
(
ParseNode
*
value
)
;
MOZ_MUST_USE
bool
emitObjLiteralValue
(
ObjLiteralWriter
&
writer
ParseNode
*
value
)
;
enum
class
FieldPlacement
{
Instance
Static
}
;
mozilla
:
:
Maybe
<
MemberInitializers
>
setupMemberInitializers
(
ListNode
*
classMembers
FieldPlacement
placement
)
;
MOZ_MUST_USE
bool
emitCreateFieldKeys
(
ListNode
*
obj
FieldPlacement
placement
)
;
MOZ_MUST_USE
bool
emitCreateMemberInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
FieldPlacement
placement
)
;
const
MemberInitializers
&
findMemberInitializersForCall
(
)
;
MOZ_MUST_USE
bool
emitInitializeInstanceMembers
(
)
;
MOZ_MUST_USE
bool
emitInitializeStaticFields
(
ListNode
*
classMembers
)
;
MOZ_MUST_USE
bool
emitPrivateMethodInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
)
;
MOZ_MUST_USE
bool
emitPrivateMethodInitializer
(
ClassEmitter
&
ce
ParseNode
*
prop
ParseNode
*
propName
const
ParserAtom
*
storedMethodAtom
AccessorType
accessorType
)
;
MOZ_MUST_USE
bool
emitLocalOp
(
JSOp
op
uint32_t
slot
)
;
MOZ_MUST_USE
bool
emitArgOp
(
JSOp
op
uint16_t
slot
)
;
MOZ_MUST_USE
bool
emitEnvCoordOp
(
JSOp
op
EnvironmentCoordinate
ec
)
;
MOZ_MUST_USE
bool
emitGetNameAtLocation
(
const
ParserAtom
*
name
const
NameLocation
&
loc
)
;
MOZ_MUST_USE
bool
emitGetName
(
const
ParserAtom
*
name
)
{
return
emitGetNameAtLocation
(
name
lookupName
(
name
)
)
;
}
MOZ_MUST_USE
bool
emitGetName
(
NameNode
*
name
)
;
MOZ_MUST_USE
bool
emitGetPrivateName
(
NameNode
*
name
)
;
MOZ_MUST_USE
bool
emitGetPrivateName
(
const
ParserAtom
*
name
)
;
MOZ_MUST_USE
bool
emitTDZCheckIfNeeded
(
const
ParserAtom
*
name
const
NameLocation
&
loc
ValueIsOnStack
isOnStack
)
;
MOZ_MUST_USE
bool
emitNameIncDec
(
UnaryNode
*
incDec
)
;
MOZ_MUST_USE
bool
emitDeclarationList
(
ListNode
*
declList
)
;
MOZ_MUST_USE
bool
emitSingleDeclaration
(
ListNode
*
declList
NameNode
*
decl
ParseNode
*
initializer
)
;
MOZ_MUST_USE
bool
emitAssignmentRhs
(
ParseNode
*
rhs
const
ParserAtom
*
anonFunctionName
)
;
MOZ_MUST_USE
bool
emitAssignmentRhs
(
uint8_t
offset
)
;
MOZ_MUST_USE
bool
emitPrepareIteratorResult
(
)
;
MOZ_MUST_USE
bool
emitFinishIteratorResult
(
bool
done
)
;
MOZ_MUST_USE
bool
iteratorResultShape
(
GCThingIndex
*
outShape
)
;
MOZ_MUST_USE
bool
addObjLiteralData
(
ObjLiteralWriter
&
writer
GCThingIndex
*
outIndex
)
;
MOZ_MUST_USE
bool
emitGetDotGeneratorInInnermostScope
(
)
{
return
emitGetDotGeneratorInScope
(
*
innermostEmitterScope
(
)
)
;
}
MOZ_MUST_USE
bool
emitGetDotGeneratorInScope
(
EmitterScope
&
currentScope
)
;
MOZ_MUST_USE
bool
allocateResumeIndex
(
BytecodeOffset
offset
uint32_t
*
resumeIndex
)
;
MOZ_MUST_USE
bool
allocateResumeIndexRange
(
mozilla
:
:
Span
<
BytecodeOffset
>
offsets
uint32_t
*
firstResumeIndex
)
;
MOZ_MUST_USE
bool
emitInitialYield
(
UnaryNode
*
yieldNode
)
;
MOZ_MUST_USE
bool
emitYield
(
UnaryNode
*
yieldNode
)
;
MOZ_MUST_USE
bool
emitYieldOp
(
JSOp
op
)
;
MOZ_MUST_USE
bool
emitYieldStar
(
ParseNode
*
iter
)
;
MOZ_MUST_USE
bool
emitAwaitInInnermostScope
(
)
{
return
emitAwaitInScope
(
*
innermostEmitterScope
(
)
)
;
}
MOZ_MUST_USE
bool
emitAwaitInInnermostScope
(
UnaryNode
*
awaitNode
)
;
MOZ_MUST_USE
bool
emitAwaitInScope
(
EmitterScope
&
currentScope
)
;
MOZ_MUST_USE
bool
emitPushResumeKind
(
GeneratorResumeKind
kind
)
;
MOZ_MUST_USE
bool
emitPropLHS
(
PropertyAccess
*
prop
)
;
MOZ_MUST_USE
bool
emitPropIncDec
(
UnaryNode
*
incDec
)
;
MOZ_MUST_USE
bool
emitComputedPropertyName
(
UnaryNode
*
computedPropName
)
;
enum
class
EmitElemOption
{
Get
Call
IncDec
CompoundAssign
Ref
}
;
MOZ_MUST_USE
bool
emitElemOperands
(
PropertyByValue
*
elem
EmitElemOption
opts
)
;
MOZ_MUST_USE
bool
emitElemObjAndKey
(
PropertyByValue
*
elem
bool
isSuper
ElemOpEmitter
&
eoe
)
;
MOZ_MUST_USE
bool
emitElemOpBase
(
JSOp
op
ShouldInstrument
shouldInstrument
=
ShouldInstrument
:
:
No
)
;
MOZ_MUST_USE
bool
emitElemOp
(
PropertyByValue
*
elem
JSOp
op
)
;
MOZ_MUST_USE
bool
emitElemIncDec
(
UnaryNode
*
incDec
)
;
MOZ_MUST_USE
bool
emitCatch
(
BinaryNode
*
catchClause
)
;
MOZ_MUST_USE
bool
emitIf
(
TernaryNode
*
ifNode
)
;
MOZ_MUST_USE
bool
emitWith
(
BinaryNode
*
withNode
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitLabeledStatement
(
const
LabeledStatement
*
labeledStmt
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitLexicalScope
(
LexicalScopeNode
*
lexicalScope
)
;
MOZ_MUST_USE
bool
emitLexicalScopeBody
(
ParseNode
*
body
EmitLineNumberNote
emitLineNote
=
EMIT_LINENOTE
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitSwitch
(
SwitchStatement
*
switchStmt
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitTry
(
TryNode
*
tryNode
)
;
MOZ_MUST_USE
bool
emitGoSub
(
JumpList
*
jump
)
;
MOZ_MUST_USE
bool
emitDestructuringLHSRef
(
ParseNode
*
target
size_t
*
emitted
)
;
MOZ_MUST_USE
bool
emitSetOrInitializeDestructuring
(
ParseNode
*
target
DestructuringFlavor
flav
)
;
MOZ_MUST_USE
bool
emitDestructuringObjRestExclusionSet
(
ListNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitDestructuringOps
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
MOZ_MUST_USE
bool
emitDestructuringOpsArray
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
MOZ_MUST_USE
bool
emitDestructuringOpsObject
(
ListNode
*
pattern
DestructuringFlavor
flav
)
;
enum
class
CopyOption
{
Filtered
Unfiltered
}
;
MOZ_MUST_USE
bool
emitCopyDataProperties
(
CopyOption
option
)
;
MOZ_MUST_USE
bool
emitIterator
(
)
;
MOZ_MUST_USE
bool
emitAsyncIterator
(
)
;
MOZ_MUST_USE
bool
emitIteratorNext
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
callSourceCoordOffset
IteratorKind
kind
=
IteratorKind
:
:
Sync
bool
allowSelfHosted
=
false
)
;
MOZ_MUST_USE
bool
emitIteratorCloseInScope
(
EmitterScope
&
currentScope
IteratorKind
iterKind
=
IteratorKind
:
:
Sync
CompletionKind
completionKind
=
CompletionKind
:
:
Normal
bool
allowSelfHosted
=
false
)
;
MOZ_MUST_USE
bool
emitIteratorCloseInInnermostScope
(
IteratorKind
iterKind
=
IteratorKind
:
:
Sync
CompletionKind
completionKind
=
CompletionKind
:
:
Normal
bool
allowSelfHosted
=
false
)
{
return
emitIteratorCloseInScope
(
*
innermostEmitterScope
(
)
iterKind
completionKind
allowSelfHosted
)
;
}
template
<
typename
InnerEmitter
>
MOZ_MUST_USE
bool
wrapWithDestructuringTryNote
(
int32_t
iterDepth
InnerEmitter
emitter
)
;
MOZ_MUST_USE
bool
defineHoistedTopLevelFunctions
(
ParseNode
*
body
)
;
MOZ_MUST_USE
bool
emitDefault
(
ParseNode
*
defaultExpr
ParseNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitAnonymousFunctionWithName
(
ParseNode
*
node
const
ParserAtom
*
name
)
;
MOZ_MUST_USE
bool
emitAnonymousFunctionWithComputedName
(
ParseNode
*
node
FunctionPrefixKind
prefixKind
)
;
MOZ_MUST_USE
bool
setFunName
(
FunctionBox
*
fun
const
ParserAtom
*
name
)
;
MOZ_MUST_USE
bool
emitInitializer
(
ParseNode
*
initializer
ParseNode
*
pattern
)
;
MOZ_MUST_USE
bool
emitCallSiteObjectArray
(
ListNode
*
cookedOrRaw
GCThingIndex
*
outArrayIndex
)
;
MOZ_MUST_USE
bool
emitCallSiteObject
(
CallSiteNode
*
callSiteObj
)
;
MOZ_MUST_USE
bool
emitTemplateString
(
ListNode
*
templateString
)
;
MOZ_MUST_USE
bool
emitAssignmentOrInit
(
ParseNodeKind
kind
ParseNode
*
lhs
ParseNode
*
rhs
)
;
MOZ_MUST_USE
bool
emitShortCircuitAssignment
(
AssignmentNode
*
node
)
;
MOZ_MUST_USE
bool
emitReturn
(
UnaryNode
*
returnNode
)
;
MOZ_MUST_USE
bool
emitExpressionStatement
(
UnaryNode
*
exprStmt
)
;
MOZ_MUST_USE
bool
emitStatementList
(
ListNode
*
stmtList
)
;
MOZ_MUST_USE
bool
emitDeleteName
(
UnaryNode
*
deleteNode
)
;
MOZ_MUST_USE
bool
emitDeleteProperty
(
UnaryNode
*
deleteNode
)
;
MOZ_MUST_USE
bool
emitDeleteElement
(
UnaryNode
*
deleteNode
)
;
MOZ_MUST_USE
bool
emitDeleteExpression
(
UnaryNode
*
deleteNode
)
;
MOZ_MUST_USE
bool
emitOptionalChain
(
UnaryNode
*
expr
ValueUsage
valueUsage
)
;
MOZ_MUST_USE
bool
emitCalleeAndThisForOptionalChain
(
UnaryNode
*
expr
CallNode
*
callNode
CallOrNewEmitter
&
cone
)
;
MOZ_MUST_USE
bool
emitDeleteOptionalChain
(
UnaryNode
*
deleteNode
)
;
MOZ_MUST_USE
bool
emitOptionalDotExpression
(
PropertyAccessBase
*
expr
PropOpEmitter
&
poe
bool
isSuper
OptionalEmitter
&
oe
)
;
MOZ_MUST_USE
bool
emitOptionalElemExpression
(
PropertyByValueBase
*
elem
ElemOpEmitter
&
poe
bool
isSuper
OptionalEmitter
&
oe
)
;
MOZ_MUST_USE
bool
emitOptionalCall
(
CallNode
*
callNode
OptionalEmitter
&
oe
ValueUsage
valueUsage
)
;
MOZ_MUST_USE
bool
emitDeletePropertyInOptChain
(
PropertyAccessBase
*
propExpr
OptionalEmitter
&
oe
)
;
MOZ_MUST_USE
bool
emitDeleteElementInOptChain
(
PropertyByValueBase
*
elemExpr
OptionalEmitter
&
oe
)
;
MOZ_MUST_USE
bool
emitTypeof
(
UnaryNode
*
typeofNode
JSOp
op
)
;
MOZ_MUST_USE
bool
emitUnary
(
UnaryNode
*
unaryNode
)
;
MOZ_MUST_USE
bool
emitRightAssociative
(
ListNode
*
node
)
;
MOZ_MUST_USE
bool
emitLeftAssociative
(
ListNode
*
node
)
;
MOZ_MUST_USE
bool
emitShortCircuit
(
ListNode
*
node
)
;
MOZ_MUST_USE
bool
emitSequenceExpr
(
ListNode
*
node
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
)
;
MOZ_NEVER_INLINE
MOZ_MUST_USE
bool
emitIncOrDec
(
UnaryNode
*
incDec
)
;
MOZ_MUST_USE
bool
emitConditionalExpression
(
ConditionalExpression
&
conditional
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
)
;
bool
isRestParameter
(
ParseNode
*
expr
)
;
MOZ_MUST_USE
ParseNode
*
getCoordNode
(
ParseNode
*
callNode
ParseNode
*
calleeNode
JSOp
op
ListNode
*
argsList
)
;
MOZ_MUST_USE
bool
emitArguments
(
ListNode
*
argsList
bool
isCall
bool
isSpread
CallOrNewEmitter
&
cone
)
;
MOZ_MUST_USE
bool
emitCallOrNew
(
CallNode
*
callNode
ValueUsage
valueUsage
=
ValueUsage
:
:
WantValue
)
;
MOZ_MUST_USE
bool
emitSelfHostedCallFunction
(
CallNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedResumeGenerator
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedForceInterpreter
(
)
;
MOZ_MUST_USE
bool
emitSelfHostedAllowContentIter
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedDefineDataProperty
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedGetPropertySuper
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedHasOwn
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedToNumeric
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedToString
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedGetBuiltinConstructor
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedGetBuiltinPrototype
(
BinaryNode
*
callNode
)
;
#
ifdef
DEBUG
MOZ_MUST_USE
bool
checkSelfHostedUnsafeGetReservedSlot
(
BinaryNode
*
callNode
)
;
MOZ_MUST_USE
bool
checkSelfHostedUnsafeSetReservedSlot
(
BinaryNode
*
callNode
)
;
#
endif
MOZ_MUST_USE
bool
emitDo
(
BinaryNode
*
doNode
)
;
MOZ_MUST_USE
bool
emitWhile
(
BinaryNode
*
whileNode
)
;
MOZ_MUST_USE
bool
emitFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
=
nullptr
)
;
MOZ_MUST_USE
bool
emitCStyleFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
MOZ_MUST_USE
bool
emitForIn
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
MOZ_MUST_USE
bool
emitForOf
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
;
MOZ_MUST_USE
bool
emitInitializeForInOrOfTarget
(
TernaryNode
*
forHead
)
;
MOZ_MUST_USE
bool
emitBreak
(
const
ParserName
*
label
)
;
MOZ_MUST_USE
bool
emitContinue
(
const
ParserName
*
label
)
;
MOZ_MUST_USE
bool
emitFunctionFormalParameters
(
ListNode
*
paramsBody
)
;
MOZ_MUST_USE
bool
emitInitializeFunctionSpecialNames
(
)
;
MOZ_MUST_USE
bool
emitLexicalInitialization
(
NameNode
*
name
)
;
MOZ_MUST_USE
bool
emitLexicalInitialization
(
const
ParserAtom
*
name
)
;
MOZ_MUST_USE
bool
emitSpread
(
bool
allowSelfHosted
=
false
)
;
enum
class
ClassNameKind
{
BindingName
InferredName
ComputedName
}
;
MOZ_MUST_USE
bool
emitClass
(
ClassNode
*
classNode
ClassNameKind
nameKind
=
ClassNameKind
:
:
BindingName
const
ParserAtom
*
nameForAnonymousClass
=
nullptr
)
;
MOZ_MUST_USE
bool
emitSuperElemOperands
(
PropertyByValue
*
elem
EmitElemOption
opts
=
EmitElemOption
:
:
Get
)
;
MOZ_MUST_USE
bool
emitSuperGetElem
(
PropertyByValue
*
elem
bool
isCall
=
false
)
;
MOZ_MUST_USE
bool
emitCalleeAndThis
(
ParseNode
*
callee
ParseNode
*
call
CallOrNewEmitter
&
cone
)
;
MOZ_MUST_USE
bool
emitOptionalCalleeAndThis
(
ParseNode
*
callee
CallNode
*
call
CallOrNewEmitter
&
cone
OptionalEmitter
&
oe
)
;
MOZ_MUST_USE
bool
emitPipeline
(
ListNode
*
node
)
;
MOZ_MUST_USE
bool
emitExportDefault
(
BinaryNode
*
exportNode
)
;
MOZ_MUST_USE
bool
emitReturnRval
(
)
{
return
emitInstrumentation
(
InstrumentationKind
:
:
Exit
)
&
&
emit1
(
JSOp
:
:
RetRval
)
;
}
MOZ_MUST_USE
bool
emitCheckPrivateField
(
ThrowCondition
throwCondition
ThrowMsgKind
msgKind
)
{
return
emit3
(
JSOp
:
:
CheckPrivateField
uint8_t
(
throwCondition
)
uint8_t
(
msgKind
)
)
;
}
template
<
class
ClassMemberType
>
MOZ_MUST_USE
bool
emitNewPrivateNames
(
ListNode
*
classMembers
)
;
MOZ_MUST_USE
bool
emitInstrumentation
(
InstrumentationKind
kind
uint32_t
npopped
=
0
)
{
return
MOZ_LIKELY
(
!
instrumentationKinds
)
|
|
emitInstrumentationSlow
(
kind
std
:
:
function
<
bool
(
uint32_t
)
>
(
)
)
;
}
MOZ_MUST_USE
bool
emitInstrumentationForOpcode
(
JSOp
op
GCThingIndex
atomIndex
)
{
return
MOZ_LIKELY
(
!
instrumentationKinds
)
|
|
emitInstrumentationForOpcodeSlow
(
op
atomIndex
)
;
}
MOZ_MUST_USE
js
:
:
UniquePtr
<
ImmutableScriptData
>
createImmutableScriptData
(
JSContext
*
cx
)
;
private
:
MOZ_MUST_USE
bool
emitInstrumentationSlow
(
InstrumentationKind
kind
const
std
:
:
function
<
bool
(
uint32_t
)
>
&
pushOperandsCallback
)
;
MOZ_MUST_USE
bool
emitInstrumentationForOpcodeSlow
(
JSOp
op
GCThingIndex
atomIndex
)
;
MOZ_MUST_USE
bool
allowSelfHostedIter
(
ParseNode
*
parseNode
)
;
MOZ_MUST_USE
bool
emitSelfHostedGetBuiltinConstructorOrPrototype
(
BinaryNode
*
callNode
bool
isConstructor
)
;
}
;
class
MOZ_RAII
AutoCheckUnstableEmitterScope
{
#
ifdef
DEBUG
bool
prev_
;
BytecodeEmitter
*
bce_
;
#
endif
public
:
AutoCheckUnstableEmitterScope
(
)
=
delete
;
explicit
AutoCheckUnstableEmitterScope
(
BytecodeEmitter
*
bce
)
#
ifdef
DEBUG
:
bce_
(
bce
)
#
endif
{
#
ifdef
DEBUG
prev_
=
bce_
-
>
unstableEmitterScope
;
bce_
-
>
unstableEmitterScope
=
true
;
#
endif
}
~
AutoCheckUnstableEmitterScope
(
)
{
#
ifdef
DEBUG
bce_
-
>
unstableEmitterScope
=
prev_
;
#
endif
}
}
;
}
}
#
endif
