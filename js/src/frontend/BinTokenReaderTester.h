#
ifndef
frontend_BinTokenReaderTester_h
#
define
frontend_BinTokenReaderTester_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
BinToken
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
if
!
defined
(
NIGHTLY_BUILD
)
#
error
"
BinTokenReaderTester
.
*
is
designed
to
help
test
implementations
of
successive
versions
of
JS
BinaryAST
.
It
is
available
only
on
Nightly
.
"
#
endif
namespace
js
{
namespace
frontend
{
using
namespace
mozilla
;
using
namespace
JS
;
class
MOZ_STACK_CLASS
BinTokenReaderTester
{
public
:
using
BinFields
=
Vector
<
BinField
8
>
;
using
Chars
=
Vector
<
uint8_t
32
>
;
class
AutoList
;
class
AutoTuple
;
class
AutoTaggedTuple
;
public
:
BinTokenReaderTester
(
JSContext
*
cx
const
uint8_t
*
start
const
size_t
length
)
;
BinTokenReaderTester
(
JSContext
*
cx
const
Vector
<
uint8_t
>
&
chars
)
;
MOZ_MUST_USE
bool
readMaybeBool
(
Maybe
<
bool
>
&
out
)
;
MOZ_MUST_USE
bool
readBool
(
bool
&
out
)
;
MOZ_MUST_USE
bool
readMaybeDouble
(
Maybe
<
double
>
&
out
)
;
MOZ_MUST_USE
bool
readDouble
(
double
&
out
)
;
MOZ_MUST_USE
bool
readMaybeChars
(
Maybe
<
Chars
>
&
out
)
;
MOZ_MUST_USE
bool
readChars
(
Chars
&
out
)
;
MOZ_MUST_USE
bool
enterList
(
uint32_t
&
length
AutoList
&
guard
)
;
MOZ_MUST_USE
bool
enterTaggedTuple
(
BinKind
&
tag
BinTokenReaderTester
:
:
BinFields
&
fields
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
bool
enterUntaggedTuple
(
AutoTuple
&
guard
)
;
TokenPos
pos
(
)
;
TokenPos
pos
(
size_t
startOffset
)
;
size_t
offset
(
)
const
;
MOZ_MUST_USE
bool
raiseError
(
const
char
*
description
)
;
void
poison
(
)
;
private
:
MOZ_MUST_USE
bool
readByte
(
uint8_t
*
byte
)
;
MOZ_MUST_USE
bool
readBuf
(
uint8_t
*
bytes
uint32_t
len
)
;
MOZ_MUST_USE
bool
readInternalUint32
(
uint32_t
*
)
;
template
<
size_t
N
>
MOZ_MUST_USE
bool
readConst
(
const
char
(
&
value
)
[
N
]
)
;
template
<
size_t
N
>
MOZ_MUST_USE
bool
matchConst
(
const
char
(
&
value
)
[
N
]
)
;
void
updateLatestKnownGood
(
)
;
private
:
JSContext
*
cx_
;
bool
poisoned_
;
const
uint8_t
*
start_
;
const
uint8_t
*
current_
;
const
uint8_t
*
stop_
;
size_t
latestKnownGoodPos_
;
BinTokenReaderTester
(
const
BinTokenReaderTester
&
)
=
delete
;
BinTokenReaderTester
(
BinTokenReaderTester
&
&
)
=
delete
;
BinTokenReaderTester
&
operator
=
(
BinTokenReaderTester
&
)
=
delete
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinTokenReaderTester
&
reader
)
;
~
AutoBase
(
)
;
MOZ_MUST_USE
bool
checkPosition
(
const
uint8_t
*
expectedPosition
)
;
friend
BinTokenReaderTester
;
void
init
(
)
;
bool
initialized_
;
BinTokenReaderTester
&
reader_
;
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinTokenReaderTester
&
reader
)
;
MOZ_MUST_USE
bool
done
(
)
;
protected
:
friend
BinTokenReaderTester
;
void
init
(
const
uint8_t
*
expectedEnd
)
;
private
:
const
uint8_t
*
expectedEnd_
;
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinTokenReaderTester
&
reader
)
;
MOZ_MUST_USE
bool
done
(
)
;
}
;
class
MOZ_STACK_CLASS
AutoTuple
:
public
AutoBase
{
public
:
explicit
AutoTuple
(
BinTokenReaderTester
&
reader
)
;
MOZ_MUST_USE
bool
done
(
)
;
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
length
(
)
+
1
!
=
N
)
return
false
;
if
(
!
std
:
:
equal
(
left
.
begin
(
)
left
.
end
(
)
right
)
)
return
false
;
return
true
;
}
}
;
}
}
#
endif
