#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
asmjs
/
AsmJSLink
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
FoldConstants
.
h
"
#
include
"
frontend
/
NameFunctions
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
frontend
/
Parser
-
inl
.
h
"
#
include
"
vm
/
ScopeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
class
MOZ_STACK_CLASS
AutoCompilationTraceLogger
{
public
:
AutoCompilationTraceLogger
(
ExclusiveContext
*
cx
const
TraceLoggerTextId
id
)
;
private
:
TraceLoggerThread
*
logger
;
TraceLoggerEvent
event
;
AutoTraceLog
scriptLogger
;
AutoTraceLog
typeLogger
;
}
;
class
MOZ_STACK_CLASS
BytecodeCompiler
{
public
:
BytecodeCompiler
(
ExclusiveContext
*
cx
LifoAlloc
*
alloc
const
ReadOnlyCompileOptions
&
options
SourceBufferHolder
&
sourceBuffer
Handle
<
ScopeObject
*
>
enclosingStaticScope
TraceLoggerTextId
logId
)
;
void
maybeSetSourceCompressor
(
SourceCompressionTask
*
sourceCompressor
)
;
void
setSourceArgumentsNotIncluded
(
)
;
JSScript
*
compileScript
(
HandleObject
scopeChain
HandleScript
evalCaller
)
;
ModuleObject
*
compileModule
(
)
;
bool
compileFunctionBody
(
MutableHandleFunction
fun
Handle
<
PropertyNameVector
>
formals
GeneratorKind
generatorKind
)
;
ScriptSourceObject
*
sourceObjectPtr
(
)
const
;
private
:
bool
checkLength
(
)
;
bool
createScriptSource
(
)
;
bool
maybeCompressSource
(
)
;
bool
canLazilyParse
(
)
;
bool
createParser
(
)
;
bool
createSourceAndParser
(
)
;
bool
createScript
(
bool
savedCallerFun
=
false
)
;
bool
createEmitter
(
SharedContext
*
sharedContext
HandleScript
evalCaller
=
nullptr
bool
insideNonGlobalEval
=
false
)
;
bool
isEvalCompilationUnit
(
)
;
bool
isNonGlobalEvalCompilationUnit
(
)
;
bool
isNonSyntacticCompilationUnit
(
)
;
bool
createParseContext
(
Maybe
<
ParseContext
<
FullParseHandler
>
>
&
parseContext
SharedContext
&
globalsc
uint32_t
blockScopeDepth
=
0
)
;
bool
saveCallerFun
(
HandleScript
evalCaller
ParseContext
<
FullParseHandler
>
&
parseContext
)
;
bool
handleStatementParseFailure
(
HandleObject
scopeChain
HandleScript
evalCaller
Maybe
<
ParseContext
<
FullParseHandler
>
>
&
parseContext
SharedContext
&
globalsc
)
;
bool
handleParseFailure
(
const
Directives
&
newDirectives
)
;
bool
prepareAndEmitTree
(
ParseNode
*
*
pn
ParseContext
<
FullParseHandler
>
&
pc
)
;
bool
checkArgumentsWithinEval
(
JSContext
*
cx
HandleFunction
fun
)
;
bool
maybeCheckEvalFreeVariables
(
HandleScript
evalCaller
HandleObject
scopeChain
ParseContext
<
FullParseHandler
>
&
pc
)
;
bool
maybeSetDisplayURL
(
TokenStream
&
tokenStream
)
;
bool
maybeSetSourceMap
(
TokenStream
&
tokenStream
)
;
bool
maybeSetSourceMapFromOptions
(
)
;
bool
emitFinalReturn
(
)
;
bool
initGlobalOrEvalBindings
(
ParseContext
<
FullParseHandler
>
&
pc
Handle
<
TraceableVector
<
Binding
>
>
vars
Handle
<
TraceableVector
<
Binding
>
>
lexicals
)
;
bool
maybeCompleteCompressSource
(
)
;
AutoCompilationTraceLogger
traceLogger
;
AutoKeepAtoms
keepAtoms
;
ExclusiveContext
*
cx
;
LifoAlloc
*
alloc
;
const
ReadOnlyCompileOptions
&
options
;
SourceBufferHolder
&
sourceBuffer
;
Rooted
<
ScopeObject
*
>
enclosingStaticScope
;
bool
sourceArgumentsNotIncluded
;
RootedScriptSource
sourceObject
;
ScriptSource
*
scriptSource
;
Maybe
<
SourceCompressionTask
>
maybeSourceCompressor
;
SourceCompressionTask
*
sourceCompressor
;
Maybe
<
Parser
<
SyntaxParseHandler
>
>
syntaxParser
;
Maybe
<
Parser
<
FullParseHandler
>
>
parser
;
Directives
directives
;
TokenStream
:
:
Position
startPosition
;
RootedScript
script
;
Maybe
<
BytecodeEmitter
>
emitter
;
}
;
AutoCompilationTraceLogger
:
:
AutoCompilationTraceLogger
(
ExclusiveContext
*
cx
const
TraceLoggerTextId
id
)
:
logger
(
cx
-
>
isJSContext
(
)
?
TraceLoggerForMainThread
(
cx
-
>
asJSContext
(
)
-
>
runtime
(
)
)
:
TraceLoggerForCurrentThread
(
)
)
event
(
logger
TraceLogger_AnnotateScripts
)
scriptLogger
(
logger
event
)
typeLogger
(
logger
id
)
{
}
BytecodeCompiler
:
:
BytecodeCompiler
(
ExclusiveContext
*
cx
LifoAlloc
*
alloc
const
ReadOnlyCompileOptions
&
options
SourceBufferHolder
&
sourceBuffer
Handle
<
ScopeObject
*
>
enclosingStaticScope
TraceLoggerTextId
logId
)
:
traceLogger
(
cx
logId
)
keepAtoms
(
cx
-
>
perThreadData
)
cx
(
cx
)
alloc
(
alloc
)
options
(
options
)
sourceBuffer
(
sourceBuffer
)
enclosingStaticScope
(
cx
enclosingStaticScope
)
sourceArgumentsNotIncluded
(
false
)
sourceObject
(
cx
)
scriptSource
(
nullptr
)
sourceCompressor
(
nullptr
)
directives
(
options
.
strictOption
)
startPosition
(
keepAtoms
)
script
(
cx
)
{
}
void
BytecodeCompiler
:
:
maybeSetSourceCompressor
(
SourceCompressionTask
*
sourceCompressor
)
{
this
-
>
sourceCompressor
=
sourceCompressor
;
}
void
BytecodeCompiler
:
:
setSourceArgumentsNotIncluded
(
)
{
sourceArgumentsNotIncluded
=
true
;
}
bool
BytecodeCompiler
:
:
checkLength
(
)
{
if
(
sourceBuffer
.
length
(
)
>
UINT32_MAX
)
{
if
(
cx
-
>
isJSContext
(
)
)
JS_ReportErrorNumber
(
cx
-
>
asJSContext
(
)
GetErrorMessage
nullptr
JSMSG_SOURCE_TOO_LONG
)
;
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
createScriptSource
(
)
{
if
(
!
checkLength
(
)
)
return
false
;
sourceObject
=
CreateScriptSourceObject
(
cx
options
)
;
if
(
!
sourceObject
)
return
false
;
scriptSource
=
sourceObject
-
>
source
(
)
;
return
true
;
}
bool
BytecodeCompiler
:
:
maybeCompressSource
(
)
{
if
(
!
sourceCompressor
)
{
maybeSourceCompressor
.
emplace
(
cx
)
;
sourceCompressor
=
maybeSourceCompressor
.
ptr
(
)
;
}
if
(
!
cx
-
>
compartment
(
)
-
>
options
(
)
.
discardSource
(
)
)
{
if
(
options
.
sourceIsLazy
)
{
scriptSource
-
>
setSourceRetrievable
(
)
;
}
else
if
(
!
scriptSource
-
>
setSourceCopy
(
cx
sourceBuffer
sourceArgumentsNotIncluded
sourceCompressor
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeCompiler
:
:
canLazilyParse
(
)
{
return
options
.
canLazilyParse
&
&
!
HasNonSyntacticStaticScopeChain
(
enclosingStaticScope
)
&
&
!
cx
-
>
compartment
(
)
-
>
options
(
)
.
disableLazyParsing
(
)
&
&
!
cx
-
>
compartment
(
)
-
>
options
(
)
.
discardSource
(
)
&
&
!
options
.
sourceIsLazy
&
&
!
cx
-
>
lcovEnabled
(
)
;
}
bool
BytecodeCompiler
:
:
createParser
(
)
{
if
(
canLazilyParse
(
)
)
{
syntaxParser
.
emplace
(
cx
alloc
options
sourceBuffer
.
get
(
)
sourceBuffer
.
length
(
)
false
(
Parser
<
SyntaxParseHandler
>
*
)
nullptr
(
LazyScript
*
)
nullptr
)
;
if
(
!
syntaxParser
-
>
checkOptions
(
)
)
return
false
;
}
parser
.
emplace
(
cx
alloc
options
sourceBuffer
.
get
(
)
sourceBuffer
.
length
(
)
true
syntaxParser
.
ptrOr
(
nullptr
)
nullptr
)
;
parser
-
>
sct
=
sourceCompressor
;
parser
-
>
ss
=
scriptSource
;
if
(
!
parser
-
>
checkOptions
(
)
)
return
false
;
parser
-
>
tokenStream
.
tell
(
&
startPosition
)
;
return
true
;
}
bool
BytecodeCompiler
:
:
createSourceAndParser
(
)
{
return
createScriptSource
(
)
&
&
maybeCompressSource
(
)
&
&
createParser
(
)
;
}
bool
BytecodeCompiler
:
:
createScript
(
bool
savedCallerFun
)
{
script
=
JSScript
:
:
Create
(
cx
enclosingStaticScope
savedCallerFun
options
sourceObject
0
sourceBuffer
.
length
(
)
)
;
return
script
!
=
nullptr
;
}
bool
BytecodeCompiler
:
:
createEmitter
(
SharedContext
*
sharedContext
HandleScript
evalCaller
bool
insideNonGlobalEval
)
{
BytecodeEmitter
:
:
EmitterMode
emitterMode
=
options
.
selfHostingMode
?
BytecodeEmitter
:
:
SelfHosting
:
BytecodeEmitter
:
:
Normal
;
emitter
.
emplace
(
nullptr
parser
.
ptr
(
)
sharedContext
script
nullptr
options
.
forEval
evalCaller
insideNonGlobalEval
options
.
lineno
emitterMode
)
;
return
emitter
-
>
init
(
)
;
}
bool
BytecodeCompiler
:
:
isEvalCompilationUnit
(
)
{
return
enclosingStaticScope
-
>
is
<
StaticEvalObject
>
(
)
;
}
bool
BytecodeCompiler
:
:
isNonGlobalEvalCompilationUnit
(
)
{
if
(
!
isEvalCompilationUnit
(
)
)
return
false
;
StaticEvalObject
&
eval
=
enclosingStaticScope
-
>
as
<
StaticEvalObject
>
(
)
;
JSObject
*
enclosing
=
eval
.
enclosingScopeForStaticScopeIter
(
)
;
return
!
IsStaticGlobalLexicalScope
(
enclosing
)
;
}
bool
BytecodeCompiler
:
:
isNonSyntacticCompilationUnit
(
)
{
return
enclosingStaticScope
-
>
is
<
StaticNonSyntacticScopeObjects
>
(
)
;
}
bool
BytecodeCompiler
:
:
createParseContext
(
Maybe
<
ParseContext
<
FullParseHandler
>
>
&
parseContext
SharedContext
&
globalsc
uint32_t
blockScopeDepth
)
{
parseContext
.
emplace
(
parser
.
ptr
(
)
(
GenericParseContext
*
)
nullptr
(
ParseNode
*
)
nullptr
&
globalsc
(
Directives
*
)
nullptr
blockScopeDepth
)
;
return
parseContext
-
>
init
(
*
parser
)
;
}
bool
BytecodeCompiler
:
:
saveCallerFun
(
HandleScript
evalCaller
ParseContext
<
FullParseHandler
>
&
parseContext
)
{
RootedFunction
fun
(
cx
evalCaller
-
>
functionOrCallerFunction
(
)
)
;
MOZ_ASSERT_IF
(
fun
-
>
strict
(
)
options
.
strictOption
)
;
Directives
directives
(
options
.
strictOption
)
;
ObjectBox
*
funbox
=
parser
-
>
newFunctionBox
(
nullptr
fun
&
parseContext
directives
fun
-
>
generatorKind
(
)
fun
-
>
asyncKind
(
)
)
;
if
(
!
funbox
)
return
false
;
emitter
-
>
objectList
.
add
(
funbox
)
;
return
true
;
}
bool
BytecodeCompiler
:
:
handleStatementParseFailure
(
HandleObject
scopeChain
HandleScript
evalCaller
Maybe
<
ParseContext
<
FullParseHandler
>
>
&
parseContext
SharedContext
&
globalsc
)
{
if
(
!
parser
-
>
hadAbortedSyntaxParse
(
)
)
return
false
;
parser
-
>
clearAbortedSyntaxParse
(
)
;
parser
-
>
tokenStream
.
seek
(
startPosition
)
;
parser
-
>
blockScopes
.
clear
(
)
;
if
(
!
maybeCheckEvalFreeVariables
(
evalCaller
scopeChain
parseContext
.
ref
(
)
)
)
return
false
;
parseContext
.
reset
(
)
;
if
(
!
createParseContext
(
parseContext
globalsc
script
-
>
bindings
.
numBlockScoped
(
)
)
)
return
false
;
MOZ_ASSERT
(
parser
-
>
pc
=
=
parseContext
.
ptr
(
)
)
;
return
true
;
}
bool
BytecodeCompiler
:
:
handleParseFailure
(
const
Directives
&
newDirectives
)
{
if
(
parser
-
>
hadAbortedSyntaxParse
(
)
)
{
parser
-
>
clearAbortedSyntaxParse
(
)
;
}
else
if
(
parser
-
>
tokenStream
.
hadError
(
)
|
|
directives
=
=
newDirectives
)
{
return
false
;
}
parser
-
>
tokenStream
.
seek
(
startPosition
)
;
MOZ_ASSERT_IF
(
directives
.
strict
(
)
newDirectives
.
strict
(
)
)
;
MOZ_ASSERT_IF
(
directives
.
asmJS
(
)
newDirectives
.
asmJS
(
)
)
;
directives
=
newDirectives
;
return
true
;
}
bool
BytecodeCompiler
:
:
prepareAndEmitTree
(
ParseNode
*
*
ppn
ParseContext
<
FullParseHandler
>
&
pc
)
{
script
-
>
bindings
.
updateNumBlockScoped
(
pc
.
blockScopeDepth
)
;
if
(
!
FoldConstants
(
cx
ppn
parser
.
ptr
(
)
)
|
|
!
NameFunctions
(
cx
*
ppn
)
|
|
!
emitter
-
>
updateLocalsToFrameSlots
(
)
|
|
!
emitter
-
>
emitTree
(
*
ppn
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
maybeSetDisplayURL
(
TokenStream
&
tokenStream
)
{
if
(
tokenStream
.
hasDisplayURL
(
)
)
{
if
(
!
scriptSource
-
>
setDisplayURL
(
cx
tokenStream
.
displayURL
(
)
)
)
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
maybeSetSourceMap
(
TokenStream
&
tokenStream
)
{
if
(
tokenStream
.
hasSourceMapURL
(
)
)
{
MOZ_ASSERT
(
!
scriptSource
-
>
hasSourceMapURL
(
)
)
;
if
(
!
scriptSource
-
>
setSourceMapURL
(
cx
tokenStream
.
sourceMapURL
(
)
)
)
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
maybeSetSourceMapFromOptions
(
)
{
if
(
options
.
sourceMapURL
(
)
)
{
if
(
scriptSource
-
>
hasSourceMapURL
(
)
)
{
if
(
!
parser
-
>
report
(
ParseWarning
false
nullptr
JSMSG_ALREADY_HAS_PRAGMA
scriptSource
-
>
filename
(
)
"
/
/
#
sourceMappingURL
"
)
)
return
false
;
}
if
(
!
scriptSource
-
>
setSourceMapURL
(
cx
options
.
sourceMapURL
(
)
)
)
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
checkArgumentsWithinEval
(
JSContext
*
cx
HandleFunction
fun
)
{
RootedScript
script
(
cx
fun
-
>
getOrCreateScript
(
cx
)
)
;
if
(
!
script
)
return
false
;
if
(
script
-
>
isGeneratorExp
(
)
&
&
script
-
>
isLegacyGenerator
(
)
)
{
parser
-
>
report
(
ParseError
false
nullptr
JSMSG_BAD_GENEXP_BODY
js_arguments_str
)
;
return
false
;
}
return
true
;
}
bool
BytecodeCompiler
:
:
maybeCheckEvalFreeVariables
(
HandleScript
evalCaller
HandleObject
scopeChain
ParseContext
<
FullParseHandler
>
&
pc
)
{
if
(
!
evalCaller
|
|
!
evalCaller
-
>
functionOrCallerFunction
(
)
)
return
true
;
JSContext
*
cx
=
this
-
>
cx
-
>
asJSContext
(
)
;
RootedFunction
fun
(
cx
evalCaller
-
>
functionOrCallerFunction
(
)
)
;
HandlePropertyName
arguments
=
cx
-
>
names
(
)
.
arguments
;
for
(
AtomDefnRange
r
=
pc
.
lexdeps
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
if
(
r
.
front
(
)
.
key
(
)
=
=
arguments
)
{
if
(
!
checkArgumentsWithinEval
(
cx
fun
)
)
return
false
;
}
}
for
(
AtomDefnListMap
:
:
Range
r
=
pc
.
decls
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
if
(
r
.
front
(
)
.
key
(
)
=
=
arguments
)
{
if
(
!
checkArgumentsWithinEval
(
cx
fun
)
)
return
false
;
}
}
if
(
pc
.
sc
-
>
hasDebuggerStatement
(
)
)
{
RootedObject
scope
(
cx
scopeChain
)
;
while
(
scope
-
>
is
<
ScopeObject
>
(
)
|
|
scope
-
>
is
<
DebugScopeObject
>
(
)
)
{
if
(
scope
-
>
is
<
CallObject
>
(
)
&
&
!
scope
-
>
as
<
CallObject
>
(
)
.
isForEval
(
)
)
{
RootedScript
script
(
cx
scope
-
>
as
<
CallObject
>
(
)
.
callee
(
)
.
getOrCreateScript
(
cx
)
)
;
if
(
!
script
)
return
false
;
if
(
script
-
>
argumentsHasVarBinding
(
)
)
{
if
(
!
JSScript
:
:
argumentsOptimizationFailed
(
cx
script
)
)
return
false
;
}
}
scope
=
scope
-
>
enclosingScope
(
)
;
}
}
return
true
;
}
bool
BytecodeCompiler
:
:
emitFinalReturn
(
)
{
return
emitter
-
>
emit1
(
JSOP_RETRVAL
)
;
}
bool
BytecodeCompiler
:
:
initGlobalOrEvalBindings
(
ParseContext
<
FullParseHandler
>
&
pc
Handle
<
TraceableVector
<
Binding
>
>
vars
Handle
<
TraceableVector
<
Binding
>
>
lexicals
)
{
Rooted
<
Bindings
>
bindings
(
cx
script
-
>
bindings
)
;
Binding
*
packedBindings
=
alloc
-
>
newArrayUninitialized
<
Binding
>
(
vars
.
length
(
)
+
lexicals
.
length
(
)
)
;
if
(
!
packedBindings
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
Binding
*
packedIter
=
packedBindings
;
for
(
const
Binding
&
b
:
vars
)
*
packedIter
+
+
=
Binding
(
b
.
name
(
)
b
.
kind
(
)
false
)
;
for
(
const
Binding
&
b
:
lexicals
)
*
packedIter
+
+
=
Binding
(
b
.
name
(
)
b
.
kind
(
)
false
)
;
if
(
!
Bindings
:
:
initWithTemporaryStorage
(
cx
&
bindings
0
vars
.
length
(
)
lexicals
.
length
(
)
pc
.
blockScopeDepth
0
0
packedBindings
)
)
return
false
;
script
-
>
bindings
=
bindings
;
return
true
;
}
bool
BytecodeCompiler
:
:
maybeCompleteCompressSource
(
)
{
return
!
maybeSourceCompressor
|
|
maybeSourceCompressor
-
>
complete
(
)
;
}
JSScript
*
BytecodeCompiler
:
:
compileScript
(
HandleObject
scopeChain
HandleScript
evalCaller
)
{
if
(
!
createSourceAndParser
(
)
)
return
nullptr
;
bool
savedCallerFun
=
evalCaller
&
&
evalCaller
-
>
functionOrCallerFunction
(
)
;
if
(
!
createScript
(
savedCallerFun
)
)
return
nullptr
;
GlobalSharedContext
globalsc
(
cx
enclosingStaticScope
directives
options
.
extraWarningsOption
)
;
if
(
!
createEmitter
(
&
globalsc
evalCaller
isNonGlobalEvalCompilationUnit
(
)
)
)
return
nullptr
;
Rooted
<
TraceableVector
<
Binding
>
>
vars
(
cx
TraceableVector
<
Binding
>
(
cx
)
)
;
Rooted
<
TraceableVector
<
Binding
>
>
lexicals
(
cx
TraceableVector
<
Binding
>
(
cx
)
)
;
Maybe
<
ParseContext
<
FullParseHandler
>
>
pc
;
if
(
!
createParseContext
(
pc
globalsc
)
)
return
nullptr
;
if
(
savedCallerFun
&
&
!
saveCallerFun
(
evalCaller
pc
.
ref
(
)
)
)
return
nullptr
;
if
(
isEvalCompilationUnit
(
)
)
{
ParseNode
*
pn
;
do
{
pn
=
parser
-
>
evalBody
(
)
;
if
(
!
pn
&
&
!
handleStatementParseFailure
(
scopeChain
evalCaller
pc
globalsc
)
)
return
nullptr
;
}
while
(
!
pn
)
;
if
(
!
prepareAndEmitTree
(
&
pn
*
pc
)
)
return
nullptr
;
if
(
!
pc
-
>
drainGlobalOrEvalBindings
(
cx
&
vars
&
lexicals
)
)
return
nullptr
;
parser
-
>
handler
.
freeTree
(
pn
)
;
}
else
{
bool
canHaveDirectives
=
true
;
for
(
;
;
)
{
TokenKind
tt
;
if
(
!
parser
-
>
tokenStream
.
peekToken
(
&
tt
TokenStream
:
:
Operand
)
)
return
nullptr
;
if
(
tt
=
=
TOK_EOF
)
break
;
parser
-
>
tokenStream
.
tell
(
&
startPosition
)
;
ParseNode
*
pn
=
parser
-
>
statement
(
YieldIsName
canHaveDirectives
)
;
if
(
!
pn
)
{
if
(
!
handleStatementParseFailure
(
scopeChain
evalCaller
pc
globalsc
)
)
return
nullptr
;
pn
=
parser
-
>
statement
(
YieldIsName
)
;
if
(
!
pn
)
{
MOZ_ASSERT
(
!
parser
-
>
hadAbortedSyntaxParse
(
)
)
;
return
nullptr
;
}
}
if
(
canHaveDirectives
)
{
if
(
!
parser
-
>
maybeParseDirective
(
nullptr
pn
&
canHaveDirectives
)
)
return
nullptr
;
}
if
(
!
prepareAndEmitTree
(
&
pn
*
pc
)
)
return
nullptr
;
if
(
!
pc
-
>
drainGlobalOrEvalBindings
(
cx
&
vars
&
lexicals
)
)
return
nullptr
;
parser
-
>
handler
.
freeTree
(
pn
)
;
}
}
if
(
!
maybeCheckEvalFreeVariables
(
evalCaller
scopeChain
*
pc
)
|
|
!
maybeSetDisplayURL
(
parser
-
>
tokenStream
)
|
|
!
maybeSetSourceMap
(
parser
-
>
tokenStream
)
|
|
!
maybeSetSourceMapFromOptions
(
)
|
|
!
emitFinalReturn
(
)
|
|
!
initGlobalOrEvalBindings
(
pc
.
ref
(
)
vars
lexicals
)
|
|
!
JSScript
:
:
fullyInitFromEmitter
(
cx
script
emitter
.
ptr
(
)
)
)
{
return
nullptr
;
}
emitter
-
>
tellDebuggerAboutCompiledScript
(
cx
)
;
if
(
!
maybeCompleteCompressSource
(
)
)
return
nullptr
;
MOZ_ASSERT_IF
(
cx
-
>
isJSContext
(
)
!
cx
-
>
asJSContext
(
)
-
>
isExceptionPending
(
)
)
;
return
script
;
}
ModuleObject
*
BytecodeCompiler
:
:
compileModule
(
)
{
MOZ_ASSERT
(
!
enclosingStaticScope
)
;
if
(
!
createSourceAndParser
(
)
)
return
nullptr
;
if
(
!
createScript
(
)
)
return
nullptr
;
Rooted
<
ModuleObject
*
>
module
(
cx
ModuleObject
:
:
create
(
cx
)
)
;
if
(
!
module
)
return
nullptr
;
module
-
>
init
(
script
)
;
ParseNode
*
pn
=
parser
-
>
standaloneModule
(
module
)
;
if
(
!
pn
)
return
nullptr
;
if
(
!
NameFunctions
(
cx
pn
)
|
|
!
maybeSetDisplayURL
(
parser
-
>
tokenStream
)
|
|
!
maybeSetSourceMap
(
parser
-
>
tokenStream
)
)
{
return
nullptr
;
}
script
-
>
bindings
=
pn
-
>
pn_modulebox
-
>
bindings
;
RootedModuleEnvironmentObject
dynamicScope
(
cx
ModuleEnvironmentObject
:
:
create
(
cx
module
)
)
;
if
(
!
dynamicScope
)
return
nullptr
;
module
-
>
setInitialEnvironment
(
dynamicScope
)
;
if
(
!
createEmitter
(
pn
-
>
pn_modulebox
)
|
|
!
emitter
-
>
emitModuleScript
(
pn
-
>
pn_body
)
)
{
return
nullptr
;
}
ModuleBuilder
builder
(
cx
-
>
asJSContext
(
)
)
;
if
(
!
builder
.
buildAndInit
(
pn
module
)
)
return
nullptr
;
parser
-
>
handler
.
freeTree
(
pn
)
;
if
(
!
maybeCompleteCompressSource
(
)
)
return
nullptr
;
MOZ_ASSERT_IF
(
cx
-
>
isJSContext
(
)
!
cx
-
>
asJSContext
(
)
-
>
isExceptionPending
(
)
)
;
return
module
;
}
bool
BytecodeCompiler
:
:
compileFunctionBody
(
MutableHandleFunction
fun
Handle
<
PropertyNameVector
>
formals
GeneratorKind
generatorKind
)
{
MOZ_ASSERT
(
fun
)
;
MOZ_ASSERT
(
fun
-
>
isTenured
(
)
)
;
fun
-
>
setArgCount
(
formals
.
length
(
)
)
;
if
(
!
createSourceAndParser
(
)
)
return
false
;
ParseNode
*
fn
;
do
{
Directives
newDirectives
=
directives
;
fn
=
parser
-
>
standaloneFunctionBody
(
fun
formals
generatorKind
SyncFunction
directives
&
newDirectives
enclosingStaticScope
)
;
if
(
!
fn
&
&
!
handleParseFailure
(
newDirectives
)
)
return
false
;
}
while
(
!
fn
)
;
if
(
!
NameFunctions
(
cx
fn
)
|
|
!
maybeSetDisplayURL
(
parser
-
>
tokenStream
)
|
|
!
maybeSetSourceMap
(
parser
-
>
tokenStream
)
)
{
return
false
;
}
if
(
fn
-
>
pn_funbox
-
>
function
(
)
-
>
isInterpreted
(
)
)
{
MOZ_ASSERT
(
fun
=
=
fn
-
>
pn_funbox
-
>
function
(
)
)
;
if
(
!
createScript
(
)
)
return
false
;
script
-
>
bindings
=
fn
-
>
pn_funbox
-
>
bindings
;
if
(
!
createEmitter
(
fn
-
>
pn_funbox
)
|
|
!
emitter
-
>
emitFunctionScript
(
fn
-
>
pn_body
)
)
{
return
false
;
}
}
else
{
fun
.
set
(
fn
-
>
pn_funbox
-
>
function
(
)
)
;
MOZ_ASSERT
(
IsAsmJSModuleNative
(
fun
-
>
native
(
)
)
)
;
}
if
(
!
maybeCompleteCompressSource
(
)
)
return
false
;
return
true
;
}
ScriptSourceObject
*
BytecodeCompiler
:
:
sourceObjectPtr
(
)
const
{
return
sourceObject
.
get
(
)
;
}
ScriptSourceObject
*
frontend
:
:
CreateScriptSourceObject
(
ExclusiveContext
*
cx
const
ReadOnlyCompileOptions
&
options
)
{
ScriptSource
*
ss
=
cx
-
>
new_
<
ScriptSource
>
(
)
;
if
(
!
ss
)
return
nullptr
;
ScriptSourceHolder
ssHolder
(
ss
)
;
if
(
!
ss
-
>
initFromOptions
(
cx
options
)
)
return
nullptr
;
RootedScriptSource
sso
(
cx
ScriptSourceObject
:
:
create
(
cx
ss
)
)
;
if
(
!
sso
)
return
nullptr
;
if
(
cx
-
>
isJSContext
(
)
)
{
if
(
!
ScriptSourceObject
:
:
initFromOptions
(
cx
-
>
asJSContext
(
)
sso
options
)
)
return
nullptr
;
}
return
sso
;
}
JSScript
*
frontend
:
:
CompileScript
(
ExclusiveContext
*
cx
LifoAlloc
*
alloc
HandleObject
scopeChain
Handle
<
ScopeObject
*
>
enclosingStaticScope
HandleScript
evalCaller
const
ReadOnlyCompileOptions
&
options
SourceBufferHolder
&
srcBuf
JSString
*
source_
SourceCompressionTask
*
extraSct
ScriptSourceObject
*
*
sourceObjectOut
)
{
MOZ_ASSERT
(
srcBuf
.
get
(
)
)
;
MOZ_ASSERT_IF
(
evalCaller
options
.
isRunOnce
)
;
MOZ_ASSERT_IF
(
evalCaller
options
.
forEval
)
;
MOZ_ASSERT_IF
(
evalCaller
&
&
evalCaller
-
>
strict
(
)
options
.
strictOption
)
;
MOZ_ASSERT_IF
(
sourceObjectOut
*
sourceObjectOut
=
=
nullptr
)
;
BytecodeCompiler
compiler
(
cx
alloc
options
srcBuf
enclosingStaticScope
TraceLogger_ParserCompileScript
)
;
compiler
.
maybeSetSourceCompressor
(
extraSct
)
;
JSScript
*
script
=
compiler
.
compileScript
(
scopeChain
evalCaller
)
;
if
(
sourceObjectOut
)
*
sourceObjectOut
=
compiler
.
sourceObjectPtr
(
)
;
return
script
;
}
ModuleObject
*
frontend
:
:
CompileModule
(
JSContext
*
cx
HandleObject
obj
const
ReadOnlyCompileOptions
&
optionsInput
SourceBufferHolder
&
srcBuf
)
{
MOZ_ASSERT
(
srcBuf
.
get
(
)
)
;
CompileOptions
options
(
cx
optionsInput
)
;
options
.
maybeMakeStrictMode
(
true
)
;
options
.
setIsRunOnce
(
true
)
;
BytecodeCompiler
compiler
(
cx
&
cx
-
>
tempLifoAlloc
(
)
options
srcBuf
nullptr
TraceLogger_ParserCompileModule
)
;
return
compiler
.
compileModule
(
)
;
}
bool
frontend
:
:
CompileLazyFunction
(
JSContext
*
cx
Handle
<
LazyScript
*
>
lazy
const
char16_t
*
chars
size_t
length
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
lazy
-
>
functionNonDelazifying
(
)
-
>
compartment
(
)
)
;
CompileOptions
options
(
cx
lazy
-
>
version
(
)
)
;
options
.
setMutedErrors
(
lazy
-
>
mutedErrors
(
)
)
.
setFileAndLine
(
lazy
-
>
filename
(
)
lazy
-
>
lineno
(
)
)
.
setColumn
(
lazy
-
>
column
(
)
)
.
setNoScriptRval
(
false
)
.
setSelfHostingMode
(
false
)
;
AutoCompilationTraceLogger
traceLogger
(
cx
TraceLogger_ParserCompileLazy
)
;
Parser
<
FullParseHandler
>
parser
(
cx
&
cx
-
>
tempLifoAlloc
(
)
options
chars
length
true
nullptr
lazy
)
;
if
(
!
parser
.
checkOptions
(
)
)
return
false
;
Rooted
<
JSFunction
*
>
fun
(
cx
lazy
-
>
functionNonDelazifying
(
)
)
;
MOZ_ASSERT
(
!
lazy
-
>
isLegacyGenerator
(
)
)
;
ParseNode
*
pn
=
parser
.
standaloneLazyFunction
(
fun
lazy
-
>
strict
(
)
lazy
-
>
generatorKind
(
)
lazy
-
>
asyncKind
(
)
)
;
if
(
!
pn
)
return
false
;
if
(
!
NameFunctions
(
cx
pn
)
)
return
false
;
RootedObject
enclosingScope
(
cx
lazy
-
>
enclosingScope
(
)
)
;
RootedScriptSource
sourceObject
(
cx
lazy
-
>
sourceObject
(
)
)
;
MOZ_ASSERT
(
sourceObject
)
;
Rooted
<
JSScript
*
>
script
(
cx
JSScript
:
:
Create
(
cx
enclosingScope
false
options
sourceObject
lazy
-
>
begin
(
)
lazy
-
>
end
(
)
)
)
;
if
(
!
script
)
return
false
;
script
-
>
bindings
=
pn
-
>
pn_funbox
-
>
bindings
;
if
(
lazy
-
>
usesArgumentsApplyAndThis
(
)
)
script
-
>
setUsesArgumentsApplyAndThis
(
)
;
if
(
lazy
-
>
hasBeenCloned
(
)
)
script
-
>
setHasBeenCloned
(
)
;
MOZ_ASSERT
(
!
options
.
forEval
)
;
BytecodeEmitter
bce
(
nullptr
&
parser
pn
-
>
pn_funbox
script
lazy
false
nullptr
false
options
.
lineno
BytecodeEmitter
:
:
LazyFunction
)
;
if
(
!
bce
.
init
(
)
)
return
false
;
return
bce
.
emitFunctionScript
(
pn
-
>
pn_body
)
;
}
static
bool
CompileFunctionBody
(
JSContext
*
cx
MutableHandleFunction
fun
const
ReadOnlyCompileOptions
&
options
Handle
<
PropertyNameVector
>
formals
SourceBufferHolder
&
srcBuf
Handle
<
ScopeObject
*
>
enclosingStaticScope
GeneratorKind
generatorKind
)
{
MOZ_ASSERT
(
!
options
.
isRunOnce
)
;
BytecodeCompiler
compiler
(
cx
&
cx
-
>
tempLifoAlloc
(
)
options
srcBuf
enclosingStaticScope
TraceLogger_ParserCompileFunction
)
;
compiler
.
setSourceArgumentsNotIncluded
(
)
;
return
compiler
.
compileFunctionBody
(
fun
formals
generatorKind
)
;
}
bool
frontend
:
:
CompileFunctionBody
(
JSContext
*
cx
MutableHandleFunction
fun
const
ReadOnlyCompileOptions
&
options
Handle
<
PropertyNameVector
>
formals
JS
:
:
SourceBufferHolder
&
srcBuf
Handle
<
ScopeObject
*
>
enclosingStaticScope
)
{
return
CompileFunctionBody
(
cx
fun
options
formals
srcBuf
enclosingStaticScope
NotGenerator
)
;
}
bool
frontend
:
:
CompileFunctionBody
(
JSContext
*
cx
MutableHandleFunction
fun
const
ReadOnlyCompileOptions
&
options
Handle
<
PropertyNameVector
>
formals
JS
:
:
SourceBufferHolder
&
srcBuf
)
{
Rooted
<
ScopeObject
*
>
staticLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalScope
(
)
.
staticBlock
(
)
)
;
return
CompileFunctionBody
(
cx
fun
options
formals
srcBuf
staticLexical
NotGenerator
)
;
}
bool
frontend
:
:
CompileStarGeneratorBody
(
JSContext
*
cx
MutableHandleFunction
fun
const
ReadOnlyCompileOptions
&
options
Handle
<
PropertyNameVector
>
formals
JS
:
:
SourceBufferHolder
&
srcBuf
)
{
Rooted
<
ScopeObject
*
>
staticLexical
(
cx
&
cx
-
>
global
(
)
-
>
lexicalScope
(
)
.
staticBlock
(
)
)
;
return
CompileFunctionBody
(
cx
fun
options
formals
srcBuf
staticLexical
StarGenerator
)
;
}
