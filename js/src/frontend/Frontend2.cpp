#
include
"
frontend
/
Frontend2
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
smoosh_generated
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
mozilla
:
:
Utf8Unit
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
frontend
;
using
namespace
js
;
namespace
js
{
namespace
frontend
{
class
SmooshScriptStencil
:
public
ScriptStencil
{
const
SmooshResult
&
result_
;
void
init
(
)
{
lineno
=
result_
.
lineno
;
column
=
result_
.
column
;
natoms
=
result_
.
strings
.
len
;
ngcthings
=
1
;
numResumeOffsets
=
0
;
numScopeNotes
=
0
;
numTryNotes
=
0
;
mainOffset
=
result_
.
main_offset
;
nfixed
=
result_
.
max_fixed_slots
;
nslots
=
nfixed
+
result_
.
maximum_stack_depth
;
bodyScopeIndex
=
result_
.
body_scope_index
;
numICEntries
=
result_
.
num_ic_entries
;
numBytecodeTypeSets
=
result_
.
num_type_sets
;
strict
=
result_
.
strict
;
bindingsAccessedDynamically
=
result_
.
bindings_accessed_dynamically
;
hasCallSiteObj
=
result_
.
has_call_site_obj
;
isForEval
=
result_
.
is_for_eval
;
isModule
=
result_
.
is_module
;
isFunction
=
result_
.
is_function
;
hasNonSyntacticScope
=
result_
.
has_non_syntactic_scope
;
needsFunctionEnvironmentObjects
=
result_
.
needs_function_environment_objects
;
hasModuleGoal
=
result_
.
has_module_goal
;
code
=
mozilla
:
:
MakeSpan
(
result_
.
bytecode
.
data
result_
.
bytecode
.
len
)
;
MOZ_ASSERT
(
notes
.
IsEmpty
(
)
)
;
}
public
:
explicit
SmooshScriptStencil
(
const
SmooshResult
&
result
)
:
result_
(
result
)
{
init
(
)
;
}
virtual
bool
finishGCThings
(
JSContext
*
cx
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
gcthings
)
const
{
gcthings
[
0
]
=
JS
:
:
GCCellPtr
(
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
return
true
;
}
virtual
bool
initAtomMap
(
JSContext
*
cx
GCPtrAtom
*
atoms
)
const
{
for
(
uint32_t
i
=
0
;
i
<
natoms
;
i
+
+
)
{
const
CVec
<
uint8_t
>
&
string
=
result_
.
strings
.
data
[
i
]
;
JSAtom
*
atom
=
AtomizeUTF8Chars
(
cx
(
const
char
*
)
string
.
data
string
.
len
)
;
if
(
!
atom
)
{
return
false
;
}
atoms
[
i
]
=
atom
;
}
return
true
;
}
virtual
void
finishResumeOffsets
(
mozilla
:
:
Span
<
uint32_t
>
resumeOffsets
)
const
{
}
virtual
void
finishScopeNotes
(
mozilla
:
:
Span
<
ScopeNote
>
scopeNotes
)
const
{
}
virtual
void
finishTryNotes
(
mozilla
:
:
Span
<
JSTryNote
>
tryNotes
)
const
{
}
virtual
void
finishInnerFunctions
(
)
const
{
}
}
;
class
AutoFreeSmooshResult
{
SmooshResult
*
result_
;
public
:
AutoFreeSmooshResult
(
)
=
delete
;
explicit
AutoFreeSmooshResult
(
SmooshResult
*
result
)
:
result_
(
result
)
{
}
~
AutoFreeSmooshResult
(
)
{
if
(
result_
)
{
free_smoosh
(
*
result_
)
;
}
}
}
;
void
ReportSmooshCompileError
(
JSContext
*
cx
ErrorMetadata
&
&
metadata
int
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
ReportCompileErrorUTF8
(
cx
std
:
:
move
(
metadata
)
nullptr
JSREPORT_ERROR
errorNumber
&
args
)
;
va_end
(
args
)
;
}
JSScript
*
Smoosh
:
:
compileGlobalScript
(
CompilationInfo
&
compilationInfo
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
bool
*
unimplemented
)
{
auto
bytes
=
reinterpret_cast
<
const
uint8_t
*
>
(
srcBuf
.
get
(
)
)
;
size_t
length
=
srcBuf
.
length
(
)
;
JSContext
*
cx
=
compilationInfo
.
cx
;
const
auto
&
options
=
compilationInfo
.
options
;
SmooshCompileOptions
compileOptions
;
compileOptions
.
no_script_rval
=
options
.
noScriptRval
;
SmooshResult
smoosh
=
run_smoosh
(
bytes
length
&
compileOptions
)
;
AutoFreeSmooshResult
afsr
(
&
smoosh
)
;
if
(
smoosh
.
error
.
data
)
{
*
unimplemented
=
false
;
ErrorMetadata
metadata
;
metadata
.
filename
=
"
<
unknown
>
"
;
metadata
.
lineNumber
=
1
;
metadata
.
columnNumber
=
0
;
metadata
.
isMuted
=
false
;
ReportSmooshCompileError
(
cx
std
:
:
move
(
metadata
)
JSMSG_SMOOSH_COMPILE_ERROR
reinterpret_cast
<
const
char
*
>
(
smoosh
.
error
.
data
)
)
;
return
nullptr
;
}
if
(
smoosh
.
unimplemented
)
{
*
unimplemented
=
true
;
return
nullptr
;
}
*
unimplemented
=
false
;
RootedScriptSourceObject
sso
(
cx
frontend
:
:
CreateScriptSourceObject
(
cx
options
)
)
;
if
(
!
sso
)
{
return
nullptr
;
}
RootedObject
proto
(
cx
)
;
if
(
!
GetFunctionPrototype
(
cx
GeneratorKind
:
:
NotGenerator
FunctionAsyncKind
:
:
SyncFunction
&
proto
)
)
{
return
nullptr
;
}
SourceExtent
extent
(
0
length
0
length
1
0
)
;
RootedScript
script
(
cx
JSScript
:
:
Create
(
cx
cx
-
>
global
(
)
options
sso
extent
)
)
;
SmooshScriptStencil
stencil
(
smoosh
)
;
if
(
!
JSScript
:
:
fullyInitFromStencil
(
cx
script
stencil
)
)
{
return
nullptr
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
{
return
nullptr
;
}
if
(
!
Disassemble
(
cx
script
true
&
sprinter
DisassembleSkeptically
:
:
Yes
)
)
{
return
nullptr
;
}
printf
(
"
%
s
\
n
"
sprinter
.
string
(
)
)
;
if
(
!
Disassemble
(
cx
script
true
&
sprinter
DisassembleSkeptically
:
:
No
)
)
{
return
nullptr
;
}
#
endif
return
script
;
}
bool
SmooshParseScript
(
JSContext
*
cx
const
uint8_t
*
bytes
size_t
length
)
{
if
(
test_parse_script
(
bytes
length
)
)
{
return
true
;
}
JS_ReportErrorASCII
(
cx
"
Smoosh
parse
script
failed
"
)
;
return
false
;
}
bool
SmooshParseModule
(
JSContext
*
cx
const
uint8_t
*
bytes
size_t
length
)
{
if
(
test_parse_module
(
bytes
length
)
)
{
return
true
;
}
JS_ReportErrorASCII
(
cx
"
Smoosh
parse
module
failed
"
)
;
return
false
;
}
}
}
