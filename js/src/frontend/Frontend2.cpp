#
include
"
frontend
/
Frontend2
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
smoosh_generated
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
irregexp
/
RegExpAPI
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
mozilla
:
:
Utf8Unit
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
frontend
;
using
namespace
js
;
namespace
js
{
namespace
frontend
{
class
SmooshScriptStencil
:
public
ScriptStencil
{
const
SmooshResult
&
result_
;
CompilationInfo
&
compilationInfo_
;
JSAtom
*
*
allAtoms_
=
nullptr
;
public
:
SmooshScriptStencil
(
const
SmooshResult
&
result
CompilationInfo
&
compilationInfo
)
:
ScriptStencil
(
compilationInfo
.
cx
)
result_
(
result
)
compilationInfo_
(
compilationInfo
)
{
}
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
UniquePtr
<
ImmutableScriptData
>
immutableData
)
{
using
ImmutableFlags
=
js
:
:
ImmutableScriptFlagsEnum
;
const
JS
:
:
ReadOnlyCompileOptions
&
options
=
compilationInfo_
.
options
;
immutableFlags
=
result_
.
top_level_script
.
immutable_flags
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
SelfHosted
options
.
selfHostingMode
)
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
NoScriptRval
options
.
noScriptRval
)
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
immutableScriptData
=
std
:
:
move
(
immutableData
)
;
if
(
!
createAtoms
(
cx
)
)
{
return
false
;
}
if
(
!
createGCThings
(
cx
)
)
{
return
false
;
}
if
(
!
createScopeCreationData
(
cx
)
)
{
return
false
;
}
if
(
!
createRegExpData
(
cx
)
)
{
return
false
;
}
return
true
;
}
private
:
bool
createAtoms
(
JSContext
*
cx
)
{
size_t
numAtoms
=
result_
.
all_atoms_len
;
auto
&
alloc
=
compilationInfo_
.
allocScope
.
alloc
(
)
;
allAtoms_
=
alloc
.
newArray
<
JSAtom
*
>
(
numAtoms
)
;
if
(
!
allAtoms_
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
numAtoms
;
i
+
+
)
{
auto
s
=
smoosh_get_atom_at
(
result_
i
)
;
auto
len
=
smoosh_get_atom_len_at
(
result_
i
)
;
JSAtom
*
atom
=
AtomizeUTF8Chars
(
cx
s
len
)
;
if
(
!
atom
)
{
return
false
;
}
allAtoms_
[
i
]
=
atom
;
}
return
true
;
}
bool
createGCThings
(
JSContext
*
cx
)
{
size_t
ngcthings
=
result_
.
top_level_script
.
gcthings
.
len
;
if
(
!
gcThings
.
reserve
(
ngcthings
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
ngcthings
;
i
+
+
)
{
SmooshGCThing
&
item
=
result_
.
top_level_script
.
gcthings
.
data
[
i
]
;
switch
(
item
.
tag
)
{
case
SmooshGCThing
:
:
Tag
:
:
Atom
:
{
gcThings
.
infallibleAppend
(
mozilla
:
:
AsVariant
(
allAtoms_
[
item
.
AsAtom
(
)
]
)
)
;
break
;
}
case
SmooshGCThing
:
:
Tag
:
:
Scope
:
{
gcThings
.
infallibleAppend
(
mozilla
:
:
AsVariant
(
ScopeIndex
(
item
.
AsScope
(
)
)
)
)
;
break
;
}
case
SmooshGCThing
:
:
Tag
:
:
RegExp
:
{
gcThings
.
infallibleAppend
(
mozilla
:
:
AsVariant
(
RegExpIndex
(
item
.
AsRegExp
(
)
)
)
)
;
break
;
}
}
}
return
true
;
}
private
:
bool
createScopeCreationData
(
JSContext
*
cx
)
{
auto
&
alloc
=
compilationInfo_
.
allocScope
.
alloc
(
)
;
for
(
size_t
i
=
0
;
i
<
result_
.
scopes
.
len
;
i
+
+
)
{
SmooshScopeData
&
scopeData
=
result_
.
scopes
.
data
[
i
]
;
ScopeIndex
index
;
switch
(
scopeData
.
tag
)
{
case
SmooshScopeData
:
:
Tag
:
:
Global
:
{
auto
&
global
=
scopeData
.
AsGlobal
(
)
;
size_t
numBindings
=
global
.
bindings
.
len
;
JS
:
:
Rooted
<
GlobalScope
:
:
Data
*
>
data
(
cx
NewEmptyGlobalScopeData
(
cx
alloc
numBindings
)
)
;
if
(
!
data
)
{
return
false
;
}
copyBindingNames
(
global
.
bindings
data
-
>
trailingNames
.
start
(
)
)
;
data
-
>
letStart
=
global
.
let_start
;
data
-
>
constStart
=
global
.
const_start
;
data
-
>
length
=
numBindings
;
if
(
!
ScopeCreationData
:
:
create
(
cx
compilationInfo_
ScopeKind
:
:
Global
data
&
index
)
)
{
return
false
;
}
break
;
}
case
SmooshScopeData
:
:
Tag
:
:
Lexical
:
{
auto
&
lexical
=
scopeData
.
AsLexical
(
)
;
size_t
numBindings
=
lexical
.
bindings
.
len
;
JS
:
:
Rooted
<
LexicalScope
:
:
Data
*
>
data
(
cx
NewEmptyLexicalScopeData
(
cx
alloc
numBindings
)
)
;
if
(
!
data
)
{
return
false
;
}
copyBindingNames
(
lexical
.
bindings
data
-
>
trailingNames
.
start
(
)
)
;
data
-
>
constStart
=
lexical
.
const_start
;
data
-
>
length
=
numBindings
;
uint32_t
firstFrameSlot
=
lexical
.
first_frame_slot
;
ScopeIndex
enclosingIndex
(
lexical
.
enclosing
)
;
Rooted
<
AbstractScopePtr
>
enclosing
(
cx
AbstractScopePtr
(
compilationInfo_
enclosingIndex
)
)
;
if
(
!
ScopeCreationData
:
:
create
(
cx
compilationInfo_
ScopeKind
:
:
Lexical
data
firstFrameSlot
enclosing
&
index
)
)
{
return
false
;
}
break
;
}
}
MOZ_ASSERT
(
index
=
=
i
)
;
}
return
true
;
}
bool
createRegExpData
(
JSContext
*
cx
)
{
for
(
size_t
i
=
0
;
i
<
result_
.
regexps
.
len
;
i
+
+
)
{
SmooshRegExpItem
&
item
=
result_
.
regexps
.
data
[
i
]
;
auto
s
=
smoosh_get_slice_at
(
result_
item
.
pattern
)
;
auto
len
=
smoosh_get_slice_len_at
(
result_
item
.
pattern
)
;
JS
:
:
RegExpFlags
:
:
Flag
flags
=
JS
:
:
RegExpFlag
:
:
NoFlags
;
if
(
item
.
global
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
Global
;
}
if
(
item
.
ignore_case
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
IgnoreCase
;
}
if
(
item
.
multi_line
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
Multiline
;
}
if
(
item
.
dot_all
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
DotAll
;
}
if
(
item
.
sticky
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
Sticky
;
}
if
(
item
.
unicode
)
{
flags
|
=
JS
:
:
RegExpFlag
:
:
Unicode
;
}
size_t
length
;
JS
:
:
UniqueTwoByteChars
pattern
(
UTF8CharsToNewTwoByteCharsZ
(
cx
JS
:
:
UTF8Chars
(
s
len
)
&
length
StringBufferArena
)
.
get
(
)
)
;
if
(
!
pattern
)
{
return
false
;
}
mozilla
:
:
Range
<
const
char16_t
>
range
(
pattern
.
get
(
)
length
)
;
TokenStreamAnyChars
ts
(
cx
compilationInfo_
.
options
nullptr
)
;
LifoAllocScope
allocScope
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
if
(
!
irregexp
:
:
CheckPatternSyntax
(
cx
ts
range
flags
)
)
{
return
false
;
}
RegExpIndex
index
(
compilationInfo_
.
regExpData
.
length
(
)
)
;
if
(
!
compilationInfo_
.
regExpData
.
emplaceBack
(
)
)
{
return
false
;
}
if
(
!
compilationInfo_
.
regExpData
[
index
]
.
init
(
cx
range
JS
:
:
RegExpFlags
(
flags
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
index
.
index
=
=
i
)
;
}
return
true
;
}
void
copyBindingNames
(
CVec
<
SmooshBindingName
>
&
from
BindingName
*
to
)
{
size_t
numBindings
=
from
.
len
;
for
(
size_t
i
=
0
;
i
<
numBindings
;
i
+
+
)
{
SmooshBindingName
&
name
=
from
.
data
[
i
]
;
new
(
mozilla
:
:
KnownNotNull
&
to
[
i
]
)
BindingName
(
allAtoms_
[
name
.
name
]
name
.
is_closed_over
name
.
is_top_level_function
)
;
}
}
}
;
class
AutoFreeSmooshResult
{
SmooshResult
*
result_
;
public
:
AutoFreeSmooshResult
(
)
=
delete
;
explicit
AutoFreeSmooshResult
(
SmooshResult
*
result
)
:
result_
(
result
)
{
}
~
AutoFreeSmooshResult
(
)
{
if
(
result_
)
{
smoosh_free
(
*
result_
)
;
}
}
}
;
class
AutoFreeSmooshParseResult
{
SmooshParseResult
*
result_
;
public
:
AutoFreeSmooshParseResult
(
)
=
delete
;
explicit
AutoFreeSmooshParseResult
(
SmooshParseResult
*
result
)
:
result_
(
result
)
{
}
~
AutoFreeSmooshParseResult
(
)
{
if
(
result_
)
{
smoosh_free_parse_result
(
*
result_
)
;
}
}
}
;
void
InitSmoosh
(
)
{
smoosh_init
(
)
;
}
void
ReportSmooshCompileError
(
JSContext
*
cx
ErrorMetadata
&
&
metadata
int
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
ReportCompileErrorUTF8
(
cx
std
:
:
move
(
metadata
)
nullptr
errorNumber
&
args
)
;
va_end
(
args
)
;
}
JSScript
*
Smoosh
:
:
compileGlobalScript
(
CompilationInfo
&
compilationInfo
JS
:
:
SourceText
<
Utf8Unit
>
&
srcBuf
bool
*
unimplemented
)
{
auto
bytes
=
reinterpret_cast
<
const
uint8_t
*
>
(
srcBuf
.
get
(
)
)
;
size_t
length
=
srcBuf
.
length
(
)
;
JSContext
*
cx
=
compilationInfo
.
cx
;
const
auto
&
options
=
compilationInfo
.
options
;
SmooshCompileOptions
compileOptions
;
compileOptions
.
no_script_rval
=
options
.
noScriptRval
;
SmooshResult
smoosh
=
smoosh_run
(
bytes
length
&
compileOptions
)
;
AutoFreeSmooshResult
afsr
(
&
smoosh
)
;
if
(
smoosh
.
error
.
data
)
{
*
unimplemented
=
false
;
ErrorMetadata
metadata
;
metadata
.
filename
=
"
<
unknown
>
"
;
metadata
.
lineNumber
=
1
;
metadata
.
columnNumber
=
0
;
metadata
.
isMuted
=
false
;
ReportSmooshCompileError
(
cx
std
:
:
move
(
metadata
)
JSMSG_SMOOSH_COMPILE_ERROR
reinterpret_cast
<
const
char
*
>
(
smoosh
.
error
.
data
)
)
;
return
nullptr
;
}
if
(
smoosh
.
unimplemented
)
{
*
unimplemented
=
true
;
return
nullptr
;
}
*
unimplemented
=
false
;
auto
&
smooshScript
=
smoosh
.
top_level_script
;
auto
&
smooshScriptData
=
smoosh
.
script_data_list
.
data
[
smooshScript
.
immutable_script_data
.
AsSome
(
)
]
;
Vector
<
ScopeNote
0
SystemAllocPolicy
>
scopeNotes
;
if
(
!
scopeNotes
.
resize
(
smooshScriptData
.
scope_notes
.
len
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
smooshScriptData
.
scope_notes
.
len
;
i
+
+
)
{
SmooshScopeNote
&
scopeNote
=
smooshScriptData
.
scope_notes
.
data
[
i
]
;
scopeNotes
[
i
]
.
index
=
scopeNote
.
index
;
scopeNotes
[
i
]
.
start
=
scopeNote
.
start
;
scopeNotes
[
i
]
.
length
=
scopeNote
.
length
;
scopeNotes
[
i
]
.
parent
=
scopeNote
.
parent
;
}
bool
isFunction
=
false
;
int
funLength
=
0
;
auto
immutableScriptData
=
ImmutableScriptData
:
:
new_
(
cx
smooshScriptData
.
main_offset
smooshScriptData
.
nfixed
smooshScriptData
.
nslots
smooshScriptData
.
body_scope_index
smooshScriptData
.
num_ic_entries
smooshScriptData
.
num_bytecode_type_sets
isFunction
funLength
mozilla
:
:
MakeSpan
(
smooshScriptData
.
bytecode
.
data
smooshScriptData
.
bytecode
.
len
)
mozilla
:
:
Span
<
const
SrcNote
>
(
)
mozilla
:
:
Span
<
const
uint32_t
>
(
)
scopeNotes
mozilla
:
:
Span
<
const
TryNote
>
(
)
)
;
if
(
!
immutableScriptData
)
{
return
nullptr
;
}
SmooshScriptStencil
stencil
(
smoosh
compilationInfo
)
;
if
(
!
stencil
.
init
(
cx
std
:
:
move
(
immutableScriptData
)
)
)
{
return
nullptr
;
}
stencil
.
extent
=
SourceExtent
:
:
makeGlobalExtent
(
length
)
;
RootedScript
script
(
cx
JSScript
:
:
fromStencil
(
cx
compilationInfo
stencil
)
)
;
if
(
!
script
)
{
return
nullptr
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
{
return
nullptr
;
}
if
(
!
Disassemble
(
cx
script
true
&
sprinter
DisassembleSkeptically
:
:
Yes
)
)
{
return
nullptr
;
}
printf
(
"
%
s
\
n
"
sprinter
.
string
(
)
)
;
if
(
!
Disassemble
(
cx
script
true
&
sprinter
DisassembleSkeptically
:
:
No
)
)
{
return
nullptr
;
}
#
endif
return
script
;
}
bool
SmooshParseScript
(
JSContext
*
cx
const
uint8_t
*
bytes
size_t
length
)
{
SmooshParseResult
result
=
smoosh_test_parse_script
(
bytes
length
)
;
AutoFreeSmooshParseResult
afspr
(
&
result
)
;
if
(
result
.
error
.
data
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
result
.
unimplemented
?
JSMSG_SMOOSH_UNIMPLEMENTED
:
JSMSG_SMOOSH_COMPILE_ERROR
reinterpret_cast
<
const
char
*
>
(
result
.
error
.
data
)
)
;
return
false
;
}
return
true
;
}
bool
SmooshParseModule
(
JSContext
*
cx
const
uint8_t
*
bytes
size_t
length
)
{
SmooshParseResult
result
=
smoosh_test_parse_module
(
bytes
length
)
;
AutoFreeSmooshParseResult
afspr
(
&
result
)
;
if
(
result
.
error
.
data
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
result
.
unimplemented
?
JSMSG_SMOOSH_UNIMPLEMENTED
:
JSMSG_SMOOSH_COMPILE_ERROR
reinterpret_cast
<
const
char
*
>
(
result
.
error
.
data
)
)
;
return
false
;
}
return
true
;
}
}
}
