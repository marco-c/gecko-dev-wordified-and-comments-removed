#
ifndef
frontend_FunctionTree_h
#
define
frontend_FunctionTree_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
namespace
frontend
{
class
FunctionBox
;
class
ParserBase
;
class
FunctionTree
{
FunctionBox
*
funbox_
;
Vector
<
FunctionTree
>
children_
;
public
:
explicit
FunctionTree
(
JSContext
*
cx
)
:
funbox_
(
nullptr
)
children_
(
cx
)
{
}
FunctionTree
*
add
(
JSContext
*
cx
)
{
if
(
!
children_
.
emplaceBack
(
cx
)
)
{
return
nullptr
;
}
return
&
children_
.
back
(
)
;
}
void
reset
(
)
{
funbox_
=
nullptr
;
children_
.
clear
(
)
;
}
FunctionBox
*
funbox
(
)
{
return
funbox_
;
}
void
setFunctionBox
(
FunctionBox
*
node
)
{
funbox_
=
node
;
}
typedef
bool
(
*
FunctionTreeVisitorFunction
)
(
ParserBase
*
FunctionTree
*
)
;
bool
visitRecursively
(
JSContext
*
cx
ParserBase
*
parser
FunctionTreeVisitorFunction
func
)
{
if
(
!
CheckRecursionLimit
(
cx
)
)
{
return
false
;
}
for
(
auto
&
child
:
children_
)
{
if
(
!
child
.
visitRecursively
(
cx
parser
func
)
)
{
return
false
;
}
}
return
func
(
parser
this
)
;
}
void
dump
(
JSContext
*
cx
)
{
dump
(
cx
*
this
1
)
;
}
private
:
static
void
dump
(
JSContext
*
cx
FunctionTree
&
node
int
indent
)
;
}
;
class
FunctionTreeHolder
{
private
:
FunctionTree
treeRoot_
;
FunctionTree
*
currentParent_
;
public
:
explicit
FunctionTreeHolder
(
JSContext
*
cx
)
:
treeRoot_
(
cx
)
currentParent_
(
&
treeRoot_
)
{
}
FunctionTree
*
getFunctionTree
(
)
{
return
&
treeRoot_
;
}
FunctionTree
*
getCurrentParent
(
)
{
return
currentParent_
;
}
void
setCurrentParent
(
FunctionTree
*
parent
)
{
currentParent_
=
parent
;
}
void
resetFunctionTree
(
)
{
treeRoot_
.
reset
(
)
;
currentParent_
=
&
treeRoot_
;
}
}
;
class
MOZ_RAII
AutoPushTree
{
FunctionTreeHolder
&
holder_
;
FunctionTree
*
oldParent_
=
nullptr
;
public
:
explicit
AutoPushTree
(
FunctionTreeHolder
&
holder
)
;
~
AutoPushTree
(
)
;
bool
init
(
JSContext
*
cx
FunctionBox
*
box
)
;
}
;
}
}
#
endif
