#
ifndef
frontend_ParseNodeVisitor_h
#
define
frontend_ParseNodeVisitor_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
namespace
js
{
namespace
frontend
{
template
<
typename
Derived
>
class
ParseNodeVisitor
{
public
:
JSContext
*
cx_
;
explicit
ParseNodeVisitor
(
JSContext
*
cx
)
:
cx_
(
cx
)
{
}
[
[
nodiscard
]
]
bool
visit
(
ParseNode
*
pn
)
{
if
(
!
CheckRecursionLimit
(
cx_
)
)
{
return
false
;
}
switch
(
pn
-
>
getKind
(
)
)
{
#
define
VISIT_CASE
(
KIND
TYPE
)
\
case
ParseNodeKind
:
:
KIND
:
\
return
static_cast
<
Derived
*
>
(
this
)
-
>
visit
#
#
KIND
(
&
pn
-
>
as
<
TYPE
>
(
)
)
;
FOR_EACH_PARSE_NODE_KIND
(
VISIT_CASE
)
#
undef
VISIT_CASE
default
:
MOZ_CRASH
(
"
invalid
node
kind
"
)
;
}
}
#
define
VISIT_METHOD
(
KIND
TYPE
)
\
[
[
nodiscard
]
]
bool
visit
#
#
KIND
(
TYPE
*
pn
)
{
/
*
NOLINT
*
/
\
return
pn
-
>
accept
(
*
static_cast
<
Derived
*
>
(
this
)
)
;
\
}
FOR_EACH_PARSE_NODE_KIND
(
VISIT_METHOD
)
#
undef
VISIT_METHOD
}
;
template
<
typename
Derived
>
class
RewritingParseNodeVisitor
{
public
:
JSContext
*
cx_
;
explicit
RewritingParseNodeVisitor
(
JSContext
*
cx
)
:
cx_
(
cx
)
{
}
[
[
nodiscard
]
]
bool
visit
(
ParseNode
*
&
pn
)
{
if
(
!
CheckRecursionLimit
(
cx_
)
)
{
return
false
;
}
switch
(
pn
-
>
getKind
(
)
)
{
#
define
VISIT_CASE
(
KIND
_type
)
\
case
ParseNodeKind
:
:
KIND
:
\
return
static_cast
<
Derived
*
>
(
this
)
-
>
visit
#
#
KIND
(
pn
)
;
FOR_EACH_PARSE_NODE_KIND
(
VISIT_CASE
)
#
undef
VISIT_CASE
default
:
MOZ_CRASH
(
"
invalid
node
kind
"
)
;
}
}
#
define
VISIT_METHOD
(
KIND
TYPE
)
\
[
[
nodiscard
]
]
bool
visit
#
#
KIND
(
ParseNode
*
&
pn
)
{
\
MOZ_ASSERT
(
pn
-
>
is
<
TYPE
>
(
)
\
"
Node
of
kind
"
#
KIND
"
was
not
of
type
"
#
TYPE
)
;
\
return
pn
-
>
as
<
TYPE
>
(
)
.
accept
(
*
static_cast
<
Derived
*
>
(
this
)
)
;
\
}
FOR_EACH_PARSE_NODE_KIND
(
VISIT_METHOD
)
#
undef
VISIT_METHOD
}
;
}
}
#
endif
