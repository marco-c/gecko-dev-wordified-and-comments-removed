#
include
"
frontend
/
Stencil
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
WasmModule
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
ObjectGroup
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
bool
frontend
:
:
RegExpCreationData
:
:
init
(
JSContext
*
cx
JSAtom
*
pattern
JS
:
:
RegExpFlags
flags
)
{
length_
=
pattern
-
>
length
(
)
;
buf_
=
cx
-
>
make_pod_array
<
char16_t
>
(
length_
)
;
if
(
!
buf_
)
{
return
false
;
}
js
:
:
CopyChars
(
buf_
.
get
(
)
*
pattern
)
;
flags_
=
flags
;
return
true
;
}
AbstractScopePtr
ScopeCreationData
:
:
enclosing
(
CompilationInfo
&
compilationInfo
)
{
if
(
enclosing_
)
{
return
AbstractScopePtr
(
compilationInfo
*
enclosing_
)
;
}
if
(
compilationInfo
.
options
.
selfHostingMode
)
{
MOZ_ASSERT
(
compilationInfo
.
enclosingScope
=
=
nullptr
)
;
return
AbstractScopePtr
(
&
compilationInfo
.
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
)
;
}
return
AbstractScopePtr
(
compilationInfo
.
enclosingScope
)
;
}
Scope
*
ScopeCreationData
:
:
getEnclosingScope
(
CompilationInfo
&
compilationInfo
)
{
return
enclosing
(
compilationInfo
)
.
existingScope
(
)
;
}
JSFunction
*
ScopeCreationData
:
:
function
(
frontend
:
:
CompilationInfo
&
compilationInfo
)
{
return
compilationInfo
.
functions
[
*
functionIndex_
]
;
}
Scope
*
ScopeCreationData
:
:
createScope
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
Scope
*
scope
=
nullptr
;
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
{
scope
=
createSpecificScope
<
FunctionScope
CallObject
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
{
scope
=
createSpecificScope
<
LexicalScope
LexicalEnvironmentObject
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
FunctionBodyVar
:
{
scope
=
createSpecificScope
<
VarScope
VarEnvironmentObject
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
{
scope
=
createSpecificScope
<
GlobalScope
std
:
:
nullptr_t
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
{
scope
=
createSpecificScope
<
EvalScope
VarEnvironmentObject
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
Module
:
{
scope
=
createSpecificScope
<
ModuleScope
ModuleEnvironmentObject
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
With
:
{
scope
=
createSpecificScope
<
WithScope
std
:
:
nullptr_t
>
(
cx
compilationInfo
)
;
break
;
}
case
ScopeKind
:
:
WasmFunction
:
case
ScopeKind
:
:
WasmInstance
:
{
MOZ_CRASH
(
"
Unexpected
deferred
type
"
)
;
}
}
return
scope
;
}
void
ScopeCreationData
:
:
trace
(
JSTracer
*
trc
)
{
if
(
data_
)
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
{
data
<
FunctionScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
{
data
<
LexicalScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
FunctionBodyVar
:
{
data
<
VarScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
{
data
<
GlobalScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
{
data
<
EvalScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
Module
:
{
data
<
ModuleScope
>
(
)
.
trace
(
trc
)
;
break
;
}
case
ScopeKind
:
:
With
:
default
:
MOZ_CRASH
(
"
Unexpected
data
type
"
)
;
}
}
}
uint32_t
ScopeCreationData
:
:
nextFrameSlot
(
)
const
{
switch
(
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
return
nextFrameSlot
<
FunctionScope
>
(
)
;
case
ScopeKind
:
:
FunctionBodyVar
:
return
nextFrameSlot
<
VarScope
>
(
)
;
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
return
nextFrameSlot
<
LexicalScope
>
(
)
;
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
return
0
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
return
nextFrameSlot
<
EvalScope
>
(
)
;
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
return
0
;
case
ScopeKind
:
:
Module
:
return
nextFrameSlot
<
ModuleScope
>
(
)
;
case
ScopeKind
:
:
WasmInstance
:
case
ScopeKind
:
:
WasmFunction
:
case
ScopeKind
:
:
With
:
MOZ_CRASH
(
"
With
WasmInstance
and
WasmFunction
Scopes
don
'
t
get
"
"
nextFrameSlot
(
)
"
)
;
return
0
;
}
MOZ_CRASH
(
"
Not
an
enclosing
intra
-
frame
scope
"
)
;
}
void
StencilModuleEntry
:
:
trace
(
JSTracer
*
trc
)
{
if
(
specifier
)
{
TraceManuallyBarrieredEdge
(
trc
&
specifier
"
module
specifier
"
)
;
}
if
(
localName
)
{
TraceManuallyBarrieredEdge
(
trc
&
localName
"
module
local
name
"
)
;
}
if
(
importName
)
{
TraceManuallyBarrieredEdge
(
trc
&
importName
"
module
import
name
"
)
;
}
if
(
exportName
)
{
TraceManuallyBarrieredEdge
(
trc
&
exportName
"
module
export
name
"
)
;
}
}
void
StencilModuleMetadata
:
:
trace
(
JSTracer
*
trc
)
{
requestedModules
.
trace
(
trc
)
;
importEntries
.
trace
(
trc
)
;
localExportEntries
.
trace
(
trc
)
;
indirectExportEntries
.
trace
(
trc
)
;
starExportEntries
.
trace
(
trc
)
;
}
void
ScriptStencil
:
:
trace
(
JSTracer
*
trc
)
{
for
(
ScriptThingVariant
&
thing
:
gcThings
)
{
if
(
thing
.
is
<
ScriptAtom
>
(
)
)
{
JSAtom
*
atom
=
thing
.
as
<
ScriptAtom
>
(
)
;
TraceRoot
(
trc
&
atom
"
script
-
atom
"
)
;
MOZ_ASSERT
(
atom
=
=
thing
.
as
<
ScriptAtom
>
(
)
"
Atoms
should
be
unmovable
"
)
;
}
}
if
(
functionAtom
)
{
TraceRoot
(
trc
&
functionAtom
"
script
-
atom
"
)
;
}
}
static
bool
CreateLazyScript
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScriptStencil
&
stencil
HandleFunction
function
)
{
const
ScriptThingsVector
&
gcthings
=
stencil
.
gcThings
;
Rooted
<
BaseScript
*
>
lazy
(
cx
BaseScript
:
:
CreateRawLazy
(
cx
gcthings
.
length
(
)
function
compilationInfo
.
sourceObject
stencil
.
extent
stencil
.
immutableFlags
)
)
;
if
(
!
lazy
)
{
return
false
;
}
if
(
!
EmitScriptThingsVector
(
cx
compilationInfo
gcthings
lazy
-
>
gcthingsForInit
(
)
)
)
{
return
false
;
}
function
-
>
initScript
(
lazy
)
;
return
true
;
}
static
JSFunction
*
CreateFunction
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ScriptStencil
&
stencil
FunctionIndex
functionIndex
)
{
GeneratorKind
generatorKind
=
stencil
.
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
IsGenerator
)
?
GeneratorKind
:
:
Generator
:
GeneratorKind
:
:
NotGenerator
;
FunctionAsyncKind
asyncKind
=
stencil
.
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
IsAsync
)
?
FunctionAsyncKind
:
:
AsyncFunction
:
FunctionAsyncKind
:
:
SyncFunction
;
RootedObject
proto
(
cx
)
;
if
(
!
GetFunctionPrototype
(
cx
generatorKind
asyncKind
&
proto
)
)
{
return
nullptr
;
}
gc
:
:
AllocKind
allocKind
=
stencil
.
functionFlags
.
isExtended
(
)
?
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
:
gc
:
:
AllocKind
:
:
FUNCTION
;
bool
isAsmJS
=
stencil
.
functionFlags
.
isAsmJSNative
(
)
;
JSNative
maybeNative
=
isAsmJS
?
InstantiateAsmJS
:
nullptr
;
RootedAtom
displayAtom
(
cx
stencil
.
functionAtom
)
;
RootedFunction
fun
(
cx
NewFunctionWithProto
(
cx
maybeNative
stencil
.
nargs
stencil
.
functionFlags
nullptr
displayAtom
proto
allocKind
TenuredObject
)
)
;
if
(
!
fun
)
{
return
nullptr
;
}
if
(
isAsmJS
)
{
RefPtr
<
const
JS
:
:
WasmModule
>
asmJS
=
compilationInfo
.
asmJS
.
lookup
(
functionIndex
)
-
>
value
(
)
;
JSObject
*
moduleObj
=
asmJS
-
>
createObjectForAsmJS
(
cx
)
;
if
(
!
moduleObj
)
{
return
nullptr
;
}
fun
-
>
setExtendedSlot
(
FunctionExtended
:
:
ASMJS_MODULE_SLOT
ObjectValue
(
*
moduleObj
)
)
;
}
return
fun
;
}
static
bool
InstantiateScriptSourceObject
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
MOZ_ASSERT
(
compilationInfo
.
source
(
)
)
;
compilationInfo
.
sourceObject
=
ScriptSourceObject
:
:
create
(
cx
compilationInfo
.
source
(
)
)
;
if
(
!
compilationInfo
.
sourceObject
)
{
return
false
;
}
if
(
!
cx
-
>
isHelperThreadContext
(
)
)
{
if
(
!
ScriptSourceObject
:
:
initFromOptions
(
cx
compilationInfo
.
sourceObject
compilationInfo
.
options
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
MaybeInstantiateModule
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
if
(
compilationInfo
.
topLevel
.
get
(
)
.
isModule
(
)
)
{
compilationInfo
.
module
=
ModuleObject
:
:
create
(
cx
)
;
if
(
!
compilationInfo
.
module
)
{
return
false
;
}
if
(
!
compilationInfo
.
moduleMetadata
.
get
(
)
.
initModule
(
cx
compilationInfo
.
module
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
InstantiateFunctions
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
for
(
auto
item
:
compilationInfo
.
functionScriptStencils
(
)
)
{
auto
&
stencil
=
item
.
stencil
;
auto
functionIndex
=
item
.
functionIndex
;
MOZ_ASSERT
(
!
item
.
function
)
;
RootedFunction
fun
(
cx
CreateFunction
(
cx
compilationInfo
stencil
functionIndex
)
)
;
if
(
!
fun
)
{
return
false
;
}
compilationInfo
.
functions
[
functionIndex
]
.
set
(
fun
)
;
}
return
true
;
}
static
bool
InstantiateScopes
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
if
(
!
compilationInfo
.
scopes
.
reserve
(
compilationInfo
.
scopeCreationData
.
length
(
)
)
)
{
return
false
;
}
for
(
auto
&
scd
:
compilationInfo
.
scopeCreationData
)
{
Scope
*
scope
=
scd
.
createScope
(
cx
compilationInfo
)
;
if
(
!
scope
)
{
return
false
;
}
compilationInfo
.
scopes
.
infallibleAppend
(
scope
)
;
}
return
true
;
}
static
bool
SetTypeForExposedFunctions
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
for
(
auto
item
:
compilationInfo
.
functionScriptStencils
(
)
)
{
auto
&
stencil
=
item
.
stencil
;
auto
&
fun
=
item
.
function
;
if
(
!
stencil
.
functionFlags
.
hasBaseScript
(
)
)
{
continue
;
}
if
(
!
stencil
.
wasFunctionEmitted
&
&
!
stencil
.
isStandaloneFunction
)
{
continue
;
}
if
(
!
JSFunction
:
:
setTypeForScriptedFunction
(
cx
fun
stencil
.
isSingletonFunction
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
InstantiateScriptStencils
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
for
(
auto
item
:
compilationInfo
.
functionScriptStencils
(
)
)
{
auto
&
stencil
=
item
.
stencil
;
auto
&
fun
=
item
.
function
;
if
(
stencil
.
immutableScriptData
)
{
if
(
!
stencil
.
wasFunctionEmitted
)
{
continue
;
}
RootedScript
script
(
cx
JSScript
:
:
fromStencil
(
cx
compilationInfo
stencil
fun
)
)
;
if
(
!
script
)
{
return
false
;
}
}
else
if
(
stencil
.
functionFlags
.
isAsmJSNative
(
)
)
{
MOZ_ASSERT
(
fun
-
>
isAsmJSNative
(
)
)
;
}
else
if
(
fun
-
>
isIncomplete
(
)
)
{
MOZ_ASSERT
(
compilationInfo
.
lazy
=
=
nullptr
)
;
if
(
!
CreateLazyScript
(
cx
compilationInfo
stencil
fun
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
InstantiateTopLevel
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
)
{
ScriptStencil
&
stencil
=
compilationInfo
.
topLevel
.
get
(
)
;
RootedFunction
fun
(
cx
)
;
if
(
stencil
.
isFunction
(
)
)
{
fun
=
compilationInfo
.
functions
[
CompilationInfo
:
:
TopLevelFunctionIndex
]
;
}
if
(
stencil
.
functionFlags
.
isAsmJSNative
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
stencil
.
immutableScriptData
)
;
if
(
compilationInfo
.
lazy
)
{
compilationInfo
.
script
=
JSScript
:
:
CastFromLazy
(
compilationInfo
.
lazy
)
;
return
JSScript
:
:
fullyInitFromStencil
(
cx
compilationInfo
compilationInfo
.
script
stencil
fun
)
;
}
compilationInfo
.
script
=
JSScript
:
:
fromStencil
(
cx
compilationInfo
stencil
fun
)
;
if
(
!
compilationInfo
.
script
)
{
return
false
;
}
if
(
stencil
.
isModule
(
)
)
{
compilationInfo
.
module
-
>
initScriptSlots
(
compilationInfo
.
script
)
;
compilationInfo
.
module
-
>
initStatusSlot
(
)
;
if
(
!
ModuleObject
:
:
createEnvironment
(
cx
compilationInfo
.
module
)
)
{
return
false
;
}
}
return
true
;
}
static
void
UpdateEmittedInnerFunctions
(
CompilationInfo
&
compilationInfo
)
{
for
(
auto
item
:
compilationInfo
.
functionScriptStencils
(
)
)
{
auto
&
stencil
=
item
.
stencil
;
auto
&
fun
=
item
.
function
;
if
(
!
stencil
.
wasFunctionEmitted
)
{
continue
;
}
if
(
stencil
.
functionFlags
.
isAsmJSNative
(
)
|
|
fun
-
>
baseScript
(
)
-
>
hasBytecode
(
)
)
{
MOZ_ASSERT
(
stencil
.
lazyFunctionEnclosingScopeIndex_
.
isNothing
(
)
)
;
}
else
{
BaseScript
*
script
=
fun
-
>
baseScript
(
)
;
ScopeIndex
index
=
*
stencil
.
lazyFunctionEnclosingScopeIndex_
;
Scope
*
scope
=
compilationInfo
.
scopes
[
index
]
.
get
(
)
;
script
-
>
setEnclosingScope
(
scope
)
;
script
-
>
initTreatAsRunOnce
(
stencil
.
immutableFlags
.
hasFlag
(
ImmutableScriptFlagsEnum
:
:
TreatAsRunOnce
)
)
;
if
(
stencil
.
fieldInitializers
)
{
script
-
>
setFieldInitializers
(
*
stencil
.
fieldInitializers
)
;
}
}
if
(
fun
-
>
displayAtom
(
)
=
=
nullptr
)
{
if
(
stencil
.
functionFlags
.
hasInferredName
(
)
)
{
fun
-
>
setInferredName
(
stencil
.
functionAtom
)
;
}
if
(
stencil
.
functionFlags
.
hasGuessedAtom
(
)
)
{
fun
-
>
setGuessedAtom
(
stencil
.
functionAtom
)
;
}
}
}
}
static
void
LinkEnclosingLazyScript
(
CompilationInfo
&
compilationInfo
)
{
for
(
auto
item
:
compilationInfo
.
functionScriptStencils
(
)
)
{
auto
&
stencil
=
item
.
stencil
;
auto
&
fun
=
item
.
function
;
if
(
!
stencil
.
functionFlags
.
hasBaseScript
(
)
)
{
continue
;
}
if
(
fun
-
>
baseScript
(
)
-
>
hasBytecode
(
)
)
{
continue
;
}
BaseScript
*
script
=
fun
-
>
baseScript
(
)
;
MOZ_ASSERT
(
!
script
-
>
hasBytecode
(
)
)
;
for
(
auto
inner
:
script
-
>
gcthings
(
)
)
{
if
(
!
inner
.
is
<
JSObject
>
(
)
)
{
continue
;
}
inner
.
as
<
JSObject
>
(
)
.
as
<
JSFunction
>
(
)
.
setEnclosingLazyScript
(
script
)
;
}
}
}
static
void
FunctionsFromExistingLazy
(
CompilationInfo
&
compilationInfo
)
{
MOZ_ASSERT
(
compilationInfo
.
lazy
)
;
size_t
idx
=
0
;
compilationInfo
.
functions
[
idx
+
+
]
.
set
(
compilationInfo
.
lazy
-
>
function
(
)
)
;
for
(
JS
:
:
GCCellPtr
elem
:
compilationInfo
.
lazy
-
>
gcthings
(
)
)
{
if
(
!
elem
.
is
<
JSObject
>
(
)
)
{
continue
;
}
compilationInfo
.
functions
[
idx
+
+
]
.
set
(
&
elem
.
as
<
JSObject
>
(
)
.
as
<
JSFunction
>
(
)
)
;
}
MOZ_ASSERT
(
idx
=
=
compilationInfo
.
functions
.
length
(
)
)
;
}
bool
CompilationInfo
:
:
instantiateStencils
(
)
{
if
(
!
functions
.
resize
(
funcData
.
length
(
)
)
)
{
return
false
;
}
if
(
lazy
)
{
FunctionsFromExistingLazy
(
*
this
)
;
}
else
{
if
(
!
InstantiateScriptSourceObject
(
cx
*
this
)
)
{
return
false
;
}
if
(
!
MaybeInstantiateModule
(
cx
*
this
)
)
{
return
false
;
}
if
(
!
InstantiateFunctions
(
cx
*
this
)
)
{
return
false
;
}
}
if
(
!
InstantiateScopes
(
cx
*
this
)
)
{
return
false
;
}
if
(
!
SetTypeForExposedFunctions
(
cx
*
this
)
)
{
return
false
;
}
if
(
!
InstantiateScriptStencils
(
cx
*
this
)
)
{
return
false
;
}
if
(
!
InstantiateTopLevel
(
cx
*
this
)
)
{
return
false
;
}
UpdateEmittedInnerFunctions
(
*
this
)
;
if
(
lazy
=
=
nullptr
)
{
LinkEnclosingLazyScript
(
*
this
)
;
}
return
true
;
}
