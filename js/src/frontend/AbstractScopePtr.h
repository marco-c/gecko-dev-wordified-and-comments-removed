#
ifndef
frontend_AbstractScopePtr_h
#
define
frontend_AbstractScopePtr_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
namespace
js
{
class
Scope
;
class
GlobalScope
;
class
EvalScope
;
struct
FieldInitializers
;
class
GCMarker
;
namespace
frontend
{
struct
CompilationInfo
;
class
ScopeCreationData
;
}
using
ScopeIndex
=
frontend
:
:
TypedIndex
<
Scope
>
;
using
HeapPtrScope
=
HeapPtr
<
Scope
*
>
;
class
AbstractScopePtr
{
public
:
struct
Deferred
{
ScopeIndex
index
;
frontend
:
:
CompilationInfo
&
compilationInfo
;
}
;
using
ScopeType
=
mozilla
:
:
Variant
<
HeapPtrScope
Deferred
>
;
private
:
ScopeType
scope_
=
ScopeType
(
HeapPtrScope
(
)
)
;
public
:
friend
class
js
:
:
Scope
;
AbstractScopePtr
(
)
=
default
;
explicit
AbstractScopePtr
(
Scope
*
scope
)
:
scope_
(
HeapPtrScope
(
scope
)
)
{
}
AbstractScopePtr
(
frontend
:
:
CompilationInfo
&
compilationInfo
ScopeIndex
scope
)
:
scope_
(
Deferred
{
scope
compilationInfo
}
)
{
}
bool
isNullptr
(
)
const
{
if
(
isScopeCreationData
(
)
)
{
return
false
;
}
return
scope_
.
as
<
HeapPtrScope
>
(
)
=
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
!
isNullptr
(
)
;
}
bool
isScopeCreationData
(
)
const
{
return
scope_
.
is
<
Deferred
>
(
)
;
}
MutableHandle
<
frontend
:
:
ScopeCreationData
>
scopeCreationData
(
)
const
;
frontend
:
:
CompilationInfo
&
compilationInfo
(
)
const
;
Scope
*
scope
(
)
const
{
return
scope_
.
as
<
HeapPtrScope
>
(
)
;
}
template
<
typename
T
>
bool
is
(
)
const
{
static_assert
(
std
:
:
is_base_of_v
<
Scope
T
>
"
Trying
to
ask
about
non
-
Scope
type
"
)
;
if
(
isNullptr
(
)
)
{
return
false
;
}
return
kind
(
)
=
=
T
:
:
classScopeKind_
;
}
ScopeKind
kind
(
)
const
;
AbstractScopePtr
enclosing
(
)
const
;
bool
hasEnvironment
(
)
const
;
uint32_t
nextFrameSlot
(
)
const
;
bool
isArrow
(
)
const
;
bool
hasOnChain
(
ScopeKind
kind
)
const
{
for
(
AbstractScopePtr
it
=
*
this
;
it
;
it
=
it
.
enclosing
(
)
)
{
if
(
it
.
kind
(
)
=
=
kind
)
{
return
true
;
}
}
return
false
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
inline
bool
AbstractScopePtr
:
:
is
<
GlobalScope
>
(
)
const
{
return
!
isNullptr
(
)
&
&
(
kind
(
)
=
=
ScopeKind
:
:
Global
|
|
kind
(
)
=
=
ScopeKind
:
:
NonSyntactic
)
;
}
template
<
>
inline
bool
AbstractScopePtr
:
:
is
<
EvalScope
>
(
)
const
{
return
!
isNullptr
(
)
&
&
(
kind
(
)
=
=
ScopeKind
:
:
Eval
|
|
kind
(
)
=
=
ScopeKind
:
:
StrictEval
)
;
}
class
AbstractScopePtrIter
{
AbstractScopePtr
scope_
;
public
:
explicit
AbstractScopePtrIter
(
const
AbstractScopePtr
&
f
)
:
scope_
(
f
)
{
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
bool
done
(
)
const
{
return
!
scope_
;
}
ScopeKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
scope_
)
;
return
scope_
.
kind
(
)
;
}
AbstractScopePtr
abstractScopePtr
(
)
const
{
return
scope_
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
scope_
=
scope_
.
enclosing
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
;
void
trace
(
JSTracer
*
trc
)
{
if
(
scope_
)
{
scope_
.
trace
(
trc
)
;
}
}
;
}
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
AbstractScopePtr
:
:
Deferred
>
:
JS
:
:
IgnoreGCPolicy
<
js
:
:
AbstractScopePtr
:
:
Deferred
>
{
}
;
}
#
endif
