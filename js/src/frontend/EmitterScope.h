#
ifndef
frontend_EmitterScope_h
#
define
frontend_EmitterScope_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ds
/
Nestable
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
#
include
"
frontend
/
UsingEmitter
.
h
"
#
endif
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
namespace
js
{
namespace
frontend
{
struct
BytecodeEmitter
;
class
EvalSharedContext
;
class
FunctionBox
;
class
GlobalSharedContext
;
class
ModuleSharedContext
;
class
TaggedParserAtomIndex
;
class
EmitterScope
:
public
Nestable
<
EmitterScope
>
{
PooledMapPtr
<
NameLocationMap
>
nameCache_
;
mozilla
:
:
Maybe
<
NameLocation
>
fallbackFreeNameLocation_
;
bool
hasEnvironment_
;
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
mozilla
:
:
Maybe
<
UsingEmitter
>
usingEmitter_
;
mozilla
:
:
Maybe
<
ForOfDisposalEmitter
>
forOfDisposalEmitter_
;
public
:
enum
class
BlockKind
:
uint8_t
{
Switch
ForOf
Other
}
;
private
:
BlockKind
blockKind_
=
BlockKind
:
:
Other
;
#
endif
uint8_t
environmentChainLength_
;
uint32_t
nextFrameSlot_
;
GCThingIndex
scopeIndex_
;
uint32_t
noteIndex_
;
[
[
nodiscard
]
]
bool
ensureCache
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
checkSlotLimits
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
;
[
[
nodiscard
]
]
bool
checkEnvironmentChainLength
(
BytecodeEmitter
*
bce
)
;
void
updateFrameFixedSlots
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
;
[
[
nodiscard
]
]
bool
putNameInCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
NameLocation
loc
)
;
mozilla
:
:
Maybe
<
NameLocation
>
lookupInCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
EmitterScope
*
enclosing
(
BytecodeEmitter
*
*
bce
)
const
;
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosingScopeIndex
(
BytecodeEmitter
*
bce
)
const
;
static
bool
nameCanBeFree
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
NameLocation
searchAndCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
internEmptyGlobalScopeAsBody
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
internScopeStencil
(
BytecodeEmitter
*
bce
ScopeIndex
index
)
;
[
[
nodiscard
]
]
bool
internBodyScopeStencil
(
BytecodeEmitter
*
bce
ScopeIndex
index
)
;
[
[
nodiscard
]
]
bool
appendScopeNote
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
clearFrameSlotRange
(
BytecodeEmitter
*
bce
JSOp
opcode
uint32_t
slotStart
uint32_t
slotEnd
)
const
;
[
[
nodiscard
]
]
bool
deadZoneFrameSlotRange
(
BytecodeEmitter
*
bce
uint32_t
slotStart
uint32_t
slotEnd
)
const
{
return
clearFrameSlotRange
(
bce
JSOp
:
:
Uninitialized
slotStart
slotEnd
)
;
}
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
void
setHasDisposables
(
BytecodeEmitter
*
bce
)
{
if
(
!
usingEmitter_
.
isSome
(
)
)
{
usingEmitter_
.
emplace
(
bce
)
;
}
}
#
endif
public
:
explicit
EmitterScope
(
BytecodeEmitter
*
bce
)
;
void
dump
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
enterLexical
(
BytecodeEmitter
*
bce
ScopeKind
kind
LexicalScope
:
:
ParserData
*
bindings
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
BlockKind
blockKind
=
BlockKind
:
:
Other
#
endif
)
;
[
[
nodiscard
]
]
bool
enterClassBody
(
BytecodeEmitter
*
bce
ScopeKind
kind
ClassBodyScope
:
:
ParserData
*
bindings
)
;
[
[
nodiscard
]
]
bool
enterNamedLambda
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterFunction
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterFunctionExtraBodyVar
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterGlobal
(
BytecodeEmitter
*
bce
GlobalSharedContext
*
globalsc
)
;
[
[
nodiscard
]
]
bool
enterEval
(
BytecodeEmitter
*
bce
EvalSharedContext
*
evalsc
)
;
[
[
nodiscard
]
]
bool
enterModule
(
BytecodeEmitter
*
module
ModuleSharedContext
*
modulesc
)
;
[
[
nodiscard
]
]
bool
enterWith
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
deadZoneFrameSlots
(
BytecodeEmitter
*
bce
)
const
;
[
[
nodiscard
]
]
bool
leave
(
BytecodeEmitter
*
bce
bool
nonLocal
=
false
)
;
GCThingIndex
index
(
)
const
{
MOZ_ASSERT
(
scopeIndex_
!
=
ScopeNote
:
:
NoScopeIndex
"
Did
you
forget
to
intern
a
Scope
?
"
)
;
return
scopeIndex_
;
}
uint32_t
noteIndex
(
)
const
{
return
noteIndex_
;
}
AbstractScopePtr
scope
(
const
BytecodeEmitter
*
bce
)
const
;
mozilla
:
:
Maybe
<
ScopeIndex
>
scopeIndex
(
const
BytecodeEmitter
*
bce
)
const
;
bool
hasEnvironment
(
)
const
{
return
hasEnvironment_
;
}
#
ifdef
ENABLE_EXPLICIT_RESOURCE_MANAGEMENT
private
:
[
[
nodiscard
]
]
bool
prepareForDisposableScopeBody
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
emitSwitchBlockEndForDisposableScopeBodyEnd
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
emitDisposableScopeBodyEnd
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
emitDisposableScopeBodyEndForNonLocalJump
(
BytecodeEmitter
*
bce
)
;
public
:
[
[
nodiscard
]
]
bool
prepareForModuleDisposableScopeBody
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
emitModuleDisposableScopeBodyEnd
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
prepareForDisposableAssignment
(
UsingHint
hint
)
;
[
[
nodiscard
]
]
bool
prepareForForOfLoopIteration
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
prepareForForOfIteratorCloseOnThrow
(
)
;
bool
hasDisposables
(
)
const
{
return
usingEmitter_
.
isSome
(
)
;
}
bool
hasAsyncDisposables
(
)
const
{
return
hasDisposables
(
)
&
&
usingEmitter_
-
>
hasAwaitUsing
(
)
;
}
#
endif
uint32_t
frameSlotStart
(
)
const
{
if
(
EmitterScope
*
inFrame
=
enclosingInFrame
(
)
)
{
return
inFrame
-
>
nextFrameSlot_
;
}
return
0
;
}
uint32_t
frameSlotEnd
(
)
const
{
return
nextFrameSlot_
;
}
EmitterScope
*
enclosingInFrame
(
)
const
{
return
Nestable
<
EmitterScope
>
:
:
enclosing
(
)
;
}
NameLocation
lookup
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
void
lookupPrivate
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
NameLocation
&
loc
mozilla
:
:
Maybe
<
NameLocation
>
&
brandLoc
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationBoundInScope
(
TaggedParserAtomIndex
name
EmitterScope
*
target
)
;
static
uint32_t
CountEnclosingCompilationEnvironments
(
BytecodeEmitter
*
bce
EmitterScope
*
emitterScope
)
;
}
;
}
}
#
endif
