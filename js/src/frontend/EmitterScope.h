#
ifndef
frontend_EmitterScope_h
#
define
frontend_EmitterScope_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ds
/
Nestable
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
namespace
js
{
class
Scope
;
namespace
frontend
{
struct
BytecodeEmitter
;
class
EmitterScope
:
public
Nestable
<
EmitterScope
>
{
PooledMapPtr
<
NameLocationMap
>
nameCache_
;
mozilla
:
:
Maybe
<
NameLocation
>
fallbackFreeNameLocation_
;
bool
hasEnvironment_
;
uint8_t
environmentChainLength_
;
uint32_t
nextFrameSlot_
;
GCThingIndex
scopeIndex_
;
uint32_t
noteIndex_
;
[
[
nodiscard
]
]
bool
ensureCache
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
checkSlotLimits
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
;
[
[
nodiscard
]
]
bool
checkEnvironmentChainLength
(
BytecodeEmitter
*
bce
)
;
void
updateFrameFixedSlots
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
;
[
[
nodiscard
]
]
bool
putNameInCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
NameLocation
loc
)
;
mozilla
:
:
Maybe
<
NameLocation
>
lookupInCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
EmitterScope
*
enclosing
(
BytecodeEmitter
*
*
bce
)
const
;
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosingScopeIndex
(
BytecodeEmitter
*
bce
)
const
;
static
bool
nameCanBeFree
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
NameLocation
searchAndCache
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
[
[
nodiscard
]
]
bool
internEmptyGlobalScopeAsBody
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
internScopeStencil
(
BytecodeEmitter
*
bce
ScopeIndex
index
)
;
[
[
nodiscard
]
]
bool
internBodyScopeStencil
(
BytecodeEmitter
*
bce
ScopeIndex
index
)
;
[
[
nodiscard
]
]
bool
appendScopeNote
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
clearFrameSlotRange
(
BytecodeEmitter
*
bce
JSOp
opcode
uint32_t
slotStart
uint32_t
slotEnd
)
const
;
[
[
nodiscard
]
]
bool
deadZoneFrameSlotRange
(
BytecodeEmitter
*
bce
uint32_t
slotStart
uint32_t
slotEnd
)
const
{
return
clearFrameSlotRange
(
bce
JSOp
:
:
Uninitialized
slotStart
slotEnd
)
;
}
public
:
explicit
EmitterScope
(
BytecodeEmitter
*
bce
)
;
void
dump
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
enterLexical
(
BytecodeEmitter
*
bce
ScopeKind
kind
LexicalScope
:
:
ParserData
*
bindings
)
;
[
[
nodiscard
]
]
bool
enterClassBody
(
BytecodeEmitter
*
bce
ScopeKind
kind
ClassBodyScope
:
:
ParserData
*
bindings
)
;
[
[
nodiscard
]
]
bool
enterNamedLambda
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterFunction
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterFunctionExtraBodyVar
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
;
[
[
nodiscard
]
]
bool
enterGlobal
(
BytecodeEmitter
*
bce
GlobalSharedContext
*
globalsc
)
;
[
[
nodiscard
]
]
bool
enterEval
(
BytecodeEmitter
*
bce
EvalSharedContext
*
evalsc
)
;
[
[
nodiscard
]
]
bool
enterModule
(
BytecodeEmitter
*
module
ModuleSharedContext
*
modulesc
)
;
[
[
nodiscard
]
]
bool
enterWith
(
BytecodeEmitter
*
bce
)
;
[
[
nodiscard
]
]
bool
deadZoneFrameSlots
(
BytecodeEmitter
*
bce
)
const
;
[
[
nodiscard
]
]
bool
leave
(
BytecodeEmitter
*
bce
bool
nonLocal
=
false
)
;
GCThingIndex
index
(
)
const
{
MOZ_ASSERT
(
scopeIndex_
!
=
ScopeNote
:
:
NoScopeIndex
"
Did
you
forget
to
intern
a
Scope
?
"
)
;
return
scopeIndex_
;
}
uint32_t
noteIndex
(
)
const
{
return
noteIndex_
;
}
AbstractScopePtr
scope
(
const
BytecodeEmitter
*
bce
)
const
;
mozilla
:
:
Maybe
<
ScopeIndex
>
scopeIndex
(
const
BytecodeEmitter
*
bce
)
const
;
bool
hasEnvironment
(
)
const
{
return
hasEnvironment_
;
}
uint32_t
frameSlotStart
(
)
const
{
if
(
EmitterScope
*
inFrame
=
enclosingInFrame
(
)
)
{
return
inFrame
-
>
nextFrameSlot_
;
}
return
0
;
}
uint32_t
frameSlotEnd
(
)
const
{
return
nextFrameSlot_
;
}
EmitterScope
*
enclosingInFrame
(
)
const
{
return
Nestable
<
EmitterScope
>
:
:
enclosing
(
)
;
}
NameLocation
lookup
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
)
;
mozilla
:
:
Maybe
<
NameLocation
>
locationBoundInScope
(
TaggedParserAtomIndex
name
EmitterScope
*
target
)
;
}
;
}
}
#
endif
