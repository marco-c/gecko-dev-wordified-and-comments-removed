#
include
"
frontend
/
EmitterScope
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
frontend
/
TDZCheckCache
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
EmitterScope
:
:
EmitterScope
(
BytecodeEmitter
*
bce
)
:
Nestable
<
EmitterScope
>
(
&
bce
-
>
innermostEmitterScope_
)
nameCache_
(
bce
-
>
cx
-
>
frontendCollectionPool
(
)
)
hasEnvironment_
(
false
)
environmentChainLength_
(
0
)
nextFrameSlot_
(
0
)
scopeIndex_
(
ScopeNote
:
:
NoScopeIndex
)
noteIndex_
(
ScopeNote
:
:
NoScopeNoteIndex
)
{
}
bool
EmitterScope
:
:
ensureCache
(
BytecodeEmitter
*
bce
)
{
return
nameCache_
.
acquire
(
bce
-
>
cx
)
;
}
bool
EmitterScope
:
:
checkSlotLimits
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
{
if
(
bi
.
nextFrameSlot
(
)
>
=
LOCALNO_LIMIT
|
|
bi
.
nextEnvironmentSlot
(
)
>
=
ENVCOORD_SLOT_LIMIT
)
{
bce
-
>
reportError
(
nullptr
JSMSG_TOO_MANY_LOCALS
)
;
return
false
;
}
return
true
;
}
bool
EmitterScope
:
:
checkEnvironmentChainLength
(
BytecodeEmitter
*
bce
)
{
uint32_t
hops
;
if
(
EmitterScope
*
emitterScope
=
enclosing
(
&
bce
)
)
{
hops
=
emitterScope
-
>
environmentChainLength_
;
}
else
{
hops
=
bce
-
>
compilationInfo
.
enclosingScope
-
>
environmentChainLength
(
)
;
}
if
(
hops
>
=
ENVCOORD_HOPS_LIMIT
-
1
)
{
bce
-
>
reportError
(
nullptr
JSMSG_TOO_DEEP
js_function_str
)
;
return
false
;
}
environmentChainLength_
=
mozilla
:
:
AssertedCast
<
uint8_t
>
(
hops
+
1
)
;
return
true
;
}
void
EmitterScope
:
:
updateFrameFixedSlots
(
BytecodeEmitter
*
bce
const
ParserBindingIter
&
bi
)
{
nextFrameSlot_
=
bi
.
nextFrameSlot
(
)
;
if
(
nextFrameSlot_
>
bce
-
>
maxFixedSlots
)
{
bce
-
>
maxFixedSlots
=
nextFrameSlot_
;
}
MOZ_ASSERT_IF
(
bce
-
>
sc
-
>
isFunctionBox
(
)
&
&
(
bce
-
>
sc
-
>
asFunctionBox
(
)
-
>
isGenerator
(
)
|
|
bce
-
>
sc
-
>
asFunctionBox
(
)
-
>
isAsync
(
)
)
bce
-
>
maxFixedSlots
=
=
0
)
;
}
bool
EmitterScope
:
:
putNameInCache
(
BytecodeEmitter
*
bce
const
ParserAtom
*
name
NameLocation
loc
)
{
NameLocationMap
&
cache
=
*
nameCache_
;
NameLocationMap
:
:
AddPtr
p
=
cache
.
lookupForAdd
(
name
)
;
MOZ_ASSERT
(
!
p
)
;
if
(
!
cache
.
add
(
p
name
loc
)
)
{
ReportOutOfMemory
(
bce
-
>
cx
)
;
return
false
;
}
return
true
;
}
Maybe
<
NameLocation
>
EmitterScope
:
:
lookupInCache
(
BytecodeEmitter
*
bce
const
ParserAtom
*
name
)
{
if
(
NameLocationMap
:
:
Ptr
p
=
nameCache_
-
>
lookup
(
name
)
)
{
return
Some
(
p
-
>
value
(
)
.
wrapped
)
;
}
if
(
fallbackFreeNameLocation_
&
&
nameCanBeFree
(
bce
name
)
)
{
return
fallbackFreeNameLocation_
;
}
return
Nothing
(
)
;
}
EmitterScope
*
EmitterScope
:
:
enclosing
(
BytecodeEmitter
*
*
bce
)
const
{
if
(
EmitterScope
*
inFrame
=
enclosingInFrame
(
)
)
{
return
inFrame
;
}
if
(
(
*
bce
)
-
>
parent
)
{
*
bce
=
(
*
bce
)
-
>
parent
;
return
(
*
bce
)
-
>
innermostEmitterScopeNoCheck
(
)
;
}
return
nullptr
;
}
mozilla
:
:
Maybe
<
ScopeIndex
>
EmitterScope
:
:
enclosingScopeIndex
(
BytecodeEmitter
*
bce
)
const
{
if
(
EmitterScope
*
es
=
enclosing
(
&
bce
)
)
{
MOZ_ASSERT_IF
(
es
-
>
scopeIndex
(
bce
)
.
isNothing
(
)
bce
-
>
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
;
return
es
-
>
scopeIndex
(
bce
)
;
}
return
mozilla
:
:
Nothing
(
)
;
}
bool
EmitterScope
:
:
nameCanBeFree
(
BytecodeEmitter
*
bce
const
ParserAtom
*
name
)
{
return
name
!
=
bce
-
>
cx
-
>
parserNames
(
)
.
dotGenerator
;
}
#
ifdef
DEBUG
static
bool
NameIsOnEnvironment
(
Scope
*
scope
JSAtom
*
name
)
{
for
(
BindingIter
bi
(
scope
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
=
=
name
)
{
BindingLocation
:
:
Kind
kind
=
bi
.
location
(
)
.
kind
(
)
;
if
(
bi
.
hasArgumentSlot
(
)
)
{
JSScript
*
script
=
scope
-
>
as
<
FunctionScope
>
(
)
.
script
(
)
;
if
(
script
-
>
functionAllowsParameterRedeclaration
(
)
)
{
for
(
BindingIter
bi2
(
bi
)
;
bi2
&
&
bi2
.
hasArgumentSlot
(
)
;
bi2
+
+
)
{
if
(
bi2
.
name
(
)
=
=
name
)
{
kind
=
bi2
.
location
(
)
.
kind
(
)
;
}
}
}
}
return
kind
=
=
BindingLocation
:
:
Kind
:
:
Global
|
|
kind
=
=
BindingLocation
:
:
Kind
:
:
Environment
|
|
kind
=
=
BindingLocation
:
:
Kind
:
:
Import
;
}
}
return
true
;
}
#
endif
NameLocation
EmitterScope
:
:
searchInEnclosingScope
(
JSAtom
*
name
Scope
*
scope
uint8_t
hops
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
MOZ_ASSERT
(
NameIsOnEnvironment
(
si
.
scope
(
)
name
)
)
;
bool
hasEnv
=
si
.
hasSyntacticEnvironment
(
)
;
switch
(
si
.
kind
(
)
)
{
case
ScopeKind
:
:
Function
:
if
(
hasEnv
)
{
JSScript
*
script
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
script
(
)
;
if
(
script
-
>
funHasExtensibleScope
(
)
)
{
return
NameLocation
:
:
Dynamic
(
)
;
}
for
(
BindingIter
bi
(
si
.
scope
(
)
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
!
=
name
)
{
continue
;
}
BindingLocation
bindLoc
=
bi
.
location
(
)
;
if
(
bi
.
hasArgumentSlot
(
)
&
&
script
-
>
functionAllowsParameterRedeclaration
(
)
)
{
for
(
BindingIter
bi2
(
bi
)
;
bi2
&
&
bi2
.
hasArgumentSlot
(
)
;
bi2
+
+
)
{
if
(
bi2
.
name
(
)
=
=
name
)
{
bindLoc
=
bi2
.
location
(
)
;
}
}
}
MOZ_ASSERT
(
bindLoc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Environment
)
;
return
NameLocation
:
:
EnvironmentCoordinate
(
bi
.
kind
(
)
hops
bindLoc
.
slot
(
)
)
;
}
}
break
;
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
if
(
hasEnv
)
{
for
(
BindingIter
bi
(
si
.
scope
(
)
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
!
=
name
)
{
continue
;
}
BindingLocation
bindLoc
=
bi
.
location
(
)
;
MOZ_ASSERT
(
bindLoc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Environment
)
;
return
NameLocation
:
:
EnvironmentCoordinate
(
bi
.
kind
(
)
hops
bindLoc
.
slot
(
)
)
;
}
}
break
;
case
ScopeKind
:
:
Module
:
if
(
hasEnv
)
{
for
(
BindingIter
bi
(
si
.
scope
(
)
)
;
bi
;
bi
+
+
)
{
if
(
bi
.
name
(
)
!
=
name
)
{
continue
;
}
BindingLocation
bindLoc
=
bi
.
location
(
)
;
if
(
bindLoc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Import
)
{
MOZ_ASSERT
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
;
return
NameLocation
:
:
Import
(
)
;
}
MOZ_ASSERT
(
bindLoc
.
kind
(
)
=
=
BindingLocation
:
:
Kind
:
:
Environment
)
;
return
NameLocation
:
:
EnvironmentCoordinate
(
bi
.
kind
(
)
hops
bindLoc
.
slot
(
)
)
;
}
}
break
;
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
if
(
!
hasEnv
&
&
si
.
scope
(
)
-
>
enclosing
(
)
-
>
is
<
GlobalScope
>
(
)
)
{
return
NameLocation
:
:
Global
(
BindingKind
:
:
Var
)
;
}
return
NameLocation
:
:
Dynamic
(
)
;
case
ScopeKind
:
:
Global
:
return
NameLocation
:
:
Global
(
BindingKind
:
:
Var
)
;
case
ScopeKind
:
:
With
:
case
ScopeKind
:
:
NonSyntactic
:
return
NameLocation
:
:
Dynamic
(
)
;
case
ScopeKind
:
:
WasmInstance
:
case
ScopeKind
:
:
WasmFunction
:
MOZ_CRASH
(
"
No
direct
eval
inside
wasm
functions
"
)
;
}
if
(
hasEnv
)
{
MOZ_ASSERT
(
hops
<
ENVCOORD_HOPS_LIMIT
-
1
)
;
hops
+
+
;
}
}
MOZ_CRASH
(
"
Malformed
scope
chain
"
)
;
}
NameLocation
EmitterScope
:
:
searchAndCache
(
BytecodeEmitter
*
bce
const
ParserAtom
*
name
)
{
Maybe
<
NameLocation
>
loc
;
uint8_t
hops
=
hasEnvironment
(
)
?
1
:
0
;
DebugOnly
<
bool
>
inCurrentScript
=
enclosingInFrame
(
)
;
for
(
EmitterScope
*
es
=
enclosing
(
&
bce
)
;
es
;
es
=
es
-
>
enclosing
(
&
bce
)
)
{
loc
=
es
-
>
lookupInCache
(
bce
name
)
;
if
(
loc
)
{
if
(
loc
-
>
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
EnvironmentCoordinate
)
{
*
loc
=
loc
-
>
addHops
(
hops
)
;
}
break
;
}
if
(
es
-
>
hasEnvironment
(
)
)
{
hops
+
+
;
}
#
ifdef
DEBUG
if
(
!
es
-
>
enclosingInFrame
(
)
)
{
inCurrentScript
=
false
;
}
#
endif
}
if
(
!
loc
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
JSAtom
*
jsname
=
bce
-
>
compilationInfo
.
liftParserAtomToJSAtom
(
name
)
;
if
(
!
jsname
)
{
oomUnsafe
.
crash
(
"
EmitterScope
:
:
searchAndCache
"
)
;
}
inCurrentScript
=
false
;
loc
=
Some
(
searchInEnclosingScope
(
jsname
bce
-
>
compilationInfo
.
enclosingScope
hops
)
)
;
}
MOZ_ASSERT_IF
(
!
inCurrentScript
loc
-
>
kind
(
)
!
=
NameLocation
:
:
Kind
:
:
FrameSlot
)
;
if
(
!
putNameInCache
(
bce
name
*
loc
)
)
{
bce
-
>
cx
-
>
recoverFromOutOfMemory
(
)
;
}
return
*
loc
;
}
bool
EmitterScope
:
:
internEmptyGlobalScopeAsBody
(
BytecodeEmitter
*
bce
)
{
MOZ_ASSERT
(
bce
-
>
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
;
Scope
*
scope
=
&
bce
-
>
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
;
hasEnvironment_
=
scope
-
>
hasEnvironment
(
)
;
bce
-
>
bodyScopeIndex
=
GCThingIndex
(
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
)
;
return
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
appendEmptyGlobalScope
(
&
scopeIndex_
)
;
}
template
<
typename
ScopeCreator
>
bool
EmitterScope
:
:
internScopeCreationData
(
BytecodeEmitter
*
bce
ScopeCreator
createScope
)
{
ScopeIndex
index
;
if
(
!
createScope
(
bce
-
>
cx
enclosingScopeIndex
(
bce
)
&
index
)
)
{
return
false
;
}
ScopeStencil
&
scope
=
bce
-
>
compilationInfo
.
scopeData
[
index
.
index
]
;
hasEnvironment_
=
scope
.
hasEnvironment
(
)
;
return
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
append
(
index
&
scopeIndex_
)
;
}
template
<
typename
ScopeCreator
>
bool
EmitterScope
:
:
internBodyScopeCreationData
(
BytecodeEmitter
*
bce
ScopeCreator
createScope
)
{
MOZ_ASSERT
(
bce
-
>
bodyScopeIndex
=
=
ScopeNote
:
:
NoScopeIndex
"
There
can
be
only
one
body
scope
"
)
;
bce
-
>
bodyScopeIndex
=
GCThingIndex
(
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
)
;
return
internScopeCreationData
(
bce
createScope
)
;
}
bool
EmitterScope
:
:
appendScopeNote
(
BytecodeEmitter
*
bce
)
{
MOZ_ASSERT
(
ScopeKindIsInBody
(
scope
(
bce
)
.
kind
(
)
)
&
&
enclosingInFrame
(
)
"
Scope
notes
are
not
needed
for
body
-
level
scopes
.
"
)
;
noteIndex_
=
bce
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
length
(
)
;
return
bce
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
append
(
index
(
)
bce
-
>
bytecodeSection
(
)
.
offset
(
)
enclosingInFrame
(
)
?
enclosingInFrame
(
)
-
>
noteIndex
(
)
:
ScopeNote
:
:
NoScopeNoteIndex
)
;
}
bool
EmitterScope
:
:
deadZoneFrameSlotRange
(
BytecodeEmitter
*
bce
uint32_t
slotStart
uint32_t
slotEnd
)
const
{
if
(
slotStart
!
=
slotEnd
)
{
if
(
!
bce
-
>
emit1
(
JSOp
:
:
Uninitialized
)
)
{
return
false
;
}
for
(
uint32_t
slot
=
slotStart
;
slot
<
slotEnd
;
slot
+
+
)
{
if
(
!
bce
-
>
emitLocalOp
(
JSOp
:
:
InitLexical
slot
)
)
{
return
false
;
}
}
if
(
!
bce
-
>
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
true
;
}
void
EmitterScope
:
:
dump
(
BytecodeEmitter
*
bce
)
{
fprintf
(
stdout
"
EmitterScope
[
%
s
]
%
p
\
n
"
ScopeKindString
(
scope
(
bce
)
.
kind
(
)
)
this
)
;
for
(
NameLocationMap
:
:
Range
r
=
nameCache_
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
NameLocation
&
l
=
r
.
front
(
)
.
value
(
)
;
UniqueChars
bytes
=
ParserAtomToPrintableString
(
bce
-
>
cx
r
.
front
(
)
.
key
(
)
)
;
if
(
!
bytes
)
{
return
;
}
if
(
l
.
kind
(
)
!
=
NameLocation
:
:
Kind
:
:
Dynamic
)
{
fprintf
(
stdout
"
%
s
%
s
"
BindingKindString
(
l
.
bindingKind
(
)
)
bytes
.
get
(
)
)
;
}
else
{
fprintf
(
stdout
"
%
s
"
bytes
.
get
(
)
)
;
}
switch
(
l
.
kind
(
)
)
{
case
NameLocation
:
:
Kind
:
:
Dynamic
:
fprintf
(
stdout
"
dynamic
\
n
"
)
;
break
;
case
NameLocation
:
:
Kind
:
:
Global
:
fprintf
(
stdout
"
global
\
n
"
)
;
break
;
case
NameLocation
:
:
Kind
:
:
Intrinsic
:
fprintf
(
stdout
"
intrinsic
\
n
"
)
;
break
;
case
NameLocation
:
:
Kind
:
:
NamedLambdaCallee
:
fprintf
(
stdout
"
named
lambda
callee
\
n
"
)
;
break
;
case
NameLocation
:
:
Kind
:
:
Import
:
fprintf
(
stdout
"
import
\
n
"
)
;
break
;
case
NameLocation
:
:
Kind
:
:
ArgumentSlot
:
fprintf
(
stdout
"
arg
slot
=
%
u
\
n
"
l
.
argumentSlot
(
)
)
;
break
;
case
NameLocation
:
:
Kind
:
:
FrameSlot
:
fprintf
(
stdout
"
frame
slot
=
%
u
\
n
"
l
.
frameSlot
(
)
)
;
break
;
case
NameLocation
:
:
Kind
:
:
EnvironmentCoordinate
:
fprintf
(
stdout
"
environment
hops
=
%
u
slot
=
%
u
\
n
"
l
.
environmentCoordinate
(
)
.
hops
(
)
l
.
environmentCoordinate
(
)
.
slot
(
)
)
;
break
;
case
NameLocation
:
:
Kind
:
:
DynamicAnnexBVar
:
fprintf
(
stdout
"
dynamic
annex
b
var
\
n
"
)
;
break
;
}
}
fprintf
(
stdout
"
\
n
"
)
;
}
bool
EmitterScope
:
:
enterLexical
(
BytecodeEmitter
*
bce
ScopeKind
kind
ParserLexicalScopeData
*
bindings
)
{
MOZ_ASSERT
(
kind
!
=
ScopeKind
:
:
NamedLambda
&
&
kind
!
=
ScopeKind
:
:
StrictNamedLambda
)
;
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
TDZCheckCache
*
tdzCache
=
bce
-
>
innermostTDZCheckCache
;
uint32_t
firstFrameSlot
=
frameSlotStart
(
)
;
ParserBindingIter
bi
(
*
bindings
firstFrameSlot
false
)
;
for
(
;
bi
;
bi
+
+
)
{
if
(
!
checkSlotLimits
(
bce
bi
)
)
{
return
false
;
}
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
if
(
!
putNameInCache
(
bce
bi
.
name
(
)
loc
)
)
{
return
false
;
}
if
(
!
tdzCache
-
>
noteTDZCheck
(
bce
bi
.
name
(
)
CheckTDZ
)
)
{
return
false
;
}
}
updateFrameFixedSlots
(
bce
bi
)
;
auto
createScope
=
[
kind
bindings
firstFrameSlot
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForLexicalScope
(
cx
bce
-
>
compilationInfo
kind
bindings
firstFrameSlot
enclosing
index
)
;
}
;
if
(
!
internScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
if
(
ScopeKindIsInBody
(
kind
)
&
&
hasEnvironment
(
)
)
{
if
(
!
bce
-
>
emitInternedScopeOp
(
index
(
)
JSOp
:
:
PushLexicalEnv
)
)
{
return
false
;
}
}
if
(
!
appendScopeNote
(
bce
)
)
{
return
false
;
}
if
(
!
deadZoneFrameSlotRange
(
bce
firstFrameSlot
frameSlotEnd
(
)
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
bool
EmitterScope
:
:
enterNamedLambda
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
MOZ_ASSERT
(
funbox
-
>
namedLambdaBindings
(
)
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
ParserBindingIter
bi
(
*
funbox
-
>
namedLambdaBindings
(
)
LOCALNO_LIMIT
true
)
;
MOZ_ASSERT
(
bi
.
kind
(
)
=
=
BindingKind
:
:
NamedLambdaCallee
)
;
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
if
(
!
putNameInCache
(
bce
bi
.
name
(
)
loc
)
)
{
return
false
;
}
bi
+
+
;
MOZ_ASSERT
(
!
bi
"
There
should
be
exactly
one
binding
in
a
NamedLambda
scope
"
)
;
ScopeKind
scopeKind
=
funbox
-
>
strict
(
)
?
ScopeKind
:
:
StrictNamedLambda
:
ScopeKind
:
:
NamedLambda
;
auto
createScope
=
[
funbox
scopeKind
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForLexicalScope
(
cx
bce
-
>
compilationInfo
scopeKind
funbox
-
>
namedLambdaBindings
(
)
LOCALNO_LIMIT
enclosing
index
)
;
}
;
if
(
!
internScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
bool
EmitterScope
:
:
enterFunction
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
if
(
!
funbox
-
>
functionHasExtraBodyVarScope
(
)
)
{
bce
-
>
setVarEmitterScope
(
this
)
;
}
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
auto
bindings
=
funbox
-
>
functionScopeBindings
(
)
;
if
(
bindings
)
{
NameLocationMap
&
cache
=
*
nameCache_
;
ParserBindingIter
bi
(
*
bindings
funbox
-
>
hasParameterExprs
)
;
for
(
;
bi
;
bi
+
+
)
{
if
(
!
checkSlotLimits
(
bce
bi
)
)
{
return
false
;
}
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
NameLocationMap
:
:
AddPtr
p
=
cache
.
lookupForAdd
(
bi
.
name
(
)
)
;
if
(
p
)
{
MOZ_ASSERT
(
bi
.
kind
(
)
=
=
BindingKind
:
:
FormalParameter
)
;
MOZ_ASSERT
(
!
funbox
-
>
hasDestructuringArgs
)
;
MOZ_ASSERT
(
!
funbox
-
>
hasRest
(
)
)
;
p
-
>
value
(
)
=
loc
;
continue
;
}
if
(
!
cache
.
add
(
p
bi
.
name
(
)
loc
)
)
{
ReportOutOfMemory
(
bce
-
>
cx
)
;
return
false
;
}
}
updateFrameFixedSlots
(
bce
bi
)
;
}
else
{
nextFrameSlot_
=
0
;
}
if
(
funbox
-
>
funHasExtensibleScope
(
)
)
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Dynamic
(
)
)
;
}
if
(
funbox
-
>
hasParameterExprs
&
&
nextFrameSlot_
)
{
uint32_t
paramFrameSlotEnd
=
0
;
for
(
ParserBindingIter
bi
(
*
bindings
true
)
;
bi
;
bi
+
+
)
{
if
(
!
BindingKindIsLexical
(
bi
.
kind
(
)
)
)
{
break
;
}
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
)
{
MOZ_ASSERT
(
paramFrameSlotEnd
<
=
loc
.
frameSlot
(
)
)
;
paramFrameSlotEnd
=
loc
.
frameSlot
(
)
+
1
;
}
}
if
(
!
deadZoneFrameSlotRange
(
bce
0
paramFrameSlotEnd
)
)
{
return
false
;
}
}
auto
createScope
=
[
funbox
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForFunctionScope
(
cx
bce
-
>
compilationInfo
funbox
-
>
functionScopeBindings
(
)
funbox
-
>
hasParameterExprs
funbox
-
>
needsCallObjectRegardlessOfBindings
(
)
funbox
-
>
index
(
)
funbox
-
>
isArrow
(
)
enclosing
index
)
;
}
;
if
(
!
internBodyScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
bool
EmitterScope
:
:
enterFunctionExtraBodyVar
(
BytecodeEmitter
*
bce
FunctionBox
*
funbox
)
{
MOZ_ASSERT
(
funbox
-
>
hasParameterExprs
)
;
MOZ_ASSERT
(
funbox
-
>
extraVarScopeBindings
(
)
|
|
funbox
-
>
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
)
;
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
bce
-
>
setVarEmitterScope
(
this
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
uint32_t
firstFrameSlot
=
frameSlotStart
(
)
;
if
(
auto
bindings
=
funbox
-
>
extraVarScopeBindings
(
)
)
{
ParserBindingIter
bi
(
*
bindings
firstFrameSlot
)
;
for
(
;
bi
;
bi
+
+
)
{
if
(
!
checkSlotLimits
(
bce
bi
)
)
{
return
false
;
}
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
if
(
!
putNameInCache
(
bce
bi
.
name
(
)
loc
)
)
{
return
false
;
}
}
updateFrameFixedSlots
(
bce
bi
)
;
}
else
{
nextFrameSlot_
=
firstFrameSlot
;
}
if
(
funbox
-
>
funHasExtensibleScope
(
)
)
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Dynamic
(
)
)
;
}
auto
createScope
=
[
funbox
firstFrameSlot
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForVarScope
(
cx
bce
-
>
compilationInfo
ScopeKind
:
:
FunctionBodyVar
funbox
-
>
extraVarScopeBindings
(
)
firstFrameSlot
funbox
-
>
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
enclosing
index
)
;
}
;
if
(
!
internScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
if
(
hasEnvironment
(
)
)
{
if
(
!
bce
-
>
emitInternedScopeOp
(
index
(
)
JSOp
:
:
PushVarEnv
)
)
{
return
false
;
}
}
if
(
!
appendScopeNote
(
bce
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
class
DynamicBindingIter
:
public
ParserBindingIter
{
public
:
explicit
DynamicBindingIter
(
GlobalSharedContext
*
sc
)
:
ParserBindingIter
(
*
sc
-
>
bindings
)
{
}
explicit
DynamicBindingIter
(
EvalSharedContext
*
sc
)
:
ParserBindingIter
(
*
sc
-
>
bindings
false
)
{
MOZ_ASSERT
(
!
sc
-
>
strict
(
)
)
;
}
JSOp
bindingOp
(
)
const
{
switch
(
kind
(
)
)
{
case
BindingKind
:
:
Var
:
return
JSOp
:
:
DefVar
;
case
BindingKind
:
:
Let
:
return
JSOp
:
:
DefLet
;
case
BindingKind
:
:
Const
:
return
JSOp
:
:
DefConst
;
default
:
MOZ_CRASH
(
"
Bad
BindingKind
"
)
;
}
}
}
;
bool
EmitterScope
:
:
enterGlobal
(
BytecodeEmitter
*
bce
GlobalSharedContext
*
globalsc
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
bce
-
>
setVarEmitterScope
(
this
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
if
(
bce
-
>
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Intrinsic
(
)
)
;
return
internEmptyGlobalScopeAsBody
(
bce
)
;
}
auto
createScope
=
[
globalsc
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
MOZ_ASSERT
(
enclosing
.
isNothing
(
)
)
;
return
ScopeStencil
:
:
createForGlobalScope
(
cx
bce
-
>
compilationInfo
globalsc
-
>
scopeKind
(
)
globalsc
-
>
bindings
index
)
;
}
;
if
(
!
internBodyScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
MOZ_ASSERT
(
bce
-
>
bodyScopeIndex
=
=
GCThingIndex
:
:
outermostScopeIndex
(
)
"
Global
scope
must
be
index
0
"
)
;
if
(
globalsc
-
>
bindings
)
{
if
(
!
bce
-
>
emit1
(
JSOp
:
:
CheckGlobalOrEvalDecl
)
)
{
return
false
;
}
for
(
DynamicBindingIter
bi
(
globalsc
)
;
bi
;
bi
+
+
)
{
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
const
ParserAtom
*
name
=
bi
.
name
(
)
;
if
(
!
putNameInCache
(
bce
name
loc
)
)
{
return
false
;
}
if
(
bi
.
isTopLevelFunction
(
)
)
{
continue
;
}
if
(
!
bce
-
>
emitAtomOp
(
bi
.
bindingOp
(
)
name
)
)
{
return
false
;
}
}
}
if
(
globalsc
-
>
scopeKind
(
)
=
=
ScopeKind
:
:
Global
)
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Global
(
BindingKind
:
:
Var
)
)
;
}
else
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Dynamic
(
)
)
;
}
return
true
;
}
bool
EmitterScope
:
:
enterEval
(
BytecodeEmitter
*
bce
EvalSharedContext
*
evalsc
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
bce
-
>
setVarEmitterScope
(
this
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Dynamic
(
)
)
;
auto
createScope
=
[
evalsc
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
ScopeKind
scopeKind
=
evalsc
-
>
strict
(
)
?
ScopeKind
:
:
StrictEval
:
ScopeKind
:
:
Eval
;
return
ScopeStencil
:
:
createForEvalScope
(
cx
bce
-
>
compilationInfo
scopeKind
evalsc
-
>
bindings
enclosing
index
)
;
}
;
if
(
!
internBodyScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
if
(
hasEnvironment
(
)
)
{
if
(
!
bce
-
>
emitInternedScopeOp
(
index
(
)
JSOp
:
:
PushVarEnv
)
)
{
return
false
;
}
}
else
{
if
(
!
hasEnvironment
(
)
&
&
evalsc
-
>
bindings
)
{
if
(
!
bce
-
>
emit1
(
JSOp
:
:
CheckGlobalOrEvalDecl
)
)
{
return
false
;
}
for
(
DynamicBindingIter
bi
(
evalsc
)
;
bi
;
bi
+
+
)
{
MOZ_ASSERT
(
bi
.
bindingOp
(
)
=
=
JSOp
:
:
DefVar
)
;
if
(
bi
.
isTopLevelFunction
(
)
)
{
continue
;
}
if
(
!
bce
-
>
emitAtomOp
(
JSOp
:
:
DefVar
bi
.
name
(
)
)
)
{
return
false
;
}
}
}
if
(
scope
(
bce
)
.
enclosing
(
)
.
is
<
GlobalScope
>
(
)
)
{
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Global
(
BindingKind
:
:
Var
)
)
;
}
}
return
true
;
}
bool
EmitterScope
:
:
enterModule
(
BytecodeEmitter
*
bce
ModuleSharedContext
*
modulesc
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
bce
-
>
setVarEmitterScope
(
this
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
TDZCheckCache
*
tdzCache
=
bce
-
>
innermostTDZCheckCache
;
Maybe
<
uint32_t
>
firstLexicalFrameSlot
;
if
(
ParserModuleScopeData
*
bindings
=
modulesc
-
>
bindings
)
{
ParserBindingIter
bi
(
*
bindings
)
;
for
(
;
bi
;
bi
+
+
)
{
if
(
!
checkSlotLimits
(
bce
bi
)
)
{
return
false
;
}
NameLocation
loc
=
NameLocation
:
:
fromBinding
(
bi
.
kind
(
)
bi
.
location
(
)
)
;
if
(
!
putNameInCache
(
bce
bi
.
name
(
)
loc
)
)
{
return
false
;
}
if
(
BindingKindIsLexical
(
bi
.
kind
(
)
)
)
{
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
&
&
!
firstLexicalFrameSlot
)
{
firstLexicalFrameSlot
=
Some
(
loc
.
frameSlot
(
)
)
;
}
if
(
!
tdzCache
-
>
noteTDZCheck
(
bce
bi
.
name
(
)
CheckTDZ
)
)
{
return
false
;
}
}
}
updateFrameFixedSlots
(
bce
bi
)
;
}
else
{
nextFrameSlot_
=
0
;
}
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Global
(
BindingKind
:
:
Var
)
)
;
if
(
firstLexicalFrameSlot
)
{
if
(
!
deadZoneFrameSlotRange
(
bce
*
firstLexicalFrameSlot
frameSlotEnd
(
)
)
)
{
return
false
;
}
}
auto
createScope
=
[
modulesc
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForModuleScope
(
cx
bce
-
>
compilationInfo
modulesc
-
>
bindings
enclosing
index
)
;
}
;
if
(
!
internBodyScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
bool
EmitterScope
:
:
enterWith
(
BytecodeEmitter
*
bce
)
{
MOZ_ASSERT
(
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
if
(
!
ensureCache
(
bce
)
)
{
return
false
;
}
fallbackFreeNameLocation_
=
Some
(
NameLocation
:
:
Dynamic
(
)
)
;
auto
createScope
=
[
bce
]
(
JSContext
*
cx
mozilla
:
:
Maybe
<
ScopeIndex
>
enclosing
ScopeIndex
*
index
)
{
return
ScopeStencil
:
:
createForWithScope
(
cx
bce
-
>
compilationInfo
enclosing
index
)
;
}
;
if
(
!
internScopeCreationData
(
bce
createScope
)
)
{
return
false
;
}
if
(
!
bce
-
>
emitInternedScopeOp
(
index
(
)
JSOp
:
:
EnterWith
)
)
{
return
false
;
}
if
(
!
appendScopeNote
(
bce
)
)
{
return
false
;
}
return
checkEnvironmentChainLength
(
bce
)
;
}
bool
EmitterScope
:
:
deadZoneFrameSlots
(
BytecodeEmitter
*
bce
)
const
{
return
deadZoneFrameSlotRange
(
bce
frameSlotStart
(
)
frameSlotEnd
(
)
)
;
}
bool
EmitterScope
:
:
leave
(
BytecodeEmitter
*
bce
bool
nonLocal
)
{
MOZ_ASSERT_IF
(
!
nonLocal
this
=
=
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
;
ScopeKind
kind
=
scope
(
bce
)
.
kind
(
)
;
switch
(
kind
)
{
case
ScopeKind
:
:
Lexical
:
case
ScopeKind
:
:
SimpleCatch
:
case
ScopeKind
:
:
Catch
:
case
ScopeKind
:
:
FunctionLexical
:
case
ScopeKind
:
:
ClassBody
:
if
(
!
bce
-
>
emit1
(
hasEnvironment
(
)
?
JSOp
:
:
PopLexicalEnv
:
JSOp
:
:
DebugLeaveLexicalEnv
)
)
{
return
false
;
}
break
;
case
ScopeKind
:
:
With
:
if
(
!
bce
-
>
emit1
(
JSOp
:
:
LeaveWith
)
)
{
return
false
;
}
break
;
case
ScopeKind
:
:
Function
:
case
ScopeKind
:
:
FunctionBodyVar
:
case
ScopeKind
:
:
NamedLambda
:
case
ScopeKind
:
:
StrictNamedLambda
:
case
ScopeKind
:
:
Eval
:
case
ScopeKind
:
:
StrictEval
:
case
ScopeKind
:
:
Global
:
case
ScopeKind
:
:
NonSyntactic
:
case
ScopeKind
:
:
Module
:
break
;
case
ScopeKind
:
:
WasmInstance
:
case
ScopeKind
:
:
WasmFunction
:
MOZ_CRASH
(
"
No
wasm
function
scopes
in
JS
"
)
;
}
if
(
!
nonLocal
)
{
if
(
ScopeKindIsInBody
(
kind
)
)
{
if
(
kind
=
=
ScopeKind
:
:
FunctionBodyVar
)
{
bce
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
recordEndFunctionBodyVar
(
noteIndex_
)
;
}
else
{
bce
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
recordEnd
(
noteIndex_
bce
-
>
bytecodeSection
(
)
.
offset
(
)
)
;
}
}
}
return
true
;
}
AbstractScopePtr
EmitterScope
:
:
scope
(
const
BytecodeEmitter
*
bce
)
const
{
return
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
getScope
(
index
(
)
)
;
}
mozilla
:
:
Maybe
<
ScopeIndex
>
EmitterScope
:
:
scopeIndex
(
const
BytecodeEmitter
*
bce
)
const
{
return
bce
-
>
perScriptData
(
)
.
gcThingList
(
)
.
getScopeIndex
(
index
(
)
)
;
}
NameLocation
EmitterScope
:
:
lookup
(
BytecodeEmitter
*
bce
const
ParserAtom
*
name
)
{
if
(
Maybe
<
NameLocation
>
loc
=
lookupInCache
(
bce
name
)
)
{
return
*
loc
;
}
return
searchAndCache
(
bce
name
)
;
}
Maybe
<
NameLocation
>
EmitterScope
:
:
locationBoundInScope
(
const
ParserAtom
*
name
EmitterScope
*
target
)
{
uint8_t
extraHops
=
0
;
for
(
EmitterScope
*
es
=
this
;
es
!
=
target
;
es
=
es
-
>
enclosingInFrame
(
)
)
{
if
(
es
-
>
hasEnvironment
(
)
)
{
extraHops
+
+
;
}
}
Maybe
<
NameLocation
>
loc
;
if
(
NameLocationMap
:
:
Ptr
p
=
target
-
>
nameCache_
-
>
lookup
(
name
)
)
{
NameLocation
l
=
p
-
>
value
(
)
.
wrapped
;
if
(
l
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
EnvironmentCoordinate
)
{
loc
=
Some
(
l
.
addHops
(
extraHops
)
)
;
}
else
{
loc
=
Some
(
l
)
;
}
}
return
loc
;
}
