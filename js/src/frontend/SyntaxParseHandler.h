#
ifndef
frontend_SyntaxParseHandler_h
#
define
frontend_SyntaxParseHandler_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
string
.
h
>
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
namespace
frontend
{
class
SyntaxParseHandler
{
JSAtom
*
lastAtom
;
TokenPos
lastStringPos
;
public
:
enum
Node
{
NodeFailure
=
0
NodeGeneric
NodeGetProp
NodeStringExprStatement
NodeReturn
NodeBreak
NodeThrow
NodeEmptyStatement
NodeVarDeclaration
NodeLexicalDeclaration
NodeFunctionExpression
NodeFunctionArrow
NodeFunctionStatement
NodeFunctionCall
NodeName
NodeArgumentsName
NodeEvalName
NodePotentialAsyncKeyword
NodeDottedProperty
NodeElement
NodeParenthesizedArray
NodeParenthesizedObject
NodeUnparenthesizedArray
NodeUnparenthesizedObject
NodeUnparenthesizedString
NodeUnparenthesizedAssignment
NodeUnparenthesizedUnary
NodeSuperBase
}
;
bool
isNonArrowFunctionExpression
(
Node
node
)
const
{
return
node
=
=
NodeFunctionExpression
;
}
bool
isPropertyAccess
(
Node
node
)
{
return
node
=
=
NodeDottedProperty
|
|
node
=
=
NodeElement
;
}
bool
isFunctionCall
(
Node
node
)
{
return
node
=
=
NodeFunctionCall
;
}
static
bool
isUnparenthesizedDestructuringPattern
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedArray
|
|
node
=
=
NodeUnparenthesizedObject
;
}
static
bool
isParenthesizedDestructuringPattern
(
Node
node
)
{
return
node
=
=
NodeParenthesizedArray
|
|
node
=
=
NodeParenthesizedObject
;
}
public
:
SyntaxParseHandler
(
JSContext
*
cx
LifoAlloc
&
alloc
LazyScript
*
lazyOuterFunction
)
:
lastAtom
(
nullptr
)
{
}
static
Node
null
(
)
{
return
NodeFailure
;
}
void
prepareNodeForMutation
(
Node
node
)
{
}
void
freeTree
(
Node
node
)
{
}
Node
newName
(
PropertyName
*
name
const
TokenPos
&
pos
JSContext
*
cx
)
{
lastAtom
=
name
;
if
(
name
=
=
cx
-
>
names
(
)
.
arguments
)
return
NodeArgumentsName
;
if
(
pos
.
begin
+
strlen
(
"
async
"
)
=
=
pos
.
end
&
&
name
=
=
cx
-
>
names
(
)
.
async
)
return
NodePotentialAsyncKeyword
;
if
(
name
=
=
cx
-
>
names
(
)
.
eval
)
return
NodeEvalName
;
return
NodeName
;
}
Node
newComputedName
(
Node
expr
uint32_t
start
uint32_t
end
)
{
return
NodeGeneric
;
}
Node
newObjectLiteralPropertyName
(
JSAtom
*
atom
const
TokenPos
&
pos
)
{
return
NodeName
;
}
Node
newNumber
(
double
value
DecimalPoint
decimalPoint
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newBooleanLiteral
(
bool
cond
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newStringLiteral
(
JSAtom
*
atom
const
TokenPos
&
pos
)
{
lastAtom
=
atom
;
lastStringPos
=
pos
;
return
NodeUnparenthesizedString
;
}
Node
newTemplateStringLiteral
(
JSAtom
*
atom
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newCallSiteObject
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
void
addToCallSiteObject
(
Node
callSiteObj
Node
rawNode
Node
cookedNode
)
{
}
Node
newThisLiteral
(
const
TokenPos
&
pos
Node
thisName
)
{
return
NodeGeneric
;
}
Node
newNullLiteral
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newRawUndefinedLiteral
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
template
<
class
Boxer
>
Node
newRegExp
(
Node
reobj
const
TokenPos
&
pos
Boxer
&
boxer
)
{
return
NodeGeneric
;
}
Node
newConditional
(
Node
cond
Node
thenExpr
Node
elseExpr
)
{
return
NodeGeneric
;
}
Node
newElision
(
)
{
return
NodeGeneric
;
}
Node
newDelete
(
uint32_t
begin
Node
expr
)
{
return
NodeUnparenthesizedUnary
;
}
Node
newTypeof
(
uint32_t
begin
Node
kid
)
{
return
NodeUnparenthesizedUnary
;
}
Node
newUnary
(
ParseNodeKind
kind
uint32_t
begin
Node
kid
)
{
return
NodeUnparenthesizedUnary
;
}
Node
newUpdate
(
ParseNodeKind
kind
uint32_t
begin
Node
kid
)
{
return
NodeGeneric
;
}
Node
newSpread
(
uint32_t
begin
Node
kid
)
{
return
NodeGeneric
;
}
Node
appendOrCreateList
(
ParseNodeKind
kind
Node
left
Node
right
ParseContext
*
pc
)
{
return
NodeGeneric
;
}
Node
newArrayLiteral
(
uint32_t
begin
)
{
return
NodeUnparenthesizedArray
;
}
MOZ_MUST_USE
bool
addElision
(
Node
literal
const
TokenPos
&
pos
)
{
return
true
;
}
MOZ_MUST_USE
bool
addSpreadElement
(
Node
literal
uint32_t
begin
Node
inner
)
{
return
true
;
}
void
addArrayElement
(
Node
literal
Node
element
)
{
}
Node
newCall
(
const
TokenPos
&
pos
)
{
return
NodeFunctionCall
;
}
Node
newSuperCall
(
Node
callee
)
{
return
NodeGeneric
;
}
Node
newTaggedTemplate
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newObjectLiteral
(
uint32_t
begin
)
{
return
NodeUnparenthesizedObject
;
}
Node
newClassMethodList
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
Node
newClassNames
(
Node
outer
Node
inner
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newClass
(
Node
name
Node
heritage
Node
methodBlock
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newNewTarget
(
Node
newHolder
Node
targetHolder
)
{
return
NodeGeneric
;
}
Node
newPosHolder
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newSuperBase
(
Node
thisName
const
TokenPos
&
pos
)
{
return
NodeSuperBase
;
}
MOZ_MUST_USE
bool
addPrototypeMutation
(
Node
literal
uint32_t
begin
Node
expr
)
{
return
true
;
}
Node
newPropertyDefinition
(
Node
name
Node
expr
)
{
return
NodeGeneric
;
}
void
addPropertyDefinition
(
Node
literal
Node
propdef
)
{
}
MOZ_MUST_USE
bool
addPropertyDefinition
(
Node
literal
Node
name
Node
expr
)
{
return
true
;
}
MOZ_MUST_USE
bool
addShorthand
(
Node
literal
Node
name
Node
expr
)
{
return
true
;
}
MOZ_MUST_USE
bool
addSpreadProperty
(
Node
literal
uint32_t
begin
Node
inner
)
{
return
true
;
}
MOZ_MUST_USE
bool
addObjectMethodDefinition
(
Node
literal
Node
name
Node
fn
AccessorType
atype
)
{
return
true
;
}
MOZ_MUST_USE
bool
addClassMethodDefinition
(
Node
literal
Node
name
Node
fn
AccessorType
atype
bool
isStatic
)
{
return
true
;
}
Node
newYieldExpression
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
Node
newYieldStarExpression
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
Node
newAwaitExpression
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
Node
newStatementList
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
void
addStatementToList
(
Node
list
Node
stmt
)
{
}
void
setListEndPosition
(
Node
list
const
TokenPos
&
pos
)
{
}
void
addCaseStatementToList
(
Node
list
Node
stmt
)
{
}
MOZ_MUST_USE
bool
prependInitialYield
(
Node
stmtList
Node
gen
)
{
return
true
;
}
Node
newEmptyStatement
(
const
TokenPos
&
pos
)
{
return
NodeEmptyStatement
;
}
Node
newExportDeclaration
(
Node
kid
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newExportFromDeclaration
(
uint32_t
begin
Node
exportSpecSet
Node
moduleSpec
)
{
return
NodeGeneric
;
}
Node
newExportDefaultDeclaration
(
Node
kid
Node
maybeBinding
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newExportSpec
(
Node
bindingName
Node
exportName
)
{
return
NodeGeneric
;
}
Node
newExportBatchSpec
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newSetThis
(
Node
thisName
Node
value
)
{
return
value
;
}
Node
newExprStatement
(
Node
expr
uint32_t
end
)
{
return
expr
=
=
NodeUnparenthesizedString
?
NodeStringExprStatement
:
NodeGeneric
;
}
Node
newIfStatement
(
uint32_t
begin
Node
cond
Node
then
Node
else_
)
{
return
NodeGeneric
;
}
Node
newDoWhileStatement
(
Node
body
Node
cond
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newWhileStatement
(
uint32_t
begin
Node
cond
Node
body
)
{
return
NodeGeneric
;
}
Node
newSwitchStatement
(
uint32_t
begin
Node
discriminant
Node
caseList
)
{
return
NodeGeneric
;
}
Node
newCaseOrDefault
(
uint32_t
begin
Node
expr
Node
body
)
{
return
NodeGeneric
;
}
Node
newContinueStatement
(
PropertyName
*
label
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newBreakStatement
(
PropertyName
*
label
const
TokenPos
&
pos
)
{
return
NodeBreak
;
}
Node
newReturnStatement
(
Node
expr
const
TokenPos
&
pos
)
{
return
NodeReturn
;
}
Node
newExpressionBody
(
Node
expr
)
{
return
NodeReturn
;
}
Node
newWithStatement
(
uint32_t
begin
Node
expr
Node
body
)
{
return
NodeGeneric
;
}
Node
newLabeledStatement
(
PropertyName
*
label
Node
stmt
uint32_t
begin
)
{
return
NodeGeneric
;
}
Node
newThrowStatement
(
Node
expr
const
TokenPos
&
pos
)
{
return
NodeThrow
;
}
Node
newTryStatement
(
uint32_t
begin
Node
body
Node
catchScope
Node
finallyBlock
)
{
return
NodeGeneric
;
}
Node
newDebuggerStatement
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newPropertyAccess
(
Node
expr
PropertyName
*
key
uint32_t
end
)
{
lastAtom
=
key
;
return
NodeDottedProperty
;
}
Node
newPropertyByValue
(
Node
pn
Node
kid
uint32_t
end
)
{
return
NodeElement
;
}
MOZ_MUST_USE
bool
setupCatchScope
(
Node
letBlock
Node
catchName
Node
catchBody
)
{
return
true
;
}
MOZ_MUST_USE
bool
setLastFunctionFormalParameterDefault
(
Node
funcpn
Node
pn
)
{
return
true
;
}
Node
newFunctionStatement
(
const
TokenPos
&
pos
)
{
return
NodeFunctionStatement
;
}
Node
newFunctionExpression
(
const
TokenPos
&
pos
)
{
return
NodeFunctionExpression
;
}
Node
newArrowFunction
(
const
TokenPos
&
pos
)
{
return
NodeFunctionArrow
;
}
void
setFunctionFormalParametersAndBody
(
Node
funcNode
Node
kid
)
{
}
void
setFunctionBody
(
Node
pn
Node
kid
)
{
}
void
setFunctionBox
(
Node
pn
FunctionBox
*
funbox
)
{
}
void
addFunctionFormalParameter
(
Node
pn
Node
argpn
)
{
}
Node
newForStatement
(
uint32_t
begin
Node
forHead
Node
body
unsigned
iflags
)
{
return
NodeGeneric
;
}
Node
newForHead
(
Node
init
Node
test
Node
update
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
Node
newForInOrOfHead
(
ParseNodeKind
kind
Node
target
Node
iteratedExpr
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
MOZ_MUST_USE
bool
finishInitializerAssignment
(
Node
pn
Node
init
)
{
return
true
;
}
void
setBeginPosition
(
Node
pn
Node
oth
)
{
}
void
setBeginPosition
(
Node
pn
uint32_t
begin
)
{
}
void
setEndPosition
(
Node
pn
Node
oth
)
{
}
void
setEndPosition
(
Node
pn
uint32_t
end
)
{
}
uint32_t
getFunctionNameOffset
(
Node
func
TokenStreamAnyChars
&
ts
)
{
return
ts
.
currentToken
(
)
.
pos
.
begin
;
}
Node
newList
(
ParseNodeKind
kind
const
TokenPos
&
pos
)
{
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
Var
)
;
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
Let
)
;
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
Const
)
;
return
NodeGeneric
;
}
Node
newList
(
ParseNodeKind
kind
Node
kid
)
{
return
newList
(
kind
TokenPos
(
)
)
;
}
Node
newDeclarationList
(
ParseNodeKind
kind
const
TokenPos
&
pos
)
{
if
(
kind
=
=
ParseNodeKind
:
:
Var
)
return
NodeVarDeclaration
;
MOZ_ASSERT
(
kind
=
=
ParseNodeKind
:
:
Let
|
|
kind
=
=
ParseNodeKind
:
:
Const
)
;
return
NodeLexicalDeclaration
;
}
bool
isDeclarationList
(
Node
node
)
{
return
node
=
=
NodeVarDeclaration
|
|
node
=
=
NodeLexicalDeclaration
;
}
Node
singleBindingFromDeclaration
(
Node
decl
)
=
delete
;
Node
newCommaExpressionList
(
Node
kid
)
{
return
NodeGeneric
;
}
void
addList
(
Node
list
Node
kid
)
{
MOZ_ASSERT
(
list
=
=
NodeGeneric
|
|
list
=
=
NodeUnparenthesizedArray
|
|
list
=
=
NodeUnparenthesizedObject
|
|
list
=
=
NodeVarDeclaration
|
|
list
=
=
NodeLexicalDeclaration
|
|
list
=
=
NodeFunctionCall
)
;
}
Node
newNewExpression
(
uint32_t
begin
Node
ctor
)
{
return
NodeGeneric
;
}
Node
newAssignment
(
ParseNodeKind
kind
Node
lhs
Node
rhs
)
{
return
kind
=
=
ParseNodeKind
:
:
Assign
?
NodeUnparenthesizedAssignment
:
NodeGeneric
;
}
bool
isUnparenthesizedAssignment
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedAssignment
;
}
bool
isUnparenthesizedUnaryExpression
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedUnary
;
}
bool
isReturnStatement
(
Node
node
)
{
return
node
=
=
NodeReturn
;
}
bool
isStatementPermittedAfterReturnStatement
(
Node
pn
)
{
return
pn
=
=
NodeFunctionStatement
|
|
isNonArrowFunctionExpression
(
pn
)
|
|
pn
=
=
NodeVarDeclaration
|
|
pn
=
=
NodeBreak
|
|
pn
=
=
NodeThrow
|
|
pn
=
=
NodeEmptyStatement
;
}
bool
isSuperBase
(
Node
pn
)
{
return
pn
=
=
NodeSuperBase
;
}
void
setOp
(
Node
pn
JSOp
op
)
{
}
void
setListFlag
(
Node
pn
unsigned
flag
)
{
}
MOZ_MUST_USE
Node
parenthesize
(
Node
node
)
{
if
(
node
=
=
NodeUnparenthesizedArray
)
return
NodeParenthesizedArray
;
if
(
node
=
=
NodeUnparenthesizedObject
)
return
NodeParenthesizedObject
;
if
(
node
=
=
NodeUnparenthesizedString
|
|
node
=
=
NodeUnparenthesizedAssignment
|
|
node
=
=
NodeUnparenthesizedUnary
)
{
return
NodeGeneric
;
}
if
(
node
=
=
NodePotentialAsyncKeyword
)
return
NodeName
;
return
node
;
}
MOZ_MUST_USE
Node
setLikelyIIFE
(
Node
pn
)
{
return
pn
;
}
void
setInDirectivePrologue
(
Node
pn
)
{
}
bool
isName
(
Node
node
)
{
return
node
=
=
NodeName
|
|
node
=
=
NodeArgumentsName
|
|
node
=
=
NodeEvalName
|
|
node
=
=
NodePotentialAsyncKeyword
;
}
bool
isArgumentsName
(
Node
node
JSContext
*
cx
)
{
return
node
=
=
NodeArgumentsName
;
}
bool
isEvalName
(
Node
node
JSContext
*
cx
)
{
return
node
=
=
NodeEvalName
;
}
bool
isAsyncKeyword
(
Node
node
JSContext
*
cx
)
{
return
node
=
=
NodePotentialAsyncKeyword
;
}
PropertyName
*
maybeDottedProperty
(
Node
node
)
{
if
(
node
!
=
NodeDottedProperty
)
return
nullptr
;
return
lastAtom
-
>
asPropertyName
(
)
;
}
JSAtom
*
isStringExprStatement
(
Node
pn
TokenPos
*
pos
)
{
if
(
pn
=
=
NodeStringExprStatement
)
{
*
pos
=
lastStringPos
;
return
lastAtom
;
}
return
nullptr
;
}
bool
canSkipLazyInnerFunctions
(
)
{
return
false
;
}
bool
canSkipLazyClosedOverBindings
(
)
{
return
false
;
}
JSAtom
*
nextLazyClosedOverBinding
(
)
{
MOZ_CRASH
(
"
SyntaxParseHandler
:
:
canSkipLazyClosedOverBindings
must
return
false
"
)
;
}
void
adjustGetToSet
(
Node
node
)
{
}
}
JS_HAZ_ROOTED
;
}
}
#
endif
