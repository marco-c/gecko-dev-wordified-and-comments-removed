#
ifndef
frontend_SyntaxParseHandler_h
#
define
frontend_SyntaxParseHandler_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
string
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
namespace
frontend
{
class
SyntaxParseHandler
{
TaggedParserAtomIndex
lastAtom
;
TokenPos
lastStringPos
;
public
:
enum
Node
{
NodeFailure
=
0
NodeGeneric
NodeGetProp
NodeStringExprStatement
NodeReturn
NodeBreak
NodeThrow
NodeEmptyStatement
NodeVarDeclaration
NodeLexicalDeclaration
NodeFunctionExpression
NodeFunctionArrow
NodeFunctionStatement
NodeFunctionCall
NodeOptionalFunctionCall
NodeName
NodeArgumentsName
NodeEvalName
NodePotentialAsyncKeyword
NodePrivateName
NodeDottedProperty
NodeOptionalDottedProperty
NodeElement
NodeOptionalElement
NodePrivateMemberAccess
NodeOptionalPrivateMemberAccess
NodeParenthesizedArray
NodeParenthesizedObject
NodeUnparenthesizedArray
NodeUnparenthesizedObject
NodeUnparenthesizedString
NodeUnparenthesizedAssignment
NodeUnparenthesizedUnary
NodeSuperBase
}
;
#
define
DECLARE_TYPE
(
typeName
longTypeName
asMethodName
)
\
using
longTypeName
=
Node
;
FOR_EACH_PARSENODE_SUBCLASS
(
DECLARE_TYPE
)
#
undef
DECLARE_TYPE
using
NullNode
=
Node
;
bool
isNonArrowFunctionExpression
(
Node
node
)
const
{
return
node
=
=
NodeFunctionExpression
;
}
bool
isPropertyOrPrivateMemberAccess
(
Node
node
)
{
return
node
=
=
NodeDottedProperty
|
|
node
=
=
NodeElement
|
|
node
=
=
NodePrivateMemberAccess
;
}
bool
isOptionalPropertyOrPrivateMemberAccess
(
Node
node
)
{
return
node
=
=
NodeOptionalDottedProperty
|
|
node
=
=
NodeOptionalElement
|
|
node
=
=
NodeOptionalPrivateMemberAccess
;
}
bool
isFunctionCall
(
Node
node
)
{
return
node
=
=
NodeFunctionCall
;
}
static
bool
isUnparenthesizedDestructuringPattern
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedArray
|
|
node
=
=
NodeUnparenthesizedObject
;
}
static
bool
isParenthesizedDestructuringPattern
(
Node
node
)
{
return
node
=
=
NodeParenthesizedArray
|
|
node
=
=
NodeParenthesizedObject
;
}
public
:
SyntaxParseHandler
(
JSContext
*
cx
CompilationState
&
compilationState
)
{
MOZ_ASSERT
(
!
compilationState
.
input
.
isDelazifying
(
)
)
;
}
static
NullNode
null
(
)
{
return
NodeFailure
;
}
#
define
DECLARE_AS
(
typeName
longTypeName
asMethodName
)
\
static
longTypeName
asMethodName
(
Node
node
)
{
return
node
;
}
FOR_EACH_PARSENODE_SUBCLASS
(
DECLARE_AS
)
#
undef
DECLARE_AS
NameNodeType
newName
(
TaggedParserAtomIndex
name
const
TokenPos
&
pos
)
{
lastAtom
=
name
;
if
(
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
arguments
(
)
)
{
return
NodeArgumentsName
;
}
if
(
pos
.
begin
+
strlen
(
"
async
"
)
=
=
pos
.
end
&
&
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
async
(
)
)
{
return
NodePotentialAsyncKeyword
;
}
if
(
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
eval
(
)
)
{
return
NodeEvalName
;
}
return
NodeName
;
}
UnaryNodeType
newComputedName
(
Node
expr
uint32_t
start
uint32_t
end
)
{
return
NodeGeneric
;
}
UnaryNodeType
newSyntheticComputedName
(
Node
expr
uint32_t
start
uint32_t
end
)
{
return
NodeGeneric
;
}
NameNodeType
newObjectLiteralPropertyName
(
TaggedParserAtomIndex
atom
const
TokenPos
&
pos
)
{
return
NodeName
;
}
NameNodeType
newPrivateName
(
TaggedParserAtomIndex
atom
const
TokenPos
&
pos
)
{
return
NodePrivateName
;
}
NumericLiteralType
newNumber
(
double
value
DecimalPoint
decimalPoint
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BigIntLiteralType
newBigInt
(
)
{
return
NodeGeneric
;
}
BooleanLiteralType
newBooleanLiteral
(
bool
cond
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
NameNodeType
newStringLiteral
(
TaggedParserAtomIndex
atom
const
TokenPos
&
pos
)
{
lastAtom
=
atom
;
lastStringPos
=
pos
;
return
NodeUnparenthesizedString
;
}
NameNodeType
newTemplateStringLiteral
(
TaggedParserAtomIndex
atom
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
CallSiteNodeType
newCallSiteObject
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
void
addToCallSiteObject
(
CallSiteNodeType
callSiteObj
Node
rawNode
Node
cookedNode
)
{
}
ThisLiteralType
newThisLiteral
(
const
TokenPos
&
pos
Node
thisName
)
{
return
NodeGeneric
;
}
NullLiteralType
newNullLiteral
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
RawUndefinedLiteralType
newRawUndefinedLiteral
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
RegExpLiteralType
newRegExp
(
Node
reobj
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
ConditionalExpressionType
newConditional
(
Node
cond
Node
thenExpr
Node
elseExpr
)
{
return
NodeGeneric
;
}
UnaryNodeType
newDelete
(
uint32_t
begin
Node
expr
)
{
return
NodeUnparenthesizedUnary
;
}
UnaryNodeType
newTypeof
(
uint32_t
begin
Node
kid
)
{
return
NodeUnparenthesizedUnary
;
}
UnaryNodeType
newUnary
(
ParseNodeKind
kind
uint32_t
begin
Node
kid
)
{
return
NodeUnparenthesizedUnary
;
}
UnaryNodeType
newUpdate
(
ParseNodeKind
kind
uint32_t
begin
Node
kid
)
{
return
NodeGeneric
;
}
UnaryNodeType
newSpread
(
uint32_t
begin
Node
kid
)
{
return
NodeGeneric
;
}
Node
appendOrCreateList
(
ParseNodeKind
kind
Node
left
Node
right
ParseContext
*
pc
)
{
return
NodeGeneric
;
}
ListNodeType
newArrayLiteral
(
uint32_t
begin
)
{
return
NodeUnparenthesizedArray
;
}
[
[
nodiscard
]
]
bool
addElision
(
ListNodeType
literal
const
TokenPos
&
pos
)
{
return
true
;
}
[
[
nodiscard
]
]
bool
addSpreadElement
(
ListNodeType
literal
uint32_t
begin
Node
inner
)
{
return
true
;
}
void
addArrayElement
(
ListNodeType
literal
Node
element
)
{
}
ListNodeType
newArguments
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
CallNodeType
newCall
(
Node
callee
Node
args
JSOp
callOp
)
{
return
NodeFunctionCall
;
}
CallNodeType
newOptionalCall
(
Node
callee
Node
args
JSOp
callOp
)
{
return
NodeOptionalFunctionCall
;
}
CallNodeType
newSuperCall
(
Node
callee
Node
args
bool
isSpread
)
{
return
NodeGeneric
;
}
CallNodeType
newTaggedTemplate
(
Node
tag
Node
args
JSOp
callOp
)
{
return
NodeGeneric
;
}
ListNodeType
newObjectLiteral
(
uint32_t
begin
)
{
return
NodeUnparenthesizedObject
;
}
#
ifdef
ENABLE_RECORD_TUPLE
ListNodeType
newRecordLiteral
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
ListNodeType
newTupleLiteral
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
#
endif
ListNodeType
newClassMemberList
(
uint32_t
begin
)
{
return
NodeGeneric
;
}
ClassNamesType
newClassNames
(
Node
outer
Node
inner
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
ClassNodeType
newClass
(
Node
name
Node
heritage
Node
methodBlock
#
ifdef
ENABLE_DECORATORS
ListNodeType
decorators
#
endif
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
LexicalScopeNodeType
newLexicalScope
(
Node
body
)
{
return
NodeLexicalDeclaration
;
}
ClassBodyScopeNodeType
newClassBodyScope
(
Node
body
)
{
return
NodeLexicalDeclaration
;
}
NewTargetNodeType
newNewTarget
(
NullaryNodeType
newHolder
NullaryNodeType
targetHolder
NameNodeType
newTargetName
)
{
return
NodeGeneric
;
}
NullaryNodeType
newPosHolder
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
UnaryNodeType
newSuperBase
(
Node
thisName
const
TokenPos
&
pos
)
{
return
NodeSuperBase
;
}
[
[
nodiscard
]
]
bool
addPrototypeMutation
(
ListNodeType
literal
uint32_t
begin
Node
expr
)
{
return
true
;
}
BinaryNodeType
newPropertyDefinition
(
Node
key
Node
val
)
{
return
NodeGeneric
;
}
void
addPropertyDefinition
(
ListNodeType
literal
BinaryNodeType
propdef
)
{
}
[
[
nodiscard
]
]
bool
addPropertyDefinition
(
ListNodeType
literal
Node
key
Node
expr
)
{
return
true
;
}
[
[
nodiscard
]
]
bool
addShorthand
(
ListNodeType
literal
NameNodeType
name
NameNodeType
expr
)
{
return
true
;
}
[
[
nodiscard
]
]
bool
addSpreadProperty
(
ListNodeType
literal
uint32_t
begin
Node
inner
)
{
return
true
;
}
[
[
nodiscard
]
]
bool
addObjectMethodDefinition
(
ListNodeType
literal
Node
key
FunctionNodeType
funNode
AccessorType
atype
)
{
return
true
;
}
[
[
nodiscard
]
]
Node
newDefaultClassConstructor
(
Node
key
FunctionNodeType
funNode
)
{
return
NodeGeneric
;
}
[
[
nodiscard
]
]
Node
newClassMethodDefinition
(
Node
key
FunctionNodeType
funNode
AccessorType
atype
bool
isStatic
mozilla
:
:
Maybe
<
FunctionNodeType
>
initializerIfPrivate
#
ifdef
ENABLE_DECORATORS
ListNodeType
decorators
#
endif
)
{
return
NodeGeneric
;
}
[
[
nodiscard
]
]
Node
newClassFieldDefinition
(
Node
name
FunctionNodeType
initializer
bool
isStatic
#
ifdef
ENABLE_DECORATORS
ListNodeType
decorators
#
endif
)
{
return
NodeGeneric
;
}
[
[
nodiscard
]
]
Node
newStaticClassBlock
(
FunctionNodeType
block
)
{
return
NodeGeneric
;
}
[
[
nodiscard
]
]
bool
addClassMemberDefinition
(
ListNodeType
memberList
Node
member
)
{
return
true
;
}
UnaryNodeType
newYieldExpression
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
UnaryNodeType
newYieldStarExpression
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
UnaryNodeType
newAwaitExpression
(
uint32_t
begin
Node
value
)
{
return
NodeUnparenthesizedUnary
;
}
UnaryNodeType
newOptionalChain
(
uint32_t
begin
Node
value
)
{
return
NodeGeneric
;
}
ListNodeType
newStatementList
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
void
addStatementToList
(
ListNodeType
list
Node
stmt
)
{
}
void
setListEndPosition
(
ListNodeType
list
const
TokenPos
&
pos
)
{
}
void
addCaseStatementToList
(
ListNodeType
list
CaseClauseType
caseClause
)
{
}
[
[
nodiscard
]
]
bool
prependInitialYield
(
ListNodeType
stmtList
Node
genName
)
{
return
true
;
}
NullaryNodeType
newEmptyStatement
(
const
TokenPos
&
pos
)
{
return
NodeEmptyStatement
;
}
BinaryNodeType
newImportAssertion
(
Node
keyNode
Node
valueNode
)
{
return
NodeGeneric
;
}
BinaryNodeType
newModuleRequest
(
Node
moduleSpec
Node
importAssertionList
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newImportDeclaration
(
Node
importSpecSet
Node
moduleRequest
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newImportSpec
(
Node
importNameNode
Node
bindingName
)
{
return
NodeGeneric
;
}
UnaryNodeType
newImportNamespaceSpec
(
uint32_t
begin
Node
bindingName
)
{
return
NodeGeneric
;
}
UnaryNodeType
newExportDeclaration
(
Node
kid
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newExportFromDeclaration
(
uint32_t
begin
Node
exportSpecSet
Node
moduleRequest
)
{
return
NodeGeneric
;
}
BinaryNodeType
newExportDefaultDeclaration
(
Node
kid
Node
maybeBinding
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newExportSpec
(
Node
bindingName
Node
exportName
)
{
return
NodeGeneric
;
}
UnaryNodeType
newExportNamespaceSpec
(
uint32_t
begin
Node
exportName
)
{
return
NodeGeneric
;
}
NullaryNodeType
newExportBatchSpec
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newImportMeta
(
NullaryNodeType
importHolder
NullaryNodeType
metaHolder
)
{
return
NodeGeneric
;
}
BinaryNodeType
newCallImport
(
NullaryNodeType
importHolder
Node
singleArg
)
{
return
NodeGeneric
;
}
BinaryNodeType
newCallImportSpec
(
Node
specifierArg
Node
optionalArg
)
{
return
NodeGeneric
;
}
BinaryNodeType
newSetThis
(
Node
thisName
Node
value
)
{
return
value
;
}
UnaryNodeType
newExprStatement
(
Node
expr
uint32_t
end
)
{
return
expr
=
=
NodeUnparenthesizedString
?
NodeStringExprStatement
:
NodeGeneric
;
}
TernaryNodeType
newIfStatement
(
uint32_t
begin
Node
cond
Node
thenBranch
Node
elseBranch
)
{
return
NodeGeneric
;
}
BinaryNodeType
newDoWhileStatement
(
Node
body
Node
cond
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BinaryNodeType
newWhileStatement
(
uint32_t
begin
Node
cond
Node
body
)
{
return
NodeGeneric
;
}
SwitchStatementType
newSwitchStatement
(
uint32_t
begin
Node
discriminant
LexicalScopeNodeType
lexicalForCaseList
bool
hasDefault
)
{
return
NodeGeneric
;
}
CaseClauseType
newCaseOrDefault
(
uint32_t
begin
Node
expr
Node
body
)
{
return
NodeGeneric
;
}
ContinueStatementType
newContinueStatement
(
TaggedParserAtomIndex
label
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
BreakStatementType
newBreakStatement
(
TaggedParserAtomIndex
label
const
TokenPos
&
pos
)
{
return
NodeBreak
;
}
UnaryNodeType
newReturnStatement
(
Node
expr
const
TokenPos
&
pos
)
{
return
NodeReturn
;
}
UnaryNodeType
newExpressionBody
(
Node
expr
)
{
return
NodeReturn
;
}
BinaryNodeType
newWithStatement
(
uint32_t
begin
Node
expr
Node
body
)
{
return
NodeGeneric
;
}
LabeledStatementType
newLabeledStatement
(
TaggedParserAtomIndex
label
Node
stmt
uint32_t
begin
)
{
return
NodeGeneric
;
}
UnaryNodeType
newThrowStatement
(
Node
expr
const
TokenPos
&
pos
)
{
return
NodeThrow
;
}
TernaryNodeType
newTryStatement
(
uint32_t
begin
Node
body
LexicalScopeNodeType
catchScope
Node
finallyBlock
)
{
return
NodeGeneric
;
}
DebuggerStatementType
newDebuggerStatement
(
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
NameNodeType
newPropertyName
(
TaggedParserAtomIndex
name
const
TokenPos
&
pos
)
{
lastAtom
=
name
;
return
NodeGeneric
;
}
PropertyAccessType
newPropertyAccess
(
Node
expr
NameNodeType
key
)
{
return
NodeDottedProperty
;
}
PropertyAccessType
newOptionalPropertyAccess
(
Node
expr
NameNodeType
key
)
{
return
NodeOptionalDottedProperty
;
}
PropertyByValueType
newPropertyByValue
(
Node
lhs
Node
index
uint32_t
end
)
{
MOZ_ASSERT
(
!
isPrivateName
(
index
)
)
;
return
NodeElement
;
}
PropertyByValueType
newOptionalPropertyByValue
(
Node
lhs
Node
index
uint32_t
end
)
{
return
NodeOptionalElement
;
}
PrivateMemberAccessType
newPrivateMemberAccess
(
Node
lhs
Node
privateName
uint32_t
end
)
{
return
NodePrivateMemberAccess
;
}
PrivateMemberAccessType
newOptionalPrivateMemberAccess
(
Node
lhs
Node
privateName
uint32_t
end
)
{
return
NodeOptionalPrivateMemberAccess
;
}
[
[
nodiscard
]
]
bool
setupCatchScope
(
LexicalScopeNodeType
lexicalScope
Node
catchName
Node
catchBody
)
{
return
true
;
}
[
[
nodiscard
]
]
bool
setLastFunctionFormalParameterDefault
(
FunctionNodeType
funNode
Node
defaultValue
)
{
return
true
;
}
void
checkAndSetIsDirectRHSAnonFunction
(
Node
pn
)
{
}
FunctionNodeType
newFunction
(
FunctionSyntaxKind
syntaxKind
const
TokenPos
&
pos
)
{
switch
(
syntaxKind
)
{
case
FunctionSyntaxKind
:
:
Statement
:
return
NodeFunctionStatement
;
case
FunctionSyntaxKind
:
:
Arrow
:
return
NodeFunctionArrow
;
default
:
return
NodeFunctionExpression
;
}
}
void
setFunctionFormalParametersAndBody
(
FunctionNodeType
funNode
ListNodeType
paramsBody
)
{
}
void
setFunctionBody
(
FunctionNodeType
funNode
LexicalScopeNodeType
body
)
{
}
void
setFunctionBox
(
FunctionNodeType
funNode
FunctionBox
*
funbox
)
{
}
void
addFunctionFormalParameter
(
FunctionNodeType
funNode
Node
argpn
)
{
}
ForNodeType
newForStatement
(
uint32_t
begin
TernaryNodeType
forHead
Node
body
unsigned
iflags
)
{
return
NodeGeneric
;
}
TernaryNodeType
newForHead
(
Node
init
Node
test
Node
update
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
TernaryNodeType
newForInOrOfHead
(
ParseNodeKind
kind
Node
target
Node
iteratedExpr
const
TokenPos
&
pos
)
{
return
NodeGeneric
;
}
AssignmentNodeType
finishInitializerAssignment
(
NameNodeType
nameNode
Node
init
)
{
return
NodeUnparenthesizedAssignment
;
}
void
setBeginPosition
(
Node
pn
Node
oth
)
{
}
void
setBeginPosition
(
Node
pn
uint32_t
begin
)
{
}
void
setEndPosition
(
Node
pn
Node
oth
)
{
}
void
setEndPosition
(
Node
pn
uint32_t
end
)
{
}
uint32_t
getFunctionNameOffset
(
Node
func
TokenStreamAnyChars
&
ts
)
{
return
ts
.
currentToken
(
)
.
pos
.
begin
;
}
ListNodeType
newList
(
ParseNodeKind
kind
const
TokenPos
&
pos
)
{
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
VarStmt
)
;
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
LetDecl
)
;
MOZ_ASSERT
(
kind
!
=
ParseNodeKind
:
:
ConstDecl
)
;
return
NodeGeneric
;
}
ListNodeType
newList
(
ParseNodeKind
kind
Node
kid
)
{
return
newList
(
kind
TokenPos
(
)
)
;
}
ListNodeType
newDeclarationList
(
ParseNodeKind
kind
const
TokenPos
&
pos
)
{
if
(
kind
=
=
ParseNodeKind
:
:
VarStmt
)
{
return
NodeVarDeclaration
;
}
MOZ_ASSERT
(
kind
=
=
ParseNodeKind
:
:
LetDecl
|
|
kind
=
=
ParseNodeKind
:
:
ConstDecl
)
;
return
NodeLexicalDeclaration
;
}
bool
isDeclarationList
(
Node
node
)
{
return
node
=
=
NodeVarDeclaration
|
|
node
=
=
NodeLexicalDeclaration
;
}
Node
singleBindingFromDeclaration
(
ListNodeType
decl
)
=
delete
;
ListNodeType
newCommaExpressionList
(
Node
kid
)
{
return
NodeGeneric
;
}
void
addList
(
ListNodeType
list
Node
kid
)
{
MOZ_ASSERT
(
list
=
=
NodeGeneric
|
|
list
=
=
NodeUnparenthesizedArray
|
|
list
=
=
NodeUnparenthesizedObject
|
|
list
=
=
NodeVarDeclaration
|
|
list
=
=
NodeLexicalDeclaration
|
|
list
=
=
NodeFunctionCall
)
;
}
CallNodeType
newNewExpression
(
uint32_t
begin
Node
ctor
Node
args
bool
isSpread
)
{
return
NodeGeneric
;
}
AssignmentNodeType
newAssignment
(
ParseNodeKind
kind
Node
lhs
Node
rhs
)
{
return
kind
=
=
ParseNodeKind
:
:
AssignExpr
?
NodeUnparenthesizedAssignment
:
NodeGeneric
;
}
bool
isUnparenthesizedAssignment
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedAssignment
;
}
bool
isUnparenthesizedUnaryExpression
(
Node
node
)
{
return
node
=
=
NodeUnparenthesizedUnary
;
}
bool
isReturnStatement
(
Node
node
)
{
return
node
=
=
NodeReturn
;
}
bool
isStatementPermittedAfterReturnStatement
(
Node
pn
)
{
return
pn
=
=
NodeFunctionStatement
|
|
isNonArrowFunctionExpression
(
pn
)
|
|
pn
=
=
NodeVarDeclaration
|
|
pn
=
=
NodeBreak
|
|
pn
=
=
NodeThrow
|
|
pn
=
=
NodeEmptyStatement
;
}
bool
isSuperBase
(
Node
pn
)
{
return
pn
=
=
NodeSuperBase
;
}
void
setListHasNonConstInitializer
(
ListNodeType
literal
)
{
}
[
[
nodiscard
]
]
Node
parenthesize
(
Node
node
)
{
if
(
node
=
=
NodeUnparenthesizedArray
)
{
return
NodeParenthesizedArray
;
}
if
(
node
=
=
NodeUnparenthesizedObject
)
{
return
NodeParenthesizedObject
;
}
if
(
node
=
=
NodeUnparenthesizedString
|
|
node
=
=
NodeUnparenthesizedAssignment
|
|
node
=
=
NodeUnparenthesizedUnary
)
{
return
NodeGeneric
;
}
if
(
node
=
=
NodePotentialAsyncKeyword
)
{
return
NodeName
;
}
return
node
;
}
template
<
typename
NodeType
>
[
[
nodiscard
]
]
NodeType
setLikelyIIFE
(
NodeType
node
)
{
return
node
;
}
bool
isName
(
Node
node
)
{
return
node
=
=
NodeName
|
|
node
=
=
NodeArgumentsName
|
|
node
=
=
NodeEvalName
|
|
node
=
=
NodePotentialAsyncKeyword
;
}
bool
isArgumentsName
(
Node
node
)
{
return
node
=
=
NodeArgumentsName
;
}
bool
isEvalName
(
Node
node
)
{
return
node
=
=
NodeEvalName
;
}
bool
isAsyncKeyword
(
Node
node
)
{
return
node
=
=
NodePotentialAsyncKeyword
;
}
bool
isPrivateName
(
Node
node
)
{
return
node
=
=
NodePrivateName
;
}
bool
isPrivateMemberAccess
(
Node
node
)
{
return
node
=
=
NodePrivateMemberAccess
;
}
TaggedParserAtomIndex
maybeDottedProperty
(
Node
node
)
{
if
(
node
!
=
NodeDottedProperty
&
&
node
!
=
NodeOptionalDottedProperty
)
{
return
TaggedParserAtomIndex
:
:
null
(
)
;
}
return
lastAtom
;
}
TaggedParserAtomIndex
isStringExprStatement
(
Node
pn
TokenPos
*
pos
)
{
if
(
pn
=
=
NodeStringExprStatement
)
{
*
pos
=
lastStringPos
;
return
lastAtom
;
}
return
TaggedParserAtomIndex
:
:
null
(
)
;
}
bool
reuseLazyInnerFunctions
(
)
{
return
false
;
}
bool
reuseClosedOverBindings
(
)
{
return
false
;
}
TaggedParserAtomIndex
nextLazyClosedOverBinding
(
)
{
MOZ_CRASH
(
"
SyntaxParseHandler
:
:
canSkipLazyClosedOverBindings
must
return
false
"
)
;
}
void
setPrivateNameKind
(
Node
node
PrivateNameKind
kind
)
{
}
}
;
}
}
#
endif
