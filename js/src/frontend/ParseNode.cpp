#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
IsFinite
;
#
ifdef
DEBUG
void
ListNode
:
:
checkConsistency
(
)
const
{
ParseNode
*
const
*
tailNode
;
uint32_t
actualCount
=
0
;
if
(
const
ParseNode
*
last
=
head
(
)
)
{
const
ParseNode
*
pn
=
last
;
while
(
pn
)
{
last
=
pn
;
pn
=
pn
-
>
pn_next
;
actualCount
+
+
;
}
tailNode
=
&
last
-
>
pn_next
;
}
else
{
tailNode
=
&
head_
;
}
MOZ_ASSERT
(
tail
(
)
=
=
tailNode
)
;
MOZ_ASSERT
(
count
(
)
=
=
actualCount
)
;
}
#
endif
void
*
ParseNodeAllocator
:
:
allocNode
(
size_t
size
)
{
LifoAlloc
:
:
AutoFallibleScope
fallibleAllocator
(
&
alloc
)
;
void
*
p
=
alloc
.
alloc
(
size
)
;
if
(
!
p
)
{
ReportOutOfMemory
(
cx
)
;
}
return
p
;
}
ParseNode
*
ParseNode
:
:
appendOrCreateList
(
ParseNodeKind
kind
ParseNode
*
left
ParseNode
*
right
FullParseHandler
*
handler
ParseContext
*
pc
)
{
if
(
!
pc
-
>
useAsmOrInsideUseAsm
(
)
)
{
if
(
left
-
>
isKind
(
kind
)
&
&
(
kind
=
=
ParseNodeKind
:
:
PowExpr
?
!
left
-
>
isInParens
(
)
:
left
-
>
isBinaryOperation
(
)
)
)
{
ListNode
*
list
=
&
left
-
>
as
<
ListNode
>
(
)
;
list
-
>
append
(
right
)
;
list
-
>
pn_pos
.
end
=
right
-
>
pn_pos
.
end
;
return
list
;
}
}
ListNode
*
list
=
handler
-
>
new_
<
ListNode
>
(
kind
left
)
;
if
(
!
list
)
{
return
nullptr
;
}
list
-
>
append
(
right
)
;
return
list
;
}
const
ParseNode
:
:
TypeCode
ParseNode
:
:
typeCodeTable
[
]
=
{
#
define
TYPE_CODE
(
_name
type
)
type
:
:
classTypeCode
(
)
FOR_EACH_PARSE_NODE_KIND
(
TYPE_CODE
)
#
undef
TYPE_CODE
}
;
#
ifdef
DEBUG
const
size_t
ParseNode
:
:
sizeTable
[
]
=
{
#
define
NODE_SIZE
(
_name
type
)
sizeof
(
type
)
FOR_EACH_PARSE_NODE_KIND
(
NODE_SIZE
)
#
undef
NODE_SIZE
}
;
static
const
char
*
const
parseNodeNames
[
]
=
{
#
define
STRINGIFY
(
name
_type
)
#
name
FOR_EACH_PARSE_NODE_KIND
(
STRINGIFY
)
#
undef
STRINGIFY
}
;
void
frontend
:
:
DumpParseTree
(
ParserBase
*
parser
ParseNode
*
pn
GenericPrinter
&
out
int
indent
)
{
if
(
pn
=
=
nullptr
)
{
out
.
put
(
"
#
NULL
"
)
;
}
else
{
pn
-
>
dump
(
parser
out
indent
)
;
}
}
static
void
IndentNewLine
(
GenericPrinter
&
out
int
indent
)
{
out
.
putChar
(
'
\
n
'
)
;
for
(
int
i
=
0
;
i
<
indent
;
+
+
i
)
{
out
.
putChar
(
'
'
)
;
}
}
void
ParseNode
:
:
dump
(
)
{
dump
(
nullptr
)
;
}
void
ParseNode
:
:
dump
(
ParserBase
*
parser
)
{
js
:
:
Fprinter
out
(
stderr
)
;
dump
(
parser
out
)
;
}
void
ParseNode
:
:
dump
(
ParserBase
*
parser
GenericPrinter
&
out
)
{
dump
(
parser
out
0
)
;
out
.
putChar
(
'
\
n
'
)
;
}
void
ParseNode
:
:
dump
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
switch
(
getKind
(
)
)
{
#
define
DUMP
(
K
T
)
\
case
ParseNodeKind
:
:
K
:
\
as
<
T
>
(
)
.
dumpImpl
(
parser
out
indent
)
;
\
break
;
FOR_EACH_PARSE_NODE_KIND
(
DUMP
)
#
undef
DUMP
default
:
out
.
printf
(
"
#
<
BAD
NODE
%
p
kind
=
%
u
>
"
(
void
*
)
this
unsigned
(
getKind
(
)
)
)
;
}
}
void
NullaryNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
switch
(
getKind
(
)
)
{
case
ParseNodeKind
:
:
TrueExpr
:
out
.
put
(
"
#
true
"
)
;
break
;
case
ParseNodeKind
:
:
FalseExpr
:
out
.
put
(
"
#
false
"
)
;
break
;
case
ParseNodeKind
:
:
NullExpr
:
out
.
put
(
"
#
null
"
)
;
break
;
case
ParseNodeKind
:
:
RawUndefinedExpr
:
out
.
put
(
"
#
undefined
"
)
;
break
;
default
:
out
.
printf
(
"
(
%
s
)
"
parseNodeNames
[
getKindAsIndex
(
)
]
)
;
}
}
void
NumericLiteral
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
ToCStringBuf
cbuf
;
const
char
*
cstr
=
NumberToCString
(
nullptr
&
cbuf
value
(
)
)
;
if
(
!
IsFinite
(
value
(
)
)
)
{
out
.
put
(
"
#
"
)
;
}
if
(
cstr
)
{
out
.
printf
(
"
%
s
"
cstr
)
;
}
else
{
out
.
printf
(
"
%
g
"
value
(
)
)
;
}
}
void
BigIntLiteral
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
out
.
printf
(
"
(
%
s
)
"
parseNodeNames
[
getKindAsIndex
(
)
]
)
;
}
void
RegExpLiteral
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
out
.
printf
(
"
(
%
s
)
"
parseNodeNames
[
getKindAsIndex
(
)
]
)
;
}
static
void
DumpCharsNoNewline
(
const
ParserAtom
*
atom
js
:
:
GenericPrinter
&
out
)
{
if
(
atom
-
>
hasLatin1Chars
(
)
)
{
out
.
put
(
"
[
Latin
1
]
"
)
;
JSString
:
:
dumpChars
(
atom
-
>
latin1Chars
(
)
atom
-
>
length
(
)
out
)
;
}
else
{
out
.
put
(
"
[
2
byte
]
"
)
;
JSString
:
:
dumpChars
(
atom
-
>
twoByteChars
(
)
atom
-
>
length
(
)
out
)
;
}
}
static
void
DumpCharsNoNewline
(
ParserBase
*
parser
TaggedParserAtomIndex
index
GenericPrinter
&
out
)
{
if
(
parser
)
{
const
auto
*
atom
=
parser
-
>
getCompilationState
(
)
.
parserAtoms
.
getParserAtom
(
index
)
;
DumpCharsNoNewline
(
atom
out
)
;
}
else
{
out
.
put
(
"
\
"
"
)
;
DumpTaggedParserAtomIndexNoQuote
(
out
index
nullptr
)
;
out
.
put
(
"
\
"
"
)
;
}
}
void
LoopControlStatement
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
if
(
label_
)
{
out
.
printf
(
"
"
)
;
DumpCharsNoNewline
(
parser
label_
out
)
;
}
out
.
printf
(
"
)
"
)
;
}
void
UnaryNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
indent
+
=
strlen
(
name
)
+
2
;
DumpParseTree
(
parser
kid
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
BinaryNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
if
(
isKind
(
ParseNodeKind
:
:
DotExpr
)
)
{
out
.
put
(
"
(
.
"
)
;
DumpParseTree
(
parser
right
(
)
out
indent
+
2
)
;
out
.
putChar
(
'
'
)
;
if
(
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
out
.
put
(
"
super
"
)
;
}
else
{
DumpParseTree
(
parser
left
(
)
out
indent
+
2
)
;
}
out
.
printf
(
"
)
"
)
;
return
;
}
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
indent
+
=
strlen
(
name
)
+
2
;
DumpParseTree
(
parser
left
(
)
out
indent
)
;
IndentNewLine
(
out
indent
)
;
DumpParseTree
(
parser
right
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
TernaryNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
indent
+
=
strlen
(
name
)
+
2
;
DumpParseTree
(
parser
kid1
(
)
out
indent
)
;
IndentNewLine
(
out
indent
)
;
DumpParseTree
(
parser
kid2
(
)
out
indent
)
;
IndentNewLine
(
out
indent
)
;
DumpParseTree
(
parser
kid3
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
FunctionNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
indent
+
=
strlen
(
name
)
+
2
;
DumpParseTree
(
parser
body
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
ModuleNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
indent
+
=
strlen
(
name
)
+
2
;
DumpParseTree
(
parser
body
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
ListNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
[
"
name
)
;
if
(
ParseNode
*
listHead
=
head
(
)
)
{
indent
+
=
strlen
(
name
)
+
3
;
DumpParseTree
(
parser
listHead
out
indent
)
;
for
(
ParseNode
*
item
:
contentsFrom
(
listHead
-
>
pn_next
)
)
{
IndentNewLine
(
out
indent
)
;
DumpParseTree
(
parser
item
out
indent
)
;
}
}
out
.
printf
(
"
]
)
"
)
;
}
template
<
typename
CharT
>
static
void
DumpName
(
GenericPrinter
&
out
const
CharT
*
s
size_t
len
)
{
if
(
len
=
=
0
)
{
out
.
put
(
"
#
<
zero
-
length
name
>
"
)
;
}
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
char16_t
c
=
s
[
i
]
;
if
(
c
>
32
&
&
c
<
127
)
{
out
.
putChar
(
c
)
;
}
else
if
(
c
<
=
255
)
{
out
.
printf
(
"
\
\
x
%
02x
"
unsigned
(
c
)
)
;
}
else
{
out
.
printf
(
"
\
\
u
%
04x
"
unsigned
(
c
)
)
;
}
}
}
void
NameNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
switch
(
getKind
(
)
)
{
case
ParseNodeKind
:
:
StringExpr
:
case
ParseNodeKind
:
:
TemplateStringExpr
:
case
ParseNodeKind
:
:
ObjectPropertyName
:
DumpCharsNoNewline
(
parser
atom_
out
)
;
return
;
case
ParseNodeKind
:
:
Name
:
case
ParseNodeKind
:
:
PrivateName
:
case
ParseNodeKind
:
:
PropertyNameExpr
:
if
(
!
atom_
)
{
out
.
put
(
"
#
<
null
name
>
"
)
;
}
else
if
(
parser
)
{
const
auto
*
atom
=
parser
-
>
getCompilationState
(
)
.
parserAtoms
.
getParserAtom
(
atom_
)
;
if
(
atom
-
>
hasLatin1Chars
(
)
)
{
DumpName
(
out
atom
-
>
latin1Chars
(
)
atom
-
>
length
(
)
)
;
}
else
{
DumpName
(
out
atom
-
>
twoByteChars
(
)
atom
-
>
length
(
)
)
;
}
}
else
{
DumpTaggedParserAtomIndexNoQuote
(
out
atom_
nullptr
)
;
}
return
;
case
ParseNodeKind
:
:
LabelStmt
:
{
this
-
>
as
<
LabeledStatement
>
(
)
.
dumpImpl
(
parser
out
indent
)
;
return
;
}
default
:
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
)
"
name
)
;
return
;
}
}
}
void
LabeledStatement
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
"
name
)
;
DumpCharsNoNewline
(
parser
labelIndex
(
)
out
)
;
out
.
printf
(
"
"
)
;
indent
+
=
strlen
(
name
)
+
3
;
if
(
parser
)
{
const
auto
*
labelAtom
=
parser
-
>
getCompilationState
(
)
.
parserAtoms
.
getParserAtom
(
labelIndex
(
)
)
;
indent
+
=
labelAtom
-
>
length
(
)
;
}
DumpParseTree
(
parser
statement
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
void
LexicalScopeNode
:
:
dumpImpl
(
ParserBase
*
parser
GenericPrinter
&
out
int
indent
)
{
const
char
*
name
=
parseNodeNames
[
getKindAsIndex
(
)
]
;
out
.
printf
(
"
(
%
s
[
"
name
)
;
int
nameIndent
=
indent
+
strlen
(
name
)
+
3
;
if
(
!
isEmptyScope
(
)
)
{
LexicalScope
:
:
ParserData
*
bindings
=
scopeBindings
(
)
;
for
(
uint32_t
i
=
0
;
i
<
bindings
-
>
slotInfo
.
length
;
i
+
+
)
{
auto
index
=
bindings
-
>
trailingNames
[
i
]
.
name
(
)
;
if
(
parser
)
{
const
auto
*
name
=
parser
-
>
getCompilationState
(
)
.
parserAtoms
.
getParserAtom
(
index
)
;
if
(
name
-
>
hasLatin1Chars
(
)
)
{
DumpName
(
out
name
-
>
latin1Chars
(
)
name
-
>
length
(
)
)
;
}
else
{
DumpName
(
out
name
-
>
twoByteChars
(
)
name
-
>
length
(
)
)
;
}
}
else
{
DumpTaggedParserAtomIndexNoQuote
(
out
index
nullptr
)
;
}
if
(
i
<
bindings
-
>
slotInfo
.
length
-
1
)
{
IndentNewLine
(
out
nameIndent
)
;
}
}
}
out
.
putChar
(
'
]
'
)
;
indent
+
=
2
;
IndentNewLine
(
out
indent
)
;
DumpParseTree
(
parser
scopeBody
(
)
out
indent
)
;
out
.
printf
(
"
)
"
)
;
}
#
endif
TaggedParserAtomIndex
NumericLiteral
:
:
toAtom
(
JSContext
*
cx
ParserAtomsTable
&
parserAtoms
)
const
{
const
auto
*
atom
=
NumberToParserAtom
(
cx
parserAtoms
value
(
)
)
;
return
atom
?
atom
-
>
toIndex
(
)
:
TaggedParserAtomIndex
:
:
null
(
)
;
}
RegExpObject
*
RegExpStencil
:
:
createRegExp
(
JSContext
*
cx
const
CompilationAtomCache
&
atomCache
)
const
{
RootedAtom
atom
(
cx
atomCache
.
getExistingAtomAt
(
cx
atom_
)
)
;
return
RegExpObject
:
:
createSyntaxChecked
(
cx
atom
flags
(
)
TenuredObject
)
;
}
RegExpObject
*
RegExpStencil
:
:
createRegExpAndEnsureAtom
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
BaseCompilationStencil
&
stencil
)
const
{
const
ParserAtom
*
parserAtom
=
stencil
.
getParserAtomAt
(
cx
atom_
)
;
MOZ_ASSERT
(
parserAtom
)
;
RootedAtom
atom
(
cx
parserAtom
-
>
toJSAtom
(
cx
atomCache
)
)
;
if
(
!
atom
)
{
return
nullptr
;
}
return
RegExpObject
:
:
createSyntaxChecked
(
cx
atom
flags
(
)
TenuredObject
)
;
}
RegExpObject
*
RegExpLiteral
:
:
create
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
BaseCompilationStencil
&
stencil
)
const
{
return
stencil
.
regExpData
[
index_
]
.
createRegExpAndEnsureAtom
(
cx
atomCache
stencil
)
;
}
bool
js
:
:
frontend
:
:
IsAnonymousFunctionDefinition
(
ParseNode
*
pn
)
{
if
(
pn
-
>
is
<
FunctionNode
>
(
)
&
&
!
pn
-
>
as
<
FunctionNode
>
(
)
.
funbox
(
)
-
>
explicitName
(
)
)
{
return
true
;
}
if
(
pn
-
>
is
<
ClassNode
>
(
)
&
&
!
pn
-
>
as
<
ClassNode
>
(
)
.
names
(
)
)
{
return
true
;
}
return
false
;
}
