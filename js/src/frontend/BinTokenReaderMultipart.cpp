#
include
"
frontend
/
BinTokenReaderMultipart
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
utility
>
#
include
"
frontend
/
BinSource
-
macros
.
h
"
#
include
"
frontend
/
BinSourceRuntimeSupport
.
h
"
#
include
"
js
/
Result
.
h
"
namespace
js
{
namespace
frontend
{
const
char
MAGIC_HEADER
[
]
=
"
BINJS
"
;
const
uint32_t
MAGIC_FORMAT_VERSION
=
0
;
const
char
SECTION_HEADER_GRAMMAR
[
]
=
"
[
GRAMMAR
]
"
;
const
char
SECTION_HEADER_STRINGS
[
]
=
"
[
STRINGS
]
"
;
const
char
SECTION_HEADER_TREE
[
]
=
"
[
TREE
]
"
;
const
char
COMPRESSION_IDENTITY
[
]
=
"
identity
;
"
;
const
uint32_t
MAX_NUMBER_OF_STRINGS
=
32768
;
using
AutoList
=
BinTokenReaderMultipart
:
:
AutoList
;
using
AutoTaggedTuple
=
BinTokenReaderMultipart
:
:
AutoTaggedTuple
;
using
AutoTuple
=
BinTokenReaderMultipart
:
:
AutoTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Chars
=
BinTokenReaderMultipart
:
:
Chars
;
BinTokenReaderMultipart
:
:
BinTokenReaderMultipart
(
JSContext
*
cx
const
uint8_t
*
start
const
size_t
length
)
:
BinTokenReaderBase
(
cx
start
length
)
grammarTable_
(
cx
)
atomsTable_
(
cx
AtomVector
(
cx
)
)
slicesTable_
(
cx
)
posBeforeTree_
(
nullptr
)
{
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
readHeader
(
)
{
MOZ_ASSERT
(
!
posBeforeTree_
)
;
MOZ_TRY
(
readConst
(
MAGIC_HEADER
)
)
;
BINJS_MOZ_TRY_DECL
(
version
readInternalUint32
(
)
)
;
if
(
version
!
=
MAGIC_FORMAT_VERSION
)
{
return
raiseError
(
"
Format
version
not
implemented
"
)
;
}
MOZ_TRY
(
readConst
(
SECTION_HEADER_GRAMMAR
)
)
;
MOZ_TRY
(
readConst
(
COMPRESSION_IDENTITY
)
)
;
BINJS_MOZ_TRY_DECL
(
grammarByteLen
readInternalUint32
(
)
)
;
const
auto
posBeforeGrammar
=
current_
;
if
(
posBeforeGrammar
+
grammarByteLen
>
stop_
|
|
posBeforeGrammar
+
grammarByteLen
<
current_
)
{
return
raiseError
(
"
Invalid
byte
length
in
grammar
table
"
)
;
}
BINJS_MOZ_TRY_DECL
(
grammarNumberOfEntries
readInternalUint32
(
)
)
;
if
(
grammarNumberOfEntries
>
BINKIND_LIMIT
)
{
return
raiseError
(
"
Invalid
number
of
entries
in
grammar
table
"
)
;
}
if
(
!
grammarTable_
.
reserve
(
grammarNumberOfEntries
)
)
{
return
raiseOOM
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
grammarNumberOfEntries
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
byteLen
readInternalUint32
(
)
)
;
if
(
current_
+
byteLen
>
stop_
)
{
return
raiseError
(
"
Invalid
byte
length
in
grammar
table
"
)
;
}
if
(
current_
+
byteLen
<
current_
)
{
return
raiseError
(
"
Invalid
byte
length
in
grammar
table
"
)
;
}
CharSlice
name
(
(
const
char
*
)
current_
byteLen
)
;
current_
+
=
byteLen
;
BINJS_MOZ_TRY_DECL
(
kind
cx_
-
>
runtime
(
)
-
>
binast
(
)
.
binKind
(
cx_
name
)
)
;
if
(
!
kind
)
{
return
raiseError
(
"
Invalid
entry
in
grammar
table
"
)
;
}
grammarTable_
.
infallibleAppend
(
*
kind
)
;
}
if
(
current_
!
=
grammarByteLen
+
posBeforeGrammar
)
{
return
raiseError
(
"
The
length
of
the
grammar
table
didn
'
t
match
its
contents
.
"
)
;
}
MOZ_TRY
(
readConst
(
SECTION_HEADER_STRINGS
)
)
;
MOZ_TRY
(
readConst
(
COMPRESSION_IDENTITY
)
)
;
BINJS_MOZ_TRY_DECL
(
stringsByteLen
readInternalUint32
(
)
)
;
const
auto
posBeforeStrings
=
current_
;
if
(
posBeforeStrings
+
stringsByteLen
>
stop_
|
|
posBeforeStrings
+
stringsByteLen
<
current_
)
{
return
raiseError
(
"
Invalid
byte
length
in
strings
table
"
)
;
}
BINJS_MOZ_TRY_DECL
(
stringsNumberOfEntries
readInternalUint32
(
)
)
;
if
(
stringsNumberOfEntries
>
MAX_NUMBER_OF_STRINGS
)
{
return
raiseError
(
"
Too
many
entries
in
strings
table
"
)
;
}
if
(
!
atomsTable_
.
reserve
(
stringsNumberOfEntries
)
)
{
return
raiseOOM
(
)
;
}
if
(
!
slicesTable_
.
reserve
(
stringsNumberOfEntries
)
)
{
return
raiseOOM
(
)
;
}
RootedAtom
atom
(
cx_
)
;
for
(
uint32_t
i
=
0
;
i
<
stringsNumberOfEntries
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
byteLen
readInternalUint32
(
)
)
;
if
(
current_
+
byteLen
>
stop_
|
|
current_
+
byteLen
<
current_
)
{
return
raiseError
(
"
Invalid
byte
length
in
individual
string
"
)
;
}
if
(
byteLen
=
=
2
&
&
*
current_
=
=
255
&
&
*
(
current_
+
1
)
=
=
0
)
{
atom
=
nullptr
;
}
else
{
BINJS_TRY_VAR
(
atom
Atomize
(
cx_
(
const
char
*
)
current_
byteLen
)
)
;
}
atomsTable_
.
infallibleAppend
(
atom
)
;
Chars
slice
(
(
const
char
*
)
current_
byteLen
)
;
slicesTable_
.
infallibleAppend
(
std
:
:
move
(
slice
)
)
;
current_
+
=
byteLen
;
}
if
(
posBeforeStrings
+
stringsByteLen
!
=
current_
)
{
return
raiseError
(
"
The
length
of
the
strings
table
didn
'
t
match
its
contents
.
"
)
;
}
MOZ_TRY
(
readConst
(
SECTION_HEADER_TREE
)
)
;
MOZ_TRY
(
readConst
(
COMPRESSION_IDENTITY
)
)
;
posBeforeTree_
=
current_
;
BINJS_MOZ_TRY_DECL
(
treeByteLen
readInternalUint32
(
)
)
;
if
(
posBeforeTree_
+
treeByteLen
>
stop_
|
|
posBeforeTree_
+
treeByteLen
<
posBeforeTree_
)
{
return
raiseError
(
"
Invalid
byte
length
in
tree
table
"
)
;
}
return
Ok
(
)
;
}
JS
:
:
Result
<
bool
>
BinTokenReaderMultipart
:
:
readBool
(
)
{
updateLatestKnownGood
(
)
;
BINJS_MOZ_TRY_DECL
(
byte
readByte
(
)
)
;
switch
(
byte
)
{
case
0
:
return
false
;
case
1
:
return
true
;
case
2
:
return
raiseError
(
"
Not
implemented
:
null
boolean
value
"
)
;
default
:
return
raiseError
(
"
Invalid
boolean
value
"
)
;
}
}
JS
:
:
Result
<
double
>
BinTokenReaderMultipart
:
:
readDouble
(
)
{
updateLatestKnownGood
(
)
;
uint8_t
bytes
[
8
]
;
MOZ_ASSERT
(
sizeof
(
bytes
)
=
=
sizeof
(
double
)
)
;
MOZ_TRY
(
readBuf
(
reinterpret_cast
<
uint8_t
*
>
(
bytes
)
mozilla
:
:
ArrayLength
(
bytes
)
)
)
;
const
uint64_t
asInt
=
mozilla
:
:
LittleEndian
:
:
readUint64
(
bytes
)
;
if
(
asInt
=
=
NULL_FLOAT_REPRESENTATION
)
{
return
raiseError
(
"
Not
implemented
:
null
double
value
"
)
;
}
return
JS
:
:
CanonicalizeNaN
(
mozilla
:
:
BitwiseCast
<
double
>
(
asInt
)
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinTokenReaderMultipart
:
:
readMaybeAtom
(
)
{
updateLatestKnownGood
(
)
;
BINJS_MOZ_TRY_DECL
(
index
readInternalUint32
(
)
)
;
if
(
index
>
=
atomsTable_
.
length
(
)
)
{
return
raiseError
(
"
Invalid
index
to
strings
table
"
)
;
}
return
atomsTable_
[
index
]
.
get
(
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinTokenReaderMultipart
:
:
readAtom
(
)
{
BINJS_MOZ_TRY_DECL
(
maybe
readMaybeAtom
(
)
)
;
if
(
!
maybe
)
{
return
raiseError
(
"
Empty
string
"
)
;
}
return
maybe
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
readChars
(
Chars
&
out
)
{
updateLatestKnownGood
(
)
;
BINJS_MOZ_TRY_DECL
(
index
readInternalUint32
(
)
)
;
if
(
index
>
=
slicesTable_
.
length
(
)
)
{
return
raiseError
(
"
Invalid
index
to
strings
table
for
string
enum
"
)
;
}
out
=
slicesTable_
[
index
]
;
return
Ok
(
)
;
}
JS
:
:
Result
<
BinVariant
>
BinTokenReaderMultipart
:
:
readVariant
(
)
{
updateLatestKnownGood
(
)
;
BINJS_MOZ_TRY_DECL
(
index
readInternalUint32
(
)
)
;
if
(
index
>
=
slicesTable_
.
length
(
)
)
{
return
raiseError
(
"
Invalid
index
to
strings
table
for
string
enum
"
)
;
}
auto
variantsPtr
=
variantsTable_
.
lookupForAdd
(
index
)
;
if
(
variantsPtr
)
{
return
variantsPtr
-
>
value
(
)
;
}
Chars
slice
=
slicesTable_
[
index
]
;
BINJS_MOZ_TRY_DECL
(
variant
cx_
-
>
runtime
(
)
-
>
binast
(
)
.
binVariant
(
cx_
slice
)
)
;
if
(
!
variant
)
{
return
raiseError
(
"
Invalid
string
enum
variant
"
)
;
}
if
(
!
variantsTable_
.
add
(
variantsPtr
index
*
variant
)
)
{
return
raiseOOM
(
)
;
}
return
*
variant
;
}
JS
:
:
Result
<
BinTokenReaderBase
:
:
SkippableSubTree
>
BinTokenReaderMultipart
:
:
readSkippableSubTree
(
)
{
updateLatestKnownGood
(
)
;
BINJS_MOZ_TRY_DECL
(
byteLen
readInternalUint32
(
)
)
;
if
(
current_
+
byteLen
>
stop_
|
|
current_
+
byteLen
<
current_
)
{
return
raiseError
(
"
Invalid
byte
length
in
readSkippableSubTree
"
)
;
}
const
auto
start
=
current_
;
current_
+
=
byteLen
;
return
BinTokenReaderBase
:
:
SkippableSubTree
(
start
byteLen
)
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
enterUntaggedTuple
(
AutoTuple
&
guard
)
{
guard
.
init
(
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
enterTaggedTuple
(
BinKind
&
tag
BinTokenReaderMultipart
:
:
BinFields
&
AutoTaggedTuple
&
guard
)
{
BINJS_MOZ_TRY_DECL
(
index
readInternalUint32
(
)
)
;
if
(
index
>
=
grammarTable_
.
length
(
)
)
{
return
raiseError
(
"
Invalid
index
to
grammar
table
"
)
;
}
tag
=
grammarTable_
[
index
]
;
guard
.
init
(
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
enterList
(
uint32_t
&
items
AutoList
&
guard
)
{
guard
.
init
(
)
;
MOZ_TRY_VAR
(
items
readInternalUint32
(
)
)
;
return
Ok
(
)
;
}
void
BinTokenReaderMultipart
:
:
AutoBase
:
:
init
(
)
{
initialized_
=
true
;
}
BinTokenReaderMultipart
:
:
AutoBase
:
:
AutoBase
(
BinTokenReaderMultipart
&
reader
)
:
initialized_
(
false
)
reader_
(
reader
)
{
}
BinTokenReaderMultipart
:
:
AutoBase
:
:
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
cx_
-
>
isExceptionPending
(
)
)
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
AutoBase
:
:
checkPosition
(
const
uint8_t
*
expectedEnd
)
{
if
(
reader_
.
current_
!
=
expectedEnd
)
{
return
reader_
.
raiseError
(
"
Caller
did
not
consume
the
expected
set
of
bytes
"
)
;
}
return
Ok
(
)
;
}
BinTokenReaderMultipart
:
:
AutoList
:
:
AutoList
(
BinTokenReaderMultipart
&
reader
)
:
AutoBase
(
reader
)
{
}
void
BinTokenReaderMultipart
:
:
AutoList
:
:
init
(
)
{
AutoBase
:
:
init
(
)
;
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
AutoList
:
:
done
(
)
{
MOZ_ASSERT
(
initialized_
)
;
initialized_
=
false
;
if
(
reader_
.
cx_
-
>
isExceptionPending
(
)
)
{
return
reader_
.
cx_
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
BinTokenReaderMultipart
:
:
readInternalUint32
(
)
{
uint32_t
result
=
0
;
uint32_t
shift
=
0
;
while
(
true
)
{
MOZ_ASSERT
(
shift
<
32
)
;
uint32_t
byte
;
MOZ_TRY_VAR
(
byte
readByte
(
)
)
;
const
uint32_t
newResult
=
result
|
(
byte
>
>
1
)
<
<
shift
;
if
(
newResult
<
result
)
{
return
raiseError
(
"
Overflow
during
readInternalUint32
"
)
;
}
result
=
newResult
;
shift
+
=
7
;
if
(
(
byte
&
1
)
=
=
0
)
{
return
result
;
}
}
}
BinTokenReaderMultipart
:
:
AutoTaggedTuple
:
:
AutoTaggedTuple
(
BinTokenReaderMultipart
&
reader
)
:
AutoBase
(
reader
)
{
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
AutoTaggedTuple
:
:
done
(
)
{
MOZ_ASSERT
(
initialized_
)
;
initialized_
=
false
;
if
(
reader_
.
cx_
-
>
isExceptionPending
(
)
)
{
return
reader_
.
cx_
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
BinTokenReaderMultipart
:
:
AutoTuple
:
:
AutoTuple
(
BinTokenReaderMultipart
&
reader
)
:
AutoBase
(
reader
)
{
}
JS
:
:
Result
<
Ok
>
BinTokenReaderMultipart
:
:
AutoTuple
:
:
done
(
)
{
MOZ_ASSERT
(
initialized_
)
;
initialized_
=
false
;
if
(
reader_
.
cx_
-
>
isExceptionPending
(
)
)
{
return
reader_
.
cx_
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
}
}
