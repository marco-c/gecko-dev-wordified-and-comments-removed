#
include
"
frontend
/
BinASTTokenReaderContext
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
string
.
h
>
#
include
"
ds
/
FixedLengthVector
.
h
"
#
include
"
ds
/
Sort
.
h
"
#
include
"
frontend
/
BinAST
-
macros
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
namespace
frontend
{
#
ifdef
BINAST_CX_MAGIC_HEADER
const
char
CX_MAGIC_HEADER
[
]
=
"
\
x89
"
"
BJS
\
r
\
n
\
0
\
n
"
;
const
uint32_t
MAGIC_FORMAT_VERSION
=
2
;
#
endif
const
uint8_t
MAX_CODE_BIT_LENGTH
=
20
;
const
uint8_t
MAX_BIT_LENGTH_BIT_LENGTH
=
5
;
static_assert
(
1
<
<
(
MAX_BIT_LENGTH_BIT_LENGTH
-
1
)
<
MAX_CODE_BIT_LENGTH
"
MAX_BIT_LENGTH_BIT_LENGTH
-
1
bits
MUST
be
insufficient
to
"
"
store
MAX_CODE_BIT_LENGTH
"
)
;
static_assert
(
1
<
<
MAX_BIT_LENGTH_BIT_LENGTH
>
=
MAX_CODE_BIT_LENGTH
"
MAX_BIT_LENGTH
bits
MUST
be
sufficient
to
store
MAX_CODE_BIT_LENGTH
"
)
;
const
uint8_t
MAX_PREFIX_BIT_LENGTH
=
32
;
const
uint8_t
BIT_BUFFER_SIZE
=
64
;
const
uint8_t
BIT_BUFFER_READ_UNIT
=
8
;
const
uint32_t
MAX_NUMBER_OF_SYMBOLS
=
32768
;
const
uint32_t
MAX_LIST_LENGTH
=
std
:
:
min
(
(
uint32_t
)
32768
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
;
const
size_t
HUFFMAN_STACK_INITIAL_CAPACITY
=
1024
;
extern
const
size_t
SUM_LIMITS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
size_t
STRING_ENUM_LIMITS
[
BINASTSTRINGENUM_LIMIT
]
;
extern
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
;
using
Compression
=
BinASTTokenReaderContext
:
:
Compression
;
using
EndOfFilePolicy
=
BinASTTokenReaderContext
:
:
EndOfFilePolicy
;
#
define
WRAP_INTERFACE
(
TYPE
)
Interface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_MAYBE_INTERFACE
(
TYPE
)
MaybeInterface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_PRIMITIVE
(
TYPE
)
TYPE
#
define
WRAP_LIST
(
TYPE
_
)
List
:
:
Maker
(
BinASTList
:
:
TYPE
)
#
define
WRAP_SUM
(
TYPE
)
Sum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_MAYBE_SUM
(
TYPE
)
MaybeSum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_STRING_ENUM
(
TYPE
)
StringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
#
define
WRAP_MAYBE_STRING_ENUM
(
TYPE
)
\
MaybeStringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Chars
=
BinASTTokenReaderContext
:
:
Chars
;
class
HuffmanPreludeReader
{
public
:
HuffmanPreludeReader
(
JSContext
*
cx
BinASTTokenReaderContext
&
reader
)
:
cx_
(
cx
)
reader_
(
reader
)
dictionary_
(
nullptr
)
stack_
(
cx_
)
auxStorageLength_
(
cx_
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanDictionaryForMetadata
*
>
run
(
size_t
initialCapacity
)
;
private
:
JSContext
*
cx_
;
BinASTTokenReaderContext
&
reader_
;
UniquePtr
<
HuffmanDictionary
>
dictionary_
;
TemporaryStorage
tempStorage_
;
public
:
enum
TableHeader
:
uint8_t
{
SingleValue
=
0x00
MultipleValues
=
0x01
Unreachable
=
0x02
}
;
struct
EntryBase
{
const
NormalizedInterfaceAndField
identity_
;
explicit
EntryBase
(
const
NormalizedInterfaceAndField
identity
)
:
identity_
(
identity
)
{
}
}
;
struct
EntryIndexed
:
EntryBase
{
using
Indexed
=
Ok
;
explicit
EntryIndexed
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
EntryExplicit
:
EntryBase
{
using
Explicit
=
Ok
;
explicit
EntryExplicit
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
String
:
EntryExplicit
{
explicit
String
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
using
IdentifierName
=
String
;
using
PropertyKey
=
String
;
struct
MaybeString
:
EntryExplicit
{
explicit
MaybeString
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
using
MaybeIdentifierName
=
MaybeString
;
using
MaybePropertyKey
=
MaybeString
;
struct
Number
:
EntryExplicit
{
explicit
Number
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
UnsignedLong
:
EntryExplicit
{
explicit
UnsignedLong
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
Boolean
:
EntryIndexed
{
explicit
Boolean
(
const
NormalizedInterfaceAndField
identity
)
:
EntryIndexed
(
identity
)
{
}
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
1
)
;
MOZ_ASSERT
(
bIndex
<
=
1
)
;
return
aIndex
<
bIndex
;
}
}
;
struct
Lazy
:
EntryExplicit
{
explicit
Lazy
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
Interface
:
EntryIndexed
{
const
BinASTKind
kind_
;
Interface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryIndexed
(
identity
)
kind_
(
kind
)
{
}
struct
Maker
{
const
BinASTKind
kind_
;
explicit
Maker
(
BinASTKind
kind
)
:
kind_
(
kind
)
{
}
Interface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Interface
(
identity
kind_
)
;
}
}
;
}
;
struct
MaybeInterface
:
EntryIndexed
{
const
BinASTKind
kind_
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
1
)
;
MOZ_ASSERT
(
bIndex
<
=
1
)
;
return
aIndex
<
bIndex
;
}
MaybeInterface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryIndexed
(
identity
)
kind_
(
kind
)
{
}
size_t
maxMumberOfSymbols
(
)
const
{
return
2
;
}
struct
Maker
{
const
BinASTKind
kind_
;
explicit
Maker
(
BinASTKind
kind
)
:
kind_
(
kind
)
{
}
MaybeInterface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeInterface
(
identity
kind_
)
;
}
}
;
}
;
struct
List
:
EntryExplicit
{
const
BinASTList
contents_
;
List
(
const
NormalizedInterfaceAndField
identity
const
BinASTList
contents
)
:
EntryExplicit
(
identity
)
contents_
(
contents
)
{
}
struct
Maker
{
const
BinASTList
contents_
;
explicit
Maker
(
BinASTList
contents
)
:
contents_
(
contents
)
{
}
List
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
{
identity
contents_
}
;
}
}
;
}
;
struct
ListContents
:
EntryBase
{
explicit
ListContents
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
Sum
:
EntryIndexed
{
const
BinASTSum
contents_
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
maxNumberOfSymbols
(
)
)
;
MOZ_ASSERT
(
bIndex
<
=
maxNumberOfSymbols
(
)
)
;
const
size_t
aKey
=
getBinASTKindSortKey
(
interfaceAt
(
aIndex
)
)
;
const
size_t
bKey
=
getBinASTKindSortKey
(
interfaceAt
(
bIndex
)
)
;
return
aKey
<
bKey
;
}
Sum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryIndexed
(
identity
)
contents_
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents_
)
]
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents_
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTSum
contents_
;
explicit
Maker
(
BinASTSum
contents
)
:
contents_
(
contents
)
{
}
Sum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Sum
(
identity
contents_
)
;
}
}
;
}
;
struct
MaybeSum
:
EntryIndexed
{
const
BinASTSum
contents_
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
return
aIndex
<
bIndex
;
}
MaybeSum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryIndexed
(
identity
)
contents_
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents_
)
]
+
1
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
if
(
index
=
=
0
)
{
return
BinASTKind
:
:
_Null
;
}
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents_
)
]
[
index
-
1
]
;
}
struct
Maker
{
const
BinASTSum
contents_
;
explicit
Maker
(
BinASTSum
contents
)
:
contents_
(
contents
)
{
}
MaybeSum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeSum
(
identity
contents_
)
;
}
}
;
}
;
struct
StringEnum
:
EntryIndexed
{
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
maxNumberOfSymbols
(
)
)
;
MOZ_ASSERT
(
bIndex
<
=
maxNumberOfSymbols
(
)
)
;
const
size_t
aKey
=
getBinASTVariantSortKey
(
variantAt
(
aIndex
)
)
;
const
size_t
bKey
=
getBinASTVariantSortKey
(
variantAt
(
bIndex
)
)
;
return
aKey
<
bKey
;
}
const
BinASTStringEnum
contents_
;
StringEnum
(
const
NormalizedInterfaceAndField
identity
const
BinASTStringEnum
contents
)
:
EntryIndexed
(
identity
)
contents_
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
STRING_ENUM_LIMITS
[
static_cast
<
size_t
>
(
contents_
)
]
;
}
BinASTVariant
variantAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
STRING_ENUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents_
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTStringEnum
contents_
;
explicit
Maker
(
BinASTStringEnum
contents
)
:
contents_
(
contents
)
{
}
StringEnum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
StringEnum
(
identity
contents_
)
;
}
}
;
}
;
public
:
using
Entry
=
mozilla
:
:
Variant
<
Boolean
String
MaybeString
Number
UnsignedLong
Lazy
Interface
MaybeInterface
List
Sum
MaybeSum
StringEnum
>
;
#
ifdef
DEBUG
struct
PrintEntry
{
static
void
print
(
const
char
*
text
const
Entry
&
entry
)
{
fprintf
(
stderr
"
%
s
"
text
)
;
entry
.
match
(
PrintEntry
(
)
)
;
fprintf
(
stderr
"
\
n
"
)
;
}
void
operator
(
)
(
const
EntryBase
&
entry
)
{
fprintf
(
stderr
"
%
s
"
describeBinASTInterfaceAndField
(
entry
.
identity_
.
identity_
)
)
;
}
}
;
#
endif
private
:
Vector
<
Entry
>
stack_
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
List
&
list
)
{
const
auto
tableId
=
TableIdentity
(
list
.
contents_
)
;
if
(
dictionary_
-
>
isUnreachable
(
tableId
)
)
{
dictionary_
-
>
setInitializing
(
tableId
)
;
MOZ_TRY
(
(
readTable
<
List
>
(
tableId
list
)
)
)
;
}
const
auto
&
table
=
dictionary_
-
>
getTable
(
tableId
)
;
bool
empty
=
true
;
for
(
auto
iter
:
table
)
{
if
(
iter
-
>
toListLength
(
)
>
0
)
{
empty
=
false
;
break
;
}
}
if
(
empty
)
{
return
Ok
(
)
;
}
switch
(
list
.
contents_
)
{
#
define
WRAP_LIST_2
(
_
CONTENT
)
CONTENT
#
define
EMIT_CASE
(
LIST_NAME
_CONTENT_TYPE
_HUMAN_NAME
TYPE
)
\
case
BinASTList
:
:
LIST_NAME
:
\
return
pushValue
(
list
.
identity_
TYPE
(
list
.
identity_
)
)
;
FOR_EACH_BIN_LIST
(
EMIT_CASE
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
WRAP_LIST_2
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
WRAP_MAYBE_STRING_ENUM
)
#
undef
EMIT_CASE
#
undef
WRAP_LIST_2
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
Interface
&
interface
)
{
const
auto
tableId
=
TableIdentity
(
identity
)
;
if
(
dictionary_
-
>
isUnreachable
(
tableId
)
)
{
auto
&
table
=
dictionary_
-
>
createTable
(
tableId
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromKind
(
BinASTKind
(
interface
.
kind_
)
)
)
)
;
}
return
pushFields
(
interface
.
kind_
)
;
}
template
<
class
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
Entry
&
entry
)
{
const
auto
tableId
=
TableIdentity
(
identity
)
;
if
(
!
dictionary_
-
>
isUnreachable
(
tableId
)
)
{
return
Ok
(
)
;
}
dictionary_
-
>
setInitializing
(
tableId
)
;
BINJS_TRY
(
stack_
.
append
(
entry
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
pushFields
(
BinASTKind
tag
)
{
switch
(
tag
)
{
#
define
EMIT_FIELD
(
TAG_NAME
FIELD_NAME
FIELD_INDEX
FIELD_TYPE
_
)
\
MOZ_TRY
(
pushValue
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
\
FIELD_TYPE
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
)
)
)
;
#
define
EMIT_CASE
(
TAG_ENUM_NAME
_2
TAG_MACRO_NAME
)
\
case
BinASTKind
:
:
TAG_ENUM_NAME
:
{
\
FOR_EACH_BIN_FIELD_IN_INTERFACE_
#
#
TAG_MACRO_NAME
(
\
EMIT_FIELD
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
\
WRAP_LIST
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
\
WRAP_MAYBE_STRING_ENUM
)
;
\
break
;
\
}
FOR_EACH_BIN_KIND
(
EMIT_CASE
)
#
undef
EMIT_CASE
#
undef
EMIT_FIELD
}
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
readSymbol
(
const
Entry
&
size_t
index
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readNumberOfSymbols
(
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readSingleValueTable
(
GenericHuffmanTable
&
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readMultipleValuesTable
(
GenericHuffmanTable
&
table
Entry
entry
)
{
BINJS_MOZ_TRY_DECL
(
numberOfSymbols
readNumberOfSymbols
<
Entry
>
(
entry
)
)
;
MOZ_ASSERT
(
numberOfSymbols
<
=
MAX_NUMBER_OF_SYMBOLS
)
;
if
(
numberOfSymbols
=
=
1
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
!
=
0
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
0
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
symbol
)
)
;
return
Ok
(
)
;
}
MOZ_TRY
(
readMultipleValuesTableAndAssignCode
<
Entry
>
(
table
entry
numberOfSymbols
)
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
Explicit
>
readMultipleValuesTableAndAssignCode
(
GenericHuffmanTable
&
table
Entry
entry
uint32_t
numberOfSymbols
)
{
MOZ_ASSERT
(
auxStorageLength_
.
empty
(
)
)
;
BINJS_TRY
(
auxStorageLength_
.
reserve
(
numberOfSymbols
+
1
)
)
;
uint8_t
largestBitLength
=
0
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
=
=
0
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
if
(
bitLength
>
largestBitLength
)
{
largestBitLength
=
bitLength
;
}
auxStorageLength_
.
infallibleAppend
(
BitLengthAndIndex
(
bitLength
i
)
)
;
}
auxStorageLength_
.
infallibleAppend
(
BitLengthAndIndex
(
MAX_CODE_BIT_LENGTH
numberOfSymbols
)
)
;
uint32_t
code
=
0
;
MOZ_TRY
(
table
.
initStart
(
cx_
&
tempStorage_
numberOfSymbols
largestBitLength
)
)
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
const
auto
bitLength
=
auxStorageLength_
[
i
]
.
bitLength_
;
const
auto
nextBitLength
=
auxStorageLength_
[
i
+
1
]
.
bitLength_
;
if
(
MOZ_UNLIKELY
(
bitLength
>
nextBitLength
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
i
)
)
;
MOZ_TRY
(
table
.
addSymbol
(
i
code
bitLength
symbol
)
)
;
code
=
(
code
+
1
)
<
<
(
nextBitLength
-
bitLength
)
;
}
MOZ_TRY
(
table
.
initComplete
(
cx_
&
tempStorage_
)
)
;
auxStorageLength_
.
clear
(
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
Indexed
>
readMultipleValuesTableAndAssignCode
(
GenericHuffmanTable
&
table
Entry
entry
uint32_t
numberOfSymbols
)
{
MOZ_ASSERT
(
auxStorageLength_
.
empty
(
)
)
;
BINJS_TRY
(
auxStorageLength_
.
reserve
(
numberOfSymbols
+
1
)
)
;
uint8_t
largestBitLength
=
0
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
>
MAX_CODE_BIT_LENGTH
)
)
{
MOZ_CRASH
(
"
FIXME
:
Implement
error
"
)
;
}
if
(
bitLength
>
0
)
{
auxStorageLength_
.
infallibleAppend
(
BitLengthAndIndex
(
bitLength
i
)
)
;
if
(
bitLength
>
largestBitLength
)
{
largestBitLength
=
bitLength
;
}
}
}
if
(
auxStorageLength_
.
length
(
)
=
=
1
)
{
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
auxStorageLength_
[
0
]
.
index_
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
symbol
)
)
;
auxStorageLength_
.
clear
(
)
;
return
Ok
(
)
;
}
std
:
:
sort
(
auxStorageLength_
.
begin
(
)
auxStorageLength_
.
end
(
)
[
&
entry
]
(
const
BitLengthAndIndex
&
a
const
BitLengthAndIndex
&
b
)
-
>
bool
{
MOZ_ASSERT
(
a
.
index_
!
=
b
.
index_
)
;
if
(
a
.
bitLength_
<
b
.
bitLength_
)
{
return
true
;
}
if
(
a
.
bitLength_
>
b
.
bitLength_
)
{
return
false
;
}
return
entry
.
lessThan
(
a
.
index_
b
.
index_
)
;
}
)
;
auxStorageLength_
.
infallibleEmplaceBack
(
MAX_CODE_BIT_LENGTH
numberOfSymbols
)
;
uint32_t
code
=
0
;
MOZ_TRY
(
table
.
initStart
(
cx_
&
tempStorage_
auxStorageLength_
.
length
(
)
-
1
largestBitLength
)
)
;
for
(
size_t
i
=
0
;
i
<
auxStorageLength_
.
length
(
)
-
1
;
+
+
i
)
{
const
auto
bitLength
=
auxStorageLength_
[
i
]
.
bitLength_
;
const
auto
nextBitLength
=
auxStorageLength_
[
i
+
1
]
.
bitLength_
;
MOZ_ASSERT
(
bitLength
>
0
)
;
MOZ_ASSERT
(
bitLength
<
=
nextBitLength
)
;
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
auxStorageLength_
[
i
]
.
index_
)
)
;
MOZ_TRY
(
table
.
addSymbol
(
i
code
bitLength
symbol
)
)
;
code
=
(
code
+
1
)
<
<
(
nextBitLength
-
bitLength
)
;
}
MOZ_TRY
(
table
.
initComplete
(
cx_
&
tempStorage_
)
)
;
auxStorageLength_
.
clear
(
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
Entry
entry
)
{
const
auto
tableId
=
TableIdentity
(
entry
.
identity_
)
;
if
(
MOZ_UNLIKELY
(
!
dictionary_
-
>
isInitializing
(
tableId
)
)
)
{
return
raiseDuplicateTableError
(
entry
.
identity_
)
;
}
return
readTable
<
Entry
>
(
tableId
entry
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
TableIdentity
tableId
Entry
entry
)
{
uint8_t
headerByte
;
MOZ_TRY_VAR
(
headerByte
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
switch
(
headerByte
)
{
case
TableHeader
:
:
SingleValue
:
{
auto
&
table
=
dictionary_
-
>
createTable
(
tableId
)
;
MOZ_TRY
(
(
readSingleValueTable
<
Entry
>
(
table
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
MultipleValues
:
{
auto
&
table
=
dictionary_
-
>
createTable
(
tableId
)
;
MOZ_TRY
(
(
readMultipleValuesTable
<
Entry
>
(
table
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
Unreachable
:
return
Ok
(
)
;
default
:
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
}
private
:
struct
BitLengthAndIndex
{
BitLengthAndIndex
(
uint8_t
bitLength
size_t
index
)
:
bitLength_
(
bitLength
)
index_
(
index
)
{
}
uint8_t
bitLength_
;
size_t
index_
;
}
;
Vector
<
BitLengthAndIndex
>
auxStorageLength_
;
struct
ReadPoppedEntryMatcher
{
HuffmanPreludeReader
&
owner
;
explicit
ReadPoppedEntryMatcher
(
HuffmanPreludeReader
&
owner
)
:
owner
(
owner
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Lazy
&
entry
)
{
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Boolean
&
entry
)
{
return
owner
.
readTable
<
Boolean
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Interface
&
entry
)
{
return
owner
.
pushFields
(
entry
.
kind_
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeInterface
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeInterface
>
(
entry
)
)
)
;
const
auto
tableId
=
TableIdentity
(
entry
.
identity_
)
;
if
(
owner
.
dictionary_
-
>
isUnreachable
(
tableId
)
)
{
return
Ok
(
)
;
}
const
auto
&
table
=
owner
.
dictionary_
-
>
getTable
(
tableId
)
;
if
(
!
table
.
isMaybeInterfaceAlwaysNull
(
)
)
{
MOZ_TRY
(
owner
.
pushFields
(
entry
.
kind_
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Sum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
Sum
>
(
entry
)
)
)
;
const
auto
tableId
=
TableIdentity
(
entry
.
identity_
)
;
if
(
owner
.
dictionary_
-
>
isInitializing
(
tableId
)
)
{
return
Ok
(
)
;
}
auto
index
=
entry
.
identity_
;
const
auto
&
table
=
owner
.
dictionary_
-
>
getTable
(
tableId
)
;
for
(
auto
iter
:
table
)
{
MOZ_TRY
(
owner
.
pushValue
(
index
Interface
(
index
iter
-
>
toKind
(
)
)
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeSum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeSum
>
(
entry
)
)
)
;
const
auto
tableId
=
TableIdentity
(
entry
.
identity_
)
;
if
(
owner
.
dictionary_
-
>
isUnreachable
(
tableId
)
)
{
return
Ok
(
)
;
}
auto
index
=
entry
.
identity_
;
const
auto
&
table
=
owner
.
dictionary_
-
>
getTable
(
tableId
)
;
for
(
auto
iter
:
table
)
{
MOZ_TRY
(
owner
.
pushValue
(
index
Interface
(
index
iter
-
>
toKind
(
)
)
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Number
&
entry
)
{
return
owner
.
readTable
<
Number
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
String
&
entry
)
{
return
owner
.
readTable
<
String
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeString
&
entry
)
{
return
owner
.
readTable
<
MaybeString
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
StringEnum
&
entry
)
{
return
owner
.
readTable
<
StringEnum
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
UnsignedLong
&
entry
)
{
return
owner
.
readTable
<
UnsignedLong
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
List
&
)
{
MOZ_CRASH
(
"
Unreachable
"
)
;
return
Ok
(
)
;
}
}
;
template
<
typename
T
>
using
ErrorResult
=
BinASTTokenReaderBase
:
:
ErrorResult
<
T
>
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseDuplicateTableError
(
const
NormalizedInterfaceAndField
identity
)
{
return
reader_
.
raiseError
(
"
Duplicate
table
.
"
)
;
}
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidTableData
(
const
NormalizedInterfaceAndField
identity
)
{
return
reader_
.
raiseError
(
"
Invalid
data
while
reading
table
.
"
)
;
}
}
;
using
Boolean
=
HuffmanPreludeReader
:
:
Boolean
;
using
Interface
=
HuffmanPreludeReader
:
:
Interface
;
using
List
=
HuffmanPreludeReader
:
:
List
;
using
MaybeInterface
=
HuffmanPreludeReader
:
:
MaybeInterface
;
using
MaybeString
=
HuffmanPreludeReader
:
:
MaybeString
;
using
MaybeSum
=
HuffmanPreludeReader
:
:
MaybeSum
;
using
Number
=
HuffmanPreludeReader
:
:
Number
;
using
String
=
HuffmanPreludeReader
:
:
String
;
using
StringEnum
=
HuffmanPreludeReader
:
:
StringEnum
;
using
Sum
=
HuffmanPreludeReader
:
:
Sum
;
using
UnsignedLong
=
HuffmanPreludeReader
:
:
UnsignedLong
;
BinASTTokenReaderContext
:
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
BinASTTokenReaderBase
(
cx
er
start
length
)
metadata_
(
nullptr
)
posBeforeTree_
(
nullptr
)
{
MOZ_ASSERT
(
er
)
;
}
BinASTTokenReaderContext
:
:
~
BinASTTokenReaderContext
(
)
{
if
(
metadata_
&
&
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
{
UniqueBinASTSourceMetadataPtr
ptr
(
metadata_
)
;
}
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
BestEffort
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
len
=
std
:
:
min
(
(
uint32_t
)
(
stop_
-
current_
)
len
)
;
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
RaiseError
>
(
)
{
return
raiseError
(
"
Unexpected
end
of
stream
"
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
BestEffort
>
(
)
{
return
Ok
(
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
Compression
:
:
No
>
(
)
{
return
Base
:
:
readByte
(
)
;
}
BinASTSourceMetadata
*
BinASTTokenReaderContext
:
:
takeMetadata
(
)
{
MOZ_ASSERT
(
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
metadata_
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
initFromScriptSource
(
ScriptSource
*
scriptSource
)
{
metadata_
=
scriptSource
-
>
binASTSourceMetadata
(
)
-
>
asContext
(
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHeader
(
)
{
MOZ_ASSERT
(
!
posBeforeTree_
)
;
#
if
BINAST_CX_MAGIC_HEADER
MOZ_TRY
(
readConst
(
CX_MAGIC_HEADER
)
)
;
BINJS_MOZ_TRY_DECL
(
version
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
version
!
=
MAGIC_FORMAT_VERSION
)
)
{
return
raiseError
(
"
Format
version
not
implemented
"
)
;
}
#
endif
MOZ_TRY
(
readStringPrelude
(
)
)
;
MOZ_TRY
(
readHuffmanPrelude
(
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readStringPrelude
(
)
{
BINJS_MOZ_TRY_DECL
(
stringsNumberOfEntries
readVarU32
<
Compression
:
:
No
>
(
)
)
;
const
uint32_t
MAX_NUMBER_OF_STRINGS
=
32768
;
if
(
MOZ_UNLIKELY
(
stringsNumberOfEntries
>
MAX_NUMBER_OF_STRINGS
)
)
{
return
raiseError
(
"
Too
many
entries
in
strings
dictionary
"
)
;
}
BinASTSourceMetadataContext
*
metadata
=
BinASTSourceMetadataContext
:
:
create
(
stringsNumberOfEntries
)
;
if
(
MOZ_UNLIKELY
(
!
metadata
)
)
{
return
raiseOOM
(
)
;
}
auto
se
=
mozilla
:
:
MakeScopeExit
(
[
metadata
]
(
)
{
js_free
(
metadata
)
;
}
)
;
RootedAtom
atom
(
cx_
)
;
for
(
uint32_t
stringIndex
=
0
;
stringIndex
<
stringsNumberOfEntries
;
stringIndex
+
+
)
{
if
(
MOZ_UNLIKELY
(
current_
>
=
stop_
)
)
{
return
raiseError
(
"
End
of
file
reached
while
reading
strings
table
"
)
;
}
const
uint8_t
*
end
=
static_cast
<
const
uint8_t
*
>
(
memchr
(
current_
'
\
0
'
stop_
-
current_
)
)
;
if
(
MOZ_UNLIKELY
(
!
end
)
)
{
return
raiseError
(
"
Invalid
string
missing
NUL
"
)
;
}
const
char
*
start
=
reinterpret_cast
<
const
char
*
>
(
current_
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
start
end
-
current_
)
)
;
metadata
-
>
getAtom
(
stringIndex
)
=
atom
;
current_
=
end
+
1
;
}
MOZ_ASSERT
(
!
metadata_
)
;
se
.
release
(
)
;
metadata_
=
metadata
;
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHuffmanPrelude
(
)
{
HuffmanPreludeReader
reader
(
cx_
*
this
)
;
BINJS_MOZ_TRY_DECL
(
dictionary
reader
.
run
(
HUFFMAN_STACK_INITIAL_CAPACITY
)
)
;
metadata_
-
>
setDictionary
(
dictionary
)
;
return
Ok
(
)
;
}
BinASTTokenReaderContext
:
:
BitBuffer
:
:
BitBuffer
(
)
:
bits_
(
0
)
bitLength_
(
0
)
{
static_assert
(
sizeof
(
bits_
)
*
8
=
=
BIT_BUFFER_SIZE
"
Expecting
bitBuffer
to
match
BIT_BUFFER_SIZE
"
)
;
}
template
<
Compression
C
>
JS
:
:
Result
<
HuffmanLookup
>
BinASTTokenReaderContext
:
:
BitBuffer
:
:
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
{
if
(
bitLength_
<
=
MAX_PREFIX_BIT_LENGTH
)
{
uint8_t
bytes
[
8
]
=
{
}
;
uint32_t
bytesInBits
=
(
bitLength_
+
BIT_BUFFER_READ_UNIT
-
1
)
/
BIT_BUFFER_READ_UNIT
;
uint32_t
readLen
=
sizeof
(
bytes
)
-
bytesInBits
;
MOZ_TRY
(
(
owner
.
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
BestEffort
>
(
bytes
readLen
)
)
)
;
uint64_t
newBits
=
(
static_cast
<
uint64_t
>
(
bytes
[
0
]
)
<
<
56
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
1
]
)
<
<
48
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
2
]
)
<
<
40
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
3
]
)
<
<
32
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
4
]
)
<
<
24
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
5
]
)
<
<
16
)
|
(
static_cast
<
uint64_t
>
(
bytes
[
6
]
)
<
<
8
)
|
static_cast
<
uint64_t
>
(
bytes
[
7
]
)
;
static_assert
(
sizeof
(
bytes
)
=
=
sizeof
(
newBits
)
"
Expecting
bytes
array
to
match
size
of
newBits
"
)
;
newBits
>
>
=
(
BIT_BUFFER_READ_UNIT
*
(
sizeof
(
bytes
)
-
readLen
)
)
;
newBits
=
(
(
newBits
>
>
1
)
&
0x5555555555555555
)
|
(
(
newBits
&
0x5555555555555555
)
<
<
1
)
;
newBits
=
(
(
newBits
>
>
2
)
&
0x3333333333333333
)
|
(
(
newBits
&
0x3333333333333333
)
<
<
2
)
;
newBits
=
(
(
newBits
>
>
4
)
&
0x0F0F0F0F0F0F0F0F
)
|
(
(
newBits
&
0x0F0F0F0F0F0F0F0F
)
<
<
4
)
;
bitLength_
+
=
(
BIT_BUFFER_READ_UNIT
*
readLen
)
;
if
(
readLen
!
=
8
)
{
bits_
<
<
=
(
BIT_BUFFER_READ_UNIT
*
readLen
)
;
bits_
+
=
newBits
;
}
else
{
bits_
=
newBits
;
}
if
(
bitLength_
<
=
MAX_PREFIX_BIT_LENGTH
)
{
return
HuffmanLookup
(
bits_
bitLength_
)
;
}
}
const
uint64_t
bitPrefix
=
bits_
>
>
(
bitLength_
-
MAX_PREFIX_BIT_LENGTH
)
;
MOZ_ASSERT
(
bitPrefix
<
=
uint32_t
(
-
1
)
)
;
return
HuffmanLookup
(
bitPrefix
MAX_PREFIX_BIT_LENGTH
)
;
}
template
<
>
void
BinASTTokenReaderContext
:
:
BitBuffer
:
:
advanceBitBuffer
<
Compression
:
:
No
>
(
const
uint8_t
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
bitLength_
)
;
bitLength_
-
=
bitLength
;
const
uint64_t
mask
=
bitLength_
=
=
0
?
0
:
uint64_t
(
-
1
)
>
>
(
BIT_BUFFER_SIZE
-
bitLength_
)
;
bits_
&
=
mask
;
MOZ_ASSERT_IF
(
bitLength_
!
=
BIT_BUFFER_SIZE
bits_
>
>
bitLength_
=
=
0
)
;
}
void
BinASTTokenReaderContext
:
:
traceMetadata
(
JSTracer
*
trc
)
{
if
(
metadata_
)
{
metadata_
-
>
trace
(
trc
)
;
}
}
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
BinASTTokenReaderContext
:
:
raiseInvalidValue
(
)
{
errorReporter_
-
>
errorNoOffset
(
JSMSG_BINAST
"
Invalid
value
"
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
BinASTTokenReaderContext
:
:
raiseNotInPrelude
(
)
{
errorReporter_
-
>
errorNoOffset
(
JSMSG_BINAST
"
Value
is
not
in
prelude
"
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
struct
ExtractBinASTInterfaceAndFieldMatcher
{
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
context
)
{
return
context
.
position_
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
ListContext
&
context
)
{
return
context
.
position_
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
RootContext
&
)
{
MOZ_CRASH
(
"
The
root
context
has
no
interface
/
field
"
)
;
}
}
;
JS
:
:
Result
<
BinASTKind
>
BinASTTokenReaderContext
:
:
readTagFromTable
(
const
BinASTInterfaceAndField
&
identity
)
{
const
auto
tableId
=
TableIdentity
(
NormalizedInterfaceAndField
(
identity
)
)
;
const
auto
&
table
=
metadata_
-
>
dictionary
(
)
-
>
getTable
(
tableId
)
;
BINJS_MOZ_TRY_DECL
(
bits_
(
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
)
;
const
auto
result
=
table
.
lookup
(
bits_
)
;
if
(
MOZ_UNLIKELY
(
!
result
.
isFound
(
)
)
)
{
return
raiseInvalidValue
(
)
;
}
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
result
.
bitLength
(
)
)
;
return
result
.
value
(
)
.
toKind
(
)
;
}
JS
:
:
Result
<
BinASTSymbol
>
BinASTTokenReaderContext
:
:
readFieldFromTable
(
const
BinASTInterfaceAndField
&
identity
)
{
const
auto
tableId
=
TableIdentity
(
NormalizedInterfaceAndField
(
identity
)
)
;
if
(
!
metadata_
-
>
dictionary
(
)
-
>
isReady
(
tableId
)
)
{
return
raiseNotInPrelude
(
)
;
}
const
auto
&
table
=
metadata_
-
>
dictionary
(
)
-
>
getTable
(
tableId
)
;
BINJS_MOZ_TRY_DECL
(
bits_
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
;
const
auto
result
=
table
.
lookup
(
bits_
)
;
if
(
MOZ_UNLIKELY
(
!
result
.
isFound
(
)
)
)
{
return
raiseInvalidValue
(
)
;
}
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
result
.
bitLength
(
)
)
;
return
result
.
value
(
)
;
}
JS
:
:
Result
<
bool
>
BinASTTokenReaderContext
:
:
readBool
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
return
result
.
toBool
(
)
;
}
JS
:
:
Result
<
double
>
BinASTTokenReaderContext
:
:
readDouble
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
return
result
.
toDouble
(
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeAtom
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
if
(
result
.
isNullAtom
(
)
)
{
return
nullptr
;
}
return
metadata_
-
>
getAtom
(
result
.
toAtomIndex
(
)
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readAtom
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
MOZ_ASSERT
(
!
result
.
isNullAtom
(
)
)
;
return
metadata_
-
>
getAtom
(
result
.
toAtomIndex
(
)
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeIdentifierName
(
const
FieldContext
&
context
)
{
return
readMaybeAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readIdentifierName
(
const
FieldContext
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readPropertyKey
(
const
FieldContext
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readChars
(
Chars
&
out
const
FieldContext
&
)
{
return
raiseError
(
"
readChars
is
not
implemented
in
BinASTTokenReaderContext
"
)
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
ListContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
return
result
.
toVariant
(
)
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
return
result
.
toVariant
(
)
;
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnsignedLong
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
(
context
.
position_
)
)
;
return
result
.
toUnsignedLong
(
)
;
}
JS
:
:
Result
<
BinASTTokenReaderBase
:
:
SkippableSubTree
>
BinASTTokenReaderContext
:
:
readSkippableSubTree
(
const
FieldContext
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterSum
(
BinASTKind
&
tag
const
FieldOrRootContext
&
context
)
{
return
context
.
match
(
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
asFieldContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asFieldContext
.
position_
)
)
;
return
Ok
(
)
;
}
[
&
tag
]
(
const
BinASTTokenReaderBase
:
:
RootContext
&
)
-
>
JS
:
:
Result
<
Ok
>
{
tag
=
BinASTKind
:
:
Script
;
return
Ok
(
)
;
}
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterSum
(
BinASTKind
&
tag
const
FieldOrListContext
&
context
)
{
return
context
.
match
(
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
asFieldContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asFieldContext
.
position_
)
)
;
return
Ok
(
)
;
}
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
ListContext
&
asListContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asListContext
.
position_
)
)
;
return
Ok
(
)
;
}
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterSum
(
BinASTKind
&
tag
const
RootContext
&
context
)
{
tag
=
BinASTKind
:
:
Script
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterSum
(
BinASTKind
&
tag
const
ListContext
&
context
)
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
context
.
position_
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterSum
(
BinASTKind
&
tag
const
FieldContext
&
context
)
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
context
.
position_
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterList
(
uint32_t
&
items
const
ListContext
&
context
)
{
const
auto
tableId
=
TableIdentity
(
context
.
content_
)
;
const
auto
&
table
=
metadata_
-
>
dictionary
(
)
-
>
getTable
(
tableId
)
;
BINJS_MOZ_TRY_DECL
(
bits_
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
;
const
auto
result
=
table
.
lookup
(
bits_
)
;
if
(
MOZ_UNLIKELY
(
!
result
.
isFound
(
)
)
)
{
return
raiseInvalidValue
(
)
;
}
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
result
.
bitLength
(
)
)
;
items
=
result
.
value
(
)
.
toListLength
(
)
;
return
Ok
(
)
;
}
template
<
Compression
compression
>
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readVarU32
(
)
{
uint32_t
result
=
0
;
uint32_t
shift
=
0
;
while
(
true
)
{
MOZ_ASSERT
(
shift
<
32
)
;
uint32_t
byte
;
MOZ_TRY_VAR
(
byte
readByte
<
compression
>
(
)
)
;
const
uint32_t
newResult
=
result
|
(
byte
&
0x7f
)
<
<
shift
;
if
(
MOZ_UNLIKELY
(
newResult
<
result
)
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
result
=
newResult
;
shift
+
=
7
;
if
(
(
byte
&
0x80
)
=
=
0
)
{
return
result
;
}
if
(
MOZ_UNLIKELY
(
shift
>
=
32
)
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
}
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnpackedLong
(
)
{
uint8_t
bytes
[
4
]
;
uint32_t
length
=
4
;
MOZ_TRY
(
(
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
bytes
length
)
)
)
;
const
uint32_t
result
=
uint32_t
(
bytes
[
0
]
)
<
<
24
|
uint32_t
(
bytes
[
1
]
)
<
<
16
|
uint32_t
(
bytes
[
2
]
)
<
<
8
|
uint32_t
(
bytes
[
3
]
)
;
return
result
;
}
HuffmanKey
:
:
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits_
(
bits
)
bitLength_
(
bitLength
)
{
MOZ_ASSERT
(
bitLength_
<
=
MAX_PREFIX_BIT_LENGTH
)
;
MOZ_ASSERT_IF
(
bitLength_
!
=
32
bits
>
>
bitLength
=
=
0
)
;
}
template
<
typename
T
>
T
*
TemporaryStorageItem
<
T
>
:
:
alloc
(
JSContext
*
cx
size_t
count
)
{
total_
+
=
count
;
if
(
MOZ_LIKELY
(
head_
)
)
{
if
(
MOZ_LIKELY
(
head_
-
>
used_
+
count
<
head_
-
>
size_
)
)
{
T
*
ret
=
head_
-
>
entries_
+
head_
-
>
used_
;
head_
-
>
used_
+
=
count
;
return
ret
;
}
}
size_t
chunkSize
=
Chunk
:
:
DefaultSize
;
if
(
count
>
chunkSize
)
{
chunkSize
=
count
;
}
Chunk
*
chunk
=
reinterpret_cast
<
Chunk
*
>
(
cx
-
>
template
maybe_pod_malloc
<
uint8_t
>
(
sizeof
(
Chunk
)
-
sizeof
(
T
)
+
chunkSize
*
sizeof
(
T
)
)
)
;
if
(
!
chunk
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
chunk
-
>
used_
=
count
;
chunk
-
>
size_
=
chunkSize
;
chunk
-
>
next_
=
head_
;
head_
=
chunk
;
return
head_
-
>
entries_
;
}
template
<
typename
T
>
JS
:
:
Result
<
mozilla
:
:
Span
<
T
>
>
TemporaryStorage
:
:
alloc
(
JSContext
*
cx
size_t
count
)
{
MOZ_CRASH
(
"
unsupported
type
"
)
;
return
nullptr
;
}
template
<
>
JS
:
:
Result
<
mozilla
:
:
Span
<
HuffmanEntry
>
>
TemporaryStorage
:
:
alloc
<
HuffmanEntry
>
(
JSContext
*
cx
size_t
count
)
{
auto
*
items
=
huffmanEntries_
.
alloc
(
cx
count
)
;
if
(
!
items
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
mozilla
:
:
MakeSpan
(
items
count
)
;
}
template
<
>
JS
:
:
Result
<
mozilla
:
:
Span
<
TemporaryStorage
:
:
InternalIndex
>
>
TemporaryStorage
:
:
alloc
<
TemporaryStorage
:
:
InternalIndex
>
(
JSContext
*
cx
size_t
count
)
{
auto
*
items
=
internalIndices_
.
alloc
(
cx
count
)
;
if
(
!
items
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
mozilla
:
:
MakeSpan
(
items
count
)
;
}
template
<
>
JS
:
:
Result
<
mozilla
:
:
Span
<
SingleLookupHuffmanTable
>
>
TemporaryStorage
:
:
alloc
<
SingleLookupHuffmanTable
>
(
JSContext
*
cx
size_t
count
)
{
auto
*
items
=
singleTables_
.
alloc
(
cx
count
)
;
if
(
!
items
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
mozilla
:
:
MakeSpan
(
items
count
)
;
}
template
<
>
JS
:
:
Result
<
mozilla
:
:
Span
<
TwoLookupsHuffmanTable
>
>
TemporaryStorage
:
:
alloc
<
TwoLookupsHuffmanTable
>
(
JSContext
*
cx
size_t
count
)
{
auto
*
items
=
twoTables_
.
alloc
(
cx
count
)
;
if
(
!
items
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
mozilla
:
:
MakeSpan
(
items
count
)
;
}
GenericHuffmanTable
:
:
Iterator
:
:
Iterator
(
typename
SingleEntryHuffmanTable
:
:
Iterator
&
&
iterator
)
:
implementation_
(
std
:
:
move
(
iterator
)
)
{
}
GenericHuffmanTable
:
:
Iterator
:
:
Iterator
(
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
&
iterator
)
:
implementation_
(
std
:
:
move
(
iterator
)
)
{
}
GenericHuffmanTable
:
:
Iterator
:
:
Iterator
(
typename
SingleLookupHuffmanTable
:
:
Iterator
&
&
iterator
)
:
implementation_
(
std
:
:
move
(
iterator
)
)
{
}
GenericHuffmanTable
:
:
Iterator
:
:
Iterator
(
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
&
iterator
)
:
implementation_
(
std
:
:
move
(
iterator
)
)
{
}
GenericHuffmanTable
:
:
Iterator
:
:
Iterator
(
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
&
iterator
)
:
implementation_
(
std
:
:
move
(
iterator
)
)
{
}
void
GenericHuffmanTable
:
:
Iterator
:
:
operator
+
+
(
)
{
implementation_
.
match
(
[
]
(
typename
SingleEntryHuffmanTable
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
SingleLookupHuffmanTable
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
)
;
}
bool
GenericHuffmanTable
:
:
Iterator
:
:
operator
=
=
(
const
GenericHuffmanTable
:
:
Iterator
&
other
)
const
{
return
implementation_
.
match
(
[
other
]
(
const
typename
SingleEntryHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation_
.
template
as
<
typename
SingleEntryHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation_
.
template
as
<
typename
TwoEntriesHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
SingleLookupHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation_
.
template
as
<
typename
SingleLookupHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation_
.
template
as
<
typename
TwoLookupsHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation_
.
template
as
<
typename
ThreeLookupsHuffmanTable
:
:
Iterator
>
(
)
;
}
)
;
}
bool
GenericHuffmanTable
:
:
Iterator
:
:
operator
!
=
(
const
GenericHuffmanTable
:
:
Iterator
&
other
)
const
{
return
implementation_
.
match
(
[
other
]
(
const
typename
SingleEntryHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation_
.
template
as
<
typename
SingleEntryHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation_
.
template
as
<
typename
TwoEntriesHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
SingleLookupHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation_
.
template
as
<
typename
SingleLookupHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation_
.
template
as
<
typename
TwoLookupsHuffmanTable
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation_
.
template
as
<
typename
ThreeLookupsHuffmanTable
:
:
Iterator
>
(
)
;
}
)
;
}
const
BinASTSymbol
*
GenericHuffmanTable
:
:
Iterator
:
:
operator
*
(
)
const
{
return
implementation_
.
match
(
[
]
(
const
typename
SingleEntryHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
SingleLookupHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
)
;
}
const
BinASTSymbol
*
GenericHuffmanTable
:
:
Iterator
:
:
operator
-
>
(
)
const
{
return
implementation_
.
match
(
[
]
(
const
typename
SingleEntryHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
-
>
(
)
;
}
[
]
(
const
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
-
>
(
)
;
}
[
]
(
const
typename
SingleLookupHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
-
>
(
)
;
}
[
]
(
const
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
-
>
(
)
;
}
[
]
(
const
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
-
>
(
)
;
}
)
;
}
GenericHuffmanTable
:
:
GenericHuffmanTable
(
)
:
implementation_
(
TableImplementationUninitialized
{
}
)
{
}
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
:
:
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
{
return
implementation_
.
match
(
[
]
(
SingleEntryHuffmanTable
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
SingleEntryHuffmanTable
shouldn
'
t
have
multiple
entries
!
"
)
;
}
[
cx
tempStorage
]
(
TwoEntriesHuffmanTable
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
cx
tempStorage
)
;
}
[
cx
tempStorage
]
(
SingleLookupHuffmanTable
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
cx
tempStorage
)
;
}
[
cx
tempStorage
]
(
TwoLookupsHuffmanTable
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
cx
tempStorage
)
;
}
[
cx
tempStorage
]
(
ThreeLookupsHuffmanTable
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
cx
tempStorage
)
;
}
[
]
(
TableImplementationUninitialized
&
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
typename
GenericHuffmanTable
:
:
Iterator
GenericHuffmanTable
:
:
begin
(
)
const
{
return
implementation_
.
match
(
[
]
(
const
SingleEntryHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
TwoEntriesHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
SingleLookupHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
TwoLookupsHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
ThreeLookupsHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
TableImplementationUninitialized
&
)
-
>
GenericHuffmanTable
:
:
Iterator
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
typename
GenericHuffmanTable
:
:
Iterator
GenericHuffmanTable
:
:
end
(
)
const
{
return
implementation_
.
match
(
[
]
(
const
SingleEntryHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
TwoEntriesHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
SingleLookupHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
TwoLookupsHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
ThreeLookupsHuffmanTable
&
implementation
)
-
>
GenericHuffmanTable
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
TableImplementationUninitialized
&
)
-
>
GenericHuffmanTable
:
:
Iterator
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
:
:
initWithSingleValue
(
JSContext
*
cx
const
BinASTSymbol
&
value
)
{
MOZ_ASSERT
(
implementation_
.
template
is
<
TableImplementationUninitialized
>
(
)
)
;
implementation_
=
{
mozilla
:
:
VariantType
<
SingleEntryHuffmanTable
>
{
}
value
}
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
:
:
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
static_assert
(
MAX_CODE_BIT_LENGTH
<
=
ThreeLookupsHuffmanTable
:
:
MAX_BIT_LENGTH
"
ThreeLookupsHuffmanTable
cannot
hold
all
bit
lengths
"
)
;
MOZ_ASSERT
(
implementation_
.
template
is
<
TableImplementationUninitialized
>
(
)
)
;
MOZ_ASSERT
(
numberOfSymbols
!
=
1
"
Should
have
used
initWithSingleValue
instead
"
)
;
if
(
numberOfSymbols
=
=
2
)
{
implementation_
=
{
mozilla
:
:
VariantType
<
TwoEntriesHuffmanTable
>
{
}
}
;
return
implementation_
.
template
as
<
TwoEntriesHuffmanTable
>
(
)
.
initStart
(
cx
tempStorage
numberOfSymbols
largestBitLength
)
;
}
if
(
largestBitLength
<
=
SingleLookupHuffmanTable
:
:
MAX_BIT_LENGTH
)
{
implementation_
=
{
mozilla
:
:
VariantType
<
SingleLookupHuffmanTable
>
{
}
SingleLookupHuffmanTable
:
:
Use
:
:
ToplevelTable
}
;
return
implementation_
.
template
as
<
SingleLookupHuffmanTable
>
(
)
.
initStart
(
cx
tempStorage
numberOfSymbols
largestBitLength
)
;
}
if
(
largestBitLength
<
=
TwoLookupsHuffmanTable
:
:
MAX_BIT_LENGTH
)
{
implementation_
=
{
mozilla
:
:
VariantType
<
TwoLookupsHuffmanTable
>
{
}
}
;
return
implementation_
.
template
as
<
TwoLookupsHuffmanTable
>
(
)
.
initStart
(
cx
tempStorage
numberOfSymbols
largestBitLength
)
;
}
implementation_
=
{
mozilla
:
:
VariantType
<
ThreeLookupsHuffmanTable
>
{
}
}
;
return
implementation_
.
template
as
<
ThreeLookupsHuffmanTable
>
(
)
.
initStart
(
cx
tempStorage
numberOfSymbols
largestBitLength
)
;
}
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
:
:
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
{
return
implementation_
.
match
(
[
]
(
SingleEntryHuffmanTable
&
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
SingleEntryHuffmanTable
shouldn
'
t
have
multiple
entries
!
"
)
;
return
Ok
(
)
;
}
[
index
bits
bitLength
value
]
(
TwoEntriesHuffmanTable
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
index
bits
bitLength
value
)
;
}
[
index
bits
bitLength
value
]
(
SingleLookupHuffmanTable
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
index
bits
bitLength
value
)
;
}
[
index
bits
bitLength
value
]
(
TwoLookupsHuffmanTable
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
index
bits
bitLength
value
)
;
}
[
index
bits
bitLength
value
=
value
]
(
ThreeLookupsHuffmanTable
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
index
bits
bitLength
value
)
;
}
[
]
(
TableImplementationUninitialized
&
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
return
Ok
(
)
;
}
)
;
}
HuffmanLookupResult
GenericHuffmanTable
:
:
lookup
(
HuffmanLookup
key
)
const
{
return
implementation_
.
match
(
[
key
]
(
const
SingleEntryHuffmanTable
&
implementation
)
-
>
HuffmanLookupResult
{
return
implementation
.
lookup
(
key
)
;
}
[
key
]
(
const
TwoEntriesHuffmanTable
&
implementation
)
-
>
HuffmanLookupResult
{
return
implementation
.
lookup
(
key
)
;
}
[
key
]
(
const
SingleLookupHuffmanTable
&
implementation
)
-
>
HuffmanLookupResult
{
return
implementation
.
lookup
(
key
)
;
}
[
key
]
(
const
TwoLookupsHuffmanTable
&
implementation
)
-
>
HuffmanLookupResult
{
return
implementation
.
lookup
(
key
)
;
}
[
key
]
(
const
ThreeLookupsHuffmanTable
&
implementation
)
-
>
HuffmanLookupResult
{
return
implementation
.
lookup
(
key
)
;
}
[
]
(
const
TableImplementationUninitialized
&
)
-
>
HuffmanLookupResult
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
size_t
GenericHuffmanTable
:
:
length
(
)
const
{
return
implementation_
.
match
(
[
]
(
const
SingleEntryHuffmanTable
&
implementation
)
-
>
size_t
{
return
implementation
.
length
(
)
;
}
[
]
(
const
TwoEntriesHuffmanTable
&
implementation
)
-
>
size_t
{
return
implementation
.
length
(
)
;
}
[
]
(
const
SingleLookupHuffmanTable
&
implementation
)
-
>
size_t
{
return
implementation
.
length
(
)
;
}
[
]
(
const
TwoLookupsHuffmanTable
&
implementation
)
-
>
size_t
{
return
implementation
.
length
(
)
;
}
[
]
(
const
ThreeLookupsHuffmanTable
&
implementation
)
-
>
size_t
{
return
implementation
.
length
(
)
;
}
[
]
(
const
TableImplementationUninitialized
&
implementation
)
-
>
size_t
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
SingleEntryHuffmanTable
:
:
Iterator
:
:
Iterator
(
const
BinASTSymbol
*
position
)
:
position_
(
position
)
{
}
void
SingleEntryHuffmanTable
:
:
Iterator
:
:
operator
+
+
(
)
{
position_
=
nullptr
;
}
const
BinASTSymbol
*
SingleEntryHuffmanTable
:
:
Iterator
:
:
operator
*
(
)
const
{
return
position_
;
}
const
BinASTSymbol
*
SingleEntryHuffmanTable
:
:
Iterator
:
:
operator
-
>
(
)
const
{
return
position_
;
}
bool
SingleEntryHuffmanTable
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position_
=
=
other
.
position_
;
}
bool
SingleEntryHuffmanTable
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position_
!
=
other
.
position_
;
}
HuffmanLookupResult
SingleEntryHuffmanTable
:
:
lookup
(
HuffmanLookup
key
)
const
{
return
HuffmanLookupResult
:
:
found
(
0
&
value_
)
;
}
TwoEntriesHuffmanTable
:
:
Iterator
:
:
Iterator
(
const
BinASTSymbol
*
position
)
:
position_
(
position
)
{
}
void
TwoEntriesHuffmanTable
:
:
Iterator
:
:
operator
+
+
(
)
{
position_
+
+
;
}
const
BinASTSymbol
*
TwoEntriesHuffmanTable
:
:
Iterator
:
:
operator
*
(
)
const
{
return
position_
;
}
const
BinASTSymbol
*
TwoEntriesHuffmanTable
:
:
Iterator
:
:
operator
-
>
(
)
const
{
return
position_
;
}
bool
TwoEntriesHuffmanTable
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position_
=
=
other
.
position_
;
}
bool
TwoEntriesHuffmanTable
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position_
!
=
other
.
position_
;
}
JS
:
:
Result
<
Ok
>
TwoEntriesHuffmanTable
:
:
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
MOZ_ASSERT
(
numberOfSymbols
=
=
2
)
;
MOZ_ASSERT
(
largestBitLength
=
=
1
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
TwoEntriesHuffmanTable
:
:
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
{
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
TwoEntriesHuffmanTable
:
:
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
{
MOZ_ASSERT_IF
(
index
=
=
0
bits
=
=
0
)
;
MOZ_ASSERT_IF
(
index
=
=
1
bits
=
=
1
)
;
MOZ_ASSERT
(
bitLength
=
=
1
)
;
values_
[
index
]
=
value
;
return
Ok
(
)
;
}
HuffmanLookupResult
TwoEntriesHuffmanTable
:
:
lookup
(
HuffmanLookup
key
)
const
{
const
auto
index
=
key
.
leadingBits
(
1
)
;
return
HuffmanLookupResult
:
:
found
(
1
&
values_
[
index
]
)
;
}
SingleLookupHuffmanTable
:
:
Iterator
:
:
Iterator
(
const
HuffmanEntry
*
position
)
:
position_
(
position
)
{
}
void
SingleLookupHuffmanTable
:
:
Iterator
:
:
operator
+
+
(
)
{
position_
+
+
;
}
const
BinASTSymbol
*
SingleLookupHuffmanTable
:
:
Iterator
:
:
operator
*
(
)
const
{
return
&
position_
-
>
value
(
)
;
}
const
BinASTSymbol
*
SingleLookupHuffmanTable
:
:
Iterator
:
:
operator
-
>
(
)
const
{
return
&
position_
-
>
value
(
)
;
}
bool
SingleLookupHuffmanTable
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position_
=
=
other
.
position_
;
}
bool
SingleLookupHuffmanTable
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position_
!
=
other
.
position_
;
}
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
:
:
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
MOZ_ASSERT_IF
(
largestBitLength
!
=
32
(
uint32_t
(
1
)
<
<
largestBitLength
)
-
1
<
=
mozilla
:
:
MaxValue
<
InternalIndex
>
:
:
value
)
;
largestBitLength_
=
largestBitLength
;
MOZ_TRY_VAR
(
values_
tempStorage
-
>
alloc
<
HuffmanEntry
>
(
cx
numberOfSymbols
)
)
;
const
size_t
saturatedLength
=
1
<
<
largestBitLength_
;
MOZ_TRY_VAR
(
saturated_
tempStorage
-
>
alloc
<
InternalIndex
>
(
cx
saturatedLength
)
)
;
for
(
size_t
i
=
0
;
i
<
saturatedLength
;
+
+
i
)
{
saturated_
[
i
]
=
InternalIndex
(
-
1
)
;
}
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
:
:
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
{
MOZ_ASSERT
(
largestBitLength_
<
=
MAX_CODE_BIT_LENGTH
)
;
if
(
values_
.
size
(
)
=
=
0
)
{
MOZ_ASSERT
(
largestBitLength_
=
=
0
)
;
return
Ok
(
)
;
}
#
ifdef
DEBUG
bool
foundMaxBitLength
=
false
;
for
(
size_t
i
=
0
;
i
<
saturated_
.
size
(
)
;
+
+
i
)
{
const
uint8_t
index
=
saturated_
[
i
]
;
if
(
use_
!
=
Use
:
:
ToplevelTable
)
{
if
(
index
>
=
values_
.
size
(
)
)
{
continue
;
}
}
MOZ_ASSERT
(
values_
[
index
]
.
key
(
)
.
bitLength_
<
=
largestBitLength_
)
;
if
(
values_
[
index
]
.
key
(
)
.
bitLength_
=
=
largestBitLength_
)
{
foundMaxBitLength
=
true
;
}
}
MOZ_ASSERT
(
foundMaxBitLength
)
;
#
endif
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
:
:
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
{
MOZ_ASSERT_IF
(
largestBitLength_
!
=
0
bitLength
!
=
0
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
MOZ_ASSERT
(
bitLength
<
=
largestBitLength_
)
;
new
(
mozilla
:
:
KnownNotNull
&
values_
[
index
]
)
HuffmanEntry
(
bits
bitLength
value
)
;
const
HuffmanLookup
base
(
bits
bitLength
)
;
for
(
size_t
i
:
base
.
suffixes
(
largestBitLength_
)
)
{
saturated_
[
i
]
=
index
;
}
return
Ok
(
)
;
}
HuffmanLookupResult
SingleLookupHuffmanTable
:
:
lookup
(
HuffmanLookup
key
)
const
{
if
(
values_
.
size
(
)
=
=
0
)
{
return
HuffmanLookupResult
:
:
notFound
(
)
;
}
const
uint32_t
bits
=
key
.
leadingBits
(
largestBitLength_
)
;
const
size_t
index
=
saturated_
[
bits
]
;
if
(
index
>
=
values_
.
size
(
)
)
{
MOZ_ASSERT
(
use_
=
=
Use
:
:
ShortKeys
)
;
return
HuffmanLookupResult
:
:
notFound
(
)
;
}
const
auto
&
entry
=
values_
[
index
]
;
return
HuffmanLookupResult
:
:
found
(
entry
.
key
(
)
.
bitLength_
&
entry
.
value
(
)
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
Iterator
(
const
HuffmanEntry
*
position
)
:
position_
(
position
)
{
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
void
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
+
+
(
)
{
position_
+
+
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
const
BinASTSymbol
*
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
*
(
)
const
{
return
&
position_
-
>
value
(
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
const
BinASTSymbol
*
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
-
>
(
)
const
{
return
&
position_
-
>
value
(
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
bool
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position_
=
=
other
.
position_
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
bool
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position_
!
=
other
.
position_
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
static_assert
(
PrefixBitLength
<
MAX_CODE_BIT_LENGTH
"
Invalid
PrefixBitLength
"
)
;
largestBitLength_
=
largestBitLength
;
MOZ_TRY_VAR
(
values_
tempStorage
-
>
alloc
<
HuffmanEntry
>
(
cx
numberOfSymbols
)
)
;
auto
numTables
=
1
<
<
PrefixBitLength
;
MOZ_TRY_VAR
(
suffixTables_
tempStorage
-
>
alloc
<
Subtable
>
(
cx
numTables
)
)
;
return
Ok
(
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
{
MOZ_ASSERT_IF
(
largestBitLength_
!
=
0
bitLength
!
=
0
)
;
MOZ_ASSERT
(
index
=
=
0
|
|
values_
[
index
-
1
]
.
key
(
)
.
bitLength_
<
=
bitLength
"
Symbols
must
be
ranked
by
increasing
bits
length
"
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
new
(
mozilla
:
:
KnownNotNull
&
values_
[
index
]
)
HuffmanEntry
(
bits
bitLength
value
)
;
return
Ok
(
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
{
struct
Bucket
{
Bucket
(
)
:
largestBitLength_
(
0
)
numberOfSymbols_
(
0
)
{
}
;
uint8_t
largestBitLength_
;
uint32_t
numberOfSymbols_
;
void
addSymbol
(
uint8_t
bitLength
)
{
+
+
numberOfSymbols_
;
if
(
bitLength
>
largestBitLength_
)
{
largestBitLength_
=
bitLength
;
}
}
}
;
FixedLengthVector
<
Bucket
>
buckets
;
if
(
!
buckets
.
allocate
(
cx
1
<
<
PrefixBitLength
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
Bucket
shortKeysBucket
;
for
(
const
auto
&
entry
:
values_
)
{
if
(
entry
.
key
(
)
.
bitLength_
<
=
SingleLookupHuffmanTable
:
:
MAX_BIT_LENGTH
)
{
shortKeysBucket
.
addSymbol
(
entry
.
key
(
)
.
bitLength_
)
;
continue
;
}
const
HuffmanLookup
lookup
(
entry
.
key
(
)
.
bits_
entry
.
key
(
)
.
bitLength_
)
;
const
auto
split
=
lookup
.
split
(
PrefixBitLength
)
;
MOZ_ASSERT_IF
(
split
.
suffix_
.
bitLength_
!
=
32
split
.
suffix_
.
bits_
>
>
split
.
suffix_
.
bitLength_
=
=
0
)
;
for
(
const
auto
index
:
lookup
.
suffixes
(
PrefixBitLength
)
)
{
Bucket
&
bucket
=
buckets
[
index
]
;
bucket
.
addSymbol
(
split
.
suffix_
.
bitLength_
)
;
}
}
FixedLengthVector
<
size_t
>
suffixTablesIndices
;
if
(
MOZ_UNLIKELY
(
!
suffixTablesIndices
.
allocateUninitialized
(
cx
suffixTables_
.
size
(
)
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
size_t
i
=
0
;
for
(
auto
&
bucket
:
buckets
)
{
new
(
mozilla
:
:
KnownNotNull
&
suffixTables_
[
i
]
)
Subtable
(
)
;
suffixTablesIndices
[
i
]
=
0
;
if
(
bucket
.
numberOfSymbols_
!
=
0
)
{
MOZ_TRY
(
suffixTables_
[
i
]
.
initStart
(
cx
tempStorage
bucket
.
numberOfSymbols_
bucket
.
largestBitLength_
)
)
;
}
i
+
+
;
}
MOZ_TRY
(
shortKeys_
.
initStart
(
cx
tempStorage
shortKeysBucket
.
numberOfSymbols_
shortKeysBucket
.
largestBitLength_
)
)
;
size_t
shortKeysIndex
=
0
;
for
(
size_t
i
=
0
;
i
<
values_
.
size
(
)
;
+
+
i
)
{
const
auto
&
entry
=
values_
[
i
]
;
if
(
entry
.
key
(
)
.
bitLength_
<
=
SingleLookupHuffmanTable
:
:
MAX_BIT_LENGTH
)
{
MOZ_TRY
(
shortKeys_
.
addSymbol
(
shortKeysIndex
+
+
entry
.
key
(
)
.
bits_
entry
.
key
(
)
.
bitLength_
BinASTSymbol
:
:
fromSubtableIndex
(
i
)
)
)
;
continue
;
}
const
HuffmanLookup
lookup
(
entry
.
key
(
)
.
bits_
entry
.
key
(
)
.
bitLength_
)
;
const
auto
split
=
lookup
.
split
(
PrefixBitLength
)
;
MOZ_ASSERT_IF
(
split
.
suffix_
.
bitLength_
!
=
32
split
.
suffix_
.
bits_
>
>
split
.
suffix_
.
bitLength_
=
=
0
)
;
for
(
const
auto
index
:
lookup
.
suffixes
(
PrefixBitLength
)
)
{
auto
&
sub
=
suffixTables_
[
index
]
;
MOZ_TRY
(
sub
.
addSymbol
(
suffixTablesIndices
[
index
]
+
+
split
.
suffix_
.
bits_
split
.
suffix_
.
bitLength_
BinASTSymbol
:
:
fromSubtableIndex
(
i
)
)
)
;
}
}
MOZ_TRY
(
shortKeys_
.
initComplete
(
cx
tempStorage
)
)
;
for
(
size_t
i
=
0
;
i
<
buckets
.
length
(
)
;
+
+
i
)
{
if
(
buckets
[
i
]
.
numberOfSymbols_
=
=
0
)
{
continue
;
}
auto
&
sub
=
suffixTables_
[
i
]
;
MOZ_TRY
(
sub
.
initComplete
(
cx
tempStorage
)
)
;
}
return
Ok
(
)
;
}
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
HuffmanLookupResult
MultiLookupHuffmanTable
<
Subtable
PrefixBitLength
>
:
:
lookup
(
HuffmanLookup
key
)
const
{
{
auto
subResult
=
shortKeys_
.
lookup
(
key
)
;
if
(
subResult
.
isFound
(
)
)
{
const
auto
&
result
=
values_
[
subResult
.
value
(
)
.
toSubtableIndex
(
)
]
;
return
HuffmanLookupResult
:
:
found
(
result
.
key
(
)
.
bitLength_
&
result
.
value
(
)
)
;
}
}
const
auto
split
=
key
.
split
(
PrefixBitLength
)
;
if
(
split
.
prefix_
.
bits_
>
=
suffixTables_
.
size
(
)
)
{
return
HuffmanLookupResult
:
:
notFound
(
)
;
}
const
Subtable
&
subtable
=
suffixTables_
[
split
.
prefix_
.
bits_
]
;
auto
subResult
=
subtable
.
lookup
(
split
.
suffix_
)
;
if
(
!
subResult
.
isFound
(
)
)
{
return
HuffmanLookupResult
:
:
notFound
(
)
;
}
const
auto
&
result
=
values_
[
subResult
.
value
(
)
.
toSubtableIndex
(
)
]
;
return
HuffmanLookupResult
:
:
found
(
result
.
key
(
)
.
bitLength_
&
result
.
value
(
)
)
;
}
const
size_t
SUM_LIMITS
[
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
BINAST_SUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
#
define
WITH_SUM_CONTENTS
(
_SUM_NAME
_INDEX
INTERFACE_NAME
_MACRO_NAME
\
_SPEC_NAME
)
\
BinASTKind
:
:
INTERFACE_NAME
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
const
BinASTKind
SUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_INTERFACE_IN_SUM_
#
#
MACRO_NAME
(
WITH_SUM_CONTENTS
)
}
;
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
#
undef
WITH_SUM_CONTENTS
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
SUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
const
size_t
STRING_ENUM_LIMITS
[
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
BIN_AST_STRING_ENUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
#
define
WITH_ENUM_CONTENTS
(
_ENUM_NAME
VARIANT_NAME
_HUMAN_NAME
)
\
BinASTVariant
:
:
VARIANT_NAME
#
define
WITH_ENUM
(
_ENUM_NAME
_
MACRO_NAME
)
\
const
BinASTVariant
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_VARIANT_IN_STRING_ENUM_
#
#
MACRO_NAME
#
#
_BY_WEBIDL_ORDER
(
\
WITH_ENUM_CONTENTS
)
}
;
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
#
undef
WITH_ENUM_CONTENTS
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanDictionaryForMetadata
*
>
HuffmanPreludeReader
:
:
run
(
size_t
initialCapacity
)
{
BINJS_TRY
(
stack_
.
reserve
(
initialCapacity
)
)
;
dictionary_
.
reset
(
cx_
-
>
new_
<
HuffmanDictionary
>
(
)
)
;
BINJS_TRY
(
dictionary_
)
;
MOZ_TRY
(
pushFields
(
BinASTKind
:
:
Script
)
)
;
while
(
stack_
.
length
(
)
>
0
)
{
const
Entry
entry
=
stack_
.
popCopy
(
)
;
MOZ_TRY
(
entry
.
match
(
ReadPoppedEntryMatcher
(
*
this
)
)
)
;
}
auto
dictForMetadata
=
HuffmanDictionaryForMetadata
:
:
createFrom
(
dictionary_
.
get
(
)
&
tempStorage_
)
;
if
(
!
dictForMetadata
)
{
ReportOutOfMemory
(
cx_
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
return
dictForMetadata
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Boolean
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Boolean
&
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
BinASTSymbol
:
:
fromBool
(
index
!
=
0
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Boolean
>
(
GenericHuffmanTable
&
table
const
Boolean
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
indexByte
>
=
2
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromBool
(
indexByte
!
=
0
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeInterface
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeInterface
&
entry
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
BinASTSymbol
:
:
fromKind
(
index
=
=
0
?
BinASTKind
:
:
_Null
:
entry
.
kind_
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeInterface
>
(
GenericHuffmanTable
&
table
const
MaybeInterface
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader_
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
indexByte
>
=
2
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromKind
(
indexByte
=
=
0
?
BinASTKind
:
:
_Null
:
entry
.
kind_
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Sum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Sum
&
entry
size_t
index
)
{
MOZ_ASSERT
(
index
<
entry
.
maxNumberOfSymbols
(
)
)
;
return
BinASTSymbol
:
:
fromKind
(
entry
.
interfaceAt
(
index
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Sum
>
(
GenericHuffmanTable
&
table
const
Sum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
sum
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromKind
(
sum
.
interfaceAt
(
index
)
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeSum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeSum
&
sum
size_t
index
)
{
MOZ_ASSERT
(
index
<
sum
.
maxNumberOfSymbols
(
)
)
;
return
BinASTSymbol
:
:
fromKind
(
sum
.
interfaceAt
(
index
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeSum
>
(
GenericHuffmanTable
&
table
const
MaybeSum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
sum
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromKind
(
sum
.
interfaceAt
(
index
)
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
number
.
identity_
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Number
&
number
size_t
)
{
uint8_t
bytes
[
8
]
;
MOZ_ASSERT
(
sizeof
(
bytes
)
=
=
sizeof
(
double
)
)
;
uint32_t
len
=
mozilla
:
:
ArrayLength
(
bytes
)
;
MOZ_TRY
(
(
reader_
.
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
reinterpret_cast
<
uint8_t
*
>
(
bytes
)
len
)
)
)
;
const
uint64_t
asInt
=
mozilla
:
:
BigEndian
:
:
readUint64
(
bytes
)
;
return
BinASTSymbol
:
:
fromDouble
(
JS
:
:
CanonicalizeNaN
(
mozilla
:
:
BitwiseCast
<
double
>
(
asInt
)
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Number
>
(
GenericHuffmanTable
&
table
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
value
readSymbol
(
number
0
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
value
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
List
&
list
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
list
.
identity_
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
List
&
list
size_t
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readUnpackedLong
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_LIST_LENGTH
)
)
{
return
raiseInvalidTableData
(
list
.
identity_
)
;
}
return
BinASTSymbol
:
:
fromListLength
(
length
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
List
>
(
GenericHuffmanTable
&
table
const
List
&
list
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readUnpackedLong
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_LIST_LENGTH
)
)
{
return
raiseInvalidTableData
(
list
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromListLength
(
length
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
String
&
string
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
|
|
length
>
reader_
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
string
.
identity_
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
String
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader_
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
return
BinASTSymbol
:
:
fromAtomIndex
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
String
>
(
GenericHuffmanTable
&
table
const
String
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader_
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromAtomIndex
(
index
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeString
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
|
|
length
>
reader_
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeString
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
index
=
=
0
)
{
return
BinASTSymbol
:
:
nullAtom
(
)
;
}
if
(
MOZ_UNLIKELY
(
index
>
reader_
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
return
BinASTSymbol
:
:
fromAtomIndex
(
index
-
1
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeString
>
(
GenericHuffmanTable
&
table
const
MaybeString
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader_
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
if
(
index
=
=
0
)
{
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
nullAtom
(
)
)
)
;
}
else
{
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromAtomIndex
(
index
-
1
)
)
)
;
}
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
StringEnum
&
entry
)
{
return
entry
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
StringEnum
&
entry
size_t
index
)
{
return
BinASTSymbol
:
:
fromVariant
(
entry
.
variantAt
(
index
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
StringEnum
>
(
GenericHuffmanTable
&
table
const
StringEnum
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
entry
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
BinASTVariant
symbol
=
entry
.
variantAt
(
index
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromVariant
(
symbol
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
UnsignedLong
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
length
reader_
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
entry
.
identity_
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
HuffmanPreludeReader
:
:
readSymbol
(
const
UnsignedLong
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
result
reader_
.
readUnpackedLong
(
)
)
;
return
BinASTSymbol
:
:
fromUnsignedLong
(
result
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
UnsignedLong
>
(
GenericHuffmanTable
&
table
const
UnsignedLong
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader_
.
readUnpackedLong
(
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
BinASTSymbol
:
:
fromUnsignedLong
(
index
)
)
)
;
return
Ok
(
)
;
}
HuffmanDictionaryForMetadata
:
:
~
HuffmanDictionaryForMetadata
(
)
{
for
(
size_t
i
=
0
;
i
<
numTables_
;
i
+
+
)
{
tablesBase
(
)
[
i
]
.
~
GenericHuffmanTable
(
)
;
}
for
(
size_t
i
=
0
;
i
<
numSingleTables_
;
i
+
+
)
{
singleTablesBase
(
)
[
i
]
.
~
SingleLookupHuffmanTable
(
)
;
}
for
(
size_t
i
=
0
;
i
<
numTwoTables_
;
i
+
+
)
{
twoTablesBase
(
)
[
i
]
.
~
TwoLookupsHuffmanTable
(
)
;
}
}
HuffmanDictionaryForMetadata
*
HuffmanDictionaryForMetadata
:
:
createFrom
(
HuffmanDictionary
*
dictionary
TemporaryStorage
*
tempStorage
)
{
size_t
numTables
=
dictionary
-
>
numTables
(
)
;
size_t
numHuffmanEntries
=
tempStorage
-
>
numHuffmanEntries
(
)
;
size_t
numInternalIndices
=
tempStorage
-
>
numInternalIndices
(
)
;
while
(
numInternalIndices
*
sizeof
(
InternalIndex
)
%
sizeof
(
uintptr_t
)
!
=
0
)
{
numInternalIndices
+
+
;
}
size_t
numSingleTables
=
tempStorage
-
>
numSingleTables
(
)
;
size_t
numTwoTables
=
tempStorage
-
>
numTwoTables
(
)
;
HuffmanDictionaryForMetadata
*
data
=
static_cast
<
HuffmanDictionaryForMetadata
*
>
(
js_malloc
(
totalSize
(
numTables
numHuffmanEntries
numInternalIndices
numSingleTables
numTwoTables
)
)
)
;
if
(
MOZ_UNLIKELY
(
!
data
)
)
{
return
nullptr
;
}
new
(
mozilla
:
:
KnownNotNull
data
)
HuffmanDictionaryForMetadata
(
numTables
numHuffmanEntries
numInternalIndices
numSingleTables
numTwoTables
)
;
data
-
>
moveFrom
(
dictionary
tempStorage
)
;
return
data
;
}
void
HuffmanDictionaryForMetadata
:
:
moveFrom
(
HuffmanDictionary
*
dictionary
TemporaryStorage
*
tempStorage
)
{
for
(
size_t
i
=
0
;
i
<
TableIdentity
:
:
Limit
;
i
+
+
)
{
if
(
dictionary
-
>
status_
[
i
]
=
=
HuffmanDictionary
:
:
TableStatus
:
:
Ready
)
{
tableIndices_
[
i
]
=
dictionary
-
>
tableIndices_
[
i
]
;
}
}
auto
tablePtr
=
tablesBase
(
)
;
auto
huffmanEntryPtr
=
huffmanEntriesBase
(
)
;
auto
internalIndexPtr
=
internalIndicesBase
(
)
;
auto
singleTablePtr
=
singleTablesBase
(
)
;
auto
twoTablePtr
=
twoTablesBase
(
)
;
auto
moveSingleTableContent
=
[
&
huffmanEntryPtr
&
internalIndexPtr
]
(
SingleLookupHuffmanTable
&
table
)
{
{
size_t
size
=
table
.
values_
.
size
(
)
;
memmove
(
huffmanEntryPtr
.
get
(
)
table
.
values_
.
data
(
)
sizeof
(
HuffmanEntry
)
*
size
)
;
table
.
values_
=
mozilla
:
:
MakeSpan
(
huffmanEntryPtr
.
get
(
)
size
)
;
huffmanEntryPtr
+
=
size
;
}
{
size_t
size
=
table
.
saturated_
.
size
(
)
;
memmove
(
internalIndexPtr
.
get
(
)
table
.
saturated_
.
data
(
)
sizeof
(
InternalIndex
)
*
size
)
;
table
.
saturated_
=
mozilla
:
:
MakeSpan
(
internalIndexPtr
.
get
(
)
size
)
;
internalIndexPtr
+
=
size
;
}
}
;
auto
moveTwoTableContent
=
[
&
huffmanEntryPtr
&
singleTablePtr
moveSingleTableContent
]
(
TwoLookupsHuffmanTable
&
table
)
{
moveSingleTableContent
(
table
.
shortKeys_
)
;
{
size_t
size
=
table
.
values_
.
size
(
)
;
memmove
(
huffmanEntryPtr
.
get
(
)
table
.
values_
.
data
(
)
sizeof
(
HuffmanEntry
)
*
size
)
;
table
.
values_
=
mozilla
:
:
MakeSpan
(
huffmanEntryPtr
.
get
(
)
size
)
;
huffmanEntryPtr
+
=
size
;
}
{
size_t
size
=
table
.
suffixTables_
.
size
(
)
;
auto
head
=
singleTablePtr
.
get
(
)
;
for
(
auto
&
fromSubTable
:
table
.
suffixTables_
)
{
memmove
(
singleTablePtr
.
get
(
)
&
fromSubTable
sizeof
(
SingleLookupHuffmanTable
)
)
;
auto
&
toSubTable
=
*
singleTablePtr
;
singleTablePtr
+
+
;
moveSingleTableContent
(
toSubTable
)
;
}
table
.
suffixTables_
=
mozilla
:
:
MakeSpan
(
head
size
)
;
}
}
;
auto
moveThreeTableContent
=
[
&
huffmanEntryPtr
&
twoTablePtr
moveSingleTableContent
moveTwoTableContent
]
(
ThreeLookupsHuffmanTable
&
table
)
{
moveSingleTableContent
(
table
.
shortKeys_
)
;
{
size_t
size
=
table
.
values_
.
size
(
)
;
memmove
(
huffmanEntryPtr
.
get
(
)
table
.
values_
.
data
(
)
sizeof
(
HuffmanEntry
)
*
size
)
;
table
.
values_
=
mozilla
:
:
MakeSpan
(
huffmanEntryPtr
.
get
(
)
size
)
;
huffmanEntryPtr
+
=
size
;
}
{
size_t
size
=
table
.
suffixTables_
.
size
(
)
;
auto
head
=
twoTablePtr
.
get
(
)
;
for
(
auto
&
fromSubTable
:
table
.
suffixTables_
)
{
memmove
(
twoTablePtr
.
get
(
)
&
fromSubTable
sizeof
(
TwoLookupsHuffmanTable
)
)
;
auto
&
toSubTable
=
*
twoTablePtr
;
twoTablePtr
+
+
;
moveTwoTableContent
(
toSubTable
)
;
}
table
.
suffixTables_
=
mozilla
:
:
MakeSpan
(
head
size
)
;
}
}
;
for
(
size_t
i
=
0
;
i
<
numTables_
;
i
+
+
)
{
auto
&
fromTable
=
dictionary
-
>
tableAtIndex
(
i
)
;
if
(
fromTable
.
implementation_
.
is
<
SingleEntryHuffmanTable
>
(
)
|
|
fromTable
.
implementation_
.
is
<
TwoEntriesHuffmanTable
>
(
)
)
{
memmove
(
tablePtr
.
get
(
)
&
fromTable
sizeof
(
GenericHuffmanTable
)
)
;
tablePtr
+
+
;
}
else
if
(
fromTable
.
implementation_
.
is
<
SingleLookupHuffmanTable
>
(
)
)
{
memmove
(
tablePtr
.
get
(
)
&
fromTable
sizeof
(
GenericHuffmanTable
)
)
;
auto
&
specialized
=
tablePtr
-
>
implementation_
.
as
<
SingleLookupHuffmanTable
>
(
)
;
tablePtr
+
+
;
moveSingleTableContent
(
specialized
)
;
}
else
if
(
fromTable
.
implementation_
.
is
<
TwoLookupsHuffmanTable
>
(
)
)
{
memmove
(
tablePtr
.
get
(
)
&
fromTable
sizeof
(
GenericHuffmanTable
)
)
;
auto
&
specialized
=
tablePtr
-
>
implementation_
.
as
<
TwoLookupsHuffmanTable
>
(
)
;
tablePtr
+
+
;
moveTwoTableContent
(
specialized
)
;
}
else
{
MOZ_ASSERT
(
fromTable
.
implementation_
.
is
<
ThreeLookupsHuffmanTable
>
(
)
)
;
memmove
(
tablePtr
.
get
(
)
&
fromTable
sizeof
(
GenericHuffmanTable
)
)
;
auto
&
specialized
=
tablePtr
-
>
implementation_
.
as
<
ThreeLookupsHuffmanTable
>
(
)
;
tablePtr
+
+
;
moveThreeTableContent
(
specialized
)
;
}
}
}
size_t
HuffmanDictionaryForMetadata
:
:
totalSize
(
size_t
numTables
size_t
numHuffmanEntries
size_t
numInternalIndices
size_t
numSingleTables
size_t
numTwoTables
)
{
static_assert
(
alignof
(
GenericHuffmanTable
)
%
sizeof
(
uintptr_t
)
=
=
0
"
should
be
aligned
to
pointer
size
"
)
;
static_assert
(
alignof
(
HuffmanEntry
)
%
sizeof
(
uintptr_t
)
=
=
0
"
should
be
aligned
to
pointer
size
"
)
;
static_assert
(
alignof
(
SingleLookupHuffmanTable
)
%
sizeof
(
uintptr_t
)
=
=
0
"
should
be
aligned
to
pointer
size
"
)
;
static_assert
(
alignof
(
TwoLookupsHuffmanTable
)
%
sizeof
(
uintptr_t
)
=
=
0
"
should
be
aligned
to
pointer
size
"
)
;
MOZ_ASSERT
(
numInternalIndices
*
sizeof
(
InternalIndex
)
%
sizeof
(
uintptr_t
)
=
=
0
)
;
return
sizeof
(
HuffmanDictionaryForMetadata
)
+
numTables
*
sizeof
(
GenericHuffmanTable
)
+
numHuffmanEntries
*
sizeof
(
HuffmanEntry
)
+
numInternalIndices
*
sizeof
(
InternalIndex
)
+
numSingleTables
*
sizeof
(
SingleLookupHuffmanTable
)
+
numTwoTables
*
sizeof
(
TwoLookupsHuffmanTable
)
;
}
HuffmanDictionary
:
:
~
HuffmanDictionary
(
)
{
for
(
size_t
i
=
0
;
i
<
nextIndex_
;
i
+
+
)
{
tableAtIndex
(
i
)
.
~
GenericHuffmanTable
(
)
;
}
}
uint32_t
HuffmanLookup
:
:
leadingBits
(
const
uint8_t
aBitLength
)
const
{
MOZ_ASSERT
(
aBitLength
<
=
bitLength_
)
;
const
uint32_t
result
=
(
aBitLength
=
=
0
)
?
0
:
bits_
>
>
uint32_t
(
bitLength_
-
aBitLength
)
;
return
result
;
}
Split
<
HuffmanLookup
>
HuffmanLookup
:
:
split
(
const
uint8_t
prefixLength
)
const
{
if
(
bitLength_
<
=
prefixLength
)
{
return
{
{
bits_
<
<
(
prefixLength
-
bitLength_
)
prefixLength
}
{
0
0
}
}
;
}
const
uint8_t
shift
=
bitLength_
-
prefixLength
;
switch
(
shift
)
{
case
0
:
return
{
{
bits_
prefixLength
}
{
0
0
}
}
;
case
32
:
return
{
{
0
prefixLength
}
{
bits_
shift
}
}
;
}
return
{
{
bits_
>
>
shift
prefixLength
}
{
bits_
&
(
mozilla
:
:
MaxValue
<
uint32_t
>
:
:
value
>
>
(
32
-
shift
)
)
shift
}
}
;
}
mozilla
:
:
detail
:
:
IntegerRange
<
size_t
>
HuffmanLookup
:
:
suffixes
(
uint8_t
expectedBitLength
)
const
{
if
(
expectedBitLength
<
=
bitLength_
)
{
const
uint8_t
shearing
=
bitLength_
-
expectedBitLength
;
const
size_t
first
=
size_t
(
bits_
)
>
>
shearing
;
const
size_t
last
=
first
;
return
mozilla
:
:
IntegerRange
<
size_t
>
(
first
last
+
1
)
;
}
const
uint8_t
padding
=
expectedBitLength
-
bitLength_
;
const
size_t
first
=
bits_
<
<
padding
;
const
size_t
last
=
first
+
(
size_t
(
-
1
)
>
>
(
8
*
sizeof
(
size_t
)
-
padding
)
)
;
return
mozilla
:
:
IntegerRange
<
size_t
>
(
first
last
+
1
)
;
}
}
}
