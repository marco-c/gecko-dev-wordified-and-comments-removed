#
include
"
frontend
/
BinASTTokenReaderContext
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
string
.
h
>
#
include
"
frontend
/
BinAST
-
macros
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
namespace
frontend
{
const
char
CX_MAGIC_HEADER
[
]
=
"
\
x89
"
"
BJS
\
r
\
n
\
0
\
n
"
;
const
uint32_t
MAGIC_FORMAT_VERSION
=
2
;
using
AutoList
=
BinASTTokenReaderContext
:
:
AutoList
;
using
AutoTaggedTuple
=
BinASTTokenReaderContext
:
:
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Chars
=
BinASTTokenReaderContext
:
:
Chars
;
BinASTTokenReaderContext
:
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
BinASTTokenReaderBase
(
cx
er
start
length
)
metadata_
(
nullptr
)
posBeforeTree_
(
nullptr
)
{
MOZ_ASSERT
(
er
)
;
}
BinASTTokenReaderContext
:
:
~
BinASTTokenReaderContext
(
)
{
if
(
metadata_
&
&
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
{
UniqueBinASTSourceMetadataPtr
ptr
(
metadata_
)
;
}
if
(
decoder_
)
{
BrotliDecoderDestroyInstance
(
decoder_
)
;
}
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
BinASTTokenReaderContext
:
:
Compression
:
:
No
>
(
uint8_t
*
bytes
uint32_t
len
)
{
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
BinASTTokenReaderContext
:
:
Compression
:
:
Yes
>
(
uint8_t
*
bytes
uint32_t
len
)
{
while
(
availableDecodedLength
(
)
<
len
)
{
if
(
availableDecodedLength
(
)
)
{
memmove
(
bytes
decodedBufferBegin
(
)
availableDecodedLength
(
)
)
;
bytes
+
=
availableDecodedLength
(
)
;
len
-
=
availableDecodedLength
(
)
;
}
MOZ_TRY
(
fillDecodedBuf
(
)
)
;
}
memmove
(
bytes
decodedBufferBegin
(
)
len
)
;
advanceDecodedBuffer
(
len
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
fillDecodedBuf
(
)
{
if
(
isEOF
(
)
)
{
return
raiseError
(
"
Unexpected
end
of
file
"
)
;
}
MOZ_ASSERT
(
!
availableDecodedLength
(
)
)
;
decodedBegin_
=
0
;
size_t
inSize
=
stop_
-
current_
;
size_t
outSize
=
DECODED_BUFFER_SIZE
;
uint8_t
*
out
=
decodedBuffer_
;
BrotliDecoderResult
result
;
result
=
BrotliDecoderDecompressStream
(
decoder_
&
inSize
&
current_
&
outSize
&
out
nullptr
)
;
if
(
result
=
=
BROTLI_DECODER_RESULT_ERROR
)
{
return
raiseError
(
"
Failed
to
decompress
brotli
stream
"
)
;
}
decodedEnd_
=
out
-
decodedBuffer_
;
return
Ok
(
)
;
}
void
BinASTTokenReaderContext
:
:
advanceDecodedBuffer
(
uint32_t
count
)
{
MOZ_ASSERT
(
decodedBegin_
+
count
<
=
decodedEnd_
)
;
decodedBegin_
+
=
count
;
}
bool
BinASTTokenReaderContext
:
:
isEOF
(
)
const
{
return
BrotliDecoderIsFinished
(
decoder_
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
BinASTTokenReaderContext
:
:
Compression
:
:
No
>
(
)
{
return
Base
:
:
readByte
(
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
BinASTTokenReaderContext
:
:
Compression
:
:
Yes
>
(
)
{
uint8_t
buf
;
MOZ_TRY
(
readBuf
<
Compression
:
:
Yes
>
(
&
buf
1
)
)
;
return
buf
;
}
BinASTSourceMetadata
*
BinASTTokenReaderContext
:
:
takeMetadata
(
)
{
MOZ_ASSERT
(
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
metadata_
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
initFromScriptSource
(
ScriptSource
*
scriptSource
)
{
metadata_
=
scriptSource
-
>
binASTSourceMetadata
(
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHeader
(
)
{
MOZ_ASSERT
(
!
posBeforeTree_
)
;
MOZ_TRY
(
readConst
(
CX_MAGIC_HEADER
)
)
;
BINJS_MOZ_TRY_DECL
(
version
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
version
!
=
MAGIC_FORMAT_VERSION
)
{
return
raiseError
(
"
Format
version
not
implemented
"
)
;
}
decoder_
=
BrotliDecoderCreateInstance
(
nullptr
nullptr
nullptr
)
;
if
(
!
decoder_
)
{
return
raiseError
(
"
Failed
to
create
brotli
decoder
"
)
;
}
MOZ_TRY
(
readStringPrelude
(
)
)
;
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readStringPrelude
(
)
{
BINJS_MOZ_TRY_DECL
(
stringsNumberOfEntries
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
const
uint32_t
MAX_NUMBER_OF_STRINGS
=
32768
;
if
(
stringsNumberOfEntries
>
MAX_NUMBER_OF_STRINGS
)
{
return
raiseError
(
"
Too
many
entries
in
strings
dictionary
"
)
;
}
Vector
<
BinASTKind
>
binASTKinds
(
cx_
)
;
BinASTSourceMetadata
*
metadata
=
BinASTSourceMetadata
:
:
Create
(
binASTKinds
stringsNumberOfEntries
)
;
if
(
!
metadata
)
{
return
raiseOOM
(
)
;
}
auto
se
=
mozilla
:
:
MakeScopeExit
(
[
metadata
]
(
)
{
js_free
(
metadata
)
;
}
)
;
StringBuffer
buf
(
cx_
)
;
RootedAtom
atom
(
cx_
)
;
for
(
uint32_t
stringIndex
=
0
;
stringIndex
<
stringsNumberOfEntries
;
stringIndex
+
+
)
{
size_t
len
;
while
(
true
)
{
if
(
availableDecodedLength
(
)
=
=
0
)
{
MOZ_TRY
(
fillDecodedBuf
(
)
)
;
}
MOZ_ASSERT
(
availableDecodedLength
(
)
>
0
)
;
const
uint8_t
*
end
=
static_cast
<
const
uint8_t
*
>
(
memchr
(
decodedBufferBegin
(
)
'
\
0
'
availableDecodedLength
(
)
)
)
;
if
(
end
)
{
len
=
end
-
decodedBufferBegin
(
)
;
break
;
}
BINJS_TRY
(
buf
.
append
(
decodedBufferBegin
(
)
availableDecodedLength
(
)
)
)
;
advanceDecodedBuffer
(
availableDecodedLength
(
)
)
;
}
if
(
!
buf
.
length
(
)
)
{
const
char
*
begin
=
reinterpret_cast
<
const
char
*
>
(
decodedBufferBegin
(
)
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
begin
len
)
)
;
}
else
{
BINJS_TRY
(
buf
.
append
(
reinterpret_cast
<
const
char
*
>
(
decodedBufferBegin
(
)
)
len
)
)
;
const
char
*
begin
=
reinterpret_cast
<
const
char
*
>
(
buf
.
rawLatin1Begin
(
)
)
;
len
=
buf
.
length
(
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
begin
len
)
)
;
buf
.
clear
(
)
;
}
metadata
-
>
getAtom
(
stringIndex
)
=
atom
;
advanceDecodedBuffer
(
len
+
1
)
;
}
MOZ_ASSERT
(
!
metadata_
)
;
MOZ_ASSERT
(
buf
.
empty
(
)
)
;
se
.
release
(
)
;
metadata_
=
metadata
;
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
return
Ok
(
)
;
}
void
BinASTTokenReaderContext
:
:
traceMetadata
(
JSTracer
*
trc
)
{
if
(
metadata_
)
{
metadata_
-
>
trace
(
trc
)
;
}
}
JS
:
:
Result
<
bool
>
BinASTTokenReaderContext
:
:
readBool
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
double
>
BinASTTokenReaderContext
:
:
readDouble
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeAtom
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readAtom
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeIdentifierName
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readIdentifierName
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readPropertyKey
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readChars
(
Chars
&
out
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
BinASTTokenReaderBase
:
:
SkippableSubTree
>
BinASTTokenReaderContext
:
:
readSkippableSubTree
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
Context
&
AutoTaggedTuple
&
guard
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterList
(
uint32_t
&
items
const
Context
&
AutoList
&
guard
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
void
BinASTTokenReaderContext
:
:
AutoBase
:
:
init
(
)
{
initialized_
=
true
;
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
AutoBase
(
BinASTTokenReaderContext
&
reader
)
:
initialized_
(
false
)
reader_
(
reader
)
{
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoBase
:
:
checkPosition
(
const
uint8_t
*
expectedEnd
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
BinASTTokenReaderContext
:
:
AutoList
:
:
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
void
BinASTTokenReaderContext
:
:
AutoList
:
:
init
(
)
{
AutoBase
:
:
init
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoList
:
:
done
(
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
template
<
BinASTTokenReaderContext
:
:
Compression
compression
>
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readVarU32
(
)
{
uint32_t
result
=
0
;
uint32_t
shift
=
0
;
while
(
true
)
{
MOZ_ASSERT
(
shift
<
32
)
;
uint32_t
byte
;
MOZ_TRY_VAR
(
byte
readByte
<
compression
>
(
)
)
;
const
uint32_t
newResult
=
result
|
(
byte
&
0x7f
)
<
<
shift
;
if
(
newResult
<
result
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
result
=
newResult
;
shift
+
=
7
;
if
(
(
byte
&
0x80
)
=
=
0
)
{
return
result
;
}
if
(
shift
>
=
32
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
}
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnsignedLong
(
const
Context
&
)
{
return
readVarU32
<
Compression
:
:
Yes
>
(
)
;
}
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
done
(
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
}
}
