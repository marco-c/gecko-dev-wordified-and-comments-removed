#
include
"
frontend
/
BinASTTokenReaderContext
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
string
.
h
>
#
include
"
ds
/
Sort
.
h
"
#
include
"
frontend
/
BinAST
-
macros
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
namespace
frontend
{
#
ifdef
BINAST_CX_MAGIC_HEADER
const
char
CX_MAGIC_HEADER
[
]
=
"
\
x89
"
"
BJS
\
r
\
n
\
0
\
n
"
;
const
uint32_t
MAGIC_FORMAT_VERSION
=
2
;
#
endif
const
uint8_t
MAX_CODE_BIT_LENGTH
=
20
;
const
uint8_t
MAX_BIT_LENGTH_BIT_LENGTH
=
5
;
static_assert
(
1
<
<
(
MAX_BIT_LENGTH_BIT_LENGTH
-
1
)
<
MAX_CODE_BIT_LENGTH
"
MAX_BIT_LENGTH_BIT_LENGTH
-
1
bits
MUST
be
insufficient
to
"
"
store
MAX_CODE_BIT_LENGTH
"
)
;
static_assert
(
1
<
<
MAX_BIT_LENGTH_BIT_LENGTH
>
=
MAX_CODE_BIT_LENGTH
"
MAX_BIT_LENGTH
bits
MUST
be
sufficient
to
store
MAX_CODE_BIT_LENGTH
"
)
;
const
uint8_t
MAX_PREFIX_BIT_LENGTH
=
32
;
const
uint8_t
BIT_BUFFER_SIZE
=
64
;
const
uint8_t
BIT_BUFFER_READ_UNIT
=
8
;
const
uint32_t
MAX_NUMBER_OF_SYMBOLS
=
32768
;
const
uint32_t
MAX_LIST_LENGTH
=
std
:
:
min
(
(
uint32_t
)
32768
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
;
const
size_t
HUFFMAN_STACK_INITIAL_CAPACITY
=
1024
;
extern
const
size_t
SUM_LIMITS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
size_t
STRING_ENUM_LIMITS
[
BINASTSTRINGENUM_LIMIT
]
;
extern
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
;
using
Compression
=
BinASTTokenReaderContext
:
:
Compression
;
using
EndOfFilePolicy
=
BinASTTokenReaderContext
:
:
EndOfFilePolicy
;
#
define
WRAP_INTERFACE
(
TYPE
)
Interface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_MAYBE_INTERFACE
(
TYPE
)
MaybeInterface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_PRIMITIVE
(
TYPE
)
TYPE
#
define
WRAP_LIST
(
TYPE
_
)
List
:
:
Maker
(
BinASTList
:
:
TYPE
)
#
define
WRAP_SUM
(
TYPE
)
Sum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_MAYBE_SUM
(
TYPE
)
MaybeSum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_STRING_ENUM
(
TYPE
)
StringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
#
define
WRAP_MAYBE_STRING_ENUM
(
TYPE
)
\
MaybeStringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
using
AutoList
=
BinASTTokenReaderContext
:
:
AutoList
;
using
AutoTaggedTuple
=
BinASTTokenReaderContext
:
:
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Chars
=
BinASTTokenReaderContext
:
:
Chars
;
class
HuffmanPreludeReader
{
public
:
HuffmanPreludeReader
(
JSContext
*
cx
BinASTTokenReaderContext
&
reader
HuffmanDictionary
&
dictionary
)
:
cx_
(
cx
)
reader
(
reader
)
dictionary
(
dictionary
)
stack
(
cx_
)
auxStorageLength
(
cx_
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
run
(
size_t
initialCapacity
)
;
private
:
JSContext
*
cx_
;
BinASTTokenReaderContext
&
reader
;
HuffmanDictionary
&
dictionary
;
public
:
enum
TableHeader
:
uint8_t
{
SingleValue
=
0x00
MultipleValues
=
0x01
Unreachable
=
0x02
}
;
struct
EntryBase
{
const
NormalizedInterfaceAndField
identity
;
explicit
EntryBase
(
const
NormalizedInterfaceAndField
identity
)
:
identity
(
identity
)
{
}
}
;
struct
EntryIndexed
:
EntryBase
{
using
Indexed
=
Ok
;
explicit
EntryIndexed
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
EntryExplicit
:
EntryBase
{
using
Explicit
=
Ok
;
explicit
EntryExplicit
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
String
:
EntryExplicit
{
using
SymbolType
=
JSAtom
*
;
using
Table
=
HuffmanTableIndexedSymbolsLiteralString
;
explicit
String
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
using
IdentifierName
=
String
;
using
PropertyKey
=
String
;
struct
MaybeString
:
EntryExplicit
{
using
SymbolType
=
JSAtom
*
;
using
Table
=
HuffmanTableIndexedSymbolsOptionalLiteralString
;
explicit
MaybeString
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
using
MaybeIdentifierName
=
MaybeString
;
using
MaybePropertyKey
=
MaybeString
;
struct
Number
:
EntryExplicit
{
using
SymbolType
=
double
;
using
Table
=
HuffmanTableExplicitSymbolsF64
;
explicit
Number
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
UnsignedLong
:
EntryExplicit
{
using
SymbolType
=
uint32_t
;
using
Table
=
HuffmanTableExplicitSymbolsU32
;
explicit
UnsignedLong
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
Boolean
:
EntryIndexed
{
using
SymbolType
=
bool
;
using
Table
=
HuffmanTableIndexedSymbolsBool
;
explicit
Boolean
(
const
NormalizedInterfaceAndField
identity
)
:
EntryIndexed
(
identity
)
{
}
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
1
)
;
MOZ_ASSERT
(
bIndex
<
=
1
)
;
return
aIndex
<
bIndex
;
}
}
;
struct
Lazy
:
EntryExplicit
{
explicit
Lazy
(
const
NormalizedInterfaceAndField
identity
)
:
EntryExplicit
(
identity
)
{
}
}
;
struct
Interface
:
EntryIndexed
{
using
SymbolType
=
BinASTKind
;
const
BinASTKind
kind
;
Interface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryIndexed
(
identity
)
kind
(
kind
)
{
}
struct
Maker
{
const
BinASTKind
kind
;
explicit
Maker
(
BinASTKind
kind
)
:
kind
(
kind
)
{
}
Interface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Interface
(
identity
kind
)
;
}
}
;
}
;
struct
MaybeInterface
:
EntryIndexed
{
using
SymbolType
=
BinASTKind
;
using
Table
=
HuffmanTableIndexedSymbolsMaybeInterface
;
const
BinASTKind
kind
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
1
)
;
MOZ_ASSERT
(
bIndex
<
=
1
)
;
return
aIndex
<
bIndex
;
}
MaybeInterface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryIndexed
(
identity
)
kind
(
kind
)
{
}
size_t
maxMumberOfSymbols
(
)
const
{
return
2
;
}
struct
Maker
{
const
BinASTKind
kind
;
explicit
Maker
(
BinASTKind
kind
)
:
kind
(
kind
)
{
}
MaybeInterface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeInterface
(
identity
kind
)
;
}
}
;
}
;
struct
List
:
EntryExplicit
{
using
SymbolType
=
uint32_t
;
using
Table
=
HuffmanTableExplicitSymbolsListLength
;
const
BinASTList
contents
;
List
(
const
NormalizedInterfaceAndField
identity
const
BinASTList
contents
)
:
EntryExplicit
(
identity
)
contents
(
contents
)
{
}
struct
Maker
{
const
BinASTList
contents
;
explicit
Maker
(
BinASTList
contents
)
:
contents
(
contents
)
{
}
List
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
{
identity
contents
}
;
}
}
;
}
;
struct
ListContents
:
EntryBase
{
explicit
ListContents
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
Sum
:
EntryIndexed
{
using
SymbolType
=
BinASTKind
;
using
Table
=
HuffmanTableIndexedSymbolsSum
;
const
BinASTSum
contents
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
maxNumberOfSymbols
(
)
)
;
MOZ_ASSERT
(
bIndex
<
=
maxNumberOfSymbols
(
)
)
;
const
size_t
aKey
=
getBinASTKindSortKey
(
interfaceAt
(
aIndex
)
)
;
const
size_t
bKey
=
getBinASTKindSortKey
(
interfaceAt
(
bIndex
)
)
;
return
aKey
<
bKey
;
}
Sum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryIndexed
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTSum
contents
;
explicit
Maker
(
BinASTSum
contents
)
:
contents
(
contents
)
{
}
Sum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Sum
(
identity
contents
)
;
}
}
;
}
;
struct
MaybeSum
:
EntryIndexed
{
using
SymbolType
=
BinASTKind
;
using
Table
=
HuffmanTableIndexedSymbolsSum
;
const
BinASTSum
contents
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
return
aIndex
<
bIndex
;
}
MaybeSum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryIndexed
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
+
1
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
if
(
index
=
=
0
)
{
return
BinASTKind
:
:
_Null
;
}
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
-
1
]
;
}
struct
Maker
{
const
BinASTSum
contents
;
explicit
Maker
(
BinASTSum
contents
)
:
contents
(
contents
)
{
}
MaybeSum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeSum
(
identity
contents
)
;
}
}
;
}
;
struct
StringEnum
:
EntryIndexed
{
using
SymbolType
=
BinASTVariant
;
using
Table
=
HuffmanTableIndexedSymbolsStringEnum
;
inline
bool
lessThan
(
uint32_t
aIndex
uint32_t
bIndex
)
{
MOZ_ASSERT
(
aIndex
<
=
maxNumberOfSymbols
(
)
)
;
MOZ_ASSERT
(
bIndex
<
=
maxNumberOfSymbols
(
)
)
;
const
size_t
aKey
=
getBinASTVariantSortKey
(
variantAt
(
aIndex
)
)
;
const
size_t
bKey
=
getBinASTVariantSortKey
(
variantAt
(
bIndex
)
)
;
return
aKey
<
bKey
;
}
const
BinASTStringEnum
contents
;
StringEnum
(
const
NormalizedInterfaceAndField
identity
const
BinASTStringEnum
contents
)
:
EntryIndexed
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
STRING_ENUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
;
}
BinASTVariant
variantAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
STRING_ENUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTStringEnum
contents
;
explicit
Maker
(
BinASTStringEnum
contents
)
:
contents
(
contents
)
{
}
StringEnum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
StringEnum
(
identity
contents
)
;
}
}
;
}
;
public
:
using
Entry
=
mozilla
:
:
Variant
<
Boolean
String
MaybeString
Number
UnsignedLong
Lazy
Interface
MaybeInterface
List
Sum
MaybeSum
StringEnum
>
;
#
ifdef
DEBUG
struct
PrintEntry
{
static
void
print
(
const
char
*
text
const
Entry
&
entry
)
{
fprintf
(
stderr
"
%
s
"
text
)
;
entry
.
match
(
PrintEntry
(
)
)
;
fprintf
(
stderr
"
\
n
"
)
;
}
void
operator
(
)
(
const
EntryBase
&
entry
)
{
fprintf
(
stderr
"
%
s
"
describeBinASTInterfaceAndField
(
entry
.
identity
.
identity
)
)
;
}
}
;
#
endif
private
:
Vector
<
Entry
>
stack
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
List
&
list
)
{
auto
&
table
=
dictionary
.
tableForListLength
(
list
.
contents
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
table
=
{
mozilla
:
:
VariantType
<
HuffmanTableInitializing
>
{
}
}
;
MOZ_TRY
(
(
readTable
<
HuffmanTableListLength
List
>
(
table
list
)
)
)
;
}
auto
&
lengthTable
=
table
.
as
<
HuffmanTableExplicitSymbolsListLength
>
(
)
;
bool
empty
=
true
;
for
(
auto
iter
:
lengthTable
)
{
if
(
*
iter
>
0
)
{
empty
=
false
;
break
;
}
}
if
(
empty
)
{
return
Ok
(
)
;
}
switch
(
list
.
contents
)
{
#
define
WRAP_LIST_2
(
_
CONTENT
)
CONTENT
#
define
EMIT_CASE
(
LIST_NAME
_CONTENT_TYPE
_HUMAN_NAME
TYPE
)
\
case
BinASTList
:
:
LIST_NAME
:
\
return
pushValue
(
list
.
identity
TYPE
(
list
.
identity
)
)
;
FOR_EACH_BIN_LIST
(
EMIT_CASE
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
WRAP_LIST_2
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
WRAP_MAYBE_STRING_ENUM
)
#
undef
EMIT_CASE
#
undef
WRAP_LIST_2
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
Interface
&
interface
)
{
auto
&
table
=
dictionary
.
tableForField
(
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
HuffmanTableIndexedSymbolsSum
sum
(
cx_
)
;
MOZ_TRY
(
sum
.
initWithSingleValue
(
cx_
BinASTKind
(
interface
.
kind
)
)
)
;
table
=
{
mozilla
:
:
VariantType
<
HuffmanTableIndexedSymbolsSum
>
{
}
std
:
:
move
(
sum
)
}
;
}
return
pushFields
(
interface
.
kind
)
;
}
template
<
class
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
Entry
&
entry
)
{
auto
&
table
=
dictionary
.
tableForField
(
identity
)
;
if
(
!
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
table
=
{
mozilla
:
:
VariantType
<
HuffmanTableInitializing
>
{
}
}
;
BINJS_TRY
(
stack
.
append
(
entry
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
pushFields
(
BinASTKind
tag
)
{
switch
(
tag
)
{
#
define
EMIT_FIELD
(
TAG_NAME
FIELD_NAME
FIELD_INDEX
FIELD_TYPE
_
)
\
MOZ_TRY
(
pushValue
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
\
FIELD_TYPE
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
)
)
)
;
#
define
EMIT_CASE
(
TAG_ENUM_NAME
_2
TAG_MACRO_NAME
)
\
case
BinASTKind
:
:
TAG_ENUM_NAME
:
{
\
FOR_EACH_BIN_FIELD_IN_INTERFACE_
#
#
TAG_MACRO_NAME
(
\
EMIT_FIELD
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
\
WRAP_LIST
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
\
WRAP_MAYBE_STRING_ENUM
)
;
\
break
;
\
}
FOR_EACH_BIN_KIND
(
EMIT_CASE
)
#
undef
EMIT_CASE
#
undef
EMIT_FIELD
}
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
SymbolType
>
readSymbol
(
const
Entry
&
size_t
index
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readNumberOfSymbols
(
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readSingleValueTable
(
typename
Entry
:
:
Table
&
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readMultipleValuesTable
(
typename
Entry
:
:
Table
&
table
Entry
entry
)
{
BINJS_MOZ_TRY_DECL
(
numberOfSymbols
readNumberOfSymbols
<
Entry
>
(
entry
)
)
;
MOZ_ASSERT
(
numberOfSymbols
<
=
MAX_NUMBER_OF_SYMBOLS
)
;
if
(
numberOfSymbols
=
=
1
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
!
=
0
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
0
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
symbol
)
)
)
;
return
Ok
(
)
;
}
MOZ_TRY
(
readMultipleValuesTableAndAssignCode
<
Entry
>
(
table
entry
numberOfSymbols
)
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
Explicit
>
readMultipleValuesTableAndAssignCode
(
typename
Entry
:
:
Table
&
table
Entry
entry
uint32_t
numberOfSymbols
)
{
MOZ_ASSERT
(
auxStorageLength
.
empty
(
)
)
;
BINJS_TRY
(
auxStorageLength
.
reserve
(
numberOfSymbols
+
1
)
)
;
uint8_t
largestBitLength
=
0
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
=
=
0
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
if
(
bitLength
>
largestBitLength
)
{
largestBitLength
=
bitLength
;
}
BINJS_TRY
(
auxStorageLength
.
append
(
BitLengthAndIndex
(
bitLength
i
)
)
)
;
}
BINJS_TRY
(
auxStorageLength
.
append
(
BitLengthAndIndex
(
MAX_CODE_BIT_LENGTH
numberOfSymbols
)
)
)
;
uint32_t
code
=
0
;
MOZ_TRY
(
table
.
initStart
(
cx_
numberOfSymbols
largestBitLength
)
)
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
const
auto
bitLength
=
auxStorageLength
[
i
]
.
bitLength
;
const
auto
nextBitLength
=
auxStorageLength
[
i
+
1
]
.
bitLength
;
if
(
MOZ_UNLIKELY
(
bitLength
>
nextBitLength
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
i
)
)
;
MOZ_TRY
(
table
.
addSymbol
(
code
bitLength
std
:
:
move
(
symbol
)
)
)
;
code
=
(
code
+
1
)
<
<
(
nextBitLength
-
bitLength
)
;
}
MOZ_TRY
(
table
.
initComplete
(
)
)
;
auxStorageLength
.
clear
(
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
Indexed
>
readMultipleValuesTableAndAssignCode
(
typename
Entry
:
:
Table
&
table
Entry
entry
uint32_t
numberOfSymbols
)
{
MOZ_ASSERT
(
auxStorageLength
.
empty
(
)
)
;
BINJS_TRY
(
auxStorageLength
.
reserve
(
numberOfSymbols
+
1
)
)
;
uint8_t
largestBitLength
=
0
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
bitLength
>
MAX_CODE_BIT_LENGTH
)
)
{
MOZ_CRASH
(
"
FIXME
:
Implement
error
"
)
;
}
if
(
bitLength
>
0
)
{
BINJS_TRY
(
auxStorageLength
.
append
(
BitLengthAndIndex
(
bitLength
i
)
)
)
;
if
(
bitLength
>
largestBitLength
)
{
largestBitLength
=
bitLength
;
}
}
}
std
:
:
sort
(
auxStorageLength
.
begin
(
)
auxStorageLength
.
end
(
)
[
&
entry
]
(
const
BitLengthAndIndex
&
a
const
BitLengthAndIndex
&
b
)
-
>
bool
{
MOZ_ASSERT
(
a
.
index
!
=
b
.
index
)
;
if
(
a
.
bitLength
<
b
.
bitLength
)
{
return
true
;
}
if
(
a
.
bitLength
>
b
.
bitLength
)
{
return
false
;
}
return
entry
.
lessThan
(
a
.
index
b
.
index
)
;
}
)
;
BINJS_TRY
(
auxStorageLength
.
emplaceBack
(
MAX_CODE_BIT_LENGTH
numberOfSymbols
)
)
;
uint32_t
code
=
0
;
MOZ_TRY
(
table
.
initStart
(
cx_
auxStorageLength
.
length
(
)
-
1
largestBitLength
)
)
;
for
(
size_t
i
=
0
;
i
<
auxStorageLength
.
length
(
)
-
1
;
+
+
i
)
{
const
auto
bitLength
=
auxStorageLength
[
i
]
.
bitLength
;
const
auto
nextBitLength
=
auxStorageLength
[
i
+
1
]
.
bitLength
;
MOZ_ASSERT
(
bitLength
>
0
)
;
MOZ_ASSERT
(
bitLength
<
=
nextBitLength
)
;
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
auxStorageLength
[
i
]
.
index
)
)
;
MOZ_TRY
(
table
.
addSymbol
(
code
bitLength
std
:
:
move
(
symbol
)
)
)
;
code
=
(
code
+
1
)
<
<
(
nextBitLength
-
bitLength
)
;
}
MOZ_TRY
(
table
.
initComplete
(
)
)
;
auxStorageLength
.
clear
(
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
Entry
entry
)
{
auto
&
table
=
dictionary
.
tableForField
(
entry
.
identity
)
;
return
readTable
<
HuffmanTableValue
Entry
>
(
table
entry
)
;
}
template
<
typename
HuffmanTable
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
HuffmanTable
&
table
Entry
entry
)
{
if
(
MOZ_UNLIKELY
(
!
table
.
template
is
<
HuffmanTableInitializing
>
(
)
)
)
{
return
raiseDuplicateTableError
(
entry
.
identity
)
;
}
uint8_t
headerByte
;
MOZ_TRY_VAR
(
headerByte
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
switch
(
headerByte
)
{
case
TableHeader
:
:
SingleValue
:
{
table
=
{
mozilla
:
:
VariantType
<
typename
Entry
:
:
Table
>
{
}
cx_
}
;
auto
&
tableRef
=
table
.
template
as
<
typename
Entry
:
:
Table
>
(
)
;
MOZ_TRY
(
(
readSingleValueTable
<
Entry
>
(
tableRef
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
MultipleValues
:
{
table
=
{
mozilla
:
:
VariantType
<
typename
Entry
:
:
Table
>
{
}
cx_
}
;
auto
&
tableRef
=
table
.
template
as
<
typename
Entry
:
:
Table
>
(
)
;
MOZ_TRY
(
(
readMultipleValuesTable
<
Entry
>
(
tableRef
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
Unreachable
:
return
Ok
(
)
;
default
:
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
}
private
:
struct
BitLengthAndIndex
{
BitLengthAndIndex
(
uint8_t
bitLength
size_t
index
)
:
bitLength
(
bitLength
)
index
(
index
)
{
}
uint8_t
bitLength
;
size_t
index
;
}
;
Vector
<
BitLengthAndIndex
>
auxStorageLength
;
struct
ReadPoppedEntryMatcher
{
HuffmanPreludeReader
&
owner
;
explicit
ReadPoppedEntryMatcher
(
HuffmanPreludeReader
&
owner
)
:
owner
(
owner
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Lazy
&
entry
)
{
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Boolean
&
entry
)
{
return
owner
.
readTable
<
Boolean
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Interface
&
entry
)
{
return
owner
.
pushFields
(
entry
.
kind
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeInterface
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeInterface
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsMaybeInterface
>
(
)
;
if
(
!
tableRef
.
isAlwaysNull
(
)
)
{
MOZ_TRY
(
owner
.
pushFields
(
entry
.
kind
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Sum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
Sum
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableInitializing
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsSum
>
(
)
;
for
(
auto
iter
:
tableRef
)
{
MOZ_TRY
(
owner
.
pushValue
(
entry
.
identity
Interface
(
entry
.
identity
*
iter
)
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeSum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeSum
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsSum
>
(
)
;
for
(
auto
iter
:
tableRef
)
{
MOZ_TRY
(
owner
.
pushValue
(
entry
.
identity
Interface
(
entry
.
identity
*
iter
)
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Number
&
entry
)
{
return
owner
.
readTable
<
Number
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
String
&
entry
)
{
return
owner
.
readTable
<
String
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeString
&
entry
)
{
return
owner
.
readTable
<
MaybeString
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
StringEnum
&
entry
)
{
return
owner
.
readTable
<
StringEnum
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
UnsignedLong
&
entry
)
{
return
owner
.
readTable
<
UnsignedLong
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
List
&
)
{
MOZ_CRASH
(
"
Unreachable
"
)
;
return
Ok
(
)
;
}
}
;
template
<
typename
T
>
using
ErrorResult
=
BinASTTokenReaderBase
:
:
ErrorResult
<
T
>
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseDuplicateTableError
(
const
NormalizedInterfaceAndField
identity
)
{
return
reader
.
raiseError
(
"
Duplicate
table
.
"
)
;
}
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidTableData
(
const
NormalizedInterfaceAndField
identity
)
{
return
reader
.
raiseError
(
"
Invalid
data
while
reading
table
.
"
)
;
}
}
;
using
Boolean
=
HuffmanPreludeReader
:
:
Boolean
;
using
Interface
=
HuffmanPreludeReader
:
:
Interface
;
using
List
=
HuffmanPreludeReader
:
:
List
;
using
MaybeInterface
=
HuffmanPreludeReader
:
:
MaybeInterface
;
using
MaybeString
=
HuffmanPreludeReader
:
:
MaybeString
;
using
MaybeSum
=
HuffmanPreludeReader
:
:
MaybeSum
;
using
Number
=
HuffmanPreludeReader
:
:
Number
;
using
String
=
HuffmanPreludeReader
:
:
String
;
using
StringEnum
=
HuffmanPreludeReader
:
:
StringEnum
;
using
Sum
=
HuffmanPreludeReader
:
:
Sum
;
using
UnsignedLong
=
HuffmanPreludeReader
:
:
UnsignedLong
;
BinASTTokenReaderContext
:
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
BinASTTokenReaderBase
(
cx
er
start
length
)
metadata_
(
nullptr
)
dictionary
(
cx
)
posBeforeTree_
(
nullptr
)
{
MOZ_ASSERT
(
er
)
;
}
BinASTTokenReaderContext
:
:
~
BinASTTokenReaderContext
(
)
{
if
(
metadata_
&
&
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
{
UniqueBinASTSourceMetadataPtr
ptr
(
metadata_
)
;
}
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
BestEffort
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
len
=
std
:
:
min
(
(
uint32_t
)
(
stop_
-
current_
)
len
)
;
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
RaiseError
>
(
)
{
return
raiseError
(
"
Unexpected
end
of
stream
"
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
BestEffort
>
(
)
{
return
Ok
(
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
Compression
:
:
No
>
(
)
{
return
Base
:
:
readByte
(
)
;
}
BinASTSourceMetadata
*
BinASTTokenReaderContext
:
:
takeMetadata
(
)
{
MOZ_ASSERT
(
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
metadata_
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
initFromScriptSource
(
ScriptSource
*
scriptSource
)
{
metadata_
=
scriptSource
-
>
binASTSourceMetadata
(
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHeader
(
)
{
MOZ_ASSERT
(
!
posBeforeTree_
)
;
#
if
BINAST_CX_MAGIC_HEADER
MOZ_TRY
(
readConst
(
CX_MAGIC_HEADER
)
)
;
BINJS_MOZ_TRY_DECL
(
version
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
version
!
=
MAGIC_FORMAT_VERSION
)
)
{
return
raiseError
(
"
Format
version
not
implemented
"
)
;
}
#
endif
MOZ_TRY
(
readStringPrelude
(
)
)
;
MOZ_TRY
(
readHuffmanPrelude
(
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readStringPrelude
(
)
{
BINJS_MOZ_TRY_DECL
(
stringsNumberOfEntries
readVarU32
<
Compression
:
:
No
>
(
)
)
;
const
uint32_t
MAX_NUMBER_OF_STRINGS
=
32768
;
if
(
MOZ_UNLIKELY
(
stringsNumberOfEntries
>
MAX_NUMBER_OF_STRINGS
)
)
{
return
raiseError
(
"
Too
many
entries
in
strings
dictionary
"
)
;
}
Vector
<
BinASTKind
>
binASTKinds
(
cx_
)
;
BinASTSourceMetadata
*
metadata
=
BinASTSourceMetadata
:
:
Create
(
binASTKinds
stringsNumberOfEntries
)
;
if
(
MOZ_UNLIKELY
(
!
metadata
)
)
{
return
raiseOOM
(
)
;
}
auto
se
=
mozilla
:
:
MakeScopeExit
(
[
metadata
]
(
)
{
js_free
(
metadata
)
;
}
)
;
StringBuffer
buf
(
cx_
)
;
RootedAtom
atom
(
cx_
)
;
for
(
uint32_t
stringIndex
=
0
;
stringIndex
<
stringsNumberOfEntries
;
stringIndex
+
+
)
{
if
(
MOZ_UNLIKELY
(
current_
>
=
stop_
)
)
{
return
raiseError
(
"
End
of
file
reached
while
reading
strings
table
"
)
;
}
const
uint8_t
*
end
=
static_cast
<
const
uint8_t
*
>
(
memchr
(
current_
'
\
0
'
stop_
-
current_
)
)
;
if
(
MOZ_UNLIKELY
(
!
end
)
)
{
return
raiseError
(
"
Invalid
string
missing
NUL
"
)
;
}
const
char
*
start
=
reinterpret_cast
<
const
char
*
>
(
current_
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
start
end
-
current_
)
)
;
metadata
-
>
getAtom
(
stringIndex
)
=
atom
;
current_
=
end
+
1
;
}
MOZ_ASSERT
(
!
metadata_
)
;
MOZ_ASSERT
(
buf
.
empty
(
)
)
;
se
.
release
(
)
;
metadata_
=
metadata
;
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHuffmanPrelude
(
)
{
HuffmanPreludeReader
reader
{
cx_
*
this
dictionary
}
;
return
reader
.
run
(
HUFFMAN_STACK_INITIAL_CAPACITY
)
;
}
BinASTTokenReaderContext
:
:
BitBuffer
:
:
BitBuffer
(
)
:
bits
(
0
)
bitLength
(
0
)
{
static_assert
(
sizeof
(
bits
)
*
8
=
=
BIT_BUFFER_SIZE
"
Expecting
bitBuffer
to
match
BIT_BUFFER_SIZE
"
)
;
}
template
<
Compression
C
>
JS
:
:
Result
<
HuffmanLookup
>
BinASTTokenReaderContext
:
:
BitBuffer
:
:
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
{
if
(
this
-
>
bitLength
<
=
MAX_PREFIX_BIT_LENGTH
)
{
mozilla
:
:
Array
<
uint8_t
8
>
bytes
;
uint64_t
*
newBits
=
reinterpret_cast
<
uint64_t
*
>
(
bytes
.
begin
(
)
)
;
static_assert
(
sizeof
(
bytes
)
=
=
sizeof
(
*
newBits
)
"
Expecting
bytes
array
to
match
size
of
*
newBits
"
)
;
*
newBits
=
0
;
uint32_t
bytesInBits
=
(
this
-
>
bitLength
+
BIT_BUFFER_READ_UNIT
-
1
)
/
BIT_BUFFER_READ_UNIT
;
uint32_t
readLen
=
sizeof
(
bytes
)
-
bytesInBits
;
MOZ_TRY
(
(
owner
.
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
BestEffort
>
(
bytes
.
begin
(
)
readLen
)
)
)
;
#
if
MOZ_LITTLE_ENDIAN
*
newBits
=
(
(
(
*
newBits
&
0x00000000000000ffULL
)
<
<
56
)
|
(
(
*
newBits
&
0x000000000000ff00ULL
)
<
<
40
)
|
(
(
*
newBits
&
0x0000000000ff0000ULL
)
<
<
24
)
|
(
(
*
newBits
&
0x00000000ff000000ULL
)
<
<
8
)
|
(
(
*
newBits
&
0x000000ff00000000ULL
)
>
>
8
)
|
(
(
*
newBits
&
0x0000ff0000000000ULL
)
>
>
24
)
|
(
(
*
newBits
&
0x00ff000000000000ULL
)
>
>
40
)
|
(
(
*
newBits
&
0xff00000000000000ULL
)
>
>
56
)
)
;
#
endif
*
newBits
>
>
=
(
BIT_BUFFER_READ_UNIT
*
(
sizeof
(
bytes
)
-
readLen
)
)
;
*
newBits
=
(
(
*
newBits
>
>
1
)
&
0x5555555555555555
)
|
(
(
*
newBits
&
0x5555555555555555
)
<
<
1
)
;
*
newBits
=
(
(
*
newBits
>
>
2
)
&
0x3333333333333333
)
|
(
(
*
newBits
&
0x3333333333333333
)
<
<
2
)
;
*
newBits
=
(
(
*
newBits
>
>
4
)
&
0x0F0F0F0F0F0F0F0F
)
|
(
(
*
newBits
&
0x0F0F0F0F0F0F0F0F
)
<
<
4
)
;
this
-
>
bitLength
+
=
(
BIT_BUFFER_READ_UNIT
*
readLen
)
;
if
(
readLen
!
=
8
)
{
this
-
>
bits
<
<
=
(
BIT_BUFFER_READ_UNIT
*
readLen
)
;
this
-
>
bits
+
=
*
newBits
;
}
else
{
this
-
>
bits
=
*
newBits
;
}
if
(
this
-
>
bitLength
<
=
MAX_PREFIX_BIT_LENGTH
)
{
return
HuffmanLookup
(
this
-
>
bits
this
-
>
bitLength
)
;
}
}
const
uint64_t
bitPrefix
=
this
-
>
bits
>
>
(
this
-
>
bitLength
-
MAX_PREFIX_BIT_LENGTH
)
;
MOZ_ASSERT
(
bitPrefix
<
=
uint32_t
(
-
1
)
)
;
return
HuffmanLookup
(
bitPrefix
MAX_PREFIX_BIT_LENGTH
)
;
}
template
<
>
void
BinASTTokenReaderContext
:
:
BitBuffer
:
:
advanceBitBuffer
<
Compression
:
:
No
>
(
const
uint8_t
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
this
-
>
bitLength
)
;
this
-
>
bitLength
-
=
bitLength
;
const
uint64_t
mask
=
this
-
>
bitLength
=
=
0
?
0
:
uint64_t
(
-
1
)
>
>
(
BIT_BUFFER_SIZE
-
this
-
>
bitLength
)
;
this
-
>
bits
&
=
mask
;
MOZ_ASSERT_IF
(
this
-
>
bitLength
!
=
BIT_BUFFER_SIZE
this
-
>
bits
>
>
this
-
>
bitLength
=
=
0
)
;
}
void
BinASTTokenReaderContext
:
:
traceMetadata
(
JSTracer
*
trc
)
{
if
(
metadata_
)
{
metadata_
-
>
trace
(
trc
)
;
}
}
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
BinASTTokenReaderContext
:
:
raiseInvalidValue
(
)
{
errorReporter_
-
>
errorNoOffset
(
JSMSG_BINAST
"
Invalid
value
"
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
BinASTTokenReaderContext
:
:
raiseNotInPrelude
(
)
{
errorReporter_
-
>
errorNoOffset
(
JSMSG_BINAST
"
Value
is
not
in
prelude
"
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
struct
ExtractBinASTInterfaceAndFieldMatcher
{
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
context
)
{
return
context
.
position
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
ListContext
&
context
)
{
return
context
.
position
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
RootContext
&
)
{
MOZ_CRASH
(
"
The
root
context
has
no
interface
/
field
"
)
;
}
}
;
JS
:
:
Result
<
BinASTKind
>
BinASTTokenReaderContext
:
:
readTagFromTable
(
const
BinASTInterfaceAndField
&
identity
)
{
const
auto
&
table
=
dictionary
.
tableForField
(
NormalizedInterfaceAndField
(
identity
)
)
;
BINJS_MOZ_TRY_DECL
(
bits
(
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
)
;
if
(
table
.
is
<
HuffmanTableIndexedSymbolsSum
>
(
)
)
{
const
auto
&
specialized
=
table
.
as
<
HuffmanTableIndexedSymbolsSum
>
(
)
;
const
auto
lookup
=
specialized
.
lookup
(
bits
)
;
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
lookup
.
key
.
bitLength
)
;
if
(
MOZ_UNLIKELY
(
!
lookup
.
value
)
)
{
return
raiseInvalidValue
(
)
;
}
return
*
lookup
.
value
;
}
MOZ_ASSERT
(
table
.
is
<
HuffmanTableIndexedSymbolsMaybeInterface
>
(
)
)
;
const
auto
&
specialized
=
table
.
as
<
HuffmanTableIndexedSymbolsMaybeInterface
>
(
)
;
const
auto
lookup
=
specialized
.
lookup
(
bits
)
;
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
lookup
.
key
.
bitLength
)
;
if
(
MOZ_UNLIKELY
(
!
lookup
.
value
)
)
{
return
raiseInvalidValue
(
)
;
}
return
*
lookup
.
value
;
}
template
<
typename
Table
>
JS
:
:
Result
<
typename
Table
:
:
Contents
>
BinASTTokenReaderContext
:
:
readFieldFromTable
(
const
BinASTInterfaceAndField
&
identity
)
{
const
auto
&
table
=
dictionary
.
tableForField
(
NormalizedInterfaceAndField
(
identity
)
)
;
if
(
MOZ_UNLIKELY
(
!
table
.
is
<
Table
>
(
)
)
)
{
return
raiseNotInPrelude
(
)
;
}
BINJS_MOZ_TRY_DECL
(
bits
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
;
const
auto
lookup
=
table
.
as
<
Table
>
(
)
.
lookup
(
bits
)
;
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
lookup
.
key
.
bitLength
)
;
if
(
MOZ_UNLIKELY
(
!
lookup
.
value
)
)
{
return
raiseInvalidValue
(
)
;
}
return
*
lookup
.
value
;
}
JS
:
:
Result
<
bool
>
BinASTTokenReaderContext
:
:
readBool
(
const
FieldContext
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsBool
>
(
context
.
position
)
;
}
JS
:
:
Result
<
double
>
BinASTTokenReaderContext
:
:
readDouble
(
const
FieldContext
&
context
)
{
return
readFieldFromTable
<
HuffmanTableExplicitSymbolsF64
>
(
context
.
position
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeAtom
(
const
FieldContext
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsOptionalLiteralString
>
(
context
.
position
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readAtom
(
const
FieldContext
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsLiteralString
>
(
context
.
position
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeIdentifierName
(
const
FieldContext
&
context
)
{
return
readMaybeAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readIdentifierName
(
const
FieldContext
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readPropertyKey
(
const
FieldContext
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readChars
(
Chars
&
out
const
FieldContext
&
)
{
return
raiseError
(
"
readChars
is
not
implemented
in
BinASTTokenReaderContext
"
)
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
ListContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
<
HuffmanTableIndexedSymbolsStringEnum
>
(
context
.
position
)
)
;
return
result
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
FieldContext
&
context
)
{
BINJS_MOZ_TRY_DECL
(
result
readFieldFromTable
<
HuffmanTableIndexedSymbolsStringEnum
>
(
context
.
position
)
)
;
return
result
;
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnsignedLong
(
const
FieldContext
&
context
)
{
return
readFieldFromTable
<
HuffmanTableExplicitSymbolsU32
>
(
context
.
position
)
;
}
JS
:
:
Result
<
BinASTTokenReaderBase
:
:
SkippableSubTree
>
BinASTTokenReaderContext
:
:
readSkippableSubTree
(
const
FieldContext
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
FieldOrRootContext
&
context
AutoTaggedTuple
&
guard
)
{
return
context
.
match
(
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
asFieldContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asFieldContext
.
position
)
)
;
return
Ok
(
)
;
}
[
&
tag
]
(
const
BinASTTokenReaderBase
:
:
RootContext
&
)
-
>
JS
:
:
Result
<
Ok
>
{
tag
=
BinASTKind
:
:
Script
;
return
Ok
(
)
;
}
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
FieldOrListContext
&
context
AutoTaggedTuple
&
guard
)
{
return
context
.
match
(
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
asFieldContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asFieldContext
.
position
)
)
;
return
Ok
(
)
;
}
[
this
&
tag
]
(
const
BinASTTokenReaderBase
:
:
ListContext
&
asListContext
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
asListContext
.
position
)
)
;
return
Ok
(
)
;
}
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
RootContext
&
context
AutoTaggedTuple
&
guard
)
{
tag
=
BinASTKind
:
:
Script
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
ListContext
&
context
AutoTaggedTuple
&
guard
)
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
context
.
position
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
FieldContext
&
context
AutoTaggedTuple
&
guard
)
{
MOZ_TRY_VAR
(
tag
readTagFromTable
(
context
.
position
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterList
(
uint32_t
&
items
const
ListContext
&
context
AutoList
&
guard
)
{
const
auto
identity
=
context
.
content
;
const
auto
&
table
=
dictionary
.
tableForListLength
(
identity
)
;
BINJS_MOZ_TRY_DECL
(
bits
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
No
>
(
*
this
)
)
;
const
auto
&
tableForLookup
=
table
.
as
<
HuffmanTableExplicitSymbolsListLength
>
(
)
;
const
auto
lookup
=
tableForLookup
.
lookup
(
bits
)
;
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
No
>
(
lookup
.
key
.
bitLength
)
;
if
(
MOZ_UNLIKELY
(
!
lookup
.
value
)
)
{
return
raiseInvalidValue
(
)
;
}
items
=
*
lookup
.
value
;
return
Ok
(
)
;
}
void
BinASTTokenReaderContext
:
:
AutoBase
:
:
init
(
)
{
initialized_
=
true
;
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
AutoBase
(
BinASTTokenReaderContext
&
reader
)
:
initialized_
(
false
)
reader_
(
reader
)
{
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoBase
:
:
checkPosition
(
const
uint8_t
*
expectedEnd
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
BinASTTokenReaderContext
:
:
AutoList
:
:
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
void
BinASTTokenReaderContext
:
:
AutoList
:
:
init
(
)
{
AutoBase
:
:
init
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoList
:
:
done
(
)
{
return
Ok
(
)
;
}
template
<
Compression
compression
>
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readVarU32
(
)
{
uint32_t
result
=
0
;
uint32_t
shift
=
0
;
while
(
true
)
{
MOZ_ASSERT
(
shift
<
32
)
;
uint32_t
byte
;
MOZ_TRY_VAR
(
byte
readByte
<
compression
>
(
)
)
;
const
uint32_t
newResult
=
result
|
(
byte
&
0x7f
)
<
<
shift
;
if
(
MOZ_UNLIKELY
(
newResult
<
result
)
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
result
=
newResult
;
shift
+
=
7
;
if
(
(
byte
&
0x80
)
=
=
0
)
{
return
result
;
}
if
(
MOZ_UNLIKELY
(
shift
>
=
32
)
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
}
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnpackedLong
(
)
{
uint8_t
bytes
[
4
]
;
uint32_t
length
=
4
;
MOZ_TRY
(
(
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
bytes
length
)
)
)
;
const
uint32_t
result
=
uint32_t
(
bytes
[
0
]
)
<
<
24
|
uint32_t
(
bytes
[
1
]
)
<
<
16
|
uint32_t
(
bytes
[
2
]
)
<
<
8
|
uint32_t
(
bytes
[
3
]
)
;
return
result
;
}
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
done
(
)
{
return
Ok
(
)
;
}
HuffmanKey
:
:
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits
(
bits
)
bitLength
(
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
MAX_PREFIX_BIT_LENGTH
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
}
FlatHuffmanKey
:
:
FlatHuffmanKey
(
HuffmanKey
key
)
:
representation
(
(
key
.
bitLength
<
<
MAX_CODE_BIT_LENGTH
)
|
key
.
bits
)
{
static_assert
(
MAX_CODE_BIT_LENGTH
+
MAX_BIT_LENGTH_BIT_LENGTH
<
=
32
"
32
bits
MUST
be
sufficient
to
store
bits
and
bitLength
"
)
;
MOZ_ASSERT
(
key
.
bits
>
>
MAX_CODE_BIT_LENGTH
=
=
0
)
;
MOZ_ASSERT
(
key
.
bitLength
>
>
MAX_BIT_LENGTH_BIT_LENGTH
=
=
0
)
;
}
FlatHuffmanKey
:
:
FlatHuffmanKey
(
const
HuffmanKey
*
key
)
:
representation
(
(
key
-
>
bitLength
<
<
MAX_CODE_BIT_LENGTH
)
|
key
-
>
bits
)
{
static_assert
(
MAX_CODE_BIT_LENGTH
+
MAX_BIT_LENGTH_BIT_LENGTH
<
=
32
"
32
bits
MUST
be
sufficient
to
store
bits
and
bitLength
"
)
;
MOZ_ASSERT
(
key
-
>
bits
>
>
MAX_CODE_BIT_LENGTH
=
=
0
)
;
MOZ_ASSERT
(
key
-
>
bitLength
>
>
MAX_BIT_LENGTH_BIT_LENGTH
=
=
0
)
;
}
template
<
typename
T
>
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
Iterator
(
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
&
iterator
)
:
implementation
(
std
:
:
move
(
iterator
)
)
{
}
template
<
typename
T
>
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
Iterator
(
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
&
iterator
)
:
implementation
(
std
:
:
move
(
iterator
)
)
{
}
template
<
typename
T
>
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
Iterator
(
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
&
iterator
)
:
implementation
(
std
:
:
move
(
iterator
)
)
{
}
template
<
typename
T
>
void
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
+
+
(
)
{
implementation
.
match
(
[
]
(
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
[
]
(
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
iterator
.
operator
+
+
(
)
;
}
)
;
}
template
<
typename
T
>
bool
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
=
=
(
const
GenericHuffmanTable
<
T
>
:
:
Iterator
&
other
)
const
{
return
implementation
.
match
(
[
other
]
(
const
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation
.
template
as
<
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation
.
template
as
<
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
=
=
other
.
implementation
.
template
as
<
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
)
;
}
template
<
typename
T
>
bool
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
!
=
(
const
GenericHuffmanTable
<
T
>
:
:
Iterator
&
other
)
const
{
return
implementation
.
match
(
[
other
]
(
const
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation
.
template
as
<
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation
.
template
as
<
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
[
other
]
(
const
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
!
=
other
.
implementation
.
template
as
<
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
>
(
)
;
}
)
;
}
template
<
typename
T
>
const
T
*
GenericHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
*
(
)
const
{
return
implementation
.
match
(
[
]
(
const
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
[
]
(
const
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
iterator
)
{
return
iterator
.
operator
*
(
)
;
}
)
;
}
template
<
typename
T
>
GenericHuffmanTable
<
T
>
:
:
GenericHuffmanTable
(
JSContext
*
)
:
implementation
(
HuffmanTableUnreachable
{
}
)
{
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
<
T
>
:
:
initComplete
(
)
{
return
this
-
>
implementation
.
match
(
[
]
(
SingleLookupHuffmanTable
<
T
>
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
)
;
}
[
]
(
TwoLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
)
;
}
[
]
(
ThreeLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
initComplete
(
)
;
}
[
]
(
HuffmanTableUnreachable
&
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
template
<
typename
T
>
typename
GenericHuffmanTable
<
T
>
:
:
Iterator
GenericHuffmanTable
<
T
>
:
:
begin
(
)
const
{
return
this
-
>
implementation
.
match
(
[
]
(
const
SingleLookupHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
TwoLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
ThreeLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
begin
(
)
)
;
}
[
]
(
const
HuffmanTableUnreachable
&
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
template
<
typename
T
>
typename
GenericHuffmanTable
<
T
>
:
:
Iterator
GenericHuffmanTable
<
T
>
:
:
end
(
)
const
{
return
this
-
>
implementation
.
match
(
[
]
(
const
SingleLookupHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
TwoLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
ThreeLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
return
Iterator
(
implementation
.
end
(
)
)
;
}
[
]
(
const
HuffmanTableUnreachable
&
)
-
>
GenericHuffmanTable
<
T
>
:
:
Iterator
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
<
T
>
:
:
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
{
MOZ_ASSERT
(
this
-
>
implementation
.
template
is
<
HuffmanTableUnreachable
>
(
)
)
;
this
-
>
implementation
=
{
mozilla
:
:
VariantType
<
SingleLookupHuffmanTable
<
T
>
>
{
}
cx
}
;
MOZ_TRY
(
this
-
>
implementation
.
template
as
<
SingleLookupHuffmanTable
<
T
>
>
(
)
.
initWithSingleValue
(
cx
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
<
T
>
:
:
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
static_assert
(
MAX_CODE_BIT_LENGTH
<
=
ThreeLookupsHuffmanTable
<
T
>
:
:
MAX_BIT_LENGTH
"
ThreeLookupsHuffmanTable
cannot
hold
all
bit
lengths
"
)
;
MOZ_ASSERT
(
this
-
>
implementation
.
template
is
<
HuffmanTableUnreachable
>
(
)
)
;
if
(
largestBitLength
<
=
SingleLookupHuffmanTable
<
T
>
:
:
MAX_BIT_LENGTH
)
{
this
-
>
implementation
=
{
mozilla
:
:
VariantType
<
SingleLookupHuffmanTable
<
T
>
>
{
}
cx
}
;
return
this
-
>
implementation
.
template
as
<
SingleLookupHuffmanTable
<
T
>
>
(
)
.
initStart
(
cx
numberOfSymbols
largestBitLength
)
;
}
if
(
largestBitLength
<
=
TwoLookupsHuffmanTable
<
T
>
:
:
MAX_BIT_LENGTH
)
{
this
-
>
implementation
=
{
mozilla
:
:
VariantType
<
TwoLookupsHuffmanTable
<
T
>
>
{
}
cx
}
;
return
this
-
>
implementation
.
template
as
<
TwoLookupsHuffmanTable
<
T
>
>
(
)
.
initStart
(
cx
numberOfSymbols
largestBitLength
)
;
}
this
-
>
implementation
=
{
mozilla
:
:
VariantType
<
ThreeLookupsHuffmanTable
<
T
>
>
{
}
cx
}
;
return
this
-
>
implementation
.
template
as
<
ThreeLookupsHuffmanTable
<
T
>
>
(
)
.
initStart
(
cx
numberOfSymbols
largestBitLength
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
GenericHuffmanTable
<
T
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
return
this
-
>
implementation
.
match
(
[
bits
bitLength
value
=
std
:
:
move
(
value
)
]
(
SingleLookupHuffmanTable
<
T
>
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
bits
bitLength
std
:
:
move
(
value
)
)
;
}
[
bits
bitLength
value
=
std
:
:
move
(
value
)
]
(
TwoLookupsHuffmanTable
<
T
>
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
bits
bitLength
std
:
:
move
(
value
)
)
;
}
[
bits
bitLength
value
=
std
:
:
move
(
value
)
]
(
ThreeLookupsHuffmanTable
<
T
>
&
implementation
)
mutable
-
>
JS
:
:
Result
<
Ok
>
{
return
implementation
.
addSymbol
(
bits
bitLength
std
:
:
move
(
value
)
)
;
}
[
]
(
HuffmanTableUnreachable
&
)
-
>
JS
:
:
Result
<
Ok
>
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
return
Ok
(
)
;
}
)
;
}
template
<
typename
T
>
HuffmanEntry
<
const
T
*
>
GenericHuffmanTable
<
T
>
:
:
lookup
(
HuffmanLookup
lookup
)
const
{
return
this
-
>
implementation
.
match
(
[
lookup
]
(
const
SingleLookupHuffmanTable
<
T
>
&
implementation
)
-
>
HuffmanEntry
<
const
T
*
>
{
return
implementation
.
lookup
(
lookup
)
;
}
[
lookup
]
(
const
TwoLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
HuffmanEntry
<
const
T
*
>
{
return
implementation
.
lookup
(
lookup
)
;
}
[
lookup
]
(
const
ThreeLookupsHuffmanTable
<
T
>
&
implementation
)
-
>
HuffmanEntry
<
const
T
*
>
{
return
implementation
.
lookup
(
lookup
)
;
}
[
]
(
const
HuffmanTableUnreachable
&
)
-
>
HuffmanEntry
<
const
T
*
>
{
MOZ_CRASH
(
"
GenericHuffmanTable
is
unitialized
!
"
)
;
}
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
NaiveHuffmanTable
<
T
N
>
:
:
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
values
.
append
(
HuffmanEntry
<
T
>
(
0
0
std
:
:
move
(
value
)
)
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
NaiveHuffmanTable
<
T
N
>
:
:
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
values
.
initCapacity
(
numberOfSymbols
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
NaiveHuffmanTable
<
T
N
>
:
:
initComplete
(
)
{
MOZ_ASSERT
(
values
.
length
(
)
<
=
N
)
;
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
NaiveHuffmanTable
<
T
N
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
MOZ_ASSERT
(
bitLength
!
=
0
"
Adding
a
symbol
with
a
bitLength
of
0
doesn
'
t
make
sense
.
"
)
;
MOZ_ASSERT
(
values
.
empty
(
)
|
|
values
.
back
(
)
.
key
.
bitLength
<
=
bitLength
"
Symbols
must
be
ranked
by
increasing
bits
length
"
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
MOZ_ALWAYS_TRUE
(
values
.
emplaceBack
(
bits
bitLength
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
HuffmanEntry
<
const
T
*
>
NaiveHuffmanTable
<
T
N
>
:
:
lookup
(
HuffmanLookup
key
)
const
{
for
(
const
auto
&
iter
:
values
)
{
if
(
iter
.
key
.
bitLength
>
key
.
bitLength
)
{
break
;
}
const
uint32_t
keyBits
=
key
.
leadingBits
(
iter
.
key
.
bitLength
)
;
if
(
keyBits
=
=
iter
.
key
.
bits
)
{
return
HuffmanEntry
<
const
T
*
>
(
iter
.
key
.
bits
iter
.
key
.
bitLength
&
iter
.
value
)
;
}
}
return
HuffmanEntry
<
const
T
*
>
(
0
0
nullptr
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
MapBasedHuffmanTable
<
T
>
:
:
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
const
HuffmanKey
key
(
0
0
)
;
if
(
MOZ_UNLIKELY
(
!
values
.
put
(
FlatHuffmanKey
(
key
)
std
:
:
move
(
value
)
)
|
|
!
keys
.
append
(
key
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
MapBasedHuffmanTable
<
T
>
:
:
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
values
.
reserve
(
numberOfSymbols
)
|
|
!
keys
.
reserve
(
numberOfSymbols
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
MapBasedHuffmanTable
<
T
>
:
:
initComplete
(
)
{
#
if
DEBUG
for
(
const
auto
&
key
:
keys
)
{
MOZ_ALWAYS_TRUE
(
values
.
has
(
FlatHuffmanKey
(
key
)
)
)
;
}
MOZ_ASSERT
(
values
.
count
(
)
=
=
keys
.
length
(
)
)
;
#
endif
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
MapBasedHuffmanTable
<
T
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
const
HuffmanKey
key
(
bits
bitLength
)
;
const
FlatHuffmanKey
flat
(
key
)
;
values
.
putNewInfallible
(
flat
std
:
:
move
(
value
)
)
;
keys
.
infallibleAppend
(
std
:
:
move
(
key
)
)
;
return
Ok
(
)
;
}
template
<
typename
T
>
HuffmanEntry
<
const
T
*
>
MapBasedHuffmanTable
<
T
>
:
:
lookup
(
HuffmanLookup
lookup
)
const
{
for
(
auto
bitLength
=
0
;
bitLength
<
MAX_CODE_BIT_LENGTH
;
+
+
bitLength
)
{
const
uint32_t
bits
=
lookup
.
leadingBits
(
bitLength
)
;
const
HuffmanKey
key
(
bits
bitLength
)
;
const
FlatHuffmanKey
flat
(
key
)
;
if
(
auto
ptr
=
values
.
lookup
(
flat
)
)
{
return
HuffmanEntry
<
const
T
*
>
(
bits
bitLength
&
ptr
-
>
value
(
)
)
;
}
}
return
HuffmanEntry
<
const
T
*
>
(
0
0
nullptr
)
;
}
template
<
typename
T
>
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
:
:
Iterator
(
const
HuffmanEntry
<
T
>
*
position
)
:
position
(
position
)
{
}
template
<
typename
T
>
void
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
+
+
(
)
{
position
+
+
;
}
template
<
typename
T
>
const
T
*
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
*
(
)
const
{
return
&
position
-
>
value
;
}
template
<
typename
T
>
bool
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position
=
=
other
.
position
;
}
template
<
typename
T
>
bool
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position
!
=
other
.
position
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
<
T
>
:
:
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
values
.
emplaceBack
(
0
0
std
:
:
move
(
value
)
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
saturated
.
emplaceBack
(
0
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
this
-
>
largestBitLength
=
0
;
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
<
T
>
:
:
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
MOZ_ASSERT_IF
(
largestBitLength
!
=
32
(
uint32_t
(
1
)
<
<
largestBitLength
)
-
1
<
=
mozilla
:
:
MaxValue
<
InternalIndex
>
:
:
value
)
;
MOZ_ASSERT
(
values
.
empty
(
)
)
;
this
-
>
largestBitLength
=
largestBitLength
;
if
(
MOZ_UNLIKELY
(
!
values
.
initCapacity
(
numberOfSymbols
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
const
size_t
saturatedLength
=
1
<
<
largestBitLength
;
if
(
MOZ_UNLIKELY
(
!
saturated
.
initCapacity
(
saturatedLength
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
for
(
size_t
i
=
0
;
i
<
saturatedLength
;
+
+
i
)
{
saturated
.
infallibleAppend
(
InternalIndex
(
-
1
)
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
<
T
>
:
:
initComplete
(
)
{
MOZ_ASSERT
(
this
-
>
largestBitLength
<
=
MAX_CODE_BIT_LENGTH
)
;
if
(
values
.
length
(
)
=
=
0
)
{
MOZ_ASSERT
(
this
-
>
largestBitLength
=
=
0
)
;
return
Ok
(
)
;
}
#
ifdef
DEBUG
bool
foundMaxBitLength
=
false
;
for
(
size_t
i
=
0
;
i
<
saturated
.
length
(
)
;
+
+
i
)
{
const
uint8_t
index
=
saturated
[
i
]
;
MOZ_ASSERT
(
values
[
index
]
.
key
.
bitLength
<
=
largestBitLength
)
;
if
(
values
[
index
]
.
key
.
bitLength
=
=
largestBitLength
)
{
foundMaxBitLength
=
true
;
}
}
MOZ_ASSERT
(
foundMaxBitLength
)
;
#
endif
return
Ok
(
)
;
}
template
<
typename
T
>
JS
:
:
Result
<
Ok
>
SingleLookupHuffmanTable
<
T
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
MOZ_ASSERT_IF
(
largestBitLength
!
=
0
bitLength
!
=
0
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
MOZ_ASSERT
(
bitLength
<
=
largestBitLength
)
;
const
size_t
index
=
values
.
length
(
)
;
values
.
infallibleEmplaceBack
(
bits
bitLength
std
:
:
move
(
value
)
)
;
const
HuffmanLookup
base
(
bits
bitLength
)
;
for
(
size_t
i
:
base
.
suffixes
(
largestBitLength
)
)
{
saturated
[
i
]
=
index
;
}
return
Ok
(
)
;
}
template
<
typename
T
>
HuffmanEntry
<
const
T
*
>
SingleLookupHuffmanTable
<
T
>
:
:
lookup
(
HuffmanLookup
key
)
const
{
if
(
values
.
length
(
)
=
=
0
)
{
return
HuffmanEntry
<
const
T
*
>
(
0
0
nullptr
)
;
}
const
uint32_t
bits
=
key
.
leadingBits
(
largestBitLength
)
;
const
size_t
index
=
saturated
[
bits
]
;
const
auto
&
entry
=
values
[
index
]
;
return
HuffmanEntry
<
const
T
*
>
(
entry
.
key
.
bits
entry
.
key
.
bitLength
&
entry
.
value
)
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
Iterator
(
const
HuffmanEntry
<
T
>
*
position
)
:
position
(
position
)
{
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
void
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
+
+
(
)
{
position
+
+
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
const
T
*
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
*
(
)
const
{
return
&
position
-
>
value
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
bool
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
=
=
(
const
Iterator
&
other
)
const
{
return
position
=
=
other
.
position
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
bool
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
Iterator
:
:
operator
!
=
(
const
Iterator
&
other
)
const
{
return
position
!
=
other
.
position
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
{
static_assert
(
PrefixBitLength
<
MAX_CODE_BIT_LENGTH
"
Invalid
PrefixBitLength
"
)
;
MOZ_ASSERT
(
values
.
empty
(
)
)
;
MOZ_ASSERT
(
subTables
.
empty
(
)
)
;
this
-
>
largestBitLength
=
largestBitLength
;
if
(
MOZ_UNLIKELY
(
!
values
.
initCapacity
(
numberOfSymbols
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
subTables
.
initCapacity
(
1
<
<
PrefixBitLength
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
MOZ_ASSERT_IF
(
largestBitLength
!
=
0
bitLength
!
=
0
)
;
MOZ_ASSERT
(
values
.
empty
(
)
|
|
values
.
back
(
)
.
key
.
bitLength
<
=
bitLength
"
Symbols
must
be
ranked
by
increasing
bits
length
"
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
bits
>
>
bitLength
=
=
0
)
;
values
.
infallibleEmplaceBack
(
bits
bitLength
std
:
:
move
(
value
)
)
;
return
Ok
(
)
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
JS
:
:
Result
<
Ok
>
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
initComplete
(
)
{
struct
Bucket
{
Bucket
(
)
:
largestBitLength
(
0
)
numberOfSymbols
(
0
)
{
}
;
uint8_t
largestBitLength
;
uint32_t
numberOfSymbols
;
}
;
Vector
<
Bucket
>
buckets
{
cx_
}
;
BINJS_TRY
(
buckets
.
resize
(
1
<
<
PrefixBitLength
)
)
;
for
(
const
auto
&
entry
:
values
)
{
const
HuffmanLookup
lookup
(
entry
.
key
.
bits
entry
.
key
.
bitLength
)
;
const
auto
split
=
lookup
.
split
(
PrefixBitLength
)
;
MOZ_ASSERT_IF
(
split
.
suffix
.
bitLength
!
=
32
split
.
suffix
.
bits
>
>
split
.
suffix
.
bitLength
=
=
0
)
;
for
(
const
auto
index
:
lookup
.
suffixes
(
PrefixBitLength
)
)
{
Bucket
&
bucket
=
buckets
[
index
]
;
if
(
split
.
suffix
.
bitLength
>
=
bucket
.
largestBitLength
)
{
bucket
.
largestBitLength
=
split
.
suffix
.
bitLength
;
}
bucket
.
numberOfSymbols
+
+
;
}
}
for
(
auto
&
bucket
:
buckets
)
{
Subtable
sub
(
cx_
)
;
MOZ_TRY
(
sub
.
initStart
(
cx_
bucket
.
numberOfSymbols
bucket
.
largestBitLength
)
)
;
BINJS_TRY
(
subTables
.
append
(
std
:
:
move
(
sub
)
)
)
;
}
for
(
size_t
i
=
0
;
i
<
values
.
length
(
)
;
+
+
i
)
{
const
auto
&
entry
=
values
[
i
]
;
const
HuffmanLookup
lookup
(
entry
.
key
.
bits
entry
.
key
.
bitLength
)
;
const
auto
split
=
lookup
.
split
(
PrefixBitLength
)
;
MOZ_ASSERT_IF
(
split
.
suffix
.
bitLength
!
=
32
split
.
suffix
.
bits
>
>
split
.
suffix
.
bitLength
=
=
0
)
;
for
(
const
auto
index
:
lookup
.
suffixes
(
PrefixBitLength
)
)
{
auto
&
sub
=
subTables
[
index
]
;
MOZ_TRY
(
sub
.
addSymbol
(
split
.
suffix
.
bits
split
.
suffix
.
bitLength
std
:
:
move
(
i
)
)
)
;
}
}
for
(
auto
&
sub
:
subTables
)
{
MOZ_TRY
(
sub
.
initComplete
(
)
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
HuffmanEntry
<
const
T
*
>
MultiLookupHuffmanTable
<
T
Subtable
PrefixBitLength
>
:
:
lookup
(
HuffmanLookup
key
)
const
{
const
auto
split
=
key
.
split
(
PrefixBitLength
)
;
if
(
split
.
prefix
.
bits
>
=
subTables
.
length
(
)
)
{
return
HuffmanEntry
<
const
T
*
>
(
0
0
nullptr
)
;
}
const
Subtable
&
subtable
=
subTables
[
split
.
prefix
.
bits
]
;
auto
found
=
subtable
.
lookup
(
split
.
suffix
)
;
if
(
found
.
value
=
=
nullptr
)
{
return
{
0
0
nullptr
}
;
}
const
auto
&
result
=
values
[
*
found
.
value
]
;
return
{
result
.
key
.
bits
result
.
key
.
bitLength
std
:
:
move
(
&
result
.
value
)
}
;
}
const
size_t
SUM_LIMITS
[
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
BINAST_SUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
#
define
WITH_SUM_CONTENTS
(
_SUM_NAME
_INDEX
INTERFACE_NAME
_MACRO_NAME
\
_SPEC_NAME
)
\
BinASTKind
:
:
INTERFACE_NAME
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
const
BinASTKind
SUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_INTERFACE_IN_SUM_
#
#
MACRO_NAME
(
WITH_SUM_CONTENTS
)
}
;
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
#
undef
WITH_SUM_CONTENTS
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
SUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
const
size_t
STRING_ENUM_LIMITS
[
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
BIN_AST_STRING_ENUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
#
define
WITH_ENUM_CONTENTS
(
_ENUM_NAME
VARIANT_NAME
_HUMAN_NAME
)
\
BinASTVariant
:
:
VARIANT_NAME
#
define
WITH_ENUM
(
_ENUM_NAME
_
MACRO_NAME
)
\
const
BinASTVariant
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_VARIANT_IN_STRING_ENUM_
#
#
MACRO_NAME
#
#
_BY_WEBIDL_ORDER
(
\
WITH_ENUM_CONTENTS
)
}
;
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
#
undef
WITH_ENUM_CONTENTS
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
run
(
size_t
initialCapacity
)
{
BINJS_TRY
(
stack
.
reserve
(
initialCapacity
)
)
;
MOZ_TRY
(
pushFields
(
BinASTKind
:
:
Script
)
)
;
while
(
stack
.
length
(
)
>
0
)
{
const
Entry
entry
=
stack
.
popCopy
(
)
;
MOZ_TRY
(
entry
.
match
(
ReadPoppedEntryMatcher
(
*
this
)
)
)
;
}
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Boolean
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Boolean
&
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
index
!
=
0
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Boolean
>
(
Boolean
:
:
Table
&
table
const
Boolean
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
indexByte
>
=
2
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
indexByte
!
=
0
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeInterface
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeInterface
&
entry
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
index
=
=
0
?
BinASTKind
:
:
_Null
:
entry
.
kind
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeInterface
>
(
MaybeInterface
:
:
Table
&
table
const
MaybeInterface
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader
.
readByte
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
indexByte
>
=
2
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
indexByte
=
=
0
?
BinASTKind
:
:
_Null
:
entry
.
kind
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Sum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Sum
&
entry
size_t
index
)
{
MOZ_ASSERT
(
index
<
entry
.
maxNumberOfSymbols
(
)
)
;
return
entry
.
interfaceAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Sum
>
(
HuffmanTableIndexedSymbolsSum
&
table
const
Sum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
sum
.
identity
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
sum
.
interfaceAt
(
index
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeSum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeSum
&
sum
size_t
index
)
{
MOZ_ASSERT
(
index
<
sum
.
maxNumberOfSymbols
(
)
)
;
return
sum
.
interfaceAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeSum
>
(
HuffmanTableIndexedSymbolsSum
&
table
const
MaybeSum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
sum
.
identity
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
sum
.
interfaceAt
(
index
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
number
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
double
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Number
&
number
size_t
)
{
uint8_t
bytes
[
8
]
;
MOZ_ASSERT
(
sizeof
(
bytes
)
=
=
sizeof
(
double
)
)
;
uint32_t
len
=
mozilla
:
:
ArrayLength
(
bytes
)
;
MOZ_TRY
(
(
reader
.
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
reinterpret_cast
<
uint8_t
*
>
(
bytes
)
len
)
)
)
;
const
uint64_t
asInt
=
mozilla
:
:
BigEndian
:
:
readUint64
(
bytes
)
;
return
JS
:
:
CanonicalizeNaN
(
mozilla
:
:
BitwiseCast
<
double
>
(
asInt
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Number
>
(
HuffmanTableExplicitSymbolsF64
&
table
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
value
readSymbol
(
number
0
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
List
&
list
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
list
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readSymbol
(
const
List
&
list
size_t
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readUnpackedLong
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_LIST_LENGTH
)
)
{
return
raiseInvalidTableData
(
list
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
List
>
(
HuffmanTableExplicitSymbolsListLength
&
table
const
List
&
list
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readUnpackedLong
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_LIST_LENGTH
)
)
{
return
raiseInvalidTableData
(
list
.
identity
)
;
}
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
length
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
String
&
string
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
|
|
length
>
reader
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
string
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
HuffmanPreludeReader
:
:
readSymbol
(
const
String
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
return
reader
.
metadata_
-
>
getAtom
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
String
>
(
HuffmanTableIndexedSymbolsLiteralString
&
table
const
String
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
JSAtom
*
value
=
reader
.
metadata_
-
>
getAtom
(
index
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeString
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
|
|
length
>
reader
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeString
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
index
=
=
0
)
{
return
nullptr
;
}
if
(
MOZ_UNLIKELY
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
return
reader
.
metadata_
-
>
getAtom
(
index
-
1
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeString
>
(
HuffmanTableIndexedSymbolsOptionalLiteralString
&
table
const
MaybeString
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
+
1
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
JSAtom
*
symbol
=
index
=
=
0
?
nullptr
:
reader
.
metadata_
-
>
getAtom
(
index
-
1
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
symbol
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
StringEnum
&
entry
)
{
return
entry
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
HuffmanPreludeReader
:
:
readSymbol
(
const
StringEnum
&
entry
size_t
index
)
{
return
entry
.
variantAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
StringEnum
>
(
HuffmanTableIndexedSymbolsStringEnum
&
table
const
StringEnum
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
index
>
entry
.
maxNumberOfSymbols
(
)
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BinASTVariant
symbol
=
entry
.
variantAt
(
index
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
symbol
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
UnsignedLong
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readSymbol
(
const
UnsignedLong
&
entry
size_t
)
{
return
reader
.
readUnpackedLong
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
UnsignedLong
>
(
HuffmanTableExplicitSymbolsU32
&
table
const
UnsignedLong
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readUnpackedLong
(
)
)
;
MOZ_TRY
(
table
.
initWithSingleValue
(
cx_
std
:
:
move
(
index
)
)
)
;
return
Ok
(
)
;
}
HuffmanDictionary
:
:
HuffmanDictionary
(
JSContext
*
cx
)
:
fields
(
BINAST_PARAM_NUMBER_OF_INTERFACE_AND_FIELD
(
mozilla
:
:
AsVariant
(
HuffmanTableUnreachable
(
)
)
)
)
listLengths
(
BINAST_PARAM_NUMBER_OF_LIST_TYPES
(
mozilla
:
:
AsVariant
(
HuffmanTableUnreachable
(
)
)
)
)
{
}
HuffmanTableValue
&
HuffmanDictionary
:
:
tableForField
(
NormalizedInterfaceAndField
index
)
{
return
fields
[
static_cast
<
size_t
>
(
index
.
identity
)
]
;
}
HuffmanTableListLength
&
HuffmanDictionary
:
:
tableForListLength
(
BinASTList
list
)
{
return
listLengths
[
static_cast
<
size_t
>
(
list
)
]
;
}
uint32_t
HuffmanLookup
:
:
leadingBits
(
const
uint8_t
aBitLength
)
const
{
MOZ_ASSERT
(
aBitLength
<
=
this
-
>
bitLength
)
;
const
uint32_t
result
=
(
aBitLength
=
=
0
)
?
0
:
this
-
>
bits
>
>
uint32_t
(
this
-
>
bitLength
-
aBitLength
)
;
return
result
;
}
Split
<
HuffmanLookup
>
HuffmanLookup
:
:
split
(
const
uint8_t
prefixLength
)
const
{
if
(
bitLength
<
=
prefixLength
)
{
return
{
{
bits
<
<
(
prefixLength
-
bitLength
)
prefixLength
}
{
0
0
}
}
;
}
const
uint8_t
shift
=
bitLength
-
prefixLength
;
switch
(
shift
)
{
case
0
:
return
{
{
bits
prefixLength
}
{
0
0
}
}
;
case
32
:
return
{
{
0
prefixLength
}
{
bits
shift
}
}
;
}
return
{
{
bits
>
>
shift
prefixLength
}
{
bits
&
(
mozilla
:
:
MaxValue
<
uint32_t
>
:
:
value
>
>
(
32
-
shift
)
)
shift
}
}
;
}
mozilla
:
:
detail
:
:
IntegerRange
<
size_t
>
HuffmanLookup
:
:
suffixes
(
uint8_t
expectedBitLength
)
const
{
if
(
expectedBitLength
<
=
bitLength
)
{
const
uint8_t
shearing
=
bitLength
-
expectedBitLength
;
const
size_t
first
=
size_t
(
bits
)
>
>
shearing
;
const
size_t
last
=
first
;
return
mozilla
:
:
IntegerRange
<
size_t
>
(
first
last
+
1
)
;
}
const
uint8_t
padding
=
expectedBitLength
-
bitLength
;
const
size_t
first
=
bits
<
<
padding
;
const
size_t
last
=
first
+
(
size_t
(
-
1
)
>
>
(
8
*
sizeof
(
size_t
)
-
padding
)
)
;
return
mozilla
:
:
IntegerRange
<
size_t
>
(
first
last
+
1
)
;
}
}
}
