#
include
"
frontend
/
BinASTTokenReaderContext
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
string
.
h
>
#
include
"
frontend
/
BinAST
-
macros
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSScript
.
h
"
namespace
js
{
namespace
frontend
{
const
char
CX_MAGIC_HEADER
[
]
=
"
\
x89
"
"
BJS
\
r
\
n
\
0
\
n
"
;
const
uint32_t
MAGIC_FORMAT_VERSION
=
2
;
const
uint8_t
MAX_CODE_BIT_LENGTH
=
20
;
const
uint8_t
MAX_PREFIX_BIT_LENGTH
=
32
;
const
uint8_t
BIT_BUFFER_LENGTH
=
64
;
const
uint8_t
BIT_BUFFER_READ_UNIT
=
8
;
const
uint32_t
MAX_NUMBER_OF_SYMBOLS
=
32768
;
const
uint32_t
MAX_LIST_LENGTH
=
std
:
:
min
(
(
uint32_t
)
32768
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
;
const
size_t
HUFFMAN_STACK_INITIAL_CAPACITY
=
1024
;
extern
const
size_t
SUM_LIMITS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
;
extern
const
size_t
STRING_ENUM_LIMITS
[
BINASTSTRINGENUM_LIMIT
]
;
extern
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
;
using
Compression
=
BinASTTokenReaderContext
:
:
Compression
;
using
EndOfFilePolicy
=
BinASTTokenReaderContext
:
:
EndOfFilePolicy
;
#
define
WRAP_INTERFACE
(
TYPE
)
Interface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_MAYBE_INTERFACE
(
TYPE
)
MaybeInterface
:
:
Maker
(
BinASTKind
:
:
TYPE
)
#
define
WRAP_PRIMITIVE
(
TYPE
)
TYPE
#
define
WRAP_LIST
(
TYPE
_
)
List
:
:
Maker
(
BinASTList
:
:
TYPE
)
#
define
WRAP_SUM
(
TYPE
)
Sum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_MAYBE_SUM
(
TYPE
)
MaybeSum
:
:
Maker
(
BinASTSum
:
:
TYPE
)
#
define
WRAP_STRING_ENUM
(
TYPE
)
StringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
#
define
WRAP_MAYBE_STRING_ENUM
(
TYPE
)
\
MaybeStringEnum
:
:
Maker
(
BinASTStringEnum
:
:
TYPE
)
using
AutoList
=
BinASTTokenReaderContext
:
:
AutoList
;
using
AutoTaggedTuple
=
BinASTTokenReaderContext
:
:
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Chars
=
BinASTTokenReaderContext
:
:
Chars
;
class
HuffmanPreludeReader
{
public
:
HuffmanPreludeReader
(
JSContext
*
cx
BinASTTokenReaderContext
&
reader
HuffmanDictionary
&
dictionary
)
:
cx_
(
cx
)
reader
(
reader
)
dictionary
(
dictionary
)
stack
(
cx_
)
auxStorageBitLengths
(
cx_
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
run
(
size_t
initialCapacity
)
;
private
:
JSContext
*
cx_
;
BinASTTokenReaderContext
&
reader
;
HuffmanDictionary
&
dictionary
;
public
:
enum
TableHeader
:
uint8_t
{
SingleValue
=
0x00
MultipleValues
=
0x01
Unreachable
=
0x02
}
;
struct
EntryBase
{
const
NormalizedInterfaceAndField
identity
;
explicit
EntryBase
(
const
NormalizedInterfaceAndField
identity
)
:
identity
(
identity
)
{
}
}
;
struct
EntryIndexed
:
EntryBase
{
explicit
EntryIndexed
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
String
:
EntryBase
{
using
SymbolType
=
JSAtom
*
;
using
Table
=
HuffmanTableIndexedSymbolsLiteralString
;
explicit
String
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
using
IdentifierName
=
String
;
using
PropertyKey
=
String
;
struct
MaybeString
:
EntryBase
{
using
SymbolType
=
JSAtom
*
;
using
Table
=
HuffmanTableIndexedSymbolsOptionalLiteralString
;
explicit
MaybeString
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
using
MaybeIdentifierName
=
MaybeString
;
using
MaybePropertyKey
=
MaybeString
;
struct
Number
:
EntryBase
{
using
SymbolType
=
double
;
using
Table
=
HuffmanTableExplicitSymbolsF64
;
explicit
Number
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
UnsignedLong
:
EntryBase
{
explicit
UnsignedLong
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
Boolean
:
EntryIndexed
{
using
SymbolType
=
bool
;
using
Table
=
HuffmanTableIndexedSymbolsBool
;
explicit
Boolean
(
const
NormalizedInterfaceAndField
identity
)
:
EntryIndexed
(
identity
)
{
}
}
;
struct
Lazy
:
EntryBase
{
explicit
Lazy
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
Interface
:
EntryBase
{
const
BinASTKind
kind
;
Interface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryBase
(
identity
)
kind
(
kind
)
{
}
struct
Maker
{
const
BinASTKind
kind
;
explicit
Maker
(
BinASTKind
kind
)
:
kind
(
kind
)
{
}
Interface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Interface
(
identity
kind
)
;
}
}
;
}
;
struct
MaybeInterface
:
EntryIndexed
{
using
SymbolType
=
Nullable
;
using
Table
=
HuffmanTableIndexedSymbolsMaybeInterface
;
const
BinASTKind
kind
;
MaybeInterface
(
const
NormalizedInterfaceAndField
identity
BinASTKind
kind
)
:
EntryIndexed
(
identity
)
kind
(
kind
)
{
}
size_t
maxMumberOfSymbols
(
)
const
{
return
2
;
}
struct
Maker
{
const
BinASTKind
kind
;
explicit
Maker
(
BinASTKind
kind
)
:
kind
(
kind
)
{
}
MaybeInterface
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeInterface
(
identity
kind
)
;
}
}
;
}
;
struct
List
:
EntryBase
{
using
SymbolType
=
uint32_t
;
using
Table
=
HuffmanTableExplicitSymbolsListLength
;
const
BinASTList
contents
;
List
(
const
NormalizedInterfaceAndField
identity
const
BinASTList
contents
)
:
EntryBase
(
identity
)
contents
(
contents
)
{
}
struct
Maker
{
const
BinASTList
contents
;
explicit
Maker
(
BinASTList
contents
)
:
contents
(
contents
)
{
}
List
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
{
identity
contents
}
;
}
}
;
}
;
struct
ListContents
:
EntryBase
{
explicit
ListContents
(
const
NormalizedInterfaceAndField
identity
)
:
EntryBase
(
identity
)
{
}
}
;
struct
Sum
:
EntryIndexed
{
using
SymbolType
=
BinASTKind
;
using
Table
=
HuffmanTableIndexedSymbolsSum
;
const
BinASTSum
contents
;
Sum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryIndexed
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTSum
contents
;
explicit
Maker
(
BinASTSum
contents
)
:
contents
(
contents
)
{
}
Sum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
Sum
(
identity
contents
)
;
}
}
;
}
;
struct
MaybeSum
:
EntryBase
{
using
SymbolType
=
BinASTKind
;
using
Table
=
HuffmanTableIndexedSymbolsSum
;
const
BinASTSum
contents
;
MaybeSum
(
const
NormalizedInterfaceAndField
identity
const
BinASTSum
contents
)
:
EntryBase
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
SUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
+
1
;
}
BinASTKind
interfaceAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
if
(
index
=
=
0
)
{
return
BinASTKind
:
:
_Null
;
}
return
SUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
-
1
]
;
}
struct
Maker
{
const
BinASTSum
contents
;
explicit
Maker
(
BinASTSum
contents
)
:
contents
(
contents
)
{
}
MaybeSum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
MaybeSum
(
identity
contents
)
;
}
}
;
}
;
struct
StringEnum
:
EntryBase
{
using
SymbolType
=
BinASTVariant
;
using
Table
=
HuffmanTableIndexedSymbolsStringEnum
;
const
BinASTStringEnum
contents
;
StringEnum
(
const
NormalizedInterfaceAndField
identity
const
BinASTStringEnum
contents
)
:
EntryBase
(
identity
)
contents
(
contents
)
{
}
size_t
maxNumberOfSymbols
(
)
const
{
return
STRING_ENUM_LIMITS
[
static_cast
<
size_t
>
(
contents
)
]
;
}
BinASTVariant
variantAt
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
maxNumberOfSymbols
(
)
)
;
return
STRING_ENUM_RESOLUTIONS
[
static_cast
<
size_t
>
(
contents
)
]
[
index
]
;
}
struct
Maker
{
const
BinASTStringEnum
contents
;
explicit
Maker
(
BinASTStringEnum
contents
)
:
contents
(
contents
)
{
}
StringEnum
operator
(
)
(
const
NormalizedInterfaceAndField
identity
)
{
return
StringEnum
(
identity
contents
)
;
}
}
;
}
;
using
Entry
=
mozilla
:
:
Variant
<
Boolean
String
MaybeString
Number
UnsignedLong
Lazy
Interface
MaybeInterface
List
Sum
MaybeSum
StringEnum
>
;
Vector
<
Entry
>
stack
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
pushValue
(
NormalizedInterfaceAndField
identity
const
Entry
&
entry
)
{
if
(
!
dictionary
.
tableForField
(
identity
)
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
BINJS_TRY
(
stack
.
append
(
entry
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
pushFields
(
BinASTKind
tag
)
{
switch
(
tag
)
{
#
define
EMIT_FIELD
(
TAG_NAME
FIELD_NAME
FIELD_INDEX
FIELD_TYPE
_
)
\
MOZ_TRY
(
\
pushValue
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
\
Entry
(
FIELD_TYPE
(
NormalizedInterfaceAndField
(
\
BinASTInterfaceAndField
:
:
TAG_NAME
#
#
__
#
#
FIELD_NAME
)
)
)
)
)
;
#
define
EMIT_CASE
(
TAG_ENUM_NAME
_2
TAG_MACRO_NAME
)
\
case
BinASTKind
:
:
TAG_ENUM_NAME
:
{
\
FOR_EACH_BIN_FIELD_IN_INTERFACE_
#
#
TAG_MACRO_NAME
(
\
EMIT_FIELD
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
\
WRAP_LIST
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
\
WRAP_MAYBE_STRING_ENUM
)
;
\
break
;
\
}
FOR_EACH_BIN_KIND
(
EMIT_CASE
)
#
undef
EMIT_CASE
#
undef
EMIT_FIELD
}
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Entry
:
:
SymbolType
>
readSymbol
(
const
Entry
&
size_t
index
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readNumberOfSymbols
(
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readSingleValueTable
(
typename
Entry
:
:
Table
&
const
Entry
&
)
;
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readMultipleValuesTable
(
typename
Entry
:
:
Table
&
table
Entry
entry
)
{
BINJS_MOZ_TRY_DECL
(
numberOfSymbols
readNumberOfSymbols
<
Entry
>
(
entry
)
)
;
MOZ_ASSERT
(
numberOfSymbols
<
=
MAX_NUMBER_OF_SYMBOLS
)
;
MOZ_ASSERT
(
auxStorageBitLengths
.
empty
(
)
)
;
BINJS_TRY
(
auxStorageBitLengths
.
reserve
(
numberOfSymbols
+
1
)
)
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
BINJS_MOZ_TRY_DECL
(
bitLength
reader
.
readByte
<
Compression
:
:
Yes
>
(
)
)
;
if
(
bitLength
=
=
0
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BINJS_TRY
(
auxStorageBitLengths
.
append
(
bitLength
)
)
;
}
BINJS_TRY
(
auxStorageBitLengths
.
append
(
MAX_CODE_BIT_LENGTH
)
)
;
uint32_t
code
=
0
;
MOZ_TRY
(
table
.
impl
.
init
(
cx_
numberOfSymbols
)
)
;
for
(
size_t
i
=
0
;
i
<
numberOfSymbols
;
+
+
i
)
{
const
auto
bitLength
=
auxStorageBitLengths
[
i
]
;
const
auto
nextBitLength
=
auxStorageBitLengths
[
i
+
1
]
;
if
(
bitLength
>
nextBitLength
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BINJS_MOZ_TRY_DECL
(
symbol
readSymbol
<
Entry
>
(
entry
i
)
)
;
MOZ_TRY
(
table
.
impl
.
addSymbol
(
code
bitLength
std
:
:
move
(
symbol
)
)
)
;
code
=
(
code
+
1
)
<
<
(
nextBitLength
-
bitLength
)
;
}
auxStorageBitLengths
.
clear
(
)
;
return
Ok
(
)
;
}
template
<
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
Entry
entry
)
{
auto
&
table
=
dictionary
.
tableForField
(
entry
.
identity
)
;
return
readTable
<
HuffmanTable
Entry
>
(
table
entry
)
;
}
template
<
typename
HuffmanTable
typename
Entry
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTable
(
HuffmanTable
&
table
Entry
entry
)
{
if
(
!
table
.
template
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
raiseDuplicateTableError
(
entry
.
identity
)
;
}
uint8_t
headerByte
;
MOZ_TRY_VAR
(
headerByte
reader
.
readByte
<
Compression
:
:
Yes
>
(
)
)
;
switch
(
headerByte
)
{
case
TableHeader
:
:
SingleValue
:
{
table
=
{
mozilla
:
:
VariantType
<
typename
Entry
:
:
Table
>
{
}
cx_
}
;
auto
&
tableRef
=
table
.
template
as
<
typename
Entry
:
:
Table
>
(
)
;
MOZ_TRY
(
(
readSingleValueTable
<
Entry
>
(
tableRef
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
MultipleValues
:
{
table
=
{
mozilla
:
:
VariantType
<
typename
Entry
:
:
Table
>
{
}
cx_
}
;
auto
&
tableRef
=
table
.
template
as
<
typename
Entry
:
:
Table
>
(
)
;
MOZ_TRY
(
(
readMultipleValuesTable
<
Entry
>
(
tableRef
entry
)
)
)
;
return
Ok
(
)
;
}
case
TableHeader
:
:
Unreachable
:
return
Ok
(
)
;
default
:
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
}
private
:
Vector
<
uint8_t
>
auxStorageBitLengths
;
struct
EntryMatcher
{
HuffmanPreludeReader
&
owner
;
explicit
EntryMatcher
(
HuffmanPreludeReader
&
owner
)
:
owner
(
owner
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Lazy
&
entry
)
{
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Boolean
&
entry
)
{
return
owner
.
readTable
<
Boolean
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Interface
&
entry
)
{
return
owner
.
pushFields
(
entry
.
kind
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeInterface
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeInterface
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsMaybeInterface
>
(
)
;
if
(
!
tableRef
.
isAlwaysNull
(
)
)
{
MOZ_TRY
(
owner
.
pushFields
(
entry
.
kind
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Sum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
Sum
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsSum
>
(
)
;
for
(
const
auto
&
kind
:
tableRef
.
impl
)
{
MOZ_TRY
(
owner
.
pushValue
(
entry
.
identity
{
mozilla
:
:
VariantType
<
Interface
>
(
)
entry
.
identity
kind
.
value
}
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeSum
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
MaybeSum
>
(
entry
)
)
)
;
const
auto
&
table
=
owner
.
dictionary
.
tableForField
(
entry
.
identity
)
;
if
(
table
.
is
<
HuffmanTableUnreachable
>
(
)
)
{
return
Ok
(
)
;
}
const
auto
&
tableRef
=
table
.
as
<
HuffmanTableIndexedSymbolsSum
>
(
)
;
for
(
const
auto
&
kind
:
tableRef
.
impl
)
{
MOZ_TRY
(
owner
.
pushValue
(
entry
.
identity
{
mozilla
:
:
VariantType
<
Interface
>
(
)
entry
.
identity
kind
.
value
}
)
)
;
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
Number
&
entry
)
{
return
owner
.
readTable
<
Number
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
List
&
entry
)
{
MOZ_TRY
(
(
owner
.
readTable
<
HuffmanTableListLength
List
>
(
owner
.
dictionary
.
tableForListLength
(
entry
.
contents
)
entry
)
)
)
;
switch
(
entry
.
contents
)
{
#
define
EMIT_CASE
(
LIST_NAME
_CONTENT_NAME
_HUMAN_NAME
TYPE
)
\
case
BinASTList
:
:
LIST_NAME
:
\
return
owner
.
pushValue
(
entry
.
identity
Entry
(
TYPE
(
entry
.
identity
)
)
)
;
FOR_EACH_BIN_LIST
(
EMIT_CASE
WRAP_PRIMITIVE
WRAP_INTERFACE
WRAP_MAYBE_INTERFACE
WRAP_LIST
WRAP_SUM
WRAP_MAYBE_SUM
WRAP_STRING_ENUM
WRAP_MAYBE_STRING_ENUM
)
#
undef
EMIT_CASE
}
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
String
&
entry
)
{
return
owner
.
readTable
<
String
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
MaybeString
&
entry
)
{
return
owner
.
readTable
<
MaybeString
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
StringEnum
&
entry
)
{
return
owner
.
readTable
<
StringEnum
>
(
entry
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
operator
(
)
(
const
UnsignedLong
&
entry
)
{
MOZ_CRASH
(
"
Unimplemented
"
)
;
return
Ok
(
)
;
}
}
;
template
<
typename
T
>
using
ErrorResult
=
BinASTTokenReaderBase
:
:
ErrorResult
<
T
>
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseDuplicateTableError
(
const
NormalizedInterfaceAndField
identity
)
{
MOZ_CRASH
(
"
FIXME
:
Implement
"
)
;
return
reader
.
raiseError
(
"
Duplicate
table
.
"
)
;
}
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidTableData
(
const
NormalizedInterfaceAndField
identity
)
{
MOZ_CRASH
(
"
FIXME
:
Implement
"
)
;
return
reader
.
raiseError
(
"
Invalid
data
while
reading
table
.
"
)
;
}
}
;
using
Boolean
=
HuffmanPreludeReader
:
:
Boolean
;
using
Interface
=
HuffmanPreludeReader
:
:
Interface
;
using
List
=
HuffmanPreludeReader
:
:
List
;
using
MaybeInterface
=
HuffmanPreludeReader
:
:
MaybeInterface
;
using
MaybeString
=
HuffmanPreludeReader
:
:
MaybeString
;
using
MaybeSum
=
HuffmanPreludeReader
:
:
MaybeSum
;
using
Number
=
HuffmanPreludeReader
:
:
Number
;
using
String
=
HuffmanPreludeReader
:
:
String
;
using
StringEnum
=
HuffmanPreludeReader
:
:
StringEnum
;
using
Sum
=
HuffmanPreludeReader
:
:
Sum
;
BinASTTokenReaderContext
:
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
BinASTTokenReaderBase
(
cx
er
start
length
)
metadata_
(
nullptr
)
dictionary
(
cx
)
posBeforeTree_
(
nullptr
)
{
MOZ_ASSERT
(
er
)
;
}
BinASTTokenReaderContext
:
:
~
BinASTTokenReaderContext
(
)
{
if
(
metadata_
&
&
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
{
UniqueBinASTSourceMetadataPtr
ptr
(
metadata_
)
;
}
if
(
decoder_
)
{
BrotliDecoderDestroyInstance
(
decoder_
)
;
}
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
No
EndOfFilePolicy
:
:
RaiseError
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
return
Base
:
:
readBuf
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
RaiseError
>
(
)
{
return
raiseError
(
"
Unexpected
end
of
stream
"
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
handleEndOfStream
<
EndOfFilePolicy
:
:
BestEffort
>
(
)
{
return
Ok
(
)
;
}
template
<
EndOfFilePolicy
policy
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
{
uint32_t
remaining
=
len
;
len
=
0
;
while
(
availableDecodedLength
(
)
<
remaining
)
{
if
(
availableDecodedLength
(
)
)
{
memmove
(
bytes
decodedBufferBegin
(
)
availableDecodedLength
(
)
)
;
bytes
+
=
availableDecodedLength
(
)
;
remaining
-
=
availableDecodedLength
(
)
;
len
+
=
availableDecodedLength
(
)
;
}
BINJS_MOZ_TRY_DECL
(
fillResult
fillDecodedBuf
(
)
)
;
if
(
fillResult
=
=
FillResult
:
:
EndOfStream
)
{
MOZ_TRY
(
handleEndOfStream
<
policy
>
(
)
)
;
if
(
availableDecodedLength
(
)
=
=
0
)
{
break
;
}
}
}
memmove
(
bytes
decodedBufferBegin
(
)
remaining
)
;
advanceDecodedBuffer
(
remaining
)
;
return
Ok
(
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
Yes
EndOfFilePolicy
:
:
RaiseError
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
return
readBufCompressedAux
<
EndOfFilePolicy
:
:
RaiseError
>
(
bytes
len
)
;
}
template
<
>
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readBuf
<
Compression
:
:
Yes
EndOfFilePolicy
:
:
BestEffort
>
(
uint8_t
*
bytes
uint32_t
&
len
)
{
return
readBufCompressedAux
<
EndOfFilePolicy
:
:
BestEffort
>
(
bytes
len
)
;
}
JS
:
:
Result
<
BinASTTokenReaderContext
:
:
FillResult
>
BinASTTokenReaderContext
:
:
fillDecodedBuf
(
)
{
if
(
isEOF
(
)
)
{
return
BinASTTokenReaderContext
:
:
FillResult
:
:
EndOfStream
;
}
MOZ_ASSERT
(
!
availableDecodedLength
(
)
)
;
decodedBegin_
=
0
;
size_t
inSize
=
stop_
-
current_
;
size_t
outSize
=
DECODED_BUFFER_SIZE
;
uint8_t
*
out
=
decodedBuffer_
;
BrotliDecoderResult
result
;
result
=
BrotliDecoderDecompressStream
(
decoder_
&
inSize
&
current_
&
outSize
&
out
nullptr
)
;
if
(
result
=
=
BROTLI_DECODER_RESULT_ERROR
)
{
return
raiseError
(
"
Failed
to
decompress
brotli
stream
"
)
;
}
decodedEnd_
=
out
-
decodedBuffer_
;
return
BinASTTokenReaderContext
:
:
FillResult
:
:
Filled
;
}
void
BinASTTokenReaderContext
:
:
advanceDecodedBuffer
(
uint32_t
count
)
{
MOZ_ASSERT
(
decodedBegin_
+
count
<
=
decodedEnd_
)
;
decodedBegin_
+
=
count
;
}
bool
BinASTTokenReaderContext
:
:
isEOF
(
)
const
{
return
BrotliDecoderIsFinished
(
decoder_
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
Compression
:
:
No
>
(
)
{
return
Base
:
:
readByte
(
)
;
}
template
<
>
JS
:
:
Result
<
uint8_t
>
BinASTTokenReaderContext
:
:
readByte
<
Compression
:
:
Yes
>
(
)
{
uint8_t
buf
;
uint32_t
len
=
1
;
MOZ_TRY
(
(
readBuf
<
Compression
:
:
Yes
EndOfFilePolicy
:
:
RaiseError
>
(
&
buf
len
)
)
)
;
return
buf
;
}
BinASTSourceMetadata
*
BinASTTokenReaderContext
:
:
takeMetadata
(
)
{
MOZ_ASSERT
(
metadataOwned_
=
=
MetadataOwnership
:
:
Owned
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
metadata_
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
initFromScriptSource
(
ScriptSource
*
scriptSource
)
{
metadata_
=
scriptSource
-
>
binASTSourceMetadata
(
)
;
metadataOwned_
=
MetadataOwnership
:
:
Unowned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHeader
(
)
{
MOZ_ASSERT
(
!
posBeforeTree_
)
;
MOZ_TRY
(
readConst
(
CX_MAGIC_HEADER
)
)
;
BINJS_MOZ_TRY_DECL
(
version
readVarU32
<
Compression
:
:
No
>
(
)
)
;
if
(
version
!
=
MAGIC_FORMAT_VERSION
)
{
return
raiseError
(
"
Format
version
not
implemented
"
)
;
}
decoder_
=
BrotliDecoderCreateInstance
(
nullptr
nullptr
nullptr
)
;
if
(
!
decoder_
)
{
return
raiseError
(
"
Failed
to
create
brotli
decoder
"
)
;
}
MOZ_TRY
(
readStringPrelude
(
)
)
;
MOZ_TRY
(
readHuffmanPrelude
(
)
)
;
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readStringPrelude
(
)
{
BINJS_MOZ_TRY_DECL
(
stringsNumberOfEntries
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
const
uint32_t
MAX_NUMBER_OF_STRINGS
=
32768
;
if
(
stringsNumberOfEntries
>
MAX_NUMBER_OF_STRINGS
)
{
return
raiseError
(
"
Too
many
entries
in
strings
dictionary
"
)
;
}
Vector
<
BinASTKind
>
binASTKinds
(
cx_
)
;
BinASTSourceMetadata
*
metadata
=
BinASTSourceMetadata
:
:
Create
(
binASTKinds
stringsNumberOfEntries
)
;
if
(
!
metadata
)
{
return
raiseOOM
(
)
;
}
auto
se
=
mozilla
:
:
MakeScopeExit
(
[
metadata
]
(
)
{
js_free
(
metadata
)
;
}
)
;
StringBuffer
buf
(
cx_
)
;
RootedAtom
atom
(
cx_
)
;
for
(
uint32_t
stringIndex
=
0
;
stringIndex
<
stringsNumberOfEntries
;
stringIndex
+
+
)
{
size_t
len
;
while
(
true
)
{
if
(
availableDecodedLength
(
)
=
=
0
)
{
MOZ_TRY
(
fillDecodedBuf
(
)
)
;
}
MOZ_ASSERT
(
availableDecodedLength
(
)
>
0
)
;
const
uint8_t
*
end
=
static_cast
<
const
uint8_t
*
>
(
memchr
(
decodedBufferBegin
(
)
'
\
0
'
availableDecodedLength
(
)
)
)
;
if
(
end
)
{
len
=
end
-
decodedBufferBegin
(
)
;
break
;
}
BINJS_TRY
(
buf
.
append
(
decodedBufferBegin
(
)
availableDecodedLength
(
)
)
)
;
advanceDecodedBuffer
(
availableDecodedLength
(
)
)
;
}
if
(
!
buf
.
length
(
)
)
{
const
char
*
begin
=
reinterpret_cast
<
const
char
*
>
(
decodedBufferBegin
(
)
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
begin
len
)
)
;
}
else
{
BINJS_TRY
(
buf
.
append
(
reinterpret_cast
<
const
char
*
>
(
decodedBufferBegin
(
)
)
len
)
)
;
const
char
*
begin
=
reinterpret_cast
<
const
char
*
>
(
buf
.
rawLatin1Begin
(
)
)
;
len
=
buf
.
length
(
)
;
BINJS_TRY_VAR
(
atom
AtomizeWTF8Chars
(
cx_
begin
len
)
)
;
buf
.
clear
(
)
;
}
metadata
-
>
getAtom
(
stringIndex
)
=
atom
;
advanceDecodedBuffer
(
len
+
1
)
;
}
MOZ_ASSERT
(
!
metadata_
)
;
MOZ_ASSERT
(
buf
.
empty
(
)
)
;
se
.
release
(
)
;
metadata_
=
metadata
;
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readHuffmanPrelude
(
)
{
HuffmanPreludeReader
reader
{
cx_
*
this
dictionary
}
;
return
reader
.
run
(
HUFFMAN_STACK_INITIAL_CAPACITY
)
;
}
BinASTTokenReaderContext
:
:
BitBuffer
:
:
BitBuffer
(
)
:
bits
(
0
)
length
(
0
)
{
static_assert
(
sizeof
(
bits
)
*
8
=
=
BIT_BUFFER_LENGTH
"
Expecting
bitBuffer
to
match
BIT_BUFFER_LENGTH
"
)
;
}
template
<
Compression
C
>
HuffmanLookup
BinASTTokenReaderContext
:
:
BitBuffer
:
:
getHuffmanLookup
(
)
{
const
uint8_t
bitLength
=
std
:
:
min
<
uint8_t
>
(
length
MAX_PREFIX_BIT_LENGTH
)
;
const
uint32_t
bitsPrefix
=
bits
&
(
uint64_t
)
0x00000000FFFFFFFF
;
return
HuffmanLookup
(
bitsPrefix
bitLength
)
;
}
template
<
Compression
C
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
BitBuffer
:
:
advanceBitBuffer
(
BinASTTokenReaderContext
&
owner
const
uint8_t
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
this
-
>
length
)
;
this
-
>
length
-
=
bitLength
;
this
-
>
bits
<
<
=
bitLength
;
if
(
length
<
=
MAX_PREFIX_BIT_LENGTH
)
{
while
(
length
<
=
BIT_BUFFER_LENGTH
-
BIT_BUFFER_READ_UNIT
)
{
uint8_t
byte
;
uint32_t
byteLen
=
1
;
MOZ_TRY
(
(
owner
.
readBuf
<
C
EndOfFilePolicy
:
:
BestEffort
>
(
&
byte
byteLen
)
)
)
;
if
(
byteLen
<
1
)
{
break
;
}
MOZ_ASSERT
(
bits
<
=
0x00FFFFFFFFFFFFFF
)
;
this
-
>
bits
<
<
=
BIT_BUFFER_READ_UNIT
;
this
-
>
bits
+
=
byte
;
this
-
>
length
+
=
BIT_BUFFER_READ_UNIT
;
MOZ_ASSERT
(
bits
>
>
this
-
>
length
=
=
0
)
;
}
}
return
Ok
(
)
;
}
void
BinASTTokenReaderContext
:
:
traceMetadata
(
JSTracer
*
trc
)
{
if
(
metadata_
)
{
metadata_
-
>
trace
(
trc
)
;
}
}
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
BinASTTokenReaderContext
:
:
raiseInvalidValue
(
const
Context
&
)
{
errorReporter_
-
>
errorNoOffset
(
JSMSG_BINAST
"
Invalid
value
"
)
;
return
cx_
-
>
alreadyReportedError
(
)
;
}
struct
ExtractBinASTInterfaceAndFieldMatcher
{
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
FieldContext
&
context
)
{
return
context
.
position
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
ListContext
&
context
)
{
return
context
.
position
;
}
BinASTInterfaceAndField
operator
(
)
(
const
BinASTTokenReaderBase
:
:
RootContext
&
)
{
MOZ_CRASH
(
"
The
root
context
has
no
interface
/
field
"
)
;
}
}
;
template
<
typename
Table
>
JS
:
:
Result
<
typename
Table
:
:
Contents
>
BinASTTokenReaderContext
:
:
readFieldFromTable
(
const
Context
&
context
)
{
BinASTInterfaceAndField
identity
=
context
.
match
(
ExtractBinASTInterfaceAndFieldMatcher
(
)
)
;
const
auto
&
table
=
dictionary
.
tableForField
(
NormalizedInterfaceAndField
(
identity
)
)
;
const
auto
lookup
=
table
.
as
<
Table
>
(
)
.
impl
.
lookup
(
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
Yes
>
(
)
)
;
MOZ_TRY
(
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
Yes
>
(
*
this
lookup
.
key
.
bitLength
)
)
;
if
(
!
lookup
.
value
)
{
return
raiseInvalidValue
(
context
)
;
}
return
*
lookup
.
value
;
}
JS
:
:
Result
<
bool
>
BinASTTokenReaderContext
:
:
readBool
(
const
Context
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsBool
>
(
context
)
;
}
JS
:
:
Result
<
double
>
BinASTTokenReaderContext
:
:
readDouble
(
const
Context
&
context
)
{
return
readFieldFromTable
<
HuffmanTableExplicitSymbolsF64
>
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeAtom
(
const
Context
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsOptionalLiteralString
>
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readAtom
(
const
Context
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsLiteralString
>
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readMaybeIdentifierName
(
const
Context
&
context
)
{
return
readMaybeAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readIdentifierName
(
const
Context
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
JSAtom
*
>
BinASTTokenReaderContext
:
:
readPropertyKey
(
const
Context
&
context
)
{
return
readAtom
(
context
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
readChars
(
Chars
&
out
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
BinASTVariant
>
BinASTTokenReaderContext
:
:
readVariant
(
const
Context
&
context
)
{
return
readFieldFromTable
<
HuffmanTableIndexedSymbolsStringEnum
>
(
context
)
;
}
JS
:
:
Result
<
BinASTTokenReaderBase
:
:
SkippableSubTree
>
BinASTTokenReaderContext
:
:
readSkippableSubTree
(
const
Context
&
)
{
return
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
const
Context
&
context
AutoTaggedTuple
&
guard
)
{
if
(
context
.
is
<
BinASTTokenReaderBase
:
:
RootContext
>
(
)
)
{
tag
=
BinASTKind
:
:
Script
;
return
Ok
(
)
;
}
MOZ_TRY_VAR
(
tag
(
readFieldFromTable
<
HuffmanTableIndexedSymbolsSum
>
(
context
)
)
)
;
return
Ok
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
enterList
(
uint32_t
&
items
const
Context
&
context
AutoList
&
guard
)
{
const
auto
identity
=
context
.
as
<
BinASTTokenReaderBase
:
:
ListContext
>
(
)
.
content
;
const
auto
&
table
=
dictionary
.
tableForListLength
(
identity
)
;
const
auto
lookup
=
table
.
as
<
HuffmanTableExplicitSymbolsListLength
>
(
)
.
impl
.
lookup
(
bitBuffer
.
getHuffmanLookup
<
Compression
:
:
Yes
>
(
)
)
;
MOZ_TRY
(
bitBuffer
.
advanceBitBuffer
<
Compression
:
:
Yes
>
(
*
this
lookup
.
key
.
bitLength
)
)
;
if
(
!
lookup
.
value
)
{
return
raiseInvalidValue
(
context
)
;
}
items
=
*
lookup
.
value
;
return
Ok
(
)
;
}
void
BinASTTokenReaderContext
:
:
AutoBase
:
:
init
(
)
{
initialized_
=
true
;
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
AutoBase
(
BinASTTokenReaderContext
&
reader
)
:
initialized_
(
false
)
reader_
(
reader
)
{
}
BinASTTokenReaderContext
:
:
AutoBase
:
:
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoBase
:
:
checkPosition
(
const
uint8_t
*
expectedEnd
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
BinASTTokenReaderContext
:
:
AutoList
:
:
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
void
BinASTTokenReaderContext
:
:
AutoList
:
:
init
(
)
{
AutoBase
:
:
init
(
)
;
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoList
:
:
done
(
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
template
<
Compression
compression
>
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readVarU32
(
)
{
uint32_t
result
=
0
;
uint32_t
shift
=
0
;
while
(
true
)
{
MOZ_ASSERT
(
shift
<
32
)
;
uint32_t
byte
;
MOZ_TRY_VAR
(
byte
readByte
<
compression
>
(
)
)
;
const
uint32_t
newResult
=
result
|
(
byte
&
0x7f
)
<
<
shift
;
if
(
newResult
<
result
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
result
=
newResult
;
shift
+
=
7
;
if
(
(
byte
&
0x80
)
=
=
0
)
{
return
result
;
}
if
(
shift
>
=
32
)
{
return
raiseError
(
"
Overflow
during
readVarU32
"
)
;
}
}
}
JS
:
:
Result
<
uint32_t
>
BinASTTokenReaderContext
:
:
readUnsignedLong
(
const
Context
&
)
{
return
readVarU32
<
Compression
:
:
Yes
>
(
)
;
}
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
JS
:
:
Result
<
Ok
>
BinASTTokenReaderContext
:
:
AutoTaggedTuple
:
:
done
(
)
{
return
reader_
.
raiseError
(
"
Not
Yet
Implemented
"
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
HuffmanTableImpl
<
T
N
>
:
:
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
!
values
.
append
(
HuffmanEntry
<
T
>
(
0
0
std
:
:
move
(
value
)
)
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
HuffmanTableImpl
<
T
N
>
:
:
init
(
JSContext
*
cx
size_t
numberOfSymbols
)
{
MOZ_ASSERT
(
values
.
empty
(
)
)
;
if
(
!
values
.
initCapacity
(
numberOfSymbols
)
)
{
return
cx
-
>
alreadyReportedError
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
JS
:
:
Result
<
Ok
>
HuffmanTableImpl
<
T
N
>
:
:
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
{
MOZ_ASSERT
(
bitLength
!
=
0
"
Adding
a
symbol
with
a
bitLength
of
0
doesn
'
t
make
sense
.
"
)
;
MOZ_ASSERT
(
values
.
empty
(
)
|
|
values
.
back
(
)
.
key
.
bitLength
<
=
bitLength
"
Symbols
must
be
ranked
by
increasing
bits
length
"
)
;
MOZ_ASSERT
(
bits
>
>
bitLength
=
=
0
)
;
if
(
!
values
.
emplaceBack
(
bits
bitLength
std
:
:
move
(
value
)
)
)
{
MOZ_CRASH
(
)
;
}
return
Ok
(
)
;
}
template
<
typename
T
int
N
>
HuffmanEntry
<
const
T
*
>
HuffmanTableImpl
<
T
N
>
:
:
lookup
(
HuffmanLookup
key
)
const
{
MOZ_ASSERT
(
length
(
)
>
0
)
;
for
(
const
auto
&
iter
:
values
)
{
if
(
iter
.
key
.
bitLength
>
key
.
bitLength
)
{
break
;
}
const
uint32_t
keyBits
=
key
.
leadingBits
(
iter
.
key
.
bitLength
)
;
if
(
keyBits
=
=
iter
.
key
.
bits
)
{
return
HuffmanEntry
<
const
T
*
>
(
iter
.
key
.
bits
iter
.
key
.
bitLength
&
iter
.
value
)
;
}
}
return
HuffmanEntry
<
const
T
*
>
(
0
0
nullptr
)
;
}
const
size_t
SUM_LIMITS
[
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
BINAST_SUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
#
define
WITH_SUM_CONTENTS
(
_SUM_NAME
_INDEX
INTERFACE_NAME
_MACRO_NAME
\
_SPEC_NAME
)
\
BinASTKind
:
:
INTERFACE_NAME
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
const
BinASTKind
SUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_INTERFACE_IN_SUM_
#
#
MACRO_NAME
(
WITH_SUM_CONTENTS
)
}
;
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
#
undef
WITH_SUM_CONTENTS
const
BinASTKind
*
SUM_RESOLUTIONS
[
BINAST_NUMBER_OF_SUM_TYPES
]
{
#
define
WITH_SUM
(
_ENUM_NAME
_HUMAN_NAME
MACRO_NAME
_TYPE_NAME
)
\
SUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_SUM
(
WITH_SUM
)
#
undef
WITH_SUM
}
;
const
size_t
STRING_ENUM_LIMITS
[
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
BIN_AST_STRING_ENUM_
#
#
MACRO_NAME
#
#
_LIMIT
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
#
define
WITH_ENUM_CONTENTS
(
_ENUM_NAME
VARIANT_NAME
_HUMAN_NAME
)
\
BinASTVariant
:
:
VARIANT_NAME
#
define
WITH_ENUM
(
_ENUM_NAME
_
MACRO_NAME
)
\
const
BinASTVariant
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
[
]
{
\
FOR_EACH_BIN_VARIANT_IN_STRING_ENUM_
#
#
MACRO_NAME
#
#
_BY_STRING_ORDER
(
\
WITH_ENUM_CONTENTS
)
}
;
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
#
undef
WITH_ENUM_CONTENTS
const
BinASTVariant
*
STRING_ENUM_RESOLUTIONS
[
BINASTSTRINGENUM_LIMIT
]
{
#
define
WITH_ENUM
(
name
_
MACRO_NAME
)
STRING_ENUM_RESOLUTION_
#
#
MACRO_NAME
FOR_EACH_BIN_STRING_ENUM
(
WITH_ENUM
)
#
undef
WITH_ENUM
}
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
run
(
size_t
initialCapacity
)
{
BINJS_TRY
(
stack
.
reserve
(
initialCapacity
)
)
;
MOZ_TRY
(
pushFields
(
BinASTKind
:
:
Script
)
)
;
while
(
stack
.
length
(
)
>
0
)
{
const
Entry
entry
=
stack
.
popCopy
(
)
;
MOZ_TRY
(
entry
.
match
(
EntryMatcher
(
*
this
)
)
)
;
}
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Boolean
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Boolean
&
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
index
!
=
0
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Boolean
>
(
Boolean
:
:
Table
&
table
const
Boolean
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader
.
readByte
<
Compression
:
:
Yes
>
(
)
)
;
if
(
indexByte
>
=
2
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
indexByte
!
=
0
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeInterface
&
)
{
return
2
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Nullable
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeInterface
&
size_t
index
)
{
MOZ_ASSERT
(
index
<
2
)
;
return
index
=
=
0
?
Nullable
:
:
Null
:
Nullable
:
:
NonNull
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeInterface
>
(
MaybeInterface
:
:
Table
&
table
const
MaybeInterface
&
entry
)
{
uint8_t
indexByte
;
MOZ_TRY_VAR
(
indexByte
reader
.
readByte
<
Compression
:
:
Yes
>
(
)
)
;
if
(
indexByte
>
=
2
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
indexByte
=
=
0
?
Nullable
:
:
Null
:
Nullable
:
:
NonNull
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Sum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Sum
&
entry
size_t
index
)
{
MOZ_ASSERT
(
index
<
entry
.
maxNumberOfSymbols
(
)
)
;
return
entry
.
interfaceAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Sum
>
(
HuffmanTableIndexedSymbolsSum
&
table
const
Sum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
{
return
raiseInvalidTableData
(
sum
.
identity
)
;
}
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
sum
.
interfaceAt
(
index
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeSum
&
sum
)
{
return
sum
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeSum
&
sum
size_t
index
)
{
MOZ_ASSERT
(
index
<
sum
.
maxNumberOfSymbols
(
)
)
;
return
sum
.
interfaceAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeSum
>
(
HuffmanTableIndexedSymbolsSum
&
table
const
MaybeSum
&
sum
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
=
sum
.
maxNumberOfSymbols
(
)
)
{
return
raiseInvalidTableData
(
sum
.
identity
)
;
}
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
sum
.
interfaceAt
(
index
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
length
>
MAX_NUMBER_OF_SYMBOLS
)
{
return
raiseInvalidTableData
(
number
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
double
>
HuffmanPreludeReader
:
:
readSymbol
(
const
Number
&
number
size_t
)
{
uint8_t
bytes
[
8
]
;
MOZ_ASSERT
(
sizeof
(
bytes
)
=
=
sizeof
(
double
)
)
;
uint32_t
len
=
mozilla
:
:
ArrayLength
(
bytes
)
;
MOZ_TRY
(
(
reader
.
readBuf
<
Compression
:
:
Yes
EndOfFilePolicy
:
:
RaiseError
>
(
reinterpret_cast
<
uint8_t
*
>
(
bytes
)
len
)
)
)
;
const
uint64_t
asInt
=
mozilla
:
:
BigEndian
:
:
readUint64
(
bytes
)
;
return
JS
:
:
CanonicalizeNaN
(
mozilla
:
:
BitwiseCast
<
double
>
(
asInt
)
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
Number
>
(
HuffmanTableExplicitSymbolsF64
&
table
const
Number
&
number
)
{
BINJS_MOZ_TRY_DECL
(
value
readSymbol
(
number
0
)
)
;
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
List
&
)
{
return
1
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readSymbol
(
const
List
&
list
size_t
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
length
>
MAX_LIST_LENGTH
)
{
return
raiseInvalidTableData
(
list
.
identity
)
;
}
return
length
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
List
>
(
HuffmanTableExplicitSymbolsListLength
&
table
const
List
&
list
)
{
BINJS_MOZ_TRY_DECL
(
length
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
length
>
MAX_LIST_LENGTH
)
{
return
raiseInvalidTableData
(
list
.
identity
)
;
}
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
std
:
:
move
(
length
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
String
&
)
{
return
reader
.
metadata_
-
>
numStrings
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
HuffmanPreludeReader
:
:
readSymbol
(
const
String
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
return
reader
.
metadata_
-
>
getAtom
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
String
>
(
HuffmanTableIndexedSymbolsLiteralString
&
table
const
String
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
JSAtom
*
value
=
reader
.
metadata_
-
>
getAtom
(
index
)
;
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
std
:
:
move
(
value
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
MaybeString
&
)
{
return
reader
.
metadata_
-
>
numStrings
(
)
+
1
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
HuffmanPreludeReader
:
:
readSymbol
(
const
MaybeString
&
entry
size_t
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
=
=
0
)
{
return
nullptr
;
}
else
if
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
+
1
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
else
{
return
reader
.
metadata_
-
>
getAtom
(
index
-
1
)
;
}
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
MaybeString
>
(
HuffmanTableIndexedSymbolsOptionalLiteralString
&
table
const
MaybeString
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
reader
.
metadata_
-
>
numStrings
(
)
+
1
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
JSAtom
*
symbol
=
index
=
=
0
?
nullptr
:
reader
.
metadata_
-
>
getAtom
(
index
-
1
)
;
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
std
:
:
move
(
symbol
)
)
)
;
return
Ok
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
HuffmanPreludeReader
:
:
readNumberOfSymbols
(
const
StringEnum
&
entry
)
{
return
entry
.
maxNumberOfSymbols
(
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
HuffmanPreludeReader
:
:
readSymbol
(
const
StringEnum
&
entry
size_t
index
)
{
return
entry
.
variantAt
(
index
)
;
}
template
<
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
HuffmanPreludeReader
:
:
readSingleValueTable
<
StringEnum
>
(
HuffmanTableIndexedSymbolsStringEnum
&
table
const
StringEnum
&
entry
)
{
BINJS_MOZ_TRY_DECL
(
index
reader
.
readVarU32
<
Compression
:
:
Yes
>
(
)
)
;
if
(
index
>
entry
.
maxNumberOfSymbols
(
)
)
{
return
raiseInvalidTableData
(
entry
.
identity
)
;
}
BinASTVariant
symbol
=
entry
.
variantAt
(
index
)
;
MOZ_TRY
(
table
.
impl
.
initWithSingleValue
(
cx_
std
:
:
move
(
symbol
)
)
)
;
return
Ok
(
)
;
}
HuffmanTable
&
HuffmanDictionary
:
:
tableForField
(
NormalizedInterfaceAndField
index
)
{
return
fields
[
static_cast
<
size_t
>
(
index
.
identity
)
]
;
}
HuffmanTableListLength
&
HuffmanDictionary
:
:
tableForListLength
(
BinASTList
list
)
{
return
listLengths
[
static_cast
<
size_t
>
(
list
)
]
;
}
uint32_t
HuffmanLookup
:
:
leadingBits
(
const
uint8_t
bitLength
)
const
{
MOZ_ASSERT
(
bitLength
<
=
this
-
>
bitLength
)
;
return
this
-
>
bits
>
>
(
32
-
bitLength
)
;
}
}
}
