#
include
"
js
/
experimental
/
CompileScript
.
h
"
#
include
"
frontend
/
BytecodeCompilation
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
frontend
/
ScopeBindingCache
.
h
"
#
include
"
js
/
SourceText
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
JS_PUBLIC_API
FrontendContext
*
JS
:
:
NewFrontendContext
(
)
{
MOZ_ASSERT
(
JS
:
:
detail
:
:
libraryInitState
=
=
JS
:
:
detail
:
:
InitState
:
:
Running
"
must
call
JS_Init
prior
to
creating
any
FrontendContexts
"
)
;
return
js
:
:
NewFrontendContext
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
DestroyFrontendContext
(
FrontendContext
*
fc
)
{
return
js
:
:
DestroyFrontendContext
(
fc
)
;
}
JS_PUBLIC_API
bool
JS
:
:
SetSupportedImportAssertions
(
FrontendContext
*
fc
const
JS
:
:
ImportAssertionVector
&
supportedImportAssertions
)
{
return
fc
-
>
setSupportedImportAssertions
(
supportedImportAssertions
)
;
}
JS
:
:
CompilationStorage
:
:
~
CompilationStorage
(
)
{
if
(
input_
&
&
!
isBorrowed_
)
{
js_delete
(
input_
)
;
input_
=
nullptr
;
}
}
size_t
JS
:
:
CompilationStorage
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
sizeOfCompilationInput
=
input_
?
input_
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
:
0
;
return
mallocSizeOf
(
this
)
+
sizeOfCompilationInput
;
}
bool
JS
:
:
CompilationStorage
:
:
allocateInput
(
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
{
MOZ_ASSERT
(
!
input_
)
;
input_
=
fc
-
>
getAllocator
(
)
-
>
new_
<
frontend
:
:
CompilationInput
>
(
options
)
;
return
!
!
input_
;
}
void
JS
:
:
CompilationStorage
:
:
trace
(
JSTracer
*
trc
)
{
if
(
input_
)
{
input_
-
>
trace
(
trc
)
;
}
}
template
<
typename
CharT
>
static
already_AddRefed
<
JS
:
:
Stencil
>
CompileGlobalScriptToStencilImpl
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
CharT
>
&
srcBuf
JS
:
:
CompilationStorage
&
compilationStorage
)
{
ScopeKind
scopeKind
=
options
.
nonSyntacticScope
?
ScopeKind
:
:
NonSyntactic
:
ScopeKind
:
:
Global
;
JS
:
:
SourceText
<
CharT
>
data
(
std
:
:
move
(
srcBuf
)
)
;
compilationStorage
.
allocateInput
(
fc
options
)
;
if
(
!
compilationStorage
.
hasInput
(
)
)
{
return
nullptr
;
}
frontend
:
:
NoScopeBindingCache
scopeCache
;
LifoAlloc
tempLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
RefPtr
<
frontend
:
:
CompilationStencil
>
stencil_
=
frontend
:
:
CompileGlobalScriptToStencil
(
nullptr
fc
tempLifoAlloc
compilationStorage
.
getInput
(
)
&
scopeCache
data
scopeKind
)
;
return
stencil_
.
forget
(
)
;
}
template
<
typename
CharT
>
static
already_AddRefed
<
JS
:
:
Stencil
>
CompileModuleScriptToStencilImpl
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
optionsInput
JS
:
:
SourceText
<
CharT
>
&
srcBuf
JS
:
:
CompilationStorage
&
compilationStorage
)
{
JS
:
:
CompileOptions
options
(
nullptr
optionsInput
)
;
options
.
setModule
(
)
;
compilationStorage
.
allocateInput
(
fc
options
)
;
if
(
!
compilationStorage
.
hasInput
(
)
)
{
return
nullptr
;
}
NoScopeBindingCache
scopeCache
;
js
:
:
LifoAlloc
tempLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
ParseModuleToStencil
(
nullptr
fc
fc
-
>
stackLimit
(
)
tempLifoAlloc
compilationStorage
.
getInput
(
)
&
scopeCache
srcBuf
)
;
if
(
!
stencil
)
{
return
nullptr
;
}
return
stencil
.
forget
(
)
;
}
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
CompileGlobalScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
{
return
CompileGlobalScriptToStencilImpl
(
fc
options
srcBuf
compileStorage
)
;
}
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
CompileGlobalScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
{
return
CompileGlobalScriptToStencilImpl
(
fc
options
srcBuf
compileStorage
)
;
}
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
CompileModuleScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
optionsInput
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
{
return
CompileModuleScriptToStencilImpl
(
fc
optionsInput
srcBuf
compileStorage
)
;
}
already_AddRefed
<
JS
:
:
Stencil
>
JS
:
:
CompileModuleScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
optionsInput
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
{
return
CompileModuleScriptToStencilImpl
(
fc
optionsInput
srcBuf
compileStorage
)
;
}
#
ifdef
DEBUG
static
bool
isGCSafe
(
js
:
:
frontend
:
:
CompilationInput
&
input
)
{
bool
isGlobalOrModule
=
input
.
target
=
=
CompilationInput
:
:
CompilationTarget
:
:
Global
|
|
input
.
target
=
=
CompilationInput
:
:
CompilationTarget
:
:
Module
;
bool
scopeHasNoGC
=
input
.
enclosingScope
.
isStencil
(
)
|
|
input
.
enclosingScope
.
isNull
(
)
;
bool
scriptHasNoGC
=
input
.
lazyOuterScript
(
)
.
isStencil
(
)
|
|
input
.
lazyOuterScript
(
)
.
isNull
(
)
;
bool
cacheHasNoGC
=
input
.
atomCache
.
empty
(
)
;
return
isGlobalOrModule
&
&
scopeHasNoGC
&
&
scriptHasNoGC
&
&
cacheHasNoGC
;
}
#
endif
bool
JS
:
:
PrepareForInstantiate
(
JS
:
:
FrontendContext
*
fc
JS
:
:
CompilationStorage
&
compileStorage
JS
:
:
Stencil
&
stencil
JS
:
:
InstantiationStorage
&
storage
)
{
MOZ_ASSERT
(
compileStorage
.
hasInput
(
)
)
;
MOZ_ASSERT
(
isGCSafe
(
compileStorage
.
getInput
(
)
)
)
;
if
(
!
storage
.
gcOutput_
)
{
storage
.
gcOutput_
=
fc
-
>
getAllocator
(
)
-
>
new_
<
js
:
:
frontend
:
:
CompilationGCOutput
>
(
)
;
if
(
!
storage
.
gcOutput_
)
{
return
false
;
}
}
return
CompilationStencil
:
:
prepareForInstantiate
(
fc
compileStorage
.
getInput
(
)
.
atomCache
stencil
*
storage
.
gcOutput_
)
;
}
