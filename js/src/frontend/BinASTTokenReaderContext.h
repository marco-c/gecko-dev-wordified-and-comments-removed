#
ifndef
frontend_BinASTTokenReaderContext_h
#
define
frontend_BinASTTokenReaderContext_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JS_PUBLIC_API
JSAtom
;
class
JS_PUBLIC_API
JSTracer
;
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
class
ScriptSource
;
namespace
frontend
{
class
ErrorReporter
;
struct
NormalizedInterfaceAndField
{
const
BinASTInterfaceAndField
identity_
;
explicit
NormalizedInterfaceAndField
(
BinASTInterfaceAndField
identity
)
:
identity_
(
identity
=
=
BinASTInterfaceAndField
:
:
StaticMemberAssignmentTarget__Property
?
BinASTInterfaceAndField
:
:
StaticMemberExpression__Property
:
identity
)
{
}
}
;
template
<
typename
T
>
struct
Split
{
T
prefix_
;
T
suffix_
;
}
;
struct
HuffmanLookup
{
HuffmanLookup
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits_
(
bitLength
=
=
0
?
0
:
(
bits
&
(
uint32_t
(
0xFFFFFFFF
)
>
>
(
32
-
bitLength
)
)
)
)
bitLength_
(
bitLength
)
{
MOZ_ASSERT
(
bitLength_
<
=
32
)
;
MOZ_ASSERT_IF
(
bitLength_
!
=
32
bits_
>
>
bitLength_
=
=
0
)
;
}
uint32_t
leadingBits
(
const
uint8_t
bitLength
)
const
;
Split
<
HuffmanLookup
>
split
(
const
uint8_t
prefixLength
)
const
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
mozilla
:
:
detail
:
:
IntegerRange
<
size_t
>
suffixes
(
uint8_t
expectedBitLength
)
const
;
}
;
struct
HuffmanKey
{
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
}
;
class
alignas
(
8
)
BinASTSymbol
{
private
:
static
const
size_t
NullAtomIndex
=
size_t
(
-
1
)
;
uint64_t
asBits_
;
explicit
BinASTSymbol
(
uint64_t
asBits
)
:
asBits_
(
asBits
)
{
}
static
BinASTSymbol
fromRawBits
(
uint64_t
asBits
)
{
return
BinASTSymbol
(
asBits
)
;
}
public
:
static
BinASTSymbol
fromUnsignedLong
(
uint32_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromListLength
(
uint32_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromSubtableIndex
(
size_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromBool
(
bool
b
)
{
return
fromRawBits
(
b
)
;
}
static
BinASTSymbol
fromDouble
(
double
d
)
{
return
fromRawBits
(
mozilla
:
:
BitwiseCast
<
uint64_t
>
(
d
)
)
;
}
static
BinASTSymbol
fromKind
(
BinASTKind
k
)
{
return
fromRawBits
(
uint64_t
(
k
)
)
;
}
static
BinASTSymbol
fromVariant
(
BinASTVariant
v
)
{
return
fromRawBits
(
uint64_t
(
v
)
)
;
}
static
BinASTSymbol
fromAtomIndex
(
size_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
nullAtom
(
)
{
return
fromRawBits
(
NullAtomIndex
)
;
}
uint32_t
toUnsignedLong
(
)
const
{
return
uint32_t
(
asBits_
)
;
}
uint32_t
toListLength
(
)
const
{
return
uint32_t
(
asBits_
)
;
}
size_t
toSubtableIndex
(
)
const
{
return
size_t
(
asBits_
)
;
}
bool
toBool
(
)
const
{
return
bool
(
asBits_
)
;
}
double
toDouble
(
)
const
{
return
mozilla
:
:
BitwiseCast
<
double
>
(
asBits_
)
;
}
BinASTKind
toKind
(
)
const
{
return
BinASTKind
(
asBits_
)
;
}
BinASTVariant
toVariant
(
)
const
{
return
BinASTVariant
(
asBits_
)
;
}
size_t
toAtomIndex
(
)
const
{
MOZ_ASSERT
(
!
isNullAtom
(
)
)
;
return
toAtomIndexNoCheck
(
)
;
}
bool
isNullAtom
(
)
const
{
return
toAtomIndexNoCheck
(
)
=
=
NullAtomIndex
;
}
private
:
size_t
toAtomIndexNoCheck
(
)
const
{
return
size_t
(
asBits_
)
;
}
friend
class
:
:
js
:
:
ScriptSource
;
}
;
class
HuffmanEntry
{
const
HuffmanKey
key_
;
const
BinASTSymbol
value_
;
public
:
HuffmanEntry
(
HuffmanKey
key
const
BinASTSymbol
&
value
)
:
key_
(
key
)
value_
(
value
)
{
}
HuffmanEntry
(
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
:
key_
(
bits
bitLength
)
value_
(
value
)
{
}
const
HuffmanKey
&
key
(
)
const
{
return
key_
;
}
;
const
BinASTSymbol
&
value
(
)
const
{
return
value_
;
}
;
}
;
class
HuffmanLookupResult
{
uint8_t
bitLength_
;
const
BinASTSymbol
*
value_
;
HuffmanLookupResult
(
uint8_t
bitLength
const
BinASTSymbol
*
value
)
:
bitLength_
(
bitLength
)
value_
(
value
)
{
}
public
:
static
HuffmanLookupResult
found
(
uint8_t
bitLength
const
BinASTSymbol
*
value
)
{
MOZ_ASSERT
(
value
)
;
return
HuffmanLookupResult
(
bitLength
value
)
;
}
static
HuffmanLookupResult
notFound
(
)
{
return
HuffmanLookupResult
(
0
nullptr
)
;
}
bool
isFound
(
)
const
{
return
!
!
value_
;
}
;
uint8_t
bitLength
(
)
const
{
MOZ_ASSERT
(
isFound
(
)
)
;
return
bitLength_
;
}
const
BinASTSymbol
&
value
(
)
const
{
MOZ_ASSERT
(
isFound
(
)
)
;
return
*
value_
;
}
}
;
enum
class
Nullable
{
Null
NonNull
}
;
class
TemporaryStorage
;
class
SingleEntryHuffmanTable
{
public
:
explicit
SingleEntryHuffmanTable
(
const
BinASTSymbol
&
value
)
:
value_
(
value
)
{
}
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
&
other
)
=
default
;
SingleEntryHuffmanTable
(
)
=
delete
;
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
1
;
}
struct
Iterator
{
explicit
Iterator
(
const
BinASTSymbol
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
BinASTSymbol
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
&
value_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
nullptr
)
;
}
private
:
BinASTSymbol
value_
;
friend
class
HuffmanPreludeReader
;
friend
class
:
:
js
:
:
ScriptSource
;
}
;
class
TwoEntriesHuffmanTable
{
public
:
TwoEntriesHuffmanTable
(
)
=
default
;
TwoEntriesHuffmanTable
(
TwoEntriesHuffmanTable
&
&
other
)
noexcept
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
TwoEntriesHuffmanTable
(
TwoEntriesHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
struct
Iterator
{
explicit
Iterator
(
const
BinASTSymbol
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
BinASTSymbol
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
std
:
:
begin
(
values_
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
std
:
:
end
(
values_
)
)
;
}
size_t
length
(
)
const
{
return
2
;
}
private
:
BinASTSymbol
values_
[
2
]
=
{
BinASTSymbol
:
:
fromBool
(
false
)
BinASTSymbol
:
:
fromBool
(
false
)
}
;
friend
class
HuffmanPreludeReader
;
friend
class
:
:
js
:
:
ScriptSource
;
}
;
class
SingleLookupHuffmanTable
{
public
:
using
InternalIndex
=
uint8_t
;
enum
Use
{
LeafOfMultiLookupHuffmanTable
ToplevelTable
ShortKeys
}
;
static
const
uint8_t
MAX_BIT_LENGTH
=
sizeof
(
InternalIndex
)
*
8
;
explicit
SingleLookupHuffmanTable
(
Use
use
=
Use
:
:
LeafOfMultiLookupHuffmanTable
)
:
largestBitLength_
(
-
1
)
#
ifdef
DEBUG
use_
(
use
)
#
endif
{
}
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
size
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
&
values_
[
0
]
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
&
values_
[
0
]
+
values_
.
size
(
)
)
;
}
private
:
mozilla
:
:
Span
<
HuffmanEntry
>
values_
;
mozilla
:
:
Span
<
InternalIndex
>
saturated_
;
friend
class
HuffmanDictionaryForMetadata
;
uint8_t
largestBitLength_
;
#
ifdef
DEBUG
Use
use_
;
#
endif
friend
class
HuffmanPreludeReader
;
friend
class
:
:
js
:
:
ScriptSource
;
}
;
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
class
MultiLookupHuffmanTable
{
public
:
static
const
uint8_t
MAX_BIT_LENGTH
=
PrefixBitLength
+
Subtable
:
:
MAX_BIT_LENGTH
;
MultiLookupHuffmanTable
(
)
:
shortKeys_
(
SingleLookupHuffmanTable
:
:
Use
:
:
ShortKeys
)
largestBitLength_
(
-
1
)
{
}
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
size
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
&
values_
[
0
]
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
&
values_
[
0
]
+
values_
.
size
(
)
)
;
}
public
:
using
InternalIndex
=
uint8_t
;
private
:
SingleLookupHuffmanTable
shortKeys_
;
mozilla
:
:
Span
<
HuffmanEntry
>
values_
;
mozilla
:
:
Span
<
Subtable
>
suffixTables_
;
friend
class
HuffmanDictionaryForMetadata
;
uint8_t
largestBitLength_
;
friend
class
HuffmanPreludeReader
;
friend
class
:
:
js
:
:
ScriptSource
;
}
;
using
TwoLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
SingleLookupHuffmanTable
6
>
;
using
ThreeLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
TwoLookupsHuffmanTable
6
>
;
struct
TableImplementationUninitialized
{
}
;
struct
GenericHuffmanTable
{
GenericHuffmanTable
(
)
;
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
const
BinASTSymbol
&
value
)
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
TemporaryStorage
*
tempStorage
)
;
size_t
length
(
)
const
;
struct
Iterator
{
explicit
Iterator
(
typename
SingleEntryHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
SingleLookupHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
&
)
;
Iterator
(
Iterator
&
&
)
=
default
;
Iterator
(
const
Iterator
&
)
=
default
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
mozilla
:
:
Variant
<
typename
SingleEntryHuffmanTable
:
:
Iterator
typename
TwoEntriesHuffmanTable
:
:
Iterator
typename
SingleLookupHuffmanTable
:
:
Iterator
typename
TwoLookupsHuffmanTable
:
:
Iterator
typename
ThreeLookupsHuffmanTable
:
:
Iterator
>
implementation_
;
}
;
Iterator
begin
(
)
const
;
Iterator
end
(
)
const
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
bool
isMaybeInterfaceAlwaysNull
(
)
const
{
MOZ_ASSERT
(
length
(
)
=
=
1
|
|
length
(
)
=
=
2
)
;
if
(
length
(
)
=
=
2
)
{
return
false
;
}
return
begin
(
)
-
>
toKind
(
)
=
=
BinASTKind
:
:
_Null
;
}
private
:
mozilla
:
:
Variant
<
SingleEntryHuffmanTable
TwoEntriesHuffmanTable
SingleLookupHuffmanTable
TwoLookupsHuffmanTable
ThreeLookupsHuffmanTable
TableImplementationUninitialized
>
implementation_
;
friend
class
HuffmanDictionaryForMetadata
;
friend
class
:
:
js
:
:
ScriptSource
;
}
;
template
<
typename
T
>
class
TemporaryStorageItem
{
class
Chunk
{
public
:
static
const
size_t
DefaultSize
=
1024
;
Chunk
*
next_
=
nullptr
;
size_t
used_
=
0
;
size_t
size_
=
0
;
T
entries_
[
1
]
;
Chunk
(
)
=
default
;
}
;
size_t
total_
=
0
;
Chunk
*
head_
=
nullptr
;
public
:
TemporaryStorageItem
(
)
=
default
;
~
TemporaryStorageItem
(
)
{
Chunk
*
chunk
=
head_
;
while
(
chunk
)
{
Chunk
*
next
=
chunk
-
>
next_
;
js_free
(
chunk
)
;
chunk
=
next
;
}
}
T
*
alloc
(
JSContext
*
cx
size_t
count
)
;
size_t
total
(
)
const
{
return
total_
;
}
}
;
class
TemporaryStorage
{
using
InternalIndex
=
SingleLookupHuffmanTable
:
:
InternalIndex
;
static_assert
(
sizeof
(
SingleLookupHuffmanTable
:
:
InternalIndex
)
=
=
sizeof
(
TwoLookupsHuffmanTable
:
:
InternalIndex
)
"
InternalIndex
should
be
same
between
tables
"
)
;
TemporaryStorageItem
<
HuffmanEntry
>
huffmanEntries_
;
TemporaryStorageItem
<
InternalIndex
>
internalIndices_
;
TemporaryStorageItem
<
SingleLookupHuffmanTable
>
singleTables_
;
TemporaryStorageItem
<
TwoLookupsHuffmanTable
>
twoTables_
;
public
:
TemporaryStorage
(
)
=
default
;
template
<
typename
T
>
JS
:
:
Result
<
mozilla
:
:
Span
<
T
>
>
alloc
(
JSContext
*
cx
size_t
count
)
;
size_t
numHuffmanEntries
(
)
const
{
return
huffmanEntries_
.
total
(
)
;
}
size_t
numInternalIndices
(
)
const
{
return
internalIndices_
.
total
(
)
;
}
size_t
numSingleTables
(
)
const
{
return
singleTables_
.
total
(
)
;
}
size_t
numTwoTables
(
)
const
{
return
twoTables_
.
total
(
)
;
}
}
;
class
TableIdentity
{
size_t
index_
;
static
const
size_t
ListIdentityBase
=
BINAST_INTERFACE_AND_FIELD_LIMIT
;
public
:
static
const
size_t
Limit
=
ListIdentityBase
+
BINAST_NUMBER_OF_LIST_TYPES
;
explicit
TableIdentity
(
NormalizedInterfaceAndField
index
)
:
index_
(
static_cast
<
size_t
>
(
index
.
identity_
)
)
{
}
explicit
TableIdentity
(
BinASTList
list
)
:
index_
(
static_cast
<
size_t
>
(
list
)
+
ListIdentityBase
)
{
}
size_t
toIndex
(
)
const
{
return
index_
;
}
}
;
class
HuffmanDictionary
;
class
alignas
(
uintptr_t
)
HuffmanDictionaryForMetadata
{
static
const
uint16_t
UnreachableIndex
=
uint16_t
(
-
1
)
;
using
InternalIndex
=
uint8_t
;
HuffmanDictionaryForMetadata
(
size_t
numTables
size_t
numHuffmanEntries
size_t
numInternalIndices
size_t
numSingleTables
size_t
numTwoTables
)
:
numTables_
(
numTables
)
numHuffmanEntries_
(
numHuffmanEntries
)
numInternalIndices_
(
numInternalIndices
)
numSingleTables_
(
numSingleTables
)
numTwoTables_
(
numTwoTables
)
{
}
mozilla
:
:
RangedPtr
<
GenericHuffmanTable
>
tablesBase
(
)
{
auto
p
=
reinterpret_cast
<
GenericHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
)
;
return
mozilla
:
:
RangedPtr
<
GenericHuffmanTable
>
(
p
p
p
+
numTables_
)
;
}
const
mozilla
:
:
RangedPtr
<
GenericHuffmanTable
>
tablesBase
(
)
const
{
auto
p
=
reinterpret_cast
<
GenericHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
)
;
return
mozilla
:
:
RangedPtr
<
GenericHuffmanTable
>
(
p
p
p
+
numTables_
)
;
}
mozilla
:
:
RangedPtr
<
HuffmanEntry
>
huffmanEntriesBase
(
)
{
auto
p
=
reinterpret_cast
<
HuffmanEntry
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
)
;
return
mozilla
:
:
RangedPtr
<
HuffmanEntry
>
(
p
p
p
+
numHuffmanEntries_
)
;
}
const
mozilla
:
:
RangedPtr
<
HuffmanEntry
>
huffmanEntriesBase
(
)
const
{
auto
p
=
reinterpret_cast
<
HuffmanEntry
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
)
;
return
mozilla
:
:
RangedPtr
<
HuffmanEntry
>
(
p
p
p
+
numHuffmanEntries_
)
;
}
mozilla
:
:
RangedPtr
<
InternalIndex
>
internalIndicesBase
(
)
{
auto
p
=
reinterpret_cast
<
InternalIndex
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
)
;
return
mozilla
:
:
RangedPtr
<
InternalIndex
>
(
p
p
p
+
numInternalIndices_
)
;
}
const
mozilla
:
:
RangedPtr
<
InternalIndex
>
internalIndicesBase
(
)
const
{
auto
p
=
reinterpret_cast
<
InternalIndex
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
)
;
return
mozilla
:
:
RangedPtr
<
InternalIndex
>
(
p
p
p
+
numInternalIndices_
)
;
}
mozilla
:
:
RangedPtr
<
SingleLookupHuffmanTable
>
singleTablesBase
(
)
{
auto
p
=
reinterpret_cast
<
SingleLookupHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
+
sizeof
(
InternalIndex
)
*
numInternalIndices_
)
;
return
mozilla
:
:
RangedPtr
<
SingleLookupHuffmanTable
>
(
p
p
p
+
numSingleTables_
)
;
}
const
mozilla
:
:
RangedPtr
<
SingleLookupHuffmanTable
>
singleTablesBase
(
)
const
{
auto
p
=
reinterpret_cast
<
SingleLookupHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
+
sizeof
(
InternalIndex
)
*
numInternalIndices_
)
;
return
mozilla
:
:
RangedPtr
<
SingleLookupHuffmanTable
>
(
p
p
p
+
numSingleTables_
)
;
}
mozilla
:
:
RangedPtr
<
TwoLookupsHuffmanTable
>
twoTablesBase
(
)
{
auto
p
=
reinterpret_cast
<
TwoLookupsHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
+
sizeof
(
InternalIndex
)
*
numInternalIndices_
+
sizeof
(
SingleLookupHuffmanTable
)
*
numSingleTables_
)
;
return
mozilla
:
:
RangedPtr
<
TwoLookupsHuffmanTable
>
(
p
p
p
+
numTwoTables_
)
;
}
const
mozilla
:
:
RangedPtr
<
TwoLookupsHuffmanTable
>
twoTablesBase
(
)
const
{
auto
p
=
reinterpret_cast
<
TwoLookupsHuffmanTable
*
>
(
reinterpret_cast
<
uintptr_t
>
(
this
+
1
)
+
sizeof
(
GenericHuffmanTable
)
*
numTables_
+
sizeof
(
HuffmanEntry
)
*
numHuffmanEntries_
+
sizeof
(
InternalIndex
)
*
numInternalIndices_
+
sizeof
(
SingleLookupHuffmanTable
)
*
numSingleTables_
)
;
return
mozilla
:
:
RangedPtr
<
TwoLookupsHuffmanTable
>
(
p
p
p
+
numTwoTables_
)
;
}
public
:
HuffmanDictionaryForMetadata
(
)
=
delete
;
~
HuffmanDictionaryForMetadata
(
)
;
static
HuffmanDictionaryForMetadata
*
createFrom
(
HuffmanDictionary
*
dictionary
TemporaryStorage
*
tempStorage
)
;
static
HuffmanDictionaryForMetadata
*
create
(
size_t
numTables
size_t
numHuffmanEntries
size_t
numInternalIndices
size_t
numSingleTables
size_t
numTwoTables
)
;
void
clearFromIncompleteInitialization
(
size_t
numInitializedTables
size_t
numInitializedSingleTables
size_t
numInitializedTwoTables
)
;
friend
class
:
:
js
:
:
ScriptSource
;
private
:
static
size_t
totalSize
(
size_t
numTables
size_t
numHuffmanEntries
size_t
numInternalIndices
size_t
numSingleTables
size_t
numTwoTables
)
;
void
moveFrom
(
HuffmanDictionary
*
dictionary
TemporaryStorage
*
tempStorage
)
;
public
:
bool
isUnreachable
(
TableIdentity
i
)
const
{
return
tableIndices_
[
i
.
toIndex
(
)
]
=
=
UnreachableIndex
;
}
bool
isReady
(
TableIdentity
i
)
const
{
return
tableIndices_
[
i
.
toIndex
(
)
]
!
=
UnreachableIndex
;
}
const
GenericHuffmanTable
&
getTable
(
TableIdentity
i
)
const
{
MOZ_ASSERT
(
isReady
(
i
)
)
;
return
table
(
i
)
;
}
private
:
size_t
numTables_
=
0
;
size_t
numHuffmanEntries_
=
0
;
size_t
numInternalIndices_
=
0
;
size_t
numSingleTables_
=
0
;
size_t
numTwoTables_
=
0
;
uint16_t
tableIndices_
[
TableIdentity
:
:
Limit
]
=
{
UnreachableIndex
}
;
GenericHuffmanTable
&
table
(
TableIdentity
i
)
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
const
GenericHuffmanTable
&
table
(
TableIdentity
i
)
const
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
{
return
tablesBase
(
)
[
i
]
;
}
const
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
const
{
return
tablesBase
(
)
[
i
]
;
}
public
:
size_t
numTables
(
)
const
{
return
numTables_
;
}
size_t
numHuffmanEntries
(
)
const
{
return
numHuffmanEntries_
;
}
size_t
numInternalIndices
(
)
const
{
return
numInternalIndices_
;
}
size_t
numSingleTables
(
)
const
{
return
numSingleTables_
;
}
size_t
numTwoTables
(
)
const
{
return
numTwoTables_
;
}
size_t
huffmanEntryIndexOf
(
HuffmanEntry
*
entry
)
{
MOZ_ASSERT
(
huffmanEntriesBase
(
)
.
get
(
)
<
=
entry
&
&
entry
<
huffmanEntriesBase
(
)
.
get
(
)
+
numHuffmanEntries
(
)
)
;
return
entry
-
huffmanEntriesBase
(
)
.
get
(
)
;
}
size_t
internalIndexIndexOf
(
InternalIndex
*
index
)
{
MOZ_ASSERT
(
internalIndicesBase
(
)
.
get
(
)
<
=
index
&
&
index
<
internalIndicesBase
(
)
.
get
(
)
+
numInternalIndices
(
)
)
;
return
index
-
internalIndicesBase
(
)
.
get
(
)
;
}
size_t
singleTableIndexOf
(
SingleLookupHuffmanTable
*
table
)
{
MOZ_ASSERT
(
singleTablesBase
(
)
.
get
(
)
<
=
table
&
&
table
<
singleTablesBase
(
)
.
get
(
)
+
numSingleTables
(
)
)
;
return
table
-
singleTablesBase
(
)
.
get
(
)
;
}
size_t
twoTableIndexOf
(
TwoLookupsHuffmanTable
*
table
)
{
MOZ_ASSERT
(
twoTablesBase
(
)
.
get
(
)
<
=
table
&
&
table
<
twoTablesBase
(
)
.
get
(
)
+
numTwoTables
(
)
)
;
return
table
-
twoTablesBase
(
)
.
get
(
)
;
}
}
;
class
MOZ_STACK_CLASS
AutoClearHuffmanDictionaryForMetadata
{
frontend
:
:
HuffmanDictionaryForMetadata
*
dictionary_
;
size_t
numInitializedTables_
=
0
;
size_t
numInitializedSingleTables_
=
0
;
size_t
numInitializedTwoTables_
=
0
;
public
:
AutoClearHuffmanDictionaryForMetadata
(
)
:
dictionary_
(
nullptr
)
{
}
~
AutoClearHuffmanDictionaryForMetadata
(
)
{
if
(
dictionary_
)
{
dictionary_
-
>
clearFromIncompleteInitialization
(
numInitializedTables_
numInitializedSingleTables_
numInitializedTwoTables_
)
;
}
}
void
set
(
frontend
:
:
HuffmanDictionaryForMetadata
*
dictionary
)
{
dictionary_
=
dictionary
;
}
void
reset
(
)
{
dictionary_
=
nullptr
;
}
void
addInitializedTable
(
)
{
numInitializedTables_
+
+
;
}
void
addInitializedSingleTable
(
)
{
numInitializedSingleTables_
+
+
;
}
void
addInitializedTwoTable
(
)
{
numInitializedTwoTables_
+
+
;
}
}
;
class
HuffmanDictionary
{
enum
class
TableStatus
:
uint8_t
{
Unreachable
Initializing
Ready
}
;
public
:
HuffmanDictionary
(
)
=
default
;
~
HuffmanDictionary
(
)
;
bool
isUnreachable
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Unreachable
;
}
bool
isInitializing
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Initializing
;
}
bool
isReady
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Ready
;
}
void
setInitializing
(
TableIdentity
i
)
{
status_
[
i
.
toIndex
(
)
]
=
TableStatus
:
:
Initializing
;
}
private
:
void
setReady
(
TableIdentity
i
)
{
status_
[
i
.
toIndex
(
)
]
=
TableStatus
:
:
Ready
;
}
public
:
GenericHuffmanTable
&
createTable
(
TableIdentity
i
)
{
MOZ_ASSERT
(
isUnreachable
(
i
)
|
|
isInitializing
(
i
)
)
;
setReady
(
i
)
;
tableIndices_
[
i
.
toIndex
(
)
]
=
nextIndex_
+
+
;
auto
&
t
=
table
(
i
)
;
new
(
mozilla
:
:
KnownNotNull
&
t
)
GenericHuffmanTable
(
)
;
return
t
;
}
const
GenericHuffmanTable
&
getTable
(
TableIdentity
i
)
const
{
MOZ_ASSERT
(
isReady
(
i
)
)
;
return
table
(
i
)
;
}
size_t
numTables
(
)
const
{
return
nextIndex_
;
}
private
:
TableStatus
status_
[
TableIdentity
:
:
Limit
]
=
{
TableStatus
:
:
Unreachable
}
;
uint16_t
tableIndices_
[
TableIdentity
:
:
Limit
]
=
{
0
}
;
uint16_t
nextIndex_
=
0
;
alignas
(
GenericHuffmanTable
)
char
tables_
[
sizeof
(
GenericHuffmanTable
)
*
TableIdentity
:
:
Limit
]
;
GenericHuffmanTable
&
table
(
TableIdentity
i
)
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
const
GenericHuffmanTable
&
table
(
TableIdentity
i
)
const
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
{
return
(
reinterpret_cast
<
GenericHuffmanTable
*
>
(
tables_
)
)
[
i
]
;
}
const
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
const
{
return
(
reinterpret_cast
<
const
GenericHuffmanTable
*
>
(
tables_
)
)
[
i
]
;
}
friend
class
HuffmanDictionaryForMetadata
;
}
;
class
MOZ_STACK_CLASS
BinASTTokenReaderContext
:
public
BinASTTokenReaderBase
{
using
Base
=
BinASTTokenReaderBase
;
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
RootContext
=
BinASTTokenReaderBase
:
:
RootContext
;
using
ListContext
=
BinASTTokenReaderBase
:
:
ListContext
;
using
FieldContext
=
BinASTTokenReaderBase
:
:
FieldContext
;
using
FieldOrRootContext
=
BinASTTokenReaderBase
:
:
FieldOrRootContext
;
using
FieldOrListContext
=
BinASTTokenReaderBase
:
:
FieldOrListContext
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderContext
(
)
;
enum
class
Compression
{
No
Yes
}
;
enum
class
EndOfFilePolicy
{
RaiseError
BestEffort
}
;
protected
:
struct
BitBuffer
{
BitBuffer
(
)
;
template
<
Compression
Compression
>
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanLookup
>
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
;
template
<
Compression
Compression
>
void
advanceBitBuffer
(
const
uint8_t
bitLength
)
;
size_t
numUnusedBytes
(
)
const
{
return
bitLength_
/
8
;
}
void
flush
(
)
{
bitLength_
=
0
;
}
private
:
uint64_t
bits_
;
uint8_t
bitLength_
;
}
bitBuffer
;
bool
isEOF
(
)
const
;
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
template
<
Compression
compression
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
&
len
)
;
enum
class
FillResult
{
EndOfStream
Filled
}
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readTreeFooter
(
)
;
private
:
void
flushBitStream
(
)
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readStringPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHuffmanPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
registerLazyScript
(
BaseScript
*
lazy
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
)
{
MOZ_ASSERT
(
tag
!
=
BinASTKind
:
:
_Uninitialized
)
;
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
RootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
ListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
RootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
ListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
RootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnpackedLong
(
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
readTagFromTable
(
const
BinASTInterfaceAndField
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
readFieldFromTable
(
const
BinASTInterfaceAndField
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidValue
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseNotInPrelude
(
)
;
private
:
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readVarU32
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
handleEndOfStream
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
;
private
:
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadataContext
*
metadata_
;
const
uint8_t
*
posBeforeTree_
;
Rooted
<
GCVector
<
BaseScript
*
>
>
lazyScripts_
;
public
:
BinASTTokenReaderContext
(
const
BinASTTokenReaderContext
&
)
=
delete
;
BinASTTokenReaderContext
(
BinASTTokenReaderContext
&
&
)
=
delete
;
BinASTTokenReaderContext
&
operator
=
(
BinASTTokenReaderContext
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
protected
:
friend
class
HuffmanPreludeReader
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderContext
&
reader
)
#
ifdef
DEBUG
:
initialized_
(
false
)
reader_
(
reader
)
#
endif
{
}
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
friend
BinASTTokenReaderContext
;
public
:
inline
void
init
(
)
{
#
ifdef
DEBUG
initialized_
=
true
;
#
endif
}
inline
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
{
#
ifdef
DEBUG
initialized_
=
false
;
#
endif
return
Ok
(
)
;
}
protected
:
#
ifdef
DEBUG
bool
initialized_
;
BinASTTokenReaderContext
&
reader_
;
#
endif
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
}
;
}
}
#
endif
