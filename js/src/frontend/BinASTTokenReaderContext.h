#
ifndef
frontend_BinASTTokenReaderContext_h
#
define
frontend_BinASTTokenReaderContext_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
ds
/
FixedLengthVector
.
h
"
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JS_PUBLIC_API
JSAtom
;
class
JS_PUBLIC_API
JSTracer
;
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
class
ScriptSource
;
namespace
frontend
{
class
ErrorReporter
;
struct
NormalizedInterfaceAndField
{
const
BinASTInterfaceAndField
identity_
;
explicit
NormalizedInterfaceAndField
(
BinASTInterfaceAndField
identity
)
:
identity_
(
identity
=
=
BinASTInterfaceAndField
:
:
StaticMemberAssignmentTarget__Property
?
BinASTInterfaceAndField
:
:
StaticMemberExpression__Property
:
identity
)
{
}
}
;
template
<
typename
T
>
struct
Split
{
T
prefix_
;
T
suffix_
;
}
;
struct
HuffmanLookup
{
HuffmanLookup
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits_
(
bitLength
=
=
0
?
0
:
(
bits
&
(
uint32_t
(
0xFFFFFFFF
)
>
>
(
32
-
bitLength
)
)
)
)
bitLength_
(
bitLength
)
{
MOZ_ASSERT
(
bitLength_
<
=
32
)
;
MOZ_ASSERT_IF
(
bitLength_
!
=
32
bits_
>
>
bitLength_
=
=
0
)
;
}
uint32_t
leadingBits
(
const
uint8_t
bitLength
)
const
;
Split
<
HuffmanLookup
>
split
(
const
uint8_t
prefixLength
)
const
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
mozilla
:
:
detail
:
:
IntegerRange
<
size_t
>
suffixes
(
uint8_t
expectedBitLength
)
const
;
}
;
struct
HuffmanKey
{
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
}
;
class
alignas
(
8
)
BinASTSymbol
{
private
:
static
const
size_t
NullAtomIndex
=
size_t
(
-
1
)
;
uint64_t
asBits_
;
explicit
BinASTSymbol
(
uint64_t
asBits
)
:
asBits_
(
asBits
)
{
}
static
BinASTSymbol
fromRawBits
(
uint64_t
asBits
)
{
return
BinASTSymbol
(
asBits
)
;
}
public
:
static
BinASTSymbol
fromUnsignedLong
(
uint32_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromListLength
(
uint32_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromSubtableIndex
(
size_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
fromBool
(
bool
b
)
{
return
fromRawBits
(
b
)
;
}
static
BinASTSymbol
fromDouble
(
double
d
)
{
return
fromRawBits
(
mozilla
:
:
BitwiseCast
<
uint64_t
>
(
d
)
)
;
}
static
BinASTSymbol
fromKind
(
BinASTKind
k
)
{
return
fromRawBits
(
uint64_t
(
k
)
)
;
}
static
BinASTSymbol
fromVariant
(
BinASTVariant
v
)
{
return
fromRawBits
(
uint64_t
(
v
)
)
;
}
static
BinASTSymbol
fromAtomIndex
(
size_t
i
)
{
return
fromRawBits
(
i
)
;
}
static
BinASTSymbol
nullAtom
(
)
{
return
fromRawBits
(
NullAtomIndex
)
;
}
uint32_t
toUnsignedLong
(
)
const
{
return
uint32_t
(
asBits_
)
;
}
uint32_t
toListLength
(
)
const
{
return
uint32_t
(
asBits_
)
;
}
size_t
toSubtableIndex
(
)
const
{
return
size_t
(
asBits_
)
;
}
bool
toBool
(
)
const
{
return
bool
(
asBits_
)
;
}
double
toDouble
(
)
const
{
return
mozilla
:
:
BitwiseCast
<
double
>
(
asBits_
)
;
}
BinASTKind
toKind
(
)
const
{
return
BinASTKind
(
asBits_
)
;
}
BinASTVariant
toVariant
(
)
const
{
return
BinASTVariant
(
asBits_
)
;
}
size_t
toAtomIndex
(
)
const
{
MOZ_ASSERT
(
!
isNullAtom
(
)
)
;
return
toAtomIndexNoCheck
(
)
;
}
bool
isNullAtom
(
)
const
{
return
toAtomIndexNoCheck
(
)
=
=
NullAtomIndex
;
}
private
:
size_t
toAtomIndexNoCheck
(
)
const
{
return
size_t
(
asBits_
)
;
}
}
;
class
HuffmanEntry
{
const
HuffmanKey
key_
;
const
BinASTSymbol
value_
;
public
:
HuffmanEntry
(
HuffmanKey
key
const
BinASTSymbol
&
value
)
:
key_
(
key
)
value_
(
value
)
{
}
HuffmanEntry
(
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
:
key_
(
bits
bitLength
)
value_
(
value
)
{
}
const
HuffmanKey
&
key
(
)
const
{
return
key_
;
}
;
const
BinASTSymbol
&
value
(
)
const
{
return
value_
;
}
;
}
;
class
HuffmanLookupResult
{
uint8_t
bitLength_
;
const
BinASTSymbol
*
value_
;
HuffmanLookupResult
(
uint8_t
bitLength
const
BinASTSymbol
*
value
)
:
bitLength_
(
bitLength
)
value_
(
value
)
{
}
public
:
static
HuffmanLookupResult
found
(
uint8_t
bitLength
const
BinASTSymbol
*
value
)
{
MOZ_ASSERT
(
value
)
;
return
HuffmanLookupResult
(
bitLength
value
)
;
}
static
HuffmanLookupResult
notFound
(
)
{
return
HuffmanLookupResult
(
0
nullptr
)
;
}
bool
isFound
(
)
const
{
return
!
!
value_
;
}
;
uint8_t
bitLength
(
)
const
{
MOZ_ASSERT
(
isFound
(
)
)
;
return
bitLength_
;
}
const
BinASTSymbol
&
value
(
)
const
{
MOZ_ASSERT
(
isFound
(
)
)
;
return
*
value_
;
}
}
;
enum
class
Nullable
{
Null
NonNull
}
;
class
SingleEntryHuffmanTable
{
public
:
explicit
SingleEntryHuffmanTable
(
const
BinASTSymbol
&
value
)
:
value_
(
value
)
{
}
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
&
other
)
=
default
;
SingleEntryHuffmanTable
(
)
=
delete
;
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
1
;
}
struct
Iterator
{
explicit
Iterator
(
const
BinASTSymbol
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
BinASTSymbol
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
&
value_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
nullptr
)
;
}
private
:
BinASTSymbol
value_
;
friend
class
HuffmanPreludeReader
;
}
;
class
TwoEntriesHuffmanTable
{
public
:
TwoEntriesHuffmanTable
(
)
{
}
TwoEntriesHuffmanTable
(
TwoEntriesHuffmanTable
&
&
other
)
noexcept
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
TwoEntriesHuffmanTable
(
TwoEntriesHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
struct
Iterator
{
explicit
Iterator
(
const
BinASTSymbol
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
BinASTSymbol
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
std
:
:
begin
(
values_
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
std
:
:
end
(
values_
)
)
;
}
size_t
length
(
)
const
{
return
2
;
}
private
:
BinASTSymbol
values_
[
2
]
=
{
BinASTSymbol
:
:
fromBool
(
false
)
BinASTSymbol
:
:
fromBool
(
false
)
}
;
friend
class
HuffmanPreludeReader
;
}
;
class
SingleLookupHuffmanTable
{
public
:
using
InternalIndex
=
uint8_t
;
enum
Use
{
LeafOfMultiLookupHuffmanTable
ToplevelTable
ShortKeys
}
;
static
const
uint8_t
MAX_BIT_LENGTH
=
sizeof
(
InternalIndex
)
*
8
;
explicit
SingleLookupHuffmanTable
(
Use
use
=
Use
:
:
LeafOfMultiLookupHuffmanTable
)
:
largestBitLength_
(
-
1
)
#
ifdef
DEBUG
use_
(
use
)
#
endif
{
}
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
length
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values_
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values_
.
end
(
)
)
;
}
private
:
FixedLengthVector
<
HuffmanEntry
>
values_
;
FixedLengthVector
<
InternalIndex
>
saturated_
;
uint8_t
largestBitLength_
;
#
ifdef
DEBUG
Use
use_
;
#
endif
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
Subtable
uint8_t
PrefixBitLength
>
class
MultiLookupHuffmanTable
{
public
:
static
const
uint8_t
MAX_BIT_LENGTH
=
PrefixBitLength
+
Subtable
:
:
MAX_BIT_LENGTH
;
MultiLookupHuffmanTable
(
)
:
shortKeys_
(
SingleLookupHuffmanTable
:
:
Use
:
:
ShortKeys
)
largestBitLength_
(
-
1
)
{
}
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
)
=
delete
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
length
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
*
position
)
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values_
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values_
.
end
(
)
)
;
}
public
:
using
InternalIndex
=
uint8_t
;
private
:
SingleLookupHuffmanTable
shortKeys_
;
FixedLengthVector
<
HuffmanEntry
>
values_
;
FixedLengthVector
<
Subtable
>
suffixTables_
;
uint8_t
largestBitLength_
;
friend
class
HuffmanPreludeReader
;
}
;
using
TwoLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
SingleLookupHuffmanTable
6
>
;
using
ThreeLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
TwoLookupsHuffmanTable
6
>
;
struct
TableImplementationUninitialized
{
}
;
struct
GenericHuffmanTable
{
GenericHuffmanTable
(
)
;
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
const
BinASTSymbol
&
value
)
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
size_t
index
uint32_t
bits
uint8_t
bitLength
const
BinASTSymbol
&
value
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
JSContext
*
cx
)
;
size_t
length
(
)
const
;
struct
Iterator
{
explicit
Iterator
(
typename
SingleEntryHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
TwoEntriesHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
SingleLookupHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
TwoLookupsHuffmanTable
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
ThreeLookupsHuffmanTable
:
:
Iterator
&
&
)
;
Iterator
(
Iterator
&
&
)
=
default
;
Iterator
(
const
Iterator
&
)
=
default
;
void
operator
+
+
(
)
;
const
BinASTSymbol
*
operator
*
(
)
const
;
const
BinASTSymbol
*
operator
-
>
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
mozilla
:
:
Variant
<
typename
SingleEntryHuffmanTable
:
:
Iterator
typename
TwoEntriesHuffmanTable
:
:
Iterator
typename
SingleLookupHuffmanTable
:
:
Iterator
typename
TwoLookupsHuffmanTable
:
:
Iterator
typename
ThreeLookupsHuffmanTable
:
:
Iterator
>
implementation_
;
}
;
Iterator
begin
(
)
const
;
Iterator
end
(
)
const
;
HuffmanLookupResult
lookup
(
HuffmanLookup
key
)
const
;
bool
isMaybeInterfaceAlwaysNull
(
)
const
{
MOZ_ASSERT
(
length
(
)
=
=
1
|
|
length
(
)
=
=
2
)
;
if
(
length
(
)
=
=
2
)
{
return
false
;
}
return
begin
(
)
-
>
toKind
(
)
=
=
BinASTKind
:
:
_Null
;
}
private
:
mozilla
:
:
Variant
<
SingleEntryHuffmanTable
TwoEntriesHuffmanTable
SingleLookupHuffmanTable
TwoLookupsHuffmanTable
ThreeLookupsHuffmanTable
TableImplementationUninitialized
>
implementation_
;
}
;
class
HuffmanDictionary
{
enum
class
TableStatus
:
uint8_t
{
Unreachable
Initializing
Ready
}
;
public
:
HuffmanDictionary
(
)
{
}
~
HuffmanDictionary
(
)
;
class
TableIdentity
{
size_t
index_
;
static
const
size_t
ListIdentityBase
=
BINAST_INTERFACE_AND_FIELD_LIMIT
;
public
:
static
const
size_t
Limit
=
ListIdentityBase
+
BINAST_NUMBER_OF_LIST_TYPES
;
explicit
TableIdentity
(
NormalizedInterfaceAndField
index
)
:
index_
(
static_cast
<
size_t
>
(
index
.
identity_
)
)
{
}
explicit
TableIdentity
(
BinASTList
list
)
:
index_
(
static_cast
<
size_t
>
(
list
)
+
ListIdentityBase
)
{
}
size_t
toIndex
(
)
const
{
return
index_
;
}
}
;
bool
isUnreachable
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Unreachable
;
}
bool
isInitializing
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Initializing
;
}
bool
isReady
(
TableIdentity
i
)
const
{
return
status_
[
i
.
toIndex
(
)
]
=
=
TableStatus
:
:
Ready
;
}
void
setInitializing
(
TableIdentity
i
)
{
status_
[
i
.
toIndex
(
)
]
=
TableStatus
:
:
Initializing
;
}
private
:
void
setReady
(
TableIdentity
i
)
{
status_
[
i
.
toIndex
(
)
]
=
TableStatus
:
:
Ready
;
}
public
:
GenericHuffmanTable
&
createTable
(
TableIdentity
i
)
{
MOZ_ASSERT
(
isUnreachable
(
i
)
|
|
isInitializing
(
i
)
)
;
setReady
(
i
)
;
tableIndices_
[
i
.
toIndex
(
)
]
=
nextIndex_
+
+
;
auto
&
t
=
table
(
i
)
;
new
(
mozilla
:
:
KnownNotNull
&
t
)
GenericHuffmanTable
(
)
;
return
t
;
}
const
GenericHuffmanTable
&
getTable
(
TableIdentity
i
)
const
{
MOZ_ASSERT
(
isReady
(
i
)
)
;
return
table
(
i
)
;
}
private
:
TableStatus
status_
[
TableIdentity
:
:
Limit
]
=
{
TableStatus
:
:
Unreachable
}
;
uint16_t
tableIndices_
[
TableIdentity
:
:
Limit
]
=
{
0
}
;
uint16_t
nextIndex_
=
0
;
alignas
(
GenericHuffmanTable
)
char
tables_
[
sizeof
(
GenericHuffmanTable
)
*
TableIdentity
:
:
Limit
]
;
GenericHuffmanTable
&
table
(
TableIdentity
i
)
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
const
GenericHuffmanTable
&
table
(
TableIdentity
i
)
const
{
return
tableAtIndex
(
tableIndices_
[
i
.
toIndex
(
)
]
)
;
}
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
{
return
(
reinterpret_cast
<
GenericHuffmanTable
*
>
(
tables_
)
)
[
i
]
;
}
const
GenericHuffmanTable
&
tableAtIndex
(
size_t
i
)
const
{
return
(
reinterpret_cast
<
const
GenericHuffmanTable
*
>
(
tables_
)
)
[
i
]
;
}
}
;
class
MOZ_STACK_CLASS
BinASTTokenReaderContext
:
public
BinASTTokenReaderBase
{
using
Base
=
BinASTTokenReaderBase
;
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
RootContext
=
BinASTTokenReaderBase
:
:
RootContext
;
using
ListContext
=
BinASTTokenReaderBase
:
:
ListContext
;
using
FieldContext
=
BinASTTokenReaderBase
:
:
FieldContext
;
using
FieldOrRootContext
=
BinASTTokenReaderBase
:
:
FieldOrRootContext
;
using
FieldOrListContext
=
BinASTTokenReaderBase
:
:
FieldOrListContext
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderContext
(
)
;
enum
class
Compression
{
No
Yes
}
;
enum
class
EndOfFilePolicy
{
RaiseError
BestEffort
}
;
protected
:
struct
BitBuffer
{
BitBuffer
(
)
;
template
<
Compression
Compression
>
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanLookup
>
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
;
template
<
Compression
Compression
>
void
advanceBitBuffer
(
const
uint8_t
bitLength
)
;
private
:
uint64_t
bits_
;
uint8_t
bitLength_
;
}
bitBuffer
;
bool
isEOF
(
)
const
;
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
template
<
Compression
compression
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
&
len
)
;
enum
class
FillResult
{
EndOfStream
Filled
}
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readStringPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHuffmanPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
)
{
MOZ_ASSERT
(
tag
!
=
BinASTKind
:
:
_Uninitialized
)
;
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
RootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
ListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
RootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
ListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
RootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnpackedLong
(
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
readTagFromTable
(
const
BinASTInterfaceAndField
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTSymbol
>
readFieldFromTable
(
const
BinASTInterfaceAndField
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidValue
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseNotInPrelude
(
)
;
private
:
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readVarU32
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
handleEndOfStream
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
;
private
:
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadata
*
metadata_
;
class
HuffmanDictionary
dictionary_
;
const
uint8_t
*
posBeforeTree_
;
public
:
BinASTTokenReaderContext
(
const
BinASTTokenReaderContext
&
)
=
delete
;
BinASTTokenReaderContext
(
BinASTTokenReaderContext
&
&
)
=
delete
;
BinASTTokenReaderContext
&
operator
=
(
BinASTTokenReaderContext
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
protected
:
friend
class
HuffmanPreludeReader
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderContext
&
reader
)
#
ifdef
DEBUG
:
initialized_
(
false
)
reader_
(
reader
)
#
endif
{
}
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
friend
BinASTTokenReaderContext
;
public
:
inline
void
init
(
)
{
#
ifdef
DEBUG
initialized_
=
true
;
#
endif
}
inline
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
{
#
ifdef
DEBUG
initialized_
=
false
;
#
endif
return
Ok
(
)
;
}
protected
:
#
ifdef
DEBUG
bool
initialized_
;
BinASTTokenReaderContext
&
reader_
;
#
endif
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
}
;
}
}
#
endif
