#
ifndef
frontend_BinASTTokenReaderContext_h
#
define
frontend_BinASTTokenReaderContext_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
brotli
/
decode
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JSAtom
;
class
JSTracer
;
struct
JSContext
;
namespace
js
{
class
ScriptSource
;
namespace
frontend
{
class
ErrorReporter
;
struct
NormalizedInterfaceAndField
{
const
BinASTInterfaceAndField
identity
;
explicit
NormalizedInterfaceAndField
(
BinASTInterfaceAndField
identity
)
:
identity
(
identity
=
=
BinASTInterfaceAndField
:
:
StaticMemberAssignmentTarget__Property
?
BinASTInterfaceAndField
:
:
StaticMemberExpression__Property
:
identity
)
{
}
}
;
struct
HuffmanLookup
{
HuffmanLookup
(
uint32_t
bits
uint8_t
bitLength
)
:
bits
(
bits
)
bitLength
(
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
32
)
;
MOZ_ASSERT
(
bits
>
>
bitLength
=
=
0
)
;
}
uint32_t
leadingBits
(
const
uint8_t
bitLength
)
const
;
uint32_t
bits
;
uint8_t
bitLength
;
}
;
struct
HuffmanKey
{
HuffmanKey
(
uint32_t
bits
uint8_t
bitLength
)
:
bits
(
bits
)
bitLength
(
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
32
)
;
MOZ_ASSERT
(
bits
>
>
bitLength
=
=
0
)
;
}
uint32_t
bits
;
uint8_t
bitLength
;
}
;
template
<
typename
T
>
struct
HuffmanEntry
{
HuffmanEntry
(
HuffmanKey
key
T
&
&
value
)
:
key
(
key
)
value
(
value
)
{
}
HuffmanEntry
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
:
key
(
bits
bitLength
)
value
(
value
)
{
}
const
HuffmanKey
key
;
const
T
value
;
}
;
const
size_t
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
=
8
;
enum
class
Nullable
{
Null
NonNull
}
;
template
<
typename
T
int
N
=
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
>
class
HuffmanTableImpl
{
public
:
explicit
HuffmanTableImpl
(
JSContext
*
cx
)
:
values
(
cx
)
{
}
HuffmanTableImpl
(
HuffmanTableImpl
&
&
other
)
noexcept
:
values
(
std
:
:
move
(
other
.
values
)
)
{
}
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
init
(
JSContext
*
cx
size_t
numberOfSymbols
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bits_length
T
&
&
value
)
;
HuffmanTableImpl
(
)
=
delete
;
HuffmanTableImpl
(
HuffmanTableImpl
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values
.
length
(
)
;
}
const
HuffmanEntry
<
T
>
*
begin
(
)
const
{
return
values
.
begin
(
)
;
}
const
HuffmanEntry
<
T
>
*
end
(
)
const
{
return
values
.
end
(
)
;
}
private
:
Vector
<
HuffmanEntry
<
T
>
N
>
values
;
friend
class
HuffmanPreludeReader
;
}
;
struct
HuffmanTableUnreachable
{
}
;
struct
HuffmanTableExplicitSymbolsF64
{
using
Contents
=
double
;
HuffmanTableImpl
<
double
>
impl
;
explicit
HuffmanTableExplicitSymbolsF64
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
struct
HuffmanTableExplicitSymbolsU32
{
using
Contents
=
uint32_t
;
HuffmanTableImpl
<
uint32_t
>
impl
;
}
;
struct
HuffmanTableIndexedSymbolsSum
{
using
Contents
=
BinASTKind
;
HuffmanTableImpl
<
BinASTKind
>
impl
;
explicit
HuffmanTableIndexedSymbolsSum
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsBool
{
using
Contents
=
bool
;
HuffmanTableImpl
<
bool
2
>
impl
;
explicit
HuffmanTableIndexedSymbolsBool
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsMaybeInterface
{
using
Contents
=
Nullable
;
HuffmanTableImpl
<
Nullable
2
>
impl
;
explicit
HuffmanTableIndexedSymbolsMaybeInterface
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
bool
isAlwaysNull
(
)
const
{
MOZ_ASSERT
(
impl
.
length
(
)
>
0
)
;
if
(
impl
.
length
(
)
!
=
1
)
{
return
false
;
}
return
impl
.
begin
(
)
-
>
value
=
=
Nullable
:
:
Null
;
}
}
;
struct
HuffmanTableIndexedSymbolsStringEnum
{
using
Contents
=
BinASTVariant
;
HuffmanTableImpl
<
BinASTVariant
>
impl
;
explicit
HuffmanTableIndexedSymbolsStringEnum
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsLiteralString
{
using
Contents
=
JSAtom
*
;
HuffmanTableImpl
<
JSAtom
*
>
impl
;
explicit
HuffmanTableIndexedSymbolsLiteralString
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsOptionalLiteralString
{
using
Contents
=
JSAtom
*
;
HuffmanTableImpl
<
JSAtom
*
>
impl
;
explicit
HuffmanTableIndexedSymbolsOptionalLiteralString
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
using
HuffmanTable
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableExplicitSymbolsF64
HuffmanTableExplicitSymbolsU32
HuffmanTableIndexedSymbolsSum
HuffmanTableIndexedSymbolsMaybeInterface
HuffmanTableIndexedSymbolsBool
HuffmanTableIndexedSymbolsStringEnum
HuffmanTableIndexedSymbolsLiteralString
HuffmanTableIndexedSymbolsOptionalLiteralString
>
;
struct
HuffmanTableExplicitSymbolsListLength
{
using
Contents
=
uint32_t
;
HuffmanTableImpl
<
uint32_t
>
impl
;
explicit
HuffmanTableExplicitSymbolsListLength
(
JSContext
*
cx
)
:
impl
(
cx
)
{
}
}
;
using
HuffmanTableListLength
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableExplicitSymbolsListLength
>
;
class
HuffmanDictionary
{
public
:
explicit
HuffmanDictionary
(
JSContext
*
cx
)
:
fields
(
cx
)
listLengths
(
cx
)
{
}
HuffmanTable
&
tableForField
(
NormalizedInterfaceAndField
index
)
;
HuffmanTableListLength
&
tableForListLength
(
BinASTList
list
)
;
private
:
Vector
<
HuffmanTable
BINAST_INTERFACE_AND_FIELD_LIMIT
>
fields
;
Vector
<
HuffmanTableListLength
BINAST_NUMBER_OF_LIST_TYPES
>
listLengths
;
}
;
class
MOZ_STACK_CLASS
BinASTTokenReaderContext
:
public
BinASTTokenReaderBase
{
using
Base
=
BinASTTokenReaderBase
;
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Context
=
BinASTTokenReaderBase
:
:
Context
;
class
BinASTFields
{
public
:
explicit
BinASTFields
(
JSContext
*
)
{
}
}
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderContext
(
)
;
enum
class
Compression
{
No
Yes
}
;
enum
class
EndOfFilePolicy
{
RaiseError
BestEffort
}
;
private
:
static
const
size_t
DECODED_BUFFER_SIZE
=
128
;
uint8_t
decodedBuffer_
[
DECODED_BUFFER_SIZE
]
;
size_t
decodedBegin_
=
0
;
size_t
decodedEnd_
=
0
;
struct
BitBuffer
{
BitBuffer
(
)
;
template
<
Compression
Compression
>
HuffmanLookup
getHuffmanLookup
(
)
;
template
<
Compression
Compression
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
advanceBitBuffer
(
BinASTTokenReaderContext
&
owner
const
uint8_t
bitLength
)
;
private
:
uint64_t
bits
;
uint64_t
length
;
}
bitBuffer
;
size_t
availableDecodedLength
(
)
const
{
return
decodedEnd_
-
decodedBegin_
;
}
const
uint8_t
*
decodedBufferBegin
(
)
const
{
return
decodedBuffer_
+
decodedBegin_
;
}
bool
isEOF
(
)
const
;
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
template
<
Compression
compression
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
&
len
)
;
enum
class
FillResult
{
EndOfStream
Filled
}
;
MOZ_MUST_USE
JS
:
:
Result
<
FillResult
>
fillDecodedBuf
(
)
;
void
advanceDecodedBuffer
(
uint32_t
count
)
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readStringPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHuffmanPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
mozilla
:
:
Maybe
<
BinASTVariant
>
>
readMaybeVariant
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
Context
&
AutoList
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
fields
const
Context
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
Context
&
)
;
private
:
template
<
typename
Table
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Table
:
:
Contents
>
readFieldFromTable
(
const
Context
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidValue
(
const
Context
&
)
;
private
:
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readVarU32
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
handleEndOfStream
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
;
private
:
js
:
:
HashMap
<
uint32_t
BinASTVariant
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
variantsTable_
;
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadata
*
metadata_
;
class
HuffmanDictionary
dictionary
;
const
uint8_t
*
posBeforeTree_
;
BrotliDecoderState
*
decoder_
=
nullptr
;
public
:
BinASTTokenReaderContext
(
const
BinASTTokenReaderContext
&
)
=
delete
;
BinASTTokenReaderContext
(
BinASTTokenReaderContext
&
&
)
=
delete
;
BinASTTokenReaderContext
&
operator
=
(
BinASTTokenReaderContext
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
protected
:
friend
class
HuffmanPreludeReader
;
JSContext
*
cx_
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderContext
&
reader
)
;
~
AutoBase
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkPosition
(
const
uint8_t
*
expectedPosition
)
;
friend
BinASTTokenReaderContext
;
void
init
(
)
;
bool
initialized_
;
BinASTTokenReaderContext
&
reader_
;
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderContext
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
protected
:
friend
BinASTTokenReaderContext
;
void
init
(
)
;
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
template
<
size_t
N
>
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields
(
const
BinASTKind
kind
const
BinASTFields
&
actual
const
BinASTField
(
&
expected
)
[
N
]
)
{
return
Ok
(
)
;
}
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields0
(
const
BinASTKind
kind
const
BinASTFields
&
actual
)
{
return
Ok
(
)
;
}
}
;
}
}
#
endif
