#
ifndef
frontend_BinASTTokenReaderContext_h
#
define
frontend_BinASTTokenReaderContext_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JSAtom
;
class
JSTracer
;
struct
JSContext
;
namespace
js
{
class
ScriptSource
;
namespace
frontend
{
class
ErrorReporter
;
struct
NormalizedInterfaceAndField
{
const
BinASTInterfaceAndField
identity
;
explicit
NormalizedInterfaceAndField
(
BinASTInterfaceAndField
identity
)
:
identity
(
identity
=
=
BinASTInterfaceAndField
:
:
StaticMemberAssignmentTarget__Property
?
BinASTInterfaceAndField
:
:
StaticMemberExpression__Property
:
identity
)
{
}
}
;
struct
HuffmanLookup
{
HuffmanLookup
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits
(
bitLength
=
=
0
?
0
:
(
bits
&
(
uint32_t
(
0xFFFFFFFF
)
>
>
(
32
-
bitLength
)
)
)
)
bitLength
(
bitLength
)
{
MOZ_ASSERT
(
bitLength
<
=
32
)
;
MOZ_ASSERT_IF
(
bitLength
!
=
32
this
-
>
bits
>
>
bitLength
=
=
0
)
;
}
uint32_t
leadingBits
(
const
uint8_t
bitLength
)
const
;
const
uint32_t
bits
;
const
uint8_t
bitLength
;
}
;
struct
HuffmanKey
{
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
;
const
uint32_t
bits
;
const
uint8_t
bitLength
;
}
;
struct
FlatHuffmanKey
{
FlatHuffmanKey
(
HuffmanKey
key
)
;
FlatHuffmanKey
(
const
HuffmanKey
*
key
)
;
const
uint32_t
representation
;
using
Lookup
=
FlatHuffmanKey
;
using
Key
=
Lookup
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
mozilla
:
:
DefaultHasher
<
uint32_t
>
:
:
hash
(
lookup
.
representation
)
;
}
static
bool
match
(
const
Key
&
key
const
Lookup
&
lookup
)
{
return
mozilla
:
:
DefaultHasher
<
uint32_t
>
:
:
match
(
key
.
representation
lookup
.
representation
)
;
}
}
;
template
<
typename
T
>
struct
HuffmanEntry
{
HuffmanEntry
(
HuffmanKey
key
T
&
&
value
)
:
key
(
key
)
value
(
value
)
{
}
HuffmanEntry
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
:
key
(
bits
bitLength
)
value
(
value
)
{
}
const
HuffmanKey
key
;
const
T
value
;
}
;
const
size_t
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
=
8
;
enum
class
Nullable
{
Null
NonNull
}
;
template
<
typename
T
int
N
=
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
>
class
HuffmanTableImplementationNaive
{
public
:
explicit
HuffmanTableImplementationNaive
(
JSContext
*
cx
)
:
values
(
cx
)
{
}
HuffmanTableImplementationNaive
(
HuffmanTableImplementationNaive
&
&
other
)
:
values
(
std
:
:
move
(
other
.
values
)
)
{
}
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
init
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bits_length
T
&
&
value
)
;
HuffmanTableImplementationNaive
(
)
=
delete
;
HuffmanTableImplementationNaive
(
HuffmanTableImplementationNaive
&
)
=
delete
;
#
ifdef
DEBUG
void
selfCheck
(
)
;
#
endif
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values
.
length
(
)
;
}
const
HuffmanEntry
<
T
>
*
begin
(
)
const
{
return
values
.
begin
(
)
;
}
const
HuffmanEntry
<
T
>
*
end
(
)
const
{
return
values
.
end
(
)
;
}
private
:
Vector
<
HuffmanEntry
<
T
>
N
>
values
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
>
class
HuffmanTableImplementationMap
{
public
:
explicit
HuffmanTableImplementationMap
(
JSContext
*
cx
)
:
values
(
cx
)
keys
(
cx
)
{
}
HuffmanTableImplementationMap
(
HuffmanTableImplementationMap
&
&
other
)
noexcept
:
values
(
std
:
:
move
(
other
.
values
)
)
keys
(
std
:
:
move
(
other
.
keys
)
)
{
}
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
init
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bits_length
T
&
&
value
)
;
#
ifdef
DEBUG
void
selfCheck
(
)
;
#
endif
HuffmanTableImplementationMap
(
)
=
delete
;
HuffmanTableImplementationMap
(
HuffmanTableImplementationMap
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values
.
length
(
)
;
}
struct
Iterator
{
Iterator
(
const
js
:
:
HashMap
<
FlatHuffmanKey
T
FlatHuffmanKey
>
&
values
const
HuffmanKey
*
position
)
:
values
(
values
)
position
(
position
)
{
}
void
operator
+
+
(
)
{
+
+
position
;
}
const
T
*
operator
*
(
)
const
{
const
FlatHuffmanKey
key
(
position
)
;
if
(
const
auto
ptr
=
values
.
lookup
(
key
)
)
{
return
&
ptr
-
>
value
(
)
;
}
MOZ_CRASH
(
)
;
}
bool
operator
=
=
(
const
Iterator
&
other
)
const
{
MOZ_ASSERT
(
&
values
=
=
&
other
.
values
)
;
return
position
=
=
other
.
position
;
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
MOZ_ASSERT
(
&
values
=
=
&
other
.
values
)
;
return
position
!
=
other
.
position
;
}
private
:
const
js
:
:
HashMap
<
FlatHuffmanKey
T
FlatHuffmanKey
>
&
values
;
const
HuffmanKey
*
position
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values
keys
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values
keys
.
end
(
)
)
;
}
private
:
js
:
:
HashMap
<
FlatHuffmanKey
T
FlatHuffmanKey
>
values
;
Vector
<
HuffmanKey
>
keys
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
>
class
HuffmanTableImplementationSaturated
{
public
:
explicit
HuffmanTableImplementationSaturated
(
JSContext
*
cx
)
:
values
(
cx
)
saturated
(
cx
)
maxBitLength
(
-
1
)
{
}
HuffmanTableImplementationSaturated
(
HuffmanTableImplementationSaturated
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
init
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
#
ifdef
DEBUG
void
selfCheck
(
)
;
#
endif
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bits_length
T
&
&
value
)
;
HuffmanTableImplementationSaturated
(
)
=
delete
;
HuffmanTableImplementationSaturated
(
HuffmanTableImplementationSaturated
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values
.
length
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
<
T
>
*
position
)
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
<
T
>
*
position
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values
.
end
(
)
)
;
}
private
:
Vector
<
HuffmanEntry
<
T
>
>
values
;
Vector
<
uint8_t
>
saturated
;
uint8_t
maxBitLength
;
friend
class
HuffmanPreludeReader
;
}
;
struct
HuffmanTableUnreachable
{
}
;
template
<
typename
T
>
struct
HuffmanTableImplementationGeneric
{
HuffmanTableImplementationGeneric
(
JSContext
*
cx
)
;
HuffmanTableImplementationGeneric
(
)
=
delete
;
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
init
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
#
ifdef
DEBUG
void
selfCheck
(
)
;
#
endif
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bits_length
T
&
&
value
)
;
size_t
length
(
)
const
;
struct
Iterator
{
Iterator
(
typename
HuffmanTableImplementationSaturated
<
T
>
:
:
Iterator
&
&
)
;
Iterator
(
typename
HuffmanTableImplementationMap
<
T
>
:
:
Iterator
&
&
)
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
mozilla
:
:
Variant
<
typename
HuffmanTableImplementationSaturated
<
T
>
:
:
Iterator
typename
HuffmanTableImplementationMap
<
T
>
:
:
Iterator
>
implementation
;
}
;
Iterator
begin
(
)
const
;
Iterator
end
(
)
const
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
private
:
mozilla
:
:
Variant
<
HuffmanTableImplementationSaturated
<
T
>
HuffmanTableImplementationMap
<
T
>
HuffmanTableUnreachable
>
implementation
;
}
;
struct
HuffmanTableInitializing
{
}
;
struct
HuffmanTableExplicitSymbolsF64
:
HuffmanTableImplementationGeneric
<
double
>
{
using
Contents
=
double
;
explicit
HuffmanTableExplicitSymbolsF64
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
struct
HuffmanTableExplicitSymbolsU32
:
HuffmanTableImplementationGeneric
<
uint32_t
>
{
using
Contents
=
uint32_t
;
explicit
HuffmanTableExplicitSymbolsU32
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsSum
:
HuffmanTableImplementationGeneric
<
BinASTKind
>
{
using
Contents
=
BinASTKind
;
explicit
HuffmanTableIndexedSymbolsSum
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsBool
:
HuffmanTableImplementationNaive
<
bool
2
>
{
using
Contents
=
bool
;
explicit
HuffmanTableIndexedSymbolsBool
(
JSContext
*
cx
)
:
HuffmanTableImplementationNaive
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsMaybeInterface
:
HuffmanTableImplementationNaive
<
BinASTKind
2
>
{
using
Contents
=
BinASTKind
;
explicit
HuffmanTableIndexedSymbolsMaybeInterface
(
JSContext
*
cx
)
:
HuffmanTableImplementationNaive
(
cx
)
{
}
bool
isAlwaysNull
(
)
const
{
MOZ_ASSERT
(
length
(
)
>
0
)
;
if
(
length
(
)
!
=
1
)
{
return
false
;
}
return
begin
(
)
-
>
value
=
=
BinASTKind
:
:
_Null
;
}
}
;
struct
HuffmanTableIndexedSymbolsStringEnum
:
HuffmanTableImplementationGeneric
<
BinASTVariant
>
{
using
Contents
=
BinASTVariant
;
explicit
HuffmanTableIndexedSymbolsStringEnum
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsLiteralString
:
HuffmanTableImplementationGeneric
<
JSAtom
*
>
{
using
Contents
=
JSAtom
*
;
explicit
HuffmanTableIndexedSymbolsLiteralString
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsOptionalLiteralString
:
HuffmanTableImplementationGeneric
<
JSAtom
*
>
{
using
Contents
=
JSAtom
*
;
explicit
HuffmanTableIndexedSymbolsOptionalLiteralString
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
using
HuffmanTableValue
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableInitializing
HuffmanTableExplicitSymbolsF64
HuffmanTableExplicitSymbolsU32
HuffmanTableIndexedSymbolsSum
HuffmanTableIndexedSymbolsMaybeInterface
HuffmanTableIndexedSymbolsBool
HuffmanTableIndexedSymbolsStringEnum
HuffmanTableIndexedSymbolsLiteralString
HuffmanTableIndexedSymbolsOptionalLiteralString
>
;
struct
HuffmanTableExplicitSymbolsListLength
:
HuffmanTableImplementationGeneric
<
uint32_t
>
{
using
Contents
=
uint32_t
;
explicit
HuffmanTableExplicitSymbolsListLength
(
JSContext
*
cx
)
:
HuffmanTableImplementationGeneric
(
cx
)
{
}
}
;
using
HuffmanTableListLength
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableInitializing
HuffmanTableExplicitSymbolsListLength
>
;
class
HuffmanDictionary
{
public
:
explicit
HuffmanDictionary
(
JSContext
*
cx
)
;
HuffmanTableValue
&
tableForField
(
NormalizedInterfaceAndField
index
)
;
HuffmanTableListLength
&
tableForListLength
(
BinASTList
list
)
;
private
:
mozilla
:
:
Array
<
HuffmanTableValue
BINAST_INTERFACE_AND_FIELD_LIMIT
>
fields
;
mozilla
:
:
Array
<
HuffmanTableListLength
BINAST_NUMBER_OF_LIST_TYPES
>
listLengths
;
}
;
class
MOZ_STACK_CLASS
BinASTTokenReaderContext
:
public
BinASTTokenReaderBase
{
using
Base
=
BinASTTokenReaderBase
;
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
Context
=
BinASTTokenReaderBase
:
:
Context
;
class
BinASTFields
{
public
:
explicit
BinASTFields
(
JSContext
*
)
{
}
}
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderContext
(
)
;
enum
class
Compression
{
No
Yes
}
;
enum
class
EndOfFilePolicy
{
RaiseError
BestEffort
}
;
protected
:
struct
BitBuffer
{
BitBuffer
(
)
;
template
<
Compression
Compression
>
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanLookup
>
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
;
template
<
Compression
Compression
>
void
advanceBitBuffer
(
const
uint8_t
bitLength
)
;
private
:
uint64_t
bits
;
uint8_t
bitLength
;
}
bitBuffer
;
bool
isEOF
(
)
const
;
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
template
<
Compression
compression
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
&
len
)
;
enum
class
FillResult
{
EndOfStream
Filled
}
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readStringPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHuffmanPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
mozilla
:
:
Maybe
<
BinASTVariant
>
>
readMaybeVariant
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
Context
&
AutoList
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterTaggedTuple
(
BinASTKind
&
tag
BinASTTokenReaderContext
:
:
BinASTFields
&
fields
const
Context
&
AutoTaggedTuple
&
guard
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
Context
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnpackedLong
(
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
readTagFromTable
(
const
Context
&
)
;
template
<
typename
Table
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Table
:
:
Contents
>
readFieldFromTable
(
const
Context
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidValue
(
const
Context
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseNotInPrelude
(
const
Context
&
)
;
private
:
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readVarU32
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
handleEndOfStream
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
;
private
:
js
:
:
HashMap
<
FlatHuffmanKey
BinASTVariant
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
variantsTable_
;
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadata
*
metadata_
;
class
HuffmanDictionary
dictionary
;
const
uint8_t
*
posBeforeTree_
;
public
:
BinASTTokenReaderContext
(
const
BinASTTokenReaderContext
&
)
=
delete
;
BinASTTokenReaderContext
(
BinASTTokenReaderContext
&
&
)
=
delete
;
BinASTTokenReaderContext
&
operator
=
(
BinASTTokenReaderContext
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
protected
:
friend
class
HuffmanPreludeReader
;
friend
struct
TagReader
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderContext
&
reader
)
;
~
AutoBase
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkPosition
(
const
uint8_t
*
expectedPosition
)
;
friend
BinASTTokenReaderContext
;
void
init
(
)
;
bool
initialized_
;
BinASTTokenReaderContext
&
reader_
;
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderContext
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
protected
:
friend
BinASTTokenReaderContext
;
void
init
(
)
;
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
;
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
template
<
size_t
N
>
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields
(
const
BinASTKind
kind
const
BinASTFields
&
actual
const
BinASTField
(
&
expected
)
[
N
]
)
{
return
Ok
(
)
;
}
static
JS
:
:
Result
<
Ok
JS
:
:
Error
&
>
checkFields0
(
const
BinASTKind
kind
const
BinASTFields
&
actual
)
{
return
Ok
(
)
;
}
}
;
}
}
#
endif
