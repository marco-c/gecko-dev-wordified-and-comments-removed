#
ifndef
frontend_BinASTTokenReaderContext_h
#
define
frontend_BinASTTokenReaderContext_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
frontend
/
BinASTRuntimeSupport
.
h
"
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
BinASTTokenReaderBase
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JSAtom
;
class
JSTracer
;
struct
JSContext
;
namespace
js
{
class
ScriptSource
;
namespace
frontend
{
class
ErrorReporter
;
struct
NormalizedInterfaceAndField
{
const
BinASTInterfaceAndField
identity_
;
explicit
NormalizedInterfaceAndField
(
BinASTInterfaceAndField
identity
)
:
identity_
(
identity
=
=
BinASTInterfaceAndField
:
:
StaticMemberAssignmentTarget__Property
?
BinASTInterfaceAndField
:
:
StaticMemberExpression__Property
:
identity
)
{
}
}
;
template
<
typename
T
>
struct
Split
{
T
prefix_
;
T
suffix_
;
}
;
struct
HuffmanLookup
{
HuffmanLookup
(
const
uint32_t
bits
const
uint8_t
bitLength
)
:
bits_
(
bitLength
=
=
0
?
0
:
(
bits
&
(
uint32_t
(
0xFFFFFFFF
)
>
>
(
32
-
bitLength
)
)
)
)
bitLength_
(
bitLength
)
{
MOZ_ASSERT
(
bitLength_
<
=
32
)
;
MOZ_ASSERT_IF
(
bitLength_
!
=
32
bits_
>
>
bitLength_
=
=
0
)
;
}
uint32_t
leadingBits
(
const
uint8_t
bitLength
)
const
;
Split
<
HuffmanLookup
>
split
(
const
uint8_t
prefixLength
)
const
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
mozilla
:
:
detail
:
:
IntegerRange
<
size_t
>
suffixes
(
uint8_t
expectedBitLength
)
const
;
}
;
struct
HuffmanKey
{
HuffmanKey
(
const
uint32_t
bits
const
uint8_t
bitLength
)
;
const
uint32_t
bits_
;
const
uint8_t
bitLength_
;
}
;
struct
FlatHuffmanKey
{
explicit
FlatHuffmanKey
(
HuffmanKey
key
)
;
explicit
FlatHuffmanKey
(
const
HuffmanKey
*
key
)
;
const
uint32_t
representation_
;
using
Lookup
=
FlatHuffmanKey
;
using
Key
=
Lookup
;
static
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
mozilla
:
:
DefaultHasher
<
uint32_t
>
:
:
hash
(
lookup
.
representation_
)
;
}
static
bool
match
(
const
Key
&
key
const
Lookup
&
lookup
)
{
return
mozilla
:
:
DefaultHasher
<
uint32_t
>
:
:
match
(
key
.
representation_
lookup
.
representation_
)
;
}
}
;
template
<
typename
T
>
struct
HuffmanEntry
{
HuffmanEntry
(
HuffmanKey
key
T
&
&
value
)
:
key_
(
key
)
value_
(
value
)
{
}
HuffmanEntry
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
:
key_
(
bits
bitLength
)
value_
(
value
)
{
}
const
HuffmanKey
key_
;
const
T
value_
;
}
;
const
size_t
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
=
8
;
enum
class
Nullable
{
Null
NonNull
}
;
template
<
typename
T
int
N
=
HUFFMAN_TABLE_DEFAULT_INLINE_BUFFER_LENGTH
>
class
NaiveHuffmanTable
{
public
:
explicit
NaiveHuffmanTable
(
JSContext
*
cx
)
:
values_
(
cx
)
{
}
NaiveHuffmanTable
(
NaiveHuffmanTable
&
&
other
)
noexcept
:
values_
(
std
:
:
move
(
other
.
values_
)
)
{
}
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
;
NaiveHuffmanTable
(
)
=
delete
;
NaiveHuffmanTable
(
NaiveHuffmanTable
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
lookup
)
const
;
size_t
length
(
)
const
{
return
values_
.
length
(
)
;
}
const
HuffmanEntry
<
T
>
*
begin
(
)
const
{
return
values_
.
begin
(
)
;
}
const
HuffmanEntry
<
T
>
*
end
(
)
const
{
return
values_
.
end
(
)
;
}
private
:
Vector
<
HuffmanEntry
<
T
>
N
>
values_
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
>
class
SingleEntryHuffmanTable
{
public
:
explicit
SingleEntryHuffmanTable
(
T
&
&
value
)
:
value_
(
std
:
:
move
(
value
)
)
{
}
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
&
other
)
=
default
;
SingleEntryHuffmanTable
(
)
=
delete
;
SingleEntryHuffmanTable
(
SingleEntryHuffmanTable
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
1
;
}
struct
Iterator
{
explicit
Iterator
(
const
T
*
position
)
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
T
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
&
value_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
nullptr
)
;
}
private
:
T
value_
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
>
class
SingleLookupHuffmanTable
{
public
:
using
InternalIndex
=
uint8_t
;
static
const
uint8_t
MAX_BIT_LENGTH
=
sizeof
(
InternalIndex
)
*
8
;
explicit
SingleLookupHuffmanTable
(
JSContext
*
cx
)
:
values_
(
cx
)
saturated_
(
cx
)
largestBitLength_
(
-
1
)
{
}
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
;
SingleLookupHuffmanTable
(
)
=
delete
;
SingleLookupHuffmanTable
(
SingleLookupHuffmanTable
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
length
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
<
T
>
*
position
)
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
<
T
>
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values_
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values_
.
end
(
)
)
;
}
private
:
Vector
<
HuffmanEntry
<
T
>
>
values_
;
Vector
<
InternalIndex
>
saturated_
;
uint8_t
largestBitLength_
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
typename
Subtable
uint8_t
PrefixBitLength
>
class
MultiLookupHuffmanTable
{
public
:
static
const
uint8_t
MAX_BIT_LENGTH
=
PrefixBitLength
+
Subtable
:
:
MAX_BIT_LENGTH
;
explicit
MultiLookupHuffmanTable
(
JSContext
*
cx
)
:
cx_
(
cx
)
values_
(
cx
)
subTables_
(
cx
)
largestBitLength_
(
-
1
)
{
}
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
&
other
)
=
default
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
largestBitLength
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
;
MultiLookupHuffmanTable
(
)
=
delete
;
MultiLookupHuffmanTable
(
MultiLookupHuffmanTable
&
)
=
delete
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
size_t
length
(
)
const
{
return
values_
.
length
(
)
;
}
struct
Iterator
{
explicit
Iterator
(
const
HuffmanEntry
<
T
>
*
position
)
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
const
HuffmanEntry
<
T
>
*
position_
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
values_
.
begin
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
values_
.
end
(
)
)
;
}
public
:
using
InternalIndex
=
uint8_t
;
private
:
JSContext
*
cx_
;
Vector
<
HuffmanEntry
<
T
>
>
values_
;
Vector
<
Subtable
>
subTables_
;
uint8_t
largestBitLength_
;
friend
class
HuffmanPreludeReader
;
}
;
template
<
typename
T
>
using
TwoLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
T
SingleLookupHuffmanTable
<
size_t
>
6
>
;
template
<
typename
T
>
using
ThreeLookupsHuffmanTable
=
MultiLookupHuffmanTable
<
T
TwoLookupsHuffmanTable
<
size_t
>
6
>
;
struct
HuffmanTableUnreachable
{
}
;
template
<
typename
T
>
struct
GenericHuffmanTable
{
explicit
GenericHuffmanTable
(
JSContext
*
cx
)
;
explicit
GenericHuffmanTable
(
)
=
delete
;
JS
:
:
Result
<
Ok
>
initWithSingleValue
(
JSContext
*
cx
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
initStart
(
JSContext
*
cx
size_t
numberOfSymbols
uint8_t
maxBitLength
)
;
JS
:
:
Result
<
Ok
>
addSymbol
(
uint32_t
bits
uint8_t
bitLength
T
&
&
value
)
;
JS
:
:
Result
<
Ok
>
initComplete
(
)
;
size_t
length
(
)
const
;
struct
Iterator
{
explicit
Iterator
(
typename
SingleEntryHuffmanTable
<
T
>
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
&
&
)
;
explicit
Iterator
(
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
&
&
)
;
Iterator
(
Iterator
&
&
)
=
default
;
Iterator
(
const
Iterator
&
)
=
default
;
void
operator
+
+
(
)
;
const
T
*
operator
*
(
)
const
;
bool
operator
=
=
(
const
Iterator
&
other
)
const
;
bool
operator
!
=
(
const
Iterator
&
other
)
const
;
private
:
mozilla
:
:
Variant
<
typename
SingleEntryHuffmanTable
<
T
>
:
:
Iterator
typename
SingleLookupHuffmanTable
<
T
>
:
:
Iterator
typename
TwoLookupsHuffmanTable
<
T
>
:
:
Iterator
typename
ThreeLookupsHuffmanTable
<
T
>
:
:
Iterator
>
implementation_
;
}
;
Iterator
begin
(
)
const
;
Iterator
end
(
)
const
;
HuffmanEntry
<
const
T
*
>
lookup
(
HuffmanLookup
key
)
const
;
private
:
mozilla
:
:
Variant
<
SingleEntryHuffmanTable
<
T
>
SingleLookupHuffmanTable
<
T
>
TwoLookupsHuffmanTable
<
T
>
ThreeLookupsHuffmanTable
<
T
>
HuffmanTableUnreachable
>
implementation_
;
}
;
struct
HuffmanTableInitializing
{
}
;
struct
HuffmanTableExplicitSymbolsF64
:
GenericHuffmanTable
<
double
>
{
using
Contents
=
double
;
explicit
HuffmanTableExplicitSymbolsF64
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableExplicitSymbolsU32
:
GenericHuffmanTable
<
uint32_t
>
{
using
Contents
=
uint32_t
;
explicit
HuffmanTableExplicitSymbolsU32
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsSum
:
GenericHuffmanTable
<
BinASTKind
>
{
using
Contents
=
BinASTKind
;
explicit
HuffmanTableIndexedSymbolsSum
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsBool
:
NaiveHuffmanTable
<
bool
2
>
{
using
Contents
=
bool
;
explicit
HuffmanTableIndexedSymbolsBool
(
JSContext
*
cx
)
:
NaiveHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsMaybeInterface
:
NaiveHuffmanTable
<
BinASTKind
2
>
{
using
Contents
=
BinASTKind
;
explicit
HuffmanTableIndexedSymbolsMaybeInterface
(
JSContext
*
cx
)
:
NaiveHuffmanTable
(
cx
)
{
}
bool
isAlwaysNull
(
)
const
{
MOZ_ASSERT
(
length
(
)
>
0
)
;
if
(
length
(
)
!
=
1
)
{
return
false
;
}
return
begin
(
)
-
>
value_
=
=
BinASTKind
:
:
_Null
;
}
}
;
struct
HuffmanTableIndexedSymbolsStringEnum
:
GenericHuffmanTable
<
BinASTVariant
>
{
using
Contents
=
BinASTVariant
;
explicit
HuffmanTableIndexedSymbolsStringEnum
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsLiteralString
:
GenericHuffmanTable
<
JSAtom
*
>
{
using
Contents
=
JSAtom
*
;
explicit
HuffmanTableIndexedSymbolsLiteralString
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
struct
HuffmanTableIndexedSymbolsOptionalLiteralString
:
GenericHuffmanTable
<
JSAtom
*
>
{
using
Contents
=
JSAtom
*
;
explicit
HuffmanTableIndexedSymbolsOptionalLiteralString
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
using
HuffmanTableValue
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableInitializing
HuffmanTableExplicitSymbolsF64
HuffmanTableExplicitSymbolsU32
HuffmanTableIndexedSymbolsSum
HuffmanTableIndexedSymbolsMaybeInterface
HuffmanTableIndexedSymbolsBool
HuffmanTableIndexedSymbolsStringEnum
HuffmanTableIndexedSymbolsLiteralString
HuffmanTableIndexedSymbolsOptionalLiteralString
>
;
struct
HuffmanTableExplicitSymbolsListLength
:
GenericHuffmanTable
<
uint32_t
>
{
using
Contents
=
uint32_t
;
explicit
HuffmanTableExplicitSymbolsListLength
(
JSContext
*
cx
)
:
GenericHuffmanTable
(
cx
)
{
}
}
;
using
HuffmanTableListLength
=
mozilla
:
:
Variant
<
HuffmanTableUnreachable
HuffmanTableInitializing
HuffmanTableExplicitSymbolsListLength
>
;
class
HuffmanDictionary
{
public
:
explicit
HuffmanDictionary
(
JSContext
*
cx
)
;
HuffmanTableValue
&
tableForField
(
NormalizedInterfaceAndField
index
)
;
HuffmanTableListLength
&
tableForListLength
(
BinASTList
list
)
;
private
:
mozilla
:
:
Array
<
HuffmanTableValue
BINAST_INTERFACE_AND_FIELD_LIMIT
>
fields_
;
mozilla
:
:
Array
<
HuffmanTableListLength
BINAST_NUMBER_OF_LIST_TYPES
>
listLengths_
;
}
;
class
MOZ_STACK_CLASS
BinASTTokenReaderContext
:
public
BinASTTokenReaderBase
{
using
Base
=
BinASTTokenReaderBase
;
public
:
class
AutoList
;
class
AutoTaggedTuple
;
using
CharSlice
=
BinaryASTSupport
:
:
CharSlice
;
using
RootContext
=
BinASTTokenReaderBase
:
:
RootContext
;
using
ListContext
=
BinASTTokenReaderBase
:
:
ListContext
;
using
FieldContext
=
BinASTTokenReaderBase
:
:
FieldContext
;
using
FieldOrRootContext
=
BinASTTokenReaderBase
:
:
FieldOrRootContext
;
using
FieldOrListContext
=
BinASTTokenReaderBase
:
:
FieldOrListContext
;
using
Chars
=
CharSlice
;
public
:
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
;
BinASTTokenReaderContext
(
JSContext
*
cx
ErrorReporter
*
er
const
Vector
<
uint8_t
>
&
chars
)
;
~
BinASTTokenReaderContext
(
)
;
enum
class
Compression
{
No
Yes
}
;
enum
class
EndOfFilePolicy
{
RaiseError
BestEffort
}
;
protected
:
struct
BitBuffer
{
BitBuffer
(
)
;
template
<
Compression
Compression
>
MOZ_MUST_USE
JS
:
:
Result
<
HuffmanLookup
>
getHuffmanLookup
(
BinASTTokenReaderContext
&
owner
)
;
template
<
Compression
Compression
>
void
advanceBitBuffer
(
const
uint8_t
bitLength
)
;
private
:
uint64_t
bits_
;
uint8_t
bitLength_
;
}
bitBuffer
;
bool
isEOF
(
)
const
;
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
template
<
Compression
compression
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
&
len
)
;
enum
class
FillResult
{
EndOfStream
Filled
}
;
public
:
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHeader
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readStringPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readHuffmanPrelude
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readDouble
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readAtom
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readMaybeIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readIdentifierName
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
JSAtom
*
>
readPropertyKey
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readChars
(
Chars
&
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
BinASTVariant
>
readVariant
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
SkippableSubTree
>
readSkippableSubTree
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterList
(
uint32_t
&
length
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
)
{
MOZ_ASSERT
(
tag
!
=
BinASTKind
:
:
_Uninitialized
)
;
return
Ok
(
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
RootContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
ListContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterInterface
(
BinASTKind
&
tag
const
FieldContext
&
)
{
return
enterInterface
(
tag
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrRootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldOrListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
RootContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
ListContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterOptionalInterface
(
BinASTKind
&
tag
const
FieldContext
&
context
)
{
return
enterSum
(
tag
context
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrRootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldOrListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
RootContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
ListContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
enterSum
(
BinASTKind
&
tag
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnsignedLong
(
const
FieldContext
&
)
;
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readUnpackedLong
(
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
BinASTKind
>
readTagFromTable
(
const
BinASTInterfaceAndField
&
)
;
template
<
typename
Table
>
MOZ_MUST_USE
JS
:
:
Result
<
typename
Table
:
:
Contents
>
readFieldFromTable
(
const
BinASTInterfaceAndField
&
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidValue
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseNotInPrelude
(
)
;
private
:
template
<
Compression
compression
>
MOZ_MUST_USE
JS
:
:
Result
<
uint32_t
>
readVarU32
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
handleEndOfStream
(
)
;
template
<
EndOfFilePolicy
policy
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBufCompressedAux
(
uint8_t
*
bytes
uint32_t
&
len
)
;
private
:
js
:
:
HashMap
<
FlatHuffmanKey
BinASTVariant
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
variantsTable_
;
enum
class
MetadataOwnership
{
Owned
Unowned
}
;
MetadataOwnership
metadataOwned_
=
MetadataOwnership
:
:
Owned
;
BinASTSourceMetadata
*
metadata_
;
class
HuffmanDictionary
dictionary_
;
const
uint8_t
*
posBeforeTree_
;
public
:
BinASTTokenReaderContext
(
const
BinASTTokenReaderContext
&
)
=
delete
;
BinASTTokenReaderContext
(
BinASTTokenReaderContext
&
&
)
=
delete
;
BinASTTokenReaderContext
&
operator
=
(
BinASTTokenReaderContext
&
)
=
delete
;
public
:
void
traceMetadata
(
JSTracer
*
trc
)
;
BinASTSourceMetadata
*
takeMetadata
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
initFromScriptSource
(
ScriptSource
*
scriptSource
)
;
protected
:
friend
class
HuffmanPreludeReader
;
public
:
class
MOZ_STACK_CLASS
AutoBase
{
protected
:
explicit
AutoBase
(
BinASTTokenReaderContext
&
reader
)
#
ifdef
DEBUG
:
initialized_
(
false
)
reader_
(
reader
)
#
endif
{
}
~
AutoBase
(
)
{
MOZ_ASSERT_IF
(
initialized_
reader_
.
hasRaisedError
(
)
)
;
}
friend
BinASTTokenReaderContext
;
public
:
inline
void
init
(
)
{
#
ifdef
DEBUG
initialized_
=
true
;
#
endif
}
inline
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
done
(
)
{
#
ifdef
DEBUG
initialized_
=
false
;
#
endif
return
Ok
(
)
;
}
protected
:
#
ifdef
DEBUG
bool
initialized_
;
BinASTTokenReaderContext
&
reader_
;
#
endif
}
;
class
MOZ_STACK_CLASS
AutoList
:
public
AutoBase
{
public
:
explicit
AutoList
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
class
MOZ_STACK_CLASS
AutoTaggedTuple
:
public
AutoBase
{
public
:
explicit
AutoTaggedTuple
(
BinASTTokenReaderContext
&
reader
)
:
AutoBase
(
reader
)
{
}
}
;
template
<
size_t
N
>
static
bool
equals
(
const
Chars
&
left
const
char
(
&
right
)
[
N
]
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
right
[
N
-
1
]
=
=
0
)
;
if
(
left
.
byteLen_
+
1
!
=
N
)
{
return
false
;
}
if
(
!
std
:
:
equal
(
left
.
start_
left
.
start_
+
left
.
byteLen_
right
)
)
{
return
false
;
}
return
true
;
}
}
;
}
}
#
endif
