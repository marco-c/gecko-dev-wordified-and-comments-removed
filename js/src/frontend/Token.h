#
ifndef
frontend_Token_h
#
define
frontend_Token_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
TokenKind
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
namespace
js
{
namespace
frontend
{
struct
TokenPos
{
uint32_t
begin
=
0
;
uint32_t
end
=
0
;
TokenPos
(
)
=
default
;
TokenPos
(
uint32_t
begin
uint32_t
end
)
:
begin
(
begin
)
end
(
end
)
{
}
static
TokenPos
box
(
const
TokenPos
&
left
const
TokenPos
&
right
)
{
MOZ_ASSERT
(
left
.
begin
<
=
left
.
end
)
;
MOZ_ASSERT
(
left
.
end
<
=
right
.
begin
)
;
MOZ_ASSERT
(
right
.
begin
<
=
right
.
end
)
;
return
TokenPos
(
left
.
begin
right
.
end
)
;
}
bool
operator
=
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
=
=
bpos
.
begin
&
&
end
=
=
bpos
.
end
;
}
bool
operator
!
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
!
=
bpos
.
begin
|
|
end
!
=
bpos
.
end
;
}
bool
operator
<
(
const
TokenPos
&
bpos
)
const
{
return
begin
<
bpos
.
begin
;
}
bool
operator
<
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
<
=
bpos
.
begin
;
}
bool
operator
>
(
const
TokenPos
&
bpos
)
const
{
return
!
(
*
this
<
=
bpos
)
;
}
bool
operator
>
=
(
const
TokenPos
&
bpos
)
const
{
return
!
(
*
this
<
bpos
)
;
}
bool
encloses
(
const
TokenPos
&
pos
)
const
{
return
begin
<
=
pos
.
begin
&
&
pos
.
end
<
=
end
;
}
}
;
enum
DecimalPoint
{
NoDecimal
=
false
HasDecimal
=
true
}
;
enum
class
IdentifierEscapes
{
None
SawUnicodeEscape
}
;
enum
class
NameVisibility
{
Public
Private
}
;
class
TokenStreamShared
;
struct
Token
{
private
:
enum
Modifier
{
SlashIsDiv
SlashIsRegExp
SlashIsInvalid
}
;
friend
class
TokenStreamShared
;
public
:
TokenKind
type
;
TokenPos
pos
;
union
{
private
:
friend
struct
Token
;
const
ParserName
*
name
;
const
ParserAtom
*
atom
;
struct
{
double
value
;
DecimalPoint
decimalPoint
;
}
number
;
JS
:
:
RegExpFlags
reflags
;
}
u
;
#
ifdef
DEBUG
Modifier
modifier
;
#
endif
void
setName
(
const
ParserName
*
name
)
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
Name
|
|
type
=
=
TokenKind
:
:
PrivateName
)
;
u
.
name
=
name
;
}
void
setAtom
(
const
ParserAtom
*
atom
)
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
String
|
|
type
=
=
TokenKind
:
:
TemplateHead
|
|
type
=
=
TokenKind
:
:
NoSubsTemplate
)
;
u
.
atom
=
atom
;
}
void
setRegExpFlags
(
JS
:
:
RegExpFlags
flags
)
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
RegExp
)
;
u
.
reflags
=
flags
;
}
void
setNumber
(
double
n
DecimalPoint
decimalPoint
)
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
Number
)
;
u
.
number
.
value
=
n
;
u
.
number
.
decimalPoint
=
decimalPoint
;
}
const
ParserName
*
name
(
)
const
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
Name
|
|
type
=
=
TokenKind
:
:
PrivateName
)
;
return
u
.
name
-
>
asName
(
)
;
}
const
ParserAtom
*
atom
(
)
const
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
String
|
|
type
=
=
TokenKind
:
:
TemplateHead
|
|
type
=
=
TokenKind
:
:
NoSubsTemplate
)
;
return
u
.
atom
;
}
JS
:
:
RegExpFlags
regExpFlags
(
)
const
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
RegExp
)
;
return
u
.
reflags
;
}
double
number
(
)
const
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
Number
)
;
return
u
.
number
.
value
;
}
DecimalPoint
decimalPoint
(
)
const
{
MOZ_ASSERT
(
type
=
=
TokenKind
:
:
Number
)
;
return
u
.
number
.
decimalPoint
;
}
}
;
}
}
#
endif
