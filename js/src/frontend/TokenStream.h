#
ifndef
frontend_TokenStream_h
#
define
frontend_TokenStream_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
"
jscntxt
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
frontend
/
TokenKind
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
ErrorReporting
.
h
"
#
include
"
vm
/
RegExpShared
.
h
"
#
include
"
vm
/
String
.
h
"
#
include
"
vm
/
Unicode
.
h
"
struct
KeywordInfo
;
namespace
js
{
namespace
frontend
{
struct
TokenPos
{
uint32_t
begin
;
uint32_t
end
;
TokenPos
(
)
{
}
TokenPos
(
uint32_t
begin
uint32_t
end
)
:
begin
(
begin
)
end
(
end
)
{
}
static
TokenPos
box
(
const
TokenPos
&
left
const
TokenPos
&
right
)
{
MOZ_ASSERT
(
left
.
begin
<
=
left
.
end
)
;
MOZ_ASSERT
(
left
.
end
<
=
right
.
begin
)
;
MOZ_ASSERT
(
right
.
begin
<
=
right
.
end
)
;
return
TokenPos
(
left
.
begin
right
.
end
)
;
}
bool
operator
=
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
=
=
bpos
.
begin
&
&
end
=
=
bpos
.
end
;
}
bool
operator
!
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
!
=
bpos
.
begin
|
|
end
!
=
bpos
.
end
;
}
bool
operator
<
(
const
TokenPos
&
bpos
)
const
{
return
begin
<
bpos
.
begin
;
}
bool
operator
<
=
(
const
TokenPos
&
bpos
)
const
{
return
begin
<
=
bpos
.
begin
;
}
bool
operator
>
(
const
TokenPos
&
bpos
)
const
{
return
!
(
*
this
<
=
bpos
)
;
}
bool
operator
>
=
(
const
TokenPos
&
bpos
)
const
{
return
!
(
*
this
<
bpos
)
;
}
bool
encloses
(
const
TokenPos
&
pos
)
const
{
return
begin
<
=
pos
.
begin
&
&
pos
.
end
<
=
end
;
}
}
;
enum
DecimalPoint
{
NoDecimal
=
false
HasDecimal
=
true
}
;
enum
class
InvalidEscapeType
{
None
Hexadecimal
Unicode
UnicodeOverflow
Octal
}
;
class
TokenStreamAnyChars
;
struct
Token
{
private
:
enum
Modifier
{
None
Operand
TemplateTail
}
;
enum
ModifierException
{
NoException
NoneIsOperand
OperandIsNone
}
;
friend
class
TokenStreamAnyChars
;
public
:
TokenKind
type
;
TokenPos
pos
;
union
{
private
:
friend
struct
Token
;
PropertyName
*
name
;
JSAtom
*
atom
;
struct
{
double
value
;
DecimalPoint
decimalPoint
;
}
number
;
RegExpFlag
reflags
;
}
u
;
#
ifdef
DEBUG
Modifier
modifier
;
ModifierException
modifierException
;
#
endif
void
setName
(
PropertyName
*
name
)
{
MOZ_ASSERT
(
type
=
=
TOK_NAME
)
;
u
.
name
=
name
;
}
void
setAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
type
=
=
TOK_STRING
|
|
type
=
=
TOK_TEMPLATE_HEAD
|
|
type
=
=
TOK_NO_SUBS_TEMPLATE
)
;
u
.
atom
=
atom
;
}
void
setRegExpFlags
(
RegExpFlag
flags
)
{
MOZ_ASSERT
(
type
=
=
TOK_REGEXP
)
;
MOZ_ASSERT
(
(
flags
&
AllFlags
)
=
=
flags
)
;
u
.
reflags
=
flags
;
}
void
setNumber
(
double
n
DecimalPoint
decimalPoint
)
{
MOZ_ASSERT
(
type
=
=
TOK_NUMBER
)
;
u
.
number
.
value
=
n
;
u
.
number
.
decimalPoint
=
decimalPoint
;
}
PropertyName
*
name
(
)
const
{
MOZ_ASSERT
(
type
=
=
TOK_NAME
)
;
return
u
.
name
-
>
JSAtom
:
:
asPropertyName
(
)
;
}
JSAtom
*
atom
(
)
const
{
MOZ_ASSERT
(
type
=
=
TOK_STRING
|
|
type
=
=
TOK_TEMPLATE_HEAD
|
|
type
=
=
TOK_NO_SUBS_TEMPLATE
)
;
return
u
.
atom
;
}
RegExpFlag
regExpFlags
(
)
const
{
MOZ_ASSERT
(
type
=
=
TOK_REGEXP
)
;
MOZ_ASSERT
(
(
u
.
reflags
&
AllFlags
)
=
=
u
.
reflags
)
;
return
u
.
reflags
;
}
double
number
(
)
const
{
MOZ_ASSERT
(
type
=
=
TOK_NUMBER
)
;
return
u
.
number
.
value
;
}
DecimalPoint
decimalPoint
(
)
const
{
MOZ_ASSERT
(
type
=
=
TOK_NUMBER
)
;
return
u
.
number
.
decimalPoint
;
}
}
;
extern
TokenKind
ReservedWordTokenKind
(
PropertyName
*
str
)
;
extern
const
char
*
ReservedWordToCharZ
(
PropertyName
*
str
)
;
extern
const
char
*
ReservedWordToCharZ
(
TokenKind
tt
)
;
class
StrictModeGetter
{
public
:
virtual
bool
strictMode
(
)
=
0
;
}
;
class
TokenStreamAnyChars
{
protected
:
TokenStreamAnyChars
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
StrictModeGetter
*
smg
)
;
static
const
size_t
ntokens
=
4
;
static
const
unsigned
maxLookahead
=
2
;
static
const
unsigned
ntokensMask
=
ntokens
-
1
;
public
:
const
Token
&
currentToken
(
)
const
{
return
tokens
[
cursor
]
;
}
bool
isCurrentTokenType
(
TokenKind
type
)
const
{
return
currentToken
(
)
.
type
=
=
type
;
}
const
char
*
getFilename
(
)
const
{
return
filename
;
}
bool
getMutedErrors
(
)
const
{
return
mutedErrors
;
}
JSVersion
versionNumber
(
)
const
{
return
VersionNumber
(
options
(
)
.
version
)
;
}
JSVersion
versionWithFlags
(
)
const
{
return
options
(
)
.
version
;
}
MOZ_MUST_USE
bool
checkOptions
(
)
;
protected
:
PropertyName
*
reservedWordToPropertyName
(
TokenKind
tt
)
const
;
public
:
PropertyName
*
currentName
(
)
const
{
if
(
isCurrentTokenType
(
TOK_NAME
)
)
return
currentToken
(
)
.
name
(
)
;
MOZ_ASSERT
(
TokenKindIsPossibleIdentifierName
(
currentToken
(
)
.
type
)
)
;
return
reservedWordToPropertyName
(
currentToken
(
)
.
type
)
;
}
bool
currentNameHasEscapes
(
)
const
{
if
(
isCurrentTokenType
(
TOK_NAME
)
)
{
TokenPos
pos
=
currentToken
(
)
.
pos
;
return
(
pos
.
end
-
pos
.
begin
)
!
=
currentToken
(
)
.
name
(
)
-
>
length
(
)
;
}
MOZ_ASSERT
(
TokenKindIsPossibleIdentifierName
(
currentToken
(
)
.
type
)
)
;
return
false
;
}
PropertyName
*
nextName
(
)
const
{
if
(
nextToken
(
)
.
type
!
=
TOK_NAME
)
return
nextToken
(
)
.
name
(
)
;
MOZ_ASSERT
(
TokenKindIsPossibleIdentifierName
(
nextToken
(
)
.
type
)
)
;
return
reservedWordToPropertyName
(
nextToken
(
)
.
type
)
;
}
bool
isCurrentTokenAssignment
(
)
const
{
return
TokenKindIsAssignment
(
currentToken
(
)
.
type
)
;
}
bool
isEOF
(
)
const
{
return
flags
.
isEOF
;
}
bool
sawOctalEscape
(
)
const
{
return
flags
.
sawOctalEscape
;
}
bool
hadError
(
)
const
{
return
flags
.
hadError
;
}
void
clearSawOctalEscape
(
)
{
flags
.
sawOctalEscape
=
false
;
}
bool
hasInvalidTemplateEscape
(
)
const
{
return
invalidTemplateEscapeType
!
=
InvalidEscapeType
:
:
None
;
}
void
clearInvalidTemplateEscape
(
)
{
invalidTemplateEscapeType
=
InvalidEscapeType
:
:
None
;
}
static
const
uint32_t
NoOffset
=
UINT32_MAX
;
protected
:
bool
strictMode
(
)
const
{
return
strictModeGetter
&
&
strictModeGetter
-
>
strictMode
(
)
;
}
void
setInvalidTemplateEscape
(
uint32_t
offset
InvalidEscapeType
type
)
{
MOZ_ASSERT
(
type
!
=
InvalidEscapeType
:
:
None
)
;
if
(
invalidTemplateEscapeType
!
=
InvalidEscapeType
:
:
None
)
return
;
invalidTemplateEscapeOffset
=
offset
;
invalidTemplateEscapeType
=
type
;
}
uint32_t
invalidTemplateEscapeOffset
=
0
;
InvalidEscapeType
invalidTemplateEscapeType
=
InvalidEscapeType
:
:
None
;
protected
:
struct
Flags
{
bool
isEOF
:
1
;
bool
isDirtyLine
:
1
;
bool
sawOctalEscape
:
1
;
bool
hadError
:
1
;
Flags
(
)
:
isEOF
(
)
isDirtyLine
(
)
sawOctalEscape
(
)
hadError
(
)
{
}
}
;
public
:
typedef
Token
:
:
Modifier
Modifier
;
static
constexpr
Modifier
None
=
Token
:
:
None
;
static
constexpr
Modifier
Operand
=
Token
:
:
Operand
;
static
constexpr
Modifier
TemplateTail
=
Token
:
:
TemplateTail
;
typedef
Token
:
:
ModifierException
ModifierException
;
static
constexpr
ModifierException
NoException
=
Token
:
:
NoException
;
static
constexpr
ModifierException
NoneIsOperand
=
Token
:
:
NoneIsOperand
;
static
constexpr
ModifierException
OperandIsNone
=
Token
:
:
OperandIsNone
;
void
addModifierException
(
ModifierException
modifierException
)
{
#
ifdef
DEBUG
const
Token
&
next
=
nextToken
(
)
;
if
(
next
.
modifierException
=
=
NoneIsOperand
)
{
MOZ_ASSERT
(
modifierException
=
=
OperandIsNone
)
;
MOZ_ASSERT
(
next
.
type
!
=
TOK_DIV
"
next
token
requires
contextual
specifier
to
be
parsed
unambiguously
"
)
;
return
;
}
MOZ_ASSERT
(
next
.
modifierException
=
=
NoException
)
;
switch
(
modifierException
)
{
case
NoneIsOperand
:
MOZ_ASSERT
(
next
.
modifier
=
=
Operand
)
;
MOZ_ASSERT
(
next
.
type
!
=
TOK_DIV
"
next
token
requires
contextual
specifier
to
be
parsed
unambiguously
"
)
;
break
;
case
OperandIsNone
:
MOZ_ASSERT
(
next
.
modifier
=
=
None
)
;
MOZ_ASSERT
(
next
.
type
!
=
TOK_DIV
&
&
next
.
type
!
=
TOK_REGEXP
"
next
token
requires
contextual
specifier
to
be
parsed
unambiguously
"
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
modifier
exception
"
)
;
}
tokens
[
(
cursor
+
1
)
&
ntokensMask
]
.
modifierException
=
modifierException
;
#
endif
}
void
verifyConsistentModifier
(
Modifier
modifier
Token
lookaheadToken
)
{
#
ifdef
DEBUG
if
(
modifier
=
=
lookaheadToken
.
modifier
)
return
;
if
(
lookaheadToken
.
modifierException
=
=
OperandIsNone
)
{
if
(
modifier
=
=
Operand
&
&
lookaheadToken
.
modifier
=
=
None
)
return
;
}
if
(
lookaheadToken
.
modifierException
=
=
NoneIsOperand
)
{
if
(
modifier
=
=
None
&
&
lookaheadToken
.
modifier
=
=
Operand
)
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
this
token
was
previously
looked
up
with
a
"
"
different
modifier
potentially
making
"
"
tokenization
non
-
deterministic
"
)
;
#
endif
}
#
ifdef
DEBUG
inline
bool
debugHasNoLookahead
(
)
const
{
return
lookahead
=
=
0
;
}
#
endif
bool
hasDisplayURL
(
)
const
{
return
displayURL_
!
=
nullptr
;
}
char16_t
*
displayURL
(
)
{
return
displayURL_
.
get
(
)
;
}
bool
hasSourceMapURL
(
)
const
{
return
sourceMapURL_
!
=
nullptr
;
}
char16_t
*
sourceMapURL
(
)
{
return
sourceMapURL_
.
get
(
)
;
}
class
SourceCoords
{
Vector
<
uint32_t
128
>
lineStartOffsets_
;
uint32_t
initialLineNum_
;
uint32_t
initialColumn_
;
mutable
uint32_t
lastLineIndex_
;
uint32_t
lineIndexOf
(
uint32_t
offset
)
const
;
static
const
uint32_t
MAX_PTR
=
UINT32_MAX
;
uint32_t
lineIndexToNum
(
uint32_t
lineIndex
)
const
{
return
lineIndex
+
initialLineNum_
;
}
uint32_t
lineNumToIndex
(
uint32_t
lineNum
)
const
{
return
lineNum
-
initialLineNum_
;
}
uint32_t
lineIndexAndOffsetToColumn
(
uint32_t
lineIndex
uint32_t
offset
)
const
{
uint32_t
lineStartOffset
=
lineStartOffsets_
[
lineIndex
]
;
MOZ_RELEASE_ASSERT
(
offset
>
=
lineStartOffset
)
;
uint32_t
column
=
offset
-
lineStartOffset
;
if
(
lineIndex
=
=
0
)
return
column
+
initialColumn_
;
return
column
;
}
public
:
SourceCoords
(
JSContext
*
cx
uint32_t
ln
uint32_t
col
uint32_t
initialLineOffset
)
;
MOZ_MUST_USE
bool
add
(
uint32_t
lineNum
uint32_t
lineStartOffset
)
;
MOZ_MUST_USE
bool
fill
(
const
SourceCoords
&
other
)
;
bool
isOnThisLine
(
uint32_t
offset
uint32_t
lineNum
bool
*
onThisLine
)
const
{
uint32_t
lineIndex
=
lineNumToIndex
(
lineNum
)
;
if
(
lineIndex
+
1
>
=
lineStartOffsets_
.
length
(
)
)
return
false
;
*
onThisLine
=
lineStartOffsets_
[
lineIndex
]
<
=
offset
&
&
offset
<
lineStartOffsets_
[
lineIndex
+
1
]
;
return
true
;
}
uint32_t
lineNum
(
uint32_t
offset
)
const
;
uint32_t
columnIndex
(
uint32_t
offset
)
const
;
void
lineNumAndColumnIndex
(
uint32_t
offset
uint32_t
*
lineNum
uint32_t
*
column
)
const
;
}
;
SourceCoords
srcCoords
;
JSAtomState
&
names
(
)
const
{
return
cx
-
>
names
(
)
;
}
JSContext
*
context
(
)
const
{
return
cx
;
}
const
ReadOnlyCompileOptions
&
options
(
)
const
{
return
options_
;
}
bool
fillExcludingContext
(
ErrorMetadata
*
err
uint32_t
offset
)
;
void
updateFlagsForEOL
(
)
;
const
Token
&
nextToken
(
)
const
{
MOZ_ASSERT
(
hasLookahead
(
)
)
;
return
tokens
[
(
cursor
+
1
)
&
ntokensMask
]
;
}
bool
hasLookahead
(
)
const
{
return
lookahead
>
0
;
}
public
:
MOZ_MUST_USE
bool
compileWarning
(
ErrorMetadata
&
&
metadata
UniquePtr
<
JSErrorNotes
>
notes
unsigned
flags
unsigned
errorNumber
va_list
args
)
;
void
reportErrorNoOffset
(
unsigned
errorNumber
.
.
.
)
;
void
computeErrorMetadataNoOffset
(
ErrorMetadata
*
err
)
;
protected
:
const
ReadOnlyCompileOptions
&
options_
;
Token
tokens
[
ntokens
]
;
unsigned
cursor
;
unsigned
lookahead
;
unsigned
lineno
;
Flags
flags
;
size_t
linebase
;
size_t
prevLinebase
;
const
char
*
filename
;
UniqueTwoByteChars
displayURL_
;
UniqueTwoByteChars
sourceMapURL_
;
uint8_t
isExprEnding
[
TOK_LIMIT
]
;
JSContext
*
const
cx
;
bool
mutedErrors
;
StrictModeGetter
*
strictModeGetter
;
}
;
class
MOZ_STACK_CLASS
TokenStream
final
:
public
TokenStreamAnyChars
{
public
:
using
CharT
=
char16_t
;
using
CharBuffer
=
Vector
<
CharT
32
>
;
TokenStream
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
CharT
*
base
size_t
length
StrictModeGetter
*
smg
)
;
const
CharBuffer
&
getTokenbuf
(
)
const
{
return
tokenbuf
;
}
bool
checkForInvalidTemplateEscapeError
(
)
{
if
(
invalidTemplateEscapeType
=
=
InvalidEscapeType
:
:
None
)
return
true
;
reportInvalidEscapeError
(
invalidTemplateEscapeOffset
invalidTemplateEscapeType
)
;
return
false
;
}
void
reportError
(
unsigned
errorNumber
.
.
.
)
;
void
error
(
unsigned
errorNumber
.
.
.
)
;
void
errorAt
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
;
MOZ_MUST_USE
bool
warning
(
unsigned
errorNumber
.
.
.
)
;
private
:
MOZ_MUST_USE
bool
computeLineOfContext
(
ErrorMetadata
*
err
uint32_t
offset
)
;
public
:
MOZ_MUST_USE
bool
computeErrorMetadata
(
ErrorMetadata
*
err
uint32_t
offset
)
;
bool
reportStrictModeErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
bool
strictMode
unsigned
errorNumber
va_list
args
)
;
bool
reportExtraWarningErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
unsigned
errorNumber
va_list
args
)
;
JSAtom
*
getRawTemplateStringAtom
(
)
{
MOZ_ASSERT
(
currentToken
(
)
.
type
=
=
TOK_TEMPLATE_HEAD
|
|
currentToken
(
)
.
type
=
=
TOK_NO_SUBS_TEMPLATE
)
;
const
CharT
*
cur
=
userbuf
.
rawCharPtrAt
(
currentToken
(
)
.
pos
.
begin
+
1
)
;
const
CharT
*
end
;
if
(
currentToken
(
)
.
type
=
=
TOK_TEMPLATE_HEAD
)
{
end
=
userbuf
.
rawCharPtrAt
(
currentToken
(
)
.
pos
.
end
-
2
)
;
}
else
{
end
=
userbuf
.
rawCharPtrAt
(
currentToken
(
)
.
pos
.
end
-
1
)
;
}
CharBuffer
charbuf
(
cx
)
;
while
(
cur
<
end
)
{
CharT
ch
=
*
cur
;
if
(
ch
=
=
'
\
r
'
)
{
ch
=
'
\
n
'
;
if
(
(
cur
+
1
<
end
)
&
&
(
*
(
cur
+
1
)
=
=
'
\
n
'
)
)
cur
+
+
;
}
if
(
!
charbuf
.
append
(
ch
)
)
return
nullptr
;
cur
+
+
;
}
return
AtomizeChars
(
cx
charbuf
.
begin
(
)
charbuf
.
length
(
)
)
;
}
private
:
bool
reportStrictModeError
(
unsigned
errorNumber
.
.
.
)
;
void
reportInvalidEscapeError
(
uint32_t
offset
InvalidEscapeType
type
)
{
switch
(
type
)
{
case
InvalidEscapeType
:
:
None
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
InvalidEscapeType
"
)
;
return
;
case
InvalidEscapeType
:
:
Hexadecimal
:
errorAt
(
offset
JSMSG_MALFORMED_ESCAPE
"
hexadecimal
"
)
;
return
;
case
InvalidEscapeType
:
:
Unicode
:
errorAt
(
offset
JSMSG_MALFORMED_ESCAPE
"
Unicode
"
)
;
return
;
case
InvalidEscapeType
:
:
UnicodeOverflow
:
errorAt
(
offset
JSMSG_UNICODE_OVERFLOW
"
escape
sequence
"
)
;
return
;
case
InvalidEscapeType
:
:
Octal
:
errorAt
(
offset
JSMSG_DEPRECATED_OCTAL
)
;
return
;
}
}
static
JSAtom
*
atomize
(
JSContext
*
cx
CharBuffer
&
cb
)
;
MOZ_MUST_USE
bool
putIdentInTokenbuf
(
const
CharT
*
identStart
)
;
public
:
MOZ_MUST_USE
bool
getToken
(
TokenKind
*
ttp
Modifier
modifier
=
None
)
{
if
(
lookahead
!
=
0
)
{
MOZ_ASSERT
(
!
flags
.
hadError
)
;
lookahead
-
-
;
cursor
=
(
cursor
+
1
)
&
ntokensMask
;
TokenKind
tt
=
currentToken
(
)
.
type
;
MOZ_ASSERT
(
tt
!
=
TOK_EOL
)
;
verifyConsistentModifier
(
modifier
currentToken
(
)
)
;
*
ttp
=
tt
;
return
true
;
}
return
getTokenInternal
(
ttp
modifier
)
;
}
void
ungetToken
(
)
{
MOZ_ASSERT
(
lookahead
<
maxLookahead
)
;
lookahead
+
+
;
cursor
=
(
cursor
-
1
)
&
ntokensMask
;
}
MOZ_MUST_USE
bool
peekToken
(
TokenKind
*
ttp
Modifier
modifier
=
None
)
{
if
(
lookahead
>
0
)
{
MOZ_ASSERT
(
!
flags
.
hadError
)
;
verifyConsistentModifier
(
modifier
nextToken
(
)
)
;
*
ttp
=
nextToken
(
)
.
type
;
return
true
;
}
if
(
!
getTokenInternal
(
ttp
modifier
)
)
return
false
;
ungetToken
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
peekTokenPos
(
TokenPos
*
posp
Modifier
modifier
=
None
)
{
if
(
lookahead
=
=
0
)
{
TokenKind
tt
;
if
(
!
getTokenInternal
(
&
tt
modifier
)
)
return
false
;
ungetToken
(
)
;
MOZ_ASSERT
(
hasLookahead
(
)
)
;
}
else
{
MOZ_ASSERT
(
!
flags
.
hadError
)
;
verifyConsistentModifier
(
modifier
nextToken
(
)
)
;
}
*
posp
=
nextToken
(
)
.
pos
;
return
true
;
}
MOZ_MUST_USE
bool
peekOffset
(
uint32_t
*
offset
Modifier
modifier
=
None
)
{
TokenPos
pos
;
if
(
!
peekTokenPos
(
&
pos
modifier
)
)
return
false
;
*
offset
=
pos
.
begin
;
return
true
;
}
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
bool
peekTokenSameLine
(
TokenKind
*
ttp
Modifier
modifier
=
None
)
{
const
Token
&
curr
=
currentToken
(
)
;
if
(
lookahead
!
=
0
)
{
bool
onThisLine
;
if
(
!
srcCoords
.
isOnThisLine
(
curr
.
pos
.
end
lineno
&
onThisLine
)
)
{
reportError
(
JSMSG_OUT_OF_MEMORY
)
;
return
false
;
}
if
(
onThisLine
)
{
MOZ_ASSERT
(
!
flags
.
hadError
)
;
verifyConsistentModifier
(
modifier
nextToken
(
)
)
;
*
ttp
=
nextToken
(
)
.
type
;
return
true
;
}
}
TokenKind
tmp
;
if
(
!
getToken
(
&
tmp
modifier
)
)
return
false
;
const
Token
&
next
=
currentToken
(
)
;
ungetToken
(
)
;
*
ttp
=
srcCoords
.
lineNum
(
curr
.
pos
.
end
)
=
=
srcCoords
.
lineNum
(
next
.
pos
.
begin
)
?
next
.
type
:
TOK_EOL
;
return
true
;
}
MOZ_MUST_USE
bool
matchToken
(
bool
*
matchedp
TokenKind
tt
Modifier
modifier
=
None
)
{
TokenKind
token
;
if
(
!
getToken
(
&
token
modifier
)
)
return
false
;
if
(
token
=
=
tt
)
{
*
matchedp
=
true
;
}
else
{
ungetToken
(
)
;
*
matchedp
=
false
;
}
return
true
;
}
void
consumeKnownToken
(
TokenKind
tt
Modifier
modifier
=
None
)
{
bool
matched
;
MOZ_ASSERT
(
hasLookahead
(
)
)
;
MOZ_ALWAYS_TRUE
(
matchToken
(
&
matched
tt
modifier
)
)
;
MOZ_ALWAYS_TRUE
(
matched
)
;
}
MOZ_MUST_USE
bool
nextTokenEndsExpr
(
bool
*
endsExpr
)
{
TokenKind
tt
;
if
(
!
peekToken
(
&
tt
)
)
return
false
;
*
endsExpr
=
isExprEnding
[
tt
]
;
return
true
;
}
class
MOZ_STACK_CLASS
Position
{
public
:
explicit
Position
(
AutoKeepAtoms
&
)
{
}
private
:
Position
(
const
Position
&
)
=
delete
;
friend
class
TokenStream
;
const
CharT
*
buf
;
Flags
flags
;
unsigned
lineno
;
size_t
linebase
;
size_t
prevLinebase
;
Token
currentToken
;
unsigned
lookahead
;
Token
lookaheadTokens
[
maxLookahead
]
;
}
;
MOZ_MUST_USE
bool
advance
(
size_t
position
)
;
void
tell
(
Position
*
)
;
void
seek
(
const
Position
&
pos
)
;
MOZ_MUST_USE
bool
seek
(
const
Position
&
pos
const
TokenStream
&
other
)
;
const
CharT
*
rawCharPtrAt
(
size_t
offset
)
const
{
return
userbuf
.
rawCharPtrAt
(
offset
)
;
}
const
CharT
*
rawLimit
(
)
const
{
return
userbuf
.
limit
(
)
;
}
private
:
class
TokenBuf
{
public
:
TokenBuf
(
JSContext
*
cx
const
CharT
*
buf
size_t
length
size_t
startOffset
)
:
base_
(
buf
)
startOffset_
(
startOffset
)
limit_
(
buf
+
length
)
ptr
(
buf
)
{
}
bool
hasRawChars
(
)
const
{
return
ptr
<
limit_
;
}
bool
atStart
(
)
const
{
return
offset
(
)
=
=
0
;
}
size_t
startOffset
(
)
const
{
return
startOffset_
;
}
size_t
offset
(
)
const
{
return
startOffset_
+
mozilla
:
:
PointerRangeSize
(
base_
ptr
)
;
}
const
CharT
*
rawCharPtrAt
(
size_t
offset
)
const
{
MOZ_ASSERT
(
startOffset_
<
=
offset
)
;
MOZ_ASSERT
(
offset
-
startOffset_
<
=
mozilla
:
:
PointerRangeSize
(
base_
limit_
)
)
;
return
base_
+
(
offset
-
startOffset_
)
;
}
const
CharT
*
limit
(
)
const
{
return
limit_
;
}
CharT
getRawChar
(
)
{
return
*
ptr
+
+
;
}
CharT
peekRawChar
(
)
const
{
return
*
ptr
;
}
bool
matchRawChar
(
CharT
c
)
{
if
(
*
ptr
=
=
c
)
{
ptr
+
+
;
return
true
;
}
return
false
;
}
bool
matchRawCharBackwards
(
CharT
c
)
{
MOZ_ASSERT
(
ptr
)
;
if
(
*
(
ptr
-
1
)
=
=
c
)
{
ptr
-
-
;
return
true
;
}
return
false
;
}
void
ungetRawChar
(
)
{
MOZ_ASSERT
(
ptr
)
;
ptr
-
-
;
}
const
CharT
*
addressOfNextRawChar
(
bool
allowPoisoned
=
false
)
const
{
MOZ_ASSERT_IF
(
!
allowPoisoned
ptr
)
;
return
ptr
;
}
void
setAddressOfNextRawChar
(
const
CharT
*
a
bool
allowPoisoned
=
false
)
{
MOZ_ASSERT_IF
(
!
allowPoisoned
a
)
;
ptr
=
a
;
}
#
ifdef
DEBUG
void
poison
(
)
{
ptr
=
nullptr
;
}
#
endif
static
bool
isRawEOLChar
(
int32_t
c
)
{
return
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
|
|
c
=
=
unicode
:
:
LINE_SEPARATOR
|
|
c
=
=
unicode
:
:
PARA_SEPARATOR
;
}
size_t
findEOLMax
(
size_t
start
size_t
max
)
;
private
:
const
CharT
*
base_
;
uint32_t
startOffset_
;
const
CharT
*
limit_
;
const
CharT
*
ptr
;
}
;
MOZ_MUST_USE
bool
getTokenInternal
(
TokenKind
*
ttp
Modifier
modifier
)
;
MOZ_MUST_USE
bool
getStringOrTemplateToken
(
int
untilChar
Token
*
*
tp
)
;
MOZ_MUST_USE
bool
getChar
(
int32_t
*
cp
)
;
int32_t
getCharIgnoreEOL
(
)
;
void
ungetChar
(
int32_t
c
)
;
void
ungetCharIgnoreEOL
(
int32_t
c
)
;
Token
*
newToken
(
ptrdiff_t
adjust
)
;
uint32_t
peekUnicodeEscape
(
uint32_t
*
codePoint
)
;
uint32_t
peekExtendedUnicodeEscape
(
uint32_t
*
codePoint
)
;
uint32_t
matchUnicodeEscapeIdStart
(
uint32_t
*
codePoint
)
;
bool
matchUnicodeEscapeIdent
(
uint32_t
*
codePoint
)
;
bool
matchTrailForLeadSurrogate
(
char16_t
lead
char16_t
*
trail
uint32_t
*
codePoint
)
;
bool
peekChars
(
int
n
CharT
*
cp
)
;
MOZ_MUST_USE
bool
getDirectives
(
bool
isMultiline
bool
shouldWarnDeprecated
)
;
MOZ_MUST_USE
bool
getDirective
(
bool
isMultiline
bool
shouldWarnDeprecated
const
char
*
directive
uint8_t
directiveLength
const
char
*
errorMsgPragma
UniquePtr
<
CharT
[
]
JS
:
:
FreePolicy
>
*
destination
)
;
MOZ_MUST_USE
bool
getDisplayURL
(
bool
isMultiline
bool
shouldWarnDeprecated
)
;
MOZ_MUST_USE
bool
getSourceMappingURL
(
bool
isMultiline
bool
shouldWarnDeprecated
)
;
bool
matchChar
(
int32_t
expect
)
{
MOZ_ASSERT
(
!
TokenBuf
:
:
isRawEOLChar
(
expect
)
)
;
return
MOZ_LIKELY
(
userbuf
.
hasRawChars
(
)
)
&
&
userbuf
.
matchRawChar
(
expect
)
;
}
void
consumeKnownChar
(
int32_t
expect
)
{
int32_t
c
;
MOZ_ALWAYS_TRUE
(
getChar
(
&
c
)
)
;
MOZ_ASSERT
(
c
=
=
expect
)
;
}
MOZ_MUST_USE
bool
peekChar
(
int32_t
*
c
)
{
if
(
!
getChar
(
c
)
)
return
false
;
ungetChar
(
*
c
)
;
return
true
;
}
void
skipChars
(
uint32_t
n
)
{
while
(
n
-
-
>
0
)
{
MOZ_ASSERT
(
userbuf
.
hasRawChars
(
)
)
;
mozilla
:
:
DebugOnly
<
int32_t
>
c
=
getCharIgnoreEOL
(
)
;
MOZ_ASSERT
(
c
!
=
'
\
n
'
)
;
}
}
void
skipCharsIgnoreEOL
(
uint8_t
n
)
{
while
(
n
-
-
>
0
)
{
MOZ_ASSERT
(
userbuf
.
hasRawChars
(
)
)
;
getCharIgnoreEOL
(
)
;
}
}
MOZ_MUST_USE
MOZ_ALWAYS_INLINE
bool
updateLineInfoForEOL
(
)
;
TokenBuf
userbuf
;
CharBuffer
tokenbuf
;
}
;
extern
const
char
*
TokenKindToDesc
(
TokenKind
tt
)
;
}
}
extern
JS_FRIEND_API
(
int
)
js_fgets
(
char
*
buf
int
size
FILE
*
file
)
;
#
ifdef
DEBUG
extern
const
char
*
TokenKindToString
(
js
:
:
frontend
:
:
TokenKind
tt
)
;
#
endif
#
endif
