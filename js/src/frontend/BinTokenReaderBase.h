#
ifndef
frontend_BinTokenReaderBase_h
#
define
frontend_BinTokenReaderBase_h
#
include
"
frontend
/
BinToken
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
frontend
{
extern
const
uint64_t
NULL_FLOAT_REPRESENTATION
;
class
MOZ_STACK_CLASS
BinTokenReaderBase
{
public
:
template
<
typename
T
>
using
ErrorResult
=
mozilla
:
:
GenericErrorResult
<
T
>
;
class
SkippableSubTree
{
public
:
SkippableSubTree
(
const
uint8_t
*
start
const
size_t
length
)
:
start_
(
start
)
length_
(
length
)
{
}
const
uint8_t
*
start
(
)
const
{
return
start_
;
}
size_t
length
(
)
const
{
return
length_
;
}
private
:
const
uint8_t
*
start_
;
const
size_t
length_
;
}
;
TokenPos
pos
(
)
;
TokenPos
pos
(
size_t
startOffset
)
;
size_t
offset
(
)
const
;
void
poison
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseError
(
const
char
*
description
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseOOM
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidNumberOfFields
(
const
BinKind
kind
const
uint32_t
expected
const
uint32_t
got
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidField
(
const
char
*
kind
const
BinField
field
)
;
protected
:
BinTokenReaderBase
(
JSContext
*
cx
const
uint8_t
*
start
const
size_t
length
)
:
cx_
(
cx
)
poisoned_
(
false
)
start_
(
start
)
current_
(
start
)
stop_
(
start
+
length
)
latestKnownGoodPos_
(
0
)
{
}
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
len
)
;
template
<
size_t
N
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readConst
(
const
char
(
&
value
)
[
N
]
)
{
updateLatestKnownGood
(
)
;
if
(
!
matchConst
(
value
false
)
)
return
raiseError
(
"
Could
not
find
expected
literal
"
)
;
return
Ok
(
)
;
}
template
<
size_t
N
>
MOZ_MUST_USE
bool
matchConst
(
const
char
(
&
value
)
[
N
]
bool
expectNul
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
value
[
N
-
1
]
=
=
0
)
;
MOZ_ASSERT
(
!
cx_
-
>
isExceptionPending
(
)
)
;
if
(
current_
+
N
-
1
>
stop_
)
return
false
;
if
(
!
std
:
:
equal
(
current_
current_
+
N
+
(
expectNul
?
0
:
-
1
)
value
)
)
return
false
;
current_
+
=
N
+
(
expectNul
?
0
:
-
1
)
;
updateLatestKnownGood
(
)
;
return
true
;
}
void
updateLatestKnownGood
(
)
;
JSContext
*
cx_
;
bool
poisoned_
;
const
uint8_t
*
start_
;
const
uint8_t
*
current_
;
const
uint8_t
*
stop_
;
size_t
latestKnownGoodPos_
;
private
:
BinTokenReaderBase
(
const
BinTokenReaderBase
&
)
=
delete
;
BinTokenReaderBase
(
BinTokenReaderBase
&
&
)
=
delete
;
BinTokenReaderBase
&
operator
=
(
BinTokenReaderBase
&
)
=
delete
;
}
;
}
}
#
endif
