#
ifndef
frontend_ParserAtom_h
#
define
frontend_ParserAtom_h
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
CommonPropertyNames
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
namespace
frontend
{
struct
CompilationAtomCache
;
struct
CompilationStencil
;
class
ParserAtom
;
template
<
typename
CharT
>
class
SpecificParserAtomLookup
;
class
ParserAtomsTable
;
enum
class
WellKnownAtomId
:
uint32_t
{
#
define
ENUM_ENTRY_
(
_
NAME
_2
)
NAME
FOR_EACH_COMMON_PROPERTYNAME
(
ENUM_ENTRY_
)
#
undef
ENUM_ENTRY_
#
define
ENUM_ENTRY_
(
NAME
_
)
NAME
JS_FOR_EACH_PROTOTYPE
(
ENUM_ENTRY_
)
#
undef
ENUM_ENTRY_
Limit
}
;
enum
class
StaticParserString1
:
uint8_t
;
enum
class
StaticParserString2
:
uint16_t
;
class
ParserAtom
;
using
ParserAtomIndex
=
TypedIndex
<
ParserAtom
>
;
class
TaggedParserAtomIndex
{
uint32_t
data_
;
public
:
static
constexpr
size_t
IndexBit
=
28
;
static
constexpr
size_t
IndexMask
=
BitMask
(
IndexBit
)
;
static
constexpr
size_t
TagShift
=
IndexBit
;
static
constexpr
size_t
TagBit
=
4
;
static
constexpr
size_t
TagMask
=
BitMask
(
TagBit
)
<
<
TagShift
;
enum
class
Kind
:
uint32_t
{
Null
=
0
ParserAtomIndex
WellKnown
}
;
private
:
static
constexpr
size_t
SmallIndexBit
=
16
;
static
constexpr
size_t
SmallIndexMask
=
BitMask
(
SmallIndexBit
)
;
static
constexpr
size_t
SubTagShift
=
SmallIndexBit
;
static
constexpr
size_t
SubTagBit
=
2
;
static
constexpr
size_t
SubTagMask
=
BitMask
(
SubTagBit
)
<
<
SubTagShift
;
public
:
static
constexpr
uint32_t
NullTag
=
uint32_t
(
Kind
:
:
Null
)
<
<
TagShift
;
static
constexpr
uint32_t
ParserAtomIndexTag
=
uint32_t
(
Kind
:
:
ParserAtomIndex
)
<
<
TagShift
;
static
constexpr
uint32_t
WellKnownTag
=
uint32_t
(
Kind
:
:
WellKnown
)
<
<
TagShift
;
private
:
static
constexpr
uint32_t
WellKnownSubTag
=
0
<
<
SubTagShift
;
static
constexpr
uint32_t
Static1SubTag
=
1
<
<
SubTagShift
;
static
constexpr
uint32_t
Static2SubTag
=
2
<
<
SubTagShift
;
public
:
static
constexpr
uint32_t
IndexLimit
=
Bit
(
IndexBit
)
;
static
constexpr
uint32_t
SmallIndexLimit
=
Bit
(
SmallIndexBit
)
;
private
:
explicit
TaggedParserAtomIndex
(
uint32_t
data
)
:
data_
(
data
)
{
}
public
:
constexpr
TaggedParserAtomIndex
(
)
:
data_
(
NullTag
)
{
}
explicit
constexpr
TaggedParserAtomIndex
(
ParserAtomIndex
index
)
:
data_
(
index
.
index
|
ParserAtomIndexTag
)
{
MOZ_ASSERT
(
index
.
index
<
IndexLimit
)
;
}
explicit
constexpr
TaggedParserAtomIndex
(
WellKnownAtomId
index
)
:
data_
(
uint32_t
(
index
)
|
WellKnownTag
|
WellKnownSubTag
)
{
MOZ_ASSERT
(
uint32_t
(
index
)
<
SmallIndexLimit
)
;
#
define
CHECK_
(
_
NAME
_2
)
MOZ_ASSERT
(
index
!
=
WellKnownAtomId
:
:
NAME
)
;
FOR_EACH_NON_EMPTY_TINY_PROPERTYNAME
(
CHECK_
)
#
undef
CHECK_
}
explicit
constexpr
TaggedParserAtomIndex
(
StaticParserString1
index
)
:
data_
(
uint32_t
(
index
)
|
WellKnownTag
|
Static1SubTag
)
{
}
explicit
constexpr
TaggedParserAtomIndex
(
StaticParserString2
index
)
:
data_
(
uint32_t
(
index
)
|
WellKnownTag
|
Static2SubTag
)
{
}
class
WellKnown
{
public
:
#
define
METHOD_
(
_
NAME
_2
)
\
static
constexpr
TaggedParserAtomIndex
NAME
(
)
{
\
return
TaggedParserAtomIndex
(
WellKnownAtomId
:
:
NAME
)
;
\
}
FOR_EACH_NONTINY_COMMON_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
NAME
_
)
\
static
constexpr
TaggedParserAtomIndex
NAME
(
)
{
\
return
TaggedParserAtomIndex
(
WellKnownAtomId
:
:
NAME
)
;
\
}
JS_FOR_EACH_PROTOTYPE
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
_
NAME
STR
)
\
static
constexpr
TaggedParserAtomIndex
NAME
(
)
{
\
return
TaggedParserAtomIndex
(
StaticParserString1
(
(
STR
)
[
0
]
)
)
;
\
}
FOR_EACH_LENGTH1_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
_
NAME
STR
)
\
static
constexpr
TaggedParserAtomIndex
NAME
(
)
{
\
return
TaggedParserAtomIndex
(
StaticParserString2
(
\
(
StaticStrings
:
:
getLength2IndexStatic
(
(
STR
)
[
0
]
(
STR
)
[
1
]
)
)
)
)
;
\
}
FOR_EACH_LENGTH2_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
static
constexpr
TaggedParserAtomIndex
empty
(
)
{
return
TaggedParserAtomIndex
(
WellKnownAtomId
:
:
empty
)
;
}
}
;
class
WellKnownRawData
{
public
:
#
define
METHOD_
(
_
NAME
_2
)
\
static
constexpr
uint32_t
NAME
(
)
{
\
return
uint32_t
(
WellKnownAtomId
:
:
NAME
)
|
WellKnownTag
|
WellKnownSubTag
;
\
}
FOR_EACH_NONTINY_COMMON_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
NAME
_
)
\
static
constexpr
uint32_t
NAME
(
)
{
\
return
uint32_t
(
WellKnownAtomId
:
:
NAME
)
|
WellKnownTag
|
WellKnownSubTag
;
\
}
JS_FOR_EACH_PROTOTYPE
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
_
NAME
STR
)
\
static
constexpr
uint32_t
NAME
(
)
{
\
return
uint32_t
(
(
STR
)
[
0
]
)
|
WellKnownTag
|
Static1SubTag
;
\
}
FOR_EACH_LENGTH1_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
#
define
METHOD_
(
_
NAME
STR
)
\
static
constexpr
uint32_t
NAME
(
)
{
\
return
uint32_t
(
\
StaticStrings
:
:
getLength2IndexStatic
(
(
STR
)
[
0
]
(
STR
)
[
1
]
)
)
|
\
WellKnownTag
|
Static2SubTag
;
\
}
FOR_EACH_LENGTH2_PROPERTYNAME
(
METHOD_
)
#
undef
METHOD_
static
constexpr
uint32_t
empty
(
)
{
return
uint32_t
(
WellKnownAtomId
:
:
empty
)
|
WellKnownTag
|
WellKnownSubTag
;
}
}
;
static
TaggedParserAtomIndex
null
(
)
{
return
TaggedParserAtomIndex
(
)
;
}
#
ifdef
DEBUG
void
validateRaw
(
)
;
#
endif
static
TaggedParserAtomIndex
fromRaw
(
uint32_t
data
)
{
auto
result
=
TaggedParserAtomIndex
(
data
)
;
#
ifdef
DEBUG
result
.
validateRaw
(
)
;
#
endif
return
result
;
}
bool
isParserAtomIndex
(
)
const
{
return
(
data_
&
TagMask
)
=
=
ParserAtomIndexTag
;
}
bool
isWellKnownAtomId
(
)
const
{
return
(
data_
&
(
TagMask
|
SubTagMask
)
)
=
=
(
WellKnownTag
|
WellKnownSubTag
)
;
}
bool
isStaticParserString1
(
)
const
{
return
(
data_
&
(
TagMask
|
SubTagMask
)
)
=
=
(
WellKnownTag
|
Static1SubTag
)
;
}
bool
isStaticParserString2
(
)
const
{
return
(
data_
&
(
TagMask
|
SubTagMask
)
)
=
=
(
WellKnownTag
|
Static2SubTag
)
;
}
bool
isNull
(
)
const
{
bool
result
=
!
data_
;
MOZ_ASSERT_IF
(
result
(
data_
&
TagMask
)
=
=
NullTag
)
;
return
result
;
}
ParserAtomIndex
toParserAtomIndex
(
)
const
{
MOZ_ASSERT
(
isParserAtomIndex
(
)
)
;
return
ParserAtomIndex
(
data_
&
IndexMask
)
;
}
WellKnownAtomId
toWellKnownAtomId
(
)
const
{
MOZ_ASSERT
(
isWellKnownAtomId
(
)
)
;
return
WellKnownAtomId
(
data_
&
SmallIndexMask
)
;
}
StaticParserString1
toStaticParserString1
(
)
const
{
MOZ_ASSERT
(
isStaticParserString1
(
)
)
;
return
StaticParserString1
(
data_
&
SmallIndexMask
)
;
}
StaticParserString2
toStaticParserString2
(
)
const
{
MOZ_ASSERT
(
isStaticParserString2
(
)
)
;
return
StaticParserString2
(
data_
&
SmallIndexMask
)
;
}
uint32_t
*
rawDataRef
(
)
{
return
&
data_
;
}
uint32_t
rawData
(
)
const
{
return
data_
;
}
bool
operator
=
=
(
const
TaggedParserAtomIndex
&
rhs
)
const
{
return
data_
=
=
rhs
.
data_
;
}
bool
operator
!
=
(
const
TaggedParserAtomIndex
&
rhs
)
const
{
return
data_
!
=
rhs
.
data_
;
}
explicit
operator
bool
(
)
const
{
return
!
isNull
(
)
;
}
}
;
class
TrivialTaggedParserAtomIndex
{
uint32_t
data_
;
public
:
static
TrivialTaggedParserAtomIndex
from
(
TaggedParserAtomIndex
index
)
{
TrivialTaggedParserAtomIndex
result
;
result
.
data_
=
index
.
rawData
(
)
;
return
result
;
}
operator
TaggedParserAtomIndex
(
)
const
{
return
TaggedParserAtomIndex
:
:
fromRaw
(
data_
)
;
}
static
TrivialTaggedParserAtomIndex
null
(
)
{
TrivialTaggedParserAtomIndex
result
;
result
.
data_
=
0
;
return
result
;
}
bool
isNull
(
)
const
{
static_assert
(
TaggedParserAtomIndex
:
:
NullTag
=
=
0
)
;
return
data_
=
=
0
;
}
uint32_t
rawData
(
)
const
{
return
data_
;
}
bool
operator
=
=
(
const
TrivialTaggedParserAtomIndex
&
rhs
)
const
{
return
data_
=
=
rhs
.
data_
;
}
bool
operator
!
=
(
const
TrivialTaggedParserAtomIndex
&
rhs
)
const
{
return
data_
!
=
rhs
.
data_
;
}
explicit
operator
bool
(
)
const
{
return
!
isNull
(
)
;
}
}
;
class
alignas
(
alignof
(
uint32_t
)
)
ParserAtom
{
friend
class
ParserAtomsTable
;
friend
class
WellKnownParserAtoms
;
friend
class
WellKnownParserAtoms_ROM
;
static
const
uint16_t
MAX_LATIN1_CHAR
=
0xff
;
static
constexpr
uint32_t
HasTwoByteCharsFlag
=
1
<
<
0
;
static
constexpr
uint32_t
UsedByStencilFlag
=
1
<
<
1
;
static
constexpr
uint32_t
WellKnownOrStaticFlag
=
1
<
<
2
;
template
<
typename
CharT
typename
SeqCharT
>
static
void
drainChar16Seq
(
CharT
*
buf
InflatedChar16Sequence
<
SeqCharT
>
seq
uint32_t
length
)
{
static_assert
(
std
:
:
is_same_v
<
CharT
char16_t
>
|
|
std
:
:
is_same_v
<
CharT
Latin1Char
>
"
Invalid
target
buffer
type
.
"
)
;
CharT
*
cur
=
buf
;
while
(
seq
.
hasMore
(
)
)
{
char16_t
ch
=
seq
.
next
(
)
;
if
constexpr
(
std
:
:
is_same_v
<
CharT
Latin1Char
>
)
{
MOZ_ASSERT
(
ch
<
=
MAX_LATIN1_CHAR
)
;
}
MOZ_ASSERT
(
cur
<
(
buf
+
length
)
)
;
*
cur
=
ch
;
cur
+
+
;
}
}
private
:
HashNumber
hash_
=
0
;
uint32_t
length_
=
0
;
uint32_t
flags_
=
0
;
static
const
uint32_t
MAX_LENGTH
=
JSString
:
:
MAX_LENGTH
;
ParserAtom
(
uint32_t
length
HashNumber
hash
bool
hasTwoByteChars
)
:
hash_
(
hash
)
length_
(
length
)
flags_
(
hasTwoByteChars
?
HasTwoByteCharsFlag
:
0
)
{
}
public
:
constexpr
ParserAtom
(
)
=
default
;
ParserAtom
(
const
ParserAtom
&
)
=
delete
;
ParserAtom
(
ParserAtom
&
&
other
)
=
delete
;
template
<
typename
CharT
typename
SeqCharT
>
static
ParserAtom
*
allocate
(
JSContext
*
cx
LifoAlloc
&
alloc
InflatedChar16Sequence
<
SeqCharT
>
seq
uint32_t
length
HashNumber
hash
)
;
static
ParserAtom
*
allocateRaw
(
JSContext
*
cx
LifoAlloc
&
alloc
const
uint8_t
*
srcRaw
size_t
totalLength
)
;
bool
hasLatin1Chars
(
)
const
{
return
!
(
flags_
&
HasTwoByteCharsFlag
)
;
}
bool
hasTwoByteChars
(
)
const
{
return
flags_
&
HasTwoByteCharsFlag
;
}
template
<
typename
CharT
>
const
CharT
*
chars
(
)
const
{
MOZ_ASSERT
(
sizeof
(
CharT
)
=
=
(
hasTwoByteChars
(
)
?
2
:
1
)
)
;
return
reinterpret_cast
<
const
CharT
*
>
(
this
+
1
)
;
}
template
<
typename
CharT
>
CharT
*
chars
(
)
{
MOZ_ASSERT
(
sizeof
(
CharT
)
=
=
(
hasTwoByteChars
(
)
?
2
:
1
)
)
;
return
reinterpret_cast
<
CharT
*
>
(
this
+
1
)
;
}
const
Latin1Char
*
latin1Chars
(
)
const
{
return
chars
<
Latin1Char
>
(
)
;
}
const
char16_t
*
twoByteChars
(
)
const
{
return
chars
<
char16_t
>
(
)
;
}
mozilla
:
:
Range
<
const
Latin1Char
>
latin1Range
(
)
const
{
return
mozilla
:
:
Range
(
latin1Chars
(
)
length_
)
;
}
mozilla
:
:
Range
<
const
char16_t
>
twoByteRange
(
)
const
{
return
mozilla
:
:
Range
(
twoByteChars
(
)
length_
)
;
}
private
:
bool
isIndex
(
uint32_t
*
indexp
)
const
;
bool
isPrivateName
(
)
const
;
public
:
bool
isAscii
(
)
const
{
if
(
hasTwoByteChars
(
)
)
{
return
false
;
}
for
(
Latin1Char
ch
:
latin1Range
(
)
)
{
if
(
!
mozilla
:
:
IsAscii
(
ch
)
)
{
return
false
;
}
}
return
true
;
}
HashNumber
hash
(
)
const
{
return
hash_
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
bool
isUsedByStencil
(
)
const
{
return
flags_
&
UsedByStencilFlag
;
}
void
markUsedByStencil
(
)
const
{
if
(
!
isWellKnownOrStatic
(
)
)
{
const_cast
<
ParserAtom
*
>
(
this
)
-
>
flags_
|
=
UsedByStencilFlag
;
}
}
bool
equalsJSAtom
(
JSAtom
*
other
)
const
;
template
<
typename
CharT
>
bool
equalsSeq
(
HashNumber
hash
InflatedChar16Sequence
<
CharT
>
seq
)
const
;
private
:
bool
isWellKnownOrStatic
(
)
const
{
return
flags_
&
WellKnownOrStaticFlag
;
}
constexpr
void
setWellKnownOrStatic
(
)
{
flags_
|
=
WellKnownOrStaticFlag
;
}
constexpr
void
setHashAndLength
(
HashNumber
hash
uint32_t
length
)
{
hash_
=
hash
;
length_
=
length
;
}
public
:
JSAtom
*
toJSAtom
(
JSContext
*
cx
TaggedParserAtomIndex
index
CompilationAtomCache
&
atomCache
)
const
;
JSAtom
*
instantiate
(
JSContext
*
cx
TaggedParserAtomIndex
index
CompilationAtomCache
&
atomCache
)
const
;
private
:
bool
toNumber
(
JSContext
*
cx
double
*
result
)
const
;
public
:
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dumpCharsNoQuote
(
js
:
:
GenericPrinter
&
out
)
const
;
#
endif
}
;
UniqueChars
ParserAtomToPrintableString
(
JSContext
*
cx
ParserAtomsTable
&
parserAtoms
TaggedParserAtomIndex
atomIndex
)
;
template
<
size_t
Length
>
class
StaticParserAtom
:
public
ParserAtom
{
alignas
(
alignof
(
ParserAtom
)
)
char
storage_
[
Length
]
=
{
}
;
public
:
constexpr
StaticParserAtom
(
)
=
default
;
constexpr
char
*
storage
(
)
{
static_assert
(
offsetof
(
StaticParserAtom
storage_
)
=
=
sizeof
(
ParserAtom
)
"
StaticParserAtom
storage
should
follow
ParserAtom
"
)
;
return
storage_
;
}
}
;
template
<
>
class
StaticParserAtom
<
0
>
:
public
ParserAtom
{
public
:
constexpr
StaticParserAtom
(
)
=
default
;
}
;
class
ParserAtomLookup
{
protected
:
HashNumber
hash_
;
ParserAtomLookup
(
HashNumber
hash
)
:
hash_
(
hash
)
{
}
public
:
HashNumber
hash
(
)
const
{
return
hash_
;
}
virtual
bool
equalsEntry
(
const
ParserAtom
*
entry
)
const
=
0
;
}
;
struct
ParserAtomLookupHasher
{
using
Lookup
=
ParserAtomLookup
;
static
inline
HashNumber
hash
(
const
Lookup
&
l
)
{
return
l
.
hash
(
)
;
}
static
inline
bool
match
(
const
ParserAtom
*
entry
const
Lookup
&
l
)
{
return
l
.
equalsEntry
(
entry
)
;
}
}
;
class
WellKnownParserAtoms_ROM
{
using
CharTraits
=
std
:
:
char_traits
<
char
>
;
using
Char16Traits
=
std
:
:
char_traits
<
char16_t
>
;
public
:
static
constexpr
size_t
ASCII_STATIC_LIMIT
=
128U
;
static
constexpr
size_t
NUM_LENGTH2_ENTRIES
=
StaticStrings
:
:
NUM_LENGTH2_ENTRIES
;
StaticParserAtom
<
0
>
emptyAtom
;
StaticParserAtom
<
1
>
length1Table
[
ASCII_STATIC_LIMIT
]
;
StaticParserAtom
<
2
>
length2Table
[
NUM_LENGTH2_ENTRIES
]
;
#
define
PROPERTYNAME_FIELD_
(
_
NAME
TEXT
)
\
StaticParserAtom
<
CharTraits
:
:
length
(
TEXT
)
>
NAME
;
FOR_EACH_NONTINY_COMMON_PROPERTYNAME
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
#
define
PROPERTYNAME_FIELD_
(
NAME
_
)
\
StaticParserAtom
<
CharTraits
:
:
length
(
#
NAME
)
>
NAME
;
JS_FOR_EACH_PROTOTYPE
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
public
:
constexpr
WellKnownParserAtoms_ROM
(
)
{
emptyAtom
.
setHashAndLength
(
mozilla
:
:
HashString
(
u
"
"
)
0
)
;
emptyAtom
.
setWellKnownOrStatic
(
)
;
for
(
size_t
i
=
0
;
i
<
ASCII_STATIC_LIMIT
;
+
+
i
)
{
init
(
length1Table
[
i
]
i
)
;
}
for
(
size_t
i
=
0
;
i
<
NUM_LENGTH2_ENTRIES
;
+
+
i
)
{
init
(
length2Table
[
i
]
i
)
;
}
#
define
PROPERTYNAME_FIELD_
(
_
NAME
TEXT
)
\
init
(
NAME
NAME
.
storage
(
)
u
"
"
TEXT
WellKnownAtomId
:
:
NAME
)
;
FOR_EACH_NONTINY_COMMON_PROPERTYNAME
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
#
define
PROPERTYNAME_FIELD_
(
NAME
_
)
\
init
(
NAME
NAME
.
storage
(
)
u
"
"
#
NAME
WellKnownAtomId
:
:
NAME
)
;
JS_FOR_EACH_PROTOTYPE
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
}
private
:
static
constexpr
void
init
(
StaticParserAtom
<
1
>
&
entry
size_t
i
)
{
size_t
len
=
1
;
char16_t
buf
[
]
=
{
static_cast
<
char16_t
>
(
i
)
0
}
;
entry
.
setHashAndLength
(
mozilla
:
:
HashString
(
buf
)
len
)
;
entry
.
setWellKnownOrStatic
(
)
;
entry
.
storage
(
)
[
0
]
=
buf
[
0
]
;
}
static
constexpr
void
init
(
StaticParserAtom
<
2
>
&
entry
size_t
i
)
{
size_t
len
=
2
;
char16_t
buf
[
]
=
{
StaticStrings
:
:
firstCharOfLength2
(
i
)
StaticStrings
:
:
secondCharOfLength2
(
i
)
0
}
;
entry
.
setHashAndLength
(
mozilla
:
:
HashString
(
buf
)
len
)
;
entry
.
setWellKnownOrStatic
(
)
;
entry
.
storage
(
)
[
0
]
=
buf
[
0
]
;
entry
.
storage
(
)
[
1
]
=
buf
[
1
]
;
}
static
constexpr
void
init
(
ParserAtom
&
entry
char
*
storage
const
char16_t
*
text
WellKnownAtomId
id
)
{
size_t
len
=
Char16Traits
:
:
length
(
text
)
;
entry
.
setHashAndLength
(
mozilla
:
:
HashString
(
text
)
len
)
;
entry
.
setWellKnownOrStatic
(
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
storage
[
i
]
=
text
[
i
]
;
}
}
public
:
template
<
typename
CharsT
>
const
ParserAtom
*
lookupTiny
(
CharsT
chars
size_t
length
)
const
{
static_assert
(
std
:
:
is_same_v
<
CharsT
const
Latin1Char
*
>
|
|
std
:
:
is_same_v
<
CharsT
const
char16_t
*
>
|
|
std
:
:
is_same_v
<
CharsT
const
char
*
>
|
|
std
:
:
is_same_v
<
CharsT
char16_t
*
>
|
|
std
:
:
is_same_v
<
CharsT
LittleEndianChars
>
"
This
assert
mostly
explicitly
documents
the
calling
types
"
"
and
forces
that
to
be
updated
if
new
types
show
up
.
"
)
;
switch
(
length
)
{
case
0
:
return
&
emptyAtom
;
case
1
:
{
if
(
char16_t
(
chars
[
0
]
)
<
ASCII_STATIC_LIMIT
)
{
size_t
index
=
static_cast
<
size_t
>
(
chars
[
0
]
)
;
return
&
length1Table
[
index
]
;
}
break
;
}
case
2
:
if
(
StaticStrings
:
:
fitsInSmallChar
(
chars
[
0
]
)
&
&
StaticStrings
:
:
fitsInSmallChar
(
chars
[
1
]
)
)
{
size_t
index
=
StaticStrings
:
:
getLength2Index
(
chars
[
0
]
chars
[
1
]
)
;
return
&
length2Table
[
index
]
;
}
break
;
}
return
nullptr
;
}
template
<
typename
CharsT
>
TaggedParserAtomIndex
lookupTinyIndex
(
CharsT
chars
size_t
length
)
const
{
static_assert
(
std
:
:
is_same_v
<
CharsT
const
Latin1Char
*
>
|
|
std
:
:
is_same_v
<
CharsT
const
char16_t
*
>
|
|
std
:
:
is_same_v
<
CharsT
const
char
*
>
|
|
std
:
:
is_same_v
<
CharsT
char16_t
*
>
|
|
std
:
:
is_same_v
<
CharsT
LittleEndianChars
>
"
This
assert
mostly
explicitly
documents
the
calling
types
"
"
and
forces
that
to
be
updated
if
new
types
show
up
.
"
)
;
switch
(
length
)
{
case
0
:
return
TaggedParserAtomIndex
:
:
WellKnown
:
:
empty
(
)
;
case
1
:
{
if
(
char16_t
(
chars
[
0
]
)
<
ASCII_STATIC_LIMIT
)
{
return
TaggedParserAtomIndex
(
StaticParserString1
(
chars
[
0
]
)
)
;
}
break
;
}
case
2
:
if
(
StaticStrings
:
:
fitsInSmallChar
(
chars
[
0
]
)
&
&
StaticStrings
:
:
fitsInSmallChar
(
chars
[
1
]
)
)
{
return
TaggedParserAtomIndex
(
StaticParserString2
(
StaticStrings
:
:
getLength2Index
(
chars
[
0
]
chars
[
1
]
)
)
)
;
}
break
;
}
return
TaggedParserAtomIndex
:
:
null
(
)
;
}
}
;
using
ParserAtomVector
=
Vector
<
ParserAtom
*
0
js
:
:
SystemAllocPolicy
>
;
using
ParserAtomSpan
=
mozilla
:
:
Span
<
ParserAtom
*
>
;
class
WellKnownParserAtoms
{
public
:
#
define
PROPERTYNAME_FIELD_
(
_
NAME
_2
)
const
ParserAtom
*
NAME
{
}
;
FOR_EACH_COMMON_PROPERTYNAME
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
#
define
PROPERTYNAME_FIELD_
(
NAME
_
)
const
ParserAtom
*
NAME
{
}
;
JS_FOR_EACH_PROTOTYPE
(
PROPERTYNAME_FIELD_
)
#
undef
PROPERTYNAME_FIELD_
static
constexpr
WellKnownParserAtoms_ROM
rom_
=
{
}
;
using
EntryMap
=
HashMap
<
const
ParserAtom
*
TaggedParserAtomIndex
ParserAtomLookupHasher
js
:
:
SystemAllocPolicy
>
;
EntryMap
wellKnownMap_
;
bool
initTinyStringAlias
(
JSContext
*
cx
const
ParserAtom
*
*
name
const
char
*
str
)
;
bool
initSingle
(
JSContext
*
cx
const
ParserAtom
*
*
name
const
ParserAtom
&
romEntry
TaggedParserAtomIndex
index
)
;
public
:
bool
init
(
JSContext
*
cx
)
;
static
constexpr
size_t
MaxWellKnownLength
=
32
;
template
<
typename
CharT
>
TaggedParserAtomIndex
lookupChar16Seq
(
const
SpecificParserAtomLookup
<
CharT
>
&
lookup
)
const
;
template
<
typename
CharsT
>
const
ParserAtom
*
lookupTiny
(
CharsT
chars
size_t
length
)
const
{
return
rom_
.
lookupTiny
(
chars
length
)
;
}
template
<
typename
CharsT
>
TaggedParserAtomIndex
lookupTinyIndex
(
CharsT
chars
size_t
length
)
const
{
return
rom_
.
lookupTinyIndex
(
chars
length
)
;
}
const
ParserAtom
*
getWellKnown
(
WellKnownAtomId
atomId
)
const
;
static
const
ParserAtom
*
getStatic1
(
StaticParserString1
s
)
;
static
const
ParserAtom
*
getStatic2
(
StaticParserString2
s
)
;
}
;
bool
InstantiateMarkedAtoms
(
JSContext
*
cx
const
ParserAtomSpan
&
entries
CompilationAtomCache
&
atomCache
)
;
class
ParserAtomsTable
{
private
:
const
WellKnownParserAtoms
&
wellKnownTable_
;
LifoAlloc
&
alloc_
;
using
EntryMap
=
HashMap
<
const
ParserAtom
*
TaggedParserAtomIndex
ParserAtomLookupHasher
js
:
:
SystemAllocPolicy
>
;
EntryMap
entryMap_
;
ParserAtomVector
entries_
;
public
:
ParserAtomsTable
(
JSRuntime
*
rt
LifoAlloc
&
alloc
)
;
ParserAtomsTable
(
ParserAtomsTable
&
&
)
=
default
;
private
:
TaggedParserAtomIndex
addEntry
(
JSContext
*
cx
EntryMap
:
:
AddPtr
&
addPtr
ParserAtom
*
entry
)
;
template
<
typename
AtomCharT
typename
SeqCharT
>
TaggedParserAtomIndex
internChar16Seq
(
JSContext
*
cx
EntryMap
:
:
AddPtr
&
addPtr
HashNumber
hash
InflatedChar16Sequence
<
SeqCharT
>
seq
uint32_t
length
)
;
public
:
TaggedParserAtomIndex
internAscii
(
JSContext
*
cx
const
char
*
asciiPtr
uint32_t
length
)
;
TaggedParserAtomIndex
internLatin1
(
JSContext
*
cx
const
JS
:
:
Latin1Char
*
latin1Ptr
uint32_t
length
)
;
TaggedParserAtomIndex
internUtf8
(
JSContext
*
cx
const
mozilla
:
:
Utf8Unit
*
utf8Ptr
uint32_t
nbyte
)
;
TaggedParserAtomIndex
internChar16
(
JSContext
*
cx
const
char16_t
*
char16Ptr
uint32_t
length
)
;
TaggedParserAtomIndex
internJSAtom
(
JSContext
*
cx
CompilationAtomCache
&
atomCache
JSAtom
*
atom
)
;
TaggedParserAtomIndex
concatAtoms
(
JSContext
*
cx
mozilla
:
:
Range
<
const
ParserAtom
*
>
atoms
)
;
private
:
const
ParserAtom
*
getWellKnown
(
WellKnownAtomId
atomId
)
const
;
const
ParserAtom
*
getStatic1
(
StaticParserString1
s
)
const
;
const
ParserAtom
*
getStatic2
(
StaticParserString2
s
)
const
;
template
<
class
T
>
friend
const
ParserAtom
*
GetParserAtom
(
T
self
TaggedParserAtomIndex
index
)
;
public
:
const
ParserAtom
*
getParserAtom
(
ParserAtomIndex
index
)
const
;
const
ParserAtom
*
getParserAtom
(
TaggedParserAtomIndex
index
)
const
;
void
markUsedByStencil
(
TaggedParserAtomIndex
index
)
const
;
const
ParserAtomVector
&
entries
(
)
const
{
return
entries_
;
}
bool
isPrivateName
(
TaggedParserAtomIndex
index
)
const
;
bool
isIndex
(
TaggedParserAtomIndex
index
uint32_t
*
indexp
)
const
;
bool
toNumber
(
JSContext
*
cx
TaggedParserAtomIndex
index
double
*
result
)
const
;
UniqueChars
toNewUTF8CharsZ
(
JSContext
*
cx
TaggedParserAtomIndex
index
)
const
;
}
;
class
ParserAtomSpanBuilder
{
private
:
const
WellKnownParserAtoms
&
wellKnownTable_
;
ParserAtomSpan
&
entries_
;
public
:
ParserAtomSpanBuilder
(
JSRuntime
*
rt
ParserAtomSpan
&
entries
)
;
bool
allocate
(
JSContext
*
cx
LifoAlloc
&
alloc
size_t
count
)
;
size_t
size
(
)
const
{
return
entries_
.
size
(
)
;
}
void
set
(
ParserAtomIndex
index
const
ParserAtom
*
atom
)
{
entries_
[
index
]
=
const_cast
<
ParserAtom
*
>
(
atom
)
;
}
private
:
const
ParserAtom
*
getWellKnown
(
WellKnownAtomId
atomId
)
const
;
const
ParserAtom
*
getStatic1
(
StaticParserString1
s
)
const
;
const
ParserAtom
*
getStatic2
(
StaticParserString2
s
)
const
;
template
<
class
T
>
friend
const
ParserAtom
*
GetParserAtom
(
T
self
TaggedParserAtomIndex
index
)
;
public
:
const
ParserAtom
*
getParserAtom
(
ParserAtomIndex
index
)
const
;
const
ParserAtom
*
getParserAtom
(
TaggedParserAtomIndex
index
)
const
;
}
;
template
<
typename
CharT
>
class
SpecificParserAtomLookup
:
public
ParserAtomLookup
{
InflatedChar16Sequence
<
CharT
>
seq_
;
public
:
explicit
SpecificParserAtomLookup
(
const
InflatedChar16Sequence
<
CharT
>
&
seq
)
:
SpecificParserAtomLookup
(
seq
seq
.
computeHash
(
)
)
{
}
SpecificParserAtomLookup
(
const
InflatedChar16Sequence
<
CharT
>
&
seq
HashNumber
hash
)
:
ParserAtomLookup
(
hash
)
seq_
(
seq
)
{
MOZ_ASSERT
(
seq_
.
computeHash
(
)
=
=
hash
)
;
}
virtual
bool
equalsEntry
(
const
ParserAtom
*
entry
)
const
override
{
return
entry
-
>
equalsSeq
<
CharT
>
(
hash_
seq_
)
;
}
}
;
template
<
typename
CharT
>
inline
bool
ParserAtom
:
:
equalsSeq
(
HashNumber
hash
InflatedChar16Sequence
<
CharT
>
seq
)
const
{
if
(
hash_
!
=
hash
)
{
return
false
;
}
if
(
hasTwoByteChars
(
)
)
{
const
char16_t
*
chars
=
twoByteChars
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length_
;
i
+
+
)
{
if
(
!
seq
.
hasMore
(
)
|
|
chars
[
i
]
!
=
seq
.
next
(
)
)
{
return
false
;
}
}
}
else
{
const
Latin1Char
*
chars
=
latin1Chars
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length_
;
i
+
+
)
{
if
(
!
seq
.
hasMore
(
)
|
|
char16_t
(
chars
[
i
]
)
!
=
seq
.
next
(
)
)
{
return
false
;
}
}
}
return
!
seq
.
hasMore
(
)
;
}
JSAtom
*
GetWellKnownAtom
(
JSContext
*
cx
WellKnownAtomId
atomId
)
;
}
}
#
endif
