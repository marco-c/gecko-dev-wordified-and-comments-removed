#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSContext
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
void
CGNumberList
:
:
finish
(
mozilla
:
:
Span
<
GCPtrValue
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
.
init
(
vector
[
i
]
)
;
}
}
unsigned
CGObjectList
:
:
add
(
ObjectBox
*
objbox
)
{
MOZ_ASSERT
(
objbox
-
>
isObjectBox
(
)
)
;
MOZ_ASSERT
(
!
objbox
-
>
emitLink
)
;
objbox
-
>
emitLink
=
lastbox
;
lastbox
=
objbox
;
return
length
+
+
;
}
void
CGObjectList
:
:
finish
(
mozilla
:
:
Span
<
GCPtrObject
>
array
)
{
MOZ_ASSERT
(
length
<
=
INDEX_LIMIT
)
;
MOZ_ASSERT
(
length
=
=
array
.
size
(
)
)
;
ObjectBox
*
objbox
=
lastbox
;
for
(
GCPtrObject
&
obj
:
mozilla
:
:
Reversed
(
array
)
)
{
MOZ_ASSERT
(
obj
=
=
nullptr
)
;
MOZ_ASSERT
(
objbox
-
>
object
(
)
-
>
isTenured
(
)
)
;
obj
.
init
(
objbox
-
>
object
(
)
)
;
objbox
=
objbox
-
>
emitLink
;
}
}
void
CGObjectList
:
:
finishInnerFunctions
(
)
{
ObjectBox
*
objbox
=
lastbox
;
while
(
objbox
)
{
if
(
objbox
-
>
isFunctionBox
(
)
)
{
objbox
-
>
asFunctionBox
(
)
-
>
finish
(
)
;
}
objbox
=
objbox
-
>
emitLink
;
}
}
void
CGScopeList
:
:
finish
(
mozilla
:
:
Span
<
GCPtrScope
>
array
)
{
MOZ_ASSERT
(
length
(
)
<
=
INDEX_LIMIT
)
;
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
.
init
(
vector
[
i
]
)
;
}
}
bool
CGTryNoteList
:
:
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
{
MOZ_ASSERT
(
start
<
=
end
)
;
JSTryNote
note
;
note
.
kind
=
kind
;
note
.
stackDepth
=
stackDepth
;
note
.
start
=
start
.
toUint32
(
)
;
note
.
length
=
(
end
-
start
)
.
toUint32
(
)
;
return
list
.
append
(
note
)
;
}
void
CGTryNoteList
:
:
finish
(
mozilla
:
:
Span
<
JSTryNote
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
=
list
[
i
]
;
}
}
bool
CGScopeNoteList
:
:
append
(
uint32_t
scopeIndex
BytecodeOffset
offset
uint32_t
parent
)
{
CGScopeNote
note
;
mozilla
:
:
PodZero
(
&
note
)
;
note
.
index
=
scopeIndex
;
note
.
start
=
offset
.
toUint32
(
)
;
note
.
parent
=
parent
;
return
list
.
append
(
note
)
;
}
void
CGScopeNoteList
:
:
recordEnd
(
uint32_t
index
BytecodeOffset
offset
)
{
recordEndImpl
(
index
offset
.
toUint32
(
)
)
;
}
void
CGScopeNoteList
:
:
recordEndFunctionBodyVar
(
uint32_t
index
)
{
recordEndImpl
(
index
UINT32_MAX
)
;
}
void
CGScopeNoteList
:
:
recordEndImpl
(
uint32_t
index
uint32_t
offset
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
MOZ_ASSERT
(
list
[
index
]
.
length
=
=
0
)
;
list
[
index
]
.
end
=
offset
;
}
void
CGScopeNoteList
:
:
finish
(
mozilla
:
:
Span
<
ScopeNote
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
list
[
i
]
.
end
>
=
list
[
i
]
.
start
)
;
list
[
i
]
.
length
=
list
[
i
]
.
end
-
list
[
i
]
.
start
;
array
[
i
]
=
list
[
i
]
;
}
}
void
CGResumeOffsetList
:
:
finish
(
mozilla
:
:
Span
<
uint32_t
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
=
list
[
i
]
;
}
}
BytecodeSection
:
:
BytecodeSection
(
JSContext
*
cx
uint32_t
lineNum
)
:
code_
(
cx
)
notes_
(
cx
)
lastNoteOffset_
(
0
)
tryNoteList_
(
cx
)
scopeNoteList_
(
cx
)
resumeOffsetList_
(
cx
)
currentLine_
(
lineNum
)
{
}
void
BytecodeSection
:
:
updateDepth
(
BytecodeOffset
target
)
{
jsbytecode
*
pc
=
code
(
target
)
;
int
nuses
=
StackUses
(
pc
)
;
int
ndefs
=
StackDefs
(
pc
)
;
stackDepth_
-
=
nuses
;
MOZ_ASSERT
(
stackDepth_
>
=
0
)
;
stackDepth_
+
=
ndefs
;
if
(
uint32_t
(
stackDepth_
)
>
maxStackDepth_
)
{
maxStackDepth_
=
stackDepth_
;
}
}
PerScriptData
:
:
PerScriptData
(
JSContext
*
cx
)
:
scopeList_
(
cx
)
numberList_
(
cx
)
atomIndices_
(
cx
-
>
frontendCollectionPool
(
)
)
{
}
bool
PerScriptData
:
:
init
(
JSContext
*
cx
)
{
return
atomIndices_
.
acquire
(
cx
)
;
}
