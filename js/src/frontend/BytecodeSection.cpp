#
include
"
frontend
/
BytecodeSection
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
frontend
/
CompilationInfo
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
RegExpObject
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
bool
GCThingList
:
:
append
(
FunctionBox
*
funbox
uint32_t
*
index
)
{
MOZ_ASSERT
(
!
funbox
-
>
emitLink_
)
;
funbox
-
>
emitLink_
=
lastbox
;
lastbox
=
funbox
;
*
index
=
vector
.
length
(
)
;
return
vector
.
append
(
mozilla
:
:
AsVariant
(
JS
:
:
GCCellPtr
(
funbox
-
>
function
(
)
)
)
)
;
}
void
GCThingList
:
:
finishInnerFunctions
(
)
{
FunctionBox
*
funbox
=
lastbox
;
while
(
funbox
)
{
funbox
-
>
finish
(
)
;
funbox
=
funbox
-
>
emitLink_
;
}
}
bool
GCThingList
:
:
finish
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
array
)
{
MOZ_ASSERT
(
length
(
)
<
=
INDEX_LIMIT
)
;
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
struct
Matcher
{
JSContext
*
cx
;
CompilationInfo
&
compilationInfo
;
uint32_t
i
;
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
&
array
;
bool
operator
(
)
(
const
JS
:
:
GCCellPtr
&
value
)
{
array
[
i
]
=
value
;
return
true
;
}
bool
operator
(
)
(
BigIntIndex
&
index
)
{
BigIntCreationData
&
data
=
compilationInfo
.
bigIntData
[
index
]
;
BigInt
*
bi
=
data
.
createBigInt
(
cx
)
;
if
(
!
bi
)
{
return
false
;
}
array
[
i
]
=
JS
:
:
GCCellPtr
(
bi
)
;
return
true
;
}
bool
operator
(
)
(
RegExpIndex
&
rindex
)
{
RegExpCreationData
&
data
=
compilationInfo
.
regExpData
[
rindex
]
;
RegExpObject
*
regexp
=
data
.
createRegExp
(
cx
)
;
if
(
!
regexp
)
{
return
false
;
}
array
[
i
]
=
JS
:
:
GCCellPtr
(
regexp
)
;
return
true
;
}
bool
operator
(
)
(
ObjLiteralCreationData
&
data
)
{
JSObject
*
obj
=
data
.
create
(
cx
)
;
if
(
!
obj
)
{
return
false
;
}
array
[
i
]
=
JS
:
:
GCCellPtr
(
obj
)
;
return
true
;
}
bool
operator
(
)
(
ScopeIndex
&
index
)
{
MutableHandle
<
ScopeCreationData
>
data
=
compilationInfo
.
scopeCreationData
[
index
]
;
Scope
*
scope
=
data
.
get
(
)
.
createScope
(
cx
)
;
if
(
!
scope
)
{
return
false
;
}
array
[
i
]
=
JS
:
:
GCCellPtr
(
scope
)
;
return
true
;
}
}
;
for
(
uint32_t
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
Matcher
m
{
cx
compilationInfo
i
array
}
;
if
(
!
vector
[
i
]
.
get
(
)
.
match
(
m
)
)
{
return
false
;
}
}
return
true
;
}
bool
CGTryNoteList
:
:
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
{
MOZ_ASSERT
(
start
<
=
end
)
;
JSTryNote
note
;
note
.
kind
=
kind
;
note
.
stackDepth
=
stackDepth
;
note
.
start
=
start
.
toUint32
(
)
;
note
.
length
=
(
end
-
start
)
.
toUint32
(
)
;
return
list
.
append
(
note
)
;
}
void
CGTryNoteList
:
:
finish
(
mozilla
:
:
Span
<
JSTryNote
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
=
list
[
i
]
;
}
}
bool
CGScopeNoteList
:
:
append
(
uint32_t
scopeIndex
BytecodeOffset
offset
uint32_t
parent
)
{
CGScopeNote
note
;
mozilla
:
:
PodZero
(
&
note
)
;
note
.
index
=
scopeIndex
;
note
.
start
=
offset
.
toUint32
(
)
;
note
.
parent
=
parent
;
return
list
.
append
(
note
)
;
}
void
CGScopeNoteList
:
:
recordEnd
(
uint32_t
index
BytecodeOffset
offset
)
{
recordEndImpl
(
index
offset
.
toUint32
(
)
)
;
}
void
CGScopeNoteList
:
:
recordEndFunctionBodyVar
(
uint32_t
index
)
{
recordEndImpl
(
index
UINT32_MAX
)
;
}
void
CGScopeNoteList
:
:
recordEndImpl
(
uint32_t
index
uint32_t
offset
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
MOZ_ASSERT
(
list
[
index
]
.
length
=
=
0
)
;
list
[
index
]
.
end
=
offset
;
}
void
CGScopeNoteList
:
:
finish
(
mozilla
:
:
Span
<
ScopeNote
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
list
[
i
]
.
end
>
=
list
[
i
]
.
start
)
;
list
[
i
]
.
length
=
list
[
i
]
.
end
-
list
[
i
]
.
start
;
array
[
i
]
=
list
[
i
]
;
}
}
void
CGResumeOffsetList
:
:
finish
(
mozilla
:
:
Span
<
uint32_t
>
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
size
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
array
[
i
]
=
list
[
i
]
;
}
}
JSObject
*
ObjLiteralCreationData
:
:
create
(
JSContext
*
cx
)
{
return
InterpretObjLiteral
(
cx
atoms_
writer_
)
;
}
BytecodeSection
:
:
BytecodeSection
(
JSContext
*
cx
uint32_t
lineNum
)
:
code_
(
cx
)
notes_
(
cx
)
lastNoteOffset_
(
0
)
tryNoteList_
(
cx
)
scopeNoteList_
(
cx
)
resumeOffsetList_
(
cx
)
currentLine_
(
lineNum
)
{
}
void
BytecodeSection
:
:
updateDepth
(
BytecodeOffset
target
)
{
jsbytecode
*
pc
=
code
(
target
)
;
int
nuses
=
StackUses
(
pc
)
;
int
ndefs
=
StackDefs
(
pc
)
;
stackDepth_
-
=
nuses
;
MOZ_ASSERT
(
stackDepth_
>
=
0
)
;
stackDepth_
+
=
ndefs
;
if
(
uint32_t
(
stackDepth_
)
>
maxStackDepth_
)
{
maxStackDepth_
=
stackDepth_
;
}
}
PerScriptData
:
:
PerScriptData
(
JSContext
*
cx
frontend
:
:
CompilationInfo
&
compilationInfo
)
:
gcThingList_
(
cx
compilationInfo
)
atomIndices_
(
cx
-
>
frontendCollectionPool
(
)
)
{
}
bool
PerScriptData
:
:
init
(
JSContext
*
cx
)
{
return
atomIndices_
.
acquire
(
cx
)
;
}
