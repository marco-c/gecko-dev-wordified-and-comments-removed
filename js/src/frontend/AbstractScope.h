#
ifndef
frontend_AbstractScope_h
#
define
frontend_AbstractScope_h
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
frontend
/
TypedIndex
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
namespace
js
{
class
Scope
;
class
GlobalScope
;
class
EvalScope
;
class
GCMarker
;
class
ScopeCreationData
;
namespace
frontend
{
struct
ParseInfo
;
class
FunctionBox
;
}
using
ScopeIndex
=
frontend
:
:
TypedIndex
<
Scope
>
;
using
HeapPtrScope
=
HeapPtr
<
Scope
*
>
;
class
AbstractScope
{
public
:
struct
Deferred
{
ScopeIndex
index
;
frontend
:
:
ParseInfo
&
parseInfo
;
}
;
using
ScopeType
=
mozilla
:
:
Variant
<
HeapPtrScope
Deferred
>
;
private
:
ScopeType
scope_
=
ScopeType
(
HeapPtrScope
(
)
)
;
Scope
*
getExistingScope
(
)
const
;
public
:
friend
class
js
:
:
Scope
;
friend
class
js
:
:
frontend
:
:
FunctionBox
;
AbstractScope
(
)
=
default
;
explicit
AbstractScope
(
Scope
*
scope
)
:
scope_
(
HeapPtrScope
(
scope
)
)
{
}
AbstractScope
(
frontend
:
:
ParseInfo
&
parseInfo
ScopeIndex
scope
)
:
scope_
(
Deferred
{
scope
parseInfo
}
)
{
}
bool
isNullptr
(
)
const
{
if
(
isScopeCreationData
(
)
)
{
return
false
;
}
return
scope_
.
as
<
HeapPtrScope
>
(
)
=
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
!
isNullptr
(
)
;
}
bool
isScopeCreationData
(
)
const
{
return
scope_
.
is
<
Deferred
>
(
)
;
}
MutableHandle
<
ScopeCreationData
>
scopeCreationData
(
)
const
;
Scope
*
scope
(
)
const
{
return
scope_
.
as
<
HeapPtrScope
>
(
)
;
}
bool
getOrCreateScope
(
JSContext
*
cx
MutableHandleScope
scope
)
;
template
<
typename
T
>
bool
is
(
)
const
{
static_assert
(
std
:
:
is_base_of
<
Scope
T
>
:
:
value
"
Trying
to
ask
about
non
-
Scope
type
"
)
;
if
(
isNullptr
(
)
)
{
return
false
;
}
return
kind
(
)
=
=
T
:
:
classScopeKind_
;
}
ScopeKind
kind
(
)
const
;
AbstractScope
enclosing
(
)
const
;
bool
hasEnvironment
(
)
const
;
uint32_t
nextFrameSlot
(
)
const
;
bool
isArrow
(
)
const
;
JSFunction
*
canonicalFunction
(
)
const
;
bool
hasOnChain
(
ScopeKind
kind
)
const
{
for
(
AbstractScope
it
=
*
this
;
it
;
it
=
it
.
enclosing
(
)
)
{
if
(
it
.
kind
(
)
=
=
kind
)
{
return
true
;
}
}
return
false
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
template
<
>
inline
bool
AbstractScope
:
:
is
<
GlobalScope
>
(
)
const
{
return
!
isNullptr
(
)
&
&
(
kind
(
)
=
=
ScopeKind
:
:
Global
|
|
kind
(
)
=
=
ScopeKind
:
:
NonSyntactic
)
;
}
template
<
>
inline
bool
AbstractScope
:
:
is
<
EvalScope
>
(
)
const
{
return
!
isNullptr
(
)
&
&
(
kind
(
)
=
=
ScopeKind
:
:
Eval
|
|
kind
(
)
=
=
ScopeKind
:
:
StrictEval
)
;
}
class
AbstractScopeIter
{
AbstractScope
scope_
;
public
:
explicit
AbstractScopeIter
(
const
AbstractScope
&
f
)
:
scope_
(
f
)
{
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
bool
done
(
)
const
{
return
!
scope_
;
}
ScopeKind
kind
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
scope_
)
;
return
scope_
.
kind
(
)
;
}
AbstractScope
abstractScope
(
)
const
{
return
scope_
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
scope_
=
scope_
.
enclosing
(
)
;
}
bool
hasSyntacticEnvironment
(
)
const
;
void
trace
(
JSTracer
*
trc
)
{
if
(
scope_
)
{
scope_
.
trace
(
trc
)
;
}
}
;
}
;
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
AbstractScope
:
:
Deferred
>
:
JS
:
:
IgnoreGCPolicy
<
js
:
:
AbstractScope
:
:
Deferred
>
{
}
;
}
#
endif
