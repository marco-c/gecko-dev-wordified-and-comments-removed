#
ifndef
frontend_ScopeBindingCache_h
#
define
frontend_ScopeBindingCache_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
StringType
.
h
"
struct
JS_PUBLIC_API
JSContext
;
namespace
js
{
namespace
frontend
{
struct
CompilationAtomCache
;
struct
CompilationStencil
;
struct
ScopeStencilRef
;
struct
CompilationStencilMerger
;
struct
GenericAtom
{
struct
EmitterName
{
JSContext
*
cx
;
ErrorContext
*
ec
;
ParserAtomsTable
&
parserAtoms
;
CompilationAtomCache
&
atomCache
;
TaggedParserAtomIndex
index
;
EmitterName
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
TaggedParserAtomIndex
index
)
:
cx
(
cx
)
ec
(
ec
)
parserAtoms
(
parserAtoms
)
atomCache
(
atomCache
)
index
(
index
)
{
}
}
;
struct
StencilName
{
const
CompilationStencil
&
stencil
;
TaggedParserAtomIndex
index
;
}
;
using
AnyName
=
mozilla
:
:
Variant
<
EmitterName
StencilName
JSAtom
*
>
;
HashNumber
hash
;
AnyName
ref
;
GenericAtom
(
JSContext
*
cx
ErrorContext
*
ec
ParserAtomsTable
&
parserAtoms
CompilationAtomCache
&
atomCache
TaggedParserAtomIndex
index
)
;
GenericAtom
(
const
CompilationStencil
&
context
TaggedParserAtomIndex
index
)
;
GenericAtom
(
ScopeStencilRef
&
scope
TaggedParserAtomIndex
index
)
;
GenericAtom
(
const
Scope
*
JSAtom
*
ptr
)
:
GenericAtom
(
ptr
)
{
}
explicit
GenericAtom
(
JSAtom
*
ptr
)
:
ref
(
ptr
)
{
hash
=
ptr
-
>
hash
(
)
;
}
bool
operator
=
=
(
const
GenericAtom
&
other
)
const
;
}
;
template
<
typename
NameT
>
struct
BindingHasher
;
template
<
>
struct
BindingHasher
<
TaggedParserAtomIndex
>
{
using
Key
=
TaggedParserAtomIndex
;
struct
Lookup
{
const
CompilationStencil
&
keyStencil
;
GenericAtom
other
;
Lookup
(
ScopeStencilRef
&
scope_ref
const
GenericAtom
&
other
)
;
}
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
aLookup
.
other
.
hash
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
GenericAtom
key
(
aLookup
.
keyStencil
aKey
)
;
return
key
=
=
aLookup
.
other
;
}
}
;
template
<
>
struct
BindingHasher
<
JSAtom
*
>
{
using
Key
=
JSAtom
*
;
struct
Lookup
{
GenericAtom
other
;
template
<
typename
Any
>
Lookup
(
const
Any
&
const
GenericAtom
&
other
)
:
other
(
other
)
{
}
}
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
aLookup
.
other
.
hash
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
GenericAtom
key
(
aKey
)
;
return
key
=
=
aLookup
.
other
;
}
}
;
template
<
typename
NameT
>
struct
BindingMap
{
using
Lookup
=
typename
BindingHasher
<
NameT
>
:
:
Lookup
;
using
Map
=
HashMap
<
NameT
NameLocation
BindingHasher
<
NameT
>
js
:
:
SystemAllocPolicy
>
;
Map
hashMap
;
mozilla
:
:
Maybe
<
NameLocation
>
catchAll
;
}
;
template
<
typename
NameT
typename
ScopeT
=
NameT
>
using
ScopeBindingMap
=
HashMap
<
AbstractBaseScopeData
<
ScopeT
>
*
BindingMap
<
NameT
>
DefaultHasher
<
AbstractBaseScopeData
<
ScopeT
>
*
>
js
:
:
SystemAllocPolicy
>
;
class
ScopeBindingCache
{
public
:
using
CacheGeneration
=
size_t
;
virtual
CacheGeneration
getCurrentGeneration
(
)
const
=
0
;
virtual
bool
canCacheFor
(
Scope
*
ptr
)
;
virtual
bool
canCacheFor
(
ScopeStencilRef
ref
)
;
virtual
BindingMap
<
JSAtom
*
>
*
createCacheFor
(
Scope
*
ptr
)
;
virtual
BindingMap
<
TaggedParserAtomIndex
>
*
createCacheFor
(
ScopeStencilRef
ref
)
;
virtual
BindingMap
<
JSAtom
*
>
*
lookupScope
(
Scope
*
ptr
CacheGeneration
gen
)
;
virtual
BindingMap
<
TaggedParserAtomIndex
>
*
lookupScope
(
ScopeStencilRef
ref
CacheGeneration
gen
)
;
}
;
class
NoScopeBindingCache
final
:
public
ScopeBindingCache
{
public
:
CacheGeneration
getCurrentGeneration
(
)
const
override
{
return
1
;
}
;
bool
canCacheFor
(
Scope
*
ptr
)
override
;
bool
canCacheFor
(
ScopeStencilRef
ref
)
override
;
}
;
class
MOZ_STACK_CLASS
StencilScopeBindingCache
final
:
public
ScopeBindingCache
{
ScopeBindingMap
<
TaggedParserAtomIndex
>
scopeMap
;
#
ifdef
DEBUG
const
CompilationStencilMerger
&
merger_
;
#
endif
public
:
explicit
StencilScopeBindingCache
(
const
CompilationStencilMerger
&
merger
)
#
ifdef
DEBUG
:
merger_
(
merger
)
#
endif
{
}
CacheGeneration
getCurrentGeneration
(
)
const
override
{
return
1
;
}
bool
canCacheFor
(
ScopeStencilRef
ref
)
override
;
BindingMap
<
TaggedParserAtomIndex
>
*
createCacheFor
(
ScopeStencilRef
ref
)
override
;
BindingMap
<
TaggedParserAtomIndex
>
*
lookupScope
(
ScopeStencilRef
ref
CacheGeneration
gen
)
override
;
}
;
class
RuntimeScopeBindingCache
final
:
public
ScopeBindingCache
{
ScopeBindingMap
<
JSAtom
*
JSAtom
>
scopeMap
;
size_t
cacheGeneration
=
1
;
public
:
CacheGeneration
getCurrentGeneration
(
)
const
override
{
return
cacheGeneration
;
}
bool
canCacheFor
(
Scope
*
ptr
)
override
;
BindingMap
<
JSAtom
*
>
*
createCacheFor
(
Scope
*
ptr
)
override
;
BindingMap
<
JSAtom
*
>
*
lookupScope
(
Scope
*
ptr
CacheGeneration
gen
)
override
;
void
purge
(
)
{
cacheGeneration
+
+
;
scopeMap
.
clearAndCompact
(
)
;
}
}
;
}
}
#
endif
