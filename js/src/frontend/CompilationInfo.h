#
ifndef
frontend_CompilationInfo_h
#
define
frontend_CompilationInfo_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
ScriptIndex
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
TaggedParserAtomIndexHasher
.
h
"
#
include
"
frontend
/
UsedNameTracker
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RealmOptions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
js
/
WasmModule
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
ScopeKind
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
namespace
js
{
class
JSONPrinter
;
namespace
frontend
{
struct
CompilationInput
;
struct
ScopeContext
{
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
=
{
}
;
enum
class
EnclosingLexicalBindingKind
{
Let
Const
CatchParameter
}
;
using
EnclosingLexicalBindingCache
=
mozilla
:
:
HashMap
<
TaggedParserAtomIndex
EnclosingLexicalBindingKind
TaggedParserAtomIndexHasher
>
;
mozilla
:
:
Maybe
<
EnclosingLexicalBindingCache
>
enclosingLexicalBindingCache_
;
using
EffectiveScopePrivateFieldCache
=
mozilla
:
:
HashSet
<
TaggedParserAtomIndex
TaggedParserAtomIndexHasher
>
;
mozilla
:
:
Maybe
<
EffectiveScopePrivateFieldCache
>
effectiveScopePrivateFieldCache_
;
uint32_t
enclosingScopeEnvironmentChainLength
=
0
;
uint32_t
enclosingThisEnvironmentHops
=
0
;
ScopeKind
enclosingScopeKind
=
ScopeKind
:
:
Global
;
ThisBinding
thisBinding
=
ThisBinding
:
:
Global
;
bool
allowNewTarget
=
false
;
bool
allowSuperProperty
=
false
;
bool
allowSuperCall
=
false
;
bool
allowArguments
=
true
;
bool
inClass
=
false
;
bool
inWith
=
false
;
bool
enclosingScopeIsArrow
=
false
;
bool
enclosingScopeHasEnvironment
=
false
;
#
ifdef
DEBUG
bool
hasNonSyntacticScopeOnChain
=
false
;
bool
hasFunctionNeedsHomeObjectOnChain
=
false
;
#
endif
bool
init
(
JSContext
*
cx
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
InheritThis
inheritThis
JSObject
*
enclosingEnv
)
;
mozilla
:
:
Maybe
<
EnclosingLexicalBindingKind
>
lookupLexicalBindingInEnclosingScope
(
TaggedParserAtomIndex
name
)
;
NameLocation
searchInDelazificationEnclosingScope
(
JSContext
*
cx
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
TaggedParserAtomIndex
name
uint8_t
hops
)
;
bool
effectiveScopePrivateFieldCacheHas
(
TaggedParserAtomIndex
name
)
;
private
:
void
computeThisBinding
(
Scope
*
scope
)
;
void
computeThisEnvironment
(
Scope
*
enclosingScope
)
;
void
computeInScope
(
Scope
*
enclosingScope
)
;
void
cacheEnclosingScope
(
Scope
*
enclosingScope
)
;
static
Scope
*
determineEffectiveScope
(
Scope
*
scope
JSObject
*
environment
)
;
bool
cacheEnclosingScopeBindingForEval
(
JSContext
*
cx
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
)
;
bool
cachePrivateFieldsForEval
(
JSContext
*
cx
CompilationInput
&
input
Scope
*
effectiveScope
ParserAtomsTable
&
parserAtoms
)
;
bool
addToEnclosingLexicalBindingCache
(
JSContext
*
cx
CompilationInput
&
input
ParserAtomsTable
&
parserAtoms
JSAtom
*
name
EnclosingLexicalBindingKind
kind
)
;
}
;
struct
CompilationAtomCache
{
public
:
using
AtomCacheVector
=
JS
:
:
GCVector
<
JSAtom
*
0
js
:
:
SystemAllocPolicy
>
;
private
:
AtomCacheVector
atoms_
;
public
:
JSAtom
*
getExistingAtomAt
(
ParserAtomIndex
index
)
const
;
JSAtom
*
getExistingAtomAt
(
JSContext
*
cx
TaggedParserAtomIndex
taggedIndex
)
const
;
JSAtom
*
getAtomAt
(
ParserAtomIndex
index
)
const
;
bool
hasAtomAt
(
ParserAtomIndex
index
)
const
;
bool
setAtomAt
(
JSContext
*
cx
ParserAtomIndex
index
JSAtom
*
atom
)
;
bool
allocate
(
JSContext
*
cx
size_t
length
)
;
bool
extendIfNecessary
(
JSContext
*
cx
size_t
length
)
;
void
stealBuffer
(
AtomCacheVector
&
atoms
)
;
void
releaseBuffer
(
AtomCacheVector
&
atoms
)
;
void
trace
(
JSTracer
*
trc
)
;
}
JS_HAZ_GC_POINTER
;
struct
CompilationInput
{
enum
class
CompilationTarget
{
Global
SelfHosting
StandaloneFunction
StandaloneFunctionInNonSyntacticScope
Eval
Module
Delazification
}
;
CompilationTarget
target
=
CompilationTarget
:
:
Global
;
const
JS
:
:
ReadOnlyCompileOptions
&
options
;
CompilationAtomCache
atomCache
;
BaseScript
*
lazy
=
nullptr
;
ScriptSourceHolder
source_
;
Scope
*
enclosingScope
=
nullptr
;
explicit
CompilationInput
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
options
(
options
)
{
}
private
:
bool
initScriptSource
(
JSContext
*
cx
)
;
public
:
bool
initForGlobal
(
JSContext
*
cx
)
{
target
=
CompilationTarget
:
:
Global
;
return
initScriptSource
(
cx
)
;
}
bool
initForSelfHostingGlobal
(
JSContext
*
cx
)
{
target
=
CompilationTarget
:
:
SelfHosting
;
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
;
return
true
;
}
bool
initForStandaloneFunction
(
JSContext
*
cx
)
{
target
=
CompilationTarget
:
:
StandaloneFunction
;
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
;
return
true
;
}
bool
initForStandaloneFunctionInNonSyntacticScope
(
JSContext
*
cx
HandleScope
functionEnclosingScope
)
;
bool
initForEval
(
JSContext
*
cx
HandleScope
evalEnclosingScope
)
{
target
=
CompilationTarget
:
:
Eval
;
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
evalEnclosingScope
;
return
true
;
}
bool
initForModule
(
JSContext
*
cx
)
{
target
=
CompilationTarget
:
:
Module
;
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
return
true
;
}
void
initFromLazy
(
BaseScript
*
lazyScript
)
{
target
=
CompilationTarget
:
:
Delazification
;
lazy
=
lazyScript
;
enclosingScope
=
lazy
-
>
function
(
)
-
>
enclosingScope
(
)
;
}
bool
hasNonDefaultEnclosingScope
(
)
const
{
return
target
=
=
CompilationTarget
:
:
StandaloneFunctionInNonSyntacticScope
|
|
target
=
=
CompilationTarget
:
:
Eval
|
|
target
=
=
CompilationTarget
:
:
Delazification
;
}
Scope
*
maybeNonDefaultEnclosingScope
(
)
const
{
if
(
hasNonDefaultEnclosingScope
(
)
)
{
return
enclosingScope
;
}
return
nullptr
;
}
ScriptSource
*
source
(
)
{
return
source_
.
get
(
)
;
}
void
setSource
(
ScriptSource
*
ss
)
{
return
source_
.
reset
(
ss
)
;
}
template
<
typename
Unit
>
MOZ_MUST_USE
bool
assignSource
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
sourceBuffer
)
{
return
source
(
)
-
>
assignSource
(
cx
options
sourceBuffer
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
JS_HAZ_GC_POINTER
;
struct
CompilationStencil
;
struct
MOZ_RAII
CompilationState
{
Directives
directives
;
ScopeContext
scopeContext
;
UsedNameTracker
usedNames
;
LifoAllocScope
&
allocScope
;
CompilationInput
&
input
;
Vector
<
RegExpStencil
0
js
:
:
SystemAllocPolicy
>
regExpData
;
Vector
<
BigIntStencil
0
js
:
:
SystemAllocPolicy
>
bigIntData
;
Vector
<
ObjLiteralStencil
0
js
:
:
SystemAllocPolicy
>
objLiteralData
;
Vector
<
ScriptStencil
0
js
:
:
SystemAllocPolicy
>
scriptData
;
Vector
<
ScriptStencilExtra
0
js
:
:
SystemAllocPolicy
>
scriptExtra
;
Vector
<
ScopeStencil
0
js
:
:
SystemAllocPolicy
>
scopeData
;
Vector
<
BaseParserScopeData
*
0
js
:
:
SystemAllocPolicy
>
scopeNames
;
Vector
<
TaggedScriptThingIndex
0
js
:
:
SystemAllocPolicy
>
gcThingData
;
ParserAtomsTable
parserAtoms
;
size_t
nonLazyFunctionCount
=
0
;
CompilationState
(
JSContext
*
cx
LifoAllocScope
&
frontendAllocScope
const
JS
:
:
ReadOnlyCompileOptions
&
options
CompilationStencil
&
stencil
)
;
bool
init
(
JSContext
*
cx
InheritThis
inheritThis
=
InheritThis
:
:
No
JSObject
*
enclosingEnv
=
nullptr
)
{
return
scopeContext
.
init
(
cx
input
parserAtoms
inheritThis
enclosingEnv
)
;
}
bool
finish
(
JSContext
*
cx
CompilationStencil
&
stencil
)
;
bool
allocateGCThingsUninitialized
(
JSContext
*
cx
ScriptIndex
scriptIndex
size_t
length
TaggedScriptThingIndex
*
*
cursor
)
;
bool
appendGCThings
(
JSContext
*
cx
ScriptIndex
scriptIndex
mozilla
:
:
Span
<
const
TaggedScriptThingIndex
>
things
)
;
}
;
struct
SharedDataContainer
{
using
SingleSharedDataPtr
=
SharedImmutableScriptData
*
;
using
SharedDataVector
=
Vector
<
RefPtr
<
js
:
:
SharedImmutableScriptData
>
0
js
:
:
SystemAllocPolicy
>
;
using
SharedDataVectorPtr
=
SharedDataVector
*
;
using
SharedDataMap
=
HashMap
<
ScriptIndex
RefPtr
<
js
:
:
SharedImmutableScriptData
>
mozilla
:
:
DefaultHasher
<
ScriptIndex
>
js
:
:
SystemAllocPolicy
>
;
using
SharedDataMapPtr
=
SharedDataMap
*
;
private
:
enum
{
SingleTag
=
0
VectorTag
=
1
MapTag
=
2
TagMask
=
3
}
;
uintptr_t
data_
=
0
;
public
:
SharedDataContainer
(
)
=
default
;
~
SharedDataContainer
(
)
;
bool
initVector
(
JSContext
*
cx
)
;
bool
initMap
(
JSContext
*
cx
)
;
bool
isEmpty
(
)
const
{
return
(
data_
)
=
=
SingleTag
;
}
bool
isSingle
(
)
const
{
return
(
data_
&
TagMask
)
=
=
SingleTag
;
}
bool
isVector
(
)
const
{
return
(
data_
&
TagMask
)
=
=
VectorTag
;
}
bool
isMap
(
)
const
{
return
(
data_
&
TagMask
)
=
=
MapTag
;
}
void
setSingle
(
already_AddRefed
<
SharedImmutableScriptData
>
&
&
data
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
data_
=
reinterpret_cast
<
uintptr_t
>
(
data
.
take
(
)
)
;
MOZ_ASSERT
(
isSingle
(
)
)
;
}
SingleSharedDataPtr
asSingle
(
)
const
{
MOZ_ASSERT
(
isSingle
(
)
)
;
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
static_assert
(
SingleTag
=
=
0
)
;
return
reinterpret_cast
<
SingleSharedDataPtr
>
(
data_
)
;
}
SharedDataVectorPtr
asVector
(
)
const
{
MOZ_ASSERT
(
isVector
(
)
)
;
return
reinterpret_cast
<
SharedDataVectorPtr
>
(
data_
&
~
TagMask
)
;
}
SharedDataMapPtr
asMap
(
)
const
{
MOZ_ASSERT
(
isMap
(
)
)
;
return
reinterpret_cast
<
SharedDataMapPtr
>
(
data_
&
~
TagMask
)
;
}
bool
prepareStorageFor
(
JSContext
*
cx
size_t
nonLazyScriptCount
size_t
allScriptCount
)
;
js
:
:
SharedImmutableScriptData
*
get
(
ScriptIndex
index
)
const
;
bool
addAndShare
(
JSContext
*
cx
ScriptIndex
index
js
:
:
SharedImmutableScriptData
*
data
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
struct
BaseCompilationStencil
{
mozilla
:
:
Span
<
RegExpStencil
>
regExpData
;
mozilla
:
:
Span
<
BigIntStencil
>
bigIntData
;
mozilla
:
:
Span
<
ObjLiteralStencil
>
objLiteralData
;
mozilla
:
:
Span
<
ScriptStencil
>
scriptData
;
SharedDataContainer
sharedData
;
mozilla
:
:
Span
<
TaggedScriptThingIndex
>
gcThingData
;
mozilla
:
:
Span
<
ScopeStencil
>
scopeData
;
mozilla
:
:
Span
<
BaseParserScopeData
*
>
scopeNames
;
ParserAtomSpan
parserAtomData
;
using
FunctionKey
=
uint32_t
;
static
constexpr
FunctionKey
NullFunctionKey
=
0
;
FunctionKey
functionKey
=
NullFunctionKey
;
BaseCompilationStencil
(
)
=
default
;
BaseCompilationStencil
(
BaseCompilationStencil
&
&
other
)
=
default
;
bool
prepareStorageFor
(
JSContext
*
cx
CompilationState
&
compilationState
)
{
MOZ_ASSERT
(
scriptData
.
empty
(
)
)
;
size_t
allScriptCount
=
compilationState
.
scriptData
.
length
(
)
;
size_t
nonLazyScriptCount
=
compilationState
.
nonLazyFunctionCount
;
if
(
!
compilationState
.
scriptData
[
0
]
.
isFunction
(
)
)
{
nonLazyScriptCount
+
+
;
}
return
sharedData
.
prepareStorageFor
(
cx
nonLazyScriptCount
allScriptCount
)
;
}
static
FunctionKey
toFunctionKey
(
const
SourceExtent
&
extent
)
{
auto
result
=
extent
.
sourceStart
+
1
;
MOZ_ASSERT
(
result
!
=
NullFunctionKey
)
;
return
result
;
}
bool
isInitialStencil
(
)
const
{
return
functionKey
=
=
NullFunctionKey
;
}
inline
CompilationStencil
&
asCompilationStencil
(
)
;
inline
const
CompilationStencil
&
asCompilationStencil
(
)
const
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpAtom
(
TaggedParserAtomIndex
index
)
const
;
#
endif
}
;
struct
CompilationGCOutput
{
JSScript
*
script
=
nullptr
;
ModuleObject
*
module
=
nullptr
;
JS
:
:
GCVector
<
JSFunction
*
0
js
:
:
SystemAllocPolicy
>
functions
;
JS
:
:
GCVector
<
js
:
:
Scope
*
0
js
:
:
SystemAllocPolicy
>
scopes
;
ScriptSourceObject
*
sourceObject
=
nullptr
;
CompilationGCOutput
(
)
=
default
;
void
trace
(
JSTracer
*
trc
)
;
}
JS_HAZ_GC_POINTER
;
class
ScriptStencilIterable
{
public
:
class
ScriptAndFunction
{
public
:
const
ScriptStencil
&
script
;
const
ScriptStencilExtra
*
scriptExtra
;
JSFunction
*
function
;
ScriptIndex
index
;
ScriptAndFunction
(
)
=
delete
;
ScriptAndFunction
(
const
ScriptStencil
&
script
const
ScriptStencilExtra
*
scriptExtra
JSFunction
*
function
ScriptIndex
index
)
:
script
(
script
)
scriptExtra
(
scriptExtra
)
function
(
function
)
index
(
index
)
{
}
}
;
class
Iterator
{
size_t
index_
=
0
;
const
BaseCompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
Iterator
(
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
size_t
index
)
:
index_
(
index
)
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
MOZ_ASSERT
(
index
=
=
stencil
.
scriptData
.
size
(
)
)
;
}
public
:
explicit
Iterator
(
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
skipTopLevelNonFunction
(
)
;
}
Iterator
operator
+
+
(
)
{
next
(
)
;
assertFunction
(
)
;
return
*
this
;
}
void
next
(
)
{
MOZ_ASSERT
(
index_
<
stencil_
.
scriptData
.
size
(
)
)
;
index_
+
+
;
}
void
assertFunction
(
)
{
if
(
index_
<
stencil_
.
scriptData
.
size
(
)
)
{
MOZ_ASSERT
(
stencil_
.
scriptData
[
index_
]
.
isFunction
(
)
)
;
}
}
void
skipTopLevelNonFunction
(
)
{
MOZ_ASSERT
(
index_
=
=
0
)
;
if
(
stencil_
.
scriptData
.
size
(
)
)
{
if
(
!
stencil_
.
scriptData
[
0
]
.
isFunction
(
)
)
{
next
(
)
;
assertFunction
(
)
;
}
}
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
index_
!
=
other
.
index_
;
}
inline
ScriptAndFunction
operator
*
(
)
;
static
Iterator
end
(
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
{
return
Iterator
(
stencil
gcOutput
stencil
.
scriptData
.
size
(
)
)
;
}
}
;
const
BaseCompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
explicit
ScriptStencilIterable
(
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
}
Iterator
begin
(
)
const
{
return
Iterator
(
stencil_
gcOutput_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
:
:
end
(
stencil_
gcOutput_
)
;
}
}
;
struct
CompilationStencil
:
public
BaseCompilationStencil
{
static
constexpr
ScriptIndex
TopLevelIndex
=
ScriptIndex
(
0
)
;
LifoAlloc
alloc
;
static
constexpr
size_t
LifoAllocChunkSize
=
512
;
CompilationInput
input
;
mozilla
:
:
Span
<
ScriptStencilExtra
>
scriptExtra
;
mozilla
:
:
Maybe
<
StencilModuleMetadata
>
moduleMetadata
;
HashMap
<
ScriptIndex
RefPtr
<
const
JS
:
:
WasmModule
>
mozilla
:
:
DefaultHasher
<
ScriptIndex
>
js
:
:
SystemAllocPolicy
>
asmJS
;
bool
preparationIsPerformed
=
false
;
struct
RewindToken
{
size_t
scriptDataLength
=
0
;
size_t
asmJSCount
=
0
;
}
;
RewindToken
getRewindToken
(
CompilationState
&
state
)
;
void
rewind
(
CompilationState
&
state
const
RewindToken
&
pos
)
;
CompilationStencil
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
alloc
(
LifoAllocChunkSize
)
input
(
options
)
{
}
static
MOZ_MUST_USE
bool
prepareInputAndStencilForInstantiate
(
JSContext
*
cx
CompilationInput
&
input
BaseCompilationStencil
&
stencil
)
;
static
MOZ_MUST_USE
bool
prepareGCOutputForInstantiate
(
JSContext
*
cx
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
static
MOZ_MUST_USE
bool
prepareForInstantiate
(
JSContext
*
cx
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
static
MOZ_MUST_USE
bool
instantiateStencils
(
JSContext
*
cx
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
static
MOZ_MUST_USE
bool
instantiateStencilsAfterPreparation
(
JSContext
*
cx
CompilationInput
&
input
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
;
MOZ_MUST_USE
bool
serializeStencils
(
JSContext
*
cx
JS
:
:
TranscodeBuffer
&
buf
bool
*
succeededOut
=
nullptr
)
;
CompilationStencil
(
CompilationStencil
&
&
other
)
noexcept
:
BaseCompilationStencil
(
std
:
:
move
(
other
)
)
alloc
(
LifoAllocChunkSize
)
input
(
std
:
:
move
(
other
.
input
)
)
{
alloc
.
steal
(
&
other
.
alloc
)
;
}
CompilationStencil
(
const
CompilationStencil
&
)
=
delete
;
CompilationStencil
&
operator
=
(
const
CompilationStencil
&
)
=
delete
;
CompilationStencil
&
operator
=
(
CompilationStencil
&
&
)
=
delete
;
static
ScriptStencilIterable
functionScriptStencils
(
const
BaseCompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
{
return
ScriptStencilIterable
(
stencil
gcOutput
)
;
}
void
setFunctionKey
(
BaseScript
*
lazy
)
{
functionKey
=
toFunctionKey
(
lazy
-
>
extent
(
)
)
;
}
void
trace
(
JSTracer
*
trc
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
const
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
const
;
void
dumpFields
(
js
:
:
JSONPrinter
&
json
)
const
;
#
endif
}
;
inline
CompilationStencil
&
BaseCompilationStencil
:
:
asCompilationStencil
(
)
{
MOZ_ASSERT
(
isInitialStencil
(
)
"
cast
from
BaseCompilationStencil
to
CompilationStencil
is
"
"
allowed
only
for
initial
stencil
"
)
;
return
*
static_cast
<
CompilationStencil
*
>
(
this
)
;
}
inline
const
CompilationStencil
&
BaseCompilationStencil
:
:
asCompilationStencil
(
)
const
{
MOZ_ASSERT
(
isInitialStencil
(
)
"
cast
from
BaseCompilationStencil
to
CompilationStencil
is
"
"
allowed
only
for
initial
stencil
"
)
;
return
*
static_cast
<
const
CompilationStencil
*
>
(
this
)
;
}
inline
ScriptStencilIterable
:
:
ScriptAndFunction
ScriptStencilIterable
:
:
Iterator
:
:
operator
*
(
)
{
ScriptIndex
index
=
ScriptIndex
(
index_
)
;
const
ScriptStencil
&
script
=
stencil_
.
scriptData
[
index
]
;
const
ScriptStencilExtra
*
scriptExtra
=
nullptr
;
if
(
stencil_
.
isInitialStencil
(
)
)
{
scriptExtra
=
&
stencil_
.
asCompilationStencil
(
)
.
scriptExtra
[
index
]
;
}
return
ScriptAndFunction
(
script
scriptExtra
gcOutput_
.
functions
[
index
]
index
)
;
}
struct
CompilationStencilSet
:
public
CompilationStencil
{
private
:
using
ScriptIndexVector
=
Vector
<
ScriptIndex
0
js
:
:
SystemAllocPolicy
>
;
MOZ_MUST_USE
bool
buildDelazificationIndices
(
JSContext
*
cx
)
;
public
:
Vector
<
BaseCompilationStencil
0
js
:
:
SystemAllocPolicy
>
delazifications
;
ScriptIndexVector
delazificationIndices
;
CompilationAtomCache
:
:
AtomCacheVector
delazificationAtomCache
;
CompilationStencilSet
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
CompilationStencil
(
cx
options
)
{
}
CompilationStencilSet
(
CompilationStencilSet
&
&
other
)
=
default
;
CompilationStencilSet
(
const
CompilationStencilSet
&
)
=
delete
;
CompilationStencilSet
&
operator
=
(
const
CompilationStencilSet
&
)
=
delete
;
CompilationStencilSet
&
operator
=
(
CompilationStencilSet
&
&
)
=
delete
;
MOZ_MUST_USE
bool
prepareForInstantiate
(
JSContext
*
cx
CompilationGCOutput
&
gcOutput
CompilationGCOutput
&
gcOutputForDelazification
)
;
MOZ_MUST_USE
bool
instantiateStencils
(
JSContext
*
cx
CompilationGCOutput
&
gcOutput
CompilationGCOutput
&
gcOutputForDelazification
)
;
MOZ_MUST_USE
bool
instantiateStencilsAfterPreparation
(
JSContext
*
cx
CompilationGCOutput
&
gcOutput
CompilationGCOutput
&
gcOutputForDelazification
)
;
MOZ_MUST_USE
bool
deserializeStencils
(
JSContext
*
cx
const
JS
:
:
TranscodeRange
&
range
bool
*
succeededOut
)
;
}
;
}
}
#
endif
