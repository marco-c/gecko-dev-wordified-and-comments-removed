#
ifndef
frontend_CompilationInfo_h
#
define
frontend_CompilationInfo_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
UsedNameTracker
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RealmOptions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
js
/
WasmModule
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Realm
.
h
"
namespace
js
{
class
JSONPrinter
;
namespace
frontend
{
struct
ScopeContext
{
bool
allowNewTarget
=
false
;
bool
allowSuperProperty
=
false
;
bool
allowSuperCall
=
false
;
bool
allowArguments
=
true
;
ThisBinding
thisBinding
=
ThisBinding
:
:
Global
;
bool
inWith
=
false
;
bool
inClass
=
false
;
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
=
{
}
;
JS
:
:
Rooted
<
Scope
*
>
effectiveScope
;
explicit
ScopeContext
(
JSContext
*
cx
Scope
*
scope
JSObject
*
enclosingEnv
=
nullptr
)
:
effectiveScope
(
cx
determineEffectiveScope
(
scope
enclosingEnv
)
)
{
computeAllowSyntax
(
scope
)
;
computeThisBinding
(
effectiveScope
)
;
computeInWith
(
scope
)
;
computeExternalInitializers
(
scope
)
;
computeInClass
(
scope
)
;
}
private
:
void
computeAllowSyntax
(
Scope
*
scope
)
;
void
computeThisBinding
(
Scope
*
scope
)
;
void
computeInWith
(
Scope
*
scope
)
;
void
computeExternalInitializers
(
Scope
*
scope
)
;
void
computeInClass
(
Scope
*
scope
)
;
static
Scope
*
determineEffectiveScope
(
Scope
*
scope
JSObject
*
environment
)
;
}
;
struct
CompilationAtomCache
{
JS
:
:
GCVector
<
JSAtom
*
0
js
:
:
SystemAllocPolicy
>
atoms
;
void
trace
(
JSTracer
*
trc
)
;
}
JS_HAZ_GC_POINTER
;
struct
CompilationInput
{
const
JS
:
:
ReadOnlyCompileOptions
&
options
;
CompilationAtomCache
atomCache
;
BaseScript
*
lazy
=
nullptr
;
ScriptSourceHolder
source_
;
Scope
*
enclosingScope
=
nullptr
;
explicit
CompilationInput
(
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
options
(
options
)
{
}
private
:
bool
initScriptSource
(
JSContext
*
cx
)
;
public
:
bool
initForGlobal
(
JSContext
*
cx
)
{
return
initScriptSource
(
cx
)
;
}
bool
initForSelfHostingGlobal
(
JSContext
*
cx
)
{
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
&
cx
-
>
global
(
)
-
>
emptyGlobalScope
(
)
;
return
true
;
}
bool
initForStandaloneFunction
(
JSContext
*
cx
HandleScope
functionEnclosingScope
)
{
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
functionEnclosingScope
;
return
true
;
}
bool
initForEval
(
JSContext
*
cx
HandleScope
evalEnclosingScope
)
{
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
enclosingScope
=
evalEnclosingScope
;
return
true
;
}
bool
initForModule
(
JSContext
*
cx
)
{
if
(
!
initScriptSource
(
cx
)
)
{
return
false
;
}
return
true
;
}
void
initFromLazy
(
BaseScript
*
lazyScript
)
{
lazy
=
lazyScript
;
enclosingScope
=
lazy
-
>
function
(
)
-
>
enclosingScope
(
)
;
}
ScriptSource
*
source
(
)
{
return
source_
.
get
(
)
;
}
private
:
void
setSource
(
ScriptSource
*
ss
)
{
return
source_
.
reset
(
ss
)
;
}
public
:
template
<
typename
Unit
>
MOZ_MUST_USE
bool
assignSource
(
JSContext
*
cx
JS
:
:
SourceText
<
Unit
>
&
sourceBuffer
)
{
return
source
(
)
-
>
assignSource
(
cx
options
sourceBuffer
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
JS_HAZ_GC_POINTER
;
struct
MOZ_RAII
CompilationState
{
Directives
directives
;
ScopeContext
scopeContext
;
UsedNameTracker
usedNames
;
LifoAllocScope
&
allocScope
;
CompilationState
(
JSContext
*
cx
LifoAllocScope
&
alloc
const
JS
:
:
ReadOnlyCompileOptions
&
options
Scope
*
enclosingScope
=
nullptr
JSObject
*
enclosingEnv
=
nullptr
)
:
directives
(
options
.
forceStrictMode
(
)
)
scopeContext
(
cx
enclosingScope
enclosingEnv
)
usedNames
(
cx
)
allocScope
(
alloc
)
{
}
}
;
struct
CompilationStencil
{
Vector
<
RegExpStencil
0
js
:
:
SystemAllocPolicy
>
regExpData
;
Vector
<
BigIntStencil
0
js
:
:
SystemAllocPolicy
>
bigIntData
;
Vector
<
ObjLiteralStencil
0
js
:
:
SystemAllocPolicy
>
objLiteralData
;
Vector
<
ScriptStencil
0
js
:
:
SystemAllocPolicy
>
scriptData
;
Vector
<
ScopeStencil
0
js
:
:
SystemAllocPolicy
>
scopeData
;
StencilModuleMetadata
moduleMetadata
;
HashMap
<
FunctionIndex
RefPtr
<
const
JS
:
:
WasmModule
>
mozilla
:
:
DefaultHasher
<
FunctionIndex
>
js
:
:
SystemAllocPolicy
>
asmJS
;
ParserAtomsTable
parserAtoms
;
explicit
CompilationStencil
(
JSRuntime
*
rt
)
:
parserAtoms
(
rt
)
{
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
dump
(
)
;
void
dump
(
js
:
:
JSONPrinter
&
json
)
;
#
endif
}
;
struct
MOZ_RAII
CompilationGCOutput
{
JS
:
:
Rooted
<
JSScript
*
>
script
;
JS
:
:
Rooted
<
ModuleObject
*
>
module
;
JS
:
:
RootedVector
<
JSFunction
*
>
functions
;
JS
:
:
RootedVector
<
js
:
:
Scope
*
>
scopes
;
JS
:
:
Rooted
<
ScriptSourceObject
*
>
sourceObject
;
explicit
CompilationGCOutput
(
JSContext
*
cx
)
:
script
(
cx
)
module
(
cx
)
functions
(
cx
)
scopes
(
cx
)
sourceObject
(
cx
)
{
}
}
;
class
ScriptStencilIterable
{
public
:
class
ScriptAndFunction
{
public
:
const
ScriptStencil
&
script
;
HandleFunction
function
;
FunctionIndex
functionIndex
;
ScriptAndFunction
(
)
=
delete
;
ScriptAndFunction
(
const
ScriptStencil
&
script
HandleFunction
function
FunctionIndex
functionIndex
)
:
script
(
script
)
function
(
function
)
functionIndex
(
functionIndex
)
{
}
}
;
class
Iterator
{
size_t
index_
=
0
;
const
CompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
Iterator
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
size_t
index
)
:
index_
(
index
)
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
skipNonFunctions
(
)
;
}
public
:
explicit
Iterator
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
skipNonFunctions
(
)
;
}
Iterator
operator
+
+
(
)
{
next
(
)
;
skipNonFunctions
(
)
;
return
*
this
;
}
void
next
(
)
{
MOZ_ASSERT
(
index_
<
stencil_
.
scriptData
.
length
(
)
)
;
index_
+
+
;
}
void
skipNonFunctions
(
)
{
size_t
length
=
stencil_
.
scriptData
.
length
(
)
;
while
(
index_
<
length
)
{
if
(
stencil_
.
scriptData
[
index_
]
.
isFunction
(
)
)
{
return
;
}
index_
+
+
;
}
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
index_
!
=
other
.
index_
;
}
ScriptAndFunction
operator
*
(
)
{
const
ScriptStencil
&
script
=
stencil_
.
scriptData
[
index_
]
;
FunctionIndex
functionIndex
=
FunctionIndex
(
index_
)
;
return
ScriptAndFunction
(
script
gcOutput_
.
functions
[
functionIndex
]
functionIndex
)
;
}
static
Iterator
end
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
{
return
Iterator
(
stencil
gcOutput
stencil
.
scriptData
.
length
(
)
)
;
}
}
;
const
CompilationStencil
&
stencil_
;
CompilationGCOutput
&
gcOutput_
;
explicit
ScriptStencilIterable
(
const
CompilationStencil
&
stencil
CompilationGCOutput
&
gcOutput
)
:
stencil_
(
stencil
)
gcOutput_
(
gcOutput
)
{
}
Iterator
begin
(
)
const
{
return
Iterator
(
stencil_
gcOutput_
)
;
}
Iterator
end
(
)
const
{
return
Iterator
:
:
end
(
stencil_
gcOutput_
)
;
}
}
;
struct
CompilationInfo
{
static
constexpr
FunctionIndex
TopLevelIndex
=
FunctionIndex
(
0
)
;
CompilationInput
input
;
CompilationStencil
stencil
;
struct
RewindToken
{
size_t
scriptDataLength
=
0
;
size_t
asmJSCount
=
0
;
}
;
RewindToken
getRewindToken
(
)
;
void
rewind
(
const
RewindToken
&
pos
)
;
CompilationInfo
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
input
(
options
)
stencil
(
cx
-
>
runtime
(
)
)
{
}
MOZ_MUST_USE
bool
instantiateStencils
(
JSContext
*
cx
CompilationGCOutput
&
gcOutput
)
;
MOZ_MUST_USE
bool
serializeStencils
(
JSContext
*
cx
JS
:
:
TranscodeBuffer
&
buf
bool
*
succeededOut
=
nullptr
)
;
const
ParserAtom
*
lowerJSAtomToParserAtom
(
JSContext
*
cx
JSAtom
*
atom
)
{
auto
result
=
stencil
.
parserAtoms
.
internJSAtom
(
cx
*
this
atom
)
;
return
result
.
unwrapOr
(
nullptr
)
;
}
CompilationInfo
(
CompilationInfo
&
&
)
=
default
;
CompilationInfo
(
const
CompilationInfo
&
)
=
delete
;
CompilationInfo
&
operator
=
(
const
CompilationInfo
&
)
=
delete
;
CompilationInfo
&
operator
=
(
CompilationInfo
&
&
)
=
delete
;
ScriptStencilIterable
functionScriptStencils
(
CompilationGCOutput
&
gcOutput
)
{
return
ScriptStencilIterable
(
stencil
gcOutput
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
struct
CompilationInfoVector
{
private
:
using
FunctionKey
=
uint64_t
;
using
FunctionMap
=
HashMap
<
FunctionKey
FunctionIndex
>
;
static
FunctionKey
toFunctionKey
(
const
SourceExtent
&
extent
)
{
return
(
FunctionKey
)
extent
.
sourceStart
<
<
32
|
extent
.
sourceEnd
;
}
MOZ_MUST_USE
bool
buildDelazificationStencilMap
(
FunctionMap
&
functionMap
)
;
public
:
frontend
:
:
CompilationInfo
initial
;
GCVector
<
frontend
:
:
CompilationInfo
0
js
:
:
SystemAllocPolicy
>
delazifications
;
CompilationInfoVector
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
initial
(
cx
options
)
{
}
CompilationInfoVector
(
CompilationInfoVector
&
&
)
=
default
;
CompilationInfoVector
(
const
CompilationInfoVector
&
)
=
delete
;
CompilationInfoVector
&
operator
=
(
const
CompilationInfoVector
&
)
=
delete
;
CompilationInfoVector
&
operator
=
(
CompilationInfoVector
&
&
)
=
delete
;
MOZ_MUST_USE
bool
instantiateStencils
(
JSContext
*
cx
CompilationGCOutput
&
gcOutput
)
;
MOZ_MUST_USE
bool
deserializeStencils
(
JSContext
*
cx
const
JS
:
:
TranscodeRange
&
range
bool
*
succeededOut
)
;
void
trace
(
JSTracer
*
trc
)
;
}
;
}
}
#
endif
