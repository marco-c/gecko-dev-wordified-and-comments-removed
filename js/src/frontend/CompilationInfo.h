#
ifndef
frontend_CompilationInfo_h
#
define
frontend_CompilationInfo_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
frontend
/
UsedNameTracker
.
h
"
#
include
"
js
/
GCVariant
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RealmOptions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
js
/
WasmModule
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
namespace
js
{
namespace
frontend
{
struct
ScopeContext
{
bool
allowNewTarget
=
false
;
bool
allowSuperProperty
=
false
;
bool
allowSuperCall
=
false
;
bool
allowArguments
=
true
;
ThisBinding
thisBinding
=
ThisBinding
:
:
Global
;
bool
inWith
=
false
;
bool
inClass
=
false
;
mozilla
:
:
Maybe
<
FieldInitializers
>
fieldInitializers
=
{
}
;
explicit
ScopeContext
(
Scope
*
scope
JSObject
*
enclosingEnv
=
nullptr
)
{
computeAllowSyntax
(
scope
)
;
computeThisBinding
(
scope
enclosingEnv
)
;
computeInWith
(
scope
)
;
computeExternalInitializers
(
scope
)
;
computeInClass
(
scope
)
;
}
private
:
void
computeAllowSyntax
(
Scope
*
scope
)
;
void
computeThisBinding
(
Scope
*
scope
JSObject
*
environment
=
nullptr
)
;
void
computeInWith
(
Scope
*
scope
)
;
void
computeExternalInitializers
(
Scope
*
scope
)
;
void
computeInClass
(
Scope
*
scope
)
;
}
;
struct
MOZ_RAII
CompilationInfo
:
public
JS
:
:
CustomAutoRooter
{
JSContext
*
cx
;
const
JS
:
:
ReadOnlyCompileOptions
&
options
;
AutoKeepAtoms
keepAtoms
;
ParserAtomsTable
parserAtoms
;
Directives
directives
;
ScopeContext
scopeContext
;
FunctionBox
*
traceListHead
=
nullptr
;
JS
:
:
Rooted
<
JSScript
*
>
script
;
JS
:
:
Rooted
<
BaseScript
*
>
lazy
;
UsedNameTracker
usedNames
;
LifoAllocScope
&
allocScope
;
Vector
<
RegExpCreationData
>
regExpData
;
Vector
<
BigIntCreationData
>
bigIntData
;
JS
:
:
RootedVector
<
JSFunction
*
>
functions
;
JS
:
:
RootedVector
<
ScriptStencil
>
funcData
;
JS
:
:
Rooted
<
ScriptStencil
>
topLevel
;
JS
:
:
RootedVector
<
ScopeCreationData
>
scopeCreationData
;
HashMap
<
FunctionIndex
RefPtr
<
const
JS
:
:
WasmModule
>
>
asmJS
;
JS
:
:
Rooted
<
ScriptSourceObject
*
>
sourceObject
;
struct
RewindToken
{
FunctionBox
*
funbox
=
nullptr
;
size_t
funcDataLength
=
0
;
}
;
RewindToken
getRewindToken
(
)
;
void
rewind
(
const
RewindToken
&
pos
)
;
CompilationInfo
(
JSContext
*
cx
LifoAllocScope
&
alloc
const
JS
:
:
ReadOnlyCompileOptions
&
options
Scope
*
enclosingScope
=
nullptr
JSObject
*
enclosingEnv
=
nullptr
)
:
JS
:
:
CustomAutoRooter
(
cx
)
cx
(
cx
)
options
(
options
)
keepAtoms
(
cx
)
parserAtoms
(
cx
)
directives
(
options
.
forceStrictMode
(
)
)
scopeContext
(
enclosingScope
enclosingEnv
)
script
(
cx
)
lazy
(
cx
)
usedNames
(
cx
)
allocScope
(
alloc
)
regExpData
(
cx
)
bigIntData
(
cx
)
functions
(
cx
)
funcData
(
cx
)
topLevel
(
cx
)
scopeCreationData
(
cx
)
asmJS
(
cx
)
sourceObject
(
cx
)
{
}
bool
init
(
JSContext
*
cx
)
;
void
initFromLazy
(
BaseScript
*
lazy
)
{
this
-
>
lazy
=
lazy
;
this
-
>
sourceObject
=
lazy
-
>
sourceObject
(
)
;
}
template
<
typename
Unit
>
MOZ_MUST_USE
bool
assignSource
(
JS
:
:
SourceText
<
Unit
>
&
sourceBuffer
)
{
return
sourceObject
-
>
source
(
)
-
>
assignSource
(
cx
options
sourceBuffer
)
;
}
MOZ_MUST_USE
bool
instantiateStencils
(
)
;
void
trace
(
JSTracer
*
trc
)
final
;
CompilationInfo
(
const
CompilationInfo
&
)
=
delete
;
CompilationInfo
(
CompilationInfo
&
&
)
=
delete
;
CompilationInfo
&
operator
=
(
const
CompilationInfo
&
)
=
delete
;
CompilationInfo
&
operator
=
(
CompilationInfo
&
&
)
=
delete
;
}
;
}
}
#
endif
