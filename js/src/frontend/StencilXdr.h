#
ifndef
frontend_StencilXdr_h
#
define
frontend_StencilXdr_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
frontend
/
CompilationStencil
.
h
"
#
include
"
frontend
/
ObjLiteral
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
Xdr
.
h
"
namespace
JS
{
class
DecodeOptions
;
}
namespace
js
{
class
LifoAlloc
;
class
ScriptSource
;
namespace
frontend
{
template
<
typename
DataT
>
struct
CanCopyDataToDisk
{
#
ifdef
__cpp_lib_has_unique_object_representations
static
constexpr
bool
unique_repr
=
std
:
:
has_unique_object_representations
<
DataT
>
(
)
;
#
else
static
constexpr
bool
unique_repr
=
true
;
#
endif
static
constexpr
bool
no_pointer
=
alignof
(
DataT
)
<
alignof
(
void
*
)
|
|
sizeof
(
void
*
)
=
=
sizeof
(
uint32_t
)
;
static
constexpr
bool
value
=
unique_repr
&
&
no_pointer
;
}
;
class
StencilXDR
{
private
:
template
<
XDRMode
mode
>
[
[
nodiscard
]
]
static
XDRResult
codeSourceUnretrievableUncompressed
(
XDRState
<
mode
>
*
xdr
ScriptSource
*
ss
uint8_t
sourceCharSize
uint32_t
uncompressedLength
)
;
template
<
typename
Unit
template
<
typename
U
SourceRetrievable
CanRetrieve
>
class
Data
XDRMode
mode
>
static
void
codeSourceRetrievable
(
ScriptSource
*
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
[
[
nodiscard
]
]
static
XDRResult
codeSourceUncompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
[
[
nodiscard
]
]
static
XDRResult
codeSourceCompressedData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
template
<
typename
Unit
XDRMode
mode
>
static
void
codeSourceRetrievableData
(
ScriptSource
*
ss
)
;
template
<
XDRMode
mode
>
[
[
nodiscard
]
]
static
XDRResult
codeSourceData
(
XDRState
<
mode
>
*
const
xdr
ScriptSource
*
const
ss
)
;
public
:
template
<
XDRMode
mode
>
static
XDRResult
codeSource
(
XDRState
<
mode
>
*
xdr
const
JS
:
:
DecodeOptions
*
maybeOptions
RefPtr
<
ScriptSource
>
&
source
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeBigInt
(
XDRState
<
mode
>
*
xdr
LifoAlloc
&
alloc
BigIntStencil
&
stencil
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeObjLiteral
(
XDRState
<
mode
>
*
xdr
LifoAlloc
&
alloc
ObjLiteralStencil
&
stencil
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeScopeData
(
XDRState
<
mode
>
*
xdr
LifoAlloc
&
alloc
ScopeStencil
&
stencil
BaseParserScopeData
*
&
baseScopeData
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeSharedData
(
XDRState
<
mode
>
*
xdr
RefPtr
<
SharedImmutableScriptData
>
&
sisd
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeSharedDataContainer
(
XDRState
<
mode
>
*
xdr
SharedDataContainer
&
sharedData
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeParserAtom
(
XDRState
<
mode
>
*
xdr
LifoAlloc
&
alloc
ParserAtom
*
*
atomp
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeParserAtomSpan
(
XDRState
<
mode
>
*
xdr
LifoAlloc
&
alloc
ParserAtomSpan
&
parserAtomData
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeModuleEntry
(
XDRState
<
mode
>
*
xdr
StencilModuleEntry
&
stencil
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeModuleEntryVector
(
XDRState
<
mode
>
*
xdr
StencilModuleMetadata
:
:
EntryVector
&
vector
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeModuleMetadata
(
XDRState
<
mode
>
*
xdr
StencilModuleMetadata
&
stencil
)
;
static
XDRResult
checkCompilationStencil
(
XDRStencilEncoder
*
encoder
const
CompilationStencil
&
stencil
)
;
static
XDRResult
checkCompilationStencil
(
const
ExtensibleCompilationStencil
&
stencil
)
;
template
<
XDRMode
mode
>
static
XDRResult
codeCompilationStencil
(
XDRState
<
mode
>
*
xdr
CompilationStencil
&
stencil
)
;
}
;
}
}
#
endif
