#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
ctype
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jsexn
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
ReservedWords
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
util
/
Unicode
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
IsAscii
;
using
mozilla
:
:
IsAsciiAlpha
;
using
mozilla
:
:
IsAsciiDigit
;
using
mozilla
:
:
MakeScopeExit
;
using
mozilla
:
:
PodCopy
;
struct
ReservedWordInfo
{
const
char
*
chars
;
js
:
:
frontend
:
:
TokenKind
tokentype
;
}
;
static
const
ReservedWordInfo
reservedWords
[
]
=
{
#
define
RESERVED_WORD_INFO
(
word
name
type
)
\
{
js_
#
#
word
#
#
_str
js
:
:
frontend
:
:
type
}
FOR_EACH_JAVASCRIPT_RESERVED_WORD
(
RESERVED_WORD_INFO
)
#
undef
RESERVED_WORD_INFO
}
;
template
<
typename
CharT
>
static
const
ReservedWordInfo
*
FindReservedWord
(
const
CharT
*
s
size_t
length
)
{
MOZ_ASSERT
(
length
!
=
0
)
;
size_t
i
;
const
ReservedWordInfo
*
rw
;
const
char
*
chars
;
#
define
JSRW_LENGTH
(
)
length
#
define
JSRW_AT
(
column
)
s
[
column
]
#
define
JSRW_GOT_MATCH
(
index
)
i
=
(
index
)
;
goto
got_match
;
#
define
JSRW_TEST_GUESS
(
index
)
i
=
(
index
)
;
goto
test_guess
;
#
define
JSRW_NO_MATCH
(
)
goto
no_match
;
#
include
"
frontend
/
ReservedWordsGenerated
.
h
"
#
undef
JSRW_NO_MATCH
#
undef
JSRW_TEST_GUESS
#
undef
JSRW_GOT_MATCH
#
undef
JSRW_AT
#
undef
JSRW_LENGTH
got_match
:
return
&
reservedWords
[
i
]
;
test_guess
:
rw
=
&
reservedWords
[
i
]
;
chars
=
rw
-
>
chars
;
do
{
if
(
*
s
+
+
!
=
(
unsigned
char
)
(
*
chars
+
+
)
)
goto
no_match
;
}
while
(
-
-
length
!
=
0
)
;
return
rw
;
no_match
:
return
nullptr
;
}
static
const
ReservedWordInfo
*
FindReservedWord
(
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
return
str
-
>
hasLatin1Chars
(
)
?
FindReservedWord
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
:
FindReservedWord
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
;
}
template
<
typename
CharT
>
static
bool
IsIdentifier
(
const
CharT
*
chars
size_t
length
)
{
using
namespace
js
;
if
(
length
=
=
0
)
return
false
;
if
(
!
unicode
:
:
IsIdentifierStart
(
char16_t
(
*
chars
)
)
)
return
false
;
const
CharT
*
end
=
chars
+
length
;
while
(
+
+
chars
!
=
end
)
{
if
(
!
unicode
:
:
IsIdentifierPart
(
char16_t
(
*
chars
)
)
)
return
false
;
}
return
true
;
}
static
uint32_t
GetSingleCodePoint
(
const
char16_t
*
*
p
const
char16_t
*
end
)
{
using
namespace
js
;
uint32_t
codePoint
;
if
(
MOZ_UNLIKELY
(
unicode
:
:
IsLeadSurrogate
(
*
*
p
)
)
&
&
*
p
+
1
<
end
)
{
char16_t
lead
=
*
*
p
;
char16_t
maybeTrail
=
*
(
*
p
+
1
)
;
if
(
unicode
:
:
IsTrailSurrogate
(
maybeTrail
)
)
{
*
p
+
=
2
;
return
unicode
:
:
UTF16Decode
(
lead
maybeTrail
)
;
}
}
codePoint
=
*
*
p
;
(
*
p
)
+
+
;
return
codePoint
;
}
static
bool
IsIdentifierMaybeNonBMP
(
const
char16_t
*
chars
size_t
length
)
{
using
namespace
js
;
if
(
IsIdentifier
(
chars
length
)
)
return
true
;
if
(
length
=
=
0
)
return
false
;
const
char16_t
*
p
=
chars
;
const
char16_t
*
end
=
chars
+
length
;
uint32_t
codePoint
;
codePoint
=
GetSingleCodePoint
(
&
p
end
)
;
if
(
!
unicode
:
:
IsIdentifierStart
(
codePoint
)
)
return
false
;
while
(
p
<
end
)
{
codePoint
=
GetSingleCodePoint
(
&
p
end
)
;
if
(
!
unicode
:
:
IsIdentifierPart
(
codePoint
)
)
return
false
;
}
return
true
;
}
namespace
js
{
namespace
frontend
{
bool
IsIdentifier
(
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
MOZ_ASSERT
(
str
)
;
if
(
str
-
>
hasLatin1Chars
(
)
)
return
:
:
IsIdentifier
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
;
return
:
:
IsIdentifierMaybeNonBMP
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
;
}
bool
IsIdentifier
(
const
char
*
chars
size_t
length
)
{
return
:
:
IsIdentifier
(
chars
length
)
;
}
bool
IsIdentifier
(
const
char16_t
*
chars
size_t
length
)
{
return
:
:
IsIdentifier
(
chars
length
)
;
}
bool
IsKeyword
(
JSLinearString
*
str
)
{
if
(
const
ReservedWordInfo
*
rw
=
FindReservedWord
(
str
)
)
return
TokenKindIsKeyword
(
rw
-
>
tokentype
)
;
return
false
;
}
TokenKind
ReservedWordTokenKind
(
PropertyName
*
str
)
{
if
(
const
ReservedWordInfo
*
rw
=
FindReservedWord
(
str
)
)
return
rw
-
>
tokentype
;
return
TokenKind
:
:
Name
;
}
const
char
*
ReservedWordToCharZ
(
PropertyName
*
str
)
{
if
(
const
ReservedWordInfo
*
rw
=
FindReservedWord
(
str
)
)
return
ReservedWordToCharZ
(
rw
-
>
tokentype
)
;
return
nullptr
;
}
const
char
*
ReservedWordToCharZ
(
TokenKind
tt
)
{
MOZ_ASSERT
(
tt
!
=
TokenKind
:
:
Name
)
;
switch
(
tt
)
{
#
define
EMIT_CASE
(
word
name
type
)
case
type
:
return
js_
#
#
word
#
#
_str
;
FOR_EACH_JAVASCRIPT_RESERVED_WORD
(
EMIT_CASE
)
#
undef
EMIT_CASE
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
a
reserved
word
PropertyName
.
"
)
;
}
return
nullptr
;
}
PropertyName
*
TokenStreamAnyChars
:
:
reservedWordToPropertyName
(
TokenKind
tt
)
const
{
MOZ_ASSERT
(
tt
!
=
TokenKind
:
:
Name
)
;
switch
(
tt
)
{
#
define
EMIT_CASE
(
word
name
type
)
case
type
:
return
cx
-
>
names
(
)
.
name
;
FOR_EACH_JAVASCRIPT_RESERVED_WORD
(
EMIT_CASE
)
#
undef
EMIT_CASE
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
a
reserved
word
TokenKind
.
"
)
;
}
return
nullptr
;
}
TokenStreamAnyChars
:
:
SourceCoords
:
:
SourceCoords
(
JSContext
*
cx
uint32_t
ln
uint32_t
col
uint32_t
initialLineOffset
)
:
lineStartOffsets_
(
cx
)
initialLineNum_
(
ln
)
initialColumn_
(
col
)
lastLineIndex_
(
0
)
{
uint32_t
maxPtr
=
MAX_PTR
;
MOZ_ASSERT
(
lineStartOffsets_
.
capacity
(
)
>
=
2
)
;
MOZ_ALWAYS_TRUE
(
lineStartOffsets_
.
reserve
(
2
)
)
;
lineStartOffsets_
.
infallibleAppend
(
initialLineOffset
)
;
lineStartOffsets_
.
infallibleAppend
(
maxPtr
)
;
}
MOZ_ALWAYS_INLINE
bool
TokenStreamAnyChars
:
:
SourceCoords
:
:
add
(
uint32_t
lineNum
uint32_t
lineStartOffset
)
{
uint32_t
lineIndex
=
lineNumToIndex
(
lineNum
)
;
uint32_t
sentinelIndex
=
lineStartOffsets_
.
length
(
)
-
1
;
MOZ_ASSERT
(
lineStartOffsets_
[
0
]
<
=
lineStartOffset
&
&
lineStartOffsets_
[
sentinelIndex
]
=
=
MAX_PTR
)
;
if
(
lineIndex
=
=
sentinelIndex
)
{
uint32_t
maxPtr
=
MAX_PTR
;
if
(
!
lineStartOffsets_
.
append
(
maxPtr
)
)
{
static_assert
(
mozilla
:
:
IsSame
<
decltype
(
lineStartOffsets_
.
allocPolicy
(
)
)
TempAllocPolicy
&
>
:
:
value
"
this
function
'
s
caller
depends
on
it
reporting
an
"
"
error
on
failure
as
TempAllocPolicy
ensures
"
)
;
return
false
;
}
lineStartOffsets_
[
lineIndex
]
=
lineStartOffset
;
}
else
{
MOZ_ASSERT_IF
(
lineIndex
<
sentinelIndex
lineStartOffsets_
[
lineIndex
]
=
=
lineStartOffset
)
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
TokenStreamAnyChars
:
:
SourceCoords
:
:
fill
(
const
TokenStreamAnyChars
:
:
SourceCoords
&
other
)
{
MOZ_ASSERT
(
lineStartOffsets_
[
0
]
=
=
other
.
lineStartOffsets_
[
0
]
)
;
MOZ_ASSERT
(
lineStartOffsets_
.
back
(
)
=
=
MAX_PTR
)
;
MOZ_ASSERT
(
other
.
lineStartOffsets_
.
back
(
)
=
=
MAX_PTR
)
;
if
(
lineStartOffsets_
.
length
(
)
>
=
other
.
lineStartOffsets_
.
length
(
)
)
return
true
;
uint32_t
sentinelIndex
=
lineStartOffsets_
.
length
(
)
-
1
;
lineStartOffsets_
[
sentinelIndex
]
=
other
.
lineStartOffsets_
[
sentinelIndex
]
;
for
(
size_t
i
=
sentinelIndex
+
1
;
i
<
other
.
lineStartOffsets_
.
length
(
)
;
i
+
+
)
{
if
(
!
lineStartOffsets_
.
append
(
other
.
lineStartOffsets_
[
i
]
)
)
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
uint32_t
TokenStreamAnyChars
:
:
SourceCoords
:
:
lineIndexOf
(
uint32_t
offset
)
const
{
uint32_t
iMin
iMax
iMid
;
if
(
lineStartOffsets_
[
lastLineIndex_
]
<
=
offset
)
{
if
(
offset
<
lineStartOffsets_
[
lastLineIndex_
+
1
]
)
return
lastLineIndex_
;
lastLineIndex_
+
+
;
if
(
offset
<
lineStartOffsets_
[
lastLineIndex_
+
1
]
)
return
lastLineIndex_
;
lastLineIndex_
+
+
;
if
(
offset
<
lineStartOffsets_
[
lastLineIndex_
+
1
]
)
{
return
lastLineIndex_
;
}
iMin
=
lastLineIndex_
+
1
;
MOZ_ASSERT
(
iMin
<
lineStartOffsets_
.
length
(
)
-
1
)
;
}
else
{
iMin
=
0
;
}
iMax
=
lineStartOffsets_
.
length
(
)
-
2
;
while
(
iMax
>
iMin
)
{
iMid
=
iMin
+
(
iMax
-
iMin
)
/
2
;
if
(
offset
>
=
lineStartOffsets_
[
iMid
+
1
]
)
iMin
=
iMid
+
1
;
else
iMax
=
iMid
;
}
MOZ_ASSERT
(
iMax
=
=
iMin
)
;
MOZ_ASSERT
(
lineStartOffsets_
[
iMin
]
<
=
offset
&
&
offset
<
lineStartOffsets_
[
iMin
+
1
]
)
;
lastLineIndex_
=
iMin
;
return
iMin
;
}
uint32_t
TokenStreamAnyChars
:
:
SourceCoords
:
:
lineNum
(
uint32_t
offset
)
const
{
uint32_t
lineIndex
=
lineIndexOf
(
offset
)
;
return
lineIndexToNum
(
lineIndex
)
;
}
uint32_t
TokenStreamAnyChars
:
:
SourceCoords
:
:
columnIndex
(
uint32_t
offset
)
const
{
return
lineIndexAndOffsetToColumn
(
lineIndexOf
(
offset
)
offset
)
;
}
void
TokenStreamAnyChars
:
:
SourceCoords
:
:
lineNumAndColumnIndex
(
uint32_t
offset
uint32_t
*
lineNum
uint32_t
*
column
)
const
{
uint32_t
lineIndex
=
lineIndexOf
(
offset
)
;
*
lineNum
=
lineIndexToNum
(
lineIndex
)
;
*
column
=
lineIndexAndOffsetToColumn
(
lineIndex
offset
)
;
}
TokenStreamAnyChars
:
:
TokenStreamAnyChars
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
StrictModeGetter
*
smg
)
:
srcCoords
(
cx
options
.
lineno
options
.
column
options
.
scriptSourceOffset
)
options_
(
options
)
tokens
(
)
cursor_
(
0
)
lookahead
(
)
lineno
(
options
.
lineno
)
flags
(
)
linebase
(
0
)
prevLinebase
(
size_t
(
-
1
)
)
filename_
(
options
.
filename
(
)
)
displayURL_
(
nullptr
)
sourceMapURL_
(
nullptr
)
cx
(
cx
)
mutedErrors
(
options
.
mutedErrors
(
)
)
strictModeGetter
(
smg
)
{
isExprEnding
[
size_t
(
TokenKind
:
:
Comma
)
]
=
true
;
isExprEnding
[
size_t
(
TokenKind
:
:
Semi
)
]
=
true
;
isExprEnding
[
size_t
(
TokenKind
:
:
Colon
)
]
=
true
;
isExprEnding
[
size_t
(
TokenKind
:
:
Rp
)
]
=
true
;
isExprEnding
[
size_t
(
TokenKind
:
:
Rb
)
]
=
true
;
isExprEnding
[
size_t
(
TokenKind
:
:
Rc
)
]
=
true
;
}
template
<
typename
CharT
>
TokenStreamCharsBase
<
CharT
>
:
:
TokenStreamCharsBase
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
size_t
startOffset
)
:
sourceUnits
(
chars
length
startOffset
)
tokenbuf
(
cx
)
{
}
template
<
typename
CharT
class
AnyCharsAccess
>
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
TokenStreamSpecific
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
CharT
*
base
size_t
length
)
:
TokenStreamChars
<
CharT
AnyCharsAccess
>
(
cx
base
length
options
.
scriptSourceOffset
)
{
}
bool
TokenStreamAnyChars
:
:
checkOptions
(
)
{
if
(
options
(
)
.
column
>
=
mozilla
:
:
MaxValue
<
int32_t
>
:
:
value
/
2
+
1
)
{
reportErrorNoOffset
(
JSMSG_BAD_COLUMN_NUMBER
)
;
return
false
;
}
return
true
;
}
#
if
defined
(
HAVE_GETC_UNLOCKED
)
#
define
fast_getc
getc_unlocked
#
elif
defined
(
HAVE__GETC_NOLOCK
)
#
define
fast_getc
_getc_nolock
#
else
#
define
fast_getc
getc
#
endif
MOZ_MUST_USE
MOZ_ALWAYS_INLINE
bool
TokenStreamAnyChars
:
:
internalUpdateLineInfoForEOL
(
uint32_t
lineStartOffset
)
{
prevLinebase
=
linebase
;
linebase
=
lineStartOffset
;
lineno
+
+
;
return
srcCoords
.
add
(
lineno
linebase
)
;
}
void
TokenStreamAnyChars
:
:
undoInternalUpdateLineInfoForEOL
(
)
{
MOZ_ASSERT
(
prevLinebase
!
=
size_t
(
-
1
)
)
;
linebase
=
prevLinebase
;
prevLinebase
=
size_t
(
-
1
)
;
lineno
-
-
;
}
MOZ_ALWAYS_INLINE
void
TokenStreamAnyChars
:
:
updateFlagsForEOL
(
)
{
flags
.
isDirtyLine
=
false
;
}
template
<
class
AnyCharsAccess
>
bool
TokenStreamChars
<
char16_t
AnyCharsAccess
>
:
:
getCodePoint
(
int32_t
*
cp
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
if
(
MOZ_UNLIKELY
(
sourceUnits
.
atEnd
(
)
)
)
{
anyChars
.
flags
.
isEOF
=
true
;
*
cp
=
EOF
;
return
true
;
}
int32_t
c
=
sourceUnits
.
getCodeUnit
(
)
;
do
{
if
(
MOZ_UNLIKELY
(
c
=
=
'
\
n
'
)
)
break
;
if
(
MOZ_UNLIKELY
(
c
=
=
'
\
r
'
)
)
{
if
(
MOZ_LIKELY
(
!
sourceUnits
.
atEnd
(
)
)
)
sourceUnits
.
matchCodeUnit
(
'
\
n
'
)
;
break
;
}
if
(
MOZ_UNLIKELY
(
c
=
=
unicode
:
:
LINE_SEPARATOR
|
|
c
=
=
unicode
:
:
PARA_SEPARATOR
)
)
break
;
*
cp
=
c
;
return
true
;
}
while
(
false
)
;
if
(
!
updateLineInfoForEOL
(
)
)
return
false
;
*
cp
=
'
\
n
'
;
return
true
;
}
template
<
class
AnyCharsAccess
>
bool
TokenStreamChars
<
char16_t
AnyCharsAccess
>
:
:
getNonAsciiCodePoint
(
char16_t
lead
int32_t
*
codePoint
)
{
MOZ_ASSERT
(
!
isAsciiCodePoint
(
lead
)
"
ASCII
code
unit
/
point
must
be
handled
separately
"
)
;
MOZ_ASSERT
(
lead
=
=
sourceUnits
.
previousCodeUnit
(
)
"
getNonAsciiCodePoint
called
incorrectly
"
)
;
*
codePoint
=
lead
;
if
(
MOZ_LIKELY
(
!
unicode
:
:
IsLeadSurrogate
(
lead
)
)
)
{
if
(
MOZ_UNLIKELY
(
lead
=
=
unicode
:
:
LINE_SEPARATOR
|
|
lead
=
=
unicode
:
:
PARA_SEPARATOR
)
)
{
if
(
!
updateLineInfoForEOL
(
)
)
{
#
ifdef
DEBUG
*
codePoint
=
EOF
;
#
endif
MOZ_MAKE_MEM_UNDEFINED
(
codePoint
sizeof
(
*
codePoint
)
)
;
return
false
;
}
*
codePoint
=
'
\
n
'
;
}
else
{
MOZ_ASSERT
(
!
SourceUnits
:
:
isRawEOLChar
(
*
codePoint
)
)
;
}
return
true
;
}
if
(
MOZ_UNLIKELY
(
sourceUnits
.
atEnd
(
)
|
|
!
unicode
:
:
IsTrailSurrogate
(
sourceUnits
.
peekCodeUnit
(
)
)
)
)
{
MOZ_ASSERT
(
!
SourceUnits
:
:
isRawEOLChar
(
*
codePoint
)
)
;
return
true
;
}
*
codePoint
=
unicode
:
:
UTF16Decode
(
lead
sourceUnits
.
getCodeUnit
(
)
)
;
MOZ_ASSERT
(
!
SourceUnits
:
:
isRawEOLChar
(
*
codePoint
)
)
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
int32_t
GeneralTokenStreamChars
<
CharT
AnyCharsAccess
>
:
:
getCodeUnit
(
)
{
if
(
MOZ_LIKELY
(
!
sourceUnits
.
atEnd
(
)
)
)
return
sourceUnits
.
getCodeUnit
(
)
;
anyCharsAccess
(
)
.
flags
.
isEOF
=
true
;
return
EOF
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
GeneralTokenStreamChars
<
CharT
AnyCharsAccess
>
:
:
ungetChar
(
int32_t
c
)
{
if
(
c
=
=
EOF
)
return
;
sourceUnits
.
ungetCodeUnit
(
)
;
if
(
c
=
=
'
\
n
'
)
{
int32_t
c2
=
sourceUnits
.
peekCodeUnit
(
)
;
MOZ_ASSERT
(
SourceUnits
:
:
isRawEOLChar
(
c2
)
)
;
if
(
c2
=
=
CharT
(
'
\
n
'
)
&
&
!
sourceUnits
.
atStart
(
)
)
sourceUnits
.
ungetOptionalCRBeforeLF
(
)
;
anyCharsAccess
(
)
.
undoInternalUpdateLineInfoForEOL
(
)
;
}
else
{
MOZ_ASSERT
(
sourceUnits
.
peekCodeUnit
(
)
=
=
c
)
;
}
}
template
<
typename
CharT
>
void
TokenStreamCharsBase
<
CharT
>
:
:
ungetCodeUnit
(
int32_t
c
)
{
if
(
c
=
=
EOF
)
return
;
sourceUnits
.
ungetCodeUnit
(
)
;
}
template
<
class
AnyCharsAccess
>
void
TokenStreamChars
<
char16_t
AnyCharsAccess
>
:
:
ungetCodePointIgnoreEOL
(
uint32_t
codePoint
)
{
MOZ_ASSERT
(
!
sourceUnits
.
atStart
(
)
)
;
unsigned
numUnits
=
0
;
char16_t
units
[
2
]
;
unicode
:
:
UTF16Encode
(
codePoint
units
&
numUnits
)
;
MOZ_ASSERT
(
numUnits
=
=
1
|
|
numUnits
=
=
2
)
;
while
(
numUnits
-
-
>
0
)
ungetCodeUnit
(
units
[
numUnits
]
)
;
}
template
<
class
AnyCharsAccess
>
void
TokenStreamChars
<
char16_t
AnyCharsAccess
>
:
:
ungetLineTerminator
(
)
{
sourceUnits
.
ungetCodeUnit
(
)
;
char16_t
last
=
sourceUnits
.
peekCodeUnit
(
)
;
MOZ_ASSERT
(
SourceUnits
:
:
isRawEOLChar
(
last
)
)
;
if
(
last
=
=
'
\
n
'
)
sourceUnits
.
ungetOptionalCRBeforeLF
(
)
;
anyCharsAccess
(
)
.
undoInternalUpdateLineInfoForEOL
(
)
;
}
template
<
typename
CharT
>
size_t
SourceUnits
<
CharT
>
:
:
findEOLMax
(
size_t
start
size_t
max
)
{
const
CharT
*
p
=
codeUnitPtrAt
(
start
)
;
size_t
n
=
0
;
while
(
true
)
{
if
(
p
>
=
limit_
)
break
;
if
(
n
>
=
max
)
break
;
n
+
+
;
if
(
isRawEOLChar
(
*
p
+
+
)
)
break
;
}
return
start
+
n
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
advance
(
size_t
position
)
{
const
CharT
*
end
=
sourceUnits
.
codeUnitPtrAt
(
position
)
;
while
(
sourceUnits
.
addressOfNextCodeUnit
(
)
<
end
)
{
int32_t
c
;
if
(
!
getCodePoint
(
&
c
)
)
return
false
;
}
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
Token
*
cur
=
const_cast
<
Token
*
>
(
&
anyChars
.
currentToken
(
)
)
;
cur
-
>
pos
.
begin
=
sourceUnits
.
offset
(
)
;
MOZ_MAKE_MEM_UNDEFINED
(
&
cur
-
>
type
sizeof
(
cur
-
>
type
)
)
;
anyChars
.
lookahead
=
0
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
seek
(
const
Position
&
pos
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
sourceUnits
.
setAddressOfNextCodeUnit
(
pos
.
buf
true
)
;
anyChars
.
flags
=
pos
.
flags
;
anyChars
.
lineno
=
pos
.
lineno
;
anyChars
.
linebase
=
pos
.
linebase
;
anyChars
.
prevLinebase
=
pos
.
prevLinebase
;
anyChars
.
lookahead
=
pos
.
lookahead
;
anyChars
.
tokens
[
anyChars
.
cursor
(
)
]
=
pos
.
currentToken
;
for
(
unsigned
i
=
0
;
i
<
anyChars
.
lookahead
;
i
+
+
)
anyChars
.
tokens
[
anyChars
.
aheadCursor
(
1
+
i
)
]
=
pos
.
lookaheadTokens
[
i
]
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
seek
(
const
Position
&
pos
const
TokenStreamAnyChars
&
other
)
{
if
(
!
anyCharsAccess
(
)
.
srcCoords
.
fill
(
other
.
srcCoords
)
)
return
false
;
seek
(
pos
)
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
reportStrictModeErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
bool
strictMode
unsigned
errorNumber
va_list
*
args
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
if
(
!
strictMode
&
&
!
anyChars
.
options
(
)
.
extraWarningsOption
)
return
true
;
ErrorMetadata
metadata
;
if
(
!
computeErrorMetadata
(
&
metadata
offset
)
)
return
false
;
if
(
strictMode
)
{
ReportCompileError
(
anyChars
.
cx
std
:
:
move
(
metadata
)
std
:
:
move
(
notes
)
JSREPORT_ERROR
errorNumber
*
args
)
;
return
false
;
}
return
anyChars
.
compileWarning
(
std
:
:
move
(
metadata
)
std
:
:
move
(
notes
)
JSREPORT_WARNING
|
JSREPORT_STRICT
errorNumber
*
args
)
;
}
bool
TokenStreamAnyChars
:
:
compileWarning
(
ErrorMetadata
&
&
metadata
UniquePtr
<
JSErrorNotes
>
notes
unsigned
flags
unsigned
errorNumber
va_list
args
)
{
if
(
options
(
)
.
werrorOption
)
{
flags
&
=
~
JSREPORT_WARNING
;
ReportCompileError
(
cx
std
:
:
move
(
metadata
)
std
:
:
move
(
notes
)
flags
errorNumber
args
)
;
return
false
;
}
return
ReportCompileWarning
(
cx
std
:
:
move
(
metadata
)
std
:
:
move
(
notes
)
flags
errorNumber
args
)
;
}
void
TokenStreamAnyChars
:
:
computeErrorMetadataNoOffset
(
ErrorMetadata
*
err
)
{
err
-
>
isMuted
=
mutedErrors
;
err
-
>
filename
=
filename_
;
err
-
>
lineNumber
=
0
;
err
-
>
columnNumber
=
0
;
MOZ_ASSERT
(
err
-
>
lineOfContext
=
=
nullptr
)
;
}
bool
TokenStreamAnyChars
:
:
fillExcludingContext
(
ErrorMetadata
*
err
uint32_t
offset
)
{
err
-
>
isMuted
=
mutedErrors
;
if
(
!
filename_
&
&
!
cx
-
>
helperThread
(
)
)
{
NonBuiltinFrameIter
iter
(
cx
FrameIter
:
:
FOLLOW_DEBUGGER_EVAL_PREV_LINK
cx
-
>
realm
(
)
-
>
principals
(
)
)
;
if
(
!
iter
.
done
(
)
&
&
iter
.
filename
(
)
)
{
err
-
>
filename
=
iter
.
filename
(
)
;
err
-
>
lineNumber
=
iter
.
computeLine
(
&
err
-
>
columnNumber
)
;
return
false
;
}
}
err
-
>
filename
=
filename_
;
srcCoords
.
lineNumAndColumnIndex
(
offset
&
err
-
>
lineNumber
&
err
-
>
columnNumber
)
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
hasTokenizationStarted
(
)
const
{
const
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
return
anyChars
.
isCurrentTokenType
(
TokenKind
:
:
Eof
)
&
&
!
anyChars
.
isEOF
(
)
;
}
void
TokenStreamAnyChars
:
:
lineAndColumnAt
(
size_t
offset
uint32_t
*
line
uint32_t
*
column
)
const
{
srcCoords
.
lineNumAndColumnIndex
(
offset
line
column
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
currentLineAndColumn
(
uint32_t
*
line
uint32_t
*
column
)
const
{
const
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
uint32_t
offset
=
anyChars
.
currentToken
(
)
.
pos
.
begin
;
anyChars
.
srcCoords
.
lineNumAndColumnIndex
(
offset
line
column
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
computeErrorMetadata
(
ErrorMetadata
*
err
uint32_t
offset
)
{
if
(
offset
=
=
NoOffset
)
{
anyCharsAccess
(
)
.
computeErrorMetadataNoOffset
(
err
)
;
return
true
;
}
if
(
!
anyCharsAccess
(
)
.
fillExcludingContext
(
err
offset
)
)
return
true
;
return
computeLineOfContext
(
err
offset
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
computeLineOfContext
(
ErrorMetadata
*
err
uint32_t
offset
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
if
(
err
-
>
lineNumber
!
=
anyChars
.
lineno
)
return
true
;
constexpr
size_t
windowRadius
=
ErrorMetadata
:
:
lineOfContextRadius
;
MOZ_ASSERT
(
offset
>
=
anyChars
.
linebase
)
;
size_t
windowStart
=
(
offset
-
anyChars
.
linebase
>
windowRadius
)
?
offset
-
windowRadius
:
anyChars
.
linebase
;
if
(
windowStart
<
sourceUnits
.
startOffset
(
)
)
windowStart
=
sourceUnits
.
startOffset
(
)
;
size_t
windowEnd
=
sourceUnits
.
findEOLMax
(
offset
windowRadius
)
;
size_t
windowLength
=
windowEnd
-
windowStart
;
MOZ_ASSERT
(
windowLength
<
=
windowRadius
*
2
)
;
StringBuffer
windowBuf
(
anyChars
.
cx
)
;
if
(
!
windowBuf
.
append
(
codeUnitPtrAt
(
windowStart
)
windowLength
)
|
|
!
windowBuf
.
append
(
'
\
0
'
)
)
{
return
false
;
}
err
-
>
lineOfContext
.
reset
(
windowBuf
.
stealChars
(
)
)
;
if
(
!
err
-
>
lineOfContext
)
return
false
;
err
-
>
lineLength
=
windowLength
;
err
-
>
tokenOffset
=
offset
-
windowStart
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
reportStrictModeError
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
bool
result
=
reportStrictModeErrorNumberVA
(
nullptr
anyChars
.
currentToken
(
)
.
pos
.
begin
anyChars
.
strictMode
(
)
errorNumber
&
args
)
;
va_end
(
args
)
;
return
result
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
reportError
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
ErrorMetadata
metadata
;
if
(
computeErrorMetadata
(
&
metadata
anyChars
.
currentToken
(
)
.
pos
.
begin
)
)
{
ReportCompileError
(
anyChars
.
cx
std
:
:
move
(
metadata
)
nullptr
JSREPORT_ERROR
errorNumber
args
)
;
}
va_end
(
args
)
;
}
void
TokenStreamAnyChars
:
:
reportErrorNoOffset
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
reportErrorNoOffsetVA
(
errorNumber
args
)
;
va_end
(
args
)
;
}
void
TokenStreamAnyChars
:
:
reportErrorNoOffsetVA
(
unsigned
errorNumber
va_list
args
)
{
ErrorMetadata
metadata
;
computeErrorMetadataNoOffset
(
&
metadata
)
;
ReportCompileError
(
cx
std
:
:
move
(
metadata
)
nullptr
JSREPORT_ERROR
errorNumber
args
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
warning
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
ErrorMetadata
metadata
;
bool
result
=
computeErrorMetadata
(
&
metadata
anyCharsAccess
(
)
.
currentToken
(
)
.
pos
.
begin
)
&
&
anyCharsAccess
(
)
.
compileWarning
(
std
:
:
move
(
metadata
)
nullptr
JSREPORT_WARNING
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
reportExtraWarningErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
if
(
!
anyChars
.
options
(
)
.
extraWarningsOption
)
return
true
;
ErrorMetadata
metadata
;
if
(
!
computeErrorMetadata
(
&
metadata
offset
)
)
return
false
;
return
anyChars
.
compileWarning
(
std
:
:
move
(
metadata
)
std
:
:
move
(
notes
)
JSREPORT_STRICT
|
JSREPORT_WARNING
errorNumber
*
args
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
error
(
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
ErrorMetadata
metadata
;
if
(
computeErrorMetadata
(
&
metadata
sourceUnits
.
offset
(
)
)
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
ReportCompileError
(
anyChars
.
cx
std
:
:
move
(
metadata
)
nullptr
JSREPORT_ERROR
errorNumber
args
)
;
}
va_end
(
args
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
errorAtVA
(
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
{
ErrorMetadata
metadata
;
if
(
computeErrorMetadata
(
&
metadata
offset
)
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
ReportCompileError
(
anyChars
.
cx
std
:
:
move
(
metadata
)
nullptr
JSREPORT_ERROR
errorNumber
*
args
)
;
}
}
template
<
typename
CharT
class
AnyCharsAccess
>
void
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
errorAt
(
uint32_t
offset
unsigned
errorNumber
.
.
.
)
{
va_list
args
;
va_start
(
args
errorNumber
)
;
errorAtVA
(
offset
errorNumber
&
args
)
;
va_end
(
args
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
uint32_t
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
peekUnicodeEscape
(
uint32_t
*
codePoint
)
{
int32_t
c
=
getCodeUnit
(
)
;
if
(
c
!
=
'
u
'
)
{
ungetCodeUnit
(
c
)
;
return
0
;
}
CharT
cp
[
3
]
;
uint32_t
length
;
c
=
getCodeUnit
(
)
;
if
(
JS7_ISHEX
(
c
)
&
&
sourceUnits
.
peekCodeUnits
(
3
cp
)
&
&
JS7_ISHEX
(
cp
[
0
]
)
&
&
JS7_ISHEX
(
cp
[
1
]
)
&
&
JS7_ISHEX
(
cp
[
2
]
)
)
{
*
codePoint
=
(
JS7_UNHEX
(
c
)
<
<
12
)
|
(
JS7_UNHEX
(
cp
[
0
]
)
<
<
8
)
|
(
JS7_UNHEX
(
cp
[
1
]
)
<
<
4
)
|
JS7_UNHEX
(
cp
[
2
]
)
;
length
=
5
;
}
else
if
(
c
=
=
'
{
'
)
{
length
=
peekExtendedUnicodeEscape
(
codePoint
)
;
}
else
{
length
=
0
;
}
ungetCodeUnit
(
c
)
;
ungetCodeUnit
(
'
u
'
)
;
return
length
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
uint32_t
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
peekExtendedUnicodeEscape
(
uint32_t
*
codePoint
)
{
int32_t
c
=
getCodeUnit
(
)
;
uint32_t
leadingZeros
=
0
;
while
(
c
=
=
'
0
'
)
{
leadingZeros
+
+
;
c
=
getCodeUnit
(
)
;
}
CharT
cp
[
6
]
;
size_t
i
=
0
;
uint32_t
code
=
0
;
while
(
JS7_ISHEX
(
c
)
&
&
i
<
6
)
{
cp
[
i
+
+
]
=
c
;
code
=
code
<
<
4
|
JS7_UNHEX
(
c
)
;
c
=
getCodeUnit
(
)
;
}
uint32_t
length
;
if
(
c
=
=
'
}
'
&
&
(
leadingZeros
>
0
|
|
i
>
0
)
&
&
code
<
=
unicode
:
:
NonBMPMax
)
{
*
codePoint
=
code
;
length
=
leadingZeros
+
i
+
3
;
}
else
{
length
=
0
;
}
ungetCodeUnit
(
c
)
;
while
(
i
-
-
)
ungetCodeUnit
(
cp
[
i
]
)
;
while
(
leadingZeros
-
-
)
ungetCodeUnit
(
'
0
'
)
;
return
length
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
uint32_t
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
matchUnicodeEscapeIdStart
(
uint32_t
*
codePoint
)
{
uint32_t
length
=
peekUnicodeEscape
(
codePoint
)
;
if
(
length
>
0
&
&
unicode
:
:
IsIdentifierStart
(
*
codePoint
)
)
{
sourceUnits
.
skipCodeUnits
(
length
)
;
return
length
;
}
return
0
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
matchUnicodeEscapeIdent
(
uint32_t
*
codePoint
)
{
uint32_t
length
=
peekUnicodeEscape
(
codePoint
)
;
if
(
length
>
0
&
&
unicode
:
:
IsIdentifierPart
(
*
codePoint
)
)
{
sourceUnits
.
skipCodeUnits
(
length
)
;
return
true
;
}
return
false
;
}
template
<
typename
CharT
>
static
bool
CharsMatch
(
const
CharT
*
p
const
char
*
q
)
{
while
(
*
q
)
{
if
(
*
p
+
+
!
=
*
q
+
+
)
return
false
;
}
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getDirectives
(
bool
isMultiline
bool
shouldWarnDeprecated
)
{
bool
res
=
getDisplayURL
(
isMultiline
shouldWarnDeprecated
)
&
&
getSourceMappingURL
(
isMultiline
shouldWarnDeprecated
)
;
if
(
!
res
)
badToken
(
)
;
return
res
;
}
template
<
>
MOZ_MUST_USE
bool
TokenStreamCharsBase
<
char16_t
>
:
:
copyTokenbufTo
(
JSContext
*
cx
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
*
destination
)
{
size_t
length
=
tokenbuf
.
length
(
)
;
*
destination
=
cx
-
>
make_pod_array
<
char16_t
>
(
length
+
1
)
;
if
(
!
*
destination
)
return
false
;
PodCopy
(
destination
-
>
get
(
)
tokenbuf
.
begin
(
)
length
)
;
(
*
destination
)
[
length
]
=
'
\
0
'
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_MUST_USE
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getDirective
(
bool
isMultiline
bool
shouldWarnDeprecated
const
char
*
directive
uint8_t
directiveLength
const
char
*
errorMsgPragma
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
*
destination
)
{
MOZ_ASSERT
(
directiveLength
<
=
18
)
;
char16_t
peeked
[
18
]
;
if
(
!
sourceUnits
.
peekCodeUnits
(
directiveLength
peeked
)
)
return
true
;
if
(
!
CharsMatch
(
peeked
directive
)
)
return
true
;
if
(
shouldWarnDeprecated
)
{
if
(
!
warning
(
JSMSG_DEPRECATED_PRAGMA
errorMsgPragma
)
)
return
false
;
}
sourceUnits
.
skipCodeUnits
(
directiveLength
)
;
tokenbuf
.
clear
(
)
;
do
{
int32_t
unit
=
peekCodeUnit
(
)
;
if
(
unit
=
=
EOF
)
break
;
if
(
MOZ_LIKELY
(
isAsciiCodePoint
(
unit
)
)
)
{
if
(
unicode
:
:
IsSpaceOrBOM2
(
unit
)
)
break
;
consumeKnownCodeUnit
(
unit
)
;
if
(
isMultiline
&
&
unit
=
=
'
*
'
&
&
peekCodeUnit
(
)
=
=
'
/
'
)
{
ungetCodeUnit
(
'
*
'
)
;
break
;
}
if
(
!
tokenbuf
.
append
(
unit
)
)
return
false
;
continue
;
}
int32_t
codePoint
;
if
(
!
getCodePoint
(
&
codePoint
)
)
return
false
;
if
(
unicode
:
:
IsSpaceOrBOM2
(
codePoint
)
)
{
ungetCodePointIgnoreEOL
(
codePoint
)
;
if
(
codePoint
=
=
unicode
:
:
LINE_SEPARATOR
|
|
codePoint
=
=
unicode
:
:
PARA_SEPARATOR
)
anyCharsAccess
(
)
.
undoInternalUpdateLineInfoForEOL
(
)
;
break
;
}
if
(
!
appendCodePointToTokenbuf
(
codePoint
)
)
return
false
;
}
while
(
true
)
;
if
(
tokenbuf
.
empty
(
)
)
{
return
true
;
}
return
copyTokenbufTo
(
anyCharsAccess
(
)
.
cx
destination
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getDisplayURL
(
bool
isMultiline
bool
shouldWarnDeprecated
)
{
static
const
char
sourceURLDirective
[
]
=
"
sourceURL
=
"
;
constexpr
uint8_t
sourceURLDirectiveLength
=
ArrayLength
(
sourceURLDirective
)
-
1
;
return
getDirective
(
isMultiline
shouldWarnDeprecated
sourceURLDirective
sourceURLDirectiveLength
"
sourceURL
"
&
anyCharsAccess
(
)
.
displayURL_
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getSourceMappingURL
(
bool
isMultiline
bool
shouldWarnDeprecated
)
{
static
const
char
sourceMappingURLDirective
[
]
=
"
sourceMappingURL
=
"
;
constexpr
uint8_t
sourceMappingURLDirectiveLength
=
ArrayLength
(
sourceMappingURLDirective
)
-
1
;
return
getDirective
(
isMultiline
shouldWarnDeprecated
sourceMappingURLDirective
sourceMappingURLDirectiveLength
"
sourceMappingURL
"
&
anyCharsAccess
(
)
.
sourceMapURL_
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_ALWAYS_INLINE
Token
*
GeneralTokenStreamChars
<
CharT
AnyCharsAccess
>
:
:
newTokenInternal
(
TokenKind
kind
TokenStart
start
TokenKind
*
out
)
{
MOZ_ASSERT
(
kind
<
TokenKind
:
:
Limit
)
;
MOZ_ASSERT
(
kind
!
=
TokenKind
:
:
Eol
"
TokenKind
:
:
Eol
should
never
be
used
in
an
actual
Token
only
"
"
returned
by
peekTokenSameLine
(
)
"
)
;
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
flags
.
isDirtyLine
=
true
;
Token
*
token
=
anyChars
.
allocateToken
(
)
;
*
out
=
token
-
>
type
=
kind
;
token
-
>
pos
=
TokenPos
(
start
.
offset
(
)
this
-
>
sourceUnits
.
offset
(
)
)
;
MOZ_ASSERT
(
token
-
>
pos
.
begin
<
=
token
-
>
pos
.
end
)
;
return
token
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_COLD
bool
GeneralTokenStreamChars
<
CharT
AnyCharsAccess
>
:
:
badToken
(
)
{
anyCharsAccess
(
)
.
flags
.
hadError
=
true
;
sourceUnits
.
poisonInDebug
(
)
;
return
false
;
}
;
template
<
>
MOZ_MUST_USE
bool
TokenStreamCharsBase
<
char16_t
>
:
:
appendCodePointToTokenbuf
(
uint32_t
codePoint
)
{
char16_t
units
[
2
]
;
unsigned
numUnits
=
0
;
unicode
:
:
UTF16Encode
(
codePoint
units
&
numUnits
)
;
MOZ_ASSERT
(
numUnits
=
=
1
|
|
numUnits
=
=
2
"
UTF
-
16
code
points
are
only
encoded
in
one
or
two
units
"
)
;
if
(
!
tokenbuf
.
append
(
units
[
0
]
)
)
return
false
;
if
(
numUnits
=
=
1
)
return
true
;
return
tokenbuf
.
append
(
units
[
1
]
)
;
}
template
<
class
AnyCharsAccess
>
void
TokenStreamChars
<
char16_t
AnyCharsAccess
>
:
:
matchMultiUnitCodePointSlow
(
char16_t
lead
uint32_t
*
codePoint
)
{
MOZ_ASSERT
(
unicode
:
:
IsLeadSurrogate
(
lead
)
"
matchMultiUnitCodepoint
should
have
ensured
|
lead
|
is
a
lead
"
"
surrogate
"
)
;
int32_t
maybeTrail
=
getCodeUnit
(
)
;
if
(
MOZ_LIKELY
(
unicode
:
:
IsTrailSurrogate
(
maybeTrail
)
)
)
{
*
codePoint
=
unicode
:
:
UTF16Decode
(
lead
maybeTrail
)
;
}
else
{
ungetCodeUnit
(
maybeTrail
)
;
*
codePoint
=
0
;
}
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
putIdentInTokenbuf
(
const
CharT
*
identStart
)
{
const
CharT
*
const
originalAddress
=
sourceUnits
.
addressOfNextCodeUnit
(
)
;
sourceUnits
.
setAddressOfNextCodeUnit
(
identStart
)
;
auto
restoreNextRawCharAddress
=
MakeScopeExit
(
[
this
originalAddress
]
(
)
{
this
-
>
sourceUnits
.
setAddressOfNextCodeUnit
(
originalAddress
)
;
}
)
;
tokenbuf
.
clear
(
)
;
for
(
;
;
)
{
int32_t
c
=
getCodeUnit
(
)
;
uint32_t
codePoint
;
if
(
!
matchMultiUnitCodePoint
(
c
&
codePoint
)
)
return
false
;
if
(
codePoint
)
{
if
(
!
unicode
:
:
IsIdentifierPart
(
codePoint
)
)
break
;
}
else
{
if
(
unicode
:
:
IsIdentifierPart
(
char16_t
(
c
)
)
)
{
codePoint
=
c
;
}
else
{
if
(
c
!
=
'
\
\
'
|
|
!
matchUnicodeEscapeIdent
(
&
codePoint
)
)
break
;
}
}
if
(
!
appendCodePointToTokenbuf
(
codePoint
)
)
return
false
;
}
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_MUST_USE
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
identifierName
(
TokenStart
start
const
CharT
*
identStart
IdentifierEscapes
escaping
Modifier
modifier
TokenKind
*
out
)
{
auto
noteBadToken
=
MakeScopeExit
(
[
this
]
(
)
{
this
-
>
badToken
(
)
;
}
)
;
int
c
;
while
(
true
)
{
c
=
getCodeUnit
(
)
;
if
(
c
=
=
EOF
)
break
;
uint32_t
codePoint
;
if
(
!
matchMultiUnitCodePoint
(
c
&
codePoint
)
)
return
false
;
if
(
codePoint
)
{
if
(
!
unicode
:
:
IsIdentifierPart
(
codePoint
)
)
break
;
continue
;
}
if
(
!
unicode
:
:
IsIdentifierPart
(
char16_t
(
c
)
)
)
{
uint32_t
qc
;
if
(
c
!
=
'
\
\
'
|
|
!
matchUnicodeEscapeIdent
(
&
qc
)
)
break
;
escaping
=
IdentifierEscapes
:
:
SawUnicodeEscape
;
}
}
ungetCodeUnit
(
c
)
;
const
CharT
*
chars
;
size_t
length
;
if
(
escaping
=
=
IdentifierEscapes
:
:
SawUnicodeEscape
)
{
if
(
!
putIdentInTokenbuf
(
identStart
)
)
return
false
;
chars
=
tokenbuf
.
begin
(
)
;
length
=
tokenbuf
.
length
(
)
;
}
else
{
chars
=
identStart
;
length
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
identStart
;
if
(
const
ReservedWordInfo
*
rw
=
FindReservedWord
(
chars
length
)
)
{
noteBadToken
.
release
(
)
;
newSimpleToken
(
rw
-
>
tokentype
start
modifier
out
)
;
return
true
;
}
}
JSAtom
*
atom
=
atomizeChars
(
anyCharsAccess
(
)
.
cx
chars
length
)
;
if
(
!
atom
)
return
false
;
noteBadToken
.
release
(
)
;
newNameToken
(
atom
-
>
asPropertyName
(
)
start
modifier
out
)
;
return
true
;
}
enum
FirstCharKind
{
OneChar_Min
=
0
OneChar_Max
=
size_t
(
TokenKind
:
:
Limit
)
-
1
Space
=
size_t
(
TokenKind
:
:
Limit
)
Ident
Dec
String
EOL
ZeroDigit
Other
LastCharKind
=
Other
}
;
#
define
T_COMMA
size_t
(
TokenKind
:
:
Comma
)
#
define
T_COLON
size_t
(
TokenKind
:
:
Colon
)
#
define
T_BITNOT
size_t
(
TokenKind
:
:
BitNot
)
#
define
T_LP
size_t
(
TokenKind
:
:
Lp
)
#
define
T_RP
size_t
(
TokenKind
:
:
Rp
)
#
define
T_SEMI
size_t
(
TokenKind
:
:
Semi
)
#
define
T_HOOK
size_t
(
TokenKind
:
:
Hook
)
#
define
T_LB
size_t
(
TokenKind
:
:
Lb
)
#
define
T_RB
size_t
(
TokenKind
:
:
Rb
)
#
define
T_LC
size_t
(
TokenKind
:
:
Lc
)
#
define
T_RC
size_t
(
TokenKind
:
:
Rc
)
#
define
_______
Other
static
const
uint8_t
firstCharKinds
[
]
=
{
_______
_______
_______
_______
_______
_______
_______
_______
_______
Space
EOL
Space
Space
EOL
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
_______
Space
_______
String
_______
Ident
_______
_______
String
T_LP
T_RP
_______
_______
T_COMMA
_______
_______
_______
ZeroDigit
Dec
Dec
Dec
Dec
Dec
Dec
Dec
Dec
Dec
T_COLON
T_SEMI
_______
_______
_______
T_HOOK
_______
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
T_LB
_______
T_RB
_______
Ident
String
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
Ident
T_LC
_______
T_RC
T_BITNOT
_______
}
;
#
undef
T_COMMA
#
undef
T_COLON
#
undef
T_BITNOT
#
undef
T_LP
#
undef
T_RP
#
undef
T_SEMI
#
undef
T_HOOK
#
undef
T_LB
#
undef
T_RB
#
undef
T_LC
#
undef
T_RC
#
undef
_______
static_assert
(
LastCharKind
<
(
1
<
<
(
sizeof
(
firstCharKinds
[
0
]
)
*
8
)
)
"
Elements
of
firstCharKinds
[
]
are
too
small
"
)
;
template
<
typename
CharT
class
AnyCharsAccess
>
void
GeneralTokenStreamChars
<
CharT
AnyCharsAccess
>
:
:
consumeRestOfSingleLineComment
(
)
{
int32_t
c
;
do
{
c
=
getCodeUnit
(
)
;
}
while
(
c
!
=
EOF
&
&
!
SourceUnits
:
:
isRawEOLChar
(
c
)
)
;
ungetCodeUnit
(
c
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_MUST_USE
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
decimalNumber
(
int
c
TokenStart
start
const
CharT
*
numStart
Modifier
modifier
TokenKind
*
out
)
{
auto
noteBadToken
=
MakeScopeExit
(
[
this
]
(
)
{
this
-
>
badToken
(
)
;
}
)
;
while
(
IsAsciiDigit
(
c
)
)
c
=
getCodeUnit
(
)
;
double
dval
;
DecimalPoint
decimalPoint
=
NoDecimal
;
if
(
c
!
=
'
.
'
&
&
c
!
=
'
e
'
&
&
c
!
=
'
E
'
)
{
ungetCodeUnit
(
c
)
;
if
(
!
GetDecimalInteger
(
anyCharsAccess
(
)
.
cx
numStart
sourceUnits
.
addressOfNextCodeUnit
(
)
&
dval
)
)
{
return
false
;
}
}
else
{
if
(
c
=
=
'
.
'
)
{
decimalPoint
=
HasDecimal
;
do
{
c
=
getCodeUnit
(
)
;
}
while
(
IsAsciiDigit
(
c
)
)
;
}
if
(
c
=
=
'
e
'
|
|
c
=
=
'
E
'
)
{
c
=
getCodeUnit
(
)
;
if
(
c
=
=
'
+
'
|
|
c
=
=
'
-
'
)
c
=
getCodeUnit
(
)
;
if
(
!
IsAsciiDigit
(
c
)
)
{
ungetCodeUnit
(
c
)
;
error
(
JSMSG_MISSING_EXPONENT
)
;
return
false
;
}
do
{
c
=
getCodeUnit
(
)
;
}
while
(
IsAsciiDigit
(
c
)
)
;
}
ungetCodeUnit
(
c
)
;
const
CharT
*
dummy
;
if
(
!
js_strtod
(
anyCharsAccess
(
)
.
cx
numStart
sourceUnits
.
addressOfNextCodeUnit
(
)
&
dummy
&
dval
)
)
{
return
false
;
}
}
if
(
c
!
=
EOF
)
{
if
(
unicode
:
:
IsIdentifierStart
(
char16_t
(
c
)
)
)
{
error
(
JSMSG_IDSTART_AFTER_NUMBER
)
;
return
false
;
}
consumeKnownCharIgnoreEOL
(
c
)
;
uint32_t
codePoint
;
if
(
!
matchMultiUnitCodePoint
(
c
&
codePoint
)
)
return
false
;
if
(
codePoint
)
{
ungetCodePointIgnoreEOL
(
codePoint
)
;
if
(
unicode
:
:
IsIdentifierStart
(
codePoint
)
)
{
error
(
JSMSG_IDSTART_AFTER_NUMBER
)
;
return
false
;
}
}
else
{
ungetCodeUnit
(
c
)
;
}
}
noteBadToken
.
release
(
)
;
newNumberToken
(
dval
decimalPoint
start
modifier
out
)
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_MUST_USE
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
regexpLiteral
(
TokenStart
start
TokenKind
*
out
)
{
MOZ_ASSERT
(
sourceUnits
.
previousCodeUnit
(
)
=
=
'
/
'
)
;
tokenbuf
.
clear
(
)
;
auto
ProcessNonAsciiCodePoint
=
[
this
]
(
CharT
lead
)
{
int32_t
codePoint
;
if
(
!
this
-
>
getNonAsciiCodePoint
(
lead
&
codePoint
)
)
return
false
;
if
(
codePoint
=
=
'
\
n
'
)
{
this
-
>
ungetLineTerminator
(
)
;
this
-
>
reportError
(
JSMSG_UNTERMINATED_REGEXP
)
;
return
false
;
}
return
this
-
>
appendCodePointToTokenbuf
(
codePoint
)
;
}
;
auto
ReportUnterminatedRegExp
=
[
this
]
(
CharT
unit
)
{
this
-
>
ungetCodeUnit
(
unit
)
;
this
-
>
error
(
JSMSG_UNTERMINATED_REGEXP
)
;
}
;
bool
inCharClass
=
false
;
do
{
int32_t
unit
=
getCodeUnit
(
)
;
if
(
unit
=
=
EOF
)
{
ReportUnterminatedRegExp
(
unit
)
;
return
badToken
(
)
;
}
if
(
MOZ_LIKELY
(
isAsciiCodePoint
(
unit
)
)
)
{
if
(
unit
=
=
'
\
\
'
)
{
if
(
!
tokenbuf
.
append
(
unit
)
)
return
badToken
(
)
;
unit
=
getCodeUnit
(
)
;
if
(
unit
=
=
EOF
)
{
ReportUnterminatedRegExp
(
unit
)
;
return
badToken
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
isAsciiCodePoint
(
unit
)
)
)
{
if
(
!
ProcessNonAsciiCodePoint
(
unit
)
)
return
badToken
(
)
;
continue
;
}
}
else
if
(
unit
=
=
'
[
'
)
{
inCharClass
=
true
;
}
else
if
(
unit
=
=
'
]
'
)
{
inCharClass
=
false
;
}
else
if
(
unit
=
=
'
/
'
&
&
!
inCharClass
)
{
break
;
}
if
(
unit
=
=
'
\
r
'
|
|
unit
=
=
'
\
n
'
)
{
ReportUnterminatedRegExp
(
unit
)
;
return
badToken
(
)
;
}
if
(
!
tokenbuf
.
append
(
unit
)
)
return
badToken
(
)
;
}
else
{
if
(
!
ProcessNonAsciiCodePoint
(
unit
)
)
return
badToken
(
)
;
}
}
while
(
true
)
;
int32_t
unit
;
RegExpFlag
reflags
=
NoFlags
;
while
(
true
)
{
RegExpFlag
flag
;
unit
=
getCodeUnit
(
)
;
if
(
unit
=
=
'
g
'
)
flag
=
GlobalFlag
;
else
if
(
unit
=
=
'
i
'
)
flag
=
IgnoreCaseFlag
;
else
if
(
unit
=
=
'
m
'
)
flag
=
MultilineFlag
;
else
if
(
unit
=
=
'
y
'
)
flag
=
StickyFlag
;
else
if
(
unit
=
=
'
u
'
)
flag
=
UnicodeFlag
;
else
if
(
IsAsciiAlpha
(
unit
)
)
flag
=
NoFlags
;
else
break
;
if
(
(
reflags
&
flag
)
|
|
flag
=
=
NoFlags
)
{
ungetCodeUnit
(
unit
)
;
char
buf
[
2
]
=
{
char
(
unit
)
'
\
0
'
}
;
error
(
JSMSG_BAD_REGEXP_FLAG
buf
)
;
return
badToken
(
)
;
}
reflags
=
RegExpFlag
(
reflags
|
flag
)
;
}
ungetCodeUnit
(
unit
)
;
newRegExpToken
(
reflags
start
out
)
;
return
true
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
MOZ_MUST_USE
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getTokenInternal
(
TokenKind
*
const
ttp
const
Modifier
modifier
)
{
#
ifdef
DEBUG
*
ttp
=
TokenKind
:
:
Limit
;
#
endif
MOZ_MAKE_MEM_UNDEFINED
(
ttp
sizeof
(
*
ttp
)
)
;
if
(
MOZ_UNLIKELY
(
modifier
=
=
TemplateTail
)
)
return
getStringOrTemplateToken
(
'
'
modifier
ttp
)
;
do
{
if
(
MOZ_UNLIKELY
(
sourceUnits
.
atEnd
(
)
)
)
{
anyCharsAccess
(
)
.
flags
.
isEOF
=
true
;
TokenStart
start
(
sourceUnits
0
)
;
newSimpleToken
(
TokenKind
:
:
Eof
start
modifier
ttp
)
;
return
true
;
}
int
c
=
sourceUnits
.
getCodeUnit
(
)
;
MOZ_ASSERT
(
c
!
=
EOF
)
;
if
(
MOZ_UNLIKELY
(
c
>
=
128
)
)
{
if
(
unicode
:
:
IsSpaceOrBOM2
(
c
)
)
{
if
(
c
=
=
unicode
:
:
LINE_SEPARATOR
|
|
c
=
=
unicode
:
:
PARA_SEPARATOR
)
{
if
(
!
updateLineInfoForEOL
(
)
)
return
badToken
(
)
;
anyCharsAccess
(
)
.
updateFlagsForEOL
(
)
;
}
continue
;
}
TokenStart
start
(
sourceUnits
-
1
)
;
const
CharT
*
identStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
static_assert
(
'
'
<
128
"
IdentifierStart
contains
'
'
but
as
"
"
!
IsUnicodeIDStart
(
'
'
)
ensure
that
'
'
is
never
"
"
handled
here
"
)
;
static_assert
(
'
_
'
<
128
"
IdentifierStart
contains
'
_
'
but
as
"
"
!
IsUnicodeIDStart
(
'
_
'
)
ensure
that
'
_
'
is
never
"
"
handled
here
"
)
;
if
(
unicode
:
:
IsUnicodeIDStart
(
char16_t
(
c
)
)
)
return
identifierName
(
start
identStart
IdentifierEscapes
:
:
None
modifier
ttp
)
;
uint32_t
codePoint
=
c
;
if
(
!
matchMultiUnitCodePoint
(
c
&
codePoint
)
)
return
badToken
(
)
;
if
(
codePoint
&
&
unicode
:
:
IsUnicodeIDStart
(
codePoint
)
)
return
identifierName
(
start
identStart
IdentifierEscapes
:
:
None
modifier
ttp
)
;
ungetCodePointIgnoreEOL
(
codePoint
)
;
error
(
JSMSG_ILLEGAL_CHARACTER
)
;
return
badToken
(
)
;
}
FirstCharKind
c1kind
=
FirstCharKind
(
firstCharKinds
[
c
]
)
;
if
(
c1kind
<
=
OneChar_Max
)
{
TokenStart
start
(
sourceUnits
-
1
)
;
newSimpleToken
(
TokenKind
(
c1kind
)
start
modifier
ttp
)
;
return
true
;
}
if
(
c1kind
=
=
Space
)
continue
;
if
(
c1kind
=
=
Ident
)
{
TokenStart
start
(
sourceUnits
-
1
)
;
return
identifierName
(
start
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
IdentifierEscapes
:
:
None
modifier
ttp
)
;
}
if
(
c1kind
=
=
Dec
)
{
TokenStart
start
(
sourceUnits
-
1
)
;
const
CharT
*
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
return
decimalNumber
(
c
start
numStart
modifier
ttp
)
;
}
if
(
c1kind
=
=
String
)
return
getStringOrTemplateToken
(
static_cast
<
char
>
(
c
)
modifier
ttp
)
;
if
(
c1kind
=
=
EOL
)
{
if
(
c
=
=
'
\
r
'
&
&
!
sourceUnits
.
atEnd
(
)
)
sourceUnits
.
matchCodeUnit
(
'
\
n
'
)
;
if
(
!
updateLineInfoForEOL
(
)
)
return
badToken
(
)
;
anyCharsAccess
(
)
.
updateFlagsForEOL
(
)
;
continue
;
}
if
(
c1kind
=
=
ZeroDigit
)
{
TokenStart
start
(
sourceUnits
-
1
)
;
int
radix
;
const
CharT
*
numStart
;
c
=
getCodeUnit
(
)
;
if
(
c
=
=
'
x
'
|
|
c
=
=
'
X
'
)
{
radix
=
16
;
c
=
getCodeUnit
(
)
;
if
(
!
JS7_ISHEX
(
c
)
)
{
ungetCodeUnit
(
c
)
;
reportError
(
JSMSG_MISSING_HEXDIGITS
)
;
return
badToken
(
)
;
}
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
while
(
JS7_ISHEX
(
c
)
)
c
=
getCodeUnit
(
)
;
}
else
if
(
c
=
=
'
b
'
|
|
c
=
=
'
B
'
)
{
radix
=
2
;
c
=
getCodeUnit
(
)
;
if
(
c
!
=
'
0
'
&
&
c
!
=
'
1
'
)
{
ungetCodeUnit
(
c
)
;
reportError
(
JSMSG_MISSING_BINARY_DIGITS
)
;
return
badToken
(
)
;
}
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
while
(
c
=
=
'
0
'
|
|
c
=
=
'
1
'
)
c
=
getCodeUnit
(
)
;
}
else
if
(
c
=
=
'
o
'
|
|
c
=
=
'
O
'
)
{
radix
=
8
;
c
=
getCodeUnit
(
)
;
if
(
c
<
'
0
'
|
|
c
>
'
7
'
)
{
ungetCodeUnit
(
c
)
;
reportError
(
JSMSG_MISSING_OCTAL_DIGITS
)
;
return
badToken
(
)
;
}
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
while
(
'
0
'
<
=
c
&
&
c
<
=
'
7
'
)
c
=
getCodeUnit
(
)
;
}
else
if
(
IsAsciiDigit
(
c
)
)
{
radix
=
8
;
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
do
{
if
(
!
reportStrictModeError
(
JSMSG_DEPRECATED_OCTAL
)
)
return
badToken
(
)
;
if
(
c
>
=
'
8
'
)
{
if
(
!
warning
(
JSMSG_BAD_OCTAL
c
=
=
'
8
'
?
"
08
"
:
"
09
"
)
)
return
badToken
(
)
;
return
decimalNumber
(
c
start
numStart
modifier
ttp
)
;
}
c
=
getCodeUnit
(
)
;
}
while
(
IsAsciiDigit
(
c
)
)
;
}
else
{
numStart
=
sourceUnits
.
addressOfNextCodeUnit
(
)
-
1
;
return
decimalNumber
(
c
start
numStart
modifier
ttp
)
;
}
ungetCodeUnit
(
c
)
;
if
(
c
!
=
EOF
)
{
if
(
unicode
:
:
IsIdentifierStart
(
char16_t
(
c
)
)
)
{
error
(
JSMSG_IDSTART_AFTER_NUMBER
)
;
return
badToken
(
)
;
}
consumeKnownCharIgnoreEOL
(
c
)
;
uint32_t
codePoint
;
if
(
!
matchMultiUnitCodePoint
(
c
&
codePoint
)
)
return
badToken
(
)
;
if
(
codePoint
)
{
ungetCodePointIgnoreEOL
(
codePoint
)
;
if
(
unicode
:
:
IsIdentifierStart
(
codePoint
)
)
{
error
(
JSMSG_IDSTART_AFTER_NUMBER
)
;
return
badToken
(
)
;
}
}
else
{
ungetCodeUnit
(
c
)
;
}
}
double
dval
;
const
char16_t
*
dummy
;
if
(
!
GetPrefixInteger
(
anyCharsAccess
(
)
.
cx
numStart
sourceUnits
.
addressOfNextCodeUnit
(
)
radix
&
dummy
&
dval
)
)
{
return
badToken
(
)
;
}
newNumberToken
(
dval
NoDecimal
start
modifier
ttp
)
;
return
true
;
}
MOZ_ASSERT
(
c1kind
=
=
Other
)
;
TokenStart
start
(
sourceUnits
-
1
)
;
TokenKind
simpleKind
;
#
ifdef
DEBUG
simpleKind
=
TokenKind
:
:
Limit
;
#
endif
switch
(
c
)
{
case
'
.
'
:
c
=
getCodeUnit
(
)
;
if
(
IsAsciiDigit
(
c
)
)
{
return
decimalNumber
(
'
.
'
start
sourceUnits
.
addressOfNextCodeUnit
(
)
-
2
modifier
ttp
)
;
}
if
(
c
=
=
'
.
'
)
{
if
(
matchCodeUnit
(
'
.
'
)
)
{
simpleKind
=
TokenKind
:
:
TripleDot
;
break
;
}
}
ungetCodeUnit
(
c
)
;
simpleKind
=
TokenKind
:
:
Dot
;
break
;
case
'
=
'
:
if
(
matchCodeUnit
(
'
=
'
)
)
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
StrictEq
:
TokenKind
:
:
Eq
;
else
if
(
matchCodeUnit
(
'
>
'
)
)
simpleKind
=
TokenKind
:
:
Arrow
;
else
simpleKind
=
TokenKind
:
:
Assign
;
break
;
case
'
+
'
:
if
(
matchCodeUnit
(
'
+
'
)
)
simpleKind
=
TokenKind
:
:
Inc
;
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
AddAssign
:
TokenKind
:
:
Add
;
break
;
case
'
\
\
'
:
{
uint32_t
qc
;
if
(
uint32_t
escapeLength
=
matchUnicodeEscapeIdStart
(
&
qc
)
)
{
return
identifierName
(
start
sourceUnits
.
addressOfNextCodeUnit
(
)
-
escapeLength
-
1
IdentifierEscapes
:
:
SawUnicodeEscape
modifier
ttp
)
;
}
ungetCodeUnit
(
'
\
\
'
)
;
error
(
JSMSG_BAD_ESCAPE
)
;
return
badToken
(
)
;
}
case
'
|
'
:
if
(
matchCodeUnit
(
'
|
'
)
)
simpleKind
=
TokenKind
:
:
Or
;
#
ifdef
ENABLE_PIPELINE_OPERATOR
else
if
(
matchCodeUnit
(
'
>
'
)
)
simpleKind
=
TokenKind
:
:
Pipeline
;
#
endif
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
BitOrAssign
:
TokenKind
:
:
BitOr
;
break
;
case
'
^
'
:
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
BitXorAssign
:
TokenKind
:
:
BitXor
;
break
;
case
'
&
'
:
if
(
matchCodeUnit
(
'
&
'
)
)
simpleKind
=
TokenKind
:
:
And
;
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
BitAndAssign
:
TokenKind
:
:
BitAnd
;
break
;
case
'
!
'
:
if
(
matchCodeUnit
(
'
=
'
)
)
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
StrictNe
:
TokenKind
:
:
Ne
;
else
simpleKind
=
TokenKind
:
:
Not
;
break
;
case
'
<
'
:
if
(
anyCharsAccess
(
)
.
options
(
)
.
allowHTMLComments
)
{
if
(
matchCodeUnit
(
'
!
'
)
)
{
if
(
matchCodeUnit
(
'
-
'
)
)
{
if
(
matchCodeUnit
(
'
-
'
)
)
{
consumeRestOfSingleLineComment
(
)
;
continue
;
}
ungetCodeUnit
(
'
-
'
)
;
}
ungetCodeUnit
(
'
!
'
)
;
}
}
if
(
matchCodeUnit
(
'
<
'
)
)
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
LshAssign
:
TokenKind
:
:
Lsh
;
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
Le
:
TokenKind
:
:
Lt
;
break
;
case
'
>
'
:
if
(
matchCodeUnit
(
'
>
'
)
)
{
if
(
matchCodeUnit
(
'
>
'
)
)
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
UrshAssign
:
TokenKind
:
:
Ursh
;
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
RshAssign
:
TokenKind
:
:
Rsh
;
}
else
{
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
Ge
:
TokenKind
:
:
Gt
;
}
break
;
case
'
*
'
:
if
(
matchCodeUnit
(
'
*
'
)
)
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
PowAssign
:
TokenKind
:
:
Pow
;
else
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
MulAssign
:
TokenKind
:
:
Mul
;
break
;
case
'
/
'
:
if
(
matchCodeUnit
(
'
/
'
)
)
{
c
=
getCodeUnit
(
)
;
if
(
c
=
=
'
'
|
|
c
=
=
'
#
'
)
{
bool
shouldWarn
=
c
=
=
'
'
;
if
(
!
getDirectives
(
false
shouldWarn
)
)
return
false
;
}
else
{
ungetCodeUnit
(
c
)
;
}
consumeRestOfSingleLineComment
(
)
;
continue
;
}
if
(
matchCodeUnit
(
'
*
'
)
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
unsigned
linenoBefore
=
anyChars
.
lineno
;
do
{
int32_t
unit
=
getCodeUnit
(
)
;
if
(
unit
=
=
EOF
)
{
reportError
(
JSMSG_UNTERMINATED_COMMENT
)
;
return
badToken
(
)
;
}
if
(
unit
=
=
'
*
'
&
&
matchCodeUnit
(
'
/
'
)
)
break
;
if
(
unit
=
=
'
'
|
|
unit
=
=
'
#
'
)
{
bool
shouldWarn
=
unit
=
=
'
'
;
if
(
!
getDirectives
(
true
shouldWarn
)
)
return
badToken
(
)
;
}
else
if
(
MOZ_LIKELY
(
isAsciiCodePoint
(
unit
)
)
)
{
int32_t
codePoint
;
if
(
!
getFullAsciiCodePoint
(
unit
&
codePoint
)
)
return
badToken
(
)
;
}
else
{
int32_t
codePoint
;
if
(
!
getNonAsciiCodePoint
(
unit
&
codePoint
)
)
return
badToken
(
)
;
}
}
while
(
true
)
;
if
(
linenoBefore
!
=
anyChars
.
lineno
)
anyChars
.
updateFlagsForEOL
(
)
;
continue
;
}
if
(
modifier
=
=
Operand
)
return
regexpLiteral
(
start
ttp
)
;
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
DivAssign
:
TokenKind
:
:
Div
;
break
;
case
'
%
'
:
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
ModAssign
:
TokenKind
:
:
Mod
;
break
;
case
'
-
'
:
if
(
matchCodeUnit
(
'
-
'
)
)
{
if
(
anyCharsAccess
(
)
.
options
(
)
.
allowHTMLComments
&
&
!
anyCharsAccess
(
)
.
flags
.
isDirtyLine
)
{
if
(
matchCodeUnit
(
'
>
'
)
)
{
consumeRestOfSingleLineComment
(
)
;
continue
;
}
}
simpleKind
=
TokenKind
:
:
Dec
;
}
else
{
simpleKind
=
matchCodeUnit
(
'
=
'
)
?
TokenKind
:
:
SubAssign
:
TokenKind
:
:
Sub
;
}
break
;
default
:
ungetCodePointIgnoreEOL
(
c
)
;
error
(
JSMSG_ILLEGAL_CHARACTER
)
;
return
badToken
(
)
;
}
MOZ_ASSERT
(
simpleKind
!
=
TokenKind
:
:
Limit
"
switch
-
statement
should
have
set
|
simpleKind
|
before
"
"
breaking
"
)
;
newSimpleToken
(
simpleKind
start
modifier
ttp
)
;
return
true
;
}
while
(
true
)
;
}
template
<
typename
CharT
class
AnyCharsAccess
>
bool
TokenStreamSpecific
<
CharT
AnyCharsAccess
>
:
:
getStringOrTemplateToken
(
char
untilChar
Modifier
modifier
TokenKind
*
out
)
{
MOZ_ASSERT
(
untilChar
=
=
'
\
'
'
|
|
untilChar
=
=
'
"
'
|
|
untilChar
=
=
'
'
"
unexpected
string
/
template
literal
delimiter
"
)
;
bool
parsingTemplate
=
(
untilChar
=
=
'
'
)
;
bool
templateHead
=
false
;
TokenStart
start
(
sourceUnits
-
1
)
;
tokenbuf
.
clear
(
)
;
auto
noteBadToken
=
MakeScopeExit
(
[
this
]
(
)
{
this
-
>
badToken
(
)
;
}
)
;
auto
ReportPrematureEndOfLiteral
=
[
this
untilChar
]
(
unsigned
errnum
)
{
MOZ_ASSERT
(
this
-
>
sourceUnits
.
atEnd
(
)
|
|
this
-
>
sourceUnits
.
peekCodeUnit
(
)
=
=
'
\
r
'
|
|
this
-
>
sourceUnits
.
peekCodeUnit
(
)
=
=
'
\
n
'
"
must
be
parked
at
EOF
or
EOL
to
call
this
function
"
)
;
const
char
delimiters
[
]
=
{
untilChar
untilChar
'
\
0
'
}
;
this
-
>
error
(
errnum
delimiters
)
;
return
;
}
;
int32_t
unit
;
while
(
(
unit
=
getCodeUnit
(
)
)
!
=
untilChar
)
{
if
(
unit
=
=
EOF
)
{
ReportPrematureEndOfLiteral
(
JSMSG_EOF_BEFORE_END_OF_LITERAL
)
;
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
isAsciiCodePoint
(
unit
)
)
)
{
static_assert
(
mozilla
:
:
IsSame
<
CharT
char16_t
>
:
:
value
"
need
a
getNonAsciiCodePoint
that
doesn
'
t
normalize
"
"
LineTerminatorSequences
to
correctly
handle
UTF
-
8
"
)
;
int32_t
codePoint
;
if
(
unit
=
=
unicode
:
:
LINE_SEPARATOR
|
|
unit
=
=
unicode
:
:
PARA_SEPARATOR
)
{
if
(
!
updateLineInfoForEOL
(
)
)
return
false
;
anyCharsAccess
(
)
.
updateFlagsForEOL
(
)
;
codePoint
=
unit
;
}
else
{
if
(
!
getNonAsciiCodePoint
(
unit
&
codePoint
)
)
return
false
;
}
if
(
!
appendCodePointToTokenbuf
(
codePoint
)
)
return
false
;
continue
;
}
if
(
unit
=
=
'
\
\
'
)
{
unit
=
getCodeUnit
(
)
;
if
(
unit
=
=
EOF
)
{
ReportPrematureEndOfLiteral
(
JSMSG_EOF_IN_ESCAPE_IN_LITERAL
)
;
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
isAsciiCodePoint
(
unit
)
)
)
{
int32_t
codePoint
;
if
(
!
getNonAsciiCodePoint
(
unit
&
codePoint
)
)
return
false
;
if
(
codePoint
!
=
'
\
n
'
)
{
if
(
!
tokenbuf
.
append
(
unit
)
)
return
false
;
}
continue
;
}
switch
(
static_cast
<
CharT
>
(
unit
)
)
{
case
'
b
'
:
unit
=
'
\
b
'
;
break
;
case
'
f
'
:
unit
=
'
\
f
'
;
break
;
case
'
n
'
:
unit
=
'
\
n
'
;
break
;
case
'
r
'
:
unit
=
'
\
r
'
;
break
;
case
'
t
'
:
unit
=
'
\
t
'
;
break
;
case
'
v
'
:
unit
=
'
\
v
'
;
break
;
case
'
\
r
'
:
sourceUnits
.
matchCodeUnit
(
'
\
n
'
)
;
MOZ_FALLTHROUGH
;
case
'
\
n
'
:
{
if
(
!
updateLineInfoForEOL
(
)
)
return
false
;
continue
;
}
case
'
u
'
:
{
int32_t
c2
=
getCodeUnit
(
)
;
if
(
c2
=
=
EOF
)
{
ReportPrematureEndOfLiteral
(
JSMSG_EOF_IN_ESCAPE_IN_LITERAL
)
;
return
false
;
}
if
(
c2
=
=
'
{
'
)
{
uint32_t
start
=
sourceUnits
.
offset
(
)
-
3
;
uint32_t
code
=
0
;
bool
first
=
true
;
bool
valid
=
true
;
do
{
int32_t
u3
=
getCodeUnit
(
)
;
if
(
u3
=
=
EOF
)
{
if
(
parsingTemplate
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
InvalidEscapeType
:
:
Unicode
)
;
valid
=
false
;
break
;
}
reportInvalidEscapeError
(
start
InvalidEscapeType
:
:
Unicode
)
;
return
false
;
}
if
(
u3
=
=
'
}
'
)
{
if
(
first
)
{
if
(
parsingTemplate
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
InvalidEscapeType
:
:
Unicode
)
;
valid
=
false
;
break
;
}
reportInvalidEscapeError
(
start
InvalidEscapeType
:
:
Unicode
)
;
return
false
;
}
break
;
}
if
(
!
JS7_ISHEX
(
u3
)
)
{
if
(
parsingTemplate
)
{
ungetCodeUnit
(
u3
)
;
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
InvalidEscapeType
:
:
Unicode
)
;
valid
=
false
;
break
;
}
reportInvalidEscapeError
(
start
InvalidEscapeType
:
:
Unicode
)
;
return
false
;
}
code
=
(
code
<
<
4
)
|
JS7_UNHEX
(
u3
)
;
if
(
code
>
unicode
:
:
NonBMPMax
)
{
if
(
parsingTemplate
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
+
3
InvalidEscapeType
:
:
UnicodeOverflow
)
;
valid
=
false
;
break
;
}
reportInvalidEscapeError
(
start
+
3
InvalidEscapeType
:
:
UnicodeOverflow
)
;
return
false
;
}
first
=
false
;
}
while
(
true
)
;
if
(
!
valid
)
continue
;
MOZ_ASSERT
(
code
<
=
unicode
:
:
NonBMPMax
)
;
if
(
!
appendCodePointToTokenbuf
(
code
)
)
return
false
;
continue
;
}
CharT
cp
[
3
]
;
if
(
JS7_ISHEX
(
c2
)
&
&
sourceUnits
.
peekCodeUnits
(
3
cp
)
&
&
JS7_ISHEX
(
cp
[
0
]
)
&
&
JS7_ISHEX
(
cp
[
1
]
)
&
&
JS7_ISHEX
(
cp
[
2
]
)
)
{
unit
=
(
JS7_UNHEX
(
c2
)
<
<
12
)
|
(
JS7_UNHEX
(
cp
[
0
]
)
<
<
8
)
|
(
JS7_UNHEX
(
cp
[
1
]
)
<
<
4
)
|
JS7_UNHEX
(
cp
[
2
]
)
;
sourceUnits
.
skipCodeUnits
(
3
)
;
}
else
{
ungetCodeUnit
(
c2
)
;
uint32_t
start
=
sourceUnits
.
offset
(
)
-
2
;
if
(
parsingTemplate
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
InvalidEscapeType
:
:
Unicode
)
;
continue
;
}
reportInvalidEscapeError
(
start
InvalidEscapeType
:
:
Unicode
)
;
return
false
;
}
break
;
}
case
'
x
'
:
{
CharT
cp
[
2
]
;
if
(
sourceUnits
.
peekCodeUnits
(
2
cp
)
&
&
JS7_ISHEX
(
cp
[
0
]
)
&
&
JS7_ISHEX
(
cp
[
1
]
)
)
{
unit
=
(
JS7_UNHEX
(
cp
[
0
]
)
<
<
4
)
+
JS7_UNHEX
(
cp
[
1
]
)
;
sourceUnits
.
skipCodeUnits
(
2
)
;
}
else
{
uint32_t
start
=
sourceUnits
.
offset
(
)
-
2
;
if
(
parsingTemplate
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
anyChars
.
setInvalidTemplateEscape
(
start
InvalidEscapeType
:
:
Hexadecimal
)
;
continue
;
}
reportInvalidEscapeError
(
start
InvalidEscapeType
:
:
Hexadecimal
)
;
return
false
;
}
break
;
}
default
:
{
if
(
!
JS7_ISOCT
(
unit
)
)
break
;
int32_t
val
=
JS7_UNOCT
(
unit
)
;
unit
=
peekCodeUnit
(
)
;
if
(
MOZ_UNLIKELY
(
unit
=
=
EOF
)
)
{
ReportPrematureEndOfLiteral
(
JSMSG_EOF_IN_ESCAPE_IN_LITERAL
)
;
return
false
;
}
if
(
val
!
=
0
|
|
IsAsciiDigit
(
unit
)
)
{
TokenStreamAnyChars
&
anyChars
=
anyCharsAccess
(
)
;
if
(
parsingTemplate
)
{
anyChars
.
setInvalidTemplateEscape
(
sourceUnits
.
offset
(
)
-
2
InvalidEscapeType
:
:
Octal
)
;
continue
;
}
if
(
!
reportStrictModeError
(
JSMSG_DEPRECATED_OCTAL
)
)
return
false
;
anyChars
.
flags
.
sawOctalEscape
=
true
;
}
if
(
JS7_ISOCT
(
unit
)
)
{
val
=
8
*
val
+
JS7_UNOCT
(
unit
)
;
consumeKnownCodeUnit
(
unit
)
;
unit
=
peekCodeUnit
(
)
;
if
(
MOZ_UNLIKELY
(
unit
=
=
EOF
)
)
{
ReportPrematureEndOfLiteral
(
JSMSG_EOF_IN_ESCAPE_IN_LITERAL
)
;
return
false
;
}
if
(
JS7_ISOCT
(
unit
)
)
{
int32_t
save
=
val
;
val
=
8
*
val
+
JS7_UNOCT
(
unit
)
;
if
(
val
<
=
0xFF
)
consumeKnownCodeUnit
(
unit
)
;
else
val
=
save
;
}
}
unit
=
char16_t
(
val
)
;
break
;
}
}
if
(
!
tokenbuf
.
append
(
unit
)
)
return
false
;
continue
;
}
if
(
unit
=
=
'
\
r
'
|
|
unit
=
=
'
\
n
'
)
{
if
(
!
parsingTemplate
)
{
ungetCodeUnit
(
unit
)
;
ReportPrematureEndOfLiteral
(
JSMSG_EOL_BEFORE_END_OF_STRING
)
;
return
false
;
}
if
(
unit
=
=
'
\
r
'
)
{
unit
=
'
\
n
'
;
if
(
!
sourceUnits
.
atEnd
(
)
)
sourceUnits
.
matchCodeUnit
(
'
\
n
'
)
;
}
if
(
!
updateLineInfoForEOL
(
)
)
return
false
;
anyCharsAccess
(
)
.
updateFlagsForEOL
(
)
;
}
else
if
(
parsingTemplate
&
&
unit
=
=
'
'
&
&
matchCodeUnit
(
'
{
'
)
)
{
templateHead
=
true
;
break
;
}
if
(
!
tokenbuf
.
append
(
unit
)
)
return
false
;
}
JSAtom
*
atom
=
atomizeChars
(
anyCharsAccess
(
)
.
cx
tokenbuf
.
begin
(
)
tokenbuf
.
length
(
)
)
;
if
(
!
atom
)
return
false
;
noteBadToken
.
release
(
)
;
MOZ_ASSERT_IF
(
!
parsingTemplate
!
templateHead
)
;
TokenKind
kind
=
!
parsingTemplate
?
TokenKind
:
:
String
:
templateHead
?
TokenKind
:
:
TemplateHead
:
TokenKind
:
:
NoSubsTemplate
;
newAtomToken
(
kind
atom
start
modifier
out
)
;
return
true
;
}
const
char
*
TokenKindToDesc
(
TokenKind
tt
)
{
switch
(
tt
)
{
#
define
EMIT_CASE
(
name
desc
)
case
TokenKind
:
:
name
:
return
desc
;
FOR_EACH_TOKEN_KIND
(
EMIT_CASE
)
#
undef
EMIT_CASE
case
TokenKind
:
:
Limit
:
MOZ_ASSERT_UNREACHABLE
(
"
TokenKind
:
:
Limit
should
not
be
passed
.
"
)
;
break
;
}
return
"
<
bad
TokenKind
>
"
;
}
#
ifdef
DEBUG
const
char
*
TokenKindToString
(
TokenKind
tt
)
{
switch
(
tt
)
{
#
define
EMIT_CASE
(
name
desc
)
case
TokenKind
:
:
name
:
return
"
TokenKind
:
:
"
#
name
;
FOR_EACH_TOKEN_KIND
(
EMIT_CASE
)
#
undef
EMIT_CASE
case
TokenKind
:
:
Limit
:
break
;
}
return
"
<
bad
TokenKind
>
"
;
}
#
endif
template
class
frontend
:
:
TokenStreamCharsBase
<
char16_t
>
;
template
class
frontend
:
:
TokenStreamChars
<
char16_t
frontend
:
:
TokenStreamAnyCharsAccess
>
;
template
class
frontend
:
:
TokenStreamSpecific
<
char16_t
frontend
:
:
TokenStreamAnyCharsAccess
>
;
template
class
frontend
:
:
TokenStreamChars
<
char16_t
frontend
:
:
ParserAnyCharsAccess
<
frontend
:
:
GeneralParser
<
frontend
:
:
FullParseHandler
char16_t
>
>
>
;
template
class
frontend
:
:
TokenStreamChars
<
char16_t
frontend
:
:
ParserAnyCharsAccess
<
frontend
:
:
GeneralParser
<
frontend
:
:
SyntaxParseHandler
char16_t
>
>
>
;
template
class
frontend
:
:
TokenStreamSpecific
<
char16_t
frontend
:
:
ParserAnyCharsAccess
<
frontend
:
:
GeneralParser
<
frontend
:
:
FullParseHandler
char16_t
>
>
>
;
template
class
frontend
:
:
TokenStreamSpecific
<
char16_t
frontend
:
:
ParserAnyCharsAccess
<
frontend
:
:
GeneralParser
<
frontend
:
:
SyntaxParseHandler
char16_t
>
>
>
;
}
}
JS_FRIEND_API
(
int
)
js_fgets
(
char
*
buf
int
size
FILE
*
file
)
{
int
n
i
c
;
bool
crflag
;
n
=
size
-
1
;
if
(
n
<
0
)
return
-
1
;
crflag
=
false
;
for
(
i
=
0
;
i
<
n
&
&
(
c
=
fast_getc
(
file
)
)
!
=
EOF
;
i
+
+
)
{
buf
[
i
]
=
c
;
if
(
c
=
=
'
\
n
'
)
{
i
+
+
;
break
;
}
if
(
crflag
)
{
ungetc
(
c
file
)
;
break
;
}
crflag
=
(
c
=
=
'
\
r
'
)
;
}
buf
[
i
]
=
'
\
0
'
;
return
i
;
}
