#
include
"
frontend
/
BytecodeControlStructures
.
h
"
#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
frontend
/
EmitterScope
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
NestableControl
:
:
NestableControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
:
Nestable
<
NestableControl
>
(
&
bce
-
>
innermostNestableControl
)
kind_
(
kind
)
emitterScope_
(
bce
-
>
innermostEmitterScopeNoCheck
(
)
)
{
}
BreakableControl
:
:
BreakableControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
:
NestableControl
(
bce
kind
)
{
MOZ_ASSERT
(
is
<
BreakableControl
>
(
)
)
;
}
bool
BreakableControl
:
:
patchBreaks
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitJumpTargetAndPatch
(
breaks
)
;
}
LabelControl
:
:
LabelControl
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
label
BytecodeOffset
startOffset
)
:
BreakableControl
(
bce
StatementKind
:
:
Label
)
label_
(
label
)
startOffset_
(
startOffset
)
{
}
LoopControl
:
:
LoopControl
(
BytecodeEmitter
*
bce
StatementKind
loopKind
)
:
BreakableControl
(
bce
loopKind
)
tdzCache_
(
bce
)
{
MOZ_ASSERT
(
is
<
LoopControl
>
(
)
)
;
LoopControl
*
enclosingLoop
=
findNearest
<
LoopControl
>
(
enclosing
(
)
)
;
stackDepth_
=
bce
-
>
bytecodeSection
(
)
.
stackDepth
(
)
;
loopDepth_
=
enclosingLoop
?
enclosingLoop
-
>
loopDepth_
+
1
:
1
;
}
bool
LoopControl
:
:
emitContinueTarget
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitJumpTargetAndPatch
(
continues
)
;
}
bool
LoopControl
:
:
emitLoopHead
(
BytecodeEmitter
*
bce
const
Maybe
<
uint32_t
>
&
nextPos
)
{
if
(
bce
-
>
bytecodeSection
(
)
.
offset
(
)
.
toUint32
(
)
=
=
0
)
{
if
(
!
bce
-
>
emit1
(
JSOp
:
:
Nop
)
)
{
return
false
;
}
}
if
(
nextPos
)
{
if
(
!
bce
-
>
updateSourceCoordNotes
(
*
nextPos
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
loopDepth_
>
0
)
;
head_
=
{
bce
-
>
bytecodeSection
(
)
.
offset
(
)
}
;
BytecodeOffset
off
;
if
(
!
bce
-
>
emitJumpTargetOp
(
JSOp
:
:
LoopHead
&
off
)
)
{
return
false
;
}
SetLoopHeadDepthHint
(
bce
-
>
bytecodeSection
(
)
.
code
(
off
)
loopDepth_
)
;
return
true
;
}
bool
LoopControl
:
:
emitLoopEnd
(
BytecodeEmitter
*
bce
JSOp
op
TryNoteKind
tryNoteKind
)
{
JumpList
jump
;
if
(
!
bce
-
>
emitJumpNoFallthrough
(
op
&
jump
)
)
{
return
false
;
}
bce
-
>
patchJumpsToTarget
(
jump
head_
)
;
JumpTarget
breakTarget
;
if
(
!
bce
-
>
emitJumpTarget
(
&
breakTarget
)
)
{
return
false
;
}
if
(
!
patchBreaks
(
bce
)
)
{
return
false
;
}
if
(
!
bce
-
>
addTryNote
(
tryNoteKind
bce
-
>
bytecodeSection
(
)
.
stackDepth
(
)
headOffset
(
)
breakTarget
.
offset
)
)
{
return
false
;
}
return
true
;
}
TryFinallyControl
:
:
TryFinallyControl
(
BytecodeEmitter
*
bce
StatementKind
kind
)
:
NestableControl
(
bce
kind
)
emittingSubroutine_
(
false
)
{
MOZ_ASSERT
(
is
<
TryFinallyControl
>
(
)
)
;
}
