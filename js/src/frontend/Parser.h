#
ifndef
frontend_Parser_h
#
define
frontend_Parser_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
NameCollections
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
SyntaxParseHandler
.
h
"
namespace
js
{
class
ModuleObject
;
namespace
frontend
{
class
ParseContext
:
public
Nestable
<
ParseContext
>
{
public
:
class
Statement
:
public
Nestable
<
Statement
>
{
StatementKind
kind_
;
public
:
using
Nestable
<
Statement
>
:
:
enclosing
;
using
Nestable
<
Statement
>
:
:
findNearest
;
Statement
(
ParseContext
*
pc
StatementKind
kind
)
:
Nestable
<
Statement
>
(
&
pc
-
>
innermostStatement_
)
kind_
(
kind
)
{
}
template
<
typename
T
>
inline
bool
is
(
)
const
;
template
<
typename
T
>
inline
T
&
as
(
)
;
StatementKind
kind
(
)
const
{
return
kind_
;
}
void
refineForKind
(
StatementKind
newForKind
)
{
MOZ_ASSERT
(
kind_
=
=
StatementKind
:
:
ForLoop
)
;
MOZ_ASSERT
(
newForKind
=
=
StatementKind
:
:
ForInLoop
|
|
newForKind
=
=
StatementKind
:
:
ForOfLoop
)
;
kind_
=
newForKind
;
}
}
;
class
LabelStatement
:
public
Statement
{
RootedAtom
label_
;
public
:
LabelStatement
(
ParseContext
*
pc
JSAtom
*
label
)
:
Statement
(
pc
StatementKind
:
:
Label
)
label_
(
pc
-
>
sc_
-
>
context
label
)
{
}
HandleAtom
label
(
)
const
{
return
label_
;
}
}
;
class
Scope
:
public
Nestable
<
Scope
>
{
PooledMapPtr
<
DeclaredNameMap
>
declared_
;
uint32_t
id_
;
bool
maybeReportOOM
(
ParseContext
*
pc
bool
result
)
{
if
(
!
result
)
ReportOutOfMemory
(
pc
-
>
sc
(
)
-
>
context
)
;
return
result
;
}
public
:
using
DeclaredNamePtr
=
DeclaredNameMap
:
:
Ptr
;
using
AddDeclaredNamePtr
=
DeclaredNameMap
:
:
AddPtr
;
using
Nestable
<
Scope
>
:
:
enclosing
;
template
<
typename
ParseHandler
>
explicit
Scope
(
Parser
<
ParseHandler
>
*
parser
)
:
Nestable
<
Scope
>
(
&
parser
-
>
pc
-
>
innermostScope_
)
declared_
(
parser
-
>
context
-
>
frontendCollectionPool
(
)
)
id_
(
parser
-
>
usedNames
.
nextScopeId
(
)
)
{
}
void
dump
(
ParseContext
*
pc
)
;
uint32_t
id
(
)
const
{
return
id_
;
}
MOZ_MUST_USE
bool
init
(
ParseContext
*
pc
)
{
if
(
id_
=
=
UINT32_MAX
)
{
pc
-
>
tokenStream_
.
reportError
(
JSMSG_NEED_DIET
js_script_str
)
;
return
false
;
}
return
declared_
.
acquire
(
pc
-
>
sc
(
)
-
>
context
)
;
}
DeclaredNamePtr
lookupDeclaredName
(
JSAtom
*
name
)
{
return
declared_
-
>
lookup
(
name
)
;
}
AddDeclaredNamePtr
lookupDeclaredNameForAdd
(
JSAtom
*
name
)
{
return
declared_
-
>
lookupForAdd
(
name
)
;
}
MOZ_MUST_USE
bool
addDeclaredName
(
ParseContext
*
pc
AddDeclaredNamePtr
&
p
JSAtom
*
name
DeclarationKind
kind
)
{
return
maybeReportOOM
(
pc
declared_
-
>
add
(
p
name
DeclaredNameInfo
(
kind
)
)
)
;
}
static
void
removeVarForAnnexBLexicalFunction
(
ParseContext
*
pc
JSAtom
*
name
)
;
bool
addCatchParameters
(
ParseContext
*
pc
Scope
&
catchParamScope
)
;
void
removeCatchParameters
(
ParseContext
*
pc
Scope
&
catchParamScope
)
;
void
useAsVarScope
(
ParseContext
*
pc
)
{
MOZ_ASSERT
(
!
pc
-
>
varScope_
)
;
pc
-
>
varScope_
=
this
;
}
class
BindingIter
{
friend
class
Scope
;
DeclaredNameMap
:
:
Range
declaredRange_
;
mozilla
:
:
DebugOnly
<
uint32_t
>
count_
;
bool
isVarScope_
;
BindingIter
(
Scope
&
scope
bool
isVarScope
)
:
declaredRange_
(
scope
.
declared_
-
>
all
(
)
)
count_
(
0
)
isVarScope_
(
isVarScope
)
{
settle
(
)
;
}
void
settle
(
)
{
if
(
isVarScope_
)
return
;
while
(
!
declaredRange_
.
empty
(
)
)
{
if
(
BindingKindIsLexical
(
kind
(
)
)
)
break
;
declaredRange_
.
popFront
(
)
;
}
}
public
:
bool
done
(
)
const
{
return
declaredRange_
.
empty
(
)
;
}
explicit
operator
bool
(
)
const
{
return
!
done
(
)
;
}
JSAtom
*
name
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
declaredRange_
.
front
(
)
.
key
(
)
;
}
DeclarationKind
declarationKind
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
declaredRange_
.
front
(
)
.
value
(
)
-
>
kind
(
)
;
}
BindingKind
kind
(
)
{
return
DeclarationKindToBindingKind
(
declarationKind
(
)
)
;
}
bool
closedOver
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
declaredRange_
.
front
(
)
.
value
(
)
-
>
closedOver
(
)
;
}
void
setClosedOver
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
declaredRange_
.
front
(
)
.
value
(
)
-
>
setClosedOver
(
)
;
}
void
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
count_
!
=
UINT32_MAX
)
;
declaredRange_
.
popFront
(
)
;
settle
(
)
;
}
}
;
inline
BindingIter
bindings
(
ParseContext
*
pc
)
;
}
;
class
VarScope
:
public
Scope
{
public
:
template
<
typename
ParseHandler
>
explicit
VarScope
(
Parser
<
ParseHandler
>
*
parser
)
:
Scope
(
parser
)
{
useAsVarScope
(
parser
-
>
pc
)
;
}
}
;
private
:
SharedContext
*
sc_
;
TokenStream
&
tokenStream_
;
Statement
*
innermostStatement_
;
Scope
*
innermostScope_
;
mozilla
:
:
Maybe
<
Scope
>
namedLambdaScope_
;
mozilla
:
:
Maybe
<
Scope
>
functionScope_
;
Scope
*
varScope_
;
PooledVectorPtr
<
FunctionBoxVector
>
innerFunctionBoxesForAnnexB_
;
PooledVectorPtr
<
AtomVector
>
positionalFormalParameterNames_
;
PooledVectorPtr
<
AtomVector
>
closedOverBindingsForLazy_
;
uint32_t
scriptId_
;
bool
isStandaloneFunctionBody_
;
bool
superScopeNeedsHomeObject_
;
public
:
static
const
uint32_t
NoYieldOffset
=
UINT32_MAX
;
uint32_t
lastYieldOffset
;
Rooted
<
GCVector
<
JSFunction
*
8
>
>
innerFunctionsForLazy
;
Directives
*
newDirectives
;
mozilla
:
:
Maybe
<
DeclarationKind
>
inDestructuringDecl
;
bool
funHasReturnExpr
;
bool
funHasReturnVoid
;
public
:
template
<
typename
ParseHandler
>
ParseContext
(
Parser
<
ParseHandler
>
*
prs
SharedContext
*
sc
Directives
*
newDirectives
)
:
Nestable
<
ParseContext
>
(
&
prs
-
>
pc
)
sc_
(
sc
)
tokenStream_
(
prs
-
>
tokenStream
)
innermostStatement_
(
nullptr
)
innermostScope_
(
nullptr
)
varScope_
(
nullptr
)
innerFunctionBoxesForAnnexB_
(
prs
-
>
context
-
>
frontendCollectionPool
(
)
)
positionalFormalParameterNames_
(
prs
-
>
context
-
>
frontendCollectionPool
(
)
)
closedOverBindingsForLazy_
(
prs
-
>
context
-
>
frontendCollectionPool
(
)
)
scriptId_
(
prs
-
>
usedNames
.
nextScriptId
(
)
)
isStandaloneFunctionBody_
(
false
)
superScopeNeedsHomeObject_
(
false
)
lastYieldOffset
(
NoYieldOffset
)
innerFunctionsForLazy
(
prs
-
>
context
GCVector
<
JSFunction
*
8
>
(
prs
-
>
context
)
)
newDirectives
(
newDirectives
)
funHasReturnExpr
(
false
)
funHasReturnVoid
(
false
)
{
if
(
isFunctionBox
(
)
)
{
if
(
functionBox
(
)
-
>
function
(
)
-
>
isNamedLambda
(
)
)
namedLambdaScope_
.
emplace
(
prs
)
;
functionScope_
.
emplace
(
prs
)
;
}
}
~
ParseContext
(
)
;
MOZ_MUST_USE
bool
init
(
)
;
SharedContext
*
sc
(
)
{
return
sc_
;
}
bool
isFunctionBox
(
)
const
{
return
sc_
-
>
isFunctionBox
(
)
;
}
FunctionBox
*
functionBox
(
)
{
return
sc_
-
>
asFunctionBox
(
)
;
}
Statement
*
innermostStatement
(
)
{
return
innermostStatement_
;
}
Scope
*
innermostScope
(
)
{
MOZ_ASSERT
(
innermostScope_
)
;
return
innermostScope_
;
}
Scope
&
namedLambdaScope
(
)
{
MOZ_ASSERT
(
functionBox
(
)
-
>
function
(
)
-
>
isNamedLambda
(
)
)
;
return
*
namedLambdaScope_
;
}
Scope
&
functionScope
(
)
{
MOZ_ASSERT
(
isFunctionBox
(
)
)
;
return
*
functionScope_
;
}
Scope
&
varScope
(
)
{
MOZ_ASSERT
(
varScope_
)
;
return
*
varScope_
;
}
bool
isFunctionExtraBodyVarScopeInnermost
(
)
{
return
isFunctionBox
(
)
&
&
functionBox
(
)
-
>
hasParameterExprs
&
&
innermostScope
(
)
=
=
varScope_
;
}
template
<
typename
Predicate
>
Statement
*
findInnermostStatement
(
Predicate
predicate
)
{
return
Statement
:
:
findNearest
(
innermostStatement_
predicate
)
;
}
template
<
typename
T
typename
Predicate
>
T
*
findInnermostStatement
(
Predicate
predicate
)
{
return
Statement
:
:
findNearest
<
T
>
(
innermostStatement_
predicate
)
;
}
AtomVector
&
positionalFormalParameterNames
(
)
{
return
*
positionalFormalParameterNames_
;
}
AtomVector
&
closedOverBindingsForLazy
(
)
{
return
*
closedOverBindingsForLazy_
;
}
MOZ_MUST_USE
bool
addInnerFunctionBoxForAnnexB
(
FunctionBox
*
funbox
)
;
void
removeInnerFunctionBoxesForAnnexB
(
JSAtom
*
name
)
;
void
finishInnerFunctionBoxesForAnnexB
(
)
;
bool
atBodyLevel
(
)
{
return
!
innermostStatement_
;
}
bool
atGlobalLevel
(
)
{
return
atBodyLevel
(
)
&
&
sc_
-
>
isGlobalContext
(
)
;
}
bool
atModuleLevel
(
)
{
return
atBodyLevel
(
)
&
&
sc_
-
>
isModuleContext
(
)
;
}
void
setIsStandaloneFunctionBody
(
)
{
isStandaloneFunctionBody_
=
true
;
}
bool
isStandaloneFunctionBody
(
)
const
{
return
isStandaloneFunctionBody_
;
}
void
setSuperScopeNeedsHomeObject
(
)
{
MOZ_ASSERT
(
sc_
-
>
allowSuperProperty
(
)
)
;
superScopeNeedsHomeObject_
=
true
;
}
bool
superScopeNeedsHomeObject
(
)
const
{
return
superScopeNeedsHomeObject_
;
}
bool
useAsmOrInsideUseAsm
(
)
const
{
return
sc_
-
>
isFunctionBox
(
)
&
&
sc_
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
}
GeneratorKind
generatorKind
(
)
const
{
return
sc_
-
>
isFunctionBox
(
)
?
sc_
-
>
asFunctionBox
(
)
-
>
generatorKind
(
)
:
NotGenerator
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
StarGenerator
;
}
bool
isArrowFunction
(
)
const
{
return
sc_
-
>
isFunctionBox
(
)
&
&
sc_
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
isArrow
(
)
;
}
bool
isMethod
(
)
const
{
return
sc_
-
>
isFunctionBox
(
)
&
&
sc_
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
isMethod
(
)
;
}
uint32_t
scriptId
(
)
const
{
return
scriptId_
;
}
}
;
template
<
>
inline
bool
ParseContext
:
:
Statement
:
:
is
<
ParseContext
:
:
LabelStatement
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Label
;
}
template
<
typename
T
>
inline
T
&
ParseContext
:
:
Statement
:
:
as
(
)
{
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
static_cast
<
T
&
>
(
*
this
)
;
}
inline
ParseContext
:
:
Scope
:
:
BindingIter
ParseContext
:
:
Scope
:
:
bindings
(
ParseContext
*
pc
)
{
return
BindingIter
(
*
this
pc
-
>
varScope_
=
=
this
|
|
pc
-
>
functionScope_
.
ptrOr
(
nullptr
)
=
=
this
)
;
}
inline
Directives
:
:
Directives
(
ParseContext
*
parent
)
:
strict_
(
parent
-
>
sc
(
)
-
>
strict
(
)
)
asmJS_
(
parent
-
>
useAsmOrInsideUseAsm
(
)
)
{
}
enum
VarContext
{
HoistVars
DontHoistVars
}
;
enum
PropListType
{
ObjectLiteral
ClassBody
DerivedClassBody
}
;
enum
class
PropertyType
{
Normal
Shorthand
CoverInitializedName
Getter
GetterNoExpressionClosure
Setter
SetterNoExpressionClosure
Method
GeneratorMethod
Constructor
DerivedConstructor
}
;
enum
YieldHandling
{
YieldIsName
YieldIsKeyword
}
;
enum
InHandling
{
InAllowed
InProhibited
}
;
enum
DefaultHandling
{
NameRequired
AllowDefaultName
}
;
enum
TripledotHandling
{
TripledotAllowed
TripledotProhibited
}
;
class
UsedNameTracker
{
public
:
struct
Use
{
uint32_t
scriptId
;
uint32_t
scopeId
;
}
;
class
UsedNameInfo
{
friend
class
UsedNameTracker
;
Vector
<
Use
6
>
uses_
;
void
resetToScope
(
uint32_t
scriptId
uint32_t
scopeId
)
;
public
:
explicit
UsedNameInfo
(
ExclusiveContext
*
cx
)
:
uses_
(
cx
)
{
}
UsedNameInfo
(
UsedNameInfo
&
&
other
)
:
uses_
(
mozilla
:
:
Move
(
other
.
uses_
)
)
{
}
bool
noteUsedInScope
(
uint32_t
scriptId
uint32_t
scopeId
)
{
if
(
uses_
.
empty
(
)
|
|
uses_
.
back
(
)
.
scopeId
<
scopeId
)
return
uses_
.
append
(
Use
{
scriptId
scopeId
}
)
;
return
true
;
}
void
noteBoundInScope
(
uint32_t
scriptId
uint32_t
scopeId
bool
*
closedOver
)
{
*
closedOver
=
false
;
while
(
!
uses_
.
empty
(
)
)
{
Use
&
innermost
=
uses_
.
back
(
)
;
if
(
innermost
.
scopeId
<
scopeId
)
break
;
if
(
innermost
.
scriptId
>
scriptId
)
*
closedOver
=
true
;
uses_
.
popBack
(
)
;
}
}
bool
isUsedInScript
(
uint32_t
scriptId
)
const
{
return
!
uses_
.
empty
(
)
&
&
uses_
.
back
(
)
.
scriptId
>
=
scriptId
;
}
}
;
using
UsedNameMap
=
HashMap
<
JSAtom
*
UsedNameInfo
DefaultHasher
<
JSAtom
*
>
>
;
private
:
UsedNameMap
map_
;
uint32_t
scriptCounter_
;
uint32_t
scopeCounter_
;
public
:
explicit
UsedNameTracker
(
ExclusiveContext
*
cx
)
:
map_
(
cx
)
scriptCounter_
(
0
)
scopeCounter_
(
0
)
{
}
MOZ_MUST_USE
bool
init
(
)
{
return
map_
.
init
(
)
;
}
uint32_t
nextScriptId
(
)
{
MOZ_ASSERT
(
scriptCounter_
!
=
UINT32_MAX
"
ParseContext
:
:
Scope
:
:
init
should
have
prevented
wraparound
"
)
;
return
scriptCounter_
+
+
;
}
uint32_t
nextScopeId
(
)
{
MOZ_ASSERT
(
scopeCounter_
!
=
UINT32_MAX
)
;
return
scopeCounter_
+
+
;
}
UsedNameMap
:
:
Ptr
lookup
(
JSAtom
*
name
)
const
{
return
map_
.
lookup
(
name
)
;
}
MOZ_MUST_USE
bool
noteUse
(
ExclusiveContext
*
cx
JSAtom
*
name
uint32_t
scriptId
uint32_t
scopeId
)
;
struct
RewindToken
{
private
:
friend
class
UsedNameTracker
;
uint32_t
scriptId
;
uint32_t
scopeId
;
}
;
RewindToken
getRewindToken
(
)
const
{
RewindToken
token
;
token
.
scriptId
=
scriptCounter_
;
token
.
scopeId
=
scopeCounter_
;
return
token
;
}
void
rewind
(
RewindToken
token
)
;
void
reset
(
)
{
map_
.
clear
(
)
;
RewindToken
token
;
token
.
scriptId
=
0
;
token
.
scopeId
=
0
;
rewind
(
token
)
;
}
}
;
template
<
typename
ParseHandler
>
class
Parser
final
:
private
JS
:
:
AutoGCRooter
public
StrictModeGetter
{
private
:
class
MOZ_STACK_CLASS
PossibleError
{
protected
:
enum
ErrorState
{
None
Pending
}
;
ErrorState
state_
;
uint32_t
offset_
;
unsigned
errorNumber_
;
ParseReportKind
reportKind_
;
Parser
<
ParseHandler
>
&
parser_
;
bool
strict_
;
public
:
explicit
PossibleError
(
Parser
<
ParseHandler
>
&
parser
)
;
bool
setPending
(
ParseReportKind
kind
unsigned
errorNumber
bool
strict
)
;
void
setResolved
(
)
;
bool
hasError
(
)
;
bool
checkForExprErrors
(
)
;
void
transferErrorTo
(
PossibleError
*
other
)
;
}
;
public
:
ExclusiveContext
*
const
context
;
LifoAlloc
&
alloc
;
TokenStream
tokenStream
;
LifoAlloc
:
:
Mark
tempPoolMark
;
ObjectBox
*
traceListHead
;
ParseContext
*
pc
;
UsedNameTracker
&
usedNames
;
SourceCompressionTask
*
sct
;
ScriptSource
*
ss
;
AutoKeepAtoms
keepAtoms
;
const
bool
foldConstants
:
1
;
private
:
#
if
DEBUG
bool
checkOptionsCalled
:
1
;
#
endif
bool
abortedSyntaxParse
:
1
;
bool
isUnexpectedEOF_
:
1
;
typedef
typename
ParseHandler
:
:
Node
Node
;
public
:
ParseHandler
handler
;
void
prepareNodeForMutation
(
Node
node
)
{
handler
.
prepareNodeForMutation
(
node
)
;
}
void
freeTree
(
Node
node
)
{
handler
.
freeTree
(
node
)
;
}
private
:
bool
reportHelper
(
ParseReportKind
kind
bool
strict
uint32_t
offset
unsigned
errorNumber
va_list
args
)
;
public
:
bool
report
(
ParseReportKind
kind
bool
strict
Node
pn
unsigned
errorNumber
.
.
.
)
;
bool
reportNoOffset
(
ParseReportKind
kind
bool
strict
unsigned
errorNumber
.
.
.
)
;
bool
reportWithOffset
(
ParseReportKind
kind
bool
strict
uint32_t
offset
unsigned
errorNumber
.
.
.
)
;
Parser
(
ExclusiveContext
*
cx
LifoAlloc
&
alloc
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
bool
foldConstants
UsedNameTracker
&
usedNames
Parser
<
SyntaxParseHandler
>
*
syntaxParser
LazyScript
*
lazyOuterFunction
)
;
~
Parser
(
)
;
bool
checkOptions
(
)
;
class
Mark
{
friend
class
Parser
;
LifoAlloc
:
:
Mark
mark
;
ObjectBox
*
traceListHead
;
}
;
Mark
mark
(
)
const
{
Mark
m
;
m
.
mark
=
alloc
.
mark
(
)
;
m
.
traceListHead
=
traceListHead
;
return
m
;
}
void
release
(
Mark
m
)
{
alloc
.
release
(
m
.
mark
)
;
traceListHead
=
m
.
traceListHead
;
}
friend
void
js
:
:
frontend
:
:
MarkParser
(
JSTracer
*
trc
JS
:
:
AutoGCRooter
*
parser
)
;
const
char
*
getFilename
(
)
const
{
return
tokenStream
.
getFilename
(
)
;
}
JSVersion
versionNumber
(
)
const
{
return
tokenStream
.
versionNumber
(
)
;
}
Node
parse
(
)
;
ObjectBox
*
newObjectBox
(
JSObject
*
obj
)
;
FunctionBox
*
newFunctionBox
(
Node
fn
JSFunction
*
fun
Directives
directives
GeneratorKind
generatorKind
bool
tryAnnexB
)
;
JSFunction
*
newFunction
(
HandleAtom
atom
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
HandleObject
proto
)
;
void
trace
(
JSTracer
*
trc
)
;
bool
hadAbortedSyntaxParse
(
)
{
return
abortedSyntaxParse
;
}
void
clearAbortedSyntaxParse
(
)
{
abortedSyntaxParse
=
false
;
}
bool
isUnexpectedEOF
(
)
const
{
return
isUnexpectedEOF_
;
}
bool
checkUnescapedName
(
)
;
private
:
Parser
*
thisForCtor
(
)
{
return
this
;
}
JSAtom
*
stopStringCompression
(
)
;
Node
stringLiteral
(
)
;
Node
noSubstitutionTemplate
(
)
;
Node
templateLiteral
(
YieldHandling
yieldHandling
)
;
bool
taggedTemplate
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
tt
)
;
bool
appendToCallSiteObj
(
Node
callSiteObj
)
;
bool
addExprAndGetNextTemplStrToken
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
*
ttp
)
;
bool
checkStatementsEOF
(
)
;
inline
Node
newName
(
PropertyName
*
name
)
;
inline
Node
newName
(
PropertyName
*
name
TokenPos
pos
)
;
inline
Node
newYieldExpression
(
uint32_t
begin
Node
expr
bool
isYieldStar
=
false
)
;
inline
bool
abortIfSyntaxParser
(
)
;
public
:
Node
statement
(
YieldHandling
yieldHandling
)
;
Node
statementListItem
(
YieldHandling
yieldHandling
bool
canHaveDirectives
=
false
)
;
bool
maybeParseDirective
(
Node
list
Node
pn
bool
*
cont
)
;
Node
evalBody
(
EvalSharedContext
*
evalsc
)
;
Node
globalBody
(
GlobalSharedContext
*
globalsc
)
;
Node
moduleBody
(
ModuleSharedContext
*
modulesc
)
;
Node
standaloneFunctionBody
(
HandleFunction
fun
HandleScope
enclosingScope
Handle
<
PropertyNameVector
>
formals
GeneratorKind
generatorKind
Directives
inheritedDirectives
Directives
*
newDirectives
)
;
Node
standaloneLazyFunction
(
HandleFunction
fun
bool
strict
GeneratorKind
generatorKind
)
;
bool
innerFunction
(
Node
pn
ParseContext
*
outerpc
FunctionBox
*
funbox
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
Directives
inheritedDirectives
Directives
*
newDirectives
)
;
bool
functionFormalParametersAndBody
(
InHandling
inHandling
YieldHandling
yieldHandling
Node
pn
FunctionSyntaxKind
kind
)
;
bool
yieldExpressionsSupported
(
)
{
return
versionNumber
(
)
>
=
JSVERSION_1_7
|
|
pc
-
>
isGenerator
(
)
;
}
PropertyName
*
bindingIdentifier
(
YieldHandling
yieldHandling
)
;
virtual
bool
strictMode
(
)
{
return
pc
-
>
sc
(
)
-
>
strict
(
)
;
}
bool
setLocalStrictMode
(
bool
strict
)
{
MOZ_ASSERT
(
tokenStream
.
debugHasNoLookahead
(
)
)
;
return
pc
-
>
sc
(
)
-
>
setLocalStrictMode
(
strict
)
;
}
const
ReadOnlyCompileOptions
&
options
(
)
const
{
return
tokenStream
.
options
(
)
;
}
private
:
enum
InvokedPrediction
{
PredictUninvoked
=
false
PredictInvoked
=
true
}
;
enum
ForInitLocation
{
InForInit
NotInForInit
}
;
private
:
Node
functionStmt
(
YieldHandling
yieldHandling
DefaultHandling
defaultHandling
)
;
Node
functionExpr
(
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
statementList
(
YieldHandling
yieldHandling
)
;
Node
blockStatement
(
YieldHandling
yieldHandling
unsigned
errorNumber
=
JSMSG_CURLY_IN_COMPOUND
)
;
Node
doWhileStatement
(
YieldHandling
yieldHandling
)
;
Node
whileStatement
(
YieldHandling
yieldHandling
)
;
Node
forStatement
(
YieldHandling
yieldHandling
)
;
bool
forHeadStart
(
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInitialPart
mozilla
:
:
Maybe
<
ParseContext
:
:
Scope
>
&
forLetImpliedScope
Node
*
forInOrOfExpression
)
;
bool
validateForInOrOfLHSExpression
(
Node
target
PossibleError
*
possibleError
)
;
Node
expressionAfterForInOrOf
(
ParseNodeKind
forHeadKind
YieldHandling
yieldHandling
)
;
Node
switchStatement
(
YieldHandling
yieldHandling
)
;
Node
continueStatement
(
YieldHandling
yieldHandling
)
;
Node
breakStatement
(
YieldHandling
yieldHandling
)
;
Node
returnStatement
(
YieldHandling
yieldHandling
)
;
Node
withStatement
(
YieldHandling
yieldHandling
)
;
Node
throwStatement
(
YieldHandling
yieldHandling
)
;
Node
tryStatement
(
YieldHandling
yieldHandling
)
;
Node
catchBlockStatement
(
YieldHandling
yieldHandling
ParseContext
:
:
Scope
&
catchParamScope
)
;
Node
debuggerStatement
(
)
;
Node
variableStatement
(
YieldHandling
yieldHandling
)
;
Node
labeledStatement
(
YieldHandling
yieldHandling
)
;
Node
labeledItem
(
YieldHandling
yieldHandling
)
;
Node
ifStatement
(
YieldHandling
yieldHandling
)
;
Node
consequentOrAlternative
(
YieldHandling
yieldHandling
)
;
bool
nextTokenContinuesLetDeclaration
(
TokenKind
next
YieldHandling
yieldHandling
)
;
Node
lexicalDeclaration
(
YieldHandling
yieldHandling
bool
isConst
)
;
Node
importDeclaration
(
)
;
Node
exportDeclaration
(
)
;
Node
expressionStatement
(
YieldHandling
yieldHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
declarationList
(
YieldHandling
yieldHandling
ParseNodeKind
kind
ParseNodeKind
*
forHeadKind
=
nullptr
Node
*
forInOrOfExpression
=
nullptr
)
;
Node
declarationPattern
(
Node
decl
DeclarationKind
declKind
TokenKind
tt
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
Node
declarationName
(
Node
decl
DeclarationKind
declKind
TokenKind
tt
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
bool
initializerInNameDeclaration
(
Node
decl
Node
binding
Handle
<
PropertyName
*
>
name
DeclarationKind
declKind
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
Node
expr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
expr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
assignExpr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
assignExpr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
assignExprWithoutYield
(
YieldHandling
yieldHandling
unsigned
err
)
;
Node
yieldExpression
(
InHandling
inHandling
)
;
Node
condExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
orExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
unaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
memberExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
TokenKind
tt
bool
allowCallSyntax
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
memberExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
TokenKind
tt
bool
allowCallSyntax
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
primaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
TokenKind
tt
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
exprInParens
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
PossibleError
*
possibleError
)
;
Node
exprInParens
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
)
;
bool
tryNewTarget
(
Node
&
newTarget
)
;
bool
checkAndMarkSuperScope
(
)
;
Node
methodDefinition
(
PropertyType
propType
HandleAtom
funName
)
;
bool
functionArguments
(
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
Node
funcpn
)
;
Node
functionDefinition
(
InHandling
inHandling
YieldHandling
yieldHandling
HandleAtom
name
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
InvokedPrediction
invoked
=
PredictUninvoked
)
;
enum
FunctionBodyType
{
StatementListBody
ExpressionBody
}
;
Node
functionBody
(
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
FunctionBodyType
type
)
;
Node
unaryOpExpr
(
YieldHandling
yieldHandling
ParseNodeKind
kind
JSOp
op
uint32_t
begin
)
;
Node
condition
(
InHandling
inHandling
YieldHandling
yieldHandling
)
;
Node
generatorComprehensionLambda
(
unsigned
begin
)
;
Node
comprehensionFor
(
GeneratorKind
comprehensionKind
)
;
Node
comprehensionIf
(
GeneratorKind
comprehensionKind
)
;
Node
comprehensionTail
(
GeneratorKind
comprehensionKind
)
;
Node
comprehension
(
GeneratorKind
comprehensionKind
)
;
Node
arrayComprehension
(
uint32_t
begin
)
;
Node
generatorComprehension
(
uint32_t
begin
)
;
bool
argumentList
(
YieldHandling
yieldHandling
Node
listNode
bool
*
isSpread
)
;
Node
destructuringDeclaration
(
DeclarationKind
kind
YieldHandling
yieldHandling
TokenKind
tt
)
;
Node
destructuringDeclarationWithoutYield
(
DeclarationKind
kind
YieldHandling
yieldHandling
TokenKind
tt
unsigned
msg
)
;
bool
namedImportsOrNamespaceImport
(
TokenKind
tt
Node
importSpecSet
)
;
bool
checkExportedName
(
JSAtom
*
exportName
)
;
bool
checkExportedNamesForDeclaration
(
Node
node
)
;
enum
ClassContext
{
ClassStatement
ClassExpression
}
;
Node
classDefinition
(
YieldHandling
yieldHandling
ClassContext
classContext
DefaultHandling
defaultHandling
)
;
PropertyName
*
labelOrIdentifierReference
(
YieldHandling
yieldHandling
bool
yieldTokenizedAsName
)
;
PropertyName
*
labelIdentifier
(
YieldHandling
yieldHandling
)
{
return
labelOrIdentifierReference
(
yieldHandling
false
)
;
}
PropertyName
*
identifierReference
(
YieldHandling
yieldHandling
bool
yieldTokenizedAsName
=
false
)
{
return
labelOrIdentifierReference
(
yieldHandling
yieldTokenizedAsName
)
;
}
PropertyName
*
importedBinding
(
)
{
return
bindingIdentifier
(
YieldIsName
)
;
}
Node
identifierReference
(
Handle
<
PropertyName
*
>
name
)
;
bool
matchLabel
(
YieldHandling
yieldHandling
MutableHandle
<
PropertyName
*
>
label
)
;
bool
allowsForEachIn
(
)
{
#
if
!
JS_HAS_FOR_EACH_IN
return
false
;
#
else
return
versionNumber
(
)
>
=
JSVERSION_1_6
;
#
endif
}
enum
AssignmentFlavor
{
PlainAssignment
CompoundAssignment
KeyedDestructuringAssignment
IncrementAssignment
DecrementAssignment
ForInOrOfTarget
}
;
bool
checkAndMarkAsAssignmentLhs
(
Node
pn
AssignmentFlavor
flavor
PossibleError
*
possibleError
=
nullptr
)
;
bool
matchInOrOf
(
bool
*
isForInp
bool
*
isForOfp
)
;
bool
hasUsedFunctionSpecialName
(
HandlePropertyName
name
)
;
bool
declareFunctionArgumentsObject
(
)
;
bool
declareFunctionThis
(
)
;
Node
newInternalDotName
(
HandlePropertyName
name
)
;
Node
newThisName
(
)
;
Node
newDotGeneratorName
(
)
;
bool
declareDotGeneratorName
(
)
;
bool
checkFunctionDefinition
(
HandleAtom
funAtom
Node
pn
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
bool
*
tryAnnexB
)
;
bool
skipLazyInnerFunction
(
Node
pn
FunctionSyntaxKind
kind
bool
tryAnnexB
)
;
bool
innerFunction
(
Node
pn
ParseContext
*
outerpc
HandleFunction
fun
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
bool
tryAnnexB
Directives
inheritedDirectives
Directives
*
newDirectives
)
;
bool
trySyntaxParseInnerFunction
(
Node
pn
HandleFunction
fun
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
bool
tryAnnexB
Directives
inheritedDirectives
Directives
*
newDirectives
)
;
bool
finishFunctionScopes
(
)
;
bool
finishFunction
(
)
;
bool
leaveInnerFunction
(
ParseContext
*
outerpc
)
;
public
:
enum
FunctionCallBehavior
{
PermitAssignmentToFunctionCalls
ForbidAssignmentToFunctionCalls
}
;
bool
isValidSimpleAssignmentTarget
(
Node
node
FunctionCallBehavior
behavior
=
ForbidAssignmentToFunctionCalls
)
;
private
:
bool
reportIfArgumentsEvalTarget
(
Node
nameNode
)
;
bool
reportIfNotValidSimpleAssignmentTarget
(
Node
target
AssignmentFlavor
flavor
)
;
bool
checkAndMarkAsIncOperand
(
Node
kid
AssignmentFlavor
flavor
)
;
bool
checkStrictAssignment
(
Node
lhs
)
;
bool
checkStrictBinding
(
PropertyName
*
name
TokenPos
pos
)
;
void
reportRedeclaration
(
HandlePropertyName
name
DeclarationKind
kind
TokenPos
pos
)
;
bool
notePositionalFormalParameter
(
Node
fn
HandlePropertyName
name
bool
disallowDuplicateParams
=
false
bool
*
duplicatedParam
=
nullptr
)
;
bool
noteDestructuredPositionalFormalParameter
(
Node
fn
Node
destruct
)
;
mozilla
:
:
Maybe
<
DeclarationKind
>
isVarRedeclaredInEval
(
HandlePropertyName
name
DeclarationKind
kind
)
;
bool
tryDeclareVar
(
HandlePropertyName
name
DeclarationKind
kind
mozilla
:
:
Maybe
<
DeclarationKind
>
*
redeclaredKind
)
;
bool
tryDeclareVarForAnnexBLexicalFunction
(
HandlePropertyName
name
bool
*
tryAnnexB
)
;
bool
checkLexicalDeclarationDirectlyWithinBlock
(
ParseContext
:
:
Statement
&
stmt
DeclarationKind
kind
TokenPos
pos
)
;
bool
noteDeclaredName
(
HandlePropertyName
name
DeclarationKind
kind
TokenPos
pos
)
;
bool
noteUsedName
(
HandlePropertyName
name
)
;
bool
hasUsedName
(
HandlePropertyName
name
)
;
bool
propagateFreeNamesAndMarkClosedOverBindings
(
ParseContext
:
:
Scope
&
scope
)
;
mozilla
:
:
Maybe
<
GlobalScope
:
:
Data
*
>
newGlobalScopeData
(
ParseContext
:
:
Scope
&
scope
)
;
mozilla
:
:
Maybe
<
ModuleScope
:
:
Data
*
>
newModuleScopeData
(
ParseContext
:
:
Scope
&
scope
)
;
mozilla
:
:
Maybe
<
EvalScope
:
:
Data
*
>
newEvalScopeData
(
ParseContext
:
:
Scope
&
scope
)
;
mozilla
:
:
Maybe
<
FunctionScope
:
:
Data
*
>
newFunctionScopeData
(
ParseContext
:
:
Scope
&
scope
bool
hasParameterExprs
)
;
mozilla
:
:
Maybe
<
VarScope
:
:
Data
*
>
newVarScopeData
(
ParseContext
:
:
Scope
&
scope
)
;
mozilla
:
:
Maybe
<
LexicalScope
:
:
Data
*
>
newLexicalScopeData
(
ParseContext
:
:
Scope
&
scope
)
;
Node
finishLexicalScope
(
ParseContext
:
:
Scope
&
scope
Node
body
)
;
Node
propertyName
(
YieldHandling
yieldHandling
Node
propList
PropertyType
*
propType
MutableHandleAtom
propAtom
)
;
Node
computedPropertyName
(
YieldHandling
yieldHandling
Node
literal
)
;
Node
arrayInitializer
(
YieldHandling
yieldHandling
)
;
Node
newRegExp
(
)
;
Node
objectLiteral
(
YieldHandling
yieldHandling
PossibleError
*
possibleError
)
;
bool
checkDestructuringPattern
(
Node
pattern
mozilla
:
:
Maybe
<
DeclarationKind
>
maybeDecl
=
mozilla
:
:
Nothing
(
)
)
;
bool
checkDestructuringArray
(
Node
arrayPattern
mozilla
:
:
Maybe
<
DeclarationKind
>
maybeDecl
)
;
bool
checkDestructuringObject
(
Node
objectPattern
mozilla
:
:
Maybe
<
DeclarationKind
>
maybeDecl
)
;
bool
checkDestructuringName
(
Node
expr
mozilla
:
:
Maybe
<
DeclarationKind
>
maybeDecl
)
;
bool
checkAssignmentToCall
(
Node
node
unsigned
errnum
)
;
Node
newNumber
(
const
Token
&
tok
)
{
return
handler
.
newNumber
(
tok
.
number
(
)
tok
.
decimalPoint
(
)
tok
.
pos
)
;
}
static
Node
null
(
)
{
return
ParseHandler
:
:
null
(
)
;
}
bool
reportBadReturn
(
Node
pn
ParseReportKind
kind
unsigned
errnum
unsigned
anonerrnum
)
;
JSAtom
*
prefixAccessorName
(
PropertyType
propType
HandleAtom
propAtom
)
;
TokenPos
pos
(
)
const
{
return
tokenStream
.
currentToken
(
)
.
pos
;
}
bool
asmJS
(
Node
list
)
;
void
addTelemetry
(
JSCompartment
:
:
DeprecatedLanguageExtension
e
)
;
bool
warnOnceAboutExprClosure
(
)
;
bool
warnOnceAboutForEach
(
)
;
}
;
}
}
#
endif
