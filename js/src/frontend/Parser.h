#
ifndef
frontend_Parser_h
#
define
frontend_Parser_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
ParseMaps
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
SyntaxParseHandler
.
h
"
namespace
js
{
class
ModuleObject
;
class
StaticFunctionBoxScopeObject
;
namespace
frontend
{
struct
StmtInfoPC
:
public
StmtInfoBase
{
static
const
unsigned
BlockIdLimit
=
1
<
<
ParseNode
:
:
NumBlockIdBits
;
StmtInfoPC
*
enclosing
;
StmtInfoPC
*
enclosingScope
;
uint32_t
blockid
;
uint32_t
innerBlockScopeDepth
;
uint16_t
firstDominatingLexicalInCase
;
explicit
StmtInfoPC
(
ExclusiveContext
*
cx
)
:
StmtInfoBase
(
cx
)
blockid
(
BlockIdLimit
)
innerBlockScopeDepth
(
0
)
firstDominatingLexicalInCase
(
0
)
{
}
}
;
class
SharedContext
;
typedef
Vector
<
Definition
*
16
>
DeclVector
;
struct
GenericParseContext
{
GenericParseContext
*
parent
;
SharedContext
*
sc
;
bool
funHasReturnExpr
:
1
;
bool
funHasReturnVoid
:
1
;
GenericParseContext
(
GenericParseContext
*
parent
SharedContext
*
sc
)
:
parent
(
parent
)
sc
(
sc
)
funHasReturnExpr
(
false
)
funHasReturnVoid
(
false
)
{
}
}
;
template
<
typename
ParseHandler
>
bool
GenerateBlockId
(
TokenStream
&
ts
ParseContext
<
ParseHandler
>
*
pc
uint32_t
&
blockid
)
;
template
<
typename
ParseHandler
>
struct
MOZ_STACK_CLASS
ParseContext
:
public
GenericParseContext
{
typedef
typename
ParseHandler
:
:
Node
Node
;
typedef
typename
ParseHandler
:
:
DefinitionNode
DefinitionNode
;
uint32_t
bodyid
;
StmtInfoStack
<
StmtInfoPC
>
stmtStack
;
Node
maybeFunction
;
mozilla
:
:
Maybe
<
JSFunction
:
:
AutoParseUsingFunctionBox
>
parseUsingFunctionBox
;
static
const
uint32_t
NoYieldOffset
=
UINT32_MAX
;
uint32_t
lastYieldOffset
;
GeneratorKind
generatorKind
(
)
const
{
return
sc
-
>
isFunctionBox
(
)
?
sc
-
>
asFunctionBox
(
)
-
>
generatorKind
(
)
:
NotGenerator
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
StarGenerator
;
}
bool
isArrowFunction
(
)
const
{
return
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
isArrow
(
)
;
}
bool
isMethod
(
)
const
{
return
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
isMethod
(
)
;
}
uint32_t
blockScopeDepth
;
Node
blockNode
;
private
:
AtomDecls
<
ParseHandler
>
decls_
;
DeclVector
args_
;
DeclVector
vars_
;
DeclVector
bodyLevelLexicals_
;
bool
checkLocalsOverflow
(
TokenStream
&
ts
)
;
public
:
const
AtomDecls
<
ParseHandler
>
&
decls
(
)
const
{
return
decls_
;
}
uint32_t
numArgs
(
)
const
{
MOZ_ASSERT
(
sc
-
>
isFunctionBox
(
)
)
;
return
args_
.
length
(
)
;
}
bool
define
(
TokenStream
&
ts
HandlePropertyName
name
Node
pn
Definition
:
:
Kind
)
;
void
popLetDecl
(
JSAtom
*
atom
)
;
void
prepareToAddDuplicateArg
(
HandlePropertyName
name
DefinitionNode
prevDecl
)
;
void
updateDecl
(
TokenStream
&
ts
JSAtom
*
atom
Node
newDecl
)
;
bool
generateBindings
(
ExclusiveContext
*
cx
TokenStream
&
ts
LifoAlloc
&
alloc
MutableHandle
<
Bindings
>
bindings
)
const
;
private
:
ParseContext
*
*
parserPC
;
ParseContext
<
ParseHandler
>
*
oldpc
;
public
:
OwnedAtomDefnMapPtr
lexdeps
;
Rooted
<
GCVector
<
JSFunction
*
>
>
innerFunctions
;
Directives
*
newDirectives
;
bool
inDeclDestructuring
:
1
;
ParseContext
(
Parser
<
ParseHandler
>
*
prs
GenericParseContext
*
parent
Node
maybeFunction
SharedContext
*
sc
Directives
*
newDirectives
)
:
GenericParseContext
(
parent
sc
)
bodyid
(
0
)
stmtStack
(
prs
-
>
context
)
maybeFunction
(
maybeFunction
)
lastYieldOffset
(
NoYieldOffset
)
blockScopeDepth
(
0
)
blockNode
(
ParseHandler
:
:
null
(
)
)
decls_
(
prs
-
>
context
prs
-
>
alloc
)
args_
(
prs
-
>
context
)
vars_
(
prs
-
>
context
)
bodyLevelLexicals_
(
prs
-
>
context
)
parserPC
(
&
prs
-
>
pc
)
oldpc
(
prs
-
>
pc
)
lexdeps
(
prs
-
>
context
)
innerFunctions
(
prs
-
>
context
GCVector
<
JSFunction
*
>
(
prs
-
>
context
)
)
newDirectives
(
newDirectives
)
inDeclDestructuring
(
false
)
{
prs
-
>
pc
=
this
;
if
(
sc
-
>
isFunctionBox
(
)
)
parseUsingFunctionBox
.
emplace
(
prs
-
>
context
sc
-
>
asFunctionBox
(
)
)
;
}
~
ParseContext
(
)
;
bool
init
(
Parser
<
ParseHandler
>
&
parser
)
;
unsigned
blockid
(
)
{
return
stmtStack
.
innermost
(
)
?
stmtStack
.
innermost
(
)
-
>
blockid
:
bodyid
;
}
StmtInfoPC
*
innermostStmt
(
)
const
{
return
stmtStack
.
innermost
(
)
;
}
StmtInfoPC
*
innermostScopeStmt
(
)
const
{
return
stmtStack
.
innermostScopeStmt
(
)
;
}
StmtInfoPC
*
innermostNonLabelStmt
(
)
const
{
return
stmtStack
.
innermostNonLabel
(
)
;
}
StaticScope
*
innermostStaticScope
(
)
const
{
if
(
StmtInfoPC
*
stmt
=
innermostScopeStmt
(
)
)
return
stmt
-
>
staticScope
;
return
sc
-
>
staticScope
(
)
;
}
bool
atBodyLevel
(
StmtInfoPC
*
stmt
)
{
if
(
sc
-
>
staticScope
(
)
-
>
is
<
StaticEvalScope
>
(
)
)
{
bool
bl
=
!
stmt
-
>
enclosing
;
MOZ_ASSERT_IF
(
bl
stmt
-
>
type
=
=
StmtType
:
:
BLOCK
)
;
MOZ_ASSERT_IF
(
bl
stmt
-
>
staticScope
-
>
enclosingScope
(
)
=
=
sc
-
>
staticScope
(
)
)
;
return
bl
;
}
return
!
stmt
;
}
bool
atBodyLevel
(
)
{
return
atBodyLevel
(
innermostStmt
(
)
)
;
}
bool
atGlobalLevel
(
)
{
return
atBodyLevel
(
)
&
&
sc
-
>
isGlobalContext
(
)
&
&
!
innermostScopeStmt
(
)
;
}
bool
atModuleLevel
(
)
{
return
atBodyLevel
(
)
&
&
sc
-
>
isModuleBox
(
)
;
}
bool
isFunctionConstructorBody
(
)
const
{
return
sc
-
>
isFunctionBox
(
)
&
&
!
parent
&
&
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
isLambda
(
)
;
}
inline
bool
useAsmOrInsideUseAsm
(
)
const
{
return
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
}
}
;
template
<
typename
ParseHandler
>
inline
Directives
:
:
Directives
(
ParseContext
<
ParseHandler
>
*
parent
)
:
strict_
(
parent
-
>
sc
-
>
strict
(
)
)
asmJS_
(
parent
-
>
useAsmOrInsideUseAsm
(
)
)
{
}
template
<
typename
ParseHandler
>
struct
BindData
;
class
CompExprTransplanter
;
enum
VarContext
{
HoistVars
DontHoistVars
}
;
enum
PropListType
{
ObjectLiteral
ClassBody
DerivedClassBody
}
;
enum
class
PropertyType
{
Normal
Shorthand
Getter
GetterNoExpressionClosure
Setter
SetterNoExpressionClosure
Method
GeneratorMethod
Constructor
DerivedConstructor
}
;
enum
YieldHandling
{
YieldIsName
YieldIsKeyword
}
;
enum
InHandling
{
InAllowed
InProhibited
}
;
enum
DefaultHandling
{
NameRequired
AllowDefaultName
}
;
enum
TripledotHandling
{
TripledotAllowed
TripledotProhibited
}
;
template
<
typename
ParseHandler
>
class
Parser
:
private
JS
:
:
AutoGCRooter
public
StrictModeGetter
{
class
MOZ_STACK_CLASS
AutoPushStmtInfoPC
{
Parser
<
ParseHandler
>
&
parser_
;
StmtInfoPC
stmt_
;
public
:
AutoPushStmtInfoPC
(
Parser
<
ParseHandler
>
&
parser
StmtType
type
)
;
AutoPushStmtInfoPC
(
Parser
<
ParseHandler
>
&
parser
StmtType
type
NestedStaticScope
&
staticScope
)
;
~
AutoPushStmtInfoPC
(
)
;
bool
generateBlockId
(
)
;
bool
makeInnermostLexicalScope
(
StaticBlockScope
&
blockScope
)
;
StmtInfoPC
&
operator
*
(
)
{
return
stmt_
;
}
StmtInfoPC
*
operator
-
>
(
)
{
return
&
stmt_
;
}
operator
StmtInfoPC
*
(
)
{
return
&
stmt_
;
}
}
;
public
:
ExclusiveContext
*
const
context
;
LifoAlloc
&
alloc
;
TokenStream
tokenStream
;
LifoAlloc
:
:
Mark
tempPoolMark
;
ObjectBox
*
traceListHead
;
ParseContext
<
ParseHandler
>
*
pc
;
AutoObjectVector
blockScopes
;
SourceCompressionTask
*
sct
;
ScriptSource
*
ss
;
AutoKeepAtoms
keepAtoms
;
const
bool
foldConstants
:
1
;
private
:
#
if
DEBUG
bool
checkOptionsCalled
:
1
;
#
endif
bool
abortedSyntaxParse
:
1
;
bool
isUnexpectedEOF_
:
1
;
typedef
typename
ParseHandler
:
:
Node
Node
;
typedef
typename
ParseHandler
:
:
DefinitionNode
DefinitionNode
;
public
:
ParseHandler
handler
;
void
prepareNodeForMutation
(
Node
node
)
{
handler
.
prepareNodeForMutation
(
node
)
;
}
void
freeTree
(
Node
node
)
{
handler
.
freeTree
(
node
)
;
}
private
:
bool
reportHelper
(
ParseReportKind
kind
bool
strict
uint32_t
offset
unsigned
errorNumber
va_list
args
)
;
public
:
bool
report
(
ParseReportKind
kind
bool
strict
Node
pn
unsigned
errorNumber
.
.
.
)
;
bool
reportNoOffset
(
ParseReportKind
kind
bool
strict
unsigned
errorNumber
.
.
.
)
;
bool
reportWithOffset
(
ParseReportKind
kind
bool
strict
uint32_t
offset
unsigned
errorNumber
.
.
.
)
;
Parser
(
ExclusiveContext
*
cx
LifoAlloc
*
alloc
const
ReadOnlyCompileOptions
&
options
const
char16_t
*
chars
size_t
length
bool
foldConstants
Parser
<
SyntaxParseHandler
>
*
syntaxParser
LazyScript
*
lazyOuterFunction
)
;
~
Parser
(
)
;
bool
checkOptions
(
)
;
class
Mark
{
friend
class
Parser
;
LifoAlloc
:
:
Mark
mark
;
ObjectBox
*
traceListHead
;
}
;
Mark
mark
(
)
const
{
Mark
m
;
m
.
mark
=
alloc
.
mark
(
)
;
m
.
traceListHead
=
traceListHead
;
return
m
;
}
void
release
(
Mark
m
)
{
alloc
.
release
(
m
.
mark
)
;
traceListHead
=
m
.
traceListHead
;
}
friend
void
js
:
:
frontend
:
:
MarkParser
(
JSTracer
*
trc
JS
:
:
AutoGCRooter
*
parser
)
;
const
char
*
getFilename
(
)
const
{
return
tokenStream
.
getFilename
(
)
;
}
JSVersion
versionNumber
(
)
const
{
return
tokenStream
.
versionNumber
(
)
;
}
Node
parse
(
)
;
ObjectBox
*
newObjectBox
(
JSObject
*
obj
)
;
FunctionBox
*
newFunctionBox
(
Node
fn
JSFunction
*
fun
ParseContext
<
ParseHandler
>
*
outerpc
Directives
directives
GeneratorKind
generatorKind
Handle
<
StaticScope
*
>
enclosingStaticScope
)
;
FunctionBox
*
newFunctionBox
(
Node
fn
HandleFunction
fun
Directives
directives
GeneratorKind
generatorKind
Handle
<
StaticScope
*
>
enclosingStaticScope
)
{
return
newFunctionBox
(
fn
fun
nullptr
directives
generatorKind
enclosingStaticScope
)
;
}
FunctionBox
*
newFunctionBox
(
Node
fn
HandleFunction
fun
ParseContext
<
ParseHandler
>
*
outerpc
Directives
directives
GeneratorKind
generatorKind
)
{
Rooted
<
StaticScope
*
>
enclosing
(
context
outerpc
-
>
innermostStaticScope
(
)
)
;
return
newFunctionBox
(
fn
fun
outerpc
directives
generatorKind
enclosing
)
;
}
ModuleBox
*
newModuleBox
(
Node
pn
HandleModuleObject
module
ModuleBuilder
&
builder
)
;
JSFunction
*
newFunction
(
HandleAtom
atom
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
HandleObject
proto
)
;
bool
generateBlockId
(
StaticScope
*
staticScope
uint32_t
*
blockIdOut
)
{
if
(
blockScopes
.
length
(
)
=
=
StmtInfoPC
:
:
BlockIdLimit
)
{
tokenStream
.
reportError
(
JSMSG_NEED_DIET
"
program
"
)
;
return
false
;
}
MOZ_ASSERT
(
blockScopes
.
length
(
)
<
StmtInfoPC
:
:
BlockIdLimit
)
;
*
blockIdOut
=
blockScopes
.
length
(
)
;
return
blockScopes
.
append
(
staticScope
)
;
}
void
trace
(
JSTracer
*
trc
)
;
bool
hadAbortedSyntaxParse
(
)
{
return
abortedSyntaxParse
;
}
void
clearAbortedSyntaxParse
(
)
{
abortedSyntaxParse
=
false
;
}
bool
isUnexpectedEOF
(
)
const
{
return
isUnexpectedEOF_
;
}
bool
checkUnescapedName
(
)
;
private
:
Parser
*
thisForCtor
(
)
{
return
this
;
}
JSAtom
*
stopStringCompression
(
)
;
Node
stringLiteral
(
)
;
Node
noSubstitutionTemplate
(
)
;
Node
templateLiteral
(
YieldHandling
yieldHandling
)
;
bool
taggedTemplate
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
tt
)
;
bool
appendToCallSiteObj
(
Node
callSiteObj
)
;
bool
addExprAndGetNextTemplStrToken
(
YieldHandling
yieldHandling
Node
nodeList
TokenKind
*
ttp
)
;
bool
checkStatementsEOF
(
)
;
inline
Node
newName
(
PropertyName
*
name
)
;
inline
Node
newYieldExpression
(
uint32_t
begin
Node
expr
bool
isYieldStar
=
false
)
;
inline
bool
abortIfSyntaxParser
(
)
;
public
:
Node
statement
(
YieldHandling
yieldHandling
bool
canHaveDirectives
=
false
)
;
bool
maybeParseDirective
(
Node
list
Node
pn
bool
*
cont
)
;
Node
evalBody
(
)
;
Node
globalBody
(
)
;
Node
standaloneModule
(
Handle
<
ModuleObject
*
>
module
ModuleBuilder
&
builder
)
;
Node
standaloneFunctionBody
(
HandleFunction
fun
Handle
<
PropertyNameVector
>
formals
GeneratorKind
generatorKind
Directives
inheritedDirectives
Directives
*
newDirectives
Handle
<
StaticScope
*
>
enclosingStaticScope
)
;
Node
standaloneLazyFunction
(
HandleFunction
fun
bool
strict
GeneratorKind
generatorKind
)
;
enum
FunctionBodyType
{
StatementListBody
ExpressionBody
}
;
Node
functionBody
(
InHandling
inHandling
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
FunctionBodyType
type
)
;
bool
functionArgsAndBodyGeneric
(
InHandling
inHandling
YieldHandling
yieldHandling
Node
pn
HandleFunction
fun
FunctionSyntaxKind
kind
)
;
bool
checkYieldNameValidity
(
)
;
bool
yieldExpressionsSupported
(
)
{
return
versionNumber
(
)
>
=
JSVERSION_1_7
|
|
pc
-
>
isGenerator
(
)
;
}
virtual
bool
strictMode
(
)
{
return
pc
-
>
sc
-
>
strict
(
)
;
}
bool
setLocalStrictMode
(
bool
strict
)
{
MOZ_ASSERT
(
tokenStream
.
debugHasNoLookahead
(
)
)
;
return
pc
-
>
sc
-
>
setLocalStrictMode
(
strict
)
;
}
const
ReadOnlyCompileOptions
&
options
(
)
const
{
return
tokenStream
.
options
(
)
;
}
private
:
enum
InvokedPrediction
{
PredictUninvoked
=
false
PredictInvoked
=
true
}
;
enum
ForInitLocation
{
InForInit
NotInForInit
}
;
private
:
Node
functionStmt
(
YieldHandling
yieldHandling
DefaultHandling
defaultHandling
)
;
Node
functionExpr
(
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
statements
(
YieldHandling
yieldHandling
)
;
Node
blockStatement
(
YieldHandling
yieldHandling
)
;
Node
ifStatement
(
YieldHandling
yieldHandling
)
;
Node
doWhileStatement
(
YieldHandling
yieldHandling
)
;
Node
whileStatement
(
YieldHandling
yieldHandling
)
;
Node
forStatement
(
YieldHandling
yieldHandling
)
;
bool
forHeadStart
(
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInitialPart
mozilla
:
:
Maybe
<
AutoPushStmtInfoPC
>
&
letStmt
MutableHandle
<
StaticBlockScope
*
>
blockScope
Node
*
forLetImpliedBlock
Node
*
forInOrOfExpression
)
;
bool
validateForInOrOfLHSExpression
(
Node
target
)
;
Node
expressionAfterForInOrOf
(
ParseNodeKind
forHeadKind
YieldHandling
yieldHandling
)
;
void
assertCurrentLexicalStaticBlockIs
(
ParseContext
<
ParseHandler
>
*
pc
Handle
<
StaticBlockScope
*
>
blockScope
)
;
Node
switchStatement
(
YieldHandling
yieldHandling
)
;
Node
continueStatement
(
YieldHandling
yieldHandling
)
;
Node
breakStatement
(
YieldHandling
yieldHandling
)
;
Node
returnStatement
(
YieldHandling
yieldHandling
)
;
Node
withStatement
(
YieldHandling
yieldHandling
)
;
Node
labeledStatement
(
YieldHandling
yieldHandling
)
;
Node
throwStatement
(
YieldHandling
yieldHandling
)
;
Node
tryStatement
(
YieldHandling
yieldHandling
)
;
Node
debuggerStatement
(
)
;
Node
lexicalDeclaration
(
YieldHandling
yieldHandling
bool
isConst
)
;
Node
importDeclaration
(
)
;
Node
exportDeclaration
(
)
;
Node
expressionStatement
(
YieldHandling
yieldHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
declarationList
(
YieldHandling
yieldHandling
ParseNodeKind
kind
StaticBlockScope
*
blockScope
=
nullptr
ParseNodeKind
*
forHeadKind
=
nullptr
Node
*
forInOrOfExpression
=
nullptr
)
;
Node
declarationPattern
(
Node
decl
TokenKind
tt
BindData
<
ParseHandler
>
*
data
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
Node
declarationName
(
Node
decl
TokenKind
tt
BindData
<
ParseHandler
>
*
data
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
bool
initializerInNameDeclaration
(
Node
decl
Node
binding
Handle
<
PropertyName
*
>
name
BindData
<
ParseHandler
>
*
data
bool
initialDeclaration
YieldHandling
yieldHandling
ParseNodeKind
*
forHeadKind
Node
*
forInOrOfExpression
)
;
Node
expr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
assignExpr
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
assignExprWithoutYield
(
YieldHandling
yieldHandling
unsigned
err
)
;
Node
yieldExpression
(
InHandling
inHandling
)
;
Node
condExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
orExpr1
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
unaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
memberExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
TokenKind
tt
bool
allowCallSyntax
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
primaryExpr
(
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
TokenKind
tt
InvokedPrediction
invoked
=
PredictUninvoked
)
;
Node
exprInParens
(
InHandling
inHandling
YieldHandling
yieldHandling
TripledotHandling
tripledotHandling
)
;
bool
tryNewTarget
(
Node
&
newTarget
)
;
bool
checkAndMarkSuperScope
(
)
;
Node
methodDefinition
(
YieldHandling
yieldHandling
PropertyType
propType
HandlePropertyName
funName
)
;
bool
functionArguments
(
YieldHandling
yieldHandling
FunctionSyntaxKind
kind
Node
funcpn
bool
*
hasRest
)
;
Node
functionDef
(
InHandling
inHandling
YieldHandling
uieldHandling
HandlePropertyName
name
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
InvokedPrediction
invoked
=
PredictUninvoked
Node
*
assignmentForAnnexBOut
=
nullptr
)
;
bool
functionArgsAndBody
(
InHandling
inHandling
Node
pn
HandleFunction
fun
FunctionSyntaxKind
kind
GeneratorKind
generatorKind
Directives
inheritedDirectives
Directives
*
newDirectives
)
;
Node
unaryOpExpr
(
YieldHandling
yieldHandling
ParseNodeKind
kind
JSOp
op
uint32_t
begin
)
;
Node
condition
(
InHandling
inHandling
YieldHandling
yieldHandling
)
;
Node
generatorComprehensionLambda
(
unsigned
begin
)
;
Node
comprehensionFor
(
GeneratorKind
comprehensionKind
)
;
Node
comprehensionIf
(
GeneratorKind
comprehensionKind
)
;
Node
comprehensionTail
(
GeneratorKind
comprehensionKind
)
;
Node
comprehension
(
GeneratorKind
comprehensionKind
)
;
Node
arrayComprehension
(
uint32_t
begin
)
;
Node
generatorComprehension
(
uint32_t
begin
)
;
bool
argumentList
(
YieldHandling
yieldHandling
Node
listNode
bool
*
isSpread
)
;
Node
destructuringExpr
(
YieldHandling
yieldHandling
BindData
<
ParseHandler
>
*
data
TokenKind
tt
)
;
Node
destructuringExprWithoutYield
(
YieldHandling
yieldHandling
BindData
<
ParseHandler
>
*
data
TokenKind
tt
unsigned
msg
)
;
Node
newBoundImportForCurrentName
(
)
;
bool
namedImportsOrNamespaceImport
(
TokenKind
tt
Node
importSpecSet
)
;
bool
checkExportedName
(
JSAtom
*
exportName
)
;
bool
checkExportedNamesForDeclaration
(
Node
node
)
;
enum
ClassContext
{
ClassStatement
ClassExpression
}
;
Node
classDefinition
(
YieldHandling
yieldHandling
ClassContext
classContext
DefaultHandling
defaultHandling
)
;
Node
identifierName
(
YieldHandling
yieldHandling
)
;
bool
matchLabel
(
YieldHandling
yieldHandling
MutableHandle
<
PropertyName
*
>
label
)
;
bool
allowsForEachIn
(
)
{
#
if
!
JS_HAS_FOR_EACH_IN
return
false
;
#
else
return
versionNumber
(
)
>
=
JSVERSION_1_6
;
#
endif
}
enum
AssignmentFlavor
{
PlainAssignment
CompoundAssignment
KeyedDestructuringAssignment
IncrementAssignment
DecrementAssignment
ForInOrOfTarget
}
;
bool
checkAndMarkAsAssignmentLhs
(
Node
pn
AssignmentFlavor
flavor
)
;
bool
matchInOrOf
(
bool
*
isForInp
bool
*
isForOfp
)
;
bool
checkFunctionArguments
(
)
;
bool
defineFunctionThis
(
)
;
Node
newThisName
(
)
;
bool
makeDefIntoUse
(
Definition
*
dn
Node
pn
HandleAtom
atom
)
;
bool
bindLexicalFunctionName
(
HandlePropertyName
funName
ParseNode
*
pn
)
;
bool
bindBodyLevelFunctionName
(
HandlePropertyName
funName
ParseNode
*
*
pn
)
;
bool
checkFunctionDefinition
(
HandlePropertyName
funName
Node
*
pn
FunctionSyntaxKind
kind
bool
*
pbodyProcessed
Node
*
assignmentForAnnexBOut
)
;
bool
finishFunctionDefinition
(
Node
pn
FunctionBox
*
funbox
Node
body
)
;
bool
addFreeVariablesFromLazyFunction
(
JSFunction
*
fun
ParseContext
<
ParseHandler
>
*
pc
)
;
bool
shouldParseLetDeclaration
(
bool
*
parseDeclOut
)
;
bool
peekShouldParseLetDeclaration
(
bool
*
parseDeclOut
TokenStream
:
:
Modifier
modifier
)
;
public
:
enum
FunctionCallBehavior
{
PermitAssignmentToFunctionCalls
ForbidAssignmentToFunctionCalls
}
;
bool
isValidSimpleAssignmentTarget
(
Node
node
FunctionCallBehavior
behavior
=
ForbidAssignmentToFunctionCalls
)
;
private
:
bool
reportIfArgumentsEvalTarget
(
Node
nameNode
)
;
bool
reportIfNotValidSimpleAssignmentTarget
(
Node
target
AssignmentFlavor
flavor
)
;
bool
checkAndMarkAsIncOperand
(
Node
kid
AssignmentFlavor
flavor
)
;
bool
checkStrictAssignment
(
Node
lhs
)
;
bool
checkStrictBinding
(
PropertyName
*
name
Node
pn
)
;
bool
defineArg
(
Node
funcpn
HandlePropertyName
name
bool
disallowDuplicateArgs
=
false
Node
*
duplicatedArg
=
nullptr
)
;
Node
pushLexicalScope
(
AutoPushStmtInfoPC
&
stmt
)
;
Node
pushLexicalScope
(
Handle
<
StaticBlockScope
*
>
blockScope
AutoPushStmtInfoPC
&
stmt
)
;
Node
pushLetScope
(
Handle
<
StaticBlockScope
*
>
blockScope
AutoPushStmtInfoPC
&
stmt
)
;
bool
noteNameUse
(
HandlePropertyName
name
Node
pn
)
;
Node
propertyName
(
YieldHandling
yieldHandling
Node
propList
PropertyType
*
propType
MutableHandleAtom
propAtom
)
;
Node
computedPropertyName
(
YieldHandling
yieldHandling
Node
literal
)
;
Node
arrayInitializer
(
YieldHandling
yieldHandling
)
;
Node
newRegExp
(
)
;
Node
objectLiteral
(
YieldHandling
yieldHandling
)
;
enum
PrepareLexicalKind
{
PrepareLet
PrepareConst
PrepareFunction
}
;
bool
checkAndPrepareLexical
(
PrepareLexicalKind
prepareWhat
const
TokenPos
&
errorPos
)
;
bool
prepareAndBindInitializedLexicalWithNode
(
HandlePropertyName
name
PrepareLexicalKind
prepareWhat
ParseNode
*
pn
const
TokenPos
&
pos
)
;
Node
makeInitializedLexicalBinding
(
HandlePropertyName
name
PrepareLexicalKind
prepareWhat
const
TokenPos
&
pos
)
;
Node
newBindingNode
(
PropertyName
*
name
bool
functionScope
VarContext
varContext
=
HoistVars
)
;
bool
checkDestructuringPattern
(
BindData
<
ParseHandler
>
*
data
Node
pattern
)
;
bool
checkDestructuringArray
(
BindData
<
ParseHandler
>
*
data
Node
arrayPattern
)
;
bool
checkDestructuringObject
(
BindData
<
ParseHandler
>
*
data
Node
objectPattern
)
;
bool
checkDestructuringName
(
BindData
<
ParseHandler
>
*
data
Node
expr
)
;
bool
bindInitialized
(
BindData
<
ParseHandler
>
*
data
HandlePropertyName
name
Node
pn
)
;
bool
bindInitialized
(
BindData
<
ParseHandler
>
*
data
Node
pn
)
;
bool
bindUninitialized
(
BindData
<
ParseHandler
>
*
data
HandlePropertyName
name
Node
pn
)
;
bool
bindUninitialized
(
BindData
<
ParseHandler
>
*
data
Node
pn
)
;
bool
makeSetCall
(
Node
node
unsigned
errnum
)
;
Node
cloneForInOrOfDeclarationForAssignment
(
Node
decl
)
;
Node
cloneLeftHandSide
(
Node
opn
)
;
Node
cloneDestructuringDefault
(
Node
opn
)
;
Node
cloneParseTree
(
Node
opn
)
;
Node
newNumber
(
const
Token
&
tok
)
{
return
handler
.
newNumber
(
tok
.
number
(
)
tok
.
decimalPoint
(
)
tok
.
pos
)
;
}
static
bool
bindDestructuringArg
(
BindData
<
ParseHandler
>
*
data
HandlePropertyName
name
Parser
<
ParseHandler
>
*
parser
)
;
static
bool
bindLexical
(
BindData
<
ParseHandler
>
*
data
HandlePropertyName
name
Parser
<
ParseHandler
>
*
parser
)
;
static
bool
bindVar
(
BindData
<
ParseHandler
>
*
data
HandlePropertyName
name
Parser
<
ParseHandler
>
*
parser
)
;
static
Node
null
(
)
{
return
ParseHandler
:
:
null
(
)
;
}
bool
reportRedeclaration
(
Node
pn
Definition
:
:
Kind
redeclKind
HandlePropertyName
name
)
;
bool
reportBadReturn
(
Node
pn
ParseReportKind
kind
unsigned
errnum
unsigned
anonerrnum
)
;
DefinitionNode
getOrCreateLexicalDependency
(
ParseContext
<
ParseHandler
>
*
pc
JSAtom
*
atom
)
;
bool
leaveFunction
(
Node
fn
ParseContext
<
ParseHandler
>
*
outerpc
FunctionSyntaxKind
kind
=
Expression
)
;
TokenPos
pos
(
)
const
{
return
tokenStream
.
currentToken
(
)
.
pos
;
}
bool
asmJS
(
Node
list
)
;
void
addTelemetry
(
JSCompartment
:
:
DeprecatedLanguageExtension
e
)
;
bool
warnOnceAboutExprClosure
(
)
;
friend
struct
BindData
<
ParseHandler
>
;
}
;
}
}
#
define
TS
(
p
)
(
&
(
p
)
-
>
tokenStream
)
#
endif
