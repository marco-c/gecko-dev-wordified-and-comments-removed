#
ifndef
frontend_UsedNameTracker_h
#
define
frontend_UsedNameTracker_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
namespace
frontend
{
class
UsedNameTracker
{
public
:
struct
Use
{
uint32_t
scriptId
;
uint32_t
scopeId
;
}
;
class
UsedNameInfo
{
friend
class
UsedNameTracker
;
Vector
<
Use
6
>
uses_
;
void
resetToScope
(
uint32_t
scriptId
uint32_t
scopeId
)
;
public
:
explicit
UsedNameInfo
(
JSContext
*
cx
)
:
uses_
(
cx
)
{
}
UsedNameInfo
(
UsedNameInfo
&
&
other
)
:
uses_
(
std
:
:
move
(
other
.
uses_
)
)
{
}
bool
noteUsedInScope
(
uint32_t
scriptId
uint32_t
scopeId
)
{
if
(
uses_
.
empty
(
)
|
|
uses_
.
back
(
)
.
scopeId
<
scopeId
)
{
return
uses_
.
append
(
Use
{
scriptId
scopeId
}
)
;
}
return
true
;
}
void
noteBoundInScope
(
uint32_t
scriptId
uint32_t
scopeId
bool
*
closedOver
)
{
*
closedOver
=
false
;
while
(
!
uses_
.
empty
(
)
)
{
Use
&
innermost
=
uses_
.
back
(
)
;
if
(
innermost
.
scopeId
<
scopeId
)
{
break
;
}
if
(
innermost
.
scriptId
>
scriptId
)
{
*
closedOver
=
true
;
}
uses_
.
popBack
(
)
;
}
}
bool
isUsedInScript
(
uint32_t
scriptId
)
const
{
return
!
uses_
.
empty
(
)
&
&
uses_
.
back
(
)
.
scriptId
>
=
scriptId
;
}
}
;
using
UsedNameMap
=
HashMap
<
JSAtom
*
UsedNameInfo
DefaultHasher
<
JSAtom
*
>
>
;
private
:
UsedNameMap
map_
;
uint32_t
scriptCounter_
;
uint32_t
scopeCounter_
;
public
:
explicit
UsedNameTracker
(
JSContext
*
cx
)
:
map_
(
cx
)
scriptCounter_
(
0
)
scopeCounter_
(
0
)
{
}
uint32_t
nextScriptId
(
)
{
MOZ_ASSERT
(
scriptCounter_
!
=
UINT32_MAX
"
ParseContext
:
:
Scope
:
:
init
should
have
prevented
wraparound
"
)
;
return
scriptCounter_
+
+
;
}
uint32_t
nextScopeId
(
)
{
MOZ_ASSERT
(
scopeCounter_
!
=
UINT32_MAX
)
;
return
scopeCounter_
+
+
;
}
UsedNameMap
:
:
Ptr
lookup
(
JSAtom
*
name
)
const
{
return
map_
.
lookup
(
name
)
;
}
MOZ_MUST_USE
bool
noteUse
(
JSContext
*
cx
JSAtom
*
name
uint32_t
scriptId
uint32_t
scopeId
)
;
MOZ_MUST_USE
bool
markAsAlwaysClosedOver
(
JSContext
*
cx
JSAtom
*
name
uint32_t
scriptId
uint32_t
scopeId
)
{
return
noteUse
(
cx
name
scriptId
+
1
scopeId
+
1
)
;
}
struct
RewindToken
{
private
:
friend
class
UsedNameTracker
;
uint32_t
scriptId
;
uint32_t
scopeId
;
}
;
RewindToken
getRewindToken
(
)
const
{
RewindToken
token
;
token
.
scriptId
=
scriptCounter_
;
token
.
scopeId
=
scopeCounter_
;
return
token
;
}
void
rewind
(
RewindToken
token
)
;
}
;
}
}
#
endif
