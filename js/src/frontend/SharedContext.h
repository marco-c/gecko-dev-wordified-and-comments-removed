#
ifndef
frontend_SharedContext_h
#
define
frontend_SharedContext_h
#
include
"
jsatom
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
ModuleObject
.
h
"
#
include
"
ds
/
InlineTable
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
namespace
js
{
namespace
frontend
{
enum
class
StatementKind
:
uint8_t
{
Label
Block
If
Switch
With
Catch
Try
Finally
ForLoopLexicalHead
ForLoop
ForInLoop
ForOfLoop
DoLoop
WhileLoop
Spread
}
;
static
inline
bool
StatementKindIsLoop
(
StatementKind
kind
)
{
return
kind
=
=
StatementKind
:
:
ForLoop
|
|
kind
=
=
StatementKind
:
:
ForInLoop
|
|
kind
=
=
StatementKind
:
:
ForOfLoop
|
|
kind
=
=
StatementKind
:
:
DoLoop
|
|
kind
=
=
StatementKind
:
:
WhileLoop
|
|
kind
=
=
StatementKind
:
:
Spread
;
}
static
inline
bool
StatementKindIsUnlabeledBreakTarget
(
StatementKind
kind
)
{
return
StatementKindIsLoop
(
kind
)
|
|
kind
=
=
StatementKind
:
:
Switch
;
}
template
<
typename
Concrete
>
class
MOZ_STACK_CLASS
Nestable
{
Concrete
*
*
stack_
;
Concrete
*
enclosing_
;
protected
:
explicit
Nestable
(
Concrete
*
*
stack
)
:
stack_
(
stack
)
enclosing_
(
*
stack
)
{
*
stack_
=
static_cast
<
Concrete
*
>
(
this
)
;
}
Concrete
*
enclosing
(
)
const
{
return
enclosing_
;
}
template
<
typename
Predicate
>
static
Concrete
*
findNearest
(
Concrete
*
it
Predicate
predicate
)
{
while
(
it
&
&
!
predicate
(
it
)
)
it
=
it
-
>
enclosing
(
)
;
return
it
;
}
template
<
typename
T
>
static
T
*
findNearest
(
Concrete
*
it
)
{
while
(
it
&
&
!
it
-
>
template
is
<
T
>
(
)
)
it
=
it
-
>
enclosing
(
)
;
return
it
?
&
it
-
>
template
as
<
T
>
(
)
:
nullptr
;
}
template
<
typename
T
typename
Predicate
>
static
T
*
findNearest
(
Concrete
*
it
Predicate
predicate
)
{
while
(
it
&
&
(
!
it
-
>
template
is
<
T
>
(
)
|
|
!
predicate
(
&
it
-
>
template
as
<
T
>
(
)
)
)
)
it
=
it
-
>
enclosing
(
)
;
return
it
?
&
it
-
>
template
as
<
T
>
(
)
:
nullptr
;
}
public
:
~
Nestable
(
)
{
MOZ_ASSERT
(
*
stack_
=
=
static_cast
<
Concrete
*
>
(
this
)
)
;
*
stack_
=
enclosing_
;
}
}
;
class
AnyContextFlags
{
friend
class
SharedContext
;
bool
hasExplicitUseStrict
:
1
;
bool
bindingsAccessedDynamically
:
1
;
bool
hasDebuggerStatement
:
1
;
bool
hasDirectEval
:
1
;
public
:
AnyContextFlags
(
)
:
hasExplicitUseStrict
(
false
)
bindingsAccessedDynamically
(
false
)
hasDebuggerStatement
(
false
)
hasDirectEval
(
false
)
{
}
}
;
class
FunctionContextFlags
{
friend
class
FunctionBox
;
bool
hasExtensibleScope
:
1
;
bool
argumentsHasLocalBinding
:
1
;
bool
definitelyNeedsArgsObj
:
1
;
bool
needsHomeObject
:
1
;
bool
isDerivedClassConstructor
:
1
;
bool
hasThisBinding
:
1
;
bool
hasInnerFunctions
:
1
;
public
:
FunctionContextFlags
(
)
:
hasExtensibleScope
(
false
)
argumentsHasLocalBinding
(
false
)
definitelyNeedsArgsObj
(
false
)
needsHomeObject
(
false
)
isDerivedClassConstructor
(
false
)
hasThisBinding
(
false
)
hasInnerFunctions
(
false
)
{
}
}
;
class
Directives
{
bool
strict_
;
bool
asmJS_
;
public
:
explicit
Directives
(
bool
strict
)
:
strict_
(
strict
)
asmJS_
(
false
)
{
}
explicit
Directives
(
ParseContext
*
parent
)
;
void
setStrict
(
)
{
strict_
=
true
;
}
bool
strict
(
)
const
{
return
strict_
;
}
void
setAsmJS
(
)
{
asmJS_
=
true
;
}
bool
asmJS
(
)
const
{
return
asmJS_
;
}
Directives
&
operator
=
(
Directives
rhs
)
{
strict_
=
rhs
.
strict_
;
asmJS_
=
rhs
.
asmJS_
;
return
*
this
;
}
bool
operator
=
=
(
const
Directives
&
rhs
)
const
{
return
strict_
=
=
rhs
.
strict_
&
&
asmJS_
=
=
rhs
.
asmJS_
;
}
bool
operator
!
=
(
const
Directives
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
enum
class
ThisBinding
{
Global
Function
Module
}
;
class
GlobalSharedContext
;
class
EvalSharedContext
;
class
ModuleSharedContext
;
class
SharedContext
{
public
:
ExclusiveContext
*
const
context
;
AnyContextFlags
anyCxFlags
;
bool
strictScript
;
bool
localStrict
;
bool
extraWarnings
;
protected
:
enum
class
Kind
{
ObjectBox
Global
Eval
Module
}
;
Kind
kind_
;
ThisBinding
thisBinding_
;
bool
allowNewTarget_
;
bool
allowSuperProperty_
;
bool
allowSuperCall_
;
bool
inWith_
;
bool
needsThisTDZChecks_
;
void
computeAllowSyntax
(
Scope
*
scope
)
;
void
computeInWith
(
Scope
*
scope
)
;
void
computeThisBinding
(
Scope
*
scope
)
;
public
:
SharedContext
(
ExclusiveContext
*
cx
Kind
kind
Directives
directives
bool
extraWarnings
)
:
context
(
cx
)
anyCxFlags
(
)
strictScript
(
directives
.
strict
(
)
)
localStrict
(
false
)
extraWarnings
(
extraWarnings
)
kind_
(
kind
)
thisBinding_
(
ThisBinding
:
:
Global
)
allowNewTarget_
(
false
)
allowSuperProperty_
(
false
)
allowSuperCall_
(
false
)
inWith_
(
false
)
needsThisTDZChecks_
(
false
)
{
}
virtual
Scope
*
compilationEnclosingScope
(
)
const
=
0
;
virtual
ObjectBox
*
toObjectBox
(
)
{
return
nullptr
;
}
bool
isObjectBox
(
)
{
return
toObjectBox
(
)
;
}
bool
isFunctionBox
(
)
{
return
isObjectBox
(
)
&
&
toObjectBox
(
)
-
>
isFunctionBox
(
)
;
}
inline
FunctionBox
*
asFunctionBox
(
)
;
bool
isModuleContext
(
)
{
return
kind_
=
=
Kind
:
:
Module
;
}
inline
ModuleSharedContext
*
asModuleContext
(
)
;
bool
isGlobalContext
(
)
{
return
kind_
=
=
Kind
:
:
Global
;
}
inline
GlobalSharedContext
*
asGlobalContext
(
)
;
bool
isEvalContext
(
)
{
return
kind_
=
=
Kind
:
:
Eval
;
}
inline
EvalSharedContext
*
asEvalContext
(
)
;
ThisBinding
thisBinding
(
)
const
{
return
thisBinding_
;
}
bool
allowNewTarget
(
)
const
{
return
allowNewTarget_
;
}
bool
allowSuperProperty
(
)
const
{
return
allowSuperProperty_
;
}
bool
allowSuperCall
(
)
const
{
return
allowSuperCall_
;
}
bool
inWith
(
)
const
{
return
inWith_
;
}
bool
needsThisTDZChecks
(
)
const
{
return
needsThisTDZChecks_
;
}
bool
hasExplicitUseStrict
(
)
const
{
return
anyCxFlags
.
hasExplicitUseStrict
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
anyCxFlags
.
bindingsAccessedDynamically
;
}
bool
hasDebuggerStatement
(
)
const
{
return
anyCxFlags
.
hasDebuggerStatement
;
}
bool
hasDirectEval
(
)
const
{
return
anyCxFlags
.
hasDirectEval
;
}
void
setExplicitUseStrict
(
)
{
anyCxFlags
.
hasExplicitUseStrict
=
true
;
}
void
setBindingsAccessedDynamically
(
)
{
anyCxFlags
.
bindingsAccessedDynamically
=
true
;
}
void
setHasDebuggerStatement
(
)
{
anyCxFlags
.
hasDebuggerStatement
=
true
;
}
void
setHasDirectEval
(
)
{
anyCxFlags
.
hasDirectEval
=
true
;
}
inline
bool
allBindingsClosedOver
(
)
;
bool
strict
(
)
const
{
return
strictScript
|
|
localStrict
;
}
bool
setLocalStrictMode
(
bool
strict
)
{
bool
retVal
=
localStrict
;
localStrict
=
strict
;
return
retVal
;
}
bool
needStrictChecks
(
)
const
{
return
strict
(
)
|
|
extraWarnings
;
}
bool
isDotVariable
(
JSAtom
*
atom
)
const
{
return
atom
=
=
context
-
>
names
(
)
.
dotGenerator
|
|
atom
=
=
context
-
>
names
(
)
.
dotThis
;
}
}
;
class
MOZ_STACK_CLASS
GlobalSharedContext
:
public
SharedContext
{
ScopeKind
scopeKind_
;
public
:
Rooted
<
GlobalScope
:
:
Data
*
>
bindings
;
GlobalSharedContext
(
ExclusiveContext
*
cx
ScopeKind
scopeKind
Directives
directives
bool
extraWarnings
)
:
SharedContext
(
cx
Kind
:
:
Global
directives
extraWarnings
)
scopeKind_
(
scopeKind
)
bindings
(
cx
)
{
MOZ_ASSERT
(
scopeKind
=
=
ScopeKind
:
:
Global
|
|
scopeKind
=
=
ScopeKind
:
:
NonSyntactic
)
;
thisBinding_
=
ThisBinding
:
:
Global
;
}
Scope
*
compilationEnclosingScope
(
)
const
override
{
return
nullptr
;
}
ScopeKind
scopeKind
(
)
const
{
return
scopeKind_
;
}
}
;
inline
GlobalSharedContext
*
SharedContext
:
:
asGlobalContext
(
)
{
MOZ_ASSERT
(
isGlobalContext
(
)
)
;
return
static_cast
<
GlobalSharedContext
*
>
(
this
)
;
}
class
MOZ_STACK_CLASS
EvalSharedContext
:
public
SharedContext
{
RootedScope
enclosingScope_
;
public
:
Rooted
<
EvalScope
:
:
Data
*
>
bindings
;
EvalSharedContext
(
ExclusiveContext
*
cx
JSObject
*
enclosingEnv
Scope
*
enclosingScope
Directives
directives
bool
extraWarnings
)
;
Scope
*
compilationEnclosingScope
(
)
const
override
{
return
enclosingScope_
;
}
}
;
inline
EvalSharedContext
*
SharedContext
:
:
asEvalContext
(
)
{
MOZ_ASSERT
(
isEvalContext
(
)
)
;
return
static_cast
<
EvalSharedContext
*
>
(
this
)
;
}
class
FunctionBox
:
public
ObjectBox
public
SharedContext
{
Scope
*
enclosingScope_
;
LexicalScope
:
:
Data
*
namedLambdaBindings_
;
FunctionScope
:
:
Data
*
functionScopeBindings_
;
VarScope
:
:
Data
*
extraVarScopeBindings_
;
void
initWithEnclosingScope
(
Scope
*
enclosingScope
)
;
public
:
ParseNode
*
functionNode
;
uint32_t
bufStart
;
uint32_t
bufEnd
;
uint32_t
startLine
;
uint32_t
startColumn
;
uint16_t
length
;
uint8_t
generatorKindBits_
;
bool
isGenexpLambda
:
1
;
bool
hasDestructuringArgs
:
1
;
bool
hasParameterExprs
:
1
;
bool
hasDirectEvalInParameterExpr
:
1
;
bool
hasDuplicateParameters
:
1
;
bool
useAsm
:
1
;
bool
insideUseAsm
:
1
;
bool
isAnnexB
:
1
;
bool
wasEmitted
:
1
;
bool
declaredArguments
:
1
;
bool
usesArguments
:
1
;
bool
usesApply
:
1
;
bool
usesThis
:
1
;
bool
usesReturn
:
1
;
FunctionContextFlags
funCxFlags
;
FunctionBox
(
ExclusiveContext
*
cx
LifoAlloc
&
alloc
ObjectBox
*
traceListHead
JSFunction
*
fun
Directives
directives
bool
extraWarnings
GeneratorKind
generatorKind
)
;
MutableHandle
<
LexicalScope
:
:
Data
*
>
namedLambdaBindings
(
)
{
MOZ_ASSERT
(
context
-
>
compartment
(
)
-
>
runtimeFromAnyThread
(
)
-
>
keepAtoms
(
)
)
;
return
MutableHandle
<
LexicalScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
namedLambdaBindings_
)
;
}
MutableHandle
<
FunctionScope
:
:
Data
*
>
functionScopeBindings
(
)
{
MOZ_ASSERT
(
context
-
>
compartment
(
)
-
>
runtimeFromAnyThread
(
)
-
>
keepAtoms
(
)
)
;
return
MutableHandle
<
FunctionScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
functionScopeBindings_
)
;
}
MutableHandle
<
VarScope
:
:
Data
*
>
extraVarScopeBindings
(
)
{
MOZ_ASSERT
(
context
-
>
compartment
(
)
-
>
runtimeFromAnyThread
(
)
-
>
keepAtoms
(
)
)
;
return
MutableHandle
<
VarScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
extraVarScopeBindings_
)
;
}
void
initFromLazyFunction
(
)
;
void
initStandaloneFunction
(
Scope
*
enclosingScope
)
;
void
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionSyntaxKind
kind
)
;
ObjectBox
*
toObjectBox
(
)
override
{
return
this
;
}
JSFunction
*
function
(
)
const
{
return
&
object
-
>
as
<
JSFunction
>
(
)
;
}
Scope
*
compilationEnclosingScope
(
)
const
override
{
MOZ_ASSERT_IF
(
function
(
)
-
>
isInterpretedLazy
(
)
enclosingScope_
=
=
function
(
)
-
>
lazyScript
(
)
-
>
enclosingScope
(
)
)
;
return
enclosingScope_
;
}
bool
needsCallObjectRegardlessOfBindings
(
)
const
{
return
hasExtensibleScope
(
)
|
|
needsHomeObject
(
)
|
|
isDerivedClassConstructor
(
)
|
|
isGenerator
(
)
;
}
bool
hasExtraBodyVarScope
(
)
const
{
return
hasParameterExprs
&
&
(
extraVarScopeBindings_
|
|
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
)
;
}
bool
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
const
{
MOZ_ASSERT
(
hasParameterExprs
)
;
return
hasExtensibleScope
(
)
|
|
isGenerator
(
)
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
usesArguments
&
&
usesApply
&
&
usesThis
&
&
!
usesReturn
;
}
GeneratorKind
generatorKind
(
)
const
{
return
GeneratorKindFromBits
(
generatorKindBits_
)
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
StarGenerator
;
}
bool
isArrow
(
)
const
{
return
function
(
)
-
>
isArrow
(
)
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
generatorKindBits_
=
GeneratorKindAsBits
(
kind
)
;
}
bool
hasExtensibleScope
(
)
const
{
return
funCxFlags
.
hasExtensibleScope
;
}
bool
hasThisBinding
(
)
const
{
return
funCxFlags
.
hasThisBinding
;
}
bool
argumentsHasLocalBinding
(
)
const
{
return
funCxFlags
.
argumentsHasLocalBinding
;
}
bool
definitelyNeedsArgsObj
(
)
const
{
return
funCxFlags
.
definitelyNeedsArgsObj
;
}
bool
needsHomeObject
(
)
const
{
return
funCxFlags
.
needsHomeObject
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
funCxFlags
.
isDerivedClassConstructor
;
}
bool
hasInnerFunctions
(
)
const
{
return
funCxFlags
.
hasInnerFunctions
;
}
void
setHasExtensibleScope
(
)
{
funCxFlags
.
hasExtensibleScope
=
true
;
}
void
setHasThisBinding
(
)
{
funCxFlags
.
hasThisBinding
=
true
;
}
void
setArgumentsHasLocalBinding
(
)
{
funCxFlags
.
argumentsHasLocalBinding
=
true
;
}
void
setDefinitelyNeedsArgsObj
(
)
{
MOZ_ASSERT
(
funCxFlags
.
argumentsHasLocalBinding
)
;
funCxFlags
.
definitelyNeedsArgsObj
=
true
;
}
void
setNeedsHomeObject
(
)
{
MOZ_ASSERT
(
function
(
)
-
>
allowSuperProperty
(
)
)
;
funCxFlags
.
needsHomeObject
=
true
;
}
void
setDerivedClassConstructor
(
)
{
MOZ_ASSERT
(
function
(
)
-
>
isClassConstructor
(
)
)
;
funCxFlags
.
isDerivedClassConstructor
=
true
;
}
void
setHasInnerFunctions
(
)
{
funCxFlags
.
hasInnerFunctions
=
true
;
}
bool
hasSimpleParameterList
(
)
const
{
return
!
function
(
)
-
>
hasRest
(
)
&
&
!
hasParameterExprs
&
&
!
hasDestructuringArgs
;
}
bool
hasMappedArgsObj
(
)
const
{
return
!
strict
(
)
&
&
hasSimpleParameterList
(
)
;
}
bool
useAsmOrInsideUseAsm
(
)
const
{
return
useAsm
|
|
insideUseAsm
;
}
void
setStart
(
const
TokenStream
&
tokenStream
)
{
bufStart
=
tokenStream
.
currentToken
(
)
.
pos
.
begin
;
tokenStream
.
srcCoords
.
lineNumAndColumnIndex
(
bufStart
&
startLine
&
startColumn
)
;
}
void
trace
(
JSTracer
*
trc
)
override
;
}
;
inline
FunctionBox
*
SharedContext
:
:
asFunctionBox
(
)
{
MOZ_ASSERT
(
isFunctionBox
(
)
)
;
return
static_cast
<
FunctionBox
*
>
(
this
)
;
}
class
MOZ_STACK_CLASS
ModuleSharedContext
:
public
SharedContext
{
RootedModuleObject
module_
;
RootedScope
enclosingScope_
;
public
:
Rooted
<
ModuleScope
:
:
Data
*
>
bindings
;
ModuleBuilder
&
builder
;
ModuleSharedContext
(
ExclusiveContext
*
cx
ModuleObject
*
module
Scope
*
enclosingScope
ModuleBuilder
&
builder
)
;
HandleModuleObject
module
(
)
const
{
return
module_
;
}
Scope
*
compilationEnclosingScope
(
)
const
override
{
return
enclosingScope_
;
}
}
;
inline
ModuleSharedContext
*
SharedContext
:
:
asModuleContext
(
)
{
MOZ_ASSERT
(
isModuleContext
(
)
)
;
return
static_cast
<
ModuleSharedContext
*
>
(
this
)
;
}
inline
bool
SharedContext
:
:
allBindingsClosedOver
(
)
{
return
bindingsAccessedDynamically
(
)
|
|
(
isFunctionBox
(
)
&
&
asFunctionBox
(
)
-
>
isGenerator
(
)
)
;
}
}
}
#
endif
