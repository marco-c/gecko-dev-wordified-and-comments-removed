#
ifndef
frontend_SharedContext_h
#
define
frontend_SharedContext_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
Stencil
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
namespace
js
{
namespace
frontend
{
class
ParseContext
;
enum
class
StatementKind
:
uint8_t
{
Label
Block
If
Switch
With
Catch
Try
Finally
ForLoopLexicalHead
ForLoop
ForInLoop
ForOfLoop
DoLoop
WhileLoop
Class
Spread
YieldStar
}
;
static
inline
bool
StatementKindIsLoop
(
StatementKind
kind
)
{
return
kind
=
=
StatementKind
:
:
ForLoop
|
|
kind
=
=
StatementKind
:
:
ForInLoop
|
|
kind
=
=
StatementKind
:
:
ForOfLoop
|
|
kind
=
=
StatementKind
:
:
DoLoop
|
|
kind
=
=
StatementKind
:
:
WhileLoop
|
|
kind
=
=
StatementKind
:
:
Spread
|
|
kind
=
=
StatementKind
:
:
YieldStar
;
}
static
inline
bool
StatementKindIsUnlabeledBreakTarget
(
StatementKind
kind
)
{
return
StatementKindIsLoop
(
kind
)
|
|
kind
=
=
StatementKind
:
:
Switch
;
}
class
Directives
{
bool
strict_
;
bool
asmJS_
;
public
:
explicit
Directives
(
bool
strict
)
:
strict_
(
strict
)
asmJS_
(
false
)
{
}
explicit
Directives
(
ParseContext
*
parent
)
;
void
setStrict
(
)
{
strict_
=
true
;
}
bool
strict
(
)
const
{
return
strict_
;
}
void
setAsmJS
(
)
{
asmJS_
=
true
;
}
bool
asmJS
(
)
const
{
return
asmJS_
;
}
Directives
&
operator
=
(
Directives
rhs
)
{
strict_
=
rhs
.
strict_
;
asmJS_
=
rhs
.
asmJS_
;
return
*
this
;
}
bool
operator
=
=
(
const
Directives
&
rhs
)
const
{
return
strict_
=
=
rhs
.
strict_
&
&
asmJS_
=
=
rhs
.
asmJS_
;
}
bool
operator
!
=
(
const
Directives
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
enum
class
ThisBinding
:
uint8_t
{
Global
Function
Module
}
;
class
GlobalSharedContext
;
class
EvalSharedContext
;
class
ModuleSharedContext
;
class
SharedContext
{
public
:
JSContext
*
const
cx_
;
protected
:
enum
class
Kind
:
uint8_t
{
FunctionBox
Global
Eval
Module
}
;
Kind
kind_
;
CompilationInfo
&
compilationInfo_
;
ThisBinding
thisBinding_
;
public
:
bool
strictScript
:
1
;
bool
localStrict
:
1
;
SourceExtent
extent
;
protected
:
bool
allowNewTarget_
:
1
;
bool
allowSuperProperty_
:
1
;
bool
allowSuperCall_
:
1
;
bool
allowArguments_
:
1
;
bool
inWith_
:
1
;
bool
needsThisTDZChecks_
:
1
;
bool
hasExplicitUseStrict_
:
1
;
using
ImmutableFlags
=
ImmutableScriptFlagsEnum
;
ImmutableScriptFlags
immutableFlags_
=
{
}
;
void
computeAllowSyntax
(
Scope
*
scope
)
;
void
computeInWith
(
Scope
*
scope
)
;
void
computeThisBinding
(
Scope
*
scope
)
;
public
:
SharedContext
(
JSContext
*
cx
Kind
kind
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
cx_
(
cx
)
kind_
(
kind
)
compilationInfo_
(
compilationInfo
)
thisBinding_
(
ThisBinding
:
:
Global
)
strictScript
(
directives
.
strict
(
)
)
localStrict
(
false
)
extent
(
extent
)
allowNewTarget_
(
false
)
allowSuperProperty_
(
false
)
allowSuperCall_
(
false
)
allowArguments_
(
true
)
inWith_
(
false
)
needsThisTDZChecks_
(
false
)
hasExplicitUseStrict_
(
false
)
{
if
(
kind_
=
=
Kind
:
:
FunctionBox
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsFunction
)
;
}
else
if
(
kind_
=
=
Kind
:
:
Module
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsModule
)
;
}
else
if
(
kind_
=
=
Kind
:
:
Eval
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsForEval
)
;
}
else
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Global
)
;
}
}
virtual
Scope
*
compilationEnclosingScope
(
)
const
=
0
;
bool
isFunctionBox
(
)
const
{
return
kind_
=
=
Kind
:
:
FunctionBox
;
}
inline
FunctionBox
*
asFunctionBox
(
)
;
bool
isModuleContext
(
)
const
{
return
kind_
=
=
Kind
:
:
Module
;
}
inline
ModuleSharedContext
*
asModuleContext
(
)
;
bool
isGlobalContext
(
)
const
{
return
kind_
=
=
Kind
:
:
Global
;
}
inline
GlobalSharedContext
*
asGlobalContext
(
)
;
bool
isEvalContext
(
)
const
{
return
kind_
=
=
Kind
:
:
Eval
;
}
inline
EvalSharedContext
*
asEvalContext
(
)
;
bool
isTopLevelContext
(
)
const
{
switch
(
kind_
)
{
case
Kind
:
:
Module
:
case
Kind
:
:
Global
:
case
Kind
:
:
Eval
:
return
true
;
case
Kind
:
:
FunctionBox
:
break
;
}
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
FunctionBox
)
;
return
false
;
}
CompilationInfo
&
compilationInfo
(
)
const
{
return
compilationInfo_
;
}
ThisBinding
thisBinding
(
)
const
{
return
thisBinding_
;
}
bool
hasModuleGoal
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
HasModuleGoal
)
;
}
bool
hasInnerFunctions
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
HasInnerFunctions
)
;
}
bool
allowNewTarget
(
)
const
{
return
allowNewTarget_
;
}
bool
allowSuperProperty
(
)
const
{
return
allowSuperProperty_
;
}
bool
allowSuperCall
(
)
const
{
return
allowSuperCall_
;
}
bool
allowArguments
(
)
const
{
return
allowArguments_
;
}
bool
inWith
(
)
const
{
return
inWith_
;
}
bool
needsThisTDZChecks
(
)
const
{
return
needsThisTDZChecks_
;
}
bool
hasExplicitUseStrict
(
)
const
{
return
hasExplicitUseStrict_
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
BindingsAccessedDynamically
)
;
}
bool
hasDirectEval
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
HasDirectEval
)
;
}
bool
hasCallSiteObj
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
HasCallSiteObj
)
;
}
void
setExplicitUseStrict
(
)
{
hasExplicitUseStrict_
=
true
;
}
void
setBindingsAccessedDynamically
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
BindingsAccessedDynamically
)
;
}
void
setHasDirectEval
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasDirectEval
)
;
}
void
setHasCallSiteObj
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasCallSiteObj
)
;
}
void
setHasModuleGoal
(
bool
hasModuleGoal
=
true
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasModuleGoal
hasModuleGoal
)
;
}
void
setHasInnerFunctions
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasInnerFunctions
)
;
}
ImmutableScriptFlags
immutableFlags
(
)
{
return
immutableFlags_
;
}
inline
bool
allBindingsClosedOver
(
)
;
bool
strict
(
)
const
{
return
strictScript
|
|
localStrict
;
}
bool
setLocalStrictMode
(
bool
strict
)
{
bool
retVal
=
localStrict
;
localStrict
=
strict
;
return
retVal
;
}
}
;
class
MOZ_STACK_CLASS
GlobalSharedContext
:
public
SharedContext
{
ScopeKind
scopeKind_
;
public
:
Rooted
<
GlobalScope
:
:
Data
*
>
bindings
;
GlobalSharedContext
(
JSContext
*
cx
ScopeKind
scopeKind
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Global
compilationInfo
directives
extent
)
scopeKind_
(
scopeKind
)
bindings
(
cx
)
{
MOZ_ASSERT
(
scopeKind
=
=
ScopeKind
:
:
Global
|
|
scopeKind
=
=
ScopeKind
:
:
NonSyntactic
)
;
thisBinding_
=
ThisBinding
:
:
Global
;
}
Scope
*
compilationEnclosingScope
(
)
const
override
{
return
nullptr
;
}
ScopeKind
scopeKind
(
)
const
{
return
scopeKind_
;
}
}
;
inline
GlobalSharedContext
*
SharedContext
:
:
asGlobalContext
(
)
{
MOZ_ASSERT
(
isGlobalContext
(
)
)
;
return
static_cast
<
GlobalSharedContext
*
>
(
this
)
;
}
class
MOZ_STACK_CLASS
EvalSharedContext
:
public
SharedContext
{
RootedScope
enclosingScope_
;
public
:
Rooted
<
EvalScope
:
:
Data
*
>
bindings
;
EvalSharedContext
(
JSContext
*
cx
JSObject
*
enclosingEnv
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
Directives
directives
SourceExtent
extent
)
;
Scope
*
compilationEnclosingScope
(
)
const
override
{
return
enclosingScope_
;
}
}
;
inline
EvalSharedContext
*
SharedContext
:
:
asEvalContext
(
)
{
MOZ_ASSERT
(
isEvalContext
(
)
)
;
return
static_cast
<
EvalSharedContext
*
>
(
this
)
;
}
enum
class
HasHeritage
:
bool
{
No
Yes
}
;
class
FunctionBox
:
public
SharedContext
{
friend
struct
GCThingList
;
FunctionBox
*
traceLink_
;
FunctionBox
*
emitLink_
;
AbstractScopePtr
enclosingScope_
;
LexicalScope
:
:
Data
*
namedLambdaBindings_
;
FunctionScope
:
:
Data
*
functionScopeBindings_
;
VarScope
:
:
Data
*
extraVarScopeBindings_
;
size_t
funcDataIndex_
;
void
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionSyntaxKind
kind
bool
isArrow
bool
allowSuperProperty
)
;
public
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
SourceExtent
extent
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
JSAtom
*
explicitName
FunctionFlags
flags
size_t
index
)
;
FunctionNode
*
functionNode
;
mozilla
:
:
Maybe
<
FieldInitializers
>
fieldInitializers
;
uint16_t
length
;
bool
hasDestructuringArgs
:
1
;
bool
hasParameterExprs
:
1
;
bool
hasDuplicateParameters
:
1
;
bool
useAsm
:
1
;
bool
isAnnexB
:
1
;
bool
wasEmitted
:
1
;
bool
emitBytecode
:
1
;
bool
usesArguments
:
1
;
bool
usesApply
:
1
;
bool
usesThis
:
1
;
bool
usesReturn
:
1
;
bool
hasExprBody_
:
1
;
bool
isAsmJSModule_
:
1
;
uint16_t
nargs_
;
JSAtom
*
explicitName_
;
FunctionFlags
flags_
;
MutableHandle
<
FunctionCreationData
>
functionCreationData
(
)
const
;
bool
hasFunctionCreationData
(
)
const
;
bool
hasFunction
(
)
const
;
#
ifdef
DEBUG
bool
atomsAreKept
(
)
;
#
endif
MutableHandle
<
LexicalScope
:
:
Data
*
>
namedLambdaBindings
(
)
{
MOZ_ASSERT
(
atomsAreKept
(
)
)
;
return
MutableHandle
<
LexicalScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
namedLambdaBindings_
)
;
}
MutableHandle
<
FunctionScope
:
:
Data
*
>
functionScopeBindings
(
)
{
MOZ_ASSERT
(
atomsAreKept
(
)
)
;
return
MutableHandle
<
FunctionScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
functionScopeBindings_
)
;
}
MutableHandle
<
VarScope
:
:
Data
*
>
extraVarScopeBindings
(
)
{
MOZ_ASSERT
(
atomsAreKept
(
)
)
;
return
MutableHandle
<
VarScope
:
:
Data
*
>
:
:
fromMarkedLocation
(
&
extraVarScopeBindings_
)
;
}
void
initFromLazyFunction
(
JSFunction
*
fun
)
;
void
initStandaloneFunction
(
Scope
*
enclosingScope
)
;
void
initWithEnclosingScope
(
JSFunction
*
fun
)
;
void
initWithEnclosingParseContext
(
ParseContext
*
enclosing
Handle
<
FunctionCreationData
>
fun
FunctionSyntaxKind
kind
)
{
MOZ_ASSERT
(
fun
.
get
(
)
.
kind
=
=
kind
)
;
initWithEnclosingParseContext
(
enclosing
kind
fun
.
get
(
)
.
flags
.
isArrow
(
)
fun
.
get
(
)
.
flags
.
allowSuperProperty
(
)
)
;
}
void
initWithEnclosingParseContext
(
ParseContext
*
enclosing
JSFunction
*
fun
FunctionSyntaxKind
kind
)
{
initWithEnclosingParseContext
(
enclosing
kind
fun
-
>
isArrow
(
)
fun
-
>
allowSuperProperty
(
)
)
;
}
void
initFieldInitializer
(
ParseContext
*
enclosing
Handle
<
FunctionCreationData
>
data
)
;
void
setEnclosingScopeForInnerLazyFunction
(
const
AbstractScopePtr
&
enclosingScope
)
;
void
finish
(
)
;
JSFunction
*
function
(
)
const
;
void
initializeFunction
(
JSFunction
*
fun
)
{
clobberFunction
(
fun
)
;
synchronizeArgCount
(
)
;
}
void
setAsmJSModule
(
JSFunction
*
function
)
;
bool
isAsmJSModule
(
)
{
return
isAsmJSModule_
;
}
void
clobberFunction
(
JSFunction
*
function
)
;
Scope
*
compilationEnclosingScope
(
)
const
override
{
MOZ_ASSERT
(
enclosingScope_
)
;
return
enclosingScope_
.
scope
(
)
;
}
bool
needsCallObjectRegardlessOfBindings
(
)
const
{
return
hasExtensibleScope
(
)
|
|
isGenerator
(
)
|
|
isAsync
(
)
;
}
bool
hasExtraBodyVarScope
(
)
const
{
return
hasParameterExprs
&
&
(
extraVarScopeBindings_
|
|
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
)
;
}
bool
needsExtraBodyVarEnvironmentRegardlessOfBindings
(
)
const
{
MOZ_ASSERT
(
hasParameterExprs
)
;
return
hasExtensibleScope
(
)
;
}
bool
isLikelyConstructorWrapper
(
)
const
{
return
usesArguments
&
&
usesApply
&
&
usesThis
&
&
!
usesReturn
;
}
bool
isGenerator
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
IsGenerator
)
;
}
GeneratorKind
generatorKind
(
)
const
{
return
isGenerator
(
)
?
GeneratorKind
:
:
Generator
:
GeneratorKind
:
:
NotGenerator
;
}
bool
isAsync
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
IsAsync
)
;
}
FunctionAsyncKind
asyncKind
(
)
const
{
return
isAsync
(
)
?
FunctionAsyncKind
:
:
AsyncFunction
:
FunctionAsyncKind
:
:
SyncFunction
;
}
bool
needsFinalYield
(
)
const
{
return
isGenerator
(
)
|
|
isAsync
(
)
;
}
bool
needsDotGeneratorName
(
)
const
{
return
isGenerator
(
)
|
|
isAsync
(
)
;
}
bool
needsIteratorResult
(
)
const
{
return
isGenerator
(
)
&
&
!
isAsync
(
)
;
}
bool
needsPromiseResult
(
)
const
{
return
isAsync
(
)
&
&
!
isGenerator
(
)
;
}
bool
isArrow
(
)
const
{
return
flags_
.
isArrow
(
)
;
}
bool
isLambda
(
)
const
{
if
(
hasFunction
(
)
)
{
return
function
(
)
-
>
isLambda
(
)
;
}
return
functionCreationData
(
)
.
get
(
)
.
flags
.
isLambda
(
)
;
}
void
setDeclaredArguments
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
ShouldDeclareArguments
)
;
}
bool
declaredArguments
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
ShouldDeclareArguments
)
;
}
bool
hasRest
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
HasRest
)
;
}
void
setHasRest
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasRest
)
;
}
bool
hasExprBody
(
)
const
{
return
hasExprBody_
;
}
void
setHasExprBody
(
)
{
MOZ_ASSERT
(
isArrow
(
)
)
;
hasExprBody_
=
true
;
}
bool
hasExtensibleScope
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
FunHasExtensibleScope
)
;
}
bool
hasThisBinding
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
FunctionHasThisBinding
)
;
}
bool
argumentsHasVarBinding
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
ArgumentsHasVarBinding
)
;
}
bool
alwaysNeedsArgsObj
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
AlwaysNeedsArgsObj
)
;
}
bool
needsHomeObject
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
NeedsHomeObject
)
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
IsDerivedClassConstructor
)
;
}
bool
isNamedLambda
(
)
const
{
return
flags_
.
isNamedLambda
(
explicitName
(
)
)
;
}
bool
isGetter
(
)
const
{
return
flags_
.
isGetter
(
)
;
}
bool
isSetter
(
)
const
{
return
flags_
.
isSetter
(
)
;
}
bool
isMethod
(
)
const
{
return
flags_
.
isMethod
(
)
;
}
bool
isClassConstructor
(
)
const
{
return
flags_
.
isClassConstructor
(
)
;
}
bool
isInterpreted
(
)
const
{
return
flags_
.
hasBaseScript
(
)
;
}
void
setIsInterpreted
(
bool
interpreted
)
{
flags_
.
setFlags
(
FunctionFlags
:
:
BASESCRIPT
interpreted
)
;
}
void
initLazyScript
(
BaseScript
*
script
)
{
function
(
)
-
>
initLazyScript
(
script
)
;
}
FunctionFlags
:
:
FunctionKind
kind
(
)
{
return
flags_
.
kind
(
)
;
}
JSAtom
*
explicitName
(
)
const
{
return
explicitName_
;
}
void
setHasExtensibleScope
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
FunHasExtensibleScope
)
;
}
void
setHasThisBinding
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
FunctionHasThisBinding
)
;
}
void
setArgumentsHasVarBinding
(
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
ArgumentsHasVarBinding
)
;
}
void
setAlwaysNeedsArgsObj
(
)
{
MOZ_ASSERT
(
argumentsHasVarBinding
(
)
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
AlwaysNeedsArgsObj
)
;
}
void
setNeedsHomeObject
(
)
{
MOZ_ASSERT_IF
(
hasFunction
(
)
function
(
)
-
>
allowSuperProperty
(
)
)
;
MOZ_ASSERT_IF
(
!
hasFunction
(
)
functionCreationData
(
)
.
get
(
)
.
flags
.
allowSuperProperty
(
)
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
NeedsHomeObject
)
;
}
void
setDerivedClassConstructor
(
)
{
MOZ_ASSERT_IF
(
hasFunction
(
)
function
(
)
-
>
isClassConstructor
(
)
)
;
MOZ_ASSERT_IF
(
!
hasFunction
(
)
functionCreationData
(
)
.
get
(
)
.
flags
.
isClassConstructor
(
)
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsDerivedClassConstructor
)
;
}
bool
hasSimpleParameterList
(
)
const
{
return
!
hasRest
(
)
&
&
!
hasParameterExprs
&
&
!
hasDestructuringArgs
;
}
bool
hasMappedArgsObj
(
)
const
{
return
!
strict
(
)
&
&
hasSimpleParameterList
(
)
;
}
bool
shouldSuppressRunOnce
(
)
const
{
return
explicitName
(
)
|
|
argumentsHasVarBinding
(
)
|
|
isGenerator
(
)
|
|
isAsync
(
)
;
}
bool
useAsmOrInsideUseAsm
(
)
const
{
return
useAsm
;
}
void
setStart
(
uint32_t
offset
uint32_t
line
uint32_t
column
)
{
extent
.
sourceStart
=
offset
;
extent
.
lineno
=
line
;
extent
.
column
=
column
;
}
void
setEnd
(
uint32_t
end
)
{
extent
.
sourceEnd
=
extent
.
toStringEnd
=
end
;
}
void
setArgCount
(
uint16_t
args
)
{
nargs_
=
args
;
}
size_t
nargs
(
)
{
return
nargs_
;
}
void
synchronizeArgCount
(
)
{
if
(
hasFunction
(
)
)
{
function
(
)
-
>
setArgCount
(
nargs_
)
;
}
}
bool
setTypeForScriptedFunction
(
JSContext
*
cx
bool
singleton
)
{
RootedFunction
fun
(
cx
function
(
)
)
;
return
JSFunction
:
:
setTypeForScriptedFunction
(
cx
fun
singleton
)
;
}
bool
treatAsRunOnce
(
)
const
{
return
immutableFlags_
.
hasFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
)
;
}
void
setTreatAsRunOnce
(
bool
flag
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
flag
)
;
}
void
setInferredName
(
JSAtom
*
atom
)
{
function
(
)
-
>
setInferredName
(
atom
)
;
}
JSAtom
*
inferredName
(
)
const
{
return
function
(
)
-
>
inferredName
(
)
;
}
bool
hasInferredName
(
)
const
{
return
function
(
)
-
>
hasInferredName
(
)
;
}
size_t
index
(
)
{
return
funcDataIndex_
;
}
void
trace
(
JSTracer
*
trc
)
;
static
void
TraceList
(
JSTracer
*
trc
FunctionBox
*
listHead
)
;
}
;
inline
FunctionBox
*
SharedContext
:
:
asFunctionBox
(
)
{
MOZ_ASSERT
(
isFunctionBox
(
)
)
;
return
static_cast
<
FunctionBox
*
>
(
this
)
;
}
inline
bool
SharedContext
:
:
allBindingsClosedOver
(
)
{
return
bindingsAccessedDynamically
(
)
|
|
(
isFunctionBox
(
)
&
&
(
asFunctionBox
(
)
-
>
isGenerator
(
)
|
|
asFunctionBox
(
)
-
>
isAsync
(
)
)
)
;
}
}
}
#
endif
