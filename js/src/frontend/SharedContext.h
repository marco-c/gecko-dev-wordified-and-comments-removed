#
ifndef
frontend_SharedContext_h
#
define
frontend_SharedContext_h
#
include
"
jsatom
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
ParseMaps
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
vm
/
ScopeObject
.
h
"
namespace
js
{
namespace
frontend
{
class
AnyContextFlags
{
friend
class
SharedContext
;
bool
hasExplicitUseStrict
:
1
;
bool
bindingsAccessedDynamically
:
1
;
bool
hasDebuggerStatement
:
1
;
bool
hasDirectEval
:
1
;
public
:
AnyContextFlags
(
)
:
hasExplicitUseStrict
(
false
)
bindingsAccessedDynamically
(
false
)
hasDebuggerStatement
(
false
)
hasDirectEval
(
false
)
{
}
}
;
class
FunctionContextFlags
{
friend
class
FunctionBox
;
bool
mightAliasLocals
:
1
;
bool
hasExtensibleScope
:
1
;
bool
needsDeclEnvObject
:
1
;
bool
argumentsHasLocalBinding
:
1
;
bool
definitelyNeedsArgsObj
:
1
;
bool
needsHomeObject
:
1
;
bool
isDerivedClassConstructor
:
1
;
public
:
FunctionContextFlags
(
)
:
mightAliasLocals
(
false
)
hasExtensibleScope
(
false
)
needsDeclEnvObject
(
false
)
argumentsHasLocalBinding
(
false
)
definitelyNeedsArgsObj
(
false
)
needsHomeObject
(
false
)
isDerivedClassConstructor
(
false
)
{
}
}
;
class
GlobalSharedContext
;
class
Directives
{
bool
strict_
;
bool
asmJS_
;
public
:
explicit
Directives
(
bool
strict
)
:
strict_
(
strict
)
asmJS_
(
false
)
{
}
template
<
typename
ParseHandler
>
explicit
Directives
(
ParseContext
<
ParseHandler
>
*
parent
)
;
void
setStrict
(
)
{
strict_
=
true
;
}
bool
strict
(
)
const
{
return
strict_
;
}
void
setAsmJS
(
)
{
asmJS_
=
true
;
}
bool
asmJS
(
)
const
{
return
asmJS_
;
}
Directives
&
operator
=
(
Directives
rhs
)
{
strict_
=
rhs
.
strict_
;
asmJS_
=
rhs
.
asmJS_
;
return
*
this
;
}
bool
operator
=
=
(
const
Directives
&
rhs
)
const
{
return
strict_
=
=
rhs
.
strict_
&
&
asmJS_
=
=
rhs
.
asmJS_
;
}
bool
operator
!
=
(
const
Directives
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
class
SharedContext
{
public
:
ExclusiveContext
*
const
context
;
AnyContextFlags
anyCxFlags
;
bool
strictScript
;
bool
localStrict
;
bool
extraWarnings
;
SharedContext
(
ExclusiveContext
*
cx
Directives
directives
bool
extraWarnings
)
:
context
(
cx
)
anyCxFlags
(
)
strictScript
(
directives
.
strict
(
)
)
localStrict
(
false
)
extraWarnings
(
extraWarnings
)
{
}
virtual
ObjectBox
*
toObjectBox
(
)
=
0
;
inline
bool
isFunctionBox
(
)
{
return
toObjectBox
(
)
&
&
toObjectBox
(
)
-
>
isFunctionBox
(
)
;
}
inline
FunctionBox
*
asFunctionBox
(
)
;
inline
GlobalSharedContext
*
asGlobalSharedContext
(
)
;
bool
hasExplicitUseStrict
(
)
const
{
return
anyCxFlags
.
hasExplicitUseStrict
;
}
bool
bindingsAccessedDynamically
(
)
const
{
return
anyCxFlags
.
bindingsAccessedDynamically
;
}
bool
hasDebuggerStatement
(
)
const
{
return
anyCxFlags
.
hasDebuggerStatement
;
}
bool
hasDirectEval
(
)
const
{
return
anyCxFlags
.
hasDirectEval
;
}
void
setExplicitUseStrict
(
)
{
anyCxFlags
.
hasExplicitUseStrict
=
true
;
}
void
setBindingsAccessedDynamically
(
)
{
anyCxFlags
.
bindingsAccessedDynamically
=
true
;
}
void
setHasDebuggerStatement
(
)
{
anyCxFlags
.
hasDebuggerStatement
=
true
;
}
void
setHasDirectEval
(
)
{
anyCxFlags
.
hasDirectEval
=
true
;
}
inline
bool
allLocalsAliased
(
)
;
bool
strict
(
)
{
return
strictScript
|
|
localStrict
;
}
bool
setLocalStrictMode
(
bool
strict
)
{
bool
retVal
=
localStrict
;
localStrict
=
strict
;
return
retVal
;
}
bool
needStrictChecks
(
)
{
return
strict
(
)
|
|
extraWarnings
;
}
bool
isDotVariable
(
JSAtom
*
atom
)
const
{
return
atom
=
=
context
-
>
names
(
)
.
dotGenerator
|
|
atom
=
=
context
-
>
names
(
)
.
dotGenRVal
;
}
enum
class
AllowedSyntax
{
NewTarget
SuperProperty
}
;
virtual
bool
allowSyntax
(
AllowedSyntax
allowed
)
const
=
0
;
virtual
bool
inWith
(
)
const
=
0
;
protected
:
static
bool
FunctionAllowsSyntax
(
JSFunction
*
func
AllowedSyntax
allowed
)
{
MOZ_ASSERT
(
!
func
-
>
isArrow
(
)
)
;
switch
(
allowed
)
{
case
AllowedSyntax
:
:
NewTarget
:
return
true
;
case
AllowedSyntax
:
:
SuperProperty
:
return
func
-
>
allowSuperProperty
(
)
;
default
:
;
}
MOZ_CRASH
(
"
Unknown
AllowedSyntax
query
"
)
;
}
}
;
class
GlobalSharedContext
:
public
SharedContext
{
private
:
Handle
<
ScopeObject
*
>
topStaticScope_
;
bool
allowNewTarget_
;
bool
allowSuperProperty_
;
bool
inWith_
;
bool
computeAllowSyntax
(
AllowedSyntax
allowed
)
const
{
StaticScopeIter
<
CanGC
>
it
(
context
topStaticScope_
)
;
for
(
;
!
it
.
done
(
)
;
it
+
+
)
{
if
(
it
.
type
(
)
=
=
StaticScopeIter
<
CanGC
>
:
:
Function
&
&
!
it
.
fun
(
)
.
isArrow
(
)
)
{
return
FunctionAllowsSyntax
(
&
it
.
fun
(
)
allowed
)
;
}
}
return
false
;
}
bool
computeInWith
(
)
const
{
for
(
StaticScopeIter
<
CanGC
>
it
(
context
topStaticScope_
)
;
!
it
.
done
(
)
;
it
+
+
)
{
if
(
it
.
type
(
)
=
=
StaticScopeIter
<
CanGC
>
:
:
With
)
return
true
;
}
return
false
;
}
public
:
GlobalSharedContext
(
ExclusiveContext
*
cx
Directives
directives
Handle
<
ScopeObject
*
>
topStaticScope
bool
extraWarnings
)
:
SharedContext
(
cx
directives
extraWarnings
)
topStaticScope_
(
topStaticScope
)
allowNewTarget_
(
computeAllowSyntax
(
AllowedSyntax
:
:
NewTarget
)
)
allowSuperProperty_
(
computeAllowSyntax
(
AllowedSyntax
:
:
SuperProperty
)
)
inWith_
(
computeInWith
(
)
)
{
}
ObjectBox
*
toObjectBox
(
)
override
{
return
nullptr
;
}
HandleObject
topStaticScope
(
)
const
{
return
topStaticScope_
;
}
bool
allowSyntax
(
AllowedSyntax
allowSyntax
)
const
override
{
switch
(
allowSyntax
)
{
case
AllowedSyntax
:
:
NewTarget
:
return
allowNewTarget_
;
case
AllowedSyntax
:
:
SuperProperty
:
return
allowSuperProperty_
;
default
:
;
}
MOZ_CRASH
(
"
Unknown
AllowedSyntax
query
"
)
;
}
bool
inWith
(
)
const
override
{
return
inWith_
;
}
}
;
class
FunctionBox
:
public
ObjectBox
public
SharedContext
{
public
:
Bindings
bindings
;
uint32_t
bufStart
;
uint32_t
bufEnd
;
uint32_t
startLine
;
uint32_t
startColumn
;
uint16_t
length
;
uint8_t
generatorKindBits_
;
bool
inWith_
:
1
;
bool
inGenexpLambda
:
1
;
bool
hasDestructuringArgs
:
1
;
bool
useAsm
:
1
;
bool
insideUseAsm
:
1
;
bool
usesArguments
:
1
;
bool
usesApply
:
1
;
bool
usesThis
:
1
;
FunctionContextFlags
funCxFlags
;
template
<
typename
ParseHandler
>
FunctionBox
(
ExclusiveContext
*
cx
ObjectBox
*
traceListHead
JSFunction
*
fun
ParseContext
<
ParseHandler
>
*
pc
Directives
directives
bool
extraWarnings
GeneratorKind
generatorKind
)
;
ObjectBox
*
toObjectBox
(
)
override
{
return
this
;
}
JSFunction
*
function
(
)
const
{
return
&
object
-
>
as
<
JSFunction
>
(
)
;
}
GeneratorKind
generatorKind
(
)
const
{
return
GeneratorKindFromBits
(
generatorKindBits_
)
;
}
bool
isGenerator
(
)
const
{
return
generatorKind
(
)
!
=
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
StarGenerator
;
}
void
setGeneratorKind
(
GeneratorKind
kind
)
{
MOZ_ASSERT
(
!
isGenerator
(
)
)
;
generatorKindBits_
=
GeneratorKindAsBits
(
kind
)
;
}
bool
mightAliasLocals
(
)
const
{
return
funCxFlags
.
mightAliasLocals
;
}
bool
hasExtensibleScope
(
)
const
{
return
funCxFlags
.
hasExtensibleScope
;
}
bool
needsDeclEnvObject
(
)
const
{
return
funCxFlags
.
needsDeclEnvObject
;
}
bool
argumentsHasLocalBinding
(
)
const
{
return
funCxFlags
.
argumentsHasLocalBinding
;
}
bool
definitelyNeedsArgsObj
(
)
const
{
return
funCxFlags
.
definitelyNeedsArgsObj
;
}
bool
needsHomeObject
(
)
const
{
return
funCxFlags
.
needsHomeObject
;
}
bool
isDerivedClassConstructor
(
)
const
{
return
funCxFlags
.
isDerivedClassConstructor
;
}
void
setMightAliasLocals
(
)
{
funCxFlags
.
mightAliasLocals
=
true
;
}
void
setHasExtensibleScope
(
)
{
funCxFlags
.
hasExtensibleScope
=
true
;
}
void
setNeedsDeclEnvObject
(
)
{
funCxFlags
.
needsDeclEnvObject
=
true
;
}
void
setArgumentsHasLocalBinding
(
)
{
funCxFlags
.
argumentsHasLocalBinding
=
true
;
}
void
setDefinitelyNeedsArgsObj
(
)
{
MOZ_ASSERT
(
funCxFlags
.
argumentsHasLocalBinding
)
;
funCxFlags
.
definitelyNeedsArgsObj
=
true
;
}
void
setNeedsHomeObject
(
)
{
MOZ_ASSERT
(
function
(
)
-
>
allowSuperProperty
(
)
)
;
funCxFlags
.
needsHomeObject
=
true
;
}
void
setDerivedClassConstructor
(
)
{
MOZ_ASSERT
(
function
(
)
-
>
isClassConstructor
(
)
)
;
funCxFlags
.
isDerivedClassConstructor
=
true
;
}
bool
hasDefaults
(
)
const
{
return
length
!
=
function
(
)
-
>
nargs
(
)
-
function
(
)
-
>
hasRest
(
)
;
}
bool
useAsmOrInsideUseAsm
(
)
const
{
return
useAsm
|
|
insideUseAsm
;
}
void
setStart
(
const
TokenStream
&
tokenStream
)
{
bufStart
=
tokenStream
.
currentToken
(
)
.
pos
.
begin
;
startLine
=
tokenStream
.
getLineno
(
)
;
startColumn
=
tokenStream
.
getColumn
(
)
;
}
bool
isHeavyweight
(
)
{
return
bindings
.
hasAnyAliasedBindings
(
)
|
|
hasExtensibleScope
(
)
|
|
needsDeclEnvObject
(
)
|
|
needsHomeObject
(
)
|
|
isGenerator
(
)
;
}
bool
allowSyntax
(
AllowedSyntax
allowed
)
const
override
{
return
FunctionAllowsSyntax
(
function
(
)
allowed
)
;
}
bool
inWith
(
)
const
override
{
return
inWith_
;
}
}
;
inline
FunctionBox
*
SharedContext
:
:
asFunctionBox
(
)
{
MOZ_ASSERT
(
isFunctionBox
(
)
)
;
return
static_cast
<
FunctionBox
*
>
(
this
)
;
}
inline
GlobalSharedContext
*
SharedContext
:
:
asGlobalSharedContext
(
)
{
MOZ_ASSERT
(
!
isFunctionBox
(
)
)
;
return
static_cast
<
GlobalSharedContext
*
>
(
this
)
;
}
inline
bool
SharedContext
:
:
allLocalsAliased
(
)
{
return
bindingsAccessedDynamically
(
)
|
|
(
isFunctionBox
(
)
&
&
asFunctionBox
(
)
-
>
isGenerator
(
)
)
;
}
enum
class
StmtType
:
uint16_t
{
LABEL
IF
ELSE
SEQ
BLOCK
SWITCH
WITH
CATCH
TRY
FINALLY
SUBROUTINE
DO_LOOP
FOR_LOOP
FOR_IN_LOOP
FOR_OF_LOOP
WHILE_LOOP
SPREAD
LIMIT
}
;
struct
StmtInfoBase
{
StmtType
type
;
bool
isBlockScope
:
1
;
bool
isForLetBlock
:
1
;
RootedAtom
label
;
Rooted
<
NestedScopeObject
*
>
staticScope
;
explicit
StmtInfoBase
(
ExclusiveContext
*
cx
)
:
isBlockScope
(
false
)
isForLetBlock
(
false
)
label
(
cx
)
staticScope
(
cx
)
{
}
bool
maybeScope
(
)
const
{
return
StmtType
:
:
BLOCK
<
=
type
&
&
type
<
=
StmtType
:
:
SUBROUTINE
&
&
type
!
=
StmtType
:
:
WITH
;
}
bool
linksScope
(
)
const
{
return
!
!
staticScope
;
}
bool
canBeBlockScope
(
)
{
return
type
=
=
StmtType
:
:
BLOCK
|
|
type
=
=
StmtType
:
:
SWITCH
|
|
type
=
=
StmtType
:
:
TRY
|
|
type
=
=
StmtType
:
:
FINALLY
|
|
type
=
=
StmtType
:
:
CATCH
;
}
StaticBlockObject
&
staticBlock
(
)
const
{
MOZ_ASSERT
(
staticScope
)
;
MOZ_ASSERT
(
isBlockScope
)
;
return
staticScope
-
>
as
<
StaticBlockObject
>
(
)
;
}
bool
isLoop
(
)
const
{
return
type
>
=
StmtType
:
:
DO_LOOP
;
}
bool
isTrying
(
)
const
{
return
StmtType
:
:
TRY
<
=
type
&
&
type
<
=
StmtType
:
:
SUBROUTINE
;
}
}
;
template
<
class
StmtInfo
>
class
MOZ_STACK_CLASS
StmtInfoStack
{
StmtInfo
*
topStmt_
;
StmtInfo
*
topScopeStmt_
;
public
:
explicit
StmtInfoStack
(
ExclusiveContext
*
cx
)
:
topStmt_
(
nullptr
)
topScopeStmt_
(
nullptr
)
{
}
StmtInfo
*
top
(
)
const
{
return
topStmt_
;
}
StmtInfo
*
topScopal
(
)
const
{
return
topScopeStmt_
;
}
NestedScopeObject
*
topStaticScope
(
)
const
{
if
(
!
topScopal
(
)
)
return
nullptr
;
return
topScopal
(
)
-
>
staticScope
;
}
void
push
(
StmtInfo
*
stmt
StmtType
type
)
{
stmt
-
>
type
=
type
;
stmt
-
>
isBlockScope
=
false
;
stmt
-
>
isForLetBlock
=
false
;
stmt
-
>
label
=
nullptr
;
stmt
-
>
staticScope
=
nullptr
;
stmt
-
>
down
=
topStmt_
;
stmt
-
>
downScope
=
nullptr
;
topStmt_
=
stmt
;
}
void
pushNestedScope
(
StmtInfo
*
stmt
StmtType
type
NestedScopeObject
&
staticScope
)
{
push
(
stmt
type
)
;
linkAsTopScopal
(
stmt
staticScope
)
;
}
void
pop
(
)
{
StmtInfo
*
stmt
=
topStmt_
;
topStmt_
=
stmt
-
>
down
;
if
(
stmt
-
>
linksScope
(
)
)
topScopeStmt_
=
stmt
-
>
downScope
;
}
void
linkAsTopScopal
(
StmtInfo
*
stmt
NestedScopeObject
&
staticScope
)
{
MOZ_ASSERT
(
stmt
!
=
topScopal
(
)
)
;
MOZ_ASSERT
(
!
stmt
-
>
downScope
)
;
stmt
-
>
downScope
=
topScopeStmt_
;
topScopeStmt_
=
stmt
;
stmt
-
>
staticScope
=
&
staticScope
;
}
void
makeTopLexicalScope
(
StaticBlockObject
&
blockObj
)
{
MOZ_ASSERT
(
!
topStmt_
-
>
isBlockScope
)
;
MOZ_ASSERT
(
topStmt_
-
>
canBeBlockScope
(
)
)
;
topStmt_
-
>
isBlockScope
=
true
;
linkAsTopScopal
(
topStmt_
blockObj
)
;
}
}
;
}
}
#
endif
