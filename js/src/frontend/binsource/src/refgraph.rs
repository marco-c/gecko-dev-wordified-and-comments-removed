use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
rc
:
:
Rc
;
struct
ReferenceGraphNode
{
used
:
RefCell
<
bool
>
edges
:
HashSet
<
Rc
<
String
>
>
}
impl
ReferenceGraphNode
{
fn
new
(
edges
:
HashSet
<
Rc
<
String
>
>
)
-
>
Self
{
ReferenceGraphNode
{
used
:
RefCell
:
:
new
(
false
)
edges
}
}
}
pub
struct
ReferenceGraph
{
refnodes
:
HashMap
<
Rc
<
String
>
Rc
<
ReferenceGraphNode
>
>
}
impl
ReferenceGraph
{
pub
fn
new
(
)
-
>
Self
{
ReferenceGraph
{
refnodes
:
HashMap
:
:
new
(
)
}
}
pub
fn
trace
(
&
mut
self
name
:
Rc
<
String
>
)
{
let
mut
edges
:
HashSet
<
Rc
<
String
>
>
=
HashSet
:
:
new
(
)
;
edges
.
insert
(
name
)
;
loop
{
let
mut
next_edges
:
HashSet
<
Rc
<
String
>
>
=
HashSet
:
:
new
(
)
;
for
edge
in
edges
{
let
refnode
=
self
.
refnodes
.
get
(
&
edge
)
.
unwrap_or_else
(
|
|
panic
!
(
"
While
computing
dependencies
node
{
}
doesn
'
t
exist
"
edge
)
)
;
if
*
refnode
.
used
.
borrow
(
)
{
continue
;
}
refnode
.
used
.
replace
(
true
)
;
for
next_edge
in
refnode
.
edges
.
iter
(
)
{
next_edges
.
insert
(
next_edge
.
clone
(
)
)
;
}
}
if
next_edges
.
len
(
)
=
=
0
{
break
;
}
edges
=
next_edges
;
}
}
pub
fn
is_used
(
&
self
name
:
Rc
<
String
>
)
-
>
bool
{
match
self
.
refnodes
.
get
(
&
name
)
{
Some
(
refnode
)
=
>
*
refnode
.
used
.
borrow
(
)
None
=
>
false
}
}
pub
fn
insert
(
&
mut
self
name
:
Rc
<
String
>
edges
:
HashSet
<
Rc
<
String
>
>
)
{
self
.
refnodes
.
insert
(
name
Rc
:
:
new
(
ReferenceGraphNode
:
:
new
(
edges
)
)
)
;
}
}
