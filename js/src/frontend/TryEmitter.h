#
ifndef
frontend_TryEmitter_h
#
define
frontend_TryEmitter_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
frontend
/
BytecodeControlStructures
.
h
"
#
include
"
frontend
/
BytecodeOffset
.
h
"
#
include
"
frontend
/
JumpList
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
namespace
js
{
namespace
frontend
{
struct
BytecodeEmitter
;
class
TryEmitter
{
public
:
enum
class
Kind
{
TryCatch
TryCatchFinally
TryFinally
}
;
enum
class
ControlKind
{
Syntactic
NonSyntactic
Disposal
}
;
private
:
BytecodeEmitter
*
bce_
;
Kind
kind_
;
ControlKind
controlKind_
;
js
:
:
UniquePtr
<
TryFinallyControl
>
controlInfo_
;
int
depth_
;
BytecodeOffset
tryOpOffset_
;
JumpList
catchAndFinallyJump_
;
JumpTarget
tryEnd_
;
JumpTarget
finallyStart_
;
#
ifdef
DEBUG
enum
class
State
{
Start
Try
Catch
Finally
End
}
;
State
state_
;
#
endif
bool
hasCatch
(
)
const
{
return
kind_
=
=
Kind
:
:
TryCatch
|
|
kind_
=
=
Kind
:
:
TryCatchFinally
;
}
bool
hasFinally
(
)
const
{
return
kind_
=
=
Kind
:
:
TryCatchFinally
|
|
kind_
=
=
Kind
:
:
TryFinally
;
}
bool
requiresControlInfo
(
)
const
{
return
controlKind_
=
=
ControlKind
:
:
Syntactic
|
|
controlKind_
=
=
ControlKind
:
:
Disposal
;
}
BytecodeOffset
offsetAfterTryOp
(
)
const
{
return
tryOpOffset_
+
BytecodeOffsetDiff
(
JSOpLength_Try
)
;
}
[
[
nodiscard
]
]
bool
emitJumpToFinallyWithFallthrough
(
)
;
public
:
TryEmitter
(
BytecodeEmitter
*
bce
Kind
kind
ControlKind
controlKind
)
;
bool
shouldUpdateRval
(
)
const
;
#
ifdef
DEBUG
bool
hasControlInfo
(
)
;
#
endif
[
[
nodiscard
]
]
bool
emitTry
(
)
;
enum
class
ExceptionStack
:
bool
{
No
Yes
}
;
[
[
nodiscard
]
]
bool
emitCatch
(
ExceptionStack
stack
=
ExceptionStack
:
:
No
)
;
[
[
nodiscard
]
]
bool
emitFinally
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
finallyPos
=
mozilla
:
:
Nothing
(
)
)
;
[
[
nodiscard
]
]
bool
emitEnd
(
)
;
private
:
[
[
nodiscard
]
]
bool
emitTryEnd
(
)
;
[
[
nodiscard
]
]
bool
emitCatchEnd
(
)
;
[
[
nodiscard
]
]
bool
emitFinallyEnd
(
)
;
}
;
}
}
#
endif
