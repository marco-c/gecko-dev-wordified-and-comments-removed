#
include
"
frontend
/
NameFunctions
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
namespace
{
class
NameResolver
{
static
const
size_t
MaxParents
=
100
;
JSContext
*
cx
;
size_t
nparents
;
MOZ_INIT_OUTSIDE_CTOR
ParseNode
*
parents
[
MaxParents
]
;
StringBuffer
*
buf
;
bool
call
(
ParseNode
*
pn
)
{
return
pn
&
&
pn
-
>
isKind
(
ParseNodeKind
:
:
PNK_CALL
)
;
}
bool
appendPropertyReference
(
JSAtom
*
name
)
{
if
(
IsIdentifier
(
name
)
)
return
buf
-
>
append
(
'
.
'
)
&
&
buf
-
>
append
(
name
)
;
JSString
*
source
=
QuoteString
(
cx
name
'
"
'
)
;
return
source
&
&
buf
-
>
append
(
'
[
'
)
&
&
buf
-
>
append
(
source
)
&
&
buf
-
>
append
(
'
]
'
)
;
}
bool
appendNumber
(
double
n
)
{
char
number
[
30
]
;
int
digits
=
SprintfLiteral
(
number
"
%
g
"
n
)
;
return
buf
-
>
append
(
number
digits
)
;
}
bool
appendNumericPropertyReference
(
double
n
)
{
return
buf
-
>
append
(
"
[
"
)
&
&
appendNumber
(
n
)
&
&
buf
-
>
append
(
'
]
'
)
;
}
bool
nameExpression
(
ParseNode
*
n
bool
*
foundName
)
{
switch
(
n
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
PNK_DOT
:
if
(
!
nameExpression
(
n
-
>
expr
(
)
foundName
)
)
return
false
;
if
(
!
*
foundName
)
return
true
;
return
appendPropertyReference
(
n
-
>
pn_atom
)
;
case
ParseNodeKind
:
:
PNK_NAME
:
*
foundName
=
true
;
return
buf
-
>
append
(
n
-
>
pn_atom
)
;
case
ParseNodeKind
:
:
PNK_THIS
:
*
foundName
=
true
;
return
buf
-
>
append
(
"
this
"
)
;
case
ParseNodeKind
:
:
PNK_ELEM
:
if
(
!
nameExpression
(
n
-
>
pn_left
foundName
)
)
return
false
;
if
(
!
*
foundName
)
return
true
;
if
(
!
buf
-
>
append
(
'
[
'
)
|
|
!
nameExpression
(
n
-
>
pn_right
foundName
)
)
return
false
;
if
(
!
*
foundName
)
return
true
;
return
buf
-
>
append
(
'
]
'
)
;
case
ParseNodeKind
:
:
PNK_NUMBER
:
*
foundName
=
true
;
return
appendNumber
(
n
-
>
pn_dval
)
;
default
:
*
foundName
=
false
;
return
true
;
}
}
ParseNode
*
gatherNameable
(
ParseNode
*
*
nameable
size_t
*
size
)
{
*
size
=
0
;
for
(
int
pos
=
nparents
-
1
;
pos
>
=
0
;
pos
-
-
)
{
ParseNode
*
cur
=
parents
[
pos
]
;
if
(
cur
-
>
isAssignment
(
)
)
return
cur
;
switch
(
cur
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
PNK_NAME
:
return
cur
;
case
ParseNodeKind
:
:
PNK_THIS
:
return
cur
;
case
ParseNodeKind
:
:
PNK_FUNCTION
:
return
nullptr
;
case
ParseNodeKind
:
:
PNK_RETURN
:
for
(
int
tmp
=
pos
-
1
;
tmp
>
0
;
tmp
-
-
)
{
if
(
isDirectCall
(
tmp
cur
)
)
{
pos
=
tmp
;
break
;
}
else
if
(
call
(
cur
)
)
{
break
;
}
cur
=
parents
[
tmp
]
;
}
break
;
case
ParseNodeKind
:
:
PNK_COLON
:
case
ParseNodeKind
:
:
PNK_SHORTHAND
:
pos
-
-
;
MOZ_FALLTHROUGH
;
default
:
MOZ_ASSERT
(
*
size
<
MaxParents
)
;
nameable
[
(
*
size
)
+
+
]
=
cur
;
break
;
}
}
return
nullptr
;
}
bool
resolveFun
(
ParseNode
*
pn
HandleAtom
prefix
MutableHandleAtom
retAtom
)
{
MOZ_ASSERT
(
pn
!
=
nullptr
)
;
MOZ_ASSERT
(
pn
-
>
isKind
(
ParseNodeKind
:
:
PNK_FUNCTION
)
)
;
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_CODE
)
)
;
RootedFunction
fun
(
cx
pn
-
>
pn_funbox
-
>
function
(
)
)
;
StringBuffer
buf
(
cx
)
;
this
-
>
buf
=
&
buf
;
retAtom
.
set
(
nullptr
)
;
if
(
fun
-
>
displayAtom
(
)
!
=
nullptr
)
{
if
(
prefix
=
=
nullptr
)
{
retAtom
.
set
(
fun
-
>
displayAtom
(
)
)
;
return
true
;
}
if
(
!
buf
.
append
(
prefix
)
|
|
!
buf
.
append
(
'
/
'
)
|
|
!
buf
.
append
(
fun
-
>
displayAtom
(
)
)
)
return
false
;
retAtom
.
set
(
buf
.
finishAtom
(
)
)
;
return
!
!
retAtom
;
}
if
(
prefix
!
=
nullptr
&
&
(
!
buf
.
append
(
prefix
)
|
|
!
buf
.
append
(
'
/
'
)
)
)
return
false
;
ParseNode
*
toName
[
MaxParents
]
;
size_t
size
;
ParseNode
*
assignment
=
gatherNameable
(
toName
&
size
)
;
if
(
assignment
)
{
if
(
assignment
-
>
isAssignment
(
)
)
assignment
=
assignment
-
>
pn_left
;
bool
foundName
=
false
;
if
(
!
nameExpression
(
assignment
&
foundName
)
)
return
false
;
if
(
!
foundName
)
return
true
;
}
for
(
int
pos
=
size
-
1
;
pos
>
=
0
;
pos
-
-
)
{
ParseNode
*
node
=
toName
[
pos
]
;
if
(
node
-
>
isKind
(
ParseNodeKind
:
:
PNK_COLON
)
|
|
node
-
>
isKind
(
ParseNodeKind
:
:
PNK_SHORTHAND
)
)
{
ParseNode
*
left
=
node
-
>
pn_left
;
if
(
left
-
>
isKind
(
ParseNodeKind
:
:
PNK_OBJECT_PROPERTY_NAME
)
|
|
left
-
>
isKind
(
ParseNodeKind
:
:
PNK_STRING
)
)
{
if
(
!
appendPropertyReference
(
left
-
>
pn_atom
)
)
return
false
;
}
else
if
(
left
-
>
isKind
(
ParseNodeKind
:
:
PNK_NUMBER
)
)
{
if
(
!
appendNumericPropertyReference
(
left
-
>
pn_dval
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
left
-
>
isKind
(
ParseNodeKind
:
:
PNK_COMPUTED_NAME
)
)
;
}
}
else
{
if
(
!
buf
.
empty
(
)
&
&
buf
.
getChar
(
buf
.
length
(
)
-
1
)
!
=
'
<
'
&
&
!
buf
.
append
(
'
<
'
)
)
return
false
;
}
}
if
(
!
buf
.
empty
(
)
&
&
buf
.
getChar
(
buf
.
length
(
)
-
1
)
=
=
'
/
'
&
&
!
buf
.
append
(
'
<
'
)
)
return
false
;
if
(
buf
.
empty
(
)
)
return
true
;
retAtom
.
set
(
buf
.
finishAtom
(
)
)
;
if
(
!
retAtom
)
return
false
;
fun
-
>
setGuessedAtom
(
retAtom
)
;
return
true
;
}
bool
isDirectCall
(
int
pos
ParseNode
*
cur
)
{
return
pos
>
=
0
&
&
call
(
parents
[
pos
]
)
&
&
parents
[
pos
]
-
>
pn_head
=
=
cur
;
}
bool
resolveTemplateLiteral
(
ParseNode
*
node
HandleAtom
prefix
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
ParseNodeKind
:
:
PNK_TEMPLATE_STRING_LIST
)
)
;
ParseNode
*
element
=
node
-
>
pn_head
;
while
(
true
)
{
MOZ_ASSERT
(
element
-
>
isKind
(
ParseNodeKind
:
:
PNK_TEMPLATE_STRING
)
)
;
element
=
element
-
>
pn_next
;
if
(
!
element
)
return
true
;
if
(
!
resolve
(
element
prefix
)
)
return
false
;
element
=
element
-
>
pn_next
;
}
}
bool
resolveTaggedTemplate
(
ParseNode
*
node
HandleAtom
prefix
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
ParseNodeKind
:
:
PNK_TAGGED_TEMPLATE
)
)
;
ParseNode
*
element
=
node
-
>
pn_head
;
if
(
!
resolve
(
element
prefix
)
)
return
false
;
element
=
element
-
>
pn_next
;
#
ifdef
DEBUG
{
MOZ_ASSERT
(
element
-
>
isKind
(
ParseNodeKind
:
:
PNK_CALLSITEOBJ
)
)
;
ParseNode
*
array
=
element
-
>
pn_head
;
MOZ_ASSERT
(
array
-
>
isKind
(
ParseNodeKind
:
:
PNK_ARRAY
)
)
;
for
(
ParseNode
*
kid
=
array
-
>
pn_head
;
kid
;
kid
=
kid
-
>
pn_next
)
MOZ_ASSERT
(
kid
-
>
isKind
(
ParseNodeKind
:
:
PNK_TEMPLATE_STRING
)
)
;
for
(
ParseNode
*
next
=
array
-
>
pn_next
;
next
;
next
=
next
-
>
pn_next
)
{
MOZ_ASSERT
(
next
-
>
isKind
(
ParseNodeKind
:
:
PNK_TEMPLATE_STRING
)
|
|
next
-
>
isKind
(
ParseNodeKind
:
:
PNK_RAW_UNDEFINED
)
)
;
}
}
#
endif
ParseNode
*
interpolated
=
element
-
>
pn_next
;
for
(
;
interpolated
;
interpolated
=
interpolated
-
>
pn_next
)
{
if
(
!
resolve
(
interpolated
prefix
)
)
return
false
;
}
return
true
;
}
public
:
explicit
NameResolver
(
JSContext
*
cx
)
:
cx
(
cx
)
nparents
(
0
)
buf
(
nullptr
)
{
}
bool
resolve
(
ParseNode
*
const
cur
HandleAtom
prefixArg
=
nullptr
)
{
RootedAtom
prefix
(
cx
prefixArg
)
;
if
(
cur
=
=
nullptr
)
return
true
;
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_CODE
)
=
=
(
cur
-
>
isKind
(
ParseNodeKind
:
:
PNK_FUNCTION
)
|
|
cur
-
>
isKind
(
ParseNodeKind
:
:
PNK_MODULE
)
)
)
;
if
(
cur
-
>
isKind
(
ParseNodeKind
:
:
PNK_FUNCTION
)
)
{
RootedAtom
prefix2
(
cx
)
;
if
(
!
resolveFun
(
cur
prefix
&
prefix2
)
)
return
false
;
if
(
!
isDirectCall
(
nparents
-
1
cur
)
)
prefix
=
prefix2
;
}
if
(
nparents
>
=
MaxParents
)
return
true
;
auto
initialParents
=
nparents
;
parents
[
initialParents
]
=
cur
;
nparents
+
+
;
switch
(
cur
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
PNK_NOP
:
case
ParseNodeKind
:
:
PNK_STRING
:
case
ParseNodeKind
:
:
PNK_TEMPLATE_STRING
:
case
ParseNodeKind
:
:
PNK_REGEXP
:
case
ParseNodeKind
:
:
PNK_TRUE
:
case
ParseNodeKind
:
:
PNK_FALSE
:
case
ParseNodeKind
:
:
PNK_NULL
:
case
ParseNodeKind
:
:
PNK_RAW_UNDEFINED
:
case
ParseNodeKind
:
:
PNK_ELISION
:
case
ParseNodeKind
:
:
PNK_GENERATOR
:
case
ParseNodeKind
:
:
PNK_NUMBER
:
case
ParseNodeKind
:
:
PNK_BREAK
:
case
ParseNodeKind
:
:
PNK_CONTINUE
:
case
ParseNodeKind
:
:
PNK_DEBUGGER
:
case
ParseNodeKind
:
:
PNK_EXPORT_BATCH_SPEC
:
case
ParseNodeKind
:
:
PNK_OBJECT_PROPERTY_NAME
:
case
ParseNodeKind
:
:
PNK_POSHOLDER
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_NULLARY
)
)
;
break
;
case
ParseNodeKind
:
:
PNK_TYPEOFNAME
:
case
ParseNodeKind
:
:
PNK_SUPERBASE
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
MOZ_ASSERT
(
cur
-
>
pn_kid
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
)
;
MOZ_ASSERT
(
!
cur
-
>
pn_kid
-
>
expr
(
)
)
;
break
;
case
ParseNodeKind
:
:
PNK_NEWTARGET
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
MOZ_ASSERT
(
cur
-
>
pn_left
-
>
isKind
(
ParseNodeKind
:
:
PNK_POSHOLDER
)
)
;
MOZ_ASSERT
(
cur
-
>
pn_right
-
>
isKind
(
ParseNodeKind
:
:
PNK_POSHOLDER
)
)
;
break
;
case
ParseNodeKind
:
:
PNK_TYPEOFEXPR
:
case
ParseNodeKind
:
:
PNK_VOID
:
case
ParseNodeKind
:
:
PNK_NOT
:
case
ParseNodeKind
:
:
PNK_BITNOT
:
case
ParseNodeKind
:
:
PNK_THROW
:
case
ParseNodeKind
:
:
PNK_DELETENAME
:
case
ParseNodeKind
:
:
PNK_DELETEPROP
:
case
ParseNodeKind
:
:
PNK_DELETEELEM
:
case
ParseNodeKind
:
:
PNK_DELETEEXPR
:
case
ParseNodeKind
:
:
PNK_NEG
:
case
ParseNodeKind
:
:
PNK_POS
:
case
ParseNodeKind
:
:
PNK_PREINCREMENT
:
case
ParseNodeKind
:
:
PNK_POSTINCREMENT
:
case
ParseNodeKind
:
:
PNK_PREDECREMENT
:
case
ParseNodeKind
:
:
PNK_POSTDECREMENT
:
case
ParseNodeKind
:
:
PNK_COMPUTED_NAME
:
case
ParseNodeKind
:
:
PNK_SPREAD
:
case
ParseNodeKind
:
:
PNK_MUTATEPROTO
:
case
ParseNodeKind
:
:
PNK_EXPORT
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_kid
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_SEMI
:
case
ParseNodeKind
:
:
PNK_THIS
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
if
(
ParseNode
*
expr
=
cur
-
>
pn_kid
)
{
if
(
!
resolve
(
expr
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_ASSIGN
:
case
ParseNodeKind
:
:
PNK_ADDASSIGN
:
case
ParseNodeKind
:
:
PNK_SUBASSIGN
:
case
ParseNodeKind
:
:
PNK_BITORASSIGN
:
case
ParseNodeKind
:
:
PNK_BITXORASSIGN
:
case
ParseNodeKind
:
:
PNK_BITANDASSIGN
:
case
ParseNodeKind
:
:
PNK_LSHASSIGN
:
case
ParseNodeKind
:
:
PNK_RSHASSIGN
:
case
ParseNodeKind
:
:
PNK_URSHASSIGN
:
case
ParseNodeKind
:
:
PNK_MULASSIGN
:
case
ParseNodeKind
:
:
PNK_DIVASSIGN
:
case
ParseNodeKind
:
:
PNK_MODASSIGN
:
case
ParseNodeKind
:
:
PNK_POWASSIGN
:
case
ParseNodeKind
:
:
PNK_COLON
:
case
ParseNodeKind
:
:
PNK_SHORTHAND
:
case
ParseNodeKind
:
:
PNK_DOWHILE
:
case
ParseNodeKind
:
:
PNK_WHILE
:
case
ParseNodeKind
:
:
PNK_SWITCH
:
case
ParseNodeKind
:
:
PNK_FOR
:
case
ParseNodeKind
:
:
PNK_CLASSMETHOD
:
case
ParseNodeKind
:
:
PNK_SETTHIS
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_left
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_right
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_ELEM
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
cur
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
&
&
!
resolve
(
cur
-
>
pn_left
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_right
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_WITH
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_left
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_right
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_CASE
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
ParseNode
*
caseExpr
=
cur
-
>
pn_left
)
{
if
(
!
resolve
(
caseExpr
prefix
)
)
return
false
;
}
if
(
!
resolve
(
cur
-
>
pn_right
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_INITIALYIELD
:
MOZ_ASSERT
(
cur
-
>
pn_kid
-
>
isKind
(
ParseNodeKind
:
:
PNK_ASSIGN
)
&
&
cur
-
>
pn_kid
-
>
pn_left
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
&
&
cur
-
>
pn_kid
-
>
pn_right
-
>
isKind
(
ParseNodeKind
:
:
PNK_GENERATOR
)
)
;
break
;
case
ParseNodeKind
:
:
PNK_YIELD_STAR
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_kid
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_YIELD
:
case
ParseNodeKind
:
:
PNK_AWAIT
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
if
(
cur
-
>
pn_kid
)
{
if
(
!
resolve
(
cur
-
>
pn_kid
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_RETURN
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_UNARY
)
)
;
if
(
ParseNode
*
returnValue
=
cur
-
>
pn_kid
)
{
if
(
!
resolve
(
returnValue
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_IMPORT
:
case
ParseNodeKind
:
:
PNK_EXPORT_FROM
:
case
ParseNodeKind
:
:
PNK_EXPORT_DEFAULT
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_left
prefix
)
)
return
false
;
MOZ_ASSERT_IF
(
!
cur
-
>
isKind
(
ParseNodeKind
:
:
PNK_EXPORT_DEFAULT
)
cur
-
>
pn_right
-
>
isKind
(
ParseNodeKind
:
:
PNK_STRING
)
)
;
break
;
case
ParseNodeKind
:
:
PNK_CONDITIONAL
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_kid1
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_kid2
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_kid3
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_FORIN
:
case
ParseNodeKind
:
:
PNK_FOROF
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
ParseNode
*
decl
=
cur
-
>
pn_kid1
)
{
if
(
!
resolve
(
decl
prefix
)
)
return
false
;
}
if
(
!
resolve
(
cur
-
>
pn_kid2
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_kid3
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_FORHEAD
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
ParseNode
*
init
=
cur
-
>
pn_kid1
)
{
if
(
!
resolve
(
init
prefix
)
)
return
false
;
}
if
(
ParseNode
*
cond
=
cur
-
>
pn_kid2
)
{
if
(
!
resolve
(
cond
prefix
)
)
return
false
;
}
if
(
ParseNode
*
step
=
cur
-
>
pn_kid3
)
{
if
(
!
resolve
(
step
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_CLASS
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
cur
-
>
pn_kid1
-
>
isKind
(
ParseNodeKind
:
:
PNK_CLASSNAMES
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
cur
-
>
pn_kid1
-
>
isArity
(
PN_BINARY
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
&
&
cur
-
>
pn_kid1
-
>
pn_left
cur
-
>
pn_kid1
-
>
pn_left
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
&
&
cur
-
>
pn_kid1
-
>
pn_left
!
cur
-
>
pn_kid1
-
>
pn_left
-
>
expr
(
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
cur
-
>
pn_kid1
-
>
pn_right
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
)
;
MOZ_ASSERT_IF
(
cur
-
>
pn_kid1
!
cur
-
>
pn_kid1
-
>
pn_right
-
>
expr
(
)
)
;
if
(
cur
-
>
pn_kid2
)
{
if
(
!
resolve
(
cur
-
>
pn_kid2
prefix
)
)
return
false
;
}
if
(
!
resolve
(
cur
-
>
pn_kid3
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_IF
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_kid1
prefix
)
)
return
false
;
if
(
!
resolve
(
cur
-
>
pn_kid2
prefix
)
)
return
false
;
if
(
cur
-
>
pn_kid3
)
{
if
(
!
resolve
(
cur
-
>
pn_kid3
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_TRY
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
resolve
(
cur
-
>
pn_kid1
prefix
)
)
return
false
;
MOZ_ASSERT
(
cur
-
>
pn_kid2
|
|
cur
-
>
pn_kid3
)
;
if
(
ParseNode
*
catchScope
=
cur
-
>
pn_kid2
)
{
MOZ_ASSERT
(
catchScope
-
>
isKind
(
ParseNodeKind
:
:
PNK_LEXICALSCOPE
)
)
;
MOZ_ASSERT
(
catchScope
-
>
scopeBody
(
)
-
>
isKind
(
ParseNodeKind
:
:
PNK_CATCH
)
)
;
MOZ_ASSERT
(
catchScope
-
>
scopeBody
(
)
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
resolve
(
catchScope
-
>
scopeBody
(
)
prefix
)
)
return
false
;
}
if
(
ParseNode
*
finallyBlock
=
cur
-
>
pn_kid3
)
{
if
(
!
resolve
(
finallyBlock
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_CATCH
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_BINARY
)
)
;
if
(
cur
-
>
pn_left
)
{
if
(
!
resolve
(
cur
-
>
pn_left
prefix
)
)
return
false
;
}
if
(
!
resolve
(
cur
-
>
pn_right
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_OR
:
case
ParseNodeKind
:
:
PNK_AND
:
case
ParseNodeKind
:
:
PNK_BITOR
:
case
ParseNodeKind
:
:
PNK_BITXOR
:
case
ParseNodeKind
:
:
PNK_BITAND
:
case
ParseNodeKind
:
:
PNK_STRICTEQ
:
case
ParseNodeKind
:
:
PNK_EQ
:
case
ParseNodeKind
:
:
PNK_STRICTNE
:
case
ParseNodeKind
:
:
PNK_NE
:
case
ParseNodeKind
:
:
PNK_LT
:
case
ParseNodeKind
:
:
PNK_LE
:
case
ParseNodeKind
:
:
PNK_GT
:
case
ParseNodeKind
:
:
PNK_GE
:
case
ParseNodeKind
:
:
PNK_INSTANCEOF
:
case
ParseNodeKind
:
:
PNK_IN
:
case
ParseNodeKind
:
:
PNK_LSH
:
case
ParseNodeKind
:
:
PNK_RSH
:
case
ParseNodeKind
:
:
PNK_URSH
:
case
ParseNodeKind
:
:
PNK_ADD
:
case
ParseNodeKind
:
:
PNK_SUB
:
case
ParseNodeKind
:
:
PNK_STAR
:
case
ParseNodeKind
:
:
PNK_DIV
:
case
ParseNodeKind
:
:
PNK_MOD
:
case
ParseNodeKind
:
:
PNK_POW
:
case
ParseNodeKind
:
:
PNK_PIPELINE
:
case
ParseNodeKind
:
:
PNK_COMMA
:
case
ParseNodeKind
:
:
PNK_NEW
:
case
ParseNodeKind
:
:
PNK_CALL
:
case
ParseNodeKind
:
:
PNK_SUPERCALL
:
case
ParseNodeKind
:
:
PNK_ARRAY
:
case
ParseNodeKind
:
:
PNK_STATEMENTLIST
:
case
ParseNodeKind
:
:
PNK_PARAMSBODY
:
case
ParseNodeKind
:
:
PNK_VAR
:
case
ParseNodeKind
:
:
PNK_CONST
:
case
ParseNodeKind
:
:
PNK_LET
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
element
=
cur
-
>
pn_head
;
element
;
element
=
element
-
>
pn_next
)
{
if
(
!
resolve
(
element
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_OBJECT
:
case
ParseNodeKind
:
:
PNK_CLASSMETHODLIST
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
element
=
cur
-
>
pn_head
;
element
;
element
=
element
-
>
pn_next
)
{
if
(
!
resolve
(
element
prefix
)
)
return
false
;
}
break
;
case
ParseNodeKind
:
:
PNK_TEMPLATE_STRING_LIST
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_LIST
)
)
;
if
(
!
resolveTemplateLiteral
(
cur
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_TAGGED_TEMPLATE
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_LIST
)
)
;
if
(
!
resolveTaggedTemplate
(
cur
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_EXPORT_SPEC_LIST
:
case
ParseNodeKind
:
:
PNK_IMPORT_SPEC_LIST
:
{
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_LIST
)
)
;
#
ifdef
DEBUG
bool
isImport
=
cur
-
>
isKind
(
ParseNodeKind
:
:
PNK_IMPORT_SPEC_LIST
)
;
ParseNode
*
item
=
cur
-
>
pn_head
;
if
(
!
isImport
&
&
item
&
&
item
-
>
isKind
(
ParseNodeKind
:
:
PNK_EXPORT_BATCH_SPEC
)
)
{
MOZ_ASSERT
(
item
-
>
isArity
(
PN_NULLARY
)
)
;
break
;
}
for
(
;
item
;
item
=
item
-
>
pn_next
)
{
MOZ_ASSERT
(
item
-
>
isKind
(
isImport
?
ParseNodeKind
:
:
PNK_IMPORT_SPEC
:
ParseNodeKind
:
:
PNK_EXPORT_SPEC
)
)
;
MOZ_ASSERT
(
item
-
>
isArity
(
PN_BINARY
)
)
;
MOZ_ASSERT
(
item
-
>
pn_left
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
)
;
MOZ_ASSERT
(
!
item
-
>
pn_left
-
>
expr
(
)
)
;
MOZ_ASSERT
(
item
-
>
pn_right
-
>
isKind
(
ParseNodeKind
:
:
PNK_NAME
)
)
;
MOZ_ASSERT
(
!
item
-
>
pn_right
-
>
expr
(
)
)
;
}
#
endif
break
;
}
case
ParseNodeKind
:
:
PNK_DOT
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_NAME
)
)
;
if
(
cur
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
break
;
if
(
!
resolve
(
cur
-
>
expr
(
)
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_LABEL
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_NAME
)
)
;
if
(
!
resolve
(
cur
-
>
expr
(
)
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_NAME
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_NAME
)
)
;
if
(
!
resolve
(
cur
-
>
expr
(
)
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_LEXICALSCOPE
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_SCOPE
)
)
;
if
(
!
resolve
(
cur
-
>
scopeBody
(
)
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_FUNCTION
:
case
ParseNodeKind
:
:
PNK_MODULE
:
MOZ_ASSERT
(
cur
-
>
isArity
(
PN_CODE
)
)
;
if
(
!
resolve
(
cur
-
>
pn_body
prefix
)
)
return
false
;
break
;
case
ParseNodeKind
:
:
PNK_IMPORT_SPEC
:
case
ParseNodeKind
:
:
PNK_EXPORT_SPEC
:
case
ParseNodeKind
:
:
PNK_CALLSITEOBJ
:
case
ParseNodeKind
:
:
PNK_CLASSNAMES
:
MOZ_CRASH
(
"
should
have
been
handled
by
a
parent
node
"
)
;
case
ParseNodeKind
:
:
PNK_LIMIT
:
MOZ_CRASH
(
"
invalid
node
kind
"
)
;
}
nparents
-
-
;
MOZ_ASSERT
(
initialParents
=
=
nparents
"
nparents
imbalance
detected
"
)
;
MOZ_ASSERT
(
parents
[
initialParents
]
=
=
cur
"
pushed
child
shouldn
'
t
change
underneath
us
"
)
;
JS_POISON
(
&
parents
[
initialParents
]
0xFF
sizeof
(
parents
[
initialParents
]
)
)
;
MOZ_MAKE_MEM_UNDEFINED
(
&
parents
[
initialParents
]
sizeof
(
parents
[
initialParents
]
)
)
;
return
true
;
}
}
;
}
bool
frontend
:
:
NameFunctions
(
JSContext
*
cx
ParseNode
*
pn
)
{
AutoTraceLog
traceLog
(
TraceLoggerForCurrentThread
(
cx
)
TraceLogger_BytecodeNameFunctions
)
;
NameResolver
nr
(
cx
)
;
return
nr
.
resolve
(
pn
)
;
}
