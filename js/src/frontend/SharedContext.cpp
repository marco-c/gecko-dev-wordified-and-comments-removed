#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
frontend
/
ParseContext
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
namespace
js
{
namespace
frontend
{
void
SharedContext
:
:
computeAllowSyntax
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
FunctionScope
*
funScope
=
&
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funScope
-
>
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
fun
-
>
isDerivedClassConstructor
(
)
;
if
(
funScope
-
>
isFieldInitializer
(
)
=
=
IsFieldInitializer
:
:
Yes
)
{
allowSuperCall_
=
false
;
allowArguments_
=
false
;
}
return
;
}
}
}
void
SharedContext
:
:
computeThisBinding
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
return
;
}
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
needsThisTDZChecks_
=
true
;
}
thisBinding_
=
ThisBinding
:
:
Function
;
return
;
}
}
thisBinding_
=
ThisBinding
:
:
Global
;
}
void
SharedContext
:
:
computeInWith
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
inWith_
=
true
;
break
;
}
}
}
EvalSharedContext
:
:
EvalSharedContext
(
JSContext
*
cx
JSObject
*
enclosingEnv
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
Directives
directives
)
:
SharedContext
(
cx
Kind
:
:
Eval
compilationInfo
directives
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
{
computeAllowSyntax
(
enclosingScope
)
;
computeInWith
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
if
(
enclosingEnv
&
&
enclosingScope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
{
JSObject
*
env
=
enclosingEnv
;
while
(
env
)
{
JSObject
*
unwrapped
=
env
;
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
{
unwrapped
=
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
.
environment
(
)
;
}
if
(
unwrapped
-
>
is
<
CallObject
>
(
)
)
{
JSFunction
*
callee
=
&
unwrapped
-
>
as
<
CallObject
>
(
)
.
callee
(
)
;
computeThisBinding
(
callee
-
>
nonLazyScript
(
)
-
>
bodyScope
(
)
)
;
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
}
}
#
ifdef
DEBUG
bool
FunctionBox
:
:
atomsAreKept
(
)
{
return
cx_
-
>
zone
(
)
-
>
hasKeptAtoms
(
)
;
}
#
endif
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
uint32_t
toStringStart
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
JSAtom
*
explicitName
FunctionFlags
flags
)
:
SharedContext
(
cx
Kind
:
:
FunctionBox
compilationInfo
directives
)
object_
(
nullptr
)
traceLink_
(
traceListHead
)
emitLink_
(
nullptr
)
enclosingScope_
(
)
namedLambdaBindings_
(
nullptr
)
functionScopeBindings_
(
nullptr
)
extraVarScopeBindings_
(
nullptr
)
functionNode
(
nullptr
)
extent
{
0
0
toStringStart
0
1
0
}
length
(
0
)
isGenerator_
(
generatorKind
=
=
GeneratorKind
:
:
Generator
)
isAsync_
(
asyncKind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
hasDestructuringArgs
(
false
)
hasParameterExprs
(
false
)
hasDuplicateParameters
(
false
)
useAsm
(
false
)
isAnnexB
(
false
)
wasEmitted
(
false
)
emitBytecode
(
false
)
declaredArguments
(
false
)
usesArguments
(
false
)
usesApply
(
false
)
usesThis
(
false
)
usesReturn
(
false
)
hasRest_
(
false
)
hasExprBody_
(
false
)
hasExtensibleScope_
(
false
)
argumentsHasLocalBinding_
(
false
)
definitelyNeedsArgsObj_
(
false
)
needsHomeObject_
(
false
)
isDerivedClassConstructor_
(
false
)
hasThisBinding_
(
false
)
nargs_
(
0
)
explicitName_
(
explicitName
)
flags_
(
flags
)
{
}
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
JSFunction
*
fun
uint32_t
toStringStart
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
)
:
FunctionBox
(
cx
traceListHead
toStringStart
compilationInfo
directives
generatorKind
asyncKind
fun
-
>
explicitName
(
)
fun
-
>
flags
(
)
)
{
object_
=
fun
;
MOZ_ASSERT
(
fun
-
>
isTenured
(
)
)
;
}
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
uint32_t
toStringStart
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
size_t
functionIndex
)
:
FunctionBox
(
cx
traceListHead
toStringStart
compilationInfo
directives
generatorKind
asyncKind
compilationInfo
.
funcData
[
functionIndex
]
.
as
<
FunctionCreationData
>
(
)
.
get
(
)
.
atom
compilationInfo
.
funcData
[
functionIndex
]
.
as
<
FunctionCreationData
>
(
)
.
get
(
)
.
flags
)
{
funcDataIndex_
.
emplace
(
functionIndex
)
;
}
void
FunctionBox
:
:
initFromLazyFunction
(
JSFunction
*
fun
)
{
BaseScript
*
lazy
=
fun
-
>
baseScript
(
)
;
if
(
lazy
-
>
isDerivedClassConstructor
(
)
)
{
setDerivedClassConstructor
(
)
;
}
if
(
lazy
-
>
needsHomeObject
(
)
)
{
setNeedsHomeObject
(
)
;
}
if
(
lazy
-
>
bindingsAccessedDynamically
(
)
)
{
setBindingsAccessedDynamically
(
)
;
}
if
(
lazy
-
>
hasDirectEval
(
)
)
{
setHasDirectEval
(
)
;
}
if
(
lazy
-
>
hasModuleGoal
(
)
)
{
setHasModuleGoal
(
)
;
}
extent
=
lazy
-
>
extent
(
)
;
}
void
FunctionBox
:
:
initStandaloneFunction
(
Scope
*
enclosingScope
)
{
MOZ_ASSERT
(
enclosingScope
-
>
is
<
GlobalScope
>
(
)
)
;
enclosingScope_
=
AbstractScopePtr
(
enclosingScope
)
;
allowNewTarget_
=
true
;
thisBinding_
=
ThisBinding
:
:
Function
;
}
void
FunctionBox
:
:
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionSyntaxKind
kind
bool
isArrow
bool
allowSuperProperty
)
{
SharedContext
*
sc
=
enclosing
-
>
sc
(
)
;
useAsm
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
if
(
isArrow
)
{
allowNewTarget_
=
sc
-
>
allowNewTarget
(
)
;
allowSuperProperty_
=
sc
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
sc
-
>
allowSuperCall
(
)
;
allowArguments_
=
sc
-
>
allowArguments
(
)
;
needsThisTDZChecks_
=
sc
-
>
needsThisTDZChecks
(
)
;
thisBinding_
=
sc
-
>
thisBinding
(
)
;
}
else
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
allowSuperProperty
;
if
(
IsConstructorKind
(
kind
)
)
{
auto
stmt
=
enclosing
-
>
findInnermostStatement
<
ParseContext
:
:
ClassStatement
>
(
)
;
MOZ_ASSERT
(
stmt
)
;
stmt
-
>
constructorBox
=
this
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
}
thisBinding_
=
ThisBinding
:
:
Function
;
}
hasModuleGoal_
=
sc
-
>
hasModuleGoal
(
)
;
if
(
sc
-
>
inWith
(
)
)
{
inWith_
=
true
;
}
else
{
auto
isWith
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
With
;
}
;
inWith_
=
enclosing
-
>
findInnermostStatement
(
isWith
)
;
}
}
void
FunctionBox
:
:
initFieldInitializer
(
ParseContext
*
enclosing
Handle
<
FunctionCreationData
>
data
)
{
this
-
>
initWithEnclosingParseContext
(
enclosing
data
FunctionSyntaxKind
:
:
Method
)
;
allowArguments_
=
false
;
}
void
FunctionBox
:
:
initWithEnclosingScope
(
JSFunction
*
fun
)
{
Scope
*
enclosingScope
=
fun
-
>
enclosingScope
(
)
;
MOZ_ASSERT
(
enclosingScope
)
;
if
(
!
isArrow
(
)
)
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
if
(
isDerivedClassConstructor
(
)
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
thisBinding_
=
ThisBinding
:
:
Function
;
}
else
{
computeAllowSyntax
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
}
computeInWith
(
enclosingScope
)
;
enclosingScope_
=
AbstractScopePtr
(
enclosingScope
)
;
}
void
FunctionBox
:
:
setEnclosingScopeForInnerLazyFunction
(
const
AbstractScopePtr
&
enclosingScope
)
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
enclosingScope_
=
enclosingScope
;
}
void
FunctionBox
:
:
finish
(
)
{
if
(
!
emitBytecode
)
{
function
(
)
-
>
setEnclosingScope
(
enclosingScope_
.
getExistingScope
(
)
)
;
}
else
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
}
}
void
FunctionBox
:
:
TraceList
(
JSTracer
*
trc
FunctionBox
*
listHead
)
{
for
(
FunctionBox
*
node
=
listHead
;
node
;
node
=
node
-
>
traceLink_
)
{
node
-
>
trace
(
trc
)
;
}
}
void
FunctionBox
:
:
trace
(
JSTracer
*
trc
)
{
if
(
object_
)
{
TraceRoot
(
trc
&
object_
"
funbox
-
object
"
)
;
}
if
(
enclosingScope_
)
{
enclosingScope_
.
trace
(
trc
)
;
}
if
(
explicitName_
)
{
TraceRoot
(
trc
&
explicitName_
"
funbox
-
explicitName
"
)
;
}
}
ModuleSharedContext
:
:
ModuleSharedContext
(
JSContext
*
cx
ModuleObject
*
module
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
ModuleBuilder
&
builder
)
:
SharedContext
(
cx
Kind
:
:
Module
compilationInfo
Directives
(
true
)
)
module_
(
cx
module
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
builder
(
builder
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
hasModuleGoal_
=
true
;
}
MutableHandle
<
FunctionCreationData
>
FunctionBox
:
:
functionCreationData
(
)
const
{
MOZ_ASSERT
(
hasFunctionCreationIndex
(
)
)
;
return
MutableHandle
<
FunctionCreationData
>
:
:
fromMarkedLocation
(
&
compilationInfo_
.
funcData
[
*
funcDataIndex_
]
.
get
(
)
.
as
<
FunctionCreationData
>
(
)
)
;
}
}
}
