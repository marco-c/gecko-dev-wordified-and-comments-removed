#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
frontend
/
ParseContext
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
namespace
js
{
namespace
frontend
{
SharedContext
:
:
SharedContext
(
JSContext
*
cx
Kind
kind
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
cx_
(
cx
)
compilationInfo_
(
compilationInfo
)
thisBinding_
(
ThisBinding
:
:
Global
)
extent
(
extent
)
allowNewTarget_
(
false
)
allowSuperProperty_
(
false
)
allowSuperCall_
(
false
)
allowArguments_
(
true
)
inWith_
(
false
)
needsThisTDZChecks_
(
false
)
localStrict
(
false
)
hasExplicitUseStrict_
(
false
)
{
if
(
kind
=
=
Kind
:
:
FunctionBox
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsFunction
)
;
}
else
if
(
kind
=
=
Kind
:
:
Module
)
{
MOZ_ASSERT
(
!
compilationInfo
.
options
.
nonSyntacticScope
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsModule
)
;
}
else
if
(
kind
=
=
Kind
:
:
Eval
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsForEval
)
;
}
else
{
MOZ_ASSERT
(
kind
=
=
Kind
:
:
Global
)
;
}
const
JS
:
:
ReadOnlyCompileOptions
&
options
=
compilationInfo
.
options
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
SelfHosted
options
.
selfHostingMode
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasNonSyntacticScope
options
.
nonSyntacticScope
)
;
if
(
isTopLevelContext
(
)
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
NoScriptRval
options
.
noScriptRval
)
;
}
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
Strict
directives
.
strict
(
)
)
;
}
void
SharedContext
:
:
computeAllowSyntax
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
FunctionScope
*
funScope
=
&
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funScope
-
>
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
fun
-
>
isDerivedClassConstructor
(
)
;
if
(
funScope
-
>
isFieldInitializer
(
)
=
=
IsFieldInitializer
:
:
Yes
)
{
allowSuperCall_
=
false
;
allowArguments_
=
false
;
}
return
;
}
}
}
void
SharedContext
:
:
computeThisBinding
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
return
;
}
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
needsThisTDZChecks_
=
true
;
}
thisBinding_
=
ThisBinding
:
:
Function
;
return
;
}
}
thisBinding_
=
ThisBinding
:
:
Global
;
}
void
SharedContext
:
:
computeInWith
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
inWith_
=
true
;
break
;
}
}
}
EvalSharedContext
:
:
EvalSharedContext
(
JSContext
*
cx
JSObject
*
enclosingEnv
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
Directives
directives
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Eval
compilationInfo
directives
extent
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
{
computeAllowSyntax
(
enclosingScope
)
;
computeInWith
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
if
(
enclosingEnv
&
&
enclosingScope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
{
JSObject
*
env
=
enclosingEnv
;
while
(
env
)
{
JSObject
*
unwrapped
=
env
;
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
{
unwrapped
=
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
.
environment
(
)
;
}
if
(
unwrapped
-
>
is
<
CallObject
>
(
)
)
{
JSFunction
*
callee
=
&
unwrapped
-
>
as
<
CallObject
>
(
)
.
callee
(
)
;
computeThisBinding
(
callee
-
>
nonLazyScript
(
)
-
>
bodyScope
(
)
)
;
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
}
}
#
ifdef
DEBUG
bool
FunctionBox
:
:
atomsAreKept
(
)
{
return
cx_
-
>
zone
(
)
-
>
hasKeptAtoms
(
)
;
}
#
endif
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
SourceExtent
extent
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
JSAtom
*
explicitName
FunctionFlags
flags
size_t
index
)
:
SharedContext
(
cx
Kind
:
:
FunctionBox
compilationInfo
directives
extent
)
traceLink_
(
traceListHead
)
emitLink_
(
nullptr
)
enclosingScope_
(
)
namedLambdaBindings_
(
nullptr
)
functionScopeBindings_
(
nullptr
)
extraVarScopeBindings_
(
nullptr
)
funcDataIndex_
(
index
)
functionNode
(
nullptr
)
length
(
0
)
hasDestructuringArgs
(
false
)
hasParameterExprs
(
false
)
hasDuplicateParameters
(
false
)
useAsm
(
false
)
isAnnexB
(
false
)
wasEmitted
(
false
)
emitBytecode
(
false
)
usesArguments
(
false
)
usesApply
(
false
)
usesThis
(
false
)
usesReturn
(
false
)
hasExprBody_
(
false
)
isAsmJSModule_
(
false
)
nargs_
(
0
)
explicitName_
(
explicitName
)
flags_
(
flags
)
{
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsGenerator
generatorKind
=
=
GeneratorKind
:
:
Generator
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsAsync
asyncKind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
;
}
bool
FunctionBox
:
:
hasFunctionCreationData
(
)
const
{
return
compilationInfo_
.
funcData
[
funcDataIndex_
]
.
get
(
)
.
is
<
FunctionCreationData
>
(
)
;
}
bool
FunctionBox
:
:
hasFunction
(
)
const
{
return
compilationInfo_
.
funcData
[
funcDataIndex_
]
.
get
(
)
.
is
<
JSFunction
*
>
(
)
;
}
void
FunctionBox
:
:
initFromLazyFunction
(
JSFunction
*
fun
)
{
BaseScript
*
lazy
=
fun
-
>
baseScript
(
)
;
immutableFlags_
=
lazy
-
>
immutableFlags
(
)
;
extent
=
lazy
-
>
extent
(
)
;
if
(
fun
-
>
isClassConstructor
(
)
)
{
fieldInitializers
=
mozilla
:
:
Some
(
lazy
-
>
getFieldInitializers
(
)
)
;
}
}
void
FunctionBox
:
:
initStandaloneFunction
(
Scope
*
enclosingScope
)
{
MOZ_ASSERT
(
enclosingScope
-
>
is
<
GlobalScope
>
(
)
)
;
enclosingScope_
=
AbstractScopePtr
(
enclosingScope
)
;
allowNewTarget_
=
true
;
thisBinding_
=
ThisBinding
:
:
Function
;
}
void
FunctionBox
:
:
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionSyntaxKind
kind
bool
isArrow
bool
allowSuperProperty
)
{
SharedContext
*
sc
=
enclosing
-
>
sc
(
)
;
useAsm
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
if
(
isArrow
)
{
allowNewTarget_
=
sc
-
>
allowNewTarget
(
)
;
allowSuperProperty_
=
sc
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
sc
-
>
allowSuperCall
(
)
;
allowArguments_
=
sc
-
>
allowArguments
(
)
;
needsThisTDZChecks_
=
sc
-
>
needsThisTDZChecks
(
)
;
thisBinding_
=
sc
-
>
thisBinding
(
)
;
}
else
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
allowSuperProperty
;
if
(
IsConstructorKind
(
kind
)
)
{
auto
stmt
=
enclosing
-
>
findInnermostStatement
<
ParseContext
:
:
ClassStatement
>
(
)
;
MOZ_ASSERT
(
stmt
)
;
stmt
-
>
constructorBox
=
this
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
}
thisBinding_
=
ThisBinding
:
:
Function
;
}
setHasModuleGoal
(
sc
-
>
hasModuleGoal
(
)
)
;
if
(
sc
-
>
inWith
(
)
)
{
inWith_
=
true
;
}
else
{
auto
isWith
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
With
;
}
;
inWith_
=
enclosing
-
>
findInnermostStatement
(
isWith
)
;
}
}
void
FunctionBox
:
:
initFieldInitializer
(
ParseContext
*
enclosing
Handle
<
FunctionCreationData
>
data
)
{
this
-
>
initWithEnclosingParseContext
(
enclosing
data
FunctionSyntaxKind
:
:
Method
)
;
allowArguments_
=
false
;
}
void
FunctionBox
:
:
initWithEnclosingScope
(
JSFunction
*
fun
)
{
Scope
*
enclosingScope
=
fun
-
>
enclosingScope
(
)
;
MOZ_ASSERT
(
enclosingScope
)
;
if
(
!
isArrow
(
)
)
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
fun
-
>
allowSuperProperty
(
)
;
if
(
isDerivedClassConstructor
(
)
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
needsThisTDZChecks_
=
true
;
}
thisBinding_
=
ThisBinding
:
:
Function
;
}
else
{
computeAllowSyntax
(
enclosingScope
)
;
computeThisBinding
(
enclosingScope
)
;
}
computeInWith
(
enclosingScope
)
;
enclosingScope_
=
AbstractScopePtr
(
enclosingScope
)
;
}
void
FunctionBox
:
:
setEnclosingScopeForInnerLazyFunction
(
const
AbstractScopePtr
&
enclosingScope
)
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
enclosingScope_
=
enclosingScope
;
}
void
FunctionBox
:
:
setAsmJSModule
(
JSFunction
*
function
)
{
MOZ_ASSERT
(
IsAsmJSModule
(
function
)
)
;
isAsmJSModule_
=
true
;
clobberFunction
(
function
)
;
}
void
FunctionBox
:
:
finish
(
)
{
if
(
!
emitBytecode
)
{
function
(
)
-
>
setEnclosingScope
(
enclosingScope_
.
getExistingScope
(
)
)
;
function
(
)
-
>
baseScript
(
)
-
>
initTreatAsRunOnce
(
treatAsRunOnce
(
)
)
;
if
(
fieldInitializers
)
{
function
(
)
-
>
baseScript
(
)
-
>
setFieldInitializers
(
*
fieldInitializers
)
;
}
}
else
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
}
}
void
FunctionBox
:
:
TraceList
(
JSTracer
*
trc
FunctionBox
*
listHead
)
{
for
(
FunctionBox
*
node
=
listHead
;
node
;
node
=
node
-
>
traceLink_
)
{
node
-
>
trace
(
trc
)
;
}
}
void
FunctionBox
:
:
trace
(
JSTracer
*
trc
)
{
if
(
enclosingScope_
)
{
enclosingScope_
.
trace
(
trc
)
;
}
if
(
explicitName_
)
{
TraceRoot
(
trc
&
explicitName_
"
funbox
-
explicitName
"
)
;
}
}
JSFunction
*
FunctionBox
:
:
function
(
)
const
{
return
compilationInfo_
.
funcData
[
funcDataIndex_
]
.
as
<
JSFunction
*
>
(
)
;
}
void
FunctionBox
:
:
clobberFunction
(
JSFunction
*
function
)
{
compilationInfo_
.
funcData
[
funcDataIndex_
]
.
set
(
mozilla
:
:
AsVariant
(
function
)
)
;
setIsInterpreted
(
function
-
>
isInterpreted
(
)
)
;
}
ModuleSharedContext
:
:
ModuleSharedContext
(
JSContext
*
cx
ModuleObject
*
module
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
ModuleBuilder
&
builder
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Module
compilationInfo
Directives
(
true
)
extent
)
module_
(
cx
module
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
builder
(
builder
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasModuleGoal
)
;
}
MutableHandle
<
FunctionCreationData
>
FunctionBox
:
:
functionCreationData
(
)
const
{
MOZ_ASSERT
(
hasFunctionCreationData
(
)
)
;
return
MutableHandle
<
FunctionCreationData
>
:
:
fromMarkedLocation
(
&
compilationInfo_
.
funcData
[
funcDataIndex_
]
.
get
(
)
.
as
<
FunctionCreationData
>
(
)
)
;
}
}
}
