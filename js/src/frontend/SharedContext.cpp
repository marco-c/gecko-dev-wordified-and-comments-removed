#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
frontend
/
ParseContext
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
namespace
js
{
namespace
frontend
{
SharedContext
:
:
SharedContext
(
JSContext
*
cx
Kind
kind
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
cx_
(
cx
)
compilationInfo_
(
compilationInfo
)
extent
(
extent
)
allowNewTarget_
(
false
)
allowSuperProperty_
(
false
)
allowSuperCall_
(
false
)
allowArguments_
(
true
)
inWith_
(
false
)
inClass_
(
false
)
localStrict
(
false
)
hasExplicitUseStrict_
(
false
)
{
if
(
kind
=
=
Kind
:
:
FunctionBox
)
{
setFlag
(
ImmutableFlags
:
:
IsFunction
)
;
}
else
if
(
kind
=
=
Kind
:
:
Module
)
{
MOZ_ASSERT
(
!
compilationInfo
.
options
.
nonSyntacticScope
)
;
setFlag
(
ImmutableFlags
:
:
IsModule
)
;
}
else
if
(
kind
=
=
Kind
:
:
Eval
)
{
setFlag
(
ImmutableFlags
:
:
IsForEval
)
;
}
else
{
MOZ_ASSERT
(
kind
=
=
Kind
:
:
Global
)
;
}
const
JS
:
:
ReadOnlyCompileOptions
&
options
=
compilationInfo
.
options
;
setFlag
(
ImmutableFlags
:
:
SelfHosted
options
.
selfHostingMode
)
;
setFlag
(
ImmutableFlags
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
setFlag
(
ImmutableFlags
:
:
HasNonSyntacticScope
options
.
nonSyntacticScope
)
;
if
(
isTopLevelContext
(
)
)
{
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
setFlag
(
ImmutableFlags
:
:
NoScriptRval
options
.
noScriptRval
)
;
}
setFlag
(
ImmutableFlags
:
:
Strict
directives
.
strict
(
)
)
;
}
void
ScopeContext
:
:
computeAllowSyntax
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
FunctionScope
*
funScope
=
&
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funScope
-
>
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
allowNewTarget
=
true
;
allowSuperProperty
=
fun
-
>
allowSuperProperty
(
)
;
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
allowSuperCall
=
true
;
}
if
(
fun
-
>
isFieldInitializer
(
)
)
{
allowArguments
=
false
;
}
return
;
}
}
}
void
ScopeContext
:
:
computeThisBinding
(
Scope
*
scope
JSObject
*
environment
)
{
Scope
*
effectiveScope
=
scope
;
if
(
environment
&
&
scope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
{
JSObject
*
env
=
environment
;
while
(
env
)
{
JSObject
*
unwrapped
=
env
;
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
{
unwrapped
=
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
.
environment
(
)
;
}
if
(
unwrapped
-
>
is
<
CallObject
>
(
)
)
{
JSFunction
*
callee
=
&
unwrapped
-
>
as
<
CallObject
>
(
)
.
callee
(
)
;
effectiveScope
=
callee
-
>
nonLazyScript
(
)
-
>
bodyScope
(
)
;
break
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
}
for
(
ScopeIter
si
(
effectiveScope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
{
thisBinding
=
ThisBinding
:
:
Module
;
return
;
}
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
thisBinding
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding
=
ThisBinding
:
:
Function
;
}
return
;
}
}
thisBinding
=
ThisBinding
:
:
Global
;
}
void
ScopeContext
:
:
computeInWith
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
inWith
=
true
;
break
;
}
}
}
void
ScopeContext
:
:
computeInClass
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
ClassBody
)
{
inClass
=
true
;
break
;
}
}
}
void
ScopeContext
:
:
computeExternalInitializers
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
scope
(
)
-
>
is
<
FunctionScope
>
(
)
)
{
FunctionScope
&
funcScope
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funcScope
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isClassConstructor
(
)
)
{
fieldInitializers
=
mozilla
:
:
Some
(
fun
-
>
baseScript
(
)
-
>
getFieldInitializers
(
)
)
;
MOZ_ASSERT
(
fieldInitializers
-
>
valid
)
;
}
break
;
}
}
}
EvalSharedContext
:
:
EvalSharedContext
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
Directives
directives
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Eval
compilationInfo
directives
extent
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
{
allowNewTarget_
=
compilationInfo
.
scopeContext
.
allowNewTarget
;
allowSuperProperty_
=
compilationInfo
.
scopeContext
.
allowSuperProperty
;
allowSuperCall_
=
compilationInfo
.
scopeContext
.
allowSuperCall
;
allowArguments_
=
compilationInfo
.
scopeContext
.
allowArguments
;
thisBinding_
=
compilationInfo
.
scopeContext
.
thisBinding
;
inWith_
=
compilationInfo
.
scopeContext
.
inWith
;
}
#
ifdef
DEBUG
bool
FunctionBox
:
:
atomsAreKept
(
)
{
return
cx_
-
>
zone
(
)
-
>
hasKeptAtoms
(
)
;
}
#
endif
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
SourceExtent
extent
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
JSAtom
*
atom
FunctionFlags
flags
size_t
index
TopLevelFunction
isTopLevel
)
:
SharedContext
(
cx
Kind
:
:
FunctionBox
compilationInfo
directives
extent
)
traceLink_
(
traceListHead
)
atom_
(
atom
)
funcDataIndex_
(
index
)
flags_
(
flags
)
isTopLevel_
(
isTopLevel
)
emitBytecode
(
false
)
isStandalone
(
false
)
wasEmitted
(
false
)
isSingleton
(
false
)
isAnnexB
(
false
)
useAsm
(
false
)
isAsmJSModule_
(
false
)
hasParameterExprs
(
false
)
hasDestructuringArgs
(
false
)
hasDuplicateParameters
(
false
)
hasExprBody_
(
false
)
usesApply
(
false
)
usesThis
(
false
)
usesReturn
(
false
)
{
setFlag
(
ImmutableFlags
:
:
IsGenerator
generatorKind
=
=
GeneratorKind
:
:
Generator
)
;
setFlag
(
ImmutableFlags
:
:
IsAsync
asyncKind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
;
}
JSFunction
*
FunctionBox
:
:
createFunction
(
JSContext
*
cx
)
{
RootedObject
proto
(
cx
)
;
if
(
!
GetFunctionPrototype
(
cx
generatorKind
(
)
asyncKind
(
)
&
proto
)
)
{
return
nullptr
;
}
RootedAtom
atom
(
cx
displayAtom
(
)
)
;
gc
:
:
AllocKind
allocKind
=
flags_
.
isExtended
(
)
?
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
:
gc
:
:
AllocKind
:
:
FUNCTION
;
JSNative
maybeNative
=
isAsmJSModule
(
)
?
InstantiateAsmJS
:
nullptr
;
RootedFunction
fun
(
cx
NewFunctionWithProto
(
cx
maybeNative
nargs_
flags_
nullptr
atom
proto
allocKind
TenuredObject
)
)
;
if
(
!
fun
)
{
return
nullptr
;
}
if
(
isAsmJSModule
(
)
)
{
RefPtr
<
const
JS
:
:
WasmModule
>
asmJS
=
compilationInfo_
.
asmJS
.
lookup
(
FunctionIndex
(
index
(
)
)
)
-
>
value
(
)
;
JSObject
*
moduleObj
=
asmJS
-
>
createObjectForAsmJS
(
cx
)
;
if
(
!
moduleObj
)
{
return
nullptr
;
}
fun
-
>
setExtendedSlot
(
FunctionExtended
:
:
ASMJS_MODULE_SLOT
ObjectValue
(
*
moduleObj
)
)
;
}
return
fun
;
}
bool
FunctionBox
:
:
hasFunction
(
)
const
{
return
compilationInfo_
.
functions
[
funcDataIndex_
]
!
=
nullptr
;
}
void
FunctionBox
:
:
initFromLazyFunction
(
JSFunction
*
fun
)
{
BaseScript
*
lazy
=
fun
-
>
baseScript
(
)
;
immutableFlags_
=
lazy
-
>
immutableFlags
(
)
;
extent
=
lazy
-
>
extent
(
)
;
}
void
FunctionBox
:
:
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionFlags
flags
FunctionSyntaxKind
kind
)
{
SharedContext
*
sc
=
enclosing
-
>
sc
(
)
;
useAsm
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
setHasModuleGoal
(
sc
-
>
hasModuleGoal
(
)
)
;
if
(
flags
.
isArrow
(
)
)
{
allowNewTarget_
=
sc
-
>
allowNewTarget
(
)
;
allowSuperProperty_
=
sc
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
sc
-
>
allowSuperCall
(
)
;
allowArguments_
=
sc
-
>
allowArguments
(
)
;
thisBinding_
=
sc
-
>
thisBinding
(
)
;
}
else
{
if
(
IsConstructorKind
(
kind
)
)
{
auto
stmt
=
enclosing
-
>
findInnermostStatement
<
ParseContext
:
:
ClassStatement
>
(
)
;
MOZ_ASSERT
(
stmt
)
;
stmt
-
>
constructorBox
=
this
;
}
allowNewTarget_
=
true
;
allowSuperProperty_
=
flags
.
allowSuperProperty
(
)
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
thisBinding_
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding_
=
ThisBinding
:
:
Function
;
}
if
(
kind
=
=
FunctionSyntaxKind
:
:
FieldInitializer
)
{
setFieldInitializer
(
)
;
allowArguments_
=
false
;
}
}
if
(
sc
-
>
inWith
(
)
)
{
inWith_
=
true
;
}
else
{
auto
isWith
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
With
;
}
;
inWith_
=
enclosing
-
>
findInnermostStatement
(
isWith
)
;
}
if
(
sc
-
>
inClass
(
)
)
{
inClass_
=
true
;
}
else
{
auto
isClass
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
Class
;
}
;
inClass_
=
enclosing
-
>
findInnermostStatement
(
isClass
)
;
}
}
void
FunctionBox
:
:
initWithEnclosingScope
(
ScopeContext
&
scopeContext
Scope
*
enclosingScope
FunctionFlags
flags
FunctionSyntaxKind
kind
)
{
MOZ_ASSERT
(
enclosingScope
)
;
enclosingScope_
=
AbstractScopePtr
(
enclosingScope
)
;
if
(
flags
.
isArrow
(
)
)
{
allowNewTarget_
=
scopeContext
.
allowNewTarget
;
allowSuperProperty_
=
scopeContext
.
allowSuperProperty
;
allowSuperCall_
=
scopeContext
.
allowSuperCall
;
allowArguments_
=
scopeContext
.
allowArguments
;
thisBinding_
=
scopeContext
.
thisBinding
;
}
else
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
flags
.
allowSuperProperty
(
)
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
thisBinding_
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding_
=
ThisBinding
:
:
Function
;
}
if
(
kind
=
=
FunctionSyntaxKind
:
:
FieldInitializer
)
{
setFieldInitializer
(
)
;
allowArguments_
=
false
;
}
}
inWith_
=
scopeContext
.
inWith
;
inClass_
=
scopeContext
.
inClass
;
}
void
FunctionBox
:
:
setEnclosingScopeForInnerLazyFunction
(
const
AbstractScopePtr
&
enclosingScope
)
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
enclosingScope_
=
enclosingScope
;
}
bool
FunctionBox
:
:
setAsmJSModule
(
const
JS
:
:
WasmModule
*
module
)
{
isAsmJSModule_
=
true
;
MOZ_ASSERT
(
!
hasFunction
(
)
)
;
MOZ_ASSERT
(
flags_
.
kind
(
)
=
=
FunctionFlags
:
:
NormalFunction
)
;
flags_
.
clearBaseScript
(
)
;
flags_
.
setIsExtended
(
)
;
flags_
.
setKind
(
FunctionFlags
:
:
AsmJS
)
;
return
compilationInfo_
.
asmJS
.
putNew
(
FunctionIndex
(
index
(
)
)
module
)
;
}
void
FunctionBox
:
:
finish
(
)
{
if
(
emitBytecode
|
|
isAsmJSModule
(
)
)
{
MOZ_ASSERT
(
!
enclosingScope_
)
;
}
else
{
BaseScript
*
script
=
function
(
)
-
>
baseScript
(
)
;
script
-
>
setEnclosingScope
(
enclosingScope_
.
getExistingScope
(
)
)
;
script
-
>
initTreatAsRunOnce
(
treatAsRunOnce
(
)
)
;
if
(
fieldInitializers
)
{
script
-
>
setFieldInitializers
(
*
fieldInitializers
)
;
}
}
if
(
function
(
)
-
>
displayAtom
(
)
=
=
nullptr
)
{
if
(
hasInferredName
(
)
)
{
function
(
)
-
>
setInferredName
(
atom_
)
;
}
if
(
hasGuessedAtom
(
)
)
{
function
(
)
-
>
setGuessedAtom
(
atom_
)
;
}
}
}
void
FunctionBox
:
:
TraceList
(
JSTracer
*
trc
FunctionBox
*
listHead
)
{
for
(
FunctionBox
*
node
=
listHead
;
node
;
node
=
node
-
>
traceLink_
)
{
node
-
>
trace
(
trc
)
;
}
}
void
FunctionBox
:
:
trace
(
JSTracer
*
trc
)
{
if
(
enclosingScope_
)
{
enclosingScope_
.
trace
(
trc
)
;
}
if
(
atom_
)
{
TraceRoot
(
trc
&
atom_
"
funbox
-
atom
"
)
;
}
}
JSFunction
*
FunctionBox
:
:
function
(
)
const
{
return
compilationInfo_
.
functions
[
funcDataIndex_
]
;
}
void
FunctionBox
:
:
clobberFunction
(
JSFunction
*
function
)
{
compilationInfo_
.
functions
[
funcDataIndex_
]
.
set
(
function
)
;
setIsInterpreted
(
function
-
>
isInterpreted
(
)
)
;
}
ModuleSharedContext
:
:
ModuleSharedContext
(
JSContext
*
cx
ModuleObject
*
module
CompilationInfo
&
compilationInfo
Scope
*
enclosingScope
ModuleBuilder
&
builder
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Module
compilationInfo
Directives
(
true
)
extent
)
module_
(
cx
module
)
enclosingScope_
(
cx
enclosingScope
)
bindings
(
cx
)
builder
(
builder
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
setFlag
(
ImmutableFlags
:
:
HasModuleGoal
)
;
}
MutableHandle
<
ScriptStencil
>
FunctionBox
:
:
functionStencil
(
)
const
{
if
(
isTopLevel_
=
=
TopLevelFunction
:
:
Yes
)
{
return
&
compilationInfo_
.
topLevel
;
}
return
compilationInfo_
.
funcData
[
funcDataIndex_
]
;
}
}
}
