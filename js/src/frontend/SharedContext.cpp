#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
FunctionSyntaxKind
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
vm
/
FunctionFlags
.
h
"
#
include
"
vm
/
GeneratorAndAsyncKind
.
h
"
#
include
"
vm
/
StencilEnums
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
frontend
/
ParseContext
-
inl
.
h
"
#
include
"
vm
/
EnvironmentObject
-
inl
.
h
"
namespace
js
{
namespace
frontend
{
SharedContext
:
:
SharedContext
(
JSContext
*
cx
Kind
kind
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
cx_
(
cx
)
compilationInfo_
(
compilationInfo
)
extent_
(
extent
)
allowNewTarget_
(
false
)
allowSuperProperty_
(
false
)
allowSuperCall_
(
false
)
allowArguments_
(
true
)
inWith_
(
false
)
inClass_
(
false
)
localStrict
(
false
)
hasExplicitUseStrict_
(
false
)
isScriptFieldCopiedToStencil
(
false
)
{
if
(
kind
=
=
Kind
:
:
FunctionBox
)
{
setFlag
(
ImmutableFlags
:
:
IsFunction
)
;
}
else
if
(
kind
=
=
Kind
:
:
Module
)
{
MOZ_ASSERT
(
!
compilationInfo
.
options
.
nonSyntacticScope
)
;
setFlag
(
ImmutableFlags
:
:
IsModule
)
;
}
else
if
(
kind
=
=
Kind
:
:
Eval
)
{
setFlag
(
ImmutableFlags
:
:
IsForEval
)
;
}
else
{
MOZ_ASSERT
(
kind
=
=
Kind
:
:
Global
)
;
}
const
JS
:
:
ReadOnlyCompileOptions
&
options
=
compilationInfo
.
options
;
setFlag
(
ImmutableFlags
:
:
SelfHosted
options
.
selfHostingMode
)
;
setFlag
(
ImmutableFlags
:
:
ForceStrict
options
.
forceStrictMode
(
)
)
;
setFlag
(
ImmutableFlags
:
:
HasNonSyntacticScope
options
.
nonSyntacticScope
)
;
if
(
isTopLevelContext
(
)
)
{
setFlag
(
ImmutableFlags
:
:
TreatAsRunOnce
options
.
isRunOnce
)
;
setFlag
(
ImmutableFlags
:
:
NoScriptRval
options
.
noScriptRval
)
;
}
setFlag
(
ImmutableFlags
:
:
Strict
directives
.
strict
(
)
)
;
}
void
ScopeContext
:
:
computeAllowSyntax
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
FunctionScope
*
funScope
=
&
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funScope
-
>
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
allowNewTarget
=
true
;
allowSuperProperty
=
fun
-
>
allowSuperProperty
(
)
;
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
allowSuperCall
=
true
;
}
if
(
fun
-
>
isFieldInitializer
(
)
)
{
allowArguments
=
false
;
}
return
;
}
}
}
void
ScopeContext
:
:
computeThisBinding
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Module
)
{
thisBinding
=
ThisBinding
:
:
Module
;
return
;
}
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
Function
)
{
JSFunction
*
fun
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isDerivedClassConstructor
(
)
)
{
thisBinding
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding
=
ThisBinding
:
:
Function
;
}
return
;
}
}
thisBinding
=
ThisBinding
:
:
Global
;
}
void
ScopeContext
:
:
computeInWith
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
inWith
=
true
;
break
;
}
}
}
void
ScopeContext
:
:
computeInClass
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
kind
(
)
=
=
ScopeKind
:
:
ClassBody
)
{
inClass
=
true
;
break
;
}
}
}
void
ScopeContext
:
:
computeExternalInitializers
(
Scope
*
scope
)
{
for
(
ScopeIter
si
(
scope
)
;
si
;
si
+
+
)
{
if
(
si
.
scope
(
)
-
>
is
<
FunctionScope
>
(
)
)
{
FunctionScope
&
funcScope
=
si
.
scope
(
)
-
>
as
<
FunctionScope
>
(
)
;
JSFunction
*
fun
=
funcScope
.
canonicalFunction
(
)
;
if
(
fun
-
>
isArrow
(
)
)
{
continue
;
}
if
(
fun
-
>
isClassConstructor
(
)
)
{
memberInitializers
=
mozilla
:
:
Some
(
fun
-
>
baseScript
(
)
-
>
getMemberInitializers
(
)
)
;
MOZ_ASSERT
(
memberInitializers
-
>
valid
)
;
}
break
;
}
}
}
Scope
*
ScopeContext
:
:
determineEffectiveScope
(
Scope
*
scope
JSObject
*
environment
)
{
if
(
environment
&
&
scope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
{
JSObject
*
env
=
environment
;
while
(
env
)
{
JSObject
*
unwrapped
=
env
;
if
(
env
-
>
is
<
DebugEnvironmentProxy
>
(
)
)
{
unwrapped
=
&
env
-
>
as
<
DebugEnvironmentProxy
>
(
)
.
environment
(
)
;
}
if
(
unwrapped
-
>
is
<
CallObject
>
(
)
)
{
JSFunction
*
callee
=
&
unwrapped
-
>
as
<
CallObject
>
(
)
.
callee
(
)
;
return
callee
-
>
nonLazyScript
(
)
-
>
bodyScope
(
)
;
}
env
=
env
-
>
enclosingEnvironment
(
)
;
}
}
return
scope
;
}
EvalSharedContext
:
:
EvalSharedContext
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
Directives
directives
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Eval
compilationInfo
directives
extent
)
bindings
(
nullptr
)
{
allowNewTarget_
=
compilationInfo
.
scopeContext
.
allowNewTarget
;
allowSuperProperty_
=
compilationInfo
.
scopeContext
.
allowSuperProperty
;
allowSuperCall_
=
compilationInfo
.
scopeContext
.
allowSuperCall
;
allowArguments_
=
compilationInfo
.
scopeContext
.
allowArguments
;
thisBinding_
=
compilationInfo
.
scopeContext
.
thisBinding
;
inWith_
=
compilationInfo
.
scopeContext
.
inWith
;
}
#
ifdef
DEBUG
bool
FunctionBox
:
:
atomsAreKept
(
)
{
return
cx_
-
>
zone
(
)
-
>
hasKeptAtoms
(
)
;
}
#
endif
FunctionBox
:
:
FunctionBox
(
JSContext
*
cx
FunctionBox
*
traceListHead
SourceExtent
extent
CompilationInfo
&
compilationInfo
Directives
directives
GeneratorKind
generatorKind
FunctionAsyncKind
asyncKind
const
ParserAtom
*
atom
FunctionFlags
flags
FunctionIndex
index
TopLevelFunction
isTopLevel
)
:
SharedContext
(
cx
Kind
:
:
FunctionBox
compilationInfo
directives
extent
)
traceLink_
(
traceListHead
)
atom_
(
atom
)
funcDataIndex_
(
index
)
flags_
(
flags
)
isTopLevel_
(
isTopLevel
)
emitBytecode
(
false
)
isStandalone_
(
false
)
wasEmitted_
(
false
)
isSingleton_
(
false
)
isAnnexB
(
false
)
useAsm
(
false
)
hasParameterExprs
(
false
)
hasDestructuringArgs
(
false
)
hasDuplicateParameters
(
false
)
hasExprBody_
(
false
)
usesApply
(
false
)
usesThis
(
false
)
usesReturn
(
false
)
isFunctionFieldCopiedToStencil
(
false
)
{
setFlag
(
ImmutableFlags
:
:
IsGenerator
generatorKind
=
=
GeneratorKind
:
:
Generator
)
;
setFlag
(
ImmutableFlags
:
:
IsAsync
asyncKind
=
=
FunctionAsyncKind
:
:
AsyncFunction
)
;
}
void
FunctionBox
:
:
initFromLazyFunction
(
JSFunction
*
fun
)
{
BaseScript
*
lazy
=
fun
-
>
baseScript
(
)
;
immutableFlags_
=
lazy
-
>
immutableFlags
(
)
;
extent_
=
lazy
-
>
extent
(
)
;
}
void
FunctionBox
:
:
initWithEnclosingParseContext
(
ParseContext
*
enclosing
FunctionFlags
flags
FunctionSyntaxKind
kind
)
{
SharedContext
*
sc
=
enclosing
-
>
sc
(
)
;
useAsm
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
useAsmOrInsideUseAsm
(
)
;
setHasModuleGoal
(
sc
-
>
hasModuleGoal
(
)
)
;
if
(
flags
.
isArrow
(
)
)
{
allowNewTarget_
=
sc
-
>
allowNewTarget
(
)
;
allowSuperProperty_
=
sc
-
>
allowSuperProperty
(
)
;
allowSuperCall_
=
sc
-
>
allowSuperCall
(
)
;
allowArguments_
=
sc
-
>
allowArguments
(
)
;
thisBinding_
=
sc
-
>
thisBinding
(
)
;
}
else
{
if
(
IsConstructorKind
(
kind
)
)
{
auto
stmt
=
enclosing
-
>
findInnermostStatement
<
ParseContext
:
:
ClassStatement
>
(
)
;
MOZ_ASSERT
(
stmt
)
;
stmt
-
>
constructorBox
=
this
;
}
allowNewTarget_
=
true
;
allowSuperProperty_
=
flags
.
allowSuperProperty
(
)
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
thisBinding_
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding_
=
ThisBinding
:
:
Function
;
}
if
(
kind
=
=
FunctionSyntaxKind
:
:
FieldInitializer
)
{
setFieldInitializer
(
)
;
allowArguments_
=
false
;
}
}
if
(
sc
-
>
inWith
(
)
)
{
inWith_
=
true
;
}
else
{
auto
isWith
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
With
;
}
;
inWith_
=
enclosing
-
>
findInnermostStatement
(
isWith
)
;
}
if
(
sc
-
>
inClass
(
)
)
{
inClass_
=
true
;
}
else
{
auto
isClass
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
stmt
-
>
kind
(
)
=
=
StatementKind
:
:
Class
;
}
;
inClass_
=
enclosing
-
>
findInnermostStatement
(
isClass
)
;
}
}
void
FunctionBox
:
:
initStandalone
(
ScopeContext
&
scopeContext
FunctionFlags
flags
FunctionSyntaxKind
kind
)
{
if
(
flags
.
isArrow
(
)
)
{
allowNewTarget_
=
scopeContext
.
allowNewTarget
;
allowSuperProperty_
=
scopeContext
.
allowSuperProperty
;
allowSuperCall_
=
scopeContext
.
allowSuperCall
;
allowArguments_
=
scopeContext
.
allowArguments
;
thisBinding_
=
scopeContext
.
thisBinding
;
}
else
{
allowNewTarget_
=
true
;
allowSuperProperty_
=
flags
.
allowSuperProperty
(
)
;
if
(
kind
=
=
FunctionSyntaxKind
:
:
DerivedClassConstructor
)
{
setDerivedClassConstructor
(
)
;
allowSuperCall_
=
true
;
thisBinding_
=
ThisBinding
:
:
DerivedConstructor
;
}
else
{
thisBinding_
=
ThisBinding
:
:
Function
;
}
if
(
kind
=
=
FunctionSyntaxKind
:
:
FieldInitializer
)
{
setFieldInitializer
(
)
;
allowArguments_
=
false
;
}
}
inWith_
=
scopeContext
.
inWith
;
inClass_
=
scopeContext
.
inClass
;
}
void
FunctionBox
:
:
setEnclosingScopeForInnerLazyFunction
(
ScopeIndex
scopeIndex
)
{
MOZ_ASSERT
(
enclosingScopeIndex_
.
isNothing
(
)
)
;
enclosingScopeIndex_
=
mozilla
:
:
Some
(
scopeIndex
)
;
if
(
isFunctionFieldCopiedToStencil
)
{
copyUpdatedEnclosingScopeIndex
(
)
;
}
}
bool
FunctionBox
:
:
setAsmJSModule
(
const
JS
:
:
WasmModule
*
module
)
{
MOZ_ASSERT
(
!
isFunctionFieldCopiedToStencil
)
;
MOZ_ASSERT
(
flags_
.
kind
(
)
=
=
FunctionFlags
:
:
NormalFunction
)
;
flags_
.
clearBaseScript
(
)
;
flags_
.
setIsExtended
(
)
;
flags_
.
setKind
(
FunctionFlags
:
:
AsmJS
)
;
return
compilationInfo_
.
asmJS
.
putNew
(
index
(
)
module
)
;
}
void
FunctionBox
:
:
TraceList
(
JSTracer
*
trc
FunctionBox
*
listHead
)
{
for
(
FunctionBox
*
node
=
listHead
;
node
;
node
=
node
-
>
traceLink_
)
{
node
-
>
trace
(
trc
)
;
}
}
void
FunctionBox
:
:
trace
(
JSTracer
*
trc
)
{
}
ModuleSharedContext
:
:
ModuleSharedContext
(
JSContext
*
cx
CompilationInfo
&
compilationInfo
ModuleBuilder
&
builder
SourceExtent
extent
)
:
SharedContext
(
cx
Kind
:
:
Module
compilationInfo
Directives
(
true
)
extent
)
bindings
(
nullptr
)
builder
(
builder
)
{
thisBinding_
=
ThisBinding
:
:
Module
;
setFlag
(
ImmutableFlags
:
:
HasModuleGoal
)
;
}
MutableHandle
<
ScriptStencil
>
FunctionBox
:
:
functionStencil
(
)
const
{
if
(
isTopLevel_
=
=
TopLevelFunction
:
:
Yes
)
{
return
&
compilationInfo_
.
topLevel
;
}
return
compilationInfo_
.
funcData
[
funcDataIndex_
]
;
}
void
SharedContext
:
:
copyScriptFields
(
ScriptStencil
&
stencil
)
{
MOZ_ASSERT
(
!
isScriptFieldCopiedToStencil
)
;
stencil
.
immutableFlags
=
immutableFlags_
;
stencil
.
extent
=
extent_
;
isScriptFieldCopiedToStencil
=
true
;
}
void
FunctionBox
:
:
finishScriptFlags
(
)
{
MOZ_ASSERT
(
!
isScriptFieldCopiedToStencil
)
;
using
ImmutableFlags
=
ImmutableScriptFlagsEnum
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
HasMappedArgsObj
hasMappedArgsObj
(
)
)
;
immutableFlags_
.
setFlag
(
ImmutableFlags
:
:
IsLikelyConstructorWrapper
isLikelyConstructorWrapper
(
)
)
;
}
void
FunctionBox
:
:
copyScriptFields
(
ScriptStencil
&
stencil
)
{
MOZ_ASSERT
(
&
stencil
=
=
&
functionStencil
(
)
.
get
(
)
)
;
MOZ_ASSERT
(
!
isAsmJSModule
(
)
)
;
SharedContext
:
:
copyScriptFields
(
stencil
)
;
stencil
.
memberInitializers
=
memberInitializers_
;
isScriptFieldCopiedToStencil
=
true
;
}
void
FunctionBox
:
:
copyFunctionFields
(
ScriptStencil
&
stencil
)
{
MOZ_ASSERT
(
&
stencil
=
=
&
functionStencil
(
)
.
get
(
)
)
;
MOZ_ASSERT
(
!
isFunctionFieldCopiedToStencil
)
;
stencil
.
functionAtom
=
atom_
;
stencil
.
functionFlags
=
flags_
;
stencil
.
nargs
=
nargs_
;
stencil
.
lazyFunctionEnclosingScopeIndex_
=
enclosingScopeIndex_
;
stencil
.
isStandaloneFunction
=
isStandalone_
;
stencil
.
wasFunctionEmitted
=
wasEmitted_
;
stencil
.
isSingletonFunction
=
isSingleton_
;
isFunctionFieldCopiedToStencil
=
true
;
}
void
FunctionBox
:
:
copyUpdatedImmutableFlags
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
immutableFlags
=
immutableFlags_
;
}
void
FunctionBox
:
:
copyUpdatedExtent
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
extent
=
extent_
;
}
void
FunctionBox
:
:
copyUpdatedMemberInitializers
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
memberInitializers
=
memberInitializers_
;
}
void
FunctionBox
:
:
copyUpdatedEnclosingScopeIndex
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
lazyFunctionEnclosingScopeIndex_
=
enclosingScopeIndex_
;
}
void
FunctionBox
:
:
copyUpdatedAtomAndFlags
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
functionAtom
=
atom_
;
stencil
.
functionFlags
=
flags_
;
}
void
FunctionBox
:
:
copyUpdatedWasEmitted
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
wasFunctionEmitted
=
wasEmitted_
;
}
void
FunctionBox
:
:
copyUpdatedIsSingleton
(
)
{
ScriptStencil
&
stencil
=
functionStencil
(
)
.
get
(
)
;
stencil
.
isSingletonFunction
=
isSingleton_
;
}
}
}
